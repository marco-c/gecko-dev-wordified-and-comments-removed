#
include
"
SurfacePipe
.
h
"
#
include
<
algorithm
>
#
include
"
Decoder
.
h
"
namespace
mozilla
{
namespace
image
{
using
namespace
gfx
;
using
std
:
:
min
;
Maybe
<
SurfaceInvalidRect
>
AbstractSurfaceSink
:
:
TakeInvalidRect
(
)
{
if
(
mInvalidRect
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
SurfaceInvalidRect
invalidRect
;
invalidRect
.
mInputSpaceRect
=
invalidRect
.
mOutputSpaceRect
=
mInvalidRect
;
mInvalidRect
=
IntRect
(
)
;
return
Some
(
invalidRect
)
;
}
uint8_t
*
AbstractSurfaceSink
:
:
DoResetToFirstRow
(
)
{
mRow
=
0
;
return
GetRowPointer
(
)
;
}
uint8_t
*
AbstractSurfaceSink
:
:
DoAdvanceRow
(
)
{
if
(
mRow
>
=
uint32_t
(
InputSize
(
)
.
height
)
)
{
return
nullptr
;
}
int32_t
invalidY
=
mFlipVertically
?
InputSize
(
)
.
height
-
(
mRow
+
1
)
:
mRow
;
mInvalidRect
.
UnionRect
(
mInvalidRect
IntRect
(
0
invalidY
InputSize
(
)
.
width
1
)
)
;
mRow
=
min
(
uint32_t
(
InputSize
(
)
.
height
)
mRow
+
1
)
;
return
mRow
<
uint32_t
(
InputSize
(
)
.
height
)
?
GetRowPointer
(
)
:
nullptr
;
}
nsresult
SurfaceSink
:
:
Configure
(
const
SurfaceConfig
&
aConfig
)
{
IntSize
surfaceSize
=
aConfig
.
mOutputSize
;
IntRect
frameRect
(
0
0
surfaceSize
.
width
surfaceSize
.
height
)
;
nsresult
rv
=
aConfig
.
mDecoder
-
>
AllocateFrame
(
aConfig
.
mFrameNum
surfaceSize
frameRect
aConfig
.
mFormat
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mImageData
=
aConfig
.
mDecoder
-
>
mImageData
;
mImageDataLength
=
aConfig
.
mDecoder
-
>
mImageDataLength
;
mFlipVertically
=
aConfig
.
mFlipVertically
;
MOZ_ASSERT
(
mImageData
)
;
MOZ_ASSERT
(
mImageDataLength
=
=
uint32_t
(
surfaceSize
.
width
*
surfaceSize
.
height
*
sizeof
(
uint32_t
)
)
)
;
ConfigureFilter
(
surfaceSize
sizeof
(
uint32_t
)
)
;
return
NS_OK
;
}
uint8_t
*
SurfaceSink
:
:
GetRowPointer
(
)
const
{
uint32_t
row
=
mFlipVertically
?
InputSize
(
)
.
height
-
(
mRow
+
1
)
:
mRow
;
uint8_t
*
rowPtr
=
mImageData
+
row
*
InputSize
(
)
.
width
*
sizeof
(
uint32_t
)
;
MOZ_ASSERT
(
rowPtr
>
=
mImageData
)
;
MOZ_ASSERT
(
rowPtr
<
mImageData
+
mImageDataLength
)
;
MOZ_ASSERT
(
rowPtr
+
InputSize
(
)
.
width
*
sizeof
(
uint32_t
)
<
=
mImageData
+
mImageDataLength
)
;
return
rowPtr
;
}
nsresult
PalettedSurfaceSink
:
:
Configure
(
const
PalettedSurfaceConfig
&
aConfig
)
{
MOZ_ASSERT
(
aConfig
.
mFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
)
;
IntSize
surfaceSize
=
aConfig
.
mFrameRect
.
Size
(
)
;
nsresult
rv
=
aConfig
.
mDecoder
-
>
AllocateFrame
(
aConfig
.
mFrameNum
aConfig
.
mOutputSize
aConfig
.
mFrameRect
aConfig
.
mFormat
aConfig
.
mPaletteDepth
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mImageData
=
aConfig
.
mDecoder
-
>
mImageData
;
mImageDataLength
=
aConfig
.
mDecoder
-
>
mImageDataLength
;
mFlipVertically
=
aConfig
.
mFlipVertically
;
mFrameRect
=
aConfig
.
mFrameRect
;
MOZ_ASSERT
(
mImageData
)
;
MOZ_ASSERT
(
mImageDataLength
=
=
uint32_t
(
mFrameRect
.
Width
(
)
*
mFrameRect
.
Height
(
)
*
sizeof
(
uint8_t
)
)
)
;
ConfigureFilter
(
surfaceSize
sizeof
(
uint8_t
)
)
;
return
NS_OK
;
}
uint8_t
*
PalettedSurfaceSink
:
:
GetRowPointer
(
)
const
{
uint32_t
row
=
mFlipVertically
?
InputSize
(
)
.
height
-
(
mRow
+
1
)
:
mRow
;
uint8_t
*
rowPtr
=
mImageData
+
row
*
InputSize
(
)
.
width
*
sizeof
(
uint8_t
)
;
MOZ_ASSERT
(
rowPtr
>
=
mImageData
)
;
MOZ_ASSERT
(
rowPtr
<
mImageData
+
mImageDataLength
)
;
MOZ_ASSERT
(
rowPtr
+
InputSize
(
)
.
width
*
sizeof
(
uint8_t
)
<
=
mImageData
+
mImageDataLength
)
;
return
rowPtr
;
}
}
}
