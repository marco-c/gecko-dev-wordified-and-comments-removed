#
include
"
SurfacePipe
.
h
"
#
include
<
utility
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
Decoder
.
h
"
namespace
mozilla
{
namespace
image
{
using
namespace
gfx
;
using
std
:
:
min
;
UniquePtr
<
NullSurfaceSink
>
NullSurfaceSink
:
:
sSingleton
;
NullSurfaceSink
*
NullSurfaceSink
:
:
Singleton
(
)
{
if
(
!
sSingleton
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sSingleton
=
MakeUnique
<
NullSurfaceSink
>
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
DebugOnly
<
nsresult
>
rv
=
sSingleton
-
>
Configure
(
NullSurfaceConfig
{
}
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Couldn
'
t
configure
a
NullSurfaceSink
?
"
)
;
}
return
sSingleton
.
get
(
)
;
}
nsresult
NullSurfaceSink
:
:
Configure
(
const
NullSurfaceConfig
&
aConfig
)
{
ConfigureFilter
(
IntSize
(
)
sizeof
(
uint32_t
)
)
;
return
NS_OK
;
}
Maybe
<
SurfaceInvalidRect
>
AbstractSurfaceSink
:
:
TakeInvalidRect
(
)
{
if
(
mInvalidRect
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
SurfaceInvalidRect
invalidRect
;
invalidRect
.
mInputSpaceRect
=
invalidRect
.
mOutputSpaceRect
=
mInvalidRect
;
mInvalidRect
=
IntRect
(
)
;
return
Some
(
invalidRect
)
;
}
void
AbstractSurfaceSink
:
:
DoZeroOutRestOfSurface
(
)
{
if
(
!
mClearRequired
)
{
return
;
}
const
int32_t
width
=
InputSize
(
)
.
width
;
const
int32_t
height
=
InputSize
(
)
.
height
;
const
int32_t
pixelSize
=
IsValidPalettedPipe
(
)
?
sizeof
(
uint8_t
)
:
sizeof
(
uint32_t
)
;
const
int32_t
stride
=
width
*
pixelSize
;
const
int32_t
col
=
CurrentColumn
(
)
;
if
(
MOZ_UNLIKELY
(
col
>
0
&
&
col
<
=
width
)
)
{
uint8_t
*
rowPtr
=
CurrentRowPointer
(
)
;
MOZ_ASSERT
(
rowPtr
)
;
memset
(
rowPtr
+
col
*
pixelSize
mClearValue
(
width
-
col
)
*
pixelSize
)
;
AdvanceRow
(
)
;
}
MOZ_ASSERT
(
mWrittenRect
.
x
=
=
0
)
;
MOZ_ASSERT
(
mWrittenRect
.
width
=
=
0
|
|
mWrittenRect
.
width
=
=
width
)
;
if
(
MOZ_UNLIKELY
(
mWrittenRect
.
y
>
0
)
)
{
const
uint32_t
length
=
mWrittenRect
.
y
*
stride
;
auto
updateRect
=
IntRect
(
0
0
width
mWrittenRect
.
y
)
;
MOZ_ASSERT
(
mImageDataLength
>
=
length
)
;
memset
(
mImageData
mClearValue
length
)
;
mInvalidRect
.
UnionRect
(
mInvalidRect
updateRect
)
;
mWrittenRect
.
UnionRect
(
mWrittenRect
updateRect
)
;
}
const
int32_t
top
=
mWrittenRect
.
y
+
mWrittenRect
.
height
;
if
(
MOZ_UNLIKELY
(
top
<
height
)
)
{
const
int32_t
remainder
=
height
-
top
;
auto
updateRect
=
IntRect
(
0
top
width
remainder
)
;
MOZ_ASSERT
(
mImageDataLength
>
=
(
uint32_t
)
(
height
*
stride
)
)
;
memset
(
mImageData
+
top
*
stride
mClearValue
remainder
*
stride
)
;
mInvalidRect
.
UnionRect
(
mInvalidRect
updateRect
)
;
mWrittenRect
.
UnionRect
(
mWrittenRect
updateRect
)
;
}
}
uint8_t
*
AbstractSurfaceSink
:
:
DoResetToFirstRow
(
)
{
mRow
=
0
;
return
GetRowPointer
(
)
;
}
uint8_t
*
AbstractSurfaceSink
:
:
DoAdvanceRow
(
)
{
if
(
mRow
>
=
uint32_t
(
InputSize
(
)
.
height
)
)
{
return
nullptr
;
}
int32_t
invalidY
=
mFlipVertically
?
InputSize
(
)
.
height
-
(
mRow
+
1
)
:
mRow
;
mInvalidRect
.
UnionRect
(
mInvalidRect
IntRect
(
0
invalidY
InputSize
(
)
.
width
1
)
)
;
mWrittenRect
.
UnionRect
(
mWrittenRect
mInvalidRect
)
;
mRow
=
min
(
uint32_t
(
InputSize
(
)
.
height
)
mRow
+
1
)
;
return
mRow
<
uint32_t
(
InputSize
(
)
.
height
)
?
GetRowPointer
(
)
:
nullptr
;
}
nsresult
SurfaceSink
:
:
Configure
(
const
SurfaceConfig
&
aConfig
)
{
IntSize
surfaceSize
=
aConfig
.
mOutputSize
;
IntRect
frameRect
(
0
0
surfaceSize
.
width
surfaceSize
.
height
)
;
nsresult
rv
=
aConfig
.
mDecoder
-
>
AllocateFrame
(
aConfig
.
mFrameNum
surfaceSize
frameRect
aConfig
.
mFormat
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mImageData
=
aConfig
.
mDecoder
-
>
mImageData
;
mImageDataLength
=
aConfig
.
mDecoder
-
>
mImageDataLength
;
mFlipVertically
=
aConfig
.
mFlipVertically
;
if
(
aConfig
.
mFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
)
{
mClearRequired
=
true
;
mClearValue
=
0xFF
;
}
else
if
(
aConfig
.
mDecoder
-
>
mCurrentFrame
-
>
OnHeap
(
)
)
{
mClearRequired
=
true
;
mClearValue
=
0
;
}
MOZ_ASSERT
(
mImageData
)
;
MOZ_ASSERT
(
mImageDataLength
=
=
uint32_t
(
surfaceSize
.
width
*
surfaceSize
.
height
*
sizeof
(
uint32_t
)
)
)
;
ConfigureFilter
(
surfaceSize
sizeof
(
uint32_t
)
)
;
return
NS_OK
;
}
uint8_t
*
SurfaceSink
:
:
GetRowPointer
(
)
const
{
uint32_t
row
=
mFlipVertically
?
InputSize
(
)
.
height
-
(
mRow
+
1
)
:
mRow
;
uint8_t
*
rowPtr
=
mImageData
+
row
*
InputSize
(
)
.
width
*
sizeof
(
uint32_t
)
;
MOZ_ASSERT
(
rowPtr
>
=
mImageData
)
;
MOZ_ASSERT
(
rowPtr
<
mImageData
+
mImageDataLength
)
;
MOZ_ASSERT
(
rowPtr
+
InputSize
(
)
.
width
*
sizeof
(
uint32_t
)
<
=
mImageData
+
mImageDataLength
)
;
return
rowPtr
;
}
nsresult
PalettedSurfaceSink
:
:
Configure
(
const
PalettedSurfaceConfig
&
aConfig
)
{
MOZ_ASSERT
(
aConfig
.
mFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
)
;
MOZ_ASSERT
(
mClearValue
=
=
0
)
;
IntSize
surfaceSize
=
aConfig
.
mFrameRect
.
Size
(
)
;
nsresult
rv
=
aConfig
.
mDecoder
-
>
AllocateFrame
(
aConfig
.
mFrameNum
aConfig
.
mOutputSize
aConfig
.
mFrameRect
aConfig
.
mFormat
aConfig
.
mPaletteDepth
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mImageData
=
aConfig
.
mDecoder
-
>
mImageData
;
mImageDataLength
=
aConfig
.
mDecoder
-
>
mImageDataLength
;
mFlipVertically
=
aConfig
.
mFlipVertically
;
mFrameRect
=
aConfig
.
mFrameRect
;
mClearRequired
=
true
;
MOZ_ASSERT
(
mImageData
)
;
MOZ_ASSERT
(
mImageDataLength
=
=
uint32_t
(
mFrameRect
.
width
*
mFrameRect
.
height
*
sizeof
(
uint8_t
)
)
)
;
ConfigureFilter
(
surfaceSize
sizeof
(
uint8_t
)
)
;
return
NS_OK
;
}
uint8_t
*
PalettedSurfaceSink
:
:
GetRowPointer
(
)
const
{
uint32_t
row
=
mFlipVertically
?
InputSize
(
)
.
height
-
(
mRow
+
1
)
:
mRow
;
uint8_t
*
rowPtr
=
mImageData
+
row
*
InputSize
(
)
.
width
*
sizeof
(
uint8_t
)
;
MOZ_ASSERT
(
rowPtr
>
=
mImageData
)
;
MOZ_ASSERT
(
rowPtr
<
mImageData
+
mImageDataLength
)
;
MOZ_ASSERT
(
rowPtr
+
InputSize
(
)
.
width
*
sizeof
(
uint8_t
)
<
=
mImageData
+
mImageDataLength
)
;
return
rowPtr
;
}
}
}
