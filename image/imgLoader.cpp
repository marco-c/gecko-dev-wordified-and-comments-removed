#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsIChildChannel
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
undef
LoadImage
#
include
"
imgLoader
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
DecoderFactory
.
h
"
#
include
"
Image
.
h
"
#
include
"
ImageLogging
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
CacheExpirationTime
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
FetchPriority
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
image
/
ImageMemoryReporter
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsImageModule
.
h
"
#
include
"
nsMediaSniffer
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsILoadGroupChild
.
h
"
#
include
"
nsIDocShell
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
net
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
ImagesMallocSizeOf
)
class
imgMemoryReporter
final
:
public
nsIMemoryReporter
{
~
imgMemoryReporter
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
layers
:
:
CompositorManagerChild
*
manager
=
mozilla
:
:
layers
:
:
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
!
manager
|
|
!
StaticPrefs
:
:
image_mem_debug_reporting
(
)
)
{
layers
:
:
SharedSurfacesMemoryReport
sharedSurfaces
;
FinishCollectReports
(
aHandleReport
aData
aAnonymize
sharedSurfaces
)
;
return
NS_OK
;
}
RefPtr
<
imgMemoryReporter
>
self
(
this
)
;
nsCOMPtr
<
nsIHandleReportCallback
>
handleReport
(
aHandleReport
)
;
nsCOMPtr
<
nsISupports
>
data
(
aData
)
;
manager
-
>
SendReportSharedSurfacesMemory
(
[
=
]
(
layers
:
:
SharedSurfacesMemoryReport
aReport
)
{
self
-
>
FinishCollectReports
(
handleReport
data
aAnonymize
aReport
)
;
}
[
=
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
layers
:
:
SharedSurfacesMemoryReport
sharedSurfaces
;
self
-
>
FinishCollectReports
(
handleReport
data
aAnonymize
sharedSurfaces
)
;
}
)
;
return
NS_OK
;
}
void
FinishCollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
layers
:
:
SharedSurfacesMemoryReport
&
aSharedSurfaces
)
{
nsTArray
<
ImageMemoryCounter
>
chrome
;
nsTArray
<
ImageMemoryCounter
>
content
;
nsTArray
<
ImageMemoryCounter
>
uncached
;
for
(
uint32_t
i
=
0
;
i
<
mKnownLoaders
.
Length
(
)
;
i
+
+
)
{
for
(
imgCacheEntry
*
entry
:
mKnownLoaders
[
i
]
-
>
mCache
.
Values
(
)
)
{
RefPtr
<
imgRequest
>
req
=
entry
-
>
GetRequest
(
)
;
RecordCounterForRequest
(
req
&
content
!
entry
-
>
HasNoProxies
(
)
)
;
}
MutexAutoLock
lock
(
mKnownLoaders
[
i
]
-
>
mUncachedImagesMutex
)
;
for
(
RefPtr
<
imgRequest
>
req
:
mKnownLoaders
[
i
]
-
>
mUncachedImages
)
{
RecordCounterForRequest
(
req
&
uncached
req
-
>
HasConsumers
(
)
)
;
}
}
ReportCounterArray
(
aHandleReport
aData
chrome
"
images
/
chrome
"
false
aSharedSurfaces
)
;
ReportCounterArray
(
aHandleReport
aData
content
"
images
/
content
"
aAnonymize
aSharedSurfaces
)
;
ReportCounterArray
(
aHandleReport
aData
uncached
"
images
/
uncached
"
aAnonymize
aSharedSurfaces
)
;
ImageMemoryReporter
:
:
ReportSharedSurfaces
(
aHandleReport
aData
aSharedSurfaces
)
;
nsCOMPtr
<
nsIMemoryReporterManager
>
imgr
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
imgr
)
{
imgr
-
>
EndReport
(
)
;
}
}
static
int64_t
ImagesContentUsedUncompressedDistinguishedAmount
(
)
{
size_t
n
=
0
;
for
(
uint32_t
i
=
0
;
i
<
imgLoader
:
:
sMemReporter
-
>
mKnownLoaders
.
Length
(
)
;
i
+
+
)
{
for
(
imgCacheEntry
*
entry
:
imgLoader
:
:
sMemReporter
-
>
mKnownLoaders
[
i
]
-
>
mCache
.
Values
(
)
)
{
if
(
entry
-
>
HasNoProxies
(
)
)
{
continue
;
}
RefPtr
<
imgRequest
>
req
=
entry
-
>
GetRequest
(
)
;
RefPtr
<
image
:
:
Image
>
image
=
req
-
>
GetImage
(
)
;
if
(
!
image
)
{
continue
;
}
SizeOfState
state
(
moz_malloc_size_of
)
;
ImageMemoryCounter
counter
(
req
image
state
true
)
;
n
+
=
counter
.
Values
(
)
.
DecodedHeap
(
)
;
n
+
=
counter
.
Values
(
)
.
DecodedNonHeap
(
)
;
n
+
=
counter
.
Values
(
)
.
DecodedUnknown
(
)
;
}
}
return
n
;
}
void
RegisterLoader
(
imgLoader
*
aLoader
)
{
mKnownLoaders
.
AppendElement
(
aLoader
)
;
}
void
UnregisterLoader
(
imgLoader
*
aLoader
)
{
mKnownLoaders
.
RemoveElement
(
aLoader
)
;
}
private
:
nsTArray
<
imgLoader
*
>
mKnownLoaders
;
struct
MemoryTotal
{
MemoryTotal
&
operator
+
=
(
const
ImageMemoryCounter
&
aImageCounter
)
{
if
(
aImageCounter
.
Type
(
)
=
=
imgIContainer
:
:
TYPE_RASTER
)
{
if
(
aImageCounter
.
IsUsed
(
)
)
{
mUsedRasterCounter
+
=
aImageCounter
.
Values
(
)
;
}
else
{
mUnusedRasterCounter
+
=
aImageCounter
.
Values
(
)
;
}
}
else
if
(
aImageCounter
.
Type
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
if
(
aImageCounter
.
IsUsed
(
)
)
{
mUsedVectorCounter
+
=
aImageCounter
.
Values
(
)
;
}
else
{
mUnusedVectorCounter
+
=
aImageCounter
.
Values
(
)
;
}
}
else
if
(
aImageCounter
.
Type
(
)
=
=
imgIContainer
:
:
TYPE_REQUEST
)
{
}
else
{
MOZ_CRASH
(
"
Unexpected
image
type
"
)
;
}
return
*
this
;
}
const
MemoryCounter
&
UsedRaster
(
)
const
{
return
mUsedRasterCounter
;
}
const
MemoryCounter
&
UnusedRaster
(
)
const
{
return
mUnusedRasterCounter
;
}
const
MemoryCounter
&
UsedVector
(
)
const
{
return
mUsedVectorCounter
;
}
const
MemoryCounter
&
UnusedVector
(
)
const
{
return
mUnusedVectorCounter
;
}
private
:
MemoryCounter
mUsedRasterCounter
;
MemoryCounter
mUnusedRasterCounter
;
MemoryCounter
mUsedVectorCounter
;
MemoryCounter
mUnusedVectorCounter
;
}
;
void
ReportCounterArray
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
nsTArray
<
ImageMemoryCounter
>
&
aCounterArray
const
char
*
aPathPrefix
bool
aAnonymize
layers
:
:
SharedSurfacesMemoryReport
&
aSharedSurfaces
)
{
MemoryTotal
summaryTotal
;
MemoryTotal
nonNotableTotal
;
for
(
uint32_t
i
=
0
;
i
<
aCounterArray
.
Length
(
)
;
i
+
+
)
{
ImageMemoryCounter
&
counter
=
aCounterArray
[
i
]
;
if
(
aAnonymize
)
{
counter
.
URI
(
)
.
Truncate
(
)
;
counter
.
URI
(
)
.
AppendPrintf
(
"
<
anonymized
-
%
u
>
"
i
)
;
}
else
{
static
const
size_t
max
=
256
;
if
(
counter
.
URI
(
)
.
Length
(
)
>
max
)
{
counter
.
URI
(
)
.
Truncate
(
max
)
;
counter
.
URI
(
)
.
AppendLiteral
(
"
(
truncated
)
"
)
;
}
counter
.
URI
(
)
.
ReplaceChar
(
'
/
'
'
\
\
'
)
;
}
summaryTotal
+
=
counter
;
if
(
counter
.
IsNotable
(
)
|
|
StaticPrefs
:
:
image_mem_debug_reporting
(
)
)
{
ReportImage
(
aHandleReport
aData
aPathPrefix
counter
aSharedSurfaces
)
;
}
else
{
ImageMemoryReporter
:
:
TrimSharedSurfaces
(
counter
aSharedSurfaces
)
;
nonNotableTotal
+
=
counter
;
}
}
ReportTotal
(
aHandleReport
aData
true
aPathPrefix
"
<
non
-
notable
images
>
/
"
nonNotableTotal
)
;
ReportTotal
(
aHandleReport
aData
false
aPathPrefix
"
"
summaryTotal
)
;
}
static
void
ReportImage
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
char
*
aPathPrefix
const
ImageMemoryCounter
&
aCounter
layers
:
:
SharedSurfacesMemoryReport
&
aSharedSurfaces
)
{
nsAutoCString
pathPrefix
(
"
explicit
/
"
_ns
)
;
pathPrefix
.
Append
(
aPathPrefix
)
;
switch
(
aCounter
.
Type
(
)
)
{
case
imgIContainer
:
:
TYPE_RASTER
:
pathPrefix
.
AppendLiteral
(
"
/
raster
/
"
)
;
break
;
case
imgIContainer
:
:
TYPE_VECTOR
:
pathPrefix
.
AppendLiteral
(
"
/
vector
/
"
)
;
break
;
case
imgIContainer
:
:
TYPE_REQUEST
:
pathPrefix
.
AppendLiteral
(
"
/
request
/
"
)
;
break
;
default
:
pathPrefix
.
AppendLiteral
(
"
/
unknown
=
"
)
;
pathPrefix
.
AppendInt
(
aCounter
.
Type
(
)
)
;
pathPrefix
.
AppendLiteral
(
"
/
"
)
;
break
;
}
pathPrefix
.
Append
(
aCounter
.
IsUsed
(
)
?
"
used
/
"
:
"
unused
/
"
)
;
if
(
aCounter
.
IsValidating
(
)
)
{
pathPrefix
.
AppendLiteral
(
"
validating
/
"
)
;
}
if
(
aCounter
.
HasError
(
)
)
{
pathPrefix
.
AppendLiteral
(
"
err
/
"
)
;
}
pathPrefix
.
AppendLiteral
(
"
progress
=
"
)
;
pathPrefix
.
AppendInt
(
aCounter
.
Progress
(
)
16
)
;
pathPrefix
.
AppendLiteral
(
"
/
"
)
;
pathPrefix
.
AppendLiteral
(
"
image
(
"
)
;
pathPrefix
.
AppendInt
(
aCounter
.
IntrinsicSize
(
)
.
width
)
;
pathPrefix
.
AppendLiteral
(
"
x
"
)
;
pathPrefix
.
AppendInt
(
aCounter
.
IntrinsicSize
(
)
.
height
)
;
pathPrefix
.
AppendLiteral
(
"
"
)
;
if
(
aCounter
.
URI
(
)
.
IsEmpty
(
)
)
{
pathPrefix
.
AppendLiteral
(
"
<
unknown
URI
>
"
)
;
}
else
{
pathPrefix
.
Append
(
aCounter
.
URI
(
)
)
;
}
pathPrefix
.
AppendLiteral
(
"
)
/
"
)
;
ReportSurfaces
(
aHandleReport
aData
pathPrefix
aCounter
aSharedSurfaces
)
;
ReportSourceValue
(
aHandleReport
aData
pathPrefix
aCounter
.
Values
(
)
)
;
}
static
void
ReportSurfaces
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsACString
&
aPathPrefix
const
ImageMemoryCounter
&
aCounter
layers
:
:
SharedSurfacesMemoryReport
&
aSharedSurfaces
)
{
for
(
const
SurfaceMemoryCounter
&
counter
:
aCounter
.
Surfaces
(
)
)
{
nsAutoCString
surfacePathPrefix
(
aPathPrefix
)
;
switch
(
counter
.
Type
(
)
)
{
case
SurfaceMemoryCounterType
:
:
NORMAL
:
if
(
counter
.
IsLocked
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
locked
/
"
)
;
}
else
{
surfacePathPrefix
.
AppendLiteral
(
"
unlocked
/
"
)
;
}
if
(
counter
.
IsFactor2
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
factor2
/
"
)
;
}
if
(
counter
.
CannotSubstitute
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
cannot_substitute
/
"
)
;
}
break
;
case
SurfaceMemoryCounterType
:
:
CONTAINER
:
surfacePathPrefix
.
AppendLiteral
(
"
container
/
"
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
counter
type
"
)
;
break
;
}
surfacePathPrefix
.
AppendLiteral
(
"
types
=
"
)
;
surfacePathPrefix
.
AppendInt
(
counter
.
Values
(
)
.
SurfaceTypes
(
)
16
)
;
surfacePathPrefix
.
AppendLiteral
(
"
/
surface
(
"
)
;
surfacePathPrefix
.
AppendInt
(
counter
.
Key
(
)
.
Size
(
)
.
width
)
;
surfacePathPrefix
.
AppendLiteral
(
"
x
"
)
;
surfacePathPrefix
.
AppendInt
(
counter
.
Key
(
)
.
Size
(
)
.
height
)
;
if
(
!
counter
.
IsFinished
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
incomplete
"
)
;
}
if
(
counter
.
Values
(
)
.
ExternalHandles
(
)
>
0
)
{
surfacePathPrefix
.
AppendLiteral
(
"
handles
:
"
)
;
surfacePathPrefix
.
AppendInt
(
uint32_t
(
counter
.
Values
(
)
.
ExternalHandles
(
)
)
)
;
}
ImageMemoryReporter
:
:
AppendSharedSurfacePrefix
(
surfacePathPrefix
counter
aSharedSurfaces
)
;
PlaybackType
playback
=
counter
.
Key
(
)
.
Playback
(
)
;
if
(
playback
=
=
PlaybackType
:
:
eAnimated
)
{
if
(
StaticPrefs
:
:
image_mem_debug_reporting
(
)
)
{
surfacePathPrefix
.
AppendPrintf
(
"
(
animation
%
4u
)
"
uint32_t
(
counter
.
Values
(
)
.
FrameIndex
(
)
)
)
;
}
else
{
surfacePathPrefix
.
AppendLiteral
(
"
(
animation
)
"
)
;
}
}
if
(
counter
.
Key
(
)
.
Flags
(
)
!
=
DefaultSurfaceFlags
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
flags
:
"
)
;
surfacePathPrefix
.
AppendInt
(
uint32_t
(
counter
.
Key
(
)
.
Flags
(
)
)
16
)
;
}
if
(
counter
.
Key
(
)
.
Region
(
)
)
{
const
ImageIntRegion
&
region
=
counter
.
Key
(
)
.
Region
(
)
.
ref
(
)
;
const
gfx
:
:
IntRect
&
rect
=
region
.
Rect
(
)
;
surfacePathPrefix
.
AppendLiteral
(
"
region
:
[
rect
=
(
"
)
;
surfacePathPrefix
.
AppendInt
(
rect
.
x
)
;
surfacePathPrefix
.
AppendLiteral
(
"
"
)
;
surfacePathPrefix
.
AppendInt
(
rect
.
y
)
;
surfacePathPrefix
.
AppendLiteral
(
"
)
"
)
;
surfacePathPrefix
.
AppendInt
(
rect
.
width
)
;
surfacePathPrefix
.
AppendLiteral
(
"
x
"
)
;
surfacePathPrefix
.
AppendInt
(
rect
.
height
)
;
if
(
region
.
IsRestricted
(
)
)
{
const
gfx
:
:
IntRect
&
restrict
=
region
.
Restriction
(
)
;
if
(
restrict
=
=
rect
)
{
surfacePathPrefix
.
AppendLiteral
(
"
restrict
=
rect
"
)
;
}
else
{
surfacePathPrefix
.
AppendLiteral
(
"
restrict
=
(
"
)
;
surfacePathPrefix
.
AppendInt
(
restrict
.
x
)
;
surfacePathPrefix
.
AppendLiteral
(
"
"
)
;
surfacePathPrefix
.
AppendInt
(
restrict
.
y
)
;
surfacePathPrefix
.
AppendLiteral
(
"
)
"
)
;
surfacePathPrefix
.
AppendInt
(
restrict
.
width
)
;
surfacePathPrefix
.
AppendLiteral
(
"
x
"
)
;
surfacePathPrefix
.
AppendInt
(
restrict
.
height
)
;
}
}
if
(
region
.
GetExtendMode
(
)
!
=
gfx
:
:
ExtendMode
:
:
CLAMP
)
{
surfacePathPrefix
.
AppendLiteral
(
"
extendMode
=
"
)
;
surfacePathPrefix
.
AppendInt
(
int32_t
(
region
.
GetExtendMode
(
)
)
)
;
}
surfacePathPrefix
.
AppendLiteral
(
"
]
"
)
;
}
const
SVGImageContext
&
context
=
counter
.
Key
(
)
.
SVGContext
(
)
;
surfacePathPrefix
.
AppendLiteral
(
"
svgContext
:
[
"
)
;
if
(
context
.
GetViewportSize
(
)
)
{
const
CSSIntSize
&
size
=
context
.
GetViewportSize
(
)
.
ref
(
)
;
surfacePathPrefix
.
AppendLiteral
(
"
viewport
=
(
"
)
;
surfacePathPrefix
.
AppendInt
(
size
.
width
)
;
surfacePathPrefix
.
AppendLiteral
(
"
x
"
)
;
surfacePathPrefix
.
AppendInt
(
size
.
height
)
;
surfacePathPrefix
.
AppendLiteral
(
"
)
"
)
;
}
if
(
context
.
GetPreserveAspectRatio
(
)
)
{
nsAutoString
aspect
;
context
.
GetPreserveAspectRatio
(
)
-
>
ToString
(
aspect
)
;
surfacePathPrefix
.
AppendLiteral
(
"
preserveAspectRatio
=
(
"
)
;
LossyAppendUTF16toASCII
(
aspect
surfacePathPrefix
)
;
surfacePathPrefix
.
AppendLiteral
(
"
)
"
)
;
}
if
(
auto
scheme
=
context
.
GetColorScheme
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
colorScheme
=
"
)
;
surfacePathPrefix
.
AppendInt
(
int32_t
(
*
scheme
)
)
;
surfacePathPrefix
.
AppendLiteral
(
"
"
)
;
}
if
(
context
.
GetContextPaint
(
)
)
{
const
SVGEmbeddingContextPaint
*
paint
=
context
.
GetContextPaint
(
)
;
surfacePathPrefix
.
AppendLiteral
(
"
contextPaint
=
(
"
)
;
if
(
paint
-
>
GetFill
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
fill
=
"
)
;
surfacePathPrefix
.
AppendInt
(
paint
-
>
GetFill
(
)
-
>
ToABGR
(
)
16
)
;
}
if
(
paint
-
>
GetFillOpacity
(
)
!
=
1
.
0
)
{
surfacePathPrefix
.
AppendLiteral
(
"
fillOpa
=
"
)
;
surfacePathPrefix
.
AppendFloat
(
paint
-
>
GetFillOpacity
(
)
)
;
}
if
(
paint
-
>
GetStroke
(
)
)
{
surfacePathPrefix
.
AppendLiteral
(
"
stroke
=
"
)
;
surfacePathPrefix
.
AppendInt
(
paint
-
>
GetStroke
(
)
-
>
ToABGR
(
)
16
)
;
}
if
(
paint
-
>
GetStrokeOpacity
(
)
!
=
1
.
0
)
{
surfacePathPrefix
.
AppendLiteral
(
"
strokeOpa
=
"
)
;
surfacePathPrefix
.
AppendFloat
(
paint
-
>
GetStrokeOpacity
(
)
)
;
}
surfacePathPrefix
.
AppendLiteral
(
"
)
"
)
;
}
surfacePathPrefix
.
AppendLiteral
(
"
]
"
)
;
surfacePathPrefix
.
AppendLiteral
(
"
)
/
"
)
;
ReportValues
(
aHandleReport
aData
surfacePathPrefix
counter
.
Values
(
)
)
;
}
}
static
void
ReportTotal
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aExplicit
const
char
*
aPathPrefix
const
char
*
aPathInfix
const
MemoryTotal
&
aTotal
)
{
nsAutoCString
pathPrefix
;
if
(
aExplicit
)
{
pathPrefix
.
AppendLiteral
(
"
explicit
/
"
)
;
}
pathPrefix
.
Append
(
aPathPrefix
)
;
nsAutoCString
rasterUsedPrefix
(
pathPrefix
)
;
rasterUsedPrefix
.
AppendLiteral
(
"
/
raster
/
used
/
"
)
;
rasterUsedPrefix
.
Append
(
aPathInfix
)
;
ReportValues
(
aHandleReport
aData
rasterUsedPrefix
aTotal
.
UsedRaster
(
)
)
;
nsAutoCString
rasterUnusedPrefix
(
pathPrefix
)
;
rasterUnusedPrefix
.
AppendLiteral
(
"
/
raster
/
unused
/
"
)
;
rasterUnusedPrefix
.
Append
(
aPathInfix
)
;
ReportValues
(
aHandleReport
aData
rasterUnusedPrefix
aTotal
.
UnusedRaster
(
)
)
;
nsAutoCString
vectorUsedPrefix
(
pathPrefix
)
;
vectorUsedPrefix
.
AppendLiteral
(
"
/
vector
/
used
/
"
)
;
vectorUsedPrefix
.
Append
(
aPathInfix
)
;
ReportValues
(
aHandleReport
aData
vectorUsedPrefix
aTotal
.
UsedVector
(
)
)
;
nsAutoCString
vectorUnusedPrefix
(
pathPrefix
)
;
vectorUnusedPrefix
.
AppendLiteral
(
"
/
vector
/
unused
/
"
)
;
vectorUnusedPrefix
.
Append
(
aPathInfix
)
;
ReportValues
(
aHandleReport
aData
vectorUnusedPrefix
aTotal
.
UnusedVector
(
)
)
;
}
static
void
ReportValues
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsACString
&
aPathPrefix
const
MemoryCounter
&
aCounter
)
{
ReportSourceValue
(
aHandleReport
aData
aPathPrefix
aCounter
)
;
ReportValue
(
aHandleReport
aData
KIND_HEAP
aPathPrefix
"
decoded
-
heap
"
"
Decoded
image
data
which
is
stored
on
the
heap
.
"
aCounter
.
DecodedHeap
(
)
)
;
ReportValue
(
aHandleReport
aData
KIND_NONHEAP
aPathPrefix
"
decoded
-
nonheap
"
"
Decoded
image
data
which
isn
'
t
stored
on
the
heap
.
"
aCounter
.
DecodedNonHeap
(
)
)
;
ReportValue
(
aHandleReport
aData
KIND_NONHEAP
aPathPrefix
"
decoded
-
unknown
"
"
Decoded
image
data
which
is
unknown
to
be
on
the
heap
or
not
.
"
aCounter
.
DecodedUnknown
(
)
)
;
}
static
void
ReportSourceValue
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsACString
&
aPathPrefix
const
MemoryCounter
&
aCounter
)
{
ReportValue
(
aHandleReport
aData
KIND_HEAP
aPathPrefix
"
source
"
"
Raster
image
source
data
and
vector
image
documents
.
"
aCounter
.
Source
(
)
)
;
}
static
void
ReportValue
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
int32_t
aKind
const
nsACString
&
aPathPrefix
const
char
*
aPathSuffix
const
char
*
aDescription
size_t
aValue
)
{
if
(
aValue
=
=
0
)
{
return
;
}
nsAutoCString
desc
(
aDescription
)
;
nsAutoCString
path
(
aPathPrefix
)
;
path
.
Append
(
aPathSuffix
)
;
aHandleReport
-
>
Callback
(
"
"
_ns
path
aKind
UNITS_BYTES
aValue
desc
aData
)
;
}
static
void
RecordCounterForRequest
(
imgRequest
*
aRequest
nsTArray
<
ImageMemoryCounter
>
*
aArray
bool
aIsUsed
)
{
SizeOfState
state
(
ImagesMallocSizeOf
)
;
RefPtr
<
image
:
:
Image
>
image
=
aRequest
-
>
GetImage
(
)
;
if
(
image
)
{
ImageMemoryCounter
counter
(
aRequest
image
state
aIsUsed
)
;
aArray
-
>
AppendElement
(
std
:
:
move
(
counter
)
)
;
}
else
{
ImageMemoryCounter
counter
(
aRequest
state
aIsUsed
)
;
aArray
-
>
AppendElement
(
std
:
:
move
(
counter
)
)
;
}
}
}
;
NS_IMPL_ISUPPORTS
(
imgMemoryReporter
nsIMemoryReporter
)
NS_IMPL_ISUPPORTS
(
nsProgressNotificationProxy
nsIProgressEventSink
nsIChannelEventSink
nsIInterfaceRequestor
)
NS_IMETHODIMP
nsProgressNotificationProxy
:
:
OnProgress
(
nsIRequest
*
request
int64_t
progress
int64_t
progressMax
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
request
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
nsCOMPtr
<
nsIProgressEventSink
>
target
;
NS_QueryNotificationCallbacks
(
mOriginalCallbacks
loadGroup
NS_GET_IID
(
nsIProgressEventSink
)
getter_AddRefs
(
target
)
)
;
if
(
!
target
)
{
return
NS_OK
;
}
return
target
-
>
OnProgress
(
mImageRequest
progress
progressMax
)
;
}
NS_IMETHODIMP
nsProgressNotificationProxy
:
:
OnStatus
(
nsIRequest
*
request
nsresult
status
const
char16_t
*
statusArg
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
request
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
nsCOMPtr
<
nsIProgressEventSink
>
target
;
NS_QueryNotificationCallbacks
(
mOriginalCallbacks
loadGroup
NS_GET_IID
(
nsIProgressEventSink
)
getter_AddRefs
(
target
)
)
;
if
(
!
target
)
{
return
NS_OK
;
}
return
target
-
>
OnStatus
(
mImageRequest
status
statusArg
)
;
}
NS_IMETHODIMP
nsProgressNotificationProxy
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChannel
nsIChannel
*
newChannel
uint32_t
flags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
newChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
nsCOMPtr
<
nsIChannelEventSink
>
target
;
NS_QueryNotificationCallbacks
(
mOriginalCallbacks
loadGroup
NS_GET_IID
(
nsIChannelEventSink
)
getter_AddRefs
(
target
)
)
;
if
(
!
target
)
{
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
return
target
-
>
AsyncOnChannelRedirect
(
oldChannel
newChannel
flags
cb
)
;
}
NS_IMETHODIMP
nsProgressNotificationProxy
:
:
GetInterface
(
const
nsIID
&
iid
void
*
*
result
)
{
if
(
iid
.
Equals
(
NS_GET_IID
(
nsIProgressEventSink
)
)
)
{
*
result
=
static_cast
<
nsIProgressEventSink
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
if
(
iid
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
*
result
=
static_cast
<
nsIChannelEventSink
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
if
(
mOriginalCallbacks
)
{
return
mOriginalCallbacks
-
>
GetInterface
(
iid
result
)
;
}
return
NS_NOINTERFACE
;
}
static
void
NewRequestAndEntry
(
bool
aForcePrincipalCheckForCacheEntry
imgLoader
*
aLoader
const
ImageCacheKey
&
aKey
imgRequest
*
*
aRequest
imgCacheEntry
*
*
aEntry
)
{
RefPtr
<
imgRequest
>
request
=
new
imgRequest
(
aLoader
aKey
)
;
RefPtr
<
imgCacheEntry
>
entry
=
new
imgCacheEntry
(
aLoader
request
aForcePrincipalCheckForCacheEntry
)
;
aLoader
-
>
AddToUncachedImages
(
request
)
;
request
.
forget
(
aRequest
)
;
entry
.
forget
(
aEntry
)
;
}
static
bool
ShouldRevalidateEntry
(
imgCacheEntry
*
aEntry
nsLoadFlags
aFlags
bool
aHasExpired
)
{
if
(
aFlags
&
nsIRequest
:
:
LOAD_BYPASS_CACHE
)
{
return
false
;
}
if
(
aFlags
&
nsIRequest
:
:
VALIDATE_ALWAYS
)
{
return
true
;
}
if
(
aEntry
-
>
GetMustValidate
(
)
)
{
return
true
;
}
if
(
aHasExpired
)
{
if
(
aFlags
&
(
nsIRequest
:
:
LOAD_FROM_CACHE
|
nsIRequest
:
:
VALIDATE_NEVER
|
nsIRequest
:
:
VALIDATE_ONCE_PER_SESSION
)
)
{
return
false
;
}
return
true
;
}
return
false
;
}
static
bool
ShouldLoadCachedImage
(
imgRequest
*
aImgRequest
Document
*
aLoadingDocument
nsIPrincipal
*
aTriggeringPrincipal
nsContentPolicyType
aPolicyType
bool
aSendCSPViolationReports
)
{
bool
insecureRedirect
=
aImgRequest
-
>
HadInsecureRedirect
(
)
;
nsCOMPtr
<
nsIURI
>
contentLocation
;
aImgRequest
-
>
GetFinalURI
(
getter_AddRefs
(
contentLocation
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadingDocument
?
aLoadingDocument
-
>
NodePrincipal
(
)
:
aTriggeringPrincipal
;
if
(
!
loadingPrincipal
)
{
loadingPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
loadingPrincipal
aTriggeringPrincipal
aLoadingDocument
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
aPolicyType
)
;
secCheckLoadInfo
-
>
SetSendCSPViolationEvents
(
aSendCSPViolationReports
)
;
int16_t
decision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
rv
=
NS_CheckContentLoadPolicy
(
contentLocation
secCheckLoadInfo
&
decision
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
NS_CP_ACCEPTED
(
decision
)
)
{
return
false
;
}
if
(
insecureRedirect
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
NS_CP_GetDocShellFromContext
(
ToSupports
(
aLoadingDocument
)
)
;
if
(
docShell
)
{
Document
*
document
=
docShell
-
>
GetDocument
(
)
;
if
(
document
&
&
document
-
>
GetUpgradeInsecureRequests
(
false
)
)
{
return
false
;
}
}
if
(
!
aTriggeringPrincipal
|
|
!
aTriggeringPrincipal
-
>
IsSystemPrincipal
(
)
)
{
decision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
rv
=
nsMixedContentBlocker
:
:
ShouldLoad
(
insecureRedirect
contentLocation
secCheckLoadInfo
true
&
decision
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
NS_CP_ACCEPTED
(
decision
)
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
ValidateCORSMode
(
imgRequest
*
aRequest
bool
aForcePrincipalCheck
CORSMode
aCORSMode
nsIPrincipal
*
aTriggeringPrincipal
)
{
if
(
aRequest
-
>
GetCORSMode
(
)
!
=
aCORSMode
)
{
return
false
;
}
if
(
aRequest
-
>
GetCORSMode
(
)
!
=
CORS_NONE
|
|
aForcePrincipalCheck
)
{
nsCOMPtr
<
nsIPrincipal
>
otherprincipal
=
aRequest
-
>
GetTriggeringPrincipal
(
)
;
if
(
otherprincipal
&
&
!
aTriggeringPrincipal
)
{
return
false
;
}
if
(
otherprincipal
&
&
aTriggeringPrincipal
&
&
!
otherprincipal
-
>
Equals
(
aTriggeringPrincipal
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ValidateSecurityInfo
(
imgRequest
*
aRequest
bool
aForcePrincipalCheck
CORSMode
aCORSMode
nsIPrincipal
*
aTriggeringPrincipal
Document
*
aLoadingDocument
nsContentPolicyType
aPolicyType
)
{
if
(
!
ValidateCORSMode
(
aRequest
aForcePrincipalCheck
aCORSMode
aTriggeringPrincipal
)
)
{
return
false
;
}
return
ShouldLoadCachedImage
(
aRequest
aLoadingDocument
aTriggeringPrincipal
aPolicyType
false
)
;
}
static
void
AdjustPriorityForImages
(
nsIChannel
*
aChannel
nsLoadFlags
aLoadFlags
FetchPriority
aFetchPriority
)
{
if
(
nsCOMPtr
<
nsISupportsPriority
>
supportsPriority
=
do_QueryInterface
(
aChannel
)
)
{
int32_t
priority
=
nsISupportsPriority
:
:
PRIORITY_LOW
;
if
(
StaticPrefs
:
:
network_fetchpriority_enabled
(
)
)
{
priority
+
=
FETCH_PRIORITY_ADJUSTMENT_FOR
(
images
aFetchPriority
)
;
}
if
(
aLoadFlags
&
nsIRequest
:
:
LOAD_BACKGROUND
)
{
+
+
priority
;
}
supportsPriority
-
>
AdjustPriority
(
priority
)
;
}
if
(
nsCOMPtr
<
nsIClassOfService
>
cos
=
do_QueryInterface
(
aChannel
)
)
{
cos
-
>
SetFetchPriorityDOM
(
aFetchPriority
)
;
}
}
static
nsresult
NewImageChannel
(
nsIChannel
*
*
aResult
bool
*
aForcePrincipalCheckForCacheEntry
nsIURI
*
aURI
nsIURI
*
aInitialDocumentURI
CORSMode
aCORSMode
nsIReferrerInfo
*
aReferrerInfo
nsILoadGroup
*
aLoadGroup
nsLoadFlags
aLoadFlags
nsContentPolicyType
aPolicyType
nsIPrincipal
*
aTriggeringPrincipal
nsINode
*
aRequestingNode
bool
aRespectPrivacy
uint64_t
aEarlyHintPreloaderId
FetchPriority
aFetchPriority
)
{
MOZ_ASSERT
(
aResult
)
;
nsresult
rv
;
nsCOMPtr
<
nsIHttpChannel
>
newHttpChannel
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
if
(
aLoadGroup
)
{
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
}
nsSecurityFlags
securityFlags
=
nsContentSecurityManager
:
:
ComputeSecurityFlags
(
aCORSMode
nsContentSecurityManager
:
:
CORSSecurityMapping
:
:
CORS_NONE_MAPS_TO_INHERITED_CONTEXT
)
;
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
if
(
aRequestingNode
&
&
aTriggeringPrincipal
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
aResult
aURI
aRequestingNode
aTriggeringPrincipal
securityFlags
aPolicyType
nullptr
nullptr
callbacks
aLoadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
(
*
aResult
)
-
>
LoadInfo
(
)
;
rv
=
loadInfo
-
>
SetOriginAttributes
(
aTriggeringPrincipal
-
>
OriginAttributesRef
(
)
)
;
}
}
else
{
rv
=
NS_NewChannel
(
aResult
aURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
aPolicyType
nullptr
nullptr
nullptr
callbacks
aLoadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
OriginAttributes
attrs
;
if
(
aTriggeringPrincipal
)
{
attrs
=
aTriggeringPrincipal
-
>
OriginAttributesRef
(
)
;
}
attrs
.
mPrivateBrowsingId
=
aRespectPrivacy
?
1
:
0
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
(
*
aResult
)
-
>
LoadInfo
(
)
;
rv
=
loadInfo
-
>
SetOriginAttributes
(
attrs
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aForcePrincipalCheckForCacheEntry
=
aTriggeringPrincipal
&
&
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
aTriggeringPrincipal
aURI
false
false
)
;
newHttpChannel
=
do_QueryInterface
(
*
aResult
)
;
if
(
newHttpChannel
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
=
do_QueryInterface
(
newHttpChannel
)
;
NS_ENSURE_TRUE
(
httpChannelInternal
NS_ERROR_UNEXPECTED
)
;
rv
=
httpChannelInternal
-
>
SetDocumentURI
(
aInitialDocumentURI
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
aReferrerInfo
)
{
DebugOnly
<
nsresult
>
rv
=
newHttpChannel
-
>
SetReferrerInfo
(
aReferrerInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
if
(
aEarlyHintPreloaderId
)
{
rv
=
httpChannelInternal
-
>
SetEarlyHintPreloaderId
(
aEarlyHintPreloaderId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
AdjustPriorityForImages
(
*
aResult
aLoadFlags
aFetchPriority
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
do_CreateInstance
(
NS_LOADGROUP_CONTRACTID
)
;
nsCOMPtr
<
nsILoadGroupChild
>
childLoadGroup
=
do_QueryInterface
(
loadGroup
)
;
if
(
childLoadGroup
)
{
childLoadGroup
-
>
SetParentLoadGroup
(
aLoadGroup
)
;
}
(
*
aResult
)
-
>
SetLoadGroup
(
loadGroup
)
;
return
NS_OK
;
}
static
uint32_t
SecondsFromPRTime
(
PRTime
aTime
)
{
return
nsContentUtils
:
:
SecondsFromPRTime
(
aTime
)
;
}
imgCacheEntry
:
:
imgCacheEntry
(
imgLoader
*
loader
imgRequest
*
request
bool
forcePrincipalCheck
)
:
mLoader
(
loader
)
mRequest
(
request
)
mDataSize
(
0
)
mTouchedTime
(
SecondsFromPRTime
(
PR_Now
(
)
)
)
mLoadTime
(
SecondsFromPRTime
(
PR_Now
(
)
)
)
mExpiryTime
(
CacheExpirationTime
:
:
Never
(
)
)
mMustValidate
(
false
)
mEvicted
(
true
)
mHasNoProxies
(
true
)
mForcePrincipalCheck
(
forcePrincipalCheck
)
mHasNotified
(
false
)
{
}
imgCacheEntry
:
:
~
imgCacheEntry
(
)
{
LOG_FUNC
(
gImgLog
"
imgCacheEntry
:
:
~
imgCacheEntry
(
)
"
)
;
}
void
imgCacheEntry
:
:
Touch
(
bool
updateTime
)
{
LOG_SCOPE
(
gImgLog
"
imgCacheEntry
:
:
Touch
"
)
;
if
(
updateTime
)
{
mTouchedTime
=
SecondsFromPRTime
(
PR_Now
(
)
)
;
}
UpdateCache
(
)
;
}
void
imgCacheEntry
:
:
UpdateCache
(
int32_t
diff
)
{
if
(
!
Evicted
(
)
&
&
HasNoProxies
(
)
)
{
mLoader
-
>
CacheEntriesChanged
(
diff
)
;
}
}
void
imgCacheEntry
:
:
UpdateLoadTime
(
)
{
mLoadTime
=
SecondsFromPRTime
(
PR_Now
(
)
)
;
}
void
imgCacheEntry
:
:
SetHasNoProxies
(
bool
hasNoProxies
)
{
if
(
MOZ_LOG_TEST
(
gImgLog
LogLevel
:
:
Debug
)
)
{
if
(
hasNoProxies
)
{
LOG_FUNC_WITH_PARAM
(
gImgLog
"
imgCacheEntry
:
:
SetHasNoProxies
true
"
"
uri
"
mRequest
-
>
CacheKey
(
)
.
URI
(
)
)
;
}
else
{
LOG_FUNC_WITH_PARAM
(
gImgLog
"
imgCacheEntry
:
:
SetHasNoProxies
false
"
"
uri
"
mRequest
-
>
CacheKey
(
)
.
URI
(
)
)
;
}
}
mHasNoProxies
=
hasNoProxies
;
}
imgCacheQueue
:
:
imgCacheQueue
(
)
:
mDirty
(
false
)
mSize
(
0
)
{
}
void
imgCacheQueue
:
:
UpdateSize
(
int32_t
diff
)
{
mSize
+
=
diff
;
}
uint32_t
imgCacheQueue
:
:
GetSize
(
)
const
{
return
mSize
;
}
void
imgCacheQueue
:
:
Remove
(
imgCacheEntry
*
entry
)
{
uint64_t
index
=
mQueue
.
IndexOf
(
entry
)
;
if
(
index
=
=
queueContainer
:
:
NoIndex
)
{
return
;
}
mSize
-
=
mQueue
[
index
]
-
>
GetDataSize
(
)
;
if
(
!
IsDirty
(
)
&
&
index
=
=
0
)
{
std
:
:
pop_heap
(
mQueue
.
begin
(
)
mQueue
.
end
(
)
imgLoader
:
:
CompareCacheEntries
)
;
mQueue
.
RemoveLastElement
(
)
;
return
;
}
mQueue
.
RemoveElementAt
(
index
)
;
if
(
mQueue
.
Length
(
)
<
=
1
)
{
Refresh
(
)
;
return
;
}
MarkDirty
(
)
;
}
void
imgCacheQueue
:
:
Push
(
imgCacheEntry
*
entry
)
{
mSize
+
=
entry
-
>
GetDataSize
(
)
;
RefPtr
<
imgCacheEntry
>
refptr
(
entry
)
;
mQueue
.
AppendElement
(
std
:
:
move
(
refptr
)
)
;
if
(
!
IsDirty
(
)
)
{
std
:
:
push_heap
(
mQueue
.
begin
(
)
mQueue
.
end
(
)
imgLoader
:
:
CompareCacheEntries
)
;
}
}
already_AddRefed
<
imgCacheEntry
>
imgCacheQueue
:
:
Pop
(
)
{
if
(
mQueue
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
IsDirty
(
)
)
{
Refresh
(
)
;
}
std
:
:
pop_heap
(
mQueue
.
begin
(
)
mQueue
.
end
(
)
imgLoader
:
:
CompareCacheEntries
)
;
RefPtr
<
imgCacheEntry
>
entry
=
mQueue
.
PopLastElement
(
)
;
mSize
-
=
entry
-
>
GetDataSize
(
)
;
return
entry
.
forget
(
)
;
}
void
imgCacheQueue
:
:
Refresh
(
)
{
std
:
:
make_heap
(
mQueue
.
begin
(
)
mQueue
.
end
(
)
imgLoader
:
:
CompareCacheEntries
)
;
mDirty
=
false
;
}
void
imgCacheQueue
:
:
MarkDirty
(
)
{
mDirty
=
true
;
}
bool
imgCacheQueue
:
:
IsDirty
(
)
{
return
mDirty
;
}
uint32_t
imgCacheQueue
:
:
GetNumElements
(
)
const
{
return
mQueue
.
Length
(
)
;
}
bool
imgCacheQueue
:
:
Contains
(
imgCacheEntry
*
aEntry
)
const
{
return
mQueue
.
Contains
(
aEntry
)
;
}
imgCacheQueue
:
:
iterator
imgCacheQueue
:
:
begin
(
)
{
return
mQueue
.
begin
(
)
;
}
imgCacheQueue
:
:
const_iterator
imgCacheQueue
:
:
begin
(
)
const
{
return
mQueue
.
begin
(
)
;
}
imgCacheQueue
:
:
iterator
imgCacheQueue
:
:
end
(
)
{
return
mQueue
.
end
(
)
;
}
imgCacheQueue
:
:
const_iterator
imgCacheQueue
:
:
end
(
)
const
{
return
mQueue
.
end
(
)
;
}
nsresult
imgLoader
:
:
CreateNewProxyForRequest
(
imgRequest
*
aRequest
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
Document
*
aLoadingDocument
imgINotificationObserver
*
aObserver
nsLoadFlags
aLoadFlags
imgRequestProxy
*
*
_retval
)
{
LOG_SCOPE_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
CreateNewProxyForRequest
"
"
imgRequest
"
aRequest
)
;
RefPtr
<
imgRequestProxy
>
proxyRequest
=
new
imgRequestProxy
(
)
;
proxyRequest
-
>
SetLoadFlags
(
aLoadFlags
)
;
nsresult
rv
=
proxyRequest
-
>
Init
(
aRequest
aLoadGroup
aURI
aObserver
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
proxyRequest
.
forget
(
_retval
)
;
return
NS_OK
;
}
class
imgCacheExpirationTracker
final
:
public
nsExpirationTracker
<
imgCacheEntry
3
>
{
enum
{
TIMEOUT_SECONDS
=
10
}
;
public
:
imgCacheExpirationTracker
(
)
;
protected
:
void
NotifyExpired
(
imgCacheEntry
*
entry
)
override
;
}
;
imgCacheExpirationTracker
:
:
imgCacheExpirationTracker
(
)
:
nsExpirationTracker
<
imgCacheEntry
3
>
(
TIMEOUT_SECONDS
*
1000
"
imgCacheExpirationTracker
"
)
{
}
void
imgCacheExpirationTracker
:
:
NotifyExpired
(
imgCacheEntry
*
entry
)
{
RefPtr
<
imgCacheEntry
>
kungFuDeathGrip
(
entry
)
;
if
(
MOZ_LOG_TEST
(
gImgLog
LogLevel
:
:
Debug
)
)
{
RefPtr
<
imgRequest
>
req
=
entry
-
>
GetRequest
(
)
;
if
(
req
)
{
LOG_FUNC_WITH_PARAM
(
gImgLog
"
imgCacheExpirationTracker
:
:
NotifyExpired
"
"
entry
"
req
-
>
CacheKey
(
)
.
URI
(
)
)
;
}
}
if
(
!
entry
-
>
Evicted
(
)
)
{
entry
-
>
Loader
(
)
-
>
RemoveFromCache
(
entry
)
;
}
entry
-
>
Loader
(
)
-
>
VerifyCacheSizes
(
)
;
}
double
imgLoader
:
:
sCacheTimeWeight
;
uint32_t
imgLoader
:
:
sCacheMaxSize
;
imgMemoryReporter
*
imgLoader
:
:
sMemReporter
;
NS_IMPL_ISUPPORTS
(
imgLoader
imgILoader
nsIContentSniffer
imgICache
nsISupportsWeakReference
nsIObserver
)
static
imgLoader
*
gNormalLoader
=
nullptr
;
static
imgLoader
*
gPrivateBrowsingLoader
=
nullptr
;
already_AddRefed
<
imgLoader
>
imgLoader
:
:
CreateImageLoader
(
)
{
mozilla
:
:
image
:
:
EnsureModuleInitialized
(
)
;
RefPtr
<
imgLoader
>
loader
=
new
imgLoader
(
)
;
loader
-
>
Init
(
)
;
return
loader
.
forget
(
)
;
}
imgLoader
*
imgLoader
:
:
NormalLoader
(
)
{
if
(
!
gNormalLoader
)
{
gNormalLoader
=
CreateImageLoader
(
)
.
take
(
)
;
}
return
gNormalLoader
;
}
imgLoader
*
imgLoader
:
:
PrivateBrowsingLoader
(
)
{
if
(
!
gPrivateBrowsingLoader
)
{
gPrivateBrowsingLoader
=
CreateImageLoader
(
)
.
take
(
)
;
gPrivateBrowsingLoader
-
>
RespectPrivacyNotifications
(
)
;
}
return
gPrivateBrowsingLoader
;
}
imgLoader
:
:
imgLoader
(
)
:
mUncachedImagesMutex
(
"
imgLoader
:
:
UncachedImages
"
)
mRespectPrivacy
(
false
)
{
sMemReporter
-
>
AddRef
(
)
;
sMemReporter
-
>
RegisterLoader
(
this
)
;
}
imgLoader
:
:
~
imgLoader
(
)
{
ClearImageCache
(
)
;
{
MutexAutoLock
lock
(
mUncachedImagesMutex
)
;
for
(
RefPtr
<
imgRequest
>
req
:
mUncachedImages
)
{
req
-
>
ClearLoader
(
)
;
}
}
sMemReporter
-
>
UnregisterLoader
(
this
)
;
sMemReporter
-
>
Release
(
)
;
}
void
imgLoader
:
:
VerifyCacheSizes
(
)
{
#
ifdef
DEBUG
if
(
!
mCacheTracker
)
{
return
;
}
uint32_t
cachesize
=
mCache
.
Count
(
)
;
uint32_t
queuesize
=
mCacheQueue
.
GetNumElements
(
)
;
uint32_t
trackersize
=
0
;
for
(
nsExpirationTracker
<
imgCacheEntry
3
>
:
:
Iterator
it
(
mCacheTracker
.
get
(
)
)
;
it
.
Next
(
)
;
)
{
trackersize
+
+
;
}
MOZ_ASSERT
(
queuesize
=
=
trackersize
"
Queue
and
tracker
sizes
out
of
sync
!
"
)
;
MOZ_ASSERT
(
queuesize
<
=
cachesize
"
Queue
has
more
elements
than
cache
!
"
)
;
#
endif
}
void
imgLoader
:
:
GlobalInit
(
)
{
sCacheTimeWeight
=
StaticPrefs
:
:
image_cache_timeweight_AtStartup
(
)
/
1000
.
0
;
int32_t
cachesize
=
StaticPrefs
:
:
image_cache_size_AtStartup
(
)
;
sCacheMaxSize
=
cachesize
>
0
?
cachesize
:
0
;
sMemReporter
=
new
imgMemoryReporter
(
)
;
RegisterStrongAsyncMemoryReporter
(
sMemReporter
)
;
RegisterImagesContentUsedUncompressedDistinguishedAmount
(
imgMemoryReporter
:
:
ImagesContentUsedUncompressedDistinguishedAmount
)
;
}
void
imgLoader
:
:
ShutdownMemoryReporter
(
)
{
UnregisterImagesContentUsedUncompressedDistinguishedAmount
(
)
;
UnregisterStrongMemoryReporter
(
sMemReporter
)
;
}
nsresult
imgLoader
:
:
InitCache
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
NS_ERROR_FAILURE
;
}
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
os
-
>
AddObserver
(
this
"
chrome
-
flush
-
caches
"
false
)
;
os
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
false
)
;
os
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
false
)
;
os
-
>
AddObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
mCacheTracker
=
MakeUnique
<
imgCacheExpirationTracker
>
(
)
;
return
NS_OK
;
}
nsresult
imgLoader
:
:
Init
(
)
{
InitCache
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
imgLoader
:
:
RespectPrivacyNotifications
(
)
{
mRespectPrivacy
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
imgLoader
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
"
memory
-
pressure
"
)
=
=
0
)
{
MinimizeCache
(
)
;
}
else
if
(
strcmp
(
aTopic
"
chrome
-
flush
-
caches
"
)
=
=
0
)
{
MinimizeCache
(
)
;
ClearImageCache
(
{
ClearOption
:
:
ChromeOnly
}
)
;
}
else
if
(
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
=
=
0
)
{
if
(
mRespectPrivacy
)
{
ClearImageCache
(
)
;
}
}
else
if
(
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
=
=
0
)
{
mCacheTracker
=
nullptr
;
}
else
if
(
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
=
=
0
)
{
mCacheTracker
=
nullptr
;
ShutdownMemoryReporter
(
)
;
}
else
{
MOZ_ASSERT
(
0
"
Invalid
topic
received
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
imgLoader
:
:
ClearCache
(
bool
chrome
)
{
if
(
XRE_IsParentProcess
(
)
)
{
bool
privateLoader
=
this
=
=
gPrivateBrowsingLoader
;
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendClearImageCache
(
privateLoader
chrome
)
;
}
}
ClearOptions
options
;
if
(
chrome
)
{
options
+
=
ClearOption
:
:
ChromeOnly
;
}
return
ClearImageCache
(
options
)
;
}
NS_IMETHODIMP
imgLoader
:
:
RemoveEntriesFromPrincipalInAllProcesses
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendClearImageCacheFromPrincipal
(
aPrincipal
)
;
}
imgLoader
*
loader
;
if
(
aPrincipal
-
>
OriginAttributesRef
(
)
.
IsPrivateBrowsing
(
)
)
{
loader
=
imgLoader
:
:
PrivateBrowsingLoader
(
)
;
}
else
{
loader
=
imgLoader
:
:
NormalLoader
(
)
;
}
return
loader
-
>
RemoveEntriesInternal
(
Some
(
aPrincipal
)
Nothing
(
)
Nothing
(
)
)
;
}
NS_IMETHODIMP
imgLoader
:
:
RemoveEntriesFromSiteInAllProcesses
(
const
nsACString
&
aSchemelessSite
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributesPattern
JSContext
*
aCx
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
OriginAttributesPattern
pattern
;
if
(
!
aOriginAttributesPattern
.
isObject
(
)
|
|
!
pattern
.
Init
(
aCx
aOriginAttributesPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendClearImageCacheFromSite
(
aSchemelessSite
pattern
)
;
}
return
RemoveEntriesInternal
(
Nothing
(
)
Some
(
nsCString
(
aSchemelessSite
)
)
Some
(
pattern
)
)
;
}
nsresult
imgLoader
:
:
RemoveEntriesInternal
(
const
Maybe
<
nsCOMPtr
<
nsIPrincipal
>
>
&
aPrincipal
const
Maybe
<
nsCString
>
&
aSchemelessSite
const
Maybe
<
OriginAttributesPattern
>
&
aPattern
)
{
if
(
(
!
aPrincipal
&
&
!
aSchemelessSite
)
|
|
(
aPrincipal
&
&
aSchemelessSite
)
|
|
aSchemelessSite
.
isSome
(
)
!
=
aPattern
.
isSome
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
;
AutoTArray
<
RefPtr
<
imgCacheEntry
>
128
>
entriesToBeRemoved
;
Maybe
<
OriginAttributesPattern
>
patternWithPartitionKey
=
Nothing
(
)
;
if
(
aPattern
)
{
OriginAttributesPattern
pattern
(
aPattern
.
ref
(
)
)
;
pattern
.
mPartitionKeyPattern
.
Construct
(
)
;
pattern
.
mPartitionKeyPattern
.
Value
(
)
.
mBaseDomain
.
Construct
(
NS_ConvertUTF8toUTF16
(
aSchemelessSite
.
ref
(
)
)
)
;
patternWithPartitionKey
.
emplace
(
std
:
:
move
(
pattern
)
)
;
}
for
(
const
auto
&
entry
:
mCache
)
{
const
auto
&
key
=
entry
.
GetKey
(
)
;
const
bool
shouldRemove
=
[
&
]
{
if
(
aPrincipal
)
{
nsCOMPtr
<
nsIPrincipal
>
keyPrincipal
=
BasePrincipal
:
:
CreateContentPrincipal
(
key
.
URI
(
)
key
.
OriginAttributesRef
(
)
)
;
return
keyPrincipal
-
>
Equals
(
aPrincipal
.
ref
(
)
)
;
}
if
(
!
aSchemelessSite
)
{
return
false
;
}
nsAutoCString
host
;
nsresult
rv
=
key
.
URI
(
)
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
|
|
host
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
!
tldService
)
{
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
}
if
(
NS_WARN_IF
(
!
tldService
)
)
{
return
false
;
}
bool
hasRootDomain
=
false
;
rv
=
tldService
-
>
HasRootDomain
(
host
aSchemelessSite
.
ref
(
)
&
hasRootDomain
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
if
(
hasRootDomain
&
&
aPattern
-
>
Matches
(
key
.
OriginAttributesRef
(
)
)
)
{
return
true
;
}
Maybe
<
OriginAttributes
>
originAttributesWithPartitionKey
;
{
OriginAttributes
attrs
;
if
(
attrs
.
PopulateFromSuffix
(
key
.
IsolationKeyRef
(
)
)
)
{
OriginAttributes
attrsWithPartitionKey
(
key
.
OriginAttributesRef
(
)
)
;
attrsWithPartitionKey
.
mPartitionKey
=
attrs
.
mPartitionKey
;
originAttributesWithPartitionKey
.
emplace
(
std
:
:
move
(
attrsWithPartitionKey
)
)
;
}
}
if
(
originAttributesWithPartitionKey
.
isSome
(
)
)
{
nsAutoCString
oaSuffixForPrinting
;
originAttributesWithPartitionKey
-
>
CreateSuffix
(
oaSuffixForPrinting
)
;
nsAutoString
patternForPrinting
;
patternWithPartitionKey
-
>
ToJSON
(
patternForPrinting
)
;
return
patternWithPartitionKey
.
ref
(
)
.
Matches
(
originAttributesWithPartitionKey
.
ref
(
)
)
;
}
return
aSchemelessSite
-
>
Equals
(
key
.
IsolationKeyRef
(
)
)
;
}
(
)
;
if
(
shouldRemove
)
{
entriesToBeRemoved
.
AppendElement
(
entry
.
GetData
(
)
)
;
}
}
for
(
auto
&
entry
:
entriesToBeRemoved
)
{
if
(
!
RemoveFromCache
(
entry
)
)
{
NS_WARNING
(
"
Couldn
'
t
remove
an
entry
from
the
cache
in
"
"
RemoveEntriesInternal
(
)
\
n
"
)
;
}
}
return
NS_OK
;
}
constexpr
auto
AllCORSModes
(
)
{
return
MakeInclusiveEnumeratedRange
(
kFirstCORSMode
kLastCORSMode
)
;
}
NS_IMETHODIMP
imgLoader
:
:
RemoveEntry
(
nsIURI
*
aURI
Document
*
aDoc
)
{
if
(
!
aURI
)
{
return
NS_OK
;
}
OriginAttributes
attrs
;
if
(
aDoc
)
{
attrs
=
aDoc
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
;
}
for
(
auto
corsMode
:
AllCORSModes
(
)
)
{
ImageCacheKey
key
(
aURI
corsMode
attrs
aDoc
)
;
RemoveFromCache
(
key
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
imgLoader
:
:
FindEntryProperties
(
nsIURI
*
uri
Document
*
aDoc
nsIProperties
*
*
_retval
)
{
*
_retval
=
nullptr
;
OriginAttributes
attrs
;
if
(
aDoc
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aDoc
-
>
NodePrincipal
(
)
;
if
(
principal
)
{
attrs
=
principal
-
>
OriginAttributesRef
(
)
;
}
}
for
(
auto
corsMode
:
AllCORSModes
(
)
)
{
ImageCacheKey
key
(
uri
corsMode
attrs
aDoc
)
;
RefPtr
<
imgCacheEntry
>
entry
;
if
(
!
mCache
.
Get
(
key
getter_AddRefs
(
entry
)
)
|
|
!
entry
)
{
continue
;
}
if
(
mCacheTracker
&
&
entry
-
>
HasNoProxies
(
)
)
{
mCacheTracker
-
>
MarkUsed
(
entry
)
;
}
RefPtr
<
imgRequest
>
request
=
entry
-
>
GetRequest
(
)
;
if
(
request
)
{
nsCOMPtr
<
nsIProperties
>
properties
=
request
-
>
Properties
(
)
;
properties
.
forget
(
_retval
)
;
return
NS_OK
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
imgLoader
:
:
ClearCacheForControlledDocument
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
aDoc
)
;
AutoTArray
<
RefPtr
<
imgCacheEntry
>
128
>
entriesToBeRemoved
;
for
(
const
auto
&
entry
:
mCache
)
{
const
auto
&
key
=
entry
.
GetKey
(
)
;
if
(
key
.
ControlledDocument
(
)
=
=
aDoc
)
{
entriesToBeRemoved
.
AppendElement
(
entry
.
GetData
(
)
)
;
}
}
for
(
auto
&
entry
:
entriesToBeRemoved
)
{
if
(
!
RemoveFromCache
(
entry
)
)
{
NS_WARNING
(
"
Couldn
'
t
remove
an
entry
from
the
cache
in
"
"
ClearCacheForControlledDocument
(
)
\
n
"
)
;
}
}
}
void
imgLoader
:
:
Shutdown
(
)
{
NS_IF_RELEASE
(
gNormalLoader
)
;
gNormalLoader
=
nullptr
;
NS_IF_RELEASE
(
gPrivateBrowsingLoader
)
;
gPrivateBrowsingLoader
=
nullptr
;
}
bool
imgLoader
:
:
PutIntoCache
(
const
ImageCacheKey
&
aKey
imgCacheEntry
*
entry
)
{
LOG_STATIC_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
PutIntoCache
"
"
uri
"
aKey
.
URI
(
)
)
;
RefPtr
<
imgCacheEntry
>
tmpCacheEntry
;
if
(
mCache
.
Get
(
aKey
getter_AddRefs
(
tmpCacheEntry
)
)
&
&
tmpCacheEntry
)
{
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
PutIntoCache
-
-
Element
already
in
the
cache
"
nullptr
)
)
;
RefPtr
<
imgRequest
>
tmpRequest
=
tmpCacheEntry
-
>
GetRequest
(
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
PutIntoCache
-
-
Replacing
cached
element
"
nullptr
)
)
;
RemoveFromCache
(
aKey
)
;
}
else
{
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
PutIntoCache
-
-
"
"
Element
NOT
already
in
the
cache
"
nullptr
)
)
;
}
mCache
.
InsertOrUpdate
(
aKey
RefPtr
{
entry
}
)
;
if
(
entry
-
>
Evicted
(
)
)
{
entry
-
>
SetEvicted
(
false
)
;
}
if
(
entry
-
>
HasNoProxies
(
)
)
{
nsresult
addrv
=
NS_OK
;
if
(
mCacheTracker
)
{
addrv
=
mCacheTracker
-
>
AddObject
(
entry
)
;
}
if
(
NS_SUCCEEDED
(
addrv
)
)
{
mCacheQueue
.
Push
(
entry
)
;
}
}
RefPtr
<
imgRequest
>
request
=
entry
-
>
GetRequest
(
)
;
request
-
>
SetIsInCache
(
true
)
;
RemoveFromUncachedImages
(
request
)
;
return
true
;
}
bool
imgLoader
:
:
SetHasNoProxies
(
imgRequest
*
aRequest
imgCacheEntry
*
aEntry
)
{
LOG_STATIC_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
SetHasNoProxies
"
"
uri
"
aRequest
-
>
CacheKey
(
)
.
URI
(
)
)
;
aEntry
-
>
SetHasNoProxies
(
true
)
;
if
(
aEntry
-
>
Evicted
(
)
)
{
return
false
;
}
nsresult
addrv
=
NS_OK
;
if
(
mCacheTracker
)
{
addrv
=
mCacheTracker
-
>
AddObject
(
aEntry
)
;
}
if
(
NS_SUCCEEDED
(
addrv
)
)
{
mCacheQueue
.
Push
(
aEntry
)
;
}
return
true
;
}
bool
imgLoader
:
:
SetHasProxies
(
imgRequest
*
aRequest
)
{
VerifyCacheSizes
(
)
;
const
ImageCacheKey
&
key
=
aRequest
-
>
CacheKey
(
)
;
LOG_STATIC_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
SetHasProxies
"
"
uri
"
key
.
URI
(
)
)
;
RefPtr
<
imgCacheEntry
>
entry
;
if
(
mCache
.
Get
(
key
getter_AddRefs
(
entry
)
)
&
&
entry
)
{
RefPtr
<
imgRequest
>
entryRequest
=
entry
-
>
GetRequest
(
)
;
if
(
entryRequest
=
=
aRequest
&
&
entry
-
>
HasNoProxies
(
)
)
{
mCacheQueue
.
Remove
(
entry
)
;
if
(
mCacheTracker
)
{
mCacheTracker
-
>
RemoveObject
(
entry
)
;
}
entry
-
>
SetHasNoProxies
(
false
)
;
return
true
;
}
}
return
false
;
}
void
imgLoader
:
:
CacheEntriesChanged
(
int32_t
aSizeDiff
)
{
if
(
mCacheQueue
.
GetNumElements
(
)
>
1
)
{
mCacheQueue
.
MarkDirty
(
)
;
}
mCacheQueue
.
UpdateSize
(
aSizeDiff
)
;
}
void
imgLoader
:
:
CheckCacheLimits
(
)
{
if
(
mCacheQueue
.
GetNumElements
(
)
=
=
0
)
{
NS_ASSERTION
(
mCacheQueue
.
GetSize
(
)
=
=
0
"
imgLoader
:
:
CheckCacheLimits
-
-
incorrect
cache
size
"
)
;
}
while
(
mCacheQueue
.
GetSize
(
)
>
sCacheMaxSize
)
{
RefPtr
<
imgCacheEntry
>
entry
(
mCacheQueue
.
Pop
(
)
)
;
NS_ASSERTION
(
entry
"
imgLoader
:
:
CheckCacheLimits
-
-
NULL
entry
pointer
"
)
;
if
(
MOZ_LOG_TEST
(
gImgLog
LogLevel
:
:
Debug
)
)
{
RefPtr
<
imgRequest
>
req
=
entry
-
>
GetRequest
(
)
;
if
(
req
)
{
LOG_STATIC_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
CheckCacheLimits
"
"
entry
"
req
-
>
CacheKey
(
)
.
URI
(
)
)
;
}
}
if
(
entry
)
{
RemoveFromCache
(
entry
QueueState
:
:
AlreadyRemoved
)
;
}
}
}
bool
imgLoader
:
:
ValidateRequestWithNewChannel
(
imgRequest
*
request
nsIURI
*
aURI
nsIURI
*
aInitialDocumentURI
nsIReferrerInfo
*
aReferrerInfo
nsILoadGroup
*
aLoadGroup
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
uint64_t
aInnerWindowId
nsLoadFlags
aLoadFlags
nsContentPolicyType
aLoadPolicyType
imgRequestProxy
*
*
aProxyRequest
nsIPrincipal
*
aTriggeringPrincipal
CORSMode
aCORSMode
bool
aLinkPreload
uint64_t
aEarlyHintPreloaderId
FetchPriority
aFetchPriority
bool
*
aNewChannelCreated
)
{
nsresult
rv
;
if
(
imgCacheValidator
*
validator
=
request
-
>
GetValidator
(
)
)
{
rv
=
CreateNewProxyForRequest
(
request
aURI
aLoadGroup
aLoadingDocument
aObserver
aLoadFlags
aProxyRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
*
aProxyRequest
)
{
imgRequestProxy
*
proxy
=
static_cast
<
imgRequestProxy
*
>
(
*
aProxyRequest
)
;
proxy
-
>
MarkValidating
(
)
;
if
(
aLinkPreload
)
{
MOZ_ASSERT
(
aLoadingDocument
)
;
auto
preloadKey
=
PreloadHashKey
:
:
CreateAsImage
(
aURI
aTriggeringPrincipal
aCORSMode
)
;
proxy
-
>
NotifyOpen
(
preloadKey
aLoadingDocument
true
)
;
}
validator
-
>
AddProxy
(
proxy
)
;
}
return
true
;
}
nsCOMPtr
<
nsIChannel
>
newChannel
;
bool
forcePrincipalCheck
;
rv
=
NewImageChannel
(
getter_AddRefs
(
newChannel
)
&
forcePrincipalCheck
aURI
aInitialDocumentURI
aCORSMode
aReferrerInfo
aLoadGroup
aLoadFlags
aLoadPolicyType
aTriggeringPrincipal
aLoadingDocument
mRespectPrivacy
aEarlyHintPreloaderId
aFetchPriority
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
aNewChannelCreated
)
{
*
aNewChannelCreated
=
true
;
}
RefPtr
<
imgRequestProxy
>
req
;
rv
=
CreateNewProxyForRequest
(
request
aURI
aLoadGroup
aLoadingDocument
aObserver
aLoadFlags
getter_AddRefs
(
req
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
RefPtr
<
nsProgressNotificationProxy
>
progressproxy
=
new
nsProgressNotificationProxy
(
newChannel
req
)
;
if
(
!
progressproxy
)
{
return
false
;
}
RefPtr
<
imgCacheValidator
>
hvc
=
new
imgCacheValidator
(
progressproxy
this
request
aLoadingDocument
aInnerWindowId
forcePrincipalCheck
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
static_cast
<
nsIThreadRetargetableStreamListener
*
>
(
hvc
)
;
NS_ENSURE_TRUE
(
listener
false
)
;
newChannel
-
>
SetNotificationCallbacks
(
hvc
)
;
request
-
>
SetValidator
(
hvc
)
;
req
-
>
MarkValidating
(
)
;
if
(
aLinkPreload
)
{
MOZ_ASSERT
(
aLoadingDocument
)
;
auto
preloadKey
=
PreloadHashKey
:
:
CreateAsImage
(
aURI
aTriggeringPrincipal
aCORSMode
)
;
req
-
>
NotifyOpen
(
preloadKey
aLoadingDocument
true
)
;
}
hvc
-
>
AddProxy
(
req
)
;
mozilla
:
:
net
:
:
PredictorLearn
(
aURI
aInitialDocumentURI
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
aLoadGroup
)
;
rv
=
newChannel
-
>
AsyncOpen
(
listener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
req
-
>
CancelAndForgetObserver
(
rv
)
;
req
-
>
NotifyStart
(
newChannel
)
;
req
-
>
NotifyStop
(
rv
)
;
return
false
;
}
req
.
forget
(
aProxyRequest
)
;
return
true
;
}
void
imgLoader
:
:
NotifyObserversForCachedImage
(
imgCacheEntry
*
aEntry
imgRequest
*
request
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
Document
*
aLoadingDocument
nsIPrincipal
*
aTriggeringPrincipal
CORSMode
aCORSMode
uint64_t
aEarlyHintPreloaderId
FetchPriority
aFetchPriority
)
{
if
(
aEntry
-
>
HasNotified
(
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
;
if
(
!
obsService
-
>
HasObservers
(
"
http
-
on
-
image
-
cache
-
response
"
)
)
{
return
;
}
aEntry
-
>
SetHasNotified
(
)
;
nsCOMPtr
<
nsIChannel
>
newChannel
;
bool
forcePrincipalCheck
;
nsresult
rv
=
NewImageChannel
(
getter_AddRefs
(
newChannel
)
&
forcePrincipalCheck
aURI
nullptr
aCORSMode
aReferrerInfo
nullptr
0
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
aTriggeringPrincipal
aLoadingDocument
mRespectPrivacy
aEarlyHintPreloaderId
aFetchPriority
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
RefPtr
<
HttpBaseChannel
>
httpBaseChannel
=
do_QueryObject
(
newChannel
)
;
if
(
httpBaseChannel
)
{
httpBaseChannel
-
>
SetDummyChannelForCachedResource
(
)
;
newChannel
-
>
SetContentType
(
nsDependentCString
(
request
-
>
GetMimeType
(
)
)
)
;
RefPtr
<
mozilla
:
:
image
:
:
Image
>
image
=
request
-
>
GetImage
(
)
;
if
(
image
)
{
newChannel
-
>
SetContentLength
(
aEntry
-
>
GetDataSize
(
)
)
;
}
obsService
-
>
NotifyObservers
(
newChannel
"
http
-
on
-
image
-
cache
-
response
"
nullptr
)
;
}
}
bool
imgLoader
:
:
ValidateEntry
(
imgCacheEntry
*
aEntry
nsIURI
*
aURI
nsIURI
*
aInitialDocumentURI
nsIReferrerInfo
*
aReferrerInfo
nsILoadGroup
*
aLoadGroup
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
nsLoadFlags
aLoadFlags
nsContentPolicyType
aLoadPolicyType
bool
aCanMakeNewChannel
bool
*
aNewChannelCreated
imgRequestProxy
*
*
aProxyRequest
nsIPrincipal
*
aTriggeringPrincipal
CORSMode
aCORSMode
bool
aLinkPreload
uint64_t
aEarlyHintPreloaderId
FetchPriority
aFetchPriority
)
{
LOG_SCOPE
(
gImgLog
"
imgLoader
:
:
ValidateEntry
"
)
;
bool
hasExpired
=
aEntry
-
>
GetExpiryTime
(
)
.
IsExpired
(
)
;
if
(
nsCOMPtr
<
nsIFileURL
>
fileUrl
=
do_QueryInterface
(
aURI
)
)
{
uint32_t
lastModTime
=
aEntry
-
>
GetLoadTime
(
)
;
nsCOMPtr
<
nsIFile
>
theFile
;
if
(
NS_SUCCEEDED
(
fileUrl
-
>
GetFile
(
getter_AddRefs
(
theFile
)
)
)
)
{
PRTime
fileLastMod
;
if
(
NS_SUCCEEDED
(
theFile
-
>
GetLastModifiedTime
(
&
fileLastMod
)
)
)
{
fileLastMod
*
=
1000
;
hasExpired
=
SecondsFromPRTime
(
(
PRTime
)
fileLastMod
)
>
lastModTime
;
}
}
}
RefPtr
<
imgRequest
>
request
(
aEntry
-
>
GetRequest
(
)
)
;
if
(
!
request
)
{
return
false
;
}
if
(
!
ValidateSecurityInfo
(
request
aEntry
-
>
ForcePrincipalCheck
(
)
aCORSMode
aTriggeringPrincipal
aLoadingDocument
aLoadPolicyType
)
)
{
return
false
;
}
if
(
aURI
-
>
SchemeIs
(
"
data
"
)
&
&
!
(
aLoadFlags
&
nsIRequest
:
:
LOAD_BYPASS_CACHE
)
)
{
return
true
;
}
bool
validateRequest
=
false
;
if
(
!
request
-
>
CanReuseWithoutValidation
(
aLoadingDocument
)
)
{
if
(
aLoadFlags
&
nsIRequest
:
:
LOAD_BYPASS_CACHE
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
ImageCache
)
)
)
{
if
(
ChaosMode
:
:
randomUint32LessThan
(
4
)
<
1
)
{
return
false
;
}
}
validateRequest
=
ShouldRevalidateEntry
(
aEntry
aLoadFlags
hasExpired
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
imgLoader
:
:
ValidateEntry
validating
cache
entry
.
"
"
validateRequest
=
%
d
"
validateRequest
)
)
;
}
else
if
(
!
aLoadingDocument
&
&
MOZ_LOG_TEST
(
gImgLog
LogLevel
:
:
Debug
)
)
{
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
imgLoader
:
:
ValidateEntry
BYPASSING
cache
validation
for
%
s
"
"
because
of
NULL
loading
document
"
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
const
bool
requestComplete
=
[
&
]
{
RefPtr
<
ProgressTracker
>
tracker
;
RefPtr
<
mozilla
:
:
image
:
:
Image
>
image
=
request
-
>
GetImage
(
)
;
if
(
image
)
{
tracker
=
image
-
>
GetProgressTracker
(
)
;
}
else
{
tracker
=
request
-
>
GetProgressTracker
(
)
;
}
return
tracker
&
&
tracker
-
>
GetProgress
(
)
&
(
FLAG_LOAD_COMPLETE
|
FLAG_HAS_ERROR
)
;
}
(
)
;
if
(
!
requestComplete
)
{
return
true
;
}
if
(
validateRequest
&
&
aCanMakeNewChannel
)
{
LOG_SCOPE
(
gImgLog
"
imgLoader
:
:
ValidateRequest
|
cache
hit
|
must
validate
"
)
;
uint64_t
innerWindowID
=
aLoadingDocument
?
aLoadingDocument
-
>
InnerWindowID
(
)
:
0
;
return
ValidateRequestWithNewChannel
(
request
aURI
aInitialDocumentURI
aReferrerInfo
aLoadGroup
aObserver
aLoadingDocument
innerWindowID
aLoadFlags
aLoadPolicyType
aProxyRequest
aTriggeringPrincipal
aCORSMode
aLinkPreload
aEarlyHintPreloaderId
aFetchPriority
aNewChannelCreated
)
;
}
if
(
!
validateRequest
)
{
NotifyObserversForCachedImage
(
aEntry
request
aURI
aReferrerInfo
aLoadingDocument
aTriggeringPrincipal
aCORSMode
aEarlyHintPreloaderId
aFetchPriority
)
;
}
return
!
validateRequest
;
}
bool
imgLoader
:
:
RemoveFromCache
(
const
ImageCacheKey
&
aKey
)
{
LOG_STATIC_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
RemoveFromCache
"
"
uri
"
aKey
.
URI
(
)
)
;
RefPtr
<
imgCacheEntry
>
entry
;
mCache
.
Remove
(
aKey
getter_AddRefs
(
entry
)
)
;
if
(
entry
)
{
MOZ_ASSERT
(
!
entry
-
>
Evicted
(
)
"
Evicting
an
already
-
evicted
cache
entry
!
"
)
;
if
(
entry
-
>
HasNoProxies
(
)
)
{
if
(
mCacheTracker
)
{
mCacheTracker
-
>
RemoveObject
(
entry
)
;
}
mCacheQueue
.
Remove
(
entry
)
;
}
entry
-
>
SetEvicted
(
true
)
;
RefPtr
<
imgRequest
>
request
=
entry
-
>
GetRequest
(
)
;
request
-
>
SetIsInCache
(
false
)
;
AddToUncachedImages
(
request
)
;
return
true
;
}
return
false
;
}
bool
imgLoader
:
:
RemoveFromCache
(
imgCacheEntry
*
entry
QueueState
aQueueState
)
{
LOG_STATIC_FUNC
(
gImgLog
"
imgLoader
:
:
RemoveFromCache
entry
"
)
;
RefPtr
<
imgRequest
>
request
=
entry
-
>
GetRequest
(
)
;
if
(
request
)
{
const
ImageCacheKey
&
key
=
request
-
>
CacheKey
(
)
;
LOG_STATIC_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
RemoveFromCache
"
"
entry
'
s
uri
"
key
.
URI
(
)
)
;
mCache
.
Remove
(
key
)
;
if
(
entry
-
>
HasNoProxies
(
)
)
{
LOG_STATIC_FUNC
(
gImgLog
"
imgLoader
:
:
RemoveFromCache
removing
from
tracker
"
)
;
if
(
mCacheTracker
)
{
mCacheTracker
-
>
RemoveObject
(
entry
)
;
}
MOZ_ASSERT_IF
(
aQueueState
=
=
QueueState
:
:
AlreadyRemoved
!
mCacheQueue
.
Contains
(
entry
)
)
;
if
(
aQueueState
=
=
QueueState
:
:
MaybeExists
)
{
mCacheQueue
.
Remove
(
entry
)
;
}
}
entry
-
>
SetEvicted
(
true
)
;
request
-
>
SetIsInCache
(
false
)
;
AddToUncachedImages
(
request
)
;
return
true
;
}
return
false
;
}
nsresult
imgLoader
:
:
ClearImageCache
(
ClearOptions
aOptions
)
{
const
bool
chromeOnly
=
aOptions
.
contains
(
ClearOption
:
:
ChromeOnly
)
;
const
auto
ShouldRemove
=
[
&
]
(
imgCacheEntry
*
aEntry
)
{
if
(
chromeOnly
)
{
RefPtr
<
imgRequest
>
request
=
aEntry
-
>
GetRequest
(
)
;
if
(
!
request
|
|
!
request
-
>
CacheKey
(
)
.
URI
(
)
-
>
SchemeIs
(
"
chrome
"
)
)
{
return
false
;
}
}
return
true
;
}
;
if
(
aOptions
.
contains
(
ClearOption
:
:
UnusedOnly
)
)
{
LOG_STATIC_FUNC
(
gImgLog
"
imgLoader
:
:
ClearImageCache
queue
"
)
;
nsTArray
<
RefPtr
<
imgCacheEntry
>
>
entries
(
mCacheQueue
.
GetNumElements
(
)
)
;
for
(
auto
&
entry
:
mCacheQueue
)
{
if
(
ShouldRemove
(
entry
)
)
{
entries
.
AppendElement
(
entry
)
;
}
}
for
(
auto
&
entry
:
entries
)
{
if
(
!
RemoveFromCache
(
entry
)
)
{
return
NS_ERROR_FAILURE
;
}
}
MOZ_ASSERT
(
chromeOnly
|
|
mCacheQueue
.
GetNumElements
(
)
=
=
0
)
;
return
NS_OK
;
}
LOG_STATIC_FUNC
(
gImgLog
"
imgLoader
:
:
ClearImageCache
table
"
)
;
const
auto
entries
=
ToTArray
<
nsTArray
<
RefPtr
<
imgCacheEntry
>
>
>
(
mCache
.
Values
(
)
)
;
for
(
const
auto
&
entry
:
entries
)
{
if
(
!
ShouldRemove
(
entry
)
)
{
continue
;
}
if
(
!
RemoveFromCache
(
entry
)
)
{
return
NS_ERROR_FAILURE
;
}
}
MOZ_ASSERT
(
chromeOnly
|
|
mCache
.
IsEmpty
(
)
)
;
return
NS_OK
;
}
void
imgLoader
:
:
AddToUncachedImages
(
imgRequest
*
aRequest
)
{
MutexAutoLock
lock
(
mUncachedImagesMutex
)
;
mUncachedImages
.
Insert
(
aRequest
)
;
}
void
imgLoader
:
:
RemoveFromUncachedImages
(
imgRequest
*
aRequest
)
{
MutexAutoLock
lock
(
mUncachedImagesMutex
)
;
mUncachedImages
.
Remove
(
aRequest
)
;
}
#
define
LOAD_FLAGS_CACHE_MASK
\
(
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
nsIRequest
:
:
LOAD_FROM_CACHE
)
#
define
LOAD_FLAGS_VALIDATE_MASK
\
(
nsIRequest
:
:
VALIDATE_ALWAYS
|
nsIRequest
:
:
VALIDATE_NEVER
|
\
nsIRequest
:
:
VALIDATE_ONCE_PER_SESSION
)
NS_IMETHODIMP
imgLoader
:
:
LoadImageXPCOM
(
nsIURI
*
aURI
nsIURI
*
aInitialDocumentURI
nsIReferrerInfo
*
aReferrerInfo
nsIPrincipal
*
aTriggeringPrincipal
nsILoadGroup
*
aLoadGroup
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
nsLoadFlags
aLoadFlags
nsISupports
*
aCacheKey
nsContentPolicyType
aContentPolicyType
imgIRequest
*
*
_retval
)
{
if
(
!
aContentPolicyType
)
{
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
}
imgRequestProxy
*
proxy
;
nsresult
rv
=
LoadImage
(
aURI
aInitialDocumentURI
aReferrerInfo
aTriggeringPrincipal
0
aLoadGroup
aObserver
aLoadingDocument
aLoadingDocument
aLoadFlags
aCacheKey
aContentPolicyType
u
"
"
_ns
false
false
0
FetchPriority
:
:
Auto
&
proxy
)
;
*
_retval
=
proxy
;
return
rv
;
}
static
void
MakeRequestStaticIfNeeded
(
Document
*
aLoadingDocument
imgRequestProxy
*
*
aProxyAboutToGetReturned
)
{
if
(
!
aLoadingDocument
|
|
!
aLoadingDocument
-
>
IsStaticDocument
(
)
)
{
return
;
}
if
(
!
*
aProxyAboutToGetReturned
)
{
return
;
}
RefPtr
<
imgRequestProxy
>
proxy
=
dont_AddRef
(
*
aProxyAboutToGetReturned
)
;
*
aProxyAboutToGetReturned
=
nullptr
;
RefPtr
<
imgRequestProxy
>
staticProxy
=
proxy
-
>
GetStaticRequest
(
aLoadingDocument
)
;
if
(
staticProxy
!
=
proxy
)
{
proxy
-
>
CancelAndForgetObserver
(
NS_BINDING_ABORTED
)
;
proxy
=
std
:
:
move
(
staticProxy
)
;
}
proxy
.
forget
(
aProxyAboutToGetReturned
)
;
}
bool
imgLoader
:
:
IsImageAvailable
(
nsIURI
*
aURI
nsIPrincipal
*
aTriggeringPrincipal
CORSMode
aCORSMode
Document
*
aDocument
)
{
ImageCacheKey
key
(
aURI
aCORSMode
aTriggeringPrincipal
-
>
OriginAttributesRef
(
)
aDocument
)
;
RefPtr
<
imgCacheEntry
>
entry
;
if
(
!
mCache
.
Get
(
key
getter_AddRefs
(
entry
)
)
|
|
!
entry
)
{
return
false
;
}
RefPtr
<
imgRequest
>
request
=
entry
-
>
GetRequest
(
)
;
if
(
!
request
)
{
return
false
;
}
if
(
nsCOMPtr
<
nsILoadGroup
>
docLoadGroup
=
aDocument
-
>
GetDocumentLoadGroup
(
)
)
{
nsLoadFlags
requestFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
docLoadGroup
-
>
GetLoadFlags
(
&
requestFlags
)
;
if
(
requestFlags
&
nsIRequest
:
:
LOAD_BYPASS_CACHE
)
{
return
false
;
}
}
return
ValidateCORSMode
(
request
false
aCORSMode
aTriggeringPrincipal
)
;
}
nsresult
imgLoader
:
:
LoadImage
(
nsIURI
*
aURI
nsIURI
*
aInitialDocumentURI
nsIReferrerInfo
*
aReferrerInfo
nsIPrincipal
*
aTriggeringPrincipal
uint64_t
aRequestContextID
nsILoadGroup
*
aLoadGroup
imgINotificationObserver
*
aObserver
nsINode
*
aContext
Document
*
aLoadingDocument
nsLoadFlags
aLoadFlags
nsISupports
*
aCacheKey
nsContentPolicyType
aContentPolicyType
const
nsAString
&
initiatorType
bool
aUseUrgentStartForChannel
bool
aLinkPreload
uint64_t
aEarlyHintPreloaderId
FetchPriority
aFetchPriority
imgRequestProxy
*
*
_retval
)
{
VerifyCacheSizes
(
)
;
NS_ASSERTION
(
aURI
"
imgLoader
:
:
LoadImage
-
-
NULL
URI
pointer
"
)
;
if
(
!
aURI
)
{
return
NS_ERROR_NULL_POINTER
;
}
auto
makeStaticIfNeeded
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MakeRequestStaticIfNeeded
(
aLoadingDocument
_retval
)
;
}
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
imgLoader
:
:
LoadImage
"
NETWORK
aURI
-
>
GetSpecOrDefault
(
)
)
;
LOG_SCOPE_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
LoadImage
"
"
aURI
"
aURI
)
;
*
_retval
=
nullptr
;
RefPtr
<
imgRequest
>
request
;
nsresult
rv
;
nsLoadFlags
requestFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
#
ifdef
DEBUG
bool
isPrivate
=
false
;
if
(
aLoadingDocument
)
{
isPrivate
=
nsContentUtils
:
:
IsInPrivateBrowsing
(
aLoadingDocument
)
;
}
else
if
(
aLoadGroup
)
{
isPrivate
=
nsContentUtils
:
:
IsInPrivateBrowsing
(
aLoadGroup
)
;
}
MOZ_ASSERT
(
isPrivate
=
=
mRespectPrivacy
)
;
if
(
aLoadingDocument
)
{
nsCOMPtr
<
nsILoadGroup
>
docLoadGroup
=
aLoadingDocument
-
>
GetDocumentLoadGroup
(
)
;
MOZ_ASSERT
(
docLoadGroup
=
=
aLoadGroup
)
;
}
#
endif
if
(
aLoadGroup
)
{
aLoadGroup
-
>
GetLoadFlags
(
&
requestFlags
)
;
}
if
(
aLoadFlags
&
LOAD_FLAGS_CACHE_MASK
)
{
requestFlags
=
(
requestFlags
&
~
LOAD_FLAGS_CACHE_MASK
)
|
(
aLoadFlags
&
LOAD_FLAGS_CACHE_MASK
)
;
}
if
(
aLoadFlags
&
LOAD_FLAGS_VALIDATE_MASK
)
{
requestFlags
=
(
requestFlags
&
~
LOAD_FLAGS_VALIDATE_MASK
)
|
(
aLoadFlags
&
LOAD_FLAGS_VALIDATE_MASK
)
;
}
if
(
aLoadFlags
&
nsIRequest
:
:
LOAD_BACKGROUND
)
{
requestFlags
|
=
nsIRequest
:
:
LOAD_BACKGROUND
;
}
if
(
aLinkPreload
)
{
requestFlags
|
=
nsIRequest
:
:
LOAD_BACKGROUND
;
}
CORSMode
corsmode
=
CORS_NONE
;
if
(
aLoadFlags
&
imgILoader
:
:
LOAD_CORS_ANONYMOUS
)
{
corsmode
=
CORS_ANONYMOUS
;
}
else
if
(
aLoadFlags
&
imgILoader
:
:
LOAD_CORS_USE_CREDENTIALS
)
{
corsmode
=
CORS_USE_CREDENTIALS
;
}
if
(
!
aLinkPreload
&
&
aLoadingDocument
)
{
MOZ_ASSERT
(
!
aEarlyHintPreloaderId
)
;
auto
key
=
PreloadHashKey
:
:
CreateAsImage
(
aURI
aTriggeringPrincipal
corsmode
)
;
if
(
RefPtr
<
PreloaderBase
>
preload
=
aLoadingDocument
-
>
Preloads
(
)
.
LookupPreload
(
key
)
)
{
RefPtr
<
imgRequestProxy
>
proxy
=
do_QueryObject
(
preload
)
;
MOZ_ASSERT
(
proxy
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
LoadImage
-
-
preloaded
[
proxy
=
%
p
]
"
"
[
document
=
%
p
]
\
n
"
this
proxy
.
get
(
)
aLoadingDocument
)
)
;
proxy
-
>
RemoveSelf
(
aLoadingDocument
)
;
proxy
-
>
NotifyUsage
(
aLoadingDocument
)
;
imgRequest
*
request
=
proxy
-
>
GetOwner
(
)
;
nsresult
rv
=
CreateNewProxyForRequest
(
request
aURI
aLoadGroup
aLoadingDocument
aObserver
requestFlags
_retval
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
imgRequestProxy
*
newProxy
=
*
_retval
;
if
(
imgCacheValidator
*
validator
=
request
-
>
GetValidator
(
)
)
{
newProxy
-
>
MarkValidating
(
)
;
validator
-
>
AddProxy
(
newProxy
)
;
}
else
{
newProxy
-
>
AddToLoadGroup
(
)
;
newProxy
-
>
NotifyListener
(
)
;
}
return
NS_OK
;
}
}
RefPtr
<
imgCacheEntry
>
entry
;
OriginAttributes
attrs
;
if
(
aTriggeringPrincipal
)
{
attrs
=
aTriggeringPrincipal
-
>
OriginAttributesRef
(
)
;
}
ImageCacheKey
key
(
aURI
corsmode
attrs
aLoadingDocument
)
;
if
(
mCache
.
Get
(
key
getter_AddRefs
(
entry
)
)
&
&
entry
)
{
bool
newChannelCreated
=
false
;
if
(
ValidateEntry
(
entry
aURI
aInitialDocumentURI
aReferrerInfo
aLoadGroup
aObserver
aLoadingDocument
requestFlags
aContentPolicyType
true
&
newChannelCreated
_retval
aTriggeringPrincipal
corsmode
aLinkPreload
aEarlyHintPreloaderId
aFetchPriority
)
)
{
request
=
entry
-
>
GetRequest
(
)
;
if
(
entry
-
>
HasNoProxies
(
)
)
{
LOG_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
LoadImage
(
)
adding
proxyless
entry
"
"
uri
"
key
.
URI
(
)
)
;
MOZ_ASSERT
(
!
request
-
>
HasCacheEntry
(
)
"
Proxyless
entry
'
s
request
has
cache
entry
!
"
)
;
request
-
>
SetCacheEntry
(
entry
)
;
if
(
mCacheTracker
&
&
entry
-
>
GetExpirationState
(
)
-
>
IsTracked
(
)
)
{
mCacheTracker
-
>
MarkUsed
(
entry
)
;
}
}
entry
-
>
Touch
(
)
;
if
(
!
newChannelCreated
)
{
DebugOnly
<
bool
>
shouldLoad
=
ShouldLoadCachedImage
(
request
aLoadingDocument
aTriggeringPrincipal
aContentPolicyType
true
)
;
MOZ_ASSERT
(
shouldLoad
)
;
}
}
else
{
entry
=
nullptr
;
}
}
nsCOMPtr
<
nsIChannel
>
newChannel
;
if
(
!
request
)
{
LOG_SCOPE
(
gImgLog
"
imgLoader
:
:
LoadImage
|
cache
miss
|
"
)
;
bool
forcePrincipalCheck
;
rv
=
NewImageChannel
(
getter_AddRefs
(
newChannel
)
&
forcePrincipalCheck
aURI
aInitialDocumentURI
corsmode
aReferrerInfo
aLoadGroup
requestFlags
aContentPolicyType
aTriggeringPrincipal
aContext
mRespectPrivacy
aEarlyHintPreloaderId
aFetchPriority
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
NS_UsePrivateBrowsing
(
newChannel
)
=
=
mRespectPrivacy
)
;
NewRequestAndEntry
(
forcePrincipalCheck
this
key
getter_AddRefs
(
request
)
getter_AddRefs
(
entry
)
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
LoadImage
-
-
Created
new
imgRequest
"
"
[
request
=
%
p
]
\
n
"
this
request
.
get
(
)
)
)
;
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
newChannel
)
)
;
if
(
cos
)
{
if
(
aUseUrgentStartForChannel
&
&
!
aLinkPreload
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
}
if
(
StaticPrefs
:
:
image_priority_incremental
(
)
)
{
cos
-
>
SetIncremental
(
true
)
;
}
if
(
StaticPrefs
:
:
network_http_tailing_enabled
(
)
&
&
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Throttleable
|
nsIClassOfService
:
:
Tail
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
newChannel
)
)
;
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
SetRequestContextID
(
aRequestContextID
)
;
}
}
}
nsCOMPtr
<
nsILoadGroup
>
channelLoadGroup
;
newChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
channelLoadGroup
)
)
;
rv
=
request
-
>
Init
(
aURI
aURI
false
channelLoadGroup
newChannel
entry
aLoadingDocument
aTriggeringPrincipal
corsmode
aReferrerInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
newChannel
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
initiatorType
)
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
=
new
ProxyListener
(
request
.
get
(
)
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
LoadImage
-
-
Calling
channel
-
>
AsyncOpen
(
)
\
n
"
this
)
)
;
mozilla
:
:
net
:
:
PredictorLearn
(
aURI
aInitialDocumentURI
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
aLoadGroup
)
;
nsresult
openRes
;
openRes
=
newChannel
-
>
AsyncOpen
(
listener
)
;
if
(
NS_FAILED
(
openRes
)
)
{
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgLoader
:
:
LoadImage
-
-
AsyncOpen
(
)
failed
:
0x
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
openRes
)
)
)
;
request
-
>
CancelAndAbort
(
openRes
)
;
return
openRes
;
}
PutIntoCache
(
key
entry
)
;
}
else
{
LOG_MSG_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
LoadImage
|
cache
hit
|
"
"
request
"
request
)
;
}
if
(
!
*
_retval
)
{
request
-
>
SetLoadId
(
aLoadingDocument
)
;
LOG_MSG
(
gImgLog
"
imgLoader
:
:
LoadImage
"
"
creating
proxy
request
.
"
)
;
rv
=
CreateNewProxyForRequest
(
request
aURI
aLoadGroup
aLoadingDocument
aObserver
requestFlags
_retval
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
imgRequestProxy
*
proxy
=
*
_retval
;
if
(
newChannel
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
requestor
(
new
nsProgressNotificationProxy
(
newChannel
proxy
)
)
;
if
(
!
requestor
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
newChannel
-
>
SetNotificationCallbacks
(
requestor
)
;
}
if
(
aLinkPreload
)
{
MOZ_ASSERT
(
aLoadingDocument
)
;
auto
preloadKey
=
PreloadHashKey
:
:
CreateAsImage
(
aURI
aTriggeringPrincipal
corsmode
)
;
proxy
-
>
NotifyOpen
(
preloadKey
aLoadingDocument
true
)
;
}
proxy
-
>
AddToLoadGroup
(
)
;
if
(
!
newChannel
)
{
proxy
-
>
NotifyListener
(
)
;
}
return
rv
;
}
NS_ASSERTION
(
*
_retval
"
imgLoader
:
:
LoadImage
-
-
no
return
value
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
imgLoader
:
:
LoadImageWithChannelXPCOM
(
nsIChannel
*
channel
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
nsIStreamListener
*
*
listener
imgIRequest
*
*
_retval
)
{
nsresult
result
;
imgRequestProxy
*
proxy
;
result
=
LoadImageWithChannel
(
channel
aObserver
aLoadingDocument
listener
&
proxy
)
;
*
_retval
=
proxy
;
return
result
;
}
nsresult
imgLoader
:
:
LoadImageWithChannel
(
nsIChannel
*
channel
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
nsIStreamListener
*
*
listener
imgRequestProxy
*
*
_retval
)
{
NS_ASSERTION
(
channel
"
imgLoader
:
:
LoadImageWithChannel
-
-
NULL
channel
pointer
"
)
;
MOZ_ASSERT
(
NS_UsePrivateBrowsing
(
channel
)
=
=
mRespectPrivacy
)
;
auto
makeStaticIfNeeded
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MakeRequestStaticIfNeeded
(
aLoadingDocument
_retval
)
;
}
)
;
LOG_SCOPE
(
gImgLog
"
imgLoader
:
:
LoadImageWithChannel
"
)
;
RefPtr
<
imgRequest
>
request
;
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
OriginAttributes
attrs
=
loadInfo
-
>
GetOriginAttributes
(
)
;
const
auto
corsMode
=
CORS_NONE
;
ImageCacheKey
key
(
uri
corsMode
attrs
aLoadingDocument
)
;
nsLoadFlags
requestFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
channel
-
>
GetLoadFlags
(
&
requestFlags
)
;
RefPtr
<
imgCacheEntry
>
entry
;
if
(
requestFlags
&
nsIRequest
:
:
LOAD_BYPASS_CACHE
)
{
RemoveFromCache
(
key
)
;
}
else
{
if
(
mCache
.
Get
(
key
getter_AddRefs
(
entry
)
)
&
&
entry
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
nsContentPolicyType
policyType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
if
(
ValidateEntry
(
entry
uri
nullptr
nullptr
nullptr
aObserver
aLoadingDocument
requestFlags
policyType
false
nullptr
nullptr
nullptr
corsMode
false
0
FetchPriority
:
:
Auto
)
)
{
request
=
entry
-
>
GetRequest
(
)
;
}
else
{
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChan
(
do_QueryInterface
(
channel
)
)
;
bool
bUseCacheCopy
;
if
(
cacheChan
)
{
cacheChan
-
>
IsFromCache
(
&
bUseCacheCopy
)
;
}
else
{
bUseCacheCopy
=
false
;
}
if
(
!
bUseCacheCopy
)
{
entry
=
nullptr
;
}
else
{
request
=
entry
-
>
GetRequest
(
)
;
}
}
if
(
request
&
&
entry
)
{
if
(
entry
-
>
HasNoProxies
(
)
)
{
LOG_FUNC_WITH_PARAM
(
gImgLog
"
imgLoader
:
:
LoadImageWithChannel
(
)
adding
proxyless
entry
"
"
uri
"
key
.
URI
(
)
)
;
MOZ_ASSERT
(
!
request
-
>
HasCacheEntry
(
)
"
Proxyless
entry
'
s
request
has
cache
entry
!
"
)
;
request
-
>
SetCacheEntry
(
entry
)
;
if
(
mCacheTracker
&
&
entry
-
>
GetExpirationState
(
)
-
>
IsTracked
(
)
)
{
mCacheTracker
-
>
MarkUsed
(
entry
)
;
}
}
}
}
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
channel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
#
ifdef
DEBUG
if
(
aLoadingDocument
)
{
nsCOMPtr
<
nsILoadGroup
>
docLoadGroup
=
aLoadingDocument
-
>
GetDocumentLoadGroup
(
)
;
MOZ_ASSERT
(
docLoadGroup
=
=
loadGroup
)
;
}
#
endif
requestFlags
&
=
nsIRequest
:
:
LOAD_REQUESTMASK
;
nsresult
rv
=
NS_OK
;
if
(
request
)
{
channel
-
>
Cancel
(
NS_ERROR_PARSED_DATA_CACHED
)
;
*
listener
=
nullptr
;
rv
=
CreateNewProxyForRequest
(
request
uri
loadGroup
aLoadingDocument
aObserver
requestFlags
_retval
)
;
static_cast
<
imgRequestProxy
*
>
(
*
_retval
)
-
>
NotifyListener
(
)
;
}
else
{
nsCOMPtr
<
nsIURI
>
originalURI
;
channel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
ImageCacheKey
originalURIKey
(
originalURI
corsMode
attrs
aLoadingDocument
)
;
NewRequestAndEntry
(
true
this
originalURIKey
getter_AddRefs
(
request
)
getter_AddRefs
(
entry
)
)
;
rv
=
request
-
>
Init
(
originalURI
uri
false
channel
channel
entry
aLoadingDocument
nullptr
corsMode
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
ProxyListener
>
pl
=
new
ProxyListener
(
static_cast
<
nsIStreamListener
*
>
(
request
.
get
(
)
)
)
;
pl
.
forget
(
listener
)
;
PutIntoCache
(
originalURIKey
entry
)
;
rv
=
CreateNewProxyForRequest
(
request
originalURI
loadGroup
aLoadingDocument
aObserver
requestFlags
_retval
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
(
*
_retval
)
-
>
AddToLoadGroup
(
)
;
return
rv
;
}
bool
imgLoader
:
:
SupportImageWithMimeType
(
const
nsACString
&
aMimeType
AcceptedMimeTypes
aAccept
)
{
nsAutoCString
mimeType
(
aMimeType
)
;
ToLowerCase
(
mimeType
)
;
if
(
aAccept
=
=
AcceptedMimeTypes
:
:
IMAGES_AND_DOCUMENTS
&
&
mimeType
.
EqualsLiteral
(
"
image
/
svg
+
xml
"
)
)
{
return
true
;
}
DecoderType
type
=
DecoderFactory
:
:
GetDecoderType
(
mimeType
.
get
(
)
)
;
return
type
!
=
DecoderType
:
:
UNKNOWN
;
}
NS_IMETHODIMP
imgLoader
:
:
GetMIMETypeFromContent
(
nsIRequest
*
aRequest
const
uint8_t
*
aContents
uint32_t
aLength
nsACString
&
aContentType
)
{
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
channel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
if
(
loadInfo
-
>
GetSkipContentSniffing
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
nsresult
rv
=
GetMimeTypeFromContent
(
(
const
char
*
)
aContents
aLength
aContentType
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
channel
&
&
XRE_IsParentProcess
(
)
)
{
if
(
RefPtr
<
mozilla
:
:
net
:
:
nsHttpChannel
>
httpChannel
=
do_QueryObject
(
channel
)
)
{
httpChannel
-
>
DisableIsOpaqueResponseAllowedAfterSniffCheck
(
mozilla
:
:
net
:
:
nsHttpChannel
:
:
SnifferType
:
:
Image
)
;
}
}
return
rv
;
}
nsresult
imgLoader
:
:
GetMimeTypeFromContent
(
const
char
*
aContents
uint32_t
aLength
nsACString
&
aContentType
)
{
nsAutoCString
detected
;
if
(
aLength
>
=
6
&
&
(
!
strncmp
(
aContents
"
GIF87a
"
6
)
|
|
!
strncmp
(
aContents
"
GIF89a
"
6
)
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_GIF
)
;
}
else
if
(
aLength
>
=
8
&
&
(
(
unsigned
char
)
aContents
[
0
]
=
=
0x89
&
&
(
unsigned
char
)
aContents
[
1
]
=
=
0x50
&
&
(
unsigned
char
)
aContents
[
2
]
=
=
0x4E
&
&
(
unsigned
char
)
aContents
[
3
]
=
=
0x47
&
&
(
unsigned
char
)
aContents
[
4
]
=
=
0x0D
&
&
(
unsigned
char
)
aContents
[
5
]
=
=
0x0A
&
&
(
unsigned
char
)
aContents
[
6
]
=
=
0x1A
&
&
(
unsigned
char
)
aContents
[
7
]
=
=
0x0A
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_PNG
)
;
}
else
if
(
aLength
>
=
3
&
&
(
(
unsigned
char
)
aContents
[
0
]
)
=
=
0xFF
&
&
(
(
unsigned
char
)
aContents
[
1
]
)
=
=
0xD8
&
&
(
(
unsigned
char
)
aContents
[
2
]
)
=
=
0xFF
)
{
aContentType
.
AssignLiteral
(
IMAGE_JPEG
)
;
}
else
if
(
aLength
>
=
5
&
&
(
(
unsigned
char
)
aContents
[
0
]
)
=
=
0x4a
&
&
(
(
unsigned
char
)
aContents
[
1
]
)
=
=
0x47
&
&
(
(
unsigned
char
)
aContents
[
4
]
)
=
=
0x00
)
{
aContentType
.
AssignLiteral
(
IMAGE_ART
)
;
}
else
if
(
aLength
>
=
2
&
&
!
strncmp
(
aContents
"
BM
"
2
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_BMP
)
;
}
else
if
(
aLength
>
=
4
&
&
(
!
memcmp
(
aContents
"
\
000
\
000
\
001
\
000
"
4
)
|
|
!
memcmp
(
aContents
"
\
000
\
000
\
002
\
000
"
4
)
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_ICO
)
;
}
else
if
(
aLength
>
=
12
&
&
!
memcmp
(
aContents
"
RIFF
"
4
)
&
&
!
memcmp
(
aContents
+
8
"
WEBP
"
4
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_WEBP
)
;
}
else
if
(
MatchesMP4
(
reinterpret_cast
<
const
uint8_t
*
>
(
aContents
)
aLength
detected
)
&
&
detected
.
Equals
(
IMAGE_AVIF
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_AVIF
)
;
}
else
if
(
(
aLength
>
=
2
&
&
!
memcmp
(
aContents
"
\
xFF
\
x0A
"
2
)
)
|
|
(
aLength
>
=
12
&
&
!
memcmp
(
aContents
"
\
x00
\
x00
\
x00
\
x0CJXL
\
x0D
\
x0A
\
x87
\
x0A
"
12
)
)
)
{
aContentType
.
AssignLiteral
(
IMAGE_JXL
)
;
}
else
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
}
#
include
"
nsIRequest
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
NS_IMPL_ISUPPORTS
(
ProxyListener
nsIStreamListener
nsIThreadRetargetableStreamListener
nsIRequestObserver
)
ProxyListener
:
:
ProxyListener
(
nsIStreamListener
*
dest
)
:
mDestListener
(
dest
)
{
}
ProxyListener
:
:
~
ProxyListener
(
)
=
default
;
NS_IMETHODIMP
ProxyListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
if
(
!
mDestListener
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
channel
)
{
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
channel
)
;
if
(
timedChannel
)
{
nsAutoString
type
;
timedChannel
-
>
GetInitiatorType
(
type
)
;
if
(
type
.
IsEmpty
(
)
)
{
timedChannel
-
>
SetInitiatorType
(
u
"
img
"
_ns
)
;
}
}
nsAutoCString
contentType
;
nsresult
rv
=
channel
-
>
GetContentType
(
contentType
)
;
if
(
!
contentType
.
IsEmpty
(
)
)
{
if
(
"
multipart
/
x
-
mixed
-
replace
"
_ns
.
Equals
(
contentType
)
)
{
nsCOMPtr
<
nsIStreamConverterService
>
convServ
(
do_GetService
(
"
mozilla
.
org
/
streamConverters
;
1
"
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIStreamListener
>
toListener
(
mDestListener
)
;
nsCOMPtr
<
nsIStreamListener
>
fromListener
;
rv
=
convServ
-
>
AsyncConvertData
(
"
multipart
/
x
-
mixed
-
replace
"
"
*
/
*
"
toListener
nullptr
getter_AddRefs
(
fromListener
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mDestListener
=
fromListener
;
}
}
}
}
}
return
mDestListener
-
>
OnStartRequest
(
aRequest
)
;
}
NS_IMETHODIMP
ProxyListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
status
)
{
if
(
!
mDestListener
)
{
return
NS_ERROR_FAILURE
;
}
return
mDestListener
-
>
OnStopRequest
(
aRequest
status
)
;
}
NS_IMETHODIMP
ProxyListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
inStr
uint64_t
sourceOffset
uint32_t
count
)
{
if
(
!
mDestListener
)
{
return
NS_ERROR_FAILURE
;
}
return
mDestListener
-
>
OnDataAvailable
(
aRequest
inStr
sourceOffset
count
)
;
}
NS_IMETHODIMP
ProxyListener
:
:
OnDataFinished
(
nsresult
aStatus
)
{
if
(
!
mDestListener
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mDestListener
)
;
if
(
retargetableListener
)
{
return
retargetableListener
-
>
OnDataFinished
(
aStatus
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ProxyListener
:
:
CheckListenerChain
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
!
"
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mDestListener
&
rv
)
;
if
(
retargetableListener
)
{
rv
=
retargetableListener
-
>
CheckListenerChain
(
)
;
}
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
ProxyListener
:
:
CheckListenerChain
%
s
[
this
=
%
p
listener
=
%
p
rv
=
%
"
PRIx32
"
]
"
(
NS_SUCCEEDED
(
rv
)
?
"
success
"
:
"
failure
"
)
this
(
nsIStreamListener
*
)
mDestListener
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
NS_IMPL_ISUPPORTS
(
imgCacheValidator
nsIStreamListener
nsIRequestObserver
nsIThreadRetargetableStreamListener
nsIChannelEventSink
nsIInterfaceRequestor
nsIAsyncVerifyRedirectCallback
)
imgCacheValidator
:
:
imgCacheValidator
(
nsProgressNotificationProxy
*
progress
imgLoader
*
loader
imgRequest
*
request
Document
*
aDocument
uint64_t
aInnerWindowId
bool
forcePrincipalCheckForCacheEntry
)
:
mProgressProxy
(
progress
)
mRequest
(
request
)
mDocument
(
aDocument
)
mInnerWindowId
(
aInnerWindowId
)
mImgLoader
(
loader
)
mHadInsecureRedirect
(
false
)
{
NewRequestAndEntry
(
forcePrincipalCheckForCacheEntry
loader
mRequest
-
>
CacheKey
(
)
getter_AddRefs
(
mNewRequest
)
getter_AddRefs
(
mNewEntry
)
)
;
}
imgCacheValidator
:
:
~
imgCacheValidator
(
)
{
if
(
mRequest
)
{
UpdateProxies
(
true
false
)
;
}
}
void
imgCacheValidator
:
:
AddProxy
(
imgRequestProxy
*
aProxy
)
{
aProxy
-
>
AddToLoadGroup
(
)
;
mProxies
.
AppendElement
(
aProxy
)
;
}
void
imgCacheValidator
:
:
RemoveProxy
(
imgRequestProxy
*
aProxy
)
{
mProxies
.
RemoveElement
(
aProxy
)
;
}
void
imgCacheValidator
:
:
UpdateProxies
(
bool
aCancelRequest
bool
aSyncNotify
)
{
MOZ_ASSERT
(
mRequest
)
;
mRequest
-
>
SetValidator
(
nullptr
)
;
mRequest
=
nullptr
;
if
(
aCancelRequest
)
{
MOZ_ASSERT
(
mNewRequest
)
;
mNewRequest
-
>
CancelAndAbort
(
NS_BINDING_ABORTED
)
;
}
AutoTArray
<
RefPtr
<
imgRequestProxy
>
4
>
proxies
(
std
:
:
move
(
mProxies
)
)
;
for
(
auto
&
proxy
:
proxies
)
{
MOZ_ASSERT
(
proxy
-
>
IsValidating
(
)
)
;
MOZ_ASSERT
(
proxy
-
>
NotificationsDeferred
(
)
"
Proxies
waiting
on
cache
validation
should
be
"
"
deferring
notifications
!
"
)
;
if
(
mNewRequest
)
{
proxy
-
>
ChangeOwner
(
mNewRequest
)
;
}
proxy
-
>
ClearValidating
(
)
;
}
mNewRequest
=
nullptr
;
mNewEntry
=
nullptr
;
for
(
auto
&
proxy
:
proxies
)
{
if
(
aSyncNotify
)
{
proxy
-
>
SyncNotifyListener
(
)
;
}
else
{
proxy
-
>
NotifyListener
(
)
;
}
}
}
NS_IMETHODIMP
imgCacheValidator
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
RefPtr
<
Document
>
document
=
mDocument
.
forget
(
)
;
if
(
!
mRequest
)
{
MOZ_ASSERT_UNREACHABLE
(
"
OnStartRequest
delivered
more
than
once
?
"
)
;
aRequest
-
>
CancelWithReason
(
NS_BINDING_ABORTED
"
OnStartRequest
delivered
more
than
once
?
"
_ns
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChan
(
do_QueryInterface
(
aRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
cacheChan
&
&
channel
)
{
bool
isFromCache
=
false
;
cacheChan
-
>
IsFromCache
(
&
isFromCache
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
channel
-
>
GetURI
(
getter_AddRefs
(
channelURI
)
)
;
nsCOMPtr
<
nsIURI
>
finalURI
;
mRequest
-
>
GetFinalURI
(
getter_AddRefs
(
finalURI
)
)
;
bool
sameURI
=
false
;
if
(
channelURI
&
&
finalURI
)
{
channelURI
-
>
Equals
(
finalURI
&
sameURI
)
;
}
if
(
isFromCache
&
&
sameURI
)
{
aRequest
-
>
CancelWithReason
(
NS_BINDING_ABORTED
"
imgCacheValidator
:
:
OnStartRequest
"
_ns
)
;
mNewRequest
=
nullptr
;
mRequest
-
>
SetLoadId
(
document
)
;
mRequest
-
>
SetInnerWindowID
(
mInnerWindowId
)
;
UpdateProxies
(
false
true
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIURI
>
uri
;
mRequest
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
LOG_MSG_WITH_PARAM
(
gImgLog
"
imgCacheValidator
:
:
OnStartRequest
creating
new
request
"
"
uri
"
uri
)
;
CORSMode
corsmode
=
mRequest
-
>
GetCORSMode
(
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
mRequest
-
>
GetReferrerInfo
(
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
mRequest
-
>
GetTriggeringPrincipal
(
)
;
mRequest
-
>
RemoveFromCache
(
)
;
nsCOMPtr
<
nsIURI
>
originalURI
;
channel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
nsresult
rv
=
mNewRequest
-
>
Init
(
originalURI
uri
mHadInsecureRedirect
aRequest
channel
mNewEntry
document
triggeringPrincipal
corsmode
referrerInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
UpdateProxies
(
true
true
)
;
return
rv
;
}
mDestListener
=
new
ProxyListener
(
mNewRequest
)
;
mImgLoader
-
>
PutIntoCache
(
mNewRequest
-
>
CacheKey
(
)
mNewEntry
)
;
UpdateProxies
(
false
true
)
;
return
mDestListener
-
>
OnStartRequest
(
aRequest
)
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
status
)
{
mDocument
=
nullptr
;
if
(
!
mDestListener
)
{
return
NS_OK
;
}
return
mDestListener
-
>
OnStopRequest
(
aRequest
status
)
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
inStr
uint64_t
sourceOffset
uint32_t
count
)
{
if
(
!
mDestListener
)
{
uint32_t
_retval
;
inStr
-
>
ReadSegments
(
NS_DiscardSegment
nullptr
count
&
_retval
)
;
return
NS_OK
;
}
return
mDestListener
-
>
OnDataAvailable
(
aRequest
inStr
sourceOffset
count
)
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
OnDataFinished
(
nsresult
aStatus
)
{
if
(
!
mDestListener
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mDestListener
)
;
if
(
retargetableListener
)
{
return
retargetableListener
-
>
OnDataFinished
(
aStatus
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
CheckListenerChain
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
!
"
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetableListener
=
do_QueryInterface
(
mDestListener
&
rv
)
;
if
(
retargetableListener
)
{
rv
=
retargetableListener
-
>
CheckListenerChain
(
)
;
}
MOZ_LOG
(
gImgLog
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
imgCacheValidator
:
:
CheckListenerChain
-
-
rv
%
"
PRId32
"
=
%
s
"
this
static_cast
<
uint32_t
>
(
rv
)
NS_SUCCEEDED
(
rv
)
?
"
succeeded
"
:
"
failed
"
)
)
;
return
rv
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
return
QueryInterface
(
aIID
aResult
)
;
}
return
mProgressProxy
-
>
GetInterface
(
aIID
aResult
)
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChannel
nsIChannel
*
newChannel
uint32_t
flags
nsIAsyncVerifyRedirectCallback
*
callback
)
{
mNewRequest
-
>
SetCacheValidation
(
mNewEntry
oldChannel
)
;
nsCOMPtr
<
nsIURI
>
oldURI
;
bool
schemeLocal
=
false
;
if
(
NS_FAILED
(
oldChannel
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
oldURI
nsIProtocolHandler
:
:
URI_IS_LOCAL_RESOURCE
&
schemeLocal
)
)
|
|
(
!
oldURI
-
>
SchemeIs
(
"
https
"
)
&
&
!
oldURI
-
>
SchemeIs
(
"
chrome
"
)
&
&
!
schemeLocal
)
)
{
mHadInsecureRedirect
=
true
;
}
mRedirectCallback
=
callback
;
mRedirectChannel
=
newChannel
;
return
mProgressProxy
-
>
AsyncOnChannelRedirect
(
oldChannel
newChannel
flags
this
)
;
}
NS_IMETHODIMP
imgCacheValidator
:
:
OnRedirectVerifyCallback
(
nsresult
aResult
)
{
if
(
NS_FAILED
(
aResult
)
)
{
mRedirectCallback
-
>
OnRedirectVerifyCallback
(
aResult
)
;
mRedirectCallback
=
nullptr
;
mRedirectChannel
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
mRedirectChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsresult
result
=
NS_OK
;
if
(
nsContentUtils
:
:
IsExternalProtocol
(
uri
)
)
{
result
=
NS_ERROR_ABORT
;
}
mRedirectCallback
-
>
OnRedirectVerifyCallback
(
result
)
;
mRedirectCallback
=
nullptr
;
mRedirectChannel
=
nullptr
;
return
NS_OK
;
}
