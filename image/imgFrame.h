#
ifndef
mozilla_image_imgFrame_h
#
define
mozilla_image_imgFrame_h
#
include
<
functional
>
#
include
<
utility
>
#
include
"
AnimationParams
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
mozilla
/
layers
/
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
nsRect
.
h
"
namespace
mozilla
{
namespace
image
{
class
ImageRegion
;
class
DrawableFrameRef
;
class
RawAccessFrameRef
;
enum
class
Opacity
:
uint8_t
{
FULLY_OPAQUE
SOME_TRANSPARENCY
}
;
class
imgFrame
{
typedef
gfx
:
:
SourceSurfaceSharedData
SourceSurfaceSharedData
;
typedef
gfx
:
:
DrawTarget
DrawTarget
;
typedef
gfx
:
:
SamplingFilter
SamplingFilter
;
typedef
gfx
:
:
IntPoint
IntPoint
;
typedef
gfx
:
:
IntRect
IntRect
;
typedef
gfx
:
:
IntSize
IntSize
;
typedef
gfx
:
:
SourceSurface
SourceSurface
;
typedef
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
imgFrame
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
imgFrame
)
imgFrame
(
)
;
nsresult
InitForDecoder
(
const
nsIntSize
&
aImageSize
SurfaceFormat
aFormat
bool
aNonPremult
const
Maybe
<
AnimationParams
>
&
aAnimParams
bool
aShouldRecycle
)
;
nsresult
InitForDecoderRecycle
(
const
AnimationParams
&
aAnimParams
)
;
nsresult
InitWithDrawable
(
gfxDrawable
*
aDrawable
const
nsIntSize
&
aSize
const
SurfaceFormat
aFormat
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
gfx
:
:
BackendType
aBackend
)
;
DrawableFrameRef
DrawableRef
(
)
;
RawAccessFrameRef
RawAccessRef
(
)
;
bool
Draw
(
gfxContext
*
aContext
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
float
aOpacity
)
;
nsresult
ImageUpdated
(
const
nsIntRect
&
aUpdateRect
)
;
void
Finish
(
Opacity
aFrameOpacity
=
Opacity
:
:
SOME_TRANSPARENCY
bool
aFinalize
=
true
bool
aOrientationSwapsWidthAndHeight
=
false
)
;
void
Abort
(
)
;
bool
IsAborted
(
)
const
;
bool
IsFinished
(
)
const
;
void
WaitUntilFinished
(
)
const
;
uint32_t
GetBytesPerPixel
(
)
const
{
return
4
;
}
const
IntSize
&
GetSize
(
)
const
{
return
mImageSize
;
}
IntRect
GetRect
(
)
const
{
return
IntRect
(
IntPoint
(
0
0
)
mImageSize
)
;
}
const
IntRect
&
GetBlendRect
(
)
const
{
return
mBlendRect
;
}
IntRect
GetBoundedBlendRect
(
)
const
{
return
mBlendRect
.
Intersect
(
GetRect
(
)
)
;
}
nsIntRect
GetDecodedRect
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mDecoded
;
}
FrameTimeout
GetTimeout
(
)
const
{
return
mTimeout
;
}
BlendMethod
GetBlendMethod
(
)
const
{
return
mBlendMethod
;
}
DisposalMethod
GetDisposalMethod
(
)
const
{
return
mDisposalMethod
;
}
bool
FormatHasAlpha
(
)
const
{
return
mFormat
=
=
SurfaceFormat
:
:
OS_RGBA
;
}
void
GetImageData
(
uint8_t
*
*
aData
uint32_t
*
length
)
const
;
uint8_t
*
GetImageData
(
)
const
;
const
IntRect
&
GetDirtyRect
(
)
const
{
return
mDirtyRect
;
}
void
SetDirtyRect
(
const
IntRect
&
aDirtyRect
)
{
mDirtyRect
=
aDirtyRect
;
}
void
FinalizeSurface
(
)
;
already_AddRefed
<
SourceSurface
>
GetSourceSurface
(
)
;
struct
AddSizeOfCbData
:
public
SourceSurface
:
:
SizeOfInfo
{
AddSizeOfCbData
(
)
:
SourceSurface
:
:
SizeOfInfo
(
)
mIndex
(
0
)
mFinished
(
false
)
{
}
size_t
mIndex
;
bool
mFinished
;
}
;
typedef
std
:
:
function
<
void
(
AddSizeOfCbData
&
aMetadata
)
>
AddSizeOfCb
;
void
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
AddSizeOfCb
&
aCallback
)
const
;
private
:
~
imgFrame
(
)
;
bool
AreAllPixelsWritten
(
)
const
MOZ_REQUIRES
(
mMonitor
)
;
nsresult
ImageUpdatedInternal
(
const
nsIntRect
&
aUpdateRect
)
;
void
GetImageDataInternal
(
uint8_t
*
*
aData
uint32_t
*
length
)
const
;
uint32_t
GetImageBytesPerRow
(
)
const
;
uint32_t
GetImageDataLength
(
)
const
;
void
FinalizeSurfaceInternal
(
)
;
already_AddRefed
<
SourceSurface
>
GetSourceSurfaceInternal
(
)
;
struct
SurfaceWithFormat
{
RefPtr
<
gfxDrawable
>
mDrawable
;
SurfaceFormat
mFormat
;
SurfaceWithFormat
(
)
:
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
{
}
SurfaceWithFormat
(
gfxDrawable
*
aDrawable
SurfaceFormat
aFormat
)
:
mDrawable
(
aDrawable
)
mFormat
(
aFormat
)
{
}
SurfaceWithFormat
(
SurfaceWithFormat
&
&
aOther
)
:
mDrawable
(
std
:
:
move
(
aOther
.
mDrawable
)
)
mFormat
(
aOther
.
mFormat
)
{
}
SurfaceWithFormat
&
operator
=
(
SurfaceWithFormat
&
&
aOther
)
{
mDrawable
=
std
:
:
move
(
aOther
.
mDrawable
)
;
mFormat
=
aOther
.
mFormat
;
return
*
this
;
}
SurfaceWithFormat
&
operator
=
(
const
SurfaceWithFormat
&
aOther
)
=
delete
;
SurfaceWithFormat
(
const
SurfaceWithFormat
&
aOther
)
=
delete
;
bool
IsValid
(
)
{
return
!
!
mDrawable
;
}
}
;
SurfaceWithFormat
SurfaceForDrawing
(
bool
aDoPartialDecode
bool
aDoTile
ImageRegion
&
aRegion
SourceSurface
*
aSurface
)
;
private
:
friend
class
DrawableFrameRef
;
friend
class
RawAccessFrameRef
;
friend
class
UnlockImageDataRunnable
;
mutable
Monitor
mMonitor
;
RefPtr
<
SourceSurfaceSharedData
>
mRawSurface
MOZ_GUARDED_BY
(
mMonitor
)
;
RefPtr
<
SourceSurfaceSharedData
>
mBlankRawSurface
MOZ_GUARDED_BY
(
mMonitor
)
;
RefPtr
<
SourceSurface
>
mOptSurface
MOZ_GUARDED_BY
(
mMonitor
)
;
nsIntRect
mDecoded
MOZ_GUARDED_BY
(
mMonitor
)
;
bool
mAborted
MOZ_GUARDED_BY
(
mMonitor
)
;
bool
mFinished
MOZ_GUARDED_BY
(
mMonitor
)
;
bool
mShouldRecycle
MOZ_GUARDED_BY
(
mMonitor
)
;
IntSize
mImageSize
;
IntRect
mBlendRect
;
IntRect
mDirtyRect
;
FrameTimeout
mTimeout
;
DisposalMethod
mDisposalMethod
;
BlendMethod
mBlendMethod
;
SurfaceFormat
mFormat
;
bool
mNonPremult
;
}
;
class
DrawableFrameRef
final
{
typedef
gfx
:
:
DataSourceSurface
DataSourceSurface
;
public
:
DrawableFrameRef
(
)
{
}
explicit
DrawableFrameRef
(
imgFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
MonitorAutoLock
lock
(
aFrame
-
>
mMonitor
)
;
if
(
aFrame
-
>
mRawSurface
)
{
mRef
.
emplace
(
aFrame
-
>
mRawSurface
DataSourceSurface
:
:
READ
)
;
if
(
!
mRef
-
>
IsMapped
(
)
)
{
mFrame
=
nullptr
;
mRef
.
reset
(
)
;
}
}
else
if
(
!
aFrame
-
>
mOptSurface
|
|
!
aFrame
-
>
mOptSurface
-
>
IsValid
(
)
)
{
mFrame
=
nullptr
;
}
}
DrawableFrameRef
(
DrawableFrameRef
&
&
aOther
)
:
mFrame
(
std
:
:
move
(
aOther
.
mFrame
)
)
mRef
(
std
:
:
move
(
aOther
.
mRef
)
)
{
}
DrawableFrameRef
&
operator
=
(
DrawableFrameRef
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
mFrame
=
std
:
:
move
(
aOther
.
mFrame
)
;
mRef
=
std
:
:
move
(
aOther
.
mRef
)
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mFrame
)
;
}
imgFrame
*
operator
-
>
(
)
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
const
imgFrame
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
imgFrame
*
get
(
)
{
return
mFrame
;
}
const
imgFrame
*
get
(
)
const
{
return
mFrame
;
}
void
reset
(
)
{
mFrame
=
nullptr
;
mRef
.
reset
(
)
;
}
private
:
DrawableFrameRef
(
const
DrawableFrameRef
&
aOther
)
=
delete
;
DrawableFrameRef
&
operator
=
(
const
DrawableFrameRef
&
aOther
)
=
delete
;
RefPtr
<
imgFrame
>
mFrame
;
Maybe
<
DataSourceSurface
:
:
ScopedMap
>
mRef
;
}
;
class
RawAccessFrameRef
final
{
public
:
RawAccessFrameRef
(
)
:
mData
(
nullptr
)
{
}
explicit
RawAccessFrameRef
(
imgFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mData
(
nullptr
)
{
MOZ_ASSERT
(
mFrame
"
Need
a
frame
"
)
;
mData
=
mFrame
-
>
GetImageData
(
)
;
if
(
!
mData
)
{
mFrame
=
nullptr
;
}
}
RawAccessFrameRef
(
RawAccessFrameRef
&
&
aOther
)
:
mFrame
(
std
:
:
move
(
aOther
.
mFrame
)
)
mData
(
aOther
.
mData
)
{
aOther
.
mData
=
nullptr
;
}
~
RawAccessFrameRef
(
)
{
}
RawAccessFrameRef
&
operator
=
(
RawAccessFrameRef
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
mFrame
=
std
:
:
move
(
aOther
.
mFrame
)
;
mData
=
aOther
.
mData
;
aOther
.
mData
=
nullptr
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mFrame
)
;
}
imgFrame
*
operator
-
>
(
)
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
.
get
(
)
;
}
const
imgFrame
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
imgFrame
*
get
(
)
{
return
mFrame
;
}
const
imgFrame
*
get
(
)
const
{
return
mFrame
;
}
void
reset
(
)
{
mFrame
=
nullptr
;
mData
=
nullptr
;
}
uint8_t
*
Data
(
)
const
{
return
mData
;
}
private
:
RawAccessFrameRef
(
const
RawAccessFrameRef
&
aOther
)
=
delete
;
RawAccessFrameRef
&
operator
=
(
const
RawAccessFrameRef
&
aOther
)
=
delete
;
RefPtr
<
imgFrame
>
mFrame
;
uint8_t
*
mData
;
}
;
}
}
#
endif
