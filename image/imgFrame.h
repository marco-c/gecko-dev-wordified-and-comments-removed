#
ifndef
mozilla_image_imgFrame_h
#
define
mozilla_image_imgFrame_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
AnimationParams
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
MainThreadUtils
.
h
"
namespace
mozilla
{
namespace
image
{
class
ImageRegion
;
class
DrawableFrameRef
;
class
RawAccessFrameRef
;
enum
class
Opacity
:
uint8_t
{
FULLY_OPAQUE
SOME_TRANSPARENCY
}
;
class
imgFrame
{
typedef
gfx
:
:
Color
Color
;
typedef
gfx
:
:
DataSourceSurface
DataSourceSurface
;
typedef
gfx
:
:
DrawTarget
DrawTarget
;
typedef
gfx
:
:
SamplingFilter
SamplingFilter
;
typedef
gfx
:
:
IntPoint
IntPoint
;
typedef
gfx
:
:
IntRect
IntRect
;
typedef
gfx
:
:
IntSize
IntSize
;
typedef
gfx
:
:
SourceSurface
SourceSurface
;
typedef
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
imgFrame
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
imgFrame
)
imgFrame
(
)
;
nsresult
InitForDecoder
(
const
nsIntSize
&
aImageSize
const
nsIntRect
&
aRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
bool
aNonPremult
const
Maybe
<
AnimationParams
>
&
aAnimParams
bool
aIsFullFrame
bool
aShouldRecycle
)
;
nsresult
InitForAnimator
(
const
nsIntSize
&
aSize
SurfaceFormat
aFormat
)
{
nsIntRect
frameRect
(
0
0
aSize
.
width
aSize
.
height
)
;
AnimationParams
animParams
{
frameRect
FrameTimeout
:
:
Forever
(
)
1
BlendMethod
:
:
OVER
DisposalMethod
:
:
NOT_SPECIFIED
}
;
return
InitForDecoder
(
aSize
frameRect
aFormat
0
false
Some
(
animParams
)
false
false
)
;
}
nsresult
InitForDecoderRecycle
(
const
AnimationParams
&
aAnimParams
)
;
nsresult
InitWithDrawable
(
gfxDrawable
*
aDrawable
const
nsIntSize
&
aSize
const
SurfaceFormat
aFormat
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
gfx
:
:
BackendType
aBackend
)
;
DrawableFrameRef
DrawableRef
(
)
;
RawAccessFrameRef
RawAccessRef
(
bool
aOnlyFinished
=
false
)
;
void
SetRawAccessOnly
(
)
;
bool
Draw
(
gfxContext
*
aContext
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
float
aOpacity
)
;
nsresult
ImageUpdated
(
const
nsIntRect
&
aUpdateRect
)
;
void
Finish
(
Opacity
aFrameOpacity
=
Opacity
:
:
SOME_TRANSPARENCY
bool
aFinalize
=
true
)
;
void
Abort
(
)
;
bool
IsAborted
(
)
const
;
bool
IsFinished
(
)
const
;
void
WaitUntilFinished
(
)
const
;
uint32_t
GetBytesPerPixel
(
)
const
{
return
GetIsPaletted
(
)
?
1
:
4
;
}
const
IntSize
&
GetImageSize
(
)
const
{
return
mImageSize
;
}
const
IntRect
&
GetRect
(
)
const
{
return
mFrameRect
;
}
IntSize
GetSize
(
)
const
{
return
mFrameRect
.
Size
(
)
;
}
const
IntRect
&
GetBlendRect
(
)
const
{
return
mBlendRect
;
}
IntRect
GetBoundedBlendRect
(
)
const
{
return
mBlendRect
.
Intersect
(
mFrameRect
)
;
}
FrameTimeout
GetTimeout
(
)
const
{
return
mTimeout
;
}
BlendMethod
GetBlendMethod
(
)
const
{
return
mBlendMethod
;
}
DisposalMethod
GetDisposalMethod
(
)
const
{
return
mDisposalMethod
;
}
bool
FormatHasAlpha
(
)
const
{
return
mFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
;
}
void
GetImageData
(
uint8_t
*
*
aData
uint32_t
*
length
)
const
;
uint8_t
*
GetImageData
(
)
const
;
bool
GetIsPaletted
(
)
const
;
void
GetPaletteData
(
uint32_t
*
*
aPalette
uint32_t
*
length
)
const
;
uint32_t
*
GetPaletteData
(
)
const
;
uint8_t
GetPaletteDepth
(
)
const
{
return
mPaletteDepth
;
}
const
IntRect
&
GetDirtyRect
(
)
const
{
return
mDirtyRect
;
}
void
SetDirtyRect
(
const
IntRect
&
aDirtyRect
)
{
mDirtyRect
=
aDirtyRect
;
}
bool
IsFullFrame
(
)
const
{
return
mIsFullFrame
;
}
bool
GetCompositingFailed
(
)
const
;
void
SetCompositingFailed
(
bool
val
)
;
bool
ShouldRecycle
(
)
const
{
return
mShouldRecycle
;
}
void
SetOptimizable
(
)
;
void
FinalizeSurface
(
)
;
already_AddRefed
<
SourceSurface
>
GetSourceSurface
(
)
;
struct
AddSizeOfCbData
{
AddSizeOfCbData
(
)
:
heap
(
0
)
nonHeap
(
0
)
handles
(
0
)
index
(
0
)
externalId
(
0
)
{
}
size_t
heap
;
size_t
nonHeap
;
size_t
handles
;
size_t
index
;
uint64_t
externalId
;
}
;
typedef
std
:
:
function
<
void
(
AddSizeOfCbData
&
aMetadata
)
>
AddSizeOfCb
;
void
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
AddSizeOfCb
&
aCallback
)
const
;
private
:
~
imgFrame
(
)
;
uint8_t
*
LockImageData
(
bool
aOnlyFinished
)
;
nsresult
UnlockImageData
(
)
;
nsresult
Optimize
(
gfx
:
:
DrawTarget
*
aTarget
)
;
void
AssertImageDataLocked
(
)
const
;
bool
AreAllPixelsWritten
(
)
const
;
nsresult
ImageUpdatedInternal
(
const
nsIntRect
&
aUpdateRect
)
;
void
GetImageDataInternal
(
uint8_t
*
*
aData
uint32_t
*
length
)
const
;
uint32_t
GetImageBytesPerRow
(
)
const
;
uint32_t
GetImageDataLength
(
)
const
;
void
FinalizeSurfaceInternal
(
)
;
already_AddRefed
<
SourceSurface
>
GetSourceSurfaceInternal
(
bool
aTemporary
)
;
uint32_t
PaletteDataLength
(
)
const
{
return
mPaletteDepth
?
(
size_t
(
1
)
<
<
mPaletteDepth
)
*
sizeof
(
uint32_t
)
:
0
;
}
struct
SurfaceWithFormat
{
RefPtr
<
gfxDrawable
>
mDrawable
;
SurfaceFormat
mFormat
;
SurfaceWithFormat
(
)
:
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
{
}
SurfaceWithFormat
(
gfxDrawable
*
aDrawable
SurfaceFormat
aFormat
)
:
mDrawable
(
aDrawable
)
mFormat
(
aFormat
)
{
}
SurfaceWithFormat
(
SurfaceWithFormat
&
&
aOther
)
:
mDrawable
(
std
:
:
move
(
aOther
.
mDrawable
)
)
mFormat
(
aOther
.
mFormat
)
{
}
SurfaceWithFormat
&
operator
=
(
SurfaceWithFormat
&
&
aOther
)
{
mDrawable
=
std
:
:
move
(
aOther
.
mDrawable
)
;
mFormat
=
aOther
.
mFormat
;
return
*
this
;
}
SurfaceWithFormat
&
operator
=
(
const
SurfaceWithFormat
&
aOther
)
=
delete
;
SurfaceWithFormat
(
const
SurfaceWithFormat
&
aOther
)
=
delete
;
bool
IsValid
(
)
{
return
!
!
mDrawable
;
}
}
;
SurfaceWithFormat
SurfaceForDrawing
(
bool
aDoPartialDecode
bool
aDoTile
ImageRegion
&
aRegion
SourceSurface
*
aSurface
)
;
private
:
friend
class
DrawableFrameRef
;
friend
class
RawAccessFrameRef
;
friend
class
RecyclingSourceSurface
;
friend
class
UnlockImageDataRunnable
;
mutable
Monitor
mMonitor
;
RefPtr
<
DataSourceSurface
>
mRawSurface
;
RefPtr
<
DataSourceSurface
>
mLockedSurface
;
RefPtr
<
SourceSurface
>
mOptSurface
;
nsIntRect
mDecoded
;
int16_t
mLockCount
;
int16_t
mRecycleLockCount
;
bool
mAborted
;
bool
mFinished
;
bool
mOptimizable
;
bool
mShouldRecycle
;
IntSize
mImageSize
;
IntRect
mFrameRect
;
IntRect
mBlendRect
;
IntRect
mDirtyRect
;
FrameTimeout
mTimeout
;
DisposalMethod
mDisposalMethod
;
BlendMethod
mBlendMethod
;
SurfaceFormat
mFormat
;
uint8_t
*
mPalettedImageData
;
uint8_t
mPaletteDepth
;
bool
mNonPremult
;
bool
mIsFullFrame
;
bool
mCompositingFailed
;
}
;
class
DrawableFrameRef
final
{
typedef
gfx
:
:
DataSourceSurface
DataSourceSurface
;
public
:
DrawableFrameRef
(
)
{
}
explicit
DrawableFrameRef
(
imgFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
MonitorAutoLock
lock
(
aFrame
-
>
mMonitor
)
;
MOZ_ASSERT
(
!
aFrame
-
>
GetIsPaletted
(
)
"
Paletted
must
use
RawAccessFrameRef
"
)
;
if
(
aFrame
-
>
mRawSurface
)
{
mRef
.
emplace
(
aFrame
-
>
mRawSurface
DataSourceSurface
:
:
READ
)
;
if
(
!
mRef
-
>
IsMapped
(
)
)
{
mFrame
=
nullptr
;
mRef
.
reset
(
)
;
}
}
else
{
MOZ_ASSERT
(
aFrame
-
>
mOptSurface
)
;
}
}
DrawableFrameRef
(
DrawableFrameRef
&
&
aOther
)
:
mFrame
(
aOther
.
mFrame
.
forget
(
)
)
mRef
(
std
:
:
move
(
aOther
.
mRef
)
)
{
}
DrawableFrameRef
&
operator
=
(
DrawableFrameRef
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
mFrame
=
aOther
.
mFrame
.
forget
(
)
;
mRef
=
std
:
:
move
(
aOther
.
mRef
)
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mFrame
)
;
}
imgFrame
*
operator
-
>
(
)
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
const
imgFrame
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
imgFrame
*
get
(
)
{
return
mFrame
;
}
const
imgFrame
*
get
(
)
const
{
return
mFrame
;
}
void
reset
(
)
{
mFrame
=
nullptr
;
mRef
.
reset
(
)
;
}
private
:
DrawableFrameRef
(
const
DrawableFrameRef
&
aOther
)
=
delete
;
DrawableFrameRef
&
operator
=
(
const
DrawableFrameRef
&
aOther
)
=
delete
;
RefPtr
<
imgFrame
>
mFrame
;
Maybe
<
DataSourceSurface
:
:
ScopedMap
>
mRef
;
}
;
class
RawAccessFrameRef
final
{
public
:
RawAccessFrameRef
(
)
:
mData
(
nullptr
)
{
}
explicit
RawAccessFrameRef
(
imgFrame
*
aFrame
bool
aOnlyFinished
)
:
mFrame
(
aFrame
)
mData
(
nullptr
)
{
MOZ_ASSERT
(
mFrame
"
Need
a
frame
"
)
;
mData
=
mFrame
-
>
LockImageData
(
aOnlyFinished
)
;
if
(
!
mData
)
{
mFrame
=
nullptr
;
}
}
RawAccessFrameRef
(
RawAccessFrameRef
&
&
aOther
)
:
mFrame
(
aOther
.
mFrame
.
forget
(
)
)
mData
(
aOther
.
mData
)
{
aOther
.
mData
=
nullptr
;
}
~
RawAccessFrameRef
(
)
{
if
(
mFrame
)
{
mFrame
-
>
UnlockImageData
(
)
;
}
}
RawAccessFrameRef
&
operator
=
(
RawAccessFrameRef
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
if
(
mFrame
)
{
mFrame
-
>
UnlockImageData
(
)
;
}
mFrame
=
aOther
.
mFrame
.
forget
(
)
;
mData
=
aOther
.
mData
;
aOther
.
mData
=
nullptr
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mFrame
)
;
}
imgFrame
*
operator
-
>
(
)
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
.
get
(
)
;
}
const
imgFrame
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
imgFrame
*
get
(
)
{
return
mFrame
;
}
const
imgFrame
*
get
(
)
const
{
return
mFrame
;
}
void
reset
(
)
{
if
(
mFrame
)
{
mFrame
-
>
UnlockImageData
(
)
;
}
mFrame
=
nullptr
;
mData
=
nullptr
;
}
uint8_t
*
Data
(
)
const
{
return
mData
;
}
uint32_t
PaletteDataLength
(
)
const
{
return
mFrame
-
>
PaletteDataLength
(
)
;
}
private
:
RawAccessFrameRef
(
const
RawAccessFrameRef
&
aOther
)
=
delete
;
RawAccessFrameRef
&
operator
=
(
const
RawAccessFrameRef
&
aOther
)
=
delete
;
RefPtr
<
imgFrame
>
mFrame
;
uint8_t
*
mData
;
}
;
}
}
#
endif
