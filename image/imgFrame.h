#
ifndef
mozilla_image_imgFrame_h
#
define
mozilla_image_imgFrame_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
VolatileBuffer
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
MainThreadUtils
.
h
"
namespace
mozilla
{
namespace
image
{
class
ImageRegion
;
class
DrawableFrameRef
;
class
RawAccessFrameRef
;
enum
class
BlendMethod
:
int8_t
{
SOURCE
OVER
}
;
enum
class
DisposalMethod
:
int8_t
{
CLEAR_ALL
=
-
1
NOT_SPECIFIED
KEEP
CLEAR
RESTORE_PREVIOUS
}
;
enum
class
Opacity
:
uint8_t
{
FULLY_OPAQUE
SOME_TRANSPARENCY
}
;
struct
FrameTimeout
{
static
FrameTimeout
Zero
(
)
{
return
FrameTimeout
(
0
)
;
}
static
FrameTimeout
Forever
(
)
{
return
FrameTimeout
(
-
1
)
;
}
static
FrameTimeout
FromRawMilliseconds
(
int32_t
aRawMilliseconds
)
{
if
(
aRawMilliseconds
<
0
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
if
(
aRawMilliseconds
>
=
0
&
&
aRawMilliseconds
<
=
10
)
{
return
FrameTimeout
(
100
)
;
}
return
FrameTimeout
(
aRawMilliseconds
)
;
}
bool
operator
=
=
(
const
FrameTimeout
&
aOther
)
const
{
return
mTimeout
=
=
aOther
.
mTimeout
;
}
bool
operator
!
=
(
const
FrameTimeout
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
FrameTimeout
operator
+
(
const
FrameTimeout
&
aOther
)
{
if
(
*
this
=
=
Forever
(
)
|
|
aOther
=
=
Forever
(
)
)
{
return
Forever
(
)
;
}
return
FrameTimeout
(
mTimeout
+
aOther
.
mTimeout
)
;
}
FrameTimeout
&
operator
+
=
(
const
FrameTimeout
&
aOther
)
{
*
this
=
*
this
+
aOther
;
return
*
this
;
}
uint32_t
AsMilliseconds
(
)
const
{
if
(
*
this
=
=
Forever
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Calling
AsMilliseconds
(
)
on
an
infinite
FrameTimeout
"
)
;
return
100
;
}
return
uint32_t
(
mTimeout
)
;
}
int32_t
AsEncodedValueDeprecated
(
)
const
{
return
mTimeout
;
}
private
:
explicit
FrameTimeout
(
int32_t
aTimeout
)
:
mTimeout
(
aTimeout
)
{
}
int32_t
mTimeout
;
}
;
struct
AnimationData
{
AnimationData
(
uint8_t
*
aRawData
uint32_t
aPaletteDataLength
FrameTimeout
aTimeout
const
nsIntRect
&
aRect
BlendMethod
aBlendMethod
const
Maybe
<
gfx
:
:
IntRect
>
&
aBlendRect
DisposalMethod
aDisposalMethod
bool
aHasAlpha
)
:
mRawData
(
aRawData
)
mPaletteDataLength
(
aPaletteDataLength
)
mTimeout
(
aTimeout
)
mRect
(
aRect
)
mBlendMethod
(
aBlendMethod
)
mBlendRect
(
aBlendRect
)
mDisposalMethod
(
aDisposalMethod
)
mHasAlpha
(
aHasAlpha
)
{
}
uint8_t
*
mRawData
;
uint32_t
mPaletteDataLength
;
FrameTimeout
mTimeout
;
nsIntRect
mRect
;
BlendMethod
mBlendMethod
;
Maybe
<
gfx
:
:
IntRect
>
mBlendRect
;
DisposalMethod
mDisposalMethod
;
bool
mHasAlpha
;
}
;
class
imgFrame
{
typedef
gfx
:
:
Color
Color
;
typedef
gfx
:
:
DataSourceSurface
DataSourceSurface
;
typedef
gfx
:
:
DrawTarget
DrawTarget
;
typedef
gfx
:
:
SamplingFilter
SamplingFilter
;
typedef
gfx
:
:
IntPoint
IntPoint
;
typedef
gfx
:
:
IntRect
IntRect
;
typedef
gfx
:
:
IntSize
IntSize
;
typedef
gfx
:
:
SourceSurface
SourceSurface
;
typedef
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
imgFrame
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
imgFrame
)
imgFrame
(
)
;
nsresult
InitForDecoder
(
const
nsIntSize
&
aImageSize
const
nsIntRect
&
aRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
=
0
bool
aNonPremult
=
false
)
;
nsresult
InitForDecoder
(
const
nsIntSize
&
aSize
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
=
0
)
{
return
InitForDecoder
(
aSize
nsIntRect
(
0
0
aSize
.
width
aSize
.
height
)
aFormat
aPaletteDepth
)
;
}
nsresult
InitWithDrawable
(
gfxDrawable
*
aDrawable
const
nsIntSize
&
aSize
const
SurfaceFormat
aFormat
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
)
;
DrawableFrameRef
DrawableRef
(
)
;
RawAccessFrameRef
RawAccessRef
(
)
;
void
SetRawAccessOnly
(
)
;
bool
Draw
(
gfxContext
*
aContext
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
)
;
nsresult
ImageUpdated
(
const
nsIntRect
&
aUpdateRect
)
;
void
Finish
(
Opacity
aFrameOpacity
=
Opacity
:
:
SOME_TRANSPARENCY
DisposalMethod
aDisposalMethod
=
DisposalMethod
:
:
KEEP
FrameTimeout
aTimeout
=
FrameTimeout
:
:
FromRawMilliseconds
(
0
)
BlendMethod
aBlendMethod
=
BlendMethod
:
:
OVER
const
Maybe
<
IntRect
>
&
aBlendRect
=
Nothing
(
)
)
;
void
Abort
(
)
;
bool
IsAborted
(
)
const
;
bool
IsFinished
(
)
const
;
void
WaitUntilFinished
(
)
const
;
uint32_t
GetBytesPerPixel
(
)
const
{
return
GetIsPaletted
(
)
?
1
:
4
;
}
IntSize
GetImageSize
(
)
const
{
return
mImageSize
;
}
IntRect
GetRect
(
)
const
{
return
mFrameRect
;
}
IntSize
GetSize
(
)
const
{
return
mFrameRect
.
Size
(
)
;
}
bool
NeedsPadding
(
)
const
{
return
mFrameRect
.
TopLeft
(
)
!
=
IntPoint
(
0
0
)
;
}
void
GetImageData
(
uint8_t
*
*
aData
uint32_t
*
length
)
const
;
uint8_t
*
GetImageData
(
)
const
;
bool
GetIsPaletted
(
)
const
;
void
GetPaletteData
(
uint32_t
*
*
aPalette
uint32_t
*
length
)
const
;
uint32_t
*
GetPaletteData
(
)
const
;
uint8_t
GetPaletteDepth
(
)
const
{
return
mPaletteDepth
;
}
AnimationData
GetAnimationData
(
)
const
;
bool
GetCompositingFailed
(
)
const
;
void
SetCompositingFailed
(
bool
val
)
;
void
SetOptimizable
(
)
;
Color
SinglePixelColor
(
)
const
;
bool
IsSinglePixel
(
)
const
;
already_AddRefed
<
SourceSurface
>
GetSurface
(
)
;
void
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
size_t
&
aHeapSizeOut
size_t
&
aNonHeapSizeOut
)
const
;
private
:
~
imgFrame
(
)
;
nsresult
LockImageData
(
)
;
nsresult
UnlockImageData
(
)
;
bool
CanOptimizeOpaqueImage
(
)
;
nsresult
Optimize
(
)
;
void
AssertImageDataLocked
(
)
const
;
bool
AreAllPixelsWritten
(
)
const
;
nsresult
ImageUpdatedInternal
(
const
nsIntRect
&
aUpdateRect
)
;
void
GetImageDataInternal
(
uint8_t
*
*
aData
uint32_t
*
length
)
const
;
uint32_t
GetImageBytesPerRow
(
)
const
;
uint32_t
GetImageDataLength
(
)
const
;
already_AddRefed
<
SourceSurface
>
GetSurfaceInternal
(
)
;
uint32_t
PaletteDataLength
(
)
const
{
return
mPaletteDepth
?
(
size_t
(
1
)
<
<
mPaletteDepth
)
*
sizeof
(
uint32_t
)
:
0
;
}
struct
SurfaceWithFormat
{
RefPtr
<
gfxDrawable
>
mDrawable
;
SurfaceFormat
mFormat
;
SurfaceWithFormat
(
)
{
}
SurfaceWithFormat
(
gfxDrawable
*
aDrawable
SurfaceFormat
aFormat
)
:
mDrawable
(
aDrawable
)
mFormat
(
aFormat
)
{
}
bool
IsValid
(
)
{
return
!
!
mDrawable
;
}
}
;
SurfaceWithFormat
SurfaceForDrawing
(
bool
aDoPadding
bool
aDoPartialDecode
bool
aDoTile
gfxContext
*
aContext
const
nsIntMargin
&
aPadding
gfxRect
&
aImageRect
ImageRegion
&
aRegion
SourceSurface
*
aSurface
)
;
private
:
friend
class
DrawableFrameRef
;
friend
class
RawAccessFrameRef
;
friend
class
UnlockImageDataRunnable
;
mutable
Monitor
mMonitor
;
RefPtr
<
DataSourceSurface
>
mImageSurface
;
RefPtr
<
SourceSurface
>
mOptSurface
;
RefPtr
<
VolatileBuffer
>
mVBuf
;
VolatileBufferPtr
<
uint8_t
>
mVBufPtr
;
nsIntRect
mDecoded
;
int32_t
mLockCount
;
FrameTimeout
mTimeout
;
DisposalMethod
mDisposalMethod
;
BlendMethod
mBlendMethod
;
Maybe
<
IntRect
>
mBlendRect
;
SurfaceFormat
mFormat
;
bool
mHasNoAlpha
;
bool
mAborted
;
bool
mFinished
;
bool
mOptimizable
;
IntSize
mImageSize
;
IntRect
mFrameRect
;
uint8_t
*
mPalettedImageData
;
uint8_t
mPaletteDepth
;
bool
mNonPremult
;
Color
mSinglePixelColor
;
bool
mSinglePixel
;
bool
mCompositingFailed
;
}
;
class
DrawableFrameRef
final
{
public
:
DrawableFrameRef
(
)
{
}
explicit
DrawableFrameRef
(
imgFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mRef
(
aFrame
-
>
mVBuf
)
{
if
(
mRef
.
WasBufferPurged
(
)
)
{
mFrame
=
nullptr
;
mRef
=
nullptr
;
}
}
DrawableFrameRef
(
DrawableFrameRef
&
&
aOther
)
:
mFrame
(
aOther
.
mFrame
.
forget
(
)
)
mRef
(
Move
(
aOther
.
mRef
)
)
{
}
DrawableFrameRef
&
operator
=
(
DrawableFrameRef
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
mFrame
=
aOther
.
mFrame
.
forget
(
)
;
mRef
=
Move
(
aOther
.
mRef
)
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mFrame
)
;
}
imgFrame
*
operator
-
>
(
)
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
const
imgFrame
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
imgFrame
*
get
(
)
{
return
mFrame
;
}
const
imgFrame
*
get
(
)
const
{
return
mFrame
;
}
void
reset
(
)
{
mFrame
=
nullptr
;
mRef
=
nullptr
;
}
private
:
DrawableFrameRef
(
const
DrawableFrameRef
&
aOther
)
=
delete
;
RefPtr
<
imgFrame
>
mFrame
;
VolatileBufferPtr
<
uint8_t
>
mRef
;
}
;
class
RawAccessFrameRef
final
{
public
:
RawAccessFrameRef
(
)
{
}
explicit
RawAccessFrameRef
(
imgFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
MOZ_ASSERT
(
mFrame
"
Need
a
frame
"
)
;
if
(
NS_FAILED
(
mFrame
-
>
LockImageData
(
)
)
)
{
mFrame
-
>
UnlockImageData
(
)
;
mFrame
=
nullptr
;
}
}
RawAccessFrameRef
(
RawAccessFrameRef
&
&
aOther
)
:
mFrame
(
aOther
.
mFrame
.
forget
(
)
)
{
}
~
RawAccessFrameRef
(
)
{
if
(
mFrame
)
{
mFrame
-
>
UnlockImageData
(
)
;
}
}
RawAccessFrameRef
&
operator
=
(
RawAccessFrameRef
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
if
(
mFrame
)
{
mFrame
-
>
UnlockImageData
(
)
;
}
mFrame
=
aOther
.
mFrame
.
forget
(
)
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mFrame
)
;
}
imgFrame
*
operator
-
>
(
)
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
.
get
(
)
;
}
const
imgFrame
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mFrame
)
;
return
mFrame
;
}
imgFrame
*
get
(
)
{
return
mFrame
;
}
const
imgFrame
*
get
(
)
const
{
return
mFrame
;
}
void
reset
(
)
{
if
(
mFrame
)
{
mFrame
-
>
UnlockImageData
(
)
;
}
mFrame
=
nullptr
;
}
private
:
RawAccessFrameRef
(
const
RawAccessFrameRef
&
aOther
)
=
delete
;
RefPtr
<
imgFrame
>
mFrame
;
}
;
}
}
#
endif
