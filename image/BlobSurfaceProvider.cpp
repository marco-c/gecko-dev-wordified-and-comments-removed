#
include
"
BlobSurfaceProvider
.
h
"
#
include
"
AutoRestoreSVGState
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
SVGDocumentWrapper
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
layers
/
IpcResourceUpdateQueue
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderDrawEventRecorder
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
namespace
mozilla
:
:
image
{
SourceSurfaceBlobImage
:
:
SourceSurfaceBlobImage
(
image
:
:
SVGDocumentWrapper
*
aSVGDocumentWrapper
const
Maybe
<
SVGImageContext
>
&
aSVGContext
const
Maybe
<
ImageIntRegion
>
&
aRegion
const
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aImageFlags
)
:
mSVGDocumentWrapper
(
aSVGDocumentWrapper
)
mSVGContext
(
aSVGContext
)
mRegion
(
aRegion
)
mSize
(
aSize
)
mWhichFrame
(
aWhichFrame
)
mImageFlags
(
aImageFlags
)
{
MOZ_ASSERT
(
mSVGDocumentWrapper
)
;
MOZ_ASSERT
(
aWhichFrame
<
=
imgIContainer
:
:
FRAME_MAX_VALUE
)
;
MOZ_ASSERT
(
aImageFlags
&
imgIContainer
:
:
FLAG_RECORD_BLOB
)
;
}
SourceSurfaceBlobImage
:
:
~
SourceSurfaceBlobImage
(
)
{
if
(
NS_IsMainThread
(
)
)
{
DestroyKeys
(
mKeys
)
;
return
;
}
NS_ReleaseOnMainThread
(
"
SourceSurfaceBlobImage
:
:
mSVGDocumentWrapper
"
mSVGDocumentWrapper
.
forget
(
)
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
SourceSurfaceBlobImage
:
:
DestroyKeys
"
[
keys
=
std
:
:
move
(
mKeys
)
]
{
DestroyKeys
(
keys
)
;
}
)
)
;
}
void
SourceSurfaceBlobImage
:
:
DestroyKeys
(
const
AutoTArray
<
BlobImageKeyData
1
>
&
aKeys
)
{
for
(
const
auto
&
entry
:
aKeys
)
{
if
(
!
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
entry
.
mManager
-
>
GetRenderRootStateManager
(
)
-
>
AddBlobImageKeyForDiscard
(
entry
.
mBlobKey
)
;
}
}
}
Maybe
<
wr
:
:
BlobImageKey
>
SourceSurfaceBlobImage
:
:
UpdateKey
(
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
wr
:
:
BlobImageKey
>
key
;
auto
i
=
mKeys
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
BlobImageKeyData
&
entry
=
mKeys
[
i
]
;
if
(
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
mKeys
.
RemoveElementAt
(
i
)
;
}
else
if
(
entry
.
mManager
=
=
aManager
)
{
WebRenderBridgeChild
*
wrBridge
=
aManager
-
>
WrBridge
(
)
;
MOZ_ASSERT
(
wrBridge
)
;
bool
ownsKey
=
wrBridge
-
>
MatchesNamespace
(
entry
.
mBlobKey
)
;
if
(
ownsKey
&
&
!
entry
.
mDirty
)
{
key
.
emplace
(
entry
.
mBlobKey
)
;
continue
;
}
auto
newEntry
=
RecordDrawing
(
aManager
aResources
ownsKey
?
Some
(
entry
.
mBlobKey
)
:
Nothing
(
)
)
;
if
(
!
newEntry
)
{
if
(
ownsKey
)
{
aManager
-
>
GetRenderRootStateManager
(
)
-
>
AddBlobImageKeyForDiscard
(
entry
.
mBlobKey
)
;
}
mKeys
.
RemoveElementAt
(
i
)
;
continue
;
}
key
.
emplace
(
newEntry
.
ref
(
)
.
mBlobKey
)
;
entry
=
std
:
:
move
(
newEntry
.
ref
(
)
)
;
MOZ_ASSERT
(
!
entry
.
mDirty
)
;
}
}
if
(
!
key
)
{
auto
newEntry
=
RecordDrawing
(
aManager
aResources
Nothing
(
)
)
;
if
(
newEntry
)
{
key
.
emplace
(
newEntry
.
ref
(
)
.
mBlobKey
)
;
mKeys
.
AppendElement
(
std
:
:
move
(
newEntry
.
ref
(
)
)
)
;
}
}
return
key
;
}
void
SourceSurfaceBlobImage
:
:
MarkDirty
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
i
=
mKeys
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
BlobImageKeyData
&
entry
=
mKeys
[
i
]
;
if
(
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
mKeys
.
RemoveElementAt
(
i
)
;
}
else
{
entry
.
mDirty
=
true
;
}
}
}
Maybe
<
BlobImageKeyData
>
SourceSurfaceBlobImage
:
:
RecordDrawing
(
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
Maybe
<
wr
:
:
BlobImageKey
>
aBlobKey
)
{
MOZ_ASSERT
(
!
aManager
-
>
IsDestroyed
(
)
)
;
if
(
mSVGDocumentWrapper
-
>
IsDrawing
(
)
)
{
return
Nothing
(
)
;
}
auto
*
rootManager
=
aManager
-
>
GetRenderRootStateManager
(
)
;
auto
*
wrBridge
=
aManager
-
>
WrBridge
(
)
;
IntRect
imageRect
=
mRegion
?
mRegion
-
>
Rect
(
)
:
IntRect
(
IntPoint
(
0
0
)
mSize
)
;
IntRect
imageRectOrigin
=
imageRect
-
imageRect
.
TopLeft
(
)
;
std
:
:
vector
<
RefPtr
<
ScaledFont
>
>
fonts
;
bool
validFonts
=
true
;
RefPtr
<
WebRenderDrawEventRecorder
>
recorder
=
MakeAndAddRef
<
WebRenderDrawEventRecorder
>
(
[
&
]
(
MemStream
&
aStream
std
:
:
vector
<
RefPtr
<
ScaledFont
>
>
&
aScaledFonts
)
{
auto
count
=
aScaledFonts
.
size
(
)
;
aStream
.
write
(
(
const
char
*
)
&
count
sizeof
(
count
)
)
;
for
(
auto
&
scaled
:
aScaledFonts
)
{
Maybe
<
wr
:
:
FontInstanceKey
>
key
=
wrBridge
-
>
GetFontKeyForScaledFont
(
scaled
&
aResources
)
;
if
(
key
.
isNothing
(
)
)
{
validFonts
=
false
;
break
;
}
BlobFont
font
=
{
key
.
value
(
)
scaled
}
;
aStream
.
write
(
(
const
char
*
)
&
font
sizeof
(
font
)
)
;
}
fonts
=
std
:
:
move
(
aScaledFonts
)
;
}
)
;
RefPtr
<
DrawTarget
>
dummyDt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateRecordingDrawTarget
(
recorder
dummyDt
imageRectOrigin
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
return
Nothing
(
)
;
}
bool
contextPaint
=
mSVGContext
&
&
mSVGContext
-
>
GetContextPaint
(
)
;
float
animTime
=
(
mWhichFrame
=
=
imgIContainer
:
:
FRAME_FIRST
)
?
0
.
0f
:
mSVGDocumentWrapper
-
>
GetCurrentTimeAsFloat
(
)
;
IntSize
viewportSize
=
mSize
;
if
(
mSVGContext
)
{
auto
cssViewportSize
=
mSVGContext
-
>
GetViewportSize
(
)
;
if
(
cssViewportSize
)
{
viewportSize
.
SizeTo
(
cssViewportSize
-
>
width
cssViewportSize
-
>
height
)
;
}
}
{
RefPtr
<
PresShell
>
presShell
=
mSVGDocumentWrapper
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
"
GetPresShell
returned
null
for
an
SVG
image
?
"
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
"
pres
shell
w
/
out
pres
context
"
)
;
auto
*
doc
=
presShell
-
>
GetDocument
(
)
;
[
[
maybe_unused
]
]
nsIURI
*
uri
=
doc
?
doc
-
>
GetDocumentURI
(
)
:
nullptr
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
SVG
Image
recording
"
GRAPHICS
nsPrintfCString
(
"
(
%
d
%
d
)
%
dx
%
d
from
%
dx
%
d
%
s
"
imageRect
.
x
imageRect
.
y
imageRect
.
width
imageRect
.
height
mSize
.
width
mSize
.
height
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
N
/
A
"
)
)
;
AutoRestoreSVGState
autoRestore
(
mSVGContext
animTime
mSVGDocumentWrapper
contextPaint
)
;
mSVGDocumentWrapper
-
>
UpdateViewportBounds
(
viewportSize
)
;
mSVGDocumentWrapper
-
>
FlushImageTransformInvalidation
(
)
;
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
MOZ_ASSERT
(
ctx
)
;
nsRect
svgRect
;
auto
auPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
if
(
mSize
!
=
viewportSize
)
{
auto
scaleX
=
double
(
mSize
.
width
)
/
viewportSize
.
width
;
auto
scaleY
=
double
(
mSize
.
height
)
/
viewportSize
.
height
;
ctx
-
>
SetMatrix
(
Matrix
:
:
Scaling
(
float
(
scaleX
)
float
(
scaleY
)
)
)
;
auto
scaledVisibleRect
=
IntRectToRect
(
imageRect
)
;
scaledVisibleRect
.
Scale
(
float
(
auPerDevPixel
/
scaleX
)
float
(
auPerDevPixel
/
scaleY
)
)
;
scaledVisibleRect
.
Round
(
)
;
svgRect
.
SetRect
(
int32_t
(
scaledVisibleRect
.
x
)
int32_t
(
scaledVisibleRect
.
y
)
int32_t
(
scaledVisibleRect
.
width
)
int32_t
(
scaledVisibleRect
.
height
)
)
;
}
else
{
auto
scaledVisibleRect
(
imageRect
)
;
scaledVisibleRect
.
Scale
(
auPerDevPixel
)
;
svgRect
.
SetRect
(
scaledVisibleRect
.
x
scaledVisibleRect
.
y
scaledVisibleRect
.
width
scaledVisibleRect
.
height
)
;
}
RenderDocumentFlags
renderDocFlags
=
RenderDocumentFlags
:
:
IgnoreViewportScrolling
;
if
(
!
(
mImageFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
)
{
renderDocFlags
|
=
RenderDocumentFlags
:
:
AsyncDecodeImages
;
}
if
(
mImageFlags
&
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
)
{
renderDocFlags
|
=
RenderDocumentFlags
:
:
UseHighQualityScaling
;
}
presShell
-
>
RenderDocument
(
svgRect
renderDocFlags
NS_RGBA
(
0
0
0
0
)
ctx
)
;
}
recorder
-
>
FlushItem
(
imageRectOrigin
)
;
recorder
-
>
Finish
(
)
;
if
(
!
validFonts
)
{
gfxCriticalNote
<
<
"
Failed
serializing
fonts
for
blob
vector
image
"
;
return
Nothing
(
)
;
}
Range
<
uint8_t
>
bytes
(
(
uint8_t
*
)
recorder
-
>
mOutputStream
.
mData
recorder
-
>
mOutputStream
.
mLength
)
;
wr
:
:
BlobImageKey
key
=
aBlobKey
?
aBlobKey
.
value
(
)
:
wr
:
:
BlobImageKey
{
wrBridge
-
>
GetNextImageKey
(
)
}
;
wr
:
:
ImageDescriptor
descriptor
(
imageRect
.
Size
(
)
0
SurfaceFormat
:
:
OS_RGBA
wr
:
:
OpacityType
:
:
HasAlphaChannel
)
;
auto
visibleRect
=
ImageIntRect
:
:
FromUnknownRect
(
imageRectOrigin
)
;
if
(
aBlobKey
)
{
if
(
!
aResources
.
UpdateBlobImage
(
key
descriptor
bytes
visibleRect
visibleRect
)
)
{
return
Nothing
(
)
;
}
}
else
if
(
!
aResources
.
AddBlobImage
(
key
descriptor
bytes
visibleRect
)
)
{
return
Nothing
(
)
;
}
std
:
:
vector
<
RefPtr
<
SourceSurface
>
>
externalSurfaces
;
recorder
-
>
TakeExternalSurfaces
(
externalSurfaces
)
;
for
(
auto
&
surface
:
externalSurfaces
)
{
wr
:
:
ImageKey
key
=
{
}
;
DebugOnly
<
nsresult
>
rv
=
SharedSurfacesChild
:
:
Share
(
surface
rootManager
aResources
key
)
;
MOZ_ASSERT
(
rv
.
value
!
=
NS_ERROR_NOT_IMPLEMENTED
)
;
}
return
Some
(
BlobImageKeyData
(
aManager
key
std
:
:
move
(
fonts
)
std
:
:
move
(
externalSurfaces
)
)
)
;
}
}
