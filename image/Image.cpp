#
include
"
Image
.
h
"
#
include
"
imgRequest
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceRawData
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SizeOfState
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesChild
.
h
"
#
include
"
SourceSurfaceBlobImage
.
h
"
namespace
mozilla
{
namespace
image
{
ImageMemoryCounter
:
:
ImageMemoryCounter
(
imgRequest
*
aRequest
SizeOfState
&
aState
bool
aIsUsed
)
:
mProgress
(
UINT32_MAX
)
mType
(
UINT16_MAX
)
mIsUsed
(
aIsUsed
)
mHasError
(
false
)
mValidating
(
false
)
{
MOZ_ASSERT
(
aRequest
)
;
nsCOMPtr
<
nsIURI
>
imageURL
;
nsresult
rv
=
aRequest
-
>
GetURI
(
getter_AddRefs
(
imageURL
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
imageURL
)
{
imageURL
-
>
GetSpec
(
mURI
)
;
}
mType
=
imgIContainer
:
:
TYPE_REQUEST
;
mHasError
=
NS_FAILED
(
aRequest
-
>
GetImageErrorCode
(
)
)
;
mValidating
=
!
!
aRequest
-
>
GetValidator
(
)
;
RefPtr
<
ProgressTracker
>
tracker
=
aRequest
-
>
GetProgressTracker
(
)
;
if
(
tracker
)
{
mProgress
=
tracker
-
>
GetProgress
(
)
;
}
}
ImageMemoryCounter
:
:
ImageMemoryCounter
(
imgRequest
*
aRequest
Image
*
aImage
SizeOfState
&
aState
bool
aIsUsed
)
:
mProgress
(
UINT32_MAX
)
mType
(
UINT16_MAX
)
mIsUsed
(
aIsUsed
)
mHasError
(
false
)
mValidating
(
false
)
{
MOZ_ASSERT
(
aRequest
)
;
MOZ_ASSERT
(
aImage
)
;
nsCOMPtr
<
nsIURI
>
imageURL
(
aImage
-
>
GetURI
(
)
)
;
if
(
imageURL
)
{
imageURL
-
>
GetSpec
(
mURI
)
;
}
int32_t
width
=
0
;
int32_t
height
=
0
;
aImage
-
>
GetWidth
(
&
width
)
;
aImage
-
>
GetHeight
(
&
height
)
;
mIntrinsicSize
.
SizeTo
(
width
height
)
;
mType
=
aImage
-
>
GetType
(
)
;
mHasError
=
aImage
-
>
HasError
(
)
;
mValidating
=
!
!
aRequest
-
>
GetValidator
(
)
;
RefPtr
<
ProgressTracker
>
tracker
=
aImage
-
>
GetProgressTracker
(
)
;
if
(
tracker
)
{
mProgress
=
tracker
-
>
GetProgress
(
)
;
}
mValues
.
SetSource
(
aImage
-
>
SizeOfSourceWithComputedFallback
(
aState
)
)
;
aImage
-
>
CollectSizeOfSurfaces
(
mSurfaces
aState
.
mMallocSizeOf
)
;
for
(
const
SurfaceMemoryCounter
&
surfaceCounter
:
mSurfaces
)
{
mValues
+
=
surfaceCounter
.
Values
(
)
;
}
}
bool
ImageResource
:
:
GetSpecTruncatedTo1k
(
nsCString
&
aSpec
)
const
{
static
const
size_t
sMaxTruncatedLength
=
1024
;
mURI
-
>
GetSpec
(
aSpec
)
;
if
(
sMaxTruncatedLength
>
=
aSpec
.
Length
(
)
)
{
return
true
;
}
aSpec
.
Truncate
(
sMaxTruncatedLength
)
;
return
false
;
}
void
ImageResource
:
:
SetCurrentImage
(
layers
:
:
ImageContainer
*
aContainer
gfx
:
:
SourceSurface
*
aSurface
const
Maybe
<
gfx
:
:
IntRect
>
&
aDirtyRect
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aContainer
)
;
if
(
!
aSurface
)
{
return
;
}
RefPtr
<
layers
:
:
Image
>
image
=
new
layers
:
:
SourceSurfaceImage
(
aSurface
)
;
AutoTArray
<
layers
:
:
ImageContainer
:
:
NonOwningImage
1
>
imageList
;
imageList
.
AppendElement
(
layers
:
:
ImageContainer
:
:
NonOwningImage
(
image
TimeStamp
(
)
mLastFrameID
+
+
mImageProducerID
)
)
;
if
(
aDirtyRect
)
{
aContainer
-
>
SetCurrentImagesInTransaction
(
imageList
)
;
}
else
{
aContainer
-
>
SetCurrentImages
(
imageList
)
;
}
if
(
mProgressTracker
-
>
GetProgress
(
)
&
FLAG_IS_ANIMATED
)
{
if
(
aDirtyRect
)
{
layers
:
:
SharedSurfacesChild
:
:
UpdateAnimation
(
aContainer
aSurface
aDirtyRect
.
ref
(
)
)
;
}
else
{
gfx
:
:
IntRect
dirtyRect
(
gfx
:
:
IntPoint
(
0
0
)
aSurface
-
>
GetSize
(
)
)
;
layers
:
:
SharedSurfacesChild
:
:
UpdateAnimation
(
aContainer
aSurface
dirtyRect
)
;
}
}
}
ImgDrawResult
ImageResource
:
:
GetImageContainerImpl
(
WindowRenderer
*
aRenderer
const
gfx
:
:
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
const
Maybe
<
ImageIntRegion
>
&
aRegion
uint32_t
aFlags
layers
:
:
ImageContainer
*
*
aOutContainer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aRenderer
)
;
MOZ_ASSERT
(
(
aFlags
&
~
(
FLAG_SYNC_DECODE
|
FLAG_SYNC_DECODE_IF_FAST
|
FLAG_RECORD_BLOB
|
FLAG_ASYNC_NOTIFY
|
FLAG_HIGH_QUALITY_SCALING
)
)
=
=
FLAG_NONE
"
Unsupported
flag
passed
to
GetImageContainer
"
)
;
ImgDrawResult
drawResult
;
gfx
:
:
IntSize
size
;
Tie
(
drawResult
size
)
=
GetImageContainerSize
(
aRenderer
aSize
aFlags
)
;
if
(
drawResult
!
=
ImgDrawResult
:
:
SUCCESS
)
{
return
drawResult
;
}
MOZ_ASSERT
(
!
size
.
IsEmpty
(
)
)
;
if
(
mAnimationConsumers
=
=
0
)
{
SendOnUnlockedDraw
(
aFlags
)
;
}
uint32_t
flags
=
(
aFlags
&
~
(
FLAG_SYNC_DECODE
|
FLAG_SYNC_DECODE_IF_FAST
)
)
|
FLAG_ASYNC_NOTIFY
;
RefPtr
<
layers
:
:
ImageContainer
>
container
;
ImageContainerEntry
*
entry
=
nullptr
;
int
i
=
mImageContainers
.
Length
(
)
-
1
;
for
(
;
i
>
=
0
;
-
-
i
)
{
entry
=
&
mImageContainers
[
i
]
;
if
(
size
=
=
entry
-
>
mSize
&
&
flags
=
=
entry
-
>
mFlags
&
&
aSVGContext
=
=
entry
-
>
mSVGContext
&
&
aRegion
=
=
entry
-
>
mRegion
)
{
container
=
RefPtr
<
layers
:
:
ImageContainer
>
(
entry
-
>
mContainer
)
;
break
;
}
else
if
(
entry
-
>
mContainer
.
IsDead
(
)
)
{
mImageContainers
.
RemoveElementAt
(
i
)
;
}
}
if
(
container
)
{
switch
(
entry
-
>
mLastDrawResult
)
{
case
ImgDrawResult
:
:
SUCCESS
:
case
ImgDrawResult
:
:
BAD_IMAGE
:
case
ImgDrawResult
:
:
BAD_ARGS
:
case
ImgDrawResult
:
:
NOT_SUPPORTED
:
container
.
forget
(
aOutContainer
)
;
return
entry
-
>
mLastDrawResult
;
case
ImgDrawResult
:
:
NOT_READY
:
case
ImgDrawResult
:
:
INCOMPLETE
:
case
ImgDrawResult
:
:
TEMPORARY_ERROR
:
break
;
case
ImgDrawResult
:
:
WRONG_SIZE
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
ImgDrawResult
type
!
"
)
;
container
.
forget
(
aOutContainer
)
;
return
entry
-
>
mLastDrawResult
;
}
}
AutoProfilerImagePaintMarker
PROFILER_RAII
(
this
)
;
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
gfx
:
:
IntSize
bestSize
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
Tie
(
drawResult
bestSize
surface
)
=
GetFrameInternal
(
size
aSVGContext
aRegion
FRAME_CURRENT
aFlags
|
FLAG_ASYNC_NOTIFY
)
;
if
(
bestSize
!
=
size
)
{
MOZ_ASSERT
(
!
bestSize
.
IsEmpty
(
)
)
;
if
(
i
>
=
0
&
&
!
container
)
{
mImageContainers
.
RemoveElementAt
(
i
)
;
}
container
=
nullptr
;
i
=
mImageContainers
.
Length
(
)
-
1
;
for
(
;
i
>
=
0
;
-
-
i
)
{
entry
=
&
mImageContainers
[
i
]
;
if
(
bestSize
=
=
entry
-
>
mSize
&
&
flags
=
=
entry
-
>
mFlags
&
&
aSVGContext
=
=
entry
-
>
mSVGContext
&
&
aRegion
=
=
entry
-
>
mRegion
)
{
container
=
RefPtr
<
layers
:
:
ImageContainer
>
(
entry
-
>
mContainer
)
;
if
(
container
)
{
switch
(
entry
-
>
mLastDrawResult
)
{
case
ImgDrawResult
:
:
SUCCESS
:
case
ImgDrawResult
:
:
BAD_IMAGE
:
case
ImgDrawResult
:
:
BAD_ARGS
:
case
ImgDrawResult
:
:
NOT_SUPPORTED
:
container
.
forget
(
aOutContainer
)
;
return
entry
-
>
mLastDrawResult
;
case
ImgDrawResult
:
:
NOT_READY
:
case
ImgDrawResult
:
:
INCOMPLETE
:
case
ImgDrawResult
:
:
TEMPORARY_ERROR
:
break
;
case
ImgDrawResult
:
:
WRONG_SIZE
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
DrawResult
type
!
"
)
;
container
.
forget
(
aOutContainer
)
;
return
entry
-
>
mLastDrawResult
;
}
}
break
;
}
}
}
if
(
!
container
)
{
container
=
layers
:
:
LayerManager
:
:
CreateImageContainer
(
)
;
if
(
i
>
=
0
)
{
entry
-
>
mContainer
=
container
;
}
else
{
entry
=
mImageContainers
.
AppendElement
(
ImageContainerEntry
(
bestSize
aSVGContext
aRegion
container
.
get
(
)
flags
)
)
;
}
}
SetCurrentImage
(
container
surface
Nothing
(
)
)
;
entry
-
>
mLastDrawResult
=
drawResult
;
container
.
forget
(
aOutContainer
)
;
return
drawResult
;
}
bool
ImageResource
:
:
UpdateImageContainer
(
const
Maybe
<
gfx
:
:
IntRect
>
&
aDirtyRect
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
int
i
=
mImageContainers
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
ImageContainerEntry
&
entry
=
mImageContainers
[
i
]
;
RefPtr
<
layers
:
:
ImageContainer
>
container
(
entry
.
mContainer
)
;
if
(
container
)
{
if
(
entry
.
mFlags
&
FLAG_RECORD_BLOB
)
{
AutoTArray
<
layers
:
:
ImageContainer
:
:
OwningImage
1
>
images
;
container
-
>
GetCurrentImages
(
&
images
)
;
if
(
images
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Empty
container
!
"
)
;
continue
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
images
[
0
]
.
mImage
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
|
|
surface
-
>
GetType
(
)
!
=
gfx
:
:
SurfaceType
:
:
BLOB_IMAGE
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
/
wrong
surface
in
container
!
"
)
;
continue
;
}
static_cast
<
SourceSurfaceBlobImage
*
>
(
surface
.
get
(
)
)
-
>
MarkDirty
(
)
;
continue
;
}
gfx
:
:
IntSize
bestSize
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
Tie
(
entry
.
mLastDrawResult
bestSize
surface
)
=
GetFrameInternal
(
entry
.
mSize
entry
.
mSVGContext
entry
.
mRegion
FRAME_CURRENT
entry
.
mFlags
)
;
if
(
aDirtyRect
)
{
SetCurrentImage
(
container
surface
aDirtyRect
)
;
}
else
{
gfx
:
:
IntRect
dirtyRect
(
gfx
:
:
IntPoint
(
0
0
)
bestSize
)
;
SetCurrentImage
(
container
surface
Some
(
dirtyRect
)
)
;
}
}
else
{
mImageContainers
.
RemoveElementAt
(
i
)
;
}
}
return
!
mImageContainers
.
IsEmpty
(
)
;
}
void
ImageResource
:
:
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
const
auto
&
entry
:
mImageContainers
)
{
RefPtr
<
layers
:
:
ImageContainer
>
container
(
entry
.
mContainer
)
;
if
(
!
container
)
{
continue
;
}
AutoTArray
<
layers
:
:
ImageContainer
:
:
OwningImage
1
>
images
;
container
-
>
GetCurrentImages
(
&
images
)
;
if
(
images
.
IsEmpty
(
)
)
{
continue
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
images
[
0
]
.
mImage
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
surface
in
container
!
"
)
;
continue
;
}
bool
isMappedSurface
=
surface
-
>
GetType
(
)
=
=
gfx
:
:
SurfaceType
:
:
DATA_MAPPED
;
const
gfx
:
:
SourceSurface
*
actualSurface
=
isMappedSurface
?
static_cast
<
gfx
:
:
SourceSurfaceMappedData
*
>
(
surface
.
get
(
)
)
-
>
GetScopedSurface
(
)
:
surface
.
get
(
)
;
bool
found
=
false
;
for
(
const
auto
&
counter
:
aCounters
)
{
if
(
counter
.
Surface
(
)
=
=
actualSurface
)
{
found
=
true
;
break
;
}
}
if
(
found
)
{
continue
;
}
gfx
:
:
SourceSurface
:
:
SizeOfInfo
info
;
surface
-
>
SizeOfExcludingThis
(
aMallocSizeOf
info
)
;
uint32_t
heapBytes
=
aMallocSizeOf
(
actualSurface
)
;
if
(
isMappedSurface
)
{
heapBytes
+
=
aMallocSizeOf
(
surface
.
get
(
)
)
;
}
SurfaceKey
key
=
ContainerSurfaceKey
(
surface
-
>
GetSize
(
)
entry
.
mSVGContext
ToSurfaceFlags
(
entry
.
mFlags
)
)
;
SurfaceMemoryCounter
counter
(
key
actualSurface
false
false
false
true
SurfaceMemoryCounterType
:
:
CONTAINER
)
;
counter
.
Values
(
)
.
SetDecodedHeap
(
info
.
mHeapBytes
+
heapBytes
)
;
counter
.
Values
(
)
.
SetDecodedNonHeap
(
info
.
mNonHeapBytes
)
;
counter
.
Values
(
)
.
SetDecodedUnknown
(
info
.
mUnknownBytes
)
;
counter
.
Values
(
)
.
SetExternalHandles
(
info
.
mExternalHandles
)
;
counter
.
Values
(
)
.
SetExternalId
(
info
.
mExternalId
)
;
counter
.
Values
(
)
.
SetSurfaceTypes
(
info
.
mTypes
)
;
aCounters
.
AppendElement
(
counter
)
;
}
}
void
ImageResource
:
:
ReleaseImageContainer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mImageContainers
.
Clear
(
)
;
}
ImageResource
:
:
ImageResource
(
nsIURI
*
aURI
)
:
mURI
(
aURI
)
mInnerWindowId
(
0
)
mAnimationConsumers
(
0
)
mAnimationMode
(
kNormalAnimMode
)
mInitialized
(
false
)
mAnimating
(
false
)
mError
(
false
)
mImageProducerID
(
layers
:
:
ImageContainer
:
:
AllocateProducerID
(
)
)
mLastFrameID
(
0
)
{
}
ImageResource
:
:
~
ImageResource
(
)
{
mProgressTracker
-
>
ResetImage
(
)
;
}
void
ImageResource
:
:
IncrementAnimationConsumers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
to
encourage
serialization
"
"
with
DecrementAnimationConsumers
"
)
;
mAnimationConsumers
+
+
;
}
void
ImageResource
:
:
DecrementAnimationConsumers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
to
encourage
serialization
"
"
with
IncrementAnimationConsumers
"
)
;
MOZ_ASSERT
(
mAnimationConsumers
>
=
1
"
Invalid
no
.
of
animation
consumers
!
"
)
;
mAnimationConsumers
-
-
;
}
nsresult
ImageResource
:
:
GetAnimationModeInternal
(
uint16_t
*
aAnimationMode
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_ARG_POINTER
(
aAnimationMode
)
;
*
aAnimationMode
=
mAnimationMode
;
return
NS_OK
;
}
nsresult
ImageResource
:
:
SetAnimationModeInternal
(
uint16_t
aAnimationMode
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
aAnimationMode
=
=
kNormalAnimMode
|
|
aAnimationMode
=
=
kDontAnimMode
|
|
aAnimationMode
=
=
kLoopOnceAnimMode
"
Wrong
Animation
Mode
is
being
set
!
"
)
;
mAnimationMode
=
aAnimationMode
;
return
NS_OK
;
}
bool
ImageResource
:
:
HadRecentRefresh
(
const
TimeStamp
&
aTime
)
{
static
TimeDuration
recentThreshold
=
TimeDuration
:
:
FromMilliseconds
(
nsRefreshDriver
:
:
DefaultInterval
(
)
/
2
.
0
)
;
if
(
!
mLastRefreshTime
.
IsNull
(
)
&
&
aTime
-
mLastRefreshTime
<
recentThreshold
)
{
return
true
;
}
mLastRefreshTime
=
aTime
;
return
false
;
}
void
ImageResource
:
:
EvaluateAnimation
(
)
{
if
(
!
mAnimating
&
&
ShouldAnimate
(
)
)
{
nsresult
rv
=
StartAnimation
(
)
;
mAnimating
=
NS_SUCCEEDED
(
rv
)
;
}
else
if
(
mAnimating
&
&
!
ShouldAnimate
(
)
)
{
StopAnimation
(
)
;
}
}
void
ImageResource
:
:
SendOnUnlockedDraw
(
uint32_t
aFlags
)
{
if
(
!
mProgressTracker
)
{
return
;
}
if
(
!
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
)
{
mProgressTracker
-
>
OnUnlockedDraw
(
)
;
}
else
{
NotNull
<
RefPtr
<
ImageResource
>
>
image
=
WrapNotNull
(
this
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
mProgressTracker
-
>
GetEventTarget
(
)
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NS_NewRunnableFunction
(
"
image
:
:
ImageResource
:
:
SendOnUnlockedDraw
"
[
=
]
(
)
-
>
void
{
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
if
(
tracker
)
{
tracker
-
>
OnUnlockedDraw
(
)
;
}
}
)
;
eventTarget
-
>
Dispatch
(
CreateRenderBlockingRunnable
(
ev
.
forget
(
)
)
NS_DISPATCH_NORMAL
)
;
}
}
#
ifdef
DEBUG
void
ImageResource
:
:
NotifyDrawingObservers
(
)
{
if
(
!
mURI
|
|
!
NS_IsMainThread
(
)
)
{
return
;
}
if
(
!
mURI
-
>
SchemeIs
(
"
resource
"
)
&
&
!
mURI
-
>
SchemeIs
(
"
chrome
"
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
=
mURI
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
image
:
:
ImageResource
:
:
NotifyDrawingObservers
"
[
uri
]
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
NS_WARNING_ASSERTION
(
obs
"
Can
'
t
get
an
observer
service
handle
"
)
;
if
(
obs
)
{
nsAutoCString
spec
;
uri
-
>
GetSpec
(
spec
)
;
obs
-
>
NotifyObservers
(
nullptr
"
image
-
drawing
"
NS_ConvertUTF8toUTF16
(
spec
)
.
get
(
)
)
;
}
}
)
)
;
}
#
endif
}
}
