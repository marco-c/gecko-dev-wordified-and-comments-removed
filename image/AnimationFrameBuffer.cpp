#
include
"
AnimationFrameBuffer
.
h
"
#
include
"
mozilla
/
Move
.
h
"
namespace
mozilla
{
namespace
image
{
AnimationFrameRetainedBuffer
:
:
AnimationFrameRetainedBuffer
(
size_t
aThreshold
size_t
aBatch
size_t
aStartFrame
)
:
AnimationFrameBuffer
(
aBatch
aStartFrame
)
mThreshold
(
aThreshold
)
{
size_t
minThreshold
=
2
*
mBatch
+
1
;
if
(
mThreshold
<
minThreshold
)
{
mThreshold
=
minThreshold
;
}
mPending
=
mBatch
*
2
;
}
bool
AnimationFrameRetainedBuffer
:
:
InsertInternal
(
RefPtr
<
imgFrame
>
&
&
aFrame
)
{
MOZ_ASSERT
(
!
mSizeKnown
)
;
MOZ_ASSERT
(
mFrames
.
Length
(
)
<
mThreshold
)
;
mFrames
.
AppendElement
(
std
:
:
move
(
aFrame
)
)
;
MOZ_ASSERT
(
mSize
=
=
mFrames
.
Length
(
)
)
;
return
mSize
<
mThreshold
;
}
bool
AnimationFrameRetainedBuffer
:
:
ResetInternal
(
)
{
if
(
mPending
>
1
&
&
mSize
>
=
mBatch
*
2
+
1
)
{
MOZ_ASSERT
(
!
mSizeKnown
)
;
mPending
=
1
;
}
return
false
;
}
bool
AnimationFrameRetainedBuffer
:
:
MarkComplete
(
const
gfx
:
:
IntRect
&
aFirstFrameRefreshArea
)
{
MOZ_ASSERT
(
!
mSizeKnown
)
;
mSizeKnown
=
true
;
mPending
=
0
;
mFrames
.
Compact
(
)
;
return
false
;
}
void
AnimationFrameRetainedBuffer
:
:
AdvanceInternal
(
)
{
MOZ_ASSERT
(
!
mFrames
.
IsEmpty
(
)
)
;
size_t
framesLength
=
mFrames
.
Length
(
)
;
MOZ_ASSERT
(
mGetIndex
<
framesLength
)
;
MOZ_ASSERT_IF
(
mGetIndex
>
0
mFrames
[
mGetIndex
-
1
]
)
;
MOZ_ASSERT_IF
(
mGetIndex
=
=
0
mFrames
[
framesLength
-
1
]
)
;
MOZ_ASSERT
(
mFrames
[
mGetIndex
]
)
;
if
(
!
mSizeKnown
)
{
size_t
buffered
=
mPending
+
framesLength
-
mGetIndex
-
1
;
if
(
buffered
<
mBatch
)
{
mPending
+
=
mBatch
;
}
}
}
imgFrame
*
AnimationFrameRetainedBuffer
:
:
Get
(
size_t
aFrame
bool
aForDisplay
)
{
if
(
mFrames
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Calling
Get
(
)
when
we
have
no
frames
"
)
;
return
nullptr
;
}
if
(
aFrame
>
=
mFrames
.
Length
(
)
)
{
return
nullptr
;
}
if
(
!
mFrames
[
aFrame
]
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Calling
Get
(
)
when
frame
is
unavailable
"
)
;
return
nullptr
;
}
MOZ_ASSERT
(
aFrame
=
=
0
|
|
mAdvance
=
=
0
)
;
return
mFrames
[
aFrame
]
.
get
(
)
;
}
bool
AnimationFrameRetainedBuffer
:
:
IsFirstFrameFinished
(
)
const
{
return
!
mFrames
.
IsEmpty
(
)
&
&
mFrames
[
0
]
-
>
IsFinished
(
)
;
}
bool
AnimationFrameRetainedBuffer
:
:
IsLastInsertedFrame
(
imgFrame
*
aFrame
)
const
{
return
!
mFrames
.
IsEmpty
(
)
&
&
mFrames
.
LastElement
(
)
.
get
(
)
=
=
aFrame
;
}
void
AnimationFrameRetainedBuffer
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
AddSizeOfCb
&
aCallback
)
{
size_t
i
=
0
;
for
(
const
RefPtr
<
imgFrame
>
&
frame
:
mFrames
)
{
+
+
i
;
frame
-
>
AddSizeOfExcludingThis
(
aMallocSizeOf
[
&
]
(
AddSizeOfCbData
&
aMetadata
)
{
aMetadata
.
index
=
i
;
aCallback
(
aMetadata
)
;
}
)
;
}
}
}
}
