#
ifndef
mozilla_image_FrameAnimator_h
#
define
mozilla_image_FrameAnimator_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
imgFrame
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
SurfaceCache
.
h
"
namespace
mozilla
{
namespace
image
{
class
RasterImage
;
class
AnimationState
{
public
:
explicit
AnimationState
(
uint16_t
aAnimationMode
)
:
mCurrentAnimationFrameIndex
(
0
)
mLoopRemainingCount
(
-
1
)
mLoopCount
(
-
1
)
mFirstFrameTimeout
(
FrameTimeout
:
:
FromRawMilliseconds
(
0
)
)
mAnimationMode
(
aAnimationMode
)
mDoneDecoding
(
false
)
{
}
void
SetDoneDecoding
(
bool
aDone
)
;
void
ResetAnimation
(
)
;
void
SetAnimationMode
(
uint16_t
aAnimationMode
)
;
void
UnionFirstFrameRefreshArea
(
const
nsIntRect
&
aRect
)
;
void
InitAnimationFrameTimeIfNecessary
(
)
;
void
SetAnimationFrameTime
(
const
TimeStamp
&
aTime
)
;
uint32_t
GetCurrentAnimationFrameIndex
(
)
const
;
nsIntRect
GetFirstFrameRefreshArea
(
)
const
;
void
SetLoopCount
(
int32_t
aLoopCount
)
{
mLoopCount
=
aLoopCount
;
}
int32_t
LoopCount
(
)
const
{
return
mLoopCount
;
}
void
SetFirstFrameTimeout
(
FrameTimeout
aTimeout
)
{
mFirstFrameTimeout
=
aTimeout
;
}
FrameTimeout
FirstFrameTimeout
(
)
const
{
return
mFirstFrameTimeout
;
}
private
:
friend
class
FrameAnimator
;
nsIntRect
mFirstFrameRefreshArea
;
TimeStamp
mCurrentAnimationFrameTime
;
uint32_t
mCurrentAnimationFrameIndex
;
int32_t
mLoopRemainingCount
;
int32_t
mLoopCount
;
FrameTimeout
mFirstFrameTimeout
;
uint16_t
mAnimationMode
;
bool
mDoneDecoding
;
}
;
class
FrameAnimator
{
public
:
FrameAnimator
(
RasterImage
*
aImage
gfx
:
:
IntSize
aSize
)
:
mImage
(
aImage
)
mSize
(
aSize
)
mLastCompositedFrameIndex
(
-
1
)
{
MOZ_COUNT_CTOR
(
FrameAnimator
)
;
}
~
FrameAnimator
(
)
{
MOZ_COUNT_DTOR
(
FrameAnimator
)
;
}
struct
RefreshResult
{
nsIntRect
dirtyRect
;
bool
frameAdvanced
:
1
;
bool
animationFinished
:
1
;
RefreshResult
(
)
:
frameAdvanced
(
false
)
animationFinished
(
false
)
{
}
void
Accumulate
(
const
RefreshResult
&
other
)
{
frameAdvanced
=
frameAdvanced
|
|
other
.
frameAdvanced
;
animationFinished
=
animationFinished
|
|
other
.
animationFinished
;
dirtyRect
=
dirtyRect
.
Union
(
other
.
dirtyRect
)
;
}
}
;
RefreshResult
RequestRefresh
(
AnimationState
&
aState
const
TimeStamp
&
aTime
)
;
LookupResult
GetCompositedFrame
(
uint32_t
aFrameNum
)
;
void
CollectSizeOfCompositingSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
RefreshResult
AdvanceFrame
(
AnimationState
&
aState
TimeStamp
aTime
)
;
RawAccessFrameRef
GetRawFrame
(
uint32_t
aFrameNum
)
const
;
int32_t
GetSingleLoopTime
(
AnimationState
&
aState
)
const
;
FrameTimeout
GetTimeoutForFrame
(
uint32_t
aFrameNum
)
const
;
TimeStamp
GetCurrentImgFrameEndTime
(
AnimationState
&
aState
)
const
;
bool
DoBlend
(
nsIntRect
*
aDirtyRect
uint32_t
aPrevFrameIndex
uint32_t
aNextFrameIndex
)
;
static
void
ClearFrame
(
uint8_t
*
aFrameData
const
nsIntRect
&
aFrameRect
)
;
static
void
ClearFrame
(
uint8_t
*
aFrameData
const
nsIntRect
&
aFrameRect
const
nsIntRect
&
aRectToClear
)
;
static
bool
CopyFrameImage
(
const
uint8_t
*
aDataSrc
const
nsIntRect
&
aRectSrc
uint8_t
*
aDataDest
const
nsIntRect
&
aRectDest
)
;
static
nsresult
DrawFrameTo
(
const
uint8_t
*
aSrcData
const
nsIntRect
&
aSrcRect
uint32_t
aSrcPaletteLength
bool
aSrcHasAlpha
uint8_t
*
aDstPixels
const
nsIntRect
&
aDstRect
BlendMethod
aBlendMethod
const
Maybe
<
nsIntRect
>
&
aBlendRect
)
;
private
:
RasterImage
*
mImage
;
gfx
:
:
IntSize
mSize
;
RawAccessFrameRef
mCompositingFrame
;
RawAccessFrameRef
mCompositingPrevFrame
;
int32_t
mLastCompositedFrameIndex
;
}
;
}
}
#
endif
