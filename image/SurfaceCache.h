#
ifndef
mozilla_image_SurfaceCache_h
#
define
mozilla_image_SurfaceCache_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
SurfaceFlags
.
h
"
#
include
"
SVGImageContext
.
h
"
namespace
mozilla
{
namespace
image
{
class
Image
;
class
ISurfaceProvider
;
class
LookupResult
;
class
SurfaceCacheImpl
;
struct
SurfaceMemoryCounter
;
typedef
Image
*
ImageKey
;
class
SurfaceKey
{
typedef
gfx
:
:
IntSize
IntSize
;
public
:
bool
operator
=
=
(
const
SurfaceKey
&
aOther
)
const
{
return
aOther
.
mSize
=
=
mSize
&
&
aOther
.
mSVGContext
=
=
mSVGContext
&
&
aOther
.
mAnimationTime
=
=
mAnimationTime
&
&
aOther
.
mFlags
=
=
mFlags
;
}
uint32_t
Hash
(
)
const
{
uint32_t
hash
=
HashGeneric
(
mSize
.
width
mSize
.
height
)
;
hash
=
AddToHash
(
hash
mSVGContext
.
map
(
HashSIC
)
.
valueOr
(
0
)
)
;
hash
=
AddToHash
(
hash
mAnimationTime
uint32_t
(
mFlags
)
)
;
return
hash
;
}
const
IntSize
&
Size
(
)
const
{
return
mSize
;
}
Maybe
<
SVGImageContext
>
SVGContext
(
)
const
{
return
mSVGContext
;
}
float
AnimationTime
(
)
const
{
return
mAnimationTime
;
}
SurfaceFlags
Flags
(
)
const
{
return
mFlags
;
}
private
:
SurfaceKey
(
const
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
const
float
aAnimationTime
const
SurfaceFlags
aFlags
)
:
mSize
(
aSize
)
mSVGContext
(
aSVGContext
)
mAnimationTime
(
aAnimationTime
)
mFlags
(
aFlags
)
{
}
static
uint32_t
HashSIC
(
const
SVGImageContext
&
aSIC
)
{
return
aSIC
.
Hash
(
)
;
}
friend
SurfaceKey
RasterSurfaceKey
(
const
IntSize
&
SurfaceFlags
uint32_t
)
;
friend
SurfaceKey
VectorSurfaceKey
(
const
IntSize
&
const
Maybe
<
SVGImageContext
>
&
float
)
;
IntSize
mSize
;
Maybe
<
SVGImageContext
>
mSVGContext
;
float
mAnimationTime
;
SurfaceFlags
mFlags
;
}
;
inline
SurfaceKey
RasterSurfaceKey
(
const
gfx
:
:
IntSize
&
aSize
SurfaceFlags
aFlags
uint32_t
aFrameNum
)
{
return
SurfaceKey
(
aSize
Nothing
(
)
float
(
aFrameNum
)
aFlags
)
;
}
inline
SurfaceKey
VectorSurfaceKey
(
const
gfx
:
:
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
float
aAnimationTime
)
{
return
SurfaceKey
(
aSize
aSVGContext
aAnimationTime
DefaultSurfaceFlags
(
)
)
;
}
class
AvailabilityState
{
public
:
static
AvailabilityState
StartAvailable
(
)
{
return
AvailabilityState
(
true
)
;
}
static
AvailabilityState
StartAsPlaceholder
(
)
{
return
AvailabilityState
(
false
)
;
}
bool
IsAvailable
(
)
const
{
return
mIsAvailable
;
}
bool
IsPlaceholder
(
)
const
{
return
!
mIsAvailable
;
}
private
:
friend
class
SurfaceCacheImpl
;
explicit
AvailabilityState
(
bool
aIsAvailable
)
:
mIsAvailable
(
aIsAvailable
)
{
}
void
SetAvailable
(
)
{
mIsAvailable
=
true
;
}
bool
mIsAvailable
;
}
;
enum
class
InsertOutcome
:
uint8_t
{
SUCCESS
FAILURE
FAILURE_ALREADY_PRESENT
}
;
struct
SurfaceCache
{
typedef
gfx
:
:
IntSize
IntSize
;
static
void
Initialize
(
)
;
static
void
Shutdown
(
)
;
static
LookupResult
Lookup
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
;
static
LookupResult
LookupBestMatch
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
;
static
InsertOutcome
Insert
(
NotNull
<
ISurfaceProvider
*
>
aProvider
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
;
static
InsertOutcome
InsertPlaceholder
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
;
static
void
SurfaceAvailable
(
NotNull
<
ISurfaceProvider
*
>
aProvider
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
;
static
bool
CanHold
(
const
IntSize
&
aSize
uint32_t
aBytesPerPixel
=
4
)
;
static
bool
CanHold
(
size_t
aSize
)
;
static
void
LockImage
(
const
ImageKey
aImageKey
)
;
static
void
UnlockImage
(
const
ImageKey
aImageKey
)
;
static
void
UnlockEntries
(
const
ImageKey
aImageKey
)
;
static
void
RemoveImage
(
const
ImageKey
aImageKey
)
;
static
void
DiscardAll
(
)
;
static
void
CollectSizeOfSurfaces
(
const
ImageKey
aImageKey
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
;
static
size_t
MaximumCapacity
(
)
;
private
:
virtual
~
SurfaceCache
(
)
=
0
;
}
;
}
}
#
endif
