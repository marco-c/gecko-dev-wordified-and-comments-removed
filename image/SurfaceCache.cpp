#
include
"
SurfaceCache
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPattern
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
imgFrame
.
h
"
#
include
"
Image
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
ShutdownTracker
.
h
"
#
include
"
SVGImageContext
.
h
"
using
std
:
:
max
;
using
std
:
:
min
;
namespace
mozilla
{
using
namespace
gfx
;
namespace
image
{
class
CachedSurface
;
class
SurfaceCacheImpl
;
static
StaticRefPtr
<
SurfaceCacheImpl
>
sInstance
;
typedef
size_t
Cost
;
static
const
Cost
sPlaceholderCost
=
1
;
static
Cost
ComputeCost
(
const
IntSize
&
aSize
uint32_t
aBytesPerPixel
)
{
MOZ_ASSERT
(
aBytesPerPixel
=
=
1
|
|
aBytesPerPixel
=
=
4
)
;
return
aSize
.
width
*
aSize
.
height
*
aBytesPerPixel
;
}
class
CostEntry
{
public
:
CostEntry
(
CachedSurface
*
aSurface
Cost
aCost
)
:
mSurface
(
aSurface
)
mCost
(
aCost
)
{
MOZ_ASSERT
(
aSurface
"
Must
have
a
surface
"
)
;
}
CachedSurface
*
GetSurface
(
)
const
{
return
mSurface
;
}
Cost
GetCost
(
)
const
{
return
mCost
;
}
bool
operator
=
=
(
const
CostEntry
&
aOther
)
const
{
return
mSurface
=
=
aOther
.
mSurface
&
&
mCost
=
=
aOther
.
mCost
;
}
bool
operator
<
(
const
CostEntry
&
aOther
)
const
{
return
mCost
<
aOther
.
mCost
|
|
(
mCost
=
=
aOther
.
mCost
&
&
mSurface
<
aOther
.
mSurface
)
;
}
private
:
CachedSurface
*
mSurface
;
Cost
mCost
;
}
;
class
CachedSurface
{
~
CachedSurface
(
)
{
}
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
CachedSurface
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CachedSurface
)
CachedSurface
(
imgFrame
*
aSurface
const
Cost
aCost
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
:
mSurface
(
aSurface
)
mCost
(
aCost
)
mImageKey
(
aImageKey
)
mSurfaceKey
(
aSurfaceKey
)
{
MOZ_ASSERT
(
!
IsPlaceholder
(
)
|
|
mCost
=
=
sPlaceholderCost
"
Placeholder
should
have
trivial
cost
"
)
;
MOZ_ASSERT
(
mImageKey
"
Must
have
a
valid
image
key
"
)
;
}
DrawableFrameRef
DrawableRef
(
)
const
{
if
(
MOZ_UNLIKELY
(
IsPlaceholder
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Shouldn
'
t
call
DrawableRef
(
)
on
a
placeholder
"
)
;
return
DrawableFrameRef
(
)
;
}
return
mSurface
-
>
DrawableRef
(
)
;
}
void
SetLocked
(
bool
aLocked
)
{
if
(
IsPlaceholder
(
)
)
{
return
;
}
if
(
aLocked
)
{
mDrawableRef
=
mSurface
-
>
DrawableRef
(
)
;
}
else
{
mDrawableRef
.
reset
(
)
;
}
}
bool
IsPlaceholder
(
)
const
{
return
!
bool
(
mSurface
)
;
}
bool
IsLocked
(
)
const
{
return
bool
(
mDrawableRef
)
;
}
ImageKey
GetImageKey
(
)
const
{
return
mImageKey
;
}
SurfaceKey
GetSurfaceKey
(
)
const
{
return
mSurfaceKey
;
}
CostEntry
GetCostEntry
(
)
{
return
image
:
:
CostEntry
(
this
mCost
)
;
}
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mExpirationState
;
}
bool
IsDecoded
(
)
const
{
return
!
IsPlaceholder
(
)
&
&
mSurface
-
>
IsImageComplete
(
)
;
}
struct
MOZ_STACK_CLASS
SurfaceMemoryReport
{
SurfaceMemoryReport
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
:
mCounters
(
aCounters
)
mMallocSizeOf
(
aMallocSizeOf
)
{
}
void
Add
(
CachedSurface
*
aCachedSurface
)
{
MOZ_ASSERT
(
aCachedSurface
"
Should
have
a
CachedSurface
"
)
;
SurfaceMemoryCounter
counter
(
aCachedSurface
-
>
GetSurfaceKey
(
)
aCachedSurface
-
>
IsLocked
(
)
)
;
if
(
aCachedSurface
-
>
mSurface
)
{
counter
.
SubframeSize
(
)
=
Some
(
aCachedSurface
-
>
mSurface
-
>
GetSize
(
)
)
;
size_t
heap
=
0
nonHeap
=
0
;
aCachedSurface
-
>
mSurface
-
>
AddSizeOfExcludingThis
(
mMallocSizeOf
heap
nonHeap
)
;
counter
.
Values
(
)
.
SetDecodedHeap
(
heap
)
;
counter
.
Values
(
)
.
SetDecodedNonHeap
(
nonHeap
)
;
}
mCounters
.
AppendElement
(
counter
)
;
}
private
:
nsTArray
<
SurfaceMemoryCounter
>
&
mCounters
;
MallocSizeOf
mMallocSizeOf
;
}
;
private
:
nsExpirationState
mExpirationState
;
RefPtr
<
imgFrame
>
mSurface
;
DrawableFrameRef
mDrawableRef
;
const
Cost
mCost
;
const
ImageKey
mImageKey
;
const
SurfaceKey
mSurfaceKey
;
}
;
class
ImageSurfaceCache
{
~
ImageSurfaceCache
(
)
{
}
public
:
ImageSurfaceCache
(
)
:
mLocked
(
false
)
{
}
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ImageSurfaceCache
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageSurfaceCache
)
typedef
nsRefPtrHashtable
<
nsGenericHashKey
<
SurfaceKey
>
CachedSurface
>
SurfaceTable
;
bool
IsEmpty
(
)
const
{
return
mSurfaces
.
Count
(
)
=
=
0
;
}
void
Insert
(
const
SurfaceKey
&
aKey
CachedSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
"
Should
have
a
surface
"
)
;
MOZ_ASSERT
(
!
mLocked
|
|
aSurface
-
>
IsPlaceholder
(
)
|
|
aSurface
-
>
IsLocked
(
)
"
Inserting
an
unlocked
surface
for
a
locked
image
"
)
;
mSurfaces
.
Put
(
aKey
aSurface
)
;
}
void
Remove
(
CachedSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
"
Should
have
a
surface
"
)
;
MOZ_ASSERT
(
mSurfaces
.
GetWeak
(
aSurface
-
>
GetSurfaceKey
(
)
)
"
Should
not
be
removing
a
surface
we
don
'
t
have
"
)
;
mSurfaces
.
Remove
(
aSurface
-
>
GetSurfaceKey
(
)
)
;
}
already_AddRefed
<
CachedSurface
>
Lookup
(
const
SurfaceKey
&
aSurfaceKey
)
{
RefPtr
<
CachedSurface
>
surface
;
mSurfaces
.
Get
(
aSurfaceKey
getter_AddRefs
(
surface
)
)
;
return
surface
.
forget
(
)
;
}
Pair
<
already_AddRefed
<
CachedSurface
>
MatchType
>
LookupBestMatch
(
const
SurfaceKey
&
aSurfaceKey
)
{
RefPtr
<
CachedSurface
>
exactMatch
;
mSurfaces
.
Get
(
aSurfaceKey
getter_AddRefs
(
exactMatch
)
)
;
if
(
exactMatch
&
&
exactMatch
-
>
IsDecoded
(
)
)
{
return
MakePair
(
exactMatch
.
forget
(
)
MatchType
:
:
EXACT
)
;
}
RefPtr
<
CachedSurface
>
bestMatch
;
for
(
auto
iter
=
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CachedSurface
*
surface
=
iter
.
UserData
(
)
;
const
SurfaceKey
&
idealKey
=
aSurfaceKey
;
if
(
surface
-
>
IsPlaceholder
(
)
)
{
continue
;
}
if
(
aSurfaceKey
.
AnimationTime
(
)
!
=
idealKey
.
AnimationTime
(
)
|
|
aSurfaceKey
.
SVGContext
(
)
!
=
idealKey
.
SVGContext
(
)
)
{
continue
;
}
if
(
aSurfaceKey
.
Flags
(
)
!
=
idealKey
.
Flags
(
)
)
{
continue
;
}
if
(
!
bestMatch
)
{
bestMatch
=
surface
;
continue
;
}
MOZ_ASSERT
(
bestMatch
"
Should
have
a
current
best
match
"
)
;
bool
bestMatchIsDecoded
=
bestMatch
-
>
IsDecoded
(
)
;
if
(
bestMatchIsDecoded
&
&
!
surface
-
>
IsDecoded
(
)
)
{
continue
;
}
if
(
!
bestMatchIsDecoded
&
&
surface
-
>
IsDecoded
(
)
)
{
bestMatch
=
surface
;
continue
;
}
SurfaceKey
bestMatchKey
=
bestMatch
-
>
GetSurfaceKey
(
)
;
int64_t
idealArea
=
static_cast
<
int64_t
>
(
idealKey
.
Size
(
)
.
width
)
*
static_cast
<
int64_t
>
(
idealKey
.
Size
(
)
.
height
)
;
int64_t
surfaceArea
=
aSurfaceKey
.
Size
(
)
.
width
*
aSurfaceKey
.
Size
(
)
.
height
;
int64_t
bestMatchArea
=
bestMatchKey
.
Size
(
)
.
width
*
bestMatchKey
.
Size
(
)
.
height
;
if
(
bestMatchArea
<
idealArea
)
{
if
(
surfaceArea
>
bestMatchArea
)
{
bestMatch
=
surface
;
}
continue
;
}
if
(
idealArea
<
=
surfaceArea
&
&
surfaceArea
<
bestMatchArea
)
{
bestMatch
=
surface
;
continue
;
}
}
MatchType
matchType
;
if
(
bestMatch
)
{
if
(
!
exactMatch
)
{
matchType
=
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
;
}
else
if
(
exactMatch
!
=
bestMatch
)
{
matchType
=
MatchType
:
:
SUBSTITUTE_BECAUSE_PENDING
;
}
else
{
matchType
=
MatchType
:
:
EXACT
;
}
}
else
{
if
(
exactMatch
)
{
MOZ_ASSERT
(
exactMatch
-
>
IsPlaceholder
(
)
)
;
matchType
=
MatchType
:
:
PENDING
;
}
else
{
matchType
=
MatchType
:
:
NOT_FOUND
;
}
}
return
MakePair
(
bestMatch
.
forget
(
)
matchType
)
;
}
SurfaceTable
:
:
Iterator
ConstIter
(
)
const
{
return
mSurfaces
.
ConstIter
(
)
;
}
void
SetLocked
(
bool
aLocked
)
{
mLocked
=
aLocked
;
}
bool
IsLocked
(
)
const
{
return
mLocked
;
}
private
:
SurfaceTable
mSurfaces
;
bool
mLocked
;
}
;
class
SurfaceCacheImpl
final
:
public
nsIMemoryReporter
{
public
:
NS_DECL_ISUPPORTS
SurfaceCacheImpl
(
uint32_t
aSurfaceCacheExpirationTimeMS
uint32_t
aSurfaceCacheDiscardFactor
uint32_t
aSurfaceCacheSize
)
:
mExpirationTracker
(
aSurfaceCacheExpirationTimeMS
)
mMemoryPressureObserver
(
new
MemoryPressureObserver
)
mMutex
(
"
SurfaceCache
"
)
mDiscardFactor
(
aSurfaceCacheDiscardFactor
)
mMaxCost
(
aSurfaceCacheSize
)
mAvailableCost
(
aSurfaceCacheSize
)
mLockedCost
(
0
)
mOverflowCount
(
0
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
mMemoryPressureObserver
"
memory
-
pressure
"
false
)
;
}
}
private
:
virtual
~
SurfaceCacheImpl
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
mMemoryPressureObserver
"
memory
-
pressure
"
)
;
}
UnregisterWeakMemoryReporter
(
this
)
;
}
public
:
void
InitMemoryReporter
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
Mutex
&
GetMutex
(
)
{
return
mMutex
;
}
InsertOutcome
Insert
(
imgFrame
*
aSurface
const
Cost
aCost
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
LookupResult
result
=
Lookup
(
aImageKey
aSurfaceKey
false
)
;
if
(
MOZ_UNLIKELY
(
result
)
)
{
return
InsertOutcome
:
:
FAILURE_ALREADY_PRESENT
;
}
if
(
result
.
Type
(
)
=
=
MatchType
:
:
PENDING
)
{
RemoveSurface
(
aImageKey
aSurfaceKey
)
;
}
MOZ_ASSERT
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
|
|
result
.
Type
(
)
=
=
MatchType
:
:
PENDING
"
A
LookupResult
with
no
surface
should
be
NOT_FOUND
or
PENDING
"
)
;
if
(
MOZ_UNLIKELY
(
!
CanHoldAfterDiscarding
(
aCost
)
)
)
{
mOverflowCount
+
+
;
return
InsertOutcome
:
:
FAILURE
;
}
while
(
aCost
>
mAvailableCost
)
{
MOZ_ASSERT
(
!
mCosts
.
IsEmpty
(
)
"
Removed
everything
and
it
still
won
'
t
fit
"
)
;
Remove
(
mCosts
.
LastElement
(
)
.
GetSurface
(
)
)
;
}
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
cache
=
new
ImageSurfaceCache
;
mImageCaches
.
Put
(
aImageKey
cache
)
;
}
RefPtr
<
CachedSurface
>
surface
=
new
CachedSurface
(
aSurface
aCost
aImageKey
aSurfaceKey
)
;
if
(
cache
-
>
IsLocked
(
)
&
&
!
surface
-
>
IsPlaceholder
(
)
)
{
surface
-
>
SetLocked
(
true
)
;
if
(
!
surface
-
>
IsLocked
(
)
)
{
return
InsertOutcome
:
:
FAILURE
;
}
}
MOZ_ASSERT
(
aCost
<
=
mAvailableCost
"
Inserting
despite
too
large
a
cost
"
)
;
cache
-
>
Insert
(
aSurfaceKey
surface
)
;
StartTracking
(
surface
)
;
return
InsertOutcome
:
:
SUCCESS
;
}
void
Remove
(
CachedSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
"
Should
have
a
surface
"
)
;
ImageKey
imageKey
=
aSurface
-
>
GetImageKey
(
)
;
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
imageKey
)
;
MOZ_ASSERT
(
cache
"
Shouldn
'
t
try
to
remove
a
surface
with
no
image
cache
"
)
;
if
(
!
aSurface
-
>
IsPlaceholder
(
)
)
{
static_cast
<
Image
*
>
(
imageKey
)
-
>
OnSurfaceDiscarded
(
)
;
}
StopTracking
(
aSurface
)
;
cache
-
>
Remove
(
aSurface
)
;
if
(
cache
-
>
IsEmpty
(
)
&
&
!
cache
-
>
IsLocked
(
)
)
{
mImageCaches
.
Remove
(
imageKey
)
;
}
}
void
StartTracking
(
CachedSurface
*
aSurface
)
{
CostEntry
costEntry
=
aSurface
-
>
GetCostEntry
(
)
;
MOZ_ASSERT
(
costEntry
.
GetCost
(
)
<
=
mAvailableCost
"
Cost
too
large
and
the
caller
didn
'
t
catch
it
"
)
;
mAvailableCost
-
=
costEntry
.
GetCost
(
)
;
if
(
aSurface
-
>
IsLocked
(
)
)
{
mLockedCost
+
=
costEntry
.
GetCost
(
)
;
MOZ_ASSERT
(
mLockedCost
<
=
mMaxCost
"
Locked
more
than
we
can
hold
?
"
)
;
}
else
{
mCosts
.
InsertElementSorted
(
costEntry
)
;
mExpirationTracker
.
AddObject
(
aSurface
)
;
}
}
void
StopTracking
(
CachedSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
"
Should
have
a
surface
"
)
;
CostEntry
costEntry
=
aSurface
-
>
GetCostEntry
(
)
;
if
(
aSurface
-
>
IsLocked
(
)
)
{
MOZ_ASSERT
(
mLockedCost
>
=
costEntry
.
GetCost
(
)
"
Costs
don
'
t
balance
"
)
;
mLockedCost
-
=
costEntry
.
GetCost
(
)
;
MOZ_ASSERT
(
!
mCosts
.
Contains
(
costEntry
)
"
Shouldn
'
t
have
a
cost
entry
for
a
locked
surface
"
)
;
}
else
{
if
(
MOZ_LIKELY
(
aSurface
-
>
GetExpirationState
(
)
-
>
IsTracked
(
)
)
)
{
mExpirationTracker
.
RemoveObject
(
aSurface
)
;
}
else
{
NS_ASSERTION
(
ShutdownTracker
:
:
ShutdownHasStarted
(
)
"
Not
expiration
-
tracking
an
unlocked
surface
!
"
)
;
}
DebugOnly
<
bool
>
foundInCosts
=
mCosts
.
RemoveElementSorted
(
costEntry
)
;
MOZ_ASSERT
(
foundInCosts
"
Lost
track
of
costs
for
this
surface
"
)
;
}
mAvailableCost
+
=
costEntry
.
GetCost
(
)
;
MOZ_ASSERT
(
mAvailableCost
<
=
mMaxCost
"
More
available
cost
than
we
started
with
"
)
;
}
LookupResult
Lookup
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
bool
aMarkUsed
=
true
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
RefPtr
<
CachedSurface
>
surface
=
cache
-
>
Lookup
(
aSurfaceKey
)
;
if
(
!
surface
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
if
(
surface
-
>
IsPlaceholder
(
)
)
{
return
LookupResult
(
MatchType
:
:
PENDING
)
;
}
DrawableFrameRef
ref
=
surface
-
>
DrawableRef
(
)
;
if
(
!
ref
)
{
Remove
(
surface
)
;
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
if
(
aMarkUsed
)
{
MarkUsed
(
surface
cache
)
;
}
MOZ_ASSERT
(
surface
-
>
GetSurfaceKey
(
)
=
=
aSurfaceKey
"
Lookup
(
)
not
returning
an
exact
match
?
"
)
;
return
LookupResult
(
Move
(
ref
)
MatchType
:
:
EXACT
)
;
}
LookupResult
LookupBestMatch
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
RefPtr
<
CachedSurface
>
surface
;
DrawableFrameRef
ref
;
MatchType
matchType
=
MatchType
:
:
NOT_FOUND
;
while
(
true
)
{
Tie
(
surface
matchType
)
=
cache
-
>
LookupBestMatch
(
aSurfaceKey
)
;
if
(
!
surface
)
{
return
LookupResult
(
matchType
)
;
}
ref
=
surface
-
>
DrawableRef
(
)
;
if
(
ref
)
{
break
;
}
Remove
(
surface
)
;
}
MOZ_ASSERT_IF
(
matchType
=
=
MatchType
:
:
EXACT
surface
-
>
GetSurfaceKey
(
)
=
=
aSurfaceKey
)
;
MOZ_ASSERT_IF
(
matchType
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
|
|
matchType
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_PENDING
surface
-
>
GetSurfaceKey
(
)
.
SVGContext
(
)
=
=
aSurfaceKey
.
SVGContext
(
)
&
&
surface
-
>
GetSurfaceKey
(
)
.
AnimationTime
(
)
=
=
aSurfaceKey
.
AnimationTime
(
)
&
&
surface
-
>
GetSurfaceKey
(
)
.
Flags
(
)
=
=
aSurfaceKey
.
Flags
(
)
)
;
if
(
matchType
=
=
MatchType
:
:
EXACT
)
{
MarkUsed
(
surface
cache
)
;
}
return
LookupResult
(
Move
(
ref
)
matchType
)
;
}
void
RemoveSurface
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
return
;
}
RefPtr
<
CachedSurface
>
surface
=
cache
-
>
Lookup
(
aSurfaceKey
)
;
if
(
!
surface
)
{
return
;
}
Remove
(
surface
)
;
}
bool
CanHold
(
const
Cost
aCost
)
const
{
return
aCost
<
=
mMaxCost
;
}
void
LockImage
(
const
ImageKey
aImageKey
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
cache
=
new
ImageSurfaceCache
;
mImageCaches
.
Put
(
aImageKey
cache
)
;
}
cache
-
>
SetLocked
(
true
)
;
}
void
UnlockImage
(
const
ImageKey
aImageKey
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
|
|
!
cache
-
>
IsLocked
(
)
)
{
return
;
}
cache
-
>
SetLocked
(
false
)
;
DoUnlockSurfaces
(
cache
)
;
}
void
UnlockSurfaces
(
const
ImageKey
aImageKey
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
|
|
!
cache
-
>
IsLocked
(
)
)
{
return
;
}
DoUnlockSurfaces
(
cache
)
;
}
void
RemoveImage
(
const
ImageKey
aImageKey
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
return
;
}
for
(
auto
iter
=
cache
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
StopTracking
(
iter
.
UserData
(
)
)
;
}
mImageCaches
.
Remove
(
aImageKey
)
;
}
void
DiscardAll
(
)
{
while
(
!
mCosts
.
IsEmpty
(
)
)
{
Remove
(
mCosts
.
LastElement
(
)
.
GetSurface
(
)
)
;
}
}
void
DiscardForMemoryPressure
(
)
{
const
Cost
discardableCost
=
(
mMaxCost
-
mAvailableCost
)
-
mLockedCost
;
MOZ_ASSERT
(
discardableCost
<
=
mMaxCost
"
Discardable
cost
doesn
'
t
add
up
"
)
;
const
Cost
targetCost
=
mAvailableCost
+
(
discardableCost
/
mDiscardFactor
)
;
if
(
targetCost
>
mMaxCost
-
mLockedCost
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Target
cost
is
more
than
we
can
discard
"
)
;
DiscardAll
(
)
;
return
;
}
while
(
mAvailableCost
<
targetCost
)
{
MOZ_ASSERT
(
!
mCosts
.
IsEmpty
(
)
"
Removed
everything
and
still
not
done
"
)
;
Remove
(
mCosts
.
LastElement
(
)
.
GetSurface
(
)
)
;
}
}
void
LockSurface
(
CachedSurface
*
aSurface
)
{
if
(
aSurface
-
>
IsPlaceholder
(
)
|
|
aSurface
-
>
IsLocked
(
)
)
{
return
;
}
StopTracking
(
aSurface
)
;
aSurface
-
>
SetLocked
(
true
)
;
StartTracking
(
aSurface
)
;
}
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
nsresult
rv
;
rv
=
MOZ_COLLECT_REPORT
(
"
imagelib
-
surface
-
cache
-
estimated
-
total
"
KIND_OTHER
UNITS_BYTES
(
mMaxCost
-
mAvailableCost
)
"
Estimated
total
memory
used
by
the
imagelib
"
"
surface
cache
.
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MOZ_COLLECT_REPORT
(
"
imagelib
-
surface
-
cache
-
estimated
-
locked
"
KIND_OTHER
UNITS_BYTES
mLockedCost
"
Estimated
memory
used
by
locked
surfaces
in
the
"
"
imagelib
surface
cache
.
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MOZ_COLLECT_REPORT
(
"
imagelib
-
surface
-
cache
-
overflow
-
count
"
KIND_OTHER
UNITS_COUNT
mOverflowCount
"
Count
of
how
many
times
the
surface
cache
has
hit
"
"
its
capacity
and
been
unable
to
insert
a
new
"
"
surface
.
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
CollectSizeOfSurfaces
(
const
ImageKey
aImageKey
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
{
RefPtr
<
ImageSurfaceCache
>
cache
=
GetImageCache
(
aImageKey
)
;
if
(
!
cache
)
{
return
;
}
CachedSurface
:
:
SurfaceMemoryReport
report
(
aCounters
aMallocSizeOf
)
;
for
(
auto
iter
=
cache
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
report
.
Add
(
iter
.
UserData
(
)
)
;
}
}
private
:
already_AddRefed
<
ImageSurfaceCache
>
GetImageCache
(
const
ImageKey
aImageKey
)
{
RefPtr
<
ImageSurfaceCache
>
imageCache
;
mImageCaches
.
Get
(
aImageKey
getter_AddRefs
(
imageCache
)
)
;
return
imageCache
.
forget
(
)
;
}
bool
CanHoldAfterDiscarding
(
const
Cost
aCost
)
const
{
return
aCost
<
=
mMaxCost
-
mLockedCost
;
}
void
MarkUsed
(
CachedSurface
*
aSurface
ImageSurfaceCache
*
aCache
)
{
if
(
aCache
-
>
IsLocked
(
)
)
{
LockSurface
(
aSurface
)
;
}
else
{
mExpirationTracker
.
MarkUsed
(
aSurface
)
;
}
}
void
DoUnlockSurfaces
(
ImageSurfaceCache
*
aCache
)
{
for
(
auto
iter
=
aCache
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CachedSurface
*
surface
=
iter
.
UserData
(
)
;
if
(
surface
-
>
IsPlaceholder
(
)
|
|
!
surface
-
>
IsLocked
(
)
)
{
continue
;
}
StopTracking
(
surface
)
;
surface
-
>
SetLocked
(
false
)
;
StartTracking
(
surface
)
;
}
}
struct
SurfaceTracker
:
public
nsExpirationTracker
<
CachedSurface
2
>
{
explicit
SurfaceTracker
(
uint32_t
aSurfaceCacheExpirationTimeMS
)
:
nsExpirationTracker
<
CachedSurface
2
>
(
aSurfaceCacheExpirationTimeMS
"
SurfaceTracker
"
)
{
}
protected
:
virtual
void
NotifyExpired
(
CachedSurface
*
aSurface
)
override
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
sInstance
-
>
Remove
(
aSurface
)
;
}
}
}
;
struct
MemoryPressureObserver
:
public
nsIObserver
{
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
override
{
if
(
sInstance
&
&
strcmp
(
aTopic
"
memory
-
pressure
"
)
=
=
0
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
sInstance
-
>
DiscardForMemoryPressure
(
)
;
}
return
NS_OK
;
}
private
:
virtual
~
MemoryPressureObserver
(
)
{
}
}
;
nsTArray
<
CostEntry
>
mCosts
;
nsRefPtrHashtable
<
nsPtrHashKey
<
Image
>
ImageSurfaceCache
>
mImageCaches
;
SurfaceTracker
mExpirationTracker
;
RefPtr
<
MemoryPressureObserver
>
mMemoryPressureObserver
;
Mutex
mMutex
;
const
uint32_t
mDiscardFactor
;
const
Cost
mMaxCost
;
Cost
mAvailableCost
;
Cost
mLockedCost
;
size_t
mOverflowCount
;
}
;
NS_IMPL_ISUPPORTS
(
SurfaceCacheImpl
nsIMemoryReporter
)
NS_IMPL_ISUPPORTS
(
SurfaceCacheImpl
:
:
MemoryPressureObserver
nsIObserver
)
void
SurfaceCache
:
:
Initialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sInstance
"
Shouldn
'
t
initialize
more
than
once
"
)
;
uint32_t
surfaceCacheExpirationTimeMS
=
gfxPrefs
:
:
ImageMemSurfaceCacheMinExpirationMS
(
)
;
uint32_t
surfaceCacheDiscardFactor
=
max
(
gfxPrefs
:
:
ImageMemSurfaceCacheDiscardFactor
(
)
1u
)
;
uint64_t
surfaceCacheMaxSizeKB
=
gfxPrefs
:
:
ImageMemSurfaceCacheMaxSizeKB
(
)
;
uint32_t
surfaceCacheSizeFactor
=
max
(
gfxPrefs
:
:
ImageMemSurfaceCacheSizeFactor
(
)
1u
)
;
uint64_t
memorySize
=
PR_GetPhysicalMemorySize
(
)
;
if
(
memorySize
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
PR_GetPhysicalMemorySize
not
implemented
here
"
)
;
memorySize
=
256
*
1024
*
1024
;
}
uint64_t
proposedSize
=
memorySize
/
surfaceCacheSizeFactor
;
uint64_t
surfaceCacheSizeBytes
=
min
(
proposedSize
surfaceCacheMaxSizeKB
*
1024
)
;
uint32_t
finalSurfaceCacheSizeBytes
=
min
(
surfaceCacheSizeBytes
uint64_t
(
UINT32_MAX
)
)
;
sInstance
=
new
SurfaceCacheImpl
(
surfaceCacheExpirationTimeMS
surfaceCacheDiscardFactor
finalSurfaceCacheSizeBytes
)
;
sInstance
-
>
InitMemoryReporter
(
)
;
}
void
SurfaceCache
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
sInstance
"
No
singleton
-
was
Shutdown
(
)
called
twice
?
"
)
;
sInstance
=
nullptr
;
}
LookupResult
SurfaceCache
:
:
Lookup
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
if
(
!
sInstance
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
Lookup
(
aImageKey
aSurfaceKey
)
;
}
LookupResult
SurfaceCache
:
:
LookupBestMatch
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
if
(
!
sInstance
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
LookupBestMatch
(
aImageKey
aSurfaceKey
)
;
}
InsertOutcome
SurfaceCache
:
:
Insert
(
imgFrame
*
aSurface
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
if
(
!
sInstance
)
{
return
InsertOutcome
:
:
FAILURE
;
}
if
(
!
aSurface
)
{
MOZ_CRASH
(
"
Don
'
t
pass
null
surfaces
to
SurfaceCache
:
:
Insert
"
)
;
}
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
Cost
cost
=
ComputeCost
(
aSurface
-
>
GetSize
(
)
aSurface
-
>
GetBytesPerPixel
(
)
)
;
return
sInstance
-
>
Insert
(
aSurface
cost
aImageKey
aSurfaceKey
)
;
}
InsertOutcome
SurfaceCache
:
:
InsertPlaceholder
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
if
(
!
sInstance
)
{
return
InsertOutcome
:
:
FAILURE
;
}
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
Insert
(
nullptr
sPlaceholderCost
aImageKey
aSurfaceKey
)
;
}
bool
SurfaceCache
:
:
CanHold
(
const
IntSize
&
aSize
uint32_t
aBytesPerPixel
)
{
if
(
!
sInstance
)
{
return
false
;
}
Cost
cost
=
ComputeCost
(
aSize
aBytesPerPixel
)
;
return
sInstance
-
>
CanHold
(
cost
)
;
}
bool
SurfaceCache
:
:
CanHold
(
size_t
aSize
)
{
if
(
!
sInstance
)
{
return
false
;
}
return
sInstance
-
>
CanHold
(
aSize
)
;
}
void
SurfaceCache
:
:
LockImage
(
Image
*
aImageKey
)
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
LockImage
(
aImageKey
)
;
}
}
void
SurfaceCache
:
:
UnlockImage
(
Image
*
aImageKey
)
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
UnlockImage
(
aImageKey
)
;
}
}
void
SurfaceCache
:
:
UnlockSurfaces
(
const
ImageKey
aImageKey
)
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
UnlockSurfaces
(
aImageKey
)
;
}
}
void
SurfaceCache
:
:
RemoveSurface
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
)
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
sInstance
-
>
RemoveSurface
(
aImageKey
aSurfaceKey
)
;
}
}
void
SurfaceCache
:
:
RemoveImage
(
Image
*
aImageKey
)
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
sInstance
-
>
RemoveImage
(
aImageKey
)
;
}
}
void
SurfaceCache
:
:
DiscardAll
(
)
{
if
(
sInstance
)
{
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
sInstance
-
>
DiscardAll
(
)
;
}
}
void
SurfaceCache
:
:
CollectSizeOfSurfaces
(
const
ImageKey
aImageKey
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
{
if
(
!
sInstance
)
{
return
;
}
MutexAutoLock
lock
(
sInstance
-
>
GetMutex
(
)
)
;
return
sInstance
-
>
CollectSizeOfSurfaces
(
aImageKey
aCounters
aMallocSizeOf
)
;
}
}
}
