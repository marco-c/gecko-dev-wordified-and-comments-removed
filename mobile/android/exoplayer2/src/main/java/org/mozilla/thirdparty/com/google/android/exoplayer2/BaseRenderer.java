package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
;
import
android
.
os
.
Looper
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmInitData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
ExoMediaCrypto
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SampleStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MediaClock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
public
abstract
class
BaseRenderer
implements
Renderer
RendererCapabilities
{
private
final
int
trackType
;
private
final
FormatHolder
formatHolder
;
private
RendererConfiguration
configuration
;
private
int
index
;
private
int
state
;
private
SampleStream
stream
;
private
Format
[
]
streamFormats
;
private
long
streamOffsetUs
;
private
long
readingPositionUs
;
private
boolean
streamIsFinal
;
private
boolean
throwRendererExceptionIsExecuting
;
public
BaseRenderer
(
int
trackType
)
{
this
.
trackType
=
trackType
;
formatHolder
=
new
FormatHolder
(
)
;
readingPositionUs
=
C
.
TIME_END_OF_SOURCE
;
}
Override
public
final
int
getTrackType
(
)
{
return
trackType
;
}
Override
public
final
RendererCapabilities
getCapabilities
(
)
{
return
this
;
}
Override
public
final
void
setIndex
(
int
index
)
{
this
.
index
=
index
;
}
Override
Nullable
public
MediaClock
getMediaClock
(
)
{
return
null
;
}
Override
public
final
int
getState
(
)
{
return
state
;
}
Override
public
final
void
enable
(
RendererConfiguration
configuration
Format
[
]
formats
SampleStream
stream
long
positionUs
boolean
joining
long
offsetUs
)
throws
ExoPlaybackException
{
Assertions
.
checkState
(
state
=
=
STATE_DISABLED
)
;
this
.
configuration
=
configuration
;
state
=
STATE_ENABLED
;
onEnabled
(
joining
)
;
replaceStream
(
formats
stream
offsetUs
)
;
onPositionReset
(
positionUs
joining
)
;
}
Override
public
final
void
start
(
)
throws
ExoPlaybackException
{
Assertions
.
checkState
(
state
=
=
STATE_ENABLED
)
;
state
=
STATE_STARTED
;
onStarted
(
)
;
}
Override
public
final
void
replaceStream
(
Format
[
]
formats
SampleStream
stream
long
offsetUs
)
throws
ExoPlaybackException
{
Assertions
.
checkState
(
!
streamIsFinal
)
;
this
.
stream
=
stream
;
readingPositionUs
=
offsetUs
;
streamFormats
=
formats
;
streamOffsetUs
=
offsetUs
;
onStreamChanged
(
formats
offsetUs
)
;
}
Override
Nullable
public
final
SampleStream
getStream
(
)
{
return
stream
;
}
Override
public
final
boolean
hasReadStreamToEnd
(
)
{
return
readingPositionUs
=
=
C
.
TIME_END_OF_SOURCE
;
}
Override
public
final
long
getReadingPositionUs
(
)
{
return
readingPositionUs
;
}
Override
public
final
void
setCurrentStreamFinal
(
)
{
streamIsFinal
=
true
;
}
Override
public
final
boolean
isCurrentStreamFinal
(
)
{
return
streamIsFinal
;
}
Override
public
final
void
maybeThrowStreamError
(
)
throws
IOException
{
stream
.
maybeThrowError
(
)
;
}
Override
public
final
void
resetPosition
(
long
positionUs
)
throws
ExoPlaybackException
{
streamIsFinal
=
false
;
readingPositionUs
=
positionUs
;
onPositionReset
(
positionUs
false
)
;
}
Override
public
final
void
stop
(
)
throws
ExoPlaybackException
{
Assertions
.
checkState
(
state
=
=
STATE_STARTED
)
;
state
=
STATE_ENABLED
;
onStopped
(
)
;
}
Override
public
final
void
disable
(
)
{
Assertions
.
checkState
(
state
=
=
STATE_ENABLED
)
;
formatHolder
.
clear
(
)
;
state
=
STATE_DISABLED
;
stream
=
null
;
streamFormats
=
null
;
streamIsFinal
=
false
;
onDisabled
(
)
;
}
Override
public
final
void
reset
(
)
{
Assertions
.
checkState
(
state
=
=
STATE_DISABLED
)
;
formatHolder
.
clear
(
)
;
onReset
(
)
;
}
Override
AdaptiveSupport
public
int
supportsMixedMimeTypeAdaptation
(
)
throws
ExoPlaybackException
{
return
ADAPTIVE_NOT_SUPPORTED
;
}
Override
public
void
handleMessage
(
int
what
Nullable
Object
object
)
throws
ExoPlaybackException
{
}
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
}
protected
void
onStreamChanged
(
Format
[
]
formats
long
offsetUs
)
throws
ExoPlaybackException
{
}
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
}
protected
void
onStarted
(
)
throws
ExoPlaybackException
{
}
protected
void
onStopped
(
)
throws
ExoPlaybackException
{
}
protected
void
onDisabled
(
)
{
}
protected
void
onReset
(
)
{
}
protected
final
FormatHolder
getFormatHolder
(
)
{
formatHolder
.
clear
(
)
;
return
formatHolder
;
}
protected
final
Format
[
]
getStreamFormats
(
)
{
return
streamFormats
;
}
protected
final
RendererConfiguration
getConfiguration
(
)
{
return
configuration
;
}
Nullable
protected
final
<
T
extends
ExoMediaCrypto
>
DrmSession
<
T
>
getUpdatedSourceDrmSession
(
Nullable
Format
oldFormat
Format
newFormat
Nullable
DrmSessionManager
<
T
>
drmSessionManager
Nullable
DrmSession
<
T
>
existingSourceSession
)
throws
ExoPlaybackException
{
boolean
drmInitDataChanged
=
!
Util
.
areEqual
(
newFormat
.
drmInitData
oldFormat
=
=
null
?
null
:
oldFormat
.
drmInitData
)
;
if
(
!
drmInitDataChanged
)
{
return
existingSourceSession
;
}
Nullable
DrmSession
<
T
>
newSourceDrmSession
=
null
;
if
(
newFormat
.
drmInitData
!
=
null
)
{
if
(
drmSessionManager
=
=
null
)
{
throw
createRendererException
(
new
IllegalStateException
(
"
Media
requires
a
DrmSessionManager
"
)
newFormat
)
;
}
newSourceDrmSession
=
drmSessionManager
.
acquireSession
(
Assertions
.
checkNotNull
(
Looper
.
myLooper
(
)
)
newFormat
.
drmInitData
)
;
}
if
(
existingSourceSession
!
=
null
)
{
existingSourceSession
.
release
(
)
;
}
return
newSourceDrmSession
;
}
protected
final
int
getIndex
(
)
{
return
index
;
}
protected
final
ExoPlaybackException
createRendererException
(
Exception
cause
Nullable
Format
format
)
{
FormatSupport
int
formatSupport
=
RendererCapabilities
.
FORMAT_HANDLED
;
if
(
format
!
=
null
&
&
!
throwRendererExceptionIsExecuting
)
{
throwRendererExceptionIsExecuting
=
true
;
try
{
formatSupport
=
RendererCapabilities
.
getFormatSupport
(
supportsFormat
(
format
)
)
;
}
catch
(
ExoPlaybackException
e
)
{
}
finally
{
throwRendererExceptionIsExecuting
=
false
;
}
}
return
ExoPlaybackException
.
createForRenderer
(
cause
getIndex
(
)
format
formatSupport
)
;
}
protected
final
int
readSource
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
)
{
int
result
=
stream
.
readData
(
formatHolder
buffer
formatRequired
)
;
if
(
result
=
=
C
.
RESULT_BUFFER_READ
)
{
if
(
buffer
.
isEndOfStream
(
)
)
{
readingPositionUs
=
C
.
TIME_END_OF_SOURCE
;
return
streamIsFinal
?
C
.
RESULT_BUFFER_READ
:
C
.
RESULT_NOTHING_READ
;
}
buffer
.
timeUs
+
=
streamOffsetUs
;
readingPositionUs
=
Math
.
max
(
readingPositionUs
buffer
.
timeUs
)
;
}
else
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
Format
format
=
formatHolder
.
format
;
if
(
format
.
subsampleOffsetUs
!
=
Format
.
OFFSET_SAMPLE_RELATIVE
)
{
format
=
format
.
copyWithSubsampleOffsetUs
(
format
.
subsampleOffsetUs
+
streamOffsetUs
)
;
formatHolder
.
format
=
format
;
}
}
return
result
;
}
protected
int
skipSource
(
long
positionUs
)
{
return
stream
.
skipData
(
positionUs
-
streamOffsetUs
)
;
}
protected
final
boolean
isSourceReady
(
)
{
return
hasReadStreamToEnd
(
)
?
streamIsFinal
:
stream
.
isReady
(
)
;
}
protected
static
boolean
supportsFormatDrm
(
Nullable
DrmSessionManager
<
?
>
drmSessionManager
Nullable
DrmInitData
drmInitData
)
{
if
(
drmInitData
=
=
null
)
{
return
true
;
}
else
if
(
drmSessionManager
=
=
null
)
{
return
false
;
}
return
drmSessionManager
.
canAcquireSession
(
drmInitData
)
;
}
}
