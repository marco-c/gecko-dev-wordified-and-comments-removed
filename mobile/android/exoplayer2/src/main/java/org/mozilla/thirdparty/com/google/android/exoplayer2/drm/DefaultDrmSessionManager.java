package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmInitData
.
SchemeData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
.
DrmSessionException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
ExoMediaDrm
.
OnEventListener
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DefaultLoadErrorHandlingPolicy
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
LoadErrorHandlingPolicy
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
EventDispatcher
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
UUID
;
TargetApi
(
18
)
public
class
DefaultDrmSessionManager
<
T
extends
ExoMediaCrypto
>
implements
DrmSessionManager
<
T
>
{
public
static
final
class
Builder
{
private
final
HashMap
<
String
String
>
keyRequestParameters
;
private
UUID
uuid
;
private
ExoMediaDrm
.
Provider
<
ExoMediaCrypto
>
exoMediaDrmProvider
;
private
boolean
multiSession
;
private
int
[
]
useDrmSessionsForClearContentTrackTypes
;
private
boolean
playClearSamplesWithoutKeys
;
private
LoadErrorHandlingPolicy
loadErrorHandlingPolicy
;
SuppressWarnings
(
"
unchecked
"
)
public
Builder
(
)
{
keyRequestParameters
=
new
HashMap
<
>
(
)
;
uuid
=
C
.
WIDEVINE_UUID
;
exoMediaDrmProvider
=
(
ExoMediaDrm
.
Provider
)
FrameworkMediaDrm
.
DEFAULT_PROVIDER
;
loadErrorHandlingPolicy
=
new
DefaultLoadErrorHandlingPolicy
(
)
;
useDrmSessionsForClearContentTrackTypes
=
new
int
[
0
]
;
}
public
Builder
setKeyRequestParameters
(
Map
<
String
String
>
keyRequestParameters
)
{
this
.
keyRequestParameters
.
clear
(
)
;
this
.
keyRequestParameters
.
putAll
(
Assertions
.
checkNotNull
(
keyRequestParameters
)
)
;
return
this
;
}
SuppressWarnings
(
{
"
rawtypes
"
"
unchecked
"
}
)
public
Builder
setUuidAndExoMediaDrmProvider
(
UUID
uuid
ExoMediaDrm
.
Provider
exoMediaDrmProvider
)
{
this
.
uuid
=
Assertions
.
checkNotNull
(
uuid
)
;
this
.
exoMediaDrmProvider
=
Assertions
.
checkNotNull
(
exoMediaDrmProvider
)
;
return
this
;
}
public
Builder
setMultiSession
(
boolean
multiSession
)
{
this
.
multiSession
=
multiSession
;
return
this
;
}
public
Builder
setUseDrmSessionsForClearContent
(
int
.
.
.
useDrmSessionsForClearContentTrackTypes
)
{
for
(
int
trackType
:
useDrmSessionsForClearContentTrackTypes
)
{
Assertions
.
checkArgument
(
trackType
=
=
C
.
TRACK_TYPE_VIDEO
|
|
trackType
=
=
C
.
TRACK_TYPE_AUDIO
)
;
}
this
.
useDrmSessionsForClearContentTrackTypes
=
useDrmSessionsForClearContentTrackTypes
.
clone
(
)
;
return
this
;
}
public
Builder
setPlayClearSamplesWithoutKeys
(
boolean
playClearSamplesWithoutKeys
)
{
this
.
playClearSamplesWithoutKeys
=
playClearSamplesWithoutKeys
;
return
this
;
}
public
Builder
setLoadErrorHandlingPolicy
(
LoadErrorHandlingPolicy
loadErrorHandlingPolicy
)
{
this
.
loadErrorHandlingPolicy
=
Assertions
.
checkNotNull
(
loadErrorHandlingPolicy
)
;
return
this
;
}
public
DefaultDrmSessionManager
<
ExoMediaCrypto
>
build
(
MediaDrmCallback
mediaDrmCallback
)
{
return
new
DefaultDrmSessionManager
<
>
(
uuid
exoMediaDrmProvider
mediaDrmCallback
keyRequestParameters
multiSession
useDrmSessionsForClearContentTrackTypes
playClearSamplesWithoutKeys
loadErrorHandlingPolicy
)
;
}
}
public
static
final
class
MissingSchemeDataException
extends
Exception
{
private
MissingSchemeDataException
(
UUID
uuid
)
{
super
(
"
Media
does
not
support
uuid
:
"
+
uuid
)
;
}
}
public
static
final
String
PLAYREADY_CUSTOM_DATA_KEY
=
"
PRCustomData
"
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
MODE_PLAYBACK
MODE_QUERY
MODE_DOWNLOAD
MODE_RELEASE
}
)
public
interface
Mode
{
}
public
static
final
int
MODE_PLAYBACK
=
0
;
public
static
final
int
MODE_QUERY
=
1
;
public
static
final
int
MODE_DOWNLOAD
=
2
;
public
static
final
int
MODE_RELEASE
=
3
;
public
static
final
int
INITIAL_DRM_REQUEST_RETRY_COUNT
=
3
;
private
static
final
String
TAG
=
"
DefaultDrmSessionMgr
"
;
private
final
UUID
uuid
;
private
final
ExoMediaDrm
.
Provider
<
T
>
exoMediaDrmProvider
;
private
final
MediaDrmCallback
callback
;
private
final
HashMap
<
String
String
>
keyRequestParameters
;
private
final
EventDispatcher
<
DefaultDrmSessionEventListener
>
eventDispatcher
;
private
final
boolean
multiSession
;
private
final
int
[
]
useDrmSessionsForClearContentTrackTypes
;
private
final
boolean
playClearSamplesWithoutKeys
;
private
final
ProvisioningManagerImpl
provisioningManagerImpl
;
private
final
LoadErrorHandlingPolicy
loadErrorHandlingPolicy
;
private
final
List
<
DefaultDrmSession
<
T
>
>
sessions
;
private
final
List
<
DefaultDrmSession
<
T
>
>
provisioningSessions
;
private
int
prepareCallsCount
;
Nullable
private
ExoMediaDrm
<
T
>
exoMediaDrm
;
Nullable
private
DefaultDrmSession
<
T
>
placeholderDrmSession
;
Nullable
private
DefaultDrmSession
<
T
>
noMultiSessionDrmSession
;
Nullable
private
Looper
playbackLooper
;
private
int
mode
;
Nullable
private
byte
[
]
offlineLicenseKeySetId
;
volatile
Nullable
MediaDrmHandler
mediaDrmHandler
;
SuppressWarnings
(
"
deprecation
"
)
Deprecated
public
DefaultDrmSessionManager
(
UUID
uuid
ExoMediaDrm
<
T
>
exoMediaDrm
MediaDrmCallback
callback
Nullable
HashMap
<
String
String
>
keyRequestParameters
)
{
this
(
uuid
exoMediaDrm
callback
keyRequestParameters
=
=
null
?
new
HashMap
<
>
(
)
:
keyRequestParameters
false
INITIAL_DRM_REQUEST_RETRY_COUNT
)
;
}
Deprecated
public
DefaultDrmSessionManager
(
UUID
uuid
ExoMediaDrm
<
T
>
exoMediaDrm
MediaDrmCallback
callback
Nullable
HashMap
<
String
String
>
keyRequestParameters
boolean
multiSession
)
{
this
(
uuid
exoMediaDrm
callback
keyRequestParameters
=
=
null
?
new
HashMap
<
>
(
)
:
keyRequestParameters
multiSession
INITIAL_DRM_REQUEST_RETRY_COUNT
)
;
}
Deprecated
public
DefaultDrmSessionManager
(
UUID
uuid
ExoMediaDrm
<
T
>
exoMediaDrm
MediaDrmCallback
callback
Nullable
HashMap
<
String
String
>
keyRequestParameters
boolean
multiSession
int
initialDrmRequestRetryCount
)
{
this
(
uuid
new
ExoMediaDrm
.
AppManagedProvider
<
>
(
exoMediaDrm
)
callback
keyRequestParameters
=
=
null
?
new
HashMap
<
>
(
)
:
keyRequestParameters
multiSession
new
int
[
0
]
false
new
DefaultLoadErrorHandlingPolicy
(
initialDrmRequestRetryCount
)
)
;
}
SuppressWarnings
(
"
nullness
:
initialization
.
fields
.
uninitialized
"
)
private
DefaultDrmSessionManager
(
UUID
uuid
ExoMediaDrm
.
Provider
<
T
>
exoMediaDrmProvider
MediaDrmCallback
callback
HashMap
<
String
String
>
keyRequestParameters
boolean
multiSession
int
[
]
useDrmSessionsForClearContentTrackTypes
boolean
playClearSamplesWithoutKeys
LoadErrorHandlingPolicy
loadErrorHandlingPolicy
)
{
Assertions
.
checkNotNull
(
uuid
)
;
Assertions
.
checkArgument
(
!
C
.
COMMON_PSSH_UUID
.
equals
(
uuid
)
"
Use
C
.
CLEARKEY_UUID
instead
"
)
;
this
.
uuid
=
uuid
;
this
.
exoMediaDrmProvider
=
exoMediaDrmProvider
;
this
.
callback
=
callback
;
this
.
keyRequestParameters
=
keyRequestParameters
;
this
.
eventDispatcher
=
new
EventDispatcher
<
>
(
)
;
this
.
multiSession
=
multiSession
;
this
.
useDrmSessionsForClearContentTrackTypes
=
useDrmSessionsForClearContentTrackTypes
;
this
.
playClearSamplesWithoutKeys
=
playClearSamplesWithoutKeys
;
this
.
loadErrorHandlingPolicy
=
loadErrorHandlingPolicy
;
provisioningManagerImpl
=
new
ProvisioningManagerImpl
(
)
;
mode
=
MODE_PLAYBACK
;
sessions
=
new
ArrayList
<
>
(
)
;
provisioningSessions
=
new
ArrayList
<
>
(
)
;
}
public
final
void
addListener
(
Handler
handler
DefaultDrmSessionEventListener
eventListener
)
{
eventDispatcher
.
addListener
(
handler
eventListener
)
;
}
public
final
void
removeListener
(
DefaultDrmSessionEventListener
eventListener
)
{
eventDispatcher
.
removeListener
(
eventListener
)
;
}
public
void
setMode
(
Mode
int
mode
Nullable
byte
[
]
offlineLicenseKeySetId
)
{
Assertions
.
checkState
(
sessions
.
isEmpty
(
)
)
;
if
(
mode
=
=
MODE_QUERY
|
|
mode
=
=
MODE_RELEASE
)
{
Assertions
.
checkNotNull
(
offlineLicenseKeySetId
)
;
}
this
.
mode
=
mode
;
this
.
offlineLicenseKeySetId
=
offlineLicenseKeySetId
;
}
Override
public
final
void
prepare
(
)
{
if
(
prepareCallsCount
+
+
=
=
0
)
{
Assertions
.
checkState
(
exoMediaDrm
=
=
null
)
;
exoMediaDrm
=
exoMediaDrmProvider
.
acquireExoMediaDrm
(
uuid
)
;
exoMediaDrm
.
setOnEventListener
(
new
MediaDrmEventListener
(
)
)
;
}
}
Override
public
final
void
release
(
)
{
if
(
-
-
prepareCallsCount
=
=
0
)
{
Assertions
.
checkNotNull
(
exoMediaDrm
)
.
release
(
)
;
exoMediaDrm
=
null
;
}
}
Override
public
boolean
canAcquireSession
(
DrmInitData
drmInitData
)
{
if
(
offlineLicenseKeySetId
!
=
null
)
{
return
true
;
}
List
<
SchemeData
>
schemeDatas
=
getSchemeDatas
(
drmInitData
uuid
true
)
;
if
(
schemeDatas
.
isEmpty
(
)
)
{
if
(
drmInitData
.
schemeDataCount
=
=
1
&
&
drmInitData
.
get
(
0
)
.
matches
(
C
.
COMMON_PSSH_UUID
)
)
{
Log
.
w
(
TAG
"
DrmInitData
only
contains
common
PSSH
SchemeData
.
Assuming
support
for
:
"
+
uuid
)
;
}
else
{
return
false
;
}
}
String
schemeType
=
drmInitData
.
schemeType
;
if
(
schemeType
=
=
null
|
|
C
.
CENC_TYPE_cenc
.
equals
(
schemeType
)
)
{
return
true
;
}
else
if
(
C
.
CENC_TYPE_cbc1
.
equals
(
schemeType
)
|
|
C
.
CENC_TYPE_cbcs
.
equals
(
schemeType
)
|
|
C
.
CENC_TYPE_cens
.
equals
(
schemeType
)
)
{
return
Util
.
SDK_INT
>
=
25
;
}
return
true
;
}
Override
Nullable
public
DrmSession
<
T
>
acquirePlaceholderSession
(
Looper
playbackLooper
int
trackType
)
{
assertExpectedPlaybackLooper
(
playbackLooper
)
;
ExoMediaDrm
<
T
>
exoMediaDrm
=
Assertions
.
checkNotNull
(
this
.
exoMediaDrm
)
;
boolean
avoidPlaceholderDrmSessions
=
FrameworkMediaCrypto
.
class
.
equals
(
exoMediaDrm
.
getExoMediaCryptoType
(
)
)
&
&
FrameworkMediaCrypto
.
WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC
;
if
(
avoidPlaceholderDrmSessions
|
|
Util
.
linearSearch
(
useDrmSessionsForClearContentTrackTypes
trackType
)
=
=
C
.
INDEX_UNSET
|
|
exoMediaDrm
.
getExoMediaCryptoType
(
)
=
=
null
)
{
return
null
;
}
maybeCreateMediaDrmHandler
(
playbackLooper
)
;
if
(
placeholderDrmSession
=
=
null
)
{
DefaultDrmSession
<
T
>
placeholderDrmSession
=
createNewDefaultSession
(
Collections
.
emptyList
(
)
true
)
;
sessions
.
add
(
placeholderDrmSession
)
;
this
.
placeholderDrmSession
=
placeholderDrmSession
;
}
placeholderDrmSession
.
acquire
(
)
;
return
placeholderDrmSession
;
}
Override
public
DrmSession
<
T
>
acquireSession
(
Looper
playbackLooper
DrmInitData
drmInitData
)
{
assertExpectedPlaybackLooper
(
playbackLooper
)
;
maybeCreateMediaDrmHandler
(
playbackLooper
)
;
Nullable
List
<
SchemeData
>
schemeDatas
=
null
;
if
(
offlineLicenseKeySetId
=
=
null
)
{
schemeDatas
=
getSchemeDatas
(
drmInitData
uuid
false
)
;
if
(
schemeDatas
.
isEmpty
(
)
)
{
final
MissingSchemeDataException
error
=
new
MissingSchemeDataException
(
uuid
)
;
eventDispatcher
.
dispatch
(
listener
-
>
listener
.
onDrmSessionManagerError
(
error
)
)
;
return
new
ErrorStateDrmSession
<
>
(
new
DrmSessionException
(
error
)
)
;
}
}
Nullable
DefaultDrmSession
<
T
>
session
;
if
(
!
multiSession
)
{
session
=
noMultiSessionDrmSession
;
}
else
{
session
=
null
;
for
(
DefaultDrmSession
<
T
>
existingSession
:
sessions
)
{
if
(
Util
.
areEqual
(
existingSession
.
schemeDatas
schemeDatas
)
)
{
session
=
existingSession
;
break
;
}
}
}
if
(
session
=
=
null
)
{
session
=
createNewDefaultSession
(
schemeDatas
false
)
;
if
(
!
multiSession
)
{
noMultiSessionDrmSession
=
session
;
}
sessions
.
add
(
session
)
;
}
session
.
acquire
(
)
;
return
session
;
}
Override
Nullable
public
Class
<
T
>
getExoMediaCryptoType
(
DrmInitData
drmInitData
)
{
return
canAcquireSession
(
drmInitData
)
?
Assertions
.
checkNotNull
(
exoMediaDrm
)
.
getExoMediaCryptoType
(
)
:
null
;
}
private
void
assertExpectedPlaybackLooper
(
Looper
playbackLooper
)
{
Assertions
.
checkState
(
this
.
playbackLooper
=
=
null
|
|
this
.
playbackLooper
=
=
playbackLooper
)
;
this
.
playbackLooper
=
playbackLooper
;
}
private
void
maybeCreateMediaDrmHandler
(
Looper
playbackLooper
)
{
if
(
mediaDrmHandler
=
=
null
)
{
mediaDrmHandler
=
new
MediaDrmHandler
(
playbackLooper
)
;
}
}
private
DefaultDrmSession
<
T
>
createNewDefaultSession
(
Nullable
List
<
SchemeData
>
schemeDatas
boolean
isPlaceholderSession
)
{
Assertions
.
checkNotNull
(
exoMediaDrm
)
;
boolean
playClearSamplesWithoutKeys
=
this
.
playClearSamplesWithoutKeys
|
isPlaceholderSession
;
return
new
DefaultDrmSession
<
>
(
uuid
exoMediaDrm
provisioningManagerImpl
this
:
:
onSessionReleased
schemeDatas
mode
playClearSamplesWithoutKeys
isPlaceholderSession
offlineLicenseKeySetId
keyRequestParameters
callback
Assertions
.
checkNotNull
(
playbackLooper
)
eventDispatcher
loadErrorHandlingPolicy
)
;
}
private
void
onSessionReleased
(
DefaultDrmSession
<
T
>
drmSession
)
{
sessions
.
remove
(
drmSession
)
;
if
(
placeholderDrmSession
=
=
drmSession
)
{
placeholderDrmSession
=
null
;
}
if
(
noMultiSessionDrmSession
=
=
drmSession
)
{
noMultiSessionDrmSession
=
null
;
}
if
(
provisioningSessions
.
size
(
)
>
1
&
&
provisioningSessions
.
get
(
0
)
=
=
drmSession
)
{
provisioningSessions
.
get
(
1
)
.
provision
(
)
;
}
provisioningSessions
.
remove
(
drmSession
)
;
}
private
static
List
<
SchemeData
>
getSchemeDatas
(
DrmInitData
drmInitData
UUID
uuid
boolean
allowMissingData
)
{
List
<
SchemeData
>
matchingSchemeDatas
=
new
ArrayList
<
>
(
drmInitData
.
schemeDataCount
)
;
for
(
int
i
=
0
;
i
<
drmInitData
.
schemeDataCount
;
i
+
+
)
{
SchemeData
schemeData
=
drmInitData
.
get
(
i
)
;
boolean
uuidMatches
=
schemeData
.
matches
(
uuid
)
|
|
(
C
.
CLEARKEY_UUID
.
equals
(
uuid
)
&
&
schemeData
.
matches
(
C
.
COMMON_PSSH_UUID
)
)
;
if
(
uuidMatches
&
&
(
schemeData
.
data
!
=
null
|
|
allowMissingData
)
)
{
matchingSchemeDatas
.
add
(
schemeData
)
;
}
}
return
matchingSchemeDatas
;
}
SuppressLint
(
"
HandlerLeak
"
)
private
class
MediaDrmHandler
extends
Handler
{
public
MediaDrmHandler
(
Looper
looper
)
{
super
(
looper
)
;
}
Override
public
void
handleMessage
(
Message
msg
)
{
byte
[
]
sessionId
=
(
byte
[
]
)
msg
.
obj
;
if
(
sessionId
=
=
null
)
{
return
;
}
for
(
DefaultDrmSession
<
T
>
session
:
sessions
)
{
if
(
session
.
hasSessionId
(
sessionId
)
)
{
session
.
onMediaDrmEvent
(
msg
.
what
)
;
return
;
}
}
}
}
private
class
ProvisioningManagerImpl
implements
DefaultDrmSession
.
ProvisioningManager
<
T
>
{
Override
public
void
provisionRequired
(
DefaultDrmSession
<
T
>
session
)
{
if
(
provisioningSessions
.
contains
(
session
)
)
{
return
;
}
provisioningSessions
.
add
(
session
)
;
if
(
provisioningSessions
.
size
(
)
=
=
1
)
{
session
.
provision
(
)
;
}
}
Override
public
void
onProvisionCompleted
(
)
{
for
(
DefaultDrmSession
<
T
>
session
:
provisioningSessions
)
{
session
.
onProvisionCompleted
(
)
;
}
provisioningSessions
.
clear
(
)
;
}
Override
public
void
onProvisionError
(
Exception
error
)
{
for
(
DefaultDrmSession
<
T
>
session
:
provisioningSessions
)
{
session
.
onProvisionError
(
error
)
;
}
provisioningSessions
.
clear
(
)
;
}
}
private
class
MediaDrmEventListener
implements
OnEventListener
<
T
>
{
Override
public
void
onEvent
(
ExoMediaDrm
<
?
extends
T
>
md
Nullable
byte
[
]
sessionId
int
event
int
extra
Nullable
byte
[
]
data
)
{
Assertions
.
checkNotNull
(
mediaDrmHandler
)
.
obtainMessage
(
event
sessionId
)
.
sendToTarget
(
)
;
}
}
}
