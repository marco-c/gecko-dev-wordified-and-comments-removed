package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
nio
.
ByteBuffer
;
final
class
FloatResamplingAudioProcessor
extends
BaseAudioProcessor
{
private
static
final
int
FLOAT_NAN_AS_INT
=
Float
.
floatToIntBits
(
Float
.
NaN
)
;
private
static
final
double
PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR
=
1
.
0
/
0x7FFFFFFF
;
Override
public
AudioFormat
onConfigure
(
AudioFormat
inputAudioFormat
)
throws
UnhandledAudioFormatException
{
C
.
PcmEncoding
int
encoding
=
inputAudioFormat
.
encoding
;
if
(
!
Util
.
isEncodingHighResolutionPcm
(
encoding
)
)
{
throw
new
UnhandledAudioFormatException
(
inputAudioFormat
)
;
}
return
encoding
!
=
C
.
ENCODING_PCM_FLOAT
?
new
AudioFormat
(
inputAudioFormat
.
sampleRate
inputAudioFormat
.
channelCount
C
.
ENCODING_PCM_FLOAT
)
:
AudioFormat
.
NOT_SET
;
}
Override
public
void
queueInput
(
ByteBuffer
inputBuffer
)
{
int
position
=
inputBuffer
.
position
(
)
;
int
limit
=
inputBuffer
.
limit
(
)
;
int
size
=
limit
-
position
;
ByteBuffer
buffer
;
switch
(
inputAudioFormat
.
encoding
)
{
case
C
.
ENCODING_PCM_24BIT
:
buffer
=
replaceOutputBuffer
(
(
size
/
3
)
*
4
)
;
for
(
int
i
=
position
;
i
<
limit
;
i
+
=
3
)
{
int
pcm32BitInteger
=
(
(
inputBuffer
.
get
(
i
)
&
0xFF
)
<
<
8
)
|
(
(
inputBuffer
.
get
(
i
+
1
)
&
0xFF
)
<
<
16
)
|
(
(
inputBuffer
.
get
(
i
+
2
)
&
0xFF
)
<
<
24
)
;
writePcm32BitFloat
(
pcm32BitInteger
buffer
)
;
}
break
;
case
C
.
ENCODING_PCM_32BIT
:
buffer
=
replaceOutputBuffer
(
size
)
;
for
(
int
i
=
position
;
i
<
limit
;
i
+
=
4
)
{
int
pcm32BitInteger
=
(
inputBuffer
.
get
(
i
)
&
0xFF
)
|
(
(
inputBuffer
.
get
(
i
+
1
)
&
0xFF
)
<
<
8
)
|
(
(
inputBuffer
.
get
(
i
+
2
)
&
0xFF
)
<
<
16
)
|
(
(
inputBuffer
.
get
(
i
+
3
)
&
0xFF
)
<
<
24
)
;
writePcm32BitFloat
(
pcm32BitInteger
buffer
)
;
}
break
;
case
C
.
ENCODING_PCM_8BIT
:
case
C
.
ENCODING_PCM_16BIT
:
case
C
.
ENCODING_PCM_16BIT_BIG_ENDIAN
:
case
C
.
ENCODING_PCM_FLOAT
:
case
C
.
ENCODING_INVALID
:
case
Format
.
NO_VALUE
:
default
:
throw
new
IllegalStateException
(
)
;
}
inputBuffer
.
position
(
inputBuffer
.
limit
(
)
)
;
buffer
.
flip
(
)
;
}
private
static
void
writePcm32BitFloat
(
int
pcm32BitInt
ByteBuffer
buffer
)
{
float
pcm32BitFloat
=
(
float
)
(
PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR
*
pcm32BitInt
)
;
int
floatBits
=
Float
.
floatToIntBits
(
pcm32BitFloat
)
;
if
(
floatBits
=
=
FLOAT_NAN_AS_INT
)
{
floatBits
=
Float
.
floatToIntBits
(
(
float
)
0
.
0
)
;
}
buffer
.
putInt
(
floatBits
)
;
}
}
