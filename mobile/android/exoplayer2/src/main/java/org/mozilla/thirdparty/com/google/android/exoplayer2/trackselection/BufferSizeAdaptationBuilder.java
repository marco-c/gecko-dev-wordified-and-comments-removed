package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
;
import
android
.
util
.
Pair
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
DefaultLoadControl
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
LoadControl
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
MediaChunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
MediaChunkIterator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
.
Definition
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
BandwidthMeter
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DefaultAllocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Clock
;
import
java
.
util
.
List
;
import
org
.
checkerframework
.
checker
.
nullness
.
compatqual
.
NullableType
;
public
final
class
BufferSizeAdaptationBuilder
{
public
interface
DynamicFormatFilter
{
DynamicFormatFilter
NO_FILTER
=
(
format
trackBitrate
isInitialSelection
)
-
>
true
;
boolean
isFormatAllowed
(
Format
format
int
trackBitrate
boolean
isInitialSelection
)
;
}
public
static
final
int
DEFAULT_MIN_BUFFER_MS
=
15000
;
public
static
final
int
DEFAULT_MAX_BUFFER_MS
=
50000
;
public
static
final
int
DEFAULT_BUFFER_FOR_PLAYBACK_MS
=
DefaultLoadControl
.
DEFAULT_BUFFER_FOR_PLAYBACK_MS
;
public
static
final
int
DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS
=
DefaultLoadControl
.
DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS
;
public
static
final
int
DEFAULT_HYSTERESIS_BUFFER_MS
=
5000
;
public
static
final
float
DEFAULT_START_UP_BANDWIDTH_FRACTION
=
AdaptiveTrackSelection
.
DEFAULT_BANDWIDTH_FRACTION
;
public
static
final
int
DEFAULT_START_UP_MIN_BUFFER_FOR_QUALITY_INCREASE_MS
=
AdaptiveTrackSelection
.
DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS
;
Nullable
private
DefaultAllocator
allocator
;
private
Clock
clock
;
private
int
minBufferMs
;
private
int
maxBufferMs
;
private
int
bufferForPlaybackMs
;
private
int
bufferForPlaybackAfterRebufferMs
;
private
int
hysteresisBufferMs
;
private
float
startUpBandwidthFraction
;
private
int
startUpMinBufferForQualityIncreaseMs
;
private
DynamicFormatFilter
dynamicFormatFilter
;
private
boolean
buildCalled
;
public
BufferSizeAdaptationBuilder
(
)
{
clock
=
Clock
.
DEFAULT
;
minBufferMs
=
DEFAULT_MIN_BUFFER_MS
;
maxBufferMs
=
DEFAULT_MAX_BUFFER_MS
;
bufferForPlaybackMs
=
DEFAULT_BUFFER_FOR_PLAYBACK_MS
;
bufferForPlaybackAfterRebufferMs
=
DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS
;
hysteresisBufferMs
=
DEFAULT_HYSTERESIS_BUFFER_MS
;
startUpBandwidthFraction
=
DEFAULT_START_UP_BANDWIDTH_FRACTION
;
startUpMinBufferForQualityIncreaseMs
=
DEFAULT_START_UP_MIN_BUFFER_FOR_QUALITY_INCREASE_MS
;
dynamicFormatFilter
=
DynamicFormatFilter
.
NO_FILTER
;
}
public
BufferSizeAdaptationBuilder
setClock
(
Clock
clock
)
{
Assertions
.
checkState
(
!
buildCalled
)
;
this
.
clock
=
clock
;
return
this
;
}
public
BufferSizeAdaptationBuilder
setAllocator
(
DefaultAllocator
allocator
)
{
Assertions
.
checkState
(
!
buildCalled
)
;
this
.
allocator
=
allocator
;
return
this
;
}
public
BufferSizeAdaptationBuilder
setBufferDurationsMs
(
int
minBufferMs
int
maxBufferMs
int
bufferForPlaybackMs
int
bufferForPlaybackAfterRebufferMs
)
{
Assertions
.
checkState
(
!
buildCalled
)
;
this
.
minBufferMs
=
minBufferMs
;
this
.
maxBufferMs
=
maxBufferMs
;
this
.
bufferForPlaybackMs
=
bufferForPlaybackMs
;
this
.
bufferForPlaybackAfterRebufferMs
=
bufferForPlaybackAfterRebufferMs
;
return
this
;
}
public
BufferSizeAdaptationBuilder
setHysteresisBufferMs
(
int
hysteresisBufferMs
)
{
Assertions
.
checkState
(
!
buildCalled
)
;
this
.
hysteresisBufferMs
=
hysteresisBufferMs
;
return
this
;
}
public
BufferSizeAdaptationBuilder
setStartUpTrackSelectionParameters
(
float
bandwidthFraction
int
minBufferForQualityIncreaseMs
)
{
Assertions
.
checkState
(
!
buildCalled
)
;
this
.
startUpBandwidthFraction
=
bandwidthFraction
;
this
.
startUpMinBufferForQualityIncreaseMs
=
minBufferForQualityIncreaseMs
;
return
this
;
}
public
BufferSizeAdaptationBuilder
setDynamicFormatFilter
(
DynamicFormatFilter
dynamicFormatFilter
)
{
Assertions
.
checkState
(
!
buildCalled
)
;
this
.
dynamicFormatFilter
=
dynamicFormatFilter
;
return
this
;
}
public
Pair
<
TrackSelection
.
Factory
LoadControl
>
buildPlayerComponents
(
)
{
Assertions
.
checkArgument
(
hysteresisBufferMs
<
maxBufferMs
-
minBufferMs
)
;
Assertions
.
checkState
(
!
buildCalled
)
;
buildCalled
=
true
;
DefaultLoadControl
.
Builder
loadControlBuilder
=
new
DefaultLoadControl
.
Builder
(
)
.
setTargetBufferBytes
(
Integer
.
MAX_VALUE
)
.
setBufferDurationsMs
(
maxBufferMs
maxBufferMs
bufferForPlaybackMs
bufferForPlaybackAfterRebufferMs
)
;
if
(
allocator
!
=
null
)
{
loadControlBuilder
.
setAllocator
(
allocator
)
;
}
TrackSelection
.
Factory
trackSelectionFactory
=
new
TrackSelection
.
Factory
(
)
{
Override
public
NullableType
TrackSelection
[
]
createTrackSelections
(
NullableType
Definition
[
]
definitions
BandwidthMeter
bandwidthMeter
)
{
return
TrackSelectionUtil
.
createTrackSelectionsForDefinitions
(
definitions
definition
-
>
new
BufferSizeAdaptiveTrackSelection
(
definition
.
group
definition
.
tracks
bandwidthMeter
minBufferMs
maxBufferMs
hysteresisBufferMs
startUpBandwidthFraction
startUpMinBufferForQualityIncreaseMs
dynamicFormatFilter
clock
)
)
;
}
}
;
return
Pair
.
create
(
trackSelectionFactory
loadControlBuilder
.
createDefaultLoadControl
(
)
)
;
}
private
static
final
class
BufferSizeAdaptiveTrackSelection
extends
BaseTrackSelection
{
private
static
final
int
BITRATE_BLACKLISTED
=
Format
.
NO_VALUE
;
private
final
BandwidthMeter
bandwidthMeter
;
private
final
Clock
clock
;
private
final
DynamicFormatFilter
dynamicFormatFilter
;
private
final
int
[
]
formatBitrates
;
private
final
long
minBufferUs
;
private
final
long
maxBufferUs
;
private
final
long
hysteresisBufferUs
;
private
final
float
startUpBandwidthFraction
;
private
final
long
startUpMinBufferForQualityIncreaseUs
;
private
final
int
minBitrate
;
private
final
int
maxBitrate
;
private
final
double
bitrateToBufferFunctionSlope
;
private
final
double
bitrateToBufferFunctionIntercept
;
private
boolean
isInSteadyState
;
private
int
selectedIndex
;
private
int
selectionReason
;
private
float
playbackSpeed
;
private
BufferSizeAdaptiveTrackSelection
(
TrackGroup
trackGroup
int
[
]
tracks
BandwidthMeter
bandwidthMeter
int
minBufferMs
int
maxBufferMs
int
hysteresisBufferMs
float
startUpBandwidthFraction
int
startUpMinBufferForQualityIncreaseMs
DynamicFormatFilter
dynamicFormatFilter
Clock
clock
)
{
super
(
trackGroup
tracks
)
;
this
.
bandwidthMeter
=
bandwidthMeter
;
this
.
minBufferUs
=
C
.
msToUs
(
minBufferMs
)
;
this
.
maxBufferUs
=
C
.
msToUs
(
maxBufferMs
)
;
this
.
hysteresisBufferUs
=
C
.
msToUs
(
hysteresisBufferMs
)
;
this
.
startUpBandwidthFraction
=
startUpBandwidthFraction
;
this
.
startUpMinBufferForQualityIncreaseUs
=
C
.
msToUs
(
startUpMinBufferForQualityIncreaseMs
)
;
this
.
dynamicFormatFilter
=
dynamicFormatFilter
;
this
.
clock
=
clock
;
formatBitrates
=
new
int
[
length
]
;
maxBitrate
=
getFormat
(
0
)
.
bitrate
;
minBitrate
=
getFormat
(
length
-
1
)
.
bitrate
;
selectionReason
=
C
.
SELECTION_REASON_UNKNOWN
;
playbackSpeed
=
1
.
0f
;
bitrateToBufferFunctionSlope
=
(
maxBufferUs
-
hysteresisBufferUs
-
minBufferUs
)
/
Math
.
log
(
(
double
)
maxBitrate
/
minBitrate
)
;
bitrateToBufferFunctionIntercept
=
minBufferUs
-
bitrateToBufferFunctionSlope
*
Math
.
log
(
minBitrate
)
;
}
Override
public
void
onPlaybackSpeed
(
float
playbackSpeed
)
{
this
.
playbackSpeed
=
playbackSpeed
;
}
Override
public
void
onDiscontinuity
(
)
{
isInSteadyState
=
false
;
}
Override
public
int
getSelectedIndex
(
)
{
return
selectedIndex
;
}
Override
public
int
getSelectionReason
(
)
{
return
selectionReason
;
}
Override
Nullable
public
Object
getSelectionData
(
)
{
return
null
;
}
Override
public
void
updateSelectedTrack
(
long
playbackPositionUs
long
bufferedDurationUs
long
availableDurationUs
List
<
?
extends
MediaChunk
>
queue
MediaChunkIterator
[
]
mediaChunkIterators
)
{
updateFormatBitrates
(
clock
.
elapsedRealtime
(
)
)
;
if
(
selectionReason
=
=
C
.
SELECTION_REASON_UNKNOWN
)
{
selectionReason
=
C
.
SELECTION_REASON_INITIAL
;
selectedIndex
=
selectIdealIndexUsingBandwidth
(
true
)
;
return
;
}
long
bufferUs
=
getCurrentPeriodBufferedDurationUs
(
playbackPositionUs
bufferedDurationUs
)
;
int
oldSelectedIndex
=
selectedIndex
;
if
(
isInSteadyState
)
{
selectIndexSteadyState
(
bufferUs
)
;
}
else
{
selectIndexStartUpPhase
(
bufferUs
)
;
}
if
(
selectedIndex
!
=
oldSelectedIndex
)
{
selectionReason
=
C
.
SELECTION_REASON_ADAPTIVE
;
}
}
private
void
selectIndexSteadyState
(
long
bufferUs
)
{
if
(
isOutsideHysteresis
(
bufferUs
)
)
{
selectedIndex
=
selectIdealIndexUsingBufferSize
(
bufferUs
)
;
}
}
private
boolean
isOutsideHysteresis
(
long
bufferUs
)
{
if
(
formatBitrates
[
selectedIndex
]
=
=
BITRATE_BLACKLISTED
)
{
return
true
;
}
long
targetBufferForCurrentBitrateUs
=
getTargetBufferForBitrateUs
(
formatBitrates
[
selectedIndex
]
)
;
long
bufferDiffUs
=
bufferUs
-
targetBufferForCurrentBitrateUs
;
return
Math
.
abs
(
bufferDiffUs
)
>
hysteresisBufferUs
;
}
private
int
selectIdealIndexUsingBufferSize
(
long
bufferUs
)
{
int
lowestBitrateNonBlacklistedIndex
=
0
;
for
(
int
i
=
0
;
i
<
formatBitrates
.
length
;
i
+
+
)
{
if
(
formatBitrates
[
i
]
!
=
BITRATE_BLACKLISTED
)
{
if
(
getTargetBufferForBitrateUs
(
formatBitrates
[
i
]
)
<
=
bufferUs
&
&
dynamicFormatFilter
.
isFormatAllowed
(
getFormat
(
i
)
formatBitrates
[
i
]
false
)
)
{
return
i
;
}
lowestBitrateNonBlacklistedIndex
=
i
;
}
}
return
lowestBitrateNonBlacklistedIndex
;
}
private
void
selectIndexStartUpPhase
(
long
bufferUs
)
{
int
startUpSelectedIndex
=
selectIdealIndexUsingBandwidth
(
false
)
;
int
steadyStateSelectedIndex
=
selectIdealIndexUsingBufferSize
(
bufferUs
)
;
if
(
steadyStateSelectedIndex
<
=
selectedIndex
)
{
selectedIndex
=
steadyStateSelectedIndex
;
isInSteadyState
=
true
;
}
else
{
if
(
bufferUs
<
startUpMinBufferForQualityIncreaseUs
&
&
startUpSelectedIndex
<
selectedIndex
&
&
formatBitrates
[
selectedIndex
]
!
=
BITRATE_BLACKLISTED
)
{
return
;
}
selectedIndex
=
startUpSelectedIndex
;
}
}
private
int
selectIdealIndexUsingBandwidth
(
boolean
isInitialSelection
)
{
long
effectiveBitrate
=
(
long
)
(
bandwidthMeter
.
getBitrateEstimate
(
)
*
startUpBandwidthFraction
)
;
int
lowestBitrateNonBlacklistedIndex
=
0
;
for
(
int
i
=
0
;
i
<
formatBitrates
.
length
;
i
+
+
)
{
if
(
formatBitrates
[
i
]
!
=
BITRATE_BLACKLISTED
)
{
if
(
Math
.
round
(
formatBitrates
[
i
]
*
playbackSpeed
)
<
=
effectiveBitrate
&
&
dynamicFormatFilter
.
isFormatAllowed
(
getFormat
(
i
)
formatBitrates
[
i
]
isInitialSelection
)
)
{
return
i
;
}
lowestBitrateNonBlacklistedIndex
=
i
;
}
}
return
lowestBitrateNonBlacklistedIndex
;
}
private
void
updateFormatBitrates
(
long
nowMs
)
{
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
nowMs
=
=
Long
.
MIN_VALUE
|
|
!
isBlacklisted
(
i
nowMs
)
)
{
formatBitrates
[
i
]
=
getFormat
(
i
)
.
bitrate
;
}
else
{
formatBitrates
[
i
]
=
BITRATE_BLACKLISTED
;
}
}
}
private
long
getTargetBufferForBitrateUs
(
int
bitrate
)
{
if
(
bitrate
<
=
minBitrate
)
{
return
minBufferUs
;
}
if
(
bitrate
>
=
maxBitrate
)
{
return
maxBufferUs
-
hysteresisBufferUs
;
}
return
(
int
)
(
bitrateToBufferFunctionSlope
*
Math
.
log
(
bitrate
)
+
bitrateToBufferFunctionIntercept
)
;
}
private
static
long
getCurrentPeriodBufferedDurationUs
(
long
playbackPositionUs
long
bufferedDurationUs
)
{
return
playbackPositionUs
>
=
0
?
bufferedDurationUs
:
playbackPositionUs
+
bufferedDurationUs
;
}
}
}
