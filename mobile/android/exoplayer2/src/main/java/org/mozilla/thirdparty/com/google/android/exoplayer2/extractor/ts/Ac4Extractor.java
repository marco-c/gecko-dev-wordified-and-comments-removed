package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
Ac4Util
.
AC40_SYNCWORD
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
Ac4Util
.
AC41_SYNCWORD
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
FLAG_DATA_ALIGNMENT_INDICATOR
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
id3
.
Id3Decoder
.
ID3_HEADER_LENGTH
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
id3
.
Id3Decoder
.
ID3_TAG
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
Ac4Util
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
TrackIdGenerator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
public
final
class
Ac4Extractor
implements
Extractor
{
public
static
final
ExtractorsFactory
FACTORY
=
(
)
-
>
new
Extractor
[
]
{
new
Ac4Extractor
(
)
}
;
private
static
final
int
MAX_SNIFF_BYTES
=
8
*
1024
;
private
static
final
int
READ_BUFFER_SIZE
=
16384
;
private
static
final
int
FRAME_HEADER_SIZE
=
7
;
private
final
Ac4Reader
reader
;
private
final
ParsableByteArray
sampleData
;
private
boolean
startedPacket
;
public
Ac4Extractor
(
)
{
reader
=
new
Ac4Reader
(
)
;
sampleData
=
new
ParsableByteArray
(
READ_BUFFER_SIZE
)
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
ParsableByteArray
scratch
=
new
ParsableByteArray
(
ID3_HEADER_LENGTH
)
;
int
startPosition
=
0
;
while
(
true
)
{
input
.
peekFully
(
scratch
.
data
0
ID3_HEADER_LENGTH
)
;
scratch
.
setPosition
(
0
)
;
if
(
scratch
.
readUnsignedInt24
(
)
!
=
ID3_TAG
)
{
break
;
}
scratch
.
skipBytes
(
3
)
;
int
length
=
scratch
.
readSynchSafeInt
(
)
;
startPosition
+
=
10
+
length
;
input
.
advancePeekPosition
(
length
)
;
}
input
.
resetPeekPosition
(
)
;
input
.
advancePeekPosition
(
startPosition
)
;
int
headerPosition
=
startPosition
;
int
validFramesCount
=
0
;
while
(
true
)
{
input
.
peekFully
(
scratch
.
data
0
FRAME_HEADER_SIZE
)
;
scratch
.
setPosition
(
0
)
;
int
syncBytes
=
scratch
.
readUnsignedShort
(
)
;
if
(
syncBytes
!
=
AC40_SYNCWORD
&
&
syncBytes
!
=
AC41_SYNCWORD
)
{
validFramesCount
=
0
;
input
.
resetPeekPosition
(
)
;
if
(
+
+
headerPosition
-
startPosition
>
=
MAX_SNIFF_BYTES
)
{
return
false
;
}
input
.
advancePeekPosition
(
headerPosition
)
;
}
else
{
if
(
+
+
validFramesCount
>
=
4
)
{
return
true
;
}
int
frameSize
=
Ac4Util
.
parseAc4SyncframeSize
(
scratch
.
data
syncBytes
)
;
if
(
frameSize
=
=
C
.
LENGTH_UNSET
)
{
return
false
;
}
input
.
advancePeekPosition
(
frameSize
-
FRAME_HEADER_SIZE
)
;
}
}
}
Override
public
void
init
(
ExtractorOutput
output
)
{
reader
.
createTracks
(
output
new
TrackIdGenerator
(
0
1
)
)
;
output
.
endTracks
(
)
;
output
.
seekMap
(
new
SeekMap
.
Unseekable
(
C
.
TIME_UNSET
)
)
;
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
startedPacket
=
false
;
reader
.
seek
(
)
;
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
int
bytesRead
=
input
.
read
(
sampleData
.
data
0
READ_BUFFER_SIZE
)
;
if
(
bytesRead
=
=
C
.
RESULT_END_OF_INPUT
)
{
return
RESULT_END_OF_INPUT
;
}
sampleData
.
setPosition
(
0
)
;
sampleData
.
setLimit
(
bytesRead
)
;
if
(
!
startedPacket
)
{
reader
.
packetStarted
(
0
FLAG_DATA_ALIGNMENT_INDICATOR
)
;
startedPacket
=
true
;
}
reader
.
consume
(
sampleData
)
;
return
RESULT_CONTINUE
;
}
}
