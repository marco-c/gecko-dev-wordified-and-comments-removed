package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
CryptoInfo
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
.
CryptoData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SampleQueue
.
SampleExtrasHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocation
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
Arrays
;
class
SampleDataQueue
{
private
static
final
int
INITIAL_SCRATCH_SIZE
=
32
;
private
final
Allocator
allocator
;
private
final
int
allocationLength
;
private
final
ParsableByteArray
scratch
;
private
AllocationNode
firstAllocationNode
;
private
AllocationNode
readAllocationNode
;
private
AllocationNode
writeAllocationNode
;
private
long
totalBytesWritten
;
public
SampleDataQueue
(
Allocator
allocator
)
{
this
.
allocator
=
allocator
;
allocationLength
=
allocator
.
getIndividualAllocationLength
(
)
;
scratch
=
new
ParsableByteArray
(
INITIAL_SCRATCH_SIZE
)
;
firstAllocationNode
=
new
AllocationNode
(
0
allocationLength
)
;
readAllocationNode
=
firstAllocationNode
;
writeAllocationNode
=
firstAllocationNode
;
}
public
void
reset
(
)
{
clearAllocationNodes
(
firstAllocationNode
)
;
firstAllocationNode
=
new
AllocationNode
(
0
allocationLength
)
;
readAllocationNode
=
firstAllocationNode
;
writeAllocationNode
=
firstAllocationNode
;
totalBytesWritten
=
0
;
allocator
.
trim
(
)
;
}
public
void
discardUpstreamSampleBytes
(
long
totalBytesWritten
)
{
this
.
totalBytesWritten
=
totalBytesWritten
;
if
(
this
.
totalBytesWritten
=
=
0
|
|
this
.
totalBytesWritten
=
=
firstAllocationNode
.
startPosition
)
{
clearAllocationNodes
(
firstAllocationNode
)
;
firstAllocationNode
=
new
AllocationNode
(
this
.
totalBytesWritten
allocationLength
)
;
readAllocationNode
=
firstAllocationNode
;
writeAllocationNode
=
firstAllocationNode
;
}
else
{
AllocationNode
lastNodeToKeep
=
firstAllocationNode
;
while
(
this
.
totalBytesWritten
>
lastNodeToKeep
.
endPosition
)
{
lastNodeToKeep
=
lastNodeToKeep
.
next
;
}
AllocationNode
firstNodeToDiscard
=
lastNodeToKeep
.
next
;
clearAllocationNodes
(
firstNodeToDiscard
)
;
lastNodeToKeep
.
next
=
new
AllocationNode
(
lastNodeToKeep
.
endPosition
allocationLength
)
;
writeAllocationNode
=
this
.
totalBytesWritten
=
=
lastNodeToKeep
.
endPosition
?
lastNodeToKeep
.
next
:
lastNodeToKeep
;
if
(
readAllocationNode
=
=
firstNodeToDiscard
)
{
readAllocationNode
=
lastNodeToKeep
.
next
;
}
}
}
public
void
rewind
(
)
{
readAllocationNode
=
firstAllocationNode
;
}
public
void
readToBuffer
(
DecoderInputBuffer
buffer
SampleExtrasHolder
extrasHolder
)
{
if
(
buffer
.
isEncrypted
(
)
)
{
readEncryptionData
(
buffer
extrasHolder
)
;
}
if
(
buffer
.
hasSupplementalData
(
)
)
{
scratch
.
reset
(
4
)
;
readData
(
extrasHolder
.
offset
scratch
.
data
4
)
;
int
sampleSize
=
scratch
.
readUnsignedIntToInt
(
)
;
extrasHolder
.
offset
+
=
4
;
extrasHolder
.
size
-
=
4
;
buffer
.
ensureSpaceForWrite
(
sampleSize
)
;
readData
(
extrasHolder
.
offset
buffer
.
data
sampleSize
)
;
extrasHolder
.
offset
+
=
sampleSize
;
extrasHolder
.
size
-
=
sampleSize
;
buffer
.
resetSupplementalData
(
extrasHolder
.
size
)
;
readData
(
extrasHolder
.
offset
buffer
.
supplementalData
extrasHolder
.
size
)
;
}
else
{
buffer
.
ensureSpaceForWrite
(
extrasHolder
.
size
)
;
readData
(
extrasHolder
.
offset
buffer
.
data
extrasHolder
.
size
)
;
}
}
public
void
discardDownstreamTo
(
long
absolutePosition
)
{
if
(
absolutePosition
=
=
C
.
POSITION_UNSET
)
{
return
;
}
while
(
absolutePosition
>
=
firstAllocationNode
.
endPosition
)
{
allocator
.
release
(
firstAllocationNode
.
allocation
)
;
firstAllocationNode
=
firstAllocationNode
.
clear
(
)
;
}
if
(
readAllocationNode
.
startPosition
<
firstAllocationNode
.
startPosition
)
{
readAllocationNode
=
firstAllocationNode
;
}
}
public
long
getTotalBytesWritten
(
)
{
return
totalBytesWritten
;
}
public
int
sampleData
(
ExtractorInput
input
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
length
=
preAppend
(
length
)
;
int
bytesAppended
=
input
.
read
(
writeAllocationNode
.
allocation
.
data
writeAllocationNode
.
translateOffset
(
totalBytesWritten
)
length
)
;
if
(
bytesAppended
=
=
C
.
RESULT_END_OF_INPUT
)
{
if
(
allowEndOfInput
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
throw
new
EOFException
(
)
;
}
postAppend
(
bytesAppended
)
;
return
bytesAppended
;
}
public
void
sampleData
(
ParsableByteArray
buffer
int
length
)
{
while
(
length
>
0
)
{
int
bytesAppended
=
preAppend
(
length
)
;
buffer
.
readBytes
(
writeAllocationNode
.
allocation
.
data
writeAllocationNode
.
translateOffset
(
totalBytesWritten
)
bytesAppended
)
;
length
-
=
bytesAppended
;
postAppend
(
bytesAppended
)
;
}
}
private
void
readEncryptionData
(
DecoderInputBuffer
buffer
SampleExtrasHolder
extrasHolder
)
{
long
offset
=
extrasHolder
.
offset
;
scratch
.
reset
(
1
)
;
readData
(
offset
scratch
.
data
1
)
;
offset
+
+
;
byte
signalByte
=
scratch
.
data
[
0
]
;
boolean
subsampleEncryption
=
(
signalByte
&
0x80
)
!
=
0
;
int
ivSize
=
signalByte
&
0x7F
;
CryptoInfo
cryptoInfo
=
buffer
.
cryptoInfo
;
if
(
cryptoInfo
.
iv
=
=
null
)
{
cryptoInfo
.
iv
=
new
byte
[
16
]
;
}
else
{
Arrays
.
fill
(
cryptoInfo
.
iv
(
byte
)
0
)
;
}
readData
(
offset
cryptoInfo
.
iv
ivSize
)
;
offset
+
=
ivSize
;
int
subsampleCount
;
if
(
subsampleEncryption
)
{
scratch
.
reset
(
2
)
;
readData
(
offset
scratch
.
data
2
)
;
offset
+
=
2
;
subsampleCount
=
scratch
.
readUnsignedShort
(
)
;
}
else
{
subsampleCount
=
1
;
}
Nullable
int
[
]
clearDataSizes
=
cryptoInfo
.
numBytesOfClearData
;
if
(
clearDataSizes
=
=
null
|
|
clearDataSizes
.
length
<
subsampleCount
)
{
clearDataSizes
=
new
int
[
subsampleCount
]
;
}
Nullable
int
[
]
encryptedDataSizes
=
cryptoInfo
.
numBytesOfEncryptedData
;
if
(
encryptedDataSizes
=
=
null
|
|
encryptedDataSizes
.
length
<
subsampleCount
)
{
encryptedDataSizes
=
new
int
[
subsampleCount
]
;
}
if
(
subsampleEncryption
)
{
int
subsampleDataLength
=
6
*
subsampleCount
;
scratch
.
reset
(
subsampleDataLength
)
;
readData
(
offset
scratch
.
data
subsampleDataLength
)
;
offset
+
=
subsampleDataLength
;
scratch
.
setPosition
(
0
)
;
for
(
int
i
=
0
;
i
<
subsampleCount
;
i
+
+
)
{
clearDataSizes
[
i
]
=
scratch
.
readUnsignedShort
(
)
;
encryptedDataSizes
[
i
]
=
scratch
.
readUnsignedIntToInt
(
)
;
}
}
else
{
clearDataSizes
[
0
]
=
0
;
encryptedDataSizes
[
0
]
=
extrasHolder
.
size
-
(
int
)
(
offset
-
extrasHolder
.
offset
)
;
}
CryptoData
cryptoData
=
extrasHolder
.
cryptoData
;
cryptoInfo
.
set
(
subsampleCount
clearDataSizes
encryptedDataSizes
cryptoData
.
encryptionKey
cryptoInfo
.
iv
cryptoData
.
cryptoMode
cryptoData
.
encryptedBlocks
cryptoData
.
clearBlocks
)
;
int
bytesRead
=
(
int
)
(
offset
-
extrasHolder
.
offset
)
;
extrasHolder
.
offset
+
=
bytesRead
;
extrasHolder
.
size
-
=
bytesRead
;
}
private
void
readData
(
long
absolutePosition
ByteBuffer
target
int
length
)
{
advanceReadTo
(
absolutePosition
)
;
int
remaining
=
length
;
while
(
remaining
>
0
)
{
int
toCopy
=
Math
.
min
(
remaining
(
int
)
(
readAllocationNode
.
endPosition
-
absolutePosition
)
)
;
Allocation
allocation
=
readAllocationNode
.
allocation
;
target
.
put
(
allocation
.
data
readAllocationNode
.
translateOffset
(
absolutePosition
)
toCopy
)
;
remaining
-
=
toCopy
;
absolutePosition
+
=
toCopy
;
if
(
absolutePosition
=
=
readAllocationNode
.
endPosition
)
{
readAllocationNode
=
readAllocationNode
.
next
;
}
}
}
private
void
readData
(
long
absolutePosition
byte
[
]
target
int
length
)
{
advanceReadTo
(
absolutePosition
)
;
int
remaining
=
length
;
while
(
remaining
>
0
)
{
int
toCopy
=
Math
.
min
(
remaining
(
int
)
(
readAllocationNode
.
endPosition
-
absolutePosition
)
)
;
Allocation
allocation
=
readAllocationNode
.
allocation
;
System
.
arraycopy
(
allocation
.
data
readAllocationNode
.
translateOffset
(
absolutePosition
)
target
length
-
remaining
toCopy
)
;
remaining
-
=
toCopy
;
absolutePosition
+
=
toCopy
;
if
(
absolutePosition
=
=
readAllocationNode
.
endPosition
)
{
readAllocationNode
=
readAllocationNode
.
next
;
}
}
}
private
void
advanceReadTo
(
long
absolutePosition
)
{
while
(
absolutePosition
>
=
readAllocationNode
.
endPosition
)
{
readAllocationNode
=
readAllocationNode
.
next
;
}
}
private
void
clearAllocationNodes
(
AllocationNode
fromNode
)
{
if
(
!
fromNode
.
wasInitialized
)
{
return
;
}
int
allocationCount
=
(
writeAllocationNode
.
wasInitialized
?
1
:
0
)
+
(
(
int
)
(
writeAllocationNode
.
startPosition
-
fromNode
.
startPosition
)
/
allocationLength
)
;
Allocation
[
]
allocationsToRelease
=
new
Allocation
[
allocationCount
]
;
AllocationNode
currentNode
=
fromNode
;
for
(
int
i
=
0
;
i
<
allocationsToRelease
.
length
;
i
+
+
)
{
allocationsToRelease
[
i
]
=
currentNode
.
allocation
;
currentNode
=
currentNode
.
clear
(
)
;
}
allocator
.
release
(
allocationsToRelease
)
;
}
private
int
preAppend
(
int
length
)
{
if
(
!
writeAllocationNode
.
wasInitialized
)
{
writeAllocationNode
.
initialize
(
allocator
.
allocate
(
)
new
AllocationNode
(
writeAllocationNode
.
endPosition
allocationLength
)
)
;
}
return
Math
.
min
(
length
(
int
)
(
writeAllocationNode
.
endPosition
-
totalBytesWritten
)
)
;
}
private
void
postAppend
(
int
length
)
{
totalBytesWritten
+
=
length
;
if
(
totalBytesWritten
=
=
writeAllocationNode
.
endPosition
)
{
writeAllocationNode
=
writeAllocationNode
.
next
;
}
}
private
static
final
class
AllocationNode
{
public
final
long
startPosition
;
public
final
long
endPosition
;
public
boolean
wasInitialized
;
Nullable
public
Allocation
allocation
;
Nullable
public
AllocationNode
next
;
public
AllocationNode
(
long
startPosition
int
allocationLength
)
{
this
.
startPosition
=
startPosition
;
this
.
endPosition
=
startPosition
+
allocationLength
;
}
public
void
initialize
(
Allocation
allocation
AllocationNode
next
)
{
this
.
allocation
=
allocation
;
this
.
next
=
next
;
wasInitialized
=
true
;
}
public
int
translateOffset
(
long
absolutePosition
)
{
return
(
int
)
(
absolutePosition
-
startPosition
)
+
allocation
.
offset
;
}
public
AllocationNode
clear
(
)
{
allocation
=
null
;
AllocationNode
temp
=
next
;
next
=
null
;
return
temp
;
}
}
}
