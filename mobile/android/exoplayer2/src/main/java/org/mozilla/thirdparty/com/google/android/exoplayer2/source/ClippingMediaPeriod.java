package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
SeekParameters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
org
.
checkerframework
.
checker
.
nullness
.
compatqual
.
NullableType
;
public
final
class
ClippingMediaPeriod
implements
MediaPeriod
MediaPeriod
.
Callback
{
public
final
MediaPeriod
mediaPeriod
;
Nullable
private
MediaPeriod
.
Callback
callback
;
private
NullableType
ClippingSampleStream
[
]
sampleStreams
;
private
long
pendingInitialDiscontinuityPositionUs
;
long
startUs
;
long
endUs
;
public
ClippingMediaPeriod
(
MediaPeriod
mediaPeriod
boolean
enableInitialDiscontinuity
long
startUs
long
endUs
)
{
this
.
mediaPeriod
=
mediaPeriod
;
sampleStreams
=
new
ClippingSampleStream
[
0
]
;
pendingInitialDiscontinuityPositionUs
=
enableInitialDiscontinuity
?
startUs
:
C
.
TIME_UNSET
;
this
.
startUs
=
startUs
;
this
.
endUs
=
endUs
;
}
public
void
updateClipping
(
long
startUs
long
endUs
)
{
this
.
startUs
=
startUs
;
this
.
endUs
=
endUs
;
}
Override
public
void
prepare
(
MediaPeriod
.
Callback
callback
long
positionUs
)
{
this
.
callback
=
callback
;
mediaPeriod
.
prepare
(
this
positionUs
)
;
}
Override
public
void
maybeThrowPrepareError
(
)
throws
IOException
{
mediaPeriod
.
maybeThrowPrepareError
(
)
;
}
Override
public
TrackGroupArray
getTrackGroups
(
)
{
return
mediaPeriod
.
getTrackGroups
(
)
;
}
Override
public
long
selectTracks
(
NullableType
TrackSelection
[
]
selections
boolean
[
]
mayRetainStreamFlags
NullableType
SampleStream
[
]
streams
boolean
[
]
streamResetFlags
long
positionUs
)
{
sampleStreams
=
new
ClippingSampleStream
[
streams
.
length
]
;
NullableType
SampleStream
[
]
childStreams
=
new
SampleStream
[
streams
.
length
]
;
for
(
int
i
=
0
;
i
<
streams
.
length
;
i
+
+
)
{
sampleStreams
[
i
]
=
(
ClippingSampleStream
)
streams
[
i
]
;
childStreams
[
i
]
=
sampleStreams
[
i
]
!
=
null
?
sampleStreams
[
i
]
.
childStream
:
null
;
}
long
enablePositionUs
=
mediaPeriod
.
selectTracks
(
selections
mayRetainStreamFlags
childStreams
streamResetFlags
positionUs
)
;
pendingInitialDiscontinuityPositionUs
=
isPendingInitialDiscontinuity
(
)
&
&
positionUs
=
=
startUs
&
&
shouldKeepInitialDiscontinuity
(
startUs
selections
)
?
enablePositionUs
:
C
.
TIME_UNSET
;
Assertions
.
checkState
(
enablePositionUs
=
=
positionUs
|
|
(
enablePositionUs
>
=
startUs
&
&
(
endUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
enablePositionUs
<
=
endUs
)
)
)
;
for
(
int
i
=
0
;
i
<
streams
.
length
;
i
+
+
)
{
if
(
childStreams
[
i
]
=
=
null
)
{
sampleStreams
[
i
]
=
null
;
}
else
if
(
sampleStreams
[
i
]
=
=
null
|
|
sampleStreams
[
i
]
.
childStream
!
=
childStreams
[
i
]
)
{
sampleStreams
[
i
]
=
new
ClippingSampleStream
(
childStreams
[
i
]
)
;
}
streams
[
i
]
=
sampleStreams
[
i
]
;
}
return
enablePositionUs
;
}
Override
public
void
discardBuffer
(
long
positionUs
boolean
toKeyframe
)
{
mediaPeriod
.
discardBuffer
(
positionUs
toKeyframe
)
;
}
Override
public
void
reevaluateBuffer
(
long
positionUs
)
{
mediaPeriod
.
reevaluateBuffer
(
positionUs
)
;
}
Override
public
long
readDiscontinuity
(
)
{
if
(
isPendingInitialDiscontinuity
(
)
)
{
long
initialDiscontinuityUs
=
pendingInitialDiscontinuityPositionUs
;
pendingInitialDiscontinuityPositionUs
=
C
.
TIME_UNSET
;
long
childDiscontinuityUs
=
readDiscontinuity
(
)
;
return
childDiscontinuityUs
!
=
C
.
TIME_UNSET
?
childDiscontinuityUs
:
initialDiscontinuityUs
;
}
long
discontinuityUs
=
mediaPeriod
.
readDiscontinuity
(
)
;
if
(
discontinuityUs
=
=
C
.
TIME_UNSET
)
{
return
C
.
TIME_UNSET
;
}
Assertions
.
checkState
(
discontinuityUs
>
=
startUs
)
;
Assertions
.
checkState
(
endUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
discontinuityUs
<
=
endUs
)
;
return
discontinuityUs
;
}
Override
public
long
getBufferedPositionUs
(
)
{
long
bufferedPositionUs
=
mediaPeriod
.
getBufferedPositionUs
(
)
;
if
(
bufferedPositionUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
(
endUs
!
=
C
.
TIME_END_OF_SOURCE
&
&
bufferedPositionUs
>
=
endUs
)
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
return
bufferedPositionUs
;
}
Override
public
long
seekToUs
(
long
positionUs
)
{
pendingInitialDiscontinuityPositionUs
=
C
.
TIME_UNSET
;
for
(
ClippingSampleStream
sampleStream
:
sampleStreams
)
{
if
(
sampleStream
!
=
null
)
{
sampleStream
.
clearSentEos
(
)
;
}
}
long
seekUs
=
mediaPeriod
.
seekToUs
(
positionUs
)
;
Assertions
.
checkState
(
seekUs
=
=
positionUs
|
|
(
seekUs
>
=
startUs
&
&
(
endUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
seekUs
<
=
endUs
)
)
)
;
return
seekUs
;
}
Override
public
long
getAdjustedSeekPositionUs
(
long
positionUs
SeekParameters
seekParameters
)
{
if
(
positionUs
=
=
startUs
)
{
return
startUs
;
}
SeekParameters
clippedSeekParameters
=
clipSeekParameters
(
positionUs
seekParameters
)
;
return
mediaPeriod
.
getAdjustedSeekPositionUs
(
positionUs
clippedSeekParameters
)
;
}
Override
public
long
getNextLoadPositionUs
(
)
{
long
nextLoadPositionUs
=
mediaPeriod
.
getNextLoadPositionUs
(
)
;
if
(
nextLoadPositionUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
(
endUs
!
=
C
.
TIME_END_OF_SOURCE
&
&
nextLoadPositionUs
>
=
endUs
)
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
return
nextLoadPositionUs
;
}
Override
public
boolean
continueLoading
(
long
positionUs
)
{
return
mediaPeriod
.
continueLoading
(
positionUs
)
;
}
Override
public
boolean
isLoading
(
)
{
return
mediaPeriod
.
isLoading
(
)
;
}
Override
public
void
onPrepared
(
MediaPeriod
mediaPeriod
)
{
Assertions
.
checkNotNull
(
callback
)
.
onPrepared
(
this
)
;
}
Override
public
void
onContinueLoadingRequested
(
MediaPeriod
source
)
{
Assertions
.
checkNotNull
(
callback
)
.
onContinueLoadingRequested
(
this
)
;
}
boolean
isPendingInitialDiscontinuity
(
)
{
return
pendingInitialDiscontinuityPositionUs
!
=
C
.
TIME_UNSET
;
}
private
SeekParameters
clipSeekParameters
(
long
positionUs
SeekParameters
seekParameters
)
{
long
toleranceBeforeUs
=
Util
.
constrainValue
(
seekParameters
.
toleranceBeforeUs
0
positionUs
-
startUs
)
;
long
toleranceAfterUs
=
Util
.
constrainValue
(
seekParameters
.
toleranceAfterUs
0
endUs
=
=
C
.
TIME_END_OF_SOURCE
?
Long
.
MAX_VALUE
:
endUs
-
positionUs
)
;
if
(
toleranceBeforeUs
=
=
seekParameters
.
toleranceBeforeUs
&
&
toleranceAfterUs
=
=
seekParameters
.
toleranceAfterUs
)
{
return
seekParameters
;
}
else
{
return
new
SeekParameters
(
toleranceBeforeUs
toleranceAfterUs
)
;
}
}
private
static
boolean
shouldKeepInitialDiscontinuity
(
long
startUs
NullableType
TrackSelection
[
]
selections
)
{
if
(
startUs
!
=
0
)
{
for
(
TrackSelection
trackSelection
:
selections
)
{
if
(
trackSelection
!
=
null
)
{
Format
selectedFormat
=
trackSelection
.
getSelectedFormat
(
)
;
if
(
!
MimeTypes
.
isAudio
(
selectedFormat
.
sampleMimeType
)
)
{
return
true
;
}
}
}
}
return
false
;
}
private
final
class
ClippingSampleStream
implements
SampleStream
{
public
final
SampleStream
childStream
;
private
boolean
sentEos
;
public
ClippingSampleStream
(
SampleStream
childStream
)
{
this
.
childStream
=
childStream
;
}
public
void
clearSentEos
(
)
{
sentEos
=
false
;
}
Override
public
boolean
isReady
(
)
{
return
!
isPendingInitialDiscontinuity
(
)
&
&
childStream
.
isReady
(
)
;
}
Override
public
void
maybeThrowError
(
)
throws
IOException
{
childStream
.
maybeThrowError
(
)
;
}
Override
public
int
readData
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
requireFormat
)
{
if
(
isPendingInitialDiscontinuity
(
)
)
{
return
C
.
RESULT_NOTHING_READ
;
}
if
(
sentEos
)
{
buffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
return
C
.
RESULT_BUFFER_READ
;
}
int
result
=
childStream
.
readData
(
formatHolder
buffer
requireFormat
)
;
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
Format
format
=
Assertions
.
checkNotNull
(
formatHolder
.
format
)
;
if
(
format
.
encoderDelay
!
=
0
|
|
format
.
encoderPadding
!
=
0
)
{
int
encoderDelay
=
startUs
!
=
0
?
0
:
format
.
encoderDelay
;
int
encoderPadding
=
endUs
!
=
C
.
TIME_END_OF_SOURCE
?
0
:
format
.
encoderPadding
;
formatHolder
.
format
=
format
.
copyWithGaplessInfo
(
encoderDelay
encoderPadding
)
;
}
return
C
.
RESULT_FORMAT_READ
;
}
if
(
endUs
!
=
C
.
TIME_END_OF_SOURCE
&
&
(
(
result
=
=
C
.
RESULT_BUFFER_READ
&
&
buffer
.
timeUs
>
=
endUs
)
|
|
(
result
=
=
C
.
RESULT_NOTHING_READ
&
&
getBufferedPositionUs
(
)
=
=
C
.
TIME_END_OF_SOURCE
&
&
!
buffer
.
waitingForKeys
)
)
)
{
buffer
.
clear
(
)
;
buffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
sentEos
=
true
;
return
C
.
RESULT_BUFFER_READ
;
}
return
result
;
}
Override
public
int
skipData
(
long
positionUs
)
{
if
(
isPendingInitialDiscontinuity
(
)
)
{
return
C
.
RESULT_NOTHING_READ
;
}
return
childStream
.
skipData
(
positionUs
)
;
}
}
}
