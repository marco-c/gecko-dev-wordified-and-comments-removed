package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
java
.
io
.
File
;
import
java
.
util
.
TreeSet
;
final
class
CachedContent
{
private
static
final
String
TAG
=
"
CachedContent
"
;
public
final
int
id
;
public
final
String
key
;
private
final
TreeSet
<
SimpleCacheSpan
>
cachedSpans
;
private
DefaultContentMetadata
metadata
;
private
boolean
locked
;
public
CachedContent
(
int
id
String
key
)
{
this
(
id
key
DefaultContentMetadata
.
EMPTY
)
;
}
public
CachedContent
(
int
id
String
key
DefaultContentMetadata
metadata
)
{
this
.
id
=
id
;
this
.
key
=
key
;
this
.
metadata
=
metadata
;
this
.
cachedSpans
=
new
TreeSet
<
>
(
)
;
}
public
DefaultContentMetadata
getMetadata
(
)
{
return
metadata
;
}
public
boolean
applyMetadataMutations
(
ContentMetadataMutations
mutations
)
{
DefaultContentMetadata
oldMetadata
=
metadata
;
metadata
=
metadata
.
copyWithMutationsApplied
(
mutations
)
;
return
!
metadata
.
equals
(
oldMetadata
)
;
}
public
boolean
isLocked
(
)
{
return
locked
;
}
public
void
setLocked
(
boolean
locked
)
{
this
.
locked
=
locked
;
}
public
void
addSpan
(
SimpleCacheSpan
span
)
{
cachedSpans
.
add
(
span
)
;
}
public
TreeSet
<
SimpleCacheSpan
>
getSpans
(
)
{
return
cachedSpans
;
}
public
SimpleCacheSpan
getSpan
(
long
position
)
{
SimpleCacheSpan
lookupSpan
=
SimpleCacheSpan
.
createLookup
(
key
position
)
;
SimpleCacheSpan
floorSpan
=
cachedSpans
.
floor
(
lookupSpan
)
;
if
(
floorSpan
!
=
null
&
&
floorSpan
.
position
+
floorSpan
.
length
>
position
)
{
return
floorSpan
;
}
SimpleCacheSpan
ceilSpan
=
cachedSpans
.
ceiling
(
lookupSpan
)
;
return
ceilSpan
=
=
null
?
SimpleCacheSpan
.
createOpenHole
(
key
position
)
:
SimpleCacheSpan
.
createClosedHole
(
key
position
ceilSpan
.
position
-
position
)
;
}
public
long
getCachedBytesLength
(
long
position
long
length
)
{
SimpleCacheSpan
span
=
getSpan
(
position
)
;
if
(
span
.
isHoleSpan
(
)
)
{
return
-
Math
.
min
(
span
.
isOpenEnded
(
)
?
Long
.
MAX_VALUE
:
span
.
length
length
)
;
}
long
queryEndPosition
=
position
+
length
;
long
currentEndPosition
=
span
.
position
+
span
.
length
;
if
(
currentEndPosition
<
queryEndPosition
)
{
for
(
SimpleCacheSpan
next
:
cachedSpans
.
tailSet
(
span
false
)
)
{
if
(
next
.
position
>
currentEndPosition
)
{
break
;
}
currentEndPosition
=
Math
.
max
(
currentEndPosition
next
.
position
+
next
.
length
)
;
if
(
currentEndPosition
>
=
queryEndPosition
)
{
break
;
}
}
}
return
Math
.
min
(
currentEndPosition
-
position
length
)
;
}
public
SimpleCacheSpan
setLastTouchTimestamp
(
SimpleCacheSpan
cacheSpan
long
lastTouchTimestamp
boolean
updateFile
)
{
Assertions
.
checkState
(
cachedSpans
.
remove
(
cacheSpan
)
)
;
File
file
=
cacheSpan
.
file
;
if
(
updateFile
)
{
File
directory
=
file
.
getParentFile
(
)
;
long
position
=
cacheSpan
.
position
;
File
newFile
=
SimpleCacheSpan
.
getCacheFile
(
directory
id
position
lastTouchTimestamp
)
;
if
(
file
.
renameTo
(
newFile
)
)
{
file
=
newFile
;
}
else
{
Log
.
w
(
TAG
"
Failed
to
rename
"
+
file
+
"
to
"
+
newFile
)
;
}
}
SimpleCacheSpan
newCacheSpan
=
cacheSpan
.
copyWithFileAndLastTouchTimestamp
(
file
lastTouchTimestamp
)
;
cachedSpans
.
add
(
newCacheSpan
)
;
return
newCacheSpan
;
}
public
boolean
isEmpty
(
)
{
return
cachedSpans
.
isEmpty
(
)
;
}
public
boolean
removeSpan
(
CacheSpan
span
)
{
if
(
cachedSpans
.
remove
(
span
)
)
{
span
.
file
.
delete
(
)
;
return
true
;
}
return
false
;
}
Override
public
int
hashCode
(
)
{
int
result
=
id
;
result
=
31
*
result
+
key
.
hashCode
(
)
;
result
=
31
*
result
+
metadata
.
hashCode
(
)
;
return
result
;
}
Override
public
boolean
equals
(
Nullable
Object
o
)
{
if
(
this
=
=
o
)
{
return
true
;
}
if
(
o
=
=
null
|
|
getClass
(
)
!
=
o
.
getClass
(
)
)
{
return
false
;
}
CachedContent
that
=
(
CachedContent
)
o
;
return
id
=
=
that
.
id
&
&
key
.
equals
(
that
.
key
)
&
&
cachedSpans
.
equals
(
that
.
cachedSpans
)
&
&
metadata
.
equals
(
that
.
metadata
)
;
}
}
