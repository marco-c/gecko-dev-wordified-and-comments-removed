package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
android
.
os
.
Looper
;
import
androidx
.
annotation
.
CallSuper
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmInitData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
public
class
SampleQueue
implements
TrackOutput
{
public
interface
UpstreamFormatChangedListener
{
void
onUpstreamFormatChanged
(
Format
format
)
;
}
VisibleForTesting
static
final
int
SAMPLE_CAPACITY_INCREMENT
=
1000
;
private
final
SampleDataQueue
sampleDataQueue
;
private
final
SampleExtrasHolder
extrasHolder
;
private
final
DrmSessionManager
<
?
>
drmSessionManager
;
private
UpstreamFormatChangedListener
upstreamFormatChangeListener
;
Nullable
private
Format
downstreamFormat
;
Nullable
private
DrmSession
<
?
>
currentDrmSession
;
private
int
capacity
;
private
int
[
]
sourceIds
;
private
long
[
]
offsets
;
private
int
[
]
sizes
;
private
int
[
]
flags
;
private
long
[
]
timesUs
;
private
CryptoData
[
]
cryptoDatas
;
private
Format
[
]
formats
;
private
int
length
;
private
int
absoluteFirstIndex
;
private
int
relativeFirstIndex
;
private
int
readPosition
;
private
long
largestDiscardedTimestampUs
;
private
long
largestQueuedTimestampUs
;
private
boolean
isLastSampleQueued
;
private
boolean
upstreamKeyframeRequired
;
private
boolean
upstreamFormatRequired
;
private
Format
upstreamFormat
;
private
Format
upstreamCommittedFormat
;
private
int
upstreamSourceId
;
private
boolean
pendingUpstreamFormatAdjustment
;
private
Format
unadjustedUpstreamFormat
;
private
long
sampleOffsetUs
;
private
boolean
pendingSplice
;
public
SampleQueue
(
Allocator
allocator
DrmSessionManager
<
?
>
drmSessionManager
)
{
sampleDataQueue
=
new
SampleDataQueue
(
allocator
)
;
this
.
drmSessionManager
=
drmSessionManager
;
extrasHolder
=
new
SampleExtrasHolder
(
)
;
capacity
=
SAMPLE_CAPACITY_INCREMENT
;
sourceIds
=
new
int
[
capacity
]
;
offsets
=
new
long
[
capacity
]
;
timesUs
=
new
long
[
capacity
]
;
flags
=
new
int
[
capacity
]
;
sizes
=
new
int
[
capacity
]
;
cryptoDatas
=
new
CryptoData
[
capacity
]
;
formats
=
new
Format
[
capacity
]
;
largestDiscardedTimestampUs
=
Long
.
MIN_VALUE
;
largestQueuedTimestampUs
=
Long
.
MIN_VALUE
;
upstreamFormatRequired
=
true
;
upstreamKeyframeRequired
=
true
;
}
CallSuper
public
void
release
(
)
{
reset
(
true
)
;
releaseDrmSessionReferences
(
)
;
}
public
final
void
reset
(
)
{
reset
(
false
)
;
}
CallSuper
public
void
reset
(
boolean
resetUpstreamFormat
)
{
sampleDataQueue
.
reset
(
)
;
length
=
0
;
absoluteFirstIndex
=
0
;
relativeFirstIndex
=
0
;
readPosition
=
0
;
upstreamKeyframeRequired
=
true
;
largestDiscardedTimestampUs
=
Long
.
MIN_VALUE
;
largestQueuedTimestampUs
=
Long
.
MIN_VALUE
;
isLastSampleQueued
=
false
;
upstreamCommittedFormat
=
null
;
if
(
resetUpstreamFormat
)
{
unadjustedUpstreamFormat
=
null
;
upstreamFormat
=
null
;
upstreamFormatRequired
=
true
;
}
}
public
final
void
sourceId
(
int
sourceId
)
{
upstreamSourceId
=
sourceId
;
}
public
final
void
splice
(
)
{
pendingSplice
=
true
;
}
public
final
int
getWriteIndex
(
)
{
return
absoluteFirstIndex
+
length
;
}
public
final
void
discardUpstreamSamples
(
int
discardFromIndex
)
{
sampleDataQueue
.
discardUpstreamSampleBytes
(
discardUpstreamSampleMetadata
(
discardFromIndex
)
)
;
}
CallSuper
public
void
preRelease
(
)
{
discardToEnd
(
)
;
releaseDrmSessionReferences
(
)
;
}
CallSuper
public
void
maybeThrowError
(
)
throws
IOException
{
if
(
currentDrmSession
!
=
null
&
&
currentDrmSession
.
getState
(
)
=
=
DrmSession
.
STATE_ERROR
)
{
throw
Assertions
.
checkNotNull
(
currentDrmSession
.
getError
(
)
)
;
}
}
public
final
int
getFirstIndex
(
)
{
return
absoluteFirstIndex
;
}
public
final
int
getReadIndex
(
)
{
return
absoluteFirstIndex
+
readPosition
;
}
public
final
synchronized
int
peekSourceId
(
)
{
int
relativeReadIndex
=
getRelativeIndex
(
readPosition
)
;
return
hasNextSample
(
)
?
sourceIds
[
relativeReadIndex
]
:
upstreamSourceId
;
}
public
final
synchronized
Format
getUpstreamFormat
(
)
{
return
upstreamFormatRequired
?
null
:
upstreamFormat
;
}
public
final
synchronized
long
getLargestQueuedTimestampUs
(
)
{
return
largestQueuedTimestampUs
;
}
public
final
synchronized
boolean
isLastSampleQueued
(
)
{
return
isLastSampleQueued
;
}
public
final
synchronized
long
getFirstTimestampUs
(
)
{
return
length
=
=
0
?
Long
.
MIN_VALUE
:
timesUs
[
relativeFirstIndex
]
;
}
SuppressWarnings
(
"
ReferenceEquality
"
)
CallSuper
public
synchronized
boolean
isReady
(
boolean
loadingFinished
)
{
if
(
!
hasNextSample
(
)
)
{
return
loadingFinished
|
|
isLastSampleQueued
|
|
(
upstreamFormat
!
=
null
&
&
upstreamFormat
!
=
downstreamFormat
)
;
}
int
relativeReadIndex
=
getRelativeIndex
(
readPosition
)
;
if
(
formats
[
relativeReadIndex
]
!
=
downstreamFormat
)
{
return
true
;
}
return
mayReadSample
(
relativeReadIndex
)
;
}
CallSuper
public
int
read
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
boolean
loadingFinished
long
decodeOnlyUntilUs
)
{
int
result
=
readSampleMetadata
(
formatHolder
buffer
formatRequired
loadingFinished
decodeOnlyUntilUs
extrasHolder
)
;
if
(
result
=
=
C
.
RESULT_BUFFER_READ
&
&
!
buffer
.
isEndOfStream
(
)
&
&
!
buffer
.
isFlagsOnly
(
)
)
{
sampleDataQueue
.
readToBuffer
(
buffer
extrasHolder
)
;
}
return
result
;
}
public
final
synchronized
boolean
seekTo
(
int
sampleIndex
)
{
rewind
(
)
;
if
(
sampleIndex
<
absoluteFirstIndex
|
|
sampleIndex
>
absoluteFirstIndex
+
length
)
{
return
false
;
}
readPosition
=
sampleIndex
-
absoluteFirstIndex
;
return
true
;
}
public
final
synchronized
boolean
seekTo
(
long
timeUs
boolean
allowTimeBeyondBuffer
)
{
rewind
(
)
;
int
relativeReadIndex
=
getRelativeIndex
(
readPosition
)
;
if
(
!
hasNextSample
(
)
|
|
timeUs
<
timesUs
[
relativeReadIndex
]
|
|
(
timeUs
>
largestQueuedTimestampUs
&
&
!
allowTimeBeyondBuffer
)
)
{
return
false
;
}
int
offset
=
findSampleBefore
(
relativeReadIndex
length
-
readPosition
timeUs
true
)
;
if
(
offset
=
=
-
1
)
{
return
false
;
}
readPosition
+
=
offset
;
return
true
;
}
public
final
synchronized
int
advanceTo
(
long
timeUs
)
{
int
relativeReadIndex
=
getRelativeIndex
(
readPosition
)
;
if
(
!
hasNextSample
(
)
|
|
timeUs
<
timesUs
[
relativeReadIndex
]
)
{
return
0
;
}
int
offset
=
findSampleBefore
(
relativeReadIndex
length
-
readPosition
timeUs
true
)
;
if
(
offset
=
=
-
1
)
{
return
0
;
}
readPosition
+
=
offset
;
return
offset
;
}
public
final
synchronized
int
advanceToEnd
(
)
{
int
skipCount
=
length
-
readPosition
;
readPosition
=
length
;
return
skipCount
;
}
public
final
void
discardTo
(
long
timeUs
boolean
toKeyframe
boolean
stopAtReadPosition
)
{
sampleDataQueue
.
discardDownstreamTo
(
discardSampleMetadataTo
(
timeUs
toKeyframe
stopAtReadPosition
)
)
;
}
public
final
void
discardToRead
(
)
{
sampleDataQueue
.
discardDownstreamTo
(
discardSampleMetadataToRead
(
)
)
;
}
public
final
void
discardToEnd
(
)
{
sampleDataQueue
.
discardDownstreamTo
(
discardSampleMetadataToEnd
(
)
)
;
}
public
final
void
setSampleOffsetUs
(
long
sampleOffsetUs
)
{
if
(
this
.
sampleOffsetUs
!
=
sampleOffsetUs
)
{
this
.
sampleOffsetUs
=
sampleOffsetUs
;
invalidateUpstreamFormatAdjustment
(
)
;
}
}
public
final
void
setUpstreamFormatChangeListener
(
UpstreamFormatChangedListener
listener
)
{
upstreamFormatChangeListener
=
listener
;
}
Override
public
final
void
format
(
Format
unadjustedUpstreamFormat
)
{
Format
adjustedUpstreamFormat
=
getAdjustedUpstreamFormat
(
unadjustedUpstreamFormat
)
;
pendingUpstreamFormatAdjustment
=
false
;
this
.
unadjustedUpstreamFormat
=
unadjustedUpstreamFormat
;
boolean
upstreamFormatChanged
=
setUpstreamFormat
(
adjustedUpstreamFormat
)
;
if
(
upstreamFormatChangeListener
!
=
null
&
&
upstreamFormatChanged
)
{
upstreamFormatChangeListener
.
onUpstreamFormatChanged
(
adjustedUpstreamFormat
)
;
}
}
Override
public
final
int
sampleData
(
ExtractorInput
input
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
return
sampleDataQueue
.
sampleData
(
input
length
allowEndOfInput
)
;
}
Override
public
final
void
sampleData
(
ParsableByteArray
buffer
int
length
)
{
sampleDataQueue
.
sampleData
(
buffer
length
)
;
}
Override
public
final
void
sampleMetadata
(
long
timeUs
C
.
BufferFlags
int
flags
int
size
int
offset
Nullable
CryptoData
cryptoData
)
{
if
(
pendingUpstreamFormatAdjustment
)
{
format
(
unadjustedUpstreamFormat
)
;
}
timeUs
+
=
sampleOffsetUs
;
if
(
pendingSplice
)
{
if
(
(
flags
&
C
.
BUFFER_FLAG_KEY_FRAME
)
=
=
0
|
|
!
attemptSplice
(
timeUs
)
)
{
return
;
}
pendingSplice
=
false
;
}
long
absoluteOffset
=
sampleDataQueue
.
getTotalBytesWritten
(
)
-
size
-
offset
;
commitSample
(
timeUs
flags
absoluteOffset
size
cryptoData
)
;
}
protected
final
void
invalidateUpstreamFormatAdjustment
(
)
{
pendingUpstreamFormatAdjustment
=
true
;
}
CallSuper
protected
Format
getAdjustedUpstreamFormat
(
Format
format
)
{
if
(
sampleOffsetUs
!
=
0
&
&
format
.
subsampleOffsetUs
!
=
Format
.
OFFSET_SAMPLE_RELATIVE
)
{
format
=
format
.
copyWithSubsampleOffsetUs
(
format
.
subsampleOffsetUs
+
sampleOffsetUs
)
;
}
return
format
;
}
private
synchronized
void
rewind
(
)
{
readPosition
=
0
;
sampleDataQueue
.
rewind
(
)
;
}
SuppressWarnings
(
"
ReferenceEquality
"
)
private
synchronized
int
readSampleMetadata
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
boolean
loadingFinished
long
decodeOnlyUntilUs
SampleExtrasHolder
extrasHolder
)
{
buffer
.
waitingForKeys
=
false
;
boolean
hasNextSample
;
int
relativeReadIndex
=
C
.
INDEX_UNSET
;
while
(
(
hasNextSample
=
hasNextSample
(
)
)
)
{
relativeReadIndex
=
getRelativeIndex
(
readPosition
)
;
long
timeUs
=
timesUs
[
relativeReadIndex
]
;
if
(
timeUs
<
decodeOnlyUntilUs
&
&
MimeTypes
.
allSamplesAreSyncSamples
(
formats
[
relativeReadIndex
]
.
sampleMimeType
)
)
{
readPosition
+
+
;
}
else
{
break
;
}
}
if
(
!
hasNextSample
)
{
if
(
loadingFinished
|
|
isLastSampleQueued
)
{
buffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
return
C
.
RESULT_BUFFER_READ
;
}
else
if
(
upstreamFormat
!
=
null
&
&
(
formatRequired
|
|
upstreamFormat
!
=
downstreamFormat
)
)
{
onFormatResult
(
Assertions
.
checkNotNull
(
upstreamFormat
)
formatHolder
)
;
return
C
.
RESULT_FORMAT_READ
;
}
else
{
return
C
.
RESULT_NOTHING_READ
;
}
}
if
(
formatRequired
|
|
formats
[
relativeReadIndex
]
!
=
downstreamFormat
)
{
onFormatResult
(
formats
[
relativeReadIndex
]
formatHolder
)
;
return
C
.
RESULT_FORMAT_READ
;
}
if
(
!
mayReadSample
(
relativeReadIndex
)
)
{
buffer
.
waitingForKeys
=
true
;
return
C
.
RESULT_NOTHING_READ
;
}
buffer
.
setFlags
(
flags
[
relativeReadIndex
]
)
;
buffer
.
timeUs
=
timesUs
[
relativeReadIndex
]
;
if
(
buffer
.
timeUs
<
decodeOnlyUntilUs
)
{
buffer
.
addFlag
(
C
.
BUFFER_FLAG_DECODE_ONLY
)
;
}
if
(
buffer
.
isFlagsOnly
(
)
)
{
return
C
.
RESULT_BUFFER_READ
;
}
extrasHolder
.
size
=
sizes
[
relativeReadIndex
]
;
extrasHolder
.
offset
=
offsets
[
relativeReadIndex
]
;
extrasHolder
.
cryptoData
=
cryptoDatas
[
relativeReadIndex
]
;
readPosition
+
+
;
return
C
.
RESULT_BUFFER_READ
;
}
private
synchronized
boolean
setUpstreamFormat
(
Format
format
)
{
if
(
format
=
=
null
)
{
upstreamFormatRequired
=
true
;
return
false
;
}
upstreamFormatRequired
=
false
;
if
(
Util
.
areEqual
(
format
upstreamFormat
)
)
{
return
false
;
}
else
if
(
Util
.
areEqual
(
format
upstreamCommittedFormat
)
)
{
upstreamFormat
=
upstreamCommittedFormat
;
return
true
;
}
else
{
upstreamFormat
=
format
;
return
true
;
}
}
private
synchronized
long
discardSampleMetadataTo
(
long
timeUs
boolean
toKeyframe
boolean
stopAtReadPosition
)
{
if
(
length
=
=
0
|
|
timeUs
<
timesUs
[
relativeFirstIndex
]
)
{
return
C
.
POSITION_UNSET
;
}
int
searchLength
=
stopAtReadPosition
&
&
readPosition
!
=
length
?
readPosition
+
1
:
length
;
int
discardCount
=
findSampleBefore
(
relativeFirstIndex
searchLength
timeUs
toKeyframe
)
;
if
(
discardCount
=
=
-
1
)
{
return
C
.
POSITION_UNSET
;
}
return
discardSamples
(
discardCount
)
;
}
public
synchronized
long
discardSampleMetadataToRead
(
)
{
if
(
readPosition
=
=
0
)
{
return
C
.
POSITION_UNSET
;
}
return
discardSamples
(
readPosition
)
;
}
private
synchronized
long
discardSampleMetadataToEnd
(
)
{
if
(
length
=
=
0
)
{
return
C
.
POSITION_UNSET
;
}
return
discardSamples
(
length
)
;
}
private
void
releaseDrmSessionReferences
(
)
{
if
(
currentDrmSession
!
=
null
)
{
currentDrmSession
.
release
(
)
;
currentDrmSession
=
null
;
downstreamFormat
=
null
;
}
}
private
synchronized
void
commitSample
(
long
timeUs
C
.
BufferFlags
int
sampleFlags
long
offset
int
size
CryptoData
cryptoData
)
{
if
(
upstreamKeyframeRequired
)
{
if
(
(
sampleFlags
&
C
.
BUFFER_FLAG_KEY_FRAME
)
=
=
0
)
{
return
;
}
upstreamKeyframeRequired
=
false
;
}
Assertions
.
checkState
(
!
upstreamFormatRequired
)
;
isLastSampleQueued
=
(
sampleFlags
&
C
.
BUFFER_FLAG_LAST_SAMPLE
)
!
=
0
;
largestQueuedTimestampUs
=
Math
.
max
(
largestQueuedTimestampUs
timeUs
)
;
int
relativeEndIndex
=
getRelativeIndex
(
length
)
;
timesUs
[
relativeEndIndex
]
=
timeUs
;
offsets
[
relativeEndIndex
]
=
offset
;
sizes
[
relativeEndIndex
]
=
size
;
flags
[
relativeEndIndex
]
=
sampleFlags
;
cryptoDatas
[
relativeEndIndex
]
=
cryptoData
;
formats
[
relativeEndIndex
]
=
upstreamFormat
;
sourceIds
[
relativeEndIndex
]
=
upstreamSourceId
;
upstreamCommittedFormat
=
upstreamFormat
;
length
+
+
;
if
(
length
=
=
capacity
)
{
int
newCapacity
=
capacity
+
SAMPLE_CAPACITY_INCREMENT
;
int
[
]
newSourceIds
=
new
int
[
newCapacity
]
;
long
[
]
newOffsets
=
new
long
[
newCapacity
]
;
long
[
]
newTimesUs
=
new
long
[
newCapacity
]
;
int
[
]
newFlags
=
new
int
[
newCapacity
]
;
int
[
]
newSizes
=
new
int
[
newCapacity
]
;
CryptoData
[
]
newCryptoDatas
=
new
CryptoData
[
newCapacity
]
;
Format
[
]
newFormats
=
new
Format
[
newCapacity
]
;
int
beforeWrap
=
capacity
-
relativeFirstIndex
;
System
.
arraycopy
(
offsets
relativeFirstIndex
newOffsets
0
beforeWrap
)
;
System
.
arraycopy
(
timesUs
relativeFirstIndex
newTimesUs
0
beforeWrap
)
;
System
.
arraycopy
(
flags
relativeFirstIndex
newFlags
0
beforeWrap
)
;
System
.
arraycopy
(
sizes
relativeFirstIndex
newSizes
0
beforeWrap
)
;
System
.
arraycopy
(
cryptoDatas
relativeFirstIndex
newCryptoDatas
0
beforeWrap
)
;
System
.
arraycopy
(
formats
relativeFirstIndex
newFormats
0
beforeWrap
)
;
System
.
arraycopy
(
sourceIds
relativeFirstIndex
newSourceIds
0
beforeWrap
)
;
int
afterWrap
=
relativeFirstIndex
;
System
.
arraycopy
(
offsets
0
newOffsets
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
timesUs
0
newTimesUs
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
flags
0
newFlags
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
sizes
0
newSizes
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
cryptoDatas
0
newCryptoDatas
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
formats
0
newFormats
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
sourceIds
0
newSourceIds
beforeWrap
afterWrap
)
;
offsets
=
newOffsets
;
timesUs
=
newTimesUs
;
flags
=
newFlags
;
sizes
=
newSizes
;
cryptoDatas
=
newCryptoDatas
;
formats
=
newFormats
;
sourceIds
=
newSourceIds
;
relativeFirstIndex
=
0
;
capacity
=
newCapacity
;
}
}
private
synchronized
boolean
attemptSplice
(
long
timeUs
)
{
if
(
length
=
=
0
)
{
return
timeUs
>
largestDiscardedTimestampUs
;
}
long
largestReadTimestampUs
=
Math
.
max
(
largestDiscardedTimestampUs
getLargestTimestamp
(
readPosition
)
)
;
if
(
largestReadTimestampUs
>
=
timeUs
)
{
return
false
;
}
int
retainCount
=
length
;
int
relativeSampleIndex
=
getRelativeIndex
(
length
-
1
)
;
while
(
retainCount
>
readPosition
&
&
timesUs
[
relativeSampleIndex
]
>
=
timeUs
)
{
retainCount
-
-
;
relativeSampleIndex
-
-
;
if
(
relativeSampleIndex
=
=
-
1
)
{
relativeSampleIndex
=
capacity
-
1
;
}
}
discardUpstreamSampleMetadata
(
absoluteFirstIndex
+
retainCount
)
;
return
true
;
}
private
long
discardUpstreamSampleMetadata
(
int
discardFromIndex
)
{
int
discardCount
=
getWriteIndex
(
)
-
discardFromIndex
;
Assertions
.
checkArgument
(
0
<
=
discardCount
&
&
discardCount
<
=
(
length
-
readPosition
)
)
;
length
-
=
discardCount
;
largestQueuedTimestampUs
=
Math
.
max
(
largestDiscardedTimestampUs
getLargestTimestamp
(
length
)
)
;
isLastSampleQueued
=
discardCount
=
=
0
&
&
isLastSampleQueued
;
if
(
length
!
=
0
)
{
int
relativeLastWriteIndex
=
getRelativeIndex
(
length
-
1
)
;
return
offsets
[
relativeLastWriteIndex
]
+
sizes
[
relativeLastWriteIndex
]
;
}
return
0
;
}
private
boolean
hasNextSample
(
)
{
return
readPosition
!
=
length
;
}
private
void
onFormatResult
(
Format
newFormat
FormatHolder
outputFormatHolder
)
{
outputFormatHolder
.
format
=
newFormat
;
boolean
isFirstFormat
=
downstreamFormat
=
=
null
;
DrmInitData
oldDrmInitData
=
isFirstFormat
?
null
:
downstreamFormat
.
drmInitData
;
downstreamFormat
=
newFormat
;
if
(
drmSessionManager
=
=
DrmSessionManager
.
DUMMY
)
{
return
;
}
DrmInitData
newDrmInitData
=
newFormat
.
drmInitData
;
outputFormatHolder
.
includesDrmSession
=
true
;
outputFormatHolder
.
drmSession
=
currentDrmSession
;
if
(
!
isFirstFormat
&
&
Util
.
areEqual
(
oldDrmInitData
newDrmInitData
)
)
{
return
;
}
DrmSession
<
?
>
previousSession
=
currentDrmSession
;
Looper
playbackLooper
=
Assertions
.
checkNotNull
(
Looper
.
myLooper
(
)
)
;
currentDrmSession
=
newDrmInitData
!
=
null
?
drmSessionManager
.
acquireSession
(
playbackLooper
newDrmInitData
)
:
drmSessionManager
.
acquirePlaceholderSession
(
playbackLooper
MimeTypes
.
getTrackType
(
newFormat
.
sampleMimeType
)
)
;
outputFormatHolder
.
drmSession
=
currentDrmSession
;
if
(
previousSession
!
=
null
)
{
previousSession
.
release
(
)
;
}
}
private
boolean
mayReadSample
(
int
relativeReadIndex
)
{
if
(
drmSessionManager
=
=
DrmSessionManager
.
DUMMY
)
{
return
true
;
}
return
currentDrmSession
=
=
null
|
|
currentDrmSession
.
getState
(
)
=
=
DrmSession
.
STATE_OPENED_WITH_KEYS
|
|
(
(
flags
[
relativeReadIndex
]
&
C
.
BUFFER_FLAG_ENCRYPTED
)
=
=
0
&
&
currentDrmSession
.
playClearSamplesWithoutKeys
(
)
)
;
}
private
int
findSampleBefore
(
int
relativeStartIndex
int
length
long
timeUs
boolean
keyframe
)
{
int
sampleCountToTarget
=
-
1
;
int
searchIndex
=
relativeStartIndex
;
for
(
int
i
=
0
;
i
<
length
&
&
timesUs
[
searchIndex
]
<
=
timeUs
;
i
+
+
)
{
if
(
!
keyframe
|
|
(
flags
[
searchIndex
]
&
C
.
BUFFER_FLAG_KEY_FRAME
)
!
=
0
)
{
sampleCountToTarget
=
i
;
}
searchIndex
+
+
;
if
(
searchIndex
=
=
capacity
)
{
searchIndex
=
0
;
}
}
return
sampleCountToTarget
;
}
private
long
discardSamples
(
int
discardCount
)
{
largestDiscardedTimestampUs
=
Math
.
max
(
largestDiscardedTimestampUs
getLargestTimestamp
(
discardCount
)
)
;
length
-
=
discardCount
;
absoluteFirstIndex
+
=
discardCount
;
relativeFirstIndex
+
=
discardCount
;
if
(
relativeFirstIndex
>
=
capacity
)
{
relativeFirstIndex
-
=
capacity
;
}
readPosition
-
=
discardCount
;
if
(
readPosition
<
0
)
{
readPosition
=
0
;
}
if
(
length
=
=
0
)
{
int
relativeLastDiscardIndex
=
(
relativeFirstIndex
=
=
0
?
capacity
:
relativeFirstIndex
)
-
1
;
return
offsets
[
relativeLastDiscardIndex
]
+
sizes
[
relativeLastDiscardIndex
]
;
}
else
{
return
offsets
[
relativeFirstIndex
]
;
}
}
private
long
getLargestTimestamp
(
int
length
)
{
if
(
length
=
=
0
)
{
return
Long
.
MIN_VALUE
;
}
long
largestTimestampUs
=
Long
.
MIN_VALUE
;
int
relativeSampleIndex
=
getRelativeIndex
(
length
-
1
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
largestTimestampUs
=
Math
.
max
(
largestTimestampUs
timesUs
[
relativeSampleIndex
]
)
;
if
(
(
flags
[
relativeSampleIndex
]
&
C
.
BUFFER_FLAG_KEY_FRAME
)
!
=
0
)
{
break
;
}
relativeSampleIndex
-
-
;
if
(
relativeSampleIndex
=
=
-
1
)
{
relativeSampleIndex
=
capacity
-
1
;
}
}
return
largestTimestampUs
;
}
private
int
getRelativeIndex
(
int
offset
)
{
int
relativeIndex
=
relativeFirstIndex
+
offset
;
return
relativeIndex
<
capacity
?
relativeIndex
:
relativeIndex
-
capacity
;
}
static
final
class
SampleExtrasHolder
{
public
int
size
;
public
long
offset
;
public
CryptoData
cryptoData
;
}
}
