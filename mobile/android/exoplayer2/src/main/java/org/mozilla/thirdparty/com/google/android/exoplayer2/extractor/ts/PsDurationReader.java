package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
final
class
PsDurationReader
{
private
static
final
int
TIMESTAMP_SEARCH_BYTES
=
20000
;
private
final
TimestampAdjuster
scrTimestampAdjuster
;
private
final
ParsableByteArray
packetBuffer
;
private
boolean
isDurationRead
;
private
boolean
isFirstScrValueRead
;
private
boolean
isLastScrValueRead
;
private
long
firstScrValue
;
private
long
lastScrValue
;
private
long
durationUs
;
PsDurationReader
(
)
{
scrTimestampAdjuster
=
new
TimestampAdjuster
(
0
)
;
firstScrValue
=
C
.
TIME_UNSET
;
lastScrValue
=
C
.
TIME_UNSET
;
durationUs
=
C
.
TIME_UNSET
;
packetBuffer
=
new
ParsableByteArray
(
)
;
}
public
boolean
isDurationReadFinished
(
)
{
return
isDurationRead
;
}
public
TimestampAdjuster
getScrTimestampAdjuster
(
)
{
return
scrTimestampAdjuster
;
}
public
Extractor
.
ReadResult
int
readDuration
(
ExtractorInput
input
PositionHolder
seekPositionHolder
)
throws
IOException
InterruptedException
{
if
(
!
isLastScrValueRead
)
{
return
readLastScrValue
(
input
seekPositionHolder
)
;
}
if
(
lastScrValue
=
=
C
.
TIME_UNSET
)
{
return
finishReadDuration
(
input
)
;
}
if
(
!
isFirstScrValueRead
)
{
return
readFirstScrValue
(
input
seekPositionHolder
)
;
}
if
(
firstScrValue
=
=
C
.
TIME_UNSET
)
{
return
finishReadDuration
(
input
)
;
}
long
minScrPositionUs
=
scrTimestampAdjuster
.
adjustTsTimestamp
(
firstScrValue
)
;
long
maxScrPositionUs
=
scrTimestampAdjuster
.
adjustTsTimestamp
(
lastScrValue
)
;
durationUs
=
maxScrPositionUs
-
minScrPositionUs
;
return
finishReadDuration
(
input
)
;
}
public
long
getDurationUs
(
)
{
return
durationUs
;
}
public
static
long
readScrValueFromPack
(
ParsableByteArray
packetBuffer
)
{
int
originalPosition
=
packetBuffer
.
getPosition
(
)
;
if
(
packetBuffer
.
bytesLeft
(
)
<
9
)
{
return
C
.
TIME_UNSET
;
}
byte
[
]
scrBytes
=
new
byte
[
9
]
;
packetBuffer
.
readBytes
(
scrBytes
0
scrBytes
.
length
)
;
packetBuffer
.
setPosition
(
originalPosition
)
;
if
(
!
checkMarkerBits
(
scrBytes
)
)
{
return
C
.
TIME_UNSET
;
}
return
readScrValueFromPackHeader
(
scrBytes
)
;
}
private
int
finishReadDuration
(
ExtractorInput
input
)
{
packetBuffer
.
reset
(
Util
.
EMPTY_BYTE_ARRAY
)
;
isDurationRead
=
true
;
input
.
resetPeekPosition
(
)
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
int
readFirstScrValue
(
ExtractorInput
input
PositionHolder
seekPositionHolder
)
throws
IOException
InterruptedException
{
int
bytesToSearch
=
(
int
)
Math
.
min
(
TIMESTAMP_SEARCH_BYTES
input
.
getLength
(
)
)
;
int
searchStartPosition
=
0
;
if
(
input
.
getPosition
(
)
!
=
searchStartPosition
)
{
seekPositionHolder
.
position
=
searchStartPosition
;
return
Extractor
.
RESULT_SEEK
;
}
packetBuffer
.
reset
(
bytesToSearch
)
;
input
.
resetPeekPosition
(
)
;
input
.
peekFully
(
packetBuffer
.
data
0
bytesToSearch
)
;
firstScrValue
=
readFirstScrValueFromBuffer
(
packetBuffer
)
;
isFirstScrValueRead
=
true
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
long
readFirstScrValueFromBuffer
(
ParsableByteArray
packetBuffer
)
{
int
searchStartPosition
=
packetBuffer
.
getPosition
(
)
;
int
searchEndPosition
=
packetBuffer
.
limit
(
)
;
for
(
int
searchPosition
=
searchStartPosition
;
searchPosition
<
searchEndPosition
-
3
;
searchPosition
+
+
)
{
int
nextStartCode
=
peekIntAtPosition
(
packetBuffer
.
data
searchPosition
)
;
if
(
nextStartCode
=
=
PsExtractor
.
PACK_START_CODE
)
{
packetBuffer
.
setPosition
(
searchPosition
+
4
)
;
long
scrValue
=
readScrValueFromPack
(
packetBuffer
)
;
if
(
scrValue
!
=
C
.
TIME_UNSET
)
{
return
scrValue
;
}
}
}
return
C
.
TIME_UNSET
;
}
private
int
readLastScrValue
(
ExtractorInput
input
PositionHolder
seekPositionHolder
)
throws
IOException
InterruptedException
{
long
inputLength
=
input
.
getLength
(
)
;
int
bytesToSearch
=
(
int
)
Math
.
min
(
TIMESTAMP_SEARCH_BYTES
inputLength
)
;
long
searchStartPosition
=
inputLength
-
bytesToSearch
;
if
(
input
.
getPosition
(
)
!
=
searchStartPosition
)
{
seekPositionHolder
.
position
=
searchStartPosition
;
return
Extractor
.
RESULT_SEEK
;
}
packetBuffer
.
reset
(
bytesToSearch
)
;
input
.
resetPeekPosition
(
)
;
input
.
peekFully
(
packetBuffer
.
data
0
bytesToSearch
)
;
lastScrValue
=
readLastScrValueFromBuffer
(
packetBuffer
)
;
isLastScrValueRead
=
true
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
long
readLastScrValueFromBuffer
(
ParsableByteArray
packetBuffer
)
{
int
searchStartPosition
=
packetBuffer
.
getPosition
(
)
;
int
searchEndPosition
=
packetBuffer
.
limit
(
)
;
for
(
int
searchPosition
=
searchEndPosition
-
4
;
searchPosition
>
=
searchStartPosition
;
searchPosition
-
-
)
{
int
nextStartCode
=
peekIntAtPosition
(
packetBuffer
.
data
searchPosition
)
;
if
(
nextStartCode
=
=
PsExtractor
.
PACK_START_CODE
)
{
packetBuffer
.
setPosition
(
searchPosition
+
4
)
;
long
scrValue
=
readScrValueFromPack
(
packetBuffer
)
;
if
(
scrValue
!
=
C
.
TIME_UNSET
)
{
return
scrValue
;
}
}
}
return
C
.
TIME_UNSET
;
}
private
int
peekIntAtPosition
(
byte
[
]
data
int
position
)
{
return
(
data
[
position
]
&
0xFF
)
<
<
24
|
(
data
[
position
+
1
]
&
0xFF
)
<
<
16
|
(
data
[
position
+
2
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
3
]
&
0xFF
)
;
}
private
static
boolean
checkMarkerBits
(
byte
[
]
scrBytes
)
{
if
(
(
scrBytes
[
0
]
&
0xC4
)
!
=
0x44
)
{
return
false
;
}
if
(
(
scrBytes
[
2
]
&
0x04
)
!
=
0x04
)
{
return
false
;
}
if
(
(
scrBytes
[
4
]
&
0x04
)
!
=
0x04
)
{
return
false
;
}
if
(
(
scrBytes
[
5
]
&
0x01
)
!
=
0x01
)
{
return
false
;
}
return
(
scrBytes
[
8
]
&
0x03
)
=
=
0x03
;
}
private
static
long
readScrValueFromPackHeader
(
byte
[
]
scrBytes
)
{
return
(
(
scrBytes
[
0
]
&
0b00111000L
)
>
>
3
)
<
<
30
|
(
scrBytes
[
0
]
&
0b00000011L
)
<
<
28
|
(
scrBytes
[
1
]
&
0xFFL
)
<
<
20
|
(
(
scrBytes
[
2
]
&
0b11111000L
)
>
>
3
)
<
<
15
|
(
scrBytes
[
2
]
&
0b00000011L
)
<
<
13
|
(
scrBytes
[
3
]
&
0xFFL
)
<
<
5
|
(
scrBytes
[
4
]
&
0b11111000L
)
>
>
3
;
}
}
