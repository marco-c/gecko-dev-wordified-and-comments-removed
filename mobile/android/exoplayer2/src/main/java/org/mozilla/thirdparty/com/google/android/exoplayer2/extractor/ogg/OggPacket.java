package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ogg
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
final
class
OggPacket
{
private
final
OggPageHeader
pageHeader
=
new
OggPageHeader
(
)
;
private
final
ParsableByteArray
packetArray
=
new
ParsableByteArray
(
new
byte
[
OggPageHeader
.
MAX_PAGE_PAYLOAD
]
0
)
;
private
int
currentSegmentIndex
=
C
.
INDEX_UNSET
;
private
int
segmentCount
;
private
boolean
populated
;
public
void
reset
(
)
{
pageHeader
.
reset
(
)
;
packetArray
.
reset
(
)
;
currentSegmentIndex
=
C
.
INDEX_UNSET
;
populated
=
false
;
}
public
boolean
populate
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
Assertions
.
checkState
(
input
!
=
null
)
;
if
(
populated
)
{
populated
=
false
;
packetArray
.
reset
(
)
;
}
while
(
!
populated
)
{
if
(
currentSegmentIndex
<
0
)
{
if
(
!
pageHeader
.
populate
(
input
true
)
)
{
return
false
;
}
int
segmentIndex
=
0
;
int
bytesToSkip
=
pageHeader
.
headerSize
;
if
(
(
pageHeader
.
type
&
0x01
)
=
=
0x01
&
&
packetArray
.
limit
(
)
=
=
0
)
{
bytesToSkip
+
=
calculatePacketSize
(
segmentIndex
)
;
segmentIndex
+
=
segmentCount
;
}
input
.
skipFully
(
bytesToSkip
)
;
currentSegmentIndex
=
segmentIndex
;
}
int
size
=
calculatePacketSize
(
currentSegmentIndex
)
;
int
segmentIndex
=
currentSegmentIndex
+
segmentCount
;
if
(
size
>
0
)
{
if
(
packetArray
.
capacity
(
)
<
packetArray
.
limit
(
)
+
size
)
{
packetArray
.
data
=
Arrays
.
copyOf
(
packetArray
.
data
packetArray
.
limit
(
)
+
size
)
;
}
input
.
readFully
(
packetArray
.
data
packetArray
.
limit
(
)
size
)
;
packetArray
.
setLimit
(
packetArray
.
limit
(
)
+
size
)
;
populated
=
pageHeader
.
laces
[
segmentIndex
-
1
]
!
=
255
;
}
currentSegmentIndex
=
segmentIndex
=
=
pageHeader
.
pageSegmentCount
?
C
.
INDEX_UNSET
:
segmentIndex
;
}
return
true
;
}
public
OggPageHeader
getPageHeader
(
)
{
return
pageHeader
;
}
public
ParsableByteArray
getPayload
(
)
{
return
packetArray
;
}
public
void
trimPayload
(
)
{
if
(
packetArray
.
data
.
length
=
=
OggPageHeader
.
MAX_PAGE_PAYLOAD
)
{
return
;
}
packetArray
.
data
=
Arrays
.
copyOf
(
packetArray
.
data
Math
.
max
(
OggPageHeader
.
MAX_PAGE_PAYLOAD
packetArray
.
limit
(
)
)
)
;
}
private
int
calculatePacketSize
(
int
startSegmentIndex
)
{
segmentCount
=
0
;
int
size
=
0
;
while
(
startSegmentIndex
+
segmentCount
<
pageHeader
.
pageSegmentCount
)
{
int
segmentLength
=
pageHeader
.
laces
[
startSegmentIndex
+
segmentCount
+
+
]
;
size
+
=
segmentLength
;
if
(
segmentLength
!
=
255
)
{
break
;
}
}
return
size
;
}
}
