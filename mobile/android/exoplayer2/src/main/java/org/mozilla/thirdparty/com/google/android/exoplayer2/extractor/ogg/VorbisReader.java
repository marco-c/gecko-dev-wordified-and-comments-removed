package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ogg
;
import
androidx
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
VorbisUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
VorbisUtil
.
Mode
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
final
class
VorbisReader
extends
StreamReader
{
private
VorbisSetup
vorbisSetup
;
private
int
previousPacketBlockSize
;
private
boolean
seenFirstAudioPacket
;
private
VorbisUtil
.
VorbisIdHeader
vorbisIdHeader
;
private
VorbisUtil
.
CommentHeader
commentHeader
;
public
static
boolean
verifyBitstreamType
(
ParsableByteArray
data
)
{
try
{
return
VorbisUtil
.
verifyVorbisHeaderCapturePattern
(
0x01
data
true
)
;
}
catch
(
ParserException
e
)
{
return
false
;
}
}
Override
protected
void
reset
(
boolean
headerData
)
{
super
.
reset
(
headerData
)
;
if
(
headerData
)
{
vorbisSetup
=
null
;
vorbisIdHeader
=
null
;
commentHeader
=
null
;
}
previousPacketBlockSize
=
0
;
seenFirstAudioPacket
=
false
;
}
Override
protected
void
onSeekEnd
(
long
currentGranule
)
{
super
.
onSeekEnd
(
currentGranule
)
;
seenFirstAudioPacket
=
currentGranule
!
=
0
;
previousPacketBlockSize
=
vorbisIdHeader
!
=
null
?
vorbisIdHeader
.
blockSize0
:
0
;
}
Override
protected
long
preparePayload
(
ParsableByteArray
packet
)
{
if
(
(
packet
.
data
[
0
]
&
0x01
)
=
=
1
)
{
return
-
1
;
}
int
packetBlockSize
=
decodeBlockSize
(
packet
.
data
[
0
]
vorbisSetup
)
;
int
samplesInPacket
=
seenFirstAudioPacket
?
(
packetBlockSize
+
previousPacketBlockSize
)
/
4
:
0
;
appendNumberOfSamples
(
packet
samplesInPacket
)
;
seenFirstAudioPacket
=
true
;
previousPacketBlockSize
=
packetBlockSize
;
return
samplesInPacket
;
}
Override
protected
boolean
readHeaders
(
ParsableByteArray
packet
long
position
SetupData
setupData
)
throws
IOException
InterruptedException
{
if
(
vorbisSetup
!
=
null
)
{
return
false
;
}
vorbisSetup
=
readSetupHeaders
(
packet
)
;
if
(
vorbisSetup
=
=
null
)
{
return
true
;
}
ArrayList
<
byte
[
]
>
codecInitialisationData
=
new
ArrayList
<
>
(
)
;
codecInitialisationData
.
add
(
vorbisSetup
.
idHeader
.
data
)
;
codecInitialisationData
.
add
(
vorbisSetup
.
setupHeaderData
)
;
setupData
.
format
=
Format
.
createAudioSampleFormat
(
null
MimeTypes
.
AUDIO_VORBIS
null
this
.
vorbisSetup
.
idHeader
.
bitrateNominal
Format
.
NO_VALUE
this
.
vorbisSetup
.
idHeader
.
channels
(
int
)
this
.
vorbisSetup
.
idHeader
.
sampleRate
codecInitialisationData
null
0
null
)
;
return
true
;
}
VisibleForTesting
VorbisSetup
readSetupHeaders
(
ParsableByteArray
scratch
)
throws
IOException
{
if
(
vorbisIdHeader
=
=
null
)
{
vorbisIdHeader
=
VorbisUtil
.
readVorbisIdentificationHeader
(
scratch
)
;
return
null
;
}
if
(
commentHeader
=
=
null
)
{
commentHeader
=
VorbisUtil
.
readVorbisCommentHeader
(
scratch
)
;
return
null
;
}
byte
[
]
setupHeaderData
=
new
byte
[
scratch
.
limit
(
)
]
;
System
.
arraycopy
(
scratch
.
data
0
setupHeaderData
0
scratch
.
limit
(
)
)
;
Mode
[
]
modes
=
VorbisUtil
.
readVorbisModes
(
scratch
vorbisIdHeader
.
channels
)
;
int
iLogModes
=
VorbisUtil
.
iLog
(
modes
.
length
-
1
)
;
return
new
VorbisSetup
(
vorbisIdHeader
commentHeader
setupHeaderData
modes
iLogModes
)
;
}
VisibleForTesting
static
int
readBits
(
byte
src
int
length
int
leastSignificantBitIndex
)
{
return
(
src
>
>
leastSignificantBitIndex
)
&
(
255
>
>
>
(
8
-
length
)
)
;
}
VisibleForTesting
static
void
appendNumberOfSamples
(
ParsableByteArray
buffer
long
packetSampleCount
)
{
buffer
.
setLimit
(
buffer
.
limit
(
)
+
4
)
;
buffer
.
data
[
buffer
.
limit
(
)
-
4
]
=
(
byte
)
(
packetSampleCount
&
0xFF
)
;
buffer
.
data
[
buffer
.
limit
(
)
-
3
]
=
(
byte
)
(
(
packetSampleCount
>
>
>
8
)
&
0xFF
)
;
buffer
.
data
[
buffer
.
limit
(
)
-
2
]
=
(
byte
)
(
(
packetSampleCount
>
>
>
16
)
&
0xFF
)
;
buffer
.
data
[
buffer
.
limit
(
)
-
1
]
=
(
byte
)
(
(
packetSampleCount
>
>
>
24
)
&
0xFF
)
;
}
private
static
int
decodeBlockSize
(
byte
firstByteOfAudioPacket
VorbisSetup
vorbisSetup
)
{
int
modeNumber
=
readBits
(
firstByteOfAudioPacket
vorbisSetup
.
iLogModes
1
)
;
int
currentBlockSize
;
if
(
!
vorbisSetup
.
modes
[
modeNumber
]
.
blockFlag
)
{
currentBlockSize
=
vorbisSetup
.
idHeader
.
blockSize0
;
}
else
{
currentBlockSize
=
vorbisSetup
.
idHeader
.
blockSize1
;
}
return
currentBlockSize
;
}
static
final
class
VorbisSetup
{
public
final
VorbisUtil
.
VorbisIdHeader
idHeader
;
public
final
VorbisUtil
.
CommentHeader
commentHeader
;
public
final
byte
[
]
setupHeaderData
;
public
final
Mode
[
]
modes
;
public
final
int
iLogModes
;
public
VorbisSetup
(
VorbisUtil
.
VorbisIdHeader
idHeader
VorbisUtil
.
CommentHeader
commentHeader
byte
[
]
setupHeaderData
Mode
[
]
modes
int
iLogModes
)
{
this
.
idHeader
=
idHeader
;
this
.
commentHeader
=
commentHeader
;
this
.
setupHeaderData
=
setupHeaderData
;
this
.
modes
=
modes
;
this
.
iLogModes
=
iLogModes
;
}
}
}
