package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
wav
;
import
android
.
util
.
Pair
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
WavUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
final
class
WavHeaderReader
{
private
static
final
String
TAG
=
"
WavHeaderReader
"
;
Nullable
public
static
WavHeader
peek
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
Assertions
.
checkNotNull
(
input
)
;
ParsableByteArray
scratch
=
new
ParsableByteArray
(
16
)
;
ChunkHeader
chunkHeader
=
ChunkHeader
.
peek
(
input
scratch
)
;
if
(
chunkHeader
.
id
!
=
WavUtil
.
RIFF_FOURCC
)
{
return
null
;
}
input
.
peekFully
(
scratch
.
data
0
4
)
;
scratch
.
setPosition
(
0
)
;
int
riffFormat
=
scratch
.
readInt
(
)
;
if
(
riffFormat
!
=
WavUtil
.
WAVE_FOURCC
)
{
Log
.
e
(
TAG
"
Unsupported
RIFF
format
:
"
+
riffFormat
)
;
return
null
;
}
chunkHeader
=
ChunkHeader
.
peek
(
input
scratch
)
;
while
(
chunkHeader
.
id
!
=
WavUtil
.
FMT_FOURCC
)
{
input
.
advancePeekPosition
(
(
int
)
chunkHeader
.
size
)
;
chunkHeader
=
ChunkHeader
.
peek
(
input
scratch
)
;
}
Assertions
.
checkState
(
chunkHeader
.
size
>
=
16
)
;
input
.
peekFully
(
scratch
.
data
0
16
)
;
scratch
.
setPosition
(
0
)
;
int
audioFormatType
=
scratch
.
readLittleEndianUnsignedShort
(
)
;
int
numChannels
=
scratch
.
readLittleEndianUnsignedShort
(
)
;
int
frameRateHz
=
scratch
.
readLittleEndianUnsignedIntToInt
(
)
;
int
averageBytesPerSecond
=
scratch
.
readLittleEndianUnsignedIntToInt
(
)
;
int
blockSize
=
scratch
.
readLittleEndianUnsignedShort
(
)
;
int
bitsPerSample
=
scratch
.
readLittleEndianUnsignedShort
(
)
;
int
bytesLeft
=
(
int
)
chunkHeader
.
size
-
16
;
byte
[
]
extraData
;
if
(
bytesLeft
>
0
)
{
extraData
=
new
byte
[
bytesLeft
]
;
input
.
peekFully
(
extraData
0
bytesLeft
)
;
}
else
{
extraData
=
Util
.
EMPTY_BYTE_ARRAY
;
}
return
new
WavHeader
(
audioFormatType
numChannels
frameRateHz
averageBytesPerSecond
blockSize
bitsPerSample
extraData
)
;
}
public
static
Pair
<
Long
Long
>
skipToData
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
Assertions
.
checkNotNull
(
input
)
;
input
.
resetPeekPosition
(
)
;
ParsableByteArray
scratch
=
new
ParsableByteArray
(
ChunkHeader
.
SIZE_IN_BYTES
)
;
ChunkHeader
chunkHeader
=
ChunkHeader
.
peek
(
input
scratch
)
;
while
(
chunkHeader
.
id
!
=
WavUtil
.
DATA_FOURCC
)
{
if
(
chunkHeader
.
id
!
=
WavUtil
.
RIFF_FOURCC
&
&
chunkHeader
.
id
!
=
WavUtil
.
FMT_FOURCC
)
{
Log
.
w
(
TAG
"
Ignoring
unknown
WAV
chunk
:
"
+
chunkHeader
.
id
)
;
}
long
bytesToSkip
=
ChunkHeader
.
SIZE_IN_BYTES
+
chunkHeader
.
size
;
if
(
chunkHeader
.
id
=
=
WavUtil
.
RIFF_FOURCC
)
{
bytesToSkip
=
ChunkHeader
.
SIZE_IN_BYTES
+
4
;
}
if
(
bytesToSkip
>
Integer
.
MAX_VALUE
)
{
throw
new
ParserException
(
"
Chunk
is
too
large
(
~
2GB
+
)
to
skip
;
id
:
"
+
chunkHeader
.
id
)
;
}
input
.
skipFully
(
(
int
)
bytesToSkip
)
;
chunkHeader
=
ChunkHeader
.
peek
(
input
scratch
)
;
}
input
.
skipFully
(
ChunkHeader
.
SIZE_IN_BYTES
)
;
long
dataStartPosition
=
input
.
getPosition
(
)
;
long
dataEndPosition
=
dataStartPosition
+
chunkHeader
.
size
;
long
inputLength
=
input
.
getLength
(
)
;
if
(
inputLength
!
=
C
.
LENGTH_UNSET
&
&
dataEndPosition
>
inputLength
)
{
Log
.
w
(
TAG
"
Data
exceeds
input
length
:
"
+
dataEndPosition
+
"
"
+
inputLength
)
;
dataEndPosition
=
inputLength
;
}
return
Pair
.
create
(
dataStartPosition
dataEndPosition
)
;
}
private
WavHeaderReader
(
)
{
}
private
static
final
class
ChunkHeader
{
public
static
final
int
SIZE_IN_BYTES
=
8
;
public
final
int
id
;
public
final
long
size
;
private
ChunkHeader
(
int
id
long
size
)
{
this
.
id
=
id
;
this
.
size
=
size
;
}
public
static
ChunkHeader
peek
(
ExtractorInput
input
ParsableByteArray
scratch
)
throws
IOException
InterruptedException
{
input
.
peekFully
(
scratch
.
data
0
SIZE_IN_BYTES
)
;
scratch
.
setPosition
(
0
)
;
int
id
=
scratch
.
readInt
(
)
;
long
size
=
scratch
.
readLittleEndianUnsignedInt
(
)
;
return
new
ChunkHeader
(
id
size
)
;
}
}
}
