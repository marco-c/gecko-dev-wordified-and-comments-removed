package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
ClippingMediaPeriod
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
EmptySampleStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaPeriod
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
.
MediaPeriodId
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SampleStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroupArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelectionArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelector
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelectorResult
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
checkerframework
.
checker
.
nullness
.
compatqual
.
NullableType
;
final
class
MediaPeriodHolder
{
private
static
final
String
TAG
=
"
MediaPeriodHolder
"
;
public
final
MediaPeriod
mediaPeriod
;
public
final
Object
uid
;
public
final
NullableType
SampleStream
[
]
sampleStreams
;
public
boolean
prepared
;
public
boolean
hasEnabledTracks
;
public
MediaPeriodInfo
info
;
private
final
boolean
[
]
mayRetainStreamFlags
;
private
final
RendererCapabilities
[
]
rendererCapabilities
;
private
final
TrackSelector
trackSelector
;
private
final
MediaSource
mediaSource
;
Nullable
private
MediaPeriodHolder
next
;
private
TrackGroupArray
trackGroups
;
private
TrackSelectorResult
trackSelectorResult
;
private
long
rendererPositionOffsetUs
;
public
MediaPeriodHolder
(
RendererCapabilities
[
]
rendererCapabilities
long
rendererPositionOffsetUs
TrackSelector
trackSelector
Allocator
allocator
MediaSource
mediaSource
MediaPeriodInfo
info
TrackSelectorResult
emptyTrackSelectorResult
)
{
this
.
rendererCapabilities
=
rendererCapabilities
;
this
.
rendererPositionOffsetUs
=
rendererPositionOffsetUs
;
this
.
trackSelector
=
trackSelector
;
this
.
mediaSource
=
mediaSource
;
this
.
uid
=
info
.
id
.
periodUid
;
this
.
info
=
info
;
this
.
trackGroups
=
TrackGroupArray
.
EMPTY
;
this
.
trackSelectorResult
=
emptyTrackSelectorResult
;
sampleStreams
=
new
SampleStream
[
rendererCapabilities
.
length
]
;
mayRetainStreamFlags
=
new
boolean
[
rendererCapabilities
.
length
]
;
mediaPeriod
=
createMediaPeriod
(
info
.
id
mediaSource
allocator
info
.
startPositionUs
info
.
endPositionUs
)
;
}
public
long
toRendererTime
(
long
periodTimeUs
)
{
return
periodTimeUs
+
getRendererOffset
(
)
;
}
public
long
toPeriodTime
(
long
rendererTimeUs
)
{
return
rendererTimeUs
-
getRendererOffset
(
)
;
}
public
long
getRendererOffset
(
)
{
return
rendererPositionOffsetUs
;
}
public
void
setRendererOffset
(
long
rendererPositionOffsetUs
)
{
this
.
rendererPositionOffsetUs
=
rendererPositionOffsetUs
;
}
public
long
getStartPositionRendererTime
(
)
{
return
info
.
startPositionUs
+
rendererPositionOffsetUs
;
}
public
boolean
isFullyBuffered
(
)
{
return
prepared
&
&
(
!
hasEnabledTracks
|
|
mediaPeriod
.
getBufferedPositionUs
(
)
=
=
C
.
TIME_END_OF_SOURCE
)
;
}
public
long
getBufferedPositionUs
(
)
{
if
(
!
prepared
)
{
return
info
.
startPositionUs
;
}
long
bufferedPositionUs
=
hasEnabledTracks
?
mediaPeriod
.
getBufferedPositionUs
(
)
:
C
.
TIME_END_OF_SOURCE
;
return
bufferedPositionUs
=
=
C
.
TIME_END_OF_SOURCE
?
info
.
durationUs
:
bufferedPositionUs
;
}
public
long
getNextLoadPositionUs
(
)
{
return
!
prepared
?
0
:
mediaPeriod
.
getNextLoadPositionUs
(
)
;
}
public
void
handlePrepared
(
float
playbackSpeed
Timeline
timeline
)
throws
ExoPlaybackException
{
prepared
=
true
;
trackGroups
=
mediaPeriod
.
getTrackGroups
(
)
;
TrackSelectorResult
selectorResult
=
selectTracks
(
playbackSpeed
timeline
)
;
long
newStartPositionUs
=
applyTrackSelection
(
selectorResult
info
.
startPositionUs
false
)
;
rendererPositionOffsetUs
+
=
info
.
startPositionUs
-
newStartPositionUs
;
info
=
info
.
copyWithStartPositionUs
(
newStartPositionUs
)
;
}
public
void
reevaluateBuffer
(
long
rendererPositionUs
)
{
Assertions
.
checkState
(
isLoadingMediaPeriod
(
)
)
;
if
(
prepared
)
{
mediaPeriod
.
reevaluateBuffer
(
toPeriodTime
(
rendererPositionUs
)
)
;
}
}
public
void
continueLoading
(
long
rendererPositionUs
)
{
Assertions
.
checkState
(
isLoadingMediaPeriod
(
)
)
;
long
loadingPeriodPositionUs
=
toPeriodTime
(
rendererPositionUs
)
;
mediaPeriod
.
continueLoading
(
loadingPeriodPositionUs
)
;
}
public
TrackSelectorResult
selectTracks
(
float
playbackSpeed
Timeline
timeline
)
throws
ExoPlaybackException
{
TrackSelectorResult
selectorResult
=
trackSelector
.
selectTracks
(
rendererCapabilities
getTrackGroups
(
)
info
.
id
timeline
)
;
for
(
TrackSelection
trackSelection
:
selectorResult
.
selections
.
getAll
(
)
)
{
if
(
trackSelection
!
=
null
)
{
trackSelection
.
onPlaybackSpeed
(
playbackSpeed
)
;
}
}
return
selectorResult
;
}
public
long
applyTrackSelection
(
TrackSelectorResult
trackSelectorResult
long
positionUs
boolean
forceRecreateStreams
)
{
return
applyTrackSelection
(
trackSelectorResult
positionUs
forceRecreateStreams
new
boolean
[
rendererCapabilities
.
length
]
)
;
}
public
long
applyTrackSelection
(
TrackSelectorResult
newTrackSelectorResult
long
positionUs
boolean
forceRecreateStreams
boolean
[
]
streamResetFlags
)
{
for
(
int
i
=
0
;
i
<
newTrackSelectorResult
.
length
;
i
+
+
)
{
mayRetainStreamFlags
[
i
]
=
!
forceRecreateStreams
&
&
newTrackSelectorResult
.
isEquivalent
(
trackSelectorResult
i
)
;
}
disassociateNoSampleRenderersWithEmptySampleStream
(
sampleStreams
)
;
disableTrackSelectionsInResult
(
)
;
trackSelectorResult
=
newTrackSelectorResult
;
enableTrackSelectionsInResult
(
)
;
TrackSelectionArray
trackSelections
=
newTrackSelectorResult
.
selections
;
positionUs
=
mediaPeriod
.
selectTracks
(
trackSelections
.
getAll
(
)
mayRetainStreamFlags
sampleStreams
streamResetFlags
positionUs
)
;
associateNoSampleRenderersWithEmptySampleStream
(
sampleStreams
)
;
hasEnabledTracks
=
false
;
for
(
int
i
=
0
;
i
<
sampleStreams
.
length
;
i
+
+
)
{
if
(
sampleStreams
[
i
]
!
=
null
)
{
Assertions
.
checkState
(
newTrackSelectorResult
.
isRendererEnabled
(
i
)
)
;
if
(
rendererCapabilities
[
i
]
.
getTrackType
(
)
!
=
C
.
TRACK_TYPE_NONE
)
{
hasEnabledTracks
=
true
;
}
}
else
{
Assertions
.
checkState
(
trackSelections
.
get
(
i
)
=
=
null
)
;
}
}
return
positionUs
;
}
public
void
release
(
)
{
disableTrackSelectionsInResult
(
)
;
releaseMediaPeriod
(
info
.
endPositionUs
mediaSource
mediaPeriod
)
;
}
public
void
setNext
(
Nullable
MediaPeriodHolder
nextMediaPeriodHolder
)
{
if
(
nextMediaPeriodHolder
=
=
next
)
{
return
;
}
disableTrackSelectionsInResult
(
)
;
next
=
nextMediaPeriodHolder
;
enableTrackSelectionsInResult
(
)
;
}
Nullable
public
MediaPeriodHolder
getNext
(
)
{
return
next
;
}
public
TrackGroupArray
getTrackGroups
(
)
{
return
trackGroups
;
}
public
TrackSelectorResult
getTrackSelectorResult
(
)
{
return
trackSelectorResult
;
}
private
void
enableTrackSelectionsInResult
(
)
{
if
(
!
isLoadingMediaPeriod
(
)
)
{
return
;
}
for
(
int
i
=
0
;
i
<
trackSelectorResult
.
length
;
i
+
+
)
{
boolean
rendererEnabled
=
trackSelectorResult
.
isRendererEnabled
(
i
)
;
TrackSelection
trackSelection
=
trackSelectorResult
.
selections
.
get
(
i
)
;
if
(
rendererEnabled
&
&
trackSelection
!
=
null
)
{
trackSelection
.
enable
(
)
;
}
}
}
private
void
disableTrackSelectionsInResult
(
)
{
if
(
!
isLoadingMediaPeriod
(
)
)
{
return
;
}
for
(
int
i
=
0
;
i
<
trackSelectorResult
.
length
;
i
+
+
)
{
boolean
rendererEnabled
=
trackSelectorResult
.
isRendererEnabled
(
i
)
;
TrackSelection
trackSelection
=
trackSelectorResult
.
selections
.
get
(
i
)
;
if
(
rendererEnabled
&
&
trackSelection
!
=
null
)
{
trackSelection
.
disable
(
)
;
}
}
}
private
void
disassociateNoSampleRenderersWithEmptySampleStream
(
NullableType
SampleStream
[
]
sampleStreams
)
{
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
if
(
rendererCapabilities
[
i
]
.
getTrackType
(
)
=
=
C
.
TRACK_TYPE_NONE
)
{
sampleStreams
[
i
]
=
null
;
}
}
}
private
void
associateNoSampleRenderersWithEmptySampleStream
(
NullableType
SampleStream
[
]
sampleStreams
)
{
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
if
(
rendererCapabilities
[
i
]
.
getTrackType
(
)
=
=
C
.
TRACK_TYPE_NONE
&
&
trackSelectorResult
.
isRendererEnabled
(
i
)
)
{
sampleStreams
[
i
]
=
new
EmptySampleStream
(
)
;
}
}
}
private
boolean
isLoadingMediaPeriod
(
)
{
return
next
=
=
null
;
}
private
static
MediaPeriod
createMediaPeriod
(
MediaPeriodId
id
MediaSource
mediaSource
Allocator
allocator
long
startPositionUs
long
endPositionUs
)
{
MediaPeriod
mediaPeriod
=
mediaSource
.
createPeriod
(
id
allocator
startPositionUs
)
;
if
(
endPositionUs
!
=
C
.
TIME_UNSET
&
&
endPositionUs
!
=
C
.
TIME_END_OF_SOURCE
)
{
mediaPeriod
=
new
ClippingMediaPeriod
(
mediaPeriod
true
0
endPositionUs
)
;
}
return
mediaPeriod
;
}
private
static
void
releaseMediaPeriod
(
long
endPositionUs
MediaSource
mediaSource
MediaPeriod
mediaPeriod
)
{
try
{
if
(
endPositionUs
!
=
C
.
TIME_UNSET
&
&
endPositionUs
!
=
C
.
TIME_END_OF_SOURCE
)
{
mediaSource
.
releasePeriod
(
(
(
ClippingMediaPeriod
)
mediaPeriod
)
.
mediaPeriod
)
;
}
else
{
mediaSource
.
releasePeriod
(
mediaPeriod
)
;
}
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
TAG
"
Period
release
failed
.
"
e
)
;
}
}
}
