package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
util
.
Arrays
;
public
final
class
DefaultAllocator
implements
Allocator
{
private
static
final
int
AVAILABLE_EXTRA_CAPACITY
=
100
;
private
final
boolean
trimOnReset
;
private
final
int
individualAllocationSize
;
private
final
byte
[
]
initialAllocationBlock
;
private
final
Allocation
[
]
singleAllocationReleaseHolder
;
private
int
targetBufferSize
;
private
int
allocatedCount
;
private
int
availableCount
;
private
Allocation
[
]
availableAllocations
;
public
DefaultAllocator
(
boolean
trimOnReset
int
individualAllocationSize
)
{
this
(
trimOnReset
individualAllocationSize
0
)
;
}
public
DefaultAllocator
(
boolean
trimOnReset
int
individualAllocationSize
int
initialAllocationCount
)
{
Assertions
.
checkArgument
(
individualAllocationSize
>
0
)
;
Assertions
.
checkArgument
(
initialAllocationCount
>
=
0
)
;
this
.
trimOnReset
=
trimOnReset
;
this
.
individualAllocationSize
=
individualAllocationSize
;
this
.
availableCount
=
initialAllocationCount
;
this
.
availableAllocations
=
new
Allocation
[
initialAllocationCount
+
AVAILABLE_EXTRA_CAPACITY
]
;
if
(
initialAllocationCount
>
0
)
{
initialAllocationBlock
=
new
byte
[
initialAllocationCount
*
individualAllocationSize
]
;
for
(
int
i
=
0
;
i
<
initialAllocationCount
;
i
+
+
)
{
int
allocationOffset
=
i
*
individualAllocationSize
;
availableAllocations
[
i
]
=
new
Allocation
(
initialAllocationBlock
allocationOffset
)
;
}
}
else
{
initialAllocationBlock
=
null
;
}
singleAllocationReleaseHolder
=
new
Allocation
[
1
]
;
}
public
synchronized
void
reset
(
)
{
if
(
trimOnReset
)
{
setTargetBufferSize
(
0
)
;
}
}
public
synchronized
void
setTargetBufferSize
(
int
targetBufferSize
)
{
boolean
targetBufferSizeReduced
=
targetBufferSize
<
this
.
targetBufferSize
;
this
.
targetBufferSize
=
targetBufferSize
;
if
(
targetBufferSizeReduced
)
{
trim
(
)
;
}
}
Override
public
synchronized
Allocation
allocate
(
)
{
allocatedCount
+
+
;
Allocation
allocation
;
if
(
availableCount
>
0
)
{
allocation
=
availableAllocations
[
-
-
availableCount
]
;
availableAllocations
[
availableCount
]
=
null
;
}
else
{
allocation
=
new
Allocation
(
new
byte
[
individualAllocationSize
]
0
)
;
}
return
allocation
;
}
Override
public
synchronized
void
release
(
Allocation
allocation
)
{
singleAllocationReleaseHolder
[
0
]
=
allocation
;
release
(
singleAllocationReleaseHolder
)
;
}
Override
public
synchronized
void
release
(
Allocation
[
]
allocations
)
{
if
(
availableCount
+
allocations
.
length
>
=
availableAllocations
.
length
)
{
availableAllocations
=
Arrays
.
copyOf
(
availableAllocations
Math
.
max
(
availableAllocations
.
length
*
2
availableCount
+
allocations
.
length
)
)
;
}
for
(
Allocation
allocation
:
allocations
)
{
availableAllocations
[
availableCount
+
+
]
=
allocation
;
}
allocatedCount
-
=
allocations
.
length
;
notifyAll
(
)
;
}
Override
public
synchronized
void
trim
(
)
{
int
targetAllocationCount
=
Util
.
ceilDivide
(
targetBufferSize
individualAllocationSize
)
;
int
targetAvailableCount
=
Math
.
max
(
0
targetAllocationCount
-
allocatedCount
)
;
if
(
targetAvailableCount
>
=
availableCount
)
{
return
;
}
if
(
initialAllocationBlock
!
=
null
)
{
int
lowIndex
=
0
;
int
highIndex
=
availableCount
-
1
;
while
(
lowIndex
<
=
highIndex
)
{
Allocation
lowAllocation
=
availableAllocations
[
lowIndex
]
;
if
(
lowAllocation
.
data
=
=
initialAllocationBlock
)
{
lowIndex
+
+
;
}
else
{
Allocation
highAllocation
=
availableAllocations
[
highIndex
]
;
if
(
highAllocation
.
data
!
=
initialAllocationBlock
)
{
highIndex
-
-
;
}
else
{
availableAllocations
[
lowIndex
+
+
]
=
highAllocation
;
availableAllocations
[
highIndex
-
-
]
=
lowAllocation
;
}
}
}
targetAvailableCount
=
Math
.
max
(
targetAvailableCount
lowIndex
)
;
if
(
targetAvailableCount
>
=
availableCount
)
{
return
;
}
}
Arrays
.
fill
(
availableAllocations
targetAvailableCount
availableCount
null
)
;
availableCount
=
targetAvailableCount
;
}
Override
public
synchronized
int
getTotalBytesAllocated
(
)
{
return
allocatedCount
*
individualAllocationSize
;
}
Override
public
int
getIndividualAllocationLength
(
)
{
return
individualAllocationSize
;
}
}
