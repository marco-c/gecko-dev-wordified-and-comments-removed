package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
;
import
static
android
.
opengl
.
GLU
.
gluErrorString
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
Context
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
opengl
.
EGL14
;
import
android
.
opengl
.
EGLDisplay
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
android
.
text
.
TextUtils
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlayerLibraryInfo
;
import
java
.
nio
.
Buffer
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
ByteOrder
;
import
java
.
nio
.
FloatBuffer
;
import
java
.
nio
.
IntBuffer
;
import
javax
.
microedition
.
khronos
.
egl
.
EGL10
;
public
final
class
GlUtil
{
public
static
final
class
Attribute
{
public
final
String
name
;
private
final
int
index
;
private
final
int
location
;
Nullable
private
Buffer
buffer
;
private
int
size
;
public
Attribute
(
int
program
int
index
)
{
int
[
]
len
=
new
int
[
1
]
;
GLES20
.
glGetProgramiv
(
program
GLES20
.
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
len
0
)
;
int
[
]
type
=
new
int
[
1
]
;
int
[
]
size
=
new
int
[
1
]
;
byte
[
]
nameBytes
=
new
byte
[
len
[
0
]
]
;
int
[
]
ignore
=
new
int
[
1
]
;
GLES20
.
glGetActiveAttrib
(
program
index
len
[
0
]
ignore
0
size
0
type
0
nameBytes
0
)
;
name
=
new
String
(
nameBytes
0
strlen
(
nameBytes
)
)
;
location
=
GLES20
.
glGetAttribLocation
(
program
name
)
;
this
.
index
=
index
;
}
public
void
setBuffer
(
float
[
]
buffer
int
size
)
{
this
.
buffer
=
createBuffer
(
buffer
)
;
this
.
size
=
size
;
}
public
void
bind
(
)
{
Buffer
buffer
=
Assertions
.
checkNotNull
(
this
.
buffer
"
call
setBuffer
before
bind
"
)
;
GLES20
.
glBindBuffer
(
GLES20
.
GL_ARRAY_BUFFER
0
)
;
GLES20
.
glVertexAttribPointer
(
location
size
GLES20
.
GL_FLOAT
false
0
buffer
)
;
GLES20
.
glEnableVertexAttribArray
(
index
)
;
checkGlError
(
)
;
}
}
public
static
final
class
Uniform
{
public
final
String
name
;
private
final
int
location
;
private
final
int
type
;
private
final
float
[
]
value
;
private
int
texId
;
private
int
unit
;
public
Uniform
(
int
program
int
index
)
{
int
[
]
len
=
new
int
[
1
]
;
GLES20
.
glGetProgramiv
(
program
GLES20
.
GL_ACTIVE_UNIFORM_MAX_LENGTH
len
0
)
;
int
[
]
type
=
new
int
[
1
]
;
int
[
]
size
=
new
int
[
1
]
;
byte
[
]
name
=
new
byte
[
len
[
0
]
]
;
int
[
]
ignore
=
new
int
[
1
]
;
GLES20
.
glGetActiveUniform
(
program
index
len
[
0
]
ignore
0
size
0
type
0
name
0
)
;
this
.
name
=
new
String
(
name
0
strlen
(
name
)
)
;
location
=
GLES20
.
glGetUniformLocation
(
program
this
.
name
)
;
this
.
type
=
type
[
0
]
;
value
=
new
float
[
1
]
;
}
public
void
setSamplerTexId
(
int
texId
int
unit
)
{
this
.
texId
=
texId
;
this
.
unit
=
unit
;
}
public
void
setFloat
(
float
value
)
{
this
.
value
[
0
]
=
value
;
}
public
void
bind
(
)
{
if
(
type
=
=
GLES20
.
GL_FLOAT
)
{
GLES20
.
glUniform1fv
(
location
1
value
0
)
;
checkGlError
(
)
;
return
;
}
if
(
texId
=
=
0
)
{
throw
new
IllegalStateException
(
"
call
setSamplerTexId
before
bind
"
)
;
}
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
+
unit
)
;
if
(
type
=
=
GLES11Ext
.
GL_SAMPLER_EXTERNAL_OES
)
{
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
texId
)
;
}
else
if
(
type
=
=
GLES20
.
GL_SAMPLER_2D
)
{
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
texId
)
;
}
else
{
throw
new
IllegalStateException
(
"
unexpected
uniform
type
:
"
+
type
)
;
}
GLES20
.
glUniform1i
(
location
unit
)
;
GLES20
.
glTexParameteri
(
GLES20
.
GL_TEXTURE_2D
GLES20
.
GL_TEXTURE_MAG_FILTER
GLES20
.
GL_LINEAR
)
;
GLES20
.
glTexParameteri
(
GLES20
.
GL_TEXTURE_2D
GLES20
.
GL_TEXTURE_MIN_FILTER
GLES20
.
GL_LINEAR
)
;
GLES20
.
glTexParameteri
(
GLES20
.
GL_TEXTURE_2D
GLES20
.
GL_TEXTURE_WRAP_S
GLES20
.
GL_CLAMP_TO_EDGE
)
;
GLES20
.
glTexParameteri
(
GLES20
.
GL_TEXTURE_2D
GLES20
.
GL_TEXTURE_WRAP_T
GLES20
.
GL_CLAMP_TO_EDGE
)
;
checkGlError
(
)
;
}
}
private
static
final
String
TAG
=
"
GlUtil
"
;
private
static
final
String
EXTENSION_PROTECTED_CONTENT
=
"
EGL_EXT_protected_content
"
;
private
static
final
String
EXTENSION_SURFACELESS_CONTEXT
=
"
EGL_KHR_surfaceless_context
"
;
private
GlUtil
(
)
{
}
TargetApi
(
24
)
public
static
boolean
isProtectedContentExtensionSupported
(
Context
context
)
{
if
(
Util
.
SDK_INT
<
24
)
{
return
false
;
}
if
(
Util
.
SDK_INT
<
26
&
&
(
"
samsung
"
.
equals
(
Util
.
MANUFACTURER
)
|
|
"
XT1650
"
.
equals
(
Util
.
MODEL
)
)
)
{
return
false
;
}
if
(
Util
.
SDK_INT
<
26
&
&
!
context
.
getPackageManager
(
)
.
hasSystemFeature
(
PackageManager
.
FEATURE_VR_MODE_HIGH_PERFORMANCE
)
)
{
return
false
;
}
EGLDisplay
display
=
EGL14
.
eglGetDisplay
(
EGL14
.
EGL_DEFAULT_DISPLAY
)
;
Nullable
String
eglExtensions
=
EGL14
.
eglQueryString
(
display
EGL10
.
EGL_EXTENSIONS
)
;
return
eglExtensions
!
=
null
&
&
eglExtensions
.
contains
(
EXTENSION_PROTECTED_CONTENT
)
;
}
TargetApi
(
17
)
public
static
boolean
isSurfacelessContextExtensionSupported
(
)
{
if
(
Util
.
SDK_INT
<
17
)
{
return
false
;
}
EGLDisplay
display
=
EGL14
.
eglGetDisplay
(
EGL14
.
EGL_DEFAULT_DISPLAY
)
;
Nullable
String
eglExtensions
=
EGL14
.
eglQueryString
(
display
EGL10
.
EGL_EXTENSIONS
)
;
return
eglExtensions
!
=
null
&
&
eglExtensions
.
contains
(
EXTENSION_SURFACELESS_CONTEXT
)
;
}
public
static
void
checkGlError
(
)
{
int
lastError
=
GLES20
.
GL_NO_ERROR
;
int
error
;
while
(
(
error
=
GLES20
.
glGetError
(
)
)
!
=
GLES20
.
GL_NO_ERROR
)
{
Log
.
e
(
TAG
"
glError
"
+
gluErrorString
(
error
)
)
;
lastError
=
error
;
}
if
(
ExoPlayerLibraryInfo
.
GL_ASSERTIONS_ENABLED
&
&
lastError
!
=
GLES20
.
GL_NO_ERROR
)
{
throw
new
RuntimeException
(
"
glError
"
+
gluErrorString
(
lastError
)
)
;
}
}
public
static
int
compileProgram
(
String
[
]
vertexCode
String
[
]
fragmentCode
)
{
return
compileProgram
(
TextUtils
.
join
(
"
\
n
"
vertexCode
)
TextUtils
.
join
(
"
\
n
"
fragmentCode
)
)
;
}
public
static
int
compileProgram
(
String
vertexCode
String
fragmentCode
)
{
int
program
=
GLES20
.
glCreateProgram
(
)
;
checkGlError
(
)
;
addShader
(
GLES20
.
GL_VERTEX_SHADER
vertexCode
program
)
;
addShader
(
GLES20
.
GL_FRAGMENT_SHADER
fragmentCode
program
)
;
GLES20
.
glLinkProgram
(
program
)
;
int
[
]
linkStatus
=
new
int
[
]
{
GLES20
.
GL_FALSE
}
;
GLES20
.
glGetProgramiv
(
program
GLES20
.
GL_LINK_STATUS
linkStatus
0
)
;
if
(
linkStatus
[
0
]
!
=
GLES20
.
GL_TRUE
)
{
throwGlError
(
"
Unable
to
link
shader
program
:
\
n
"
+
GLES20
.
glGetProgramInfoLog
(
program
)
)
;
}
checkGlError
(
)
;
return
program
;
}
public
static
Attribute
[
]
getAttributes
(
int
program
)
{
int
[
]
attributeCount
=
new
int
[
1
]
;
GLES20
.
glGetProgramiv
(
program
GLES20
.
GL_ACTIVE_ATTRIBUTES
attributeCount
0
)
;
if
(
attributeCount
[
0
]
!
=
2
)
{
throw
new
IllegalStateException
(
"
expected
two
attributes
"
)
;
}
Attribute
[
]
attributes
=
new
Attribute
[
attributeCount
[
0
]
]
;
for
(
int
i
=
0
;
i
<
attributeCount
[
0
]
;
i
+
+
)
{
attributes
[
i
]
=
new
Attribute
(
program
i
)
;
}
return
attributes
;
}
public
static
Uniform
[
]
getUniforms
(
int
program
)
{
int
[
]
uniformCount
=
new
int
[
1
]
;
GLES20
.
glGetProgramiv
(
program
GLES20
.
GL_ACTIVE_UNIFORMS
uniformCount
0
)
;
Uniform
[
]
uniforms
=
new
Uniform
[
uniformCount
[
0
]
]
;
for
(
int
i
=
0
;
i
<
uniformCount
[
0
]
;
i
+
+
)
{
uniforms
[
i
]
=
new
Uniform
(
program
i
)
;
}
return
uniforms
;
}
public
static
FloatBuffer
createBuffer
(
float
[
]
data
)
{
return
(
FloatBuffer
)
createBuffer
(
data
.
length
)
.
put
(
data
)
.
flip
(
)
;
}
public
static
FloatBuffer
createBuffer
(
int
capacity
)
{
ByteBuffer
byteBuffer
=
ByteBuffer
.
allocateDirect
(
capacity
*
C
.
BYTES_PER_FLOAT
)
;
return
byteBuffer
.
order
(
ByteOrder
.
nativeOrder
(
)
)
.
asFloatBuffer
(
)
;
}
public
static
int
createExternalTexture
(
)
{
int
[
]
texId
=
new
int
[
1
]
;
GLES20
.
glGenTextures
(
1
IntBuffer
.
wrap
(
texId
)
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
texId
[
0
]
)
;
GLES20
.
glTexParameteri
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_MIN_FILTER
GLES20
.
GL_LINEAR
)
;
GLES20
.
glTexParameteri
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_MAG_FILTER
GLES20
.
GL_LINEAR
)
;
GLES20
.
glTexParameteri
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_WRAP_S
GLES20
.
GL_CLAMP_TO_EDGE
)
;
GLES20
.
glTexParameteri
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_WRAP_T
GLES20
.
GL_CLAMP_TO_EDGE
)
;
checkGlError
(
)
;
return
texId
[
0
]
;
}
private
static
void
addShader
(
int
type
String
source
int
program
)
{
int
shader
=
GLES20
.
glCreateShader
(
type
)
;
GLES20
.
glShaderSource
(
shader
source
)
;
GLES20
.
glCompileShader
(
shader
)
;
int
[
]
result
=
new
int
[
]
{
GLES20
.
GL_FALSE
}
;
GLES20
.
glGetShaderiv
(
shader
GLES20
.
GL_COMPILE_STATUS
result
0
)
;
if
(
result
[
0
]
!
=
GLES20
.
GL_TRUE
)
{
throwGlError
(
GLES20
.
glGetShaderInfoLog
(
shader
)
+
"
source
:
"
+
source
)
;
}
GLES20
.
glAttachShader
(
program
shader
)
;
GLES20
.
glDeleteShader
(
shader
)
;
checkGlError
(
)
;
}
private
static
void
throwGlError
(
String
errorMsg
)
{
Log
.
e
(
TAG
errorMsg
)
;
if
(
ExoPlayerLibraryInfo
.
GL_ASSERTIONS_ENABLED
)
{
throw
new
RuntimeException
(
errorMsg
)
;
}
}
private
static
int
strlen
(
byte
[
]
strVal
)
{
for
(
int
i
=
0
;
i
<
strVal
.
length
;
+
+
i
)
{
if
(
strVal
[
i
]
=
=
'
\
0
'
)
{
return
i
;
}
}
return
strVal
.
length
;
}
}
