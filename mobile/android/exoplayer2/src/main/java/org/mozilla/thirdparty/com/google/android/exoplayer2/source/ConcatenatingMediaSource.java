package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Message
;
import
androidx
.
annotation
.
GuardedBy
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Timeline
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
ConcatenatingMediaSource
.
MediaSourceHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
ShuffleOrder
.
DefaultShuffleOrder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
TransferListener
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
IdentityHashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
public
final
class
ConcatenatingMediaSource
extends
CompositeMediaSource
<
MediaSourceHolder
>
{
private
static
final
int
MSG_ADD
=
0
;
private
static
final
int
MSG_REMOVE
=
1
;
private
static
final
int
MSG_MOVE
=
2
;
private
static
final
int
MSG_SET_SHUFFLE_ORDER
=
3
;
private
static
final
int
MSG_UPDATE_TIMELINE
=
4
;
private
static
final
int
MSG_ON_COMPLETION
=
5
;
GuardedBy
(
"
this
"
)
private
final
List
<
MediaSourceHolder
>
mediaSourcesPublic
;
GuardedBy
(
"
this
"
)
private
final
Set
<
HandlerAndRunnable
>
pendingOnCompletionActions
;
GuardedBy
(
"
this
"
)
Nullable
private
Handler
playbackThreadHandler
;
private
final
List
<
MediaSourceHolder
>
mediaSourceHolders
;
private
final
Map
<
MediaPeriod
MediaSourceHolder
>
mediaSourceByMediaPeriod
;
private
final
Map
<
Object
MediaSourceHolder
>
mediaSourceByUid
;
private
final
Set
<
MediaSourceHolder
>
enabledMediaSourceHolders
;
private
final
boolean
isAtomic
;
private
final
boolean
useLazyPreparation
;
private
boolean
timelineUpdateScheduled
;
private
Set
<
HandlerAndRunnable
>
nextTimelineUpdateOnCompletionActions
;
private
ShuffleOrder
shuffleOrder
;
public
ConcatenatingMediaSource
(
MediaSource
.
.
.
mediaSources
)
{
this
(
false
mediaSources
)
;
}
public
ConcatenatingMediaSource
(
boolean
isAtomic
MediaSource
.
.
.
mediaSources
)
{
this
(
isAtomic
new
DefaultShuffleOrder
(
0
)
mediaSources
)
;
}
public
ConcatenatingMediaSource
(
boolean
isAtomic
ShuffleOrder
shuffleOrder
MediaSource
.
.
.
mediaSources
)
{
this
(
isAtomic
false
shuffleOrder
mediaSources
)
;
}
SuppressWarnings
(
"
initialization
"
)
public
ConcatenatingMediaSource
(
boolean
isAtomic
boolean
useLazyPreparation
ShuffleOrder
shuffleOrder
MediaSource
.
.
.
mediaSources
)
{
for
(
MediaSource
mediaSource
:
mediaSources
)
{
Assertions
.
checkNotNull
(
mediaSource
)
;
}
this
.
shuffleOrder
=
shuffleOrder
.
getLength
(
)
>
0
?
shuffleOrder
.
cloneAndClear
(
)
:
shuffleOrder
;
this
.
mediaSourceByMediaPeriod
=
new
IdentityHashMap
<
>
(
)
;
this
.
mediaSourceByUid
=
new
HashMap
<
>
(
)
;
this
.
mediaSourcesPublic
=
new
ArrayList
<
>
(
)
;
this
.
mediaSourceHolders
=
new
ArrayList
<
>
(
)
;
this
.
nextTimelineUpdateOnCompletionActions
=
new
HashSet
<
>
(
)
;
this
.
pendingOnCompletionActions
=
new
HashSet
<
>
(
)
;
this
.
enabledMediaSourceHolders
=
new
HashSet
<
>
(
)
;
this
.
isAtomic
=
isAtomic
;
this
.
useLazyPreparation
=
useLazyPreparation
;
addMediaSources
(
Arrays
.
asList
(
mediaSources
)
)
;
}
public
synchronized
void
addMediaSource
(
MediaSource
mediaSource
)
{
addMediaSource
(
mediaSourcesPublic
.
size
(
)
mediaSource
)
;
}
public
synchronized
void
addMediaSource
(
MediaSource
mediaSource
Handler
handler
Runnable
onCompletionAction
)
{
addMediaSource
(
mediaSourcesPublic
.
size
(
)
mediaSource
handler
onCompletionAction
)
;
}
public
synchronized
void
addMediaSource
(
int
index
MediaSource
mediaSource
)
{
addPublicMediaSources
(
index
Collections
.
singletonList
(
mediaSource
)
null
null
)
;
}
public
synchronized
void
addMediaSource
(
int
index
MediaSource
mediaSource
Handler
handler
Runnable
onCompletionAction
)
{
addPublicMediaSources
(
index
Collections
.
singletonList
(
mediaSource
)
handler
onCompletionAction
)
;
}
public
synchronized
void
addMediaSources
(
Collection
<
MediaSource
>
mediaSources
)
{
addPublicMediaSources
(
mediaSourcesPublic
.
size
(
)
mediaSources
null
null
)
;
}
public
synchronized
void
addMediaSources
(
Collection
<
MediaSource
>
mediaSources
Handler
handler
Runnable
onCompletionAction
)
{
addPublicMediaSources
(
mediaSourcesPublic
.
size
(
)
mediaSources
handler
onCompletionAction
)
;
}
public
synchronized
void
addMediaSources
(
int
index
Collection
<
MediaSource
>
mediaSources
)
{
addPublicMediaSources
(
index
mediaSources
null
null
)
;
}
public
synchronized
void
addMediaSources
(
int
index
Collection
<
MediaSource
>
mediaSources
Handler
handler
Runnable
onCompletionAction
)
{
addPublicMediaSources
(
index
mediaSources
handler
onCompletionAction
)
;
}
public
synchronized
MediaSource
removeMediaSource
(
int
index
)
{
MediaSource
removedMediaSource
=
getMediaSource
(
index
)
;
removePublicMediaSources
(
index
index
+
1
null
null
)
;
return
removedMediaSource
;
}
public
synchronized
MediaSource
removeMediaSource
(
int
index
Handler
handler
Runnable
onCompletionAction
)
{
MediaSource
removedMediaSource
=
getMediaSource
(
index
)
;
removePublicMediaSources
(
index
index
+
1
handler
onCompletionAction
)
;
return
removedMediaSource
;
}
public
synchronized
void
removeMediaSourceRange
(
int
fromIndex
int
toIndex
)
{
removePublicMediaSources
(
fromIndex
toIndex
null
null
)
;
}
public
synchronized
void
removeMediaSourceRange
(
int
fromIndex
int
toIndex
Handler
handler
Runnable
onCompletionAction
)
{
removePublicMediaSources
(
fromIndex
toIndex
handler
onCompletionAction
)
;
}
public
synchronized
void
moveMediaSource
(
int
currentIndex
int
newIndex
)
{
movePublicMediaSource
(
currentIndex
newIndex
null
null
)
;
}
public
synchronized
void
moveMediaSource
(
int
currentIndex
int
newIndex
Handler
handler
Runnable
onCompletionAction
)
{
movePublicMediaSource
(
currentIndex
newIndex
handler
onCompletionAction
)
;
}
public
synchronized
void
clear
(
)
{
removeMediaSourceRange
(
0
getSize
(
)
)
;
}
public
synchronized
void
clear
(
Handler
handler
Runnable
onCompletionAction
)
{
removeMediaSourceRange
(
0
getSize
(
)
handler
onCompletionAction
)
;
}
public
synchronized
int
getSize
(
)
{
return
mediaSourcesPublic
.
size
(
)
;
}
public
synchronized
MediaSource
getMediaSource
(
int
index
)
{
return
mediaSourcesPublic
.
get
(
index
)
.
mediaSource
;
}
public
synchronized
void
setShuffleOrder
(
ShuffleOrder
shuffleOrder
)
{
setPublicShuffleOrder
(
shuffleOrder
null
null
)
;
}
public
synchronized
void
setShuffleOrder
(
ShuffleOrder
shuffleOrder
Handler
handler
Runnable
onCompletionAction
)
{
setPublicShuffleOrder
(
shuffleOrder
handler
onCompletionAction
)
;
}
Override
Nullable
public
Object
getTag
(
)
{
return
null
;
}
Override
protected
synchronized
void
prepareSourceInternal
(
Nullable
TransferListener
mediaTransferListener
)
{
super
.
prepareSourceInternal
(
mediaTransferListener
)
;
playbackThreadHandler
=
new
Handler
(
this
:
:
handleMessage
)
;
if
(
mediaSourcesPublic
.
isEmpty
(
)
)
{
updateTimelineAndScheduleOnCompletionActions
(
)
;
}
else
{
shuffleOrder
=
shuffleOrder
.
cloneAndInsert
(
0
mediaSourcesPublic
.
size
(
)
)
;
addMediaSourcesInternal
(
0
mediaSourcesPublic
)
;
scheduleTimelineUpdate
(
)
;
}
}
SuppressWarnings
(
"
MissingSuperCall
"
)
Override
protected
void
enableInternal
(
)
{
}
Override
public
MediaPeriod
createPeriod
(
MediaPeriodId
id
Allocator
allocator
long
startPositionUs
)
{
Object
mediaSourceHolderUid
=
getMediaSourceHolderUid
(
id
.
periodUid
)
;
MediaPeriodId
childMediaPeriodId
=
id
.
copyWithPeriodUid
(
getChildPeriodUid
(
id
.
periodUid
)
)
;
MediaSourceHolder
holder
=
mediaSourceByUid
.
get
(
mediaSourceHolderUid
)
;
if
(
holder
=
=
null
)
{
holder
=
new
MediaSourceHolder
(
new
DummyMediaSource
(
)
useLazyPreparation
)
;
holder
.
isRemoved
=
true
;
prepareChildSource
(
holder
holder
.
mediaSource
)
;
}
enableMediaSource
(
holder
)
;
holder
.
activeMediaPeriodIds
.
add
(
childMediaPeriodId
)
;
MediaPeriod
mediaPeriod
=
holder
.
mediaSource
.
createPeriod
(
childMediaPeriodId
allocator
startPositionUs
)
;
mediaSourceByMediaPeriod
.
put
(
mediaPeriod
holder
)
;
disableUnusedMediaSources
(
)
;
return
mediaPeriod
;
}
Override
public
void
releasePeriod
(
MediaPeriod
mediaPeriod
)
{
MediaSourceHolder
holder
=
Assertions
.
checkNotNull
(
mediaSourceByMediaPeriod
.
remove
(
mediaPeriod
)
)
;
holder
.
mediaSource
.
releasePeriod
(
mediaPeriod
)
;
holder
.
activeMediaPeriodIds
.
remove
(
(
(
MaskingMediaPeriod
)
mediaPeriod
)
.
id
)
;
if
(
!
mediaSourceByMediaPeriod
.
isEmpty
(
)
)
{
disableUnusedMediaSources
(
)
;
}
maybeReleaseChildSource
(
holder
)
;
}
Override
protected
void
disableInternal
(
)
{
super
.
disableInternal
(
)
;
enabledMediaSourceHolders
.
clear
(
)
;
}
Override
protected
synchronized
void
releaseSourceInternal
(
)
{
super
.
releaseSourceInternal
(
)
;
mediaSourceHolders
.
clear
(
)
;
enabledMediaSourceHolders
.
clear
(
)
;
mediaSourceByUid
.
clear
(
)
;
shuffleOrder
=
shuffleOrder
.
cloneAndClear
(
)
;
if
(
playbackThreadHandler
!
=
null
)
{
playbackThreadHandler
.
removeCallbacksAndMessages
(
null
)
;
playbackThreadHandler
=
null
;
}
timelineUpdateScheduled
=
false
;
nextTimelineUpdateOnCompletionActions
.
clear
(
)
;
dispatchOnCompletionActions
(
pendingOnCompletionActions
)
;
}
Override
protected
void
onChildSourceInfoRefreshed
(
MediaSourceHolder
mediaSourceHolder
MediaSource
mediaSource
Timeline
timeline
)
{
updateMediaSourceInternal
(
mediaSourceHolder
timeline
)
;
}
Override
Nullable
protected
MediaPeriodId
getMediaPeriodIdForChildMediaPeriodId
(
MediaSourceHolder
mediaSourceHolder
MediaPeriodId
mediaPeriodId
)
{
for
(
int
i
=
0
;
i
<
mediaSourceHolder
.
activeMediaPeriodIds
.
size
(
)
;
i
+
+
)
{
if
(
mediaSourceHolder
.
activeMediaPeriodIds
.
get
(
i
)
.
windowSequenceNumber
=
=
mediaPeriodId
.
windowSequenceNumber
)
{
Object
periodUid
=
getPeriodUid
(
mediaSourceHolder
mediaPeriodId
.
periodUid
)
;
return
mediaPeriodId
.
copyWithPeriodUid
(
periodUid
)
;
}
}
return
null
;
}
Override
protected
int
getWindowIndexForChildWindowIndex
(
MediaSourceHolder
mediaSourceHolder
int
windowIndex
)
{
return
windowIndex
+
mediaSourceHolder
.
firstWindowIndexInChild
;
}
GuardedBy
(
"
this
"
)
private
void
addPublicMediaSources
(
int
index
Collection
<
MediaSource
>
mediaSources
Nullable
Handler
handler
Nullable
Runnable
onCompletionAction
)
{
Assertions
.
checkArgument
(
(
handler
=
=
null
)
=
=
(
onCompletionAction
=
=
null
)
)
;
Handler
playbackThreadHandler
=
this
.
playbackThreadHandler
;
for
(
MediaSource
mediaSource
:
mediaSources
)
{
Assertions
.
checkNotNull
(
mediaSource
)
;
}
List
<
MediaSourceHolder
>
mediaSourceHolders
=
new
ArrayList
<
>
(
mediaSources
.
size
(
)
)
;
for
(
MediaSource
mediaSource
:
mediaSources
)
{
mediaSourceHolders
.
add
(
new
MediaSourceHolder
(
mediaSource
useLazyPreparation
)
)
;
}
mediaSourcesPublic
.
addAll
(
index
mediaSourceHolders
)
;
if
(
playbackThreadHandler
!
=
null
&
&
!
mediaSources
.
isEmpty
(
)
)
{
HandlerAndRunnable
callbackAction
=
createOnCompletionAction
(
handler
onCompletionAction
)
;
playbackThreadHandler
.
obtainMessage
(
MSG_ADD
new
MessageData
<
>
(
index
mediaSourceHolders
callbackAction
)
)
.
sendToTarget
(
)
;
}
else
if
(
onCompletionAction
!
=
null
&
&
handler
!
=
null
)
{
handler
.
post
(
onCompletionAction
)
;
}
}
GuardedBy
(
"
this
"
)
private
void
removePublicMediaSources
(
int
fromIndex
int
toIndex
Nullable
Handler
handler
Nullable
Runnable
onCompletionAction
)
{
Assertions
.
checkArgument
(
(
handler
=
=
null
)
=
=
(
onCompletionAction
=
=
null
)
)
;
Handler
playbackThreadHandler
=
this
.
playbackThreadHandler
;
Util
.
removeRange
(
mediaSourcesPublic
fromIndex
toIndex
)
;
if
(
playbackThreadHandler
!
=
null
)
{
HandlerAndRunnable
callbackAction
=
createOnCompletionAction
(
handler
onCompletionAction
)
;
playbackThreadHandler
.
obtainMessage
(
MSG_REMOVE
new
MessageData
<
>
(
fromIndex
toIndex
callbackAction
)
)
.
sendToTarget
(
)
;
}
else
if
(
onCompletionAction
!
=
null
&
&
handler
!
=
null
)
{
handler
.
post
(
onCompletionAction
)
;
}
}
GuardedBy
(
"
this
"
)
private
void
movePublicMediaSource
(
int
currentIndex
int
newIndex
Nullable
Handler
handler
Nullable
Runnable
onCompletionAction
)
{
Assertions
.
checkArgument
(
(
handler
=
=
null
)
=
=
(
onCompletionAction
=
=
null
)
)
;
Handler
playbackThreadHandler
=
this
.
playbackThreadHandler
;
mediaSourcesPublic
.
add
(
newIndex
mediaSourcesPublic
.
remove
(
currentIndex
)
)
;
if
(
playbackThreadHandler
!
=
null
)
{
HandlerAndRunnable
callbackAction
=
createOnCompletionAction
(
handler
onCompletionAction
)
;
playbackThreadHandler
.
obtainMessage
(
MSG_MOVE
new
MessageData
<
>
(
currentIndex
newIndex
callbackAction
)
)
.
sendToTarget
(
)
;
}
else
if
(
onCompletionAction
!
=
null
&
&
handler
!
=
null
)
{
handler
.
post
(
onCompletionAction
)
;
}
}
GuardedBy
(
"
this
"
)
private
void
setPublicShuffleOrder
(
ShuffleOrder
shuffleOrder
Nullable
Handler
handler
Nullable
Runnable
onCompletionAction
)
{
Assertions
.
checkArgument
(
(
handler
=
=
null
)
=
=
(
onCompletionAction
=
=
null
)
)
;
Handler
playbackThreadHandler
=
this
.
playbackThreadHandler
;
if
(
playbackThreadHandler
!
=
null
)
{
int
size
=
getSize
(
)
;
if
(
shuffleOrder
.
getLength
(
)
!
=
size
)
{
shuffleOrder
=
shuffleOrder
.
cloneAndClear
(
)
.
cloneAndInsert
(
0
size
)
;
}
HandlerAndRunnable
callbackAction
=
createOnCompletionAction
(
handler
onCompletionAction
)
;
playbackThreadHandler
.
obtainMessage
(
MSG_SET_SHUFFLE_ORDER
new
MessageData
<
>
(
0
shuffleOrder
callbackAction
)
)
.
sendToTarget
(
)
;
}
else
{
this
.
shuffleOrder
=
shuffleOrder
.
getLength
(
)
>
0
?
shuffleOrder
.
cloneAndClear
(
)
:
shuffleOrder
;
if
(
onCompletionAction
!
=
null
&
&
handler
!
=
null
)
{
handler
.
post
(
onCompletionAction
)
;
}
}
}
GuardedBy
(
"
this
"
)
Nullable
private
HandlerAndRunnable
createOnCompletionAction
(
Nullable
Handler
handler
Nullable
Runnable
runnable
)
{
if
(
handler
=
=
null
|
|
runnable
=
=
null
)
{
return
null
;
}
HandlerAndRunnable
handlerAndRunnable
=
new
HandlerAndRunnable
(
handler
runnable
)
;
pendingOnCompletionActions
.
add
(
handlerAndRunnable
)
;
return
handlerAndRunnable
;
}
SuppressWarnings
(
"
unchecked
"
)
private
boolean
handleMessage
(
Message
msg
)
{
switch
(
msg
.
what
)
{
case
MSG_ADD
:
MessageData
<
Collection
<
MediaSourceHolder
>
>
addMessage
=
(
MessageData
<
Collection
<
MediaSourceHolder
>
>
)
Util
.
castNonNull
(
msg
.
obj
)
;
shuffleOrder
=
shuffleOrder
.
cloneAndInsert
(
addMessage
.
index
addMessage
.
customData
.
size
(
)
)
;
addMediaSourcesInternal
(
addMessage
.
index
addMessage
.
customData
)
;
scheduleTimelineUpdate
(
addMessage
.
onCompletionAction
)
;
break
;
case
MSG_REMOVE
:
MessageData
<
Integer
>
removeMessage
=
(
MessageData
<
Integer
>
)
Util
.
castNonNull
(
msg
.
obj
)
;
int
fromIndex
=
removeMessage
.
index
;
int
toIndex
=
removeMessage
.
customData
;
if
(
fromIndex
=
=
0
&
&
toIndex
=
=
shuffleOrder
.
getLength
(
)
)
{
shuffleOrder
=
shuffleOrder
.
cloneAndClear
(
)
;
}
else
{
shuffleOrder
=
shuffleOrder
.
cloneAndRemove
(
fromIndex
toIndex
)
;
}
for
(
int
index
=
toIndex
-
1
;
index
>
=
fromIndex
;
index
-
-
)
{
removeMediaSourceInternal
(
index
)
;
}
scheduleTimelineUpdate
(
removeMessage
.
onCompletionAction
)
;
break
;
case
MSG_MOVE
:
MessageData
<
Integer
>
moveMessage
=
(
MessageData
<
Integer
>
)
Util
.
castNonNull
(
msg
.
obj
)
;
shuffleOrder
=
shuffleOrder
.
cloneAndRemove
(
moveMessage
.
index
moveMessage
.
index
+
1
)
;
shuffleOrder
=
shuffleOrder
.
cloneAndInsert
(
moveMessage
.
customData
1
)
;
moveMediaSourceInternal
(
moveMessage
.
index
moveMessage
.
customData
)
;
scheduleTimelineUpdate
(
moveMessage
.
onCompletionAction
)
;
break
;
case
MSG_SET_SHUFFLE_ORDER
:
MessageData
<
ShuffleOrder
>
shuffleOrderMessage
=
(
MessageData
<
ShuffleOrder
>
)
Util
.
castNonNull
(
msg
.
obj
)
;
shuffleOrder
=
shuffleOrderMessage
.
customData
;
scheduleTimelineUpdate
(
shuffleOrderMessage
.
onCompletionAction
)
;
break
;
case
MSG_UPDATE_TIMELINE
:
updateTimelineAndScheduleOnCompletionActions
(
)
;
break
;
case
MSG_ON_COMPLETION
:
Set
<
HandlerAndRunnable
>
actions
=
(
Set
<
HandlerAndRunnable
>
)
Util
.
castNonNull
(
msg
.
obj
)
;
dispatchOnCompletionActions
(
actions
)
;
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
return
true
;
}
private
void
scheduleTimelineUpdate
(
)
{
scheduleTimelineUpdate
(
null
)
;
}
private
void
scheduleTimelineUpdate
(
Nullable
HandlerAndRunnable
onCompletionAction
)
{
if
(
!
timelineUpdateScheduled
)
{
getPlaybackThreadHandlerOnPlaybackThread
(
)
.
obtainMessage
(
MSG_UPDATE_TIMELINE
)
.
sendToTarget
(
)
;
timelineUpdateScheduled
=
true
;
}
if
(
onCompletionAction
!
=
null
)
{
nextTimelineUpdateOnCompletionActions
.
add
(
onCompletionAction
)
;
}
}
private
void
updateTimelineAndScheduleOnCompletionActions
(
)
{
timelineUpdateScheduled
=
false
;
Set
<
HandlerAndRunnable
>
onCompletionActions
=
nextTimelineUpdateOnCompletionActions
;
nextTimelineUpdateOnCompletionActions
=
new
HashSet
<
>
(
)
;
refreshSourceInfo
(
new
ConcatenatedTimeline
(
mediaSourceHolders
shuffleOrder
isAtomic
)
)
;
getPlaybackThreadHandlerOnPlaybackThread
(
)
.
obtainMessage
(
MSG_ON_COMPLETION
onCompletionActions
)
.
sendToTarget
(
)
;
}
SuppressWarnings
(
"
GuardedBy
"
)
private
Handler
getPlaybackThreadHandlerOnPlaybackThread
(
)
{
return
Assertions
.
checkNotNull
(
playbackThreadHandler
)
;
}
private
synchronized
void
dispatchOnCompletionActions
(
Set
<
HandlerAndRunnable
>
onCompletionActions
)
{
for
(
HandlerAndRunnable
pendingAction
:
onCompletionActions
)
{
pendingAction
.
dispatch
(
)
;
}
pendingOnCompletionActions
.
removeAll
(
onCompletionActions
)
;
}
private
void
addMediaSourcesInternal
(
int
index
Collection
<
MediaSourceHolder
>
mediaSourceHolders
)
{
for
(
MediaSourceHolder
mediaSourceHolder
:
mediaSourceHolders
)
{
addMediaSourceInternal
(
index
+
+
mediaSourceHolder
)
;
}
}
private
void
addMediaSourceInternal
(
int
newIndex
MediaSourceHolder
newMediaSourceHolder
)
{
if
(
newIndex
>
0
)
{
MediaSourceHolder
previousHolder
=
mediaSourceHolders
.
get
(
newIndex
-
1
)
;
Timeline
previousTimeline
=
previousHolder
.
mediaSource
.
getTimeline
(
)
;
newMediaSourceHolder
.
reset
(
newIndex
previousHolder
.
firstWindowIndexInChild
+
previousTimeline
.
getWindowCount
(
)
)
;
}
else
{
newMediaSourceHolder
.
reset
(
newIndex
0
)
;
}
Timeline
newTimeline
=
newMediaSourceHolder
.
mediaSource
.
getTimeline
(
)
;
correctOffsets
(
newIndex
1
newTimeline
.
getWindowCount
(
)
)
;
mediaSourceHolders
.
add
(
newIndex
newMediaSourceHolder
)
;
mediaSourceByUid
.
put
(
newMediaSourceHolder
.
uid
newMediaSourceHolder
)
;
prepareChildSource
(
newMediaSourceHolder
newMediaSourceHolder
.
mediaSource
)
;
if
(
isEnabled
(
)
&
&
mediaSourceByMediaPeriod
.
isEmpty
(
)
)
{
enabledMediaSourceHolders
.
add
(
newMediaSourceHolder
)
;
}
else
{
disableChildSource
(
newMediaSourceHolder
)
;
}
}
private
void
updateMediaSourceInternal
(
MediaSourceHolder
mediaSourceHolder
Timeline
timeline
)
{
if
(
mediaSourceHolder
=
=
null
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
mediaSourceHolder
.
childIndex
+
1
<
mediaSourceHolders
.
size
(
)
)
{
MediaSourceHolder
nextHolder
=
mediaSourceHolders
.
get
(
mediaSourceHolder
.
childIndex
+
1
)
;
int
windowOffsetUpdate
=
timeline
.
getWindowCount
(
)
-
(
nextHolder
.
firstWindowIndexInChild
-
mediaSourceHolder
.
firstWindowIndexInChild
)
;
if
(
windowOffsetUpdate
!
=
0
)
{
correctOffsets
(
mediaSourceHolder
.
childIndex
+
1
0
windowOffsetUpdate
)
;
}
}
scheduleTimelineUpdate
(
)
;
}
private
void
removeMediaSourceInternal
(
int
index
)
{
MediaSourceHolder
holder
=
mediaSourceHolders
.
remove
(
index
)
;
mediaSourceByUid
.
remove
(
holder
.
uid
)
;
Timeline
oldTimeline
=
holder
.
mediaSource
.
getTimeline
(
)
;
correctOffsets
(
index
-
1
-
oldTimeline
.
getWindowCount
(
)
)
;
holder
.
isRemoved
=
true
;
maybeReleaseChildSource
(
holder
)
;
}
private
void
moveMediaSourceInternal
(
int
currentIndex
int
newIndex
)
{
int
startIndex
=
Math
.
min
(
currentIndex
newIndex
)
;
int
endIndex
=
Math
.
max
(
currentIndex
newIndex
)
;
int
windowOffset
=
mediaSourceHolders
.
get
(
startIndex
)
.
firstWindowIndexInChild
;
mediaSourceHolders
.
add
(
newIndex
mediaSourceHolders
.
remove
(
currentIndex
)
)
;
for
(
int
i
=
startIndex
;
i
<
=
endIndex
;
i
+
+
)
{
MediaSourceHolder
holder
=
mediaSourceHolders
.
get
(
i
)
;
holder
.
childIndex
=
i
;
holder
.
firstWindowIndexInChild
=
windowOffset
;
windowOffset
+
=
holder
.
mediaSource
.
getTimeline
(
)
.
getWindowCount
(
)
;
}
}
private
void
correctOffsets
(
int
startIndex
int
childIndexUpdate
int
windowOffsetUpdate
)
{
for
(
int
i
=
startIndex
;
i
<
mediaSourceHolders
.
size
(
)
;
i
+
+
)
{
MediaSourceHolder
holder
=
mediaSourceHolders
.
get
(
i
)
;
holder
.
childIndex
+
=
childIndexUpdate
;
holder
.
firstWindowIndexInChild
+
=
windowOffsetUpdate
;
}
}
private
void
maybeReleaseChildSource
(
MediaSourceHolder
mediaSourceHolder
)
{
if
(
mediaSourceHolder
.
isRemoved
&
&
mediaSourceHolder
.
activeMediaPeriodIds
.
isEmpty
(
)
)
{
enabledMediaSourceHolders
.
remove
(
mediaSourceHolder
)
;
releaseChildSource
(
mediaSourceHolder
)
;
}
}
private
void
enableMediaSource
(
MediaSourceHolder
mediaSourceHolder
)
{
enabledMediaSourceHolders
.
add
(
mediaSourceHolder
)
;
enableChildSource
(
mediaSourceHolder
)
;
}
private
void
disableUnusedMediaSources
(
)
{
Iterator
<
MediaSourceHolder
>
iterator
=
enabledMediaSourceHolders
.
iterator
(
)
;
while
(
iterator
.
hasNext
(
)
)
{
MediaSourceHolder
holder
=
iterator
.
next
(
)
;
if
(
holder
.
activeMediaPeriodIds
.
isEmpty
(
)
)
{
disableChildSource
(
holder
)
;
iterator
.
remove
(
)
;
}
}
}
private
static
Object
getMediaSourceHolderUid
(
Object
periodUid
)
{
return
ConcatenatedTimeline
.
getChildTimelineUidFromConcatenatedUid
(
periodUid
)
;
}
private
static
Object
getChildPeriodUid
(
Object
periodUid
)
{
return
ConcatenatedTimeline
.
getChildPeriodUidFromConcatenatedUid
(
periodUid
)
;
}
private
static
Object
getPeriodUid
(
MediaSourceHolder
holder
Object
childPeriodUid
)
{
return
ConcatenatedTimeline
.
getConcatenatedUid
(
holder
.
uid
childPeriodUid
)
;
}
static
final
class
MediaSourceHolder
{
public
final
MaskingMediaSource
mediaSource
;
public
final
Object
uid
;
public
final
List
<
MediaPeriodId
>
activeMediaPeriodIds
;
public
int
childIndex
;
public
int
firstWindowIndexInChild
;
public
boolean
isRemoved
;
public
MediaSourceHolder
(
MediaSource
mediaSource
boolean
useLazyPreparation
)
{
this
.
mediaSource
=
new
MaskingMediaSource
(
mediaSource
useLazyPreparation
)
;
this
.
activeMediaPeriodIds
=
new
ArrayList
<
>
(
)
;
this
.
uid
=
new
Object
(
)
;
}
public
void
reset
(
int
childIndex
int
firstWindowIndexInChild
)
{
this
.
childIndex
=
childIndex
;
this
.
firstWindowIndexInChild
=
firstWindowIndexInChild
;
this
.
isRemoved
=
false
;
this
.
activeMediaPeriodIds
.
clear
(
)
;
}
}
private
static
final
class
MessageData
<
T
>
{
public
final
int
index
;
public
final
T
customData
;
Nullable
public
final
HandlerAndRunnable
onCompletionAction
;
public
MessageData
(
int
index
T
customData
Nullable
HandlerAndRunnable
onCompletionAction
)
{
this
.
index
=
index
;
this
.
customData
=
customData
;
this
.
onCompletionAction
=
onCompletionAction
;
}
}
private
static
final
class
ConcatenatedTimeline
extends
AbstractConcatenatedTimeline
{
private
final
int
windowCount
;
private
final
int
periodCount
;
private
final
int
[
]
firstPeriodInChildIndices
;
private
final
int
[
]
firstWindowInChildIndices
;
private
final
Timeline
[
]
timelines
;
private
final
Object
[
]
uids
;
private
final
HashMap
<
Object
Integer
>
childIndexByUid
;
public
ConcatenatedTimeline
(
Collection
<
MediaSourceHolder
>
mediaSourceHolders
ShuffleOrder
shuffleOrder
boolean
isAtomic
)
{
super
(
isAtomic
shuffleOrder
)
;
int
childCount
=
mediaSourceHolders
.
size
(
)
;
firstPeriodInChildIndices
=
new
int
[
childCount
]
;
firstWindowInChildIndices
=
new
int
[
childCount
]
;
timelines
=
new
Timeline
[
childCount
]
;
uids
=
new
Object
[
childCount
]
;
childIndexByUid
=
new
HashMap
<
>
(
)
;
int
index
=
0
;
int
windowCount
=
0
;
int
periodCount
=
0
;
for
(
MediaSourceHolder
mediaSourceHolder
:
mediaSourceHolders
)
{
timelines
[
index
]
=
mediaSourceHolder
.
mediaSource
.
getTimeline
(
)
;
firstWindowInChildIndices
[
index
]
=
windowCount
;
firstPeriodInChildIndices
[
index
]
=
periodCount
;
windowCount
+
=
timelines
[
index
]
.
getWindowCount
(
)
;
periodCount
+
=
timelines
[
index
]
.
getPeriodCount
(
)
;
uids
[
index
]
=
mediaSourceHolder
.
uid
;
childIndexByUid
.
put
(
uids
[
index
]
index
+
+
)
;
}
this
.
windowCount
=
windowCount
;
this
.
periodCount
=
periodCount
;
}
Override
protected
int
getChildIndexByPeriodIndex
(
int
periodIndex
)
{
return
Util
.
binarySearchFloor
(
firstPeriodInChildIndices
periodIndex
+
1
false
false
)
;
}
Override
protected
int
getChildIndexByWindowIndex
(
int
windowIndex
)
{
return
Util
.
binarySearchFloor
(
firstWindowInChildIndices
windowIndex
+
1
false
false
)
;
}
Override
protected
int
getChildIndexByChildUid
(
Object
childUid
)
{
Integer
index
=
childIndexByUid
.
get
(
childUid
)
;
return
index
=
=
null
?
C
.
INDEX_UNSET
:
index
;
}
Override
protected
Timeline
getTimelineByChildIndex
(
int
childIndex
)
{
return
timelines
[
childIndex
]
;
}
Override
protected
int
getFirstPeriodIndexByChildIndex
(
int
childIndex
)
{
return
firstPeriodInChildIndices
[
childIndex
]
;
}
Override
protected
int
getFirstWindowIndexByChildIndex
(
int
childIndex
)
{
return
firstWindowInChildIndices
[
childIndex
]
;
}
Override
protected
Object
getChildUidByChildIndex
(
int
childIndex
)
{
return
uids
[
childIndex
]
;
}
Override
public
int
getWindowCount
(
)
{
return
windowCount
;
}
Override
public
int
getPeriodCount
(
)
{
return
periodCount
;
}
}
private
static
final
class
DummyMediaSource
extends
BaseMediaSource
{
Override
protected
void
prepareSourceInternal
(
Nullable
TransferListener
mediaTransferListener
)
{
}
Override
Nullable
public
Object
getTag
(
)
{
return
null
;
}
Override
protected
void
releaseSourceInternal
(
)
{
}
Override
public
void
maybeThrowSourceInfoRefreshError
(
)
throws
IOException
{
}
Override
public
MediaPeriod
createPeriod
(
MediaPeriodId
id
Allocator
allocator
long
startPositionUs
)
{
throw
new
UnsupportedOperationException
(
)
;
}
Override
public
void
releasePeriod
(
MediaPeriod
mediaPeriod
)
{
}
}
private
static
final
class
HandlerAndRunnable
{
private
final
Handler
handler
;
private
final
Runnable
runnable
;
public
HandlerAndRunnable
(
Handler
handler
Runnable
runnable
)
{
this
.
handler
=
handler
;
this
.
runnable
=
runnable
;
}
public
void
dispatch
(
)
{
handler
.
post
(
runnable
)
;
}
}
}
