package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ogg
;
import
androidx
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekPoint
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
final
class
DefaultOggSeeker
implements
OggSeeker
{
private
static
final
int
MATCH_RANGE
=
72000
;
private
static
final
int
MATCH_BYTE_RANGE
=
100000
;
private
static
final
int
DEFAULT_OFFSET
=
30000
;
private
static
final
int
STATE_SEEK_TO_END
=
0
;
private
static
final
int
STATE_READ_LAST_PAGE
=
1
;
private
static
final
int
STATE_SEEK
=
2
;
private
static
final
int
STATE_SKIP
=
3
;
private
static
final
int
STATE_IDLE
=
4
;
private
final
OggPageHeader
pageHeader
=
new
OggPageHeader
(
)
;
private
final
long
payloadStartPosition
;
private
final
long
payloadEndPosition
;
private
final
StreamReader
streamReader
;
private
int
state
;
private
long
totalGranules
;
private
long
positionBeforeSeekToEnd
;
private
long
targetGranule
;
private
long
start
;
private
long
end
;
private
long
startGranule
;
private
long
endGranule
;
public
DefaultOggSeeker
(
StreamReader
streamReader
long
payloadStartPosition
long
payloadEndPosition
long
firstPayloadPageSize
long
firstPayloadPageGranulePosition
boolean
firstPayloadPageIsLastPage
)
{
Assertions
.
checkArgument
(
payloadStartPosition
>
=
0
&
&
payloadEndPosition
>
payloadStartPosition
)
;
this
.
streamReader
=
streamReader
;
this
.
payloadStartPosition
=
payloadStartPosition
;
this
.
payloadEndPosition
=
payloadEndPosition
;
if
(
firstPayloadPageSize
=
=
payloadEndPosition
-
payloadStartPosition
|
|
firstPayloadPageIsLastPage
)
{
totalGranules
=
firstPayloadPageGranulePosition
;
state
=
STATE_IDLE
;
}
else
{
state
=
STATE_SEEK_TO_END
;
}
}
Override
SuppressWarnings
(
"
fallthrough
"
)
public
long
read
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
switch
(
state
)
{
case
STATE_IDLE
:
return
-
1
;
case
STATE_SEEK_TO_END
:
positionBeforeSeekToEnd
=
input
.
getPosition
(
)
;
state
=
STATE_READ_LAST_PAGE
;
long
lastPageSearchPosition
=
payloadEndPosition
-
OggPageHeader
.
MAX_PAGE_SIZE
;
if
(
lastPageSearchPosition
>
positionBeforeSeekToEnd
)
{
return
lastPageSearchPosition
;
}
case
STATE_READ_LAST_PAGE
:
totalGranules
=
readGranuleOfLastPage
(
input
)
;
state
=
STATE_IDLE
;
return
positionBeforeSeekToEnd
;
case
STATE_SEEK
:
long
position
=
getNextSeekPosition
(
input
)
;
if
(
position
!
=
C
.
POSITION_UNSET
)
{
return
position
;
}
state
=
STATE_SKIP
;
case
STATE_SKIP
:
skipToPageOfTargetGranule
(
input
)
;
state
=
STATE_IDLE
;
return
-
(
startGranule
+
2
)
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
Override
public
OggSeekMap
createSeekMap
(
)
{
return
totalGranules
!
=
0
?
new
OggSeekMap
(
)
:
null
;
}
Override
public
void
startSeek
(
long
targetGranule
)
{
this
.
targetGranule
=
Util
.
constrainValue
(
targetGranule
0
totalGranules
-
1
)
;
state
=
STATE_SEEK
;
start
=
payloadStartPosition
;
end
=
payloadEndPosition
;
startGranule
=
0
;
endGranule
=
totalGranules
;
}
private
long
getNextSeekPosition
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
if
(
start
=
=
end
)
{
return
C
.
POSITION_UNSET
;
}
long
currentPosition
=
input
.
getPosition
(
)
;
if
(
!
skipToNextPage
(
input
end
)
)
{
if
(
start
=
=
currentPosition
)
{
throw
new
IOException
(
"
No
ogg
page
can
be
found
.
"
)
;
}
return
start
;
}
pageHeader
.
populate
(
input
false
)
;
input
.
resetPeekPosition
(
)
;
long
granuleDistance
=
targetGranule
-
pageHeader
.
granulePosition
;
int
pageSize
=
pageHeader
.
headerSize
+
pageHeader
.
bodySize
;
if
(
0
<
=
granuleDistance
&
&
granuleDistance
<
MATCH_RANGE
)
{
return
C
.
POSITION_UNSET
;
}
if
(
granuleDistance
<
0
)
{
end
=
currentPosition
;
endGranule
=
pageHeader
.
granulePosition
;
}
else
{
start
=
input
.
getPosition
(
)
+
pageSize
;
startGranule
=
pageHeader
.
granulePosition
;
}
if
(
end
-
start
<
MATCH_BYTE_RANGE
)
{
end
=
start
;
return
start
;
}
long
offset
=
pageSize
*
(
granuleDistance
<
=
0
?
2L
:
1L
)
;
long
nextPosition
=
input
.
getPosition
(
)
-
offset
+
(
granuleDistance
*
(
end
-
start
)
/
(
endGranule
-
startGranule
)
)
;
return
Util
.
constrainValue
(
nextPosition
start
end
-
1
)
;
}
private
void
skipToPageOfTargetGranule
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
pageHeader
.
populate
(
input
false
)
;
while
(
pageHeader
.
granulePosition
<
=
targetGranule
)
{
input
.
skipFully
(
pageHeader
.
headerSize
+
pageHeader
.
bodySize
)
;
start
=
input
.
getPosition
(
)
;
startGranule
=
pageHeader
.
granulePosition
;
pageHeader
.
populate
(
input
false
)
;
}
input
.
resetPeekPosition
(
)
;
}
VisibleForTesting
void
skipToNextPage
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
if
(
!
skipToNextPage
(
input
payloadEndPosition
)
)
{
throw
new
EOFException
(
)
;
}
}
private
boolean
skipToNextPage
(
ExtractorInput
input
long
limit
)
throws
IOException
InterruptedException
{
limit
=
Math
.
min
(
limit
+
3
payloadEndPosition
)
;
byte
[
]
buffer
=
new
byte
[
2048
]
;
int
peekLength
=
buffer
.
length
;
while
(
true
)
{
if
(
input
.
getPosition
(
)
+
peekLength
>
limit
)
{
peekLength
=
(
int
)
(
limit
-
input
.
getPosition
(
)
)
;
if
(
peekLength
<
4
)
{
return
false
;
}
}
input
.
peekFully
(
buffer
0
peekLength
false
)
;
for
(
int
i
=
0
;
i
<
peekLength
-
3
;
i
+
+
)
{
if
(
buffer
[
i
]
=
=
'
O
'
&
&
buffer
[
i
+
1
]
=
=
'
g
'
&
&
buffer
[
i
+
2
]
=
=
'
g
'
&
&
buffer
[
i
+
3
]
=
=
'
S
'
)
{
input
.
skipFully
(
i
)
;
return
true
;
}
}
input
.
skipFully
(
peekLength
-
3
)
;
}
}
VisibleForTesting
long
readGranuleOfLastPage
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
skipToNextPage
(
input
)
;
pageHeader
.
reset
(
)
;
while
(
(
pageHeader
.
type
&
0x04
)
!
=
0x04
&
&
input
.
getPosition
(
)
<
payloadEndPosition
)
{
pageHeader
.
populate
(
input
false
)
;
input
.
skipFully
(
pageHeader
.
headerSize
+
pageHeader
.
bodySize
)
;
}
return
pageHeader
.
granulePosition
;
}
private
final
class
OggSeekMap
implements
SeekMap
{
Override
public
boolean
isSeekable
(
)
{
return
true
;
}
Override
public
SeekPoints
getSeekPoints
(
long
timeUs
)
{
long
targetGranule
=
streamReader
.
convertTimeToGranule
(
timeUs
)
;
long
estimatedPosition
=
payloadStartPosition
+
(
targetGranule
*
(
payloadEndPosition
-
payloadStartPosition
)
/
totalGranules
)
-
DEFAULT_OFFSET
;
estimatedPosition
=
Util
.
constrainValue
(
estimatedPosition
payloadStartPosition
payloadEndPosition
-
1
)
;
return
new
SeekPoints
(
new
SeekPoint
(
timeUs
estimatedPosition
)
)
;
}
Override
public
long
getDurationUs
(
)
{
return
streamReader
.
convertGranuleToTime
(
totalGranules
)
;
}
}
}
