package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
ByteOrder
;
public
final
class
TeeAudioProcessor
extends
BaseAudioProcessor
{
public
interface
AudioBufferSink
{
void
flush
(
int
sampleRateHz
int
channelCount
C
.
PcmEncoding
int
encoding
)
;
void
handleBuffer
(
ByteBuffer
buffer
)
;
}
private
final
AudioBufferSink
audioBufferSink
;
public
TeeAudioProcessor
(
AudioBufferSink
audioBufferSink
)
{
this
.
audioBufferSink
=
Assertions
.
checkNotNull
(
audioBufferSink
)
;
}
Override
public
AudioFormat
onConfigure
(
AudioFormat
inputAudioFormat
)
{
return
inputAudioFormat
;
}
Override
public
void
queueInput
(
ByteBuffer
inputBuffer
)
{
int
remaining
=
inputBuffer
.
remaining
(
)
;
if
(
remaining
=
=
0
)
{
return
;
}
audioBufferSink
.
handleBuffer
(
inputBuffer
.
asReadOnlyBuffer
(
)
)
;
replaceOutputBuffer
(
remaining
)
.
put
(
inputBuffer
)
.
flip
(
)
;
}
Override
protected
void
onQueueEndOfStream
(
)
{
flushSinkIfActive
(
)
;
}
Override
protected
void
onReset
(
)
{
flushSinkIfActive
(
)
;
}
private
void
flushSinkIfActive
(
)
{
if
(
isActive
(
)
)
{
audioBufferSink
.
flush
(
inputAudioFormat
.
sampleRate
inputAudioFormat
.
channelCount
inputAudioFormat
.
encoding
)
;
}
}
public
static
final
class
WavFileAudioBufferSink
implements
AudioBufferSink
{
private
static
final
String
TAG
=
"
WaveFileAudioBufferSink
"
;
private
static
final
int
FILE_SIZE_MINUS_8_OFFSET
=
4
;
private
static
final
int
FILE_SIZE_MINUS_44_OFFSET
=
40
;
private
static
final
int
HEADER_LENGTH
=
44
;
private
final
String
outputFileNamePrefix
;
private
final
byte
[
]
scratchBuffer
;
private
final
ByteBuffer
scratchByteBuffer
;
private
int
sampleRateHz
;
private
int
channelCount
;
C
.
PcmEncoding
private
int
encoding
;
Nullable
private
RandomAccessFile
randomAccessFile
;
private
int
counter
;
private
int
bytesWritten
;
public
WavFileAudioBufferSink
(
String
outputFileNamePrefix
)
{
this
.
outputFileNamePrefix
=
outputFileNamePrefix
;
scratchBuffer
=
new
byte
[
1024
]
;
scratchByteBuffer
=
ByteBuffer
.
wrap
(
scratchBuffer
)
.
order
(
ByteOrder
.
LITTLE_ENDIAN
)
;
}
Override
public
void
flush
(
int
sampleRateHz
int
channelCount
C
.
PcmEncoding
int
encoding
)
{
try
{
reset
(
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
TAG
"
Error
resetting
"
e
)
;
}
this
.
sampleRateHz
=
sampleRateHz
;
this
.
channelCount
=
channelCount
;
this
.
encoding
=
encoding
;
}
Override
public
void
handleBuffer
(
ByteBuffer
buffer
)
{
try
{
maybePrepareFile
(
)
;
writeBuffer
(
buffer
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
TAG
"
Error
writing
data
"
e
)
;
}
}
private
void
maybePrepareFile
(
)
throws
IOException
{
if
(
randomAccessFile
!
=
null
)
{
return
;
}
RandomAccessFile
randomAccessFile
=
new
RandomAccessFile
(
getNextOutputFileName
(
)
"
rw
"
)
;
writeFileHeader
(
randomAccessFile
)
;
this
.
randomAccessFile
=
randomAccessFile
;
bytesWritten
=
HEADER_LENGTH
;
}
private
void
writeFileHeader
(
RandomAccessFile
randomAccessFile
)
throws
IOException
{
randomAccessFile
.
writeInt
(
WavUtil
.
RIFF_FOURCC
)
;
randomAccessFile
.
writeInt
(
-
1
)
;
randomAccessFile
.
writeInt
(
WavUtil
.
WAVE_FOURCC
)
;
randomAccessFile
.
writeInt
(
WavUtil
.
FMT_FOURCC
)
;
scratchByteBuffer
.
clear
(
)
;
scratchByteBuffer
.
putInt
(
16
)
;
scratchByteBuffer
.
putShort
(
(
short
)
WavUtil
.
getTypeForPcmEncoding
(
encoding
)
)
;
scratchByteBuffer
.
putShort
(
(
short
)
channelCount
)
;
scratchByteBuffer
.
putInt
(
sampleRateHz
)
;
int
bytesPerSample
=
Util
.
getPcmFrameSize
(
encoding
channelCount
)
;
scratchByteBuffer
.
putInt
(
bytesPerSample
*
sampleRateHz
)
;
scratchByteBuffer
.
putShort
(
(
short
)
bytesPerSample
)
;
scratchByteBuffer
.
putShort
(
(
short
)
(
8
*
bytesPerSample
/
channelCount
)
)
;
randomAccessFile
.
write
(
scratchBuffer
0
scratchByteBuffer
.
position
(
)
)
;
randomAccessFile
.
writeInt
(
WavUtil
.
DATA_FOURCC
)
;
randomAccessFile
.
writeInt
(
-
1
)
;
}
private
void
writeBuffer
(
ByteBuffer
buffer
)
throws
IOException
{
RandomAccessFile
randomAccessFile
=
Assertions
.
checkNotNull
(
this
.
randomAccessFile
)
;
while
(
buffer
.
hasRemaining
(
)
)
{
int
bytesToWrite
=
Math
.
min
(
buffer
.
remaining
(
)
scratchBuffer
.
length
)
;
buffer
.
get
(
scratchBuffer
0
bytesToWrite
)
;
randomAccessFile
.
write
(
scratchBuffer
0
bytesToWrite
)
;
bytesWritten
+
=
bytesToWrite
;
}
}
private
void
reset
(
)
throws
IOException
{
RandomAccessFile
randomAccessFile
=
this
.
randomAccessFile
;
if
(
randomAccessFile
=
=
null
)
{
return
;
}
try
{
scratchByteBuffer
.
clear
(
)
;
scratchByteBuffer
.
putInt
(
bytesWritten
-
8
)
;
randomAccessFile
.
seek
(
FILE_SIZE_MINUS_8_OFFSET
)
;
randomAccessFile
.
write
(
scratchBuffer
0
4
)
;
scratchByteBuffer
.
clear
(
)
;
scratchByteBuffer
.
putInt
(
bytesWritten
-
44
)
;
randomAccessFile
.
seek
(
FILE_SIZE_MINUS_44_OFFSET
)
;
randomAccessFile
.
write
(
scratchBuffer
0
4
)
;
}
catch
(
IOException
e
)
{
Log
.
w
(
TAG
"
Error
updating
file
size
"
e
)
;
}
try
{
randomAccessFile
.
close
(
)
;
}
finally
{
this
.
randomAccessFile
=
null
;
}
}
private
String
getNextOutputFileName
(
)
{
return
Util
.
formatInvariant
(
"
%
s
-
%
04d
.
wav
"
outputFileNamePrefix
counter
+
+
)
;
}
}
}
