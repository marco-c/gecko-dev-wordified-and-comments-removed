package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
;
import
android
.
os
.
Handler
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
public
final
class
PlayerMessage
{
public
interface
Target
{
void
handleMessage
(
int
messageType
Nullable
Object
payload
)
throws
ExoPlaybackException
;
}
public
interface
Sender
{
void
sendMessage
(
PlayerMessage
message
)
;
}
private
final
Target
target
;
private
final
Sender
sender
;
private
final
Timeline
timeline
;
private
int
type
;
Nullable
private
Object
payload
;
private
Handler
handler
;
private
int
windowIndex
;
private
long
positionMs
;
private
boolean
deleteAfterDelivery
;
private
boolean
isSent
;
private
boolean
isDelivered
;
private
boolean
isProcessed
;
private
boolean
isCanceled
;
public
PlayerMessage
(
Sender
sender
Target
target
Timeline
timeline
int
defaultWindowIndex
Handler
defaultHandler
)
{
this
.
sender
=
sender
;
this
.
target
=
target
;
this
.
timeline
=
timeline
;
this
.
handler
=
defaultHandler
;
this
.
windowIndex
=
defaultWindowIndex
;
this
.
positionMs
=
C
.
TIME_UNSET
;
this
.
deleteAfterDelivery
=
true
;
}
public
Timeline
getTimeline
(
)
{
return
timeline
;
}
public
Target
getTarget
(
)
{
return
target
;
}
public
PlayerMessage
setType
(
int
messageType
)
{
Assertions
.
checkState
(
!
isSent
)
;
this
.
type
=
messageType
;
return
this
;
}
public
int
getType
(
)
{
return
type
;
}
public
PlayerMessage
setPayload
(
Nullable
Object
payload
)
{
Assertions
.
checkState
(
!
isSent
)
;
this
.
payload
=
payload
;
return
this
;
}
Nullable
public
Object
getPayload
(
)
{
return
payload
;
}
public
PlayerMessage
setHandler
(
Handler
handler
)
{
Assertions
.
checkState
(
!
isSent
)
;
this
.
handler
=
handler
;
return
this
;
}
public
Handler
getHandler
(
)
{
return
handler
;
}
public
long
getPositionMs
(
)
{
return
positionMs
;
}
public
PlayerMessage
setPosition
(
long
positionMs
)
{
Assertions
.
checkState
(
!
isSent
)
;
this
.
positionMs
=
positionMs
;
return
this
;
}
public
PlayerMessage
setPosition
(
int
windowIndex
long
positionMs
)
{
Assertions
.
checkState
(
!
isSent
)
;
Assertions
.
checkArgument
(
positionMs
!
=
C
.
TIME_UNSET
)
;
if
(
windowIndex
<
0
|
|
(
!
timeline
.
isEmpty
(
)
&
&
windowIndex
>
=
timeline
.
getWindowCount
(
)
)
)
{
throw
new
IllegalSeekPositionException
(
timeline
windowIndex
positionMs
)
;
}
this
.
windowIndex
=
windowIndex
;
this
.
positionMs
=
positionMs
;
return
this
;
}
public
int
getWindowIndex
(
)
{
return
windowIndex
;
}
public
PlayerMessage
setDeleteAfterDelivery
(
boolean
deleteAfterDelivery
)
{
Assertions
.
checkState
(
!
isSent
)
;
this
.
deleteAfterDelivery
=
deleteAfterDelivery
;
return
this
;
}
public
boolean
getDeleteAfterDelivery
(
)
{
return
deleteAfterDelivery
;
}
public
PlayerMessage
send
(
)
{
Assertions
.
checkState
(
!
isSent
)
;
if
(
positionMs
=
=
C
.
TIME_UNSET
)
{
Assertions
.
checkArgument
(
deleteAfterDelivery
)
;
}
isSent
=
true
;
sender
.
sendMessage
(
this
)
;
return
this
;
}
public
synchronized
PlayerMessage
cancel
(
)
{
Assertions
.
checkState
(
isSent
)
;
isCanceled
=
true
;
markAsProcessed
(
false
)
;
return
this
;
}
public
synchronized
boolean
isCanceled
(
)
{
return
isCanceled
;
}
public
synchronized
boolean
blockUntilDelivered
(
)
throws
InterruptedException
{
Assertions
.
checkState
(
isSent
)
;
Assertions
.
checkState
(
handler
.
getLooper
(
)
.
getThread
(
)
!
=
Thread
.
currentThread
(
)
)
;
while
(
!
isProcessed
)
{
wait
(
)
;
}
return
isDelivered
;
}
public
synchronized
void
markAsProcessed
(
boolean
isDelivered
)
{
this
.
isDelivered
|
=
isDelivered
;
isProcessed
=
true
;
notifyAll
(
)
;
}
}
