package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
nio
.
ByteBuffer
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
EnsuresNonNull
;
public
class
DecoderInputBuffer
extends
Buffer
{
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
BUFFER_REPLACEMENT_MODE_DISABLED
BUFFER_REPLACEMENT_MODE_NORMAL
BUFFER_REPLACEMENT_MODE_DIRECT
}
)
public
interface
BufferReplacementMode
{
}
public
static
final
int
BUFFER_REPLACEMENT_MODE_DISABLED
=
0
;
public
static
final
int
BUFFER_REPLACEMENT_MODE_NORMAL
=
1
;
public
static
final
int
BUFFER_REPLACEMENT_MODE_DIRECT
=
2
;
public
final
CryptoInfo
cryptoInfo
;
Nullable
public
ByteBuffer
data
;
public
boolean
waitingForKeys
;
public
long
timeUs
;
Nullable
public
ByteBuffer
supplementalData
;
BufferReplacementMode
private
final
int
bufferReplacementMode
;
public
static
DecoderInputBuffer
newFlagsOnlyInstance
(
)
{
return
new
DecoderInputBuffer
(
BUFFER_REPLACEMENT_MODE_DISABLED
)
;
}
public
DecoderInputBuffer
(
BufferReplacementMode
int
bufferReplacementMode
)
{
this
.
cryptoInfo
=
new
CryptoInfo
(
)
;
this
.
bufferReplacementMode
=
bufferReplacementMode
;
}
EnsuresNonNull
(
"
supplementalData
"
)
public
void
resetSupplementalData
(
int
length
)
{
if
(
supplementalData
=
=
null
|
|
supplementalData
.
capacity
(
)
<
length
)
{
supplementalData
=
ByteBuffer
.
allocate
(
length
)
;
}
else
{
supplementalData
.
clear
(
)
;
}
}
EnsuresNonNull
(
"
data
"
)
public
void
ensureSpaceForWrite
(
int
length
)
{
if
(
data
=
=
null
)
{
data
=
createReplacementByteBuffer
(
length
)
;
return
;
}
int
capacity
=
data
.
capacity
(
)
;
int
position
=
data
.
position
(
)
;
int
requiredCapacity
=
position
+
length
;
if
(
capacity
>
=
requiredCapacity
)
{
return
;
}
ByteBuffer
newData
=
createReplacementByteBuffer
(
requiredCapacity
)
;
newData
.
order
(
data
.
order
(
)
)
;
if
(
position
>
0
)
{
data
.
flip
(
)
;
newData
.
put
(
data
)
;
}
data
=
newData
;
}
public
final
boolean
isFlagsOnly
(
)
{
return
data
=
=
null
&
&
bufferReplacementMode
=
=
BUFFER_REPLACEMENT_MODE_DISABLED
;
}
public
final
boolean
isEncrypted
(
)
{
return
getFlag
(
C
.
BUFFER_FLAG_ENCRYPTED
)
;
}
public
final
void
flip
(
)
{
data
.
flip
(
)
;
if
(
supplementalData
!
=
null
)
{
supplementalData
.
flip
(
)
;
}
}
Override
public
void
clear
(
)
{
super
.
clear
(
)
;
if
(
data
!
=
null
)
{
data
.
clear
(
)
;
}
if
(
supplementalData
!
=
null
)
{
supplementalData
.
clear
(
)
;
}
waitingForKeys
=
false
;
}
private
ByteBuffer
createReplacementByteBuffer
(
int
requiredCapacity
)
{
if
(
bufferReplacementMode
=
=
BUFFER_REPLACEMENT_MODE_NORMAL
)
{
return
ByteBuffer
.
allocate
(
requiredCapacity
)
;
}
else
if
(
bufferReplacementMode
=
=
BUFFER_REPLACEMENT_MODE_DIRECT
)
{
return
ByteBuffer
.
allocateDirect
(
requiredCapacity
)
;
}
else
{
int
currentCapacity
=
data
=
=
null
?
0
:
data
.
capacity
(
)
;
throw
new
IllegalStateException
(
"
Buffer
too
small
(
"
+
currentCapacity
+
"
<
"
+
requiredCapacity
+
"
)
"
)
;
}
}
}
