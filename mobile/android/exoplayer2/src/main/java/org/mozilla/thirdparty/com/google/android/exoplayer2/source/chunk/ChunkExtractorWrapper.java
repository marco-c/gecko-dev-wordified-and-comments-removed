package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
;
import
android
.
util
.
SparseArray
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
DummyTrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
public
final
class
ChunkExtractorWrapper
implements
ExtractorOutput
{
public
interface
TrackOutputProvider
{
TrackOutput
track
(
int
id
int
type
)
;
}
public
final
Extractor
extractor
;
private
final
int
primaryTrackType
;
private
final
Format
primaryTrackManifestFormat
;
private
final
SparseArray
<
BindingTrackOutput
>
bindingTrackOutputs
;
private
boolean
extractorInitialized
;
private
TrackOutputProvider
trackOutputProvider
;
private
long
endTimeUs
;
private
SeekMap
seekMap
;
private
Format
[
]
sampleFormats
;
public
ChunkExtractorWrapper
(
Extractor
extractor
int
primaryTrackType
Format
primaryTrackManifestFormat
)
{
this
.
extractor
=
extractor
;
this
.
primaryTrackType
=
primaryTrackType
;
this
.
primaryTrackManifestFormat
=
primaryTrackManifestFormat
;
bindingTrackOutputs
=
new
SparseArray
<
>
(
)
;
}
public
SeekMap
getSeekMap
(
)
{
return
seekMap
;
}
public
Format
[
]
getSampleFormats
(
)
{
return
sampleFormats
;
}
public
void
init
(
Nullable
TrackOutputProvider
trackOutputProvider
long
startTimeUs
long
endTimeUs
)
{
this
.
trackOutputProvider
=
trackOutputProvider
;
this
.
endTimeUs
=
endTimeUs
;
if
(
!
extractorInitialized
)
{
extractor
.
init
(
this
)
;
if
(
startTimeUs
!
=
C
.
TIME_UNSET
)
{
extractor
.
seek
(
0
startTimeUs
)
;
}
extractorInitialized
=
true
;
}
else
{
extractor
.
seek
(
0
startTimeUs
=
=
C
.
TIME_UNSET
?
0
:
startTimeUs
)
;
for
(
int
i
=
0
;
i
<
bindingTrackOutputs
.
size
(
)
;
i
+
+
)
{
bindingTrackOutputs
.
valueAt
(
i
)
.
bind
(
trackOutputProvider
endTimeUs
)
;
}
}
}
Override
public
TrackOutput
track
(
int
id
int
type
)
{
BindingTrackOutput
bindingTrackOutput
=
bindingTrackOutputs
.
get
(
id
)
;
if
(
bindingTrackOutput
=
=
null
)
{
Assertions
.
checkState
(
sampleFormats
=
=
null
)
;
bindingTrackOutput
=
new
BindingTrackOutput
(
id
type
type
=
=
primaryTrackType
?
primaryTrackManifestFormat
:
null
)
;
bindingTrackOutput
.
bind
(
trackOutputProvider
endTimeUs
)
;
bindingTrackOutputs
.
put
(
id
bindingTrackOutput
)
;
}
return
bindingTrackOutput
;
}
Override
public
void
endTracks
(
)
{
Format
[
]
sampleFormats
=
new
Format
[
bindingTrackOutputs
.
size
(
)
]
;
for
(
int
i
=
0
;
i
<
bindingTrackOutputs
.
size
(
)
;
i
+
+
)
{
sampleFormats
[
i
]
=
bindingTrackOutputs
.
valueAt
(
i
)
.
sampleFormat
;
}
this
.
sampleFormats
=
sampleFormats
;
}
Override
public
void
seekMap
(
SeekMap
seekMap
)
{
this
.
seekMap
=
seekMap
;
}
private
static
final
class
BindingTrackOutput
implements
TrackOutput
{
private
final
int
id
;
private
final
int
type
;
private
final
Format
manifestFormat
;
private
final
DummyTrackOutput
dummyTrackOutput
;
public
Format
sampleFormat
;
private
TrackOutput
trackOutput
;
private
long
endTimeUs
;
public
BindingTrackOutput
(
int
id
int
type
Format
manifestFormat
)
{
this
.
id
=
id
;
this
.
type
=
type
;
this
.
manifestFormat
=
manifestFormat
;
dummyTrackOutput
=
new
DummyTrackOutput
(
)
;
}
public
void
bind
(
TrackOutputProvider
trackOutputProvider
long
endTimeUs
)
{
if
(
trackOutputProvider
=
=
null
)
{
trackOutput
=
dummyTrackOutput
;
return
;
}
this
.
endTimeUs
=
endTimeUs
;
trackOutput
=
trackOutputProvider
.
track
(
id
type
)
;
if
(
sampleFormat
!
=
null
)
{
trackOutput
.
format
(
sampleFormat
)
;
}
}
Override
public
void
format
(
Format
format
)
{
sampleFormat
=
manifestFormat
!
=
null
?
format
.
copyWithManifestFormatInfo
(
manifestFormat
)
:
format
;
trackOutput
.
format
(
sampleFormat
)
;
}
Override
public
int
sampleData
(
ExtractorInput
input
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
return
trackOutput
.
sampleData
(
input
length
allowEndOfInput
)
;
}
Override
public
void
sampleData
(
ParsableByteArray
data
int
length
)
{
trackOutput
.
sampleData
(
data
length
)
;
}
Override
public
void
sampleMetadata
(
long
timeUs
C
.
BufferFlags
int
flags
int
size
int
offset
CryptoData
cryptoData
)
{
if
(
endTimeUs
!
=
C
.
TIME_UNSET
&
&
timeUs
>
=
endTimeUs
)
{
trackOutput
=
dummyTrackOutput
;
}
trackOutput
.
sampleMetadata
(
timeUs
flags
size
offset
cryptoData
)
;
}
}
}
