package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
offline
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
.
castNonNull
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
public
final
class
DownloadRequest
implements
Parcelable
{
public
static
class
UnsupportedRequestException
extends
IOException
{
}
public
static
final
String
TYPE_PROGRESSIVE
=
"
progressive
"
;
public
static
final
String
TYPE_DASH
=
"
dash
"
;
public
static
final
String
TYPE_HLS
=
"
hls
"
;
public
static
final
String
TYPE_SS
=
"
ss
"
;
public
final
String
id
;
public
final
String
type
;
public
final
Uri
uri
;
public
final
List
<
StreamKey
>
streamKeys
;
Nullable
public
final
String
customCacheKey
;
public
final
byte
[
]
data
;
public
DownloadRequest
(
String
id
String
type
Uri
uri
List
<
StreamKey
>
streamKeys
Nullable
String
customCacheKey
Nullable
byte
[
]
data
)
{
if
(
TYPE_DASH
.
equals
(
type
)
|
|
TYPE_HLS
.
equals
(
type
)
|
|
TYPE_SS
.
equals
(
type
)
)
{
Assertions
.
checkArgument
(
customCacheKey
=
=
null
"
customCacheKey
must
be
null
for
type
:
"
+
type
)
;
}
this
.
id
=
id
;
this
.
type
=
type
;
this
.
uri
=
uri
;
ArrayList
<
StreamKey
>
mutableKeys
=
new
ArrayList
<
>
(
streamKeys
)
;
Collections
.
sort
(
mutableKeys
)
;
this
.
streamKeys
=
Collections
.
unmodifiableList
(
mutableKeys
)
;
this
.
customCacheKey
=
customCacheKey
;
this
.
data
=
data
!
=
null
?
Arrays
.
copyOf
(
data
data
.
length
)
:
Util
.
EMPTY_BYTE_ARRAY
;
}
DownloadRequest
(
Parcel
in
)
{
id
=
castNonNull
(
in
.
readString
(
)
)
;
type
=
castNonNull
(
in
.
readString
(
)
)
;
uri
=
Uri
.
parse
(
castNonNull
(
in
.
readString
(
)
)
)
;
int
streamKeyCount
=
in
.
readInt
(
)
;
ArrayList
<
StreamKey
>
mutableStreamKeys
=
new
ArrayList
<
>
(
streamKeyCount
)
;
for
(
int
i
=
0
;
i
<
streamKeyCount
;
i
+
+
)
{
mutableStreamKeys
.
add
(
in
.
readParcelable
(
StreamKey
.
class
.
getClassLoader
(
)
)
)
;
}
streamKeys
=
Collections
.
unmodifiableList
(
mutableStreamKeys
)
;
customCacheKey
=
in
.
readString
(
)
;
data
=
castNonNull
(
in
.
createByteArray
(
)
)
;
}
public
DownloadRequest
copyWithId
(
String
id
)
{
return
new
DownloadRequest
(
id
type
uri
streamKeys
customCacheKey
data
)
;
}
public
DownloadRequest
copyWithMergedRequest
(
DownloadRequest
newRequest
)
{
Assertions
.
checkArgument
(
id
.
equals
(
newRequest
.
id
)
)
;
Assertions
.
checkArgument
(
type
.
equals
(
newRequest
.
type
)
)
;
List
<
StreamKey
>
mergedKeys
;
if
(
streamKeys
.
isEmpty
(
)
|
|
newRequest
.
streamKeys
.
isEmpty
(
)
)
{
mergedKeys
=
Collections
.
emptyList
(
)
;
}
else
{
mergedKeys
=
new
ArrayList
<
>
(
streamKeys
)
;
for
(
int
i
=
0
;
i
<
newRequest
.
streamKeys
.
size
(
)
;
i
+
+
)
{
StreamKey
newKey
=
newRequest
.
streamKeys
.
get
(
i
)
;
if
(
!
mergedKeys
.
contains
(
newKey
)
)
{
mergedKeys
.
add
(
newKey
)
;
}
}
}
return
new
DownloadRequest
(
id
type
newRequest
.
uri
mergedKeys
newRequest
.
customCacheKey
newRequest
.
data
)
;
}
Override
public
String
toString
(
)
{
return
type
+
"
:
"
+
id
;
}
Override
public
boolean
equals
(
Nullable
Object
o
)
{
if
(
!
(
o
instanceof
DownloadRequest
)
)
{
return
false
;
}
DownloadRequest
that
=
(
DownloadRequest
)
o
;
return
id
.
equals
(
that
.
id
)
&
&
type
.
equals
(
that
.
type
)
&
&
uri
.
equals
(
that
.
uri
)
&
&
streamKeys
.
equals
(
that
.
streamKeys
)
&
&
Util
.
areEqual
(
customCacheKey
that
.
customCacheKey
)
&
&
Arrays
.
equals
(
data
that
.
data
)
;
}
Override
public
final
int
hashCode
(
)
{
int
result
=
type
.
hashCode
(
)
;
result
=
31
*
result
+
id
.
hashCode
(
)
;
result
=
31
*
result
+
type
.
hashCode
(
)
;
result
=
31
*
result
+
uri
.
hashCode
(
)
;
result
=
31
*
result
+
streamKeys
.
hashCode
(
)
;
result
=
31
*
result
+
(
customCacheKey
!
=
null
?
customCacheKey
.
hashCode
(
)
:
0
)
;
result
=
31
*
result
+
Arrays
.
hashCode
(
data
)
;
return
result
;
}
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
Parcel
dest
int
flags
)
{
dest
.
writeString
(
id
)
;
dest
.
writeString
(
type
)
;
dest
.
writeString
(
uri
.
toString
(
)
)
;
dest
.
writeInt
(
streamKeys
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
streamKeys
.
size
(
)
;
i
+
+
)
{
dest
.
writeParcelable
(
streamKeys
.
get
(
i
)
0
)
;
}
dest
.
writeString
(
customCacheKey
)
;
dest
.
writeByteArray
(
data
)
;
}
public
static
final
Parcelable
.
Creator
<
DownloadRequest
>
CREATOR
=
new
Parcelable
.
Creator
<
DownloadRequest
>
(
)
{
Override
public
DownloadRequest
createFromParcel
(
Parcel
in
)
{
return
new
DownloadRequest
(
in
)
;
}
Override
public
DownloadRequest
[
]
newArray
(
int
size
)
{
return
new
DownloadRequest
[
size
]
;
}
}
;
}
