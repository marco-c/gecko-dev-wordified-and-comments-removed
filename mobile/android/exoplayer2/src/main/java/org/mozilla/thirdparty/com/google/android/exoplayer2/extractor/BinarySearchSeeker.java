package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
abstract
class
BinarySearchSeeker
{
protected
interface
TimestampSeeker
{
TimestampSearchResult
searchForTimestamp
(
ExtractorInput
input
long
targetTimestamp
)
throws
IOException
InterruptedException
;
default
void
onSeekFinished
(
)
{
}
}
public
static
final
class
DefaultSeekTimestampConverter
implements
SeekTimestampConverter
{
Override
public
long
timeUsToTargetTime
(
long
timeUs
)
{
return
timeUs
;
}
}
protected
interface
SeekTimestampConverter
{
long
timeUsToTargetTime
(
long
timeUs
)
;
}
private
static
final
long
MAX_SKIP_BYTES
=
256
*
1024
;
protected
final
BinarySearchSeekMap
seekMap
;
protected
final
TimestampSeeker
timestampSeeker
;
protected
Nullable
SeekOperationParams
seekOperationParams
;
private
final
int
minimumSearchRange
;
SuppressWarnings
(
"
initialization
"
)
protected
BinarySearchSeeker
(
SeekTimestampConverter
seekTimestampConverter
TimestampSeeker
timestampSeeker
long
durationUs
long
floorTimePosition
long
ceilingTimePosition
long
floorBytePosition
long
ceilingBytePosition
long
approxBytesPerFrame
int
minimumSearchRange
)
{
this
.
timestampSeeker
=
timestampSeeker
;
this
.
minimumSearchRange
=
minimumSearchRange
;
this
.
seekMap
=
new
BinarySearchSeekMap
(
seekTimestampConverter
durationUs
floorTimePosition
ceilingTimePosition
floorBytePosition
ceilingBytePosition
approxBytesPerFrame
)
;
}
public
final
SeekMap
getSeekMap
(
)
{
return
seekMap
;
}
public
final
void
setSeekTargetUs
(
long
timeUs
)
{
if
(
seekOperationParams
!
=
null
&
&
seekOperationParams
.
getSeekTimeUs
(
)
=
=
timeUs
)
{
return
;
}
seekOperationParams
=
createSeekParamsForTargetTimeUs
(
timeUs
)
;
}
public
final
boolean
isSeeking
(
)
{
return
seekOperationParams
!
=
null
;
}
public
int
handlePendingSeek
(
ExtractorInput
input
PositionHolder
seekPositionHolder
)
throws
InterruptedException
IOException
{
TimestampSeeker
timestampSeeker
=
Assertions
.
checkNotNull
(
this
.
timestampSeeker
)
;
while
(
true
)
{
SeekOperationParams
seekOperationParams
=
Assertions
.
checkNotNull
(
this
.
seekOperationParams
)
;
long
floorPosition
=
seekOperationParams
.
getFloorBytePosition
(
)
;
long
ceilingPosition
=
seekOperationParams
.
getCeilingBytePosition
(
)
;
long
searchPosition
=
seekOperationParams
.
getNextSearchBytePosition
(
)
;
if
(
ceilingPosition
-
floorPosition
<
=
minimumSearchRange
)
{
markSeekOperationFinished
(
false
floorPosition
)
;
return
seekToPosition
(
input
floorPosition
seekPositionHolder
)
;
}
if
(
!
skipInputUntilPosition
(
input
searchPosition
)
)
{
return
seekToPosition
(
input
searchPosition
seekPositionHolder
)
;
}
input
.
resetPeekPosition
(
)
;
TimestampSearchResult
timestampSearchResult
=
timestampSeeker
.
searchForTimestamp
(
input
seekOperationParams
.
getTargetTimePosition
(
)
)
;
switch
(
timestampSearchResult
.
type
)
{
case
TimestampSearchResult
.
TYPE_POSITION_OVERESTIMATED
:
seekOperationParams
.
updateSeekCeiling
(
timestampSearchResult
.
timestampToUpdate
timestampSearchResult
.
bytePositionToUpdate
)
;
break
;
case
TimestampSearchResult
.
TYPE_POSITION_UNDERESTIMATED
:
seekOperationParams
.
updateSeekFloor
(
timestampSearchResult
.
timestampToUpdate
timestampSearchResult
.
bytePositionToUpdate
)
;
break
;
case
TimestampSearchResult
.
TYPE_TARGET_TIMESTAMP_FOUND
:
markSeekOperationFinished
(
true
timestampSearchResult
.
bytePositionToUpdate
)
;
skipInputUntilPosition
(
input
timestampSearchResult
.
bytePositionToUpdate
)
;
return
seekToPosition
(
input
timestampSearchResult
.
bytePositionToUpdate
seekPositionHolder
)
;
case
TimestampSearchResult
.
TYPE_NO_TIMESTAMP
:
markSeekOperationFinished
(
false
searchPosition
)
;
return
seekToPosition
(
input
searchPosition
seekPositionHolder
)
;
default
:
throw
new
IllegalStateException
(
"
Invalid
case
"
)
;
}
}
}
protected
SeekOperationParams
createSeekParamsForTargetTimeUs
(
long
timeUs
)
{
return
new
SeekOperationParams
(
timeUs
seekMap
.
timeUsToTargetTime
(
timeUs
)
seekMap
.
floorTimePosition
seekMap
.
ceilingTimePosition
seekMap
.
floorBytePosition
seekMap
.
ceilingBytePosition
seekMap
.
approxBytesPerFrame
)
;
}
protected
final
void
markSeekOperationFinished
(
boolean
foundTargetFrame
long
resultPosition
)
{
seekOperationParams
=
null
;
timestampSeeker
.
onSeekFinished
(
)
;
onSeekOperationFinished
(
foundTargetFrame
resultPosition
)
;
}
protected
void
onSeekOperationFinished
(
boolean
foundTargetFrame
long
resultPosition
)
{
}
protected
final
boolean
skipInputUntilPosition
(
ExtractorInput
input
long
position
)
throws
IOException
InterruptedException
{
long
bytesToSkip
=
position
-
input
.
getPosition
(
)
;
if
(
bytesToSkip
>
=
0
&
&
bytesToSkip
<
=
MAX_SKIP_BYTES
)
{
input
.
skipFully
(
(
int
)
bytesToSkip
)
;
return
true
;
}
return
false
;
}
protected
final
int
seekToPosition
(
ExtractorInput
input
long
position
PositionHolder
seekPositionHolder
)
{
if
(
position
=
=
input
.
getPosition
(
)
)
{
return
Extractor
.
RESULT_CONTINUE
;
}
else
{
seekPositionHolder
.
position
=
position
;
return
Extractor
.
RESULT_SEEK
;
}
}
protected
static
class
SeekOperationParams
{
private
final
long
seekTimeUs
;
private
final
long
targetTimePosition
;
private
final
long
approxBytesPerFrame
;
private
long
floorTimePosition
;
private
long
ceilingTimePosition
;
private
long
floorBytePosition
;
private
long
ceilingBytePosition
;
private
long
nextSearchBytePosition
;
protected
static
long
calculateNextSearchBytePosition
(
long
targetTimePosition
long
floorTimePosition
long
ceilingTimePosition
long
floorBytePosition
long
ceilingBytePosition
long
approxBytesPerFrame
)
{
if
(
floorBytePosition
+
1
>
=
ceilingBytePosition
|
|
floorTimePosition
+
1
>
=
ceilingTimePosition
)
{
return
floorBytePosition
;
}
long
seekTimeDuration
=
targetTimePosition
-
floorTimePosition
;
float
estimatedBytesPerTimeUnit
=
(
float
)
(
ceilingBytePosition
-
floorBytePosition
)
/
(
ceilingTimePosition
-
floorTimePosition
)
;
long
bytesToSkip
=
(
long
)
(
seekTimeDuration
*
estimatedBytesPerTimeUnit
)
;
long
confidenceInterval
=
bytesToSkip
/
20
;
long
estimatedFramePosition
=
floorBytePosition
+
bytesToSkip
-
approxBytesPerFrame
;
long
estimatedPosition
=
estimatedFramePosition
-
confidenceInterval
;
return
Util
.
constrainValue
(
estimatedPosition
floorBytePosition
ceilingBytePosition
-
1
)
;
}
protected
SeekOperationParams
(
long
seekTimeUs
long
targetTimePosition
long
floorTimePosition
long
ceilingTimePosition
long
floorBytePosition
long
ceilingBytePosition
long
approxBytesPerFrame
)
{
this
.
seekTimeUs
=
seekTimeUs
;
this
.
targetTimePosition
=
targetTimePosition
;
this
.
floorTimePosition
=
floorTimePosition
;
this
.
ceilingTimePosition
=
ceilingTimePosition
;
this
.
floorBytePosition
=
floorBytePosition
;
this
.
ceilingBytePosition
=
ceilingBytePosition
;
this
.
approxBytesPerFrame
=
approxBytesPerFrame
;
this
.
nextSearchBytePosition
=
calculateNextSearchBytePosition
(
targetTimePosition
floorTimePosition
ceilingTimePosition
floorBytePosition
ceilingBytePosition
approxBytesPerFrame
)
;
}
private
long
getFloorBytePosition
(
)
{
return
floorBytePosition
;
}
private
long
getCeilingBytePosition
(
)
{
return
ceilingBytePosition
;
}
private
long
getTargetTimePosition
(
)
{
return
targetTimePosition
;
}
private
long
getSeekTimeUs
(
)
{
return
seekTimeUs
;
}
private
void
updateSeekFloor
(
long
floorTimePosition
long
floorBytePosition
)
{
this
.
floorTimePosition
=
floorTimePosition
;
this
.
floorBytePosition
=
floorBytePosition
;
updateNextSearchBytePosition
(
)
;
}
private
void
updateSeekCeiling
(
long
ceilingTimePosition
long
ceilingBytePosition
)
{
this
.
ceilingTimePosition
=
ceilingTimePosition
;
this
.
ceilingBytePosition
=
ceilingBytePosition
;
updateNextSearchBytePosition
(
)
;
}
private
long
getNextSearchBytePosition
(
)
{
return
nextSearchBytePosition
;
}
private
void
updateNextSearchBytePosition
(
)
{
this
.
nextSearchBytePosition
=
calculateNextSearchBytePosition
(
targetTimePosition
floorTimePosition
ceilingTimePosition
floorBytePosition
ceilingBytePosition
approxBytesPerFrame
)
;
}
}
public
static
final
class
TimestampSearchResult
{
public
static
final
int
TYPE_TARGET_TIMESTAMP_FOUND
=
0
;
public
static
final
int
TYPE_POSITION_OVERESTIMATED
=
-
1
;
public
static
final
int
TYPE_POSITION_UNDERESTIMATED
=
-
2
;
public
static
final
int
TYPE_NO_TIMESTAMP
=
-
3
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
TYPE_TARGET_TIMESTAMP_FOUND
TYPE_POSITION_OVERESTIMATED
TYPE_POSITION_UNDERESTIMATED
TYPE_NO_TIMESTAMP
}
)
interface
Type
{
}
public
static
final
TimestampSearchResult
NO_TIMESTAMP_IN_RANGE_RESULT
=
new
TimestampSearchResult
(
TYPE_NO_TIMESTAMP
C
.
TIME_UNSET
C
.
POSITION_UNSET
)
;
Type
private
final
int
type
;
private
final
long
timestampToUpdate
;
private
final
long
bytePositionToUpdate
;
private
TimestampSearchResult
(
Type
int
type
long
timestampToUpdate
long
bytePositionToUpdate
)
{
this
.
type
=
type
;
this
.
timestampToUpdate
=
timestampToUpdate
;
this
.
bytePositionToUpdate
=
bytePositionToUpdate
;
}
public
static
TimestampSearchResult
overestimatedResult
(
long
newCeilingTimestamp
long
newCeilingBytePosition
)
{
return
new
TimestampSearchResult
(
TYPE_POSITION_OVERESTIMATED
newCeilingTimestamp
newCeilingBytePosition
)
;
}
public
static
TimestampSearchResult
underestimatedResult
(
long
newFloorTimestamp
long
newCeilingBytePosition
)
{
return
new
TimestampSearchResult
(
TYPE_POSITION_UNDERESTIMATED
newFloorTimestamp
newCeilingBytePosition
)
;
}
public
static
TimestampSearchResult
targetFoundResult
(
long
resultBytePosition
)
{
return
new
TimestampSearchResult
(
TYPE_TARGET_TIMESTAMP_FOUND
C
.
TIME_UNSET
resultBytePosition
)
;
}
}
public
static
class
BinarySearchSeekMap
implements
SeekMap
{
private
final
SeekTimestampConverter
seekTimestampConverter
;
private
final
long
durationUs
;
private
final
long
floorTimePosition
;
private
final
long
ceilingTimePosition
;
private
final
long
floorBytePosition
;
private
final
long
ceilingBytePosition
;
private
final
long
approxBytesPerFrame
;
public
BinarySearchSeekMap
(
SeekTimestampConverter
seekTimestampConverter
long
durationUs
long
floorTimePosition
long
ceilingTimePosition
long
floorBytePosition
long
ceilingBytePosition
long
approxBytesPerFrame
)
{
this
.
seekTimestampConverter
=
seekTimestampConverter
;
this
.
durationUs
=
durationUs
;
this
.
floorTimePosition
=
floorTimePosition
;
this
.
ceilingTimePosition
=
ceilingTimePosition
;
this
.
floorBytePosition
=
floorBytePosition
;
this
.
ceilingBytePosition
=
ceilingBytePosition
;
this
.
approxBytesPerFrame
=
approxBytesPerFrame
;
}
Override
public
boolean
isSeekable
(
)
{
return
true
;
}
Override
public
SeekPoints
getSeekPoints
(
long
timeUs
)
{
long
nextSearchPosition
=
SeekOperationParams
.
calculateNextSearchBytePosition
(
seekTimestampConverter
.
timeUsToTargetTime
(
timeUs
)
floorTimePosition
ceilingTimePosition
floorBytePosition
ceilingBytePosition
approxBytesPerFrame
)
;
return
new
SeekPoints
(
new
SeekPoint
(
timeUs
nextSearchPosition
)
)
;
}
Override
public
long
getDurationUs
(
)
{
return
durationUs
;
}
public
long
timeUsToTargetTime
(
long
timeUs
)
{
return
seekTimestampConverter
.
timeUsToTargetTime
(
timeUs
)
;
}
}
}
