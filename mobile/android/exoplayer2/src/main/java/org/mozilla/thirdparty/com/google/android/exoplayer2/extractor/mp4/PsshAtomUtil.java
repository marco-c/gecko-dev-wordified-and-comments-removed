package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
UUID
;
public
final
class
PsshAtomUtil
{
private
static
final
String
TAG
=
"
PsshAtomUtil
"
;
private
PsshAtomUtil
(
)
{
}
public
static
byte
[
]
buildPsshAtom
(
UUID
systemId
Nullable
byte
[
]
data
)
{
return
buildPsshAtom
(
systemId
null
data
)
;
}
SuppressWarnings
(
{
"
ParameterNotNullable
"
"
nullness
:
dereference
.
of
.
nullable
"
}
)
public
static
byte
[
]
buildPsshAtom
(
UUID
systemId
Nullable
UUID
[
]
keyIds
Nullable
byte
[
]
data
)
{
int
dataLength
=
data
!
=
null
?
data
.
length
:
0
;
int
psshBoxLength
=
Atom
.
FULL_HEADER_SIZE
+
16
+
4
+
dataLength
;
if
(
keyIds
!
=
null
)
{
psshBoxLength
+
=
4
+
(
keyIds
.
length
*
16
)
;
}
ByteBuffer
psshBox
=
ByteBuffer
.
allocate
(
psshBoxLength
)
;
psshBox
.
putInt
(
psshBoxLength
)
;
psshBox
.
putInt
(
Atom
.
TYPE_pssh
)
;
psshBox
.
putInt
(
keyIds
!
=
null
?
0x01000000
:
0
)
;
psshBox
.
putLong
(
systemId
.
getMostSignificantBits
(
)
)
;
psshBox
.
putLong
(
systemId
.
getLeastSignificantBits
(
)
)
;
if
(
keyIds
!
=
null
)
{
psshBox
.
putInt
(
keyIds
.
length
)
;
for
(
UUID
keyId
:
keyIds
)
{
psshBox
.
putLong
(
keyId
.
getMostSignificantBits
(
)
)
;
psshBox
.
putLong
(
keyId
.
getLeastSignificantBits
(
)
)
;
}
}
if
(
data
!
=
null
&
&
data
.
length
!
=
0
)
{
psshBox
.
putInt
(
data
.
length
)
;
psshBox
.
put
(
data
)
;
}
return
psshBox
.
array
(
)
;
}
public
static
boolean
isPsshAtom
(
byte
[
]
data
)
{
return
parsePsshAtom
(
data
)
!
=
null
;
}
public
static
Nullable
UUID
parseUuid
(
byte
[
]
atom
)
{
PsshAtom
parsedAtom
=
parsePsshAtom
(
atom
)
;
if
(
parsedAtom
=
=
null
)
{
return
null
;
}
return
parsedAtom
.
uuid
;
}
public
static
int
parseVersion
(
byte
[
]
atom
)
{
PsshAtom
parsedAtom
=
parsePsshAtom
(
atom
)
;
if
(
parsedAtom
=
=
null
)
{
return
-
1
;
}
return
parsedAtom
.
version
;
}
public
static
Nullable
byte
[
]
parseSchemeSpecificData
(
byte
[
]
atom
UUID
uuid
)
{
PsshAtom
parsedAtom
=
parsePsshAtom
(
atom
)
;
if
(
parsedAtom
=
=
null
)
{
return
null
;
}
if
(
uuid
!
=
null
&
&
!
uuid
.
equals
(
parsedAtom
.
uuid
)
)
{
Log
.
w
(
TAG
"
UUID
mismatch
.
Expected
:
"
+
uuid
+
"
got
:
"
+
parsedAtom
.
uuid
+
"
.
"
)
;
return
null
;
}
return
parsedAtom
.
schemeData
;
}
private
static
Nullable
PsshAtom
parsePsshAtom
(
byte
[
]
atom
)
{
ParsableByteArray
atomData
=
new
ParsableByteArray
(
atom
)
;
if
(
atomData
.
limit
(
)
<
Atom
.
FULL_HEADER_SIZE
+
16
+
4
)
{
return
null
;
}
atomData
.
setPosition
(
0
)
;
int
atomSize
=
atomData
.
readInt
(
)
;
if
(
atomSize
!
=
atomData
.
bytesLeft
(
)
+
4
)
{
return
null
;
}
int
atomType
=
atomData
.
readInt
(
)
;
if
(
atomType
!
=
Atom
.
TYPE_pssh
)
{
return
null
;
}
int
atomVersion
=
Atom
.
parseFullAtomVersion
(
atomData
.
readInt
(
)
)
;
if
(
atomVersion
>
1
)
{
Log
.
w
(
TAG
"
Unsupported
pssh
version
:
"
+
atomVersion
)
;
return
null
;
}
UUID
uuid
=
new
UUID
(
atomData
.
readLong
(
)
atomData
.
readLong
(
)
)
;
if
(
atomVersion
=
=
1
)
{
int
keyIdCount
=
atomData
.
readUnsignedIntToInt
(
)
;
atomData
.
skipBytes
(
16
*
keyIdCount
)
;
}
int
dataSize
=
atomData
.
readUnsignedIntToInt
(
)
;
if
(
dataSize
!
=
atomData
.
bytesLeft
(
)
)
{
return
null
;
}
byte
[
]
data
=
new
byte
[
dataSize
]
;
atomData
.
readBytes
(
data
0
dataSize
)
;
return
new
PsshAtom
(
uuid
atomVersion
data
)
;
}
private
static
class
PsshAtom
{
private
final
UUID
uuid
;
private
final
int
version
;
private
final
byte
[
]
schemeData
;
public
PsshAtom
(
UUID
uuid
int
version
byte
[
]
schemeData
)
{
this
.
uuid
=
uuid
;
this
.
version
=
version
;
this
.
schemeData
=
schemeData
;
}
}
}
