package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
;
public
final
class
ParsableBitArray
{
public
byte
[
]
data
;
private
int
byteOffset
;
private
int
bitOffset
;
private
int
byteLimit
;
public
ParsableBitArray
(
)
{
data
=
Util
.
EMPTY_BYTE_ARRAY
;
}
public
ParsableBitArray
(
byte
[
]
data
)
{
this
(
data
data
.
length
)
;
}
public
ParsableBitArray
(
byte
[
]
data
int
limit
)
{
this
.
data
=
data
;
byteLimit
=
limit
;
}
public
void
reset
(
byte
[
]
data
)
{
reset
(
data
data
.
length
)
;
}
public
void
reset
(
ParsableByteArray
parsableByteArray
)
{
reset
(
parsableByteArray
.
data
parsableByteArray
.
limit
(
)
)
;
setPosition
(
parsableByteArray
.
getPosition
(
)
*
8
)
;
}
public
void
reset
(
byte
[
]
data
int
limit
)
{
this
.
data
=
data
;
byteOffset
=
0
;
bitOffset
=
0
;
byteLimit
=
limit
;
}
public
int
bitsLeft
(
)
{
return
(
byteLimit
-
byteOffset
)
*
8
-
bitOffset
;
}
public
int
getPosition
(
)
{
return
byteOffset
*
8
+
bitOffset
;
}
public
int
getBytePosition
(
)
{
Assertions
.
checkState
(
bitOffset
=
=
0
)
;
return
byteOffset
;
}
public
void
setPosition
(
int
position
)
{
byteOffset
=
position
/
8
;
bitOffset
=
position
-
(
byteOffset
*
8
)
;
assertValidOffset
(
)
;
}
public
void
skipBit
(
)
{
if
(
+
+
bitOffset
=
=
8
)
{
bitOffset
=
0
;
byteOffset
+
+
;
}
assertValidOffset
(
)
;
}
public
void
skipBits
(
int
numBits
)
{
int
numBytes
=
numBits
/
8
;
byteOffset
+
=
numBytes
;
bitOffset
+
=
numBits
-
(
numBytes
*
8
)
;
if
(
bitOffset
>
7
)
{
byteOffset
+
+
;
bitOffset
-
=
8
;
}
assertValidOffset
(
)
;
}
public
boolean
readBit
(
)
{
boolean
returnValue
=
(
data
[
byteOffset
]
&
(
0x80
>
>
bitOffset
)
)
!
=
0
;
skipBit
(
)
;
return
returnValue
;
}
public
int
readBits
(
int
numBits
)
{
if
(
numBits
=
=
0
)
{
return
0
;
}
int
returnValue
=
0
;
bitOffset
+
=
numBits
;
while
(
bitOffset
>
8
)
{
bitOffset
-
=
8
;
returnValue
|
=
(
data
[
byteOffset
+
+
]
&
0xFF
)
<
<
bitOffset
;
}
returnValue
|
=
(
data
[
byteOffset
]
&
0xFF
)
>
>
(
8
-
bitOffset
)
;
returnValue
&
=
0xFFFFFFFF
>
>
>
(
32
-
numBits
)
;
if
(
bitOffset
=
=
8
)
{
bitOffset
=
0
;
byteOffset
+
+
;
}
assertValidOffset
(
)
;
return
returnValue
;
}
public
long
readBitsToLong
(
int
numBits
)
{
if
(
numBits
<
=
32
)
{
return
Util
.
toUnsignedLong
(
readBits
(
numBits
)
)
;
}
return
Util
.
toLong
(
readBits
(
numBits
-
32
)
readBits
(
32
)
)
;
}
public
void
readBits
(
byte
[
]
buffer
int
offset
int
numBits
)
{
int
to
=
offset
+
(
numBits
>
>
3
)
;
for
(
int
i
=
offset
;
i
<
to
;
i
+
+
)
{
buffer
[
i
]
=
(
byte
)
(
data
[
byteOffset
+
+
]
<
<
bitOffset
)
;
buffer
[
i
]
=
(
byte
)
(
buffer
[
i
]
|
(
(
data
[
byteOffset
]
&
0xFF
)
>
>
(
8
-
bitOffset
)
)
)
;
}
int
bitsLeft
=
numBits
&
7
;
if
(
bitsLeft
=
=
0
)
{
return
;
}
buffer
[
to
]
=
(
byte
)
(
buffer
[
to
]
&
(
0xFF
>
>
bitsLeft
)
)
;
if
(
bitOffset
+
bitsLeft
>
8
)
{
buffer
[
to
]
=
(
byte
)
(
buffer
[
to
]
|
(
(
data
[
byteOffset
+
+
]
&
0xFF
)
<
<
bitOffset
)
)
;
bitOffset
-
=
8
;
}
bitOffset
+
=
bitsLeft
;
int
lastDataByteTrailingBits
=
(
data
[
byteOffset
]
&
0xFF
)
>
>
(
8
-
bitOffset
)
;
buffer
[
to
]
|
=
(
byte
)
(
lastDataByteTrailingBits
<
<
(
8
-
bitsLeft
)
)
;
if
(
bitOffset
=
=
8
)
{
bitOffset
=
0
;
byteOffset
+
+
;
}
assertValidOffset
(
)
;
}
public
void
byteAlign
(
)
{
if
(
bitOffset
=
=
0
)
{
return
;
}
bitOffset
=
0
;
byteOffset
+
+
;
assertValidOffset
(
)
;
}
public
void
readBytes
(
byte
[
]
buffer
int
offset
int
length
)
{
Assertions
.
checkState
(
bitOffset
=
=
0
)
;
System
.
arraycopy
(
data
byteOffset
buffer
offset
length
)
;
byteOffset
+
=
length
;
assertValidOffset
(
)
;
}
public
void
skipBytes
(
int
length
)
{
Assertions
.
checkState
(
bitOffset
=
=
0
)
;
byteOffset
+
=
length
;
assertValidOffset
(
)
;
}
public
void
putInt
(
int
value
int
numBits
)
{
int
remainingBitsToRead
=
numBits
;
if
(
numBits
<
32
)
{
value
&
=
(
1
<
<
numBits
)
-
1
;
}
int
firstByteReadSize
=
Math
.
min
(
8
-
bitOffset
numBits
)
;
int
firstByteRightPaddingSize
=
8
-
bitOffset
-
firstByteReadSize
;
int
firstByteBitmask
=
(
0xFF00
>
>
bitOffset
)
|
(
(
1
<
<
firstByteRightPaddingSize
)
-
1
)
;
data
[
byteOffset
]
=
(
byte
)
(
data
[
byteOffset
]
&
firstByteBitmask
)
;
int
firstByteInputBits
=
value
>
>
>
(
numBits
-
firstByteReadSize
)
;
data
[
byteOffset
]
=
(
byte
)
(
data
[
byteOffset
]
|
(
firstByteInputBits
<
<
firstByteRightPaddingSize
)
)
;
remainingBitsToRead
-
=
firstByteReadSize
;
int
currentByteIndex
=
byteOffset
+
1
;
while
(
remainingBitsToRead
>
8
)
{
data
[
currentByteIndex
+
+
]
=
(
byte
)
(
value
>
>
>
(
remainingBitsToRead
-
8
)
)
;
remainingBitsToRead
-
=
8
;
}
int
lastByteRightPaddingSize
=
8
-
remainingBitsToRead
;
data
[
currentByteIndex
]
=
(
byte
)
(
data
[
currentByteIndex
]
&
(
(
1
<
<
lastByteRightPaddingSize
)
-
1
)
)
;
int
lastByteInput
=
value
&
(
(
1
<
<
remainingBitsToRead
)
-
1
)
;
data
[
currentByteIndex
]
=
(
byte
)
(
data
[
currentByteIndex
]
|
(
lastByteInput
<
<
lastByteRightPaddingSize
)
)
;
skipBits
(
numBits
)
;
assertValidOffset
(
)
;
}
private
void
assertValidOffset
(
)
{
Assertions
.
checkState
(
byteOffset
>
=
0
&
&
(
byteOffset
<
byteLimit
|
|
(
byteOffset
=
=
byteLimit
&
&
bitOffset
=
=
0
)
)
)
;
}
}
