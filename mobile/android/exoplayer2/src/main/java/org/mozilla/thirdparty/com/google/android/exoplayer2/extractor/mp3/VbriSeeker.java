package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
MpegAudioHeader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekPoint
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
final
class
VbriSeeker
implements
Seeker
{
private
static
final
String
TAG
=
"
VbriSeeker
"
;
public
static
Nullable
VbriSeeker
create
(
long
inputLength
long
position
MpegAudioHeader
mpegAudioHeader
ParsableByteArray
frame
)
{
frame
.
skipBytes
(
10
)
;
int
numFrames
=
frame
.
readInt
(
)
;
if
(
numFrames
<
=
0
)
{
return
null
;
}
int
sampleRate
=
mpegAudioHeader
.
sampleRate
;
long
durationUs
=
Util
.
scaleLargeTimestamp
(
numFrames
C
.
MICROS_PER_SECOND
*
(
sampleRate
>
=
32000
?
1152
:
576
)
sampleRate
)
;
int
entryCount
=
frame
.
readUnsignedShort
(
)
;
int
scale
=
frame
.
readUnsignedShort
(
)
;
int
entrySize
=
frame
.
readUnsignedShort
(
)
;
frame
.
skipBytes
(
2
)
;
long
minPosition
=
position
+
mpegAudioHeader
.
frameSize
;
long
[
]
timesUs
=
new
long
[
entryCount
]
;
long
[
]
positions
=
new
long
[
entryCount
]
;
for
(
int
index
=
0
;
index
<
entryCount
;
index
+
+
)
{
timesUs
[
index
]
=
(
index
*
durationUs
)
/
entryCount
;
positions
[
index
]
=
Math
.
max
(
position
minPosition
)
;
int
segmentSize
;
switch
(
entrySize
)
{
case
1
:
segmentSize
=
frame
.
readUnsignedByte
(
)
;
break
;
case
2
:
segmentSize
=
frame
.
readUnsignedShort
(
)
;
break
;
case
3
:
segmentSize
=
frame
.
readUnsignedInt24
(
)
;
break
;
case
4
:
segmentSize
=
frame
.
readUnsignedIntToInt
(
)
;
break
;
default
:
return
null
;
}
position
+
=
segmentSize
*
scale
;
}
if
(
inputLength
!
=
C
.
LENGTH_UNSET
&
&
inputLength
!
=
position
)
{
Log
.
w
(
TAG
"
VBRI
data
size
mismatch
:
"
+
inputLength
+
"
"
+
position
)
;
}
return
new
VbriSeeker
(
timesUs
positions
durationUs
position
)
;
}
private
final
long
[
]
timesUs
;
private
final
long
[
]
positions
;
private
final
long
durationUs
;
private
final
long
dataEndPosition
;
private
VbriSeeker
(
long
[
]
timesUs
long
[
]
positions
long
durationUs
long
dataEndPosition
)
{
this
.
timesUs
=
timesUs
;
this
.
positions
=
positions
;
this
.
durationUs
=
durationUs
;
this
.
dataEndPosition
=
dataEndPosition
;
}
Override
public
boolean
isSeekable
(
)
{
return
true
;
}
Override
public
SeekPoints
getSeekPoints
(
long
timeUs
)
{
int
tableIndex
=
Util
.
binarySearchFloor
(
timesUs
timeUs
true
true
)
;
SeekPoint
seekPoint
=
new
SeekPoint
(
timesUs
[
tableIndex
]
positions
[
tableIndex
]
)
;
if
(
seekPoint
.
timeUs
>
=
timeUs
|
|
tableIndex
=
=
timesUs
.
length
-
1
)
{
return
new
SeekPoints
(
seekPoint
)
;
}
else
{
SeekPoint
nextSeekPoint
=
new
SeekPoint
(
timesUs
[
tableIndex
+
1
]
positions
[
tableIndex
+
1
]
)
;
return
new
SeekPoints
(
seekPoint
nextSeekPoint
)
;
}
}
Override
public
long
getTimeUs
(
long
position
)
{
return
timesUs
[
Util
.
binarySearchFloor
(
positions
position
true
true
)
]
;
}
Override
public
long
getDurationUs
(
)
{
return
durationUs
;
}
Override
public
long
getDataEndPosition
(
)
{
return
dataEndPosition
;
}
}
