package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
offline
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
offline
.
Download
.
STOP_REASON_NONE
;
import
android
.
app
.
Notification
;
import
android
.
app
.
Service
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
os
.
Handler
;
import
android
.
os
.
IBinder
;
import
android
.
os
.
Looper
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
StringRes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
scheduler
.
Requirements
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
scheduler
.
Scheduler
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
NotificationUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
MonotonicNonNull
;
public
abstract
class
DownloadService
extends
Service
{
public
static
final
String
ACTION_INIT
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
INIT
"
;
private
static
final
String
ACTION_RESTART
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
RESTART
"
;
public
static
final
String
ACTION_ADD_DOWNLOAD
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
ADD_DOWNLOAD
"
;
public
static
final
String
ACTION_REMOVE_DOWNLOAD
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
REMOVE_DOWNLOAD
"
;
public
static
final
String
ACTION_REMOVE_ALL_DOWNLOADS
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
REMOVE_ALL_DOWNLOADS
"
;
public
static
final
String
ACTION_RESUME_DOWNLOADS
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
RESUME_DOWNLOADS
"
;
public
static
final
String
ACTION_PAUSE_DOWNLOADS
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
PAUSE_DOWNLOADS
"
;
public
static
final
String
ACTION_SET_STOP_REASON
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
SET_STOP_REASON
"
;
public
static
final
String
ACTION_SET_REQUIREMENTS
=
"
com
.
google
.
android
.
exoplayer
.
downloadService
.
action
.
SET_REQUIREMENTS
"
;
public
static
final
String
KEY_DOWNLOAD_REQUEST
=
"
download_request
"
;
public
static
final
String
KEY_CONTENT_ID
=
"
content_id
"
;
public
static
final
String
KEY_STOP_REASON
=
"
stop_reason
"
;
public
static
final
String
KEY_REQUIREMENTS
=
"
requirements
"
;
public
static
final
String
KEY_FOREGROUND
=
"
foreground
"
;
public
static
final
int
FOREGROUND_NOTIFICATION_ID_NONE
=
0
;
public
static
final
long
DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL
=
1000
;
private
static
final
String
TAG
=
"
DownloadService
"
;
private
static
final
HashMap
<
Class
<
?
extends
DownloadService
>
DownloadManagerHelper
>
downloadManagerHelpers
=
new
HashMap
<
>
(
)
;
Nullable
private
final
ForegroundNotificationUpdater
foregroundNotificationUpdater
;
Nullable
private
final
String
channelId
;
StringRes
private
final
int
channelNameResourceId
;
StringRes
private
final
int
channelDescriptionResourceId
;
MonotonicNonNull
private
DownloadManager
downloadManager
;
private
int
lastStartId
;
private
boolean
startedInForeground
;
private
boolean
taskRemoved
;
private
boolean
isStopped
;
private
boolean
isDestroyed
;
protected
DownloadService
(
int
foregroundNotificationId
)
{
this
(
foregroundNotificationId
DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL
)
;
}
protected
DownloadService
(
int
foregroundNotificationId
long
foregroundNotificationUpdateInterval
)
{
this
(
foregroundNotificationId
foregroundNotificationUpdateInterval
null
0
0
)
;
}
Deprecated
protected
DownloadService
(
int
foregroundNotificationId
long
foregroundNotificationUpdateInterval
Nullable
String
channelId
StringRes
int
channelNameResourceId
)
{
this
(
foregroundNotificationId
foregroundNotificationUpdateInterval
channelId
channelNameResourceId
0
)
;
}
protected
DownloadService
(
int
foregroundNotificationId
long
foregroundNotificationUpdateInterval
Nullable
String
channelId
StringRes
int
channelNameResourceId
StringRes
int
channelDescriptionResourceId
)
{
if
(
foregroundNotificationId
=
=
FOREGROUND_NOTIFICATION_ID_NONE
)
{
this
.
foregroundNotificationUpdater
=
null
;
this
.
channelId
=
null
;
this
.
channelNameResourceId
=
0
;
this
.
channelDescriptionResourceId
=
0
;
}
else
{
this
.
foregroundNotificationUpdater
=
new
ForegroundNotificationUpdater
(
foregroundNotificationId
foregroundNotificationUpdateInterval
)
;
this
.
channelId
=
channelId
;
this
.
channelNameResourceId
=
channelNameResourceId
;
this
.
channelDescriptionResourceId
=
channelDescriptionResourceId
;
}
}
public
static
Intent
buildAddDownloadIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
DownloadRequest
downloadRequest
boolean
foreground
)
{
return
buildAddDownloadIntent
(
context
clazz
downloadRequest
STOP_REASON_NONE
foreground
)
;
}
public
static
Intent
buildAddDownloadIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
DownloadRequest
downloadRequest
int
stopReason
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_ADD_DOWNLOAD
foreground
)
.
putExtra
(
KEY_DOWNLOAD_REQUEST
downloadRequest
)
.
putExtra
(
KEY_STOP_REASON
stopReason
)
;
}
public
static
Intent
buildRemoveDownloadIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
String
id
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_REMOVE_DOWNLOAD
foreground
)
.
putExtra
(
KEY_CONTENT_ID
id
)
;
}
public
static
Intent
buildRemoveAllDownloadsIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_REMOVE_ALL_DOWNLOADS
foreground
)
;
}
public
static
Intent
buildResumeDownloadsIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_RESUME_DOWNLOADS
foreground
)
;
}
public
static
Intent
buildPauseDownloadsIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_PAUSE_DOWNLOADS
foreground
)
;
}
public
static
Intent
buildSetStopReasonIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
Nullable
String
id
int
stopReason
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_SET_STOP_REASON
foreground
)
.
putExtra
(
KEY_CONTENT_ID
id
)
.
putExtra
(
KEY_STOP_REASON
stopReason
)
;
}
public
static
Intent
buildSetRequirementsIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
Requirements
requirements
boolean
foreground
)
{
return
getIntent
(
context
clazz
ACTION_SET_REQUIREMENTS
foreground
)
.
putExtra
(
KEY_REQUIREMENTS
requirements
)
;
}
public
static
void
sendAddDownload
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
DownloadRequest
downloadRequest
boolean
foreground
)
{
Intent
intent
=
buildAddDownloadIntent
(
context
clazz
downloadRequest
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendAddDownload
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
DownloadRequest
downloadRequest
int
stopReason
boolean
foreground
)
{
Intent
intent
=
buildAddDownloadIntent
(
context
clazz
downloadRequest
stopReason
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendRemoveDownload
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
String
id
boolean
foreground
)
{
Intent
intent
=
buildRemoveDownloadIntent
(
context
clazz
id
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendRemoveAllDownloads
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
boolean
foreground
)
{
Intent
intent
=
buildRemoveAllDownloadsIntent
(
context
clazz
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendResumeDownloads
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
boolean
foreground
)
{
Intent
intent
=
buildResumeDownloadsIntent
(
context
clazz
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendPauseDownloads
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
boolean
foreground
)
{
Intent
intent
=
buildPauseDownloadsIntent
(
context
clazz
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendSetStopReason
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
Nullable
String
id
int
stopReason
boolean
foreground
)
{
Intent
intent
=
buildSetStopReasonIntent
(
context
clazz
id
stopReason
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
sendSetRequirements
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
Requirements
requirements
boolean
foreground
)
{
Intent
intent
=
buildSetRequirementsIntent
(
context
clazz
requirements
foreground
)
;
startService
(
context
intent
foreground
)
;
}
public
static
void
start
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
)
{
context
.
startService
(
getIntent
(
context
clazz
ACTION_INIT
)
)
;
}
public
static
void
startForeground
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
)
{
Intent
intent
=
getIntent
(
context
clazz
ACTION_INIT
true
)
;
Util
.
startForegroundService
(
context
intent
)
;
}
Override
public
void
onCreate
(
)
{
if
(
channelId
!
=
null
)
{
NotificationUtil
.
createNotificationChannel
(
this
channelId
channelNameResourceId
channelDescriptionResourceId
NotificationUtil
.
IMPORTANCE_LOW
)
;
}
Class
<
?
extends
DownloadService
>
clazz
=
getClass
(
)
;
Nullable
DownloadManagerHelper
downloadManagerHelper
=
downloadManagerHelpers
.
get
(
clazz
)
;
if
(
downloadManagerHelper
=
=
null
)
{
boolean
foregroundAllowed
=
foregroundNotificationUpdater
!
=
null
;
Nullable
Scheduler
scheduler
=
foregroundAllowed
?
getScheduler
(
)
:
null
;
downloadManager
=
getDownloadManager
(
)
;
downloadManager
.
resumeDownloads
(
)
;
downloadManagerHelper
=
new
DownloadManagerHelper
(
getApplicationContext
(
)
downloadManager
foregroundAllowed
scheduler
clazz
)
;
downloadManagerHelpers
.
put
(
clazz
downloadManagerHelper
)
;
}
else
{
downloadManager
=
downloadManagerHelper
.
downloadManager
;
}
downloadManagerHelper
.
attachService
(
this
)
;
}
Override
public
int
onStartCommand
(
Nullable
Intent
intent
int
flags
int
startId
)
{
lastStartId
=
startId
;
taskRemoved
=
false
;
Nullable
String
intentAction
=
null
;
Nullable
String
contentId
=
null
;
if
(
intent
!
=
null
)
{
intentAction
=
intent
.
getAction
(
)
;
contentId
=
intent
.
getStringExtra
(
KEY_CONTENT_ID
)
;
startedInForeground
|
=
intent
.
getBooleanExtra
(
KEY_FOREGROUND
false
)
|
|
ACTION_RESTART
.
equals
(
intentAction
)
;
}
if
(
intentAction
=
=
null
)
{
intentAction
=
ACTION_INIT
;
}
DownloadManager
downloadManager
=
Assertions
.
checkNotNull
(
this
.
downloadManager
)
;
switch
(
intentAction
)
{
case
ACTION_INIT
:
case
ACTION_RESTART
:
break
;
case
ACTION_ADD_DOWNLOAD
:
Nullable
DownloadRequest
downloadRequest
=
Assertions
.
checkNotNull
(
intent
)
.
getParcelableExtra
(
KEY_DOWNLOAD_REQUEST
)
;
if
(
downloadRequest
=
=
null
)
{
Log
.
e
(
TAG
"
Ignored
ADD_DOWNLOAD
:
Missing
"
+
KEY_DOWNLOAD_REQUEST
+
"
extra
"
)
;
}
else
{
int
stopReason
=
intent
.
getIntExtra
(
KEY_STOP_REASON
Download
.
STOP_REASON_NONE
)
;
downloadManager
.
addDownload
(
downloadRequest
stopReason
)
;
}
break
;
case
ACTION_REMOVE_DOWNLOAD
:
if
(
contentId
=
=
null
)
{
Log
.
e
(
TAG
"
Ignored
REMOVE_DOWNLOAD
:
Missing
"
+
KEY_CONTENT_ID
+
"
extra
"
)
;
}
else
{
downloadManager
.
removeDownload
(
contentId
)
;
}
break
;
case
ACTION_REMOVE_ALL_DOWNLOADS
:
downloadManager
.
removeAllDownloads
(
)
;
break
;
case
ACTION_RESUME_DOWNLOADS
:
downloadManager
.
resumeDownloads
(
)
;
break
;
case
ACTION_PAUSE_DOWNLOADS
:
downloadManager
.
pauseDownloads
(
)
;
break
;
case
ACTION_SET_STOP_REASON
:
if
(
!
Assertions
.
checkNotNull
(
intent
)
.
hasExtra
(
KEY_STOP_REASON
)
)
{
Log
.
e
(
TAG
"
Ignored
SET_STOP_REASON
:
Missing
"
+
KEY_STOP_REASON
+
"
extra
"
)
;
}
else
{
int
stopReason
=
intent
.
getIntExtra
(
KEY_STOP_REASON
0
)
;
downloadManager
.
setStopReason
(
contentId
stopReason
)
;
}
break
;
case
ACTION_SET_REQUIREMENTS
:
Nullable
Requirements
requirements
=
Assertions
.
checkNotNull
(
intent
)
.
getParcelableExtra
(
KEY_REQUIREMENTS
)
;
if
(
requirements
=
=
null
)
{
Log
.
e
(
TAG
"
Ignored
SET_REQUIREMENTS
:
Missing
"
+
KEY_REQUIREMENTS
+
"
extra
"
)
;
}
else
{
downloadManager
.
setRequirements
(
requirements
)
;
}
break
;
default
:
Log
.
e
(
TAG
"
Ignored
unrecognized
action
:
"
+
intentAction
)
;
break
;
}
if
(
Util
.
SDK_INT
>
=
26
&
&
startedInForeground
&
&
foregroundNotificationUpdater
!
=
null
)
{
foregroundNotificationUpdater
.
showNotificationIfNotAlready
(
)
;
}
isStopped
=
false
;
if
(
downloadManager
.
isIdle
(
)
)
{
stop
(
)
;
}
return
START_STICKY
;
}
Override
public
void
onTaskRemoved
(
Intent
rootIntent
)
{
taskRemoved
=
true
;
}
Override
public
void
onDestroy
(
)
{
isDestroyed
=
true
;
DownloadManagerHelper
downloadManagerHelper
=
Assertions
.
checkNotNull
(
downloadManagerHelpers
.
get
(
getClass
(
)
)
)
;
downloadManagerHelper
.
detachService
(
this
)
;
if
(
foregroundNotificationUpdater
!
=
null
)
{
foregroundNotificationUpdater
.
stopPeriodicUpdates
(
)
;
}
}
Nullable
Override
public
final
IBinder
onBind
(
Intent
intent
)
{
throw
new
UnsupportedOperationException
(
)
;
}
protected
abstract
DownloadManager
getDownloadManager
(
)
;
Nullable
protected
abstract
Scheduler
getScheduler
(
)
;
protected
abstract
Notification
getForegroundNotification
(
List
<
Download
>
downloads
)
;
protected
final
void
invalidateForegroundNotification
(
)
{
if
(
foregroundNotificationUpdater
!
=
null
&
&
!
isDestroyed
)
{
foregroundNotificationUpdater
.
invalidate
(
)
;
}
}
Deprecated
protected
void
onDownloadChanged
(
Download
download
)
{
}
Deprecated
protected
void
onDownloadRemoved
(
Download
download
)
{
}
private
void
notifyDownloads
(
List
<
Download
>
downloads
)
{
if
(
foregroundNotificationUpdater
!
=
null
)
{
for
(
int
i
=
0
;
i
<
downloads
.
size
(
)
;
i
+
+
)
{
if
(
needsStartedService
(
downloads
.
get
(
i
)
.
state
)
)
{
foregroundNotificationUpdater
.
startPeriodicUpdates
(
)
;
break
;
}
}
}
}
SuppressWarnings
(
"
deprecation
"
)
private
void
notifyDownloadChanged
(
Download
download
)
{
onDownloadChanged
(
download
)
;
if
(
foregroundNotificationUpdater
!
=
null
)
{
if
(
needsStartedService
(
download
.
state
)
)
{
foregroundNotificationUpdater
.
startPeriodicUpdates
(
)
;
}
else
{
foregroundNotificationUpdater
.
invalidate
(
)
;
}
}
}
SuppressWarnings
(
"
deprecation
"
)
private
void
notifyDownloadRemoved
(
Download
download
)
{
onDownloadRemoved
(
download
)
;
if
(
foregroundNotificationUpdater
!
=
null
)
{
foregroundNotificationUpdater
.
invalidate
(
)
;
}
}
private
boolean
isStopped
(
)
{
return
isStopped
;
}
private
void
stop
(
)
{
if
(
foregroundNotificationUpdater
!
=
null
)
{
foregroundNotificationUpdater
.
stopPeriodicUpdates
(
)
;
}
if
(
Util
.
SDK_INT
<
28
&
&
taskRemoved
)
{
stopSelf
(
)
;
isStopped
=
true
;
}
else
{
isStopped
|
=
stopSelfResult
(
lastStartId
)
;
}
}
private
static
boolean
needsStartedService
(
Download
.
State
int
state
)
{
return
state
=
=
Download
.
STATE_DOWNLOADING
|
|
state
=
=
Download
.
STATE_REMOVING
|
|
state
=
=
Download
.
STATE_RESTARTING
;
}
private
static
Intent
getIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
String
action
boolean
foreground
)
{
return
getIntent
(
context
clazz
action
)
.
putExtra
(
KEY_FOREGROUND
foreground
)
;
}
private
static
Intent
getIntent
(
Context
context
Class
<
?
extends
DownloadService
>
clazz
String
action
)
{
return
new
Intent
(
context
clazz
)
.
setAction
(
action
)
;
}
private
static
void
startService
(
Context
context
Intent
intent
boolean
foreground
)
{
if
(
foreground
)
{
Util
.
startForegroundService
(
context
intent
)
;
}
else
{
context
.
startService
(
intent
)
;
}
}
private
final
class
ForegroundNotificationUpdater
{
private
final
int
notificationId
;
private
final
long
updateInterval
;
private
final
Handler
handler
;
private
boolean
periodicUpdatesStarted
;
private
boolean
notificationDisplayed
;
public
ForegroundNotificationUpdater
(
int
notificationId
long
updateInterval
)
{
this
.
notificationId
=
notificationId
;
this
.
updateInterval
=
updateInterval
;
this
.
handler
=
new
Handler
(
Looper
.
getMainLooper
(
)
)
;
}
public
void
startPeriodicUpdates
(
)
{
periodicUpdatesStarted
=
true
;
update
(
)
;
}
public
void
stopPeriodicUpdates
(
)
{
periodicUpdatesStarted
=
false
;
handler
.
removeCallbacksAndMessages
(
null
)
;
}
public
void
showNotificationIfNotAlready
(
)
{
if
(
!
notificationDisplayed
)
{
update
(
)
;
}
}
public
void
invalidate
(
)
{
if
(
notificationDisplayed
)
{
update
(
)
;
}
}
private
void
update
(
)
{
List
<
Download
>
downloads
=
Assertions
.
checkNotNull
(
downloadManager
)
.
getCurrentDownloads
(
)
;
startForeground
(
notificationId
getForegroundNotification
(
downloads
)
)
;
notificationDisplayed
=
true
;
if
(
periodicUpdatesStarted
)
{
handler
.
removeCallbacksAndMessages
(
null
)
;
handler
.
postDelayed
(
this
:
:
update
updateInterval
)
;
}
}
}
private
static
final
class
DownloadManagerHelper
implements
DownloadManager
.
Listener
{
private
final
Context
context
;
private
final
DownloadManager
downloadManager
;
private
final
boolean
foregroundAllowed
;
Nullable
private
final
Scheduler
scheduler
;
private
final
Class
<
?
extends
DownloadService
>
serviceClass
;
Nullable
private
DownloadService
downloadService
;
private
DownloadManagerHelper
(
Context
context
DownloadManager
downloadManager
boolean
foregroundAllowed
Nullable
Scheduler
scheduler
Class
<
?
extends
DownloadService
>
serviceClass
)
{
this
.
context
=
context
;
this
.
downloadManager
=
downloadManager
;
this
.
foregroundAllowed
=
foregroundAllowed
;
this
.
scheduler
=
scheduler
;
this
.
serviceClass
=
serviceClass
;
downloadManager
.
addListener
(
this
)
;
updateScheduler
(
)
;
}
public
void
attachService
(
DownloadService
downloadService
)
{
Assertions
.
checkState
(
this
.
downloadService
=
=
null
)
;
this
.
downloadService
=
downloadService
;
if
(
downloadManager
.
isInitialized
(
)
)
{
new
Handler
(
)
.
postAtFrontOfQueue
(
(
)
-
>
downloadService
.
notifyDownloads
(
downloadManager
.
getCurrentDownloads
(
)
)
)
;
}
}
public
void
detachService
(
DownloadService
downloadService
)
{
Assertions
.
checkState
(
this
.
downloadService
=
=
downloadService
)
;
this
.
downloadService
=
null
;
if
(
scheduler
!
=
null
&
&
!
downloadManager
.
isWaitingForRequirements
(
)
)
{
scheduler
.
cancel
(
)
;
}
}
Override
public
void
onInitialized
(
DownloadManager
downloadManager
)
{
if
(
downloadService
!
=
null
)
{
downloadService
.
notifyDownloads
(
downloadManager
.
getCurrentDownloads
(
)
)
;
}
}
Override
public
void
onDownloadChanged
(
DownloadManager
downloadManager
Download
download
)
{
if
(
downloadService
!
=
null
)
{
downloadService
.
notifyDownloadChanged
(
download
)
;
}
if
(
serviceMayNeedRestart
(
)
&
&
needsStartedService
(
download
.
state
)
)
{
Log
.
w
(
TAG
"
DownloadService
wasn
'
t
running
.
Restarting
.
"
)
;
restartService
(
)
;
}
}
Override
public
void
onDownloadRemoved
(
DownloadManager
downloadManager
Download
download
)
{
if
(
downloadService
!
=
null
)
{
downloadService
.
notifyDownloadRemoved
(
download
)
;
}
}
Override
public
final
void
onIdle
(
DownloadManager
downloadManager
)
{
if
(
downloadService
!
=
null
)
{
downloadService
.
stop
(
)
;
}
}
Override
public
void
onWaitingForRequirementsChanged
(
DownloadManager
downloadManager
boolean
waitingForRequirements
)
{
if
(
!
waitingForRequirements
&
&
!
downloadManager
.
getDownloadsPaused
(
)
&
&
serviceMayNeedRestart
(
)
)
{
List
<
Download
>
downloads
=
downloadManager
.
getCurrentDownloads
(
)
;
for
(
int
i
=
0
;
i
<
downloads
.
size
(
)
;
i
+
+
)
{
if
(
downloads
.
get
(
i
)
.
state
=
=
Download
.
STATE_QUEUED
)
{
restartService
(
)
;
break
;
}
}
}
updateScheduler
(
)
;
}
private
boolean
serviceMayNeedRestart
(
)
{
return
downloadService
=
=
null
|
|
downloadService
.
isStopped
(
)
;
}
private
void
restartService
(
)
{
if
(
foregroundAllowed
)
{
Intent
intent
=
getIntent
(
context
serviceClass
DownloadService
.
ACTION_RESTART
)
;
Util
.
startForegroundService
(
context
intent
)
;
}
else
{
try
{
Intent
intent
=
getIntent
(
context
serviceClass
DownloadService
.
ACTION_INIT
)
;
context
.
startService
(
intent
)
;
}
catch
(
IllegalArgumentException
e
)
{
Log
.
w
(
TAG
"
Failed
to
restart
DownloadService
(
process
is
idle
)
.
"
)
;
}
}
}
private
void
updateScheduler
(
)
{
if
(
scheduler
=
=
null
)
{
return
;
}
if
(
downloadManager
.
isWaitingForRequirements
(
)
)
{
String
servicePackage
=
context
.
getPackageName
(
)
;
Requirements
requirements
=
downloadManager
.
getRequirements
(
)
;
boolean
success
=
scheduler
.
schedule
(
requirements
servicePackage
ACTION_RESTART
)
;
if
(
!
success
)
{
Log
.
e
(
TAG
"
Scheduling
downloads
failed
.
"
)
;
}
}
else
{
scheduler
.
cancel
(
)
;
}
}
}
}
