package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
BinarySearchSeeker
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
final
class
PsBinarySearchSeeker
extends
BinarySearchSeeker
{
private
static
final
long
SEEK_TOLERANCE_US
=
100_000
;
private
static
final
int
MINIMUM_SEARCH_RANGE_BYTES
=
1000
;
private
static
final
int
TIMESTAMP_SEARCH_BYTES
=
20000
;
public
PsBinarySearchSeeker
(
TimestampAdjuster
scrTimestampAdjuster
long
streamDurationUs
long
inputLength
)
{
super
(
new
DefaultSeekTimestampConverter
(
)
new
PsScrSeeker
(
scrTimestampAdjuster
)
streamDurationUs
0
streamDurationUs
+
1
0
inputLength
TsExtractor
.
TS_PACKET_SIZE
MINIMUM_SEARCH_RANGE_BYTES
)
;
}
private
static
final
class
PsScrSeeker
implements
TimestampSeeker
{
private
final
TimestampAdjuster
scrTimestampAdjuster
;
private
final
ParsableByteArray
packetBuffer
;
private
PsScrSeeker
(
TimestampAdjuster
scrTimestampAdjuster
)
{
this
.
scrTimestampAdjuster
=
scrTimestampAdjuster
;
packetBuffer
=
new
ParsableByteArray
(
)
;
}
Override
public
TimestampSearchResult
searchForTimestamp
(
ExtractorInput
input
long
targetTimestamp
)
throws
IOException
InterruptedException
{
long
inputPosition
=
input
.
getPosition
(
)
;
int
bytesToSearch
=
(
int
)
Math
.
min
(
TIMESTAMP_SEARCH_BYTES
input
.
getLength
(
)
-
inputPosition
)
;
packetBuffer
.
reset
(
bytesToSearch
)
;
input
.
peekFully
(
packetBuffer
.
data
0
bytesToSearch
)
;
return
searchForScrValueInBuffer
(
packetBuffer
targetTimestamp
inputPosition
)
;
}
Override
public
void
onSeekFinished
(
)
{
packetBuffer
.
reset
(
Util
.
EMPTY_BYTE_ARRAY
)
;
}
private
TimestampSearchResult
searchForScrValueInBuffer
(
ParsableByteArray
packetBuffer
long
targetScrTimeUs
long
bufferStartOffset
)
{
int
startOfLastPacketPosition
=
C
.
POSITION_UNSET
;
int
endOfLastPacketPosition
=
C
.
POSITION_UNSET
;
long
lastScrTimeUsInRange
=
C
.
TIME_UNSET
;
while
(
packetBuffer
.
bytesLeft
(
)
>
=
4
)
{
int
nextStartCode
=
peekIntAtPosition
(
packetBuffer
.
data
packetBuffer
.
getPosition
(
)
)
;
if
(
nextStartCode
!
=
PsExtractor
.
PACK_START_CODE
)
{
packetBuffer
.
skipBytes
(
1
)
;
continue
;
}
else
{
packetBuffer
.
skipBytes
(
4
)
;
}
long
scrValue
=
PsDurationReader
.
readScrValueFromPack
(
packetBuffer
)
;
if
(
scrValue
!
=
C
.
TIME_UNSET
)
{
long
scrTimeUs
=
scrTimestampAdjuster
.
adjustTsTimestamp
(
scrValue
)
;
if
(
scrTimeUs
>
targetScrTimeUs
)
{
if
(
lastScrTimeUsInRange
=
=
C
.
TIME_UNSET
)
{
return
TimestampSearchResult
.
overestimatedResult
(
scrTimeUs
bufferStartOffset
)
;
}
else
{
return
TimestampSearchResult
.
targetFoundResult
(
bufferStartOffset
+
startOfLastPacketPosition
)
;
}
}
else
if
(
scrTimeUs
+
SEEK_TOLERANCE_US
>
targetScrTimeUs
)
{
long
startOfPacketInStream
=
bufferStartOffset
+
packetBuffer
.
getPosition
(
)
;
return
TimestampSearchResult
.
targetFoundResult
(
startOfPacketInStream
)
;
}
lastScrTimeUsInRange
=
scrTimeUs
;
startOfLastPacketPosition
=
packetBuffer
.
getPosition
(
)
;
}
skipToEndOfCurrentPack
(
packetBuffer
)
;
endOfLastPacketPosition
=
packetBuffer
.
getPosition
(
)
;
}
if
(
lastScrTimeUsInRange
!
=
C
.
TIME_UNSET
)
{
long
endOfLastPacketPositionInStream
=
bufferStartOffset
+
endOfLastPacketPosition
;
return
TimestampSearchResult
.
underestimatedResult
(
lastScrTimeUsInRange
endOfLastPacketPositionInStream
)
;
}
else
{
return
TimestampSearchResult
.
NO_TIMESTAMP_IN_RANGE_RESULT
;
}
}
private
static
void
skipToEndOfCurrentPack
(
ParsableByteArray
packetBuffer
)
{
int
limit
=
packetBuffer
.
limit
(
)
;
if
(
packetBuffer
.
bytesLeft
(
)
<
10
)
{
packetBuffer
.
setPosition
(
limit
)
;
return
;
}
packetBuffer
.
skipBytes
(
9
)
;
int
packStuffingLength
=
packetBuffer
.
readUnsignedByte
(
)
&
0x07
;
if
(
packetBuffer
.
bytesLeft
(
)
<
packStuffingLength
)
{
packetBuffer
.
setPosition
(
limit
)
;
return
;
}
packetBuffer
.
skipBytes
(
packStuffingLength
)
;
if
(
packetBuffer
.
bytesLeft
(
)
<
4
)
{
packetBuffer
.
setPosition
(
limit
)
;
return
;
}
int
nextStartCode
=
peekIntAtPosition
(
packetBuffer
.
data
packetBuffer
.
getPosition
(
)
)
;
if
(
nextStartCode
=
=
PsExtractor
.
SYSTEM_HEADER_START_CODE
)
{
packetBuffer
.
skipBytes
(
4
)
;
int
systemHeaderLength
=
packetBuffer
.
readUnsignedShort
(
)
;
if
(
packetBuffer
.
bytesLeft
(
)
<
systemHeaderLength
)
{
packetBuffer
.
setPosition
(
limit
)
;
return
;
}
packetBuffer
.
skipBytes
(
systemHeaderLength
)
;
}
while
(
packetBuffer
.
bytesLeft
(
)
>
=
4
)
{
nextStartCode
=
peekIntAtPosition
(
packetBuffer
.
data
packetBuffer
.
getPosition
(
)
)
;
if
(
nextStartCode
=
=
PsExtractor
.
PACK_START_CODE
|
|
nextStartCode
=
=
PsExtractor
.
MPEG_PROGRAM_END_CODE
)
{
break
;
}
if
(
nextStartCode
>
>
>
8
!
=
PsExtractor
.
PACKET_START_CODE_PREFIX
)
{
break
;
}
packetBuffer
.
skipBytes
(
4
)
;
if
(
packetBuffer
.
bytesLeft
(
)
<
2
)
{
packetBuffer
.
setPosition
(
limit
)
;
return
;
}
int
pesPacketLength
=
packetBuffer
.
readUnsignedShort
(
)
;
packetBuffer
.
setPosition
(
Math
.
min
(
packetBuffer
.
limit
(
)
packetBuffer
.
getPosition
(
)
+
pesPacketLength
)
)
;
}
}
}
private
static
int
peekIntAtPosition
(
byte
[
]
data
int
position
)
{
return
(
data
[
position
]
&
0xFF
)
<
<
24
|
(
data
[
position
+
1
]
&
0xFF
)
<
<
16
|
(
data
[
position
+
2
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
3
]
&
0xFF
)
;
}
}
