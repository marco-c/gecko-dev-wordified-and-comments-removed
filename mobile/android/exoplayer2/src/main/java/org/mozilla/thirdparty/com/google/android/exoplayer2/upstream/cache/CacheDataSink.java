package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSink
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
.
Cache
.
CacheException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ReusableBufferedOutputStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
public
final
class
CacheDataSink
implements
DataSink
{
public
static
final
long
DEFAULT_FRAGMENT_SIZE
=
5
*
1024
*
1024
;
public
static
final
int
DEFAULT_BUFFER_SIZE
=
20
*
1024
;
private
static
final
long
MIN_RECOMMENDED_FRAGMENT_SIZE
=
2
*
1024
*
1024
;
private
static
final
String
TAG
=
"
CacheDataSink
"
;
private
final
Cache
cache
;
private
final
long
fragmentSize
;
private
final
int
bufferSize
;
private
DataSpec
dataSpec
;
private
long
dataSpecFragmentSize
;
private
File
file
;
private
OutputStream
outputStream
;
private
long
outputStreamBytesWritten
;
private
long
dataSpecBytesWritten
;
private
ReusableBufferedOutputStream
bufferedOutputStream
;
public
static
class
CacheDataSinkException
extends
CacheException
{
public
CacheDataSinkException
(
IOException
cause
)
{
super
(
cause
)
;
}
}
public
CacheDataSink
(
Cache
cache
long
fragmentSize
)
{
this
(
cache
fragmentSize
DEFAULT_BUFFER_SIZE
)
;
}
public
CacheDataSink
(
Cache
cache
long
fragmentSize
int
bufferSize
)
{
Assertions
.
checkState
(
fragmentSize
>
0
|
|
fragmentSize
=
=
C
.
LENGTH_UNSET
"
fragmentSize
must
be
positive
or
C
.
LENGTH_UNSET
.
"
)
;
if
(
fragmentSize
!
=
C
.
LENGTH_UNSET
&
&
fragmentSize
<
MIN_RECOMMENDED_FRAGMENT_SIZE
)
{
Log
.
w
(
TAG
"
fragmentSize
is
below
the
minimum
recommended
value
of
"
+
MIN_RECOMMENDED_FRAGMENT_SIZE
+
"
.
This
may
cause
poor
cache
performance
.
"
)
;
}
this
.
cache
=
Assertions
.
checkNotNull
(
cache
)
;
this
.
fragmentSize
=
fragmentSize
=
=
C
.
LENGTH_UNSET
?
Long
.
MAX_VALUE
:
fragmentSize
;
this
.
bufferSize
=
bufferSize
;
}
Override
public
void
open
(
DataSpec
dataSpec
)
throws
CacheDataSinkException
{
if
(
dataSpec
.
length
=
=
C
.
LENGTH_UNSET
&
&
dataSpec
.
isFlagSet
(
DataSpec
.
FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN
)
)
{
this
.
dataSpec
=
null
;
return
;
}
this
.
dataSpec
=
dataSpec
;
this
.
dataSpecFragmentSize
=
dataSpec
.
isFlagSet
(
DataSpec
.
FLAG_ALLOW_CACHE_FRAGMENTATION
)
?
fragmentSize
:
Long
.
MAX_VALUE
;
dataSpecBytesWritten
=
0
;
try
{
openNextOutputStream
(
)
;
}
catch
(
IOException
e
)
{
throw
new
CacheDataSinkException
(
e
)
;
}
}
Override
public
void
write
(
byte
[
]
buffer
int
offset
int
length
)
throws
CacheDataSinkException
{
if
(
dataSpec
=
=
null
)
{
return
;
}
try
{
int
bytesWritten
=
0
;
while
(
bytesWritten
<
length
)
{
if
(
outputStreamBytesWritten
=
=
dataSpecFragmentSize
)
{
closeCurrentOutputStream
(
)
;
openNextOutputStream
(
)
;
}
int
bytesToWrite
=
(
int
)
Math
.
min
(
length
-
bytesWritten
dataSpecFragmentSize
-
outputStreamBytesWritten
)
;
outputStream
.
write
(
buffer
offset
+
bytesWritten
bytesToWrite
)
;
bytesWritten
+
=
bytesToWrite
;
outputStreamBytesWritten
+
=
bytesToWrite
;
dataSpecBytesWritten
+
=
bytesToWrite
;
}
}
catch
(
IOException
e
)
{
throw
new
CacheDataSinkException
(
e
)
;
}
}
Override
public
void
close
(
)
throws
CacheDataSinkException
{
if
(
dataSpec
=
=
null
)
{
return
;
}
try
{
closeCurrentOutputStream
(
)
;
}
catch
(
IOException
e
)
{
throw
new
CacheDataSinkException
(
e
)
;
}
}
private
void
openNextOutputStream
(
)
throws
IOException
{
long
length
=
dataSpec
.
length
=
=
C
.
LENGTH_UNSET
?
C
.
LENGTH_UNSET
:
Math
.
min
(
dataSpec
.
length
-
dataSpecBytesWritten
dataSpecFragmentSize
)
;
file
=
cache
.
startFile
(
dataSpec
.
key
dataSpec
.
absoluteStreamPosition
+
dataSpecBytesWritten
length
)
;
FileOutputStream
underlyingFileOutputStream
=
new
FileOutputStream
(
file
)
;
if
(
bufferSize
>
0
)
{
if
(
bufferedOutputStream
=
=
null
)
{
bufferedOutputStream
=
new
ReusableBufferedOutputStream
(
underlyingFileOutputStream
bufferSize
)
;
}
else
{
bufferedOutputStream
.
reset
(
underlyingFileOutputStream
)
;
}
outputStream
=
bufferedOutputStream
;
}
else
{
outputStream
=
underlyingFileOutputStream
;
}
outputStreamBytesWritten
=
0
;
}
private
void
closeCurrentOutputStream
(
)
throws
IOException
{
if
(
outputStream
=
=
null
)
{
return
;
}
boolean
success
=
false
;
try
{
outputStream
.
flush
(
)
;
success
=
true
;
}
finally
{
Util
.
closeQuietly
(
outputStream
)
;
outputStream
=
null
;
File
fileToCommit
=
file
;
file
=
null
;
if
(
success
)
{
cache
.
commitFile
(
fileToCommit
outputStreamBytesWritten
)
;
}
else
{
fileToCommit
.
delete
(
)
;
}
}
}
}
