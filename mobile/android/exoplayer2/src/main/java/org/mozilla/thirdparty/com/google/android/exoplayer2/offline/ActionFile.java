package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
offline
;
import
android
.
net
.
Uri
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
offline
.
DownloadRequest
.
UnsupportedRequestException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
AtomicFile
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
DataInputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
Deprecated
final
class
ActionFile
{
private
static
final
int
VERSION
=
0
;
private
final
AtomicFile
atomicFile
;
public
ActionFile
(
File
actionFile
)
{
atomicFile
=
new
AtomicFile
(
actionFile
)
;
}
public
boolean
exists
(
)
{
return
atomicFile
.
exists
(
)
;
}
public
void
delete
(
)
{
atomicFile
.
delete
(
)
;
}
public
DownloadRequest
[
]
load
(
)
throws
IOException
{
if
(
!
exists
(
)
)
{
return
new
DownloadRequest
[
0
]
;
}
Nullable
InputStream
inputStream
=
null
;
try
{
inputStream
=
atomicFile
.
openRead
(
)
;
DataInputStream
dataInputStream
=
new
DataInputStream
(
inputStream
)
;
int
version
=
dataInputStream
.
readInt
(
)
;
if
(
version
>
VERSION
)
{
throw
new
IOException
(
"
Unsupported
action
file
version
:
"
+
version
)
;
}
int
actionCount
=
dataInputStream
.
readInt
(
)
;
ArrayList
<
DownloadRequest
>
actions
=
new
ArrayList
<
>
(
)
;
for
(
int
i
=
0
;
i
<
actionCount
;
i
+
+
)
{
try
{
actions
.
add
(
readDownloadRequest
(
dataInputStream
)
)
;
}
catch
(
UnsupportedRequestException
e
)
{
}
}
return
actions
.
toArray
(
new
DownloadRequest
[
0
]
)
;
}
finally
{
Util
.
closeQuietly
(
inputStream
)
;
}
}
private
static
DownloadRequest
readDownloadRequest
(
DataInputStream
input
)
throws
IOException
{
String
type
=
input
.
readUTF
(
)
;
int
version
=
input
.
readInt
(
)
;
Uri
uri
=
Uri
.
parse
(
input
.
readUTF
(
)
)
;
boolean
isRemoveAction
=
input
.
readBoolean
(
)
;
int
dataLength
=
input
.
readInt
(
)
;
Nullable
byte
[
]
data
;
if
(
dataLength
!
=
0
)
{
data
=
new
byte
[
dataLength
]
;
input
.
readFully
(
data
)
;
}
else
{
data
=
null
;
}
boolean
isLegacyProgressive
=
version
=
=
0
&
&
DownloadRequest
.
TYPE_PROGRESSIVE
.
equals
(
type
)
;
List
<
StreamKey
>
keys
=
new
ArrayList
<
>
(
)
;
if
(
!
isLegacyProgressive
)
{
int
keyCount
=
input
.
readInt
(
)
;
for
(
int
i
=
0
;
i
<
keyCount
;
i
+
+
)
{
keys
.
add
(
readKey
(
type
version
input
)
)
;
}
}
boolean
isLegacySegmented
=
version
<
2
&
&
(
DownloadRequest
.
TYPE_DASH
.
equals
(
type
)
|
|
DownloadRequest
.
TYPE_HLS
.
equals
(
type
)
|
|
DownloadRequest
.
TYPE_SS
.
equals
(
type
)
)
;
Nullable
String
customCacheKey
=
null
;
if
(
!
isLegacySegmented
)
{
customCacheKey
=
input
.
readBoolean
(
)
?
input
.
readUTF
(
)
:
null
;
}
String
id
=
version
<
3
?
generateDownloadId
(
uri
customCacheKey
)
:
input
.
readUTF
(
)
;
if
(
isRemoveAction
)
{
throw
new
UnsupportedRequestException
(
)
;
}
return
new
DownloadRequest
(
id
type
uri
keys
customCacheKey
data
)
;
}
private
static
StreamKey
readKey
(
String
type
int
version
DataInputStream
input
)
throws
IOException
{
int
periodIndex
;
int
groupIndex
;
int
trackIndex
;
if
(
(
DownloadRequest
.
TYPE_HLS
.
equals
(
type
)
|
|
DownloadRequest
.
TYPE_SS
.
equals
(
type
)
)
&
&
version
=
=
0
)
{
periodIndex
=
0
;
groupIndex
=
input
.
readInt
(
)
;
trackIndex
=
input
.
readInt
(
)
;
}
else
{
periodIndex
=
input
.
readInt
(
)
;
groupIndex
=
input
.
readInt
(
)
;
trackIndex
=
input
.
readInt
(
)
;
}
return
new
StreamKey
(
periodIndex
groupIndex
trackIndex
)
;
}
private
static
String
generateDownloadId
(
Uri
uri
Nullable
String
customCacheKey
)
{
return
customCacheKey
!
=
null
?
customCacheKey
:
uri
.
toString
(
)
;
}
}
