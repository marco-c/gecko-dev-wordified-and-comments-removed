package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
public
final
class
DefaultExtractorInput
implements
ExtractorInput
{
private
static
final
int
PEEK_MIN_FREE_SPACE_AFTER_RESIZE
=
64
*
1024
;
private
static
final
int
PEEK_MAX_FREE_SPACE
=
512
*
1024
;
private
static
final
int
SCRATCH_SPACE_SIZE
=
4096
;
private
final
byte
[
]
scratchSpace
;
private
final
DataSource
dataSource
;
private
final
long
streamLength
;
private
long
position
;
private
byte
[
]
peekBuffer
;
private
int
peekBufferPosition
;
private
int
peekBufferLength
;
public
DefaultExtractorInput
(
DataSource
dataSource
long
position
long
length
)
{
this
.
dataSource
=
dataSource
;
this
.
position
=
position
;
this
.
streamLength
=
length
;
peekBuffer
=
new
byte
[
PEEK_MIN_FREE_SPACE_AFTER_RESIZE
]
;
scratchSpace
=
new
byte
[
SCRATCH_SPACE_SIZE
]
;
}
Override
public
int
read
(
byte
[
]
target
int
offset
int
length
)
throws
IOException
InterruptedException
{
int
bytesRead
=
readFromPeekBuffer
(
target
offset
length
)
;
if
(
bytesRead
=
=
0
)
{
bytesRead
=
readFromDataSource
(
target
offset
length
0
true
)
;
}
commitBytesRead
(
bytesRead
)
;
return
bytesRead
;
}
Override
public
boolean
readFully
(
byte
[
]
target
int
offset
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
int
bytesRead
=
readFromPeekBuffer
(
target
offset
length
)
;
while
(
bytesRead
<
length
&
&
bytesRead
!
=
C
.
RESULT_END_OF_INPUT
)
{
bytesRead
=
readFromDataSource
(
target
offset
length
bytesRead
allowEndOfInput
)
;
}
commitBytesRead
(
bytesRead
)
;
return
bytesRead
!
=
C
.
RESULT_END_OF_INPUT
;
}
Override
public
void
readFully
(
byte
[
]
target
int
offset
int
length
)
throws
IOException
InterruptedException
{
readFully
(
target
offset
length
false
)
;
}
Override
public
int
skip
(
int
length
)
throws
IOException
InterruptedException
{
int
bytesSkipped
=
skipFromPeekBuffer
(
length
)
;
if
(
bytesSkipped
=
=
0
)
{
bytesSkipped
=
readFromDataSource
(
scratchSpace
0
Math
.
min
(
length
scratchSpace
.
length
)
0
true
)
;
}
commitBytesRead
(
bytesSkipped
)
;
return
bytesSkipped
;
}
Override
public
boolean
skipFully
(
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
int
bytesSkipped
=
skipFromPeekBuffer
(
length
)
;
while
(
bytesSkipped
<
length
&
&
bytesSkipped
!
=
C
.
RESULT_END_OF_INPUT
)
{
int
minLength
=
Math
.
min
(
length
bytesSkipped
+
scratchSpace
.
length
)
;
bytesSkipped
=
readFromDataSource
(
scratchSpace
-
bytesSkipped
minLength
bytesSkipped
allowEndOfInput
)
;
}
commitBytesRead
(
bytesSkipped
)
;
return
bytesSkipped
!
=
C
.
RESULT_END_OF_INPUT
;
}
Override
public
void
skipFully
(
int
length
)
throws
IOException
InterruptedException
{
skipFully
(
length
false
)
;
}
Override
public
int
peek
(
byte
[
]
target
int
offset
int
length
)
throws
IOException
InterruptedException
{
ensureSpaceForPeek
(
length
)
;
int
peekBufferRemainingBytes
=
peekBufferLength
-
peekBufferPosition
;
int
bytesPeeked
;
if
(
peekBufferRemainingBytes
=
=
0
)
{
bytesPeeked
=
readFromDataSource
(
peekBuffer
peekBufferPosition
length
0
true
)
;
if
(
bytesPeeked
=
=
C
.
RESULT_END_OF_INPUT
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
peekBufferLength
+
=
bytesPeeked
;
}
else
{
bytesPeeked
=
Math
.
min
(
length
peekBufferRemainingBytes
)
;
}
System
.
arraycopy
(
peekBuffer
peekBufferPosition
target
offset
bytesPeeked
)
;
peekBufferPosition
+
=
bytesPeeked
;
return
bytesPeeked
;
}
Override
public
boolean
peekFully
(
byte
[
]
target
int
offset
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
if
(
!
advancePeekPosition
(
length
allowEndOfInput
)
)
{
return
false
;
}
System
.
arraycopy
(
peekBuffer
peekBufferPosition
-
length
target
offset
length
)
;
return
true
;
}
Override
public
void
peekFully
(
byte
[
]
target
int
offset
int
length
)
throws
IOException
InterruptedException
{
peekFully
(
target
offset
length
false
)
;
}
Override
public
boolean
advancePeekPosition
(
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
ensureSpaceForPeek
(
length
)
;
int
bytesPeeked
=
peekBufferLength
-
peekBufferPosition
;
while
(
bytesPeeked
<
length
)
{
bytesPeeked
=
readFromDataSource
(
peekBuffer
peekBufferPosition
length
bytesPeeked
allowEndOfInput
)
;
if
(
bytesPeeked
=
=
C
.
RESULT_END_OF_INPUT
)
{
return
false
;
}
peekBufferLength
=
peekBufferPosition
+
bytesPeeked
;
}
peekBufferPosition
+
=
length
;
return
true
;
}
Override
public
void
advancePeekPosition
(
int
length
)
throws
IOException
InterruptedException
{
advancePeekPosition
(
length
false
)
;
}
Override
public
void
resetPeekPosition
(
)
{
peekBufferPosition
=
0
;
}
Override
public
long
getPeekPosition
(
)
{
return
position
+
peekBufferPosition
;
}
Override
public
long
getPosition
(
)
{
return
position
;
}
Override
public
long
getLength
(
)
{
return
streamLength
;
}
Override
public
<
E
extends
Throwable
>
void
setRetryPosition
(
long
position
E
e
)
throws
E
{
Assertions
.
checkArgument
(
position
>
=
0
)
;
this
.
position
=
position
;
throw
e
;
}
private
void
ensureSpaceForPeek
(
int
length
)
{
int
requiredLength
=
peekBufferPosition
+
length
;
if
(
requiredLength
>
peekBuffer
.
length
)
{
int
newPeekCapacity
=
Util
.
constrainValue
(
peekBuffer
.
length
*
2
requiredLength
+
PEEK_MIN_FREE_SPACE_AFTER_RESIZE
requiredLength
+
PEEK_MAX_FREE_SPACE
)
;
peekBuffer
=
Arrays
.
copyOf
(
peekBuffer
newPeekCapacity
)
;
}
}
private
int
skipFromPeekBuffer
(
int
length
)
{
int
bytesSkipped
=
Math
.
min
(
peekBufferLength
length
)
;
updatePeekBuffer
(
bytesSkipped
)
;
return
bytesSkipped
;
}
private
int
readFromPeekBuffer
(
byte
[
]
target
int
offset
int
length
)
{
if
(
peekBufferLength
=
=
0
)
{
return
0
;
}
int
peekBytes
=
Math
.
min
(
peekBufferLength
length
)
;
System
.
arraycopy
(
peekBuffer
0
target
offset
peekBytes
)
;
updatePeekBuffer
(
peekBytes
)
;
return
peekBytes
;
}
private
void
updatePeekBuffer
(
int
bytesConsumed
)
{
peekBufferLength
-
=
bytesConsumed
;
peekBufferPosition
=
0
;
byte
[
]
newPeekBuffer
=
peekBuffer
;
if
(
peekBufferLength
<
peekBuffer
.
length
-
PEEK_MAX_FREE_SPACE
)
{
newPeekBuffer
=
new
byte
[
peekBufferLength
+
PEEK_MIN_FREE_SPACE_AFTER_RESIZE
]
;
}
System
.
arraycopy
(
peekBuffer
bytesConsumed
newPeekBuffer
0
peekBufferLength
)
;
peekBuffer
=
newPeekBuffer
;
}
private
int
readFromDataSource
(
byte
[
]
target
int
offset
int
length
int
bytesAlreadyRead
boolean
allowEndOfInput
)
throws
InterruptedException
IOException
{
if
(
Thread
.
interrupted
(
)
)
{
throw
new
InterruptedException
(
)
;
}
int
bytesRead
=
dataSource
.
read
(
target
offset
+
bytesAlreadyRead
length
-
bytesAlreadyRead
)
;
if
(
bytesRead
=
=
C
.
RESULT_END_OF_INPUT
)
{
if
(
bytesAlreadyRead
=
=
0
&
&
allowEndOfInput
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
throw
new
EOFException
(
)
;
}
return
bytesAlreadyRead
+
bytesRead
;
}
private
void
commitBytesRead
(
int
bytesRead
)
{
if
(
bytesRead
!
=
C
.
RESULT_END_OF_INPUT
)
{
position
+
=
bytesRead
;
}
}
}
