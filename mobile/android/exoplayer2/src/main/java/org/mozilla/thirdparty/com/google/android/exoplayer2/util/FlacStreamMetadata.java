package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
Metadata
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
flac
.
PictureFrame
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
flac
.
VorbisComment
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
public
final
class
FlacStreamMetadata
{
public
static
class
SeekTable
{
public
final
long
[
]
pointSampleNumbers
;
public
final
long
[
]
pointOffsets
;
public
SeekTable
(
long
[
]
pointSampleNumbers
long
[
]
pointOffsets
)
{
this
.
pointSampleNumbers
=
pointSampleNumbers
;
this
.
pointOffsets
=
pointOffsets
;
}
}
private
static
final
String
TAG
=
"
FlacStreamMetadata
"
;
public
static
final
int
NOT_IN_LOOKUP_TABLE
=
-
1
;
private
static
final
String
SEPARATOR
=
"
=
"
;
public
final
int
minBlockSizeSamples
;
public
final
int
maxBlockSizeSamples
;
public
final
int
minFrameSize
;
public
final
int
maxFrameSize
;
public
final
int
sampleRate
;
public
final
int
sampleRateLookupKey
;
public
final
int
channels
;
public
final
int
bitsPerSample
;
public
final
int
bitsPerSampleLookupKey
;
public
final
long
totalSamples
;
Nullable
public
final
SeekTable
seekTable
;
Nullable
private
final
Metadata
metadata
;
public
FlacStreamMetadata
(
byte
[
]
data
int
offset
)
{
ParsableBitArray
scratch
=
new
ParsableBitArray
(
data
)
;
scratch
.
setPosition
(
offset
*
8
)
;
minBlockSizeSamples
=
scratch
.
readBits
(
16
)
;
maxBlockSizeSamples
=
scratch
.
readBits
(
16
)
;
minFrameSize
=
scratch
.
readBits
(
24
)
;
maxFrameSize
=
scratch
.
readBits
(
24
)
;
sampleRate
=
scratch
.
readBits
(
20
)
;
sampleRateLookupKey
=
getSampleRateLookupKey
(
sampleRate
)
;
channels
=
scratch
.
readBits
(
3
)
+
1
;
bitsPerSample
=
scratch
.
readBits
(
5
)
+
1
;
bitsPerSampleLookupKey
=
getBitsPerSampleLookupKey
(
bitsPerSample
)
;
totalSamples
=
scratch
.
readBitsToLong
(
36
)
;
seekTable
=
null
;
metadata
=
null
;
}
public
FlacStreamMetadata
(
int
minBlockSizeSamples
int
maxBlockSizeSamples
int
minFrameSize
int
maxFrameSize
int
sampleRate
int
channels
int
bitsPerSample
long
totalSamples
ArrayList
<
String
>
vorbisComments
ArrayList
<
PictureFrame
>
pictureFrames
)
{
this
(
minBlockSizeSamples
maxBlockSizeSamples
minFrameSize
maxFrameSize
sampleRate
channels
bitsPerSample
totalSamples
null
buildMetadata
(
vorbisComments
pictureFrames
)
)
;
}
private
FlacStreamMetadata
(
int
minBlockSizeSamples
int
maxBlockSizeSamples
int
minFrameSize
int
maxFrameSize
int
sampleRate
int
channels
int
bitsPerSample
long
totalSamples
Nullable
SeekTable
seekTable
Nullable
Metadata
metadata
)
{
this
.
minBlockSizeSamples
=
minBlockSizeSamples
;
this
.
maxBlockSizeSamples
=
maxBlockSizeSamples
;
this
.
minFrameSize
=
minFrameSize
;
this
.
maxFrameSize
=
maxFrameSize
;
this
.
sampleRate
=
sampleRate
;
this
.
sampleRateLookupKey
=
getSampleRateLookupKey
(
sampleRate
)
;
this
.
channels
=
channels
;
this
.
bitsPerSample
=
bitsPerSample
;
this
.
bitsPerSampleLookupKey
=
getBitsPerSampleLookupKey
(
bitsPerSample
)
;
this
.
totalSamples
=
totalSamples
;
this
.
seekTable
=
seekTable
;
this
.
metadata
=
metadata
;
}
public
int
getMaxDecodedFrameSize
(
)
{
return
maxBlockSizeSamples
*
channels
*
(
bitsPerSample
/
8
)
;
}
public
int
getBitRate
(
)
{
return
bitsPerSample
*
sampleRate
*
channels
;
}
public
long
getDurationUs
(
)
{
return
totalSamples
=
=
0
?
C
.
TIME_UNSET
:
totalSamples
*
C
.
MICROS_PER_SECOND
/
sampleRate
;
}
public
long
getSampleNumber
(
long
timeUs
)
{
long
sampleNumber
=
(
timeUs
*
sampleRate
)
/
C
.
MICROS_PER_SECOND
;
return
Util
.
constrainValue
(
sampleNumber
0
totalSamples
-
1
)
;
}
public
long
getApproxBytesPerFrame
(
)
{
long
approxBytesPerFrame
;
if
(
maxFrameSize
>
0
)
{
approxBytesPerFrame
=
(
(
long
)
maxFrameSize
+
minFrameSize
)
/
2
+
1
;
}
else
{
long
blockSizeSamples
=
(
minBlockSizeSamples
=
=
maxBlockSizeSamples
&
&
minBlockSizeSamples
>
0
)
?
minBlockSizeSamples
:
4096
;
approxBytesPerFrame
=
(
blockSizeSamples
*
channels
*
bitsPerSample
)
/
8
+
64
;
}
return
approxBytesPerFrame
;
}
public
Format
getFormat
(
byte
[
]
streamMarkerAndInfoBlock
Nullable
Metadata
id3Metadata
)
{
streamMarkerAndInfoBlock
[
4
]
=
(
byte
)
0x80
;
int
maxInputSize
=
maxFrameSize
>
0
?
maxFrameSize
:
Format
.
NO_VALUE
;
Nullable
Metadata
metadataWithId3
=
getMetadataCopyWithAppendedEntriesFrom
(
id3Metadata
)
;
return
Format
.
createAudioSampleFormat
(
null
MimeTypes
.
AUDIO_FLAC
null
getBitRate
(
)
maxInputSize
channels
sampleRate
Format
.
NO_VALUE
0
0
Collections
.
singletonList
(
streamMarkerAndInfoBlock
)
null
0
null
metadataWithId3
)
;
}
Nullable
public
Metadata
getMetadataCopyWithAppendedEntriesFrom
(
Nullable
Metadata
other
)
{
return
metadata
=
=
null
?
other
:
metadata
.
copyWithAppendedEntriesFrom
(
other
)
;
}
public
FlacStreamMetadata
copyWithSeekTable
(
Nullable
SeekTable
seekTable
)
{
return
new
FlacStreamMetadata
(
minBlockSizeSamples
maxBlockSizeSamples
minFrameSize
maxFrameSize
sampleRate
channels
bitsPerSample
totalSamples
seekTable
metadata
)
;
}
public
FlacStreamMetadata
copyWithVorbisComments
(
List
<
String
>
vorbisComments
)
{
Nullable
Metadata
appendedMetadata
=
getMetadataCopyWithAppendedEntriesFrom
(
buildMetadata
(
vorbisComments
Collections
.
emptyList
(
)
)
)
;
return
new
FlacStreamMetadata
(
minBlockSizeSamples
maxBlockSizeSamples
minFrameSize
maxFrameSize
sampleRate
channels
bitsPerSample
totalSamples
seekTable
appendedMetadata
)
;
}
public
FlacStreamMetadata
copyWithPictureFrames
(
List
<
PictureFrame
>
pictureFrames
)
{
Nullable
Metadata
appendedMetadata
=
getMetadataCopyWithAppendedEntriesFrom
(
buildMetadata
(
Collections
.
emptyList
(
)
pictureFrames
)
)
;
return
new
FlacStreamMetadata
(
minBlockSizeSamples
maxBlockSizeSamples
minFrameSize
maxFrameSize
sampleRate
channels
bitsPerSample
totalSamples
seekTable
appendedMetadata
)
;
}
private
static
int
getSampleRateLookupKey
(
int
sampleRate
)
{
switch
(
sampleRate
)
{
case
88200
:
return
1
;
case
176400
:
return
2
;
case
192000
:
return
3
;
case
8000
:
return
4
;
case
16000
:
return
5
;
case
22050
:
return
6
;
case
24000
:
return
7
;
case
32000
:
return
8
;
case
44100
:
return
9
;
case
48000
:
return
10
;
case
96000
:
return
11
;
default
:
return
NOT_IN_LOOKUP_TABLE
;
}
}
private
static
int
getBitsPerSampleLookupKey
(
int
bitsPerSample
)
{
switch
(
bitsPerSample
)
{
case
8
:
return
1
;
case
12
:
return
2
;
case
16
:
return
4
;
case
20
:
return
5
;
case
24
:
return
6
;
default
:
return
NOT_IN_LOOKUP_TABLE
;
}
}
Nullable
private
static
Metadata
buildMetadata
(
List
<
String
>
vorbisComments
List
<
PictureFrame
>
pictureFrames
)
{
if
(
vorbisComments
.
isEmpty
(
)
&
&
pictureFrames
.
isEmpty
(
)
)
{
return
null
;
}
ArrayList
<
Metadata
.
Entry
>
metadataEntries
=
new
ArrayList
<
>
(
)
;
for
(
int
i
=
0
;
i
<
vorbisComments
.
size
(
)
;
i
+
+
)
{
String
vorbisComment
=
vorbisComments
.
get
(
i
)
;
String
[
]
keyAndValue
=
Util
.
splitAtFirst
(
vorbisComment
SEPARATOR
)
;
if
(
keyAndValue
.
length
!
=
2
)
{
Log
.
w
(
TAG
"
Failed
to
parse
Vorbis
comment
:
"
+
vorbisComment
)
;
}
else
{
VorbisComment
entry
=
new
VorbisComment
(
keyAndValue
[
0
]
keyAndValue
[
1
]
)
;
metadataEntries
.
add
(
entry
)
;
}
}
metadataEntries
.
addAll
(
pictureFrames
)
;
return
metadataEntries
.
isEmpty
(
)
?
null
:
new
Metadata
(
metadataEntries
)
;
}
}
