package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
;
import
android
.
content
.
Context
;
import
android
.
media
.
AudioFocusRequest
;
import
android
.
media
.
AudioManager
;
import
android
.
os
.
Handler
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
RequiresApi
;
import
androidx
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
AudioAttributes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
MonotonicNonNull
;
final
class
AudioFocusManager
{
public
interface
PlayerControl
{
void
setVolumeMultiplier
(
float
volumeMultiplier
)
;
void
executePlayerCommand
(
PlayerCommand
int
playerCommand
)
;
}
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
PLAYER_COMMAND_DO_NOT_PLAY
PLAYER_COMMAND_WAIT_FOR_CALLBACK
PLAYER_COMMAND_PLAY_WHEN_READY
}
)
public
interface
PlayerCommand
{
}
public
static
final
int
PLAYER_COMMAND_DO_NOT_PLAY
=
-
1
;
public
static
final
int
PLAYER_COMMAND_WAIT_FOR_CALLBACK
=
0
;
public
static
final
int
PLAYER_COMMAND_PLAY_WHEN_READY
=
1
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
AUDIO_FOCUS_STATE_NO_FOCUS
AUDIO_FOCUS_STATE_HAVE_FOCUS
AUDIO_FOCUS_STATE_LOSS_TRANSIENT
AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
}
)
private
interface
AudioFocusState
{
}
private
static
final
int
AUDIO_FOCUS_STATE_NO_FOCUS
=
0
;
private
static
final
int
AUDIO_FOCUS_STATE_HAVE_FOCUS
=
1
;
private
static
final
int
AUDIO_FOCUS_STATE_LOSS_TRANSIENT
=
2
;
private
static
final
int
AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
=
3
;
private
static
final
String
TAG
=
"
AudioFocusManager
"
;
private
static
final
float
VOLUME_MULTIPLIER_DUCK
=
0
.
2f
;
private
static
final
float
VOLUME_MULTIPLIER_DEFAULT
=
1
.
0f
;
private
final
AudioManager
audioManager
;
private
final
AudioFocusListener
focusListener
;
Nullable
private
PlayerControl
playerControl
;
Nullable
private
AudioAttributes
audioAttributes
;
AudioFocusState
private
int
audioFocusState
;
C
.
AudioFocusGain
private
int
focusGain
;
private
float
volumeMultiplier
=
VOLUME_MULTIPLIER_DEFAULT
;
private
MonotonicNonNull
AudioFocusRequest
audioFocusRequest
;
private
boolean
rebuildAudioFocusRequest
;
public
AudioFocusManager
(
Context
context
Handler
eventHandler
PlayerControl
playerControl
)
{
this
.
audioManager
=
(
AudioManager
)
context
.
getApplicationContext
(
)
.
getSystemService
(
Context
.
AUDIO_SERVICE
)
;
this
.
playerControl
=
playerControl
;
this
.
focusListener
=
new
AudioFocusListener
(
eventHandler
)
;
this
.
audioFocusState
=
AUDIO_FOCUS_STATE_NO_FOCUS
;
}
public
float
getVolumeMultiplier
(
)
{
return
volumeMultiplier
;
}
public
void
setAudioAttributes
(
Nullable
AudioAttributes
audioAttributes
)
{
if
(
!
Util
.
areEqual
(
this
.
audioAttributes
audioAttributes
)
)
{
this
.
audioAttributes
=
audioAttributes
;
focusGain
=
convertAudioAttributesToFocusGain
(
audioAttributes
)
;
Assertions
.
checkArgument
(
focusGain
=
=
C
.
AUDIOFOCUS_GAIN
|
|
focusGain
=
=
C
.
AUDIOFOCUS_NONE
"
Automatic
handling
of
audio
focus
is
only
available
for
USAGE_MEDIA
and
USAGE_GAME
.
"
)
;
}
}
PlayerCommand
public
int
updateAudioFocus
(
boolean
playWhenReady
Player
.
State
int
playbackState
)
{
if
(
shouldAbandonAudioFocus
(
playbackState
)
)
{
abandonAudioFocus
(
)
;
return
playWhenReady
?
PLAYER_COMMAND_PLAY_WHEN_READY
:
PLAYER_COMMAND_DO_NOT_PLAY
;
}
return
playWhenReady
?
requestAudioFocus
(
)
:
PLAYER_COMMAND_DO_NOT_PLAY
;
}
public
void
release
(
)
{
playerControl
=
null
;
abandonAudioFocus
(
)
;
}
VisibleForTesting
AudioManager
.
OnAudioFocusChangeListener
getFocusListener
(
)
{
return
focusListener
;
}
private
boolean
shouldAbandonAudioFocus
(
Player
.
State
int
playbackState
)
{
return
playbackState
=
=
Player
.
STATE_IDLE
|
|
focusGain
!
=
C
.
AUDIOFOCUS_GAIN
;
}
PlayerCommand
private
int
requestAudioFocus
(
)
{
if
(
audioFocusState
=
=
AUDIO_FOCUS_STATE_HAVE_FOCUS
)
{
return
PLAYER_COMMAND_PLAY_WHEN_READY
;
}
int
requestResult
=
Util
.
SDK_INT
>
=
26
?
requestAudioFocusV26
(
)
:
requestAudioFocusDefault
(
)
;
if
(
requestResult
=
=
AudioManager
.
AUDIOFOCUS_REQUEST_GRANTED
)
{
setAudioFocusState
(
AUDIO_FOCUS_STATE_HAVE_FOCUS
)
;
return
PLAYER_COMMAND_PLAY_WHEN_READY
;
}
else
{
setAudioFocusState
(
AUDIO_FOCUS_STATE_NO_FOCUS
)
;
return
PLAYER_COMMAND_DO_NOT_PLAY
;
}
}
private
void
abandonAudioFocus
(
)
{
if
(
audioFocusState
=
=
AUDIO_FOCUS_STATE_NO_FOCUS
)
{
return
;
}
if
(
Util
.
SDK_INT
>
=
26
)
{
abandonAudioFocusV26
(
)
;
}
else
{
abandonAudioFocusDefault
(
)
;
}
setAudioFocusState
(
AUDIO_FOCUS_STATE_NO_FOCUS
)
;
}
private
int
requestAudioFocusDefault
(
)
{
return
audioManager
.
requestAudioFocus
(
focusListener
Util
.
getStreamTypeForAudioUsage
(
Assertions
.
checkNotNull
(
audioAttributes
)
.
usage
)
focusGain
)
;
}
RequiresApi
(
26
)
private
int
requestAudioFocusV26
(
)
{
if
(
audioFocusRequest
=
=
null
|
|
rebuildAudioFocusRequest
)
{
AudioFocusRequest
.
Builder
builder
=
audioFocusRequest
=
=
null
?
new
AudioFocusRequest
.
Builder
(
focusGain
)
:
new
AudioFocusRequest
.
Builder
(
audioFocusRequest
)
;
boolean
willPauseWhenDucked
=
willPauseWhenDucked
(
)
;
audioFocusRequest
=
builder
.
setAudioAttributes
(
Assertions
.
checkNotNull
(
audioAttributes
)
.
getAudioAttributesV21
(
)
)
.
setWillPauseWhenDucked
(
willPauseWhenDucked
)
.
setOnAudioFocusChangeListener
(
focusListener
)
.
build
(
)
;
rebuildAudioFocusRequest
=
false
;
}
return
audioManager
.
requestAudioFocus
(
audioFocusRequest
)
;
}
private
void
abandonAudioFocusDefault
(
)
{
audioManager
.
abandonAudioFocus
(
focusListener
)
;
}
RequiresApi
(
26
)
private
void
abandonAudioFocusV26
(
)
{
if
(
audioFocusRequest
!
=
null
)
{
audioManager
.
abandonAudioFocusRequest
(
audioFocusRequest
)
;
}
}
private
boolean
willPauseWhenDucked
(
)
{
return
audioAttributes
!
=
null
&
&
audioAttributes
.
contentType
=
=
C
.
CONTENT_TYPE_SPEECH
;
}
C
.
AudioFocusGain
private
static
int
convertAudioAttributesToFocusGain
(
Nullable
AudioAttributes
audioAttributes
)
{
if
(
audioAttributes
=
=
null
)
{
return
C
.
AUDIOFOCUS_NONE
;
}
switch
(
audioAttributes
.
usage
)
{
case
C
.
USAGE_VOICE_COMMUNICATION_SIGNALLING
:
return
C
.
AUDIOFOCUS_NONE
;
case
C
.
USAGE_GAME
:
case
C
.
USAGE_MEDIA
:
return
C
.
AUDIOFOCUS_GAIN
;
case
C
.
USAGE_UNKNOWN
:
Log
.
w
(
TAG
"
Specify
a
proper
usage
in
the
audio
attributes
for
audio
focus
"
+
"
handling
.
Using
AUDIOFOCUS_GAIN
by
default
.
"
)
;
return
C
.
AUDIOFOCUS_GAIN
;
case
C
.
USAGE_ALARM
:
case
C
.
USAGE_VOICE_COMMUNICATION
:
return
C
.
AUDIOFOCUS_GAIN_TRANSIENT
;
case
C
.
USAGE_ASSISTANCE_NAVIGATION_GUIDANCE
:
case
C
.
USAGE_ASSISTANCE_SONIFICATION
:
case
C
.
USAGE_NOTIFICATION
:
case
C
.
USAGE_NOTIFICATION_COMMUNICATION_DELAYED
:
case
C
.
USAGE_NOTIFICATION_COMMUNICATION_INSTANT
:
case
C
.
USAGE_NOTIFICATION_COMMUNICATION_REQUEST
:
case
C
.
USAGE_NOTIFICATION_EVENT
:
case
C
.
USAGE_NOTIFICATION_RINGTONE
:
return
C
.
AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK
;
case
C
.
USAGE_ASSISTANT
:
if
(
Util
.
SDK_INT
>
=
19
)
{
return
C
.
AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE
;
}
else
{
return
C
.
AUDIOFOCUS_GAIN_TRANSIENT
;
}
case
C
.
USAGE_ASSISTANCE_ACCESSIBILITY
:
if
(
audioAttributes
.
contentType
=
=
C
.
CONTENT_TYPE_SPEECH
)
{
return
C
.
AUDIOFOCUS_GAIN_TRANSIENT
;
}
return
C
.
AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK
;
default
:
Log
.
w
(
TAG
"
Unidentified
audio
usage
:
"
+
audioAttributes
.
usage
)
;
return
C
.
AUDIOFOCUS_NONE
;
}
}
private
void
setAudioFocusState
(
AudioFocusState
int
audioFocusState
)
{
if
(
this
.
audioFocusState
=
=
audioFocusState
)
{
return
;
}
this
.
audioFocusState
=
audioFocusState
;
float
volumeMultiplier
=
(
audioFocusState
=
=
AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
)
?
AudioFocusManager
.
VOLUME_MULTIPLIER_DUCK
:
AudioFocusManager
.
VOLUME_MULTIPLIER_DEFAULT
;
if
(
this
.
volumeMultiplier
=
=
volumeMultiplier
)
{
return
;
}
this
.
volumeMultiplier
=
volumeMultiplier
;
if
(
playerControl
!
=
null
)
{
playerControl
.
setVolumeMultiplier
(
volumeMultiplier
)
;
}
}
private
void
handlePlatformAudioFocusChange
(
int
focusChange
)
{
switch
(
focusChange
)
{
case
AudioManager
.
AUDIOFOCUS_GAIN
:
setAudioFocusState
(
AUDIO_FOCUS_STATE_HAVE_FOCUS
)
;
executePlayerCommand
(
PLAYER_COMMAND_PLAY_WHEN_READY
)
;
return
;
case
AudioManager
.
AUDIOFOCUS_LOSS
:
executePlayerCommand
(
PLAYER_COMMAND_DO_NOT_PLAY
)
;
abandonAudioFocus
(
)
;
return
;
case
AudioManager
.
AUDIOFOCUS_LOSS_TRANSIENT
:
case
AudioManager
.
AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK
:
if
(
focusChange
=
=
AudioManager
.
AUDIOFOCUS_LOSS_TRANSIENT
|
|
willPauseWhenDucked
(
)
)
{
executePlayerCommand
(
PLAYER_COMMAND_WAIT_FOR_CALLBACK
)
;
setAudioFocusState
(
AUDIO_FOCUS_STATE_LOSS_TRANSIENT
)
;
}
else
{
setAudioFocusState
(
AUDIO_FOCUS_STATE_LOSS_TRANSIENT_DUCK
)
;
}
return
;
default
:
Log
.
w
(
TAG
"
Unknown
focus
change
type
:
"
+
focusChange
)
;
}
}
private
void
executePlayerCommand
(
PlayerCommand
int
playerCommand
)
{
if
(
playerControl
!
=
null
)
{
playerControl
.
executePlayerCommand
(
playerCommand
)
;
}
}
private
class
AudioFocusListener
implements
AudioManager
.
OnAudioFocusChangeListener
{
private
final
Handler
eventHandler
;
public
AudioFocusListener
(
Handler
eventHandler
)
{
this
.
eventHandler
=
eventHandler
;
}
Override
public
void
onAudioFocusChange
(
int
focusChange
)
{
eventHandler
.
post
(
(
)
-
>
handlePlatformAudioFocusChange
(
focusChange
)
)
;
}
}
}
