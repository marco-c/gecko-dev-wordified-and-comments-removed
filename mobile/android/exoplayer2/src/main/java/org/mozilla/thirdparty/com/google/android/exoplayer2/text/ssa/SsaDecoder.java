package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
ssa
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
.
castNonNull
;
import
android
.
text
.
Layout
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
Cue
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SimpleSubtitleDecoder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
Subtitle
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
LinkedHashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
MonotonicNonNull
;
public
final
class
SsaDecoder
extends
SimpleSubtitleDecoder
{
private
static
final
String
TAG
=
"
SsaDecoder
"
;
private
static
final
Pattern
SSA_TIMECODE_PATTERN
=
Pattern
.
compile
(
"
(
?
:
(
\
\
d
+
)
:
)
?
(
\
\
d
+
)
:
(
\
\
d
+
)
[
:
.
]
(
\
\
d
+
)
"
)
;
static
final
String
FORMAT_LINE_PREFIX
=
"
Format
:
"
;
static
final
String
STYLE_LINE_PREFIX
=
"
Style
:
"
;
private
static
final
String
DIALOGUE_LINE_PREFIX
=
"
Dialogue
:
"
;
private
static
final
float
DEFAULT_MARGIN
=
0
.
05f
;
private
final
boolean
haveInitializationData
;
Nullable
private
final
SsaDialogueFormat
dialogueFormatFromInitializationData
;
private
MonotonicNonNull
Map
<
String
SsaStyle
>
styles
;
private
float
screenWidth
;
private
float
screenHeight
;
public
SsaDecoder
(
)
{
this
(
null
)
;
}
public
SsaDecoder
(
Nullable
List
<
byte
[
]
>
initializationData
)
{
super
(
"
SsaDecoder
"
)
;
screenWidth
=
Cue
.
DIMEN_UNSET
;
screenHeight
=
Cue
.
DIMEN_UNSET
;
if
(
initializationData
!
=
null
&
&
!
initializationData
.
isEmpty
(
)
)
{
haveInitializationData
=
true
;
String
formatLine
=
Util
.
fromUtf8Bytes
(
initializationData
.
get
(
0
)
)
;
Assertions
.
checkArgument
(
formatLine
.
startsWith
(
FORMAT_LINE_PREFIX
)
)
;
dialogueFormatFromInitializationData
=
Assertions
.
checkNotNull
(
SsaDialogueFormat
.
fromFormatLine
(
formatLine
)
)
;
parseHeader
(
new
ParsableByteArray
(
initializationData
.
get
(
1
)
)
)
;
}
else
{
haveInitializationData
=
false
;
dialogueFormatFromInitializationData
=
null
;
}
}
Override
protected
Subtitle
decode
(
byte
[
]
bytes
int
length
boolean
reset
)
{
List
<
List
<
Cue
>
>
cues
=
new
ArrayList
<
>
(
)
;
List
<
Long
>
cueTimesUs
=
new
ArrayList
<
>
(
)
;
ParsableByteArray
data
=
new
ParsableByteArray
(
bytes
length
)
;
if
(
!
haveInitializationData
)
{
parseHeader
(
data
)
;
}
parseEventBody
(
data
cues
cueTimesUs
)
;
return
new
SsaSubtitle
(
cues
cueTimesUs
)
;
}
private
void
parseHeader
(
ParsableByteArray
data
)
{
Nullable
String
currentLine
;
while
(
(
currentLine
=
data
.
readLine
(
)
)
!
=
null
)
{
if
(
"
[
Script
Info
]
"
.
equalsIgnoreCase
(
currentLine
)
)
{
parseScriptInfo
(
data
)
;
}
else
if
(
"
[
V4
+
Styles
]
"
.
equalsIgnoreCase
(
currentLine
)
)
{
styles
=
parseStyles
(
data
)
;
}
else
if
(
"
[
V4
Styles
]
"
.
equalsIgnoreCase
(
currentLine
)
)
{
Log
.
i
(
TAG
"
[
V4
Styles
]
are
not
supported
"
)
;
}
else
if
(
"
[
Events
]
"
.
equalsIgnoreCase
(
currentLine
)
)
{
return
;
}
}
}
private
void
parseScriptInfo
(
ParsableByteArray
data
)
{
Nullable
String
currentLine
;
while
(
(
currentLine
=
data
.
readLine
(
)
)
!
=
null
&
&
(
data
.
bytesLeft
(
)
=
=
0
|
|
data
.
peekUnsignedByte
(
)
!
=
'
[
'
)
)
{
String
[
]
infoNameAndValue
=
currentLine
.
split
(
"
:
"
)
;
if
(
infoNameAndValue
.
length
!
=
2
)
{
continue
;
}
switch
(
Util
.
toLowerInvariant
(
infoNameAndValue
[
0
]
.
trim
(
)
)
)
{
case
"
playresx
"
:
try
{
screenWidth
=
Float
.
parseFloat
(
infoNameAndValue
[
1
]
.
trim
(
)
)
;
}
catch
(
NumberFormatException
e
)
{
}
break
;
case
"
playresy
"
:
try
{
screenHeight
=
Float
.
parseFloat
(
infoNameAndValue
[
1
]
.
trim
(
)
)
;
}
catch
(
NumberFormatException
e
)
{
}
break
;
}
}
}
private
static
Map
<
String
SsaStyle
>
parseStyles
(
ParsableByteArray
data
)
{
Map
<
String
SsaStyle
>
styles
=
new
LinkedHashMap
<
>
(
)
;
Nullable
SsaStyle
.
Format
formatInfo
=
null
;
Nullable
String
currentLine
;
while
(
(
currentLine
=
data
.
readLine
(
)
)
!
=
null
&
&
(
data
.
bytesLeft
(
)
=
=
0
|
|
data
.
peekUnsignedByte
(
)
!
=
'
[
'
)
)
{
if
(
currentLine
.
startsWith
(
FORMAT_LINE_PREFIX
)
)
{
formatInfo
=
SsaStyle
.
Format
.
fromFormatLine
(
currentLine
)
;
}
else
if
(
currentLine
.
startsWith
(
STYLE_LINE_PREFIX
)
)
{
if
(
formatInfo
=
=
null
)
{
Log
.
w
(
TAG
"
Skipping
'
Style
:
'
line
before
'
Format
:
'
line
:
"
+
currentLine
)
;
continue
;
}
Nullable
SsaStyle
style
=
SsaStyle
.
fromStyleLine
(
currentLine
formatInfo
)
;
if
(
style
!
=
null
)
{
styles
.
put
(
style
.
name
style
)
;
}
}
}
return
styles
;
}
private
void
parseEventBody
(
ParsableByteArray
data
List
<
List
<
Cue
>
>
cues
List
<
Long
>
cueTimesUs
)
{
Nullable
SsaDialogueFormat
format
=
haveInitializationData
?
dialogueFormatFromInitializationData
:
null
;
Nullable
String
currentLine
;
while
(
(
currentLine
=
data
.
readLine
(
)
)
!
=
null
)
{
if
(
currentLine
.
startsWith
(
FORMAT_LINE_PREFIX
)
)
{
format
=
SsaDialogueFormat
.
fromFormatLine
(
currentLine
)
;
}
else
if
(
currentLine
.
startsWith
(
DIALOGUE_LINE_PREFIX
)
)
{
if
(
format
=
=
null
)
{
Log
.
w
(
TAG
"
Skipping
dialogue
line
before
complete
format
:
"
+
currentLine
)
;
continue
;
}
parseDialogueLine
(
currentLine
format
cues
cueTimesUs
)
;
}
}
}
private
void
parseDialogueLine
(
String
dialogueLine
SsaDialogueFormat
format
List
<
List
<
Cue
>
>
cues
List
<
Long
>
cueTimesUs
)
{
Assertions
.
checkArgument
(
dialogueLine
.
startsWith
(
DIALOGUE_LINE_PREFIX
)
)
;
String
[
]
lineValues
=
dialogueLine
.
substring
(
DIALOGUE_LINE_PREFIX
.
length
(
)
)
.
split
(
"
"
format
.
length
)
;
if
(
lineValues
.
length
!
=
format
.
length
)
{
Log
.
w
(
TAG
"
Skipping
dialogue
line
with
fewer
columns
than
format
:
"
+
dialogueLine
)
;
return
;
}
long
startTimeUs
=
parseTimecodeUs
(
lineValues
[
format
.
startTimeIndex
]
)
;
if
(
startTimeUs
=
=
C
.
TIME_UNSET
)
{
Log
.
w
(
TAG
"
Skipping
invalid
timing
:
"
+
dialogueLine
)
;
return
;
}
long
endTimeUs
=
parseTimecodeUs
(
lineValues
[
format
.
endTimeIndex
]
)
;
if
(
endTimeUs
=
=
C
.
TIME_UNSET
)
{
Log
.
w
(
TAG
"
Skipping
invalid
timing
:
"
+
dialogueLine
)
;
return
;
}
Nullable
SsaStyle
style
=
styles
!
=
null
&
&
format
.
styleIndex
!
=
C
.
INDEX_UNSET
?
styles
.
get
(
lineValues
[
format
.
styleIndex
]
.
trim
(
)
)
:
null
;
String
rawText
=
lineValues
[
format
.
textIndex
]
;
SsaStyle
.
Overrides
styleOverrides
=
SsaStyle
.
Overrides
.
parseFromDialogue
(
rawText
)
;
String
text
=
SsaStyle
.
Overrides
.
stripStyleOverrides
(
rawText
)
.
replaceAll
(
"
\
\
\
\
N
"
"
\
n
"
)
.
replaceAll
(
"
\
\
\
\
n
"
"
\
n
"
)
;
Cue
cue
=
createCue
(
text
style
styleOverrides
screenWidth
screenHeight
)
;
int
startTimeIndex
=
addCuePlacerholderByTime
(
startTimeUs
cueTimesUs
cues
)
;
int
endTimeIndex
=
addCuePlacerholderByTime
(
endTimeUs
cueTimesUs
cues
)
;
for
(
int
i
=
startTimeIndex
;
i
<
endTimeIndex
;
i
+
+
)
{
cues
.
get
(
i
)
.
add
(
cue
)
;
}
}
private
static
long
parseTimecodeUs
(
String
timeString
)
{
Matcher
matcher
=
SSA_TIMECODE_PATTERN
.
matcher
(
timeString
.
trim
(
)
)
;
if
(
!
matcher
.
matches
(
)
)
{
return
C
.
TIME_UNSET
;
}
long
timestampUs
=
Long
.
parseLong
(
castNonNull
(
matcher
.
group
(
1
)
)
)
*
60
*
60
*
C
.
MICROS_PER_SECOND
;
timestampUs
+
=
Long
.
parseLong
(
castNonNull
(
matcher
.
group
(
2
)
)
)
*
60
*
C
.
MICROS_PER_SECOND
;
timestampUs
+
=
Long
.
parseLong
(
castNonNull
(
matcher
.
group
(
3
)
)
)
*
C
.
MICROS_PER_SECOND
;
timestampUs
+
=
Long
.
parseLong
(
castNonNull
(
matcher
.
group
(
4
)
)
)
*
10000
;
return
timestampUs
;
}
private
static
Cue
createCue
(
String
text
Nullable
SsaStyle
style
SsaStyle
.
Overrides
styleOverrides
float
screenWidth
float
screenHeight
)
{
SsaStyle
.
SsaAlignment
int
alignment
;
if
(
styleOverrides
.
alignment
!
=
SsaStyle
.
SSA_ALIGNMENT_UNKNOWN
)
{
alignment
=
styleOverrides
.
alignment
;
}
else
if
(
style
!
=
null
)
{
alignment
=
style
.
alignment
;
}
else
{
alignment
=
SsaStyle
.
SSA_ALIGNMENT_UNKNOWN
;
}
Cue
.
AnchorType
int
positionAnchor
=
toPositionAnchor
(
alignment
)
;
Cue
.
AnchorType
int
lineAnchor
=
toLineAnchor
(
alignment
)
;
float
position
;
float
line
;
if
(
styleOverrides
.
position
!
=
null
&
&
screenHeight
!
=
Cue
.
DIMEN_UNSET
&
&
screenWidth
!
=
Cue
.
DIMEN_UNSET
)
{
position
=
styleOverrides
.
position
.
x
/
screenWidth
;
line
=
styleOverrides
.
position
.
y
/
screenHeight
;
}
else
{
position
=
computeDefaultLineOrPosition
(
positionAnchor
)
;
line
=
computeDefaultLineOrPosition
(
lineAnchor
)
;
}
return
new
Cue
(
text
toTextAlignment
(
alignment
)
line
Cue
.
LINE_TYPE_FRACTION
lineAnchor
position
positionAnchor
Cue
.
DIMEN_UNSET
)
;
}
Nullable
private
static
Layout
.
Alignment
toTextAlignment
(
SsaStyle
.
SsaAlignment
int
alignment
)
{
switch
(
alignment
)
{
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_LEFT
:
return
Layout
.
Alignment
.
ALIGN_NORMAL
;
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_CENTER
:
return
Layout
.
Alignment
.
ALIGN_CENTER
;
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_RIGHT
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_RIGHT
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_RIGHT
:
return
Layout
.
Alignment
.
ALIGN_OPPOSITE
;
case
SsaStyle
.
SSA_ALIGNMENT_UNKNOWN
:
return
null
;
default
:
Log
.
w
(
TAG
"
Unknown
alignment
:
"
+
alignment
)
;
return
null
;
}
}
Cue
.
AnchorType
private
static
int
toLineAnchor
(
SsaStyle
.
SsaAlignment
int
alignment
)
{
switch
(
alignment
)
{
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_RIGHT
:
return
Cue
.
ANCHOR_TYPE_END
;
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_RIGHT
:
return
Cue
.
ANCHOR_TYPE_MIDDLE
;
case
SsaStyle
.
SSA_ALIGNMENT_TOP_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_RIGHT
:
return
Cue
.
ANCHOR_TYPE_START
;
case
SsaStyle
.
SSA_ALIGNMENT_UNKNOWN
:
return
Cue
.
TYPE_UNSET
;
default
:
Log
.
w
(
TAG
"
Unknown
alignment
:
"
+
alignment
)
;
return
Cue
.
TYPE_UNSET
;
}
}
Cue
.
AnchorType
private
static
int
toPositionAnchor
(
SsaStyle
.
SsaAlignment
int
alignment
)
{
switch
(
alignment
)
{
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_LEFT
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_LEFT
:
return
Cue
.
ANCHOR_TYPE_START
;
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_CENTER
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_CENTER
:
return
Cue
.
ANCHOR_TYPE_MIDDLE
;
case
SsaStyle
.
SSA_ALIGNMENT_BOTTOM_RIGHT
:
case
SsaStyle
.
SSA_ALIGNMENT_MIDDLE_RIGHT
:
case
SsaStyle
.
SSA_ALIGNMENT_TOP_RIGHT
:
return
Cue
.
ANCHOR_TYPE_END
;
case
SsaStyle
.
SSA_ALIGNMENT_UNKNOWN
:
return
Cue
.
TYPE_UNSET
;
default
:
Log
.
w
(
TAG
"
Unknown
alignment
:
"
+
alignment
)
;
return
Cue
.
TYPE_UNSET
;
}
}
private
static
float
computeDefaultLineOrPosition
(
Cue
.
AnchorType
int
anchor
)
{
switch
(
anchor
)
{
case
Cue
.
ANCHOR_TYPE_START
:
return
DEFAULT_MARGIN
;
case
Cue
.
ANCHOR_TYPE_MIDDLE
:
return
0
.
5f
;
case
Cue
.
ANCHOR_TYPE_END
:
return
1
.
0f
-
DEFAULT_MARGIN
;
case
Cue
.
TYPE_UNSET
:
default
:
return
Cue
.
DIMEN_UNSET
;
}
}
private
static
int
addCuePlacerholderByTime
(
long
timeUs
List
<
Long
>
sortedCueTimesUs
List
<
List
<
Cue
>
>
cues
)
{
int
insertionIndex
=
0
;
for
(
int
i
=
sortedCueTimesUs
.
size
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
sortedCueTimesUs
.
get
(
i
)
=
=
timeUs
)
{
return
i
;
}
if
(
sortedCueTimesUs
.
get
(
i
)
<
timeUs
)
{
insertionIndex
=
i
+
1
;
break
;
}
}
sortedCueTimesUs
.
add
(
insertionIndex
timeUs
)
;
cues
.
add
(
insertionIndex
insertionIndex
=
=
0
?
new
ArrayList
<
>
(
)
:
new
ArrayList
<
>
(
cues
.
get
(
insertionIndex
-
1
)
)
)
;
return
insertionIndex
;
}
}
