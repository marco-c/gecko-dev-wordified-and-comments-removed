package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
Context
;
import
android
.
hardware
.
display
.
DisplayManager
;
import
android
.
os
.
Handler
;
import
android
.
os
.
HandlerThread
;
import
android
.
os
.
Message
;
import
android
.
view
.
Choreographer
;
import
android
.
view
.
Choreographer
.
FrameCallback
;
import
android
.
view
.
Display
;
import
android
.
view
.
WindowManager
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
public
final
class
VideoFrameReleaseTimeHelper
{
private
static
final
long
CHOREOGRAPHER_SAMPLE_DELAY_MILLIS
=
500
;
private
static
final
long
MAX_ALLOWED_DRIFT_NS
=
20000000
;
private
static
final
long
VSYNC_OFFSET_PERCENTAGE
=
80
;
private
static
final
int
MIN_FRAMES_FOR_ADJUSTMENT
=
6
;
private
final
WindowManager
windowManager
;
private
final
VSyncSampler
vsyncSampler
;
private
final
DefaultDisplayListener
displayListener
;
private
long
vsyncDurationNs
;
private
long
vsyncOffsetNs
;
private
long
lastFramePresentationTimeUs
;
private
long
adjustedLastFrameTimeNs
;
private
long
pendingAdjustedFrameTimeNs
;
private
boolean
haveSync
;
private
long
syncUnadjustedReleaseTimeNs
;
private
long
syncFramePresentationTimeNs
;
private
long
frameCount
;
public
VideoFrameReleaseTimeHelper
(
)
{
this
(
null
)
;
}
public
VideoFrameReleaseTimeHelper
(
Nullable
Context
context
)
{
if
(
context
!
=
null
)
{
context
=
context
.
getApplicationContext
(
)
;
windowManager
=
(
WindowManager
)
context
.
getSystemService
(
Context
.
WINDOW_SERVICE
)
;
}
else
{
windowManager
=
null
;
}
if
(
windowManager
!
=
null
)
{
displayListener
=
Util
.
SDK_INT
>
=
17
?
maybeBuildDefaultDisplayListenerV17
(
context
)
:
null
;
vsyncSampler
=
VSyncSampler
.
getInstance
(
)
;
}
else
{
displayListener
=
null
;
vsyncSampler
=
null
;
}
vsyncDurationNs
=
C
.
TIME_UNSET
;
vsyncOffsetNs
=
C
.
TIME_UNSET
;
}
public
void
enable
(
)
{
haveSync
=
false
;
if
(
windowManager
!
=
null
)
{
vsyncSampler
.
addObserver
(
)
;
if
(
displayListener
!
=
null
)
{
displayListener
.
register
(
)
;
}
updateDefaultDisplayRefreshRateParams
(
)
;
}
}
public
void
disable
(
)
{
if
(
windowManager
!
=
null
)
{
if
(
displayListener
!
=
null
)
{
displayListener
.
unregister
(
)
;
}
vsyncSampler
.
removeObserver
(
)
;
}
}
public
long
adjustReleaseTime
(
long
framePresentationTimeUs
long
unadjustedReleaseTimeNs
)
{
long
framePresentationTimeNs
=
framePresentationTimeUs
*
1000
;
long
adjustedFrameTimeNs
=
framePresentationTimeNs
;
long
adjustedReleaseTimeNs
=
unadjustedReleaseTimeNs
;
if
(
haveSync
)
{
if
(
framePresentationTimeUs
!
=
lastFramePresentationTimeUs
)
{
frameCount
+
+
;
adjustedLastFrameTimeNs
=
pendingAdjustedFrameTimeNs
;
}
if
(
frameCount
>
=
MIN_FRAMES_FOR_ADJUSTMENT
)
{
long
averageFrameDurationNs
=
(
framePresentationTimeNs
-
syncFramePresentationTimeNs
)
/
frameCount
;
long
candidateAdjustedFrameTimeNs
=
adjustedLastFrameTimeNs
+
averageFrameDurationNs
;
if
(
isDriftTooLarge
(
candidateAdjustedFrameTimeNs
unadjustedReleaseTimeNs
)
)
{
haveSync
=
false
;
}
else
{
adjustedFrameTimeNs
=
candidateAdjustedFrameTimeNs
;
adjustedReleaseTimeNs
=
syncUnadjustedReleaseTimeNs
+
adjustedFrameTimeNs
-
syncFramePresentationTimeNs
;
}
}
else
{
if
(
isDriftTooLarge
(
framePresentationTimeNs
unadjustedReleaseTimeNs
)
)
{
haveSync
=
false
;
}
}
}
if
(
!
haveSync
)
{
syncFramePresentationTimeNs
=
framePresentationTimeNs
;
syncUnadjustedReleaseTimeNs
=
unadjustedReleaseTimeNs
;
frameCount
=
0
;
haveSync
=
true
;
}
lastFramePresentationTimeUs
=
framePresentationTimeUs
;
pendingAdjustedFrameTimeNs
=
adjustedFrameTimeNs
;
if
(
vsyncSampler
=
=
null
|
|
vsyncDurationNs
=
=
C
.
TIME_UNSET
)
{
return
adjustedReleaseTimeNs
;
}
long
sampledVsyncTimeNs
=
vsyncSampler
.
sampledVsyncTimeNs
;
if
(
sampledVsyncTimeNs
=
=
C
.
TIME_UNSET
)
{
return
adjustedReleaseTimeNs
;
}
long
snappedTimeNs
=
closestVsync
(
adjustedReleaseTimeNs
sampledVsyncTimeNs
vsyncDurationNs
)
;
return
snappedTimeNs
-
vsyncOffsetNs
;
}
TargetApi
(
17
)
private
DefaultDisplayListener
maybeBuildDefaultDisplayListenerV17
(
Context
context
)
{
DisplayManager
manager
=
(
DisplayManager
)
context
.
getSystemService
(
Context
.
DISPLAY_SERVICE
)
;
return
manager
=
=
null
?
null
:
new
DefaultDisplayListener
(
manager
)
;
}
private
void
updateDefaultDisplayRefreshRateParams
(
)
{
Display
defaultDisplay
=
windowManager
.
getDefaultDisplay
(
)
;
if
(
defaultDisplay
!
=
null
)
{
double
defaultDisplayRefreshRate
=
defaultDisplay
.
getRefreshRate
(
)
;
vsyncDurationNs
=
(
long
)
(
C
.
NANOS_PER_SECOND
/
defaultDisplayRefreshRate
)
;
vsyncOffsetNs
=
(
vsyncDurationNs
*
VSYNC_OFFSET_PERCENTAGE
)
/
100
;
}
}
private
boolean
isDriftTooLarge
(
long
frameTimeNs
long
releaseTimeNs
)
{
long
elapsedFrameTimeNs
=
frameTimeNs
-
syncFramePresentationTimeNs
;
long
elapsedReleaseTimeNs
=
releaseTimeNs
-
syncUnadjustedReleaseTimeNs
;
return
Math
.
abs
(
elapsedReleaseTimeNs
-
elapsedFrameTimeNs
)
>
MAX_ALLOWED_DRIFT_NS
;
}
private
static
long
closestVsync
(
long
releaseTime
long
sampledVsyncTime
long
vsyncDuration
)
{
long
vsyncCount
=
(
releaseTime
-
sampledVsyncTime
)
/
vsyncDuration
;
long
snappedTimeNs
=
sampledVsyncTime
+
(
vsyncDuration
*
vsyncCount
)
;
long
snappedBeforeNs
;
long
snappedAfterNs
;
if
(
releaseTime
<
=
snappedTimeNs
)
{
snappedBeforeNs
=
snappedTimeNs
-
vsyncDuration
;
snappedAfterNs
=
snappedTimeNs
;
}
else
{
snappedBeforeNs
=
snappedTimeNs
;
snappedAfterNs
=
snappedTimeNs
+
vsyncDuration
;
}
long
snappedAfterDiff
=
snappedAfterNs
-
releaseTime
;
long
snappedBeforeDiff
=
releaseTime
-
snappedBeforeNs
;
return
snappedAfterDiff
<
snappedBeforeDiff
?
snappedAfterNs
:
snappedBeforeNs
;
}
TargetApi
(
17
)
private
final
class
DefaultDisplayListener
implements
DisplayManager
.
DisplayListener
{
private
final
DisplayManager
displayManager
;
public
DefaultDisplayListener
(
DisplayManager
displayManager
)
{
this
.
displayManager
=
displayManager
;
}
public
void
register
(
)
{
displayManager
.
registerDisplayListener
(
this
null
)
;
}
public
void
unregister
(
)
{
displayManager
.
unregisterDisplayListener
(
this
)
;
}
Override
public
void
onDisplayAdded
(
int
displayId
)
{
}
Override
public
void
onDisplayRemoved
(
int
displayId
)
{
}
Override
public
void
onDisplayChanged
(
int
displayId
)
{
if
(
displayId
=
=
Display
.
DEFAULT_DISPLAY
)
{
updateDefaultDisplayRefreshRateParams
(
)
;
}
}
}
private
static
final
class
VSyncSampler
implements
FrameCallback
Handler
.
Callback
{
public
volatile
long
sampledVsyncTimeNs
;
private
static
final
int
CREATE_CHOREOGRAPHER
=
0
;
private
static
final
int
MSG_ADD_OBSERVER
=
1
;
private
static
final
int
MSG_REMOVE_OBSERVER
=
2
;
private
static
final
VSyncSampler
INSTANCE
=
new
VSyncSampler
(
)
;
private
final
Handler
handler
;
private
final
HandlerThread
choreographerOwnerThread
;
private
Choreographer
choreographer
;
private
int
observerCount
;
public
static
VSyncSampler
getInstance
(
)
{
return
INSTANCE
;
}
private
VSyncSampler
(
)
{
sampledVsyncTimeNs
=
C
.
TIME_UNSET
;
choreographerOwnerThread
=
new
HandlerThread
(
"
ChoreographerOwner
:
Handler
"
)
;
choreographerOwnerThread
.
start
(
)
;
handler
=
Util
.
createHandler
(
choreographerOwnerThread
.
getLooper
(
)
this
)
;
handler
.
sendEmptyMessage
(
CREATE_CHOREOGRAPHER
)
;
}
public
void
addObserver
(
)
{
handler
.
sendEmptyMessage
(
MSG_ADD_OBSERVER
)
;
}
public
void
removeObserver
(
)
{
handler
.
sendEmptyMessage
(
MSG_REMOVE_OBSERVER
)
;
}
Override
public
void
doFrame
(
long
vsyncTimeNs
)
{
sampledVsyncTimeNs
=
vsyncTimeNs
;
choreographer
.
postFrameCallbackDelayed
(
this
CHOREOGRAPHER_SAMPLE_DELAY_MILLIS
)
;
}
Override
public
boolean
handleMessage
(
Message
message
)
{
switch
(
message
.
what
)
{
case
CREATE_CHOREOGRAPHER
:
{
createChoreographerInstanceInternal
(
)
;
return
true
;
}
case
MSG_ADD_OBSERVER
:
{
addObserverInternal
(
)
;
return
true
;
}
case
MSG_REMOVE_OBSERVER
:
{
removeObserverInternal
(
)
;
return
true
;
}
default
:
{
return
false
;
}
}
}
private
void
createChoreographerInstanceInternal
(
)
{
choreographer
=
Choreographer
.
getInstance
(
)
;
}
private
void
addObserverInternal
(
)
{
observerCount
+
+
;
if
(
observerCount
=
=
1
)
{
choreographer
.
postFrameCallback
(
this
)
;
}
}
private
void
removeObserverInternal
(
)
{
observerCount
-
-
;
if
(
observerCount
=
=
0
)
{
choreographer
.
removeFrameCallback
(
this
)
;
sampledVsyncTimeNs
=
C
.
TIME_UNSET
;
}
}
}
}
