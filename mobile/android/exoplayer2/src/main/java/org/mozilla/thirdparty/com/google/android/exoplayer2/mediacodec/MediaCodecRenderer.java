package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
mediacodec
;
import
android
.
annotation
.
TargetApi
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodec
.
CodecException
;
import
android
.
media
.
MediaCodec
.
CryptoException
;
import
android
.
media
.
MediaCrypto
;
import
android
.
media
.
MediaCryptoException
;
import
android
.
media
.
MediaFormat
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
SystemClock
;
import
androidx
.
annotation
.
CheckResult
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
BaseRenderer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderCounters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
.
DrmSessionException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
FrameworkMediaCrypto
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecUtil
.
DecoderQueryException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaPeriod
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
NalUnitUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimedValueQueue
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayDeque
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
public
abstract
class
MediaCodecRenderer
extends
BaseRenderer
{
public
static
class
DecoderInitializationException
extends
Exception
{
private
static
final
int
CUSTOM_ERROR_CODE_BASE
=
-
50000
;
private
static
final
int
NO_SUITABLE_DECODER_ERROR
=
CUSTOM_ERROR_CODE_BASE
+
1
;
private
static
final
int
DECODER_QUERY_ERROR
=
CUSTOM_ERROR_CODE_BASE
+
2
;
public
final
String
mimeType
;
public
final
boolean
secureDecoderRequired
;
Nullable
public
final
MediaCodecInfo
codecInfo
;
Nullable
public
final
String
diagnosticInfo
;
Nullable
public
final
DecoderInitializationException
fallbackDecoderInitializationException
;
public
DecoderInitializationException
(
Format
format
Throwable
cause
boolean
secureDecoderRequired
int
errorCode
)
{
this
(
"
Decoder
init
failed
:
[
"
+
errorCode
+
"
]
"
+
format
cause
format
.
sampleMimeType
secureDecoderRequired
null
buildCustomDiagnosticInfo
(
errorCode
)
null
)
;
}
public
DecoderInitializationException
(
Format
format
Throwable
cause
boolean
secureDecoderRequired
MediaCodecInfo
mediaCodecInfo
)
{
this
(
"
Decoder
init
failed
:
"
+
mediaCodecInfo
.
name
+
"
"
+
format
cause
format
.
sampleMimeType
secureDecoderRequired
mediaCodecInfo
Util
.
SDK_INT
>
=
21
?
getDiagnosticInfoV21
(
cause
)
:
null
null
)
;
}
private
DecoderInitializationException
(
String
message
Throwable
cause
String
mimeType
boolean
secureDecoderRequired
Nullable
MediaCodecInfo
mediaCodecInfo
Nullable
String
diagnosticInfo
Nullable
DecoderInitializationException
fallbackDecoderInitializationException
)
{
super
(
message
cause
)
;
this
.
mimeType
=
mimeType
;
this
.
secureDecoderRequired
=
secureDecoderRequired
;
this
.
codecInfo
=
mediaCodecInfo
;
this
.
diagnosticInfo
=
diagnosticInfo
;
this
.
fallbackDecoderInitializationException
=
fallbackDecoderInitializationException
;
}
CheckResult
private
DecoderInitializationException
copyWithFallbackException
(
DecoderInitializationException
fallbackException
)
{
return
new
DecoderInitializationException
(
getMessage
(
)
getCause
(
)
mimeType
secureDecoderRequired
codecInfo
diagnosticInfo
fallbackException
)
;
}
TargetApi
(
21
)
private
static
String
getDiagnosticInfoV21
(
Throwable
cause
)
{
if
(
cause
instanceof
CodecException
)
{
return
(
(
CodecException
)
cause
)
.
getDiagnosticInfo
(
)
;
}
return
null
;
}
private
static
String
buildCustomDiagnosticInfo
(
int
errorCode
)
{
String
sign
=
errorCode
<
0
?
"
neg_
"
:
"
"
;
return
"
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecRenderer_
"
+
sign
+
Math
.
abs
(
errorCode
)
;
}
}
public
static
class
DecoderException
extends
Exception
{
Nullable
public
final
MediaCodecInfo
codecInfo
;
Nullable
public
final
String
diagnosticInfo
;
public
DecoderException
(
Throwable
cause
Nullable
MediaCodecInfo
codecInfo
)
{
super
(
"
Decoder
failed
:
"
+
(
codecInfo
=
=
null
?
null
:
codecInfo
.
name
)
cause
)
;
this
.
codecInfo
=
codecInfo
;
diagnosticInfo
=
Util
.
SDK_INT
>
=
21
?
getDiagnosticInfoV21
(
cause
)
:
null
;
}
TargetApi
(
21
)
private
static
String
getDiagnosticInfoV21
(
Throwable
cause
)
{
if
(
cause
instanceof
CodecException
)
{
return
(
(
CodecException
)
cause
)
.
getDiagnosticInfo
(
)
;
}
return
null
;
}
}
protected
static
final
float
CODEC_OPERATING_RATE_UNSET
=
-
1
;
private
static
final
String
TAG
=
"
MediaCodecRenderer
"
;
private
static
final
long
MAX_CODEC_HOTSWAP_TIME_MS
=
1000
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
KEEP_CODEC_RESULT_NO
KEEP_CODEC_RESULT_YES_WITH_FLUSH
KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION
KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION
}
)
protected
interface
KeepCodecResult
{
}
protected
static
final
int
KEEP_CODEC_RESULT_NO
=
0
;
protected
static
final
int
KEEP_CODEC_RESULT_YES_WITH_FLUSH
=
1
;
protected
static
final
int
KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION
=
2
;
protected
static
final
int
KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION
=
3
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
RECONFIGURATION_STATE_NONE
RECONFIGURATION_STATE_WRITE_PENDING
RECONFIGURATION_STATE_QUEUE_PENDING
}
)
private
interface
ReconfigurationState
{
}
private
static
final
int
RECONFIGURATION_STATE_NONE
=
0
;
private
static
final
int
RECONFIGURATION_STATE_WRITE_PENDING
=
1
;
private
static
final
int
RECONFIGURATION_STATE_QUEUE_PENDING
=
2
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
DRAIN_STATE_NONE
DRAIN_STATE_SIGNAL_END_OF_STREAM
DRAIN_STATE_WAIT_END_OF_STREAM
}
)
private
interface
DrainState
{
}
private
static
final
int
DRAIN_STATE_NONE
=
0
;
private
static
final
int
DRAIN_STATE_SIGNAL_END_OF_STREAM
=
1
;
private
static
final
int
DRAIN_STATE_WAIT_END_OF_STREAM
=
2
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
DRAIN_ACTION_NONE
DRAIN_ACTION_FLUSH
DRAIN_ACTION_UPDATE_DRM_SESSION
DRAIN_ACTION_REINITIALIZE
}
)
private
interface
DrainAction
{
}
private
static
final
int
DRAIN_ACTION_NONE
=
0
;
private
static
final
int
DRAIN_ACTION_FLUSH
=
1
;
private
static
final
int
DRAIN_ACTION_UPDATE_DRM_SESSION
=
2
;
private
static
final
int
DRAIN_ACTION_REINITIALIZE
=
3
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
ADAPTATION_WORKAROUND_MODE_NEVER
ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
ADAPTATION_WORKAROUND_MODE_ALWAYS
}
)
private
interface
AdaptationWorkaroundMode
{
}
private
static
final
int
ADAPTATION_WORKAROUND_MODE_NEVER
=
0
;
private
static
final
int
ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
=
1
;
private
static
final
int
ADAPTATION_WORKAROUND_MODE_ALWAYS
=
2
;
private
static
final
byte
[
]
ADAPTATION_WORKAROUND_BUFFER
=
new
byte
[
]
{
0
0
1
103
66
-
64
11
-
38
37
-
112
0
0
1
104
-
50
15
19
32
0
0
1
101
-
120
-
124
13
-
50
113
24
-
96
0
47
-
65
28
49
-
61
39
93
120
}
;
private
static
final
int
ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
=
32
;
private
final
MediaCodecSelector
mediaCodecSelector
;
Nullable
private
final
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
;
private
final
boolean
playClearSamplesWithoutKeys
;
private
final
boolean
enableDecoderFallback
;
private
final
float
assumedMinimumCodecOperatingRate
;
private
final
DecoderInputBuffer
buffer
;
private
final
DecoderInputBuffer
flagsOnlyBuffer
;
private
final
TimedValueQueue
<
Format
>
formatQueue
;
private
final
ArrayList
<
Long
>
decodeOnlyPresentationTimestamps
;
private
final
MediaCodec
.
BufferInfo
outputBufferInfo
;
private
boolean
drmResourcesAcquired
;
Nullable
private
Format
inputFormat
;
private
Format
outputFormat
;
Nullable
private
DrmSession
<
FrameworkMediaCrypto
>
codecDrmSession
;
Nullable
private
DrmSession
<
FrameworkMediaCrypto
>
sourceDrmSession
;
Nullable
private
MediaCrypto
mediaCrypto
;
private
boolean
mediaCryptoRequiresSecureDecoder
;
private
long
renderTimeLimitMs
;
private
float
rendererOperatingRate
;
Nullable
private
MediaCodec
codec
;
Nullable
private
Format
codecFormat
;
private
float
codecOperatingRate
;
Nullable
private
ArrayDeque
<
MediaCodecInfo
>
availableCodecInfos
;
Nullable
private
DecoderInitializationException
preferredDecoderInitializationException
;
Nullable
private
MediaCodecInfo
codecInfo
;
AdaptationWorkaroundMode
private
int
codecAdaptationWorkaroundMode
;
private
boolean
codecNeedsReconfigureWorkaround
;
private
boolean
codecNeedsDiscardToSpsWorkaround
;
private
boolean
codecNeedsFlushWorkaround
;
private
boolean
codecNeedsSosFlushWorkaround
;
private
boolean
codecNeedsEosFlushWorkaround
;
private
boolean
codecNeedsEosOutputExceptionWorkaround
;
private
boolean
codecNeedsMonoChannelCountWorkaround
;
private
boolean
codecNeedsAdaptationWorkaroundBuffer
;
private
boolean
shouldSkipAdaptationWorkaroundOutputBuffer
;
private
boolean
codecNeedsEosPropagation
;
private
ByteBuffer
[
]
inputBuffers
;
private
ByteBuffer
[
]
outputBuffers
;
private
long
codecHotswapDeadlineMs
;
private
int
inputIndex
;
private
int
outputIndex
;
private
ByteBuffer
outputBuffer
;
private
boolean
isDecodeOnlyOutputBuffer
;
private
boolean
isLastOutputBuffer
;
private
boolean
codecReconfigured
;
ReconfigurationState
private
int
codecReconfigurationState
;
DrainState
private
int
codecDrainState
;
DrainAction
private
int
codecDrainAction
;
private
boolean
codecReceivedBuffers
;
private
boolean
codecReceivedEos
;
private
boolean
codecHasOutputMediaFormat
;
private
long
largestQueuedPresentationTimeUs
;
private
long
lastBufferInStreamPresentationTimeUs
;
private
boolean
inputStreamEnded
;
private
boolean
outputStreamEnded
;
private
boolean
waitingForKeys
;
private
boolean
waitingForFirstSyncSample
;
private
boolean
waitingForFirstSampleInFormat
;
private
boolean
skipMediaCodecStopOnRelease
;
private
boolean
pendingOutputEndOfStream
;
protected
DecoderCounters
decoderCounters
;
public
MediaCodecRenderer
(
int
trackType
MediaCodecSelector
mediaCodecSelector
Nullable
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
boolean
enableDecoderFallback
float
assumedMinimumCodecOperatingRate
)
{
super
(
trackType
)
;
this
.
mediaCodecSelector
=
Assertions
.
checkNotNull
(
mediaCodecSelector
)
;
this
.
drmSessionManager
=
drmSessionManager
;
this
.
playClearSamplesWithoutKeys
=
playClearSamplesWithoutKeys
;
this
.
enableDecoderFallback
=
enableDecoderFallback
;
this
.
assumedMinimumCodecOperatingRate
=
assumedMinimumCodecOperatingRate
;
buffer
=
new
DecoderInputBuffer
(
DecoderInputBuffer
.
BUFFER_REPLACEMENT_MODE_DISABLED
)
;
flagsOnlyBuffer
=
DecoderInputBuffer
.
newFlagsOnlyInstance
(
)
;
formatQueue
=
new
TimedValueQueue
<
>
(
)
;
decodeOnlyPresentationTimestamps
=
new
ArrayList
<
>
(
)
;
outputBufferInfo
=
new
MediaCodec
.
BufferInfo
(
)
;
codecReconfigurationState
=
RECONFIGURATION_STATE_NONE
;
codecDrainState
=
DRAIN_STATE_NONE
;
codecDrainAction
=
DRAIN_ACTION_NONE
;
codecOperatingRate
=
CODEC_OPERATING_RATE_UNSET
;
rendererOperatingRate
=
1f
;
renderTimeLimitMs
=
C
.
TIME_UNSET
;
}
public
void
experimental_setRenderTimeLimitMs
(
long
renderTimeLimitMs
)
{
this
.
renderTimeLimitMs
=
renderTimeLimitMs
;
}
public
void
experimental_setSkipMediaCodecStopOnRelease
(
boolean
enabled
)
{
skipMediaCodecStopOnRelease
=
enabled
;
}
Override
AdaptiveSupport
public
final
int
supportsMixedMimeTypeAdaptation
(
)
{
return
ADAPTIVE_NOT_SEAMLESS
;
}
Override
Capabilities
public
final
int
supportsFormat
(
Format
format
)
throws
ExoPlaybackException
{
try
{
return
supportsFormat
(
mediaCodecSelector
drmSessionManager
format
)
;
}
catch
(
DecoderQueryException
e
)
{
throw
createRendererException
(
e
format
)
;
}
}
Capabilities
protected
abstract
int
supportsFormat
(
MediaCodecSelector
mediaCodecSelector
Nullable
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
Format
format
)
throws
DecoderQueryException
;
protected
abstract
List
<
MediaCodecInfo
>
getDecoderInfos
(
MediaCodecSelector
mediaCodecSelector
Format
format
boolean
requiresSecureDecoder
)
throws
DecoderQueryException
;
protected
abstract
void
configureCodec
(
MediaCodecInfo
codecInfo
MediaCodec
codec
Format
format
Nullable
MediaCrypto
crypto
float
codecOperatingRate
)
;
protected
final
void
maybeInitCodec
(
)
throws
ExoPlaybackException
{
if
(
codec
!
=
null
|
|
inputFormat
=
=
null
)
{
return
;
}
setCodecDrmSession
(
sourceDrmSession
)
;
String
mimeType
=
inputFormat
.
sampleMimeType
;
if
(
codecDrmSession
!
=
null
)
{
if
(
mediaCrypto
=
=
null
)
{
FrameworkMediaCrypto
sessionMediaCrypto
=
codecDrmSession
.
getMediaCrypto
(
)
;
if
(
sessionMediaCrypto
=
=
null
)
{
DrmSessionException
drmError
=
codecDrmSession
.
getError
(
)
;
if
(
drmError
!
=
null
)
{
}
else
{
return
;
}
}
else
{
try
{
mediaCrypto
=
new
MediaCrypto
(
sessionMediaCrypto
.
uuid
sessionMediaCrypto
.
sessionId
)
;
}
catch
(
MediaCryptoException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
mediaCryptoRequiresSecureDecoder
=
!
sessionMediaCrypto
.
forceAllowInsecureDecoderComponents
&
&
mediaCrypto
.
requiresSecureDecoderComponent
(
mimeType
)
;
}
}
if
(
FrameworkMediaCrypto
.
WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC
)
{
DrmSession
.
State
int
drmSessionState
=
codecDrmSession
.
getState
(
)
;
if
(
drmSessionState
=
=
DrmSession
.
STATE_ERROR
)
{
throw
createRendererException
(
codecDrmSession
.
getError
(
)
inputFormat
)
;
}
else
if
(
drmSessionState
!
=
DrmSession
.
STATE_OPENED_WITH_KEYS
)
{
return
;
}
}
}
try
{
maybeInitCodecWithFallback
(
mediaCrypto
mediaCryptoRequiresSecureDecoder
)
;
}
catch
(
DecoderInitializationException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
}
protected
boolean
shouldInitCodec
(
MediaCodecInfo
codecInfo
)
{
return
true
;
}
protected
boolean
getCodecNeedsEosPropagation
(
)
{
return
false
;
}
protected
final
Nullable
Format
updateOutputFormatForTime
(
long
presentationTimeUs
)
{
Format
format
=
formatQueue
.
pollFloor
(
presentationTimeUs
)
;
if
(
format
!
=
null
)
{
outputFormat
=
format
;
}
return
format
;
}
protected
final
MediaCodec
getCodec
(
)
{
return
codec
;
}
protected
final
Nullable
MediaCodecInfo
getCodecInfo
(
)
{
return
codecInfo
;
}
Override
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
if
(
drmSessionManager
!
=
null
&
&
!
drmResourcesAcquired
)
{
drmResourcesAcquired
=
true
;
drmSessionManager
.
prepare
(
)
;
}
decoderCounters
=
new
DecoderCounters
(
)
;
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
inputStreamEnded
=
false
;
outputStreamEnded
=
false
;
pendingOutputEndOfStream
=
false
;
flushOrReinitializeCodec
(
)
;
formatQueue
.
clear
(
)
;
}
Override
public
final
void
setOperatingRate
(
float
operatingRate
)
throws
ExoPlaybackException
{
rendererOperatingRate
=
operatingRate
;
if
(
codec
!
=
null
&
&
codecDrainAction
!
=
DRAIN_ACTION_REINITIALIZE
&
&
getState
(
)
!
=
STATE_DISABLED
)
{
updateCodecOperatingRate
(
)
;
}
}
Override
protected
void
onDisabled
(
)
{
inputFormat
=
null
;
if
(
sourceDrmSession
!
=
null
|
|
codecDrmSession
!
=
null
)
{
onReset
(
)
;
}
else
{
flushOrReleaseCodec
(
)
;
}
}
Override
protected
void
onReset
(
)
{
try
{
releaseCodec
(
)
;
}
finally
{
setSourceDrmSession
(
null
)
;
}
if
(
drmSessionManager
!
=
null
&
&
drmResourcesAcquired
)
{
drmResourcesAcquired
=
false
;
drmSessionManager
.
release
(
)
;
}
}
protected
void
releaseCodec
(
)
{
availableCodecInfos
=
null
;
codecInfo
=
null
;
codecFormat
=
null
;
codecHasOutputMediaFormat
=
false
;
resetInputBuffer
(
)
;
resetOutputBuffer
(
)
;
resetCodecBuffers
(
)
;
waitingForKeys
=
false
;
codecHotswapDeadlineMs
=
C
.
TIME_UNSET
;
decodeOnlyPresentationTimestamps
.
clear
(
)
;
largestQueuedPresentationTimeUs
=
C
.
TIME_UNSET
;
lastBufferInStreamPresentationTimeUs
=
C
.
TIME_UNSET
;
try
{
if
(
codec
!
=
null
)
{
decoderCounters
.
decoderReleaseCount
+
+
;
try
{
if
(
!
skipMediaCodecStopOnRelease
)
{
codec
.
stop
(
)
;
}
}
finally
{
codec
.
release
(
)
;
}
}
}
finally
{
codec
=
null
;
try
{
if
(
mediaCrypto
!
=
null
)
{
mediaCrypto
.
release
(
)
;
}
}
finally
{
mediaCrypto
=
null
;
mediaCryptoRequiresSecureDecoder
=
false
;
setCodecDrmSession
(
null
)
;
}
}
}
Override
protected
void
onStarted
(
)
{
}
Override
protected
void
onStopped
(
)
{
}
Override
public
void
render
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
{
if
(
pendingOutputEndOfStream
)
{
pendingOutputEndOfStream
=
false
;
processEndOfStream
(
)
;
}
try
{
if
(
outputStreamEnded
)
{
renderToEndOfStream
(
)
;
return
;
}
if
(
inputFormat
=
=
null
&
&
!
readToFlagsOnlyBuffer
(
true
)
)
{
return
;
}
maybeInitCodec
(
)
;
if
(
codec
!
=
null
)
{
long
drainStartTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
TraceUtil
.
beginSection
(
"
drainAndFeed
"
)
;
while
(
drainOutputBuffer
(
positionUs
elapsedRealtimeUs
)
)
{
}
while
(
feedInputBuffer
(
)
&
&
shouldContinueFeeding
(
drainStartTimeMs
)
)
{
}
TraceUtil
.
endSection
(
)
;
}
else
{
decoderCounters
.
skippedInputBufferCount
+
=
skipSource
(
positionUs
)
;
readToFlagsOnlyBuffer
(
false
)
;
}
decoderCounters
.
ensureUpdated
(
)
;
}
catch
(
IllegalStateException
e
)
{
if
(
isMediaCodecException
(
e
)
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
throw
e
;
}
}
protected
final
boolean
flushOrReinitializeCodec
(
)
throws
ExoPlaybackException
{
boolean
released
=
flushOrReleaseCodec
(
)
;
if
(
released
)
{
maybeInitCodec
(
)
;
}
return
released
;
}
protected
boolean
flushOrReleaseCodec
(
)
{
if
(
codec
=
=
null
)
{
return
false
;
}
if
(
codecDrainAction
=
=
DRAIN_ACTION_REINITIALIZE
|
|
codecNeedsFlushWorkaround
|
|
(
codecNeedsSosFlushWorkaround
&
&
!
codecHasOutputMediaFormat
)
|
|
(
codecNeedsEosFlushWorkaround
&
&
codecReceivedEos
)
)
{
releaseCodec
(
)
;
return
true
;
}
codec
.
flush
(
)
;
resetInputBuffer
(
)
;
resetOutputBuffer
(
)
;
codecHotswapDeadlineMs
=
C
.
TIME_UNSET
;
codecReceivedEos
=
false
;
codecReceivedBuffers
=
false
;
waitingForFirstSyncSample
=
true
;
codecNeedsAdaptationWorkaroundBuffer
=
false
;
shouldSkipAdaptationWorkaroundOutputBuffer
=
false
;
isDecodeOnlyOutputBuffer
=
false
;
isLastOutputBuffer
=
false
;
waitingForKeys
=
false
;
decodeOnlyPresentationTimestamps
.
clear
(
)
;
largestQueuedPresentationTimeUs
=
C
.
TIME_UNSET
;
lastBufferInStreamPresentationTimeUs
=
C
.
TIME_UNSET
;
codecDrainState
=
DRAIN_STATE_NONE
;
codecDrainAction
=
DRAIN_ACTION_NONE
;
codecReconfigurationState
=
codecReconfigured
?
RECONFIGURATION_STATE_WRITE_PENDING
:
RECONFIGURATION_STATE_NONE
;
return
false
;
}
protected
DecoderException
createDecoderException
(
Throwable
cause
Nullable
MediaCodecInfo
codecInfo
)
{
return
new
DecoderException
(
cause
codecInfo
)
;
}
private
boolean
readToFlagsOnlyBuffer
(
boolean
requireFormat
)
throws
ExoPlaybackException
{
FormatHolder
formatHolder
=
getFormatHolder
(
)
;
flagsOnlyBuffer
.
clear
(
)
;
int
result
=
readSource
(
formatHolder
flagsOnlyBuffer
requireFormat
)
;
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
)
;
return
true
;
}
else
if
(
result
=
=
C
.
RESULT_BUFFER_READ
&
&
flagsOnlyBuffer
.
isEndOfStream
(
)
)
{
inputStreamEnded
=
true
;
processEndOfStream
(
)
;
}
return
false
;
}
private
void
maybeInitCodecWithFallback
(
MediaCrypto
crypto
boolean
mediaCryptoRequiresSecureDecoder
)
throws
DecoderInitializationException
{
if
(
availableCodecInfos
=
=
null
)
{
try
{
List
<
MediaCodecInfo
>
allAvailableCodecInfos
=
getAvailableCodecInfos
(
mediaCryptoRequiresSecureDecoder
)
;
availableCodecInfos
=
new
ArrayDeque
<
>
(
)
;
if
(
enableDecoderFallback
)
{
availableCodecInfos
.
addAll
(
allAvailableCodecInfos
)
;
}
else
if
(
!
allAvailableCodecInfos
.
isEmpty
(
)
)
{
availableCodecInfos
.
add
(
allAvailableCodecInfos
.
get
(
0
)
)
;
}
preferredDecoderInitializationException
=
null
;
}
catch
(
DecoderQueryException
e
)
{
throw
new
DecoderInitializationException
(
inputFormat
e
mediaCryptoRequiresSecureDecoder
DecoderInitializationException
.
DECODER_QUERY_ERROR
)
;
}
}
if
(
availableCodecInfos
.
isEmpty
(
)
)
{
throw
new
DecoderInitializationException
(
inputFormat
null
mediaCryptoRequiresSecureDecoder
DecoderInitializationException
.
NO_SUITABLE_DECODER_ERROR
)
;
}
while
(
codec
=
=
null
)
{
MediaCodecInfo
codecInfo
=
availableCodecInfos
.
peekFirst
(
)
;
if
(
!
shouldInitCodec
(
codecInfo
)
)
{
return
;
}
try
{
initCodec
(
codecInfo
crypto
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
TAG
"
Failed
to
initialize
decoder
:
"
+
codecInfo
e
)
;
availableCodecInfos
.
removeFirst
(
)
;
DecoderInitializationException
exception
=
new
DecoderInitializationException
(
inputFormat
e
mediaCryptoRequiresSecureDecoder
codecInfo
)
;
if
(
preferredDecoderInitializationException
=
=
null
)
{
preferredDecoderInitializationException
=
exception
;
}
else
{
preferredDecoderInitializationException
=
preferredDecoderInitializationException
.
copyWithFallbackException
(
exception
)
;
}
if
(
availableCodecInfos
.
isEmpty
(
)
)
{
throw
preferredDecoderInitializationException
;
}
}
}
availableCodecInfos
=
null
;
}
private
List
<
MediaCodecInfo
>
getAvailableCodecInfos
(
boolean
mediaCryptoRequiresSecureDecoder
)
throws
DecoderQueryException
{
List
<
MediaCodecInfo
>
codecInfos
=
getDecoderInfos
(
mediaCodecSelector
inputFormat
mediaCryptoRequiresSecureDecoder
)
;
if
(
codecInfos
.
isEmpty
(
)
&
&
mediaCryptoRequiresSecureDecoder
)
{
codecInfos
=
getDecoderInfos
(
mediaCodecSelector
inputFormat
false
)
;
if
(
!
codecInfos
.
isEmpty
(
)
)
{
Log
.
w
(
TAG
"
Drm
session
requires
secure
decoder
for
"
+
inputFormat
.
sampleMimeType
+
"
but
no
secure
decoder
available
.
Trying
to
proceed
with
"
+
codecInfos
+
"
.
"
)
;
}
}
return
codecInfos
;
}
private
void
initCodec
(
MediaCodecInfo
codecInfo
MediaCrypto
crypto
)
throws
Exception
{
long
codecInitializingTimestamp
;
long
codecInitializedTimestamp
;
MediaCodec
codec
=
null
;
String
codecName
=
codecInfo
.
name
;
float
codecOperatingRate
=
Util
.
SDK_INT
<
23
?
CODEC_OPERATING_RATE_UNSET
:
getCodecOperatingRateV23
(
rendererOperatingRate
inputFormat
getStreamFormats
(
)
)
;
if
(
codecOperatingRate
<
=
assumedMinimumCodecOperatingRate
)
{
codecOperatingRate
=
CODEC_OPERATING_RATE_UNSET
;
}
try
{
codecInitializingTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
TraceUtil
.
beginSection
(
"
createCodec
:
"
+
codecName
)
;
codec
=
MediaCodec
.
createByCodecName
(
codecName
)
;
TraceUtil
.
endSection
(
)
;
TraceUtil
.
beginSection
(
"
configureCodec
"
)
;
configureCodec
(
codecInfo
codec
inputFormat
crypto
codecOperatingRate
)
;
TraceUtil
.
endSection
(
)
;
TraceUtil
.
beginSection
(
"
startCodec
"
)
;
codec
.
start
(
)
;
TraceUtil
.
endSection
(
)
;
codecInitializedTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
getCodecBuffers
(
codec
)
;
}
catch
(
Exception
e
)
{
if
(
codec
!
=
null
)
{
resetCodecBuffers
(
)
;
codec
.
release
(
)
;
}
throw
e
;
}
this
.
codec
=
codec
;
this
.
codecInfo
=
codecInfo
;
this
.
codecOperatingRate
=
codecOperatingRate
;
codecFormat
=
inputFormat
;
codecAdaptationWorkaroundMode
=
codecAdaptationWorkaroundMode
(
codecName
)
;
codecNeedsReconfigureWorkaround
=
codecNeedsReconfigureWorkaround
(
codecName
)
;
codecNeedsDiscardToSpsWorkaround
=
codecNeedsDiscardToSpsWorkaround
(
codecName
codecFormat
)
;
codecNeedsFlushWorkaround
=
codecNeedsFlushWorkaround
(
codecName
)
;
codecNeedsSosFlushWorkaround
=
codecNeedsSosFlushWorkaround
(
codecName
)
;
codecNeedsEosFlushWorkaround
=
codecNeedsEosFlushWorkaround
(
codecName
)
;
codecNeedsEosOutputExceptionWorkaround
=
codecNeedsEosOutputExceptionWorkaround
(
codecName
)
;
codecNeedsMonoChannelCountWorkaround
=
codecNeedsMonoChannelCountWorkaround
(
codecName
codecFormat
)
;
codecNeedsEosPropagation
=
codecNeedsEosPropagationWorkaround
(
codecInfo
)
|
|
getCodecNeedsEosPropagation
(
)
;
resetInputBuffer
(
)
;
resetOutputBuffer
(
)
;
codecHotswapDeadlineMs
=
getState
(
)
=
=
STATE_STARTED
?
(
SystemClock
.
elapsedRealtime
(
)
+
MAX_CODEC_HOTSWAP_TIME_MS
)
:
C
.
TIME_UNSET
;
codecReconfigured
=
false
;
codecReconfigurationState
=
RECONFIGURATION_STATE_NONE
;
codecReceivedEos
=
false
;
codecReceivedBuffers
=
false
;
largestQueuedPresentationTimeUs
=
C
.
TIME_UNSET
;
lastBufferInStreamPresentationTimeUs
=
C
.
TIME_UNSET
;
codecDrainState
=
DRAIN_STATE_NONE
;
codecDrainAction
=
DRAIN_ACTION_NONE
;
codecNeedsAdaptationWorkaroundBuffer
=
false
;
shouldSkipAdaptationWorkaroundOutputBuffer
=
false
;
isDecodeOnlyOutputBuffer
=
false
;
isLastOutputBuffer
=
false
;
waitingForFirstSyncSample
=
true
;
decoderCounters
.
decoderInitCount
+
+
;
long
elapsed
=
codecInitializedTimestamp
-
codecInitializingTimestamp
;
onCodecInitialized
(
codecName
codecInitializedTimestamp
elapsed
)
;
}
private
boolean
shouldContinueFeeding
(
long
drainStartTimeMs
)
{
return
renderTimeLimitMs
=
=
C
.
TIME_UNSET
|
|
SystemClock
.
elapsedRealtime
(
)
-
drainStartTimeMs
<
renderTimeLimitMs
;
}
private
void
getCodecBuffers
(
MediaCodec
codec
)
{
if
(
Util
.
SDK_INT
<
21
)
{
inputBuffers
=
codec
.
getInputBuffers
(
)
;
outputBuffers
=
codec
.
getOutputBuffers
(
)
;
}
}
private
void
resetCodecBuffers
(
)
{
if
(
Util
.
SDK_INT
<
21
)
{
inputBuffers
=
null
;
outputBuffers
=
null
;
}
}
private
ByteBuffer
getInputBuffer
(
int
inputIndex
)
{
if
(
Util
.
SDK_INT
>
=
21
)
{
return
codec
.
getInputBuffer
(
inputIndex
)
;
}
else
{
return
inputBuffers
[
inputIndex
]
;
}
}
private
ByteBuffer
getOutputBuffer
(
int
outputIndex
)
{
if
(
Util
.
SDK_INT
>
=
21
)
{
return
codec
.
getOutputBuffer
(
outputIndex
)
;
}
else
{
return
outputBuffers
[
outputIndex
]
;
}
}
private
boolean
hasOutputBuffer
(
)
{
return
outputIndex
>
=
0
;
}
private
void
resetInputBuffer
(
)
{
inputIndex
=
C
.
INDEX_UNSET
;
buffer
.
data
=
null
;
}
private
void
resetOutputBuffer
(
)
{
outputIndex
=
C
.
INDEX_UNSET
;
outputBuffer
=
null
;
}
private
void
setSourceDrmSession
(
Nullable
DrmSession
<
FrameworkMediaCrypto
>
session
)
{
DrmSession
.
replaceSession
(
sourceDrmSession
session
)
;
sourceDrmSession
=
session
;
}
private
void
setCodecDrmSession
(
Nullable
DrmSession
<
FrameworkMediaCrypto
>
session
)
{
DrmSession
.
replaceSession
(
codecDrmSession
session
)
;
codecDrmSession
=
session
;
}
private
boolean
feedInputBuffer
(
)
throws
ExoPlaybackException
{
if
(
codec
=
=
null
|
|
codecDrainState
=
=
DRAIN_STATE_WAIT_END_OF_STREAM
|
|
inputStreamEnded
)
{
return
false
;
}
if
(
inputIndex
<
0
)
{
inputIndex
=
codec
.
dequeueInputBuffer
(
0
)
;
if
(
inputIndex
<
0
)
{
return
false
;
}
buffer
.
data
=
getInputBuffer
(
inputIndex
)
;
buffer
.
clear
(
)
;
}
if
(
codecDrainState
=
=
DRAIN_STATE_SIGNAL_END_OF_STREAM
)
{
if
(
codecNeedsEosPropagation
)
{
}
else
{
codecReceivedEos
=
true
;
codec
.
queueInputBuffer
(
inputIndex
0
0
0
MediaCodec
.
BUFFER_FLAG_END_OF_STREAM
)
;
resetInputBuffer
(
)
;
}
codecDrainState
=
DRAIN_STATE_WAIT_END_OF_STREAM
;
return
false
;
}
if
(
codecNeedsAdaptationWorkaroundBuffer
)
{
codecNeedsAdaptationWorkaroundBuffer
=
false
;
buffer
.
data
.
put
(
ADAPTATION_WORKAROUND_BUFFER
)
;
codec
.
queueInputBuffer
(
inputIndex
0
ADAPTATION_WORKAROUND_BUFFER
.
length
0
0
)
;
resetInputBuffer
(
)
;
codecReceivedBuffers
=
true
;
return
true
;
}
int
result
;
FormatHolder
formatHolder
=
getFormatHolder
(
)
;
int
adaptiveReconfigurationBytes
=
0
;
if
(
waitingForKeys
)
{
result
=
C
.
RESULT_BUFFER_READ
;
}
else
{
if
(
codecReconfigurationState
=
=
RECONFIGURATION_STATE_WRITE_PENDING
)
{
for
(
int
i
=
0
;
i
<
codecFormat
.
initializationData
.
size
(
)
;
i
+
+
)
{
byte
[
]
data
=
codecFormat
.
initializationData
.
get
(
i
)
;
buffer
.
data
.
put
(
data
)
;
}
codecReconfigurationState
=
RECONFIGURATION_STATE_QUEUE_PENDING
;
}
adaptiveReconfigurationBytes
=
buffer
.
data
.
position
(
)
;
result
=
readSource
(
formatHolder
buffer
false
)
;
}
if
(
hasReadStreamToEnd
(
)
)
{
lastBufferInStreamPresentationTimeUs
=
largestQueuedPresentationTimeUs
;
}
if
(
result
=
=
C
.
RESULT_NOTHING_READ
)
{
return
false
;
}
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
if
(
codecReconfigurationState
=
=
RECONFIGURATION_STATE_QUEUE_PENDING
)
{
buffer
.
clear
(
)
;
codecReconfigurationState
=
RECONFIGURATION_STATE_WRITE_PENDING
;
}
onInputFormatChanged
(
formatHolder
)
;
return
true
;
}
if
(
buffer
.
isEndOfStream
(
)
)
{
if
(
codecReconfigurationState
=
=
RECONFIGURATION_STATE_QUEUE_PENDING
)
{
buffer
.
clear
(
)
;
codecReconfigurationState
=
RECONFIGURATION_STATE_WRITE_PENDING
;
}
inputStreamEnded
=
true
;
if
(
!
codecReceivedBuffers
)
{
processEndOfStream
(
)
;
return
false
;
}
try
{
if
(
codecNeedsEosPropagation
)
{
}
else
{
codecReceivedEos
=
true
;
codec
.
queueInputBuffer
(
inputIndex
0
0
0
MediaCodec
.
BUFFER_FLAG_END_OF_STREAM
)
;
resetInputBuffer
(
)
;
}
}
catch
(
CryptoException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
return
false
;
}
if
(
waitingForFirstSyncSample
&
&
!
buffer
.
isKeyFrame
(
)
)
{
buffer
.
clear
(
)
;
if
(
codecReconfigurationState
=
=
RECONFIGURATION_STATE_QUEUE_PENDING
)
{
codecReconfigurationState
=
RECONFIGURATION_STATE_WRITE_PENDING
;
}
return
true
;
}
waitingForFirstSyncSample
=
false
;
boolean
bufferEncrypted
=
buffer
.
isEncrypted
(
)
;
waitingForKeys
=
shouldWaitForKeys
(
bufferEncrypted
)
;
if
(
waitingForKeys
)
{
return
false
;
}
if
(
codecNeedsDiscardToSpsWorkaround
&
&
!
bufferEncrypted
)
{
NalUnitUtil
.
discardToSps
(
buffer
.
data
)
;
if
(
buffer
.
data
.
position
(
)
=
=
0
)
{
return
true
;
}
codecNeedsDiscardToSpsWorkaround
=
false
;
}
try
{
long
presentationTimeUs
=
buffer
.
timeUs
;
if
(
buffer
.
isDecodeOnly
(
)
)
{
decodeOnlyPresentationTimestamps
.
add
(
presentationTimeUs
)
;
}
if
(
waitingForFirstSampleInFormat
)
{
formatQueue
.
add
(
presentationTimeUs
inputFormat
)
;
waitingForFirstSampleInFormat
=
false
;
}
largestQueuedPresentationTimeUs
=
Math
.
max
(
largestQueuedPresentationTimeUs
presentationTimeUs
)
;
buffer
.
flip
(
)
;
if
(
buffer
.
hasSupplementalData
(
)
)
{
handleInputBufferSupplementalData
(
buffer
)
;
}
onQueueInputBuffer
(
buffer
)
;
if
(
bufferEncrypted
)
{
MediaCodec
.
CryptoInfo
cryptoInfo
=
getFrameworkCryptoInfo
(
buffer
adaptiveReconfigurationBytes
)
;
codec
.
queueSecureInputBuffer
(
inputIndex
0
cryptoInfo
presentationTimeUs
0
)
;
}
else
{
codec
.
queueInputBuffer
(
inputIndex
0
buffer
.
data
.
limit
(
)
presentationTimeUs
0
)
;
}
resetInputBuffer
(
)
;
codecReceivedBuffers
=
true
;
codecReconfigurationState
=
RECONFIGURATION_STATE_NONE
;
decoderCounters
.
inputBufferCount
+
+
;
}
catch
(
CryptoException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
return
true
;
}
private
boolean
shouldWaitForKeys
(
boolean
bufferEncrypted
)
throws
ExoPlaybackException
{
if
(
codecDrmSession
=
=
null
|
|
(
!
bufferEncrypted
&
&
(
playClearSamplesWithoutKeys
|
|
codecDrmSession
.
playClearSamplesWithoutKeys
(
)
)
)
)
{
return
false
;
}
DrmSession
.
State
int
drmSessionState
=
codecDrmSession
.
getState
(
)
;
if
(
drmSessionState
=
=
DrmSession
.
STATE_ERROR
)
{
throw
createRendererException
(
codecDrmSession
.
getError
(
)
inputFormat
)
;
}
return
drmSessionState
!
=
DrmSession
.
STATE_OPENED_WITH_KEYS
;
}
protected
void
onCodecInitialized
(
String
name
long
initializedTimestampMs
long
initializationDurationMs
)
{
}
SuppressWarnings
(
"
unchecked
"
)
protected
void
onInputFormatChanged
(
FormatHolder
formatHolder
)
throws
ExoPlaybackException
{
waitingForFirstSampleInFormat
=
true
;
Format
newFormat
=
Assertions
.
checkNotNull
(
formatHolder
.
format
)
;
if
(
formatHolder
.
includesDrmSession
)
{
setSourceDrmSession
(
(
DrmSession
<
FrameworkMediaCrypto
>
)
formatHolder
.
drmSession
)
;
}
else
{
sourceDrmSession
=
getUpdatedSourceDrmSession
(
inputFormat
newFormat
drmSessionManager
sourceDrmSession
)
;
}
inputFormat
=
newFormat
;
if
(
codec
=
=
null
)
{
maybeInitCodec
(
)
;
return
;
}
if
(
(
sourceDrmSession
=
=
null
&
&
codecDrmSession
!
=
null
)
|
|
(
sourceDrmSession
!
=
null
&
&
codecDrmSession
=
=
null
)
|
|
(
sourceDrmSession
!
=
codecDrmSession
&
&
!
codecInfo
.
secure
&
&
maybeRequiresSecureDecoder
(
sourceDrmSession
newFormat
)
)
|
|
(
Util
.
SDK_INT
<
23
&
&
sourceDrmSession
!
=
codecDrmSession
)
)
{
drainAndReinitializeCodec
(
)
;
return
;
}
switch
(
canKeepCodec
(
codec
codecInfo
codecFormat
newFormat
)
)
{
case
KEEP_CODEC_RESULT_NO
:
drainAndReinitializeCodec
(
)
;
break
;
case
KEEP_CODEC_RESULT_YES_WITH_FLUSH
:
codecFormat
=
newFormat
;
updateCodecOperatingRate
(
)
;
if
(
sourceDrmSession
!
=
codecDrmSession
)
{
drainAndUpdateCodecDrmSession
(
)
;
}
else
{
drainAndFlushCodec
(
)
;
}
break
;
case
KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION
:
if
(
codecNeedsReconfigureWorkaround
)
{
drainAndReinitializeCodec
(
)
;
}
else
{
codecReconfigured
=
true
;
codecReconfigurationState
=
RECONFIGURATION_STATE_WRITE_PENDING
;
codecNeedsAdaptationWorkaroundBuffer
=
codecAdaptationWorkaroundMode
=
=
ADAPTATION_WORKAROUND_MODE_ALWAYS
|
|
(
codecAdaptationWorkaroundMode
=
=
ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
&
&
newFormat
.
width
=
=
codecFormat
.
width
&
&
newFormat
.
height
=
=
codecFormat
.
height
)
;
codecFormat
=
newFormat
;
updateCodecOperatingRate
(
)
;
if
(
sourceDrmSession
!
=
codecDrmSession
)
{
drainAndUpdateCodecDrmSession
(
)
;
}
}
break
;
case
KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION
:
codecFormat
=
newFormat
;
updateCodecOperatingRate
(
)
;
if
(
sourceDrmSession
!
=
codecDrmSession
)
{
drainAndUpdateCodecDrmSession
(
)
;
}
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
protected
void
onOutputFormatChanged
(
MediaCodec
codec
MediaFormat
outputMediaFormat
)
throws
ExoPlaybackException
{
}
protected
void
handleInputBufferSupplementalData
(
DecoderInputBuffer
buffer
)
throws
ExoPlaybackException
{
}
protected
void
onQueueInputBuffer
(
DecoderInputBuffer
buffer
)
{
}
protected
void
onProcessedOutputBuffer
(
long
presentationTimeUs
)
{
}
protected
KeepCodecResult
int
canKeepCodec
(
MediaCodec
codec
MediaCodecInfo
codecInfo
Format
oldFormat
Format
newFormat
)
{
return
KEEP_CODEC_RESULT_NO
;
}
Override
public
boolean
isEnded
(
)
{
return
outputStreamEnded
;
}
Override
public
boolean
isReady
(
)
{
return
inputFormat
!
=
null
&
&
!
waitingForKeys
&
&
(
isSourceReady
(
)
|
|
hasOutputBuffer
(
)
|
|
(
codecHotswapDeadlineMs
!
=
C
.
TIME_UNSET
&
&
SystemClock
.
elapsedRealtime
(
)
<
codecHotswapDeadlineMs
)
)
;
}
protected
long
getDequeueOutputBufferTimeoutUs
(
)
{
return
0
;
}
protected
float
getCodecOperatingRateV23
(
float
operatingRate
Format
format
Format
[
]
streamFormats
)
{
return
CODEC_OPERATING_RATE_UNSET
;
}
private
void
updateCodecOperatingRate
(
)
throws
ExoPlaybackException
{
if
(
Util
.
SDK_INT
<
23
)
{
return
;
}
float
newCodecOperatingRate
=
getCodecOperatingRateV23
(
rendererOperatingRate
codecFormat
getStreamFormats
(
)
)
;
if
(
codecOperatingRate
=
=
newCodecOperatingRate
)
{
}
else
if
(
newCodecOperatingRate
=
=
CODEC_OPERATING_RATE_UNSET
)
{
drainAndReinitializeCodec
(
)
;
}
else
if
(
codecOperatingRate
!
=
CODEC_OPERATING_RATE_UNSET
|
|
newCodecOperatingRate
>
assumedMinimumCodecOperatingRate
)
{
Bundle
codecParameters
=
new
Bundle
(
)
;
codecParameters
.
putFloat
(
MediaFormat
.
KEY_OPERATING_RATE
newCodecOperatingRate
)
;
codec
.
setParameters
(
codecParameters
)
;
codecOperatingRate
=
newCodecOperatingRate
;
}
}
private
void
drainAndFlushCodec
(
)
{
if
(
codecReceivedBuffers
)
{
codecDrainState
=
DRAIN_STATE_SIGNAL_END_OF_STREAM
;
codecDrainAction
=
DRAIN_ACTION_FLUSH
;
}
}
private
void
drainAndUpdateCodecDrmSession
(
)
throws
ExoPlaybackException
{
if
(
Util
.
SDK_INT
<
23
)
{
drainAndReinitializeCodec
(
)
;
return
;
}
if
(
codecReceivedBuffers
)
{
codecDrainState
=
DRAIN_STATE_SIGNAL_END_OF_STREAM
;
codecDrainAction
=
DRAIN_ACTION_UPDATE_DRM_SESSION
;
}
else
{
updateDrmSessionOrReinitializeCodecV23
(
)
;
}
}
private
void
drainAndReinitializeCodec
(
)
throws
ExoPlaybackException
{
if
(
codecReceivedBuffers
)
{
codecDrainState
=
DRAIN_STATE_SIGNAL_END_OF_STREAM
;
codecDrainAction
=
DRAIN_ACTION_REINITIALIZE
;
}
else
{
reinitializeCodec
(
)
;
}
}
private
boolean
drainOutputBuffer
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
{
if
(
!
hasOutputBuffer
(
)
)
{
int
outputIndex
;
if
(
codecNeedsEosOutputExceptionWorkaround
&
&
codecReceivedEos
)
{
try
{
outputIndex
=
codec
.
dequeueOutputBuffer
(
outputBufferInfo
getDequeueOutputBufferTimeoutUs
(
)
)
;
}
catch
(
IllegalStateException
e
)
{
processEndOfStream
(
)
;
if
(
outputStreamEnded
)
{
releaseCodec
(
)
;
}
return
false
;
}
}
else
{
outputIndex
=
codec
.
dequeueOutputBuffer
(
outputBufferInfo
getDequeueOutputBufferTimeoutUs
(
)
)
;
}
if
(
outputIndex
<
0
)
{
if
(
outputIndex
=
=
MediaCodec
.
INFO_OUTPUT_FORMAT_CHANGED
)
{
processOutputFormat
(
)
;
return
true
;
}
else
if
(
outputIndex
=
=
MediaCodec
.
INFO_OUTPUT_BUFFERS_CHANGED
)
{
processOutputBuffersChanged
(
)
;
return
true
;
}
if
(
codecNeedsEosPropagation
&
&
(
inputStreamEnded
|
|
codecDrainState
=
=
DRAIN_STATE_WAIT_END_OF_STREAM
)
)
{
processEndOfStream
(
)
;
}
return
false
;
}
if
(
shouldSkipAdaptationWorkaroundOutputBuffer
)
{
shouldSkipAdaptationWorkaroundOutputBuffer
=
false
;
codec
.
releaseOutputBuffer
(
outputIndex
false
)
;
return
true
;
}
else
if
(
outputBufferInfo
.
size
=
=
0
&
&
(
outputBufferInfo
.
flags
&
MediaCodec
.
BUFFER_FLAG_END_OF_STREAM
)
!
=
0
)
{
processEndOfStream
(
)
;
return
false
;
}
this
.
outputIndex
=
outputIndex
;
outputBuffer
=
getOutputBuffer
(
outputIndex
)
;
if
(
outputBuffer
!
=
null
)
{
outputBuffer
.
position
(
outputBufferInfo
.
offset
)
;
outputBuffer
.
limit
(
outputBufferInfo
.
offset
+
outputBufferInfo
.
size
)
;
}
isDecodeOnlyOutputBuffer
=
isDecodeOnlyBuffer
(
outputBufferInfo
.
presentationTimeUs
)
;
isLastOutputBuffer
=
lastBufferInStreamPresentationTimeUs
=
=
outputBufferInfo
.
presentationTimeUs
;
updateOutputFormatForTime
(
outputBufferInfo
.
presentationTimeUs
)
;
}
boolean
processedOutputBuffer
;
if
(
codecNeedsEosOutputExceptionWorkaround
&
&
codecReceivedEos
)
{
try
{
processedOutputBuffer
=
processOutputBuffer
(
positionUs
elapsedRealtimeUs
codec
outputBuffer
outputIndex
outputBufferInfo
.
flags
outputBufferInfo
.
presentationTimeUs
isDecodeOnlyOutputBuffer
isLastOutputBuffer
outputFormat
)
;
}
catch
(
IllegalStateException
e
)
{
processEndOfStream
(
)
;
if
(
outputStreamEnded
)
{
releaseCodec
(
)
;
}
return
false
;
}
}
else
{
processedOutputBuffer
=
processOutputBuffer
(
positionUs
elapsedRealtimeUs
codec
outputBuffer
outputIndex
outputBufferInfo
.
flags
outputBufferInfo
.
presentationTimeUs
isDecodeOnlyOutputBuffer
isLastOutputBuffer
outputFormat
)
;
}
if
(
processedOutputBuffer
)
{
onProcessedOutputBuffer
(
outputBufferInfo
.
presentationTimeUs
)
;
boolean
isEndOfStream
=
(
outputBufferInfo
.
flags
&
MediaCodec
.
BUFFER_FLAG_END_OF_STREAM
)
!
=
0
;
resetOutputBuffer
(
)
;
if
(
!
isEndOfStream
)
{
return
true
;
}
processEndOfStream
(
)
;
}
return
false
;
}
private
void
processOutputFormat
(
)
throws
ExoPlaybackException
{
codecHasOutputMediaFormat
=
true
;
MediaFormat
mediaFormat
=
codec
.
getOutputFormat
(
)
;
if
(
codecAdaptationWorkaroundMode
!
=
ADAPTATION_WORKAROUND_MODE_NEVER
&
&
mediaFormat
.
getInteger
(
MediaFormat
.
KEY_WIDTH
)
=
=
ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
&
&
mediaFormat
.
getInteger
(
MediaFormat
.
KEY_HEIGHT
)
=
=
ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
)
{
shouldSkipAdaptationWorkaroundOutputBuffer
=
true
;
return
;
}
if
(
codecNeedsMonoChannelCountWorkaround
)
{
mediaFormat
.
setInteger
(
MediaFormat
.
KEY_CHANNEL_COUNT
1
)
;
}
onOutputFormatChanged
(
codec
mediaFormat
)
;
}
private
void
processOutputBuffersChanged
(
)
{
if
(
Util
.
SDK_INT
<
21
)
{
outputBuffers
=
codec
.
getOutputBuffers
(
)
;
}
}
protected
abstract
boolean
processOutputBuffer
(
long
positionUs
long
elapsedRealtimeUs
MediaCodec
codec
ByteBuffer
buffer
int
bufferIndex
int
bufferFlags
long
bufferPresentationTimeUs
boolean
isDecodeOnlyBuffer
boolean
isLastBuffer
Format
format
)
throws
ExoPlaybackException
;
protected
void
renderToEndOfStream
(
)
throws
ExoPlaybackException
{
}
private
void
processEndOfStream
(
)
throws
ExoPlaybackException
{
switch
(
codecDrainAction
)
{
case
DRAIN_ACTION_REINITIALIZE
:
reinitializeCodec
(
)
;
break
;
case
DRAIN_ACTION_UPDATE_DRM_SESSION
:
updateDrmSessionOrReinitializeCodecV23
(
)
;
break
;
case
DRAIN_ACTION_FLUSH
:
flushOrReinitializeCodec
(
)
;
break
;
case
DRAIN_ACTION_NONE
:
default
:
outputStreamEnded
=
true
;
renderToEndOfStream
(
)
;
break
;
}
}
protected
final
void
setPendingOutputEndOfStream
(
)
{
pendingOutputEndOfStream
=
true
;
}
private
void
reinitializeCodec
(
)
throws
ExoPlaybackException
{
releaseCodec
(
)
;
maybeInitCodec
(
)
;
}
private
boolean
isDecodeOnlyBuffer
(
long
presentationTimeUs
)
{
int
size
=
decodeOnlyPresentationTimestamps
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
decodeOnlyPresentationTimestamps
.
get
(
i
)
=
=
presentationTimeUs
)
{
decodeOnlyPresentationTimestamps
.
remove
(
i
)
;
return
true
;
}
}
return
false
;
}
TargetApi
(
23
)
private
void
updateDrmSessionOrReinitializeCodecV23
(
)
throws
ExoPlaybackException
{
Nullable
FrameworkMediaCrypto
sessionMediaCrypto
=
sourceDrmSession
.
getMediaCrypto
(
)
;
if
(
sessionMediaCrypto
=
=
null
)
{
reinitializeCodec
(
)
;
return
;
}
if
(
C
.
PLAYREADY_UUID
.
equals
(
sessionMediaCrypto
.
uuid
)
)
{
reinitializeCodec
(
)
;
return
;
}
if
(
flushOrReinitializeCodec
(
)
)
{
return
;
}
try
{
mediaCrypto
.
setMediaDrmSession
(
sessionMediaCrypto
.
sessionId
)
;
}
catch
(
MediaCryptoException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
setCodecDrmSession
(
sourceDrmSession
)
;
codecDrainState
=
DRAIN_STATE_NONE
;
codecDrainAction
=
DRAIN_ACTION_NONE
;
}
private
static
boolean
maybeRequiresSecureDecoder
(
DrmSession
<
FrameworkMediaCrypto
>
drmSession
Format
format
)
{
Nullable
FrameworkMediaCrypto
sessionMediaCrypto
=
drmSession
.
getMediaCrypto
(
)
;
if
(
sessionMediaCrypto
=
=
null
)
{
return
true
;
}
if
(
sessionMediaCrypto
.
forceAllowInsecureDecoderComponents
)
{
return
false
;
}
MediaCrypto
mediaCrypto
;
try
{
mediaCrypto
=
new
MediaCrypto
(
sessionMediaCrypto
.
uuid
sessionMediaCrypto
.
sessionId
)
;
}
catch
(
MediaCryptoException
e
)
{
return
true
;
}
try
{
return
mediaCrypto
.
requiresSecureDecoderComponent
(
format
.
sampleMimeType
)
;
}
finally
{
mediaCrypto
.
release
(
)
;
}
}
private
static
MediaCodec
.
CryptoInfo
getFrameworkCryptoInfo
(
DecoderInputBuffer
buffer
int
adaptiveReconfigurationBytes
)
{
MediaCodec
.
CryptoInfo
cryptoInfo
=
buffer
.
cryptoInfo
.
getFrameworkCryptoInfo
(
)
;
if
(
adaptiveReconfigurationBytes
=
=
0
)
{
return
cryptoInfo
;
}
if
(
cryptoInfo
.
numBytesOfClearData
=
=
null
)
{
cryptoInfo
.
numBytesOfClearData
=
new
int
[
1
]
;
}
cryptoInfo
.
numBytesOfClearData
[
0
]
+
=
adaptiveReconfigurationBytes
;
return
cryptoInfo
;
}
private
static
boolean
isMediaCodecException
(
IllegalStateException
error
)
{
if
(
Util
.
SDK_INT
>
=
21
&
&
isMediaCodecExceptionV21
(
error
)
)
{
return
true
;
}
StackTraceElement
[
]
stackTrace
=
error
.
getStackTrace
(
)
;
return
stackTrace
.
length
>
0
&
&
stackTrace
[
0
]
.
getClassName
(
)
.
equals
(
"
android
.
media
.
MediaCodec
"
)
;
}
TargetApi
(
21
)
private
static
boolean
isMediaCodecExceptionV21
(
IllegalStateException
error
)
{
return
error
instanceof
MediaCodec
.
CodecException
;
}
private
static
boolean
codecNeedsFlushWorkaround
(
String
name
)
{
return
Util
.
SDK_INT
<
18
|
|
(
Util
.
SDK_INT
=
=
18
&
&
(
"
OMX
.
SEC
.
avc
.
dec
"
.
equals
(
name
)
|
|
"
OMX
.
SEC
.
avc
.
dec
.
secure
"
.
equals
(
name
)
)
)
|
|
(
Util
.
SDK_INT
=
=
19
&
&
Util
.
MODEL
.
startsWith
(
"
SM
-
G800
"
)
&
&
(
"
OMX
.
Exynos
.
avc
.
dec
"
.
equals
(
name
)
|
|
"
OMX
.
Exynos
.
avc
.
dec
.
secure
"
.
equals
(
name
)
)
)
;
}
private
AdaptationWorkaroundMode
int
codecAdaptationWorkaroundMode
(
String
name
)
{
if
(
Util
.
SDK_INT
<
=
25
&
&
"
OMX
.
Exynos
.
avc
.
dec
.
secure
"
.
equals
(
name
)
&
&
(
Util
.
MODEL
.
startsWith
(
"
SM
-
T585
"
)
|
|
Util
.
MODEL
.
startsWith
(
"
SM
-
A510
"
)
|
|
Util
.
MODEL
.
startsWith
(
"
SM
-
A520
"
)
|
|
Util
.
MODEL
.
startsWith
(
"
SM
-
J700
"
)
)
)
{
return
ADAPTATION_WORKAROUND_MODE_ALWAYS
;
}
else
if
(
Util
.
SDK_INT
<
24
&
&
(
"
OMX
.
Nvidia
.
h264
.
decode
"
.
equals
(
name
)
|
|
"
OMX
.
Nvidia
.
h264
.
decode
.
secure
"
.
equals
(
name
)
)
&
&
(
"
flounder
"
.
equals
(
Util
.
DEVICE
)
|
|
"
flounder_lte
"
.
equals
(
Util
.
DEVICE
)
|
|
"
grouper
"
.
equals
(
Util
.
DEVICE
)
|
|
"
tilapia
"
.
equals
(
Util
.
DEVICE
)
)
)
{
return
ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION
;
}
else
{
return
ADAPTATION_WORKAROUND_MODE_NEVER
;
}
}
private
static
boolean
codecNeedsReconfigureWorkaround
(
String
name
)
{
return
Util
.
MODEL
.
startsWith
(
"
SM
-
T230
"
)
&
&
"
OMX
.
MARVELL
.
VIDEO
.
HW
.
CODA7542DECODER
"
.
equals
(
name
)
;
}
private
static
boolean
codecNeedsDiscardToSpsWorkaround
(
String
name
Format
format
)
{
return
Util
.
SDK_INT
<
21
&
&
format
.
initializationData
.
isEmpty
(
)
&
&
"
OMX
.
MTK
.
VIDEO
.
DECODER
.
AVC
"
.
equals
(
name
)
;
}
private
static
boolean
codecNeedsEosPropagationWorkaround
(
MediaCodecInfo
codecInfo
)
{
String
name
=
codecInfo
.
name
;
return
(
Util
.
SDK_INT
<
=
25
&
&
"
OMX
.
rk
.
video_decoder
.
avc
"
.
equals
(
name
)
)
|
|
(
Util
.
SDK_INT
<
=
17
&
&
"
OMX
.
allwinner
.
video
.
decoder
.
avc
"
.
equals
(
name
)
)
|
|
(
"
Amazon
"
.
equals
(
Util
.
MANUFACTURER
)
&
&
"
AFTS
"
.
equals
(
Util
.
MODEL
)
&
&
codecInfo
.
secure
)
;
}
private
static
boolean
codecNeedsEosFlushWorkaround
(
String
name
)
{
return
(
Util
.
SDK_INT
<
=
23
&
&
"
OMX
.
google
.
vorbis
.
decoder
"
.
equals
(
name
)
)
|
|
(
Util
.
SDK_INT
<
=
19
&
&
(
"
hb2000
"
.
equals
(
Util
.
DEVICE
)
|
|
"
stvm8
"
.
equals
(
Util
.
DEVICE
)
)
&
&
(
"
OMX
.
amlogic
.
avc
.
decoder
.
awesome
"
.
equals
(
name
)
|
|
"
OMX
.
amlogic
.
avc
.
decoder
.
awesome
.
secure
"
.
equals
(
name
)
)
)
;
}
private
static
boolean
codecNeedsEosOutputExceptionWorkaround
(
String
name
)
{
return
Util
.
SDK_INT
=
=
21
&
&
"
OMX
.
google
.
aac
.
decoder
"
.
equals
(
name
)
;
}
private
static
boolean
codecNeedsMonoChannelCountWorkaround
(
String
name
Format
format
)
{
return
Util
.
SDK_INT
<
=
18
&
&
format
.
channelCount
=
=
1
&
&
"
OMX
.
MTK
.
AUDIO
.
DECODER
.
MP3
"
.
equals
(
name
)
;
}
private
static
boolean
codecNeedsSosFlushWorkaround
(
String
name
)
{
return
Util
.
SDK_INT
=
=
29
&
&
"
c2
.
android
.
aac
.
decoder
"
.
equals
(
name
)
;
}
}
