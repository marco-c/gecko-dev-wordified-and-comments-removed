package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
TrackIdGenerator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableBitArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
java
.
io
.
IOException
;
public
final
class
PsExtractor
implements
Extractor
{
public
static
final
ExtractorsFactory
FACTORY
=
(
)
-
>
new
Extractor
[
]
{
new
PsExtractor
(
)
}
;
static
final
int
PACK_START_CODE
=
0x000001BA
;
static
final
int
SYSTEM_HEADER_START_CODE
=
0x000001BB
;
static
final
int
PACKET_START_CODE_PREFIX
=
0x000001
;
static
final
int
MPEG_PROGRAM_END_CODE
=
0x000001B9
;
private
static
final
int
MAX_STREAM_ID_PLUS_ONE
=
0x100
;
private
static
final
long
MAX_SEARCH_LENGTH
=
1024
*
1024
;
private
static
final
long
MAX_SEARCH_LENGTH_AFTER_AUDIO_AND_VIDEO_FOUND
=
8
*
1024
;
public
static
final
int
PRIVATE_STREAM_1
=
0xBD
;
public
static
final
int
AUDIO_STREAM
=
0xC0
;
public
static
final
int
AUDIO_STREAM_MASK
=
0xE0
;
public
static
final
int
VIDEO_STREAM
=
0xE0
;
public
static
final
int
VIDEO_STREAM_MASK
=
0xF0
;
private
final
TimestampAdjuster
timestampAdjuster
;
private
final
SparseArray
<
PesReader
>
psPayloadReaders
;
private
final
ParsableByteArray
psPacketBuffer
;
private
final
PsDurationReader
durationReader
;
private
boolean
foundAllTracks
;
private
boolean
foundAudioTrack
;
private
boolean
foundVideoTrack
;
private
long
lastTrackPosition
;
private
PsBinarySearchSeeker
psBinarySearchSeeker
;
private
ExtractorOutput
output
;
private
boolean
hasOutputSeekMap
;
public
PsExtractor
(
)
{
this
(
new
TimestampAdjuster
(
0
)
)
;
}
public
PsExtractor
(
TimestampAdjuster
timestampAdjuster
)
{
this
.
timestampAdjuster
=
timestampAdjuster
;
psPacketBuffer
=
new
ParsableByteArray
(
4096
)
;
psPayloadReaders
=
new
SparseArray
<
>
(
)
;
durationReader
=
new
PsDurationReader
(
)
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
byte
[
]
scratch
=
new
byte
[
14
]
;
input
.
peekFully
(
scratch
0
14
)
;
if
(
PACK_START_CODE
!
=
(
(
(
scratch
[
0
]
&
0xFF
)
<
<
24
)
|
(
(
scratch
[
1
]
&
0xFF
)
<
<
16
)
|
(
(
scratch
[
2
]
&
0xFF
)
<
<
8
)
|
(
scratch
[
3
]
&
0xFF
)
)
)
{
return
false
;
}
if
(
(
scratch
[
4
]
&
0xC4
)
!
=
0x44
)
{
return
false
;
}
if
(
(
scratch
[
6
]
&
0x04
)
!
=
0x04
)
{
return
false
;
}
if
(
(
scratch
[
8
]
&
0x04
)
!
=
0x04
)
{
return
false
;
}
if
(
(
scratch
[
9
]
&
0x01
)
!
=
0x01
)
{
return
false
;
}
if
(
(
scratch
[
12
]
&
0x03
)
!
=
0x03
)
{
return
false
;
}
int
packStuffingLength
=
scratch
[
13
]
&
0x07
;
input
.
advancePeekPosition
(
packStuffingLength
)
;
input
.
peekFully
(
scratch
0
3
)
;
return
(
PACKET_START_CODE_PREFIX
=
=
(
(
(
scratch
[
0
]
&
0xFF
)
<
<
16
)
|
(
(
scratch
[
1
]
&
0xFF
)
<
<
8
)
|
(
scratch
[
2
]
&
0xFF
)
)
)
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
this
.
output
=
output
;
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
boolean
hasNotEncounteredFirstTimestamp
=
timestampAdjuster
.
getTimestampOffsetUs
(
)
=
=
C
.
TIME_UNSET
;
if
(
hasNotEncounteredFirstTimestamp
|
|
(
timestampAdjuster
.
getFirstSampleTimestampUs
(
)
!
=
0
&
&
timestampAdjuster
.
getFirstSampleTimestampUs
(
)
!
=
timeUs
)
)
{
timestampAdjuster
.
reset
(
)
;
timestampAdjuster
.
setFirstSampleTimestampUs
(
timeUs
)
;
}
if
(
psBinarySearchSeeker
!
=
null
)
{
psBinarySearchSeeker
.
setSeekTargetUs
(
timeUs
)
;
}
for
(
int
i
=
0
;
i
<
psPayloadReaders
.
size
(
)
;
i
+
+
)
{
psPayloadReaders
.
valueAt
(
i
)
.
seek
(
)
;
}
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
long
inputLength
=
input
.
getLength
(
)
;
boolean
canReadDuration
=
inputLength
!
=
C
.
LENGTH_UNSET
;
if
(
canReadDuration
&
&
!
durationReader
.
isDurationReadFinished
(
)
)
{
return
durationReader
.
readDuration
(
input
seekPosition
)
;
}
maybeOutputSeekMap
(
inputLength
)
;
if
(
psBinarySearchSeeker
!
=
null
&
&
psBinarySearchSeeker
.
isSeeking
(
)
)
{
return
psBinarySearchSeeker
.
handlePendingSeek
(
input
seekPosition
)
;
}
input
.
resetPeekPosition
(
)
;
long
peekBytesLeft
=
inputLength
!
=
C
.
LENGTH_UNSET
?
inputLength
-
input
.
getPeekPosition
(
)
:
C
.
LENGTH_UNSET
;
if
(
peekBytesLeft
!
=
C
.
LENGTH_UNSET
&
&
peekBytesLeft
<
4
)
{
return
RESULT_END_OF_INPUT
;
}
if
(
!
input
.
peekFully
(
psPacketBuffer
.
data
0
4
true
)
)
{
return
RESULT_END_OF_INPUT
;
}
psPacketBuffer
.
setPosition
(
0
)
;
int
nextStartCode
=
psPacketBuffer
.
readInt
(
)
;
if
(
nextStartCode
=
=
MPEG_PROGRAM_END_CODE
)
{
return
RESULT_END_OF_INPUT
;
}
else
if
(
nextStartCode
=
=
PACK_START_CODE
)
{
input
.
peekFully
(
psPacketBuffer
.
data
0
10
)
;
psPacketBuffer
.
setPosition
(
9
)
;
int
packStuffingLength
=
psPacketBuffer
.
readUnsignedByte
(
)
&
0x07
;
input
.
skipFully
(
packStuffingLength
+
14
)
;
return
RESULT_CONTINUE
;
}
else
if
(
nextStartCode
=
=
SYSTEM_HEADER_START_CODE
)
{
input
.
peekFully
(
psPacketBuffer
.
data
0
2
)
;
psPacketBuffer
.
setPosition
(
0
)
;
int
systemHeaderLength
=
psPacketBuffer
.
readUnsignedShort
(
)
;
input
.
skipFully
(
systemHeaderLength
+
6
)
;
return
RESULT_CONTINUE
;
}
else
if
(
(
(
nextStartCode
&
0xFFFFFF00
)
>
>
8
)
!
=
PACKET_START_CODE_PREFIX
)
{
input
.
skipFully
(
1
)
;
return
RESULT_CONTINUE
;
}
int
streamId
=
nextStartCode
&
0xFF
;
PesReader
payloadReader
=
psPayloadReaders
.
get
(
streamId
)
;
if
(
!
foundAllTracks
)
{
if
(
payloadReader
=
=
null
)
{
ElementaryStreamReader
elementaryStreamReader
=
null
;
if
(
streamId
=
=
PRIVATE_STREAM_1
)
{
elementaryStreamReader
=
new
Ac3Reader
(
)
;
foundAudioTrack
=
true
;
lastTrackPosition
=
input
.
getPosition
(
)
;
}
else
if
(
(
streamId
&
AUDIO_STREAM_MASK
)
=
=
AUDIO_STREAM
)
{
elementaryStreamReader
=
new
MpegAudioReader
(
)
;
foundAudioTrack
=
true
;
lastTrackPosition
=
input
.
getPosition
(
)
;
}
else
if
(
(
streamId
&
VIDEO_STREAM_MASK
)
=
=
VIDEO_STREAM
)
{
elementaryStreamReader
=
new
H262Reader
(
)
;
foundVideoTrack
=
true
;
lastTrackPosition
=
input
.
getPosition
(
)
;
}
if
(
elementaryStreamReader
!
=
null
)
{
TrackIdGenerator
idGenerator
=
new
TrackIdGenerator
(
streamId
MAX_STREAM_ID_PLUS_ONE
)
;
elementaryStreamReader
.
createTracks
(
output
idGenerator
)
;
payloadReader
=
new
PesReader
(
elementaryStreamReader
timestampAdjuster
)
;
psPayloadReaders
.
put
(
streamId
payloadReader
)
;
}
}
long
maxSearchPosition
=
foundAudioTrack
&
&
foundVideoTrack
?
lastTrackPosition
+
MAX_SEARCH_LENGTH_AFTER_AUDIO_AND_VIDEO_FOUND
:
MAX_SEARCH_LENGTH
;
if
(
input
.
getPosition
(
)
>
maxSearchPosition
)
{
foundAllTracks
=
true
;
output
.
endTracks
(
)
;
}
}
input
.
peekFully
(
psPacketBuffer
.
data
0
2
)
;
psPacketBuffer
.
setPosition
(
0
)
;
int
payloadLength
=
psPacketBuffer
.
readUnsignedShort
(
)
;
int
pesLength
=
payloadLength
+
6
;
if
(
payloadReader
=
=
null
)
{
input
.
skipFully
(
pesLength
)
;
}
else
{
psPacketBuffer
.
reset
(
pesLength
)
;
input
.
readFully
(
psPacketBuffer
.
data
0
pesLength
)
;
psPacketBuffer
.
setPosition
(
6
)
;
payloadReader
.
consume
(
psPacketBuffer
)
;
psPacketBuffer
.
setLimit
(
psPacketBuffer
.
capacity
(
)
)
;
}
return
RESULT_CONTINUE
;
}
private
void
maybeOutputSeekMap
(
long
inputLength
)
{
if
(
!
hasOutputSeekMap
)
{
hasOutputSeekMap
=
true
;
if
(
durationReader
.
getDurationUs
(
)
!
=
C
.
TIME_UNSET
)
{
psBinarySearchSeeker
=
new
PsBinarySearchSeeker
(
durationReader
.
getScrTimestampAdjuster
(
)
durationReader
.
getDurationUs
(
)
inputLength
)
;
output
.
seekMap
(
psBinarySearchSeeker
.
getSeekMap
(
)
)
;
}
else
{
output
.
seekMap
(
new
SeekMap
.
Unseekable
(
durationReader
.
getDurationUs
(
)
)
)
;
}
}
}
private
static
final
class
PesReader
{
private
static
final
int
PES_SCRATCH_SIZE
=
64
;
private
final
ElementaryStreamReader
pesPayloadReader
;
private
final
TimestampAdjuster
timestampAdjuster
;
private
final
ParsableBitArray
pesScratch
;
private
boolean
ptsFlag
;
private
boolean
dtsFlag
;
private
boolean
seenFirstDts
;
private
int
extendedHeaderLength
;
private
long
timeUs
;
public
PesReader
(
ElementaryStreamReader
pesPayloadReader
TimestampAdjuster
timestampAdjuster
)
{
this
.
pesPayloadReader
=
pesPayloadReader
;
this
.
timestampAdjuster
=
timestampAdjuster
;
pesScratch
=
new
ParsableBitArray
(
new
byte
[
PES_SCRATCH_SIZE
]
)
;
}
public
void
seek
(
)
{
seenFirstDts
=
false
;
pesPayloadReader
.
seek
(
)
;
}
public
void
consume
(
ParsableByteArray
data
)
throws
ParserException
{
data
.
readBytes
(
pesScratch
.
data
0
3
)
;
pesScratch
.
setPosition
(
0
)
;
parseHeader
(
)
;
data
.
readBytes
(
pesScratch
.
data
0
extendedHeaderLength
)
;
pesScratch
.
setPosition
(
0
)
;
parseHeaderExtension
(
)
;
pesPayloadReader
.
packetStarted
(
timeUs
TsPayloadReader
.
FLAG_DATA_ALIGNMENT_INDICATOR
)
;
pesPayloadReader
.
consume
(
data
)
;
pesPayloadReader
.
packetFinished
(
)
;
}
private
void
parseHeader
(
)
{
pesScratch
.
skipBits
(
8
)
;
ptsFlag
=
pesScratch
.
readBit
(
)
;
dtsFlag
=
pesScratch
.
readBit
(
)
;
pesScratch
.
skipBits
(
6
)
;
extendedHeaderLength
=
pesScratch
.
readBits
(
8
)
;
}
private
void
parseHeaderExtension
(
)
{
timeUs
=
0
;
if
(
ptsFlag
)
{
pesScratch
.
skipBits
(
4
)
;
long
pts
=
(
long
)
pesScratch
.
readBits
(
3
)
<
<
30
;
pesScratch
.
skipBits
(
1
)
;
pts
|
=
pesScratch
.
readBits
(
15
)
<
<
15
;
pesScratch
.
skipBits
(
1
)
;
pts
|
=
pesScratch
.
readBits
(
15
)
;
pesScratch
.
skipBits
(
1
)
;
if
(
!
seenFirstDts
&
&
dtsFlag
)
{
pesScratch
.
skipBits
(
4
)
;
long
dts
=
(
long
)
pesScratch
.
readBits
(
3
)
<
<
30
;
pesScratch
.
skipBits
(
1
)
;
dts
|
=
pesScratch
.
readBits
(
15
)
<
<
15
;
pesScratch
.
skipBits
(
1
)
;
dts
|
=
pesScratch
.
readBits
(
15
)
;
pesScratch
.
skipBits
(
1
)
;
timestampAdjuster
.
adjustTsTimestamp
(
dts
)
;
seenFirstDts
=
true
;
}
timeUs
=
timestampAdjuster
.
adjustTsTimestamp
(
pts
)
;
}
}
}
}
