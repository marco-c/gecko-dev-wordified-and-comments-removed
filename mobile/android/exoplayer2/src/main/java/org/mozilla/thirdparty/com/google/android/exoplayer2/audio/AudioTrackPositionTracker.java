package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
.
castNonNull
;
import
android
.
media
.
AudioTimestamp
;
import
android
.
media
.
AudioTrack
;
import
android
.
os
.
SystemClock
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
lang
.
reflect
.
Method
;
final
class
AudioTrackPositionTracker
{
public
interface
Listener
{
void
onPositionFramesMismatch
(
long
audioTimestampPositionFrames
long
audioTimestampSystemTimeUs
long
systemTimeUs
long
playbackPositionUs
)
;
void
onSystemTimeUsMismatch
(
long
audioTimestampPositionFrames
long
audioTimestampSystemTimeUs
long
systemTimeUs
long
playbackPositionUs
)
;
void
onInvalidLatency
(
long
latencyUs
)
;
void
onUnderrun
(
int
bufferSize
long
bufferSizeMs
)
;
}
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
PLAYSTATE_STOPPED
PLAYSTATE_PAUSED
PLAYSTATE_PLAYING
}
)
private
interface
PlayState
{
}
private
static
final
int
PLAYSTATE_STOPPED
=
AudioTrack
.
PLAYSTATE_STOPPED
;
private
static
final
int
PLAYSTATE_PAUSED
=
AudioTrack
.
PLAYSTATE_PAUSED
;
private
static
final
int
PLAYSTATE_PLAYING
=
AudioTrack
.
PLAYSTATE_PLAYING
;
private
static
final
long
MAX_AUDIO_TIMESTAMP_OFFSET_US
=
5
*
C
.
MICROS_PER_SECOND
;
private
static
final
long
MAX_LATENCY_US
=
5
*
C
.
MICROS_PER_SECOND
;
private
static
final
long
FORCE_RESET_WORKAROUND_TIMEOUT_MS
=
200
;
private
static
final
int
MAX_PLAYHEAD_OFFSET_COUNT
=
10
;
private
static
final
int
MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US
=
30000
;
private
static
final
int
MIN_LATENCY_SAMPLE_INTERVAL_US
=
500000
;
private
final
Listener
listener
;
private
final
long
[
]
playheadOffsets
;
Nullable
private
AudioTrack
audioTrack
;
private
int
outputPcmFrameSize
;
private
int
bufferSize
;
Nullable
private
AudioTimestampPoller
audioTimestampPoller
;
private
int
outputSampleRate
;
private
boolean
needsPassthroughWorkarounds
;
private
long
bufferSizeUs
;
private
long
smoothedPlayheadOffsetUs
;
private
long
lastPlayheadSampleTimeUs
;
Nullable
private
Method
getLatencyMethod
;
private
long
latencyUs
;
private
boolean
hasData
;
private
boolean
isOutputPcm
;
private
long
lastLatencySampleTimeUs
;
private
long
lastRawPlaybackHeadPosition
;
private
long
rawPlaybackHeadWrapCount
;
private
long
passthroughWorkaroundPauseOffset
;
private
int
nextPlayheadOffsetIndex
;
private
int
playheadOffsetCount
;
private
long
stopTimestampUs
;
private
long
forceResetWorkaroundTimeMs
;
private
long
stopPlaybackHeadPosition
;
private
long
endPlaybackHeadPosition
;
public
AudioTrackPositionTracker
(
Listener
listener
)
{
this
.
listener
=
Assertions
.
checkNotNull
(
listener
)
;
if
(
Util
.
SDK_INT
>
=
18
)
{
try
{
getLatencyMethod
=
AudioTrack
.
class
.
getMethod
(
"
getLatency
"
(
Class
<
?
>
[
]
)
null
)
;
}
catch
(
NoSuchMethodException
e
)
{
}
}
playheadOffsets
=
new
long
[
MAX_PLAYHEAD_OFFSET_COUNT
]
;
}
public
void
setAudioTrack
(
AudioTrack
audioTrack
C
.
Encoding
int
outputEncoding
int
outputPcmFrameSize
int
bufferSize
)
{
this
.
audioTrack
=
audioTrack
;
this
.
outputPcmFrameSize
=
outputPcmFrameSize
;
this
.
bufferSize
=
bufferSize
;
audioTimestampPoller
=
new
AudioTimestampPoller
(
audioTrack
)
;
outputSampleRate
=
audioTrack
.
getSampleRate
(
)
;
needsPassthroughWorkarounds
=
needsPassthroughWorkarounds
(
outputEncoding
)
;
isOutputPcm
=
Util
.
isEncodingLinearPcm
(
outputEncoding
)
;
bufferSizeUs
=
isOutputPcm
?
framesToDurationUs
(
bufferSize
/
outputPcmFrameSize
)
:
C
.
TIME_UNSET
;
lastRawPlaybackHeadPosition
=
0
;
rawPlaybackHeadWrapCount
=
0
;
passthroughWorkaroundPauseOffset
=
0
;
hasData
=
false
;
stopTimestampUs
=
C
.
TIME_UNSET
;
forceResetWorkaroundTimeMs
=
C
.
TIME_UNSET
;
latencyUs
=
0
;
}
public
long
getCurrentPositionUs
(
boolean
sourceEnded
)
{
if
(
Assertions
.
checkNotNull
(
this
.
audioTrack
)
.
getPlayState
(
)
=
=
PLAYSTATE_PLAYING
)
{
maybeSampleSyncParams
(
)
;
}
long
systemTimeUs
=
System
.
nanoTime
(
)
/
1000
;
AudioTimestampPoller
audioTimestampPoller
=
Assertions
.
checkNotNull
(
this
.
audioTimestampPoller
)
;
if
(
audioTimestampPoller
.
hasTimestamp
(
)
)
{
long
timestampPositionFrames
=
audioTimestampPoller
.
getTimestampPositionFrames
(
)
;
long
timestampPositionUs
=
framesToDurationUs
(
timestampPositionFrames
)
;
if
(
!
audioTimestampPoller
.
isTimestampAdvancing
(
)
)
{
return
timestampPositionUs
;
}
long
elapsedSinceTimestampUs
=
systemTimeUs
-
audioTimestampPoller
.
getTimestampSystemTimeUs
(
)
;
return
timestampPositionUs
+
elapsedSinceTimestampUs
;
}
else
{
long
positionUs
;
if
(
playheadOffsetCount
=
=
0
)
{
positionUs
=
getPlaybackHeadPositionUs
(
)
;
}
else
{
positionUs
=
systemTimeUs
+
smoothedPlayheadOffsetUs
;
}
if
(
!
sourceEnded
)
{
positionUs
-
=
latencyUs
;
}
return
positionUs
;
}
}
public
void
start
(
)
{
Assertions
.
checkNotNull
(
audioTimestampPoller
)
.
reset
(
)
;
}
public
boolean
isPlaying
(
)
{
return
Assertions
.
checkNotNull
(
audioTrack
)
.
getPlayState
(
)
=
=
PLAYSTATE_PLAYING
;
}
public
boolean
mayHandleBuffer
(
long
writtenFrames
)
{
PlayState
int
playState
=
Assertions
.
checkNotNull
(
audioTrack
)
.
getPlayState
(
)
;
if
(
needsPassthroughWorkarounds
)
{
if
(
playState
=
=
PLAYSTATE_PAUSED
)
{
hasData
=
false
;
return
false
;
}
if
(
playState
=
=
PLAYSTATE_STOPPED
&
&
getPlaybackHeadPosition
(
)
=
=
0
)
{
return
false
;
}
}
boolean
hadData
=
hasData
;
hasData
=
hasPendingData
(
writtenFrames
)
;
if
(
hadData
&
&
!
hasData
&
&
playState
!
=
PLAYSTATE_STOPPED
&
&
listener
!
=
null
)
{
listener
.
onUnderrun
(
bufferSize
C
.
usToMs
(
bufferSizeUs
)
)
;
}
return
true
;
}
public
int
getAvailableBufferSize
(
long
writtenBytes
)
{
int
bytesPending
=
(
int
)
(
writtenBytes
-
(
getPlaybackHeadPosition
(
)
*
outputPcmFrameSize
)
)
;
return
bufferSize
-
bytesPending
;
}
public
boolean
isStalled
(
long
writtenFrames
)
{
return
forceResetWorkaroundTimeMs
!
=
C
.
TIME_UNSET
&
&
writtenFrames
>
0
&
&
SystemClock
.
elapsedRealtime
(
)
-
forceResetWorkaroundTimeMs
>
=
FORCE_RESET_WORKAROUND_TIMEOUT_MS
;
}
public
void
handleEndOfStream
(
long
writtenFrames
)
{
stopPlaybackHeadPosition
=
getPlaybackHeadPosition
(
)
;
stopTimestampUs
=
SystemClock
.
elapsedRealtime
(
)
*
1000
;
endPlaybackHeadPosition
=
writtenFrames
;
}
public
boolean
hasPendingData
(
long
writtenFrames
)
{
return
writtenFrames
>
getPlaybackHeadPosition
(
)
|
|
forceHasPendingData
(
)
;
}
public
boolean
pause
(
)
{
resetSyncParams
(
)
;
if
(
stopTimestampUs
=
=
C
.
TIME_UNSET
)
{
Assertions
.
checkNotNull
(
audioTimestampPoller
)
.
reset
(
)
;
return
true
;
}
return
false
;
}
public
void
reset
(
)
{
resetSyncParams
(
)
;
audioTrack
=
null
;
audioTimestampPoller
=
null
;
}
private
void
maybeSampleSyncParams
(
)
{
long
playbackPositionUs
=
getPlaybackHeadPositionUs
(
)
;
if
(
playbackPositionUs
=
=
0
)
{
return
;
}
long
systemTimeUs
=
System
.
nanoTime
(
)
/
1000
;
if
(
systemTimeUs
-
lastPlayheadSampleTimeUs
>
=
MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US
)
{
playheadOffsets
[
nextPlayheadOffsetIndex
]
=
playbackPositionUs
-
systemTimeUs
;
nextPlayheadOffsetIndex
=
(
nextPlayheadOffsetIndex
+
1
)
%
MAX_PLAYHEAD_OFFSET_COUNT
;
if
(
playheadOffsetCount
<
MAX_PLAYHEAD_OFFSET_COUNT
)
{
playheadOffsetCount
+
+
;
}
lastPlayheadSampleTimeUs
=
systemTimeUs
;
smoothedPlayheadOffsetUs
=
0
;
for
(
int
i
=
0
;
i
<
playheadOffsetCount
;
i
+
+
)
{
smoothedPlayheadOffsetUs
+
=
playheadOffsets
[
i
]
/
playheadOffsetCount
;
}
}
if
(
needsPassthroughWorkarounds
)
{
return
;
}
maybePollAndCheckTimestamp
(
systemTimeUs
playbackPositionUs
)
;
maybeUpdateLatency
(
systemTimeUs
)
;
}
private
void
maybePollAndCheckTimestamp
(
long
systemTimeUs
long
playbackPositionUs
)
{
AudioTimestampPoller
audioTimestampPoller
=
Assertions
.
checkNotNull
(
this
.
audioTimestampPoller
)
;
if
(
!
audioTimestampPoller
.
maybePollTimestamp
(
systemTimeUs
)
)
{
return
;
}
long
audioTimestampSystemTimeUs
=
audioTimestampPoller
.
getTimestampSystemTimeUs
(
)
;
long
audioTimestampPositionFrames
=
audioTimestampPoller
.
getTimestampPositionFrames
(
)
;
if
(
Math
.
abs
(
audioTimestampSystemTimeUs
-
systemTimeUs
)
>
MAX_AUDIO_TIMESTAMP_OFFSET_US
)
{
listener
.
onSystemTimeUsMismatch
(
audioTimestampPositionFrames
audioTimestampSystemTimeUs
systemTimeUs
playbackPositionUs
)
;
audioTimestampPoller
.
rejectTimestamp
(
)
;
}
else
if
(
Math
.
abs
(
framesToDurationUs
(
audioTimestampPositionFrames
)
-
playbackPositionUs
)
>
MAX_AUDIO_TIMESTAMP_OFFSET_US
)
{
listener
.
onPositionFramesMismatch
(
audioTimestampPositionFrames
audioTimestampSystemTimeUs
systemTimeUs
playbackPositionUs
)
;
audioTimestampPoller
.
rejectTimestamp
(
)
;
}
else
{
audioTimestampPoller
.
acceptTimestamp
(
)
;
}
}
private
void
maybeUpdateLatency
(
long
systemTimeUs
)
{
if
(
isOutputPcm
&
&
getLatencyMethod
!
=
null
&
&
systemTimeUs
-
lastLatencySampleTimeUs
>
=
MIN_LATENCY_SAMPLE_INTERVAL_US
)
{
try
{
latencyUs
=
castNonNull
(
(
Integer
)
getLatencyMethod
.
invoke
(
Assertions
.
checkNotNull
(
audioTrack
)
)
)
*
1000L
-
bufferSizeUs
;
latencyUs
=
Math
.
max
(
latencyUs
0
)
;
if
(
latencyUs
>
MAX_LATENCY_US
)
{
listener
.
onInvalidLatency
(
latencyUs
)
;
latencyUs
=
0
;
}
}
catch
(
Exception
e
)
{
getLatencyMethod
=
null
;
}
lastLatencySampleTimeUs
=
systemTimeUs
;
}
}
private
long
framesToDurationUs
(
long
frameCount
)
{
return
(
frameCount
*
C
.
MICROS_PER_SECOND
)
/
outputSampleRate
;
}
private
void
resetSyncParams
(
)
{
smoothedPlayheadOffsetUs
=
0
;
playheadOffsetCount
=
0
;
nextPlayheadOffsetIndex
=
0
;
lastPlayheadSampleTimeUs
=
0
;
}
private
boolean
forceHasPendingData
(
)
{
return
needsPassthroughWorkarounds
&
&
Assertions
.
checkNotNull
(
audioTrack
)
.
getPlayState
(
)
=
=
AudioTrack
.
PLAYSTATE_PAUSED
&
&
getPlaybackHeadPosition
(
)
=
=
0
;
}
private
static
boolean
needsPassthroughWorkarounds
(
C
.
Encoding
int
outputEncoding
)
{
return
Util
.
SDK_INT
<
23
&
&
(
outputEncoding
=
=
C
.
ENCODING_AC3
|
|
outputEncoding
=
=
C
.
ENCODING_E_AC3
)
;
}
private
long
getPlaybackHeadPositionUs
(
)
{
return
framesToDurationUs
(
getPlaybackHeadPosition
(
)
)
;
}
private
long
getPlaybackHeadPosition
(
)
{
AudioTrack
audioTrack
=
Assertions
.
checkNotNull
(
this
.
audioTrack
)
;
if
(
stopTimestampUs
!
=
C
.
TIME_UNSET
)
{
long
elapsedTimeSinceStopUs
=
(
SystemClock
.
elapsedRealtime
(
)
*
1000
)
-
stopTimestampUs
;
long
framesSinceStop
=
(
elapsedTimeSinceStopUs
*
outputSampleRate
)
/
C
.
MICROS_PER_SECOND
;
return
Math
.
min
(
endPlaybackHeadPosition
stopPlaybackHeadPosition
+
framesSinceStop
)
;
}
int
state
=
audioTrack
.
getPlayState
(
)
;
if
(
state
=
=
PLAYSTATE_STOPPED
)
{
return
0
;
}
long
rawPlaybackHeadPosition
=
0xFFFFFFFFL
&
audioTrack
.
getPlaybackHeadPosition
(
)
;
if
(
needsPassthroughWorkarounds
)
{
if
(
state
=
=
PLAYSTATE_PAUSED
&
&
rawPlaybackHeadPosition
=
=
0
)
{
passthroughWorkaroundPauseOffset
=
lastRawPlaybackHeadPosition
;
}
rawPlaybackHeadPosition
+
=
passthroughWorkaroundPauseOffset
;
}
if
(
Util
.
SDK_INT
<
=
29
)
{
if
(
rawPlaybackHeadPosition
=
=
0
&
&
lastRawPlaybackHeadPosition
>
0
&
&
state
=
=
PLAYSTATE_PLAYING
)
{
if
(
forceResetWorkaroundTimeMs
=
=
C
.
TIME_UNSET
)
{
forceResetWorkaroundTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
}
return
lastRawPlaybackHeadPosition
;
}
else
{
forceResetWorkaroundTimeMs
=
C
.
TIME_UNSET
;
}
}
if
(
lastRawPlaybackHeadPosition
>
rawPlaybackHeadPosition
)
{
rawPlaybackHeadWrapCount
+
+
;
}
lastRawPlaybackHeadPosition
=
rawPlaybackHeadPosition
;
return
rawPlaybackHeadPosition
+
(
rawPlaybackHeadWrapCount
<
<
32
)
;
}
}
