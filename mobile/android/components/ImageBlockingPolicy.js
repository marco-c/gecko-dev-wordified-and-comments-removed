const
{
classes
:
Cc
interfaces
:
Ci
manager
:
Cm
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
PLACEHOLDER_IMG
=
"
chrome
:
/
/
browser
/
skin
/
images
/
placeholder_image
.
svg
"
;
const
TELEMETRY_TAP_TO_LOAD_ENABLED
=
"
TAP_TO_LOAD_ENABLED
"
;
const
TELEMETRY_SHOW_IMAGE_SIZE
=
"
TAP_TO_LOAD_IMAGE_SIZE
"
;
const
TOPIC_GATHER_TELEMETRY
=
"
gather
-
telemetry
"
;
const
PREF_IMAGEBLOCKING
=
"
browser
.
image_blocking
"
;
const
OPTION_NEVER
=
0
;
const
OPTION_ALWAYS
=
1
;
const
OPTION_WIFI_ONLY
=
2
;
function
ImageBlockingPolicy
(
)
{
Services
.
obs
.
addObserver
(
this
TOPIC_GATHER_TELEMETRY
false
)
;
}
ImageBlockingPolicy
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIContentPolicy
Ci
.
nsIObserver
]
)
classDescription
:
"
Click
-
To
-
Play
Image
"
classID
:
Components
.
ID
(
"
{
f55f77f9
-
d33d
-
4759
-
82fc
-
60db3ee0bb91
}
"
)
contractID
:
"
mozilla
.
org
/
browser
/
blockimages
-
policy
;
1
"
xpcom_categories
:
[
{
category
:
"
content
-
policy
"
service
:
true
}
]
shouldLoad
:
function
(
contentType
contentLocation
requestOrigin
node
mimeTypeGuess
extra
)
{
if
(
this
.
_enabled
(
)
=
=
OPTION_NEVER
|
|
(
this
.
_enabled
(
)
=
=
OPTION_WIFI_ONLY
&
&
this
.
_usingCellular
(
)
)
)
{
if
(
contentType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_IMAGE
|
|
contentType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_IMAGESET
)
{
if
(
!
contentLocation
.
schemeIs
(
"
http
"
)
&
&
!
contentLocation
.
schemeIs
(
"
https
"
)
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
if
(
node
instanceof
Ci
.
nsIDOMHTMLImageElement
)
{
if
(
node
.
getAttribute
(
"
data
-
ctv
-
show
"
)
=
=
"
true
"
)
{
sendImageSizeTelemetry
(
node
.
getAttribute
(
"
data
-
ctv
-
src
"
)
)
;
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
setTimeout
(
(
)
=
>
{
node
.
setAttribute
(
"
data
-
ctv
-
src
"
contentLocation
.
spec
)
;
node
.
setAttribute
(
"
src
"
PLACEHOLDER_IMG
)
;
node
.
removeAttribute
(
"
srcset
"
)
;
}
0
)
;
}
return
Ci
.
nsIContentPolicy
.
REJECT
;
}
}
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
shouldProcess
:
function
(
contentType
contentLocation
requestOrigin
node
mimeTypeGuess
extra
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
_usingCellular
:
function
(
)
{
let
network
=
Cc
[
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
]
.
getService
(
Ci
.
nsINetworkLinkService
)
;
return
!
(
network
.
linkType
=
=
Ci
.
nsINetworkLinkService
.
LINK_TYPE_UNKNOWN
|
|
network
.
linkType
=
=
Ci
.
nsINetworkLinkService
.
LINK_TYPE_ETHERNET
|
|
network
.
linkType
=
=
Ci
.
nsINetworkLinkService
.
LINK_TYPE_USB
|
|
network
.
linkType
=
=
Ci
.
nsINetworkLinkService
.
LINK_TYPE_WIFI
)
;
}
_enabled
:
function
(
)
{
return
Services
.
prefs
.
getIntPref
(
PREF_IMAGEBLOCKING
)
;
}
observe
:
function
(
subject
topic
data
)
{
if
(
topic
=
=
TOPIC_GATHER_TELEMETRY
)
{
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_TAP_TO_LOAD_ENABLED
)
.
add
(
this
.
_enabled
(
)
)
;
}
}
}
;
function
sendImageSizeTelemetry
(
imageURL
)
{
let
xhr
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
xhr
.
open
(
"
HEAD
"
imageURL
true
)
;
xhr
.
onreadystatechange
=
function
(
e
)
{
if
(
xhr
.
readyState
!
=
4
)
{
return
;
}
if
(
xhr
.
status
!
=
200
)
{
return
;
}
let
contentLength
=
xhr
.
getResponseHeader
(
"
Content
-
Length
"
)
;
if
(
!
contentLength
)
{
return
;
}
let
imageSize
=
contentLength
/
1024
;
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_SHOW_IMAGE_SIZE
)
.
add
(
imageSize
)
;
}
;
xhr
.
send
(
null
)
;
}
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
ImageBlockingPolicy
]
)
;
