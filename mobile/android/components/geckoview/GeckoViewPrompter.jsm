"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewPrompter
"
]
;
const
{
GeckoViewUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
debug
warn
}
=
GeckoViewUtils
.
initLogging
(
"
GeckoViewPrompter
"
)
;
class
GeckoViewPrompter
{
constructor
(
aParent
)
{
this
.
id
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
if
(
aParent
)
{
if
(
Window
.
isInstance
(
aParent
)
)
{
this
.
_domWin
=
aParent
;
}
else
if
(
aParent
.
window
)
{
this
.
_domWin
=
aParent
.
window
;
}
else
{
this
.
_domWin
=
aParent
.
embedderElement
&
&
aParent
.
embedderElement
.
ownerGlobal
;
}
}
if
(
!
this
.
_domWin
)
{
this
.
_domWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
geckoview
"
)
;
}
this
.
_innerWindowId
=
this
.
_domWin
?
.
browsingContext
.
currentWindowContext
.
innerWindowId
;
}
get
domWin
(
)
{
return
this
.
_domWin
;
}
get
prompterActor
(
)
{
const
actor
=
this
.
domWin
?
.
windowGlobalChild
.
getActor
(
"
GeckoViewPrompter
"
)
;
return
actor
;
}
_changeModalState
(
aEntering
)
{
if
(
!
this
.
_domWin
)
{
return
true
;
}
try
{
const
winUtils
=
this
.
_domWin
.
windowUtils
;
if
(
!
aEntering
)
{
winUtils
.
leaveModalState
(
)
;
}
const
event
=
this
.
_domWin
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
aEntering
?
"
DOMWillOpenModalDialog
"
:
"
DOMModalDialogClosed
"
true
true
)
;
winUtils
.
dispatchEventToChromeOnly
(
this
.
_domWin
event
)
;
if
(
aEntering
)
{
winUtils
.
enterModalState
(
)
;
}
return
true
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
change
modal
state
:
"
+
ex
)
;
}
return
false
;
}
_dismissUi
(
)
{
this
.
prompterActor
?
.
dismissPrompt
(
this
)
;
}
accept
(
aInputText
=
this
.
inputText
)
{
if
(
this
.
callback
)
{
let
acceptMsg
=
{
}
;
switch
(
this
.
message
.
type
)
{
case
"
alert
"
:
acceptMsg
=
null
;
break
;
case
"
button
"
:
acceptMsg
.
button
=
0
;
break
;
case
"
text
"
:
acceptMsg
.
text
=
aInputText
;
break
;
default
:
acceptMsg
=
null
;
break
;
}
this
.
callback
(
acceptMsg
)
;
this
.
_dismissUi
(
)
;
}
}
dismiss
(
)
{
this
.
callback
(
null
)
;
this
.
_dismissUi
(
)
;
}
getPromptType
(
)
{
switch
(
this
.
message
.
type
)
{
case
"
alert
"
:
return
this
.
message
.
checkValue
?
"
alertCheck
"
:
"
alert
"
;
case
"
button
"
:
return
this
.
message
.
checkValue
?
"
confirmCheck
"
:
"
confirm
"
;
case
"
text
"
:
return
this
.
message
.
checkValue
?
"
promptCheck
"
:
"
prompt
"
;
default
:
return
this
.
message
.
type
;
}
}
getPromptText
(
)
{
return
this
.
message
.
msg
;
}
getInputText
(
)
{
return
this
.
inputText
;
}
setInputText
(
aInput
)
{
this
.
inputText
=
aInput
;
}
showPrompt
(
aMsg
)
{
let
result
=
undefined
;
if
(
!
this
.
_domWin
|
|
!
this
.
_changeModalState
(
true
)
)
{
return
result
;
}
try
{
this
.
asyncShowPrompt
(
aMsg
res
=
>
(
result
=
res
)
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
GeckoViewPrompter
.
jsm
:
showPrompt
"
(
)
=
>
this
.
_domWin
.
closed
|
|
result
!
=
=
undefined
)
;
}
finally
{
this
.
_changeModalState
(
false
)
;
}
return
result
;
}
checkInnerWindow
(
)
{
return
(
this
.
_innerWindowId
=
=
=
this
.
_domWin
.
browsingContext
.
currentWindowContext
.
innerWindowId
)
;
}
asyncShowPromptPromise
(
aMsg
)
{
return
new
Promise
(
resolve
=
>
{
this
.
asyncShowPrompt
(
aMsg
resolve
)
;
}
)
;
}
async
asyncShowPrompt
(
aMsg
aCallback
)
{
this
.
message
=
aMsg
;
this
.
inputText
=
aMsg
.
value
;
this
.
callback
=
aCallback
;
aMsg
.
id
=
this
.
id
;
let
response
=
null
;
try
{
if
(
this
.
checkInnerWindow
(
)
)
{
response
=
await
this
.
prompterActor
.
prompt
(
this
aMsg
)
;
}
}
catch
(
error
)
{
warn
Error
while
prompting
:
{
error
}
;
}
if
(
!
this
.
checkInnerWindow
(
)
)
{
aCallback
(
null
)
;
}
else
{
aCallback
(
response
)
;
}
aMsg
=
undefined
;
aCallback
=
undefined
;
}
update
(
aMsg
)
{
this
.
message
=
aMsg
;
aMsg
.
id
=
this
.
id
;
this
.
prompterActor
?
.
updatePrompt
(
aMsg
)
;
}
}
