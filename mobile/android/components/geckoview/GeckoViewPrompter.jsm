"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewPrompter
"
]
;
const
{
GeckoViewUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
debug
warn
}
=
GeckoViewUtils
.
initLogging
(
"
GeckoViewPrompter
"
)
;
class
GeckoViewPrompter
{
constructor
(
aParent
)
{
this
.
id
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
if
(
aParent
)
{
if
(
aParent
instanceof
Window
)
{
this
.
_domWin
=
aParent
;
}
else
if
(
aParent
.
window
)
{
this
.
_domWin
=
aParent
.
window
;
}
else
{
this
.
_domWin
=
aParent
.
embedderElement
&
&
aParent
.
embedderElement
.
ownerGlobal
;
}
}
if
(
this
.
_domWin
)
{
this
.
_dispatcher
=
GeckoViewUtils
.
getDispatcherForWindow
(
this
.
_domWin
)
;
}
if
(
!
this
.
_dispatcher
)
{
[
this
.
_dispatcher
this
.
_domWin
]
=
GeckoViewUtils
.
getActiveDispatcherAndWindow
(
)
;
}
this
.
_innerWindowId
=
this
.
_domWin
?
.
browsingContext
.
currentWindowContext
.
innerWindowId
;
}
get
domWin
(
)
{
return
this
.
_domWin
;
}
_changeModalState
(
aEntering
)
{
if
(
!
this
.
_domWin
)
{
return
true
;
}
try
{
const
winUtils
=
this
.
_domWin
.
windowUtils
;
if
(
!
aEntering
)
{
winUtils
.
leaveModalState
(
)
;
}
const
event
=
this
.
_domWin
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
aEntering
?
"
DOMWillOpenModalDialog
"
:
"
DOMModalDialogClosed
"
true
true
)
;
winUtils
.
dispatchEventToChromeOnly
(
this
.
_domWin
event
)
;
if
(
aEntering
)
{
winUtils
.
enterModalState
(
)
;
}
return
true
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
change
modal
state
:
"
+
ex
)
;
}
return
false
;
}
accept
(
aInputText
=
this
.
inputText
)
{
if
(
this
.
callback
)
{
let
acceptMsg
=
{
}
;
switch
(
this
.
message
.
type
)
{
case
"
alert
"
:
acceptMsg
=
null
;
break
;
case
"
button
"
:
acceptMsg
.
button
=
0
;
break
;
case
"
text
"
:
acceptMsg
.
text
=
aInputText
;
break
;
default
:
acceptMsg
=
null
;
break
;
}
this
.
callback
(
acceptMsg
)
;
this
.
dismiss
(
)
;
}
}
getPromptType
(
)
{
switch
(
this
.
message
.
type
)
{
case
"
alert
"
:
return
this
.
message
.
checkValue
?
"
alertCheck
"
:
"
alert
"
;
case
"
button
"
:
return
this
.
message
.
checkValue
?
"
confirmCheck
"
:
"
confirm
"
;
case
"
text
"
:
return
this
.
message
.
checkValue
?
"
promptCheck
"
:
"
prompt
"
;
default
:
return
this
.
message
.
type
;
}
}
getPromptText
(
)
{
return
this
.
message
.
msg
;
}
getInputText
(
)
{
return
this
.
inputText
;
}
setInputText
(
aInput
)
{
this
.
inputText
=
aInput
;
}
showPrompt
(
aMsg
)
{
let
result
=
undefined
;
if
(
!
this
.
_domWin
|
|
!
this
.
_changeModalState
(
true
)
)
{
return
result
;
}
try
{
this
.
asyncShowPrompt
(
aMsg
res
=
>
(
result
=
res
)
)
;
Services
.
tm
.
spinEventLoopUntil
(
"
GeckoViewPrompter
.
jsm
:
showPrompt
"
(
)
=
>
this
.
_domWin
.
closed
|
|
result
!
=
=
undefined
)
;
}
finally
{
this
.
_changeModalState
(
false
)
;
}
return
result
;
}
checkInnerWindow
(
)
{
return
(
this
.
_innerWindowId
=
=
=
this
.
_domWin
.
browsingContext
.
currentWindowContext
.
innerWindowId
)
;
}
asyncShowPromptPromise
(
aMsg
)
{
return
new
Promise
(
resolve
=
>
{
this
.
asyncShowPrompt
(
aMsg
resolve
)
;
}
)
;
}
dismiss
(
)
{
this
.
_dispatcher
.
dispatch
(
"
GeckoView
:
Prompt
:
Dismiss
"
{
id
:
this
.
id
}
)
;
const
actor
=
this
.
domWin
.
windowGlobalChild
.
getActor
(
"
GeckoViewPrompter
"
)
;
actor
?
.
unregisterPrompt
(
this
)
;
}
asyncShowPrompt
(
aMsg
aCallback
)
{
let
handled
=
false
;
this
.
message
=
aMsg
;
this
.
inputText
=
aMsg
.
value
;
this
.
callback
=
aCallback
;
const
actor
=
this
.
domWin
?
.
windowGlobalChild
.
getActor
(
"
GeckoViewPrompter
"
)
;
actor
?
.
registerPrompt
(
this
)
;
const
onResponse
=
response
=
>
{
if
(
handled
)
{
return
;
}
if
(
!
this
.
checkInnerWindow
(
)
)
{
aCallback
(
null
)
;
}
else
{
aCallback
(
response
)
;
}
aMsg
=
undefined
;
aCallback
=
undefined
;
handled
=
true
;
}
;
if
(
!
this
.
_dispatcher
|
|
!
this
.
checkInnerWindow
(
)
)
{
onResponse
(
null
)
;
return
;
}
aMsg
.
id
=
this
.
id
;
this
.
_dispatcher
.
dispatch
(
"
GeckoView
:
Prompt
"
aMsg
{
onSuccess
:
onResponse
onError
:
error
=
>
{
Cu
.
reportError
(
"
Prompt
error
:
"
+
error
)
;
onResponse
(
null
)
;
}
}
)
;
actor
?
.
notifyPromptShow
(
this
)
;
}
}
