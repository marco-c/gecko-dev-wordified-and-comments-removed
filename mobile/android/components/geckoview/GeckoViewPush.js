"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
GeckoViewUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
const
{
debug
warn
}
=
GeckoViewUtils
.
initLogging
(
"
GeckoViewPush
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
EventDispatcher
"
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
const
OBSERVER_TOPIC_PUSH
=
"
push
-
message
"
;
const
OBSERVER_TOPIC_SUBSCRIPTION_CHANGE
=
"
push
-
subscription
-
change
"
;
const
OBSERVER_TOPIC_SUBSCRIPTION_MODIFIED
=
"
push
-
subscription
-
modified
"
;
function
createSubscription
(
{
scope
principal
browserPublicKey
authSecret
endpoint
appServerKey
}
)
{
const
decodedBrowserKey
=
ChromeUtils
.
base64URLDecode
(
browserPublicKey
{
padding
:
"
ignore
"
}
)
;
const
decodedAuthSecret
=
ChromeUtils
.
base64URLDecode
(
authSecret
{
padding
:
"
ignore
"
}
)
;
return
new
PushSubscription
(
{
endpoint
:
endpoint
scope
p256dhKey
:
decodedBrowserKey
authenticationSecret
:
decodedAuthSecret
appServerKey
}
)
;
}
function
scopeWithAttrs
(
scope
attrs
)
{
return
scope
+
ChromeUtils
.
originAttributesToSuffix
(
attrs
)
;
}
function
PushService
(
)
{
this
.
wrappedJSObject
=
this
;
}
PushService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
a54d84d7
-
98a4
-
4fec
-
b664
-
e42e512ae9cc
}
"
)
contractID
:
"
mozilla
.
org
/
push
/
Service
;
1
"
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
Ci
.
nsIPushService
Ci
.
nsIPushQuotaManager
Ci
.
nsIPushErrorReporter
]
)
pushTopic
:
OBSERVER_TOPIC_PUSH
subscriptionChangeTopic
:
OBSERVER_TOPIC_SUBSCRIPTION_CHANGE
subscriptionModifiedTopic
:
OBSERVER_TOPIC_SUBSCRIPTION_MODIFIED
subscribe
(
scope
principal
callback
)
{
this
.
subscribeWithKey
(
scope
principal
null
callback
)
;
}
async
subscribeWithKey
(
scope
principal
appServerKey
callback
)
{
try
{
const
response
=
await
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
GeckoView
:
PushSubscribe
"
scope
:
scopeWithAttrs
(
scope
principal
.
originAttributes
)
appServerKey
:
appServerKey
?
ChromeUtils
.
base64URLEncode
(
new
Uint8Array
(
appServerKey
)
{
pad
:
true
}
)
:
null
}
)
;
let
subscription
=
null
;
if
(
response
)
{
subscription
=
createSubscription
(
{
.
.
.
response
scope
principal
appServerKey
}
)
;
}
callback
.
onPushSubscription
(
Cr
.
NS_OK
subscription
)
;
}
catch
(
e
)
{
callback
.
onPushSubscription
(
Cr
.
NS_ERROR_FAILURE
null
)
;
}
}
async
unsubscribe
(
scope
principal
callback
)
{
try
{
await
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
GeckoView
:
PushUnsubscribe
"
scope
:
scopeWithAttrs
(
scope
principal
.
originAttributes
)
}
)
;
callback
.
onUnsubscribe
(
Cr
.
NS_OK
true
)
;
}
catch
(
e
)
{
callback
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
}
}
async
getSubscription
(
scope
principal
callback
)
{
try
{
const
response
=
await
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
GeckoView
:
PushGetSubscription
"
scope
:
scopeWithAttrs
(
scope
principal
.
originAttributes
)
}
)
;
let
subscription
=
null
;
if
(
response
)
{
subscription
=
createSubscription
(
{
.
.
.
response
scope
principal
}
)
;
}
callback
.
onPushSubscription
(
Cr
.
NS_OK
subscription
)
;
}
catch
(
e
)
{
callback
.
onPushSubscription
(
Cr
.
NS_ERROR_FAILURE
null
)
;
}
}
clearForDomain
(
domain
callback
)
{
callback
.
onClear
(
Cr
.
NS_OK
)
;
}
notificationForOriginShown
(
origin
)
{
}
notificationForOriginClosed
(
origin
)
{
}
reportDeliveryError
(
messageId
reason
)
{
}
}
;
function
PushSubscription
(
props
)
{
this
.
_props
=
props
;
}
PushSubscription
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPushSubscription
]
)
get
endpoint
(
)
{
return
this
.
_props
.
endpoint
;
}
get
lastPush
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
get
pushCount
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
get
quota
(
)
{
return
-
1
;
}
get
isSystemSubscription
(
)
{
return
false
;
}
get
p256dhPrivateKey
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
quotaApplies
(
)
{
return
false
;
}
isExpired
(
)
{
return
false
;
}
getKey
(
name
)
{
switch
(
name
)
{
case
"
p256dh
"
:
return
this
.
_getRawKey
(
this
.
_props
.
p256dhKey
)
;
case
"
auth
"
:
return
this
.
_getRawKey
(
this
.
_props
.
authenticationSecret
)
;
case
"
appServer
"
:
return
this
.
_getRawKey
(
this
.
_props
.
appServerKey
)
;
}
return
[
]
;
}
_getRawKey
(
key
)
{
if
(
!
key
)
{
return
[
]
;
}
return
new
Uint8Array
(
key
)
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
PushService
]
)
;
