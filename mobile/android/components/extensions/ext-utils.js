"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
var
{
EventDispatcher
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
var
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
var
{
ExtensionUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
DefaultWeakMap
ExtensionError
}
=
ExtensionUtils
;
var
{
defineLazyGetter
}
=
ExtensionCommon
;
global
.
GlobalEventDispatcher
=
EventDispatcher
.
instance
;
const
BrowserStatusFilter
=
Components
.
Constructor
(
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
"
nsIWebProgress
"
"
addProgressListener
"
)
;
let
tabTracker
;
let
windowTracker
;
class
BrowserProgressListener
{
constructor
(
browser
listener
flags
)
{
this
.
listener
=
listener
;
this
.
browser
=
browser
;
this
.
filter
=
new
BrowserStatusFilter
(
this
flags
)
;
this
.
browser
.
addProgressListener
(
this
.
filter
flags
)
;
}
destroy
(
)
{
this
.
browser
.
removeProgressListener
(
this
.
filter
)
;
this
.
filter
.
removeProgressListener
(
this
)
;
}
delegate
(
method
.
.
.
args
)
{
if
(
this
.
listener
[
method
]
)
{
this
.
listener
[
method
]
(
this
.
browser
.
.
.
args
)
;
}
}
onLocationChange
(
webProgress
request
locationURI
flags
)
{
this
.
delegate
(
"
onLocationChange
"
webProgress
request
locationURI
flags
)
;
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
this
.
delegate
(
"
onStateChange
"
webProgress
request
stateFlags
status
)
;
}
}
class
ProgressListenerWrapper
{
constructor
(
window
listener
)
{
this
.
window
=
window
;
this
.
listener
=
listener
;
this
.
listeners
=
new
WeakMap
(
)
;
this
.
flags
=
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
;
for
(
let
nativeTab
of
this
.
window
.
BrowserApp
.
tabs
)
{
this
.
addBrowserProgressListener
(
nativeTab
.
browser
)
;
}
this
.
window
.
BrowserApp
.
deck
.
addEventListener
(
"
TabOpen
"
this
)
;
}
destroy
(
)
{
this
.
window
.
BrowserApp
.
deck
.
removeEventListener
(
"
TabOpen
"
this
)
;
for
(
let
nativeTab
of
this
.
window
.
BrowserApp
.
tabs
)
{
this
.
removeProgressListener
(
nativeTab
.
browser
)
;
}
}
addBrowserProgressListener
(
browser
)
{
this
.
removeProgressListener
(
browser
)
;
let
listener
=
new
BrowserProgressListener
(
browser
this
.
listener
this
.
flags
)
;
this
.
listeners
.
set
(
browser
listener
)
;
}
removeProgressListener
(
browser
)
{
let
listener
=
this
.
listeners
.
get
(
browser
)
;
if
(
listener
)
{
listener
.
destroy
(
)
;
this
.
listeners
.
delete
(
browser
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
TabOpen
"
)
{
this
.
addBrowserProgressListener
(
event
.
originalTarget
)
;
}
}
}
class
WindowTracker
extends
WindowTrackerBase
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
progressListeners
=
new
DefaultWeakMap
(
(
)
=
>
new
WeakMap
(
)
)
;
}
get
topWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
|
|
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
geckoview
"
)
;
}
addProgressListener
(
window
listener
)
{
let
listeners
=
this
.
progressListeners
.
get
(
window
)
;
if
(
!
listeners
.
has
(
listener
)
)
{
let
wrapper
=
new
ProgressListenerWrapper
(
window
listener
)
;
listeners
.
set
(
listener
wrapper
)
;
}
}
removeProgressListener
(
window
listener
)
{
let
listeners
=
this
.
progressListeners
.
get
(
window
)
;
let
wrapper
=
listeners
.
get
(
listener
)
;
if
(
wrapper
)
{
wrapper
.
destroy
(
)
;
listeners
.
delete
(
listener
)
;
}
}
}
global
.
makeGlobalEvent
=
function
makeGlobalEvent
(
context
name
event
listener
)
{
return
new
EventManager
(
{
context
name
register
:
fire
=
>
{
let
listener2
=
{
onEvent
(
event
data
callback
)
{
listener
(
fire
data
)
;
}
}
;
GlobalEventDispatcher
.
registerListener
(
listener2
[
event
]
)
;
return
(
)
=
>
{
GlobalEventDispatcher
.
unregisterListener
(
listener2
[
event
]
)
;
}
;
}
}
)
.
api
(
)
;
}
;
class
TabTracker
extends
TabTrackerBase
{
constructor
(
)
{
super
(
)
;
this
.
_extensionPopupTabWeak
=
null
;
this
.
_selectedTabId
=
null
;
}
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
windowTracker
.
addListener
(
"
TabClose
"
this
)
;
windowTracker
.
addListener
(
"
TabOpen
"
this
)
;
GlobalEventDispatcher
.
registerListener
(
this
[
"
Tab
:
Selected
"
]
)
;
}
get
extensionPopupTab
(
)
{
if
(
this
.
_extensionPopupTabWeak
)
{
const
tab
=
this
.
_extensionPopupTabWeak
.
get
(
)
;
if
(
tab
.
browser
)
{
return
tab
;
}
this
.
_extensionPopupTabWeak
=
null
;
}
return
undefined
;
}
openExtensionPopupTab
(
popup
)
{
let
win
=
windowTracker
.
topWindow
;
if
(
!
win
)
{
throw
new
ExtensionError
(
Unable
to
open
a
popup
without
an
active
window
)
;
}
if
(
this
.
extensionPopupTab
)
{
win
.
BrowserApp
.
closeTab
(
this
.
extensionPopupTab
)
;
}
this
.
init
(
)
;
let
{
browser
id
}
=
win
.
BrowserApp
.
selectedTab
;
let
isPrivate
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
;
this
.
_extensionPopupTabWeak
=
Cu
.
getWeakReference
(
win
.
BrowserApp
.
addTab
(
popup
{
selected
:
true
parentId
:
id
isPrivate
}
)
)
;
}
getId
(
nativeTab
)
{
return
nativeTab
.
id
;
}
getTab
(
id
default_
=
undefined
)
{
let
win
=
windowTracker
.
topWindow
;
if
(
win
)
{
let
nativeTab
=
win
.
BrowserApp
.
getTabForId
(
id
)
;
if
(
nativeTab
)
{
return
nativeTab
;
}
}
if
(
default_
!
=
=
undefined
)
{
return
default_
;
}
throw
new
ExtensionError
(
Invalid
tab
ID
:
{
id
}
)
;
}
handleEvent
(
event
)
{
const
{
BrowserApp
}
=
event
.
target
.
ownerGlobal
;
const
nativeTab
=
BrowserApp
.
getTabForBrowser
(
event
.
target
)
;
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
this
.
emitCreated
(
nativeTab
)
;
break
;
case
"
TabClose
"
:
this
.
emitRemoved
(
nativeTab
false
)
;
break
;
}
}
onEvent
(
event
data
)
{
const
{
BrowserApp
}
=
windowTracker
.
topWindow
;
switch
(
event
)
{
case
"
Tab
:
Selected
"
:
{
this
.
_selectedTabId
=
data
.
id
;
const
nativeTab
=
BrowserApp
.
getTabForId
(
data
.
id
)
;
const
popupTab
=
tabTracker
.
extensionPopupTab
;
if
(
popupTab
&
&
popupTab
!
=
=
nativeTab
)
{
BrowserApp
.
closeTab
(
popupTab
)
;
}
break
;
}
}
}
emitCreated
(
nativeTab
)
{
this
.
emit
(
"
tab
-
created
"
{
nativeTab
}
)
;
}
emitRemoved
(
nativeTab
isWindowClosing
)
{
let
windowId
=
windowTracker
.
getId
(
nativeTab
.
browser
.
ownerGlobal
)
;
let
tabId
=
this
.
getId
(
nativeTab
)
;
if
(
this
.
extensionPopupTab
&
&
this
.
extensionPopupTab
=
=
=
nativeTab
)
{
this
.
_extensionPopupTabWeak
=
null
;
if
(
this
.
_selectedTabId
!
=
=
tabId
)
{
return
;
}
const
{
BrowserApp
}
=
windowTracker
.
topWindow
;
const
popupParentTab
=
BrowserApp
.
getTabForId
(
nativeTab
.
parentId
)
;
if
(
popupParentTab
)
{
BrowserApp
.
selectTab
(
popupParentTab
)
;
}
}
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
emit
(
"
tab
-
removed
"
{
nativeTab
tabId
windowId
isWindowClosing
}
)
;
}
)
;
}
getBrowserData
(
browser
)
{
let
result
=
{
tabId
:
-
1
windowId
:
-
1
}
;
let
{
BrowserApp
}
=
browser
.
ownerGlobal
;
if
(
BrowserApp
)
{
result
.
windowId
=
windowTracker
.
getId
(
browser
.
ownerGlobal
)
;
let
nativeTab
=
BrowserApp
.
getTabForBrowser
(
browser
)
;
if
(
nativeTab
)
{
result
.
tabId
=
this
.
getId
(
nativeTab
)
;
}
}
return
result
;
}
get
activeTab
(
)
{
let
win
=
windowTracker
.
topWindow
;
if
(
win
&
&
win
.
BrowserApp
)
{
const
selectedTab
=
win
.
BrowserApp
.
selectedTab
;
if
(
selectedTab
=
=
=
this
.
extensionPopupTab
)
{
return
win
.
BrowserApp
.
getTabForId
(
selectedTab
.
parentId
)
;
}
return
selectedTab
;
}
return
null
;
}
}
windowTracker
=
new
WindowTracker
(
)
;
tabTracker
=
new
TabTracker
(
)
;
Object
.
assign
(
global
{
tabTracker
windowTracker
}
)
;
class
Tab
extends
TabBase
{
get
_favIconUrl
(
)
{
return
undefined
;
}
get
attention
(
)
{
return
false
;
}
get
audible
(
)
{
return
this
.
nativeTab
.
playingAudio
;
}
get
browser
(
)
{
return
this
.
nativeTab
.
browser
;
}
get
discarded
(
)
{
return
this
.
browser
.
getAttribute
(
"
pending
"
)
=
=
=
"
true
"
;
}
get
cookieStoreId
(
)
{
return
getCookieStoreIdForTab
(
this
this
.
nativeTab
)
;
}
get
height
(
)
{
return
this
.
browser
.
clientHeight
;
}
get
incognito
(
)
{
return
PrivateBrowsingUtils
.
isBrowserPrivate
(
this
.
browser
)
;
}
get
index
(
)
{
return
this
.
window
.
BrowserApp
.
tabs
.
indexOf
(
this
.
nativeTab
)
;
}
get
mutedInfo
(
)
{
return
{
muted
:
false
}
;
}
get
lastAccessed
(
)
{
return
this
.
nativeTab
.
lastTouchedAt
;
}
get
pinned
(
)
{
return
false
;
}
get
active
(
)
{
if
(
tabTracker
.
extensionPopupTab
)
{
if
(
tabTracker
.
extensionPopupTab
.
getActive
(
)
&
&
this
.
nativeTab
.
id
=
=
=
tabTracker
.
extensionPopupTab
.
parentId
)
{
return
true
;
}
if
(
tabTracker
.
extensionPopupTab
=
=
=
this
.
nativeTab
)
{
return
false
;
}
}
return
this
.
nativeTab
.
getActive
(
)
;
}
get
highlighted
(
)
{
return
this
.
active
;
}
get
selected
(
)
{
return
this
.
nativeTab
.
getActive
(
)
;
}
get
status
(
)
{
if
(
this
.
browser
.
webProgress
.
isLoadingDocument
)
{
return
"
loading
"
;
}
return
"
complete
"
;
}
get
successorTabId
(
)
{
return
-
1
;
}
get
width
(
)
{
return
this
.
browser
.
clientWidth
;
}
get
window
(
)
{
return
this
.
browser
.
ownerGlobal
;
}
get
windowId
(
)
{
return
windowTracker
.
getId
(
this
.
window
)
;
}
get
isArticle
(
)
{
return
false
;
}
get
isInReaderMode
(
)
{
return
false
;
}
get
hidden
(
)
{
return
false
;
}
get
sharingState
(
)
{
return
{
screen
:
undefined
microphone
:
false
camera
:
false
}
;
}
}
class
TabContext
extends
EventEmitter
{
constructor
(
getDefaultPrototype
)
{
super
(
)
;
this
.
getDefaultPrototype
=
getDefaultPrototype
;
this
.
tabData
=
new
Map
(
)
;
GlobalEventDispatcher
.
registerListener
(
this
[
"
Tab
:
Selected
"
"
Tab
:
Closed
"
]
)
;
}
get
(
tabId
)
{
if
(
!
this
.
tabData
.
has
(
tabId
)
)
{
let
data
=
Object
.
create
(
this
.
getDefaultPrototype
(
tabId
)
)
;
this
.
tabData
.
set
(
tabId
data
)
;
}
return
this
.
tabData
.
get
(
tabId
)
;
}
clear
(
tabId
)
{
this
.
tabData
.
delete
(
tabId
)
;
}
onEvent
(
event
data
)
{
switch
(
event
)
{
case
"
Tab
:
Selected
"
:
this
.
emit
(
"
tab
-
selected
"
data
.
id
)
;
break
;
case
"
Tab
:
Closed
"
:
this
.
emit
(
"
tab
-
closed
"
data
.
tabId
)
;
break
;
}
}
shutdown
(
)
{
GlobalEventDispatcher
.
unregisterListener
(
this
[
"
Tab
:
Selected
"
"
Tab
:
Closed
"
]
)
;
}
}
class
Window
extends
WindowBase
{
get
focused
(
)
{
return
this
.
window
.
document
.
hasFocus
(
)
;
}
get
top
(
)
{
return
this
.
window
.
screenY
;
}
get
left
(
)
{
return
this
.
window
.
screenX
;
}
get
width
(
)
{
return
this
.
window
.
outerWidth
;
}
get
height
(
)
{
return
this
.
window
.
outerHeight
;
}
get
incognito
(
)
{
return
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
;
}
get
alwaysOnTop
(
)
{
return
false
;
}
get
isLastFocused
(
)
{
return
this
.
window
=
=
=
windowTracker
.
topWindow
;
}
get
state
(
)
{
return
"
fullscreen
"
;
}
*
getTabs
(
)
{
let
{
tabManager
}
=
this
.
extension
;
for
(
let
nativeTab
of
this
.
window
.
BrowserApp
.
tabs
)
{
yield
tabManager
.
getWrapper
(
nativeTab
)
;
}
}
*
getHighlightedTabs
(
)
{
yield
this
.
activeTab
;
}
get
activeTab
(
)
{
let
{
BrowserApp
}
=
this
.
window
;
let
{
selectedTab
}
=
BrowserApp
;
if
(
selectedTab
=
=
=
tabTracker
.
extensionPopupTab
)
{
selectedTab
=
BrowserApp
.
getTabForId
(
selectedTab
.
parentId
)
;
}
let
{
tabManager
}
=
this
.
extension
;
return
tabManager
.
getWrapper
(
selectedTab
)
;
}
getTabAtIndex
(
index
)
{
let
nativeTab
=
this
.
window
.
BrowserApp
.
tabs
[
index
]
;
if
(
nativeTab
)
{
return
this
.
extension
.
tabManager
.
getWrapper
(
nativeTab
)
;
}
}
}
Object
.
assign
(
global
{
Tab
TabContext
Window
}
)
;
class
TabManager
extends
TabManagerBase
{
get
(
tabId
default_
=
undefined
)
{
let
nativeTab
=
tabTracker
.
getTab
(
tabId
default_
)
;
if
(
nativeTab
)
{
return
this
.
getWrapper
(
nativeTab
)
;
}
return
default_
;
}
addActiveTabPermission
(
nativeTab
=
tabTracker
.
activeTab
)
{
return
super
.
addActiveTabPermission
(
nativeTab
)
;
}
revokeActiveTabPermission
(
nativeTab
=
tabTracker
.
activeTab
)
{
return
super
.
revokeActiveTabPermission
(
nativeTab
)
;
}
canAccessTab
(
nativeTab
)
{
return
this
.
extension
.
privateBrowsingAllowed
|
|
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
nativeTab
.
browser
)
;
}
wrapTab
(
nativeTab
)
{
return
new
Tab
(
this
.
extension
nativeTab
nativeTab
.
id
)
;
}
}
class
WindowManager
extends
WindowManagerBase
{
get
(
windowId
context
)
{
let
window
=
windowTracker
.
getWindow
(
windowId
context
)
;
return
this
.
getWrapper
(
window
)
;
}
*
getAll
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
yield
this
.
getWrapper
(
window
)
;
}
}
wrapWindow
(
window
)
{
return
new
Window
(
this
.
extension
window
windowTracker
.
getId
(
window
)
)
;
}
}
extensions
.
on
(
"
startup
"
(
type
extension
)
=
>
{
defineLazyGetter
(
extension
"
tabManager
"
(
)
=
>
new
TabManager
(
extension
)
)
;
defineLazyGetter
(
extension
"
windowManager
"
(
)
=
>
new
WindowManager
(
extension
)
)
;
}
)
;
