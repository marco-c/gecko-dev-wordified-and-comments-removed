"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserActions
"
"
resource
:
/
/
gre
/
modules
/
BrowserActions
.
jsm
"
)
;
let
browserActionMap
=
new
WeakMap
(
)
;
class
BrowserAction
extends
EventEmitter
{
constructor
(
options
extension
)
{
super
(
)
;
this
.
uuid
=
{
{
extension
.
uuid
}
}
;
this
.
defaults
=
{
name
:
options
.
default_title
|
|
extension
.
name
popup
:
options
.
default_popup
}
;
this
.
tabContext
=
new
TabContext
(
tabId
=
>
this
.
defaults
)
;
this
.
tabManager
=
extension
.
tabManager
;
this
.
tabContext
.
on
(
"
tab
-
selected
"
(
evt
tabId
)
=
>
{
this
.
onTabSelected
(
tabId
)
;
}
)
;
this
.
tabContext
.
on
(
"
tab
-
closed
"
(
evt
tabId
)
=
>
{
this
.
onTabClosed
(
tabId
)
;
}
)
;
BrowserActions
.
register
(
this
)
;
}
onClicked
(
)
{
const
tab
=
tabTracker
.
activeTab
;
this
.
tabManager
.
addActiveTabPermission
(
tab
)
;
let
popup
=
this
.
tabContext
.
get
(
tab
.
id
)
.
popup
|
|
this
.
defaults
.
popup
;
if
(
popup
)
{
tabTracker
.
openExtensionPopupTab
(
popup
)
;
}
else
{
this
.
emit
(
"
click
"
tab
)
;
}
}
onTabSelected
(
tabId
)
{
let
name
=
this
.
tabContext
.
get
(
tabId
)
.
name
|
|
this
.
defaults
.
name
;
BrowserActions
.
update
(
this
.
uuid
{
name
}
)
;
}
onTabClosed
(
tabId
)
{
this
.
tabContext
.
clear
(
tabId
)
;
}
setProperty
(
tab
prop
value
)
{
if
(
tab
=
=
null
)
{
if
(
value
)
{
this
.
defaults
[
prop
]
=
value
;
}
}
else
{
let
properties
=
this
.
tabContext
.
get
(
tab
.
id
)
;
if
(
value
)
{
properties
[
prop
]
=
value
;
}
else
{
delete
properties
[
prop
]
;
}
}
if
(
!
tab
|
|
tab
.
getActive
(
)
)
{
BrowserActions
.
update
(
this
.
uuid
{
[
prop
]
:
value
}
)
;
}
}
getProperty
(
tab
prop
)
{
if
(
tab
=
=
null
)
{
return
this
.
defaults
[
prop
]
;
}
return
this
.
tabContext
.
get
(
tab
.
id
)
[
prop
]
|
|
this
.
defaults
[
prop
]
;
}
shutdown
(
)
{
this
.
tabContext
.
shutdown
(
)
;
BrowserActions
.
unregister
(
this
.
uuid
)
;
}
}
this
.
browserAction
=
class
extends
ExtensionAPI
{
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
let
browserAction
=
new
BrowserAction
(
manifest
.
browser_action
extension
)
;
browserActionMap
.
set
(
extension
browserAction
)
;
}
onShutdown
(
)
{
let
{
extension
}
=
this
;
if
(
browserActionMap
.
has
(
extension
)
)
{
browserActionMap
.
get
(
extension
)
.
shutdown
(
)
;
browserActionMap
.
delete
(
extension
)
;
}
}
getAPI
(
context
)
{
const
{
extension
}
=
context
;
const
{
tabManager
}
=
extension
;
function
getTab
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
null
;
}
return
{
browserAction
:
{
onClicked
:
new
EventManager
(
{
context
name
:
"
browserAction
.
onClicked
"
register
:
fire
=
>
{
let
listener
=
(
event
tab
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
tab
)
)
;
}
;
browserActionMap
.
get
(
extension
)
.
on
(
"
click
"
listener
)
;
return
(
)
=
>
{
browserActionMap
.
get
(
extension
)
.
off
(
"
click
"
listener
)
;
}
;
}
}
)
.
api
(
)
setTitle
:
function
(
details
)
{
let
{
tabId
title
}
=
details
;
let
tab
=
getTab
(
tabId
)
;
browserActionMap
.
get
(
extension
)
.
setProperty
(
tab
"
name
"
title
)
;
}
getTitle
:
function
(
details
)
{
let
{
tabId
}
=
details
;
let
tab
=
getTab
(
tabId
)
;
let
title
=
browserActionMap
.
get
(
extension
)
.
getProperty
(
tab
"
name
"
)
;
return
Promise
.
resolve
(
title
)
;
}
setPopup
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
url
=
details
.
popup
&
&
context
.
uri
.
resolve
(
details
.
popup
)
;
browserActionMap
.
get
(
extension
)
.
setProperty
(
tab
"
popup
"
url
)
;
}
getPopup
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
popup
=
browserActionMap
.
get
(
extension
)
.
getProperty
(
tab
"
popup
"
)
;
return
Promise
.
resolve
(
popup
)
;
}
}
}
;
}
}
;
