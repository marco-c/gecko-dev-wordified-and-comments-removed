"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
EventEmitter
"
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PageActions
"
"
resource
:
/
/
gre
/
modules
/
PageActions
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
var
{
IconDetails
}
=
ExtensionParent
;
let
pageActionMap
=
new
WeakMap
(
)
;
class
PageAction
{
constructor
(
manifest
extension
)
{
this
.
id
=
null
;
this
.
extension
=
extension
;
this
.
defaults
=
{
icons
:
IconDetails
.
normalize
(
{
path
:
manifest
.
default_icon
}
extension
)
popup
:
manifest
.
default_popup
}
;
this
.
tabManager
=
extension
.
tabManager
;
this
.
context
=
null
;
this
.
tabContext
=
new
TabContext
(
(
)
=
>
Object
.
create
(
this
.
defaults
)
extension
)
;
this
.
options
=
{
title
:
manifest
.
default_title
|
|
extension
.
name
id
:
{
{
extension
.
uuid
}
}
clickCallback
:
(
)
=
>
{
let
tab
=
tabTracker
.
activeTab
;
let
popup
=
this
.
tabContext
.
get
(
tab
.
id
)
.
popup
|
|
this
.
defaults
.
popup
;
if
(
popup
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
win
.
BrowserApp
.
addTab
(
popup
{
selected
:
true
parentId
:
win
.
BrowserApp
.
selectedTab
.
id
}
)
;
}
else
{
this
.
emit
(
"
click
"
tab
)
;
}
}
}
;
this
.
shouldShow
=
false
;
this
.
tabContext
.
on
(
"
tab
-
selected
"
(
evt
tabId
)
=
>
{
this
.
onTabSelected
(
tabId
)
;
}
)
;
this
.
tabContext
.
on
(
"
tab
-
closed
"
(
evt
tabId
)
=
>
{
this
.
onTabClosed
(
tabId
)
;
}
)
;
EventEmitter
.
decorate
(
this
)
;
}
onTabSelected
(
tabId
)
{
if
(
this
.
options
.
icon
)
{
this
.
hide
(
)
;
let
shouldShow
=
this
.
tabContext
.
get
(
tabId
)
.
show
;
if
(
shouldShow
)
{
this
.
show
(
)
;
}
}
}
onTabClosed
(
tabId
)
{
this
.
tabContext
.
clear
(
tabId
)
;
}
setContext
(
context
)
{
this
.
context
=
context
;
}
setProperty
(
tab
prop
value
)
{
if
(
tab
=
=
null
)
{
throw
new
Error
(
"
Tab
must
not
be
null
"
)
;
}
let
properties
=
this
.
tabContext
.
get
(
tab
.
id
)
;
if
(
value
)
{
properties
[
prop
]
=
value
;
}
else
{
delete
properties
[
prop
]
;
}
if
(
prop
=
=
=
"
show
"
&
&
tab
.
id
=
=
tabTracker
.
activeTab
.
id
)
{
if
(
this
.
id
&
&
!
value
)
{
return
this
.
hide
(
)
;
}
else
if
(
!
this
.
id
&
&
value
)
{
return
this
.
show
(
)
;
}
}
}
getProperty
(
tab
prop
)
{
if
(
tab
=
=
null
)
{
return
this
.
defaults
[
prop
]
;
}
return
this
.
tabContext
.
get
(
tab
.
id
)
[
prop
]
|
|
this
.
defaults
[
prop
]
;
}
show
(
)
{
if
(
this
.
id
)
{
return
Promise
.
resolve
(
)
;
}
if
(
this
.
options
.
icon
)
{
this
.
id
=
PageActions
.
add
(
this
.
options
)
;
return
Promise
.
resolve
(
)
;
}
this
.
shouldShow
=
true
;
let
{
contentWindow
}
=
this
.
context
.
xulBrowser
;
let
{
icon
}
=
IconDetails
.
getPreferredIcon
(
this
.
defaults
.
icons
this
.
extension
18
*
contentWindow
.
devicePixelRatio
)
;
let
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
return
IconDetails
.
convertImageURLToDataURL
(
icon
contentWindow
browserWindow
)
.
then
(
dataURI
=
>
{
if
(
this
.
shouldShow
)
{
this
.
options
.
icon
=
dataURI
;
this
.
id
=
PageActions
.
add
(
this
.
options
)
;
}
}
)
.
catch
(
(
)
=
>
{
return
Promise
.
reject
(
{
message
:
"
Failed
to
load
PageAction
icon
"
}
)
;
}
)
;
}
hide
(
)
{
this
.
shouldShow
=
false
;
if
(
this
.
id
)
{
PageActions
.
remove
(
this
.
id
)
;
this
.
id
=
null
;
}
}
shutdown
(
)
{
this
.
tabContext
.
shutdown
(
)
;
this
.
hide
(
)
;
}
}
;
this
.
pageAction
=
class
extends
ExtensionAPI
{
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
let
pageAction
=
new
PageAction
(
manifest
.
page_action
extension
)
;
pageActionMap
.
set
(
extension
pageAction
)
;
}
onShutdown
(
reason
)
{
let
{
extension
}
=
this
;
if
(
pageActionMap
.
has
(
extension
)
)
{
pageActionMap
.
get
(
extension
)
.
shutdown
(
)
;
pageActionMap
.
delete
(
extension
)
;
}
}
getAPI
(
context
)
{
const
{
extension
}
=
context
;
const
{
tabManager
}
=
extension
;
pageActionMap
.
get
(
extension
)
.
setContext
(
context
)
;
return
{
pageAction
:
{
onClicked
:
new
EventManager
(
context
"
pageAction
.
onClicked
"
fire
=
>
{
let
listener
=
(
event
tab
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
tab
)
)
;
}
;
pageActionMap
.
get
(
extension
)
.
on
(
"
click
"
listener
)
;
return
(
)
=
>
{
pageActionMap
.
get
(
extension
)
.
off
(
"
click
"
listener
)
;
}
;
}
)
.
api
(
)
show
(
tabId
)
{
let
tab
=
tabId
?
tabTracker
.
getTab
(
tabId
)
:
null
;
return
pageActionMap
.
get
(
extension
)
.
setProperty
(
tab
"
show
"
true
)
;
}
hide
(
tabId
)
{
let
tab
=
tabId
?
tabTracker
.
getTab
(
tabId
)
:
null
;
pageActionMap
.
get
(
extension
)
.
setProperty
(
tab
"
show
"
false
)
;
}
setPopup
(
details
)
{
let
tab
=
details
.
tabId
?
tabTracker
.
getTab
(
details
.
tabId
)
:
null
;
let
url
=
details
.
popup
&
&
context
.
uri
.
resolve
(
details
.
popup
)
;
pageActionMap
.
get
(
extension
)
.
setProperty
(
tab
"
popup
"
url
)
;
}
getPopup
(
details
)
{
let
tab
=
details
.
tabId
?
tabTracker
.
getTab
(
details
.
tabId
)
:
null
;
let
popup
=
pageActionMap
.
get
(
extension
)
.
getProperty
(
tab
"
popup
"
)
;
return
Promise
.
resolve
(
popup
)
;
}
}
}
;
}
}
;
