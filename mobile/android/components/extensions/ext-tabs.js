"
use
strict
"
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aboutNewTabService
"
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MatchPattern
"
"
resource
:
/
/
gre
/
modules
/
MatchPattern
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
SingletonEventManager
ignoreEvent
}
=
ExtensionUtils
;
function
getSender
(
extension
target
sender
)
{
let
tabId
;
if
(
"
tabId
"
in
sender
)
{
tabId
=
sender
.
tabId
;
delete
sender
.
tabId
;
}
else
if
(
target
instanceof
Ci
.
nsIDOMXULElement
)
{
tabId
=
tabTracker
.
getBrowserData
(
target
)
.
tabId
;
}
if
(
tabId
)
{
let
tab
=
extension
.
tabManager
.
get
(
tabId
null
)
;
if
(
tab
)
{
sender
.
tab
=
tab
.
convert
(
)
;
}
}
}
global
.
tabGetSender
=
getSender
;
extensions
.
on
(
"
page
-
shutdown
"
(
type
context
)
=
>
{
if
(
context
.
viewType
=
=
"
tab
"
)
{
if
(
context
.
extension
.
id
!
=
=
context
.
xulBrowser
.
contentPrincipal
.
addonId
)
{
return
;
}
let
{
BrowserApp
}
=
context
.
xulBrowser
.
ownerGlobal
;
if
(
BrowserApp
)
{
let
tab
=
BrowserApp
.
getTabForBrowser
(
context
.
xulBrowser
)
;
if
(
tab
)
{
BrowserApp
.
closeTab
(
tab
)
;
}
}
}
}
)
;
function
getBrowserWindow
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
let
tabListener
=
{
tabReadyInitialized
:
false
tabReadyPromises
:
new
WeakMap
(
)
initializingTabs
:
new
WeakSet
(
)
initTabReady
(
)
{
if
(
!
this
.
tabReadyInitialized
)
{
windowTracker
.
addListener
(
"
progress
"
this
)
;
this
.
tabReadyInitialized
=
true
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
)
{
let
{
BrowserApp
}
=
browser
.
ownerGlobal
;
let
tab
=
BrowserApp
.
getTabForBrowser
(
browser
)
;
this
.
initializingTabs
.
delete
(
tab
)
;
let
deferred
=
this
.
tabReadyPromises
.
get
(
tab
)
;
if
(
deferred
)
{
deferred
.
resolve
(
tab
)
;
this
.
tabReadyPromises
.
delete
(
tab
)
;
}
}
}
awaitTabReady
(
tab
)
{
let
deferred
=
this
.
tabReadyPromises
.
get
(
tab
)
;
if
(
!
deferred
)
{
deferred
=
PromiseUtils
.
defer
(
)
;
if
(
!
this
.
initializingTabs
.
has
(
tab
)
&
&
(
tab
.
browser
.
innerWindowID
|
|
tab
.
browser
.
currentURI
.
spec
=
=
=
"
about
:
blank
"
)
)
{
deferred
.
resolve
(
tab
)
;
}
else
{
this
.
initTabReady
(
)
;
this
.
tabReadyPromises
.
set
(
tab
deferred
)
;
}
}
return
deferred
.
promise
;
}
}
;
extensions
.
registerSchemaAPI
(
"
tabs
"
"
addon_parent
"
context
=
>
{
let
{
extension
}
=
context
;
let
{
tabManager
}
=
extension
;
function
getTabOrActive
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
tabTracker
.
activeTab
;
}
async
function
promiseTabWhenReady
(
tabId
)
{
let
tab
;
if
(
tabId
!
=
=
null
)
{
tab
=
tabManager
.
get
(
tabId
)
;
}
else
{
tab
=
tabManager
.
getWrapper
(
tabTracker
.
activeTab
)
;
}
await
tabListener
.
awaitTabReady
(
tab
.
tab
)
;
return
tab
;
}
let
self
=
{
tabs
:
{
onActivated
:
new
GlobalEventManager
(
context
"
tabs
.
onActivated
"
"
Tab
:
Selected
"
(
fire
data
)
=
>
{
let
tab
=
tabManager
.
get
(
data
.
id
)
;
fire
.
async
(
{
tabId
:
tab
.
id
windowId
:
tab
.
windowId
}
)
;
}
)
.
api
(
)
onCreated
:
new
SingletonEventManager
(
context
"
tabs
.
onCreated
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
event
.
tab
)
)
;
}
;
tabTracker
.
on
(
"
tab
-
created
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
created
"
listener
)
;
}
;
}
)
.
api
(
)
onHighlighted
:
new
GlobalEventManager
(
context
"
tabs
.
onHighlighted
"
"
Tab
:
Selected
"
(
fire
data
)
=
>
{
let
tab
=
tabManager
.
get
(
data
.
id
)
;
fire
.
async
(
{
tabIds
:
[
tab
.
id
]
windowId
:
tab
.
windowId
}
)
;
}
)
.
api
(
)
onAttached
:
new
SingletonEventManager
(
context
"
tabs
.
onAttached
"
fire
=
>
{
return
(
)
=
>
{
}
;
}
)
.
api
(
)
onDetached
:
new
SingletonEventManager
(
context
"
tabs
.
onDetached
"
fire
=
>
{
return
(
)
=
>
{
}
;
}
)
.
api
(
)
onRemoved
:
new
SingletonEventManager
(
context
"
tabs
.
onRemoved
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
windowId
:
event
.
windowId
isWindowClosing
:
event
.
isWindowClosing
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
removed
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
removed
"
listener
)
;
}
;
}
)
.
api
(
)
onReplaced
:
ignoreEvent
(
context
"
tabs
.
onReplaced
"
)
onMoved
:
new
SingletonEventManager
(
context
"
tabs
.
onMoved
"
fire
=
>
{
return
(
)
=
>
{
}
;
}
)
.
api
(
)
onUpdated
:
new
SingletonEventManager
(
context
"
tabs
.
onUpdated
"
fire
=
>
{
const
restricted
=
[
"
url
"
"
favIconUrl
"
"
title
"
]
;
function
sanitize
(
extension
changeInfo
)
{
let
result
=
{
}
;
let
nonempty
=
false
;
for
(
let
prop
in
changeInfo
)
{
if
(
extension
.
hasPermission
(
"
tabs
"
)
|
|
!
restricted
.
includes
(
prop
)
)
{
nonempty
=
true
;
result
[
prop
]
=
changeInfo
[
prop
]
;
}
}
return
[
nonempty
result
]
;
}
let
fireForTab
=
(
tab
changed
)
=
>
{
let
[
needed
changeInfo
]
=
sanitize
(
extension
changed
)
;
if
(
needed
)
{
fire
.
async
(
tab
.
id
changeInfo
tab
.
convert
(
)
)
;
}
}
;
let
listener
=
event
=
>
{
let
needed
=
[
]
;
let
tab
;
switch
(
event
.
type
)
{
case
"
DOMTitleChanged
"
:
{
let
{
BrowserApp
}
=
getBrowserWindow
(
event
.
target
.
ownerGlobal
)
;
tab
=
BrowserApp
.
getTabForWindow
(
event
.
target
.
ownerGlobal
)
;
needed
.
push
(
"
title
"
)
;
break
;
}
case
"
DOMAudioPlaybackStarted
"
:
case
"
DOMAudioPlaybackStopped
"
:
{
let
{
BrowserApp
}
=
event
.
target
.
ownerGlobal
;
tab
=
BrowserApp
.
getTabForBrowser
(
event
.
originalTarget
)
;
needed
.
push
(
"
audible
"
)
;
break
;
}
}
if
(
!
tab
)
{
return
;
}
tab
=
tabManager
.
getWrapper
(
tab
)
;
let
changeInfo
=
{
}
;
for
(
let
prop
of
needed
)
{
changeInfo
[
prop
]
=
tab
[
prop
]
;
}
fireForTab
(
tab
changeInfo
)
;
}
;
let
statusListener
=
(
{
browser
status
url
}
)
=
>
{
let
{
BrowserApp
}
=
browser
.
ownerGlobal
;
let
tab
=
BrowserApp
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
let
changed
=
{
status
}
;
if
(
url
)
{
changed
.
url
=
url
;
}
fireForTab
(
tabManager
.
wrapTab
(
tab
)
changed
)
;
}
}
;
windowTracker
.
addListener
(
"
status
"
statusListener
)
;
windowTracker
.
addListener
(
"
DOMTitleChanged
"
listener
)
;
return
(
)
=
>
{
windowTracker
.
removeListener
(
"
status
"
statusListener
)
;
windowTracker
.
removeListener
(
"
DOMTitleChanged
"
listener
)
;
}
;
}
)
.
api
(
)
async
create
(
createProperties
)
{
let
window
=
createProperties
.
windowId
!
=
=
null
?
windowTracker
.
getWindow
(
createProperties
.
windowId
context
)
:
windowTracker
.
topWindow
;
let
{
BrowserApp
}
=
window
;
let
url
;
if
(
createProperties
.
url
!
=
=
null
)
{
url
=
context
.
uri
.
resolve
(
createProperties
.
url
)
;
if
(
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
}
let
options
=
{
}
;
let
active
=
true
;
if
(
createProperties
.
active
!
=
=
null
)
{
active
=
createProperties
.
active
;
}
options
.
selected
=
active
;
if
(
createProperties
.
index
!
=
=
null
)
{
options
.
tabIndex
=
createProperties
.
index
;
}
options
.
disallowInheritPrincipal
=
true
;
tabListener
.
initTabReady
(
)
;
let
tab
=
BrowserApp
.
addTab
(
url
options
)
;
if
(
createProperties
.
url
)
{
tabListener
.
initializingTabs
.
add
(
tab
)
;
}
return
tabManager
.
convert
(
tab
)
;
}
async
remove
(
tabs
)
{
if
(
!
Array
.
isArray
(
tabs
)
)
{
tabs
=
[
tabs
]
;
}
for
(
let
tabId
of
tabs
)
{
let
tab
=
tabTracker
.
getTab
(
tabId
)
;
tab
.
browser
.
ownerGlobal
.
BrowserApp
.
closeTab
(
tab
)
;
}
}
async
update
(
tabId
updateProperties
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
{
BrowserApp
}
=
tab
.
browser
.
ownerGlobal
;
if
(
updateProperties
.
url
!
=
=
null
)
{
let
url
=
context
.
uri
.
resolve
(
updateProperties
.
url
)
;
if
(
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
tab
.
browser
.
loadURI
(
url
)
;
}
if
(
updateProperties
.
active
!
=
=
null
)
{
if
(
updateProperties
.
active
)
{
BrowserApp
.
selectTab
(
tab
)
;
}
else
{
}
}
return
tabManager
.
convert
(
tab
)
;
}
async
reload
(
tabId
reloadProperties
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
reloadProperties
&
&
reloadProperties
.
bypassCache
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
}
tab
.
browser
.
reloadWithFlags
(
flags
)
;
}
async
get
(
tabId
)
{
return
tabManager
.
get
(
tabId
)
.
convert
(
)
;
}
async
getCurrent
(
)
{
if
(
context
.
tabId
)
{
return
tabManager
.
get
(
context
.
tabId
)
.
convert
(
)
;
}
}
async
query
(
queryInfo
)
{
if
(
queryInfo
.
url
!
=
=
null
)
{
if
(
!
extension
.
hasPermission
(
"
tabs
"
)
)
{
return
Promise
.
reject
(
{
message
:
'
The
"
tabs
"
permission
is
required
to
use
the
query
API
with
the
"
url
"
parameter
'
}
)
;
}
queryInfo
=
Object
.
assign
(
{
}
queryInfo
)
;
queryInfo
.
url
=
new
MatchPattern
(
queryInfo
.
url
)
;
}
return
Array
.
from
(
tabManager
.
query
(
queryInfo
context
)
tab
=
>
tab
.
convert
(
)
)
;
}
async
captureVisibleTab
(
windowId
options
)
{
let
window
=
windowId
=
=
null
?
windowTracker
.
topWindow
:
windowTracker
.
getWindow
(
windowId
context
)
;
let
tab
=
tabManager
.
wrapTab
(
window
.
BrowserApp
.
selectedTab
)
;
await
tabListener
.
awaitTabReady
(
tab
.
tab
)
;
return
tab
.
capture
(
context
options
)
;
}
async
executeScript
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
executeScript
(
context
details
)
;
}
async
insertCSS
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
insertCSS
(
context
details
)
;
}
async
removeCSS
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
removeCSS
(
context
details
)
;
}
}
}
;
return
self
;
}
)
;
