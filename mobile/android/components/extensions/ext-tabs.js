"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
GeckoViewTabBridge
"
"
resource
:
/
/
gre
/
modules
/
GeckoViewTab
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
mobileWindowTracker
"
"
resource
:
/
/
gre
/
modules
/
GeckoViewWebExtension
.
jsm
"
)
;
const
getBrowserWindow
=
window
=
>
{
return
window
.
browsingContext
.
topChromeWindow
;
}
;
const
tabListener
=
{
tabReadyInitialized
:
false
tabReadyPromises
:
new
WeakMap
(
)
initializingTabs
:
new
WeakSet
(
)
initTabReady
(
)
{
if
(
!
this
.
tabReadyInitialized
)
{
windowTracker
.
addListener
(
"
progress
"
this
)
;
this
.
tabReadyInitialized
=
true
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
)
{
const
{
tab
}
=
browser
.
ownerGlobal
;
if
(
!
request
&
&
this
.
initializingTabs
.
has
(
tab
)
)
{
return
;
}
this
.
initializingTabs
.
delete
(
tab
)
;
const
deferred
=
this
.
tabReadyPromises
.
get
(
tab
)
;
if
(
deferred
)
{
deferred
.
resolve
(
tab
)
;
this
.
tabReadyPromises
.
delete
(
tab
)
;
}
}
}
awaitTabReady
(
nativeTab
)
{
let
deferred
=
this
.
tabReadyPromises
.
get
(
nativeTab
)
;
if
(
!
deferred
)
{
deferred
=
PromiseUtils
.
defer
(
)
;
if
(
!
this
.
initializingTabs
.
has
(
nativeTab
)
&
&
(
nativeTab
.
browser
.
innerWindowID
|
|
nativeTab
.
browser
.
currentURI
.
spec
=
=
=
"
about
:
blank
"
)
)
{
deferred
.
resolve
(
nativeTab
)
;
}
else
{
this
.
initTabReady
(
)
;
this
.
tabReadyPromises
.
set
(
nativeTab
deferred
)
;
}
}
return
deferred
.
promise
;
}
}
;
this
.
tabs
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
const
{
extension
}
=
context
;
const
{
tabManager
}
=
extension
;
function
getTabOrActive
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
tabTracker
.
activeTab
;
}
async
function
promiseTabWhenReady
(
tabId
)
{
let
tab
;
if
(
tabId
!
=
=
null
)
{
tab
=
tabManager
.
get
(
tabId
)
;
}
else
{
tab
=
tabManager
.
getWrapper
(
tabTracker
.
activeTab
)
;
}
if
(
!
tab
)
{
throw
new
ExtensionError
(
tabId
=
=
null
?
"
Cannot
access
activeTab
"
:
Invalid
tab
ID
:
{
tabId
}
)
;
}
await
tabListener
.
awaitTabReady
(
tab
.
nativeTab
)
;
return
tab
;
}
function
loadURIInTab
(
nativeTab
url
)
{
const
{
browser
}
=
nativeTab
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
let
{
principal
}
=
context
;
const
isAboutUrl
=
url
.
startsWith
(
"
about
:
"
)
;
if
(
isAboutUrl
|
|
(
url
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
&
&
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
)
{
principal
=
Services
.
scriptSecurityManager
.
getLoadContextContentPrincipal
(
Services
.
io
.
newURI
(
url
)
browser
.
loadContext
)
;
}
if
(
isAboutUrl
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
browser
.
loadURI
(
url
{
flags
triggeringPrincipal
:
principal
}
)
;
}
const
self
=
{
tabs
:
{
onActivated
:
new
EventManager
(
{
context
name
:
"
tabs
.
onActivated
"
register
:
fire
=
>
{
const
listener
=
(
eventName
event
)
=
>
{
const
{
windowId
tabId
isPrivate
}
=
event
;
if
(
isPrivate
&
&
!
context
.
privateBrowsingAllowed
)
{
return
;
}
fire
.
async
(
{
windowId
tabId
}
)
;
}
;
mobileWindowTracker
.
on
(
"
tab
-
activated
"
listener
)
;
return
(
)
=
>
{
mobileWindowTracker
.
off
(
"
tab
-
activated
"
listener
)
;
}
;
}
}
)
.
api
(
)
onCreated
:
new
EventManager
(
{
context
name
:
"
tabs
.
onCreated
"
register
:
fire
=
>
{
const
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
event
.
nativeTab
)
)
;
}
;
tabTracker
.
on
(
"
tab
-
created
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
created
"
listener
)
;
}
;
}
}
)
.
api
(
)
onHighlighted
:
makeGlobalEvent
(
context
"
tabs
.
onHighlighted
"
"
Tab
:
Selected
"
(
fire
data
)
=
>
{
const
tab
=
tabManager
.
get
(
data
.
id
)
;
fire
.
async
(
{
tabIds
:
[
tab
.
id
]
windowId
:
tab
.
windowId
}
)
;
}
)
onAttached
:
new
EventManager
(
{
context
name
:
"
tabs
.
onAttached
"
register
:
fire
=
>
{
return
(
)
=
>
{
}
;
}
}
)
.
api
(
)
onDetached
:
new
EventManager
(
{
context
name
:
"
tabs
.
onDetached
"
register
:
fire
=
>
{
return
(
)
=
>
{
}
;
}
}
)
.
api
(
)
onRemoved
:
new
EventManager
(
{
context
name
:
"
tabs
.
onRemoved
"
register
:
fire
=
>
{
const
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
windowId
:
event
.
windowId
isWindowClosing
:
event
.
isWindowClosing
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
removed
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
removed
"
listener
)
;
}
;
}
}
)
.
api
(
)
onReplaced
:
new
EventManager
(
{
context
name
:
"
tabs
.
onReplaced
"
register
:
fire
=
>
{
return
(
)
=
>
{
}
;
}
}
)
.
api
(
)
onMoved
:
new
EventManager
(
{
context
name
:
"
tabs
.
onMoved
"
register
:
fire
=
>
{
return
(
)
=
>
{
}
;
}
}
)
.
api
(
)
onUpdated
:
new
EventManager
(
{
context
name
:
"
tabs
.
onUpdated
"
register
:
fire
=
>
{
const
restricted
=
[
"
url
"
"
favIconUrl
"
"
title
"
]
;
function
sanitize
(
tab
changeInfo
)
{
const
result
=
{
}
;
let
nonempty
=
false
;
for
(
const
prop
in
changeInfo
)
{
if
(
!
restricted
.
includes
(
prop
)
|
|
tab
.
hasTabPermission
)
{
nonempty
=
true
;
result
[
prop
]
=
changeInfo
[
prop
]
;
}
}
return
[
nonempty
result
]
;
}
const
fireForTab
=
(
tab
changed
)
=
>
{
const
[
needed
changeInfo
]
=
sanitize
(
tab
changed
)
;
if
(
needed
)
{
fire
.
async
(
tab
.
id
changeInfo
tab
.
convert
(
)
)
;
}
}
;
const
listener
=
event
=
>
{
const
needed
=
[
]
;
let
nativeTab
;
switch
(
event
.
type
)
{
case
"
pagetitlechanged
"
:
{
const
window
=
getBrowserWindow
(
event
.
target
.
ownerGlobal
)
;
nativeTab
=
window
.
tab
;
needed
.
push
(
"
title
"
)
;
break
;
}
case
"
DOMAudioPlaybackStarted
"
:
case
"
DOMAudioPlaybackStopped
"
:
{
const
window
=
event
.
target
.
ownerGlobal
;
nativeTab
=
window
.
tab
;
needed
.
push
(
"
audible
"
)
;
break
;
}
}
if
(
!
nativeTab
)
{
return
;
}
const
tab
=
tabManager
.
getWrapper
(
nativeTab
)
;
const
changeInfo
=
{
}
;
for
(
const
prop
of
needed
)
{
changeInfo
[
prop
]
=
tab
[
prop
]
;
}
fireForTab
(
tab
changeInfo
)
;
}
;
const
statusListener
=
(
{
browser
status
url
}
)
=
>
{
const
{
tab
}
=
browser
.
ownerGlobal
;
if
(
tab
)
{
const
changed
=
{
status
}
;
if
(
url
)
{
changed
.
url
=
url
;
}
fireForTab
(
tabManager
.
wrapTab
(
tab
)
changed
)
;
}
}
;
windowTracker
.
addListener
(
"
status
"
statusListener
)
;
windowTracker
.
addListener
(
"
pagetitlechanged
"
listener
)
;
return
(
)
=
>
{
windowTracker
.
removeListener
(
"
status
"
statusListener
)
;
windowTracker
.
removeListener
(
"
pagetitlechanged
"
listener
)
;
}
;
}
}
)
.
api
(
)
async
create
(
{
active
cookieStoreId
discarded
index
openInReaderMode
pinned
title
url
}
=
{
}
)
{
if
(
active
=
=
=
null
)
{
active
=
true
;
}
tabListener
.
initTabReady
(
)
;
if
(
url
!
=
=
null
)
{
url
=
context
.
uri
.
resolve
(
url
)
;
if
(
!
url
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
&
&
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
}
if
(
cookieStoreId
)
{
cookieStoreId
=
getUserContextIdForCookieStoreId
(
extension
cookieStoreId
false
)
;
}
cookieStoreId
=
cookieStoreId
?
cookieStoreId
.
toString
(
)
:
undefined
;
const
nativeTab
=
await
GeckoViewTabBridge
.
createNewTab
(
{
extensionId
:
context
.
extension
.
id
createProperties
:
{
active
cookieStoreId
discarded
index
openInReaderMode
pinned
url
}
}
)
;
if
(
url
!
=
=
null
)
{
tabListener
.
initializingTabs
.
add
(
nativeTab
)
;
}
else
{
url
=
"
about
:
blank
"
;
}
loadURIInTab
(
nativeTab
url
)
;
if
(
active
)
{
const
newWindow
=
nativeTab
.
browser
.
ownerGlobal
;
mobileWindowTracker
.
setTabActive
(
newWindow
true
)
;
}
return
tabManager
.
convert
(
nativeTab
)
;
}
async
remove
(
tabs
)
{
if
(
!
Array
.
isArray
(
tabs
)
)
{
tabs
=
[
tabs
]
;
}
await
Promise
.
all
(
tabs
.
map
(
async
tabId
=
>
{
const
windowId
=
GeckoViewTabBridge
.
tabIdToWindowId
(
tabId
)
;
const
window
=
windowTracker
.
getWindow
(
windowId
context
false
)
;
if
(
!
window
)
{
throw
new
ExtensionError
(
Invalid
tab
ID
{
tabId
}
)
;
}
await
GeckoViewTabBridge
.
closeTab
(
{
window
extensionId
:
context
.
extension
.
id
}
)
;
}
)
)
;
}
async
update
(
tabId
{
active
autoDiscardable
highlighted
muted
pinned
url
}
=
{
}
)
{
const
nativeTab
=
getTabOrActive
(
tabId
)
;
const
window
=
nativeTab
.
browser
.
ownerGlobal
;
if
(
url
!
=
=
null
)
{
url
=
context
.
uri
.
resolve
(
url
)
;
if
(
!
url
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
&
&
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
}
await
GeckoViewTabBridge
.
updateTab
(
{
window
extensionId
:
context
.
extension
.
id
updateProperties
:
{
active
autoDiscardable
highlighted
muted
pinned
url
}
}
)
;
if
(
url
!
=
=
null
)
{
loadURIInTab
(
nativeTab
url
)
;
}
if
(
active
)
{
mobileWindowTracker
.
setTabActive
(
window
true
)
;
}
return
tabManager
.
convert
(
nativeTab
)
;
}
async
reload
(
tabId
reloadProperties
)
{
const
nativeTab
=
getTabOrActive
(
tabId
)
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
reloadProperties
&
&
reloadProperties
.
bypassCache
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
}
nativeTab
.
browser
.
reloadWithFlags
(
flags
)
;
}
async
get
(
tabId
)
{
return
tabManager
.
get
(
tabId
)
.
convert
(
)
;
}
async
getCurrent
(
)
{
if
(
context
.
tabId
)
{
return
tabManager
.
get
(
context
.
tabId
)
.
convert
(
)
;
}
}
async
query
(
queryInfo
)
{
return
Array
.
from
(
tabManager
.
query
(
queryInfo
context
)
tab
=
>
tab
.
convert
(
)
)
;
}
async
captureTab
(
tabId
options
)
{
const
nativeTab
=
getTabOrActive
(
tabId
)
;
await
tabListener
.
awaitTabReady
(
nativeTab
)
;
const
{
browser
}
=
nativeTab
;
const
window
=
browser
.
ownerGlobal
;
const
zoom
=
window
.
windowUtils
.
fullZoom
;
const
tab
=
tabManager
.
wrapTab
(
nativeTab
)
;
return
tab
.
capture
(
context
zoom
options
)
;
}
async
captureVisibleTab
(
windowId
options
)
{
const
window
=
windowId
=
=
null
?
windowTracker
.
topWindow
:
windowTracker
.
getWindow
(
windowId
context
)
;
const
tab
=
tabManager
.
wrapTab
(
window
.
tab
)
;
await
tabListener
.
awaitTabReady
(
tab
.
nativeTab
)
;
const
zoom
=
window
.
windowUtils
.
fullZoom
;
return
tab
.
capture
(
context
zoom
options
)
;
}
async
executeScript
(
tabId
details
)
{
const
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
executeScript
(
context
details
)
;
}
async
insertCSS
(
tabId
details
)
{
const
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
insertCSS
(
context
details
)
;
}
async
removeCSS
(
tabId
details
)
{
const
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
removeCSS
(
context
details
)
;
}
goForward
(
tabId
)
{
const
{
browser
}
=
getTabOrActive
(
tabId
)
;
browser
.
goForward
(
)
;
}
goBack
(
tabId
)
{
const
{
browser
}
=
getTabOrActive
(
tabId
)
;
browser
.
goBack
(
)
;
}
}
}
;
return
self
;
}
}
;
