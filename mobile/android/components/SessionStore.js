"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
EventDispatcher
"
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivacyLevel
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
PrivacyLevel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormData
"
"
resource
:
/
/
gre
/
modules
/
FormData
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ScrollPosition
"
"
resource
:
/
/
gre
/
modules
/
ScrollPosition
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
"
AndroidLog
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SharedPreferences
"
"
resource
:
/
/
gre
/
modules
/
SharedPreferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
function
dump
(
a
)
{
Services
.
console
.
logStringMessage
(
a
)
;
}
let
loggingEnabled
=
false
;
function
log
(
a
)
{
if
(
!
loggingEnabled
)
{
return
;
}
Log
.
d
(
"
SessionStore
"
a
)
;
}
const
STATE_STOPPED
=
0
;
const
STATE_RUNNING
=
1
;
const
STATE_QUITTING
=
-
1
;
const
STATE_QUITTING_FLUSHED
=
-
2
;
const
PREFS_RESTORE_FROM_CRASH
=
"
browser
.
sessionstore
.
resume_from_crash
"
;
const
PREFS_MAX_CRASH_RESUMES
=
"
browser
.
sessionstore
.
max_resumed_crashes
"
;
const
PREFS_MAX_TABS_UNDO
=
"
browser
.
sessionstore
.
max_tabs_undo
"
;
const
MINIMUM_SAVE_DELAY
=
2000
;
const
MINIMUM_SAVE_DELAY_BACKGROUND
=
200
;
function
SessionStore
(
)
{
}
SessionStore
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
8c1f07d6
-
cba3
-
4226
-
a315
-
8bd43d67d032
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISessionStore
Ci
.
nsIDOMEventListener
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
_windows
:
{
}
_lastSaveTime
:
0
_lastBackupTime
:
0
_interval
:
10000
_backupInterval
:
120000
_minSaveDelay
:
MINIMUM_SAVE_DELAY
_maxTabsUndo
:
5
_pendingWrite
:
0
_scrollSavePending
:
null
_writeInProgress
:
false
_sessionDataIsGood
:
false
_lastClosedTabIndex
:
-
1
_notifyClosedTabs
:
false
_keepAsZombieTabId
:
-
1
init
:
function
ss_init
(
)
{
loggingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
debug_logging
"
)
;
this
.
_sessionFile
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsILocalFile
)
;
this
.
_sessionFileBackup
=
this
.
_sessionFile
.
clone
(
)
;
this
.
_sessionFilePrevious
=
this
.
_sessionFile
.
clone
(
)
;
this
.
_sessionFileTemp
=
this
.
_sessionFile
.
clone
(
)
;
this
.
_sessionFile
.
append
(
"
sessionstore
.
js
"
)
;
this
.
_sessionFileBackup
.
append
(
"
sessionstore
.
bak
"
)
;
this
.
_sessionFilePrevious
.
append
(
"
sessionstore
.
old
"
)
;
this
.
_sessionFileTemp
.
append
(
this
.
_sessionFile
.
leafName
+
"
.
tmp
"
)
;
this
.
_loadState
=
STATE_STOPPED
;
this
.
_startupRestoreFinished
=
false
;
this
.
_interval
=
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
interval
"
)
;
this
.
_backupInterval
=
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
backupInterval
"
)
;
this
.
_updateMaxTabsUndo
(
)
;
Services
.
prefs
.
addObserver
(
PREFS_MAX_TABS_UNDO
(
)
=
>
{
this
.
_updateMaxTabsUndo
(
)
;
}
false
)
;
Services
.
prefs
.
addObserver
(
PREFS_RESTORE_FROM_CRASH
function
(
)
{
SharedPreferences
.
forApp
(
)
.
setBoolPref
(
PREFS_RESTORE_FROM_CRASH
Services
.
prefs
.
getBoolPref
(
PREFS_RESTORE_FROM_CRASH
)
)
;
}
false
)
;
Services
.
prefs
.
addObserver
(
PREFS_MAX_CRASH_RESUMES
function
(
)
{
SharedPreferences
.
forApp
(
)
.
setIntPref
(
PREFS_MAX_CRASH_RESUMES
Services
.
prefs
.
getIntPref
(
PREFS_MAX_CRASH_RESUMES
)
)
;
}
false
)
;
}
_updateMaxTabsUndo
:
function
ss_updateMaxTabsUndo
(
)
{
this
.
_maxTabsUndo
=
Services
.
prefs
.
getIntPref
(
PREFS_MAX_TABS_UNDO
)
;
if
(
this
.
_maxTabsUndo
=
=
0
)
{
this
.
_forgetClosedTabs
(
)
;
}
}
_clearDisk
:
function
ss_clearDisk
(
)
{
this
.
_sessionDataIsGood
=
false
;
this
.
_lastBackupTime
=
0
;
if
(
this
.
_loadState
>
STATE_QUITTING
)
{
OS
.
File
.
remove
(
this
.
_sessionFile
.
path
)
;
OS
.
File
.
remove
(
this
.
_sessionFileBackup
.
path
)
;
OS
.
File
.
remove
(
this
.
_sessionFilePrevious
.
path
)
;
OS
.
File
.
remove
(
this
.
_sessionFileTemp
.
path
)
;
}
else
{
if
(
this
.
_sessionFile
.
exists
(
)
)
{
this
.
_sessionFile
.
remove
(
false
)
;
}
if
(
this
.
_sessionFileBackup
.
exists
(
)
)
{
this
.
_sessionFileBackup
.
remove
(
false
)
;
}
if
(
this
.
_sessionFilePrevious
.
exists
(
)
)
{
this
.
_sessionFilePrevious
.
remove
(
false
)
;
}
if
(
this
.
_sessionFileTemp
.
exists
(
)
)
{
this
.
_sessionFileTemp
.
remove
(
false
)
;
}
}
}
_forgetClosedTabs
:
function
ss_forgetClosedTabs
(
)
{
for
(
let
[
ssid
win
]
of
Object
.
entries
(
this
.
_windows
)
)
{
win
.
closedTabs
=
[
]
;
}
this
.
_lastClosedTabIndex
=
-
1
;
}
onEvent
:
function
ss_onEvent
(
event
data
callback
)
{
switch
(
event
)
{
case
"
ClosedTabs
:
StartNotifications
"
:
this
.
_notifyClosedTabs
=
true
;
log
(
"
ClosedTabs
:
StartNotifications
"
)
;
this
.
_sendClosedTabsToJava
(
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
)
;
break
;
case
"
ClosedTabs
:
StopNotifications
"
:
this
.
_notifyClosedTabs
=
false
;
log
(
"
ClosedTabs
:
StopNotifications
"
)
;
break
;
case
"
Session
:
Restore
"
:
{
EventDispatcher
.
instance
.
unregisterListener
(
this
"
Session
:
Restore
"
)
;
if
(
data
)
{
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
restoreCleanup
=
(
function
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
restoreCleanup
"
sessionstore
-
windows
-
restored
"
)
;
if
(
window
.
BrowserApp
.
tabs
.
length
=
=
0
)
{
window
.
BrowserApp
.
addTab
(
"
about
:
home
"
{
selected
:
true
}
)
;
}
this
.
_startupRestoreFinished
=
true
;
log
(
"
startupRestoreFinished
=
true
(
through
notification
)
"
)
;
}
)
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
restoreCleanup
"
sessionstore
-
windows
-
restored
"
false
)
;
this
.
restoreLastSession
(
data
.
sessionString
)
;
}
else
{
this
.
_startupRestoreFinished
=
true
;
log
(
"
startupRestoreFinished
=
true
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
"
"
)
;
}
break
;
}
case
"
Session
:
RestoreRecentTabs
"
:
this
.
_restoreTabs
(
data
)
;
break
;
case
"
Tab
:
KeepZombified
"
:
{
if
(
data
.
nextSelectedTabId
>
=
0
)
{
this
.
_keepAsZombieTabId
=
data
.
nextSelectedTabId
;
log
(
"
Tab
:
KeepZombified
"
+
data
.
nextSelectedTabId
)
;
}
break
;
}
case
"
Tabs
:
OpenMultiple
"
:
{
this
.
_openTabs
(
data
)
;
if
(
data
.
shouldNotifyTabsOpenedToJava
)
{
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
window
.
WindowEventDispatcher
.
sendRequest
(
{
type
:
"
Tabs
:
TabsOpened
"
}
)
;
}
break
;
}
}
}
observe
:
function
ss_observe
(
aSubject
aTopic
aData
)
{
let
observerService
=
Services
.
obs
;
switch
(
aTopic
)
{
case
"
app
-
startup
"
:
EventDispatcher
.
instance
.
registerListener
(
this
[
"
ClosedTabs
:
StartNotifications
"
"
ClosedTabs
:
StopNotifications
"
"
Session
:
Restore
"
"
Session
:
RestoreRecentTabs
"
"
Tab
:
KeepZombified
"
"
Tabs
:
OpenMultiple
"
]
)
;
observerService
.
addObserver
(
this
"
final
-
ui
-
startup
"
true
)
;
observerService
.
addObserver
(
this
"
domwindowopened
"
true
)
;
observerService
.
addObserver
(
this
"
domwindowclosed
"
true
)
;
observerService
.
addObserver
(
this
"
browser
:
purge
-
session
-
history
"
true
)
;
observerService
.
addObserver
(
this
"
browser
:
purge
-
session
-
tabs
"
true
)
;
observerService
.
addObserver
(
this
"
quit
-
application
-
requested
"
true
)
;
observerService
.
addObserver
(
this
"
quit
-
application
-
proceeding
"
true
)
;
observerService
.
addObserver
(
this
"
quit
-
application
"
true
)
;
observerService
.
addObserver
(
this
"
Session
:
NotifyLocationChange
"
true
)
;
observerService
.
addObserver
(
this
"
Content
:
HistoryChange
"
true
)
;
observerService
.
addObserver
(
this
"
application
-
background
"
true
)
;
observerService
.
addObserver
(
this
"
application
-
foreground
"
true
)
;
observerService
.
addObserver
(
this
"
last
-
pb
-
context
-
exited
"
true
)
;
break
;
case
"
final
-
ui
-
startup
"
:
observerService
.
removeObserver
(
this
"
final
-
ui
-
startup
"
)
;
this
.
init
(
)
;
break
;
case
"
domwindowopened
"
:
{
let
window
=
aSubject
;
window
.
addEventListener
(
"
load
"
(
)
=
>
{
this
.
onWindowOpen
(
window
)
;
}
{
once
:
true
}
)
;
break
;
}
case
"
domwindowclosed
"
:
this
.
onWindowClose
(
aSubject
)
;
break
;
case
"
quit
-
application
-
requested
"
:
log
(
"
quit
-
application
-
requested
"
)
;
if
(
this
.
_pendingWrite
)
{
this
.
_forEachBrowserWindow
(
(
aWindow
)
=
>
{
this
.
_collectWindowData
(
aWindow
)
;
}
)
;
}
break
;
case
"
quit
-
application
-
proceeding
"
:
log
(
"
quit
-
application
-
proceeding
"
)
;
this
.
_loadState
=
STATE_QUITTING
;
break
;
case
"
quit
-
application
"
:
log
(
"
quit
-
application
"
)
;
observerService
.
removeObserver
(
this
"
domwindowopened
"
)
;
observerService
.
removeObserver
(
this
"
domwindowclosed
"
)
;
observerService
.
removeObserver
(
this
"
quit
-
application
-
requested
"
)
;
observerService
.
removeObserver
(
this
"
quit
-
application
-
proceeding
"
)
;
observerService
.
removeObserver
(
this
"
quit
-
application
"
)
;
this
.
flushPendingState
(
)
;
this
.
_loadState
=
STATE_QUITTING_FLUSHED
;
break
;
case
"
browser
:
purge
-
session
-
tabs
"
:
case
"
browser
:
purge
-
session
-
history
"
:
log
(
aTopic
)
;
this
.
_clearDisk
(
)
;
this
.
_forgetClosedTabs
(
)
;
if
(
aTopic
=
=
"
browser
:
purge
-
session
-
history
"
)
{
this
.
_forEachBrowserWindow
(
(
window
)
=
>
{
let
tabs
=
window
.
BrowserApp
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
let
data
=
tabs
[
i
]
.
browser
.
__SS_data
;
let
sHistory
=
data
.
entries
;
sHistory
.
push
(
sHistory
[
data
.
index
-
1
]
)
;
sHistory
.
splice
(
0
sHistory
.
length
-
1
)
;
data
.
index
=
1
;
}
}
)
;
}
if
(
this
.
_loadState
=
=
STATE_RUNNING
)
{
this
.
saveState
(
)
;
}
else
if
(
this
.
_loadState
<
=
STATE_QUITTING
)
{
this
.
saveStateDelayed
(
)
;
if
(
this
.
_loadState
=
=
STATE_QUITTING_FLUSHED
)
{
this
.
flushPendingState
(
)
;
}
}
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
state
-
purge
-
complete
"
"
"
)
;
if
(
this
.
_notifyClosedTabs
)
{
this
.
_sendClosedTabsToJava
(
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
)
;
}
break
;
case
"
timer
-
callback
"
:
if
(
this
.
_loadState
=
=
STATE_RUNNING
)
{
this
.
_saveTimer
=
null
;
log
(
"
timer
-
callback
pendingWrite
=
"
+
this
.
_pendingWrite
)
;
if
(
this
.
_pendingWrite
)
{
this
.
saveState
(
)
;
}
}
break
;
case
"
Session
:
NotifyLocationChange
"
:
{
let
browser
=
aSubject
;
if
(
browser
.
__SS_restoreReloadPending
&
&
this
.
_startupRestoreFinished
)
{
delete
browser
.
__SS_restoreReloadPending
;
log
(
"
remove
restoreReloadPending
"
)
;
}
if
(
browser
.
__SS_restoreDataOnLocationChange
)
{
delete
browser
.
__SS_restoreDataOnLocationChange
;
this
.
_restoreZoom
(
browser
.
__SS_data
.
scrolldata
browser
)
;
}
break
;
}
case
"
Content
:
HistoryChange
"
:
{
let
browser
=
aSubject
;
let
window
=
browser
.
ownerGlobal
;
log
(
"
Content
:
HistoryChange
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
if
(
!
browser
.
__SS_restore
&
&
!
browser
.
__SS_restoreReloadPending
)
{
if
(
browser
.
__SS_historyChange
)
{
window
.
clearTimeout
(
browser
.
__SS_historyChange
)
;
}
browser
.
__SS_historyChange
=
window
.
setTimeout
(
(
)
=
>
{
delete
browser
.
__SS_historyChange
;
this
.
onTabLoad
(
window
browser
)
;
}
0
)
;
}
break
;
}
case
"
application
-
background
"
:
log
(
"
application
-
background
"
)
;
if
(
this
.
_loadState
=
=
STATE_RUNNING
)
{
this
.
_interval
=
0
;
this
.
_minSaveDelay
=
MINIMUM_SAVE_DELAY_BACKGROUND
;
this
.
flushPendingState
(
)
;
}
break
;
case
"
application
-
foreground
"
:
log
(
"
application
-
foreground
"
)
;
this
.
_interval
=
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
interval
"
)
;
this
.
_minSaveDelay
=
MINIMUM_SAVE_DELAY
;
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
window
)
{
let
tab
=
window
.
BrowserApp
.
selectedTab
;
this
.
restoreZombieTab
(
tab
)
;
}
break
;
case
"
last
-
pb
-
context
-
exited
"
:
for
(
let
window
of
Object
.
values
(
this
.
_windows
)
)
{
window
.
closedTabs
=
window
.
closedTabs
.
filter
(
tab
=
>
!
tab
.
isPrivate
)
;
}
this
.
_lastClosedTabIndex
=
-
1
;
break
;
}
}
handleEvent
:
function
ss_handleEvent
(
aEvent
)
{
let
window
=
aEvent
.
currentTarget
.
ownerGlobal
;
switch
(
aEvent
.
type
)
{
case
"
TabOpen
"
:
{
let
browser
=
aEvent
.
target
;
log
(
"
TabOpen
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabAdd
(
window
browser
)
;
break
;
}
case
"
TabClose
"
:
{
let
browser
=
aEvent
.
target
;
log
(
"
TabClose
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabClose
(
window
browser
aEvent
.
detail
)
;
this
.
onTabRemove
(
window
browser
)
;
break
;
}
case
"
TabPreZombify
"
:
{
let
browser
=
aEvent
.
target
;
log
(
"
TabPreZombify
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabRemove
(
window
browser
true
)
;
break
;
}
case
"
TabPostZombify
"
:
{
let
browser
=
aEvent
.
target
;
log
(
"
TabPostZombify
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabAdd
(
window
browser
true
)
;
break
;
}
case
"
TabSelect
"
:
{
let
browser
=
aEvent
.
target
;
log
(
"
TabSelect
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabSelect
(
window
browser
)
;
break
;
}
case
"
TabMove
"
:
{
let
browser
=
aEvent
.
target
;
log
(
"
TabMove
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabMove
(
)
;
break
;
}
case
"
DOMTitleChanged
"
:
{
let
browser
=
aEvent
.
currentTarget
;
log
(
"
DOMTitleChanged
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabLoad
(
window
browser
)
;
break
;
}
case
"
load
"
:
{
let
browser
=
aEvent
.
currentTarget
;
if
(
browser
.
contentDocument
!
=
=
aEvent
.
originalTarget
)
{
return
;
}
log
(
"
load
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
if
(
browser
.
__SS_restoreDataOnLoad
)
{
delete
browser
.
__SS_restoreDataOnLoad
;
this
.
_restoreTextData
(
browser
.
__SS_data
.
formdata
browser
)
;
}
break
;
}
case
"
pageshow
"
:
case
"
AboutReaderContentReady
"
:
{
let
browser
=
aEvent
.
currentTarget
;
if
(
browser
.
contentDocument
!
=
=
aEvent
.
originalTarget
)
{
return
;
}
if
(
browser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
&
&
!
browser
.
contentDocument
.
body
.
classList
.
contains
(
"
loaded
"
)
)
{
return
;
}
log
(
aEvent
.
type
+
"
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
if
(
browser
.
__SS_restoreDataOnPageshow
)
{
delete
browser
.
__SS_restoreDataOnPageshow
;
this
.
_restoreScrollPosition
(
browser
.
__SS_data
.
scrolldata
browser
)
;
}
else
{
this
.
onTabScroll
(
window
browser
)
;
}
break
;
}
case
"
change
"
:
case
"
input
"
:
case
"
DOMAutoComplete
"
:
{
let
browser
=
aEvent
.
currentTarget
;
log
(
"
TabInput
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
this
.
onTabInput
(
window
browser
)
;
break
;
}
case
"
resize
"
:
case
"
scroll
"
:
{
let
browser
=
aEvent
.
currentTarget
;
if
(
loggingEnabled
)
{
log
(
aEvent
.
type
+
"
for
tab
"
+
window
.
BrowserApp
.
getTabForBrowser
(
browser
)
.
id
)
;
}
if
(
!
this
.
_scrollSavePending
)
{
this
.
_scrollSavePending
=
window
.
setTimeout
(
(
)
=
>
{
this
.
_scrollSavePending
=
null
;
this
.
onTabScroll
(
window
browser
)
;
}
500
)
;
}
break
;
}
}
}
onWindowOpen
:
function
ss_onWindowOpen
(
aWindow
)
{
if
(
aWindow
&
&
aWindow
.
__SSID
&
&
this
.
_windows
[
aWindow
.
__SSID
]
)
{
return
;
}
if
(
aWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
|
|
this
.
_loadState
<
=
STATE_QUITTING
)
{
return
;
}
aWindow
.
__SSID
=
"
window
"
+
Date
.
now
(
)
;
this
.
_windows
[
aWindow
.
__SSID
]
=
{
tabs
:
[
]
selected
:
0
closedTabs
:
[
]
}
;
if
(
this
.
_loadState
=
=
STATE_STOPPED
)
{
this
.
_loadState
=
STATE_RUNNING
;
this
.
_lastSaveTime
=
Date
.
now
(
)
;
}
let
tabs
=
aWindow
.
BrowserApp
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
this
.
onTabAdd
(
aWindow
tabs
[
i
]
.
browser
true
)
;
let
browsers
=
aWindow
.
document
.
getElementById
(
"
browsers
"
)
;
browsers
.
addEventListener
(
"
TabOpen
"
this
true
)
;
browsers
.
addEventListener
(
"
TabClose
"
this
true
)
;
browsers
.
addEventListener
(
"
TabSelect
"
this
true
)
;
browsers
.
addEventListener
(
"
TabMove
"
this
true
)
;
browsers
.
addEventListener
(
"
TabPreZombify
"
this
true
)
;
browsers
.
addEventListener
(
"
TabPostZombify
"
this
true
)
;
}
onWindowClose
:
function
ss_onWindowClose
(
aWindow
)
{
if
(
!
aWindow
.
__SSID
|
|
!
this
.
_windows
[
aWindow
.
__SSID
]
)
{
return
;
}
let
browsers
=
aWindow
.
document
.
getElementById
(
"
browsers
"
)
;
browsers
.
removeEventListener
(
"
TabOpen
"
this
true
)
;
browsers
.
removeEventListener
(
"
TabClose
"
this
true
)
;
browsers
.
removeEventListener
(
"
TabSelect
"
this
true
)
;
browsers
.
removeEventListener
(
"
TabMove
"
this
true
)
;
browsers
.
removeEventListener
(
"
TabPreZombify
"
this
true
)
;
browsers
.
removeEventListener
(
"
TabPostZombify
"
this
true
)
;
if
(
this
.
_loadState
=
=
STATE_RUNNING
)
{
this
.
_collectWindowData
(
aWindow
)
;
delete
this
.
_windows
[
aWindow
.
__SSID
]
;
this
.
saveStateDelayed
(
)
;
}
let
tabs
=
aWindow
.
BrowserApp
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
this
.
onTabRemove
(
aWindow
tabs
[
i
]
.
browser
true
)
;
delete
aWindow
.
__SSID
;
}
onTabAdd
:
function
ss_onTabAdd
(
aWindow
aBrowser
aNoNotification
)
{
aBrowser
.
addEventListener
(
"
DOMTitleChanged
"
this
true
)
;
aBrowser
.
addEventListener
(
"
load
"
this
true
)
;
aBrowser
.
addEventListener
(
"
pageshow
"
this
true
)
;
aBrowser
.
addEventListener
(
"
AboutReaderContentReady
"
this
true
)
;
aBrowser
.
addEventListener
(
"
change
"
this
true
)
;
aBrowser
.
addEventListener
(
"
input
"
this
true
)
;
aBrowser
.
addEventListener
(
"
DOMAutoComplete
"
this
true
)
;
aBrowser
.
addEventListener
(
"
scroll
"
this
true
)
;
aBrowser
.
addEventListener
(
"
resize
"
this
true
)
;
log
(
"
onTabAdd
(
)
ran
for
tab
"
+
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
.
id
+
"
aNoNotification
=
"
+
aNoNotification
)
;
if
(
!
aNoNotification
)
{
if
(
this
.
_loadState
=
=
STATE_QUITTING
)
{
this
.
_forEachBrowserWindow
(
(
aWindow
)
=
>
{
this
.
_collectWindowData
(
aWindow
)
;
}
)
;
}
this
.
saveStateDelayed
(
)
;
}
this
.
_updateCrashReportURL
(
aWindow
)
;
}
onTabRemove
:
function
ss_onTabRemove
(
aWindow
aBrowser
aNoNotification
)
{
aBrowser
.
removeEventListener
(
"
DOMTitleChanged
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
load
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
pageshow
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
AboutReaderContentReady
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
change
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
input
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
DOMAutoComplete
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
scroll
"
this
true
)
;
aBrowser
.
removeEventListener
(
"
resize
"
this
true
)
;
if
(
aBrowser
.
__SS_historyChange
)
{
aWindow
.
clearTimeout
(
aBrowser
.
__SS_historyChange
)
;
delete
aBrowser
.
__SS_historyChange
;
}
delete
aBrowser
.
__SS_data
;
log
(
"
onTabRemove
(
)
ran
for
tab
"
+
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
.
id
+
"
aNoNotification
=
"
+
aNoNotification
)
;
if
(
!
aNoNotification
)
{
this
.
saveStateDelayed
(
)
;
}
}
onTabClose
:
function
ss_onTabClose
(
aWindow
aBrowser
aTabIndex
)
{
let
data
=
aBrowser
.
__SS_data
|
|
{
}
;
if
(
this
.
_maxTabsUndo
=
=
0
|
|
this
.
_sessionDataIsEmpty
(
data
)
)
{
this
.
_lastClosedTabIndex
=
-
1
;
return
;
}
if
(
aWindow
.
BrowserApp
.
tabs
.
length
>
0
)
{
data
.
extData
=
aBrowser
.
__SS_extdata
|
|
{
}
;
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
.
unshift
(
data
)
;
let
length
=
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
.
length
;
if
(
length
>
this
.
_maxTabsUndo
)
{
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
.
splice
(
this
.
_maxTabsUndo
length
-
this
.
_maxTabsUndo
)
;
}
this
.
_lastClosedTabIndex
=
aTabIndex
;
if
(
this
.
_notifyClosedTabs
)
{
this
.
_sendClosedTabsToJava
(
aWindow
)
;
}
log
(
"
onTabClose
(
)
ran
for
tab
"
+
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
.
id
)
;
let
evt
=
new
Event
(
"
SSTabCloseProcessed
"
{
"
bubbles
"
:
true
"
cancelable
"
:
false
}
)
;
aBrowser
.
dispatchEvent
(
evt
)
;
}
}
_sessionDataIsEmpty
:
function
ss_sessionDataIsEmpty
(
aData
)
{
if
(
!
aData
|
|
!
aData
.
entries
|
|
aData
.
entries
.
length
=
=
0
)
{
return
true
;
}
let
entries
=
aData
.
entries
;
return
(
entries
.
length
=
=
1
&
&
(
entries
[
0
]
.
url
=
=
"
about
:
home
"
|
|
entries
[
0
]
.
url
=
=
"
about
:
privatebrowsing
"
)
)
;
}
onTabLoad
:
function
ss_onTabLoad
(
aWindow
aBrowser
)
{
if
(
aBrowser
.
__SS_restore
|
|
!
this
.
_startupRestoreFinished
|
|
aBrowser
.
__SS_restoreReloadPending
)
{
return
;
}
if
(
!
aBrowser
.
canGoBack
&
&
aBrowser
.
currentURI
.
spec
=
=
"
about
:
blank
"
)
{
return
;
}
let
data
=
SessionHistory
.
collect
(
aBrowser
.
docShell
)
;
if
(
!
data
.
index
)
{
return
;
}
let
historyIndex
=
data
.
index
-
1
;
for
(
let
i
=
0
;
i
<
data
.
entries
.
length
;
i
+
+
)
{
if
(
data
.
entries
[
i
]
.
url
.
startsWith
(
"
wyciwyg
"
)
)
{
if
(
i
<
=
historyIndex
)
{
data
.
index
-
-
;
historyIndex
-
-
;
}
data
.
entries
.
splice
(
i
1
)
;
i
-
-
;
}
}
let
formdata
;
let
scrolldata
;
if
(
aBrowser
.
__SS_data
)
{
formdata
=
aBrowser
.
__SS_data
.
formdata
;
scrolldata
=
aBrowser
.
__SS_data
.
scrolldata
;
}
delete
aBrowser
.
__SS_data
;
this
.
_collectTabData
(
aWindow
aBrowser
data
)
;
if
(
aBrowser
.
__SS_restoreDataOnLoad
|
|
aBrowser
.
__SS_restoreDataOnPageshow
)
{
aBrowser
.
__SS_data
.
formdata
=
formdata
;
aBrowser
.
__SS_data
.
scrolldata
=
scrolldata
;
}
else
{
this
.
onTabInput
(
aWindow
aBrowser
)
;
this
.
onTabScroll
(
aWindow
aBrowser
)
;
}
log
(
"
onTabLoad
(
)
ran
for
tab
"
+
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
.
id
)
;
let
evt
=
new
Event
(
"
SSTabDataUpdated
"
{
"
bubbles
"
:
true
"
cancelable
"
:
false
}
)
;
aBrowser
.
dispatchEvent
(
evt
)
;
this
.
saveStateDelayed
(
)
;
this
.
_updateCrashReportURL
(
aWindow
)
;
}
onTabSelect
:
function
ss_onTabSelect
(
aWindow
aBrowser
)
{
if
(
this
.
_loadState
!
=
STATE_RUNNING
)
{
return
;
}
let
index
=
aWindow
.
BrowserApp
.
selectedTabIndex
;
this
.
_windows
[
aWindow
.
__SSID
]
.
selected
=
parseInt
(
index
)
+
1
;
let
tab
=
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
;
let
tabId
=
tab
.
id
;
if
(
tabId
!
=
this
.
_keepAsZombieTabId
)
{
this
.
restoreZombieTab
(
tab
)
;
}
else
{
log
(
"
keeping
as
zombie
tab
"
+
tabId
)
;
}
this
.
_keepAsZombieTabId
=
-
1
;
log
(
"
onTabSelect
(
)
ran
for
tab
"
+
tabId
)
;
this
.
saveStateDelayed
(
)
;
this
.
_updateCrashReportURL
(
aWindow
)
;
if
(
this
.
_notifyClosedTabs
)
{
this
.
_sendClosedTabsToJava
(
aWindow
)
;
}
}
restoreZombieTab
:
function
ss_restoreZombieTab
(
aTab
)
{
if
(
!
aTab
.
browser
.
__SS_restore
)
{
return
;
}
let
browser
=
aTab
.
browser
;
let
data
=
browser
.
__SS_data
;
this
.
_restoreTab
(
data
browser
)
;
delete
browser
.
__SS_restore
;
browser
.
removeAttribute
(
"
pending
"
)
;
log
(
"
restoring
zombie
tab
"
+
aTab
.
id
)
;
}
onTabMove
:
function
ss_onTabMove
(
)
{
if
(
this
.
_loadState
!
=
STATE_RUNNING
)
{
return
;
}
this
.
_lastClosedTabIndex
=
-
1
;
this
.
saveStateDelayed
(
)
;
}
onTabInput
:
function
ss_onTabInput
(
aWindow
aBrowser
)
{
if
(
aBrowser
.
__SS_restore
|
|
!
this
.
_startupRestoreFinished
|
|
aBrowser
.
__SS_restoreReloadPending
)
{
return
;
}
let
data
=
aBrowser
.
__SS_data
;
if
(
!
data
|
|
data
.
entries
.
length
=
=
0
)
{
return
;
}
let
content
=
aBrowser
.
contentWindow
;
if
(
!
PrivacyLevel
.
check
(
content
.
document
.
documentURI
)
)
{
return
;
}
let
formdata
=
FormData
.
collect
(
content
)
|
|
{
}
;
let
children
=
[
]
;
for
(
let
i
=
0
;
i
<
content
.
frames
.
length
;
i
+
+
)
{
let
frame
=
content
.
frames
[
i
]
;
if
(
!
PrivacyLevel
.
check
(
frame
.
document
.
documentURI
)
)
{
continue
;
}
let
result
=
FormData
.
collect
(
frame
)
;
if
(
result
&
&
Object
.
keys
(
result
)
.
length
)
{
children
[
i
]
=
result
;
}
}
if
(
children
.
length
)
{
formdata
.
children
=
children
;
}
if
(
Object
.
keys
(
formdata
)
.
length
)
{
data
.
formdata
=
formdata
;
log
(
"
onTabInput
(
)
ran
for
tab
"
+
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
.
id
)
;
this
.
saveStateDelayed
(
)
;
}
}
onTabScroll
:
function
ss_onTabScroll
(
aWindow
aBrowser
)
{
if
(
this
.
_scrollSavePending
)
{
aWindow
.
clearTimeout
(
this
.
_scrollSavePending
)
;
this
.
_scrollSavePending
=
null
;
log
(
"
onTabScroll
(
)
clearing
pending
timeout
"
)
;
}
if
(
aBrowser
.
__SS_restore
|
|
!
this
.
_startupRestoreFinished
|
|
aBrowser
.
__SS_restoreReloadPending
)
{
return
;
}
let
data
=
aBrowser
.
__SS_data
;
if
(
!
data
|
|
data
.
entries
.
length
=
=
0
)
{
return
;
}
if
(
aBrowser
.
__SS_restoreDataOnLoad
|
|
aBrowser
.
__SS_restoreDataOnPageshow
)
{
return
;
}
let
content
=
aBrowser
.
contentWindow
;
let
scrolldata
=
ScrollPosition
.
collect
(
content
)
|
|
{
}
;
let
children
=
[
]
;
for
(
let
i
=
0
;
i
<
content
.
frames
.
length
;
i
+
+
)
{
let
frame
=
content
.
frames
[
i
]
;
let
result
=
ScrollPosition
.
collect
(
frame
)
;
if
(
result
&
&
Object
.
keys
(
result
)
.
length
)
{
children
[
i
]
=
result
;
}
}
if
(
children
.
length
)
{
scrolldata
.
children
=
children
;
}
let
zoom
=
{
value
:
1
}
;
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
getResolution
(
zoom
)
;
scrolldata
.
zoom
=
{
}
;
scrolldata
.
zoom
.
resolution
=
zoom
.
value
;
log
(
"
onTabScroll
(
)
zoom
level
:
"
+
zoom
.
value
)
;
scrolldata
.
zoom
.
displaySize
=
this
.
_getContentViewerSize
(
content
)
;
log
(
"
onTabScroll
(
)
displayWidth
:
"
+
scrolldata
.
zoom
.
displaySize
.
width
)
;
data
.
scrolldata
=
scrolldata
;
log
(
"
onTabScroll
(
)
ran
for
tab
"
+
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
.
id
)
;
let
evt
=
new
Event
(
"
SSTabScrollCaptured
"
{
"
bubbles
"
:
true
"
cancelable
"
:
false
}
)
;
aBrowser
.
dispatchEvent
(
evt
)
;
this
.
saveStateDelayed
(
)
;
}
_getContentViewerSize
:
function
ss_getContentViewerSize
(
aWindow
)
{
let
displaySize
=
{
}
;
let
width
=
{
}
height
=
{
}
;
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
getContentViewerSize
(
width
height
)
;
displaySize
.
width
=
width
.
value
;
displaySize
.
height
=
height
.
value
;
return
displaySize
;
}
saveStateDelayed
:
function
ss_saveStateDelayed
(
)
{
if
(
!
this
.
_saveTimer
)
{
let
currentDelay
=
this
.
_lastSaveTime
+
this
.
_interval
-
Date
.
now
(
)
;
let
delay
=
Math
.
max
(
currentDelay
this
.
_minSaveDelay
)
;
if
(
delay
>
0
)
{
this
.
_pendingWrite
+
+
;
this
.
_saveTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_saveTimer
.
init
(
this
delay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
log
(
"
saveStateDelayed
(
)
timer
delay
=
"
+
delay
+
"
incrementing
_pendingWrite
to
"
+
this
.
_pendingWrite
)
;
}
else
{
log
(
"
saveStateDelayed
(
)
no
delay
"
)
;
this
.
saveState
(
)
;
}
}
else
{
log
(
"
saveStateDelayed
(
)
timer
already
running
taking
no
action
"
)
;
}
}
saveState
:
function
ss_saveState
(
)
{
this
.
_pendingWrite
+
+
;
log
(
"
saveState
(
)
incrementing
_pendingWrite
to
"
+
this
.
_pendingWrite
)
;
this
.
_saveState
(
true
)
;
}
flushPendingState
:
function
ss_flushPendingState
(
)
{
log
(
"
flushPendingState
(
)
_pendingWrite
=
"
+
this
.
_pendingWrite
)
;
if
(
this
.
_pendingWrite
)
{
this
.
_saveState
(
false
)
;
}
}
_saveState
:
function
ss_saveState
(
aAsync
)
{
log
(
"
_saveState
(
aAsync
=
"
+
aAsync
+
"
)
"
)
;
if
(
this
.
_saveTimer
)
{
this
.
_saveTimer
.
cancel
(
)
;
this
.
_saveTimer
=
null
;
log
(
"
_saveState
(
)
killed
queued
timer
"
)
;
}
if
(
!
this
.
_writeInProgress
&
&
Date
.
now
(
)
-
this
.
_lastBackupTime
>
this
.
_backupInterval
&
&
this
.
_sessionDataIsGood
&
&
this
.
_sessionFile
.
exists
(
)
)
{
if
(
this
.
_sessionFileBackup
.
exists
(
)
)
{
this
.
_sessionFileBackup
.
remove
(
false
)
;
}
log
(
"
_saveState
(
)
backing
up
session
data
"
)
;
this
.
_sessionFile
.
copyTo
(
null
this
.
_sessionFileBackup
.
leafName
)
;
this
.
_lastBackupTime
=
Date
.
now
(
)
;
}
let
data
=
this
.
_getCurrentState
(
)
;
let
normalData
=
{
windows
:
[
]
}
;
let
privateData
=
{
windows
:
[
]
}
;
log
(
"
_saveState
(
)
current
state
collected
"
)
;
for
(
let
winIndex
=
0
;
winIndex
<
data
.
windows
.
length
;
+
+
winIndex
)
{
let
win
=
data
.
windows
[
winIndex
]
;
let
normalWin
=
{
}
;
for
(
let
prop
in
win
)
{
normalWin
[
prop
]
=
data
[
prop
]
;
}
normalWin
.
tabs
=
[
]
;
normalWin
.
closedTabs
=
win
.
closedTabs
.
filter
(
tab
=
>
!
tab
.
isPrivate
)
;
normalData
.
windows
.
push
(
normalWin
)
;
privateData
.
windows
.
push
(
{
tabs
:
[
]
}
)
;
for
(
let
i
=
0
;
i
<
win
.
tabs
.
length
;
+
+
i
)
{
let
tab
=
win
.
tabs
[
i
]
;
let
savedWin
=
tab
.
isPrivate
?
privateData
.
windows
[
winIndex
]
:
normalData
.
windows
[
winIndex
]
;
savedWin
.
tabs
.
push
(
tab
)
;
if
(
win
.
selected
=
=
i
+
1
)
{
savedWin
.
selected
=
savedWin
.
tabs
.
length
;
}
}
}
if
(
normalData
.
windows
[
0
]
&
&
normalData
.
windows
[
0
]
.
tabs
)
{
log
(
"
_saveState
(
)
writing
normal
data
"
+
normalData
.
windows
[
0
]
.
tabs
.
length
+
"
tabs
in
window
[
0
]
"
)
;
}
else
{
log
(
"
_saveState
(
)
writing
empty
normal
data
"
)
;
}
this
.
_writeFile
(
this
.
_sessionFile
this
.
_sessionFileTemp
normalData
aAsync
)
;
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
window
)
{
window
.
WindowEventDispatcher
.
sendRequest
(
{
type
:
"
PrivateBrowsing
:
Data
"
session
:
(
privateData
.
windows
.
length
>
0
&
&
privateData
.
windows
[
0
]
.
tabs
.
length
>
0
)
?
JSON
.
stringify
(
privateData
)
:
null
}
)
;
}
this
.
_lastSaveTime
=
Date
.
now
(
)
;
}
_getCurrentState
:
function
ss_getCurrentState
(
)
{
this
.
_forEachBrowserWindow
(
(
aWindow
)
=
>
{
this
.
_collectWindowData
(
aWindow
)
;
}
)
;
let
data
=
{
windows
:
[
]
}
;
for
(
let
index
in
this
.
_windows
)
{
data
.
windows
.
push
(
this
.
_windows
[
index
]
)
;
}
return
data
;
}
_collectTabData
:
function
ss__collectTabData
(
aWindow
aBrowser
aHistory
)
{
if
(
aBrowser
.
__SS_restore
)
{
return
;
}
let
tabData
=
{
}
;
let
tab
=
aWindow
.
BrowserApp
.
getTabForBrowser
(
aBrowser
)
;
tabData
.
entries
=
aHistory
.
entries
;
tabData
.
index
=
aHistory
.
index
;
tabData
.
attributes
=
{
image
:
aBrowser
.
mIconURL
}
;
tabData
.
desktopMode
=
tab
.
desktopMode
;
tabData
.
isPrivate
=
aBrowser
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
usePrivateBrowsing
;
tabData
.
tabId
=
tab
.
id
;
tabData
.
parentId
=
tab
.
parentId
;
tabData
.
type
=
tab
.
type
;
aBrowser
.
__SS_data
=
tabData
;
}
_collectWindowData
:
function
ss__collectWindowData
(
aWindow
)
{
if
(
!
aWindow
.
__SSID
|
|
!
this
.
_windows
[
aWindow
.
__SSID
]
)
{
return
;
}
let
winData
=
this
.
_windows
[
aWindow
.
__SSID
]
;
winData
.
tabs
=
[
]
;
let
index
=
aWindow
.
BrowserApp
.
selectedTabIndex
;
winData
.
selected
=
parseInt
(
index
)
+
1
;
let
tabs
=
aWindow
.
BrowserApp
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
let
browser
=
tabs
[
i
]
.
browser
;
if
(
browser
.
__SS_data
)
{
let
tabData
=
browser
.
__SS_data
;
if
(
browser
.
__SS_extdata
)
{
tabData
.
extData
=
browser
.
__SS_extdata
;
}
winData
.
tabs
.
push
(
tabData
)
;
}
}
}
_forEachBrowserWindow
:
function
ss_forEachBrowserWindow
(
aFunc
)
{
let
windowsEnum
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windowsEnum
.
hasMoreElements
(
)
)
{
let
window
=
windowsEnum
.
getNext
(
)
;
if
(
window
.
__SSID
&
&
!
window
.
closed
)
{
aFunc
.
call
(
this
window
)
;
}
}
}
_writeFile
:
function
ss_writeFile
(
aFile
aFileTemp
aData
aAsync
)
{
TelemetryStopwatch
.
start
(
"
FX_SESSION_RESTORE_SERIALIZE_DATA_MS
"
)
;
let
state
=
JSON
.
stringify
(
aData
)
;
TelemetryStopwatch
.
finish
(
"
FX_SESSION_RESTORE_SERIALIZE_DATA_MS
"
)
;
let
buffer
=
new
TextEncoder
(
)
.
encode
(
state
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_FILE_SIZE_BYTES
"
)
.
add
(
buffer
.
byteLength
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
state
-
write
"
"
"
)
;
let
startWriteMs
=
Cu
.
now
(
)
;
log
(
"
_writeFile
(
aAsync
=
"
+
aAsync
+
"
)
_pendingWrite
=
"
+
this
.
_pendingWrite
)
;
this
.
_writeInProgress
=
true
;
let
pendingWrite
=
this
.
_pendingWrite
;
this
.
_write
(
aFile
aFileTemp
buffer
aAsync
)
.
then
(
(
)
=
>
{
let
stopWriteMs
=
Cu
.
now
(
)
;
if
(
pendingWrite
=
=
=
this
.
_pendingWrite
)
{
this
.
_pendingWrite
=
0
;
this
.
_writeInProgress
=
false
;
}
log
(
"
_writeFile
(
)
_write
(
)
returned
_pendingWrite
=
"
+
this
.
_pendingWrite
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_SESSION_RESTORE_WRITE_FILE_MS
"
)
.
add
(
Math
.
round
(
stopWriteMs
-
startWriteMs
)
)
;
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
state
-
write
-
complete
"
"
"
)
;
this
.
_sessionDataIsGood
=
true
;
}
)
;
}
_write
:
function
ss_write
(
aFile
aFileTemp
aBuffer
aAsync
)
{
if
(
aAsync
)
{
log
(
"
_write
(
)
writing
asynchronously
"
)
;
return
OS
.
File
.
writeAtomic
(
aFile
.
path
aBuffer
{
tmpPath
:
aFileTemp
.
path
}
)
;
}
let
bytes
=
String
.
fromCharCode
.
apply
(
null
new
Uint16Array
(
aBuffer
)
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
stream
.
init
(
aFileTemp
0x02
|
0x08
|
0x20
0o666
0
)
;
stream
.
write
(
bytes
bytes
.
length
)
;
stream
.
close
(
)
;
aFileTemp
.
renameTo
(
null
aFile
.
leafName
)
;
log
(
"
_write
(
)
writing
synchronously
"
)
;
return
Promise
.
resolve
(
)
;
}
_updateCrashReportURL
:
function
ss_updateCrashReportURL
(
aWindow
)
{
let
crashReporterBuilt
=
"
nsICrashReporter
"
in
Ci
&
&
Services
.
appinfo
instanceof
Ci
.
nsICrashReporter
;
if
(
!
crashReporterBuilt
)
{
return
;
}
if
(
!
aWindow
.
BrowserApp
.
selectedBrowser
)
{
return
;
}
try
{
let
currentURI
=
aWindow
.
BrowserApp
.
selectedBrowser
.
currentURI
.
clone
(
)
;
try
{
currentURI
.
userPass
=
"
"
;
}
catch
(
ex
)
{
}
Services
.
appinfo
.
annotateCrashReport
(
"
URL
"
currentURI
.
spec
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
{
Cu
.
reportError
(
"
SessionStore
:
"
+
ex
)
;
}
}
}
_openTabs
:
function
ss_openTabs
(
aData
)
{
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
for
(
let
i
=
0
;
i
<
aData
.
urls
.
length
;
i
+
+
)
{
let
url
=
aData
.
urls
[
i
]
;
let
params
=
{
selected
:
(
i
=
=
aData
.
urls
.
length
-
1
)
isPrivate
:
false
desktopMode
:
false
}
;
let
tab
=
window
.
BrowserApp
.
addTab
(
url
params
)
;
}
}
_restoreTabs
:
function
ss_restoreTabs
(
aData
)
{
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
for
(
let
i
=
0
;
i
<
aData
.
tabs
.
length
;
i
+
+
)
{
let
tabData
=
JSON
.
parse
(
aData
.
tabs
[
i
]
)
;
let
isSelectedTab
=
(
i
=
=
aData
.
tabs
.
length
-
1
)
;
let
params
=
{
selected
:
isSelectedTab
isPrivate
:
tabData
.
isPrivate
desktopMode
:
tabData
.
desktopMode
cancelEditMode
:
isSelectedTab
parentId
:
tabData
.
parentId
}
;
let
tab
=
window
.
BrowserApp
.
addTab
(
tabData
.
entries
[
tabData
.
index
-
1
]
.
url
params
)
;
tab
.
browser
.
__SS_data
=
tabData
;
tab
.
browser
.
__SS_extdata
=
tabData
.
extData
;
this
.
_restoreTab
(
tabData
tab
.
browser
)
;
}
}
_restoreTab
:
function
ss_restoreTab
(
aTabData
aBrowser
)
{
if
(
!
aTabData
|
|
aTabData
.
entries
.
length
=
=
0
)
{
Cu
.
reportError
(
"
SessionStore
.
js
:
Error
trying
to
restore
tab
with
empty
tabdata
"
)
;
return
;
}
this
.
_restoreHistory
(
aBrowser
.
docShell
aTabData
)
;
aBrowser
.
__SS_restoreDataOnLocationChange
=
true
;
aBrowser
.
__SS_restoreDataOnLoad
=
true
;
aBrowser
.
__SS_restoreDataOnPageshow
=
true
;
}
_restoreHistory
:
function
ss_restoreHistory
(
aDocShell
aTabData
)
{
let
history
=
SessionHistory
.
restore
(
aDocShell
aTabData
)
;
try
{
history
.
QueryInterface
(
Ci
.
nsISHistory
)
.
reloadCurrentEntry
(
)
;
}
catch
(
e
)
{
}
}
_restoreTextData
:
function
ss_restoreTextData
(
aFormData
aBrowser
)
{
if
(
aFormData
)
{
log
(
"
_restoreTextData
(
)
"
)
;
FormData
.
restoreTree
(
aBrowser
.
contentWindow
aFormData
)
;
}
}
_restoreZoom
:
function
ss_restoreZoom
(
aScrollData
aBrowser
)
{
if
(
aScrollData
&
&
aScrollData
.
zoom
&
&
aScrollData
.
zoom
.
displaySize
)
{
log
(
"
_restoreZoom
(
)
resolution
:
"
+
aScrollData
.
zoom
.
resolution
+
"
old
displayWidth
:
"
+
aScrollData
.
zoom
.
displaySize
.
width
)
;
let
utils
=
aBrowser
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
utils
.
setRestoreResolution
(
aScrollData
.
zoom
.
resolution
aScrollData
.
zoom
.
displaySize
.
width
aScrollData
.
zoom
.
displaySize
.
height
)
;
}
}
_restoreScrollPosition
:
function
ss_restoreScrollPosition
(
aScrollData
aBrowser
)
{
if
(
aScrollData
)
{
log
(
"
_restoreScrollPosition
(
)
"
)
;
ScrollPosition
.
restoreTree
(
aBrowser
.
contentWindow
aScrollData
)
;
}
}
getBrowserState
:
function
ss_getBrowserState
(
)
{
return
this
.
_getCurrentState
(
)
;
}
_restoreWindow
:
function
ss_restoreWindow
(
aData
)
{
let
state
;
try
{
state
=
JSON
.
parse
(
aData
)
;
}
catch
(
e
)
{
throw
"
Invalid
session
JSON
:
"
+
aData
;
}
if
(
!
state
|
|
state
.
windows
.
length
=
=
0
|
|
!
state
.
windows
[
0
]
.
tabs
|
|
state
.
windows
[
0
]
.
tabs
.
length
=
=
0
)
{
throw
"
Invalid
session
JSON
:
"
+
aData
;
}
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
tabs
=
state
.
windows
[
0
]
.
tabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
let
tabData
=
tabs
[
i
]
;
let
entry
=
tabData
.
entries
[
tabData
.
index
-
1
]
;
let
tab
=
window
.
BrowserApp
.
getTabForId
(
tabData
.
tabId
)
;
if
(
tab
=
=
null
)
{
delete
tabData
.
tabId
;
continue
;
}
let
parentId
=
tabData
.
parentId
;
if
(
parentId
>
-
1
)
{
tab
.
parentId
=
parentId
;
}
tab
.
browser
.
__SS_data
=
tabData
;
tab
.
browser
.
__SS_extdata
=
tabData
.
extData
;
if
(
window
.
BrowserApp
.
selectedTab
=
=
tab
)
{
tab
.
browser
.
__SS_restoreReloadPending
=
true
;
this
.
_restoreTab
(
tabData
tab
.
browser
)
;
this
.
_startupRestoreFinished
=
true
;
log
(
"
startupRestoreFinished
=
true
"
)
;
delete
tab
.
browser
.
__SS_restore
;
tab
.
browser
.
removeAttribute
(
"
pending
"
)
;
}
else
{
tab
.
browser
.
__SS_restore
=
true
;
tab
.
browser
.
setAttribute
(
"
pending
"
"
true
"
)
;
}
}
if
(
state
.
windows
[
0
]
.
closedTabs
&
&
this
.
_maxTabsUndo
>
0
)
{
this
.
_windows
[
window
.
__SSID
]
.
closedTabs
=
state
.
windows
[
0
]
.
closedTabs
;
log
(
"
_restoreWindow
(
)
loaded
"
+
state
.
windows
[
0
]
.
closedTabs
.
length
+
"
closed
tabs
"
)
;
}
}
getClosedTabCount
:
function
ss_getClosedTabCount
(
aWindow
)
{
if
(
!
aWindow
|
|
!
aWindow
.
__SSID
|
|
!
this
.
_windows
[
aWindow
.
__SSID
]
)
{
return
0
;
}
return
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
.
length
;
}
getClosedTabs
:
function
ss_getClosedTabs
(
aWindow
)
{
if
(
!
aWindow
.
__SSID
)
{
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
;
}
undoCloseTab
:
function
ss_undoCloseTab
(
aWindow
aCloseTabData
)
{
if
(
!
aWindow
.
__SSID
)
{
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
closedTabs
=
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
;
if
(
!
closedTabs
)
{
return
null
;
}
closedTabs
.
find
(
function
(
tabData
i
)
{
if
(
tabData
=
=
aCloseTabData
)
{
closedTabs
.
splice
(
i
1
)
;
return
true
;
}
}
)
;
let
params
=
{
selected
:
true
isPrivate
:
aCloseTabData
.
isPrivate
desktopMode
:
aCloseTabData
.
desktopMode
tabIndex
:
this
.
_lastClosedTabIndex
parentId
:
aCloseTabData
.
parentId
}
;
let
tab
=
aWindow
.
BrowserApp
.
addTab
(
aCloseTabData
.
entries
[
aCloseTabData
.
index
-
1
]
.
url
params
)
;
tab
.
browser
.
__SS_data
=
aCloseTabData
;
tab
.
browser
.
__SS_extdata
=
aCloseTabData
.
extData
;
this
.
_restoreTab
(
aCloseTabData
tab
.
browser
)
;
this
.
_lastClosedTabIndex
=
-
1
;
if
(
this
.
_notifyClosedTabs
)
{
this
.
_sendClosedTabsToJava
(
aWindow
)
;
}
return
tab
.
browser
;
}
forgetClosedTab
:
function
ss_forgetClosedTab
(
aWindow
aIndex
)
{
if
(
!
aWindow
.
__SSID
)
{
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
closedTabs
=
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
;
aIndex
=
aIndex
|
|
0
;
if
(
!
(
aIndex
in
closedTabs
)
)
{
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
closedTabs
.
splice
(
aIndex
1
)
;
if
(
aIndex
=
=
0
)
{
this
.
_lastClosedTabIndex
=
-
1
;
}
if
(
this
.
_notifyClosedTabs
)
{
this
.
_sendClosedTabsToJava
(
aWindow
)
;
}
}
get
canUndoLastCloseTab
(
)
{
return
this
.
_lastClosedTabIndex
>
-
1
;
}
_sendClosedTabsToJava
:
function
ss_sendClosedTabsToJava
(
aWindow
)
{
if
(
this
.
_loadState
<
=
STATE_QUITTING
)
{
return
;
}
if
(
!
aWindow
.
__SSID
)
{
throw
(
Components
.
returnCode
=
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
closedTabs
=
this
.
_windows
[
aWindow
.
__SSID
]
.
closedTabs
;
let
isPrivate
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
aWindow
.
BrowserApp
.
selectedBrowser
)
;
let
tabs
=
closedTabs
.
filter
(
tab
=
>
tab
.
isPrivate
=
=
isPrivate
)
.
map
(
function
(
tab
)
{
let
entry
=
tab
.
entries
[
tab
.
index
-
1
]
;
return
{
url
:
entry
.
url
title
:
entry
.
title
|
|
"
"
data
:
JSON
.
stringify
(
tab
)
}
;
}
)
;
log
(
"
sending
"
+
tabs
.
length
+
"
closed
tabs
to
Java
"
)
;
EventDispatcher
.
instance
.
sendRequest
(
{
type
:
"
ClosedTabs
:
Data
"
tabs
:
tabs
}
)
;
}
getTabValue
:
function
ss_getTabValue
(
aTab
aKey
)
{
let
browser
=
aTab
.
browser
;
let
data
=
browser
.
__SS_extdata
|
|
{
}
;
return
data
[
aKey
]
|
|
"
"
;
}
setTabValue
:
function
ss_setTabValue
(
aTab
aKey
aStringValue
)
{
let
browser
=
aTab
.
browser
;
if
(
!
browser
.
__SS_extdata
)
{
browser
.
__SS_extdata
=
{
}
;
}
browser
.
__SS_extdata
[
aKey
]
=
aStringValue
;
this
.
saveStateDelayed
(
)
;
}
deleteTabValue
:
function
ss_deleteTabValue
(
aTab
aKey
)
{
let
browser
=
aTab
.
browser
;
if
(
browser
.
__SS_extdata
&
&
aKey
in
browser
.
__SS_extdata
)
{
delete
browser
.
__SS_extdata
[
aKey
]
;
this
.
saveStateDelayed
(
)
;
}
}
restoreLastSession
:
Task
.
async
(
function
*
(
aSessionString
)
{
let
notifyMessage
=
"
"
;
try
{
this
.
_restoreWindow
(
aSessionString
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
SessionStore
:
"
+
e
)
;
notifyMessage
=
"
fail
"
;
}
Services
.
obs
.
notifyObservers
(
null
"
sessionstore
-
windows
-
restored
"
notifyMessage
)
;
}
)
removeWindow
:
function
ss_removeWindow
(
aWindow
)
{
if
(
!
aWindow
|
|
!
aWindow
.
__SSID
|
|
!
this
.
_windows
[
aWindow
.
__SSID
]
)
{
return
;
}
delete
this
.
_windows
[
aWindow
.
__SSID
]
;
delete
aWindow
.
__SSID
;
if
(
this
.
_loadState
=
=
STATE_RUNNING
)
{
this
.
saveState
(
)
;
}
else
if
(
this
.
_loadState
<
=
STATE_QUITTING
)
{
this
.
saveStateDelayed
(
)
;
}
}
setLoadState
:
function
ss_setLoadState
(
aState
)
{
this
.
flushPendingState
(
)
;
this
.
_loadState
=
aState
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
SessionStore
]
)
;
