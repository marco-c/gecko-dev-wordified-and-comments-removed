const
APK_MIME_TYPE
=
"
application
/
vnd
.
android
.
package
-
archive
"
;
const
OMA_DOWNLOAD_DESCRIPTOR_MIME_TYPE
=
"
application
/
vnd
.
oma
.
dd
+
xml
"
;
const
OMA_DRM_MESSAGE_MIME
=
"
application
/
vnd
.
oma
.
drm
.
message
"
;
const
OMA_DRM_CONTENT_MIME
=
"
application
/
vnd
.
oma
.
drm
.
content
"
;
const
OMA_DRM_RIGHTS_MIME
=
"
application
/
vnd
.
oma
.
drm
.
rights
+
wbxml
"
;
const
PREF_BD_USEDOWNLOADDIR
=
"
browser
.
download
.
useDownloadDir
"
;
const
URI_GENERIC_ICON_DOWNLOAD
=
"
drawable
:
/
/
alert_download
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
HelperApps
:
"
resource
:
/
/
gre
/
modules
/
HelperApps
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
RuntimePermissions
:
"
resource
:
/
/
gre
/
modules
/
RuntimePermissions
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Snackbars
:
"
resource
:
/
/
gre
/
modules
/
Snackbars
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ContentAreaUtils
"
function
(
)
{
let
ContentAreaUtils
=
{
}
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
global
/
content
/
contentAreaUtils
.
js
"
ContentAreaUtils
)
;
return
ContentAreaUtils
;
}
)
;
function
HelperAppLauncherDialog
(
)
{
}
HelperAppLauncherDialog
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
e9d277a0
-
268a
-
4ec2
-
bb8c
-
10fdf3e44611
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIHelperAppLauncherDialog
]
)
_canDownload
:
function
(
url
alreadyResolved
=
false
)
{
if
(
url
.
schemeIs
(
"
http
"
)
|
|
url
.
schemeIs
(
"
https
"
)
|
|
url
.
schemeIs
(
"
ftp
"
)
)
{
return
true
;
}
if
(
url
.
schemeIs
(
"
chrome
"
)
|
|
url
.
schemeIs
(
"
jar
"
)
|
|
url
.
schemeIs
(
"
resource
"
)
|
|
url
.
schemeIs
(
"
wyciwyg
"
)
|
|
url
.
schemeIs
(
"
file
"
)
)
{
return
false
;
}
if
(
!
alreadyResolved
)
{
let
innerURI
=
NetUtil
.
newChannel
(
{
uri
:
url
loadUsingSystemPrincipal
:
true
}
)
.
URI
;
if
(
!
url
.
equals
(
innerURI
)
)
{
return
this
.
_canDownload
(
innerURI
true
)
;
}
}
return
true
;
}
_shouldPrompt
:
function
(
launcher
)
{
let
mimeType
=
this
.
_getMimeTypeFromLauncher
(
launcher
)
;
return
APK_MIME_TYPE
=
=
mimeType
|
|
OMA_DOWNLOAD_DESCRIPTOR_MIME_TYPE
=
=
mimeType
;
}
_shouldAddSaveToDiskIntent
:
function
(
launcher
)
{
let
mimeType
=
this
.
_getMimeTypeFromLauncher
(
launcher
)
;
return
mimeType
!
=
OMA_DOWNLOAD_DESCRIPTOR_MIME_TYPE
;
}
_shouldForwardToAndroidDownloadManager
:
function
(
aLauncher
)
{
let
forwardDownload
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
forward_oma_android_download_manager
"
)
;
if
(
!
forwardDownload
)
{
return
false
;
}
let
mimeType
=
aLauncher
.
MIMEInfo
.
MIMEType
;
if
(
!
mimeType
)
{
mimeType
=
ContentAreaUtils
.
getMIMETypeForURI
(
aLauncher
.
source
)
|
|
"
"
;
}
return
[
OMA_DOWNLOAD_DESCRIPTOR_MIME_TYPE
OMA_DRM_MESSAGE_MIME
OMA_DRM_CONTENT_MIME
OMA_DRM_RIGHTS_MIME
]
.
includes
(
mimeType
)
;
}
show
:
function
hald_show
(
aLauncher
aContext
aReason
)
{
if
(
!
this
.
_canDownload
(
aLauncher
.
source
)
)
{
this
.
_refuseDownload
(
aLauncher
)
;
return
;
}
if
(
this
.
_shouldForwardToAndroidDownloadManager
(
aLauncher
)
)
{
(
async
(
)
=
>
{
try
{
let
hasPermission
=
await
RuntimePermissions
.
waitForPermissions
(
RuntimePermissions
.
WRITE_EXTERNAL_STORAGE
)
;
if
(
hasPermission
)
{
this
.
_downloadWithAndroidDownloadManager
(
aLauncher
)
;
}
}
finally
{
aLauncher
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
return
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
apps
=
HelperApps
.
getAppsForUri
(
aLauncher
.
source
{
mimeType
:
aLauncher
.
MIMEInfo
.
MIMEType
}
)
;
if
(
this
.
_shouldAddSaveToDiskIntent
(
aLauncher
)
)
{
apps
.
unshift
(
{
name
:
bundle
.
GetStringFromName
(
"
helperapps
.
saveToDisk
"
)
packageName
:
"
org
.
mozilla
.
gecko
.
Download
"
iconUri
:
"
drawable
:
/
/
icon
"
selected
:
true
launch
:
function
(
)
{
aLauncher
.
MIMEInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
saveToDisk
;
aLauncher
.
saveToDisk
(
null
false
)
;
return
true
;
}
}
)
;
}
if
(
apps
.
length
=
=
=
0
)
{
this
.
_refuseDownload
(
aLauncher
)
;
return
;
}
let
callback
=
function
(
app
)
{
aLauncher
.
MIMEInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
useHelperApp
;
if
(
!
app
.
launch
(
aLauncher
.
source
)
)
{
aLauncher
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
}
;
let
preferredApp
=
this
.
_getPreferredApp
(
aLauncher
)
;
if
(
preferredApp
)
{
let
pref
=
apps
.
filter
(
function
(
app
)
{
return
app
.
packageName
=
=
=
preferredApp
;
}
)
;
if
(
pref
.
length
>
0
)
{
callback
(
pref
[
0
]
)
;
return
;
}
}
if
(
!
this
.
_shouldPrompt
(
aLauncher
)
&
&
(
apps
.
length
=
=
=
1
)
)
{
callback
(
apps
[
0
]
)
;
return
;
}
let
alwaysUse
=
bundle
.
GetStringFromName
(
"
helperapps
.
alwaysUse
"
)
;
let
justOnce
=
bundle
.
GetStringFromName
(
"
helperapps
.
useJustOnce
"
)
;
let
newButtonOrder
=
this
.
_useNewButtonOrder
(
)
;
HelperApps
.
prompt
(
apps
{
window
:
aContext
title
:
bundle
.
GetStringFromName
(
"
helperapps
.
pick
"
)
buttons
:
[
newButtonOrder
?
alwaysUse
:
justOnce
newButtonOrder
?
justOnce
:
alwaysUse
]
doubleTapButton
:
newButtonOrder
?
1
:
0
}
(
data
)
=
>
{
if
(
data
.
button
<
0
)
{
aLauncher
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
callback
(
apps
[
data
.
icongrid0
]
)
;
if
(
data
.
button
=
=
=
(
newButtonOrder
?
0
:
1
)
)
{
this
.
_setPreferredApp
(
aLauncher
apps
[
data
.
icongrid0
]
)
;
}
}
)
;
}
_useNewButtonOrder
:
function
(
)
{
return
Services
.
sysinfo
.
getPropertyAsUint32
(
"
version
"
)
>
=
21
;
}
_refuseDownload
:
function
(
aLauncher
)
{
aLauncher
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
Services
.
console
.
logStringMessage
(
"
Refusing
download
of
non
-
downloadable
file
.
"
)
;
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
failedText
=
bundle
.
GetStringFromName
(
"
download
.
blocked
"
)
;
Snackbars
.
show
(
failedText
Snackbars
.
LENGTH_LONG
)
;
}
_downloadWithAndroidDownloadManager
(
aLauncher
)
{
let
mimeType
=
aLauncher
.
MIMEInfo
.
MIMEType
;
if
(
!
mimeType
)
{
mimeType
=
ContentAreaUtils
.
getMIMETypeForURI
(
aLauncher
.
source
)
|
|
"
"
;
}
EventDispatcher
.
instance
.
sendRequest
(
{
"
type
"
:
"
Download
:
AndroidDownloadManager
"
"
uri
"
:
aLauncher
.
source
.
spec
"
mimeType
"
:
mimeType
"
filename
"
:
aLauncher
.
suggestedFileName
}
)
;
}
_getPrefName
:
function
getPrefName
(
mimetype
)
{
return
"
browser
.
download
.
preferred
.
"
+
mimetype
.
replace
(
"
\
\
"
"
.
"
)
;
}
_getMimeTypeFromLauncher
:
function
(
launcher
)
{
let
mime
=
launcher
.
MIMEInfo
.
MIMEType
;
if
(
!
mime
)
mime
=
ContentAreaUtils
.
getMIMETypeForURI
(
launcher
.
source
)
|
|
"
"
;
return
mime
;
}
_getPreferredApp
:
function
getPreferredApp
(
launcher
)
{
let
mime
=
this
.
_getMimeTypeFromLauncher
(
launcher
)
;
if
(
!
mime
)
return
;
try
{
return
Services
.
prefs
.
getCharPref
(
this
.
_getPrefName
(
mime
)
)
;
}
catch
(
ex
)
{
Services
.
console
.
logStringMessage
(
"
Error
getting
pref
for
"
+
mime
+
"
.
"
)
;
}
return
null
;
}
_setPreferredApp
:
function
setPreferredApp
(
launcher
app
)
{
let
mime
=
this
.
_getMimeTypeFromLauncher
(
launcher
)
;
if
(
!
mime
)
return
;
if
(
app
)
Services
.
prefs
.
setCharPref
(
this
.
_getPrefName
(
mime
)
app
.
packageName
)
;
else
Services
.
prefs
.
clearUserPref
(
this
.
_getPrefName
(
mime
)
)
;
}
promptForSaveToFileAsync
:
function
(
aLauncher
aContext
aDefaultFile
aSuggestedFileExt
aForcePrompt
)
{
(
async
(
)
=
>
{
let
file
=
null
;
try
{
let
hasPermission
=
await
RuntimePermissions
.
waitForPermissions
(
RuntimePermissions
.
WRITE_EXTERNAL_STORAGE
)
;
if
(
hasPermission
)
{
let
preferredDir
=
await
Downloads
.
getPreferredDownloadsDirectory
(
)
;
file
=
this
.
validateLeafName
(
new
FileUtils
.
File
(
preferredDir
)
aDefaultFile
aSuggestedFileExt
)
;
}
}
finally
{
aLauncher
.
saveDestinationAvailable
(
file
)
;
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
validateLeafName
:
function
hald_validateLeafName
(
aLocalFile
aLeafName
aFileExt
)
{
if
(
!
(
aLocalFile
&
&
this
.
isUsableDirectory
(
aLocalFile
)
)
)
return
null
;
aLeafName
=
aLeafName
.
replace
(
/
^
\
.
+
/
"
"
)
;
if
(
aLeafName
=
=
"
"
)
aLeafName
=
"
unnamed
"
+
(
aFileExt
?
"
.
"
+
aFileExt
:
"
"
)
;
aLocalFile
.
append
(
aLeafName
)
;
this
.
makeFileUnique
(
aLocalFile
)
;
return
aLocalFile
;
}
makeFileUnique
:
function
hald_makeFileUnique
(
aLocalFile
)
{
try
{
let
collisionCount
=
0
;
while
(
aLocalFile
.
exists
(
)
)
{
collisionCount
+
+
;
if
(
collisionCount
=
=
1
)
{
if
(
aLocalFile
.
leafName
.
match
(
/
\
.
[
^
\
.
]
{
1
3
}
\
.
(
gz
|
bz2
|
Z
)
/
i
)
)
aLocalFile
.
leafName
=
aLocalFile
.
leafName
.
replace
(
/
\
.
[
^
\
.
]
{
1
3
}
\
.
(
gz
|
bz2
|
Z
)
/
i
"
(
2
)
&
"
)
;
else
aLocalFile
.
leafName
=
aLocalFile
.
leafName
.
replace
(
/
(
\
.
[
^
\
.
]
*
)
?
/
"
(
2
)
&
"
)
;
}
else
{
aLocalFile
.
leafName
=
aLocalFile
.
leafName
.
replace
(
/
^
(
.
*
\
(
)
\
d
+
\
)
/
"
1
"
+
(
collisionCount
+
1
)
+
"
)
"
)
;
}
}
aLocalFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o600
)
;
}
catch
(
e
)
{
dump
(
"
*
*
*
exception
in
validateLeafName
:
"
+
e
+
"
\
n
"
)
;
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FILE_ACCESS_DENIED
)
throw
e
;
if
(
aLocalFile
.
leafName
=
=
"
"
|
|
aLocalFile
.
isDirectory
(
)
)
{
aLocalFile
.
append
(
"
unnamed
"
)
;
if
(
aLocalFile
.
exists
(
)
)
aLocalFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o600
)
;
}
}
}
isUsableDirectory
:
function
hald_isUsableDirectory
(
aDirectory
)
{
return
aDirectory
.
exists
(
)
&
&
aDirectory
.
isDirectory
(
)
&
&
aDirectory
.
isWritable
(
)
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
HelperAppLauncherDialog
]
)
;
