from
__future__
import
absolute_import
print_function
unicode_literals
import
argparse
import
logging
import
os
import
mozpack
.
path
as
mozpath
from
mozbuild
.
base
import
(
    
MachCommandBase
    
MachCommandConditions
as
conditions
)
from
mozbuild
.
shellutil
import
(
    
split
as
shell_split
)
from
mach
.
decorators
import
(
    
CommandArgument
    
CommandProvider
    
Command
    
SubCommand
)
def
REMOVED
(
cls
)
:
    
"
"
"
Command
no
longer
exists
!
Use
the
Gradle
configuration
rooted
in
the
top
source
directory
instead
.
    
See
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Simple_Firefox_for_Android_build
#
Developing_Firefox_for_Android_in_Android_Studio_or_IDEA_IntelliJ
.
    
"
"
"
    
return
False
CommandProvider
class
MachCommands
(
MachCommandBase
)
:
    
Command
(
'
android
'
category
=
'
devenv
'
        
description
=
'
Run
Android
-
specific
commands
.
'
        
conditions
=
[
conditions
.
is_android
]
)
    
def
android
(
self
)
:
        
pass
    
SubCommand
(
'
android
'
'
test
'
        
"
"
"
Run
Android
local
unit
tests
.
        
See
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Mozilla
/
Android
-
specific_test_suites
#
android
-
test
"
"
"
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
android_test
(
self
args
)
:
        
gradle_targets
=
[
            
'
app
:
testOfficialPhotonDebugUnitTest
'
        
]
        
ret
=
self
.
gradle
(
gradle_targets
+
[
"
-
-
continue
"
]
+
args
verbose
=
True
)
        
import
itertools
        
import
xml
.
etree
.
ElementTree
as
ET
        
from
mozpack
.
files
import
(
            
FileFinder
        
)
        
if
'
TASK_ID
'
in
os
.
environ
and
'
RUN_ID
'
in
os
.
environ
:
            
root_url
=
"
https
:
/
/
queue
.
taskcluster
.
net
/
v1
/
task
/
{
}
/
runs
/
{
}
/
artifacts
/
public
/
android
/
unittest
"
.
format
(
os
.
environ
[
'
TASK_ID
'
]
os
.
environ
[
'
RUN_ID
'
]
)
        
else
:
            
root_url
=
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
reports
/
tests
'
)
        
reports
=
(
'
officialPhotonDebug
'
)
        
for
report
in
reports
:
            
finder
=
FileFinder
(
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
test
-
results
/
'
report
)
)
            
for
p
_
in
finder
.
find
(
'
TEST
-
*
.
xml
'
)
:
                
f
=
open
(
os
.
path
.
join
(
finder
.
base
p
)
'
rt
'
)
                
tree
=
ET
.
parse
(
f
)
                
root
=
tree
.
getroot
(
)
                
print
(
'
SUITE
-
START
|
android
-
test
|
{
}
{
}
'
.
format
(
report
root
.
get
(
'
name
'
)
)
)
                
for
testcase
in
root
.
findall
(
'
testcase
'
)
:
                    
name
=
testcase
.
get
(
'
name
'
)
                    
print
(
'
TEST
-
START
|
{
}
'
.
format
(
name
)
)
                    
error_count
=
0
                    
for
unexpected
in
itertools
.
chain
(
testcase
.
findall
(
'
error
'
)
                                                      
testcase
.
findall
(
'
failure
'
)
)
:
                        
for
line
in
ET
.
tostring
(
unexpected
)
.
strip
(
)
.
splitlines
(
)
:
                            
print
(
'
TEST
-
UNEXPECTED
-
FAIL
|
{
}
|
{
}
'
.
format
(
name
line
)
)
                        
error_count
+
=
1
                        
ret
|
=
1
                    
for
skipped
in
testcase
.
findall
(
'
skipped
'
)
:
                        
for
line
in
ET
.
tostring
(
skipped
)
.
strip
(
)
.
splitlines
(
)
:
                            
print
(
'
TEST
-
INFO
|
{
}
|
{
}
'
.
format
(
name
line
)
)
                    
if
not
error_count
:
                        
print
(
'
TEST
-
PASS
|
{
}
'
.
format
(
name
)
)
                
print
(
'
SUITE
-
END
|
android
-
test
|
{
}
{
}
'
.
format
(
report
root
.
get
(
'
name
'
)
)
)
            
title
=
report
            
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
{
}
/
index
.
html
'
>
HTML
{
}
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
report
title
)
)
        
return
ret
    
SubCommand
(
'
android
'
'
lint
'
        
"
"
"
Run
Android
lint
.
        
See
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Mozilla
/
Android
-
specific_test_suites
#
android
-
lint
"
"
"
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
android_lint
(
self
args
)
:
        
gradle_targets
=
[
            
'
app
:
lintOfficialPhotonDebug
'
        
]
        
ret
=
self
.
gradle
(
gradle_targets
+
[
"
-
-
continue
"
]
+
args
verbose
=
True
)
        
import
xml
.
etree
.
ElementTree
as
ET
        
if
'
TASK_ID
'
in
os
.
environ
and
'
RUN_ID
'
in
os
.
environ
:
            
root_url
=
"
https
:
/
/
queue
.
taskcluster
.
net
/
v1
/
task
/
{
}
/
runs
/
{
}
/
artifacts
/
public
/
android
/
lint
"
.
format
(
os
.
environ
[
'
TASK_ID
'
]
os
.
environ
[
'
RUN_ID
'
]
)
        
else
:
            
root_url
=
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
outputs
'
)
        
reports
=
(
'
officialPhotonDebug
'
)
        
for
report
in
reports
:
            
f
=
open
(
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
outputs
/
lint
-
results
-
{
}
.
xml
'
.
format
(
report
)
)
'
rt
'
)
            
tree
=
ET
.
parse
(
f
)
            
root
=
tree
.
getroot
(
)
            
print
(
'
SUITE
-
START
|
android
-
lint
|
{
}
'
.
format
(
report
)
)
            
for
issue
in
root
.
findall
(
"
issue
[
severity
=
'
Error
'
]
"
)
:
                
for
line
in
ET
.
tostring
(
issue
)
.
strip
(
)
.
splitlines
(
)
:
                    
print
(
'
TEST
-
UNEXPECTED
-
FAIL
|
{
}
'
.
format
(
line
)
)
                
ret
|
=
1
            
print
(
'
SUITE
-
END
|
android
-
lint
|
{
}
'
.
format
(
report
)
)
            
title
=
report
            
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
lint
-
results
-
{
}
.
html
'
>
HTML
{
}
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
report
title
)
)
            
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
lint
-
results
-
{
}
.
xml
'
>
XML
{
}
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
report
title
)
)
        
return
ret
    
SubCommand
(
'
android
'
'
checkstyle
'
        
"
"
"
Run
Android
checkstyle
.
        
See
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Mozilla
/
Android
-
specific_test_suites
#
android
-
checkstyle
"
"
"
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
android_checkstyle
(
self
args
)
:
        
gradle_targets
=
[
            
'
app
:
checkstyle
'
        
]
        
ret
=
self
.
gradle
(
gradle_targets
+
[
"
-
-
continue
"
]
+
args
verbose
=
True
)
        
import
xml
.
etree
.
ElementTree
as
ET
        
f
=
open
(
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
reports
/
checkstyle
/
checkstyle
.
xml
'
)
'
rt
'
)
        
tree
=
ET
.
parse
(
f
)
        
root
=
tree
.
getroot
(
)
        
print
(
'
SUITE
-
START
|
android
-
checkstyle
'
)
        
for
file
in
root
.
findall
(
'
file
'
)
:
            
name
=
file
.
get
(
'
name
'
)
            
print
(
'
TEST
-
START
|
{
}
'
.
format
(
name
)
)
            
error_count
=
0
            
for
error
in
file
.
findall
(
'
error
'
)
:
                
print
(
'
TEST
-
UNEXPECTED
-
FAIL
|
{
}
'
.
format
(
name
)
)
                
for
line
in
ET
.
tostring
(
error
)
.
strip
(
)
.
splitlines
(
)
:
                    
print
(
'
TEST
-
UNEXPECTED
-
FAIL
|
{
}
'
.
format
(
line
)
)
                
error_count
+
=
1
                
ret
|
=
1
            
if
not
error_count
:
                
print
(
'
TEST
-
PASS
|
{
}
'
.
format
(
name
)
)
        
print
(
'
SUITE
-
END
|
android
-
checkstyle
'
)
        
if
'
TASK_ID
'
in
os
.
environ
and
'
RUN_ID
'
in
os
.
environ
:
            
root_url
=
"
https
:
/
/
queue
.
taskcluster
.
net
/
v1
/
task
/
{
}
/
runs
/
{
}
/
artifacts
/
public
/
android
/
checkstyle
"
.
format
(
os
.
environ
[
'
TASK_ID
'
]
os
.
environ
[
'
RUN_ID
'
]
)
        
else
:
            
root_url
=
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
reports
/
checkstyle
'
)
        
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
checkstyle
.
html
'
>
HTML
checkstyle
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
)
)
        
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
checkstyle
.
xml
'
>
XML
checkstyle
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
)
)
        
return
ret
    
SubCommand
(
'
android
'
'
findbugs
'
        
"
"
"
Run
Android
findbugs
.
        
See
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Mozilla
/
Android
-
specific_test_suites
#
android
-
findbugs
"
"
"
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
android_findbugs
(
self
dryrun
=
False
args
=
[
]
)
:
        
gradle_targets
=
[
            
'
app
:
findbugsXmlOfficialPhotonDebug
'
            
'
app
:
findbugsHtmlOfficialPhotonDebug
'
        
]
        
ret
=
self
.
gradle
(
gradle_targets
+
[
"
-
-
continue
"
]
+
args
verbose
=
True
)
        
import
xml
.
etree
.
ElementTree
as
ET
        
if
'
TASK_ID
'
in
os
.
environ
and
'
RUN_ID
'
in
os
.
environ
:
            
root_url
=
"
https
:
/
/
queue
.
taskcluster
.
net
/
v1
/
task
/
{
}
/
runs
/
{
}
/
artifacts
/
public
/
artifacts
/
findbugs
"
.
format
(
os
.
environ
[
'
TASK_ID
'
]
os
.
environ
[
'
RUN_ID
'
]
)
        
else
:
            
root_url
=
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
outputs
/
findbugs
'
)
        
reports
=
(
'
findbugs
-
officialPhotonDebug
-
output
.
xml
'
)
        
for
report
in
reports
:
            
try
:
                
f
=
open
(
os
.
path
.
join
(
self
.
topobjdir
'
gradle
/
build
/
mobile
/
android
/
app
/
outputs
/
findbugs
'
report
)
'
rt
'
)
            
except
IOError
:
                
continue
            
tree
=
ET
.
parse
(
f
)
            
root
=
tree
.
getroot
(
)
            
print
(
'
SUITE
-
START
|
android
-
findbugs
|
{
}
'
.
format
(
report
)
)
            
for
error
in
root
.
findall
(
'
.
/
BugInstance
'
)
:
                
print
(
'
TEST
-
UNEXPECTED
-
FAIL
|
{
}
:
{
}
|
{
}
'
.
format
(
report
error
.
get
(
'
type
'
)
error
.
find
(
'
Class
'
)
.
get
(
'
classname
'
)
)
)
                
for
line
in
ET
.
tostring
(
error
)
.
strip
(
)
.
splitlines
(
)
:
                    
print
(
'
TEST
-
UNEXPECTED
-
FAIL
|
{
}
:
{
}
|
{
}
'
.
format
(
report
error
.
get
(
'
type
'
)
line
)
)
                
ret
|
=
1
            
print
(
'
SUITE
-
END
|
android
-
findbugs
|
{
}
'
.
format
(
report
)
)
            
title
=
report
.
replace
(
'
findbugs
-
'
'
'
)
.
replace
(
'
-
output
.
xml
'
'
'
)
            
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
{
}
'
>
HTML
{
}
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
report
.
replace
(
'
.
xml
'
'
.
html
'
)
title
)
)
            
print
(
"
TinderboxPrint
:
report
<
br
/
>
<
a
href
=
'
{
}
/
{
}
'
>
XML
{
}
report
<
/
a
>
visit
\
"
Inspect
Task
\
"
link
for
details
"
.
format
(
root_url
report
title
)
)
        
return
ret
    
SubCommand
(
'
android
'
'
gradle
-
dependencies
'
        
"
"
"
Collect
Android
Gradle
dependencies
.
        
See
https
:
/
/
gecko
.
readthedocs
.
io
/
en
/
latest
/
build
/
buildsystem
/
toolchains
.
html
#
firefox
-
for
-
android
-
with
-
gradle
"
"
"
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
android_gradle_dependencies
(
self
args
)
:
        
gradle_targets
=
[
            
'
app
:
checkstyle
'
            
'
app
:
assembleOfficialPhotonRelease
'
            
'
app
:
assembleOfficialPhotonDebug
'
            
'
app
:
assembleOfficialPhotonDebugAndroidTest
'
            
'
app
:
findbugsXmlOfficialPhotonDebug
'
            
'
app
:
findbugsHtmlOfficialPhotonDebug
'
            
'
app
:
lintOfficialPhotonDebug
'
            
'
geckoview
:
assembleWithoutGeckoBinaries
'
            
'
geckoview_example
:
assembleWithoutGeckoBinaries
'
            
'
geckoview_example
:
assembleWithoutGeckoBinariesAndroidTest
'
        
]
        
ret
=
self
.
gradle
(
gradle_targets
+
[
"
-
-
continue
"
]
+
args
verbose
=
True
)
        
return
0
    
Command
(
'
gradle
'
category
=
'
devenv
'
        
description
=
'
Run
gradle
.
'
        
conditions
=
[
conditions
.
is_android
]
)
    
CommandArgument
(
'
-
v
'
'
-
-
verbose
'
action
=
'
store_true
'
        
help
=
'
Verbose
output
for
what
commands
the
build
is
running
.
'
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
gradle
(
self
args
verbose
=
False
)
:
        
if
not
verbose
:
            
self
.
log_manager
.
terminal_handler
.
setLevel
(
logging
.
CRITICAL
)
        
java_home
=
os
.
path
.
dirname
(
os
.
path
.
dirname
(
self
.
substs
[
'
JAVA
'
]
)
)
        
gradle_flags
=
shell_split
(
self
.
substs
.
get
(
'
GRADLE_FLAGS
'
'
'
)
)
        
return
self
.
run_process
(
[
self
.
substs
[
'
GRADLE
'
]
]
+
gradle_flags
+
args
            
append_env
=
{
                
'
GRADLE_OPTS
'
:
'
-
Dfile
.
encoding
=
utf
-
8
'
                
'
JAVA_HOME
'
:
java_home
            
}
            
pass_thru
=
True
            
ensure_exit_code
=
False
            
cwd
=
mozpath
.
join
(
self
.
topsrcdir
)
)
    
Command
(
'
gradle
-
install
'
category
=
'
devenv
'
        
conditions
=
[
REMOVED
]
)
    
def
gradle_install
(
self
)
:
        
pass
CommandProvider
class
AndroidEmulatorCommands
(
MachCommandBase
)
:
    
"
"
"
       
Run
the
Android
emulator
with
one
of
the
AVDs
used
in
the
Mozilla
       
automated
test
environment
.
If
necessary
the
AVD
is
fetched
from
       
the
tooltool
server
and
installed
.
    
"
"
"
    
Command
(
'
android
-
emulator
'
category
=
'
devenv
'
        
conditions
=
[
]
        
description
=
'
Run
the
Android
emulator
with
an
AVD
from
test
automation
.
'
)
    
CommandArgument
(
'
-
-
version
'
metavar
=
'
VERSION
'
choices
=
[
'
4
.
3
'
'
6
.
0
'
'
7
.
0
'
'
x86
'
'
x86
-
6
.
0
'
]
        
help
=
'
Specify
Android
version
to
run
in
emulator
.
One
of
"
4
.
3
"
"
6
.
0
"
"
7
.
0
"
"
x86
"
or
"
x86
-
6
.
0
"
.
'
        
default
=
'
4
.
3
'
)
    
CommandArgument
(
'
-
-
wait
'
action
=
'
store_true
'
        
help
=
'
Wait
for
emulator
to
be
closed
.
'
)
    
CommandArgument
(
'
-
-
force
-
update
'
action
=
'
store_true
'
        
help
=
'
Update
AVD
definition
even
when
AVD
is
already
installed
.
'
)
    
CommandArgument
(
'
-
-
verbose
'
action
=
'
store_true
'
        
help
=
'
Log
informative
status
messages
.
'
)
    
def
emulator
(
self
version
wait
=
False
force_update
=
False
verbose
=
False
)
:
        
from
mozrunner
.
devices
.
android_device
import
AndroidEmulator
        
emulator
=
AndroidEmulator
(
version
verbose
substs
=
self
.
substs
device_serial
=
'
emulator
-
5554
'
)
        
if
emulator
.
is_running
(
)
:
            
self
.
log
(
logging
.
ERROR
"
emulator
"
{
}
                     
"
An
Android
emulator
is
already
running
.
\
n
"
                     
"
Close
the
existing
emulator
and
re
-
run
this
command
.
"
)
            
return
1
        
if
not
emulator
.
is_available
(
)
:
            
self
.
log
(
logging
.
WARN
"
emulator
"
{
}
                     
"
Emulator
binary
not
found
.
\
n
"
                     
"
Install
the
Android
SDK
and
make
sure
'
emulator
'
is
in
your
PATH
.
"
)
            
return
2
        
if
not
emulator
.
check_avd
(
force_update
)
:
            
self
.
log
(
logging
.
INFO
"
emulator
"
{
}
                     
"
Fetching
and
installing
AVD
.
This
may
take
a
few
minutes
.
.
.
"
)
            
emulator
.
update_avd
(
force_update
)
        
self
.
log
(
logging
.
INFO
"
emulator
"
{
}
                 
"
Starting
Android
emulator
running
%
s
.
.
.
"
%
                 
emulator
.
get_avd_description
(
)
)
        
emulator
.
start
(
)
        
if
emulator
.
wait_for_start
(
)
:
            
self
.
log
(
logging
.
INFO
"
emulator
"
{
}
                     
"
Android
emulator
is
running
.
"
)
        
else
:
            
self
.
log
(
logging
.
WARN
"
emulator
"
{
}
                     
"
Unable
to
verify
that
emulator
is
running
.
"
)
        
if
conditions
.
is_android
(
self
)
:
            
self
.
log
(
logging
.
INFO
"
emulator
"
{
}
                     
"
Use
'
mach
install
'
to
install
or
update
Firefox
on
your
emulator
.
"
)
        
else
:
            
self
.
log
(
logging
.
WARN
"
emulator
"
{
}
                     
"
No
Firefox
for
Android
build
detected
.
\
n
"
                     
"
Switch
to
a
Firefox
for
Android
build
context
or
use
'
mach
bootstrap
'
\
n
"
                     
"
to
setup
an
Android
build
environment
.
"
)
        
if
wait
:
            
self
.
log
(
logging
.
INFO
"
emulator
"
{
}
                     
"
Waiting
for
Android
emulator
to
close
.
.
.
"
)
            
rc
=
emulator
.
wait
(
)
            
if
rc
is
not
None
:
                
self
.
log
(
logging
.
INFO
"
emulator
"
{
}
                         
"
Android
emulator
completed
with
return
code
%
d
.
"
%
rc
)
            
else
:
                
self
.
log
(
logging
.
WARN
"
emulator
"
{
}
                         
"
Unable
to
retrieve
Android
emulator
return
code
.
"
)
        
return
0
CommandProvider
class
AutophoneCommands
(
MachCommandBase
)
:
    
"
"
"
       
Run
autophone
https
:
/
/
wiki
.
mozilla
.
org
/
Auto
-
tools
/
Projects
/
Autophone
.
       
If
necessary
autophone
is
cloned
from
github
installed
and
configured
.
    
"
"
"
    
Command
(
'
autophone
'
category
=
'
devenv
'
        
conditions
=
[
]
        
description
=
'
Run
autophone
.
'
)
    
CommandArgument
(
'
-
-
clean
'
action
=
'
store_true
'
        
help
=
'
Delete
an
existing
autophone
installation
.
'
)
    
CommandArgument
(
'
-
-
verbose
'
action
=
'
store_true
'
        
help
=
'
Log
informative
status
messages
.
'
)
    
def
autophone
(
self
clean
=
False
verbose
=
False
)
:
        
import
platform
        
from
mozrunner
.
devices
.
autophone
import
AutophoneRunner
        
if
platform
.
system
(
)
=
=
"
Windows
"
:
            
self
.
log
(
logging
.
ERROR
"
autophone
"
{
}
                
"
This
mach
command
is
not
supported
on
Windows
!
"
)
            
return
-
1
        
runner
=
AutophoneRunner
(
self
verbose
)
        
runner
.
load_config
(
)
        
if
clean
:
            
runner
.
reset_to_clean
(
)
            
return
0
        
if
not
runner
.
setup_directory
(
)
:
            
return
1
        
if
not
runner
.
install_requirements
(
)
:
            
runner
.
save_config
(
)
            
return
2
        
if
not
runner
.
configure
(
)
:
            
runner
.
save_config
(
)
            
return
3
        
runner
.
save_config
(
)
        
runner
.
launch_autophone
(
)
        
runner
.
command_prompts
(
)
        
return
0
