const
{
GeckoViewActorChild
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewActorChild
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
LayoutUtils
:
"
resource
:
/
/
gre
/
modules
/
LayoutUtils
.
sys
.
mjs
"
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
SelectionActionDelegateChild
"
]
;
const
MAGNIFIER_PREF
=
"
layout
.
accessiblecaret
.
magnifier
.
enabled
"
;
const
ACCESSIBLECARET_HEIGHT_PREF
=
"
layout
.
accessiblecaret
.
height
"
;
const
PREFS
=
[
MAGNIFIER_PREF
ACCESSIBLECARET_HEIGHT_PREF
]
;
class
SelectionActionDelegateChild
extends
GeckoViewActorChild
{
constructor
(
aModuleName
aMessageManager
)
{
super
(
aModuleName
aMessageManager
)
;
this
.
_actionCallback
=
(
)
=
>
{
}
;
this
.
_isActive
=
false
;
this
.
_previousMessage
=
"
"
;
this
.
_observerFunction
=
(
subject
topic
data
)
=
>
{
this
.
observe
(
subject
topic
data
)
;
}
;
for
(
const
pref
of
PREFS
)
{
Services
.
prefs
.
addObserver
(
pref
this
.
_observerFunction
)
;
}
this
.
_magnifierEnabled
=
Services
.
prefs
.
getBoolPref
(
MAGNIFIER_PREF
)
;
this
.
_accessiblecaretHeight
=
parseFloat
(
Services
.
prefs
.
getCharPref
(
ACCESSIBLECARET_HEIGHT_PREF
"
0
"
)
)
;
}
didDestroy
(
)
{
for
(
const
pref
of
PREFS
)
{
Services
.
prefs
.
removeObserver
(
pref
this
.
_observerFunction
)
;
}
}
_actions
=
[
{
id
:
"
org
.
mozilla
.
geckoview
.
HIDE
"
predicate
:
_
=
>
true
perform
:
_
=
>
this
.
handleEvent
(
{
type
:
"
pagehide
"
}
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
CUT
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
&
&
!
this
.
_isPasswordField
(
e
)
perform
:
_
=
>
this
.
docShell
.
doCommand
(
"
cmd_cut
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COPY
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
!
this
.
_isPasswordField
(
e
)
perform
:
_
=
>
this
.
docShell
.
doCommand
(
"
cmd_copy
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
PASTE
"
predicate
:
e
=
>
e
.
selectionEditable
&
&
Services
.
clipboard
.
hasDataMatchingFlavors
(
[
"
text
/
unicode
"
]
Ci
.
nsIClipboard
.
kGlobalClipboard
)
perform
:
_
=
>
this
.
_performPaste
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
PASTE_AS_PLAIN_TEXT
"
predicate
:
e
=
>
this
.
_isContentHtmlEditable
(
e
)
&
&
Services
.
clipboard
.
hasDataMatchingFlavors
(
[
"
text
/
html
"
]
Ci
.
nsIClipboard
.
kGlobalClipboard
)
perform
:
_
=
>
this
.
_performPasteAsPlainText
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
DELETE
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
_
=
>
this
.
docShell
.
doCommand
(
"
cmd_delete
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_START
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_moveLeft
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_END
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_moveRight
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
UNSELECT
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
!
e
.
selectionEditable
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_selectNone
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
SELECT_ALL
"
predicate
:
e
=
>
{
if
(
e
.
reason
=
=
=
"
longpressonemptycontent
"
)
{
return
false
;
}
const
element
=
Services
.
focus
.
focusedElement
|
|
e
.
target
?
.
activeElement
;
if
(
e
.
selectionEditable
&
&
e
.
target
&
&
element
)
{
let
value
=
"
"
;
if
(
element
.
value
)
{
value
=
element
.
value
;
}
else
if
(
element
.
isContentEditable
|
|
e
.
target
.
designMode
=
=
=
"
on
"
)
{
value
=
element
.
innerText
;
}
return
value
!
=
=
"
"
&
&
value
!
=
=
e
.
selectedTextContent
;
}
return
true
;
}
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_selectAll
"
)
}
]
;
receiveMessage
(
{
name
data
}
)
{
debug
receiveMessage
{
name
}
;
switch
(
name
)
{
case
"
ExecuteSelectionAction
"
:
{
this
.
_actionCallback
(
data
)
;
}
}
}
_performPaste
(
)
{
this
.
handleEvent
(
{
type
:
"
pagehide
"
}
)
;
this
.
docShell
.
doCommand
(
"
cmd_paste
"
)
;
}
_performPasteAsPlainText
(
)
{
this
.
handleEvent
(
{
type
:
"
pagehide
"
}
)
;
this
.
docShell
.
doCommand
(
"
cmd_pasteNoFormatting
"
)
;
}
_isPasswordField
(
aEvent
)
{
if
(
!
aEvent
.
selectionEditable
)
{
return
false
;
}
const
win
=
aEvent
.
target
.
defaultView
;
const
focus
=
aEvent
.
target
.
activeElement
;
return
(
win
&
&
win
.
HTMLInputElement
&
&
win
.
HTMLInputElement
.
isInstance
(
focus
)
&
&
!
focus
.
mozIsTextField
(
true
)
)
;
}
_isContentHtmlEditable
(
aEvent
)
{
if
(
!
aEvent
.
selectionEditable
)
{
return
false
;
}
if
(
aEvent
.
target
.
designMode
=
=
"
on
"
)
{
return
true
;
}
const
win
=
aEvent
.
target
.
defaultView
;
const
focus
=
Services
.
focus
.
focusedElement
;
return
(
win
&
&
win
.
HTMLInputElement
&
&
win
.
HTMLTextAreaElement
&
&
!
win
.
HTMLInputElement
.
isInstance
(
focus
)
&
&
!
win
.
HTMLTextAreaElement
.
isInstance
(
focus
)
)
;
}
_getFrameOffset
(
aEvent
)
{
const
offset
=
{
left
:
0
top
:
0
}
;
let
currentWindow
=
aEvent
.
target
.
defaultView
;
while
(
currentWindow
.
realFrameElement
)
{
const
frameElement
=
currentWindow
.
realFrameElement
;
currentWindow
=
frameElement
.
ownerGlobal
;
const
currentRect
=
frameElement
.
getBoundingClientRect
(
)
;
const
style
=
currentWindow
.
getComputedStyle
(
frameElement
)
;
const
borderLeft
=
parseFloat
(
style
.
borderLeftWidth
)
|
|
0
;
const
borderTop
=
parseFloat
(
style
.
borderTopWidth
)
|
|
0
;
const
paddingLeft
=
parseFloat
(
style
.
paddingLeft
)
|
|
0
;
const
paddingTop
=
parseFloat
(
style
.
paddingTop
)
|
|
0
;
offset
.
left
+
=
currentRect
.
left
+
borderLeft
+
paddingLeft
;
offset
.
top
+
=
currentRect
.
top
+
borderTop
+
paddingTop
;
const
targetDocShell
=
currentWindow
.
docShell
;
if
(
targetDocShell
.
isMozBrowser
)
{
break
;
}
}
var
offsetX
=
{
}
;
var
offsetY
=
{
}
;
currentWindow
.
windowUtils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
offset
.
left
-
=
offsetX
.
value
;
offset
.
top
-
=
offsetY
.
value
;
return
offset
;
}
_getDefaultMagnifierPoint
(
aEvent
)
{
const
rect
=
lazy
.
LayoutUtils
.
rectToScreenRect
(
aEvent
.
target
.
ownerGlobal
{
left
:
aEvent
.
clientX
top
:
aEvent
.
clientY
-
this
.
_accessiblecaretHeight
width
:
0
height
:
0
}
)
;
return
{
x
:
rect
.
left
y
:
rect
.
top
}
;
}
_getBetterMagnifierPoint
(
aEvent
)
{
const
win
=
aEvent
.
target
.
defaultView
;
if
(
!
win
)
{
return
this
.
_getDefaultMagnifierPoint
(
aEvent
)
;
}
const
focus
=
aEvent
.
target
.
activeElement
;
if
(
win
.
HTMLInputElement
?
.
isInstance
(
focus
)
&
&
focus
.
mozIsTextField
(
false
)
)
{
const
bounds
=
focus
.
getBoundingClientRect
(
)
;
const
rect
=
lazy
.
LayoutUtils
.
rectToScreenRect
(
aEvent
.
target
.
ownerGlobal
{
left
:
aEvent
.
clientX
top
:
bounds
.
top
width
:
0
height
:
bounds
.
height
}
)
;
return
{
x
:
rect
.
left
y
:
rect
.
top
+
rect
.
height
/
2
}
;
}
if
(
win
.
HTMLTextAreaElement
?
.
isInstance
(
focus
)
)
{
return
this
.
_getDefaultMagnifierPoint
(
aEvent
)
;
}
const
selection
=
win
.
getSelection
(
)
;
if
(
selection
.
rangeCount
!
=
1
)
{
return
this
.
_getDefaultMagnifierPoint
(
aEvent
)
;
}
const
bounds
=
(
(
)
=
>
{
const
range
=
selection
.
getRangeAt
(
0
)
;
let
distance
=
Number
.
MAX_SAFE_INTEGER
;
let
y
=
aEvent
.
clientY
;
const
rectList
=
range
.
getClientRects
(
)
;
for
(
const
rect
of
rectList
)
{
const
newDistance
=
Math
.
abs
(
aEvent
.
clientY
-
rect
.
bottom
)
;
if
(
distance
>
newDistance
)
{
y
=
rect
.
top
+
rect
.
height
/
2
;
distance
=
newDistance
;
}
}
return
{
left
:
aEvent
.
clientX
top
:
y
width
:
0
height
:
0
}
;
}
)
(
)
;
const
rect
=
lazy
.
LayoutUtils
.
rectToScreenRect
(
aEvent
.
target
.
ownerGlobal
bounds
)
;
return
{
x
:
rect
.
left
y
:
rect
.
top
}
;
}
_handleMagnifier
(
aEvent
)
{
if
(
[
"
presscaret
"
"
dragcaret
"
]
.
includes
(
aEvent
.
reason
)
)
{
debug
_handleMagnifier
:
{
aEvent
.
reason
}
;
const
screenPoint
=
this
.
_getBetterMagnifierPoint
(
aEvent
)
;
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
ShowMagnifier
"
screenPoint
}
)
;
}
else
if
(
aEvent
.
reason
=
=
"
releasecaret
"
)
{
debug
_handleMagnifier
:
{
aEvent
.
reason
}
;
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
HideMagnifier
"
}
)
;
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
=
=
=
"
pagehide
"
|
|
aEvent
.
type
=
=
=
"
deactivate
"
)
{
aEvent
=
{
reason
:
"
visibilitychange
"
caretVisibile
:
false
selectionVisible
:
false
collapsed
:
true
selectionEditable
:
false
}
;
}
let
reason
=
aEvent
.
reason
;
if
(
this
.
_isActive
&
&
!
aEvent
.
caretVisible
)
{
reason
=
"
visibilitychange
"
;
}
else
if
(
!
aEvent
.
collapsed
&
&
!
aEvent
.
selectionVisible
)
{
reason
=
"
invisibleselection
"
;
}
else
if
(
!
this
.
_isActive
&
&
aEvent
.
selectionEditable
&
&
aEvent
.
collapsed
&
&
reason
!
=
=
"
longpressonemptycontent
"
&
&
reason
!
=
=
"
taponcaret
"
&
&
!
Services
.
prefs
.
getBoolPref
(
"
geckoview
.
selection_action
.
show_on_focus
"
false
)
)
{
reason
=
"
visibilitychange
"
;
}
debug
handleEvent
:
{
reason
}
;
if
(
this
.
_magnifierEnabled
)
{
this
.
_handleMagnifier
(
aEvent
)
;
}
if
(
[
"
longpressonemptycontent
"
"
releasecaret
"
"
taponcaret
"
"
updateposition
"
]
.
includes
(
reason
)
)
{
const
actions
=
this
.
_actions
.
filter
(
action
=
>
action
.
predicate
.
call
(
this
aEvent
)
)
;
const
screenRect
=
(
(
)
=
>
{
const
boundingRect
=
aEvent
.
boundingClientRect
;
if
(
!
boundingRect
)
{
return
null
;
}
const
rect
=
lazy
.
LayoutUtils
.
rectToScreenRect
(
aEvent
.
target
.
ownerGlobal
boundingRect
)
;
return
{
left
:
rect
.
left
top
:
rect
.
top
right
:
rect
.
right
bottom
:
rect
.
bottom
+
this
.
_accessiblecaretHeight
}
;
}
)
(
)
;
const
clientRect
=
(
(
)
=
>
{
const
boundingRect
=
aEvent
.
boundingClientRect
;
if
(
!
boundingRect
)
{
return
null
;
}
const
offset
=
this
.
_getFrameOffset
(
aEvent
)
;
return
{
left
:
aEvent
.
boundingClientRect
.
left
+
offset
.
left
top
:
aEvent
.
boundingClientRect
.
top
+
offset
.
top
right
:
aEvent
.
boundingClientRect
.
right
+
offset
.
left
bottom
:
aEvent
.
boundingClientRect
.
bottom
+
offset
.
top
+
this
.
_accessiblecaretHeight
}
;
}
)
(
)
;
const
password
=
this
.
_isPasswordField
(
aEvent
)
;
const
msg
=
{
collapsed
:
aEvent
.
collapsed
editable
:
aEvent
.
selectionEditable
password
selection
:
password
?
"
"
:
aEvent
.
selectedTextContent
clientRect
screenRect
actions
:
actions
.
map
(
action
=
>
action
.
id
)
}
;
if
(
this
.
_isActive
&
&
JSON
.
stringify
(
msg
)
=
=
=
this
.
_previousMessage
)
{
return
;
}
this
.
_isActive
=
true
;
this
.
_previousMessage
=
JSON
.
stringify
(
msg
)
;
this
.
_actionCallback
=
data
=
>
{
const
action
=
actions
.
find
(
action
=
>
action
.
id
=
=
=
data
.
id
)
;
if
(
action
)
{
debug
Performing
{
data
.
id
}
;
action
.
perform
.
call
(
this
aEvent
)
;
}
else
{
warn
Invalid
action
{
data
.
id
}
;
}
}
;
this
.
sendAsyncMessage
(
"
ShowSelectionAction
"
msg
)
;
}
else
if
(
[
"
invisibleselection
"
"
presscaret
"
"
scroll
"
"
visibilitychange
"
]
.
includes
(
reason
)
)
{
if
(
!
this
.
_isActive
)
{
return
;
}
this
.
_isActive
=
false
;
if
(
reason
!
=
=
"
invisibleselection
"
&
&
reason
!
=
=
"
scroll
"
)
{
this
.
_seqNo
+
+
;
}
this
.
sendAsyncMessage
(
"
HideSelectionAction
"
{
reason
}
)
;
}
else
if
(
reason
=
=
"
dragcaret
"
)
{
}
else
{
warn
Unknown
reason
:
{
reason
}
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
)
{
return
;
}
switch
(
aData
)
{
case
ACCESSIBLECARET_HEIGHT_PREF
:
this
.
_accessiblecaretHeight
=
parseFloat
(
Services
.
prefs
.
getCharPref
(
ACCESSIBLECARET_HEIGHT_PREF
"
0
"
)
)
;
break
;
case
MAGNIFIER_PREF
:
this
.
_magnifierEnabled
=
Services
.
prefs
.
getBoolPref
(
MAGNIFIER_PREF
)
;
break
;
}
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
HideMagnifier
"
}
)
;
}
}
const
{
debug
warn
}
=
SelectionActionDelegateChild
.
initLogging
(
"
SelectionActionDelegate
"
)
;
