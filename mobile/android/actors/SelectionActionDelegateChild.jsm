const
{
GeckoViewActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewActorChild
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
EXPORTED_SYMBOLS
=
[
"
SelectionActionDelegateChild
"
]
;
const
MAGNIFIER_PREF
=
"
layout
.
accessiblecaret
.
magnifier
.
enabled
"
;
const
ACCESSIBLECARET_HEIGHT_PREF
=
"
layout
.
accessiblecaret
.
height
"
;
const
PREFS
=
[
MAGNIFIER_PREF
ACCESSIBLECARET_HEIGHT_PREF
]
;
class
SelectionActionDelegateChild
extends
GeckoViewActorChild
{
constructor
(
aModuleName
aMessageManager
)
{
super
(
aModuleName
aMessageManager
)
;
this
.
_seqNo
=
0
;
this
.
_isActive
=
false
;
this
.
_previousMessage
=
"
"
;
this
.
_observerFunction
=
(
subject
topic
data
)
=
>
{
this
.
observe
(
subject
topic
data
)
;
}
;
for
(
const
pref
of
PREFS
)
{
Services
.
prefs
.
addObserver
(
pref
this
.
_observerFunction
)
;
}
this
.
_magnifierEnabled
=
Services
.
prefs
.
getBoolPref
(
MAGNIFIER_PREF
)
;
this
.
_accessiblecaretHeight
=
parseFloat
(
Services
.
prefs
.
getCharPref
(
ACCESSIBLECARET_HEIGHT_PREF
"
0
"
)
)
;
}
didDestroy
(
)
{
for
(
const
pref
of
PREFS
)
{
Services
.
prefs
.
removeObserver
(
pref
this
.
_observerFunction
)
;
}
}
_actions
=
[
{
id
:
"
org
.
mozilla
.
geckoview
.
HIDE
"
predicate
:
_
=
>
true
perform
:
_
=
>
this
.
handleEvent
(
{
type
:
"
pagehide
"
}
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
CUT
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
&
&
!
this
.
_isPasswordField
(
e
)
perform
:
_
=
>
this
.
docShell
.
doCommand
(
"
cmd_cut
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COPY
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
!
this
.
_isPasswordField
(
e
)
perform
:
_
=
>
this
.
docShell
.
doCommand
(
"
cmd_copy
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
PASTE
"
predicate
:
e
=
>
e
.
selectionEditable
&
&
Services
.
clipboard
.
hasDataMatchingFlavors
(
[
"
text
/
unicode
"
]
Ci
.
nsIClipboard
.
kGlobalClipboard
)
perform
:
_
=
>
this
.
_performPaste
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
PASTE_AS_PLAIN_TEXT
"
predicate
:
e
=
>
this
.
_isContentHtmlEditable
(
e
)
&
&
Services
.
clipboard
.
hasDataMatchingFlavors
(
[
"
text
/
html
"
]
Ci
.
nsIClipboard
.
kGlobalClipboard
)
perform
:
_
=
>
this
.
_performPasteAsPlainText
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
DELETE
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
_
=
>
this
.
docShell
.
doCommand
(
"
cmd_delete
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_START
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_moveLeft
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_END
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_moveRight
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
UNSELECT
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
!
e
.
selectionEditable
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_selectNone
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
SELECT_ALL
"
predicate
:
e
=
>
{
if
(
e
.
reason
=
=
=
"
longpressonemptycontent
"
)
{
return
false
;
}
const
element
=
Services
.
focus
.
focusedElement
|
|
e
.
target
?
.
activeElement
;
if
(
e
.
selectionEditable
&
&
e
.
target
&
&
element
)
{
let
value
=
"
"
;
if
(
element
.
value
)
{
value
=
element
.
value
;
}
else
if
(
element
.
isContentEditable
|
|
e
.
target
.
designMode
=
=
=
"
on
"
)
{
value
=
element
.
innerText
;
}
return
value
!
=
=
"
"
&
&
value
!
=
=
e
.
selectedTextContent
;
}
return
true
;
}
perform
:
e
=
>
this
.
docShell
.
doCommand
(
"
cmd_selectAll
"
)
}
]
;
_performPaste
(
)
{
this
.
handleEvent
(
{
type
:
"
pagehide
"
}
)
;
this
.
docShell
.
doCommand
(
"
cmd_paste
"
)
;
}
_performPasteAsPlainText
(
)
{
this
.
handleEvent
(
{
type
:
"
pagehide
"
}
)
;
this
.
docShell
.
doCommand
(
"
cmd_pasteNoFormatting
"
)
;
}
_isPasswordField
(
aEvent
)
{
if
(
!
aEvent
.
selectionEditable
)
{
return
false
;
}
const
win
=
aEvent
.
target
.
defaultView
;
const
focus
=
aEvent
.
target
.
activeElement
;
return
(
win
&
&
win
.
HTMLInputElement
&
&
win
.
HTMLInputElement
.
isInstance
(
focus
)
&
&
!
focus
.
mozIsTextField
(
true
)
)
;
}
_isContentHtmlEditable
(
aEvent
)
{
if
(
!
aEvent
.
selectionEditable
)
{
return
false
;
}
if
(
aEvent
.
target
.
designMode
=
=
"
on
"
)
{
return
true
;
}
const
win
=
aEvent
.
target
.
defaultView
;
const
focus
=
Services
.
focus
.
focusedElement
;
return
(
win
&
&
win
.
HTMLInputElement
&
&
win
.
HTMLTextAreaElement
&
&
!
win
.
HTMLInputElement
.
isInstance
(
focus
)
&
&
!
win
.
HTMLTextAreaElement
.
isInstance
(
focus
)
)
;
}
_getFrameOffset
(
aEvent
)
{
const
offset
=
{
left
:
0
top
:
0
}
;
let
currentWindow
=
aEvent
.
target
.
defaultView
;
while
(
currentWindow
.
realFrameElement
)
{
const
frameElement
=
currentWindow
.
realFrameElement
;
currentWindow
=
frameElement
.
ownerGlobal
;
const
currentRect
=
frameElement
.
getBoundingClientRect
(
)
;
const
style
=
currentWindow
.
getComputedStyle
(
frameElement
)
;
const
borderLeft
=
parseFloat
(
style
.
borderLeftWidth
)
|
|
0
;
const
borderTop
=
parseFloat
(
style
.
borderTopWidth
)
|
|
0
;
const
paddingLeft
=
parseFloat
(
style
.
paddingLeft
)
|
|
0
;
const
paddingTop
=
parseFloat
(
style
.
paddingTop
)
|
|
0
;
offset
.
left
+
=
currentRect
.
left
+
borderLeft
+
paddingLeft
;
offset
.
top
+
=
currentRect
.
top
+
borderTop
+
paddingTop
;
const
targetDocShell
=
currentWindow
.
docShell
;
if
(
targetDocShell
.
isMozBrowser
)
{
break
;
}
}
var
offsetX
=
{
}
;
var
offsetY
=
{
}
;
currentWindow
.
windowUtils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
offset
.
left
-
=
offsetX
.
value
;
offset
.
top
-
=
offsetY
.
value
;
return
offset
;
}
_handleMagnifier
(
aEvent
)
{
if
(
[
"
presscaret
"
"
dragcaret
"
]
.
includes
(
aEvent
.
reason
)
)
{
debug
_handleMagnifier
:
{
aEvent
.
reason
}
;
const
offset
=
this
.
_getFrameOffset
(
aEvent
)
;
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
ShowMagnifier
"
clientPoint
:
{
x
:
aEvent
.
clientX
+
offset
.
left
y
:
aEvent
.
clientY
+
offset
.
top
-
this
.
_accessiblecaretHeight
}
}
)
;
}
else
if
(
aEvent
.
reason
=
=
"
releasecaret
"
)
{
debug
_handleMagnifier
:
{
aEvent
.
reason
}
;
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
HideMagnifier
"
}
)
;
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
=
=
=
"
pagehide
"
|
|
aEvent
.
type
=
=
=
"
deactivate
"
)
{
aEvent
=
{
reason
:
"
visibilitychange
"
caretVisibile
:
false
selectionVisible
:
false
collapsed
:
true
selectionEditable
:
false
}
;
}
let
reason
=
aEvent
.
reason
;
if
(
this
.
_isActive
&
&
!
aEvent
.
caretVisible
)
{
reason
=
"
visibilitychange
"
;
}
else
if
(
!
aEvent
.
collapsed
&
&
!
aEvent
.
selectionVisible
)
{
reason
=
"
invisibleselection
"
;
}
else
if
(
!
this
.
_isActive
&
&
aEvent
.
selectionEditable
&
&
aEvent
.
collapsed
&
&
reason
!
=
=
"
longpressonemptycontent
"
&
&
reason
!
=
=
"
taponcaret
"
&
&
!
Services
.
prefs
.
getBoolPref
(
"
geckoview
.
selection_action
.
show_on_focus
"
false
)
)
{
reason
=
"
visibilitychange
"
;
}
debug
handleEvent
:
{
reason
}
;
if
(
this
.
_magnifierEnabled
)
{
this
.
_handleMagnifier
(
aEvent
)
;
}
if
(
[
"
longpressonemptycontent
"
"
releasecaret
"
"
taponcaret
"
"
updateposition
"
]
.
includes
(
reason
)
)
{
const
actions
=
this
.
_actions
.
filter
(
action
=
>
action
.
predicate
.
call
(
this
aEvent
)
)
;
const
offset
=
this
.
_getFrameOffset
(
aEvent
)
;
const
password
=
this
.
_isPasswordField
(
aEvent
)
;
const
msg
=
{
type
:
"
GeckoView
:
ShowSelectionAction
"
seqNo
:
this
.
_seqNo
collapsed
:
aEvent
.
collapsed
editable
:
aEvent
.
selectionEditable
password
selection
:
password
?
"
"
:
aEvent
.
selectedTextContent
clientRect
:
!
aEvent
.
boundingClientRect
?
null
:
{
left
:
aEvent
.
boundingClientRect
.
left
+
offset
.
left
top
:
aEvent
.
boundingClientRect
.
top
+
offset
.
top
right
:
aEvent
.
boundingClientRect
.
right
+
offset
.
left
bottom
:
aEvent
.
boundingClientRect
.
bottom
+
offset
.
top
}
actions
:
actions
.
map
(
action
=
>
action
.
id
)
}
;
if
(
msg
.
clientRect
)
{
msg
.
clientRect
.
bottom
+
=
this
.
_accessiblecaretHeight
;
}
if
(
this
.
_isActive
&
&
JSON
.
stringify
(
msg
)
=
=
=
this
.
_previousMessage
)
{
return
;
}
msg
.
seqNo
=
+
+
this
.
_seqNo
;
this
.
_isActive
=
true
;
this
.
_previousMessage
=
JSON
.
stringify
(
msg
)
;
this
.
eventDispatcher
.
sendRequest
(
msg
{
onSuccess
:
response
=
>
{
if
(
response
.
seqNo
!
=
=
this
.
_seqNo
)
{
warn
Stale
response
{
response
.
id
}
;
return
;
}
const
action
=
actions
.
find
(
action
=
>
action
.
id
=
=
=
response
.
id
)
;
if
(
action
)
{
debug
Performing
{
response
.
id
}
;
action
.
perform
.
call
(
this
aEvent
response
)
;
}
else
{
warn
Invalid
action
{
response
.
id
}
;
}
}
onError
:
_
=
>
{
}
}
)
;
}
else
if
(
[
"
invisibleselection
"
"
presscaret
"
"
scroll
"
"
visibilitychange
"
]
.
includes
(
reason
)
)
{
if
(
!
this
.
_isActive
)
{
return
;
}
this
.
_isActive
=
false
;
if
(
reason
!
=
=
"
invisibleselection
"
&
&
reason
!
=
=
"
scroll
"
)
{
this
.
_seqNo
+
+
;
}
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
HideSelectionAction
"
reason
}
)
;
}
else
if
(
reason
=
=
"
dragcaret
"
)
{
}
else
{
warn
Unknown
reason
:
{
reason
}
;
}
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
)
{
return
;
}
switch
(
aData
)
{
case
ACCESSIBLECARET_HEIGHT_PREF
:
this
.
_accessiblecaretHeight
=
parseFloat
(
Services
.
prefs
.
getCharPref
(
ACCESSIBLECARET_HEIGHT_PREF
"
0
"
)
)
;
break
;
case
MAGNIFIER_PREF
:
this
.
_magnifierEnabled
=
Services
.
prefs
.
getBoolPref
(
MAGNIFIER_PREF
)
;
break
;
}
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
HideMagnifier
"
}
)
;
}
}
const
{
debug
warn
}
=
SelectionActionDelegateChild
.
initLogging
(
"
SelectionActionDelegate
"
)
;
