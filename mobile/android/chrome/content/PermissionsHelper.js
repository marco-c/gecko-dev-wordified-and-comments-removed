"
use
strict
"
;
var
PermissionsHelper
=
{
_permissonTypes
:
[
"
password
"
"
geolocation
"
"
popup
"
"
indexedDB
"
"
offline
-
app
"
"
desktop
-
notification
"
"
plugins
"
"
native
-
intent
"
]
_permissionStrings
:
{
password
:
{
label
:
"
password
.
logins
"
allowed
:
"
password
.
save
"
denied
:
"
password
.
dontSave
"
}
geolocation
:
{
label
:
"
geolocation
.
location
"
allowed
:
"
geolocation
.
allow
"
denied
:
"
geolocation
.
dontAllow
"
}
popup
:
{
label
:
"
blockPopups
.
label2
"
allowed
:
"
popup
.
show
"
denied
:
"
popup
.
dontShow
"
}
indexedDB
:
{
label
:
"
offlineApps
.
offlineData
"
allowed
:
"
offlineApps
.
allow
"
denied
:
"
offlineApps
.
dontAllow2
"
}
"
offline
-
app
"
:
{
label
:
"
offlineApps
.
offlineData
"
allowed
:
"
offlineApps
.
allow
"
denied
:
"
offlineApps
.
dontAllow2
"
}
"
desktop
-
notification
"
:
{
label
:
"
desktopNotification
.
notifications
"
allowed
:
"
desktopNotification2
.
allow
"
denied
:
"
desktopNotification2
.
dontAllow
"
}
plugins
:
{
label
:
"
clickToPlayPlugins
.
plugins
"
allowed
:
"
clickToPlayPlugins
.
activate
"
denied
:
"
clickToPlayPlugins
.
dontActivate
"
}
"
native
-
intent
"
:
{
label
:
"
helperapps
.
openWithList2
"
allowed
:
"
helperapps
.
always
"
denied
:
"
helperapps
.
never
"
}
}
onEvent
:
function
onEvent
(
event
data
callback
)
{
let
principal
=
BrowserApp
.
selectedBrowser
.
contentPrincipal
;
let
check
=
false
;
switch
(
event
)
{
case
"
Permissions
:
Check
"
:
check
=
true
;
case
"
Permissions
:
Get
"
:
let
permissions
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
_permissonTypes
.
length
;
i
+
+
)
{
let
type
=
this
.
_permissonTypes
[
i
]
;
let
value
=
this
.
getPermission
(
principal
type
)
;
if
(
value
=
=
Services
.
perms
.
UNKNOWN_ACTION
)
{
continue
;
}
if
(
check
)
{
GlobalEventDispatcher
.
sendRequest
(
{
type
:
"
Permissions
:
CheckResult
"
hasPermissions
:
true
}
)
;
return
;
}
let
typeStrings
=
this
.
_permissionStrings
[
type
]
;
let
label
=
Strings
.
browser
.
GetStringFromName
(
typeStrings
.
label
)
;
let
valueKey
=
value
=
=
Services
.
perms
.
ALLOW_ACTION
?
"
allowed
"
:
"
denied
"
;
let
valueString
=
Strings
.
browser
.
GetStringFromName
(
typeStrings
[
valueKey
]
)
;
permissions
.
push
(
{
type
:
type
setting
:
label
value
:
valueString
}
)
;
}
if
(
check
)
{
GlobalEventDispatcher
.
sendRequest
(
{
type
:
"
Permissions
:
CheckResult
"
hasPermissions
:
false
}
)
;
return
;
}
this
.
_currentPermissions
=
permissions
;
WindowEventDispatcher
.
sendRequest
(
{
type
:
"
Permissions
:
Data
"
permissions
:
permissions
}
)
;
break
;
case
"
Permissions
:
Clear
"
:
let
permissionsToClear
=
data
.
permissions
;
let
privacyContext
=
BrowserApp
.
selectedBrowser
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
;
for
(
let
i
=
0
;
i
<
permissionsToClear
.
length
;
i
+
+
)
{
let
indexToClear
=
permissionsToClear
[
i
]
;
let
permissionType
=
this
.
_currentPermissions
[
indexToClear
]
.
type
;
this
.
clearPermission
(
uri
permissionType
privacyContext
)
;
}
break
;
}
}
getPermission
:
function
getPermission
(
aPrincipal
aType
)
{
let
aURI
=
BrowserApp
.
selectedBrowser
.
lastURI
;
if
(
aType
=
=
"
password
"
)
{
if
(
!
Services
.
logins
.
getLoginSavingEnabled
(
aURI
.
displayPrePath
)
)
{
return
Services
.
perms
.
DENY_ACTION
;
}
if
(
Services
.
logins
.
countLogins
(
aURI
.
displayPrePath
"
"
"
"
)
)
{
return
Services
.
perms
.
ALLOW_ACTION
;
}
return
Services
.
perms
.
UNKNOWN_ACTION
;
}
if
(
aType
=
=
"
geolocation
"
)
{
return
Services
.
perms
.
testExactPermissionFromPrincipal
(
aPrincipal
aType
)
;
}
return
Services
.
perms
.
testPermissionFromPrincipal
(
aPrincipal
aType
)
;
}
clearPermission
:
function
clearPermission
(
aPrincipal
aType
aContext
)
{
if
(
aType
=
=
"
password
"
)
{
let
logins
=
Services
.
logins
.
findLogins
(
aURI
.
displayPrePath
"
"
"
"
)
;
for
(
let
i
=
0
;
i
<
logins
.
length
;
i
+
+
)
{
Services
.
logins
.
removeLogin
(
logins
[
i
]
)
;
}
Services
.
logins
.
setLoginSavingEnabled
(
aURI
.
displayPrePath
true
)
;
}
else
{
Services
.
perms
.
removeFromPrincipal
(
aPrincipal
aType
)
;
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
.
removeByDomainAndName
(
aURI
.
spec
aType
+
"
.
request
.
remember
"
aContext
)
;
}
}
}
;
