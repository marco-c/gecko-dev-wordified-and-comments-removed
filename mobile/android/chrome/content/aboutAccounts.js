"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Accounts
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
ACTION_URL_PARAM
=
"
action
"
;
const
COMMAND_LOADED
=
"
fxaccounts
:
loaded
"
;
const
log
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
bind
(
"
FxAccounts
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ParentalControls
"
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
"
nsIParentalControlsService
"
)
;
function
show
(
id
)
{
let
allTop
=
document
.
querySelectorAll
(
"
.
toplevel
"
)
;
for
(
let
elt
of
allTop
)
{
if
(
elt
.
getAttribute
(
"
id
"
)
=
=
id
)
{
elt
.
style
.
display
=
"
block
"
;
}
else
{
elt
.
style
.
display
=
"
none
"
;
}
}
if
(
id
=
=
"
spinner
"
)
{
document
.
getElementById
(
"
remote
"
)
.
style
.
display
=
"
block
"
;
document
.
getElementById
(
"
remote
"
)
.
style
.
opacity
=
0
;
}
}
var
loadedDeferred
=
null
;
function
deferTransitionToRemoteAfterLoaded
(
)
{
log
.
d
(
"
Waiting
for
LOADED
message
.
"
)
;
loadedDeferred
=
PromiseUtils
.
defer
(
)
;
loadedDeferred
.
promise
.
then
(
(
)
=
>
{
log
.
d
(
"
Got
LOADED
message
!
"
)
;
document
.
getElementById
(
"
remote
"
)
.
style
.
opacity
=
0
;
show
(
"
remote
"
)
;
document
.
getElementById
(
"
remote
"
)
.
style
.
opacity
=
1
;
}
)
.
catch
(
(
e
)
=
>
{
log
.
w
(
"
Did
not
get
LOADED
message
:
"
+
e
.
toString
(
)
)
;
}
)
;
}
function
handleLoadedMessage
(
message
)
{
loadedDeferred
.
resolve
(
)
;
}
var
wrapper
=
{
iframe
:
null
url
:
null
init
:
function
(
url
)
{
this
.
url
=
url
;
deferTransitionToRemoteAfterLoaded
(
)
;
let
iframe
=
document
.
getElementById
(
"
remote
"
)
;
this
.
iframe
=
iframe
;
let
docShell
=
this
.
iframe
.
frameLoader
.
docShell
;
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
docShell
.
addProgressListener
(
this
.
iframeListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
let
webNav
=
iframe
.
frameLoader
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
null
null
null
)
;
}
retry
:
function
(
)
{
deferTransitionToRemoteAfterLoaded
(
)
;
let
webNav
=
this
.
iframe
.
frameLoader
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
this
.
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
null
null
null
)
;
}
iframeListener
:
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
onStateChange
:
function
(
aWebProgress
aRequest
aState
aStatus
)
{
let
failure
=
false
;
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_REDIRECTING
)
)
{
failure
=
true
;
}
else
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
)
{
if
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
{
try
{
failure
=
aRequest
.
responseStatus
!
=
200
;
}
catch
(
e
)
{
failure
=
aStatus
!
=
Cr
.
NS_OK
;
}
}
}
if
(
failure
&
&
aStatus
!
=
Cr
.
NS_BINDING_ABORTED
)
{
aRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
loadedDeferred
.
reject
(
new
Error
(
"
Failed
in
onStateChange
!
"
)
)
;
show
(
"
networkError
"
)
;
}
}
onLocationChange
:
function
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
aRequest
&
&
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
aRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
loadedDeferred
.
reject
(
new
Error
(
"
Failed
in
onLocationChange
!
"
)
)
;
show
(
"
networkError
"
)
;
}
}
}
}
;
function
retry
(
)
{
log
.
i
(
"
Retrying
.
"
)
;
show
(
"
spinner
"
)
;
wrapper
.
retry
(
)
;
}
function
openPrefs
(
)
{
log
.
i
(
"
Opening
Sync
preferences
.
"
)
;
Accounts
.
launchSetup
(
)
;
}
function
getURLForAction
(
action
urlParams
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
webchannel
.
uri
"
)
;
url
=
url
+
(
url
.
endsWith
(
"
/
"
)
?
"
"
:
"
/
"
)
+
action
;
const
CONTEXT
=
"
fx_fennec_v1
"
;
const
SERVICE
=
"
sync
"
;
urlParams
=
urlParams
|
|
new
URLSearchParams
(
"
"
)
;
urlParams
.
set
(
"
service
"
SERVICE
)
;
urlParams
.
set
(
"
context
"
CONTEXT
)
;
let
urlParamStr
=
urlParams
.
toString
(
)
;
if
(
urlParamStr
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
urlParamStr
;
}
return
url
;
}
function
updateDisplayedEmail
(
user
)
{
let
emailDiv
=
document
.
getElementById
(
"
email
"
)
;
if
(
emailDiv
&
&
user
)
{
emailDiv
.
textContent
=
user
.
email
;
}
}
function
init
(
)
{
if
(
!
ParentalControls
.
isAllowed
(
ParentalControls
.
MODIFY_ACCOUNTS
)
)
{
log
.
e
(
"
This
profile
cannot
connect
to
Firefox
Accounts
:
showing
restricted
error
.
"
)
;
show
(
"
restrictedError
"
)
;
return
;
}
Accounts
.
getFirefoxAccount
(
)
.
then
(
user
=
>
{
if
(
window
.
closed
)
{
return
;
}
updateDisplayedEmail
(
user
)
;
let
urlParams
=
new
URLSearchParams
(
document
.
URL
.
split
(
"
?
"
)
[
1
]
|
|
"
"
)
;
let
action
=
urlParams
.
get
(
ACTION_URL_PARAM
)
;
urlParams
.
delete
(
ACTION_URL_PARAM
)
;
switch
(
action
)
{
case
"
signup
"
:
if
(
user
)
{
show
(
"
prefs
"
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
case
"
signin
"
:
if
(
user
)
{
show
(
"
prefs
"
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signin
"
urlParams
)
)
;
}
break
;
case
"
force_auth
"
:
if
(
user
)
{
show
(
"
spinner
"
)
;
urlParams
.
set
(
"
email
"
user
.
email
)
;
wrapper
.
init
(
getURLForAction
(
"
force_auth
"
urlParams
)
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
case
"
manage
"
:
if
(
user
)
{
show
(
"
spinner
"
)
;
urlParams
.
set
(
"
email
"
user
.
email
)
;
wrapper
.
init
(
getURLForAction
(
"
settings
"
urlParams
)
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
case
"
avatar
"
:
if
(
user
)
{
show
(
"
spinner
"
)
;
urlParams
.
set
(
"
email
"
user
.
email
)
;
wrapper
.
init
(
getURLForAction
(
"
settings
/
avatar
/
change
"
urlParams
)
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
default
:
if
(
action
)
{
log
.
w
(
"
Ignoring
unrecognized
action
:
"
+
action
)
;
}
if
(
user
)
{
show
(
"
prefs
"
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
}
}
)
.
catch
(
e
=
>
{
log
.
e
(
"
Failed
to
get
the
signed
in
user
:
"
+
e
.
toString
(
)
)
;
}
)
;
}
document
.
addEventListener
(
"
DOMContentLoaded
"
function
(
)
{
init
(
)
;
var
buttonRetry
=
document
.
getElementById
(
"
buttonRetry
"
)
;
buttonRetry
.
addEventListener
(
"
click
"
retry
)
;
var
buttonOpenPrefs
=
document
.
getElementById
(
"
buttonOpenPrefs
"
)
;
buttonOpenPrefs
.
addEventListener
(
"
click
"
openPrefs
)
;
}
{
capture
:
true
once
:
true
}
)
;
function
getBrowserMessageManager
(
)
{
let
browser
=
window
.
document
.
docShell
.
rootTreeItem
.
domWindow
.
BrowserApp
.
getBrowserForDocument
(
document
)
;
if
(
browser
)
{
return
browser
.
messageManager
;
}
return
null
;
}
var
mm
=
getBrowserMessageManager
(
)
;
if
(
mm
)
{
mm
.
addMessageListener
(
COMMAND_LOADED
handleLoadedMessage
)
;
}
else
{
log
.
e
(
"
No
messageManager
not
listening
for
LOADED
message
!
"
)
;
}
window
.
addEventListener
(
"
unload
"
function
(
event
)
{
try
{
let
mm
=
getBrowserMessageManager
(
)
;
if
(
mm
)
{
mm
.
removeMessageListener
(
COMMAND_LOADED
handleLoadedMessage
)
;
}
}
catch
(
e
)
{
log
.
w
(
"
Not
removing
listener
for
LOADED
message
:
"
+
e
.
toString
(
)
)
;
}
}
)
;
