"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Accounts
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
ACTION_URL_PARAM
=
"
action
"
;
const
COMMAND_LOADED
=
"
fxaccounts
:
loaded
"
;
const
log
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
bind
(
"
FxAccounts
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ParentalControls
"
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
"
nsIParentalControlsService
"
)
;
function
show
(
id
)
{
let
allTop
=
document
.
querySelectorAll
(
"
.
toplevel
"
)
;
for
(
let
elt
of
allTop
)
{
if
(
elt
.
getAttribute
(
"
id
"
)
=
=
id
)
{
elt
.
style
.
display
=
'
block
'
;
}
else
{
elt
.
style
.
display
=
'
none
'
;
}
}
if
(
id
=
=
'
spinner
'
)
{
document
.
getElementById
(
'
remote
'
)
.
style
.
display
=
'
block
'
;
document
.
getElementById
(
'
remote
'
)
.
style
.
opacity
=
0
;
}
}
var
loadedDeferred
=
null
;
function
deferTransitionToRemoteAfterLoaded
(
url
)
{
log
.
d
(
'
Waiting
for
LOADED
message
.
'
)
;
let
recordResultTelemetry
;
let
isCustomized
=
Services
.
prefs
.
prefHasUserValue
(
"
identity
.
fxaccounts
.
remote
.
webchannel
.
uri
"
)
;
if
(
!
isCustomized
)
{
let
key
=
Services
.
io
.
newURI
(
url
null
null
)
.
path
.
split
(
"
?
"
)
[
0
]
;
let
startTime
=
Cu
.
now
(
)
;
let
start
=
Services
.
telemetry
.
getKeyedHistogramById
(
'
ABOUT_ACCOUNTS_CONTENT_SERVER_LOAD_STARTED_COUNT
'
)
;
start
.
add
(
key
)
;
recordResultTelemetry
=
function
(
success
)
{
let
rate
=
Services
.
telemetry
.
getKeyedHistogramById
(
'
ABOUT_ACCOUNTS_CONTENT_SERVER_LOADED_RATE
'
)
;
rate
.
add
(
key
success
)
;
let
delta
=
Cu
.
now
(
)
-
startTime
;
let
time
=
success
?
Services
.
telemetry
.
getKeyedHistogramById
(
'
ABOUT_ACCOUNTS_CONTENT_SERVER_LOADED_TIME_MS
'
)
:
Services
.
telemetry
.
getKeyedHistogramById
(
'
ABOUT_ACCOUNTS_CONTENT_SERVER_FAILURE_TIME_MS
'
)
;
time
.
add
(
key
Math
.
round
(
delta
)
)
;
}
;
}
loadedDeferred
=
PromiseUtils
.
defer
(
)
;
loadedDeferred
.
promise
.
then
(
(
)
=
>
{
log
.
d
(
'
Got
LOADED
message
!
'
)
;
document
.
getElementById
(
"
remote
"
)
.
style
.
opacity
=
0
;
show
(
"
remote
"
)
;
document
.
getElementById
(
"
remote
"
)
.
style
.
opacity
=
1
;
if
(
!
isCustomized
)
{
recordResultTelemetry
(
true
)
;
}
}
)
.
catch
(
(
e
)
=
>
{
log
.
w
(
'
Did
not
get
LOADED
message
:
'
+
e
.
toString
(
)
)
;
if
(
!
isCustomized
)
{
recordResultTelemetry
(
false
)
;
}
}
)
;
}
function
handleLoadedMessage
(
message
)
{
loadedDeferred
.
resolve
(
)
;
}
;
let
wrapper
=
{
iframe
:
null
url
:
null
init
:
function
(
url
)
{
this
.
url
=
url
;
deferTransitionToRemoteAfterLoaded
(
this
.
url
)
;
let
iframe
=
document
.
getElementById
(
"
remote
"
)
;
this
.
iframe
=
iframe
;
this
.
iframe
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
;
let
docShell
=
this
.
iframe
.
frameLoader
.
docShell
;
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
docShell
.
addProgressListener
(
this
.
iframeListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
let
webNav
=
iframe
.
frameLoader
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
null
null
null
)
;
}
retry
:
function
(
)
{
deferTransitionToRemoteAfterLoaded
(
this
.
url
)
;
let
webNav
=
this
.
iframe
.
frameLoader
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
loadURI
(
this
.
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
null
null
null
)
;
}
iframeListener
:
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsISupports
]
)
onStateChange
:
function
(
aWebProgress
aRequest
aState
aStatus
)
{
let
failure
=
false
;
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_REDIRECTING
)
)
{
failure
=
true
;
}
else
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
)
{
if
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
{
try
{
failure
=
aRequest
.
responseStatus
!
=
200
;
}
catch
(
e
)
{
failure
=
aStatus
!
=
Components
.
results
.
NS_OK
;
}
}
}
if
(
failure
&
&
aStatus
!
=
Components
.
results
.
NS_BINDING_ABORTED
)
{
aRequest
.
cancel
(
Components
.
results
.
NS_BINDING_ABORTED
)
;
loadedDeferred
.
reject
(
new
Error
(
"
Failed
in
onStateChange
!
"
)
)
;
show
(
"
networkError
"
)
;
}
}
onLocationChange
:
function
(
aWebProgress
aRequest
aLocation
aFlags
)
{
if
(
aRequest
&
&
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
aRequest
.
cancel
(
Components
.
results
.
NS_BINDING_ABORTED
)
;
loadedDeferred
.
reject
(
new
Error
(
"
Failed
in
onLocationChange
!
"
)
)
;
show
(
"
networkError
"
)
;
}
}
onProgressChange
:
function
(
)
{
}
onStatusChange
:
function
(
)
{
}
onSecurityChange
:
function
(
)
{
}
}
}
;
function
retry
(
)
{
log
.
i
(
"
Retrying
.
"
)
;
show
(
"
spinner
"
)
;
wrapper
.
retry
(
)
;
}
function
openPrefs
(
)
{
log
.
i
(
"
Opening
Sync
preferences
.
"
)
;
Accounts
.
launchSetup
(
)
;
}
function
getURLForAction
(
action
urlParams
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
webchannel
.
uri
"
)
;
url
=
url
+
(
url
.
endsWith
(
"
/
"
)
?
"
"
:
"
/
"
)
+
action
;
const
CONTEXT
=
"
fx_fennec_v1
"
;
const
SERVICE
=
"
sync
"
;
urlParams
=
urlParams
|
|
new
URLSearchParams
(
"
"
)
;
urlParams
.
set
(
'
service
'
SERVICE
)
;
urlParams
.
set
(
'
context
'
CONTEXT
)
;
let
urlParamStr
=
urlParams
.
toString
(
)
;
if
(
urlParamStr
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
urlParamStr
;
}
return
url
;
}
function
updateDisplayedEmail
(
user
)
{
let
emailDiv
=
document
.
getElementById
(
"
email
"
)
;
if
(
emailDiv
&
&
user
)
{
emailDiv
.
textContent
=
user
.
email
;
}
}
function
init
(
)
{
if
(
!
ParentalControls
.
isAllowed
(
ParentalControls
.
MODIFY_ACCOUNTS
)
)
{
log
.
e
(
"
This
profile
cannot
connect
to
Firefox
Accounts
:
showing
restricted
error
.
"
)
;
show
(
"
restrictedError
"
)
;
return
;
}
Accounts
.
getFirefoxAccount
(
)
.
then
(
user
=
>
{
if
(
window
.
closed
)
{
return
;
}
updateDisplayedEmail
(
user
)
;
let
urlParams
=
new
URLSearchParams
(
document
.
URL
.
split
(
"
?
"
)
[
1
]
|
|
"
"
)
;
let
action
=
urlParams
.
get
(
ACTION_URL_PARAM
)
;
urlParams
.
delete
(
ACTION_URL_PARAM
)
;
switch
(
action
)
{
case
"
signup
"
:
if
(
user
)
{
show
(
"
prefs
"
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
case
"
signin
"
:
if
(
user
)
{
show
(
"
prefs
"
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signin
"
urlParams
)
)
;
}
break
;
case
"
force_auth
"
:
if
(
user
)
{
show
(
"
spinner
"
)
;
urlParams
.
set
(
"
email
"
user
.
email
)
;
wrapper
.
init
(
getURLForAction
(
"
force_auth
"
urlParams
)
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
case
"
manage
"
:
if
(
user
)
{
show
(
"
spinner
"
)
;
urlParams
.
set
(
"
email
"
user
.
email
)
;
wrapper
.
init
(
getURLForAction
(
"
settings
"
urlParams
)
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
case
"
avatar
"
:
if
(
user
)
{
show
(
"
spinner
"
)
;
urlParams
.
set
(
"
email
"
user
.
email
)
;
wrapper
.
init
(
getURLForAction
(
"
settings
/
avatar
/
change
"
urlParams
)
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
default
:
if
(
action
)
{
log
.
w
(
"
Ignoring
unrecognized
action
:
"
+
action
)
;
}
if
(
user
)
{
show
(
"
prefs
"
)
;
}
else
{
show
(
"
spinner
"
)
;
wrapper
.
init
(
getURLForAction
(
"
signup
"
urlParams
)
)
;
}
break
;
}
}
)
.
catch
(
e
=
>
{
log
.
e
(
"
Failed
to
get
the
signed
in
user
:
"
+
e
.
toString
(
)
)
;
}
)
;
}
document
.
addEventListener
(
"
DOMContentLoaded
"
function
onload
(
)
{
document
.
removeEventListener
(
"
DOMContentLoaded
"
onload
true
)
;
init
(
)
;
var
buttonRetry
=
document
.
getElementById
(
'
buttonRetry
'
)
;
buttonRetry
.
addEventListener
(
'
click
'
retry
)
;
var
buttonOpenPrefs
=
document
.
getElementById
(
'
buttonOpenPrefs
'
)
;
buttonOpenPrefs
.
addEventListener
(
'
click
'
openPrefs
)
;
}
true
)
;
function
getBrowserMessageManager
(
)
{
let
browser
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
.
BrowserApp
.
getBrowserForDocument
(
document
)
;
if
(
browser
)
{
return
browser
.
messageManager
;
}
return
null
;
}
let
mm
=
getBrowserMessageManager
(
)
;
if
(
mm
)
{
mm
.
addMessageListener
(
COMMAND_LOADED
handleLoadedMessage
)
;
}
else
{
log
.
e
(
'
No
messageManager
not
listening
for
LOADED
message
!
'
)
;
}
window
.
addEventListener
(
"
unload
"
function
(
event
)
{
try
{
let
mm
=
getBrowserMessageManager
(
)
;
if
(
mm
)
{
mm
.
removeMessageListener
(
COMMAND_LOADED
handleLoadedMessage
)
;
}
}
catch
(
e
)
{
log
.
w
(
'
Not
removing
listener
for
LOADED
message
:
'
+
e
.
toString
(
)
)
;
}
}
)
;
