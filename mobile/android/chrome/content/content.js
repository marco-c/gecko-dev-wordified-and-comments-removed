var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AboutReader
"
"
resource
:
/
/
gre
/
modules
/
AboutReader
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ReaderMode
"
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
LoginManagerContent
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerContent
.
jsm
"
)
;
var
dump
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
d
.
bind
(
null
"
Content
"
)
;
var
global
=
this
;
var
AboutReaderListener
=
{
_articlePromise
:
null
_isLeavingReaderableReaderMode
:
false
init
:
function
(
)
{
addEventListener
(
"
AboutReaderContentLoaded
"
this
false
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
false
)
;
addEventListener
(
"
pageshow
"
this
false
)
;
addEventListener
(
"
pagehide
"
this
false
)
;
addMessageListener
(
"
Reader
:
ToggleReaderMode
"
this
)
;
addMessageListener
(
"
Reader
:
PushState
"
this
)
;
}
receiveMessage
:
function
(
message
)
{
switch
(
message
.
name
)
{
case
"
Reader
:
ToggleReaderMode
"
:
let
url
=
content
.
document
.
location
.
href
;
if
(
!
this
.
isAboutReader
)
{
this
.
_articlePromise
=
ReaderMode
.
parseDocument
(
content
.
document
)
.
catch
(
Cu
.
reportError
)
;
ReaderMode
.
enterReaderMode
(
docShell
content
)
;
}
else
{
this
.
_isLeavingReaderableReaderMode
=
this
.
isReaderableAboutReader
;
ReaderMode
.
leaveReaderMode
(
docShell
content
)
;
}
break
;
case
"
Reader
:
PushState
"
:
this
.
updateReaderButton
(
!
!
(
message
.
data
&
&
message
.
data
.
isArticle
)
)
;
break
;
}
}
get
isAboutReader
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
;
}
get
isReaderableAboutReader
(
)
{
return
this
.
isAboutReader
&
&
!
content
.
document
.
documentElement
.
dataset
.
isError
;
}
get
isErrorPage
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
|
|
content
.
document
.
documentURI
.
startsWith
(
"
about
:
certerror
"
)
|
|
content
.
document
.
documentURI
.
startsWith
(
"
about
:
blocked
"
)
;
}
handleEvent
:
function
(
aEvent
)
{
if
(
aEvent
.
originalTarget
.
defaultView
!
=
content
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
AboutReaderContentLoaded
"
:
if
(
!
this
.
isAboutReader
)
{
return
;
}
if
(
content
.
document
.
body
)
{
new
AboutReader
(
global
content
this
.
_articlePromise
)
;
this
.
_articlePromise
=
null
;
}
break
;
case
"
pagehide
"
:
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
this
.
_isLeavingReaderableReaderMode
}
)
;
if
(
this
.
_isLeavingReaderableReaderMode
)
{
this
.
_isLeavingReaderableReaderMode
=
false
;
}
break
;
case
"
pageshow
"
:
if
(
aEvent
.
persisted
)
{
this
.
updateReaderButton
(
)
;
}
break
;
case
"
DOMContentLoaded
"
:
this
.
updateReaderButton
(
)
;
break
;
}
}
updateReaderButton
:
function
(
forceNonArticle
)
{
if
(
this
.
isErrorPage
)
{
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
false
}
)
;
}
else
if
(
!
ReaderMode
.
isEnabledForParseOnLoad
|
|
this
.
isAboutReader
|
|
!
(
content
.
document
instanceof
content
.
HTMLDocument
)
|
|
content
.
document
.
mozSyntheticDocument
)
{
return
;
}
else
{
this
.
scheduleReadabilityCheckPostPaint
(
forceNonArticle
)
;
}
}
cancelPotentialPendingReadabilityCheck
:
function
(
)
{
if
(
this
.
_pendingReadabilityCheck
)
{
removeEventListener
(
"
MozAfterPaint
"
this
.
_pendingReadabilityCheck
)
;
delete
this
.
_pendingReadabilityCheck
;
}
}
scheduleReadabilityCheckPostPaint
:
function
(
forceNonArticle
)
{
if
(
this
.
_pendingReadabilityCheck
)
{
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
}
this
.
_pendingReadabilityCheck
=
this
.
onPaintWhenWaitedFor
.
bind
(
this
forceNonArticle
)
;
addEventListener
(
"
MozAfterPaint
"
this
.
_pendingReadabilityCheck
)
;
}
onPaintWhenWaitedFor
:
function
(
forceNonArticle
event
)
{
if
(
!
event
.
clientRects
.
length
)
{
return
;
}
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
if
(
ReaderMode
.
isProbablyReaderable
(
content
.
document
)
)
{
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
true
}
)
;
}
else
if
(
forceNonArticle
)
{
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
false
}
)
;
}
}
}
;
AboutReaderListener
.
init
(
)
;
addMessageListener
(
"
RemoteLogins
:
fillForm
"
function
(
message
)
{
LoginManagerContent
.
receiveMessage
(
message
content
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
this
"
tab
-
content
-
frameloader
-
created
"
)
;
