ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AboutReader
"
"
resource
:
/
/
gre
/
modules
/
AboutReader
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ReaderMode
"
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginManagerContent
"
"
resource
:
/
/
gre
/
modules
/
LoginManagerContent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPipNSSBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
pipnss
/
locale
/
pipnss
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gNSSErrorsBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
pipnss
/
locale
/
nsserrors
.
properties
"
)
;
}
)
;
var
dump
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
d
.
bind
(
null
"
Content
"
)
;
var
global
=
this
;
var
AboutBlockedSiteListener
=
{
init
(
chromeGlobal
)
{
addEventListener
(
"
AboutBlockedLoaded
"
this
false
true
)
;
}
get
isBlockedSite
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
blocked
"
)
;
}
handleEvent
(
aEvent
)
{
if
(
!
this
.
isBlockedSite
)
{
return
;
}
if
(
aEvent
.
type
!
=
"
AboutBlockedLoaded
"
)
{
return
;
}
let
provider
=
"
"
;
if
(
docShell
.
failedChannel
)
{
let
classifiedChannel
=
docShell
.
failedChannel
.
QueryInterface
(
Ci
.
nsIClassifiedChannel
)
;
if
(
classifiedChannel
)
{
provider
=
classifiedChannel
.
matchedProvider
;
}
}
let
advisoryUrl
=
Services
.
prefs
.
getCharPref
(
"
browser
.
safebrowsing
.
provider
.
"
+
provider
+
"
.
advisoryURL
"
"
"
)
;
if
(
!
advisoryUrl
)
{
let
el
=
content
.
document
.
getElementById
(
"
advisoryDesc
"
)
;
el
.
remove
(
)
;
return
;
}
let
advisoryLinkText
=
Services
.
prefs
.
getCharPref
(
"
browser
.
safebrowsing
.
provider
.
"
+
provider
+
"
.
advisoryName
"
"
"
)
;
if
(
!
advisoryLinkText
)
{
let
el
=
content
.
document
.
getElementById
(
"
advisoryDesc
"
)
;
el
.
remove
(
)
;
return
;
}
let
anchorEl
=
content
.
document
.
getElementById
(
"
advisory_provider
"
)
;
anchorEl
.
setAttribute
(
"
href
"
advisoryUrl
)
;
anchorEl
.
textContent
=
advisoryLinkText
;
}
}
;
AboutBlockedSiteListener
.
init
(
)
;
const
SEC_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
NSS_SEC_ERROR_BASE
;
const
MOZILLA_PKIX_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
MOZILLA_PKIX_ERROR_BASE
;
const
SEC_ERROR_EXPIRED_CERTIFICATE
=
SEC_ERROR_BASE
+
11
;
const
SEC_ERROR_UNKNOWN_ISSUER
=
SEC_ERROR_BASE
+
13
;
const
SEC_ERROR_UNTRUSTED_ISSUER
=
SEC_ERROR_BASE
+
20
;
const
SEC_ERROR_UNTRUSTED_CERT
=
SEC_ERROR_BASE
+
21
;
const
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
=
SEC_ERROR_BASE
+
30
;
const
SEC_ERROR_CA_CERT_INVALID
=
SEC_ERROR_BASE
+
36
;
const
SEC_ERROR_OCSP_FUTURE_RESPONSE
=
SEC_ERROR_BASE
+
131
;
const
SEC_ERROR_OCSP_OLD_RESPONSE
=
SEC_ERROR_BASE
+
132
;
const
SEC_ERROR_REUSED_ISSUER_AND_SERIAL
=
SEC_ERROR_BASE
+
138
;
const
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
=
SEC_ERROR_BASE
+
176
;
const
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
=
MOZILLA_PKIX_ERROR_BASE
+
5
;
const
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
=
MOZILLA_PKIX_ERROR_BASE
+
6
;
const
SSL_ERROR_BASE
=
Ci
.
nsINSSErrorsService
.
NSS_SSL_ERROR_BASE
;
const
SSL_ERROR_SSL_DISABLED
=
SSL_ERROR_BASE
+
20
;
const
SSL_ERROR_SSL2_DISABLED
=
SSL_ERROR_BASE
+
14
;
var
AboutNetErrorListener
=
{
init
(
chromeGlobal
)
{
addEventListener
(
"
AboutNetErrorLoad
"
this
false
true
)
;
}
get
isNetErrorSite
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
;
}
_getErrorMessageFromCode
(
securityInfo
doc
)
{
let
uri
=
Services
.
io
.
newURI
(
doc
.
location
)
;
let
hostString
=
uri
.
host
;
if
(
uri
.
port
!
=
443
&
&
uri
.
port
!
=
-
1
)
{
hostString
+
=
"
:
"
+
uri
.
port
;
}
let
id_str
=
"
"
;
switch
(
securityInfo
.
errorCode
)
{
case
SSL_ERROR_SSL_DISABLED
:
id_str
=
"
PSMERR_SSL_Disabled
"
;
break
;
case
SSL_ERROR_SSL2_DISABLED
:
id_str
=
"
PSMERR_SSL2_Disabled
"
;
break
;
case
SEC_ERROR_REUSED_ISSUER_AND_SERIAL
:
id_str
=
"
PSMERR_HostReusedIssuerSerial
"
;
break
;
}
let
nss_error_id_str
=
securityInfo
.
errorCodeString
;
let
msg2
=
"
"
;
if
(
id_str
)
{
msg2
=
gPipNSSBundle
.
GetStringFromName
(
id_str
)
+
"
\
n
"
;
}
else
if
(
nss_error_id_str
)
{
msg2
=
gNSSErrorsBundle
.
GetStringFromName
(
nss_error_id_str
)
+
"
\
n
"
;
}
if
(
!
msg2
)
{
msg2
=
nss_error_id_str
;
}
let
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
SSLConnectionErrorPrefix2
"
[
hostString
msg2
]
2
)
;
if
(
nss_error_id_str
)
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorCodePrefix3
"
[
nss_error_id_str
]
1
)
;
}
return
msg
;
}
handleEvent
(
aEvent
)
{
if
(
!
this
.
isNetErrorSite
)
{
return
;
}
if
(
aEvent
.
type
!
=
"
AboutNetErrorLoad
"
)
{
return
;
}
let
{
securityInfo
}
=
docShell
.
failedChannel
;
if
(
securityInfo
)
{
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
let
msg
=
this
.
_getErrorMessageFromCode
(
securityInfo
aEvent
.
originalTarget
.
ownerGlobal
)
;
let
id
=
content
.
document
.
getElementById
(
"
errorShortDescText
"
)
;
id
.
textContent
=
msg
;
}
}
}
;
AboutNetErrorListener
.
init
(
)
;
var
AboutCertErrorListener
=
{
init
(
chromeGlobal
)
{
addEventListener
(
"
AboutCertErrorLoad
"
this
false
true
)
;
}
get
isCertErrorSite
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
certerror
"
)
;
}
_setTechDetailsMsgPart1
(
hostString
sslStatus
technicalInfo
doc
)
{
let
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorIntro
"
[
hostString
]
1
)
;
msg
+
=
"
\
n
\
n
"
;
if
(
sslStatus
.
isUntrusted
&
&
!
sslStatus
.
serverCert
.
isSelfSigned
)
{
switch
(
securityInfo
.
errorCode
)
{
case
SEC_ERROR_UNKNOWN_ISSUER
:
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_UnknownIssuer
"
)
+
"
\
n
"
;
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_UnknownIssuer2
"
)
+
"
\
n
"
;
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_UnknownIssuer3
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_CA_CERT_INVALID
:
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_CaInvalid
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_UNTRUSTED_ISSUER
:
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_Issuer
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
:
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_SignatureAlgorithmDisabled
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_ExpiredIssuer
"
)
+
"
\
n
"
;
break
;
case
SEC_ERROR_UNTRUSTED_CERT
:
default
:
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_Untrusted
"
)
+
"
\
n
"
;
}
}
if
(
sslStatus
.
isUntrusted
&
&
sslStatus
.
serverCert
.
isSelfSigned
)
{
msg
+
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorTrust_SelfSigned
"
)
+
"
\
n
"
;
}
technicalInfo
.
appendChild
(
doc
.
createTextNode
(
msg
)
)
;
}
_setTechDetails
(
sslStatus
securityInfo
location
)
{
if
(
!
securityInfo
|
|
!
sslStatus
|
|
!
location
)
{
return
;
}
let
validity
=
sslStatus
.
serverCert
.
validity
;
let
doc
=
content
.
document
;
let
searchParams
=
new
URLSearchParams
(
doc
.
documentURI
.
split
(
"
?
"
)
[
1
]
)
;
let
cssClass
=
searchParams
.
get
(
"
s
"
)
;
let
error
=
searchParams
.
get
(
"
e
"
)
;
let
technicalInfo
=
doc
.
getElementById
(
"
technicalContentText
"
)
;
let
uri
=
Services
.
io
.
newURI
(
location
)
;
let
hostString
=
uri
.
host
;
if
(
uri
.
port
!
=
443
&
&
uri
.
port
!
=
-
1
)
{
hostString
+
=
"
:
"
+
uri
.
port
;
}
this
.
_setTechDetailsMsgPart1
(
hostString
sslStatus
technicalInfo
doc
)
;
if
(
sslStatus
.
isDomainMismatch
)
{
let
subjectAltNamesList
=
sslStatus
.
serverCert
.
subjectAltNames
;
let
subjectAltNames
=
subjectAltNamesList
.
split
(
"
"
)
;
let
numSubjectAltNames
=
subjectAltNames
.
length
;
let
msgPrefix
=
"
"
;
if
(
numSubjectAltNames
!
=
0
)
{
if
(
numSubjectAltNames
=
=
1
)
{
msgPrefix
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorMismatchSinglePrefix
"
)
;
let
okHost
=
subjectAltNamesList
;
let
href
=
"
"
;
let
thisHost
=
doc
.
location
.
hostname
;
let
proto
=
doc
.
location
.
protocol
+
"
/
/
"
;
okHost
=
okHost
.
replace
(
/
^
\
*
\
.
/
"
www
.
"
)
;
if
(
okHost
.
endsWith
(
"
.
"
+
thisHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
thisHost
.
endsWith
(
"
.
"
+
okHost
)
)
{
href
=
proto
+
okHost
;
}
if
(
href
&
&
cssClass
!
=
"
expertBadCert
"
)
{
doc
.
getElementById
(
"
technicalContentText
"
)
.
style
.
display
=
"
block
"
;
}
if
(
href
)
{
let
referrerlink
=
doc
.
createElement
(
"
a
"
)
;
referrerlink
.
append
(
subjectAltNamesList
+
"
\
n
"
)
;
referrerlink
.
title
=
subjectAltNamesList
;
referrerlink
.
id
=
"
cert_domain_link
"
;
referrerlink
.
href
=
href
;
let
fragment
=
BrowserUtils
.
getLocalizedFragment
(
doc
msgPrefix
referrerlink
)
;
technicalInfo
.
appendChild
(
fragment
)
;
}
else
{
let
fragment
=
BrowserUtils
.
getLocalizedFragment
(
doc
msgPrefix
subjectAltNamesList
)
;
technicalInfo
.
appendChild
(
fragment
)
;
}
technicalInfo
.
append
(
"
\
n
"
)
;
}
else
{
let
msg
=
gPipNSSBundle
.
GetStringFromName
(
"
certErrorMismatchMultiple
"
)
+
"
\
n
"
;
for
(
let
i
=
0
;
i
<
numSubjectAltNames
;
i
+
+
)
{
msg
+
=
subjectAltNames
[
i
]
;
if
(
i
!
=
(
numSubjectAltNames
-
1
)
)
{
msg
+
=
"
"
;
}
}
technicalInfo
.
append
(
msg
+
"
\
n
"
)
;
}
}
else
{
let
msg
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorMismatch
"
[
hostString
]
1
)
;
technicalInfo
.
append
(
msg
+
"
\
n
"
)
;
}
}
if
(
sslStatus
.
isNotValidAtThisTime
)
{
let
nowTime
=
new
Date
(
)
.
getTime
(
)
*
1000
;
let
dateOptions
=
{
year
:
"
numeric
"
month
:
"
long
"
day
:
"
numeric
"
hour
:
"
numeric
"
minute
:
"
numeric
"
}
;
let
now
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
dateOptions
)
.
format
(
new
Date
(
)
)
;
let
msg
=
"
"
;
if
(
validity
.
notBefore
)
{
if
(
nowTime
>
validity
.
notAfter
)
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorExpiredNow
"
[
validity
.
notAfterLocalTime
now
]
2
)
+
"
\
n
"
;
}
else
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorNotYetValidNow
"
[
validity
.
notBeforeLocalTime
now
]
2
)
+
"
\
n
"
;
}
}
else
{
msg
+
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorExpiredNow
"
[
"
"
now
]
2
)
+
"
\
n
"
;
}
technicalInfo
.
append
(
msg
)
;
}
technicalInfo
.
append
(
"
\
n
"
)
;
let
errorCodeMsg
=
gPipNSSBundle
.
formatStringFromName
(
"
certErrorCodePrefix3
"
[
securityInfo
.
errorCodeString
]
1
)
;
technicalInfo
.
append
(
errorCodeMsg
)
;
}
handleEvent
(
aEvent
)
{
if
(
!
this
.
isCertErrorSite
)
{
return
;
}
if
(
aEvent
.
type
!
=
"
AboutCertErrorLoad
"
)
{
return
;
}
let
ownerDoc
=
aEvent
.
originalTarget
.
ownerGlobal
;
let
securityInfo
=
docShell
.
failedChannel
&
&
docShell
.
failedChannel
.
securityInfo
;
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
.
QueryInterface
(
Ci
.
nsISerializable
)
;
let
sslStatus
=
securityInfo
.
QueryInterface
(
Ci
.
nsISSLStatusProvider
)
.
SSLStatus
;
this
.
_setTechDetails
(
sslStatus
securityInfo
ownerDoc
.
location
.
href
)
;
}
}
;
AboutCertErrorListener
.
init
(
)
;
var
AboutReaderListener
=
{
_articlePromise
:
null
_isLeavingReaderableReaderMode
:
false
init
:
function
(
)
{
addEventListener
(
"
AboutReaderContentLoaded
"
this
false
true
)
;
addEventListener
(
"
DOMContentLoaded
"
this
false
)
;
addEventListener
(
"
pageshow
"
this
false
)
;
addEventListener
(
"
pagehide
"
this
false
)
;
addMessageListener
(
"
Reader
:
ToggleReaderMode
"
this
)
;
addMessageListener
(
"
Reader
:
PushState
"
this
)
;
}
receiveMessage
:
function
(
message
)
{
switch
(
message
.
name
)
{
case
"
Reader
:
ToggleReaderMode
"
:
let
url
=
content
.
document
.
location
.
href
;
if
(
!
this
.
isAboutReader
)
{
this
.
_articlePromise
=
ReaderMode
.
parseDocument
(
content
.
document
)
.
catch
(
Cu
.
reportError
)
;
ReaderMode
.
enterReaderMode
(
docShell
content
)
;
}
else
{
this
.
_isLeavingReaderableReaderMode
=
this
.
isReaderableAboutReader
;
ReaderMode
.
leaveReaderMode
(
docShell
content
)
;
}
break
;
case
"
Reader
:
PushState
"
:
this
.
updateReaderButton
(
!
!
(
message
.
data
&
&
message
.
data
.
isArticle
)
)
;
break
;
}
}
get
isAboutReader
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
reader
"
)
;
}
get
isReaderableAboutReader
(
)
{
return
this
.
isAboutReader
&
&
!
content
.
document
.
documentElement
.
dataset
.
isError
;
}
get
isErrorPage
(
)
{
return
content
.
document
.
documentURI
.
startsWith
(
"
about
:
neterror
"
)
|
|
content
.
document
.
documentURI
.
startsWith
(
"
about
:
certerror
"
)
|
|
content
.
document
.
documentURI
.
startsWith
(
"
about
:
blocked
"
)
;
}
handleEvent
:
function
(
aEvent
)
{
if
(
aEvent
.
originalTarget
.
defaultView
!
=
content
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
AboutReaderContentLoaded
"
:
if
(
!
this
.
isAboutReader
)
{
return
;
}
if
(
content
.
document
.
body
)
{
new
AboutReader
(
global
content
this
.
_articlePromise
)
;
this
.
_articlePromise
=
null
;
}
break
;
case
"
pagehide
"
:
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
this
.
_isLeavingReaderableReaderMode
}
)
;
if
(
this
.
_isLeavingReaderableReaderMode
)
{
this
.
_isLeavingReaderableReaderMode
=
false
;
}
break
;
case
"
pageshow
"
:
if
(
aEvent
.
persisted
)
{
this
.
updateReaderButton
(
)
;
}
break
;
case
"
DOMContentLoaded
"
:
this
.
updateReaderButton
(
)
;
break
;
}
}
updateReaderButton
:
function
(
forceNonArticle
)
{
if
(
this
.
isErrorPage
)
{
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
false
}
)
;
}
else
if
(
!
ReaderMode
.
isEnabledForParseOnLoad
|
|
this
.
isAboutReader
|
|
!
(
content
.
document
instanceof
content
.
HTMLDocument
)
|
|
content
.
document
.
mozSyntheticDocument
)
{
}
else
{
this
.
scheduleReadabilityCheckPostPaint
(
forceNonArticle
)
;
}
}
cancelPotentialPendingReadabilityCheck
:
function
(
)
{
if
(
this
.
_pendingReadabilityCheck
)
{
removeEventListener
(
"
MozAfterPaint
"
this
.
_pendingReadabilityCheck
)
;
delete
this
.
_pendingReadabilityCheck
;
}
}
scheduleReadabilityCheckPostPaint
:
function
(
forceNonArticle
)
{
if
(
this
.
_pendingReadabilityCheck
)
{
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
}
this
.
_pendingReadabilityCheck
=
this
.
onPaintWhenWaitedFor
.
bind
(
this
forceNonArticle
)
;
addEventListener
(
"
MozAfterPaint
"
this
.
_pendingReadabilityCheck
)
;
}
onPaintWhenWaitedFor
:
function
(
forceNonArticle
event
)
{
if
(
!
event
.
clientRects
.
length
)
{
return
;
}
this
.
cancelPotentialPendingReadabilityCheck
(
)
;
if
(
ReaderMode
.
isProbablyReaderable
(
content
.
document
)
)
{
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
true
}
)
;
}
else
if
(
forceNonArticle
)
{
sendAsyncMessage
(
"
Reader
:
UpdateReaderButton
"
{
isArticle
:
false
}
)
;
}
}
}
;
AboutReaderListener
.
init
(
)
;
addMessageListener
(
"
RemoteLogins
:
fillForm
"
function
(
message
)
{
LoginManagerContent
.
receiveMessage
(
message
content
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
this
"
tab
-
content
-
frameloader
-
created
"
)
;
