"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionData
"
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
)
;
var
ExtensionPermissions
=
{
updates
:
new
Map
(
)
_prepareStrings
(
info
)
{
let
appName
=
Strings
.
brand
.
GetStringFromName
(
"
brandShortName
"
)
;
let
info2
=
Object
.
assign
(
{
appName
addonName
:
info
.
addon
.
name
}
info
)
;
let
strings
=
ExtensionData
.
formatPermissionStrings
(
info2
Strings
.
browser
)
;
let
message
=
"
"
;
if
(
strings
.
msgs
.
length
>
0
)
{
message
=
[
strings
.
listIntro
.
.
.
strings
.
msgs
.
map
(
s
=
>
\
u2022
{
s
}
)
]
.
join
(
"
\
n
"
)
;
}
return
{
header
:
strings
.
header
|
|
strings
.
text
message
acceptText
:
strings
.
acceptText
cancelText
:
strings
.
cancelText
}
;
}
_prepareIcon
(
iconURL
)
{
if
(
iconURL
.
endsWith
(
"
.
png
"
)
)
{
return
iconURL
;
}
return
"
DEFAULT
"
;
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
webextension
-
permission
-
prompt
"
:
{
let
{
target
info
}
=
subject
.
wrappedJSObject
;
let
details
=
this
.
_prepareStrings
(
info
)
;
details
.
icon
=
this
.
_prepareIcon
(
info
.
icon
)
;
details
.
type
=
"
Extension
:
PermissionPrompt
"
;
let
accepted
=
await
EventDispatcher
.
instance
.
sendRequestForResult
(
details
)
;
if
(
accepted
)
{
info
.
resolve
(
)
;
}
else
{
info
.
reject
(
)
;
}
break
;
}
case
"
webextension
-
update
-
permissions
"
:
let
info
=
subject
.
wrappedJSObject
;
let
{
addon
resolve
reject
}
=
info
;
let
stringInfo
=
Object
.
assign
(
{
type
:
"
update
"
}
info
)
;
let
details
=
this
.
_prepareStrings
(
stringInfo
)
;
if
(
details
.
message
.
length
=
=
0
)
{
resolve
(
)
;
return
;
}
details
.
icon
=
this
.
_prepareIcon
(
addon
.
iconURL
|
|
"
dummy
.
svg
"
)
;
let
first
=
(
this
.
updates
.
size
=
=
0
)
;
this
.
updates
.
set
(
addon
.
id
{
details
resolve
reject
}
)
;
if
(
first
)
{
EventDispatcher
.
instance
.
sendRequest
(
{
type
:
"
Extension
:
ShowUpdateIcon
"
value
:
true
}
)
;
}
break
;
case
"
webextension
-
optional
-
permission
-
prompt
"
:
subject
.
wrappedJSObject
.
resolve
(
true
)
;
break
;
}
}
async
applyUpdate
(
id
)
{
if
(
!
this
.
updates
.
has
(
id
)
)
{
return
;
}
let
update
=
this
.
updates
.
get
(
id
)
;
this
.
updates
.
delete
(
id
)
;
if
(
this
.
updates
.
size
=
=
0
)
{
EventDispatcher
.
instance
.
sendRequest
(
{
type
:
"
Extension
:
ShowUpdateIcon
"
value
:
false
}
)
;
}
let
{
details
}
=
update
;
details
.
type
=
"
Extension
:
PermissionPrompt
"
;
let
accepted
=
await
EventDispatcher
.
instance
.
sendRequestForResult
(
details
)
;
if
(
accepted
)
{
update
.
resolve
(
)
;
}
else
{
update
.
reject
(
)
;
}
}
}
;
