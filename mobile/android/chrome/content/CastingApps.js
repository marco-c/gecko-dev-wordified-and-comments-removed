"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
PageActions
"
"
resource
:
/
/
gre
/
modules
/
PageActions
.
jsm
"
)
;
var
rokuDevice
=
{
id
:
"
roku
:
ecp
"
target
:
"
roku
:
ecp
"
factory
:
function
(
aService
)
{
const
{
RokuApp
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
RokuApp
.
jsm
"
)
;
return
new
RokuApp
(
aService
)
;
}
types
:
[
"
video
/
mp4
"
]
extensions
:
[
"
mp4
"
]
}
;
var
mediaPlayerDevice
=
{
id
:
"
media
:
router
"
target
:
"
media
:
router
"
factory
:
function
(
aService
)
{
const
{
MediaPlayerApp
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
MediaPlayerApp
.
jsm
"
)
;
return
new
MediaPlayerApp
(
aService
)
;
}
types
:
[
"
video
/
mp4
"
"
video
/
webm
"
"
application
/
x
-
mpegurl
"
]
extensions
:
[
"
mp4
"
"
webm
"
"
m3u
"
"
m3u8
"
]
init
:
function
(
)
{
GlobalEventDispatcher
.
registerListener
(
this
[
"
MediaPlayer
:
Added
"
"
MediaPlayer
:
Changed
"
"
MediaPlayer
:
Removed
"
]
)
;
}
onEvent
:
function
(
event
data
callback
)
{
if
(
event
=
=
=
"
MediaPlayer
:
Added
"
)
{
let
service
=
this
.
toService
(
data
)
;
SimpleServiceDiscovery
.
addService
(
service
)
;
}
else
if
(
event
=
=
=
"
MediaPlayer
:
Changed
"
)
{
let
service
=
this
.
toService
(
data
)
;
SimpleServiceDiscovery
.
updateService
(
service
)
;
}
else
if
(
event
=
=
=
"
MediaPlayer
:
Removed
"
)
{
SimpleServiceDiscovery
.
removeService
(
data
.
id
)
;
}
}
toService
:
function
(
display
)
{
return
{
location
:
display
.
location
target
:
"
media
:
router
"
friendlyName
:
display
.
friendlyName
uuid
:
display
.
uuid
manufacturer
:
display
.
manufacturer
modelName
:
display
.
modelName
}
;
}
}
;
var
CastingApps
=
{
_castMenuId
:
-
1
_blocked
:
null
_bound
:
null
_interval
:
120
*
1000
init
:
function
ca_init
(
)
{
if
(
!
this
.
isCastingEnabled
(
)
)
{
return
;
}
SimpleServiceDiscovery
.
registerDevice
(
rokuDevice
)
;
mediaPlayerDevice
.
init
(
)
;
SimpleServiceDiscovery
.
registerDevice
(
mediaPlayerDevice
)
;
SimpleServiceDiscovery
.
search
(
this
.
_interval
)
;
this
.
_castMenuId
=
NativeWindow
.
contextmenus
.
add
(
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
sendToDevice
"
)
this
.
filterCast
this
.
handleContextMenu
.
bind
(
this
)
)
;
GlobalEventDispatcher
.
registerListener
(
this
[
"
Casting
:
Play
"
"
Casting
:
Pause
"
"
Casting
:
Stop
"
]
)
;
Services
.
obs
.
addObserver
(
this
"
ssdp
-
service
-
found
"
)
;
Services
.
obs
.
addObserver
(
this
"
ssdp
-
service
-
lost
"
)
;
Services
.
obs
.
addObserver
(
this
"
application
-
background
"
)
;
Services
.
obs
.
addObserver
(
this
"
application
-
foreground
"
)
;
BrowserApp
.
deck
.
addEventListener
(
"
TabSelect
"
this
true
)
;
BrowserApp
.
deck
.
addEventListener
(
"
pageshow
"
this
true
)
;
BrowserApp
.
deck
.
addEventListener
(
"
playing
"
this
true
)
;
BrowserApp
.
deck
.
addEventListener
(
"
ended
"
this
true
)
;
BrowserApp
.
deck
.
addEventListener
(
"
MozAutoplayMediaBlocked
"
this
true
)
;
BrowserApp
.
deck
.
addEventListener
(
"
MozNoControlsVideoBindingAttached
"
this
true
true
)
;
}
_mirrorStarted
:
function
(
stopMirrorCallback
)
{
this
.
stopMirrorCallback
=
stopMirrorCallback
;
NativeWindow
.
menu
.
update
(
this
.
mirrorStartMenuId
{
visible
:
false
}
)
;
NativeWindow
.
menu
.
update
(
this
.
mirrorStopMenuId
{
visible
:
true
}
)
;
}
serviceAdded
:
function
(
aService
)
{
}
serviceLost
:
function
(
aService
)
{
}
isCastingEnabled
:
function
isCastingEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
casting
.
enabled
"
)
;
}
onEvent
:
function
(
event
message
callback
)
{
switch
(
event
)
{
case
"
Casting
:
Play
"
:
if
(
this
.
session
&
&
this
.
session
.
remoteMedia
.
status
=
=
"
paused
"
)
{
this
.
session
.
remoteMedia
.
play
(
)
;
}
break
;
case
"
Casting
:
Pause
"
:
if
(
this
.
session
&
&
this
.
session
.
remoteMedia
.
status
=
=
"
started
"
)
{
this
.
session
.
remoteMedia
.
pause
(
)
;
}
break
;
case
"
Casting
:
Stop
"
:
if
(
this
.
session
)
{
this
.
closeExternal
(
)
;
}
break
;
}
}
observe
:
function
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
ssdp
-
service
-
found
"
:
this
.
serviceAdded
(
SimpleServiceDiscovery
.
findServiceForID
(
aData
)
)
;
break
;
case
"
ssdp
-
service
-
lost
"
:
this
.
serviceLost
(
SimpleServiceDiscovery
.
findServiceForID
(
aData
)
)
;
break
;
case
"
application
-
background
"
:
this
.
_interval
=
SimpleServiceDiscovery
.
search
(
0
)
;
SimpleServiceDiscovery
.
stopSearch
(
)
;
break
;
case
"
application
-
foreground
"
:
SimpleServiceDiscovery
.
search
(
this
.
_interval
)
;
break
;
}
}
handleEvent
:
function
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
TabSelect
"
:
{
let
tab
=
BrowserApp
.
getTabForBrowser
(
aEvent
.
target
)
;
this
.
_updatePageActionForTab
(
tab
aEvent
)
;
break
;
}
case
"
pageshow
"
:
{
let
tab
=
BrowserApp
.
getTabForWindow
(
aEvent
.
originalTarget
.
defaultView
)
;
this
.
_updatePageActionForTab
(
tab
aEvent
)
;
break
;
}
case
"
playing
"
:
case
"
ended
"
:
{
let
video
=
aEvent
.
target
;
if
(
video
instanceof
HTMLVideoElement
)
{
this
.
_updatePageActionForVideo
(
aEvent
.
type
=
=
=
"
playing
"
?
video
:
null
)
;
}
break
;
}
case
"
MozAutoplayMediaBlocked
"
:
{
if
(
this
.
_bound
&
&
this
.
_bound
.
has
(
aEvent
.
target
)
)
{
aEvent
.
target
.
dispatchEvent
(
new
aEvent
.
target
.
ownerGlobal
.
CustomEvent
(
"
MozNoControlsBlockedVideo
"
)
)
;
}
else
{
if
(
!
this
.
_blocked
)
{
this
.
_blocked
=
new
WeakMap
;
}
this
.
_blocked
.
set
(
aEvent
.
target
true
)
;
}
break
;
}
case
"
MozNoControlsVideoBindingAttached
"
:
{
if
(
!
this
.
_bound
)
{
this
.
_bound
=
new
WeakMap
;
}
let
video
=
this
.
_findVideoFromEventTarget
(
aEvent
.
target
)
;
if
(
!
video
)
{
return
;
}
this
.
_bound
.
set
(
video
true
)
;
if
(
this
.
_blocked
&
&
this
.
_blocked
.
has
(
video
)
)
{
this
.
_blocked
.
delete
(
video
)
;
video
.
dispatchEvent
(
new
video
.
ownerGlobal
.
CustomEvent
(
"
MozNoControlsBlockedVideo
"
)
)
;
}
break
;
}
}
}
_findVideoFromEventTarget
(
aTarget
)
{
if
(
typeof
ShadowRoot
!
=
=
"
undefined
"
&
&
aTarget
.
parentNode
instanceof
ShadowRoot
&
&
aTarget
.
parentNode
.
host
instanceof
HTMLVideoElement
)
{
return
aTarget
.
parentNode
.
host
;
}
if
(
aTarget
instanceof
HTMLVideoElement
)
{
return
aTarget
;
}
return
null
;
}
_sendEventToVideo
:
function
_sendEventToVideo
(
aElement
aData
)
{
let
event
=
aElement
.
ownerDocument
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
"
media
-
videoCasting
"
false
true
JSON
.
stringify
(
aData
)
)
;
aElement
.
dispatchEvent
(
event
)
;
}
handleVideoBindingAttached
:
function
handleVideoBindingAttached
(
aTab
aEvent
)
{
let
video
=
this
.
_findVideoFromEventTarget
(
aEvent
.
target
)
;
if
(
!
video
)
{
return
;
}
if
(
SimpleServiceDiscovery
.
services
.
length
=
=
0
)
{
return
;
}
this
.
getVideo
(
video
0
0
(
aBundle
)
=
>
{
if
(
aBundle
)
{
this
.
_sendEventToVideo
(
aBundle
.
element
{
allow
:
true
}
)
;
}
}
)
;
}
handleVideoBindingCast
:
function
handleVideoBindingCast
(
aTab
aEvent
)
{
let
video
=
this
.
_findVideoFromEventTarget
(
aEvent
.
target
)
;
if
(
!
video
)
{
return
;
}
this
.
closeExternal
(
)
;
UITelemetry
.
addEvent
(
"
cast
.
1
"
"
button
"
null
)
;
this
.
openExternal
(
video
0
0
)
;
}
makeURI
:
function
makeURI
(
aURL
aOriginCharset
aBaseURI
)
{
return
Services
.
io
.
newURI
(
aURL
aOriginCharset
aBaseURI
)
;
}
allowableExtension
:
function
(
aURI
aExtensions
)
{
return
(
aURI
instanceof
Ci
.
nsIURL
)
&
&
aExtensions
.
includes
(
aURI
.
fileExtension
)
;
}
allowableMimeType
:
function
(
aType
aTypes
)
{
return
aTypes
.
includes
(
aType
)
;
}
getVideo
:
function
(
aElement
aX
aY
aCallback
)
{
let
extensions
=
SimpleServiceDiscovery
.
getSupportedExtensions
(
)
;
let
types
=
SimpleServiceDiscovery
.
getSupportedMimeTypes
(
)
;
if
(
aElement
instanceof
HTMLVideoElement
)
{
this
.
_getVideo
(
aElement
types
extensions
aCallback
)
;
return
;
}
try
{
let
elements
=
aElement
.
ownerDocument
.
querySelectorAll
(
"
video
"
)
;
for
(
let
element
of
elements
)
{
let
rect
=
element
.
getBoundingClientRect
(
)
;
if
(
aY
>
=
rect
.
top
&
&
aX
>
=
rect
.
left
&
&
aY
<
=
rect
.
bottom
&
&
aX
<
=
rect
.
right
)
{
this
.
_getVideo
(
element
types
extensions
aCallback
)
;
return
;
}
}
}
catch
(
e
)
{
}
}
_getContentTypeForURI
:
function
(
aURI
aElement
aCallback
)
{
let
channel
;
try
{
let
secFlags
=
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
;
if
(
aElement
.
crossOrigin
)
{
secFlags
=
Ci
.
nsILoadInfo
.
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
aElement
.
crossOrigin
=
=
=
"
use
-
credentials
"
)
{
secFlags
|
=
Ci
.
nsILoadInfo
.
SEC_COOKIES_INCLUDE
;
}
}
channel
=
NetUtil
.
newChannel
(
{
uri
:
aURI
loadingNode
:
aElement
securityFlags
:
secFlags
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_VIDEO
}
)
;
}
catch
(
e
)
{
aCallback
(
null
)
;
return
;
}
let
listener
=
{
onStartRequest
:
function
(
request
)
{
switch
(
channel
.
responseStatus
)
{
case
301
:
case
302
:
case
303
:
request
.
cancel
(
0
)
;
let
location
=
channel
.
getResponseHeader
(
"
Location
"
)
;
CastingApps
.
_getContentTypeForURI
(
CastingApps
.
makeURI
(
location
)
aElement
aCallback
)
;
break
;
default
:
aCallback
(
channel
.
contentType
)
;
request
.
cancel
(
0
)
;
break
;
}
}
onStopRequest
:
function
(
request
statusCode
)
{
}
onDataAvailable
:
function
(
request
stream
offset
count
)
{
}
}
;
if
(
channel
)
{
channel
.
asyncOpen
(
listener
)
;
}
else
{
aCallback
(
null
)
;
}
}
_getVideo
:
function
(
aElement
aTypes
aExtensions
aCallback
)
{
let
asyncURIs
=
[
]
;
let
posterURL
=
aElement
.
poster
;
let
sourceURL
=
aElement
.
src
;
if
(
!
sourceURL
)
{
sourceURL
=
aElement
.
currentSrc
;
}
if
(
sourceURL
)
{
let
sourceURI
=
this
.
makeURI
(
sourceURL
null
this
.
makeURI
(
aElement
.
baseURI
)
)
;
if
(
this
.
allowableExtension
(
sourceURI
aExtensions
)
)
{
aCallback
(
{
element
:
aElement
source
:
sourceURI
.
spec
poster
:
posterURL
sourceURI
:
sourceURI
}
)
;
return
;
}
if
(
aElement
.
type
)
{
if
(
this
.
allowableMimeType
(
aElement
.
type
aTypes
)
)
{
aCallback
(
{
element
:
aElement
source
:
sourceURI
.
spec
poster
:
posterURL
sourceURI
:
sourceURI
type
:
aElement
.
type
}
)
;
return
;
}
}
asyncURIs
.
push
(
sourceURI
)
;
}
let
sourceNodes
=
aElement
.
getElementsByTagName
(
"
source
"
)
;
for
(
let
sourceNode
of
sourceNodes
)
{
let
sourceURI
=
this
.
makeURI
(
sourceNode
.
src
null
this
.
makeURI
(
sourceNode
.
baseURI
)
)
;
if
(
this
.
allowableExtension
(
sourceURI
aExtensions
)
)
{
aCallback
(
{
element
:
aElement
source
:
sourceURI
.
spec
poster
:
posterURL
sourceURI
:
sourceURI
type
:
sourceNode
.
type
}
)
;
return
;
}
if
(
sourceNode
.
type
)
{
if
(
this
.
allowableMimeType
(
sourceNode
.
type
aTypes
)
)
{
aCallback
(
{
element
:
aElement
source
:
sourceURI
.
spec
poster
:
posterURL
sourceURI
:
sourceURI
type
:
sourceNode
.
type
}
)
;
return
;
}
}
asyncURIs
.
push
(
sourceURI
)
;
}
var
_getContentTypeForURIs
=
(
aURIs
)
=
>
{
let
sourceURI
=
aURIs
.
pop
(
)
;
this
.
_getContentTypeForURI
(
sourceURI
aElement
(
aType
)
=
>
{
if
(
this
.
allowableMimeType
(
aType
aTypes
)
)
{
aCallback
(
{
element
:
aElement
source
:
sourceURI
.
spec
poster
:
posterURL
sourceURI
:
sourceURI
type
:
aType
}
)
;
}
else
if
(
aURIs
.
length
>
0
)
{
_getContentTypeForURIs
(
aURIs
)
;
}
else
{
aCallback
(
null
)
;
}
}
)
;
}
;
if
(
asyncURIs
.
length
>
0
)
{
_getContentTypeForURIs
(
asyncURIs
)
;
}
}
isVideoCastable
:
function
(
aElement
aX
aY
)
{
if
(
aElement
instanceof
HTMLVideoElement
)
{
return
aElement
.
mozAllowCasting
;
}
try
{
let
elements
=
aElement
.
ownerDocument
.
querySelectorAll
(
"
video
"
)
;
for
(
let
element
of
elements
)
{
let
rect
=
element
.
getBoundingClientRect
(
)
;
if
(
aY
>
=
rect
.
top
&
&
aX
>
=
rect
.
left
&
&
aY
<
=
rect
.
bottom
&
&
aX
<
=
rect
.
right
)
{
return
element
.
mozAllowCasting
;
}
}
}
catch
(
e
)
{
}
return
false
;
}
filterCast
:
{
matches
:
function
(
aElement
aX
aY
)
{
if
(
SimpleServiceDiscovery
.
services
.
length
=
=
0
)
return
false
;
return
CastingApps
.
isVideoCastable
(
aElement
aX
aY
)
;
}
}
pageAction
:
{
click
:
function
(
)
{
let
browser
=
BrowserApp
.
selectedBrowser
;
if
(
!
browser
)
{
return
;
}
let
videos
=
browser
.
contentDocument
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
if
(
!
video
.
paused
&
&
video
.
mozAllowCasting
)
{
UITelemetry
.
addEvent
(
"
cast
.
1
"
"
pageaction
"
null
)
;
CastingApps
.
openExternal
(
video
0
0
)
;
return
;
}
}
}
}
_findCastableVideo
:
function
_findCastableVideo
(
aBrowser
)
{
if
(
!
aBrowser
)
{
return
null
;
}
let
castableVideo
=
null
;
let
videos
=
aBrowser
.
contentDocument
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
if
(
video
.
mozIsCasting
)
{
return
video
;
}
if
(
!
video
.
paused
&
&
video
.
mozAllowCasting
)
{
castableVideo
=
video
;
}
}
return
castableVideo
;
}
_updatePageActionForTab
:
function
_updatePageActionForTab
(
aTab
aEvent
)
{
if
(
aTab
!
=
BrowserApp
.
selectedTab
)
{
return
;
}
this
.
_updatePageAction
(
)
;
}
_updatePageActionForVideo
:
function
_updatePageActionForVideo
(
aVideo
)
{
this
.
_updatePageAction
(
aVideo
)
;
}
_updatePageAction
:
function
_updatePageAction
(
aVideo
)
{
if
(
this
.
pageAction
.
id
)
{
PageActions
.
remove
(
this
.
pageAction
.
id
)
;
delete
this
.
pageAction
.
id
;
}
if
(
!
aVideo
)
{
aVideo
=
this
.
_findCastableVideo
(
BrowserApp
.
selectedBrowser
)
;
if
(
!
aVideo
)
{
return
;
}
}
if
(
BrowserApp
.
selectedTab
!
=
BrowserApp
.
getTabForWindow
(
aVideo
.
ownerGlobal
.
top
)
)
{
return
;
}
if
(
aVideo
.
mozIsCasting
)
{
this
.
pageAction
.
id
=
PageActions
.
add
(
{
title
:
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
sendToDevice
"
)
icon
:
"
drawable
:
/
/
casting_active
"
clickCallback
:
this
.
pageAction
.
click
important
:
true
useTint
:
false
}
)
;
}
else
if
(
aVideo
.
mozAllowCasting
)
{
this
.
pageAction
.
id
=
PageActions
.
add
(
{
title
:
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
sendToDevice
"
)
icon
:
"
drawable
:
/
/
casting
"
clickCallback
:
this
.
pageAction
.
click
important
:
true
useTint
:
true
}
)
;
}
}
prompt
:
function
(
aWindow
aCallback
aFilterFunc
)
{
let
items
=
[
]
;
let
filteredServices
=
[
]
;
SimpleServiceDiscovery
.
services
.
forEach
(
function
(
aService
)
{
let
item
=
{
label
:
aService
.
friendlyName
selected
:
false
}
;
if
(
!
aFilterFunc
|
|
aFilterFunc
(
aService
)
)
{
filteredServices
.
push
(
aService
)
;
items
.
push
(
item
)
;
}
}
)
;
if
(
items
.
length
=
=
0
)
{
return
;
}
let
prompt
=
new
Prompt
(
{
window
:
aWindow
title
:
Strings
.
browser
.
GetStringFromName
(
"
casting
.
sendToDevice
"
)
}
)
.
setSingleChoiceItems
(
items
)
.
show
(
function
(
data
)
{
let
selected
=
data
.
button
;
let
service
=
selected
=
=
-
1
?
null
:
filteredServices
[
selected
]
;
if
(
aCallback
)
aCallback
(
service
)
;
}
)
;
}
handleContextMenu
:
function
(
aElement
aX
aY
)
{
UITelemetry
.
addEvent
(
"
action
.
1
"
"
contextmenu
"
null
"
web_cast
"
)
;
UITelemetry
.
addEvent
(
"
cast
.
1
"
"
contextmenu
"
null
)
;
this
.
openExternal
(
aElement
aX
aY
)
;
}
openExternal
:
function
(
aElement
aX
aY
)
{
this
.
getVideo
(
aElement
aX
aY
this
.
_openExternal
.
bind
(
this
)
)
;
}
_openExternal
:
function
(
aVideo
)
{
if
(
!
aVideo
)
{
return
;
}
function
filterFunc
(
aService
)
{
return
this
.
allowableExtension
(
aVideo
.
sourceURI
aService
.
extensions
)
|
|
this
.
allowableMimeType
(
aVideo
.
type
aService
.
types
)
;
}
this
.
prompt
(
aVideo
.
element
.
ownerGlobal
aService
=
>
{
if
(
!
aService
)
return
;
let
app
=
SimpleServiceDiscovery
.
findAppForService
(
aService
)
;
if
(
!
app
)
return
;
if
(
aVideo
.
element
)
{
aVideo
.
title
=
aVideo
.
element
.
ownerGlobal
.
top
.
document
.
title
;
if
(
!
aVideo
.
element
.
paused
)
{
aVideo
.
element
.
pause
(
)
;
}
}
app
.
stop
(
(
)
=
>
{
app
.
start
(
aStarted
=
>
{
if
(
!
aStarted
)
{
dump
(
"
CastingApps
:
Unable
to
start
app
"
)
;
return
;
}
app
.
remoteMedia
(
aRemoteMedia
=
>
{
if
(
!
aRemoteMedia
)
{
dump
(
"
CastingApps
:
Failed
to
create
remotemedia
"
)
;
return
;
}
this
.
session
=
{
service
:
aService
app
:
app
remoteMedia
:
aRemoteMedia
data
:
{
title
:
aVideo
.
title
source
:
aVideo
.
source
poster
:
aVideo
.
poster
}
videoRef
:
Cu
.
getWeakReference
(
aVideo
.
element
)
}
;
}
this
)
;
}
)
;
}
)
;
}
filterFunc
.
bind
(
this
)
)
;
}
closeExternal
:
function
(
)
{
if
(
!
this
.
session
)
{
return
;
}
this
.
session
.
remoteMedia
.
shutdown
(
)
;
this
.
_shutdown
(
)
;
}
_shutdown
:
function
(
)
{
if
(
!
this
.
session
)
{
return
;
}
this
.
session
.
app
.
stop
(
)
;
let
video
=
this
.
session
.
videoRef
.
get
(
)
;
if
(
video
)
{
this
.
_sendEventToVideo
(
video
{
active
:
false
}
)
;
this
.
_updatePageAction
(
)
;
}
delete
this
.
session
;
}
onRemoteMediaStart
:
function
(
aRemoteMedia
)
{
if
(
!
this
.
session
)
{
return
;
}
aRemoteMedia
.
load
(
this
.
session
.
data
)
;
GlobalEventDispatcher
.
sendRequest
(
{
type
:
"
Casting
:
Started
"
device
:
this
.
session
.
service
.
friendlyName
}
)
;
let
video
=
this
.
session
.
videoRef
.
get
(
)
;
if
(
video
)
{
this
.
_sendEventToVideo
(
video
{
active
:
true
}
)
;
this
.
_updatePageAction
(
video
)
;
}
}
onRemoteMediaStop
:
function
(
aRemoteMedia
)
{
GlobalEventDispatcher
.
sendRequest
(
{
type
:
"
Casting
:
Stopped
"
}
)
;
this
.
_shutdown
(
)
;
}
onRemoteMediaStatus
:
function
(
aRemoteMedia
)
{
if
(
!
this
.
session
)
{
return
;
}
let
status
=
aRemoteMedia
.
status
;
switch
(
status
)
{
case
"
started
"
:
GlobalEventDispatcher
.
sendRequest
(
{
type
:
"
Casting
:
Playing
"
}
)
;
break
;
case
"
paused
"
:
GlobalEventDispatcher
.
sendRequest
(
{
type
:
"
Casting
:
Paused
"
}
)
;
break
;
case
"
completed
"
:
this
.
closeExternal
(
)
;
break
;
}
}
}
;
