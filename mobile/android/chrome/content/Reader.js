"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Snackbars
"
"
resource
:
/
/
gre
/
modules
/
Snackbars
.
jsm
"
)
;
var
Reader
=
{
STATUS_UNFETCHED
:
0
STATUS_FETCH_FAILED_TEMPORARY
:
1
STATUS_FETCH_FAILED_PERMANENT
:
2
STATUS_FETCH_FAILED_UNSUPPORTED_FORMAT
:
3
STATUS_FETCHED_ARTICLE
:
4
get
_hasUsedToolbar
(
)
{
delete
this
.
_hasUsedToolbar
;
return
this
.
_hasUsedToolbar
=
Services
.
prefs
.
getBoolPref
(
"
reader
.
has_used_toolbar
"
)
;
}
_backPressListeners
:
[
]
_backPressViewIds
:
[
]
_addBackPressListener
:
function
(
tabId
viewId
listener
)
{
this
.
_backPressListeners
[
tabId
]
=
listener
;
this
.
_backPressViewIds
[
viewId
]
=
tabId
;
}
_removeBackPressListener
:
function
(
viewId
)
{
let
tabId
=
this
.
_backPressViewIds
[
viewId
]
;
if
(
tabId
!
=
undefined
)
{
this
.
_backPressListeners
[
tabId
]
=
null
;
delete
this
.
_backPressViewIds
[
viewId
]
;
}
}
onBackPress
:
function
(
tabId
)
{
let
listener
=
this
.
_backPressListeners
[
tabId
]
;
return
{
handled
:
(
listener
?
listener
(
)
:
false
)
}
;
}
observe
:
function
Reader_observe
(
aMessage
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
Reader
:
RemoveFromCache
"
:
{
ReaderMode
.
removeArticleFromCache
(
aData
)
.
catch
(
e
=
>
Cu
.
reportError
(
"
Error
removing
article
from
cache
:
"
+
e
)
)
;
break
;
}
case
"
Reader
:
AddToCache
"
:
{
let
tab
=
BrowserApp
.
getTabForId
(
aData
)
;
if
(
!
tab
)
{
throw
new
Error
(
"
No
tab
for
tabID
=
"
+
aData
+
"
when
trying
to
save
reader
view
article
"
)
;
}
this
.
_getArticleData
(
tab
.
browser
)
.
then
(
(
article
)
=
>
{
ReaderMode
.
storeArticleInCache
(
article
)
;
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
"
Error
storing
article
in
cache
:
"
+
e
)
)
;
break
;
}
}
}
receiveMessage
:
function
(
message
)
{
switch
(
message
.
name
)
{
case
"
Reader
:
ArticleGet
"
:
this
.
_getArticle
(
message
.
data
.
url
)
.
then
(
(
article
)
=
>
{
if
(
message
.
target
.
messageManager
)
{
message
.
target
.
messageManager
.
sendAsyncMessage
(
"
Reader
:
ArticleData
"
{
article
:
article
}
)
;
}
}
e
=
>
{
if
(
e
&
&
e
.
newURL
)
{
message
.
target
.
loadURI
(
"
about
:
reader
?
url
=
"
+
encodeURIComponent
(
e
.
newURL
)
)
;
}
}
)
;
break
;
case
"
Reader
:
DropdownClosed
"
:
{
this
.
_removeBackPressListener
(
message
.
data
)
;
break
;
}
case
"
Reader
:
DropdownOpened
"
:
{
let
tabId
=
BrowserApp
.
selectedTab
.
id
;
this
.
_addBackPressListener
(
tabId
message
.
data
(
)
=
>
{
if
(
message
.
target
.
messageManager
)
{
message
.
target
.
messageManager
.
sendAsyncMessage
(
"
Reader
:
CloseDropdown
"
)
;
return
true
;
}
return
false
;
}
)
;
break
;
}
case
"
Reader
:
FaviconRequest
"
:
{
Messaging
.
sendRequestForResult
(
{
type
:
"
Reader
:
FaviconRequest
"
url
:
message
.
data
.
url
}
)
.
then
(
data
=
>
{
message
.
target
.
messageManager
.
sendAsyncMessage
(
"
Reader
:
FaviconReturn
"
JSON
.
parse
(
data
)
)
;
}
)
;
break
;
}
case
"
Reader
:
SystemUIVisibility
"
:
Messaging
.
sendRequest
(
{
type
:
"
SystemUI
:
Visibility
"
visible
:
message
.
data
.
visible
}
)
;
break
;
case
"
Reader
:
ToolbarHidden
"
:
if
(
!
this
.
_hasUsedToolbar
)
{
Snackbars
.
show
(
Strings
.
browser
.
GetStringFromName
(
"
readerMode
.
toolbarTip
"
)
Snackbars
.
LENGTH_LONG
)
;
Services
.
prefs
.
setBoolPref
(
"
reader
.
has_used_toolbar
"
true
)
;
this
.
_hasUsedToolbar
=
true
;
}
break
;
case
"
Reader
:
UpdateReaderButton
"
:
{
let
tab
=
BrowserApp
.
getTabForBrowser
(
message
.
target
)
;
tab
.
browser
.
isArticle
=
message
.
data
.
isArticle
;
this
.
updatePageAction
(
tab
)
;
break
;
}
}
}
pageAction
:
{
readerModeCallback
:
function
(
browser
)
{
let
url
=
browser
.
currentURI
.
spec
;
if
(
url
.
startsWith
(
"
about
:
reader
"
)
)
{
UITelemetry
.
addEvent
(
"
action
.
1
"
"
button
"
"
reader_exit
"
)
;
}
else
{
UITelemetry
.
addEvent
(
"
action
.
1
"
"
button
"
"
reader_enter
"
)
;
}
browser
.
messageManager
.
sendAsyncMessage
(
"
Reader
:
ToggleReaderMode
"
)
;
}
}
updatePageAction
:
function
(
tab
)
{
if
(
!
tab
.
getActive
(
)
)
{
return
;
}
if
(
this
.
pageAction
.
id
)
{
PageActions
.
remove
(
this
.
pageAction
.
id
)
;
delete
this
.
pageAction
.
id
;
}
let
showPageAction
=
(
icon
title
)
=
>
{
this
.
pageAction
.
id
=
PageActions
.
add
(
{
icon
:
icon
title
:
title
clickCallback
:
(
)
=
>
this
.
pageAction
.
readerModeCallback
(
browser
)
important
:
true
}
)
;
}
;
let
browser
=
tab
.
browser
;
if
(
browser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
{
showPageAction
(
"
drawable
:
/
/
reader_active
"
Strings
.
reader
.
GetStringFromName
(
"
readerView
.
close
"
)
)
;
UITelemetry
.
startSession
(
"
reader
.
1
"
null
)
;
return
;
}
UITelemetry
.
stopSession
(
"
reader
.
1
"
"
"
null
)
;
if
(
browser
.
isArticle
)
{
showPageAction
(
"
drawable
:
/
/
reader
"
Strings
.
reader
.
GetStringFromName
(
"
readerView
.
enter
"
)
)
;
UITelemetry
.
addEvent
(
"
show
.
1
"
"
button
"
"
reader_available
"
)
;
}
else
{
UITelemetry
.
addEvent
(
"
show
.
1
"
"
button
"
"
reader_unavailable
"
)
;
}
}
_getArticle
:
Task
.
async
(
function
*
(
url
)
{
let
article
=
yield
ReaderMode
.
getArticleFromCache
(
url
)
;
if
(
article
)
{
return
article
;
}
return
yield
ReaderMode
.
downloadAndParseDocument
(
url
)
.
catch
(
e
=
>
{
if
(
e
&
&
e
.
newURL
)
{
throw
e
;
}
Cu
.
reportError
(
"
Error
downloading
and
parsing
document
:
"
+
e
)
;
return
null
;
}
)
;
}
)
_getArticleData
:
function
(
browser
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
browser
=
=
null
)
{
reject
(
"
_getArticleData
needs
valid
browser
"
)
;
}
let
mm
=
browser
.
messageManager
;
let
listener
=
(
message
)
=
>
{
mm
.
removeMessageListener
(
"
Reader
:
StoredArticleData
"
listener
)
;
resolve
(
message
.
data
.
article
)
;
}
;
mm
.
addMessageListener
(
"
Reader
:
StoredArticleData
"
listener
)
;
mm
.
sendAsyncMessage
(
"
Reader
:
GetStoredArticleData
"
)
;
}
)
;
}
migrateCache
:
Task
.
async
(
function
*
(
)
{
let
cacheDB
=
yield
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
window
.
indexedDB
.
open
(
"
about
:
reader
"
1
)
;
request
.
onsuccess
=
event
=
>
resolve
(
event
.
target
.
result
)
;
request
.
onerror
=
event
=
>
reject
(
request
.
error
)
;
request
.
onupgradeneeded
=
event
=
>
resolve
(
null
)
;
}
)
;
if
(
!
cacheDB
)
{
return
;
}
let
articles
=
yield
new
Promise
(
(
resolve
reject
)
=
>
{
let
articles
=
[
]
;
let
transaction
=
cacheDB
.
transaction
(
cacheDB
.
objectStoreNames
)
;
let
store
=
transaction
.
objectStore
(
cacheDB
.
objectStoreNames
[
0
]
)
;
let
request
=
store
.
openCursor
(
)
;
request
.
onsuccess
=
event
=
>
{
let
cursor
=
event
.
target
.
result
;
if
(
!
cursor
)
{
resolve
(
articles
)
;
}
else
{
articles
.
push
(
cursor
.
value
)
;
cursor
.
continue
(
)
;
}
}
;
request
.
onerror
=
event
=
>
reject
(
request
.
error
)
;
}
)
;
for
(
let
article
of
articles
)
{
yield
ReaderMode
.
storeArticleInCache
(
article
)
;
}
window
.
indexedDB
.
deleteDatabase
(
"
about
:
reader
"
)
;
}
)
}
;
