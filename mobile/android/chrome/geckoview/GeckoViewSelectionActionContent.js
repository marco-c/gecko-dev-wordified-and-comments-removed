ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewContentModule
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
class
GeckoViewSelectionActionContent
extends
GeckoViewContentModule
{
constructor
(
aModuleName
aMessageManager
)
{
super
(
aModuleName
aMessageManager
)
;
this
.
_seqNo
=
0
;
this
.
_isActive
=
false
;
this
.
_previousMessage
=
{
}
;
this
.
_actions
=
[
{
id
:
"
org
.
mozilla
.
geckoview
.
CUT
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
&
&
!
this
.
_isPasswordField
(
e
)
perform
:
_
=
>
this
.
_domWindowUtils
.
sendContentCommandEvent
(
"
cut
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COPY
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
!
this
.
_isPasswordField
(
e
)
perform
:
_
=
>
this
.
_domWindowUtils
.
sendContentCommandEvent
(
"
copy
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
PASTE
"
predicate
:
e
=
>
e
.
selectionEditable
&
&
Services
.
clipboard
.
hasDataMatchingFlavors
(
[
"
text
/
unicode
"
]
1
Ci
.
nsIClipboard
.
kGlobalClipboard
)
perform
:
_
=
>
this
.
_domWindowUtils
.
sendContentCommandEvent
(
"
paste
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
DELETE
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
_
=
>
this
.
_domWindowUtils
.
sendContentCommandEvent
(
"
delete
"
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_START
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
e
=
>
this
.
_getSelection
(
e
)
.
collapseToStart
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_END
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
e
.
selectionEditable
perform
:
e
=
>
this
.
_getSelection
(
e
)
.
collapseToEnd
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
UNSELECT
"
predicate
:
e
=
>
!
e
.
collapsed
&
&
!
e
.
selectionEditable
perform
:
e
=
>
this
.
_getSelection
(
e
)
.
removeAllRanges
(
)
}
{
id
:
"
org
.
mozilla
.
geckoview
.
SELECT_ALL
"
predicate
:
e
=
>
e
.
reason
!
=
=
"
longpressonemptycontent
"
perform
:
e
=
>
this
.
_getSelectionController
(
e
)
.
selectAll
(
)
}
]
;
}
get
_domWindowUtils
(
)
{
return
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
_isPasswordField
(
aEvent
)
{
if
(
!
aEvent
.
selectionEditable
)
{
return
false
;
}
const
win
=
aEvent
.
target
.
defaultView
;
const
focus
=
aEvent
.
target
.
activeElement
;
return
win
&
&
win
.
HTMLInputElement
&
&
focus
instanceof
win
.
HTMLInputElement
&
&
!
focus
.
mozIsTextField
(
true
)
;
}
_getSelectionController
(
aEvent
)
{
if
(
aEvent
.
selectionEditable
)
{
const
focus
=
aEvent
.
target
.
activeElement
;
if
(
focus
.
editor
)
{
return
focus
.
editor
.
selectionController
;
}
}
return
aEvent
.
target
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsISelectionDisplay
)
.
QueryInterface
(
Ci
.
nsISelectionController
)
;
}
_getSelection
(
aEvent
)
{
return
this
.
_getSelectionController
(
aEvent
)
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_NORMAL
)
;
}
_getFrameOffset
(
aEvent
)
{
const
offset
=
{
left
:
0
top
:
0
}
;
let
currentWindow
=
aEvent
.
target
.
defaultView
;
while
(
currentWindow
.
realFrameElement
)
{
const
currentRect
=
currentWindow
.
realFrameElement
.
getBoundingClientRect
(
)
;
currentWindow
=
currentWindow
.
realFrameElement
.
ownerGlobal
;
offset
.
left
+
=
currentRect
.
left
;
offset
.
top
+
=
currentRect
.
top
;
let
targetDocShell
=
currentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
targetDocShell
.
isMozBrowser
)
{
break
;
}
}
return
offset
;
}
onEnable
(
)
{
debug
onEnable
;
addEventListener
(
"
mozcaretstatechanged
"
this
{
mozSystemGroup
:
true
}
)
;
}
onDisable
(
)
{
debug
onDisable
;
removeEventListener
(
"
mozcaretstatechanged
"
this
{
mozSystemGroup
:
true
}
)
;
}
handleEvent
(
aEvent
)
{
let
reason
=
aEvent
.
reason
;
if
(
this
.
_isActive
&
&
!
aEvent
.
caretVisible
)
{
reason
=
"
visibilitychange
"
;
}
else
if
(
!
aEvent
.
collapsed
&
&
!
aEvent
.
selectionVisible
)
{
reason
=
"
invisibleselection
"
;
}
else
if
(
aEvent
.
selectionEditable
&
&
aEvent
.
collapsed
&
&
reason
!
=
=
"
longpressonemptycontent
"
&
&
reason
!
=
=
"
taponcaret
"
)
{
reason
=
"
visibilitychange
"
;
}
debug
handleEvent
:
{
reason
}
;
if
(
[
"
longpressonemptycontent
"
"
releasecaret
"
"
taponcaret
"
"
updateposition
"
]
.
includes
(
reason
)
)
{
const
actions
=
this
.
_actions
.
filter
(
action
=
>
action
.
predicate
.
call
(
this
aEvent
)
)
;
const
offset
=
this
.
_getFrameOffset
(
aEvent
)
;
const
password
=
this
.
_isPasswordField
(
aEvent
)
;
const
msg
=
{
type
:
"
GeckoView
:
ShowSelectionAction
"
seqNo
:
this
.
_seqNo
collapsed
:
aEvent
.
collapsed
editable
:
aEvent
.
selectionEditable
password
selection
:
password
?
"
"
:
aEvent
.
selectedTextContent
clientRect
:
!
aEvent
.
boundingClientRect
?
null
:
{
left
:
aEvent
.
boundingClientRect
.
left
+
offset
.
left
top
:
aEvent
.
boundingClientRect
.
top
+
offset
.
top
right
:
aEvent
.
boundingClientRect
.
right
+
offset
.
left
bottom
:
aEvent
.
boundingClientRect
.
bottom
+
offset
.
top
}
actions
:
actions
.
map
(
action
=
>
action
.
id
)
}
;
try
{
if
(
msg
.
clientRect
)
{
msg
.
clientRect
.
bottom
+
=
parseFloat
(
Services
.
prefs
.
getCharPref
(
"
layout
.
accessiblecaret
.
height
"
"
0
"
)
)
;
}
}
catch
(
e
)
{
}
if
(
this
.
_isActive
&
&
JSON
.
stringify
(
msg
)
=
=
=
this
.
_previousMessage
)
{
return
;
}
msg
.
seqNo
=
+
+
this
.
_seqNo
;
this
.
_isActive
=
true
;
this
.
_previousMessage
=
JSON
.
stringify
(
msg
)
;
this
.
eventDispatcher
.
sendRequest
(
msg
{
onSuccess
:
response
=
>
{
if
(
response
.
seqNo
!
=
=
this
.
_seqNo
)
{
return
;
}
let
action
=
actions
.
find
(
action
=
>
action
.
id
=
=
=
response
.
id
)
;
if
(
action
)
{
action
.
perform
.
call
(
this
aEvent
response
)
;
}
else
{
warn
Invalid
action
{
response
.
id
}
;
}
}
onError
:
_
=
>
{
}
}
)
;
}
else
if
(
[
"
invisibleselection
"
"
presscaret
"
"
scroll
"
"
visibilitychange
"
]
.
includes
(
reason
)
)
{
if
(
!
this
.
_isActive
)
{
return
;
}
this
.
_isActive
=
false
;
if
(
reason
!
=
=
"
invisibleselection
"
&
&
reason
!
=
=
"
scroll
"
)
{
this
.
_seqNo
+
+
;
}
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
HideSelectionAction
"
reason
:
reason
}
)
;
}
else
{
warn
Unknown
reason
:
{
reason
}
;
}
}
}
let
{
debug
warn
}
=
GeckoViewSelectionActionContent
.
initLogging
(
"
GeckoViewSelectionAction
"
)
;
let
module
=
GeckoViewSelectionActionContent
.
create
(
this
)
;
