"
use
strict
"
;
const
{
GeckoViewChildModule
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewChildModule
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeoutWithTarget
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
SessionHistory
:
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
}
)
;
const
NO_INDEX
=
Number
.
MAX_SAFE_INTEGER
;
const
LAST_INDEX
=
Number
.
MAX_SAFE_INTEGER
-
1
;
const
DEFAULT_INTERVAL_MS
=
1500
;
const
TIMEOUT_DISABLED_PREF
=
"
browser
.
sessionstore
.
debug
.
no_auto_updates
"
;
const
PREF_INTERVAL
=
"
browser
.
sessionstore
.
interval
"
;
class
Handler
{
constructor
(
store
)
{
this
.
store
=
store
;
}
get
mm
(
)
{
return
this
.
store
.
mm
;
}
get
eventDispatcher
(
)
{
return
this
.
store
.
eventDispatcher
;
}
get
messageQueue
(
)
{
return
this
.
store
.
messageQueue
;
}
get
stateChangeNotifier
(
)
{
return
this
.
store
.
stateChangeNotifier
;
}
}
class
StateChangeNotifier
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_observers
=
new
Set
(
)
;
const
ifreq
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
const
webProgress
=
ifreq
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
addObserver
(
obs
)
{
this
.
_observers
.
add
(
obs
)
;
}
notifyObservers
(
method
)
{
for
(
const
obs
of
this
.
_observers
)
{
if
(
typeof
obs
[
method
]
=
=
"
function
"
)
{
obs
[
method
]
(
)
;
}
}
}
onStateChange
(
webProgress
request
stateFlags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
webProgress
.
DOMWindow
!
=
this
.
mm
.
content
)
{
return
;
}
if
(
!
this
.
mm
.
docShell
.
hasLoadedNonBlankURI
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
notifyObservers
(
"
onPageLoadStarted
"
)
;
}
else
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
this
.
notifyObservers
(
"
onPageLoadCompleted
"
)
;
}
}
}
StateChangeNotifier
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
class
SessionHistoryListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_fromIdx
=
NO_INDEX
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
.
addSHistoryListener
(
this
)
;
this
.
mm
.
addEventListener
(
"
DOMTitleChanged
"
this
)
;
}
uninit
(
)
{
const
sessionHistory
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
sessionHistory
)
{
sessionHistory
.
legacySHistory
.
removeSHistoryListener
(
this
)
;
}
}
collect
(
)
{
if
(
this
.
mm
.
docShell
)
{
this
.
collectFrom
(
-
1
)
;
}
}
collectFrom
(
idx
)
{
if
(
this
.
_fromIdx
<
=
idx
)
{
return
;
}
this
.
_fromIdx
=
idx
;
this
.
messageQueue
.
push
(
"
historychange
"
(
)
=
>
{
if
(
this
.
_fromIdx
=
=
=
NO_INDEX
)
{
return
null
;
}
const
history
=
SessionHistory
.
collect
(
this
.
mm
.
docShell
this
.
_fromIdx
)
;
this
.
_fromIdx
=
NO_INDEX
;
return
history
;
}
)
;
}
handleEvent
(
event
)
{
this
.
collect
(
)
;
}
onPageLoadCompleted
(
)
{
this
.
collect
(
)
;
}
onPageLoadStarted
(
)
{
this
.
collect
(
)
;
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collect
(
)
;
}
OnHistoryGotoIndex
(
index
gotoURI
)
{
this
.
collect
(
)
;
}
OnHistoryPurge
(
numEntries
)
{
this
.
collect
(
)
;
}
OnHistoryReload
(
reloadURI
reloadFlags
)
{
this
.
collect
(
)
;
return
true
;
}
OnHistoryReplaceEntry
(
index
)
{
this
.
collect
(
)
;
}
}
SessionHistoryListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISHistoryListener
"
"
nsISupportsWeakReference
"
]
)
;
class
ScrollPositionListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
SessionStoreUtils
.
addDynamicFrameFilteredListener
(
this
.
mm
"
mozvisualscroll
"
this
false
true
)
;
SessionStoreUtils
.
addDynamicFrameFilteredListener
(
this
.
mm
"
mozvisualresize
"
this
false
true
)
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
}
handleEvent
(
)
{
this
.
messageQueue
.
push
(
"
scroll
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadCompleted
(
)
{
this
.
messageQueue
.
push
(
"
scroll
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadStarted
(
)
{
this
.
messageQueue
.
push
(
"
scroll
"
(
)
=
>
null
)
;
}
collect
(
)
{
let
zoom
=
1
;
const
scrolldata
=
SessionStoreUtils
.
collectScrollPosition
(
this
.
mm
.
content
)
|
|
{
}
;
const
domWindowUtils
=
this
.
mm
.
content
.
windowUtils
;
zoom
=
domWindowUtils
.
getResolution
(
)
;
scrolldata
.
zoom
=
{
}
;
scrolldata
.
zoom
.
resolution
=
zoom
;
const
displaySize
=
{
}
;
const
width
=
{
}
height
=
{
}
;
domWindowUtils
.
getContentViewerSize
(
width
height
)
;
displaySize
.
width
=
width
.
value
;
displaySize
.
height
=
height
.
value
;
scrolldata
.
zoom
.
displaySize
=
displaySize
;
return
scrolldata
;
}
}
class
FormDataListener
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
SessionStoreUtils
.
addDynamicFrameFilteredListener
(
this
.
mm
"
input
"
this
true
)
;
this
.
stateChangeNotifier
.
addObserver
(
this
)
;
}
handleEvent
(
)
{
this
.
messageQueue
.
push
(
"
formdata
"
(
)
=
>
this
.
collect
(
)
)
;
}
onPageLoadStarted
(
)
{
this
.
messageQueue
.
push
(
"
formdata
"
(
)
=
>
null
)
;
}
collect
(
)
{
return
SessionStoreUtils
.
collectFormData
(
this
.
mm
.
content
)
;
}
}
class
MessageQueue
extends
Handler
{
constructor
(
store
)
{
super
(
store
)
;
this
.
_data
=
new
Map
(
)
;
this
.
BATCH_DELAY_MS
=
1000
;
this
.
NEEDED_IDLE_PERIOD_MS
=
5
;
this
.
_timeoutWaitIdlePeriodMs
=
null
;
this
.
_timeout
=
null
;
this
.
_timeoutDisabled
=
false
;
this
.
_idleScheduled
=
false
;
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
false
)
;
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
DEFAULT_INTERVAL_MS
)
;
Services
.
prefs
.
addObserver
(
TIMEOUT_DISABLED_PREF
this
)
;
Services
.
prefs
.
addObserver
(
PREF_INTERVAL
this
)
;
}
get
timeoutDisabled
(
)
{
return
this
.
_timeoutDisabled
;
}
set
timeoutDisabled
(
val
)
{
this
.
_timeoutDisabled
=
val
;
if
(
val
&
&
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
uninit
(
)
{
this
.
cleanupTimers
(
)
;
}
cleanupTimers
(
)
{
this
.
_idleScheduled
=
false
;
if
(
this
.
_timeout
)
{
clearTimeout
(
this
.
_timeout
)
;
this
.
_timeout
=
null
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
switch
(
data
)
{
case
TIMEOUT_DISABLED_PREF
:
this
.
timeoutDisabled
=
Services
.
prefs
.
getBoolPref
(
TIMEOUT_DISABLED_PREF
false
)
;
break
;
case
PREF_INTERVAL
:
this
.
_timeoutWaitIdlePeriodMs
=
Services
.
prefs
.
getIntPref
(
PREF_INTERVAL
DEFAULT_INTERVAL_MS
)
;
break
;
default
:
debug
Received
unknown
message
:
{
data
}
;
break
;
}
}
}
push
(
key
fn
)
{
this
.
_data
.
set
(
key
fn
)
;
if
(
!
this
.
_timeout
&
&
!
this
.
_timeoutDisabled
)
{
this
.
_timeout
=
setTimeoutWithTarget
(
(
)
=
>
this
.
sendWhenIdle
(
)
this
.
BATCH_DELAY_MS
this
.
mm
.
tabEventTarget
)
;
}
}
sendWhenIdle
(
deadline
)
{
if
(
!
this
.
mm
.
content
)
{
return
;
}
if
(
deadline
)
{
if
(
deadline
.
didTimeout
|
|
deadline
.
timeRemaining
(
)
>
this
.
NEEDED_IDLE_PERIOD_MS
)
{
this
.
send
(
)
;
return
;
}
}
else
if
(
this
.
_idleScheduled
)
{
return
;
}
ChromeUtils
.
idleDispatch
(
deadline_
=
>
this
.
sendWhenIdle
(
deadline_
)
{
timeout
:
this
.
_timeoutWaitIdlePeriodMs
}
)
;
this
.
_idleScheduled
=
true
;
}
send
(
options
=
{
}
)
{
if
(
!
this
.
mm
.
docShell
)
{
return
;
}
this
.
cleanupTimers
(
)
;
const
data
=
{
}
;
for
(
const
[
key
func
]
of
this
.
_data
)
{
const
value
=
func
(
)
;
if
(
value
|
|
(
key
!
=
"
storagechange
"
&
&
key
!
=
"
historychange
"
)
)
{
data
[
key
]
=
value
;
}
}
this
.
_data
.
clear
(
)
;
try
{
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
StateUpdated
"
data
isFinal
:
options
.
isFinal
|
|
false
epoch
:
this
.
store
.
epoch
}
)
;
}
catch
(
ex
)
{
if
(
ex
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_OUT_OF_MEMORY
)
{
warn
Failed
to
save
session
state
;
}
}
}
}
class
SessionStateAggregator
extends
GeckoViewChildModule
{
constructor
(
aModuleName
aMessageManager
)
{
super
(
aModuleName
aMessageManager
)
;
this
.
mm
=
aMessageManager
;
this
.
messageQueue
=
new
MessageQueue
(
this
)
;
this
.
stateChangeNotifier
=
new
StateChangeNotifier
(
this
)
;
this
.
handlers
=
[
new
FormDataListener
(
this
)
new
SessionHistoryListener
(
this
)
new
ScrollPositionListener
(
this
)
this
.
stateChangeNotifier
this
.
messageQueue
]
;
this
.
messageManager
.
addMessageListener
(
"
GeckoView
:
FlushSessionState
"
this
)
;
}
receiveMessage
(
aMsg
)
{
debug
receiveMessage
:
{
aMsg
.
name
}
;
switch
(
aMsg
.
name
)
{
case
"
GeckoView
:
FlushSessionState
"
:
this
.
flush
(
)
;
break
;
}
}
flush
(
)
{
this
.
messageQueue
.
send
(
)
;
}
onUnload
(
)
{
this
.
messageQueue
.
send
(
{
isFinal
:
true
}
)
;
for
(
const
handler
of
this
.
handlers
)
{
if
(
handler
.
uninit
)
{
handler
.
uninit
(
)
;
}
}
}
}
class
DummySessionStateAggregator
extends
GeckoViewChildModule
{
constructor
(
aModuleName
aMessageManager
)
{
super
(
aModuleName
aMessageManager
)
;
this
.
messageManager
.
addMessageListener
(
"
GeckoView
:
FlushSessionState
"
this
)
;
}
receiveMessage
(
aMsg
)
{
debug
receiveMessage
:
{
aMsg
.
name
}
;
switch
(
aMsg
.
name
)
{
case
"
GeckoView
:
FlushSessionState
"
:
break
;
}
}
}
const
{
debug
warn
}
=
SessionStateAggregator
.
initLogging
(
"
SessionStateAggregator
"
)
;
const
module
=
Services
.
appinfo
.
sessionHistoryInParent
?
DummySessionStateAggregator
.
create
(
this
)
:
SessionStateAggregator
.
create
(
this
)
;
