package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
annotation
.
JNITarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
NetworkUtils
;
import
org
.
mozilla
.
gecko
.
util
.
NetworkUtils
.
ConnectionSubType
;
import
org
.
mozilla
.
gecko
.
util
.
NetworkUtils
.
ConnectionType
;
import
org
.
mozilla
.
gecko
.
util
.
NetworkUtils
.
NetworkStatus
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
content
.
BroadcastReceiver
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
IntentFilter
;
import
android
.
net
.
ConnectivityManager
;
import
android
.
net
.
DhcpInfo
;
import
android
.
net
.
wifi
.
WifiInfo
;
import
android
.
net
.
wifi
.
WifiManager
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
android
.
telephony
.
TelephonyManager
;
import
android
.
text
.
format
.
Formatter
;
import
android
.
util
.
Log
;
public
class
GeckoNetworkManager
extends
BroadcastReceiver
implements
BundleEventListener
{
private
static
final
String
LOGTAG
=
"
GeckoNetworkManager
"
;
private
static
final
String
LINK_DATA_CHANGED
=
"
changed
"
;
private
static
GeckoNetworkManager
instance
;
private
Context
mContext
;
public
static
void
destroy
(
)
{
if
(
instance
!
=
null
)
{
instance
.
onDestroy
(
)
;
instance
=
null
;
}
}
public
enum
ManagerState
{
OffNoListeners
OffWithListeners
OnNoListeners
OnWithListeners
}
public
enum
ManagerEvent
{
start
stop
enableNotifications
disableNotifications
receivedUpdate
}
private
ManagerState
mCurrentState
=
ManagerState
.
OffNoListeners
;
private
ConnectionType
mCurrentConnectionType
=
ConnectionType
.
NONE
;
private
ConnectionType
mPreviousConnectionType
=
ConnectionType
.
NONE
;
private
ConnectionSubType
mCurrentConnectionSubtype
=
ConnectionSubType
.
UNKNOWN
;
private
ConnectionSubType
mPreviousConnectionSubtype
=
ConnectionSubType
.
UNKNOWN
;
private
NetworkStatus
mCurrentNetworkStatus
=
NetworkStatus
.
UNKNOWN
;
private
NetworkStatus
mPreviousNetworkStatus
=
NetworkStatus
.
UNKNOWN
;
private
enum
InfoType
{
MCC
MNC
}
private
GeckoNetworkManager
(
)
{
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
Wifi
:
Enable
"
"
Wifi
:
GetIPAddress
"
)
;
}
private
void
onDestroy
(
)
{
handleManagerEvent
(
ManagerEvent
.
stop
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
"
Wifi
:
Enable
"
"
Wifi
:
GetIPAddress
"
)
;
}
public
static
GeckoNetworkManager
getInstance
(
)
{
if
(
instance
=
=
null
)
{
instance
=
new
GeckoNetworkManager
(
)
;
}
return
instance
;
}
public
double
[
]
getCurrentInformation
(
)
{
final
Context
applicationContext
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
ConnectionType
connectionType
=
mCurrentConnectionType
;
return
new
double
[
]
{
connectionType
.
value
connectionType
=
=
ConnectionType
.
WIFI
?
1
.
0
:
0
.
0
connectionType
=
=
ConnectionType
.
WIFI
?
wifiDhcpGatewayAddress
(
applicationContext
)
:
0
.
0
}
;
}
Override
public
void
onReceive
(
final
Context
aContext
final
Intent
aIntent
)
{
handleManagerEvent
(
ManagerEvent
.
receivedUpdate
)
;
}
public
void
start
(
final
Context
context
)
{
mContext
=
context
;
handleManagerEvent
(
ManagerEvent
.
start
)
;
}
public
void
stop
(
)
{
handleManagerEvent
(
ManagerEvent
.
stop
)
;
}
public
void
enableNotifications
(
)
{
handleManagerEvent
(
ManagerEvent
.
enableNotifications
)
;
}
public
void
disableNotifications
(
)
{
handleManagerEvent
(
ManagerEvent
.
disableNotifications
)
;
}
private
synchronized
boolean
handleManagerEvent
(
final
ManagerEvent
event
)
{
final
ManagerState
nextState
=
getNextState
(
mCurrentState
event
)
;
Log
.
d
(
LOGTAG
"
Incoming
event
"
+
event
+
"
for
state
"
+
mCurrentState
+
"
-
>
"
+
nextState
)
;
if
(
nextState
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Invalid
event
"
+
event
+
"
for
state
"
+
mCurrentState
)
;
return
false
;
}
final
Context
contextForAction
;
if
(
mContext
!
=
null
)
{
contextForAction
=
mContext
;
}
else
{
contextForAction
=
GeckoAppShell
.
getApplicationContext
(
)
;
}
if
(
contextForAction
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Context
is
not
available
while
processing
event
"
+
event
+
"
for
state
"
+
mCurrentState
)
;
return
false
;
}
performActionsForStateEvent
(
contextForAction
mCurrentState
event
)
;
mCurrentState
=
nextState
;
return
true
;
}
Nullable
public
static
ManagerState
getNextState
(
final
NonNull
ManagerState
currentState
final
NonNull
ManagerEvent
event
)
{
switch
(
currentState
)
{
case
OffNoListeners
:
switch
(
event
)
{
case
start
:
return
ManagerState
.
OnNoListeners
;
case
enableNotifications
:
return
ManagerState
.
OffWithListeners
;
default
:
return
null
;
}
case
OnNoListeners
:
switch
(
event
)
{
case
stop
:
return
ManagerState
.
OffNoListeners
;
case
enableNotifications
:
return
ManagerState
.
OnWithListeners
;
case
receivedUpdate
:
return
ManagerState
.
OnNoListeners
;
default
:
return
null
;
}
case
OnWithListeners
:
switch
(
event
)
{
case
stop
:
return
ManagerState
.
OffWithListeners
;
case
disableNotifications
:
return
ManagerState
.
OnNoListeners
;
case
receivedUpdate
:
return
ManagerState
.
OnWithListeners
;
default
:
return
null
;
}
case
OffWithListeners
:
switch
(
event
)
{
case
start
:
return
ManagerState
.
OnWithListeners
;
case
disableNotifications
:
return
ManagerState
.
OffNoListeners
;
default
:
return
null
;
}
default
:
throw
new
IllegalStateException
(
"
Unknown
current
state
:
"
+
currentState
.
name
(
)
)
;
}
}
private
void
performActionsForStateEvent
(
final
Context
context
final
ManagerState
currentState
final
ManagerEvent
event
)
{
switch
(
currentState
)
{
case
OffNoListeners
:
if
(
event
=
=
ManagerEvent
.
start
)
{
updateNetworkStateAndConnectionType
(
context
)
;
registerBroadcastReceiver
(
context
this
)
;
}
if
(
event
=
=
ManagerEvent
.
enableNotifications
)
{
updateNetworkStateAndConnectionType
(
context
)
;
}
break
;
case
OnNoListeners
:
if
(
event
=
=
ManagerEvent
.
receivedUpdate
)
{
updateNetworkStateAndConnectionType
(
context
)
;
sendNetworkStateToListeners
(
context
)
;
}
if
(
event
=
=
ManagerEvent
.
enableNotifications
)
{
updateNetworkStateAndConnectionType
(
context
)
;
registerBroadcastReceiver
(
context
this
)
;
}
if
(
event
=
=
ManagerEvent
.
stop
)
{
unregisterBroadcastReceiver
(
context
this
)
;
}
break
;
case
OnWithListeners
:
if
(
event
=
=
ManagerEvent
.
receivedUpdate
)
{
updateNetworkStateAndConnectionType
(
context
)
;
sendNetworkStateToListeners
(
context
)
;
}
if
(
event
=
=
ManagerEvent
.
stop
)
{
unregisterBroadcastReceiver
(
context
this
)
;
}
break
;
case
OffWithListeners
:
if
(
event
=
=
ManagerEvent
.
start
)
{
registerBroadcastReceiver
(
context
this
)
;
}
break
;
default
:
throw
new
IllegalStateException
(
"
Unknown
current
state
:
"
+
currentState
.
name
(
)
)
;
}
}
private
void
updateNetworkStateAndConnectionType
(
final
Context
context
)
{
final
ConnectivityManager
connectivityManager
=
(
ConnectivityManager
)
context
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
;
if
(
connectivityManager
=
=
null
)
{
Log
.
e
(
LOGTAG
"
ConnectivityManager
does
not
exist
.
"
)
;
}
mCurrentConnectionType
=
NetworkUtils
.
getConnectionType
(
connectivityManager
)
;
mCurrentNetworkStatus
=
NetworkUtils
.
getNetworkStatus
(
connectivityManager
)
;
mCurrentConnectionSubtype
=
NetworkUtils
.
getConnectionSubType
(
connectivityManager
)
;
Log
.
d
(
LOGTAG
"
New
network
state
:
"
+
mCurrentNetworkStatus
+
"
"
+
mCurrentConnectionType
+
"
"
+
mCurrentConnectionSubtype
)
;
}
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
private
static
native
void
onConnectionChanged
(
int
type
String
subType
boolean
isWifi
int
dhcpGateway
)
;
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
private
static
native
void
onStatusChanged
(
String
status
)
;
private
void
sendNetworkStateToListeners
(
final
Context
context
)
{
final
boolean
connectionTypeOrSubtypeChanged
=
mCurrentConnectionType
!
=
mPreviousConnectionType
|
|
mCurrentConnectionSubtype
!
=
mPreviousConnectionSubtype
;
if
(
connectionTypeOrSubtypeChanged
)
{
mPreviousConnectionType
=
mCurrentConnectionType
;
mPreviousConnectionSubtype
=
mCurrentConnectionSubtype
;
final
boolean
isWifi
=
mCurrentConnectionType
=
=
ConnectionType
.
WIFI
;
final
int
gateway
=
!
isWifi
?
0
:
wifiDhcpGatewayAddress
(
context
)
;
if
(
GeckoThread
.
isRunning
(
)
)
{
onConnectionChanged
(
mCurrentConnectionType
.
value
mCurrentConnectionSubtype
.
value
isWifi
gateway
)
;
}
else
{
GeckoThread
.
queueNativeCall
(
GeckoNetworkManager
.
class
"
onConnectionChanged
"
mCurrentConnectionType
.
value
String
.
class
mCurrentConnectionSubtype
.
value
isWifi
gateway
)
;
}
}
if
(
mCurrentNetworkStatus
=
=
mPreviousNetworkStatus
&
&
!
connectionTypeOrSubtypeChanged
)
{
return
;
}
final
String
status
;
if
(
mCurrentNetworkStatus
=
=
mPreviousNetworkStatus
)
{
status
=
LINK_DATA_CHANGED
;
}
else
{
mPreviousNetworkStatus
=
mCurrentNetworkStatus
;
status
=
mCurrentNetworkStatus
.
value
;
}
if
(
GeckoThread
.
isRunning
(
)
)
{
onStatusChanged
(
status
)
;
}
else
{
GeckoThread
.
queueNativeCall
(
GeckoNetworkManager
.
class
"
onStatusChanged
"
String
.
class
status
)
;
}
}
private
static
void
unregisterBroadcastReceiver
(
final
Context
context
final
BroadcastReceiver
receiver
)
{
context
.
unregisterReceiver
(
receiver
)
;
}
private
static
void
registerBroadcastReceiver
(
final
Context
context
final
BroadcastReceiver
receiver
)
{
final
IntentFilter
filter
=
new
IntentFilter
(
ConnectivityManager
.
CONNECTIVITY_ACTION
)
;
context
.
registerReceiver
(
receiver
filter
)
;
}
private
static
int
wifiDhcpGatewayAddress
(
final
Context
context
)
{
if
(
context
=
=
null
)
{
return
0
;
}
try
{
WifiManager
mgr
=
(
WifiManager
)
context
.
getApplicationContext
(
)
.
getSystemService
(
Context
.
WIFI_SERVICE
)
;
if
(
mgr
=
=
null
)
{
return
0
;
}
SuppressLint
(
"
MissingPermission
"
)
DhcpInfo
d
=
mgr
.
getDhcpInfo
(
)
;
if
(
d
=
=
null
)
{
return
0
;
}
return
d
.
gateway
;
}
catch
(
Exception
ex
)
{
return
0
;
}
}
SuppressLint
(
"
MissingPermission
"
)
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
Context
applicationContext
=
GeckoAppShell
.
getApplicationContext
(
)
;
switch
(
event
)
{
case
"
Wifi
:
Enable
"
:
final
WifiManager
mgr
=
(
WifiManager
)
applicationContext
.
getSystemService
(
Context
.
WIFI_SERVICE
)
;
if
(
mgr
=
=
null
)
{
return
;
}
if
(
!
mgr
.
isWifiEnabled
(
)
)
{
mgr
.
setWifiEnabled
(
true
)
;
break
;
}
Intent
intent
=
new
Intent
(
android
.
provider
.
Settings
.
ACTION_WIFI_SETTINGS
)
;
intent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
applicationContext
.
startActivity
(
intent
)
;
break
;
case
"
Wifi
:
GetIPAddress
"
:
getWifiIPAddress
(
callback
)
;
break
;
}
}
private
void
getWifiIPAddress
(
final
EventCallback
callback
)
{
final
WifiManager
mgr
=
(
WifiManager
)
GeckoAppShell
.
getApplicationContext
(
)
.
getSystemService
(
Context
.
WIFI_SERVICE
)
;
if
(
mgr
=
=
null
)
{
callback
.
sendError
(
"
Cannot
get
WifiManager
"
)
;
return
;
}
SuppressLint
(
"
MissingPermission
"
)
final
WifiInfo
info
=
mgr
.
getConnectionInfo
(
)
;
if
(
info
=
=
null
)
{
callback
.
sendError
(
"
Cannot
get
connection
info
"
)
;
return
;
}
int
ip
=
info
.
getIpAddress
(
)
;
if
(
ip
=
=
0
)
{
callback
.
sendError
(
"
Cannot
get
IPv4
address
"
)
;
return
;
}
callback
.
sendSuccess
(
Formatter
.
formatIpAddress
(
ip
)
)
;
}
private
static
int
getNetworkOperator
(
final
InfoType
type
final
Context
context
)
{
if
(
null
=
=
context
)
{
return
-
1
;
}
TelephonyManager
tel
=
(
TelephonyManager
)
context
.
getSystemService
(
Context
.
TELEPHONY_SERVICE
)
;
if
(
tel
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Telephony
service
does
not
exist
"
)
;
return
-
1
;
}
String
networkOperator
=
tel
.
getNetworkOperator
(
)
;
if
(
networkOperator
=
=
null
|
|
networkOperator
.
length
(
)
<
=
3
)
{
return
-
1
;
}
if
(
type
=
=
InfoType
.
MNC
)
{
return
Integer
.
parseInt
(
networkOperator
.
substring
(
3
)
)
;
}
if
(
type
=
=
InfoType
.
MCC
)
{
return
Integer
.
parseInt
(
networkOperator
.
substring
(
0
3
)
)
;
}
return
-
1
;
}
JNITarget
public
static
int
getMCC
(
)
{
return
getNetworkOperator
(
InfoType
.
MCC
GeckoAppShell
.
getApplicationContext
(
)
)
;
}
JNITarget
public
static
int
getMNC
(
)
{
return
getNetworkOperator
(
InfoType
.
MNC
GeckoAppShell
.
getApplicationContext
(
)
)
;
}
}
