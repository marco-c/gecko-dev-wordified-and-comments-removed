package
org
.
mozilla
.
gecko
.
gfx
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
IntBuffer
;
import
org
.
mozilla
.
gecko
.
AndroidGamepadManager
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
GeckoAccessibility
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
Point
;
import
android
.
graphics
.
PointF
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
os
.
Parcelable
;
import
android
.
support
.
v4
.
util
.
SimpleArrayMap
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
SurfaceHolder
;
import
android
.
view
.
SurfaceView
;
import
android
.
view
.
TextureView
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
InputDevice
;
import
android
.
widget
.
FrameLayout
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
public
class
LayerView
extends
FrameLayout
{
private
static
final
String
LOGTAG
=
"
GeckoLayerView
"
;
private
GeckoLayerClient
mLayerClient
;
private
PanZoomController
mPanZoomController
;
private
DynamicToolbarAnimator
mToolbarAnimator
;
private
FullScreenState
mFullScreenState
;
private
SurfaceView
mSurfaceView
;
private
TextureView
mTextureView
;
private
Listener
mListener
;
private
final
Overscroll
mOverscroll
;
private
boolean
mServerSurfaceValid
;
private
int
mWidth
mHeight
;
private
boolean
onAttachedToWindowCalled
;
private
int
mDefaultClearColor
=
Color
.
WHITE
;
GetPixelsResult
mGetPixelsResult
;
private
final
List
<
DrawListener
>
mDrawListeners
;
volatile
boolean
mCompositorCreated
;
volatile
boolean
mCompositorControllerOpen
;
final
static
int
STATIC_TOOLBAR_NEEDS_UPDATE
=
0
;
final
static
int
STATIC_TOOLBAR_READY
=
1
;
final
static
int
TOOLBAR_HIDDEN
=
2
;
final
static
int
TOOLBAR_VISIBLE
=
3
;
final
static
int
TOOLBAR_SHOW
=
4
;
final
static
int
FIRST_PAINT
=
5
;
final
static
int
REQUEST_SHOW_TOOLBAR_IMMEDIATELY
=
6
;
final
static
int
REQUEST_SHOW_TOOLBAR_ANIMATED
=
7
;
final
static
int
REQUEST_HIDE_TOOLBAR_IMMEDIATELY
=
8
;
final
static
int
REQUEST_HIDE_TOOLBAR_ANIMATED
=
9
;
final
static
int
LAYERS_UPDATED
=
10
;
final
static
int
TOOLBAR_SNAPSHOT_FAILED
=
11
;
final
static
int
COMPOSITOR_CONTROLLER_OPEN
=
20
;
final
static
int
IS_COMPOSITOR_CONTROLLER_OPEN
=
21
;
private
void
postCompositorMessage
(
final
int
message
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mCompositor
.
sendToolbarAnimatorMessage
(
message
)
;
}
}
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
boolean
isCompositorReady
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mCompositorCreated
&
&
mCompositorControllerOpen
;
}
class
Compositor
extends
JNIObject
{
public
Compositor
(
)
{
}
boolean
isReady
(
)
{
return
isCompositorReady
(
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
(
calledFrom
=
"
any
"
dispatchTo
=
"
gecko
"
)
native
void
attachToJava
(
GeckoLayerClient
layerClient
NativePanZoomController
npzc
)
;
WrapForJNI
(
calledFrom
=
"
any
"
dispatchTo
=
"
gecko_priority
"
)
native
void
onSizeChanged
(
int
windowWidth
int
windowHeight
int
screenWidth
int
screenHeight
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
proxy
"
)
native
void
createCompositor
(
int
width
int
height
Object
surface
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
syncPauseCompositor
(
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
syncResumeResizeCompositor
(
int
width
int
height
Object
surface
)
;
WrapForJNI
(
calledFrom
=
"
any
"
dispatchTo
=
"
current
"
)
native
void
syncInvalidateAndScheduleComposite
(
)
;
WrapForJNI
(
calledFrom
=
"
any
"
dispatchTo
=
"
current
"
)
native
void
setMaxToolbarHeight
(
int
height
)
;
WrapForJNI
(
calledFrom
=
"
any
"
dispatchTo
=
"
current
"
)
native
void
setPinned
(
boolean
pinned
int
reason
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
sendToolbarAnimatorMessage
(
int
message
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
void
recvToolbarAnimatorMessage
(
int
message
)
{
handleToolbarAnimatorMessage
(
message
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
setDefaultClearColor
(
int
color
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
requestScreenPixels
(
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
void
recvScreenPixels
(
int
width
int
height
int
[
]
pixels
)
{
if
(
mGetPixelsResult
!
=
null
)
{
mGetPixelsResult
.
onPixelsResult
(
width
height
IntBuffer
.
wrap
(
pixels
)
)
;
mGetPixelsResult
=
null
;
}
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
enableLayerUpdateNotifications
(
boolean
enable
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
sendToolbarPixelsToCompositor
(
final
int
width
final
int
height
final
int
[
]
pixels
)
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
void
reattach
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
updateCompositor
(
)
;
}
}
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
void
destroy
(
)
{
LayerView
.
this
.
mCompositorCreated
=
false
;
LayerView
.
this
.
mCompositorControllerOpen
=
false
;
LayerView
.
this
.
mLayerClient
.
setGeckoReady
(
false
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
LayerView
.
this
.
mDrawListeners
.
clear
(
)
;
disposeNative
(
)
;
}
}
)
;
}
}
void
handleToolbarAnimatorMessage
(
int
message
)
{
switch
(
message
)
{
case
STATIC_TOOLBAR_NEEDS_UPDATE
:
Bitmap
bm
=
mToolbarAnimator
.
getBitmapOfToolbarChrome
(
)
;
if
(
bm
=
=
null
)
{
postCompositorMessage
(
TOOLBAR_SNAPSHOT_FAILED
)
;
break
;
}
final
int
width
=
bm
.
getWidth
(
)
;
final
int
height
=
bm
.
getHeight
(
)
;
int
[
]
pixels
=
new
int
[
bm
.
getByteCount
(
)
/
4
]
;
try
{
bm
.
getPixels
(
pixels
0
width
0
0
width
height
)
;
mCompositor
.
sendToolbarPixelsToCompositor
(
width
height
pixels
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Caught
exception
while
getting
toolbar
pixels
from
Bitmap
:
"
+
e
.
toString
(
)
)
;
}
break
;
case
STATIC_TOOLBAR_READY
:
mToolbarAnimator
.
onToggleChrome
(
false
)
;
mListener
.
surfaceChanged
(
)
;
postCompositorMessage
(
TOOLBAR_HIDDEN
)
;
break
;
case
TOOLBAR_SHOW
:
mToolbarAnimator
.
onToggleChrome
(
true
)
;
mListener
.
surfaceChanged
(
)
;
postCompositorMessage
(
TOOLBAR_VISIBLE
)
;
break
;
case
FIRST_PAINT
:
setSurfaceBackgroundColor
(
Color
.
TRANSPARENT
)
;
break
;
case
LAYERS_UPDATED
:
for
(
DrawListener
listener
:
mDrawListeners
)
{
listener
.
drawFinished
(
)
;
}
break
;
case
COMPOSITOR_CONTROLLER_OPEN
:
if
(
mCompositorControllerOpen
)
{
break
;
}
mCompositorControllerOpen
=
true
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mCompositor
.
setDefaultClearColor
(
mDefaultClearColor
)
;
mCompositor
.
enableLayerUpdateNotifications
(
!
mDrawListeners
.
isEmpty
(
)
)
;
mToolbarAnimator
.
updateCompositor
(
)
;
updateCompositor
(
)
;
}
}
)
;
break
;
default
:
Log
.
e
(
LOGTAG
"
Unhandled
Toolbar
Animator
Message
:
"
+
message
)
;
break
;
}
}
private
final
Compositor
mCompositor
=
new
Compositor
(
)
;
public
boolean
shouldUseTextureView
(
)
{
return
false
;
}
public
LayerView
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
mFullScreenState
=
FullScreenState
.
NONE
;
mOverscroll
=
new
OverscrollEdgeEffect
(
this
)
;
mDrawListeners
=
new
ArrayList
<
DrawListener
>
(
)
;
}
public
LayerView
(
Context
context
)
{
this
(
context
null
)
;
}
public
void
initializeView
(
)
{
mLayerClient
=
new
GeckoLayerClient
(
getContext
(
)
this
)
;
if
(
mOverscroll
!
=
null
)
{
mLayerClient
.
setOverscrollHandler
(
mOverscroll
)
;
}
mPanZoomController
=
mLayerClient
.
getPanZoomController
(
)
;
mToolbarAnimator
=
mLayerClient
.
getDynamicToolbarAnimator
(
)
;
mToolbarAnimator
.
notifyCompositorCreated
(
mCompositor
)
;
setFocusable
(
true
)
;
setFocusableInTouchMode
(
true
)
;
GeckoAccessibility
.
setDelegate
(
this
)
;
}
public
void
setIsLongpressEnabled
(
final
boolean
isLongpressEnabled
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mPanZoomController
.
setIsLongpressEnabled
(
isLongpressEnabled
)
;
}
}
)
;
}
private
static
Point
getEventRadius
(
MotionEvent
event
)
{
return
new
Point
(
(
int
)
event
.
getToolMajor
(
)
/
2
(
int
)
event
.
getToolMinor
(
)
/
2
)
;
}
public
void
showSurface
(
)
{
mSurfaceView
.
setVisibility
(
View
.
VISIBLE
)
;
}
public
void
hideSurface
(
)
{
mSurfaceView
.
setVisibility
(
View
.
INVISIBLE
)
;
}
public
void
destroy
(
)
{
if
(
mLayerClient
!
=
null
)
{
mLayerClient
.
destroy
(
)
;
}
}
Override
public
void
dispatchDraw
(
final
Canvas
canvas
)
{
super
.
dispatchDraw
(
canvas
)
;
if
(
mLayerClient
!
=
null
&
&
mOverscroll
!
=
null
)
{
mOverscroll
.
draw
(
canvas
getViewportMetrics
(
)
)
;
}
}
Override
public
boolean
onTouchEvent
(
MotionEvent
event
)
{
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
)
{
requestFocus
(
)
;
}
if
(
!
mLayerClient
.
isGeckoReady
(
)
)
{
return
true
;
}
if
(
mPanZoomController
!
=
null
&
&
mPanZoomController
.
onTouchEvent
(
event
)
)
{
return
true
;
}
return
false
;
}
Override
public
boolean
onHoverEvent
(
MotionEvent
event
)
{
if
(
event
.
getSource
(
)
=
=
InputDevice
.
SOURCE_TOUCHSCREEN
&
&
!
GeckoAccessibility
.
isEnabled
(
)
)
{
return
false
;
}
if
(
!
mLayerClient
.
isGeckoReady
(
)
)
{
return
true
;
}
else
if
(
mPanZoomController
!
=
null
&
&
mPanZoomController
.
onMotionEvent
(
event
)
)
{
return
true
;
}
return
false
;
}
Override
public
boolean
onGenericMotionEvent
(
MotionEvent
event
)
{
if
(
AndroidGamepadManager
.
handleMotionEvent
(
event
)
)
{
return
true
;
}
if
(
!
mLayerClient
.
isGeckoReady
(
)
)
{
return
true
;
}
if
(
mPanZoomController
!
=
null
&
&
mPanZoomController
.
onMotionEvent
(
event
)
)
{
return
true
;
}
return
false
;
}
Override
protected
void
onRestoreInstanceState
(
final
Parcelable
state
)
{
if
(
onAttachedToWindowCalled
)
{
attachCompositor
(
)
;
}
super
.
onRestoreInstanceState
(
state
)
;
}
Override
protected
void
onAttachedToWindow
(
)
{
super
.
onAttachedToWindow
(
)
;
setDescendantFocusability
(
FOCUS_BLOCK_DESCENDANTS
)
;
if
(
shouldUseTextureView
(
)
)
{
mTextureView
=
new
TextureView
(
getContext
(
)
)
;
mTextureView
.
setSurfaceTextureListener
(
new
SurfaceTextureListener
(
)
)
;
mTextureView
.
setBackgroundColor
(
Color
.
WHITE
)
;
addView
(
mTextureView
ViewGroup
.
LayoutParams
.
MATCH_PARENT
ViewGroup
.
LayoutParams
.
MATCH_PARENT
)
;
}
else
{
setWillNotCacheDrawing
(
false
)
;
mSurfaceView
=
new
LayerSurfaceView
(
getContext
(
)
this
)
;
mSurfaceView
.
setBackgroundColor
(
Color
.
WHITE
)
;
addView
(
mSurfaceView
new
ViewGroup
.
LayoutParams
(
ViewGroup
.
LayoutParams
.
MATCH_PARENT
ViewGroup
.
LayoutParams
.
MATCH_PARENT
)
)
;
SurfaceHolder
holder
=
mSurfaceView
.
getHolder
(
)
;
holder
.
addCallback
(
new
SurfaceListener
(
)
)
;
}
attachCompositor
(
)
;
onAttachedToWindowCalled
=
true
;
}
Override
protected
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
onAttachedToWindowCalled
=
false
;
}
GeckoLayerClient
getLayerClient
(
)
{
return
mLayerClient
;
}
boolean
isGeckoReady
(
)
{
return
mLayerClient
.
isGeckoReady
(
)
;
}
public
PanZoomController
getPanZoomController
(
)
{
return
mPanZoomController
;
}
public
DynamicToolbarAnimator
getDynamicToolbarAnimator
(
)
{
return
mToolbarAnimator
;
}
public
ImmutableViewportMetrics
getViewportMetrics
(
)
{
return
mLayerClient
.
getViewportMetrics
(
)
;
}
public
Matrix
getMatrixForLayerRectToViewRect
(
)
{
return
mLayerClient
.
getMatrixForLayerRectToViewRect
(
)
;
}
public
void
setSurfaceBackgroundColor
(
int
newColor
)
{
if
(
mSurfaceView
!
=
null
)
{
mSurfaceView
.
setBackgroundColor
(
newColor
)
;
}
}
public
void
requestRender
(
)
{
if
(
isCompositorReady
(
)
)
{
mCompositor
.
syncInvalidateAndScheduleComposite
(
)
;
}
}
public
interface
GetPixelsResult
{
public
void
onPixelsResult
(
int
width
int
height
IntBuffer
pixels
)
;
}
RobocopTarget
public
void
getPixels
(
final
GetPixelsResult
getPixelsResult
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
getPixels
(
getPixelsResult
)
;
}
}
)
;
return
;
}
if
(
isCompositorReady
(
)
)
{
mGetPixelsResult
=
getPixelsResult
;
mCompositor
.
requestScreenPixels
(
)
;
}
else
{
getPixelsResult
.
onPixelsResult
(
0
0
null
)
;
}
}
public
void
setListener
(
Listener
listener
)
{
mListener
=
listener
;
}
Listener
getListener
(
)
{
return
mListener
;
}
private
void
attachCompositor
(
)
{
final
NativePanZoomController
npzc
=
(
NativePanZoomController
)
mPanZoomController
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
mCompositor
.
attachToJava
(
mLayerClient
npzc
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mCompositor
"
attachToJava
"
GeckoLayerClient
.
class
mLayerClient
NativePanZoomController
.
class
npzc
)
;
}
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
protected
Object
getCompositor
(
)
{
return
mCompositor
;
}
void
serverSurfaceChanged
(
int
newWidth
int
newHeight
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mWidth
=
newWidth
;
mHeight
=
newHeight
;
mServerSurfaceValid
=
true
;
updateCompositor
(
)
;
}
void
updateCompositor
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isCompositorReady
(
)
)
{
if
(
!
mServerSurfaceValid
)
{
return
;
}
mCompositor
.
syncResumeResizeCompositor
(
mWidth
mHeight
getSurface
(
)
)
;
return
;
}
if
(
!
mCompositorCreated
&
&
mServerSurfaceValid
&
&
getLayerClient
(
)
.
isGeckoReady
(
)
)
{
mCompositorCreated
=
true
;
mCompositor
.
createCompositor
(
mWidth
mHeight
getSurface
(
)
)
;
}
if
(
mCompositorCreated
&
&
!
mCompositorControllerOpen
)
{
mCompositor
.
sendToolbarAnimatorMessage
(
IS_COMPOSITOR_CONTROLLER_OPEN
)
;
}
}
private
void
onSizeChanged
(
int
width
int
height
)
{
if
(
!
mServerSurfaceValid
|
|
mSurfaceView
=
=
null
)
{
surfaceChanged
(
width
height
)
;
return
;
}
if
(
isCompositorReady
(
)
)
{
mCompositor
.
syncResumeResizeCompositor
(
width
height
getSurface
(
)
)
;
}
if
(
mOverscroll
!
=
null
)
{
mOverscroll
.
setSize
(
width
height
)
;
}
}
private
void
surfaceChanged
(
int
width
int
height
)
{
serverSurfaceChanged
(
width
height
)
;
if
(
mListener
!
=
null
)
{
mListener
.
surfaceChanged
(
)
;
}
if
(
mOverscroll
!
=
null
)
{
mOverscroll
.
setSize
(
width
height
)
;
}
}
void
notifySizeChanged
(
int
windowWidth
int
windowHeight
int
screenWidth
int
screenHeight
)
{
mCompositor
.
onSizeChanged
(
windowWidth
windowHeight
screenWidth
screenHeight
)
;
}
void
serverSurfaceDestroyed
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isCompositorReady
(
)
)
{
mCompositor
.
syncPauseCompositor
(
)
;
}
mServerSurfaceValid
=
false
;
}
private
void
onDestroyed
(
)
{
serverSurfaceDestroyed
(
)
;
}
public
Object
getNativeWindow
(
)
{
if
(
mSurfaceView
!
=
null
)
return
mSurfaceView
.
getHolder
(
)
;
return
mTextureView
.
getSurfaceTexture
(
)
;
}
public
Object
getSurface
(
)
{
if
(
mSurfaceView
!
=
null
)
{
return
mSurfaceView
.
getHolder
(
)
.
getSurface
(
)
;
}
return
null
;
}
public
interface
Listener
{
void
surfaceChanged
(
)
;
}
private
class
SurfaceListener
implements
SurfaceHolder
.
Callback
{
Override
public
void
surfaceChanged
(
SurfaceHolder
holder
int
format
int
width
int
height
)
{
onSizeChanged
(
width
height
)
;
}
Override
public
void
surfaceCreated
(
SurfaceHolder
holder
)
{
}
Override
public
void
surfaceDestroyed
(
SurfaceHolder
holder
)
{
onDestroyed
(
)
;
}
}
private
class
LayerSurfaceView
extends
SurfaceView
{
private
LayerView
mParent
;
public
LayerSurfaceView
(
Context
context
LayerView
parent
)
{
super
(
context
)
;
mParent
=
parent
;
}
Override
protected
void
onLayout
(
boolean
changed
int
left
int
top
int
right
int
bottom
)
{
super
.
onLayout
(
changed
left
top
right
bottom
)
;
if
(
changed
&
&
mParent
.
mServerSurfaceValid
)
{
mParent
.
surfaceChanged
(
right
-
left
bottom
-
top
)
;
}
}
}
private
class
SurfaceTextureListener
implements
TextureView
.
SurfaceTextureListener
{
Override
public
void
onSurfaceTextureAvailable
(
SurfaceTexture
surface
int
width
int
height
)
{
onSizeChanged
(
width
height
)
;
}
Override
public
boolean
onSurfaceTextureDestroyed
(
SurfaceTexture
surface
)
{
onDestroyed
(
)
;
return
true
;
}
Override
public
void
onSurfaceTextureSizeChanged
(
SurfaceTexture
surface
int
width
int
height
)
{
onSizeChanged
(
width
height
)
;
}
Override
public
void
onSurfaceTextureUpdated
(
SurfaceTexture
surface
)
{
}
}
RobocopTarget
public
void
addDrawListener
(
final
DrawListener
listener
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
addDrawListener
(
listener
)
;
}
}
)
;
return
;
}
boolean
wasEmpty
=
mDrawListeners
.
isEmpty
(
)
;
mDrawListeners
.
add
(
listener
)
;
if
(
isCompositorReady
(
)
&
&
wasEmpty
)
{
mCompositor
.
enableLayerUpdateNotifications
(
true
)
;
}
}
RobocopTarget
public
void
removeDrawListener
(
final
DrawListener
listener
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
removeDrawListener
(
listener
)
;
}
}
)
;
return
;
}
boolean
notEmpty
=
mDrawListeners
.
isEmpty
(
)
;
mDrawListeners
.
remove
(
listener
)
;
if
(
isCompositorReady
(
)
&
&
notEmpty
&
&
mDrawListeners
.
isEmpty
(
)
)
{
mCompositor
.
enableLayerUpdateNotifications
(
false
)
;
}
}
RobocopTarget
public
static
interface
DrawListener
{
public
void
drawFinished
(
)
;
}
Override
public
void
setOverScrollMode
(
int
overscrollMode
)
{
super
.
setOverScrollMode
(
overscrollMode
)
;
}
Override
public
int
getOverScrollMode
(
)
{
return
super
.
getOverScrollMode
(
)
;
}
public
float
getZoomFactor
(
)
{
return
getLayerClient
(
)
.
getViewportMetrics
(
)
.
zoomFactor
;
}
Override
public
void
onFocusChanged
(
boolean
gainFocus
int
direction
Rect
previouslyFocusedRect
)
{
super
.
onFocusChanged
(
gainFocus
direction
previouslyFocusedRect
)
;
GeckoAccessibility
.
onLayerViewFocusChanged
(
gainFocus
)
;
}
public
void
setFullScreenState
(
FullScreenState
state
)
{
mFullScreenState
=
state
;
}
public
boolean
isFullScreen
(
)
{
return
mFullScreenState
!
=
FullScreenState
.
NONE
;
}
public
void
setMaxToolbarHeight
(
int
maxHeight
)
{
mToolbarAnimator
.
setMaxToolbarHeight
(
maxHeight
)
;
}
public
int
getCurrentToolbarHeight
(
)
{
return
mToolbarAnimator
.
getCurrentToolbarHeight
(
)
;
}
public
void
setClearColor
(
final
int
color
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
setClearColor
(
color
)
;
}
}
)
;
return
;
}
mDefaultClearColor
=
color
;
if
(
isCompositorReady
(
)
)
{
mCompositor
.
setDefaultClearColor
(
mDefaultClearColor
)
;
}
}
}
