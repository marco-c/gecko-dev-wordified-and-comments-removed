package
org
.
mozilla
.
gecko
.
mozglue
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
InputStream
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Locale
;
import
java
.
util
.
zip
.
ZipEntry
;
import
java
.
util
.
zip
.
ZipFile
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Environment
;
import
java
.
util
.
ArrayList
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
annotation
.
JNITarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
geckoview
.
BuildConfig
;
public
final
class
GeckoLoader
{
private
static
final
String
LOGTAG
=
"
GeckoLoader
"
;
private
static
File
sCacheFile
;
private
static
File
sGREDir
;
private
static
boolean
sSQLiteLibsLoaded
;
private
static
boolean
sNSSLibsLoaded
;
private
static
boolean
sMozGlueLoaded
;
private
GeckoLoader
(
)
{
}
public
static
File
getCacheDir
(
Context
context
)
{
if
(
sCacheFile
=
=
null
)
{
sCacheFile
=
context
.
getCacheDir
(
)
;
}
return
sCacheFile
;
}
public
static
File
getGREDir
(
Context
context
)
{
if
(
sGREDir
=
=
null
)
{
sGREDir
=
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
)
;
}
return
sGREDir
;
}
private
static
void
setupDownloadEnvironment
(
final
Context
context
)
{
try
{
File
downloadDir
=
Environment
.
getExternalStoragePublicDirectory
(
Environment
.
DIRECTORY_DOWNLOADS
)
;
File
updatesDir
=
context
.
getExternalFilesDir
(
Environment
.
DIRECTORY_DOWNLOADS
)
;
if
(
downloadDir
=
=
null
)
{
downloadDir
=
new
File
(
Environment
.
getExternalStorageDirectory
(
)
.
getPath
(
)
"
download
"
)
;
}
if
(
updatesDir
=
=
null
)
{
updatesDir
=
downloadDir
;
}
putenv
(
"
DOWNLOADS_DIRECTORY
=
"
+
downloadDir
.
getPath
(
)
)
;
putenv
(
"
UPDATES_DIRECTORY
=
"
+
updatesDir
.
getPath
(
)
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
No
download
directory
found
.
"
e
)
;
}
}
private
static
void
delTree
(
File
file
)
{
if
(
file
.
isDirectory
(
)
)
{
File
children
[
]
=
file
.
listFiles
(
)
;
for
(
File
child
:
children
)
{
delTree
(
child
)
;
}
}
file
.
delete
(
)
;
}
private
static
File
getTmpDir
(
Context
context
)
{
File
tmpDir
=
context
.
getDir
(
"
tmpdir
"
Context
.
MODE_PRIVATE
)
;
File
oldDir
=
new
File
(
tmpDir
.
getParentFile
(
)
"
app_tmp
"
)
;
if
(
oldDir
.
exists
(
)
)
{
delTree
(
oldDir
)
;
}
return
tmpDir
;
}
public
synchronized
static
void
setupGeckoEnvironment
(
final
Context
context
final
String
profilePath
final
Collection
<
String
>
env
)
{
for
(
final
String
e
:
env
)
{
putenv
(
e
)
;
}
try
{
final
File
dataDir
=
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
)
;
putenv
(
"
MOZ_ANDROID_DATA_DIR
=
"
+
dataDir
.
getCanonicalPath
(
)
)
;
}
catch
(
final
java
.
io
.
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
resolve
app
data
directory
"
)
;
}
putenv
(
"
MOZ_ANDROID_PACKAGE_NAME
=
"
+
context
.
getPackageName
(
)
)
;
setupDownloadEnvironment
(
context
)
;
putenv
(
"
HOME
=
"
+
profilePath
)
;
File
f
=
getTmpDir
(
context
)
;
if
(
!
f
.
exists
(
)
)
{
f
.
mkdirs
(
)
;
}
putenv
(
"
TMPDIR
=
"
+
f
.
getPath
(
)
)
;
f
=
Environment
.
getDownloadCacheDirectory
(
)
;
putenv
(
"
EXTERNAL_STORAGE
=
"
+
f
.
getPath
(
)
)
;
f
=
context
.
getCacheDir
(
)
;
putenv
(
"
CACHE_DIRECTORY
=
"
+
f
.
getPath
(
)
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
17
)
{
android
.
os
.
UserManager
um
=
(
android
.
os
.
UserManager
)
context
.
getSystemService
(
Context
.
USER_SERVICE
)
;
if
(
um
!
=
null
)
{
putenv
(
"
MOZ_ANDROID_USER_SERIAL_NUMBER
=
"
+
um
.
getSerialNumberForUser
(
android
.
os
.
Process
.
myUserHandle
(
)
)
)
;
}
else
{
Log
.
d
(
LOGTAG
"
Unable
to
obtain
user
manager
service
on
a
device
with
SDK
version
"
+
Build
.
VERSION
.
SDK_INT
)
;
}
}
putenv
(
"
LANG
=
"
+
Locale
.
getDefault
(
)
.
toString
(
)
)
;
loadLibsSetupLocked
(
context
)
;
}
private
static
void
loadLibsSetupLocked
(
Context
context
)
{
putenv
(
"
GRE_HOME
=
"
+
getGREDir
(
context
)
.
getPath
(
)
)
;
putenv
(
"
MOZ_LINKER_CACHE
=
"
+
getCacheDir
(
context
)
.
getPath
(
)
)
;
putenv
(
"
MOZ_LINKER_EXTRACT
=
1
"
)
;
}
RobocopTarget
public
synchronized
static
void
loadSQLiteLibs
(
final
Context
context
final
String
apkName
)
{
if
(
sSQLiteLibsLoaded
)
{
return
;
}
loadMozGlue
(
context
)
;
loadLibsSetupLocked
(
context
)
;
loadSQLiteLibsNative
(
apkName
)
;
sSQLiteLibsLoaded
=
true
;
}
public
synchronized
static
void
loadNSSLibs
(
final
Context
context
final
String
apkName
)
{
if
(
sNSSLibsLoaded
)
{
return
;
}
loadMozGlue
(
context
)
;
loadLibsSetupLocked
(
context
)
;
loadNSSLibsNative
(
apkName
)
;
sNSSLibsLoaded
=
true
;
}
SuppressWarnings
(
"
deprecation
"
)
private
static
final
String
getCPUABI
(
)
{
return
android
.
os
.
Build
.
CPU_ABI
;
}
private
static
boolean
extractLibrary
(
final
Context
context
final
String
lib
final
String
outDir
)
{
final
String
apkPath
=
context
.
getApplicationInfo
(
)
.
sourceDir
;
if
(
!
apkPath
.
endsWith
(
"
.
apk
"
)
)
{
Log
.
w
(
LOGTAG
"
sourceDir
is
not
an
APK
.
"
)
;
return
false
;
}
File
outDirFile
=
new
File
(
outDir
)
;
if
(
!
outDirFile
.
isDirectory
(
)
)
{
if
(
!
outDirFile
.
mkdirs
(
)
)
{
Log
.
e
(
LOGTAG
"
Couldn
'
t
create
"
+
outDir
)
;
return
false
;
}
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
21
)
{
String
[
]
abis
=
Build
.
SUPPORTED_ABIS
;
for
(
String
abi
:
abis
)
{
if
(
tryLoadWithABI
(
lib
outDir
apkPath
abi
)
)
{
return
true
;
}
}
return
false
;
}
else
{
final
String
abi
=
getCPUABI
(
)
;
return
tryLoadWithABI
(
lib
outDir
apkPath
abi
)
;
}
}
private
static
boolean
tryLoadWithABI
(
String
lib
String
outDir
String
apkPath
String
abi
)
{
try
{
final
ZipFile
zipFile
=
new
ZipFile
(
new
File
(
apkPath
)
)
;
try
{
final
String
libPath
=
"
lib
/
"
+
abi
+
"
/
lib
"
+
lib
+
"
.
so
"
;
final
ZipEntry
entry
=
zipFile
.
getEntry
(
libPath
)
;
if
(
entry
=
=
null
)
{
Log
.
w
(
LOGTAG
libPath
+
"
not
found
in
APK
"
+
apkPath
)
;
return
false
;
}
final
InputStream
in
=
zipFile
.
getInputStream
(
entry
)
;
try
{
final
String
outPath
=
outDir
+
"
/
lib
"
+
lib
+
"
.
so
"
;
final
FileOutputStream
out
=
new
FileOutputStream
(
outPath
)
;
final
byte
[
]
bytes
=
new
byte
[
1024
]
;
int
read
;
Log
.
d
(
LOGTAG
"
Copying
"
+
libPath
+
"
to
"
+
outPath
)
;
boolean
failed
=
false
;
try
{
while
(
(
read
=
in
.
read
(
bytes
0
1024
)
)
!
=
-
1
)
{
out
.
write
(
bytes
0
read
)
;
}
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Failing
library
copy
.
"
e
)
;
failed
=
true
;
}
finally
{
out
.
close
(
)
;
}
if
(
failed
)
{
new
File
(
outPath
)
.
delete
(
)
;
}
else
{
Log
.
d
(
LOGTAG
"
Marking
"
+
outPath
+
"
as
executable
.
"
)
;
new
File
(
outPath
)
.
setExecutable
(
true
)
;
}
return
!
failed
;
}
finally
{
in
.
close
(
)
;
}
}
finally
{
zipFile
.
close
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
extract
lib
from
APK
.
"
e
)
;
return
false
;
}
}
private
static
String
getLoadDiagnostics
(
final
Context
context
final
String
lib
)
{
final
String
androidPackageName
=
context
.
getPackageName
(
)
;
final
StringBuilder
message
=
new
StringBuilder
(
"
LOAD
"
)
;
message
.
append
(
lib
)
;
message
.
append
(
"
:
ABI
:
"
+
BuildConfig
.
MOZ_APP_ABI
+
"
"
+
getCPUABI
(
)
)
;
message
.
append
(
"
:
Data
:
"
+
context
.
getApplicationInfo
(
)
.
dataDir
)
;
try
{
final
boolean
appLibExists
=
new
File
(
"
/
data
/
app
-
lib
/
"
+
androidPackageName
+
"
/
lib
"
+
lib
+
"
.
so
"
)
.
exists
(
)
;
final
boolean
dataDataExists
=
new
File
(
"
/
data
/
data
/
"
+
androidPackageName
+
"
/
lib
/
lib
"
+
lib
+
"
.
so
"
)
.
exists
(
)
;
message
.
append
(
"
ax
=
"
+
appLibExists
)
;
message
.
append
(
"
ddx
=
"
+
dataDataExists
)
;
}
catch
(
Throwable
e
)
{
message
.
append
(
"
:
ax
/
ddx
fail
"
)
;
}
try
{
final
String
dashOne
=
"
/
data
/
data
/
"
+
androidPackageName
+
"
-
1
"
;
final
String
dashTwo
=
"
/
data
/
data
/
"
+
androidPackageName
+
"
-
2
"
;
final
boolean
dashOneExists
=
new
File
(
dashOne
)
.
exists
(
)
;
final
boolean
dashTwoExists
=
new
File
(
dashTwo
)
.
exists
(
)
;
message
.
append
(
"
-
1x
=
"
+
dashOneExists
)
;
message
.
append
(
"
-
2x
=
"
+
dashTwoExists
)
;
}
catch
(
Throwable
e
)
{
message
.
append
(
"
dash
fail
"
)
;
}
try
{
final
String
nativeLibPath
=
context
.
getApplicationInfo
(
)
.
nativeLibraryDir
;
final
boolean
nativeLibDirExists
=
new
File
(
nativeLibPath
)
.
exists
(
)
;
final
boolean
nativeLibLibExists
=
new
File
(
nativeLibPath
+
"
/
lib
"
+
lib
+
"
.
so
"
)
.
exists
(
)
;
message
.
append
(
"
nativeLib
:
"
+
nativeLibPath
)
;
message
.
append
(
"
dirx
=
"
+
nativeLibDirExists
)
;
message
.
append
(
"
libx
=
"
+
nativeLibLibExists
)
;
}
catch
(
Throwable
e
)
{
message
.
append
(
"
nativeLib
fail
.
"
)
;
}
return
message
.
toString
(
)
;
}
private
static
final
boolean
attemptLoad
(
final
String
path
)
{
try
{
System
.
load
(
path
)
;
return
true
;
}
catch
(
Throwable
e
)
{
Log
.
wtf
(
LOGTAG
"
Couldn
'
t
load
"
+
path
+
"
:
"
+
e
)
;
}
return
false
;
}
private
static
final
Throwable
doLoadLibraryExpected
(
final
Context
context
final
String
lib
)
{
try
{
System
.
loadLibrary
(
lib
)
;
return
null
;
}
catch
(
Throwable
e
)
{
Log
.
wtf
(
LOGTAG
"
Couldn
'
t
load
"
+
lib
+
"
.
Trying
native
library
dir
.
"
)
;
final
String
libDir
=
context
.
getApplicationInfo
(
)
.
nativeLibraryDir
;
final
String
libPath
=
libDir
+
"
/
lib
"
+
lib
+
"
.
so
"
;
if
(
new
File
(
libPath
)
.
exists
(
)
)
{
if
(
attemptLoad
(
libPath
)
)
{
return
null
;
}
Log
.
wtf
(
LOGTAG
"
Library
exists
but
couldn
'
t
load
!
"
)
;
}
else
{
Log
.
wtf
(
LOGTAG
"
Library
doesn
'
t
exist
when
it
should
.
"
)
;
}
return
e
;
}
}
public
static
void
doLoadLibrary
(
final
Context
context
final
String
lib
)
{
final
Throwable
e
=
doLoadLibraryExpected
(
context
lib
)
;
if
(
e
=
=
null
)
{
return
;
}
final
String
nativeLibPath
=
context
.
getApplicationInfo
(
)
.
nativeLibraryDir
;
if
(
nativeLibPath
.
contains
(
"
mismatched_uid
"
)
)
{
throw
new
RuntimeException
(
"
Fatal
:
mismatched
UID
:
cannot
load
.
"
)
;
}
final
String
dataLibPath
=
context
.
getApplicationInfo
(
)
.
dataDir
+
"
/
lib
/
lib
"
+
lib
+
"
.
so
"
;
if
(
attemptLoad
(
dataLibPath
)
)
{
return
;
}
final
String
androidPackageName
=
context
.
getPackageName
(
)
;
if
(
attemptLoad
(
"
/
data
/
app
-
lib
/
"
+
androidPackageName
+
"
/
lib
"
+
lib
+
"
.
so
"
)
)
{
return
;
}
if
(
attemptLoad
(
"
/
data
/
data
/
"
+
androidPackageName
+
"
/
lib
/
lib
"
+
lib
+
"
.
so
"
)
)
{
return
;
}
final
String
filesLibDir
=
context
.
getFilesDir
(
)
+
"
/
lib
"
;
final
String
filesLibPath
=
filesLibDir
+
"
/
lib
"
+
lib
+
"
.
so
"
;
if
(
new
File
(
filesLibPath
)
.
exists
(
)
)
{
if
(
attemptLoad
(
filesLibPath
)
)
{
return
;
}
}
else
{
if
(
extractLibrary
(
context
lib
filesLibDir
)
)
{
if
(
attemptLoad
(
filesLibPath
)
)
{
return
;
}
}
}
final
String
message
=
getLoadDiagnostics
(
context
lib
)
;
Log
.
e
(
LOGTAG
"
Load
diagnostics
:
"
+
message
)
;
throw
new
RuntimeException
(
message
e
)
;
}
public
synchronized
static
void
loadMozGlue
(
final
Context
context
)
{
if
(
sMozGlueLoaded
)
{
return
;
}
doLoadLibrary
(
context
"
mozglue
"
)
;
sMozGlueLoaded
=
true
;
}
public
synchronized
static
void
loadGeckoLibs
(
final
Context
context
final
String
apkName
)
{
loadLibsSetupLocked
(
context
)
;
loadGeckoLibsNative
(
apkName
)
;
}
SuppressWarnings
(
"
serial
"
)
public
static
class
AbortException
extends
Exception
{
public
AbortException
(
String
msg
)
{
super
(
msg
)
;
}
}
JNITarget
public
static
void
abort
(
final
String
msg
)
{
final
Thread
thread
=
Thread
.
currentThread
(
)
;
final
Thread
.
UncaughtExceptionHandler
uncaughtHandler
=
thread
.
getUncaughtExceptionHandler
(
)
;
if
(
uncaughtHandler
!
=
null
)
{
uncaughtHandler
.
uncaughtException
(
thread
new
AbortException
(
msg
)
)
;
}
}
private
static
native
void
putenv
(
String
map
)
;
public
static
native
boolean
verifyCRCs
(
String
apkName
)
;
public
static
native
void
nativeRun
(
String
[
]
args
int
prefsFd
int
ipcFd
int
crashFd
int
crashAnnotationFd
)
;
private
static
native
void
loadGeckoLibsNative
(
String
apkName
)
;
private
static
native
void
loadSQLiteLibsNative
(
String
apkName
)
;
private
static
native
void
loadNSSLibsNative
(
String
apkName
)
;
public
static
native
boolean
neonCompatible
(
)
;
public
static
native
void
suppressCrashDialog
(
)
;
}
