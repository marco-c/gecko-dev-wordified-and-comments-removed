package
org
.
mozilla
.
geckoview
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Rect
;
import
android
.
view
.
Surface
;
import
android
.
view
.
SurfaceControl
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
UiThread
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
public
class
GeckoDisplay
{
private
final
GeckoSession
mSession
;
protected
GeckoDisplay
(
final
GeckoSession
session
)
{
mSession
=
session
;
}
public
static
class
SurfaceInfo
{
final
NonNull
Surface
mSurface
;
final
Nullable
SurfaceControl
mSurfaceControl
;
final
int
mLeft
;
final
int
mTop
;
final
int
mWidth
;
final
int
mHeight
;
private
SurfaceInfo
(
final
NonNull
Builder
builder
)
{
mSurface
=
builder
.
mSurface
;
mSurfaceControl
=
builder
.
mSurfaceControl
;
mLeft
=
builder
.
mLeft
;
mTop
=
builder
.
mTop
;
mWidth
=
builder
.
mWidth
;
mHeight
=
builder
.
mHeight
;
}
public
static
class
Builder
{
private
Surface
mSurface
;
private
SurfaceControl
mSurfaceControl
;
private
int
mLeft
;
private
int
mTop
;
private
int
mWidth
;
private
int
mHeight
;
public
Builder
(
final
NonNull
Surface
surface
)
{
mSurface
=
surface
;
}
UiThread
public
NonNull
Builder
surfaceControl
(
final
Nullable
SurfaceControl
surfaceControl
)
{
mSurfaceControl
=
surfaceControl
;
return
this
;
}
UiThread
public
NonNull
Builder
offset
(
final
int
left
final
int
top
)
{
mLeft
=
left
;
mTop
=
top
;
return
this
;
}
UiThread
public
NonNull
Builder
size
(
final
int
width
final
int
height
)
{
mWidth
=
width
;
mHeight
=
height
;
return
this
;
}
UiThread
public
NonNull
SurfaceInfo
build
(
)
{
if
(
(
mLeft
<
0
)
|
|
(
mTop
<
0
)
)
{
throw
new
IllegalArgumentException
(
"
Left
and
Top
offsets
can
not
be
negative
.
"
)
;
}
return
new
SurfaceInfo
(
this
)
;
}
}
}
UiThread
public
void
surfaceChanged
(
NonNull
final
SurfaceInfo
surfaceInfo
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
.
getDisplay
(
)
=
=
this
)
{
mSession
.
onSurfaceChanged
(
surfaceInfo
)
;
}
}
UiThread
public
void
surfaceDestroyed
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
.
getDisplay
(
)
=
=
this
)
{
mSession
.
onSurfaceDestroyed
(
)
;
}
}
UiThread
public
void
screenOriginChanged
(
final
int
left
final
int
top
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
.
getDisplay
(
)
=
=
this
)
{
mSession
.
onScreenOriginChanged
(
left
top
)
;
}
}
UiThread
public
void
safeAreaInsetsChanged
(
final
int
top
final
int
right
final
int
bottom
final
int
left
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
.
getDisplay
(
)
=
=
this
)
{
mSession
.
onSafeAreaInsetsChanged
(
top
right
bottom
left
)
;
}
}
UiThread
public
void
setDynamicToolbarMaxHeight
(
final
int
height
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
!
=
null
)
{
mSession
.
setDynamicToolbarMaxHeight
(
height
)
;
}
}
UiThread
public
void
setVerticalClipping
(
final
int
clippingHeight
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
!
=
null
)
{
mSession
.
setFixedBottomOffset
(
clippingHeight
)
;
}
}
UiThread
public
boolean
shouldPinOnScreen
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mSession
.
getDisplay
(
)
=
=
this
&
&
mSession
.
shouldPinOnScreen
(
)
;
}
UiThread
public
NonNull
GeckoResult
<
Bitmap
>
capturePixels
(
)
{
return
screenshot
(
)
.
capture
(
)
;
}
public
static
final
class
ScreenshotBuilder
{
private
static
final
int
NONE
=
0
;
private
static
final
int
SCALE
=
1
;
private
static
final
int
ASPECT
=
2
;
private
static
final
int
FULL
=
3
;
private
static
final
int
RECYCLE
=
4
;
private
final
GeckoSession
mSession
;
private
int
mOffsetX
;
private
int
mOffsetY
;
private
int
mSrcWidth
;
private
int
mSrcHeight
;
private
int
mOutWidth
;
private
int
mOutHeight
;
private
int
mAspectPreservingWidth
;
private
float
mScale
;
private
Bitmap
mRecycle
;
private
int
mSizeType
;
ScreenshotBuilder
(
final
GeckoSession
session
)
{
this
.
mSizeType
=
NONE
;
this
.
mSession
=
session
;
}
AnyThread
public
NonNull
ScreenshotBuilder
source
(
final
int
x
final
int
y
final
int
width
final
int
height
)
{
mOffsetX
=
x
;
mOffsetY
=
y
;
mSrcWidth
=
width
;
mSrcHeight
=
height
;
return
this
;
}
AnyThread
public
NonNull
ScreenshotBuilder
source
(
final
NonNull
Rect
source
)
{
mOffsetX
=
source
.
left
;
mOffsetY
=
source
.
top
;
mSrcWidth
=
source
.
width
(
)
;
mSrcHeight
=
source
.
height
(
)
;
return
this
;
}
private
void
checkAndSetSizeType
(
final
int
sizeType
)
{
if
(
mSizeType
!
=
NONE
)
{
throw
new
IllegalStateException
(
"
Size
has
already
been
set
.
"
)
;
}
mSizeType
=
sizeType
;
}
AnyThread
public
NonNull
ScreenshotBuilder
aspectPreservingSize
(
final
int
width
)
{
checkAndSetSizeType
(
ASPECT
)
;
mAspectPreservingWidth
=
width
;
return
this
;
}
AnyThread
public
NonNull
ScreenshotBuilder
scale
(
final
float
scale
)
{
checkAndSetSizeType
(
SCALE
)
;
mScale
=
scale
;
return
this
;
}
AnyThread
public
NonNull
ScreenshotBuilder
size
(
final
int
width
final
int
height
)
{
checkAndSetSizeType
(
FULL
)
;
mOutWidth
=
width
;
mOutHeight
=
height
;
return
this
;
}
AnyThread
public
NonNull
ScreenshotBuilder
bitmap
(
final
Nullable
Bitmap
bitmap
)
{
checkAndSetSizeType
(
RECYCLE
)
;
mRecycle
=
bitmap
;
return
this
;
}
UiThread
public
NonNull
GeckoResult
<
Bitmap
>
capture
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
mSession
.
isCompositorReady
(
)
)
{
throw
new
IllegalStateException
(
"
Compositor
must
be
ready
before
pixels
can
be
captured
"
)
;
}
final
GeckoResult
<
Bitmap
>
result
=
new
GeckoResult
<
>
(
)
;
final
Bitmap
target
;
final
Rect
rect
=
new
Rect
(
)
;
if
(
mSrcWidth
=
=
0
|
|
mSrcHeight
=
=
0
)
{
mSession
.
getSurfaceBounds
(
rect
)
;
mSrcWidth
=
rect
.
width
(
)
;
mSrcHeight
=
rect
.
height
(
)
;
}
switch
(
mSizeType
)
{
case
NONE
:
mOutWidth
=
mSrcWidth
;
mOutHeight
=
mSrcHeight
;
break
;
case
SCALE
:
mSession
.
getSurfaceBounds
(
rect
)
;
mOutWidth
=
(
int
)
(
rect
.
width
(
)
*
mScale
)
;
mOutHeight
=
(
int
)
(
rect
.
height
(
)
*
mScale
)
;
break
;
case
ASPECT
:
mSession
.
getSurfaceBounds
(
rect
)
;
mOutWidth
=
mAspectPreservingWidth
;
mOutHeight
=
(
int
)
(
rect
.
height
(
)
*
(
mAspectPreservingWidth
/
(
double
)
rect
.
width
(
)
)
)
;
break
;
case
RECYCLE
:
mOutWidth
=
mRecycle
.
getWidth
(
)
;
mOutHeight
=
mRecycle
.
getHeight
(
)
;
break
;
}
if
(
mRecycle
=
=
null
)
{
try
{
target
=
Bitmap
.
createBitmap
(
mOutWidth
mOutHeight
Bitmap
.
Config
.
ARGB_8888
)
;
}
catch
(
final
Throwable
e
)
{
if
(
e
instanceof
NullPointerException
|
|
e
instanceof
OutOfMemoryError
)
{
return
GeckoResult
.
fromException
(
new
OutOfMemoryError
(
"
Not
enough
memory
to
allocate
for
bitmap
"
)
)
;
}
return
GeckoResult
.
fromException
(
new
Throwable
(
"
Failed
to
create
bitmap
"
e
)
)
;
}
}
else
{
target
=
mRecycle
;
}
mSession
.
mCompositor
.
requestScreenPixels
(
result
target
mOffsetX
mOffsetY
mSrcWidth
mSrcHeight
mOutWidth
mOutHeight
)
;
return
result
;
}
}
UiThread
public
NonNull
ScreenshotBuilder
screenshot
(
)
{
return
new
ScreenshotBuilder
(
mSession
)
;
}
}
