package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
LinkedList
;
WrapForJNI
AnyThread
class
GeckoInputStream
extends
InputStream
{
private
static
final
String
LOGTAG
=
"
GeckoInputStream
"
;
private
LinkedList
<
ByteBuffer
>
mBuffers
=
new
LinkedList
<
>
(
)
;
private
boolean
mEOF
;
private
boolean
mClosed
;
private
boolean
mResumed
;
private
Support
mSupport
;
private
GeckoInputStream
(
final
NonNull
Support
support
)
{
mSupport
=
support
;
}
Override
public
synchronized
void
close
(
)
throws
IOException
{
super
.
close
(
)
;
sendEof
(
)
;
mClosed
=
true
;
}
Override
public
synchronized
int
available
(
)
throws
IOException
{
if
(
mClosed
)
{
return
0
;
}
final
ByteBuffer
buf
=
mBuffers
.
peekFirst
(
)
;
return
buf
!
=
null
?
buf
.
remaining
(
)
:
0
;
}
private
void
ensureNotClosed
(
)
throws
IOException
{
if
(
mClosed
)
{
throw
new
IOException
(
"
Stream
is
closed
"
)
;
}
}
Override
public
synchronized
int
read
(
)
throws
IOException
{
ensureNotClosed
(
)
;
int
expect
=
Integer
.
SIZE
/
8
;
byte
[
]
bytes
=
new
byte
[
expect
]
;
int
count
=
0
;
while
(
count
<
expect
)
{
long
bytesRead
=
read
(
bytes
count
expect
-
count
)
;
if
(
bytesRead
<
0
)
{
return
-
1
;
}
count
+
=
bytesRead
;
}
final
ByteBuffer
buffer
=
ByteBuffer
.
wrap
(
bytes
)
;
return
buffer
.
getInt
(
)
;
}
Override
public
int
read
(
final
NonNull
byte
[
]
b
)
throws
IOException
{
return
read
(
b
0
b
.
length
)
;
}
Override
public
synchronized
int
read
(
final
NonNull
byte
[
]
dest
final
int
offset
final
int
length
)
throws
IOException
{
ensureNotClosed
(
)
;
while
(
!
mEOF
&
&
mBuffers
.
size
(
)
=
=
0
)
{
if
(
!
mResumed
)
{
mSupport
.
resume
(
)
;
mResumed
=
true
;
}
try
{
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
}
}
if
(
mEOF
&
&
mBuffers
.
size
(
)
=
=
0
)
{
return
-
1
;
}
final
ByteBuffer
buf
=
mBuffers
.
peekFirst
(
)
;
final
int
readCount
=
Math
.
min
(
length
buf
.
remaining
(
)
)
;
buf
.
get
(
dest
offset
readCount
)
;
if
(
buf
.
remaining
(
)
=
=
0
)
{
mBuffers
.
removeFirst
(
)
;
}
return
readCount
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
synchronized
void
sendEof
(
)
{
mEOF
=
true
;
notifyAll
(
)
;
}
WrapForJNI
(
exceptionMode
=
"
nsresult
"
calledFrom
=
"
gecko
"
)
private
synchronized
void
appendBuffer
(
final
byte
[
]
buf
)
throws
IOException
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
if
(
mEOF
)
{
throw
new
IllegalStateException
(
)
;
}
mBuffers
.
add
(
ByteBuffer
.
wrap
(
buf
)
)
;
notifyAll
(
)
;
}
WrapForJNI
private
static
class
Support
extends
JNIObject
{
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
private
native
void
resume
(
)
;
Override
protected
void
disposeNative
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
}
