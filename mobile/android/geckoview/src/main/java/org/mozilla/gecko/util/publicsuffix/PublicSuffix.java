package
org
.
mozilla
.
gecko
.
util
.
publicsuffix
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
text
.
TextUtils
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
import
java
.
util
.
Set
;
public
class
PublicSuffix
{
NonNull
WorkerThread
public
static
String
stripPublicSuffix
(
Context
context
NonNull
String
domain
)
{
if
(
domain
.
length
(
)
=
=
0
)
{
return
domain
;
}
final
int
index
=
findPublicSuffixIndex
(
context
domain
)
;
if
(
index
=
=
-
1
)
{
return
domain
;
}
return
domain
.
substring
(
0
index
)
;
}
NonNull
WorkerThread
public
static
String
getPublicSuffix
(
NonNull
final
Context
context
NonNull
final
String
domain
final
int
additionalPartCount
)
{
if
(
context
=
=
null
)
{
throw
new
NullPointerException
(
"
Expected
non
-
null
Context
argument
"
)
;
}
if
(
domain
=
=
null
)
{
throw
new
NullPointerException
(
"
Expected
non
-
null
domain
argument
"
)
;
}
if
(
additionalPartCount
<
0
)
{
throw
new
IllegalArgumentException
(
"
Expected
additionalPartCount
>
0
.
Got
:
"
+
additionalPartCount
)
;
}
final
int
publicSuffixCombinedIndex
=
findPublicSuffixIndex
(
context
domain
)
;
if
(
publicSuffixCombinedIndex
<
0
)
{
return
"
"
;
}
final
String
publicSuffix
=
domain
.
substring
(
publicSuffixCombinedIndex
+
1
)
;
final
int
nextPartIndex
=
publicSuffix
.
indexOf
(
'
.
'
)
;
final
String
publicSuffixFirstPart
=
nextPartIndex
<
0
?
publicSuffix
:
publicSuffix
.
substring
(
0
nextPartIndex
)
;
final
List
<
String
>
domainParts
=
normalizeAndSplit
(
domain
)
;
final
int
publicSuffixPartsIndex
=
domainParts
.
indexOf
(
publicSuffixFirstPart
)
;
final
int
returnedPartsIndex
=
Math
.
max
(
0
publicSuffixPartsIndex
-
additionalPartCount
)
;
return
TextUtils
.
join
(
"
.
"
domainParts
.
subList
(
returnedPartsIndex
domainParts
.
size
(
)
)
)
;
}
WorkerThread
private
static
int
findPublicSuffixIndex
(
Context
context
String
domain
)
{
final
List
<
String
>
parts
=
normalizeAndSplit
(
domain
)
;
final
int
partsSize
=
parts
.
size
(
)
;
final
Set
<
String
>
exact
=
PublicSuffixPatterns
.
getExactSet
(
context
)
;
for
(
int
i
=
0
;
i
<
partsSize
;
i
+
+
)
{
String
ancestorName
=
TextUtils
.
join
(
"
.
"
parts
.
subList
(
i
partsSize
)
)
;
if
(
exact
.
contains
(
ancestorName
)
)
{
return
joinIndex
(
parts
i
)
;
}
if
(
PublicSuffixPatterns
.
EXCLUDED
.
contains
(
ancestorName
)
)
{
return
joinIndex
(
parts
i
+
1
)
;
}
if
(
matchesWildcardPublicSuffix
(
ancestorName
)
)
{
return
joinIndex
(
parts
i
)
;
}
}
return
-
1
;
}
private
static
List
<
String
>
normalizeAndSplit
(
String
domain
)
{
domain
=
domain
.
replaceAll
(
"
[
.
\
u3002
\
uFF0E
\
uFF61
]
"
"
.
"
)
;
domain
=
domain
.
toLowerCase
(
)
;
if
(
domain
.
endsWith
(
"
.
"
)
)
{
domain
=
domain
.
substring
(
0
domain
.
length
(
)
-
1
)
;
}
List
<
String
>
parts
=
new
ArrayList
<
>
(
)
;
Collections
.
addAll
(
parts
domain
.
split
(
"
\
\
.
"
)
)
;
return
parts
;
}
private
static
int
joinIndex
(
List
<
String
>
parts
int
index
)
{
int
actualIndex
=
parts
.
get
(
0
)
.
length
(
)
;
for
(
int
i
=
1
;
i
<
index
;
i
+
+
)
{
actualIndex
+
=
parts
.
get
(
i
)
.
length
(
)
+
1
;
}
return
actualIndex
;
}
private
static
boolean
matchesWildcardPublicSuffix
(
String
domain
)
{
final
String
[
]
pieces
=
domain
.
split
(
"
\
\
.
"
2
)
;
return
pieces
.
length
=
=
2
&
&
PublicSuffixPatterns
.
UNDER
.
contains
(
pieces
[
1
]
)
;
}
}
