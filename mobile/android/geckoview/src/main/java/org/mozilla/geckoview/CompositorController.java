package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
graphics
.
Color
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
java
.
nio
.
IntBuffer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
UiThread
public
final
class
CompositorController
{
private
final
GeckoSession
.
Compositor
mCompositor
;
public
interface
GetPixelsCallback
{
UiThread
void
onPixelsResult
(
int
width
int
height
Nullable
IntBuffer
pixels
)
;
}
private
List
<
Runnable
>
mDrawCallbacks
;
private
GetPixelsCallback
mGetPixelsCallback
;
private
int
mDefaultClearColor
=
Color
.
WHITE
;
private
Runnable
mFirstPaintCallback
;
CompositorController
(
final
GeckoSession
session
)
{
mCompositor
=
session
.
mCompositor
;
}
void
onCompositorReady
(
)
{
mCompositor
.
setDefaultClearColor
(
mDefaultClearColor
)
;
mCompositor
.
enableLayerUpdateNotifications
(
mDrawCallbacks
!
=
null
&
&
!
mDrawCallbacks
.
isEmpty
(
)
)
;
}
void
onCompositorDetached
(
)
{
if
(
mDrawCallbacks
!
=
null
)
{
mDrawCallbacks
.
clear
(
)
;
}
}
void
notifyDrawCallbacks
(
)
{
if
(
mDrawCallbacks
!
=
null
)
{
for
(
final
Runnable
callback
:
mDrawCallbacks
)
{
callback
.
run
(
)
;
}
}
}
RobocopTarget
public
void
addDrawCallback
(
final
NonNull
Runnable
callback
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mDrawCallbacks
=
=
null
)
{
mDrawCallbacks
=
new
ArrayList
<
Runnable
>
(
2
)
;
}
if
(
mDrawCallbacks
.
add
(
callback
)
&
&
mDrawCallbacks
.
size
(
)
=
=
1
&
&
mCompositor
.
isReady
(
)
)
{
mCompositor
.
enableLayerUpdateNotifications
(
true
)
;
}
}
RobocopTarget
public
void
removeDrawCallback
(
final
NonNull
Runnable
callback
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mDrawCallbacks
=
=
null
)
{
return
;
}
if
(
mDrawCallbacks
.
remove
(
callback
)
&
&
mDrawCallbacks
.
isEmpty
(
)
&
&
mCompositor
.
isReady
(
)
)
{
mCompositor
.
enableLayerUpdateNotifications
(
false
)
;
}
}
void
recvScreenPixels
(
final
int
width
final
int
height
final
int
[
]
pixels
)
{
if
(
mGetPixelsCallback
!
=
null
)
{
mGetPixelsCallback
.
onPixelsResult
(
width
height
IntBuffer
.
wrap
(
pixels
)
)
;
mGetPixelsCallback
=
null
;
}
}
RobocopTarget
public
void
getPixels
(
final
NonNull
GetPixelsCallback
callback
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mCompositor
.
isReady
(
)
)
{
mGetPixelsCallback
=
callback
;
mCompositor
.
requestScreenPixels
(
)
;
}
else
{
callback
.
onPixelsResult
(
0
0
null
)
;
}
}
public
int
getClearColor
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mDefaultClearColor
;
}
public
void
setClearColor
(
final
int
color
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDefaultClearColor
=
color
;
if
(
mCompositor
.
isReady
(
)
)
{
mCompositor
.
setDefaultClearColor
(
mDefaultClearColor
)
;
}
}
public
Nullable
Runnable
getFirstPaintCallback
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mFirstPaintCallback
;
}
public
void
setFirstPaintCallback
(
final
Nullable
Runnable
callback
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mFirstPaintCallback
=
callback
;
}
void
onFirstPaint
(
)
{
if
(
mFirstPaintCallback
!
=
null
)
{
mFirstPaintCallback
.
run
(
)
;
}
}
}
