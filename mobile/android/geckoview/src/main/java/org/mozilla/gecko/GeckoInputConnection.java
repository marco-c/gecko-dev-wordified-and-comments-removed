package
org
.
mozilla
.
gecko
;
import
java
.
lang
.
reflect
.
InvocationHandler
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Proxy
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GamepadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
RectF
;
import
android
.
media
.
AudioManager
;
import
android
.
os
.
Build
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
SystemClock
;
import
android
.
text
.
Editable
;
import
android
.
text
.
InputType
;
import
android
.
text
.
Selection
;
import
android
.
text
.
SpannableString
;
import
android
.
text
.
Spanned
;
import
android
.
text
.
method
.
KeyListener
;
import
android
.
text
.
method
.
TextKeyListener
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
inputmethod
.
BaseInputConnection
;
import
android
.
view
.
inputmethod
.
CursorAnchorInfo
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
ExtractedText
;
import
android
.
view
.
inputmethod
.
ExtractedTextRequest
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
class
GeckoInputConnection
extends
BaseInputConnection
implements
TextInputController
.
Delegate
TextInputController
.
EditableListener
{
private
static
final
boolean
DEBUG
=
false
;
protected
static
final
String
LOGTAG
=
"
GeckoInputConnection
"
;
private
static
final
String
CUSTOM_HANDLER_TEST_METHOD
=
"
testInputConnection
"
;
private
static
final
String
CUSTOM_HANDLER_TEST_CLASS
=
"
org
.
mozilla
.
gecko
.
tests
.
components
.
GeckoViewComponent
TextInput
"
;
private
static
final
int
INLINE_IME_MIN_DISPLAY_SIZE
=
480
;
private
static
Handler
sBackgroundHandler
;
private
int
mIMEState
;
private
String
mIMETypeHint
=
"
"
;
private
String
mIMEModeHint
=
"
"
;
private
String
mIMEActionHint
=
"
"
;
private
int
mIMEFlags
;
private
boolean
mFocused
;
private
int
mLastSelectionStart
;
private
int
mLastSelectionEnd
;
private
String
mCurrentInputMethod
=
"
"
;
private
final
GeckoSession
mSession
;
private
final
View
mView
;
private
final
TextInputController
.
EditableClient
mEditableClient
;
protected
int
mBatchEditCount
;
private
ExtractedTextRequest
mUpdateRequest
;
private
final
ExtractedText
mUpdateExtract
=
new
ExtractedText
(
)
;
private
final
InputConnection
mKeyInputConnection
;
private
CursorAnchorInfo
.
Builder
mCursorAnchorInfoBuilder
;
private
volatile
boolean
mSoftInputReentrancyGuard
;
public
static
TextInputController
.
Delegate
create
(
final
GeckoSession
session
final
View
targetView
final
TextInputController
.
EditableClient
editable
)
{
if
(
DEBUG
)
{
return
DebugGeckoInputConnection
.
create
(
session
targetView
editable
)
;
}
else
{
return
new
GeckoInputConnection
(
session
targetView
editable
)
;
}
}
protected
GeckoInputConnection
(
final
GeckoSession
session
final
View
targetView
final
TextInputController
.
EditableClient
editable
)
{
super
(
targetView
true
)
;
mSession
=
session
;
mView
=
targetView
;
mEditableClient
=
editable
;
mIMEState
=
IME_STATE_DISABLED
;
mKeyInputConnection
=
new
BaseInputConnection
(
targetView
false
)
;
}
Override
public
synchronized
boolean
beginBatchEdit
(
)
{
mBatchEditCount
+
+
;
if
(
mBatchEditCount
=
=
1
)
{
mEditableClient
.
setBatchMode
(
true
)
;
}
return
true
;
}
Override
public
synchronized
boolean
endBatchEdit
(
)
{
if
(
mBatchEditCount
<
=
0
)
{
Log
.
w
(
LOGTAG
"
endBatchEdit
(
)
called
but
mBatchEditCount
<
=
0
?
!
"
)
;
return
true
;
}
mBatchEditCount
-
-
;
if
(
mBatchEditCount
!
=
0
)
{
return
true
;
}
mEditableClient
.
setBatchMode
(
false
)
;
return
true
;
}
Override
public
Editable
getEditable
(
)
{
return
mEditableClient
.
getEditable
(
)
;
}
Override
public
boolean
performContextMenuAction
(
int
id
)
{
final
View
view
=
getView
(
)
;
final
Editable
editable
=
getEditable
(
)
;
if
(
view
=
=
null
|
|
editable
=
=
null
)
{
return
false
;
}
int
selStart
=
Selection
.
getSelectionStart
(
editable
)
;
int
selEnd
=
Selection
.
getSelectionEnd
(
editable
)
;
switch
(
id
)
{
case
android
.
R
.
id
.
selectAll
:
setSelection
(
0
editable
.
length
(
)
)
;
break
;
case
android
.
R
.
id
.
cut
:
if
(
selStart
=
=
selEnd
)
{
Clipboard
.
setText
(
view
.
getContext
(
)
editable
)
;
editable
.
clear
(
)
;
}
else
{
Clipboard
.
setText
(
view
.
getContext
(
)
editable
.
subSequence
(
Math
.
min
(
selStart
selEnd
)
Math
.
max
(
selStart
selEnd
)
)
)
;
editable
.
delete
(
selStart
selEnd
)
;
}
break
;
case
android
.
R
.
id
.
paste
:
commitText
(
Clipboard
.
getText
(
view
.
getContext
(
)
)
1
)
;
break
;
case
android
.
R
.
id
.
copy
:
String
copiedText
=
selStart
=
=
selEnd
?
"
"
:
editable
.
toString
(
)
.
substring
(
Math
.
min
(
selStart
selEnd
)
Math
.
max
(
selStart
selEnd
)
)
;
Clipboard
.
setText
(
view
.
getContext
(
)
copiedText
)
;
break
;
}
return
true
;
}
Override
public
ExtractedText
getExtractedText
(
ExtractedTextRequest
req
int
flags
)
{
if
(
req
=
=
null
)
return
null
;
if
(
(
flags
&
GET_EXTRACTED_TEXT_MONITOR
)
!
=
0
)
mUpdateRequest
=
req
;
Editable
editable
=
getEditable
(
)
;
if
(
editable
=
=
null
)
{
return
null
;
}
int
selStart
=
Selection
.
getSelectionStart
(
editable
)
;
int
selEnd
=
Selection
.
getSelectionEnd
(
editable
)
;
ExtractedText
extract
=
new
ExtractedText
(
)
;
extract
.
flags
=
0
;
extract
.
partialStartOffset
=
-
1
;
extract
.
partialEndOffset
=
-
1
;
extract
.
selectionStart
=
selStart
;
extract
.
selectionEnd
=
selEnd
;
extract
.
startOffset
=
0
;
if
(
(
req
.
flags
&
GET_TEXT_WITH_STYLES
)
!
=
0
)
{
extract
.
text
=
new
SpannableString
(
editable
)
;
}
else
{
extract
.
text
=
editable
.
toString
(
)
;
}
return
extract
;
}
Override
public
View
getView
(
)
{
return
mView
;
}
private
InputMethodManager
getInputMethodManager
(
)
{
View
view
=
getView
(
)
;
if
(
view
=
=
null
)
{
return
null
;
}
Context
context
=
view
.
getContext
(
)
;
return
InputMethods
.
getInputMethodManager
(
context
)
;
}
private
void
showSoftInputWithToolbar
(
final
boolean
showToolbar
)
{
if
(
mSoftInputReentrancyGuard
)
{
return
;
}
final
View
v
=
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
)
;
if
(
v
=
=
null
|
|
imm
=
=
null
)
{
return
;
}
v
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
v
.
hasFocus
(
)
&
&
!
imm
.
isActive
(
v
)
)
{
v
.
clearFocus
(
)
;
v
.
requestFocus
(
)
;
}
if
(
showToolbar
)
{
mSession
.
getDynamicToolbarAnimator
(
)
.
showToolbar
(
true
)
;
}
mSession
.
getEventDispatcher
(
)
.
dispatch
(
"
GeckoView
:
ZoomToInput
"
null
)
;
mSoftInputReentrancyGuard
=
true
;
imm
.
showSoftInput
(
v
0
)
;
mSoftInputReentrancyGuard
=
false
;
}
}
)
;
}
private
void
hideSoftInput
(
)
{
if
(
mSoftInputReentrancyGuard
)
{
return
;
}
final
InputMethodManager
imm
=
getInputMethodManager
(
)
;
if
(
imm
!
=
null
)
{
final
View
v
=
getView
(
)
;
mSoftInputReentrancyGuard
=
true
;
imm
.
hideSoftInputFromWindow
(
v
.
getWindowToken
(
)
0
)
;
mSoftInputReentrancyGuard
=
false
;
}
}
private
void
restartInput
(
)
{
final
InputMethodManager
imm
=
getInputMethodManager
(
)
;
if
(
imm
=
=
null
)
{
return
;
}
final
View
v
=
getView
(
)
;
if
(
InputMethods
.
needsSoftResetWorkaround
(
mCurrentInputMethod
)
)
{
notifySelectionChange
(
-
1
-
1
)
;
}
try
{
imm
.
restartInput
(
v
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Error
restarting
input
"
e
)
;
}
}
private
void
resetInputConnection
(
)
{
if
(
mBatchEditCount
!
=
0
)
{
Log
.
w
(
LOGTAG
"
resetting
with
mBatchEditCount
=
"
+
mBatchEditCount
)
;
mBatchEditCount
=
0
;
}
restartInput
(
)
;
}
Override
public
void
onTextChange
(
)
{
if
(
mUpdateRequest
=
=
null
)
{
return
;
}
final
InputMethodManager
imm
=
getInputMethodManager
(
)
;
final
View
v
=
getView
(
)
;
final
Editable
editable
=
getEditable
(
)
;
if
(
imm
=
=
null
|
|
v
=
=
null
|
|
editable
=
=
null
)
{
return
;
}
mUpdateExtract
.
flags
=
0
;
mUpdateExtract
.
partialStartOffset
=
-
1
;
mUpdateExtract
.
partialEndOffset
=
-
1
;
mUpdateExtract
.
selectionStart
=
Selection
.
getSelectionStart
(
editable
)
;
mUpdateExtract
.
selectionEnd
=
Selection
.
getSelectionEnd
(
editable
)
;
mUpdateExtract
.
startOffset
=
0
;
if
(
(
mUpdateRequest
.
flags
&
GET_TEXT_WITH_STYLES
)
!
=
0
)
{
mUpdateExtract
.
text
=
new
SpannableString
(
editable
)
;
}
else
{
mUpdateExtract
.
text
=
editable
.
toString
(
)
;
}
imm
.
updateExtractedText
(
v
mUpdateRequest
.
token
mUpdateExtract
)
;
}
Override
public
void
onSelectionChange
(
)
{
final
Editable
editable
=
getEditable
(
)
;
if
(
editable
!
=
null
)
{
mLastSelectionStart
=
Selection
.
getSelectionStart
(
editable
)
;
mLastSelectionEnd
=
Selection
.
getSelectionEnd
(
editable
)
;
notifySelectionChange
(
mLastSelectionStart
mLastSelectionEnd
)
;
}
}
private
void
notifySelectionChange
(
int
start
int
end
)
{
final
InputMethodManager
imm
=
getInputMethodManager
(
)
;
final
View
v
=
getView
(
)
;
final
Editable
editable
=
getEditable
(
)
;
if
(
imm
=
=
null
|
|
v
=
=
null
|
|
editable
=
=
null
)
{
return
;
}
imm
.
updateSelection
(
v
start
end
getComposingSpanStart
(
editable
)
getComposingSpanEnd
(
editable
)
)
;
}
TargetApi
(
21
)
Override
public
void
updateCompositionRects
(
final
RectF
[
]
rects
)
{
if
(
!
(
Build
.
VERSION
.
SDK_INT
>
=
21
)
)
{
return
;
}
final
View
view
=
getView
(
)
;
if
(
view
=
=
null
)
{
return
;
}
final
Editable
content
=
getEditable
(
)
;
if
(
content
=
=
null
)
{
return
;
}
final
int
composingStart
=
getComposingSpanStart
(
content
)
;
final
int
composingEnd
=
getComposingSpanEnd
(
content
)
;
if
(
composingStart
<
0
|
|
composingEnd
<
0
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
No
composition
for
updates
"
)
;
}
return
;
}
final
CharSequence
composition
=
content
.
subSequence
(
composingStart
composingEnd
)
;
view
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
updateCompositionRectsOnUi
(
view
rects
composition
)
;
}
}
)
;
}
TargetApi
(
21
)
void
updateCompositionRectsOnUi
(
final
View
view
final
RectF
[
]
rects
final
CharSequence
composition
)
{
if
(
mCursorAnchorInfoBuilder
=
=
null
)
{
mCursorAnchorInfoBuilder
=
new
CursorAnchorInfo
.
Builder
(
)
;
}
mCursorAnchorInfoBuilder
.
reset
(
)
;
final
Matrix
matrix
=
new
Matrix
(
)
;
mSession
.
getClientToScreenMatrix
(
matrix
)
;
mCursorAnchorInfoBuilder
.
setMatrix
(
matrix
)
;
for
(
int
i
=
0
;
i
<
rects
.
length
;
i
+
+
)
{
mCursorAnchorInfoBuilder
.
addCharacterBounds
(
i
rects
[
i
]
.
left
rects
[
i
]
.
top
rects
[
i
]
.
right
rects
[
i
]
.
bottom
CursorAnchorInfo
.
FLAG_HAS_VISIBLE_REGION
)
;
}
mCursorAnchorInfoBuilder
.
setComposingText
(
0
composition
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
)
;
if
(
imm
=
=
null
)
{
return
;
}
imm
.
updateCursorAnchorInfo
(
view
mCursorAnchorInfoBuilder
.
build
(
)
)
;
}
Override
public
boolean
requestCursorUpdates
(
int
cursorUpdateMode
)
{
if
(
(
cursorUpdateMode
&
InputConnection
.
CURSOR_UPDATE_IMMEDIATE
)
!
=
0
)
{
mEditableClient
.
requestCursorUpdates
(
TextInputController
.
EditableClient
.
ONE_SHOT
)
;
}
if
(
(
cursorUpdateMode
&
InputConnection
.
CURSOR_UPDATE_MONITOR
)
!
=
0
)
{
mEditableClient
.
requestCursorUpdates
(
TextInputController
.
EditableClient
.
START_MONITOR
)
;
}
else
{
mEditableClient
.
requestCursorUpdates
(
TextInputController
.
EditableClient
.
END_MONITOR
)
;
}
return
true
;
}
Override
public
void
onDefaultKeyEvent
(
final
KeyEvent
event
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoInputConnection
.
this
.
performDefaultKeyAction
(
event
)
;
}
}
)
;
}
private
static
synchronized
Handler
getBackgroundHandler
(
)
{
if
(
sBackgroundHandler
!
=
null
)
{
return
sBackgroundHandler
;
}
Thread
backgroundThread
=
new
Thread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Looper
.
prepare
(
)
;
synchronized
(
GeckoInputConnection
.
class
)
{
sBackgroundHandler
=
new
Handler
(
)
;
GeckoInputConnection
.
class
.
notify
(
)
;
}
Looper
.
loop
(
)
;
throw
new
IllegalThreadStateException
(
"
unreachable
code
"
)
;
}
}
LOGTAG
)
;
backgroundThread
.
setDaemon
(
true
)
;
backgroundThread
.
start
(
)
;
while
(
sBackgroundHandler
=
=
null
)
{
try
{
GeckoInputConnection
.
class
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
}
}
return
sBackgroundHandler
;
}
private
synchronized
boolean
canReturnCustomHandler
(
)
{
if
(
mIMEState
=
=
IME_STATE_DISABLED
)
{
return
false
;
}
for
(
StackTraceElement
frame
:
Thread
.
currentThread
(
)
.
getStackTrace
(
)
)
{
if
(
"
startInputInner
"
.
equals
(
frame
.
getMethodName
(
)
)
&
&
"
android
.
view
.
inputmethod
.
InputMethodManager
"
.
equals
(
frame
.
getClassName
(
)
)
)
{
return
Build
.
VERSION
.
SDK_INT
<
24
;
}
if
(
CUSTOM_HANDLER_TEST_METHOD
.
equals
(
frame
.
getMethodName
(
)
)
&
&
CUSTOM_HANDLER_TEST_CLASS
.
equals
(
frame
.
getClassName
(
)
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
isPhysicalKeyboardPresent
(
)
{
final
View
v
=
getView
(
)
;
if
(
v
=
=
null
)
{
return
false
;
}
final
Configuration
config
=
v
.
getContext
(
)
.
getResources
(
)
.
getConfiguration
(
)
;
return
config
.
keyboard
!
=
Configuration
.
KEYBOARD_NOKEYS
;
}
SuppressLint
(
"
Override
"
)
public
Handler
getHandler
(
)
{
final
Handler
handler
;
if
(
isPhysicalKeyboardPresent
(
)
)
{
handler
=
ThreadUtils
.
getUiHandler
(
)
;
}
else
{
handler
=
getBackgroundHandler
(
)
;
}
return
mEditableClient
.
setInputConnectionHandler
(
handler
)
;
}
Override
public
Handler
getHandler
(
Handler
defHandler
)
{
if
(
!
canReturnCustomHandler
(
)
)
{
return
defHandler
;
}
return
getHandler
(
)
;
}
SuppressLint
(
"
Override
"
)
public
void
closeConnection
(
)
{
}
Override
public
synchronized
InputConnection
onCreateInputConnection
(
EditorInfo
outAttrs
)
{
outAttrs
.
inputType
=
InputType
.
TYPE_CLASS_TEXT
;
outAttrs
.
imeOptions
=
EditorInfo
.
IME_ACTION_NONE
;
outAttrs
.
actionLabel
=
null
;
if
(
mIMEState
=
=
IME_STATE_DISABLED
)
{
hideSoftInput
(
)
;
return
null
;
}
if
(
mIMEState
=
=
IME_STATE_PASSWORD
|
|
"
password
"
.
equalsIgnoreCase
(
mIMETypeHint
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_VARIATION_PASSWORD
;
else
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
url
"
)
|
|
mIMETypeHint
.
equalsIgnoreCase
(
"
mozAwesomebar
"
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_VARIATION_URI
;
else
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
email
"
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_VARIATION_EMAIL_ADDRESS
;
else
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
tel
"
)
)
outAttrs
.
inputType
=
InputType
.
TYPE_CLASS_PHONE
;
else
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
number
"
)
|
|
mIMETypeHint
.
equalsIgnoreCase
(
"
range
"
)
)
outAttrs
.
inputType
=
InputType
.
TYPE_CLASS_NUMBER
|
InputType
.
TYPE_NUMBER_FLAG_SIGNED
|
InputType
.
TYPE_NUMBER_FLAG_DECIMAL
;
else
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
week
"
)
|
|
mIMETypeHint
.
equalsIgnoreCase
(
"
month
"
)
)
outAttrs
.
inputType
=
InputType
.
TYPE_CLASS_DATETIME
|
InputType
.
TYPE_DATETIME_VARIATION_DATE
;
else
if
(
mIMEModeHint
.
equalsIgnoreCase
(
"
numeric
"
)
)
outAttrs
.
inputType
=
InputType
.
TYPE_CLASS_NUMBER
|
InputType
.
TYPE_NUMBER_FLAG_SIGNED
|
InputType
.
TYPE_NUMBER_FLAG_DECIMAL
;
else
if
(
mIMEModeHint
.
equalsIgnoreCase
(
"
digit
"
)
)
outAttrs
.
inputType
=
InputType
.
TYPE_CLASS_NUMBER
;
else
{
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_FLAG_AUTO_CORRECT
|
InputType
.
TYPE_TEXT_FLAG_IME_MULTI_LINE
;
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
textarea
"
)
|
|
mIMETypeHint
.
length
(
)
=
=
0
)
{
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_FLAG_MULTI_LINE
;
}
if
(
mIMEModeHint
.
equalsIgnoreCase
(
"
uppercase
"
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_FLAG_CAP_CHARACTERS
;
else
if
(
mIMEModeHint
.
equalsIgnoreCase
(
"
titlecase
"
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_FLAG_CAP_WORDS
;
else
if
(
mIMETypeHint
.
equalsIgnoreCase
(
"
text
"
)
&
&
!
mIMEModeHint
.
equalsIgnoreCase
(
"
autocapitalized
"
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_VARIATION_NORMAL
;
else
if
(
!
mIMEModeHint
.
equalsIgnoreCase
(
"
lowercase
"
)
)
outAttrs
.
inputType
|
=
InputType
.
TYPE_TEXT_FLAG_CAP_SENTENCES
;
}
if
(
mIMEActionHint
.
equalsIgnoreCase
(
"
go
"
)
)
outAttrs
.
imeOptions
=
EditorInfo
.
IME_ACTION_GO
;
else
if
(
mIMEActionHint
.
equalsIgnoreCase
(
"
done
"
)
)
outAttrs
.
imeOptions
=
EditorInfo
.
IME_ACTION_DONE
;
else
if
(
mIMEActionHint
.
equalsIgnoreCase
(
"
next
"
)
)
outAttrs
.
imeOptions
=
EditorInfo
.
IME_ACTION_NEXT
;
else
if
(
mIMEActionHint
.
equalsIgnoreCase
(
"
search
"
)
|
|
mIMETypeHint
.
equalsIgnoreCase
(
"
search
"
)
)
outAttrs
.
imeOptions
=
EditorInfo
.
IME_ACTION_SEARCH
;
else
if
(
mIMEActionHint
.
equalsIgnoreCase
(
"
send
"
)
)
outAttrs
.
imeOptions
=
EditorInfo
.
IME_ACTION_SEND
;
else
if
(
mIMEActionHint
.
length
(
)
>
0
)
{
if
(
DEBUG
)
Log
.
w
(
LOGTAG
"
Unexpected
mIMEActionHint
=
\
"
"
+
mIMEActionHint
+
"
\
"
"
)
;
outAttrs
.
actionLabel
=
mIMEActionHint
;
}
if
(
(
mIMEFlags
&
IME_FLAG_PRIVATE_BROWSING
)
!
=
0
)
{
outAttrs
.
imeOptions
|
=
InputMethods
.
IME_FLAG_NO_PERSONALIZED_LEARNING
;
}
Context
context
=
getView
(
)
.
getContext
(
)
;
DisplayMetrics
metrics
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
;
if
(
Math
.
min
(
metrics
.
widthPixels
metrics
.
heightPixels
)
>
INLINE_IME_MIN_DISPLAY_SIZE
)
{
outAttrs
.
imeOptions
|
=
EditorInfo
.
IME_FLAG_NO_EXTRACT_UI
|
EditorInfo
.
IME_FLAG_NO_FULLSCREEN
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
mapped
IME
states
to
:
inputType
=
"
+
Integer
.
toHexString
(
outAttrs
.
inputType
)
+
"
imeOptions
=
"
+
Integer
.
toHexString
(
outAttrs
.
imeOptions
)
)
;
}
String
prevInputMethod
=
mCurrentInputMethod
;
mCurrentInputMethod
=
InputMethods
.
getCurrentInputMethod
(
context
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
IME
:
CurrentInputMethod
=
"
+
mCurrentInputMethod
)
;
}
outAttrs
.
initialSelStart
=
mLastSelectionStart
;
outAttrs
.
initialSelEnd
=
mLastSelectionEnd
;
if
(
(
mIMEFlags
&
IME_FLAG_USER_ACTION
)
!
=
0
)
{
if
(
(
context
instanceof
Activity
)
&
&
ActivityUtils
.
isFullScreen
(
(
Activity
)
context
)
)
{
showSoftInputWithToolbar
(
false
)
;
}
else
{
showSoftInputWithToolbar
(
true
)
;
}
}
return
this
;
}
private
boolean
replaceComposingSpanWithSelection
(
)
{
final
Editable
content
=
getEditable
(
)
;
if
(
content
=
=
null
)
{
return
false
;
}
int
a
=
getComposingSpanStart
(
content
)
b
=
getComposingSpanEnd
(
content
)
;
if
(
a
!
=
-
1
&
&
b
!
=
-
1
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
removing
composition
at
"
+
a
+
"
-
"
+
b
)
;
}
removeComposingSpans
(
content
)
;
Selection
.
setSelection
(
content
a
b
)
;
}
return
true
;
}
Override
public
boolean
commitText
(
CharSequence
text
int
newCursorPosition
)
{
if
(
InputMethods
.
shouldCommitCharAsKey
(
mCurrentInputMethod
)
&
&
text
.
length
(
)
=
=
1
&
&
newCursorPosition
>
0
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
committing
\
"
"
+
text
+
"
\
"
as
key
"
)
;
}
return
replaceComposingSpanWithSelection
(
)
&
&
mKeyInputConnection
.
commitText
(
text
newCursorPosition
)
;
}
return
super
.
commitText
(
text
newCursorPosition
)
;
}
Override
public
boolean
setSelection
(
int
start
int
end
)
{
if
(
start
<
0
|
|
end
<
0
)
{
return
true
;
}
return
super
.
setSelection
(
start
end
)
;
}
void
sendKeyEvent
(
final
int
action
KeyEvent
event
)
{
final
Editable
editable
=
getEditable
(
)
;
if
(
editable
=
=
null
)
{
return
;
}
final
KeyListener
keyListener
=
TextKeyListener
.
getInstance
(
)
;
event
=
translateKey
(
event
.
getKeyCode
(
)
event
)
;
final
View
v
=
ThreadUtils
.
isOnUiThread
(
)
?
getView
(
)
:
null
;
final
int
keyCode
=
event
.
getKeyCode
(
)
;
final
boolean
handled
;
if
(
shouldSkipKeyListener
(
keyCode
event
)
)
{
handled
=
false
;
}
else
if
(
action
=
=
KeyEvent
.
ACTION_DOWN
)
{
mEditableClient
.
setSuppressKeyUp
(
true
)
;
handled
=
keyListener
.
onKeyDown
(
v
editable
keyCode
event
)
;
}
else
if
(
action
=
=
KeyEvent
.
ACTION_UP
)
{
handled
=
keyListener
.
onKeyUp
(
v
editable
keyCode
event
)
;
}
else
{
handled
=
keyListener
.
onKeyOther
(
v
editable
event
)
;
}
if
(
!
handled
)
{
mEditableClient
.
sendKeyEvent
(
event
action
TextKeyListener
.
getMetaState
(
editable
)
)
;
}
if
(
action
=
=
KeyEvent
.
ACTION_DOWN
)
{
if
(
!
handled
)
{
TextKeyListener
.
adjustMetaAfterKeypress
(
editable
)
;
}
mEditableClient
.
setSuppressKeyUp
(
false
)
;
}
}
Override
public
boolean
sendKeyEvent
(
KeyEvent
event
)
{
sendKeyEvent
(
event
.
getAction
(
)
event
)
;
return
false
;
}
Override
public
boolean
onKeyPreIme
(
int
keyCode
KeyEvent
event
)
{
return
false
;
}
private
boolean
shouldProcessKey
(
int
keyCode
KeyEvent
event
)
{
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_MENU
:
case
KeyEvent
.
KEYCODE_BACK
:
case
KeyEvent
.
KEYCODE_VOLUME_UP
:
case
KeyEvent
.
KEYCODE_VOLUME_DOWN
:
case
KeyEvent
.
KEYCODE_SEARCH
:
case
KeyEvent
.
KEYCODE_HEADSETHOOK
:
return
false
;
}
return
true
;
}
private
boolean
shouldSkipKeyListener
(
int
keyCode
KeyEvent
event
)
{
if
(
mIMEState
=
=
IME_STATE_DISABLED
)
{
return
true
;
}
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_ENTER
|
|
keyCode
=
=
KeyEvent
.
KEYCODE_TAB
)
{
return
true
;
}
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_DEL
|
|
keyCode
=
=
KeyEvent
.
KEYCODE_FORWARD_DEL
)
{
return
true
;
}
return
false
;
}
private
KeyEvent
translateKey
(
int
keyCode
KeyEvent
event
)
{
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_ENTER
:
if
(
(
event
.
getFlags
(
)
&
KeyEvent
.
FLAG_EDITOR_ACTION
)
!
=
0
&
&
mIMEActionHint
.
equalsIgnoreCase
(
"
next
"
)
)
{
return
new
KeyEvent
(
event
.
getAction
(
)
KeyEvent
.
KEYCODE_TAB
)
;
}
break
;
}
if
(
GamepadUtils
.
isSonyXperiaGamepadKeyEvent
(
event
)
)
{
return
GamepadUtils
.
translateSonyXperiaGamepadKeys
(
keyCode
event
)
;
}
return
event
;
}
void
performDefaultKeyAction
(
KeyEvent
event
)
{
switch
(
event
.
getKeyCode
(
)
)
{
case
KeyEvent
.
KEYCODE_MUTE
:
case
KeyEvent
.
KEYCODE_HEADSETHOOK
:
case
KeyEvent
.
KEYCODE_MEDIA_PLAY
:
case
KeyEvent
.
KEYCODE_MEDIA_PAUSE
:
case
KeyEvent
.
KEYCODE_MEDIA_PLAY_PAUSE
:
case
KeyEvent
.
KEYCODE_MEDIA_STOP
:
case
KeyEvent
.
KEYCODE_MEDIA_NEXT
:
case
KeyEvent
.
KEYCODE_MEDIA_PREVIOUS
:
case
KeyEvent
.
KEYCODE_MEDIA_REWIND
:
case
KeyEvent
.
KEYCODE_MEDIA_RECORD
:
case
KeyEvent
.
KEYCODE_MEDIA_FAST_FORWARD
:
case
KeyEvent
.
KEYCODE_MEDIA_CLOSE
:
case
KeyEvent
.
KEYCODE_MEDIA_EJECT
:
case
KeyEvent
.
KEYCODE_MEDIA_AUDIO_TRACK
:
if
(
Build
.
VERSION
.
SDK_INT
>
=
19
)
{
Context
viewContext
=
getView
(
)
.
getContext
(
)
;
AudioManager
am
=
(
AudioManager
)
viewContext
.
getSystemService
(
Context
.
AUDIO_SERVICE
)
;
am
.
dispatchMediaKeyEvent
(
event
)
;
}
break
;
}
}
private
boolean
processKey
(
final
int
action
final
int
keyCode
final
KeyEvent
event
)
{
if
(
keyCode
>
KeyEvent
.
getMaxKeyCode
(
)
|
|
!
shouldProcessKey
(
keyCode
event
)
)
{
return
false
;
}
mEditableClient
.
postToInputConnection
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
sendKeyEvent
(
action
event
)
;
}
}
)
;
return
true
;
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
return
processKey
(
KeyEvent
.
ACTION_DOWN
keyCode
event
)
;
}
Override
public
boolean
onKeyUp
(
int
keyCode
KeyEvent
event
)
{
return
processKey
(
KeyEvent
.
ACTION_UP
keyCode
event
)
;
}
private
KeyEvent
getCharKeyEvent
(
final
char
c
)
{
final
long
time
=
SystemClock
.
uptimeMillis
(
)
;
return
new
KeyEvent
(
time
time
KeyEvent
.
ACTION_MULTIPLE
KeyEvent
.
KEYCODE_UNKNOWN
0
)
{
Override
public
int
getUnicodeChar
(
)
{
return
c
;
}
Override
public
int
getUnicodeChar
(
int
metaState
)
{
return
c
;
}
}
;
}
Override
public
boolean
onKeyMultiple
(
int
keyCode
int
repeatCount
final
KeyEvent
event
)
{
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_UNKNOWN
)
{
final
String
str
=
event
.
getCharacters
(
)
;
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
+
+
)
{
final
KeyEvent
charEvent
=
getCharKeyEvent
(
str
.
charAt
(
i
)
)
;
if
(
!
processKey
(
KeyEvent
.
ACTION_DOWN
KeyEvent
.
KEYCODE_UNKNOWN
charEvent
)
|
|
!
processKey
(
KeyEvent
.
ACTION_UP
KeyEvent
.
KEYCODE_UNKNOWN
charEvent
)
)
{
return
false
;
}
}
return
true
;
}
while
(
(
repeatCount
-
-
)
!
=
0
)
{
if
(
!
processKey
(
KeyEvent
.
ACTION_DOWN
keyCode
event
)
|
|
!
processKey
(
KeyEvent
.
ACTION_UP
keyCode
event
)
)
{
return
false
;
}
}
return
true
;
}
Override
public
boolean
onKeyLongPress
(
int
keyCode
KeyEvent
event
)
{
View
v
=
getView
(
)
;
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_MENU
:
InputMethodManager
imm
=
getInputMethodManager
(
)
;
imm
.
toggleSoftInputFromWindow
(
v
.
getWindowToken
(
)
InputMethodManager
.
SHOW_FORCED
0
)
;
return
true
;
default
:
break
;
}
return
false
;
}
Override
public
synchronized
boolean
isInputActive
(
)
{
return
mIMEState
!
=
IME_STATE_DISABLED
;
}
Override
public
void
notifyIME
(
int
type
)
{
switch
(
type
)
{
case
NOTIFY_IME_OF_FOCUS
:
mFocused
=
true
;
resetInputConnection
(
)
;
break
;
case
NOTIFY_IME_OF_BLUR
:
mFocused
=
false
;
break
;
case
NOTIFY_IME_OPEN_VKB
:
showSoftInputWithToolbar
(
false
)
;
break
;
case
NOTIFY_IME_TO_COMMIT_COMPOSITION
:
{
final
Editable
editable
=
getEditable
(
)
;
if
(
editable
=
=
null
)
{
break
;
}
final
Object
[
]
spans
=
editable
.
getSpans
(
0
editable
.
length
(
)
Object
.
class
)
;
for
(
final
Object
span
:
spans
)
{
if
(
(
editable
.
getSpanFlags
(
span
)
&
Spanned
.
SPAN_COMPOSING
)
!
=
0
)
{
return
;
}
}
restartInput
(
)
;
break
;
}
default
:
if
(
DEBUG
)
{
throw
new
IllegalArgumentException
(
"
Unexpected
NOTIFY_IME
=
"
+
type
)
;
}
break
;
}
}
Override
public
synchronized
void
notifyIMEContext
(
int
state
final
String
typeHint
final
String
modeHint
final
String
actionHint
final
int
flags
)
{
if
(
typeHint
!
=
null
&
&
(
typeHint
.
equalsIgnoreCase
(
"
date
"
)
|
|
typeHint
.
equalsIgnoreCase
(
"
time
"
)
|
|
typeHint
.
equalsIgnoreCase
(
"
datetime
"
)
|
|
typeHint
.
equalsIgnoreCase
(
"
month
"
)
|
|
typeHint
.
equalsIgnoreCase
(
"
week
"
)
|
|
typeHint
.
equalsIgnoreCase
(
"
datetime
-
local
"
)
)
)
{
state
=
IME_STATE_DISABLED
;
}
mIMEState
=
state
;
mIMETypeHint
=
(
typeHint
=
=
null
)
?
"
"
:
typeHint
;
mIMEModeHint
=
(
modeHint
=
=
null
)
?
"
"
:
modeHint
;
mIMEActionHint
=
(
actionHint
=
=
null
)
?
"
"
:
actionHint
;
mIMEFlags
=
flags
;
mUpdateRequest
=
null
;
mCurrentInputMethod
=
"
"
;
View
v
=
getView
(
)
;
if
(
v
=
=
null
|
|
!
v
.
hasFocus
(
)
)
{
return
;
}
if
(
mIMEState
=
=
IME_STATE_DISABLED
|
|
mFocused
)
{
restartInput
(
)
;
}
}
}
final
class
DebugGeckoInputConnection
extends
GeckoInputConnection
implements
InvocationHandler
{
private
InputConnection
mProxy
;
private
final
StringBuilder
mCallLevel
;
private
DebugGeckoInputConnection
(
final
GeckoSession
session
final
View
targetView
final
TextInputController
.
EditableClient
editable
)
{
super
(
session
targetView
editable
)
;
mCallLevel
=
new
StringBuilder
(
)
;
}
public
static
TextInputController
.
Delegate
create
(
final
GeckoSession
session
final
View
targetView
final
TextInputController
.
EditableClient
editable
)
{
final
Class
<
?
>
[
]
PROXY_INTERFACES
=
{
InputConnection
.
class
TextInputController
.
Delegate
.
class
TextInputController
.
EditableListener
.
class
}
;
DebugGeckoInputConnection
dgic
=
new
DebugGeckoInputConnection
(
session
targetView
editable
)
;
dgic
.
mProxy
=
(
InputConnection
)
Proxy
.
newProxyInstance
(
GeckoInputConnection
.
class
.
getClassLoader
(
)
PROXY_INTERFACES
dgic
)
;
return
(
TextInputController
.
Delegate
)
dgic
.
mProxy
;
}
Override
public
Object
invoke
(
Object
proxy
Method
method
Object
[
]
args
)
throws
Throwable
{
StringBuilder
log
=
new
StringBuilder
(
mCallLevel
)
;
log
.
append
(
"
>
"
)
.
append
(
method
.
getName
(
)
)
.
append
(
"
(
"
)
;
if
(
args
!
=
null
)
{
for
(
Object
arg
:
args
)
{
if
(
"
notifyIME
"
.
equals
(
method
.
getName
(
)
)
&
&
arg
=
=
args
[
0
]
)
{
log
.
append
(
GeckoEditable
.
getConstantName
(
TextInputController
.
EditableListener
.
class
"
NOTIFY_IME_
"
arg
)
)
;
}
else
if
(
"
notifyIMEContext
"
.
equals
(
method
.
getName
(
)
)
&
&
arg
=
=
args
[
0
]
)
{
log
.
append
(
GeckoEditable
.
getConstantName
(
TextInputController
.
EditableListener
.
class
"
IME_STATE_
"
arg
)
)
;
}
else
{
GeckoEditable
.
debugAppend
(
log
arg
)
;
}
log
.
append
(
"
"
)
;
}
if
(
args
.
length
>
0
)
{
log
.
setLength
(
log
.
length
(
)
-
2
)
;
}
}
log
.
append
(
"
)
"
)
;
Log
.
d
(
LOGTAG
log
.
toString
(
)
)
;
mCallLevel
.
append
(
'
'
)
;
Object
ret
=
method
.
invoke
(
this
args
)
;
if
(
ret
=
=
this
)
{
ret
=
mProxy
;
}
mCallLevel
.
setLength
(
Math
.
max
(
0
mCallLevel
.
length
(
)
-
1
)
)
;
log
.
setLength
(
mCallLevel
.
length
(
)
)
;
log
.
append
(
"
<
"
)
.
append
(
method
.
getName
(
)
)
;
if
(
!
method
.
getReturnType
(
)
.
equals
(
Void
.
TYPE
)
)
{
GeckoEditable
.
debugAppend
(
log
.
append
(
"
:
"
)
ret
)
;
}
Log
.
d
(
LOGTAG
log
.
toString
(
)
)
;
return
ret
;
}
}
