package
org
.
mozilla
.
gecko
.
gfx
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Log
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
public
final
class
PanningPerfAPI
{
private
static
final
String
LOGTAG
=
"
GeckoPanningPerfAPI
"
;
private
static
final
int
EXPECTED_FRAME_COUNT
=
2048
;
private
static
boolean
mRecordingFrames
;
private
static
List
<
Long
>
mFrameTimes
;
private
static
long
mFrameStartTime
;
private
static
void
initialiseRecordingArrays
(
)
{
if
(
mFrameTimes
=
=
null
)
{
mFrameTimes
=
new
ArrayList
<
Long
>
(
EXPECTED_FRAME_COUNT
)
;
}
else
{
mFrameTimes
.
clear
(
)
;
}
}
RobocopTarget
public
static
void
startFrameTimeRecording
(
)
{
if
(
mRecordingFrames
)
{
Log
.
e
(
LOGTAG
"
Error
:
startFrameTimeRecording
(
)
called
while
already
recording
!
"
)
;
return
;
}
mRecordingFrames
=
true
;
initialiseRecordingArrays
(
)
;
mFrameStartTime
=
SystemClock
.
uptimeMillis
(
)
;
}
RobocopTarget
public
static
List
<
Long
>
stopFrameTimeRecording
(
)
{
if
(
!
mRecordingFrames
)
{
Log
.
e
(
LOGTAG
"
Error
:
stopFrameTimeRecording
(
)
called
when
not
recording
!
"
)
;
return
null
;
}
mRecordingFrames
=
false
;
return
mFrameTimes
;
}
public
static
void
recordFrameTime
(
)
{
if
(
mRecordingFrames
)
{
mFrameTimes
.
add
(
SystemClock
.
uptimeMillis
(
)
-
mFrameStartTime
)
;
}
}
RobocopTarget
public
static
void
startCheckerboardRecording
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
RobocopTarget
public
static
List
<
Float
>
stopCheckerboardRecording
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
