package
org
.
mozilla
.
gecko
.
gfx
;
import
static
org
.
mozilla
.
geckoview
.
BuildConfig
.
DEBUG_BUILD
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
view
.
Surface
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
public
final
class
GeckoSurface
extends
Surface
{
private
static
final
String
LOGTAG
=
"
GeckoSurface
"
;
private
int
mHandle
;
private
boolean
mIsSingleBuffer
;
private
volatile
boolean
mIsAvailable
;
private
boolean
mOwned
=
true
;
private
int
mMyPid
;
private
GeckoSurface
mSyncSurface
;
WrapForJNI
(
exceptionMode
=
"
nsresult
"
)
public
GeckoSurface
(
final
GeckoSurfaceTexture
gst
)
{
super
(
gst
)
;
mHandle
=
gst
.
getHandle
(
)
;
mIsSingleBuffer
=
gst
.
isSingleBuffer
(
)
;
mIsAvailable
=
true
;
mMyPid
=
android
.
os
.
Process
.
myPid
(
)
;
}
public
GeckoSurface
(
final
Parcel
p
final
SurfaceTexture
dummy
)
{
super
(
dummy
)
;
readFromParcel
(
p
)
;
mHandle
=
p
.
readInt
(
)
;
mIsSingleBuffer
=
p
.
readByte
(
)
=
=
1
?
true
:
false
;
mIsAvailable
=
(
p
.
readByte
(
)
=
=
1
?
true
:
false
)
;
mMyPid
=
p
.
readInt
(
)
;
dummy
.
release
(
)
;
}
public
static
final
Parcelable
.
Creator
<
GeckoSurface
>
CREATOR
=
new
Parcelable
.
Creator
<
GeckoSurface
>
(
)
{
public
GeckoSurface
createFromParcel
(
final
Parcel
p
)
{
return
new
GeckoSurface
(
p
new
SurfaceTexture
(
0
)
)
;
}
public
GeckoSurface
[
]
newArray
(
final
int
size
)
{
return
new
GeckoSurface
[
size
]
;
}
}
;
Override
public
void
writeToParcel
(
final
Parcel
out
final
int
flags
)
{
super
.
writeToParcel
(
out
flags
)
;
if
(
(
flags
&
Parcelable
.
PARCELABLE_WRITE_RETURN_VALUE
)
=
=
0
)
{
super
.
release
(
)
;
}
mOwned
=
false
;
out
.
writeInt
(
mHandle
)
;
out
.
writeByte
(
(
byte
)
(
mIsSingleBuffer
?
1
:
0
)
)
;
out
.
writeByte
(
(
byte
)
(
mIsAvailable
?
1
:
0
)
)
;
out
.
writeInt
(
mMyPid
)
;
}
Override
public
void
release
(
)
{
if
(
mSyncSurface
!
=
null
)
{
mSyncSurface
.
release
(
)
;
final
GeckoSurfaceTexture
gst
=
GeckoSurfaceTexture
.
lookup
(
mSyncSurface
.
getHandle
(
)
)
;
if
(
gst
!
=
null
)
{
gst
.
decrementUse
(
)
;
}
mSyncSurface
=
null
;
}
if
(
mOwned
)
{
super
.
release
(
)
;
}
}
WrapForJNI
public
int
getHandle
(
)
{
return
mHandle
;
}
WrapForJNI
public
boolean
getAvailable
(
)
{
return
mIsAvailable
;
}
WrapForJNI
public
void
setAvailable
(
final
boolean
available
)
{
mIsAvailable
=
available
;
}
boolean
inProcess
(
)
{
return
android
.
os
.
Process
.
myPid
(
)
=
=
mMyPid
;
}
SyncConfig
initSyncSurface
(
final
int
width
final
int
height
)
{
if
(
DEBUG_BUILD
)
{
if
(
inProcess
(
)
)
{
throw
new
AssertionError
(
"
no
need
for
sync
when
allocated
in
process
"
)
;
}
}
if
(
GeckoSurfaceTexture
.
lookup
(
mHandle
)
!
=
null
)
{
throw
new
AssertionError
(
"
texture
#
"
+
mHandle
+
"
already
in
use
.
"
)
;
}
final
GeckoSurfaceTexture
texture
=
GeckoSurfaceTexture
.
acquire
(
GeckoSurfaceTexture
.
isSingleBufferSupported
(
)
mHandle
)
;
texture
.
setDefaultBufferSize
(
width
height
)
;
texture
.
track
(
mHandle
)
;
mSyncSurface
=
new
GeckoSurface
(
texture
)
;
return
new
SyncConfig
(
mHandle
mSyncSurface
width
height
)
;
}
}
