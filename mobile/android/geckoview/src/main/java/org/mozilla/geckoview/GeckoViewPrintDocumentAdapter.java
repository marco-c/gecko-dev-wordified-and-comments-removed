package
org
.
mozilla
.
geckoview
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
pdf
.
PdfRenderer
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
CancellationSignal
;
import
android
.
os
.
ParcelFileDescriptor
;
import
android
.
print
.
PageRange
;
import
android
.
print
.
PrintAttributes
;
import
android
.
print
.
PrintDocumentAdapter
;
import
android
.
print
.
PrintDocumentInfo
;
import
android
.
util
.
Log
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
geckoview
.
GeckoSession
.
GeckoPrintException
;
public
class
GeckoViewPrintDocumentAdapter
extends
PrintDocumentAdapter
{
private
static
final
String
LOGTAG
=
"
GVPrintDocumentAdapter
"
;
private
static
final
String
PRINT_NAME_DEFAULT
=
"
Document
"
;
private
boolean
mPrintError
;
private
String
mPrintName
=
PRINT_NAME_DEFAULT
;
private
File
mPdfFile
;
private
GeckoResult
<
File
>
mGeneratedPdfFile
;
private
Boolean
mDoDeleteTmpPdf
;
private
GeckoResult
<
Boolean
>
mPrintDialogFinish
=
null
;
public
GeckoViewPrintDocumentAdapter
(
NonNull
final
InputStream
pdfInputStream
NonNull
final
Context
context
)
{
this
.
mDoDeleteTmpPdf
=
true
;
this
.
mGeneratedPdfFile
=
pdfInputStreamToFile
(
pdfInputStream
context
)
;
}
public
GeckoViewPrintDocumentAdapter
(
NonNull
final
InputStream
pdfInputStream
NonNull
final
Context
context
Nullable
final
GeckoResult
<
Boolean
>
printDialogFinish
)
{
this
.
mDoDeleteTmpPdf
=
true
;
this
.
mGeneratedPdfFile
=
pdfInputStreamToFile
(
pdfInputStream
context
)
;
this
.
mPrintDialogFinish
=
printDialogFinish
;
this
.
mPrintError
=
false
;
}
public
GeckoViewPrintDocumentAdapter
(
NonNull
final
File
pdfFile
)
{
this
.
mPdfFile
=
pdfFile
;
this
.
mDoDeleteTmpPdf
=
false
;
this
.
mPrintName
=
mPdfFile
.
getName
(
)
;
}
AnyThread
public
static
Nullable
File
makeTempPdfFile
(
NonNull
final
InputStream
pdfInputStream
NonNull
final
Context
context
)
{
final
File
file
;
try
{
file
=
File
.
createTempFile
(
"
temp
"
"
.
pdf
"
context
.
getCacheDir
(
)
)
;
}
catch
(
final
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Could
not
make
a
file
in
the
cache
dir
:
"
ioe
)
;
return
null
;
}
final
int
bufferSize
=
8192
;
final
byte
[
]
buffer
=
new
byte
[
bufferSize
]
;
try
(
final
OutputStream
out
=
new
BufferedOutputStream
(
new
FileOutputStream
(
file
)
)
)
{
int
len
;
while
(
(
len
=
pdfInputStream
.
read
(
buffer
)
)
!
=
-
1
)
{
out
.
write
(
buffer
0
len
)
;
}
}
catch
(
final
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Writing
temporary
PDF
file
failed
:
"
ioe
)
;
return
null
;
}
try
{
final
ParcelFileDescriptor
pfd
=
ParcelFileDescriptor
.
open
(
file
ParcelFileDescriptor
.
MODE_READ_ONLY
)
;
final
PdfRenderer
renderer
=
new
PdfRenderer
(
pfd
)
;
if
(
renderer
.
getPageCount
(
)
>
0
)
{
return
file
;
}
}
catch
(
final
Exception
e
)
{
file
.
delete
(
)
;
return
null
;
}
return
file
;
}
private
NonNull
GeckoResult
<
File
>
pdfInputStreamToFile
(
final
NonNull
InputStream
pdfInputStream
final
NonNull
Context
context
)
{
final
GeckoResult
<
File
>
result
=
new
GeckoResult
<
>
(
)
;
ThreadUtils
.
postToBackgroundThread
(
(
)
-
>
{
final
File
tempFile
=
makeTempPdfFile
(
pdfInputStream
context
)
;
if
(
tempFile
=
=
null
)
{
result
.
complete
(
null
)
;
mPrintError
=
true
;
mPrintDialogFinish
.
completeExceptionally
(
new
GeckoPrintException
(
GeckoPrintException
.
ERROR_UNABLE_TO_PROCESS_DOCUMENT
)
)
;
return
;
}
result
.
complete
(
tempFile
)
;
}
)
;
return
result
;
}
Override
public
void
onLayout
(
final
PrintAttributes
oldAttributes
final
PrintAttributes
newAttributes
final
CancellationSignal
cancellationSignal
final
LayoutResultCallback
layoutResultCallback
final
Bundle
bundle
)
{
if
(
cancellationSignal
.
isCanceled
(
)
)
{
layoutResultCallback
.
onLayoutCancelled
(
)
;
return
;
}
final
PrintDocumentInfo
pdi
=
new
PrintDocumentInfo
.
Builder
(
mPrintName
)
.
setContentType
(
PrintDocumentInfo
.
CONTENT_TYPE_DOCUMENT
)
.
build
(
)
;
layoutResultCallback
.
onLayoutFinished
(
pdi
true
)
;
}
private
void
onWritePdf
(
final
Nullable
File
pdfFile
final
NonNull
ParcelFileDescriptor
parcelFileDescriptor
final
NonNull
WriteResultCallback
writeResultCallback
)
{
if
(
mPrintError
)
{
writeResultCallback
.
onWriteFailed
(
null
)
;
return
;
}
InputStream
input
=
null
;
OutputStream
output
=
null
;
try
{
input
=
new
FileInputStream
(
pdfFile
)
;
output
=
new
FileOutputStream
(
parcelFileDescriptor
.
getFileDescriptor
(
)
)
;
final
int
bufferSize
=
8192
;
final
byte
[
]
buffer
=
new
byte
[
bufferSize
]
;
int
bytesRead
;
while
(
(
bytesRead
=
input
.
read
(
buffer
)
)
>
0
)
{
output
.
write
(
buffer
0
bytesRead
)
;
}
writeResultCallback
.
onWriteFinished
(
new
PageRange
[
]
{
PageRange
.
ALL_PAGES
}
)
;
}
catch
(
final
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Could
not
complete
onWrite
for
printing
:
"
ex
)
;
writeResultCallback
.
onWriteFailed
(
null
)
;
}
finally
{
try
{
input
.
close
(
)
;
output
.
close
(
)
;
}
catch
(
final
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Could
not
close
i
/
o
stream
:
"
ex
)
;
}
}
}
Override
public
void
onWrite
(
final
PageRange
[
]
pageRanges
final
ParcelFileDescriptor
parcelFileDescriptor
final
CancellationSignal
cancellationSignal
final
WriteResultCallback
writeResultCallback
)
{
ThreadUtils
.
postToBackgroundThread
(
(
)
-
>
{
if
(
mGeneratedPdfFile
!
=
null
)
{
mGeneratedPdfFile
.
then
(
file
-
>
{
if
(
mPrintName
=
=
PRINT_NAME_DEFAULT
)
{
if
(
file
!
=
null
)
mPrintName
=
file
.
getName
(
)
;
}
onWritePdf
(
file
parcelFileDescriptor
writeResultCallback
)
;
return
null
;
}
)
;
}
else
{
onWritePdf
(
mPdfFile
parcelFileDescriptor
writeResultCallback
)
;
}
}
)
;
}
Override
public
void
onFinish
(
)
{
try
{
if
(
mDoDeleteTmpPdf
)
{
if
(
mPdfFile
!
=
null
)
{
mPdfFile
.
delete
(
)
;
}
if
(
mGeneratedPdfFile
!
=
null
)
{
mGeneratedPdfFile
.
then
(
file
-
>
{
if
(
file
!
=
null
)
file
.
delete
(
)
;
return
null
;
}
)
;
}
}
}
catch
(
final
NullPointerException
npe
)
{
}
if
(
this
.
mPrintDialogFinish
!
=
null
&
&
!
this
.
mPrintError
)
{
mPrintDialogFinish
.
complete
(
true
)
;
}
}
}
