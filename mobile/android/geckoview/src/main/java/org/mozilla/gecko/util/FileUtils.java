package
org
.
mozilla
.
gecko
.
util
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
database
.
Cursor
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Build
;
import
android
.
os
.
Environment
;
import
android
.
os
.
storage
.
StorageVolume
;
import
android
.
provider
.
MediaStore
;
import
androidx
.
annotation
.
Nullable
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
FilenameFilter
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
Random
;
import
java
.
util
.
Set
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
static
org
.
mozilla
.
gecko
.
util
.
ContentUriUtils
.
getOriginalFilePathFromUri
;
import
static
org
.
mozilla
.
gecko
.
util
.
ContentUriUtils
.
getTempFilePathFromContentUri
;
public
class
FileUtils
{
private
static
final
String
LOGTAG
=
"
GeckoFileUtils
"
;
private
static
final
String
FILE_SCHEME
=
"
file
"
;
private
static
final
String
CONTENT_SCHEME
=
"
content
"
;
private
static
final
String
FILE_ABSOLUTE_URI
=
FILE_SCHEME
+
"
:
/
/
%
s
"
;
public
static
final
String
CONTENT_TEMP_DIRECTORY
=
"
contentUri
"
;
static
public
class
NameAndAgeFilter
implements
FilenameFilter
{
final
private
String
mName
;
final
private
double
mMaxAge
;
public
NameAndAgeFilter
(
final
String
name
final
double
age
)
{
mName
=
name
;
mMaxAge
=
age
;
}
Override
public
boolean
accept
(
final
File
dir
final
String
filename
)
{
if
(
mName
=
=
null
|
|
mName
.
matches
(
filename
)
)
{
final
File
f
=
new
File
(
dir
filename
)
;
if
(
mMaxAge
<
0
|
|
System
.
currentTimeMillis
(
)
-
f
.
lastModified
(
)
>
mMaxAge
)
{
return
true
;
}
}
return
false
;
}
}
RobocopTarget
public
static
void
delTree
(
final
File
dir
final
FilenameFilter
filter
final
boolean
recurse
)
{
String
[
]
files
=
null
;
if
(
filter
!
=
null
)
{
files
=
dir
.
list
(
filter
)
;
}
else
{
files
=
dir
.
list
(
)
;
}
if
(
files
=
=
null
)
{
return
;
}
for
(
final
String
file
:
files
)
{
final
File
f
=
new
File
(
dir
file
)
;
delete
(
f
recurse
)
;
}
}
public
static
boolean
delete
(
final
File
file
)
throws
IOException
{
return
delete
(
file
true
)
;
}
public
static
boolean
delete
(
final
File
file
final
boolean
recurse
)
{
if
(
file
.
isDirectory
(
)
&
&
recurse
)
{
final
String
[
]
files
=
file
.
list
(
)
;
for
(
final
String
temp
:
files
)
{
final
File
fileDelete
=
new
File
(
file
temp
)
;
try
{
delete
(
fileDelete
)
;
}
catch
(
final
IOException
ex
)
{
Log
.
i
(
LOGTAG
"
Error
deleting
"
+
fileDelete
.
getPath
(
)
ex
)
;
}
}
}
return
file
.
delete
(
)
;
}
public
static
JSONObject
readJSONObjectFromFile
(
final
File
file
)
throws
IOException
JSONException
{
if
(
file
.
length
(
)
=
=
0
)
{
throw
new
IOException
(
"
Given
file
is
empty
-
the
JSON
parser
cannot
create
an
object
from
an
empty
file
"
)
;
}
return
new
JSONObject
(
readStringFromFile
(
file
)
)
;
}
public
static
String
readStringFromFile
(
final
File
file
)
throws
IOException
{
if
(
!
file
.
exists
(
)
)
{
throw
new
FileNotFoundException
(
"
Given
file
"
+
file
+
"
does
not
exist
"
)
;
}
else
if
(
file
.
length
(
)
=
=
0
)
{
return
"
"
;
}
final
int
len
=
(
int
)
file
.
length
(
)
;
return
readStringFromInputStreamAndCloseStream
(
new
FileInputStream
(
file
)
len
)
;
}
public
static
String
readStringFromInputStreamAndCloseStream
(
final
InputStream
inputStream
final
int
bufferSize
)
throws
IOException
{
InputStreamReader
reader
=
null
;
try
{
if
(
bufferSize
<
=
0
)
{
throw
new
IllegalArgumentException
(
"
Expected
buffer
size
larger
than
0
.
Got
:
"
+
bufferSize
)
;
}
final
StringBuilder
stringBuilder
=
new
StringBuilder
(
bufferSize
)
;
reader
=
new
InputStreamReader
(
inputStream
StringUtils
.
UTF_8
)
;
int
charsRead
;
final
char
[
]
buffer
=
new
char
[
bufferSize
]
;
while
(
(
charsRead
=
reader
.
read
(
buffer
0
bufferSize
)
)
!
=
-
1
)
{
stringBuilder
.
append
(
buffer
0
charsRead
)
;
}
return
stringBuilder
.
toString
(
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
reader
)
;
IOUtils
.
safeStreamClose
(
inputStream
)
;
}
}
public
static
void
writeJSONObjectToFile
(
final
File
file
final
JSONObject
obj
)
throws
IOException
{
writeStringToFile
(
file
obj
.
toString
(
)
)
;
}
public
static
void
writeStringToFile
(
final
File
file
final
String
str
)
throws
IOException
{
writeStringToOutputStreamAndCloseStream
(
new
FileOutputStream
(
file
false
)
str
)
;
}
public
static
void
writeStringToOutputStreamAndCloseStream
(
final
OutputStream
outputStream
final
String
str
)
throws
IOException
{
try
{
final
OutputStreamWriter
writer
=
new
OutputStreamWriter
(
outputStream
Charset
.
forName
(
"
UTF
-
8
"
)
)
;
try
{
writer
.
write
(
str
)
;
}
finally
{
writer
.
close
(
)
;
}
}
finally
{
outputStream
.
close
(
)
;
}
}
public
static
class
FilenameWhitelistFilter
implements
FilenameFilter
{
private
final
Set
<
String
>
mFilenameWhitelist
;
public
FilenameWhitelistFilter
(
final
Set
<
String
>
filenameWhitelist
)
{
mFilenameWhitelist
=
filenameWhitelist
;
}
Override
public
boolean
accept
(
final
File
dir
final
String
filename
)
{
return
mFilenameWhitelist
.
contains
(
filename
)
;
}
}
public
static
class
FilenameRegexFilter
implements
FilenameFilter
{
private
final
Pattern
mPattern
;
private
Matcher
mCachedMatcher
;
public
FilenameRegexFilter
(
final
Pattern
pattern
)
{
mPattern
=
pattern
;
}
public
FilenameRegexFilter
(
final
String
pattern
)
{
mPattern
=
Pattern
.
compile
(
pattern
)
;
}
Override
public
boolean
accept
(
final
File
dir
final
String
filename
)
{
if
(
mCachedMatcher
=
=
null
)
{
mCachedMatcher
=
mPattern
.
matcher
(
filename
)
;
}
else
{
mCachedMatcher
.
reset
(
filename
)
;
}
return
mCachedMatcher
.
matches
(
)
;
}
}
public
static
class
FileLastModifiedComparator
implements
Comparator
<
File
>
{
Override
public
int
compare
(
final
File
lhs
final
File
rhs
)
{
final
long
lhsModified
=
lhs
.
lastModified
(
)
;
final
long
rhsModified
=
rhs
.
lastModified
(
)
;
if
(
lhsModified
<
rhsModified
)
{
return
-
1
;
}
else
if
(
lhsModified
=
=
rhsModified
)
{
return
0
;
}
else
{
return
1
;
}
}
}
public
static
File
createTempDir
(
final
File
directory
final
String
prefix
)
{
if
(
prefix
.
length
(
)
<
3
)
{
throw
new
IllegalArgumentException
(
"
prefix
must
be
at
least
3
characters
"
)
;
}
File
tempDirectory
=
directory
;
if
(
tempDirectory
=
=
null
)
{
final
String
tmpDir
=
System
.
getProperty
(
"
java
.
io
.
tmpdir
"
"
.
"
)
;
tempDirectory
=
new
File
(
tmpDir
)
;
}
File
result
;
final
Random
random
=
new
Random
(
)
;
do
{
result
=
new
File
(
tempDirectory
prefix
+
random
.
nextInt
(
)
)
;
}
while
(
!
result
.
mkdirs
(
)
)
;
return
result
;
}
public
static
String
resolveContentUri
(
final
Context
context
final
Uri
uri
)
{
String
path
=
getOriginalFilePathFromUri
(
context
uri
)
;
if
(
TextUtils
.
isEmpty
(
path
)
)
{
path
=
getTempFilePathFromContentUri
(
context
uri
)
;
}
return
!
TextUtils
.
isEmpty
(
path
)
?
String
.
format
(
FILE_ABSOLUTE_URI
path
)
:
path
;
}
public
static
String
getFileNameFromContentUri
(
final
Context
context
final
Uri
uri
)
{
final
ContentResolver
cr
=
context
.
getContentResolver
(
)
;
final
String
[
]
projection
=
{
MediaStore
.
MediaColumns
.
DISPLAY_NAME
}
;
String
fileName
=
null
;
try
(
final
Cursor
metaCursor
=
cr
.
query
(
uri
projection
null
null
null
)
;
)
{
if
(
metaCursor
.
moveToFirst
(
)
)
{
fileName
=
metaCursor
.
getString
(
0
)
;
}
}
catch
(
final
Exception
e
)
{
e
.
printStackTrace
(
)
;
}
return
canonicalizeFilename
(
fileName
)
;
}
public
static
void
copy
(
final
Context
context
final
Uri
srcUri
final
File
dstFile
)
{
try
(
final
InputStream
inputStream
=
context
.
getContentResolver
(
)
.
openInputStream
(
srcUri
)
;
final
OutputStream
outputStream
=
new
FileOutputStream
(
dstFile
)
)
{
IOUtils
.
copy
(
inputStream
outputStream
)
;
}
catch
(
final
Exception
e
)
{
e
.
printStackTrace
(
)
;
}
}
public
static
boolean
isContentUri
(
final
Uri
uri
)
{
return
uri
!
=
null
&
&
uri
.
getScheme
(
)
!
=
null
&
&
CONTENT_SCHEME
.
equals
(
uri
.
getScheme
(
)
)
;
}
public
static
boolean
isContentUri
(
final
String
sUri
)
{
return
sUri
!
=
null
&
&
sUri
.
startsWith
(
CONTENT_SCHEME
)
;
}
TargetApi
(
19
)
public
static
Nullable
String
getExternalStoragePath
(
final
Context
context
final
Nullable
String
uuid
)
{
final
File
[
]
externalStorages
=
context
.
getExternalFilesDirs
(
null
)
;
final
String
uuidDir
=
!
TextUtils
.
isEmpty
(
uuid
)
?
'
/
'
+
uuid
+
'
/
'
:
null
;
String
firstNonEmulatedStorage
=
null
;
String
targetStorage
=
null
;
for
(
final
File
externalStorage
:
externalStorages
)
{
if
(
isExternalStorageEmulated
(
externalStorage
)
)
{
continue
;
}
String
storagePath
=
externalStorage
.
getAbsolutePath
(
)
;
storagePath
=
storagePath
.
substring
(
0
storagePath
.
indexOf
(
"
/
Android
"
)
)
;
if
(
firstNonEmulatedStorage
=
=
null
)
{
firstNonEmulatedStorage
=
storagePath
;
}
if
(
!
TextUtils
.
isEmpty
(
uuidDir
)
&
&
storagePath
.
contains
(
uuidDir
)
)
{
targetStorage
=
storagePath
;
break
;
}
}
if
(
targetStorage
=
=
null
)
{
targetStorage
=
firstNonEmulatedStorage
;
}
return
targetStorage
;
}
public
static
boolean
isExternalStorageEmulated
(
final
File
path
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
21
)
{
return
Environment
.
isExternalStorageEmulated
(
path
)
;
}
else
{
final
String
absPath
=
path
.
getAbsolutePath
(
)
;
return
absPath
.
contains
(
"
/
sdcard0
"
)
|
|
absPath
.
contains
(
"
/
storage
/
emulated
"
)
;
}
}
private
static
Nullable
String
canonicalizeFilename
(
Nullable
final
String
originalFilename
)
{
if
(
TextUtils
.
isEmpty
(
originalFilename
)
)
{
return
null
;
}
else
{
return
new
File
(
originalFilename
)
.
getName
(
)
;
}
}
}
