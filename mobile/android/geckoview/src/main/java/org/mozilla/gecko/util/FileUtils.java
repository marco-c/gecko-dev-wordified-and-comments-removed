package
org
.
mozilla
.
gecko
.
util
;
import
android
.
util
.
Log
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
FilenameFilter
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
Random
;
import
java
.
util
.
Set
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
public
class
FileUtils
{
private
static
final
String
LOGTAG
=
"
GeckoFileUtils
"
;
static
public
class
NameAndAgeFilter
implements
FilenameFilter
{
final
private
String
mName
;
final
private
double
mMaxAge
;
public
NameAndAgeFilter
(
String
name
double
age
)
{
mName
=
name
;
mMaxAge
=
age
;
}
Override
public
boolean
accept
(
File
dir
String
filename
)
{
if
(
mName
=
=
null
|
|
mName
.
matches
(
filename
)
)
{
File
f
=
new
File
(
dir
filename
)
;
if
(
mMaxAge
<
0
|
|
System
.
currentTimeMillis
(
)
-
f
.
lastModified
(
)
>
mMaxAge
)
{
return
true
;
}
}
return
false
;
}
}
RobocopTarget
public
static
void
delTree
(
File
dir
FilenameFilter
filter
boolean
recurse
)
{
String
[
]
files
=
null
;
if
(
filter
!
=
null
)
{
files
=
dir
.
list
(
filter
)
;
}
else
{
files
=
dir
.
list
(
)
;
}
if
(
files
=
=
null
)
{
return
;
}
for
(
String
file
:
files
)
{
File
f
=
new
File
(
dir
file
)
;
delete
(
f
recurse
)
;
}
}
public
static
boolean
delete
(
File
file
)
throws
IOException
{
return
delete
(
file
true
)
;
}
public
static
boolean
delete
(
File
file
boolean
recurse
)
{
if
(
file
.
isDirectory
(
)
&
&
recurse
)
{
String
files
[
]
=
file
.
list
(
)
;
for
(
String
temp
:
files
)
{
File
fileDelete
=
new
File
(
file
temp
)
;
try
{
delete
(
fileDelete
)
;
}
catch
(
IOException
ex
)
{
Log
.
i
(
LOGTAG
"
Error
deleting
"
+
fileDelete
.
getPath
(
)
ex
)
;
}
}
}
return
file
.
delete
(
)
;
}
public
static
JSONObject
readJSONObjectFromFile
(
final
File
file
)
throws
IOException
JSONException
{
if
(
file
.
length
(
)
=
=
0
)
{
throw
new
IOException
(
"
Given
file
is
empty
-
the
JSON
parser
cannot
create
an
object
from
an
empty
file
"
)
;
}
return
new
JSONObject
(
readStringFromFile
(
file
)
)
;
}
public
static
String
readStringFromFile
(
final
File
file
)
throws
IOException
{
if
(
!
file
.
exists
(
)
)
{
throw
new
FileNotFoundException
(
"
Given
file
"
+
file
+
"
does
not
exist
"
)
;
}
else
if
(
file
.
length
(
)
=
=
0
)
{
return
"
"
;
}
final
int
len
=
(
int
)
file
.
length
(
)
;
return
readStringFromInputStreamAndCloseStream
(
new
FileInputStream
(
file
)
len
)
;
}
public
static
String
readStringFromInputStreamAndCloseStream
(
final
InputStream
inputStream
final
int
bufferSize
)
throws
IOException
{
if
(
bufferSize
<
=
0
)
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
throw
new
IllegalArgumentException
(
"
Expected
buffer
size
larger
than
0
.
Got
:
"
+
bufferSize
)
;
}
final
StringBuilder
stringBuilder
=
new
StringBuilder
(
bufferSize
)
;
final
InputStreamReader
reader
=
new
InputStreamReader
(
inputStream
Charset
.
forName
(
"
UTF
-
8
"
)
)
;
try
{
int
charsRead
;
final
char
[
]
buffer
=
new
char
[
bufferSize
]
;
while
(
(
charsRead
=
reader
.
read
(
buffer
0
bufferSize
)
)
!
=
-
1
)
{
stringBuilder
.
append
(
buffer
0
charsRead
)
;
}
}
finally
{
reader
.
close
(
)
;
}
return
stringBuilder
.
toString
(
)
;
}
public
static
void
writeJSONObjectToFile
(
final
File
file
final
JSONObject
obj
)
throws
IOException
{
writeStringToFile
(
file
obj
.
toString
(
)
)
;
}
public
static
void
writeStringToFile
(
final
File
file
final
String
str
)
throws
IOException
{
writeStringToOutputStreamAndCloseStream
(
new
FileOutputStream
(
file
false
)
str
)
;
}
public
static
void
writeStringToOutputStreamAndCloseStream
(
final
OutputStream
outputStream
final
String
str
)
throws
IOException
{
try
{
final
OutputStreamWriter
writer
=
new
OutputStreamWriter
(
outputStream
Charset
.
forName
(
"
UTF
-
8
"
)
)
;
try
{
writer
.
write
(
str
)
;
}
finally
{
writer
.
close
(
)
;
}
}
finally
{
outputStream
.
close
(
)
;
}
}
public
static
class
FilenameWhitelistFilter
implements
FilenameFilter
{
private
final
Set
<
String
>
mFilenameWhitelist
;
public
FilenameWhitelistFilter
(
final
Set
<
String
>
filenameWhitelist
)
{
mFilenameWhitelist
=
filenameWhitelist
;
}
Override
public
boolean
accept
(
final
File
dir
final
String
filename
)
{
return
mFilenameWhitelist
.
contains
(
filename
)
;
}
}
public
static
class
FilenameRegexFilter
implements
FilenameFilter
{
private
final
Pattern
mPattern
;
private
Matcher
mCachedMatcher
;
public
FilenameRegexFilter
(
final
Pattern
pattern
)
{
mPattern
=
pattern
;
}
public
FilenameRegexFilter
(
final
String
pattern
)
{
mPattern
=
Pattern
.
compile
(
pattern
)
;
}
Override
public
boolean
accept
(
final
File
dir
final
String
filename
)
{
if
(
mCachedMatcher
=
=
null
)
{
mCachedMatcher
=
mPattern
.
matcher
(
filename
)
;
}
else
{
mCachedMatcher
.
reset
(
filename
)
;
}
return
mCachedMatcher
.
matches
(
)
;
}
}
public
static
class
FileLastModifiedComparator
implements
Comparator
<
File
>
{
Override
public
int
compare
(
final
File
lhs
final
File
rhs
)
{
final
long
lhsModified
=
lhs
.
lastModified
(
)
;
final
long
rhsModified
=
rhs
.
lastModified
(
)
;
if
(
lhsModified
<
rhsModified
)
{
return
-
1
;
}
else
if
(
lhsModified
=
=
rhsModified
)
{
return
0
;
}
else
{
return
1
;
}
}
}
public
static
File
createTempDir
(
File
directory
String
prefix
)
{
if
(
prefix
.
length
(
)
<
3
)
{
throw
new
IllegalArgumentException
(
"
prefix
must
be
at
least
3
characters
"
)
;
}
if
(
directory
=
=
null
)
{
String
tmpDir
=
System
.
getProperty
(
"
java
.
io
.
tmpdir
"
"
.
"
)
;
directory
=
new
File
(
tmpDir
)
;
}
File
result
;
Random
random
=
new
Random
(
)
;
do
{
result
=
new
File
(
directory
prefix
+
random
.
nextInt
(
)
)
;
}
while
(
!
result
.
mkdirs
(
)
)
;
return
result
;
}
}
