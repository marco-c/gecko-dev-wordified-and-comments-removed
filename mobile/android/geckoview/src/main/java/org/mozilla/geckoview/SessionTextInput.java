package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
InputMethods
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
IGeckoEditableParent
;
import
org
.
mozilla
.
gecko
.
NativeQueue
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
Build
;
import
android
.
os
.
Handler
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
text
.
Editable
;
import
android
.
text
.
InputType
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewStructure
;
import
android
.
view
.
autofill
.
AutofillManager
;
import
android
.
view
.
inputmethod
.
CursorAnchorInfo
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
ExtractedText
;
import
android
.
view
.
inputmethod
.
ExtractedTextRequest
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
java
.
util
.
Locale
;
public
final
class
SessionTextInput
{
static
final
String
LOGTAG
=
"
GeckoSessionTextInput
"
;
private
static
final
boolean
DEBUG
=
false
;
interface
InputConnectionClient
{
View
getView
(
)
;
Handler
getHandler
(
Handler
defHandler
)
;
InputConnection
onCreateInputConnection
(
EditorInfo
attrs
)
;
}
interface
EditableClient
{
WrapForJNI
final
int
ONE_SHOT
=
1
;
WrapForJNI
final
int
START_MONITOR
=
2
;
WrapForJNI
final
int
END_MONITOR
=
3
;
void
sendKeyEvent
(
Nullable
View
view
int
action
NonNull
KeyEvent
event
)
;
Editable
getEditable
(
)
;
void
setBatchMode
(
boolean
isBatchMode
)
;
Handler
setInputConnectionHandler
(
NonNull
Handler
handler
)
;
void
postToInputConnection
(
NonNull
Runnable
runnable
)
;
void
requestCursorUpdates
(
int
requestMode
)
;
}
interface
EditableListener
{
WrapForJNI
final
int
NOTIFY_IME_OF_TOKEN
=
-
3
;
WrapForJNI
final
int
NOTIFY_IME_OPEN_VKB
=
-
2
;
WrapForJNI
final
int
NOTIFY_IME_REPLY_EVENT
=
-
1
;
WrapForJNI
final
int
NOTIFY_IME_OF_FOCUS
=
1
;
WrapForJNI
final
int
NOTIFY_IME_OF_BLUR
=
2
;
WrapForJNI
final
int
NOTIFY_IME_TO_COMMIT_COMPOSITION
=
8
;
WrapForJNI
final
int
NOTIFY_IME_TO_CANCEL_COMPOSITION
=
9
;
final
int
IME_STATE_UNKNOWN
=
-
1
;
final
int
IME_STATE_DISABLED
=
0
;
final
int
IME_STATE_ENABLED
=
1
;
final
int
IME_STATE_PASSWORD
=
2
;
WrapForJNI
final
int
IME_FLAG_PRIVATE_BROWSING
=
1
;
WrapForJNI
final
int
IME_FLAG_USER_ACTION
=
2
;
void
notifyIME
(
int
type
)
;
void
notifyIMEContext
(
int
state
String
typeHint
String
modeHint
String
actionHint
int
flag
)
;
void
onSelectionChange
(
)
;
void
onTextChange
(
)
;
void
onDefaultKeyEvent
(
KeyEvent
event
)
;
void
updateCompositionRects
(
final
RectF
[
]
aRects
)
;
}
private
static
final
class
DefaultDelegate
implements
GeckoSession
.
TextInputDelegate
{
public
static
final
DefaultDelegate
INSTANCE
=
new
DefaultDelegate
(
)
;
private
InputMethodManager
getInputMethodManager
(
Nullable
final
View
view
)
{
if
(
view
=
=
null
)
{
return
null
;
}
return
(
InputMethodManager
)
view
.
getContext
(
)
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
;
}
Override
public
void
restartInput
(
NonNull
final
GeckoSession
session
final
int
reason
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
if
(
reason
=
=
RESTART_REASON_FOCUS
)
{
final
Context
context
=
(
view
!
=
null
)
?
view
.
getContext
(
)
:
null
;
if
(
(
context
instanceof
Activity
)
&
&
!
ActivityUtils
.
isFullScreen
(
(
Activity
)
context
)
)
{
session
.
getDynamicToolbarAnimator
(
)
.
showToolbar
(
true
)
;
}
}
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
=
=
null
)
{
return
;
}
if
(
InputMethods
.
needsSoftResetWorkaround
(
InputMethods
.
getCurrentInputMethod
(
view
.
getContext
(
)
)
)
)
{
imm
.
updateSelection
(
view
-
1
-
1
-
1
-
1
)
;
}
try
{
imm
.
restartInput
(
view
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Error
restarting
input
"
e
)
;
}
}
Override
public
void
showSoftInput
(
NonNull
final
GeckoSession
session
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
if
(
view
.
hasFocus
(
)
&
&
!
imm
.
isActive
(
view
)
)
{
view
.
clearFocus
(
)
;
view
.
requestFocus
(
)
;
}
imm
.
showSoftInput
(
view
0
)
;
}
}
Override
public
void
hideSoftInput
(
NonNull
final
GeckoSession
session
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
hideSoftInputFromWindow
(
view
.
getWindowToken
(
)
0
)
;
}
}
Override
public
void
updateSelection
(
NonNull
final
GeckoSession
session
final
int
selStart
final
int
selEnd
final
int
compositionStart
final
int
compositionEnd
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
if
(
compositionStart
<
0
&
&
compositionEnd
<
0
&
&
InputMethods
.
needsRestartInput
(
InputMethods
.
getCurrentInputMethod
(
view
.
getContext
(
)
)
)
)
{
try
{
imm
.
restartInput
(
view
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Error
restarting
input
"
e
)
;
}
}
imm
.
updateSelection
(
view
selStart
selEnd
compositionStart
compositionEnd
)
;
}
}
Override
public
void
updateExtractedText
(
NonNull
final
GeckoSession
session
NonNull
final
ExtractedTextRequest
request
NonNull
final
ExtractedText
text
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
updateExtractedText
(
view
request
.
token
text
)
;
}
}
TargetApi
(
21
)
Override
public
void
updateCursorAnchorInfo
(
NonNull
final
GeckoSession
session
NonNull
final
CursorAnchorInfo
info
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
updateCursorAnchorInfo
(
view
info
)
;
}
}
Override
public
void
notifyAutoFill
(
NonNull
final
GeckoSession
session
AutoFillNotification
final
int
notification
final
int
virtualId
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
if
(
Build
.
VERSION
.
SDK_INT
<
26
|
|
view
=
=
null
)
{
return
;
}
final
AutofillManager
manager
=
view
.
getContext
(
)
.
getSystemService
(
AutofillManager
.
class
)
;
if
(
manager
=
=
null
)
{
return
;
}
switch
(
notification
)
{
case
AUTO_FILL_NOTIFY_STARTED
:
manager
.
cancel
(
)
;
break
;
case
AUTO_FILL_NOTIFY_COMMITTED
:
manager
.
commit
(
)
;
break
;
case
AUTO_FILL_NOTIFY_CANCELED
:
manager
.
cancel
(
)
;
break
;
case
AUTO_FILL_NOTIFY_VIEW_ENTERED
:
manager
.
notifyViewEntered
(
view
virtualId
getDummyAutoFillRect
(
session
true
view
)
)
;
break
;
case
AUTO_FILL_NOTIFY_VIEW_EXITED
:
manager
.
notifyViewExited
(
view
virtualId
)
;
break
;
}
}
}
private
final
GeckoSession
mSession
;
private
final
NativeQueue
mQueue
;
private
final
GeckoEditable
mEditable
;
private
InputConnectionClient
mInputConnection
;
private
GeckoSession
.
TextInputDelegate
mDelegate
;
private
SparseArray
<
GeckoBundle
>
mAutoFillNodes
;
private
SparseArray
<
EventCallback
>
mAutoFillRoots
;
private
int
mAutoFillFocusedId
=
View
.
NO_ID
;
private
int
mAutoFillFocusedRoot
=
View
.
NO_ID
;
SessionTextInput
(
final
NonNull
GeckoSession
session
final
NonNull
NativeQueue
queue
)
{
mSession
=
session
;
mQueue
=
queue
;
mEditable
=
new
GeckoEditable
(
session
)
;
session
.
getEventDispatcher
(
)
.
registerUiThreadListener
(
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
AddAutoFill
"
.
equals
(
event
)
)
{
addAutoFill
(
message
callback
)
;
}
else
if
(
"
GeckoView
:
ClearAutoFill
"
.
equals
(
event
)
)
{
clearAutoFill
(
)
;
}
else
if
(
"
GeckoView
:
OnAutoFillFocus
"
.
equals
(
event
)
)
{
onAutoFillFocus
(
message
)
;
}
}
}
"
GeckoView
:
AddAutoFill
"
"
GeckoView
:
ClearAutoFill
"
"
GeckoView
:
OnAutoFillFocus
"
null
)
;
}
void
onWindowChanged
(
final
GeckoSession
.
Window
window
)
{
if
(
mQueue
.
isReady
(
)
)
{
window
.
attachEditable
(
mEditable
)
;
}
else
{
mQueue
.
queueUntilReady
(
window
"
attachEditable
"
IGeckoEditableParent
.
class
mEditable
)
;
}
}
AnyThread
public
synchronized
NonNull
Handler
getHandler
(
final
NonNull
Handler
defHandler
)
{
if
(
mInputConnection
!
=
null
)
{
return
mInputConnection
.
getHandler
(
defHandler
)
;
}
return
defHandler
;
}
UiThread
public
Nullable
View
getView
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mInputConnection
!
=
null
?
mInputConnection
.
getView
(
)
:
null
;
}
UiThread
public
synchronized
void
setView
(
final
Nullable
View
view
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
view
=
=
null
)
{
mInputConnection
=
null
;
}
else
if
(
mInputConnection
=
=
null
|
|
mInputConnection
.
getView
(
)
!
=
view
)
{
mInputConnection
=
GeckoInputConnection
.
create
(
mSession
view
mEditable
)
;
}
mEditable
.
setListener
(
(
EditableListener
)
mInputConnection
)
;
}
AnyThread
public
synchronized
Nullable
InputConnection
onCreateInputConnection
(
final
NonNull
EditorInfo
attrs
)
{
mEditable
.
onCreateInputConnection
(
attrs
)
;
if
(
!
mQueue
.
isReady
(
)
|
|
mInputConnection
=
=
null
)
{
return
null
;
}
return
mInputConnection
.
onCreateInputConnection
(
attrs
)
;
}
UiThread
public
boolean
onKeyPreIme
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyPreIme
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyDown
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyDown
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyUp
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyUp
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyLongPress
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyLongPress
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyMultiple
(
final
int
keyCode
final
int
repeatCount
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyMultiple
(
getView
(
)
keyCode
repeatCount
event
)
;
}
UiThread
public
void
setDelegate
(
Nullable
final
GeckoSession
.
TextInputDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDelegate
=
delegate
;
}
UiThread
public
NonNull
GeckoSession
.
TextInputDelegate
getDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mDelegate
=
=
null
)
{
mDelegate
=
DefaultDelegate
.
INSTANCE
;
}
return
mDelegate
;
}
TargetApi
(
23
)
UiThread
public
void
onProvideAutofillVirtualStructure
(
NonNull
final
ViewStructure
structure
final
int
flags
)
{
final
View
view
=
getView
(
)
;
if
(
view
!
=
null
)
{
structure
.
setClassName
(
view
.
getClass
(
)
.
getName
(
)
)
;
}
structure
.
setEnabled
(
true
)
;
structure
.
setVisibility
(
View
.
VISIBLE
)
;
final
Rect
rect
=
getDummyAutoFillRect
(
mSession
false
null
)
;
structure
.
setDimens
(
rect
.
left
rect
.
top
0
0
rect
.
width
(
)
rect
.
height
(
)
)
;
if
(
mAutoFillRoots
=
=
null
)
{
structure
.
setChildCount
(
0
)
;
return
;
}
final
int
size
=
mAutoFillRoots
.
size
(
)
;
structure
.
setChildCount
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
final
int
id
=
mAutoFillRoots
.
keyAt
(
i
)
;
final
GeckoBundle
root
=
mAutoFillNodes
.
get
(
id
)
;
fillAutoFillStructure
(
view
id
root
structure
.
newChild
(
i
)
rect
)
;
}
}
UiThread
public
void
autofill
(
final
NonNull
SparseArray
<
CharSequence
>
values
)
{
if
(
mAutoFillRoots
=
=
null
)
{
return
;
}
GeckoBundle
response
=
null
;
EventCallback
callback
=
null
;
for
(
int
i
=
0
;
i
<
values
.
size
(
)
;
i
+
+
)
{
final
int
id
=
values
.
keyAt
(
i
)
;
final
CharSequence
value
=
values
.
valueAt
(
i
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
performAutoFill
(
"
+
id
+
'
)
'
)
;
}
int
rootId
=
id
;
for
(
int
currentId
=
id
;
currentId
!
=
View
.
NO_ID
;
)
{
final
GeckoBundle
bundle
=
mAutoFillNodes
.
get
(
currentId
)
;
if
(
bundle
=
=
null
)
{
return
;
}
rootId
=
currentId
;
currentId
=
bundle
.
getInt
(
"
parent
"
View
.
NO_ID
)
;
}
final
EventCallback
newCallback
=
mAutoFillRoots
.
get
(
rootId
)
;
if
(
callback
=
=
null
|
|
newCallback
!
=
callback
)
{
if
(
callback
!
=
null
)
{
callback
.
sendSuccess
(
response
)
;
}
response
=
new
GeckoBundle
(
values
.
size
(
)
-
i
)
;
callback
=
newCallback
;
}
response
.
putString
(
String
.
valueOf
(
id
)
String
.
valueOf
(
value
)
)
;
}
if
(
callback
!
=
null
)
{
callback
.
sendSuccess
(
response
)
;
}
}
TargetApi
(
23
)
private
void
fillAutoFillStructure
(
Nullable
final
View
view
final
int
id
NonNull
final
GeckoBundle
bundle
NonNull
final
ViewStructure
structure
NonNull
final
Rect
rect
)
{
if
(
mAutoFillRoots
=
=
null
)
{
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
fillAutoFillStructure
(
"
+
id
+
'
)
'
)
;
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
if
(
view
!
=
null
)
{
structure
.
setAutofillId
(
view
.
getAutofillId
(
)
id
)
;
}
structure
.
setWebDomain
(
bundle
.
getString
(
"
origin
"
)
)
;
}
structure
.
setId
(
id
null
null
null
)
;
if
(
mAutoFillFocusedRoot
!
=
View
.
NO_ID
&
&
mAutoFillFocusedRoot
=
=
bundle
.
getInt
(
"
root
"
View
.
NO_ID
)
)
{
structure
.
setDimens
(
0
0
0
0
rect
.
width
(
)
rect
.
height
(
)
)
;
}
final
GeckoBundle
[
]
children
=
bundle
.
getBundleArray
(
"
children
"
)
;
if
(
children
!
=
null
)
{
structure
.
setChildCount
(
children
.
length
)
;
for
(
int
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
final
GeckoBundle
childBundle
=
children
[
i
]
;
final
int
childId
=
childBundle
.
getInt
(
"
id
"
)
;
final
ViewStructure
childStructure
=
structure
.
newChild
(
i
)
;
fillAutoFillStructure
(
view
childId
childBundle
childStructure
rect
)
;
mAutoFillNodes
.
append
(
childId
childBundle
)
;
}
}
String
tag
=
bundle
.
getString
(
"
tag
"
"
"
)
;
final
String
type
=
bundle
.
getString
(
"
type
"
"
text
"
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
final
GeckoBundle
attrs
=
bundle
.
getBundle
(
"
attributes
"
)
;
final
ViewStructure
.
HtmlInfo
.
Builder
builder
=
structure
.
newHtmlInfoBuilder
(
tag
.
toLowerCase
(
Locale
.
US
)
)
;
for
(
final
String
key
:
attrs
.
keys
(
)
)
{
builder
.
addAttribute
(
key
String
.
valueOf
(
attrs
.
get
(
key
)
)
)
;
}
structure
.
setHtmlInfo
(
builder
.
build
(
)
)
;
}
if
(
"
INPUT
"
.
equals
(
tag
)
&
&
!
bundle
.
getBoolean
(
"
editable
"
false
)
)
{
tag
=
"
"
;
}
switch
(
tag
)
{
case
"
INPUT
"
:
case
"
TEXTAREA
"
:
{
final
boolean
disabled
=
bundle
.
getBoolean
(
"
disabled
"
)
;
structure
.
setClassName
(
"
android
.
widget
.
EditText
"
)
;
structure
.
setEnabled
(
!
disabled
)
;
structure
.
setFocusable
(
!
disabled
)
;
structure
.
setFocused
(
id
=
=
mAutoFillFocusedId
)
;
structure
.
setVisibility
(
View
.
VISIBLE
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
structure
.
setAutofillType
(
View
.
AUTOFILL_TYPE_TEXT
)
;
}
break
;
}
default
:
if
(
children
!
=
null
)
{
structure
.
setClassName
(
"
android
.
view
.
ViewGroup
"
)
;
}
else
{
structure
.
setClassName
(
"
android
.
view
.
View
"
)
;
}
break
;
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
&
&
"
INPUT
"
.
equals
(
tag
)
)
{
switch
(
type
)
{
case
"
email
"
:
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_EMAIL_ADDRESS
}
)
;
structure
.
setInputType
(
InputType
.
TYPE_CLASS_TEXT
|
InputType
.
TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS
)
;
break
;
case
"
number
"
:
structure
.
setInputType
(
InputType
.
TYPE_CLASS_NUMBER
)
;
break
;
case
"
password
"
:
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_PASSWORD
}
)
;
structure
.
setInputType
(
InputType
.
TYPE_CLASS_TEXT
|
InputType
.
TYPE_TEXT_VARIATION_WEB_PASSWORD
)
;
break
;
case
"
tel
"
:
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_PHONE
}
)
;
structure
.
setInputType
(
InputType
.
TYPE_CLASS_PHONE
)
;
break
;
case
"
url
"
:
structure
.
setInputType
(
InputType
.
TYPE_CLASS_TEXT
|
InputType
.
TYPE_TEXT_VARIATION_URI
)
;
break
;
case
"
text
"
:
final
String
autofillhint
=
bundle
.
getString
(
"
autofillhint
"
"
"
)
;
if
(
autofillhint
.
equals
(
"
username
"
)
)
{
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_USERNAME
}
)
;
structure
.
setInputType
(
InputType
.
TYPE_CLASS_TEXT
|
InputType
.
TYPE_TEXT_VARIATION_WEB_EDIT_TEXT
)
;
}
break
;
}
}
}
void
addAutoFill
(
NonNull
final
GeckoBundle
message
NonNull
final
EventCallback
callback
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
23
)
{
return
;
}
final
boolean
initializing
;
if
(
mAutoFillRoots
=
=
null
)
{
mAutoFillRoots
=
new
SparseArray
<
>
(
)
;
mAutoFillNodes
=
new
SparseArray
<
>
(
)
;
initializing
=
true
;
}
else
{
initializing
=
false
;
}
final
int
id
=
message
.
getInt
(
"
id
"
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
addAutoFill
(
"
+
id
+
'
)
'
)
;
}
mAutoFillRoots
.
append
(
id
callback
)
;
mAutoFillNodes
.
append
(
id
message
)
;
if
(
initializing
)
{
getDelegate
(
)
.
notifyAutoFill
(
mSession
GeckoSession
.
TextInputDelegate
.
AUTO_FILL_NOTIFY_STARTED
id
)
;
}
else
{
getDelegate
(
)
.
notifyAutoFill
(
mSession
GeckoSession
.
TextInputDelegate
.
AUTO_FILL_NOTIFY_VIEW_ADDED
id
)
;
}
}
void
clearAutoFill
(
)
{
if
(
mAutoFillRoots
=
=
null
)
{
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
clearAutoFill
(
)
"
)
;
}
mAutoFillRoots
=
null
;
mAutoFillNodes
=
null
;
mAutoFillFocusedId
=
View
.
NO_ID
;
mAutoFillFocusedRoot
=
View
.
NO_ID
;
getDelegate
(
)
.
notifyAutoFill
(
mSession
GeckoSession
.
TextInputDelegate
.
AUTO_FILL_NOTIFY_CANCELED
View
.
NO_ID
)
;
}
void
onAutoFillFocus
(
Nullable
final
GeckoBundle
message
)
{
if
(
mAutoFillRoots
=
=
null
)
{
return
;
}
final
int
id
;
final
int
root
;
if
(
message
!
=
null
)
{
id
=
message
.
getInt
(
"
id
"
)
;
root
=
message
.
getInt
(
"
root
"
)
;
}
else
{
id
=
root
=
View
.
NO_ID
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onAutoFillFocus
(
"
+
id
+
'
)
'
)
;
}
if
(
mAutoFillFocusedId
=
=
id
)
{
return
;
}
if
(
mAutoFillFocusedId
!
=
View
.
NO_ID
)
{
getDelegate
(
)
.
notifyAutoFill
(
mSession
GeckoSession
.
TextInputDelegate
.
AUTO_FILL_NOTIFY_VIEW_EXITED
mAutoFillFocusedId
)
;
}
mAutoFillFocusedId
=
id
;
mAutoFillFocusedRoot
=
root
;
if
(
id
!
=
View
.
NO_ID
)
{
getDelegate
(
)
.
notifyAutoFill
(
mSession
GeckoSession
.
TextInputDelegate
.
AUTO_FILL_NOTIFY_VIEW_ENTERED
id
)
;
}
}
static
Rect
getDummyAutoFillRect
(
NonNull
final
GeckoSession
session
final
boolean
screen
Nullable
final
View
view
)
{
final
Rect
rect
=
new
Rect
(
)
;
session
.
getSurfaceBounds
(
rect
)
;
if
(
screen
)
{
if
(
view
=
=
null
)
{
throw
new
IllegalArgumentException
(
)
;
}
final
int
[
]
offset
=
new
int
[
2
]
;
view
.
getLocationOnScreen
(
offset
)
;
rect
.
offset
(
offset
[
0
]
offset
[
1
]
)
;
}
return
rect
;
}
}
