package
org
.
mozilla
.
geckoview
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
Handler
;
import
android
.
text
.
Editable
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
inputmethod
.
CursorAnchorInfo
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
ExtractedText
;
import
android
.
view
.
inputmethod
.
ExtractedTextRequest
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
UiThread
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
org
.
mozilla
.
gecko
.
IGeckoEditableParent
;
import
org
.
mozilla
.
gecko
.
InputMethods
;
import
org
.
mozilla
.
gecko
.
NativeQueue
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
public
final
class
SessionTextInput
{
static
final
String
LOGTAG
=
"
GeckoSessionTextInput
"
;
private
static
final
boolean
DEBUG
=
false
;
interface
InputConnectionClient
{
View
getView
(
)
;
Handler
getHandler
(
Handler
defHandler
)
;
InputConnection
onCreateInputConnection
(
EditorInfo
attrs
)
;
}
interface
EditableClient
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
ONE_SHOT
START_MONITOR
END_MONITOR
}
)
interface
CursorMonitorMode
{
}
WrapForJNI
int
ONE_SHOT
=
1
;
WrapForJNI
int
START_MONITOR
=
2
;
WrapForJNI
int
END_MONITOR
=
3
;
void
sendKeyEvent
(
Nullable
View
view
int
action
NonNull
KeyEvent
event
)
;
Editable
getEditable
(
)
;
void
setBatchMode
(
boolean
isBatchMode
)
;
Handler
setInputConnectionHandler
(
NonNull
Handler
handler
)
;
void
postToInputConnection
(
NonNull
Runnable
runnable
)
;
void
requestCursorUpdates
(
CursorMonitorMode
int
requestMode
)
;
void
insertImage
(
NonNull
byte
[
]
data
NonNull
String
mimeType
)
;
}
interface
EditableListener
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
NOTIFY_IME_OF_TOKEN
NOTIFY_IME_OPEN_VKB
NOTIFY_IME_REPLY_EVENT
NOTIFY_IME_OF_FOCUS
NOTIFY_IME_OF_BLUR
NOTIFY_IME_TO_COMMIT_COMPOSITION
NOTIFY_IME_TO_CANCEL_COMPOSITION
}
)
interface
IMENotificationType
{
}
WrapForJNI
int
NOTIFY_IME_OF_TOKEN
=
-
3
;
WrapForJNI
int
NOTIFY_IME_OPEN_VKB
=
-
2
;
WrapForJNI
int
NOTIFY_IME_REPLY_EVENT
=
-
1
;
WrapForJNI
int
NOTIFY_IME_OF_FOCUS
=
1
;
WrapForJNI
int
NOTIFY_IME_OF_BLUR
=
2
;
WrapForJNI
int
NOTIFY_IME_TO_COMMIT_COMPOSITION
=
8
;
WrapForJNI
int
NOTIFY_IME_TO_CANCEL_COMPOSITION
=
9
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
IME_STATE_UNKNOWN
IME_STATE_DISABLED
IME_STATE_ENABLED
IME_STATE_PASSWORD
}
)
interface
IMEState
{
}
int
IME_STATE_UNKNOWN
=
-
1
;
int
IME_STATE_DISABLED
=
0
;
int
IME_STATE_ENABLED
=
1
;
int
IME_STATE_PASSWORD
=
2
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
IME_FLAG_PRIVATE_BROWSING
IME_FLAG_USER_ACTION
IME_FOCUS_NOT_CHANGED
}
)
interface
IMEContextFlags
{
}
WrapForJNI
int
IME_FLAG_PRIVATE_BROWSING
=
1
<
<
0
;
WrapForJNI
int
IME_FLAG_USER_ACTION
=
1
<
<
1
;
WrapForJNI
int
IME_FOCUS_NOT_CHANGED
=
1
<
<
2
;
void
notifyIME
(
IMENotificationType
int
type
)
;
void
notifyIMEContext
(
IMEState
int
state
String
typeHint
String
modeHint
String
actionHint
IMEContextFlags
int
flag
)
;
void
onSelectionChange
(
)
;
void
onTextChange
(
)
;
void
onDiscardComposition
(
)
;
void
onDefaultKeyEvent
(
KeyEvent
event
)
;
void
updateCompositionRects
(
final
RectF
[
]
aRects
final
RectF
aCaretRect
)
;
}
private
static
final
class
DefaultDelegate
implements
GeckoSession
.
TextInputDelegate
{
public
static
final
DefaultDelegate
INSTANCE
=
new
DefaultDelegate
(
)
;
private
InputMethodManager
getInputMethodManager
(
Nullable
final
View
view
)
{
if
(
view
=
=
null
)
{
return
null
;
}
return
(
InputMethodManager
)
view
.
getContext
(
)
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
;
}
Override
public
void
restartInput
(
NonNull
final
GeckoSession
session
final
int
reason
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
=
=
null
)
{
return
;
}
if
(
InputMethods
.
needsSoftResetWorkaround
(
InputMethods
.
getCurrentInputMethod
(
view
.
getContext
(
)
)
)
)
{
imm
.
updateSelection
(
view
-
1
-
1
-
1
-
1
)
;
}
try
{
imm
.
restartInput
(
view
)
;
}
catch
(
final
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Error
restarting
input
"
e
)
;
}
}
Override
public
void
showSoftInput
(
NonNull
final
GeckoSession
session
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
if
(
view
.
hasFocus
(
)
&
&
!
imm
.
isActive
(
view
)
)
{
view
.
clearFocus
(
)
;
view
.
requestFocus
(
)
;
}
imm
.
showSoftInput
(
view
0
)
;
}
}
Override
public
void
hideSoftInput
(
NonNull
final
GeckoSession
session
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
hideSoftInputFromWindow
(
view
.
getWindowToken
(
)
0
)
;
}
}
Override
public
void
updateSelection
(
NonNull
final
GeckoSession
session
final
int
selStart
final
int
selEnd
final
int
compositionStart
final
int
compositionEnd
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
updateSelection
(
view
selStart
selEnd
compositionStart
compositionEnd
)
;
}
}
Override
public
void
updateExtractedText
(
NonNull
final
GeckoSession
session
NonNull
final
ExtractedTextRequest
request
NonNull
final
ExtractedText
text
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
updateExtractedText
(
view
request
.
token
text
)
;
}
}
Override
public
void
updateCursorAnchorInfo
(
NonNull
final
GeckoSession
session
NonNull
final
CursorAnchorInfo
info
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
View
view
=
session
.
getTextInput
(
)
.
getView
(
)
;
final
InputMethodManager
imm
=
getInputMethodManager
(
view
)
;
if
(
imm
!
=
null
)
{
imm
.
updateCursorAnchorInfo
(
view
info
)
;
}
}
}
private
final
GeckoSession
mSession
;
private
final
NativeQueue
mQueue
;
private
final
GeckoEditable
mEditable
;
private
InputConnectionClient
mInputConnection
;
private
GeckoSession
.
TextInputDelegate
mDelegate
;
SessionTextInput
(
final
NonNull
GeckoSession
session
final
NonNull
NativeQueue
queue
)
{
mSession
=
session
;
mQueue
=
queue
;
mEditable
=
new
GeckoEditable
(
session
)
;
}
void
onWindowChanged
(
final
GeckoSession
.
Window
window
)
{
if
(
mQueue
.
isReady
(
)
)
{
window
.
attachEditable
(
mEditable
)
;
}
else
{
mQueue
.
queueUntilReady
(
window
"
attachEditable
"
IGeckoEditableParent
.
class
mEditable
)
;
}
}
AnyThread
public
synchronized
NonNull
Handler
getHandler
(
final
NonNull
Handler
defHandler
)
{
if
(
mInputConnection
!
=
null
)
{
return
mInputConnection
.
getHandler
(
defHandler
)
;
}
return
defHandler
;
}
UiThread
public
Nullable
View
getView
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mInputConnection
!
=
null
?
mInputConnection
.
getView
(
)
:
null
;
}
UiThread
public
synchronized
void
setView
(
final
Nullable
View
view
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
view
=
=
null
)
{
mInputConnection
=
null
;
}
else
if
(
mInputConnection
=
=
null
|
|
mInputConnection
.
getView
(
)
!
=
view
)
{
mInputConnection
=
GeckoInputConnection
.
create
(
mSession
view
mEditable
)
;
}
mEditable
.
setListener
(
(
EditableListener
)
mInputConnection
)
;
}
AnyThread
public
synchronized
Nullable
InputConnection
onCreateInputConnection
(
final
NonNull
EditorInfo
attrs
)
{
mEditable
.
onCreateInputConnection
(
attrs
)
;
if
(
!
mQueue
.
isReady
(
)
|
|
mInputConnection
=
=
null
)
{
return
null
;
}
return
mInputConnection
.
onCreateInputConnection
(
attrs
)
;
}
UiThread
public
boolean
onKeyPreIme
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyPreIme
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyDown
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyDown
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyUp
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyUp
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyLongPress
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyLongPress
(
getView
(
)
keyCode
event
)
;
}
UiThread
public
boolean
onKeyMultiple
(
final
int
keyCode
final
int
repeatCount
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mEditable
.
onKeyMultiple
(
getView
(
)
keyCode
repeatCount
event
)
;
}
UiThread
public
void
setDelegate
(
Nullable
final
GeckoSession
.
TextInputDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDelegate
=
delegate
;
}
UiThread
public
NonNull
GeckoSession
.
TextInputDelegate
getDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mDelegate
=
=
null
)
{
mDelegate
=
DefaultDelegate
.
INSTANCE
;
}
return
mDelegate
;
}
}
