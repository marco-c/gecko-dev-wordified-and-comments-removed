package
org
.
mozilla
.
gecko
;
import
android
.
security
.
KeyChain
;
import
android
.
security
.
KeyChainException
;
import
android
.
util
.
Log
;
import
java
.
security
.
InvalidKeyException
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
security
.
PrivateKey
;
import
java
.
security
.
PublicKey
;
import
java
.
security
.
Signature
;
import
java
.
security
.
SignatureException
;
import
java
.
security
.
cert
.
CertificateEncodingException
;
import
java
.
security
.
cert
.
X509Certificate
;
import
java
.
security
.
interfaces
.
ECPublicKey
;
import
java
.
security
.
interfaces
.
RSAPublicKey
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
javax
.
crypto
.
BadPaddingException
;
import
javax
.
crypto
.
Cipher
;
import
javax
.
crypto
.
IllegalBlockSizeException
;
import
javax
.
crypto
.
NoSuchPaddingException
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
public
class
ClientAuthCertificateManager
{
private
static
final
String
LOGTAG
=
"
ClientAuthCertManager
"
;
private
static
ClientAuthCertificateManager
sClientAuthCertificateManager
=
null
;
private
final
ArrayList
<
ClientAuthCertificate
>
mCertificates
=
new
ArrayList
<
ClientAuthCertificate
>
(
)
;
private
ClientAuthCertificateManager
(
)
{
}
private
static
ClientAuthCertificateManager
getSingleton
(
)
{
synchronized
(
ClientAuthCertificateManager
.
class
)
{
if
(
sClientAuthCertificateManager
=
=
null
)
{
sClientAuthCertificateManager
=
new
ClientAuthCertificateManager
(
)
;
}
return
sClientAuthCertificateManager
;
}
}
private
ClientAuthCertificate
findCertificateByAlias
(
final
String
alias
)
{
for
(
final
ClientAuthCertificate
certificate
:
mCertificates
)
{
if
(
certificate
.
mAlias
.
equals
(
alias
)
)
{
return
certificate
;
}
}
return
null
;
}
WrapForJNI
(
calledFrom
=
"
any
"
)
private
static
byte
[
]
getCertificateFromAlias
(
final
String
alias
)
{
final
ClientAuthCertificateManager
singleton
=
getSingleton
(
)
;
synchronized
(
singleton
)
{
ClientAuthCertificate
certificate
=
singleton
.
findCertificateByAlias
(
alias
)
;
if
(
certificate
!
=
null
)
{
return
certificate
.
getCertificateBytes
(
)
;
}
final
X509Certificate
[
]
chain
;
try
{
chain
=
KeyChain
.
getCertificateChain
(
GeckoAppShell
.
getApplicationContext
(
)
alias
)
;
}
catch
(
final
InterruptedException
|
KeyChainException
e
)
{
Log
.
e
(
LOGTAG
"
getCertificateChain
failed
"
e
)
;
return
null
;
}
if
(
chain
=
=
null
|
|
chain
.
length
<
1
)
{
return
null
;
}
try
{
certificate
=
new
ClientAuthCertificate
(
alias
chain
)
;
singleton
.
mCertificates
.
add
(
certificate
)
;
return
certificate
.
getCertificateBytes
(
)
;
}
catch
(
final
UnsuitableCertificateException
e
)
{
Log
.
e
(
LOGTAG
"
unsuitable
certificate
"
e
)
;
}
}
return
null
;
}
WrapForJNI
(
calledFrom
=
"
any
"
)
private
static
ClientAuthCertificate
[
]
getClientAuthCertificates
(
)
{
final
ClientAuthCertificateManager
singleton
=
ClientAuthCertificateManager
.
getSingleton
(
)
;
synchronized
(
singleton
)
{
return
singleton
.
mCertificates
.
toArray
(
new
ClientAuthCertificate
[
0
]
)
;
}
}
private
ClientAuthCertificate
findCertificateByBytes
(
final
byte
[
]
certificateBytes
)
{
for
(
final
ClientAuthCertificate
certificate
:
mCertificates
)
{
if
(
Arrays
.
equals
(
certificate
.
getCertificateBytes
(
)
certificateBytes
)
)
{
return
certificate
;
}
}
return
null
;
}
WrapForJNI
(
calledFrom
=
"
any
"
)
private
static
byte
[
]
[
]
getCertificateIssuersBytes
(
final
byte
[
]
certificateBytes
)
{
final
ClientAuthCertificateManager
singleton
=
ClientAuthCertificateManager
.
getSingleton
(
)
;
synchronized
(
singleton
)
{
final
ClientAuthCertificate
certificate
=
singleton
.
findCertificateByBytes
(
certificateBytes
)
;
if
(
certificate
=
=
null
)
{
return
null
;
}
return
certificate
.
getIssuersBytes
(
)
;
}
}
WrapForJNI
(
calledFrom
=
"
any
"
)
private
static
byte
[
]
sign
(
final
byte
[
]
certificateBytes
final
byte
[
]
data
final
String
algorithm
)
{
final
ClientAuthCertificateManager
singleton
=
ClientAuthCertificateManager
.
getSingleton
(
)
;
synchronized
(
singleton
)
{
final
ClientAuthCertificate
certificate
=
singleton
.
findCertificateByBytes
(
certificateBytes
)
;
if
(
certificate
=
=
null
)
{
return
null
;
}
final
PrivateKey
key
;
try
{
key
=
KeyChain
.
getPrivateKey
(
GeckoAppShell
.
getApplicationContext
(
)
certificate
.
mAlias
)
;
}
catch
(
final
InterruptedException
|
KeyChainException
e
)
{
Log
.
e
(
LOGTAG
"
getPrivateKey
failed
"
e
)
;
return
null
;
}
if
(
key
=
=
null
)
{
Log
.
e
(
LOGTAG
"
couldn
'
t
get
private
key
"
)
;
return
null
;
}
if
(
algorithm
.
equals
(
"
raw
"
)
)
{
final
Cipher
cipher
;
try
{
cipher
=
Cipher
.
getInstance
(
"
RSA
/
None
/
NoPadding
"
)
;
}
catch
(
final
NoSuchAlgorithmException
|
NoSuchPaddingException
e
)
{
Log
.
e
(
LOGTAG
"
getInstance
failed
"
e
)
;
return
null
;
}
try
{
cipher
.
init
(
Cipher
.
ENCRYPT_MODE
key
)
;
}
catch
(
final
InvalidKeyException
e
)
{
Log
.
e
(
LOGTAG
"
init
failed
"
e
)
;
return
null
;
}
try
{
return
cipher
.
doFinal
(
data
)
;
}
catch
(
final
BadPaddingException
|
IllegalBlockSizeException
e
)
{
Log
.
e
(
LOGTAG
"
doFinal
failed
"
e
)
;
return
null
;
}
}
if
(
!
algorithm
.
equals
(
"
NoneWithRSA
"
)
&
&
!
algorithm
.
equals
(
"
NoneWithECDSA
"
)
)
{
Log
.
e
(
LOGTAG
"
given
unexpected
algorithm
"
+
algorithm
)
;
return
null
;
}
final
Signature
signature
;
try
{
signature
=
Signature
.
getInstance
(
algorithm
)
;
}
catch
(
final
NoSuchAlgorithmException
e
)
{
Log
.
e
(
LOGTAG
"
getInstance
failed
"
e
)
;
return
null
;
}
try
{
signature
.
initSign
(
key
)
;
}
catch
(
final
InvalidKeyException
e
)
{
Log
.
e
(
LOGTAG
"
initSign
failed
"
e
)
;
return
null
;
}
try
{
signature
.
update
(
data
)
;
}
catch
(
final
SignatureException
e
)
{
Log
.
e
(
LOGTAG
"
update
failed
"
e
)
;
return
null
;
}
try
{
return
signature
.
sign
(
)
;
}
catch
(
final
SignatureException
e
)
{
Log
.
e
(
LOGTAG
"
sign
failed
"
e
)
;
return
null
;
}
}
}
private
static
class
UnsuitableCertificateException
extends
Exception
{
public
UnsuitableCertificateException
(
final
String
message
)
{
super
(
message
)
;
}
}
private
static
class
ClientAuthCertificate
extends
JNIObject
{
private
static
final
String
LOGTAG
=
"
ClientAuthCertificate
"
;
private
static
int
sRSAKey
=
2
;
private
static
int
sECKey
=
3
;
private
String
mAlias
;
private
byte
[
]
mCertificateBytes
;
private
byte
[
]
[
]
mIssuersBytes
;
private
byte
[
]
mKeyParameters
;
private
int
mType
;
ClientAuthCertificate
(
final
String
alias
final
X509Certificate
[
]
x509Certificates
)
throws
UnsuitableCertificateException
{
mAlias
=
alias
;
final
ArrayList
<
byte
[
]
>
issuersBytes
=
new
ArrayList
<
byte
[
]
>
(
)
;
for
(
final
X509Certificate
certificate
:
x509Certificates
)
{
if
(
mCertificateBytes
=
=
null
)
{
try
{
mCertificateBytes
=
certificate
.
getEncoded
(
)
;
}
catch
(
final
CertificateEncodingException
cee
)
{
Log
.
e
(
LOGTAG
"
getEncoded
(
)
failed
"
cee
)
;
throw
new
UnsuitableCertificateException
(
"
couldn
'
t
get
certificate
bytes
"
)
;
}
}
else
{
try
{
issuersBytes
.
add
(
certificate
.
getEncoded
(
)
)
;
}
catch
(
final
CertificateEncodingException
cee
)
{
Log
.
e
(
LOGTAG
"
getEncoded
(
)
failed
"
cee
)
;
break
;
}
}
}
mIssuersBytes
=
issuersBytes
.
toArray
(
new
byte
[
0
]
[
0
]
)
;
final
PublicKey
publicKey
=
x509Certificates
[
0
]
.
getPublicKey
(
)
;
if
(
publicKey
instanceof
RSAPublicKey
)
{
mKeyParameters
=
(
(
RSAPublicKey
)
publicKey
)
.
getModulus
(
)
.
toByteArray
(
)
;
mType
=
sRSAKey
;
}
else
if
(
publicKey
instanceof
ECPublicKey
)
{
mKeyParameters
=
publicKey
.
getEncoded
(
)
;
mType
=
sECKey
;
}
else
{
throw
new
UnsuitableCertificateException
(
"
unsupported
key
type
"
)
;
}
}
WrapForJNI
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
(
calledFrom
=
"
any
"
)
public
byte
[
]
getCertificateBytes
(
)
{
return
mCertificateBytes
;
}
WrapForJNI
(
calledFrom
=
"
any
"
)
public
byte
[
]
[
]
getIssuersBytes
(
)
{
return
mIssuersBytes
;
}
WrapForJNI
(
calledFrom
=
"
any
"
)
private
byte
[
]
getKeyParameters
(
)
{
return
mKeyParameters
;
}
WrapForJNI
(
calledFrom
=
"
any
"
)
private
int
getType
(
)
{
return
mType
;
}
}
}
