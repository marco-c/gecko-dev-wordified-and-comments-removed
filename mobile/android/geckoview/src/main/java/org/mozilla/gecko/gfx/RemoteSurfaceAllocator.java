package
org
.
mozilla
.
gecko
.
gfx
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
public
final
class
RemoteSurfaceAllocator
extends
ISurfaceAllocator
.
Stub
{
private
static
final
String
LOGTAG
=
"
RemoteSurfaceAllocator
"
;
private
static
RemoteSurfaceAllocator
mInstance
;
private
final
int
mAllocatorId
;
private
static
AtomicInteger
sNextHandle
=
new
AtomicInteger
(
1
)
;
public
static
synchronized
RemoteSurfaceAllocator
getInstance
(
final
int
allocatorId
)
{
if
(
mInstance
=
=
null
&
&
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
)
{
mInstance
=
new
RemoteSurfaceAllocator
(
allocatorId
)
;
}
return
mInstance
;
}
private
RemoteSurfaceAllocator
(
final
int
allocatorId
)
{
mAllocatorId
=
allocatorId
;
}
Override
public
GeckoSurface
acquireSurface
(
final
int
width
final
int
height
final
boolean
singleBufferMode
)
{
final
long
handle
=
(
(
long
)
mAllocatorId
<
<
32
)
|
sNextHandle
.
getAndIncrement
(
)
;
final
GeckoSurfaceTexture
gst
=
GeckoSurfaceTexture
.
acquire
(
singleBufferMode
handle
)
;
if
(
gst
=
=
null
)
{
return
null
;
}
if
(
width
>
0
&
&
height
>
0
)
{
gst
.
setDefaultBufferSize
(
width
height
)
;
}
return
new
GeckoSurface
(
gst
)
;
}
Override
public
void
releaseSurface
(
final
long
handle
)
{
final
GeckoSurfaceTexture
gst
=
GeckoSurfaceTexture
.
lookup
(
handle
)
;
if
(
gst
!
=
null
)
{
gst
.
decrementUse
(
)
;
}
}
Override
public
void
configureSync
(
final
SyncConfig
config
)
{
final
GeckoSurfaceTexture
gst
=
GeckoSurfaceTexture
.
lookup
(
config
.
sourceTextureHandle
)
;
if
(
gst
!
=
null
)
{
gst
.
configureSnapshot
(
config
.
targetSurface
config
.
width
config
.
height
)
;
}
}
Override
public
void
sync
(
final
long
handle
)
{
final
GeckoSurfaceTexture
gst
=
GeckoSurfaceTexture
.
lookup
(
handle
)
;
if
(
gst
!
=
null
)
{
gst
.
takeSnapshot
(
)
;
}
}
}
