package
org
.
mozilla
.
gecko
.
process
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
util
.
IXPCOMEventTarget
;
import
org
.
mozilla
.
gecko
.
util
.
XPCOMEventTarget
;
import
android
.
content
.
ComponentName
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
ServiceInfo
;
import
android
.
content
.
ServiceConnection
;
import
android
.
os
.
IBinder
;
import
android
.
support
.
annotation
.
NonNull
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
BitSet
;
import
java
.
util
.
concurrent
.
Executor
;
final
class
ServiceAllocator
{
private
static
final
int
MAX_NUM_ISOLATED_CONTENT_SERVICES
=
50
;
private
static
final
Method
sBindIsolatedService
=
resolveBindIsolatedService
(
)
;
private
static
final
Method
sBindServiceWithExecutor
=
resolveBindServiceWithExecutor
(
)
;
public
static
enum
PriorityLevel
{
FOREGROUND
(
Context
.
BIND_IMPORTANT
)
BACKGROUND
(
0
)
IDLE
(
Context
.
BIND_WAIVE_PRIORITY
)
;
private
final
int
mAndroidFlag
;
private
PriorityLevel
(
final
int
androidFlag
)
{
mAndroidFlag
=
androidFlag
;
}
public
int
getAndroidFlag
(
)
{
return
mAndroidFlag
;
}
}
public
static
abstract
class
InstanceInfo
implements
ServiceConnection
{
private
final
ServiceAllocator
mAllocator
;
private
final
GeckoProcessType
mType
;
private
final
Integer
mId
;
private
final
PriorityLevel
mPriority
;
protected
InstanceInfo
(
NonNull
final
ServiceAllocator
allocator
NonNull
final
GeckoProcessType
type
NonNull
final
PriorityLevel
priority
)
{
mAllocator
=
allocator
;
mType
=
type
;
mId
=
mAllocator
.
allocate
(
type
)
;
mPriority
=
priority
;
}
public
PriorityLevel
getPriorityLevel
(
)
{
return
mPriority
;
}
public
int
getId
(
)
{
if
(
mId
=
=
null
)
{
throw
new
RuntimeException
(
"
This
service
does
not
have
a
unique
id
"
)
;
}
return
mId
.
intValue
(
)
;
}
private
String
getIdAsString
(
)
{
return
mId
=
=
null
?
"
"
:
mId
.
toString
(
)
;
}
public
boolean
isContent
(
)
{
return
mType
=
=
GeckoProcessType
.
CONTENT
;
}
public
GeckoProcessType
getType
(
)
{
return
mType
;
}
protected
boolean
bindService
(
)
{
return
mAllocator
.
bindService
(
this
)
;
}
protected
void
unbindService
(
)
{
mAllocator
.
unbindService
(
this
)
;
}
Override
public
final
void
onServiceConnected
(
final
ComponentName
name
final
IBinder
service
)
{
final
IXPCOMEventTarget
launcherThread
=
XPCOMEventTarget
.
launcherThread
(
)
;
if
(
launcherThread
.
isOnCurrentThread
(
)
)
{
onBinderConnected
(
service
)
;
return
;
}
launcherThread
.
execute
(
(
)
-
>
{
onBinderConnected
(
service
)
;
}
)
;
}
Override
public
final
void
onServiceDisconnected
(
final
ComponentName
name
)
{
final
IXPCOMEventTarget
launcherThread
=
XPCOMEventTarget
.
launcherThread
(
)
;
if
(
launcherThread
.
isOnCurrentThread
(
)
)
{
onBinderConnectionLost
(
)
;
return
;
}
launcherThread
.
execute
(
(
)
-
>
{
onBinderConnectionLost
(
)
;
}
)
;
}
protected
abstract
void
onBinderConnected
(
NonNull
final
IBinder
service
)
;
protected
abstract
void
onBinderConnectionLost
(
)
;
}
private
interface
ContentAllocationPolicy
{
boolean
bindService
(
Context
context
InstanceInfo
info
)
;
int
allocate
(
)
;
void
release
(
final
int
id
)
;
}
private
static
final
class
DefaultContentPolicy
implements
ContentAllocationPolicy
{
private
final
int
mMaxNumSvcs
;
private
final
BitSet
mAllocator
;
public
DefaultContentPolicy
(
)
{
mMaxNumSvcs
=
getContentServiceCount
(
)
;
mAllocator
=
new
BitSet
(
mMaxNumSvcs
)
;
}
Override
public
boolean
bindService
(
NonNull
final
Context
context
NonNull
final
InstanceInfo
info
)
{
return
ServiceAllocator
.
bindServiceDefault
(
context
ServiceAllocator
.
getSvcClassNameDefault
(
info
)
info
)
;
}
Override
public
int
allocate
(
)
{
final
int
next
=
mAllocator
.
nextClearBit
(
0
)
;
if
(
next
>
=
mMaxNumSvcs
)
{
throw
new
RuntimeException
(
"
No
more
content
services
available
"
)
;
}
mAllocator
.
set
(
next
)
;
return
next
;
}
Override
public
void
release
(
final
int
id
)
{
if
(
!
mAllocator
.
get
(
id
)
)
{
throw
new
IllegalStateException
(
"
Releasing
an
unallocated
id
!
"
)
;
}
mAllocator
.
clear
(
id
)
;
}
private
static
int
getContentServiceCount
(
)
{
return
ServiceUtils
.
getServiceCount
(
GeckoAppShell
.
getApplicationContext
(
)
GeckoProcessType
.
CONTENT
)
;
}
}
private
static
final
class
IsolatedContentPolicy
implements
ContentAllocationPolicy
{
private
int
mNextIsolatedSvcId
=
0
;
private
int
mCurNumIsolatedSvcs
=
0
;
Override
public
boolean
bindService
(
NonNull
final
Context
context
NonNull
final
InstanceInfo
info
)
{
return
ServiceAllocator
.
bindServiceIsolated
(
context
ServiceUtils
.
buildIsolatedSvcName
(
info
.
getType
(
)
)
info
)
;
}
Override
public
int
allocate
(
)
{
if
(
mCurNumIsolatedSvcs
>
=
MAX_NUM_ISOLATED_CONTENT_SERVICES
)
{
throw
new
RuntimeException
(
"
No
more
content
services
available
"
)
;
}
+
+
mCurNumIsolatedSvcs
;
return
mNextIsolatedSvcId
+
+
;
}
Override
public
void
release
(
final
int
id
)
{
if
(
mCurNumIsolatedSvcs
<
=
0
)
{
throw
new
IllegalStateException
(
"
Releasing
an
unallocated
id
"
)
;
}
-
-
mCurNumIsolatedSvcs
;
}
}
private
ContentAllocationPolicy
mContentAllocPolicy
=
null
;
public
boolean
bindService
(
NonNull
final
InstanceInfo
info
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
if
(
!
info
.
isContent
(
)
)
{
return
bindServiceDefault
(
context
getSvcClassNameDefault
(
info
)
info
)
;
}
return
mContentAllocPolicy
.
bindService
(
context
info
)
;
}
public
void
unbindService
(
NonNull
final
InstanceInfo
info
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
try
{
context
.
unbindService
(
info
)
;
}
finally
{
release
(
info
)
;
}
}
private
Integer
allocate
(
NonNull
final
GeckoProcessType
type
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
type
!
=
GeckoProcessType
.
CONTENT
)
{
return
null
;
}
if
(
mContentAllocPolicy
=
=
null
)
{
if
(
canBindIsolated
(
GeckoProcessType
.
CONTENT
)
)
{
mContentAllocPolicy
=
new
IsolatedContentPolicy
(
)
;
}
else
{
mContentAllocPolicy
=
new
DefaultContentPolicy
(
)
;
}
}
return
Integer
.
valueOf
(
mContentAllocPolicy
.
allocate
(
)
)
;
}
private
void
release
(
NonNull
final
InstanceInfo
info
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
!
info
.
isContent
(
)
)
{
return
;
}
mContentAllocPolicy
.
release
(
info
.
getId
(
)
)
;
}
private
static
boolean
canBindIsolated
(
NonNull
final
GeckoProcessType
type
)
{
if
(
sBindIsolatedService
=
=
null
)
{
return
false
;
}
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
int
svcFlags
=
ServiceUtils
.
getServiceFlags
(
context
type
)
;
return
(
svcFlags
&
ServiceInfo
.
FLAG_ISOLATED_PROCESS
)
!
=
0
;
}
private
static
int
getAndroidFlags
(
NonNull
final
PriorityLevel
priority
)
{
return
Context
.
BIND_AUTO_CREATE
|
priority
.
getAndroidFlag
(
)
;
}
private
static
String
getSvcClassNameDefault
(
NonNull
final
InstanceInfo
info
)
{
return
ServiceUtils
.
buildSvcName
(
info
.
getType
(
)
info
.
getIdAsString
(
)
)
;
}
private
static
boolean
bindServiceDefault
(
NonNull
final
Context
context
NonNull
final
String
svcClassName
NonNull
final
InstanceInfo
info
)
{
final
Intent
intent
=
new
Intent
(
)
;
intent
.
setClassName
(
context
svcClassName
)
;
if
(
sBindServiceWithExecutor
!
=
null
)
{
return
bindServiceWithExecutor
(
context
intent
info
)
;
}
return
context
.
bindService
(
intent
info
getAndroidFlags
(
info
.
getPriorityLevel
(
)
)
)
;
}
private
static
boolean
bindServiceIsolated
(
NonNull
final
Context
context
NonNull
final
String
svcClassName
NonNull
final
InstanceInfo
info
)
{
final
Intent
intent
=
new
Intent
(
)
;
intent
.
setClassName
(
context
svcClassName
)
;
final
String
instanceId
=
info
.
getIdAsString
(
)
;
try
{
final
Boolean
result
=
(
Boolean
)
sBindIsolatedService
.
invoke
(
context
intent
getAndroidFlags
(
info
.
getPriorityLevel
(
)
)
instanceId
XPCOMEventTarget
.
launcherThread
(
)
info
)
;
return
result
.
booleanValue
(
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
private
static
boolean
bindServiceWithExecutor
(
NonNull
final
Context
context
NonNull
final
Intent
intent
NonNull
final
InstanceInfo
info
)
{
try
{
final
Boolean
result
=
(
Boolean
)
sBindServiceWithExecutor
.
invoke
(
context
intent
getAndroidFlags
(
info
.
getPriorityLevel
(
)
)
XPCOMEventTarget
.
launcherThread
(
)
info
)
;
return
result
.
booleanValue
(
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
private
static
Method
resolveBindIsolatedService
(
)
{
try
{
return
Context
.
class
.
getDeclaredMethod
(
"
bindIsolatedService
"
Intent
.
class
Integer
.
class
String
.
class
Executor
.
class
ServiceConnection
.
class
)
;
}
catch
(
NoSuchMethodException
e
)
{
return
null
;
}
catch
(
Throwable
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
private
static
Method
resolveBindServiceWithExecutor
(
)
{
try
{
return
Context
.
class
.
getDeclaredMethod
(
"
bindService
"
Intent
.
class
Integer
.
class
Executor
.
class
ServiceConnection
.
class
)
;
}
catch
(
NoSuchMethodException
e
)
{
return
null
;
}
catch
(
Throwable
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
}
