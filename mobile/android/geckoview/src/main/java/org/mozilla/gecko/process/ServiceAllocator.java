package
org
.
mozilla
.
gecko
.
process
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
util
.
XPCOMEventTarget
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
ComponentName
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
ServiceInfo
;
import
android
.
content
.
ServiceConnection
;
import
android
.
os
.
Build
;
import
android
.
os
.
IBinder
;
import
androidx
.
annotation
.
NonNull
;
import
android
.
util
.
Log
;
import
java
.
util
.
BitSet
;
import
java
.
util
.
EnumMap
;
import
java
.
util
.
Map
.
Entry
;
final
class
ServiceAllocator
{
private
static
final
String
LOGTAG
=
"
ServiceAllocator
"
;
private
static
final
int
MAX_NUM_ISOLATED_CONTENT_SERVICES
=
50
;
private
static
boolean
hasQApis
(
)
{
return
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
Q
;
}
WrapForJNI
public
static
enum
PriorityLevel
{
FOREGROUND
(
Context
.
BIND_IMPORTANT
)
BACKGROUND
(
0
)
IDLE
(
Context
.
BIND_WAIVE_PRIORITY
)
;
private
final
int
mAndroidFlag
;
private
PriorityLevel
(
final
int
androidFlag
)
{
mAndroidFlag
=
androidFlag
;
}
public
int
getAndroidFlag
(
)
{
return
mAndroidFlag
;
}
}
public
static
final
class
BindException
extends
RuntimeException
{
public
BindException
(
NonNull
final
String
msg
)
{
super
(
msg
)
;
}
}
private
interface
BindServiceDelegate
{
boolean
bindService
(
ServiceConnection
binding
PriorityLevel
priority
)
;
String
getServiceName
(
)
;
}
public
static
abstract
class
InstanceInfo
{
private
class
Binding
implements
ServiceConnection
{
Override
public
final
void
onServiceConnected
(
final
ComponentName
name
final
IBinder
service
)
{
XPCOMEventTarget
.
runOnLauncherThread
(
(
)
-
>
{
onBinderConnectedInternal
(
service
)
;
}
)
;
}
Override
public
final
void
onServiceDisconnected
(
final
ComponentName
name
)
{
XPCOMEventTarget
.
runOnLauncherThread
(
(
)
-
>
{
onBinderConnectionLostInternal
(
)
;
}
)
;
}
}
private
class
DefaultBindDelegate
implements
BindServiceDelegate
{
Override
public
boolean
bindService
(
NonNull
final
ServiceConnection
binding
NonNull
final
PriorityLevel
priority
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
Intent
intent
=
new
Intent
(
)
;
intent
.
setClassName
(
context
getServiceName
(
)
)
;
return
bindServiceDefault
(
context
intent
binding
getAndroidFlags
(
priority
)
)
;
}
Override
public
String
getServiceName
(
)
{
return
getSvcClassNameDefault
(
InstanceInfo
.
this
)
;
}
}
private
class
IsolatedBindDelegate
implements
BindServiceDelegate
{
Override
public
boolean
bindService
(
NonNull
final
ServiceConnection
binding
NonNull
final
PriorityLevel
priority
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
Intent
intent
=
new
Intent
(
)
;
intent
.
setClassName
(
context
getServiceName
(
)
)
;
return
bindServiceIsolated
(
context
intent
getAndroidFlags
(
priority
)
getIdAsString
(
)
binding
)
;
}
Override
public
String
getServiceName
(
)
{
return
ServiceUtils
.
buildIsolatedSvcName
(
getType
(
)
)
;
}
}
private
final
ServiceAllocator
mAllocator
;
private
final
GeckoProcessType
mType
;
private
final
Integer
mId
;
private
final
EnumMap
<
PriorityLevel
Binding
>
mBindings
;
private
final
BindServiceDelegate
mBindDelegate
;
private
boolean
mCalledConnected
=
false
;
private
boolean
mCalledConnectionLost
=
false
;
private
boolean
mIsDefunct
=
false
;
private
PriorityLevel
mCurrentPriority
;
private
int
mRelativeImportance
=
0
;
protected
InstanceInfo
(
NonNull
final
ServiceAllocator
allocator
NonNull
final
GeckoProcessType
type
NonNull
final
PriorityLevel
initialPriority
)
{
mAllocator
=
allocator
;
mType
=
type
;
mId
=
mAllocator
.
allocate
(
type
)
;
mBindings
=
new
EnumMap
<
PriorityLevel
Binding
>
(
PriorityLevel
.
class
)
;
mBindDelegate
=
getBindServiceDelegate
(
)
;
mCurrentPriority
=
initialPriority
;
}
private
BindServiceDelegate
getBindServiceDelegate
(
)
{
if
(
mType
!
=
GeckoProcessType
.
CONTENT
)
{
return
this
.
new
DefaultBindDelegate
(
)
;
}
return
mAllocator
.
mContentAllocPolicy
.
getBindServiceDelegate
(
this
)
;
}
public
PriorityLevel
getPriorityLevel
(
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
return
mCurrentPriority
;
}
public
boolean
setPriorityLevel
(
NonNull
final
PriorityLevel
newPriority
)
{
return
setPriorityLevel
(
newPriority
0
)
;
}
public
boolean
setPriorityLevel
(
NonNull
final
PriorityLevel
newPriority
final
int
relativeImportance
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
mCurrentPriority
=
newPriority
;
mRelativeImportance
=
relativeImportance
;
if
(
mBindings
.
size
(
)
=
=
0
)
{
return
true
;
}
return
updateBindings
(
)
;
}
public
int
getId
(
)
{
if
(
mId
=
=
null
)
{
throw
new
RuntimeException
(
"
This
service
does
not
have
a
unique
id
"
)
;
}
return
mId
.
intValue
(
)
;
}
private
String
getIdAsString
(
)
{
return
mId
=
=
null
?
"
"
:
mId
.
toString
(
)
;
}
public
boolean
isContent
(
)
{
return
mType
=
=
GeckoProcessType
.
CONTENT
;
}
public
GeckoProcessType
getType
(
)
{
return
mType
;
}
protected
boolean
bindService
(
)
{
if
(
mIsDefunct
)
{
final
String
errorMsg
=
"
Attempt
to
bind
a
defunct
InstanceInfo
for
"
+
mType
+
"
child
process
"
;
throw
new
BindException
(
errorMsg
)
;
}
return
updateBindings
(
)
;
}
protected
void
unbindService
(
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
mIsDefunct
)
{
return
;
}
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
EnumMap
<
PriorityLevel
Binding
>
cloned
=
mBindings
.
clone
(
)
;
for
(
final
Entry
<
PriorityLevel
Binding
>
entry
:
cloned
.
entrySet
(
)
)
{
try
{
context
.
unbindService
(
entry
.
getValue
(
)
)
;
}
catch
(
final
IllegalArgumentException
e
)
{
}
mBindings
.
remove
(
entry
.
getKey
(
)
)
;
}
if
(
mBindings
.
size
(
)
!
=
0
)
{
throw
new
IllegalStateException
(
"
Unable
to
release
all
bindings
"
)
;
}
mIsDefunct
=
true
;
mAllocator
.
release
(
this
)
;
onReleaseResources
(
)
;
}
private
void
onBinderConnectedInternal
(
NonNull
final
IBinder
service
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
mCalledConnected
)
{
return
;
}
mCalledConnected
=
true
;
onBinderConnected
(
service
)
;
}
private
void
onBinderConnectionLostInternal
(
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
mCalledConnectionLost
)
{
return
;
}
mCalledConnectionLost
=
true
;
onBinderConnectionLost
(
)
;
}
protected
abstract
void
onBinderConnected
(
NonNull
final
IBinder
service
)
;
protected
abstract
void
onReleaseResources
(
)
;
protected
void
onBinderConnectionLost
(
)
{
unbindService
(
)
;
}
TargetApi
(
29
)
private
boolean
updateBindings
(
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
int
numBindSuccesses
=
0
;
int
numBindFailures
=
0
;
int
numUnbindSuccesses
=
0
;
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
int
curPriorityOrdinal
=
mCurrentPriority
.
ordinal
(
)
;
final
PriorityLevel
[
]
levels
=
PriorityLevel
.
values
(
)
;
for
(
int
curLevelIdx
=
0
;
curLevelIdx
<
levels
.
length
;
+
+
curLevelIdx
)
{
final
PriorityLevel
curLevel
=
levels
[
curLevelIdx
]
;
final
Binding
existingBinding
=
mBindings
.
get
(
curLevel
)
;
final
boolean
hasExistingBinding
=
existingBinding
!
=
null
;
if
(
curLevelIdx
<
curPriorityOrdinal
)
{
if
(
hasExistingBinding
)
{
try
{
context
.
unbindService
(
existingBinding
)
;
+
+
numUnbindSuccesses
;
mBindings
.
remove
(
curLevel
)
;
}
catch
(
final
IllegalArgumentException
e
)
{
+
+
numUnbindSuccesses
;
mBindings
.
remove
(
curLevel
)
;
}
}
}
else
{
boolean
bindNeeded
=
!
hasExistingBinding
;
if
(
hasExistingBinding
&
&
hasQApis
(
)
&
&
(
numBindSuccesses
+
numBindFailures
)
=
=
0
)
{
context
.
updateServiceGroup
(
existingBinding
0
mRelativeImportance
)
;
bindNeeded
=
true
;
}
if
(
bindNeeded
)
{
final
Binding
useBinding
=
hasExistingBinding
?
existingBinding
:
this
.
new
Binding
(
)
;
if
(
mBindDelegate
.
bindService
(
useBinding
curLevel
)
)
{
+
+
numBindSuccesses
;
if
(
!
hasExistingBinding
)
{
mBindings
.
put
(
curLevel
useBinding
)
;
}
}
else
{
+
+
numBindFailures
;
}
}
}
}
final
String
svcName
=
mBindDelegate
.
getServiceName
(
)
;
final
StringBuilder
builder
=
new
StringBuilder
(
svcName
)
;
builder
.
append
(
"
updateBindings
:
"
)
.
append
(
mCurrentPriority
)
.
append
(
"
priority
"
)
.
append
(
mRelativeImportance
)
.
append
(
"
importance
"
)
.
append
(
numBindSuccesses
)
.
append
(
"
successful
binds
"
)
.
append
(
numBindFailures
)
.
append
(
"
failed
binds
"
)
.
append
(
numUnbindSuccesses
)
.
append
(
"
successful
unbinds
"
)
;
Log
.
d
(
LOGTAG
builder
.
toString
(
)
)
;
return
numBindFailures
=
=
0
;
}
}
private
interface
ContentAllocationPolicy
{
BindServiceDelegate
getBindServiceDelegate
(
InstanceInfo
info
)
;
int
allocate
(
)
;
void
release
(
final
int
id
)
;
}
private
static
final
class
DefaultContentPolicy
implements
ContentAllocationPolicy
{
private
final
int
mMaxNumSvcs
;
private
final
BitSet
mAllocator
;
public
DefaultContentPolicy
(
)
{
mMaxNumSvcs
=
getContentServiceCount
(
)
;
mAllocator
=
new
BitSet
(
mMaxNumSvcs
)
;
}
Override
public
BindServiceDelegate
getBindServiceDelegate
(
NonNull
final
InstanceInfo
info
)
{
return
info
.
new
DefaultBindDelegate
(
)
;
}
Override
public
int
allocate
(
)
{
final
int
next
=
mAllocator
.
nextClearBit
(
0
)
;
if
(
next
>
=
mMaxNumSvcs
)
{
throw
new
RuntimeException
(
"
No
more
content
services
available
"
)
;
}
mAllocator
.
set
(
next
)
;
return
next
;
}
Override
public
void
release
(
final
int
id
)
{
if
(
!
mAllocator
.
get
(
id
)
)
{
throw
new
IllegalStateException
(
"
Releasing
an
unallocated
id
!
"
)
;
}
mAllocator
.
clear
(
id
)
;
}
private
static
int
getContentServiceCount
(
)
{
return
ServiceUtils
.
getServiceCount
(
GeckoAppShell
.
getApplicationContext
(
)
GeckoProcessType
.
CONTENT
)
;
}
}
private
static
final
class
IsolatedContentPolicy
implements
ContentAllocationPolicy
{
private
int
mNextIsolatedSvcId
=
0
;
private
int
mCurNumIsolatedSvcs
=
0
;
Override
public
BindServiceDelegate
getBindServiceDelegate
(
NonNull
final
InstanceInfo
info
)
{
return
info
.
new
IsolatedBindDelegate
(
)
;
}
Override
public
int
allocate
(
)
{
if
(
mCurNumIsolatedSvcs
>
=
MAX_NUM_ISOLATED_CONTENT_SERVICES
)
{
throw
new
RuntimeException
(
"
No
more
content
services
available
"
)
;
}
+
+
mCurNumIsolatedSvcs
;
return
mNextIsolatedSvcId
+
+
;
}
Override
public
void
release
(
final
int
id
)
{
if
(
mCurNumIsolatedSvcs
<
=
0
)
{
throw
new
IllegalStateException
(
"
Releasing
an
unallocated
id
"
)
;
}
-
-
mCurNumIsolatedSvcs
;
}
}
private
ContentAllocationPolicy
mContentAllocPolicy
=
null
;
private
Integer
allocate
(
NonNull
final
GeckoProcessType
type
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
type
!
=
GeckoProcessType
.
CONTENT
)
{
return
null
;
}
if
(
mContentAllocPolicy
=
=
null
)
{
if
(
canBindIsolated
(
GeckoProcessType
.
CONTENT
)
)
{
mContentAllocPolicy
=
new
IsolatedContentPolicy
(
)
;
}
else
{
mContentAllocPolicy
=
new
DefaultContentPolicy
(
)
;
}
}
return
Integer
.
valueOf
(
mContentAllocPolicy
.
allocate
(
)
)
;
}
private
void
release
(
NonNull
final
InstanceInfo
info
)
{
XPCOMEventTarget
.
assertOnLauncherThread
(
)
;
if
(
!
info
.
isContent
(
)
)
{
return
;
}
mContentAllocPolicy
.
release
(
info
.
getId
(
)
)
;
}
private
static
boolean
canBindIsolated
(
NonNull
final
GeckoProcessType
type
)
{
if
(
!
hasQApis
(
)
)
{
return
false
;
}
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
int
svcFlags
=
ServiceUtils
.
getServiceFlags
(
context
type
)
;
return
(
svcFlags
&
ServiceInfo
.
FLAG_ISOLATED_PROCESS
)
!
=
0
;
}
private
static
int
getAndroidFlags
(
NonNull
final
PriorityLevel
priority
)
{
return
Context
.
BIND_AUTO_CREATE
|
priority
.
getAndroidFlag
(
)
;
}
private
static
String
getSvcClassNameDefault
(
NonNull
final
InstanceInfo
info
)
{
return
ServiceUtils
.
buildSvcName
(
info
.
getType
(
)
info
.
getIdAsString
(
)
)
;
}
TargetApi
(
29
)
private
static
boolean
bindServiceDefault
(
NonNull
final
Context
context
NonNull
final
Intent
intent
NonNull
final
ServiceConnection
conn
final
int
flags
)
{
if
(
hasQApis
(
)
)
{
return
context
.
bindService
(
intent
flags
XPCOMEventTarget
.
launcherThread
(
)
conn
)
;
}
return
context
.
bindService
(
intent
conn
flags
)
;
}
TargetApi
(
29
)
private
static
boolean
bindServiceIsolated
(
NonNull
final
Context
context
NonNull
final
Intent
intent
final
int
flags
NonNull
final
String
instanceId
NonNull
final
ServiceConnection
conn
)
{
return
context
.
bindIsolatedService
(
intent
flags
instanceId
XPCOMEventTarget
.
launcherThread
(
)
conn
)
;
}
}
