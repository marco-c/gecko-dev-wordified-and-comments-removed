package
org
.
mozilla
.
gecko
.
media
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodec
.
BufferInfo
;
import
android
.
media
.
MediaCodec
.
CryptoInfo
;
import
android
.
os
.
Build
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
geckoview
.
BuildConfig
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecInfo
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecSelector
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecUtil
;
import
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
public
class
GeckoHlsVideoRenderer
extends
GeckoHlsRendererBase
{
private
enum
RECONFIGURATION_STATE
{
NONE
WRITE_PENDING
QUEUE_PENDING
}
private
boolean
mRendererReconfigured
;
private
RECONFIGURATION_STATE
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
NONE
;
private
Format
[
]
mStreamFormats
;
private
CodecMaxValues
mCodecMaxValues
;
private
ConcurrentLinkedQueue
<
GeckoHLSSample
>
mDemuxedNoDurationSamples
=
new
ConcurrentLinkedQueue
<
>
(
)
;
private
byte
[
]
mCSDInfo
=
null
;
public
GeckoHlsVideoRenderer
(
GeckoHlsPlayer
.
ComponentEventDispatcher
eventDispatcher
)
{
super
(
C
.
TRACK_TYPE_VIDEO
eventDispatcher
)
;
assertTrue
(
Build
.
VERSION
.
SDK_INT
>
=
16
)
;
LOGTAG
=
getClass
(
)
.
getSimpleName
(
)
;
DEBUG
=
!
BuildConfig
.
MOZILLA_OFFICIAL
;
}
Override
public
final
int
supportsMixedMimeTypeAdaptation
(
)
{
return
ADAPTIVE_NOT_SEAMLESS
;
}
Override
public
final
int
supportsFormat
(
Format
format
)
{
final
String
mimeType
=
format
.
sampleMimeType
;
if
(
!
MimeTypes
.
isVideo
(
mimeType
)
)
{
return
RendererCapabilities
.
FORMAT_UNSUPPORTED_TYPE
;
}
MediaCodecInfo
decoderInfo
=
null
;
try
{
MediaCodecSelector
mediaCodecSelector
=
MediaCodecSelector
.
DEFAULT
;
decoderInfo
=
mediaCodecSelector
.
getDecoderInfo
(
mimeType
false
)
;
}
catch
(
MediaCodecUtil
.
DecoderQueryException
e
)
{
Log
.
e
(
LOGTAG
e
.
getMessage
(
)
)
;
}
if
(
decoderInfo
=
=
null
)
{
return
RendererCapabilities
.
FORMAT_UNSUPPORTED_SUBTYPE
;
}
boolean
decoderCapable
=
decoderInfo
.
isCodecSupported
(
format
.
codecs
)
;
if
(
decoderCapable
&
&
format
.
width
>
0
&
&
format
.
height
>
0
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
21
)
{
try
{
decoderCapable
=
format
.
width
*
format
.
height
<
=
MediaCodecUtil
.
maxH264DecodableFrameSize
(
)
;
}
catch
(
MediaCodecUtil
.
DecoderQueryException
e
)
{
Log
.
e
(
LOGTAG
e
.
getMessage
(
)
)
;
}
if
(
!
decoderCapable
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Check
[
legacyFrameSize
"
+
format
.
width
+
"
x
"
+
format
.
height
+
"
]
"
)
;
}
}
}
else
{
decoderCapable
=
decoderInfo
.
isVideoSizeAndRateSupportedV21
(
format
.
width
format
.
height
format
.
frameRate
)
;
}
}
int
adaptiveSupport
=
decoderInfo
.
adaptive
?
RendererCapabilities
.
ADAPTIVE_SEAMLESS
:
RendererCapabilities
.
ADAPTIVE_NOT_SEAMLESS
;
int
formatSupport
=
decoderCapable
?
RendererCapabilities
.
FORMAT_HANDLED
:
RendererCapabilities
.
FORMAT_EXCEEDS_CAPABILITIES
;
return
adaptiveSupport
|
formatSupport
;
}
Override
protected
final
void
createInputBuffer
(
)
throws
ExoPlaybackException
{
assertTrue
(
mFormats
.
size
(
)
>
0
)
;
Format
currentFormat
=
mFormats
.
get
(
mFormats
.
size
(
)
-
1
)
;
mCodecMaxValues
=
getCodecMaxValues
(
currentFormat
mStreamFormats
)
;
try
{
mInputBuffer
=
ByteBuffer
.
wrap
(
new
byte
[
mCodecMaxValues
.
inputSize
]
)
;
}
catch
(
OutOfMemoryError
e
)
{
Log
.
e
(
LOGTAG
"
cannot
allocate
input
buffer
of
size
"
+
mCodecMaxValues
.
inputSize
e
)
;
throw
ExoPlaybackException
.
createForRenderer
(
new
Exception
(
e
)
getIndex
(
)
)
;
}
}
Override
protected
void
resetRenderer
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
resetRenderer
]
mInitialized
=
"
+
mInitialized
)
;
}
if
(
mInitialized
)
{
mRendererReconfigured
=
false
;
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
NONE
;
mInputBuffer
=
null
;
mCSDInfo
=
null
;
mInitialized
=
false
;
}
}
Override
protected
void
handleReconfiguration
(
DecoderInputBuffer
bufferForRead
)
{
assertTrue
(
mFormats
.
size
(
)
>
0
)
;
if
(
mRendererReconfigurationState
=
=
RECONFIGURATION_STATE
.
WRITE_PENDING
)
{
if
(
bufferForRead
.
data
=
=
null
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
feedInput
]
[
WRITE_PENDING
]
bufferForRead
.
data
is
not
initialized
.
"
)
;
}
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
feedInput
]
[
WRITE_PENDING
]
put
initialization
data
"
)
;
}
Format
currentFormat
=
mFormats
.
get
(
mFormats
.
size
(
)
-
1
)
;
for
(
int
i
=
0
;
i
<
currentFormat
.
initializationData
.
size
(
)
;
i
+
+
)
{
byte
[
]
data
=
currentFormat
.
initializationData
.
get
(
i
)
;
bufferForRead
.
data
.
put
(
data
)
;
}
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
QUEUE_PENDING
;
}
}
Override
protected
void
handleFormatRead
(
DecoderInputBuffer
bufferForRead
)
throws
ExoPlaybackException
{
if
(
mRendererReconfigurationState
=
=
RECONFIGURATION_STATE
.
QUEUE_PENDING
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
feedInput
]
[
QUEUE_PENDING
]
2
formats
in
a
row
.
"
)
;
}
bufferForRead
.
clear
(
)
;
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
WRITE_PENDING
;
}
onInputFormatChanged
(
mFormatHolder
.
format
)
;
}
Override
protected
void
handleEndOfStream
(
DecoderInputBuffer
bufferForRead
)
{
if
(
mRendererReconfigurationState
=
=
RECONFIGURATION_STATE
.
QUEUE_PENDING
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
feedInput
]
[
QUEUE_PENDING
]
isEndOfStream
.
"
)
;
}
bufferForRead
.
clear
(
)
;
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
WRITE_PENDING
;
}
mInputStreamEnded
=
true
;
GeckoHLSSample
sample
=
GeckoHLSSample
.
EOS
;
calculatDuration
(
sample
)
;
}
Override
protected
void
handleSamplePreparation
(
DecoderInputBuffer
bufferForRead
)
{
int
csdInfoSize
=
mCSDInfo
!
=
null
?
mCSDInfo
.
length
:
0
;
int
dataSize
=
bufferForRead
.
data
.
limit
(
)
;
int
size
=
bufferForRead
.
isKeyFrame
(
)
?
csdInfoSize
+
dataSize
:
dataSize
;
byte
[
]
realData
=
new
byte
[
size
]
;
if
(
bufferForRead
.
isKeyFrame
(
)
)
{
System
.
arraycopy
(
mCSDInfo
0
realData
0
csdInfoSize
)
;
bufferForRead
.
data
.
get
(
realData
csdInfoSize
dataSize
)
;
}
else
{
bufferForRead
.
data
.
get
(
realData
0
dataSize
)
;
}
ByteBuffer
buffer
=
ByteBuffer
.
wrap
(
realData
)
;
mInputBuffer
=
bufferForRead
.
data
;
mInputBuffer
.
clear
(
)
;
CryptoInfo
cryptoInfo
=
bufferForRead
.
isEncrypted
(
)
?
bufferForRead
.
cryptoInfo
.
getFrameworkCryptoInfoV16
(
)
:
null
;
BufferInfo
bufferInfo
=
new
BufferInfo
(
)
;
int
flags
=
0
;
flags
|
=
bufferForRead
.
isKeyFrame
(
)
?
MediaCodec
.
BUFFER_FLAG_KEY_FRAME
:
0
;
flags
|
=
bufferForRead
.
isEndOfStream
(
)
?
MediaCodec
.
BUFFER_FLAG_END_OF_STREAM
:
0
;
bufferInfo
.
set
(
0
size
bufferForRead
.
timeUs
flags
)
;
assertTrue
(
mFormats
.
size
(
)
>
0
)
;
GeckoHLSSample
sample
=
GeckoHLSSample
.
create
(
buffer
bufferInfo
cryptoInfo
mFormats
.
size
(
)
-
1
)
;
calculatDuration
(
sample
)
;
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
NONE
;
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
{
super
.
onPositionReset
(
positionUs
joining
)
;
if
(
mInitialized
&
&
mRendererReconfigured
&
&
mFormats
.
size
(
)
!
=
0
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
onPositionReset
]
WRITE_PENDING
"
)
;
}
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
WRITE_PENDING
;
}
}
Override
protected
boolean
clearInputSamplesQueue
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
clearInputSamplesQueue
"
)
;
}
mDemuxedInputSamples
.
clear
(
)
;
mDemuxedNoDurationSamples
.
clear
(
)
;
return
true
;
}
Override
protected
boolean
canReconfigure
(
Format
oldFormat
Format
newFormat
)
{
boolean
canReconfig
=
areAdaptationCompatible
(
oldFormat
newFormat
)
&
&
newFormat
.
width
<
=
mCodecMaxValues
.
width
&
&
newFormat
.
height
<
=
mCodecMaxValues
.
height
&
&
newFormat
.
maxInputSize
<
=
mCodecMaxValues
.
inputSize
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
canReconfigure
]
:
"
+
canReconfig
)
;
}
return
canReconfig
;
}
Override
protected
void
prepareReconfiguration
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
onInputFormatChanged
]
starting
reconfiguration
!
"
)
;
}
mRendererReconfigured
=
true
;
mRendererReconfigurationState
=
RECONFIGURATION_STATE
.
WRITE_PENDING
;
}
Override
protected
void
updateCSDInfo
(
Format
format
)
{
int
size
=
0
;
for
(
int
i
=
0
;
i
<
format
.
initializationData
.
size
(
)
;
i
+
+
)
{
size
+
=
format
.
initializationData
.
get
(
i
)
.
length
;
}
int
startPos
=
0
;
mCSDInfo
=
new
byte
[
size
]
;
for
(
int
i
=
0
;
i
<
format
.
initializationData
.
size
(
)
;
i
+
+
)
{
byte
[
]
data
=
format
.
initializationData
.
get
(
i
)
;
System
.
arraycopy
(
data
0
mCSDInfo
startPos
data
.
length
)
;
startPos
+
=
data
.
length
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
mCSDInfo
[
"
+
Utils
.
bytesToHex
(
mCSDInfo
)
+
"
]
"
)
;
}
}
Override
protected
void
notifyPlayerInputFormatChanged
(
Format
newFormat
)
{
mPlayerEventDispatcher
.
onVideoInputFormatChanged
(
newFormat
)
;
}
private
void
calculateSamplesWithin
(
GeckoHLSSample
[
]
samples
int
range
)
{
for
(
int
i
=
0
;
i
<
range
;
i
+
+
)
{
for
(
int
j
=
-
2
;
j
<
14
;
j
+
+
)
{
if
(
i
+
j
>
=
0
&
&
i
+
j
<
range
&
&
samples
[
i
+
j
]
.
info
.
presentationTimeUs
>
samples
[
i
]
.
info
.
presentationTimeUs
)
{
samples
[
i
]
.
duration
=
Math
.
min
(
samples
[
i
]
.
duration
samples
[
i
+
j
]
.
info
.
presentationTimeUs
-
samples
[
i
]
.
info
.
presentationTimeUs
)
;
}
}
}
}
private
void
calculatDuration
(
GeckoHLSSample
inputSample
)
{
if
(
inputSample
!
=
null
)
{
mDemuxedNoDurationSamples
.
offer
(
inputSample
)
;
}
int
sizeOfNoDura
=
mDemuxedNoDurationSamples
.
size
(
)
;
int
range
=
sizeOfNoDura
>
=
17
?
17
:
sizeOfNoDura
;
GeckoHLSSample
[
]
inputArray
=
mDemuxedNoDurationSamples
.
toArray
(
new
GeckoHLSSample
[
sizeOfNoDura
]
)
;
if
(
range
>
=
17
&
&
!
mInputStreamEnded
)
{
calculateSamplesWithin
(
inputArray
range
)
;
GeckoHLSSample
toQueue
=
mDemuxedNoDurationSamples
.
poll
(
)
;
mDemuxedInputSamples
.
offer
(
toQueue
)
;
if
(
BuildConfig
.
DEBUG_BUILD
)
{
Log
.
d
(
LOGTAG
"
Demuxed
sample
PTS
:
"
+
toQueue
.
info
.
presentationTimeUs
+
"
duration
:
"
+
toQueue
.
duration
+
"
isKeyFrame
(
"
+
toQueue
.
isKeyFrame
(
)
+
"
formatIndex
(
"
+
toQueue
.
formatIndex
+
"
)
queue
size
:
"
+
mDemuxedInputSamples
.
size
(
)
+
"
NoDuQueue
size
:
"
+
mDemuxedNoDurationSamples
.
size
(
)
)
;
}
}
else
if
(
mInputStreamEnded
)
{
calculateSamplesWithin
(
inputArray
sizeOfNoDura
)
;
long
prevDuration
=
33333
;
GeckoHLSSample
sample
=
null
;
for
(
sample
=
mDemuxedNoDurationSamples
.
poll
(
)
;
sample
!
=
null
;
sample
=
mDemuxedNoDurationSamples
.
poll
(
)
)
{
if
(
sample
.
duration
=
=
Long
.
MAX_VALUE
)
{
sample
.
duration
=
prevDuration
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Adjust
the
PTS
of
the
last
sample
to
"
+
sample
.
duration
+
"
(
us
)
"
)
;
}
}
prevDuration
=
sample
.
duration
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
last
loop
to
offer
samples
-
PTS
:
"
+
sample
.
info
.
presentationTimeUs
+
"
Duration
:
"
+
sample
.
duration
+
"
isEOS
:
"
+
sample
.
isEOS
(
)
)
;
}
mDemuxedInputSamples
.
offer
(
sample
)
;
}
}
}
public
long
getNextKeyFrameTime
(
)
{
long
nextKeyFrameTime
=
Long
.
MAX_VALUE
;
for
(
GeckoHLSSample
sample
:
mDemuxedInputSamples
)
{
if
(
sample
!
=
null
&
&
(
sample
.
info
.
flags
&
MediaCodec
.
BUFFER_FLAG_KEY_FRAME
)
!
=
0
)
{
nextKeyFrameTime
=
sample
.
info
.
presentationTimeUs
;
break
;
}
}
return
nextKeyFrameTime
;
}
Override
protected
void
onStreamChanged
(
Format
[
]
formats
)
{
mStreamFormats
=
formats
;
}
private
static
CodecMaxValues
getCodecMaxValues
(
Format
format
Format
[
]
streamFormats
)
{
int
maxWidth
=
format
.
width
;
int
maxHeight
=
format
.
height
;
int
maxInputSize
=
getMaxInputSize
(
format
)
;
for
(
Format
streamFormat
:
streamFormats
)
{
if
(
areAdaptationCompatible
(
format
streamFormat
)
)
{
maxWidth
=
Math
.
max
(
maxWidth
streamFormat
.
width
)
;
maxHeight
=
Math
.
max
(
maxHeight
streamFormat
.
height
)
;
maxInputSize
=
Math
.
max
(
maxInputSize
getMaxInputSize
(
streamFormat
)
)
;
}
}
return
new
CodecMaxValues
(
maxWidth
maxHeight
maxInputSize
)
;
}
private
static
int
getMaxInputSize
(
Format
format
)
{
if
(
format
.
maxInputSize
!
=
Format
.
NO_VALUE
)
{
return
format
.
maxInputSize
;
}
if
(
format
.
width
=
=
Format
.
NO_VALUE
|
|
format
.
height
=
=
Format
.
NO_VALUE
)
{
return
Format
.
NO_VALUE
;
}
int
maxPixels
;
int
minCompressionRatio
;
switch
(
format
.
sampleMimeType
)
{
case
MimeTypes
.
VIDEO_H264
:
maxPixels
=
(
(
format
.
width
+
15
)
/
16
)
*
(
(
format
.
height
+
15
)
/
16
)
*
16
*
16
;
minCompressionRatio
=
2
;
break
;
default
:
return
Format
.
NO_VALUE
;
}
return
(
maxPixels
*
3
)
/
(
2
*
minCompressionRatio
)
;
}
private
static
boolean
areAdaptationCompatible
(
Format
first
Format
second
)
{
return
first
.
sampleMimeType
.
equals
(
second
.
sampleMimeType
)
&
&
getRotationDegrees
(
first
)
=
=
getRotationDegrees
(
second
)
;
}
private
static
int
getRotationDegrees
(
Format
format
)
{
return
format
.
rotationDegrees
=
=
Format
.
NO_VALUE
?
0
:
format
.
rotationDegrees
;
}
private
static
final
class
CodecMaxValues
{
public
final
int
width
;
public
final
int
height
;
public
final
int
inputSize
;
public
CodecMaxValues
(
int
width
int
height
int
inputSize
)
{
this
.
width
=
width
;
this
.
height
=
height
;
this
.
inputSize
=
inputSize
;
}
}
}
