package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
graphics
.
Rect
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
util
.
Log
;
import
android
.
util
.
Pair
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
InputDevice
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
ArrayList
;
UiThread
public
class
PanZoomController
extends
JNIObject
{
private
static
final
String
LOGTAG
=
"
GeckoNPZC
"
;
private
static
final
int
EVENT_SOURCE_SCROLL
=
0
;
private
static
final
int
EVENT_SOURCE_MOTION
=
1
;
private
static
final
int
EVENT_SOURCE_MOUSE
=
2
;
private
final
GeckoSession
mSession
;
private
final
Rect
mTempRect
=
new
Rect
(
)
;
private
boolean
mAttached
;
private
float
mPointerScrollFactor
=
64
.
0f
;
private
long
mLastDownTime
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
SCROLL_BEHAVIOR_SMOOTH
SCROLL_BEHAVIOR_AUTO
}
)
interface
ScrollBehaviorType
{
}
public
static
final
int
SCROLL_BEHAVIOR_SMOOTH
=
0
;
public
static
final
int
SCROLL_BEHAVIOR_AUTO
=
1
;
private
SynthesizedEventState
mPointerState
;
private
ArrayList
<
Pair
<
Integer
MotionEvent
>
>
mQueuedEvents
;
private
boolean
mSynthesizedEvent
=
false
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
native
boolean
handleMotionEvent
(
int
action
int
actionIndex
long
time
int
metaState
float
screenX
float
screenY
int
pointerId
[
]
float
x
[
]
float
y
[
]
float
orientation
[
]
float
pressure
[
]
float
toolMajor
[
]
float
toolMinor
[
]
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
native
boolean
handleScrollEvent
(
long
time
int
metaState
float
x
float
y
float
hScroll
float
vScroll
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
native
boolean
handleMouseEvent
(
int
action
long
time
int
metaState
float
x
float
y
int
buttons
)
;
private
boolean
handleMotionEvent
(
final
MotionEvent
event
)
{
if
(
!
mAttached
)
{
mQueuedEvents
.
add
(
new
Pair
<
>
(
EVENT_SOURCE_MOTION
event
)
)
;
return
false
;
}
final
int
action
=
event
.
getActionMasked
(
)
;
final
int
count
=
event
.
getPointerCount
(
)
;
if
(
action
=
=
MotionEvent
.
ACTION_DOWN
)
{
mLastDownTime
=
event
.
getDownTime
(
)
;
}
else
if
(
mLastDownTime
!
=
event
.
getDownTime
(
)
)
{
return
false
;
}
final
int
[
]
pointerId
=
new
int
[
count
]
;
final
float
[
]
x
=
new
float
[
count
]
;
final
float
[
]
y
=
new
float
[
count
]
;
final
float
[
]
orientation
=
new
float
[
count
]
;
final
float
[
]
pressure
=
new
float
[
count
]
;
final
float
[
]
toolMajor
=
new
float
[
count
]
;
final
float
[
]
toolMinor
=
new
float
[
count
]
;
final
MotionEvent
.
PointerCoords
coords
=
new
MotionEvent
.
PointerCoords
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
pointerId
[
i
]
=
event
.
getPointerId
(
i
)
;
event
.
getPointerCoords
(
i
coords
)
;
x
[
i
]
=
coords
.
x
;
y
[
i
]
=
coords
.
y
;
orientation
[
i
]
=
coords
.
orientation
;
pressure
[
i
]
=
coords
.
pressure
;
toolMajor
[
i
]
=
coords
.
toolMajor
;
toolMinor
[
i
]
=
coords
.
toolMinor
;
}
final
float
screenX
=
event
.
getRawX
(
)
-
event
.
getX
(
)
;
final
float
screenY
=
event
.
getRawY
(
)
-
event
.
getY
(
)
;
if
(
!
mSynthesizedEvent
)
{
mSession
.
onScreenOriginChanged
(
(
int
)
screenX
(
int
)
screenY
)
;
}
return
handleMotionEvent
(
action
event
.
getActionIndex
(
)
event
.
getEventTime
(
)
event
.
getMetaState
(
)
screenX
screenY
pointerId
x
y
orientation
pressure
toolMajor
toolMinor
)
;
}
private
boolean
handleScrollEvent
(
final
MotionEvent
event
)
{
if
(
!
mAttached
)
{
mQueuedEvents
.
add
(
new
Pair
<
>
(
EVENT_SOURCE_SCROLL
event
)
)
;
return
false
;
}
final
int
count
=
event
.
getPointerCount
(
)
;
if
(
count
<
=
0
)
{
return
false
;
}
final
MotionEvent
.
PointerCoords
coords
=
new
MotionEvent
.
PointerCoords
(
)
;
event
.
getPointerCoords
(
0
coords
)
;
mSession
.
getSurfaceBounds
(
mTempRect
)
;
final
float
x
=
coords
.
x
-
mTempRect
.
left
;
final
float
y
=
coords
.
y
-
mTempRect
.
top
;
final
float
hScroll
=
event
.
getAxisValue
(
MotionEvent
.
AXIS_HSCROLL
)
*
mPointerScrollFactor
;
final
float
vScroll
=
event
.
getAxisValue
(
MotionEvent
.
AXIS_VSCROLL
)
*
mPointerScrollFactor
;
return
handleScrollEvent
(
event
.
getEventTime
(
)
event
.
getMetaState
(
)
x
y
hScroll
vScroll
)
;
}
private
boolean
handleMouseEvent
(
final
MotionEvent
event
)
{
if
(
!
mAttached
)
{
mQueuedEvents
.
add
(
new
Pair
<
>
(
EVENT_SOURCE_MOUSE
event
)
)
;
return
false
;
}
final
int
count
=
event
.
getPointerCount
(
)
;
if
(
count
<
=
0
)
{
return
false
;
}
final
MotionEvent
.
PointerCoords
coords
=
new
MotionEvent
.
PointerCoords
(
)
;
event
.
getPointerCoords
(
0
coords
)
;
mSession
.
getSurfaceBounds
(
mTempRect
)
;
final
float
x
=
coords
.
x
-
mTempRect
.
left
;
final
float
y
=
coords
.
y
-
mTempRect
.
top
;
return
handleMouseEvent
(
event
.
getActionMasked
(
)
event
.
getEventTime
(
)
event
.
getMetaState
(
)
x
y
event
.
getButtonState
(
)
)
;
}
protected
PanZoomController
(
final
GeckoSession
session
)
{
mSession
=
session
;
enableEventQueue
(
)
;
}
public
void
setScrollFactor
(
final
float
factor
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mPointerScrollFactor
=
factor
;
}
public
float
getScrollFactor
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mPointerScrollFactor
;
}
public
boolean
onTouchEvent
(
final
NonNull
MotionEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
handleMotionEvent
(
event
)
;
}
public
boolean
onMouseEvent
(
final
NonNull
MotionEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
event
.
getToolType
(
0
)
=
=
MotionEvent
.
TOOL_TYPE_MOUSE
)
{
return
handleMouseEvent
(
event
)
;
}
return
handleMotionEvent
(
event
)
;
}
Override
protected
void
finalize
(
)
throws
Throwable
{
setAttached
(
false
)
;
}
public
boolean
onMotionEvent
(
final
NonNull
MotionEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
int
action
=
event
.
getActionMasked
(
)
;
if
(
action
=
=
MotionEvent
.
ACTION_SCROLL
)
{
if
(
event
.
getDownTime
(
)
>
=
mLastDownTime
)
{
mLastDownTime
=
event
.
getDownTime
(
)
;
}
else
if
(
(
InputDevice
.
getDevice
(
event
.
getDeviceId
(
)
)
.
getSources
(
)
&
InputDevice
.
SOURCE_TOUCHPAD
)
=
=
InputDevice
.
SOURCE_TOUCHPAD
)
{
return
false
;
}
return
handleScrollEvent
(
event
)
;
}
else
if
(
(
action
=
=
MotionEvent
.
ACTION_HOVER_MOVE
)
|
|
(
action
=
=
MotionEvent
.
ACTION_HOVER_ENTER
)
|
|
(
action
=
=
MotionEvent
.
ACTION_HOVER_EXIT
)
)
{
return
handleMouseEvent
(
event
)
;
}
else
{
return
false
;
}
}
private
void
enableEventQueue
(
)
{
if
(
mQueuedEvents
!
=
null
)
{
throw
new
IllegalStateException
(
"
Already
have
an
event
queue
"
)
;
}
mQueuedEvents
=
new
ArrayList
<
>
(
)
;
}
private
void
flushEventQueue
(
)
{
if
(
mQueuedEvents
=
=
null
)
{
return
;
}
ArrayList
<
Pair
<
Integer
MotionEvent
>
>
events
=
mQueuedEvents
;
mQueuedEvents
=
null
;
for
(
Pair
<
Integer
MotionEvent
>
pair
:
events
)
{
switch
(
pair
.
first
)
{
case
EVENT_SOURCE_MOTION
:
handleMotionEvent
(
pair
.
second
)
;
break
;
case
EVENT_SOURCE_SCROLL
:
handleScrollEvent
(
pair
.
second
)
;
break
;
case
EVENT_SOURCE_MOUSE
:
handleMouseEvent
(
pair
.
second
)
;
break
;
}
}
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
setAttached
(
final
boolean
attached
)
{
if
(
attached
)
{
mAttached
=
true
;
flushEventQueue
(
)
;
}
else
if
(
mAttached
)
{
mAttached
=
false
;
enableEventQueue
(
)
;
}
}
Override
protected
void
disposeNative
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
WrapForJNI
(
stubName
=
"
SetIsLongpressEnabled
"
)
private
native
void
nativeSetIsLongpressEnabled
(
boolean
isLongpressEnabled
)
;
public
void
setIsLongpressEnabled
(
final
boolean
isLongpressEnabled
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mAttached
)
{
nativeSetIsLongpressEnabled
(
isLongpressEnabled
)
;
}
}
private
static
class
PointerInfo
{
public
static
final
int
RESERVED_MOUSE_POINTER_ID
=
100000
;
public
int
pointerId
;
public
int
source
;
public
int
surfaceX
;
public
int
surfaceY
;
public
double
pressure
;
public
int
orientation
;
public
MotionEvent
.
PointerCoords
getCoords
(
)
{
MotionEvent
.
PointerCoords
coords
=
new
MotionEvent
.
PointerCoords
(
)
;
coords
.
orientation
=
orientation
;
coords
.
pressure
=
(
float
)
pressure
;
coords
.
x
=
surfaceX
;
coords
.
y
=
surfaceY
;
return
coords
;
}
}
private
static
class
SynthesizedEventState
{
public
final
ArrayList
<
PointerInfo
>
pointers
;
public
long
downTime
;
SynthesizedEventState
(
)
{
pointers
=
new
ArrayList
<
PointerInfo
>
(
)
;
}
int
getPointerIndex
(
final
int
pointerId
)
{
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
pointerId
=
=
pointerId
)
{
return
i
;
}
}
return
-
1
;
}
int
addPointer
(
final
int
pointerId
final
int
source
)
{
PointerInfo
info
=
new
PointerInfo
(
)
;
info
.
pointerId
=
pointerId
;
info
.
source
=
source
;
pointers
.
add
(
info
)
;
return
pointers
.
size
(
)
-
1
;
}
int
getPointerCount
(
final
int
source
)
{
int
count
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
count
+
+
;
}
}
return
count
;
}
MotionEvent
.
PointerProperties
[
]
getPointerProperties
(
final
int
source
)
{
MotionEvent
.
PointerProperties
[
]
props
=
new
MotionEvent
.
PointerProperties
[
getPointerCount
(
source
)
]
;
int
index
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
MotionEvent
.
PointerProperties
p
=
new
MotionEvent
.
PointerProperties
(
)
;
p
.
id
=
pointers
.
get
(
i
)
.
pointerId
;
switch
(
source
)
{
case
InputDevice
.
SOURCE_TOUCHSCREEN
:
p
.
toolType
=
MotionEvent
.
TOOL_TYPE_FINGER
;
break
;
case
InputDevice
.
SOURCE_MOUSE
:
p
.
toolType
=
MotionEvent
.
TOOL_TYPE_MOUSE
;
break
;
}
props
[
index
+
+
]
=
p
;
}
}
return
props
;
}
MotionEvent
.
PointerCoords
[
]
getPointerCoords
(
final
int
source
)
{
MotionEvent
.
PointerCoords
[
]
coords
=
new
MotionEvent
.
PointerCoords
[
getPointerCount
(
source
)
]
;
int
index
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
coords
[
index
+
+
]
=
pointers
.
get
(
i
)
.
getCoords
(
)
;
}
}
return
coords
;
}
}
private
void
synthesizeNativePointer
(
final
int
source
final
int
pointerId
final
int
originalEventType
final
int
clientX
final
int
clientY
final
double
pressure
final
int
orientation
)
{
if
(
mPointerState
=
=
null
)
{
mPointerState
=
new
SynthesizedEventState
(
)
;
}
int
pointerIndex
=
mPointerState
.
getPointerIndex
(
pointerId
)
;
int
eventType
=
originalEventType
;
switch
(
originalEventType
)
{
case
MotionEvent
.
ACTION_POINTER_UP
:
if
(
pointerIndex
<
0
)
{
Log
.
w
(
LOGTAG
"
Pointer
-
up
for
invalid
pointer
"
)
;
return
;
}
if
(
mPointerState
.
pointers
.
size
(
)
=
=
1
)
{
eventType
=
MotionEvent
.
ACTION_UP
;
}
break
;
case
MotionEvent
.
ACTION_CANCEL
:
if
(
pointerIndex
<
0
)
{
Log
.
w
(
LOGTAG
"
Pointer
-
cancel
for
invalid
pointer
"
)
;
return
;
}
break
;
case
MotionEvent
.
ACTION_POINTER_DOWN
:
if
(
pointerIndex
<
0
)
{
pointerIndex
=
mPointerState
.
addPointer
(
pointerId
source
)
;
if
(
pointerIndex
=
=
0
)
{
eventType
=
MotionEvent
.
ACTION_DOWN
;
mPointerState
.
downTime
=
SystemClock
.
uptimeMillis
(
)
;
}
}
else
{
eventType
=
MotionEvent
.
ACTION_MOVE
;
}
break
;
case
MotionEvent
.
ACTION_HOVER_MOVE
:
if
(
pointerIndex
<
0
)
{
pointerIndex
=
mPointerState
.
addPointer
(
pointerId
source
)
;
}
else
{
eventType
=
MotionEvent
.
ACTION_MOVE
;
}
break
;
}
mSession
.
getSurfaceBounds
(
mTempRect
)
;
final
int
surfaceX
=
clientX
+
mTempRect
.
left
;
final
int
surfaceY
=
clientY
+
mTempRect
.
top
;
PointerInfo
info
=
mPointerState
.
pointers
.
get
(
pointerIndex
)
;
info
.
surfaceX
=
surfaceX
;
info
.
surfaceY
=
surfaceY
;
info
.
pressure
=
pressure
;
info
.
orientation
=
orientation
;
int
action
=
0
;
if
(
eventType
=
=
MotionEvent
.
ACTION_POINTER_DOWN
|
|
eventType
=
=
MotionEvent
.
ACTION_POINTER_UP
)
{
action
=
(
pointerIndex
<
<
MotionEvent
.
ACTION_POINTER_INDEX_SHIFT
)
;
action
&
=
MotionEvent
.
ACTION_POINTER_INDEX_MASK
;
}
action
|
=
(
eventType
&
MotionEvent
.
ACTION_MASK
)
;
boolean
isButtonDown
=
(
source
=
=
InputDevice
.
SOURCE_MOUSE
)
&
&
(
eventType
=
=
MotionEvent
.
ACTION_DOWN
|
|
eventType
=
=
MotionEvent
.
ACTION_MOVE
)
;
final
MotionEvent
event
=
MotionEvent
.
obtain
(
mPointerState
.
downTime
SystemClock
.
uptimeMillis
(
)
action
mPointerState
.
getPointerCount
(
source
)
mPointerState
.
getPointerProperties
(
source
)
mPointerState
.
getPointerCoords
(
source
)
0
(
isButtonDown
?
MotionEvent
.
BUTTON_PRIMARY
:
0
)
0
0
0
0
source
0
)
;
mSynthesizedEvent
=
true
;
onTouchEvent
(
event
)
;
mSynthesizedEvent
=
false
;
if
(
eventType
=
=
MotionEvent
.
ACTION_POINTER_UP
|
|
eventType
=
=
MotionEvent
.
ACTION_UP
|
|
eventType
=
=
MotionEvent
.
ACTION_CANCEL
|
|
eventType
=
=
MotionEvent
.
ACTION_HOVER_MOVE
)
{
mPointerState
.
pointers
.
remove
(
pointerIndex
)
;
}
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
synthesizeNativeTouchPoint
(
final
int
pointerId
final
int
eventType
final
int
clientX
final
int
clientY
final
double
pressure
final
int
orientation
)
{
if
(
pointerId
=
=
PointerInfo
.
RESERVED_MOUSE_POINTER_ID
)
{
throw
new
IllegalArgumentException
(
"
Pointer
ID
reserved
for
mouse
"
)
;
}
synthesizeNativePointer
(
InputDevice
.
SOURCE_TOUCHSCREEN
pointerId
eventType
clientX
clientY
pressure
orientation
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
synthesizeNativeMouseEvent
(
final
int
eventType
final
int
clientX
final
int
clientY
)
{
synthesizeNativePointer
(
InputDevice
.
SOURCE_MOUSE
PointerInfo
.
RESERVED_MOUSE_POINTER_ID
eventType
clientX
clientY
0
0
)
;
}
UiThread
public
void
scrollBy
(
final
NonNull
ScreenLength
width
final
NonNull
ScreenLength
height
)
{
scrollBy
(
width
height
SCROLL_BEHAVIOR_SMOOTH
)
;
}
UiThread
public
void
scrollBy
(
final
NonNull
ScreenLength
width
final
NonNull
ScreenLength
height
final
ScrollBehaviorType
int
behavior
)
{
final
GeckoBundle
msg
=
buildScrollMessage
(
width
height
behavior
)
;
mSession
.
getEventDispatcher
(
)
.
dispatch
(
"
GeckoView
:
ScrollBy
"
msg
)
;
}
UiThread
public
void
scrollTo
(
final
NonNull
ScreenLength
width
final
NonNull
ScreenLength
height
)
{
scrollTo
(
width
height
SCROLL_BEHAVIOR_SMOOTH
)
;
}
UiThread
public
void
scrollTo
(
final
NonNull
ScreenLength
width
final
NonNull
ScreenLength
height
final
ScrollBehaviorType
int
behavior
)
{
final
GeckoBundle
msg
=
buildScrollMessage
(
width
height
behavior
)
;
mSession
.
getEventDispatcher
(
)
.
dispatch
(
"
GeckoView
:
ScrollTo
"
msg
)
;
}
UiThread
public
void
scrollToTop
(
)
{
scrollTo
(
ScreenLength
.
zero
(
)
ScreenLength
.
top
(
)
SCROLL_BEHAVIOR_SMOOTH
)
;
}
UiThread
public
void
scrollToBottom
(
)
{
scrollTo
(
ScreenLength
.
zero
(
)
ScreenLength
.
bottom
(
)
SCROLL_BEHAVIOR_SMOOTH
)
;
}
private
GeckoBundle
buildScrollMessage
(
final
NonNull
ScreenLength
width
final
NonNull
ScreenLength
height
final
ScrollBehaviorType
int
behavior
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
)
;
msg
.
putDouble
(
"
widthValue
"
width
.
getValue
(
)
)
;
msg
.
putInt
(
"
widthType
"
width
.
getType
(
)
)
;
msg
.
putDouble
(
"
heightValue
"
height
.
getValue
(
)
)
;
msg
.
putInt
(
"
heightType
"
height
.
getType
(
)
)
;
msg
.
putInt
(
"
behavior
"
behavior
)
;
return
msg
;
}
}
