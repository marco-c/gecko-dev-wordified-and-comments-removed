package
org
.
mozilla
.
gecko
.
util
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
public
final
class
INIParser
extends
INISection
{
private
final
File
mFile
;
private
Hashtable
<
String
INISection
>
mSections
;
public
INIParser
(
final
File
iniFile
)
{
super
(
"
"
)
;
mFile
=
iniFile
;
}
public
void
write
(
)
{
writeTo
(
mFile
)
;
}
public
void
writeTo
(
final
File
f
)
{
if
(
f
=
=
null
)
return
;
FileWriter
outputStream
=
null
;
try
{
outputStream
=
new
FileWriter
(
f
)
;
}
catch
(
final
IOException
e1
)
{
e1
.
printStackTrace
(
)
;
}
final
BufferedWriter
writer
=
new
BufferedWriter
(
outputStream
)
;
try
{
write
(
writer
)
;
}
catch
(
final
IOException
e
)
{
e
.
printStackTrace
(
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
writer
)
;
}
}
Override
public
void
write
(
final
BufferedWriter
writer
)
throws
IOException
{
super
.
write
(
writer
)
;
if
(
mSections
!
=
null
)
{
for
(
final
Enumeration
<
INISection
>
e
=
mSections
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
final
INISection
section
=
e
.
nextElement
(
)
;
section
.
write
(
writer
)
;
writer
.
newLine
(
)
;
}
}
}
public
Hashtable
<
String
INISection
>
getSections
(
)
{
if
(
mSections
=
=
null
)
{
try
{
parse
(
)
;
}
catch
(
final
IOException
e
)
{
debug
(
"
Error
parsing
:
"
+
e
)
;
}
}
return
mSections
;
}
Override
protected
void
parse
(
)
throws
IOException
{
super
.
parse
(
)
;
parse
(
mFile
)
;
}
private
void
parse
(
final
File
f
)
throws
IOException
{
mSections
=
new
Hashtable
<
String
INISection
>
(
)
;
if
(
f
=
=
null
|
|
!
f
.
exists
(
)
)
return
;
FileReader
inputStream
=
null
;
try
{
inputStream
=
new
FileReader
(
f
)
;
}
catch
(
final
FileNotFoundException
e1
)
{
return
;
}
final
BufferedReader
buf
=
new
BufferedReader
(
inputStream
)
;
String
line
=
null
;
INISection
currentSection
=
null
;
while
(
(
line
=
buf
.
readLine
(
)
)
!
=
null
)
{
if
(
line
!
=
null
)
line
=
line
.
trim
(
)
;
if
(
line
=
=
null
|
|
line
.
length
(
)
=
=
0
|
|
line
.
charAt
(
0
)
=
=
'
;
'
)
{
debug
(
"
Ignore
line
:
"
+
line
)
;
}
else
if
(
line
.
charAt
(
0
)
=
=
'
[
'
)
{
debug
(
"
Parse
as
section
:
"
+
line
)
;
currentSection
=
new
INISection
(
line
.
substring
(
1
line
.
length
(
)
-
1
)
)
;
mSections
.
put
(
currentSection
.
getName
(
)
currentSection
)
;
}
else
{
debug
(
"
Parse
as
property
:
"
+
line
)
;
final
String
[
]
pieces
=
line
.
split
(
"
=
"
)
;
if
(
pieces
.
length
!
=
2
)
continue
;
final
String
key
=
pieces
[
0
]
.
trim
(
)
;
final
String
value
=
pieces
[
1
]
.
trim
(
)
;
if
(
currentSection
!
=
null
)
{
currentSection
.
setProperty
(
key
value
)
;
}
else
{
mProperties
.
put
(
key
value
)
;
}
}
}
buf
.
close
(
)
;
}
public
void
addSection
(
final
INISection
sect
)
{
getSections
(
)
;
mSections
.
put
(
sect
.
getName
(
)
sect
)
;
}
public
INISection
getSection
(
final
String
key
)
{
getSections
(
)
;
return
mSections
.
get
(
key
)
;
}
public
void
removeSection
(
final
String
name
)
{
getSections
(
)
;
mSections
.
remove
(
name
)
;
}
public
void
renameSection
(
final
String
oldName
final
String
newName
)
{
getSections
(
)
;
mSections
.
remove
(
newName
)
;
final
INISection
section
=
mSections
.
get
(
oldName
)
;
if
(
section
=
=
null
)
return
;
section
.
setName
(
newName
)
;
mSections
.
remove
(
oldName
)
;
mSections
.
put
(
newName
section
)
;
}
}
