package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
annotation
.
ReflectionTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
geckoview
.
BuildConfig
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Handler
;
import
android
.
util
.
Log
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
CopyOnWriteArrayList
;
RobocopTarget
public
final
class
EventDispatcher
extends
JNIObject
{
private
static
final
String
LOGTAG
=
"
GeckoEventDispatcher
"
;
private
static
final
EventDispatcher
INSTANCE
=
new
EventDispatcher
(
)
;
private
static
final
int
DEFAULT_GECKO_EVENTS_COUNT
=
64
;
private
static
final
int
DEFAULT_UI_EVENTS_COUNT
=
128
;
private
static
final
int
DEFAULT_BACKGROUND_EVENTS_COUNT
=
64
;
private
final
Map
<
String
List
<
BundleEventListener
>
>
mGeckoThreadListeners
=
new
HashMap
<
String
List
<
BundleEventListener
>
>
(
DEFAULT_GECKO_EVENTS_COUNT
)
;
private
final
Map
<
String
List
<
BundleEventListener
>
>
mUiThreadListeners
=
new
HashMap
<
String
List
<
BundleEventListener
>
>
(
DEFAULT_UI_EVENTS_COUNT
)
;
private
final
Map
<
String
List
<
BundleEventListener
>
>
mBackgroundThreadListeners
=
new
HashMap
<
String
List
<
BundleEventListener
>
>
(
DEFAULT_BACKGROUND_EVENTS_COUNT
)
;
private
boolean
mAttachedToGecko
;
private
final
NativeQueue
mNativeQueue
;
ReflectionTarget
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
static
EventDispatcher
getInstance
(
)
{
return
INSTANCE
;
}
EventDispatcher
(
)
{
mNativeQueue
=
GeckoThread
.
getNativeQueue
(
)
;
}
public
EventDispatcher
(
final
NativeQueue
queue
)
{
mNativeQueue
=
queue
;
}
public
NativeQueue
getNativeQueue
(
)
{
return
mNativeQueue
;
}
private
boolean
isReadyForDispatchingToGecko
(
)
{
return
mNativeQueue
.
isReady
(
)
;
}
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
private
static
final
int
DETACHED
=
0
;
WrapForJNI
private
static
final
int
ATTACHED
=
1
;
WrapForJNI
private
static
final
int
REATTACHING
=
2
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
synchronized
void
setAttachedToGecko
(
final
int
state
)
{
if
(
mAttachedToGecko
&
&
state
=
=
DETACHED
)
{
if
(
GeckoThread
.
isRunning
(
)
)
{
disposeNative
(
)
;
}
else
{
GeckoThread
.
queueNativeCall
(
this
"
disposeNative
"
)
;
}
}
mAttachedToGecko
=
(
state
=
=
ATTACHED
)
;
}
private
<
T
>
void
registerListener
(
final
Class
<
?
>
listType
final
Map
<
String
List
<
T
>
>
listenersMap
final
T
listener
final
String
[
]
events
)
{
try
{
synchronized
(
listenersMap
)
{
for
(
final
String
event
:
events
)
{
if
(
event
=
=
null
)
{
continue
;
}
List
<
T
>
listeners
=
listenersMap
.
get
(
event
)
;
if
(
listeners
=
=
null
)
{
SuppressWarnings
(
"
unchecked
"
)
final
Class
<
?
extends
List
<
T
>
>
type
=
(
Class
)
listType
;
listeners
=
type
.
newInstance
(
)
;
listenersMap
.
put
(
event
listeners
)
;
}
if
(
!
BuildConfig
.
RELEASE_OR_BETA
&
&
listeners
.
contains
(
listener
)
)
{
throw
new
IllegalStateException
(
"
Already
registered
"
+
event
)
;
}
listeners
.
add
(
listener
)
;
}
}
}
catch
(
final
Exception
e
)
{
throw
new
IllegalArgumentException
(
"
Invalid
new
list
type
"
e
)
;
}
}
private
void
checkNotRegisteredElsewhere
(
final
Map
<
String
?
>
allowedMap
final
String
[
]
events
)
{
if
(
BuildConfig
.
RELEASE_OR_BETA
)
{
return
;
}
for
(
final
Map
<
String
?
>
listenersMap
:
Arrays
.
asList
(
mGeckoThreadListeners
mUiThreadListeners
mBackgroundThreadListeners
)
)
{
if
(
listenersMap
=
=
allowedMap
)
{
continue
;
}
synchronized
(
listenersMap
)
{
for
(
final
String
event
:
events
)
{
if
(
listenersMap
.
get
(
event
)
!
=
null
)
{
throw
new
IllegalStateException
(
"
Already
registered
"
+
event
+
"
under
a
different
type
"
)
;
}
}
}
}
}
private
<
T
>
void
unregisterListener
(
final
Map
<
String
List
<
T
>
>
listenersMap
final
T
listener
final
String
[
]
events
)
{
synchronized
(
listenersMap
)
{
for
(
final
String
event
:
events
)
{
if
(
event
=
=
null
)
{
continue
;
}
List
<
T
>
listeners
=
listenersMap
.
get
(
event
)
;
if
(
(
listeners
=
=
null
|
|
!
listeners
.
remove
(
listener
)
)
&
&
!
BuildConfig
.
RELEASE_OR_BETA
)
{
throw
new
IllegalArgumentException
(
event
+
"
was
not
registered
"
)
;
}
}
}
}
public
void
registerGeckoThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
checkNotRegisteredElsewhere
(
mGeckoThreadListeners
events
)
;
registerListener
(
CopyOnWriteArrayList
.
class
mGeckoThreadListeners
listener
events
)
;
}
public
void
registerUiThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
checkNotRegisteredElsewhere
(
mUiThreadListeners
events
)
;
registerListener
(
ArrayList
.
class
mUiThreadListeners
listener
events
)
;
}
ReflectionTarget
public
void
registerBackgroundThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
checkNotRegisteredElsewhere
(
mBackgroundThreadListeners
events
)
;
registerListener
(
ArrayList
.
class
mBackgroundThreadListeners
listener
events
)
;
}
public
void
unregisterGeckoThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
unregisterListener
(
mGeckoThreadListeners
listener
events
)
;
}
public
void
unregisterUiThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
unregisterListener
(
mUiThreadListeners
listener
events
)
;
}
public
void
unregisterBackgroundThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
unregisterListener
(
mBackgroundThreadListeners
listener
events
)
;
}
WrapForJNI
private
native
boolean
hasGeckoListener
(
final
String
event
)
;
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
private
native
void
dispatchToGecko
(
final
String
event
final
GeckoBundle
data
final
EventCallback
callback
)
;
public
void
dispatch
(
final
String
type
final
GeckoBundle
message
)
{
dispatch
(
type
message
null
)
;
}
public
void
dispatch
(
final
String
type
final
GeckoBundle
message
final
EventCallback
callback
)
{
synchronized
(
this
)
{
if
(
isReadyForDispatchingToGecko
(
)
&
&
mAttachedToGecko
&
&
hasGeckoListener
(
type
)
)
{
dispatchToGecko
(
type
message
JavaCallbackDelegate
.
wrap
(
callback
)
)
;
return
;
}
}
if
(
!
dispatchToThreads
(
type
message
callback
)
)
{
Log
.
w
(
LOGTAG
"
No
listener
for
"
+
type
)
;
}
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
boolean
dispatchToThreads
(
final
String
type
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
List
<
BundleEventListener
>
geckoListeners
;
synchronized
(
mGeckoThreadListeners
)
{
geckoListeners
=
mGeckoThreadListeners
.
get
(
type
)
;
}
if
(
geckoListeners
!
=
null
&
&
!
geckoListeners
.
isEmpty
(
)
)
{
final
boolean
onGeckoThread
=
ThreadUtils
.
isOnGeckoThread
(
)
;
final
EventCallback
wrappedCallback
=
JavaCallbackDelegate
.
wrap
(
callback
)
;
for
(
final
BundleEventListener
listener
:
geckoListeners
)
{
if
(
onGeckoThread
)
{
listener
.
handleMessage
(
type
message
wrappedCallback
)
;
continue
;
}
ThreadUtils
.
sGeckoHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
.
handleMessage
(
type
message
wrappedCallback
)
;
}
}
)
;
}
return
true
;
}
if
(
dispatchToThread
(
type
message
callback
mUiThreadListeners
ThreadUtils
.
getUiHandler
(
)
)
)
{
return
true
;
}
if
(
dispatchToThread
(
type
message
callback
mBackgroundThreadListeners
ThreadUtils
.
getBackgroundHandler
(
)
)
)
{
return
true
;
}
if
(
!
isReadyForDispatchingToGecko
(
)
)
{
mNativeQueue
.
queueUntilReady
(
this
"
dispatchToGecko
"
String
.
class
type
GeckoBundle
.
class
message
EventCallback
.
class
JavaCallbackDelegate
.
wrap
(
callback
)
)
;
return
true
;
}
return
false
;
}
private
boolean
dispatchToThread
(
final
String
type
final
GeckoBundle
message
final
EventCallback
callback
final
Map
<
String
List
<
BundleEventListener
>
>
listenersMap
final
Handler
thread
)
{
synchronized
(
listenersMap
)
{
final
List
<
BundleEventListener
>
listeners
=
listenersMap
.
get
(
type
)
;
if
(
listeners
=
=
null
)
{
return
false
;
}
if
(
listeners
.
isEmpty
(
)
)
{
return
false
;
}
final
EventCallback
wrappedCallback
=
JavaCallbackDelegate
.
wrap
(
callback
)
;
for
(
final
BundleEventListener
listener
:
listeners
)
{
thread
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
.
handleMessage
(
type
message
wrappedCallback
)
;
}
}
)
;
}
return
true
;
}
}
private
static
class
NativeCallbackDelegate
extends
JNIObject
implements
EventCallback
{
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
NativeCallbackDelegate
(
)
{
}
Override
protected
void
disposeNative
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
Override
public
native
void
sendSuccess
(
Object
response
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
Override
public
native
void
sendError
(
Object
response
)
;
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
Override
protected
native
void
finalize
(
)
;
}
private
static
class
JavaCallbackDelegate
implements
EventCallback
{
private
final
Thread
originalThread
=
Thread
.
currentThread
(
)
;
private
final
EventCallback
callback
;
public
static
EventCallback
wrap
(
final
EventCallback
callback
)
{
if
(
callback
=
=
null
)
{
return
null
;
}
if
(
callback
instanceof
NativeCallbackDelegate
)
{
return
callback
;
}
return
new
JavaCallbackDelegate
(
callback
)
;
}
JavaCallbackDelegate
(
final
EventCallback
callback
)
{
this
.
callback
=
callback
;
}
private
void
makeCallback
(
final
boolean
callSuccess
final
Object
rawResponse
)
{
final
Object
response
;
if
(
rawResponse
instanceof
Number
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
use
number
as
Java
callback
result
"
)
;
}
else
if
(
rawResponse
!
=
null
&
&
rawResponse
.
getClass
(
)
.
isArray
(
)
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
use
arrays
as
Java
callback
result
"
)
;
}
else
if
(
rawResponse
instanceof
Character
)
{
response
=
rawResponse
.
toString
(
)
;
}
else
{
response
=
rawResponse
;
}
if
(
ThreadUtils
.
isOnThread
(
originalThread
)
)
{
if
(
callSuccess
)
{
callback
.
sendSuccess
(
response
)
;
}
else
{
callback
.
sendError
(
response
)
;
}
return
;
}
final
Handler
handler
=
originalThread
=
=
ThreadUtils
.
getUiThread
(
)
?
ThreadUtils
.
getUiHandler
(
)
:
originalThread
=
=
ThreadUtils
.
sGeckoThread
?
ThreadUtils
.
sGeckoHandler
:
ThreadUtils
.
getBackgroundHandler
(
)
;
final
EventCallback
callback
=
this
.
callback
;
handler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
callSuccess
)
{
callback
.
sendSuccess
(
response
)
;
}
else
{
callback
.
sendError
(
response
)
;
}
}
}
)
;
}
Override
public
void
sendSuccess
(
Object
response
)
{
makeCallback
(
true
response
)
;
}
Override
public
void
sendError
(
Object
response
)
{
makeCallback
(
false
response
)
;
}
}
}
