package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
annotation
.
ReflectionTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
geckoview
.
BuildConfig
;
import
android
.
os
.
Handler
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
util
.
Log
;
RobocopTarget
public
final
class
EventDispatcher
extends
JNIObject
{
private
static
final
String
LOGTAG
=
"
GeckoEventDispatcher
"
;
private
static
final
EventDispatcher
INSTANCE
=
new
EventDispatcher
(
)
;
private
static
final
int
DEFAULT_UI_EVENTS_COUNT
=
128
;
private
final
MultiMap
<
String
BundleEventListener
>
mListeners
=
new
MultiMap
<
>
(
DEFAULT_UI_EVENTS_COUNT
)
;
private
boolean
mAttachedToGecko
;
private
final
NativeQueue
mNativeQueue
;
ReflectionTarget
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
static
EventDispatcher
getInstance
(
)
{
return
INSTANCE
;
}
EventDispatcher
(
)
{
mNativeQueue
=
GeckoThread
.
getNativeQueue
(
)
;
}
public
EventDispatcher
(
final
NativeQueue
queue
)
{
mNativeQueue
=
queue
;
}
private
boolean
isReadyForDispatchingToGecko
(
)
{
return
mNativeQueue
.
isReady
(
)
;
}
WrapForJNI
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
private
static
final
int
DETACHED
=
0
;
WrapForJNI
private
static
final
int
ATTACHED
=
1
;
WrapForJNI
private
static
final
int
REATTACHING
=
2
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
synchronized
void
setAttachedToGecko
(
final
int
state
)
{
if
(
mAttachedToGecko
&
&
state
=
=
DETACHED
)
{
dispose
(
false
)
;
}
mAttachedToGecko
=
(
state
=
=
ATTACHED
)
;
}
private
void
dispose
(
final
boolean
force
)
{
final
Handler
geckoHandler
=
ThreadUtils
.
sGeckoHandler
;
if
(
geckoHandler
=
=
null
)
{
return
;
}
geckoHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
force
|
|
!
mAttachedToGecko
)
{
disposeNative
(
)
;
}
}
}
)
;
}
public
void
registerUiThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
try
{
synchronized
(
mListeners
)
{
for
(
final
String
event
:
events
)
{
if
(
!
BuildConfig
.
RELEASE_OR_BETA
&
&
mListeners
.
containsEntry
(
event
listener
)
)
{
throw
new
IllegalStateException
(
"
Already
registered
"
+
event
)
;
}
mListeners
.
add
(
event
listener
)
;
}
}
}
catch
(
final
Exception
e
)
{
throw
new
IllegalArgumentException
(
"
Invalid
new
list
type
"
e
)
;
}
}
public
void
unregisterUiThreadListener
(
final
BundleEventListener
listener
final
String
.
.
.
events
)
{
synchronized
(
mListeners
)
{
for
(
final
String
event
:
events
)
{
if
(
!
mListeners
.
remove
(
event
listener
)
&
&
!
BuildConfig
.
RELEASE_OR_BETA
)
{
throw
new
IllegalArgumentException
(
event
+
"
was
not
registered
"
)
;
}
}
}
}
WrapForJNI
private
native
boolean
hasGeckoListener
(
final
String
event
)
;
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
private
native
void
dispatchToGecko
(
final
String
event
final
GeckoBundle
data
final
EventCallback
callback
)
;
public
void
dispatch
(
final
String
type
final
GeckoBundle
message
)
{
dispatch
(
type
message
null
)
;
}
AnyThread
public
void
dispatch
(
final
String
type
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
boolean
isGeckoReady
;
synchronized
(
this
)
{
isGeckoReady
=
isReadyForDispatchingToGecko
(
)
;
if
(
isGeckoReady
&
&
mAttachedToGecko
&
&
hasGeckoListener
(
type
)
)
{
dispatchToGecko
(
type
message
JavaCallbackDelegate
.
wrap
(
callback
)
)
;
return
;
}
}
dispatchToThreads
(
type
message
callback
isGeckoReady
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
boolean
dispatchToThreads
(
final
String
type
final
GeckoBundle
message
final
EventCallback
callback
)
{
return
dispatchToThreads
(
type
message
callback
true
)
;
}
private
boolean
dispatchToThreads
(
final
String
type
final
GeckoBundle
message
final
EventCallback
callback
final
boolean
isGeckoReady
)
{
synchronized
(
mListeners
)
{
if
(
mListeners
.
containsKey
(
type
)
)
{
final
EventCallback
wrappedCallback
=
JavaCallbackDelegate
.
wrap
(
callback
)
;
for
(
final
BundleEventListener
listener
:
mListeners
.
get
(
type
)
)
{
ThreadUtils
.
getUiHandler
(
)
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
.
handleMessage
(
type
message
wrappedCallback
)
;
}
}
)
;
}
return
true
;
}
}
if
(
!
isGeckoReady
)
{
mNativeQueue
.
queueUntilReady
(
this
"
dispatchToGecko
"
String
.
class
type
GeckoBundle
.
class
message
EventCallback
.
class
JavaCallbackDelegate
.
wrap
(
callback
)
)
;
return
true
;
}
final
String
error
=
"
No
listener
for
"
+
type
;
if
(
callback
!
=
null
)
{
callback
.
sendError
(
error
)
;
}
Log
.
w
(
LOGTAG
error
)
;
return
false
;
}
WrapForJNI
public
boolean
hasListener
(
final
String
event
)
{
synchronized
(
mListeners
)
{
return
mListeners
.
containsKey
(
event
)
;
}
}
Override
protected
void
finalize
(
)
throws
Throwable
{
dispose
(
true
)
;
}
private
static
class
NativeCallbackDelegate
extends
JNIObject
implements
EventCallback
{
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
NativeCallbackDelegate
(
)
{
}
Override
protected
void
disposeNative
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
Override
public
native
void
sendSuccess
(
Object
response
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
Override
public
native
void
sendError
(
Object
response
)
;
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
Override
protected
native
void
finalize
(
)
;
}
private
static
class
JavaCallbackDelegate
implements
EventCallback
{
private
final
Thread
mOriginalThread
=
Thread
.
currentThread
(
)
;
private
final
EventCallback
mCallback
;
public
static
EventCallback
wrap
(
final
EventCallback
callback
)
{
if
(
callback
=
=
null
)
{
return
null
;
}
if
(
callback
instanceof
NativeCallbackDelegate
)
{
return
callback
;
}
return
new
JavaCallbackDelegate
(
callback
)
;
}
JavaCallbackDelegate
(
final
EventCallback
callback
)
{
mCallback
=
callback
;
}
private
void
makeCallback
(
final
boolean
callSuccess
final
Object
rawResponse
)
{
final
Object
response
;
if
(
rawResponse
instanceof
Number
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
use
number
as
Java
callback
result
"
)
;
}
else
if
(
rawResponse
!
=
null
&
&
rawResponse
.
getClass
(
)
.
isArray
(
)
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
use
arrays
as
Java
callback
result
"
)
;
}
else
if
(
rawResponse
instanceof
Character
)
{
response
=
rawResponse
.
toString
(
)
;
}
else
{
response
=
rawResponse
;
}
if
(
ThreadUtils
.
isOnThread
(
mOriginalThread
)
)
{
if
(
callSuccess
)
{
mCallback
.
sendSuccess
(
response
)
;
}
else
{
mCallback
.
sendError
(
response
)
;
}
return
;
}
final
Handler
handler
=
mOriginalThread
=
=
ThreadUtils
.
getUiThread
(
)
?
ThreadUtils
.
getUiHandler
(
)
:
mOriginalThread
=
=
ThreadUtils
.
sGeckoThread
?
ThreadUtils
.
sGeckoHandler
:
ThreadUtils
.
getBackgroundHandler
(
)
;
final
EventCallback
callback
=
mCallback
;
handler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
callSuccess
)
{
callback
.
sendSuccess
(
response
)
;
}
else
{
callback
.
sendError
(
response
)
;
}
}
}
)
;
}
Override
public
void
sendSuccess
(
final
Object
response
)
{
makeCallback
(
true
response
)
;
}
Override
public
void
sendError
(
final
Object
response
)
{
makeCallback
(
false
response
)
;
}
}
}
