package
org
.
mozilla
.
gecko
.
gfx
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
util
.
Log
;
import
android
.
view
.
Surface
;
public
class
LayerSession
{
private
static
final
String
LOGTAG
=
"
GeckoLayerSession
"
;
private
static
final
boolean
DEBUG
=
false
;
final
static
int
STATIC_TOOLBAR_NEEDS_UPDATE
=
0
;
final
static
int
STATIC_TOOLBAR_READY
=
1
;
final
static
int
TOOLBAR_HIDDEN
=
2
;
final
static
int
TOOLBAR_VISIBLE
=
3
;
final
static
int
TOOLBAR_SHOW
=
4
;
final
static
int
FIRST_PAINT
=
5
;
final
static
int
REQUEST_SHOW_TOOLBAR_IMMEDIATELY
=
6
;
final
static
int
REQUEST_SHOW_TOOLBAR_ANIMATED
=
7
;
final
static
int
REQUEST_HIDE_TOOLBAR_IMMEDIATELY
=
8
;
final
static
int
REQUEST_HIDE_TOOLBAR_ANIMATED
=
9
;
final
static
int
LAYERS_UPDATED
=
10
;
final
static
int
TOOLBAR_SNAPSHOT_FAILED
=
11
;
final
static
int
COMPOSITOR_CONTROLLER_OPEN
=
20
;
final
static
int
IS_COMPOSITOR_CONTROLLER_OPEN
=
21
;
protected
class
Compositor
extends
JNIObject
{
public
boolean
isReady
(
)
{
return
LayerSession
.
this
.
isCompositorReady
(
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
onCompositorAttached
(
)
{
LayerSession
.
this
.
onCompositorAttached
(
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
onCompositorDetached
(
)
{
LayerSession
.
this
.
onCompositorDetached
(
)
;
disposeNative
(
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
(
calledFrom
=
"
any
"
dispatchTo
=
"
gecko
"
)
public
native
void
attachNPZC
(
PanZoomController
npzc
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
public
native
void
onBoundsChanged
(
int
left
int
top
int
width
int
height
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
proxy
"
)
public
native
void
createCompositor
(
int
width
int
height
Object
surface
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
syncPauseCompositor
(
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
syncResumeResizeCompositor
(
int
width
int
height
Object
surface
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
setMaxToolbarHeight
(
int
height
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
setPinned
(
boolean
pinned
int
reason
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
sendToolbarAnimatorMessage
(
int
message
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
recvToolbarAnimatorMessage
(
int
message
)
{
LayerSession
.
this
.
handleCompositorMessage
(
message
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
setDefaultClearColor
(
int
color
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
requestScreenPixels
(
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
recvScreenPixels
(
int
width
int
height
int
[
]
pixels
)
{
LayerSession
.
this
.
recvScreenPixels
(
width
height
pixels
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
enableLayerUpdateNotifications
(
boolean
enable
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
sendToolbarPixelsToCompositor
(
final
int
width
final
int
height
final
int
[
]
pixels
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
updateRootFrameMetrics
(
float
scrollX
float
scrollY
float
zoom
)
{
LayerSession
.
this
.
onMetricsChanged
(
scrollX
scrollY
zoom
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
updateOverscrollVelocity
(
final
float
x
final
float
y
)
{
LayerSession
.
this
.
updateOverscrollVelocity
(
x
y
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
updateOverscrollOffset
(
final
float
x
final
float
y
)
{
LayerSession
.
this
.
updateOverscrollOffset
(
x
y
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
onSelectionCaretDrag
(
final
boolean
dragging
)
{
LayerSession
.
this
.
onSelectionCaretDrag
(
dragging
)
;
}
}
protected
final
Compositor
mCompositor
=
new
Compositor
(
)
;
private
final
GeckoDisplay
mDisplay
=
new
GeckoDisplay
(
this
)
;
private
PanZoomController
mNPZC
;
private
OverscrollEdgeEffect
mOverscroll
;
private
DynamicToolbarAnimator
mToolbar
;
private
CompositorController
mController
;
private
boolean
mAttachedCompositor
;
private
boolean
mCalledCreateCompositor
;
private
boolean
mCompositorReady
;
private
Surface
mSurface
;
private
int
mLeft
;
private
int
mTop
;
private
int
mClientTop
;
private
int
mWidth
;
private
int
mHeight
;
private
int
mClientHeight
;
private
float
mViewportLeft
;
private
float
mViewportTop
;
private
float
mViewportZoom
=
1
.
0f
;
GeckoDisplay
getDisplay
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
return
mDisplay
;
}
public
PanZoomController
getPanZoomController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mNPZC
=
=
null
)
{
mNPZC
=
new
PanZoomController
(
this
)
;
if
(
mAttachedCompositor
)
{
mCompositor
.
attachNPZC
(
mNPZC
)
;
}
}
return
mNPZC
;
}
public
OverscrollEdgeEffect
getOverscrollEdgeEffect
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mOverscroll
=
=
null
)
{
mOverscroll
=
new
OverscrollEdgeEffect
(
this
)
;
}
return
mOverscroll
;
}
public
NonNull
DynamicToolbarAnimator
getDynamicToolbarAnimator
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mToolbar
=
=
null
)
{
mToolbar
=
new
DynamicToolbarAnimator
(
this
)
;
}
return
mToolbar
;
}
public
NonNull
CompositorController
getCompositorController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mController
=
=
null
)
{
mController
=
new
CompositorController
(
this
)
;
if
(
mCompositorReady
)
{
mController
.
onCompositorReady
(
)
;
}
}
return
mController
;
}
public
void
getClientToScreenMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
getClientToSurfaceMatrix
(
matrix
)
;
matrix
.
postTranslate
(
mLeft
mTop
)
;
}
public
void
getClientToSurfaceMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
matrix
.
setScale
(
mViewportZoom
mViewportZoom
)
;
if
(
mClientTop
!
=
mTop
)
{
matrix
.
postTranslate
(
0
mClientTop
-
mTop
)
;
}
}
public
void
getPageToScreenMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
getPageToSurfaceMatrix
(
matrix
)
;
matrix
.
postTranslate
(
mLeft
mTop
)
;
}
public
void
getPageToSurfaceMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
getClientToSurfaceMatrix
(
matrix
)
;
matrix
.
postTranslate
(
-
mViewportLeft
-
mViewportTop
)
;
}
public
void
getClientBounds
(
NonNull
final
RectF
rect
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
rect
.
set
(
0
.
0f
0
.
0f
(
float
)
mWidth
/
mViewportZoom
(
float
)
mClientHeight
/
mViewportZoom
)
;
}
public
void
getSurfaceBounds
(
NonNull
final
Rect
rect
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
rect
.
set
(
0
mClientTop
-
mTop
mWidth
mHeight
)
;
}
WrapForJNI
(
stubName
=
"
GetCompositor
"
calledFrom
=
"
ui
"
)
private
Object
getCompositorFromNative
(
)
{
return
mCompositorReady
?
mCompositor
:
null
;
}
void
onCompositorAttached
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mAttachedCompositor
=
true
;
if
(
mNPZC
!
=
null
)
{
mCompositor
.
attachNPZC
(
mNPZC
)
;
}
if
(
mSurface
!
=
null
)
{
onSurfaceChanged
(
mSurface
mWidth
mHeight
)
;
}
}
void
onCompositorDetached
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mController
!
=
null
)
{
mController
.
onCompositorDetached
(
)
;
}
mAttachedCompositor
=
false
;
mCalledCreateCompositor
=
false
;
mCompositorReady
=
false
;
}
void
handleCompositorMessage
(
final
int
message
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
switch
(
message
)
{
case
COMPOSITOR_CONTROLLER_OPEN
:
{
if
(
isCompositorReady
(
)
)
{
return
;
}
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
onCompositorReady
(
)
;
}
}
)
;
break
;
}
case
FIRST_PAINT
:
{
if
(
mController
!
=
null
)
{
mController
.
onFirstPaint
(
)
;
}
break
;
}
case
LAYERS_UPDATED
:
{
if
(
mController
!
=
null
)
{
mController
.
notifyDrawCallbacks
(
)
;
}
break
;
}
case
STATIC_TOOLBAR_READY
:
case
TOOLBAR_SHOW
:
{
if
(
mToolbar
!
=
null
)
{
mToolbar
.
handleToolbarAnimatorMessage
(
message
)
;
onWindowBoundsChanged
(
)
;
}
break
;
}
default
:
{
if
(
mToolbar
!
=
null
)
{
mToolbar
.
handleToolbarAnimatorMessage
(
message
)
;
}
else
{
Log
.
w
(
LOGTAG
"
Unexpected
message
:
"
+
message
)
;
}
break
;
}
}
}
void
recvScreenPixels
(
int
width
int
height
int
[
]
pixels
)
{
if
(
mController
!
=
null
)
{
mController
.
recvScreenPixels
(
width
height
pixels
)
;
}
}
boolean
isCompositorReady
(
)
{
return
mCompositorReady
;
}
void
onCompositorReady
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mCompositorReady
=
true
;
if
(
mController
!
=
null
)
{
mController
.
onCompositorReady
(
)
;
}
if
(
mSurface
!
=
null
)
{
onSurfaceChanged
(
mSurface
mWidth
mHeight
)
;
mSurface
=
null
;
}
if
(
mToolbar
!
=
null
)
{
mToolbar
.
onCompositorReady
(
)
;
}
}
void
updateOverscrollVelocity
(
final
float
x
final
float
y
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mOverscroll
=
=
null
)
{
return
;
}
mOverscroll
.
setVelocity
(
x
*
1000
.
0f
OverscrollEdgeEffect
.
AXIS_X
)
;
mOverscroll
.
setVelocity
(
y
*
1000
.
0f
OverscrollEdgeEffect
.
AXIS_Y
)
;
}
void
updateOverscrollOffset
(
final
float
x
final
float
y
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mOverscroll
=
=
null
)
{
return
;
}
mOverscroll
.
setDistance
(
x
OverscrollEdgeEffect
.
AXIS_X
)
;
mOverscroll
.
setDistance
(
y
OverscrollEdgeEffect
.
AXIS_Y
)
;
}
void
onSelectionCaretDrag
(
final
boolean
dragging
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mToolbar
!
=
null
)
{
mToolbar
.
setPinned
(
dragging
DynamicToolbarAnimator
.
PinReason
.
CARET_DRAG
)
;
}
}
void
onMetricsChanged
(
final
float
scrollX
final
float
scrollY
final
float
zoom
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mViewportLeft
=
scrollX
;
mViewportTop
=
scrollY
;
mViewportZoom
=
zoom
;
}
void
onWindowBoundsChanged
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
final
int
toolbarHeight
;
if
(
mToolbar
!
=
null
)
{
toolbarHeight
=
mToolbar
.
getCurrentToolbarHeight
(
)
;
}
else
{
toolbarHeight
=
0
;
}
mClientTop
=
mTop
+
toolbarHeight
;
mClientHeight
=
mHeight
-
toolbarHeight
;
if
(
mAttachedCompositor
)
{
mCompositor
.
onBoundsChanged
(
mLeft
mClientTop
mWidth
mClientHeight
)
;
}
if
(
mOverscroll
!
=
null
)
{
mOverscroll
.
setSize
(
mWidth
mClientHeight
)
;
}
}
void
onSurfaceChanged
(
final
Surface
surface
final
int
width
final
int
height
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mWidth
=
width
;
mHeight
=
height
;
if
(
mCompositorReady
)
{
mCompositor
.
syncResumeResizeCompositor
(
width
height
surface
)
;
onWindowBoundsChanged
(
)
;
return
;
}
if
(
mAttachedCompositor
&
&
!
mCalledCreateCompositor
)
{
mCompositor
.
createCompositor
(
width
height
surface
)
;
mCompositor
.
sendToolbarAnimatorMessage
(
IS_COMPOSITOR_CONTROLLER_OPEN
)
;
mCalledCreateCompositor
=
true
;
}
mSurface
=
surface
;
onWindowBoundsChanged
(
)
;
}
void
onSurfaceDestroyed
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mCompositorReady
)
{
mCompositor
.
syncPauseCompositor
(
)
;
return
;
}
mSurface
=
null
;
}
void
onScreenOriginChanged
(
final
int
left
final
int
top
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mLeft
=
=
left
&
&
mTop
=
=
top
)
{
return
;
}
mLeft
=
left
;
mTop
=
top
;
onWindowBoundsChanged
(
)
;
}
public
NonNull
GeckoDisplay
acquireDisplay
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mDisplay
;
}
public
void
releaseDisplay
(
final
NonNull
GeckoDisplay
display
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
display
!
=
mDisplay
)
{
throw
new
IllegalArgumentException
(
"
Display
not
attached
"
)
;
}
}
}
