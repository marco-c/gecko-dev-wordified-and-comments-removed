package
org
.
mozilla
.
geckoview
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Color
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
support
.
annotation
.
LongDef
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Date
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
UUID
;
public
class
WebExtension
{
public
final
NonNull
String
location
;
public
final
NonNull
String
id
;
public
final
WebExtensionFlags
long
flags
;
public
final
Nullable
MetaData
metaData
;
public
final
boolean
isBuiltIn
;
interface
DelegateController
{
void
onMessageDelegate
(
final
String
nativeApp
final
MessageDelegate
delegate
)
;
void
onActionDelegate
(
final
ActionDelegate
delegate
)
;
void
onTabDelegate
(
final
TabDelegate
delegate
)
;
ActionDelegate
getActionDelegate
(
)
;
TabDelegate
getTabDelegate
(
)
;
}
private
DelegateController
mDelegateController
=
null
;
void
setDelegateController
(
final
DelegateController
delegate
)
{
mDelegateController
=
delegate
;
}
Override
public
String
toString
(
)
{
return
"
WebExtension
{
"
+
"
location
=
"
+
location
+
"
"
+
"
id
=
"
+
id
+
"
"
+
"
flags
=
"
+
flags
+
"
}
"
;
}
private
final
static
String
LOGTAG
=
"
WebExtension
"
;
public
static
class
Flags
{
public
static
final
long
NONE
=
0
;
public
static
final
long
ALLOW_CONTENT_MESSAGING
=
1
<
<
0
;
protected
Flags
(
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
LongDef
(
flag
=
true
value
=
{
Flags
.
NONE
Flags
.
ALLOW_CONTENT_MESSAGING
}
)
interface
WebExtensionFlags
{
}
WebExtension
(
final
GeckoBundle
bundle
)
{
location
=
bundle
.
getString
(
"
locationURI
"
)
;
id
=
bundle
.
getString
(
"
webExtensionId
"
)
;
flags
=
bundle
.
getInt
(
"
webExtensionFlags
"
0
)
;
isBuiltIn
=
bundle
.
getBoolean
(
"
isBuiltIn
"
false
)
;
if
(
bundle
.
containsKey
(
"
metaData
"
)
)
{
metaData
=
new
MetaData
(
bundle
.
getBundle
(
"
metaData
"
)
)
;
}
else
{
metaData
=
null
;
}
}
Deprecated
public
WebExtension
(
final
NonNull
String
location
final
NonNull
String
id
final
WebExtensionFlags
long
flags
final
NonNull
WebExtensionController
controller
)
{
setDelegateController
(
controller
.
delegateFor
(
this
)
)
;
this
.
location
=
location
;
this
.
id
=
id
;
this
.
flags
=
flags
;
this
.
isBuiltIn
=
false
;
this
.
metaData
=
null
;
}
Deprecated
public
WebExtension
(
final
NonNull
String
location
final
NonNull
WebExtensionController
controller
)
{
this
(
location
"
{
"
+
UUID
.
randomUUID
(
)
.
toString
(
)
+
"
}
"
Flags
.
NONE
controller
)
;
}
UiThread
public
void
setMessageDelegate
(
final
Nullable
MessageDelegate
messageDelegate
final
NonNull
String
nativeApp
)
{
if
(
mDelegateController
!
=
null
)
{
mDelegateController
.
onMessageDelegate
(
nativeApp
messageDelegate
)
;
}
}
UiThread
public
interface
MessageDelegate
{
Nullable
default
GeckoResult
<
Object
>
onMessage
(
final
NonNull
String
nativeApp
final
NonNull
Object
message
final
NonNull
MessageSender
sender
)
{
return
null
;
}
Nullable
default
void
onConnect
(
final
NonNull
Port
port
)
{
}
}
UiThread
public
interface
PortDelegate
{
default
void
onPortMessage
(
final
NonNull
Object
message
final
NonNull
Port
port
)
{
}
NonNull
default
void
onDisconnect
(
final
NonNull
Port
port
)
{
}
}
UiThread
public
static
class
Port
{
final
long
id
;
PortDelegate
delegate
;
boolean
disconnected
=
false
;
final
EventDispatcher
mEventDispatcher
;
boolean
mListenersRegistered
=
false
;
public
NonNull
final
MessageSender
sender
;
public
NonNull
final
String
name
;
protected
Port
(
)
{
this
.
id
=
-
1
;
this
.
delegate
=
null
;
this
.
sender
=
null
;
this
.
name
=
null
;
mEventDispatcher
=
null
;
}
Port
(
final
String
name
final
long
id
final
MessageSender
sender
)
{
this
.
id
=
id
;
this
.
delegate
=
null
;
this
.
sender
=
sender
;
this
.
name
=
name
;
mEventDispatcher
=
EventDispatcher
.
byName
(
"
port
:
"
+
id
)
;
}
private
BundleEventListener
mEventListener
=
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
WebExtension
:
Disconnect
"
.
equals
(
event
)
)
{
disconnectFromExtension
(
callback
)
;
}
else
if
(
"
GeckoView
:
WebExtension
:
PortMessage
"
.
equals
(
event
)
)
{
portMessage
(
message
callback
)
;
}
}
}
;
private
void
disconnectFromExtension
(
final
EventCallback
callback
)
{
delegate
.
onDisconnect
(
this
)
;
disconnected
(
)
;
}
private
void
portMessage
(
final
GeckoBundle
bundle
final
EventCallback
callback
)
{
final
Object
content
;
try
{
content
=
bundle
.
toJSONObject
(
)
.
get
(
"
data
"
)
;
}
catch
(
JSONException
ex
)
{
callback
.
sendError
(
ex
)
;
return
;
}
delegate
.
onPortMessage
(
content
this
)
;
}
public
void
postMessage
(
final
NonNull
JSONObject
message
)
{
GeckoBundle
args
=
new
GeckoBundle
(
1
)
;
try
{
args
.
putBundle
(
"
message
"
GeckoBundle
.
fromJSONObject
(
message
)
)
;
}
catch
(
JSONException
ex
)
{
throw
new
RuntimeException
(
ex
)
;
}
mEventDispatcher
.
dispatch
(
"
GeckoView
:
WebExtension
:
PortMessageFromApp
"
args
)
;
}
public
void
disconnect
(
)
{
if
(
this
.
disconnected
)
{
return
;
}
GeckoBundle
args
=
new
GeckoBundle
(
1
)
;
args
.
putLong
(
"
portId
"
id
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
WebExtension
:
PortDisconnect
"
args
)
;
disconnected
(
)
;
}
private
void
disconnected
(
)
{
unregisterListeners
(
)
;
mEventDispatcher
.
shutdown
(
)
;
this
.
disconnected
=
true
;
}
public
void
setDelegate
(
final
Nullable
PortDelegate
delegate
)
{
this
.
delegate
=
delegate
;
if
(
delegate
!
=
null
)
{
registerListeners
(
)
;
}
else
{
unregisterListeners
(
)
;
}
}
private
void
unregisterListeners
(
)
{
if
(
!
mListenersRegistered
)
{
return
;
}
mEventDispatcher
.
unregisterUiThreadListener
(
mEventListener
"
GeckoView
:
WebExtension
:
Disconnect
"
"
GeckoView
:
WebExtension
:
PortMessage
"
)
;
mListenersRegistered
=
false
;
}
private
void
registerListeners
(
)
{
if
(
mListenersRegistered
)
{
return
;
}
mEventDispatcher
.
registerUiThreadListener
(
mEventListener
"
GeckoView
:
WebExtension
:
Disconnect
"
"
GeckoView
:
WebExtension
:
PortMessage
"
)
;
mListenersRegistered
=
true
;
}
}
public
interface
SessionTabDelegate
{
UiThread
NonNull
default
GeckoResult
<
AllowOrDeny
>
onCloseTab
(
Nullable
WebExtension
source
NonNull
GeckoSession
session
)
{
return
GeckoResult
.
DENY
;
}
UiThread
NonNull
default
GeckoResult
<
AllowOrDeny
>
onUpdateTab
(
final
NonNull
WebExtension
extension
final
NonNull
GeckoSession
session
final
NonNull
UpdateTabDetails
details
)
{
return
GeckoResult
.
DENY
;
}
}
public
static
class
UpdateTabDetails
{
Nullable
public
final
Boolean
active
;
Nullable
public
final
Boolean
autoDiscardable
;
Nullable
public
final
Boolean
highlighted
;
Nullable
public
final
Boolean
muted
;
Nullable
public
final
Boolean
pinned
;
Nullable
public
final
String
url
;
protected
UpdateTabDetails
(
)
{
active
=
null
;
autoDiscardable
=
null
;
highlighted
=
null
;
muted
=
null
;
pinned
=
null
;
url
=
null
;
}
UpdateTabDetails
(
final
GeckoBundle
bundle
)
{
active
=
bundle
.
getBooleanObject
(
"
active
"
)
;
autoDiscardable
=
bundle
.
getBooleanObject
(
"
autoDiscardable
"
)
;
highlighted
=
bundle
.
getBooleanObject
(
"
highlighted
"
)
;
muted
=
bundle
.
getBooleanObject
(
"
muted
"
)
;
pinned
=
bundle
.
getBooleanObject
(
"
pinned
"
)
;
url
=
bundle
.
getString
(
"
url
"
)
;
}
}
public
static
class
CreateTabDetails
{
Nullable
public
final
Boolean
active
;
Nullable
public
final
String
cookieStoreId
;
Nullable
public
final
Boolean
discarded
;
Nullable
public
final
Integer
index
;
Nullable
public
final
Boolean
openInReaderMode
;
Nullable
public
final
Boolean
pinned
;
Nullable
public
final
String
url
;
protected
CreateTabDetails
(
)
{
active
=
null
;
cookieStoreId
=
null
;
discarded
=
null
;
index
=
null
;
openInReaderMode
=
null
;
pinned
=
null
;
url
=
null
;
}
CreateTabDetails
(
final
GeckoBundle
bundle
)
{
active
=
bundle
.
getBooleanObject
(
"
active
"
)
;
cookieStoreId
=
bundle
.
getString
(
"
cookieStoreId
"
)
;
discarded
=
bundle
.
getBooleanObject
(
"
discarded
"
)
;
index
=
bundle
.
getInteger
(
"
index
"
)
;
openInReaderMode
=
bundle
.
getBooleanObject
(
"
openInReaderMode
"
)
;
pinned
=
bundle
.
getBooleanObject
(
"
pinned
"
)
;
url
=
bundle
.
getString
(
"
url
"
)
;
}
}
public
interface
TabDelegate
{
UiThread
Nullable
default
GeckoResult
<
GeckoSession
>
onNewTab
(
NonNull
WebExtension
source
NonNull
CreateTabDetails
createDetails
)
{
return
null
;
}
UiThread
default
void
onOpenOptionsPage
(
NonNull
WebExtension
source
)
{
}
}
UiThread
Nullable
public
WebExtension
.
TabDelegate
getTabDelegate
(
)
{
return
mDelegateController
.
getTabDelegate
(
)
;
}
UiThread
public
void
setTabDelegate
(
final
Nullable
TabDelegate
delegate
)
{
if
(
mDelegateController
!
=
null
)
{
mDelegateController
.
onTabDelegate
(
delegate
)
;
}
}
private
static
class
Sender
{
public
String
webExtensionId
;
public
String
nativeApp
;
public
Sender
(
final
String
webExtensionId
final
String
nativeApp
)
{
this
.
webExtensionId
=
webExtensionId
;
this
.
nativeApp
=
nativeApp
;
}
Override
public
boolean
equals
(
final
Object
other
)
{
if
(
!
(
other
instanceof
Sender
)
)
{
return
false
;
}
Sender
o
=
(
Sender
)
other
;
return
webExtensionId
.
equals
(
o
.
webExtensionId
)
&
&
nativeApp
.
equals
(
o
.
nativeApp
)
;
}
Override
public
int
hashCode
(
)
{
int
result
=
17
;
result
=
31
*
result
+
(
webExtensionId
!
=
null
?
webExtensionId
.
hashCode
(
)
:
0
)
;
result
=
31
*
result
+
(
nativeApp
!
=
null
?
nativeApp
.
hashCode
(
)
:
0
)
;
return
result
;
}
}
public
static
class
SessionController
{
private
final
Listener
<
SessionTabDelegate
>
mListener
;
void
setRuntime
(
final
GeckoRuntime
runtime
)
{
mListener
.
runtime
=
runtime
;
}
SessionController
(
final
GeckoSession
session
)
{
mListener
=
new
Listener
<
>
(
session
)
;
}
AnyThread
public
void
setMessageDelegate
(
final
NonNull
WebExtension
webExtension
final
Nullable
WebExtension
.
MessageDelegate
delegate
final
NonNull
String
nativeApp
)
{
mListener
.
setMessageDelegate
(
webExtension
delegate
nativeApp
)
;
}
AnyThread
public
Nullable
WebExtension
.
MessageDelegate
getMessageDelegate
(
final
NonNull
WebExtension
extension
final
NonNull
String
nativeApp
)
{
return
mListener
.
getMessageDelegate
(
extension
nativeApp
)
;
}
AnyThread
public
void
setActionDelegate
(
final
NonNull
WebExtension
extension
final
Nullable
ActionDelegate
delegate
)
{
mListener
.
setActionDelegate
(
extension
delegate
)
;
}
AnyThread
Nullable
public
ActionDelegate
getActionDelegate
(
final
NonNull
WebExtension
extension
)
{
return
mListener
.
getActionDelegate
(
extension
)
;
}
AnyThread
public
void
setTabDelegate
(
final
NonNull
WebExtension
extension
final
Nullable
SessionTabDelegate
delegate
)
{
mListener
.
setTabDelegate
(
extension
delegate
)
;
}
AnyThread
Nullable
public
SessionTabDelegate
getTabDelegate
(
final
NonNull
WebExtension
extension
)
{
return
mListener
.
getTabDelegate
(
extension
)
;
}
}
final
static
class
Listener
<
TabDelegate
>
implements
BundleEventListener
{
final
private
HashMap
<
Sender
WebExtension
.
MessageDelegate
>
mMessageDelegates
;
final
private
HashMap
<
String
WebExtension
.
ActionDelegate
>
mActionDelegates
;
final
private
HashMap
<
String
TabDelegate
>
mTabDelegates
;
final
private
GeckoSession
mSession
;
final
private
EventDispatcher
mEventDispatcher
;
private
boolean
mActionDelegateRegistered
=
false
;
private
boolean
mTabDelegateRegistered
=
false
;
public
GeckoRuntime
runtime
;
public
Listener
(
final
GeckoRuntime
runtime
)
{
this
(
null
runtime
)
;
}
public
Listener
(
final
GeckoSession
session
)
{
this
(
session
null
)
;
mEventDispatcher
.
registerUiThreadListener
(
this
"
GeckoView
:
WebExtension
:
NewTab
"
"
GeckoView
:
WebExtension
:
UpdateTab
"
"
GeckoView
:
WebExtension
:
CloseTab
"
"
GeckoView
:
WebExtension
:
OpenOptionsPage
"
)
;
mTabDelegateRegistered
=
true
;
}
private
Listener
(
final
GeckoSession
session
final
GeckoRuntime
runtime
)
{
mMessageDelegates
=
new
HashMap
<
>
(
)
;
mActionDelegates
=
new
HashMap
<
>
(
)
;
mTabDelegates
=
new
HashMap
<
>
(
)
;
mEventDispatcher
=
session
!
=
null
?
session
.
getEventDispatcher
(
)
:
EventDispatcher
.
getInstance
(
)
;
mSession
=
session
;
this
.
runtime
=
runtime
;
mEventDispatcher
.
registerUiThreadListener
(
this
"
GeckoView
:
WebExtension
:
Message
"
"
GeckoView
:
WebExtension
:
PortMessage
"
"
GeckoView
:
WebExtension
:
Connect
"
"
GeckoView
:
WebExtension
:
Disconnect
"
)
;
}
public
void
unregisterWebExtension
(
final
WebExtension
extension
)
{
mMessageDelegates
.
remove
(
extension
.
id
)
;
mActionDelegates
.
remove
(
extension
.
id
)
;
mTabDelegates
.
remove
(
extension
.
id
)
;
}
public
void
setTabDelegate
(
final
WebExtension
webExtension
final
TabDelegate
delegate
)
{
if
(
!
mTabDelegateRegistered
&
&
delegate
!
=
null
)
{
mEventDispatcher
.
registerUiThreadListener
(
this
"
GeckoView
:
WebExtension
:
NewTab
"
"
GeckoView
:
WebExtension
:
UpdateTab
"
"
GeckoView
:
WebExtension
:
CloseTab
"
"
GeckoView
:
WebExtension
:
OpenOptionsPage
"
)
;
mTabDelegateRegistered
=
true
;
}
mTabDelegates
.
put
(
webExtension
.
id
delegate
)
;
}
public
TabDelegate
getTabDelegate
(
final
WebExtension
webExtension
)
{
return
mTabDelegates
.
get
(
webExtension
.
id
)
;
}
public
void
setActionDelegate
(
final
WebExtension
webExtension
final
WebExtension
.
ActionDelegate
delegate
)
{
if
(
!
mActionDelegateRegistered
&
&
delegate
!
=
null
)
{
mEventDispatcher
.
registerUiThreadListener
(
this
"
GeckoView
:
BrowserAction
:
Update
"
"
GeckoView
:
BrowserAction
:
OpenPopup
"
"
GeckoView
:
PageAction
:
Update
"
"
GeckoView
:
PageAction
:
OpenPopup
"
)
;
mActionDelegateRegistered
=
true
;
}
mActionDelegates
.
put
(
webExtension
.
id
delegate
)
;
}
public
WebExtension
.
ActionDelegate
getActionDelegate
(
final
WebExtension
webExtension
)
{
return
mActionDelegates
.
get
(
webExtension
.
id
)
;
}
public
void
setMessageDelegate
(
final
WebExtension
webExtension
final
WebExtension
.
MessageDelegate
delegate
final
String
nativeApp
)
{
mMessageDelegates
.
put
(
new
Sender
(
webExtension
.
id
nativeApp
)
delegate
)
;
}
public
WebExtension
.
MessageDelegate
getMessageDelegate
(
final
WebExtension
webExtension
final
String
nativeApp
)
{
return
mMessageDelegates
.
get
(
new
Sender
(
webExtension
.
id
nativeApp
)
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
runtime
=
=
null
)
{
return
;
}
runtime
.
getWebExtensionController
(
)
.
handleMessage
(
event
message
callback
mSession
)
;
}
}
UiThread
public
static
class
MessageSender
{
public
final
NonNull
WebExtension
webExtension
;
public
final
Nullable
GeckoSession
session
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
ENV_TYPE_UNKNOWN
ENV_TYPE_EXTENSION
ENV_TYPE_CONTENT_SCRIPT
}
)
interface
EnvType
{
}
static
final
int
ENV_TYPE_UNKNOWN
=
0
;
public
static
final
int
ENV_TYPE_EXTENSION
=
1
;
public
static
final
int
ENV_TYPE_CONTENT_SCRIPT
=
2
;
public
final
EnvType
int
environmentType
;
public
final
NonNull
String
url
;
final
boolean
isTopLevel
;
MessageSender
(
final
NonNull
WebExtension
webExtension
final
Nullable
GeckoSession
session
final
Nullable
String
url
final
EnvType
int
environmentType
final
boolean
isTopLevel
)
{
this
.
webExtension
=
webExtension
;
this
.
session
=
session
;
this
.
isTopLevel
=
isTopLevel
;
this
.
url
=
url
;
this
.
environmentType
=
environmentType
;
}
protected
MessageSender
(
)
{
this
.
webExtension
=
null
;
this
.
session
=
null
;
this
.
isTopLevel
=
false
;
this
.
url
=
null
;
this
.
environmentType
=
ENV_TYPE_UNKNOWN
;
}
public
boolean
isTopLevel
(
)
{
return
this
.
isTopLevel
;
}
}
public
static
class
Icon
{
private
Map
<
Integer
String
>
mIconUris
;
AnyThread
NonNull
public
GeckoResult
<
Bitmap
>
get
(
final
int
pixelSize
)
{
int
size
;
if
(
mIconUris
.
containsKey
(
pixelSize
)
)
{
size
=
pixelSize
;
}
else
{
List
<
Integer
>
sizes
=
new
ArrayList
<
>
(
)
;
sizes
.
addAll
(
mIconUris
.
keySet
(
)
)
;
Collections
.
sort
(
sizes
(
a
b
)
-
>
Integer
.
compare
(
b
-
pixelSize
a
-
pixelSize
)
)
;
size
=
sizes
.
get
(
0
)
;
}
final
String
uri
=
mIconUris
.
get
(
size
)
;
return
ImageDecoder
.
instance
(
)
.
decode
(
uri
pixelSize
)
;
}
Icon
(
final
GeckoBundle
bundle
)
{
mIconUris
=
new
HashMap
<
>
(
)
;
for
(
final
String
key
:
bundle
.
keys
(
)
)
{
final
Integer
intKey
=
Integer
.
valueOf
(
key
)
;
if
(
intKey
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Non
-
integer
icon
key
:
"
+
intKey
)
;
if
(
BuildConfig
.
DEBUG
)
{
throw
new
RuntimeException
(
"
Non
-
integer
icon
key
:
"
+
key
)
;
}
continue
;
}
final
String
value
=
getIconValue
(
bundle
.
get
(
key
)
)
;
if
(
value
!
=
null
)
{
mIconUris
.
put
(
intKey
value
)
;
}
}
}
private
String
getIconValue
(
final
Object
value
)
{
if
(
value
instanceof
GeckoBundle
)
{
final
GeckoBundle
themeIcons
=
(
GeckoBundle
)
value
;
final
Object
defaultIcon
=
themeIcons
.
get
(
"
default
"
)
;
if
(
!
(
defaultIcon
instanceof
String
)
)
{
if
(
BuildConfig
.
DEBUG
)
{
throw
new
RuntimeException
(
"
Unexpected
themed_icon
value
.
"
)
;
}
Log
.
e
(
LOGTAG
"
Unexpected
themed_icon
value
.
"
)
;
return
null
;
}
return
(
String
)
defaultIcon
;
}
if
(
value
instanceof
String
)
{
return
(
String
)
value
;
}
if
(
BuildConfig
.
DEBUG
)
{
throw
new
RuntimeException
(
"
Unexpected
icon
value
:
"
+
value
)
;
}
Log
.
e
(
LOGTAG
"
Unexpected
icon
value
.
"
)
;
return
null
;
}
protected
Icon
(
)
{
mIconUris
=
null
;
}
Override
public
boolean
equals
(
final
Object
o
)
{
if
(
o
=
=
this
)
{
return
true
;
}
if
(
!
(
o
instanceof
Icon
)
)
{
return
false
;
}
return
mIconUris
.
equals
(
(
(
Icon
)
o
)
.
mIconUris
)
;
}
Override
public
int
hashCode
(
)
{
return
mIconUris
.
hashCode
(
)
;
}
}
AnyThread
public
static
class
Action
{
final
public
Nullable
String
title
;
final
public
Nullable
Icon
icon
;
final
private
Nullable
String
mPopupUri
;
final
public
Nullable
Boolean
enabled
;
final
public
Nullable
String
badgeText
;
final
public
Nullable
Integer
badgeBackgroundColor
;
final
public
Nullable
Integer
badgeTextColor
;
final
private
WebExtension
mExtension
;
final
static
int
TYPE_BROWSER_ACTION
=
1
;
final
static
int
TYPE_PAGE_ACTION
=
2
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
TYPE_BROWSER_ACTION
TYPE_PAGE_ACTION
}
)
interface
ActionType
{
}
final
ActionType
int
type
;
Action
(
final
ActionType
int
type
final
GeckoBundle
bundle
final
WebExtension
extension
)
{
mExtension
=
extension
;
mPopupUri
=
bundle
.
getString
(
"
popup
"
)
;
this
.
type
=
type
;
title
=
bundle
.
getString
(
"
title
"
)
;
badgeText
=
bundle
.
getString
(
"
badgeText
"
)
;
badgeBackgroundColor
=
colorFromRgbaArray
(
bundle
.
getDoubleArray
(
"
badgeBackgroundColor
"
)
)
;
badgeTextColor
=
colorFromRgbaArray
(
bundle
.
getDoubleArray
(
"
badgeTextColor
"
)
)
;
if
(
bundle
.
containsKey
(
"
icon
"
)
)
{
icon
=
new
Icon
(
bundle
.
getBundle
(
"
icon
"
)
)
;
}
else
{
icon
=
null
;
}
if
(
bundle
.
getBoolean
(
"
patternMatching
"
false
)
)
{
enabled
=
true
;
}
else
if
(
bundle
.
containsKey
(
"
enabled
"
)
)
{
enabled
=
bundle
.
getBoolean
(
"
enabled
"
)
;
}
else
{
enabled
=
null
;
}
}
private
Integer
colorFromRgbaArray
(
final
double
[
]
c
)
{
if
(
c
=
=
null
)
{
return
null
;
}
return
Color
.
argb
(
(
int
)
c
[
3
]
(
int
)
c
[
0
]
(
int
)
c
[
1
]
(
int
)
c
[
2
]
)
;
}
Override
public
String
toString
(
)
{
return
"
Action
{
\
n
"
+
"
\
ttitle
:
"
+
this
.
title
+
"
\
n
"
+
"
\
ticon
:
"
+
this
.
icon
+
"
\
n
"
+
"
\
tpopupUri
:
"
+
this
.
mPopupUri
+
"
\
n
"
+
"
\
tenabled
:
"
+
this
.
enabled
+
"
\
n
"
+
"
\
tbadgeText
:
"
+
this
.
badgeText
+
"
\
n
"
+
"
\
tbadgeTextColor
:
"
+
this
.
badgeTextColor
+
"
\
n
"
+
"
\
tbadgeBackgroundColor
:
"
+
this
.
badgeBackgroundColor
+
"
\
n
"
+
"
}
"
;
}
protected
Action
(
)
{
type
=
TYPE_BROWSER_ACTION
;
mExtension
=
null
;
mPopupUri
=
null
;
title
=
null
;
icon
=
null
;
enabled
=
null
;
badgeText
=
null
;
badgeTextColor
=
null
;
badgeBackgroundColor
=
null
;
}
NonNull
public
Action
withDefault
(
final
NonNull
Action
defaultValue
)
{
return
new
Action
(
this
defaultValue
)
;
}
private
Action
(
final
Action
source
final
Action
defaultValue
)
{
if
(
source
.
type
!
=
defaultValue
.
type
)
{
throw
new
IllegalArgumentException
(
"
defaultValue
must
be
of
the
same
type
.
"
)
;
}
type
=
source
.
type
;
mExtension
=
source
.
mExtension
;
title
=
source
.
title
!
=
null
?
source
.
title
:
defaultValue
.
title
;
icon
=
source
.
icon
!
=
null
?
source
.
icon
:
defaultValue
.
icon
;
mPopupUri
=
source
.
mPopupUri
!
=
null
?
source
.
mPopupUri
:
defaultValue
.
mPopupUri
;
enabled
=
source
.
enabled
!
=
null
?
source
.
enabled
:
defaultValue
.
enabled
;
badgeText
=
source
.
badgeText
!
=
null
?
source
.
badgeText
:
defaultValue
.
badgeText
;
badgeTextColor
=
source
.
badgeTextColor
!
=
null
?
source
.
badgeTextColor
:
defaultValue
.
badgeTextColor
;
badgeBackgroundColor
=
source
.
badgeBackgroundColor
!
=
null
?
source
.
badgeBackgroundColor
:
defaultValue
.
badgeBackgroundColor
;
}
UiThread
public
void
click
(
)
{
if
(
mPopupUri
!
=
null
&
&
!
mPopupUri
.
isEmpty
(
)
)
{
final
ActionDelegate
delegate
=
mExtension
.
mDelegateController
.
getActionDelegate
(
)
;
if
(
delegate
=
=
null
)
{
return
;
}
GeckoResult
<
GeckoSession
>
popup
=
delegate
.
onTogglePopup
(
mExtension
this
)
;
openPopup
(
popup
)
;
return
;
}
final
GeckoBundle
bundle
=
new
GeckoBundle
(
1
)
;
bundle
.
putString
(
"
extensionId
"
mExtension
.
id
)
;
if
(
type
=
=
TYPE_BROWSER_ACTION
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
BrowserAction
:
Click
"
bundle
)
;
}
else
if
(
type
=
=
TYPE_PAGE_ACTION
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
PageAction
:
Click
"
bundle
)
;
}
else
{
throw
new
IllegalStateException
(
"
Unknown
Action
type
"
)
;
}
}
void
openPopup
(
final
GeckoResult
<
GeckoSession
>
popup
)
{
if
(
popup
=
=
null
)
{
return
;
}
popup
.
accept
(
session
-
>
{
if
(
session
=
=
null
)
{
return
;
}
session
.
getSettings
(
)
.
setIsPopup
(
true
)
;
session
.
loadUri
(
mPopupUri
)
;
}
)
;
}
}
public
interface
ActionDelegate
{
UiThread
default
void
onBrowserAction
(
final
NonNull
WebExtension
extension
final
Nullable
GeckoSession
session
final
NonNull
Action
action
)
{
}
UiThread
default
void
onPageAction
(
final
NonNull
WebExtension
extension
final
Nullable
GeckoSession
session
final
NonNull
Action
action
)
{
}
UiThread
Nullable
default
GeckoResult
<
GeckoSession
>
onTogglePopup
(
final
NonNull
WebExtension
extension
final
NonNull
Action
action
)
{
return
null
;
}
UiThread
Nullable
default
GeckoResult
<
GeckoSession
>
onOpenPopup
(
final
NonNull
WebExtension
extension
final
NonNull
Action
action
)
{
return
null
;
}
}
public
static
class
InstallException
extends
Exception
{
public
static
class
ErrorCodes
{
public
static
final
int
ERROR_NETWORK_FAILURE
=
-
1
;
public
static
final
int
ERROR_INCORRECT_HASH
=
-
2
;
public
static
final
int
ERROR_CORRUPT_FILE
=
-
3
;
public
static
final
int
ERROR_FILE_ACCESS
=
-
4
;
public
static
final
int
ERROR_SIGNEDSTATE_REQUIRED
=
-
5
;
public
static
final
int
ERROR_UNEXPECTED_ADDON_TYPE
=
-
6
;
public
static
final
int
ERROR_INCORRECT_ID
=
-
7
;
public
static
final
int
ERROR_USER_CANCELED
=
-
100
;
public
static
final
int
ERROR_POSTPONED
=
-
101
;
protected
ErrorCodes
(
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
value
=
{
ErrorCodes
.
ERROR_NETWORK_FAILURE
ErrorCodes
.
ERROR_INCORRECT_HASH
ErrorCodes
.
ERROR_CORRUPT_FILE
ErrorCodes
.
ERROR_FILE_ACCESS
ErrorCodes
.
ERROR_SIGNEDSTATE_REQUIRED
ErrorCodes
.
ERROR_UNEXPECTED_ADDON_TYPE
ErrorCodes
.
ERROR_INCORRECT_ID
ErrorCodes
.
ERROR_USER_CANCELED
ErrorCodes
.
ERROR_POSTPONED
}
)
interface
Codes
{
}
public
final
Codes
int
code
;
protected
InstallException
(
)
{
this
.
code
=
ErrorCodes
.
ERROR_NETWORK_FAILURE
;
}
Override
public
String
toString
(
)
{
return
"
InstallException
:
"
+
code
;
}
InstallException
(
final
Codes
int
code
)
{
this
.
code
=
code
;
}
}
AnyThread
public
void
setActionDelegate
(
final
Nullable
ActionDelegate
delegate
)
{
if
(
mDelegateController
!
=
null
)
{
mDelegateController
.
onActionDelegate
(
delegate
)
;
}
final
GeckoBundle
bundle
=
new
GeckoBundle
(
1
)
;
bundle
.
putString
(
"
extensionId
"
id
)
;
if
(
delegate
!
=
null
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
ActionDelegate
:
Attached
"
bundle
)
;
}
}
public
static
class
SignedStateFlags
{
public
final
static
int
UNKNOWN
=
-
1
;
public
final
static
int
MISSING
=
0
;
public
final
static
int
PRELIMINARY
=
1
;
public
final
static
int
SIGNED
=
2
;
public
final
static
int
SYSTEM
=
3
;
public
final
static
int
PRIVILEGED
=
4
;
final
static
int
LAST
=
PRIVILEGED
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
SignedStateFlags
.
UNKNOWN
SignedStateFlags
.
MISSING
SignedStateFlags
.
PRELIMINARY
SignedStateFlags
.
SIGNED
SignedStateFlags
.
SYSTEM
SignedStateFlags
.
PRIVILEGED
}
)
interface
SignedState
{
}
public
static
class
BlocklistStateFlags
{
public
final
static
int
NOT_BLOCKED
=
0
;
public
final
static
int
SOFTBLOCKED
=
1
;
public
final
static
int
BLOCKED
=
2
;
public
final
static
int
OUTDATED
=
3
;
public
final
static
int
VULNERABLE_UPDATE_AVAILABLE
=
4
;
public
final
static
int
VULNERABLE_NO_UPDATE
=
5
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
BlocklistStateFlags
.
NOT_BLOCKED
BlocklistStateFlags
.
SOFTBLOCKED
BlocklistStateFlags
.
BLOCKED
BlocklistStateFlags
.
OUTDATED
BlocklistStateFlags
.
VULNERABLE_UPDATE_AVAILABLE
BlocklistStateFlags
.
VULNERABLE_NO_UPDATE
}
)
interface
BlocklistState
{
}
public
static
class
DisabledFlags
{
public
final
static
int
USER
=
1
<
<
1
;
public
final
static
int
BLOCKLIST
=
1
<
<
2
;
public
final
static
int
APP
=
1
<
<
3
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
DisabledFlags
.
USER
DisabledFlags
.
BLOCKLIST
DisabledFlags
.
APP
}
)
interface
EnabledFlags
{
}
public
class
MetaData
{
public
final
NonNull
Icon
icon
;
public
final
NonNull
String
[
]
permissions
;
public
final
NonNull
String
[
]
origins
;
public
final
Nullable
String
name
;
public
final
Nullable
String
description
;
public
final
NonNull
String
version
;
public
final
Nullable
String
creatorName
;
public
final
Nullable
String
creatorUrl
;
public
final
Nullable
String
homepageUrl
;
public
final
Nullable
String
optionsPageUrl
;
public
final
boolean
openOptionsPageInTab
;
public
final
boolean
isRecommended
;
public
final
BlocklistState
int
blocklistState
;
public
final
SignedState
int
signedState
;
public
final
EnabledFlags
int
disabledFlags
;
public
final
NonNull
String
baseUrl
;
public
final
boolean
allowedInPrivateBrowsing
;
public
final
boolean
enabled
;
protected
MetaData
(
)
{
icon
=
null
;
permissions
=
null
;
origins
=
null
;
name
=
null
;
description
=
null
;
version
=
null
;
creatorName
=
null
;
creatorUrl
=
null
;
homepageUrl
=
null
;
optionsPageUrl
=
null
;
openOptionsPageInTab
=
false
;
isRecommended
=
false
;
blocklistState
=
BlocklistStateFlags
.
NOT_BLOCKED
;
signedState
=
SignedStateFlags
.
UNKNOWN
;
disabledFlags
=
0
;
enabled
=
true
;
baseUrl
=
null
;
allowedInPrivateBrowsing
=
false
;
}
MetaData
(
final
GeckoBundle
bundle
)
{
permissions
=
bundle
.
getStringArray
(
"
promptPermissions
"
)
;
origins
=
bundle
.
getStringArray
(
"
origins
"
)
;
description
=
bundle
.
getString
(
"
description
"
)
;
version
=
bundle
.
getString
(
"
version
"
)
;
creatorName
=
bundle
.
getString
(
"
creatorName
"
)
;
creatorUrl
=
bundle
.
getString
(
"
creatorURL
"
)
;
homepageUrl
=
bundle
.
getString
(
"
homepageURL
"
)
;
name
=
bundle
.
getString
(
"
name
"
)
;
optionsPageUrl
=
bundle
.
getString
(
"
optionsPageURL
"
)
;
openOptionsPageInTab
=
bundle
.
getBoolean
(
"
openOptionsPageInTab
"
)
;
isRecommended
=
bundle
.
getBoolean
(
"
isRecommended
"
)
;
blocklistState
=
bundle
.
getInt
(
"
blocklistState
"
BlocklistStateFlags
.
NOT_BLOCKED
)
;
enabled
=
bundle
.
getBoolean
(
"
enabled
"
false
)
;
baseUrl
=
bundle
.
getString
(
"
baseURL
"
)
;
allowedInPrivateBrowsing
=
bundle
.
getBoolean
(
"
privateBrowsingAllowed
"
false
)
;
int
signedState
=
bundle
.
getInt
(
"
signedState
"
SignedStateFlags
.
UNKNOWN
)
;
if
(
signedState
<
=
SignedStateFlags
.
LAST
)
{
this
.
signedState
=
signedState
;
}
else
{
Log
.
e
(
LOGTAG
"
Unrecognized
signed
state
:
"
+
signedState
)
;
this
.
signedState
=
SignedStateFlags
.
UNKNOWN
;
}
int
disabledFlags
=
0
;
final
String
[
]
disabledFlagsString
=
bundle
.
getStringArray
(
"
disabledFlags
"
)
;
for
(
final
String
flag
:
disabledFlagsString
)
{
if
(
flag
.
equals
(
"
userDisabled
"
)
)
{
disabledFlags
|
=
DisabledFlags
.
USER
;
}
else
if
(
flag
.
equals
(
"
blocklistDisabled
"
)
)
{
disabledFlags
|
=
DisabledFlags
.
BLOCKLIST
;
}
else
if
(
flag
.
equals
(
"
appDisabled
"
)
)
{
disabledFlags
|
=
DisabledFlags
.
APP
;
}
else
{
Log
.
e
(
LOGTAG
"
Unrecognized
disabledFlag
state
:
"
+
flag
)
;
}
}
this
.
disabledFlags
=
disabledFlags
;
if
(
bundle
.
containsKey
(
"
icons
"
)
)
{
icon
=
new
Icon
(
bundle
.
getBundle
(
"
icons
"
)
)
;
}
else
{
icon
=
null
;
}
}
}
IntDef
(
flag
=
true
value
=
{
Context
.
NONE
Context
.
BOOKMARK
Context
.
BROWSER_ACTION
Context
.
PAGE_ACTION
Context
.
TAB
Context
.
TOOLS_MENU
}
)
interface
ContextFlags
{
}
static
class
Context
{
static
final
int
NONE
=
0
;
static
final
int
BOOKMARK
=
1
<
<
1
;
static
final
int
BROWSER_ACTION
=
1
<
<
2
;
static
final
int
PAGE_ACTION
=
1
<
<
3
;
static
final
int
TAB
=
1
<
<
4
;
static
final
int
TOOLS_MENU
=
1
<
<
5
;
}
static
class
Menu
{
final
NonNull
List
<
MenuItem
>
items
;
final
Nullable
Icon
icon
;
final
Nullable
String
title
;
final
NonNull
WebExtension
extension
;
Menu
(
final
NonNull
WebExtension
extension
final
GeckoBundle
bundle
)
{
this
.
extension
=
extension
;
title
=
bundle
.
getString
(
"
title
"
"
"
)
;
GeckoBundle
[
]
items
=
bundle
.
getBundleArray
(
"
items
"
)
;
this
.
items
=
new
ArrayList
<
>
(
)
;
if
(
items
!
=
null
)
{
for
(
GeckoBundle
item
:
items
)
{
this
.
items
.
add
(
new
MenuItem
(
this
.
extension
item
)
)
;
}
}
if
(
bundle
.
containsKey
(
"
icon
"
)
)
{
icon
=
new
Icon
(
bundle
.
getBundle
(
"
icon
"
)
)
;
}
else
{
icon
=
null
;
}
}
void
show
(
)
{
final
GeckoBundle
bundle
=
new
GeckoBundle
(
1
)
;
bundle
.
putString
(
"
extensionId
"
extension
.
id
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
WebExtension
:
MenuShow
"
bundle
)
;
}
void
hide
(
)
{
final
GeckoBundle
bundle
=
new
GeckoBundle
(
1
)
;
bundle
.
putString
(
"
extensionId
"
extension
.
id
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
WebExtension
:
MenuHide
"
bundle
)
;
}
}
static
class
MenuItem
{
IntDef
(
flag
=
false
value
=
{
MenuType
.
NORMAL
MenuType
.
CHECKBOX
MenuType
.
RADIO
MenuType
.
SEPARATOR
}
)
interface
Type
{
}
static
class
MenuType
{
static
final
int
NORMAL
=
0
;
static
final
int
CHECKBOX
=
1
;
static
final
int
RADIO
=
2
;
static
final
int
SEPARATOR
=
3
;
}
final
Nullable
List
<
MenuItem
>
children
;
final
Type
int
type
;
final
Nullable
String
id
;
final
boolean
visible
;
final
Nullable
String
title
;
final
boolean
checked
;
final
ContextFlags
int
contexts
;
final
Nullable
Icon
icon
;
final
WebExtension
mExtension
;
MenuItem
(
final
WebExtension
extension
final
GeckoBundle
bundle
)
{
title
=
bundle
.
getString
(
"
title
"
)
;
mExtension
=
extension
;
checked
=
bundle
.
getBoolean
(
"
checked
"
false
)
;
visible
=
bundle
.
getBoolean
(
"
visible
"
true
)
;
id
=
bundle
.
getString
(
"
id
"
)
;
contexts
=
bundle
.
getInt
(
"
contexts
"
)
;
type
=
bundle
.
getInt
(
"
type
"
)
;
children
=
new
ArrayList
<
>
(
)
;
if
(
bundle
.
containsKey
(
"
icon
"
)
)
{
icon
=
new
Icon
(
bundle
.
getBundle
(
"
icon
"
)
)
;
}
else
{
icon
=
null
;
}
}
void
click
(
)
{
final
GeckoBundle
bundle
=
new
GeckoBundle
(
2
)
;
bundle
.
putString
(
"
menuId
"
this
.
id
)
;
bundle
.
putString
(
"
extensionId
"
mExtension
.
id
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
WebExtension
:
MenuClick
"
bundle
)
;
}
}
interface
DownloadDelegate
{
AnyThread
default
GeckoResult
<
WebExtension
.
Download
>
onDownload
(
WebExtension
source
DownloadRequest
request
)
{
return
null
;
}
}
static
class
Download
{
final
String
id
;
private
Download
(
final
String
id
)
{
this
.
id
=
id
;
}
void
setDelegate
(
final
Delegate
delegate
)
{
}
GeckoResult
<
Void
>
update
(
final
DownloadInfo
data
)
{
return
null
;
}
interface
Delegate
{
default
GeckoResult
<
Void
>
onPause
(
WebExtension
source
WebExtension
.
Download
download
)
{
return
null
;
}
default
GeckoResult
<
Void
>
onResume
(
WebExtension
source
WebExtension
.
Download
download
)
{
return
null
;
}
default
GeckoResult
<
Void
>
onCancel
(
WebExtension
source
WebExtension
.
Download
download
)
{
return
null
;
}
default
GeckoResult
<
Void
>
onErase
(
WebExtension
source
WebExtension
.
Download
download
)
{
return
null
;
}
default
GeckoResult
<
Void
>
onOpen
(
WebExtension
source
WebExtension
.
Download
download
)
{
return
null
;
}
default
GeckoResult
<
Void
>
onRemoveFile
(
WebExtension
source
WebExtension
.
Download
download
)
{
return
null
;
}
}
interface
DownloadInfo
{
IntDef
(
flag
=
true
value
=
{
IN_PROGRESS
INTERRUPTED
COMPLETE
}
)
interface
DownloadStatusFlags
{
}
;
static
final
int
IN_PROGRESS
=
0
;
static
final
int
INTERRUPTED
=
1
;
static
final
int
COMPLETE
=
1
<
<
1
;
default
boolean
paused
(
)
{
return
false
;
}
default
Date
estimatedEndTime
(
)
{
return
null
;
}
default
boolean
canResume
(
)
{
return
false
;
}
default
long
bytesReceived
(
)
{
return
0
;
}
default
long
totalBytes
(
)
{
return
0
;
}
default
Date
endTime
(
)
{
return
null
;
}
default
boolean
fileExists
(
)
{
return
false
;
}
default
DownloadStatusFlags
int
status
(
)
{
return
0
;
}
}
}
static
final
class
DownloadRequest
{
final
WebRequest
request
;
final
GeckoWebExecutor
.
FetchFlags
int
downloadFlags
;
final
String
filename
;
final
ConflictActionFlags
int
conflictActionFlag
;
IntDef
(
flag
=
true
value
=
{
UNIQUIFY
OVERWRITE
PROMPT
}
)
interface
ConflictActionFlags
{
}
static
final
int
UNIQUIFY
=
0
;
static
final
int
OVERWRITE
=
1
;
static
final
int
PROMPT
=
1
<
<
1
;
private
DownloadRequest
(
final
DownloadRequest
.
Builder
builder
)
{
this
.
request
=
builder
.
mRequest
;
this
.
downloadFlags
=
builder
.
mDownloadFlags
;
this
.
filename
=
builder
.
mFilename
;
this
.
conflictActionFlag
=
builder
.
mConflictActionFlag
;
}
class
Builder
{
private
final
WebRequest
mRequest
;
private
GeckoWebExecutor
.
FetchFlags
int
mDownloadFlags
=
0
;
private
String
mFilename
=
null
;
private
ConflictActionFlags
int
mConflictActionFlag
=
UNIQUIFY
;
Builder
(
final
WebRequest
request
)
{
this
.
mRequest
=
request
;
}
Builder
downloadFlags
(
final
GeckoWebExecutor
.
FetchFlags
int
flags
)
{
this
.
mDownloadFlags
=
flags
;
return
this
;
}
Builder
filename
(
final
String
filename
)
{
this
.
mFilename
=
filename
;
return
this
;
}
Builder
conflictAction
(
final
ConflictActionFlags
int
conflictActionFlag
)
{
this
.
mConflictActionFlag
=
conflictActionFlag
;
return
this
;
}
DownloadRequest
build
(
)
{
return
new
DownloadRequest
(
this
)
;
}
}
}
}
