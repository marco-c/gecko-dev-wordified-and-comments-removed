package
org
.
mozilla
.
geckoview
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
public
class
LoginStorage
{
private
static
final
String
LOGTAG
=
"
LoginStorage
"
;
private
static
final
boolean
DEBUG
=
false
;
public
static
class
LoginEntry
{
private
static
final
String
GUID_KEY
=
"
guid
"
;
private
static
final
String
ORIGIN_KEY
=
"
origin
"
;
private
static
final
String
FORM_ACTION_ORIGIN_KEY
=
"
formActionOrigin
"
;
private
static
final
String
HTTP_REALM_KEY
=
"
httpRealm
"
;
private
static
final
String
USERNAME_KEY
=
"
username
"
;
private
static
final
String
PASSWORD_KEY
=
"
password
"
;
public
final
Nullable
String
guid
;
public
final
NonNull
String
origin
;
public
final
Nullable
String
formActionOrigin
;
public
final
Nullable
String
httpRealm
;
public
final
NonNull
String
username
;
public
final
NonNull
String
password
;
AnyThread
protected
LoginEntry
(
)
{
guid
=
null
;
origin
=
"
"
;
formActionOrigin
=
null
;
httpRealm
=
null
;
username
=
"
"
;
password
=
"
"
;
}
AnyThread
LoginEntry
(
final
NonNull
GeckoBundle
bundle
)
{
guid
=
bundle
.
getString
(
GUID_KEY
)
;
origin
=
bundle
.
getString
(
ORIGIN_KEY
)
;
formActionOrigin
=
bundle
.
getString
(
FORM_ACTION_ORIGIN_KEY
)
;
httpRealm
=
bundle
.
getString
(
HTTP_REALM_KEY
)
;
username
=
bundle
.
getString
(
USERNAME_KEY
)
;
password
=
bundle
.
getString
(
PASSWORD_KEY
)
;
}
Override
AnyThread
public
String
toString
(
)
{
StringBuilder
builder
=
new
StringBuilder
(
"
LoginEntry
{
"
)
;
builder
.
append
(
"
guid
=
"
)
.
append
(
guid
)
.
append
(
"
origin
=
"
)
.
append
(
origin
)
.
append
(
"
formActionOrigin
=
"
)
.
append
(
formActionOrigin
)
.
append
(
"
httpRealm
=
"
)
.
append
(
httpRealm
)
.
append
(
"
username
=
"
)
.
append
(
username
)
.
append
(
"
password
=
"
)
.
append
(
password
)
.
append
(
"
}
"
)
;
return
builder
.
toString
(
)
;
}
AnyThread
NonNull
GeckoBundle
toBundle
(
)
{
final
GeckoBundle
bundle
=
new
GeckoBundle
(
6
)
;
bundle
.
putString
(
GUID_KEY
guid
)
;
bundle
.
putString
(
ORIGIN_KEY
origin
)
;
bundle
.
putString
(
FORM_ACTION_ORIGIN_KEY
formActionOrigin
)
;
bundle
.
putString
(
HTTP_REALM_KEY
httpRealm
)
;
bundle
.
putString
(
USERNAME_KEY
username
)
;
bundle
.
putString
(
PASSWORD_KEY
password
)
;
return
bundle
;
}
public
static
class
Builder
{
private
final
GeckoBundle
mBundle
;
AnyThread
Builder
(
final
NonNull
GeckoBundle
bundle
)
{
mBundle
=
new
GeckoBundle
(
bundle
)
;
}
AnyThread
public
Builder
(
)
{
mBundle
=
new
GeckoBundle
(
6
)
;
}
AnyThread
public
NonNull
LoginEntry
build
(
)
{
return
new
LoginEntry
(
mBundle
)
;
}
AnyThread
public
NonNull
Builder
guid
(
final
Nullable
String
guid
)
{
mBundle
.
putString
(
GUID_KEY
guid
)
;
return
this
;
}
AnyThread
public
NonNull
Builder
origin
(
final
NonNull
String
origin
)
{
mBundle
.
putString
(
ORIGIN_KEY
origin
)
;
return
this
;
}
AnyThread
public
NonNull
Builder
formActionOrigin
(
final
Nullable
String
formActionOrigin
)
{
mBundle
.
putString
(
FORM_ACTION_ORIGIN_KEY
formActionOrigin
)
;
return
this
;
}
AnyThread
public
NonNull
Builder
httpRealm
(
final
Nullable
String
httpRealm
)
{
mBundle
.
putString
(
HTTP_REALM_KEY
httpRealm
)
;
return
this
;
}
AnyThread
public
NonNull
Builder
username
(
final
NonNull
String
username
)
{
mBundle
.
putString
(
USERNAME_KEY
username
)
;
return
this
;
}
AnyThread
public
NonNull
Builder
password
(
final
NonNull
String
password
)
{
mBundle
.
putString
(
PASSWORD_KEY
password
)
;
return
this
;
}
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
UsedField
.
PASSWORD
}
)
interface
LSUsedField
{
}
public
static
class
UsedField
{
public
static
final
int
PASSWORD
=
1
;
}
public
interface
Delegate
{
UiThread
default
Nullable
GeckoResult
<
LoginEntry
[
]
>
onLoginFetch
(
NonNull
String
domain
)
{
return
null
;
}
UiThread
default
void
onLoginSave
(
NonNull
LoginEntry
login
)
{
}
UiThread
default
void
onLoginUsed
(
NonNull
LoginEntry
login
LSUsedField
int
usedFields
)
{
}
}
final
static
class
Proxy
implements
BundleEventListener
{
private
static
final
String
LOGTAG
=
"
LoginStorageProxy
"
;
private
static
final
String
FETCH_EVENT
=
"
GeckoView
:
LoginStorage
:
Fetch
"
;
private
static
final
String
SAVE_EVENT
=
"
GeckoView
:
LoginStorage
:
Save
"
;
private
static
final
String
USED_EVENT
=
"
GeckoView
:
LoginStorage
:
Used
"
;
private
Nullable
Delegate
mDelegate
;
public
Proxy
(
)
{
}
private
void
registerListener
(
)
{
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
FETCH_EVENT
SAVE_EVENT
USED_EVENT
)
;
}
private
void
unregisterListener
(
)
{
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
FETCH_EVENT
SAVE_EVENT
USED_EVENT
)
;
}
public
synchronized
void
setDelegate
(
final
Nullable
Delegate
delegate
)
{
if
(
mDelegate
=
=
null
&
&
delegate
!
=
null
)
{
registerListener
(
)
;
}
else
if
(
mDelegate
!
=
null
&
&
delegate
=
=
null
)
{
unregisterListener
(
)
;
}
mDelegate
=
delegate
;
}
public
synchronized
Nullable
Delegate
getDelegate
(
)
{
return
mDelegate
;
}
Override
public
synchronized
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
handleMessage
"
+
event
)
;
}
if
(
mDelegate
=
=
null
)
{
if
(
callback
!
=
null
)
{
callback
.
sendError
(
"
No
LoginStorage
delegate
attached
"
)
;
}
return
;
}
if
(
FETCH_EVENT
.
equals
(
event
)
)
{
final
String
domain
=
message
.
getString
(
"
domain
"
)
;
final
GeckoResult
<
LoginStorage
.
LoginEntry
[
]
>
result
=
mDelegate
.
onLoginFetch
(
domain
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
new
GeckoBundle
[
0
]
)
;
return
;
}
result
.
accept
(
logins
-
>
{
if
(
logins
=
=
null
)
{
callback
.
sendSuccess
(
new
GeckoBundle
[
0
]
)
;
}
final
GeckoBundle
[
]
loginBundles
=
new
GeckoBundle
[
logins
.
length
]
;
for
(
int
i
=
0
;
i
<
logins
.
length
;
+
+
i
)
{
loginBundles
[
i
]
=
logins
[
i
]
.
toBundle
(
)
;
}
callback
.
sendSuccess
(
loginBundles
)
;
}
exception
-
>
callback
.
sendError
(
exception
.
getMessage
(
)
)
)
;
}
else
if
(
SAVE_EVENT
.
equals
(
event
)
)
{
final
GeckoBundle
loginBundle
=
message
.
getBundle
(
"
login
"
)
;
final
LoginEntry
login
=
new
LoginEntry
(
loginBundle
)
;
mDelegate
.
onLoginSave
(
login
)
;
}
else
if
(
USED_EVENT
.
equals
(
event
)
)
{
final
GeckoBundle
loginBundle
=
message
.
getBundle
(
"
login
"
)
;
final
LoginEntry
login
=
new
LoginEntry
(
loginBundle
)
;
final
int
fields
=
message
.
getInt
(
"
usedFields
"
)
;
mDelegate
.
onLoginUsed
(
login
fields
)
;
}
}
}
}
