package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
graphics
.
Bitmap
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
util
.
Log
;
import
java
.
util
.
EnumSet
;
import
java
.
util
.
Set
;
UiThread
public
final
class
DynamicToolbarAnimator
{
private
static
final
String
LOGTAG
=
"
DynamicToolbarAnimator
"
;
AnyThread
public
static
enum
PinReason
{
DISABLED
(
0
)
RELAYOUT
(
1
)
ACTION_MODE
(
2
)
FULL_SCREEN
(
3
)
CARET_DRAG
(
4
)
PAGE_LOADING
(
5
)
CUSTOM_TAB
(
6
)
;
public
final
int
value
;
PinReason
(
final
int
aValue
)
{
value
=
aValue
;
}
}
public
interface
ToolbarChromeProxy
{
UiThread
Nullable
default
Bitmap
getBitmapOfToolbarChrome
(
)
{
return
null
;
}
UiThread
default
boolean
isToolbarChromeVisible
(
)
{
return
false
;
}
UiThread
default
void
toggleToolbarChrome
(
boolean
aShow
)
{
}
}
private
final
Set
<
PinReason
>
mPinFlags
=
EnumSet
.
noneOf
(
PinReason
.
class
)
;
private
final
GeckoSession
mTarget
;
private
final
GeckoSession
.
Compositor
mCompositor
;
private
ToolbarChromeProxy
mToolbarChromeProxy
;
private
int
mMaxToolbarHeight
;
DynamicToolbarAnimator
(
final
GeckoSession
aTarget
)
{
mTarget
=
aTarget
;
mCompositor
=
aTarget
.
mCompositor
;
}
public
Nullable
ToolbarChromeProxy
getToolbarChromeProxy
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mToolbarChromeProxy
;
}
public
void
setToolbarChromeProxy
(
Nullable
final
ToolbarChromeProxy
aToolbarChromeProxy
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mToolbarChromeProxy
=
aToolbarChromeProxy
;
}
public
void
setMaxToolbarHeight
(
final
int
maxToolbarHeight
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mMaxToolbarHeight
=
maxToolbarHeight
;
if
(
mCompositor
.
isReady
(
)
)
{
mCompositor
.
setMaxToolbarHeight
(
mMaxToolbarHeight
)
;
}
}
int
getCurrentToolbarHeight
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
(
mToolbarChromeProxy
!
=
null
)
&
&
mToolbarChromeProxy
.
isToolbarChromeVisible
(
)
)
{
return
mMaxToolbarHeight
;
}
return
0
;
}
public
boolean
isPinned
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
!
mPinFlags
.
isEmpty
(
)
;
}
public
boolean
isPinnedBy
(
NonNull
final
PinReason
reason
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mPinFlags
.
contains
(
reason
)
;
}
public
void
setPinned
(
final
boolean
pinned
final
NonNull
PinReason
reason
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
pinned
!
=
mPinFlags
.
contains
(
reason
)
&
&
mCompositor
.
isReady
(
)
)
{
mCompositor
.
setPinned
(
pinned
reason
.
value
)
;
}
if
(
pinned
)
{
mPinFlags
.
add
(
reason
)
;
}
else
{
mPinFlags
.
remove
(
reason
)
;
}
}
public
void
showToolbar
(
final
boolean
immediately
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mCompositor
.
isReady
(
)
)
{
mCompositor
.
sendToolbarAnimatorMessage
(
immediately
?
GeckoSession
.
REQUEST_SHOW_TOOLBAR_IMMEDIATELY
:
GeckoSession
.
REQUEST_SHOW_TOOLBAR_ANIMATED
)
;
}
}
public
void
hideToolbar
(
final
boolean
immediately
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mCompositor
.
isReady
(
)
)
{
mCompositor
.
sendToolbarAnimatorMessage
(
immediately
?
GeckoSession
.
REQUEST_HIDE_TOOLBAR_IMMEDIATELY
:
GeckoSession
.
REQUEST_HIDE_TOOLBAR_ANIMATED
)
;
}
}
void
onCompositorReady
(
)
{
mCompositor
.
setMaxToolbarHeight
(
mMaxToolbarHeight
)
;
if
(
(
mToolbarChromeProxy
!
=
null
)
&
&
mToolbarChromeProxy
.
isToolbarChromeVisible
(
)
)
{
mCompositor
.
sendToolbarAnimatorMessage
(
GeckoSession
.
REQUEST_SHOW_TOOLBAR_IMMEDIATELY
)
;
}
else
{
mCompositor
.
sendToolbarAnimatorMessage
(
GeckoSession
.
REQUEST_HIDE_TOOLBAR_IMMEDIATELY
)
;
}
for
(
final
PinReason
reason
:
PinReason
.
values
(
)
)
{
mCompositor
.
setPinned
(
mPinFlags
.
contains
(
reason
)
reason
.
value
)
;
}
}
void
handleToolbarAnimatorMessage
(
final
int
message
)
{
if
(
mToolbarChromeProxy
=
=
null
|
|
!
mCompositor
.
isReady
(
)
)
{
return
;
}
switch
(
message
)
{
case
GeckoSession
.
STATIC_TOOLBAR_NEEDS_UPDATE
:
{
final
Bitmap
bm
=
mToolbarChromeProxy
.
getBitmapOfToolbarChrome
(
)
;
if
(
bm
=
=
null
)
{
mCompositor
.
sendToolbarAnimatorMessage
(
GeckoSession
.
TOOLBAR_SNAPSHOT_FAILED
)
;
break
;
}
try
{
final
int
width
=
bm
.
getWidth
(
)
;
final
int
height
=
bm
.
getHeight
(
)
;
final
int
[
]
pixels
=
new
int
[
bm
.
getByteCount
(
)
/
4
]
;
bm
.
getPixels
(
pixels
0
width
0
0
width
height
)
;
mCompositor
.
sendToolbarPixelsToCompositor
(
width
height
pixels
)
;
}
catch
(
final
Throwable
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
get
toolbar
pixels
"
e
)
;
mCompositor
.
sendToolbarAnimatorMessage
(
GeckoSession
.
TOOLBAR_SNAPSHOT_FAILED
)
;
}
break
;
}
case
GeckoSession
.
STATIC_TOOLBAR_READY
:
{
mToolbarChromeProxy
.
toggleToolbarChrome
(
false
)
;
mCompositor
.
sendToolbarAnimatorMessage
(
GeckoSession
.
TOOLBAR_HIDDEN
)
;
break
;
}
case
GeckoSession
.
TOOLBAR_SHOW
:
{
mToolbarChromeProxy
.
toggleToolbarChrome
(
true
)
;
mCompositor
.
sendToolbarAnimatorMessage
(
GeckoSession
.
TOOLBAR_VISIBLE
)
;
break
;
}
default
:
Log
.
e
(
LOGTAG
"
Unhandled
Toolbar
Animator
Message
:
"
+
message
)
;
break
;
}
}
}
