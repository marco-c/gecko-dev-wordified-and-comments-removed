package
org
.
mozilla
.
gecko
.
sqlite
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
import
org
.
mozilla
.
gecko
.
annotation
.
JNITarget
;
import
android
.
database
.
AbstractCursor
;
import
android
.
database
.
CursorIndexOutOfBoundsException
;
import
android
.
util
.
Log
;
public
class
MatrixBlobCursor
extends
AbstractCursor
{
private
static
final
String
LOGTAG
=
"
GeckoMatrixCursor
"
;
private
final
String
[
]
mColumnNames
;
private
final
int
mColumnCount
;
private
int
mRowCount
;
private
Throwable
mAllocationStack
;
Object
[
]
mData
;
JNITarget
public
MatrixBlobCursor
(
final
String
[
]
columnNames
final
int
initialCapacity
)
{
mColumnNames
=
columnNames
;
mColumnCount
=
columnNames
.
length
;
int
capacity
=
initialCapacity
;
if
(
capacity
<
1
)
{
capacity
=
1
;
}
mData
=
new
Object
[
mColumnCount
*
capacity
]
;
mAllocationStack
=
new
Throwable
(
"
allocationStack
"
)
;
}
JNITarget
public
MatrixBlobCursor
(
final
String
[
]
columnNames
)
{
this
(
columnNames
16
)
;
}
public
void
close
(
)
{
mAllocationStack
=
null
;
mData
=
null
;
super
.
close
(
)
;
}
protected
Object
get
(
final
int
column
)
{
if
(
column
<
0
|
|
column
>
=
mColumnCount
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
Requested
column
:
"
+
column
+
"
#
of
columns
:
"
+
mColumnCount
)
;
}
if
(
mPos
<
0
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
Before
first
row
.
"
)
;
}
if
(
mPos
>
=
mRowCount
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
After
last
row
.
"
)
;
}
return
mData
[
mPos
*
mColumnCount
+
column
]
;
}
public
RowBuilder
newRow
(
)
{
mRowCount
+
+
;
int
endIndex
=
mRowCount
*
mColumnCount
;
ensureCapacity
(
endIndex
)
;
int
start
=
endIndex
-
mColumnCount
;
return
new
RowBuilder
(
start
endIndex
)
;
}
JNITarget
public
void
addRow
(
final
Object
[
]
columnValues
)
{
if
(
columnValues
.
length
!
=
mColumnCount
)
{
throw
new
IllegalArgumentException
(
"
columnNames
.
length
=
"
+
mColumnCount
+
"
columnValues
.
length
=
"
+
columnValues
.
length
)
;
}
int
start
=
mRowCount
+
+
*
mColumnCount
;
ensureCapacity
(
start
+
mColumnCount
)
;
System
.
arraycopy
(
columnValues
0
mData
start
mColumnCount
)
;
}
JNITarget
public
void
addRow
(
final
Iterable
<
?
>
columnValues
)
{
final
int
start
=
mRowCount
*
mColumnCount
;
if
(
columnValues
instanceof
ArrayList
<
?
>
)
{
addRow
(
(
ArrayList
<
?
>
)
columnValues
start
)
;
return
;
}
final
int
end
=
start
+
mColumnCount
;
int
current
=
start
;
ensureCapacity
(
end
)
;
final
Object
[
]
localData
=
mData
;
for
(
Object
columnValue
:
columnValues
)
{
if
(
current
=
=
end
)
{
throw
new
IllegalArgumentException
(
"
columnValues
.
size
(
)
>
columnNames
.
length
"
)
;
}
localData
[
current
+
+
]
=
columnValue
;
}
if
(
current
!
=
end
)
{
throw
new
IllegalArgumentException
(
"
columnValues
.
size
(
)
<
columnNames
.
length
"
)
;
}
mRowCount
+
+
;
}
JNITarget
private
void
addRow
(
final
ArrayList
<
?
>
columnValues
final
int
start
)
{
final
int
size
=
columnValues
.
size
(
)
;
if
(
size
!
=
mColumnCount
)
{
throw
new
IllegalArgumentException
(
"
columnNames
.
length
=
"
+
mColumnCount
+
"
columnValues
.
size
(
)
=
"
+
size
)
;
}
final
int
end
=
start
+
mColumnCount
;
ensureCapacity
(
end
)
;
final
Object
[
]
localData
=
mData
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
localData
[
start
+
i
]
=
columnValues
.
get
(
i
)
;
}
mRowCount
+
+
;
}
private
void
ensureCapacity
(
final
int
size
)
{
if
(
size
<
=
mData
.
length
)
{
return
;
}
final
Object
[
]
oldData
=
mData
;
mData
=
new
Object
[
Math
.
max
(
size
mData
.
length
*
2
)
]
;
System
.
arraycopy
(
oldData
0
mData
0
oldData
.
length
)
;
}
public
class
RowBuilder
{
private
int
mIndex
;
private
final
int
mEndIndex
;
RowBuilder
(
final
int
index
final
int
endIndex
)
{
this
.
mIndex
=
index
;
this
.
mEndIndex
=
endIndex
;
}
public
RowBuilder
add
(
final
Object
columnValue
)
{
if
(
mIndex
=
=
mEndIndex
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
No
more
columns
left
.
"
)
;
}
mData
[
mIndex
+
+
]
=
columnValue
;
return
this
;
}
}
public
void
set
(
final
int
column
final
Object
value
)
{
if
(
column
<
0
|
|
column
>
=
mColumnCount
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
Requested
column
:
"
+
column
+
"
#
of
columns
:
"
+
mColumnCount
)
;
}
if
(
mPos
<
0
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
Before
first
row
.
"
)
;
}
if
(
mPos
>
=
mRowCount
)
{
throw
new
CursorIndexOutOfBoundsException
(
"
After
last
row
.
"
)
;
}
mData
[
mPos
*
mColumnCount
+
column
]
=
value
;
}
Override
public
int
getCount
(
)
{
return
mRowCount
;
}
Override
public
String
[
]
getColumnNames
(
)
{
return
mColumnNames
;
}
Override
public
String
getString
(
final
int
column
)
{
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
null
;
return
value
.
toString
(
)
;
}
Override
public
short
getShort
(
final
int
column
)
{
final
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
0
;
if
(
value
instanceof
Number
)
return
(
(
Number
)
value
)
.
shortValue
(
)
;
return
Short
.
parseShort
(
value
.
toString
(
)
)
;
}
Override
public
int
getInt
(
final
int
column
)
{
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
0
;
if
(
value
instanceof
Number
)
return
(
(
Number
)
value
)
.
intValue
(
)
;
return
Integer
.
parseInt
(
value
.
toString
(
)
)
;
}
Override
public
long
getLong
(
final
int
column
)
{
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
0
;
if
(
value
instanceof
Number
)
return
(
(
Number
)
value
)
.
longValue
(
)
;
return
Long
.
parseLong
(
value
.
toString
(
)
)
;
}
Override
public
float
getFloat
(
final
int
column
)
{
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
0
.
0f
;
if
(
value
instanceof
Number
)
return
(
(
Number
)
value
)
.
floatValue
(
)
;
return
Float
.
parseFloat
(
value
.
toString
(
)
)
;
}
Override
public
double
getDouble
(
final
int
column
)
{
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
0
.
0d
;
if
(
value
instanceof
Number
)
return
(
(
Number
)
value
)
.
doubleValue
(
)
;
return
Double
.
parseDouble
(
value
.
toString
(
)
)
;
}
Override
public
byte
[
]
getBlob
(
final
int
column
)
{
Object
value
=
get
(
column
)
;
if
(
value
=
=
null
)
return
null
;
if
(
value
instanceof
byte
[
]
)
{
return
(
byte
[
]
)
value
;
}
if
(
value
instanceof
ByteBuffer
)
{
final
ByteBuffer
bytes
=
(
ByteBuffer
)
value
;
byte
[
]
byteArray
=
new
byte
[
bytes
.
remaining
(
)
]
;
bytes
.
get
(
byteArray
)
;
return
byteArray
;
}
throw
new
UnsupportedOperationException
(
"
BLOB
Object
not
of
known
type
"
)
;
}
Override
public
boolean
isNull
(
final
int
column
)
{
return
get
(
column
)
=
=
null
;
}
Override
protected
void
finalize
(
)
{
if
(
!
isClosed
(
)
)
{
Log
.
e
(
LOGTAG
"
Cursor
finalized
without
being
closed
"
mAllocationStack
)
;
}
super
.
finalize
(
)
;
}
}
