package
org
.
mozilla
.
gecko
;
import
java
.
io
.
File
;
import
java
.
net
.
URLConnection
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Set
;
import
org
.
mozilla
.
gecko
.
annotation
.
ReflectionTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
android
.
app
.
Activity
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
res
.
Resources
;
import
android
.
database
.
Cursor
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Binder
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Handler
;
import
android
.
os
.
IBinder
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
public
class
GeckoView
extends
LayerView
{
private
static
final
String
DEFAULT_SHARED_PREFERENCES_FILE
=
"
GeckoView
"
;
private
static
final
String
LOGTAG
=
"
GeckoView
"
;
private
static
final
boolean
DEBUG
=
false
;
enum
State
implements
NativeQueue
.
State
{
WrapForJNI
INITIAL
(
0
)
WrapForJNI
READY
(
1
)
;
private
final
int
mRank
;
private
State
(
int
rank
)
{
mRank
=
rank
;
}
Override
public
boolean
is
(
final
NativeQueue
.
State
other
)
{
return
this
=
=
other
;
}
Override
public
boolean
isAtLeast
(
final
NativeQueue
.
State
other
)
{
return
(
other
instanceof
State
)
&
&
mRank
>
=
(
(
State
)
other
)
.
mRank
;
}
}
static
{
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
Prompt
"
.
equals
(
event
)
)
{
handlePromptEvent
(
null
message
callback
)
;
}
}
}
"
GeckoView
:
Prompt
"
)
;
}
private
static
PromptDelegate
sDefaultPromptDelegate
;
private
final
NativeQueue
mNativeQueue
=
new
NativeQueue
(
State
.
INITIAL
State
.
READY
)
;
private
final
EventDispatcher
mEventDispatcher
=
new
EventDispatcher
(
mNativeQueue
)
;
private
final
GeckoViewHandler
<
ContentListener
>
mContentHandler
=
new
GeckoViewHandler
<
ContentListener
>
(
"
GeckoViewContent
"
this
new
String
[
]
{
"
GeckoView
:
ContextMenu
"
"
GeckoView
:
DOMTitleChanged
"
"
GeckoView
:
FullScreenEnter
"
"
GeckoView
:
FullScreenExit
"
}
)
{
Override
public
void
handleMessage
(
final
ContentListener
listener
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ContextMenu
"
.
equals
(
event
)
)
{
listener
.
onContextMenu
(
GeckoView
.
this
message
.
getInt
(
"
screenX
"
)
message
.
getInt
(
"
screenY
"
)
message
.
getString
(
"
uri
"
)
message
.
getString
(
"
elementSrc
"
)
)
;
}
else
if
(
"
GeckoView
:
DOMTitleChanged
"
.
equals
(
event
)
)
{
listener
.
onTitleChange
(
GeckoView
.
this
message
.
getString
(
"
title
"
)
)
;
}
else
if
(
"
GeckoView
:
FullScreenEnter
"
.
equals
(
event
)
)
{
listener
.
onFullScreen
(
GeckoView
.
this
true
)
;
}
else
if
(
"
GeckoView
:
FullScreenExit
"
.
equals
(
event
)
)
{
listener
.
onFullScreen
(
GeckoView
.
this
false
)
;
}
}
}
;
private
final
GeckoViewHandler
<
NavigationListener
>
mNavigationHandler
=
new
GeckoViewHandler
<
NavigationListener
>
(
"
GeckoViewNavigation
"
this
new
String
[
]
{
"
GeckoView
:
LocationChange
"
}
)
{
Override
public
void
handleMessage
(
final
NavigationListener
listener
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
LocationChange
"
.
equals
(
event
)
)
{
listener
.
onLocationChange
(
GeckoView
.
this
message
.
getString
(
"
uri
"
)
)
;
listener
.
onCanGoBack
(
GeckoView
.
this
message
.
getBoolean
(
"
canGoBack
"
)
)
;
listener
.
onCanGoForward
(
GeckoView
.
this
message
.
getBoolean
(
"
canGoForward
"
)
)
;
}
}
}
;
private
final
GeckoViewHandler
<
ProgressListener
>
mProgressHandler
=
new
GeckoViewHandler
<
ProgressListener
>
(
"
GeckoViewProgress
"
this
new
String
[
]
{
"
GeckoView
:
PageStart
"
"
GeckoView
:
PageStop
"
"
GeckoView
:
SecurityChanged
"
}
)
{
Override
public
void
handleMessage
(
final
ProgressListener
listener
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
PageStart
"
.
equals
(
event
)
)
{
listener
.
onPageStart
(
GeckoView
.
this
message
.
getString
(
"
uri
"
)
)
;
}
else
if
(
"
GeckoView
:
PageStop
"
.
equals
(
event
)
)
{
listener
.
onPageStop
(
GeckoView
.
this
message
.
getBoolean
(
"
success
"
)
)
;
}
else
if
(
"
GeckoView
:
SecurityChanged
"
.
equals
(
event
)
)
{
final
int
state
=
message
.
getInt
(
"
status
"
)
&
ProgressListener
.
STATE_ALL
;
final
GeckoBundle
identity
=
message
.
getBundle
(
"
identity
"
)
;
listener
.
onSecurityChange
(
GeckoView
.
this
state
identity
)
;
}
}
}
;
private
final
GeckoViewHandler
<
ScrollListener
>
mScrollHandler
=
new
GeckoViewHandler
<
ScrollListener
>
(
"
GeckoViewScroll
"
this
new
String
[
]
{
"
GeckoView
:
ScrollChanged
"
}
)
{
Override
public
void
handleMessage
(
final
ScrollListener
listener
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ScrollChanged
"
.
equals
(
event
)
)
{
listener
.
onScrollChanged
(
GeckoView
.
this
message
.
getInt
(
"
scrollX
"
)
message
.
getInt
(
"
scrollY
"
)
)
;
}
}
}
;
private
final
GeckoViewHandler
<
PermissionDelegate
>
mPermissionHandler
=
new
GeckoViewHandler
<
PermissionDelegate
>
(
"
GeckoViewPermission
"
this
new
String
[
]
{
"
GeckoView
:
AndroidPermission
"
"
GeckoView
:
ContentPermission
"
"
GeckoView
:
MediaPermission
"
}
true
)
{
Override
public
void
handleMessage
(
final
PermissionDelegate
listener
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
listener
=
=
null
)
{
callback
.
sendSuccess
(
false
)
;
return
;
}
if
(
"
GeckoView
:
AndroidPermission
"
.
equals
(
event
)
)
{
listener
.
requestAndroidPermissions
(
GeckoView
.
this
message
.
getStringArray
(
"
perms
"
)
new
PermissionCallback
(
"
android
"
callback
)
)
;
}
else
if
(
"
GeckoView
:
ContentPermission
"
.
equals
(
event
)
)
{
final
String
type
=
message
.
getString
(
"
perm
"
)
;
listener
.
requestContentPermission
(
GeckoView
.
this
message
.
getString
(
"
uri
"
)
type
message
.
getString
(
"
access
"
)
new
PermissionCallback
(
type
callback
)
)
;
}
else
if
(
"
GeckoView
:
MediaPermission
"
.
equals
(
event
)
)
{
listener
.
requestMediaPermission
(
GeckoView
.
this
message
.
getString
(
"
uri
"
)
message
.
getBundleArray
(
"
video
"
)
message
.
getBundleArray
(
"
audio
"
)
new
PermissionCallback
(
"
media
"
callback
)
)
;
}
}
}
;
private
static
class
PermissionCallback
implements
PermissionDelegate
.
Callback
PermissionDelegate
.
MediaCallback
{
private
final
String
mType
;
private
EventCallback
mCallback
;
public
PermissionCallback
(
final
String
type
final
EventCallback
callback
)
{
mType
=
type
;
mCallback
=
callback
;
}
private
void
submit
(
final
Object
response
)
{
if
(
mCallback
!
=
null
)
{
mCallback
.
sendSuccess
(
response
)
;
mCallback
=
null
;
}
}
Override
public
void
grant
(
)
{
if
(
"
media
"
.
equals
(
mType
)
)
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
true
)
;
}
Override
public
void
reject
(
)
{
submit
(
false
)
;
}
Override
public
void
grant
(
final
String
video
final
String
audio
)
{
if
(
!
"
media
"
.
equals
(
mType
)
)
{
throw
new
UnsupportedOperationException
(
)
;
}
final
GeckoBundle
response
=
new
GeckoBundle
(
2
)
;
response
.
putString
(
"
video
"
video
)
;
response
.
putString
(
"
audio
"
audio
)
;
submit
(
response
)
;
}
Override
public
void
grant
(
final
GeckoBundle
video
final
GeckoBundle
audio
)
{
grant
(
video
!
=
null
?
video
.
getString
(
"
id
"
)
:
null
audio
!
=
null
?
audio
.
getString
(
"
id
"
)
:
null
)
;
}
}
public
PermissionDelegate
getPermissionDelegate
(
)
{
return
mPermissionHandler
.
getListener
(
)
;
}
public
void
setPermissionDelegate
(
final
PermissionDelegate
delegate
)
{
mPermissionHandler
.
setListener
(
delegate
this
)
;
}
private
PromptDelegate
mPromptDelegate
;
private
InputConnectionListener
mInputConnectionListener
;
private
GeckoViewSettings
mSettings
;
protected
String
mChromeUri
;
protected
int
mScreenId
=
0
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
protected
static
final
class
Window
extends
JNIObject
{
WrapForJNI
(
skip
=
true
)
public
final
String
chromeUri
;
WrapForJNI
(
skip
=
true
)
NativeQueue
mNativeQueue
;
WrapForJNI
(
skip
=
true
)
Window
(
final
String
chromeUri
final
NativeQueue
queue
)
{
this
.
chromeUri
=
chromeUri
;
mNativeQueue
=
queue
;
}
static
native
void
open
(
Window
instance
GeckoView
view
Object
compositor
EventDispatcher
dispatcher
String
chromeUri
GeckoBundle
settings
int
screenId
boolean
privateMode
)
;
Override
protected
native
void
disposeNative
(
)
;
native
void
close
(
)
;
native
void
reattach
(
GeckoView
view
Object
compositor
EventDispatcher
dispatcher
)
;
native
void
loadUri
(
String
uri
int
flags
)
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
synchronized
void
setState
(
final
State
newState
)
{
if
(
mNativeQueue
.
getState
(
)
!
=
State
.
READY
&
&
newState
=
=
State
.
READY
)
{
Log
.
i
(
LOGTAG
"
zerdatime
"
+
SystemClock
.
elapsedRealtime
(
)
+
"
-
chrome
startup
finished
"
)
;
}
mNativeQueue
.
setState
(
newState
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
synchronized
void
onReattach
(
final
GeckoView
view
)
{
if
(
view
.
mNativeQueue
=
=
mNativeQueue
)
{
return
;
}
view
.
mNativeQueue
.
setState
(
mNativeQueue
.
getState
(
)
)
;
mNativeQueue
=
view
.
mNativeQueue
;
}
}
private
static
class
StateBinder
extends
Binder
implements
Parcelable
{
public
final
Parcelable
superState
;
public
final
Window
window
;
public
StateBinder
(
Parcelable
superState
Window
window
)
{
this
.
superState
=
superState
;
this
.
window
=
window
;
}
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
Parcel
out
int
flags
)
{
out
.
writeParcelable
(
superState
flags
)
;
out
.
writeStrongBinder
(
this
)
;
}
ReflectionTarget
public
static
final
Parcelable
.
Creator
<
StateBinder
>
CREATOR
=
new
Parcelable
.
Creator
<
StateBinder
>
(
)
{
Override
public
StateBinder
createFromParcel
(
Parcel
in
)
{
final
Parcelable
superState
=
in
.
readParcelable
(
null
)
;
final
IBinder
binder
=
in
.
readStrongBinder
(
)
;
if
(
binder
instanceof
StateBinder
)
{
return
(
StateBinder
)
binder
;
}
return
new
StateBinder
(
superState
null
)
;
}
Override
public
StateBinder
[
]
newArray
(
int
size
)
{
return
new
StateBinder
[
size
]
;
}
}
;
}
private
class
Listener
implements
BundleEventListener
{
void
registerListeners
(
)
{
getEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
GeckoView
:
Prompt
"
null
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
handleMessage
:
event
=
"
+
event
)
;
}
if
(
"
GeckoView
:
Prompt
"
.
equals
(
event
)
)
{
handlePromptEvent
(
GeckoView
.
this
message
callback
)
;
}
}
}
protected
Window
mWindow
;
private
boolean
mStateSaved
;
private
final
Listener
mListener
=
new
Listener
(
)
;
public
GeckoView
(
Context
context
)
{
super
(
context
)
;
init
(
context
null
)
;
}
public
GeckoView
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
init
(
context
null
)
;
}
public
GeckoView
(
Context
context
final
GeckoViewSettings
settings
)
{
super
(
context
)
;
final
GeckoViewSettings
newSettings
=
new
GeckoViewSettings
(
settings
getEventDispatcher
(
)
)
;
init
(
context
settings
)
;
}
public
GeckoView
(
Context
context
AttributeSet
attrs
final
GeckoViewSettings
settings
)
{
super
(
context
attrs
)
;
final
GeckoViewSettings
newSettings
=
new
GeckoViewSettings
(
settings
getEventDispatcher
(
)
)
;
init
(
context
newSettings
)
;
}
public
static
void
preload
(
final
Context
context
)
{
preload
(
context
null
)
;
}
public
static
void
preload
(
final
Context
context
final
String
geckoArgs
)
{
final
Context
appContext
=
context
.
getApplicationContext
(
)
;
if
(
GeckoAppShell
.
getApplicationContext
(
)
=
=
null
)
{
GeckoAppShell
.
setApplicationContext
(
appContext
)
;
}
if
(
GeckoThread
.
initMainProcess
(
GeckoProfile
.
initFromArgs
(
appContext
geckoArgs
)
geckoArgs
false
)
)
{
GeckoThread
.
launch
(
)
;
}
}
private
void
init
(
final
Context
context
final
GeckoViewSettings
settings
)
{
preload
(
context
)
;
GeckoAppShell
.
setLayerView
(
this
)
;
initializeView
(
)
;
mListener
.
registerListeners
(
)
;
if
(
settings
=
=
null
)
{
mSettings
=
new
GeckoViewSettings
(
getEventDispatcher
(
)
)
;
}
else
{
mSettings
=
settings
;
}
}
Override
protected
Parcelable
onSaveInstanceState
(
)
{
final
Parcelable
superState
=
super
.
onSaveInstanceState
(
)
;
mStateSaved
=
true
;
return
new
StateBinder
(
superState
mWindow
)
;
}
Override
protected
void
onRestoreInstanceState
(
final
Parcelable
state
)
{
final
StateBinder
stateBinder
=
(
StateBinder
)
state
;
if
(
stateBinder
.
window
!
=
null
)
{
mWindow
=
stateBinder
.
window
;
}
mStateSaved
=
false
;
super
.
onRestoreInstanceState
(
stateBinder
.
superState
)
;
}
public
String
getChromeUri
(
)
{
if
(
mWindow
!
=
null
)
{
return
mWindow
.
chromeUri
;
}
return
mChromeUri
;
}
public
void
setChromeUri
(
final
String
uri
)
{
if
(
mWindow
!
=
null
)
{
throw
new
IllegalStateException
(
"
Already
opened
chrome
window
"
)
;
}
mChromeUri
=
uri
;
}
protected
void
openWindow
(
)
{
mWindow
=
new
Window
(
mChromeUri
mNativeQueue
)
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
Window
.
open
(
mWindow
this
getCompositor
(
)
mEventDispatcher
mChromeUri
mSettings
.
asBundle
(
)
mScreenId
mSettings
.
getBoolean
(
GeckoViewSettings
.
USE_PRIVATE_MODE
)
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
Window
.
class
"
open
"
mWindow
GeckoView
.
class
this
Object
.
class
getCompositor
(
)
EventDispatcher
.
class
mEventDispatcher
String
.
class
mChromeUri
GeckoBundle
.
class
mSettings
.
asBundle
(
)
mScreenId
mSettings
.
getBoolean
(
GeckoViewSettings
.
USE_PRIVATE_MODE
)
)
;
}
}
protected
void
reattachWindow
(
)
{
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
mWindow
.
reattach
(
this
getCompositor
(
)
mEventDispatcher
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mWindow
"
reattach
"
GeckoView
.
class
this
Object
.
class
getCompositor
(
)
EventDispatcher
.
class
mEventDispatcher
)
;
}
}
Override
public
void
onAttachedToWindow
(
)
{
final
DisplayMetrics
metrics
=
getContext
(
)
.
getResources
(
)
.
getDisplayMetrics
(
)
;
if
(
mWindow
=
=
null
)
{
openWindow
(
)
;
}
else
{
reattachWindow
(
)
;
}
super
.
onAttachedToWindow
(
)
;
}
Override
public
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
super
.
destroy
(
)
;
if
(
mStateSaved
)
{
return
;
}
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
mWindow
.
close
(
)
;
mWindow
.
disposeNative
(
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mWindow
"
close
"
)
;
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mWindow
"
disposeNative
"
)
;
}
}
WrapForJNI
public
static
final
int
LOAD_DEFAULT
=
0
;
WrapForJNI
public
static
final
int
LOAD_NEW_TAB
=
1
;
WrapForJNI
public
static
final
int
LOAD_SWITCH_TAB
=
2
;
public
void
loadUri
(
String
uri
int
flags
)
{
if
(
mWindow
=
=
null
)
{
throw
new
IllegalStateException
(
"
Not
attached
to
window
"
)
;
}
if
(
GeckoThread
.
isRunning
(
)
)
{
mWindow
.
loadUri
(
uri
flags
)
;
}
else
{
GeckoThread
.
queueNativeCall
(
mWindow
"
loadUri
"
String
.
class
uri
flags
)
;
}
}
public
void
loadUri
(
String
uri
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
)
;
msg
.
putString
(
"
uri
"
uri
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
LoadUri
"
msg
)
;
}
public
void
loadUri
(
Uri
uri
)
{
loadUri
(
uri
.
toString
(
)
)
;
}
public
void
reload
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
Reload
"
null
)
;
}
public
void
stop
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
Stop
"
null
)
;
}
void
setInputConnectionListener
(
final
InputConnectionListener
icl
)
{
mInputConnectionListener
=
icl
;
}
public
void
goBack
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GoBack
"
null
)
;
}
public
void
goForward
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GoForward
"
null
)
;
}
public
GeckoViewSettings
getSettings
(
)
{
return
mSettings
;
}
Override
public
Handler
getHandler
(
)
{
if
(
mInputConnectionListener
!
=
null
)
{
return
mInputConnectionListener
.
getHandler
(
super
.
getHandler
(
)
)
;
}
return
super
.
getHandler
(
)
;
}
Override
public
InputConnection
onCreateInputConnection
(
EditorInfo
outAttrs
)
{
if
(
mInputConnectionListener
!
=
null
)
{
return
mInputConnectionListener
.
onCreateInputConnection
(
outAttrs
)
;
}
return
null
;
}
Override
public
boolean
onKeyPreIme
(
int
keyCode
KeyEvent
event
)
{
if
(
super
.
onKeyPreIme
(
keyCode
event
)
)
{
return
true
;
}
return
mInputConnectionListener
!
=
null
&
&
mInputConnectionListener
.
onKeyPreIme
(
keyCode
event
)
;
}
Override
public
boolean
onKeyUp
(
int
keyCode
KeyEvent
event
)
{
if
(
super
.
onKeyUp
(
keyCode
event
)
)
{
return
true
;
}
return
mInputConnectionListener
!
=
null
&
&
mInputConnectionListener
.
onKeyUp
(
keyCode
event
)
;
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
if
(
super
.
onKeyDown
(
keyCode
event
)
)
{
return
true
;
}
return
mInputConnectionListener
!
=
null
&
&
mInputConnectionListener
.
onKeyDown
(
keyCode
event
)
;
}
Override
public
boolean
onKeyLongPress
(
int
keyCode
KeyEvent
event
)
{
if
(
super
.
onKeyLongPress
(
keyCode
event
)
)
{
return
true
;
}
return
mInputConnectionListener
!
=
null
&
&
mInputConnectionListener
.
onKeyLongPress
(
keyCode
event
)
;
}
Override
public
boolean
onKeyMultiple
(
int
keyCode
int
repeatCount
KeyEvent
event
)
{
if
(
super
.
onKeyMultiple
(
keyCode
repeatCount
event
)
)
{
return
true
;
}
return
mInputConnectionListener
!
=
null
&
&
mInputConnectionListener
.
onKeyMultiple
(
keyCode
repeatCount
event
)
;
}
boolean
isIMEEnabled
(
)
{
return
mInputConnectionListener
!
=
null
&
&
mInputConnectionListener
.
isIMEEnabled
(
)
;
}
public
void
importScript
(
final
String
url
)
{
if
(
url
.
startsWith
(
"
resource
:
/
/
android
/
assets
/
"
)
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putString
(
"
scriptURL
"
url
)
;
getEventDispatcher
(
)
.
dispatch
(
"
GeckoView
:
ImportScript
"
data
)
;
return
;
}
throw
new
IllegalArgumentException
(
"
Must
import
script
from
'
resources
:
/
/
android
/
assets
/
'
location
.
"
)
;
}
public
void
exitFullScreen
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoViewContent
:
ExitFullScreen
"
null
)
;
}
public
void
setContentListener
(
ContentListener
listener
)
{
mContentHandler
.
setListener
(
listener
this
)
;
}
public
ContentListener
getContentListener
(
)
{
return
mContentHandler
.
getListener
(
)
;
}
public
void
setProgressListener
(
ProgressListener
listener
)
{
mProgressHandler
.
setListener
(
listener
this
)
;
}
public
ProgressListener
getProgressListener
(
)
{
return
mProgressHandler
.
getListener
(
)
;
}
public
void
setNavigationListener
(
NavigationListener
listener
)
{
mNavigationHandler
.
setListener
(
listener
this
)
;
}
public
NavigationListener
getNavigationListener
(
)
{
return
mNavigationHandler
.
getListener
(
)
;
}
public
static
void
setDefaultPromptDelegate
(
PromptDelegate
delegate
)
{
sDefaultPromptDelegate
=
delegate
;
}
public
void
setScrollListener
(
ScrollListener
listener
)
{
mScrollHandler
.
setListener
(
listener
this
)
;
}
public
static
PromptDelegate
getDefaultPromptDelegate
(
)
{
return
sDefaultPromptDelegate
;
}
public
void
setPromptDelegate
(
PromptDelegate
delegate
)
{
mPromptDelegate
=
delegate
;
}
public
PromptDelegate
getPromptDelegate
(
)
{
return
mPromptDelegate
;
}
private
static
class
PromptCallback
implements
PromptDelegate
.
AlertCallback
PromptDelegate
.
ButtonCallback
PromptDelegate
.
TextCallback
PromptDelegate
.
AuthCallback
PromptDelegate
.
ChoiceCallback
PromptDelegate
.
FileCallback
{
private
final
String
mType
;
private
final
String
mMode
;
private
final
boolean
mHasCheckbox
;
private
final
String
mCheckboxMessage
;
private
EventCallback
mCallback
;
private
boolean
mCheckboxValue
;
private
GeckoBundle
mResult
;
public
PromptCallback
(
final
String
type
final
String
mode
final
GeckoBundle
message
final
EventCallback
callback
)
{
mType
=
type
;
mMode
=
mode
;
mCallback
=
callback
;
mHasCheckbox
=
message
.
getBoolean
(
"
hasCheck
"
)
;
mCheckboxMessage
=
message
.
getString
(
"
checkMsg
"
)
;
mCheckboxValue
=
message
.
getBoolean
(
"
checkValue
"
)
;
}
private
GeckoBundle
ensureResult
(
)
{
if
(
mResult
=
=
null
)
{
mResult
=
new
GeckoBundle
(
2
)
;
}
return
mResult
;
}
private
void
submit
(
)
{
if
(
mHasCheckbox
)
{
ensureResult
(
)
.
putBoolean
(
"
checkValue
"
mCheckboxValue
)
;
}
if
(
mCallback
!
=
null
)
{
mCallback
.
sendSuccess
(
mResult
)
;
mCallback
=
null
;
}
}
Override
public
void
dismiss
(
)
{
mResult
=
null
;
submit
(
)
;
}
Override
public
boolean
hasCheckbox
(
)
{
return
mHasCheckbox
;
}
Override
public
String
getCheckboxMessage
(
)
{
return
mCheckboxMessage
;
}
Override
public
boolean
getCheckboxValue
(
)
{
return
mCheckboxValue
;
}
Override
public
void
setCheckboxValue
(
final
boolean
value
)
{
mCheckboxValue
=
value
;
}
Override
public
void
confirm
(
final
int
value
)
{
if
(
"
button
"
.
equals
(
mType
)
)
{
ensureResult
(
)
.
putInt
(
"
button
"
value
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
final
String
value
)
{
if
(
"
text
"
.
equals
(
mType
)
|
|
"
color
"
.
equals
(
mType
)
|
|
"
datetime
"
.
equals
(
mType
)
)
{
ensureResult
(
)
.
putString
(
mType
value
)
;
}
else
if
(
"
auth
"
.
equals
(
mType
)
)
{
if
(
!
"
password
"
.
equals
(
mMode
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
ensureResult
(
)
.
putString
(
"
password
"
value
)
;
}
else
if
(
"
choice
"
.
equals
(
mType
)
)
{
confirm
(
new
String
[
]
{
value
}
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
final
String
username
final
String
password
)
{
if
(
"
auth
"
.
equals
(
mType
)
)
{
if
(
!
"
auth
"
.
equals
(
mMode
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
ensureResult
(
)
.
putString
(
"
username
"
username
)
;
ensureResult
(
)
.
putString
(
"
password
"
password
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
final
String
[
]
values
)
{
if
(
(
"
menu
"
.
equals
(
mMode
)
|
|
"
single
"
.
equals
(
mMode
)
)
&
&
(
values
=
=
null
|
|
values
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
"
choice
"
.
equals
(
mType
)
)
{
ensureResult
(
)
.
putStringArray
(
"
choices
"
values
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
GeckoBundle
item
)
{
if
(
"
choice
"
.
equals
(
mType
)
)
{
confirm
(
item
=
=
null
?
null
:
item
.
getString
(
"
id
"
)
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
Override
public
void
confirm
(
GeckoBundle
[
]
items
)
{
if
(
(
"
menu
"
.
equals
(
mMode
)
|
|
"
single
"
.
equals
(
mMode
)
)
&
&
(
items
=
=
null
|
|
items
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
"
choice
"
.
equals
(
mType
)
)
{
if
(
items
=
=
null
)
{
confirm
(
(
String
[
]
)
null
)
;
return
;
}
final
String
[
]
ids
=
new
String
[
items
.
length
]
;
for
(
int
i
=
0
;
i
<
ids
.
length
;
i
+
+
)
{
ids
[
i
]
=
(
items
[
i
]
=
=
null
)
?
null
:
items
[
i
]
.
getString
(
"
id
"
)
;
}
confirm
(
ids
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
Override
public
void
confirm
(
final
Uri
uri
)
{
if
(
"
file
"
.
equals
(
mType
)
)
{
confirm
(
uri
=
=
null
?
null
:
new
Uri
[
]
{
uri
}
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
private
static
String
getFile
(
final
Uri
uri
)
{
if
(
uri
=
=
null
)
{
return
null
;
}
if
(
"
file
"
.
equals
(
uri
.
getScheme
(
)
)
)
{
return
uri
.
getPath
(
)
;
}
final
ContentResolver
cr
=
GeckoAppShell
.
getApplicationContext
(
)
.
getContentResolver
(
)
;
final
Cursor
cur
=
cr
.
query
(
uri
new
String
[
]
{
"
_data
"
}
null
null
null
)
;
if
(
cur
=
=
null
)
{
return
null
;
}
try
{
final
int
idx
=
cur
.
getColumnIndex
(
"
_data
"
)
;
if
(
idx
<
0
|
|
!
cur
.
moveToFirst
(
)
)
{
return
null
;
}
do
{
try
{
final
String
path
=
cur
.
getString
(
idx
)
;
if
(
path
!
=
null
&
&
!
path
.
isEmpty
(
)
)
{
return
path
;
}
}
catch
(
final
Exception
e
)
{
}
}
while
(
cur
.
moveToNext
(
)
)
;
}
finally
{
cur
.
close
(
)
;
}
return
null
;
}
Override
public
void
confirm
(
final
Uri
[
]
uris
)
{
if
(
"
single
"
.
equals
(
mMode
)
&
&
(
uris
=
=
null
|
|
uris
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
"
file
"
.
equals
(
mType
)
)
{
final
String
[
]
paths
=
new
String
[
uris
!
=
null
?
uris
.
length
:
0
]
;
for
(
int
i
=
0
;
i
<
paths
.
length
;
i
+
+
)
{
paths
[
i
]
=
getFile
(
uris
[
i
]
)
;
if
(
paths
[
i
]
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Only
file
URI
is
supported
:
"
+
uris
[
i
]
)
;
}
}
ensureResult
(
)
.
putStringArray
(
"
files
"
paths
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
}
static
void
handlePromptEvent
(
final
GeckoView
view
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
PromptDelegate
delegate
;
if
(
view
!
=
null
&
&
view
.
mPromptDelegate
!
=
null
)
{
delegate
=
view
.
mPromptDelegate
;
}
else
{
delegate
=
sDefaultPromptDelegate
;
}
if
(
delegate
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
final
String
type
=
message
.
getString
(
"
type
"
)
;
final
String
mode
=
message
.
getString
(
"
mode
"
)
;
final
PromptCallback
cb
=
new
PromptCallback
(
type
mode
message
callback
)
;
final
String
title
=
message
.
getString
(
"
title
"
)
;
final
String
msg
=
message
.
getString
(
"
msg
"
)
;
switch
(
type
)
{
case
"
alert
"
:
{
delegate
.
alert
(
view
title
msg
cb
)
;
break
;
}
case
"
button
"
:
{
final
String
[
]
btnTitle
=
message
.
getStringArray
(
"
btnTitle
"
)
;
final
String
[
]
btnCustomTitle
=
message
.
getStringArray
(
"
btnCustomTitle
"
)
;
for
(
int
i
=
0
;
i
<
btnCustomTitle
.
length
;
i
+
+
)
{
final
int
resId
;
if
(
"
ok
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
ok
;
}
else
if
(
"
cancel
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
cancel
;
}
else
if
(
"
yes
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
yes
;
}
else
if
(
"
no
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
no
;
}
else
{
continue
;
}
btnCustomTitle
[
i
]
=
Resources
.
getSystem
(
)
.
getString
(
resId
)
;
}
delegate
.
promptForButton
(
view
title
msg
btnCustomTitle
cb
)
;
break
;
}
case
"
text
"
:
{
delegate
.
promptForText
(
view
title
msg
message
.
getString
(
"
value
"
)
cb
)
;
break
;
}
case
"
auth
"
:
{
delegate
.
promptForAuth
(
view
title
msg
message
.
getBundle
(
"
options
"
)
cb
)
;
break
;
}
case
"
choice
"
:
{
final
int
intMode
;
if
(
"
menu
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
CHOICE_TYPE_MENU
;
}
else
if
(
"
single
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
CHOICE_TYPE_SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
CHOICE_TYPE_MULTIPLE
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
delegate
.
promptForChoice
(
view
title
msg
intMode
message
.
getBundleArray
(
"
choices
"
)
cb
)
;
break
;
}
case
"
color
"
:
{
delegate
.
promptForColor
(
view
title
message
.
getString
(
"
value
"
)
cb
)
;
break
;
}
case
"
datetime
"
:
{
final
int
intMode
;
if
(
"
date
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_DATE
;
}
else
if
(
"
month
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_MONTH
;
}
else
if
(
"
week
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_WEEK
;
}
else
if
(
"
time
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_TIME
;
}
else
if
(
"
datetime
-
local
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_DATETIME_LOCAL
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
delegate
.
promptForDateTime
(
view
title
intMode
message
.
getString
(
"
value
"
)
message
.
getString
(
"
min
"
)
message
.
getString
(
"
max
"
)
cb
)
;
break
;
}
case
"
file
"
:
{
final
int
intMode
;
if
(
"
single
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
FILE_TYPE_SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
FILE_TYPE_MULTIPLE
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
String
[
]
mimeTypes
=
message
.
getStringArray
(
"
mimeTypes
"
)
;
final
String
[
]
extensions
=
message
.
getStringArray
(
"
extension
"
)
;
if
(
extensions
!
=
null
)
{
final
ArrayList
<
String
>
combined
=
new
ArrayList
<
>
(
mimeTypes
.
length
+
extensions
.
length
)
;
combined
.
addAll
(
Arrays
.
asList
(
mimeTypes
)
)
;
for
(
final
String
extension
:
extensions
)
{
final
String
mimeType
=
URLConnection
.
guessContentTypeFromName
(
extension
)
;
if
(
mimeType
!
=
null
)
{
combined
.
add
(
mimeType
)
;
}
}
mimeTypes
=
combined
.
toArray
(
new
String
[
combined
.
size
(
)
]
)
;
}
delegate
.
promptForFile
(
view
title
intMode
mimeTypes
cb
)
;
break
;
}
default
:
{
callback
.
sendError
(
"
Invalid
type
"
)
;
break
;
}
}
}
public
EventDispatcher
getEventDispatcher
(
)
{
return
mEventDispatcher
;
}
public
interface
ProgressListener
{
static
final
int
STATE_IS_BROKEN
=
1
;
static
final
int
STATE_IS_SECURE
=
2
;
static
final
int
STATE_IS_INSECURE
=
4
;
final
int
STATE_ALL
=
STATE_IS_BROKEN
|
STATE_IS_SECURE
|
STATE_IS_INSECURE
;
void
onPageStart
(
GeckoView
view
String
url
)
;
void
onPageStop
(
GeckoView
view
boolean
success
)
;
void
onSecurityChange
(
GeckoView
view
int
status
GeckoBundle
identity
)
;
}
public
interface
ContentListener
{
void
onTitleChange
(
GeckoView
view
String
title
)
;
void
onFullScreen
(
GeckoView
view
boolean
fullScreen
)
;
void
onContextMenu
(
GeckoView
view
int
screenX
int
screenY
String
uri
String
elementSrc
)
;
}
public
interface
NavigationListener
{
void
onLocationChange
(
GeckoView
view
String
url
)
;
void
onCanGoBack
(
GeckoView
view
boolean
canGoBack
)
;
void
onCanGoForward
(
GeckoView
view
boolean
canGoForward
)
;
}
public
interface
PromptDelegate
{
interface
AlertCallback
{
void
dismiss
(
)
;
boolean
hasCheckbox
(
)
;
String
getCheckboxMessage
(
)
;
boolean
getCheckboxValue
(
)
;
void
setCheckboxValue
(
boolean
value
)
;
}
void
alert
(
GeckoView
view
String
title
String
msg
AlertCallback
callback
)
;
interface
ButtonCallback
extends
AlertCallback
{
void
confirm
(
int
button
)
;
}
static
final
int
BUTTON_TYPE_POSITIVE
=
0
;
static
final
int
BUTTON_TYPE_NEUTRAL
=
1
;
static
final
int
BUTTON_TYPE_NEGATIVE
=
2
;
void
promptForButton
(
GeckoView
view
String
title
String
msg
String
[
]
btnMsg
ButtonCallback
callback
)
;
interface
TextCallback
extends
AlertCallback
{
void
confirm
(
String
text
)
;
}
void
promptForText
(
GeckoView
view
String
title
String
msg
String
value
TextCallback
callback
)
;
interface
AuthCallback
extends
AlertCallback
{
void
confirm
(
String
password
)
;
void
confirm
(
String
username
String
password
)
;
}
static
final
int
AUTH_FLAG_HOST
=
1
;
static
final
int
AUTH_FLAG_PROXY
=
2
;
static
final
int
AUTH_FLAG_ONLY_PASSWORD
=
8
;
static
final
int
AUTH_FLAG_PREVIOUS_FAILED
=
16
;
static
final
int
AUTH_FLAG_CROSS_ORIGIN_SUB_RESOURCE
=
32
;
static
final
int
AUTH_LEVEL_NONE
=
0
;
static
final
int
AUTH_LEVEL_PW_ENCRYPTED
=
1
;
static
final
int
AUTH_LEVEL_SECURE
=
2
;
void
promptForAuth
(
GeckoView
view
String
title
String
msg
GeckoBundle
options
AuthCallback
callback
)
;
interface
ChoiceCallback
extends
AlertCallback
{
void
confirm
(
String
id
)
;
void
confirm
(
String
[
]
ids
)
;
void
confirm
(
GeckoBundle
item
)
;
void
confirm
(
GeckoBundle
[
]
items
)
;
}
static
final
int
CHOICE_TYPE_MENU
=
1
;
static
final
int
CHOICE_TYPE_SINGLE
=
2
;
static
final
int
CHOICE_TYPE_MULTIPLE
=
3
;
void
promptForChoice
(
GeckoView
view
String
title
String
msg
int
type
GeckoBundle
[
]
choices
ChoiceCallback
callback
)
;
void
promptForColor
(
GeckoView
view
String
title
String
value
TextCallback
callback
)
;
static
final
int
DATETIME_TYPE_DATE
=
1
;
static
final
int
DATETIME_TYPE_MONTH
=
2
;
static
final
int
DATETIME_TYPE_WEEK
=
3
;
static
final
int
DATETIME_TYPE_TIME
=
4
;
static
final
int
DATETIME_TYPE_DATETIME_LOCAL
=
5
;
void
promptForDateTime
(
GeckoView
view
String
title
int
type
String
value
String
min
String
max
TextCallback
callback
)
;
interface
FileCallback
extends
AlertCallback
{
void
confirm
(
Uri
uri
)
;
void
confirm
(
Uri
[
]
uris
)
;
}
static
final
int
FILE_TYPE_SINGLE
=
1
;
static
final
int
FILE_TYPE_MULTIPLE
=
2
;
void
promptForFile
(
GeckoView
view
String
title
int
type
String
[
]
mimeTypes
FileCallback
callback
)
;
}
public
interface
ScrollListener
{
public
void
onScrollChanged
(
GeckoView
view
int
scrollX
int
scrollY
)
;
}
public
interface
PermissionDelegate
{
interface
Callback
{
void
grant
(
)
;
void
reject
(
)
;
}
void
requestAndroidPermissions
(
GeckoView
view
String
[
]
permissions
Callback
callback
)
;
void
requestContentPermission
(
GeckoView
view
String
uri
String
type
String
access
Callback
callback
)
;
interface
MediaCallback
{
void
grant
(
final
String
video
final
String
audio
)
;
void
grant
(
final
GeckoBundle
video
final
GeckoBundle
audio
)
;
void
reject
(
)
;
}
void
requestMediaPermission
(
GeckoView
view
String
uri
GeckoBundle
[
]
video
GeckoBundle
[
]
audio
MediaCallback
callback
)
;
}
}
