package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
GeckoEditable
;
import
org
.
mozilla
.
gecko
.
GeckoEditableChild
;
import
org
.
mozilla
.
gecko
.
GeckoInputConnection
;
import
org
.
mozilla
.
gecko
.
IGeckoEditableParent
;
import
org
.
mozilla
.
gecko
.
NativeQueue
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
Handler
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
text
.
Editable
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
public
final
class
TextInputController
{
public
interface
Delegate
{
View
getView
(
)
;
Handler
getHandler
(
Handler
defHandler
)
;
InputConnection
onCreateInputConnection
(
EditorInfo
attrs
)
;
boolean
onKeyPreIme
(
int
keyCode
KeyEvent
event
)
;
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
;
boolean
onKeyUp
(
int
keyCode
KeyEvent
event
)
;
boolean
onKeyLongPress
(
int
keyCode
KeyEvent
event
)
;
boolean
onKeyMultiple
(
int
keyCode
int
repeatCount
KeyEvent
event
)
;
boolean
isInputActive
(
)
;
}
public
interface
EditableClient
{
WrapForJNI
final
int
ONE_SHOT
=
1
;
WrapForJNI
final
int
START_MONITOR
=
2
;
WrapForJNI
final
int
END_MONITOR
=
3
;
void
sendKeyEvent
(
KeyEvent
event
int
action
int
metaState
)
;
Editable
getEditable
(
)
;
void
setBatchMode
(
boolean
isBatchMode
)
;
void
setSuppressKeyUp
(
boolean
suppress
)
;
Handler
setInputConnectionHandler
(
Handler
handler
)
;
void
postToInputConnection
(
Runnable
runnable
)
;
void
requestCursorUpdates
(
int
requestMode
)
;
}
public
interface
EditableListener
{
WrapForJNI
final
int
NOTIFY_IME_OF_TOKEN
=
-
3
;
WrapForJNI
final
int
NOTIFY_IME_OPEN_VKB
=
-
2
;
WrapForJNI
final
int
NOTIFY_IME_REPLY_EVENT
=
-
1
;
WrapForJNI
final
int
NOTIFY_IME_OF_FOCUS
=
1
;
WrapForJNI
final
int
NOTIFY_IME_OF_BLUR
=
2
;
WrapForJNI
final
int
NOTIFY_IME_TO_COMMIT_COMPOSITION
=
8
;
WrapForJNI
final
int
NOTIFY_IME_TO_CANCEL_COMPOSITION
=
9
;
final
int
IME_STATE_DISABLED
=
0
;
final
int
IME_STATE_ENABLED
=
1
;
final
int
IME_STATE_PASSWORD
=
2
;
WrapForJNI
final
int
IME_FLAG_PRIVATE_BROWSING
=
1
;
WrapForJNI
final
int
IME_FLAG_USER_ACTION
=
2
;
void
notifyIME
(
int
type
)
;
void
notifyIMEContext
(
int
state
String
typeHint
String
modeHint
String
actionHint
int
flag
)
;
void
onSelectionChange
(
)
;
void
onTextChange
(
)
;
void
onDefaultKeyEvent
(
KeyEvent
event
)
;
void
updateCompositionRects
(
final
RectF
[
]
aRects
)
;
}
private
final
GeckoSession
mSession
;
private
final
NativeQueue
mQueue
;
private
final
GeckoEditable
mEditable
=
new
GeckoEditable
(
)
;
private
final
GeckoEditableChild
mEditableChild
=
new
GeckoEditableChild
(
mEditable
)
;
private
Delegate
mInputConnection
;
public
TextInputController
(
final
NonNull
GeckoSession
session
final
NonNull
NativeQueue
queue
)
{
mSession
=
session
;
mQueue
=
queue
;
mEditable
.
setDefaultEditableChild
(
mEditableChild
)
;
}
public
void
onWindowChanged
(
final
GeckoSession
.
Window
window
)
{
if
(
mQueue
.
isReady
(
)
)
{
window
.
attachEditable
(
mEditable
mEditableChild
)
;
}
else
{
mQueue
.
queueUntilReady
(
window
"
attachEditable
"
IGeckoEditableParent
.
class
mEditable
GeckoEditableChild
.
class
mEditableChild
)
;
}
}
public
NonNull
Handler
getHandler
(
final
NonNull
Handler
defHandler
)
{
if
(
mInputConnection
!
=
null
)
{
return
mInputConnection
.
getHandler
(
defHandler
)
;
}
return
defHandler
;
}
private
synchronized
boolean
ensureInputConnection
(
)
{
if
(
!
mQueue
.
isReady
(
)
)
{
return
false
;
}
if
(
mInputConnection
=
=
null
)
{
mInputConnection
=
GeckoInputConnection
.
create
(
mSession
null
mEditable
)
;
mEditable
.
setListener
(
(
EditableListener
)
mInputConnection
)
;
}
return
true
;
}
public
Nullable
View
getView
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mInputConnection
!
=
null
?
mInputConnection
.
getView
(
)
:
null
;
}
public
synchronized
void
setView
(
final
Nullable
View
view
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
view
=
=
null
)
{
mInputConnection
=
null
;
}
else
if
(
mInputConnection
=
=
null
|
|
mInputConnection
.
getView
(
)
!
=
view
)
{
mInputConnection
=
GeckoInputConnection
.
create
(
mSession
view
mEditable
)
;
}
mEditable
.
setListener
(
(
EditableListener
)
mInputConnection
)
;
}
public
Nullable
InputConnection
onCreateInputConnection
(
final
NonNull
EditorInfo
attrs
)
{
if
(
!
ensureInputConnection
(
)
)
{
return
null
;
}
return
mInputConnection
.
onCreateInputConnection
(
attrs
)
;
}
public
boolean
onKeyPreIme
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
ensureInputConnection
(
)
)
{
return
false
;
}
return
mInputConnection
.
onKeyPreIme
(
keyCode
event
)
;
}
public
boolean
onKeyDown
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
ensureInputConnection
(
)
)
{
return
false
;
}
return
mInputConnection
.
onKeyDown
(
keyCode
event
)
;
}
public
boolean
onKeyUp
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
ensureInputConnection
(
)
)
{
return
false
;
}
return
mInputConnection
.
onKeyUp
(
keyCode
event
)
;
}
public
boolean
onKeyLongPress
(
final
int
keyCode
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
ensureInputConnection
(
)
)
{
return
false
;
}
return
mInputConnection
.
onKeyLongPress
(
keyCode
event
)
;
}
public
boolean
onKeyMultiple
(
final
int
keyCode
final
int
repeatCount
final
NonNull
KeyEvent
event
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
ensureInputConnection
(
)
)
{
return
false
;
}
return
mInputConnection
.
onKeyMultiple
(
keyCode
repeatCount
event
)
;
}
public
boolean
isInputActive
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mInputConnection
!
=
null
&
&
mInputConnection
.
isInputActive
(
)
;
}
}
