package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
v4
.
util
.
SimpleArrayMap
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
concurrent
.
TimeoutException
;
import
java
.
util
.
function
.
Consumer
;
AnyThread
public
class
GeckoResult
<
T
>
{
private
static
final
String
LOGTAG
=
"
GeckoResult
"
;
private
interface
Dispatcher
{
void
dispatch
(
Runnable
r
)
;
}
private
static
class
HandlerDispatcher
implements
Dispatcher
{
HandlerDispatcher
(
final
Handler
h
)
{
mHandler
=
h
;
}
public
void
dispatch
(
final
Runnable
r
)
{
mHandler
.
post
(
r
)
;
}
Override
public
boolean
equals
(
final
Object
other
)
{
if
(
!
(
other
instanceof
HandlerDispatcher
)
)
{
return
false
;
}
return
mHandler
.
equals
(
(
(
HandlerDispatcher
)
other
)
.
mHandler
)
;
}
Override
public
int
hashCode
(
)
{
return
mHandler
.
hashCode
(
)
;
}
Handler
mHandler
;
}
private
static
class
DirectDispatcher
implements
Dispatcher
{
public
void
dispatch
(
final
Runnable
r
)
{
r
.
run
(
)
;
}
static
DirectDispatcher
sInstance
=
new
DirectDispatcher
(
)
;
private
DirectDispatcher
(
)
{
}
}
public
static
final
class
UncaughtException
extends
RuntimeException
{
public
UncaughtException
(
final
Throwable
cause
)
{
super
(
cause
)
;
}
}
public
static
final
GeckoResult
<
AllowOrDeny
>
ALLOW
=
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
;
public
static
final
GeckoResult
<
AllowOrDeny
>
DENY
=
GeckoResult
.
fromValue
(
AllowOrDeny
.
DENY
)
;
private
final
Dispatcher
mDispatcher
;
private
boolean
mComplete
;
private
T
mValue
;
private
Throwable
mError
;
private
boolean
mIsUncaughtError
;
private
SimpleArrayMap
<
Dispatcher
ArrayList
<
Runnable
>
>
mListeners
=
new
SimpleArrayMap
<
>
(
)
;
WrapForJNI
public
GeckoResult
(
)
{
if
(
ThreadUtils
.
isOnUiThread
(
)
)
{
mDispatcher
=
new
HandlerDispatcher
(
ThreadUtils
.
getUiHandler
(
)
)
;
}
else
if
(
Looper
.
myLooper
(
)
!
=
null
)
{
mDispatcher
=
new
HandlerDispatcher
(
new
Handler
(
)
)
;
}
else
{
mDispatcher
=
null
;
}
}
public
GeckoResult
(
final
Handler
handler
)
{
mDispatcher
=
new
HandlerDispatcher
(
handler
)
;
}
public
GeckoResult
(
final
GeckoResult
<
T
>
from
)
{
this
(
)
;
completeFrom
(
from
)
;
}
WrapForJNI
public
static
NonNull
<
U
>
GeckoResult
<
U
>
fromValue
(
Nullable
final
U
value
)
{
final
GeckoResult
<
U
>
result
=
new
GeckoResult
<
>
(
)
;
result
.
complete
(
value
)
;
return
result
;
}
WrapForJNI
public
static
NonNull
<
T
>
GeckoResult
<
T
>
fromException
(
NonNull
final
Throwable
error
)
{
final
GeckoResult
<
T
>
result
=
new
GeckoResult
<
>
(
)
;
result
.
completeExceptionally
(
error
)
;
return
result
;
}
Override
public
synchronized
int
hashCode
(
)
{
int
result
=
17
;
result
=
31
*
result
+
(
mComplete
?
1
:
0
)
;
result
=
31
*
result
+
(
mValue
!
=
null
?
mValue
.
hashCode
(
)
:
0
)
;
result
=
31
*
result
+
(
mError
!
=
null
?
mError
.
hashCode
(
)
:
0
)
;
return
result
;
}
private
static
boolean
objectEquals
(
final
Object
a
final
Object
b
)
{
return
a
=
=
b
|
|
(
a
!
=
null
&
&
a
.
equals
(
b
)
)
;
}
Override
public
synchronized
boolean
equals
(
final
Object
other
)
{
if
(
other
instanceof
GeckoResult
<
?
>
)
{
final
GeckoResult
<
?
>
result
=
(
GeckoResult
<
?
>
)
other
;
return
result
.
mComplete
=
=
mComplete
&
&
objectEquals
(
result
.
mError
mError
)
&
&
objectEquals
(
result
.
mValue
mValue
)
;
}
return
false
;
}
public
NonNull
<
U
>
GeckoResult
<
U
>
then
(
NonNull
final
OnValueListener
<
T
U
>
valueListener
)
{
return
then
(
valueListener
null
)
;
}
public
NonNull
<
U
>
GeckoResult
<
U
>
exceptionally
(
NonNull
final
OnExceptionListener
<
U
>
exceptionListener
)
{
return
then
(
null
exceptionListener
)
;
}
public
interface
Consumer
<
T
>
{
AnyThread
void
accept
(
Nullable
T
t
)
;
}
public
NonNull
GeckoResult
<
Void
>
accept
(
Nullable
final
Consumer
<
T
>
valueListener
)
{
return
accept
(
valueListener
null
)
;
}
public
NonNull
GeckoResult
<
Void
>
accept
(
Nullable
final
Consumer
<
T
>
valueConsumer
Nullable
final
Consumer
<
Throwable
>
exceptionConsumer
)
{
final
OnValueListener
<
T
Void
>
valueListener
=
valueConsumer
=
=
null
?
null
:
value
-
>
{
valueConsumer
.
accept
(
value
)
;
return
null
;
}
;
final
OnExceptionListener
<
Void
>
exceptionListener
=
exceptionConsumer
=
=
null
?
null
:
value
-
>
{
exceptionConsumer
.
accept
(
value
)
;
return
null
;
}
;
return
then
(
valueListener
exceptionListener
)
;
}
public
NonNull
<
U
>
GeckoResult
<
U
>
then
(
Nullable
final
OnValueListener
<
T
U
>
valueListener
Nullable
final
OnExceptionListener
<
U
>
exceptionListener
)
{
if
(
mDispatcher
=
=
null
)
{
throw
new
IllegalThreadStateException
(
"
Must
have
a
Handler
"
)
;
}
return
thenInternal
(
mDispatcher
valueListener
exceptionListener
)
;
}
private
NonNull
<
U
>
GeckoResult
<
U
>
thenInternal
(
NonNull
final
Dispatcher
dispatcher
Nullable
final
OnValueListener
<
T
U
>
valueListener
Nullable
final
OnExceptionListener
<
U
>
exceptionListener
)
{
if
(
valueListener
=
=
null
&
&
exceptionListener
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
At
least
one
listener
should
be
non
-
null
"
)
;
}
final
GeckoResult
<
U
>
result
=
new
GeckoResult
<
U
>
(
)
;
thenInternal
(
dispatcher
(
)
-
>
{
try
{
if
(
haveValue
(
)
)
{
result
.
completeFrom
(
valueListener
!
=
null
?
valueListener
.
onValue
(
mValue
)
:
null
)
;
}
else
if
(
!
haveError
(
)
)
{
throw
new
AssertionError
(
)
;
}
else
if
(
exceptionListener
!
=
null
)
{
result
.
completeFrom
(
exceptionListener
.
onException
(
mError
)
)
;
}
else
{
result
.
mIsUncaughtError
=
mIsUncaughtError
;
result
.
completeExceptionally
(
mError
)
;
}
}
catch
(
Throwable
e
)
{
if
(
!
result
.
mComplete
)
{
result
.
mIsUncaughtError
=
true
;
result
.
completeExceptionally
(
e
)
;
}
else
if
(
e
instanceof
RuntimeException
)
{
throw
(
RuntimeException
)
e
;
}
}
}
)
;
return
result
;
}
private
synchronized
void
thenInternal
(
NonNull
final
Dispatcher
dispatcher
NonNull
final
Runnable
listener
)
{
if
(
mComplete
)
{
dispatcher
.
dispatch
(
listener
)
;
}
else
{
if
(
!
mListeners
.
containsKey
(
dispatcher
)
)
{
mListeners
.
put
(
dispatcher
new
ArrayList
<
>
(
1
)
)
;
}
mListeners
.
get
(
dispatcher
)
.
add
(
listener
)
;
}
}
public
Nullable
Looper
getLooper
(
)
{
if
(
mDispatcher
=
=
null
|
|
!
(
mDispatcher
instanceof
HandlerDispatcher
)
)
{
return
null
;
}
return
(
(
HandlerDispatcher
)
mDispatcher
)
.
mHandler
.
getLooper
(
)
;
}
public
NonNull
GeckoResult
<
T
>
withHandler
(
final
Nullable
Handler
handler
)
{
final
GeckoResult
<
T
>
result
=
new
GeckoResult
<
>
(
handler
)
;
result
.
completeFrom
(
this
)
;
return
result
;
}
private
void
dispatchLocked
(
)
{
if
(
!
mComplete
)
{
throw
new
IllegalStateException
(
"
Cannot
dispatch
unless
result
is
complete
"
)
;
}
if
(
mListeners
.
isEmpty
(
)
)
{
if
(
mIsUncaughtError
)
{
throw
new
UncaughtException
(
mError
)
;
}
return
;
}
if
(
mDispatcher
=
=
null
)
{
throw
new
AssertionError
(
"
Shouldn
'
t
have
listeners
with
null
dispatcher
"
)
;
}
for
(
int
i
=
0
;
i
<
mListeners
.
size
(
)
;
+
+
i
)
{
Dispatcher
dispatcher
=
mListeners
.
keyAt
(
i
)
;
ArrayList
<
Runnable
>
jobs
=
mListeners
.
valueAt
(
i
)
;
dispatcher
.
dispatch
(
(
)
-
>
{
for
(
final
Runnable
job
:
jobs
)
{
job
.
run
(
)
;
}
}
)
;
}
mListeners
.
clear
(
)
;
}
private
void
completeFrom
(
final
GeckoResult
<
T
>
other
)
{
if
(
other
=
=
null
)
{
complete
(
null
)
;
return
;
}
other
.
thenInternal
(
DirectDispatcher
.
sInstance
(
)
-
>
{
if
(
other
.
haveValue
(
)
)
{
complete
(
other
.
mValue
)
;
}
else
{
mIsUncaughtError
=
other
.
mIsUncaughtError
;
completeExceptionally
(
other
.
mError
)
;
}
}
)
;
}
public
synchronized
Nullable
T
poll
(
)
throws
Throwable
{
if
(
Looper
.
myLooper
(
)
!
=
null
)
{
throw
new
IllegalThreadStateException
(
"
Cannot
poll
indefinitely
from
thread
with
Looper
"
)
;
}
return
poll
(
Long
.
MAX_VALUE
)
;
}
public
synchronized
Nullable
T
poll
(
final
long
timeoutMillis
)
throws
Throwable
{
final
long
start
=
SystemClock
.
uptimeMillis
(
)
;
long
remaining
=
timeoutMillis
;
while
(
!
mComplete
&
&
remaining
>
0
)
{
try
{
wait
(
remaining
)
;
}
catch
(
InterruptedException
e
)
{
}
remaining
=
timeoutMillis
-
(
SystemClock
.
uptimeMillis
(
)
-
start
)
;
}
if
(
!
mComplete
)
{
throw
new
TimeoutException
(
)
;
}
if
(
haveError
(
)
)
{
throw
mError
;
}
return
mValue
;
}
WrapForJNI
public
synchronized
void
complete
(
final
Nullable
T
value
)
{
if
(
mComplete
)
{
throw
new
IllegalStateException
(
"
result
is
already
complete
"
)
;
}
mValue
=
value
;
mComplete
=
true
;
dispatchLocked
(
)
;
notifyAll
(
)
;
}
WrapForJNI
public
synchronized
void
completeExceptionally
(
NonNull
final
Throwable
exception
)
{
if
(
mComplete
)
{
throw
new
IllegalStateException
(
"
result
is
already
complete
"
)
;
}
if
(
exception
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Throwable
must
not
be
null
"
)
;
}
mError
=
exception
;
mComplete
=
true
;
dispatchLocked
(
)
;
notifyAll
(
)
;
}
public
interface
OnValueListener
<
T
U
>
{
AnyThread
Nullable
GeckoResult
<
U
>
onValue
(
Nullable
T
value
)
throws
Throwable
;
}
public
interface
OnExceptionListener
<
V
>
{
AnyThread
Nullable
GeckoResult
<
V
>
onException
(
NonNull
Throwable
exception
)
throws
Throwable
;
}
private
boolean
haveValue
(
)
{
return
mComplete
&
&
mError
=
=
null
;
}
private
boolean
haveError
(
)
{
return
mComplete
&
&
mError
!
=
null
;
}
}
