package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
concurrent
.
TimeoutException
;
AnyThread
public
class
GeckoResult
<
T
>
{
private
static
final
String
LOGTAG
=
"
GeckoResult
"
;
public
static
final
class
UncaughtException
extends
RuntimeException
{
public
UncaughtException
(
final
Throwable
cause
)
{
super
(
cause
)
;
}
}
public
static
final
GeckoResult
<
AllowOrDeny
>
ALLOW
=
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
;
public
static
final
GeckoResult
<
AllowOrDeny
>
DENY
=
GeckoResult
.
fromValue
(
AllowOrDeny
.
DENY
)
;
private
final
Handler
mHandler
;
private
boolean
mComplete
;
private
T
mValue
;
private
Throwable
mError
;
private
boolean
mIsUncaughtError
;
private
ArrayList
<
Runnable
>
mListeners
;
WrapForJNI
public
GeckoResult
(
)
{
if
(
ThreadUtils
.
isOnUiThread
(
)
)
{
mHandler
=
ThreadUtils
.
getUiHandler
(
)
;
}
else
if
(
Looper
.
myLooper
(
)
!
=
null
)
{
mHandler
=
new
Handler
(
)
;
}
else
{
mHandler
=
null
;
}
}
public
GeckoResult
(
final
Handler
handler
)
{
mHandler
=
handler
;
}
public
GeckoResult
(
final
GeckoResult
<
T
>
from
)
{
this
(
)
;
completeFrom
(
from
)
;
}
WrapForJNI
public
static
NonNull
<
U
>
GeckoResult
<
U
>
fromValue
(
Nullable
final
U
value
)
{
final
GeckoResult
<
U
>
result
=
new
GeckoResult
<
>
(
)
;
result
.
complete
(
value
)
;
return
result
;
}
WrapForJNI
public
static
NonNull
<
T
>
GeckoResult
<
T
>
fromException
(
NonNull
final
Throwable
error
)
{
final
GeckoResult
<
T
>
result
=
new
GeckoResult
<
>
(
)
;
result
.
completeExceptionally
(
error
)
;
return
result
;
}
Override
public
synchronized
int
hashCode
(
)
{
int
result
=
17
;
result
=
31
*
result
+
(
mComplete
?
1
:
0
)
;
result
=
31
*
result
+
(
mValue
!
=
null
?
mValue
.
hashCode
(
)
:
0
)
;
result
=
31
*
result
+
(
mError
!
=
null
?
mError
.
hashCode
(
)
:
0
)
;
return
result
;
}
private
static
boolean
objectEquals
(
final
Object
a
final
Object
b
)
{
return
a
=
=
b
|
|
(
a
!
=
null
&
&
a
.
equals
(
b
)
)
;
}
Override
public
synchronized
boolean
equals
(
final
Object
other
)
{
if
(
other
instanceof
GeckoResult
<
?
>
)
{
final
GeckoResult
<
?
>
result
=
(
GeckoResult
<
?
>
)
other
;
return
result
.
mComplete
=
=
mComplete
&
&
objectEquals
(
result
.
mError
mError
)
&
&
objectEquals
(
result
.
mValue
mValue
)
;
}
return
false
;
}
public
NonNull
<
U
>
GeckoResult
<
U
>
then
(
NonNull
final
OnValueListener
<
T
U
>
valueListener
)
{
return
then
(
valueListener
null
)
;
}
public
NonNull
<
U
>
GeckoResult
<
U
>
exceptionally
(
NonNull
final
OnExceptionListener
<
U
>
exceptionListener
)
{
return
then
(
null
exceptionListener
)
;
}
public
NonNull
<
U
>
GeckoResult
<
U
>
then
(
Nullable
final
OnValueListener
<
T
U
>
valueListener
Nullable
final
OnExceptionListener
<
U
>
exceptionListener
)
{
if
(
valueListener
=
=
null
&
&
exceptionListener
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
At
least
one
listener
should
be
non
-
null
"
)
;
}
if
(
mHandler
=
=
null
)
{
throw
new
IllegalThreadStateException
(
"
Must
have
a
Handler
"
)
;
}
final
GeckoResult
<
U
>
result
=
new
GeckoResult
<
U
>
(
)
;
then
(
(
)
-
>
{
try
{
if
(
haveValue
(
)
)
{
result
.
completeFrom
(
valueListener
!
=
null
?
valueListener
.
onValue
(
mValue
)
:
null
)
;
}
else
if
(
!
haveError
(
)
)
{
throw
new
AssertionError
(
)
;
}
else
if
(
exceptionListener
!
=
null
)
{
result
.
completeFrom
(
exceptionListener
.
onException
(
mError
)
)
;
}
else
{
result
.
mIsUncaughtError
=
mIsUncaughtError
;
result
.
completeExceptionally
(
mError
)
;
}
}
catch
(
Throwable
e
)
{
if
(
!
result
.
mComplete
)
{
result
.
mIsUncaughtError
=
true
;
result
.
completeExceptionally
(
e
)
;
}
}
}
)
;
return
result
;
}
private
synchronized
void
then
(
NonNull
final
Runnable
listener
)
{
if
(
mComplete
)
{
dispatchLocked
(
listener
)
;
}
else
{
if
(
mListeners
=
=
null
)
{
mListeners
=
new
ArrayList
<
>
(
1
)
;
}
mListeners
.
add
(
listener
)
;
}
}
public
Nullable
Looper
getLooper
(
)
{
if
(
mHandler
=
=
null
)
{
return
null
;
}
return
mHandler
.
getLooper
(
)
;
}
public
NonNull
GeckoResult
<
T
>
withHandler
(
final
Nullable
Handler
handler
)
{
final
GeckoResult
<
T
>
result
=
new
GeckoResult
<
>
(
handler
)
;
result
.
completeFrom
(
this
)
;
return
result
;
}
private
void
dispatchLocked
(
)
{
if
(
!
mComplete
)
{
throw
new
IllegalStateException
(
"
Cannot
dispatch
unless
result
is
complete
"
)
;
}
if
(
mListeners
=
=
null
&
&
!
mIsUncaughtError
)
{
return
;
}
final
Runnable
dispatcher
=
(
)
-
>
{
if
(
mListeners
!
=
null
)
{
for
(
final
Runnable
listener
:
mListeners
)
{
listener
.
run
(
)
;
}
}
else
if
(
mIsUncaughtError
)
{
throw
new
UncaughtException
(
mError
)
;
}
}
;
dispatchLocked
(
dispatcher
)
;
}
private
void
dispatchLocked
(
final
Runnable
runnable
)
{
if
(
!
mComplete
)
{
throw
new
IllegalStateException
(
"
Cannot
dispatch
unless
result
is
complete
"
)
;
}
if
(
mHandler
=
=
null
)
{
runnable
.
run
(
)
;
return
;
}
mHandler
.
post
(
runnable
)
;
}
private
void
completeFrom
(
final
GeckoResult
<
T
>
other
)
{
if
(
other
=
=
null
)
{
complete
(
null
)
;
return
;
}
other
.
then
(
(
)
-
>
{
if
(
other
.
haveValue
(
)
)
{
complete
(
other
.
mValue
)
;
}
else
{
mIsUncaughtError
=
other
.
mIsUncaughtError
;
completeExceptionally
(
other
.
mError
)
;
}
}
)
;
}
public
synchronized
Nullable
T
poll
(
)
throws
Throwable
{
if
(
Looper
.
myLooper
(
)
!
=
null
)
{
throw
new
IllegalThreadStateException
(
"
Cannot
poll
indefinitely
from
thread
with
Looper
"
)
;
}
return
poll
(
Long
.
MAX_VALUE
)
;
}
public
synchronized
Nullable
T
poll
(
final
long
timeoutMillis
)
throws
Throwable
{
final
long
start
=
SystemClock
.
uptimeMillis
(
)
;
long
remaining
=
timeoutMillis
;
while
(
!
mComplete
&
&
remaining
>
0
)
{
try
{
wait
(
remaining
)
;
}
catch
(
InterruptedException
e
)
{
}
remaining
=
timeoutMillis
-
(
SystemClock
.
uptimeMillis
(
)
-
start
)
;
}
if
(
!
mComplete
)
{
throw
new
TimeoutException
(
)
;
}
if
(
haveError
(
)
)
{
throw
mError
;
}
return
mValue
;
}
WrapForJNI
public
synchronized
void
complete
(
final
Nullable
T
value
)
{
if
(
mComplete
)
{
throw
new
IllegalStateException
(
"
result
is
already
complete
"
)
;
}
mValue
=
value
;
mComplete
=
true
;
dispatchLocked
(
)
;
notifyAll
(
)
;
}
WrapForJNI
public
synchronized
void
completeExceptionally
(
NonNull
final
Throwable
exception
)
{
if
(
mComplete
)
{
throw
new
IllegalStateException
(
"
result
is
already
complete
"
)
;
}
if
(
exception
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Throwable
must
not
be
null
"
)
;
}
mError
=
exception
;
mComplete
=
true
;
dispatchLocked
(
)
;
notifyAll
(
)
;
}
public
interface
OnValueListener
<
T
U
>
{
AnyThread
Nullable
GeckoResult
<
U
>
onValue
(
Nullable
T
value
)
throws
Throwable
;
}
public
interface
OnExceptionListener
<
V
>
{
AnyThread
Nullable
GeckoResult
<
V
>
onException
(
NonNull
Throwable
exception
)
throws
Throwable
;
}
private
boolean
haveValue
(
)
{
return
mComplete
&
&
mError
=
=
null
;
}
private
boolean
haveError
(
)
{
return
mComplete
&
&
mError
!
=
null
;
}
}
