package
org
.
mozilla
.
gecko
.
util
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodecInfo
;
import
android
.
media
.
MediaCodecInfo
.
CodecCapabilities
;
import
android
.
media
.
MediaCodecList
;
import
android
.
os
.
Build
;
import
android
.
util
.
Log
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Set
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
public
final
class
HardwareCodecCapabilityUtils
{
private
static
final
String
LOGTAG
=
"
HardwareCodecCapability
"
;
private
static
final
String
[
]
supportedVp8HwEncCodecPrefixes
=
{
"
OMX
.
qcom
.
"
"
OMX
.
Intel
.
"
}
;
private
static
final
String
[
]
supportedVp8HwDecCodecPrefixes
=
{
"
OMX
.
qcom
.
"
"
OMX
.
Nvidia
.
"
"
OMX
.
Exynos
.
"
"
c2
.
exynos
"
"
OMX
.
Intel
.
"
}
;
private
static
final
String
VP8_MIME_TYPE
=
"
video
/
x
-
vnd
.
on2
.
vp8
"
;
private
static
final
String
[
]
supportedVp9HwCodecPrefixes
=
{
"
OMX
.
qcom
.
"
"
OMX
.
Exynos
.
"
"
c2
.
exynos
"
"
OMX
.
allwinner
.
"
"
OMX
.
amlogic
.
"
"
OMX
.
MTK
.
"
"
OMX
.
Nvidia
.
"
"
OMX
.
rk
.
"
}
;
private
static
final
String
VP9_MIME_TYPE
=
"
video
/
x
-
vnd
.
on2
.
vp9
"
;
private
static
final
String
[
]
supportedGenericHwCodecPrefixes
=
{
"
OMX
.
qcom
.
"
"
OMX
.
Intel
.
"
"
OMX
.
Exynos
.
"
"
c2
.
exynos
"
"
OMX
.
Nvidia
"
"
OMX
.
SEC
.
"
"
OMX
.
IMG
.
"
"
OMX
.
k3
.
"
"
OMX
.
hisi
.
"
"
OMX
.
TI
.
"
"
OMX
.
MTK
.
"
"
OMX
.
allwinner
.
"
"
OMX
.
amlogic
.
"
"
OMX
.
rk
.
"
}
;
private
static
final
String
H264_MIME_TYPE
=
"
video
/
avc
"
;
private
static
final
String
HEVC_MIME_TYPE
=
"
video
/
hevc
"
;
private
static
final
String
AV1_MIME_TYPE
=
"
video
/
av01
"
;
private
static
final
int
COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m
=
0x7FA30C04
;
private
static
final
int
[
]
supportedColorList
=
{
CodecCapabilities
.
COLOR_FormatYUV420Planar
CodecCapabilities
.
COLOR_FormatYUV420SemiPlanar
CodecCapabilities
.
COLOR_QCOM_FormatYUV420SemiPlanar
COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m
}
;
private
static
final
int
COLOR_FORMAT_NOT_SUPPORTED
=
-
1
;
private
static
final
String
[
]
adaptivePlaybackBlocklist
=
{
"
GT
-
I9300
"
"
SCH
-
I535
"
"
SGH
-
T999
"
"
SAMSUNG
-
SGH
-
T999
"
"
SGH
-
M919
"
"
GT
-
I9505
"
"
GT
-
I9515
"
"
SCH
-
R970
"
"
SGH
-
I337
"
"
SPH
-
L720
"
"
SAMSUNG
-
SGH
-
I337
"
"
GT
-
I9195
"
"
300E5EV
/
300E4EV
/
270E5EV
/
270E4EV
/
2470EV
/
2470EE
"
"
LG
-
D605
"
}
;
private
static
MediaCodecInfo
[
]
getCodecListWithOldAPI
(
)
{
int
numCodecs
=
0
;
try
{
numCodecs
=
MediaCodecList
.
getCodecCount
(
)
;
}
catch
(
final
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
retrieve
media
codec
count
"
e
)
;
return
new
MediaCodecInfo
[
numCodecs
]
;
}
final
MediaCodecInfo
[
]
codecList
=
new
MediaCodecInfo
[
numCodecs
]
;
for
(
int
i
=
0
;
i
<
numCodecs
;
+
+
i
)
{
final
MediaCodecInfo
info
=
MediaCodecList
.
getCodecInfoAt
(
i
)
;
codecList
[
i
]
=
info
;
}
return
codecList
;
}
private
static
MediaCodecInfo
[
]
getCodecList
(
)
{
final
MediaCodecInfo
[
]
codecList
;
try
{
final
MediaCodecList
list
=
new
MediaCodecList
(
MediaCodecList
.
REGULAR_CODECS
)
;
codecList
=
list
.
getCodecInfos
(
)
;
}
catch
(
final
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
retrieve
media
codec
support
list
"
e
)
;
return
new
MediaCodecInfo
[
0
]
;
}
return
codecList
;
}
private
static
MediaCodecInfo
[
]
getDecoderInfos
(
)
{
final
ArrayList
<
MediaCodecInfo
>
decoderList
=
new
ArrayList
<
MediaCodecInfo
>
(
)
;
for
(
final
MediaCodecInfo
info
:
getCodecList
(
)
)
{
if
(
!
info
.
isEncoder
(
)
)
{
decoderList
.
add
(
info
)
;
}
}
return
decoderList
.
toArray
(
new
MediaCodecInfo
[
0
]
)
;
}
private
static
MediaCodecInfo
[
]
getEncoderInfos
(
)
{
final
ArrayList
<
MediaCodecInfo
>
encoderList
=
new
ArrayList
<
MediaCodecInfo
>
(
)
;
for
(
final
MediaCodecInfo
info
:
getCodecList
(
)
)
{
if
(
info
.
isEncoder
(
)
)
{
encoderList
.
add
(
info
)
;
}
}
return
encoderList
.
toArray
(
new
MediaCodecInfo
[
0
]
)
;
}
WrapForJNI
public
static
String
[
]
getDecoderSupportedMimeTypes
(
)
{
final
Set
<
String
>
mimeTypes
=
new
HashSet
<
>
(
)
;
for
(
final
MediaCodecInfo
info
:
getDecoderInfos
(
)
)
{
mimeTypes
.
addAll
(
Arrays
.
asList
(
info
.
getSupportedTypes
(
)
)
)
;
}
return
mimeTypes
.
toArray
(
new
String
[
0
]
)
;
}
WrapForJNI
public
static
String
[
]
getDecoderSupportedMimeTypesWithAccelInfo
(
)
{
final
Set
<
String
>
mimeTypes
=
new
HashSet
<
>
(
)
;
final
String
[
]
hwPrefixes
=
getAllSupportedHWCodecPrefixes
(
false
)
;
for
(
final
MediaCodecInfo
info
:
getDecoderInfos
(
)
)
{
final
boolean
isHw
=
isHardwareAccelerated
(
info
hwPrefixes
)
;
final
String
[
]
supportedTypes
=
info
.
getSupportedTypes
(
)
;
for
(
final
String
mimeType
:
info
.
getSupportedTypes
(
)
)
{
if
(
!
isHw
)
{
mimeTypes
.
add
(
"
SW
"
+
mimeType
)
;
continue
;
}
final
CodecCapabilities
caps
=
info
.
getCapabilitiesForType
(
mimeType
)
;
if
(
getSupportsYUV420orNV12
(
caps
)
!
=
COLOR_FORMAT_NOT_SUPPORTED
)
{
mimeTypes
.
add
(
"
HW
"
+
mimeType
)
;
}
}
}
for
(
final
String
typeit
:
mimeTypes
)
{
Log
.
d
(
LOGTAG
"
MIME
support
:
"
+
typeit
)
;
}
return
mimeTypes
.
toArray
(
new
String
[
0
]
)
;
}
private
static
boolean
isHardwareAccelerated
(
final
MediaCodecInfo
aCodecInfo
final
String
[
]
aHwPrefixes
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
Q
)
{
return
aCodecInfo
.
isHardwareAccelerated
(
)
;
}
if
(
aHwPrefixes
=
=
null
)
{
return
false
;
}
for
(
final
String
prefix
:
aHwPrefixes
)
{
if
(
aCodecInfo
.
getName
(
)
.
startsWith
(
prefix
)
)
{
return
true
;
}
}
return
false
;
}
public
static
boolean
checkSupportsAdaptivePlayback
(
final
MediaCodec
aCodec
final
String
aMimeType
)
{
if
(
isAdaptivePlaybackBlocklisted
(
aMimeType
)
)
{
return
false
;
}
try
{
final
MediaCodecInfo
info
=
aCodec
.
getCodecInfo
(
)
;
final
MediaCodecInfo
.
CodecCapabilities
capabilities
=
info
.
getCapabilitiesForType
(
aMimeType
)
;
return
capabilities
!
=
null
&
&
capabilities
.
isFeatureSupported
(
MediaCodecInfo
.
CodecCapabilities
.
FEATURE_AdaptivePlayback
)
;
}
catch
(
final
IllegalArgumentException
e
)
{
Log
.
e
(
LOGTAG
"
Retrieve
codec
information
failed
"
e
)
;
}
return
false
;
}
private
static
boolean
isAdaptivePlaybackBlocklisted
(
final
String
aMimeType
)
{
Log
.
d
(
LOGTAG
"
The
device
ModelID
is
"
+
Build
.
MODEL
)
;
if
(
!
aMimeType
.
equals
(
"
video
/
avc
"
)
&
&
!
aMimeType
.
equals
(
"
video
/
avc1
"
)
)
{
return
false
;
}
if
(
!
Build
.
MANUFACTURER
.
toLowerCase
(
Locale
.
ROOT
)
.
equals
(
"
samsung
"
)
)
{
return
false
;
}
for
(
final
String
model
:
adaptivePlaybackBlocklist
)
{
if
(
Build
.
MODEL
.
startsWith
(
model
)
)
{
return
true
;
}
}
return
false
;
}
public
static
boolean
getHWCodecCapability
(
final
String
aMimeType
final
boolean
aIsEncoder
)
{
for
(
final
MediaCodecInfo
info
:
getCodecList
(
)
)
{
if
(
info
.
isEncoder
(
)
!
=
aIsEncoder
)
{
continue
;
}
String
name
=
null
;
for
(
final
String
mimeType
:
info
.
getSupportedTypes
(
)
)
{
if
(
mimeType
.
equals
(
aMimeType
)
)
{
name
=
info
.
getName
(
)
;
break
;
}
}
if
(
name
=
=
null
)
{
continue
;
}
Log
.
d
(
LOGTAG
"
Found
candidate
"
+
(
aIsEncoder
?
"
encoder
"
:
"
decoder
"
)
+
name
)
;
if
(
!
isHardwareAccelerated
(
info
getSupportedHWCodecPrefixes
(
aMimeType
aIsEncoder
)
)
)
{
continue
;
}
final
CodecCapabilities
capabilities
=
info
.
getCapabilitiesForType
(
aMimeType
)
;
for
(
final
int
colorFormat
:
capabilities
.
colorFormats
)
{
Log
.
v
(
LOGTAG
"
Color
:
0x
"
+
Integer
.
toHexString
(
colorFormat
)
)
;
}
for
(
final
MediaCodecInfo
.
CodecProfileLevel
pl
:
capabilities
.
profileLevels
)
{
Log
.
v
(
LOGTAG
"
Profile
:
0x
"
+
Integer
.
toHexString
(
pl
.
profile
)
+
"
/
Level
=
0x
"
+
Integer
.
toHexString
(
pl
.
level
)
)
;
}
final
int
codecColorFormat
=
getSupportsYUV420orNV12
(
capabilities
)
;
if
(
codecColorFormat
!
=
COLOR_FORMAT_NOT_SUPPORTED
)
{
Log
.
d
(
LOGTAG
"
Found
target
"
+
(
aIsEncoder
?
"
encoder
"
:
"
decoder
"
)
+
name
+
"
.
Color
:
0x
"
+
Integer
.
toHexString
(
codecColorFormat
)
)
;
return
true
;
}
}
return
false
;
}
private
static
int
getSupportsYUV420orNV12
(
final
CodecCapabilities
aCodecCaps
)
{
for
(
final
int
supportedColorFormat
:
supportedColorList
)
{
for
(
final
int
codecColorFormat
:
aCodecCaps
.
colorFormats
)
{
if
(
codecColorFormat
=
=
supportedColorFormat
)
{
return
codecColorFormat
;
}
}
}
return
COLOR_FORMAT_NOT_SUPPORTED
;
}
private
static
String
[
]
getSupportedHWCodecPrefixes
(
final
String
aMimeType
final
boolean
aIsEncoder
)
{
if
(
aMimeType
.
equals
(
H264_MIME_TYPE
)
|
|
aMimeType
.
equals
(
HEVC_MIME_TYPE
)
|
|
aMimeType
.
equals
(
AV1_MIME_TYPE
)
)
{
return
supportedGenericHwCodecPrefixes
;
}
if
(
aMimeType
.
equals
(
VP9_MIME_TYPE
)
)
{
return
supportedVp9HwCodecPrefixes
;
}
if
(
aMimeType
.
equals
(
VP8_MIME_TYPE
)
)
{
return
aIsEncoder
?
supportedVp8HwEncCodecPrefixes
:
supportedVp8HwDecCodecPrefixes
;
}
return
null
;
}
private
static
String
[
]
getAllSupportedHWCodecPrefixes
(
final
boolean
aIsEncoder
)
{
final
Set
<
String
>
prefixes
=
new
HashSet
<
>
(
)
;
final
String
[
]
mimeTypes
=
{
H264_MIME_TYPE
HEVC_MIME_TYPE
AV1_MIME_TYPE
VP8_MIME_TYPE
VP9_MIME_TYPE
}
;
for
(
final
String
mt
:
mimeTypes
)
{
prefixes
.
addAll
(
Arrays
.
asList
(
getSupportedHWCodecPrefixes
(
mt
aIsEncoder
)
)
)
;
}
return
prefixes
.
toArray
(
new
String
[
0
]
)
;
}
WrapForJNI
public
static
boolean
hasHWVP8
(
final
boolean
aIsEncoder
)
{
return
getHWCodecCapability
(
VP8_MIME_TYPE
aIsEncoder
)
;
}
WrapForJNI
public
static
boolean
hasHWVP9
(
final
boolean
aIsEncoder
)
{
return
getHWCodecCapability
(
VP9_MIME_TYPE
aIsEncoder
)
;
}
WrapForJNI
public
static
boolean
hasHWAV1
(
final
boolean
aIsEncoder
)
{
return
getHWCodecCapability
(
AV1_MIME_TYPE
aIsEncoder
)
;
}
WrapForJNI
public
static
boolean
hasHWHEVC
(
final
boolean
aIsEncoder
)
{
return
getHWCodecCapability
(
HEVC_MIME_TYPE
aIsEncoder
)
;
}
WrapForJNI
public
static
boolean
hasHWH264
(
final
boolean
aIsEncoder
)
{
return
getHWCodecCapability
(
H264_MIME_TYPE
aIsEncoder
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
static
boolean
hasHWH264
(
)
{
return
getHWCodecCapability
(
H264_MIME_TYPE
true
)
&
&
getHWCodecCapability
(
H264_MIME_TYPE
false
)
;
}
WrapForJNI
public
static
boolean
decodes10Bit
(
final
String
aMimeType
)
{
final
MediaCodecList
codecs
=
new
MediaCodecList
(
MediaCodecList
.
REGULAR_CODECS
)
;
for
(
final
MediaCodecInfo
info
:
codecs
.
getCodecInfos
(
)
)
{
if
(
info
.
isEncoder
(
)
)
{
continue
;
}
try
{
for
(
final
MediaCodecInfo
.
CodecProfileLevel
pl
:
info
.
getCapabilitiesForType
(
aMimeType
)
.
profileLevels
)
{
if
(
(
aMimeType
.
equals
(
H264_MIME_TYPE
)
&
&
pl
.
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
AVCProfileHigh10
)
|
|
(
aMimeType
.
equals
(
VP9_MIME_TYPE
)
&
&
is10BitVP9Profile
(
pl
.
profile
)
)
|
|
(
aMimeType
.
equals
(
HEVC_MIME_TYPE
)
&
&
is10BitHEVCProfile
(
pl
.
profile
)
)
|
|
(
aMimeType
.
equals
(
AV1_MIME_TYPE
)
&
&
is10BitAV1Profile
(
pl
.
profile
)
)
)
{
return
true
;
}
}
}
catch
(
final
IllegalArgumentException
e
)
{
continue
;
}
}
return
false
;
}
private
static
boolean
is10BitVP9Profile
(
final
int
profile
)
{
if
(
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
VP9Profile2
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
VP9Profile3
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
VP9Profile2HDR
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
VP9Profile3HDR
)
)
{
return
true
;
}
return
Build
.
VERSION
.
SDK_INT
>
=
29
&
&
(
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
VP9Profile2HDR10Plus
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
VP9Profile3HDR10Plus
)
)
;
}
private
static
boolean
is10BitHEVCProfile
(
final
int
profile
)
{
if
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
HEVCProfileMain10
)
{
return
true
;
}
if
(
Build
.
VERSION
.
SDK_INT
<
29
)
{
return
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
HEVCProfileMain10HDR10
;
}
return
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
HEVCProfileMain10HDR10
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
HEVCProfileMain10HDR10Plus
)
;
}
private
static
boolean
is10BitAV1Profile
(
final
int
profile
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
29
)
{
return
false
;
}
return
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
AV1ProfileMain10
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
AV1ProfileMain10HDR10
)
|
|
(
profile
=
=
MediaCodecInfo
.
CodecProfileLevel
.
AV1ProfileMain10HDR10Plus
)
;
}
}
