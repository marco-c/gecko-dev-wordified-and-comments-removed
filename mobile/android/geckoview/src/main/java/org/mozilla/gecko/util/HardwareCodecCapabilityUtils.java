package
org
.
mozilla
.
gecko
.
util
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodecInfo
;
import
android
.
media
.
MediaCodecInfo
.
CodecCapabilities
;
import
android
.
media
.
MediaCodecList
;
import
android
.
os
.
Build
;
import
android
.
util
.
Log
;
import
java
.
util
.
Locale
;
public
final
class
HardwareCodecCapabilityUtils
{
private
static
final
String
LOGTAG
=
"
GeckoHardwareCodecCapabilityUtils
"
;
private
static
final
String
[
]
supportedVp8HwEncCodecPrefixes
=
{
"
OMX
.
qcom
.
"
"
OMX
.
Intel
.
"
}
;
private
static
final
String
[
]
supportedVp8HwDecCodecPrefixes
=
{
"
OMX
.
qcom
.
"
"
OMX
.
Nvidia
.
"
"
OMX
.
Exynos
.
"
"
OMX
.
Intel
.
"
}
;
private
static
final
String
VP8_MIME_TYPE
=
"
video
/
x
-
vnd
.
on2
.
vp8
"
;
private
static
final
String
VP9_MIME_TYPE
=
"
video
/
x
-
vnd
.
on2
.
vp9
"
;
private
static
final
int
COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m
=
0x7FA30C04
;
private
static
final
int
[
]
supportedColorList
=
{
CodecCapabilities
.
COLOR_FormatYUV420Planar
CodecCapabilities
.
COLOR_FormatYUV420SemiPlanar
CodecCapabilities
.
COLOR_QCOM_FormatYUV420SemiPlanar
COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m
}
;
private
static
final
String
[
]
adaptivePlaybackBlacklist
=
{
"
GT
-
I9300
"
"
SCH
-
I535
"
}
;
WrapForJNI
public
static
boolean
findDecoderCodecInfoForMimeType
(
String
aMimeType
)
{
int
numCodecs
=
0
;
try
{
numCodecs
=
MediaCodecList
.
getCodecCount
(
)
;
}
catch
(
final
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
retrieve
media
codec
count
"
e
)
;
return
false
;
}
for
(
int
i
=
0
;
i
<
numCodecs
;
+
+
i
)
{
MediaCodecInfo
info
=
MediaCodecList
.
getCodecInfoAt
(
i
)
;
if
(
info
.
isEncoder
(
)
)
{
continue
;
}
for
(
String
mimeType
:
info
.
getSupportedTypes
(
)
)
{
if
(
mimeType
.
equals
(
aMimeType
)
)
{
return
true
;
}
}
}
return
false
;
}
WrapForJNI
public
static
boolean
checkSupportsAdaptivePlayback
(
MediaCodec
aCodec
String
aMimeType
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
|
|
isAdaptivePlaybackBlacklisted
(
aMimeType
)
)
{
return
false
;
}
try
{
MediaCodecInfo
info
=
aCodec
.
getCodecInfo
(
)
;
MediaCodecInfo
.
CodecCapabilities
capabilities
=
info
.
getCapabilitiesForType
(
aMimeType
)
;
return
capabilities
!
=
null
&
&
capabilities
.
isFeatureSupported
(
MediaCodecInfo
.
CodecCapabilities
.
FEATURE_AdaptivePlayback
)
;
}
catch
(
IllegalArgumentException
e
)
{
Log
.
e
(
LOGTAG
"
Retrieve
codec
information
failed
"
e
)
;
}
return
false
;
}
private
static
boolean
isAdaptivePlaybackBlacklisted
(
String
aMimeType
)
{
if
(
!
aMimeType
.
equals
(
"
video
/
avc
"
)
&
&
!
aMimeType
.
equals
(
"
video
/
avc1
"
)
)
{
return
false
;
}
if
(
!
Build
.
VERSION
.
RELEASE
.
equals
(
"
4
.
4
.
2
"
)
)
{
return
false
;
}
if
(
!
Build
.
MANUFACTURER
.
toLowerCase
(
Locale
.
getDefault
(
)
)
.
equals
(
"
samsung
"
)
)
{
return
false
;
}
for
(
String
model
:
adaptivePlaybackBlacklist
)
{
if
(
Build
.
MODEL
.
startsWith
(
model
)
)
{
return
true
;
}
}
return
false
;
}
public
static
boolean
getHWEncoderCapability
(
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
20
)
{
for
(
int
i
=
0
;
i
<
MediaCodecList
.
getCodecCount
(
)
;
+
+
i
)
{
MediaCodecInfo
info
=
MediaCodecList
.
getCodecInfoAt
(
i
)
;
if
(
!
info
.
isEncoder
(
)
)
{
continue
;
}
String
name
=
null
;
for
(
String
mimeType
:
info
.
getSupportedTypes
(
)
)
{
if
(
mimeType
.
equals
(
VP8_MIME_TYPE
)
)
{
name
=
info
.
getName
(
)
;
break
;
}
}
if
(
name
=
=
null
)
{
continue
;
}
Log
.
e
(
LOGTAG
"
Found
candidate
encoder
"
+
name
)
;
boolean
supportedCodec
=
false
;
for
(
String
codecPrefix
:
supportedVp8HwEncCodecPrefixes
)
{
if
(
name
.
startsWith
(
codecPrefix
)
)
{
supportedCodec
=
true
;
break
;
}
}
if
(
!
supportedCodec
)
{
continue
;
}
CodecCapabilities
capabilities
=
info
.
getCapabilitiesForType
(
VP8_MIME_TYPE
)
;
for
(
int
colorFormat
:
capabilities
.
colorFormats
)
{
Log
.
v
(
LOGTAG
"
Color
:
0x
"
+
Integer
.
toHexString
(
colorFormat
)
)
;
}
for
(
int
supportedColorFormat
:
supportedColorList
)
{
for
(
int
codecColorFormat
:
capabilities
.
colorFormats
)
{
if
(
codecColorFormat
=
=
supportedColorFormat
)
{
Log
.
e
(
LOGTAG
"
Found
target
encoder
"
+
name
+
"
.
Color
:
0x
"
+
Integer
.
toHexString
(
codecColorFormat
)
)
;
return
true
;
}
}
}
}
}
return
false
;
}
public
static
boolean
getHWDecoderCapability
(
)
{
return
getHWDecoderCapability
(
VP8_MIME_TYPE
)
;
}
WrapForJNI
public
static
boolean
HasHWVP9
(
)
{
return
getHWDecoderCapability
(
VP9_MIME_TYPE
)
;
}
public
static
boolean
getHWDecoderCapability
(
String
aMimeType
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
20
)
{
for
(
int
i
=
0
;
i
<
MediaCodecList
.
getCodecCount
(
)
;
+
+
i
)
{
MediaCodecInfo
info
=
MediaCodecList
.
getCodecInfoAt
(
i
)
;
if
(
info
.
isEncoder
(
)
)
{
continue
;
}
String
name
=
null
;
for
(
String
mimeType
:
info
.
getSupportedTypes
(
)
)
{
if
(
mimeType
.
equals
(
aMimeType
)
)
{
name
=
info
.
getName
(
)
;
break
;
}
}
if
(
name
=
=
null
)
{
continue
;
}
Log
.
e
(
LOGTAG
"
Found
candidate
decoder
"
+
name
)
;
boolean
supportedCodec
=
false
;
for
(
String
codecPrefix
:
supportedVp8HwDecCodecPrefixes
)
{
if
(
name
.
startsWith
(
codecPrefix
)
)
{
supportedCodec
=
true
;
break
;
}
}
if
(
!
supportedCodec
)
{
continue
;
}
CodecCapabilities
capabilities
=
info
.
getCapabilitiesForType
(
aMimeType
)
;
for
(
int
colorFormat
:
capabilities
.
colorFormats
)
{
Log
.
v
(
LOGTAG
"
Color
:
0x
"
+
Integer
.
toHexString
(
colorFormat
)
)
;
}
for
(
int
supportedColorFormat
:
supportedColorList
)
{
for
(
int
codecColorFormat
:
capabilities
.
colorFormats
)
{
if
(
codecColorFormat
=
=
supportedColorFormat
)
{
Log
.
e
(
LOGTAG
"
Found
target
decoder
"
+
name
+
"
.
Color
:
0x
"
+
Integer
.
toHexString
(
codecColorFormat
)
)
;
return
true
;
}
}
}
}
}
return
false
;
}
}
