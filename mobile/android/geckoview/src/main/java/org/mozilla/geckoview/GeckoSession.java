package
org
.
mozilla
.
geckoview
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
lang
.
ref
.
WeakReference
;
import
java
.
security
.
cert
.
CertificateException
;
import
java
.
security
.
cert
.
CertificateFactory
;
import
java
.
security
.
cert
.
X509Certificate
;
import
java
.
util
.
AbstractSequentialList
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
ListIterator
;
import
java
.
util
.
Map
;
import
java
.
util
.
NoSuchElementException
;
import
java
.
util
.
Set
;
import
java
.
util
.
UUID
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
import
org
.
mozilla
.
gecko
.
IGeckoEditableParent
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
NativeQueue
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
database
.
Cursor
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Binder
;
import
android
.
os
.
IBinder
;
import
android
.
os
.
IInterface
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
support
.
annotation
.
LongDef
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
StringDef
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Base64
;
import
android
.
util
.
Log
;
import
android
.
util
.
LongSparseArray
;
import
android
.
util
.
SparseArray
;
import
android
.
view
.
Surface
;
import
android
.
view
.
inputmethod
.
CursorAnchorInfo
;
import
android
.
view
.
inputmethod
.
ExtractedText
;
import
android
.
view
.
inputmethod
.
ExtractedTextRequest
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewStructure
;
public
class
GeckoSession
implements
Parcelable
{
private
static
final
String
LOGTAG
=
"
GeckoSession
"
;
private
static
final
boolean
DEBUG
=
false
;
private
static
final
int
WINDOW_CLOSE
=
0
;
private
static
final
int
WINDOW_OPEN
=
1
;
private
static
final
int
WINDOW_TRANSFER_OUT
=
2
;
private
static
final
int
WINDOW_TRANSFER_IN
=
3
;
private
enum
State
implements
NativeQueue
.
State
{
INITIAL
(
0
)
READY
(
1
)
;
private
final
int
mRank
;
private
State
(
final
int
rank
)
{
mRank
=
rank
;
}
Override
public
boolean
is
(
final
NativeQueue
.
State
other
)
{
return
this
=
=
other
;
}
Override
public
boolean
isAtLeast
(
final
NativeQueue
.
State
other
)
{
return
(
other
instanceof
State
)
&
&
mRank
>
=
(
(
State
)
other
)
.
mRank
;
}
}
private
final
NativeQueue
mNativeQueue
=
new
NativeQueue
(
State
.
INITIAL
State
.
READY
)
;
private
final
EventDispatcher
mEventDispatcher
=
new
EventDispatcher
(
mNativeQueue
)
;
private
final
SessionTextInput
mTextInput
=
new
SessionTextInput
(
this
mNativeQueue
)
;
private
SessionAccessibility
mAccessibility
;
private
SessionFinder
mFinder
;
private
String
mId
=
UUID
.
randomUUID
(
)
.
toString
(
)
.
replace
(
"
-
"
"
"
)
;
String
getId
(
)
{
return
mId
;
}
private
boolean
mShouldPinOnScreen
;
private
PanZoomController
mPanZoomController
=
new
PanZoomController
(
this
)
;
private
OverscrollEdgeEffect
mOverscroll
;
private
CompositorController
mController
;
private
Autofill
.
Support
mAutofillSupport
;
private
boolean
mAttachedCompositor
;
private
boolean
mCompositorReady
;
private
Surface
mSurface
;
private
int
mLeft
;
private
int
mTop
;
private
int
mClientTop
;
private
int
mOffsetX
;
private
int
mOffsetY
;
private
int
mWidth
;
private
int
mHeight
;
private
int
mClientHeight
;
private
int
mFixedBottomOffset
=
0
;
private
int
mDynamicToolbarMaxHeight
=
0
;
private
float
mViewportLeft
;
private
float
mViewportTop
;
private
float
mViewportZoom
=
1
.
0f
;
final
static
int
FIRST_PAINT
=
0
;
final
static
int
LAYERS_UPDATED
=
1
;
final
static
int
COMPOSITOR_CONTROLLER_OPEN
=
2
;
final
static
int
IS_COMPOSITOR_CONTROLLER_OPEN
=
3
;
class
Compositor
extends
JNIObject
{
public
boolean
isReady
(
)
{
return
GeckoSession
.
this
.
isCompositorReady
(
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
onCompositorAttached
(
)
{
GeckoSession
.
this
.
onCompositorAttached
(
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
onCompositorDetached
(
)
{
GeckoSession
.
this
.
onCompositorDetached
(
)
;
}
WrapForJNI
(
dispatchTo
=
"
gecko
"
)
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
public
native
void
attachNPZC
(
PanZoomController
.
NativeProvider
npzc
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
public
native
void
onBoundsChanged
(
int
left
int
top
int
width
int
height
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
public
native
void
setDynamicToolbarMaxHeight
(
int
height
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
syncPauseCompositor
(
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
syncResumeResizeCompositor
(
int
x
int
y
int
width
int
height
Object
surface
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
setMaxToolbarHeight
(
int
height
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
public
native
void
setFixedBottomOffset
(
int
offset
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
sendToolbarAnimatorMessage
(
int
message
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
recvToolbarAnimatorMessage
(
final
int
message
)
{
GeckoSession
.
this
.
handleCompositorMessage
(
message
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
setDefaultClearColor
(
int
color
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
native
void
requestScreenPixels
(
final
GeckoResult
<
Bitmap
>
result
final
Bitmap
target
final
int
x
final
int
y
final
int
srcWidth
final
int
srcHeight
final
int
outWidth
final
int
outHeight
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
current
"
)
public
native
void
enableLayerUpdateNotifications
(
boolean
enable
)
;
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
updateRootFrameMetrics
(
final
float
scrollX
final
float
scrollY
final
float
zoom
)
{
GeckoSession
.
this
.
onMetricsChanged
(
scrollX
scrollY
zoom
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
updateOverscrollVelocity
(
final
float
x
final
float
y
)
{
GeckoSession
.
this
.
updateOverscrollVelocity
(
x
y
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
updateOverscrollOffset
(
final
float
x
final
float
y
)
{
GeckoSession
.
this
.
updateOverscrollOffset
(
x
y
)
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
dispatchTo
=
"
gecko
"
)
public
native
void
onSafeAreaInsetsChanged
(
int
top
int
right
int
bottom
int
left
)
;
Override
protected
void
finalize
(
)
throws
Throwable
{
disposeNative
(
)
;
}
}
final
Compositor
mCompositor
=
new
Compositor
(
)
;
WrapForJNI
(
stubName
=
"
GetCompositor
"
calledFrom
=
"
ui
"
)
private
Object
getCompositorFromNative
(
)
{
return
mCompositorReady
?
mCompositor
:
null
;
}
private
final
GeckoSessionHandler
<
HistoryDelegate
>
mHistoryHandler
=
new
GeckoSessionHandler
<
HistoryDelegate
>
(
"
GeckoViewHistory
"
this
new
String
[
]
{
"
GeckoView
:
OnVisited
"
"
GeckoView
:
GetVisited
"
"
GeckoView
:
StateUpdated
"
}
)
{
Override
public
void
handleMessage
(
final
HistoryDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
OnVisited
"
.
equals
(
event
)
)
{
final
GeckoResult
<
Boolean
>
result
=
delegate
.
onVisited
(
GeckoSession
.
this
message
.
getString
(
"
url
"
)
message
.
getString
(
"
lastVisitedURL
"
)
message
.
getInt
(
"
flags
"
)
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
false
)
;
return
;
}
result
.
accept
(
visited
-
>
callback
.
sendSuccess
(
visited
.
booleanValue
(
)
)
exception
-
>
callback
.
sendSuccess
(
false
)
)
;
}
else
if
(
"
GeckoView
:
GetVisited
"
.
equals
(
event
)
)
{
final
String
[
]
urls
=
message
.
getStringArray
(
"
urls
"
)
;
final
GeckoResult
<
boolean
[
]
>
result
=
delegate
.
getVisited
(
GeckoSession
.
this
urls
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
result
.
accept
(
visited
-
>
callback
.
sendSuccess
(
visited
)
exception
-
>
callback
.
sendError
(
"
Failed
to
fetch
visited
statuses
for
URIs
"
)
)
;
}
else
if
(
"
GeckoView
:
StateUpdated
"
.
equals
(
event
)
)
{
final
GeckoBundle
update
=
message
.
getBundle
(
"
data
"
)
;
if
(
update
=
=
null
)
{
return
;
}
final
int
previousHistorySize
=
mStateCache
.
size
(
)
;
mStateCache
.
updateSessionState
(
update
)
;
ProgressDelegate
progressDelegate
=
getProgressDelegate
(
)
;
if
(
progressDelegate
!
=
null
)
{
progressDelegate
.
onSessionStateChange
(
GeckoSession
.
this
new
SessionState
(
mStateCache
)
)
;
}
if
(
update
.
getBundle
(
"
historychange
"
)
!
=
null
)
{
final
SessionState
state
=
new
SessionState
(
mStateCache
)
;
delegate
.
onHistoryStateChange
(
GeckoSession
.
this
state
)
;
if
(
(
previousHistorySize
>
1
)
&
&
(
state
.
size
(
)
=
=
1
)
&
&
mNavigationHandler
.
getDelegate
(
)
!
=
null
)
{
mNavigationHandler
.
getDelegate
(
)
.
onCanGoForward
(
GeckoSession
.
this
false
)
;
mNavigationHandler
.
getDelegate
(
)
.
onCanGoBack
(
GeckoSession
.
this
false
)
;
}
}
}
}
}
;
private
final
WebExtension
.
SessionController
mWebExtensionController
;
private
final
GeckoSessionHandler
<
ContentDelegate
>
mContentHandler
=
new
GeckoSessionHandler
<
ContentDelegate
>
(
"
GeckoViewContent
"
this
new
String
[
]
{
"
GeckoView
:
ContentCrash
"
"
GeckoView
:
ContentKill
"
"
GeckoView
:
ContextMenu
"
"
GeckoView
:
DOMMetaViewportFit
"
"
GeckoView
:
DOMTitleChanged
"
"
GeckoView
:
DOMWindowClose
"
"
GeckoView
:
ExternalResponse
"
"
GeckoView
:
FocusRequest
"
"
GeckoView
:
FullScreenEnter
"
"
GeckoView
:
FullScreenExit
"
"
GeckoView
:
WebAppManifest
"
"
GeckoView
:
FirstContentfulPaint
"
"
GeckoView
:
PaintStatusReset
"
}
)
{
Override
public
void
handleMessage
(
final
ContentDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ContentCrash
"
.
equals
(
event
)
)
{
close
(
)
;
delegate
.
onCrash
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
ContentKill
"
.
equals
(
event
)
)
{
close
(
)
;
delegate
.
onKill
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
ContextMenu
"
.
equals
(
event
)
)
{
final
ContentDelegate
.
ContextElement
elem
=
new
ContentDelegate
.
ContextElement
(
message
.
getString
(
"
baseUri
"
)
message
.
getString
(
"
uri
"
)
message
.
getString
(
"
title
"
)
message
.
getString
(
"
alt
"
)
message
.
getString
(
"
elementType
"
)
message
.
getString
(
"
elementSrc
"
)
)
;
delegate
.
onContextMenu
(
GeckoSession
.
this
message
.
getInt
(
"
screenX
"
)
message
.
getInt
(
"
screenY
"
)
elem
)
;
}
else
if
(
"
GeckoView
:
DOMMetaViewportFit
"
.
equals
(
event
)
)
{
delegate
.
onMetaViewportFitChange
(
GeckoSession
.
this
message
.
getString
(
"
viewportfit
"
)
)
;
}
else
if
(
"
GeckoView
:
DOMTitleChanged
"
.
equals
(
event
)
)
{
delegate
.
onTitleChange
(
GeckoSession
.
this
message
.
getString
(
"
title
"
)
)
;
}
else
if
(
"
GeckoView
:
FocusRequest
"
.
equals
(
event
)
)
{
delegate
.
onFocusRequest
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
DOMWindowClose
"
.
equals
(
event
)
)
{
delegate
.
onCloseRequest
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
FullScreenEnter
"
.
equals
(
event
)
)
{
delegate
.
onFullScreen
(
GeckoSession
.
this
true
)
;
}
else
if
(
"
GeckoView
:
FullScreenExit
"
.
equals
(
event
)
)
{
delegate
.
onFullScreen
(
GeckoSession
.
this
false
)
;
}
else
if
(
"
GeckoView
:
ExternalResponse
"
.
equals
(
event
)
)
{
delegate
.
onExternalResponse
(
GeckoSession
.
this
new
WebResponseInfo
(
message
)
)
;
}
else
if
(
"
GeckoView
:
WebAppManifest
"
.
equals
(
event
)
)
{
final
GeckoBundle
manifest
=
message
.
getBundle
(
"
manifest
"
)
;
if
(
manifest
=
=
null
)
{
return
;
}
try
{
delegate
.
onWebAppManifest
(
GeckoSession
.
this
fixupWebAppManifest
(
manifest
.
toJSONObject
(
)
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
convert
web
app
manifest
to
JSON
"
e
)
;
}
}
else
if
(
"
GeckoView
:
FirstContentfulPaint
"
.
equals
(
event
)
)
{
delegate
.
onFirstContentfulPaint
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
PaintStatusReset
"
.
equals
(
event
)
)
{
delegate
.
onPaintStatusReset
(
GeckoSession
.
this
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
NavigationDelegate
>
mNavigationHandler
=
new
GeckoSessionHandler
<
NavigationDelegate
>
(
"
GeckoViewNavigation
"
this
new
String
[
]
{
"
GeckoView
:
LocationChange
"
"
GeckoView
:
OnNewSession
"
}
new
String
[
]
{
"
GeckoView
:
OnLoadError
"
"
GeckoView
:
OnLoadRequest
"
}
)
{
private
int
convertGeckoTarget
(
final
int
geckoTarget
)
{
switch
(
geckoTarget
)
{
case
0
:
case
1
:
return
NavigationDelegate
.
TARGET_WINDOW_CURRENT
;
default
:
return
NavigationDelegate
.
TARGET_WINDOW_NEW
;
}
}
Override
public
void
handleDefaultMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
OnLoadRequest
"
.
equals
(
event
)
)
{
callback
.
sendSuccess
(
false
)
;
}
else
if
(
"
GeckoView
:
OnLoadError
"
.
equals
(
event
)
)
{
callback
.
sendSuccess
(
null
)
;
}
else
{
super
.
handleDefaultMessage
(
event
message
callback
)
;
}
}
Override
public
void
handleMessage
(
final
NavigationDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
Log
.
d
(
LOGTAG
"
handleMessage
"
+
event
+
"
uri
=
"
+
message
.
getString
(
"
uri
"
)
)
;
if
(
"
GeckoView
:
LocationChange
"
.
equals
(
event
)
)
{
if
(
message
.
getBoolean
(
"
isTopLevel
"
)
)
{
delegate
.
onLocationChange
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
)
;
}
delegate
.
onCanGoBack
(
GeckoSession
.
this
message
.
getBoolean
(
"
canGoBack
"
)
)
;
delegate
.
onCanGoForward
(
GeckoSession
.
this
message
.
getBoolean
(
"
canGoForward
"
)
)
;
}
else
if
(
"
GeckoView
:
OnLoadRequest
"
.
equals
(
event
)
)
{
final
NavigationDelegate
.
LoadRequest
request
=
new
NavigationDelegate
.
LoadRequest
(
message
.
getString
(
"
uri
"
)
message
.
getString
(
"
triggerUri
"
)
message
.
getInt
(
"
where
"
)
message
.
getInt
(
"
flags
"
)
message
.
getBoolean
(
"
hasUserGesture
"
)
false
)
;
if
(
!
IntentUtils
.
isUriSafeForScheme
(
request
.
uri
)
)
{
callback
.
sendError
(
"
Blocked
unsafe
intent
URI
"
)
;
delegate
.
onLoadError
(
GeckoSession
.
this
request
.
uri
new
WebRequestError
(
WebRequestError
.
ERROR_MALFORMED_URI
WebRequestError
.
ERROR_CATEGORY_URI
null
)
)
;
return
;
}
final
GeckoResult
<
AllowOrDeny
>
result
=
delegate
.
onLoadRequest
(
GeckoSession
.
this
request
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
result
.
accept
(
value
-
>
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
value
=
=
AllowOrDeny
.
ALLOW
)
{
callback
.
sendSuccess
(
false
)
;
}
else
if
(
value
=
=
AllowOrDeny
.
DENY
)
{
callback
.
sendSuccess
(
true
)
;
}
else
{
callback
.
sendError
(
"
Invalid
response
"
)
;
}
}
exception
-
>
callback
.
sendError
(
exception
.
getMessage
(
)
)
)
;
}
else
if
(
"
GeckoView
:
OnLoadError
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
long
errorCode
=
message
.
getLong
(
"
error
"
)
;
final
int
errorModule
=
message
.
getInt
(
"
errorModule
"
)
;
final
int
errorClass
=
message
.
getInt
(
"
errorClass
"
)
;
final
WebRequestError
err
=
WebRequestError
.
fromGeckoError
(
errorCode
errorModule
errorClass
null
)
;
final
GeckoResult
<
String
>
result
=
delegate
.
onLoadError
(
GeckoSession
.
this
uri
err
)
;
if
(
result
=
=
null
)
{
callback
.
sendError
(
"
abort
"
)
;
return
;
}
result
.
accept
(
url
-
>
{
if
(
url
=
=
null
)
{
callback
.
sendError
(
"
abort
"
)
;
}
else
{
callback
.
sendSuccess
(
url
)
;
}
}
exception
-
>
callback
.
sendError
(
exception
.
getMessage
(
)
)
)
;
}
else
if
(
"
GeckoView
:
OnNewSession
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
GeckoResult
<
GeckoSession
>
result
=
delegate
.
onNewSession
(
GeckoSession
.
this
uri
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
result
.
accept
(
session
-
>
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
session
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
if
(
session
.
isOpen
(
)
)
{
throw
new
IllegalArgumentException
(
"
Must
use
an
unopened
GeckoSession
instance
"
)
;
}
if
(
GeckoSession
.
this
.
mWindow
=
=
null
)
{
callback
.
sendError
(
"
Session
is
not
attached
to
a
window
"
)
;
}
else
{
session
.
open
(
GeckoSession
.
this
.
mWindow
.
runtime
)
;
callback
.
sendSuccess
(
session
.
getId
(
)
)
;
}
}
exception
-
>
callback
.
sendError
(
exception
.
getMessage
(
)
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
ContentDelegate
>
mProcessHangHandler
=
new
GeckoSessionHandler
<
ContentDelegate
>
(
"
GeckoViewProcessHangMonitor
"
this
new
String
[
]
{
"
GeckoView
:
HangReport
"
}
)
{
Override
protected
void
handleMessage
(
final
ContentDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
eventCallback
)
{
Log
.
d
(
LOGTAG
"
handleMessage
"
+
event
+
"
uri
=
"
+
message
.
getString
(
"
uri
"
)
)
;
GeckoResult
<
SlowScriptResponse
>
result
=
delegate
.
onSlowScript
(
GeckoSession
.
this
message
.
getString
(
"
scriptFileName
"
)
)
;
if
(
result
!
=
null
)
{
final
int
mReportId
=
message
.
getInt
(
"
hangId
"
)
;
result
.
accept
(
stopOrContinue
-
>
{
if
(
stopOrContinue
!
=
null
)
{
final
GeckoBundle
bundle
=
new
GeckoBundle
(
)
;
bundle
.
putInt
(
"
hangId
"
mReportId
)
;
switch
(
stopOrContinue
)
{
case
STOP
:
mEventDispatcher
.
dispatch
(
"
GeckoView
:
HangReportStop
"
bundle
)
;
break
;
case
CONTINUE
:
mEventDispatcher
.
dispatch
(
"
GeckoView
:
HangReportWait
"
bundle
)
;
break
;
}
}
}
)
;
}
else
{
final
GeckoBundle
bundle
=
new
GeckoBundle
(
)
;
bundle
.
putInt
(
"
hangId
"
message
.
getInt
(
"
hangId
"
)
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
HangReportStop
"
bundle
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
ProgressDelegate
>
mProgressHandler
=
new
GeckoSessionHandler
<
ProgressDelegate
>
(
"
GeckoViewProgress
"
this
new
String
[
]
{
"
GeckoView
:
PageStart
"
"
GeckoView
:
PageStop
"
"
GeckoView
:
ProgressChanged
"
"
GeckoView
:
SecurityChanged
"
"
GeckoView
:
StateUpdated
"
}
)
{
Override
public
void
handleMessage
(
final
ProgressDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
Log
.
d
(
LOGTAG
"
handleMessage
"
+
event
+
"
uri
=
"
+
message
.
getString
(
"
uri
"
)
)
;
if
(
"
GeckoView
:
PageStart
"
.
equals
(
event
)
)
{
delegate
.
onPageStart
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
)
;
}
else
if
(
"
GeckoView
:
PageStop
"
.
equals
(
event
)
)
{
delegate
.
onPageStop
(
GeckoSession
.
this
message
.
getBoolean
(
"
success
"
)
)
;
}
else
if
(
"
GeckoView
:
ProgressChanged
"
.
equals
(
event
)
)
{
delegate
.
onProgressChange
(
GeckoSession
.
this
message
.
getInt
(
"
progress
"
)
)
;
}
else
if
(
"
GeckoView
:
SecurityChanged
"
.
equals
(
event
)
)
{
final
GeckoBundle
identity
=
message
.
getBundle
(
"
identity
"
)
;
delegate
.
onSecurityChange
(
GeckoSession
.
this
new
ProgressDelegate
.
SecurityInformation
(
identity
)
)
;
}
else
if
(
"
GeckoView
:
StateUpdated
"
.
equals
(
event
)
)
{
final
GeckoBundle
update
=
message
.
getBundle
(
"
data
"
)
;
if
(
update
!
=
null
)
{
if
(
getHistoryDelegate
(
)
=
=
null
)
{
mStateCache
.
updateSessionState
(
update
)
;
delegate
.
onSessionStateChange
(
GeckoSession
.
this
new
SessionState
(
mStateCache
)
)
;
}
}
}
}
}
;
private
final
GeckoSessionHandler
<
ScrollDelegate
>
mScrollHandler
=
new
GeckoSessionHandler
<
ScrollDelegate
>
(
"
GeckoViewScroll
"
this
new
String
[
]
{
"
GeckoView
:
ScrollChanged
"
}
)
{
Override
public
void
handleMessage
(
final
ScrollDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ScrollChanged
"
.
equals
(
event
)
)
{
delegate
.
onScrollChanged
(
GeckoSession
.
this
message
.
getInt
(
"
scrollX
"
)
message
.
getInt
(
"
scrollY
"
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
ContentBlocking
.
Delegate
>
mContentBlockingHandler
=
new
GeckoSessionHandler
<
ContentBlocking
.
Delegate
>
(
"
GeckoViewContentBlocking
"
this
new
String
[
]
{
"
GeckoView
:
ContentBlockingEvent
"
}
)
{
Override
public
void
handleMessage
(
final
ContentBlocking
.
Delegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ContentBlockingEvent
"
.
equals
(
event
)
)
{
final
ContentBlocking
.
BlockEvent
be
=
ContentBlocking
.
BlockEvent
.
fromBundle
(
message
)
;
if
(
be
.
isBlocking
(
)
)
{
delegate
.
onContentBlocked
(
GeckoSession
.
this
be
)
;
}
else
{
delegate
.
onContentLoaded
(
GeckoSession
.
this
be
)
;
}
}
}
}
;
private
final
GeckoSessionHandler
<
PermissionDelegate
>
mPermissionHandler
=
new
GeckoSessionHandler
<
PermissionDelegate
>
(
"
GeckoViewPermission
"
this
new
String
[
]
{
"
GeckoView
:
AndroidPermission
"
"
GeckoView
:
ContentPermission
"
"
GeckoView
:
MediaPermission
"
}
)
{
Override
public
void
handleMessage
(
final
PermissionDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
delegate
=
=
null
)
{
callback
.
sendSuccess
(
false
)
;
return
;
}
if
(
"
GeckoView
:
AndroidPermission
"
.
equals
(
event
)
)
{
delegate
.
onAndroidPermissionsRequest
(
GeckoSession
.
this
message
.
getStringArray
(
"
perms
"
)
new
PermissionCallback
(
"
android
"
callback
)
)
;
}
else
if
(
"
GeckoView
:
ContentPermission
"
.
equals
(
event
)
)
{
final
String
typeString
=
message
.
getString
(
"
perm
"
)
;
final
int
type
;
if
(
"
geolocation
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_GEOLOCATION
;
}
else
if
(
"
desktop
-
notification
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_DESKTOP_NOTIFICATION
;
}
else
if
(
"
persistent
-
storage
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_PERSISTENT_STORAGE
;
}
else
if
(
"
xr
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_XR
;
}
else
if
(
"
midi
"
.
equals
(
typeString
)
)
{
callback
.
sendError
(
"
Unsupported
"
)
;
return
;
}
else
if
(
"
autoplay
-
media
-
inaudible
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_AUTOPLAY_INAUDIBLE
;
}
else
if
(
"
autoplay
-
media
-
audible
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_AUTOPLAY_AUDIBLE
;
}
else
if
(
"
media
-
key
-
system
-
access
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_MEDIA_KEY_SYSTEM_ACCESS
;
}
else
{
throw
new
IllegalArgumentException
(
"
Unknown
permission
request
:
"
+
typeString
)
;
}
delegate
.
onContentPermissionRequest
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
type
new
PermissionCallback
(
typeString
callback
)
)
;
}
else
if
(
"
GeckoView
:
MediaPermission
"
.
equals
(
event
)
)
{
GeckoBundle
[
]
videoBundles
=
message
.
getBundleArray
(
"
video
"
)
;
GeckoBundle
[
]
audioBundles
=
message
.
getBundleArray
(
"
audio
"
)
;
PermissionDelegate
.
MediaSource
[
]
videos
=
null
;
PermissionDelegate
.
MediaSource
[
]
audios
=
null
;
if
(
videoBundles
!
=
null
)
{
videos
=
new
PermissionDelegate
.
MediaSource
[
videoBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
videoBundles
.
length
;
i
+
+
)
{
videos
[
i
]
=
new
PermissionDelegate
.
MediaSource
(
videoBundles
[
i
]
)
;
}
}
if
(
audioBundles
!
=
null
)
{
audios
=
new
PermissionDelegate
.
MediaSource
[
audioBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
audioBundles
.
length
;
i
+
+
)
{
audios
[
i
]
=
new
PermissionDelegate
.
MediaSource
(
audioBundles
[
i
]
)
;
}
}
delegate
.
onMediaPermissionRequest
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
videos
audios
new
PermissionCallback
(
"
media
"
callback
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
SelectionActionDelegate
>
mSelectionActionDelegate
=
new
GeckoSessionHandler
<
SelectionActionDelegate
>
(
"
GeckoViewSelectionAction
"
this
new
String
[
]
{
"
GeckoView
:
HideSelectionAction
"
"
GeckoView
:
ShowSelectionAction
"
}
)
{
Override
public
void
handleMessage
(
final
SelectionActionDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ShowSelectionAction
"
.
equals
(
event
)
)
{
final
SelectionActionDelegateAction
HashSet
<
String
>
actionsSet
=
new
HashSet
<
>
(
Arrays
.
asList
(
message
.
getStringArray
(
"
actions
"
)
)
)
;
final
SelectionActionDelegate
.
Selection
selection
=
new
SelectionActionDelegate
.
Selection
(
message
actionsSet
callback
)
;
delegate
.
onShowActionRequest
(
GeckoSession
.
this
selection
)
;
}
else
if
(
"
GeckoView
:
HideSelectionAction
"
.
equals
(
event
)
)
{
final
String
reasonString
=
message
.
getString
(
"
reason
"
)
;
final
int
reason
;
if
(
"
invisibleselection
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_INVISIBLE_SELECTION
;
}
else
if
(
"
presscaret
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_ACTIVE_SELECTION
;
}
else
if
(
"
scroll
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_ACTIVE_SCROLL
;
}
else
if
(
"
visibilitychange
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_NO_SELECTION
;
}
else
{
throw
new
IllegalArgumentException
(
)
;
}
delegate
.
onHideAction
(
GeckoSession
.
this
reason
)
;
}
}
}
;
private
LongSparseArray
<
MediaElement
>
mMediaElements
=
new
LongSparseArray
<
>
(
)
;
LongSparseArray
<
MediaElement
>
getMediaElements
(
)
{
return
mMediaElements
;
}
private
final
GeckoSessionHandler
<
MediaDelegate
>
mMediaHandler
=
new
GeckoSessionHandler
<
MediaDelegate
>
(
"
GeckoViewMedia
"
this
new
String
[
]
{
"
GeckoView
:
MediaAdd
"
"
GeckoView
:
MediaRemove
"
"
GeckoView
:
MediaRemoveAll
"
"
GeckoView
:
MediaReadyStateChanged
"
"
GeckoView
:
MediaTimeChanged
"
"
GeckoView
:
MediaPlaybackStateChanged
"
"
GeckoView
:
MediaMetadataChanged
"
"
GeckoView
:
MediaProgress
"
"
GeckoView
:
MediaVolumeChanged
"
"
GeckoView
:
MediaRateChanged
"
"
GeckoView
:
MediaFullscreenChanged
"
"
GeckoView
:
MediaError
"
"
GeckoView
:
MediaRecordingStatusChanged
"
}
)
{
Override
public
void
handleMessage
(
final
MediaDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
MediaAdd
"
.
equals
(
event
)
)
{
final
MediaElement
element
=
new
MediaElement
(
message
.
getLong
(
"
id
"
)
GeckoSession
.
this
)
;
delegate
.
onMediaAdd
(
GeckoSession
.
this
element
)
;
return
;
}
else
if
(
"
GeckoView
:
MediaRemoveAll
"
.
equals
(
event
)
)
{
for
(
int
i
=
0
;
i
<
mMediaElements
.
size
(
)
;
i
+
+
)
{
final
long
key
=
mMediaElements
.
keyAt
(
i
)
;
delegate
.
onMediaRemove
(
GeckoSession
.
this
mMediaElements
.
get
(
key
)
)
;
}
mMediaElements
.
clear
(
)
;
return
;
}
else
if
(
"
GeckoView
:
MediaRecordingStatusChanged
"
.
equals
(
event
)
)
{
final
GeckoBundle
[
]
deviceBundles
=
message
.
getBundleArray
(
"
devices
"
)
;
final
MediaDelegate
.
RecordingDevice
[
]
devices
=
new
MediaDelegate
.
RecordingDevice
[
deviceBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
deviceBundles
.
length
;
i
+
+
)
{
devices
[
i
]
=
new
MediaDelegate
.
RecordingDevice
(
deviceBundles
[
i
]
)
;
}
delegate
.
onRecordingStatusChanged
(
GeckoSession
.
this
devices
)
;
return
;
}
final
long
id
=
message
.
getLong
(
"
id
"
0
)
;
final
MediaElement
element
=
mMediaElements
.
get
(
id
)
;
if
(
element
=
=
null
)
{
Log
.
w
(
LOGTAG
"
MediaElement
not
found
for
'
"
+
id
+
"
'
"
)
;
return
;
}
if
(
"
GeckoView
:
MediaTimeChanged
"
.
equals
(
event
)
)
{
element
.
notifyTimeChange
(
message
.
getDouble
(
"
time
"
)
)
;
}
else
if
(
"
GeckoView
:
MediaProgress
"
.
equals
(
event
)
)
{
element
.
notifyLoadProgress
(
message
)
;
}
else
if
(
"
GeckoView
:
MediaMetadataChanged
"
.
equals
(
event
)
)
{
element
.
notifyMetadataChange
(
message
)
;
}
else
if
(
"
GeckoView
:
MediaReadyStateChanged
"
.
equals
(
event
)
)
{
element
.
notifyReadyStateChange
(
message
.
getInt
(
"
readyState
"
)
)
;
}
else
if
(
"
GeckoView
:
MediaPlaybackStateChanged
"
.
equals
(
event
)
)
{
element
.
notifyPlaybackStateChange
(
message
.
getString
(
"
playbackState
"
)
)
;
}
else
if
(
"
GeckoView
:
MediaVolumeChanged
"
.
equals
(
event
)
)
{
element
.
notifyVolumeChange
(
message
.
getDouble
(
"
volume
"
)
message
.
getBoolean
(
"
muted
"
)
)
;
}
else
if
(
"
GeckoView
:
MediaRateChanged
"
.
equals
(
event
)
)
{
element
.
notifyPlaybackRateChange
(
message
.
getDouble
(
"
rate
"
)
)
;
}
else
if
(
"
GeckoView
:
MediaFullscreenChanged
"
.
equals
(
event
)
)
{
element
.
notifyFullscreenChange
(
message
.
getBoolean
(
"
fullscreen
"
)
)
;
}
else
if
(
"
GeckoView
:
MediaRemove
"
.
equals
(
event
)
)
{
delegate
.
onMediaRemove
(
GeckoSession
.
this
element
)
;
mMediaElements
.
remove
(
element
.
getVideoId
(
)
)
;
}
else
if
(
"
GeckoView
:
MediaError
"
.
equals
(
event
)
)
{
element
.
notifyError
(
message
.
getInt
(
"
code
"
)
)
;
}
else
{
throw
new
UnsupportedOperationException
(
event
+
"
media
message
not
implemented
"
)
;
}
}
}
;
private
final
MediaSession
.
Handler
mMediaSessionHandler
=
new
MediaSession
.
Handler
(
this
)
;
int
handlersCount
;
private
final
GeckoSessionHandler
<
?
>
[
]
mSessionHandlers
=
new
GeckoSessionHandler
<
?
>
[
]
{
mContentHandler
mHistoryHandler
mMediaHandler
mNavigationHandler
mPermissionHandler
mProcessHangHandler
mProgressHandler
mScrollHandler
mSelectionActionDelegate
mContentBlockingHandler
mMediaSessionHandler
}
;
private
static
class
PermissionCallback
implements
PermissionDelegate
.
Callback
PermissionDelegate
.
MediaCallback
{
private
final
String
mType
;
private
EventCallback
mCallback
;
public
PermissionCallback
(
final
String
type
final
EventCallback
callback
)
{
mType
=
type
;
mCallback
=
callback
;
}
private
void
submit
(
final
Object
response
)
{
if
(
mCallback
!
=
null
)
{
mCallback
.
sendSuccess
(
response
)
;
mCallback
=
null
;
}
}
Override
public
void
grant
(
)
{
if
(
"
media
"
.
equals
(
mType
)
)
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
true
)
;
}
Override
public
void
reject
(
)
{
submit
(
false
)
;
}
Override
public
void
grant
(
final
String
video
final
String
audio
)
{
if
(
!
"
media
"
.
equals
(
mType
)
)
{
throw
new
UnsupportedOperationException
(
)
;
}
final
GeckoBundle
response
=
new
GeckoBundle
(
2
)
;
response
.
putString
(
"
video
"
video
)
;
response
.
putString
(
"
audio
"
audio
)
;
submit
(
response
)
;
}
Override
public
void
grant
(
final
PermissionDelegate
.
MediaSource
video
final
PermissionDelegate
.
MediaSource
audio
)
{
grant
(
video
!
=
null
?
video
.
id
:
null
audio
!
=
null
?
audio
.
id
:
null
)
;
}
}
AnyThread
public
NonNull
GeckoResult
<
String
>
getUserAgent
(
)
{
final
CallbackResult
<
String
>
result
=
new
CallbackResult
<
String
>
(
)
{
Override
public
void
sendSuccess
(
final
Object
value
)
{
complete
(
(
String
)
value
)
;
}
}
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GetUserAgent
"
null
result
)
;
return
result
;
}
AnyThread
public
static
NonNull
String
getDefaultUserAgent
(
)
{
return
BuildConfig
.
USER_AGENT_GECKOVIEW_MOBILE
;
}
UiThread
public
Nullable
PermissionDelegate
getPermissionDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mPermissionHandler
.
getDelegate
(
)
;
}
UiThread
public
void
setPermissionDelegate
(
final
Nullable
PermissionDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mPermissionHandler
.
setDelegate
(
delegate
this
)
;
}
private
PromptDelegate
mPromptDelegate
;
private
final
Listener
mListener
=
new
Listener
(
)
;
static
final
class
Window
extends
JNIObject
implements
IInterface
{
public
final
GeckoRuntime
runtime
;
private
WeakReference
<
GeckoSession
>
mOwner
;
private
NativeQueue
mNativeQueue
;
private
Binder
mBinder
;
public
Window
(
final
NonNull
GeckoRuntime
runtime
final
NonNull
GeckoSession
owner
final
NonNull
NativeQueue
nativeQueue
)
{
this
.
runtime
=
runtime
;
mOwner
=
new
WeakReference
<
>
(
owner
)
;
mNativeQueue
=
nativeQueue
;
}
Override
public
Binder
asBinder
(
)
{
if
(
mBinder
=
=
null
)
{
mBinder
=
new
Binder
(
)
;
mBinder
.
attachInterface
(
this
Window
.
class
.
getName
(
)
)
;
}
return
mBinder
;
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
static
native
void
open
(
Window
instance
NativeQueue
queue
Compositor
compositor
EventDispatcher
dispatcher
SessionAccessibility
.
NativeProvider
sessionAccessibility
GeckoBundle
initData
String
id
String
chromeUri
int
screenId
boolean
privateMode
boolean
isRemote
)
;
Override
public
void
disposeNative
(
)
{
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
nativeDisposeNative
(
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
this
"
nativeDisposeNative
"
)
;
}
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
stubName
=
"
DisposeNative
"
)
private
native
void
nativeDisposeNative
(
)
;
public
void
close
(
)
{
synchronized
(
this
)
{
if
(
mNativeQueue
=
=
null
)
{
return
;
}
mNativeQueue
.
reset
(
State
.
INITIAL
)
;
mNativeQueue
=
null
;
mOwner
=
null
;
}
asBinder
(
)
.
attachInterface
(
null
Window
.
class
.
getName
(
)
)
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
nativeClose
(
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
this
"
nativeClose
"
)
;
}
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
stubName
=
"
Close
"
)
private
native
void
nativeClose
(
)
;
public
synchronized
void
transfer
(
final
GeckoSession
owner
final
NativeQueue
queue
final
Compositor
compositor
final
EventDispatcher
dispatcher
final
SessionAccessibility
.
NativeProvider
sessionAccessibility
final
GeckoBundle
initData
)
{
if
(
mNativeQueue
=
=
null
)
{
return
;
}
final
GeckoSession
oldOwner
=
mOwner
.
get
(
)
;
if
(
oldOwner
!
=
null
&
&
owner
!
=
oldOwner
)
{
oldOwner
.
abandonWindow
(
)
;
}
mOwner
=
new
WeakReference
<
>
(
owner
)
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
nativeTransfer
(
queue
compositor
dispatcher
sessionAccessibility
initData
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
this
"
nativeTransfer
"
NativeQueue
.
class
queue
Compositor
.
class
compositor
EventDispatcher
.
class
dispatcher
SessionAccessibility
.
NativeProvider
.
class
sessionAccessibility
GeckoBundle
.
class
initData
)
;
}
if
(
mNativeQueue
!
=
queue
)
{
mNativeQueue
.
reset
(
State
.
INITIAL
)
;
mNativeQueue
=
queue
;
}
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
stubName
=
"
Transfer
"
)
private
native
void
nativeTransfer
(
NativeQueue
queue
Compositor
compositor
EventDispatcher
dispatcher
SessionAccessibility
.
NativeProvider
sessionAccessibility
GeckoBundle
initData
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
native
void
attachEditable
(
IGeckoEditableParent
parent
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
native
void
attachAccessibility
(
SessionAccessibility
.
NativeProvider
sessionAccessibility
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
native
void
attachMediaSessionController
(
final
MediaSession
.
Controller
controller
final
long
id
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
native
void
detachMediaSessionController
(
final
MediaSession
.
Controller
controller
)
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
synchronized
void
onReady
(
final
Nullable
NativeQueue
queue
)
{
if
(
(
queue
=
=
null
&
&
mNativeQueue
=
=
null
)
|
|
(
queue
!
=
null
&
&
mNativeQueue
!
=
queue
)
)
{
return
;
}
if
(
mNativeQueue
.
checkAndSetState
(
State
.
INITIAL
State
.
READY
)
&
&
queue
=
=
null
)
{
Log
.
i
(
LOGTAG
"
zerdatime
"
+
SystemClock
.
elapsedRealtime
(
)
+
"
-
chrome
startup
finished
"
)
;
}
}
Override
protected
void
finalize
(
)
throws
Throwable
{
close
(
)
;
disposeNative
(
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
GeckoResult
<
Boolean
>
onLoadRequest
(
final
NonNull
String
uri
final
int
windowType
final
int
flags
final
Nullable
String
triggeringUri
final
boolean
hasUserGesture
final
boolean
isTopLevel
)
{
final
GeckoSession
session
=
(
mOwner
=
=
null
)
?
null
:
mOwner
.
get
(
)
;
if
(
session
=
=
null
)
{
return
GeckoResult
.
fromValue
(
false
)
;
}
GeckoResult
<
Boolean
>
res
=
new
GeckoResult
<
>
(
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
NavigationDelegate
delegate
=
session
.
getNavigationDelegate
(
)
;
if
(
delegate
=
=
null
)
{
res
.
complete
(
false
)
;
return
;
}
final
String
trigger
=
TextUtils
.
isEmpty
(
triggeringUri
)
?
null
:
triggeringUri
;
final
NavigationDelegate
.
LoadRequest
req
=
new
NavigationDelegate
.
LoadRequest
(
uri
trigger
windowType
flags
hasUserGesture
false
)
;
final
GeckoResult
<
AllowOrDeny
>
reqResponse
=
isTopLevel
?
delegate
.
onLoadRequest
(
session
req
)
:
delegate
.
onSubframeLoadRequest
(
session
req
)
;
if
(
reqResponse
=
=
null
)
{
res
.
complete
(
false
)
;
return
;
}
reqResponse
.
accept
(
value
-
>
{
if
(
value
=
=
AllowOrDeny
.
DENY
)
{
res
.
complete
(
true
)
;
}
else
{
res
.
complete
(
false
)
;
}
}
ex
-
>
{
res
.
complete
(
false
)
;
}
)
;
}
}
)
;
return
res
;
}
WrapForJNI
(
calledFrom
=
"
ui
"
)
private
void
passExternalWebResponse
(
final
WebResponse
response
)
{
GeckoSession
session
=
mOwner
.
get
(
)
;
if
(
session
=
=
null
)
{
return
;
}
ContentDelegate
delegate
=
session
.
getContentDelegate
(
)
;
if
(
delegate
!
=
null
)
{
delegate
.
onExternalResponse
(
session
response
)
;
}
}
}
private
class
Listener
implements
BundleEventListener
{
void
registerListeners
(
)
{
getEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
GeckoView
:
PinOnScreen
"
"
GeckoView
:
Prompt
"
null
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
handleMessage
:
event
=
"
+
event
)
;
}
if
(
"
GeckoView
:
PinOnScreen
"
.
equals
(
event
)
)
{
GeckoSession
.
this
.
setShouldPinOnScreen
(
message
.
getBoolean
(
"
pinned
"
)
)
;
}
else
if
(
"
GeckoView
:
Prompt
"
.
equals
(
event
)
)
{
handlePromptEvent
(
GeckoSession
.
this
message
callback
)
;
}
}
}
protected
Nullable
Window
mWindow
;
private
GeckoSessionSettings
mSettings
;
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
GeckoSession
(
)
{
this
(
null
)
;
}
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
GeckoSession
(
final
Nullable
GeckoSessionSettings
settings
)
{
mSettings
=
new
GeckoSessionSettings
(
settings
this
)
;
mListener
.
registerListeners
(
)
;
mWebExtensionController
=
new
WebExtension
.
SessionController
(
this
)
;
mAutofillSupport
=
new
Autofill
.
Support
(
this
)
;
mAutofillSupport
.
registerListeners
(
)
;
if
(
BuildConfig
.
DEBUG
&
&
handlersCount
!
=
mSessionHandlers
.
length
)
{
throw
new
AssertionError
(
"
Add
new
handler
to
handlers
list
"
)
;
}
}
Nullable
GeckoRuntime
getRuntime
(
)
{
if
(
mWindow
=
=
null
)
{
return
null
;
}
return
mWindow
.
runtime
;
}
synchronized
void
abandonWindow
(
)
{
if
(
mWindow
=
=
null
)
{
return
;
}
onWindowChanged
(
WINDOW_TRANSFER_OUT
true
)
;
mWindow
=
null
;
onWindowChanged
(
WINDOW_TRANSFER_OUT
false
)
;
}
private
void
transferFrom
(
final
Window
window
final
GeckoSessionSettings
settings
final
String
id
)
{
if
(
isOpen
(
)
)
{
throw
new
IllegalStateException
(
"
Session
is
open
"
)
;
}
if
(
window
!
=
null
)
{
onWindowChanged
(
WINDOW_TRANSFER_IN
true
)
;
}
mWindow
=
window
;
mSettings
=
new
GeckoSessionSettings
(
settings
this
)
;
mId
=
id
;
if
(
mWindow
!
=
null
)
{
mWindow
.
transfer
(
this
mNativeQueue
mCompositor
mEventDispatcher
mAccessibility
!
=
null
?
mAccessibility
.
nativeProvider
:
null
createInitData
(
)
)
;
onWindowChanged
(
WINDOW_TRANSFER_IN
false
)
;
mWebExtensionController
.
setRuntime
(
mWindow
.
runtime
)
;
}
}
void
transferFrom
(
final
GeckoSession
session
)
{
transferFrom
(
session
.
mWindow
session
.
mSettings
session
.
mId
)
;
session
.
mWindow
=
null
;
}
Deprecated
Override
AnyThread
public
int
describeContents
(
)
{
return
0
;
}
Deprecated
Override
AnyThread
public
void
writeToParcel
(
final
Parcel
out
final
int
flags
)
{
out
.
writeStrongInterface
(
mWindow
)
;
out
.
writeParcelable
(
mSettings
flags
)
;
out
.
writeString
(
mId
)
;
}
Deprecated
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
void
readFromParcel
(
final
NonNull
Parcel
source
)
{
final
IBinder
binder
=
source
.
readStrongBinder
(
)
;
final
IInterface
ifce
=
(
binder
!
=
null
)
?
binder
.
queryLocalInterface
(
Window
.
class
.
getName
(
)
)
:
null
;
final
Window
window
=
(
ifce
instanceof
Window
)
?
(
Window
)
ifce
:
null
;
final
GeckoSessionSettings
settings
=
source
.
readParcelable
(
getClass
(
)
.
getClassLoader
(
)
)
;
final
String
id
=
source
.
readString
(
)
;
transferFrom
(
window
settings
id
)
;
}
Deprecated
public
static
final
Creator
<
GeckoSession
>
CREATOR
=
new
Creator
<
GeckoSession
>
(
)
{
Override
AnyThread
public
GeckoSession
createFromParcel
(
final
Parcel
in
)
{
final
GeckoSession
session
=
new
GeckoSession
(
)
;
session
.
readFromParcel
(
in
)
;
return
session
;
}
Override
AnyThread
public
GeckoSession
[
]
newArray
(
final
int
size
)
{
return
new
GeckoSession
[
size
]
;
}
}
;
boolean
equalsId
(
final
GeckoSession
other
)
{
if
(
other
=
=
null
)
{
return
false
;
}
return
mId
.
equals
(
other
.
mId
)
;
}
AnyThread
public
boolean
isOpen
(
)
{
return
mWindow
!
=
null
;
}
boolean
isReady
(
)
{
return
mNativeQueue
.
isReady
(
)
;
}
private
GeckoBundle
createInitData
(
)
{
final
GeckoBundle
initData
=
new
GeckoBundle
(
2
)
;
initData
.
putBundle
(
"
settings
"
mSettings
.
toBundle
(
)
)
;
final
GeckoBundle
modules
=
new
GeckoBundle
(
mSessionHandlers
.
length
)
;
for
(
final
GeckoSessionHandler
<
?
>
handler
:
mSessionHandlers
)
{
modules
.
putBoolean
(
handler
.
getName
(
)
handler
.
isEnabled
(
)
)
;
}
initData
.
putBundle
(
"
modules
"
modules
)
;
return
initData
;
}
UiThread
public
void
open
(
final
NonNull
GeckoRuntime
runtime
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isOpen
(
)
)
{
throw
new
IllegalStateException
(
"
Session
is
open
"
)
;
}
final
String
chromeUri
=
mSettings
.
getChromeUri
(
)
;
final
int
screenId
=
mSettings
.
getScreenId
(
)
;
final
boolean
isPrivate
=
mSettings
.
getUsePrivateMode
(
)
;
final
boolean
isRemote
=
runtime
.
getSettings
(
)
.
getUseMultiprocess
(
)
;
mWindow
=
new
Window
(
runtime
this
mNativeQueue
)
;
mWebExtensionController
.
setRuntime
(
runtime
)
;
onWindowChanged
(
WINDOW_OPEN
true
)
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
Window
.
open
(
mWindow
mNativeQueue
mCompositor
mEventDispatcher
mAccessibility
!
=
null
?
mAccessibility
.
nativeProvider
:
null
createInitData
(
)
mId
chromeUri
screenId
isPrivate
isRemote
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
Window
.
class
"
open
"
Window
.
class
mWindow
NativeQueue
.
class
mNativeQueue
Compositor
.
class
mCompositor
EventDispatcher
.
class
mEventDispatcher
SessionAccessibility
.
NativeProvider
.
class
mAccessibility
!
=
null
?
mAccessibility
.
nativeProvider
:
null
GeckoBundle
.
class
createInitData
(
)
String
.
class
mId
String
.
class
chromeUri
screenId
isPrivate
isRemote
)
;
}
onWindowChanged
(
WINDOW_OPEN
false
)
;
}
UiThread
public
void
close
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
isOpen
(
)
)
{
Log
.
w
(
LOGTAG
"
Attempted
to
close
a
GeckoSession
that
was
already
closed
.
"
)
;
return
;
}
onWindowChanged
(
WINDOW_CLOSE
true
)
;
onSurfaceDestroyed
(
)
;
mWindow
.
close
(
)
;
mWindow
.
disposeNative
(
)
;
mWindow
=
null
;
onWindowChanged
(
WINDOW_CLOSE
false
)
;
}
private
void
onWindowChanged
(
final
int
change
final
boolean
inProgress
)
{
if
(
(
change
=
=
WINDOW_OPEN
|
|
change
=
=
WINDOW_TRANSFER_IN
)
&
&
!
inProgress
)
{
mTextInput
.
onWindowChanged
(
mWindow
)
;
}
if
(
(
change
=
=
WINDOW_CLOSE
|
|
change
=
=
WINDOW_TRANSFER_OUT
)
&
&
!
inProgress
)
{
getAutofillSupport
(
)
.
clear
(
)
;
}
}
AnyThread
public
NonNull
SessionTextInput
getTextInput
(
)
{
return
mTextInput
;
}
UiThread
public
NonNull
SessionAccessibility
getAccessibility
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mAccessibility
!
=
null
)
{
return
mAccessibility
;
}
mAccessibility
=
new
SessionAccessibility
(
this
)
;
if
(
mWindow
!
=
null
)
{
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
mWindow
.
attachAccessibility
(
mAccessibility
.
nativeProvider
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mWindow
"
attachAccessibility
"
SessionAccessibility
.
NativeProvider
.
class
mAccessibility
.
nativeProvider
)
;
}
}
return
mAccessibility
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
LOAD_FLAGS_NONE
LOAD_FLAGS_BYPASS_CACHE
LOAD_FLAGS_BYPASS_PROXY
LOAD_FLAGS_EXTERNAL
LOAD_FLAGS_ALLOW_POPUPS
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
LOAD_FLAGS_REPLACE_HISTORY
}
)
interface
LoadFlags
{
}
public
static
final
int
LOAD_FLAGS_NONE
=
0
;
public
static
final
int
LOAD_FLAGS_BYPASS_CACHE
=
1
<
<
0
;
public
static
final
int
LOAD_FLAGS_BYPASS_PROXY
=
1
<
<
1
;
public
static
final
int
LOAD_FLAGS_EXTERNAL
=
1
<
<
2
;
public
static
final
int
LOAD_FLAGS_ALLOW_POPUPS
=
1
<
<
3
;
public
static
final
int
LOAD_FLAGS_BYPASS_CLASSIFIER
=
1
<
<
4
;
public
static
final
int
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
=
1
<
<
5
;
public
static
final
int
LOAD_FLAGS_REPLACE_HISTORY
=
1
<
<
6
;
private
ArrayList
<
String
>
additionalHeadersToStringArray
(
final
NonNull
Map
<
String
String
>
additionalHeaders
)
{
ArrayList
<
String
>
headers
=
new
ArrayList
<
String
>
(
)
;
for
(
String
key
:
additionalHeaders
.
keySet
(
)
)
{
if
(
key
=
=
null
)
continue
;
headers
.
add
(
String
.
format
(
"
%
s
:
%
s
"
key
additionalHeaders
.
get
(
key
)
)
)
;
}
return
headers
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
)
{
loadUri
(
uri
(
GeckoSession
)
null
LOAD_FLAGS_NONE
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
final
Nullable
Map
<
String
String
>
additionalHeaders
)
{
loadUri
(
uri
(
GeckoSession
)
null
LOAD_FLAGS_NONE
additionalHeaders
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
final
LoadFlags
int
flags
)
{
loadUri
(
uri
(
GeckoSession
)
null
flags
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
final
Nullable
String
referrer
final
LoadFlags
int
flags
)
{
loadUri
(
uri
referrer
flags
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
final
Nullable
String
referrer
final
LoadFlags
int
flags
final
Nullable
Map
<
String
String
>
additionalHeaders
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
)
;
msg
.
putString
(
"
uri
"
uri
)
;
msg
.
putInt
(
"
flags
"
flags
)
;
if
(
referrer
!
=
null
)
{
msg
.
putString
(
"
referrerUri
"
referrer
)
;
}
if
(
additionalHeaders
!
=
null
)
{
msg
.
putStringArray
(
"
headers
"
additionalHeadersToStringArray
(
additionalHeaders
)
)
;
}
mEventDispatcher
.
dispatch
(
"
GeckoView
:
LoadUri
"
msg
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
final
Nullable
GeckoSession
referrer
final
LoadFlags
int
flags
)
{
loadUri
(
uri
referrer
flags
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
String
uri
final
Nullable
GeckoSession
referrer
final
LoadFlags
int
flags
final
Nullable
Map
<
String
String
>
additionalHeaders
)
{
final
NavigationDelegate
.
LoadRequest
request
=
new
NavigationDelegate
.
LoadRequest
(
uri
null
1
0
false
true
)
;
shouldLoadUri
(
request
)
.
getOrAccept
(
allowOrDeny
-
>
{
if
(
allowOrDeny
=
=
AllowOrDeny
.
DENY
)
{
return
;
}
final
GeckoBundle
msg
=
new
GeckoBundle
(
)
;
msg
.
putString
(
"
uri
"
uri
)
;
msg
.
putInt
(
"
flags
"
flags
)
;
if
(
referrer
!
=
null
)
{
msg
.
putString
(
"
referrerSessionId
"
referrer
.
mId
)
;
}
if
(
additionalHeaders
!
=
null
)
{
msg
.
putStringArray
(
"
headers
"
additionalHeadersToStringArray
(
additionalHeaders
)
)
;
}
mEventDispatcher
.
dispatch
(
"
GeckoView
:
LoadUri
"
msg
)
;
}
)
;
}
private
GeckoResult
<
AllowOrDeny
>
shouldLoadUri
(
final
NavigationDelegate
.
LoadRequest
request
)
{
final
NavigationDelegate
delegate
=
mNavigationHandler
.
getDelegate
(
)
;
if
(
delegate
=
=
null
)
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
;
}
final
GeckoResult
<
AllowOrDeny
>
result
=
new
GeckoResult
<
>
(
)
;
ThreadUtils
.
runOnUiThread
(
(
)
-
>
{
final
GeckoResult
<
AllowOrDeny
>
delegateResult
=
delegate
.
onLoadRequest
(
this
request
)
;
if
(
delegateResult
=
=
null
)
{
result
.
complete
(
AllowOrDeny
.
ALLOW
)
;
}
else
{
delegateResult
.
getOrAccept
(
allowOrDeny
-
>
result
.
complete
(
allowOrDeny
)
error
-
>
result
.
completeExceptionally
(
error
)
)
;
}
}
)
;
return
result
;
}
AnyThread
public
void
loadUri
(
final
NonNull
Uri
uri
)
{
loadUri
(
uri
.
toString
(
)
(
GeckoSession
)
null
LOAD_FLAGS_NONE
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
Uri
uri
final
Nullable
Map
<
String
String
>
additionalHeaders
)
{
loadUri
(
uri
.
toString
(
)
(
GeckoSession
)
null
LOAD_FLAGS_NONE
additionalHeaders
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
Uri
uri
final
LoadFlags
int
flags
)
{
loadUri
(
uri
.
toString
(
)
(
GeckoSession
)
null
flags
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
Uri
uri
final
Nullable
Uri
referrer
final
LoadFlags
int
flags
)
{
loadUri
(
uri
.
toString
(
)
referrer
!
=
null
?
referrer
.
toString
(
)
:
null
flags
(
Map
<
String
String
>
)
null
)
;
}
AnyThread
public
void
loadUri
(
final
NonNull
Uri
uri
final
Nullable
Uri
referrer
final
LoadFlags
int
flags
final
Nullable
Map
<
String
String
>
additionalHeaders
)
{
loadUri
(
uri
.
toString
(
)
referrer
!
=
null
?
referrer
.
toString
(
)
:
null
flags
additionalHeaders
)
;
}
AnyThread
public
void
loadString
(
NonNull
final
String
data
Nullable
final
String
mimeType
)
{
if
(
data
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
data
cannot
be
null
"
)
;
}
loadUri
(
createDataUri
(
data
mimeType
)
(
GeckoSession
)
null
LOAD_FLAGS_NONE
)
;
}
AnyThread
public
void
loadData
(
NonNull
final
byte
[
]
bytes
Nullable
final
String
mimeType
)
{
if
(
bytes
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
data
cannot
be
null
"
)
;
}
loadUri
(
createDataUri
(
bytes
mimeType
)
(
GeckoSession
)
null
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
)
;
}
AnyThread
public
static
NonNull
String
createDataUri
(
NonNull
final
byte
[
]
bytes
Nullable
final
String
mimeType
)
{
return
String
.
format
(
"
data
:
%
s
;
base64
%
s
"
mimeType
!
=
null
?
mimeType
:
"
"
Base64
.
encodeToString
(
bytes
Base64
.
NO_WRAP
)
)
;
}
AnyThread
public
static
NonNull
String
createDataUri
(
NonNull
final
String
data
Nullable
final
String
mimeType
)
{
return
String
.
format
(
"
data
:
%
s
%
s
"
mimeType
!
=
null
?
mimeType
:
"
"
data
)
;
}
AnyThread
public
void
reload
(
)
{
reload
(
LOAD_FLAGS_NONE
)
;
}
AnyThread
public
void
reload
(
final
LoadFlags
int
flags
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
)
;
msg
.
putInt
(
"
flags
"
flags
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
Reload
"
msg
)
;
}
AnyThread
public
void
stop
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
Stop
"
null
)
;
}
AnyThread
public
void
goBack
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GoBack
"
null
)
;
}
AnyThread
public
void
goForward
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GoForward
"
null
)
;
}
AnyThread
public
void
gotoHistoryIndex
(
final
int
index
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
1
)
;
msg
.
putInt
(
"
index
"
index
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GotoHistoryIndex
"
msg
)
;
}
UiThread
public
NonNull
WebExtension
.
SessionController
getWebExtensionController
(
)
{
return
mWebExtensionController
;
}
AnyThread
public
void
purgeHistory
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
PurgeHistory
"
null
)
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FINDER_FIND_BACKWARDS
FINDER_FIND_LINKS_ONLY
FINDER_FIND_MATCH_CASE
FINDER_FIND_WHOLE_WORD
}
)
interface
FinderFindFlags
{
}
public
static
final
int
FINDER_FIND_BACKWARDS
=
1
;
public
static
final
int
FINDER_FIND_MATCH_CASE
=
1
<
<
1
;
public
static
final
int
FINDER_FIND_WHOLE_WORD
=
1
<
<
2
;
public
static
final
int
FINDER_FIND_LINKS_ONLY
=
1
<
<
3
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FINDER_DISPLAY_HIGHLIGHT_ALL
FINDER_DISPLAY_DIM_PAGE
FINDER_DISPLAY_DRAW_LINK_OUTLINE
}
)
interface
FinderDisplayFlags
{
}
public
static
final
int
FINDER_DISPLAY_HIGHLIGHT_ALL
=
1
;
public
static
final
int
FINDER_DISPLAY_DIM_PAGE
=
1
<
<
1
;
public
static
final
int
FINDER_DISPLAY_DRAW_LINK_OUTLINE
=
1
<
<
2
;
AnyThread
public
static
class
FinderResult
{
public
final
boolean
found
;
public
final
boolean
wrapped
;
public
final
int
current
;
public
final
int
total
;
NonNull
public
final
String
searchString
;
FinderFindFlags
public
final
int
flags
;
Nullable
public
final
String
linkUri
;
Nullable
public
final
RectF
clientRect
;
FinderResult
(
NonNull
final
GeckoBundle
bundle
)
{
found
=
bundle
.
getBoolean
(
"
found
"
)
;
wrapped
=
bundle
.
getBoolean
(
"
wrapped
"
)
;
current
=
bundle
.
getInt
(
"
current
"
0
)
;
total
=
bundle
.
getInt
(
"
total
"
-
1
)
;
searchString
=
bundle
.
getString
(
"
searchString
"
)
;
flags
=
SessionFinder
.
getFlagsFromBundle
(
bundle
.
getBundle
(
"
flags
"
)
)
;
linkUri
=
bundle
.
getString
(
"
linkURL
"
)
;
final
GeckoBundle
rectBundle
=
bundle
.
getBundle
(
"
clientRect
"
)
;
if
(
rectBundle
=
=
null
)
{
clientRect
=
null
;
}
else
{
clientRect
=
new
RectF
(
(
float
)
rectBundle
.
getDouble
(
"
left
"
)
(
float
)
rectBundle
.
getDouble
(
"
top
"
)
(
float
)
rectBundle
.
getDouble
(
"
right
"
)
(
float
)
rectBundle
.
getDouble
(
"
bottom
"
)
)
;
}
}
protected
FinderResult
(
)
{
found
=
false
;
wrapped
=
false
;
current
=
0
;
total
=
0
;
flags
=
0
;
searchString
=
"
"
;
linkUri
=
"
"
;
clientRect
=
null
;
}
}
AnyThread
public
NonNull
SessionFinder
getFinder
(
)
{
if
(
mFinder
=
=
null
)
{
mFinder
=
new
SessionFinder
(
getEventDispatcher
(
)
)
;
}
return
mFinder
;
}
AnyThread
public
void
setActive
(
final
boolean
active
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
1
)
;
msg
.
putBoolean
(
"
active
"
active
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
SetActive
"
msg
)
;
if
(
!
active
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
FlushSessionState
"
null
)
;
}
ThreadUtils
.
runOnUiThread
(
(
)
-
>
getAutofillSupport
(
)
.
onActiveChanged
(
active
)
)
;
}
AnyThread
public
void
setFocused
(
final
boolean
focused
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
1
)
;
msg
.
putBoolean
(
"
focused
"
focused
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
SetFocused
"
msg
)
;
}
AnyThread
public
static
class
SessionState
extends
AbstractSequentialList
<
HistoryDelegate
.
HistoryItem
>
implements
HistoryDelegate
.
HistoryList
Parcelable
{
private
GeckoBundle
mState
;
private
class
SessionStateItem
implements
HistoryDelegate
.
HistoryItem
{
private
final
GeckoBundle
mItem
;
private
SessionStateItem
(
final
NonNull
GeckoBundle
item
)
{
mItem
=
item
;
}
Override
public
String
getUri
(
)
{
return
mItem
.
getString
(
"
url
"
)
;
}
Override
public
String
getTitle
(
)
{
return
mItem
.
getString
(
"
title
"
)
;
}
}
private
class
SessionStateIterator
implements
ListIterator
<
HistoryDelegate
.
HistoryItem
>
{
private
final
SessionState
mState
;
private
int
mIndex
;
private
SessionStateIterator
(
final
NonNull
SessionState
state
)
{
this
(
state
0
)
;
}
private
SessionStateIterator
(
final
NonNull
SessionState
state
final
int
index
)
{
mIndex
=
index
;
mState
=
state
;
}
Override
public
void
add
(
final
HistoryDelegate
.
HistoryItem
item
)
{
throw
new
UnsupportedOperationException
(
)
;
}
Override
public
boolean
hasNext
(
)
{
final
GeckoBundle
[
]
entries
=
mState
.
getHistoryEntries
(
)
;
if
(
entries
=
=
null
)
{
Log
.
w
(
LOGTAG
"
No
history
entries
found
.
"
)
;
return
false
;
}
if
(
mIndex
>
=
mState
.
getHistoryEntries
(
)
.
length
)
{
return
false
;
}
return
true
;
}
Override
public
boolean
hasPrevious
(
)
{
if
(
mIndex
<
=
0
)
{
return
false
;
}
return
true
;
}
Override
public
HistoryDelegate
.
HistoryItem
next
(
)
{
if
(
hasNext
(
)
)
{
mIndex
+
+
;
return
new
SessionStateItem
(
mState
.
getHistoryEntries
(
)
[
mIndex
-
1
]
)
;
}
else
{
throw
new
NoSuchElementException
(
)
;
}
}
Override
public
int
nextIndex
(
)
{
return
mIndex
;
}
Override
public
HistoryDelegate
.
HistoryItem
previous
(
)
{
if
(
hasPrevious
(
)
)
{
mIndex
-
-
;
return
new
SessionStateItem
(
mState
.
getHistoryEntries
(
)
[
mIndex
]
)
;
}
else
{
throw
new
NoSuchElementException
(
)
;
}
}
Override
public
int
previousIndex
(
)
{
return
mIndex
-
1
;
}
Override
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
Override
public
void
set
(
final
NonNull
HistoryDelegate
.
HistoryItem
item
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
private
SessionState
(
)
{
mState
=
new
GeckoBundle
(
3
)
;
}
private
SessionState
(
final
NonNull
GeckoBundle
state
)
{
mState
=
new
GeckoBundle
(
state
)
;
}
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
SessionState
(
final
NonNull
SessionState
state
)
{
mState
=
new
GeckoBundle
(
state
.
mState
)
;
}
void
updateSessionState
(
final
NonNull
GeckoBundle
updateData
)
{
if
(
updateData
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Session
state
update
has
no
data
field
.
"
)
;
return
;
}
final
GeckoBundle
history
=
updateData
.
getBundle
(
"
historychange
"
)
;
final
GeckoBundle
scroll
=
updateData
.
getBundle
(
"
scroll
"
)
;
final
GeckoBundle
formdata
=
updateData
.
getBundle
(
"
formdata
"
)
;
if
(
history
!
=
null
)
{
mState
.
putBundle
(
"
history
"
history
)
;
}
if
(
scroll
!
=
null
)
{
mState
.
putBundle
(
"
scrolldata
"
scroll
)
;
}
if
(
formdata
!
=
null
)
{
mState
.
putBundle
(
"
formdata
"
formdata
)
;
}
return
;
}
Override
public
int
hashCode
(
)
{
return
mState
.
hashCode
(
)
;
}
Override
public
boolean
equals
(
final
Object
other
)
{
if
(
other
=
=
null
|
|
!
(
other
instanceof
SessionState
)
)
{
return
false
;
}
final
SessionState
otherState
=
(
SessionState
)
other
;
return
this
.
mState
.
equals
(
otherState
.
mState
)
;
}
public
static
NonNull
SessionState
fromString
(
final
NonNull
String
value
)
throws
JSONException
{
return
new
SessionState
(
GeckoBundle
.
fromJSONObject
(
new
JSONObject
(
value
)
)
)
;
}
Override
public
String
toString
(
)
{
if
(
mState
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Can
'
t
convert
SessionState
with
null
state
to
string
"
)
;
return
null
;
}
String
res
;
try
{
res
=
mState
.
toJSONObject
(
)
.
toString
(
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Could
not
convert
session
state
to
string
.
"
)
;
res
=
null
;
}
return
res
;
}
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
final
Parcel
dest
final
int
flags
)
{
dest
.
writeString
(
toString
(
)
)
;
}
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
void
readFromParcel
(
final
NonNull
Parcel
source
)
{
if
(
source
.
readString
(
)
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Can
'
t
reproduce
session
state
from
Parcel
"
)
;
}
try
{
mState
=
GeckoBundle
.
fromJSONObject
(
new
JSONObject
(
source
.
readString
(
)
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Could
not
convert
string
to
session
state
.
"
)
;
mState
=
null
;
}
}
public
static
final
Parcelable
.
Creator
<
SessionState
>
CREATOR
=
new
Parcelable
.
Creator
<
SessionState
>
(
)
{
Override
public
SessionState
createFromParcel
(
final
Parcel
source
)
{
if
(
source
.
readString
(
)
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Can
'
t
create
session
state
from
Parcel
"
)
;
}
GeckoBundle
res
;
try
{
res
=
GeckoBundle
.
fromJSONObject
(
new
JSONObject
(
source
.
readString
(
)
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Could
not
convert
parcel
to
session
state
.
"
)
;
res
=
null
;
}
return
new
SessionState
(
res
)
;
}
Override
public
SessionState
[
]
newArray
(
final
int
size
)
{
return
new
SessionState
[
size
]
;
}
}
;
Override
public
NonNull
HistoryDelegate
.
HistoryItem
get
(
final
int
index
)
{
final
GeckoBundle
[
]
entries
=
getHistoryEntries
(
)
;
if
(
entries
=
=
null
|
|
index
<
0
|
|
index
>
=
entries
.
length
)
{
throw
new
NoSuchElementException
(
)
;
}
return
new
SessionStateItem
(
entries
[
index
]
)
;
}
Override
public
NonNull
Iterator
<
HistoryDelegate
.
HistoryItem
>
iterator
(
)
{
return
listIterator
(
0
)
;
}
Override
public
NonNull
ListIterator
<
HistoryDelegate
.
HistoryItem
>
listIterator
(
final
int
index
)
{
return
new
SessionStateIterator
(
this
index
)
;
}
Override
public
int
size
(
)
{
final
GeckoBundle
[
]
entries
=
getHistoryEntries
(
)
;
if
(
entries
=
=
null
)
{
Log
.
w
(
LOGTAG
"
No
history
entries
found
.
"
)
;
return
0
;
}
return
entries
.
length
;
}
Override
public
int
getCurrentIndex
(
)
{
final
GeckoBundle
history
=
getHistory
(
)
;
if
(
history
=
=
null
)
{
throw
new
IllegalStateException
(
"
No
history
state
exists
.
"
)
;
}
return
history
.
getInt
(
"
index
"
)
+
history
.
getInt
(
"
fromIdx
"
)
;
}
private
GeckoBundle
getHistory
(
)
{
if
(
mState
=
=
null
)
{
return
null
;
}
return
mState
.
getBundle
(
"
history
"
)
;
}
private
GeckoBundle
[
]
getHistoryEntries
(
)
{
final
GeckoBundle
history
=
getHistory
(
)
;
if
(
history
=
=
null
)
{
return
null
;
}
return
history
.
getBundleArray
(
"
entries
"
)
;
}
}
private
SessionState
mStateCache
=
new
SessionState
(
)
;
AnyThread
public
void
restoreState
(
final
NonNull
SessionState
state
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
RestoreState
"
state
.
mState
)
;
}
private
GeckoDisplay
mDisplay
;
GeckoDisplay
getDisplay
(
)
{
return
mDisplay
;
}
UiThread
public
NonNull
GeckoDisplay
acquireDisplay
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mDisplay
!
=
null
)
{
throw
new
IllegalStateException
(
"
Display
already
acquired
"
)
;
}
mDisplay
=
new
GeckoDisplay
(
this
)
;
return
mDisplay
;
}
UiThread
public
void
releaseDisplay
(
final
NonNull
GeckoDisplay
display
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
display
!
=
mDisplay
)
{
throw
new
IllegalArgumentException
(
"
Display
not
attached
"
)
;
}
mDisplay
=
null
;
}
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
NonNull
GeckoSessionSettings
getSettings
(
)
{
return
mSettings
;
}
AnyThread
public
void
exitFullScreen
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoViewContent
:
ExitFullScreen
"
null
)
;
}
UiThread
public
void
setContentDelegate
(
final
Nullable
ContentDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mContentHandler
.
setDelegate
(
delegate
this
)
;
mProcessHangHandler
.
setDelegate
(
delegate
this
)
;
}
UiThread
public
Nullable
ContentDelegate
getContentDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mContentHandler
.
getDelegate
(
)
;
}
UiThread
public
void
setProgressDelegate
(
final
Nullable
ProgressDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mProgressHandler
.
setDelegate
(
delegate
this
)
;
}
UiThread
public
Nullable
ProgressDelegate
getProgressDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mProgressHandler
.
getDelegate
(
)
;
}
UiThread
public
void
setNavigationDelegate
(
final
Nullable
NavigationDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mNavigationHandler
.
setDelegate
(
delegate
this
)
;
}
UiThread
public
Nullable
NavigationDelegate
getNavigationDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mNavigationHandler
.
getDelegate
(
)
;
}
UiThread
public
void
setScrollDelegate
(
final
Nullable
ScrollDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mScrollHandler
.
setDelegate
(
delegate
this
)
;
}
UiThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
Nullable
ScrollDelegate
getScrollDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mScrollHandler
.
getDelegate
(
)
;
}
AnyThread
public
void
setHistoryDelegate
(
final
Nullable
HistoryDelegate
delegate
)
{
mHistoryHandler
.
setDelegate
(
delegate
this
)
;
}
AnyThread
public
Nullable
HistoryDelegate
getHistoryDelegate
(
)
{
return
mHistoryHandler
.
getDelegate
(
)
;
}
AnyThread
public
void
setContentBlockingDelegate
(
final
Nullable
ContentBlocking
.
Delegate
delegate
)
{
mContentBlockingHandler
.
setDelegate
(
delegate
this
)
;
}
AnyThread
public
Nullable
ContentBlocking
.
Delegate
getContentBlockingDelegate
(
)
{
return
mContentBlockingHandler
.
getDelegate
(
)
;
}
AnyThread
public
void
setPromptDelegate
(
final
Nullable
PromptDelegate
delegate
)
{
mPromptDelegate
=
delegate
;
}
AnyThread
public
Nullable
PromptDelegate
getPromptDelegate
(
)
{
return
mPromptDelegate
;
}
UiThread
public
void
setSelectionActionDelegate
(
final
Nullable
SelectionActionDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
getSelectionActionDelegate
(
)
!
=
null
)
{
getSelectionActionDelegate
(
)
.
onHideAction
(
this
GeckoSession
.
SelectionActionDelegate
.
HIDE_REASON_NO_SELECTION
)
;
}
mSelectionActionDelegate
.
setDelegate
(
delegate
this
)
;
}
AnyThread
public
void
setMediaDelegate
(
final
Nullable
MediaDelegate
delegate
)
{
mMediaHandler
.
setDelegate
(
delegate
this
)
;
}
AnyThread
public
Nullable
MediaDelegate
getMediaDelegate
(
)
{
return
mMediaHandler
.
getDelegate
(
)
;
}
AnyThread
public
void
setMediaSessionDelegate
(
final
Nullable
MediaSession
.
Delegate
delegate
)
{
Log
.
d
(
LOGTAG
"
setMediaSessionDelegate
"
+
mWindow
)
;
mMediaSessionHandler
.
setDelegate
(
delegate
this
)
;
}
AnyThread
public
Nullable
MediaSession
.
Delegate
getMediaSessionDelegate
(
)
{
return
mMediaSessionHandler
.
getDelegate
(
)
;
}
UiThread
void
attachMediaSessionController
(
final
MediaSession
.
Controller
controller
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
attachMediaSessionController
"
+
"
isOpen
=
"
+
isOpen
(
)
+
"
isEnabled
=
"
+
mMediaSessionHandler
.
isEnabled
(
)
)
;
}
if
(
!
isOpen
(
)
|
|
!
mMediaSessionHandler
.
isEnabled
(
)
)
{
return
;
}
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
mWindow
.
attachMediaSessionController
(
controller
controller
.
getId
(
)
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mWindow
"
attachMediaSessionController
"
MediaSession
.
Controller
.
class
controller
controller
.
getId
(
)
)
;
}
}
UiThread
void
detachMediaSessionController
(
final
MediaSession
.
Controller
controller
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
detachMediaSessionController
"
+
"
isOpen
=
"
+
isOpen
(
)
+
"
isEnabled
=
"
+
mMediaSessionHandler
.
isEnabled
(
)
)
;
}
if
(
!
isOpen
(
)
|
|
!
mMediaSessionHandler
.
isEnabled
(
)
)
{
return
;
}
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
mWindow
.
detachMediaSessionController
(
controller
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
mWindow
"
detachMediaSessionController
"
MediaSession
.
Controller
.
class
controller
)
;
}
}
AnyThread
public
Nullable
SelectionActionDelegate
getSelectionActionDelegate
(
)
{
return
mSelectionActionDelegate
.
getDelegate
(
)
;
}
static
void
handlePromptEvent
(
final
GeckoSession
session
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
PromptDelegate
delegate
=
session
.
getPromptDelegate
(
)
;
if
(
delegate
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
final
String
type
=
message
.
getString
(
"
type
"
)
;
final
String
mode
=
message
.
getString
(
"
mode
"
)
;
final
String
title
=
message
.
getString
(
"
title
"
)
;
final
String
msg
=
message
.
getString
(
"
msg
"
)
;
GeckoResult
<
PromptDelegate
.
PromptResponse
>
res
=
null
;
switch
(
type
)
{
case
"
alert
"
:
{
final
PromptDelegate
.
AlertPrompt
prompt
=
new
PromptDelegate
.
AlertPrompt
(
title
msg
)
;
res
=
delegate
.
onAlertPrompt
(
session
prompt
)
;
break
;
}
case
"
beforeUnload
"
:
{
final
PromptDelegate
.
BeforeUnloadPrompt
prompt
=
new
PromptDelegate
.
BeforeUnloadPrompt
(
)
;
res
=
delegate
.
onBeforeUnloadPrompt
(
session
prompt
)
;
break
;
}
case
"
button
"
:
{
final
PromptDelegate
.
ButtonPrompt
prompt
=
new
PromptDelegate
.
ButtonPrompt
(
title
msg
)
;
res
=
delegate
.
onButtonPrompt
(
session
prompt
)
;
break
;
}
case
"
text
"
:
{
final
String
defaultValue
=
message
.
getString
(
"
value
"
)
;
final
PromptDelegate
.
TextPrompt
prompt
=
new
PromptDelegate
.
TextPrompt
(
title
msg
defaultValue
)
;
res
=
delegate
.
onTextPrompt
(
session
prompt
)
;
break
;
}
case
"
auth
"
:
{
final
PromptDelegate
.
AuthPrompt
.
AuthOptions
authOptions
=
new
PromptDelegate
.
AuthPrompt
.
AuthOptions
(
message
.
getBundle
(
"
options
"
)
)
;
final
PromptDelegate
.
AuthPrompt
prompt
=
new
PromptDelegate
.
AuthPrompt
(
title
msg
authOptions
)
;
res
=
delegate
.
onAuthPrompt
(
session
prompt
)
;
break
;
}
case
"
choice
"
:
{
final
int
intMode
;
if
(
"
menu
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
ChoicePrompt
.
Type
.
MENU
;
}
else
if
(
"
single
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
ChoicePrompt
.
Type
.
SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
ChoicePrompt
.
Type
.
MULTIPLE
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
GeckoBundle
[
]
choiceBundles
=
message
.
getBundleArray
(
"
choices
"
)
;
PromptDelegate
.
ChoicePrompt
.
Choice
choices
[
]
;
if
(
choiceBundles
=
=
null
|
|
choiceBundles
.
length
=
=
0
)
{
choices
=
new
PromptDelegate
.
ChoicePrompt
.
Choice
[
0
]
;
}
else
{
choices
=
new
PromptDelegate
.
ChoicePrompt
.
Choice
[
choiceBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
choiceBundles
.
length
;
i
+
+
)
{
choices
[
i
]
=
new
PromptDelegate
.
ChoicePrompt
.
Choice
(
choiceBundles
[
i
]
)
;
}
}
final
PromptDelegate
.
ChoicePrompt
prompt
=
new
PromptDelegate
.
ChoicePrompt
(
title
msg
intMode
choices
)
;
res
=
delegate
.
onChoicePrompt
(
session
prompt
)
;
break
;
}
case
"
color
"
:
{
final
String
defaultValue
=
message
.
getString
(
"
value
"
)
;
final
PromptDelegate
.
ColorPrompt
prompt
=
new
PromptDelegate
.
ColorPrompt
(
title
defaultValue
)
;
res
=
delegate
.
onColorPrompt
(
session
prompt
)
;
break
;
}
case
"
datetime
"
:
{
final
int
intMode
;
if
(
"
date
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DateTimePrompt
.
Type
.
DATE
;
}
else
if
(
"
month
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DateTimePrompt
.
Type
.
MONTH
;
}
else
if
(
"
week
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DateTimePrompt
.
Type
.
WEEK
;
}
else
if
(
"
time
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DateTimePrompt
.
Type
.
TIME
;
}
else
if
(
"
datetime
-
local
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DateTimePrompt
.
Type
.
DATETIME_LOCAL
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
final
String
defaultValue
=
message
.
getString
(
"
value
"
)
;
final
String
minValue
=
message
.
getString
(
"
min
"
)
;
final
String
maxValue
=
message
.
getString
(
"
max
"
)
;
final
PromptDelegate
.
DateTimePrompt
prompt
=
new
PromptDelegate
.
DateTimePrompt
(
title
intMode
defaultValue
minValue
maxValue
)
;
res
=
delegate
.
onDateTimePrompt
(
session
prompt
)
;
break
;
}
case
"
file
"
:
{
final
int
intMode
;
if
(
"
single
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
FilePrompt
.
Type
.
SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
FilePrompt
.
Type
.
MULTIPLE
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
String
[
]
mimeTypes
=
message
.
getStringArray
(
"
mimeTypes
"
)
;
int
capture
=
message
.
getInt
(
"
capture
"
)
;
final
PromptDelegate
.
FilePrompt
prompt
=
new
PromptDelegate
.
FilePrompt
(
title
intMode
capture
mimeTypes
)
;
res
=
delegate
.
onFilePrompt
(
session
prompt
)
;
break
;
}
case
"
popup
"
:
{
final
String
targetUri
=
message
.
getString
(
"
targetUri
"
)
;
final
PromptDelegate
.
PopupPrompt
prompt
=
new
PromptDelegate
.
PopupPrompt
(
targetUri
)
;
res
=
delegate
.
onPopupPrompt
(
session
prompt
)
;
break
;
}
case
"
share
"
:
{
final
String
text
=
message
.
getString
(
"
text
"
)
;
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
PromptDelegate
.
SharePrompt
prompt
=
new
PromptDelegate
.
SharePrompt
(
title
text
uri
)
;
res
=
delegate
.
onSharePrompt
(
session
prompt
)
;
break
;
}
case
"
Autocomplete
:
Save
:
Login
"
:
{
final
int
hint
=
message
.
getInt
(
"
hint
"
)
;
final
GeckoBundle
[
]
loginBundles
=
message
.
getBundleArray
(
"
logins
"
)
;
if
(
loginBundles
=
=
null
)
{
break
;
}
final
Autocomplete
.
LoginSaveOption
[
]
options
=
new
Autocomplete
.
LoginSaveOption
[
loginBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
options
.
length
;
+
+
i
)
{
options
[
i
]
=
new
Autocomplete
.
LoginSaveOption
(
new
Autocomplete
.
LoginEntry
(
loginBundles
[
i
]
)
hint
)
;
}
final
PromptDelegate
.
AutocompleteRequest
<
Autocomplete
.
LoginSaveOption
>
request
=
new
PromptDelegate
.
AutocompleteRequest
<
>
(
options
)
;
res
=
delegate
.
onLoginSave
(
session
request
)
;
break
;
}
case
"
Autocomplete
:
Select
:
Login
"
:
{
final
GeckoBundle
[
]
optionBundles
=
message
.
getBundleArray
(
"
options
"
)
;
if
(
optionBundles
=
=
null
)
{
break
;
}
final
Autocomplete
.
LoginSelectOption
[
]
options
=
new
Autocomplete
.
LoginSelectOption
[
optionBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
options
.
length
;
+
+
i
)
{
options
[
i
]
=
Autocomplete
.
LoginSelectOption
.
fromBundle
(
optionBundles
[
i
]
)
;
}
final
PromptDelegate
.
AutocompleteRequest
<
Autocomplete
.
LoginSelectOption
>
request
=
new
PromptDelegate
.
AutocompleteRequest
<
>
(
options
)
;
res
=
delegate
.
onLoginSelect
(
session
request
)
;
break
;
}
default
:
{
callback
.
sendError
(
"
Invalid
type
"
)
;
return
;
}
}
if
(
res
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
}
else
{
res
.
accept
(
value
-
>
{
value
.
dispatch
(
callback
)
;
}
exception
-
>
callback
.
sendError
(
"
Failed
to
get
prompt
response
.
"
)
)
;
}
}
UiThread
protected
void
setShouldPinOnScreen
(
final
boolean
pinned
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mShouldPinOnScreen
=
pinned
;
}
boolean
shouldPinOnScreen
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mShouldPinOnScreen
;
}
AnyThread
NonNull
EventDispatcher
getEventDispatcher
(
)
{
return
mEventDispatcher
;
}
public
interface
ProgressDelegate
{
public
class
SecurityInformation
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
SECURITY_MODE_UNKNOWN
SECURITY_MODE_IDENTIFIED
SECURITY_MODE_VERIFIED
}
)
interface
SecurityMode
{
}
public
static
final
int
SECURITY_MODE_UNKNOWN
=
0
;
public
static
final
int
SECURITY_MODE_IDENTIFIED
=
1
;
public
static
final
int
SECURITY_MODE_VERIFIED
=
2
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
CONTENT_UNKNOWN
CONTENT_BLOCKED
CONTENT_LOADED
}
)
interface
ContentType
{
}
public
static
final
int
CONTENT_UNKNOWN
=
0
;
public
static
final
int
CONTENT_BLOCKED
=
1
;
public
static
final
int
CONTENT_LOADED
=
2
;
public
final
boolean
isSecure
;
public
final
boolean
isException
;
public
final
Nullable
String
origin
;
public
final
NonNull
String
host
;
public
final
Nullable
X509Certificate
certificate
;
public
final
SecurityMode
int
securityMode
;
public
final
ContentType
int
mixedModePassive
;
public
final
ContentType
int
mixedModeActive
;
SecurityInformation
(
final
GeckoBundle
identityData
)
{
final
GeckoBundle
mode
=
identityData
.
getBundle
(
"
mode
"
)
;
mixedModePassive
=
mode
.
getInt
(
"
mixed_display
"
)
;
mixedModeActive
=
mode
.
getInt
(
"
mixed_active
"
)
;
securityMode
=
mode
.
getInt
(
"
identity
"
)
;
isSecure
=
identityData
.
getBoolean
(
"
secure
"
)
;
isException
=
identityData
.
getBoolean
(
"
securityException
"
)
;
origin
=
identityData
.
getString
(
"
origin
"
)
;
host
=
identityData
.
getString
(
"
host
"
)
;
X509Certificate
decodedCert
=
null
;
try
{
final
CertificateFactory
factory
=
CertificateFactory
.
getInstance
(
"
X
.
509
"
)
;
final
String
certString
=
identityData
.
getString
(
"
certificate
"
)
;
if
(
certString
!
=
null
)
{
final
byte
[
]
certBytes
=
Base64
.
decode
(
certString
Base64
.
NO_WRAP
)
;
decodedCert
=
(
X509Certificate
)
factory
.
generateCertificate
(
new
ByteArrayInputStream
(
certBytes
)
)
;
}
}
catch
(
CertificateException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
decode
certificate
"
e
)
;
}
certificate
=
decodedCert
;
}
protected
SecurityInformation
(
)
{
mixedModePassive
=
0
;
mixedModeActive
=
0
;
securityMode
=
0
;
isSecure
=
false
;
isException
=
false
;
origin
=
"
"
;
host
=
"
"
;
certificate
=
null
;
}
}
UiThread
default
void
onPageStart
(
NonNull
GeckoSession
session
NonNull
String
url
)
{
}
UiThread
default
void
onPageStop
(
NonNull
GeckoSession
session
boolean
success
)
{
}
UiThread
default
void
onProgressChange
(
NonNull
GeckoSession
session
int
progress
)
{
}
UiThread
default
void
onSecurityChange
(
NonNull
GeckoSession
session
NonNull
SecurityInformation
securityInfo
)
{
}
UiThread
default
void
onSessionStateChange
(
NonNull
GeckoSession
session
NonNull
SessionState
sessionState
)
{
}
}
AnyThread
static
public
class
WebResponseInfo
{
NonNull
public
final
String
uri
;
Nullable
public
final
String
contentType
;
Nullable
public
final
long
contentLength
;
Nullable
public
final
String
filename
;
WebResponseInfo
(
final
GeckoBundle
message
)
{
uri
=
message
.
getString
(
"
uri
"
)
;
if
(
uri
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
URI
cannot
be
null
"
)
;
}
contentType
=
message
.
getString
(
"
contentType
"
)
;
contentLength
=
message
.
getLong
(
"
contentLength
"
)
;
filename
=
message
.
getString
(
"
filename
"
)
;
}
protected
WebResponseInfo
(
)
{
uri
=
"
"
;
contentType
=
"
"
;
contentLength
=
0
;
filename
=
"
"
;
}
}
public
interface
ContentDelegate
{
UiThread
default
void
onTitleChange
(
NonNull
GeckoSession
session
Nullable
String
title
)
{
}
UiThread
default
void
onFocusRequest
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onCloseRequest
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onFullScreen
(
NonNull
GeckoSession
session
boolean
fullScreen
)
{
}
UiThread
default
void
onMetaViewportFitChange
(
NonNull
GeckoSession
session
NonNull
String
viewportFit
)
{
}
public
static
class
ContextElement
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
TYPE_NONE
TYPE_IMAGE
TYPE_VIDEO
TYPE_AUDIO
}
)
interface
Type
{
}
public
static
final
int
TYPE_NONE
=
0
;
public
static
final
int
TYPE_IMAGE
=
1
;
public
static
final
int
TYPE_VIDEO
=
2
;
public
static
final
int
TYPE_AUDIO
=
3
;
public
final
Nullable
String
baseUri
;
public
final
Nullable
String
linkUri
;
public
final
Nullable
String
title
;
public
final
Nullable
String
altText
;
public
final
Type
int
type
;
public
final
Nullable
String
srcUri
;
final
List
<
WebExtension
.
Menu
>
extensionMenus
;
protected
ContextElement
(
final
Nullable
String
baseUri
final
Nullable
String
linkUri
final
Nullable
String
title
final
Nullable
String
altText
final
NonNull
String
typeStr
final
Nullable
String
srcUri
)
{
this
.
baseUri
=
baseUri
;
this
.
linkUri
=
linkUri
;
this
.
title
=
title
;
this
.
altText
=
altText
;
this
.
type
=
getType
(
typeStr
)
;
this
.
srcUri
=
srcUri
;
this
.
extensionMenus
=
null
;
}
private
static
int
getType
(
final
String
name
)
{
if
(
"
HTMLImageElement
"
.
equals
(
name
)
)
{
return
TYPE_IMAGE
;
}
else
if
(
"
HTMLVideoElement
"
.
equals
(
name
)
)
{
return
TYPE_VIDEO
;
}
else
if
(
"
HTMLAudioElement
"
.
equals
(
name
)
)
{
return
TYPE_AUDIO
;
}
return
TYPE_NONE
;
}
}
UiThread
default
void
onContextMenu
(
NonNull
GeckoSession
session
int
screenX
int
screenY
NonNull
ContextElement
element
)
{
}
Deprecated
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
UiThread
default
void
onExternalResponse
(
NonNull
GeckoSession
session
NonNull
WebResponseInfo
response
)
{
}
UiThread
default
void
onExternalResponse
(
NonNull
GeckoSession
session
NonNull
WebResponse
response
)
{
}
UiThread
default
void
onCrash
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onKill
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onFirstComposite
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onFirstContentfulPaint
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onPaintStatusReset
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
onWebAppManifest
(
NonNull
GeckoSession
session
NonNull
JSONObject
manifest
)
{
}
UiThread
default
Nullable
GeckoResult
<
SlowScriptResponse
>
onSlowScript
(
NonNull
GeckoSession
geckoSession
NonNull
String
scriptFileName
)
{
return
null
;
}
}
public
interface
SelectionActionDelegate
{
final
int
FLAG_IS_COLLAPSED
=
1
;
final
int
FLAG_IS_EDITABLE
=
2
;
final
int
FLAG_IS_PASSWORD
=
4
;
final
String
ACTION_HIDE
=
"
org
.
mozilla
.
geckoview
.
HIDE
"
;
final
String
ACTION_CUT
=
"
org
.
mozilla
.
geckoview
.
CUT
"
;
final
String
ACTION_COPY
=
"
org
.
mozilla
.
geckoview
.
COPY
"
;
final
String
ACTION_DELETE
=
"
org
.
mozilla
.
geckoview
.
DELETE
"
;
final
String
ACTION_PASTE
=
"
org
.
mozilla
.
geckoview
.
PASTE
"
;
final
String
ACTION_SELECT_ALL
=
"
org
.
mozilla
.
geckoview
.
SELECT_ALL
"
;
final
String
ACTION_UNSELECT
=
"
org
.
mozilla
.
geckoview
.
UNSELECT
"
;
final
String
ACTION_COLLAPSE_TO_START
=
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_START
"
;
final
String
ACTION_COLLAPSE_TO_END
=
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_END
"
;
class
Selection
{
public
final
SelectionActionDelegateFlag
int
flags
;
public
final
NonNull
String
text
;
public
final
Nullable
RectF
clientRect
;
public
final
NonNull
SelectionActionDelegateAction
Collection
<
String
>
availableActions
;
private
final
int
mSeqNo
;
private
final
EventCallback
mEventCallback
;
Selection
(
final
GeckoBundle
bundle
final
NonNull
SelectionActionDelegateAction
Set
<
String
>
actions
final
EventCallback
callback
)
{
flags
=
(
bundle
.
getBoolean
(
"
collapsed
"
)
?
SelectionActionDelegate
.
FLAG_IS_COLLAPSED
:
0
)
|
(
bundle
.
getBoolean
(
"
editable
"
)
?
SelectionActionDelegate
.
FLAG_IS_EDITABLE
:
0
)
|
(
bundle
.
getBoolean
(
"
password
"
)
?
SelectionActionDelegate
.
FLAG_IS_PASSWORD
:
0
)
;
text
=
bundle
.
getString
(
"
selection
"
)
;
final
GeckoBundle
rectBundle
=
bundle
.
getBundle
(
"
clientRect
"
)
;
if
(
rectBundle
=
=
null
)
{
clientRect
=
null
;
}
else
{
clientRect
=
new
RectF
(
(
float
)
rectBundle
.
getDouble
(
"
left
"
)
(
float
)
rectBundle
.
getDouble
(
"
top
"
)
(
float
)
rectBundle
.
getDouble
(
"
right
"
)
(
float
)
rectBundle
.
getDouble
(
"
bottom
"
)
)
;
}
availableActions
=
actions
;
mSeqNo
=
bundle
.
getInt
(
"
seqNo
"
)
;
mEventCallback
=
callback
;
}
protected
Selection
(
)
{
flags
=
0
;
text
=
"
"
;
clientRect
=
null
;
availableActions
=
new
HashSet
<
>
(
)
;
mSeqNo
=
0
;
mEventCallback
=
null
;
}
AnyThread
public
boolean
isActionAvailable
(
NonNull
SelectionActionDelegateAction
final
String
action
)
{
return
availableActions
.
contains
(
action
)
;
}
AnyThread
public
void
execute
(
NonNull
SelectionActionDelegateAction
final
String
action
)
{
if
(
!
isActionAvailable
(
action
)
)
{
throw
new
IllegalStateException
(
"
Action
not
available
"
)
;
}
final
GeckoBundle
response
=
new
GeckoBundle
(
2
)
;
response
.
putString
(
"
id
"
action
)
;
response
.
putInt
(
"
seqNo
"
mSeqNo
)
;
mEventCallback
.
sendSuccess
(
response
)
;
}
AnyThread
public
void
hide
(
)
{
execute
(
ACTION_HIDE
)
;
}
AnyThread
public
void
cut
(
)
{
execute
(
ACTION_CUT
)
;
}
AnyThread
public
void
copy
(
)
{
execute
(
ACTION_COPY
)
;
}
AnyThread
public
void
delete
(
)
{
execute
(
ACTION_DELETE
)
;
}
AnyThread
public
void
paste
(
)
{
execute
(
ACTION_PASTE
)
;
}
AnyThread
public
void
selectAll
(
)
{
execute
(
ACTION_SELECT_ALL
)
;
}
AnyThread
public
void
unselect
(
)
{
execute
(
ACTION_UNSELECT
)
;
}
AnyThread
public
void
collapseToStart
(
)
{
execute
(
ACTION_COLLAPSE_TO_START
)
;
}
AnyThread
public
void
collapseToEnd
(
)
{
execute
(
ACTION_COLLAPSE_TO_END
)
;
}
}
UiThread
default
void
onShowActionRequest
(
NonNull
GeckoSession
session
NonNull
Selection
selection
)
{
}
final
int
HIDE_REASON_NO_SELECTION
=
0
;
final
int
HIDE_REASON_INVISIBLE_SELECTION
=
1
;
final
int
HIDE_REASON_ACTIVE_SELECTION
=
2
;
final
int
HIDE_REASON_ACTIVE_SCROLL
=
3
;
UiThread
default
void
onHideAction
(
NonNull
GeckoSession
session
SelectionActionDelegateHideReason
int
reason
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
StringDef
(
{
SelectionActionDelegate
.
ACTION_HIDE
SelectionActionDelegate
.
ACTION_CUT
SelectionActionDelegate
.
ACTION_COPY
SelectionActionDelegate
.
ACTION_DELETE
SelectionActionDelegate
.
ACTION_PASTE
SelectionActionDelegate
.
ACTION_SELECT_ALL
SelectionActionDelegate
.
ACTION_UNSELECT
SelectionActionDelegate
.
ACTION_COLLAPSE_TO_START
SelectionActionDelegate
.
ACTION_COLLAPSE_TO_END
}
)
interface
SelectionActionDelegateAction
{
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
SelectionActionDelegate
.
FLAG_IS_COLLAPSED
SelectionActionDelegate
.
FLAG_IS_EDITABLE
}
)
interface
SelectionActionDelegateFlag
{
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
SelectionActionDelegate
.
HIDE_REASON_NO_SELECTION
SelectionActionDelegate
.
HIDE_REASON_INVISIBLE_SELECTION
SelectionActionDelegate
.
HIDE_REASON_ACTIVE_SELECTION
SelectionActionDelegate
.
HIDE_REASON_ACTIVE_SCROLL
}
)
interface
SelectionActionDelegateHideReason
{
}
public
interface
NavigationDelegate
{
UiThread
default
void
onLocationChange
(
NonNull
GeckoSession
session
Nullable
String
url
)
{
}
UiThread
default
void
onCanGoBack
(
NonNull
GeckoSession
session
boolean
canGoBack
)
{
}
UiThread
default
void
onCanGoForward
(
NonNull
GeckoSession
session
boolean
canGoForward
)
{
}
public
static
final
int
TARGET_WINDOW_NONE
=
0
;
public
static
final
int
TARGET_WINDOW_CURRENT
=
1
;
public
static
final
int
TARGET_WINDOW_NEW
=
2
;
static
final
int
LOAD_REQUEST_IS_REDIRECT
=
0x800000
;
public
static
class
LoadRequest
{
LoadRequest
(
NonNull
final
String
uri
Nullable
final
String
triggerUri
final
int
geckoTarget
final
int
flags
final
boolean
hasUserGesture
final
boolean
isDirectNavigation
)
{
this
.
uri
=
uri
;
this
.
triggerUri
=
triggerUri
;
this
.
target
=
convertGeckoTarget
(
geckoTarget
)
;
this
.
isRedirect
=
(
flags
&
LOAD_REQUEST_IS_REDIRECT
)
!
=
0
;
this
.
hasUserGesture
=
hasUserGesture
;
this
.
isDirectNavigation
=
isDirectNavigation
;
}
protected
LoadRequest
(
)
{
uri
=
"
"
;
triggerUri
=
null
;
target
=
0
;
isRedirect
=
false
;
hasUserGesture
=
false
;
isDirectNavigation
=
false
;
}
private
TargetWindow
int
convertGeckoTarget
(
final
int
geckoTarget
)
{
switch
(
geckoTarget
)
{
case
0
:
case
1
:
return
TARGET_WINDOW_CURRENT
;
default
:
return
TARGET_WINDOW_NEW
;
}
}
public
final
NonNull
String
uri
;
public
final
Nullable
String
triggerUri
;
public
final
TargetWindow
int
target
;
public
final
boolean
isRedirect
;
public
final
boolean
hasUserGesture
;
public
final
boolean
isDirectNavigation
;
Override
public
String
toString
(
)
{
final
StringBuilder
out
=
new
StringBuilder
(
"
LoadRequest
{
"
)
;
out
.
append
(
"
uri
:
"
+
uri
)
.
append
(
"
triggerUri
:
"
+
triggerUri
)
.
append
(
"
target
:
"
+
target
)
.
append
(
"
isRedirect
:
"
+
isRedirect
)
.
append
(
"
hasUserGesture
:
"
+
hasUserGesture
)
.
append
(
"
fromLoadUri
:
"
+
hasUserGesture
)
.
append
(
"
}
"
)
;
return
out
.
toString
(
)
;
}
}
UiThread
default
Nullable
GeckoResult
<
AllowOrDeny
>
onLoadRequest
(
NonNull
GeckoSession
session
NonNull
LoadRequest
request
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
AllowOrDeny
>
onSubframeLoadRequest
(
NonNull
GeckoSession
session
NonNull
LoadRequest
request
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
GeckoSession
>
onNewSession
(
NonNull
GeckoSession
session
NonNull
String
uri
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
String
>
onLoadError
(
NonNull
GeckoSession
session
Nullable
String
uri
NonNull
WebRequestError
error
)
{
return
null
;
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
NavigationDelegate
.
TARGET_WINDOW_NONE
NavigationDelegate
.
TARGET_WINDOW_CURRENT
NavigationDelegate
.
TARGET_WINDOW_NEW
}
)
interface
TargetWindow
{
}
public
interface
PromptDelegate
{
public
class
PromptResponse
{
private
final
BasePrompt
mPrompt
;
PromptResponse
(
NonNull
final
BasePrompt
prompt
)
{
mPrompt
=
prompt
;
}
void
dispatch
(
NonNull
final
EventCallback
callback
)
{
if
(
mPrompt
=
=
null
)
{
throw
new
RuntimeException
(
"
Trying
to
confirm
/
dismiss
a
null
prompt
.
"
)
;
}
mPrompt
.
dispatch
(
callback
)
;
}
}
public
class
BasePrompt
{
private
boolean
mIsCompleted
;
private
boolean
mIsConfirmed
;
private
GeckoBundle
mResult
;
public
final
Nullable
String
title
;
private
BasePrompt
(
Nullable
final
String
title
)
{
this
.
title
=
title
;
mIsConfirmed
=
false
;
mIsCompleted
=
false
;
}
UiThread
protected
NonNull
PromptResponse
confirm
(
)
{
if
(
mIsCompleted
)
{
throw
new
RuntimeException
(
"
Cannot
confirm
/
dismiss
a
Prompt
twice
.
"
)
;
}
mIsCompleted
=
true
;
mIsConfirmed
=
true
;
return
new
PromptResponse
(
this
)
;
}
UiThread
public
NonNull
PromptResponse
dismiss
(
)
{
if
(
mIsCompleted
)
{
throw
new
RuntimeException
(
"
Cannot
confirm
/
dismiss
a
Prompt
twice
.
"
)
;
}
mIsCompleted
=
true
;
return
new
PromptResponse
(
this
)
;
}
GeckoBundle
ensureResult
(
)
{
if
(
mResult
=
=
null
)
{
mResult
=
new
GeckoBundle
(
2
)
;
}
return
mResult
;
}
UiThread
public
boolean
isComplete
(
)
{
return
mIsCompleted
;
}
void
dispatch
(
NonNull
final
EventCallback
callback
)
{
if
(
!
mIsCompleted
)
{
throw
new
RuntimeException
(
"
Trying
to
dispatch
an
incomplete
prompt
.
"
)
;
}
if
(
!
mIsConfirmed
)
{
callback
.
sendSuccess
(
null
)
;
}
else
{
callback
.
sendSuccess
(
mResult
)
;
}
}
}
class
BeforeUnloadPrompt
extends
BasePrompt
{
protected
BeforeUnloadPrompt
(
)
{
super
(
null
)
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
final
Nullable
AllowOrDeny
allowOrDeny
)
{
ensureResult
(
)
.
putBoolean
(
"
allow
"
allowOrDeny
!
=
AllowOrDeny
.
DENY
)
;
return
super
.
confirm
(
)
;
}
}
public
class
AlertPrompt
extends
BasePrompt
{
public
final
Nullable
String
message
;
protected
AlertPrompt
(
Nullable
final
String
title
Nullable
final
String
message
)
{
super
(
title
)
;
this
.
message
=
message
;
}
}
public
class
ButtonPrompt
extends
BasePrompt
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Type
.
POSITIVE
Type
.
NEGATIVE
}
)
interface
ButtonType
{
}
public
static
class
Type
{
public
static
final
int
POSITIVE
=
0
;
public
static
final
int
NEGATIVE
=
2
;
protected
Type
(
)
{
}
}
public
final
Nullable
String
message
;
protected
ButtonPrompt
(
Nullable
final
String
title
Nullable
final
String
message
)
{
super
(
title
)
;
this
.
message
=
message
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
ButtonType
final
int
selection
)
{
ensureResult
(
)
.
putInt
(
"
button
"
selection
)
;
return
super
.
confirm
(
)
;
}
}
public
class
TextPrompt
extends
BasePrompt
{
public
final
Nullable
String
message
;
public
final
Nullable
String
defaultValue
;
protected
TextPrompt
(
Nullable
final
String
title
Nullable
final
String
message
Nullable
final
String
defaultValue
)
{
super
(
title
)
;
this
.
message
=
message
;
this
.
defaultValue
=
defaultValue
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
text
)
{
ensureResult
(
)
.
putString
(
"
text
"
text
)
;
return
super
.
confirm
(
)
;
}
}
public
class
AuthPrompt
extends
BasePrompt
{
public
static
class
AuthOptions
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
Flags
.
HOST
Flags
.
PROXY
Flags
.
ONLY_PASSWORD
Flags
.
PREVIOUS_FAILED
Flags
.
CROSS_ORIGIN_SUB_RESOURCE
}
)
interface
AuthFlag
{
}
public
static
class
Flags
{
public
static
final
int
HOST
=
1
;
public
static
final
int
PROXY
=
2
;
public
static
final
int
ONLY_PASSWORD
=
8
;
public
static
final
int
PREVIOUS_FAILED
=
16
;
public
static
final
int
CROSS_ORIGIN_SUB_RESOURCE
=
32
;
protected
Flags
(
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Level
.
NONE
Level
.
PW_ENCRYPTED
Level
.
SECURE
}
)
interface
AuthLevel
{
}
public
static
class
Level
{
public
static
final
int
NONE
=
0
;
public
static
final
int
PW_ENCRYPTED
=
1
;
public
static
final
int
SECURE
=
2
;
protected
Level
(
)
{
}
}
public
AuthFlag
final
int
flags
;
public
Nullable
final
String
uri
;
public
AuthLevel
final
int
level
;
public
Nullable
final
String
username
;
public
Nullable
final
String
password
;
AuthOptions
(
final
GeckoBundle
options
)
{
flags
=
options
.
getInt
(
"
flags
"
)
;
uri
=
options
.
getString
(
"
uri
"
)
;
level
=
options
.
getInt
(
"
level
"
)
;
username
=
options
.
getString
(
"
username
"
)
;
password
=
options
.
getString
(
"
password
"
)
;
}
protected
AuthOptions
(
)
{
flags
=
0
;
uri
=
"
"
;
level
=
0
;
username
=
"
"
;
password
=
"
"
;
}
}
public
final
Nullable
String
message
;
public
final
NonNull
AuthOptions
authOptions
;
protected
AuthPrompt
(
Nullable
final
String
title
Nullable
final
String
message
NonNull
final
AuthOptions
authOptions
)
{
super
(
title
)
;
this
.
message
=
message
;
this
.
authOptions
=
authOptions
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
password
)
{
ensureResult
(
)
.
putString
(
"
password
"
password
)
;
return
super
.
confirm
(
)
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
username
NonNull
final
String
password
)
{
ensureResult
(
)
.
putString
(
"
username
"
username
)
;
ensureResult
(
)
.
putString
(
"
password
"
password
)
;
return
super
.
confirm
(
)
;
}
}
public
class
ChoicePrompt
extends
BasePrompt
{
public
static
class
Choice
{
public
final
boolean
disabled
;
public
final
Nullable
String
icon
;
public
final
NonNull
String
id
;
public
final
Nullable
Choice
[
]
items
;
public
final
NonNull
String
label
;
public
final
boolean
selected
;
public
final
boolean
separator
;
Choice
(
final
GeckoBundle
choice
)
{
disabled
=
choice
.
getBoolean
(
"
disabled
"
)
;
icon
=
choice
.
getString
(
"
icon
"
)
;
id
=
choice
.
getString
(
"
id
"
)
;
label
=
choice
.
getString
(
"
label
"
)
;
selected
=
choice
.
getBoolean
(
"
selected
"
)
;
separator
=
choice
.
getBoolean
(
"
separator
"
)
;
GeckoBundle
[
]
choices
=
choice
.
getBundleArray
(
"
items
"
)
;
if
(
choices
=
=
null
)
{
items
=
null
;
}
else
{
items
=
new
Choice
[
choices
.
length
]
;
for
(
int
i
=
0
;
i
<
choices
.
length
;
i
+
+
)
{
items
[
i
]
=
new
Choice
(
choices
[
i
]
)
;
}
}
}
protected
Choice
(
)
{
disabled
=
false
;
icon
=
"
"
;
id
=
"
"
;
label
=
"
"
;
selected
=
false
;
separator
=
false
;
items
=
null
;
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Type
.
MENU
Type
.
SINGLE
Type
.
MULTIPLE
}
)
interface
ChoiceType
{
}
public
static
class
Type
{
public
static
final
int
MENU
=
1
;
public
static
final
int
SINGLE
=
2
;
public
static
final
int
MULTIPLE
=
3
;
protected
Type
(
)
{
}
}
public
final
Nullable
String
message
;
public
final
ChoiceType
int
type
;
public
final
NonNull
Choice
[
]
choices
;
protected
ChoicePrompt
(
Nullable
final
String
title
Nullable
final
String
message
ChoiceType
final
int
type
NonNull
final
Choice
[
]
choices
)
{
super
(
title
)
;
this
.
message
=
message
;
this
.
type
=
type
;
this
.
choices
=
choices
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
selectedId
)
{
return
confirm
(
new
String
[
]
{
selectedId
}
)
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
[
]
selectedIds
)
{
if
(
(
Type
.
MENU
=
=
type
|
|
Type
.
SINGLE
=
=
type
)
&
&
(
selectedIds
=
=
null
|
|
selectedIds
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
ensureResult
(
)
.
putStringArray
(
"
choices
"
selectedIds
)
;
return
super
.
confirm
(
)
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
Choice
selectedChoice
)
{
return
confirm
(
selectedChoice
=
=
null
?
null
:
selectedChoice
.
id
)
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
Choice
[
]
selectedChoices
)
{
if
(
(
Type
.
MENU
=
=
type
|
|
Type
.
SINGLE
=
=
type
)
&
&
(
selectedChoices
=
=
null
|
|
selectedChoices
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
selectedChoices
=
=
null
)
{
return
confirm
(
(
String
[
]
)
null
)
;
}
final
String
[
]
ids
=
new
String
[
selectedChoices
.
length
]
;
for
(
int
i
=
0
;
i
<
ids
.
length
;
i
+
+
)
{
ids
[
i
]
=
(
selectedChoices
[
i
]
=
=
null
)
?
null
:
selectedChoices
[
i
]
.
id
;
}
return
confirm
(
ids
)
;
}
}
public
class
ColorPrompt
extends
BasePrompt
{
public
final
Nullable
String
defaultValue
;
protected
ColorPrompt
(
Nullable
final
String
title
Nullable
final
String
defaultValue
)
{
super
(
title
)
;
this
.
defaultValue
=
defaultValue
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
color
)
{
ensureResult
(
)
.
putString
(
"
color
"
color
)
;
return
super
.
confirm
(
)
;
}
}
public
class
DateTimePrompt
extends
BasePrompt
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Type
.
DATE
Type
.
MONTH
Type
.
WEEK
Type
.
TIME
Type
.
DATETIME_LOCAL
}
)
interface
DatetimeType
{
}
public
static
class
Type
{
public
static
final
int
DATE
=
1
;
public
static
final
int
MONTH
=
2
;
public
static
final
int
WEEK
=
3
;
public
static
final
int
TIME
=
4
;
public
static
final
int
DATETIME_LOCAL
=
5
;
protected
Type
(
)
{
}
}
public
final
DatetimeType
int
type
;
public
final
Nullable
String
defaultValue
;
public
final
Nullable
String
minValue
;
public
final
Nullable
String
maxValue
;
protected
DateTimePrompt
(
Nullable
final
String
title
DatetimeType
final
int
type
Nullable
final
String
defaultValue
Nullable
final
String
minValue
Nullable
final
String
maxValue
)
{
super
(
title
)
;
this
.
type
=
type
;
this
.
defaultValue
=
defaultValue
;
this
.
minValue
=
minValue
;
this
.
maxValue
=
maxValue
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
String
datetime
)
{
ensureResult
(
)
.
putString
(
"
datetime
"
datetime
)
;
return
super
.
confirm
(
)
;
}
}
public
class
FilePrompt
extends
BasePrompt
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Type
.
SINGLE
Type
.
MULTIPLE
}
)
interface
FileType
{
}
public
static
class
Type
{
public
static
final
int
SINGLE
=
1
;
public
static
final
int
MULTIPLE
=
2
;
protected
Type
(
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Capture
.
NONE
Capture
.
ANY
Capture
.
USER
Capture
.
ENVIRONMENT
}
)
interface
CaptureType
{
}
public
static
class
Capture
{
public
static
final
int
NONE
=
0
;
public
static
final
int
ANY
=
1
;
public
static
final
int
USER
=
2
;
public
static
final
int
ENVIRONMENT
=
3
;
protected
Capture
(
)
{
}
}
public
final
FileType
int
type
;
public
final
Nullable
String
[
]
mimeTypes
;
public
final
CaptureType
int
capture
;
protected
FilePrompt
(
Nullable
final
String
title
FileType
final
int
type
CaptureType
final
int
capture
Nullable
final
String
[
]
mimeTypes
)
{
super
(
title
)
;
this
.
type
=
type
;
this
.
capture
=
capture
;
this
.
mimeTypes
=
mimeTypes
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
Context
context
NonNull
final
Uri
uri
)
{
return
confirm
(
context
new
Uri
[
]
{
uri
}
)
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
Context
context
NonNull
final
Uri
[
]
uris
)
{
if
(
Type
.
SINGLE
=
=
type
&
&
(
uris
=
=
null
|
|
uris
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
final
String
[
]
paths
=
new
String
[
uris
!
=
null
?
uris
.
length
:
0
]
;
for
(
int
i
=
0
;
i
<
paths
.
length
;
i
+
+
)
{
paths
[
i
]
=
getFile
(
context
uris
[
i
]
)
;
if
(
paths
[
i
]
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Only
file
URIs
are
supported
:
"
+
uris
[
i
]
)
;
}
}
ensureResult
(
)
.
putStringArray
(
"
files
"
paths
)
;
return
super
.
confirm
(
)
;
}
private
static
String
getFile
(
final
NonNull
Context
context
final
NonNull
Uri
uri
)
{
if
(
uri
=
=
null
)
{
return
null
;
}
if
(
"
file
"
.
equals
(
uri
.
getScheme
(
)
)
)
{
return
uri
.
getPath
(
)
;
}
final
ContentResolver
cr
=
context
.
getContentResolver
(
)
;
final
Cursor
cur
=
cr
.
query
(
uri
new
String
[
]
{
"
_data
"
}
null
null
null
)
;
if
(
cur
=
=
null
)
{
return
null
;
}
try
{
final
int
idx
=
cur
.
getColumnIndex
(
"
_data
"
)
;
if
(
idx
<
0
|
|
!
cur
.
moveToFirst
(
)
)
{
return
null
;
}
do
{
try
{
final
String
path
=
cur
.
getString
(
idx
)
;
if
(
path
!
=
null
&
&
!
path
.
isEmpty
(
)
)
{
return
path
;
}
}
catch
(
final
Exception
e
)
{
}
}
while
(
cur
.
moveToNext
(
)
)
;
}
finally
{
cur
.
close
(
)
;
}
return
null
;
}
}
public
class
PopupPrompt
extends
BasePrompt
{
public
final
Nullable
String
targetUri
;
protected
PopupPrompt
(
Nullable
final
String
targetUri
)
{
super
(
null
)
;
this
.
targetUri
=
targetUri
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
NonNull
final
AllowOrDeny
response
)
{
boolean
res
=
false
;
if
(
AllowOrDeny
.
ALLOW
=
=
response
)
{
res
=
true
;
}
ensureResult
(
)
.
putBoolean
(
"
response
"
res
)
;
return
super
.
confirm
(
)
;
}
}
public
class
SharePrompt
extends
BasePrompt
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Result
.
SUCCESS
Result
.
FAILURE
Result
.
ABORT
}
)
interface
ShareResult
{
}
public
static
class
Result
{
public
static
final
int
SUCCESS
=
0
;
public
static
final
int
FAILURE
=
1
;
public
static
final
int
ABORT
=
2
;
protected
Result
(
)
{
}
}
public
final
Nullable
String
text
;
public
final
Nullable
String
uri
;
protected
SharePrompt
(
Nullable
final
String
title
Nullable
final
String
text
Nullable
final
String
uri
)
{
super
(
title
)
;
this
.
text
=
text
;
this
.
uri
=
uri
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
ShareResult
final
int
response
)
{
ensureResult
(
)
.
putInt
(
"
response
"
response
)
;
return
super
.
confirm
(
)
;
}
UiThread
public
NonNull
PromptResponse
dismiss
(
)
{
ensureResult
(
)
.
putInt
(
"
response
"
Result
.
ABORT
)
;
return
super
.
dismiss
(
)
;
}
}
public
class
AutocompleteRequest
<
T
extends
Autocomplete
.
Option
<
?
>
>
extends
BasePrompt
{
public
final
NonNull
T
[
]
options
;
protected
AutocompleteRequest
(
final
NonNull
T
[
]
options
)
{
super
(
null
)
;
this
.
options
=
options
;
}
UiThread
public
NonNull
PromptResponse
confirm
(
final
NonNull
Autocomplete
.
Option
<
?
>
selection
)
{
ensureResult
(
)
.
putBundle
(
"
selection
"
selection
.
toBundle
(
)
)
;
return
super
.
confirm
(
)
;
}
UiThread
public
NonNull
PromptResponse
dismiss
(
)
{
return
super
.
dismiss
(
)
;
}
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onAlertPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
AlertPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onBeforeUnloadPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
BeforeUnloadPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onButtonPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
ButtonPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onTextPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
TextPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onAuthPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
AuthPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onChoicePrompt
(
NonNull
final
GeckoSession
session
NonNull
final
ChoicePrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onColorPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
ColorPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onDateTimePrompt
(
NonNull
final
GeckoSession
session
NonNull
final
DateTimePrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onFilePrompt
(
NonNull
final
GeckoSession
session
NonNull
final
FilePrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onPopupPrompt
(
NonNull
final
GeckoSession
session
NonNull
final
PopupPrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onSharePrompt
(
NonNull
final
GeckoSession
session
NonNull
final
SharePrompt
prompt
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onLoginSave
(
NonNull
final
GeckoSession
session
NonNull
final
AutocompleteRequest
<
Autocomplete
.
LoginSaveOption
>
request
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
PromptResponse
>
onLoginSelect
(
NonNull
final
GeckoSession
session
NonNull
final
AutocompleteRequest
<
Autocomplete
.
LoginSelectOption
>
request
)
{
return
null
;
}
}
public
interface
ScrollDelegate
{
UiThread
default
void
onScrollChanged
(
NonNull
GeckoSession
session
int
scrollX
int
scrollY
)
{
}
}
UiThread
public
NonNull
PanZoomController
getPanZoomController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mPanZoomController
;
}
UiThread
public
NonNull
OverscrollEdgeEffect
getOverscrollEdgeEffect
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mOverscroll
=
=
null
)
{
mOverscroll
=
new
OverscrollEdgeEffect
(
this
)
;
}
return
mOverscroll
;
}
UiThread
public
NonNull
CompositorController
getCompositorController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mController
=
=
null
)
{
mController
=
new
CompositorController
(
this
)
;
if
(
mCompositorReady
)
{
mController
.
onCompositorReady
(
)
;
}
}
return
mController
;
}
UiThread
public
void
getClientToSurfaceMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
matrix
.
setScale
(
mViewportZoom
mViewportZoom
)
;
if
(
mClientTop
!
=
mTop
)
{
matrix
.
postTranslate
(
0
mClientTop
-
mTop
)
;
}
}
UiThread
public
void
getClientToScreenMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
getClientToSurfaceMatrix
(
matrix
)
;
matrix
.
postTranslate
(
mLeft
mTop
)
;
}
UiThread
public
void
getPageToScreenMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
getPageToSurfaceMatrix
(
matrix
)
;
matrix
.
postTranslate
(
mLeft
mTop
)
;
}
UiThread
public
void
getPageToSurfaceMatrix
(
NonNull
final
Matrix
matrix
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
getClientToSurfaceMatrix
(
matrix
)
;
matrix
.
postTranslate
(
-
mViewportLeft
-
mViewportTop
)
;
}
UiThread
public
void
getClientBounds
(
NonNull
final
RectF
rect
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
rect
.
set
(
0
.
0f
0
.
0f
(
float
)
mWidth
/
mViewportZoom
(
float
)
mClientHeight
/
mViewportZoom
)
;
}
UiThread
public
void
getSurfaceBounds
(
NonNull
final
Rect
rect
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
rect
.
set
(
0
mClientTop
-
mTop
mWidth
mHeight
)
;
}
public
interface
PermissionDelegate
{
int
PERMISSION_GEOLOCATION
=
0
;
int
PERMISSION_DESKTOP_NOTIFICATION
=
1
;
int
PERMISSION_PERSISTENT_STORAGE
=
2
;
int
PERMISSION_XR
=
3
;
int
PERMISSION_AUTOPLAY_INAUDIBLE
=
4
;
int
PERMISSION_AUTOPLAY_AUDIBLE
=
5
;
int
PERMISSION_MEDIA_KEY_SYSTEM_ACCESS
=
6
;
interface
Callback
{
UiThread
default
void
grant
(
)
{
}
UiThread
default
void
reject
(
)
{
}
}
UiThread
default
void
onAndroidPermissionsRequest
(
NonNull
GeckoSession
session
Nullable
String
[
]
permissions
NonNull
Callback
callback
)
{
callback
.
reject
(
)
;
}
UiThread
default
void
onContentPermissionRequest
(
NonNull
GeckoSession
session
Nullable
String
uri
Permission
int
type
NonNull
Callback
callback
)
{
callback
.
reject
(
)
;
}
class
MediaSource
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
SOURCE_CAMERA
SOURCE_SCREEN
SOURCE_MICROPHONE
SOURCE_AUDIOCAPTURE
SOURCE_OTHER
}
)
interface
Source
{
}
public
static
final
int
SOURCE_CAMERA
=
0
;
public
static
final
int
SOURCE_SCREEN
=
1
;
public
static
final
int
SOURCE_MICROPHONE
=
2
;
public
static
final
int
SOURCE_AUDIOCAPTURE
=
3
;
public
static
final
int
SOURCE_OTHER
=
4
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
TYPE_VIDEO
TYPE_AUDIO
}
)
interface
Type
{
}
public
static
final
int
TYPE_VIDEO
=
0
;
public
static
final
int
TYPE_AUDIO
=
1
;
public
final
NonNull
String
id
;
public
final
NonNull
String
rawId
;
public
final
Nullable
String
name
;
public
final
Source
int
source
;
public
final
Type
int
type
;
private
static
Source
int
getSourceFromString
(
final
String
src
)
{
if
(
"
camera
"
.
equals
(
src
)
)
{
return
SOURCE_CAMERA
;
}
else
if
(
"
screen
"
.
equals
(
src
)
|
|
"
window
"
.
equals
(
src
)
|
|
"
browser
"
.
equals
(
src
)
)
{
return
SOURCE_SCREEN
;
}
else
if
(
"
microphone
"
.
equals
(
src
)
)
{
return
SOURCE_MICROPHONE
;
}
else
if
(
"
audioCapture
"
.
equals
(
src
)
)
{
return
SOURCE_AUDIOCAPTURE
;
}
else
if
(
"
other
"
.
equals
(
src
)
|
|
"
application
"
.
equals
(
src
)
)
{
return
SOURCE_OTHER
;
}
else
{
throw
new
IllegalArgumentException
(
"
String
:
"
+
src
+
"
is
not
a
valid
media
source
string
"
)
;
}
}
private
static
Type
int
getTypeFromString
(
final
String
type
)
{
if
(
"
videoinput
"
.
equals
(
type
)
)
{
return
TYPE_VIDEO
;
}
else
if
(
"
audioinput
"
.
equals
(
type
)
)
{
return
TYPE_AUDIO
;
}
else
{
throw
new
IllegalArgumentException
(
"
String
:
"
+
type
+
"
is
not
a
valid
media
type
string
"
)
;
}
}
MediaSource
(
final
GeckoBundle
media
)
{
id
=
media
.
getString
(
"
id
"
)
;
rawId
=
media
.
getString
(
"
rawId
"
)
;
name
=
media
.
getString
(
"
name
"
)
;
source
=
getSourceFromString
(
media
.
getString
(
"
mediaSource
"
)
)
;
type
=
getTypeFromString
(
media
.
getString
(
"
type
"
)
)
;
}
protected
MediaSource
(
)
{
id
=
null
;
rawId
=
null
;
name
=
null
;
source
=
0
;
type
=
0
;
}
}
interface
MediaCallback
{
UiThread
default
void
grant
(
final
Nullable
String
video
final
Nullable
String
audio
)
{
}
UiThread
default
void
grant
(
final
Nullable
MediaSource
video
final
Nullable
MediaSource
audio
)
{
}
UiThread
default
void
reject
(
)
{
}
}
UiThread
default
void
onMediaPermissionRequest
(
NonNull
GeckoSession
session
NonNull
String
uri
Nullable
MediaSource
[
]
video
Nullable
MediaSource
[
]
audio
NonNull
MediaCallback
callback
)
{
callback
.
reject
(
)
;
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
PermissionDelegate
.
PERMISSION_GEOLOCATION
PermissionDelegate
.
PERMISSION_DESKTOP_NOTIFICATION
PermissionDelegate
.
PERMISSION_PERSISTENT_STORAGE
PermissionDelegate
.
PERMISSION_XR
PermissionDelegate
.
PERMISSION_AUTOPLAY_INAUDIBLE
PermissionDelegate
.
PERMISSION_AUTOPLAY_AUDIBLE
PermissionDelegate
.
PERMISSION_MEDIA_KEY_SYSTEM_ACCESS
}
)
interface
Permission
{
}
public
interface
TextInputDelegate
{
int
RESTART_REASON_FOCUS
=
0
;
int
RESTART_REASON_BLUR
=
1
;
int
RESTART_REASON_CONTENT_CHANGE
=
2
;
UiThread
default
void
restartInput
(
NonNull
GeckoSession
session
RestartReason
int
reason
)
{
}
UiThread
default
void
showSoftInput
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
hideSoftInput
(
NonNull
GeckoSession
session
)
{
}
UiThread
default
void
updateSelection
(
NonNull
GeckoSession
session
int
selStart
int
selEnd
int
compositionStart
int
compositionEnd
)
{
}
UiThread
default
void
updateExtractedText
(
NonNull
GeckoSession
session
NonNull
ExtractedTextRequest
request
NonNull
ExtractedText
text
)
{
}
UiThread
default
void
updateCursorAnchorInfo
(
NonNull
GeckoSession
session
NonNull
CursorAnchorInfo
info
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
TextInputDelegate
.
RESTART_REASON_FOCUS
TextInputDelegate
.
RESTART_REASON_BLUR
TextInputDelegate
.
RESTART_REASON_CONTENT_CHANGE
}
)
interface
RestartReason
{
}
void
onSurfaceChanged
(
final
Surface
surface
final
int
x
final
int
y
final
int
width
final
int
height
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mOffsetX
=
x
;
mOffsetY
=
y
;
mWidth
=
width
;
mHeight
=
height
;
if
(
mCompositorReady
)
{
mCompositor
.
syncResumeResizeCompositor
(
x
y
width
height
surface
)
;
onWindowBoundsChanged
(
)
;
return
;
}
mSurface
=
surface
;
onWindowBoundsChanged
(
)
;
}
void
onSurfaceDestroyed
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mCompositorReady
)
{
mCompositor
.
syncPauseCompositor
(
)
;
return
;
}
mSurface
=
null
;
}
void
onScreenOriginChanged
(
final
int
left
final
int
top
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mLeft
=
=
left
&
&
mTop
=
=
top
)
{
return
;
}
mLeft
=
left
;
mTop
=
top
;
onWindowBoundsChanged
(
)
;
}
void
setDynamicToolbarMaxHeight
(
final
int
height
)
{
if
(
mDynamicToolbarMaxHeight
=
=
height
)
{
return
;
}
if
(
mHeight
!
=
0
&
&
height
!
=
0
&
&
mHeight
<
height
)
{
Log
.
w
(
LOGTAG
new
AssertionError
(
"
The
maximum
height
of
the
dynamic
toolbar
(
"
+
height
+
"
)
should
be
smaller
than
GeckoView
height
(
"
+
mHeight
+
"
)
"
)
)
;
}
mDynamicToolbarMaxHeight
=
height
;
if
(
mAttachedCompositor
)
{
mCompositor
.
setDynamicToolbarMaxHeight
(
mDynamicToolbarMaxHeight
)
;
}
}
void
setFixedBottomOffset
(
final
int
offset
)
{
if
(
mFixedBottomOffset
=
=
offset
)
{
return
;
}
mFixedBottomOffset
=
offset
;
if
(
mCompositorReady
)
{
mCompositor
.
setFixedBottomOffset
(
mFixedBottomOffset
)
;
}
}
void
onCompositorAttached
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mAttachedCompositor
=
true
;
mCompositor
.
attachNPZC
(
mPanZoomController
.
mNative
)
;
if
(
mSurface
!
=
null
)
{
onSurfaceChanged
(
mSurface
mOffsetX
mOffsetY
mWidth
mHeight
)
;
}
mCompositor
.
sendToolbarAnimatorMessage
(
IS_COMPOSITOR_CONTROLLER_OPEN
)
;
mCompositor
.
setDynamicToolbarMaxHeight
(
mDynamicToolbarMaxHeight
)
;
}
void
onCompositorDetached
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mController
!
=
null
)
{
mController
.
onCompositorDetached
(
)
;
}
mAttachedCompositor
=
false
;
mCompositorReady
=
false
;
}
void
handleCompositorMessage
(
final
int
message
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
switch
(
message
)
{
case
COMPOSITOR_CONTROLLER_OPEN
:
{
if
(
isCompositorReady
(
)
)
{
return
;
}
ThreadUtils
.
postToUiThread
(
this
:
:
onCompositorReady
)
;
break
;
}
case
FIRST_PAINT
:
{
if
(
mController
!
=
null
)
{
mController
.
onFirstPaint
(
)
;
}
ContentDelegate
delegate
=
mContentHandler
.
getDelegate
(
)
;
if
(
delegate
!
=
null
)
{
delegate
.
onFirstComposite
(
this
)
;
}
break
;
}
case
LAYERS_UPDATED
:
{
if
(
mController
!
=
null
)
{
mController
.
notifyDrawCallbacks
(
)
;
}
break
;
}
default
:
{
Log
.
w
(
LOGTAG
"
Unexpected
message
:
"
+
message
)
;
break
;
}
}
}
boolean
isCompositorReady
(
)
{
return
mCompositorReady
;
}
void
onCompositorReady
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
!
mAttachedCompositor
)
{
return
;
}
mCompositorReady
=
true
;
if
(
mController
!
=
null
)
{
mController
.
onCompositorReady
(
)
;
}
if
(
mSurface
!
=
null
)
{
onSurfaceChanged
(
mSurface
mOffsetX
mOffsetY
mWidth
mHeight
)
;
mSurface
=
null
;
}
if
(
mFixedBottomOffset
!
=
0
)
{
mCompositor
.
setFixedBottomOffset
(
mFixedBottomOffset
)
;
}
}
void
updateOverscrollVelocity
(
final
float
x
final
float
y
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mOverscroll
=
=
null
)
{
return
;
}
mOverscroll
.
setVelocity
(
x
*
1000
.
0f
OverscrollEdgeEffect
.
AXIS_X
)
;
mOverscroll
.
setVelocity
(
y
*
1000
.
0f
OverscrollEdgeEffect
.
AXIS_Y
)
;
}
void
updateOverscrollOffset
(
final
float
x
final
float
y
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mOverscroll
=
=
null
)
{
return
;
}
mOverscroll
.
setDistance
(
x
OverscrollEdgeEffect
.
AXIS_X
)
;
mOverscroll
.
setDistance
(
y
OverscrollEdgeEffect
.
AXIS_Y
)
;
}
void
onMetricsChanged
(
final
float
scrollX
final
float
scrollY
final
float
zoom
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mViewportLeft
=
scrollX
;
mViewportTop
=
scrollY
;
mViewportZoom
=
zoom
;
}
void
onWindowBoundsChanged
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
if
(
mHeight
!
=
0
&
&
mDynamicToolbarMaxHeight
!
=
0
&
&
mHeight
<
mDynamicToolbarMaxHeight
)
{
Log
.
w
(
LOGTAG
new
AssertionError
(
"
The
maximum
height
of
the
dynamic
toolbar
(
"
+
mDynamicToolbarMaxHeight
+
"
)
should
be
smaller
than
GeckoView
height
(
"
+
mHeight
+
"
)
"
)
)
;
}
final
int
toolbarHeight
=
0
;
mClientTop
=
mTop
+
toolbarHeight
;
mClientHeight
=
Math
.
max
(
mHeight
-
toolbarHeight
0
)
;
if
(
mAttachedCompositor
)
{
mCompositor
.
onBoundsChanged
(
mLeft
mClientTop
mWidth
mClientHeight
)
;
}
if
(
mOverscroll
!
=
null
)
{
mOverscroll
.
setSize
(
mWidth
mClientHeight
)
;
}
}
void
onSafeAreaInsetsChanged
(
final
int
top
final
int
right
final
int
bottom
final
int
left
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mAttachedCompositor
)
{
mCompositor
.
onSafeAreaInsetsChanged
(
top
right
bottom
left
)
;
}
}
public
interface
MediaDelegate
{
class
RecordingDevice
{
public
static
class
Status
{
public
static
final
long
RECORDING
=
0
;
public
static
final
long
INACTIVE
=
1
<
<
0
;
protected
Status
(
)
{
}
}
public
static
class
Type
{
public
static
final
long
CAMERA
=
0
;
public
static
final
long
MICROPHONE
=
1
<
<
0
;
protected
Type
(
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
LongDef
(
flag
=
true
value
=
{
Status
.
RECORDING
Status
.
INACTIVE
}
)
interface
RecordingStatus
{
}
Retention
(
RetentionPolicy
.
SOURCE
)
LongDef
(
flag
=
true
value
=
{
Type
.
CAMERA
Type
.
MICROPHONE
}
)
interface
DeviceType
{
}
public
final
RecordingStatus
long
status
;
public
final
DeviceType
long
type
;
private
static
DeviceType
long
getTypeFromString
(
final
String
type
)
{
if
(
"
microphone
"
.
equals
(
type
)
)
{
return
Type
.
MICROPHONE
;
}
else
if
(
"
camera
"
.
equals
(
type
)
)
{
return
Type
.
CAMERA
;
}
else
{
throw
new
IllegalArgumentException
(
"
String
:
"
+
type
+
"
is
not
a
valid
recording
device
string
"
)
;
}
}
private
static
RecordingStatus
long
getStatusFromString
(
final
String
type
)
{
if
(
"
recording
"
.
equals
(
type
)
)
{
return
Status
.
RECORDING
;
}
else
{
return
Status
.
INACTIVE
;
}
}
RecordingDevice
(
final
GeckoBundle
media
)
{
status
=
getStatusFromString
(
media
.
getString
(
"
status
"
)
)
;
type
=
getTypeFromString
(
media
.
getString
(
"
type
"
)
)
;
}
protected
RecordingDevice
(
)
{
status
=
Status
.
INACTIVE
;
type
=
Type
.
CAMERA
;
}
}
UiThread
default
void
onMediaAdd
(
NonNull
GeckoSession
session
NonNull
MediaElement
element
)
{
}
UiThread
default
void
onMediaRemove
(
NonNull
GeckoSession
session
NonNull
MediaElement
element
)
{
}
UiThread
default
void
onRecordingStatusChanged
(
NonNull
GeckoSession
session
NonNull
RecordingDevice
[
]
devices
)
{
}
}
public
interface
HistoryDelegate
{
public
interface
HistoryItem
{
AnyThread
default
NonNull
String
getUri
(
)
{
throw
new
UnsupportedOperationException
(
"
HistoryItem
.
getUri
(
)
called
on
invalid
object
.
"
)
;
}
AnyThread
default
NonNull
String
getTitle
(
)
{
throw
new
UnsupportedOperationException
(
"
HistoryItem
.
getString
(
)
called
on
invalid
object
.
"
)
;
}
}
public
interface
HistoryList
extends
List
<
HistoryItem
>
{
AnyThread
default
int
getCurrentIndex
(
)
{
throw
new
UnsupportedOperationException
(
"
HistoryList
.
getCurrentIndex
(
)
called
on
invalid
object
.
"
)
;
}
}
final
int
VISIT_TOP_LEVEL
=
1
<
<
0
;
final
int
VISIT_REDIRECT_TEMPORARY
=
1
<
<
1
;
final
int
VISIT_REDIRECT_PERMANENT
=
1
<
<
2
;
final
int
VISIT_REDIRECT_SOURCE
=
1
<
<
3
;
final
int
VISIT_REDIRECT_SOURCE_PERMANENT
=
1
<
<
4
;
final
int
VISIT_UNRECOVERABLE_ERROR
=
1
<
<
5
;
UiThread
default
Nullable
GeckoResult
<
Boolean
>
onVisited
(
NonNull
GeckoSession
session
NonNull
String
url
Nullable
String
lastVisitedURL
VisitFlags
int
flags
)
{
return
null
;
}
UiThread
default
Nullable
GeckoResult
<
boolean
[
]
>
getVisited
(
NonNull
GeckoSession
session
NonNull
String
[
]
urls
)
{
return
null
;
}
UiThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
default
void
onHistoryStateChange
(
NonNull
GeckoSession
session
NonNull
HistoryList
historyList
)
{
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
HistoryDelegate
.
VISIT_TOP_LEVEL
HistoryDelegate
.
VISIT_REDIRECT_TEMPORARY
HistoryDelegate
.
VISIT_REDIRECT_PERMANENT
HistoryDelegate
.
VISIT_REDIRECT_SOURCE
HistoryDelegate
.
VISIT_REDIRECT_SOURCE_PERMANENT
HistoryDelegate
.
VISIT_UNRECOVERABLE_ERROR
}
)
interface
VisitFlags
{
}
private
Autofill
.
Support
getAutofillSupport
(
)
{
return
mAutofillSupport
;
}
UiThread
public
void
setAutofillDelegate
(
final
Nullable
Autofill
.
Delegate
delegate
)
{
getAutofillSupport
(
)
.
setDelegate
(
delegate
)
;
}
UiThread
public
Nullable
Autofill
.
Delegate
getAutofillDelegate
(
)
{
return
getAutofillSupport
(
)
.
getDelegate
(
)
;
}
UiThread
public
void
autofill
(
final
NonNull
SparseArray
<
CharSequence
>
values
)
{
getAutofillSupport
(
)
.
autofill
(
values
)
;
}
UiThread
public
NonNull
Autofill
.
Session
getAutofillSession
(
)
{
return
getAutofillSupport
(
)
.
getAutofillSession
(
)
;
}
private
static
String
rgbaToArgb
(
final
String
color
)
{
if
(
color
.
length
(
)
!
=
9
|
|
!
color
.
startsWith
(
"
#
"
)
)
{
throw
new
IllegalArgumentException
(
"
Invalid
color
format
"
)
;
}
return
"
#
"
+
color
.
substring
(
7
)
+
color
.
substring
(
1
7
)
;
}
private
static
void
fixupManifestColor
(
final
JSONObject
manifest
final
String
name
)
throws
JSONException
{
if
(
manifest
.
isNull
(
name
)
)
{
return
;
}
manifest
.
put
(
name
rgbaToArgb
(
manifest
.
getString
(
name
)
)
)
;
}
private
static
JSONObject
fixupWebAppManifest
(
final
JSONObject
manifest
)
{
try
{
fixupManifestColor
(
manifest
"
theme_color
"
)
;
fixupManifestColor
(
manifest
"
background_color
"
)
;
}
catch
(
JSONException
e
)
{
Log
.
w
(
LOGTAG
"
Failed
to
fixup
web
app
manifest
"
e
)
;
}
return
manifest
;
}
}
