package
org
.
mozilla
.
geckoview
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
net
.
URLConnection
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
UUID
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerSession
;
import
org
.
mozilla
.
gecko
.
GeckoEditableChild
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
import
org
.
mozilla
.
gecko
.
IGeckoEditableParent
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
NativeQueue
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Resources
;
import
android
.
database
.
Cursor
;
import
android
.
graphics
.
RectF
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Binder
;
import
android
.
os
.
IBinder
;
import
android
.
os
.
IInterface
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
StringDef
;
import
android
.
util
.
Base64
;
import
android
.
util
.
Log
;
import
android
.
view
.
Surface
;
import
android
.
view
.
inputmethod
.
CursorAnchorInfo
;
import
android
.
view
.
inputmethod
.
ExtractedText
;
import
android
.
view
.
inputmethod
.
ExtractedTextRequest
;
public
final
class
GeckoSession
extends
LayerSession
implements
Parcelable
{
private
static
final
String
LOGTAG
=
"
GeckoSession
"
;
private
static
final
boolean
DEBUG
=
false
;
private
static
final
int
WINDOW_CLOSE
=
0
;
private
static
final
int
WINDOW_OPEN
=
1
;
private
static
final
int
WINDOW_TRANSFER_OUT
=
2
;
private
static
final
int
WINDOW_TRANSFER_IN
=
3
;
private
enum
State
implements
NativeQueue
.
State
{
INITIAL
(
0
)
READY
(
1
)
;
private
final
int
mRank
;
private
State
(
int
rank
)
{
mRank
=
rank
;
}
Override
public
boolean
is
(
final
NativeQueue
.
State
other
)
{
return
this
=
=
other
;
}
Override
public
boolean
isAtLeast
(
final
NativeQueue
.
State
other
)
{
return
(
other
instanceof
State
)
&
&
mRank
>
=
(
(
State
)
other
)
.
mRank
;
}
}
private
final
NativeQueue
mNativeQueue
=
new
NativeQueue
(
State
.
INITIAL
State
.
READY
)
;
private
final
EventDispatcher
mEventDispatcher
=
new
EventDispatcher
(
mNativeQueue
)
;
private
final
SessionTextInput
mTextInput
=
new
SessionTextInput
(
this
mNativeQueue
)
;
private
SessionAccessibility
mAccessibility
;
private
SessionFinder
mFinder
;
private
String
mId
=
UUID
.
randomUUID
(
)
.
toString
(
)
.
replace
(
"
-
"
"
"
)
;
String
getId
(
)
{
return
mId
;
}
static
abstract
class
CallbackResult
<
T
>
extends
GeckoResult
<
T
>
implements
EventCallback
{
Override
public
void
sendError
(
Object
response
)
{
completeExceptionally
(
response
!
=
null
?
new
Exception
(
response
.
toString
(
)
)
:
new
UnknownError
(
)
)
;
}
}
private
final
GeckoSessionHandler
<
ContentDelegate
>
mContentHandler
=
new
GeckoSessionHandler
<
ContentDelegate
>
(
"
GeckoViewContent
"
this
new
String
[
]
{
"
GeckoView
:
ContentCrash
"
"
GeckoView
:
ContextMenu
"
"
GeckoView
:
DOMTitleChanged
"
"
GeckoView
:
DOMWindowFocus
"
"
GeckoView
:
DOMWindowClose
"
"
GeckoView
:
ExternalResponse
"
"
GeckoView
:
FullScreenEnter
"
"
GeckoView
:
FullScreenExit
"
}
)
{
Override
public
void
handleMessage
(
final
ContentDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ContentCrash
"
.
equals
(
event
)
)
{
close
(
)
;
delegate
.
onCrash
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
ContextMenu
"
.
equals
(
event
)
)
{
final
int
type
=
getContentElementType
(
message
.
getString
(
"
elementType
"
)
)
;
delegate
.
onContextMenu
(
GeckoSession
.
this
message
.
getInt
(
"
screenX
"
)
message
.
getInt
(
"
screenY
"
)
message
.
getString
(
"
uri
"
)
type
message
.
getString
(
"
elementSrc
"
)
)
;
}
else
if
(
"
GeckoView
:
DOMTitleChanged
"
.
equals
(
event
)
)
{
delegate
.
onTitleChange
(
GeckoSession
.
this
message
.
getString
(
"
title
"
)
)
;
}
else
if
(
"
GeckoView
:
DOMWindowFocus
"
.
equals
(
event
)
)
{
delegate
.
onFocusRequest
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
DOMWindowClose
"
.
equals
(
event
)
)
{
delegate
.
onCloseRequest
(
GeckoSession
.
this
)
;
}
else
if
(
"
GeckoView
:
FullScreenEnter
"
.
equals
(
event
)
)
{
delegate
.
onFullScreen
(
GeckoSession
.
this
true
)
;
}
else
if
(
"
GeckoView
:
FullScreenExit
"
.
equals
(
event
)
)
{
delegate
.
onFullScreen
(
GeckoSession
.
this
false
)
;
}
else
if
(
"
GeckoView
:
ExternalResponse
"
.
equals
(
event
)
)
{
delegate
.
onExternalResponse
(
GeckoSession
.
this
new
WebResponseInfo
(
message
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
NavigationDelegate
>
mNavigationHandler
=
new
GeckoSessionHandler
<
NavigationDelegate
>
(
"
GeckoViewNavigation
"
this
new
String
[
]
{
"
GeckoView
:
LocationChange
"
"
GeckoView
:
OnLoadError
"
"
GeckoView
:
OnLoadRequest
"
"
GeckoView
:
OnNewSession
"
}
)
{
private
int
convertGeckoTarget
(
int
geckoTarget
)
{
switch
(
geckoTarget
)
{
case
0
:
case
1
:
return
NavigationDelegate
.
TARGET_WINDOW_CURRENT
;
default
:
return
NavigationDelegate
.
TARGET_WINDOW_NEW
;
}
}
private
int
filterFlags
(
int
flags
)
{
return
flags
&
NavigationDelegate
.
LOAD_REQUEST_IS_USER_TRIGGERED
;
}
private
NavigationDelegate
.
LoadErrorCategory
int
getErrorCategory
(
long
errorModule
NavigationDelegate
.
LoadError
int
error
)
{
if
(
errorModule
=
=
21
)
{
return
NavigationDelegate
.
ERROR_CATEGORY_SECURITY
;
}
return
error
&
0xF
;
}
private
NavigationDelegate
.
LoadError
int
convertGeckoError
(
long
geckoError
int
geckoErrorModule
int
geckoErrorClass
)
{
if
(
geckoError
=
=
0x805D001FL
)
{
return
NavigationDelegate
.
ERROR_SAFEBROWSING_PHISHING_URI
;
}
if
(
geckoError
=
=
0x805D001EL
)
{
return
NavigationDelegate
.
ERROR_SAFEBROWSING_MALWARE_URI
;
}
if
(
geckoError
=
=
0x805D0023L
)
{
return
NavigationDelegate
.
ERROR_SAFEBROWSING_UNWANTED_URI
;
}
if
(
geckoError
=
=
0x805D0026L
)
{
return
NavigationDelegate
.
ERROR_SAFEBROWSING_HARMFUL_URI
;
}
if
(
geckoError
=
=
0x805E0010L
)
{
return
NavigationDelegate
.
ERROR_CONTENT_CRASHED
;
}
if
(
geckoError
=
=
0x804B001BL
)
{
return
NavigationDelegate
.
ERROR_INVALID_CONTENT_ENCODING
;
}
if
(
geckoError
=
=
0x804B004AL
)
{
return
NavigationDelegate
.
ERROR_UNSAFE_CONTENT_TYPE
;
}
if
(
geckoError
=
=
0x804B001DL
)
{
return
NavigationDelegate
.
ERROR_CORRUPTED_CONTENT
;
}
if
(
geckoError
=
=
0x804B0014L
)
{
return
NavigationDelegate
.
ERROR_NET_RESET
;
}
if
(
geckoError
=
=
0x804B0047L
)
{
return
NavigationDelegate
.
ERROR_NET_INTERRUPT
;
}
if
(
geckoError
=
=
0x804B000EL
)
{
return
NavigationDelegate
.
ERROR_NET_TIMEOUT
;
}
if
(
geckoError
=
=
0x804B000DL
)
{
return
NavigationDelegate
.
ERROR_CONNECTION_REFUSED
;
}
if
(
geckoError
=
=
0x804B0033L
)
{
return
NavigationDelegate
.
ERROR_UNKNOWN_SOCKET_TYPE
;
}
if
(
geckoError
=
=
0x804B001FL
)
{
return
NavigationDelegate
.
ERROR_REDIRECT_LOOP
;
}
if
(
geckoError
=
=
0x804B0010L
)
{
return
NavigationDelegate
.
ERROR_OFFLINE
;
}
if
(
geckoError
=
=
0x804B0013L
)
{
return
NavigationDelegate
.
ERROR_PORT_BLOCKED
;
}
if
(
geckoError
=
=
0x804B0012L
)
{
return
NavigationDelegate
.
ERROR_UNKNOWN_PROTOCOL
;
}
if
(
geckoError
=
=
0x804B001EL
)
{
return
NavigationDelegate
.
ERROR_UNKNOWN_HOST
;
}
if
(
geckoError
=
=
0x804B000AL
)
{
return
NavigationDelegate
.
ERROR_MALFORMED_URI
;
}
if
(
geckoError
=
=
0x80520012L
)
{
return
NavigationDelegate
.
ERROR_FILE_NOT_FOUND
;
}
if
(
geckoError
=
=
0x80520015L
)
{
return
NavigationDelegate
.
ERROR_FILE_ACCESS_DENIED
;
}
if
(
geckoError
=
=
0x804B002AL
)
{
return
NavigationDelegate
.
ERROR_UNKNOWN_PROXY_HOST
;
}
if
(
geckoError
=
=
0x804B0048L
)
{
return
NavigationDelegate
.
ERROR_PROXY_CONNECTION_REFUSED
;
}
if
(
geckoErrorModule
=
=
21
)
{
if
(
geckoErrorClass
=
=
1
)
{
return
NavigationDelegate
.
ERROR_SECURITY_SSL
;
}
if
(
geckoErrorClass
=
=
2
)
{
return
NavigationDelegate
.
ERROR_SECURITY_BAD_CERT
;
}
}
return
NavigationDelegate
.
ERROR_UNKNOWN
;
}
Override
public
void
handleMessage
(
final
NavigationDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
LocationChange
"
.
equals
(
event
)
)
{
if
(
message
.
getBoolean
(
"
isTopLevel
"
)
)
{
delegate
.
onLocationChange
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
)
;
}
delegate
.
onCanGoBack
(
GeckoSession
.
this
message
.
getBoolean
(
"
canGoBack
"
)
)
;
delegate
.
onCanGoForward
(
GeckoSession
.
this
message
.
getBoolean
(
"
canGoForward
"
)
)
;
}
else
if
(
"
GeckoView
:
OnLoadRequest
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
int
where
=
convertGeckoTarget
(
message
.
getInt
(
"
where
"
)
)
;
final
int
flags
=
filterFlags
(
message
.
getInt
(
"
flags
"
)
)
;
if
(
!
IntentUtils
.
isUriSafeForScheme
(
uri
)
)
{
callback
.
sendError
(
"
Blocked
unsafe
intent
URI
"
)
;
delegate
.
onLoadError
(
GeckoSession
.
this
uri
NavigationDelegate
.
ERROR_CATEGORY_URI
NavigationDelegate
.
ERROR_MALFORMED_URI
)
;
return
;
}
final
GeckoResult
<
Boolean
>
result
=
delegate
.
onLoadRequest
(
GeckoSession
.
this
uri
where
flags
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
result
.
then
(
new
GeckoResult
.
OnValueListener
<
Boolean
Void
>
(
)
{
Override
public
GeckoResult
<
Void
>
onValue
(
Boolean
value
)
throws
Throwable
{
ThreadUtils
.
assertOnUiThread
(
)
;
callback
.
sendSuccess
(
value
)
;
return
null
;
}
}
new
GeckoResult
.
OnExceptionListener
<
Void
>
(
)
{
Override
public
GeckoResult
<
Void
>
onException
(
Throwable
exception
)
throws
Throwable
{
callback
.
sendError
(
exception
.
getMessage
(
)
)
;
return
null
;
}
}
)
;
}
else
if
(
"
GeckoView
:
OnLoadError
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
long
errorCode
=
message
.
getLong
(
"
error
"
)
;
final
int
errorModule
=
message
.
getInt
(
"
errorModule
"
)
;
final
int
errorClass
=
message
.
getInt
(
"
errorClass
"
)
;
final
int
error
=
convertGeckoError
(
errorCode
errorModule
errorClass
)
;
final
int
errorCat
=
getErrorCategory
(
errorModule
error
)
;
final
GeckoResult
<
String
>
result
=
delegate
.
onLoadError
(
GeckoSession
.
this
uri
errorCat
error
)
;
if
(
result
=
=
null
)
{
if
(
GeckoAppShell
.
isFennec
(
)
)
{
callback
.
sendSuccess
(
null
)
;
}
else
{
callback
.
sendError
(
"
abort
"
)
;
}
return
;
}
result
.
then
(
new
GeckoResult
.
OnValueListener
<
String
Void
>
(
)
{
Override
public
GeckoResult
<
Void
>
onValue
(
Nullable
String
url
)
throws
Throwable
{
if
(
url
=
=
null
)
{
if
(
GeckoAppShell
.
isFennec
(
)
)
{
callback
.
sendSuccess
(
null
)
;
}
else
{
callback
.
sendError
(
"
abort
"
)
;
}
}
else
{
callback
.
sendSuccess
(
url
)
;
}
return
null
;
}
}
new
GeckoResult
.
OnExceptionListener
<
Void
>
(
)
{
Override
public
GeckoResult
<
Void
>
onException
(
NonNull
Throwable
exception
)
throws
Throwable
{
callback
.
sendError
(
exception
.
getMessage
(
)
)
;
return
null
;
}
}
)
;
}
else
if
(
"
GeckoView
:
OnNewSession
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
GeckoResult
<
GeckoSession
>
result
=
delegate
.
onNewSession
(
GeckoSession
.
this
uri
)
;
if
(
result
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
result
.
then
(
new
GeckoResult
.
OnValueListener
<
GeckoSession
Void
>
(
)
{
Override
public
GeckoResult
<
Void
>
onValue
(
GeckoSession
session
)
throws
Throwable
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
session
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
null
;
}
if
(
session
.
isOpen
(
)
)
{
throw
new
IllegalArgumentException
(
"
Must
use
an
unopened
GeckoSession
instance
"
)
;
}
if
(
GeckoSession
.
this
.
mWindow
=
=
null
)
{
callback
.
sendError
(
"
Session
is
not
attached
to
a
window
"
)
;
}
else
{
session
.
open
(
GeckoSession
.
this
.
mWindow
.
runtime
)
;
callback
.
sendSuccess
(
session
.
getId
(
)
)
;
}
return
null
;
}
}
new
GeckoResult
.
OnExceptionListener
<
Void
>
(
)
{
Override
public
GeckoResult
<
Void
>
onException
(
Throwable
exception
)
throws
Throwable
{
callback
.
sendError
(
exception
.
getMessage
(
)
)
;
return
null
;
}
}
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
ProgressDelegate
>
mProgressHandler
=
new
GeckoSessionHandler
<
ProgressDelegate
>
(
"
GeckoViewProgress
"
this
new
String
[
]
{
"
GeckoView
:
PageStart
"
"
GeckoView
:
PageStop
"
"
GeckoView
:
ProgressChanged
"
"
GeckoView
:
SecurityChanged
"
}
)
{
Override
public
void
handleMessage
(
final
ProgressDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
PageStart
"
.
equals
(
event
)
)
{
delegate
.
onPageStart
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
)
;
}
else
if
(
"
GeckoView
:
PageStop
"
.
equals
(
event
)
)
{
delegate
.
onPageStop
(
GeckoSession
.
this
message
.
getBoolean
(
"
success
"
)
)
;
}
else
if
(
"
GeckoView
:
ProgressChanged
"
.
equals
(
event
)
)
{
delegate
.
onProgressChange
(
GeckoSession
.
this
message
.
getInt
(
"
progress
"
)
)
;
}
else
if
(
"
GeckoView
:
SecurityChanged
"
.
equals
(
event
)
)
{
final
GeckoBundle
identity
=
message
.
getBundle
(
"
identity
"
)
;
delegate
.
onSecurityChange
(
GeckoSession
.
this
new
ProgressDelegate
.
SecurityInformation
(
identity
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
ScrollDelegate
>
mScrollHandler
=
new
GeckoSessionHandler
<
ScrollDelegate
>
(
"
GeckoViewScroll
"
this
new
String
[
]
{
"
GeckoView
:
ScrollChanged
"
}
)
{
Override
public
void
handleMessage
(
final
ScrollDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ScrollChanged
"
.
equals
(
event
)
)
{
delegate
.
onScrollChanged
(
GeckoSession
.
this
message
.
getInt
(
"
scrollX
"
)
message
.
getInt
(
"
scrollY
"
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
TrackingProtectionDelegate
>
mTrackingProtectionHandler
=
new
GeckoSessionHandler
<
TrackingProtectionDelegate
>
(
"
GeckoViewTrackingProtection
"
this
new
String
[
]
{
"
GeckoView
:
TrackingProtectionBlocked
"
}
)
{
Override
public
void
handleMessage
(
final
TrackingProtectionDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
TrackingProtectionBlocked
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
src
"
)
;
final
String
matchedList
=
message
.
getString
(
"
matchedList
"
)
;
delegate
.
onTrackerBlocked
(
GeckoSession
.
this
uri
TrackingProtection
.
listToCategory
(
matchedList
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
PermissionDelegate
>
mPermissionHandler
=
new
GeckoSessionHandler
<
PermissionDelegate
>
(
"
GeckoViewPermission
"
this
new
String
[
]
{
"
GeckoView
:
AndroidPermission
"
"
GeckoView
:
ContentPermission
"
"
GeckoView
:
MediaPermission
"
}
)
{
Override
public
void
handleMessage
(
final
PermissionDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
delegate
=
=
null
)
{
callback
.
sendSuccess
(
false
)
;
return
;
}
if
(
"
GeckoView
:
AndroidPermission
"
.
equals
(
event
)
)
{
delegate
.
onAndroidPermissionsRequest
(
GeckoSession
.
this
message
.
getStringArray
(
"
perms
"
)
new
PermissionCallback
(
"
android
"
callback
)
)
;
}
else
if
(
"
GeckoView
:
ContentPermission
"
.
equals
(
event
)
)
{
final
String
typeString
=
message
.
getString
(
"
perm
"
)
;
final
int
type
;
if
(
"
geolocation
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_GEOLOCATION
;
}
else
if
(
"
desktop
-
notification
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_DESKTOP_NOTIFICATION
;
}
else
if
(
"
autoplay
-
media
"
.
equals
(
typeString
)
)
{
type
=
PermissionDelegate
.
PERMISSION_AUTOPLAY_MEDIA
;
}
else
{
throw
new
IllegalArgumentException
(
"
Unknown
permission
request
:
"
+
typeString
)
;
}
delegate
.
onContentPermissionRequest
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
type
message
.
getString
(
"
access
"
)
new
PermissionCallback
(
typeString
callback
)
)
;
}
else
if
(
"
GeckoView
:
MediaPermission
"
.
equals
(
event
)
)
{
GeckoBundle
[
]
videoBundles
=
message
.
getBundleArray
(
"
video
"
)
;
GeckoBundle
[
]
audioBundles
=
message
.
getBundleArray
(
"
audio
"
)
;
PermissionDelegate
.
MediaSource
[
]
videos
=
null
;
PermissionDelegate
.
MediaSource
[
]
audios
=
null
;
if
(
videoBundles
!
=
null
)
{
videos
=
new
PermissionDelegate
.
MediaSource
[
videoBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
videoBundles
.
length
;
i
+
+
)
{
videos
[
i
]
=
new
PermissionDelegate
.
MediaSource
(
videoBundles
[
i
]
)
;
}
}
if
(
audioBundles
!
=
null
)
{
audios
=
new
PermissionDelegate
.
MediaSource
[
audioBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
audioBundles
.
length
;
i
+
+
)
{
audios
[
i
]
=
new
PermissionDelegate
.
MediaSource
(
audioBundles
[
i
]
)
;
}
}
delegate
.
onMediaPermissionRequest
(
GeckoSession
.
this
message
.
getString
(
"
uri
"
)
videos
audios
new
PermissionCallback
(
"
media
"
callback
)
)
;
}
}
}
;
private
final
GeckoSessionHandler
<
SelectionActionDelegate
>
mSelectionActionDelegate
=
new
GeckoSessionHandler
<
SelectionActionDelegate
>
(
"
GeckoViewSelectionAction
"
this
new
String
[
]
{
"
GeckoView
:
HideSelectionAction
"
"
GeckoView
:
ShowSelectionAction
"
}
)
{
Override
public
void
handleMessage
(
final
SelectionActionDelegate
delegate
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
GeckoView
:
ShowSelectionAction
"
.
equals
(
event
)
)
{
final
SelectionActionDelegate
.
Selection
selection
=
new
SelectionActionDelegate
.
Selection
(
message
)
;
final
String
[
]
actions
=
message
.
getStringArray
(
"
actions
"
)
;
final
int
seqNo
=
message
.
getInt
(
"
seqNo
"
)
;
final
GeckoResponse
<
String
>
response
=
new
GeckoResponse
<
String
>
(
)
{
Override
public
void
respond
(
final
String
action
)
{
final
GeckoBundle
response
=
new
GeckoBundle
(
2
)
;
response
.
putString
(
"
id
"
action
)
;
response
.
putInt
(
"
seqNo
"
seqNo
)
;
callback
.
sendSuccess
(
response
)
;
}
}
;
delegate
.
onShowActionRequest
(
GeckoSession
.
this
selection
actions
response
)
;
}
else
if
(
"
GeckoView
:
HideSelectionAction
"
.
equals
(
event
)
)
{
final
String
reasonString
=
message
.
getString
(
"
reason
"
)
;
final
int
reason
;
if
(
"
invisibleselection
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_INVISIBLE_SELECTION
;
}
else
if
(
"
presscaret
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_ACTIVE_SELECTION
;
}
else
if
(
"
scroll
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_ACTIVE_SCROLL
;
}
else
if
(
"
visibilitychange
"
.
equals
(
reasonString
)
)
{
reason
=
SelectionActionDelegate
.
HIDE_REASON_NO_SELECTION
;
}
else
{
throw
new
IllegalArgumentException
(
)
;
}
delegate
.
onHideAction
(
GeckoSession
.
this
reason
)
;
}
}
}
;
int
handlersCount
;
private
final
GeckoSessionHandler
<
?
>
[
]
mSessionHandlers
=
new
GeckoSessionHandler
<
?
>
[
]
{
mContentHandler
mNavigationHandler
mProgressHandler
mScrollHandler
mTrackingProtectionHandler
mPermissionHandler
mSelectionActionDelegate
}
;
private
static
class
PermissionCallback
implements
PermissionDelegate
.
Callback
PermissionDelegate
.
MediaCallback
{
private
final
String
mType
;
private
EventCallback
mCallback
;
public
PermissionCallback
(
final
String
type
final
EventCallback
callback
)
{
mType
=
type
;
mCallback
=
callback
;
}
private
void
submit
(
final
Object
response
)
{
if
(
mCallback
!
=
null
)
{
mCallback
.
sendSuccess
(
response
)
;
mCallback
=
null
;
}
}
Override
public
void
grant
(
)
{
if
(
"
media
"
.
equals
(
mType
)
)
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
true
)
;
}
Override
public
void
reject
(
)
{
submit
(
false
)
;
}
Override
public
void
grant
(
final
String
video
final
String
audio
)
{
if
(
!
"
media
"
.
equals
(
mType
)
)
{
throw
new
UnsupportedOperationException
(
)
;
}
final
GeckoBundle
response
=
new
GeckoBundle
(
2
)
;
response
.
putString
(
"
video
"
video
)
;
response
.
putString
(
"
audio
"
audio
)
;
submit
(
response
)
;
}
Override
public
void
grant
(
final
PermissionDelegate
.
MediaSource
video
final
PermissionDelegate
.
MediaSource
audio
)
{
grant
(
video
!
=
null
?
video
.
id
:
null
audio
!
=
null
?
audio
.
id
:
null
)
;
}
}
public
PermissionDelegate
getPermissionDelegate
(
)
{
return
mPermissionHandler
.
getDelegate
(
)
;
}
public
void
setPermissionDelegate
(
final
PermissionDelegate
delegate
)
{
mPermissionHandler
.
setDelegate
(
delegate
this
)
;
}
private
PromptDelegate
mPromptDelegate
;
private
final
Listener
mListener
=
new
Listener
(
)
;
static
final
class
Window
extends
JNIObject
implements
IInterface
{
public
final
GeckoRuntime
runtime
;
private
NativeQueue
mNativeQueue
;
private
Binder
mBinder
;
public
Window
(
final
NonNull
GeckoRuntime
runtime
final
NonNull
NativeQueue
nativeQueue
)
{
this
.
runtime
=
runtime
;
mNativeQueue
=
nativeQueue
;
}
Override
public
Binder
asBinder
(
)
{
if
(
mBinder
=
=
null
)
{
mBinder
=
new
Binder
(
)
;
mBinder
.
attachInterface
(
this
Window
.
class
.
getName
(
)
)
;
}
return
mBinder
;
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
static
native
void
open
(
Window
instance
NativeQueue
queue
Compositor
compositor
EventDispatcher
dispatcher
GeckoBundle
initData
String
id
String
chromeUri
int
screenId
boolean
privateMode
)
;
Override
public
void
disposeNative
(
)
{
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
nativeDisposeNative
(
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
this
"
nativeDisposeNative
"
)
;
}
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
stubName
=
"
DisposeNative
"
)
private
native
void
nativeDisposeNative
(
)
;
public
void
close
(
)
{
synchronized
(
this
)
{
if
(
mNativeQueue
=
=
null
)
{
return
;
}
mNativeQueue
.
reset
(
State
.
INITIAL
)
;
mNativeQueue
=
null
;
}
asBinder
(
)
.
attachInterface
(
null
Window
.
class
.
getName
(
)
)
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
nativeClose
(
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
this
"
nativeClose
"
)
;
}
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
stubName
=
"
Close
"
)
private
native
void
nativeClose
(
)
;
public
synchronized
void
transfer
(
final
NativeQueue
queue
final
Compositor
compositor
final
EventDispatcher
dispatcher
final
GeckoBundle
initData
)
{
if
(
mNativeQueue
=
=
null
)
{
return
;
}
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
nativeTransfer
(
queue
compositor
dispatcher
initData
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
this
"
nativeTransfer
"
NativeQueue
.
class
queue
Compositor
.
class
compositor
EventDispatcher
.
class
dispatcher
GeckoBundle
.
class
initData
)
;
}
if
(
mNativeQueue
!
=
queue
)
{
mNativeQueue
.
reset
(
State
.
INITIAL
)
;
mNativeQueue
=
queue
;
}
}
WrapForJNI
(
dispatchTo
=
"
proxy
"
stubName
=
"
Transfer
"
)
private
native
void
nativeTransfer
(
NativeQueue
queue
Compositor
compositor
EventDispatcher
dispatcher
GeckoBundle
initData
)
;
WrapForJNI
(
dispatchTo
=
"
proxy
"
)
public
native
void
attachEditable
(
IGeckoEditableParent
parent
GeckoEditableChild
child
)
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
synchronized
void
onReady
(
final
Nullable
NativeQueue
queue
)
{
if
(
(
queue
=
=
null
&
&
mNativeQueue
=
=
null
)
|
|
(
queue
!
=
null
&
&
mNativeQueue
!
=
queue
)
)
{
return
;
}
if
(
mNativeQueue
.
checkAndSetState
(
State
.
INITIAL
State
.
READY
)
&
&
queue
=
=
null
)
{
Log
.
i
(
LOGTAG
"
zerdatime
"
+
SystemClock
.
elapsedRealtime
(
)
+
"
-
chrome
startup
finished
"
)
;
}
}
}
private
class
Listener
implements
BundleEventListener
{
void
registerListeners
(
)
{
getEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
GeckoView
:
Prompt
"
null
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
handleMessage
:
event
=
"
+
event
)
;
}
if
(
"
GeckoView
:
Prompt
"
.
equals
(
event
)
)
{
handlePromptEvent
(
GeckoSession
.
this
message
callback
)
;
}
}
}
protected
Window
mWindow
;
private
GeckoSessionSettings
mSettings
;
public
GeckoSession
(
)
{
this
(
null
)
;
}
public
GeckoSession
(
final
Nullable
GeckoSessionSettings
settings
)
{
mSettings
=
new
GeckoSessionSettings
(
settings
this
)
;
mListener
.
registerListeners
(
)
;
if
(
BuildConfig
.
DEBUG
&
&
handlersCount
!
=
mSessionHandlers
.
length
)
{
throw
new
AssertionError
(
"
Add
new
handler
to
handlers
list
"
)
;
}
}
Nullable
GeckoRuntime
getRuntime
(
)
{
if
(
mWindow
=
=
null
)
{
return
null
;
}
return
mWindow
.
runtime
;
}
private
void
transferFrom
(
final
Window
window
final
GeckoSessionSettings
settings
final
String
id
)
{
if
(
isOpen
(
)
)
{
throw
new
IllegalStateException
(
"
Session
is
open
"
)
;
}
if
(
window
!
=
null
)
{
onWindowChanged
(
WINDOW_TRANSFER_IN
true
)
;
}
mWindow
=
window
;
mSettings
=
new
GeckoSessionSettings
(
settings
this
)
;
mId
=
id
;
if
(
mWindow
!
=
null
)
{
mWindow
.
transfer
(
mNativeQueue
mCompositor
mEventDispatcher
createInitData
(
)
)
;
onWindowChanged
(
WINDOW_TRANSFER_IN
false
)
;
}
}
void
transferFrom
(
final
GeckoSession
session
)
{
final
boolean
changing
=
(
session
.
mWindow
!
=
null
)
;
if
(
changing
)
{
session
.
onWindowChanged
(
WINDOW_TRANSFER_OUT
true
)
;
}
transferFrom
(
session
.
mWindow
session
.
mSettings
session
.
mId
)
;
session
.
mWindow
=
null
;
if
(
changing
)
{
session
.
onWindowChanged
(
WINDOW_TRANSFER_OUT
false
)
;
}
}
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
Parcel
out
int
flags
)
{
out
.
writeStrongInterface
(
mWindow
)
;
out
.
writeParcelable
(
mSettings
flags
)
;
out
.
writeString
(
mId
)
;
}
public
void
readFromParcel
(
final
Parcel
source
)
{
final
IBinder
binder
=
source
.
readStrongBinder
(
)
;
final
IInterface
ifce
=
(
binder
!
=
null
)
?
binder
.
queryLocalInterface
(
Window
.
class
.
getName
(
)
)
:
null
;
final
Window
window
=
(
ifce
instanceof
Window
)
?
(
Window
)
ifce
:
null
;
final
GeckoSessionSettings
settings
=
source
.
readParcelable
(
getClass
(
)
.
getClassLoader
(
)
)
;
final
String
id
=
source
.
readString
(
)
;
transferFrom
(
window
settings
id
)
;
}
public
static
final
Creator
<
GeckoSession
>
CREATOR
=
new
Creator
<
GeckoSession
>
(
)
{
Override
public
GeckoSession
createFromParcel
(
final
Parcel
in
)
{
final
GeckoSession
session
=
new
GeckoSession
(
)
;
session
.
readFromParcel
(
in
)
;
return
session
;
}
Override
public
GeckoSession
[
]
newArray
(
final
int
size
)
{
return
new
GeckoSession
[
size
]
;
}
}
;
Override
public
int
hashCode
(
)
{
return
mId
.
hashCode
(
)
;
}
Override
public
boolean
equals
(
Object
obj
)
{
return
obj
instanceof
GeckoSession
&
&
mId
.
equals
(
(
(
GeckoSession
)
obj
)
.
mId
)
;
}
public
boolean
isOpen
(
)
{
return
mWindow
!
=
null
;
}
boolean
isReady
(
)
{
return
mNativeQueue
.
isReady
(
)
;
}
private
GeckoBundle
createInitData
(
)
{
final
GeckoBundle
initData
=
new
GeckoBundle
(
2
)
;
initData
.
putBundle
(
"
settings
"
mSettings
.
toBundle
(
)
)
;
final
GeckoBundle
modules
=
new
GeckoBundle
(
mSessionHandlers
.
length
)
;
for
(
final
GeckoSessionHandler
<
?
>
handler
:
mSessionHandlers
)
{
modules
.
putBoolean
(
handler
.
getName
(
)
handler
.
isEnabled
(
)
)
;
}
initData
.
putBundle
(
"
modules
"
modules
)
;
return
initData
;
}
public
void
open
(
final
NonNull
GeckoRuntime
runtime
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isOpen
(
)
)
{
throw
new
IllegalStateException
(
"
Session
is
open
"
)
;
}
final
String
chromeUri
=
mSettings
.
getString
(
GeckoSessionSettings
.
CHROME_URI
)
;
final
int
screenId
=
mSettings
.
getInt
(
GeckoSessionSettings
.
SCREEN_ID
)
;
final
boolean
isPrivate
=
mSettings
.
getBoolean
(
GeckoSessionSettings
.
USE_PRIVATE_MODE
)
;
mWindow
=
new
Window
(
runtime
mNativeQueue
)
;
onWindowChanged
(
WINDOW_OPEN
true
)
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
Window
.
open
(
mWindow
mNativeQueue
mCompositor
mEventDispatcher
createInitData
(
)
mId
chromeUri
screenId
isPrivate
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
Window
.
class
"
open
"
Window
.
class
mWindow
NativeQueue
.
class
mNativeQueue
Compositor
.
class
mCompositor
EventDispatcher
.
class
mEventDispatcher
GeckoBundle
.
class
createInitData
(
)
String
.
class
mId
String
.
class
chromeUri
screenId
isPrivate
)
;
}
onWindowChanged
(
WINDOW_OPEN
false
)
;
}
public
void
close
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
isOpen
(
)
)
{
Log
.
w
(
LOGTAG
"
Attempted
to
close
a
GeckoSession
that
was
already
closed
.
"
)
;
return
;
}
onWindowChanged
(
WINDOW_CLOSE
true
)
;
mWindow
.
close
(
)
;
mWindow
.
disposeNative
(
)
;
mWindow
=
null
;
onWindowChanged
(
WINDOW_CLOSE
false
)
;
}
private
void
onWindowChanged
(
int
change
boolean
inProgress
)
{
if
(
(
change
=
=
WINDOW_OPEN
|
|
change
=
=
WINDOW_TRANSFER_IN
)
&
&
!
inProgress
)
{
mTextInput
.
onWindowChanged
(
mWindow
)
;
}
if
(
(
change
=
=
WINDOW_CLOSE
|
|
change
=
=
WINDOW_TRANSFER_OUT
)
&
&
!
inProgress
)
{
if
(
mAccessibility
!
=
null
)
{
mAccessibility
.
clearAutoFill
(
)
;
}
mTextInput
.
clearAutoFill
(
)
;
}
}
public
NonNull
SessionTextInput
getTextInput
(
)
{
return
mTextInput
;
}
public
NonNull
SessionAccessibility
getAccessibility
(
)
{
if
(
mAccessibility
=
=
null
)
{
mAccessibility
=
new
SessionAccessibility
(
this
)
;
}
return
mAccessibility
;
}
IntDef
(
flag
=
true
value
=
{
LOAD_FLAGS_NONE
LOAD_FLAGS_BYPASS_CACHE
LOAD_FLAGS_BYPASS_PROXY
LOAD_FLAGS_EXTERNAL
LOAD_FLAGS_ALLOW_POPUPS
}
)
interface
LoadFlags
{
}
public
static
final
int
LOAD_FLAGS_NONE
=
0
;
public
static
final
int
LOAD_FLAGS_BYPASS_CACHE
=
1
<
<
0
;
public
static
final
int
LOAD_FLAGS_BYPASS_PROXY
=
1
<
<
1
;
public
static
final
int
LOAD_FLAGS_EXTERNAL
=
1
<
<
2
;
public
static
final
int
LOAD_FLAGS_ALLOW_POPUPS
=
1
<
<
3
;
public
void
loadUri
(
NonNull
String
uri
)
{
loadUri
(
uri
null
LOAD_FLAGS_NONE
)
;
}
public
void
loadUri
(
NonNull
String
uri
LoadFlags
int
flags
)
{
loadUri
(
uri
null
flags
)
;
}
public
void
loadUri
(
NonNull
String
uri
Nullable
String
referrer
LoadFlags
int
flags
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
)
;
msg
.
putString
(
"
uri
"
uri
)
;
msg
.
putInt
(
"
flags
"
flags
)
;
if
(
referrer
!
=
null
)
{
msg
.
putString
(
"
referrer
"
referrer
)
;
}
mEventDispatcher
.
dispatch
(
"
GeckoView
:
LoadUri
"
msg
)
;
}
public
void
loadUri
(
NonNull
Uri
uri
)
{
loadUri
(
uri
null
LOAD_FLAGS_NONE
)
;
}
public
void
loadUri
(
NonNull
Uri
uri
LoadFlags
int
flags
)
{
loadUri
(
uri
.
toString
(
)
null
flags
)
;
}
public
void
loadUri
(
NonNull
Uri
uri
Nullable
Uri
referrer
LoadFlags
int
flags
)
{
loadUri
(
uri
.
toString
(
)
referrer
!
=
null
?
referrer
.
toString
(
)
:
null
flags
)
;
}
public
void
loadString
(
NonNull
final
String
data
Nullable
final
String
mimeType
)
{
if
(
data
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
data
cannot
be
null
"
)
;
}
loadUri
(
createDataUri
(
data
mimeType
)
null
LOAD_FLAGS_NONE
)
;
}
public
void
loadData
(
NonNull
final
byte
[
]
bytes
Nullable
final
String
mimeType
)
{
if
(
bytes
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
data
cannot
be
null
"
)
;
}
loadUri
(
createDataUri
(
bytes
mimeType
)
null
LOAD_FLAGS_NONE
)
;
}
public
static
String
createDataUri
(
NonNull
final
byte
[
]
bytes
Nullable
final
String
mimeType
)
{
return
String
.
format
(
"
data
:
%
s
;
base64
%
s
"
mimeType
!
=
null
?
mimeType
:
"
"
Base64
.
encodeToString
(
bytes
Base64
.
NO_WRAP
)
)
;
}
public
static
String
createDataUri
(
NonNull
final
String
data
Nullable
final
String
mimeType
)
{
return
String
.
format
(
"
data
:
%
s
%
s
"
mimeType
!
=
null
?
mimeType
:
"
"
data
)
;
}
public
void
reload
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
Reload
"
null
)
;
}
public
void
stop
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
Stop
"
null
)
;
}
public
void
goBack
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GoBack
"
null
)
;
}
public
void
goForward
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoView
:
GoForward
"
null
)
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FINDER_FIND_BACKWARDS
FINDER_FIND_LINKS_ONLY
FINDER_FIND_MATCH_CASE
FINDER_FIND_WHOLE_WORD
}
)
interface
FinderFindFlags
{
}
public
static
final
int
FINDER_FIND_BACKWARDS
=
1
;
public
static
final
int
FINDER_FIND_MATCH_CASE
=
1
<
<
1
;
public
static
final
int
FINDER_FIND_WHOLE_WORD
=
1
<
<
2
;
public
static
final
int
FINDER_FIND_LINKS_ONLY
=
1
<
<
3
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FINDER_DISPLAY_HIGHLIGHT_ALL
FINDER_DISPLAY_DIM_PAGE
FINDER_DISPLAY_DRAW_LINK_OUTLINE
}
)
interface
FinderDisplayFlags
{
}
public
static
final
int
FINDER_DISPLAY_HIGHLIGHT_ALL
=
1
;
public
static
final
int
FINDER_DISPLAY_DIM_PAGE
=
1
<
<
1
;
public
static
final
int
FINDER_DISPLAY_DRAW_LINK_OUTLINE
=
1
<
<
2
;
public
static
final
class
FinderResult
{
public
final
boolean
found
;
public
final
boolean
wrapped
;
public
final
int
current
;
public
final
int
total
;
NonNull
public
final
String
searchString
;
FinderFindFlags
public
final
int
flags
;
Nullable
public
final
String
linkUri
;
Nullable
public
final
RectF
clientRect
;
FinderResult
(
NonNull
final
GeckoBundle
bundle
)
{
found
=
bundle
.
getBoolean
(
"
found
"
)
;
wrapped
=
bundle
.
getBoolean
(
"
wrapped
"
)
;
current
=
bundle
.
getInt
(
"
current
"
0
)
;
total
=
bundle
.
getInt
(
"
total
"
-
1
)
;
searchString
=
bundle
.
getString
(
"
searchString
"
)
;
flags
=
SessionFinder
.
getFlagsFromBundle
(
bundle
.
getBundle
(
"
flags
"
)
)
;
linkUri
=
bundle
.
getString
(
"
linkURL
"
)
;
final
GeckoBundle
rectBundle
=
bundle
.
getBundle
(
"
clientRect
"
)
;
if
(
rectBundle
=
=
null
)
{
clientRect
=
null
;
}
else
{
clientRect
=
new
RectF
(
(
float
)
rectBundle
.
getDouble
(
"
left
"
)
(
float
)
rectBundle
.
getDouble
(
"
top
"
)
(
float
)
rectBundle
.
getDouble
(
"
right
"
)
(
float
)
rectBundle
.
getDouble
(
"
bottom
"
)
)
;
}
}
}
public
SessionFinder
getFinder
(
)
{
if
(
mFinder
=
=
null
)
{
mFinder
=
new
SessionFinder
(
getEventDispatcher
(
)
)
;
}
return
mFinder
;
}
public
void
setActive
(
boolean
active
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
1
)
;
msg
.
putBoolean
(
"
active
"
active
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
SetActive
"
msg
)
;
}
public
void
setFocused
(
boolean
focused
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
1
)
;
msg
.
putBoolean
(
"
focused
"
focused
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
SetFocused
"
msg
)
;
if
(
focused
&
&
mAccessibility
!
=
null
)
{
mAccessibility
.
onWindowFocus
(
)
;
}
}
public
static
class
SessionState
implements
Parcelable
{
private
String
mState
;
public
SessionState
(
final
String
state
)
{
mState
=
state
;
}
Override
public
String
toString
(
)
{
return
mState
;
}
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
final
Parcel
dest
final
int
flags
)
{
dest
.
writeString
(
mState
)
;
}
public
void
readFromParcel
(
final
Parcel
source
)
{
mState
=
source
.
readString
(
)
;
}
public
static
final
Parcelable
.
Creator
<
SessionState
>
CREATOR
=
new
Parcelable
.
Creator
<
SessionState
>
(
)
{
Override
public
SessionState
createFromParcel
(
final
Parcel
source
)
{
return
new
SessionState
(
source
.
readString
(
)
)
;
}
Override
public
SessionState
[
]
newArray
(
final
int
size
)
{
return
new
SessionState
[
size
]
;
}
}
;
}
public
NonNull
GeckoResult
<
SessionState
>
saveState
(
)
{
CallbackResult
<
SessionState
>
result
=
new
CallbackResult
<
SessionState
>
(
)
{
Override
public
void
sendSuccess
(
final
Object
value
)
{
complete
(
new
SessionState
(
(
String
)
value
)
)
;
}
}
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
SaveState
"
null
result
)
;
return
result
;
}
public
void
restoreState
(
final
SessionState
state
)
{
final
GeckoBundle
msg
=
new
GeckoBundle
(
1
)
;
msg
.
putString
(
"
state
"
state
.
toString
(
)
)
;
mEventDispatcher
.
dispatch
(
"
GeckoView
:
RestoreState
"
msg
)
;
}
private
GeckoDisplay
mDisplay
;
GeckoDisplay
getDisplay
(
)
{
return
mDisplay
;
}
public
NonNull
GeckoDisplay
acquireDisplay
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mDisplay
!
=
null
)
{
throw
new
IllegalStateException
(
"
Display
already
acquired
"
)
;
}
mDisplay
=
new
GeckoDisplay
(
this
)
;
return
mDisplay
;
}
public
void
releaseDisplay
(
final
NonNull
GeckoDisplay
display
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
display
!
=
mDisplay
)
{
throw
new
IllegalArgumentException
(
"
Display
not
attached
"
)
;
}
mDisplay
=
null
;
}
public
GeckoSessionSettings
getSettings
(
)
{
return
mSettings
;
}
public
void
exitFullScreen
(
)
{
mEventDispatcher
.
dispatch
(
"
GeckoViewContent
:
ExitFullScreen
"
null
)
;
}
public
void
setContentDelegate
(
ContentDelegate
delegate
)
{
mContentHandler
.
setDelegate
(
delegate
this
)
;
}
public
ContentDelegate
getContentDelegate
(
)
{
return
mContentHandler
.
getDelegate
(
)
;
}
public
void
setProgressDelegate
(
ProgressDelegate
delegate
)
{
mProgressHandler
.
setDelegate
(
delegate
this
)
;
}
public
ProgressDelegate
getProgressDelegate
(
)
{
return
mProgressHandler
.
getDelegate
(
)
;
}
public
void
setNavigationDelegate
(
NavigationDelegate
delegate
)
{
mNavigationHandler
.
setDelegate
(
delegate
this
)
;
}
public
NavigationDelegate
getNavigationDelegate
(
)
{
return
mNavigationHandler
.
getDelegate
(
)
;
}
public
void
setScrollDelegate
(
ScrollDelegate
delegate
)
{
mScrollHandler
.
setDelegate
(
delegate
this
)
;
}
public
ScrollDelegate
getScrollDelegate
(
)
{
return
mScrollHandler
.
getDelegate
(
)
;
}
public
void
setTrackingProtectionDelegate
(
TrackingProtectionDelegate
delegate
)
{
mTrackingProtectionHandler
.
setDelegate
(
delegate
this
)
;
}
public
TrackingProtectionDelegate
getTrackingProtectionDelegate
(
)
{
return
mTrackingProtectionHandler
.
getDelegate
(
)
;
}
public
void
setPromptDelegate
(
PromptDelegate
delegate
)
{
mPromptDelegate
=
delegate
;
}
public
PromptDelegate
getPromptDelegate
(
)
{
return
mPromptDelegate
;
}
public
void
setSelectionActionDelegate
(
Nullable
SelectionActionDelegate
delegate
)
{
if
(
getSelectionActionDelegate
(
)
!
=
null
)
{
getSelectionActionDelegate
(
)
.
onHideAction
(
this
GeckoSession
.
SelectionActionDelegate
.
HIDE_REASON_NO_SELECTION
)
;
}
mSelectionActionDelegate
.
setDelegate
(
delegate
this
)
;
}
public
Nullable
SelectionActionDelegate
getSelectionActionDelegate
(
)
{
return
mSelectionActionDelegate
.
getDelegate
(
)
;
}
private
static
class
PromptCallback
implements
PromptDelegate
.
AlertCallback
PromptDelegate
.
ButtonCallback
PromptDelegate
.
TextCallback
PromptDelegate
.
AuthCallback
PromptDelegate
.
ChoiceCallback
PromptDelegate
.
FileCallback
{
private
final
String
mType
;
private
final
String
mMode
;
private
final
boolean
mHasCheckbox
;
private
final
String
mCheckboxMessage
;
private
EventCallback
mCallback
;
private
boolean
mCheckboxValue
;
private
GeckoBundle
mResult
;
public
PromptCallback
(
final
String
type
final
String
mode
final
GeckoBundle
message
final
EventCallback
callback
)
{
mType
=
type
;
mMode
=
mode
;
mCallback
=
callback
;
mHasCheckbox
=
message
.
getBoolean
(
"
hasCheck
"
)
;
mCheckboxMessage
=
message
.
getString
(
"
checkMsg
"
)
;
mCheckboxValue
=
message
.
getBoolean
(
"
checkValue
"
)
;
}
private
GeckoBundle
ensureResult
(
)
{
if
(
mResult
=
=
null
)
{
mResult
=
new
GeckoBundle
(
2
)
;
}
return
mResult
;
}
private
void
submit
(
)
{
if
(
mHasCheckbox
)
{
ensureResult
(
)
.
putBoolean
(
"
checkValue
"
mCheckboxValue
)
;
}
if
(
mCallback
!
=
null
)
{
mCallback
.
sendSuccess
(
mResult
)
;
mCallback
=
null
;
}
}
Override
public
void
dismiss
(
)
{
mResult
=
null
;
submit
(
)
;
}
Override
public
boolean
hasCheckbox
(
)
{
return
mHasCheckbox
;
}
Override
public
String
getCheckboxMessage
(
)
{
return
mCheckboxMessage
;
}
Override
public
boolean
getCheckboxValue
(
)
{
return
mCheckboxValue
;
}
Override
public
void
setCheckboxValue
(
final
boolean
value
)
{
mCheckboxValue
=
value
;
}
Override
public
void
confirm
(
final
int
value
)
{
if
(
"
button
"
.
equals
(
mType
)
)
{
ensureResult
(
)
.
putInt
(
"
button
"
value
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
final
String
value
)
{
if
(
"
text
"
.
equals
(
mType
)
|
|
"
color
"
.
equals
(
mType
)
|
|
"
datetime
"
.
equals
(
mType
)
)
{
ensureResult
(
)
.
putString
(
mType
value
)
;
}
else
if
(
"
auth
"
.
equals
(
mType
)
)
{
if
(
!
"
password
"
.
equals
(
mMode
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
ensureResult
(
)
.
putString
(
"
password
"
value
)
;
}
else
if
(
"
choice
"
.
equals
(
mType
)
)
{
confirm
(
new
String
[
]
{
value
}
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
final
String
username
final
String
password
)
{
if
(
"
auth
"
.
equals
(
mType
)
)
{
if
(
!
"
auth
"
.
equals
(
mMode
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
ensureResult
(
)
.
putString
(
"
username
"
username
)
;
ensureResult
(
)
.
putString
(
"
password
"
password
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
final
String
[
]
values
)
{
if
(
(
"
menu
"
.
equals
(
mMode
)
|
|
"
single
"
.
equals
(
mMode
)
)
&
&
(
values
=
=
null
|
|
values
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
"
choice
"
.
equals
(
mType
)
)
{
ensureResult
(
)
.
putStringArray
(
"
choices
"
values
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
Override
public
void
confirm
(
PromptDelegate
.
Choice
item
)
{
if
(
"
choice
"
.
equals
(
mType
)
)
{
confirm
(
item
=
=
null
?
null
:
item
.
id
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
Override
public
void
confirm
(
PromptDelegate
.
Choice
[
]
items
)
{
if
(
(
"
menu
"
.
equals
(
mMode
)
|
|
"
single
"
.
equals
(
mMode
)
)
&
&
(
items
=
=
null
|
|
items
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
"
choice
"
.
equals
(
mType
)
)
{
if
(
items
=
=
null
)
{
confirm
(
(
String
[
]
)
null
)
;
return
;
}
final
String
[
]
ids
=
new
String
[
items
.
length
]
;
for
(
int
i
=
0
;
i
<
ids
.
length
;
i
+
+
)
{
ids
[
i
]
=
(
items
[
i
]
=
=
null
)
?
null
:
items
[
i
]
.
id
;
}
confirm
(
ids
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
Override
public
void
confirm
(
final
Context
context
final
Uri
uri
)
{
if
(
"
file
"
.
equals
(
mType
)
)
{
confirm
(
context
uri
=
=
null
?
null
:
new
Uri
[
]
{
uri
}
)
;
return
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
private
static
String
getFile
(
final
Context
context
final
Uri
uri
)
{
if
(
uri
=
=
null
)
{
return
null
;
}
if
(
"
file
"
.
equals
(
uri
.
getScheme
(
)
)
)
{
return
uri
.
getPath
(
)
;
}
final
ContentResolver
cr
=
context
.
getContentResolver
(
)
;
final
Cursor
cur
=
cr
.
query
(
uri
new
String
[
]
{
"
_data
"
}
null
null
null
)
;
if
(
cur
=
=
null
)
{
return
null
;
}
try
{
final
int
idx
=
cur
.
getColumnIndex
(
"
_data
"
)
;
if
(
idx
<
0
|
|
!
cur
.
moveToFirst
(
)
)
{
return
null
;
}
do
{
try
{
final
String
path
=
cur
.
getString
(
idx
)
;
if
(
path
!
=
null
&
&
!
path
.
isEmpty
(
)
)
{
return
path
;
}
}
catch
(
final
Exception
e
)
{
}
}
while
(
cur
.
moveToNext
(
)
)
;
}
finally
{
cur
.
close
(
)
;
}
return
null
;
}
Override
public
void
confirm
(
final
Context
context
final
Uri
[
]
uris
)
{
if
(
"
single
"
.
equals
(
mMode
)
&
&
(
uris
=
=
null
|
|
uris
.
length
!
=
1
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
if
(
"
file
"
.
equals
(
mType
)
)
{
final
String
[
]
paths
=
new
String
[
uris
!
=
null
?
uris
.
length
:
0
]
;
for
(
int
i
=
0
;
i
<
paths
.
length
;
i
+
+
)
{
paths
[
i
]
=
getFile
(
context
uris
[
i
]
)
;
if
(
paths
[
i
]
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Only
file
URI
is
supported
:
"
+
uris
[
i
]
)
;
}
}
ensureResult
(
)
.
putStringArray
(
"
files
"
paths
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
submit
(
)
;
}
}
static
void
handlePromptEvent
(
final
GeckoSession
session
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
PromptDelegate
delegate
=
session
.
getPromptDelegate
(
)
;
if
(
delegate
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
;
}
final
String
type
=
message
.
getString
(
"
type
"
)
;
final
String
mode
=
message
.
getString
(
"
mode
"
)
;
final
PromptCallback
cb
=
new
PromptCallback
(
type
mode
message
callback
)
;
final
String
title
=
message
.
getString
(
"
title
"
)
;
final
String
msg
=
message
.
getString
(
"
msg
"
)
;
switch
(
type
)
{
case
"
alert
"
:
{
delegate
.
onAlert
(
session
title
msg
cb
)
;
break
;
}
case
"
button
"
:
{
final
String
[
]
btnTitle
=
message
.
getStringArray
(
"
btnTitle
"
)
;
final
String
[
]
btnCustomTitle
=
message
.
getStringArray
(
"
btnCustomTitle
"
)
;
for
(
int
i
=
0
;
i
<
btnCustomTitle
.
length
;
i
+
+
)
{
final
int
resId
;
if
(
"
ok
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
ok
;
}
else
if
(
"
cancel
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
cancel
;
}
else
if
(
"
yes
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
yes
;
}
else
if
(
"
no
"
.
equals
(
btnTitle
[
i
]
)
)
{
resId
=
android
.
R
.
string
.
no
;
}
else
{
continue
;
}
btnCustomTitle
[
i
]
=
Resources
.
getSystem
(
)
.
getString
(
resId
)
;
}
delegate
.
onButtonPrompt
(
session
title
msg
btnCustomTitle
cb
)
;
break
;
}
case
"
text
"
:
{
delegate
.
onTextPrompt
(
session
title
msg
message
.
getString
(
"
value
"
)
cb
)
;
break
;
}
case
"
auth
"
:
{
delegate
.
onAuthPrompt
(
session
title
msg
new
PromptDelegate
.
AuthOptions
(
message
.
getBundle
(
"
options
"
)
)
cb
)
;
break
;
}
case
"
choice
"
:
{
final
int
intMode
;
if
(
"
menu
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
Choice
.
CHOICE_TYPE_MENU
;
}
else
if
(
"
single
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
Choice
.
CHOICE_TYPE_SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
Choice
.
CHOICE_TYPE_MULTIPLE
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
GeckoBundle
[
]
choiceBundles
=
message
.
getBundleArray
(
"
choices
"
)
;
PromptDelegate
.
Choice
choices
[
]
;
if
(
choiceBundles
=
=
null
|
|
choiceBundles
.
length
=
=
0
)
{
choices
=
null
;
}
else
{
choices
=
new
PromptDelegate
.
Choice
[
choiceBundles
.
length
]
;
for
(
int
i
=
0
;
i
<
choiceBundles
.
length
;
i
+
+
)
{
choices
[
i
]
=
new
PromptDelegate
.
Choice
(
choiceBundles
[
i
]
)
;
}
}
delegate
.
onChoicePrompt
(
session
title
msg
intMode
choices
cb
)
;
break
;
}
case
"
color
"
:
{
delegate
.
onColorPrompt
(
session
title
message
.
getString
(
"
value
"
)
cb
)
;
break
;
}
case
"
datetime
"
:
{
final
int
intMode
;
if
(
"
date
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_DATE
;
}
else
if
(
"
month
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_MONTH
;
}
else
if
(
"
week
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_WEEK
;
}
else
if
(
"
time
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_TIME
;
}
else
if
(
"
datetime
-
local
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
DATETIME_TYPE_DATETIME_LOCAL
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
delegate
.
onDateTimePrompt
(
session
title
intMode
message
.
getString
(
"
value
"
)
message
.
getString
(
"
min
"
)
message
.
getString
(
"
max
"
)
cb
)
;
break
;
}
case
"
file
"
:
{
final
int
intMode
;
if
(
"
single
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
FILE_TYPE_SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
mode
)
)
{
intMode
=
PromptDelegate
.
FILE_TYPE_MULTIPLE
;
}
else
{
callback
.
sendError
(
"
Invalid
mode
"
)
;
return
;
}
String
[
]
mimeTypes
=
message
.
getStringArray
(
"
mimeTypes
"
)
;
final
String
[
]
extensions
=
message
.
getStringArray
(
"
extension
"
)
;
if
(
extensions
!
=
null
)
{
final
ArrayList
<
String
>
combined
=
new
ArrayList
<
>
(
mimeTypes
.
length
+
extensions
.
length
)
;
combined
.
addAll
(
Arrays
.
asList
(
mimeTypes
)
)
;
for
(
final
String
extension
:
extensions
)
{
final
String
mimeType
=
URLConnection
.
guessContentTypeFromName
(
extension
)
;
if
(
mimeType
!
=
null
)
{
combined
.
add
(
mimeType
)
;
}
}
mimeTypes
=
combined
.
toArray
(
new
String
[
combined
.
size
(
)
]
)
;
}
delegate
.
onFilePrompt
(
session
title
intMode
mimeTypes
cb
)
;
break
;
}
default
:
{
callback
.
sendError
(
"
Invalid
type
"
)
;
break
;
}
}
}
public
EventDispatcher
getEventDispatcher
(
)
{
return
mEventDispatcher
;
}
public
interface
ProgressDelegate
{
public
class
SecurityInformation
{
IntDef
(
{
SECURITY_MODE_UNKNOWN
SECURITY_MODE_IDENTIFIED
SECURITY_MODE_VERIFIED
}
)
interface
SecurityMode
{
}
public
static
final
int
SECURITY_MODE_UNKNOWN
=
0
;
public
static
final
int
SECURITY_MODE_IDENTIFIED
=
1
;
public
static
final
int
SECURITY_MODE_VERIFIED
=
2
;
IntDef
(
{
CONTENT_UNKNOWN
CONTENT_BLOCKED
CONTENT_LOADED
}
)
interface
ContentType
{
}
public
static
final
int
CONTENT_UNKNOWN
=
0
;
public
static
final
int
CONTENT_BLOCKED
=
1
;
public
static
final
int
CONTENT_LOADED
=
2
;
public
final
boolean
isSecure
;
public
final
boolean
isException
;
public
final
String
origin
;
public
final
String
host
;
public
final
String
organization
;
public
final
String
subjectName
;
public
final
String
issuerCommonName
;
public
final
String
issuerOrganization
;
public
final
SecurityMode
int
securityMode
;
public
final
ContentType
int
mixedModePassive
;
public
final
ContentType
int
mixedModeActive
;
public
final
ContentType
int
trackingMode
;
SecurityInformation
(
GeckoBundle
identityData
)
{
final
GeckoBundle
mode
=
identityData
.
getBundle
(
"
mode
"
)
;
mixedModePassive
=
mode
.
getInt
(
"
mixed_display
"
)
;
mixedModeActive
=
mode
.
getInt
(
"
mixed_active
"
)
;
trackingMode
=
mode
.
getInt
(
"
tracking
"
)
;
securityMode
=
mode
.
getInt
(
"
identity
"
)
;
isSecure
=
identityData
.
getBoolean
(
"
secure
"
)
;
isException
=
identityData
.
getBoolean
(
"
securityException
"
)
;
origin
=
identityData
.
getString
(
"
origin
"
)
;
host
=
identityData
.
getString
(
"
host
"
)
;
organization
=
identityData
.
getString
(
"
organization
"
)
;
subjectName
=
identityData
.
getString
(
"
subjectName
"
)
;
issuerCommonName
=
identityData
.
getString
(
"
issuerCommonName
"
)
;
issuerOrganization
=
identityData
.
getString
(
"
issuerOrganization
"
)
;
}
}
void
onPageStart
(
GeckoSession
session
String
url
)
;
void
onPageStop
(
GeckoSession
session
boolean
success
)
;
void
onProgressChange
(
GeckoSession
session
int
progress
)
;
void
onSecurityChange
(
GeckoSession
session
SecurityInformation
securityInfo
)
;
}
private
static
int
getContentElementType
(
final
String
name
)
{
if
(
"
HTMLImageElement
"
.
equals
(
name
)
)
{
return
ContentDelegate
.
ELEMENT_TYPE_IMAGE
;
}
else
if
(
"
HTMLVideoElement
"
.
equals
(
name
)
)
{
return
ContentDelegate
.
ELEMENT_TYPE_VIDEO
;
}
else
if
(
"
HTMLAudioElement
"
.
equals
(
name
)
)
{
return
ContentDelegate
.
ELEMENT_TYPE_AUDIO
;
}
return
ContentDelegate
.
ELEMENT_TYPE_NONE
;
}
static
public
class
WebResponseInfo
{
NonNull
public
final
String
uri
;
Nullable
public
final
String
contentType
;
Nullable
public
final
long
contentLength
;
Nullable
public
final
String
filename
;
WebResponseInfo
(
GeckoBundle
message
)
{
uri
=
message
.
getString
(
"
uri
"
)
;
if
(
uri
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
URI
cannot
be
null
"
)
;
}
contentType
=
message
.
getString
(
"
contentType
"
)
;
contentLength
=
message
.
getLong
(
"
contentLength
"
)
;
filename
=
message
.
getString
(
"
filename
"
)
;
}
}
public
interface
ContentDelegate
{
IntDef
(
{
ELEMENT_TYPE_NONE
ELEMENT_TYPE_IMAGE
ELEMENT_TYPE_VIDEO
ELEMENT_TYPE_AUDIO
}
)
interface
ElementType
{
}
static
final
int
ELEMENT_TYPE_NONE
=
0
;
static
final
int
ELEMENT_TYPE_IMAGE
=
1
;
static
final
int
ELEMENT_TYPE_VIDEO
=
2
;
static
final
int
ELEMENT_TYPE_AUDIO
=
3
;
void
onTitleChange
(
GeckoSession
session
String
title
)
;
void
onFocusRequest
(
GeckoSession
session
)
;
void
onCloseRequest
(
GeckoSession
session
)
;
void
onFullScreen
(
GeckoSession
session
boolean
fullScreen
)
;
void
onContextMenu
(
GeckoSession
session
int
screenX
int
screenY
String
uri
ElementType
int
elementType
String
elementSrc
)
;
void
onExternalResponse
(
GeckoSession
session
WebResponseInfo
response
)
;
void
onCrash
(
GeckoSession
session
)
;
}
public
interface
SelectionActionDelegate
{
IntDef
(
flag
=
true
value
=
{
FLAG_IS_COLLAPSED
FLAG_IS_EDITABLE
}
)
interface
Flag
{
}
final
int
FLAG_IS_COLLAPSED
=
1
;
final
int
FLAG_IS_EDITABLE
=
2
;
final
int
FLAG_IS_PASSWORD
=
4
;
StringDef
(
{
ACTION_HIDE
ACTION_CUT
ACTION_COPY
ACTION_DELETE
ACTION_PASTE
ACTION_SELECT_ALL
ACTION_UNSELECT
ACTION_COLLAPSE_TO_START
ACTION_COLLAPSE_TO_END
}
)
interface
Action
{
}
final
String
ACTION_HIDE
=
"
org
.
mozilla
.
geckoview
.
HIDE
"
;
final
String
ACTION_CUT
=
"
org
.
mozilla
.
geckoview
.
CUT
"
;
final
String
ACTION_COPY
=
"
org
.
mozilla
.
geckoview
.
COPY
"
;
final
String
ACTION_DELETE
=
"
org
.
mozilla
.
geckoview
.
DELETE
"
;
final
String
ACTION_PASTE
=
"
org
.
mozilla
.
geckoview
.
PASTE
"
;
final
String
ACTION_SELECT_ALL
=
"
org
.
mozilla
.
geckoview
.
SELECT_ALL
"
;
final
String
ACTION_UNSELECT
=
"
org
.
mozilla
.
geckoview
.
UNSELECT
"
;
final
String
ACTION_COLLAPSE_TO_START
=
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_START
"
;
final
String
ACTION_COLLAPSE_TO_END
=
"
org
.
mozilla
.
geckoview
.
COLLAPSE_TO_END
"
;
class
Selection
{
public
final
Flag
int
flags
;
public
final
String
text
;
public
final
RectF
clientRect
;
Selection
(
final
GeckoBundle
bundle
)
{
flags
=
(
bundle
.
getBoolean
(
"
collapsed
"
)
?
SelectionActionDelegate
.
FLAG_IS_COLLAPSED
:
0
)
|
(
bundle
.
getBoolean
(
"
editable
"
)
?
SelectionActionDelegate
.
FLAG_IS_EDITABLE
:
0
)
|
(
bundle
.
getBoolean
(
"
password
"
)
?
SelectionActionDelegate
.
FLAG_IS_PASSWORD
:
0
)
;
text
=
bundle
.
getString
(
"
selection
"
)
;
final
GeckoBundle
rectBundle
=
bundle
.
getBundle
(
"
clientRect
"
)
;
if
(
rectBundle
=
=
null
)
{
clientRect
=
null
;
}
else
{
clientRect
=
new
RectF
(
(
float
)
rectBundle
.
getDouble
(
"
left
"
)
(
float
)
rectBundle
.
getDouble
(
"
top
"
)
(
float
)
rectBundle
.
getDouble
(
"
right
"
)
(
float
)
rectBundle
.
getDouble
(
"
bottom
"
)
)
;
}
}
}
void
onShowActionRequest
(
GeckoSession
session
Selection
selection
Action
String
[
]
actions
GeckoResponse
<
String
>
response
)
;
IntDef
(
{
HIDE_REASON_NO_SELECTION
HIDE_REASON_INVISIBLE_SELECTION
HIDE_REASON_ACTIVE_SELECTION
HIDE_REASON_ACTIVE_SCROLL
}
)
interface
HideReason
{
}
final
int
HIDE_REASON_NO_SELECTION
=
0
;
final
int
HIDE_REASON_INVISIBLE_SELECTION
=
1
;
final
int
HIDE_REASON_ACTIVE_SELECTION
=
2
;
final
int
HIDE_REASON_ACTIVE_SCROLL
=
3
;
void
onHideAction
(
GeckoSession
session
HideReason
int
reason
)
;
}
public
interface
NavigationDelegate
{
void
onLocationChange
(
GeckoSession
session
String
url
)
;
void
onCanGoBack
(
GeckoSession
session
boolean
canGoBack
)
;
void
onCanGoForward
(
GeckoSession
session
boolean
canGoForward
)
;
IntDef
(
{
TARGET_WINDOW_NONE
TARGET_WINDOW_CURRENT
TARGET_WINDOW_NEW
}
)
interface
TargetWindow
{
}
public
static
final
int
TARGET_WINDOW_NONE
=
0
;
public
static
final
int
TARGET_WINDOW_CURRENT
=
1
;
public
static
final
int
TARGET_WINDOW_NEW
=
2
;
IntDef
(
flag
=
true
value
=
{
LOAD_REQUEST_IS_USER_TRIGGERED
}
)
interface
LoadRequestFlags
{
}
public
static
final
int
LOAD_REQUEST_IS_USER_TRIGGERED
=
0x1000
;
Nullable
GeckoResult
<
Boolean
>
onLoadRequest
(
NonNull
GeckoSession
session
NonNull
String
uri
TargetWindow
int
target
LoadRequestFlags
int
flags
)
;
Nullable
GeckoResult
<
GeckoSession
>
onNewSession
(
NonNull
GeckoSession
session
NonNull
String
uri
)
;
IntDef
(
{
ERROR_CATEGORY_UNKNOWN
ERROR_CATEGORY_SECURITY
ERROR_CATEGORY_NETWORK
ERROR_CATEGORY_CONTENT
ERROR_CATEGORY_URI
ERROR_CATEGORY_PROXY
ERROR_CATEGORY_SAFEBROWSING
}
)
public
interface
LoadErrorCategory
{
}
IntDef
(
{
ERROR_UNKNOWN
ERROR_SECURITY_SSL
ERROR_SECURITY_BAD_CERT
ERROR_NET_RESET
ERROR_NET_INTERRUPT
ERROR_NET_TIMEOUT
ERROR_CONNECTION_REFUSED
ERROR_UNKNOWN_PROTOCOL
ERROR_UNKNOWN_HOST
ERROR_UNKNOWN_SOCKET_TYPE
ERROR_UNKNOWN_PROXY_HOST
ERROR_MALFORMED_URI
ERROR_REDIRECT_LOOP
ERROR_SAFEBROWSING_PHISHING_URI
ERROR_SAFEBROWSING_MALWARE_URI
ERROR_SAFEBROWSING_UNWANTED_URI
ERROR_SAFEBROWSING_HARMFUL_URI
ERROR_CONTENT_CRASHED
ERROR_OFFLINE
ERROR_PORT_BLOCKED
ERROR_PROXY_CONNECTION_REFUSED
ERROR_FILE_NOT_FOUND
ERROR_FILE_ACCESS_DENIED
ERROR_INVALID_CONTENT_ENCODING
ERROR_UNSAFE_CONTENT_TYPE
ERROR_CORRUPTED_CONTENT
}
)
public
interface
LoadError
{
}
public
static
final
int
ERROR_CATEGORY_UNKNOWN
=
0x1
;
public
static
final
int
ERROR_CATEGORY_SECURITY
=
0x2
;
public
static
final
int
ERROR_CATEGORY_NETWORK
=
0x3
;
public
static
final
int
ERROR_CATEGORY_CONTENT
=
0x4
;
public
static
final
int
ERROR_CATEGORY_URI
=
0x5
;
public
static
final
int
ERROR_CATEGORY_PROXY
=
0x6
;
public
static
final
int
ERROR_CATEGORY_SAFEBROWSING
=
0x7
;
public
static
final
int
ERROR_UNKNOWN
=
0x11
;
public
static
final
int
ERROR_SECURITY_SSL
=
0x22
;
public
static
final
int
ERROR_SECURITY_BAD_CERT
=
0x32
;
public
static
final
int
ERROR_NET_INTERRUPT
=
0x23
;
public
static
final
int
ERROR_NET_TIMEOUT
=
0x33
;
public
static
final
int
ERROR_CONNECTION_REFUSED
=
0x43
;
public
static
final
int
ERROR_UNKNOWN_SOCKET_TYPE
=
0x53
;
public
static
final
int
ERROR_REDIRECT_LOOP
=
0x63
;
public
static
final
int
ERROR_OFFLINE
=
0x73
;
public
static
final
int
ERROR_PORT_BLOCKED
=
0x83
;
public
static
final
int
ERROR_NET_RESET
=
0x93
;
public
static
final
int
ERROR_UNSAFE_CONTENT_TYPE
=
0x24
;
public
static
final
int
ERROR_CORRUPTED_CONTENT
=
0x34
;
public
static
final
int
ERROR_CONTENT_CRASHED
=
0x44
;
public
static
final
int
ERROR_INVALID_CONTENT_ENCODING
=
0x54
;
public
static
final
int
ERROR_UNKNOWN_HOST
=
0x25
;
public
static
final
int
ERROR_MALFORMED_URI
=
0x35
;
public
static
final
int
ERROR_UNKNOWN_PROTOCOL
=
0x45
;
public
static
final
int
ERROR_FILE_NOT_FOUND
=
0x55
;
public
static
final
int
ERROR_FILE_ACCESS_DENIED
=
0x65
;
public
static
final
int
ERROR_PROXY_CONNECTION_REFUSED
=
0x26
;
public
static
final
int
ERROR_UNKNOWN_PROXY_HOST
=
0x36
;
public
static
final
int
ERROR_SAFEBROWSING_MALWARE_URI
=
0x27
;
public
static
final
int
ERROR_SAFEBROWSING_UNWANTED_URI
=
0x37
;
public
static
final
int
ERROR_SAFEBROWSING_HARMFUL_URI
=
0x47
;
public
static
final
int
ERROR_SAFEBROWSING_PHISHING_URI
=
0x57
;
GeckoResult
<
String
>
onLoadError
(
GeckoSession
session
String
uri
LoadErrorCategory
int
category
LoadError
int
error
)
;
}
public
interface
PromptDelegate
{
interface
AlertCallback
{
void
dismiss
(
)
;
boolean
hasCheckbox
(
)
;
String
getCheckboxMessage
(
)
;
boolean
getCheckboxValue
(
)
;
void
setCheckboxValue
(
boolean
value
)
;
}
void
onAlert
(
GeckoSession
session
String
title
String
msg
AlertCallback
callback
)
;
interface
ButtonCallback
extends
AlertCallback
{
void
confirm
(
int
button
)
;
}
static
final
int
BUTTON_TYPE_POSITIVE
=
0
;
static
final
int
BUTTON_TYPE_NEUTRAL
=
1
;
static
final
int
BUTTON_TYPE_NEGATIVE
=
2
;
void
onButtonPrompt
(
GeckoSession
session
String
title
String
msg
String
[
]
btnMsg
ButtonCallback
callback
)
;
interface
TextCallback
extends
AlertCallback
{
void
confirm
(
String
text
)
;
}
void
onTextPrompt
(
GeckoSession
session
String
title
String
msg
String
value
TextCallback
callback
)
;
interface
AuthCallback
extends
AlertCallback
{
void
confirm
(
String
password
)
;
void
confirm
(
String
username
String
password
)
;
}
class
AuthOptions
{
IntDef
(
flag
=
true
value
=
{
AUTH_FLAG_HOST
AUTH_FLAG_PROXY
AUTH_FLAG_ONLY_PASSWORD
AUTH_FLAG_PREVIOUS_FAILED
AUTH_FLAG_CROSS_ORIGIN_SUB_RESOURCE
}
)
interface
AuthFlag
{
}
public
static
final
int
AUTH_FLAG_HOST
=
1
;
public
static
final
int
AUTH_FLAG_PROXY
=
2
;
public
static
final
int
AUTH_FLAG_ONLY_PASSWORD
=
8
;
public
static
final
int
AUTH_FLAG_PREVIOUS_FAILED
=
16
;
public
static
final
int
AUTH_FLAG_CROSS_ORIGIN_SUB_RESOURCE
=
32
;
IntDef
(
{
AUTH_LEVEL_NONE
AUTH_LEVEL_PW_ENCRYPTED
AUTH_LEVEL_SECURE
}
)
interface
AuthLevel
{
}
public
static
final
int
AUTH_LEVEL_NONE
=
0
;
public
static
final
int
AUTH_LEVEL_PW_ENCRYPTED
=
1
;
public
static
final
int
AUTH_LEVEL_SECURE
=
2
;
public
AuthFlag
int
flags
;
public
String
uri
;
public
AuthLevel
int
level
;
public
String
username
;
public
String
password
;
AuthOptions
(
GeckoBundle
options
)
{
flags
=
options
.
getInt
(
"
flags
"
)
;
uri
=
options
.
getString
(
"
uri
"
)
;
level
=
options
.
getInt
(
"
level
"
)
;
username
=
options
.
getString
(
"
username
"
)
;
password
=
options
.
getString
(
"
password
"
)
;
}
}
void
onAuthPrompt
(
GeckoSession
session
String
title
String
msg
AuthOptions
options
AuthCallback
callback
)
;
class
Choice
{
IntDef
(
{
CHOICE_TYPE_MENU
CHOICE_TYPE_SINGLE
CHOICE_TYPE_MULTIPLE
}
)
interface
ChoiceType
{
}
public
static
final
int
CHOICE_TYPE_MENU
=
1
;
public
static
final
int
CHOICE_TYPE_SINGLE
=
2
;
public
static
final
int
CHOICE_TYPE_MULTIPLE
=
3
;
public
final
boolean
disabled
;
public
final
String
icon
;
public
final
String
id
;
public
final
Choice
[
]
items
;
public
final
String
label
;
public
final
boolean
selected
;
public
final
boolean
separator
;
Choice
(
GeckoBundle
choice
)
{
disabled
=
choice
.
getBoolean
(
"
disabled
"
)
;
icon
=
choice
.
getString
(
"
icon
"
)
;
id
=
choice
.
getString
(
"
id
"
)
;
label
=
choice
.
getString
(
"
label
"
)
;
selected
=
choice
.
getBoolean
(
"
selected
"
)
;
separator
=
choice
.
getBoolean
(
"
separator
"
)
;
GeckoBundle
[
]
choices
=
choice
.
getBundleArray
(
"
items
"
)
;
if
(
choices
=
=
null
)
{
items
=
null
;
}
else
{
items
=
new
Choice
[
choices
.
length
]
;
for
(
int
i
=
0
;
i
<
choices
.
length
;
i
+
+
)
{
items
[
i
]
=
new
Choice
(
choices
[
i
]
)
;
}
}
}
}
interface
ChoiceCallback
extends
AlertCallback
{
void
confirm
(
String
id
)
;
void
confirm
(
String
[
]
ids
)
;
void
confirm
(
Choice
item
)
;
void
confirm
(
Choice
[
]
items
)
;
}
void
onChoicePrompt
(
GeckoSession
session
String
title
String
msg
Choice
.
ChoiceType
int
type
Choice
[
]
choices
ChoiceCallback
callback
)
;
void
onColorPrompt
(
GeckoSession
session
String
title
String
value
TextCallback
callback
)
;
IntDef
(
{
DATETIME_TYPE_DATE
DATETIME_TYPE_MONTH
DATETIME_TYPE_WEEK
DATETIME_TYPE_TIME
DATETIME_TYPE_DATETIME_LOCAL
}
)
interface
DatetimeType
{
}
static
final
int
DATETIME_TYPE_DATE
=
1
;
static
final
int
DATETIME_TYPE_MONTH
=
2
;
static
final
int
DATETIME_TYPE_WEEK
=
3
;
static
final
int
DATETIME_TYPE_TIME
=
4
;
static
final
int
DATETIME_TYPE_DATETIME_LOCAL
=
5
;
void
onDateTimePrompt
(
GeckoSession
session
String
title
DatetimeType
int
type
String
value
String
min
String
max
TextCallback
callback
)
;
interface
FileCallback
extends
AlertCallback
{
void
confirm
(
Context
context
Uri
uri
)
;
void
confirm
(
Context
context
Uri
[
]
uris
)
;
}
IntDef
(
{
FILE_TYPE_SINGLE
FILE_TYPE_MULTIPLE
}
)
interface
FileType
{
}
static
final
int
FILE_TYPE_SINGLE
=
1
;
static
final
int
FILE_TYPE_MULTIPLE
=
2
;
void
onFilePrompt
(
GeckoSession
session
String
title
FileType
int
type
String
[
]
mimeTypes
FileCallback
callback
)
;
}
public
interface
ScrollDelegate
{
public
void
onScrollChanged
(
GeckoSession
session
int
scrollX
int
scrollY
)
;
}
public
interface
TrackingProtectionDelegate
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
CATEGORY_NONE
CATEGORY_AD
CATEGORY_ANALYTIC
CATEGORY_SOCIAL
CATEGORY_CONTENT
CATEGORY_ALL
CATEGORY_TEST
}
)
interface
Category
{
}
static
final
int
CATEGORY_NONE
=
0
;
static
final
int
CATEGORY_AD
=
1
<
<
0
;
static
final
int
CATEGORY_ANALYTIC
=
1
<
<
1
;
static
final
int
CATEGORY_SOCIAL
=
1
<
<
2
;
static
final
int
CATEGORY_CONTENT
=
1
<
<
3
;
static
final
int
CATEGORY_TEST
=
1
<
<
4
;
static
final
int
CATEGORY_ALL
=
(
1
<
<
5
)
-
1
;
void
onTrackerBlocked
(
GeckoSession
session
String
uri
Category
int
categories
)
;
}
public
interface
PermissionDelegate
{
IntDef
(
{
PERMISSION_GEOLOCATION
PERMISSION_DESKTOP_NOTIFICATION
PERMISSION_AUTOPLAY_MEDIA
}
)
interface
Permission
{
}
public
static
final
int
PERMISSION_GEOLOCATION
=
0
;
public
static
final
int
PERMISSION_DESKTOP_NOTIFICATION
=
1
;
public
static
final
int
PERMISSION_AUTOPLAY_MEDIA
=
2
;
interface
Callback
{
void
grant
(
)
;
void
reject
(
)
;
}
void
onAndroidPermissionsRequest
(
GeckoSession
session
String
[
]
permissions
Callback
callback
)
;
void
onContentPermissionRequest
(
GeckoSession
session
String
uri
Permission
int
type
String
access
Callback
callback
)
;
class
MediaSource
{
IntDef
(
{
SOURCE_CAMERA
SOURCE_SCREEN
SOURCE_APPLICATION
SOURCE_WINDOW
SOURCE_BROWSER
SOURCE_MICROPHONE
SOURCE_AUDIOCAPTURE
SOURCE_OTHER
}
)
interface
Source
{
}
public
static
final
int
SOURCE_CAMERA
=
0
;
public
static
final
int
SOURCE_SCREEN
=
1
;
public
static
final
int
SOURCE_APPLICATION
=
2
;
public
static
final
int
SOURCE_WINDOW
=
3
;
public
static
final
int
SOURCE_BROWSER
=
4
;
public
static
final
int
SOURCE_MICROPHONE
=
5
;
public
static
final
int
SOURCE_AUDIOCAPTURE
=
6
;
public
static
final
int
SOURCE_OTHER
=
7
;
IntDef
(
{
TYPE_VIDEO
TYPE_AUDIO
}
)
interface
Type
{
}
public
static
final
int
TYPE_VIDEO
=
0
;
public
static
final
int
TYPE_AUDIO
=
1
;
public
final
String
id
;
public
final
String
rawId
;
public
final
String
name
;
public
final
Source
int
source
;
public
final
Type
int
type
;
private
static
Source
int
getSourceFromString
(
String
src
)
{
if
(
"
camera
"
.
equals
(
src
)
)
{
return
SOURCE_CAMERA
;
}
else
if
(
"
screen
"
.
equals
(
src
)
)
{
return
SOURCE_SCREEN
;
}
else
if
(
"
application
"
.
equals
(
src
)
)
{
return
SOURCE_APPLICATION
;
}
else
if
(
"
window
"
.
equals
(
src
)
)
{
return
SOURCE_WINDOW
;
}
else
if
(
"
browser
"
.
equals
(
src
)
)
{
return
SOURCE_BROWSER
;
}
else
if
(
"
microphone
"
.
equals
(
src
)
)
{
return
SOURCE_MICROPHONE
;
}
else
if
(
"
audioCapture
"
.
equals
(
src
)
)
{
return
SOURCE_AUDIOCAPTURE
;
}
else
if
(
"
other
"
.
equals
(
src
)
)
{
return
SOURCE_OTHER
;
}
else
{
throw
new
IllegalArgumentException
(
"
String
:
"
+
src
+
"
is
not
a
valid
media
source
string
"
)
;
}
}
private
static
Type
int
getTypeFromString
(
String
type
)
{
if
(
"
videoinput
"
.
equals
(
type
)
)
{
return
TYPE_VIDEO
;
}
else
if
(
"
audioinput
"
.
equals
(
type
)
)
{
return
TYPE_AUDIO
;
}
else
{
throw
new
IllegalArgumentException
(
"
String
:
"
+
type
+
"
is
not
a
valid
media
type
string
"
)
;
}
}
MediaSource
(
GeckoBundle
media
)
{
id
=
media
.
getString
(
"
id
"
)
;
rawId
=
media
.
getString
(
"
rawId
"
)
;
name
=
media
.
getString
(
"
name
"
)
;
source
=
getSourceFromString
(
media
.
getString
(
"
mediaSource
"
)
)
;
type
=
getTypeFromString
(
media
.
getString
(
"
type
"
)
)
;
}
}
interface
MediaCallback
{
void
grant
(
final
String
video
final
String
audio
)
;
void
grant
(
final
MediaSource
video
final
MediaSource
audio
)
;
void
reject
(
)
;
}
void
onMediaPermissionRequest
(
GeckoSession
session
String
uri
MediaSource
[
]
video
MediaSource
[
]
audio
MediaCallback
callback
)
;
}
public
interface
TextInputDelegate
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
RESTART_REASON_FOCUS
RESTART_REASON_BLUR
RESTART_REASON_CONTENT_CHANGE
}
)
interface
RestartReason
{
}
int
RESTART_REASON_FOCUS
=
0
;
int
RESTART_REASON_BLUR
=
1
;
int
RESTART_REASON_CONTENT_CHANGE
=
2
;
void
restartInput
(
NonNull
GeckoSession
session
RestartReason
int
reason
)
;
void
showSoftInput
(
NonNull
GeckoSession
session
)
;
void
hideSoftInput
(
NonNull
GeckoSession
session
)
;
void
updateSelection
(
NonNull
GeckoSession
session
int
selStart
int
selEnd
int
compositionStart
int
compositionEnd
)
;
void
updateExtractedText
(
NonNull
GeckoSession
session
NonNull
ExtractedTextRequest
request
NonNull
ExtractedText
text
)
;
void
updateCursorAnchorInfo
(
NonNull
GeckoSession
session
NonNull
CursorAnchorInfo
info
)
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
AUTO_FILL_NOTIFY_STARTED
AUTO_FILL_NOTIFY_COMMITTED
AUTO_FILL_NOTIFY_CANCELED
AUTO_FILL_NOTIFY_VIEW_ADDED
AUTO_FILL_NOTIFY_VIEW_REMOVED
AUTO_FILL_NOTIFY_VIEW_UPDATED
AUTO_FILL_NOTIFY_VIEW_ENTERED
AUTO_FILL_NOTIFY_VIEW_EXITED
}
)
interface
AutoFillNotification
{
}
int
AUTO_FILL_NOTIFY_STARTED
=
0
;
int
AUTO_FILL_NOTIFY_COMMITTED
=
1
;
int
AUTO_FILL_NOTIFY_CANCELED
=
2
;
int
AUTO_FILL_NOTIFY_VIEW_ADDED
=
3
;
int
AUTO_FILL_NOTIFY_VIEW_REMOVED
=
4
;
int
AUTO_FILL_NOTIFY_VIEW_UPDATED
=
5
;
int
AUTO_FILL_NOTIFY_VIEW_ENTERED
=
6
;
int
AUTO_FILL_NOTIFY_VIEW_EXITED
=
7
;
void
notifyAutoFill
(
NonNull
GeckoSession
session
AutoFillNotification
int
notification
int
virtualId
)
;
}
}
