package
org
.
mozilla
.
geckoview
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Context
;
import
android
.
content
.
ContextWrapper
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
graphics
.
Region
;
import
android
.
os
.
Build
;
import
android
.
os
.
Handler
;
import
android
.
print
.
PrintDocumentAdapter
;
import
android
.
print
.
PrintManager
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
android
.
util
.
TypedValue
;
import
android
.
view
.
DisplayCutout
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
Surface
;
import
android
.
view
.
SurfaceControl
;
import
android
.
view
.
SurfaceView
;
import
android
.
view
.
TextureView
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
ViewStructure
;
import
android
.
view
.
autofill
.
AutofillManager
;
import
android
.
view
.
autofill
.
AutofillValue
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
android
.
widget
.
FrameLayout
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
UiThread
;
import
androidx
.
core
.
view
.
ViewCompat
;
import
java
.
io
.
InputStream
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
lang
.
ref
.
WeakReference
;
import
java
.
util
.
Objects
;
import
org
.
mozilla
.
gecko
.
AndroidGamepadManager
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
InputMethods
;
import
org
.
mozilla
.
gecko
.
SurfaceViewWrapper
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
UiThread
public
class
GeckoView
extends
FrameLayout
{
private
static
final
String
LOGTAG
=
"
GeckoView
"
;
private
static
final
boolean
DEBUG
=
false
;
protected
final
NonNull
Display
mDisplay
=
new
Display
(
)
;
private
Integer
mLastCoverColor
;
protected
Nullable
GeckoSession
mSession
;
WeakReference
<
Autofill
.
Session
>
mAutofillSession
=
new
WeakReference
<
>
(
null
)
;
private
boolean
mIsSessionPoisoned
=
false
;
private
boolean
mStateSaved
;
private
Nullable
SurfaceViewWrapper
mSurfaceWrapper
;
private
boolean
mIsResettingFocus
;
private
boolean
mAutofillEnabled
=
true
;
private
GeckoSession
.
SelectionActionDelegate
mSelectionActionDelegate
;
private
Autofill
.
Delegate
mAutofillDelegate
;
private
Nullable
ActivityContextDelegate
mActivityDelegate
;
private
GeckoSession
.
PrintDelegate
mPrintDelegate
;
private
class
Display
implements
SurfaceViewWrapper
.
Listener
{
private
final
int
[
]
mOrigin
=
new
int
[
2
]
;
private
GeckoDisplay
mDisplay
;
private
boolean
mValid
;
private
int
mClippingHeight
;
private
int
mDynamicToolbarMaxHeight
;
public
void
acquire
(
final
GeckoDisplay
display
)
{
mDisplay
=
display
;
if
(
!
mValid
)
{
return
;
}
setVerticalClipping
(
mClippingHeight
)
;
onGlobalLayout
(
)
;
if
(
GeckoView
.
this
.
mSurfaceWrapper
!
=
null
)
{
final
SurfaceViewWrapper
wrapper
=
GeckoView
.
this
.
mSurfaceWrapper
;
mDisplay
.
surfaceChanged
(
new
GeckoDisplay
.
SurfaceInfo
.
Builder
(
wrapper
.
getSurface
(
)
)
.
surfaceControl
(
wrapper
.
getSurfaceControl
(
)
)
.
size
(
wrapper
.
getWidth
(
)
wrapper
.
getHeight
(
)
)
.
build
(
)
)
;
mDisplay
.
setDynamicToolbarMaxHeight
(
mDynamicToolbarMaxHeight
)
;
GeckoView
.
this
.
setActive
(
true
)
;
}
}
public
GeckoDisplay
release
(
)
{
if
(
mValid
)
{
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceDestroyed
(
)
;
}
GeckoView
.
this
.
setActive
(
false
)
;
}
final
GeckoDisplay
display
=
mDisplay
;
mDisplay
=
null
;
return
display
;
}
Override
public
void
onSurfaceChanged
(
final
Surface
surface
Nullable
final
SurfaceControl
surfaceControl
final
int
width
final
int
height
)
{
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceChanged
(
new
GeckoDisplay
.
SurfaceInfo
.
Builder
(
surface
)
.
surfaceControl
(
surfaceControl
)
.
size
(
width
height
)
.
build
(
)
)
;
mDisplay
.
setDynamicToolbarMaxHeight
(
mDynamicToolbarMaxHeight
)
;
if
(
!
mValid
)
{
GeckoView
.
this
.
setActive
(
true
)
;
}
}
mValid
=
true
;
}
Override
public
void
onSurfaceDestroyed
(
)
{
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceDestroyed
(
)
;
GeckoView
.
this
.
setActive
(
false
)
;
}
mValid
=
false
;
}
public
void
onGlobalLayout
(
)
{
if
(
mDisplay
=
=
null
)
{
return
;
}
if
(
GeckoView
.
this
.
mSurfaceWrapper
!
=
null
)
{
GeckoView
.
this
.
mSurfaceWrapper
.
getView
(
)
.
getLocationOnScreen
(
mOrigin
)
;
mDisplay
.
screenOriginChanged
(
mOrigin
[
0
]
mOrigin
[
1
]
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
28
)
{
final
DisplayCutout
cutout
=
GeckoView
.
this
.
mSurfaceWrapper
.
getView
(
)
.
getRootWindowInsets
(
)
.
getDisplayCutout
(
)
;
if
(
cutout
!
=
null
)
{
mDisplay
.
safeAreaInsetsChanged
(
cutout
.
getSafeInsetTop
(
)
cutout
.
getSafeInsetRight
(
)
cutout
.
getSafeInsetBottom
(
)
cutout
.
getSafeInsetLeft
(
)
)
;
}
}
}
}
public
boolean
shouldPinOnScreen
(
)
{
return
mDisplay
!
=
null
?
mDisplay
.
shouldPinOnScreen
(
)
:
false
;
}
public
void
setVerticalClipping
(
final
int
clippingHeight
)
{
mClippingHeight
=
clippingHeight
;
if
(
mDisplay
!
=
null
)
{
mDisplay
.
setVerticalClipping
(
clippingHeight
)
;
}
}
public
void
setDynamicToolbarMaxHeight
(
final
int
height
)
{
mDynamicToolbarMaxHeight
=
height
;
setVerticalClipping
(
0
)
;
if
(
mDisplay
!
=
null
)
{
mDisplay
.
setDynamicToolbarMaxHeight
(
height
)
;
}
}
UiThread
NonNull
GeckoResult
<
Bitmap
>
capturePixels
(
)
{
if
(
mDisplay
=
=
null
)
{
return
GeckoResult
.
fromException
(
new
IllegalStateException
(
"
Display
must
be
created
before
pixels
can
be
captured
"
)
)
;
}
return
mDisplay
.
capturePixels
(
)
;
}
}
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
GeckoView
(
final
Context
context
)
{
super
(
context
)
;
init
(
)
;
}
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
GeckoView
(
final
Context
context
final
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
init
(
)
;
}
private
static
Activity
getActivityFromContext
(
final
Context
outerContext
)
{
Context
context
=
outerContext
;
while
(
context
instanceof
ContextWrapper
)
{
if
(
context
instanceof
Activity
)
{
return
(
Activity
)
context
;
}
context
=
(
(
ContextWrapper
)
context
)
.
getBaseContext
(
)
;
}
return
null
;
}
private
void
init
(
)
{
setFocusable
(
true
)
;
setFocusableInTouchMode
(
true
)
;
setImportantForAccessibility
(
View
.
IMPORTANT_FOR_ACCESSIBILITY_YES
)
;
setDescendantFocusability
(
FOCUS_BLOCK_DESCENDANTS
)
;
setWillNotCacheDrawing
(
false
)
;
mSurfaceWrapper
=
new
SurfaceViewWrapper
(
getContext
(
)
)
;
mSurfaceWrapper
.
setBackgroundColor
(
Color
.
WHITE
)
;
addView
(
mSurfaceWrapper
.
getView
(
)
new
ViewGroup
.
LayoutParams
(
ViewGroup
.
LayoutParams
.
MATCH_PARENT
ViewGroup
.
LayoutParams
.
MATCH_PARENT
)
)
;
mSurfaceWrapper
.
setListener
(
mDisplay
)
;
final
Activity
activity
=
getActivityFromContext
(
getContext
(
)
)
;
if
(
activity
!
=
null
)
{
mSelectionActionDelegate
=
new
BasicSelectionActionDelegate
(
activity
)
;
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
mAutofillDelegate
=
new
AndroidAutofillDelegate
(
)
;
}
else
{
mAutofillDelegate
=
new
Autofill
.
Delegate
(
)
{
}
;
}
mPrintDelegate
=
new
GeckoViewPrintDelegate
(
)
;
}
public
void
coverUntilFirstPaint
(
final
int
color
)
{
mLastCoverColor
=
color
;
if
(
mSession
!
=
null
)
{
mSession
.
getCompositorController
(
)
.
setClearColor
(
color
)
;
}
coverUntilFirstPaintInternal
(
color
)
;
}
private
void
uncover
(
)
{
coverUntilFirstPaintInternal
(
Color
.
TRANSPARENT
)
;
}
private
void
coverUntilFirstPaintInternal
(
final
int
color
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSurfaceWrapper
!
=
null
)
{
mSurfaceWrapper
.
setBackgroundColor
(
color
)
;
}
}
public
static
final
int
BACKEND_SURFACE_VIEW
=
1
;
public
static
final
int
BACKEND_TEXTURE_VIEW
=
2
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
BACKEND_SURFACE_VIEW
BACKEND_TEXTURE_VIEW
}
)
public
interface
ViewBackend
{
}
public
void
setViewBackend
(
final
ViewBackend
int
backend
)
{
removeView
(
mSurfaceWrapper
.
getView
(
)
)
;
if
(
backend
=
=
BACKEND_SURFACE_VIEW
)
{
mSurfaceWrapper
.
useSurfaceView
(
getContext
(
)
)
;
}
else
if
(
backend
=
=
BACKEND_TEXTURE_VIEW
)
{
mSurfaceWrapper
.
useTextureView
(
getContext
(
)
)
;
}
addView
(
mSurfaceWrapper
.
getView
(
)
)
;
if
(
mSession
!
=
null
)
{
mSession
.
getMagnifier
(
)
.
setView
(
mSurfaceWrapper
.
getView
(
)
)
;
}
}
public
boolean
shouldPinOnScreen
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mDisplay
.
shouldPinOnScreen
(
)
;
}
public
void
setVerticalClipping
(
final
int
clippingHeight
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDisplay
.
setVerticalClipping
(
clippingHeight
)
;
}
public
void
setDynamicToolbarMaxHeight
(
final
int
height
)
{
mDisplay
.
setDynamicToolbarMaxHeight
(
height
)
;
}
void
setActive
(
final
boolean
active
)
{
if
(
mSession
!
=
null
)
{
mSession
.
setActive
(
active
)
;
}
}
static
final
int
DEFAULT_DARK_COLOR
=
0xFF2A2A2E
;
private
int
defaultColor
(
)
{
if
(
mLastCoverColor
!
=
null
)
{
return
mLastCoverColor
;
}
if
(
mSession
=
=
null
|
|
!
mSession
.
isOpen
(
)
)
{
return
Color
.
WHITE
;
}
return
mSession
.
getRuntime
(
)
.
usesDarkTheme
(
)
?
DEFAULT_DARK_COLOR
:
Color
.
WHITE
;
}
UiThread
public
Nullable
GeckoSession
releaseSession
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
=
=
null
)
{
return
null
;
}
final
GeckoSession
session
=
mSession
;
mSession
.
releaseDisplay
(
mDisplay
.
release
(
)
)
;
mSession
.
getOverscrollEdgeEffect
(
)
.
setInvalidationCallback
(
null
)
;
mSession
.
getOverscrollEdgeEffect
(
)
.
setSession
(
null
)
;
mSession
.
getCompositorController
(
)
.
setFirstPaintCallback
(
null
)
;
if
(
mSession
.
getAccessibility
(
)
.
getView
(
)
=
=
this
)
{
mSession
.
getAccessibility
(
)
.
setView
(
null
)
;
}
if
(
mSession
.
getTextInput
(
)
.
getView
(
)
=
=
this
)
{
mSession
.
getTextInput
(
)
.
setView
(
null
)
;
}
if
(
mSession
.
getSelectionActionDelegate
(
)
=
=
mSelectionActionDelegate
)
{
mSession
.
setSelectionActionDelegate
(
null
)
;
}
if
(
mSession
.
getAutofillDelegate
(
)
=
=
mAutofillDelegate
)
{
mSession
.
setAutofillDelegate
(
null
)
;
}
if
(
mSession
.
getPrintDelegate
(
)
=
=
mPrintDelegate
)
{
session
.
setPrintDelegate
(
null
)
;
}
if
(
mSession
.
getMagnifier
(
)
.
getView
(
)
=
=
mSurfaceWrapper
.
getView
(
)
)
{
session
.
getMagnifier
(
)
.
setView
(
null
)
;
}
if
(
isFocused
(
)
)
{
mSession
.
setFocused
(
false
)
;
}
mSession
=
null
;
mIsSessionPoisoned
=
false
;
session
.
releaseOwner
(
)
;
return
session
;
}
private
final
GeckoSession
.
Owner
mSessionOwner
=
new
GeckoSession
.
Owner
(
)
{
Override
public
void
onRelease
(
)
{
releaseSession
(
)
;
mIsSessionPoisoned
=
true
;
}
}
;
UiThread
public
void
setSession
(
NonNull
final
GeckoSession
session
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
session
=
=
mSession
)
{
return
;
}
releaseSession
(
)
;
session
.
setOwner
(
mSessionOwner
)
;
mSession
=
session
;
mIsSessionPoisoned
=
false
;
mSession
.
getCompositorController
(
)
.
setClearColor
(
defaultColor
(
)
)
;
if
(
ViewCompat
.
isAttachedToWindow
(
this
)
)
{
mDisplay
.
acquire
(
session
.
acquireDisplay
(
)
)
;
}
final
Context
context
=
getContext
(
)
;
session
.
getOverscrollEdgeEffect
(
)
.
setTheme
(
context
)
;
session
.
getOverscrollEdgeEffect
(
)
.
setSession
(
session
)
;
session
.
getOverscrollEdgeEffect
(
)
.
setInvalidationCallback
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
16
)
{
GeckoView
.
this
.
postInvalidateOnAnimation
(
)
;
}
else
{
GeckoView
.
this
.
postInvalidateDelayed
(
10
)
;
}
}
}
)
;
final
DisplayMetrics
metrics
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
;
final
TypedValue
outValue
=
new
TypedValue
(
)
;
if
(
context
.
getTheme
(
)
.
resolveAttribute
(
android
.
R
.
attr
.
listPreferredItemHeight
outValue
true
)
)
{
session
.
getPanZoomController
(
)
.
setScrollFactor
(
outValue
.
getDimension
(
metrics
)
)
;
}
else
{
session
.
getPanZoomController
(
)
.
setScrollFactor
(
0
.
075f
*
metrics
.
densityDpi
)
;
}
session
.
getCompositorController
(
)
.
setFirstPaintCallback
(
this
:
:
uncover
)
;
if
(
session
.
getTextInput
(
)
.
getView
(
)
=
=
null
)
{
session
.
getTextInput
(
)
.
setView
(
this
)
;
}
if
(
session
.
getAccessibility
(
)
.
getView
(
)
=
=
null
)
{
session
.
getAccessibility
(
)
.
setView
(
this
)
;
}
if
(
session
.
getSelectionActionDelegate
(
)
=
=
null
&
&
mSelectionActionDelegate
!
=
null
)
{
session
.
setSelectionActionDelegate
(
mSelectionActionDelegate
)
;
}
if
(
mAutofillEnabled
)
{
session
.
setAutofillDelegate
(
mAutofillDelegate
)
;
}
if
(
session
.
getMagnifier
(
)
.
getView
(
)
=
=
null
)
{
session
.
getMagnifier
(
)
.
setView
(
mSurfaceWrapper
.
getView
(
)
)
;
}
if
(
session
.
getPrintDelegate
(
)
=
=
null
&
&
mPrintDelegate
!
=
null
)
{
session
.
setPrintDelegate
(
mPrintDelegate
)
;
}
if
(
isFocused
(
)
)
{
session
.
setFocused
(
true
)
;
}
}
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
Nullable
GeckoSession
getSession
(
)
{
return
mSession
;
}
AnyThread
NonNull
EventDispatcher
getEventDispatcher
(
)
{
return
mSession
.
getEventDispatcher
(
)
;
}
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
NonNull
PanZoomController
getPanZoomController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mSession
.
getPanZoomController
(
)
;
}
Override
public
void
onAttachedToWindow
(
)
{
if
(
mIsSessionPoisoned
)
{
throw
new
IllegalStateException
(
"
Trying
to
display
a
view
with
invalid
session
.
"
)
;
}
if
(
mSession
!
=
null
)
{
final
GeckoRuntime
runtime
=
mSession
.
getRuntime
(
)
;
if
(
runtime
!
=
null
)
{
runtime
.
orientationChanged
(
)
;
}
}
if
(
mSession
!
=
null
)
{
mDisplay
.
acquire
(
mSession
.
acquireDisplay
(
)
)
;
}
super
.
onAttachedToWindow
(
)
;
}
Override
public
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
if
(
mSession
=
=
null
)
{
return
;
}
mSession
.
releaseDisplay
(
mDisplay
.
release
(
)
)
;
}
Override
protected
void
onConfigurationChanged
(
final
Configuration
newConfig
)
{
super
.
onConfigurationChanged
(
newConfig
)
;
if
(
mSession
!
=
null
)
{
final
GeckoRuntime
runtime
=
mSession
.
getRuntime
(
)
;
if
(
runtime
!
=
null
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
JELLY_BEAN_MR1
)
{
runtime
.
orientationChanged
(
newConfig
.
orientation
)
;
}
else
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
S
)
{
runtime
.
orientationChanged
(
)
;
}
runtime
.
configurationChanged
(
newConfig
)
;
}
}
}
Override
public
boolean
gatherTransparentRegion
(
final
Region
region
)
{
if
(
mSurfaceWrapper
!
=
null
)
{
mDisplay
.
onGlobalLayout
(
)
;
}
return
super
.
gatherTransparentRegion
(
region
)
;
}
Override
public
void
onWindowFocusChanged
(
final
boolean
hasWindowFocus
)
{
super
.
onWindowFocusChanged
(
hasWindowFocus
)
;
if
(
mSession
!
=
null
&
&
hasWindowFocus
&
&
isFocused
(
)
)
{
mSession
.
setFocused
(
true
)
;
}
}
Override
protected
void
onWindowVisibilityChanged
(
final
int
visibility
)
{
super
.
onWindowVisibilityChanged
(
visibility
)
;
if
(
mSession
!
=
null
&
&
visibility
!
=
View
.
VISIBLE
&
&
!
hasWindowFocus
(
)
)
{
mSession
.
setFocused
(
false
)
;
}
}
Override
protected
void
onFocusChanged
(
final
boolean
gainFocus
final
int
direction
final
Rect
previouslyFocusedRect
)
{
super
.
onFocusChanged
(
gainFocus
direction
previouslyFocusedRect
)
;
if
(
mIsResettingFocus
)
{
return
;
}
if
(
mSession
!
=
null
)
{
mSession
.
setFocused
(
gainFocus
)
;
}
if
(
!
gainFocus
)
{
return
;
}
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
!
isFocused
(
)
)
{
return
;
}
final
InputMethodManager
imm
=
InputMethods
.
getInputMethodManager
(
getContext
(
)
)
;
if
(
!
imm
.
isActive
(
GeckoView
.
this
)
)
{
mIsResettingFocus
=
true
;
clearFocus
(
)
;
requestFocus
(
)
;
mIsResettingFocus
=
false
;
}
}
}
)
;
}
Override
public
Handler
getHandler
(
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
24
|
|
mSession
=
=
null
)
{
return
super
.
getHandler
(
)
;
}
return
mSession
.
getTextInput
(
)
.
getHandler
(
super
.
getHandler
(
)
)
;
}
Override
public
InputConnection
onCreateInputConnection
(
final
EditorInfo
outAttrs
)
{
if
(
mSession
=
=
null
)
{
return
null
;
}
return
mSession
.
getTextInput
(
)
.
onCreateInputConnection
(
outAttrs
)
;
}
Override
public
boolean
onKeyPreIme
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyPreIme
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyPreIme
(
keyCode
event
)
;
}
Override
public
boolean
onKeyUp
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyUp
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyUp
(
keyCode
event
)
;
}
Override
public
boolean
onKeyDown
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyDown
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyDown
(
keyCode
event
)
;
}
Override
public
boolean
onKeyLongPress
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyLongPress
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyLongPress
(
keyCode
event
)
;
}
Override
public
boolean
onKeyMultiple
(
final
int
keyCode
final
int
repeatCount
final
KeyEvent
event
)
{
if
(
super
.
onKeyMultiple
(
keyCode
repeatCount
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyMultiple
(
keyCode
repeatCount
event
)
;
}
Override
public
void
dispatchDraw
(
final
Nullable
Canvas
canvas
)
{
super
.
dispatchDraw
(
canvas
)
;
if
(
mSession
!
=
null
)
{
mSession
.
getOverscrollEdgeEffect
(
)
.
draw
(
canvas
)
;
}
}
SuppressLint
(
"
ClickableViewAccessibility
"
)
Override
public
boolean
onTouchEvent
(
final
MotionEvent
event
)
{
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
)
{
requestFocus
(
)
;
}
if
(
mSession
=
=
null
)
{
return
false
;
}
mSession
.
getPanZoomController
(
)
.
onTouchEvent
(
event
)
;
return
true
;
}
public
NonNull
GeckoResult
<
PanZoomController
.
InputResultDetail
>
onTouchEventForDetailResult
(
final
NonNull
MotionEvent
event
)
{
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
)
{
requestFocus
(
)
;
}
if
(
mSession
=
=
null
)
{
return
GeckoResult
.
fromValue
(
new
PanZoomController
.
InputResultDetail
(
PanZoomController
.
INPUT_RESULT_UNHANDLED
PanZoomController
.
SCROLLABLE_FLAG_NONE
PanZoomController
.
OVERSCROLL_FLAG_NONE
)
)
;
}
return
mSession
.
getPanZoomController
(
)
.
onTouchEventForDetailResult
(
event
)
;
}
Override
public
boolean
onGenericMotionEvent
(
final
MotionEvent
event
)
{
if
(
AndroidGamepadManager
.
handleMotionEvent
(
event
)
)
{
return
true
;
}
if
(
mSession
=
=
null
)
{
return
true
;
}
if
(
mSession
.
getAccessibility
(
)
.
onMotionEvent
(
event
)
)
{
return
true
;
}
mSession
.
getPanZoomController
(
)
.
onMotionEvent
(
event
)
;
return
true
;
}
Override
public
void
onProvideAutofillVirtualStructure
(
final
ViewStructure
structure
final
int
flags
)
{
if
(
mSession
=
=
null
)
{
return
;
}
final
Autofill
.
Session
autofillSession
=
mSession
.
getAutofillSession
(
)
;
mAutofillSession
=
new
WeakReference
<
>
(
autofillSession
)
;
autofillSession
.
fillViewStructure
(
this
structure
flags
)
;
}
Override
TargetApi
(
26
)
public
void
autofill
(
NonNull
final
SparseArray
<
AutofillValue
>
values
)
{
final
Autofill
.
Session
session
=
mAutofillSession
.
get
(
)
;
if
(
session
=
=
null
)
{
return
;
}
final
SparseArray
<
CharSequence
>
strValues
=
new
SparseArray
<
>
(
values
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
values
.
size
(
)
;
i
+
+
)
{
final
AutofillValue
value
=
values
.
valueAt
(
i
)
;
if
(
value
.
isText
(
)
)
{
strValues
.
put
(
values
.
keyAt
(
i
)
value
.
getTextValue
(
)
)
;
}
}
session
.
autofill
(
strValues
)
;
}
Override
public
boolean
isVisibleToUserForAutofill
(
final
int
virtualId
)
{
return
true
;
}
UiThread
public
NonNull
GeckoResult
<
Bitmap
>
capturePixels
(
)
{
return
mDisplay
.
capturePixels
(
)
;
}
TargetApi
(
26
)
public
void
setAutofillEnabled
(
final
boolean
enabled
)
{
mAutofillEnabled
=
enabled
;
if
(
mSession
!
=
null
)
{
if
(
!
enabled
&
&
mSession
.
getAutofillDelegate
(
)
=
=
mAutofillDelegate
)
{
mSession
.
setAutofillDelegate
(
null
)
;
}
else
if
(
enabled
)
{
mSession
.
setAutofillDelegate
(
mAutofillDelegate
)
;
}
}
}
TargetApi
(
26
)
public
boolean
getAutofillEnabled
(
)
{
return
mAutofillEnabled
;
}
TargetApi
(
26
)
private
class
AndroidAutofillDelegate
implements
Autofill
.
Delegate
{
AutofillManager
mAutofillManager
;
boolean
mDisabled
=
false
;
private
void
ensureAutofillManager
(
)
{
if
(
mDisabled
|
|
mAutofillManager
!
=
null
)
{
return
;
}
mAutofillManager
=
GeckoView
.
this
.
getContext
(
)
.
getSystemService
(
AutofillManager
.
class
)
;
if
(
mAutofillManager
=
=
null
)
{
mDisabled
=
true
;
}
}
private
Rect
displayRectForId
(
NonNull
final
GeckoSession
session
Nullable
final
Autofill
.
Node
node
)
{
if
(
node
=
=
null
)
{
return
new
Rect
(
0
0
0
0
)
;
}
if
(
!
node
.
getScreenRect
(
)
.
isEmpty
(
)
)
{
return
node
.
getScreenRect
(
)
;
}
final
Matrix
matrix
=
new
Matrix
(
)
;
final
RectF
rectF
=
new
RectF
(
node
.
getDimensions
(
)
)
;
session
.
getPageToScreenMatrix
(
matrix
)
;
matrix
.
mapRect
(
rectF
)
;
final
Rect
screenRect
=
new
Rect
(
)
;
rectF
.
roundOut
(
screenRect
)
;
return
screenRect
;
}
Override
public
void
onNodeBlur
(
final
NonNull
GeckoSession
session
final
NonNull
Autofill
.
Node
prev
final
NonNull
Autofill
.
NodeData
data
)
{
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
notifyViewExited
(
GeckoView
.
this
data
.
getId
(
)
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
notifyViewExited
:
"
e
)
;
}
}
Override
public
void
onNodeAdd
(
final
NonNull
GeckoSession
session
final
NonNull
Autofill
.
Node
node
final
NonNull
Autofill
.
NodeData
data
)
{
if
(
!
mSession
.
getAutofillSession
(
)
.
isVisible
(
node
)
)
{
return
;
}
final
Autofill
.
Node
focused
=
mSession
.
getAutofillSession
(
)
.
getFocused
(
)
;
Objects
.
requireNonNull
(
focused
)
;
final
Autofill
.
NodeData
focusedData
=
mSession
.
getAutofillSession
(
)
.
dataFor
(
focused
)
;
Objects
.
requireNonNull
(
focusedData
)
;
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
notifyViewExited
(
GeckoView
.
this
focusedData
.
getId
(
)
)
;
mAutofillManager
.
notifyViewEntered
(
GeckoView
.
this
focusedData
.
getId
(
)
displayRectForId
(
session
focused
)
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
notifyViewExited
or
AutofillManager
.
notifyViewEntered
:
"
e
)
;
}
}
Override
public
void
onNodeFocus
(
final
NonNull
GeckoSession
session
final
NonNull
Autofill
.
Node
focused
final
NonNull
Autofill
.
NodeData
data
)
{
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
notifyViewEntered
(
GeckoView
.
this
data
.
getId
(
)
displayRectForId
(
session
focused
)
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
notifyViewEntered
:
"
e
)
;
}
}
Override
public
void
onNodeRemove
(
final
NonNull
GeckoSession
session
final
NonNull
Autofill
.
Node
node
final
NonNull
Autofill
.
NodeData
data
)
{
}
Override
public
void
onNodeUpdate
(
final
NonNull
GeckoSession
session
final
NonNull
Autofill
.
Node
node
final
NonNull
Autofill
.
NodeData
data
)
{
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
notifyValueChanged
(
GeckoView
.
this
data
.
getId
(
)
AutofillValue
.
forText
(
data
.
getValue
(
)
)
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
notifyValueChanged
:
"
e
)
;
}
}
Override
public
void
onSessionCancel
(
final
NonNull
GeckoSession
session
)
{
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
cancel
(
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
cancel
:
"
e
)
;
}
}
Override
public
void
onSessionCommit
(
final
NonNull
GeckoSession
session
final
NonNull
Autofill
.
Node
node
final
NonNull
Autofill
.
NodeData
data
)
{
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
commit
(
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
commit
:
"
e
)
;
}
}
Override
public
void
onSessionStart
(
final
NonNull
GeckoSession
session
)
{
ensureAutofillManager
(
)
;
if
(
mAutofillManager
=
=
null
)
{
return
;
}
try
{
mAutofillManager
.
cancel
(
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Failed
to
call
AutofillManager
.
cancel
:
"
e
)
;
}
}
}
AnyThread
public
interface
ActivityContextDelegate
{
Nullable
Context
getActivityContext
(
)
;
}
public
void
setActivityContextDelegate
(
final
Nullable
ActivityContextDelegate
delegate
)
{
mActivityDelegate
=
delegate
;
}
public
Nullable
ActivityContextDelegate
getActivityContextDelegate
(
)
{
return
mActivityDelegate
;
}
public
Nullable
GeckoSession
.
PrintDelegate
getPrintDelegate
(
)
{
return
mPrintDelegate
;
}
public
void
getPrintDelegate
(
Nullable
final
GeckoSession
.
PrintDelegate
delegate
)
{
mPrintDelegate
=
delegate
;
}
private
class
GeckoViewPrintDelegate
implements
GeckoSession
.
PrintDelegate
{
public
void
onPrint
(
NonNull
final
GeckoSession
session
)
{
final
GeckoResult
<
InputStream
>
geckoResult
=
session
.
saveAsPdf
(
)
;
geckoResult
.
accept
(
pdfStream
-
>
{
onPrint
(
pdfStream
)
;
}
exception
-
>
Log
.
e
(
LOGTAG
"
Could
not
create
a
content
PDF
to
print
.
"
exception
)
)
;
}
public
void
onPrint
(
NonNull
final
InputStream
pdfStream
)
{
if
(
mActivityDelegate
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Missing
an
activity
context
delegate
which
is
required
for
printing
.
"
)
;
return
;
}
final
Context
printContext
=
mActivityDelegate
.
getActivityContext
(
)
;
if
(
printContext
=
=
null
)
{
Log
.
w
(
LOGTAG
"
An
activity
context
is
required
for
printing
.
"
)
;
return
;
}
final
PrintManager
printManager
=
(
PrintManager
)
mActivityDelegate
.
getActivityContext
(
)
.
getSystemService
(
Context
.
PRINT_SERVICE
)
;
final
PrintDocumentAdapter
pda
=
new
GeckoViewPrintDocumentAdapter
(
pdfStream
getContext
(
)
)
;
printManager
.
print
(
"
Firefox
"
pda
null
)
;
}
}
}
