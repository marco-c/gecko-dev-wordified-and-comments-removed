package
org
.
mozilla
.
geckoview
;
import
org
.
mozilla
.
gecko
.
AndroidGamepadManager
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
InputMethods
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
Region
;
import
android
.
os
.
Build
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
support
.
v4
.
view
.
ViewCompat
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
SparseArray
;
import
android
.
util
.
TypedValue
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
SurfaceHolder
;
import
android
.
view
.
SurfaceView
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
ViewStructure
;
import
android
.
view
.
autofill
.
AutofillValue
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
android
.
widget
.
FrameLayout
;
UiThread
public
class
GeckoView
extends
FrameLayout
{
private
static
final
String
LOGTAG
=
"
GeckoView
"
;
private
static
final
boolean
DEBUG
=
false
;
protected
final
NonNull
Display
mDisplay
=
new
Display
(
)
;
protected
Nullable
GeckoSession
mSession
;
private
boolean
mStateSaved
;
protected
Nullable
SurfaceView
mSurfaceView
;
private
boolean
mIsResettingFocus
;
private
GeckoSession
.
SelectionActionDelegate
mSelectionActionDelegate
;
private
static
class
SavedState
extends
BaseSavedState
{
public
final
GeckoSession
session
;
public
SavedState
(
final
Parcelable
superState
final
GeckoSession
session
)
{
super
(
superState
)
;
this
.
session
=
session
;
}
SavedState
(
final
Parcel
in
)
{
super
(
in
)
;
session
=
in
.
readParcelable
(
getClass
(
)
.
getClassLoader
(
)
)
;
}
Override
public
void
writeToParcel
(
final
Parcel
dest
final
int
flags
)
{
super
.
writeToParcel
(
dest
flags
)
;
dest
.
writeParcelable
(
session
flags
)
;
}
public
static
final
Creator
<
SavedState
>
CREATOR
=
new
Creator
<
SavedState
>
(
)
{
Override
public
SavedState
createFromParcel
(
final
Parcel
in
)
{
return
new
SavedState
(
in
)
;
}
Override
public
SavedState
[
]
newArray
(
final
int
size
)
{
return
new
SavedState
[
size
]
;
}
}
;
}
private
class
Display
implements
SurfaceHolder
.
Callback
{
private
final
int
[
]
mOrigin
=
new
int
[
2
]
;
private
GeckoDisplay
mDisplay
;
private
boolean
mValid
;
private
int
mClippingHeight
;
public
void
acquire
(
final
GeckoDisplay
display
)
{
mDisplay
=
display
;
if
(
!
mValid
)
{
return
;
}
setVerticalClipping
(
mClippingHeight
)
;
onGlobalLayout
(
)
;
if
(
GeckoView
.
this
.
mSurfaceView
!
=
null
)
{
final
SurfaceHolder
holder
=
GeckoView
.
this
.
mSurfaceView
.
getHolder
(
)
;
final
Rect
frame
=
holder
.
getSurfaceFrame
(
)
;
mDisplay
.
surfaceChanged
(
holder
.
getSurface
(
)
frame
.
right
frame
.
bottom
)
;
GeckoView
.
this
.
setActive
(
true
)
;
}
}
public
GeckoDisplay
release
(
)
{
if
(
mValid
)
{
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceDestroyed
(
)
;
}
GeckoView
.
this
.
setActive
(
false
)
;
}
final
GeckoDisplay
display
=
mDisplay
;
mDisplay
=
null
;
return
display
;
}
Override
public
void
surfaceCreated
(
final
SurfaceHolder
holder
)
{
}
Override
public
void
surfaceChanged
(
final
SurfaceHolder
holder
final
int
format
final
int
width
final
int
height
)
{
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceChanged
(
holder
.
getSurface
(
)
width
height
)
;
if
(
!
mValid
)
{
GeckoView
.
this
.
setActive
(
true
)
;
}
}
mValid
=
true
;
}
Override
public
void
surfaceDestroyed
(
final
SurfaceHolder
holder
)
{
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceDestroyed
(
)
;
GeckoView
.
this
.
setActive
(
false
)
;
}
mValid
=
false
;
}
public
void
onGlobalLayout
(
)
{
if
(
mDisplay
=
=
null
)
{
return
;
}
if
(
GeckoView
.
this
.
mSurfaceView
!
=
null
)
{
GeckoView
.
this
.
mSurfaceView
.
getLocationOnScreen
(
mOrigin
)
;
mDisplay
.
screenOriginChanged
(
mOrigin
[
0
]
mOrigin
[
1
]
)
;
}
}
public
boolean
shouldPinOnScreen
(
)
{
return
mDisplay
!
=
null
?
mDisplay
.
shouldPinOnScreen
(
)
:
false
;
}
public
void
setVerticalClipping
(
final
int
clippingHeight
)
{
mClippingHeight
=
clippingHeight
;
if
(
mDisplay
!
=
null
)
{
mDisplay
.
setVerticalClipping
(
clippingHeight
)
;
}
}
UiThread
NonNull
GeckoResult
<
Bitmap
>
capturePixels
(
)
{
if
(
mDisplay
=
=
null
)
{
return
GeckoResult
.
fromException
(
new
IllegalStateException
(
"
Display
must
be
created
before
pixels
can
be
captured
"
)
)
;
}
return
mDisplay
.
capturePixels
(
)
;
}
}
public
GeckoView
(
final
Context
context
)
{
super
(
context
)
;
init
(
)
;
}
public
GeckoView
(
final
Context
context
final
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
init
(
)
;
}
private
void
init
(
)
{
setFocusable
(
true
)
;
setFocusableInTouchMode
(
true
)
;
setImportantForAccessibility
(
View
.
IMPORTANT_FOR_ACCESSIBILITY_YES
)
;
setDescendantFocusability
(
FOCUS_BLOCK_DESCENDANTS
)
;
setWillNotCacheDrawing
(
false
)
;
mSurfaceView
=
new
SurfaceView
(
getContext
(
)
)
;
mSurfaceView
.
setBackgroundColor
(
Color
.
WHITE
)
;
addView
(
mSurfaceView
new
ViewGroup
.
LayoutParams
(
ViewGroup
.
LayoutParams
.
MATCH_PARENT
ViewGroup
.
LayoutParams
.
MATCH_PARENT
)
)
;
mSurfaceView
.
getHolder
(
)
.
addCallback
(
mDisplay
)
;
final
Activity
activity
=
ActivityUtils
.
getActivityFromContext
(
getContext
(
)
)
;
if
(
activity
!
=
null
)
{
mSelectionActionDelegate
=
new
BasicSelectionActionDelegate
(
activity
)
;
}
}
public
void
coverUntilFirstPaint
(
final
int
color
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSurfaceView
!
=
null
)
{
mSurfaceView
.
setBackgroundColor
(
color
)
;
}
}
public
boolean
shouldPinOnScreen
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mDisplay
.
shouldPinOnScreen
(
)
;
}
public
void
setVerticalClipping
(
final
int
clippingHeight
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDisplay
.
setVerticalClipping
(
clippingHeight
)
;
}
void
setActive
(
final
boolean
active
)
{
if
(
mSession
!
=
null
)
{
mSession
.
setActive
(
active
)
;
}
}
UiThread
public
Nullable
GeckoSession
releaseSession
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
=
=
null
)
{
return
null
;
}
coverUntilFirstPaint
(
Color
.
WHITE
)
;
GeckoSession
session
=
mSession
;
mSession
.
releaseDisplay
(
mDisplay
.
release
(
)
)
;
mSession
.
getOverscrollEdgeEffect
(
)
.
setInvalidationCallback
(
null
)
;
mSession
.
getCompositorController
(
)
.
setFirstPaintCallback
(
null
)
;
if
(
mSession
.
getAccessibility
(
)
.
getView
(
)
=
=
this
)
{
mSession
.
getAccessibility
(
)
.
setView
(
null
)
;
}
if
(
mSession
.
getTextInput
(
)
.
getView
(
)
=
=
this
)
{
mSession
.
getTextInput
(
)
.
setView
(
null
)
;
}
if
(
mSession
.
getSelectionActionDelegate
(
)
=
=
mSelectionActionDelegate
)
{
mSession
.
setSelectionActionDelegate
(
null
)
;
}
if
(
isFocused
(
)
)
{
mSession
.
setFocused
(
false
)
;
}
mSession
=
null
;
return
session
;
}
UiThread
public
void
setSession
(
NonNull
final
GeckoSession
session
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mSession
!
=
null
&
&
mSession
.
isOpen
(
)
)
{
throw
new
IllegalStateException
(
"
Current
session
is
open
"
)
;
}
releaseSession
(
)
;
mSession
=
session
;
if
(
ViewCompat
.
isAttachedToWindow
(
this
)
)
{
mDisplay
.
acquire
(
session
.
acquireDisplay
(
)
)
;
}
final
Context
context
=
getContext
(
)
;
session
.
getOverscrollEdgeEffect
(
)
.
setTheme
(
context
)
;
session
.
getOverscrollEdgeEffect
(
)
.
setInvalidationCallback
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
16
)
{
GeckoView
.
this
.
postInvalidateOnAnimation
(
)
;
}
else
{
GeckoView
.
this
.
postInvalidateDelayed
(
10
)
;
}
}
}
)
;
final
DisplayMetrics
metrics
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
;
final
TypedValue
outValue
=
new
TypedValue
(
)
;
if
(
context
.
getTheme
(
)
.
resolveAttribute
(
android
.
R
.
attr
.
listPreferredItemHeight
outValue
true
)
)
{
session
.
getPanZoomController
(
)
.
setScrollFactor
(
outValue
.
getDimension
(
metrics
)
)
;
}
else
{
session
.
getPanZoomController
(
)
.
setScrollFactor
(
0
.
075f
*
metrics
.
densityDpi
)
;
}
session
.
getCompositorController
(
)
.
setFirstPaintCallback
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
coverUntilFirstPaint
(
Color
.
TRANSPARENT
)
;
}
}
)
;
if
(
session
.
getTextInput
(
)
.
getView
(
)
=
=
null
)
{
session
.
getTextInput
(
)
.
setView
(
this
)
;
}
if
(
session
.
getAccessibility
(
)
.
getView
(
)
=
=
null
)
{
session
.
getAccessibility
(
)
.
setView
(
this
)
;
}
if
(
session
.
getSelectionActionDelegate
(
)
=
=
null
&
&
mSelectionActionDelegate
!
=
null
)
{
session
.
setSelectionActionDelegate
(
mSelectionActionDelegate
)
;
}
if
(
isFocused
(
)
)
{
session
.
setFocused
(
true
)
;
}
}
AnyThread
public
Nullable
GeckoSession
getSession
(
)
{
return
mSession
;
}
AnyThread
NonNull
EventDispatcher
getEventDispatcher
(
)
{
return
mSession
.
getEventDispatcher
(
)
;
}
public
NonNull
PanZoomController
getPanZoomController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mSession
.
getPanZoomController
(
)
;
}
public
NonNull
DynamicToolbarAnimator
getDynamicToolbarAnimator
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mSession
.
getDynamicToolbarAnimator
(
)
;
}
Override
public
void
onAttachedToWindow
(
)
{
if
(
mSession
!
=
null
)
{
final
GeckoRuntime
runtime
=
mSession
.
getRuntime
(
)
;
if
(
runtime
!
=
null
)
{
runtime
.
orientationChanged
(
)
;
}
}
if
(
mSession
!
=
null
)
{
mDisplay
.
acquire
(
mSession
.
acquireDisplay
(
)
)
;
}
super
.
onAttachedToWindow
(
)
;
}
Override
public
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
if
(
mSession
=
=
null
)
{
return
;
}
mSession
.
releaseDisplay
(
mDisplay
.
release
(
)
)
;
}
Override
protected
void
onConfigurationChanged
(
final
Configuration
newConfig
)
{
super
.
onConfigurationChanged
(
newConfig
)
;
if
(
mSession
!
=
null
)
{
final
GeckoRuntime
runtime
=
mSession
.
getRuntime
(
)
;
if
(
runtime
!
=
null
)
{
runtime
.
orientationChanged
(
newConfig
.
orientation
)
;
runtime
.
configurationChanged
(
newConfig
)
;
}
}
}
Override
public
boolean
gatherTransparentRegion
(
final
Region
region
)
{
if
(
mSurfaceView
!
=
null
)
{
mDisplay
.
onGlobalLayout
(
)
;
}
return
super
.
gatherTransparentRegion
(
region
)
;
}
Override
protected
Parcelable
onSaveInstanceState
(
)
{
mStateSaved
=
true
;
return
new
SavedState
(
super
.
onSaveInstanceState
(
)
mSession
)
;
}
Override
protected
void
onRestoreInstanceState
(
final
Parcelable
state
)
{
mStateSaved
=
false
;
if
(
!
(
state
instanceof
SavedState
)
)
{
super
.
onRestoreInstanceState
(
state
)
;
return
;
}
final
SavedState
ss
=
(
SavedState
)
state
;
super
.
onRestoreInstanceState
(
ss
.
getSuperState
(
)
)
;
restoreSession
(
ss
.
session
)
;
}
private
void
restoreSession
(
final
Nullable
GeckoSession
savedSession
)
{
if
(
savedSession
=
=
null
|
|
savedSession
.
equals
(
mSession
)
)
{
return
;
}
setSession
(
savedSession
)
;
}
Override
public
void
onWindowFocusChanged
(
final
boolean
hasWindowFocus
)
{
super
.
onWindowFocusChanged
(
hasWindowFocus
)
;
if
(
mSession
!
=
null
&
&
hasWindowFocus
&
&
isFocused
(
)
)
{
mSession
.
setFocused
(
true
)
;
}
}
Override
protected
void
onWindowVisibilityChanged
(
final
int
visibility
)
{
super
.
onWindowVisibilityChanged
(
visibility
)
;
if
(
mSession
!
=
null
&
&
visibility
!
=
View
.
VISIBLE
&
&
!
hasWindowFocus
(
)
)
{
mSession
.
setFocused
(
false
)
;
}
}
Override
protected
void
onFocusChanged
(
final
boolean
gainFocus
final
int
direction
final
Rect
previouslyFocusedRect
)
{
super
.
onFocusChanged
(
gainFocus
direction
previouslyFocusedRect
)
;
if
(
mIsResettingFocus
)
{
return
;
}
if
(
mSession
!
=
null
)
{
mSession
.
setFocused
(
gainFocus
)
;
}
if
(
!
gainFocus
)
{
return
;
}
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
!
isFocused
(
)
)
{
return
;
}
final
InputMethodManager
imm
=
InputMethods
.
getInputMethodManager
(
getContext
(
)
)
;
if
(
!
imm
.
isActive
(
GeckoView
.
this
)
)
{
mIsResettingFocus
=
true
;
clearFocus
(
)
;
requestFocus
(
)
;
mIsResettingFocus
=
false
;
}
}
}
)
;
}
Override
public
Handler
getHandler
(
)
{
if
(
Build
.
VERSION
.
SDK_INT
>
=
24
|
|
mSession
=
=
null
)
{
return
super
.
getHandler
(
)
;
}
return
mSession
.
getTextInput
(
)
.
getHandler
(
super
.
getHandler
(
)
)
;
}
Override
public
InputConnection
onCreateInputConnection
(
final
EditorInfo
outAttrs
)
{
if
(
mSession
=
=
null
)
{
return
null
;
}
return
mSession
.
getTextInput
(
)
.
onCreateInputConnection
(
outAttrs
)
;
}
Override
public
boolean
onKeyPreIme
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyPreIme
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyPreIme
(
keyCode
event
)
;
}
Override
public
boolean
onKeyUp
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyUp
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyUp
(
keyCode
event
)
;
}
Override
public
boolean
onKeyDown
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyDown
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyDown
(
keyCode
event
)
;
}
Override
public
boolean
onKeyLongPress
(
final
int
keyCode
final
KeyEvent
event
)
{
if
(
super
.
onKeyLongPress
(
keyCode
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyLongPress
(
keyCode
event
)
;
}
Override
public
boolean
onKeyMultiple
(
final
int
keyCode
final
int
repeatCount
final
KeyEvent
event
)
{
if
(
super
.
onKeyMultiple
(
keyCode
repeatCount
event
)
)
{
return
true
;
}
return
mSession
!
=
null
&
&
mSession
.
getTextInput
(
)
.
onKeyMultiple
(
keyCode
repeatCount
event
)
;
}
Override
public
void
dispatchDraw
(
final
Canvas
canvas
)
{
super
.
dispatchDraw
(
canvas
)
;
if
(
mSession
!
=
null
)
{
mSession
.
getOverscrollEdgeEffect
(
)
.
draw
(
canvas
)
;
}
}
SuppressLint
(
"
ClickableViewAccessibility
"
)
Override
public
boolean
onTouchEvent
(
final
MotionEvent
event
)
{
return
onTouchEventForResult
(
event
)
!
=
PanZoomController
.
INPUT_RESULT_UNHANDLED
;
}
public
PanZoomController
.
InputResult
int
onTouchEventForResult
(
final
NonNull
MotionEvent
event
)
{
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
)
{
requestFocus
(
)
;
}
if
(
mSession
=
=
null
)
{
return
PanZoomController
.
INPUT_RESULT_UNHANDLED
;
}
return
mSession
.
getPanZoomController
(
)
.
onTouchEvent
(
event
)
;
}
Override
public
boolean
onGenericMotionEvent
(
final
MotionEvent
event
)
{
return
onGenericMotionEventForResult
(
event
)
!
=
PanZoomController
.
INPUT_RESULT_HANDLED
;
}
public
PanZoomController
.
InputResult
int
onGenericMotionEventForResult
(
final
NonNull
MotionEvent
event
)
{
if
(
AndroidGamepadManager
.
handleMotionEvent
(
event
)
)
{
return
PanZoomController
.
INPUT_RESULT_HANDLED
;
}
if
(
mSession
=
=
null
)
{
return
PanZoomController
.
INPUT_RESULT_UNHANDLED
;
}
if
(
mSession
.
getAccessibility
(
)
.
onMotionEvent
(
event
)
)
{
return
PanZoomController
.
INPUT_RESULT_HANDLED
;
}
return
mSession
.
getPanZoomController
(
)
.
onMotionEvent
(
event
)
;
}
Override
public
void
onProvideAutofillVirtualStructure
(
final
ViewStructure
structure
final
int
flags
)
{
super
.
onProvideAutofillVirtualStructure
(
structure
flags
)
;
if
(
mSession
!
=
null
)
{
mSession
.
provideAutofillVirtualStructure
(
this
structure
flags
)
;
}
}
Override
TargetApi
(
26
)
public
void
autofill
(
NonNull
final
SparseArray
<
AutofillValue
>
values
)
{
super
.
autofill
(
values
)
;
if
(
mSession
=
=
null
)
{
return
;
}
final
SparseArray
<
CharSequence
>
strValues
=
new
SparseArray
<
>
(
values
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
values
.
size
(
)
;
i
+
+
)
{
final
AutofillValue
value
=
values
.
valueAt
(
i
)
;
if
(
value
.
isText
(
)
)
{
strValues
.
put
(
values
.
keyAt
(
i
)
value
.
getTextValue
(
)
)
;
}
}
mSession
.
autofill
(
strValues
)
;
}
UiThread
public
NonNull
GeckoResult
<
Bitmap
>
capturePixels
(
)
{
return
mDisplay
.
capturePixels
(
)
;
}
}
