package
org
.
mozilla
.
gecko
;
import
android
.
os
.
Build
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Process
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Log
;
import
androidx
.
annotation
.
GuardedBy
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Objects
;
import
java
.
util
.
Queue
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
Executors
;
import
java
.
util
.
concurrent
.
LinkedBlockingQueue
;
import
java
.
util
.
concurrent
.
ScheduledExecutorService
;
import
java
.
util
.
concurrent
.
ScheduledFuture
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicReference
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
geckoview
.
GeckoResult
;
public
class
GeckoJavaSampler
{
private
static
final
String
LOGTAG
=
"
GeckoJavaSampler
"
;
private
static
final
long
REPLACEMENT_MAIN_THREAD_ID
=
1
;
private
static
final
String
REPLACEMENT_MAIN_THREAD_NAME
=
"
AndroidUI
"
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
static
SamplingRunnable
sSamplingRunnable
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
static
ScheduledExecutorService
sSamplingScheduler
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
static
final
AtomicReference
<
ScheduledFuture
<
?
>
>
sSamplingFuture
=
new
AtomicReference
<
>
(
)
;
private
static
final
MarkerStorage
sMarkerStorage
=
new
MarkerStorage
(
)
;
public
static
boolean
isProfilerActive
(
)
{
return
sSamplingFuture
.
get
(
)
!
=
null
;
}
WrapForJNI
private
static
native
double
getProfilerTime
(
)
;
public
static
Nullable
Double
tryToGetProfilerTime
(
)
{
if
(
!
isProfilerActive
(
)
)
{
return
null
;
}
if
(
!
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
)
{
return
null
;
}
return
getProfilerTime
(
)
;
}
private
static
class
Sample
{
public
final
long
mThreadId
;
public
final
Frame
[
]
mFrames
;
public
final
double
mTime
;
public
final
long
mJavaTime
;
public
Sample
(
final
long
aThreadId
final
StackTraceElement
[
]
aStack
)
{
mThreadId
=
aThreadId
;
mFrames
=
new
Frame
[
aStack
.
length
]
;
mTime
=
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
?
getProfilerTime
(
)
:
0
;
mJavaTime
=
mTime
=
=
0
.
0d
?
SystemClock
.
elapsedRealtime
(
)
:
0
;
for
(
int
i
=
0
;
i
<
aStack
.
length
;
i
+
+
)
{
mFrames
[
aStack
.
length
-
1
-
i
]
=
new
Frame
(
aStack
[
i
]
.
getMethodName
(
)
aStack
[
i
]
.
getClassName
(
)
)
;
}
}
}
private
static
class
Frame
{
public
final
String
methodName
;
public
final
String
className
;
private
Frame
(
final
String
methodName
final
String
className
)
{
this
.
methodName
=
methodName
;
this
.
className
=
className
;
}
}
private
static
class
ThreadInfo
{
private
final
long
mId
;
private
final
String
mName
;
public
ThreadInfo
(
final
long
mId
final
String
mName
)
{
this
.
mId
=
mId
;
this
.
mName
=
mName
;
}
WrapForJNI
public
long
getId
(
)
{
return
mId
;
}
WrapForJNI
public
String
getName
(
)
{
return
mName
;
}
}
private
static
class
Marker
extends
JNIObject
{
private
final
long
mThreadId
;
private
final
String
mMarkerName
;
private
final
double
mTime
;
private
final
long
mJavaTime
;
private
final
double
mEndTime
;
private
final
long
mEndJavaTime
;
private
Nullable
final
String
mText
;
public
Marker
(
final
long
aThreadId
NonNull
final
String
aMarkerName
Nullable
final
Double
aStartTime
Nullable
final
Double
aEndTime
Nullable
final
String
aText
)
{
mThreadId
=
getAdjustedThreadId
(
aThreadId
)
;
mMarkerName
=
aMarkerName
;
mText
=
aText
;
if
(
aStartTime
!
=
null
)
{
mTime
=
aStartTime
;
mJavaTime
=
0
;
if
(
aEndTime
!
=
null
)
{
mEndTime
=
aEndTime
;
mEndJavaTime
=
0
;
}
else
{
mEndTime
=
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
?
getProfilerTime
(
)
:
0
;
mEndJavaTime
=
mEndTime
=
=
0
.
0d
?
SystemClock
.
elapsedRealtime
(
)
:
0
;
}
}
else
{
mEndTime
=
0
;
mEndJavaTime
=
0
;
if
(
aEndTime
!
=
null
)
{
mTime
=
aEndTime
;
mJavaTime
=
0
;
}
else
{
mTime
=
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
?
getProfilerTime
(
)
:
0
;
mJavaTime
=
mTime
=
=
0
.
0d
?
SystemClock
.
elapsedRealtime
(
)
:
0
;
}
}
}
WrapForJNI
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
public
double
getStartTime
(
)
{
if
(
mJavaTime
!
=
0
)
{
return
(
mJavaTime
-
SystemClock
.
elapsedRealtime
(
)
)
+
getProfilerTime
(
)
;
}
return
mTime
;
}
WrapForJNI
public
double
getEndTime
(
)
{
if
(
mEndJavaTime
!
=
0
)
{
return
(
mEndJavaTime
-
SystemClock
.
elapsedRealtime
(
)
)
+
getProfilerTime
(
)
;
}
return
mEndTime
;
}
WrapForJNI
public
long
getThreadId
(
)
{
return
mThreadId
;
}
WrapForJNI
public
NonNull
String
getMarkerName
(
)
{
return
mMarkerName
;
}
WrapForJNI
public
Nullable
String
getMarkerText
(
)
{
return
mText
;
}
}
public
static
void
addMarker
(
NonNull
final
String
aMarkerName
Nullable
final
Double
aStartTime
Nullable
final
Double
aEndTime
Nullable
final
String
aText
)
{
sMarkerStorage
.
addMarker
(
aMarkerName
aStartTime
aEndTime
aText
)
;
}
private
static
class
SamplingRunnable
implements
Runnable
{
private
final
long
mMainThreadId
=
Looper
.
getMainLooper
(
)
.
getThread
(
)
.
getId
(
)
;
public
final
int
mInterval
;
private
final
int
mSampleCount
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
boolean
mBufferOverflowed
=
false
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
NonNull
final
List
<
Thread
>
mThreadsToProfile
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
final
Sample
[
]
mSamples
;
GuardedBy
(
"
GeckoJavaSampler
.
class
"
)
private
int
mSamplePos
;
public
SamplingRunnable
(
NonNull
final
List
<
Thread
>
aThreadsToProfile
final
int
aInterval
final
int
aSampleCount
)
{
mThreadsToProfile
=
aThreadsToProfile
;
mInterval
=
Math
.
max
(
1
aInterval
)
;
mSampleCount
=
aSampleCount
;
mSamples
=
new
Sample
[
mSampleCount
]
;
mSamplePos
=
0
;
}
Override
public
void
run
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
for
(
int
i
=
0
;
i
<
mThreadsToProfile
.
size
(
)
;
i
+
+
)
{
final
Thread
thread
=
mThreadsToProfile
.
get
(
i
)
;
final
StackTraceElement
[
]
stackTrace
=
thread
.
getStackTrace
(
)
;
if
(
stackTrace
.
length
=
=
0
)
{
continue
;
}
mSamples
[
mSamplePos
]
=
new
Sample
(
thread
.
getId
(
)
stackTrace
)
;
mSamplePos
+
=
1
;
if
(
mSamplePos
=
=
mSampleCount
)
{
mSamplePos
=
0
;
mBufferOverflowed
=
true
;
}
}
}
}
private
Sample
getSample
(
final
int
aSampleId
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
aSampleId
>
=
mSampleCount
)
{
return
null
;
}
int
samplePos
=
aSampleId
;
if
(
mBufferOverflowed
)
{
samplePos
=
(
samplePos
+
mSamplePos
)
%
mSampleCount
;
}
return
mSamples
[
samplePos
]
;
}
}
}
private
static
synchronized
Sample
getSample
(
final
int
aSampleId
)
{
return
sSamplingRunnable
.
getSample
(
aSampleId
)
;
}
WrapForJNI
public
static
Marker
pollNextMarker
(
)
{
return
sMarkerStorage
.
pollNextMarker
(
)
;
}
WrapForJNI
public
static
synchronized
int
getRegisteredThreadCount
(
)
{
return
sSamplingRunnable
.
mThreadsToProfile
.
size
(
)
;
}
WrapForJNI
public
static
synchronized
ThreadInfo
getRegisteredThreadInfo
(
final
int
aIndex
)
{
final
Thread
thread
=
sSamplingRunnable
.
mThreadsToProfile
.
get
(
aIndex
)
;
String
adjustedThreadName
=
thread
.
getId
(
)
=
=
sSamplingRunnable
.
mMainThreadId
?
REPLACEMENT_MAIN_THREAD_NAME
:
thread
.
getName
(
)
;
adjustedThreadName
+
=
"
(
JVM
)
"
;
return
new
ThreadInfo
(
getAdjustedThreadId
(
thread
.
getId
(
)
)
adjustedThreadName
)
;
}
WrapForJNI
public
static
synchronized
long
getThreadId
(
final
int
aSampleId
)
{
final
Sample
sample
=
getSample
(
aSampleId
)
;
return
getAdjustedThreadId
(
sample
!
=
null
?
sample
.
mThreadId
:
0
)
;
}
private
static
synchronized
long
getAdjustedThreadId
(
final
long
threadId
)
{
return
threadId
=
=
sSamplingRunnable
.
mMainThreadId
?
REPLACEMENT_MAIN_THREAD_ID
:
threadId
;
}
WrapForJNI
public
static
synchronized
double
getSampleTime
(
final
int
aSampleId
)
{
final
Sample
sample
=
getSample
(
aSampleId
)
;
if
(
sample
!
=
null
)
{
if
(
sample
.
mJavaTime
!
=
0
)
{
return
(
sample
.
mJavaTime
-
SystemClock
.
elapsedRealtime
(
)
)
+
getProfilerTime
(
)
;
}
return
sample
.
mTime
;
}
return
0
;
}
WrapForJNI
public
static
synchronized
String
getFrameName
(
final
int
aSampleId
final
int
aFrameId
)
{
final
Sample
sample
=
getSample
(
aSampleId
)
;
if
(
sample
!
=
null
&
&
aFrameId
<
sample
.
mFrames
.
length
)
{
final
Frame
frame
=
sample
.
mFrames
[
aFrameId
]
;
if
(
frame
=
=
null
)
{
return
null
;
}
return
frame
.
className
+
"
.
"
+
frame
.
methodName
+
"
(
)
"
;
}
return
null
;
}
private
static
class
MarkerStorage
{
private
volatile
Queue
<
Marker
>
mMarkers
;
private
volatile
Set
<
Long
>
mProfiledThreadIds
=
Collections
.
emptySet
(
)
;
MarkerStorage
(
)
{
}
public
synchronized
void
start
(
final
int
aMarkerCount
final
List
<
Thread
>
aProfiledThreads
)
{
if
(
this
.
mMarkers
!
=
null
)
{
return
;
}
this
.
mMarkers
=
new
LinkedBlockingQueue
<
>
(
aMarkerCount
)
;
final
Set
<
Long
>
profiledThreadIds
=
new
HashSet
<
>
(
aProfiledThreads
.
size
(
)
)
;
for
(
final
Thread
thread
:
aProfiledThreads
)
{
profiledThreadIds
.
add
(
thread
.
getId
(
)
)
;
}
mProfiledThreadIds
=
Collections
.
unmodifiableSet
(
profiledThreadIds
)
;
}
public
synchronized
void
stop
(
)
{
if
(
this
.
mMarkers
=
=
null
)
{
return
;
}
this
.
mMarkers
=
null
;
mProfiledThreadIds
=
Collections
.
emptySet
(
)
;
}
private
void
addMarker
(
NonNull
final
String
aMarkerName
Nullable
final
Double
aStartTime
Nullable
final
Double
aEndTime
Nullable
final
String
aText
)
{
final
Queue
<
Marker
>
markersQueue
=
this
.
mMarkers
;
if
(
markersQueue
=
=
null
)
{
return
;
}
final
long
threadId
=
Thread
.
currentThread
(
)
.
getId
(
)
;
if
(
!
mProfiledThreadIds
.
contains
(
threadId
)
)
{
return
;
}
final
Marker
newMarker
=
new
Marker
(
threadId
aMarkerName
aStartTime
aEndTime
aText
)
;
boolean
successful
=
markersQueue
.
offer
(
newMarker
)
;
while
(
!
successful
)
{
markersQueue
.
poll
(
)
;
successful
=
markersQueue
.
offer
(
newMarker
)
;
}
}
private
Marker
pollNextMarker
(
)
{
final
Queue
<
Marker
>
markersQueue
=
this
.
mMarkers
;
if
(
markersQueue
=
=
null
)
{
return
null
;
}
return
markersQueue
.
poll
(
)
;
}
}
WrapForJNI
public
static
void
start
(
NonNull
final
Object
[
]
aFilters
final
int
aInterval
final
int
aEntryCount
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
sSamplingRunnable
!
=
null
)
{
return
;
}
final
ScheduledFuture
<
?
>
future
=
sSamplingFuture
.
get
(
)
;
if
(
future
!
=
null
&
&
!
future
.
isDone
(
)
)
{
return
;
}
Log
.
i
(
LOGTAG
"
Profiler
starting
.
Calling
thread
:
"
+
Thread
.
currentThread
(
)
.
getName
(
)
)
;
final
int
limitedEntryCount
=
Math
.
min
(
aEntryCount
120000
)
;
final
List
<
Thread
>
threadsToProfile
=
getThreadsToProfile
(
aFilters
)
;
if
(
threadsToProfile
.
size
(
)
<
1
)
{
throw
new
IllegalStateException
(
"
Expected
>
=
1
thread
to
profile
(
main
thread
)
.
"
)
;
}
Log
.
i
(
LOGTAG
"
Number
of
threads
to
profile
:
"
+
threadsToProfile
.
size
(
)
)
;
sSamplingRunnable
=
new
SamplingRunnable
(
threadsToProfile
aInterval
limitedEntryCount
)
;
sMarkerStorage
.
start
(
limitedEntryCount
threadsToProfile
)
;
sSamplingScheduler
=
Executors
.
newSingleThreadScheduledExecutor
(
)
;
sSamplingFuture
.
set
(
sSamplingScheduler
.
scheduleAtFixedRate
(
sSamplingRunnable
0
sSamplingRunnable
.
mInterval
TimeUnit
.
MILLISECONDS
)
)
;
}
}
private
static
NonNull
List
<
Thread
>
getThreadsToProfile
(
final
Object
[
]
aFilters
)
{
final
List
<
String
>
cleanedFilters
=
new
ArrayList
<
>
(
)
;
for
(
final
Object
rawFilter
:
aFilters
)
{
final
String
filter
=
(
(
String
)
rawFilter
)
.
trim
(
)
.
toLowerCase
(
Locale
.
US
)
;
if
(
filter
.
isEmpty
(
)
)
{
continue
;
}
cleanedFilters
.
add
(
filter
)
;
}
final
ThreadGroup
rootThreadGroup
=
getRootThreadGroup
(
)
;
final
Thread
[
]
activeThreads
=
getActiveThreads
(
rootThreadGroup
)
;
final
Thread
mainThread
=
Looper
.
getMainLooper
(
)
.
getThread
(
)
;
if
(
cleanedFilters
.
contains
(
"
*
"
)
|
|
doAnyFiltersMatchPid
(
cleanedFilters
Process
.
myPid
(
)
)
)
{
final
List
<
Thread
>
activeThreadList
=
new
ArrayList
<
>
(
)
;
Collections
.
addAll
(
activeThreadList
activeThreads
)
;
if
(
!
activeThreadList
.
contains
(
mainThread
)
)
{
activeThreadList
.
add
(
mainThread
)
;
}
return
activeThreadList
;
}
final
List
<
Thread
>
threadsToProfile
=
new
ArrayList
<
>
(
)
;
threadsToProfile
.
add
(
mainThread
)
;
for
(
final
Thread
thread
:
activeThreads
)
{
if
(
shouldProfileThread
(
thread
cleanedFilters
mainThread
)
)
{
threadsToProfile
.
add
(
thread
)
;
}
}
return
threadsToProfile
;
}
private
static
boolean
shouldProfileThread
(
final
Thread
aThread
final
List
<
String
>
aFilters
final
Thread
aMainThread
)
{
final
String
threadName
=
aThread
.
getName
(
)
.
trim
(
)
.
toLowerCase
(
Locale
.
US
)
;
if
(
threadName
.
isEmpty
(
)
)
{
return
false
;
}
if
(
aThread
.
equals
(
aMainThread
)
)
{
return
false
;
}
for
(
final
String
filter
:
aFilters
)
{
if
(
threadName
.
contains
(
filter
)
)
{
return
true
;
}
}
return
false
;
}
private
static
boolean
doAnyFiltersMatchPid
(
NonNull
final
List
<
String
>
aFilters
final
long
aPid
)
{
final
String
prefix
=
"
pid
:
"
;
for
(
final
String
filter
:
aFilters
)
{
if
(
!
filter
.
startsWith
(
prefix
)
)
{
continue
;
}
try
{
final
long
filterPid
=
Long
.
parseLong
(
filter
.
substring
(
prefix
.
length
(
)
)
)
;
if
(
filterPid
=
=
aPid
)
{
return
true
;
}
}
catch
(
final
NumberFormatException
e
)
{
}
}
return
false
;
}
private
static
NonNull
Thread
[
]
getActiveThreads
(
final
NonNull
ThreadGroup
rootThreadGroup
)
{
Thread
[
]
allThreads
;
int
threadsFound
;
do
{
allThreads
=
new
Thread
[
rootThreadGroup
.
activeCount
(
)
+
15
]
;
threadsFound
=
rootThreadGroup
.
enumerate
(
allThreads
true
)
;
}
while
(
threadsFound
>
=
allThreads
.
length
)
;
return
Arrays
.
copyOfRange
(
allThreads
0
threadsFound
)
;
}
private
static
NonNull
ThreadGroup
getRootThreadGroup
(
)
{
ThreadGroup
parentGroup
=
Objects
.
requireNonNull
(
Thread
.
currentThread
(
)
.
getThreadGroup
(
)
)
;
ThreadGroup
group
=
null
;
while
(
parentGroup
!
=
null
)
{
group
=
parentGroup
;
parentGroup
=
group
.
getParent
(
)
;
}
return
group
;
}
WrapForJNI
public
static
void
pauseSampling
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
final
ScheduledFuture
<
?
>
future
=
sSamplingFuture
.
getAndSet
(
null
)
;
future
.
cancel
(
false
)
;
}
}
WrapForJNI
public
static
void
unpauseSampling
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
sSamplingFuture
.
get
(
)
!
=
null
)
{
return
;
}
sSamplingFuture
.
set
(
sSamplingScheduler
.
scheduleAtFixedRate
(
sSamplingRunnable
0
sSamplingRunnable
.
mInterval
TimeUnit
.
MILLISECONDS
)
)
;
}
}
WrapForJNI
public
static
void
stop
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
sSamplingRunnable
=
=
null
)
{
return
;
}
Log
.
i
(
LOGTAG
"
Profiler
stopping
.
Sample
array
position
:
"
+
sSamplingRunnable
.
mSamplePos
+
"
.
Overflowed
?
"
+
sSamplingRunnable
.
mBufferOverflowed
)
;
try
{
sSamplingScheduler
.
shutdown
(
)
;
sSamplingScheduler
.
awaitTermination
(
1000
TimeUnit
.
MILLISECONDS
)
;
}
catch
(
final
InterruptedException
e
)
{
Log
.
e
(
LOGTAG
"
Sampling
scheduler
isn
'
t
terminated
.
Last
sampling
data
might
be
broken
.
"
)
;
sSamplingScheduler
.
shutdownNow
(
)
;
}
sSamplingScheduler
=
null
;
sSamplingRunnable
=
null
;
sSamplingFuture
.
set
(
null
)
;
sMarkerStorage
.
stop
(
)
;
}
}
WrapForJNI
(
dispatchTo
=
"
gecko
"
stubName
=
"
StartProfiler
"
)
private
static
native
void
startProfilerNative
(
String
[
]
aFilters
String
[
]
aFeaturesArr
)
;
WrapForJNI
(
dispatchTo
=
"
gecko
"
stubName
=
"
StopProfiler
"
)
private
static
native
void
stopProfilerNative
(
GeckoResult
<
byte
[
]
>
aResult
)
;
public
static
void
startProfiler
(
final
String
[
]
aFilters
final
String
[
]
aFeaturesArr
)
{
startProfilerNative
(
aFilters
aFeaturesArr
)
;
}
public
static
GeckoResult
<
byte
[
]
>
stopProfiler
(
)
{
final
GeckoResult
<
byte
[
]
>
result
=
new
GeckoResult
<
byte
[
]
>
(
)
;
stopProfilerNative
(
result
)
;
return
result
;
}
WrapForJNI
public
static
String
getDeviceInformation
(
)
{
final
StringBuilder
sb
=
new
StringBuilder
(
Build
.
BRAND
)
;
sb
.
append
(
"
"
)
;
sb
.
append
(
Build
.
MODEL
)
;
return
sb
.
toString
(
)
;
}
}
