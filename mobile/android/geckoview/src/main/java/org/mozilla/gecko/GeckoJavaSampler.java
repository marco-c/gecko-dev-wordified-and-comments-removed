package
org
.
mozilla
.
gecko
;
import
android
.
os
.
Looper
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Log
;
import
java
.
util
.
concurrent
.
Executors
;
import
java
.
util
.
concurrent
.
ScheduledExecutorService
;
import
java
.
util
.
concurrent
.
ScheduledFuture
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
public
class
GeckoJavaSampler
{
private
static
final
String
LOGTAG
=
"
GeckoJavaSampler
"
;
private
static
SamplingRunnable
sSamplingRunnable
;
private
static
ScheduledExecutorService
sSamplingScheduler
;
private
static
ScheduledFuture
<
?
>
sSamplingFuture
;
WrapForJNI
private
static
native
double
getProfilerTime
(
)
;
private
static
class
Sample
{
public
Frame
[
]
mFrames
;
public
double
mTime
;
public
long
mJavaTime
;
public
Sample
(
final
StackTraceElement
[
]
aStack
)
{
mFrames
=
new
Frame
[
aStack
.
length
]
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
)
{
mTime
=
getProfilerTime
(
)
;
}
if
(
mTime
=
=
0
.
0d
)
{
mJavaTime
=
SystemClock
.
elapsedRealtime
(
)
;
}
for
(
int
i
=
0
;
i
<
aStack
.
length
;
i
+
+
)
{
mFrames
[
aStack
.
length
-
1
-
i
]
=
new
Frame
(
)
;
mFrames
[
aStack
.
length
-
1
-
i
]
.
fileName
=
aStack
[
i
]
.
getFileName
(
)
;
mFrames
[
aStack
.
length
-
1
-
i
]
.
lineNo
=
aStack
[
i
]
.
getLineNumber
(
)
;
mFrames
[
aStack
.
length
-
1
-
i
]
.
methodName
=
aStack
[
i
]
.
getMethodName
(
)
;
mFrames
[
aStack
.
length
-
1
-
i
]
.
className
=
aStack
[
i
]
.
getClassName
(
)
;
}
}
}
private
static
class
Frame
{
public
String
fileName
;
public
int
lineNo
;
public
String
methodName
;
public
String
className
;
}
private
static
class
SamplingRunnable
implements
Runnable
{
public
final
int
mInterval
;
private
final
int
mSampleCount
;
private
boolean
mBufferOverflowed
=
false
;
private
Thread
mMainThread
;
private
Sample
[
]
mSamples
;
private
int
mSamplePos
;
public
SamplingRunnable
(
final
int
aInterval
final
int
aSampleCount
)
{
mInterval
=
Math
.
max
(
1
aInterval
)
;
mSampleCount
=
Math
.
min
(
aSampleCount
100000
)
;
mSamples
=
new
Sample
[
aSampleCount
]
;
mSamplePos
=
0
;
mMainThread
=
Looper
.
getMainLooper
(
)
.
getThread
(
)
;
if
(
mMainThread
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Main
thread
not
found
"
)
;
}
}
Override
public
void
run
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
mMainThread
=
=
null
)
{
return
;
}
final
StackTraceElement
[
]
bt
=
mMainThread
.
getStackTrace
(
)
;
mSamples
[
mSamplePos
]
=
new
Sample
(
bt
)
;
mSamplePos
+
=
1
;
if
(
mSamplePos
=
=
mSampleCount
)
{
mSamplePos
=
0
;
mBufferOverflowed
=
true
;
}
}
}
private
Sample
getSample
(
final
int
aSampleId
)
{
if
(
aSampleId
>
=
mSampleCount
)
{
return
null
;
}
int
samplePos
=
aSampleId
;
if
(
mBufferOverflowed
)
{
samplePos
=
(
samplePos
+
mSamplePos
)
%
mSampleCount
;
}
return
mSamples
[
samplePos
]
;
}
}
private
synchronized
static
Sample
getSample
(
final
int
aSampleId
)
{
return
sSamplingRunnable
.
getSample
(
aSampleId
)
;
}
WrapForJNI
public
synchronized
static
double
getSampleTime
(
final
int
aSampleId
)
{
Sample
sample
=
getSample
(
aSampleId
)
;
if
(
sample
!
=
null
)
{
if
(
sample
.
mJavaTime
!
=
0
)
{
return
(
sample
.
mJavaTime
-
SystemClock
.
elapsedRealtime
(
)
)
+
getProfilerTime
(
)
;
}
return
sample
.
mTime
;
}
return
0
;
}
WrapForJNI
public
synchronized
static
String
getFrameName
(
final
int
aSampleId
final
int
aFrameId
)
{
Sample
sample
=
getSample
(
aSampleId
)
;
if
(
sample
!
=
null
&
&
aFrameId
<
sample
.
mFrames
.
length
)
{
Frame
frame
=
sample
.
mFrames
[
aFrameId
]
;
if
(
frame
=
=
null
)
{
return
null
;
}
return
frame
.
className
+
"
.
"
+
frame
.
methodName
+
"
(
)
"
;
}
return
null
;
}
WrapForJNI
public
static
void
start
(
final
int
aInterval
final
int
aSamples
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
sSamplingRunnable
!
=
null
)
{
return
;
}
if
(
sSamplingFuture
!
=
null
&
&
!
sSamplingFuture
.
isDone
(
)
)
{
return
;
}
sSamplingRunnable
=
new
SamplingRunnable
(
aInterval
aSamples
)
;
sSamplingScheduler
=
Executors
.
newSingleThreadScheduledExecutor
(
)
;
sSamplingFuture
=
sSamplingScheduler
.
scheduleAtFixedRate
(
sSamplingRunnable
0
sSamplingRunnable
.
mInterval
TimeUnit
.
MILLISECONDS
)
;
}
}
WrapForJNI
public
static
void
pause
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
sSamplingFuture
.
cancel
(
false
)
;
sSamplingFuture
=
null
;
}
}
WrapForJNI
public
static
void
unpause
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
sSamplingFuture
!
=
null
)
{
return
;
}
sSamplingFuture
=
sSamplingScheduler
.
scheduleAtFixedRate
(
sSamplingRunnable
0
sSamplingRunnable
.
mInterval
TimeUnit
.
MILLISECONDS
)
;
}
}
WrapForJNI
public
static
void
stop
(
)
{
synchronized
(
GeckoJavaSampler
.
class
)
{
if
(
sSamplingRunnable
=
=
null
)
{
return
;
}
try
{
sSamplingScheduler
.
shutdown
(
)
;
sSamplingScheduler
.
awaitTermination
(
1000
TimeUnit
.
MILLISECONDS
)
;
}
catch
(
InterruptedException
e
)
{
Log
.
e
(
LOGTAG
"
Sampling
scheduler
isn
'
t
terminated
.
Last
sampling
data
might
be
broken
.
"
)
;
sSamplingScheduler
.
shutdownNow
(
)
;
}
sSamplingScheduler
=
null
;
sSamplingRunnable
=
null
;
sSamplingFuture
=
null
;
}
}
}
