package
org
.
mozilla
.
gecko
;
import
java
.
lang
.
reflect
.
Array
;
import
java
.
lang
.
reflect
.
Field
;
import
java
.
lang
.
reflect
.
InvocationHandler
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Proxy
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
.
AssertBehavior
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
Handler
;
import
android
.
os
.
IBinder
;
import
android
.
os
.
Looper
;
import
android
.
os
.
RemoteException
;
import
android
.
text
.
Editable
;
import
android
.
text
.
InputFilter
;
import
android
.
text
.
NoCopySpan
;
import
android
.
text
.
Selection
;
import
android
.
text
.
Spannable
;
import
android
.
text
.
SpannableString
;
import
android
.
text
.
SpannableStringBuilder
;
import
android
.
text
.
Spanned
;
import
android
.
text
.
TextPaint
;
import
android
.
text
.
TextUtils
;
import
android
.
text
.
style
.
CharacterStyle
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyCharacterMap
;
import
android
.
view
.
KeyEvent
;
final
class
GeckoEditable
extends
IGeckoEditableParent
.
Stub
implements
InvocationHandler
Editable
GeckoEditableClient
{
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
LOGTAG
=
"
GeckoEditable
"
;
private
InputFilter
[
]
mFilters
;
private
final
AsyncText
mText
;
private
final
Editable
mProxy
;
private
final
ConcurrentLinkedQueue
<
Action
>
mActions
;
private
KeyCharacterMap
mKeyMap
;
private
Handler
mIcRunHandler
;
private
Handler
mIcPostHandler
;
IGeckoEditableChild
mDefaultChild
;
IGeckoEditableChild
mFocusedChild
;
IBinder
mFocusedToken
;
GeckoEditableListener
mListener
;
boolean
mInBatchMode
;
boolean
mNeedSync
;
private
boolean
mNeedUpdateComposition
;
private
boolean
mSuppressKeyUp
;
private
boolean
mIgnoreSelectionChange
;
private
static
final
int
IME_RANGE_CARETPOSITION
=
1
;
private
static
final
int
IME_RANGE_RAWINPUT
=
2
;
private
static
final
int
IME_RANGE_SELECTEDRAWTEXT
=
3
;
private
static
final
int
IME_RANGE_CONVERTEDTEXT
=
4
;
private
static
final
int
IME_RANGE_SELECTEDCONVERTEDTEXT
=
5
;
private
static
final
int
IME_RANGE_LINE_NONE
=
0
;
private
static
final
int
IME_RANGE_LINE_DOTTED
=
1
;
private
static
final
int
IME_RANGE_LINE_DASHED
=
2
;
private
static
final
int
IME_RANGE_LINE_SOLID
=
3
;
private
static
final
int
IME_RANGE_LINE_DOUBLE
=
4
;
private
static
final
int
IME_RANGE_LINE_WAVY
=
5
;
private
static
final
int
IME_RANGE_UNDERLINE
=
1
;
private
static
final
int
IME_RANGE_FORECOLOR
=
2
;
private
static
final
int
IME_RANGE_BACKCOLOR
=
4
;
private
static
final
int
IME_RANGE_LINECOLOR
=
8
;
private
void
onKeyEvent
(
final
IGeckoEditableChild
child
KeyEvent
event
int
action
int
savedMetaState
boolean
isSynthesizedImeKey
)
throws
RemoteException
{
final
int
metaState
=
event
.
getMetaState
(
)
|
savedMetaState
;
final
int
unmodifiedMetaState
=
metaState
&
~
(
KeyEvent
.
META_ALT_MASK
|
KeyEvent
.
META_CTRL_MASK
|
KeyEvent
.
META_META_MASK
)
;
final
int
unicodeChar
=
event
.
getUnicodeChar
(
metaState
)
;
final
int
unmodifiedUnicodeChar
=
event
.
getUnicodeChar
(
unmodifiedMetaState
)
;
final
int
domPrintableKeyValue
=
unicodeChar
>
=
'
'
?
unicodeChar
:
unmodifiedMetaState
!
=
metaState
?
unmodifiedUnicodeChar
:
0
;
final
int
keyPressMetaState
=
(
unicodeChar
>
=
'
'
&
&
unicodeChar
!
=
unmodifiedUnicodeChar
)
?
unmodifiedMetaState
:
metaState
;
final
int
keyUpDownMetaState
=
isSynthesizedImeKey
?
(
unmodifiedMetaState
|
savedMetaState
)
:
metaState
;
child
.
onKeyEvent
(
action
event
.
getKeyCode
(
)
event
.
getScanCode
(
)
keyUpDownMetaState
keyPressMetaState
event
.
getEventTime
(
)
domPrintableKeyValue
event
.
getRepeatCount
(
)
event
.
getFlags
(
)
isSynthesizedImeKey
event
)
;
}
private
final
class
AsyncText
{
private
final
SpannableStringBuilder
mCurrentText
=
new
SpannableStringBuilder
(
)
;
private
int
mCurrentStart
=
Integer
.
MAX_VALUE
;
private
int
mCurrentOldEnd
;
private
int
mCurrentNewEnd
;
private
boolean
mCurrentSelectionChanged
;
private
final
SpannableStringBuilder
mShadowText
=
new
SpannableStringBuilder
(
)
;
private
int
mShadowStart
=
Integer
.
MAX_VALUE
;
private
int
mShadowOldEnd
;
private
int
mShadowNewEnd
;
private
void
addCurrentChangeLocked
(
final
int
start
final
int
oldEnd
final
int
newEnd
)
{
mCurrentStart
=
Math
.
min
(
mCurrentStart
start
)
;
mCurrentOldEnd
+
=
Math
.
max
(
0
oldEnd
-
mCurrentNewEnd
)
;
mCurrentNewEnd
=
newEnd
+
Math
.
max
(
0
mCurrentNewEnd
-
oldEnd
)
;
}
public
synchronized
void
currentReplace
(
final
int
start
final
int
end
final
CharSequence
newText
)
{
mCurrentText
.
replace
(
start
end
newText
)
;
addCurrentChangeLocked
(
start
end
start
+
newText
.
length
(
)
)
;
}
public
synchronized
void
currentSetSelection
(
final
int
start
final
int
end
)
{
Selection
.
setSelection
(
mCurrentText
start
end
)
;
mCurrentSelectionChanged
=
true
;
}
public
synchronized
void
currentSetSpan
(
final
Object
obj
final
int
start
final
int
end
final
int
flags
)
{
mCurrentText
.
setSpan
(
obj
start
end
flags
)
;
addCurrentChangeLocked
(
start
end
end
)
;
}
public
synchronized
void
currentRemoveSpan
(
final
Object
obj
)
{
if
(
obj
=
=
null
)
{
mCurrentText
.
clearSpans
(
)
;
addCurrentChangeLocked
(
0
mCurrentText
.
length
(
)
mCurrentText
.
length
(
)
)
;
return
;
}
final
int
start
=
mCurrentText
.
getSpanStart
(
obj
)
;
final
int
end
=
mCurrentText
.
getSpanEnd
(
obj
)
;
if
(
start
<
0
|
|
end
<
0
)
{
return
;
}
mCurrentText
.
removeSpan
(
obj
)
;
addCurrentChangeLocked
(
start
end
end
)
;
}
public
Spanned
getCurrentText
(
)
{
return
mCurrentText
;
}
private
void
addShadowChange
(
final
int
start
final
int
oldEnd
final
int
newEnd
)
{
mShadowStart
=
Math
.
min
(
mShadowStart
start
)
;
mShadowOldEnd
+
=
Math
.
max
(
0
oldEnd
-
mShadowNewEnd
)
;
mShadowNewEnd
=
newEnd
+
Math
.
max
(
0
mShadowNewEnd
-
oldEnd
)
;
}
public
void
shadowReplace
(
final
int
start
final
int
end
final
CharSequence
newText
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
mShadowText
.
replace
(
start
end
newText
)
;
addShadowChange
(
start
end
start
+
newText
.
length
(
)
)
;
}
public
void
shadowSetSpan
(
final
Object
obj
final
int
start
final
int
end
final
int
flags
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
mShadowText
.
setSpan
(
obj
start
end
flags
)
;
addShadowChange
(
start
end
end
)
;
}
public
void
shadowRemoveSpan
(
final
Object
obj
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
if
(
obj
=
=
null
)
{
mShadowText
.
clearSpans
(
)
;
addShadowChange
(
0
mShadowText
.
length
(
)
mShadowText
.
length
(
)
)
;
return
;
}
final
int
start
=
mShadowText
.
getSpanStart
(
obj
)
;
final
int
end
=
mShadowText
.
getSpanEnd
(
obj
)
;
if
(
start
<
0
|
|
end
<
0
)
{
return
;
}
mShadowText
.
removeSpan
(
obj
)
;
addShadowChange
(
start
end
end
)
;
}
public
Spanned
getShadowText
(
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
return
mShadowText
;
}
public
synchronized
void
syncShadowText
(
final
GeckoEditableListener
listener
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
if
(
mCurrentStart
>
mCurrentOldEnd
&
&
mShadowStart
>
mShadowOldEnd
)
{
if
(
!
mCurrentSelectionChanged
)
{
return
;
}
final
int
start
=
Selection
.
getSelectionStart
(
mCurrentText
)
;
final
int
end
=
Selection
.
getSelectionEnd
(
mCurrentText
)
;
Selection
.
setSelection
(
mShadowText
start
end
)
;
mCurrentSelectionChanged
=
false
;
if
(
listener
!
=
null
)
{
listener
.
onSelectionChange
(
)
;
}
return
;
}
final
int
start
=
Math
.
min
(
mShadowStart
mCurrentStart
)
;
final
int
shadowEnd
=
mShadowNewEnd
+
Math
.
max
(
0
mCurrentOldEnd
-
mShadowOldEnd
)
;
final
int
currentEnd
=
mCurrentNewEnd
+
Math
.
max
(
0
mShadowOldEnd
-
mCurrentOldEnd
)
;
Object
[
]
spans
=
mCurrentText
.
getSpans
(
start
currentEnd
Object
.
class
)
;
for
(
final
Object
span
:
spans
)
{
mShadowText
.
removeSpan
(
span
)
;
}
spans
=
mShadowText
.
getSpans
(
start
shadowEnd
Object
.
class
)
;
for
(
final
Object
span
:
spans
)
{
mShadowText
.
removeSpan
(
span
)
;
}
mShadowText
.
replace
(
start
shadowEnd
mCurrentText
start
currentEnd
)
;
final
int
selStart
=
Selection
.
getSelectionStart
(
mCurrentText
)
;
final
int
selEnd
=
Selection
.
getSelectionEnd
(
mCurrentText
)
;
Selection
.
setSelection
(
mShadowText
selStart
selEnd
)
;
if
(
DEBUG
&
&
!
checkEqualText
(
mShadowText
mCurrentText
)
)
{
throw
new
IllegalStateException
(
"
Failed
to
sync
:
"
+
mShadowStart
+
'
-
'
+
mShadowOldEnd
+
'
-
'
+
mShadowNewEnd
+
'
/
'
+
mCurrentStart
+
'
-
'
+
mCurrentOldEnd
+
'
-
'
+
mCurrentNewEnd
)
;
}
if
(
listener
!
=
null
)
{
listener
.
onTextChange
(
)
;
if
(
mCurrentSelectionChanged
|
|
(
mCurrentOldEnd
!
=
mCurrentNewEnd
&
&
(
selStart
>
=
mCurrentStart
|
|
selEnd
>
=
mCurrentStart
)
)
)
{
listener
.
onSelectionChange
(
)
;
}
}
mCurrentStart
=
mShadowStart
=
Integer
.
MAX_VALUE
;
mCurrentOldEnd
=
mShadowOldEnd
=
0
;
mCurrentNewEnd
=
mShadowNewEnd
=
0
;
mCurrentSelectionChanged
=
false
;
}
}
private
static
boolean
checkEqualText
(
final
Spanned
s1
final
Spanned
s2
)
{
if
(
!
s1
.
toString
(
)
.
equals
(
s2
.
toString
(
)
)
)
{
return
false
;
}
final
Object
[
]
o1s
=
s1
.
getSpans
(
0
s1
.
length
(
)
Object
.
class
)
;
final
Object
[
]
o2s
=
s2
.
getSpans
(
0
s2
.
length
(
)
Object
.
class
)
;
o1loop
:
for
(
final
Object
o1
:
o1s
)
{
for
(
final
Object
o2
:
o2s
)
{
if
(
o1
!
=
o2
)
{
continue
;
}
if
(
s1
.
getSpanStart
(
o1
)
!
=
s2
.
getSpanStart
(
o2
)
|
|
s1
.
getSpanEnd
(
o1
)
!
=
s2
.
getSpanEnd
(
o2
)
|
|
s1
.
getSpanFlags
(
o1
)
!
=
s2
.
getSpanFlags
(
o2
)
)
{
return
false
;
}
continue
o1loop
;
}
return
false
;
}
return
true
;
}
private
static
final
class
Action
{
static
final
int
TYPE_EVENT
=
0
;
static
final
int
TYPE_REPLACE_TEXT
=
1
;
static
final
int
TYPE_SET_SPAN
=
2
;
static
final
int
TYPE_REMOVE_SPAN
=
3
;
static
final
int
TYPE_SET_HANDLER
=
4
;
final
int
mType
;
int
mStart
;
int
mEnd
;
CharSequence
mSequence
;
Object
mSpanObject
;
int
mSpanFlags
;
Handler
mHandler
;
Action
(
int
type
)
{
mType
=
type
;
}
static
Action
newReplaceText
(
CharSequence
text
int
start
int
end
)
{
if
(
start
<
0
|
|
start
>
end
)
{
Log
.
e
(
LOGTAG
"
invalid
replace
text
offsets
:
"
+
start
+
"
to
"
+
end
)
;
throw
new
IllegalArgumentException
(
"
invalid
replace
text
offsets
"
)
;
}
final
Action
action
=
new
Action
(
TYPE_REPLACE_TEXT
)
;
action
.
mSequence
=
text
;
action
.
mStart
=
start
;
action
.
mEnd
=
end
;
return
action
;
}
static
Action
newSetSpan
(
Object
object
int
start
int
end
int
flags
)
{
if
(
start
<
0
|
|
start
>
end
)
{
Log
.
e
(
LOGTAG
"
invalid
span
offsets
:
"
+
start
+
"
to
"
+
end
)
;
throw
new
IllegalArgumentException
(
"
invalid
span
offsets
"
)
;
}
final
Action
action
=
new
Action
(
TYPE_SET_SPAN
)
;
action
.
mSpanObject
=
object
;
action
.
mStart
=
start
;
action
.
mEnd
=
end
;
action
.
mSpanFlags
=
flags
;
return
action
;
}
static
Action
newRemoveSpan
(
Object
object
)
{
final
Action
action
=
new
Action
(
TYPE_REMOVE_SPAN
)
;
action
.
mSpanObject
=
object
;
return
action
;
}
static
Action
newSetHandler
(
Handler
handler
)
{
final
Action
action
=
new
Action
(
TYPE_SET_HANDLER
)
;
action
.
mHandler
=
handler
;
return
action
;
}
}
private
void
icOfferAction
(
final
Action
action
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
Log
.
d
(
LOGTAG
"
offer
:
Action
(
"
+
getConstantName
(
Action
.
class
"
TYPE_
"
action
.
mType
)
+
"
)
"
)
;
}
switch
(
action
.
mType
)
{
case
Action
.
TYPE_EVENT
:
case
Action
.
TYPE_SET_HANDLER
:
break
;
case
Action
.
TYPE_SET_SPAN
:
mText
.
shadowSetSpan
(
action
.
mSpanObject
action
.
mStart
action
.
mEnd
action
.
mSpanFlags
)
;
break
;
case
Action
.
TYPE_REMOVE_SPAN
:
action
.
mSpanFlags
=
mText
.
getShadowText
(
)
.
getSpanFlags
(
action
.
mSpanObject
)
;
mText
.
shadowRemoveSpan
(
action
.
mSpanObject
)
;
break
;
case
Action
.
TYPE_REPLACE_TEXT
:
mText
.
shadowReplace
(
action
.
mStart
action
.
mEnd
action
.
mSequence
)
;
break
;
default
:
throw
new
IllegalStateException
(
"
Action
not
processed
"
)
;
}
if
(
mFocusedChild
=
=
null
|
|
mListener
=
=
null
)
{
return
;
}
mActions
.
offer
(
action
)
;
try
{
icPerformAction
(
action
)
;
}
catch
(
final
RemoteException
e
)
{
Log
.
e
(
LOGTAG
"
Remote
call
failed
"
e
)
;
mActions
.
remove
(
action
)
;
}
}
private
void
icPerformAction
(
final
Action
action
)
throws
RemoteException
{
switch
(
action
.
mType
)
{
case
Action
.
TYPE_EVENT
:
case
Action
.
TYPE_SET_HANDLER
:
mFocusedChild
.
onImeSynchronize
(
)
;
break
;
case
Action
.
TYPE_SET_SPAN
:
{
final
boolean
needUpdate
=
(
action
.
mSpanFlags
&
Spanned
.
SPAN_INTERMEDIATE
)
=
=
0
&
&
(
(
action
.
mSpanFlags
&
Spanned
.
SPAN_COMPOSING
)
!
=
0
|
|
action
.
mSpanObject
=
=
Selection
.
SELECTION_START
|
|
action
.
mSpanObject
=
=
Selection
.
SELECTION_END
)
;
action
.
mSequence
=
TextUtils
.
substring
(
mText
.
getShadowText
(
)
action
.
mStart
action
.
mEnd
)
;
mNeedUpdateComposition
|
=
needUpdate
;
if
(
needUpdate
)
{
icMaybeSendComposition
(
mText
.
getShadowText
(
)
SEND_COMPOSITION_NOTIFY_GECKO
|
SEND_COMPOSITION_KEEP_CURRENT
)
;
}
mFocusedChild
.
onImeSynchronize
(
)
;
break
;
}
case
Action
.
TYPE_REMOVE_SPAN
:
{
final
boolean
needUpdate
=
(
action
.
mSpanFlags
&
Spanned
.
SPAN_INTERMEDIATE
)
=
=
0
&
&
(
action
.
mSpanFlags
&
Spanned
.
SPAN_COMPOSING
)
!
=
0
;
mNeedUpdateComposition
|
=
needUpdate
;
if
(
needUpdate
)
{
icMaybeSendComposition
(
mText
.
getShadowText
(
)
SEND_COMPOSITION_NOTIFY_GECKO
|
SEND_COMPOSITION_KEEP_CURRENT
)
;
}
mFocusedChild
.
onImeSynchronize
(
)
;
break
;
}
case
Action
.
TYPE_REPLACE_TEXT
:
mNeedSync
=
true
;
if
(
!
icMaybeSendComposition
(
action
.
mSequence
SEND_COMPOSITION_USE_ENTIRE_TEXT
)
)
{
sendCharKeyEvents
(
action
)
;
}
mFocusedChild
.
onImeReplaceText
(
action
.
mStart
action
.
mEnd
action
.
mSequence
.
toString
(
)
)
;
break
;
default
:
throw
new
IllegalStateException
(
"
Action
not
processed
"
)
;
}
}
private
KeyEvent
[
]
synthesizeKeyEvents
(
CharSequence
cs
)
{
try
{
if
(
mKeyMap
=
=
null
)
{
mKeyMap
=
KeyCharacterMap
.
load
(
KeyCharacterMap
.
VIRTUAL_KEYBOARD
)
;
}
}
catch
(
Exception
e
)
{
return
null
;
}
KeyEvent
[
]
keyEvents
=
mKeyMap
.
getEvents
(
cs
.
toString
(
)
.
toCharArray
(
)
)
;
if
(
keyEvents
=
=
null
|
|
keyEvents
.
length
=
=
0
)
{
return
null
;
}
return
keyEvents
;
}
private
void
sendCharKeyEvents
(
Action
action
)
throws
RemoteException
{
if
(
action
.
mSequence
.
length
(
)
!
=
1
|
|
(
action
.
mSequence
instanceof
Spannable
&
&
(
(
Spannable
)
action
.
mSequence
)
.
nextSpanTransition
(
-
1
Integer
.
MAX_VALUE
null
)
<
Integer
.
MAX_VALUE
)
)
{
return
;
}
KeyEvent
[
]
keyEvents
=
synthesizeKeyEvents
(
action
.
mSequence
)
;
if
(
keyEvents
=
=
null
)
{
return
;
}
for
(
KeyEvent
event
:
keyEvents
)
{
if
(
KeyEvent
.
isModifierKey
(
event
.
getKeyCode
(
)
)
)
{
continue
;
}
if
(
event
.
getAction
(
)
=
=
KeyEvent
.
ACTION_UP
&
&
mSuppressKeyUp
)
{
continue
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
sending
:
"
+
event
)
;
}
onKeyEvent
(
mFocusedChild
event
event
.
getAction
(
)
0
true
)
;
}
}
GeckoEditable
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
}
mText
=
new
AsyncText
(
)
;
mActions
=
new
ConcurrentLinkedQueue
<
Action
>
(
)
;
final
Class
<
?
>
[
]
PROXY_INTERFACES
=
{
Editable
.
class
}
;
mProxy
=
(
Editable
)
Proxy
.
newProxyInstance
(
Editable
.
class
.
getClassLoader
(
)
PROXY_INTERFACES
this
)
;
mIcRunHandler
=
mIcPostHandler
=
ThreadUtils
.
getUiHandler
(
)
;
}
void
setDefaultEditableChild
(
final
IGeckoEditableChild
child
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
Log
.
d
(
LOGTAG
"
setDefaultEditableChild
"
+
child
)
;
}
mDefaultChild
=
child
;
}
void
setListener
(
final
GeckoEditableListener
newListener
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
Log
.
d
(
LOGTAG
"
setListener
"
+
newListener
)
;
}
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onViewChange
(
set
listener
)
"
)
;
}
mListener
=
newListener
;
}
}
)
;
}
private
boolean
onIcThread
(
)
{
return
mIcRunHandler
.
getLooper
(
)
=
=
Looper
.
myLooper
(
)
;
}
private
void
assertOnIcThread
(
)
{
ThreadUtils
.
assertOnThread
(
mIcRunHandler
.
getLooper
(
)
.
getThread
(
)
AssertBehavior
.
THROW
)
;
}
private
Object
getField
(
Object
obj
String
field
Object
def
)
{
try
{
return
obj
.
getClass
(
)
.
getField
(
field
)
.
get
(
obj
)
;
}
catch
(
Exception
e
)
{
return
def
;
}
}
private
static
final
int
SEND_COMPOSITION_USE_ENTIRE_TEXT
=
1
;
private
static
final
int
SEND_COMPOSITION_NOTIFY_GECKO
=
2
;
private
static
final
int
SEND_COMPOSITION_KEEP_CURRENT
=
4
;
private
boolean
icMaybeSendComposition
(
final
CharSequence
sequence
final
int
flags
)
throws
RemoteException
{
final
boolean
useEntireText
=
(
flags
&
SEND_COMPOSITION_USE_ENTIRE_TEXT
)
!
=
0
;
final
boolean
notifyGecko
=
(
flags
&
SEND_COMPOSITION_NOTIFY_GECKO
)
!
=
0
;
final
boolean
keepCurrent
=
(
flags
&
SEND_COMPOSITION_KEEP_CURRENT
)
!
=
0
;
final
int
updateFlags
=
keepCurrent
?
GeckoEditableChild
.
FLAG_KEEP_CURRENT_COMPOSITION
:
0
;
if
(
!
keepCurrent
)
{
mNeedUpdateComposition
=
false
;
}
int
selStart
=
Selection
.
getSelectionStart
(
sequence
)
;
int
selEnd
=
Selection
.
getSelectionEnd
(
sequence
)
;
if
(
sequence
instanceof
Spanned
)
{
final
Spanned
text
=
(
Spanned
)
sequence
;
final
Object
[
]
spans
=
text
.
getSpans
(
0
text
.
length
(
)
Object
.
class
)
;
boolean
found
=
false
;
int
composingStart
=
useEntireText
?
0
:
Integer
.
MAX_VALUE
;
int
composingEnd
=
useEntireText
?
text
.
length
(
)
:
0
;
for
(
Object
span
:
spans
)
{
if
(
(
text
.
getSpanFlags
(
span
)
&
Spanned
.
SPAN_COMPOSING
)
=
=
0
)
{
continue
;
}
found
=
true
;
if
(
useEntireText
)
{
break
;
}
composingStart
=
Math
.
min
(
composingStart
text
.
getSpanStart
(
span
)
)
;
composingEnd
=
Math
.
max
(
composingEnd
text
.
getSpanEnd
(
span
)
)
;
}
if
(
useEntireText
&
&
(
selStart
<
0
|
|
selEnd
<
0
)
)
{
selStart
=
composingEnd
;
selEnd
=
composingEnd
;
}
if
(
found
)
{
icSendComposition
(
text
selStart
selEnd
composingStart
composingEnd
)
;
if
(
notifyGecko
)
{
mFocusedChild
.
onImeUpdateComposition
(
composingStart
composingEnd
updateFlags
)
;
}
return
true
;
}
}
if
(
notifyGecko
)
{
mFocusedChild
.
onImeUpdateComposition
(
selStart
selEnd
updateFlags
)
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
icSendComposition
(
)
:
no
composition
"
)
;
}
return
false
;
}
private
void
icSendComposition
(
final
Spanned
text
final
int
selStart
final
int
selEnd
final
int
composingStart
final
int
composingEnd
)
throws
RemoteException
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
Log
.
d
(
LOGTAG
"
icSendComposition
(
\
"
"
+
text
+
"
\
"
"
+
composingStart
+
"
"
+
composingEnd
+
"
)
"
)
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
range
=
"
+
composingStart
+
"
-
"
+
composingEnd
)
;
Log
.
d
(
LOGTAG
"
selection
=
"
+
selStart
+
"
-
"
+
selEnd
)
;
}
if
(
selEnd
>
=
composingStart
&
&
selEnd
<
=
composingEnd
)
{
mFocusedChild
.
onImeAddCompositionRange
(
selEnd
-
composingStart
selEnd
-
composingStart
IME_RANGE_CARETPOSITION
0
0
false
0
0
0
)
;
}
int
rangeStart
=
composingStart
;
TextPaint
tp
=
new
TextPaint
(
)
;
TextPaint
emptyTp
=
new
TextPaint
(
)
;
emptyTp
.
setColor
(
0
)
;
do
{
int
rangeType
rangeStyles
=
0
rangeLineStyle
=
IME_RANGE_LINE_NONE
;
boolean
rangeBoldLine
=
false
;
int
rangeForeColor
=
0
rangeBackColor
=
0
rangeLineColor
=
0
;
int
rangeEnd
=
text
.
nextSpanTransition
(
rangeStart
composingEnd
Object
.
class
)
;
if
(
selStart
>
rangeStart
&
&
selStart
<
rangeEnd
)
{
rangeEnd
=
selStart
;
}
else
if
(
selEnd
>
rangeStart
&
&
selEnd
<
rangeEnd
)
{
rangeEnd
=
selEnd
;
}
CharacterStyle
[
]
styleSpans
=
text
.
getSpans
(
rangeStart
rangeEnd
CharacterStyle
.
class
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
found
"
+
styleSpans
.
length
+
"
spans
"
+
rangeStart
+
"
-
"
+
rangeEnd
)
;
}
if
(
styleSpans
.
length
=
=
0
)
{
rangeType
=
(
selStart
=
=
rangeStart
&
&
selEnd
=
=
rangeEnd
)
?
IME_RANGE_SELECTEDRAWTEXT
:
IME_RANGE_RAWINPUT
;
}
else
{
rangeType
=
(
selStart
=
=
rangeStart
&
&
selEnd
=
=
rangeEnd
)
?
IME_RANGE_SELECTEDCONVERTEDTEXT
:
IME_RANGE_CONVERTEDTEXT
;
tp
.
set
(
emptyTp
)
;
for
(
CharacterStyle
span
:
styleSpans
)
{
span
.
updateDrawState
(
tp
)
;
}
int
tpUnderlineColor
=
0
;
float
tpUnderlineThickness
=
0
.
0f
;
tpUnderlineColor
=
(
Integer
)
getField
(
tp
"
underlineColor
"
0
)
;
tpUnderlineThickness
=
(
Float
)
getField
(
tp
"
underlineThickness
"
0
.
0f
)
;
if
(
tpUnderlineColor
!
=
0
)
{
rangeStyles
|
=
IME_RANGE_UNDERLINE
|
IME_RANGE_LINECOLOR
;
rangeLineColor
=
tpUnderlineColor
;
if
(
tpUnderlineThickness
<
=
0
.
5f
)
{
rangeLineStyle
=
IME_RANGE_LINE_DOTTED
;
}
else
{
rangeLineStyle
=
IME_RANGE_LINE_SOLID
;
if
(
tpUnderlineThickness
>
=
2
.
0f
)
{
rangeBoldLine
=
true
;
}
}
}
else
if
(
tp
.
isUnderlineText
(
)
)
{
rangeStyles
|
=
IME_RANGE_UNDERLINE
;
rangeLineStyle
=
IME_RANGE_LINE_SOLID
;
}
if
(
tp
.
getColor
(
)
!
=
0
)
{
rangeStyles
|
=
IME_RANGE_FORECOLOR
;
rangeForeColor
=
tp
.
getColor
(
)
;
}
if
(
tp
.
bgColor
!
=
0
)
{
rangeStyles
|
=
IME_RANGE_BACKCOLOR
;
rangeBackColor
=
tp
.
bgColor
;
}
}
mFocusedChild
.
onImeAddCompositionRange
(
rangeStart
-
composingStart
rangeEnd
-
composingStart
rangeType
rangeStyles
rangeLineStyle
rangeBoldLine
rangeForeColor
rangeBackColor
rangeLineColor
)
;
rangeStart
=
rangeEnd
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
added
"
+
rangeType
+
"
:
"
+
Integer
.
toHexString
(
rangeStyles
)
+
"
:
"
+
Integer
.
toHexString
(
rangeForeColor
)
+
"
:
"
+
Integer
.
toHexString
(
rangeBackColor
)
)
;
}
}
while
(
rangeStart
<
composingEnd
)
;
}
Override
public
void
sendKeyEvent
(
final
KeyEvent
event
int
action
int
metaState
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
Log
.
d
(
LOGTAG
"
sendKeyEvent
(
"
+
event
+
"
"
+
action
+
"
"
+
metaState
+
"
)
"
)
;
}
try
{
if
(
mFocusedChild
=
=
null
)
{
onKeyEvent
(
mDefaultChild
event
action
metaState
false
)
;
return
;
}
if
(
mNeedUpdateComposition
)
{
icMaybeSendComposition
(
mText
.
getShadowText
(
)
SEND_COMPOSITION_NOTIFY_GECKO
)
;
}
onKeyEvent
(
mFocusedChild
event
action
metaState
false
)
;
icOfferAction
(
new
Action
(
Action
.
TYPE_EVENT
)
)
;
}
catch
(
final
RemoteException
e
)
{
Log
.
e
(
LOGTAG
"
Remote
call
failed
"
e
)
;
}
}
Override
public
Editable
getEditable
(
)
{
if
(
!
onIcThread
(
)
)
{
if
(
DEBUG
)
{
Log
.
i
(
LOGTAG
"
getEditable
(
)
called
on
non
-
IC
thread
"
)
;
}
return
null
;
}
if
(
mListener
=
=
null
)
{
return
null
;
}
return
mProxy
;
}
Override
public
void
setBatchMode
(
boolean
inBatchMode
)
{
if
(
!
onIcThread
(
)
)
{
if
(
DEBUG
)
{
Log
.
i
(
LOGTAG
"
setBatchMode
(
)
called
on
non
-
IC
thread
"
)
;
}
return
;
}
mInBatchMode
=
inBatchMode
;
if
(
!
inBatchMode
&
&
mNeedSync
)
{
icSyncShadowText
(
)
;
}
}
void
icSyncShadowText
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
if
(
mInBatchMode
|
|
!
mActions
.
isEmpty
(
)
)
{
mNeedSync
=
true
;
return
;
}
mNeedSync
=
false
;
mText
.
syncShadowText
(
mListener
)
;
}
Override
public
void
setSuppressKeyUp
(
boolean
suppress
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
mSuppressKeyUp
=
suppress
;
}
Override
public
Handler
setInputConnectionHandler
(
final
Handler
handler
)
{
if
(
handler
=
=
mIcRunHandler
)
{
return
mIcRunHandler
;
}
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
handler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
synchronized
(
handler
)
{
while
(
mIcRunHandler
!
=
handler
)
{
try
{
handler
.
wait
(
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
}
}
}
)
;
icOfferAction
(
Action
.
newSetHandler
(
handler
)
)
;
return
handler
;
}
Override
public
void
postToInputConnection
(
final
Runnable
runnable
)
{
mIcPostHandler
.
post
(
runnable
)
;
}
Override
public
void
requestCursorUpdates
(
int
requestMode
)
{
try
{
if
(
mFocusedChild
!
=
null
)
{
mFocusedChild
.
onImeRequestCursorUpdates
(
requestMode
)
;
}
}
catch
(
final
RemoteException
e
)
{
Log
.
e
(
LOGTAG
"
Remote
call
failed
"
e
)
;
}
}
private
void
geckoSetIcHandler
(
final
Handler
newHandler
)
{
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
synchronized
(
newHandler
)
{
mIcRunHandler
=
newHandler
;
newHandler
.
notify
(
)
;
}
}
}
)
;
mIcPostHandler
=
newHandler
;
}
private
void
geckoActionReply
(
final
Action
action
)
{
if
(
action
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Mismatched
reply
"
)
;
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
reply
:
Action
(
"
+
getConstantName
(
Action
.
class
"
TYPE_
"
action
.
mType
)
+
"
)
"
)
;
}
switch
(
action
.
mType
)
{
case
Action
.
TYPE_SET_SPAN
:
final
int
len
=
mText
.
getCurrentText
(
)
.
length
(
)
;
if
(
action
.
mStart
>
len
|
|
action
.
mEnd
>
len
|
|
!
TextUtils
.
substring
(
mText
.
getCurrentText
(
)
action
.
mStart
action
.
mEnd
)
.
equals
(
action
.
mSequence
)
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
discarding
stale
set
span
call
"
)
;
}
break
;
}
mText
.
currentSetSpan
(
action
.
mSpanObject
action
.
mStart
action
.
mEnd
action
.
mSpanFlags
)
;
break
;
case
Action
.
TYPE_REMOVE_SPAN
:
mText
.
currentRemoveSpan
(
action
.
mSpanObject
)
;
break
;
case
Action
.
TYPE_SET_HANDLER
:
geckoSetIcHandler
(
action
.
mHandler
)
;
break
;
}
}
private
synchronized
boolean
binderCheckToken
(
final
IBinder
token
final
boolean
allowNull
)
{
if
(
mFocusedToken
=
=
token
|
|
(
mFocusedToken
=
=
null
&
&
allowNull
)
)
{
return
true
;
}
Log
.
w
(
LOGTAG
"
Invalid
token
"
)
;
return
false
;
}
Override
public
void
notifyIME
(
final
IGeckoEditableChild
child
final
int
type
)
{
if
(
DEBUG
)
{
if
(
type
!
=
GeckoEditableListener
.
NOTIFY_IME_REPLY_EVENT
)
{
Log
.
d
(
LOGTAG
"
notifyIME
(
"
+
getConstantName
(
GeckoEditableListener
.
class
"
NOTIFY_IME_
"
type
)
+
"
)
"
)
;
}
}
final
IBinder
token
=
child
.
asBinder
(
)
;
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_OF_TOKEN
)
{
synchronized
(
this
)
{
if
(
mFocusedToken
!
=
null
&
&
mFocusedToken
!
=
token
&
&
mFocusedToken
.
pingBinder
(
)
)
{
Log
.
w
(
LOGTAG
"
Already
focused
"
)
;
return
;
}
mFocusedToken
=
token
;
return
;
}
}
else
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_OPEN_VKB
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
}
else
if
(
!
binderCheckToken
(
token
false
)
)
{
return
;
}
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_OF_BLUR
)
{
synchronized
(
this
)
{
onTextChange
(
token
"
"
0
Integer
.
MAX_VALUE
)
;
mActions
.
clear
(
)
;
mFocusedToken
=
null
;
}
}
else
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_REPLY_EVENT
)
{
geckoActionReply
(
mActions
.
poll
(
)
)
;
if
(
!
mActions
.
isEmpty
(
)
)
{
return
;
}
}
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_REPLY_EVENT
)
{
if
(
mNeedSync
)
{
icSyncShadowText
(
)
;
}
return
;
}
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_OF_FOCUS
&
&
mListener
!
=
null
)
{
mFocusedChild
=
child
;
mNeedSync
=
false
;
mText
.
syncShadowText
(
null
)
;
}
else
if
(
type
=
=
GeckoEditableListener
.
NOTIFY_IME_OF_BLUR
)
{
mFocusedChild
=
null
;
}
if
(
mListener
!
=
null
)
{
mListener
.
notifyIME
(
type
)
;
}
}
}
)
;
}
Override
public
void
notifyIMEContext
(
final
int
state
final
String
typeHint
final
String
modeHint
final
String
actionHint
final
boolean
inPrivateBrowsing
final
boolean
isUserAction
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
notifyIMEContext
(
"
+
getConstantName
(
GeckoEditableListener
.
class
"
IME_STATE_
"
state
)
+
"
\
"
"
+
typeHint
+
"
\
"
\
"
"
+
modeHint
+
"
\
"
\
"
"
+
actionHint
+
"
\
"
"
+
"
inPrivateBrowsing
=
"
+
inPrivateBrowsing
+
"
)
"
)
;
}
ThreadUtils
.
assertOnGeckoThread
(
)
;
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
mListener
.
notifyIMEContext
(
state
typeHint
modeHint
actionHint
inPrivateBrowsing
isUserAction
)
;
}
}
)
;
}
Override
public
void
onSelectionChange
(
final
IBinder
token
final
int
start
final
int
end
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onSelectionChange
(
"
+
start
+
"
"
+
end
+
"
)
"
)
;
}
if
(
!
binderCheckToken
(
token
false
)
)
{
return
;
}
if
(
mIgnoreSelectionChange
)
{
mIgnoreSelectionChange
=
false
;
}
else
{
mText
.
currentSetSelection
(
start
end
)
;
}
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
icSyncShadowText
(
)
;
}
}
)
;
}
private
boolean
geckoIsSameText
(
int
start
int
oldEnd
CharSequence
newText
)
{
return
oldEnd
-
start
=
=
newText
.
length
(
)
&
&
TextUtils
.
regionMatches
(
mText
.
getCurrentText
(
)
start
newText
0
oldEnd
-
start
)
;
}
Override
public
void
onTextChange
(
final
IBinder
token
final
CharSequence
text
final
int
start
final
int
unboundedOldEnd
)
{
if
(
DEBUG
)
{
StringBuilder
sb
=
new
StringBuilder
(
"
onTextChange
(
"
)
;
debugAppend
(
sb
text
)
.
append
(
"
"
)
.
append
(
start
)
.
append
(
"
"
)
.
append
(
unboundedOldEnd
)
.
append
(
"
)
"
)
;
Log
.
d
(
LOGTAG
sb
.
toString
(
)
)
;
}
if
(
!
binderCheckToken
(
token
false
)
)
{
return
;
}
final
int
currentLength
=
mText
.
getCurrentText
(
)
.
length
(
)
;
final
int
oldEnd
=
unboundedOldEnd
>
currentLength
?
currentLength
:
unboundedOldEnd
;
final
int
newEnd
=
start
+
text
.
length
(
)
;
final
Action
action
=
mActions
.
peek
(
)
;
if
(
start
=
=
0
&
&
unboundedOldEnd
>
currentLength
)
{
mText
.
currentReplace
(
0
currentLength
"
"
)
;
mText
.
currentReplace
(
0
0
text
)
;
mIgnoreSelectionChange
=
false
;
}
else
if
(
action
!
=
null
&
&
action
.
mType
=
=
Action
.
TYPE_REPLACE_TEXT
&
&
start
<
=
action
.
mStart
&
&
oldEnd
>
=
action
.
mEnd
&
&
newEnd
>
=
action
.
mStart
+
action
.
mSequence
.
length
(
)
)
{
final
int
startWithinText
=
action
.
mStart
-
start
;
int
indexInText
=
TextUtils
.
indexOf
(
text
action
.
mSequence
startWithinText
)
;
if
(
indexInText
<
0
&
&
startWithinText
>
=
action
.
mSequence
.
length
(
)
)
{
indexInText
=
text
.
toString
(
)
.
lastIndexOf
(
action
.
mSequence
.
toString
(
)
startWithinText
)
;
}
if
(
indexInText
<
0
)
{
mText
.
currentReplace
(
start
oldEnd
text
)
;
mIgnoreSelectionChange
=
false
;
}
else
if
(
indexInText
=
=
0
&
&
text
.
length
(
)
=
=
action
.
mSequence
.
length
(
)
&
&
oldEnd
-
start
=
=
action
.
mEnd
-
action
.
mStart
)
{
mText
.
currentReplace
(
start
oldEnd
action
.
mSequence
)
;
mIgnoreSelectionChange
=
true
;
}
else
{
mText
.
currentReplace
(
start
action
.
mStart
text
.
subSequence
(
0
indexInText
)
)
;
final
int
actionStart
=
indexInText
+
start
;
final
int
delta
=
actionStart
-
action
.
mStart
;
final
int
actionEnd
=
delta
+
action
.
mEnd
;
final
Spanned
currentText
=
mText
.
getCurrentText
(
)
;
final
boolean
resetSelStart
=
Selection
.
getSelectionStart
(
currentText
)
=
=
actionEnd
;
final
boolean
resetSelEnd
=
Selection
.
getSelectionEnd
(
currentText
)
=
=
actionEnd
;
mText
.
currentReplace
(
actionEnd
delta
+
oldEnd
text
.
subSequence
(
indexInText
+
action
.
mSequence
.
length
(
)
text
.
length
(
)
)
)
;
if
(
resetSelStart
|
|
resetSelEnd
)
{
mText
.
currentSetSelection
(
resetSelStart
?
actionEnd
:
Selection
.
getSelectionStart
(
currentText
)
resetSelEnd
?
actionEnd
:
Selection
.
getSelectionEnd
(
currentText
)
)
;
}
mText
.
currentReplace
(
actionStart
actionEnd
action
.
mSequence
)
;
mIgnoreSelectionChange
=
!
resetSelStart
|
|
!
resetSelEnd
;
}
}
else
if
(
geckoIsSameText
(
start
oldEnd
text
)
)
{
mIgnoreSelectionChange
=
mIgnoreSelectionChange
|
|
(
action
!
=
null
&
&
(
action
.
mType
=
=
Action
.
TYPE_REPLACE_TEXT
|
|
action
.
mType
=
=
Action
.
TYPE_SET_SPAN
|
|
action
.
mType
=
=
Action
.
TYPE_REMOVE_SPAN
)
)
;
return
;
}
else
{
mText
.
currentReplace
(
start
oldEnd
"
"
)
;
mText
.
currentReplace
(
start
start
text
)
;
mIgnoreSelectionChange
=
false
;
}
}
Override
public
void
onDefaultKeyEvent
(
final
IBinder
token
final
KeyEvent
event
)
{
if
(
DEBUG
)
{
StringBuilder
sb
=
new
StringBuilder
(
"
onDefaultKeyEvent
(
"
)
;
sb
.
append
(
"
action
=
"
)
.
append
(
event
.
getAction
(
)
)
.
append
(
"
"
)
.
append
(
"
keyCode
=
"
)
.
append
(
event
.
getKeyCode
(
)
)
.
append
(
"
"
)
.
append
(
"
metaState
=
"
)
.
append
(
event
.
getMetaState
(
)
)
.
append
(
"
"
)
.
append
(
"
time
=
"
)
.
append
(
event
.
getEventTime
(
)
)
.
append
(
"
"
)
.
append
(
"
repeatCount
=
"
)
.
append
(
event
.
getRepeatCount
(
)
)
.
append
(
"
)
"
)
;
Log
.
d
(
LOGTAG
sb
.
toString
(
)
)
;
}
if
(
!
binderCheckToken
(
token
true
)
)
{
return
;
}
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
mListener
.
onDefaultKeyEvent
(
event
)
;
}
}
)
;
}
Override
public
void
updateCompositionRects
(
final
IBinder
token
final
RectF
[
]
rects
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
updateCompositionRects
(
rects
.
length
=
"
+
rects
.
length
+
"
)
"
)
;
}
if
(
!
binderCheckToken
(
token
false
)
)
{
return
;
}
mIcPostHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
mListener
.
updateCompositionRects
(
rects
)
;
}
}
)
;
}
static
String
getConstantName
(
Class
<
?
>
cls
String
prefix
Object
value
)
{
for
(
Field
fld
:
cls
.
getDeclaredFields
(
)
)
{
try
{
if
(
fld
.
getName
(
)
.
startsWith
(
prefix
)
&
&
fld
.
get
(
null
)
.
equals
(
value
)
)
{
return
fld
.
getName
(
)
;
}
}
catch
(
IllegalAccessException
e
)
{
}
}
return
String
.
valueOf
(
value
)
;
}
private
static
String
getPrintableChar
(
char
chr
)
{
if
(
chr
>
=
0x20
&
&
chr
<
=
0x7e
)
{
return
String
.
valueOf
(
chr
)
;
}
else
if
(
chr
=
=
'
\
n
'
)
{
return
"
\
u21b2
"
;
}
return
String
.
format
(
"
%
04x
"
(
int
)
chr
)
;
}
static
StringBuilder
debugAppend
(
StringBuilder
sb
Object
obj
)
{
if
(
obj
=
=
null
)
{
sb
.
append
(
"
null
"
)
;
}
else
if
(
obj
instanceof
GeckoEditable
)
{
sb
.
append
(
"
GeckoEditable
"
)
;
}
else
if
(
obj
instanceof
GeckoEditableChild
)
{
sb
.
append
(
"
GeckoEditableChild
"
)
;
}
else
if
(
Proxy
.
isProxyClass
(
obj
.
getClass
(
)
)
)
{
debugAppend
(
sb
Proxy
.
getInvocationHandler
(
obj
)
)
;
}
else
if
(
obj
instanceof
Character
)
{
sb
.
append
(
'
\
'
'
)
.
append
(
getPrintableChar
(
(
Character
)
obj
)
)
.
append
(
'
\
'
'
)
;
}
else
if
(
obj
instanceof
CharSequence
)
{
final
String
str
=
obj
.
toString
(
)
;
sb
.
append
(
'
"
'
)
;
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
+
+
)
{
final
char
chr
=
str
.
charAt
(
i
)
;
if
(
chr
>
=
0x20
&
&
chr
<
=
0x7e
)
{
sb
.
append
(
chr
)
;
}
else
{
sb
.
append
(
getPrintableChar
(
chr
)
)
;
}
}
sb
.
append
(
'
"
'
)
;
}
else
if
(
obj
.
getClass
(
)
.
isArray
(
)
)
{
sb
.
append
(
obj
.
getClass
(
)
.
getComponentType
(
)
.
getSimpleName
(
)
)
.
append
(
'
[
'
)
.
append
(
Array
.
getLength
(
obj
)
)
.
append
(
'
]
'
)
;
}
else
{
sb
.
append
(
obj
)
;
}
return
sb
;
}
Override
public
Object
invoke
(
Object
proxy
Method
method
Object
[
]
args
)
throws
Throwable
{
Object
target
;
final
Class
<
?
>
methodInterface
=
method
.
getDeclaringClass
(
)
;
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
if
(
methodInterface
=
=
Editable
.
class
|
|
methodInterface
=
=
Appendable
.
class
|
|
methodInterface
=
=
Spannable
.
class
)
{
target
=
this
;
}
else
{
target
=
mText
.
getShadowText
(
)
;
}
final
Object
ret
=
method
.
invoke
(
target
args
)
;
if
(
DEBUG
)
{
StringBuilder
log
=
new
StringBuilder
(
method
.
getName
(
)
)
;
log
.
append
(
"
(
"
)
;
if
(
args
!
=
null
)
{
for
(
Object
arg
:
args
)
{
debugAppend
(
log
arg
)
.
append
(
"
"
)
;
}
if
(
args
.
length
>
0
)
{
log
.
setLength
(
log
.
length
(
)
-
2
)
;
}
}
if
(
method
.
getReturnType
(
)
.
equals
(
Void
.
TYPE
)
)
{
log
.
append
(
"
)
"
)
;
}
else
{
debugAppend
(
log
.
append
(
"
)
=
"
)
ret
)
;
}
Log
.
d
(
LOGTAG
log
.
toString
(
)
)
;
}
return
ret
;
}
Override
public
void
removeSpan
(
Object
what
)
{
if
(
what
=
=
null
)
{
return
;
}
if
(
what
=
=
Selection
.
SELECTION_START
|
|
what
=
=
Selection
.
SELECTION_END
)
{
Log
.
w
(
LOGTAG
"
selection
removed
with
removeSpan
(
)
"
)
;
}
icOfferAction
(
Action
.
newRemoveSpan
(
what
)
)
;
}
Override
public
void
setSpan
(
Object
what
int
start
int
end
int
flags
)
{
icOfferAction
(
Action
.
newSetSpan
(
what
start
end
flags
)
)
;
}
Override
public
Editable
append
(
CharSequence
text
)
{
return
replace
(
mProxy
.
length
(
)
mProxy
.
length
(
)
text
0
text
.
length
(
)
)
;
}
Override
public
Editable
append
(
CharSequence
text
int
start
int
end
)
{
return
replace
(
mProxy
.
length
(
)
mProxy
.
length
(
)
text
start
end
)
;
}
Override
public
Editable
append
(
char
text
)
{
return
replace
(
mProxy
.
length
(
)
mProxy
.
length
(
)
String
.
valueOf
(
text
)
0
1
)
;
}
Override
public
InputFilter
[
]
getFilters
(
)
{
return
mFilters
;
}
Override
public
void
setFilters
(
InputFilter
[
]
filters
)
{
mFilters
=
filters
;
}
Override
public
void
clearSpans
(
)
{
Log
.
w
(
LOGTAG
"
selection
cleared
with
clearSpans
(
)
"
)
;
icOfferAction
(
Action
.
newRemoveSpan
(
null
)
)
;
}
Override
public
Editable
replace
(
int
st
int
en
CharSequence
source
int
start
int
end
)
{
CharSequence
text
=
source
;
if
(
start
<
0
|
|
start
>
end
|
|
end
>
text
.
length
(
)
)
{
Log
.
e
(
LOGTAG
"
invalid
replace
offsets
:
"
+
start
+
"
to
"
+
end
+
"
length
:
"
+
text
.
length
(
)
)
;
throw
new
IllegalArgumentException
(
"
invalid
replace
offsets
"
)
;
}
if
(
start
!
=
0
|
|
end
!
=
text
.
length
(
)
)
{
text
=
text
.
subSequence
(
start
end
)
;
}
if
(
mFilters
!
=
null
)
{
for
(
int
i
=
0
;
i
<
mFilters
.
length
;
+
+
i
)
{
final
CharSequence
cs
=
mFilters
[
i
]
.
filter
(
text
0
text
.
length
(
)
mProxy
st
en
)
;
if
(
cs
!
=
null
)
{
text
=
cs
;
}
}
}
if
(
text
=
=
source
)
{
text
=
new
SpannableString
(
source
)
;
}
icOfferAction
(
Action
.
newReplaceText
(
text
Math
.
min
(
st
en
)
Math
.
max
(
st
en
)
)
)
;
return
mProxy
;
}
Override
public
void
clear
(
)
{
replace
(
0
mProxy
.
length
(
)
"
"
0
0
)
;
}
Override
public
Editable
delete
(
int
st
int
en
)
{
return
replace
(
st
en
"
"
0
0
)
;
}
Override
public
Editable
insert
(
int
where
CharSequence
text
int
start
int
end
)
{
return
replace
(
where
where
text
start
end
)
;
}
Override
public
Editable
insert
(
int
where
CharSequence
text
)
{
return
replace
(
where
where
text
0
text
.
length
(
)
)
;
}
Override
public
Editable
replace
(
int
st
int
en
CharSequence
text
)
{
return
replace
(
st
en
text
0
text
.
length
(
)
)
;
}
Override
public
void
getChars
(
int
start
int
end
char
[
]
dest
int
destoff
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
getSpanEnd
(
Object
tag
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
getSpanFlags
(
Object
tag
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
getSpanStart
(
Object
tag
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
<
T
>
T
[
]
getSpans
(
int
start
int
end
Class
<
T
>
type
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
SuppressWarnings
(
"
rawtypes
"
)
public
int
nextSpanTransition
(
int
start
int
limit
Class
type
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
char
charAt
(
int
index
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
length
(
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
CharSequence
subSequence
(
int
start
int
end
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
String
toString
(
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
}
