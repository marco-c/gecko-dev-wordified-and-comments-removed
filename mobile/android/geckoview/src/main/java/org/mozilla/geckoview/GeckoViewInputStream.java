package
org
.
mozilla
.
geckoview
;
import
android
.
util
.
Log
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
NonNull
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
channels
.
Channels
;
import
java
.
nio
.
channels
.
ReadableByteChannel
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
WrapForJNI
AnyThread
class
GeckoViewInputStream
{
private
static
final
String
LOGTAG
=
"
GeckoViewInputStream
"
;
private
static
final
int
BUFFER_SIZE
=
4096
;
protected
final
ByteBuffer
mBuffer
=
ByteBuffer
.
allocateDirect
(
BUFFER_SIZE
)
;
private
ReadableByteChannel
mChannel
;
private
InputStream
mIs
=
null
;
private
boolean
mMustGetData
=
true
;
private
int
mPos
=
0
;
private
int
mSize
;
protected
void
setInputStream
(
final
NonNull
InputStream
is
)
{
mIs
=
is
;
mChannel
=
Channels
.
newChannel
(
is
)
;
}
public
boolean
isClosed
(
)
{
return
mIs
=
=
null
;
}
public
int
available
(
)
{
if
(
mIs
=
=
null
|
|
mSize
=
=
-
1
)
{
return
0
;
}
try
{
return
Math
.
max
(
mIs
.
available
(
)
mMustGetData
?
0
:
mSize
-
mPos
)
;
}
catch
(
final
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
get
the
number
of
available
bytes
"
e
)
;
return
0
;
}
}
public
void
close
(
)
{
if
(
mIs
=
=
null
)
{
return
;
}
try
{
mChannel
.
close
(
)
;
}
catch
(
final
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
close
the
channel
"
e
)
;
}
finally
{
mChannel
=
null
;
}
try
{
mIs
.
close
(
)
;
}
catch
(
final
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
close
the
stream
"
e
)
;
}
finally
{
mIs
=
null
;
}
}
public
long
consumedData
(
final
int
length
)
{
mPos
+
=
length
;
if
(
mPos
>
=
mSize
)
{
mPos
=
0
;
mMustGetData
=
true
;
}
return
mPos
;
}
protected
boolean
checkHeaders
(
final
NonNull
byte
[
]
[
]
headers
)
throws
IOException
{
read
(
0
)
;
for
(
final
byte
[
]
header
:
headers
)
{
final
int
headerLength
=
header
.
length
;
if
(
mSize
<
headerLength
)
{
continue
;
}
int
i
=
0
;
for
(
;
i
<
headerLength
;
i
+
+
)
{
if
(
mBuffer
.
get
(
i
)
!
=
header
[
i
]
)
{
break
;
}
}
if
(
i
=
=
headerLength
)
{
return
true
;
}
}
return
false
;
}
WrapForJNI
(
exceptionMode
=
"
nsresult
"
)
public
int
read
(
final
long
aCount
)
throws
IOException
{
if
(
mIs
=
=
null
)
{
Log
.
e
(
LOGTAG
"
The
stream
is
closed
.
"
)
;
throw
new
IllegalStateException
(
"
Stream
is
closed
"
)
;
}
if
(
!
mMustGetData
)
{
return
(
int
)
Math
.
min
(
(
long
)
(
mSize
-
mPos
)
aCount
)
;
}
mMustGetData
=
false
;
mBuffer
.
clear
(
)
;
try
{
mSize
=
mChannel
.
read
(
mBuffer
)
;
}
catch
(
final
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
read
some
bytes
"
e
)
;
throw
e
;
}
if
(
mSize
=
=
-
1
)
{
return
-
1
;
}
return
(
int
)
Math
.
min
(
(
long
)
mSize
aCount
)
;
}
}
