package
org
.
mozilla
.
gecko
.
media
;
import
android
.
util
.
Log
;
import
com
.
google
.
android
.
exoplayer2
.
BaseRenderer
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
java
.
util
.
Iterator
;
public
abstract
class
GeckoHlsRendererBase
extends
BaseRenderer
{
protected
static
final
int
QUEUED_INPUT_SAMPLE_DURATION_THRESHOLD
=
1000000
;
protected
final
FormatHolder
mFormatHolder
=
new
FormatHolder
(
)
;
protected
boolean
DEBUG
;
protected
String
LOGTAG
;
protected
GeckoHlsPlayer
.
ComponentEventDispatcher
mPlayerEventDispatcher
;
protected
ConcurrentLinkedQueue
<
GeckoHLSSample
>
mDemuxedInputSamples
=
new
ConcurrentLinkedQueue
<
>
(
)
;
protected
ByteBuffer
mInputBuffer
=
null
;
protected
ArrayList
<
Format
>
mFormats
=
new
ArrayList
<
Format
>
(
)
;
protected
boolean
mInitialized
=
false
;
protected
boolean
mWaitingForData
=
true
;
protected
boolean
mInputStreamEnded
=
false
;
protected
long
mFirstSampleStartTime
=
Long
.
MIN_VALUE
;
protected
abstract
void
createInputBuffer
(
)
;
protected
abstract
void
handleReconfiguration
(
DecoderInputBuffer
bufferForRead
)
;
protected
abstract
void
handleFormatRead
(
DecoderInputBuffer
bufferForRead
)
;
protected
abstract
void
handleEndOfStream
(
DecoderInputBuffer
bufferForRead
)
;
protected
abstract
void
handleSamplePreparation
(
DecoderInputBuffer
bufferForRead
)
;
protected
abstract
void
resetRenderer
(
)
;
protected
abstract
boolean
clearInputSamplesQueue
(
)
;
protected
abstract
void
notifyPlayerInputFormatChanged
(
Format
newFormat
)
;
protected
void
assertTrue
(
boolean
condition
)
{
if
(
DEBUG
&
&
!
condition
)
{
throw
new
AssertionError
(
"
Expected
condition
to
be
true
"
)
;
}
}
public
GeckoHlsRendererBase
(
int
trackType
GeckoHlsPlayer
.
ComponentEventDispatcher
eventDispatcher
)
{
super
(
trackType
)
;
mPlayerEventDispatcher
=
eventDispatcher
;
}
private
boolean
isQueuedEnoughData
(
)
{
if
(
mDemuxedInputSamples
.
isEmpty
(
)
)
{
return
false
;
}
Iterator
<
GeckoHLSSample
>
iter
=
mDemuxedInputSamples
.
iterator
(
)
;
long
firstPTS
=
0
;
if
(
iter
.
hasNext
(
)
)
{
GeckoHLSSample
sample
=
iter
.
next
(
)
;
firstPTS
=
sample
.
info
.
presentationTimeUs
;
}
long
lastPTS
=
firstPTS
;
while
(
iter
.
hasNext
(
)
)
{
GeckoHLSSample
sample
=
iter
.
next
(
)
;
lastPTS
=
sample
.
info
.
presentationTimeUs
;
}
return
Math
.
abs
(
lastPTS
-
firstPTS
)
>
QUEUED_INPUT_SAMPLE_DURATION_THRESHOLD
;
}
public
Format
getFormat
(
int
index
)
{
assertTrue
(
index
>
=
0
)
;
Format
fmt
=
index
<
mFormats
.
size
(
)
?
mFormats
.
get
(
index
)
:
null
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
getFormat
:
index
=
"
+
index
+
"
format
:
"
+
fmt
)
;
}
return
fmt
;
}
public
long
getFirstSamplePTS
(
)
{
return
mFirstSampleStartTime
;
}
public
synchronized
ConcurrentLinkedQueue
<
GeckoHLSSample
>
getQueuedSamples
(
int
number
)
{
ConcurrentLinkedQueue
<
GeckoHLSSample
>
samples
=
new
ConcurrentLinkedQueue
<
GeckoHLSSample
>
(
)
;
int
queuedSize
=
mDemuxedInputSamples
.
size
(
)
;
for
(
int
i
=
0
;
i
<
queuedSize
;
i
+
+
)
{
if
(
i
>
=
number
)
{
break
;
}
GeckoHLSSample
sample
=
mDemuxedInputSamples
.
poll
(
)
;
samples
.
offer
(
sample
)
;
}
if
(
samples
.
isEmpty
(
)
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
getQueuedSamples
isEmpty
mWaitingForData
=
true
!
"
)
;
}
mWaitingForData
=
true
;
}
else
if
(
mFirstSampleStartTime
=
=
Long
.
MIN_VALUE
)
{
mFirstSampleStartTime
=
samples
.
peek
(
)
.
info
.
presentationTimeUs
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
mFirstSampleStartTime
=
"
+
mFirstSampleStartTime
)
;
}
}
return
samples
;
}
protected
void
handleDrmInitChanged
(
Format
oldFormat
Format
newFormat
)
{
Object
oldDrmInit
=
oldFormat
=
=
null
?
null
:
oldFormat
.
drmInitData
;
Object
newDrnInit
=
newFormat
.
drmInitData
;
if
(
newDrnInit
!
=
oldDrmInit
)
{
if
(
newDrnInit
!
=
null
)
{
}
else
{
}
}
}
protected
boolean
canReconfigure
(
Format
oldFormat
Format
newFormat
)
{
return
false
;
}
protected
void
prepareReconfiguration
(
)
{
}
protected
void
updateCSDInfo
(
Format
format
)
{
}
protected
void
onInputFormatChanged
(
Format
newFormat
)
{
Format
oldFormat
;
try
{
oldFormat
=
mFormats
.
get
(
mFormats
.
size
(
)
-
1
)
;
}
catch
(
IndexOutOfBoundsException
e
)
{
oldFormat
=
null
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
[
onInputFormatChanged
]
old
:
"
+
oldFormat
+
"
=
>
new
:
"
+
newFormat
)
;
}
mFormats
.
add
(
newFormat
)
;
handleDrmInitChanged
(
oldFormat
newFormat
)
;
if
(
mInitialized
&
&
canReconfigure
(
oldFormat
newFormat
)
)
{
prepareReconfiguration
(
)
;
}
else
{
resetRenderer
(
)
;
maybeInitRenderer
(
)
;
}
updateCSDInfo
(
newFormat
)
;
notifyPlayerInputFormatChanged
(
newFormat
)
;
}
protected
void
maybeInitRenderer
(
)
{
if
(
mInitialized
|
|
mFormats
.
size
(
)
=
=
0
)
{
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Initializing
.
.
.
"
)
;
}
createInputBuffer
(
)
;
mInitialized
=
true
;
}
protected
synchronized
boolean
feedInputBuffersQueue
(
)
{
if
(
!
mInitialized
|
|
mInputStreamEnded
|
|
isQueuedEnoughData
(
)
)
{
return
false
;
}
DecoderInputBuffer
bufferForRead
=
new
DecoderInputBuffer
(
DecoderInputBuffer
.
BUFFER_REPLACEMENT_MODE_NORMAL
)
;
bufferForRead
.
data
=
mInputBuffer
;
if
(
bufferForRead
.
data
!
=
null
)
{
bufferForRead
.
clear
(
)
;
}
handleReconfiguration
(
bufferForRead
)
;
int
result
=
C
.
RESULT_NOTHING_READ
;
try
{
result
=
readSource
(
mFormatHolder
bufferForRead
false
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
[
feedInput
]
Exception
when
readSource
:
"
e
)
;
return
false
;
}
if
(
result
=
=
C
.
RESULT_NOTHING_READ
)
{
return
false
;
}
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
handleFormatRead
(
bufferForRead
)
;
return
true
;
}
if
(
bufferForRead
.
isEndOfStream
(
)
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Now
we
'
re
at
the
End
Of
Stream
.
"
)
;
}
handleEndOfStream
(
bufferForRead
)
;
return
false
;
}
bufferForRead
.
flip
(
)
;
handleSamplePreparation
(
bufferForRead
)
;
maybeNotifyDataArrived
(
)
;
return
true
;
}
private
void
maybeNotifyDataArrived
(
)
{
if
(
mWaitingForData
&
&
isQueuedEnoughData
(
)
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onDataArrived
"
)
;
}
mPlayerEventDispatcher
.
onDataArrived
(
getTrackType
(
)
)
;
mWaitingForData
=
false
;
}
}
private
void
readFormat
(
)
{
int
result
=
readSource
(
mFormatHolder
null
true
)
;
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
mFormatHolder
.
format
)
;
}
}
Override
protected
void
onEnabled
(
boolean
joining
)
{
}
Override
protected
void
onDisabled
(
)
{
mFormats
.
clear
(
)
;
resetRenderer
(
)
;
}
Override
public
boolean
isReady
(
)
{
return
mFormats
.
size
(
)
!
=
0
;
}
Override
public
boolean
isEnded
(
)
{
return
mInputStreamEnded
;
}
Override
protected
synchronized
void
onPositionReset
(
long
positionUs
boolean
joining
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onPositionReset
:
positionUs
=
"
+
positionUs
)
;
}
mInputStreamEnded
=
false
;
if
(
mInitialized
)
{
clearInputSamplesQueue
(
)
;
}
}
Override
public
void
render
(
long
positionUs
long
elapsedRealtimeUs
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
positionUs
=
"
+
positionUs
+
"
mInputStreamEnded
=
"
+
mInputStreamEnded
)
;
}
if
(
mInputStreamEnded
)
{
return
;
}
if
(
mFormats
.
size
(
)
=
=
0
)
{
readFormat
(
)
;
}
maybeInitRenderer
(
)
;
while
(
feedInputBuffersQueue
(
)
)
{
}
}
}
