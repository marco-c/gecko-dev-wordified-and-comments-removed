package
org
.
mozilla
.
gecko
.
util
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URL
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Resources
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
BitmapFactory
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
drawable
.
BitmapDrawable
;
import
android
.
graphics
.
drawable
.
Drawable
;
import
android
.
net
.
Uri
;
import
androidx
.
annotation
.
ColorInt
;
import
androidx
.
palette
.
graphics
.
Palette
;
import
android
.
util
.
Base64
;
import
android
.
util
.
Log
;
public
final
class
BitmapUtils
{
private
static
final
String
LOGTAG
=
"
GeckoBitmapUtils
"
;
private
BitmapUtils
(
)
{
}
public
static
Bitmap
decodeByteArray
(
final
byte
[
]
bytes
)
{
return
decodeByteArray
(
bytes
null
)
;
}
public
static
Bitmap
decodeByteArray
(
final
byte
[
]
bytes
final
BitmapFactory
.
Options
options
)
{
return
decodeByteArray
(
bytes
0
bytes
.
length
options
)
;
}
public
static
Bitmap
decodeByteArray
(
final
byte
[
]
bytes
final
int
offset
final
int
length
)
{
return
decodeByteArray
(
bytes
offset
length
null
)
;
}
public
static
Bitmap
decodeByteArray
(
final
byte
[
]
bytes
final
int
offset
final
int
length
final
BitmapFactory
.
Options
options
)
{
if
(
bytes
.
length
<
=
0
)
{
throw
new
IllegalArgumentException
(
"
bytes
.
length
"
+
bytes
.
length
+
"
must
be
a
positive
number
"
)
;
}
Bitmap
bitmap
=
null
;
try
{
bitmap
=
BitmapFactory
.
decodeByteArray
(
bytes
offset
length
options
)
;
}
catch
(
OutOfMemoryError
e
)
{
Log
.
e
(
LOGTAG
"
decodeByteArray
(
bytes
.
length
=
"
+
bytes
.
length
+
"
options
=
"
+
options
+
"
)
OOM
!
"
e
)
;
return
null
;
}
if
(
bitmap
=
=
null
)
{
Log
.
w
(
LOGTAG
"
decodeByteArray
(
)
returning
null
because
BitmapFactory
returned
null
"
)
;
return
null
;
}
if
(
bitmap
.
getWidth
(
)
<
=
0
|
|
bitmap
.
getHeight
(
)
<
=
0
)
{
Log
.
w
(
LOGTAG
"
decodeByteArray
(
)
returning
null
because
BitmapFactory
returned
"
+
"
a
bitmap
with
dimensions
"
+
bitmap
.
getWidth
(
)
+
"
x
"
+
bitmap
.
getHeight
(
)
)
;
return
null
;
}
return
bitmap
;
}
public
static
Bitmap
decodeStream
(
final
InputStream
inputStream
)
{
try
{
return
BitmapFactory
.
decodeStream
(
inputStream
)
;
}
catch
(
OutOfMemoryError
e
)
{
Log
.
e
(
LOGTAG
"
decodeStream
(
)
OOM
!
"
e
)
;
return
null
;
}
}
public
static
Bitmap
decodeUrl
(
final
Uri
uri
)
{
return
decodeUrl
(
uri
.
toString
(
)
)
;
}
public
static
Bitmap
decodeUrl
(
final
String
urlString
)
{
URL
url
;
try
{
url
=
new
URL
(
urlString
)
;
}
catch
(
MalformedURLException
e
)
{
Log
.
w
(
LOGTAG
"
decodeUrl
:
malformed
URL
"
+
urlString
)
;
return
null
;
}
return
decodeUrl
(
url
)
;
}
public
static
Bitmap
decodeUrl
(
final
URL
url
)
{
InputStream
stream
=
null
;
try
{
stream
=
url
.
openStream
(
)
;
}
catch
(
IOException
e
)
{
Log
.
w
(
LOGTAG
"
decodeUrl
:
IOException
downloading
"
+
url
)
;
return
null
;
}
if
(
stream
=
=
null
)
{
Log
.
w
(
LOGTAG
"
decodeUrl
:
stream
not
found
downloading
"
+
url
)
;
return
null
;
}
Bitmap
bitmap
=
decodeStream
(
stream
)
;
try
{
stream
.
close
(
)
;
}
catch
(
IOException
e
)
{
Log
.
w
(
LOGTAG
"
decodeUrl
:
IOException
closing
stream
"
+
url
e
)
;
}
return
bitmap
;
}
public
static
Bitmap
decodeResource
(
final
Context
context
final
int
id
)
{
return
decodeResource
(
context
id
null
)
;
}
public
static
Bitmap
decodeResource
(
final
Context
context
final
int
id
final
BitmapFactory
.
Options
options
)
{
Resources
resources
=
context
.
getResources
(
)
;
try
{
return
BitmapFactory
.
decodeResource
(
resources
id
options
)
;
}
catch
(
OutOfMemoryError
e
)
{
Log
.
e
(
LOGTAG
"
decodeResource
(
)
OOM
!
Resource
id
=
"
+
id
e
)
;
return
null
;
}
}
public
static
ColorInt
int
getDominantColor
(
final
Bitmap
source
final
ColorInt
int
defaultColor
)
{
if
(
HardwareUtils
.
isX86System
(
)
)
{
return
getDominantColorCustomImplementation
(
source
true
defaultColor
)
;
}
else
{
try
{
final
Palette
palette
=
Palette
.
from
(
source
)
.
generate
(
)
;
return
palette
.
getVibrantColor
(
defaultColor
)
;
}
catch
(
ArrayIndexOutOfBoundsException
e
)
{
Log
.
e
(
LOGTAG
"
Palette
generation
failed
with
ArrayIndexOutOfBoundsException
"
e
)
;
return
defaultColor
;
}
}
}
public
static
ColorInt
int
getDominantColorCustomImplementation
(
final
Bitmap
source
)
{
return
getDominantColorCustomImplementation
(
source
true
Color
.
WHITE
)
;
}
public
static
ColorInt
int
getDominantColorCustomImplementation
(
final
Bitmap
source
final
boolean
applyThreshold
final
ColorInt
int
defaultColor
)
{
if
(
source
=
=
null
)
{
return
defaultColor
;
}
int
[
]
colorBins
=
new
int
[
36
]
;
int
maxBin
=
-
1
;
float
[
]
sumHue
=
new
float
[
36
]
;
float
[
]
sumSat
=
new
float
[
36
]
;
float
[
]
sumVal
=
new
float
[
36
]
;
float
[
]
hsv
=
new
float
[
3
]
;
int
height
=
source
.
getHeight
(
)
;
int
width
=
source
.
getWidth
(
)
;
int
[
]
pixels
=
new
int
[
width
*
height
]
;
source
.
getPixels
(
pixels
0
width
0
0
width
height
)
;
for
(
int
row
=
0
;
row
<
height
;
row
+
+
)
{
for
(
int
col
=
0
;
col
<
width
;
col
+
+
)
{
int
c
=
pixels
[
col
+
row
*
width
]
;
if
(
Color
.
alpha
(
c
)
<
128
)
continue
;
Color
.
colorToHSV
(
c
hsv
)
;
if
(
applyThreshold
&
&
(
hsv
[
1
]
<
=
0
.
35f
|
|
hsv
[
2
]
<
=
0
.
35f
)
)
continue
;
int
bin
=
(
int
)
Math
.
floor
(
hsv
[
0
]
/
10
.
0f
)
;
sumHue
[
bin
]
=
sumHue
[
bin
]
+
hsv
[
0
]
;
sumSat
[
bin
]
=
sumSat
[
bin
]
+
hsv
[
1
]
;
sumVal
[
bin
]
=
sumVal
[
bin
]
+
hsv
[
2
]
;
colorBins
[
bin
]
+
+
;
if
(
maxBin
<
0
|
|
colorBins
[
bin
]
>
colorBins
[
maxBin
]
)
maxBin
=
bin
;
}
}
if
(
maxBin
<
0
)
{
return
defaultColor
;
}
hsv
[
0
]
=
sumHue
[
maxBin
]
/
colorBins
[
maxBin
]
;
hsv
[
1
]
=
sumSat
[
maxBin
]
/
colorBins
[
maxBin
]
;
hsv
[
2
]
=
sumVal
[
maxBin
]
/
colorBins
[
maxBin
]
;
return
Color
.
HSVToColor
(
hsv
)
;
}
public
static
Bitmap
getBitmapFromDataURI
(
final
String
dataURI
)
{
if
(
dataURI
=
=
null
)
{
return
null
;
}
byte
[
]
raw
=
getBytesFromDataURI
(
dataURI
)
;
if
(
raw
=
=
null
|
|
raw
.
length
=
=
0
)
{
return
null
;
}
return
decodeByteArray
(
raw
)
;
}
public
static
byte
[
]
getBytesFromBase64
(
final
String
base64
)
{
try
{
return
Base64
.
decode
(
base64
Base64
.
DEFAULT
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
exception
decoding
bitmap
from
data
URI
:
"
+
base64
e
)
;
}
return
null
;
}
public
static
byte
[
]
getBytesFromDataURI
(
final
String
dataURI
)
{
final
String
base64
=
dataURI
.
substring
(
dataURI
.
indexOf
(
'
'
)
+
1
)
;
return
getBytesFromBase64
(
base64
)
;
}
public
static
Bitmap
getBitmapFromDrawable
(
final
Drawable
drawable
)
{
if
(
drawable
instanceof
BitmapDrawable
)
{
return
(
(
BitmapDrawable
)
drawable
)
.
getBitmap
(
)
;
}
int
width
=
drawable
.
getIntrinsicWidth
(
)
;
width
=
width
>
0
?
width
:
1
;
int
height
=
drawable
.
getIntrinsicHeight
(
)
;
height
=
height
>
0
?
height
:
1
;
Bitmap
bitmap
=
Bitmap
.
createBitmap
(
width
height
Bitmap
.
Config
.
ARGB_8888
)
;
Canvas
canvas
=
new
Canvas
(
bitmap
)
;
drawable
.
setBounds
(
0
0
canvas
.
getWidth
(
)
canvas
.
getHeight
(
)
)
;
drawable
.
draw
(
canvas
)
;
return
bitmap
;
}
public
static
int
getResource
(
final
Context
context
final
Uri
resourceUrl
)
{
final
String
scheme
=
resourceUrl
.
getScheme
(
)
;
if
(
!
"
drawable
"
.
equals
(
scheme
)
)
{
return
android
.
R
.
drawable
.
sym_def_app_icon
;
}
String
resource
=
resourceUrl
.
getSchemeSpecificPart
(
)
;
if
(
resource
.
startsWith
(
"
/
/
"
)
)
{
resource
=
resource
.
substring
(
2
)
;
}
final
Resources
res
=
context
.
getResources
(
)
;
int
id
=
res
.
getIdentifier
(
resource
"
drawable
"
context
.
getPackageName
(
)
)
;
if
(
id
!
=
0
)
{
return
id
;
}
id
=
res
.
getIdentifier
(
resource
"
drawable
"
"
android
"
)
;
if
(
id
!
=
0
)
{
return
id
;
}
Log
.
w
(
LOGTAG
"
Cannot
find
drawable
/
"
+
resource
)
;
return
android
.
R
.
drawable
.
sym_def_app_icon
;
}
}
