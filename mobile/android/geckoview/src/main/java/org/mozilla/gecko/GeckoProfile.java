package
org
.
mozilla
.
gecko
;
import
android
.
content
.
Context
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
WorkerThread
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoMozillaDirectoryException
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoSuchProfileException
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
INIParser
;
import
org
.
mozilla
.
gecko
.
util
.
INISection
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
UUID
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
final
class
GeckoProfile
{
private
static
final
String
LOGTAG
=
"
GeckoProfile
"
;
private
static
final
String
CLIENT_ID_FILE_PATH
=
"
datareporting
/
state
.
json
"
;
private
static
final
String
CLIENT_ID_JSON_ATTR
=
"
clientID
"
;
private
static
final
String
HAD_CANARY_CLIENT_ID_JSON_ATTR
=
"
wasCanary
"
;
private
static
final
String
CANARY_CLIENT_ID
=
"
c0ffeec0
-
ffee
-
c0ff
-
eec0
-
ffeec0ffeec0
"
;
private
static
final
String
TIMES_PATH
=
"
times
.
json
"
;
private
static
volatile
boolean
sAcceptDirectoryChanges
=
true
;
public
static
final
String
DEFAULT_PROFILE
=
"
default
"
;
public
static
final
String
CUSTOM_PROFILE
=
"
"
;
private
static
final
ConcurrentHashMap
<
String
GeckoProfile
>
sProfileCache
=
new
ConcurrentHashMap
<
String
GeckoProfile
>
(
4
0
.
75f
2
)
;
private
static
String
sDefaultProfileName
;
private
static
String
sIntentArgs
;
private
final
String
mName
;
private
final
File
mMozillaDir
;
private
Object
mData
;
private
File
mProfileDir
;
public
static
GeckoProfile
initFromArgs
(
final
Context
context
final
String
args
)
{
String
profileName
=
null
;
String
profilePath
=
null
;
if
(
args
!
=
null
&
&
args
.
contains
(
"
-
P
"
)
)
{
final
Pattern
p
=
Pattern
.
compile
(
"
(
?
:
-
P
\
\
s
*
)
(
\
\
w
*
)
(
\
\
s
*
)
"
)
;
final
Matcher
m
=
p
.
matcher
(
args
)
;
if
(
m
.
find
(
)
)
{
profileName
=
m
.
group
(
1
)
;
}
}
if
(
args
!
=
null
&
&
args
.
contains
(
"
-
profile
"
)
)
{
final
Pattern
p
=
Pattern
.
compile
(
"
(
?
:
-
profile
\
\
s
*
)
(
\
\
S
*
)
(
\
\
s
*
)
"
)
;
final
Matcher
m
=
p
.
matcher
(
args
)
;
if
(
m
.
find
(
)
)
{
profilePath
=
m
.
group
(
1
)
;
}
}
if
(
TextUtils
.
isEmpty
(
profileName
)
&
&
profilePath
=
=
null
)
{
informIfCustomProfileIsUnavailable
(
profileName
false
)
;
return
getDefaultProfile
(
context
)
;
}
return
GeckoProfile
.
get
(
context
profileName
profilePath
)
;
}
private
static
GeckoProfile
getDefaultProfile
(
final
Context
context
)
{
try
{
return
get
(
context
getDefaultProfileName
(
context
)
)
;
}
catch
(
final
NoMozillaDirectoryException
e
)
{
Log
.
wtf
(
LOGTAG
"
Unable
to
get
default
profile
name
.
"
e
)
;
throw
new
RuntimeException
(
e
)
;
}
}
public
static
GeckoProfile
get
(
final
Context
context
final
String
profileName
)
{
if
(
profileName
!
=
null
)
{
GeckoProfile
profile
=
sProfileCache
.
get
(
profileName
)
;
if
(
profile
!
=
null
)
return
profile
;
}
return
get
(
context
profileName
(
File
)
null
)
;
}
RobocopTarget
public
static
GeckoProfile
get
(
final
Context
context
final
String
profileName
final
String
profilePath
)
{
File
dir
=
null
;
if
(
!
TextUtils
.
isEmpty
(
profilePath
)
)
{
dir
=
new
File
(
profilePath
)
;
if
(
!
dir
.
exists
(
)
|
|
!
dir
.
isDirectory
(
)
)
{
Log
.
w
(
LOGTAG
"
requested
profile
directory
missing
:
"
+
profilePath
)
;
}
}
return
get
(
context
profileName
dir
)
;
}
RobocopTarget
public
static
GeckoProfile
get
(
final
Context
context
final
String
profileName
final
File
profileDir
)
{
if
(
context
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
context
must
be
non
-
null
"
)
;
}
String
resolvedProfileName
=
profileName
;
if
(
TextUtils
.
isEmpty
(
profileName
)
&
&
profileDir
=
=
null
)
{
final
GeckoProfile
profile
=
GeckoThread
.
getActiveProfile
(
)
;
if
(
profile
!
=
null
)
{
informIfCustomProfileIsUnavailable
(
profileName
true
)
;
return
profile
;
}
informIfCustomProfileIsUnavailable
(
profileName
false
)
;
return
GeckoProfile
.
initFromArgs
(
context
sIntentArgs
)
;
}
else
if
(
profileName
=
=
null
)
{
resolvedProfileName
=
CUSTOM_PROFILE
;
}
final
boolean
init
=
profileDir
!
=
null
&
&
profileDir
.
mkdirs
(
)
;
if
(
init
)
{
Log
.
d
(
LOGTAG
"
Creating
profile
directory
:
"
+
profileDir
)
;
}
GeckoProfile
profile
=
sProfileCache
.
get
(
resolvedProfileName
)
;
GeckoProfile
newProfile
=
null
;
if
(
profile
=
=
null
)
{
try
{
Log
.
d
(
LOGTAG
"
Loading
profile
at
:
"
+
profileDir
+
"
name
:
"
+
resolvedProfileName
)
;
newProfile
=
new
GeckoProfile
(
context
resolvedProfileName
profileDir
)
;
}
catch
(
NoMozillaDirectoryException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
profile
=
sProfileCache
.
putIfAbsent
(
resolvedProfileName
newProfile
)
;
}
if
(
profile
=
=
null
)
{
profile
=
newProfile
;
}
else
if
(
profileDir
!
=
null
)
{
boolean
consistent
=
false
;
try
{
consistent
=
profile
.
mProfileDir
!
=
null
&
&
profile
.
mProfileDir
.
getCanonicalPath
(
)
.
equals
(
profileDir
.
getCanonicalPath
(
)
)
;
}
catch
(
final
IOException
e
)
{
}
if
(
!
consistent
)
{
if
(
!
sAcceptDirectoryChanges
|
|
!
profileDir
.
isDirectory
(
)
)
{
throw
new
IllegalStateException
(
"
Refusing
to
reuse
profile
with
a
different
directory
.
"
)
;
}
profile
.
setDir
(
profileDir
)
;
}
}
if
(
init
)
{
profile
.
enqueueInitialization
(
profileDir
)
;
}
return
profile
;
}
private
static
void
informIfCustomProfileIsUnavailable
(
final
String
profileName
final
boolean
activeOrDefaultProfileFallback
)
{
if
(
CUSTOM_PROFILE
.
equals
(
profileName
)
)
{
final
String
fallbackProfileName
=
activeOrDefaultProfileFallback
?
"
active
"
:
"
default
"
;
Log
.
w
(
LOGTAG
String
.
format
(
"
Custom
profile
must
have
a
directory
specified
!
"
+
"
Reverting
to
use
the
%
s
profile
"
fallbackProfileName
)
)
;
}
}
private
GeckoProfile
(
final
Context
context
final
String
profileName
final
File
profileDir
)
throws
NoMozillaDirectoryException
{
if
(
profileName
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Unable
to
create
GeckoProfile
for
empty
profile
name
.
"
)
;
}
mName
=
profileName
;
mMozillaDir
=
GeckoProfileDirectories
.
getMozillaDirectory
(
context
)
;
mProfileDir
=
profileDir
;
if
(
profileDir
!
=
null
)
{
if
(
!
profileDir
.
isDirectory
(
)
)
{
throw
new
IllegalArgumentException
(
"
Profile
directory
must
exist
if
specified
:
"
+
profileDir
.
getPath
(
)
)
;
}
FileWriter
fileWriter
=
null
;
try
{
fileWriter
=
new
FileWriter
(
new
File
(
profileDir
"
.
can
-
write
-
sentinel
"
)
false
)
;
fileWriter
.
write
(
0
)
;
}
catch
(
IOException
e
)
{
throw
new
IllegalArgumentException
(
"
Profile
directory
must
be
writable
if
specified
:
"
+
profileDir
.
getPath
(
)
e
)
;
}
finally
{
try
{
if
(
fileWriter
!
=
null
)
{
fileWriter
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
closing
.
can
-
write
-
sentinel
;
ignoring
"
e
)
;
}
}
}
}
private
void
setDir
(
final
File
dir
)
{
if
(
dir
!
=
null
&
&
dir
.
exists
(
)
&
&
dir
.
isDirectory
(
)
)
{
synchronized
(
this
)
{
mProfileDir
=
dir
;
}
}
}
RobocopTarget
public
String
getName
(
)
{
return
mName
;
}
public
boolean
isCustomProfile
(
)
{
return
CUSTOM_PROFILE
.
equals
(
mName
)
;
}
public
Object
getLock
(
)
{
return
this
;
}
RobocopTarget
public
synchronized
File
getDir
(
)
{
forceCreateLocked
(
)
;
return
mProfileDir
;
}
private
void
forceCreateLocked
(
)
{
if
(
mProfileDir
!
=
null
)
{
return
;
}
try
{
try
{
mProfileDir
=
findProfileDir
(
)
;
Log
.
d
(
LOGTAG
"
Found
profile
dir
:
"
+
mProfileDir
)
;
}
catch
(
NoSuchProfileException
noSuchProfile
)
{
mProfileDir
=
createProfileDir
(
)
;
Log
.
d
(
LOGTAG
"
Creating
profile
dir
:
"
+
mProfileDir
)
;
}
}
catch
(
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Error
getting
profile
dir
"
ioe
)
;
}
}
public
File
getFile
(
final
String
aFile
)
{
File
f
=
getDir
(
)
;
if
(
f
=
=
null
)
return
null
;
return
new
File
(
f
aFile
)
;
}
protected
static
String
generateNewClientId
(
)
{
return
UUID
.
randomUUID
(
)
.
toString
(
)
;
}
WorkerThread
private
void
persistNewClientId
(
Nullable
final
String
oldClientId
NonNull
final
String
newClientId
)
throws
IOException
{
if
(
!
ensureParentDirs
(
CLIENT_ID_FILE_PATH
)
)
{
throw
new
IOException
(
"
Could
not
create
client
ID
parent
directories
"
)
;
}
final
JSONObject
obj
=
new
JSONObject
(
)
;
try
{
obj
.
put
(
CLIENT_ID_JSON_ATTR
newClientId
)
;
obj
.
put
(
HAD_CANARY_CLIENT_ID_JSON_ATTR
isCanaryClientId
(
oldClientId
)
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Could
not
create
client
ID
JSON
object
"
e
)
;
}
Log
.
d
(
LOGTAG
"
Attempting
to
write
new
client
ID
properties
"
)
;
writeFile
(
CLIENT_ID_FILE_PATH
obj
.
toString
(
)
)
;
}
private
static
boolean
isCanaryClientId
(
Nullable
final
String
clientId
)
{
return
CANARY_CLIENT_ID
.
equals
(
clientId
)
;
}
WorkerThread
protected
boolean
ensureParentDirs
(
final
String
filename
)
{
final
File
file
=
new
File
(
getDir
(
)
filename
)
;
final
File
parentFile
=
file
.
getParentFile
(
)
;
return
parentFile
.
mkdirs
(
)
|
|
parentFile
.
isDirectory
(
)
;
}
public
void
writeFile
(
final
String
filename
final
String
data
)
{
File
file
=
new
File
(
getDir
(
)
filename
)
;
BufferedWriter
bufferedWriter
=
null
;
try
{
bufferedWriter
=
new
BufferedWriter
(
new
FileWriter
(
file
false
)
)
;
bufferedWriter
.
write
(
data
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
write
to
file
"
e
)
;
}
finally
{
try
{
if
(
bufferedWriter
!
=
null
)
{
bufferedWriter
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
closing
writer
while
writing
to
file
"
e
)
;
}
}
}
public
static
String
getDefaultProfileName
(
final
Context
context
)
throws
NoMozillaDirectoryException
{
if
(
sDefaultProfileName
!
=
null
)
{
return
sDefaultProfileName
;
}
final
String
profileName
=
GeckoProfileDirectories
.
findDefaultProfileName
(
context
)
;
if
(
profileName
=
=
null
)
{
sDefaultProfileName
=
DEFAULT_PROFILE
;
return
DEFAULT_PROFILE
;
}
sDefaultProfileName
=
profileName
;
return
sDefaultProfileName
;
}
private
File
findProfileDir
(
)
throws
NoSuchProfileException
{
if
(
isCustomProfile
(
)
)
{
return
mProfileDir
;
}
return
GeckoProfileDirectories
.
findProfileDir
(
mMozillaDir
mName
)
;
}
WorkerThread
private
File
createProfileDir
(
)
throws
IOException
{
if
(
isCustomProfile
(
)
)
{
return
mProfileDir
;
}
INIParser
parser
=
GeckoProfileDirectories
.
getProfilesINI
(
mMozillaDir
)
;
String
saltedName
;
File
profileDir
;
do
{
saltedName
=
GeckoProfileDirectories
.
saltProfileName
(
mName
)
;
profileDir
=
new
File
(
mMozillaDir
saltedName
)
;
}
while
(
profileDir
.
exists
(
)
)
;
if
(
!
profileDir
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Unable
to
create
profile
.
"
)
;
}
Log
.
d
(
LOGTAG
"
Created
new
profile
dir
.
"
)
;
int
profileNum
=
0
;
boolean
isDefaultSet
=
false
;
INISection
profileSection
;
while
(
(
profileSection
=
parser
.
getSection
(
"
Profile
"
+
profileNum
)
)
!
=
null
)
{
profileNum
+
+
;
if
(
profileSection
.
getProperty
(
"
Default
"
)
!
=
null
)
{
isDefaultSet
=
true
;
}
}
profileSection
=
new
INISection
(
"
Profile
"
+
profileNum
)
;
profileSection
.
setProperty
(
"
Name
"
mName
)
;
profileSection
.
setProperty
(
"
IsRelative
"
1
)
;
profileSection
.
setProperty
(
"
Path
"
saltedName
)
;
if
(
parser
.
getSection
(
"
General
"
)
=
=
null
)
{
INISection
generalSection
=
new
INISection
(
"
General
"
)
;
generalSection
.
setProperty
(
"
StartWithLastProfile
"
1
)
;
parser
.
addSection
(
generalSection
)
;
}
if
(
!
isDefaultSet
)
{
profileSection
.
setProperty
(
"
Default
"
1
)
;
}
parser
.
addSection
(
profileSection
)
;
parser
.
write
(
)
;
enqueueInitialization
(
profileDir
)
;
try
{
FileOutputStream
stream
=
new
FileOutputStream
(
profileDir
.
getAbsolutePath
(
)
+
File
.
separator
+
TIMES_PATH
)
;
OutputStreamWriter
writer
=
new
OutputStreamWriter
(
stream
Charset
.
forName
(
"
UTF
-
8
"
)
)
;
try
{
writer
.
append
(
"
{
\
"
created
\
"
:
"
+
System
.
currentTimeMillis
(
)
+
"
}
\
n
"
)
;
}
finally
{
writer
.
close
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Couldn
'
t
write
"
+
TIMES_PATH
e
)
;
}
persistNewClientId
(
null
generateNewClientId
(
)
)
;
return
profileDir
;
}
RobocopTarget
public
void
enqueueInitialization
(
final
File
profileDir
)
{
Log
.
i
(
LOGTAG
"
Enqueuing
profile
init
.
"
)
;
final
GeckoBundle
message
=
new
GeckoBundle
(
2
)
;
message
.
putString
(
"
name
"
getName
(
)
)
;
message
.
putString
(
"
path
"
profileDir
.
getAbsolutePath
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Profile
:
Create
"
message
)
;
}
}
