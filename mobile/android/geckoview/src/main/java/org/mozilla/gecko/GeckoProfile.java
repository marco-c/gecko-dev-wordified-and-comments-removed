package
org
.
mozilla
.
gecko
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoMozillaDirectoryException
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoSuchProfileException
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
INIParser
;
import
org
.
mozilla
.
gecko
.
util
.
INISection
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
UUID
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
final
class
GeckoProfile
{
private
static
final
String
LOGTAG
=
"
GeckoProfile
"
;
private
static
final
String
CLIENT_ID_FILE_PATH
=
"
datareporting
/
state
.
json
"
;
private
static
final
String
CLIENT_ID_JSON_ATTR
=
"
clientID
"
;
private
static
final
String
HAD_CANARY_CLIENT_ID_JSON_ATTR
=
"
wasCanary
"
;
private
static
final
String
CANARY_CLIENT_ID
=
"
c0ffeec0
-
ffee
-
c0ff
-
eec0
-
ffeec0ffeec0
"
;
private
static
final
String
TIMES_PATH
=
"
times
.
json
"
;
private
static
final
String
PROFILE_CREATION_DATE_JSON_ATTR
=
"
created
"
;
private
static
volatile
boolean
sAcceptDirectoryChanges
=
true
;
RobocopTarget
public
static
void
enableDirectoryChanges
(
)
{
Log
.
w
(
LOGTAG
"
Directory
changes
should
only
be
enabled
for
tests
.
And
even
then
it
'
s
a
bad
idea
.
"
)
;
sAcceptDirectoryChanges
=
true
;
}
public
static
final
String
DEFAULT_PROFILE
=
"
default
"
;
public
static
final
String
CUSTOM_PROFILE
=
"
"
;
public
static
final
String
GUEST_PROFILE_DIR
=
"
guest
"
;
public
static
final
String
GUEST_MODE_PREF
=
"
guestMode
"
;
private
static
final
String
SESSION_FILE
=
"
sessionstore
.
js
"
;
private
static
final
String
SESSION_FILE_BACKUP
=
"
sessionstore
.
bak
"
;
private
static
final
String
SESSION_FILE_PREVIOUS
=
"
sessionstore
.
old
"
;
private
static
final
long
MAX_PREVIOUS_FILE_AGE
=
1000
*
3600
*
24
;
private
boolean
mOldSessionDataProcessed
=
false
;
private
static
final
ConcurrentHashMap
<
String
GeckoProfile
>
sProfileCache
=
new
ConcurrentHashMap
<
String
GeckoProfile
>
(
4
0
.
75f
2
)
;
private
static
String
sDefaultProfileName
;
private
static
String
sIntentArgs
;
private
final
String
mName
;
private
final
File
mMozillaDir
;
private
Object
mData
;
private
File
mProfileDir
;
private
Boolean
mInGuestMode
;
public
static
boolean
shouldUseGuestMode
(
final
Context
context
)
{
return
GeckoSharedPrefs
.
forApp
(
context
)
.
getBoolean
(
GUEST_MODE_PREF
false
)
;
}
public
static
void
enterGuestMode
(
final
Context
context
)
{
GeckoSharedPrefs
.
forApp
(
context
)
.
edit
(
)
.
putBoolean
(
GUEST_MODE_PREF
true
)
.
commit
(
)
;
}
public
static
void
leaveGuestMode
(
final
Context
context
)
{
GeckoSharedPrefs
.
forApp
(
context
)
.
edit
(
)
.
putBoolean
(
GUEST_MODE_PREF
false
)
.
commit
(
)
;
}
public
static
void
setIntentArgs
(
final
String
intentArgs
)
{
sIntentArgs
=
intentArgs
;
}
public
static
GeckoProfile
initFromArgs
(
final
Context
context
final
String
args
)
{
if
(
shouldUseGuestMode
(
context
)
)
{
final
GeckoProfile
guestProfile
=
getGuestProfile
(
context
)
;
if
(
guestProfile
!
=
null
)
{
return
guestProfile
;
}
leaveGuestMode
(
context
)
;
}
if
(
getGuestDir
(
context
)
.
isDirectory
(
)
)
{
final
GeckoProfile
guestProfile
=
getGuestProfile
(
context
)
;
if
(
guestProfile
!
=
null
)
{
removeProfile
(
context
guestProfile
)
;
}
}
String
profileName
=
null
;
String
profilePath
=
null
;
if
(
args
!
=
null
&
&
args
.
contains
(
"
-
P
"
)
)
{
final
Pattern
p
=
Pattern
.
compile
(
"
(
?
:
-
P
\
\
s
*
)
(
\
\
w
*
)
(
\
\
s
*
)
"
)
;
final
Matcher
m
=
p
.
matcher
(
args
)
;
if
(
m
.
find
(
)
)
{
profileName
=
m
.
group
(
1
)
;
}
}
if
(
args
!
=
null
&
&
args
.
contains
(
"
-
profile
"
)
)
{
final
Pattern
p
=
Pattern
.
compile
(
"
(
?
:
-
profile
\
\
s
*
)
(
\
\
S
*
)
(
\
\
s
*
)
"
)
;
final
Matcher
m
=
p
.
matcher
(
args
)
;
if
(
m
.
find
(
)
)
{
profilePath
=
m
.
group
(
1
)
;
}
}
if
(
TextUtils
.
isEmpty
(
profileName
)
&
&
profilePath
=
=
null
)
{
informIfCustomProfileIsUnavailable
(
profileName
false
)
;
return
getDefaultProfile
(
context
)
;
}
return
GeckoProfile
.
get
(
context
profileName
profilePath
)
;
}
private
static
GeckoProfile
getDefaultProfile
(
Context
context
)
{
try
{
return
get
(
context
getDefaultProfileName
(
context
)
)
;
}
catch
(
final
NoMozillaDirectoryException
e
)
{
Log
.
wtf
(
LOGTAG
"
Unable
to
get
default
profile
name
.
"
e
)
;
throw
new
RuntimeException
(
e
)
;
}
}
public
static
GeckoProfile
get
(
Context
context
)
{
return
get
(
context
null
(
File
)
null
)
;
}
public
static
GeckoProfile
get
(
Context
context
String
profileName
)
{
if
(
profileName
!
=
null
)
{
GeckoProfile
profile
=
sProfileCache
.
get
(
profileName
)
;
if
(
profile
!
=
null
)
return
profile
;
}
return
get
(
context
profileName
(
File
)
null
)
;
}
RobocopTarget
public
static
GeckoProfile
get
(
Context
context
String
profileName
String
profilePath
)
{
File
dir
=
null
;
if
(
!
TextUtils
.
isEmpty
(
profilePath
)
)
{
dir
=
new
File
(
profilePath
)
;
if
(
!
dir
.
exists
(
)
|
|
!
dir
.
isDirectory
(
)
)
{
Log
.
w
(
LOGTAG
"
requested
profile
directory
missing
:
"
+
profilePath
)
;
}
}
return
get
(
context
profileName
dir
)
;
}
RobocopTarget
public
static
GeckoProfile
get
(
Context
context
String
profileName
File
profileDir
)
{
if
(
context
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
context
must
be
non
-
null
"
)
;
}
if
(
TextUtils
.
isEmpty
(
profileName
)
&
&
profileDir
=
=
null
)
{
final
GeckoProfile
profile
=
GeckoThread
.
getActiveProfile
(
)
;
if
(
profile
!
=
null
)
{
informIfCustomProfileIsUnavailable
(
profileName
true
)
;
return
profile
;
}
informIfCustomProfileIsUnavailable
(
profileName
false
)
;
return
GeckoProfile
.
initFromArgs
(
context
sIntentArgs
)
;
}
else
if
(
profileName
=
=
null
)
{
profileName
=
CUSTOM_PROFILE
;
}
final
boolean
init
=
profileDir
!
=
null
&
&
profileDir
.
mkdirs
(
)
;
GeckoProfile
profile
=
sProfileCache
.
get
(
profileName
)
;
GeckoProfile
newProfile
=
null
;
if
(
profile
=
=
null
)
{
try
{
newProfile
=
new
GeckoProfile
(
context
profileName
profileDir
)
;
}
catch
(
NoMozillaDirectoryException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
profile
=
sProfileCache
.
putIfAbsent
(
profileName
newProfile
)
;
}
if
(
profile
=
=
null
)
{
profile
=
newProfile
;
}
else
if
(
profileDir
!
=
null
)
{
boolean
consistent
=
false
;
try
{
consistent
=
profile
.
mProfileDir
!
=
null
&
&
profile
.
mProfileDir
.
getCanonicalPath
(
)
.
equals
(
profileDir
.
getCanonicalPath
(
)
)
;
}
catch
(
final
IOException
e
)
{
}
if
(
!
consistent
)
{
if
(
!
sAcceptDirectoryChanges
|
|
!
profileDir
.
isDirectory
(
)
)
{
throw
new
IllegalStateException
(
"
Refusing
to
reuse
profile
with
a
different
directory
.
"
)
;
}
profile
.
setDir
(
profileDir
)
;
}
}
if
(
init
)
{
profile
.
enqueueInitialization
(
profileDir
)
;
}
return
profile
;
}
private
static
void
informIfCustomProfileIsUnavailable
(
final
String
profileName
final
boolean
activeOrDefaultProfileFallback
)
{
if
(
CUSTOM_PROFILE
.
equals
(
profileName
)
)
{
final
String
fallbackProfileName
=
activeOrDefaultProfileFallback
?
"
active
"
:
"
default
"
;
Log
.
w
(
LOGTAG
String
.
format
(
"
Custom
profile
must
have
a
directory
specified
!
"
+
"
Reverting
to
use
the
%
s
profile
"
fallbackProfileName
)
)
;
}
}
RobocopTarget
public
static
boolean
removeProfile
(
final
Context
context
final
GeckoProfile
profile
)
{
final
boolean
success
=
profile
.
remove
(
)
;
if
(
success
)
{
GeckoSharedPrefs
.
forProfileName
(
context
profile
.
getName
(
)
)
.
edit
(
)
.
clear
(
)
.
apply
(
)
;
}
return
success
;
}
private
static
File
getGuestDir
(
final
Context
context
)
{
return
context
.
getFileStreamPath
(
GUEST_PROFILE_DIR
)
;
}
RobocopTarget
public
static
GeckoProfile
getGuestProfile
(
final
Context
context
)
{
return
get
(
context
CUSTOM_PROFILE
getGuestDir
(
context
)
)
;
}
public
static
boolean
isGuestProfile
(
final
Context
context
final
String
profileName
final
File
profileDir
)
{
if
(
profileDir
=
=
null
|
|
!
CUSTOM_PROFILE
.
equals
(
profileName
)
)
{
return
false
;
}
try
{
return
profileDir
.
getCanonicalPath
(
)
.
equals
(
getGuestDir
(
context
)
.
getCanonicalPath
(
)
)
;
}
catch
(
final
IOException
e
)
{
return
false
;
}
}
private
GeckoProfile
(
Context
context
String
profileName
File
profileDir
)
throws
NoMozillaDirectoryException
{
if
(
profileName
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Unable
to
create
GeckoProfile
for
empty
profile
name
.
"
)
;
}
mName
=
profileName
;
mMozillaDir
=
GeckoProfileDirectories
.
getMozillaDirectory
(
context
)
;
mProfileDir
=
profileDir
;
if
(
profileDir
!
=
null
&
&
!
profileDir
.
isDirectory
(
)
)
{
throw
new
IllegalArgumentException
(
"
Profile
directory
must
exist
if
specified
.
"
)
;
}
}
public
Object
getData
(
)
{
return
mData
;
}
public
void
setData
(
final
Object
data
)
{
mData
=
data
;
}
private
void
setDir
(
File
dir
)
{
if
(
dir
!
=
null
&
&
dir
.
exists
(
)
&
&
dir
.
isDirectory
(
)
)
{
synchronized
(
this
)
{
mProfileDir
=
dir
;
mInGuestMode
=
null
;
}
}
}
RobocopTarget
public
String
getName
(
)
{
return
mName
;
}
public
boolean
isCustomProfile
(
)
{
return
CUSTOM_PROFILE
.
equals
(
mName
)
;
}
RobocopTarget
public
boolean
inGuestMode
(
)
{
if
(
mInGuestMode
=
=
null
)
{
mInGuestMode
=
isGuestProfile
(
GeckoAppShell
.
getApplicationContext
(
)
mName
mProfileDir
)
;
}
return
mInGuestMode
;
}
public
Object
getLock
(
)
{
return
this
;
}
RobocopTarget
public
synchronized
File
getDir
(
)
{
forceCreateLocked
(
)
;
return
mProfileDir
;
}
private
void
forceCreateLocked
(
)
{
if
(
mProfileDir
!
=
null
)
{
return
;
}
try
{
try
{
mProfileDir
=
findProfileDir
(
)
;
Log
.
d
(
LOGTAG
"
Found
profile
dir
.
"
)
;
}
catch
(
NoSuchProfileException
noSuchProfile
)
{
mProfileDir
=
createProfileDir
(
)
;
}
}
catch
(
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Error
getting
profile
dir
"
ioe
)
;
}
}
public
File
getFile
(
String
aFile
)
{
File
f
=
getDir
(
)
;
if
(
f
=
=
null
)
return
null
;
return
new
File
(
f
aFile
)
;
}
WorkerThread
public
String
getClientId
(
)
throws
IOException
{
String
clientId
=
"
"
;
try
{
clientId
=
getClientIdFromDisk
(
CLIENT_ID_FILE_PATH
)
;
}
catch
(
final
IOException
e
)
{
Log
.
d
(
LOGTAG
"
Could
not
get
client
ID
-
creating
a
new
one
:
"
+
e
.
getLocalizedMessage
(
)
)
;
}
if
(
isClientIdValid
(
clientId
)
)
{
return
clientId
;
}
else
{
String
newClientId
=
generateNewClientId
(
)
;
persistNewClientId
(
clientId
newClientId
)
;
}
return
getClientIdFromDisk
(
CLIENT_ID_FILE_PATH
)
;
}
WorkerThread
public
boolean
getIfHadCanaryClientId
(
)
throws
IOException
{
final
JSONObject
obj
=
readJSONObjectFromFile
(
CLIENT_ID_FILE_PATH
)
;
return
obj
.
optBoolean
(
HAD_CANARY_CLIENT_ID_JSON_ATTR
)
;
}
protected
static
String
generateNewClientId
(
)
{
return
UUID
.
randomUUID
(
)
.
toString
(
)
;
}
WorkerThread
private
String
getClientIdFromDisk
(
final
String
filePath
)
throws
IOException
{
final
JSONObject
obj
=
readJSONObjectFromFile
(
filePath
)
;
return
obj
.
optString
(
CLIENT_ID_JSON_ATTR
)
;
}
WorkerThread
private
void
persistNewClientId
(
Nullable
final
String
oldClientId
NonNull
final
String
newClientId
)
throws
IOException
{
if
(
!
ensureParentDirs
(
CLIENT_ID_FILE_PATH
)
)
{
throw
new
IOException
(
"
Could
not
create
client
ID
parent
directories
"
)
;
}
final
JSONObject
obj
=
new
JSONObject
(
)
;
try
{
obj
.
put
(
CLIENT_ID_JSON_ATTR
newClientId
)
;
obj
.
put
(
HAD_CANARY_CLIENT_ID_JSON_ATTR
isCanaryClientId
(
oldClientId
)
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Could
not
create
client
ID
JSON
object
"
e
)
;
}
Log
.
d
(
LOGTAG
"
Attempting
to
write
new
client
ID
properties
"
)
;
writeFile
(
CLIENT_ID_FILE_PATH
obj
.
toString
(
)
)
;
}
public
static
boolean
isClientIdValid
(
Nullable
final
String
clientId
)
{
if
(
TextUtils
.
isEmpty
(
clientId
)
)
{
return
false
;
}
if
(
CANARY_CLIENT_ID
.
equals
(
clientId
)
)
{
return
false
;
}
return
clientId
.
matches
(
"
(
?
i
:
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
)
"
)
;
}
private
static
boolean
isCanaryClientId
(
Nullable
final
String
clientId
)
{
return
CANARY_CLIENT_ID
.
equals
(
clientId
)
;
}
WorkerThread
public
long
getAndPersistProfileCreationDate
(
final
Context
context
)
{
try
{
return
getProfileCreationDateFromTimesFile
(
)
;
}
catch
(
final
IOException
e
)
{
Log
.
d
(
LOGTAG
"
Unable
to
retrieve
profile
creation
date
from
times
.
json
.
Getting
from
system
.
.
.
"
)
;
final
long
packageInstallMillis
=
org
.
mozilla
.
gecko
.
util
.
ContextUtils
.
getCurrentPackageInfo
(
context
)
.
firstInstallTime
;
try
{
persistProfileCreationDateToTimesFile
(
packageInstallMillis
)
;
}
catch
(
final
IOException
ioEx
)
{
Log
.
w
(
LOGTAG
"
Unable
to
persist
profile
creation
date
-
returning
-
1
"
)
;
return
-
1
;
}
return
packageInstallMillis
;
}
}
WorkerThread
private
long
getProfileCreationDateFromTimesFile
(
)
throws
IOException
{
final
JSONObject
obj
=
readJSONObjectFromFile
(
TIMES_PATH
)
;
try
{
return
obj
.
getLong
(
PROFILE_CREATION_DATE_JSON_ATTR
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Profile
creation
does
not
exist
in
JSONObject
"
)
;
}
}
WorkerThread
private
void
persistProfileCreationDateToTimesFile
(
final
long
profileCreationMillis
)
throws
IOException
{
final
JSONObject
obj
=
new
JSONObject
(
)
;
try
{
obj
.
put
(
PROFILE_CREATION_DATE_JSON_ATTR
profileCreationMillis
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Unable
to
persist
profile
creation
date
to
times
file
"
)
;
}
Log
.
d
(
LOGTAG
"
Attempting
to
write
new
profile
creation
date
"
)
;
writeFile
(
TIMES_PATH
obj
.
toString
(
)
)
;
}
public
void
updateSessionFile
(
boolean
shouldRestore
)
{
File
sessionFilePrevious
=
getFile
(
SESSION_FILE_PREVIOUS
)
;
if
(
!
shouldRestore
)
{
File
sessionFile
=
getFile
(
SESSION_FILE
)
;
if
(
sessionFile
!
=
null
&
&
sessionFile
.
exists
(
)
)
{
sessionFile
.
renameTo
(
sessionFilePrevious
)
;
}
}
else
{
if
(
sessionFilePrevious
!
=
null
&
&
sessionFilePrevious
.
exists
(
)
&
&
System
.
currentTimeMillis
(
)
-
sessionFilePrevious
.
lastModified
(
)
>
MAX_PREVIOUS_FILE_AGE
)
{
sessionFilePrevious
.
delete
(
)
;
}
}
synchronized
(
this
)
{
mOldSessionDataProcessed
=
true
;
notifyAll
(
)
;
}
}
public
void
waitForOldSessionDataProcessing
(
)
{
synchronized
(
this
)
{
while
(
!
mOldSessionDataProcessed
)
{
try
{
wait
(
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
}
}
public
String
readSessionFile
(
boolean
readBackup
)
{
return
readSessionFile
(
readBackup
?
SESSION_FILE_BACKUP
:
SESSION_FILE
)
;
}
public
String
readPreviousSessionFile
(
)
{
return
readSessionFile
(
SESSION_FILE_PREVIOUS
)
;
}
private
String
readSessionFile
(
String
fileName
)
{
File
sessionFile
=
getFile
(
fileName
)
;
try
{
if
(
sessionFile
!
=
null
&
&
sessionFile
.
exists
(
)
)
{
return
readFile
(
sessionFile
)
;
}
}
catch
(
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Unable
to
read
session
file
"
ioe
)
;
}
return
null
;
}
public
boolean
sessionFileExists
(
)
{
File
sessionFile
=
getFile
(
SESSION_FILE
)
;
return
sessionFile
!
=
null
&
&
sessionFile
.
exists
(
)
;
}
WorkerThread
protected
boolean
ensureParentDirs
(
final
String
filename
)
{
final
File
file
=
new
File
(
getDir
(
)
filename
)
;
final
File
parentFile
=
file
.
getParentFile
(
)
;
return
parentFile
.
mkdirs
(
)
|
|
parentFile
.
isDirectory
(
)
;
}
public
void
writeFile
(
final
String
filename
final
String
data
)
{
File
file
=
new
File
(
getDir
(
)
filename
)
;
BufferedWriter
bufferedWriter
=
null
;
try
{
bufferedWriter
=
new
BufferedWriter
(
new
FileWriter
(
file
false
)
)
;
bufferedWriter
.
write
(
data
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
write
to
file
"
e
)
;
}
finally
{
try
{
if
(
bufferedWriter
!
=
null
)
{
bufferedWriter
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
closing
writer
while
writing
to
file
"
e
)
;
}
}
}
WorkerThread
public
JSONObject
readJSONObjectFromFile
(
final
String
filename
)
throws
IOException
{
final
String
fileContents
;
try
{
fileContents
=
readFile
(
filename
)
;
}
catch
(
final
IOException
e
)
{
throw
new
IOException
(
"
Could
not
access
given
file
to
retrieve
JSONObject
"
)
;
}
try
{
return
new
JSONObject
(
fileContents
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Could
not
parse
JSON
to
retrieve
JSONObject
"
)
;
}
}
public
JSONArray
readJSONArrayFromFile
(
final
String
filename
)
{
String
fileContent
;
try
{
fileContent
=
readFile
(
filename
)
;
}
catch
(
IOException
expected
)
{
return
new
JSONArray
(
)
;
}
JSONArray
jsonArray
;
try
{
jsonArray
=
new
JSONArray
(
fileContent
)
;
}
catch
(
JSONException
e
)
{
jsonArray
=
new
JSONArray
(
)
;
}
return
jsonArray
;
}
public
String
readFile
(
String
filename
)
throws
IOException
{
File
dir
=
getDir
(
)
;
if
(
dir
=
=
null
)
{
throw
new
IOException
(
"
No
profile
directory
found
"
)
;
}
File
target
=
new
File
(
dir
filename
)
;
return
readFile
(
target
)
;
}
private
String
readFile
(
File
target
)
throws
IOException
{
FileReader
fr
=
new
FileReader
(
target
)
;
try
{
StringBuilder
sb
=
new
StringBuilder
(
)
;
char
[
]
buf
=
new
char
[
8192
]
;
int
read
=
fr
.
read
(
buf
)
;
while
(
read
>
=
0
)
{
sb
.
append
(
buf
0
read
)
;
read
=
fr
.
read
(
buf
)
;
}
return
sb
.
toString
(
)
;
}
finally
{
fr
.
close
(
)
;
}
}
public
boolean
deleteFileFromProfileDir
(
String
fileName
)
throws
IllegalArgumentException
{
if
(
TextUtils
.
isEmpty
(
fileName
)
)
{
throw
new
IllegalArgumentException
(
"
Filename
cannot
be
empty
.
"
)
;
}
File
file
=
new
File
(
getDir
(
)
fileName
)
;
return
file
.
delete
(
)
;
}
private
boolean
remove
(
)
{
try
{
synchronized
(
this
)
{
if
(
mProfileDir
!
=
null
&
&
mProfileDir
.
exists
(
)
)
{
FileUtils
.
delete
(
mProfileDir
)
;
}
if
(
isCustomProfile
(
)
)
{
return
true
;
}
try
{
findProfileDir
(
)
;
mProfileDir
=
null
;
}
catch
(
final
NoSuchProfileException
e
)
{
return
true
;
}
}
final
INIParser
parser
=
GeckoProfileDirectories
.
getProfilesINI
(
mMozillaDir
)
;
final
Hashtable
<
String
INISection
>
sections
=
parser
.
getSections
(
)
;
if
(
sections
=
=
null
)
{
return
false
;
}
for
(
Enumeration
<
INISection
>
e
=
sections
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
final
INISection
section
=
e
.
nextElement
(
)
;
String
name
=
section
.
getStringProperty
(
"
Name
"
)
;
if
(
name
=
=
null
|
|
!
name
.
equals
(
mName
)
)
{
continue
;
}
if
(
section
.
getName
(
)
.
startsWith
(
"
Profile
"
)
)
{
try
{
int
sectionNumber
=
Integer
.
parseInt
(
section
.
getName
(
)
.
substring
(
"
Profile
"
.
length
(
)
)
)
;
String
curSection
=
"
Profile
"
+
sectionNumber
;
String
nextSection
=
"
Profile
"
+
(
sectionNumber
+
1
)
;
sections
.
remove
(
curSection
)
;
while
(
sections
.
containsKey
(
nextSection
)
)
{
parser
.
renameSection
(
nextSection
curSection
)
;
sectionNumber
+
+
;
curSection
=
nextSection
;
nextSection
=
"
Profile
"
+
(
sectionNumber
+
1
)
;
}
}
catch
(
NumberFormatException
nex
)
{
Log
.
e
(
LOGTAG
"
Malformed
section
name
in
profiles
.
ini
:
"
+
section
.
getName
(
)
)
;
return
false
;
}
}
else
{
parser
.
removeSection
(
mName
)
;
}
break
;
}
parser
.
write
(
)
;
return
true
;
}
catch
(
IOException
ex
)
{
Log
.
w
(
LOGTAG
"
Failed
to
remove
profile
.
"
ex
)
;
return
false
;
}
}
public
static
String
getDefaultProfileName
(
final
Context
context
)
throws
NoMozillaDirectoryException
{
if
(
sDefaultProfileName
!
=
null
)
{
return
sDefaultProfileName
;
}
final
String
profileName
=
GeckoProfileDirectories
.
findDefaultProfileName
(
context
)
;
if
(
profileName
=
=
null
)
{
sDefaultProfileName
=
DEFAULT_PROFILE
;
return
DEFAULT_PROFILE
;
}
sDefaultProfileName
=
profileName
;
return
sDefaultProfileName
;
}
private
File
findProfileDir
(
)
throws
NoSuchProfileException
{
if
(
isCustomProfile
(
)
)
{
return
mProfileDir
;
}
return
GeckoProfileDirectories
.
findProfileDir
(
mMozillaDir
mName
)
;
}
WorkerThread
private
File
createProfileDir
(
)
throws
IOException
{
if
(
isCustomProfile
(
)
)
{
return
mProfileDir
;
}
INIParser
parser
=
GeckoProfileDirectories
.
getProfilesINI
(
mMozillaDir
)
;
String
saltedName
;
File
profileDir
;
do
{
saltedName
=
GeckoProfileDirectories
.
saltProfileName
(
mName
)
;
profileDir
=
new
File
(
mMozillaDir
saltedName
)
;
}
while
(
profileDir
.
exists
(
)
)
;
if
(
!
profileDir
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Unable
to
create
profile
.
"
)
;
}
Log
.
d
(
LOGTAG
"
Created
new
profile
dir
.
"
)
;
int
profileNum
=
0
;
boolean
isDefaultSet
=
false
;
INISection
profileSection
;
while
(
(
profileSection
=
parser
.
getSection
(
"
Profile
"
+
profileNum
)
)
!
=
null
)
{
profileNum
+
+
;
if
(
profileSection
.
getProperty
(
"
Default
"
)
!
=
null
)
{
isDefaultSet
=
true
;
}
}
profileSection
=
new
INISection
(
"
Profile
"
+
profileNum
)
;
profileSection
.
setProperty
(
"
Name
"
mName
)
;
profileSection
.
setProperty
(
"
IsRelative
"
1
)
;
profileSection
.
setProperty
(
"
Path
"
saltedName
)
;
if
(
parser
.
getSection
(
"
General
"
)
=
=
null
)
{
INISection
generalSection
=
new
INISection
(
"
General
"
)
;
generalSection
.
setProperty
(
"
StartWithLastProfile
"
1
)
;
parser
.
addSection
(
generalSection
)
;
}
if
(
!
isDefaultSet
)
{
profileSection
.
setProperty
(
"
Default
"
1
)
;
}
parser
.
addSection
(
profileSection
)
;
parser
.
write
(
)
;
enqueueInitialization
(
profileDir
)
;
try
{
FileOutputStream
stream
=
new
FileOutputStream
(
profileDir
.
getAbsolutePath
(
)
+
File
.
separator
+
TIMES_PATH
)
;
OutputStreamWriter
writer
=
new
OutputStreamWriter
(
stream
Charset
.
forName
(
"
UTF
-
8
"
)
)
;
try
{
writer
.
append
(
"
{
\
"
created
\
"
:
"
+
System
.
currentTimeMillis
(
)
+
"
}
\
n
"
)
;
}
finally
{
writer
.
close
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Couldn
'
t
write
"
+
TIMES_PATH
e
)
;
}
persistNewClientId
(
null
generateNewClientId
(
)
)
;
return
profileDir
;
}
RobocopTarget
public
void
enqueueInitialization
(
final
File
profileDir
)
{
Log
.
i
(
LOGTAG
"
Enqueuing
profile
init
.
"
)
;
final
GeckoBundle
message
=
new
GeckoBundle
(
2
)
;
message
.
putString
(
"
name
"
getName
(
)
)
;
message
.
putString
(
"
path
"
profileDir
.
getAbsolutePath
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Profile
:
Create
"
message
)
;
}
}
