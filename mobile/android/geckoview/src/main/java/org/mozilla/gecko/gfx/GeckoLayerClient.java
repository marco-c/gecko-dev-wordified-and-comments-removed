package
org
.
mozilla
.
gecko
.
gfx
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
.
DrawListener
;
import
org
.
mozilla
.
gecko
.
Tab
;
import
org
.
mozilla
.
gecko
.
Tabs
;
import
org
.
mozilla
.
gecko
.
ZoomConstraints
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
util
.
FloatUtils
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
PointF
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
android
.
view
.
InputDevice
;
import
android
.
view
.
MotionEvent
;
import
org
.
json
.
JSONObject
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
class
GeckoLayerClient
implements
LayerView
.
Listener
PanZoomTarget
{
private
static
final
String
LOGTAG
=
"
GeckoLayerClient
"
;
private
static
int
sPaintSyncId
=
1
;
private
LayerRenderer
mLayerRenderer
;
private
boolean
mLayerRendererInitialized
;
private
final
Context
mContext
;
private
IntSize
mScreenSize
;
private
IntSize
mWindowSize
;
private
DisplayPortMetrics
mDisplayPort
;
private
boolean
mRecordDrawTimes
;
private
final
DrawTimingQueue
mDrawTimingQueue
;
private
ImmutableViewportMetrics
mGeckoViewport
;
private
ImmutableViewportMetrics
mFrameMetrics
;
private
final
List
<
DrawListener
>
mDrawListeners
;
private
final
ViewTransform
mCurrentViewTransform
;
private
final
ProgressiveUpdateData
mProgressiveUpdateData
;
private
DisplayPortMetrics
mProgressiveUpdateDisplayPort
;
private
boolean
mLastProgressiveUpdateWasLowPrecision
;
private
boolean
mProgressiveUpdateWasInDanger
;
private
boolean
mForceRedraw
;
private
volatile
ImmutableViewportMetrics
mViewportMetrics
;
private
ZoomConstraints
mZoomConstraints
;
private
volatile
boolean
mGeckoIsReady
;
private
final
PanZoomController
mPanZoomController
;
private
final
DynamicToolbarAnimator
mToolbarAnimator
;
private
final
LayerView
mView
;
private
volatile
boolean
mContentDocumentIsDisplayed
;
private
SynthesizedEventState
mPointerState
;
public
GeckoLayerClient
(
Context
context
LayerView
view
EventDispatcher
eventDispatcher
)
{
mContext
=
context
;
mScreenSize
=
new
IntSize
(
0
0
)
;
mWindowSize
=
new
IntSize
(
0
0
)
;
mDisplayPort
=
new
DisplayPortMetrics
(
)
;
mRecordDrawTimes
=
true
;
mDrawTimingQueue
=
new
DrawTimingQueue
(
)
;
mCurrentViewTransform
=
new
ViewTransform
(
0
0
1
)
;
mProgressiveUpdateData
=
new
ProgressiveUpdateData
(
)
;
mProgressiveUpdateDisplayPort
=
new
DisplayPortMetrics
(
)
;
mForceRedraw
=
true
;
DisplayMetrics
displayMetrics
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
;
mViewportMetrics
=
new
ImmutableViewportMetrics
(
displayMetrics
)
.
setViewportSize
(
view
.
getWidth
(
)
view
.
getHeight
(
)
)
;
mZoomConstraints
=
new
ZoomConstraints
(
false
)
;
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
mZoomConstraints
=
tab
.
getZoomConstraints
(
)
;
mViewportMetrics
=
mViewportMetrics
.
setIsRTL
(
tab
.
getIsRTL
(
)
)
;
}
mFrameMetrics
=
mViewportMetrics
;
mDrawListeners
=
new
ArrayList
<
DrawListener
>
(
)
;
mToolbarAnimator
=
new
DynamicToolbarAnimator
(
this
)
;
mPanZoomController
=
PanZoomController
.
Factory
.
create
(
this
view
eventDispatcher
)
;
mView
=
view
;
mView
.
setListener
(
this
)
;
mContentDocumentIsDisplayed
=
true
;
}
public
void
setOverscrollHandler
(
final
Overscroll
listener
)
{
mPanZoomController
.
setOverscrollHandler
(
listener
)
;
}
Override
public
boolean
isGeckoReady
(
)
{
return
mGeckoIsReady
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
void
onGeckoReady
(
)
{
mGeckoIsReady
=
true
;
mLayerRenderer
=
mView
.
getRenderer
(
)
;
sendResizeEventIfNecessary
(
true
null
)
;
DisplayPortCalculator
.
initPrefs
(
)
;
mView
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mView
.
updateCompositor
(
)
;
}
}
)
;
}
public
void
destroy
(
)
{
mPanZoomController
.
destroy
(
)
;
mToolbarAnimator
.
destroy
(
)
;
mDrawListeners
.
clear
(
)
;
mGeckoIsReady
=
false
;
}
private
boolean
getRedrawHint
(
)
{
if
(
mForceRedraw
)
{
mForceRedraw
=
false
;
return
true
;
}
if
(
!
mPanZoomController
.
getRedrawHint
(
)
)
{
return
false
;
}
return
DisplayPortCalculator
.
aboutToCheckerboard
(
mViewportMetrics
mPanZoomController
.
getVelocityVector
(
)
mDisplayPort
)
;
}
public
LayerView
getView
(
)
{
return
mView
;
}
public
FloatSize
getViewportSize
(
)
{
return
mViewportMetrics
.
getSize
(
)
;
}
boolean
setViewportSize
(
int
width
int
height
PointF
scrollChange
)
{
if
(
mViewportMetrics
.
viewportRectWidth
=
=
width
&
&
mViewportMetrics
.
viewportRectHeight
=
=
height
&
&
(
scrollChange
=
=
null
|
|
(
scrollChange
.
x
=
=
0
&
&
scrollChange
.
y
=
=
0
)
)
)
{
return
false
;
}
mViewportMetrics
=
mViewportMetrics
.
setViewportSize
(
width
height
)
;
if
(
scrollChange
!
=
null
)
{
mViewportMetrics
=
mPanZoomController
.
adjustScrollForSurfaceShift
(
mViewportMetrics
scrollChange
)
;
}
if
(
mGeckoIsReady
)
{
sendResizeEventIfNecessary
(
true
scrollChange
)
;
GeckoAppShell
.
viewSizeChanged
(
)
;
}
return
true
;
}
PanZoomController
getPanZoomController
(
)
{
return
mPanZoomController
;
}
DynamicToolbarAnimator
getDynamicToolbarAnimator
(
)
{
return
mToolbarAnimator
;
}
private
void
sendResizeEventIfNecessary
(
boolean
force
PointF
scrollChange
)
{
DisplayMetrics
metrics
=
mContext
.
getResources
(
)
.
getDisplayMetrics
(
)
;
IntSize
newScreenSize
=
new
IntSize
(
metrics
.
widthPixels
metrics
.
heightPixels
)
;
IntSize
newWindowSize
=
new
IntSize
(
mViewportMetrics
.
viewportRectWidth
mViewportMetrics
.
viewportRectHeight
)
;
boolean
screenSizeChanged
=
!
mScreenSize
.
equals
(
newScreenSize
)
;
boolean
windowSizeChanged
=
!
mWindowSize
.
equals
(
newWindowSize
)
;
if
(
!
force
&
&
!
screenSizeChanged
&
&
!
windowSizeChanged
)
{
return
;
}
mScreenSize
=
newScreenSize
;
mWindowSize
=
newWindowSize
;
if
(
screenSizeChanged
)
{
Log
.
d
(
LOGTAG
"
Screen
-
size
changed
to
"
+
mScreenSize
)
;
}
if
(
windowSizeChanged
)
{
Log
.
d
(
LOGTAG
"
Window
-
size
changed
to
"
+
mWindowSize
)
;
}
if
(
mView
!
=
null
)
{
mView
.
notifySizeChanged
(
mWindowSize
.
width
mWindowSize
.
height
mScreenSize
.
width
mScreenSize
.
height
)
;
}
String
json
=
"
"
;
try
{
if
(
scrollChange
!
=
null
)
{
int
id
=
+
+
sPaintSyncId
;
if
(
id
=
=
0
)
{
id
=
+
+
sPaintSyncId
;
}
JSONObject
jsonObj
=
new
JSONObject
(
)
;
jsonObj
.
put
(
"
x
"
scrollChange
.
x
/
mViewportMetrics
.
zoomFactor
)
;
jsonObj
.
put
(
"
y
"
scrollChange
.
y
/
mViewportMetrics
.
zoomFactor
)
;
jsonObj
.
put
(
"
id
"
id
)
;
json
=
jsonObj
.
toString
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
convert
point
to
JSON
"
e
)
;
}
GeckoAppShell
.
notifyObservers
(
"
Window
:
Resize
"
json
)
;
}
private
void
setPageRect
(
RectF
rect
RectF
cssRect
)
{
if
(
mViewportMetrics
.
getCssPageRect
(
)
.
equals
(
cssRect
)
)
return
;
mViewportMetrics
=
mViewportMetrics
.
setPageRect
(
rect
cssRect
)
;
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mPanZoomController
.
pageRectUpdated
(
)
;
mView
.
requestRender
(
)
;
}
}
)
;
}
private
void
abortPanZoomAnimation
(
)
{
if
(
mPanZoomController
!
=
null
)
{
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mPanZoomController
.
abortAnimation
(
)
;
}
}
)
;
}
}
private
enum
ViewportMessageType
{
UPDATE
PAGE_SIZE
}
private
DisplayPortMetrics
handleViewportMessage
(
ImmutableViewportMetrics
messageMetrics
ViewportMessageType
type
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
newMetrics
;
ImmutableViewportMetrics
oldMetrics
=
getViewportMetrics
(
)
;
switch
(
type
)
{
default
:
case
UPDATE
:
newMetrics
=
messageMetrics
.
setViewportSize
(
oldMetrics
.
viewportRectWidth
oldMetrics
.
viewportRectHeight
)
;
if
(
mToolbarAnimator
.
isResizing
(
)
)
{
newMetrics
=
newMetrics
.
setViewportOrigin
(
oldMetrics
.
viewportRectLeft
oldMetrics
.
viewportRectTop
)
;
break
;
}
if
(
!
oldMetrics
.
fuzzyEquals
(
newMetrics
)
)
{
abortPanZoomAnimation
(
)
;
}
break
;
case
PAGE_SIZE
:
float
scaleFactor
=
oldMetrics
.
zoomFactor
/
messageMetrics
.
zoomFactor
;
newMetrics
=
oldMetrics
.
setPageRect
(
RectUtils
.
scale
(
messageMetrics
.
getPageRect
(
)
scaleFactor
)
messageMetrics
.
getCssPageRect
(
)
)
;
break
;
}
final
ImmutableViewportMetrics
geckoMetrics
=
newMetrics
.
clamp
(
)
;
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mGeckoViewport
=
geckoMetrics
;
}
}
)
;
setViewportMetrics
(
newMetrics
type
=
=
ViewportMessageType
.
UPDATE
)
;
mDisplayPort
=
DisplayPortCalculator
.
calculate
(
getViewportMetrics
(
)
null
)
;
}
return
mDisplayPort
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
void
contentDocumentChanged
(
)
{
mContentDocumentIsDisplayed
=
false
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
boolean
isContentDocumentDisplayed
(
)
{
return
mContentDocumentIsDisplayed
;
}
WrapForJNI
public
ProgressiveUpdateData
progressiveUpdateCallback
(
boolean
aHasPendingNewThebesContent
float
x
float
y
float
width
float
height
float
resolution
boolean
lowPrecision
)
{
if
(
lowPrecision
&
&
!
mLastProgressiveUpdateWasLowPrecision
)
{
if
(
!
mProgressiveUpdateWasInDanger
)
{
mProgressiveUpdateData
.
abort
=
true
;
return
mProgressiveUpdateData
;
}
mProgressiveUpdateWasInDanger
=
false
;
}
mLastProgressiveUpdateWasLowPrecision
=
lowPrecision
;
DisplayPortMetrics
displayPort
=
mDisplayPort
;
ImmutableViewportMetrics
viewportMetrics
=
mViewportMetrics
;
mProgressiveUpdateData
.
setViewport
(
viewportMetrics
)
;
mProgressiveUpdateData
.
abort
=
false
;
if
(
!
FloatUtils
.
fuzzyEquals
(
resolution
viewportMetrics
.
zoomFactor
)
)
{
Log
.
d
(
LOGTAG
"
Aborting
draw
due
to
resolution
change
:
"
+
resolution
+
"
!
=
"
+
viewportMetrics
.
zoomFactor
)
;
mProgressiveUpdateData
.
abort
=
true
;
return
mProgressiveUpdateData
;
}
if
(
!
lowPrecision
)
{
if
(
!
FloatUtils
.
fuzzyEquals
(
resolution
mProgressiveUpdateDisplayPort
.
resolution
)
|
|
!
FloatUtils
.
fuzzyEquals
(
x
mProgressiveUpdateDisplayPort
.
getLeft
(
)
)
|
|
!
FloatUtils
.
fuzzyEquals
(
y
mProgressiveUpdateDisplayPort
.
getTop
(
)
)
|
|
!
FloatUtils
.
fuzzyEquals
(
x
+
width
mProgressiveUpdateDisplayPort
.
getRight
(
)
)
|
|
!
FloatUtils
.
fuzzyEquals
(
y
+
height
mProgressiveUpdateDisplayPort
.
getBottom
(
)
)
)
{
mProgressiveUpdateDisplayPort
=
new
DisplayPortMetrics
(
x
y
x
+
width
y
+
height
resolution
)
;
}
}
if
(
!
lowPrecision
&
&
!
mProgressiveUpdateWasInDanger
)
{
if
(
DisplayPortCalculator
.
aboutToCheckerboard
(
viewportMetrics
mPanZoomController
.
getVelocityVector
(
)
mProgressiveUpdateDisplayPort
)
)
{
mProgressiveUpdateWasInDanger
=
true
;
}
}
if
(
Math
.
abs
(
displayPort
.
getLeft
(
)
-
mProgressiveUpdateDisplayPort
.
getLeft
(
)
)
<
=
2
&
&
Math
.
abs
(
displayPort
.
getTop
(
)
-
mProgressiveUpdateDisplayPort
.
getTop
(
)
)
<
=
2
&
&
Math
.
abs
(
displayPort
.
getBottom
(
)
-
mProgressiveUpdateDisplayPort
.
getBottom
(
)
)
<
=
2
&
&
Math
.
abs
(
displayPort
.
getRight
(
)
-
mProgressiveUpdateDisplayPort
.
getRight
(
)
)
<
=
2
)
{
return
mProgressiveUpdateData
;
}
if
(
Math
.
max
(
viewportMetrics
.
viewportRectLeft
viewportMetrics
.
pageRectLeft
)
+
1
<
x
|
|
Math
.
max
(
viewportMetrics
.
viewportRectTop
viewportMetrics
.
pageRectTop
)
+
1
<
y
|
|
Math
.
min
(
viewportMetrics
.
viewportRectRight
(
)
viewportMetrics
.
pageRectRight
)
-
1
>
x
+
width
|
|
Math
.
min
(
viewportMetrics
.
viewportRectBottom
(
)
viewportMetrics
.
pageRectBottom
)
-
1
>
y
+
height
)
{
Log
.
d
(
LOGTAG
"
Aborting
update
due
to
viewport
not
in
display
-
port
"
)
;
mProgressiveUpdateData
.
abort
=
true
;
mProgressiveUpdateWasInDanger
=
true
;
return
mProgressiveUpdateData
;
}
if
(
lowPrecision
&
&
!
aHasPendingNewThebesContent
)
{
mProgressiveUpdateData
.
abort
=
true
;
}
return
mProgressiveUpdateData
;
}
void
setZoomConstraints
(
ZoomConstraints
constraints
)
{
mZoomConstraints
=
constraints
;
}
void
setIsRTL
(
boolean
aIsRTL
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
newMetrics
=
getViewportMetrics
(
)
.
setIsRTL
(
aIsRTL
)
;
setViewportMetrics
(
newMetrics
false
)
;
}
}
WrapForJNI
public
void
setFirstPaintViewport
(
float
offsetX
float
offsetY
float
zoom
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
currentMetrics
=
getViewportMetrics
(
)
;
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
RectF
pageRect
=
RectUtils
.
scaleAndRound
(
cssPageRect
zoom
)
;
final
ImmutableViewportMetrics
newMetrics
=
currentMetrics
.
setViewportOrigin
(
offsetX
offsetY
)
.
setZoomFactor
(
zoom
)
.
setPageRect
(
pageRect
cssPageRect
)
.
setIsRTL
(
tab
!
=
null
?
tab
.
getIsRTL
(
)
:
false
)
;
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mGeckoViewport
=
newMetrics
;
}
}
)
;
setViewportMetrics
(
newMetrics
)
;
if
(
tab
!
=
null
)
{
mView
.
setBackgroundColor
(
tab
.
getBackgroundColor
(
)
)
;
setZoomConstraints
(
tab
.
getZoomConstraints
(
)
)
;
}
abortPanZoomAnimation
(
)
;
if
(
mView
.
getPaintState
(
)
=
=
LayerView
.
PAINT_START
)
{
mView
.
setPaintState
(
LayerView
.
PAINT_BEFORE_FIRST
)
;
}
}
DisplayPortCalculator
.
resetPageState
(
)
;
mDrawTimingQueue
.
reset
(
)
;
mContentDocumentIsDisplayed
=
true
;
}
WrapForJNI
public
void
setPageRect
(
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
)
{
synchronized
(
getLock
(
)
)
{
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
float
ourZoom
=
getViewportMetrics
(
)
.
zoomFactor
;
setPageRect
(
RectUtils
.
scale
(
cssPageRect
ourZoom
)
cssPageRect
)
;
}
}
WrapForJNI
public
ViewTransform
syncViewportInfo
(
int
x
int
y
int
width
int
height
float
resolution
boolean
layersUpdated
int
paintSyncId
)
{
mFrameMetrics
=
getViewportMetrics
(
)
;
if
(
paintSyncId
=
=
sPaintSyncId
)
{
mToolbarAnimator
.
scrollChangeResizeCompleted
(
)
;
}
mToolbarAnimator
.
populateViewTransform
(
mCurrentViewTransform
mFrameMetrics
)
;
if
(
layersUpdated
&
&
mRecordDrawTimes
)
{
DisplayPortMetrics
drawn
=
new
DisplayPortMetrics
(
x
y
x
+
width
y
+
height
resolution
)
;
long
time
=
mDrawTimingQueue
.
findTimeFor
(
drawn
)
;
if
(
time
>
=
0
)
{
long
now
=
SystemClock
.
uptimeMillis
(
)
;
time
=
now
-
time
;
mRecordDrawTimes
=
DisplayPortCalculator
.
drawTimeUpdate
(
time
width
*
height
)
;
}
}
if
(
layersUpdated
)
{
for
(
DrawListener
listener
:
mDrawListeners
)
{
listener
.
drawFinished
(
)
;
}
}
return
mCurrentViewTransform
;
}
WrapForJNI
public
ViewTransform
syncFrameMetrics
(
float
scrollX
float
scrollY
float
zoom
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
int
dpX
int
dpY
int
dpWidth
int
dpHeight
float
paintedResolution
boolean
layersUpdated
int
paintSyncId
)
{
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
synchronized
(
getLock
(
)
)
{
mViewportMetrics
=
mViewportMetrics
.
setViewportOrigin
(
scrollX
scrollY
)
.
setZoomFactor
(
zoom
)
.
setPageRect
(
RectUtils
.
scale
(
cssPageRect
zoom
)
cssPageRect
)
;
}
return
syncViewportInfo
(
dpX
dpY
dpWidth
dpHeight
paintedResolution
layersUpdated
paintSyncId
)
;
}
class
PointerInfo
{
public
static
final
int
RESERVED_MOUSE_POINTER_ID
=
100000
;
public
int
pointerId
;
public
int
source
;
public
int
screenX
;
public
int
screenY
;
public
double
pressure
;
public
int
orientation
;
public
MotionEvent
.
PointerCoords
getCoords
(
)
{
MotionEvent
.
PointerCoords
coords
=
new
MotionEvent
.
PointerCoords
(
)
;
coords
.
orientation
=
orientation
;
coords
.
pressure
=
(
float
)
pressure
;
coords
.
x
=
screenX
;
coords
.
y
=
screenY
;
return
coords
;
}
}
class
SynthesizedEventState
{
public
final
ArrayList
<
PointerInfo
>
pointers
;
public
long
downTime
;
SynthesizedEventState
(
)
{
pointers
=
new
ArrayList
<
PointerInfo
>
(
)
;
}
int
getPointerIndex
(
int
pointerId
)
{
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
pointerId
=
=
pointerId
)
{
return
i
;
}
}
return
-
1
;
}
int
addPointer
(
int
pointerId
int
source
)
{
PointerInfo
info
=
new
PointerInfo
(
)
;
info
.
pointerId
=
pointerId
;
info
.
source
=
source
;
pointers
.
add
(
info
)
;
return
pointers
.
size
(
)
-
1
;
}
int
getPointerCount
(
int
source
)
{
int
count
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
count
+
+
;
}
}
return
count
;
}
MotionEvent
.
PointerProperties
[
]
getPointerProperties
(
int
source
)
{
MotionEvent
.
PointerProperties
[
]
props
=
new
MotionEvent
.
PointerProperties
[
getPointerCount
(
source
)
]
;
int
index
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
MotionEvent
.
PointerProperties
p
=
new
MotionEvent
.
PointerProperties
(
)
;
p
.
id
=
pointers
.
get
(
i
)
.
pointerId
;
switch
(
source
)
{
case
InputDevice
.
SOURCE_TOUCHSCREEN
:
p
.
toolType
=
MotionEvent
.
TOOL_TYPE_FINGER
;
break
;
case
InputDevice
.
SOURCE_MOUSE
:
p
.
toolType
=
MotionEvent
.
TOOL_TYPE_MOUSE
;
break
;
}
props
[
index
+
+
]
=
p
;
}
}
return
props
;
}
MotionEvent
.
PointerCoords
[
]
getPointerCoords
(
int
source
)
{
MotionEvent
.
PointerCoords
[
]
coords
=
new
MotionEvent
.
PointerCoords
[
getPointerCount
(
source
)
]
;
int
index
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
coords
[
index
+
+
]
=
pointers
.
get
(
i
)
.
getCoords
(
)
;
}
}
return
coords
;
}
}
private
void
synthesizeNativePointer
(
int
source
int
pointerId
int
eventType
int
screenX
int
screenY
double
pressure
int
orientation
)
{
Log
.
d
(
LOGTAG
"
Synthesizing
pointer
from
"
+
source
+
"
id
"
+
pointerId
+
"
at
"
+
screenX
+
"
"
+
screenY
)
;
if
(
mPointerState
=
=
null
)
{
mPointerState
=
new
SynthesizedEventState
(
)
;
}
int
pointerIndex
=
mPointerState
.
getPointerIndex
(
pointerId
)
;
switch
(
eventType
)
{
case
MotionEvent
.
ACTION_POINTER_UP
:
if
(
pointerIndex
<
0
)
{
Log
.
d
(
LOGTAG
"
Requested
synthesis
of
a
pointer
-
up
for
a
pointer
that
doesn
'
t
exist
!
"
)
;
return
;
}
if
(
mPointerState
.
pointers
.
size
(
)
=
=
1
)
{
eventType
=
MotionEvent
.
ACTION_UP
;
}
break
;
case
MotionEvent
.
ACTION_CANCEL
:
if
(
pointerIndex
<
0
)
{
Log
.
d
(
LOGTAG
"
Requested
synthesis
of
a
pointer
-
cancel
for
a
pointer
that
doesn
'
t
exist
!
"
)
;
return
;
}
break
;
case
MotionEvent
.
ACTION_POINTER_DOWN
:
if
(
pointerIndex
<
0
)
{
pointerIndex
=
mPointerState
.
addPointer
(
pointerId
source
)
;
if
(
pointerIndex
=
=
0
)
{
eventType
=
MotionEvent
.
ACTION_DOWN
;
mPointerState
.
downTime
=
SystemClock
.
uptimeMillis
(
)
;
}
}
else
{
eventType
=
MotionEvent
.
ACTION_MOVE
;
}
break
;
case
MotionEvent
.
ACTION_HOVER_MOVE
:
if
(
pointerIndex
<
0
)
{
pointerIndex
=
mPointerState
.
addPointer
(
pointerId
source
)
;
}
else
{
eventType
=
MotionEvent
.
ACTION_MOVE
;
}
break
;
}
PointerInfo
info
=
mPointerState
.
pointers
.
get
(
pointerIndex
)
;
info
.
screenX
=
screenX
;
info
.
screenY
=
screenY
;
info
.
pressure
=
pressure
;
info
.
orientation
=
orientation
;
int
action
=
(
pointerIndex
<
<
MotionEvent
.
ACTION_POINTER_INDEX_SHIFT
)
;
action
&
=
MotionEvent
.
ACTION_POINTER_INDEX_MASK
;
action
|
=
(
eventType
&
MotionEvent
.
ACTION_MASK
)
;
boolean
isButtonDown
=
(
source
=
=
InputDevice
.
SOURCE_MOUSE
)
&
&
(
eventType
=
=
MotionEvent
.
ACTION_DOWN
|
|
eventType
=
=
MotionEvent
.
ACTION_MOVE
)
;
final
MotionEvent
event
=
MotionEvent
.
obtain
(
mPointerState
.
downTime
SystemClock
.
uptimeMillis
(
)
action
mPointerState
.
getPointerCount
(
source
)
mPointerState
.
getPointerProperties
(
source
)
mPointerState
.
getPointerCoords
(
source
)
0
(
isButtonDown
?
MotionEvent
.
BUTTON_PRIMARY
:
0
)
0
0
0
0
source
0
)
;
mView
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
event
.
offsetLocation
(
0
mView
.
getSurfaceTranslation
(
)
)
;
mView
.
dispatchTouchEvent
(
event
)
;
}
}
)
;
if
(
eventType
=
=
MotionEvent
.
ACTION_POINTER_UP
|
|
eventType
=
=
MotionEvent
.
ACTION_UP
|
|
eventType
=
=
MotionEvent
.
ACTION_CANCEL
|
|
eventType
=
=
MotionEvent
.
ACTION_HOVER_MOVE
)
{
mPointerState
.
pointers
.
remove
(
pointerIndex
)
;
}
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
void
synthesizeNativeTouchPoint
(
int
pointerId
int
eventType
int
screenX
int
screenY
double
pressure
int
orientation
)
{
if
(
pointerId
=
=
PointerInfo
.
RESERVED_MOUSE_POINTER_ID
)
{
throw
new
IllegalArgumentException
(
"
Use
a
different
pointer
ID
in
your
test
this
one
is
reserved
for
mouse
"
)
;
}
synthesizeNativePointer
(
InputDevice
.
SOURCE_TOUCHSCREEN
pointerId
eventType
screenX
screenY
pressure
orientation
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
void
synthesizeNativeMouseEvent
(
int
eventType
int
screenX
int
screenY
)
{
synthesizeNativePointer
(
InputDevice
.
SOURCE_MOUSE
PointerInfo
.
RESERVED_MOUSE_POINTER_ID
eventType
screenX
screenY
0
0
)
;
}
WrapForJNI
public
LayerRenderer
.
Frame
createFrame
(
)
{
if
(
!
mLayerRendererInitialized
)
{
if
(
mLayerRenderer
=
=
null
)
{
return
null
;
}
mLayerRenderer
.
createDefaultProgram
(
)
;
mLayerRendererInitialized
=
true
;
}
try
{
return
mLayerRenderer
.
createFrame
(
mFrameMetrics
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
e
)
;
return
null
;
}
}
private
void
geometryChanged
(
DisplayPortMetrics
displayPort
)
{
sendResizeEventIfNecessary
(
false
null
)
;
}
Override
public
void
surfaceChanged
(
int
width
int
height
)
{
IntSize
viewportSize
=
mToolbarAnimator
.
getViewportSize
(
)
;
setViewportSize
(
viewportSize
.
width
viewportSize
.
height
null
)
;
}
Override
public
ImmutableViewportMetrics
getViewportMetrics
(
)
{
return
mViewportMetrics
;
}
Override
public
ZoomConstraints
getZoomConstraints
(
)
{
return
mZoomConstraints
;
}
Override
public
FullScreenState
getFullScreenState
(
)
{
return
mView
.
getFullScreenState
(
)
;
}
Override
public
PointF
getVisibleEndOfLayerView
(
)
{
return
mToolbarAnimator
.
getVisibleEndOfLayerView
(
)
;
}
Override
public
void
setAnimationTarget
(
ImmutableViewportMetrics
metrics
)
{
if
(
mGeckoIsReady
)
{
DisplayPortMetrics
displayPort
=
DisplayPortCalculator
.
calculate
(
metrics
null
)
;
}
}
Override
public
void
setViewportMetrics
(
ImmutableViewportMetrics
metrics
)
{
setViewportMetrics
(
metrics
true
)
;
}
private
void
setViewportMetrics
(
ImmutableViewportMetrics
metrics
boolean
notifyGecko
)
{
metrics
=
metrics
.
setViewportSize
(
mViewportMetrics
.
viewportRectWidth
mViewportMetrics
.
viewportRectHeight
)
;
mViewportMetrics
=
metrics
;
viewportMetricsChanged
(
notifyGecko
)
;
}
private
void
viewportMetricsChanged
(
boolean
notifyGecko
)
{
mToolbarAnimator
.
onMetricsChanged
(
mViewportMetrics
)
;
mView
.
requestRender
(
)
;
if
(
notifyGecko
&
&
mGeckoIsReady
)
{
geometryChanged
(
null
)
;
}
}
void
forceViewportMetrics
(
ImmutableViewportMetrics
metrics
boolean
notifyGecko
boolean
forceRedraw
)
{
if
(
forceRedraw
)
{
mForceRedraw
=
true
;
}
mViewportMetrics
=
metrics
;
viewportMetricsChanged
(
notifyGecko
)
;
}
Override
public
void
scrollBy
(
float
dx
float
dy
)
{
mViewportMetrics
=
mViewportMetrics
.
offsetViewportBy
(
dx
dy
)
;
viewportMetricsChanged
(
true
)
;
}
Override
public
void
panZoomStopped
(
)
{
mToolbarAnimator
.
onPanZoomStopped
(
)
;
}
Override
public
void
forceRedraw
(
DisplayPortMetrics
displayPort
)
{
mForceRedraw
=
true
;
if
(
mGeckoIsReady
)
{
geometryChanged
(
displayPort
)
;
}
}
Override
public
boolean
post
(
Runnable
action
)
{
return
mView
.
post
(
action
)
;
}
Override
public
void
postRenderTask
(
RenderTask
task
)
{
mView
.
postRenderTask
(
task
)
;
}
Override
public
void
removeRenderTask
(
RenderTask
task
)
{
mView
.
removeRenderTask
(
task
)
;
}
Override
public
Object
getLock
(
)
{
return
this
;
}
Override
public
PointF
convertViewPointToLayerPoint
(
PointF
viewPoint
)
{
if
(
!
mGeckoIsReady
)
{
return
null
;
}
ImmutableViewportMetrics
viewportMetrics
=
mViewportMetrics
;
PointF
origin
=
viewportMetrics
.
getOrigin
(
)
;
float
zoom
=
viewportMetrics
.
zoomFactor
;
ImmutableViewportMetrics
geckoViewport
=
mViewportMetrics
;
PointF
geckoOrigin
=
geckoViewport
.
getOrigin
(
)
;
float
geckoZoom
=
geckoViewport
.
zoomFactor
;
PointF
layerPoint
=
new
PointF
(
(
(
viewPoint
.
x
+
origin
.
x
)
/
zoom
)
-
(
geckoOrigin
.
x
/
geckoZoom
)
(
(
viewPoint
.
y
+
origin
.
y
)
/
zoom
)
-
(
geckoOrigin
.
y
/
geckoZoom
)
)
;
return
layerPoint
;
}
Override
public
Matrix
getMatrixForLayerRectToViewRect
(
)
{
if
(
!
mGeckoIsReady
)
{
return
null
;
}
ImmutableViewportMetrics
viewportMetrics
=
mViewportMetrics
;
PointF
origin
=
viewportMetrics
.
getOrigin
(
)
;
float
zoom
=
viewportMetrics
.
zoomFactor
;
ImmutableViewportMetrics
geckoViewport
=
mViewportMetrics
;
PointF
geckoOrigin
=
geckoViewport
.
getOrigin
(
)
;
float
geckoZoom
=
geckoViewport
.
zoomFactor
;
Matrix
matrix
=
new
Matrix
(
)
;
matrix
.
postTranslate
(
geckoOrigin
.
x
/
geckoZoom
geckoOrigin
.
y
/
geckoZoom
)
;
matrix
.
postScale
(
zoom
zoom
)
;
matrix
.
postTranslate
(
-
origin
.
x
-
origin
.
y
)
;
return
matrix
;
}
Override
public
void
setScrollingRootContent
(
boolean
isRootContent
)
{
mToolbarAnimator
.
setScrollingRootContent
(
isRootContent
)
;
}
public
void
addDrawListener
(
DrawListener
listener
)
{
mDrawListeners
.
add
(
listener
)
;
}
public
void
removeDrawListener
(
DrawListener
listener
)
{
mDrawListeners
.
remove
(
listener
)
;
}
}
