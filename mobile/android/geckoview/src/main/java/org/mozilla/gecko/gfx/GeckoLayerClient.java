package
org
.
mozilla
.
gecko
.
gfx
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
.
DrawListener
;
import
org
.
mozilla
.
gecko
.
util
.
FloatUtils
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
PointF
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
android
.
view
.
InputDevice
;
import
android
.
view
.
MotionEvent
;
import
org
.
json
.
JSONObject
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
class
GeckoLayerClient
implements
LayerView
.
Listener
PanZoomTarget
{
private
static
final
String
LOGTAG
=
"
GeckoLayerClient
"
;
private
static
int
sPaintSyncId
=
1
;
private
LayerRenderer
mLayerRenderer
;
private
boolean
mLayerRendererInitialized
;
private
final
Context
mContext
;
private
IntSize
mScreenSize
;
private
IntSize
mWindowSize
;
private
ImmutableViewportMetrics
mFrameMetrics
;
private
final
List
<
DrawListener
>
mDrawListeners
;
private
final
ViewTransform
mCurrentViewTransform
;
private
boolean
mForceRedraw
;
private
volatile
ImmutableViewportMetrics
mViewportMetrics
;
private
volatile
boolean
mGeckoIsReady
;
final
PanZoomController
mPanZoomController
;
private
final
DynamicToolbarAnimator
mToolbarAnimator
;
final
LayerView
mView
;
private
volatile
boolean
mContentDocumentIsDisplayed
;
private
SynthesizedEventState
mPointerState
;
WrapForJNI
(
stubName
=
"
ClearColor
"
)
private
volatile
int
mClearColor
=
Color
.
WHITE
;
public
GeckoLayerClient
(
Context
context
LayerView
view
)
{
mContext
=
context
;
mScreenSize
=
new
IntSize
(
0
0
)
;
mWindowSize
=
new
IntSize
(
0
0
)
;
mCurrentViewTransform
=
new
ViewTransform
(
0
0
1
)
;
mForceRedraw
=
true
;
DisplayMetrics
displayMetrics
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
;
mViewportMetrics
=
new
ImmutableViewportMetrics
(
displayMetrics
)
.
setViewportSize
(
view
.
getWidth
(
)
view
.
getHeight
(
)
)
;
mFrameMetrics
=
mViewportMetrics
;
mDrawListeners
=
new
ArrayList
<
DrawListener
>
(
)
;
mToolbarAnimator
=
new
DynamicToolbarAnimator
(
this
)
;
mPanZoomController
=
PanZoomController
.
Factory
.
create
(
this
view
)
;
mView
=
view
;
mView
.
setListener
(
this
)
;
mContentDocumentIsDisplayed
=
true
;
}
public
void
setOverscrollHandler
(
final
Overscroll
listener
)
{
mPanZoomController
.
setOverscrollHandler
(
listener
)
;
}
public
void
setGeckoReady
(
boolean
ready
)
{
mGeckoIsReady
=
ready
;
}
Override
public
boolean
isGeckoReady
(
)
{
return
mGeckoIsReady
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
void
onGeckoReady
(
)
{
mGeckoIsReady
=
true
;
mLayerRenderer
=
mView
.
getRenderer
(
)
;
sendResizeEventIfNecessary
(
true
null
)
;
mView
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mPanZoomController
.
attach
(
)
;
mView
.
updateCompositor
(
)
;
}
}
)
;
}
public
void
destroy
(
)
{
mPanZoomController
.
destroy
(
)
;
mToolbarAnimator
.
destroy
(
)
;
mDrawListeners
.
clear
(
)
;
mGeckoIsReady
=
false
;
}
public
LayerView
getView
(
)
{
return
mView
;
}
public
FloatSize
getViewportSize
(
)
{
return
mViewportMetrics
.
getSize
(
)
;
}
boolean
setViewportSize
(
int
width
int
height
PointF
scrollChange
)
{
if
(
mViewportMetrics
.
viewportRectWidth
=
=
width
&
&
mViewportMetrics
.
viewportRectHeight
=
=
height
&
&
(
scrollChange
=
=
null
|
|
(
scrollChange
.
x
=
=
0
&
&
scrollChange
.
y
=
=
0
)
)
)
{
return
false
;
}
mViewportMetrics
=
mViewportMetrics
.
setViewportSize
(
width
height
)
;
if
(
scrollChange
!
=
null
)
{
mViewportMetrics
=
mPanZoomController
.
adjustScrollForSurfaceShift
(
mViewportMetrics
scrollChange
)
;
}
if
(
mGeckoIsReady
)
{
sendResizeEventIfNecessary
(
true
scrollChange
)
;
GeckoAppShell
.
viewSizeChanged
(
)
;
}
return
true
;
}
PanZoomController
getPanZoomController
(
)
{
return
mPanZoomController
;
}
DynamicToolbarAnimator
getDynamicToolbarAnimator
(
)
{
return
mToolbarAnimator
;
}
private
void
sendResizeEventIfNecessary
(
boolean
force
PointF
scrollChange
)
{
DisplayMetrics
metrics
=
mContext
.
getResources
(
)
.
getDisplayMetrics
(
)
;
IntSize
newScreenSize
=
new
IntSize
(
metrics
.
widthPixels
metrics
.
heightPixels
)
;
IntSize
newWindowSize
=
new
IntSize
(
mViewportMetrics
.
viewportRectWidth
mViewportMetrics
.
viewportRectHeight
)
;
boolean
screenSizeChanged
=
!
mScreenSize
.
equals
(
newScreenSize
)
;
boolean
windowSizeChanged
=
!
mWindowSize
.
equals
(
newWindowSize
)
;
if
(
!
force
&
&
!
screenSizeChanged
&
&
!
windowSizeChanged
)
{
return
;
}
mScreenSize
=
newScreenSize
;
mWindowSize
=
newWindowSize
;
if
(
screenSizeChanged
)
{
Log
.
d
(
LOGTAG
"
Screen
-
size
changed
to
"
+
mScreenSize
)
;
}
if
(
windowSizeChanged
)
{
Log
.
d
(
LOGTAG
"
Window
-
size
changed
to
"
+
mWindowSize
)
;
}
if
(
mView
!
=
null
)
{
mView
.
notifySizeChanged
(
mWindowSize
.
width
mWindowSize
.
height
mScreenSize
.
width
mScreenSize
.
height
)
;
}
String
json
=
"
"
;
try
{
if
(
scrollChange
!
=
null
)
{
int
id
=
+
+
sPaintSyncId
;
if
(
id
=
=
0
)
{
id
=
+
+
sPaintSyncId
;
}
JSONObject
jsonObj
=
new
JSONObject
(
)
;
jsonObj
.
put
(
"
x
"
scrollChange
.
x
/
mViewportMetrics
.
zoomFactor
)
;
jsonObj
.
put
(
"
y
"
scrollChange
.
y
/
mViewportMetrics
.
zoomFactor
)
;
jsonObj
.
put
(
"
id
"
id
)
;
json
=
jsonObj
.
toString
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
convert
point
to
JSON
"
e
)
;
}
GeckoAppShell
.
notifyObservers
(
"
Window
:
Resize
"
json
)
;
}
private
enum
ViewportMessageType
{
UPDATE
PAGE_SIZE
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
void
contentDocumentChanged
(
)
{
mContentDocumentIsDisplayed
=
false
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
boolean
isContentDocumentDisplayed
(
)
{
return
mContentDocumentIsDisplayed
;
}
WrapForJNI
public
void
setFirstPaintViewport
(
float
offsetX
float
offsetY
float
zoom
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
currentMetrics
=
getViewportMetrics
(
)
;
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
RectF
pageRect
=
RectUtils
.
scaleAndRound
(
cssPageRect
zoom
)
;
final
ImmutableViewportMetrics
newMetrics
=
currentMetrics
.
setViewportOrigin
(
offsetX
offsetY
)
.
setZoomFactor
(
zoom
)
.
setPageRect
(
pageRect
cssPageRect
)
;
setViewportMetrics
(
newMetrics
true
)
;
if
(
mView
.
getPaintState
(
)
=
=
LayerView
.
PAINT_START
)
{
mView
.
setPaintState
(
LayerView
.
PAINT_BEFORE_FIRST
)
;
}
}
mContentDocumentIsDisplayed
=
true
;
}
private
ViewTransform
syncViewportInfo
(
int
x
int
y
int
width
int
height
float
resolution
boolean
layersUpdated
int
paintSyncId
)
{
mFrameMetrics
=
getViewportMetrics
(
)
;
if
(
paintSyncId
=
=
sPaintSyncId
)
{
mToolbarAnimator
.
scrollChangeResizeCompleted
(
)
;
}
mToolbarAnimator
.
populateViewTransform
(
mCurrentViewTransform
mFrameMetrics
)
;
if
(
layersUpdated
)
{
for
(
DrawListener
listener
:
mDrawListeners
)
{
listener
.
drawFinished
(
)
;
}
}
return
mCurrentViewTransform
;
}
WrapForJNI
public
ViewTransform
syncFrameMetrics
(
float
scrollX
float
scrollY
float
zoom
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
int
dpX
int
dpY
int
dpWidth
int
dpHeight
float
paintedResolution
boolean
layersUpdated
int
paintSyncId
)
{
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
synchronized
(
getLock
(
)
)
{
mViewportMetrics
=
mViewportMetrics
.
setViewportOrigin
(
scrollX
scrollY
)
.
setZoomFactor
(
zoom
)
.
setPageRect
(
RectUtils
.
scale
(
cssPageRect
zoom
)
cssPageRect
)
;
}
return
syncViewportInfo
(
dpX
dpY
dpWidth
dpHeight
paintedResolution
layersUpdated
paintSyncId
)
;
}
class
PointerInfo
{
public
static
final
int
RESERVED_MOUSE_POINTER_ID
=
100000
;
public
int
pointerId
;
public
int
source
;
public
int
screenX
;
public
int
screenY
;
public
double
pressure
;
public
int
orientation
;
public
MotionEvent
.
PointerCoords
getCoords
(
)
{
MotionEvent
.
PointerCoords
coords
=
new
MotionEvent
.
PointerCoords
(
)
;
coords
.
orientation
=
orientation
;
coords
.
pressure
=
(
float
)
pressure
;
coords
.
x
=
screenX
;
coords
.
y
=
screenY
;
return
coords
;
}
}
class
SynthesizedEventState
{
public
final
ArrayList
<
PointerInfo
>
pointers
;
public
long
downTime
;
SynthesizedEventState
(
)
{
pointers
=
new
ArrayList
<
PointerInfo
>
(
)
;
}
int
getPointerIndex
(
int
pointerId
)
{
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
pointerId
=
=
pointerId
)
{
return
i
;
}
}
return
-
1
;
}
int
addPointer
(
int
pointerId
int
source
)
{
PointerInfo
info
=
new
PointerInfo
(
)
;
info
.
pointerId
=
pointerId
;
info
.
source
=
source
;
pointers
.
add
(
info
)
;
return
pointers
.
size
(
)
-
1
;
}
int
getPointerCount
(
int
source
)
{
int
count
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
count
+
+
;
}
}
return
count
;
}
MotionEvent
.
PointerProperties
[
]
getPointerProperties
(
int
source
)
{
MotionEvent
.
PointerProperties
[
]
props
=
new
MotionEvent
.
PointerProperties
[
getPointerCount
(
source
)
]
;
int
index
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
MotionEvent
.
PointerProperties
p
=
new
MotionEvent
.
PointerProperties
(
)
;
p
.
id
=
pointers
.
get
(
i
)
.
pointerId
;
switch
(
source
)
{
case
InputDevice
.
SOURCE_TOUCHSCREEN
:
p
.
toolType
=
MotionEvent
.
TOOL_TYPE_FINGER
;
break
;
case
InputDevice
.
SOURCE_MOUSE
:
p
.
toolType
=
MotionEvent
.
TOOL_TYPE_MOUSE
;
break
;
}
props
[
index
+
+
]
=
p
;
}
}
return
props
;
}
MotionEvent
.
PointerCoords
[
]
getPointerCoords
(
int
source
)
{
MotionEvent
.
PointerCoords
[
]
coords
=
new
MotionEvent
.
PointerCoords
[
getPointerCount
(
source
)
]
;
int
index
=
0
;
for
(
int
i
=
0
;
i
<
pointers
.
size
(
)
;
i
+
+
)
{
if
(
pointers
.
get
(
i
)
.
source
=
=
source
)
{
coords
[
index
+
+
]
=
pointers
.
get
(
i
)
.
getCoords
(
)
;
}
}
return
coords
;
}
}
private
void
synthesizeNativePointer
(
int
source
int
pointerId
int
eventType
int
screenX
int
screenY
double
pressure
int
orientation
)
{
Log
.
d
(
LOGTAG
"
Synthesizing
pointer
from
"
+
source
+
"
id
"
+
pointerId
+
"
at
"
+
screenX
+
"
"
+
screenY
)
;
if
(
mPointerState
=
=
null
)
{
mPointerState
=
new
SynthesizedEventState
(
)
;
}
int
pointerIndex
=
mPointerState
.
getPointerIndex
(
pointerId
)
;
switch
(
eventType
)
{
case
MotionEvent
.
ACTION_POINTER_UP
:
if
(
pointerIndex
<
0
)
{
Log
.
d
(
LOGTAG
"
Requested
synthesis
of
a
pointer
-
up
for
a
pointer
that
doesn
'
t
exist
!
"
)
;
return
;
}
if
(
mPointerState
.
pointers
.
size
(
)
=
=
1
)
{
eventType
=
MotionEvent
.
ACTION_UP
;
}
break
;
case
MotionEvent
.
ACTION_CANCEL
:
if
(
pointerIndex
<
0
)
{
Log
.
d
(
LOGTAG
"
Requested
synthesis
of
a
pointer
-
cancel
for
a
pointer
that
doesn
'
t
exist
!
"
)
;
return
;
}
break
;
case
MotionEvent
.
ACTION_POINTER_DOWN
:
if
(
pointerIndex
<
0
)
{
pointerIndex
=
mPointerState
.
addPointer
(
pointerId
source
)
;
if
(
pointerIndex
=
=
0
)
{
eventType
=
MotionEvent
.
ACTION_DOWN
;
mPointerState
.
downTime
=
SystemClock
.
uptimeMillis
(
)
;
}
}
else
{
eventType
=
MotionEvent
.
ACTION_MOVE
;
}
break
;
case
MotionEvent
.
ACTION_HOVER_MOVE
:
if
(
pointerIndex
<
0
)
{
pointerIndex
=
mPointerState
.
addPointer
(
pointerId
source
)
;
}
else
{
eventType
=
MotionEvent
.
ACTION_MOVE
;
}
break
;
}
PointerInfo
info
=
mPointerState
.
pointers
.
get
(
pointerIndex
)
;
info
.
screenX
=
screenX
;
info
.
screenY
=
screenY
;
info
.
pressure
=
pressure
;
info
.
orientation
=
orientation
;
int
action
=
(
pointerIndex
<
<
MotionEvent
.
ACTION_POINTER_INDEX_SHIFT
)
;
action
&
=
MotionEvent
.
ACTION_POINTER_INDEX_MASK
;
action
|
=
(
eventType
&
MotionEvent
.
ACTION_MASK
)
;
boolean
isButtonDown
=
(
source
=
=
InputDevice
.
SOURCE_MOUSE
)
&
&
(
eventType
=
=
MotionEvent
.
ACTION_DOWN
|
|
eventType
=
=
MotionEvent
.
ACTION_MOVE
)
;
final
MotionEvent
event
=
MotionEvent
.
obtain
(
mPointerState
.
downTime
SystemClock
.
uptimeMillis
(
)
action
mPointerState
.
getPointerCount
(
source
)
mPointerState
.
getPointerProperties
(
source
)
mPointerState
.
getPointerCoords
(
source
)
0
(
isButtonDown
?
MotionEvent
.
BUTTON_PRIMARY
:
0
)
0
0
0
0
source
0
)
;
mView
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mView
.
dispatchTouchEvent
(
event
)
;
}
}
)
;
if
(
eventType
=
=
MotionEvent
.
ACTION_POINTER_UP
|
|
eventType
=
=
MotionEvent
.
ACTION_UP
|
|
eventType
=
=
MotionEvent
.
ACTION_CANCEL
|
|
eventType
=
=
MotionEvent
.
ACTION_HOVER_MOVE
)
{
mPointerState
.
pointers
.
remove
(
pointerIndex
)
;
}
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
void
synthesizeNativeTouchPoint
(
int
pointerId
int
eventType
int
screenX
int
screenY
double
pressure
int
orientation
)
{
if
(
pointerId
=
=
PointerInfo
.
RESERVED_MOUSE_POINTER_ID
)
{
throw
new
IllegalArgumentException
(
"
Use
a
different
pointer
ID
in
your
test
this
one
is
reserved
for
mouse
"
)
;
}
synthesizeNativePointer
(
InputDevice
.
SOURCE_TOUCHSCREEN
pointerId
eventType
screenX
screenY
pressure
orientation
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
void
synthesizeNativeMouseEvent
(
int
eventType
int
screenX
int
screenY
)
{
synthesizeNativePointer
(
InputDevice
.
SOURCE_MOUSE
PointerInfo
.
RESERVED_MOUSE_POINTER_ID
eventType
screenX
screenY
0
0
)
;
}
WrapForJNI
public
LayerRenderer
.
Frame
createFrame
(
)
{
if
(
!
mLayerRendererInitialized
)
{
if
(
mLayerRenderer
=
=
null
)
{
return
null
;
}
mLayerRenderer
.
createDefaultProgram
(
)
;
mLayerRendererInitialized
=
true
;
}
try
{
return
mLayerRenderer
.
createFrame
(
mFrameMetrics
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
e
)
;
return
null
;
}
}
private
void
geometryChanged
(
)
{
sendResizeEventIfNecessary
(
false
null
)
;
}
Override
public
void
surfaceChanged
(
int
width
int
height
)
{
IntSize
viewportSize
=
mToolbarAnimator
.
getViewportSize
(
)
;
setViewportSize
(
viewportSize
.
width
viewportSize
.
height
null
)
;
}
ImmutableViewportMetrics
getViewportMetrics
(
)
{
return
mViewportMetrics
;
}
private
void
setViewportMetrics
(
ImmutableViewportMetrics
metrics
boolean
notifyGecko
)
{
metrics
=
metrics
.
setViewportSize
(
mViewportMetrics
.
viewportRectWidth
mViewportMetrics
.
viewportRectHeight
)
;
mViewportMetrics
=
metrics
;
viewportMetricsChanged
(
notifyGecko
)
;
}
private
void
viewportMetricsChanged
(
boolean
notifyGecko
)
{
mToolbarAnimator
.
onMetricsChanged
(
mViewportMetrics
)
;
mView
.
requestRender
(
)
;
if
(
notifyGecko
&
&
mGeckoIsReady
)
{
geometryChanged
(
)
;
}
}
void
forceViewportMetrics
(
ImmutableViewportMetrics
metrics
boolean
notifyGecko
boolean
forceRedraw
)
{
if
(
forceRedraw
)
{
mForceRedraw
=
true
;
}
mViewportMetrics
=
metrics
;
viewportMetricsChanged
(
notifyGecko
)
;
}
Override
public
void
panZoomStopped
(
)
{
mToolbarAnimator
.
onPanZoomStopped
(
)
;
}
Object
getLock
(
)
{
return
this
;
}
Matrix
getMatrixForLayerRectToViewRect
(
)
{
if
(
!
mGeckoIsReady
)
{
return
null
;
}
ImmutableViewportMetrics
viewportMetrics
=
mViewportMetrics
;
PointF
origin
=
viewportMetrics
.
getOrigin
(
)
;
float
zoom
=
viewportMetrics
.
zoomFactor
;
ImmutableViewportMetrics
geckoViewport
=
mViewportMetrics
;
PointF
geckoOrigin
=
geckoViewport
.
getOrigin
(
)
;
float
geckoZoom
=
geckoViewport
.
zoomFactor
;
Matrix
matrix
=
new
Matrix
(
)
;
matrix
.
postTranslate
(
geckoOrigin
.
x
/
geckoZoom
geckoOrigin
.
y
/
geckoZoom
)
;
matrix
.
postScale
(
zoom
zoom
)
;
matrix
.
postTranslate
(
-
origin
.
x
-
origin
.
y
)
;
return
matrix
;
}
Override
public
void
setScrollingRootContent
(
boolean
isRootContent
)
{
mToolbarAnimator
.
setScrollingRootContent
(
isRootContent
)
;
}
public
void
addDrawListener
(
DrawListener
listener
)
{
mDrawListeners
.
add
(
listener
)
;
}
public
void
removeDrawListener
(
DrawListener
listener
)
{
mDrawListeners
.
remove
(
listener
)
;
}
public
void
setClearColor
(
int
color
)
{
mClearColor
=
color
;
}
}
