package
org
.
mozilla
.
geckoview
;
import
android
.
app
.
ActivityManager
;
import
android
.
content
.
ComponentName
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ServiceInfo
;
import
android
.
os
.
Build
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
content
.
Context
;
import
android
.
os
.
Process
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoFontScaleListener
;
import
org
.
mozilla
.
gecko
.
GeckoSystemStateListener
;
import
org
.
mozilla
.
gecko
.
GeckoScreenOrientation
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
import
org
.
mozilla
.
gecko
.
PrefsHelper
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
io
.
File
;
public
final
class
GeckoRuntime
implements
Parcelable
{
private
static
final
String
LOGTAG
=
"
GeckoRuntime
"
;
private
static
final
boolean
DEBUG
=
false
;
public
static
final
String
ACTION_CRASHED
=
"
org
.
mozilla
.
gecko
.
ACTION_CRASHED
"
;
public
static
final
String
EXTRA_MINIDUMP_PATH
=
"
minidumpPath
"
;
public
static
final
String
EXTRA_EXTRAS_PATH
=
"
extrasPath
"
;
public
static
final
String
EXTRA_MINIDUMP_SUCCESS
=
"
minidumpSuccess
"
;
public
static
final
String
EXTRA_CRASH_FATAL
=
"
fatal
"
;
private
static
GeckoRuntime
sDefaultRuntime
;
UiThread
public
static
synchronized
NonNull
GeckoRuntime
getDefault
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
getDefault
"
)
;
}
if
(
sDefaultRuntime
=
=
null
)
{
sDefaultRuntime
=
new
GeckoRuntime
(
)
;
sDefaultRuntime
.
attachTo
(
context
)
;
sDefaultRuntime
.
init
(
context
new
GeckoRuntimeSettings
(
)
)
;
}
return
sDefaultRuntime
;
}
private
GeckoRuntimeSettings
mSettings
;
private
Delegate
mDelegate
;
private
RuntimeTelemetry
mTelemetry
;
UiThread
public
void
attachTo
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
attachTo
"
+
context
.
getApplicationContext
(
)
)
;
}
final
Context
appContext
=
context
.
getApplicationContext
(
)
;
if
(
!
appContext
.
equals
(
GeckoAppShell
.
getApplicationContext
(
)
)
)
{
GeckoAppShell
.
setApplicationContext
(
appContext
)
;
}
}
private
final
BundleEventListener
mEventListener
=
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
Class
<
?
>
crashHandler
=
GeckoRuntime
.
this
.
getSettings
(
)
.
mCrashHandler
;
if
(
"
Gecko
:
Exited
"
.
equals
(
event
)
&
&
mDelegate
!
=
null
)
{
mDelegate
.
onShutdown
(
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
mEventListener
"
Gecko
:
Exited
"
)
;
}
else
if
(
"
GeckoView
:
ContentCrash
"
.
equals
(
event
)
&
&
crashHandler
!
=
null
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
Intent
i
=
new
Intent
(
ACTION_CRASHED
null
context
crashHandler
)
;
i
.
putExtra
(
EXTRA_MINIDUMP_PATH
message
.
getString
(
EXTRA_MINIDUMP_PATH
)
)
;
i
.
putExtra
(
EXTRA_EXTRAS_PATH
message
.
getString
(
EXTRA_EXTRAS_PATH
)
)
;
i
.
putExtra
(
EXTRA_MINIDUMP_SUCCESS
true
)
;
i
.
putExtra
(
EXTRA_CRASH_FATAL
message
.
getBoolean
(
EXTRA_CRASH_FATAL
true
)
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
O
)
{
context
.
startForegroundService
(
i
)
;
}
else
{
context
.
startService
(
i
)
;
}
}
}
}
;
private
static
final
String
getProcessName
(
Context
context
)
{
final
ActivityManager
manager
=
(
ActivityManager
)
context
.
getSystemService
(
Context
.
ACTIVITY_SERVICE
)
;
for
(
final
ActivityManager
.
RunningAppProcessInfo
info
:
manager
.
getRunningAppProcesses
(
)
)
{
if
(
info
.
pid
=
=
Process
.
myPid
(
)
)
{
return
info
.
processName
;
}
}
return
null
;
}
boolean
init
(
final
NonNull
Context
context
final
NonNull
GeckoRuntimeSettings
settings
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
init
"
)
;
}
int
flags
=
0
;
if
(
settings
.
getUseContentProcessHint
(
)
)
{
flags
|
=
GeckoThread
.
FLAG_PRELOAD_CHILD
;
}
if
(
settings
.
getPauseForDebuggerEnabled
(
)
)
{
flags
|
=
GeckoThread
.
FLAG_DEBUGGING
;
}
if
(
settings
.
getRemoteDebuggingEnabled
(
)
)
{
flags
|
=
GeckoThread
.
FLAG_ENABLE_MARIONETTE
;
}
final
Class
<
?
>
crashHandler
=
settings
.
getCrashHandler
(
)
;
if
(
crashHandler
!
=
null
)
{
try
{
final
ServiceInfo
info
=
context
.
getPackageManager
(
)
.
getServiceInfo
(
new
ComponentName
(
context
crashHandler
)
0
)
;
if
(
info
.
processName
.
equals
(
getProcessName
(
context
)
)
)
{
throw
new
IllegalArgumentException
(
"
Crash
handler
service
must
run
in
a
separate
process
"
)
;
}
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
mEventListener
"
GeckoView
:
ContentCrash
"
)
;
flags
|
=
GeckoThread
.
FLAG_ENABLE_NATIVE_CRASHREPORTER
;
}
catch
(
PackageManager
.
NameNotFoundException
e
)
{
throw
new
IllegalArgumentException
(
"
Crash
handler
must
be
registered
as
a
service
"
)
;
}
}
GeckoAppShell
.
useMaxScreenDepth
(
settings
.
getUseMaxScreenDepth
(
)
)
;
GeckoAppShell
.
setDisplayDensityOverride
(
settings
.
getDisplayDensityOverride
(
)
)
;
GeckoAppShell
.
setDisplayDpiOverride
(
settings
.
getDisplayDpiOverride
(
)
)
;
GeckoAppShell
.
setScreenSizeOverride
(
settings
.
getScreenSizeOverride
(
)
)
;
GeckoAppShell
.
setCrashHandlerService
(
settings
.
getCrashHandler
(
)
)
;
GeckoFontScaleListener
.
getInstance
(
)
.
attachToContext
(
context
)
;
final
GeckoThread
.
InitInfo
info
=
new
GeckoThread
.
InitInfo
(
)
;
info
.
args
=
settings
.
getArguments
(
)
;
info
.
extras
=
settings
.
getExtras
(
)
;
info
.
flags
=
flags
;
info
.
prefs
=
settings
.
getPrefsMap
(
)
;
if
(
!
GeckoThread
.
init
(
info
)
)
{
Log
.
w
(
LOGTAG
"
init
failed
(
could
not
initiate
GeckoThread
)
"
)
;
return
false
;
}
if
(
!
GeckoThread
.
launch
(
)
)
{
Log
.
w
(
LOGTAG
"
init
failed
(
GeckoThread
already
launched
)
"
)
;
return
false
;
}
mSettings
=
settings
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
mEventListener
"
Gecko
:
Exited
"
)
;
mSettings
.
attachTo
(
this
)
;
GeckoAppShell
.
getApplicationContext
(
)
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
return
true
;
}
void
setDefaultPrefs
(
GeckoBundle
prefs
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
SetDefaultPrefs
"
prefs
)
;
}
UiThread
public
static
NonNull
GeckoRuntime
create
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
create
(
context
new
GeckoRuntimeSettings
(
)
)
;
}
UiThread
public
static
NonNull
GeckoRuntime
create
(
final
NonNull
Context
context
final
NonNull
GeckoRuntimeSettings
settings
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
create
"
+
context
)
;
}
final
GeckoRuntime
runtime
=
new
GeckoRuntime
(
)
;
runtime
.
attachTo
(
context
)
;
if
(
!
runtime
.
init
(
context
settings
)
)
{
throw
new
IllegalStateException
(
"
Failed
to
initialize
GeckoRuntime
"
)
;
}
return
runtime
;
}
AnyThread
public
void
shutdown
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
shutdown
"
)
;
}
GeckoSystemStateListener
.
getInstance
(
)
.
shutdown
(
)
;
GeckoThread
.
forceQuit
(
)
;
}
public
interface
Delegate
{
UiThread
void
onShutdown
(
)
;
}
UiThread
public
void
setDelegate
(
final
Nullable
Delegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDelegate
=
delegate
;
}
UiThread
public
Nullable
Delegate
getDelegate
(
)
{
return
mDelegate
;
}
AnyThread
public
NonNull
GeckoRuntimeSettings
getSettings
(
)
{
return
mSettings
;
}
void
setPref
(
final
String
name
final
Object
value
boolean
override
)
{
if
(
override
|
|
!
GeckoAppShell
.
isFennec
(
)
)
{
PrefsHelper
.
setPref
(
name
value
false
)
;
}
}
UiThread
public
NonNull
RuntimeTelemetry
getTelemetry
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mTelemetry
=
=
null
)
{
mTelemetry
=
new
RuntimeTelemetry
(
this
)
;
}
return
mTelemetry
;
}
UiThread
public
Nullable
File
getProfileDir
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
GeckoThread
.
getActiveProfile
(
)
.
getDir
(
)
;
}
UiThread
public
void
orientationChanged
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
)
;
}
UiThread
public
void
orientationChanged
(
int
newOrientation
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
newOrientation
)
;
}
Override
AnyThread
public
int
describeContents
(
)
{
return
0
;
}
Override
AnyThread
public
void
writeToParcel
(
Parcel
out
int
flags
)
{
out
.
writeParcelable
(
mSettings
flags
)
;
}
AnyThread
public
void
readFromParcel
(
final
NonNull
Parcel
source
)
{
mSettings
=
source
.
readParcelable
(
getClass
(
)
.
getClassLoader
(
)
)
;
}
public
static
final
Parcelable
.
Creator
<
GeckoRuntime
>
CREATOR
=
new
Parcelable
.
Creator
<
GeckoRuntime
>
(
)
{
Override
AnyThread
public
GeckoRuntime
createFromParcel
(
final
Parcel
in
)
{
final
GeckoRuntime
runtime
=
new
GeckoRuntime
(
)
;
runtime
.
readFromParcel
(
in
)
;
return
runtime
;
}
Override
AnyThread
public
GeckoRuntime
[
]
newArray
(
final
int
size
)
{
return
new
GeckoRuntime
[
size
]
;
}
}
;
}
