package
org
.
mozilla
.
geckoview
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
app
.
ActivityManager
;
import
android
.
app
.
PendingIntent
;
import
android
.
app
.
Service
;
import
android
.
content
.
ComponentName
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
ActivityInfo
;
import
android
.
content
.
pm
.
ApplicationInfo
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ServiceInfo
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
os
.
Process
;
import
android
.
provider
.
Settings
;
import
android
.
text
.
format
.
DateFormat
;
import
android
.
util
.
Log
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
StringDef
;
import
androidx
.
annotation
.
UiThread
;
import
androidx
.
lifecycle
.
Lifecycle
;
import
androidx
.
lifecycle
.
LifecycleObserver
;
import
androidx
.
lifecycle
.
OnLifecycleEvent
;
import
androidx
.
lifecycle
.
ProcessLifecycleOwner
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
org
.
mozilla
.
gecko
.
Clipboard
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoNetworkManager
;
import
org
.
mozilla
.
gecko
.
GeckoScreenChangeListener
;
import
org
.
mozilla
.
gecko
.
GeckoScreenOrientation
;
import
org
.
mozilla
.
gecko
.
GeckoScreenOrientation
.
ScreenOrientation
;
import
org
.
mozilla
.
gecko
.
GeckoSystemStateListener
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
crashhelper
.
CrashHelper
;
import
org
.
mozilla
.
gecko
.
process
.
MemoryController
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
DebugConfig
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
public
final
class
GeckoRuntime
implements
Parcelable
{
private
static
final
String
LOGTAG
=
"
GeckoRuntime
"
;
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
CONFIG_FILE_PATH_TEMPLATE
=
"
/
data
/
local
/
tmp
/
%
s
-
geckoview
-
config
.
yaml
"
;
public
static
final
String
ACTION_CRASHED
=
"
org
.
mozilla
.
gecko
.
ACTION_CRASHED
"
;
public
static
final
String
EXTRA_MINIDUMP_PATH
=
"
minidumpPath
"
;
public
static
final
String
EXTRA_EXTRAS_PATH
=
"
extrasPath
"
;
public
static
final
String
EXTRA_CRASH_PROCESS_TYPE
=
"
processType
"
;
public
static
final
String
EXTRA_CRASH_REMOTE_TYPE
=
"
remoteType
"
;
public
static
final
String
CRASHED_PROCESS_TYPE_MAIN
=
"
MAIN
"
;
public
static
final
String
CRASHED_PROCESS_TYPE_FOREGROUND_CHILD
=
"
FOREGROUND_CHILD
"
;
public
static
final
String
CRASHED_PROCESS_TYPE_BACKGROUND_CHILD
=
"
BACKGROUND_CHILD
"
;
private
final
MemoryController
mMemoryController
=
new
MemoryController
(
)
;
Retention
(
RetentionPolicy
.
SOURCE
)
StringDef
(
value
=
{
CRASHED_PROCESS_TYPE_MAIN
CRASHED_PROCESS_TYPE_FOREGROUND_CHILD
CRASHED_PROCESS_TYPE_BACKGROUND_CHILD
}
)
public
interface
CrashedProcessType
{
}
private
final
class
LifecycleListener
implements
LifecycleObserver
{
private
boolean
mPaused
=
false
;
public
LifecycleListener
(
)
{
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_CREATE
)
void
onCreate
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onCreate
"
)
;
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_START
)
void
onStart
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onStart
"
)
;
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_RESUME
)
void
onResume
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onResume
"
)
;
if
(
mPaused
)
{
GeckoThread
.
onResume
(
)
;
}
else
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
InitialForeground
"
null
)
;
}
mPaused
=
false
;
GeckoAppShell
.
resumeLocation
(
)
;
GeckoNetworkManager
.
getInstance
(
)
.
start
(
GeckoAppShell
.
getApplicationContext
(
)
)
;
GeckoAppShell
.
setIs24HourFormat
(
DateFormat
.
is24HourFormat
(
GeckoAppShell
.
getApplicationContext
(
)
)
)
;
ThreadUtils
.
sGeckoHandler
.
post
(
(
)
-
>
{
Clipboard
.
updateSequenceNumber
(
GeckoAppShell
.
getApplicationContext
(
)
)
;
}
)
;
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_PAUSE
)
void
onPause
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onPause
"
)
;
mPaused
=
true
;
GeckoAppShell
.
pauseLocation
(
)
;
GeckoNetworkManager
.
getInstance
(
)
.
stop
(
)
;
GeckoThread
.
onPause
(
)
;
Clipboard
.
onPause
(
)
;
}
}
private
static
GeckoRuntime
sDefaultRuntime
;
UiThread
public
static
synchronized
NonNull
GeckoRuntime
getDefault
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
getDefault
"
)
;
}
if
(
sDefaultRuntime
=
=
null
)
{
sDefaultRuntime
=
new
GeckoRuntime
(
)
;
sDefaultRuntime
.
attachTo
(
context
)
;
sDefaultRuntime
.
init
(
context
new
GeckoRuntimeSettings
(
)
)
;
}
return
sDefaultRuntime
;
}
private
static
GeckoRuntime
sRuntime
;
private
GeckoRuntimeSettings
mSettings
;
private
Delegate
mDelegate
;
private
ServiceWorkerDelegate
mServiceWorkerDelegate
;
private
WebNotificationDelegate
mNotificationDelegate
;
private
ActivityDelegate
mActivityDelegate
;
private
OrientationController
mOrientationController
;
private
StorageController
mStorageController
;
private
final
WebExtensionController
mWebExtensionController
;
private
WebPushController
mPushController
;
private
final
ContentBlockingController
mContentBlockingController
;
private
final
Autocomplete
.
StorageProxy
mAutocompleteStorageProxy
;
private
final
ProfilerController
mProfilerController
;
private
final
GeckoScreenChangeListener
mScreenChangeListener
;
private
GeckoRuntime
(
)
{
mWebExtensionController
=
new
WebExtensionController
(
this
)
;
mContentBlockingController
=
new
ContentBlockingController
(
)
;
mAutocompleteStorageProxy
=
new
Autocomplete
.
StorageProxy
(
)
;
mProfilerController
=
new
ProfilerController
(
)
;
mScreenChangeListener
=
new
GeckoScreenChangeListener
(
)
;
if
(
sRuntime
!
=
null
)
{
throw
new
IllegalStateException
(
"
Only
one
GeckoRuntime
instance
is
allowed
"
)
;
}
sRuntime
=
this
;
}
WrapForJNI
UiThread
Nullable
static
GeckoRuntime
getInstance
(
)
{
return
sRuntime
;
}
SuppressLint
(
"
WrongThread
"
)
UiThread
private
static
NonNull
GeckoResult
<
GeckoSession
>
serviceWorkerOpenWindow
(
final
NonNull
String
url
)
{
if
(
sRuntime
!
=
null
&
&
sRuntime
.
mServiceWorkerDelegate
!
=
null
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
sRuntime
.
mServiceWorkerDelegate
.
onOpenWindow
(
url
)
;
}
return
GeckoResult
.
fromException
(
new
java
.
lang
.
RuntimeException
(
"
No
available
Service
Worker
delegate
.
"
)
)
;
}
UiThread
public
void
attachTo
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
attachTo
"
+
context
.
getApplicationContext
(
)
)
;
}
final
Context
appContext
=
context
.
getApplicationContext
(
)
;
if
(
!
appContext
.
equals
(
GeckoAppShell
.
getApplicationContext
(
)
)
)
{
GeckoAppShell
.
setApplicationContext
(
appContext
)
;
}
}
private
final
BundleEventListener
mEventListener
=
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
Class
<
?
>
crashHandler
=
GeckoRuntime
.
this
.
getSettings
(
)
.
mCrashHandler
;
if
(
"
Gecko
:
Exited
"
.
equals
(
event
)
&
&
mDelegate
!
=
null
)
{
mDelegate
.
onShutdown
(
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
mEventListener
"
Gecko
:
Exited
"
)
;
}
else
if
(
"
GeckoView
:
Test
:
NewTab
"
.
equals
(
event
)
)
{
final
String
url
=
message
.
getString
(
"
url
"
"
about
:
blank
"
)
;
serviceWorkerOpenWindow
(
url
)
.
then
(
(
GeckoResult
.
OnValueListener
<
GeckoSession
Void
>
)
session
-
>
{
if
(
session
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
null
;
}
if
(
!
session
.
isOpen
(
)
)
{
session
.
open
(
sRuntime
)
;
}
callback
.
sendSuccess
(
session
.
getId
(
)
)
;
return
null
;
}
)
.
exceptionally
(
(
GeckoResult
.
OnExceptionListener
<
Void
>
)
error
-
>
{
callback
.
sendError
(
error
+
"
Could
not
open
tab
.
"
)
;
return
null
;
}
)
;
}
else
if
(
"
GeckoView
:
ChildCrashReport
"
.
equals
(
event
)
&
&
crashHandler
!
=
null
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
Intent
i
=
new
Intent
(
ACTION_CRASHED
null
context
crashHandler
)
;
i
.
putExtra
(
EXTRA_MINIDUMP_PATH
message
.
getString
(
EXTRA_MINIDUMP_PATH
)
)
;
i
.
putExtra
(
EXTRA_EXTRAS_PATH
message
.
getString
(
EXTRA_EXTRAS_PATH
)
)
;
i
.
putExtra
(
EXTRA_CRASH_PROCESS_TYPE
message
.
getString
(
EXTRA_CRASH_PROCESS_TYPE
)
)
;
i
.
putExtra
(
EXTRA_CRASH_REMOTE_TYPE
message
.
getString
(
EXTRA_CRASH_REMOTE_TYPE
)
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
O
)
{
context
.
startForegroundService
(
i
)
;
}
else
{
context
.
startService
(
i
)
;
}
}
else
if
(
"
GeckoView
:
ServiceWorkerOpenWindow
"
.
equals
(
event
)
)
{
final
String
url
=
message
.
getString
(
"
url
"
"
about
:
blank
"
)
;
serviceWorkerOpenWindow
(
url
)
.
then
(
(
GeckoResult
.
OnValueListener
<
GeckoSession
Void
>
)
session
-
>
{
if
(
session
=
=
null
)
{
callback
.
sendSuccess
(
null
)
;
return
null
;
}
final
boolean
isOpen
=
session
.
isOpen
(
)
;
if
(
!
isOpen
)
{
session
.
open
(
sRuntime
)
;
}
final
GeckoBundle
bundle
=
new
GeckoBundle
(
)
;
bundle
.
putBoolean
(
"
isOpen
"
isOpen
)
;
bundle
.
putString
(
"
sessionId
"
session
.
getId
(
)
)
;
callback
.
sendSuccess
(
bundle
)
;
return
null
;
}
)
.
exceptionally
(
(
GeckoResult
.
OnExceptionListener
<
Void
>
)
error
-
>
{
callback
.
sendError
(
error
+
"
Could
not
open
tab
.
"
)
;
return
null
;
}
)
;
}
}
}
;
private
static
String
getProcessName
(
final
Context
context
)
{
final
ActivityManager
manager
=
(
ActivityManager
)
context
.
getSystemService
(
Context
.
ACTIVITY_SERVICE
)
;
final
List
<
ActivityManager
.
RunningAppProcessInfo
>
infos
=
manager
.
getRunningAppProcesses
(
)
;
if
(
infos
=
=
null
)
{
return
null
;
}
for
(
final
ActivityManager
.
RunningAppProcessInfo
info
:
infos
)
{
if
(
info
.
pid
=
=
Process
.
myPid
(
)
)
{
return
info
.
processName
;
}
}
return
null
;
}
private
int
[
]
startCrashHelper
(
)
{
final
CrashHelper
.
Pipes
pipes
=
CrashHelper
.
createCrashHelperPipes
(
)
;
if
(
pipes
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Could
not
create
the
crash
reporter
IPC
pipes
"
)
;
return
new
int
[
]
{
-
1
-
1
}
;
}
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
try
{
SuppressWarnings
(
"
unchecked
"
)
final
Class
<
?
extends
Service
>
cls
=
(
Class
<
?
extends
Service
>
)
Class
.
forName
(
"
org
.
mozilla
.
gecko
.
crashhelper
.
CrashHelper
"
)
;
final
Intent
i
=
new
Intent
(
context
cls
)
;
final
File
minidumps
=
new
File
(
context
.
getFilesDir
(
)
"
minidumps
"
)
;
context
.
bindService
(
i
CrashHelper
.
createConnection
(
pipes
.
mBreakpadServer
minidumps
.
getPath
(
)
pipes
.
mListener
pipes
.
mServer
)
Context
.
BIND_AUTO_CREATE
)
;
}
catch
(
final
ClassNotFoundException
e
)
{
Log
.
w
(
LOGTAG
"
Couldn
'
t
find
the
crash
helper
class
"
)
;
}
return
new
int
[
]
{
pipes
.
mBreakpadClient
.
detachFd
(
)
pipes
.
mClient
.
detachFd
(
)
}
;
}
boolean
init
(
final
NonNull
Context
context
final
NonNull
GeckoRuntimeSettings
settings
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
init
"
)
;
}
int
flags
=
GeckoThread
.
FLAG_PRELOAD_CHILD
;
if
(
settings
.
getPauseForDebuggerEnabled
(
)
)
{
flags
|
=
GeckoThread
.
FLAG_DEBUGGING
;
}
final
Class
<
?
>
crashHandler
=
settings
.
getCrashHandler
(
)
;
if
(
crashHandler
!
=
null
)
{
try
{
final
ServiceInfo
info
=
context
.
getPackageManager
(
)
.
getServiceInfo
(
new
ComponentName
(
context
crashHandler
)
0
)
;
if
(
info
.
processName
.
equals
(
getProcessName
(
context
)
)
)
{
throw
new
IllegalArgumentException
(
"
Crash
handler
service
must
run
in
a
separate
process
"
)
;
}
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
mEventListener
"
GeckoView
:
ChildCrashReport
"
)
;
flags
|
=
GeckoThread
.
FLAG_ENABLE_NATIVE_CRASHREPORTER
;
}
catch
(
final
PackageManager
.
NameNotFoundException
e
)
{
throw
new
IllegalArgumentException
(
"
Crash
handler
must
be
registered
as
a
service
"
)
;
}
}
GeckoAppShell
.
useMaxScreenDepth
(
settings
.
getUseMaxScreenDepth
(
)
)
;
GeckoAppShell
.
setDisplayDensityOverride
(
settings
.
getDisplayDensityOverride
(
)
)
;
GeckoAppShell
.
setDisplayDpiOverride
(
settings
.
getDisplayDpiOverride
(
)
)
;
GeckoAppShell
.
setScreenSizeOverride
(
settings
.
getScreenSizeOverride
(
)
)
;
GeckoAppShell
.
setCrashHandlerService
(
settings
.
getCrashHandler
(
)
)
;
GeckoFontScaleListener
.
getInstance
(
)
.
attachToContext
(
context
settings
)
;
Bundle
extras
=
settings
.
getExtras
(
)
;
String
[
]
args
=
settings
.
getArguments
(
)
;
Map
<
String
Object
>
prefs
=
settings
.
getPrefsMap
(
)
;
String
configFilePath
=
settings
.
getConfigFilePath
(
)
;
if
(
configFilePath
=
=
null
)
{
if
(
isApplicationDebuggable
(
context
)
|
|
isApplicationCurrentDebugApp
(
context
)
)
{
configFilePath
=
String
.
format
(
CONFIG_FILE_PATH_TEMPLATE
context
.
getApplicationInfo
(
)
.
packageName
)
;
}
}
if
(
configFilePath
!
=
null
&
&
!
configFilePath
.
isEmpty
(
)
)
{
try
{
final
DebugConfig
debugConfig
=
DebugConfig
.
fromFile
(
new
File
(
configFilePath
)
)
;
Log
.
i
(
LOGTAG
"
Adding
debug
configuration
from
:
"
+
configFilePath
)
;
prefs
=
debugConfig
.
mergeIntoPrefs
(
prefs
)
;
args
=
debugConfig
.
mergeIntoArgs
(
args
)
;
extras
=
debugConfig
.
mergeIntoExtras
(
extras
)
;
}
catch
(
final
DebugConfig
.
ConfigException
e
)
{
Log
.
w
(
LOGTAG
"
Failed
to
add
debug
configuration
from
:
"
+
configFilePath
e
)
;
}
catch
(
final
FileNotFoundException
e
)
{
}
}
final
int
[
]
fds
=
startCrashHelper
(
)
;
final
GeckoThread
.
InitInfo
info
=
GeckoThread
.
InitInfo
.
builder
(
)
.
args
(
args
)
.
extras
(
extras
)
.
flags
(
flags
)
.
prefs
(
prefs
)
.
outFilePath
(
extras
!
=
null
?
extras
.
getString
(
"
out_file
"
)
:
null
)
.
fds
(
fds
)
.
build
(
)
;
if
(
info
.
xpcshell
&
&
!
"
org
.
mozilla
.
geckoview
.
test_runner
"
.
equals
(
context
.
getApplicationContext
(
)
.
getPackageName
(
)
)
)
{
throw
new
IllegalArgumentException
(
"
Only
the
test
app
can
run
-
xpcshell
.
"
)
;
}
if
(
info
.
xpcshell
)
{
settings
.
setProcessCount
(
BuildConfig
.
MOZ_ANDROID_CONTENT_SERVICE_COUNT
)
;
}
if
(
!
GeckoThread
.
init
(
info
)
)
{
Log
.
w
(
LOGTAG
"
init
failed
(
could
not
initiate
GeckoThread
)
"
)
;
return
false
;
}
if
(
!
GeckoThread
.
launch
(
)
)
{
Log
.
w
(
LOGTAG
"
init
failed
(
GeckoThread
already
launched
)
"
)
;
return
false
;
}
mSettings
=
settings
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
mEventListener
"
Gecko
:
Exited
"
"
GeckoView
:
Test
:
NewTab
"
"
GeckoView
:
ServiceWorkerOpenWindow
"
)
;
mSettings
.
attachTo
(
this
)
;
GeckoAppShell
.
getApplicationContext
(
)
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
ProcessLifecycleOwner
.
get
(
)
.
getLifecycle
(
)
.
addObserver
(
new
LifecycleListener
(
)
)
;
if
(
mScreenChangeListener
!
=
null
)
{
mScreenChangeListener
.
enable
(
)
;
}
mProfilerController
.
addMarker
(
"
GeckoView
Initialization
START
"
mProfilerController
.
getProfilerTime
(
)
)
;
return
true
;
}
private
boolean
isApplicationDebuggable
(
final
NonNull
Context
context
)
{
final
ApplicationInfo
applicationInfo
=
context
.
getApplicationInfo
(
)
;
return
(
applicationInfo
.
flags
&
ApplicationInfo
.
FLAG_DEBUGGABLE
)
!
=
0
;
}
private
boolean
isApplicationCurrentDebugApp
(
final
NonNull
Context
context
)
{
final
ApplicationInfo
applicationInfo
=
context
.
getApplicationInfo
(
)
;
final
String
currentDebugApp
=
Settings
.
Global
.
getString
(
context
.
getContentResolver
(
)
Settings
.
Global
.
DEBUG_APP
)
;
return
applicationInfo
.
packageName
.
equals
(
currentDebugApp
)
;
}
void
setDefaultPrefs
(
final
GeckoBundle
prefs
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
SetDefaultPrefs
"
prefs
)
;
}
UiThread
public
static
NonNull
GeckoRuntime
create
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
create
(
context
new
GeckoRuntimeSettings
(
)
)
;
}
UiThread
public
NonNull
WebExtensionController
getWebExtensionController
(
)
{
return
mWebExtensionController
;
}
UiThread
public
NonNull
ContentBlockingController
getContentBlockingController
(
)
{
return
mContentBlockingController
;
}
UiThread
public
NonNull
ProfilerController
getProfilerController
(
)
{
return
mProfilerController
;
}
UiThread
public
static
NonNull
GeckoRuntime
create
(
final
NonNull
Context
context
final
NonNull
GeckoRuntimeSettings
settings
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
create
"
+
context
)
;
}
final
GeckoRuntime
runtime
=
new
GeckoRuntime
(
)
;
runtime
.
attachTo
(
context
)
;
if
(
!
runtime
.
init
(
context
settings
)
)
{
throw
new
IllegalStateException
(
"
Failed
to
initialize
GeckoRuntime
"
)
;
}
context
.
registerComponentCallbacks
(
runtime
.
mMemoryController
)
;
return
runtime
;
}
AnyThread
public
void
shutdown
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
shutdown
"
)
;
}
GeckoSystemStateListener
.
getInstance
(
)
.
shutdown
(
)
;
if
(
mScreenChangeListener
!
=
null
)
{
mScreenChangeListener
.
disable
(
)
;
}
GeckoThread
.
forceQuit
(
)
;
}
public
interface
Delegate
{
UiThread
void
onShutdown
(
)
;
}
UiThread
public
void
setDelegate
(
final
Nullable
Delegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDelegate
=
delegate
;
}
UiThread
public
Nullable
Delegate
getDelegate
(
)
{
return
mDelegate
;
}
UiThread
public
void
setAutocompleteStorageDelegate
(
final
Nullable
Autocomplete
.
StorageDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mAutocompleteStorageProxy
.
setDelegate
(
delegate
)
;
}
UiThread
public
Nullable
Autocomplete
.
StorageDelegate
getAutocompleteStorageDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mAutocompleteStorageProxy
.
getDelegate
(
)
;
}
UiThread
public
interface
ServiceWorkerDelegate
{
UiThread
NonNull
GeckoResult
<
GeckoSession
>
onOpenWindow
(
NonNull
String
url
)
;
}
UiThread
public
void
setServiceWorkerDelegate
(
final
Nullable
ServiceWorkerDelegate
serviceWorkerDelegate
)
{
mServiceWorkerDelegate
=
serviceWorkerDelegate
;
}
UiThread
Nullable
public
ServiceWorkerDelegate
getServiceWorkerDelegate
(
)
{
return
mServiceWorkerDelegate
;
}
UiThread
public
void
setWebNotificationDelegate
(
final
Nullable
WebNotificationDelegate
delegate
)
{
mNotificationDelegate
=
delegate
;
}
WrapForJNI
float
textScaleFactor
(
)
{
return
getSettings
(
)
.
getFontSizeFactor
(
)
;
}
WrapForJNI
boolean
usesDarkTheme
(
)
{
switch
(
getSettings
(
)
.
getPreferredColorScheme
(
)
)
{
case
GeckoRuntimeSettings
.
COLOR_SCHEME_SYSTEM
:
return
GeckoSystemStateListener
.
getInstance
(
)
.
isNightMode
(
)
;
case
GeckoRuntimeSettings
.
COLOR_SCHEME_DARK
:
return
true
;
case
GeckoRuntimeSettings
.
COLOR_SCHEME_LIGHT
:
default
:
return
false
;
}
}
WrapForJNI
UiThread
public
Nullable
WebNotificationDelegate
getWebNotificationDelegate
(
)
{
return
mNotificationDelegate
;
}
WrapForJNI
AnyThread
private
void
notifyOnShow
(
final
WebNotification
notification
)
{
ThreadUtils
.
runOnUiThread
(
(
)
-
>
{
if
(
mNotificationDelegate
!
=
null
)
{
mNotificationDelegate
.
onShowNotification
(
notification
)
;
}
}
)
;
}
WrapForJNI
AnyThread
private
void
notifyOnClose
(
final
WebNotification
notification
)
{
ThreadUtils
.
runOnUiThread
(
(
)
-
>
{
if
(
mNotificationDelegate
!
=
null
)
{
mNotificationDelegate
.
onCloseNotification
(
notification
)
;
}
}
)
;
}
public
interface
ActivityDelegate
{
UiThread
Nullable
GeckoResult
<
Intent
>
onStartActivityForResult
(
NonNull
PendingIntent
intent
)
;
}
UiThread
public
void
setActivityDelegate
(
final
Nullable
ActivityDelegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mActivityDelegate
=
delegate
;
}
UiThread
public
Nullable
ActivityDelegate
getActivityDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mActivityDelegate
;
}
AnyThread
GeckoResult
<
Intent
>
startActivityForResult
(
final
NonNull
PendingIntent
intent
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
final
GeckoResult
<
Intent
>
result
=
new
GeckoResult
<
>
(
)
;
ThreadUtils
.
runOnUiThread
(
(
)
-
>
{
final
GeckoResult
<
Intent
>
delegateResult
=
startActivityForResult
(
intent
)
;
if
(
delegateResult
!
=
null
)
{
delegateResult
.
accept
(
val
-
>
result
.
complete
(
val
)
e
-
>
result
.
completeExceptionally
(
e
)
)
;
}
else
{
result
.
completeExceptionally
(
new
IllegalStateException
(
"
No
result
"
)
)
;
}
}
)
;
return
result
;
}
if
(
mActivityDelegate
=
=
null
)
{
return
GeckoResult
.
fromException
(
new
IllegalStateException
(
"
No
delegate
attached
"
)
)
;
}
SuppressLint
(
"
WrongThread
"
)
GeckoResult
<
Intent
>
result
=
mActivityDelegate
.
onStartActivityForResult
(
intent
)
;
if
(
result
=
=
null
)
{
result
=
GeckoResult
.
fromException
(
new
IllegalStateException
(
"
No
result
"
)
)
;
}
return
result
;
}
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
NonNull
GeckoRuntimeSettings
getSettings
(
)
{
return
mSettings
;
}
UiThread
public
void
orientationChanged
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
)
;
}
UiThread
public
void
configurationChanged
(
final
NonNull
Configuration
newConfig
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoSystemStateListener
.
getInstance
(
)
.
updateNightMode
(
newConfig
.
uiMode
)
;
}
UiThread
public
void
orientationChanged
(
final
int
newOrientation
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
newOrientation
)
;
}
UiThread
public
NonNull
OrientationController
getOrientationController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mOrientationController
=
=
null
)
{
mOrientationController
=
new
OrientationController
(
)
;
}
return
mOrientationController
;
}
AnyThread
private
int
toAndroidOrientation
(
final
int
geckoOrientation
)
{
if
(
geckoOrientation
=
=
ScreenOrientation
.
PORTRAIT_PRIMARY
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_PORTRAIT
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
PORTRAIT_SECONDARY
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_REVERSE_PORTRAIT
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
LANDSCAPE_PRIMARY
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_LANDSCAPE
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
LANDSCAPE_SECONDARY
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_REVERSE_LANDSCAPE
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
DEFAULT
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_UNSPECIFIED
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
PORTRAIT
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_SENSOR_PORTRAIT
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
LANDSCAPE
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_SENSOR_LANDSCAPE
;
}
else
if
(
geckoOrientation
=
=
ScreenOrientation
.
ANY
.
value
)
{
return
ActivityInfo
.
SCREEN_ORIENTATION_FULL_SENSOR
;
}
return
ActivityInfo
.
SCREEN_ORIENTATION_PORTRAIT
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
NonNull
GeckoResult
<
Boolean
>
lockScreenOrientation
(
final
int
aOrientation
)
{
final
GeckoResult
<
Boolean
>
res
=
new
GeckoResult
<
>
(
)
;
ThreadUtils
.
runOnUiThread
(
(
)
-
>
{
final
OrientationController
.
OrientationDelegate
delegate
=
getOrientationController
(
)
.
getDelegate
(
)
;
if
(
delegate
=
=
null
)
{
res
.
completeExceptionally
(
new
Exception
(
"
Not
supported
"
)
)
;
return
;
}
final
GeckoResult
<
AllowOrDeny
>
response
=
delegate
.
onOrientationLock
(
toAndroidOrientation
(
aOrientation
)
)
;
if
(
response
=
=
null
)
{
res
.
completeExceptionally
(
new
Exception
(
"
Not
supported
"
)
)
;
return
;
}
res
.
completeFrom
(
response
.
map
(
v
-
>
v
=
=
AllowOrDeny
.
ALLOW
)
)
;
}
)
;
return
res
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
void
unlockScreenOrientation
(
)
{
ThreadUtils
.
runOnUiThread
(
(
)
-
>
{
final
OrientationController
.
OrientationDelegate
delegate
=
getOrientationController
(
)
.
getDelegate
(
)
;
if
(
delegate
!
=
null
)
{
delegate
.
onOrientationUnlock
(
)
;
}
}
)
;
}
UiThread
public
NonNull
StorageController
getStorageController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mStorageController
=
=
null
)
{
mStorageController
=
new
StorageController
(
)
;
}
return
mStorageController
;
}
UiThread
public
NonNull
WebPushController
getWebPushController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mPushController
=
=
null
)
{
mPushController
=
new
WebPushController
(
)
;
}
return
mPushController
;
}
AnyThread
public
void
appendAppNotesToCrashReport
(
NonNull
final
String
notes
)
{
final
String
notesWithNewLine
=
notes
+
"
\
n
"
;
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
PROFILE_READY
)
)
{
GeckoAppShell
.
nativeAppendAppNotesToCrashReport
(
notesWithNewLine
)
;
}
else
{
GeckoThread
.
queueNativeCallUntil
(
GeckoThread
.
State
.
PROFILE_READY
GeckoAppShell
.
class
"
nativeAppendAppNotesToCrashReport
"
String
.
class
notesWithNewLine
)
;
}
GeckoAppShell
.
appendAppNotesToCrashReport
(
notes
)
;
}
Override
AnyThread
public
int
describeContents
(
)
{
return
0
;
}
Override
AnyThread
public
void
writeToParcel
(
final
Parcel
out
final
int
flags
)
{
out
.
writeParcelable
(
mSettings
flags
)
;
}
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
void
readFromParcel
(
final
NonNull
Parcel
source
)
{
mSettings
=
source
.
readParcelable
(
getClass
(
)
.
getClassLoader
(
)
)
;
}
public
static
final
Parcelable
.
Creator
<
GeckoRuntime
>
CREATOR
=
new
Parcelable
.
Creator
<
GeckoRuntime
>
(
)
{
Override
AnyThread
public
GeckoRuntime
createFromParcel
(
final
Parcel
in
)
{
final
GeckoRuntime
runtime
=
new
GeckoRuntime
(
)
;
runtime
.
readFromParcel
(
in
)
;
return
runtime
;
}
Override
AnyThread
public
GeckoRuntime
[
]
newArray
(
final
int
size
)
{
return
new
GeckoRuntime
[
size
]
;
}
}
;
AnyThread
public
boolean
isInteractiveWidgetDefaultResizesVisual
(
)
{
if
(
!
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
JNI_READY
)
)
{
return
false
;
}
return
GeckoAppShell
.
isInteractiveWidgetDefaultResizesVisual
(
)
;
}
}
