package
org
.
mozilla
.
geckoview
;
import
android
.
arch
.
lifecycle
.
ProcessLifecycleOwner
;
import
android
.
arch
.
lifecycle
.
Lifecycle
;
import
android
.
arch
.
lifecycle
.
LifecycleObserver
;
import
android
.
arch
.
lifecycle
.
OnLifecycleEvent
;
import
android
.
app
.
ActivityManager
;
import
android
.
content
.
ComponentName
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ServiceInfo
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
os
.
Build
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
os
.
Process
;
import
android
.
support
.
annotation
.
AnyThread
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
UiThread
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoNetworkManager
;
import
org
.
mozilla
.
gecko
.
GeckoScreenOrientation
;
import
org
.
mozilla
.
gecko
.
GeckoSystemStateListener
;
import
org
.
mozilla
.
gecko
.
GeckoThread
;
import
org
.
mozilla
.
gecko
.
PrefsHelper
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
ContextUtils
;
import
org
.
mozilla
.
gecko
.
util
.
DebugConfig
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
yaml
.
snakeyaml
.
error
.
YAMLException
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
net
.
URI
;
public
final
class
GeckoRuntime
implements
Parcelable
{
private
static
final
String
LOGTAG
=
"
GeckoRuntime
"
;
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
CONFIG_FILE_PATH_TEMPLATE
=
"
/
data
/
local
/
tmp
/
%
s
-
geckoview
-
config
.
yaml
"
;
public
static
final
String
ACTION_CRASHED
=
"
org
.
mozilla
.
gecko
.
ACTION_CRASHED
"
;
public
static
final
String
EXTRA_MINIDUMP_PATH
=
"
minidumpPath
"
;
public
static
final
String
EXTRA_EXTRAS_PATH
=
"
extrasPath
"
;
public
static
final
String
EXTRA_CRASH_FATAL
=
"
fatal
"
;
private
final
class
LifecycleListener
implements
LifecycleObserver
{
private
boolean
mPaused
=
false
;
public
LifecycleListener
(
)
{
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_CREATE
)
void
onCreate
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onCreate
"
)
;
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_START
)
void
onStart
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onStart
"
)
;
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_RESUME
)
void
onResume
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onResume
"
)
;
if
(
mPaused
)
{
GeckoThread
.
onResume
(
)
;
}
mPaused
=
false
;
GeckoNetworkManager
.
getInstance
(
)
.
start
(
GeckoAppShell
.
getApplicationContext
(
)
)
;
}
OnLifecycleEvent
(
Lifecycle
.
Event
.
ON_PAUSE
)
void
onPause
(
)
{
Log
.
d
(
LOGTAG
"
Lifecycle
:
onPause
"
)
;
mPaused
=
true
;
GeckoNetworkManager
.
getInstance
(
)
.
stop
(
)
;
GeckoThread
.
onPause
(
)
;
}
}
private
static
GeckoRuntime
sDefaultRuntime
;
UiThread
public
static
synchronized
NonNull
GeckoRuntime
getDefault
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
getDefault
"
)
;
}
if
(
sDefaultRuntime
=
=
null
)
{
sDefaultRuntime
=
new
GeckoRuntime
(
)
;
sDefaultRuntime
.
attachTo
(
context
)
;
sDefaultRuntime
.
init
(
context
new
GeckoRuntimeSettings
(
)
)
;
}
return
sDefaultRuntime
;
}
private
static
GeckoRuntime
sRuntime
;
private
GeckoRuntimeSettings
mSettings
;
private
Delegate
mDelegate
;
private
ServiceWorkerDelegate
mServiceWorkerDelegate
;
private
WebNotificationDelegate
mNotificationDelegate
;
private
RuntimeTelemetry
mTelemetry
;
private
StorageController
mStorageController
;
private
final
WebExtensionController
mWebExtensionController
;
private
WebPushController
mPushController
;
private
final
ContentBlockingController
mContentBlockingController
;
private
GeckoRuntime
(
)
{
mWebExtensionController
=
new
WebExtensionController
(
this
)
;
mContentBlockingController
=
new
ContentBlockingController
(
)
;
if
(
sRuntime
!
=
null
)
{
throw
new
IllegalStateException
(
"
Only
one
GeckoRuntime
instance
is
allowed
"
)
;
}
sRuntime
=
this
;
}
WrapForJNI
UiThread
private
Nullable
static
GeckoRuntime
getInstance
(
)
{
return
sRuntime
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
NonNull
GeckoResult
<
String
>
serviceWorkerOpenWindow
(
final
NonNull
String
baseUrl
final
NonNull
String
url
)
{
if
(
sRuntime
!
=
null
&
&
sRuntime
.
mServiceWorkerDelegate
!
=
null
)
{
final
URI
actual
=
URI
.
create
(
baseUrl
)
.
resolve
(
url
)
;
GeckoResult
<
String
>
result
=
new
GeckoResult
<
>
(
)
;
ThreadUtils
.
postToUiThread
(
(
)
-
>
{
sRuntime
.
mServiceWorkerDelegate
.
onOpenWindow
(
actual
.
toString
(
)
)
.
accept
(
session
-
>
{
if
(
session
!
=
null
)
{
if
(
!
session
.
isOpen
(
)
)
{
result
.
completeExceptionally
(
new
RuntimeException
(
"
Returned
GeckoSession
must
be
open
.
"
)
)
;
}
else
{
session
.
loadUri
(
actual
.
toString
(
)
)
;
result
.
complete
(
session
.
getId
(
)
)
;
}
}
else
{
result
.
complete
(
null
)
;
}
}
)
;
}
)
;
return
result
;
}
else
{
return
GeckoResult
.
fromException
(
new
java
.
lang
.
RuntimeException
(
"
No
available
Service
Worker
delegate
.
"
)
)
;
}
}
UiThread
public
void
attachTo
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
attachTo
"
+
context
.
getApplicationContext
(
)
)
;
}
final
Context
appContext
=
context
.
getApplicationContext
(
)
;
if
(
!
appContext
.
equals
(
GeckoAppShell
.
getApplicationContext
(
)
)
)
{
GeckoAppShell
.
setApplicationContext
(
appContext
)
;
}
}
private
final
BundleEventListener
mEventListener
=
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
Class
<
?
>
crashHandler
=
GeckoRuntime
.
this
.
getSettings
(
)
.
mCrashHandler
;
if
(
"
Gecko
:
Exited
"
.
equals
(
event
)
&
&
mDelegate
!
=
null
)
{
mDelegate
.
onShutdown
(
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
mEventListener
"
Gecko
:
Exited
"
)
;
}
else
if
(
"
GeckoView
:
ContentCrashReport
"
.
equals
(
event
)
&
&
crashHandler
!
=
null
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
Intent
i
=
new
Intent
(
ACTION_CRASHED
null
context
crashHandler
)
;
i
.
putExtra
(
EXTRA_MINIDUMP_PATH
message
.
getString
(
EXTRA_MINIDUMP_PATH
)
)
;
i
.
putExtra
(
EXTRA_EXTRAS_PATH
message
.
getString
(
EXTRA_EXTRAS_PATH
)
)
;
i
.
putExtra
(
EXTRA_CRASH_FATAL
message
.
getBoolean
(
EXTRA_CRASH_FATAL
true
)
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
O
)
{
context
.
startForegroundService
(
i
)
;
}
else
{
context
.
startService
(
i
)
;
}
}
}
}
;
private
static
String
getProcessName
(
final
Context
context
)
{
final
ActivityManager
manager
=
(
ActivityManager
)
context
.
getSystemService
(
Context
.
ACTIVITY_SERVICE
)
;
for
(
final
ActivityManager
.
RunningAppProcessInfo
info
:
manager
.
getRunningAppProcesses
(
)
)
{
if
(
info
.
pid
=
=
Process
.
myPid
(
)
)
{
return
info
.
processName
;
}
}
return
null
;
}
boolean
init
(
final
NonNull
Context
context
final
NonNull
GeckoRuntimeSettings
settings
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
init
"
)
;
}
int
flags
=
0
;
if
(
settings
.
getUseContentProcessHint
(
)
)
{
flags
|
=
GeckoThread
.
FLAG_PRELOAD_CHILD
;
}
if
(
settings
.
getPauseForDebuggerEnabled
(
)
)
{
flags
|
=
GeckoThread
.
FLAG_DEBUGGING
;
}
final
Class
<
?
>
crashHandler
=
settings
.
getCrashHandler
(
)
;
if
(
crashHandler
!
=
null
)
{
try
{
final
ServiceInfo
info
=
context
.
getPackageManager
(
)
.
getServiceInfo
(
new
ComponentName
(
context
crashHandler
)
0
)
;
if
(
info
.
processName
.
equals
(
getProcessName
(
context
)
)
)
{
throw
new
IllegalArgumentException
(
"
Crash
handler
service
must
run
in
a
separate
process
"
)
;
}
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
mEventListener
"
GeckoView
:
ContentCrashReport
"
)
;
flags
|
=
GeckoThread
.
FLAG_ENABLE_NATIVE_CRASHREPORTER
;
}
catch
(
PackageManager
.
NameNotFoundException
e
)
{
throw
new
IllegalArgumentException
(
"
Crash
handler
must
be
registered
as
a
service
"
)
;
}
}
GeckoAppShell
.
useMaxScreenDepth
(
settings
.
getUseMaxScreenDepth
(
)
)
;
GeckoAppShell
.
setDisplayDensityOverride
(
settings
.
getDisplayDensityOverride
(
)
)
;
GeckoAppShell
.
setDisplayDpiOverride
(
settings
.
getDisplayDpiOverride
(
)
)
;
GeckoAppShell
.
setScreenSizeOverride
(
settings
.
getScreenSizeOverride
(
)
)
;
GeckoAppShell
.
setCrashHandlerService
(
settings
.
getCrashHandler
(
)
)
;
GeckoFontScaleListener
.
getInstance
(
)
.
attachToContext
(
context
settings
)
;
final
GeckoThread
.
InitInfo
info
=
new
GeckoThread
.
InitInfo
(
)
;
info
.
args
=
settings
.
getArguments
(
)
;
info
.
extras
=
settings
.
getExtras
(
)
;
info
.
flags
=
flags
;
info
.
prefs
=
settings
.
getPrefsMap
(
)
;
String
configFilePath
=
settings
.
getConfigFilePath
(
)
;
if
(
configFilePath
=
=
null
)
{
if
(
ContextUtils
.
isApplicationDebuggable
(
context
)
|
|
ContextUtils
.
isApplicationCurrentDebugApp
(
context
)
)
{
configFilePath
=
String
.
format
(
CONFIG_FILE_PATH_TEMPLATE
context
.
getApplicationInfo
(
)
.
packageName
)
;
}
}
if
(
configFilePath
!
=
null
&
&
!
configFilePath
.
isEmpty
(
)
)
{
try
{
final
DebugConfig
debugConfig
=
DebugConfig
.
fromFile
(
new
File
(
configFilePath
)
)
;
Log
.
i
(
LOGTAG
"
Adding
debug
configuration
from
:
"
+
configFilePath
)
;
debugConfig
.
mergeIntoInitInfo
(
info
)
;
}
catch
(
YAMLException
e
)
{
Log
.
w
(
LOGTAG
"
Failed
to
add
debug
configuration
from
:
"
+
configFilePath
e
)
;
}
catch
(
FileNotFoundException
e
)
{
}
}
if
(
!
GeckoThread
.
init
(
info
)
)
{
Log
.
w
(
LOGTAG
"
init
failed
(
could
not
initiate
GeckoThread
)
"
)
;
return
false
;
}
if
(
!
GeckoThread
.
launch
(
)
)
{
Log
.
w
(
LOGTAG
"
init
failed
(
GeckoThread
already
launched
)
"
)
;
return
false
;
}
mSettings
=
settings
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
mEventListener
"
Gecko
:
Exited
"
)
;
mSettings
.
attachTo
(
this
)
;
GeckoAppShell
.
getApplicationContext
(
)
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
ProcessLifecycleOwner
.
get
(
)
.
getLifecycle
(
)
.
addObserver
(
new
LifecycleListener
(
)
)
;
return
true
;
}
void
setDefaultPrefs
(
final
GeckoBundle
prefs
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
SetDefaultPrefs
"
prefs
)
;
}
UiThread
public
static
NonNull
GeckoRuntime
create
(
final
NonNull
Context
context
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
create
(
context
new
GeckoRuntimeSettings
(
)
)
;
}
UiThread
public
NonNull
WebExtensionController
getWebExtensionController
(
)
{
return
mWebExtensionController
;
}
UiThread
public
NonNull
ContentBlockingController
getContentBlockingController
(
)
{
return
mContentBlockingController
;
}
UiThread
public
NonNull
GeckoResult
<
Void
>
registerWebExtension
(
final
NonNull
WebExtension
webExtension
)
{
final
CallbackResult
<
Void
>
result
=
new
CallbackResult
<
Void
>
(
)
{
Override
public
void
sendSuccess
(
final
Object
response
)
{
complete
(
null
)
;
}
}
;
final
GeckoBundle
bundle
=
new
GeckoBundle
(
3
)
;
bundle
.
putString
(
"
locationUri
"
webExtension
.
location
)
;
bundle
.
putString
(
"
id
"
webExtension
.
id
)
;
bundle
.
putBoolean
(
"
allowContentMessaging
"
(
webExtension
.
flags
&
WebExtension
.
Flags
.
ALLOW_CONTENT_MESSAGING
)
>
0
)
;
mWebExtensionController
.
registerWebExtension
(
webExtension
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
RegisterWebExtension
"
bundle
result
)
;
return
result
;
}
UiThread
public
NonNull
GeckoResult
<
Void
>
unregisterWebExtension
(
final
NonNull
WebExtension
webExtension
)
{
final
CallbackResult
<
Void
>
result
=
new
CallbackResult
<
Void
>
(
)
{
Override
public
void
sendSuccess
(
final
Object
response
)
{
complete
(
null
)
;
}
}
;
final
GeckoBundle
bundle
=
new
GeckoBundle
(
1
)
;
bundle
.
putString
(
"
id
"
webExtension
.
id
)
;
mWebExtensionController
.
unregisterWebExtension
(
webExtension
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
GeckoView
:
UnregisterWebExtension
"
bundle
result
)
;
return
result
;
}
UiThread
public
static
NonNull
GeckoRuntime
create
(
final
NonNull
Context
context
final
NonNull
GeckoRuntimeSettings
settings
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
create
"
+
context
)
;
}
final
GeckoRuntime
runtime
=
new
GeckoRuntime
(
)
;
runtime
.
attachTo
(
context
)
;
if
(
!
runtime
.
init
(
context
settings
)
)
{
throw
new
IllegalStateException
(
"
Failed
to
initialize
GeckoRuntime
"
)
;
}
return
runtime
;
}
AnyThread
public
void
shutdown
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
shutdown
"
)
;
}
GeckoSystemStateListener
.
getInstance
(
)
.
shutdown
(
)
;
GeckoThread
.
forceQuit
(
)
;
}
public
interface
Delegate
{
UiThread
void
onShutdown
(
)
;
}
UiThread
public
void
setDelegate
(
final
Nullable
Delegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDelegate
=
delegate
;
}
UiThread
public
Nullable
Delegate
getDelegate
(
)
{
return
mDelegate
;
}
UiThread
public
interface
ServiceWorkerDelegate
{
UiThread
NonNull
GeckoResult
<
GeckoSession
>
onOpenWindow
(
NonNull
String
url
)
;
}
UiThread
public
void
setServiceWorkerDelegate
(
final
Nullable
ServiceWorkerDelegate
serviceWorkerDelegate
)
{
mServiceWorkerDelegate
=
serviceWorkerDelegate
;
}
UiThread
public
void
setWebNotificationDelegate
(
final
Nullable
WebNotificationDelegate
delegate
)
{
mNotificationDelegate
=
delegate
;
}
WrapForJNI
UiThread
public
Nullable
WebNotificationDelegate
getWebNotificationDelegate
(
)
{
return
mNotificationDelegate
;
}
WrapForJNI
UiThread
private
void
notifyOnShow
(
final
WebNotification
notification
)
{
ThreadUtils
.
getUiHandler
(
)
.
post
(
(
)
-
>
{
if
(
mNotificationDelegate
!
=
null
)
{
mNotificationDelegate
.
onShowNotification
(
notification
)
;
}
}
)
;
}
WrapForJNI
UiThread
private
void
notifyOnClose
(
final
WebNotification
notification
)
{
ThreadUtils
.
getUiHandler
(
)
.
post
(
(
)
-
>
{
if
(
mNotificationDelegate
!
=
null
)
{
mNotificationDelegate
.
onCloseNotification
(
notification
)
;
}
}
)
;
}
AnyThread
public
NonNull
GeckoRuntimeSettings
getSettings
(
)
{
return
mSettings
;
}
void
setPref
(
final
String
name
final
Object
value
)
{
PrefsHelper
.
setPref
(
name
value
false
)
;
}
UiThread
public
NonNull
RuntimeTelemetry
getTelemetry
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mTelemetry
=
=
null
)
{
mTelemetry
=
new
RuntimeTelemetry
(
this
)
;
}
return
mTelemetry
;
}
UiThread
public
Nullable
File
getProfileDir
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
GeckoThread
.
getActiveProfile
(
)
.
getDir
(
)
;
}
UiThread
public
void
orientationChanged
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
)
;
}
UiThread
public
void
configurationChanged
(
final
NonNull
Configuration
newConfig
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoSystemStateListener
.
getInstance
(
)
.
updateNightMode
(
newConfig
.
uiMode
)
;
}
UiThread
public
void
orientationChanged
(
final
int
newOrientation
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
newOrientation
)
;
}
UiThread
public
NonNull
StorageController
getStorageController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mStorageController
=
=
null
)
{
mStorageController
=
new
StorageController
(
)
;
}
return
mStorageController
;
}
UiThread
public
NonNull
WebPushController
getWebPushController
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mPushController
=
=
null
)
{
mPushController
=
new
WebPushController
(
)
;
}
return
mPushController
;
}
Override
AnyThread
public
int
describeContents
(
)
{
return
0
;
}
Override
AnyThread
public
void
writeToParcel
(
final
Parcel
out
final
int
flags
)
{
out
.
writeParcelable
(
mSettings
flags
)
;
}
AnyThread
public
void
readFromParcel
(
final
NonNull
Parcel
source
)
{
mSettings
=
source
.
readParcelable
(
getClass
(
)
.
getClassLoader
(
)
)
;
}
public
static
final
Parcelable
.
Creator
<
GeckoRuntime
>
CREATOR
=
new
Parcelable
.
Creator
<
GeckoRuntime
>
(
)
{
Override
AnyThread
public
GeckoRuntime
createFromParcel
(
final
Parcel
in
)
{
final
GeckoRuntime
runtime
=
new
GeckoRuntime
(
)
;
runtime
.
readFromParcel
(
in
)
;
return
runtime
;
}
Override
AnyThread
public
GeckoRuntime
[
]
newArray
(
final
int
size
)
{
return
new
GeckoRuntime
[
size
]
;
}
}
;
}
