package
org
.
mozilla
.
geckoview
;
import
android
.
annotation
.
TargetApi
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
Build
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewStructure
;
import
android
.
view
.
autofill
.
AutofillValue
;
import
androidx
.
annotation
.
AnyThread
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
NonNull
;
import
androidx
.
annotation
.
Nullable
;
import
androidx
.
annotation
.
UiThread
;
import
androidx
.
collection
.
ArrayMap
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Map
;
import
java
.
util
.
Objects
;
import
java
.
util
.
UUID
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
public
class
Autofill
{
private
static
final
boolean
DEBUG
=
false
;
public
interface
AutofillNotify
{
}
public
static
final
class
Hint
{
private
Hint
(
)
{
}
public
static
final
int
NONE
=
-
1
;
public
static
final
int
EMAIL_ADDRESS
=
0
;
public
static
final
int
PASSWORD
=
1
;
public
static
final
int
URI
=
2
;
public
static
final
int
USERNAME
=
3
;
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
static
Nullable
String
toString
(
final
AutofillHint
int
hint
)
{
final
int
idx
=
hint
+
1
;
final
String
[
]
map
=
new
String
[
]
{
"
NONE
"
"
EMAIL
"
"
PASSWORD
"
"
URI
"
"
USERNAME
"
}
;
if
(
idx
<
0
|
|
idx
>
=
map
.
length
)
{
return
null
;
}
return
map
[
idx
]
;
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
Hint
.
NONE
Hint
.
EMAIL_ADDRESS
Hint
.
PASSWORD
Hint
.
URI
Hint
.
USERNAME
}
)
public
interface
AutofillHint
{
}
public
static
final
class
InputType
{
private
InputType
(
)
{
}
public
static
final
int
NONE
=
-
1
;
public
static
final
int
TEXT
=
0
;
public
static
final
int
NUMBER
=
1
;
public
static
final
int
PHONE
=
2
;
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
static
Nullable
String
toString
(
final
AutofillInputType
int
type
)
{
final
int
idx
=
type
+
1
;
final
String
[
]
map
=
new
String
[
]
{
"
NONE
"
"
TEXT
"
"
NUMBER
"
"
PHONE
"
}
;
if
(
idx
<
0
|
|
idx
>
=
map
.
length
)
{
return
null
;
}
return
map
[
idx
]
;
}
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
InputType
.
NONE
InputType
.
TEXT
InputType
.
NUMBER
InputType
.
PHONE
}
)
public
interface
AutofillInputType
{
}
public
static
class
NodeData
{
final
int
id
;
String
value
;
Node
node
;
EventCallback
callback
;
NodeData
(
final
int
id
final
Node
node
)
{
this
.
id
=
id
;
this
.
node
=
node
;
}
AnyThread
public
Nullable
String
getValue
(
)
{
return
value
;
}
AnyThread
public
int
getId
(
)
{
return
id
;
}
}
public
static
final
class
Session
{
private
static
final
String
LOGTAG
=
"
AutofillSession
"
;
private
NonNull
final
GeckoSession
mGeckoSession
;
private
Node
mRoot
;
private
HashMap
<
String
NodeData
>
mUuidToNodeData
;
private
SparseArray
<
Node
>
mIdToNode
;
private
int
mCurrentIndex
=
0
;
private
String
mId
=
null
;
private
String
mFocusedUuid
=
null
;
Session
(
NonNull
final
GeckoSession
geckoSession
)
{
mGeckoSession
=
geckoSession
;
clear
(
UUID
.
randomUUID
(
)
.
toString
(
)
)
;
}
UiThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
NonNull
Rect
getDefaultDimensions
(
)
{
final
Rect
rect
=
new
Rect
(
)
;
mGeckoSession
.
getSurfaceBounds
(
rect
)
;
return
rect
;
}
void
clear
(
final
String
newSessionId
)
{
mId
=
newSessionId
;
mFocusedUuid
=
null
;
mRoot
=
Node
.
newDummyRoot
(
getDefaultDimensions
(
)
newSessionId
)
;
mIdToNode
=
new
SparseArray
<
>
(
)
;
mUuidToNodeData
=
new
HashMap
<
>
(
)
;
addNode
(
mRoot
)
;
}
boolean
isEmpty
(
)
{
return
mUuidToNodeData
.
size
(
)
=
=
1
;
}
UiThread
public
NonNull
NodeData
dataFor
(
final
NonNull
Node
node
)
{
final
NodeData
data
=
mUuidToNodeData
.
get
(
node
.
getUuid
(
)
)
;
Objects
.
requireNonNull
(
data
)
;
return
data
;
}
UiThread
public
void
autofill
(
NonNull
final
SparseArray
<
CharSequence
>
values
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isEmpty
(
)
)
{
return
;
}
final
HashMap
<
Node
GeckoBundle
>
valueBundles
=
new
HashMap
<
>
(
)
;
for
(
int
i
=
0
;
i
<
values
.
size
(
)
;
i
+
+
)
{
final
int
id
=
values
.
keyAt
(
i
)
;
final
Node
node
=
getNode
(
id
)
;
if
(
node
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Could
not
find
node
id
=
"
+
id
)
;
continue
;
}
final
CharSequence
value
=
values
.
valueAt
(
i
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Process
autofill
for
id
=
"
+
id
+
"
value
=
"
+
value
)
;
}
if
(
node
=
=
getRoot
(
)
)
{
Log
.
w
(
LOGTAG
"
Ignoring
autofill
on
session
root
.
"
)
;
continue
;
}
final
Node
root
=
node
.
getRoot
(
)
;
if
(
!
valueBundles
.
containsKey
(
root
)
)
{
valueBundles
.
put
(
root
new
GeckoBundle
(
)
)
;
}
valueBundles
.
get
(
root
)
.
putString
(
node
.
getUuid
(
)
String
.
valueOf
(
value
)
)
;
}
for
(
final
Node
root
:
valueBundles
.
keySet
(
)
)
{
final
NodeData
data
=
dataFor
(
root
)
;
Objects
.
requireNonNull
(
data
)
;
final
EventCallback
callback
=
data
.
callback
;
callback
.
sendSuccess
(
valueBundles
.
get
(
root
)
)
;
}
}
void
addRoot
(
NonNull
final
Node
node
final
EventCallback
callback
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
addRoot
:
"
+
node
)
;
}
mRoot
.
addChild
(
node
)
;
addNode
(
node
)
;
dataFor
(
node
)
.
callback
=
callback
;
}
void
addNode
(
NonNull
final
Node
node
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
addNode
:
"
+
node
)
;
}
NodeData
data
=
mUuidToNodeData
.
get
(
node
.
getUuid
(
)
)
;
if
(
data
=
=
null
)
{
final
int
nodeId
=
mCurrentIndex
+
+
;
data
=
new
NodeData
(
nodeId
node
)
;
mUuidToNodeData
.
put
(
node
.
getUuid
(
)
data
)
;
}
else
{
data
.
node
=
node
;
}
mIdToNode
.
put
(
data
.
id
node
)
;
for
(
final
Node
child
:
node
.
getChildren
(
)
)
{
addNode
(
child
)
;
}
}
UiThread
public
boolean
isVisible
(
final
NonNull
Node
node
)
{
if
(
!
Objects
.
equals
(
node
.
mSessionId
mId
)
)
{
Log
.
w
(
LOGTAG
"
Requesting
visibility
for
older
session
"
+
node
.
mSessionId
)
;
return
false
;
}
if
(
mRoot
=
=
node
)
{
return
true
;
}
final
Node
focused
=
getFocused
(
)
;
if
(
focused
=
=
null
)
{
return
false
;
}
final
Node
focusedRoot
=
focused
.
getRoot
(
)
;
final
Node
focusedParent
=
focused
.
getParent
(
)
;
final
String
parentUuid
=
node
.
getParent
(
)
!
=
null
?
node
.
getParent
(
)
.
getUuid
(
)
:
null
;
final
String
rootUuid
=
node
.
getRoot
(
)
!
=
null
?
node
.
getRoot
(
)
.
getUuid
(
)
:
null
;
return
(
focusedParent
!
=
null
&
&
focusedParent
.
getUuid
(
)
.
equals
(
parentUuid
)
)
|
|
(
focusedRoot
!
=
null
&
&
focusedRoot
.
getUuid
(
)
.
equals
(
rootUuid
)
)
;
}
UiThread
public
Nullable
Node
getFocused
(
)
{
return
getNode
(
mFocusedUuid
)
;
}
void
setFocus
(
final
Node
node
)
{
mFocusedUuid
=
node
!
=
null
?
node
.
getUuid
(
)
:
null
;
}
UiThread
public
Nullable
NodeData
getFocusedData
(
)
{
final
Node
focused
=
getFocused
(
)
;
return
focused
!
=
null
?
dataFor
(
focused
)
:
null
;
}
Nullable
Node
getNode
(
final
String
uuid
)
{
if
(
uuid
=
=
null
)
{
return
null
;
}
final
NodeData
nodeData
=
mUuidToNodeData
.
get
(
uuid
)
;
if
(
nodeData
=
=
null
)
{
return
null
;
}
return
nodeData
.
node
;
}
Node
getNode
(
final
int
id
)
{
return
mIdToNode
.
get
(
id
)
;
}
AnyThread
public
NonNull
Node
getRoot
(
)
{
return
mRoot
;
}
String
getId
(
)
{
return
mId
;
}
Override
UiThread
public
String
toString
(
)
{
final
StringBuilder
builder
=
new
StringBuilder
(
"
Session
{
"
)
;
final
Node
focused
=
getFocused
(
)
;
builder
.
append
(
"
id
=
"
)
.
append
(
mId
)
.
append
(
"
focused
=
"
)
.
append
(
mFocusedUuid
)
.
append
(
"
focusedRoot
=
"
)
.
append
(
(
focused
!
=
null
&
&
focused
.
getRoot
(
)
!
=
null
)
?
focused
.
getRoot
(
)
.
getUuid
(
)
:
null
)
.
append
(
"
root
=
"
)
.
append
(
getRoot
(
)
)
.
append
(
"
}
"
)
;
return
builder
.
toString
(
)
;
}
TargetApi
(
23
)
UiThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
void
fillViewStructure
(
NonNull
final
View
view
NonNull
final
ViewStructure
structure
final
int
flags
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
fillViewStructure
(
getRoot
(
)
view
structure
flags
)
;
}
TargetApi
(
23
)
UiThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
void
fillViewStructure
(
final
NonNull
Node
node
NonNull
final
View
view
NonNull
final
ViewStructure
structure
final
int
flags
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
fillViewStructure
"
)
;
}
final
NodeData
data
=
dataFor
(
node
)
;
if
(
data
=
=
null
)
{
return
;
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
structure
.
setAutofillId
(
view
.
getAutofillId
(
)
data
.
id
)
;
structure
.
setWebDomain
(
node
.
getDomain
(
)
)
;
structure
.
setAutofillValue
(
AutofillValue
.
forText
(
data
.
value
)
)
;
}
structure
.
setId
(
data
.
id
null
null
null
)
;
structure
.
setDimens
(
0
0
0
0
node
.
getDimensions
(
)
.
width
(
)
node
.
getDimensions
(
)
.
height
(
)
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
final
ViewStructure
.
HtmlInfo
.
Builder
htmlBuilder
=
structure
.
newHtmlInfoBuilder
(
node
.
getTag
(
)
)
;
for
(
final
String
key
:
node
.
getAttributes
(
)
.
keySet
(
)
)
{
htmlBuilder
.
addAttribute
(
key
String
.
valueOf
(
node
.
getAttribute
(
key
)
)
)
;
}
structure
.
setHtmlInfo
(
htmlBuilder
.
build
(
)
)
;
}
structure
.
setChildCount
(
node
.
getChildren
(
)
.
size
(
)
)
;
int
childCount
=
0
;
for
(
final
Node
child
:
node
.
getChildren
(
)
)
{
final
ViewStructure
childStructure
=
structure
.
newChild
(
childCount
)
;
fillViewStructure
(
child
view
childStructure
flags
)
;
childCount
+
+
;
}
switch
(
node
.
getTag
(
)
)
{
case
"
input
"
:
case
"
textarea
"
:
structure
.
setClassName
(
"
android
.
widget
.
EditText
"
)
;
structure
.
setEnabled
(
node
.
getEnabled
(
)
)
;
structure
.
setFocusable
(
node
.
getFocusable
(
)
)
;
structure
.
setFocused
(
node
.
equals
(
getFocused
(
)
)
)
;
structure
.
setVisibility
(
isVisible
(
node
)
?
View
.
VISIBLE
:
View
.
INVISIBLE
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
26
)
{
structure
.
setAutofillType
(
View
.
AUTOFILL_TYPE_TEXT
)
;
}
break
;
default
:
if
(
childCount
>
0
)
{
structure
.
setClassName
(
"
android
.
view
.
ViewGroup
"
)
;
}
else
{
structure
.
setClassName
(
"
android
.
view
.
View
"
)
;
}
break
;
}
if
(
Build
.
VERSION
.
SDK_INT
<
26
|
|
!
"
input
"
.
equals
(
node
.
getTag
(
)
)
)
{
return
;
}
switch
(
node
.
getHint
(
)
)
{
case
Hint
.
EMAIL_ADDRESS
:
{
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_EMAIL_ADDRESS
}
)
;
structure
.
setInputType
(
android
.
text
.
InputType
.
TYPE_CLASS_TEXT
|
android
.
text
.
InputType
.
TYPE_TEXT_VARIATION_EMAIL_ADDRESS
)
;
break
;
}
case
Hint
.
PASSWORD
:
{
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_PASSWORD
}
)
;
structure
.
setInputType
(
android
.
text
.
InputType
.
TYPE_CLASS_TEXT
|
android
.
text
.
InputType
.
TYPE_TEXT_VARIATION_WEB_PASSWORD
)
;
break
;
}
case
Hint
.
URI
:
{
structure
.
setInputType
(
android
.
text
.
InputType
.
TYPE_CLASS_TEXT
|
android
.
text
.
InputType
.
TYPE_TEXT_VARIATION_URI
)
;
break
;
}
case
Hint
.
USERNAME
:
{
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_USERNAME
}
)
;
structure
.
setInputType
(
android
.
text
.
InputType
.
TYPE_CLASS_TEXT
|
android
.
text
.
InputType
.
TYPE_TEXT_VARIATION_WEB_EDIT_TEXT
)
;
break
;
}
case
Hint
.
NONE
:
{
break
;
}
}
switch
(
node
.
getInputType
(
)
)
{
case
InputType
.
NUMBER
:
{
structure
.
setInputType
(
android
.
text
.
InputType
.
TYPE_CLASS_NUMBER
)
;
break
;
}
case
InputType
.
PHONE
:
{
structure
.
setAutofillHints
(
new
String
[
]
{
View
.
AUTOFILL_HINT_PHONE
}
)
;
structure
.
setInputType
(
android
.
text
.
InputType
.
TYPE_CLASS_PHONE
)
;
break
;
}
case
InputType
.
TEXT
:
case
InputType
.
NONE
:
break
;
}
}
}
public
static
final
class
Node
{
private
final
String
mUuid
;
private
final
Node
mRoot
;
private
final
Node
mParent
;
private
final
NonNull
Rect
mDimens
;
private
final
NonNull
Rect
mScreenRect
;
private
final
NonNull
Map
<
String
Node
>
mChildren
;
private
final
NonNull
Map
<
String
String
>
mAttributes
;
private
final
boolean
mEnabled
;
private
final
boolean
mFocusable
;
private
final
AutofillHint
int
mHint
;
private
final
AutofillInputType
int
mInputType
;
private
final
NonNull
String
mTag
;
private
final
NonNull
String
mDomain
;
private
final
String
mSessionId
;
NonNull
String
getUuid
(
)
{
return
mUuid
;
}
Nullable
Node
getRoot
(
)
{
return
mRoot
;
}
Nullable
Node
getParent
(
)
{
return
mParent
;
}
Deprecated
DeprecationSchedule
(
id
=
"
autofill
-
fission
"
version
=
112
)
AnyThread
public
NonNull
Rect
getDimensions
(
)
{
return
mDimens
;
}
AnyThread
public
NonNull
Rect
getScreenRect
(
)
{
return
mScreenRect
;
}
void
setScreenRect
(
final
NonNull
RectF
screenRectF
)
{
screenRectF
.
roundOut
(
mScreenRect
)
;
}
AnyThread
public
NonNull
Collection
<
Node
>
getChildren
(
)
{
return
mChildren
.
values
(
)
;
}
NonNull
Node
addChild
(
NonNull
final
Node
child
)
{
mChildren
.
put
(
child
.
getUuid
(
)
child
)
;
return
this
;
}
AnyThread
public
NonNull
Map
<
String
String
>
getAttributes
(
)
{
return
mAttributes
;
}
AnyThread
SuppressWarnings
(
"
checkstyle
:
javadocmethod
"
)
public
Nullable
String
getAttribute
(
NonNull
final
String
key
)
{
return
mAttributes
.
get
(
key
)
;
}
AnyThread
public
boolean
getEnabled
(
)
{
return
mEnabled
;
}
AnyThread
public
boolean
getFocusable
(
)
{
return
mFocusable
;
}
AnyThread
public
AutofillHint
int
getHint
(
)
{
return
mHint
;
}
AnyThread
public
AutofillInputType
int
getInputType
(
)
{
return
mInputType
;
}
AnyThread
public
NonNull
String
getTag
(
)
{
return
mTag
;
}
AnyThread
public
NonNull
String
getDomain
(
)
{
return
mDomain
;
}
static
Node
newDummyRoot
(
final
Rect
dimensions
final
String
sessionId
)
{
return
new
Node
(
dimensions
sessionId
)
;
}
Node
(
final
Rect
dimensions
final
String
sessionId
)
{
mRoot
=
null
;
mParent
=
null
;
mUuid
=
UUID
.
randomUUID
(
)
.
toString
(
)
;
mDimens
=
dimensions
;
mScreenRect
=
new
Rect
(
)
;
mSessionId
=
sessionId
;
mAttributes
=
new
ArrayMap
<
>
(
)
;
mEnabled
=
false
;
mFocusable
=
false
;
mHint
=
Hint
.
NONE
;
mInputType
=
InputType
.
NONE
;
mTag
=
"
"
;
mDomain
=
"
"
;
mChildren
=
new
HashMap
<
>
(
)
;
}
Override
AnyThread
public
String
toString
(
)
{
final
StringBuilder
builder
=
new
StringBuilder
(
"
Node
{
"
)
;
builder
.
append
(
"
uuid
=
"
)
.
append
(
mUuid
)
.
append
(
"
sessionId
=
"
)
.
append
(
mSessionId
)
.
append
(
"
parent
=
"
)
.
append
(
mParent
!
=
null
?
mParent
.
getUuid
(
)
:
null
)
.
append
(
"
root
=
"
)
.
append
(
mRoot
!
=
null
?
mRoot
.
getUuid
(
)
:
null
)
.
append
(
"
dims
=
"
)
.
append
(
getDimensions
(
)
.
toShortString
(
)
)
.
append
(
"
screenRect
=
"
)
.
append
(
getScreenRect
(
)
.
toShortString
(
)
)
.
append
(
"
children
=
[
"
)
;
for
(
final
Node
child
:
mChildren
.
values
(
)
)
{
builder
.
append
(
child
.
getUuid
(
)
)
.
append
(
"
"
)
;
}
builder
.
append
(
"
]
"
)
.
append
(
"
attrs
=
"
)
.
append
(
mAttributes
)
.
append
(
"
enabled
=
"
)
.
append
(
mEnabled
)
.
append
(
"
focusable
=
"
)
.
append
(
mFocusable
)
.
append
(
"
hint
=
"
)
.
append
(
Hint
.
toString
(
mHint
)
)
.
append
(
"
type
=
"
)
.
append
(
InputType
.
toString
(
mInputType
)
)
.
append
(
"
tag
=
"
)
.
append
(
mTag
)
.
append
(
"
domain
=
"
)
.
append
(
mDomain
)
.
append
(
"
}
"
)
;
return
builder
.
toString
(
)
;
}
Node
(
NonNull
final
GeckoBundle
bundle
final
Rect
defaultDimensions
final
String
sessionId
)
{
this
(
bundle
null
null
defaultDimensions
sessionId
)
;
}
Node
(
NonNull
final
GeckoBundle
bundle
final
Node
root
final
Node
parent
final
Rect
defaultDimensions
final
String
sessionId
)
{
final
GeckoBundle
bounds
=
bundle
.
getBundle
(
"
bounds
"
)
;
mSessionId
=
sessionId
;
mUuid
=
bundle
.
getString
(
"
uuid
"
)
;
mDomain
=
bundle
.
getString
(
"
origin
"
"
"
)
;
final
Rect
dimens
=
new
Rect
(
bounds
.
getInt
(
"
left
"
)
bounds
.
getInt
(
"
top
"
)
bounds
.
getInt
(
"
right
"
)
bounds
.
getInt
(
"
bottom
"
)
)
;
if
(
dimens
.
isEmpty
(
)
)
{
mDimens
=
defaultDimensions
;
}
else
{
mDimens
=
dimens
;
}
mScreenRect
=
new
Rect
(
)
;
mParent
=
parent
;
mRoot
=
root
!
=
null
?
root
:
this
;
final
GeckoBundle
[
]
children
=
bundle
.
getBundleArray
(
"
children
"
)
;
final
Map
<
String
Node
>
childrenMap
=
new
HashMap
<
>
(
children
!
=
null
?
children
.
length
:
0
)
;
if
(
children
!
=
null
)
{
for
(
final
GeckoBundle
childBundle
:
children
)
{
final
Node
child
=
new
Node
(
childBundle
mRoot
this
defaultDimensions
sessionId
)
;
childrenMap
.
put
(
child
.
getUuid
(
)
child
)
;
}
}
mChildren
=
childrenMap
;
mTag
=
bundle
.
getString
(
"
tag
"
"
"
)
.
toLowerCase
(
Locale
.
ROOT
)
;
final
GeckoBundle
attrs
=
bundle
.
getBundle
(
"
attributes
"
)
;
final
Map
<
String
String
>
attributes
=
new
HashMap
<
>
(
)
;
for
(
final
String
key
:
attrs
.
keys
(
)
)
{
attributes
.
put
(
key
String
.
valueOf
(
attrs
.
get
(
key
)
)
)
;
}
mAttributes
=
attributes
;
mEnabled
=
enabledFromBundle
(
mTag
bundle
.
getBoolean
(
"
editable
"
false
)
bundle
.
getBoolean
(
"
disabled
"
false
)
)
;
mFocusable
=
mEnabled
;
final
String
type
=
bundle
.
getString
(
"
type
"
"
text
"
)
.
toLowerCase
(
Locale
.
ROOT
)
;
final
String
hint
=
bundle
.
getString
(
"
autofillhint
"
"
"
)
.
toLowerCase
(
Locale
.
ROOT
)
;
mInputType
=
typeFromBundle
(
type
hint
)
;
mHint
=
hintFromBundle
(
type
hint
)
;
}
private
boolean
enabledFromBundle
(
final
String
tag
final
boolean
editable
final
boolean
disabled
)
{
switch
(
tag
)
{
case
"
input
"
:
{
if
(
!
editable
)
{
return
false
;
}
return
!
disabled
;
}
case
"
textarea
"
:
return
!
disabled
;
default
:
return
false
;
}
}
private
AutofillHint
int
hintFromBundle
(
final
String
type
final
String
hint
)
{
switch
(
type
)
{
case
"
email
"
:
return
Hint
.
EMAIL_ADDRESS
;
case
"
password
"
:
return
Hint
.
PASSWORD
;
case
"
url
"
:
return
Hint
.
URI
;
case
"
text
"
:
{
if
(
hint
.
equals
(
"
username
"
)
)
{
return
Hint
.
USERNAME
;
}
break
;
}
}
return
Hint
.
NONE
;
}
private
AutofillInputType
int
typeFromBundle
(
final
String
type
final
String
hint
)
{
switch
(
type
)
{
case
"
password
"
:
case
"
url
"
:
case
"
email
"
:
return
InputType
.
TEXT
;
case
"
number
"
:
return
InputType
.
NUMBER
;
case
"
tel
"
:
return
InputType
.
PHONE
;
case
"
text
"
:
{
if
(
hint
.
equals
(
"
username
"
)
)
{
return
InputType
.
TEXT
;
}
break
;
}
}
return
InputType
.
NONE
;
}
}
public
interface
Delegate
{
UiThread
default
void
onSessionStart
(
NonNull
final
GeckoSession
session
)
{
}
UiThread
default
void
onSessionCommit
(
NonNull
final
GeckoSession
session
NonNull
final
Node
node
NonNull
final
NodeData
data
)
{
}
UiThread
default
void
onSessionCancel
(
NonNull
final
GeckoSession
session
)
{
}
UiThread
default
void
onNodeAdd
(
NonNull
final
GeckoSession
session
NonNull
final
Node
node
NonNull
final
NodeData
data
)
{
}
UiThread
default
void
onNodeRemove
(
NonNull
final
GeckoSession
session
NonNull
final
Node
node
NonNull
final
NodeData
data
)
{
}
UiThread
default
void
onNodeUpdate
(
NonNull
final
GeckoSession
session
NonNull
final
Node
node
NonNull
final
NodeData
data
)
{
}
UiThread
default
void
onNodeFocus
(
NonNull
final
GeckoSession
session
NonNull
final
Node
focused
NonNull
final
NodeData
data
)
{
}
UiThread
default
void
onNodeBlur
(
NonNull
final
GeckoSession
session
NonNull
final
Node
prev
NonNull
final
NodeData
data
)
{
}
}
static
final
class
Support
implements
BundleEventListener
{
private
static
final
String
LOGTAG
=
"
AutofillSupport
"
;
private
NonNull
final
GeckoSession
mGeckoSession
;
private
NonNull
final
Session
mAutofillSession
;
private
Delegate
mDelegate
;
public
Support
(
NonNull
final
GeckoSession
geckoSession
)
{
mGeckoSession
=
geckoSession
;
mAutofillSession
=
new
Session
(
mGeckoSession
)
;
}
public
void
registerListeners
(
)
{
mGeckoSession
.
getEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
GeckoView
:
StartAutofill
"
"
GeckoView
:
AddAutofill
"
"
GeckoView
:
ClearAutofill
"
"
GeckoView
:
CommitAutofill
"
"
GeckoView
:
OnAutofillFocus
"
"
GeckoView
:
UpdateAutofill
"
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
Log
.
d
(
LOGTAG
"
handleMessage
"
+
event
)
;
if
(
"
GeckoView
:
AddAutofill
"
.
equals
(
event
)
)
{
addNode
(
message
.
getBundle
(
"
node
"
)
callback
)
;
}
else
if
(
"
GeckoView
:
StartAutofill
"
.
equals
(
event
)
)
{
start
(
message
.
getString
(
"
sessionId
"
)
)
;
}
else
if
(
"
GeckoView
:
ClearAutofill
"
.
equals
(
event
)
)
{
clear
(
)
;
}
else
if
(
"
GeckoView
:
OnAutofillFocus
"
.
equals
(
event
)
)
{
onFocusChanged
(
message
.
getBundle
(
"
node
"
)
)
;
}
else
if
(
"
GeckoView
:
CommitAutofill
"
.
equals
(
event
)
)
{
commit
(
message
.
getBundle
(
"
node
"
)
)
;
}
else
if
(
"
GeckoView
:
UpdateAutofill
"
.
equals
(
event
)
)
{
update
(
message
.
getBundle
(
"
node
"
)
)
;
}
}
UiThread
public
void
setDelegate
(
final
Nullable
Delegate
delegate
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mDelegate
=
delegate
;
}
UiThread
public
Nullable
Delegate
getDelegate
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mDelegate
;
}
UiThread
public
NonNull
Session
getAutofillSession
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
return
mAutofillSession
;
}
void
addNode
(
NonNull
final
GeckoBundle
message
NonNull
final
EventCallback
callback
)
{
final
Session
session
=
getAutofillSession
(
)
;
final
Node
node
=
new
Node
(
message
session
.
getDefaultDimensions
(
)
session
.
getId
(
)
)
;
session
.
addRoot
(
node
callback
)
;
addValues
(
message
)
;
if
(
mDelegate
!
=
null
)
{
mDelegate
.
onNodeAdd
(
mGeckoSession
node
getAutofillSession
(
)
.
dataFor
(
node
)
)
;
}
}
private
void
addValues
(
final
GeckoBundle
message
)
{
final
String
uuid
=
message
.
getString
(
"
uuid
"
)
;
if
(
uuid
=
=
null
)
{
return
;
}
final
String
value
=
message
.
getString
(
"
value
"
)
;
final
Node
node
=
getAutofillSession
(
)
.
getNode
(
uuid
)
;
if
(
node
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Cannot
find
node
uuid
=
"
+
uuid
)
;
return
;
}
Objects
.
requireNonNull
(
node
)
;
final
NodeData
data
=
getAutofillSession
(
)
.
dataFor
(
node
)
;
Objects
.
requireNonNull
(
data
)
;
data
.
value
=
value
;
final
GeckoBundle
[
]
children
=
message
.
getBundleArray
(
"
children
"
)
;
if
(
children
!
=
null
)
{
for
(
final
GeckoBundle
child
:
children
)
{
addValues
(
child
)
;
}
}
}
void
start
(
Nullable
final
String
sessionId
)
{
getAutofillSession
(
)
.
clear
(
sessionId
)
;
if
(
mDelegate
!
=
null
)
{
mDelegate
.
onSessionStart
(
mGeckoSession
)
;
}
}
void
commit
(
Nullable
final
GeckoBundle
message
)
{
if
(
getAutofillSession
(
)
.
isEmpty
(
)
|
|
message
=
=
null
)
{
return
;
}
final
String
uuid
=
message
.
getString
(
"
uuid
"
)
;
final
Node
node
=
getAutofillSession
(
)
.
getNode
(
uuid
)
;
if
(
node
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Cannot
find
node
uuid
=
"
+
uuid
)
;
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
commit
(
"
+
uuid
+
"
)
"
)
;
}
if
(
mDelegate
!
=
null
)
{
mDelegate
.
onSessionCommit
(
mGeckoSession
node
getAutofillSession
(
)
.
dataFor
(
node
)
)
;
}
}
void
update
(
Nullable
final
GeckoBundle
message
)
{
if
(
getAutofillSession
(
)
.
isEmpty
(
)
|
|
message
=
=
null
)
{
return
;
}
final
String
uuid
=
message
.
getString
(
"
uuid
"
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
update
(
"
+
uuid
+
"
)
"
)
;
}
final
Node
node
=
getAutofillSession
(
)
.
getNode
(
uuid
)
;
final
String
value
=
message
.
getString
(
"
value
"
"
"
)
;
if
(
node
=
=
null
)
{
Log
.
d
(
LOGTAG
"
could
not
find
node
"
+
uuid
)
;
return
;
}
if
(
DEBUG
)
{
final
NodeData
data
=
getAutofillSession
(
)
.
dataFor
(
node
)
;
Log
.
d
(
LOGTAG
"
updating
node
"
+
uuid
+
"
value
from
"
+
data
!
=
null
?
data
.
value
:
null
+
"
to
"
+
value
)
;
}
getAutofillSession
(
)
.
dataFor
(
node
)
.
value
=
value
;
if
(
mDelegate
!
=
null
)
{
mDelegate
.
onNodeUpdate
(
mGeckoSession
node
getAutofillSession
(
)
.
dataFor
(
node
)
)
;
}
}
void
clear
(
)
{
if
(
getAutofillSession
(
)
.
isEmpty
(
)
)
{
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
clear
(
)
"
)
;
}
getAutofillSession
(
)
.
clear
(
null
)
;
if
(
mDelegate
!
=
null
)
{
mDelegate
.
onSessionCancel
(
mGeckoSession
)
;
}
}
void
onFocusChanged
(
Nullable
final
GeckoBundle
message
)
{
final
Session
session
=
getAutofillSession
(
)
;
if
(
session
.
isEmpty
(
)
)
{
return
;
}
final
Node
prev
=
getAutofillSession
(
)
.
getFocused
(
)
;
final
String
prevUuid
=
prev
!
=
null
?
prev
.
getUuid
(
)
:
null
;
final
String
uuid
=
message
!
=
null
?
message
.
getString
(
"
uuid
"
)
:
null
;
final
Node
focused
;
if
(
uuid
=
=
null
)
{
focused
=
null
;
}
else
{
focused
=
session
.
getNode
(
uuid
)
;
if
(
focused
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Cannot
find
node
uuid
=
"
+
uuid
)
;
return
;
}
if
(
message
!
=
null
)
{
final
RectF
screenRectF
=
message
.
getRectF
(
"
screenRect
"
)
;
focused
.
setScreenRect
(
screenRectF
)
;
}
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onFocusChanged
(
"
+
(
prev
!
=
null
?
prev
.
getUuid
(
)
:
null
)
+
"
-
>
"
+
uuid
+
'
)
'
)
;
}
if
(
Objects
.
equals
(
uuid
prevUuid
)
)
{
return
;
}
session
.
setFocus
(
focused
)
;
if
(
mDelegate
!
=
null
)
{
if
(
prev
!
=
null
)
{
mDelegate
.
onNodeBlur
(
mGeckoSession
prev
getAutofillSession
(
)
.
dataFor
(
prev
)
)
;
}
if
(
uuid
!
=
null
)
{
mDelegate
.
onNodeFocus
(
mGeckoSession
focused
getAutofillSession
(
)
.
dataFor
(
focused
)
)
;
}
}
}
UiThread
public
void
onActiveChanged
(
final
boolean
active
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
final
Node
focused
=
getAutofillSession
(
)
.
getFocused
(
)
;
if
(
focused
=
=
null
)
{
return
;
}
if
(
mDelegate
!
=
null
)
{
if
(
active
)
{
mDelegate
.
onNodeFocus
(
mGeckoSession
focused
getAutofillSession
(
)
.
dataFor
(
focused
)
)
;
}
else
{
mDelegate
.
onNodeBlur
(
mGeckoSession
focused
getAutofillSession
(
)
.
dataFor
(
focused
)
)
;
}
}
}
}
}
