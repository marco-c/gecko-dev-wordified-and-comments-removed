package
org
.
mozilla
.
gecko
;
import
android
.
content
.
ClipData
;
import
android
.
content
.
ClipDescription
;
import
android
.
content
.
ClipboardManager
;
import
android
.
content
.
ClipboardManager
.
OnPrimaryClipChangedListener
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
AssetFileDescriptor
;
import
android
.
os
.
Build
;
import
android
.
os
.
PersistableBundle
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicLong
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
public
final
class
Clipboard
{
private
static
final
String
HTML_MIME
=
"
text
/
html
"
;
private
static
final
String
PLAINTEXT_MIME
=
"
text
/
plain
"
;
private
static
final
String
LOGTAG
=
"
GeckoClipboard
"
;
private
static
final
int
DEFAULT_BUFFER_SIZE
=
8192
;
private
static
OnPrimaryClipChangedListener
sClipboardChangedListener
=
null
;
private
static
final
AtomicLong
sClipboardSequenceNumber
=
new
AtomicLong
(
)
;
private
Clipboard
(
)
{
}
public
static
String
getText
(
final
Context
context
)
{
return
getTextData
(
context
PLAINTEXT_MIME
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
String
getTextData
(
final
Context
context
final
String
mimeType
)
{
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
if
(
cm
.
hasPrimaryClip
(
)
)
{
final
ClipData
clip
=
cm
.
getPrimaryClip
(
)
;
if
(
clip
=
=
null
|
|
clip
.
getItemCount
(
)
=
=
0
)
{
return
null
;
}
final
ClipDescription
description
=
clip
.
getDescription
(
)
;
if
(
HTML_MIME
.
equals
(
mimeType
)
&
&
description
.
hasMimeType
(
ClipDescription
.
MIMETYPE_TEXT_HTML
)
)
{
final
CharSequence
data
=
clip
.
getItemAt
(
0
)
.
getHtmlText
(
)
;
if
(
data
=
=
null
)
{
return
null
;
}
return
data
.
toString
(
)
;
}
if
(
PLAINTEXT_MIME
.
equals
(
mimeType
)
)
{
try
{
return
clip
.
getItemAt
(
0
)
.
coerceToText
(
context
)
.
toString
(
)
;
}
catch
(
final
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Couldn
'
t
get
clip
data
from
clipboard
"
e
)
;
}
}
}
return
null
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
exceptionMode
=
"
nsresult
"
)
private
static
byte
[
]
getRawData
(
final
String
mimeType
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
if
(
cm
.
hasPrimaryClip
(
)
)
{
final
ClipData
clip
=
cm
.
getPrimaryClip
(
)
;
if
(
clip
=
=
null
|
|
clip
.
getItemCount
(
)
=
=
0
)
{
return
null
;
}
final
ClipDescription
description
=
clip
.
getDescription
(
)
;
if
(
description
.
hasMimeType
(
mimeType
)
)
{
return
getRawDataFromClipData
(
context
clip
)
;
}
}
return
null
;
}
private
static
byte
[
]
getRawDataFromClipData
(
final
Context
context
final
ClipData
clipData
)
{
try
(
final
AssetFileDescriptor
descriptor
=
context
.
getContentResolver
(
)
.
openAssetFileDescriptor
(
clipData
.
getItemAt
(
0
)
.
getUri
(
)
"
r
"
)
;
final
InputStream
inputStream
=
new
FileInputStream
(
descriptor
.
getFileDescriptor
(
)
)
;
final
ByteArrayOutputStream
outputStream
=
new
ByteArrayOutputStream
(
)
)
{
final
byte
[
]
data
=
new
byte
[
DEFAULT_BUFFER_SIZE
]
;
int
readed
;
while
(
(
readed
=
inputStream
.
read
(
data
)
)
!
=
-
1
)
{
outputStream
.
write
(
data
0
readed
)
;
}
return
outputStream
.
toByteArray
(
)
;
}
catch
(
final
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Couldn
'
t
get
clip
data
from
clipboard
due
to
I
/
O
error
"
e
)
;
}
catch
(
final
OutOfMemoryError
e
)
{
Log
.
e
(
LOGTAG
"
Couldn
'
t
get
clip
data
from
clipboard
due
to
OOM
"
e
)
;
}
return
null
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
static
boolean
setText
(
final
Context
context
final
CharSequence
text
final
boolean
isPrivateData
)
{
return
setData
(
context
ClipData
.
newPlainText
(
"
text
"
text
)
isPrivateData
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
boolean
setHTML
(
final
Context
context
final
CharSequence
text
final
String
htmlText
final
boolean
isPrivateData
)
{
return
setData
(
context
ClipData
.
newHtmlText
(
"
html
"
text
htmlText
)
isPrivateData
)
;
}
private
static
boolean
setData
(
final
Context
context
final
ClipData
clipData
final
boolean
isPrivateData
)
{
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
if
(
isPrivateData
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
N
)
{
final
PersistableBundle
extras
=
new
PersistableBundle
(
)
;
extras
.
putBoolean
(
ClipDescription
.
EXTRA_IS_SENSITIVE
true
)
;
clipData
.
getDescription
(
)
.
setExtras
(
extras
)
;
}
try
{
cm
.
setPrimaryClip
(
clipData
)
;
}
catch
(
final
NullPointerException
e
)
{
}
catch
(
final
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Couldn
'
t
set
clip
data
to
clipboard
"
e
)
;
return
false
;
}
return
true
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
boolean
hasData
(
final
Context
context
final
String
mimeType
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
=
Build
.
VERSION_CODES
.
P
)
{
if
(
HTML_MIME
.
equals
(
mimeType
)
|
|
PLAINTEXT_MIME
.
equals
(
mimeType
)
)
{
return
!
TextUtils
.
isEmpty
(
getTextData
(
context
mimeType
)
)
;
}
}
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
if
(
!
cm
.
hasPrimaryClip
(
)
)
{
return
false
;
}
final
ClipDescription
description
=
cm
.
getPrimaryClipDescription
(
)
;
if
(
description
=
=
null
)
{
return
false
;
}
if
(
HTML_MIME
.
equals
(
mimeType
)
)
{
return
description
.
hasMimeType
(
ClipDescription
.
MIMETYPE_TEXT_HTML
)
;
}
if
(
PLAINTEXT_MIME
.
equals
(
mimeType
)
)
{
return
description
.
hasMimeType
(
ClipDescription
.
MIMETYPE_TEXT_HTML
)
|
|
description
.
hasMimeType
(
ClipDescription
.
MIMETYPE_TEXT_PLAIN
)
;
}
return
description
.
hasMimeType
(
mimeType
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
void
clear
(
final
Context
context
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
=
Build
.
VERSION_CODES
.
P
)
{
setText
(
context
null
false
)
;
return
;
}
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
cm
.
clearPrimaryClip
(
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
void
startTrackingClipboardData
(
final
Context
context
)
{
if
(
sClipboardChangedListener
!
=
null
)
{
return
;
}
sClipboardChangedListener
=
new
OnPrimaryClipChangedListener
(
)
{
Override
public
void
onPrimaryClipChanged
(
)
{
Clipboard
.
sClipboardSequenceNumber
.
incrementAndGet
(
)
;
}
}
;
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
cm
.
addPrimaryClipChangedListener
(
sClipboardChangedListener
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
void
stopTrackingClipboardData
(
final
Context
context
)
{
if
(
sClipboardChangedListener
=
=
null
)
{
return
;
}
final
ClipboardManager
cm
=
(
ClipboardManager
)
context
.
getSystemService
(
Context
.
CLIPBOARD_SERVICE
)
;
cm
.
removePrimaryClipChangedListener
(
sClipboardChangedListener
)
;
sClipboardChangedListener
=
null
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
long
getSequenceNumber
(
final
Context
context
)
{
return
sClipboardSequenceNumber
.
get
(
)
;
}
}
