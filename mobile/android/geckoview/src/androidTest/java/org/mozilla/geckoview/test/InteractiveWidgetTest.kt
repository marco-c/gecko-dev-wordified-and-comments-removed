package
org
.
mozilla
.
geckoview
.
test
import
android
.
content
.
Context
import
android
.
graphics
.
*
import
android
.
graphics
.
Bitmap
import
android
.
view
.
inputmethod
.
InputMethodManager
import
androidx
.
test
.
ext
.
junit
.
rules
.
ActivityScenarioRule
import
androidx
.
test
.
ext
.
junit
.
runners
.
AndroidJUnit4
import
androidx
.
test
.
filters
.
MediumTest
import
org
.
hamcrest
.
Matchers
.
*
import
org
.
junit
.
After
import
org
.
junit
.
Before
import
org
.
junit
.
Rule
import
org
.
junit
.
Test
import
org
.
junit
.
rules
.
RuleChain
import
org
.
junit
.
runner
.
RunWith
import
org
.
mozilla
.
geckoview
.
Autofill
import
org
.
mozilla
.
geckoview
.
GeckoSession
import
org
.
mozilla
.
geckoview
.
GeckoSession
.
ContentDelegate
import
org
.
mozilla
.
geckoview
.
GeckoView
import
org
.
mozilla
.
geckoview
.
PanZoomController
import
org
.
mozilla
.
geckoview
.
ScreenLength
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
AssertCalled
import
org
.
mozilla
.
geckoview
.
test
.
util
.
AssertUtils
RunWith
(
AndroidJUnit4
:
:
class
)
MediumTest
class
InteractiveWidgetTest
:
BaseSessionTest
(
)
{
private
val
activityRule
=
ActivityScenarioRule
(
GeckoViewTestActivity
:
:
class
.
java
)
private
val
dynamicToolbarMaxHeight
=
100
private
lateinit
var
imm
:
InputMethodManager
private
lateinit
var
view
:
GeckoView
get
:
Rule
override
val
rules
:
RuleChain
=
RuleChain
.
outerRule
(
activityRule
)
.
around
(
sessionRule
)
Before
fun
setup
(
)
{
activityRule
.
scenario
.
onActivity
{
activity
-
>
activity
.
view
.
setSession
(
mainSession
)
activity
.
view
.
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
imm
=
activity
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
as
InputMethodManager
view
=
activity
.
view
as
GeckoView
}
}
After
fun
cleanup
(
)
{
try
{
activityRule
.
scenario
.
onActivity
{
activity
-
>
activity
.
view
.
releaseSession
(
)
}
}
catch
(
e
:
Exception
)
{
}
}
private
fun
ensureKeyboardOpen
(
)
{
view
.
requestFocus
(
)
var
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
visualViewport
.
addEventListener
(
'
resize
'
(
)
=
>
{
resolve
(
true
)
;
}
{
once
:
true
}
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
mainSession
.
waitForRoundTrip
(
)
imm
.
showSoftInput
(
view
0
)
assertThat
(
"
The
visual
viewport
height
should
be
changed
in
response
to
the
the
keyboard
showing
"
promise
.
value
as
Boolean
equalTo
(
true
)
)
}
GeckoSessionTestRule
.
NullDelegate
(
Autofill
.
Delegate
:
:
class
)
Test
fun
stickyElementWithDynamicToolbarOnResizesVisual
(
)
{
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
INTERACTIVE_WIDGET_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
flushApzRepaints
(
)
ensureKeyboardOpen
(
)
view
.
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
panZoomController
.
scrollTo
(
ScreenLength
.
zero
(
)
ScreenLength
.
bottom
(
)
PanZoomController
.
SCROLL_BEHAVIOR_AUTO
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
promiseAllPaintsDone
(
)
fun
createReferenceImage
(
height
:
Double
)
:
Bitmap
{
val
rect
=
Rect
(
)
mainSession
.
getSurfaceBounds
(
rect
)
val
bitmap
=
Bitmap
.
createBitmap
(
rect
.
width
(
)
height
.
toInt
(
)
Bitmap
.
Config
.
ARGB_8888
)
val
canvas
=
Canvas
(
bitmap
)
val
paint
=
Paint
(
)
paint
.
color
=
Color
.
rgb
(
255
255
255
)
canvas
.
drawRect
(
0f
0f
rect
.
width
(
)
.
toFloat
(
)
height
.
toFloat
(
)
paint
)
paint
.
color
=
Color
.
rgb
(
0
128
0
)
canvas
.
drawRect
(
0f
(
height
-
dynamicToolbarMaxHeight
)
.
toFloat
(
)
rect
.
width
(
)
.
toFloat
(
)
height
.
toFloat
(
)
paint
)
return
bitmap
}
val
height
=
mainSession
.
evaluateJS
(
"
window
.
visualViewport
.
height
"
)
as
Double
val
pixelRatio
=
mainSession
.
evaluateJS
(
"
window
.
devicePixelRatio
"
)
as
Double
val
reference
=
createReferenceImage
(
height
*
pixelRatio
)
val
result
=
sessionRule
.
waitForResult
(
view
.
capturePixels
(
)
)
AssertUtils
.
assertScreenshotResult
(
result
reference
)
imm
.
hideSoftInputFromWindow
(
view
.
getWindowToken
(
)
0
)
}
GeckoSessionTestRule
.
NullDelegate
(
Autofill
.
Delegate
:
:
class
)
Test
fun
overlaysContent
(
)
{
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
INTERACTIVE_WIDGET_OVERLAYS_CONTENT_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
flushApzRepaints
(
)
view
.
requestFocus
(
)
imm
.
showSoftInput
(
view
0
)
view
.
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
panZoomController
.
scrollTo
(
ScreenLength
.
zero
(
)
ScreenLength
.
bottom
(
)
PanZoomController
.
SCROLL_BEHAVIOR_AUTO
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
panZoomController
.
scrollBy
(
ScreenLength
.
zero
(
)
ScreenLength
.
fromPixels
(
-
10
.
0
)
PanZoomController
.
SCROLL_BEHAVIOR_AUTO
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
promiseAllPaintsDone
(
)
fun
createReferenceImage
(
height
:
Double
)
:
Bitmap
{
val
rect
=
Rect
(
)
mainSession
.
getSurfaceBounds
(
rect
)
val
bitmap
=
Bitmap
.
createBitmap
(
rect
.
width
(
)
height
.
toInt
(
)
Bitmap
.
Config
.
ARGB_8888
)
val
canvas
=
Canvas
(
bitmap
)
val
paint
=
Paint
(
)
paint
.
color
=
Color
.
rgb
(
0
128
0
)
canvas
.
drawRect
(
0f
0f
rect
.
width
(
)
.
toFloat
(
)
height
.
toFloat
(
)
paint
)
return
bitmap
}
val
result
=
sessionRule
.
waitForResult
(
view
.
capturePixels
(
)
)
val
reference
=
createReferenceImage
(
result
.
height
.
toDouble
(
)
)
AssertUtils
.
assertScreenshotResult
(
result
reference
)
imm
.
hideSoftInputFromWindow
(
view
.
getWindowToken
(
)
0
)
}
GeckoSessionTestRule
.
NullDelegate
(
Autofill
.
Delegate
:
:
class
)
Test
fun
hideDynamicToolbarOnResizesVisual
(
)
{
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
HIDE_DYNAMIC_TOOLBAR_ON_RESIZES_VISUAL_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
flushApzRepaints
(
)
ensureKeyboardOpen
(
)
mainSession
.
evaluateJS
(
"
document
.
getElementById
(
'
input1
'
)
.
focus
(
)
;
"
)
mainSession
.
zoomToFocusedInput
(
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
promiseAllPaintsDone
(
)
mainSession
.
waitUntilCalled
(
object
:
ContentDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onHideDynamicToolbar
(
session
:
GeckoSession
)
{
}
}
)
imm
.
hideSoftInputFromWindow
(
view
.
getWindowToken
(
)
0
)
}
}
