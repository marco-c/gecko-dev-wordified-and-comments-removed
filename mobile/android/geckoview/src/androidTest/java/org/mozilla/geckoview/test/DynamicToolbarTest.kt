package
org
.
mozilla
.
geckoview
.
test
import
android
.
graphics
.
*
import
android
.
graphics
.
Bitmap
import
android
.
os
.
SystemClock
import
android
.
util
.
Base64
import
android
.
view
.
MotionEvent
import
androidx
.
test
.
ext
.
junit
.
runners
.
AndroidJUnit4
import
androidx
.
test
.
filters
.
MediumTest
import
org
.
hamcrest
.
Matchers
.
*
import
org
.
hamcrest
.
Matchers
.
closeTo
import
org
.
hamcrest
.
Matchers
.
equalTo
import
org
.
junit
.
Assume
.
assumeThat
import
org
.
junit
.
Test
import
org
.
junit
.
runner
.
RunWith
import
org
.
mozilla
.
geckoview
.
GeckoResult
import
org
.
mozilla
.
geckoview
.
GeckoSession
import
org
.
mozilla
.
geckoview
.
GeckoSession
.
ContentDelegate
import
org
.
mozilla
.
geckoview
.
GeckoSession
.
ScrollDelegate
import
org
.
mozilla
.
geckoview
.
PanZoomController
import
org
.
mozilla
.
geckoview
.
ScreenLength
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
AssertCalled
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
WithDisplay
import
java
.
io
.
ByteArrayOutputStream
private
const
val
SCREEN_WIDTH
=
100
private
const
val
SCREEN_HEIGHT
=
200
RunWith
(
AndroidJUnit4
:
:
class
)
MediumTest
class
DynamicToolbarTest
:
BaseSessionTest
(
)
{
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
outOfRangeValue
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
+
1
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
HELLO_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
}
private
fun
assertScreenshotResult
(
result
:
GeckoResult
<
Bitmap
>
comparisonImage
:
Bitmap
)
{
sessionRule
.
waitForResult
(
result
)
.
let
{
assertThat
(
"
Screenshot
is
not
null
"
it
notNullValue
(
)
)
assertThat
(
"
Widths
are
the
same
"
comparisonImage
.
width
equalTo
(
it
.
width
)
)
assertThat
(
"
Heights
are
the
same
"
comparisonImage
.
height
equalTo
(
it
.
height
)
)
assertThat
(
"
Byte
counts
are
the
same
"
comparisonImage
.
byteCount
equalTo
(
it
.
byteCount
)
)
assertThat
(
"
Configs
are
the
same
"
comparisonImage
.
config
equalTo
(
it
.
config
)
)
if
(
!
comparisonImage
.
sameAs
(
it
)
)
{
val
outputForComparison
=
ByteArrayOutputStream
(
)
comparisonImage
.
compress
(
Bitmap
.
CompressFormat
.
PNG
100
outputForComparison
)
val
outputForActual
=
ByteArrayOutputStream
(
)
it
.
compress
(
Bitmap
.
CompressFormat
.
PNG
100
outputForActual
)
val
actualString
:
String
=
Base64
.
encodeToString
(
outputForActual
.
toByteArray
(
)
Base64
.
DEFAULT
)
val
comparisonString
:
String
=
Base64
.
encodeToString
(
outputForComparison
.
toByteArray
(
)
Base64
.
DEFAULT
)
assertThat
(
"
Encoded
strings
are
the
same
"
comparisonString
equalTo
(
actualString
)
)
}
assertThat
(
"
Bytes
are
the
same
"
comparisonImage
.
sameAs
(
it
)
equalTo
(
true
)
)
}
}
private
fun
getComparisonScreenshot
(
width
:
Int
height
:
Int
)
:
Bitmap
{
val
screenshotFile
=
Bitmap
.
createBitmap
(
width
height
Bitmap
.
Config
.
ARGB_8888
)
val
canvas
=
Canvas
(
screenshotFile
)
val
paint
=
Paint
(
)
paint
.
color
=
Color
.
rgb
(
0
128
0
)
canvas
.
drawRect
(
0f
0f
width
.
toFloat
(
)
height
.
toFloat
(
)
paint
)
return
screenshotFile
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
positionFixedElementClipping
(
)
{
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
SCREEN_HEIGHT
/
2
)
}
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_VH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
window
.
scrollTo
(
{
top
:
100
behavior
:
'
instant
'
}
)
"
)
mainSession
.
evaluateJS
(
"
new
Promise
(
resolve
=
>
window
.
setTimeout
(
resolve
1000
)
)
"
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
layoutViewportExpansion
(
)
{
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
SCREEN_HEIGHT
/
2
)
}
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_VH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
window
.
scrollTo
(
0
100
)
"
)
mainSession
.
evaluateJS
(
"
window
.
scrollTo
(
{
top
:
0
behavior
:
'
smooth
'
}
)
"
)
mainSession
.
evaluateJS
(
"
new
Promise
(
resolve
=
>
window
.
setTimeout
(
resolve
1000
)
)
"
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
visualViewportEvents
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_VH
)
mainSession
.
waitForPageStop
(
)
val
pixelRatio
=
mainSession
.
evaluateJS
(
"
window
.
devicePixelRatio
"
)
as
Double
val
scale
=
mainSession
.
evaluateJS
(
"
window
.
visualViewport
.
scale
"
)
as
Double
for
(
i
in
1
.
.
dynamicToolbarMaxHeight
)
{
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
i
)
}
val
expectedViewportHeight
=
(
SCREEN_HEIGHT
-
dynamicToolbarMaxHeight
+
i
)
/
scale
/
pixelRatio
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
window
.
visualViewport
.
addEventListener
(
'
resize
'
resolve
(
window
.
visualViewport
.
height
)
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
assertThat
(
"
The
visual
viewport
height
should
be
changed
in
response
to
the
dynamc
toolbar
transition
"
promise
.
value
as
Double
closeTo
(
expectedViewportHeight
.
01
)
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
percentBaseValueOnPositionFixedElement
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_PERCENT
)
mainSession
.
waitForPageStop
(
)
val
originalHeight
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
fixed
-
element
'
)
)
.
height
"
"
"
.
trimIndent
(
)
)
as
String
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
/
2
)
}
var
height
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
fixed
-
element
'
)
)
.
height
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
%
-
based
height
should
be
the
static
in
the
middle
of
toolbar
tansition
"
height
equalTo
(
originalHeight
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
height
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
fixed
-
element
'
)
)
.
height
"
"
"
.
trimIndent
(
)
)
as
String
val
scale
=
mainSession
.
evaluateJS
(
"
window
.
visualViewport
.
scale
"
)
as
Double
val
expectedHeight
=
(
SCREEN_HEIGHT
/
scale
)
.
toInt
(
)
assertThat
(
"
The
%
-
based
height
should
be
now
recomputed
based
on
the
screen
height
"
height
equalTo
(
expectedHeight
.
toString
(
)
+
"
px
"
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
resizeEvents
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_VH
)
mainSession
.
waitForPageStop
(
)
for
(
i
in
1
.
.
dynamicToolbarMaxHeight
-
1
)
{
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
let
fired
=
false
;
window
.
addEventListener
(
'
resize
'
(
)
=
>
{
fired
=
true
;
}
{
once
:
true
}
)
;
requestAnimationFrame
(
(
)
=
>
{
resolve
(
fired
)
;
}
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
i
)
}
assertThat
(
"
'
resize
'
event
on
window
should
not
be
fired
in
response
to
the
dynamc
toolbar
transition
"
promise
.
value
as
Boolean
equalTo
(
false
)
)
}
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
'
resize
'
(
)
=
>
{
resolve
(
true
)
;
}
{
once
:
true
}
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
assertThat
(
"
'
resize
'
event
on
window
should
be
fired
when
the
dynamc
toolbar
is
completely
hidden
"
promise
.
value
as
Boolean
equalTo
(
true
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
windowInnerHeight
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_BOTTOM
)
mainSession
.
waitForPageStop
(
)
val
pixelRatio
=
mainSession
.
evaluateJS
(
"
window
.
devicePixelRatio
"
)
as
Double
for
(
i
in
1
.
.
dynamicToolbarMaxHeight
-
1
)
{
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
window
.
visualViewport
.
addEventListener
(
'
resize
'
resolve
(
window
.
innerHeight
)
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
i
)
}
assertThat
(
"
window
.
innerHeight
should
not
be
changed
in
response
to
the
dynamc
toolbar
transition
"
promise
.
value
as
Double
closeTo
(
SCREEN_HEIGHT
/
2
/
pixelRatio
.
01
)
)
}
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
'
resize
'
(
)
=
>
{
resolve
(
window
.
innerHeight
)
;
}
{
once
:
true
}
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
assertThat
(
"
window
.
innerHeight
should
be
changed
when
the
dynamc
toolbar
is
completely
hidden
"
promise
.
value
as
Double
closeTo
(
SCREEN_HEIGHT
/
pixelRatio
.
01
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
notCrashOnResizeEvent
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_VH
)
mainSession
.
waitForPageStop
(
)
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
window
.
addEventListener
(
'
resize
'
(
)
=
>
resolve
(
true
)
)
)
;
"
"
"
.
trimIndent
(
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
+
1
)
}
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
assertThat
(
"
Got
a
rezie
event
"
promise
.
value
as
Boolean
equalTo
(
true
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
showDynamicToolbar
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
SHOW_DYNAMIC_TOOLBAR_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
window
.
scrollTo
(
0
"
+
dynamicToolbarMaxHeight
+
"
)
"
)
mainSession
.
waitUntilCalled
(
object
:
ScrollDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onScrollChanged
(
session
:
GeckoSession
scrollX
:
Int
scrollY
:
Int
)
{
}
}
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
synthesizeTap
(
5
25
)
mainSession
.
waitUntilCalled
(
object
:
ContentDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onShowDynamicToolbar
(
session
:
GeckoSession
)
{
}
}
)
}
WithDisplay
(
height
=
600
width
=
600
)
Test
fun
hideDynamicToolbarToRevealFocusedInput
(
)
{
val
dynamicToolbarMaxHeight
=
300
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
HIDE_DYNAMIC_TOOLBAR_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
document
.
getElementById
(
'
input1
'
)
.
focus
(
)
;
"
)
mainSession
.
zoomToFocusedInput
(
)
mainSession
.
waitUntilCalled
(
object
:
ContentDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onHideDynamicToolbar
(
session
:
GeckoSession
)
{
}
}
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
showDynamicToolbarOnOverflowHidden
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
SHOW_DYNAMIC_TOOLBAR_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
window
.
scrollTo
(
0
"
+
dynamicToolbarMaxHeight
+
"
)
"
)
mainSession
.
waitUntilCalled
(
object
:
ScrollDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onScrollChanged
(
session
:
GeckoSession
scrollX
:
Int
scrollY
:
Int
)
{
}
}
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
overflow
=
'
hidden
'
"
)
mainSession
.
waitUntilCalled
(
object
:
ContentDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onShowDynamicToolbar
(
session
:
GeckoSession
)
{
}
}
)
}
private
fun
getComputedViewportHeight
(
style
:
String
)
:
Double
{
val
viewportHeight
=
mainSession
.
evaluateJS
(
"
"
"
const
target
=
document
.
createElement
(
'
div
'
)
;
target
.
style
.
height
=
'
style
'
;
document
.
body
.
appendChild
(
target
)
;
parseFloat
(
getComputedStyle
(
target
)
.
height
)
;
"
"
"
.
trimIndent
(
)
)
as
Double
return
viewportHeight
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
viewportVariants
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
VIEWPORT_PATH
)
mainSession
.
waitForPageStop
(
)
val
pixelRatio
=
mainSession
.
evaluateJS
(
"
window
.
devicePixelRatio
"
)
as
Double
val
scale
=
mainSession
.
evaluateJS
(
"
window
.
visualViewport
.
scale
"
)
as
Double
var
smallViewportHeight
=
getComputedViewportHeight
(
"
100svh
"
)
assertThat
(
"
svh
value
at
the
initial
state
"
smallViewportHeight
closeTo
(
(
SCREEN_HEIGHT
-
dynamicToolbarMaxHeight
)
/
scale
/
pixelRatio
0
.
1
)
)
var
largeViewportHeight
=
getComputedViewportHeight
(
"
100lvh
"
)
assertThat
(
"
lvh
value
at
the
initial
state
"
largeViewportHeight
closeTo
(
SCREEN_HEIGHT
/
scale
/
pixelRatio
0
.
1
)
)
var
dynamicViewportHeight
=
getComputedViewportHeight
(
"
100dvh
"
)
assertThat
(
"
dvh
value
at
the
initial
state
"
dynamicViewportHeight
closeTo
(
(
SCREEN_HEIGHT
-
dynamicToolbarMaxHeight
)
/
scale
/
pixelRatio
0
.
1
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
/
4
)
}
smallViewportHeight
=
getComputedViewportHeight
(
"
100svh
"
)
assertThat
(
"
svh
value
during
toolbar
transition
"
smallViewportHeight
closeTo
(
(
SCREEN_HEIGHT
-
dynamicToolbarMaxHeight
)
/
scale
/
pixelRatio
0
.
1
)
)
largeViewportHeight
=
getComputedViewportHeight
(
"
100lvh
"
)
assertThat
(
"
lvh
value
during
toolbar
transition
"
largeViewportHeight
closeTo
(
SCREEN_HEIGHT
/
scale
/
pixelRatio
0
.
1
)
)
dynamicViewportHeight
=
getComputedViewportHeight
(
"
100dvh
"
)
assertThat
(
"
dvh
value
during
toolbar
transition
"
dynamicViewportHeight
closeTo
(
(
SCREEN_HEIGHT
-
dynamicToolbarMaxHeight
+
dynamicToolbarMaxHeight
/
4
)
/
scale
/
pixelRatio
0
.
1
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
noGapAppearsBetweenBodyAndElementFullyCoveringBody
(
)
{
assumeThat
(
sessionRule
.
env
.
isDebugBuild
equalTo
(
false
)
)
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
BODY_FULLY_COVERED_BY_GREEN_ELEMENT
)
mainSession
.
waitForPageStop
(
)
mainSession
.
flushApzRepaints
(
)
var
downTime
=
SystemClock
.
uptimeMillis
(
)
var
down
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_DOWN
50f
70f
0
)
mainSession
.
panZoomController
.
onTouchEvent
(
down
)
var
move
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_MOVE
50f
30f
0
)
mainSession
.
panZoomController
.
onTouchEvent
(
move
)
var
up
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_UP
50f
10f
0
)
mainSession
.
panZoomController
.
onTouchEvent
(
up
)
mainSession
.
flushApzRepaints
(
)
downTime
=
SystemClock
.
uptimeMillis
(
)
down
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_DOWN
50f
10f
0
)
mainSession
.
panZoomController
.
onTouchEvent
(
down
)
move
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_MOVE
50f
30f
0
)
mainSession
.
panZoomController
.
onTouchEvent
(
move
)
up
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_UP
50f
70f
0
)
mainSession
.
panZoomController
.
onTouchEvent
(
up
)
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
zoomedOverflowHidden
(
)
{
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_BOTTOM
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
document
.
body
.
style
.
background
=
'
rgb
(
0
128
0
)
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
scrollbarWidth
=
'
none
'
"
)
mainSession
.
setResolutionAndScaleTo
(
10
.
0f
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
zoomedPositionFixedRoot
(
)
{
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
FIXED_BOTTOM
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
document
.
body
.
style
.
background
=
'
rgb
(
0
128
0
)
'
"
)
mainSession
.
evaluateJS
(
"
document
.
body
.
style
.
overflow
=
'
scroll
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
position
=
'
fixed
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
scrollbarWidth
=
'
none
'
"
)
mainSession
.
setResolutionAndScaleTo
(
10
.
0f
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
backgroundImageFixed
(
)
{
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
TOUCH_ACTION_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
background
=
'
linear
-
gradient
(
green
green
)
fixed
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
height
=
'
100vh
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
scrollbarWidth
=
'
none
'
"
)
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
backgroundAttachmentFixed
(
)
{
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
TOUCH_ACTION_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
background
=
'
rgb
(
0
128
0
)
fixed
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
height
=
'
100vh
'
"
)
mainSession
.
evaluateJS
(
"
document
.
documentElement
.
style
.
scrollbarWidth
=
'
none
'
"
)
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
withIntersectionObserver1
(
)
{
val
dynamicToolbarMaxHeight
=
20
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
INTERSECTION_OBSERVER_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
"
"
document
.
querySelector
(
'
#
target
'
)
.
style
.
top
=
'
calc
(
100svh
+
1px
)
'
;
document
.
querySelector
(
'
#
target
'
)
.
getBoundingClientRect
(
)
;
"
"
"
.
trimIndent
(
)
)
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
const
intersected
=
entries
.
find
(
entry
=
>
entry
.
isIntersecting
)
;
if
(
intersected
)
{
intersected
.
target
.
style
.
backgroundColor
=
'
green
'
;
resolve
(
true
)
;
}
}
)
;
observer
.
observe
(
document
.
getElementById
(
'
target
'
)
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
var
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
/
2
)
}
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
still
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
withIntersectionObserver2
(
)
{
val
dynamicToolbarMaxHeight
=
20
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
INTERSECTION_OBSERVER_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
"
"
document
.
querySelector
(
'
#
target
'
)
.
style
.
top
=
'
calc
(
100lvh
+
1px
)
'
;
document
.
querySelector
(
'
#
target
'
)
.
getBoundingClientRect
(
)
;
"
"
"
.
trimIndent
(
)
)
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
const
intersected
=
entries
.
find
(
entry
=
>
entry
.
isIntersecting
)
;
if
(
intersected
)
{
intersected
.
target
.
style
.
backgroundColor
=
'
green
'
;
resolve
(
true
)
;
}
}
)
;
observer
.
observe
(
document
.
getElementById
(
'
target
'
)
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
var
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
still
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
mainSession
.
evaluateJS
(
"
window
.
scrollBy
(
0
10
)
"
)
assertThat
(
"
resize
"
promise
.
value
as
Boolean
equalTo
(
true
)
)
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
have
changed
to
green
"
backgroundColor
equalTo
(
"
rgb
(
0
128
0
)
"
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
withIntersectionObserverWithDesktopMode1
(
)
{
val
dynamicToolbarMaxHeight
=
20
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
INTERSECTION_OBSERVER_DESKTOP_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
"
"
document
.
querySelector
(
'
#
target
'
)
.
style
.
top
=
'
calc
(
200svh
+
1px
)
'
;
document
.
querySelector
(
'
#
target
'
)
.
getBoundingClientRect
(
)
;
"
"
"
.
trimIndent
(
)
)
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
const
intersected
=
entries
.
find
(
entry
=
>
entry
.
isIntersecting
)
;
if
(
intersected
)
{
intersected
.
target
.
style
.
backgroundColor
=
'
green
'
;
resolve
(
true
)
;
}
}
)
;
observer
.
observe
(
document
.
getElementById
(
'
target
'
)
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
var
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
/
2
)
}
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
still
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
withIntersectionObserverWithDesktopMode2
(
)
{
val
dynamicToolbarMaxHeight
=
20
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
INTERSECTION_OBSERVER_DESKTOP_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
evaluateJS
(
"
"
"
document
.
querySelector
(
'
#
target
'
)
.
style
.
top
=
'
calc
(
200lvh
+
1px
)
'
;
document
.
querySelector
(
'
#
target
'
)
.
getBoundingClientRect
(
)
;
"
"
"
.
trimIndent
(
)
)
val
promise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
const
intersected
=
entries
.
find
(
entry
=
>
entry
.
isIntersecting
)
;
if
(
intersected
)
{
intersected
.
target
.
style
.
backgroundColor
=
'
green
'
;
resolve
(
true
)
;
}
}
)
;
observer
.
observe
(
document
.
getElementById
(
'
target
'
)
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
var
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
be
still
red
"
backgroundColor
equalTo
(
"
rgb
(
255
0
0
)
"
)
)
mainSession
.
evaluateJS
(
"
window
.
scrollBy
(
0
10
)
"
)
assertThat
(
"
resize
"
promise
.
value
as
Boolean
equalTo
(
true
)
)
backgroundColor
=
mainSession
.
evaluateJS
(
"
"
"
getComputedStyle
(
document
.
querySelector
(
'
#
target
'
)
)
.
backgroundColor
;
"
"
"
.
trimIndent
(
)
)
as
String
assertThat
(
"
The
background
color
of
the
IntersectionObserver
'
s
target
element
should
have
changed
to
green
"
backgroundColor
equalTo
(
"
rgb
(
0
128
0
)
"
)
)
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
bug1909181
(
)
{
val
reference
=
getComparisonScreenshot
(
SCREEN_WIDTH
SCREEN_HEIGHT
)
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
BUG1909181_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
setResolutionAndScaleTo
(
5
.
0f
)
mainSession
.
flushApzRepaints
(
)
mainSession
.
panZoomController
.
scrollBy
(
ScreenLength
.
zero
(
)
ScreenLength
.
fromPixels
(
500
.
0
)
PanZoomController
.
SCROLL_BEHAVIOR_AUTO
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
flushApzRepaints
(
)
mainSession
.
flushApzRepaints
(
)
sessionRule
.
display
?
.
let
{
assertScreenshotResult
(
it
.
capturePixels
(
)
reference
)
}
}
WithDisplay
(
height
=
SCREEN_HEIGHT
width
=
SCREEN_WIDTH
)
Test
fun
hitTestOnPositionSticky
(
)
{
val
dynamicToolbarMaxHeight
=
SCREEN_HEIGHT
/
2
sessionRule
.
display
?
.
run
{
setDynamicToolbarMaxHeight
(
dynamicToolbarMaxHeight
)
}
mainSession
.
setActive
(
true
)
mainSession
.
loadTestPath
(
BaseSessionTest
.
POSITION_STICKY_HTML_PATH
)
mainSession
.
waitForPageStop
(
)
mainSession
.
flushApzRepaints
(
)
val
clickEventPromise
=
mainSession
.
evaluatePromiseJS
(
"
"
"
new
Promise
(
resolve
=
>
{
document
.
querySelector
(
'
button
'
)
.
addEventListener
(
'
click
'
(
)
=
>
{
resolve
(
true
)
;
}
)
;
}
)
;
"
"
"
.
trimIndent
(
)
)
mainSession
.
waitForRoundTrip
(
)
sessionRule
.
display
?
.
run
{
setVerticalClipping
(
-
dynamicToolbarMaxHeight
)
}
mainSession
.
flushApzRepaints
(
)
mainSession
.
synthesizeTap
(
SCREEN_WIDTH
/
2
SCREEN_HEIGHT
-
dynamicToolbarMaxHeight
/
4
)
assertThat
(
"
click
event
"
clickEventPromise
.
value
as
Boolean
equalTo
(
true
)
)
}
}
