package
org
.
mozilla
.
geckoview
.
test
import
androidx
.
annotation
.
AnyThread
import
androidx
.
test
.
ext
.
junit
.
runners
.
AndroidJUnit4
import
androidx
.
test
.
filters
.
MediumTest
import
org
.
hamcrest
.
Matchers
.
*
import
org
.
junit
.
Assume
.
assumeThat
import
org
.
junit
.
Before
import
org
.
junit
.
Test
import
org
.
junit
.
runner
.
RunWith
import
org
.
mozilla
.
geckoview
.
*
import
org
.
mozilla
.
geckoview
.
GeckoSession
.
ContentDelegate
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
AssertCalled
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
IgnoreCrash
RunWith
(
AndroidJUnit4
:
:
class
)
MediumTest
class
ContentDelegateMultipleSessionsTest
:
BaseSessionTest
(
)
{
val
contentProcNameRegex
=
"
.
*
:
tab
\
\
d
+
"
.
toRegex
(
)
AnyThread
fun
killAllContentProcesses
(
)
{
val
contentProcessPids
=
sessionRule
.
getAllSessionPids
(
)
for
(
pid
in
contentProcessPids
)
{
sessionRule
.
killContentProcess
(
pid
)
}
}
fun
resetContentProcesses
(
)
{
val
isMainSessionAlreadyOpen
=
mainSession
.
isOpen
(
)
killAllContentProcesses
(
)
if
(
isMainSessionAlreadyOpen
)
{
mainSession
.
waitUntilCalled
(
object
:
ContentDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onKill
(
session
:
GeckoSession
)
{
}
}
)
}
mainSession
.
open
(
)
}
fun
getE10sProcessCount
(
)
:
Int
{
val
extensionProcessPref
=
"
extensions
.
webextensions
.
remote
"
val
isExtensionProcessEnabled
=
(
sessionRule
.
getPrefs
(
extensionProcessPref
)
[
0
]
as
Boolean
)
val
e10sProcessCountPref
=
"
dom
.
ipc
.
processCount
"
var
numContentProcesses
=
(
sessionRule
.
getPrefs
(
e10sProcessCountPref
)
[
0
]
as
Int
)
if
(
isExtensionProcessEnabled
&
&
numContentProcesses
>
1
)
{
-
-
numContentProcesses
}
return
numContentProcesses
}
fun
getSecondGeckoSession
(
)
:
GeckoSession
{
val
numContentProcesses
=
getE10sProcessCount
(
)
val
additionalSessions
=
Array
(
numContentProcesses
)
{
_
-
>
sessionRule
.
createOpenSession
(
)
}
return
additionalSessions
.
last
(
)
}
Before
fun
setup
(
)
{
resetContentProcesses
(
)
}
IgnoreCrash
Test
fun
crashContentMultipleSessions
(
)
{
assumeThat
(
sessionRule
.
env
.
isFission
equalTo
(
false
)
)
val
newSession
=
getSecondGeckoSession
(
)
val
mainSessionCrash
=
GeckoResult
<
Void
>
(
)
val
newSessionCrash
=
GeckoResult
<
Void
>
(
)
val
allCrashesFound
=
GeckoResult
.
allOf
(
mainSessionCrash
newSessionCrash
)
sessionRule
.
delegateUntilTestEnd
(
object
:
ContentDelegate
{
fun
reportCrash
(
session
:
GeckoSession
)
{
if
(
session
=
=
mainSession
)
{
mainSessionCrash
.
complete
(
null
)
}
else
if
(
session
=
=
newSession
)
{
newSessionCrash
.
complete
(
null
)
}
}
override
fun
onCrash
(
session
:
GeckoSession
)
{
reportCrash
(
session
)
}
override
fun
onKill
(
session
:
GeckoSession
)
{
reportCrash
(
session
)
}
}
)
newSession
.
loadTestPath
(
HELLO_HTML_PATH
)
newSession
.
waitForPageStop
(
)
mainSession
.
loadUri
(
CONTENT_CRASH_URL
)
sessionRule
.
waitForResult
(
allCrashesFound
)
}
IgnoreCrash
Test
fun
killContentMultipleSessions
(
)
{
val
newSession
=
getSecondGeckoSession
(
)
val
mainSessionKilled
=
GeckoResult
<
Void
>
(
)
val
newSessionKilled
=
GeckoResult
<
Void
>
(
)
val
allKillEventsReceived
=
GeckoResult
.
allOf
(
mainSessionKilled
newSessionKilled
)
sessionRule
.
delegateUntilTestEnd
(
object
:
ContentDelegate
{
override
fun
onKill
(
session
:
GeckoSession
)
{
if
(
session
=
=
mainSession
)
{
mainSessionKilled
.
complete
(
null
)
}
else
if
(
session
=
=
newSession
)
{
newSessionKilled
.
complete
(
null
)
}
}
}
)
killAllContentProcesses
(
)
sessionRule
.
waitForResult
(
allKillEventsReceived
)
}
}
