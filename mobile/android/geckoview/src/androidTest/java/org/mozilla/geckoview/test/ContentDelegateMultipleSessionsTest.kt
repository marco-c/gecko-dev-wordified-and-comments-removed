package
org
.
mozilla
.
geckoview
.
test
import
android
.
app
.
ActivityManager
import
android
.
content
.
Context
import
android
.
graphics
.
Matrix
import
android
.
graphics
.
SurfaceTexture
import
android
.
net
.
Uri
import
android
.
os
.
Build
import
android
.
os
.
Bundle
import
android
.
os
.
LocaleList
import
android
.
os
.
Process
import
org
.
mozilla
.
geckoview
.
GeckoSession
.
NavigationDelegate
.
LoadRequest
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
AssertCalled
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
IgnoreCrash
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
WithDisplay
import
org
.
mozilla
.
geckoview
.
test
.
util
.
Callbacks
import
androidx
.
annotation
.
AnyThread
import
androidx
.
test
.
filters
.
MediumTest
import
androidx
.
test
.
ext
.
junit
.
runners
.
AndroidJUnit4
import
android
.
util
.
Pair
import
android
.
util
.
SparseArray
import
android
.
view
.
Surface
import
android
.
view
.
View
import
android
.
view
.
ViewStructure
import
android
.
view
.
autofill
.
AutofillId
import
android
.
view
.
autofill
.
AutofillValue
import
org
.
hamcrest
.
Matchers
.
*
import
org
.
json
.
JSONObject
import
org
.
junit
.
Assume
.
assumeThat
import
org
.
junit
.
Before
import
org
.
junit
.
Test
import
org
.
junit
.
runner
.
RunWith
import
org
.
mozilla
.
gecko
.
GeckoAppShell
import
org
.
mozilla
.
geckoview
.
*
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
NullDelegate
RunWith
(
AndroidJUnit4
:
:
class
)
MediumTest
class
ContentDelegateMultipleSessionsTest
:
BaseSessionTest
(
)
{
val
contentProcNameRegex
=
"
.
*
:
tab
\
\
d
+
"
.
toRegex
(
)
AnyThread
fun
killAllContentProcesses
(
)
{
val
context
=
GeckoAppShell
.
getApplicationContext
(
)
val
manager
=
context
.
getSystemService
(
Context
.
ACTIVITY_SERVICE
)
as
ActivityManager
for
(
info
in
manager
.
runningAppProcesses
)
{
if
(
info
.
processName
.
matches
(
contentProcNameRegex
)
)
{
Process
.
killProcess
(
info
.
pid
)
}
}
}
fun
resetContentProcesses
(
)
{
val
isMainSessionAlreadyOpen
=
mainSession
.
isOpen
(
)
killAllContentProcesses
(
)
if
(
isMainSessionAlreadyOpen
)
{
mainSession
.
waitUntilCalled
(
object
:
Callbacks
.
ContentDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onKill
(
session
:
GeckoSession
)
{
}
}
)
}
mainSession
.
open
(
)
}
fun
getE10sProcessCount
(
)
:
Int
{
val
extensionProcessPref
=
"
extensions
.
webextensions
.
remote
"
val
isExtensionProcessEnabled
=
(
sessionRule
.
getPrefs
(
extensionProcessPref
)
[
0
]
as
Boolean
)
val
e10sProcessCountPref
=
"
dom
.
ipc
.
processCount
"
var
numContentProcesses
=
(
sessionRule
.
getPrefs
(
e10sProcessCountPref
)
[
0
]
as
Int
)
if
(
isExtensionProcessEnabled
&
&
numContentProcesses
>
1
)
{
-
-
numContentProcesses
}
return
numContentProcesses
}
fun
getSecondGeckoSession
(
)
:
GeckoSession
{
val
numContentProcesses
=
getE10sProcessCount
(
)
val
additionalSessions
=
Array
(
numContentProcesses
)
{
_
-
>
sessionRule
.
createOpenSession
(
)
}
return
additionalSessions
.
last
(
)
}
Before
fun
setup
(
)
{
resetContentProcesses
(
)
}
IgnoreCrash
Test
fun
crashContentMultipleSessions
(
)
{
assumeThat
(
sessionRule
.
env
.
isMultiprocess
equalTo
(
true
)
)
val
newSession
=
getSecondGeckoSession
(
)
val
mainSessionCrash
=
GeckoResult
<
Void
>
(
)
val
newSessionCrash
=
GeckoResult
<
Void
>
(
)
val
allCrashesFound
=
GeckoResult
.
allOf
(
mainSessionCrash
newSessionCrash
)
sessionRule
.
delegateUntilTestEnd
(
object
:
Callbacks
.
ContentDelegate
{
fun
reportCrash
(
session
:
GeckoSession
)
{
if
(
session
=
=
mainSession
)
{
mainSessionCrash
.
complete
(
null
)
}
else
if
(
session
=
=
newSession
)
{
newSessionCrash
.
complete
(
null
)
}
}
override
fun
onCrash
(
session
:
GeckoSession
)
{
reportCrash
(
session
)
}
override
fun
onKill
(
session
:
GeckoSession
)
{
reportCrash
(
session
)
}
}
)
newSession
.
loadTestPath
(
HELLO_HTML_PATH
)
newSession
.
waitForPageStop
(
)
mainSession
.
loadUri
(
CONTENT_CRASH_URL
)
sessionRule
.
waitForResult
(
allCrashesFound
)
}
IgnoreCrash
Test
fun
killContentMultipleSessions
(
)
{
assumeThat
(
sessionRule
.
env
.
isMultiprocess
equalTo
(
true
)
)
val
newSession
=
getSecondGeckoSession
(
)
val
mainSessionKilled
=
GeckoResult
<
Void
>
(
)
val
newSessionKilled
=
GeckoResult
<
Void
>
(
)
val
allKillEventsReceived
=
GeckoResult
.
allOf
(
mainSessionKilled
newSessionKilled
)
sessionRule
.
delegateUntilTestEnd
(
object
:
Callbacks
.
ContentDelegate
{
override
fun
onKill
(
session
:
GeckoSession
)
{
if
(
session
=
=
mainSession
)
{
mainSessionKilled
.
complete
(
null
)
}
else
if
(
session
=
=
newSession
)
{
newSessionKilled
.
complete
(
null
)
}
}
}
)
killAllContentProcesses
(
)
sessionRule
.
waitForResult
(
allKillEventsReceived
)
}
}
