package
org
.
mozilla
.
geckoview
.
test
.
rule
;
import
org
.
mozilla
.
geckoview
.
GeckoSession
;
import
org
.
mozilla
.
geckoview
.
GeckoSessionSettings
;
import
org
.
mozilla
.
geckoview
.
test
.
util
.
Callbacks
;
import
static
org
.
hamcrest
.
Matchers
.
*
;
import
static
org
.
junit
.
Assert
.
fail
;
import
org
.
hamcrest
.
Matcher
;
import
org
.
junit
.
rules
.
ErrorCollector
;
import
org
.
junit
.
runner
.
Description
;
import
org
.
junit
.
runners
.
model
.
Statement
;
import
android
.
app
.
Instrumentation
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
android
.
os
.
MessageQueue
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
test
.
InstrumentationRegistry
;
import
android
.
support
.
test
.
rule
.
UiThreadTestRule
;
import
java
.
lang
.
annotation
.
Annotation
;
import
java
.
lang
.
annotation
.
ElementType
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
lang
.
annotation
.
Target
;
import
java
.
lang
.
reflect
.
Field
;
import
java
.
lang
.
reflect
.
InvocationHandler
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
ParameterizedType
;
import
java
.
lang
.
reflect
.
Proxy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
regex
.
Pattern
;
import
kotlin
.
jvm
.
JvmClassMappingKt
;
import
kotlin
.
reflect
.
KClass
;
public
class
GeckoSessionTestRule
extends
UiThreadTestRule
{
private
static
final
long
DEFAULT_TIMEOUT_MILLIS
=
10000
;
public
static
final
String
APK_URI_PREFIX
=
"
resource
:
/
/
android
"
;
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
TimeoutMillis
{
long
value
(
)
;
}
Target
(
{
ElementType
.
ANNOTATION_TYPE
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
Setting
{
enum
Key
{
CHROME_URI
DISPLAY_MODE
SCREEN_ID
USE_MULTIPROCESS
USE_PRIVATE_MODE
USE_REMOTE_DEBUGGER
USE_TRACKING_PROTECTION
;
private
final
GeckoSessionSettings
.
Key
<
?
>
mKey
;
private
final
Class
<
?
>
mType
;
Key
(
)
{
final
Field
field
;
try
{
field
=
GeckoSessionSettings
.
class
.
getField
(
name
(
)
)
;
mKey
=
(
GeckoSessionSettings
.
Key
<
?
>
)
field
.
get
(
null
)
;
}
catch
(
final
NoSuchFieldException
|
IllegalAccessException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
ParameterizedType
genericType
=
(
ParameterizedType
)
field
.
getGenericType
(
)
;
mType
=
(
Class
<
?
>
)
genericType
.
getActualTypeArguments
(
)
[
0
]
;
}
SuppressWarnings
(
"
unchecked
"
)
public
void
set
(
final
GeckoSessionSettings
settings
final
String
value
)
{
if
(
boolean
.
class
.
equals
(
mType
)
|
|
Boolean
.
class
.
equals
(
mType
)
)
{
settings
.
setBoolean
(
(
GeckoSessionSettings
.
Key
<
Boolean
>
)
mKey
Boolean
.
valueOf
(
value
)
)
;
}
else
if
(
int
.
class
.
equals
(
mType
)
|
|
Integer
.
class
.
equals
(
mType
)
)
{
try
{
settings
.
setInt
(
(
GeckoSessionSettings
.
Key
<
Integer
>
)
mKey
(
Integer
)
GeckoSessionSettings
.
class
.
getField
(
value
)
.
get
(
null
)
)
;
return
;
}
catch
(
final
NoSuchFieldException
|
IllegalAccessException
|
ClassCastException
e
)
{
}
settings
.
setInt
(
(
GeckoSessionSettings
.
Key
<
Integer
>
)
mKey
Integer
.
valueOf
(
value
)
)
;
}
else
if
(
String
.
class
.
equals
(
mType
)
)
{
settings
.
setString
(
(
GeckoSessionSettings
.
Key
<
String
>
)
mKey
value
)
;
}
else
{
throw
new
IllegalArgumentException
(
"
Unsupported
type
:
"
+
mType
.
getSimpleName
(
)
)
;
}
}
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
interface
List
{
Setting
[
]
value
(
)
;
}
Key
key
(
)
;
String
value
(
)
;
}
Target
(
ElementType
.
METHOD
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
AssertCalled
{
boolean
value
(
)
default
true
;
int
count
(
)
default
0
;
int
[
]
order
(
)
default
0
;
}
public
static
class
CallRequirement
{
public
final
boolean
allowed
;
public
final
int
count
;
public
final
int
[
]
order
;
public
CallRequirement
(
final
boolean
allowed
final
int
count
final
int
[
]
order
)
{
this
.
allowed
=
allowed
;
this
.
count
=
count
;
this
.
order
=
order
;
}
}
public
static
class
CallInfo
{
public
final
int
counter
;
public
final
int
order
;
CallInfo
(
final
int
counter
final
int
order
)
{
this
.
counter
=
counter
;
this
.
order
=
order
;
}
}
public
static
class
MethodCall
{
public
final
Method
method
;
public
final
CallRequirement
requirement
;
private
int
currentCount
;
MethodCall
(
final
Method
method
)
{
this
(
method
(
CallRequirement
)
null
)
;
}
MethodCall
(
final
Method
method
final
AssertCalled
requirement
)
{
this
(
method
requirement
!
=
null
?
new
CallRequirement
(
requirement
.
value
(
)
requirement
.
count
(
)
requirement
.
order
(
)
)
:
null
)
;
}
public
MethodCall
(
final
Method
method
final
CallRequirement
requirement
)
{
this
.
method
=
method
;
this
.
requirement
=
requirement
;
currentCount
=
0
;
}
Override
public
boolean
equals
(
final
Object
other
)
{
if
(
this
=
=
other
)
{
return
true
;
}
else
if
(
other
instanceof
MethodCall
)
{
return
methodsEqual
(
method
(
(
MethodCall
)
other
)
.
method
)
;
}
else
if
(
other
instanceof
Method
)
{
return
methodsEqual
(
method
(
Method
)
other
)
;
}
return
false
;
}
int
getOrder
(
)
{
if
(
requirement
=
=
null
|
|
currentCount
=
=
0
)
{
return
0
;
}
final
int
[
]
order
=
requirement
.
order
;
if
(
order
=
=
null
|
|
order
.
length
=
=
0
)
{
return
0
;
}
return
order
[
Math
.
min
(
currentCount
-
1
order
.
length
-
1
)
]
;
}
int
getCount
(
)
{
return
(
requirement
=
=
null
)
?
0
:
!
requirement
.
allowed
?
-
1
:
requirement
.
count
;
}
void
incrementCounter
(
)
{
currentCount
+
+
;
}
int
getCurrentCount
(
)
{
return
currentCount
;
}
boolean
allowUnlimitedCalls
(
)
{
return
getCount
(
)
=
=
0
;
}
boolean
allowMoreCalls
(
)
{
final
int
count
=
getCount
(
)
;
return
count
=
=
0
|
|
count
>
currentCount
;
}
CallInfo
getInfo
(
)
{
return
new
CallInfo
(
currentCount
getOrder
(
)
)
;
}
private
static
boolean
methodsEqual
(
final
NonNull
Method
m1
final
NonNull
Method
m2
)
{
return
(
m1
.
getDeclaringClass
(
)
.
isAssignableFrom
(
m2
.
getDeclaringClass
(
)
)
|
|
m2
.
getDeclaringClass
(
)
.
isAssignableFrom
(
m1
.
getDeclaringClass
(
)
)
)
&
&
m1
.
getName
(
)
.
equals
(
m2
.
getName
(
)
)
&
&
m1
.
getReturnType
(
)
.
equals
(
m2
.
getReturnType
(
)
)
&
&
Arrays
.
equals
(
m1
.
getParameterTypes
(
)
m2
.
getParameterTypes
(
)
)
;
}
}
protected
static
class
CallRecord
{
public
final
Method
method
;
public
final
MethodCall
methodCall
;
public
final
Object
[
]
args
;
public
CallRecord
(
final
Method
method
final
Object
[
]
args
)
{
this
.
method
=
method
;
this
.
methodCall
=
new
MethodCall
(
method
)
;
this
.
args
=
args
;
}
}
static
AssertCalled
getAssertCalled
(
final
Method
method
final
Object
callback
)
{
final
AssertCalled
annotation
=
method
.
getAnnotation
(
AssertCalled
.
class
)
;
if
(
annotation
!
=
null
)
{
return
annotation
;
}
try
{
return
callback
.
getClass
(
)
.
getDeclaredMethod
(
"
invoke
"
method
.
getParameterTypes
(
)
)
.
getAnnotation
(
AssertCalled
.
class
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
return
null
;
}
}
private
static
void
addCallbackClasses
(
final
List
<
Class
<
?
>
>
list
final
Class
<
?
>
ifce
)
{
if
(
!
Callbacks
.
class
.
equals
(
ifce
.
getDeclaringClass
(
)
)
)
{
list
.
add
(
ifce
)
;
return
;
}
final
Class
<
?
>
[
]
superIfces
=
ifce
.
getInterfaces
(
)
;
for
(
final
Class
<
?
>
superIfce
:
superIfces
)
{
addCallbackClasses
(
list
superIfce
)
;
}
}
private
static
Class
<
?
>
[
]
getCallbackClasses
(
)
{
final
Class
<
?
>
[
]
ifces
=
Callbacks
.
class
.
getDeclaredClasses
(
)
;
final
List
<
Class
<
?
>
>
list
=
new
ArrayList
<
>
(
ifces
.
length
)
;
for
(
final
Class
<
?
>
ifce
:
ifces
)
{
addCallbackClasses
(
list
ifce
)
;
}
final
HashSet
<
Class
<
?
>
>
set
=
new
HashSet
<
>
(
list
)
;
return
set
.
toArray
(
new
Class
<
?
>
[
set
.
size
(
)
]
)
;
}
private
static
final
List
<
Class
<
?
>
>
CALLBACK_CLASSES
=
Arrays
.
asList
(
getCallbackClasses
(
)
)
;
protected
final
Instrumentation
mInstrumentation
=
InstrumentationRegistry
.
getInstrumentation
(
)
;
protected
final
GeckoSessionSettings
mDefaultSettings
;
protected
ErrorCollector
mErrorCollector
;
protected
GeckoSession
mSession
;
protected
Object
mCallbackProxy
;
protected
List
<
CallRecord
>
mCallRecords
;
protected
int
mLastWaitStart
;
protected
int
mLastWaitEnd
;
protected
MethodCall
mCurrentMethodCall
;
protected
long
mTimeoutMillis
=
DEFAULT_TIMEOUT_MILLIS
;
public
GeckoSessionTestRule
(
)
{
mDefaultSettings
=
new
GeckoSessionSettings
(
)
;
}
public
void
setErrorCollector
(
final
Nullable
ErrorCollector
ec
)
{
mErrorCollector
=
ec
;
}
public
Nullable
ErrorCollector
getErrorCollector
(
)
{
return
mErrorCollector
;
}
private
<
T
>
void
assertThat
(
final
String
reason
final
T
value
final
Matcher
<
T
>
matcher
)
{
if
(
mErrorCollector
!
=
null
)
{
mErrorCollector
.
checkThat
(
reason
value
matcher
)
;
}
else
{
org
.
junit
.
Assert
.
assertThat
(
reason
value
matcher
)
;
}
}
private
void
assertAllowMoreCalls
(
final
MethodCall
call
)
{
final
int
count
=
call
.
getCount
(
)
;
if
(
count
!
=
0
)
{
assertThat
(
call
.
method
.
getName
(
)
+
"
call
count
should
be
within
limit
"
call
.
getCurrentCount
(
)
lessThan
(
Math
.
max
(
0
count
)
)
)
;
}
}
private
void
assertOrder
(
final
MethodCall
call
final
int
order
)
{
final
int
newOrder
=
call
.
getOrder
(
)
;
if
(
newOrder
!
=
0
)
{
assertThat
(
call
.
method
.
getName
(
)
+
"
should
be
in
order
"
newOrder
greaterThanOrEqualTo
(
order
)
)
;
}
}
private
void
assertMatchesCount
(
final
MethodCall
call
)
{
if
(
call
.
requirement
=
=
null
)
{
return
;
}
final
int
count
=
call
.
getCount
(
)
;
if
(
count
<
0
)
{
assertThat
(
call
.
method
.
getName
(
)
+
"
should
not
be
called
"
call
.
getCurrentCount
(
)
equalTo
(
0
)
)
;
}
else
if
(
count
=
=
0
)
{
assertThat
(
call
.
method
.
getName
(
)
+
"
should
be
called
"
call
.
getCurrentCount
(
)
greaterThan
(
0
)
)
;
}
else
{
assertThat
(
call
.
method
.
getName
(
)
+
"
should
be
called
specified
number
of
times
"
call
.
getCurrentCount
(
)
equalTo
(
count
)
)
;
}
}
public
NonNull
GeckoSession
getSession
(
)
{
return
mSession
;
}
protected
static
Method
getCallbackSetter
(
final
NonNull
Class
<
?
>
cls
)
throws
NoSuchMethodException
{
return
GeckoSession
.
class
.
getMethod
(
"
set
"
+
cls
.
getSimpleName
(
)
cls
)
;
}
protected
static
Method
getCallbackGetter
(
final
NonNull
Class
<
?
>
cls
)
throws
NoSuchMethodException
{
return
GeckoSession
.
class
.
getMethod
(
"
get
"
+
cls
.
getSimpleName
(
)
)
;
}
protected
void
applyAnnotations
(
final
Collection
<
Annotation
>
annotations
final
GeckoSessionSettings
settings
)
{
for
(
final
Annotation
annotation
:
annotations
)
{
if
(
TimeoutMillis
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
mTimeoutMillis
=
Math
.
max
(
(
(
TimeoutMillis
)
annotation
)
.
value
(
)
100
)
;
}
else
if
(
Setting
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
(
(
Setting
)
annotation
)
.
key
(
)
.
set
(
settings
(
(
Setting
)
annotation
)
.
value
(
)
)
;
}
else
if
(
Setting
.
List
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
for
(
final
Setting
setting
:
(
(
Setting
.
List
)
annotation
)
.
value
(
)
)
{
setting
.
key
(
)
.
set
(
settings
setting
.
value
(
)
)
;
}
}
}
}
protected
void
prepareSession
(
final
Description
description
)
throws
Throwable
{
final
GeckoSessionSettings
settings
=
new
GeckoSessionSettings
(
mDefaultSettings
)
;
applyAnnotations
(
Arrays
.
asList
(
description
.
getTestClass
(
)
.
getAnnotations
(
)
)
settings
)
;
applyAnnotations
(
description
.
getAnnotations
(
)
settings
)
;
final
List
<
CallRecord
>
records
=
new
ArrayList
<
>
(
)
;
mCallRecords
=
records
;
mLastWaitStart
=
0
;
mLastWaitEnd
=
0
;
final
InvocationHandler
recorder
=
new
InvocationHandler
(
)
{
Override
public
Object
invoke
(
final
Object
proxy
final
Method
method
final
Object
[
]
args
)
{
assertThat
(
"
Callbacks
must
be
on
UI
thread
"
Looper
.
myLooper
(
)
equalTo
(
Looper
.
getMainLooper
(
)
)
)
;
records
.
add
(
new
CallRecord
(
method
args
)
)
;
try
{
return
method
.
invoke
(
Callbacks
.
Default
.
INSTANCE
args
)
;
}
catch
(
final
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
new
RuntimeException
(
e
.
getCause
(
)
!
=
null
?
e
.
getCause
(
)
:
e
)
;
}
}
}
;
final
Class
<
?
>
[
]
classes
=
CALLBACK_CLASSES
.
toArray
(
new
Class
<
?
>
[
CALLBACK_CLASSES
.
size
(
)
]
)
;
mCallbackProxy
=
Proxy
.
newProxyInstance
(
GeckoSession
.
class
.
getClassLoader
(
)
classes
recorder
)
;
mSession
=
new
GeckoSession
(
settings
)
;
for
(
final
Class
<
?
>
cls
:
CALLBACK_CLASSES
)
{
if
(
cls
!
=
null
)
{
getCallbackSetter
(
cls
)
.
invoke
(
mSession
mCallbackProxy
)
;
}
}
mSession
.
openWindow
(
mInstrumentation
.
getTargetContext
(
)
)
;
if
(
settings
.
getBoolean
(
GeckoSessionSettings
.
USE_MULTIPROCESS
)
)
{
waitForPageStop
(
)
;
}
}
protected
void
cleanupSession
(
)
throws
Throwable
{
if
(
mSession
.
isOpen
(
)
)
{
mSession
.
closeWindow
(
)
;
}
mSession
=
null
;
mCallbackProxy
=
null
;
mCallRecords
=
null
;
mLastWaitStart
=
0
;
mLastWaitEnd
=
0
;
mTimeoutMillis
=
DEFAULT_TIMEOUT_MILLIS
;
}
Override
public
Statement
apply
(
final
Statement
base
final
Description
description
)
{
return
super
.
apply
(
new
Statement
(
)
{
Override
public
void
evaluate
(
)
throws
Throwable
{
try
{
prepareSession
(
description
)
;
base
.
evaluate
(
)
;
}
finally
{
cleanupSession
(
)
;
}
}
}
description
)
;
}
Override
protected
boolean
shouldRunOnUiThread
(
final
Description
description
)
{
return
true
;
}
protected
static
void
loopUntilIdle
(
final
long
timeout
)
{
final
Looper
looper
=
Looper
.
myLooper
(
)
;
final
MessageQueue
queue
=
looper
.
getQueue
(
)
;
final
Handler
handler
=
new
Handler
(
looper
)
;
final
MessageQueue
.
IdleHandler
idleHandler
=
new
MessageQueue
.
IdleHandler
(
)
{
Override
public
boolean
queueIdle
(
)
{
final
Message
msg
=
Message
.
obtain
(
handler
)
;
msg
.
obj
=
handler
;
handler
.
sendMessageAtFrontOfQueue
(
msg
)
;
return
false
;
}
}
;
final
Method
getNextMessage
;
try
{
getNextMessage
=
queue
.
getClass
(
)
.
getDeclaredMethod
(
"
next
"
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
getNextMessage
.
setAccessible
(
true
)
;
final
Runnable
timeoutRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
fail
(
"
Timed
out
after
"
+
timeout
+
"
ms
"
)
;
}
}
;
if
(
timeout
>
0
)
{
handler
.
postDelayed
(
timeoutRunnable
timeout
)
;
}
else
{
queue
.
addIdleHandler
(
idleHandler
)
;
}
try
{
while
(
true
)
{
final
Message
msg
;
try
{
msg
=
(
Message
)
getNextMessage
.
invoke
(
queue
)
;
}
catch
(
final
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
new
RuntimeException
(
e
.
getCause
(
)
!
=
null
?
e
.
getCause
(
)
:
e
)
;
}
if
(
msg
.
getTarget
(
)
=
=
handler
&
&
msg
.
obj
=
=
handler
)
{
break
;
}
else
if
(
msg
.
getTarget
(
)
=
=
null
)
{
looper
.
quit
(
)
;
break
;
}
msg
.
getTarget
(
)
.
dispatchMessage
(
msg
)
;
if
(
timeout
>
0
)
{
handler
.
removeCallbacks
(
timeoutRunnable
)
;
queue
.
addIdleHandler
(
idleHandler
)
;
}
}
}
finally
{
if
(
timeout
>
0
)
{
handler
.
removeCallbacks
(
timeoutRunnable
)
;
}
}
}
public
void
waitForPageStop
(
)
{
waitForPageStops
(
1
)
;
}
public
void
waitForPageStops
(
final
int
count
)
{
final
Method
onPageStop
;
try
{
onPageStop
=
GeckoSession
.
ProgressListener
.
class
.
getMethod
(
"
onPageStop
"
GeckoSession
.
class
boolean
.
class
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
List
<
MethodCall
>
methodCalls
=
new
ArrayList
<
>
(
1
)
;
methodCalls
.
add
(
new
MethodCall
(
onPageStop
new
CallRequirement
(
true
count
null
)
)
)
;
waitUntilCalled
(
GeckoSession
.
ProgressListener
.
class
methodCalls
)
;
}
public
void
waitUntilCalled
(
final
NonNull
KClass
<
?
>
callback
final
Nullable
String
.
.
.
methods
)
{
waitUntilCalled
(
JvmClassMappingKt
.
getJavaClass
(
callback
)
methods
)
;
}
public
void
waitUntilCalled
(
final
NonNull
Class
<
?
>
callback
final
Nullable
String
.
.
.
methods
)
{
assertThat
(
"
Class
should
be
a
GeckoSession
interface
"
callback
isIn
(
CALLBACK_CLASSES
)
)
;
final
int
length
=
(
methods
!
=
null
)
?
methods
.
length
:
0
;
final
Pattern
[
]
patterns
=
new
Pattern
[
length
]
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
patterns
[
i
]
=
Pattern
.
compile
(
methods
[
i
]
)
;
}
final
List
<
MethodCall
>
waitMethods
=
new
ArrayList
<
>
(
)
;
for
(
final
Method
method
:
callback
.
getDeclaredMethods
(
)
)
{
for
(
final
Pattern
pattern
:
patterns
)
{
if
(
pattern
.
matcher
(
method
.
getName
(
)
)
.
matches
(
)
)
{
waitMethods
.
add
(
new
MethodCall
(
method
)
)
;
}
}
}
waitUntilCalled
(
callback
waitMethods
)
;
}
public
void
waitUntilCalled
(
final
NonNull
Object
callback
)
{
if
(
callback
instanceof
Class
<
?
>
)
{
waitUntilCalled
(
(
Class
<
?
>
)
callback
(
String
[
]
)
null
)
;
return
;
}
final
List
<
MethodCall
>
methodCalls
=
new
ArrayList
<
>
(
)
;
for
(
final
Class
<
?
>
ifce
:
CALLBACK_CLASSES
)
{
if
(
!
ifce
.
isInstance
(
callback
)
)
{
continue
;
}
for
(
final
Method
method
:
ifce
.
getMethods
(
)
)
{
final
Method
callbackMethod
;
try
{
callbackMethod
=
callback
.
getClass
(
)
.
getMethod
(
method
.
getName
(
)
method
.
getParameterTypes
(
)
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
AssertCalled
ac
=
getAssertCalled
(
callbackMethod
callback
)
;
if
(
ac
!
=
null
&
&
ac
.
value
(
)
)
{
methodCalls
.
add
(
new
MethodCall
(
callbackMethod
ac
)
)
;
}
}
}
waitUntilCalled
(
callback
.
getClass
(
)
methodCalls
)
;
forCallbacksDuringWait
(
callback
)
;
}
protected
void
waitUntilCalled
(
final
NonNull
Class
<
?
>
listener
final
NonNull
List
<
MethodCall
>
methodCalls
)
{
for
(
final
Class
<
?
>
ifce
:
CALLBACK_CLASSES
)
{
try
{
assertThat
(
"
Callbacks
should
be
set
through
"
+
"
GeckoSessionTestRule
delegate
methods
"
getCallbackGetter
(
ifce
)
.
invoke
(
mSession
)
sameInstance
(
mCallbackProxy
)
)
;
}
catch
(
final
NoSuchMethodException
|
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
new
RuntimeException
(
e
.
getCause
(
)
!
=
null
?
e
.
getCause
(
)
:
e
)
;
}
}
boolean
calledAny
=
false
;
int
index
=
mLastWaitStart
=
mLastWaitEnd
;
while
(
!
calledAny
|
|
!
methodCalls
.
isEmpty
(
)
)
{
while
(
index
>
=
mCallRecords
.
size
(
)
)
{
loopUntilIdle
(
mTimeoutMillis
)
;
}
final
MethodCall
recorded
=
mCallRecords
.
get
(
index
)
.
methodCall
;
calledAny
|
=
recorded
.
method
.
getDeclaringClass
(
)
.
isAssignableFrom
(
listener
)
;
index
+
+
;
final
int
i
=
methodCalls
.
indexOf
(
recorded
)
;
if
(
i
<
0
)
{
continue
;
}
final
MethodCall
methodCall
=
methodCalls
.
get
(
i
)
;
methodCall
.
incrementCounter
(
)
;
if
(
methodCall
.
allowUnlimitedCalls
(
)
|
|
!
methodCall
.
allowMoreCalls
(
)
)
{
methodCalls
.
remove
(
i
)
;
}
}
mLastWaitEnd
=
index
;
}
public
void
forCallbacksDuringWait
(
final
NonNull
Object
callback
)
{
final
Method
[
]
declaredMethods
=
callback
.
getClass
(
)
.
getDeclaredMethods
(
)
;
final
List
<
MethodCall
>
methodCalls
=
new
ArrayList
<
>
(
declaredMethods
.
length
)
;
for
(
final
Class
<
?
>
ifce
:
CALLBACK_CLASSES
)
{
if
(
!
ifce
.
isInstance
(
callback
)
)
{
continue
;
}
for
(
final
Method
method
:
ifce
.
getMethods
(
)
)
{
final
Method
callbackMethod
;
try
{
callbackMethod
=
callback
.
getClass
(
)
.
getMethod
(
method
.
getName
(
)
method
.
getParameterTypes
(
)
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
methodCalls
.
add
(
new
MethodCall
(
callbackMethod
getAssertCalled
(
callbackMethod
callback
)
)
)
;
}
}
int
order
=
0
;
boolean
calledAny
=
false
;
for
(
int
index
=
mLastWaitStart
;
index
<
mLastWaitEnd
;
index
+
+
)
{
final
CallRecord
record
=
mCallRecords
.
get
(
index
)
;
if
(
!
record
.
method
.
getDeclaringClass
(
)
.
isInstance
(
callback
)
)
{
continue
;
}
final
int
i
=
methodCalls
.
indexOf
(
record
.
methodCall
)
;
assertThat
(
record
.
method
.
getName
(
)
+
"
should
be
found
"
i
greaterThanOrEqualTo
(
0
)
)
;
final
MethodCall
methodCall
=
methodCalls
.
get
(
i
)
;
assertAllowMoreCalls
(
methodCall
)
;
methodCall
.
incrementCounter
(
)
;
assertOrder
(
methodCall
order
)
;
order
=
Math
.
max
(
methodCall
.
getOrder
(
)
order
)
;
try
{
mCurrentMethodCall
=
methodCall
;
record
.
method
.
invoke
(
callback
record
.
args
)
;
}
catch
(
final
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
new
RuntimeException
(
e
.
getCause
(
)
!
=
null
?
e
.
getCause
(
)
:
e
)
;
}
finally
{
mCurrentMethodCall
=
null
;
}
calledAny
=
true
;
}
for
(
final
MethodCall
methodCall
:
methodCalls
)
{
assertMatchesCount
(
methodCall
)
;
if
(
methodCall
.
requirement
!
=
null
)
{
calledAny
=
true
;
}
}
assertThat
(
"
Should
have
called
one
of
"
+
Arrays
.
toString
(
callback
.
getClass
(
)
.
getInterfaces
(
)
)
calledAny
equalTo
(
true
)
)
;
}
public
NonNull
CallInfo
getCurrentCall
(
)
{
assertThat
(
"
Should
be
in
a
method
call
"
mCurrentMethodCall
notNullValue
(
)
)
;
return
mCurrentMethodCall
.
getInfo
(
)
;
}
}
