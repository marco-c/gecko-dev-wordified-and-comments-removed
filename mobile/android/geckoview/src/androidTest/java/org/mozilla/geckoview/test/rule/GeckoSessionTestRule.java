package
org
.
mozilla
.
geckoview
.
test
.
rule
;
import
org
.
mozilla
.
gecko
.
gfx
.
GeckoDisplay
;
import
org
.
mozilla
.
geckoview
.
BuildConfig
;
import
org
.
mozilla
.
geckoview
.
GeckoResponse
;
import
org
.
mozilla
.
geckoview
.
GeckoRuntime
;
import
org
.
mozilla
.
geckoview
.
GeckoRuntimeSettings
;
import
org
.
mozilla
.
geckoview
.
GeckoSession
;
import
org
.
mozilla
.
geckoview
.
GeckoSessionSettings
;
import
org
.
mozilla
.
geckoview
.
SessionTextInput
;
import
org
.
mozilla
.
geckoview
.
test
.
rdp
.
Actor
;
import
org
.
mozilla
.
geckoview
.
test
.
rdp
.
Promise
;
import
org
.
mozilla
.
geckoview
.
test
.
rdp
.
RDPConnection
;
import
org
.
mozilla
.
geckoview
.
test
.
rdp
.
Tab
;
import
org
.
mozilla
.
geckoview
.
test
.
util
.
Callbacks
;
import
static
org
.
hamcrest
.
Matchers
.
*
;
import
static
org
.
junit
.
Assert
.
assertThat
;
import
static
org
.
junit
.
Assert
.
fail
;
import
org
.
hamcrest
.
Matcher
;
import
org
.
json
.
JSONObject
;
import
org
.
junit
.
rules
.
ErrorCollector
;
import
org
.
junit
.
runner
.
Description
;
import
org
.
junit
.
runners
.
model
.
Statement
;
import
android
.
app
.
Instrumentation
;
import
android
.
graphics
.
Point
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
net
.
LocalSocketAddress
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Debug
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
android
.
os
.
MessageQueue
;
import
android
.
os
.
Process
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
test
.
InstrumentationRegistry
;
import
android
.
support
.
test
.
rule
.
UiThreadTestRule
;
import
android
.
util
.
Log
;
import
android
.
util
.
Pair
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
Surface
;
import
java
.
io
.
File
;
import
java
.
lang
.
annotation
.
Annotation
;
import
java
.
lang
.
annotation
.
ElementType
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
lang
.
annotation
.
Target
;
import
java
.
lang
.
reflect
.
Field
;
import
java
.
lang
.
reflect
.
InvocationHandler
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
ParameterizedType
;
import
java
.
lang
.
reflect
.
Proxy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
regex
.
Pattern
;
import
kotlin
.
jvm
.
JvmClassMappingKt
;
import
kotlin
.
reflect
.
KClass
;
public
class
GeckoSessionTestRule
extends
UiThreadTestRule
{
private
static
final
String
LOGTAG
=
"
GeckoSessionTestRule
"
;
private
static
final
long
DEFAULT_TIMEOUT_MILLIS
=
10000
;
private
static
final
long
DEFAULT_ARM_DEVICE_TIMEOUT_MILLIS
=
30000
;
private
static
final
long
DEFAULT_ARM_EMULATOR_TIMEOUT_MILLIS
=
120000
;
private
static
final
long
DEFAULT_X86_DEVICE_TIMEOUT_MILLIS
=
30000
;
private
static
final
long
DEFAULT_X86_EMULATOR_TIMEOUT_MILLIS
=
5000
;
private
static
final
long
DEFAULT_IDE_DEBUG_TIMEOUT_MILLIS
=
86400000
;
public
static
final
String
APK_URI_PREFIX
=
"
resource
:
/
/
android
/
"
;
private
static
final
Method
sGetNextMessage
;
private
static
final
Method
sOnPageStop
;
private
static
final
Method
sOnNewSession
;
private
static
final
Method
sOnCrash
;
static
{
try
{
sGetNextMessage
=
MessageQueue
.
class
.
getDeclaredMethod
(
"
next
"
)
;
sGetNextMessage
.
setAccessible
(
true
)
;
sOnPageStop
=
GeckoSession
.
ProgressDelegate
.
class
.
getMethod
(
"
onPageStop
"
GeckoSession
.
class
boolean
.
class
)
;
sOnNewSession
=
GeckoSession
.
NavigationDelegate
.
class
.
getMethod
(
"
onNewSession
"
GeckoSession
.
class
String
.
class
GeckoResponse
.
class
)
;
sOnCrash
=
GeckoSession
.
ContentDelegate
.
class
.
getMethod
(
"
onCrash
"
GeckoSession
.
class
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
TimeoutMillis
{
long
value
(
)
;
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
WithDisplay
{
int
width
(
)
;
int
height
(
)
;
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
ClosedSessionAtStart
{
boolean
value
(
)
default
true
;
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
NullDelegate
{
Class
<
?
>
value
(
)
;
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
interface
List
{
NullDelegate
[
]
value
(
)
;
}
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
WithDevToolsAPI
{
boolean
value
(
)
default
true
;
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
Setting
{
enum
Key
{
CHROME_URI
DISPLAY_MODE
SCREEN_ID
USE_MULTIPROCESS
USE_PRIVATE_MODE
USE_TRACKING_PROTECTION
;
private
final
GeckoSessionSettings
.
Key
<
?
>
mKey
;
private
final
Class
<
?
>
mType
;
Key
(
)
{
final
Field
field
;
try
{
field
=
GeckoSessionSettings
.
class
.
getField
(
name
(
)
)
;
mKey
=
(
GeckoSessionSettings
.
Key
<
?
>
)
field
.
get
(
null
)
;
}
catch
(
final
NoSuchFieldException
|
IllegalAccessException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
ParameterizedType
genericType
=
(
ParameterizedType
)
field
.
getGenericType
(
)
;
mType
=
(
Class
<
?
>
)
genericType
.
getActualTypeArguments
(
)
[
0
]
;
}
SuppressWarnings
(
"
unchecked
"
)
public
void
set
(
final
GeckoSessionSettings
settings
final
String
value
)
{
if
(
boolean
.
class
.
equals
(
mType
)
|
|
Boolean
.
class
.
equals
(
mType
)
)
{
settings
.
setBoolean
(
(
GeckoSessionSettings
.
Key
<
Boolean
>
)
mKey
Boolean
.
valueOf
(
value
)
)
;
}
else
if
(
int
.
class
.
equals
(
mType
)
|
|
Integer
.
class
.
equals
(
mType
)
)
{
try
{
settings
.
setInt
(
(
GeckoSessionSettings
.
Key
<
Integer
>
)
mKey
(
Integer
)
GeckoSessionSettings
.
class
.
getField
(
value
)
.
get
(
null
)
)
;
}
catch
(
final
NoSuchFieldException
|
IllegalAccessException
|
ClassCastException
e
)
{
settings
.
setInt
(
(
GeckoSessionSettings
.
Key
<
Integer
>
)
mKey
Integer
.
valueOf
(
value
)
)
;
}
}
else
if
(
String
.
class
.
equals
(
mType
)
)
{
settings
.
setString
(
(
GeckoSessionSettings
.
Key
<
String
>
)
mKey
value
)
;
}
else
{
throw
new
IllegalArgumentException
(
"
Unsupported
type
:
"
+
mType
.
getSimpleName
(
)
)
;
}
}
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
interface
List
{
Setting
[
]
value
(
)
;
}
Key
key
(
)
;
String
value
(
)
;
}
Target
(
{
ElementType
.
METHOD
ElementType
.
TYPE
}
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
ReuseSession
{
boolean
value
(
)
default
true
;
}
Target
(
ElementType
.
METHOD
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
AssertCalled
{
boolean
value
(
)
default
true
;
int
count
(
)
default
-
1
;
int
[
]
order
(
)
default
0
;
}
public
interface
DelegateRegistrar
<
T
>
{
void
invoke
(
T
delegate
)
throws
Throwable
;
}
Target
(
ElementType
.
METHOD
)
Retention
(
RetentionPolicy
.
RUNTIME
)
public
interface
IgnoreCrash
{
boolean
value
(
)
default
true
;
}
public
static
class
TimeoutException
extends
RuntimeException
{
public
TimeoutException
(
final
String
detailMessage
)
{
super
(
detailMessage
)
;
}
}
public
static
class
RejectedPromiseException
extends
RuntimeException
{
private
final
Object
mReason
;
RejectedPromiseException
(
final
Object
reason
)
{
super
(
String
.
valueOf
(
reason
)
)
;
mReason
=
reason
;
}
public
Object
getReason
(
)
{
return
mReason
;
}
}
public
static
class
PromiseWrapper
{
private
final
Promise
mPromise
;
private
final
long
mTimeoutMillis
;
PromiseWrapper
(
final
NonNull
Promise
promise
final
long
timeoutMillis
)
{
mPromise
=
promise
;
mTimeoutMillis
=
timeoutMillis
;
}
Override
public
boolean
equals
(
final
Object
o
)
{
return
(
o
instanceof
PromiseWrapper
)
&
&
mPromise
.
equals
(
(
(
PromiseWrapper
)
o
)
.
mPromise
)
;
}
Override
public
int
hashCode
(
)
{
return
mPromise
.
hashCode
(
)
;
}
Override
public
String
toString
(
)
{
return
mPromise
.
toString
(
)
;
}
public
boolean
isPending
(
)
{
return
mPromise
.
isPending
(
)
;
}
public
Object
getValue
(
)
{
while
(
mPromise
.
isPending
(
)
)
{
loopUntilIdle
(
mTimeoutMillis
)
;
}
if
(
mPromise
.
isRejected
(
)
)
{
throw
new
RejectedPromiseException
(
mPromise
.
getReason
(
)
)
;
}
return
mPromise
.
getValue
(
)
;
}
}
public
static
class
CallRequirement
{
public
final
boolean
allowed
;
public
final
int
count
;
public
final
int
[
]
order
;
public
CallRequirement
(
final
boolean
allowed
final
int
count
final
int
[
]
order
)
{
this
.
allowed
=
allowed
;
this
.
count
=
count
;
this
.
order
=
order
;
}
}
public
static
class
CallInfo
{
public
final
int
counter
;
public
final
int
order
;
CallInfo
(
final
int
counter
final
int
order
)
{
this
.
counter
=
counter
;
this
.
order
=
order
;
}
}
public
static
class
MethodCall
{
public
final
GeckoSession
session
;
public
final
Method
method
;
public
final
CallRequirement
requirement
;
public
final
Object
target
;
private
int
currentCount
;
public
MethodCall
(
final
GeckoSession
session
final
Method
method
final
CallRequirement
requirement
)
{
this
(
session
method
requirement
null
)
;
}
MethodCall
(
final
GeckoSession
session
final
Method
method
final
AssertCalled
annotation
final
Object
target
)
{
this
(
session
method
(
annotation
!
=
null
)
?
new
CallRequirement
(
annotation
.
value
(
)
annotation
.
count
(
)
annotation
.
order
(
)
)
:
null
target
)
;
}
MethodCall
(
final
GeckoSession
session
final
Method
method
final
CallRequirement
requirement
final
Object
target
)
{
this
.
session
=
session
;
this
.
method
=
method
;
this
.
requirement
=
requirement
;
this
.
target
=
target
;
currentCount
=
0
;
}
Override
public
boolean
equals
(
final
Object
other
)
{
if
(
this
=
=
other
)
{
return
true
;
}
else
if
(
other
instanceof
MethodCall
)
{
final
MethodCall
otherCall
=
(
MethodCall
)
other
;
return
(
session
=
=
null
|
|
otherCall
.
session
=
=
null
|
|
session
=
=
otherCall
.
session
)
&
&
methodsEqual
(
method
(
(
MethodCall
)
other
)
.
method
)
;
}
else
if
(
other
instanceof
Method
)
{
return
methodsEqual
(
method
(
Method
)
other
)
;
}
return
false
;
}
Override
public
int
hashCode
(
)
{
return
method
.
hashCode
(
)
;
}
int
getOrder
(
)
{
if
(
requirement
=
=
null
|
|
currentCount
=
=
0
)
{
return
0
;
}
final
int
[
]
order
=
requirement
.
order
;
if
(
order
=
=
null
|
|
order
.
length
=
=
0
)
{
return
0
;
}
return
order
[
Math
.
min
(
currentCount
-
1
order
.
length
-
1
)
]
;
}
int
getCount
(
)
{
return
(
requirement
=
=
null
)
?
-
1
:
requirement
.
allowed
?
requirement
.
count
:
0
;
}
void
incrementCounter
(
)
{
currentCount
+
+
;
}
int
getCurrentCount
(
)
{
return
currentCount
;
}
boolean
allowUnlimitedCalls
(
)
{
return
getCount
(
)
=
=
-
1
;
}
boolean
allowMoreCalls
(
)
{
final
int
count
=
getCount
(
)
;
return
count
=
=
-
1
|
|
count
>
currentCount
;
}
CallInfo
getInfo
(
)
{
return
new
CallInfo
(
currentCount
getOrder
(
)
)
;
}
private
static
boolean
methodsEqual
(
final
NonNull
Method
m1
final
NonNull
Method
m2
)
{
return
(
m1
.
getDeclaringClass
(
)
.
isAssignableFrom
(
m2
.
getDeclaringClass
(
)
)
|
|
m2
.
getDeclaringClass
(
)
.
isAssignableFrom
(
m1
.
getDeclaringClass
(
)
)
)
&
&
m1
.
getName
(
)
.
equals
(
m2
.
getName
(
)
)
&
&
m1
.
getReturnType
(
)
.
equals
(
m2
.
getReturnType
(
)
)
&
&
Arrays
.
equals
(
m1
.
getParameterTypes
(
)
m2
.
getParameterTypes
(
)
)
;
}
}
protected
static
class
CallRecord
{
public
final
Method
method
;
public
final
MethodCall
methodCall
;
public
final
Object
[
]
args
;
public
CallRecord
(
final
GeckoSession
session
final
Method
method
final
Object
[
]
args
)
{
this
.
method
=
method
;
this
.
methodCall
=
new
MethodCall
(
session
method
null
)
;
this
.
args
=
args
;
}
}
protected
interface
CallRecordHandler
{
boolean
handleCall
(
Method
method
Object
[
]
args
)
;
}
public
class
Environment
{
Environment
(
)
{
}
private
String
getEnvVar
(
final
String
name
)
{
final
int
nameLen
=
name
.
length
(
)
;
final
Bundle
args
=
InstrumentationRegistry
.
getArguments
(
)
;
String
env
=
args
.
getString
(
"
env0
"
null
)
;
for
(
int
i
=
1
;
env
!
=
null
;
i
+
+
)
{
if
(
env
.
length
(
)
>
=
nameLen
+
1
&
&
env
.
startsWith
(
name
)
&
&
env
.
charAt
(
nameLen
)
=
=
'
=
'
)
{
return
env
.
substring
(
nameLen
+
1
)
;
}
env
=
args
.
getString
(
"
env
"
+
i
null
)
;
}
return
"
"
;
}
public
boolean
isAutomation
(
)
{
return
!
getEnvVar
(
"
MOZ_IN_AUTOMATION
"
)
.
isEmpty
(
)
;
}
public
boolean
shouldShutdownOnCrash
(
)
{
return
!
getEnvVar
(
"
MOZ_CRASHREPORTER_SHUTDOWN
"
)
.
isEmpty
(
)
;
}
public
boolean
isMultiprocess
(
)
{
return
Boolean
.
valueOf
(
InstrumentationRegistry
.
getArguments
(
)
.
getString
(
"
use_multiprocess
"
"
true
"
)
)
;
}
public
boolean
isDebugging
(
)
{
return
Debug
.
isDebuggerConnected
(
)
;
}
public
boolean
isEmulator
(
)
{
return
"
generic
"
.
equals
(
Build
.
DEVICE
)
|
|
Build
.
DEVICE
.
startsWith
(
"
generic_
"
)
;
}
public
boolean
isDebugBuild
(
)
{
return
BuildConfig
.
DEBUG_BUILD
;
}
public
String
getCPUArch
(
)
{
return
BuildConfig
.
ANDROID_CPU_ARCH
;
}
}
protected
final
class
ExternalDelegate
<
T
>
{
public
final
Class
<
T
>
delegate
;
private
final
DelegateRegistrar
<
T
>
mRegister
;
private
final
DelegateRegistrar
<
T
>
mUnregister
;
private
final
T
mProxy
;
private
boolean
mRegistered
;
public
ExternalDelegate
(
final
Class
<
T
>
delegate
final
T
impl
final
DelegateRegistrar
<
T
>
register
final
DelegateRegistrar
<
T
>
unregister
)
{
this
.
delegate
=
delegate
;
mRegister
=
register
;
mUnregister
=
unregister
;
SuppressWarnings
(
"
unchecked
"
)
final
T
delegateProxy
=
(
T
)
Proxy
.
newProxyInstance
(
getClass
(
)
.
getClassLoader
(
)
impl
.
getClass
(
)
.
getInterfaces
(
)
Proxy
.
getInvocationHandler
(
mCallbackProxy
)
)
;
mProxy
=
delegateProxy
;
}
Override
public
int
hashCode
(
)
{
return
delegate
.
hashCode
(
)
;
}
Override
public
boolean
equals
(
Object
obj
)
{
return
obj
instanceof
ExternalDelegate
<
?
>
&
&
delegate
.
equals
(
(
(
ExternalDelegate
<
?
>
)
obj
)
.
delegate
)
;
}
public
void
register
(
)
{
try
{
if
(
!
mRegistered
)
{
mRegister
.
invoke
(
mProxy
)
;
mRegistered
=
true
;
}
}
catch
(
final
Throwable
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
}
public
void
unregister
(
)
{
try
{
if
(
mRegistered
)
{
mUnregister
.
invoke
(
mProxy
)
;
mRegistered
=
false
;
}
}
catch
(
final
Throwable
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
}
}
protected
class
CallbackDelegates
{
private
final
Map
<
Pair
<
GeckoSession
Method
>
MethodCall
>
mDelegates
=
new
HashMap
<
>
(
)
;
private
final
List
<
ExternalDelegate
<
?
>
>
mExternalDelegates
=
new
ArrayList
<
>
(
)
;
private
int
mOrder
;
private
String
mOldPrefs
;
public
void
delegate
(
final
Nullable
GeckoSession
session
final
NonNull
Object
callback
)
{
for
(
final
Class
<
?
>
ifce
:
DEFAULT_DELEGATES
)
{
if
(
!
ifce
.
isInstance
(
callback
)
)
{
continue
;
}
assertThat
(
"
Cannot
delegate
null
-
delegate
callbacks
"
ifce
not
(
isIn
(
mNullDelegates
)
)
)
;
addDelegatesForInterface
(
session
callback
ifce
)
;
}
}
private
void
addDelegatesForInterface
(
Nullable
final
GeckoSession
session
NonNull
final
Object
callback
NonNull
final
Class
<
?
>
ifce
)
{
for
(
final
Method
method
:
ifce
.
getMethods
(
)
)
{
final
Method
callbackMethod
;
try
{
callbackMethod
=
callback
.
getClass
(
)
.
getMethod
(
method
.
getName
(
)
method
.
getParameterTypes
(
)
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
Pair
<
GeckoSession
Method
>
pair
=
new
Pair
<
>
(
session
method
)
;
final
MethodCall
call
=
new
MethodCall
(
session
callbackMethod
getAssertCalled
(
callbackMethod
callback
)
callback
)
;
assertThat
(
"
Cannot
replace
an
existing
delegate
"
mDelegates
not
(
hasKey
(
pair
)
)
)
;
mDelegates
.
put
(
pair
call
)
;
}
}
public
<
T
>
ExternalDelegate
<
T
>
addExternalDelegate
(
NonNull
final
Class
<
T
>
delegate
NonNull
final
DelegateRegistrar
<
T
>
register
NonNull
final
DelegateRegistrar
<
T
>
unregister
NonNull
final
T
impl
)
{
assertThat
(
"
Delegate
must
be
an
interface
"
delegate
.
isInterface
(
)
equalTo
(
true
)
)
;
addDelegatesForInterface
(
null
impl
delegate
)
;
final
ExternalDelegate
<
T
>
externalDelegate
=
new
ExternalDelegate
<
>
(
delegate
impl
register
unregister
)
;
mExternalDelegates
.
add
(
externalDelegate
)
;
mAllDelegates
.
add
(
delegate
)
;
return
externalDelegate
;
}
NonNull
public
List
<
ExternalDelegate
<
?
>
>
getExternalDelegates
(
)
{
return
mExternalDelegates
;
}
public
void
setPrefs
(
final
NonNull
Map
<
String
?
>
prefs
)
{
final
String
existingPrefs
;
if
(
mOldPrefs
=
=
null
)
{
existingPrefs
=
"
{
}
"
;
}
else
{
existingPrefs
=
String
.
format
(
"
JSON
.
parse
(
%
s
)
"
JSONObject
.
quote
(
mOldPrefs
)
)
;
}
final
StringBuilder
newPrefs
=
new
StringBuilder
(
)
;
for
(
final
Map
.
Entry
<
String
?
>
pref
:
prefs
.
entrySet
(
)
)
{
final
String
name
=
JSONObject
.
quote
(
pref
.
getKey
(
)
)
;
final
Object
value
=
pref
.
getValue
(
)
;
final
String
jsValue
;
if
(
value
instanceof
Boolean
)
{
jsValue
=
value
.
toString
(
)
;
}
else
if
(
value
instanceof
Number
)
{
jsValue
=
String
.
valueOf
(
(
(
Number
)
value
)
.
intValue
(
)
)
;
}
else
if
(
value
instanceof
CharSequence
)
{
jsValue
=
JSONObject
.
quote
(
value
.
toString
(
)
)
;
}
else
{
throw
new
IllegalArgumentException
(
"
Unsupported
pref
value
:
"
+
value
)
;
}
newPrefs
.
append
(
String
.
format
(
"
%
s
:
%
s
"
name
jsValue
)
)
;
}
final
String
prefSetter
=
String
.
format
(
"
(
function
(
)
{
"
+
"
const
prefs
=
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
'
"
+
"
{
}
)
.
Preferences
;
"
+
"
const
oldPrefs
=
%
1
s
;
"
+
"
const
newPrefs
=
{
%
2
s
}
;
"
+
"
Object
.
assign
(
oldPrefs
"
+
"
.
.
.
Object
.
keys
(
newPrefs
)
"
+
"
.
filter
(
key
=
>
!
(
key
in
oldPrefs
)
)
"
+
"
.
map
(
key
=
>
(
{
[
key
]
:
prefs
.
get
(
key
null
)
}
)
)
)
;
"
+
"
prefs
.
set
(
newPrefs
)
;
"
+
"
return
JSON
.
stringify
(
oldPrefs
)
;
"
+
"
}
)
(
)
"
existingPrefs
newPrefs
.
toString
(
)
)
;
final
Object
oldPrefs
=
evaluateChromeJS
(
prefSetter
)
;
assertThat
(
"
Old
prefs
should
be
JSON
string
"
oldPrefs
instanceOf
(
String
.
class
)
)
;
mOldPrefs
=
(
String
)
oldPrefs
;
}
private
void
restorePrefs
(
)
{
if
(
mOldPrefs
=
=
null
)
{
return
;
}
evaluateChromeJS
(
String
.
format
(
"
(
function
(
)
{
"
+
"
const
prefs
=
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
'
"
+
"
{
}
)
.
Preferences
;
"
+
"
const
oldPrefs
=
JSON
.
parse
(
%
1
s
)
;
"
+
"
for
(
let
[
name
value
]
of
Object
.
entries
(
oldPrefs
)
)
{
"
+
"
if
(
value
=
=
=
null
)
{
"
+
"
prefs
.
reset
(
name
)
;
"
+
"
}
else
{
"
+
"
prefs
.
set
(
name
value
)
;
"
+
"
}
"
+
"
}
"
+
"
}
)
(
)
"
JSONObject
.
quote
(
mOldPrefs
)
)
)
;
mOldPrefs
=
null
;
}
public
void
clear
(
)
{
for
(
int
i
=
mExternalDelegates
.
size
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
mExternalDelegates
.
get
(
i
)
.
unregister
(
)
;
}
mExternalDelegates
.
clear
(
)
;
mDelegates
.
clear
(
)
;
mOrder
=
0
;
restorePrefs
(
)
;
}
public
void
clearAndAssert
(
)
{
final
Collection
<
MethodCall
>
values
=
mDelegates
.
values
(
)
;
final
MethodCall
[
]
valuesArray
=
values
.
toArray
(
new
MethodCall
[
values
.
size
(
)
]
)
;
clear
(
)
;
for
(
final
MethodCall
call
:
valuesArray
)
{
assertMatchesCount
(
call
)
;
}
}
public
MethodCall
prepareMethodCall
(
final
GeckoSession
session
final
Method
method
)
{
MethodCall
call
=
mDelegates
.
get
(
new
Pair
<
>
(
session
method
)
)
;
if
(
call
=
=
null
&
&
session
!
=
null
)
{
call
=
mDelegates
.
get
(
new
Pair
<
>
(
(
GeckoSession
)
null
method
)
)
;
}
if
(
call
=
=
null
)
{
return
null
;
}
assertAllowMoreCalls
(
call
)
;
call
.
incrementCounter
(
)
;
assertOrder
(
call
mOrder
)
;
mOrder
=
Math
.
max
(
call
.
getOrder
(
)
mOrder
)
;
return
call
;
}
}
static
AssertCalled
getAssertCalled
(
final
Method
method
final
Object
callback
)
{
final
AssertCalled
annotation
=
method
.
getAnnotation
(
AssertCalled
.
class
)
;
if
(
annotation
!
=
null
)
{
return
annotation
;
}
try
{
return
callback
.
getClass
(
)
.
getDeclaredMethod
(
"
invoke
"
method
.
getParameterTypes
(
)
)
.
getAnnotation
(
AssertCalled
.
class
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
return
null
;
}
}
private
static
void
addCallbackClasses
(
final
List
<
Class
<
?
>
>
list
final
Class
<
?
>
ifce
)
{
if
(
!
Callbacks
.
class
.
equals
(
ifce
.
getDeclaringClass
(
)
)
)
{
list
.
add
(
ifce
)
;
return
;
}
final
Class
<
?
>
[
]
superIfces
=
ifce
.
getInterfaces
(
)
;
for
(
final
Class
<
?
>
superIfce
:
superIfces
)
{
addCallbackClasses
(
list
superIfce
)
;
}
}
private
static
Set
<
Class
<
?
>
>
getDefaultDelegates
(
)
{
final
Class
<
?
>
[
]
ifces
=
Callbacks
.
class
.
getDeclaredClasses
(
)
;
final
List
<
Class
<
?
>
>
list
=
new
ArrayList
<
>
(
ifces
.
length
)
;
for
(
final
Class
<
?
>
ifce
:
ifces
)
{
addCallbackClasses
(
list
ifce
)
;
}
return
new
HashSet
<
>
(
list
)
;
}
private
static
final
Set
<
Class
<
?
>
>
DEFAULT_DELEGATES
=
getDefaultDelegates
(
)
;
private
static
final
class
TimeoutRunnable
implements
Runnable
{
private
long
timeout
;
public
void
set
(
final
long
timeout
)
{
this
.
timeout
=
timeout
;
cancel
(
)
;
HANDLER
.
postDelayed
(
this
timeout
)
;
}
public
void
cancel
(
)
{
HANDLER
.
removeCallbacks
(
this
)
;
}
Override
public
void
run
(
)
{
throw
new
TimeoutException
(
"
Timed
out
after
"
+
timeout
+
"
ms
"
)
;
}
}
static
final
Handler
HANDLER
=
new
Handler
(
Looper
.
getMainLooper
(
)
)
;
private
static
final
TimeoutRunnable
TIMEOUT_RUNNABLE
=
new
TimeoutRunnable
(
)
;
private
static
final
MessageQueue
.
IdleHandler
IDLE_HANDLER
=
new
MessageQueue
.
IdleHandler
(
)
{
Override
public
boolean
queueIdle
(
)
{
final
Message
msg
=
Message
.
obtain
(
HANDLER
)
;
msg
.
obj
=
HANDLER
;
HANDLER
.
sendMessageAtFrontOfQueue
(
msg
)
;
return
false
;
}
}
;
private
static
GeckoRuntime
sRuntime
;
private
static
RDPConnection
sRDPConnection
;
private
static
long
sLongestWait
;
protected
static
GeckoSession
sCachedSession
;
protected
static
Tab
sCachedRDPTab
;
public
final
Environment
env
=
new
Environment
(
)
;
protected
final
Instrumentation
mInstrumentation
=
InstrumentationRegistry
.
getInstrumentation
(
)
;
protected
final
GeckoSessionSettings
mDefaultSettings
;
protected
final
Set
<
GeckoSession
>
mSubSessions
=
new
HashSet
<
>
(
)
;
protected
ErrorCollector
mErrorCollector
;
protected
GeckoSession
mMainSession
;
protected
Object
mCallbackProxy
;
protected
Set
<
Class
<
?
>
>
mNullDelegates
;
protected
Set
<
Class
<
?
>
>
mAllDelegates
;
protected
List
<
CallRecord
>
mCallRecords
;
protected
CallRecordHandler
mCallRecordHandler
;
protected
CallbackDelegates
mWaitScopeDelegates
;
protected
CallbackDelegates
mTestScopeDelegates
;
protected
int
mLastWaitStart
;
protected
int
mLastWaitEnd
;
protected
MethodCall
mCurrentMethodCall
;
protected
long
mTimeoutMillis
;
protected
Point
mDisplaySize
;
protected
SurfaceTexture
mDisplayTexture
;
protected
Surface
mDisplaySurface
;
protected
GeckoDisplay
mDisplay
;
protected
boolean
mClosedSession
;
protected
boolean
mWithDevTools
;
protected
Map
<
GeckoSession
Tab
>
mRDPTabs
;
protected
Tab
mRDPChromeProcess
;
protected
boolean
mReuseSession
;
protected
boolean
mIgnoreCrash
;
public
GeckoSessionTestRule
(
)
{
mDefaultSettings
=
new
GeckoSessionSettings
(
)
;
mDefaultSettings
.
setBoolean
(
GeckoSessionSettings
.
USE_MULTIPROCESS
env
.
isMultiprocess
(
)
)
;
}
public
void
setErrorCollector
(
final
Nullable
ErrorCollector
ec
)
{
mErrorCollector
=
ec
;
}
public
Nullable
ErrorCollector
getErrorCollector
(
)
{
return
mErrorCollector
;
}
public
<
T
>
void
checkThat
(
final
String
reason
final
T
value
final
Matcher
<
?
super
T
>
matcher
)
{
if
(
mErrorCollector
!
=
null
)
{
mErrorCollector
.
checkThat
(
reason
value
matcher
)
;
}
else
{
assertThat
(
reason
value
matcher
)
;
}
}
private
void
assertAllowMoreCalls
(
final
MethodCall
call
)
{
final
int
count
=
call
.
getCount
(
)
;
if
(
count
!
=
-
1
)
{
checkThat
(
call
.
method
.
getName
(
)
+
"
call
count
should
be
within
limit
"
call
.
getCurrentCount
(
)
+
1
lessThanOrEqualTo
(
count
)
)
;
}
}
private
void
assertOrder
(
final
MethodCall
call
final
int
order
)
{
final
int
newOrder
=
call
.
getOrder
(
)
;
if
(
newOrder
!
=
0
)
{
checkThat
(
call
.
method
.
getName
(
)
+
"
should
be
in
order
"
newOrder
greaterThanOrEqualTo
(
order
)
)
;
}
}
private
void
assertMatchesCount
(
final
MethodCall
call
)
{
if
(
call
.
requirement
=
=
null
)
{
return
;
}
final
int
count
=
call
.
getCount
(
)
;
if
(
count
=
=
0
)
{
checkThat
(
call
.
method
.
getName
(
)
+
"
should
not
be
called
"
call
.
getCurrentCount
(
)
equalTo
(
0
)
)
;
}
else
if
(
count
=
=
-
1
)
{
checkThat
(
call
.
method
.
getName
(
)
+
"
should
be
called
"
call
.
getCurrentCount
(
)
greaterThan
(
0
)
)
;
}
else
{
checkThat
(
call
.
method
.
getName
(
)
+
"
should
be
called
specified
number
of
times
"
call
.
getCurrentCount
(
)
equalTo
(
count
)
)
;
}
}
public
NonNull
GeckoSession
getSession
(
)
{
return
mMainSession
;
}
public
NonNull
GeckoRuntime
getRuntime
(
)
{
return
sRuntime
;
}
protected
static
Object
setDelegate
(
final
NonNull
Class
<
?
>
cls
final
NonNull
GeckoSession
session
final
Nullable
Object
delegate
)
throws
NoSuchMethodException
IllegalAccessException
InvocationTargetException
{
if
(
cls
=
=
GeckoSession
.
TextInputDelegate
.
class
)
{
return
SessionTextInput
.
class
.
getMethod
(
"
setDelegate
"
cls
)
.
invoke
(
session
.
getTextInput
(
)
delegate
)
;
}
return
GeckoSession
.
class
.
getMethod
(
"
set
"
+
cls
.
getSimpleName
(
)
cls
)
.
invoke
(
session
delegate
)
;
}
protected
static
Object
getDelegate
(
final
NonNull
Class
<
?
>
cls
final
NonNull
GeckoSession
session
)
throws
NoSuchMethodException
IllegalAccessException
InvocationTargetException
{
if
(
cls
=
=
GeckoSession
.
TextInputDelegate
.
class
)
{
return
SessionTextInput
.
class
.
getMethod
(
"
getDelegate
"
)
.
invoke
(
session
.
getTextInput
(
)
)
;
}
return
GeckoSession
.
class
.
getMethod
(
"
get
"
+
cls
.
getSimpleName
(
)
)
.
invoke
(
session
)
;
}
NonNull
private
Set
<
Class
<
?
>
>
getCurrentDelegates
(
)
{
final
List
<
ExternalDelegate
<
?
>
>
waitDelegates
=
mWaitScopeDelegates
.
getExternalDelegates
(
)
;
final
List
<
ExternalDelegate
<
?
>
>
testDelegates
=
mTestScopeDelegates
.
getExternalDelegates
(
)
;
if
(
waitDelegates
.
isEmpty
(
)
&
&
testDelegates
.
isEmpty
(
)
)
{
return
DEFAULT_DELEGATES
;
}
final
Set
<
Class
<
?
>
>
set
=
new
HashSet
<
>
(
DEFAULT_DELEGATES
)
;
for
(
final
ExternalDelegate
<
?
>
delegate
:
waitDelegates
)
{
set
.
add
(
delegate
.
delegate
)
;
}
for
(
final
ExternalDelegate
<
?
>
delegate
:
testDelegates
)
{
set
.
add
(
delegate
.
delegate
)
;
}
return
set
;
}
private
void
addNullDelegate
(
final
Class
<
?
>
delegate
)
{
if
(
!
Callbacks
.
class
.
equals
(
delegate
.
getDeclaringClass
(
)
)
)
{
assertThat
(
"
Null
-
delegate
must
be
valid
interface
class
"
delegate
isIn
(
DEFAULT_DELEGATES
)
)
;
mNullDelegates
.
add
(
delegate
)
;
return
;
}
for
(
final
Class
<
?
>
ifce
:
delegate
.
getInterfaces
(
)
)
{
addNullDelegate
(
ifce
)
;
}
}
protected
void
applyAnnotations
(
final
Collection
<
Annotation
>
annotations
final
GeckoSessionSettings
settings
)
{
for
(
final
Annotation
annotation
:
annotations
)
{
if
(
TimeoutMillis
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
final
long
value
=
(
(
TimeoutMillis
)
annotation
)
.
value
(
)
;
final
long
timeout
=
value
*
getScaledTimeoutMillis
(
)
/
DEFAULT_TIMEOUT_MILLIS
;
mTimeoutMillis
=
Math
.
max
(
timeout
1000
)
;
}
else
if
(
Setting
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
(
(
Setting
)
annotation
)
.
key
(
)
.
set
(
settings
(
(
Setting
)
annotation
)
.
value
(
)
)
;
}
else
if
(
Setting
.
List
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
for
(
final
Setting
setting
:
(
(
Setting
.
List
)
annotation
)
.
value
(
)
)
{
setting
.
key
(
)
.
set
(
settings
setting
.
value
(
)
)
;
}
}
else
if
(
NullDelegate
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
addNullDelegate
(
(
(
NullDelegate
)
annotation
)
.
value
(
)
)
;
}
else
if
(
NullDelegate
.
List
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
for
(
final
NullDelegate
nullDelegate
:
(
(
NullDelegate
.
List
)
annotation
)
.
value
(
)
)
{
addNullDelegate
(
nullDelegate
.
value
(
)
)
;
}
}
else
if
(
WithDisplay
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
final
WithDisplay
displaySize
=
(
WithDisplay
)
annotation
;
mDisplaySize
=
new
Point
(
displaySize
.
width
(
)
displaySize
.
height
(
)
)
;
}
else
if
(
ClosedSessionAtStart
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
mClosedSession
=
(
(
ClosedSessionAtStart
)
annotation
)
.
value
(
)
;
}
else
if
(
WithDevToolsAPI
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
mWithDevTools
=
(
(
WithDevToolsAPI
)
annotation
)
.
value
(
)
;
}
else
if
(
ReuseSession
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
mReuseSession
=
(
(
ReuseSession
)
annotation
)
.
value
(
)
;
}
else
if
(
IgnoreCrash
.
class
.
equals
(
annotation
.
annotationType
(
)
)
)
{
mIgnoreCrash
=
(
(
IgnoreCrash
)
annotation
)
.
value
(
)
;
}
}
}
private
static
RuntimeException
unwrapRuntimeException
(
final
Throwable
e
)
{
final
Throwable
cause
=
e
.
getCause
(
)
;
if
(
cause
!
=
null
&
&
cause
instanceof
RuntimeException
)
{
return
(
RuntimeException
)
cause
;
}
else
if
(
e
instanceof
RuntimeException
)
{
return
(
RuntimeException
)
e
;
}
return
new
RuntimeException
(
cause
!
=
null
?
cause
:
e
)
;
}
private
long
getScaledTimeoutMillis
(
)
{
if
(
"
x86
"
.
equals
(
env
.
getCPUArch
(
)
)
)
{
return
env
.
isEmulator
(
)
?
DEFAULT_X86_EMULATOR_TIMEOUT_MILLIS
:
DEFAULT_X86_DEVICE_TIMEOUT_MILLIS
;
}
return
env
.
isEmulator
(
)
?
DEFAULT_ARM_EMULATOR_TIMEOUT_MILLIS
:
DEFAULT_ARM_DEVICE_TIMEOUT_MILLIS
;
}
private
long
getDefaultTimeoutMillis
(
)
{
return
env
.
isDebugging
(
)
?
DEFAULT_IDE_DEBUG_TIMEOUT_MILLIS
:
getScaledTimeoutMillis
(
)
;
}
protected
void
prepareStatement
(
final
Description
description
)
throws
Throwable
{
final
GeckoSessionSettings
settings
=
new
GeckoSessionSettings
(
mDefaultSettings
)
;
mTimeoutMillis
=
getDefaultTimeoutMillis
(
)
;
mNullDelegates
=
new
HashSet
<
>
(
)
;
mClosedSession
=
false
;
mWithDevTools
=
false
;
mReuseSession
=
true
;
mIgnoreCrash
=
false
;
applyAnnotations
(
Arrays
.
asList
(
description
.
getTestClass
(
)
.
getAnnotations
(
)
)
settings
)
;
applyAnnotations
(
description
.
getAnnotations
(
)
settings
)
;
final
List
<
CallRecord
>
records
=
new
ArrayList
<
>
(
)
;
final
CallbackDelegates
waitDelegates
=
new
CallbackDelegates
(
)
;
final
CallbackDelegates
testDelegates
=
new
CallbackDelegates
(
)
;
mCallRecords
=
records
;
mWaitScopeDelegates
=
waitDelegates
;
mTestScopeDelegates
=
testDelegates
;
mLastWaitStart
=
0
;
mLastWaitEnd
=
0
;
final
InvocationHandler
recorder
=
new
InvocationHandler
(
)
{
Override
public
Object
invoke
(
final
Object
proxy
final
Method
method
final
Object
[
]
args
)
{
boolean
ignore
=
false
;
MethodCall
call
=
null
;
if
(
Object
.
class
.
equals
(
method
.
getDeclaringClass
(
)
)
)
{
switch
(
method
.
getName
(
)
)
{
case
"
equals
"
:
return
proxy
=
=
args
[
0
]
;
case
"
toString
"
:
return
"
Call
Recorder
"
;
}
ignore
=
true
;
}
else
if
(
mCallRecordHandler
!
=
null
)
{
ignore
=
mCallRecordHandler
.
handleCall
(
method
args
)
;
}
final
boolean
isExternalDelegate
=
!
DEFAULT_DELEGATES
.
contains
(
method
.
getDeclaringClass
(
)
)
;
if
(
!
ignore
)
{
assertThat
(
"
Callbacks
must
be
on
UI
thread
"
Looper
.
myLooper
(
)
equalTo
(
Looper
.
getMainLooper
(
)
)
)
;
final
GeckoSession
session
;
if
(
isExternalDelegate
)
{
session
=
null
;
}
else
{
assertThat
(
"
Callback
first
argument
must
be
session
object
"
args
arrayWithSize
(
greaterThan
(
0
)
)
)
;
assertThat
(
"
Callback
first
argument
must
be
session
object
"
args
[
0
]
instanceOf
(
GeckoSession
.
class
)
)
;
session
=
(
GeckoSession
)
args
[
0
]
;
}
if
(
sOnCrash
.
equals
(
method
)
&
&
!
mIgnoreCrash
&
&
isUsingSession
(
session
)
)
{
if
(
env
.
shouldShutdownOnCrash
(
)
)
{
sRuntime
.
shutdown
(
)
;
}
throw
new
RuntimeException
(
"
Content
process
crashed
"
)
;
}
records
.
add
(
new
CallRecord
(
session
method
args
)
)
;
call
=
waitDelegates
.
prepareMethodCall
(
session
method
)
;
if
(
call
=
=
null
)
{
call
=
testDelegates
.
prepareMethodCall
(
session
method
)
;
}
if
(
isExternalDelegate
)
{
assertThat
(
"
External
delegate
should
be
registered
"
call
notNullValue
(
)
)
;
}
}
if
(
call
!
=
null
&
&
sOnNewSession
.
equals
(
method
)
)
{
final
GeckoSession
oldSession
=
(
GeckoSession
)
args
[
0
]
;
SuppressWarnings
(
"
unchecked
"
)
final
GeckoResponse
<
GeckoSession
>
realResponse
=
(
GeckoResponse
<
GeckoSession
>
)
args
[
2
]
;
args
[
2
]
=
new
GeckoResponse
<
GeckoSession
>
(
)
{
Override
public
void
respond
(
final
GeckoSession
newSession
)
{
realResponse
.
respond
(
newSession
)
;
if
(
oldSession
.
isOpen
(
)
&
&
newSession
!
=
null
)
{
GeckoSessionTestRule
.
this
.
waitForOpenSession
(
newSession
)
;
}
}
}
;
}
try
{
mCurrentMethodCall
=
call
;
return
method
.
invoke
(
(
call
!
=
null
)
?
call
.
target
:
Callbacks
.
Default
.
INSTANCE
args
)
;
}
catch
(
final
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
finally
{
mCurrentMethodCall
=
null
;
}
}
}
;
final
Class
<
?
>
[
]
classes
=
DEFAULT_DELEGATES
.
toArray
(
new
Class
<
?
>
[
DEFAULT_DELEGATES
.
size
(
)
]
)
;
mCallbackProxy
=
Proxy
.
newProxyInstance
(
GeckoSession
.
class
.
getClassLoader
(
)
classes
recorder
)
;
mAllDelegates
=
new
HashSet
<
>
(
DEFAULT_DELEGATES
)
;
if
(
sRuntime
=
=
null
)
{
final
GeckoRuntimeSettings
.
Builder
runtimeSettingsBuilder
=
new
GeckoRuntimeSettings
.
Builder
(
)
;
runtimeSettingsBuilder
.
arguments
(
new
String
[
]
{
"
-
purgecaches
"
}
)
.
extras
(
InstrumentationRegistry
.
getArguments
(
)
)
.
remoteDebuggingEnabled
(
true
)
;
if
(
env
.
isAutomation
(
)
)
{
runtimeSettingsBuilder
.
nativeCrashReportingEnabled
(
true
)
.
javaCrashReportingEnabled
(
true
)
;
}
sRuntime
=
GeckoRuntime
.
create
(
InstrumentationRegistry
.
getTargetContext
(
)
runtimeSettingsBuilder
.
build
(
)
)
;
sRuntime
.
setDelegate
(
new
GeckoRuntime
.
Delegate
(
)
{
Override
public
void
onShutdown
(
)
{
Process
.
killProcess
(
Process
.
myPid
(
)
)
;
}
}
)
;
}
if
(
sCachedSession
!
=
null
&
&
!
sCachedSession
.
isOpen
(
)
)
{
sCachedSession
=
null
;
}
final
boolean
useDefaultSession
=
!
mClosedSession
&
&
mDefaultSettings
.
equals
(
settings
)
;
if
(
useDefaultSession
&
&
mReuseSession
&
&
sCachedSession
!
=
null
)
{
mMainSession
=
sCachedSession
;
}
else
{
mMainSession
=
new
GeckoSession
(
settings
)
;
}
prepareSession
(
mMainSession
)
;
if
(
mDisplaySize
!
=
null
)
{
mDisplayTexture
=
new
SurfaceTexture
(
0
)
;
mDisplaySurface
=
new
Surface
(
mDisplayTexture
)
;
mDisplay
=
mMainSession
.
acquireDisplay
(
)
;
mDisplay
.
surfaceChanged
(
mDisplaySurface
mDisplaySize
.
x
mDisplaySize
.
y
)
;
}
if
(
useDefaultSession
&
&
mReuseSession
)
{
if
(
sCachedSession
=
=
null
)
{
final
boolean
withDevTools
=
mWithDevTools
;
mWithDevTools
=
true
;
openSession
(
mMainSession
)
;
sCachedSession
=
mMainSession
;
sCachedRDPTab
=
mRDPTabs
.
get
(
mMainSession
)
;
mWithDevTools
=
withDevTools
;
}
else
{
mMainSession
.
loadUri
(
"
about
:
blank
"
)
;
waitForOpenSession
(
mMainSession
)
;
}
}
else
if
(
!
mClosedSession
)
{
openSession
(
mMainSession
)
;
}
}
protected
void
prepareSession
(
final
GeckoSession
session
)
throws
Throwable
{
for
(
final
Class
<
?
>
cls
:
DEFAULT_DELEGATES
)
{
setDelegate
(
cls
session
mNullDelegates
.
contains
(
cls
)
?
null
:
mCallbackProxy
)
;
}
}
public
void
openSession
(
final
GeckoSession
session
)
{
session
.
open
(
sRuntime
)
;
waitForOpenSession
(
session
)
;
}
void
waitForOpenSession
(
final
GeckoSession
session
)
{
waitForInitialLoad
(
session
)
;
if
(
mWithDevTools
)
{
if
(
sRDPConnection
=
=
null
)
{
final
String
dataDir
=
InstrumentationRegistry
.
getTargetContext
(
)
.
getApplicationInfo
(
)
.
dataDir
;
final
LocalSocketAddress
address
=
new
LocalSocketAddress
(
dataDir
+
"
/
firefox
-
debugger
-
socket
"
LocalSocketAddress
.
Namespace
.
FILESYSTEM
)
;
sRDPConnection
=
new
RDPConnection
(
address
)
;
sRDPConnection
.
setTimeout
(
mTimeoutMillis
)
;
}
if
(
mRDPTabs
=
=
null
)
{
mRDPTabs
=
new
HashMap
<
>
(
)
;
}
final
Tab
tab
=
session
.
equals
(
sCachedSession
)
?
sCachedRDPTab
:
sRDPConnection
.
getMostRecentTab
(
)
;
mRDPTabs
.
put
(
session
tab
)
;
}
}
private
void
waitForInitialLoad
(
final
GeckoSession
session
)
{
try
{
assertThat
(
"
ProgressDelegate
cannot
be
null
-
delegate
when
opening
session
"
GeckoSession
.
ProgressDelegate
.
class
not
(
isIn
(
mNullDelegates
)
)
)
;
mCallRecordHandler
=
new
CallRecordHandler
(
)
{
Override
public
boolean
handleCall
(
final
Method
method
final
Object
[
]
args
)
{
final
boolean
matching
=
DEFAULT_DELEGATES
.
contains
(
method
.
getDeclaringClass
(
)
)
&
&
session
.
equals
(
args
[
0
]
)
;
if
(
matching
&
&
sOnPageStop
.
equals
(
method
)
)
{
mCallRecordHandler
=
null
;
}
return
matching
;
}
}
;
do
{
loopUntilIdle
(
getDefaultTimeoutMillis
(
)
)
;
}
while
(
mCallRecordHandler
!
=
null
)
;
}
finally
{
mCallRecordHandler
=
null
;
}
}
public
void
performTestEndCheck
(
)
{
mWaitScopeDelegates
.
clearAndAssert
(
)
;
mTestScopeDelegates
.
clearAndAssert
(
)
;
}
protected
void
cleanupSession
(
final
GeckoSession
session
)
{
final
Tab
tab
=
(
mRDPTabs
!
=
null
)
?
mRDPTabs
.
get
(
session
)
:
null
;
if
(
tab
!
=
null
)
{
if
(
session
.
isOpen
(
)
)
{
tab
.
getPromises
(
)
.
detach
(
)
;
tab
.
detach
(
)
;
}
mRDPTabs
.
remove
(
session
)
;
}
if
(
session
.
isOpen
(
)
)
{
session
.
close
(
)
;
}
}
protected
boolean
isUsingSession
(
final
GeckoSession
session
)
{
return
session
.
equals
(
mMainSession
)
|
|
mSubSessions
.
contains
(
session
)
;
}
protected
void
deleteCrashDumps
(
)
{
File
dumpDir
=
new
File
(
sRuntime
.
getProfileDir
(
)
"
minidumps
"
)
;
for
(
final
File
dump
:
dumpDir
.
listFiles
(
)
)
{
dump
.
delete
(
)
;
}
}
protected
void
cleanupStatement
(
)
throws
Throwable
{
mWaitScopeDelegates
.
clear
(
)
;
mTestScopeDelegates
.
clear
(
)
;
for
(
final
GeckoSession
session
:
mSubSessions
)
{
cleanupSession
(
session
)
;
}
if
(
sCachedSession
!
=
null
&
&
mReuseSession
&
&
!
mIgnoreCrash
)
{
assertThat
(
"
Cached
session
should
be
open
"
sCachedSession
.
isOpen
(
)
equalTo
(
true
)
)
;
}
if
(
mMainSession
.
isOpen
(
)
&
&
mMainSession
.
equals
(
sCachedSession
)
)
{
sCachedRDPTab
.
getPromises
(
)
.
detach
(
)
;
}
else
{
cleanupSession
(
mMainSession
)
;
}
if
(
mIgnoreCrash
)
{
deleteCrashDumps
(
)
;
}
if
(
mDisplay
!
=
null
)
{
mDisplay
.
surfaceDestroyed
(
)
;
mMainSession
.
releaseDisplay
(
mDisplay
)
;
mDisplay
=
null
;
mDisplaySurface
.
release
(
)
;
mDisplaySurface
=
null
;
mDisplayTexture
.
release
(
)
;
mDisplayTexture
=
null
;
}
mMainSession
=
null
;
mCallbackProxy
=
null
;
mAllDelegates
=
null
;
mNullDelegates
=
null
;
mCallRecords
=
null
;
mWaitScopeDelegates
=
null
;
mTestScopeDelegates
=
null
;
mLastWaitStart
=
0
;
mLastWaitEnd
=
0
;
mTimeoutMillis
=
0
;
mRDPTabs
=
null
;
mRDPChromeProcess
=
null
;
}
Override
public
Statement
apply
(
final
Statement
base
final
Description
description
)
{
return
super
.
apply
(
new
Statement
(
)
{
Override
public
void
evaluate
(
)
throws
Throwable
{
try
{
prepareStatement
(
description
)
;
base
.
evaluate
(
)
;
performTestEndCheck
(
)
;
}
finally
{
cleanupStatement
(
)
;
}
}
}
description
)
;
}
Override
protected
boolean
shouldRunOnUiThread
(
final
Description
description
)
{
return
true
;
}
protected
static
void
loopUntilIdle
(
final
long
timeout
)
{
final
MessageQueue
queue
=
HANDLER
.
getLooper
(
)
.
getQueue
(
)
;
if
(
timeout
>
0
)
{
TIMEOUT_RUNNABLE
.
set
(
timeout
)
;
}
else
{
queue
.
addIdleHandler
(
IDLE_HANDLER
)
;
}
final
long
startTime
=
SystemClock
.
uptimeMillis
(
)
;
try
{
while
(
true
)
{
final
Message
msg
;
try
{
msg
=
(
Message
)
sGetNextMessage
.
invoke
(
queue
)
;
}
catch
(
final
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
if
(
msg
.
getTarget
(
)
=
=
HANDLER
&
&
msg
.
obj
=
=
HANDLER
)
{
break
;
}
else
if
(
msg
.
getTarget
(
)
=
=
null
)
{
HANDLER
.
getLooper
(
)
.
quit
(
)
;
return
;
}
msg
.
getTarget
(
)
.
dispatchMessage
(
msg
)
;
if
(
timeout
>
0
)
{
TIMEOUT_RUNNABLE
.
cancel
(
)
;
queue
.
addIdleHandler
(
IDLE_HANDLER
)
;
}
}
final
long
waitDuration
=
SystemClock
.
uptimeMillis
(
)
-
startTime
;
if
(
waitDuration
>
sLongestWait
)
{
sLongestWait
=
waitDuration
;
Log
.
i
(
LOGTAG
"
New
longest
wait
:
"
+
waitDuration
+
"
ms
"
)
;
}
}
finally
{
if
(
timeout
>
0
)
{
TIMEOUT_RUNNABLE
.
cancel
(
)
;
}
}
}
public
void
waitForPageStop
(
)
{
waitForPageStop
(
null
)
;
}
public
void
waitForPageStop
(
final
GeckoSession
session
)
{
waitForPageStops
(
session
1
)
;
}
public
void
waitForPageStops
(
final
int
count
)
{
waitForPageStops
(
null
count
)
;
}
public
void
waitForPageStops
(
final
GeckoSession
session
final
int
count
)
{
final
List
<
MethodCall
>
methodCalls
=
new
ArrayList
<
>
(
1
)
;
methodCalls
.
add
(
new
MethodCall
(
session
sOnPageStop
new
CallRequirement
(
true
count
null
)
)
)
;
waitUntilCalled
(
session
GeckoSession
.
ProgressDelegate
.
class
methodCalls
)
;
}
public
void
waitUntilCalled
(
final
NonNull
KClass
<
?
>
callback
final
Nullable
String
.
.
.
methods
)
{
waitUntilCalled
(
null
callback
methods
)
;
}
public
void
waitUntilCalled
(
final
Nullable
GeckoSession
session
final
NonNull
KClass
<
?
>
callback
final
Nullable
String
.
.
.
methods
)
{
waitUntilCalled
(
session
JvmClassMappingKt
.
getJavaClass
(
callback
)
methods
)
;
}
public
void
waitUntilCalled
(
final
NonNull
Class
<
?
>
callback
final
Nullable
String
.
.
.
methods
)
{
waitUntilCalled
(
null
callback
methods
)
;
}
public
void
waitUntilCalled
(
final
Nullable
GeckoSession
session
final
NonNull
Class
<
?
>
callback
final
Nullable
String
.
.
.
methods
)
{
final
int
length
=
(
methods
!
=
null
)
?
methods
.
length
:
0
;
final
Pattern
[
]
patterns
=
new
Pattern
[
length
]
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
patterns
[
i
]
=
Pattern
.
compile
(
methods
[
i
]
)
;
}
final
List
<
MethodCall
>
waitMethods
=
new
ArrayList
<
>
(
)
;
boolean
isSessionCallback
=
false
;
for
(
final
Class
<
?
>
ifce
:
getCurrentDelegates
(
)
)
{
if
(
!
ifce
.
isAssignableFrom
(
callback
)
)
{
continue
;
}
for
(
final
Method
method
:
ifce
.
getMethods
(
)
)
{
for
(
final
Pattern
pattern
:
patterns
)
{
if
(
!
pattern
.
matcher
(
method
.
getName
(
)
)
.
matches
(
)
)
{
continue
;
}
waitMethods
.
add
(
new
MethodCall
(
session
method
null
)
)
;
break
;
}
}
isSessionCallback
=
true
;
}
assertThat
(
"
Delegate
should
be
a
GeckoSession
delegate
"
+
"
or
registered
external
delegate
"
isSessionCallback
equalTo
(
true
)
)
;
waitUntilCalled
(
session
callback
waitMethods
)
;
}
public
void
waitUntilCalled
(
final
NonNull
Object
callback
)
{
waitUntilCalled
(
null
callback
)
;
}
public
void
waitUntilCalled
(
final
Nullable
GeckoSession
session
final
NonNull
Object
callback
)
{
if
(
callback
instanceof
Class
<
?
>
)
{
waitUntilCalled
(
session
(
Class
<
?
>
)
callback
(
String
[
]
)
null
)
;
return
;
}
final
List
<
MethodCall
>
methodCalls
=
new
ArrayList
<
>
(
)
;
boolean
isSessionCallback
=
false
;
for
(
final
Class
<
?
>
ifce
:
getCurrentDelegates
(
)
)
{
if
(
!
ifce
.
isInstance
(
callback
)
)
{
continue
;
}
for
(
final
Method
method
:
ifce
.
getMethods
(
)
)
{
final
Method
callbackMethod
;
try
{
callbackMethod
=
callback
.
getClass
(
)
.
getMethod
(
method
.
getName
(
)
method
.
getParameterTypes
(
)
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
AssertCalled
ac
=
getAssertCalled
(
callbackMethod
callback
)
;
if
(
ac
!
=
null
&
&
ac
.
value
(
)
)
{
methodCalls
.
add
(
new
MethodCall
(
session
method
ac
null
)
)
;
}
}
isSessionCallback
=
true
;
}
assertThat
(
"
Delegate
should
implement
a
GeckoSession
delegate
"
+
"
or
registered
external
delegate
"
isSessionCallback
equalTo
(
true
)
)
;
waitUntilCalled
(
session
callback
.
getClass
(
)
methodCalls
)
;
forCallbacksDuringWait
(
session
callback
)
;
}
protected
void
waitUntilCalled
(
final
Nullable
GeckoSession
session
final
NonNull
Class
<
?
>
delegate
final
NonNull
List
<
MethodCall
>
methodCalls
)
{
if
(
session
!
=
null
&
&
!
session
.
equals
(
mMainSession
)
)
{
assertThat
(
"
Session
should
be
wrapped
through
wrapSession
"
session
isIn
(
mSubSessions
)
)
;
}
for
(
final
Class
<
?
>
ifce
:
DEFAULT_DELEGATES
)
{
final
Object
callback
;
try
{
callback
=
getDelegate
(
ifce
session
=
=
null
?
mMainSession
:
session
)
;
}
catch
(
final
NoSuchMethodException
|
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
if
(
mNullDelegates
.
contains
(
ifce
)
)
{
continue
;
}
assertThat
(
ifce
.
getSimpleName
(
)
+
"
callbacks
should
be
"
+
"
accessed
through
GeckoSessionTestRule
delegate
methods
"
callback
sameInstance
(
mCallbackProxy
)
)
;
}
if
(
methodCalls
.
isEmpty
(
)
)
{
for
(
final
Class
<
?
>
ifce
:
mNullDelegates
)
{
assertThat
(
"
Cannot
wait
on
null
-
delegate
callbacks
"
delegate
not
(
typeCompatibleWith
(
ifce
)
)
)
;
}
}
else
{
for
(
final
MethodCall
call
:
methodCalls
)
{
assertThat
(
"
Cannot
wait
on
null
-
delegate
callbacks
"
call
.
method
.
getDeclaringClass
(
)
not
(
isIn
(
mNullDelegates
)
)
)
;
}
}
boolean
calledAny
=
false
;
int
index
=
mLastWaitEnd
;
beforeWait
(
)
;
while
(
!
calledAny
|
|
!
methodCalls
.
isEmpty
(
)
)
{
while
(
index
>
=
mCallRecords
.
size
(
)
)
{
loopUntilIdle
(
mTimeoutMillis
)
;
}
final
MethodCall
recorded
=
mCallRecords
.
get
(
index
)
.
methodCall
;
calledAny
|
=
recorded
.
method
.
getDeclaringClass
(
)
.
isAssignableFrom
(
delegate
)
;
index
+
+
;
final
int
i
=
methodCalls
.
indexOf
(
recorded
)
;
if
(
i
<
0
)
{
continue
;
}
final
MethodCall
methodCall
=
methodCalls
.
get
(
i
)
;
methodCall
.
incrementCounter
(
)
;
if
(
methodCall
.
allowUnlimitedCalls
(
)
|
|
!
methodCall
.
allowMoreCalls
(
)
)
{
methodCalls
.
remove
(
i
)
;
}
}
afterWait
(
index
)
;
}
protected
void
beforeWait
(
)
{
mLastWaitStart
=
mLastWaitEnd
;
}
protected
void
afterWait
(
final
int
endCallIndex
)
{
mLastWaitEnd
=
endCallIndex
;
mWaitScopeDelegates
.
clearAndAssert
(
)
;
for
(
final
ExternalDelegate
<
?
>
delegate
:
mTestScopeDelegates
.
getExternalDelegates
(
)
)
{
delegate
.
register
(
)
;
}
}
public
void
forCallbacksDuringWait
(
final
NonNull
Object
callback
)
{
forCallbacksDuringWait
(
null
callback
)
;
}
public
void
forCallbacksDuringWait
(
final
Nullable
GeckoSession
session
final
NonNull
Object
callback
)
{
final
Method
[
]
declaredMethods
=
callback
.
getClass
(
)
.
getDeclaredMethods
(
)
;
final
List
<
MethodCall
>
methodCalls
=
new
ArrayList
<
>
(
declaredMethods
.
length
)
;
boolean
assertingAnyCall
=
true
;
Class
<
?
>
foundNullDelegate
=
null
;
for
(
final
Class
<
?
>
ifce
:
mAllDelegates
)
{
if
(
!
ifce
.
isInstance
(
callback
)
)
{
continue
;
}
if
(
mNullDelegates
.
contains
(
ifce
)
)
{
foundNullDelegate
=
ifce
;
}
for
(
final
Method
method
:
ifce
.
getMethods
(
)
)
{
final
Method
callbackMethod
;
try
{
callbackMethod
=
callback
.
getClass
(
)
.
getMethod
(
method
.
getName
(
)
method
.
getParameterTypes
(
)
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
final
MethodCall
call
=
new
MethodCall
(
session
callbackMethod
getAssertCalled
(
callbackMethod
callback
)
null
)
;
methodCalls
.
add
(
call
)
;
if
(
call
.
requirement
!
=
null
)
{
if
(
foundNullDelegate
=
=
ifce
)
{
fail
(
"
Cannot
assert
on
null
-
delegate
"
+
ifce
.
getSimpleName
(
)
)
;
}
assertingAnyCall
=
false
;
}
}
}
if
(
assertingAnyCall
&
&
foundNullDelegate
!
=
null
)
{
fail
(
"
Cannot
assert
on
null
-
delegate
"
+
foundNullDelegate
.
getSimpleName
(
)
)
;
}
int
order
=
0
;
boolean
calledAny
=
false
;
for
(
int
index
=
mLastWaitStart
;
index
<
mLastWaitEnd
;
index
+
+
)
{
final
CallRecord
record
=
mCallRecords
.
get
(
index
)
;
if
(
!
record
.
method
.
getDeclaringClass
(
)
.
isInstance
(
callback
)
|
|
(
session
!
=
null
&
&
DEFAULT_DELEGATES
.
contains
(
record
.
method
.
getDeclaringClass
(
)
)
&
&
record
.
args
[
0
]
!
=
session
)
)
{
continue
;
}
final
int
i
=
methodCalls
.
indexOf
(
record
.
methodCall
)
;
checkThat
(
record
.
method
.
getName
(
)
+
"
should
be
found
"
i
greaterThanOrEqualTo
(
0
)
)
;
final
MethodCall
methodCall
=
methodCalls
.
get
(
i
)
;
assertAllowMoreCalls
(
methodCall
)
;
methodCall
.
incrementCounter
(
)
;
assertOrder
(
methodCall
order
)
;
order
=
Math
.
max
(
methodCall
.
getOrder
(
)
order
)
;
try
{
mCurrentMethodCall
=
methodCall
;
record
.
method
.
invoke
(
callback
record
.
args
)
;
}
catch
(
final
IllegalAccessException
|
InvocationTargetException
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
finally
{
mCurrentMethodCall
=
null
;
}
calledAny
=
true
;
}
for
(
final
MethodCall
methodCall
:
methodCalls
)
{
assertMatchesCount
(
methodCall
)
;
if
(
methodCall
.
requirement
!
=
null
)
{
calledAny
=
true
;
}
}
checkThat
(
"
Should
have
called
one
of
"
+
Arrays
.
toString
(
callback
.
getClass
(
)
.
getInterfaces
(
)
)
calledAny
equalTo
(
true
)
)
;
}
public
NonNull
CallInfo
getCurrentCall
(
)
{
assertThat
(
"
Should
be
in
a
method
call
"
mCurrentMethodCall
notNullValue
(
)
)
;
return
mCurrentMethodCall
.
getInfo
(
)
;
}
public
void
delegateUntilTestEnd
(
final
NonNull
Object
callback
)
{
delegateUntilTestEnd
(
null
callback
)
;
}
public
void
delegateUntilTestEnd
(
final
Nullable
GeckoSession
session
final
NonNull
Object
callback
)
{
mTestScopeDelegates
.
delegate
(
session
callback
)
;
}
public
void
delegateDuringNextWait
(
final
NonNull
Object
callback
)
{
delegateDuringNextWait
(
null
callback
)
;
}
public
void
delegateDuringNextWait
(
final
Nullable
GeckoSession
session
final
NonNull
Object
callback
)
{
mWaitScopeDelegates
.
delegate
(
session
callback
)
;
}
public
void
synthesizeTap
(
final
NonNull
GeckoSession
session
final
int
x
final
int
y
)
{
final
long
downTime
=
SystemClock
.
uptimeMillis
(
)
;
final
MotionEvent
down
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_DOWN
x
y
0
)
;
session
.
getPanZoomController
(
)
.
onTouchEvent
(
down
)
;
final
MotionEvent
up
=
MotionEvent
.
obtain
(
downTime
SystemClock
.
uptimeMillis
(
)
MotionEvent
.
ACTION_UP
x
y
0
)
;
session
.
getPanZoomController
(
)
.
onTouchEvent
(
up
)
;
}
public
GeckoSession
wrapSession
(
final
GeckoSession
session
)
{
try
{
mSubSessions
.
add
(
session
)
;
prepareSession
(
session
)
;
}
catch
(
final
Throwable
e
)
{
throw
unwrapRuntimeException
(
e
)
;
}
return
session
;
}
private
GeckoSession
createSession
(
final
GeckoSessionSettings
settings
final
boolean
open
)
{
final
GeckoSession
session
=
wrapSession
(
new
GeckoSession
(
settings
)
)
;
if
(
open
)
{
openSession
(
session
)
;
}
return
session
;
}
public
GeckoSession
createOpenSession
(
)
{
return
createSession
(
mMainSession
.
getSettings
(
)
true
)
;
}
public
GeckoSession
createOpenSession
(
final
GeckoSessionSettings
settings
)
{
return
createSession
(
settings
true
)
;
}
public
GeckoSession
createClosedSession
(
)
{
return
createSession
(
mMainSession
.
getSettings
(
)
false
)
;
}
public
GeckoSession
createClosedSession
(
final
GeckoSessionSettings
settings
)
{
return
createSession
(
settings
false
)
;
}
SafeVarargs
public
final
<
T
>
T
forEachCall
(
T
.
.
.
values
)
{
assertThat
(
"
Should
be
in
a
method
call
"
mCurrentMethodCall
notNullValue
(
)
)
;
return
values
[
Math
.
min
(
mCurrentMethodCall
.
getCurrentCount
(
)
values
.
length
)
-
1
]
;
}
public
Object
evaluateJS
(
final
NonNull
GeckoSession
session
final
NonNull
String
js
)
{
assertThat
(
"
Must
enable
RDP
using
WithDevToolsAPI
"
mWithDevTools
equalTo
(
true
)
)
;
final
Tab
tab
=
mRDPTabs
.
get
(
session
)
;
assertThat
(
"
Session
should
have
tab
object
"
tab
notNullValue
(
)
)
;
return
evaluateJS
(
tab
js
)
;
}
public
Object
evaluateChromeJS
(
final
NonNull
String
js
)
{
assertThat
(
"
Must
enable
RDP
using
WithDevToolsAPI
"
mWithDevTools
equalTo
(
true
)
)
;
ensureChromeProcess
(
)
;
return
evaluateJS
(
mRDPChromeProcess
js
)
;
}
private
void
ensureChromeProcess
(
)
{
if
(
mRDPChromeProcess
=
=
null
)
{
mRDPChromeProcess
=
sRDPConnection
.
getChromeProcess
(
)
;
assertThat
(
"
Should
have
chrome
process
object
"
mRDPChromeProcess
notNullValue
(
)
)
;
}
}
private
Object
evaluateJS
(
final
NonNull
Tab
tab
final
NonNull
String
js
)
{
final
Actor
.
Reply
<
Object
>
reply
=
tab
.
getConsole
(
)
.
evaluateJS
(
js
)
;
while
(
!
reply
.
hasResult
(
)
)
{
loopUntilIdle
(
mTimeoutMillis
)
;
}
final
Object
result
=
reply
.
get
(
)
;
if
(
result
instanceof
Promise
)
{
final
String
tag
=
String
.
valueOf
(
result
.
hashCode
(
)
)
;
tab
.
getConsole
(
)
.
evaluateJS
(
"
_
.
tag
=
"
+
JSONObject
.
quote
(
tag
)
+
"
_
"
)
;
final
Promise
[
]
promises
=
tab
.
getPromises
(
)
.
listPromises
(
)
;
for
(
final
Promise
promise
:
promises
)
{
if
(
tag
.
equals
(
promise
.
getProperty
(
"
tag
"
)
)
)
{
return
new
PromiseWrapper
(
promise
mTimeoutMillis
)
;
}
}
throw
new
AssertionError
(
"
Cannot
find
Promise
"
)
;
}
return
result
;
}
public
Nullable
Object
waitForJS
(
final
NonNull
GeckoSession
session
final
NonNull
String
js
)
{
try
{
beforeWait
(
)
;
return
resolvePromise
(
evaluateJS
(
session
js
)
)
;
}
finally
{
afterWait
(
mCallRecords
.
size
(
)
)
;
}
}
public
Nullable
Object
waitForChromeJS
(
final
NonNull
String
js
)
{
try
{
beforeWait
(
)
;
return
resolvePromise
(
evaluateChromeJS
(
js
)
)
;
}
finally
{
afterWait
(
mCallRecords
.
size
(
)
)
;
}
}
private
Nullable
Object
resolvePromise
(
final
Nullable
Object
result
)
{
if
(
result
instanceof
PromiseWrapper
)
{
return
(
(
PromiseWrapper
)
result
)
.
getValue
(
)
;
}
return
result
;
}
public
List
<
?
>
getPrefs
(
final
NonNull
String
.
.
.
prefs
)
{
assertThat
(
"
Must
enable
RDP
using
WithDevToolsAPI
"
mWithDevTools
equalTo
(
true
)
)
;
final
StringBuilder
prefsList
=
new
StringBuilder
(
)
;
for
(
final
String
pref
:
prefs
)
{
prefsList
.
append
(
JSONObject
.
quote
(
pref
)
)
.
append
(
'
'
)
;
}
return
(
List
<
?
>
)
evaluateChromeJS
(
String
.
format
(
"
(
function
(
)
{
"
+
"
return
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
'
{
}
)
"
+
"
.
Preferences
.
get
(
[
%
1
s
]
)
;
"
+
"
}
)
(
)
"
prefsList
.
toString
(
)
)
)
;
}
public
void
setPrefsUntilTestEnd
(
final
NonNull
Map
<
String
?
>
prefs
)
{
assertThat
(
"
Must
enable
RDP
using
WithDevToolsAPI
"
mWithDevTools
equalTo
(
true
)
)
;
mTestScopeDelegates
.
setPrefs
(
prefs
)
;
}
public
void
setPrefsDuringNextWait
(
final
NonNull
Map
<
String
?
>
prefs
)
{
assertThat
(
"
Must
enable
RDP
using
WithDevToolsAPI
"
mWithDevTools
equalTo
(
true
)
)
;
mWaitScopeDelegates
.
setPrefs
(
prefs
)
;
}
public
void
forceGarbageCollection
(
)
{
assertThat
(
"
Must
enable
RDP
using
WithDevToolsAPI
"
mWithDevTools
equalTo
(
true
)
)
;
ensureChromeProcess
(
)
;
mRDPChromeProcess
.
getMemory
(
)
.
forceCycleCollection
(
)
;
mRDPChromeProcess
.
getMemory
(
)
.
forceGarbageCollection
(
)
;
}
public
<
T
>
void
addExternalDelegateUntilTestEnd
(
NonNull
final
Class
<
T
>
delegate
NonNull
final
DelegateRegistrar
<
T
>
register
NonNull
final
DelegateRegistrar
<
T
>
unregister
NonNull
final
T
impl
)
{
final
ExternalDelegate
<
T
>
externalDelegate
=
mTestScopeDelegates
.
addExternalDelegate
(
delegate
register
unregister
impl
)
;
if
(
!
mWaitScopeDelegates
.
getExternalDelegates
(
)
.
contains
(
externalDelegate
)
)
{
externalDelegate
.
register
(
)
;
}
}
public
<
T
>
void
addExternalDelegateUntilTestEnd
(
NonNull
final
KClass
<
T
>
delegate
NonNull
final
DelegateRegistrar
<
T
>
register
NonNull
final
DelegateRegistrar
<
T
>
unregister
NonNull
final
T
impl
)
{
addExternalDelegateUntilTestEnd
(
JvmClassMappingKt
.
getJavaClass
(
delegate
)
register
unregister
impl
)
;
}
public
<
T
>
void
addExternalDelegateDuringNextWait
(
NonNull
final
Class
<
T
>
delegate
NonNull
final
DelegateRegistrar
<
T
>
register
NonNull
final
DelegateRegistrar
<
T
>
unregister
NonNull
final
T
impl
)
{
final
ExternalDelegate
<
T
>
externalDelegate
=
mWaitScopeDelegates
.
addExternalDelegate
(
delegate
register
unregister
impl
)
;
final
int
index
=
mTestScopeDelegates
.
getExternalDelegates
(
)
.
indexOf
(
externalDelegate
)
;
if
(
index
>
=
0
)
{
mTestScopeDelegates
.
getExternalDelegates
(
)
.
get
(
index
)
.
unregister
(
)
;
}
externalDelegate
.
register
(
)
;
}
public
<
T
>
void
addExternalDelegateDuringNextWait
(
NonNull
final
KClass
<
T
>
delegate
NonNull
final
DelegateRegistrar
<
T
>
register
NonNull
final
DelegateRegistrar
<
T
>
unregister
NonNull
final
T
impl
)
{
addExternalDelegateDuringNextWait
(
JvmClassMappingKt
.
getJavaClass
(
delegate
)
register
unregister
impl
)
;
}
}
