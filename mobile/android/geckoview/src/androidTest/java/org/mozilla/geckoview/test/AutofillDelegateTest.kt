package
org
.
mozilla
.
geckoview
.
test
import
android
.
graphics
.
Matrix
import
android
.
os
.
Bundle
import
android
.
os
.
LocaleList
import
androidx
.
test
.
filters
.
MediumTest
import
android
.
util
.
Pair
import
android
.
util
.
SparseArray
import
android
.
view
.
View
import
android
.
view
.
ViewStructure
import
android
.
view
.
autofill
.
AutofillId
import
android
.
view
.
autofill
.
AutofillValue
import
org
.
hamcrest
.
Matchers
.
*
import
org
.
junit
.
Test
import
org
.
junit
.
runner
.
RunWith
import
org
.
junit
.
runners
.
Parameterized
import
org
.
mozilla
.
geckoview
.
Autofill
import
org
.
mozilla
.
geckoview
.
GeckoSession
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
*
RunWith
(
Parameterized
:
:
class
)
MediumTest
class
AutofillDelegateTest
:
BaseSessionTest
(
)
{
companion
object
{
get
:
Parameterized
.
Parameters
(
name
=
"
{
0
}
"
)
JvmStatic
val
parameters
:
List
<
Array
<
out
Any
>
>
=
listOf
(
arrayOf
(
"
#
inProcess
"
)
arrayOf
(
"
#
oop
"
)
)
}
field
:
Parameterized
.
Parameter
(
0
)
JvmField
var
iframe
:
String
=
"
"
private
val
pageUrl
by
lazy
{
when
(
iframe
)
{
"
#
inProcess
"
-
>
"
http
:
/
/
example
.
org
/
tests
/
junit
/
forms_xorigin
.
html
"
"
#
oop
"
-
>
createTestUrl
(
FORMS_XORIGIN_HTML_PATH
)
else
-
>
throw
IllegalStateException
(
)
}
}
Test
fun
autofillCommit
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
signon
.
rememberSignons
"
to
true
"
signon
.
userInputRequiredToCapture
.
enabled
"
to
false
)
)
mainSession
.
loadUri
(
pageUrl
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
4
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
starting
auto
-
fill
"
notification
equalTo
(
forEachCall
(
Autofill
.
Notify
.
SESSION_STARTED
Autofill
.
Notify
.
NODE_ADDED
)
)
)
}
}
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
user1
'
)
.
value
=
'
user1x
'
"
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
pass1
'
)
.
value
=
'
pass1x
'
"
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
email1
'
)
.
value
=
'
e
mail
.
com
'
"
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
number1
'
)
.
value
=
'
1
'
"
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
form1
'
)
.
submit
(
)
"
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
5
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
val
info
=
sessionRule
.
currentCall
if
(
info
.
counter
<
5
)
{
assertThat
(
"
Should
be
an
update
notification
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_UPDATED
)
)
}
else
{
assertThat
(
"
Should
be
a
commit
notification
"
notification
equalTo
(
Autofill
.
Notify
.
SESSION_COMMITTED
)
)
assertThat
(
"
Values
should
match
"
countAutofillNodes
(
{
it
.
value
=
=
"
user1x
"
}
)
equalTo
(
1
)
)
assertThat
(
"
Values
should
match
"
countAutofillNodes
(
{
it
.
value
=
=
"
pass1x
"
}
)
equalTo
(
1
)
)
assertThat
(
"
Values
should
match
"
countAutofillNodes
(
{
it
.
value
=
=
"
e
mail
.
com
"
}
)
equalTo
(
1
)
)
assertThat
(
"
Values
should
match
"
countAutofillNodes
(
{
it
.
value
=
=
"
1
"
}
)
equalTo
(
1
)
)
}
}
}
)
}
Test
fun
autofillCommitIdValue
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
signon
.
rememberSignons
"
to
true
"
signon
.
userInputRequiredToCapture
.
enabled
"
to
false
)
)
mainSession
.
loadTestPath
(
FORMS_ID_VALUE_HTML_PATH
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
starting
auto
-
fill
"
notification
equalTo
(
forEachCall
(
Autofill
.
Notify
.
SESSION_STARTED
Autofill
.
Notify
.
NODE_ADDED
)
)
)
}
}
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
value
'
)
.
value
=
'
pass1x
'
"
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
form1
'
)
.
submit
(
)
"
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
2
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
val
info
=
sessionRule
.
currentCall
if
(
info
.
counter
<
2
)
{
assertThat
(
"
Should
be
an
update
notification
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_UPDATED
)
)
}
else
{
assertThat
(
"
Should
be
a
commit
notification
"
notification
equalTo
(
Autofill
.
Notify
.
SESSION_COMMITTED
)
)
assertThat
(
"
Values
should
match
"
countAutofillNodes
(
{
it
.
value
=
=
"
pass1x
"
}
)
equalTo
(
1
)
)
}
}
}
)
}
Test
fun
autofill
(
)
{
mainSession
.
loadUri
(
pageUrl
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
4
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
}
}
)
val
autofills
=
mapOf
(
"
#
user1
"
to
"
bar
"
"
#
user2
"
to
"
bar
"
"
#
pass1
"
to
"
baz
"
"
#
pass2
"
to
"
baz
"
"
#
email1
"
to
"
a
b
.
c
"
"
#
number1
"
to
"
24
"
"
#
tel1
"
to
"
42
"
)
val
promises
=
autofills
.
map
{
entry
-
>
mainSession
.
evaluatePromiseJS
(
"
"
"
window
.
getDataForAllFrames
(
'
{
entry
.
key
}
'
'
{
entry
.
value
}
'
)
"
"
"
)
}
val
autofillValues
=
SparseArray
<
CharSequence
>
(
)
fun
checkAutofillChild
(
child
:
Autofill
.
Node
domain
:
String
)
{
if
(
child
.
children
.
isNotEmpty
(
)
)
{
for
(
c
in
child
.
children
)
{
checkAutofillChild
(
c
!
!
child
.
domain
)
}
}
if
(
child
.
id
=
=
View
.
NO_ID
)
{
return
}
assertThat
(
"
Should
have
HTML
tag
"
child
.
tag
not
(
isEmptyOrNullString
(
)
)
)
if
(
domain
!
=
"
"
)
{
assertThat
(
"
Web
domain
should
match
its
parent
.
"
child
.
domain
equalTo
(
domain
)
)
}
if
(
child
.
inputType
=
=
Autofill
.
InputType
.
TEXT
)
{
assertThat
(
"
Input
should
be
enabled
"
child
.
enabled
equalTo
(
true
)
)
assertThat
(
"
Input
should
be
focusable
"
child
.
focusable
equalTo
(
true
)
)
assertThat
(
"
Should
have
HTML
tag
"
child
.
tag
equalTo
(
"
input
"
)
)
assertThat
(
"
Should
have
ID
attribute
"
child
.
attributes
.
get
(
"
id
"
)
not
(
isEmptyOrNullString
(
)
)
)
}
autofillValues
.
append
(
child
.
id
when
(
child
.
inputType
)
{
Autofill
.
InputType
.
NUMBER
-
>
"
24
"
Autofill
.
InputType
.
PHONE
-
>
"
42
"
Autofill
.
InputType
.
TEXT
-
>
when
(
child
.
hint
)
{
Autofill
.
Hint
.
PASSWORD
-
>
"
baz
"
Autofill
.
Hint
.
EMAIL_ADDRESS
-
>
"
a
b
.
c
"
else
-
>
"
bar
"
}
else
-
>
"
bar
"
}
)
}
val
nodes
=
mainSession
.
autofillSession
.
root
checkAutofillChild
(
nodes
"
"
)
mainSession
.
autofill
(
autofillValues
)
for
(
values
in
promises
.
map
{
it
.
value
.
asJsonArray
(
)
}
)
{
for
(
i
in
0
until
values
.
length
(
)
)
{
val
(
key
actual
expected
eventInterface
)
=
values
.
get
(
i
)
.
asJSList
<
String
>
(
)
assertThat
(
"
Auto
-
filled
value
must
match
(
key
)
"
actual
equalTo
(
expected
)
)
assertThat
(
"
input
event
should
be
dispatched
with
InputEvent
interface
"
eventInterface
equalTo
(
"
InputEvent
"
)
)
}
}
}
Test
fun
autofillUnknownValue
(
)
{
mainSession
.
loadUri
(
pageUrl
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
}
}
)
val
autofillValues
=
SparseArray
<
CharSequence
>
(
)
autofillValues
.
append
(
-
1
"
lobster
"
)
mainSession
.
autofill
(
autofillValues
)
}
private
fun
countAutofillNodes
(
cond
:
(
Autofill
.
Node
)
-
>
Boolean
=
{
it
.
inputType
!
=
Autofill
.
InputType
.
NONE
}
root
:
Autofill
.
Node
?
=
null
)
:
Int
{
val
node
=
if
(
root
!
=
=
null
)
root
else
mainSession
.
autofillSession
.
root
return
(
if
(
cond
(
node
)
)
1
else
0
)
+
node
.
children
.
sumOf
{
countAutofillNodes
(
cond
it
)
}
}
WithDisplay
(
width
=
100
height
=
100
)
Test
fun
autofillNavigation
(
)
{
mainSession
.
loadUri
(
pageUrl
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
4
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
starting
auto
-
fill
"
notification
equalTo
(
forEachCall
(
Autofill
.
Notify
.
SESSION_STARTED
Autofill
.
Notify
.
NODE_ADDED
)
)
)
assertThat
(
"
Node
should
be
valid
"
node
notNullValue
(
)
)
}
}
)
assertThat
(
"
Initial
auto
-
fill
count
should
match
"
countAutofillNodes
(
)
equalTo
(
16
)
)
mainSession
.
loadTestPath
(
HELLO_HTML_PATH
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
canceling
auto
-
fill
"
notification
equalTo
(
Autofill
.
Notify
.
SESSION_CANCELED
)
)
assertThat
(
"
Node
should
be
null
"
node
nullValue
(
)
)
}
}
)
assertThat
(
"
Should
not
have
auto
-
fill
fields
"
countAutofillNodes
(
)
equalTo
(
0
)
)
mainSession
.
waitForPageStop
(
)
mainSession
.
goBack
(
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
GeckoSession
.
ProgressDelegate
{
AssertCalled
(
count
=
4
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
starting
auto
-
fill
"
notification
equalTo
(
forEachCall
(
Autofill
.
Notify
.
SESSION_STARTED
Autofill
.
Notify
.
NODE_ADDED
)
)
)
assertThat
(
"
ID
should
be
valid
"
node
notNullValue
(
)
)
}
AssertCalled
(
count
=
1
)
override
fun
onPageStop
(
session
:
GeckoSession
success
:
Boolean
)
{
}
}
)
assertThat
(
"
Should
have
auto
-
fill
fields
again
"
countAutofillNodes
(
)
equalTo
(
16
)
)
assertThat
(
"
Should
not
have
focused
field
"
countAutofillNodes
(
{
it
.
focused
}
)
equalTo
(
0
)
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
pass2
'
)
.
focus
(
)
"
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
entering
auto
-
fill
view
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_FOCUSED
)
)
assertThat
(
"
ID
should
be
valid
"
node
notNullValue
(
)
)
}
}
)
assertThat
(
"
Should
have
one
focused
field
"
countAutofillNodes
(
{
it
.
focused
}
)
equalTo
(
1
)
)
assertThat
(
"
Should
have
nine
visible
nodes
"
countAutofillNodes
(
{
node
-
>
node
.
visible
}
)
equalTo
(
8
)
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
pass2
'
)
.
blur
(
)
"
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
exiting
auto
-
fill
view
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_BLURRED
)
)
assertThat
(
"
ID
should
be
valid
"
node
notNullValue
(
)
)
}
}
)
assertThat
(
"
Should
not
have
focused
field
"
countAutofillNodes
(
{
it
.
focused
}
)
equalTo
(
0
)
)
}
WithDisplay
(
height
=
100
width
=
100
)
Test
fun
autofillUserpass
(
)
{
mainSession
.
loadTestPath
(
FORMS2_HTML_PATH
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
3
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Autofill
notification
should
match
"
notification
equalTo
(
forEachCall
(
Autofill
.
Notify
.
SESSION_STARTED
Autofill
.
Notify
.
NODE_FOCUSED
Autofill
.
Notify
.
NODE_ADDED
)
)
)
}
}
)
fun
checkAutofillChild
(
child
:
Autofill
.
Node
)
:
Int
{
var
sum
=
0
for
(
c
in
child
.
children
)
{
sum
+
=
checkAutofillChild
(
c
!
!
)
}
if
(
child
.
hint
=
=
Autofill
.
Hint
.
NONE
)
{
return
sum
}
assertThat
(
"
ID
should
be
valid
"
child
.
id
not
(
equalTo
(
View
.
NO_ID
)
)
)
assertThat
(
"
Should
have
HTML
tag
"
child
.
tag
equalTo
(
"
input
"
)
)
return
sum
+
1
}
val
root
=
mainSession
.
autofillSession
.
root
assertThat
(
"
autofill
hint
count
"
checkAutofillChild
(
root
)
equalTo
(
4
)
)
}
WithDisplay
(
width
=
100
height
=
100
)
Test
fun
autofillActiveChange
(
)
{
mainSession
.
loadUri
(
pageUrl
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
4
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
starting
auto
-
fill
"
notification
equalTo
(
forEachCall
(
Autofill
.
Notify
.
SESSION_STARTED
Autofill
.
Notify
.
NODE_ADDED
)
)
)
}
}
)
mainSession
.
evaluateJS
(
"
document
.
querySelector
(
'
#
pass2
'
)
.
focus
(
)
"
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
entering
auto
-
fill
view
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_FOCUSED
)
)
assertThat
(
"
ID
should
be
valid
"
node
notNullValue
(
)
)
}
}
)
assertThat
(
"
Should
have
one
focused
field
"
countAutofillNodes
(
{
it
.
focused
}
)
equalTo
(
1
)
)
mainSession
.
setActive
(
false
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
exiting
auto
-
fill
view
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_BLURRED
)
)
assertThat
(
"
ID
should
be
valid
"
node
notNullValue
(
)
)
}
}
)
mainSession
.
setActive
(
true
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
1
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
assertThat
(
"
Should
be
entering
auto
-
fill
view
"
notification
equalTo
(
Autofill
.
Notify
.
NODE_FOCUSED
)
)
assertThat
(
"
ID
should
be
valid
"
node
notNullValue
(
)
)
}
}
)
assertThat
(
"
Should
have
one
focused
field
"
countAutofillNodes
(
{
it
.
focused
}
)
equalTo
(
1
)
)
}
WithDisplay
(
width
=
100
height
=
100
)
Test
fun
autofillAutocompleteAttribute
(
)
{
mainSession
.
loadTestPath
(
FORMS_AUTOCOMPLETE_HTML_PATH
)
sessionRule
.
waitUntilCalled
(
object
:
Autofill
.
Delegate
{
AssertCalled
(
count
=
3
)
override
fun
onAutofill
(
session
:
GeckoSession
notification
:
Int
node
:
Autofill
.
Node
?
)
{
}
}
)
;
fun
checkAutofillChild
(
child
:
Autofill
.
Node
)
:
Int
{
var
sum
=
0
for
(
c
in
child
.
children
)
{
sum
+
=
checkAutofillChild
(
c
!
!
)
}
if
(
child
.
hint
=
=
Autofill
.
Hint
.
NONE
)
{
return
sum
}
assertThat
(
"
Should
have
HTML
tag
"
child
.
tag
equalTo
(
"
input
"
)
)
return
sum
+
1
}
val
root
=
mainSession
.
autofillSession
.
root
assertThat
(
"
autofill
hint
count
"
checkAutofillChild
(
root
)
equalTo
(
6
)
)
}
}
