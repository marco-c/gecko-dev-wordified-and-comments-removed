package
org
.
mozilla
.
geckoview
.
test
import
androidx
.
test
.
filters
.
MediumTest
import
androidx
.
test
.
ext
.
junit
.
runners
.
AndroidJUnit4
import
java
.
util
.
concurrent
.
CancellationException
;
import
org
.
hamcrest
.
core
.
StringEndsWith
.
endsWith
import
org
.
hamcrest
.
core
.
IsEqual
.
equalTo
import
org
.
json
.
JSONObject
import
org
.
junit
.
Assert
.
*
import
org
.
junit
.
Before
import
org
.
junit
.
Test
import
org
.
junit
.
runner
.
RunWith
import
org
.
mozilla
.
geckoview
.
*
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
AssertCalled
import
org
.
mozilla
.
geckoview
.
test
.
util
.
Callbacks
import
org
.
mozilla
.
geckoview
.
WebExtension
.
DisabledFlags
import
org
.
mozilla
.
geckoview
.
WebExtensionController
.
EnableSource
import
org
.
mozilla
.
geckoview
.
test
.
rule
.
GeckoSessionTestRule
.
Setting
import
java
.
util
.
UUID
RunWith
(
AndroidJUnit4
:
:
class
)
MediumTest
class
WebExtensionTest
:
BaseSessionTest
(
)
{
companion
object
{
private
const
val
TABS_CREATE_BACKGROUND
:
String
=
"
resource
:
/
/
android
/
assets
/
web_extensions
/
tabs
-
create
/
"
private
const
val
TABS_CREATE_REMOVE_BACKGROUND
:
String
=
"
resource
:
/
/
android
/
assets
/
web_extensions
/
tabs
-
create
-
remove
/
"
private
const
val
TABS_ACTIVATE_REMOVE_BACKGROUND
:
String
=
"
resource
:
/
/
android
/
assets
/
web_extensions
/
tabs
-
activate
-
remove
/
"
private
const
val
TABS_REMOVE_BACKGROUND
:
String
=
"
resource
:
/
/
android
/
assets
/
web_extensions
/
tabs
-
remove
/
"
private
const
val
MESSAGING_BACKGROUND
:
String
=
"
resource
:
/
/
android
/
assets
/
web_extensions
/
messaging
/
"
private
const
val
MESSAGING_CONTENT
:
String
=
"
resource
:
/
/
android
/
assets
/
web_extensions
/
messaging
-
content
/
"
}
private
val
controller
get
(
)
=
sessionRule
.
runtime
.
webExtensionController
Before
fun
setup
(
)
{
sessionRule
.
addExternalDelegateUntilTestEnd
(
WebExtensionController
.
PromptDelegate
:
:
class
controller
:
:
setPromptDelegate
{
controller
.
promptDelegate
=
null
}
object
:
WebExtensionController
.
PromptDelegate
{
}
)
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
extensions
.
isembedded
"
to
true
)
)
sessionRule
.
runtime
.
webExtensionController
.
setTabActive
(
mainSession
true
)
}
Test
fun
registerWebExtension
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
val
borderify
=
WebExtension
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
/
"
controller
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
borderify
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
borderify
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
private
fun
assertBodyBorderEqualTo
(
expected
:
String
)
{
val
color
=
mainSession
.
evaluateJS
(
"
document
.
body
.
style
.
borderColor
"
)
assertThat
(
"
The
border
color
should
be
'
expected
'
"
color
as
String
equalTo
(
expected
)
)
}
private
fun
checkDisabledState
(
extension
:
WebExtension
userDisabled
:
Boolean
=
false
appDisabled
:
Boolean
=
false
blocklistDisabled
:
Boolean
=
false
)
{
val
enabled
=
!
userDisabled
&
&
!
appDisabled
&
&
!
blocklistDisabled
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
if
(
!
enabled
)
{
assertBodyBorderEqualTo
(
"
"
)
}
else
{
assertBodyBorderEqualTo
(
"
red
"
)
}
assertThat
(
"
enabled
should
match
"
extension
.
metaData
!
!
.
enabled
equalTo
(
enabled
)
)
assertThat
(
"
userDisabled
should
match
"
extension
.
metaData
!
!
.
disabledFlags
and
DisabledFlags
.
USER
>
0
equalTo
(
userDisabled
)
)
assertThat
(
"
appDisabled
should
match
"
extension
.
metaData
!
!
.
disabledFlags
and
DisabledFlags
.
APP
>
0
equalTo
(
appDisabled
)
)
assertThat
(
"
blocklistDisabled
should
match
"
extension
.
metaData
!
!
.
disabledFlags
and
DisabledFlags
.
BLOCKLIST
>
0
equalTo
(
blocklistDisabled
)
)
}
Test
fun
enableDisable
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
assertBodyBorderEqualTo
(
"
"
)
var
borderify
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
.
xpi
"
)
)
checkDisabledState
(
borderify
userDisabled
=
false
appDisabled
=
false
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
disable
(
borderify
EnableSource
.
USER
)
)
checkDisabledState
(
borderify
userDisabled
=
true
appDisabled
=
false
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
disable
(
borderify
EnableSource
.
APP
)
)
checkDisabledState
(
borderify
userDisabled
=
true
appDisabled
=
true
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
enable
(
borderify
EnableSource
.
APP
)
)
checkDisabledState
(
borderify
userDisabled
=
true
appDisabled
=
false
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
enable
(
borderify
EnableSource
.
USER
)
)
checkDisabledState
(
borderify
userDisabled
=
false
appDisabled
=
false
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
disable
(
borderify
EnableSource
.
APP
)
)
checkDisabledState
(
borderify
userDisabled
=
false
appDisabled
=
true
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
enable
(
borderify
EnableSource
.
APP
)
)
checkDisabledState
(
borderify
userDisabled
=
false
appDisabled
=
false
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
borderify
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
fun
installWebExtension
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
.
metaData
!
!
.
description
"
Adds
a
red
border
to
all
webpages
matching
example
.
com
.
"
)
assertEquals
(
extension
.
metaData
!
!
.
name
"
Borderify
"
)
assertEquals
(
extension
.
metaData
!
!
.
version
"
1
.
0
"
)
assertEquals
(
extension
.
metaData
!
!
.
enabled
false
)
assertEquals
(
extension
.
metaData
!
!
.
signedState
WebExtension
.
SignedStateFlags
.
SIGNED
)
assertEquals
(
extension
.
metaData
!
!
.
blocklistState
WebExtension
.
BlocklistStateFlags
.
NOT_BLOCKED
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
borderify
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
.
xpi
"
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
var
list
=
sessionRule
.
waitForResult
(
controller
.
list
(
)
)
assertEquals
(
list
.
size
1
)
assertEquals
(
list
[
0
]
.
id
borderify
.
id
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
borderify
)
)
list
=
sessionRule
.
waitForResult
(
controller
.
list
(
)
)
assertEquals
(
list
emptyList
<
WebExtension
>
(
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
Setting
.
List
(
Setting
(
key
=
Setting
.
Key
.
USE_PRIVATE_MODE
value
=
"
true
"
)
)
fun
runInPrivateBrowsing
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
var
borderify
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
.
xpi
"
)
)
assertTrue
(
mainSession
.
settings
.
usePrivateMode
)
assertFalse
(
borderify
.
metaData
!
!
.
allowedInPrivateBrowsing
)
assertBodyBorderEqualTo
(
"
"
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
setAllowedInPrivateBrowsing
(
borderify
true
)
)
assertTrue
(
borderify
.
metaData
!
!
.
allowedInPrivateBrowsing
)
mainSession
.
reload
(
)
;
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
borderify
=
sessionRule
.
waitForResult
(
controller
.
setAllowedInPrivateBrowsing
(
borderify
false
)
)
assertFalse
(
borderify
.
metaData
!
!
.
allowedInPrivateBrowsing
)
mainSession
.
reload
(
)
;
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
borderify
)
)
mainSession
.
reload
(
)
;
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
fun
optionsPageMetadata
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
)
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
dummy
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
dummy
.
xpi
"
)
)
val
metadata
=
dummy
.
metaData
!
!
assertTrue
(
(
metadata
.
optionsPageUrl
?
:
"
"
)
.
matches
(
"
^
moz
-
extension
:
/
/
[
0
-
9a
-
f
\
\
-
]
*
/
options
.
html
"
.
toRegex
(
)
)
)
;
assertEquals
(
metadata
.
openOptionsPageInTab
true
)
;
assertTrue
(
metadata
.
baseUrl
.
matches
(
"
^
moz
-
extension
:
/
/
[
0
-
9a
-
f
\
\
-
]
*
/
"
.
toRegex
(
)
)
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
dummy
)
)
}
Test
fun
installMultiple
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
)
)
var
list
=
sessionRule
.
waitForResult
(
controller
.
list
(
)
)
assertEquals
(
list
emptyList
<
WebExtension
>
(
)
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
(
count
=
2
)
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
borderifyResult
=
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
.
xpi
"
)
val
dummyResult
=
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
dummy
.
xpi
"
)
val
(
borderify
dummy
)
=
sessionRule
.
waitForResult
(
GeckoResult
.
allOf
(
borderifyResult
dummyResult
)
)
list
=
sessionRule
.
waitForResult
(
controller
.
list
(
)
)
assertTrue
(
list
.
find
{
it
.
id
=
=
borderify
.
id
}
!
=
null
)
assertTrue
(
list
.
find
{
it
.
id
=
=
dummy
.
id
}
!
=
null
)
assertEquals
(
list
.
size
2
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
borderify
)
)
list
=
sessionRule
.
waitForResult
(
controller
.
list
(
)
)
assertEquals
(
list
.
size
1
)
assertEquals
(
list
[
0
]
.
id
dummy
.
id
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
dummy
)
)
list
=
sessionRule
.
waitForResult
(
controller
.
list
(
)
)
assertEquals
(
list
emptyList
<
WebExtension
>
(
)
)
}
private
fun
testInstallError
(
name
:
String
expectedError
:
Int
)
{
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
(
count
=
0
)
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
name
"
)
.
accept
(
{
assertTrue
(
false
)
}
{
exception
-
>
val
installException
=
exception
as
WebExtension
.
InstallException
assertEquals
(
installException
.
code
expectedError
)
}
)
)
}
Test
fun
installUnsignedExtensionSignatureNotRequired
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
)
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
borderify
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
-
unsigned
.
xpi
"
)
.
then
{
extension
-
>
assertEquals
(
extension
!
!
.
metaData
!
!
.
signedState
WebExtension
.
SignedStateFlags
.
MISSING
)
assertEquals
(
extension
.
metaData
!
!
.
blocklistState
WebExtension
.
BlocklistStateFlags
.
NOT_BLOCKED
)
assertEquals
(
extension
.
metaData
!
!
.
name
"
Borderify
"
)
GeckoResult
.
fromValue
(
extension
)
}
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
borderify
)
)
}
Test
fun
installUnsignedExtensionSignatureRequired
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
true
)
)
testInstallError
(
"
borderify
-
unsigned
.
xpi
"
WebExtension
.
InstallException
.
ErrorCodes
.
ERROR_SIGNEDSTATE_REQUIRED
)
}
Test
fun
installExtensionFileNotFound
(
)
{
testInstallError
(
"
file
-
not
-
found
.
xpi
"
WebExtension
.
InstallException
.
ErrorCodes
.
ERROR_NETWORK_FAILURE
)
}
Test
fun
installExtensionMissingId
(
)
{
testInstallError
(
"
borderify
-
missing
-
id
.
xpi
"
WebExtension
.
InstallException
.
ErrorCodes
.
ERROR_CORRUPT_FILE
)
}
Test
fun
installDeny
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
(
count
=
1
)
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
DENY
)
}
}
)
sessionRule
.
waitForResult
(
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
.
xpi
"
)
.
accept
(
{
assertTrue
(
false
)
}
{
exception
-
>
assertTrue
(
exception
is
WebExtension
.
InstallException
)
val
installException
=
exception
as
WebExtension
.
InstallException
assertEquals
(
installException
.
code
WebExtension
.
InstallException
.
ErrorCodes
.
ERROR_USER_CANCELED
)
}
)
)
;
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
private
fun
testOnMessage
(
background
:
Boolean
)
{
val
messageResult
=
GeckoResult
<
Void
>
(
)
val
prefix
=
if
(
background
)
"
testBackground
"
else
"
testContent
"
val
messageDelegate
=
object
:
WebExtension
.
MessageDelegate
{
var
awaitingResponse
=
false
var
completed
=
false
override
fun
onConnect
(
port
:
WebExtension
.
Port
)
{
}
override
fun
onMessage
(
nativeApp
:
String
message
:
Any
sender
:
WebExtension
.
MessageSender
)
:
GeckoResult
<
Any
>
?
{
checkSender
(
nativeApp
sender
background
)
if
(
!
awaitingResponse
)
{
assertThat
(
"
We
should
receive
a
message
from
the
WebExtension
"
message
as
String
equalTo
(
"
{
prefix
}
BrowserMessage
"
)
)
awaitingResponse
=
true
return
GeckoResult
.
fromValue
(
"
{
prefix
}
MessageResponse
"
)
}
else
if
(
!
completed
)
{
assertThat
(
"
The
background
script
should
receive
our
message
and
respond
"
message
as
String
equalTo
(
"
response
:
{
prefix
}
MessageResponse
"
)
)
messageResult
.
complete
(
null
)
completed
=
true
}
return
null
}
}
val
messaging
=
createWebExtension
(
background
messageDelegate
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
messaging
)
)
sessionRule
.
waitForResult
(
messageResult
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
messaging
)
)
}
Test
fun
testBrowserTabsCreate
(
)
{
val
tabsCreateResult
=
GeckoResult
<
Void
>
(
)
val
tabsExtension
=
WebExtension
(
TABS_CREATE_BACKGROUND
controller
)
val
tabDelegate
=
object
:
WebExtension
.
TabDelegate
{
override
fun
onNewTab
(
source
:
WebExtension
details
:
WebExtension
.
CreateTabDetails
)
:
GeckoResult
<
GeckoSession
>
{
assertEquals
(
details
.
url
"
https
:
/
/
www
.
mozilla
.
org
/
en
-
US
/
"
)
assertEquals
(
details
.
active
true
)
assertEquals
(
tabsExtension
source
)
tabsCreateResult
.
complete
(
null
)
return
GeckoResult
.
fromValue
(
null
)
}
}
tabsExtension
.
setTabDelegate
(
tabDelegate
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
tabsExtension
)
)
sessionRule
.
waitForResult
(
tabsCreateResult
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
tabsExtension
)
)
}
Test
fun
testBrowserTabsCreateBrowserTabsRemove
(
)
{
val
onCloseRequestResult
=
GeckoResult
<
Void
>
(
)
val
tabsExtension
=
WebExtension
(
TABS_CREATE_REMOVE_BACKGROUND
controller
)
sessionRule
.
addExternalDelegateUntilTestEnd
(
WebExtension
.
TabDelegate
:
:
class
tabsExtension
:
:
setTabDelegate
{
tabsExtension
.
setTabDelegate
(
null
)
}
object
:
WebExtension
.
TabDelegate
{
override
fun
onNewTab
(
source
:
WebExtension
details
:
WebExtension
.
CreateTabDetails
)
:
GeckoResult
<
GeckoSession
>
{
val
extensionCreatedSession
=
sessionRule
.
createClosedSession
(
sessionRule
.
session
.
settings
)
extensionCreatedSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
object
:
WebExtension
.
SessionTabDelegate
{
override
fun
onCloseTab
(
source
:
WebExtension
?
session
:
GeckoSession
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
tabsExtension
source
)
assertEquals
(
details
.
active
true
)
assertNotEquals
(
null
extensionCreatedSession
)
assertEquals
(
extensionCreatedSession
session
)
onCloseRequestResult
.
complete
(
null
)
return
GeckoResult
.
ALLOW
}
}
)
return
GeckoResult
.
fromValue
(
extensionCreatedSession
)
}
}
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
tabsExtension
)
)
sessionRule
.
waitForResult
(
onCloseRequestResult
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
tabsExtension
)
)
}
Test
fun
testSetTabActive
(
)
{
val
onCloseRequestResult
=
GeckoResult
<
Void
>
(
)
val
tabsExtension
=
WebExtension
(
TABS_ACTIVATE_REMOVE_BACKGROUND
controller
)
val
newTabSession
=
sessionRule
.
createOpenSession
(
sessionRule
.
session
.
settings
)
sessionRule
.
addExternalDelegateUntilTestEnd
(
WebExtension
.
SessionTabDelegate
:
:
class
{
delegate
-
>
newTabSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
delegate
)
}
{
newTabSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
null
)
}
object
:
WebExtension
.
SessionTabDelegate
{
override
fun
onCloseTab
(
source
:
WebExtension
?
session
:
GeckoSession
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
tabsExtension
source
)
assertEquals
(
newTabSession
session
)
onCloseRequestResult
.
complete
(
null
)
return
GeckoResult
.
ALLOW
}
}
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
tabsExtension
)
)
controller
.
setTabActive
(
sessionRule
.
session
false
)
controller
.
setTabActive
(
newTabSession
true
)
sessionRule
.
waitForResult
(
onCloseRequestResult
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
tabsExtension
)
)
}
Test
fun
testSetTabActiveNotAllowedInPrivateBrowsing
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
"
extensions
.
install
.
requireBuiltInCerts
"
to
false
"
extensions
.
update
.
requireBuiltInCerts
"
to
false
)
)
val
onCloseRequestResult
=
GeckoResult
<
Void
>
(
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
tabsExtension
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
tabs
-
activate
-
remove
.
xpi
"
)
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
var
tabsExtensionPB
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
tabs
-
activate
-
remove
-
2
.
xpi
"
)
)
tabsExtensionPB
=
sessionRule
.
waitForResult
(
controller
.
setAllowedInPrivateBrowsing
(
tabsExtensionPB
true
)
)
val
newTabSession
=
sessionRule
.
createOpenSession
(
sessionRule
.
session
.
settings
)
val
newPrivateSession
=
sessionRule
.
createOpenSession
(
GeckoSessionSettings
.
Builder
(
)
.
usePrivateMode
(
true
)
.
build
(
)
)
val
privateBrowsingNewTabSession
=
GeckoResult
<
Void
>
(
)
class
TabDelegate
(
val
result
:
GeckoResult
<
Void
>
val
extension
:
WebExtension
val
expectedSession
:
GeckoSession
)
:
WebExtension
.
SessionTabDelegate
{
override
fun
onCloseTab
(
source
:
WebExtension
?
session
:
GeckoSession
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
source
)
assertEquals
(
expectedSession
session
)
result
.
complete
(
null
)
return
GeckoResult
.
ALLOW
}
}
newTabSession
.
webExtensionController
.
setTabDelegate
(
tabsExtensionPB
TabDelegate
(
privateBrowsingNewTabSession
tabsExtensionPB
newTabSession
)
)
newTabSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
TabDelegate
(
onCloseRequestResult
tabsExtension
newTabSession
)
)
val
privateBrowsingPrivateSession
=
GeckoResult
<
Void
>
(
)
newPrivateSession
.
webExtensionController
.
setTabDelegate
(
tabsExtensionPB
TabDelegate
(
privateBrowsingPrivateSession
tabsExtensionPB
newPrivateSession
)
)
newPrivateSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
object
:
WebExtension
.
SessionTabDelegate
{
override
fun
onCloseTab
(
source
:
WebExtension
?
session
:
GeckoSession
)
:
GeckoResult
<
AllowOrDeny
>
{
privateBrowsingPrivateSession
.
completeExceptionally
(
RuntimeException
(
"
Should
never
happen
"
)
)
return
GeckoResult
.
ALLOW
}
}
)
controller
.
setTabActive
(
sessionRule
.
session
false
)
controller
.
setTabActive
(
newPrivateSession
true
)
sessionRule
.
waitForResult
(
privateBrowsingPrivateSession
)
controller
.
setTabActive
(
newPrivateSession
false
)
controller
.
setTabActive
(
newTabSession
true
)
sessionRule
.
waitForResult
(
onCloseRequestResult
)
sessionRule
.
waitForResult
(
privateBrowsingNewTabSession
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
webExtensionController
.
uninstall
(
tabsExtension
)
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
webExtensionController
.
uninstall
(
tabsExtensionPB
)
)
newTabSession
.
close
(
)
newPrivateSession
.
close
(
)
}
Test
fun
testBrowserTabsRemove
(
)
{
val
onCloseRequestResult
=
GeckoResult
<
Void
>
(
)
val
existingSession
=
sessionRule
.
createOpenSession
(
)
existingSession
.
loadTestPath
(
"
HELLO_HTML_PATH
?
tabToClose
"
)
existingSession
.
waitForPageStop
(
)
val
tabsExtension
=
WebExtension
(
TABS_REMOVE_BACKGROUND
controller
)
sessionRule
.
addExternalDelegateUntilTestEnd
(
WebExtension
.
SessionTabDelegate
:
:
class
{
delegate
-
>
existingSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
delegate
)
}
{
existingSession
.
webExtensionController
.
setTabDelegate
(
tabsExtension
null
)
}
object
:
WebExtension
.
SessionTabDelegate
{
override
fun
onCloseTab
(
source
:
WebExtension
?
session
:
GeckoSession
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
existingSession
session
)
onCloseRequestResult
.
complete
(
null
)
return
GeckoResult
.
ALLOW
}
}
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
tabsExtension
)
)
sessionRule
.
waitForResult
(
onCloseRequestResult
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
tabsExtension
)
)
}
private
fun
createWebExtension
(
background
:
Boolean
messageDelegate
:
WebExtension
.
MessageDelegate
)
:
WebExtension
{
val
webExtension
:
WebExtension
val
uuid
=
"
{
{
UUID
.
randomUUID
(
)
}
}
"
if
(
background
)
{
webExtension
=
WebExtension
(
MESSAGING_BACKGROUND
uuid
WebExtension
.
Flags
.
NONE
controller
)
webExtension
.
setMessageDelegate
(
messageDelegate
"
browser
"
)
}
else
{
webExtension
=
WebExtension
(
MESSAGING_CONTENT
uuid
WebExtension
.
Flags
.
ALLOW_CONTENT_MESSAGING
controller
)
sessionRule
.
session
.
webExtensionController
.
setMessageDelegate
(
webExtension
messageDelegate
"
browser
"
)
}
return
webExtension
}
Test
fun
contentMessaging
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
testOnMessage
(
false
)
}
Test
fun
backgroundMessaging
(
)
{
testOnMessage
(
true
)
}
private
fun
testPortMessage
(
background
:
Boolean
)
{
val
result
=
GeckoResult
<
Void
>
(
)
val
prefix
=
if
(
background
)
"
testBackground
"
else
"
testContent
"
val
portDelegate
=
object
:
WebExtension
.
PortDelegate
{
var
awaitingResponse
=
false
override
fun
onPortMessage
(
message
:
Any
port
:
WebExtension
.
Port
)
{
assertEquals
(
port
.
name
"
browser
"
)
if
(
!
awaitingResponse
)
{
assertThat
(
"
We
should
receive
a
message
from
the
WebExtension
"
message
as
String
equalTo
(
"
{
prefix
}
PortMessage
"
)
)
port
.
postMessage
(
JSONObject
(
"
{
\
"
message
\
"
:
\
"
{
prefix
}
PortMessageResponse
\
"
}
"
)
)
awaitingResponse
=
true
}
else
{
assertThat
(
"
The
background
script
should
receive
our
message
and
respond
"
message
as
String
equalTo
(
"
response
:
{
prefix
}
PortMessageResponse
"
)
)
result
.
complete
(
null
)
}
}
override
fun
onDisconnect
(
port
:
WebExtension
.
Port
)
{
}
}
val
messageDelegate
=
object
:
WebExtension
.
MessageDelegate
{
override
fun
onConnect
(
port
:
WebExtension
.
Port
)
{
checkSender
(
port
.
name
port
.
sender
background
)
assertEquals
(
port
.
name
"
browser
"
)
port
.
setDelegate
(
portDelegate
)
}
override
fun
onMessage
(
nativeApp
:
String
message
:
Any
sender
:
WebExtension
.
MessageSender
)
:
GeckoResult
<
Any
>
?
{
return
null
}
}
val
messaging
=
createWebExtension
(
background
messageDelegate
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
messaging
)
)
sessionRule
.
waitForResult
(
result
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
messaging
)
)
}
Test
fun
contentPortMessaging
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
testPortMessage
(
false
)
}
Test
fun
backgroundPortMessaging
(
)
{
testPortMessage
(
true
)
}
private
fun
testPortDisconnect
(
background
:
Boolean
refresh
:
Boolean
)
{
val
result
=
GeckoResult
<
Void
>
(
)
var
messaging
:
WebExtension
?
=
null
var
messagingPort
:
WebExtension
.
Port
?
=
null
val
portDelegate
=
object
:
WebExtension
.
PortDelegate
{
override
fun
onPortMessage
(
message
:
Any
port
:
WebExtension
.
Port
)
{
assertEquals
(
port
messagingPort
)
}
override
fun
onDisconnect
(
port
:
WebExtension
.
Port
)
{
assertEquals
(
messaging
port
.
sender
.
webExtension
)
assertEquals
(
port
messagingPort
)
result
.
complete
(
null
)
}
}
val
messageDelegate
=
object
:
WebExtension
.
MessageDelegate
{
override
fun
onConnect
(
port
:
WebExtension
.
Port
)
{
assertEquals
(
messaging
port
.
sender
.
webExtension
)
checkSender
(
port
.
name
port
.
sender
background
)
assertEquals
(
port
.
name
"
browser
"
)
messagingPort
=
port
port
.
setDelegate
(
portDelegate
)
if
(
refresh
)
{
sessionRule
.
session
.
reload
(
)
}
else
{
val
message
=
JSONObject
(
)
message
.
put
(
"
action
"
"
disconnect
"
)
port
.
postMessage
(
message
)
}
}
override
fun
onMessage
(
nativeApp
:
String
message
:
Any
sender
:
WebExtension
.
MessageSender
)
:
GeckoResult
<
Any
>
?
{
assertEquals
(
messaging
sender
.
webExtension
)
return
null
}
}
messaging
=
createWebExtension
(
background
messageDelegate
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
messaging
)
)
sessionRule
.
waitForResult
(
result
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
messaging
)
)
}
Test
fun
contentPortDisconnect
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
testPortDisconnect
(
background
=
false
refresh
=
false
)
}
Test
fun
backgroundPortDisconnect
(
)
{
testPortDisconnect
(
background
=
true
refresh
=
false
)
}
Test
fun
contentPortDisconnectAfterRefresh
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
testPortDisconnect
(
background
=
false
refresh
=
true
)
}
fun
checkSender
(
nativeApp
:
String
sender
:
WebExtension
.
MessageSender
background
:
Boolean
)
{
assertEquals
(
"
nativeApp
should
always
be
'
browser
'
"
nativeApp
"
browser
"
)
if
(
background
)
{
assertEquals
(
"
Called
from
content
script
with
background
-
only
delegate
.
"
sender
.
environmentType
WebExtension
.
MessageSender
.
ENV_TYPE_EXTENSION
)
assertTrue
(
"
Unexpected
sender
url
"
sender
.
url
.
endsWith
(
"
/
_generated_background_page
.
html
"
)
)
}
else
{
assertEquals
(
"
Called
from
background
script
expecting
only
content
scripts
"
sender
.
environmentType
WebExtension
.
MessageSender
.
ENV_TYPE_CONTENT_SCRIPT
)
assertTrue
(
"
Expecting
only
top
level
senders
.
"
sender
.
isTopLevel
)
assertEquals
(
"
Unexpected
sender
url
"
sender
.
url
"
http
:
/
/
example
.
com
/
"
)
}
}
private
fun
testPortDisconnectFromApp
(
background
:
Boolean
)
{
val
result
=
GeckoResult
<
Void
>
(
)
var
messaging
:
WebExtension
?
=
null
val
messageDelegate
=
object
:
WebExtension
.
MessageDelegate
{
override
fun
onConnect
(
port
:
WebExtension
.
Port
)
{
assertEquals
(
messaging
port
.
sender
.
webExtension
)
checkSender
(
port
.
name
port
.
sender
background
)
port
.
disconnect
(
)
}
override
fun
onMessage
(
nativeApp
:
String
message
:
Any
sender
:
WebExtension
.
MessageSender
)
:
GeckoResult
<
Any
>
?
{
assertEquals
(
messaging
sender
.
webExtension
)
checkSender
(
nativeApp
sender
background
)
if
(
message
is
JSONObject
)
{
if
(
message
.
getString
(
"
type
"
)
=
=
"
portDisconnected
"
)
{
result
.
complete
(
null
)
}
}
return
null
}
}
messaging
=
createWebExtension
(
background
messageDelegate
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
messaging
)
)
sessionRule
.
waitForResult
(
result
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
messaging
)
)
}
Test
fun
contentPortDisconnectFromApp
(
)
{
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
testPortDisconnectFromApp
(
false
)
}
Test
fun
backgroundPortDisconnectFromApp
(
)
{
testPortDisconnectFromApp
(
true
)
}
private
fun
testIframeTopLevel
(
)
{
val
portTopLevel
=
GeckoResult
<
Void
>
(
)
val
portIframe
=
GeckoResult
<
Void
>
(
)
val
messageTopLevel
=
GeckoResult
<
Void
>
(
)
val
messageIframe
=
GeckoResult
<
Void
>
(
)
var
messaging
:
WebExtension
?
=
null
val
messageDelegate
=
object
:
WebExtension
.
MessageDelegate
{
override
fun
onConnect
(
port
:
WebExtension
.
Port
)
{
assertEquals
(
messaging
port
.
sender
.
webExtension
)
assertEquals
(
WebExtension
.
MessageSender
.
ENV_TYPE_CONTENT_SCRIPT
port
.
sender
.
environmentType
)
when
(
port
.
sender
.
url
)
{
"
TEST_ENDPOINT
HELLO_IFRAME_HTML_PATH
"
-
>
{
assertTrue
(
port
.
sender
.
isTopLevel
)
portTopLevel
.
complete
(
null
)
}
"
TEST_ENDPOINT
HELLO_HTML_PATH
"
-
>
{
assertFalse
(
port
.
sender
.
isTopLevel
)
portIframe
.
complete
(
null
)
}
else
-
>
fail
(
)
}
port
.
disconnect
(
)
}
override
fun
onMessage
(
nativeApp
:
String
message
:
Any
sender
:
WebExtension
.
MessageSender
)
:
GeckoResult
<
Any
>
?
{
assertEquals
(
messaging
sender
.
webExtension
)
assertEquals
(
WebExtension
.
MessageSender
.
ENV_TYPE_CONTENT_SCRIPT
sender
.
environmentType
)
when
(
sender
.
url
)
{
"
TEST_ENDPOINT
HELLO_IFRAME_HTML_PATH
"
-
>
{
assertTrue
(
sender
.
isTopLevel
)
messageTopLevel
.
complete
(
null
)
}
"
TEST_ENDPOINT
HELLO_HTML_PATH
"
-
>
{
assertFalse
(
sender
.
isTopLevel
)
messageIframe
.
complete
(
null
)
}
else
-
>
fail
(
)
}
return
null
}
}
messaging
=
WebExtension
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
messaging
-
iframe
/
"
"
{
{
UUID
.
randomUUID
(
)
}
}
"
WebExtension
.
Flags
.
ALLOW_CONTENT_MESSAGING
controller
)
sessionRule
.
session
.
webExtensionController
.
setMessageDelegate
(
messaging
messageDelegate
"
browser
"
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
messaging
)
)
sessionRule
.
waitForResult
(
portTopLevel
)
sessionRule
.
waitForResult
(
portIframe
)
sessionRule
.
waitForResult
(
messageTopLevel
)
sessionRule
.
waitForResult
(
messageIframe
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
unregisterWebExtension
(
messaging
)
)
}
Test
fun
iframeTopLevel
(
)
{
mainSession
.
loadTestPath
(
HELLO_IFRAME_HTML_PATH
)
sessionRule
.
waitForPageStop
(
)
testIframeTopLevel
(
)
}
Test
fun
loadWebExtensionPage
(
)
{
val
result
=
GeckoResult
<
String
>
(
)
var
extension
:
WebExtension
?
=
null
val
messageDelegate
=
object
:
WebExtension
.
MessageDelegate
{
override
fun
onMessage
(
nativeApp
:
String
message
:
Any
sender
:
WebExtension
.
MessageSender
)
:
GeckoResult
<
Any
>
?
{
assertEquals
(
extension
sender
.
webExtension
)
assertEquals
(
WebExtension
.
MessageSender
.
ENV_TYPE_EXTENSION
sender
.
environmentType
)
result
.
complete
(
message
as
String
)
return
null
}
}
extension
=
WebExtension
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
extension
-
page
-
update
/
"
controller
)
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
extension
)
)
val
sessionController
=
mainSession
.
webExtensionController
sessionController
.
setMessageDelegate
(
extension
messageDelegate
"
browser
"
)
sessionController
.
setTabDelegate
(
extension
object
:
WebExtension
.
SessionTabDelegate
{
override
fun
onUpdateTab
(
extension
:
WebExtension
session
:
GeckoSession
details
:
WebExtension
.
UpdateTabDetails
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
mainSession
.
loadUri
(
"
http
:
/
/
example
.
com
"
)
mainSession
.
waitUntilCalled
(
object
:
Callbacks
.
NavigationDelegate
Callbacks
.
ProgressDelegate
{
GeckoSessionTestRule
.
AssertCalled
(
count
=
1
)
override
fun
onLocationChange
(
session
:
GeckoSession
url
:
String
?
)
{
assertThat
(
"
Url
should
load
example
.
com
first
"
url
equalTo
(
"
http
:
/
/
example
.
com
/
"
)
)
}
GeckoSessionTestRule
.
AssertCalled
(
count
=
1
)
override
fun
onPageStop
(
session
:
GeckoSession
success
:
Boolean
)
{
assertThat
(
"
Page
should
load
successfully
.
"
success
equalTo
(
true
)
)
}
}
)
var
page
:
String
?
=
null
val
pageStop
=
GeckoResult
<
Boolean
>
(
)
mainSession
.
delegateUntilTestEnd
(
object
:
Callbacks
.
NavigationDelegate
Callbacks
.
ProgressDelegate
{
override
fun
onLocationChange
(
session
:
GeckoSession
url
:
String
?
)
{
page
=
url
}
override
fun
onPageStop
(
session
:
GeckoSession
success
:
Boolean
)
{
if
(
success
&
&
page
!
=
null
&
&
page
!
!
.
endsWith
(
"
/
tab
.
html
"
)
)
{
pageStop
.
complete
(
true
)
}
}
}
)
sessionRule
.
waitForResult
(
pageStop
)
assertThat
(
"
Url
should
load
WebExtension
page
"
page
endsWith
(
"
/
tab
.
html
"
)
)
assertThat
(
"
WebExtension
page
should
have
access
to
privileged
APIs
"
sessionRule
.
waitForResult
(
result
)
equalTo
(
"
HELLO_FROM_PAGE
"
)
)
sessionRule
.
addExternalDelegateUntilTestEnd
(
WebExtension
.
SessionTabDelegate
:
:
class
{
delegate
-
>
mainSession
.
webExtensionController
.
setTabDelegate
(
extension
delegate
)
}
{
mainSession
.
webExtensionController
.
setTabDelegate
(
extension
null
)
}
object
:
WebExtension
.
SessionTabDelegate
{
}
)
val
unregister
=
sessionRule
.
runtime
.
unregisterWebExtension
(
extension
)
sessionRule
.
waitUntilCalled
(
object
:
WebExtension
.
SessionTabDelegate
{
AssertCalled
override
fun
onCloseTab
(
source
:
WebExtension
?
session
:
GeckoSession
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
source
)
assertEquals
(
mainSession
session
)
return
GeckoResult
.
ALLOW
}
}
)
sessionRule
.
waitForResult
(
unregister
)
}
Test
fun
badFileType
(
)
{
testRegisterError
(
"
resource
:
/
/
android
/
bad
/
location
/
error
"
"
does
not
point
to
a
folder
or
an
.
xpi
"
)
}
Test
fun
badLocationXpi
(
)
{
testRegisterError
(
"
resource
:
/
/
android
/
bad
/
location
/
error
.
xpi
"
"
NS_ERROR_FILE_NOT_FOUND
"
)
}
Test
fun
badLocationFolder
(
)
{
testRegisterError
(
"
resource
:
/
/
android
/
bad
/
location
/
error
/
"
"
NS_ERROR_FILE_NOT_FOUND
"
)
}
private
fun
testRegisterError
(
location
:
String
expectedError
:
String
)
{
try
{
sessionRule
.
waitForResult
(
sessionRule
.
runtime
.
registerWebExtension
(
WebExtension
(
location
controller
)
)
)
}
catch
(
ex
:
Exception
)
{
assertTrue
(
ex
.
message
!
!
.
contains
(
location
)
)
assertTrue
(
ex
.
message
!
!
.
contains
(
expectedError
)
)
return
}
fail
(
"
The
above
code
should
throw
.
"
)
}
Test
fun
update
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
"
extensions
.
install
.
requireBuiltInCerts
"
to
false
"
extensions
.
update
.
requireBuiltInCerts
"
to
false
)
)
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
.
metaData
!
!
.
version
"
1
.
0
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
update1
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
update
-
1
.
xpi
"
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
val
update2
=
sessionRule
.
waitForResult
(
controller
.
update
(
update1
)
)
;
assertEquals
(
update2
.
metaData
!
!
.
version
"
2
.
0
"
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
blue
"
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
update2
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
fun
updateWithPerms
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
"
extensions
.
install
.
requireBuiltInCerts
"
to
false
"
extensions
.
update
.
requireBuiltInCerts
"
to
false
)
)
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
.
metaData
!
!
.
version
"
1
.
0
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
update1
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
update
-
with
-
perms
-
1
.
xpi
"
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onUpdatePrompt
(
currentlyInstalled
:
WebExtension
updatedExtension
:
WebExtension
newPermissions
:
Array
<
String
>
newOrigins
:
Array
<
String
>
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
currentlyInstalled
.
metaData
!
!
.
version
"
1
.
0
"
)
assertEquals
(
updatedExtension
.
metaData
!
!
.
version
"
2
.
0
"
)
assertEquals
(
newPermissions
.
size
1
)
assertEquals
(
newPermissions
[
0
]
"
tabs
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
;
}
}
)
val
update2
=
sessionRule
.
waitForResult
(
controller
.
update
(
update1
)
)
;
assertEquals
(
update2
.
metaData
!
!
.
version
"
2
.
0
"
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
blue
"
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
update2
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
fun
updateNotAvailable
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
"
extensions
.
install
.
requireBuiltInCerts
"
to
false
"
extensions
.
update
.
requireBuiltInCerts
"
to
false
)
)
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
.
metaData
!
!
.
version
"
2
.
0
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
update1
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
update
-
2
.
xpi
"
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
blue
"
)
val
update2
=
sessionRule
.
waitForResult
(
controller
.
update
(
update1
)
)
assertNull
(
update2
)
;
sessionRule
.
waitForResult
(
controller
.
uninstall
(
update1
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
fun
updateDenyPerms
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
"
extensions
.
install
.
requireBuiltInCerts
"
to
false
"
extensions
.
update
.
requireBuiltInCerts
"
to
false
)
)
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
.
metaData
!
!
.
version
"
1
.
0
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
update1
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
update
-
with
-
perms
-
1
.
xpi
"
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onUpdatePrompt
(
currentlyInstalled
:
WebExtension
updatedExtension
:
WebExtension
newPermissions
:
Array
<
String
>
newOrigins
:
Array
<
String
>
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
currentlyInstalled
.
metaData
!
!
.
version
"
1
.
0
"
)
assertEquals
(
updatedExtension
.
metaData
!
!
.
version
"
2
.
0
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
DENY
)
;
}
}
)
sessionRule
.
waitForResult
(
controller
.
update
(
update1
)
.
accept
(
{
assertTrue
(
false
)
}
{
exception
-
>
assertTrue
(
exception
is
WebExtension
.
InstallException
)
val
installException
=
exception
as
WebExtension
.
InstallException
assertEquals
(
installException
.
code
WebExtension
.
InstallException
.
ErrorCodes
.
ERROR_USER_CANCELED
)
}
)
)
;
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
update1
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
}
Test
(
expected
=
CancellationException
:
:
class
)
fun
cancelInstall
(
)
{
val
install
=
controller
.
install
(
"
TEST_ENDPOINT
/
stall
/
test
.
xpi
"
)
val
cancel
=
sessionRule
.
waitForResult
(
install
.
cancel
(
)
)
assertTrue
(
cancel
)
sessionRule
.
waitForResult
(
install
)
}
Test
fun
cancelInstallFailsAfterInstalled
(
)
{
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
var
install
=
controller
.
install
(
"
resource
:
/
/
android
/
assets
/
web_extensions
/
borderify
.
xpi
"
)
;
val
borderify
=
sessionRule
.
waitForResult
(
install
)
val
cancel
=
sessionRule
.
waitForResult
(
install
.
cancel
(
)
)
assertFalse
(
cancel
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
borderify
)
)
}
Test
fun
updatePostpone
(
)
{
sessionRule
.
setPrefsUntilTestEnd
(
mapOf
(
"
xpinstall
.
signatures
.
required
"
to
false
"
extensions
.
install
.
requireBuiltInCerts
"
to
false
"
extensions
.
update
.
requireBuiltInCerts
"
to
false
"
extensions
.
webextensions
.
warnings
-
as
-
errors
"
to
false
)
)
mainSession
.
loadUri
(
"
example
.
com
"
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
"
)
sessionRule
.
delegateDuringNextWait
(
object
:
WebExtensionController
.
PromptDelegate
{
AssertCalled
override
fun
onInstallPrompt
(
extension
:
WebExtension
)
:
GeckoResult
<
AllowOrDeny
>
{
assertEquals
(
extension
.
metaData
!
!
.
version
"
1
.
0
"
)
return
GeckoResult
.
fromValue
(
AllowOrDeny
.
ALLOW
)
}
}
)
val
update1
=
sessionRule
.
waitForResult
(
controller
.
install
(
"
https
:
/
/
example
.
org
/
tests
/
junit
/
update
-
postpone
-
1
.
xpi
"
)
)
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
sessionRule
.
waitForResult
(
controller
.
update
(
update1
)
.
accept
(
{
assertTrue
(
false
)
}
{
exception
-
>
assertTrue
(
exception
is
WebExtension
.
InstallException
)
val
installException
=
exception
as
WebExtension
.
InstallException
assertEquals
(
installException
.
code
WebExtension
.
InstallException
.
ErrorCodes
.
ERROR_POSTPONED
)
}
)
)
;
mainSession
.
reload
(
)
sessionRule
.
waitForPageStop
(
)
assertBodyBorderEqualTo
(
"
red
"
)
sessionRule
.
waitForResult
(
controller
.
uninstall
(
update1
)
)
}
}
