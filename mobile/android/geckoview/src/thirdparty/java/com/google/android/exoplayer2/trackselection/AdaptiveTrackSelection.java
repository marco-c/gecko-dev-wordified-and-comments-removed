package
com
.
google
.
android
.
exoplayer2
.
trackselection
;
import
android
.
os
.
SystemClock
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
MediaChunk
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
BandwidthMeter
;
import
java
.
util
.
List
;
public
class
AdaptiveTrackSelection
extends
BaseTrackSelection
{
public
static
final
class
Factory
implements
TrackSelection
.
Factory
{
private
final
BandwidthMeter
bandwidthMeter
;
private
final
int
maxInitialBitrate
;
private
final
int
minDurationForQualityIncreaseMs
;
private
final
int
maxDurationForQualityDecreaseMs
;
private
final
int
minDurationToRetainAfterDiscardMs
;
private
final
float
bandwidthFraction
;
public
Factory
(
BandwidthMeter
bandwidthMeter
)
{
this
(
bandwidthMeter
DEFAULT_MAX_INITIAL_BITRATE
DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS
DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS
DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS
DEFAULT_BANDWIDTH_FRACTION
)
;
}
public
Factory
(
BandwidthMeter
bandwidthMeter
int
maxInitialBitrate
int
minDurationForQualityIncreaseMs
int
maxDurationForQualityDecreaseMs
int
minDurationToRetainAfterDiscardMs
float
bandwidthFraction
)
{
this
.
bandwidthMeter
=
bandwidthMeter
;
this
.
maxInitialBitrate
=
maxInitialBitrate
;
this
.
minDurationForQualityIncreaseMs
=
minDurationForQualityIncreaseMs
;
this
.
maxDurationForQualityDecreaseMs
=
maxDurationForQualityDecreaseMs
;
this
.
minDurationToRetainAfterDiscardMs
=
minDurationToRetainAfterDiscardMs
;
this
.
bandwidthFraction
=
bandwidthFraction
;
}
Override
public
AdaptiveTrackSelection
createTrackSelection
(
TrackGroup
group
int
.
.
.
tracks
)
{
return
new
AdaptiveTrackSelection
(
group
tracks
bandwidthMeter
maxInitialBitrate
minDurationForQualityIncreaseMs
maxDurationForQualityDecreaseMs
minDurationToRetainAfterDiscardMs
bandwidthFraction
)
;
}
}
public
static
final
int
DEFAULT_MAX_INITIAL_BITRATE
=
800000
;
public
static
final
int
DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS
=
10000
;
public
static
final
int
DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS
=
25000
;
public
static
final
int
DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS
=
25000
;
public
static
final
float
DEFAULT_BANDWIDTH_FRACTION
=
0
.
75f
;
private
final
BandwidthMeter
bandwidthMeter
;
private
final
int
maxInitialBitrate
;
private
final
long
minDurationForQualityIncreaseUs
;
private
final
long
maxDurationForQualityDecreaseUs
;
private
final
long
minDurationToRetainAfterDiscardUs
;
private
final
float
bandwidthFraction
;
private
int
selectedIndex
;
private
int
reason
;
public
AdaptiveTrackSelection
(
TrackGroup
group
int
[
]
tracks
BandwidthMeter
bandwidthMeter
)
{
this
(
group
tracks
bandwidthMeter
DEFAULT_MAX_INITIAL_BITRATE
DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS
DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS
DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS
DEFAULT_BANDWIDTH_FRACTION
)
;
}
public
AdaptiveTrackSelection
(
TrackGroup
group
int
[
]
tracks
BandwidthMeter
bandwidthMeter
int
maxInitialBitrate
long
minDurationForQualityIncreaseMs
long
maxDurationForQualityDecreaseMs
long
minDurationToRetainAfterDiscardMs
float
bandwidthFraction
)
{
super
(
group
tracks
)
;
this
.
bandwidthMeter
=
bandwidthMeter
;
this
.
maxInitialBitrate
=
maxInitialBitrate
;
this
.
minDurationForQualityIncreaseUs
=
minDurationForQualityIncreaseMs
*
1000L
;
this
.
maxDurationForQualityDecreaseUs
=
maxDurationForQualityDecreaseMs
*
1000L
;
this
.
minDurationToRetainAfterDiscardUs
=
minDurationToRetainAfterDiscardMs
*
1000L
;
this
.
bandwidthFraction
=
bandwidthFraction
;
selectedIndex
=
determineIdealSelectedIndex
(
Long
.
MIN_VALUE
)
;
reason
=
C
.
SELECTION_REASON_INITIAL
;
}
Override
public
void
updateSelectedTrack
(
long
bufferedDurationUs
)
{
long
nowMs
=
SystemClock
.
elapsedRealtime
(
)
;
int
currentSelectedIndex
=
selectedIndex
;
Format
currentFormat
=
getSelectedFormat
(
)
;
int
idealSelectedIndex
=
determineIdealSelectedIndex
(
nowMs
)
;
Format
idealFormat
=
getFormat
(
idealSelectedIndex
)
;
selectedIndex
=
idealSelectedIndex
;
if
(
currentFormat
!
=
null
&
&
!
isBlacklisted
(
selectedIndex
nowMs
)
)
{
if
(
idealFormat
.
bitrate
>
currentFormat
.
bitrate
&
&
bufferedDurationUs
<
minDurationForQualityIncreaseUs
)
{
selectedIndex
=
currentSelectedIndex
;
}
else
if
(
idealFormat
.
bitrate
<
currentFormat
.
bitrate
&
&
bufferedDurationUs
>
=
maxDurationForQualityDecreaseUs
)
{
selectedIndex
=
currentSelectedIndex
;
}
}
if
(
selectedIndex
!
=
currentSelectedIndex
)
{
reason
=
C
.
SELECTION_REASON_ADAPTIVE
;
}
}
Override
public
int
getSelectedIndex
(
)
{
return
selectedIndex
;
}
Override
public
int
getSelectionReason
(
)
{
return
reason
;
}
Override
public
Object
getSelectionData
(
)
{
return
null
;
}
Override
public
int
evaluateQueueSize
(
long
playbackPositionUs
List
<
?
extends
MediaChunk
>
queue
)
{
if
(
queue
.
isEmpty
(
)
)
{
return
0
;
}
int
queueSize
=
queue
.
size
(
)
;
long
bufferedDurationUs
=
queue
.
get
(
queueSize
-
1
)
.
endTimeUs
-
playbackPositionUs
;
if
(
bufferedDurationUs
<
minDurationToRetainAfterDiscardUs
)
{
return
queueSize
;
}
int
idealSelectedIndex
=
determineIdealSelectedIndex
(
SystemClock
.
elapsedRealtime
(
)
)
;
Format
idealFormat
=
getFormat
(
idealSelectedIndex
)
;
for
(
int
i
=
0
;
i
<
queueSize
;
i
+
+
)
{
MediaChunk
chunk
=
queue
.
get
(
i
)
;
Format
format
=
chunk
.
trackFormat
;
long
durationBeforeThisChunkUs
=
chunk
.
startTimeUs
-
playbackPositionUs
;
if
(
durationBeforeThisChunkUs
>
=
minDurationToRetainAfterDiscardUs
&
&
format
.
bitrate
<
idealFormat
.
bitrate
&
&
format
.
height
!
=
Format
.
NO_VALUE
&
&
format
.
height
<
720
&
&
format
.
width
!
=
Format
.
NO_VALUE
&
&
format
.
width
<
1280
&
&
format
.
height
<
idealFormat
.
height
)
{
return
i
;
}
}
return
queueSize
;
}
private
int
determineIdealSelectedIndex
(
long
nowMs
)
{
long
bitrateEstimate
=
bandwidthMeter
.
getBitrateEstimate
(
)
;
long
effectiveBitrate
=
bitrateEstimate
=
=
BandwidthMeter
.
NO_ESTIMATE
?
maxInitialBitrate
:
(
long
)
(
bitrateEstimate
*
bandwidthFraction
)
;
int
lowestBitrateNonBlacklistedIndex
=
0
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
nowMs
=
=
Long
.
MIN_VALUE
|
|
!
isBlacklisted
(
i
nowMs
)
)
{
Format
format
=
getFormat
(
i
)
;
if
(
format
.
bitrate
<
=
effectiveBitrate
)
{
return
i
;
}
else
{
lowestBitrateNonBlacklistedIndex
=
i
;
}
}
}
return
lowestBitrateNonBlacklistedIndex
;
}
}
