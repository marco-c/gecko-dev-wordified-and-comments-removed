package
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
android
.
net
.
Uri
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
support
.
annotation
.
Nullable
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSink
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSourceException
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
FileDataSource
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
TeeDataSource
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
.
Cache
.
CacheException
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InterruptedIOException
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
final
class
CacheDataSource
implements
DataSource
{
public
static
final
long
DEFAULT_MAX_CACHE_FILE_SIZE
=
2
*
1024
*
1024
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FLAG_BLOCK_ON_CACHE
FLAG_IGNORE_CACHE_ON_ERROR
FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS
}
)
public
interface
Flags
{
}
public
static
final
int
FLAG_BLOCK_ON_CACHE
=
1
<
<
0
;
public
static
final
int
FLAG_IGNORE_CACHE_ON_ERROR
=
1
<
<
1
;
public
static
final
int
FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS
=
1
<
<
2
;
public
interface
EventListener
{
void
onCachedBytesRead
(
long
cacheSizeBytes
long
cachedBytesRead
)
;
}
private
final
Cache
cache
;
private
final
DataSource
cacheReadDataSource
;
private
final
DataSource
cacheWriteDataSource
;
private
final
DataSource
upstreamDataSource
;
Nullable
private
final
EventListener
eventListener
;
private
final
boolean
blockOnCache
;
private
final
boolean
ignoreCacheOnError
;
private
final
boolean
ignoreCacheForUnsetLengthRequests
;
private
DataSource
currentDataSource
;
private
boolean
currentRequestUnbounded
;
private
Uri
uri
;
private
int
flags
;
private
String
key
;
private
long
readPosition
;
private
long
bytesRemaining
;
private
CacheSpan
lockedSpan
;
private
boolean
seenCacheError
;
private
boolean
currentRequestIgnoresCache
;
private
long
totalCachedBytesRead
;
public
CacheDataSource
(
Cache
cache
DataSource
upstream
Flags
int
flags
)
{
this
(
cache
upstream
flags
DEFAULT_MAX_CACHE_FILE_SIZE
)
;
}
public
CacheDataSource
(
Cache
cache
DataSource
upstream
Flags
int
flags
long
maxCacheFileSize
)
{
this
(
cache
upstream
new
FileDataSource
(
)
new
CacheDataSink
(
cache
maxCacheFileSize
)
flags
null
)
;
}
public
CacheDataSource
(
Cache
cache
DataSource
upstream
DataSource
cacheReadDataSource
DataSink
cacheWriteDataSink
Flags
int
flags
Nullable
EventListener
eventListener
)
{
this
.
cache
=
cache
;
this
.
cacheReadDataSource
=
cacheReadDataSource
;
this
.
blockOnCache
=
(
flags
&
FLAG_BLOCK_ON_CACHE
)
!
=
0
;
this
.
ignoreCacheOnError
=
(
flags
&
FLAG_IGNORE_CACHE_ON_ERROR
)
!
=
0
;
this
.
ignoreCacheForUnsetLengthRequests
=
(
flags
&
FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS
)
!
=
0
;
this
.
upstreamDataSource
=
upstream
;
if
(
cacheWriteDataSink
!
=
null
)
{
this
.
cacheWriteDataSource
=
new
TeeDataSource
(
upstream
cacheWriteDataSink
)
;
}
else
{
this
.
cacheWriteDataSource
=
null
;
}
this
.
eventListener
=
eventListener
;
}
Override
public
long
open
(
DataSpec
dataSpec
)
throws
IOException
{
try
{
uri
=
dataSpec
.
uri
;
flags
=
dataSpec
.
flags
;
key
=
CacheUtil
.
getKey
(
dataSpec
)
;
readPosition
=
dataSpec
.
position
;
currentRequestIgnoresCache
=
(
ignoreCacheOnError
&
&
seenCacheError
)
|
|
(
dataSpec
.
length
=
=
C
.
LENGTH_UNSET
&
&
ignoreCacheForUnsetLengthRequests
)
;
if
(
dataSpec
.
length
!
=
C
.
LENGTH_UNSET
|
|
currentRequestIgnoresCache
)
{
bytesRemaining
=
dataSpec
.
length
;
}
else
{
bytesRemaining
=
cache
.
getContentLength
(
key
)
;
if
(
bytesRemaining
!
=
C
.
LENGTH_UNSET
)
{
bytesRemaining
-
=
dataSpec
.
position
;
if
(
bytesRemaining
<
=
0
)
{
throw
new
DataSourceException
(
DataSourceException
.
POSITION_OUT_OF_RANGE
)
;
}
}
}
openNextSource
(
true
)
;
return
bytesRemaining
;
}
catch
(
IOException
e
)
{
handleBeforeThrow
(
e
)
;
throw
e
;
}
}
Override
public
int
read
(
byte
[
]
buffer
int
offset
int
readLength
)
throws
IOException
{
if
(
readLength
=
=
0
)
{
return
0
;
}
if
(
bytesRemaining
=
=
0
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
try
{
int
bytesRead
=
currentDataSource
.
read
(
buffer
offset
readLength
)
;
if
(
bytesRead
>
=
0
)
{
if
(
currentDataSource
=
=
cacheReadDataSource
)
{
totalCachedBytesRead
+
=
bytesRead
;
}
readPosition
+
=
bytesRead
;
if
(
bytesRemaining
!
=
C
.
LENGTH_UNSET
)
{
bytesRemaining
-
=
bytesRead
;
}
}
else
{
if
(
currentRequestUnbounded
)
{
setContentLength
(
readPosition
)
;
bytesRemaining
=
0
;
}
closeCurrentSource
(
)
;
if
(
bytesRemaining
>
0
|
|
bytesRemaining
=
=
C
.
LENGTH_UNSET
)
{
if
(
openNextSource
(
false
)
)
{
return
read
(
buffer
offset
readLength
)
;
}
}
}
return
bytesRead
;
}
catch
(
IOException
e
)
{
handleBeforeThrow
(
e
)
;
throw
e
;
}
}
Override
public
Uri
getUri
(
)
{
return
currentDataSource
=
=
upstreamDataSource
?
currentDataSource
.
getUri
(
)
:
uri
;
}
Override
public
void
close
(
)
throws
IOException
{
uri
=
null
;
notifyBytesRead
(
)
;
try
{
closeCurrentSource
(
)
;
}
catch
(
IOException
e
)
{
handleBeforeThrow
(
e
)
;
throw
e
;
}
}
private
boolean
openNextSource
(
boolean
initial
)
throws
IOException
{
DataSpec
dataSpec
;
CacheSpan
span
;
if
(
currentRequestIgnoresCache
)
{
span
=
null
;
}
else
if
(
blockOnCache
)
{
try
{
span
=
cache
.
startReadWrite
(
key
readPosition
)
;
}
catch
(
InterruptedException
e
)
{
throw
new
InterruptedIOException
(
)
;
}
}
else
{
span
=
cache
.
startReadWriteNonBlocking
(
key
readPosition
)
;
}
if
(
span
=
=
null
)
{
currentDataSource
=
upstreamDataSource
;
dataSpec
=
new
DataSpec
(
uri
readPosition
bytesRemaining
key
flags
)
;
}
else
if
(
span
.
isCached
)
{
Uri
fileUri
=
Uri
.
fromFile
(
span
.
file
)
;
long
filePosition
=
readPosition
-
span
.
position
;
long
length
=
span
.
length
-
filePosition
;
if
(
bytesRemaining
!
=
C
.
LENGTH_UNSET
)
{
length
=
Math
.
min
(
length
bytesRemaining
)
;
}
dataSpec
=
new
DataSpec
(
fileUri
readPosition
filePosition
length
key
flags
)
;
currentDataSource
=
cacheReadDataSource
;
}
else
{
long
length
;
if
(
span
.
isOpenEnded
(
)
)
{
length
=
bytesRemaining
;
}
else
{
length
=
span
.
length
;
if
(
bytesRemaining
!
=
C
.
LENGTH_UNSET
)
{
length
=
Math
.
min
(
length
bytesRemaining
)
;
}
}
dataSpec
=
new
DataSpec
(
uri
readPosition
length
key
flags
)
;
if
(
cacheWriteDataSource
!
=
null
)
{
currentDataSource
=
cacheWriteDataSource
;
lockedSpan
=
span
;
}
else
{
currentDataSource
=
upstreamDataSource
;
cache
.
releaseHoleSpan
(
span
)
;
}
}
currentRequestUnbounded
=
dataSpec
.
length
=
=
C
.
LENGTH_UNSET
;
boolean
successful
=
false
;
long
currentBytesRemaining
=
0
;
try
{
currentBytesRemaining
=
currentDataSource
.
open
(
dataSpec
)
;
successful
=
true
;
}
catch
(
IOException
e
)
{
if
(
!
initial
&
&
currentRequestUnbounded
)
{
Throwable
cause
=
e
;
while
(
cause
!
=
null
)
{
if
(
cause
instanceof
DataSourceException
)
{
int
reason
=
(
(
DataSourceException
)
cause
)
.
reason
;
if
(
reason
=
=
DataSourceException
.
POSITION_OUT_OF_RANGE
)
{
e
=
null
;
break
;
}
}
cause
=
cause
.
getCause
(
)
;
}
}
if
(
e
!
=
null
)
{
throw
e
;
}
}
if
(
currentRequestUnbounded
&
&
currentBytesRemaining
!
=
C
.
LENGTH_UNSET
)
{
bytesRemaining
=
currentBytesRemaining
;
setContentLength
(
dataSpec
.
position
+
bytesRemaining
)
;
}
return
successful
;
}
private
void
setContentLength
(
long
length
)
throws
IOException
{
if
(
currentDataSource
=
=
cacheWriteDataSource
)
{
cache
.
setContentLength
(
key
length
)
;
}
}
private
void
closeCurrentSource
(
)
throws
IOException
{
if
(
currentDataSource
=
=
null
)
{
return
;
}
try
{
currentDataSource
.
close
(
)
;
currentDataSource
=
null
;
currentRequestUnbounded
=
false
;
}
finally
{
if
(
lockedSpan
!
=
null
)
{
cache
.
releaseHoleSpan
(
lockedSpan
)
;
lockedSpan
=
null
;
}
}
}
private
void
handleBeforeThrow
(
IOException
exception
)
{
if
(
currentDataSource
=
=
cacheReadDataSource
|
|
exception
instanceof
CacheException
)
{
seenCacheError
=
true
;
}
}
private
void
notifyBytesRead
(
)
{
if
(
eventListener
!
=
null
&
&
totalCachedBytesRead
>
0
)
{
eventListener
.
onCachedBytesRead
(
cache
.
getCacheSpace
(
)
totalCachedBytesRead
)
;
totalCachedBytesRead
=
0
;
}
}
}
