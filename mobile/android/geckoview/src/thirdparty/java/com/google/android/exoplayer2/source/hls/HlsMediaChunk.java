package
com
.
google
.
android
.
exoplayer2
.
source
.
hls
;
import
android
.
text
.
TextUtils
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
DefaultExtractorInput
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
.
Mp3Extractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
.
FragmentedMp4Extractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
Ac3Extractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
AdtsExtractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
DefaultTsPayloadReaderFactory
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsExtractor
;
import
com
.
google
.
android
.
exoplayer2
.
metadata
.
Metadata
;
import
com
.
google
.
android
.
exoplayer2
.
metadata
.
id3
.
Id3Decoder
;
import
com
.
google
.
android
.
exoplayer2
.
metadata
.
id3
.
PrivFrame
;
import
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
MediaChunk
;
import
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMasterPlaylist
.
HlsUrl
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
final
class
HlsMediaChunk
extends
MediaChunk
{
private
static
final
AtomicInteger
UID_SOURCE
=
new
AtomicInteger
(
)
;
private
static
final
String
PRIV_TIMESTAMP_FRAME_OWNER
=
"
com
.
apple
.
streaming
.
transportStreamTimestamp
"
;
private
static
final
String
AAC_FILE_EXTENSION
=
"
.
aac
"
;
private
static
final
String
AC3_FILE_EXTENSION
=
"
.
ac3
"
;
private
static
final
String
EC3_FILE_EXTENSION
=
"
.
ec3
"
;
private
static
final
String
MP3_FILE_EXTENSION
=
"
.
mp3
"
;
private
static
final
String
MP4_FILE_EXTENSION
=
"
.
mp4
"
;
private
static
final
String
M4_FILE_EXTENSION_PREFIX
=
"
.
m4
"
;
private
static
final
String
VTT_FILE_EXTENSION
=
"
.
vtt
"
;
private
static
final
String
WEBVTT_FILE_EXTENSION
=
"
.
webvtt
"
;
public
final
int
uid
;
public
final
int
discontinuitySequenceNumber
;
public
final
HlsUrl
hlsUrl
;
private
final
DataSource
initDataSource
;
private
final
DataSpec
initDataSpec
;
private
final
boolean
isEncrypted
;
private
final
boolean
isMasterTimestampSource
;
private
final
TimestampAdjuster
timestampAdjuster
;
private
final
String
lastPathSegment
;
private
final
Extractor
previousExtractor
;
private
final
boolean
shouldSpliceIn
;
private
final
boolean
needNewExtractor
;
private
final
List
<
Format
>
muxedCaptionFormats
;
private
final
boolean
isPackedAudio
;
private
final
Id3Decoder
id3Decoder
;
private
final
ParsableByteArray
id3Data
;
private
Extractor
extractor
;
private
int
initSegmentBytesLoaded
;
private
int
bytesLoaded
;
private
boolean
initLoadCompleted
;
private
HlsSampleStreamWrapper
extractorOutput
;
private
volatile
boolean
loadCanceled
;
private
volatile
boolean
loadCompleted
;
public
HlsMediaChunk
(
DataSource
dataSource
DataSpec
dataSpec
DataSpec
initDataSpec
HlsUrl
hlsUrl
List
<
Format
>
muxedCaptionFormats
int
trackSelectionReason
Object
trackSelectionData
long
startTimeUs
long
endTimeUs
int
chunkIndex
int
discontinuitySequenceNumber
boolean
isMasterTimestampSource
TimestampAdjuster
timestampAdjuster
HlsMediaChunk
previousChunk
byte
[
]
encryptionKey
byte
[
]
encryptionIv
)
{
super
(
buildDataSource
(
dataSource
encryptionKey
encryptionIv
)
dataSpec
hlsUrl
.
format
trackSelectionReason
trackSelectionData
startTimeUs
endTimeUs
chunkIndex
)
;
this
.
discontinuitySequenceNumber
=
discontinuitySequenceNumber
;
this
.
initDataSpec
=
initDataSpec
;
this
.
hlsUrl
=
hlsUrl
;
this
.
muxedCaptionFormats
=
muxedCaptionFormats
;
this
.
isMasterTimestampSource
=
isMasterTimestampSource
;
this
.
timestampAdjuster
=
timestampAdjuster
;
this
.
isEncrypted
=
this
.
dataSource
instanceof
Aes128DataSource
;
lastPathSegment
=
dataSpec
.
uri
.
getLastPathSegment
(
)
;
isPackedAudio
=
lastPathSegment
.
endsWith
(
AAC_FILE_EXTENSION
)
|
|
lastPathSegment
.
endsWith
(
AC3_FILE_EXTENSION
)
|
|
lastPathSegment
.
endsWith
(
EC3_FILE_EXTENSION
)
|
|
lastPathSegment
.
endsWith
(
MP3_FILE_EXTENSION
)
;
if
(
previousChunk
!
=
null
)
{
id3Decoder
=
previousChunk
.
id3Decoder
;
id3Data
=
previousChunk
.
id3Data
;
previousExtractor
=
previousChunk
.
extractor
;
shouldSpliceIn
=
previousChunk
.
hlsUrl
!
=
hlsUrl
;
needNewExtractor
=
previousChunk
.
discontinuitySequenceNumber
!
=
discontinuitySequenceNumber
|
|
shouldSpliceIn
;
}
else
{
id3Decoder
=
isPackedAudio
?
new
Id3Decoder
(
)
:
null
;
id3Data
=
isPackedAudio
?
new
ParsableByteArray
(
Id3Decoder
.
ID3_HEADER_LENGTH
)
:
null
;
previousExtractor
=
null
;
shouldSpliceIn
=
false
;
needNewExtractor
=
true
;
}
initDataSource
=
dataSource
;
uid
=
UID_SOURCE
.
getAndIncrement
(
)
;
}
public
void
init
(
HlsSampleStreamWrapper
output
)
{
extractorOutput
=
output
;
output
.
init
(
uid
shouldSpliceIn
)
;
}
Override
public
boolean
isLoadCompleted
(
)
{
return
loadCompleted
;
}
Override
public
long
bytesLoaded
(
)
{
return
bytesLoaded
;
}
Override
public
void
cancelLoad
(
)
{
loadCanceled
=
true
;
}
Override
public
boolean
isLoadCanceled
(
)
{
return
loadCanceled
;
}
Override
public
void
load
(
)
throws
IOException
InterruptedException
{
if
(
extractor
=
=
null
&
&
!
isPackedAudio
)
{
extractor
=
createExtractor
(
)
;
}
maybeLoadInitData
(
)
;
if
(
!
loadCanceled
)
{
loadMedia
(
)
;
}
}
private
void
maybeLoadInitData
(
)
throws
IOException
InterruptedException
{
if
(
previousExtractor
=
=
extractor
|
|
initLoadCompleted
|
|
initDataSpec
=
=
null
)
{
return
;
}
DataSpec
initSegmentDataSpec
=
Util
.
getRemainderDataSpec
(
initDataSpec
initSegmentBytesLoaded
)
;
try
{
ExtractorInput
input
=
new
DefaultExtractorInput
(
initDataSource
initSegmentDataSpec
.
absoluteStreamPosition
initDataSource
.
open
(
initSegmentDataSpec
)
)
;
try
{
int
result
=
Extractor
.
RESULT_CONTINUE
;
while
(
result
=
=
Extractor
.
RESULT_CONTINUE
&
&
!
loadCanceled
)
{
result
=
extractor
.
read
(
input
null
)
;
}
}
finally
{
initSegmentBytesLoaded
=
(
int
)
(
input
.
getPosition
(
)
-
initDataSpec
.
absoluteStreamPosition
)
;
}
}
finally
{
Util
.
closeQuietly
(
dataSource
)
;
}
initLoadCompleted
=
true
;
}
private
void
loadMedia
(
)
throws
IOException
InterruptedException
{
DataSpec
loadDataSpec
;
boolean
skipLoadedBytes
;
if
(
isEncrypted
)
{
loadDataSpec
=
dataSpec
;
skipLoadedBytes
=
bytesLoaded
!
=
0
;
}
else
{
loadDataSpec
=
Util
.
getRemainderDataSpec
(
dataSpec
bytesLoaded
)
;
skipLoadedBytes
=
false
;
}
if
(
!
isMasterTimestampSource
)
{
timestampAdjuster
.
waitUntilInitialized
(
)
;
}
else
if
(
timestampAdjuster
.
getFirstSampleTimestampUs
(
)
=
=
TimestampAdjuster
.
DO_NOT_OFFSET
)
{
timestampAdjuster
.
setFirstSampleTimestampUs
(
startTimeUs
)
;
}
try
{
ExtractorInput
input
=
new
DefaultExtractorInput
(
dataSource
loadDataSpec
.
absoluteStreamPosition
dataSource
.
open
(
loadDataSpec
)
)
;
if
(
extractor
=
=
null
)
{
long
id3Timestamp
=
peekId3PrivTimestamp
(
input
)
;
extractor
=
buildPackedAudioExtractor
(
id3Timestamp
!
=
C
.
TIME_UNSET
?
timestampAdjuster
.
adjustTsTimestamp
(
id3Timestamp
)
:
startTimeUs
)
;
}
if
(
skipLoadedBytes
)
{
input
.
skipFully
(
bytesLoaded
)
;
}
try
{
int
result
=
Extractor
.
RESULT_CONTINUE
;
while
(
result
=
=
Extractor
.
RESULT_CONTINUE
&
&
!
loadCanceled
)
{
result
=
extractor
.
read
(
input
null
)
;
}
}
finally
{
bytesLoaded
=
(
int
)
(
input
.
getPosition
(
)
-
dataSpec
.
absoluteStreamPosition
)
;
}
}
finally
{
Util
.
closeQuietly
(
dataSource
)
;
}
loadCompleted
=
true
;
}
private
long
peekId3PrivTimestamp
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
input
.
resetPeekPosition
(
)
;
if
(
!
input
.
peekFully
(
id3Data
.
data
0
Id3Decoder
.
ID3_HEADER_LENGTH
true
)
)
{
return
C
.
TIME_UNSET
;
}
id3Data
.
reset
(
Id3Decoder
.
ID3_HEADER_LENGTH
)
;
int
id
=
id3Data
.
readUnsignedInt24
(
)
;
if
(
id
!
=
Id3Decoder
.
ID3_TAG
)
{
return
C
.
TIME_UNSET
;
}
id3Data
.
skipBytes
(
3
)
;
int
id3Size
=
id3Data
.
readSynchSafeInt
(
)
;
int
requiredCapacity
=
id3Size
+
Id3Decoder
.
ID3_HEADER_LENGTH
;
if
(
requiredCapacity
>
id3Data
.
capacity
(
)
)
{
byte
[
]
data
=
id3Data
.
data
;
id3Data
.
reset
(
requiredCapacity
)
;
System
.
arraycopy
(
data
0
id3Data
.
data
0
Id3Decoder
.
ID3_HEADER_LENGTH
)
;
}
if
(
!
input
.
peekFully
(
id3Data
.
data
Id3Decoder
.
ID3_HEADER_LENGTH
id3Size
true
)
)
{
return
C
.
TIME_UNSET
;
}
Metadata
metadata
=
id3Decoder
.
decode
(
id3Data
.
data
id3Size
)
;
if
(
metadata
=
=
null
)
{
return
C
.
TIME_UNSET
;
}
int
metadataLength
=
metadata
.
length
(
)
;
for
(
int
i
=
0
;
i
<
metadataLength
;
i
+
+
)
{
Metadata
.
Entry
frame
=
metadata
.
get
(
i
)
;
if
(
frame
instanceof
PrivFrame
)
{
PrivFrame
privFrame
=
(
PrivFrame
)
frame
;
if
(
PRIV_TIMESTAMP_FRAME_OWNER
.
equals
(
privFrame
.
owner
)
)
{
System
.
arraycopy
(
privFrame
.
privateData
0
id3Data
.
data
0
8
)
;
id3Data
.
reset
(
8
)
;
return
id3Data
.
readLong
(
)
;
}
}
}
return
C
.
TIME_UNSET
;
}
private
static
DataSource
buildDataSource
(
DataSource
dataSource
byte
[
]
encryptionKey
byte
[
]
encryptionIv
)
{
if
(
encryptionKey
=
=
null
|
|
encryptionIv
=
=
null
)
{
return
dataSource
;
}
return
new
Aes128DataSource
(
dataSource
encryptionKey
encryptionIv
)
;
}
private
Extractor
createExtractor
(
)
{
Extractor
extractor
;
boolean
usingNewExtractor
=
true
;
if
(
MimeTypes
.
TEXT_VTT
.
equals
(
hlsUrl
.
format
.
sampleMimeType
)
|
|
lastPathSegment
.
endsWith
(
WEBVTT_FILE_EXTENSION
)
|
|
lastPathSegment
.
endsWith
(
VTT_FILE_EXTENSION
)
)
{
extractor
=
new
WebvttExtractor
(
trackFormat
.
language
timestampAdjuster
)
;
}
else
if
(
!
needNewExtractor
)
{
usingNewExtractor
=
false
;
extractor
=
previousExtractor
;
}
else
if
(
lastPathSegment
.
endsWith
(
MP4_FILE_EXTENSION
)
|
|
lastPathSegment
.
startsWith
(
M4_FILE_EXTENSION_PREFIX
lastPathSegment
.
length
(
)
-
4
)
)
{
extractor
=
new
FragmentedMp4Extractor
(
0
timestampAdjuster
)
;
}
else
{
DefaultTsPayloadReaderFactory
.
Flags
int
esReaderFactoryFlags
=
DefaultTsPayloadReaderFactory
.
FLAG_IGNORE_SPLICE_INFO_STREAM
;
if
(
!
muxedCaptionFormats
.
isEmpty
(
)
)
{
esReaderFactoryFlags
|
=
DefaultTsPayloadReaderFactory
.
FLAG_OVERRIDE_CAPTION_DESCRIPTORS
;
}
String
codecs
=
trackFormat
.
codecs
;
if
(
!
TextUtils
.
isEmpty
(
codecs
)
)
{
if
(
!
MimeTypes
.
AUDIO_AAC
.
equals
(
MimeTypes
.
getAudioMediaMimeType
(
codecs
)
)
)
{
esReaderFactoryFlags
|
=
DefaultTsPayloadReaderFactory
.
FLAG_IGNORE_AAC_STREAM
;
}
if
(
!
MimeTypes
.
VIDEO_H264
.
equals
(
MimeTypes
.
getVideoMediaMimeType
(
codecs
)
)
)
{
esReaderFactoryFlags
|
=
DefaultTsPayloadReaderFactory
.
FLAG_IGNORE_H264_STREAM
;
}
}
extractor
=
new
TsExtractor
(
TsExtractor
.
MODE_HLS
timestampAdjuster
new
DefaultTsPayloadReaderFactory
(
esReaderFactoryFlags
muxedCaptionFormats
)
)
;
}
if
(
usingNewExtractor
)
{
extractor
.
init
(
extractorOutput
)
;
}
return
extractor
;
}
private
Extractor
buildPackedAudioExtractor
(
long
startTimeUs
)
{
Extractor
extractor
;
if
(
lastPathSegment
.
endsWith
(
AAC_FILE_EXTENSION
)
)
{
extractor
=
new
AdtsExtractor
(
startTimeUs
)
;
}
else
if
(
lastPathSegment
.
endsWith
(
AC3_FILE_EXTENSION
)
|
|
lastPathSegment
.
endsWith
(
EC3_FILE_EXTENSION
)
)
{
extractor
=
new
Ac3Extractor
(
startTimeUs
)
;
}
else
if
(
lastPathSegment
.
endsWith
(
MP3_FILE_EXTENSION
)
)
{
extractor
=
new
Mp3Extractor
(
0
startTimeUs
)
;
}
else
{
throw
new
IllegalArgumentException
(
"
Unkown
extension
for
audio
file
:
"
+
lastPathSegment
)
;
}
extractor
.
init
(
extractorOutput
)
;
return
extractor
;
}
}
