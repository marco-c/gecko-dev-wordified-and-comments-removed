package
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
android
.
util
.
Log
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableBitArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
public
final
class
PesReader
implements
TsPayloadReader
{
private
static
final
String
TAG
=
"
PesReader
"
;
private
static
final
int
STATE_FINDING_HEADER
=
0
;
private
static
final
int
STATE_READING_HEADER
=
1
;
private
static
final
int
STATE_READING_HEADER_EXTENSION
=
2
;
private
static
final
int
STATE_READING_BODY
=
3
;
private
static
final
int
HEADER_SIZE
=
9
;
private
static
final
int
MAX_HEADER_EXTENSION_SIZE
=
10
;
private
static
final
int
PES_SCRATCH_SIZE
=
10
;
private
final
ElementaryStreamReader
reader
;
private
final
ParsableBitArray
pesScratch
;
private
int
state
;
private
int
bytesRead
;
private
TimestampAdjuster
timestampAdjuster
;
private
boolean
ptsFlag
;
private
boolean
dtsFlag
;
private
boolean
seenFirstDts
;
private
int
extendedHeaderLength
;
private
int
payloadSize
;
private
boolean
dataAlignmentIndicator
;
private
long
timeUs
;
public
PesReader
(
ElementaryStreamReader
reader
)
{
this
.
reader
=
reader
;
pesScratch
=
new
ParsableBitArray
(
new
byte
[
PES_SCRATCH_SIZE
]
)
;
state
=
STATE_FINDING_HEADER
;
}
Override
public
void
init
(
TimestampAdjuster
timestampAdjuster
ExtractorOutput
extractorOutput
TrackIdGenerator
idGenerator
)
{
this
.
timestampAdjuster
=
timestampAdjuster
;
reader
.
createTracks
(
extractorOutput
idGenerator
)
;
}
Override
public
final
void
seek
(
)
{
state
=
STATE_FINDING_HEADER
;
bytesRead
=
0
;
seenFirstDts
=
false
;
reader
.
seek
(
)
;
}
Override
public
final
void
consume
(
ParsableByteArray
data
boolean
payloadUnitStartIndicator
)
{
if
(
payloadUnitStartIndicator
)
{
switch
(
state
)
{
case
STATE_FINDING_HEADER
:
case
STATE_READING_HEADER
:
break
;
case
STATE_READING_HEADER_EXTENSION
:
Log
.
w
(
TAG
"
Unexpected
start
indicator
reading
extended
header
"
)
;
break
;
case
STATE_READING_BODY
:
if
(
payloadSize
!
=
-
1
)
{
Log
.
w
(
TAG
"
Unexpected
start
indicator
:
expected
"
+
payloadSize
+
"
more
bytes
"
)
;
}
reader
.
packetFinished
(
)
;
break
;
}
setState
(
STATE_READING_HEADER
)
;
}
while
(
data
.
bytesLeft
(
)
>
0
)
{
switch
(
state
)
{
case
STATE_FINDING_HEADER
:
data
.
skipBytes
(
data
.
bytesLeft
(
)
)
;
break
;
case
STATE_READING_HEADER
:
if
(
continueRead
(
data
pesScratch
.
data
HEADER_SIZE
)
)
{
setState
(
parseHeader
(
)
?
STATE_READING_HEADER_EXTENSION
:
STATE_FINDING_HEADER
)
;
}
break
;
case
STATE_READING_HEADER_EXTENSION
:
int
readLength
=
Math
.
min
(
MAX_HEADER_EXTENSION_SIZE
extendedHeaderLength
)
;
if
(
continueRead
(
data
pesScratch
.
data
readLength
)
&
&
continueRead
(
data
null
extendedHeaderLength
)
)
{
parseHeaderExtension
(
)
;
reader
.
packetStarted
(
timeUs
dataAlignmentIndicator
)
;
setState
(
STATE_READING_BODY
)
;
}
break
;
case
STATE_READING_BODY
:
readLength
=
data
.
bytesLeft
(
)
;
int
padding
=
payloadSize
=
=
-
1
?
0
:
readLength
-
payloadSize
;
if
(
padding
>
0
)
{
readLength
-
=
padding
;
data
.
setLimit
(
data
.
getPosition
(
)
+
readLength
)
;
}
reader
.
consume
(
data
)
;
if
(
payloadSize
!
=
-
1
)
{
payloadSize
-
=
readLength
;
if
(
payloadSize
=
=
0
)
{
reader
.
packetFinished
(
)
;
setState
(
STATE_READING_HEADER
)
;
}
}
break
;
}
}
}
private
void
setState
(
int
state
)
{
this
.
state
=
state
;
bytesRead
=
0
;
}
private
boolean
continueRead
(
ParsableByteArray
source
byte
[
]
target
int
targetLength
)
{
int
bytesToRead
=
Math
.
min
(
source
.
bytesLeft
(
)
targetLength
-
bytesRead
)
;
if
(
bytesToRead
<
=
0
)
{
return
true
;
}
else
if
(
target
=
=
null
)
{
source
.
skipBytes
(
bytesToRead
)
;
}
else
{
source
.
readBytes
(
target
bytesRead
bytesToRead
)
;
}
bytesRead
+
=
bytesToRead
;
return
bytesRead
=
=
targetLength
;
}
private
boolean
parseHeader
(
)
{
pesScratch
.
setPosition
(
0
)
;
int
startCodePrefix
=
pesScratch
.
readBits
(
24
)
;
if
(
startCodePrefix
!
=
0x000001
)
{
Log
.
w
(
TAG
"
Unexpected
start
code
prefix
:
"
+
startCodePrefix
)
;
payloadSize
=
-
1
;
return
false
;
}
pesScratch
.
skipBits
(
8
)
;
int
packetLength
=
pesScratch
.
readBits
(
16
)
;
pesScratch
.
skipBits
(
5
)
;
dataAlignmentIndicator
=
pesScratch
.
readBit
(
)
;
pesScratch
.
skipBits
(
2
)
;
ptsFlag
=
pesScratch
.
readBit
(
)
;
dtsFlag
=
pesScratch
.
readBit
(
)
;
pesScratch
.
skipBits
(
6
)
;
extendedHeaderLength
=
pesScratch
.
readBits
(
8
)
;
if
(
packetLength
=
=
0
)
{
payloadSize
=
-
1
;
}
else
{
payloadSize
=
packetLength
+
6
-
HEADER_SIZE
-
extendedHeaderLength
;
}
return
true
;
}
private
void
parseHeaderExtension
(
)
{
pesScratch
.
setPosition
(
0
)
;
timeUs
=
C
.
TIME_UNSET
;
if
(
ptsFlag
)
{
pesScratch
.
skipBits
(
4
)
;
long
pts
=
(
long
)
pesScratch
.
readBits
(
3
)
<
<
30
;
pesScratch
.
skipBits
(
1
)
;
pts
|
=
pesScratch
.
readBits
(
15
)
<
<
15
;
pesScratch
.
skipBits
(
1
)
;
pts
|
=
pesScratch
.
readBits
(
15
)
;
pesScratch
.
skipBits
(
1
)
;
if
(
!
seenFirstDts
&
&
dtsFlag
)
{
pesScratch
.
skipBits
(
4
)
;
long
dts
=
(
long
)
pesScratch
.
readBits
(
3
)
<
<
30
;
pesScratch
.
skipBits
(
1
)
;
dts
|
=
pesScratch
.
readBits
(
15
)
<
<
15
;
pesScratch
.
skipBits
(
1
)
;
dts
|
=
pesScratch
.
readBits
(
15
)
;
pesScratch
.
skipBits
(
1
)
;
timestampAdjuster
.
adjustTsTimestamp
(
dts
)
;
seenFirstDts
=
true
;
}
timeUs
=
timestampAdjuster
.
adjustTsTimestamp
(
pts
)
;
}
}
}
