package
com
.
google
.
android
.
exoplayer2
.
audio
;
import
android
.
media
.
audiofx
.
Virtualizer
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
IntDef
;
import
com
.
google
.
android
.
exoplayer2
.
BaseRenderer
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
com
.
google
.
android
.
exoplayer2
.
PlaybackParameters
;
import
com
.
google
.
android
.
exoplayer2
.
audio
.
AudioRendererEventListener
.
EventDispatcher
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderCounters
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
SimpleDecoder
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
SimpleOutputBuffer
;
import
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
;
import
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
com
.
google
.
android
.
exoplayer2
.
drm
.
ExoMediaCrypto
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MediaClock
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
abstract
class
SimpleDecoderAudioRenderer
extends
BaseRenderer
implements
MediaClock
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
REINITIALIZATION_STATE_NONE
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
}
)
private
interface
ReinitializationState
{
}
private
static
final
int
REINITIALIZATION_STATE_NONE
=
0
;
private
static
final
int
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
=
1
;
private
static
final
int
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
=
2
;
private
final
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
;
private
final
boolean
playClearSamplesWithoutKeys
;
private
final
EventDispatcher
eventDispatcher
;
private
final
AudioTrack
audioTrack
;
private
final
FormatHolder
formatHolder
;
private
final
DecoderInputBuffer
flagsOnlyBuffer
;
private
DecoderCounters
decoderCounters
;
private
Format
inputFormat
;
private
SimpleDecoder
<
DecoderInputBuffer
?
extends
SimpleOutputBuffer
?
extends
AudioDecoderException
>
decoder
;
private
DecoderInputBuffer
inputBuffer
;
private
SimpleOutputBuffer
outputBuffer
;
private
DrmSession
<
ExoMediaCrypto
>
drmSession
;
private
DrmSession
<
ExoMediaCrypto
>
pendingDrmSession
;
ReinitializationState
private
int
decoderReinitializationState
;
private
boolean
decoderReceivedBuffers
;
private
boolean
audioTrackNeedsConfigure
;
private
long
currentPositionUs
;
private
boolean
allowPositionDiscontinuity
;
private
boolean
inputStreamEnded
;
private
boolean
outputStreamEnded
;
private
boolean
waitingForKeys
;
public
SimpleDecoderAudioRenderer
(
)
{
this
(
null
null
)
;
}
public
SimpleDecoderAudioRenderer
(
Handler
eventHandler
AudioRendererEventListener
eventListener
AudioProcessor
.
.
.
audioProcessors
)
{
this
(
eventHandler
eventListener
null
null
false
audioProcessors
)
;
}
public
SimpleDecoderAudioRenderer
(
Handler
eventHandler
AudioRendererEventListener
eventListener
AudioCapabilities
audioCapabilities
)
{
this
(
eventHandler
eventListener
audioCapabilities
null
false
)
;
}
public
SimpleDecoderAudioRenderer
(
Handler
eventHandler
AudioRendererEventListener
eventListener
AudioCapabilities
audioCapabilities
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
AudioProcessor
.
.
.
audioProcessors
)
{
super
(
C
.
TRACK_TYPE_AUDIO
)
;
this
.
drmSessionManager
=
drmSessionManager
;
this
.
playClearSamplesWithoutKeys
=
playClearSamplesWithoutKeys
;
eventDispatcher
=
new
EventDispatcher
(
eventHandler
eventListener
)
;
audioTrack
=
new
AudioTrack
(
audioCapabilities
audioProcessors
new
AudioTrackListener
(
)
)
;
formatHolder
=
new
FormatHolder
(
)
;
flagsOnlyBuffer
=
DecoderInputBuffer
.
newFlagsOnlyInstance
(
)
;
decoderReinitializationState
=
REINITIALIZATION_STATE_NONE
;
audioTrackNeedsConfigure
=
true
;
}
Override
public
MediaClock
getMediaClock
(
)
{
return
this
;
}
Override
public
final
int
supportsFormat
(
Format
format
)
{
int
formatSupport
=
supportsFormatInternal
(
format
)
;
if
(
formatSupport
=
=
FORMAT_UNSUPPORTED_TYPE
|
|
formatSupport
=
=
FORMAT_UNSUPPORTED_SUBTYPE
)
{
return
formatSupport
;
}
int
tunnelingSupport
=
Util
.
SDK_INT
>
=
21
?
TUNNELING_SUPPORTED
:
TUNNELING_NOT_SUPPORTED
;
return
ADAPTIVE_NOT_SEAMLESS
|
tunnelingSupport
|
formatSupport
;
}
protected
abstract
int
supportsFormatInternal
(
Format
format
)
;
Override
public
void
render
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
{
if
(
outputStreamEnded
)
{
try
{
audioTrack
.
playToEndOfStream
(
)
;
}
catch
(
AudioTrack
.
WriteException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
return
;
}
if
(
inputFormat
=
=
null
)
{
flagsOnlyBuffer
.
clear
(
)
;
int
result
=
readSource
(
formatHolder
flagsOnlyBuffer
true
)
;
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
.
format
)
;
}
else
if
(
result
=
=
C
.
RESULT_BUFFER_READ
)
{
Assertions
.
checkState
(
flagsOnlyBuffer
.
isEndOfStream
(
)
)
;
inputStreamEnded
=
true
;
processEndOfStream
(
)
;
return
;
}
else
{
return
;
}
}
maybeInitDecoder
(
)
;
if
(
decoder
!
=
null
)
{
try
{
TraceUtil
.
beginSection
(
"
drainAndFeed
"
)
;
while
(
drainOutputBuffer
(
)
)
{
}
while
(
feedInputBuffer
(
)
)
{
}
TraceUtil
.
endSection
(
)
;
}
catch
(
AudioDecoderException
|
AudioTrack
.
ConfigurationException
|
AudioTrack
.
InitializationException
|
AudioTrack
.
WriteException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
decoderCounters
.
ensureUpdated
(
)
;
}
}
protected
void
onAudioSessionId
(
int
audioSessionId
)
{
}
protected
void
onAudioTrackPositionDiscontinuity
(
)
{
}
protected
void
onAudioTrackUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
}
protected
abstract
SimpleDecoder
<
DecoderInputBuffer
?
extends
SimpleOutputBuffer
?
extends
AudioDecoderException
>
createDecoder
(
Format
format
ExoMediaCrypto
mediaCrypto
)
throws
AudioDecoderException
;
protected
Format
getOutputFormat
(
)
{
return
Format
.
createAudioSampleFormat
(
null
MimeTypes
.
AUDIO_RAW
null
Format
.
NO_VALUE
Format
.
NO_VALUE
inputFormat
.
channelCount
inputFormat
.
sampleRate
C
.
ENCODING_PCM_16BIT
null
null
0
null
)
;
}
private
boolean
drainOutputBuffer
(
)
throws
ExoPlaybackException
AudioDecoderException
AudioTrack
.
ConfigurationException
AudioTrack
.
InitializationException
AudioTrack
.
WriteException
{
if
(
outputBuffer
=
=
null
)
{
outputBuffer
=
decoder
.
dequeueOutputBuffer
(
)
;
if
(
outputBuffer
=
=
null
)
{
return
false
;
}
decoderCounters
.
skippedOutputBufferCount
+
=
outputBuffer
.
skippedOutputBufferCount
;
}
if
(
outputBuffer
.
isEndOfStream
(
)
)
{
if
(
decoderReinitializationState
=
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
)
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
audioTrackNeedsConfigure
=
true
;
}
else
{
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
processEndOfStream
(
)
;
}
return
false
;
}
if
(
audioTrackNeedsConfigure
)
{
Format
outputFormat
=
getOutputFormat
(
)
;
audioTrack
.
configure
(
outputFormat
.
sampleMimeType
outputFormat
.
channelCount
outputFormat
.
sampleRate
outputFormat
.
pcmEncoding
0
)
;
audioTrackNeedsConfigure
=
false
;
}
if
(
audioTrack
.
handleBuffer
(
outputBuffer
.
data
outputBuffer
.
timeUs
)
)
{
decoderCounters
.
renderedOutputBufferCount
+
+
;
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
return
true
;
}
return
false
;
}
private
boolean
feedInputBuffer
(
)
throws
AudioDecoderException
ExoPlaybackException
{
if
(
decoder
=
=
null
|
|
decoderReinitializationState
=
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
|
|
inputStreamEnded
)
{
return
false
;
}
if
(
inputBuffer
=
=
null
)
{
inputBuffer
=
decoder
.
dequeueInputBuffer
(
)
;
if
(
inputBuffer
=
=
null
)
{
return
false
;
}
}
if
(
decoderReinitializationState
=
=
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
)
{
inputBuffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
inputBuffer
=
null
;
decoderReinitializationState
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
;
return
false
;
}
int
result
;
if
(
waitingForKeys
)
{
result
=
C
.
RESULT_BUFFER_READ
;
}
else
{
result
=
readSource
(
formatHolder
inputBuffer
false
)
;
}
if
(
result
=
=
C
.
RESULT_NOTHING_READ
)
{
return
false
;
}
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
.
format
)
;
return
true
;
}
if
(
inputBuffer
.
isEndOfStream
(
)
)
{
inputStreamEnded
=
true
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
inputBuffer
=
null
;
return
false
;
}
boolean
bufferEncrypted
=
inputBuffer
.
isEncrypted
(
)
;
waitingForKeys
=
shouldWaitForKeys
(
bufferEncrypted
)
;
if
(
waitingForKeys
)
{
return
false
;
}
inputBuffer
.
flip
(
)
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
decoderReceivedBuffers
=
true
;
decoderCounters
.
inputBufferCount
+
+
;
inputBuffer
=
null
;
return
true
;
}
private
boolean
shouldWaitForKeys
(
boolean
bufferEncrypted
)
throws
ExoPlaybackException
{
if
(
drmSession
=
=
null
)
{
return
false
;
}
DrmSession
.
State
int
drmSessionState
=
drmSession
.
getState
(
)
;
if
(
drmSessionState
=
=
DrmSession
.
STATE_ERROR
)
{
throw
ExoPlaybackException
.
createForRenderer
(
drmSession
.
getError
(
)
getIndex
(
)
)
;
}
return
drmSessionState
!
=
DrmSession
.
STATE_OPENED_WITH_KEYS
&
&
(
bufferEncrypted
|
|
!
playClearSamplesWithoutKeys
)
;
}
private
void
processEndOfStream
(
)
throws
ExoPlaybackException
{
outputStreamEnded
=
true
;
try
{
audioTrack
.
playToEndOfStream
(
)
;
}
catch
(
AudioTrack
.
WriteException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
drmSession
.
getError
(
)
getIndex
(
)
)
;
}
}
private
void
flushDecoder
(
)
throws
ExoPlaybackException
{
waitingForKeys
=
false
;
if
(
decoderReinitializationState
!
=
REINITIALIZATION_STATE_NONE
)
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
}
else
{
inputBuffer
=
null
;
if
(
outputBuffer
!
=
null
)
{
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
}
decoder
.
flush
(
)
;
decoderReceivedBuffers
=
false
;
}
}
Override
public
boolean
isEnded
(
)
{
return
outputStreamEnded
&
&
audioTrack
.
isEnded
(
)
;
}
Override
public
boolean
isReady
(
)
{
return
audioTrack
.
hasPendingData
(
)
|
|
(
inputFormat
!
=
null
&
&
!
waitingForKeys
&
&
(
isSourceReady
(
)
|
|
outputBuffer
!
=
null
)
)
;
}
Override
public
long
getPositionUs
(
)
{
long
newCurrentPositionUs
=
audioTrack
.
getCurrentPositionUs
(
isEnded
(
)
)
;
if
(
newCurrentPositionUs
!
=
AudioTrack
.
CURRENT_POSITION_NOT_SET
)
{
currentPositionUs
=
allowPositionDiscontinuity
?
newCurrentPositionUs
:
Math
.
max
(
currentPositionUs
newCurrentPositionUs
)
;
allowPositionDiscontinuity
=
false
;
}
return
currentPositionUs
;
}
Override
public
PlaybackParameters
setPlaybackParameters
(
PlaybackParameters
playbackParameters
)
{
return
audioTrack
.
setPlaybackParameters
(
playbackParameters
)
;
}
Override
public
PlaybackParameters
getPlaybackParameters
(
)
{
return
audioTrack
.
getPlaybackParameters
(
)
;
}
Override
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
decoderCounters
=
new
DecoderCounters
(
)
;
eventDispatcher
.
enabled
(
decoderCounters
)
;
int
tunnelingAudioSessionId
=
getConfiguration
(
)
.
tunnelingAudioSessionId
;
if
(
tunnelingAudioSessionId
!
=
C
.
AUDIO_SESSION_ID_UNSET
)
{
audioTrack
.
enableTunnelingV21
(
tunnelingAudioSessionId
)
;
}
else
{
audioTrack
.
disableTunneling
(
)
;
}
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
audioTrack
.
reset
(
)
;
currentPositionUs
=
positionUs
;
allowPositionDiscontinuity
=
true
;
inputStreamEnded
=
false
;
outputStreamEnded
=
false
;
if
(
decoder
!
=
null
)
{
flushDecoder
(
)
;
}
}
Override
protected
void
onStarted
(
)
{
audioTrack
.
play
(
)
;
}
Override
protected
void
onStopped
(
)
{
audioTrack
.
pause
(
)
;
}
Override
protected
void
onDisabled
(
)
{
inputFormat
=
null
;
audioTrackNeedsConfigure
=
true
;
waitingForKeys
=
false
;
try
{
releaseDecoder
(
)
;
audioTrack
.
release
(
)
;
}
finally
{
try
{
if
(
drmSession
!
=
null
)
{
drmSessionManager
.
releaseSession
(
drmSession
)
;
}
}
finally
{
try
{
if
(
pendingDrmSession
!
=
null
&
&
pendingDrmSession
!
=
drmSession
)
{
drmSessionManager
.
releaseSession
(
pendingDrmSession
)
;
}
}
finally
{
drmSession
=
null
;
pendingDrmSession
=
null
;
decoderCounters
.
ensureUpdated
(
)
;
eventDispatcher
.
disabled
(
decoderCounters
)
;
}
}
}
}
private
void
maybeInitDecoder
(
)
throws
ExoPlaybackException
{
if
(
decoder
!
=
null
)
{
return
;
}
drmSession
=
pendingDrmSession
;
ExoMediaCrypto
mediaCrypto
=
null
;
if
(
drmSession
!
=
null
)
{
DrmSession
.
State
int
drmSessionState
=
drmSession
.
getState
(
)
;
if
(
drmSessionState
=
=
DrmSession
.
STATE_ERROR
)
{
throw
ExoPlaybackException
.
createForRenderer
(
drmSession
.
getError
(
)
getIndex
(
)
)
;
}
else
if
(
drmSessionState
=
=
DrmSession
.
STATE_OPENED
|
|
drmSessionState
=
=
DrmSession
.
STATE_OPENED_WITH_KEYS
)
{
mediaCrypto
=
drmSession
.
getMediaCrypto
(
)
;
}
else
{
return
;
}
}
try
{
long
codecInitializingTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
TraceUtil
.
beginSection
(
"
createAudioDecoder
"
)
;
decoder
=
createDecoder
(
inputFormat
mediaCrypto
)
;
TraceUtil
.
endSection
(
)
;
long
codecInitializedTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
eventDispatcher
.
decoderInitialized
(
decoder
.
getName
(
)
codecInitializedTimestamp
codecInitializedTimestamp
-
codecInitializingTimestamp
)
;
decoderCounters
.
decoderInitCount
+
+
;
}
catch
(
AudioDecoderException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
}
private
void
releaseDecoder
(
)
{
if
(
decoder
=
=
null
)
{
return
;
}
inputBuffer
=
null
;
outputBuffer
=
null
;
decoder
.
release
(
)
;
decoder
=
null
;
decoderCounters
.
decoderReleaseCount
+
+
;
decoderReinitializationState
=
REINITIALIZATION_STATE_NONE
;
decoderReceivedBuffers
=
false
;
}
private
void
onInputFormatChanged
(
Format
newFormat
)
throws
ExoPlaybackException
{
Format
oldFormat
=
inputFormat
;
inputFormat
=
newFormat
;
boolean
drmInitDataChanged
=
!
Util
.
areEqual
(
inputFormat
.
drmInitData
oldFormat
=
=
null
?
null
:
oldFormat
.
drmInitData
)
;
if
(
drmInitDataChanged
)
{
if
(
inputFormat
.
drmInitData
!
=
null
)
{
if
(
drmSessionManager
=
=
null
)
{
throw
ExoPlaybackException
.
createForRenderer
(
new
IllegalStateException
(
"
Media
requires
a
DrmSessionManager
"
)
getIndex
(
)
)
;
}
pendingDrmSession
=
drmSessionManager
.
acquireSession
(
Looper
.
myLooper
(
)
inputFormat
.
drmInitData
)
;
if
(
pendingDrmSession
=
=
drmSession
)
{
drmSessionManager
.
releaseSession
(
pendingDrmSession
)
;
}
}
else
{
pendingDrmSession
=
null
;
}
}
if
(
decoderReceivedBuffers
)
{
decoderReinitializationState
=
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
;
}
else
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
audioTrackNeedsConfigure
=
true
;
}
eventDispatcher
.
inputFormatChanged
(
newFormat
)
;
}
Override
public
void
handleMessage
(
int
messageType
Object
message
)
throws
ExoPlaybackException
{
switch
(
messageType
)
{
case
C
.
MSG_SET_VOLUME
:
audioTrack
.
setVolume
(
(
Float
)
message
)
;
break
;
case
C
.
MSG_SET_STREAM_TYPE
:
C
.
StreamType
int
streamType
=
(
Integer
)
message
;
audioTrack
.
setStreamType
(
streamType
)
;
break
;
default
:
super
.
handleMessage
(
messageType
message
)
;
break
;
}
}
private
final
class
AudioTrackListener
implements
AudioTrack
.
Listener
{
Override
public
void
onAudioSessionId
(
int
audioSessionId
)
{
eventDispatcher
.
audioSessionId
(
audioSessionId
)
;
SimpleDecoderAudioRenderer
.
this
.
onAudioSessionId
(
audioSessionId
)
;
}
Override
public
void
onPositionDiscontinuity
(
)
{
onAudioTrackPositionDiscontinuity
(
)
;
SimpleDecoderAudioRenderer
.
this
.
allowPositionDiscontinuity
=
true
;
}
Override
public
void
onUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
eventDispatcher
.
audioTrackUnderrun
(
bufferSize
bufferSizeMs
elapsedSinceLastFeedMs
)
;
onAudioTrackUnderrun
(
bufferSize
bufferSizeMs
elapsedSinceLastFeedMs
)
;
}
}
}
