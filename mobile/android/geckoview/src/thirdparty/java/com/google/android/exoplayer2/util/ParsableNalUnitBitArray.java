package
com
.
google
.
android
.
exoplayer2
.
util
;
public
final
class
ParsableNalUnitBitArray
{
private
byte
[
]
data
;
private
int
byteLimit
;
private
int
byteOffset
;
private
int
bitOffset
;
public
ParsableNalUnitBitArray
(
byte
[
]
data
int
offset
int
limit
)
{
reset
(
data
offset
limit
)
;
}
public
void
reset
(
byte
[
]
data
int
offset
int
limit
)
{
this
.
data
=
data
;
byteOffset
=
offset
;
byteLimit
=
limit
;
bitOffset
=
0
;
assertValidOffset
(
)
;
}
public
void
skipBits
(
int
n
)
{
int
oldByteOffset
=
byteOffset
;
byteOffset
+
=
(
n
/
8
)
;
bitOffset
+
=
(
n
%
8
)
;
if
(
bitOffset
>
7
)
{
byteOffset
+
+
;
bitOffset
-
=
8
;
}
for
(
int
i
=
oldByteOffset
+
1
;
i
<
=
byteOffset
;
i
+
+
)
{
if
(
shouldSkipByte
(
i
)
)
{
byteOffset
+
+
;
i
+
=
2
;
}
}
assertValidOffset
(
)
;
}
public
boolean
canReadBits
(
int
n
)
{
int
oldByteOffset
=
byteOffset
;
int
newByteOffset
=
byteOffset
+
(
n
/
8
)
;
int
newBitOffset
=
bitOffset
+
(
n
%
8
)
;
if
(
newBitOffset
>
7
)
{
newByteOffset
+
+
;
newBitOffset
-
=
8
;
}
for
(
int
i
=
oldByteOffset
+
1
;
i
<
=
newByteOffset
&
&
newByteOffset
<
byteLimit
;
i
+
+
)
{
if
(
shouldSkipByte
(
i
)
)
{
newByteOffset
+
+
;
i
+
=
2
;
}
}
return
newByteOffset
<
byteLimit
|
|
(
newByteOffset
=
=
byteLimit
&
&
newBitOffset
=
=
0
)
;
}
public
boolean
readBit
(
)
{
return
readBits
(
1
)
=
=
1
;
}
public
int
readBits
(
int
numBits
)
{
if
(
numBits
=
=
0
)
{
return
0
;
}
int
returnValue
=
0
;
int
wholeBytes
=
(
numBits
/
8
)
;
for
(
int
i
=
0
;
i
<
wholeBytes
;
i
+
+
)
{
int
nextByteOffset
=
shouldSkipByte
(
byteOffset
+
1
)
?
byteOffset
+
2
:
byteOffset
+
1
;
int
byteValue
;
if
(
bitOffset
!
=
0
)
{
byteValue
=
(
(
data
[
byteOffset
]
&
0xFF
)
<
<
bitOffset
)
|
(
(
data
[
nextByteOffset
]
&
0xFF
)
>
>
>
(
8
-
bitOffset
)
)
;
}
else
{
byteValue
=
data
[
byteOffset
]
;
}
numBits
-
=
8
;
returnValue
|
=
(
byteValue
&
0xFF
)
<
<
numBits
;
byteOffset
=
nextByteOffset
;
}
if
(
numBits
>
0
)
{
int
nextBit
=
bitOffset
+
numBits
;
byte
writeMask
=
(
byte
)
(
0xFF
>
>
(
8
-
numBits
)
)
;
int
nextByteOffset
=
shouldSkipByte
(
byteOffset
+
1
)
?
byteOffset
+
2
:
byteOffset
+
1
;
if
(
nextBit
>
8
)
{
returnValue
|
=
(
(
(
(
data
[
byteOffset
]
&
0xFF
)
<
<
(
nextBit
-
8
)
|
(
(
data
[
nextByteOffset
]
&
0xFF
)
>
>
(
16
-
nextBit
)
)
)
&
writeMask
)
)
;
byteOffset
=
nextByteOffset
;
}
else
{
returnValue
|
=
(
(
(
data
[
byteOffset
]
&
0xFF
)
>
>
(
8
-
nextBit
)
)
&
writeMask
)
;
if
(
nextBit
=
=
8
)
{
byteOffset
=
nextByteOffset
;
}
}
bitOffset
=
nextBit
%
8
;
}
assertValidOffset
(
)
;
return
returnValue
;
}
public
boolean
canReadExpGolombCodedNum
(
)
{
int
initialByteOffset
=
byteOffset
;
int
initialBitOffset
=
bitOffset
;
int
leadingZeros
=
0
;
while
(
byteOffset
<
byteLimit
&
&
!
readBit
(
)
)
{
leadingZeros
+
+
;
}
boolean
hitLimit
=
byteOffset
=
=
byteLimit
;
byteOffset
=
initialByteOffset
;
bitOffset
=
initialBitOffset
;
return
!
hitLimit
&
&
canReadBits
(
leadingZeros
*
2
+
1
)
;
}
public
int
readUnsignedExpGolombCodedInt
(
)
{
return
readExpGolombCodeNum
(
)
;
}
public
int
readSignedExpGolombCodedInt
(
)
{
int
codeNum
=
readExpGolombCodeNum
(
)
;
return
(
(
codeNum
%
2
)
=
=
0
?
-
1
:
1
)
*
(
(
codeNum
+
1
)
/
2
)
;
}
private
int
readExpGolombCodeNum
(
)
{
int
leadingZeros
=
0
;
while
(
!
readBit
(
)
)
{
leadingZeros
+
+
;
}
return
(
1
<
<
leadingZeros
)
-
1
+
(
leadingZeros
>
0
?
readBits
(
leadingZeros
)
:
0
)
;
}
private
boolean
shouldSkipByte
(
int
offset
)
{
return
2
<
=
offset
&
&
offset
<
byteLimit
&
&
data
[
offset
]
=
=
(
byte
)
0x03
&
&
data
[
offset
-
2
]
=
=
(
byte
)
0x00
&
&
data
[
offset
-
1
]
=
=
(
byte
)
0x00
;
}
private
void
assertValidOffset
(
)
{
Assertions
.
checkState
(
byteOffset
>
=
0
&
&
(
bitOffset
>
=
0
&
&
bitOffset
<
8
)
&
&
(
byteOffset
<
byteLimit
|
|
(
byteOffset
=
=
byteLimit
&
&
bitOffset
=
=
0
)
)
)
;
}
}
