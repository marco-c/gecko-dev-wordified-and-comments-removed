package
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
final
class
Sniffer
{
private
static
final
int
SEARCH_LENGTH
=
4
*
1024
;
private
static
final
int
[
]
COMPATIBLE_BRANDS
=
new
int
[
]
{
Util
.
getIntegerCodeForString
(
"
isom
"
)
Util
.
getIntegerCodeForString
(
"
iso2
"
)
Util
.
getIntegerCodeForString
(
"
iso3
"
)
Util
.
getIntegerCodeForString
(
"
iso4
"
)
Util
.
getIntegerCodeForString
(
"
iso5
"
)
Util
.
getIntegerCodeForString
(
"
iso6
"
)
Util
.
getIntegerCodeForString
(
"
avc1
"
)
Util
.
getIntegerCodeForString
(
"
hvc1
"
)
Util
.
getIntegerCodeForString
(
"
hev1
"
)
Util
.
getIntegerCodeForString
(
"
mp41
"
)
Util
.
getIntegerCodeForString
(
"
mp42
"
)
Util
.
getIntegerCodeForString
(
"
3g2a
"
)
Util
.
getIntegerCodeForString
(
"
3g2b
"
)
Util
.
getIntegerCodeForString
(
"
3gr6
"
)
Util
.
getIntegerCodeForString
(
"
3gs6
"
)
Util
.
getIntegerCodeForString
(
"
3ge6
"
)
Util
.
getIntegerCodeForString
(
"
3gg6
"
)
Util
.
getIntegerCodeForString
(
"
M4V
"
)
Util
.
getIntegerCodeForString
(
"
M4A
"
)
Util
.
getIntegerCodeForString
(
"
f4v
"
)
Util
.
getIntegerCodeForString
(
"
kddi
"
)
Util
.
getIntegerCodeForString
(
"
M4VP
"
)
Util
.
getIntegerCodeForString
(
"
qt
"
)
Util
.
getIntegerCodeForString
(
"
MSNV
"
)
}
;
public
static
boolean
sniffFragmented
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
sniffInternal
(
input
true
)
;
}
public
static
boolean
sniffUnfragmented
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
sniffInternal
(
input
false
)
;
}
private
static
boolean
sniffInternal
(
ExtractorInput
input
boolean
fragmented
)
throws
IOException
InterruptedException
{
long
inputLength
=
input
.
getLength
(
)
;
int
bytesToSearch
=
(
int
)
(
inputLength
=
=
C
.
LENGTH_UNSET
|
|
inputLength
>
SEARCH_LENGTH
?
SEARCH_LENGTH
:
inputLength
)
;
ParsableByteArray
buffer
=
new
ParsableByteArray
(
64
)
;
int
bytesSearched
=
0
;
boolean
foundGoodFileType
=
false
;
boolean
isFragmented
=
false
;
while
(
bytesSearched
<
bytesToSearch
)
{
int
headerSize
=
Atom
.
HEADER_SIZE
;
buffer
.
reset
(
headerSize
)
;
input
.
peekFully
(
buffer
.
data
0
headerSize
)
;
long
atomSize
=
buffer
.
readUnsignedInt
(
)
;
int
atomType
=
buffer
.
readInt
(
)
;
if
(
atomSize
=
=
Atom
.
LONG_SIZE_PREFIX
)
{
headerSize
=
Atom
.
LONG_HEADER_SIZE
;
input
.
peekFully
(
buffer
.
data
Atom
.
HEADER_SIZE
Atom
.
LONG_HEADER_SIZE
-
Atom
.
HEADER_SIZE
)
;
buffer
.
setLimit
(
Atom
.
LONG_HEADER_SIZE
)
;
atomSize
=
buffer
.
readUnsignedLongToLong
(
)
;
}
if
(
atomSize
<
headerSize
)
{
return
false
;
}
bytesSearched
+
=
headerSize
;
if
(
atomType
=
=
Atom
.
TYPE_moov
)
{
continue
;
}
if
(
atomType
=
=
Atom
.
TYPE_moof
|
|
atomType
=
=
Atom
.
TYPE_mvex
)
{
isFragmented
=
true
;
break
;
}
if
(
bytesSearched
+
atomSize
-
headerSize
>
=
bytesToSearch
)
{
break
;
}
int
atomDataSize
=
(
int
)
(
atomSize
-
headerSize
)
;
bytesSearched
+
=
atomDataSize
;
if
(
atomType
=
=
Atom
.
TYPE_ftyp
)
{
if
(
atomDataSize
<
8
)
{
return
false
;
}
buffer
.
reset
(
atomDataSize
)
;
input
.
peekFully
(
buffer
.
data
0
atomDataSize
)
;
int
brandsCount
=
atomDataSize
/
4
;
for
(
int
i
=
0
;
i
<
brandsCount
;
i
+
+
)
{
if
(
i
=
=
1
)
{
buffer
.
skipBytes
(
4
)
;
}
else
if
(
isCompatibleBrand
(
buffer
.
readInt
(
)
)
)
{
foundGoodFileType
=
true
;
break
;
}
}
if
(
!
foundGoodFileType
)
{
return
false
;
}
}
else
if
(
atomDataSize
!
=
0
)
{
input
.
advancePeekPosition
(
atomDataSize
)
;
}
}
return
foundGoodFileType
&
&
fragmented
=
=
isFragmented
;
}
private
static
boolean
isCompatibleBrand
(
int
brand
)
{
if
(
brand
>
>
>
8
=
=
Util
.
getIntegerCodeForString
(
"
3gp
"
)
)
{
return
true
;
}
for
(
int
compatibleBrand
:
COMPATIBLE_BRANDS
)
{
if
(
compatibleBrand
=
=
brand
)
{
return
true
;
}
}
return
false
;
}
private
Sniffer
(
)
{
}
}
