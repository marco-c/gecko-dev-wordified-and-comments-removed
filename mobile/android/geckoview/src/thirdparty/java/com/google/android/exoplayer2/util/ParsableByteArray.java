package
com
.
google
.
android
.
exoplayer2
.
util
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
charset
.
Charset
;
public
final
class
ParsableByteArray
{
public
byte
[
]
data
;
private
int
position
;
private
int
limit
;
public
ParsableByteArray
(
)
{
}
public
ParsableByteArray
(
int
limit
)
{
this
.
data
=
new
byte
[
limit
]
;
this
.
limit
=
limit
;
}
public
ParsableByteArray
(
byte
[
]
data
)
{
this
.
data
=
data
;
limit
=
data
.
length
;
}
public
ParsableByteArray
(
byte
[
]
data
int
limit
)
{
this
.
data
=
data
;
this
.
limit
=
limit
;
}
public
void
reset
(
int
limit
)
{
reset
(
capacity
(
)
<
limit
?
new
byte
[
limit
]
:
data
limit
)
;
}
public
void
reset
(
byte
[
]
data
int
limit
)
{
this
.
data
=
data
;
this
.
limit
=
limit
;
position
=
0
;
}
public
void
reset
(
)
{
position
=
0
;
limit
=
0
;
}
public
int
bytesLeft
(
)
{
return
limit
-
position
;
}
public
int
limit
(
)
{
return
limit
;
}
public
void
setLimit
(
int
limit
)
{
Assertions
.
checkArgument
(
limit
>
=
0
&
&
limit
<
=
data
.
length
)
;
this
.
limit
=
limit
;
}
public
int
getPosition
(
)
{
return
position
;
}
public
int
capacity
(
)
{
return
data
=
=
null
?
0
:
data
.
length
;
}
public
void
setPosition
(
int
position
)
{
Assertions
.
checkArgument
(
position
>
=
0
&
&
position
<
=
limit
)
;
this
.
position
=
position
;
}
public
void
skipBytes
(
int
bytes
)
{
setPosition
(
position
+
bytes
)
;
}
public
void
readBytes
(
ParsableBitArray
bitArray
int
length
)
{
readBytes
(
bitArray
.
data
0
length
)
;
bitArray
.
setPosition
(
0
)
;
}
public
void
readBytes
(
byte
[
]
buffer
int
offset
int
length
)
{
System
.
arraycopy
(
data
position
buffer
offset
length
)
;
position
+
=
length
;
}
public
void
readBytes
(
ByteBuffer
buffer
int
length
)
{
buffer
.
put
(
data
position
length
)
;
position
+
=
length
;
}
public
int
peekUnsignedByte
(
)
{
return
(
data
[
position
]
&
0xFF
)
;
}
public
char
peekChar
(
)
{
return
(
char
)
(
(
data
[
position
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
1
]
&
0xFF
)
)
;
}
public
int
readUnsignedByte
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
;
}
public
int
readUnsignedShort
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
;
}
public
int
readLittleEndianUnsignedShort
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
;
}
public
short
readShort
(
)
{
return
(
short
)
(
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
)
;
}
public
short
readLittleEndianShort
(
)
{
return
(
short
)
(
(
data
[
position
+
+
]
&
0xFF
)
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
)
;
}
public
int
readUnsignedInt24
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
;
}
public
int
readLittleEndianInt24
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
16
;
}
public
int
readLittleEndianUnsignedInt24
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
16
;
}
public
long
readUnsignedInt
(
)
{
return
(
data
[
position
+
+
]
&
0xFFL
)
<
<
24
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFFL
)
;
}
public
long
readLittleEndianUnsignedInt
(
)
{
return
(
data
[
position
+
+
]
&
0xFFL
)
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
24
;
}
public
int
readInt
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
<
<
24
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
;
}
public
int
readLittleEndianInt
(
)
{
return
(
data
[
position
+
+
]
&
0xFF
)
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFF
)
<
<
24
;
}
public
long
readLong
(
)
{
return
(
data
[
position
+
+
]
&
0xFFL
)
<
<
56
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
48
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
40
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
32
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
24
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFFL
)
;
}
public
long
readLittleEndianLong
(
)
{
return
(
data
[
position
+
+
]
&
0xFFL
)
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
16
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
24
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
32
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
40
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
48
|
(
data
[
position
+
+
]
&
0xFFL
)
<
<
56
;
}
public
int
readUnsignedFixedPoint1616
(
)
{
int
result
=
(
data
[
position
+
+
]
&
0xFF
)
<
<
8
|
(
data
[
position
+
+
]
&
0xFF
)
;
position
+
=
2
;
return
result
;
}
public
int
readSynchSafeInt
(
)
{
int
b1
=
readUnsignedByte
(
)
;
int
b2
=
readUnsignedByte
(
)
;
int
b3
=
readUnsignedByte
(
)
;
int
b4
=
readUnsignedByte
(
)
;
return
(
b1
<
<
21
)
|
(
b2
<
<
14
)
|
(
b3
<
<
7
)
|
b4
;
}
public
int
readUnsignedIntToInt
(
)
{
int
result
=
readInt
(
)
;
if
(
result
<
0
)
{
throw
new
IllegalStateException
(
"
Top
bit
not
zero
:
"
+
result
)
;
}
return
result
;
}
public
int
readLittleEndianUnsignedIntToInt
(
)
{
int
result
=
readLittleEndianInt
(
)
;
if
(
result
<
0
)
{
throw
new
IllegalStateException
(
"
Top
bit
not
zero
:
"
+
result
)
;
}
return
result
;
}
public
long
readUnsignedLongToLong
(
)
{
long
result
=
readLong
(
)
;
if
(
result
<
0
)
{
throw
new
IllegalStateException
(
"
Top
bit
not
zero
:
"
+
result
)
;
}
return
result
;
}
public
float
readFloat
(
)
{
return
Float
.
intBitsToFloat
(
readInt
(
)
)
;
}
public
double
readDouble
(
)
{
return
Double
.
longBitsToDouble
(
readLong
(
)
)
;
}
public
String
readString
(
int
length
)
{
return
readString
(
length
Charset
.
defaultCharset
(
)
)
;
}
public
String
readString
(
int
length
Charset
charset
)
{
String
result
=
new
String
(
data
position
length
charset
)
;
position
+
=
length
;
return
result
;
}
public
String
readNullTerminatedString
(
int
length
)
{
if
(
length
=
=
0
)
{
return
"
"
;
}
int
stringLength
=
length
;
int
lastIndex
=
position
+
length
-
1
;
if
(
lastIndex
<
limit
&
&
data
[
lastIndex
]
=
=
0
)
{
stringLength
-
-
;
}
String
result
=
new
String
(
data
position
stringLength
)
;
position
+
=
length
;
return
result
;
}
public
String
readNullTerminatedString
(
)
{
if
(
bytesLeft
(
)
=
=
0
)
{
return
null
;
}
int
stringLimit
=
position
;
while
(
stringLimit
<
limit
&
&
data
[
stringLimit
]
!
=
0
)
{
stringLimit
+
+
;
}
String
string
=
new
String
(
data
position
stringLimit
-
position
)
;
position
=
stringLimit
;
if
(
position
<
limit
)
{
position
+
+
;
}
return
string
;
}
public
String
readLine
(
)
{
if
(
bytesLeft
(
)
=
=
0
)
{
return
null
;
}
int
lineLimit
=
position
;
while
(
lineLimit
<
limit
&
&
!
Util
.
isLinebreak
(
data
[
lineLimit
]
)
)
{
lineLimit
+
+
;
}
if
(
lineLimit
-
position
>
=
3
&
&
data
[
position
]
=
=
(
byte
)
0xEF
&
&
data
[
position
+
1
]
=
=
(
byte
)
0xBB
&
&
data
[
position
+
2
]
=
=
(
byte
)
0xBF
)
{
position
+
=
3
;
}
String
line
=
new
String
(
data
position
lineLimit
-
position
)
;
position
=
lineLimit
;
if
(
position
=
=
limit
)
{
return
line
;
}
if
(
data
[
position
]
=
=
'
\
r
'
)
{
position
+
+
;
if
(
position
=
=
limit
)
{
return
line
;
}
}
if
(
data
[
position
]
=
=
'
\
n
'
)
{
position
+
+
;
}
return
line
;
}
public
long
readUtf8EncodedLong
(
)
{
int
length
=
0
;
long
value
=
data
[
position
]
;
for
(
int
j
=
7
;
j
>
=
0
;
j
-
-
)
{
if
(
(
value
&
(
1
<
<
j
)
)
=
=
0
)
{
if
(
j
<
6
)
{
value
&
=
(
1
<
<
j
)
-
1
;
length
=
7
-
j
;
}
else
if
(
j
=
=
7
)
{
length
=
1
;
}
break
;
}
}
if
(
length
=
=
0
)
{
throw
new
NumberFormatException
(
"
Invalid
UTF
-
8
sequence
first
byte
:
"
+
value
)
;
}
for
(
int
i
=
1
;
i
<
length
;
i
+
+
)
{
int
x
=
data
[
position
+
i
]
;
if
(
(
x
&
0xC0
)
!
=
0x80
)
{
throw
new
NumberFormatException
(
"
Invalid
UTF
-
8
sequence
continuation
byte
:
"
+
value
)
;
}
value
=
(
value
<
<
6
)
|
(
x
&
0x3F
)
;
}
position
+
=
length
;
return
value
;
}
}
