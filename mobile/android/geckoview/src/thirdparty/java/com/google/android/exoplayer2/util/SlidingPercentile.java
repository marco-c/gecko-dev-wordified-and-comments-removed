package
com
.
google
.
android
.
exoplayer2
.
util
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Comparator
;
public
class
SlidingPercentile
{
private
static
final
Comparator
<
Sample
>
INDEX_COMPARATOR
=
new
Comparator
<
Sample
>
(
)
{
Override
public
int
compare
(
Sample
a
Sample
b
)
{
return
a
.
index
-
b
.
index
;
}
}
;
private
static
final
Comparator
<
Sample
>
VALUE_COMPARATOR
=
new
Comparator
<
Sample
>
(
)
{
Override
public
int
compare
(
Sample
a
Sample
b
)
{
return
a
.
value
<
b
.
value
?
-
1
:
b
.
value
<
a
.
value
?
1
:
0
;
}
}
;
private
static
final
int
SORT_ORDER_NONE
=
-
1
;
private
static
final
int
SORT_ORDER_BY_VALUE
=
0
;
private
static
final
int
SORT_ORDER_BY_INDEX
=
1
;
private
static
final
int
MAX_RECYCLED_SAMPLES
=
5
;
private
final
int
maxWeight
;
private
final
ArrayList
<
Sample
>
samples
;
private
final
Sample
[
]
recycledSamples
;
private
int
currentSortOrder
;
private
int
nextSampleIndex
;
private
int
totalWeight
;
private
int
recycledSampleCount
;
public
SlidingPercentile
(
int
maxWeight
)
{
this
.
maxWeight
=
maxWeight
;
recycledSamples
=
new
Sample
[
MAX_RECYCLED_SAMPLES
]
;
samples
=
new
ArrayList
<
>
(
)
;
currentSortOrder
=
SORT_ORDER_NONE
;
}
public
void
addSample
(
int
weight
float
value
)
{
ensureSortedByIndex
(
)
;
Sample
newSample
=
recycledSampleCount
>
0
?
recycledSamples
[
-
-
recycledSampleCount
]
:
new
Sample
(
)
;
newSample
.
index
=
nextSampleIndex
+
+
;
newSample
.
weight
=
weight
;
newSample
.
value
=
value
;
samples
.
add
(
newSample
)
;
totalWeight
+
=
weight
;
while
(
totalWeight
>
maxWeight
)
{
int
excessWeight
=
totalWeight
-
maxWeight
;
Sample
oldestSample
=
samples
.
get
(
0
)
;
if
(
oldestSample
.
weight
<
=
excessWeight
)
{
totalWeight
-
=
oldestSample
.
weight
;
samples
.
remove
(
0
)
;
if
(
recycledSampleCount
<
MAX_RECYCLED_SAMPLES
)
{
recycledSamples
[
recycledSampleCount
+
+
]
=
oldestSample
;
}
}
else
{
oldestSample
.
weight
-
=
excessWeight
;
totalWeight
-
=
excessWeight
;
}
}
}
public
float
getPercentile
(
float
percentile
)
{
ensureSortedByValue
(
)
;
float
desiredWeight
=
percentile
*
totalWeight
;
int
accumulatedWeight
=
0
;
for
(
int
i
=
0
;
i
<
samples
.
size
(
)
;
i
+
+
)
{
Sample
currentSample
=
samples
.
get
(
i
)
;
accumulatedWeight
+
=
currentSample
.
weight
;
if
(
accumulatedWeight
>
=
desiredWeight
)
{
return
currentSample
.
value
;
}
}
return
samples
.
isEmpty
(
)
?
Float
.
NaN
:
samples
.
get
(
samples
.
size
(
)
-
1
)
.
value
;
}
private
void
ensureSortedByIndex
(
)
{
if
(
currentSortOrder
!
=
SORT_ORDER_BY_INDEX
)
{
Collections
.
sort
(
samples
INDEX_COMPARATOR
)
;
currentSortOrder
=
SORT_ORDER_BY_INDEX
;
}
}
private
void
ensureSortedByValue
(
)
{
if
(
currentSortOrder
!
=
SORT_ORDER_BY_VALUE
)
{
Collections
.
sort
(
samples
VALUE_COMPARATOR
)
;
currentSortOrder
=
SORT_ORDER_BY_VALUE
;
}
}
private
static
class
Sample
{
public
int
index
;
public
int
weight
;
public
float
value
;
}
}
