package
com
.
google
.
android
.
exoplayer2
.
util
;
import
android
.
util
.
Log
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
Arrays
;
public
final
class
NalUnitUtil
{
private
static
final
String
TAG
=
"
NalUnitUtil
"
;
public
static
final
class
SpsData
{
public
final
int
seqParameterSetId
;
public
final
int
width
;
public
final
int
height
;
public
final
float
pixelWidthAspectRatio
;
public
final
boolean
separateColorPlaneFlag
;
public
final
boolean
frameMbsOnlyFlag
;
public
final
int
frameNumLength
;
public
final
int
picOrderCountType
;
public
final
int
picOrderCntLsbLength
;
public
final
boolean
deltaPicOrderAlwaysZeroFlag
;
public
SpsData
(
int
seqParameterSetId
int
width
int
height
float
pixelWidthAspectRatio
boolean
separateColorPlaneFlag
boolean
frameMbsOnlyFlag
int
frameNumLength
int
picOrderCountType
int
picOrderCntLsbLength
boolean
deltaPicOrderAlwaysZeroFlag
)
{
this
.
seqParameterSetId
=
seqParameterSetId
;
this
.
width
=
width
;
this
.
height
=
height
;
this
.
pixelWidthAspectRatio
=
pixelWidthAspectRatio
;
this
.
separateColorPlaneFlag
=
separateColorPlaneFlag
;
this
.
frameMbsOnlyFlag
=
frameMbsOnlyFlag
;
this
.
frameNumLength
=
frameNumLength
;
this
.
picOrderCountType
=
picOrderCountType
;
this
.
picOrderCntLsbLength
=
picOrderCntLsbLength
;
this
.
deltaPicOrderAlwaysZeroFlag
=
deltaPicOrderAlwaysZeroFlag
;
}
}
public
static
final
class
PpsData
{
public
final
int
picParameterSetId
;
public
final
int
seqParameterSetId
;
public
final
boolean
bottomFieldPicOrderInFramePresentFlag
;
public
PpsData
(
int
picParameterSetId
int
seqParameterSetId
boolean
bottomFieldPicOrderInFramePresentFlag
)
{
this
.
picParameterSetId
=
picParameterSetId
;
this
.
seqParameterSetId
=
seqParameterSetId
;
this
.
bottomFieldPicOrderInFramePresentFlag
=
bottomFieldPicOrderInFramePresentFlag
;
}
}
public
static
final
byte
[
]
NAL_START_CODE
=
new
byte
[
]
{
0
0
0
1
}
;
public
static
final
int
EXTENDED_SAR
=
0xFF
;
public
static
final
float
[
]
ASPECT_RATIO_IDC_VALUES
=
new
float
[
]
{
1f
1f
12f
/
11f
10f
/
11f
16f
/
11f
40f
/
33f
24f
/
11f
20f
/
11f
32f
/
11f
80f
/
33f
18f
/
11f
15f
/
11f
64f
/
33f
160f
/
99f
4f
/
3f
3f
/
2f
2f
}
;
private
static
final
int
H264_NAL_UNIT_TYPE_SEI
=
6
;
private
static
final
int
H264_NAL_UNIT_TYPE_SPS
=
7
;
private
static
final
int
H265_NAL_UNIT_TYPE_PREFIX_SEI
=
39
;
private
static
final
Object
scratchEscapePositionsLock
=
new
Object
(
)
;
private
static
int
[
]
scratchEscapePositions
=
new
int
[
10
]
;
public
static
int
unescapeStream
(
byte
[
]
data
int
limit
)
{
synchronized
(
scratchEscapePositionsLock
)
{
int
position
=
0
;
int
scratchEscapeCount
=
0
;
while
(
position
<
limit
)
{
position
=
findNextUnescapeIndex
(
data
position
limit
)
;
if
(
position
<
limit
)
{
if
(
scratchEscapePositions
.
length
<
=
scratchEscapeCount
)
{
scratchEscapePositions
=
Arrays
.
copyOf
(
scratchEscapePositions
scratchEscapePositions
.
length
*
2
)
;
}
scratchEscapePositions
[
scratchEscapeCount
+
+
]
=
position
;
position
+
=
3
;
}
}
int
unescapedLength
=
limit
-
scratchEscapeCount
;
int
escapedPosition
=
0
;
int
unescapedPosition
=
0
;
for
(
int
i
=
0
;
i
<
scratchEscapeCount
;
i
+
+
)
{
int
nextEscapePosition
=
scratchEscapePositions
[
i
]
;
int
copyLength
=
nextEscapePosition
-
escapedPosition
;
System
.
arraycopy
(
data
escapedPosition
data
unescapedPosition
copyLength
)
;
unescapedPosition
+
=
copyLength
;
data
[
unescapedPosition
+
+
]
=
0
;
data
[
unescapedPosition
+
+
]
=
0
;
escapedPosition
+
=
copyLength
+
3
;
}
int
remainingLength
=
unescapedLength
-
unescapedPosition
;
System
.
arraycopy
(
data
escapedPosition
data
unescapedPosition
remainingLength
)
;
return
unescapedLength
;
}
}
public
static
void
discardToSps
(
ByteBuffer
data
)
{
int
length
=
data
.
position
(
)
;
int
consecutiveZeros
=
0
;
int
offset
=
0
;
while
(
offset
+
1
<
length
)
{
int
value
=
data
.
get
(
offset
)
&
0xFF
;
if
(
consecutiveZeros
=
=
3
)
{
if
(
value
=
=
1
&
&
(
data
.
get
(
offset
+
1
)
&
0x1F
)
=
=
H264_NAL_UNIT_TYPE_SPS
)
{
ByteBuffer
offsetData
=
data
.
duplicate
(
)
;
offsetData
.
position
(
offset
-
3
)
;
offsetData
.
limit
(
length
)
;
data
.
position
(
0
)
;
data
.
put
(
offsetData
)
;
return
;
}
}
else
if
(
value
=
=
0
)
{
consecutiveZeros
+
+
;
}
if
(
value
!
=
0
)
{
consecutiveZeros
=
0
;
}
offset
+
+
;
}
data
.
clear
(
)
;
}
public
static
boolean
isNalUnitSei
(
String
mimeType
byte
nalUnitHeaderFirstByte
)
{
return
(
MimeTypes
.
VIDEO_H264
.
equals
(
mimeType
)
&
&
(
nalUnitHeaderFirstByte
&
0x1F
)
=
=
H264_NAL_UNIT_TYPE_SEI
)
|
|
(
MimeTypes
.
VIDEO_H265
.
equals
(
mimeType
)
&
&
(
(
nalUnitHeaderFirstByte
&
0x7E
)
>
>
1
)
=
=
H265_NAL_UNIT_TYPE_PREFIX_SEI
)
;
}
public
static
int
getNalUnitType
(
byte
[
]
data
int
offset
)
{
return
data
[
offset
+
3
]
&
0x1F
;
}
public
static
int
getH265NalUnitType
(
byte
[
]
data
int
offset
)
{
return
(
data
[
offset
+
3
]
&
0x7E
)
>
>
1
;
}
public
static
SpsData
parseSpsNalUnit
(
byte
[
]
nalData
int
nalOffset
int
nalLimit
)
{
ParsableNalUnitBitArray
data
=
new
ParsableNalUnitBitArray
(
nalData
nalOffset
nalLimit
)
;
data
.
skipBits
(
8
)
;
int
profileIdc
=
data
.
readBits
(
8
)
;
data
.
skipBits
(
16
)
;
int
seqParameterSetId
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
chromaFormatIdc
=
1
;
boolean
separateColorPlaneFlag
=
false
;
if
(
profileIdc
=
=
100
|
|
profileIdc
=
=
110
|
|
profileIdc
=
=
122
|
|
profileIdc
=
=
244
|
|
profileIdc
=
=
44
|
|
profileIdc
=
=
83
|
|
profileIdc
=
=
86
|
|
profileIdc
=
=
118
|
|
profileIdc
=
=
128
|
|
profileIdc
=
=
138
)
{
chromaFormatIdc
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
if
(
chromaFormatIdc
=
=
3
)
{
separateColorPlaneFlag
=
data
.
readBit
(
)
;
}
data
.
readUnsignedExpGolombCodedInt
(
)
;
data
.
readUnsignedExpGolombCodedInt
(
)
;
data
.
skipBits
(
1
)
;
boolean
seqScalingMatrixPresentFlag
=
data
.
readBit
(
)
;
if
(
seqScalingMatrixPresentFlag
)
{
int
limit
=
(
chromaFormatIdc
!
=
3
)
?
8
:
12
;
for
(
int
i
=
0
;
i
<
limit
;
i
+
+
)
{
boolean
seqScalingListPresentFlag
=
data
.
readBit
(
)
;
if
(
seqScalingListPresentFlag
)
{
skipScalingList
(
data
i
<
6
?
16
:
64
)
;
}
}
}
}
int
frameNumLength
=
data
.
readUnsignedExpGolombCodedInt
(
)
+
4
;
int
picOrderCntType
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
picOrderCntLsbLength
=
0
;
boolean
deltaPicOrderAlwaysZeroFlag
=
false
;
if
(
picOrderCntType
=
=
0
)
{
picOrderCntLsbLength
=
data
.
readUnsignedExpGolombCodedInt
(
)
+
4
;
}
else
if
(
picOrderCntType
=
=
1
)
{
deltaPicOrderAlwaysZeroFlag
=
data
.
readBit
(
)
;
data
.
readSignedExpGolombCodedInt
(
)
;
data
.
readSignedExpGolombCodedInt
(
)
;
long
numRefFramesInPicOrderCntCycle
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
for
(
int
i
=
0
;
i
<
numRefFramesInPicOrderCntCycle
;
i
+
+
)
{
data
.
readUnsignedExpGolombCodedInt
(
)
;
}
}
data
.
readUnsignedExpGolombCodedInt
(
)
;
data
.
skipBits
(
1
)
;
int
picWidthInMbs
=
data
.
readUnsignedExpGolombCodedInt
(
)
+
1
;
int
picHeightInMapUnits
=
data
.
readUnsignedExpGolombCodedInt
(
)
+
1
;
boolean
frameMbsOnlyFlag
=
data
.
readBit
(
)
;
int
frameHeightInMbs
=
(
2
-
(
frameMbsOnlyFlag
?
1
:
0
)
)
*
picHeightInMapUnits
;
if
(
!
frameMbsOnlyFlag
)
{
data
.
skipBits
(
1
)
;
}
data
.
skipBits
(
1
)
;
int
frameWidth
=
picWidthInMbs
*
16
;
int
frameHeight
=
frameHeightInMbs
*
16
;
boolean
frameCroppingFlag
=
data
.
readBit
(
)
;
if
(
frameCroppingFlag
)
{
int
frameCropLeftOffset
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
frameCropRightOffset
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
frameCropTopOffset
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
frameCropBottomOffset
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
cropUnitX
;
int
cropUnitY
;
if
(
chromaFormatIdc
=
=
0
)
{
cropUnitX
=
1
;
cropUnitY
=
2
-
(
frameMbsOnlyFlag
?
1
:
0
)
;
}
else
{
int
subWidthC
=
(
chromaFormatIdc
=
=
3
)
?
1
:
2
;
int
subHeightC
=
(
chromaFormatIdc
=
=
1
)
?
2
:
1
;
cropUnitX
=
subWidthC
;
cropUnitY
=
subHeightC
*
(
2
-
(
frameMbsOnlyFlag
?
1
:
0
)
)
;
}
frameWidth
-
=
(
frameCropLeftOffset
+
frameCropRightOffset
)
*
cropUnitX
;
frameHeight
-
=
(
frameCropTopOffset
+
frameCropBottomOffset
)
*
cropUnitY
;
}
float
pixelWidthHeightRatio
=
1
;
boolean
vuiParametersPresentFlag
=
data
.
readBit
(
)
;
if
(
vuiParametersPresentFlag
)
{
boolean
aspectRatioInfoPresentFlag
=
data
.
readBit
(
)
;
if
(
aspectRatioInfoPresentFlag
)
{
int
aspectRatioIdc
=
data
.
readBits
(
8
)
;
if
(
aspectRatioIdc
=
=
NalUnitUtil
.
EXTENDED_SAR
)
{
int
sarWidth
=
data
.
readBits
(
16
)
;
int
sarHeight
=
data
.
readBits
(
16
)
;
if
(
sarWidth
!
=
0
&
&
sarHeight
!
=
0
)
{
pixelWidthHeightRatio
=
(
float
)
sarWidth
/
sarHeight
;
}
}
else
if
(
aspectRatioIdc
<
NalUnitUtil
.
ASPECT_RATIO_IDC_VALUES
.
length
)
{
pixelWidthHeightRatio
=
NalUnitUtil
.
ASPECT_RATIO_IDC_VALUES
[
aspectRatioIdc
]
;
}
else
{
Log
.
w
(
TAG
"
Unexpected
aspect_ratio_idc
value
:
"
+
aspectRatioIdc
)
;
}
}
}
return
new
SpsData
(
seqParameterSetId
frameWidth
frameHeight
pixelWidthHeightRatio
separateColorPlaneFlag
frameMbsOnlyFlag
frameNumLength
picOrderCntType
picOrderCntLsbLength
deltaPicOrderAlwaysZeroFlag
)
;
}
public
static
PpsData
parsePpsNalUnit
(
byte
[
]
nalData
int
nalOffset
int
nalLimit
)
{
ParsableNalUnitBitArray
data
=
new
ParsableNalUnitBitArray
(
nalData
nalOffset
nalLimit
)
;
data
.
skipBits
(
8
)
;
int
picParameterSetId
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
int
seqParameterSetId
=
data
.
readUnsignedExpGolombCodedInt
(
)
;
data
.
skipBits
(
1
)
;
boolean
bottomFieldPicOrderInFramePresentFlag
=
data
.
readBit
(
)
;
return
new
PpsData
(
picParameterSetId
seqParameterSetId
bottomFieldPicOrderInFramePresentFlag
)
;
}
public
static
int
findNalUnit
(
byte
[
]
data
int
startOffset
int
endOffset
boolean
[
]
prefixFlags
)
{
int
length
=
endOffset
-
startOffset
;
Assertions
.
checkState
(
length
>
=
0
)
;
if
(
length
=
=
0
)
{
return
endOffset
;
}
if
(
prefixFlags
!
=
null
)
{
if
(
prefixFlags
[
0
]
)
{
clearPrefixFlags
(
prefixFlags
)
;
return
startOffset
-
3
;
}
else
if
(
length
>
1
&
&
prefixFlags
[
1
]
&
&
data
[
startOffset
]
=
=
1
)
{
clearPrefixFlags
(
prefixFlags
)
;
return
startOffset
-
2
;
}
else
if
(
length
>
2
&
&
prefixFlags
[
2
]
&
&
data
[
startOffset
]
=
=
0
&
&
data
[
startOffset
+
1
]
=
=
1
)
{
clearPrefixFlags
(
prefixFlags
)
;
return
startOffset
-
1
;
}
}
int
limit
=
endOffset
-
1
;
for
(
int
i
=
startOffset
+
2
;
i
<
limit
;
i
+
=
3
)
{
if
(
(
data
[
i
]
&
0xFE
)
!
=
0
)
{
}
else
if
(
data
[
i
-
2
]
=
=
0
&
&
data
[
i
-
1
]
=
=
0
&
&
data
[
i
]
=
=
1
)
{
if
(
prefixFlags
!
=
null
)
{
clearPrefixFlags
(
prefixFlags
)
;
}
return
i
-
2
;
}
else
{
i
-
=
2
;
}
}
if
(
prefixFlags
!
=
null
)
{
prefixFlags
[
0
]
=
length
>
2
?
(
data
[
endOffset
-
3
]
=
=
0
&
&
data
[
endOffset
-
2
]
=
=
0
&
&
data
[
endOffset
-
1
]
=
=
1
)
:
length
=
=
2
?
(
prefixFlags
[
2
]
&
&
data
[
endOffset
-
2
]
=
=
0
&
&
data
[
endOffset
-
1
]
=
=
1
)
:
(
prefixFlags
[
1
]
&
&
data
[
endOffset
-
1
]
=
=
1
)
;
prefixFlags
[
1
]
=
length
>
1
?
data
[
endOffset
-
2
]
=
=
0
&
&
data
[
endOffset
-
1
]
=
=
0
:
prefixFlags
[
2
]
&
&
data
[
endOffset
-
1
]
=
=
0
;
prefixFlags
[
2
]
=
data
[
endOffset
-
1
]
=
=
0
;
}
return
endOffset
;
}
public
static
void
clearPrefixFlags
(
boolean
[
]
prefixFlags
)
{
prefixFlags
[
0
]
=
false
;
prefixFlags
[
1
]
=
false
;
prefixFlags
[
2
]
=
false
;
}
private
static
int
findNextUnescapeIndex
(
byte
[
]
bytes
int
offset
int
limit
)
{
for
(
int
i
=
offset
;
i
<
limit
-
2
;
i
+
+
)
{
if
(
bytes
[
i
]
=
=
0x00
&
&
bytes
[
i
+
1
]
=
=
0x00
&
&
bytes
[
i
+
2
]
=
=
0x03
)
{
return
i
;
}
}
return
limit
;
}
private
static
void
skipScalingList
(
ParsableNalUnitBitArray
bitArray
int
size
)
{
int
lastScale
=
8
;
int
nextScale
=
8
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
nextScale
!
=
0
)
{
int
deltaScale
=
bitArray
.
readSignedExpGolombCodedInt
(
)
;
nextScale
=
(
lastScale
+
deltaScale
+
256
)
%
256
;
}
lastScale
=
(
nextScale
=
=
0
)
?
lastScale
:
nextScale
;
}
}
private
NalUnitUtil
(
)
{
}
}
