package
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
MpegAudioHeader
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
final
class
VbriSeeker
implements
Mp3Extractor
.
Seeker
{
public
static
VbriSeeker
create
(
MpegAudioHeader
mpegAudioHeader
ParsableByteArray
frame
long
position
long
inputLength
)
{
frame
.
skipBytes
(
10
)
;
int
numFrames
=
frame
.
readInt
(
)
;
if
(
numFrames
<
=
0
)
{
return
null
;
}
int
sampleRate
=
mpegAudioHeader
.
sampleRate
;
long
durationUs
=
Util
.
scaleLargeTimestamp
(
numFrames
C
.
MICROS_PER_SECOND
*
(
sampleRate
>
=
32000
?
1152
:
576
)
sampleRate
)
;
int
entryCount
=
frame
.
readUnsignedShort
(
)
;
int
scale
=
frame
.
readUnsignedShort
(
)
;
int
entrySize
=
frame
.
readUnsignedShort
(
)
;
frame
.
skipBytes
(
2
)
;
position
+
=
mpegAudioHeader
.
frameSize
;
long
[
]
timesUs
=
new
long
[
entryCount
+
1
]
;
long
[
]
positions
=
new
long
[
entryCount
+
1
]
;
timesUs
[
0
]
=
0L
;
positions
[
0
]
=
position
;
for
(
int
index
=
1
;
index
<
timesUs
.
length
;
index
+
+
)
{
int
segmentSize
;
switch
(
entrySize
)
{
case
1
:
segmentSize
=
frame
.
readUnsignedByte
(
)
;
break
;
case
2
:
segmentSize
=
frame
.
readUnsignedShort
(
)
;
break
;
case
3
:
segmentSize
=
frame
.
readUnsignedInt24
(
)
;
break
;
case
4
:
segmentSize
=
frame
.
readUnsignedIntToInt
(
)
;
break
;
default
:
return
null
;
}
position
+
=
segmentSize
*
scale
;
timesUs
[
index
]
=
index
*
durationUs
/
entryCount
;
positions
[
index
]
=
inputLength
=
=
C
.
LENGTH_UNSET
?
position
:
Math
.
min
(
inputLength
position
)
;
}
return
new
VbriSeeker
(
timesUs
positions
durationUs
)
;
}
private
final
long
[
]
timesUs
;
private
final
long
[
]
positions
;
private
final
long
durationUs
;
private
VbriSeeker
(
long
[
]
timesUs
long
[
]
positions
long
durationUs
)
{
this
.
timesUs
=
timesUs
;
this
.
positions
=
positions
;
this
.
durationUs
=
durationUs
;
}
Override
public
boolean
isSeekable
(
)
{
return
true
;
}
Override
public
long
getPosition
(
long
timeUs
)
{
return
positions
[
Util
.
binarySearchFloor
(
timesUs
timeUs
true
true
)
]
;
}
Override
public
long
getTimeUs
(
long
position
)
{
return
timesUs
[
Util
.
binarySearchFloor
(
positions
position
true
true
)
]
;
}
Override
public
long
getDurationUs
(
)
{
return
durationUs
;
}
}
