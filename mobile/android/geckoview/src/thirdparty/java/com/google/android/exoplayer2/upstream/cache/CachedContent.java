package
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
.
Cache
.
CacheException
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
io
.
DataInputStream
;
import
java
.
io
.
DataOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
util
.
TreeSet
;
final
class
CachedContent
{
public
final
int
id
;
public
final
String
key
;
private
final
TreeSet
<
SimpleCacheSpan
>
cachedSpans
;
private
long
length
;
public
CachedContent
(
DataInputStream
input
)
throws
IOException
{
this
(
input
.
readInt
(
)
input
.
readUTF
(
)
input
.
readLong
(
)
)
;
}
public
CachedContent
(
int
id
String
key
long
length
)
{
this
.
id
=
id
;
this
.
key
=
key
;
this
.
length
=
length
;
this
.
cachedSpans
=
new
TreeSet
<
>
(
)
;
}
public
void
writeToStream
(
DataOutputStream
output
)
throws
IOException
{
output
.
writeInt
(
id
)
;
output
.
writeUTF
(
key
)
;
output
.
writeLong
(
length
)
;
}
public
long
getLength
(
)
{
return
length
;
}
public
void
setLength
(
long
length
)
{
this
.
length
=
length
;
}
public
void
addSpan
(
SimpleCacheSpan
span
)
{
cachedSpans
.
add
(
span
)
;
}
public
TreeSet
<
SimpleCacheSpan
>
getSpans
(
)
{
return
cachedSpans
;
}
public
SimpleCacheSpan
getSpan
(
long
position
)
{
SimpleCacheSpan
lookupSpan
=
SimpleCacheSpan
.
createLookup
(
key
position
)
;
SimpleCacheSpan
floorSpan
=
cachedSpans
.
floor
(
lookupSpan
)
;
if
(
floorSpan
!
=
null
&
&
floorSpan
.
position
+
floorSpan
.
length
>
position
)
{
return
floorSpan
;
}
SimpleCacheSpan
ceilSpan
=
cachedSpans
.
ceiling
(
lookupSpan
)
;
return
ceilSpan
=
=
null
?
SimpleCacheSpan
.
createOpenHole
(
key
position
)
:
SimpleCacheSpan
.
createClosedHole
(
key
position
ceilSpan
.
position
-
position
)
;
}
public
long
getCachedBytes
(
long
position
long
length
)
{
SimpleCacheSpan
span
=
getSpan
(
position
)
;
if
(
span
.
isHoleSpan
(
)
)
{
return
-
Math
.
min
(
span
.
isOpenEnded
(
)
?
Long
.
MAX_VALUE
:
span
.
length
length
)
;
}
long
queryEndPosition
=
position
+
length
;
long
currentEndPosition
=
span
.
position
+
span
.
length
;
if
(
currentEndPosition
<
queryEndPosition
)
{
for
(
SimpleCacheSpan
next
:
cachedSpans
.
tailSet
(
span
false
)
)
{
if
(
next
.
position
>
currentEndPosition
)
{
break
;
}
currentEndPosition
=
Math
.
max
(
currentEndPosition
next
.
position
+
next
.
length
)
;
if
(
currentEndPosition
>
=
queryEndPosition
)
{
break
;
}
}
}
return
Math
.
min
(
currentEndPosition
-
position
length
)
;
}
public
SimpleCacheSpan
touch
(
SimpleCacheSpan
cacheSpan
)
throws
CacheException
{
Assertions
.
checkState
(
cachedSpans
.
remove
(
cacheSpan
)
)
;
SimpleCacheSpan
newCacheSpan
=
cacheSpan
.
copyWithUpdatedLastAccessTime
(
id
)
;
if
(
!
cacheSpan
.
file
.
renameTo
(
newCacheSpan
.
file
)
)
{
throw
new
CacheException
(
"
Renaming
of
"
+
cacheSpan
.
file
+
"
to
"
+
newCacheSpan
.
file
+
"
failed
.
"
)
;
}
cachedSpans
.
add
(
newCacheSpan
)
;
return
newCacheSpan
;
}
public
boolean
isEmpty
(
)
{
return
cachedSpans
.
isEmpty
(
)
;
}
public
boolean
removeSpan
(
CacheSpan
span
)
{
if
(
cachedSpans
.
remove
(
span
)
)
{
span
.
file
.
delete
(
)
;
return
true
;
}
return
false
;
}
public
int
headerHashCode
(
)
{
int
result
=
id
;
result
=
31
*
result
+
key
.
hashCode
(
)
;
result
=
31
*
result
+
(
int
)
(
length
^
(
length
>
>
>
32
)
)
;
return
result
;
}
}
