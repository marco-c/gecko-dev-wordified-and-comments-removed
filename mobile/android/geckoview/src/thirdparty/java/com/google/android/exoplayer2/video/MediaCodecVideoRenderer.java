package
com
.
google
.
android
.
exoplayer2
.
video
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Point
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodecInfo
.
CodecCapabilities
;
import
android
.
media
.
MediaCrypto
;
import
android
.
media
.
MediaFormat
;
import
android
.
os
.
Handler
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
util
.
Log
;
import
android
.
view
.
Surface
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmInitData
;
import
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
com
.
google
.
android
.
exoplayer2
.
drm
.
FrameworkMediaCrypto
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecInfo
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecRenderer
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecSelector
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecUtil
;
import
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecUtil
.
DecoderQueryException
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
com
.
google
.
android
.
exoplayer2
.
video
.
VideoRendererEventListener
.
EventDispatcher
;
import
java
.
nio
.
ByteBuffer
;
TargetApi
(
16
)
public
class
MediaCodecVideoRenderer
extends
MediaCodecRenderer
{
private
static
final
String
TAG
=
"
MediaCodecVideoRenderer
"
;
private
static
final
String
KEY_CROP_LEFT
=
"
crop
-
left
"
;
private
static
final
String
KEY_CROP_RIGHT
=
"
crop
-
right
"
;
private
static
final
String
KEY_CROP_BOTTOM
=
"
crop
-
bottom
"
;
private
static
final
String
KEY_CROP_TOP
=
"
crop
-
top
"
;
private
static
final
int
[
]
STANDARD_LONG_EDGE_VIDEO_PX
=
new
int
[
]
{
1920
1600
1440
1280
960
854
640
540
480
}
;
private
final
VideoFrameReleaseTimeHelper
frameReleaseTimeHelper
;
private
final
EventDispatcher
eventDispatcher
;
private
final
long
allowedJoiningTimeMs
;
private
final
int
maxDroppedFramesToNotify
;
private
final
boolean
deviceNeedsAutoFrcWorkaround
;
private
Format
[
]
streamFormats
;
private
CodecMaxValues
codecMaxValues
;
private
Surface
surface
;
C
.
VideoScalingMode
private
int
scalingMode
;
private
boolean
renderedFirstFrame
;
private
long
joiningDeadlineMs
;
private
long
droppedFrameAccumulationStartTimeMs
;
private
int
droppedFrames
;
private
int
consecutiveDroppedFrameCount
;
private
int
pendingRotationDegrees
;
private
float
pendingPixelWidthHeightRatio
;
private
int
currentWidth
;
private
int
currentHeight
;
private
int
currentUnappliedRotationDegrees
;
private
float
currentPixelWidthHeightRatio
;
private
int
reportedWidth
;
private
int
reportedHeight
;
private
int
reportedUnappliedRotationDegrees
;
private
float
reportedPixelWidthHeightRatio
;
private
boolean
tunneling
;
private
int
tunnelingAudioSessionId
;
OnFrameRenderedListenerV23
tunnelingOnFrameRenderedListener
;
public
MediaCodecVideoRenderer
(
Context
context
MediaCodecSelector
mediaCodecSelector
)
{
this
(
context
mediaCodecSelector
0
)
;
}
public
MediaCodecVideoRenderer
(
Context
context
MediaCodecSelector
mediaCodecSelector
long
allowedJoiningTimeMs
)
{
this
(
context
mediaCodecSelector
allowedJoiningTimeMs
null
null
-
1
)
;
}
public
MediaCodecVideoRenderer
(
Context
context
MediaCodecSelector
mediaCodecSelector
long
allowedJoiningTimeMs
Handler
eventHandler
VideoRendererEventListener
eventListener
int
maxDroppedFrameCountToNotify
)
{
this
(
context
mediaCodecSelector
allowedJoiningTimeMs
null
false
eventHandler
eventListener
maxDroppedFrameCountToNotify
)
;
}
public
MediaCodecVideoRenderer
(
Context
context
MediaCodecSelector
mediaCodecSelector
long
allowedJoiningTimeMs
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
Handler
eventHandler
VideoRendererEventListener
eventListener
int
maxDroppedFramesToNotify
)
{
super
(
C
.
TRACK_TYPE_VIDEO
mediaCodecSelector
drmSessionManager
playClearSamplesWithoutKeys
)
;
this
.
allowedJoiningTimeMs
=
allowedJoiningTimeMs
;
this
.
maxDroppedFramesToNotify
=
maxDroppedFramesToNotify
;
frameReleaseTimeHelper
=
new
VideoFrameReleaseTimeHelper
(
context
)
;
eventDispatcher
=
new
EventDispatcher
(
eventHandler
eventListener
)
;
deviceNeedsAutoFrcWorkaround
=
deviceNeedsAutoFrcWorkaround
(
)
;
joiningDeadlineMs
=
C
.
TIME_UNSET
;
currentWidth
=
Format
.
NO_VALUE
;
currentHeight
=
Format
.
NO_VALUE
;
currentPixelWidthHeightRatio
=
Format
.
NO_VALUE
;
pendingPixelWidthHeightRatio
=
Format
.
NO_VALUE
;
scalingMode
=
C
.
VIDEO_SCALING_MODE_DEFAULT
;
clearReportedVideoSize
(
)
;
}
Override
protected
int
supportsFormat
(
MediaCodecSelector
mediaCodecSelector
Format
format
)
throws
DecoderQueryException
{
String
mimeType
=
format
.
sampleMimeType
;
if
(
!
MimeTypes
.
isVideo
(
mimeType
)
)
{
return
FORMAT_UNSUPPORTED_TYPE
;
}
boolean
requiresSecureDecryption
=
false
;
DrmInitData
drmInitData
=
format
.
drmInitData
;
if
(
drmInitData
!
=
null
)
{
for
(
int
i
=
0
;
i
<
drmInitData
.
schemeDataCount
;
i
+
+
)
{
requiresSecureDecryption
|
=
drmInitData
.
get
(
i
)
.
requiresSecureDecryption
;
}
}
MediaCodecInfo
decoderInfo
=
mediaCodecSelector
.
getDecoderInfo
(
mimeType
requiresSecureDecryption
)
;
if
(
decoderInfo
=
=
null
)
{
return
FORMAT_UNSUPPORTED_SUBTYPE
;
}
boolean
decoderCapable
=
decoderInfo
.
isCodecSupported
(
format
.
codecs
)
;
if
(
decoderCapable
&
&
format
.
width
>
0
&
&
format
.
height
>
0
)
{
if
(
Util
.
SDK_INT
>
=
21
)
{
decoderCapable
=
decoderInfo
.
isVideoSizeAndRateSupportedV21
(
format
.
width
format
.
height
format
.
frameRate
)
;
}
else
{
decoderCapable
=
format
.
width
*
format
.
height
<
=
MediaCodecUtil
.
maxH264DecodableFrameSize
(
)
;
if
(
!
decoderCapable
)
{
Log
.
d
(
TAG
"
FalseCheck
[
legacyFrameSize
"
+
format
.
width
+
"
x
"
+
format
.
height
+
"
]
[
"
+
Util
.
DEVICE_DEBUG_INFO
+
"
]
"
)
;
}
}
}
int
adaptiveSupport
=
decoderInfo
.
adaptive
?
ADAPTIVE_SEAMLESS
:
ADAPTIVE_NOT_SEAMLESS
;
int
tunnelingSupport
=
decoderInfo
.
tunneling
?
TUNNELING_SUPPORTED
:
TUNNELING_NOT_SUPPORTED
;
int
formatSupport
=
decoderCapable
?
FORMAT_HANDLED
:
FORMAT_EXCEEDS_CAPABILITIES
;
return
adaptiveSupport
|
tunnelingSupport
|
formatSupport
;
}
Override
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
super
.
onEnabled
(
joining
)
;
tunnelingAudioSessionId
=
getConfiguration
(
)
.
tunnelingAudioSessionId
;
tunneling
=
tunnelingAudioSessionId
!
=
C
.
AUDIO_SESSION_ID_UNSET
;
eventDispatcher
.
enabled
(
decoderCounters
)
;
frameReleaseTimeHelper
.
enable
(
)
;
}
Override
protected
void
onStreamChanged
(
Format
[
]
formats
)
throws
ExoPlaybackException
{
streamFormats
=
formats
;
super
.
onStreamChanged
(
formats
)
;
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
super
.
onPositionReset
(
positionUs
joining
)
;
clearRenderedFirstFrame
(
)
;
consecutiveDroppedFrameCount
=
0
;
if
(
joining
)
{
setJoiningDeadlineMs
(
)
;
}
else
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
}
}
Override
public
boolean
isReady
(
)
{
if
(
(
renderedFirstFrame
|
|
super
.
shouldInitCodec
(
)
)
&
&
super
.
isReady
(
)
)
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
return
true
;
}
else
if
(
joiningDeadlineMs
=
=
C
.
TIME_UNSET
)
{
return
false
;
}
else
if
(
SystemClock
.
elapsedRealtime
(
)
<
joiningDeadlineMs
)
{
return
true
;
}
else
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
return
false
;
}
}
Override
protected
void
onStarted
(
)
{
super
.
onStarted
(
)
;
droppedFrames
=
0
;
droppedFrameAccumulationStartTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
joiningDeadlineMs
=
C
.
TIME_UNSET
;
}
Override
protected
void
onStopped
(
)
{
maybeNotifyDroppedFrames
(
)
;
super
.
onStopped
(
)
;
}
Override
protected
void
onDisabled
(
)
{
currentWidth
=
Format
.
NO_VALUE
;
currentHeight
=
Format
.
NO_VALUE
;
currentPixelWidthHeightRatio
=
Format
.
NO_VALUE
;
pendingPixelWidthHeightRatio
=
Format
.
NO_VALUE
;
clearReportedVideoSize
(
)
;
clearRenderedFirstFrame
(
)
;
frameReleaseTimeHelper
.
disable
(
)
;
tunnelingOnFrameRenderedListener
=
null
;
try
{
super
.
onDisabled
(
)
;
}
finally
{
decoderCounters
.
ensureUpdated
(
)
;
eventDispatcher
.
disabled
(
decoderCounters
)
;
}
}
Override
public
void
handleMessage
(
int
messageType
Object
message
)
throws
ExoPlaybackException
{
if
(
messageType
=
=
C
.
MSG_SET_SURFACE
)
{
setSurface
(
(
Surface
)
message
)
;
}
else
if
(
messageType
=
=
C
.
MSG_SET_SCALING_MODE
)
{
scalingMode
=
(
Integer
)
message
;
MediaCodec
codec
=
getCodec
(
)
;
if
(
codec
!
=
null
)
{
setVideoScalingMode
(
codec
scalingMode
)
;
}
}
else
{
super
.
handleMessage
(
messageType
message
)
;
}
}
private
void
setSurface
(
Surface
surface
)
throws
ExoPlaybackException
{
if
(
this
.
surface
!
=
surface
)
{
this
.
surface
=
surface
;
int
state
=
getState
(
)
;
if
(
state
=
=
STATE_ENABLED
|
|
state
=
=
STATE_STARTED
)
{
MediaCodec
codec
=
getCodec
(
)
;
if
(
Util
.
SDK_INT
>
=
23
&
&
codec
!
=
null
&
&
surface
!
=
null
)
{
setOutputSurfaceV23
(
codec
surface
)
;
}
else
{
releaseCodec
(
)
;
maybeInitCodec
(
)
;
}
}
if
(
surface
!
=
null
)
{
maybeRenotifyVideoSizeChanged
(
)
;
clearRenderedFirstFrame
(
)
;
if
(
state
=
=
STATE_STARTED
)
{
setJoiningDeadlineMs
(
)
;
}
}
else
{
clearReportedVideoSize
(
)
;
clearRenderedFirstFrame
(
)
;
}
}
else
if
(
surface
!
=
null
)
{
maybeRenotifyVideoSizeChanged
(
)
;
maybeRenotifyRenderedFirstFrame
(
)
;
}
}
Override
protected
boolean
shouldInitCodec
(
)
{
return
super
.
shouldInitCodec
(
)
&
&
surface
!
=
null
&
&
surface
.
isValid
(
)
;
}
Override
protected
void
configureCodec
(
MediaCodecInfo
codecInfo
MediaCodec
codec
Format
format
MediaCrypto
crypto
)
throws
DecoderQueryException
{
codecMaxValues
=
getCodecMaxValues
(
codecInfo
format
streamFormats
)
;
MediaFormat
mediaFormat
=
getMediaFormat
(
format
codecMaxValues
deviceNeedsAutoFrcWorkaround
tunnelingAudioSessionId
)
;
codec
.
configure
(
mediaFormat
surface
crypto
0
)
;
if
(
Util
.
SDK_INT
>
=
23
&
&
tunneling
)
{
tunnelingOnFrameRenderedListener
=
new
OnFrameRenderedListenerV23
(
codec
)
;
}
}
Override
protected
void
onCodecInitialized
(
String
name
long
initializedTimestampMs
long
initializationDurationMs
)
{
eventDispatcher
.
decoderInitialized
(
name
initializedTimestampMs
initializationDurationMs
)
;
}
Override
protected
void
onInputFormatChanged
(
Format
newFormat
)
throws
ExoPlaybackException
{
super
.
onInputFormatChanged
(
newFormat
)
;
eventDispatcher
.
inputFormatChanged
(
newFormat
)
;
pendingPixelWidthHeightRatio
=
getPixelWidthHeightRatio
(
newFormat
)
;
pendingRotationDegrees
=
getRotationDegrees
(
newFormat
)
;
}
Override
protected
void
onQueueInputBuffer
(
DecoderInputBuffer
buffer
)
{
if
(
Util
.
SDK_INT
<
23
&
&
tunneling
)
{
maybeNotifyRenderedFirstFrame
(
)
;
}
}
Override
protected
void
onOutputFormatChanged
(
MediaCodec
codec
android
.
media
.
MediaFormat
outputFormat
)
{
boolean
hasCrop
=
outputFormat
.
containsKey
(
KEY_CROP_RIGHT
)
&
&
outputFormat
.
containsKey
(
KEY_CROP_LEFT
)
&
&
outputFormat
.
containsKey
(
KEY_CROP_BOTTOM
)
&
&
outputFormat
.
containsKey
(
KEY_CROP_TOP
)
;
currentWidth
=
hasCrop
?
outputFormat
.
getInteger
(
KEY_CROP_RIGHT
)
-
outputFormat
.
getInteger
(
KEY_CROP_LEFT
)
+
1
:
outputFormat
.
getInteger
(
MediaFormat
.
KEY_WIDTH
)
;
currentHeight
=
hasCrop
?
outputFormat
.
getInteger
(
KEY_CROP_BOTTOM
)
-
outputFormat
.
getInteger
(
KEY_CROP_TOP
)
+
1
:
outputFormat
.
getInteger
(
MediaFormat
.
KEY_HEIGHT
)
;
currentPixelWidthHeightRatio
=
pendingPixelWidthHeightRatio
;
if
(
Util
.
SDK_INT
>
=
21
)
{
if
(
pendingRotationDegrees
=
=
90
|
|
pendingRotationDegrees
=
=
270
)
{
int
rotatedHeight
=
currentWidth
;
currentWidth
=
currentHeight
;
currentHeight
=
rotatedHeight
;
currentPixelWidthHeightRatio
=
1
/
currentPixelWidthHeightRatio
;
}
}
else
{
currentUnappliedRotationDegrees
=
pendingRotationDegrees
;
}
setVideoScalingMode
(
codec
scalingMode
)
;
}
Override
protected
boolean
canReconfigureCodec
(
MediaCodec
codec
boolean
codecIsAdaptive
Format
oldFormat
Format
newFormat
)
{
return
areAdaptationCompatible
(
oldFormat
newFormat
)
&
&
newFormat
.
width
<
=
codecMaxValues
.
width
&
&
newFormat
.
height
<
=
codecMaxValues
.
height
&
&
newFormat
.
maxInputSize
<
=
codecMaxValues
.
inputSize
&
&
(
codecIsAdaptive
|
|
(
oldFormat
.
width
=
=
newFormat
.
width
&
&
oldFormat
.
height
=
=
newFormat
.
height
)
)
;
}
Override
protected
boolean
processOutputBuffer
(
long
positionUs
long
elapsedRealtimeUs
MediaCodec
codec
ByteBuffer
buffer
int
bufferIndex
int
bufferFlags
long
bufferPresentationTimeUs
boolean
shouldSkip
)
{
if
(
shouldSkip
)
{
skipOutputBuffer
(
codec
bufferIndex
)
;
return
true
;
}
if
(
!
renderedFirstFrame
)
{
if
(
Util
.
SDK_INT
>
=
21
)
{
renderOutputBufferV21
(
codec
bufferIndex
System
.
nanoTime
(
)
)
;
}
else
{
renderOutputBuffer
(
codec
bufferIndex
)
;
}
return
true
;
}
if
(
getState
(
)
!
=
STATE_STARTED
)
{
return
false
;
}
long
elapsedSinceStartOfLoopUs
=
(
SystemClock
.
elapsedRealtime
(
)
*
1000
)
-
elapsedRealtimeUs
;
long
earlyUs
=
bufferPresentationTimeUs
-
positionUs
-
elapsedSinceStartOfLoopUs
;
long
systemTimeNs
=
System
.
nanoTime
(
)
;
long
unadjustedFrameReleaseTimeNs
=
systemTimeNs
+
(
earlyUs
*
1000
)
;
long
adjustedReleaseTimeNs
=
frameReleaseTimeHelper
.
adjustReleaseTime
(
bufferPresentationTimeUs
unadjustedFrameReleaseTimeNs
)
;
earlyUs
=
(
adjustedReleaseTimeNs
-
systemTimeNs
)
/
1000
;
if
(
shouldDropOutputBuffer
(
earlyUs
elapsedRealtimeUs
)
)
{
dropOutputBuffer
(
codec
bufferIndex
)
;
return
true
;
}
if
(
Util
.
SDK_INT
>
=
21
)
{
if
(
earlyUs
<
50000
)
{
renderOutputBufferV21
(
codec
bufferIndex
adjustedReleaseTimeNs
)
;
return
true
;
}
}
else
{
if
(
earlyUs
<
30000
)
{
if
(
earlyUs
>
11000
)
{
try
{
Thread
.
sleep
(
(
earlyUs
-
10000
)
/
1000
)
;
}
catch
(
InterruptedException
e
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
}
}
renderOutputBuffer
(
codec
bufferIndex
)
;
return
true
;
}
}
return
false
;
}
protected
boolean
shouldDropOutputBuffer
(
long
earlyUs
long
elapsedRealtimeUs
)
{
return
earlyUs
<
-
30000
;
}
private
void
skipOutputBuffer
(
MediaCodec
codec
int
bufferIndex
)
{
TraceUtil
.
beginSection
(
"
skipVideoBuffer
"
)
;
codec
.
releaseOutputBuffer
(
bufferIndex
false
)
;
TraceUtil
.
endSection
(
)
;
decoderCounters
.
skippedOutputBufferCount
+
+
;
}
private
void
dropOutputBuffer
(
MediaCodec
codec
int
bufferIndex
)
{
TraceUtil
.
beginSection
(
"
dropVideoBuffer
"
)
;
codec
.
releaseOutputBuffer
(
bufferIndex
false
)
;
TraceUtil
.
endSection
(
)
;
decoderCounters
.
droppedOutputBufferCount
+
+
;
droppedFrames
+
+
;
consecutiveDroppedFrameCount
+
+
;
decoderCounters
.
maxConsecutiveDroppedOutputBufferCount
=
Math
.
max
(
consecutiveDroppedFrameCount
decoderCounters
.
maxConsecutiveDroppedOutputBufferCount
)
;
if
(
droppedFrames
=
=
maxDroppedFramesToNotify
)
{
maybeNotifyDroppedFrames
(
)
;
}
}
private
void
renderOutputBuffer
(
MediaCodec
codec
int
bufferIndex
)
{
maybeNotifyVideoSizeChanged
(
)
;
TraceUtil
.
beginSection
(
"
releaseOutputBuffer
"
)
;
codec
.
releaseOutputBuffer
(
bufferIndex
true
)
;
TraceUtil
.
endSection
(
)
;
decoderCounters
.
renderedOutputBufferCount
+
+
;
consecutiveDroppedFrameCount
=
0
;
maybeNotifyRenderedFirstFrame
(
)
;
}
TargetApi
(
21
)
private
void
renderOutputBufferV21
(
MediaCodec
codec
int
bufferIndex
long
releaseTimeNs
)
{
maybeNotifyVideoSizeChanged
(
)
;
TraceUtil
.
beginSection
(
"
releaseOutputBuffer
"
)
;
codec
.
releaseOutputBuffer
(
bufferIndex
releaseTimeNs
)
;
TraceUtil
.
endSection
(
)
;
decoderCounters
.
renderedOutputBufferCount
+
+
;
consecutiveDroppedFrameCount
=
0
;
maybeNotifyRenderedFirstFrame
(
)
;
}
private
void
setJoiningDeadlineMs
(
)
{
joiningDeadlineMs
=
allowedJoiningTimeMs
>
0
?
(
SystemClock
.
elapsedRealtime
(
)
+
allowedJoiningTimeMs
)
:
C
.
TIME_UNSET
;
}
private
void
clearRenderedFirstFrame
(
)
{
renderedFirstFrame
=
false
;
if
(
Util
.
SDK_INT
>
=
23
&
&
tunneling
)
{
MediaCodec
codec
=
getCodec
(
)
;
if
(
codec
!
=
null
)
{
tunnelingOnFrameRenderedListener
=
new
OnFrameRenderedListenerV23
(
codec
)
;
}
}
}
void
maybeNotifyRenderedFirstFrame
(
)
{
if
(
!
renderedFirstFrame
)
{
renderedFirstFrame
=
true
;
eventDispatcher
.
renderedFirstFrame
(
surface
)
;
}
}
private
void
maybeRenotifyRenderedFirstFrame
(
)
{
if
(
renderedFirstFrame
)
{
eventDispatcher
.
renderedFirstFrame
(
surface
)
;
}
}
private
void
clearReportedVideoSize
(
)
{
reportedWidth
=
Format
.
NO_VALUE
;
reportedHeight
=
Format
.
NO_VALUE
;
reportedPixelWidthHeightRatio
=
Format
.
NO_VALUE
;
reportedUnappliedRotationDegrees
=
Format
.
NO_VALUE
;
}
private
void
maybeNotifyVideoSizeChanged
(
)
{
if
(
reportedWidth
!
=
currentWidth
|
|
reportedHeight
!
=
currentHeight
|
|
reportedUnappliedRotationDegrees
!
=
currentUnappliedRotationDegrees
|
|
reportedPixelWidthHeightRatio
!
=
currentPixelWidthHeightRatio
)
{
eventDispatcher
.
videoSizeChanged
(
currentWidth
currentHeight
currentUnappliedRotationDegrees
currentPixelWidthHeightRatio
)
;
reportedWidth
=
currentWidth
;
reportedHeight
=
currentHeight
;
reportedUnappliedRotationDegrees
=
currentUnappliedRotationDegrees
;
reportedPixelWidthHeightRatio
=
currentPixelWidthHeightRatio
;
}
}
private
void
maybeRenotifyVideoSizeChanged
(
)
{
if
(
reportedWidth
!
=
Format
.
NO_VALUE
|
|
reportedHeight
!
=
Format
.
NO_VALUE
)
{
eventDispatcher
.
videoSizeChanged
(
currentWidth
currentHeight
currentUnappliedRotationDegrees
currentPixelWidthHeightRatio
)
;
}
}
private
void
maybeNotifyDroppedFrames
(
)
{
if
(
droppedFrames
>
0
)
{
long
now
=
SystemClock
.
elapsedRealtime
(
)
;
long
elapsedMs
=
now
-
droppedFrameAccumulationStartTimeMs
;
eventDispatcher
.
droppedFrames
(
droppedFrames
elapsedMs
)
;
droppedFrames
=
0
;
droppedFrameAccumulationStartTimeMs
=
now
;
}
}
SuppressLint
(
"
InlinedApi
"
)
private
static
MediaFormat
getMediaFormat
(
Format
format
CodecMaxValues
codecMaxValues
boolean
deviceNeedsAutoFrcWorkaround
int
tunnelingAudioSessionId
)
{
MediaFormat
frameworkMediaFormat
=
format
.
getFrameworkMediaFormatV16
(
)
;
frameworkMediaFormat
.
setInteger
(
MediaFormat
.
KEY_MAX_WIDTH
codecMaxValues
.
width
)
;
frameworkMediaFormat
.
setInteger
(
MediaFormat
.
KEY_MAX_HEIGHT
codecMaxValues
.
height
)
;
if
(
codecMaxValues
.
inputSize
!
=
Format
.
NO_VALUE
)
{
frameworkMediaFormat
.
setInteger
(
MediaFormat
.
KEY_MAX_INPUT_SIZE
codecMaxValues
.
inputSize
)
;
}
if
(
deviceNeedsAutoFrcWorkaround
)
{
frameworkMediaFormat
.
setInteger
(
"
auto
-
frc
"
0
)
;
}
if
(
tunnelingAudioSessionId
!
=
C
.
AUDIO_SESSION_ID_UNSET
)
{
configureTunnelingV21
(
frameworkMediaFormat
tunnelingAudioSessionId
)
;
}
return
frameworkMediaFormat
;
}
TargetApi
(
23
)
private
static
void
setOutputSurfaceV23
(
MediaCodec
codec
Surface
surface
)
{
codec
.
setOutputSurface
(
surface
)
;
}
TargetApi
(
21
)
private
static
void
configureTunnelingV21
(
MediaFormat
mediaFormat
int
tunnelingAudioSessionId
)
{
mediaFormat
.
setFeatureEnabled
(
CodecCapabilities
.
FEATURE_TunneledPlayback
true
)
;
mediaFormat
.
setInteger
(
MediaFormat
.
KEY_AUDIO_SESSION_ID
tunnelingAudioSessionId
)
;
}
private
static
CodecMaxValues
getCodecMaxValues
(
MediaCodecInfo
codecInfo
Format
format
Format
[
]
streamFormats
)
throws
DecoderQueryException
{
int
maxWidth
=
format
.
width
;
int
maxHeight
=
format
.
height
;
int
maxInputSize
=
getMaxInputSize
(
format
)
;
if
(
streamFormats
.
length
=
=
1
)
{
return
new
CodecMaxValues
(
maxWidth
maxHeight
maxInputSize
)
;
}
boolean
haveUnknownDimensions
=
false
;
for
(
Format
streamFormat
:
streamFormats
)
{
if
(
areAdaptationCompatible
(
format
streamFormat
)
)
{
haveUnknownDimensions
|
=
(
streamFormat
.
width
=
=
Format
.
NO_VALUE
|
|
streamFormat
.
height
=
=
Format
.
NO_VALUE
)
;
maxWidth
=
Math
.
max
(
maxWidth
streamFormat
.
width
)
;
maxHeight
=
Math
.
max
(
maxHeight
streamFormat
.
height
)
;
maxInputSize
=
Math
.
max
(
maxInputSize
getMaxInputSize
(
streamFormat
)
)
;
}
}
if
(
haveUnknownDimensions
)
{
Log
.
w
(
TAG
"
Resolutions
unknown
.
Codec
max
resolution
:
"
+
maxWidth
+
"
x
"
+
maxHeight
)
;
Point
codecMaxSize
=
getCodecMaxSize
(
codecInfo
format
)
;
if
(
codecMaxSize
!
=
null
)
{
maxWidth
=
Math
.
max
(
maxWidth
codecMaxSize
.
x
)
;
maxHeight
=
Math
.
max
(
maxHeight
codecMaxSize
.
y
)
;
maxInputSize
=
Math
.
max
(
maxInputSize
getMaxInputSize
(
format
.
sampleMimeType
maxWidth
maxHeight
)
)
;
Log
.
w
(
TAG
"
Codec
max
resolution
adjusted
to
:
"
+
maxWidth
+
"
x
"
+
maxHeight
)
;
}
}
return
new
CodecMaxValues
(
maxWidth
maxHeight
maxInputSize
)
;
}
private
static
Point
getCodecMaxSize
(
MediaCodecInfo
codecInfo
Format
format
)
throws
DecoderQueryException
{
boolean
isVerticalVideo
=
format
.
height
>
format
.
width
;
int
formatLongEdgePx
=
isVerticalVideo
?
format
.
height
:
format
.
width
;
int
formatShortEdgePx
=
isVerticalVideo
?
format
.
width
:
format
.
height
;
float
aspectRatio
=
(
float
)
formatShortEdgePx
/
formatLongEdgePx
;
for
(
int
longEdgePx
:
STANDARD_LONG_EDGE_VIDEO_PX
)
{
int
shortEdgePx
=
(
int
)
(
longEdgePx
*
aspectRatio
)
;
if
(
longEdgePx
<
=
formatLongEdgePx
|
|
shortEdgePx
<
=
formatShortEdgePx
)
{
return
null
;
}
else
if
(
Util
.
SDK_INT
>
=
21
)
{
Point
alignedSize
=
codecInfo
.
alignVideoSizeV21
(
isVerticalVideo
?
shortEdgePx
:
longEdgePx
isVerticalVideo
?
longEdgePx
:
shortEdgePx
)
;
float
frameRate
=
format
.
frameRate
;
if
(
codecInfo
.
isVideoSizeAndRateSupportedV21
(
alignedSize
.
x
alignedSize
.
y
frameRate
)
)
{
return
alignedSize
;
}
}
else
{
longEdgePx
=
Util
.
ceilDivide
(
longEdgePx
16
)
*
16
;
shortEdgePx
=
Util
.
ceilDivide
(
shortEdgePx
16
)
*
16
;
if
(
longEdgePx
*
shortEdgePx
<
=
MediaCodecUtil
.
maxH264DecodableFrameSize
(
)
)
{
return
new
Point
(
isVerticalVideo
?
shortEdgePx
:
longEdgePx
isVerticalVideo
?
longEdgePx
:
shortEdgePx
)
;
}
}
}
return
null
;
}
private
static
int
getMaxInputSize
(
Format
format
)
{
if
(
format
.
maxInputSize
!
=
Format
.
NO_VALUE
)
{
return
format
.
maxInputSize
;
}
return
getMaxInputSize
(
format
.
sampleMimeType
format
.
width
format
.
height
)
;
}
private
static
int
getMaxInputSize
(
String
sampleMimeType
int
width
int
height
)
{
if
(
width
=
=
Format
.
NO_VALUE
|
|
height
=
=
Format
.
NO_VALUE
)
{
return
Format
.
NO_VALUE
;
}
int
maxPixels
;
int
minCompressionRatio
;
switch
(
sampleMimeType
)
{
case
MimeTypes
.
VIDEO_H263
:
case
MimeTypes
.
VIDEO_MP4V
:
maxPixels
=
width
*
height
;
minCompressionRatio
=
2
;
break
;
case
MimeTypes
.
VIDEO_H264
:
if
(
"
BRAVIA
4K
2015
"
.
equals
(
Util
.
MODEL
)
)
{
return
Format
.
NO_VALUE
;
}
maxPixels
=
Util
.
ceilDivide
(
width
16
)
*
Util
.
ceilDivide
(
height
16
)
*
16
*
16
;
minCompressionRatio
=
2
;
break
;
case
MimeTypes
.
VIDEO_VP8
:
maxPixels
=
width
*
height
;
minCompressionRatio
=
2
;
break
;
case
MimeTypes
.
VIDEO_H265
:
case
MimeTypes
.
VIDEO_VP9
:
maxPixels
=
width
*
height
;
minCompressionRatio
=
4
;
break
;
default
:
return
Format
.
NO_VALUE
;
}
return
(
maxPixels
*
3
)
/
(
2
*
minCompressionRatio
)
;
}
private
static
void
setVideoScalingMode
(
MediaCodec
codec
int
scalingMode
)
{
codec
.
setVideoScalingMode
(
scalingMode
)
;
}
private
static
boolean
deviceNeedsAutoFrcWorkaround
(
)
{
return
Util
.
SDK_INT
<
=
22
&
&
"
foster
"
.
equals
(
Util
.
DEVICE
)
&
&
"
NVIDIA
"
.
equals
(
Util
.
MANUFACTURER
)
;
}
private
static
boolean
areAdaptationCompatible
(
Format
first
Format
second
)
{
return
first
.
sampleMimeType
.
equals
(
second
.
sampleMimeType
)
&
&
getRotationDegrees
(
first
)
=
=
getRotationDegrees
(
second
)
;
}
private
static
float
getPixelWidthHeightRatio
(
Format
format
)
{
return
format
.
pixelWidthHeightRatio
=
=
Format
.
NO_VALUE
?
1
:
format
.
pixelWidthHeightRatio
;
}
private
static
int
getRotationDegrees
(
Format
format
)
{
return
format
.
rotationDegrees
=
=
Format
.
NO_VALUE
?
0
:
format
.
rotationDegrees
;
}
private
static
final
class
CodecMaxValues
{
public
final
int
width
;
public
final
int
height
;
public
final
int
inputSize
;
public
CodecMaxValues
(
int
width
int
height
int
inputSize
)
{
this
.
width
=
width
;
this
.
height
=
height
;
this
.
inputSize
=
inputSize
;
}
}
TargetApi
(
23
)
private
final
class
OnFrameRenderedListenerV23
implements
MediaCodec
.
OnFrameRenderedListener
{
private
OnFrameRenderedListenerV23
(
MediaCodec
codec
)
{
codec
.
setOnFrameRenderedListener
(
this
new
Handler
(
)
)
;
}
Override
public
void
onFrameRendered
(
NonNull
MediaCodec
codec
long
presentationTimeUs
long
nanoTime
)
{
if
(
this
!
=
tunnelingOnFrameRenderedListener
)
{
return
;
}
maybeNotifyRenderedFirstFrame
(
)
;
}
}
}
