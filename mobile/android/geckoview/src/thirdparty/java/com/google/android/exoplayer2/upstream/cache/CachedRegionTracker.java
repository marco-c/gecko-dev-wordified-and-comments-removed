package
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
util
.
Log
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ChunkIndex
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
NavigableSet
;
import
java
.
util
.
TreeSet
;
public
final
class
CachedRegionTracker
implements
Cache
.
Listener
{
private
static
final
String
TAG
=
"
CachedRegionTracker
"
;
public
static
final
int
NOT_CACHED
=
-
1
;
public
static
final
int
CACHED_TO_END
=
-
2
;
private
final
Cache
cache
;
private
final
String
cacheKey
;
private
final
ChunkIndex
chunkIndex
;
private
final
TreeSet
<
Region
>
regions
;
private
final
Region
lookupRegion
;
public
CachedRegionTracker
(
Cache
cache
String
cacheKey
ChunkIndex
chunkIndex
)
{
this
.
cache
=
cache
;
this
.
cacheKey
=
cacheKey
;
this
.
chunkIndex
=
chunkIndex
;
this
.
regions
=
new
TreeSet
<
>
(
)
;
this
.
lookupRegion
=
new
Region
(
0
0
)
;
synchronized
(
this
)
{
NavigableSet
<
CacheSpan
>
cacheSpans
=
cache
.
addListener
(
cacheKey
this
)
;
if
(
cacheSpans
!
=
null
)
{
Iterator
<
CacheSpan
>
spanIterator
=
cacheSpans
.
descendingIterator
(
)
;
while
(
spanIterator
.
hasNext
(
)
)
{
CacheSpan
span
=
spanIterator
.
next
(
)
;
mergeSpan
(
span
)
;
}
}
}
}
public
void
release
(
)
{
cache
.
removeListener
(
cacheKey
this
)
;
}
public
synchronized
int
getRegionEndTimeMs
(
long
byteOffset
)
{
lookupRegion
.
startOffset
=
byteOffset
;
Region
floorRegion
=
regions
.
floor
(
lookupRegion
)
;
if
(
floorRegion
=
=
null
|
|
byteOffset
>
floorRegion
.
endOffset
|
|
floorRegion
.
endOffsetIndex
=
=
-
1
)
{
return
NOT_CACHED
;
}
int
index
=
floorRegion
.
endOffsetIndex
;
if
(
index
=
=
chunkIndex
.
length
-
1
&
&
floorRegion
.
endOffset
=
=
(
chunkIndex
.
offsets
[
index
]
+
chunkIndex
.
sizes
[
index
]
)
)
{
return
CACHED_TO_END
;
}
long
segmentFractionUs
=
(
chunkIndex
.
durationsUs
[
index
]
*
(
floorRegion
.
endOffset
-
chunkIndex
.
offsets
[
index
]
)
)
/
chunkIndex
.
sizes
[
index
]
;
return
(
int
)
(
(
chunkIndex
.
timesUs
[
index
]
+
segmentFractionUs
)
/
1000
)
;
}
Override
public
synchronized
void
onSpanAdded
(
Cache
cache
CacheSpan
span
)
{
mergeSpan
(
span
)
;
}
Override
public
synchronized
void
onSpanRemoved
(
Cache
cache
CacheSpan
span
)
{
Region
removedRegion
=
new
Region
(
span
.
position
span
.
position
+
span
.
length
)
;
Region
floorRegion
=
regions
.
floor
(
removedRegion
)
;
if
(
floorRegion
=
=
null
)
{
Log
.
e
(
TAG
"
Removed
a
span
we
were
not
aware
of
"
)
;
return
;
}
regions
.
remove
(
floorRegion
)
;
if
(
floorRegion
.
startOffset
<
removedRegion
.
startOffset
)
{
Region
newFloorRegion
=
new
Region
(
floorRegion
.
startOffset
removedRegion
.
startOffset
)
;
int
index
=
Arrays
.
binarySearch
(
chunkIndex
.
offsets
newFloorRegion
.
endOffset
)
;
newFloorRegion
.
endOffsetIndex
=
index
<
0
?
-
index
-
2
:
index
;
regions
.
add
(
newFloorRegion
)
;
}
if
(
floorRegion
.
endOffset
>
removedRegion
.
endOffset
)
{
Region
newCeilingRegion
=
new
Region
(
removedRegion
.
endOffset
+
1
floorRegion
.
endOffset
)
;
newCeilingRegion
.
endOffsetIndex
=
floorRegion
.
endOffsetIndex
;
regions
.
add
(
newCeilingRegion
)
;
}
}
Override
public
void
onSpanTouched
(
Cache
cache
CacheSpan
oldSpan
CacheSpan
newSpan
)
{
}
private
void
mergeSpan
(
CacheSpan
span
)
{
Region
newRegion
=
new
Region
(
span
.
position
span
.
position
+
span
.
length
)
;
Region
floorRegion
=
regions
.
floor
(
newRegion
)
;
Region
ceilingRegion
=
regions
.
ceiling
(
newRegion
)
;
boolean
floorConnects
=
regionsConnect
(
floorRegion
newRegion
)
;
boolean
ceilingConnects
=
regionsConnect
(
newRegion
ceilingRegion
)
;
if
(
ceilingConnects
)
{
if
(
floorConnects
)
{
floorRegion
.
endOffset
=
ceilingRegion
.
endOffset
;
floorRegion
.
endOffsetIndex
=
ceilingRegion
.
endOffsetIndex
;
}
else
{
newRegion
.
endOffset
=
ceilingRegion
.
endOffset
;
newRegion
.
endOffsetIndex
=
ceilingRegion
.
endOffsetIndex
;
regions
.
add
(
newRegion
)
;
}
regions
.
remove
(
ceilingRegion
)
;
}
else
if
(
floorConnects
)
{
floorRegion
.
endOffset
=
newRegion
.
endOffset
;
int
index
=
floorRegion
.
endOffsetIndex
;
while
(
index
<
chunkIndex
.
length
-
1
&
&
(
chunkIndex
.
offsets
[
index
+
1
]
<
=
floorRegion
.
endOffset
)
)
{
index
+
+
;
}
floorRegion
.
endOffsetIndex
=
index
;
}
else
{
int
index
=
Arrays
.
binarySearch
(
chunkIndex
.
offsets
newRegion
.
endOffset
)
;
newRegion
.
endOffsetIndex
=
index
<
0
?
-
index
-
2
:
index
;
regions
.
add
(
newRegion
)
;
}
}
private
boolean
regionsConnect
(
Region
lower
Region
upper
)
{
return
lower
!
=
null
&
&
upper
!
=
null
&
&
lower
.
endOffset
=
=
upper
.
startOffset
;
}
private
static
class
Region
implements
Comparable
<
Region
>
{
public
long
startOffset
;
public
long
endOffset
;
public
int
endOffsetIndex
;
public
Region
(
long
position
long
endOffset
)
{
this
.
startOffset
=
position
;
this
.
endOffset
=
endOffset
;
}
Override
public
int
compareTo
(
NonNull
Region
another
)
{
return
startOffset
<
another
.
startOffset
?
-
1
:
startOffset
=
=
another
.
startOffset
?
0
:
1
;
}
}
}
