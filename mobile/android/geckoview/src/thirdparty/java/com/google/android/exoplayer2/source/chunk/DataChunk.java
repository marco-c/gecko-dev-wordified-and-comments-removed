package
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
public
abstract
class
DataChunk
extends
Chunk
{
private
static
final
int
READ_GRANULARITY
=
16
*
1024
;
private
byte
[
]
data
;
private
int
limit
;
private
volatile
boolean
loadCanceled
;
public
DataChunk
(
DataSource
dataSource
DataSpec
dataSpec
int
type
Format
trackFormat
int
trackSelectionReason
Object
trackSelectionData
byte
[
]
data
)
{
super
(
dataSource
dataSpec
type
trackFormat
trackSelectionReason
trackSelectionData
C
.
TIME_UNSET
C
.
TIME_UNSET
)
;
this
.
data
=
data
;
}
public
byte
[
]
getDataHolder
(
)
{
return
data
;
}
Override
public
long
bytesLoaded
(
)
{
return
limit
;
}
Override
public
final
void
cancelLoad
(
)
{
loadCanceled
=
true
;
}
Override
public
final
boolean
isLoadCanceled
(
)
{
return
loadCanceled
;
}
Override
public
final
void
load
(
)
throws
IOException
InterruptedException
{
try
{
dataSource
.
open
(
dataSpec
)
;
limit
=
0
;
int
bytesRead
=
0
;
while
(
bytesRead
!
=
C
.
RESULT_END_OF_INPUT
&
&
!
loadCanceled
)
{
maybeExpandData
(
)
;
bytesRead
=
dataSource
.
read
(
data
limit
READ_GRANULARITY
)
;
if
(
bytesRead
!
=
-
1
)
{
limit
+
=
bytesRead
;
}
}
if
(
!
loadCanceled
)
{
consume
(
data
limit
)
;
}
}
finally
{
Util
.
closeQuietly
(
dataSource
)
;
}
}
protected
abstract
void
consume
(
byte
[
]
data
int
limit
)
throws
IOException
;
private
void
maybeExpandData
(
)
{
if
(
data
=
=
null
)
{
data
=
new
byte
[
READ_GRANULARITY
]
;
}
else
if
(
data
.
length
<
limit
+
READ_GRANULARITY
)
{
data
=
Arrays
.
copyOf
(
data
data
.
length
+
READ_GRANULARITY
)
;
}
}
}
