package
com
.
google
.
android
.
exoplayer2
.
trackselection
;
import
android
.
content
.
Context
;
import
android
.
util
.
SparseArray
;
import
android
.
util
.
SparseBooleanArray
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
;
import
com
.
google
.
android
.
exoplayer2
.
RendererConfiguration
;
import
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroupArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
public
abstract
class
MappingTrackSelector
extends
TrackSelector
{
public
static
final
class
SelectionOverride
{
public
final
TrackSelection
.
Factory
factory
;
public
final
int
groupIndex
;
public
final
int
[
]
tracks
;
public
final
int
length
;
public
SelectionOverride
(
TrackSelection
.
Factory
factory
int
groupIndex
int
.
.
.
tracks
)
{
this
.
factory
=
factory
;
this
.
groupIndex
=
groupIndex
;
this
.
tracks
=
tracks
;
this
.
length
=
tracks
.
length
;
}
public
TrackSelection
createTrackSelection
(
TrackGroupArray
groups
)
{
return
factory
.
createTrackSelection
(
groups
.
get
(
groupIndex
)
tracks
)
;
}
public
boolean
containsTrack
(
int
track
)
{
for
(
int
overrideTrack
:
tracks
)
{
if
(
overrideTrack
=
=
track
)
{
return
true
;
}
}
return
false
;
}
}
private
final
SparseArray
<
Map
<
TrackGroupArray
SelectionOverride
>
>
selectionOverrides
;
private
final
SparseBooleanArray
rendererDisabledFlags
;
private
int
tunnelingAudioSessionId
;
private
MappedTrackInfo
currentMappedTrackInfo
;
public
MappingTrackSelector
(
)
{
selectionOverrides
=
new
SparseArray
<
>
(
)
;
rendererDisabledFlags
=
new
SparseBooleanArray
(
)
;
tunnelingAudioSessionId
=
C
.
AUDIO_SESSION_ID_UNSET
;
}
public
final
MappedTrackInfo
getCurrentMappedTrackInfo
(
)
{
return
currentMappedTrackInfo
;
}
public
final
void
setRendererDisabled
(
int
rendererIndex
boolean
disabled
)
{
if
(
rendererDisabledFlags
.
get
(
rendererIndex
)
=
=
disabled
)
{
return
;
}
rendererDisabledFlags
.
put
(
rendererIndex
disabled
)
;
invalidate
(
)
;
}
public
final
boolean
getRendererDisabled
(
int
rendererIndex
)
{
return
rendererDisabledFlags
.
get
(
rendererIndex
)
;
}
public
final
void
setSelectionOverride
(
int
rendererIndex
TrackGroupArray
groups
SelectionOverride
override
)
{
Map
<
TrackGroupArray
SelectionOverride
>
overrides
=
selectionOverrides
.
get
(
rendererIndex
)
;
if
(
overrides
=
=
null
)
{
overrides
=
new
HashMap
<
>
(
)
;
selectionOverrides
.
put
(
rendererIndex
overrides
)
;
}
if
(
overrides
.
containsKey
(
groups
)
&
&
Util
.
areEqual
(
overrides
.
get
(
groups
)
override
)
)
{
return
;
}
overrides
.
put
(
groups
override
)
;
invalidate
(
)
;
}
public
final
boolean
hasSelectionOverride
(
int
rendererIndex
TrackGroupArray
groups
)
{
Map
<
TrackGroupArray
SelectionOverride
>
overrides
=
selectionOverrides
.
get
(
rendererIndex
)
;
return
overrides
!
=
null
&
&
overrides
.
containsKey
(
groups
)
;
}
public
final
SelectionOverride
getSelectionOverride
(
int
rendererIndex
TrackGroupArray
groups
)
{
Map
<
TrackGroupArray
SelectionOverride
>
overrides
=
selectionOverrides
.
get
(
rendererIndex
)
;
return
overrides
!
=
null
?
overrides
.
get
(
groups
)
:
null
;
}
public
final
void
clearSelectionOverride
(
int
rendererIndex
TrackGroupArray
groups
)
{
Map
<
TrackGroupArray
SelectionOverride
>
overrides
=
selectionOverrides
.
get
(
rendererIndex
)
;
if
(
overrides
=
=
null
|
|
!
overrides
.
containsKey
(
groups
)
)
{
return
;
}
overrides
.
remove
(
groups
)
;
if
(
overrides
.
isEmpty
(
)
)
{
selectionOverrides
.
remove
(
rendererIndex
)
;
}
invalidate
(
)
;
}
public
final
void
clearSelectionOverrides
(
int
rendererIndex
)
{
Map
<
TrackGroupArray
?
>
overrides
=
selectionOverrides
.
get
(
rendererIndex
)
;
if
(
overrides
=
=
null
|
|
overrides
.
isEmpty
(
)
)
{
return
;
}
selectionOverrides
.
remove
(
rendererIndex
)
;
invalidate
(
)
;
}
public
final
void
clearSelectionOverrides
(
)
{
if
(
selectionOverrides
.
size
(
)
=
=
0
)
{
return
;
}
selectionOverrides
.
clear
(
)
;
invalidate
(
)
;
}
public
void
setTunnelingAudioSessionId
(
int
tunnelingAudioSessionId
)
{
if
(
this
.
tunnelingAudioSessionId
!
=
tunnelingAudioSessionId
)
{
this
.
tunnelingAudioSessionId
=
tunnelingAudioSessionId
;
invalidate
(
)
;
}
}
Override
public
final
TrackSelectorResult
selectTracks
(
RendererCapabilities
[
]
rendererCapabilities
TrackGroupArray
trackGroups
)
throws
ExoPlaybackException
{
int
[
]
rendererTrackGroupCounts
=
new
int
[
rendererCapabilities
.
length
+
1
]
;
TrackGroup
[
]
[
]
rendererTrackGroups
=
new
TrackGroup
[
rendererCapabilities
.
length
+
1
]
[
]
;
int
[
]
[
]
[
]
rendererFormatSupports
=
new
int
[
rendererCapabilities
.
length
+
1
]
[
]
[
]
;
for
(
int
i
=
0
;
i
<
rendererTrackGroups
.
length
;
i
+
+
)
{
rendererTrackGroups
[
i
]
=
new
TrackGroup
[
trackGroups
.
length
]
;
rendererFormatSupports
[
i
]
=
new
int
[
trackGroups
.
length
]
[
]
;
}
int
[
]
mixedMimeTypeAdaptationSupport
=
getMixedMimeTypeAdaptationSupport
(
rendererCapabilities
)
;
for
(
int
groupIndex
=
0
;
groupIndex
<
trackGroups
.
length
;
groupIndex
+
+
)
{
TrackGroup
group
=
trackGroups
.
get
(
groupIndex
)
;
int
rendererIndex
=
findRenderer
(
rendererCapabilities
group
)
;
int
[
]
rendererFormatSupport
=
rendererIndex
=
=
rendererCapabilities
.
length
?
new
int
[
group
.
length
]
:
getFormatSupport
(
rendererCapabilities
[
rendererIndex
]
group
)
;
int
rendererTrackGroupCount
=
rendererTrackGroupCounts
[
rendererIndex
]
;
rendererTrackGroups
[
rendererIndex
]
[
rendererTrackGroupCount
]
=
group
;
rendererFormatSupports
[
rendererIndex
]
[
rendererTrackGroupCount
]
=
rendererFormatSupport
;
rendererTrackGroupCounts
[
rendererIndex
]
+
+
;
}
TrackGroupArray
[
]
rendererTrackGroupArrays
=
new
TrackGroupArray
[
rendererCapabilities
.
length
]
;
int
[
]
rendererTrackTypes
=
new
int
[
rendererCapabilities
.
length
]
;
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
int
rendererTrackGroupCount
=
rendererTrackGroupCounts
[
i
]
;
rendererTrackGroupArrays
[
i
]
=
new
TrackGroupArray
(
Arrays
.
copyOf
(
rendererTrackGroups
[
i
]
rendererTrackGroupCount
)
)
;
rendererFormatSupports
[
i
]
=
Arrays
.
copyOf
(
rendererFormatSupports
[
i
]
rendererTrackGroupCount
)
;
rendererTrackTypes
[
i
]
=
rendererCapabilities
[
i
]
.
getTrackType
(
)
;
}
int
unassociatedTrackGroupCount
=
rendererTrackGroupCounts
[
rendererCapabilities
.
length
]
;
TrackGroupArray
unassociatedTrackGroupArray
=
new
TrackGroupArray
(
Arrays
.
copyOf
(
rendererTrackGroups
[
rendererCapabilities
.
length
]
unassociatedTrackGroupCount
)
)
;
TrackSelection
[
]
trackSelections
=
selectTracks
(
rendererCapabilities
rendererTrackGroupArrays
rendererFormatSupports
)
;
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
if
(
rendererDisabledFlags
.
get
(
i
)
)
{
trackSelections
[
i
]
=
null
;
}
else
{
TrackGroupArray
rendererTrackGroup
=
rendererTrackGroupArrays
[
i
]
;
Map
<
TrackGroupArray
SelectionOverride
>
overrides
=
selectionOverrides
.
get
(
i
)
;
SelectionOverride
override
=
overrides
=
=
null
?
null
:
overrides
.
get
(
rendererTrackGroup
)
;
if
(
override
!
=
null
)
{
trackSelections
[
i
]
=
override
.
createTrackSelection
(
rendererTrackGroup
)
;
}
}
}
MappedTrackInfo
mappedTrackInfo
=
new
MappedTrackInfo
(
rendererTrackTypes
rendererTrackGroupArrays
mixedMimeTypeAdaptationSupport
rendererFormatSupports
unassociatedTrackGroupArray
)
;
RendererConfiguration
[
]
rendererConfigurations
=
new
RendererConfiguration
[
rendererCapabilities
.
length
]
;
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
rendererConfigurations
[
i
]
=
trackSelections
[
i
]
!
=
null
?
RendererConfiguration
.
DEFAULT
:
null
;
}
maybeConfigureRenderersForTunneling
(
rendererCapabilities
rendererTrackGroupArrays
rendererFormatSupports
rendererConfigurations
trackSelections
tunnelingAudioSessionId
)
;
return
new
TrackSelectorResult
(
trackGroups
new
TrackSelectionArray
(
trackSelections
)
mappedTrackInfo
rendererConfigurations
)
;
}
Override
public
final
void
onSelectionActivated
(
Object
info
)
{
currentMappedTrackInfo
=
(
MappedTrackInfo
)
info
;
}
protected
abstract
TrackSelection
[
]
selectTracks
(
RendererCapabilities
[
]
rendererCapabilities
TrackGroupArray
[
]
rendererTrackGroupArrays
int
[
]
[
]
[
]
rendererFormatSupports
)
throws
ExoPlaybackException
;
private
static
int
findRenderer
(
RendererCapabilities
[
]
rendererCapabilities
TrackGroup
group
)
throws
ExoPlaybackException
{
int
bestRendererIndex
=
rendererCapabilities
.
length
;
int
bestFormatSupportLevel
=
RendererCapabilities
.
FORMAT_UNSUPPORTED_TYPE
;
for
(
int
rendererIndex
=
0
;
rendererIndex
<
rendererCapabilities
.
length
;
rendererIndex
+
+
)
{
RendererCapabilities
rendererCapability
=
rendererCapabilities
[
rendererIndex
]
;
for
(
int
trackIndex
=
0
;
trackIndex
<
group
.
length
;
trackIndex
+
+
)
{
int
formatSupportLevel
=
rendererCapability
.
supportsFormat
(
group
.
getFormat
(
trackIndex
)
)
&
RendererCapabilities
.
FORMAT_SUPPORT_MASK
;
if
(
formatSupportLevel
>
bestFormatSupportLevel
)
{
bestRendererIndex
=
rendererIndex
;
bestFormatSupportLevel
=
formatSupportLevel
;
if
(
bestFormatSupportLevel
=
=
RendererCapabilities
.
FORMAT_HANDLED
)
{
return
bestRendererIndex
;
}
}
}
}
return
bestRendererIndex
;
}
private
static
int
[
]
getFormatSupport
(
RendererCapabilities
rendererCapabilities
TrackGroup
group
)
throws
ExoPlaybackException
{
int
[
]
formatSupport
=
new
int
[
group
.
length
]
;
for
(
int
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
formatSupport
[
i
]
=
rendererCapabilities
.
supportsFormat
(
group
.
getFormat
(
i
)
)
;
}
return
formatSupport
;
}
private
static
int
[
]
getMixedMimeTypeAdaptationSupport
(
RendererCapabilities
[
]
rendererCapabilities
)
throws
ExoPlaybackException
{
int
[
]
mixedMimeTypeAdaptationSupport
=
new
int
[
rendererCapabilities
.
length
]
;
for
(
int
i
=
0
;
i
<
mixedMimeTypeAdaptationSupport
.
length
;
i
+
+
)
{
mixedMimeTypeAdaptationSupport
[
i
]
=
rendererCapabilities
[
i
]
.
supportsMixedMimeTypeAdaptation
(
)
;
}
return
mixedMimeTypeAdaptationSupport
;
}
private
static
void
maybeConfigureRenderersForTunneling
(
RendererCapabilities
[
]
rendererCapabilities
TrackGroupArray
[
]
rendererTrackGroupArrays
int
[
]
[
]
[
]
rendererFormatSupports
RendererConfiguration
[
]
rendererConfigurations
TrackSelection
[
]
trackSelections
int
tunnelingAudioSessionId
)
{
if
(
tunnelingAudioSessionId
=
=
C
.
AUDIO_SESSION_ID_UNSET
)
{
return
;
}
int
tunnelingAudioRendererIndex
=
-
1
;
int
tunnelingVideoRendererIndex
=
-
1
;
boolean
enableTunneling
=
true
;
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
int
rendererType
=
rendererCapabilities
[
i
]
.
getTrackType
(
)
;
TrackSelection
trackSelection
=
trackSelections
[
i
]
;
if
(
(
rendererType
=
=
C
.
TRACK_TYPE_AUDIO
|
|
rendererType
=
=
C
.
TRACK_TYPE_VIDEO
)
&
&
trackSelection
!
=
null
)
{
if
(
rendererSupportsTunneling
(
rendererFormatSupports
[
i
]
rendererTrackGroupArrays
[
i
]
trackSelection
)
)
{
if
(
rendererType
=
=
C
.
TRACK_TYPE_AUDIO
)
{
if
(
tunnelingAudioRendererIndex
!
=
-
1
)
{
enableTunneling
=
false
;
break
;
}
else
{
tunnelingAudioRendererIndex
=
i
;
}
}
else
{
if
(
tunnelingVideoRendererIndex
!
=
-
1
)
{
enableTunneling
=
false
;
break
;
}
else
{
tunnelingVideoRendererIndex
=
i
;
}
}
}
}
}
enableTunneling
&
=
tunnelingAudioRendererIndex
!
=
-
1
&
&
tunnelingVideoRendererIndex
!
=
-
1
;
if
(
enableTunneling
)
{
RendererConfiguration
tunnelingRendererConfiguration
=
new
RendererConfiguration
(
tunnelingAudioSessionId
)
;
rendererConfigurations
[
tunnelingAudioRendererIndex
]
=
tunnelingRendererConfiguration
;
rendererConfigurations
[
tunnelingVideoRendererIndex
]
=
tunnelingRendererConfiguration
;
}
}
private
static
boolean
rendererSupportsTunneling
(
int
[
]
[
]
formatSupport
TrackGroupArray
trackGroups
TrackSelection
selection
)
{
if
(
selection
=
=
null
)
{
return
false
;
}
int
trackGroupIndex
=
trackGroups
.
indexOf
(
selection
.
getTrackGroup
(
)
)
;
for
(
int
i
=
0
;
i
<
selection
.
length
(
)
;
i
+
+
)
{
int
trackFormatSupport
=
formatSupport
[
trackGroupIndex
]
[
selection
.
getIndexInTrackGroup
(
i
)
]
;
if
(
(
trackFormatSupport
&
RendererCapabilities
.
TUNNELING_SUPPORT_MASK
)
!
=
RendererCapabilities
.
TUNNELING_SUPPORTED
)
{
return
false
;
}
}
return
true
;
}
public
static
final
class
MappedTrackInfo
{
public
static
final
int
RENDERER_SUPPORT_NO_TRACKS
=
0
;
public
static
final
int
RENDERER_SUPPORT_UNSUPPORTED_TRACKS
=
1
;
public
static
final
int
RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS
=
2
;
public
static
final
int
RENDERER_SUPPORT_PLAYABLE_TRACKS
=
3
;
public
final
int
length
;
private
final
int
[
]
rendererTrackTypes
;
private
final
TrackGroupArray
[
]
trackGroups
;
private
final
int
[
]
mixedMimeTypeAdaptiveSupport
;
private
final
int
[
]
[
]
[
]
formatSupport
;
private
final
TrackGroupArray
unassociatedTrackGroups
;
MappedTrackInfo
(
int
[
]
rendererTrackTypes
TrackGroupArray
[
]
trackGroups
int
[
]
mixedMimeTypeAdaptiveSupport
int
[
]
[
]
[
]
formatSupport
TrackGroupArray
unassociatedTrackGroups
)
{
this
.
rendererTrackTypes
=
rendererTrackTypes
;
this
.
trackGroups
=
trackGroups
;
this
.
formatSupport
=
formatSupport
;
this
.
mixedMimeTypeAdaptiveSupport
=
mixedMimeTypeAdaptiveSupport
;
this
.
unassociatedTrackGroups
=
unassociatedTrackGroups
;
this
.
length
=
trackGroups
.
length
;
}
public
TrackGroupArray
getTrackGroups
(
int
rendererIndex
)
{
return
trackGroups
[
rendererIndex
]
;
}
public
int
getRendererSupport
(
int
rendererIndex
)
{
int
bestRendererSupport
=
RENDERER_SUPPORT_NO_TRACKS
;
int
[
]
[
]
rendererFormatSupport
=
formatSupport
[
rendererIndex
]
;
for
(
int
i
=
0
;
i
<
rendererFormatSupport
.
length
;
i
+
+
)
{
for
(
int
j
=
0
;
j
<
rendererFormatSupport
[
i
]
.
length
;
j
+
+
)
{
int
trackRendererSupport
;
switch
(
rendererFormatSupport
[
i
]
[
j
]
&
RendererCapabilities
.
FORMAT_SUPPORT_MASK
)
{
case
RendererCapabilities
.
FORMAT_HANDLED
:
return
RENDERER_SUPPORT_PLAYABLE_TRACKS
;
case
RendererCapabilities
.
FORMAT_EXCEEDS_CAPABILITIES
:
trackRendererSupport
=
RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS
;
break
;
default
:
trackRendererSupport
=
RENDERER_SUPPORT_UNSUPPORTED_TRACKS
;
break
;
}
bestRendererSupport
=
Math
.
max
(
bestRendererSupport
trackRendererSupport
)
;
}
}
return
bestRendererSupport
;
}
public
int
getTrackTypeRendererSupport
(
int
trackType
)
{
int
bestRendererSupport
=
RENDERER_SUPPORT_NO_TRACKS
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
rendererTrackTypes
[
i
]
=
=
trackType
)
{
bestRendererSupport
=
Math
.
max
(
bestRendererSupport
getRendererSupport
(
i
)
)
;
}
}
return
bestRendererSupport
;
}
public
int
getTrackFormatSupport
(
int
rendererIndex
int
groupIndex
int
trackIndex
)
{
return
formatSupport
[
rendererIndex
]
[
groupIndex
]
[
trackIndex
]
&
RendererCapabilities
.
FORMAT_SUPPORT_MASK
;
}
public
int
getAdaptiveSupport
(
int
rendererIndex
int
groupIndex
boolean
includeCapabilitiesExceededTracks
)
{
int
trackCount
=
trackGroups
[
rendererIndex
]
.
get
(
groupIndex
)
.
length
;
int
[
]
trackIndices
=
new
int
[
trackCount
]
;
int
trackIndexCount
=
0
;
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
int
fixedSupport
=
getTrackFormatSupport
(
rendererIndex
groupIndex
i
)
;
if
(
fixedSupport
=
=
RendererCapabilities
.
FORMAT_HANDLED
|
|
(
includeCapabilitiesExceededTracks
&
&
fixedSupport
=
=
RendererCapabilities
.
FORMAT_EXCEEDS_CAPABILITIES
)
)
{
trackIndices
[
trackIndexCount
+
+
]
=
i
;
}
}
trackIndices
=
Arrays
.
copyOf
(
trackIndices
trackIndexCount
)
;
return
getAdaptiveSupport
(
rendererIndex
groupIndex
trackIndices
)
;
}
public
int
getAdaptiveSupport
(
int
rendererIndex
int
groupIndex
int
[
]
trackIndices
)
{
int
handledTrackCount
=
0
;
int
adaptiveSupport
=
RendererCapabilities
.
ADAPTIVE_SEAMLESS
;
boolean
multipleMimeTypes
=
false
;
String
firstSampleMimeType
=
null
;
for
(
int
i
=
0
;
i
<
trackIndices
.
length
;
i
+
+
)
{
int
trackIndex
=
trackIndices
[
i
]
;
String
sampleMimeType
=
trackGroups
[
rendererIndex
]
.
get
(
groupIndex
)
.
getFormat
(
trackIndex
)
.
sampleMimeType
;
if
(
handledTrackCount
+
+
=
=
0
)
{
firstSampleMimeType
=
sampleMimeType
;
}
else
{
multipleMimeTypes
|
=
!
Util
.
areEqual
(
firstSampleMimeType
sampleMimeType
)
;
}
adaptiveSupport
=
Math
.
min
(
adaptiveSupport
formatSupport
[
rendererIndex
]
[
groupIndex
]
[
i
]
&
RendererCapabilities
.
ADAPTIVE_SUPPORT_MASK
)
;
}
return
multipleMimeTypes
?
Math
.
min
(
adaptiveSupport
mixedMimeTypeAdaptiveSupport
[
rendererIndex
]
)
:
adaptiveSupport
;
}
public
TrackGroupArray
getUnassociatedTrackGroups
(
)
{
return
unassociatedTrackGroups
;
}
}
}
