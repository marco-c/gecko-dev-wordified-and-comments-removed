package
com
.
google
.
android
.
exoplayer2
.
extractor
.
wav
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
java
.
io
.
IOException
;
public
final
class
WavExtractor
implements
Extractor
SeekMap
{
public
static
final
ExtractorsFactory
FACTORY
=
new
ExtractorsFactory
(
)
{
Override
public
Extractor
[
]
createExtractors
(
)
{
return
new
Extractor
[
]
{
new
WavExtractor
(
)
}
;
}
}
;
private
static
final
int
MAX_INPUT_SIZE
=
32
*
1024
;
private
ExtractorOutput
extractorOutput
;
private
TrackOutput
trackOutput
;
private
WavHeader
wavHeader
;
private
int
bytesPerFrame
;
private
int
pendingBytes
;
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
WavHeaderReader
.
peek
(
input
)
!
=
null
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
extractorOutput
=
output
;
trackOutput
=
output
.
track
(
0
C
.
TRACK_TYPE_AUDIO
)
;
wavHeader
=
null
;
output
.
endTracks
(
)
;
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
pendingBytes
=
0
;
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
if
(
wavHeader
=
=
null
)
{
wavHeader
=
WavHeaderReader
.
peek
(
input
)
;
if
(
wavHeader
=
=
null
)
{
throw
new
ParserException
(
"
Unsupported
or
unrecognized
wav
header
.
"
)
;
}
Format
format
=
Format
.
createAudioSampleFormat
(
null
MimeTypes
.
AUDIO_RAW
null
wavHeader
.
getBitrate
(
)
MAX_INPUT_SIZE
wavHeader
.
getNumChannels
(
)
wavHeader
.
getSampleRateHz
(
)
wavHeader
.
getEncoding
(
)
null
null
0
null
)
;
trackOutput
.
format
(
format
)
;
bytesPerFrame
=
wavHeader
.
getBytesPerFrame
(
)
;
}
if
(
!
wavHeader
.
hasDataBounds
(
)
)
{
WavHeaderReader
.
skipToData
(
input
wavHeader
)
;
extractorOutput
.
seekMap
(
this
)
;
}
int
bytesAppended
=
trackOutput
.
sampleData
(
input
MAX_INPUT_SIZE
-
pendingBytes
true
)
;
if
(
bytesAppended
!
=
RESULT_END_OF_INPUT
)
{
pendingBytes
+
=
bytesAppended
;
}
int
pendingFrames
=
pendingBytes
/
bytesPerFrame
;
if
(
pendingFrames
>
0
)
{
long
timeUs
=
wavHeader
.
getTimeUs
(
input
.
getPosition
(
)
-
pendingBytes
)
;
int
size
=
pendingFrames
*
bytesPerFrame
;
pendingBytes
-
=
size
;
trackOutput
.
sampleMetadata
(
timeUs
C
.
BUFFER_FLAG_KEY_FRAME
size
pendingBytes
null
)
;
}
return
bytesAppended
=
=
RESULT_END_OF_INPUT
?
RESULT_END_OF_INPUT
:
RESULT_CONTINUE
;
}
Override
public
long
getDurationUs
(
)
{
return
wavHeader
.
getDurationUs
(
)
;
}
Override
public
boolean
isSeekable
(
)
{
return
true
;
}
Override
public
long
getPosition
(
long
timeUs
)
{
return
wavHeader
.
getPosition
(
timeUs
)
;
}
}
