package
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
;
import
android
.
support
.
annotation
.
IntDef
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
GaplessInfoHolder
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
MpegAudioHeader
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
com
.
google
.
android
.
exoplayer2
.
metadata
.
Metadata
;
import
com
.
google
.
android
.
exoplayer2
.
metadata
.
id3
.
Id3Decoder
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
final
class
Mp3Extractor
implements
Extractor
{
public
static
final
ExtractorsFactory
FACTORY
=
new
ExtractorsFactory
(
)
{
Override
public
Extractor
[
]
createExtractors
(
)
{
return
new
Extractor
[
]
{
new
Mp3Extractor
(
)
}
;
}
}
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
FLAG_DISABLE_ID3_METADATA
}
)
public
interface
Flags
{
}
public
static
final
int
FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
=
1
;
public
static
final
int
FLAG_DISABLE_ID3_METADATA
=
2
;
private
static
final
int
MAX_SYNC_BYTES
=
128
*
1024
;
private
static
final
int
MAX_SNIFF_BYTES
=
MpegAudioHeader
.
MAX_FRAME_SIZE_BYTES
;
private
static
final
int
SCRATCH_LENGTH
=
10
;
private
static
final
int
HEADER_MASK
=
0xFFFE0C00
;
private
static
final
int
XING_HEADER
=
Util
.
getIntegerCodeForString
(
"
Xing
"
)
;
private
static
final
int
INFO_HEADER
=
Util
.
getIntegerCodeForString
(
"
Info
"
)
;
private
static
final
int
VBRI_HEADER
=
Util
.
getIntegerCodeForString
(
"
VBRI
"
)
;
Flags
private
final
int
flags
;
private
final
long
forcedFirstSampleTimestampUs
;
private
final
ParsableByteArray
scratch
;
private
final
MpegAudioHeader
synchronizedHeader
;
private
final
GaplessInfoHolder
gaplessInfoHolder
;
private
ExtractorOutput
extractorOutput
;
private
TrackOutput
trackOutput
;
private
int
synchronizedHeaderData
;
private
Metadata
metadata
;
private
Seeker
seeker
;
private
long
basisTimeUs
;
private
long
samplesRead
;
private
int
sampleBytesRemaining
;
public
Mp3Extractor
(
)
{
this
(
0
)
;
}
public
Mp3Extractor
(
Flags
int
flags
)
{
this
(
flags
C
.
TIME_UNSET
)
;
}
public
Mp3Extractor
(
Flags
int
flags
long
forcedFirstSampleTimestampUs
)
{
this
.
flags
=
flags
;
this
.
forcedFirstSampleTimestampUs
=
forcedFirstSampleTimestampUs
;
scratch
=
new
ParsableByteArray
(
SCRATCH_LENGTH
)
;
synchronizedHeader
=
new
MpegAudioHeader
(
)
;
gaplessInfoHolder
=
new
GaplessInfoHolder
(
)
;
basisTimeUs
=
C
.
TIME_UNSET
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
synchronize
(
input
true
)
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
extractorOutput
=
output
;
trackOutput
=
extractorOutput
.
track
(
0
C
.
TRACK_TYPE_AUDIO
)
;
extractorOutput
.
endTracks
(
)
;
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
synchronizedHeaderData
=
0
;
basisTimeUs
=
C
.
TIME_UNSET
;
samplesRead
=
0
;
sampleBytesRemaining
=
0
;
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
if
(
synchronizedHeaderData
=
=
0
)
{
try
{
synchronize
(
input
false
)
;
}
catch
(
EOFException
e
)
{
return
RESULT_END_OF_INPUT
;
}
}
if
(
seeker
=
=
null
)
{
seeker
=
setupSeeker
(
input
)
;
extractorOutput
.
seekMap
(
seeker
)
;
trackOutput
.
format
(
Format
.
createAudioSampleFormat
(
null
synchronizedHeader
.
mimeType
null
Format
.
NO_VALUE
MpegAudioHeader
.
MAX_FRAME_SIZE_BYTES
synchronizedHeader
.
channels
synchronizedHeader
.
sampleRate
Format
.
NO_VALUE
gaplessInfoHolder
.
encoderDelay
gaplessInfoHolder
.
encoderPadding
null
null
0
null
(
flags
&
FLAG_DISABLE_ID3_METADATA
)
!
=
0
?
null
:
metadata
)
)
;
}
return
readSample
(
input
)
;
}
private
int
readSample
(
ExtractorInput
extractorInput
)
throws
IOException
InterruptedException
{
if
(
sampleBytesRemaining
=
=
0
)
{
extractorInput
.
resetPeekPosition
(
)
;
if
(
!
extractorInput
.
peekFully
(
scratch
.
data
0
4
true
)
)
{
return
RESULT_END_OF_INPUT
;
}
scratch
.
setPosition
(
0
)
;
int
sampleHeaderData
=
scratch
.
readInt
(
)
;
if
(
(
sampleHeaderData
&
HEADER_MASK
)
!
=
(
synchronizedHeaderData
&
HEADER_MASK
)
|
|
MpegAudioHeader
.
getFrameSize
(
sampleHeaderData
)
=
=
C
.
LENGTH_UNSET
)
{
extractorInput
.
skipFully
(
1
)
;
synchronizedHeaderData
=
0
;
return
RESULT_CONTINUE
;
}
MpegAudioHeader
.
populateHeader
(
sampleHeaderData
synchronizedHeader
)
;
if
(
basisTimeUs
=
=
C
.
TIME_UNSET
)
{
basisTimeUs
=
seeker
.
getTimeUs
(
extractorInput
.
getPosition
(
)
)
;
if
(
forcedFirstSampleTimestampUs
!
=
C
.
TIME_UNSET
)
{
long
embeddedFirstSampleTimestampUs
=
seeker
.
getTimeUs
(
0
)
;
basisTimeUs
+
=
forcedFirstSampleTimestampUs
-
embeddedFirstSampleTimestampUs
;
}
}
sampleBytesRemaining
=
synchronizedHeader
.
frameSize
;
}
int
bytesAppended
=
trackOutput
.
sampleData
(
extractorInput
sampleBytesRemaining
true
)
;
if
(
bytesAppended
=
=
C
.
RESULT_END_OF_INPUT
)
{
return
RESULT_END_OF_INPUT
;
}
sampleBytesRemaining
-
=
bytesAppended
;
if
(
sampleBytesRemaining
>
0
)
{
return
RESULT_CONTINUE
;
}
long
timeUs
=
basisTimeUs
+
(
samplesRead
*
C
.
MICROS_PER_SECOND
/
synchronizedHeader
.
sampleRate
)
;
trackOutput
.
sampleMetadata
(
timeUs
C
.
BUFFER_FLAG_KEY_FRAME
synchronizedHeader
.
frameSize
0
null
)
;
samplesRead
+
=
synchronizedHeader
.
samplesPerFrame
;
sampleBytesRemaining
=
0
;
return
RESULT_CONTINUE
;
}
private
boolean
synchronize
(
ExtractorInput
input
boolean
sniffing
)
throws
IOException
InterruptedException
{
int
validFrameCount
=
0
;
int
candidateSynchronizedHeaderData
=
0
;
int
peekedId3Bytes
=
0
;
int
searchedBytes
=
0
;
int
searchLimitBytes
=
sniffing
?
MAX_SNIFF_BYTES
:
MAX_SYNC_BYTES
;
input
.
resetPeekPosition
(
)
;
if
(
input
.
getPosition
(
)
=
=
0
)
{
peekId3Data
(
input
)
;
peekedId3Bytes
=
(
int
)
input
.
getPeekPosition
(
)
;
if
(
!
sniffing
)
{
input
.
skipFully
(
peekedId3Bytes
)
;
}
}
while
(
true
)
{
if
(
!
input
.
peekFully
(
scratch
.
data
0
4
validFrameCount
>
0
)
)
{
break
;
}
scratch
.
setPosition
(
0
)
;
int
headerData
=
scratch
.
readInt
(
)
;
int
frameSize
;
if
(
(
candidateSynchronizedHeaderData
!
=
0
&
&
(
headerData
&
HEADER_MASK
)
!
=
(
candidateSynchronizedHeaderData
&
HEADER_MASK
)
)
|
|
(
frameSize
=
MpegAudioHeader
.
getFrameSize
(
headerData
)
)
=
=
C
.
LENGTH_UNSET
)
{
if
(
searchedBytes
+
+
=
=
searchLimitBytes
)
{
if
(
!
sniffing
)
{
throw
new
ParserException
(
"
Searched
too
many
bytes
.
"
)
;
}
return
false
;
}
validFrameCount
=
0
;
candidateSynchronizedHeaderData
=
0
;
if
(
sniffing
)
{
input
.
resetPeekPosition
(
)
;
input
.
advancePeekPosition
(
peekedId3Bytes
+
searchedBytes
)
;
}
else
{
input
.
skipFully
(
1
)
;
}
}
else
{
validFrameCount
+
+
;
if
(
validFrameCount
=
=
1
)
{
MpegAudioHeader
.
populateHeader
(
headerData
synchronizedHeader
)
;
candidateSynchronizedHeaderData
=
headerData
;
}
else
if
(
validFrameCount
=
=
4
)
{
break
;
}
input
.
advancePeekPosition
(
frameSize
-
4
)
;
}
}
if
(
sniffing
)
{
input
.
skipFully
(
peekedId3Bytes
+
searchedBytes
)
;
}
else
{
input
.
resetPeekPosition
(
)
;
}
synchronizedHeaderData
=
candidateSynchronizedHeaderData
;
return
true
;
}
private
void
peekId3Data
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
int
peekedId3Bytes
=
0
;
while
(
true
)
{
input
.
peekFully
(
scratch
.
data
0
Id3Decoder
.
ID3_HEADER_LENGTH
)
;
scratch
.
setPosition
(
0
)
;
if
(
scratch
.
readUnsignedInt24
(
)
!
=
Id3Decoder
.
ID3_TAG
)
{
break
;
}
scratch
.
skipBytes
(
3
)
;
int
framesLength
=
scratch
.
readSynchSafeInt
(
)
;
int
tagLength
=
Id3Decoder
.
ID3_HEADER_LENGTH
+
framesLength
;
if
(
metadata
=
=
null
)
{
byte
[
]
id3Data
=
new
byte
[
tagLength
]
;
System
.
arraycopy
(
scratch
.
data
0
id3Data
0
Id3Decoder
.
ID3_HEADER_LENGTH
)
;
input
.
peekFully
(
id3Data
Id3Decoder
.
ID3_HEADER_LENGTH
framesLength
)
;
Id3Decoder
.
FramePredicate
id3FramePredicate
=
(
flags
&
FLAG_DISABLE_ID3_METADATA
)
!
=
0
?
GaplessInfoHolder
.
GAPLESS_INFO_ID3_FRAME_PREDICATE
:
null
;
metadata
=
new
Id3Decoder
(
id3FramePredicate
)
.
decode
(
id3Data
tagLength
)
;
if
(
metadata
!
=
null
)
{
gaplessInfoHolder
.
setFromMetadata
(
metadata
)
;
}
}
else
{
input
.
advancePeekPosition
(
framesLength
)
;
}
peekedId3Bytes
+
=
tagLength
;
}
input
.
resetPeekPosition
(
)
;
input
.
advancePeekPosition
(
peekedId3Bytes
)
;
}
private
Seeker
setupSeeker
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
ParsableByteArray
frame
=
new
ParsableByteArray
(
synchronizedHeader
.
frameSize
)
;
input
.
peekFully
(
frame
.
data
0
synchronizedHeader
.
frameSize
)
;
long
position
=
input
.
getPosition
(
)
;
long
length
=
input
.
getLength
(
)
;
int
headerData
=
0
;
Seeker
seeker
=
null
;
int
xingBase
=
(
synchronizedHeader
.
version
&
1
)
!
=
0
?
(
synchronizedHeader
.
channels
!
=
1
?
36
:
21
)
:
(
synchronizedHeader
.
channels
!
=
1
?
21
:
13
)
;
if
(
frame
.
limit
(
)
>
=
xingBase
+
4
)
{
frame
.
setPosition
(
xingBase
)
;
headerData
=
frame
.
readInt
(
)
;
}
if
(
headerData
=
=
XING_HEADER
|
|
headerData
=
=
INFO_HEADER
)
{
seeker
=
XingSeeker
.
create
(
synchronizedHeader
frame
position
length
)
;
if
(
seeker
!
=
null
&
&
!
gaplessInfoHolder
.
hasGaplessInfo
(
)
)
{
input
.
resetPeekPosition
(
)
;
input
.
advancePeekPosition
(
xingBase
+
141
)
;
input
.
peekFully
(
scratch
.
data
0
3
)
;
scratch
.
setPosition
(
0
)
;
gaplessInfoHolder
.
setFromXingHeaderValue
(
scratch
.
readUnsignedInt24
(
)
)
;
}
input
.
skipFully
(
synchronizedHeader
.
frameSize
)
;
}
else
if
(
frame
.
limit
(
)
>
=
40
)
{
frame
.
setPosition
(
36
)
;
headerData
=
frame
.
readInt
(
)
;
if
(
headerData
=
=
VBRI_HEADER
)
{
seeker
=
VbriSeeker
.
create
(
synchronizedHeader
frame
position
length
)
;
input
.
skipFully
(
synchronizedHeader
.
frameSize
)
;
}
}
if
(
seeker
=
=
null
|
|
(
!
seeker
.
isSeekable
(
)
&
&
(
flags
&
FLAG_ENABLE_CONSTANT_BITRATE_SEEKING
)
!
=
0
)
)
{
input
.
resetPeekPosition
(
)
;
input
.
peekFully
(
scratch
.
data
0
4
)
;
scratch
.
setPosition
(
0
)
;
MpegAudioHeader
.
populateHeader
(
scratch
.
readInt
(
)
synchronizedHeader
)
;
seeker
=
new
ConstantBitrateSeeker
(
input
.
getPosition
(
)
synchronizedHeader
.
bitrate
length
)
;
}
return
seeker
;
}
interface
Seeker
extends
SeekMap
{
long
getTimeUs
(
long
position
)
;
}
}
