package
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSink
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
.
Cache
.
CacheException
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ReusableBufferedOutputStream
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
public
final
class
CacheDataSink
implements
DataSink
{
public
static
final
int
DEFAULT_BUFFER_SIZE
=
20480
;
private
final
Cache
cache
;
private
final
long
maxCacheFileSize
;
private
final
int
bufferSize
;
private
DataSpec
dataSpec
;
private
File
file
;
private
OutputStream
outputStream
;
private
FileOutputStream
underlyingFileOutputStream
;
private
long
outputStreamBytesWritten
;
private
long
dataSpecBytesWritten
;
private
ReusableBufferedOutputStream
bufferedOutputStream
;
public
static
class
CacheDataSinkException
extends
CacheException
{
public
CacheDataSinkException
(
IOException
cause
)
{
super
(
cause
)
;
}
}
public
CacheDataSink
(
Cache
cache
long
maxCacheFileSize
)
{
this
(
cache
maxCacheFileSize
DEFAULT_BUFFER_SIZE
)
;
}
public
CacheDataSink
(
Cache
cache
long
maxCacheFileSize
int
bufferSize
)
{
this
.
cache
=
Assertions
.
checkNotNull
(
cache
)
;
this
.
maxCacheFileSize
=
maxCacheFileSize
;
this
.
bufferSize
=
bufferSize
;
}
Override
public
void
open
(
DataSpec
dataSpec
)
throws
CacheDataSinkException
{
if
(
dataSpec
.
length
=
=
C
.
LENGTH_UNSET
&
&
!
dataSpec
.
isFlagSet
(
DataSpec
.
FLAG_ALLOW_CACHING_UNKNOWN_LENGTH
)
)
{
this
.
dataSpec
=
null
;
return
;
}
this
.
dataSpec
=
dataSpec
;
dataSpecBytesWritten
=
0
;
try
{
openNextOutputStream
(
)
;
}
catch
(
IOException
e
)
{
throw
new
CacheDataSinkException
(
e
)
;
}
}
Override
public
void
write
(
byte
[
]
buffer
int
offset
int
length
)
throws
CacheDataSinkException
{
if
(
dataSpec
=
=
null
)
{
return
;
}
try
{
int
bytesWritten
=
0
;
while
(
bytesWritten
<
length
)
{
if
(
outputStreamBytesWritten
=
=
maxCacheFileSize
)
{
closeCurrentOutputStream
(
)
;
openNextOutputStream
(
)
;
}
int
bytesToWrite
=
(
int
)
Math
.
min
(
length
-
bytesWritten
maxCacheFileSize
-
outputStreamBytesWritten
)
;
outputStream
.
write
(
buffer
offset
+
bytesWritten
bytesToWrite
)
;
bytesWritten
+
=
bytesToWrite
;
outputStreamBytesWritten
+
=
bytesToWrite
;
dataSpecBytesWritten
+
=
bytesToWrite
;
}
}
catch
(
IOException
e
)
{
throw
new
CacheDataSinkException
(
e
)
;
}
}
Override
public
void
close
(
)
throws
CacheDataSinkException
{
if
(
dataSpec
=
=
null
)
{
return
;
}
try
{
closeCurrentOutputStream
(
)
;
}
catch
(
IOException
e
)
{
throw
new
CacheDataSinkException
(
e
)
;
}
}
private
void
openNextOutputStream
(
)
throws
IOException
{
long
maxLength
=
dataSpec
.
length
=
=
C
.
LENGTH_UNSET
?
maxCacheFileSize
:
Math
.
min
(
dataSpec
.
length
-
dataSpecBytesWritten
maxCacheFileSize
)
;
file
=
cache
.
startFile
(
dataSpec
.
key
dataSpec
.
absoluteStreamPosition
+
dataSpecBytesWritten
maxLength
)
;
underlyingFileOutputStream
=
new
FileOutputStream
(
file
)
;
if
(
bufferSize
>
0
)
{
if
(
bufferedOutputStream
=
=
null
)
{
bufferedOutputStream
=
new
ReusableBufferedOutputStream
(
underlyingFileOutputStream
bufferSize
)
;
}
else
{
bufferedOutputStream
.
reset
(
underlyingFileOutputStream
)
;
}
outputStream
=
bufferedOutputStream
;
}
else
{
outputStream
=
underlyingFileOutputStream
;
}
outputStreamBytesWritten
=
0
;
}
SuppressWarnings
(
"
ThrowFromFinallyBlock
"
)
private
void
closeCurrentOutputStream
(
)
throws
IOException
{
if
(
outputStream
=
=
null
)
{
return
;
}
boolean
success
=
false
;
try
{
outputStream
.
flush
(
)
;
underlyingFileOutputStream
.
getFD
(
)
.
sync
(
)
;
success
=
true
;
}
finally
{
Util
.
closeQuietly
(
outputStream
)
;
outputStream
=
null
;
File
fileToCommit
=
file
;
file
=
null
;
if
(
success
)
{
cache
.
commitFile
(
fileToCommit
)
;
}
else
{
fileToCommit
.
delete
(
)
;
}
}
}
}
