package
com
.
google
.
android
.
exoplayer2
.
util
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
public
final
class
TimestampAdjuster
{
public
static
final
long
DO_NOT_OFFSET
=
Long
.
MAX_VALUE
;
private
static
final
long
MAX_PTS_PLUS_ONE
=
0x200000000L
;
private
long
firstSampleTimestampUs
;
private
long
timestampOffsetUs
;
private
volatile
long
lastSampleTimestamp
;
public
TimestampAdjuster
(
long
firstSampleTimestampUs
)
{
lastSampleTimestamp
=
C
.
TIME_UNSET
;
setFirstSampleTimestampUs
(
firstSampleTimestampUs
)
;
}
public
synchronized
void
setFirstSampleTimestampUs
(
long
firstSampleTimestampUs
)
{
Assertions
.
checkState
(
lastSampleTimestamp
=
=
C
.
TIME_UNSET
)
;
this
.
firstSampleTimestampUs
=
firstSampleTimestampUs
;
}
public
long
getFirstSampleTimestampUs
(
)
{
return
firstSampleTimestampUs
;
}
public
long
getLastAdjustedTimestampUs
(
)
{
return
lastSampleTimestamp
!
=
C
.
TIME_UNSET
?
lastSampleTimestamp
:
firstSampleTimestampUs
!
=
DO_NOT_OFFSET
?
firstSampleTimestampUs
:
C
.
TIME_UNSET
;
}
public
long
getTimestampOffsetUs
(
)
{
return
firstSampleTimestampUs
=
=
DO_NOT_OFFSET
?
0
:
lastSampleTimestamp
=
=
C
.
TIME_UNSET
?
C
.
TIME_UNSET
:
timestampOffsetUs
;
}
public
void
reset
(
)
{
lastSampleTimestamp
=
C
.
TIME_UNSET
;
}
public
long
adjustTsTimestamp
(
long
pts
)
{
if
(
pts
=
=
C
.
TIME_UNSET
)
{
return
C
.
TIME_UNSET
;
}
if
(
lastSampleTimestamp
!
=
C
.
TIME_UNSET
)
{
long
lastPts
=
usToPts
(
lastSampleTimestamp
)
;
long
closestWrapCount
=
(
lastPts
+
(
MAX_PTS_PLUS_ONE
/
2
)
)
/
MAX_PTS_PLUS_ONE
;
long
ptsWrapBelow
=
pts
+
(
MAX_PTS_PLUS_ONE
*
(
closestWrapCount
-
1
)
)
;
long
ptsWrapAbove
=
pts
+
(
MAX_PTS_PLUS_ONE
*
closestWrapCount
)
;
pts
=
Math
.
abs
(
ptsWrapBelow
-
lastPts
)
<
Math
.
abs
(
ptsWrapAbove
-
lastPts
)
?
ptsWrapBelow
:
ptsWrapAbove
;
}
return
adjustSampleTimestamp
(
ptsToUs
(
pts
)
)
;
}
public
long
adjustSampleTimestamp
(
long
timeUs
)
{
if
(
timeUs
=
=
C
.
TIME_UNSET
)
{
return
C
.
TIME_UNSET
;
}
if
(
lastSampleTimestamp
!
=
C
.
TIME_UNSET
)
{
lastSampleTimestamp
=
timeUs
;
}
else
{
if
(
firstSampleTimestampUs
!
=
DO_NOT_OFFSET
)
{
timestampOffsetUs
=
firstSampleTimestampUs
-
timeUs
;
}
synchronized
(
this
)
{
lastSampleTimestamp
=
timeUs
;
notifyAll
(
)
;
}
}
return
timeUs
+
timestampOffsetUs
;
}
public
synchronized
void
waitUntilInitialized
(
)
throws
InterruptedException
{
while
(
lastSampleTimestamp
=
=
C
.
TIME_UNSET
)
{
wait
(
)
;
}
}
public
static
long
ptsToUs
(
long
pts
)
{
return
(
pts
*
C
.
MICROS_PER_SECOND
)
/
90000
;
}
public
static
long
usToPts
(
long
us
)
{
return
(
us
*
90000
)
/
C
.
MICROS_PER_SECOND
;
}
}
