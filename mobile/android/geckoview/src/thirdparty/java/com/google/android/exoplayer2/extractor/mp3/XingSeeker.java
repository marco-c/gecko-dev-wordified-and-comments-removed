package
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
extractor
.
MpegAudioHeader
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
final
class
XingSeeker
implements
Mp3Extractor
.
Seeker
{
public
static
XingSeeker
create
(
MpegAudioHeader
mpegAudioHeader
ParsableByteArray
frame
long
position
long
inputLength
)
{
int
samplesPerFrame
=
mpegAudioHeader
.
samplesPerFrame
;
int
sampleRate
=
mpegAudioHeader
.
sampleRate
;
long
firstFramePosition
=
position
+
mpegAudioHeader
.
frameSize
;
int
flags
=
frame
.
readInt
(
)
;
int
frameCount
;
if
(
(
flags
&
0x01
)
!
=
0x01
|
|
(
frameCount
=
frame
.
readUnsignedIntToInt
(
)
)
=
=
0
)
{
return
null
;
}
long
durationUs
=
Util
.
scaleLargeTimestamp
(
frameCount
samplesPerFrame
*
C
.
MICROS_PER_SECOND
sampleRate
)
;
if
(
(
flags
&
0x06
)
!
=
0x06
)
{
return
new
XingSeeker
(
firstFramePosition
durationUs
inputLength
)
;
}
long
sizeBytes
=
frame
.
readUnsignedIntToInt
(
)
;
frame
.
skipBytes
(
1
)
;
long
[
]
tableOfContents
=
new
long
[
99
]
;
for
(
int
i
=
0
;
i
<
99
;
i
+
+
)
{
tableOfContents
[
i
]
=
frame
.
readUnsignedByte
(
)
;
}
return
new
XingSeeker
(
firstFramePosition
durationUs
inputLength
tableOfContents
sizeBytes
mpegAudioHeader
.
frameSize
)
;
}
private
final
long
firstFramePosition
;
private
final
long
durationUs
;
private
final
long
inputLength
;
private
final
long
[
]
tableOfContents
;
private
final
long
sizeBytes
;
private
final
int
headerSize
;
private
XingSeeker
(
long
firstFramePosition
long
durationUs
long
inputLength
)
{
this
(
firstFramePosition
durationUs
inputLength
null
0
0
)
;
}
private
XingSeeker
(
long
firstFramePosition
long
durationUs
long
inputLength
long
[
]
tableOfContents
long
sizeBytes
int
headerSize
)
{
this
.
firstFramePosition
=
firstFramePosition
;
this
.
durationUs
=
durationUs
;
this
.
inputLength
=
inputLength
;
this
.
tableOfContents
=
tableOfContents
;
this
.
sizeBytes
=
sizeBytes
;
this
.
headerSize
=
headerSize
;
}
Override
public
boolean
isSeekable
(
)
{
return
tableOfContents
!
=
null
;
}
Override
public
long
getPosition
(
long
timeUs
)
{
if
(
!
isSeekable
(
)
)
{
return
firstFramePosition
;
}
float
percent
=
timeUs
*
100f
/
durationUs
;
float
fx
;
if
(
percent
<
=
0f
)
{
fx
=
0f
;
}
else
if
(
percent
>
=
100f
)
{
fx
=
256f
;
}
else
{
int
a
=
(
int
)
percent
;
float
fa
fb
;
if
(
a
=
=
0
)
{
fa
=
0f
;
}
else
{
fa
=
tableOfContents
[
a
-
1
]
;
}
if
(
a
<
99
)
{
fb
=
tableOfContents
[
a
]
;
}
else
{
fb
=
256f
;
}
fx
=
fa
+
(
fb
-
fa
)
*
(
percent
-
a
)
;
}
long
position
=
Math
.
round
(
(
1
.
0
/
256
)
*
fx
*
sizeBytes
)
+
firstFramePosition
;
long
maximumPosition
=
inputLength
!
=
C
.
LENGTH_UNSET
?
inputLength
-
1
:
firstFramePosition
-
headerSize
+
sizeBytes
-
1
;
return
Math
.
min
(
position
maximumPosition
)
;
}
Override
public
long
getTimeUs
(
long
position
)
{
if
(
!
isSeekable
(
)
|
|
position
<
firstFramePosition
)
{
return
0L
;
}
double
offsetByte
=
256
.
0
*
(
position
-
firstFramePosition
)
/
sizeBytes
;
int
previousTocPosition
=
Util
.
binarySearchFloor
(
tableOfContents
(
long
)
offsetByte
true
false
)
+
1
;
long
previousTime
=
getTimeUsForTocPosition
(
previousTocPosition
)
;
long
previousByte
=
previousTocPosition
=
=
0
?
0
:
tableOfContents
[
previousTocPosition
-
1
]
;
long
nextByte
=
previousTocPosition
=
=
99
?
256
:
tableOfContents
[
previousTocPosition
]
;
long
nextTime
=
getTimeUsForTocPosition
(
previousTocPosition
+
1
)
;
long
timeOffset
=
nextByte
=
=
previousByte
?
0
:
(
long
)
(
(
nextTime
-
previousTime
)
*
(
offsetByte
-
previousByte
)
/
(
nextByte
-
previousByte
)
)
;
return
previousTime
+
timeOffset
;
}
Override
public
long
getDurationUs
(
)
{
return
durationUs
;
}
private
long
getTimeUsForTocPosition
(
int
tocPosition
)
{
return
durationUs
*
tocPosition
/
100
;
}
}
