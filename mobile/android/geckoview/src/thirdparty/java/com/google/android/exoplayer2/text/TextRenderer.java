package
com
.
google
.
android
.
exoplayer2
.
text
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Handler
.
Callback
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
android
.
support
.
annotation
.
IntDef
;
import
com
.
google
.
android
.
exoplayer2
.
BaseRenderer
;
import
com
.
google
.
android
.
exoplayer2
.
C
;
import
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
com
.
google
.
android
.
exoplayer2
.
Format
;
import
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
public
final
class
TextRenderer
extends
BaseRenderer
implements
Callback
{
public
interface
Output
{
void
onCues
(
List
<
Cue
>
cues
)
;
}
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
REPLACEMENT_STATE_NONE
REPLACEMENT_STATE_SIGNAL_END_OF_STREAM
REPLACEMENT_STATE_WAIT_END_OF_STREAM
}
)
private
interface
ReplacementState
{
}
private
static
final
int
REPLACEMENT_STATE_NONE
=
0
;
private
static
final
int
REPLACEMENT_STATE_SIGNAL_END_OF_STREAM
=
1
;
private
static
final
int
REPLACEMENT_STATE_WAIT_END_OF_STREAM
=
2
;
private
static
final
int
MSG_UPDATE_OUTPUT
=
0
;
private
final
Handler
outputHandler
;
private
final
Output
output
;
private
final
SubtitleDecoderFactory
decoderFactory
;
private
final
FormatHolder
formatHolder
;
private
boolean
inputStreamEnded
;
private
boolean
outputStreamEnded
;
ReplacementState
private
int
decoderReplacementState
;
private
Format
streamFormat
;
private
SubtitleDecoder
decoder
;
private
SubtitleInputBuffer
nextInputBuffer
;
private
SubtitleOutputBuffer
subtitle
;
private
SubtitleOutputBuffer
nextSubtitle
;
private
int
nextSubtitleEventIndex
;
public
TextRenderer
(
Output
output
Looper
outputLooper
)
{
this
(
output
outputLooper
SubtitleDecoderFactory
.
DEFAULT
)
;
}
public
TextRenderer
(
Output
output
Looper
outputLooper
SubtitleDecoderFactory
decoderFactory
)
{
super
(
C
.
TRACK_TYPE_TEXT
)
;
this
.
output
=
Assertions
.
checkNotNull
(
output
)
;
this
.
outputHandler
=
outputLooper
=
=
null
?
null
:
new
Handler
(
outputLooper
this
)
;
this
.
decoderFactory
=
decoderFactory
;
formatHolder
=
new
FormatHolder
(
)
;
}
Override
public
int
supportsFormat
(
Format
format
)
{
return
decoderFactory
.
supportsFormat
(
format
)
?
FORMAT_HANDLED
:
(
MimeTypes
.
isText
(
format
.
sampleMimeType
)
?
FORMAT_UNSUPPORTED_SUBTYPE
:
FORMAT_UNSUPPORTED_TYPE
)
;
}
Override
protected
void
onStreamChanged
(
Format
[
]
formats
)
throws
ExoPlaybackException
{
streamFormat
=
formats
[
0
]
;
if
(
decoder
!
=
null
)
{
decoderReplacementState
=
REPLACEMENT_STATE_SIGNAL_END_OF_STREAM
;
}
else
{
decoder
=
decoderFactory
.
createDecoder
(
streamFormat
)
;
}
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
{
clearOutput
(
)
;
inputStreamEnded
=
false
;
outputStreamEnded
=
false
;
if
(
decoderReplacementState
!
=
REPLACEMENT_STATE_NONE
)
{
replaceDecoder
(
)
;
}
else
{
releaseBuffers
(
)
;
decoder
.
flush
(
)
;
}
}
Override
public
void
render
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
{
if
(
outputStreamEnded
)
{
return
;
}
if
(
nextSubtitle
=
=
null
)
{
decoder
.
setPositionUs
(
positionUs
)
;
try
{
nextSubtitle
=
decoder
.
dequeueOutputBuffer
(
)
;
}
catch
(
SubtitleDecoderException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
}
if
(
getState
(
)
!
=
STATE_STARTED
)
{
return
;
}
boolean
textRendererNeedsUpdate
=
false
;
if
(
subtitle
!
=
null
)
{
long
subtitleNextEventTimeUs
=
getNextEventTime
(
)
;
while
(
subtitleNextEventTimeUs
<
=
positionUs
)
{
nextSubtitleEventIndex
+
+
;
subtitleNextEventTimeUs
=
getNextEventTime
(
)
;
textRendererNeedsUpdate
=
true
;
}
}
if
(
nextSubtitle
!
=
null
)
{
if
(
nextSubtitle
.
isEndOfStream
(
)
)
{
if
(
!
textRendererNeedsUpdate
&
&
getNextEventTime
(
)
=
=
Long
.
MAX_VALUE
)
{
if
(
decoderReplacementState
=
=
REPLACEMENT_STATE_WAIT_END_OF_STREAM
)
{
replaceDecoder
(
)
;
}
else
{
releaseBuffers
(
)
;
outputStreamEnded
=
true
;
}
}
}
else
if
(
nextSubtitle
.
timeUs
<
=
positionUs
)
{
if
(
subtitle
!
=
null
)
{
subtitle
.
release
(
)
;
}
subtitle
=
nextSubtitle
;
nextSubtitle
=
null
;
nextSubtitleEventIndex
=
subtitle
.
getNextEventTimeIndex
(
positionUs
)
;
textRendererNeedsUpdate
=
true
;
}
}
if
(
textRendererNeedsUpdate
)
{
updateOutput
(
subtitle
.
getCues
(
positionUs
)
)
;
}
if
(
decoderReplacementState
=
=
REPLACEMENT_STATE_WAIT_END_OF_STREAM
)
{
return
;
}
try
{
while
(
!
inputStreamEnded
)
{
if
(
nextInputBuffer
=
=
null
)
{
nextInputBuffer
=
decoder
.
dequeueInputBuffer
(
)
;
if
(
nextInputBuffer
=
=
null
)
{
return
;
}
}
if
(
decoderReplacementState
=
=
REPLACEMENT_STATE_SIGNAL_END_OF_STREAM
)
{
nextInputBuffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
decoder
.
queueInputBuffer
(
nextInputBuffer
)
;
nextInputBuffer
=
null
;
decoderReplacementState
=
REPLACEMENT_STATE_WAIT_END_OF_STREAM
;
return
;
}
int
result
=
readSource
(
formatHolder
nextInputBuffer
false
)
;
if
(
result
=
=
C
.
RESULT_BUFFER_READ
)
{
if
(
nextInputBuffer
.
isEndOfStream
(
)
)
{
inputStreamEnded
=
true
;
}
else
{
nextInputBuffer
.
subsampleOffsetUs
=
formatHolder
.
format
.
subsampleOffsetUs
;
nextInputBuffer
.
flip
(
)
;
}
decoder
.
queueInputBuffer
(
nextInputBuffer
)
;
nextInputBuffer
=
null
;
}
else
if
(
result
=
=
C
.
RESULT_NOTHING_READ
)
{
return
;
}
}
}
catch
(
SubtitleDecoderException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
}
Override
protected
void
onDisabled
(
)
{
streamFormat
=
null
;
clearOutput
(
)
;
releaseDecoder
(
)
;
super
.
onDisabled
(
)
;
}
Override
public
boolean
isEnded
(
)
{
return
outputStreamEnded
;
}
Override
public
boolean
isReady
(
)
{
return
true
;
}
private
void
releaseBuffers
(
)
{
nextInputBuffer
=
null
;
nextSubtitleEventIndex
=
C
.
INDEX_UNSET
;
if
(
subtitle
!
=
null
)
{
subtitle
.
release
(
)
;
subtitle
=
null
;
}
if
(
nextSubtitle
!
=
null
)
{
nextSubtitle
.
release
(
)
;
nextSubtitle
=
null
;
}
}
private
void
releaseDecoder
(
)
{
releaseBuffers
(
)
;
decoder
.
release
(
)
;
decoder
=
null
;
decoderReplacementState
=
REPLACEMENT_STATE_NONE
;
}
private
void
replaceDecoder
(
)
{
releaseDecoder
(
)
;
decoder
=
decoderFactory
.
createDecoder
(
streamFormat
)
;
}
private
long
getNextEventTime
(
)
{
return
(
(
nextSubtitleEventIndex
=
=
C
.
INDEX_UNSET
)
|
|
(
nextSubtitleEventIndex
>
=
subtitle
.
getEventTimeCount
(
)
)
)
?
Long
.
MAX_VALUE
:
(
subtitle
.
getEventTime
(
nextSubtitleEventIndex
)
)
;
}
private
void
updateOutput
(
List
<
Cue
>
cues
)
{
if
(
outputHandler
!
=
null
)
{
outputHandler
.
obtainMessage
(
MSG_UPDATE_OUTPUT
cues
)
.
sendToTarget
(
)
;
}
else
{
invokeUpdateOutputInternal
(
cues
)
;
}
}
private
void
clearOutput
(
)
{
updateOutput
(
Collections
.
<
Cue
>
emptyList
(
)
)
;
}
SuppressWarnings
(
"
unchecked
"
)
Override
public
boolean
handleMessage
(
Message
msg
)
{
switch
(
msg
.
what
)
{
case
MSG_UPDATE_OUTPUT
:
invokeUpdateOutputInternal
(
(
List
<
Cue
>
)
msg
.
obj
)
;
return
true
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
private
void
invokeUpdateOutputInternal
(
List
<
Cue
>
cues
)
{
output
.
onCues
(
cues
)
;
}
}
