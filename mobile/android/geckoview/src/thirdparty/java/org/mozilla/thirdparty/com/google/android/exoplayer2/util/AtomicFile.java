package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
util
.
Log
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
public
final
class
AtomicFile
{
private
static
final
String
TAG
=
"
AtomicFile
"
;
private
final
File
baseName
;
private
final
File
backupName
;
public
AtomicFile
(
File
baseName
)
{
this
.
baseName
=
baseName
;
backupName
=
new
File
(
baseName
.
getPath
(
)
+
"
.
bak
"
)
;
}
public
void
delete
(
)
{
baseName
.
delete
(
)
;
backupName
.
delete
(
)
;
}
public
OutputStream
startWrite
(
)
throws
IOException
{
if
(
baseName
.
exists
(
)
)
{
if
(
!
backupName
.
exists
(
)
)
{
if
(
!
baseName
.
renameTo
(
backupName
)
)
{
Log
.
w
(
TAG
"
Couldn
'
t
rename
file
"
+
baseName
+
"
to
backup
file
"
+
backupName
)
;
}
}
else
{
baseName
.
delete
(
)
;
}
}
OutputStream
str
;
try
{
str
=
new
AtomicFileOutputStream
(
baseName
)
;
}
catch
(
FileNotFoundException
e
)
{
File
parent
=
baseName
.
getParentFile
(
)
;
if
(
!
parent
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Couldn
'
t
create
directory
"
+
baseName
)
;
}
try
{
str
=
new
AtomicFileOutputStream
(
baseName
)
;
}
catch
(
FileNotFoundException
e2
)
{
throw
new
IOException
(
"
Couldn
'
t
create
"
+
baseName
)
;
}
}
return
str
;
}
public
void
endWrite
(
OutputStream
str
)
throws
IOException
{
str
.
close
(
)
;
backupName
.
delete
(
)
;
}
public
InputStream
openRead
(
)
throws
FileNotFoundException
{
restoreBackup
(
)
;
return
new
FileInputStream
(
baseName
)
;
}
private
void
restoreBackup
(
)
{
if
(
backupName
.
exists
(
)
)
{
baseName
.
delete
(
)
;
backupName
.
renameTo
(
baseName
)
;
}
}
private
static
final
class
AtomicFileOutputStream
extends
OutputStream
{
private
final
FileOutputStream
fileOutputStream
;
private
boolean
closed
=
false
;
public
AtomicFileOutputStream
(
File
file
)
throws
FileNotFoundException
{
fileOutputStream
=
new
FileOutputStream
(
file
)
;
}
Override
public
void
close
(
)
throws
IOException
{
if
(
closed
)
{
return
;
}
closed
=
true
;
flush
(
)
;
try
{
fileOutputStream
.
getFD
(
)
.
sync
(
)
;
}
catch
(
IOException
e
)
{
Log
.
w
(
TAG
"
Failed
to
sync
file
descriptor
:
"
e
)
;
}
fileOutputStream
.
close
(
)
;
}
Override
public
void
flush
(
)
throws
IOException
{
fileOutputStream
.
flush
(
)
;
}
Override
public
void
write
(
int
b
)
throws
IOException
{
fileOutputStream
.
write
(
b
)
;
}
Override
public
void
write
(
NonNull
byte
[
]
b
)
throws
IOException
{
fileOutputStream
.
write
(
b
)
;
}
Override
public
void
write
(
NonNull
byte
[
]
b
int
off
int
len
)
throws
IOException
{
fileOutputStream
.
write
(
b
off
len
)
;
}
}
}
