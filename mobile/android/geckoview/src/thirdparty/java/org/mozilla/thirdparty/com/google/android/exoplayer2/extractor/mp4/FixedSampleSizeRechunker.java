package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
final
class
FixedSampleSizeRechunker
{
public
static
final
class
Results
{
public
final
long
[
]
offsets
;
public
final
int
[
]
sizes
;
public
final
int
maximumSize
;
public
final
long
[
]
timestamps
;
public
final
int
[
]
flags
;
public
final
long
duration
;
private
Results
(
long
[
]
offsets
int
[
]
sizes
int
maximumSize
long
[
]
timestamps
int
[
]
flags
long
duration
)
{
this
.
offsets
=
offsets
;
this
.
sizes
=
sizes
;
this
.
maximumSize
=
maximumSize
;
this
.
timestamps
=
timestamps
;
this
.
flags
=
flags
;
this
.
duration
=
duration
;
}
}
private
static
final
int
MAX_SAMPLE_SIZE
=
8
*
1024
;
public
static
Results
rechunk
(
int
fixedSampleSize
long
[
]
chunkOffsets
int
[
]
chunkSampleCounts
long
timestampDeltaInTimeUnits
)
{
int
maxSampleCount
=
MAX_SAMPLE_SIZE
/
fixedSampleSize
;
int
rechunkedSampleCount
=
0
;
for
(
int
chunkSampleCount
:
chunkSampleCounts
)
{
rechunkedSampleCount
+
=
Util
.
ceilDivide
(
chunkSampleCount
maxSampleCount
)
;
}
long
[
]
offsets
=
new
long
[
rechunkedSampleCount
]
;
int
[
]
sizes
=
new
int
[
rechunkedSampleCount
]
;
int
maximumSize
=
0
;
long
[
]
timestamps
=
new
long
[
rechunkedSampleCount
]
;
int
[
]
flags
=
new
int
[
rechunkedSampleCount
]
;
int
originalSampleIndex
=
0
;
int
newSampleIndex
=
0
;
for
(
int
chunkIndex
=
0
;
chunkIndex
<
chunkSampleCounts
.
length
;
chunkIndex
+
+
)
{
int
chunkSamplesRemaining
=
chunkSampleCounts
[
chunkIndex
]
;
long
sampleOffset
=
chunkOffsets
[
chunkIndex
]
;
while
(
chunkSamplesRemaining
>
0
)
{
int
bufferSampleCount
=
Math
.
min
(
maxSampleCount
chunkSamplesRemaining
)
;
offsets
[
newSampleIndex
]
=
sampleOffset
;
sizes
[
newSampleIndex
]
=
fixedSampleSize
*
bufferSampleCount
;
maximumSize
=
Math
.
max
(
maximumSize
sizes
[
newSampleIndex
]
)
;
timestamps
[
newSampleIndex
]
=
(
timestampDeltaInTimeUnits
*
originalSampleIndex
)
;
flags
[
newSampleIndex
]
=
C
.
BUFFER_FLAG_KEY_FRAME
;
sampleOffset
+
=
sizes
[
newSampleIndex
]
;
originalSampleIndex
+
=
bufferSampleCount
;
chunkSamplesRemaining
-
=
bufferSampleCount
;
newSampleIndex
+
+
;
}
}
long
duration
=
timestampDeltaInTimeUnits
*
originalSampleIndex
;
return
new
Results
(
offsets
sizes
maximumSize
timestamps
flags
duration
)
;
}
private
FixedSampleSizeRechunker
(
)
{
}
}
