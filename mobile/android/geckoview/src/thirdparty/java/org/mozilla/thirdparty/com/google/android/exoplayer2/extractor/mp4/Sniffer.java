package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
final
class
Sniffer
{
private
static
final
int
SEARCH_LENGTH
=
4
*
1024
;
private
static
final
int
[
]
COMPATIBLE_BRANDS
=
new
int
[
]
{
0x69736f6d
0x69736f32
0x69736f33
0x69736f34
0x69736f35
0x69736f36
0x61766331
0x68766331
0x68657631
0x61763031
0x6d703431
0x6d703432
0x33673261
0x33673262
0x33677236
0x33677336
0x33676536
0x33676736
0x4d345620
0x4d344120
0x66347620
0x6b646469
0x4d345650
0x71742020
0x4d534e56
0x64627931
}
;
public
static
boolean
sniffFragmented
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
sniffInternal
(
input
true
)
;
}
public
static
boolean
sniffUnfragmented
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
sniffInternal
(
input
false
)
;
}
private
static
boolean
sniffInternal
(
ExtractorInput
input
boolean
fragmented
)
throws
IOException
InterruptedException
{
long
inputLength
=
input
.
getLength
(
)
;
int
bytesToSearch
=
(
int
)
(
inputLength
=
=
C
.
LENGTH_UNSET
|
|
inputLength
>
SEARCH_LENGTH
?
SEARCH_LENGTH
:
inputLength
)
;
ParsableByteArray
buffer
=
new
ParsableByteArray
(
64
)
;
int
bytesSearched
=
0
;
boolean
foundGoodFileType
=
false
;
boolean
isFragmented
=
false
;
while
(
bytesSearched
<
bytesToSearch
)
{
int
headerSize
=
Atom
.
HEADER_SIZE
;
buffer
.
reset
(
headerSize
)
;
input
.
peekFully
(
buffer
.
data
0
headerSize
)
;
long
atomSize
=
buffer
.
readUnsignedInt
(
)
;
int
atomType
=
buffer
.
readInt
(
)
;
if
(
atomSize
=
=
Atom
.
DEFINES_LARGE_SIZE
)
{
headerSize
=
Atom
.
LONG_HEADER_SIZE
;
input
.
peekFully
(
buffer
.
data
Atom
.
HEADER_SIZE
Atom
.
LONG_HEADER_SIZE
-
Atom
.
HEADER_SIZE
)
;
buffer
.
setLimit
(
Atom
.
LONG_HEADER_SIZE
)
;
atomSize
=
buffer
.
readLong
(
)
;
}
else
if
(
atomSize
=
=
Atom
.
EXTENDS_TO_END_SIZE
)
{
long
fileEndPosition
=
input
.
getLength
(
)
;
if
(
fileEndPosition
!
=
C
.
LENGTH_UNSET
)
{
atomSize
=
fileEndPosition
-
input
.
getPeekPosition
(
)
+
headerSize
;
}
}
if
(
atomSize
<
headerSize
)
{
return
false
;
}
bytesSearched
+
=
headerSize
;
if
(
atomType
=
=
Atom
.
TYPE_moov
)
{
bytesToSearch
+
=
(
int
)
atomSize
;
if
(
inputLength
!
=
C
.
LENGTH_UNSET
&
&
bytesToSearch
>
inputLength
)
{
bytesToSearch
=
(
int
)
inputLength
;
}
continue
;
}
if
(
atomType
=
=
Atom
.
TYPE_moof
|
|
atomType
=
=
Atom
.
TYPE_mvex
)
{
isFragmented
=
true
;
break
;
}
if
(
bytesSearched
+
atomSize
-
headerSize
>
=
bytesToSearch
)
{
break
;
}
int
atomDataSize
=
(
int
)
(
atomSize
-
headerSize
)
;
bytesSearched
+
=
atomDataSize
;
if
(
atomType
=
=
Atom
.
TYPE_ftyp
)
{
if
(
atomDataSize
<
8
)
{
return
false
;
}
buffer
.
reset
(
atomDataSize
)
;
input
.
peekFully
(
buffer
.
data
0
atomDataSize
)
;
int
brandsCount
=
atomDataSize
/
4
;
for
(
int
i
=
0
;
i
<
brandsCount
;
i
+
+
)
{
if
(
i
=
=
1
)
{
buffer
.
skipBytes
(
4
)
;
}
else
if
(
isCompatibleBrand
(
buffer
.
readInt
(
)
)
)
{
foundGoodFileType
=
true
;
break
;
}
}
if
(
!
foundGoodFileType
)
{
return
false
;
}
}
else
if
(
atomDataSize
!
=
0
)
{
input
.
advancePeekPosition
(
atomDataSize
)
;
}
}
return
foundGoodFileType
&
&
fragmented
=
=
isFragmented
;
}
private
static
boolean
isCompatibleBrand
(
int
brand
)
{
if
(
brand
>
>
>
8
=
=
0x00336770
)
{
return
true
;
}
for
(
int
compatibleBrand
:
COMPATIBLE_BRANDS
)
{
if
(
compatibleBrand
=
=
brand
)
{
return
true
;
}
}
return
false
;
}
private
Sniffer
(
)
{
}
}
