package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
.
spherical
;
import
androidx
.
annotation
.
IntDef
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
.
StereoMode
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
final
class
Projection
{
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
DRAW_MODE_TRIANGLES
DRAW_MODE_TRIANGLES_STRIP
DRAW_MODE_TRIANGLES_FAN
}
)
public
interface
DrawMode
{
}
public
static
final
int
DRAW_MODE_TRIANGLES
=
0
;
public
static
final
int
DRAW_MODE_TRIANGLES_STRIP
=
1
;
public
static
final
int
DRAW_MODE_TRIANGLES_FAN
=
2
;
public
static
final
int
TEXTURE_COORDS_PER_VERTEX
=
2
;
public
static
final
int
POSITION_COORDS_PER_VERTEX
=
3
;
public
static
Projection
createEquirectangular
(
C
.
StereoMode
int
stereoMode
)
{
return
createEquirectangular
(
50
36
72
180
360
stereoMode
)
;
}
public
static
Projection
createEquirectangular
(
float
radius
int
latitudes
int
longitudes
float
verticalFovDegrees
float
horizontalFovDegrees
C
.
StereoMode
int
stereoMode
)
{
Assertions
.
checkArgument
(
radius
>
0
)
;
Assertions
.
checkArgument
(
latitudes
>
=
1
)
;
Assertions
.
checkArgument
(
longitudes
>
=
1
)
;
Assertions
.
checkArgument
(
verticalFovDegrees
>
0
&
&
verticalFovDegrees
<
=
180
)
;
Assertions
.
checkArgument
(
horizontalFovDegrees
>
0
&
&
horizontalFovDegrees
<
=
360
)
;
float
verticalFovRads
=
(
float
)
Math
.
toRadians
(
verticalFovDegrees
)
;
float
horizontalFovRads
=
(
float
)
Math
.
toRadians
(
horizontalFovDegrees
)
;
float
quadHeightRads
=
verticalFovRads
/
latitudes
;
float
quadWidthRads
=
horizontalFovRads
/
longitudes
;
int
vertexCount
=
(
2
*
(
longitudes
+
1
)
+
2
)
*
latitudes
;
float
[
]
vertexData
=
new
float
[
vertexCount
*
POSITION_COORDS_PER_VERTEX
]
;
float
[
]
textureData
=
new
float
[
vertexCount
*
TEXTURE_COORDS_PER_VERTEX
]
;
int
vOffset
=
0
;
int
tOffset
=
0
;
for
(
int
j
=
0
;
j
<
latitudes
;
+
+
j
)
{
float
phiLow
=
quadHeightRads
*
j
-
verticalFovRads
/
2
;
float
phiHigh
=
quadHeightRads
*
(
j
+
1
)
-
verticalFovRads
/
2
;
for
(
int
i
=
0
;
i
<
longitudes
+
1
;
+
+
i
)
{
for
(
int
k
=
0
;
k
<
2
;
+
+
k
)
{
float
phi
=
k
=
=
0
?
phiLow
:
phiHigh
;
float
theta
=
quadWidthRads
*
i
+
(
float
)
Math
.
PI
-
horizontalFovRads
/
2
;
vertexData
[
vOffset
+
+
]
=
-
(
float
)
(
radius
*
Math
.
sin
(
theta
)
*
Math
.
cos
(
phi
)
)
;
vertexData
[
vOffset
+
+
]
=
(
float
)
(
radius
*
Math
.
sin
(
phi
)
)
;
vertexData
[
vOffset
+
+
]
=
(
float
)
(
radius
*
Math
.
cos
(
theta
)
*
Math
.
cos
(
phi
)
)
;
textureData
[
tOffset
+
+
]
=
i
*
quadWidthRads
/
horizontalFovRads
;
textureData
[
tOffset
+
+
]
=
(
j
+
k
)
*
quadHeightRads
/
verticalFovRads
;
if
(
(
i
=
=
0
&
&
k
=
=
0
)
|
|
(
i
=
=
longitudes
&
&
k
=
=
1
)
)
{
System
.
arraycopy
(
vertexData
vOffset
-
POSITION_COORDS_PER_VERTEX
vertexData
vOffset
POSITION_COORDS_PER_VERTEX
)
;
vOffset
+
=
POSITION_COORDS_PER_VERTEX
;
System
.
arraycopy
(
textureData
tOffset
-
TEXTURE_COORDS_PER_VERTEX
textureData
tOffset
TEXTURE_COORDS_PER_VERTEX
)
;
tOffset
+
=
TEXTURE_COORDS_PER_VERTEX
;
}
}
}
}
SubMesh
subMesh
=
new
SubMesh
(
SubMesh
.
VIDEO_TEXTURE_ID
vertexData
textureData
DRAW_MODE_TRIANGLES_STRIP
)
;
return
new
Projection
(
new
Mesh
(
subMesh
)
stereoMode
)
;
}
public
final
Mesh
leftMesh
;
public
final
Mesh
rightMesh
;
public
final
StereoMode
int
stereoMode
;
public
final
boolean
singleMesh
;
public
Projection
(
Mesh
mesh
int
stereoMode
)
{
this
(
mesh
mesh
stereoMode
)
;
}
public
Projection
(
Mesh
leftMesh
Mesh
rightMesh
int
stereoMode
)
{
this
.
leftMesh
=
leftMesh
;
this
.
rightMesh
=
rightMesh
;
this
.
stereoMode
=
stereoMode
;
this
.
singleMesh
=
leftMesh
=
=
rightMesh
;
}
public
static
final
class
SubMesh
{
public
static
final
int
VIDEO_TEXTURE_ID
=
0
;
public
final
int
textureId
;
public
final
DrawMode
int
mode
;
public
final
float
[
]
vertices
;
public
final
float
[
]
textureCoords
;
public
SubMesh
(
int
textureId
float
[
]
vertices
float
[
]
textureCoords
DrawMode
int
mode
)
{
this
.
textureId
=
textureId
;
Assertions
.
checkArgument
(
vertices
.
length
*
(
long
)
TEXTURE_COORDS_PER_VERTEX
=
=
textureCoords
.
length
*
(
long
)
POSITION_COORDS_PER_VERTEX
)
;
this
.
vertices
=
vertices
;
this
.
textureCoords
=
textureCoords
;
this
.
mode
=
mode
;
}
public
int
getVertexCount
(
)
{
return
vertices
.
length
/
POSITION_COORDS_PER_VERTEX
;
}
}
public
static
final
class
Mesh
{
private
final
SubMesh
[
]
subMeshes
;
public
Mesh
(
SubMesh
.
.
.
subMeshes
)
{
this
.
subMeshes
=
subMeshes
;
}
public
int
getSubMeshCount
(
)
{
return
subMeshes
.
length
;
}
public
SubMesh
getSubMesh
(
int
index
)
{
return
subMeshes
[
index
]
;
}
}
}
