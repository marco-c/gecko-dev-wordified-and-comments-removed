package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
android
.
annotation
.
TargetApi
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCrypto
;
import
android
.
media
.
MediaFormat
;
import
android
.
media
.
audiofx
.
Virtualizer
;
import
android
.
os
.
Handler
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
PlaybackParameters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
AudioRendererEventListener
.
EventDispatcher
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
FrameworkMediaCrypto
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecInfo
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecRenderer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecSelector
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
mediacodec
.
MediaCodecUtil
.
DecoderQueryException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MediaClock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
nio
.
ByteBuffer
;
TargetApi
(
16
)
public
class
MediaCodecAudioRenderer
extends
MediaCodecRenderer
implements
MediaClock
{
private
final
EventDispatcher
eventDispatcher
;
private
final
AudioTrack
audioTrack
;
private
boolean
passthroughEnabled
;
private
boolean
codecNeedsDiscardChannelsWorkaround
;
private
android
.
media
.
MediaFormat
passthroughMediaFormat
;
private
int
pcmEncoding
;
private
int
channelCount
;
private
long
currentPositionUs
;
private
boolean
allowPositionDiscontinuity
;
public
MediaCodecAudioRenderer
(
MediaCodecSelector
mediaCodecSelector
)
{
this
(
mediaCodecSelector
null
true
)
;
}
public
MediaCodecAudioRenderer
(
MediaCodecSelector
mediaCodecSelector
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
)
{
this
(
mediaCodecSelector
drmSessionManager
playClearSamplesWithoutKeys
null
null
)
;
}
public
MediaCodecAudioRenderer
(
MediaCodecSelector
mediaCodecSelector
Handler
eventHandler
AudioRendererEventListener
eventListener
)
{
this
(
mediaCodecSelector
null
true
eventHandler
eventListener
)
;
}
public
MediaCodecAudioRenderer
(
MediaCodecSelector
mediaCodecSelector
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
Handler
eventHandler
AudioRendererEventListener
eventListener
)
{
this
(
mediaCodecSelector
drmSessionManager
playClearSamplesWithoutKeys
eventHandler
eventListener
null
)
;
}
public
MediaCodecAudioRenderer
(
MediaCodecSelector
mediaCodecSelector
DrmSessionManager
<
FrameworkMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
Handler
eventHandler
AudioRendererEventListener
eventListener
AudioCapabilities
audioCapabilities
AudioProcessor
.
.
.
audioProcessors
)
{
super
(
C
.
TRACK_TYPE_AUDIO
mediaCodecSelector
drmSessionManager
playClearSamplesWithoutKeys
)
;
audioTrack
=
new
AudioTrack
(
audioCapabilities
audioProcessors
new
AudioTrackListener
(
)
)
;
eventDispatcher
=
new
EventDispatcher
(
eventHandler
eventListener
)
;
}
Override
protected
int
supportsFormat
(
MediaCodecSelector
mediaCodecSelector
Format
format
)
throws
DecoderQueryException
{
String
mimeType
=
format
.
sampleMimeType
;
if
(
!
MimeTypes
.
isAudio
(
mimeType
)
)
{
return
FORMAT_UNSUPPORTED_TYPE
;
}
int
tunnelingSupport
=
Util
.
SDK_INT
>
=
21
?
TUNNELING_SUPPORTED
:
TUNNELING_NOT_SUPPORTED
;
if
(
allowPassthrough
(
mimeType
)
&
&
mediaCodecSelector
.
getPassthroughDecoderInfo
(
)
!
=
null
)
{
return
ADAPTIVE_NOT_SEAMLESS
|
tunnelingSupport
|
FORMAT_HANDLED
;
}
MediaCodecInfo
decoderInfo
=
mediaCodecSelector
.
getDecoderInfo
(
mimeType
false
)
;
if
(
decoderInfo
=
=
null
)
{
return
FORMAT_UNSUPPORTED_SUBTYPE
;
}
boolean
decoderCapable
=
Util
.
SDK_INT
<
21
|
|
(
(
format
.
sampleRate
=
=
Format
.
NO_VALUE
|
|
decoderInfo
.
isAudioSampleRateSupportedV21
(
format
.
sampleRate
)
)
&
&
(
format
.
channelCount
=
=
Format
.
NO_VALUE
|
|
decoderInfo
.
isAudioChannelCountSupportedV21
(
format
.
channelCount
)
)
)
;
int
formatSupport
=
decoderCapable
?
FORMAT_HANDLED
:
FORMAT_EXCEEDS_CAPABILITIES
;
return
ADAPTIVE_NOT_SEAMLESS
|
tunnelingSupport
|
formatSupport
;
}
Override
protected
MediaCodecInfo
getDecoderInfo
(
MediaCodecSelector
mediaCodecSelector
Format
format
boolean
requiresSecureDecoder
)
throws
DecoderQueryException
{
if
(
allowPassthrough
(
format
.
sampleMimeType
)
)
{
MediaCodecInfo
passthroughDecoderInfo
=
mediaCodecSelector
.
getPassthroughDecoderInfo
(
)
;
if
(
passthroughDecoderInfo
!
=
null
)
{
passthroughEnabled
=
true
;
return
passthroughDecoderInfo
;
}
}
passthroughEnabled
=
false
;
return
super
.
getDecoderInfo
(
mediaCodecSelector
format
requiresSecureDecoder
)
;
}
protected
boolean
allowPassthrough
(
String
mimeType
)
{
return
audioTrack
.
isPassthroughSupported
(
mimeType
)
;
}
Override
protected
void
configureCodec
(
MediaCodecInfo
codecInfo
MediaCodec
codec
Format
format
MediaCrypto
crypto
)
{
codecNeedsDiscardChannelsWorkaround
=
codecNeedsDiscardChannelsWorkaround
(
codecInfo
.
name
)
;
if
(
passthroughEnabled
)
{
passthroughMediaFormat
=
format
.
getFrameworkMediaFormatV16
(
)
;
passthroughMediaFormat
.
setString
(
MediaFormat
.
KEY_MIME
MimeTypes
.
AUDIO_RAW
)
;
codec
.
configure
(
passthroughMediaFormat
null
crypto
0
)
;
passthroughMediaFormat
.
setString
(
MediaFormat
.
KEY_MIME
format
.
sampleMimeType
)
;
}
else
{
codec
.
configure
(
format
.
getFrameworkMediaFormatV16
(
)
null
crypto
0
)
;
passthroughMediaFormat
=
null
;
}
}
Override
public
MediaClock
getMediaClock
(
)
{
return
this
;
}
Override
protected
void
onCodecInitialized
(
String
name
long
initializedTimestampMs
long
initializationDurationMs
)
{
eventDispatcher
.
decoderInitialized
(
name
initializedTimestampMs
initializationDurationMs
)
;
}
Override
protected
void
onInputFormatChanged
(
Format
newFormat
)
throws
ExoPlaybackException
{
super
.
onInputFormatChanged
(
newFormat
)
;
eventDispatcher
.
inputFormatChanged
(
newFormat
)
;
pcmEncoding
=
MimeTypes
.
AUDIO_RAW
.
equals
(
newFormat
.
sampleMimeType
)
?
newFormat
.
pcmEncoding
:
C
.
ENCODING_PCM_16BIT
;
channelCount
=
newFormat
.
channelCount
;
}
Override
protected
void
onOutputFormatChanged
(
MediaCodec
codec
MediaFormat
outputFormat
)
throws
ExoPlaybackException
{
boolean
passthrough
=
passthroughMediaFormat
!
=
null
;
String
mimeType
=
passthrough
?
passthroughMediaFormat
.
getString
(
MediaFormat
.
KEY_MIME
)
:
MimeTypes
.
AUDIO_RAW
;
MediaFormat
format
=
passthrough
?
passthroughMediaFormat
:
outputFormat
;
int
channelCount
=
format
.
getInteger
(
MediaFormat
.
KEY_CHANNEL_COUNT
)
;
int
sampleRate
=
format
.
getInteger
(
MediaFormat
.
KEY_SAMPLE_RATE
)
;
int
[
]
channelMap
;
if
(
codecNeedsDiscardChannelsWorkaround
&
&
channelCount
=
=
6
&
&
this
.
channelCount
<
6
)
{
channelMap
=
new
int
[
this
.
channelCount
]
;
for
(
int
i
=
0
;
i
<
this
.
channelCount
;
i
+
+
)
{
channelMap
[
i
]
=
i
;
}
}
else
{
channelMap
=
null
;
}
try
{
audioTrack
.
configure
(
mimeType
channelCount
sampleRate
pcmEncoding
0
channelMap
)
;
}
catch
(
AudioTrack
.
ConfigurationException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
}
protected
void
onAudioSessionId
(
int
audioSessionId
)
{
}
protected
void
onAudioTrackPositionDiscontinuity
(
)
{
}
protected
void
onAudioTrackUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
}
Override
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
super
.
onEnabled
(
joining
)
;
eventDispatcher
.
enabled
(
decoderCounters
)
;
int
tunnelingAudioSessionId
=
getConfiguration
(
)
.
tunnelingAudioSessionId
;
if
(
tunnelingAudioSessionId
!
=
C
.
AUDIO_SESSION_ID_UNSET
)
{
audioTrack
.
enableTunnelingV21
(
tunnelingAudioSessionId
)
;
}
else
{
audioTrack
.
disableTunneling
(
)
;
}
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
super
.
onPositionReset
(
positionUs
joining
)
;
audioTrack
.
reset
(
)
;
currentPositionUs
=
positionUs
;
allowPositionDiscontinuity
=
true
;
}
Override
protected
void
onStarted
(
)
{
super
.
onStarted
(
)
;
audioTrack
.
play
(
)
;
}
Override
protected
void
onStopped
(
)
{
audioTrack
.
pause
(
)
;
super
.
onStopped
(
)
;
}
Override
protected
void
onDisabled
(
)
{
try
{
audioTrack
.
release
(
)
;
}
finally
{
try
{
super
.
onDisabled
(
)
;
}
finally
{
decoderCounters
.
ensureUpdated
(
)
;
eventDispatcher
.
disabled
(
decoderCounters
)
;
}
}
}
Override
public
boolean
isEnded
(
)
{
return
super
.
isEnded
(
)
&
&
audioTrack
.
isEnded
(
)
;
}
Override
public
boolean
isReady
(
)
{
return
audioTrack
.
hasPendingData
(
)
|
|
super
.
isReady
(
)
;
}
Override
public
long
getPositionUs
(
)
{
long
newCurrentPositionUs
=
audioTrack
.
getCurrentPositionUs
(
isEnded
(
)
)
;
if
(
newCurrentPositionUs
!
=
AudioTrack
.
CURRENT_POSITION_NOT_SET
)
{
currentPositionUs
=
allowPositionDiscontinuity
?
newCurrentPositionUs
:
Math
.
max
(
currentPositionUs
newCurrentPositionUs
)
;
allowPositionDiscontinuity
=
false
;
}
return
currentPositionUs
;
}
Override
public
PlaybackParameters
setPlaybackParameters
(
PlaybackParameters
playbackParameters
)
{
return
audioTrack
.
setPlaybackParameters
(
playbackParameters
)
;
}
Override
public
PlaybackParameters
getPlaybackParameters
(
)
{
return
audioTrack
.
getPlaybackParameters
(
)
;
}
Override
protected
boolean
processOutputBuffer
(
long
positionUs
long
elapsedRealtimeUs
MediaCodec
codec
ByteBuffer
buffer
int
bufferIndex
int
bufferFlags
long
bufferPresentationTimeUs
boolean
shouldSkip
)
throws
ExoPlaybackException
{
if
(
passthroughEnabled
&
&
(
bufferFlags
&
MediaCodec
.
BUFFER_FLAG_CODEC_CONFIG
)
!
=
0
)
{
codec
.
releaseOutputBuffer
(
bufferIndex
false
)
;
return
true
;
}
if
(
shouldSkip
)
{
codec
.
releaseOutputBuffer
(
bufferIndex
false
)
;
decoderCounters
.
skippedOutputBufferCount
+
+
;
audioTrack
.
handleDiscontinuity
(
)
;
return
true
;
}
try
{
if
(
audioTrack
.
handleBuffer
(
buffer
bufferPresentationTimeUs
)
)
{
codec
.
releaseOutputBuffer
(
bufferIndex
false
)
;
decoderCounters
.
renderedOutputBufferCount
+
+
;
return
true
;
}
}
catch
(
AudioTrack
.
InitializationException
|
AudioTrack
.
WriteException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
return
false
;
}
Override
protected
void
renderToEndOfStream
(
)
throws
ExoPlaybackException
{
try
{
audioTrack
.
playToEndOfStream
(
)
;
}
catch
(
AudioTrack
.
WriteException
e
)
{
throw
ExoPlaybackException
.
createForRenderer
(
e
getIndex
(
)
)
;
}
}
Override
public
void
handleMessage
(
int
messageType
Object
message
)
throws
ExoPlaybackException
{
switch
(
messageType
)
{
case
C
.
MSG_SET_VOLUME
:
audioTrack
.
setVolume
(
(
Float
)
message
)
;
break
;
case
C
.
MSG_SET_STREAM_TYPE
:
C
.
StreamType
int
streamType
=
(
Integer
)
message
;
audioTrack
.
setStreamType
(
streamType
)
;
break
;
default
:
super
.
handleMessage
(
messageType
message
)
;
break
;
}
}
private
static
boolean
codecNeedsDiscardChannelsWorkaround
(
String
codecName
)
{
return
Util
.
SDK_INT
<
24
&
&
"
OMX
.
SEC
.
aac
.
dec
"
.
equals
(
codecName
)
&
&
"
samsung
"
.
equals
(
Util
.
MANUFACTURER
)
&
&
(
Util
.
DEVICE
.
startsWith
(
"
zeroflte
"
)
|
|
Util
.
DEVICE
.
startsWith
(
"
herolte
"
)
|
|
Util
.
DEVICE
.
startsWith
(
"
heroqlte
"
)
)
;
}
private
final
class
AudioTrackListener
implements
AudioTrack
.
Listener
{
Override
public
void
onAudioSessionId
(
int
audioSessionId
)
{
eventDispatcher
.
audioSessionId
(
audioSessionId
)
;
MediaCodecAudioRenderer
.
this
.
onAudioSessionId
(
audioSessionId
)
;
}
Override
public
void
onPositionDiscontinuity
(
)
{
onAudioTrackPositionDiscontinuity
(
)
;
MediaCodecAudioRenderer
.
this
.
allowPositionDiscontinuity
=
true
;
}
Override
public
void
onUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
eventDispatcher
.
audioTrackUnderrun
(
bufferSize
bufferSizeMs
elapsedSinceLastFeedMs
)
;
onAudioTrackUnderrun
(
bufferSize
bufferSizeMs
elapsedSinceLastFeedMs
)
;
}
}
}
