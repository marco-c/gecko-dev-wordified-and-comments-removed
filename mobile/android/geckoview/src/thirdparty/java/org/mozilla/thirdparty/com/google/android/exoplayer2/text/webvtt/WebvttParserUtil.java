package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
webvtt
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
final
class
WebvttParserUtil
{
private
static
final
Pattern
COMMENT
=
Pattern
.
compile
(
"
^
NOTE
(
[
\
t
]
.
*
)
?
"
)
;
private
static
final
String
WEBVTT_HEADER
=
"
WEBVTT
"
;
private
WebvttParserUtil
(
)
{
}
public
static
void
validateWebvttHeaderLine
(
ParsableByteArray
input
)
throws
ParserException
{
int
startPosition
=
input
.
getPosition
(
)
;
if
(
!
isWebvttHeaderLine
(
input
)
)
{
input
.
setPosition
(
startPosition
)
;
throw
new
ParserException
(
"
Expected
WEBVTT
.
Got
"
+
input
.
readLine
(
)
)
;
}
}
public
static
boolean
isWebvttHeaderLine
(
ParsableByteArray
input
)
{
Nullable
String
line
=
input
.
readLine
(
)
;
return
line
!
=
null
&
&
line
.
startsWith
(
WEBVTT_HEADER
)
;
}
public
static
long
parseTimestampUs
(
String
timestamp
)
throws
NumberFormatException
{
long
value
=
0
;
String
[
]
parts
=
Util
.
splitAtFirst
(
timestamp
"
\
\
.
"
)
;
String
[
]
subparts
=
Util
.
split
(
parts
[
0
]
"
:
"
)
;
for
(
String
subpart
:
subparts
)
{
value
=
(
value
*
60
)
+
Long
.
parseLong
(
subpart
)
;
}
value
*
=
1000
;
if
(
parts
.
length
=
=
2
)
{
value
+
=
Long
.
parseLong
(
parts
[
1
]
)
;
}
return
value
*
1000
;
}
public
static
float
parsePercentage
(
String
s
)
throws
NumberFormatException
{
if
(
!
s
.
endsWith
(
"
%
"
)
)
{
throw
new
NumberFormatException
(
"
Percentages
must
end
with
%
"
)
;
}
return
Float
.
parseFloat
(
s
.
substring
(
0
s
.
length
(
)
-
1
)
)
/
100
;
}
Nullable
public
static
Matcher
findNextCueHeader
(
ParsableByteArray
input
)
{
Nullable
String
line
;
while
(
(
line
=
input
.
readLine
(
)
)
!
=
null
)
{
if
(
COMMENT
.
matcher
(
line
)
.
matches
(
)
)
{
while
(
(
line
=
input
.
readLine
(
)
)
!
=
null
&
&
!
line
.
isEmpty
(
)
)
{
}
}
else
{
Matcher
cueHeaderMatcher
=
WebvttCueParser
.
CUE_HEADER_PATTERN
.
matcher
(
line
)
;
if
(
cueHeaderMatcher
.
matches
(
)
)
{
return
cueHeaderMatcher
;
}
}
}
return
null
;
}
}
