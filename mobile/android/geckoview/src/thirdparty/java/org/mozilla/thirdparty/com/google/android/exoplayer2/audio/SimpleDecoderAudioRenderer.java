package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
android
.
media
.
audiofx
.
Virtualizer
;
import
android
.
os
.
Handler
;
import
android
.
os
.
SystemClock
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
BaseRenderer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlayer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
PlaybackParameters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
PlayerMessage
.
Target
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
.
AudioRendererEventListener
.
EventDispatcher
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderCounters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
SimpleDecoder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
SimpleOutputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
.
DrmSessionException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
ExoMediaCrypto
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MediaClock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
abstract
class
SimpleDecoderAudioRenderer
extends
BaseRenderer
implements
MediaClock
{
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
REINITIALIZATION_STATE_NONE
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
}
)
private
interface
ReinitializationState
{
}
private
static
final
int
REINITIALIZATION_STATE_NONE
=
0
;
private
static
final
int
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
=
1
;
private
static
final
int
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
=
2
;
private
final
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
;
private
final
boolean
playClearSamplesWithoutKeys
;
private
final
EventDispatcher
eventDispatcher
;
private
final
AudioSink
audioSink
;
private
final
DecoderInputBuffer
flagsOnlyBuffer
;
private
boolean
drmResourcesAcquired
;
private
DecoderCounters
decoderCounters
;
private
Format
inputFormat
;
private
int
encoderDelay
;
private
int
encoderPadding
;
private
SimpleDecoder
<
DecoderInputBuffer
?
extends
SimpleOutputBuffer
?
extends
AudioDecoderException
>
decoder
;
private
DecoderInputBuffer
inputBuffer
;
private
SimpleOutputBuffer
outputBuffer
;
Nullable
private
DrmSession
<
ExoMediaCrypto
>
decoderDrmSession
;
Nullable
private
DrmSession
<
ExoMediaCrypto
>
sourceDrmSession
;
ReinitializationState
private
int
decoderReinitializationState
;
private
boolean
decoderReceivedBuffers
;
private
boolean
audioTrackNeedsConfigure
;
private
long
currentPositionUs
;
private
boolean
allowFirstBufferPositionDiscontinuity
;
private
boolean
allowPositionDiscontinuity
;
private
boolean
inputStreamEnded
;
private
boolean
outputStreamEnded
;
private
boolean
waitingForKeys
;
public
SimpleDecoderAudioRenderer
(
)
{
this
(
null
null
)
;
}
public
SimpleDecoderAudioRenderer
(
Nullable
Handler
eventHandler
Nullable
AudioRendererEventListener
eventListener
AudioProcessor
.
.
.
audioProcessors
)
{
this
(
eventHandler
eventListener
null
null
false
audioProcessors
)
;
}
public
SimpleDecoderAudioRenderer
(
Nullable
Handler
eventHandler
Nullable
AudioRendererEventListener
eventListener
Nullable
AudioCapabilities
audioCapabilities
)
{
this
(
eventHandler
eventListener
audioCapabilities
null
false
)
;
}
public
SimpleDecoderAudioRenderer
(
Nullable
Handler
eventHandler
Nullable
AudioRendererEventListener
eventListener
Nullable
AudioCapabilities
audioCapabilities
Nullable
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
AudioProcessor
.
.
.
audioProcessors
)
{
this
(
eventHandler
eventListener
drmSessionManager
playClearSamplesWithoutKeys
new
DefaultAudioSink
(
audioCapabilities
audioProcessors
)
)
;
}
public
SimpleDecoderAudioRenderer
(
Nullable
Handler
eventHandler
Nullable
AudioRendererEventListener
eventListener
Nullable
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
AudioSink
audioSink
)
{
super
(
C
.
TRACK_TYPE_AUDIO
)
;
this
.
drmSessionManager
=
drmSessionManager
;
this
.
playClearSamplesWithoutKeys
=
playClearSamplesWithoutKeys
;
eventDispatcher
=
new
EventDispatcher
(
eventHandler
eventListener
)
;
this
.
audioSink
=
audioSink
;
audioSink
.
setListener
(
new
AudioSinkListener
(
)
)
;
flagsOnlyBuffer
=
DecoderInputBuffer
.
newFlagsOnlyInstance
(
)
;
decoderReinitializationState
=
REINITIALIZATION_STATE_NONE
;
audioTrackNeedsConfigure
=
true
;
}
Override
Nullable
public
MediaClock
getMediaClock
(
)
{
return
this
;
}
Override
Capabilities
public
final
int
supportsFormat
(
Format
format
)
{
if
(
!
MimeTypes
.
isAudio
(
format
.
sampleMimeType
)
)
{
return
RendererCapabilities
.
create
(
FORMAT_UNSUPPORTED_TYPE
)
;
}
FormatSupport
int
formatSupport
=
supportsFormatInternal
(
drmSessionManager
format
)
;
if
(
formatSupport
<
=
FORMAT_UNSUPPORTED_DRM
)
{
return
RendererCapabilities
.
create
(
formatSupport
)
;
}
TunnelingSupport
int
tunnelingSupport
=
Util
.
SDK_INT
>
=
21
?
TUNNELING_SUPPORTED
:
TUNNELING_NOT_SUPPORTED
;
return
RendererCapabilities
.
create
(
formatSupport
ADAPTIVE_NOT_SEAMLESS
tunnelingSupport
)
;
}
FormatSupport
protected
abstract
int
supportsFormatInternal
(
Nullable
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
Format
format
)
;
protected
final
boolean
supportsOutput
(
int
channelCount
C
.
Encoding
int
encoding
)
{
return
audioSink
.
supportsOutput
(
channelCount
encoding
)
;
}
Override
public
void
render
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
{
if
(
outputStreamEnded
)
{
try
{
audioSink
.
playToEndOfStream
(
)
;
}
catch
(
AudioSink
.
WriteException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
return
;
}
if
(
inputFormat
=
=
null
)
{
FormatHolder
formatHolder
=
getFormatHolder
(
)
;
flagsOnlyBuffer
.
clear
(
)
;
int
result
=
readSource
(
formatHolder
flagsOnlyBuffer
true
)
;
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
)
;
}
else
if
(
result
=
=
C
.
RESULT_BUFFER_READ
)
{
Assertions
.
checkState
(
flagsOnlyBuffer
.
isEndOfStream
(
)
)
;
inputStreamEnded
=
true
;
processEndOfStream
(
)
;
return
;
}
else
{
return
;
}
}
maybeInitDecoder
(
)
;
if
(
decoder
!
=
null
)
{
try
{
TraceUtil
.
beginSection
(
"
drainAndFeed
"
)
;
while
(
drainOutputBuffer
(
)
)
{
}
while
(
feedInputBuffer
(
)
)
{
}
TraceUtil
.
endSection
(
)
;
}
catch
(
AudioDecoderException
|
AudioSink
.
ConfigurationException
|
AudioSink
.
InitializationException
|
AudioSink
.
WriteException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
decoderCounters
.
ensureUpdated
(
)
;
}
}
protected
void
onAudioSessionId
(
int
audioSessionId
)
{
}
protected
void
onAudioTrackPositionDiscontinuity
(
)
{
}
protected
void
onAudioTrackUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
}
protected
abstract
SimpleDecoder
<
DecoderInputBuffer
?
extends
SimpleOutputBuffer
?
extends
AudioDecoderException
>
createDecoder
(
Format
format
Nullable
ExoMediaCrypto
mediaCrypto
)
throws
AudioDecoderException
;
protected
abstract
Format
getOutputFormat
(
)
;
protected
boolean
canKeepCodec
(
Format
oldFormat
Format
newFormat
)
{
return
false
;
}
private
boolean
drainOutputBuffer
(
)
throws
ExoPlaybackException
AudioDecoderException
AudioSink
.
ConfigurationException
AudioSink
.
InitializationException
AudioSink
.
WriteException
{
if
(
outputBuffer
=
=
null
)
{
outputBuffer
=
decoder
.
dequeueOutputBuffer
(
)
;
if
(
outputBuffer
=
=
null
)
{
return
false
;
}
if
(
outputBuffer
.
skippedOutputBufferCount
>
0
)
{
decoderCounters
.
skippedOutputBufferCount
+
=
outputBuffer
.
skippedOutputBufferCount
;
audioSink
.
handleDiscontinuity
(
)
;
}
}
if
(
outputBuffer
.
isEndOfStream
(
)
)
{
if
(
decoderReinitializationState
=
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
)
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
audioTrackNeedsConfigure
=
true
;
}
else
{
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
processEndOfStream
(
)
;
}
return
false
;
}
if
(
audioTrackNeedsConfigure
)
{
Format
outputFormat
=
getOutputFormat
(
)
;
audioSink
.
configure
(
outputFormat
.
pcmEncoding
outputFormat
.
channelCount
outputFormat
.
sampleRate
0
null
encoderDelay
encoderPadding
)
;
audioTrackNeedsConfigure
=
false
;
}
if
(
audioSink
.
handleBuffer
(
outputBuffer
.
data
outputBuffer
.
timeUs
)
)
{
decoderCounters
.
renderedOutputBufferCount
+
+
;
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
return
true
;
}
return
false
;
}
private
boolean
feedInputBuffer
(
)
throws
AudioDecoderException
ExoPlaybackException
{
if
(
decoder
=
=
null
|
|
decoderReinitializationState
=
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
|
|
inputStreamEnded
)
{
return
false
;
}
if
(
inputBuffer
=
=
null
)
{
inputBuffer
=
decoder
.
dequeueInputBuffer
(
)
;
if
(
inputBuffer
=
=
null
)
{
return
false
;
}
}
if
(
decoderReinitializationState
=
=
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
)
{
inputBuffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
inputBuffer
=
null
;
decoderReinitializationState
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
;
return
false
;
}
int
result
;
FormatHolder
formatHolder
=
getFormatHolder
(
)
;
if
(
waitingForKeys
)
{
result
=
C
.
RESULT_BUFFER_READ
;
}
else
{
result
=
readSource
(
formatHolder
inputBuffer
false
)
;
}
if
(
result
=
=
C
.
RESULT_NOTHING_READ
)
{
return
false
;
}
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
)
;
return
true
;
}
if
(
inputBuffer
.
isEndOfStream
(
)
)
{
inputStreamEnded
=
true
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
inputBuffer
=
null
;
return
false
;
}
boolean
bufferEncrypted
=
inputBuffer
.
isEncrypted
(
)
;
waitingForKeys
=
shouldWaitForKeys
(
bufferEncrypted
)
;
if
(
waitingForKeys
)
{
return
false
;
}
inputBuffer
.
flip
(
)
;
onQueueInputBuffer
(
inputBuffer
)
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
decoderReceivedBuffers
=
true
;
decoderCounters
.
inputBufferCount
+
+
;
inputBuffer
=
null
;
return
true
;
}
private
boolean
shouldWaitForKeys
(
boolean
bufferEncrypted
)
throws
ExoPlaybackException
{
if
(
decoderDrmSession
=
=
null
|
|
(
!
bufferEncrypted
&
&
(
playClearSamplesWithoutKeys
|
|
decoderDrmSession
.
playClearSamplesWithoutKeys
(
)
)
)
)
{
return
false
;
}
DrmSession
.
State
int
drmSessionState
=
decoderDrmSession
.
getState
(
)
;
if
(
drmSessionState
=
=
DrmSession
.
STATE_ERROR
)
{
throw
createRendererException
(
decoderDrmSession
.
getError
(
)
inputFormat
)
;
}
return
drmSessionState
!
=
DrmSession
.
STATE_OPENED_WITH_KEYS
;
}
private
void
processEndOfStream
(
)
throws
ExoPlaybackException
{
outputStreamEnded
=
true
;
try
{
audioSink
.
playToEndOfStream
(
)
;
}
catch
(
AudioSink
.
WriteException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
}
private
void
flushDecoder
(
)
throws
ExoPlaybackException
{
waitingForKeys
=
false
;
if
(
decoderReinitializationState
!
=
REINITIALIZATION_STATE_NONE
)
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
}
else
{
inputBuffer
=
null
;
if
(
outputBuffer
!
=
null
)
{
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
}
decoder
.
flush
(
)
;
decoderReceivedBuffers
=
false
;
}
}
Override
public
boolean
isEnded
(
)
{
return
outputStreamEnded
&
&
audioSink
.
isEnded
(
)
;
}
Override
public
boolean
isReady
(
)
{
return
audioSink
.
hasPendingData
(
)
|
|
(
inputFormat
!
=
null
&
&
!
waitingForKeys
&
&
(
isSourceReady
(
)
|
|
outputBuffer
!
=
null
)
)
;
}
Override
public
long
getPositionUs
(
)
{
if
(
getState
(
)
=
=
STATE_STARTED
)
{
updateCurrentPosition
(
)
;
}
return
currentPositionUs
;
}
Override
public
void
setPlaybackParameters
(
PlaybackParameters
playbackParameters
)
{
audioSink
.
setPlaybackParameters
(
playbackParameters
)
;
}
Override
public
PlaybackParameters
getPlaybackParameters
(
)
{
return
audioSink
.
getPlaybackParameters
(
)
;
}
Override
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
if
(
drmSessionManager
!
=
null
&
&
!
drmResourcesAcquired
)
{
drmResourcesAcquired
=
true
;
drmSessionManager
.
prepare
(
)
;
}
decoderCounters
=
new
DecoderCounters
(
)
;
eventDispatcher
.
enabled
(
decoderCounters
)
;
int
tunnelingAudioSessionId
=
getConfiguration
(
)
.
tunnelingAudioSessionId
;
if
(
tunnelingAudioSessionId
!
=
C
.
AUDIO_SESSION_ID_UNSET
)
{
audioSink
.
enableTunnelingV21
(
tunnelingAudioSessionId
)
;
}
else
{
audioSink
.
disableTunneling
(
)
;
}
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
audioSink
.
flush
(
)
;
currentPositionUs
=
positionUs
;
allowFirstBufferPositionDiscontinuity
=
true
;
allowPositionDiscontinuity
=
true
;
inputStreamEnded
=
false
;
outputStreamEnded
=
false
;
if
(
decoder
!
=
null
)
{
flushDecoder
(
)
;
}
}
Override
protected
void
onStarted
(
)
{
audioSink
.
play
(
)
;
}
Override
protected
void
onStopped
(
)
{
updateCurrentPosition
(
)
;
audioSink
.
pause
(
)
;
}
Override
protected
void
onDisabled
(
)
{
inputFormat
=
null
;
audioTrackNeedsConfigure
=
true
;
waitingForKeys
=
false
;
try
{
setSourceDrmSession
(
null
)
;
releaseDecoder
(
)
;
audioSink
.
reset
(
)
;
}
finally
{
eventDispatcher
.
disabled
(
decoderCounters
)
;
}
}
Override
protected
void
onReset
(
)
{
if
(
drmSessionManager
!
=
null
&
&
drmResourcesAcquired
)
{
drmResourcesAcquired
=
false
;
drmSessionManager
.
release
(
)
;
}
}
Override
public
void
handleMessage
(
int
messageType
Nullable
Object
message
)
throws
ExoPlaybackException
{
switch
(
messageType
)
{
case
C
.
MSG_SET_VOLUME
:
audioSink
.
setVolume
(
(
Float
)
message
)
;
break
;
case
C
.
MSG_SET_AUDIO_ATTRIBUTES
:
AudioAttributes
audioAttributes
=
(
AudioAttributes
)
message
;
audioSink
.
setAudioAttributes
(
audioAttributes
)
;
break
;
case
C
.
MSG_SET_AUX_EFFECT_INFO
:
AuxEffectInfo
auxEffectInfo
=
(
AuxEffectInfo
)
message
;
audioSink
.
setAuxEffectInfo
(
auxEffectInfo
)
;
break
;
default
:
super
.
handleMessage
(
messageType
message
)
;
break
;
}
}
private
void
maybeInitDecoder
(
)
throws
ExoPlaybackException
{
if
(
decoder
!
=
null
)
{
return
;
}
setDecoderDrmSession
(
sourceDrmSession
)
;
ExoMediaCrypto
mediaCrypto
=
null
;
if
(
decoderDrmSession
!
=
null
)
{
mediaCrypto
=
decoderDrmSession
.
getMediaCrypto
(
)
;
if
(
mediaCrypto
=
=
null
)
{
DrmSessionException
drmError
=
decoderDrmSession
.
getError
(
)
;
if
(
drmError
!
=
null
)
{
}
else
{
return
;
}
}
}
try
{
long
codecInitializingTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
TraceUtil
.
beginSection
(
"
createAudioDecoder
"
)
;
decoder
=
createDecoder
(
inputFormat
mediaCrypto
)
;
TraceUtil
.
endSection
(
)
;
long
codecInitializedTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
eventDispatcher
.
decoderInitialized
(
decoder
.
getName
(
)
codecInitializedTimestamp
codecInitializedTimestamp
-
codecInitializingTimestamp
)
;
decoderCounters
.
decoderInitCount
+
+
;
}
catch
(
AudioDecoderException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
}
private
void
releaseDecoder
(
)
{
inputBuffer
=
null
;
outputBuffer
=
null
;
decoderReinitializationState
=
REINITIALIZATION_STATE_NONE
;
decoderReceivedBuffers
=
false
;
if
(
decoder
!
=
null
)
{
decoder
.
release
(
)
;
decoder
=
null
;
decoderCounters
.
decoderReleaseCount
+
+
;
}
setDecoderDrmSession
(
null
)
;
}
private
void
setSourceDrmSession
(
Nullable
DrmSession
<
ExoMediaCrypto
>
session
)
{
DrmSession
.
replaceSession
(
sourceDrmSession
session
)
;
sourceDrmSession
=
session
;
}
private
void
setDecoderDrmSession
(
Nullable
DrmSession
<
ExoMediaCrypto
>
session
)
{
DrmSession
.
replaceSession
(
decoderDrmSession
session
)
;
decoderDrmSession
=
session
;
}
SuppressWarnings
(
"
unchecked
"
)
private
void
onInputFormatChanged
(
FormatHolder
formatHolder
)
throws
ExoPlaybackException
{
Format
newFormat
=
Assertions
.
checkNotNull
(
formatHolder
.
format
)
;
if
(
formatHolder
.
includesDrmSession
)
{
setSourceDrmSession
(
(
DrmSession
<
ExoMediaCrypto
>
)
formatHolder
.
drmSession
)
;
}
else
{
sourceDrmSession
=
getUpdatedSourceDrmSession
(
inputFormat
newFormat
drmSessionManager
sourceDrmSession
)
;
}
Format
oldFormat
=
inputFormat
;
inputFormat
=
newFormat
;
if
(
!
canKeepCodec
(
oldFormat
inputFormat
)
)
{
if
(
decoderReceivedBuffers
)
{
decoderReinitializationState
=
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
;
}
else
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
audioTrackNeedsConfigure
=
true
;
}
}
encoderDelay
=
inputFormat
.
encoderDelay
;
encoderPadding
=
inputFormat
.
encoderPadding
;
eventDispatcher
.
inputFormatChanged
(
inputFormat
)
;
}
private
void
onQueueInputBuffer
(
DecoderInputBuffer
buffer
)
{
if
(
allowFirstBufferPositionDiscontinuity
&
&
!
buffer
.
isDecodeOnly
(
)
)
{
if
(
Math
.
abs
(
buffer
.
timeUs
-
currentPositionUs
)
>
500000
)
{
currentPositionUs
=
buffer
.
timeUs
;
}
allowFirstBufferPositionDiscontinuity
=
false
;
}
}
private
void
updateCurrentPosition
(
)
{
long
newCurrentPositionUs
=
audioSink
.
getCurrentPositionUs
(
isEnded
(
)
)
;
if
(
newCurrentPositionUs
!
=
AudioSink
.
CURRENT_POSITION_NOT_SET
)
{
currentPositionUs
=
allowPositionDiscontinuity
?
newCurrentPositionUs
:
Math
.
max
(
currentPositionUs
newCurrentPositionUs
)
;
allowPositionDiscontinuity
=
false
;
}
}
private
final
class
AudioSinkListener
implements
AudioSink
.
Listener
{
Override
public
void
onAudioSessionId
(
int
audioSessionId
)
{
eventDispatcher
.
audioSessionId
(
audioSessionId
)
;
SimpleDecoderAudioRenderer
.
this
.
onAudioSessionId
(
audioSessionId
)
;
}
Override
public
void
onPositionDiscontinuity
(
)
{
onAudioTrackPositionDiscontinuity
(
)
;
SimpleDecoderAudioRenderer
.
this
.
allowPositionDiscontinuity
=
true
;
}
Override
public
void
onUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
eventDispatcher
.
audioTrackUnderrun
(
bufferSize
bufferSizeMs
elapsedSinceLastFeedMs
)
;
onAudioTrackUnderrun
(
bufferSize
bufferSizeMs
elapsedSinceLastFeedMs
)
;
}
}
}
