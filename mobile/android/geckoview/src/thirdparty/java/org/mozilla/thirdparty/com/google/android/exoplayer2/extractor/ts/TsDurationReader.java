package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
final
class
TsDurationReader
{
private
static
final
int
TIMESTAMP_SEARCH_BYTES
=
600
*
TsExtractor
.
TS_PACKET_SIZE
;
private
final
TimestampAdjuster
pcrTimestampAdjuster
;
private
final
ParsableByteArray
packetBuffer
;
private
boolean
isDurationRead
;
private
boolean
isFirstPcrValueRead
;
private
boolean
isLastPcrValueRead
;
private
long
firstPcrValue
;
private
long
lastPcrValue
;
private
long
durationUs
;
TsDurationReader
(
)
{
pcrTimestampAdjuster
=
new
TimestampAdjuster
(
0
)
;
firstPcrValue
=
C
.
TIME_UNSET
;
lastPcrValue
=
C
.
TIME_UNSET
;
durationUs
=
C
.
TIME_UNSET
;
packetBuffer
=
new
ParsableByteArray
(
)
;
}
public
boolean
isDurationReadFinished
(
)
{
return
isDurationRead
;
}
public
Extractor
.
ReadResult
int
readDuration
(
ExtractorInput
input
PositionHolder
seekPositionHolder
int
pcrPid
)
throws
IOException
InterruptedException
{
if
(
pcrPid
<
=
0
)
{
return
finishReadDuration
(
input
)
;
}
if
(
!
isLastPcrValueRead
)
{
return
readLastPcrValue
(
input
seekPositionHolder
pcrPid
)
;
}
if
(
lastPcrValue
=
=
C
.
TIME_UNSET
)
{
return
finishReadDuration
(
input
)
;
}
if
(
!
isFirstPcrValueRead
)
{
return
readFirstPcrValue
(
input
seekPositionHolder
pcrPid
)
;
}
if
(
firstPcrValue
=
=
C
.
TIME_UNSET
)
{
return
finishReadDuration
(
input
)
;
}
long
minPcrPositionUs
=
pcrTimestampAdjuster
.
adjustTsTimestamp
(
firstPcrValue
)
;
long
maxPcrPositionUs
=
pcrTimestampAdjuster
.
adjustTsTimestamp
(
lastPcrValue
)
;
durationUs
=
maxPcrPositionUs
-
minPcrPositionUs
;
return
finishReadDuration
(
input
)
;
}
public
long
getDurationUs
(
)
{
return
durationUs
;
}
public
TimestampAdjuster
getPcrTimestampAdjuster
(
)
{
return
pcrTimestampAdjuster
;
}
private
int
finishReadDuration
(
ExtractorInput
input
)
{
packetBuffer
.
reset
(
Util
.
EMPTY_BYTE_ARRAY
)
;
isDurationRead
=
true
;
input
.
resetPeekPosition
(
)
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
int
readFirstPcrValue
(
ExtractorInput
input
PositionHolder
seekPositionHolder
int
pcrPid
)
throws
IOException
InterruptedException
{
int
bytesToSearch
=
(
int
)
Math
.
min
(
TIMESTAMP_SEARCH_BYTES
input
.
getLength
(
)
)
;
int
searchStartPosition
=
0
;
if
(
input
.
getPosition
(
)
!
=
searchStartPosition
)
{
seekPositionHolder
.
position
=
searchStartPosition
;
return
Extractor
.
RESULT_SEEK
;
}
packetBuffer
.
reset
(
bytesToSearch
)
;
input
.
resetPeekPosition
(
)
;
input
.
peekFully
(
packetBuffer
.
data
0
bytesToSearch
)
;
firstPcrValue
=
readFirstPcrValueFromBuffer
(
packetBuffer
pcrPid
)
;
isFirstPcrValueRead
=
true
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
long
readFirstPcrValueFromBuffer
(
ParsableByteArray
packetBuffer
int
pcrPid
)
{
int
searchStartPosition
=
packetBuffer
.
getPosition
(
)
;
int
searchEndPosition
=
packetBuffer
.
limit
(
)
;
for
(
int
searchPosition
=
searchStartPosition
;
searchPosition
<
searchEndPosition
;
searchPosition
+
+
)
{
if
(
packetBuffer
.
data
[
searchPosition
]
!
=
TsExtractor
.
TS_SYNC_BYTE
)
{
continue
;
}
long
pcrValue
=
TsUtil
.
readPcrFromPacket
(
packetBuffer
searchPosition
pcrPid
)
;
if
(
pcrValue
!
=
C
.
TIME_UNSET
)
{
return
pcrValue
;
}
}
return
C
.
TIME_UNSET
;
}
private
int
readLastPcrValue
(
ExtractorInput
input
PositionHolder
seekPositionHolder
int
pcrPid
)
throws
IOException
InterruptedException
{
long
inputLength
=
input
.
getLength
(
)
;
int
bytesToSearch
=
(
int
)
Math
.
min
(
TIMESTAMP_SEARCH_BYTES
inputLength
)
;
long
searchStartPosition
=
inputLength
-
bytesToSearch
;
if
(
input
.
getPosition
(
)
!
=
searchStartPosition
)
{
seekPositionHolder
.
position
=
searchStartPosition
;
return
Extractor
.
RESULT_SEEK
;
}
packetBuffer
.
reset
(
bytesToSearch
)
;
input
.
resetPeekPosition
(
)
;
input
.
peekFully
(
packetBuffer
.
data
0
bytesToSearch
)
;
lastPcrValue
=
readLastPcrValueFromBuffer
(
packetBuffer
pcrPid
)
;
isLastPcrValueRead
=
true
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
long
readLastPcrValueFromBuffer
(
ParsableByteArray
packetBuffer
int
pcrPid
)
{
int
searchStartPosition
=
packetBuffer
.
getPosition
(
)
;
int
searchEndPosition
=
packetBuffer
.
limit
(
)
;
for
(
int
searchPosition
=
searchEndPosition
-
1
;
searchPosition
>
=
searchStartPosition
;
searchPosition
-
-
)
{
if
(
packetBuffer
.
data
[
searchPosition
]
!
=
TsExtractor
.
TS_SYNC_BYTE
)
{
continue
;
}
long
pcrValue
=
TsUtil
.
readPcrFromPacket
(
packetBuffer
searchPosition
pcrPid
)
;
if
(
pcrValue
!
=
C
.
TIME_UNSET
)
{
return
pcrValue
;
}
}
return
C
.
TIME_UNSET
;
}
}
