package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
flv
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
NalUnitUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
.
AvcConfig
;
final
class
VideoTagPayloadReader
extends
TagPayloadReader
{
private
static
final
int
VIDEO_CODEC_AVC
=
7
;
private
static
final
int
VIDEO_FRAME_KEYFRAME
=
1
;
private
static
final
int
VIDEO_FRAME_VIDEO_INFO
=
5
;
private
static
final
int
AVC_PACKET_TYPE_SEQUENCE_HEADER
=
0
;
private
static
final
int
AVC_PACKET_TYPE_AVC_NALU
=
1
;
private
final
ParsableByteArray
nalStartCode
;
private
final
ParsableByteArray
nalLength
;
private
int
nalUnitLengthFieldLength
;
private
boolean
hasOutputFormat
;
private
boolean
hasOutputKeyframe
;
private
int
frameType
;
public
VideoTagPayloadReader
(
TrackOutput
output
)
{
super
(
output
)
;
nalStartCode
=
new
ParsableByteArray
(
NalUnitUtil
.
NAL_START_CODE
)
;
nalLength
=
new
ParsableByteArray
(
4
)
;
}
Override
public
void
seek
(
)
{
hasOutputKeyframe
=
false
;
}
Override
protected
boolean
parseHeader
(
ParsableByteArray
data
)
throws
UnsupportedFormatException
{
int
header
=
data
.
readUnsignedByte
(
)
;
int
frameType
=
(
header
>
>
4
)
&
0x0F
;
int
videoCodec
=
(
header
&
0x0F
)
;
if
(
videoCodec
!
=
VIDEO_CODEC_AVC
)
{
throw
new
UnsupportedFormatException
(
"
Video
format
not
supported
:
"
+
videoCodec
)
;
}
this
.
frameType
=
frameType
;
return
(
frameType
!
=
VIDEO_FRAME_VIDEO_INFO
)
;
}
Override
protected
boolean
parsePayload
(
ParsableByteArray
data
long
timeUs
)
throws
ParserException
{
int
packetType
=
data
.
readUnsignedByte
(
)
;
int
compositionTimeMs
=
data
.
readInt24
(
)
;
timeUs
+
=
compositionTimeMs
*
1000L
;
if
(
packetType
=
=
AVC_PACKET_TYPE_SEQUENCE_HEADER
&
&
!
hasOutputFormat
)
{
ParsableByteArray
videoSequence
=
new
ParsableByteArray
(
new
byte
[
data
.
bytesLeft
(
)
]
)
;
data
.
readBytes
(
videoSequence
.
data
0
data
.
bytesLeft
(
)
)
;
AvcConfig
avcConfig
=
AvcConfig
.
parse
(
videoSequence
)
;
nalUnitLengthFieldLength
=
avcConfig
.
nalUnitLengthFieldLength
;
Format
format
=
Format
.
createVideoSampleFormat
(
null
MimeTypes
.
VIDEO_H264
null
Format
.
NO_VALUE
Format
.
NO_VALUE
avcConfig
.
width
avcConfig
.
height
Format
.
NO_VALUE
avcConfig
.
initializationData
Format
.
NO_VALUE
avcConfig
.
pixelWidthAspectRatio
null
)
;
output
.
format
(
format
)
;
hasOutputFormat
=
true
;
return
false
;
}
else
if
(
packetType
=
=
AVC_PACKET_TYPE_AVC_NALU
&
&
hasOutputFormat
)
{
boolean
isKeyframe
=
frameType
=
=
VIDEO_FRAME_KEYFRAME
;
if
(
!
hasOutputKeyframe
&
&
!
isKeyframe
)
{
return
false
;
}
byte
[
]
nalLengthData
=
nalLength
.
data
;
nalLengthData
[
0
]
=
0
;
nalLengthData
[
1
]
=
0
;
nalLengthData
[
2
]
=
0
;
int
nalUnitLengthFieldLengthDiff
=
4
-
nalUnitLengthFieldLength
;
int
bytesWritten
=
0
;
int
bytesToWrite
;
while
(
data
.
bytesLeft
(
)
>
0
)
{
data
.
readBytes
(
nalLength
.
data
nalUnitLengthFieldLengthDiff
nalUnitLengthFieldLength
)
;
nalLength
.
setPosition
(
0
)
;
bytesToWrite
=
nalLength
.
readUnsignedIntToInt
(
)
;
nalStartCode
.
setPosition
(
0
)
;
output
.
sampleData
(
nalStartCode
4
)
;
bytesWritten
+
=
4
;
output
.
sampleData
(
data
bytesToWrite
)
;
bytesWritten
+
=
bytesToWrite
;
}
output
.
sampleMetadata
(
timeUs
isKeyframe
?
C
.
BUFFER_FLAG_KEY_FRAME
:
0
bytesWritten
0
null
)
;
hasOutputKeyframe
=
true
;
return
true
;
}
else
{
return
false
;
}
}
}
