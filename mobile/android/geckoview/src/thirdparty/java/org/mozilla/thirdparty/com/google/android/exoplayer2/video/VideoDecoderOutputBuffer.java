package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
OutputBuffer
;
import
java
.
nio
.
ByteBuffer
;
public
class
VideoDecoderOutputBuffer
extends
OutputBuffer
{
public
interface
Owner
{
void
releaseOutputBuffer
(
VideoDecoderOutputBuffer
outputBuffer
)
;
}
public
static
final
int
COLORSPACE_UNKNOWN
=
0
;
public
static
final
int
COLORSPACE_BT601
=
1
;
public
static
final
int
COLORSPACE_BT709
=
2
;
public
static
final
int
COLORSPACE_BT2020
=
3
;
public
int
decoderPrivate
;
C
.
VideoOutputMode
public
int
mode
;
Nullable
public
ByteBuffer
data
;
public
int
width
;
public
int
height
;
Nullable
public
ColorInfo
colorInfo
;
Nullable
public
ByteBuffer
[
]
yuvPlanes
;
Nullable
public
int
[
]
yuvStrides
;
public
int
colorspace
;
Nullable
public
ByteBuffer
supplementalData
;
private
final
Owner
owner
;
public
VideoDecoderOutputBuffer
(
Owner
owner
)
{
this
.
owner
=
owner
;
}
Override
public
void
release
(
)
{
owner
.
releaseOutputBuffer
(
this
)
;
}
public
void
init
(
long
timeUs
C
.
VideoOutputMode
int
mode
Nullable
ByteBuffer
supplementalData
)
{
this
.
timeUs
=
timeUs
;
this
.
mode
=
mode
;
if
(
supplementalData
!
=
null
&
&
supplementalData
.
hasRemaining
(
)
)
{
addFlag
(
C
.
BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA
)
;
int
size
=
supplementalData
.
limit
(
)
;
if
(
this
.
supplementalData
=
=
null
|
|
this
.
supplementalData
.
capacity
(
)
<
size
)
{
this
.
supplementalData
=
ByteBuffer
.
allocate
(
size
)
;
}
else
{
this
.
supplementalData
.
clear
(
)
;
}
this
.
supplementalData
.
put
(
supplementalData
)
;
this
.
supplementalData
.
flip
(
)
;
supplementalData
.
position
(
0
)
;
}
else
{
this
.
supplementalData
=
null
;
}
}
public
boolean
initForYuvFrame
(
int
width
int
height
int
yStride
int
uvStride
int
colorspace
)
{
this
.
width
=
width
;
this
.
height
=
height
;
this
.
colorspace
=
colorspace
;
int
uvHeight
=
(
int
)
(
(
(
long
)
height
+
1
)
/
2
)
;
if
(
!
isSafeToMultiply
(
yStride
height
)
|
|
!
isSafeToMultiply
(
uvStride
uvHeight
)
)
{
return
false
;
}
int
yLength
=
yStride
*
height
;
int
uvLength
=
uvStride
*
uvHeight
;
int
minimumYuvSize
=
yLength
+
(
uvLength
*
2
)
;
if
(
!
isSafeToMultiply
(
uvLength
2
)
|
|
minimumYuvSize
<
yLength
)
{
return
false
;
}
if
(
data
=
=
null
|
|
data
.
capacity
(
)
<
minimumYuvSize
)
{
data
=
ByteBuffer
.
allocateDirect
(
minimumYuvSize
)
;
}
else
{
data
.
position
(
0
)
;
data
.
limit
(
minimumYuvSize
)
;
}
if
(
yuvPlanes
=
=
null
)
{
yuvPlanes
=
new
ByteBuffer
[
3
]
;
}
ByteBuffer
data
=
this
.
data
;
ByteBuffer
[
]
yuvPlanes
=
this
.
yuvPlanes
;
yuvPlanes
[
0
]
=
data
.
slice
(
)
;
yuvPlanes
[
0
]
.
limit
(
yLength
)
;
data
.
position
(
yLength
)
;
yuvPlanes
[
1
]
=
data
.
slice
(
)
;
yuvPlanes
[
1
]
.
limit
(
uvLength
)
;
data
.
position
(
yLength
+
uvLength
)
;
yuvPlanes
[
2
]
=
data
.
slice
(
)
;
yuvPlanes
[
2
]
.
limit
(
uvLength
)
;
if
(
yuvStrides
=
=
null
)
{
yuvStrides
=
new
int
[
3
]
;
}
yuvStrides
[
0
]
=
yStride
;
yuvStrides
[
1
]
=
uvStride
;
yuvStrides
[
2
]
=
uvStride
;
return
true
;
}
public
void
initForPrivateFrame
(
int
width
int
height
)
{
this
.
width
=
width
;
this
.
height
=
height
;
}
private
static
boolean
isSafeToMultiply
(
int
a
int
b
)
{
return
a
>
=
0
&
&
b
>
=
0
&
&
!
(
b
>
0
&
&
a
>
=
Integer
.
MAX_VALUE
/
b
)
;
}
}
