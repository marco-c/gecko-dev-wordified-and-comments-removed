package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
cea
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
Typeface
;
import
android
.
text
.
Layout
.
Alignment
;
import
android
.
text
.
SpannableString
;
import
android
.
text
.
SpannableStringBuilder
;
import
android
.
text
.
Spanned
;
import
android
.
text
.
style
.
CharacterStyle
;
import
android
.
text
.
style
.
ForegroundColorSpan
;
import
android
.
text
.
style
.
StyleSpan
;
import
android
.
text
.
style
.
UnderlineSpan
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
Cue
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
Subtitle
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SubtitleDecoder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SubtitleInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
public
final
class
Cea608Decoder
extends
CeaDecoder
{
private
static
final
int
CC_VALID_FLAG
=
0x04
;
private
static
final
int
CC_TYPE_FLAG
=
0x02
;
private
static
final
int
CC_FIELD_FLAG
=
0x01
;
private
static
final
int
NTSC_CC_FIELD_1
=
0x00
;
private
static
final
int
NTSC_CC_FIELD_2
=
0x01
;
private
static
final
int
CC_VALID_608_ID
=
0x04
;
private
static
final
int
CC_MODE_UNKNOWN
=
0
;
private
static
final
int
CC_MODE_ROLL_UP
=
1
;
private
static
final
int
CC_MODE_POP_ON
=
2
;
private
static
final
int
CC_MODE_PAINT_ON
=
3
;
private
static
final
int
[
]
ROW_INDICES
=
new
int
[
]
{
11
1
3
12
14
5
7
9
}
;
private
static
final
int
[
]
COLUMN_INDICES
=
new
int
[
]
{
0
4
8
12
16
20
24
28
}
;
private
static
final
int
[
]
COLORS
=
new
int
[
]
{
Color
.
WHITE
Color
.
GREEN
Color
.
BLUE
Color
.
CYAN
Color
.
RED
Color
.
YELLOW
Color
.
MAGENTA
}
;
private
static
final
int
DEFAULT_CAPTIONS_ROW_COUNT
=
4
;
private
static
final
byte
CC_IMPLICIT_DATA_HEADER
=
(
byte
)
0xFC
;
private
static
final
byte
CTRL_RESUME_CAPTION_LOADING
=
0x20
;
private
static
final
byte
CTRL_ROLL_UP_CAPTIONS_2_ROWS
=
0x25
;
private
static
final
byte
CTRL_ROLL_UP_CAPTIONS_3_ROWS
=
0x26
;
private
static
final
byte
CTRL_ROLL_UP_CAPTIONS_4_ROWS
=
0x27
;
private
static
final
byte
CTRL_RESUME_DIRECT_CAPTIONING
=
0x29
;
private
static
final
byte
CTRL_END_OF_CAPTION
=
0x2F
;
private
static
final
byte
CTRL_ERASE_DISPLAYED_MEMORY
=
0x2C
;
private
static
final
byte
CTRL_CARRIAGE_RETURN
=
0x2D
;
private
static
final
byte
CTRL_ERASE_NON_DISPLAYED_MEMORY
=
0x2E
;
private
static
final
byte
CTRL_DELETE_TO_END_OF_ROW
=
0x24
;
private
static
final
byte
CTRL_BACKSPACE
=
0x21
;
private
static
final
int
[
]
BASIC_CHARACTER_SET
=
new
int
[
]
{
0x20
0x21
0x22
0x23
0x24
0x25
0x26
0x27
0x28
0x29
0xE1
0x2B
0x2C
0x2D
0x2E
0x2F
0x30
0x31
0x32
0x33
0x34
0x35
0x36
0x37
0x38
0x39
0x3A
0x3B
0x3C
0x3D
0x3E
0x3F
0x40
0x41
0x42
0x43
0x44
0x45
0x46
0x47
0x48
0x49
0x4A
0x4B
0x4C
0x4D
0x4E
0x4F
0x50
0x51
0x52
0x53
0x54
0x55
0x56
0x57
0x58
0x59
0x5A
0x5B
0xE9
0x5D
0xED
0xF3
0xFA
0x61
0x62
0x63
0x64
0x65
0x66
0x67
0x68
0x69
0x6A
0x6B
0x6C
0x6D
0x6E
0x6F
0x70
0x71
0x72
0x73
0x74
0x75
0x76
0x77
0x78
0x79
0x7A
0xE7
0xF7
0xD1
0xF1
0x25A0
}
;
private
static
final
int
[
]
SPECIAL_CHARACTER_SET
=
new
int
[
]
{
0xAE
0xB0
0xBD
0xBF
0x2122
0xA2
0xA3
0x266A
0xE0
0x20
0xE8
0xE2
0xEA
0xEE
0xF4
0xFB
}
;
private
static
final
int
[
]
SPECIAL_ES_FR_CHARACTER_SET
=
new
int
[
]
{
0xC1
0xC9
0xD3
0xDA
0xDC
0xFC
0x2018
0xA1
0x2A
0x27
0x2014
0xA9
0x2120
0x2022
0x201C
0x201D
0xC0
0xC2
0xC7
0xC8
0xCA
0xCB
0xEB
0xCE
0xCF
0xEF
0xD4
0xD9
0xF9
0xDB
0xAB
0xBB
}
;
private
static
final
int
[
]
SPECIAL_PT_DE_CHARACTER_SET
=
new
int
[
]
{
0xC3
0xE3
0xCD
0xCC
0xEC
0xD2
0xF2
0xD5
0xF5
0x7B
0x7D
0x5C
0x5E
0x5F
0x7C
0x7E
0xC4
0xE4
0xD6
0xF6
0xDF
0xA5
0xA4
0x2502
0xC5
0xE5
0xD8
0xF8
0x250C
0x2510
0x2514
0x2518
}
;
private
final
ParsableByteArray
ccData
;
private
final
int
packetLength
;
private
final
int
selectedField
;
private
final
LinkedList
<
CueBuilder
>
cueBuilders
;
private
CueBuilder
currentCueBuilder
;
private
List
<
Cue
>
cues
;
private
List
<
Cue
>
lastCues
;
private
int
captionMode
;
private
int
captionRowCount
;
private
boolean
repeatableControlSet
;
private
byte
repeatableControlCc1
;
private
byte
repeatableControlCc2
;
public
Cea608Decoder
(
String
mimeType
int
accessibilityChannel
)
{
ccData
=
new
ParsableByteArray
(
)
;
cueBuilders
=
new
LinkedList
<
>
(
)
;
currentCueBuilder
=
new
CueBuilder
(
CC_MODE_UNKNOWN
DEFAULT_CAPTIONS_ROW_COUNT
)
;
packetLength
=
MimeTypes
.
APPLICATION_MP4CEA608
.
equals
(
mimeType
)
?
2
:
3
;
switch
(
accessibilityChannel
)
{
case
3
:
case
4
:
selectedField
=
2
;
break
;
case
1
:
case
2
:
case
Format
.
NO_VALUE
:
default
:
selectedField
=
1
;
}
setCaptionMode
(
CC_MODE_UNKNOWN
)
;
resetCueBuilders
(
)
;
}
Override
public
String
getName
(
)
{
return
"
Cea608Decoder
"
;
}
Override
public
void
flush
(
)
{
super
.
flush
(
)
;
cues
=
null
;
lastCues
=
null
;
setCaptionMode
(
CC_MODE_UNKNOWN
)
;
resetCueBuilders
(
)
;
captionRowCount
=
DEFAULT_CAPTIONS_ROW_COUNT
;
repeatableControlSet
=
false
;
repeatableControlCc1
=
0
;
repeatableControlCc2
=
0
;
}
Override
public
void
release
(
)
{
}
Override
protected
boolean
isNewSubtitleDataAvailable
(
)
{
return
cues
!
=
lastCues
;
}
Override
protected
Subtitle
createSubtitle
(
)
{
lastCues
=
cues
;
return
new
CeaSubtitle
(
cues
)
;
}
Override
protected
void
decode
(
SubtitleInputBuffer
inputBuffer
)
{
ccData
.
reset
(
inputBuffer
.
data
.
array
(
)
inputBuffer
.
data
.
limit
(
)
)
;
boolean
captionDataProcessed
=
false
;
boolean
isRepeatableControl
=
false
;
while
(
ccData
.
bytesLeft
(
)
>
=
packetLength
)
{
byte
ccDataHeader
=
packetLength
=
=
2
?
CC_IMPLICIT_DATA_HEADER
:
(
byte
)
ccData
.
readUnsignedByte
(
)
;
byte
ccData1
=
(
byte
)
(
ccData
.
readUnsignedByte
(
)
&
0x7F
)
;
byte
ccData2
=
(
byte
)
(
ccData
.
readUnsignedByte
(
)
&
0x7F
)
;
if
(
(
ccDataHeader
&
(
CC_VALID_FLAG
|
CC_TYPE_FLAG
)
)
!
=
CC_VALID_608_ID
)
{
continue
;
}
if
(
(
selectedField
=
=
1
&
&
(
ccDataHeader
&
CC_FIELD_FLAG
)
!
=
NTSC_CC_FIELD_1
)
|
|
(
selectedField
=
=
2
&
&
(
ccDataHeader
&
CC_FIELD_FLAG
)
!
=
NTSC_CC_FIELD_2
)
)
{
continue
;
}
if
(
ccData1
=
=
0
&
&
ccData2
=
=
0
)
{
continue
;
}
captionDataProcessed
=
true
;
if
(
(
(
ccData1
&
0xF7
)
=
=
0x11
)
&
&
(
(
ccData2
&
0xF0
)
=
=
0x30
)
)
{
currentCueBuilder
.
append
(
getSpecialChar
(
ccData2
)
)
;
continue
;
}
if
(
(
(
ccData1
&
0xF6
)
=
=
0x12
)
&
&
(
ccData2
&
0xE0
)
=
=
0x20
)
{
currentCueBuilder
.
backspace
(
)
;
if
(
(
ccData1
&
0x01
)
=
=
0x00
)
{
currentCueBuilder
.
append
(
getExtendedEsFrChar
(
ccData2
)
)
;
}
else
{
currentCueBuilder
.
append
(
getExtendedPtDeChar
(
ccData2
)
)
;
}
continue
;
}
if
(
(
ccData1
&
0xE0
)
=
=
0x00
)
{
isRepeatableControl
=
handleCtrl
(
ccData1
ccData2
)
;
continue
;
}
currentCueBuilder
.
append
(
getChar
(
ccData1
)
)
;
if
(
(
ccData2
&
0xE0
)
!
=
0x00
)
{
currentCueBuilder
.
append
(
getChar
(
ccData2
)
)
;
}
}
if
(
captionDataProcessed
)
{
if
(
!
isRepeatableControl
)
{
repeatableControlSet
=
false
;
}
if
(
captionMode
=
=
CC_MODE_ROLL_UP
|
|
captionMode
=
=
CC_MODE_PAINT_ON
)
{
cues
=
getDisplayCues
(
)
;
}
}
}
private
boolean
handleCtrl
(
byte
cc1
byte
cc2
)
{
boolean
isRepeatableControl
=
isRepeatable
(
cc1
)
;
if
(
isRepeatableControl
)
{
if
(
repeatableControlSet
&
&
repeatableControlCc1
=
=
cc1
&
&
repeatableControlCc2
=
=
cc2
)
{
repeatableControlSet
=
false
;
return
true
;
}
else
{
repeatableControlSet
=
true
;
repeatableControlCc1
=
cc1
;
repeatableControlCc2
=
cc2
;
}
}
if
(
isMidrowCtrlCode
(
cc1
cc2
)
)
{
handleMidrowCtrl
(
cc2
)
;
}
else
if
(
isPreambleAddressCode
(
cc1
cc2
)
)
{
handlePreambleAddressCode
(
cc1
cc2
)
;
}
else
if
(
isTabCtrlCode
(
cc1
cc2
)
)
{
currentCueBuilder
.
setTab
(
cc2
-
0x20
)
;
}
else
if
(
isMiscCode
(
cc1
cc2
)
)
{
handleMiscCode
(
cc2
)
;
}
return
isRepeatableControl
;
}
private
void
handleMidrowCtrl
(
byte
cc2
)
{
boolean
isUnderlined
=
(
cc2
&
0x01
)
=
=
0x01
;
currentCueBuilder
.
setUnderline
(
isUnderlined
)
;
int
attribute
=
(
cc2
>
>
1
)
&
0x0F
;
if
(
attribute
=
=
0x07
)
{
currentCueBuilder
.
setMidrowStyle
(
new
StyleSpan
(
Typeface
.
ITALIC
)
2
)
;
currentCueBuilder
.
setMidrowStyle
(
new
ForegroundColorSpan
(
Color
.
WHITE
)
1
)
;
}
else
{
currentCueBuilder
.
setMidrowStyle
(
new
ForegroundColorSpan
(
COLORS
[
attribute
]
)
1
)
;
}
}
private
void
handlePreambleAddressCode
(
byte
cc1
byte
cc2
)
{
int
row
=
ROW_INDICES
[
cc1
&
0x07
]
;
boolean
nextRowDown
=
(
cc2
&
0x20
)
!
=
0
;
if
(
nextRowDown
)
{
row
+
+
;
}
if
(
row
!
=
currentCueBuilder
.
getRow
(
)
)
{
if
(
captionMode
!
=
CC_MODE_ROLL_UP
&
&
!
currentCueBuilder
.
isEmpty
(
)
)
{
currentCueBuilder
=
new
CueBuilder
(
captionMode
captionRowCount
)
;
cueBuilders
.
add
(
currentCueBuilder
)
;
}
currentCueBuilder
.
setRow
(
row
)
;
}
if
(
(
cc2
&
0x01
)
=
=
0x01
)
{
currentCueBuilder
.
setPreambleStyle
(
new
UnderlineSpan
(
)
)
;
}
int
attribute
=
cc2
>
>
1
&
0x0F
;
if
(
attribute
<
=
0x07
)
{
if
(
attribute
=
=
0x07
)
{
currentCueBuilder
.
setPreambleStyle
(
new
StyleSpan
(
Typeface
.
ITALIC
)
)
;
currentCueBuilder
.
setPreambleStyle
(
new
ForegroundColorSpan
(
Color
.
WHITE
)
)
;
}
else
{
currentCueBuilder
.
setPreambleStyle
(
new
ForegroundColorSpan
(
COLORS
[
attribute
]
)
)
;
}
}
else
{
currentCueBuilder
.
setIndent
(
COLUMN_INDICES
[
attribute
&
0x07
]
)
;
}
}
private
void
handleMiscCode
(
byte
cc2
)
{
switch
(
cc2
)
{
case
CTRL_ROLL_UP_CAPTIONS_2_ROWS
:
captionRowCount
=
2
;
setCaptionMode
(
CC_MODE_ROLL_UP
)
;
return
;
case
CTRL_ROLL_UP_CAPTIONS_3_ROWS
:
captionRowCount
=
3
;
setCaptionMode
(
CC_MODE_ROLL_UP
)
;
return
;
case
CTRL_ROLL_UP_CAPTIONS_4_ROWS
:
captionRowCount
=
4
;
setCaptionMode
(
CC_MODE_ROLL_UP
)
;
return
;
case
CTRL_RESUME_CAPTION_LOADING
:
setCaptionMode
(
CC_MODE_POP_ON
)
;
return
;
case
CTRL_RESUME_DIRECT_CAPTIONING
:
setCaptionMode
(
CC_MODE_PAINT_ON
)
;
return
;
}
if
(
captionMode
=
=
CC_MODE_UNKNOWN
)
{
return
;
}
switch
(
cc2
)
{
case
CTRL_ERASE_DISPLAYED_MEMORY
:
cues
=
null
;
if
(
captionMode
=
=
CC_MODE_ROLL_UP
|
|
captionMode
=
=
CC_MODE_PAINT_ON
)
{
resetCueBuilders
(
)
;
}
break
;
case
CTRL_ERASE_NON_DISPLAYED_MEMORY
:
resetCueBuilders
(
)
;
break
;
case
CTRL_END_OF_CAPTION
:
cues
=
getDisplayCues
(
)
;
resetCueBuilders
(
)
;
break
;
case
CTRL_CARRIAGE_RETURN
:
if
(
captionMode
=
=
CC_MODE_ROLL_UP
&
&
!
currentCueBuilder
.
isEmpty
(
)
)
{
currentCueBuilder
.
rollUp
(
)
;
}
break
;
case
CTRL_BACKSPACE
:
currentCueBuilder
.
backspace
(
)
;
break
;
case
CTRL_DELETE_TO_END_OF_ROW
:
break
;
}
}
private
List
<
Cue
>
getDisplayCues
(
)
{
List
<
Cue
>
displayCues
=
new
ArrayList
<
>
(
)
;
for
(
int
i
=
0
;
i
<
cueBuilders
.
size
(
)
;
i
+
+
)
{
Cue
cue
=
cueBuilders
.
get
(
i
)
.
build
(
)
;
if
(
cue
!
=
null
)
{
displayCues
.
add
(
cue
)
;
}
}
return
displayCues
;
}
private
void
setCaptionMode
(
int
captionMode
)
{
if
(
this
.
captionMode
=
=
captionMode
)
{
return
;
}
int
oldCaptionMode
=
this
.
captionMode
;
this
.
captionMode
=
captionMode
;
resetCueBuilders
(
)
;
if
(
oldCaptionMode
=
=
CC_MODE_PAINT_ON
|
|
captionMode
=
=
CC_MODE_ROLL_UP
|
|
captionMode
=
=
CC_MODE_UNKNOWN
)
{
cues
=
null
;
}
}
private
void
resetCueBuilders
(
)
{
currentCueBuilder
.
reset
(
captionMode
captionRowCount
)
;
cueBuilders
.
clear
(
)
;
cueBuilders
.
add
(
currentCueBuilder
)
;
}
private
static
char
getChar
(
byte
ccData
)
{
int
index
=
(
ccData
&
0x7F
)
-
0x20
;
return
(
char
)
BASIC_CHARACTER_SET
[
index
]
;
}
private
static
char
getSpecialChar
(
byte
ccData
)
{
int
index
=
ccData
&
0x0F
;
return
(
char
)
SPECIAL_CHARACTER_SET
[
index
]
;
}
private
static
char
getExtendedEsFrChar
(
byte
ccData
)
{
int
index
=
ccData
&
0x1F
;
return
(
char
)
SPECIAL_ES_FR_CHARACTER_SET
[
index
]
;
}
private
static
char
getExtendedPtDeChar
(
byte
ccData
)
{
int
index
=
ccData
&
0x1F
;
return
(
char
)
SPECIAL_PT_DE_CHARACTER_SET
[
index
]
;
}
private
static
boolean
isMidrowCtrlCode
(
byte
cc1
byte
cc2
)
{
return
(
(
cc1
&
0xF7
)
=
=
0x11
)
&
&
(
(
cc2
&
0xF0
)
=
=
0x20
)
;
}
private
static
boolean
isPreambleAddressCode
(
byte
cc1
byte
cc2
)
{
return
(
(
cc1
&
0xF0
)
=
=
0x10
)
&
&
(
(
cc2
&
0xC0
)
=
=
0x40
)
;
}
private
static
boolean
isTabCtrlCode
(
byte
cc1
byte
cc2
)
{
return
(
(
cc1
&
0xF7
)
=
=
0x17
)
&
&
(
cc2
>
=
0x21
&
&
cc2
<
=
0x23
)
;
}
private
static
boolean
isMiscCode
(
byte
cc1
byte
cc2
)
{
return
(
(
cc1
&
0xF7
)
=
=
0x14
)
&
&
(
(
cc2
&
0xF0
)
=
=
0x20
)
;
}
private
static
boolean
isRepeatable
(
byte
cc1
)
{
return
(
cc1
&
0xF0
)
=
=
0x10
;
}
private
static
class
CueBuilder
{
private
static
final
int
POSITION_UNSET
=
-
1
;
private
static
final
int
SCREEN_CHARWIDTH
=
32
;
private
static
final
int
BASE_ROW
=
15
;
private
final
List
<
CharacterStyle
>
preambleStyles
;
private
final
List
<
CueStyle
>
midrowStyles
;
private
final
List
<
SpannableString
>
rolledUpCaptions
;
private
final
SpannableStringBuilder
captionStringBuilder
;
private
int
row
;
private
int
indent
;
private
int
tabOffset
;
private
int
captionMode
;
private
int
captionRowCount
;
private
int
underlineStartPosition
;
public
CueBuilder
(
int
captionMode
int
captionRowCount
)
{
preambleStyles
=
new
ArrayList
<
>
(
)
;
midrowStyles
=
new
ArrayList
<
>
(
)
;
rolledUpCaptions
=
new
LinkedList
<
>
(
)
;
captionStringBuilder
=
new
SpannableStringBuilder
(
)
;
reset
(
captionMode
captionRowCount
)
;
}
public
void
reset
(
int
captionMode
int
captionRowCount
)
{
preambleStyles
.
clear
(
)
;
midrowStyles
.
clear
(
)
;
rolledUpCaptions
.
clear
(
)
;
captionStringBuilder
.
clear
(
)
;
row
=
BASE_ROW
;
indent
=
0
;
tabOffset
=
0
;
this
.
captionMode
=
captionMode
;
this
.
captionRowCount
=
captionRowCount
;
underlineStartPosition
=
POSITION_UNSET
;
}
public
boolean
isEmpty
(
)
{
return
preambleStyles
.
isEmpty
(
)
&
&
midrowStyles
.
isEmpty
(
)
&
&
rolledUpCaptions
.
isEmpty
(
)
&
&
captionStringBuilder
.
length
(
)
=
=
0
;
}
public
void
backspace
(
)
{
int
length
=
captionStringBuilder
.
length
(
)
;
if
(
length
>
0
)
{
captionStringBuilder
.
delete
(
length
-
1
length
)
;
}
}
public
int
getRow
(
)
{
return
row
;
}
public
void
setRow
(
int
row
)
{
this
.
row
=
row
;
}
public
void
rollUp
(
)
{
rolledUpCaptions
.
add
(
buildSpannableString
(
)
)
;
captionStringBuilder
.
clear
(
)
;
preambleStyles
.
clear
(
)
;
midrowStyles
.
clear
(
)
;
underlineStartPosition
=
POSITION_UNSET
;
int
numRows
=
Math
.
min
(
captionRowCount
row
)
;
while
(
rolledUpCaptions
.
size
(
)
>
=
numRows
)
{
rolledUpCaptions
.
remove
(
0
)
;
}
}
public
void
setIndent
(
int
indent
)
{
this
.
indent
=
indent
;
}
public
void
setTab
(
int
tabs
)
{
tabOffset
=
tabs
;
}
public
void
setPreambleStyle
(
CharacterStyle
style
)
{
preambleStyles
.
add
(
style
)
;
}
public
void
setMidrowStyle
(
CharacterStyle
style
int
nextStyleIncrement
)
{
midrowStyles
.
add
(
new
CueStyle
(
style
captionStringBuilder
.
length
(
)
nextStyleIncrement
)
)
;
}
public
void
setUnderline
(
boolean
enabled
)
{
if
(
enabled
)
{
underlineStartPosition
=
captionStringBuilder
.
length
(
)
;
}
else
if
(
underlineStartPosition
!
=
POSITION_UNSET
)
{
captionStringBuilder
.
setSpan
(
new
UnderlineSpan
(
)
underlineStartPosition
captionStringBuilder
.
length
(
)
Spanned
.
SPAN_EXCLUSIVE_EXCLUSIVE
)
;
underlineStartPosition
=
POSITION_UNSET
;
}
}
public
void
append
(
char
text
)
{
captionStringBuilder
.
append
(
text
)
;
}
public
SpannableString
buildSpannableString
(
)
{
int
length
=
captionStringBuilder
.
length
(
)
;
for
(
int
i
=
0
;
i
<
preambleStyles
.
size
(
)
;
i
+
+
)
{
captionStringBuilder
.
setSpan
(
preambleStyles
.
get
(
i
)
0
length
Spanned
.
SPAN_EXCLUSIVE_EXCLUSIVE
)
;
}
for
(
int
i
=
0
;
i
<
midrowStyles
.
size
(
)
;
i
+
+
)
{
CueStyle
cueStyle
=
midrowStyles
.
get
(
i
)
;
int
end
=
(
i
<
midrowStyles
.
size
(
)
-
cueStyle
.
nextStyleIncrement
)
?
midrowStyles
.
get
(
i
+
cueStyle
.
nextStyleIncrement
)
.
start
:
length
;
captionStringBuilder
.
setSpan
(
cueStyle
.
style
cueStyle
.
start
end
Spanned
.
SPAN_EXCLUSIVE_EXCLUSIVE
)
;
}
if
(
underlineStartPosition
!
=
POSITION_UNSET
)
{
captionStringBuilder
.
setSpan
(
new
UnderlineSpan
(
)
underlineStartPosition
length
Spanned
.
SPAN_EXCLUSIVE_EXCLUSIVE
)
;
}
return
new
SpannableString
(
captionStringBuilder
)
;
}
public
Cue
build
(
)
{
SpannableStringBuilder
cueString
=
new
SpannableStringBuilder
(
)
;
for
(
int
i
=
0
;
i
<
rolledUpCaptions
.
size
(
)
;
i
+
+
)
{
cueString
.
append
(
rolledUpCaptions
.
get
(
i
)
)
;
cueString
.
append
(
'
\
n
'
)
;
}
cueString
.
append
(
buildSpannableString
(
)
)
;
if
(
cueString
.
length
(
)
=
=
0
)
{
return
null
;
}
float
position
;
int
positionAnchor
;
int
startPadding
=
indent
+
tabOffset
;
int
endPadding
=
SCREEN_CHARWIDTH
-
startPadding
-
cueString
.
length
(
)
;
int
startEndPaddingDelta
=
startPadding
-
endPadding
;
if
(
captionMode
=
=
CC_MODE_POP_ON
&
&
Math
.
abs
(
startEndPaddingDelta
)
<
3
)
{
position
=
0
.
5f
;
positionAnchor
=
Cue
.
ANCHOR_TYPE_MIDDLE
;
}
else
if
(
captionMode
=
=
CC_MODE_POP_ON
&
&
startEndPaddingDelta
>
0
)
{
position
=
(
float
)
(
SCREEN_CHARWIDTH
-
endPadding
)
/
SCREEN_CHARWIDTH
;
position
=
position
*
0
.
8f
+
0
.
1f
;
positionAnchor
=
Cue
.
ANCHOR_TYPE_END
;
}
else
{
position
=
(
float
)
startPadding
/
SCREEN_CHARWIDTH
;
position
=
position
*
0
.
8f
+
0
.
1f
;
positionAnchor
=
Cue
.
ANCHOR_TYPE_START
;
}
int
lineAnchor
;
int
line
;
if
(
captionMode
=
=
CC_MODE_ROLL_UP
|
|
row
>
(
BASE_ROW
/
2
)
)
{
lineAnchor
=
Cue
.
ANCHOR_TYPE_END
;
line
=
row
-
BASE_ROW
;
line
-
=
2
;
}
else
{
lineAnchor
=
Cue
.
ANCHOR_TYPE_START
;
line
=
row
;
}
return
new
Cue
(
cueString
Alignment
.
ALIGN_NORMAL
line
Cue
.
LINE_TYPE_NUMBER
lineAnchor
position
positionAnchor
Cue
.
DIMEN_UNSET
)
;
}
Override
public
String
toString
(
)
{
return
captionStringBuilder
.
toString
(
)
;
}
private
static
class
CueStyle
{
public
final
CharacterStyle
style
;
public
final
int
start
;
public
final
int
nextStyleIncrement
;
public
CueStyle
(
CharacterStyle
style
int
start
int
nextStyleIncrement
)
{
this
.
style
=
style
;
this
.
start
=
start
;
this
.
nextStyleIncrement
=
nextStyleIncrement
;
}
}
}
}
