package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
cache
.
Cache
.
CacheException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
AtomicFile
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ReusableBufferedOutputStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
DataInputStream
;
import
java
.
io
.
DataOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
security
.
InvalidAlgorithmParameterException
;
import
java
.
security
.
InvalidKeyException
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
Random
;
import
java
.
util
.
Set
;
import
javax
.
crypto
.
Cipher
;
import
javax
.
crypto
.
CipherInputStream
;
import
javax
.
crypto
.
CipherOutputStream
;
import
javax
.
crypto
.
NoSuchPaddingException
;
import
javax
.
crypto
.
spec
.
IvParameterSpec
;
import
javax
.
crypto
.
spec
.
SecretKeySpec
;
final
class
CachedContentIndex
{
public
static
final
String
FILE_NAME
=
"
cached_content_index
.
exi
"
;
private
static
final
int
VERSION
=
1
;
private
static
final
int
FLAG_ENCRYPTED_INDEX
=
1
;
private
static
final
String
TAG
=
"
CachedContentIndex
"
;
private
final
HashMap
<
String
CachedContent
>
keyToContent
;
private
final
SparseArray
<
String
>
idToKey
;
private
final
AtomicFile
atomicFile
;
private
final
Cipher
cipher
;
private
final
SecretKeySpec
secretKeySpec
;
private
boolean
changed
;
private
ReusableBufferedOutputStream
bufferedOutputStream
;
public
CachedContentIndex
(
File
cacheDir
)
{
this
(
cacheDir
null
)
;
}
public
CachedContentIndex
(
File
cacheDir
byte
[
]
secretKey
)
{
if
(
secretKey
!
=
null
)
{
Assertions
.
checkArgument
(
secretKey
.
length
=
=
16
)
;
try
{
cipher
=
Cipher
.
getInstance
(
"
AES
/
CBC
/
PKCS5PADDING
"
)
;
secretKeySpec
=
new
SecretKeySpec
(
secretKey
"
AES
"
)
;
}
catch
(
NoSuchAlgorithmException
|
NoSuchPaddingException
e
)
{
throw
new
IllegalStateException
(
e
)
;
}
}
else
{
cipher
=
null
;
secretKeySpec
=
null
;
}
keyToContent
=
new
HashMap
<
>
(
)
;
idToKey
=
new
SparseArray
<
>
(
)
;
atomicFile
=
new
AtomicFile
(
new
File
(
cacheDir
FILE_NAME
)
)
;
}
public
void
load
(
)
{
Assertions
.
checkState
(
!
changed
)
;
if
(
!
readFile
(
)
)
{
atomicFile
.
delete
(
)
;
keyToContent
.
clear
(
)
;
idToKey
.
clear
(
)
;
}
}
public
void
store
(
)
throws
CacheException
{
if
(
!
changed
)
{
return
;
}
writeFile
(
)
;
changed
=
false
;
}
public
CachedContent
add
(
String
key
)
{
CachedContent
cachedContent
=
keyToContent
.
get
(
key
)
;
if
(
cachedContent
=
=
null
)
{
cachedContent
=
addNew
(
key
C
.
LENGTH_UNSET
)
;
}
return
cachedContent
;
}
public
CachedContent
get
(
String
key
)
{
return
keyToContent
.
get
(
key
)
;
}
public
Collection
<
CachedContent
>
getAll
(
)
{
return
keyToContent
.
values
(
)
;
}
public
int
assignIdForKey
(
String
key
)
{
return
add
(
key
)
.
id
;
}
public
String
getKeyForId
(
int
id
)
{
return
idToKey
.
get
(
id
)
;
}
public
void
removeEmpty
(
String
key
)
{
CachedContent
cachedContent
=
keyToContent
.
remove
(
key
)
;
if
(
cachedContent
!
=
null
)
{
Assertions
.
checkState
(
cachedContent
.
isEmpty
(
)
)
;
idToKey
.
remove
(
cachedContent
.
id
)
;
changed
=
true
;
}
}
public
void
removeEmpty
(
)
{
LinkedList
<
String
>
cachedContentToBeRemoved
=
new
LinkedList
<
>
(
)
;
for
(
CachedContent
cachedContent
:
keyToContent
.
values
(
)
)
{
if
(
cachedContent
.
isEmpty
(
)
)
{
cachedContentToBeRemoved
.
add
(
cachedContent
.
key
)
;
}
}
for
(
String
key
:
cachedContentToBeRemoved
)
{
removeEmpty
(
key
)
;
}
}
public
Set
<
String
>
getKeys
(
)
{
return
keyToContent
.
keySet
(
)
;
}
public
void
setContentLength
(
String
key
long
length
)
{
CachedContent
cachedContent
=
get
(
key
)
;
if
(
cachedContent
!
=
null
)
{
if
(
cachedContent
.
getLength
(
)
!
=
length
)
{
cachedContent
.
setLength
(
length
)
;
changed
=
true
;
}
}
else
{
addNew
(
key
length
)
;
}
}
public
long
getContentLength
(
String
key
)
{
CachedContent
cachedContent
=
get
(
key
)
;
return
cachedContent
=
=
null
?
C
.
LENGTH_UNSET
:
cachedContent
.
getLength
(
)
;
}
private
boolean
readFile
(
)
{
DataInputStream
input
=
null
;
try
{
InputStream
inputStream
=
new
BufferedInputStream
(
atomicFile
.
openRead
(
)
)
;
input
=
new
DataInputStream
(
inputStream
)
;
int
version
=
input
.
readInt
(
)
;
if
(
version
!
=
VERSION
)
{
return
false
;
}
int
flags
=
input
.
readInt
(
)
;
if
(
(
flags
&
FLAG_ENCRYPTED_INDEX
)
!
=
0
)
{
if
(
cipher
=
=
null
)
{
return
false
;
}
byte
[
]
initializationVector
=
new
byte
[
16
]
;
input
.
readFully
(
initializationVector
)
;
IvParameterSpec
ivParameterSpec
=
new
IvParameterSpec
(
initializationVector
)
;
try
{
cipher
.
init
(
Cipher
.
DECRYPT_MODE
secretKeySpec
ivParameterSpec
)
;
}
catch
(
InvalidKeyException
|
InvalidAlgorithmParameterException
e
)
{
throw
new
IllegalStateException
(
e
)
;
}
input
=
new
DataInputStream
(
new
CipherInputStream
(
inputStream
cipher
)
)
;
}
else
{
if
(
cipher
!
=
null
)
{
changed
=
true
;
}
}
int
count
=
input
.
readInt
(
)
;
int
hashCode
=
0
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
CachedContent
cachedContent
=
new
CachedContent
(
input
)
;
add
(
cachedContent
)
;
hashCode
+
=
cachedContent
.
headerHashCode
(
)
;
}
if
(
input
.
readInt
(
)
!
=
hashCode
)
{
return
false
;
}
}
catch
(
FileNotFoundException
e
)
{
return
false
;
}
catch
(
IOException
e
)
{
Log
.
e
(
TAG
"
Error
reading
cache
content
index
file
.
"
e
)
;
return
false
;
}
finally
{
if
(
input
!
=
null
)
{
Util
.
closeQuietly
(
input
)
;
}
}
return
true
;
}
private
void
writeFile
(
)
throws
CacheException
{
DataOutputStream
output
=
null
;
try
{
OutputStream
outputStream
=
atomicFile
.
startWrite
(
)
;
if
(
bufferedOutputStream
=
=
null
)
{
bufferedOutputStream
=
new
ReusableBufferedOutputStream
(
outputStream
)
;
}
else
{
bufferedOutputStream
.
reset
(
outputStream
)
;
}
output
=
new
DataOutputStream
(
bufferedOutputStream
)
;
output
.
writeInt
(
VERSION
)
;
int
flags
=
cipher
!
=
null
?
FLAG_ENCRYPTED_INDEX
:
0
;
output
.
writeInt
(
flags
)
;
if
(
cipher
!
=
null
)
{
byte
[
]
initializationVector
=
new
byte
[
16
]
;
new
Random
(
)
.
nextBytes
(
initializationVector
)
;
output
.
write
(
initializationVector
)
;
IvParameterSpec
ivParameterSpec
=
new
IvParameterSpec
(
initializationVector
)
;
try
{
cipher
.
init
(
Cipher
.
ENCRYPT_MODE
secretKeySpec
ivParameterSpec
)
;
}
catch
(
InvalidKeyException
|
InvalidAlgorithmParameterException
e
)
{
throw
new
IllegalStateException
(
e
)
;
}
output
.
flush
(
)
;
output
=
new
DataOutputStream
(
new
CipherOutputStream
(
bufferedOutputStream
cipher
)
)
;
}
output
.
writeInt
(
keyToContent
.
size
(
)
)
;
int
hashCode
=
0
;
for
(
CachedContent
cachedContent
:
keyToContent
.
values
(
)
)
{
cachedContent
.
writeToStream
(
output
)
;
hashCode
+
=
cachedContent
.
headerHashCode
(
)
;
}
output
.
writeInt
(
hashCode
)
;
atomicFile
.
endWrite
(
output
)
;
output
=
null
;
}
catch
(
IOException
e
)
{
throw
new
CacheException
(
e
)
;
}
finally
{
Util
.
closeQuietly
(
output
)
;
}
}
private
void
add
(
CachedContent
cachedContent
)
{
keyToContent
.
put
(
cachedContent
.
key
cachedContent
)
;
idToKey
.
put
(
cachedContent
.
id
cachedContent
.
key
)
;
}
void
addNew
(
CachedContent
cachedContent
)
{
add
(
cachedContent
)
;
changed
=
true
;
}
private
CachedContent
addNew
(
String
key
long
length
)
{
int
id
=
getNewId
(
idToKey
)
;
CachedContent
cachedContent
=
new
CachedContent
(
id
key
length
)
;
addNew
(
cachedContent
)
;
return
cachedContent
;
}
public
static
int
getNewId
(
SparseArray
<
String
>
idToKey
)
{
int
size
=
idToKey
.
size
(
)
;
int
id
=
size
=
=
0
?
0
:
(
idToKey
.
keyAt
(
size
-
1
)
+
1
)
;
if
(
id
<
0
)
{
for
(
id
=
0
;
id
<
size
;
id
+
+
)
{
if
(
id
!
=
idToKey
.
keyAt
(
id
)
)
{
break
;
}
}
}
return
id
;
}
}
