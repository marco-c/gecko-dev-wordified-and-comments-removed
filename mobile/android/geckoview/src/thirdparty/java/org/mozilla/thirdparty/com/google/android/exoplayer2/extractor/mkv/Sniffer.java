package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mkv
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
final
class
Sniffer
{
private
static
final
int
SEARCH_LENGTH
=
1024
;
private
static
final
int
ID_EBML
=
0x1A45DFA3
;
private
final
ParsableByteArray
scratch
;
private
int
peekLength
;
public
Sniffer
(
)
{
scratch
=
new
ParsableByteArray
(
8
)
;
}
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
long
inputLength
=
input
.
getLength
(
)
;
int
bytesToSearch
=
(
int
)
(
inputLength
=
=
C
.
LENGTH_UNSET
|
|
inputLength
>
SEARCH_LENGTH
?
SEARCH_LENGTH
:
inputLength
)
;
input
.
peekFully
(
scratch
.
data
0
4
)
;
long
tag
=
scratch
.
readUnsignedInt
(
)
;
peekLength
=
4
;
while
(
tag
!
=
ID_EBML
)
{
if
(
+
+
peekLength
=
=
bytesToSearch
)
{
return
false
;
}
input
.
peekFully
(
scratch
.
data
0
1
)
;
tag
=
(
tag
<
<
8
)
&
0xFFFFFF00
;
tag
|
=
scratch
.
data
[
0
]
&
0xFF
;
}
long
headerSize
=
readUint
(
input
)
;
long
headerStart
=
peekLength
;
if
(
headerSize
=
=
Long
.
MIN_VALUE
|
|
(
inputLength
!
=
C
.
LENGTH_UNSET
&
&
headerStart
+
headerSize
>
=
inputLength
)
)
{
return
false
;
}
while
(
peekLength
<
headerStart
+
headerSize
)
{
long
id
=
readUint
(
input
)
;
if
(
id
=
=
Long
.
MIN_VALUE
)
{
return
false
;
}
long
size
=
readUint
(
input
)
;
if
(
size
<
0
|
|
size
>
Integer
.
MAX_VALUE
)
{
return
false
;
}
if
(
size
!
=
0
)
{
int
sizeInt
=
(
int
)
size
;
input
.
advancePeekPosition
(
sizeInt
)
;
peekLength
+
=
sizeInt
;
}
}
return
peekLength
=
=
headerStart
+
headerSize
;
}
private
long
readUint
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
input
.
peekFully
(
scratch
.
data
0
1
)
;
int
value
=
scratch
.
data
[
0
]
&
0xFF
;
if
(
value
=
=
0
)
{
return
Long
.
MIN_VALUE
;
}
int
mask
=
0x80
;
int
length
=
0
;
while
(
(
value
&
mask
)
=
=
0
)
{
mask
>
>
=
1
;
length
+
+
;
}
value
&
=
~
mask
;
input
.
peekFully
(
scratch
.
data
1
length
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
value
<
<
=
8
;
value
+
=
scratch
.
data
[
i
+
1
]
&
0xFF
;
}
peekLength
+
=
length
+
1
;
return
value
;
}
}
