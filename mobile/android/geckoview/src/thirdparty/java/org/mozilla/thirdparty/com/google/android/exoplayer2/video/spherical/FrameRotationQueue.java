package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
.
spherical
;
import
android
.
opengl
.
Matrix
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimedValueQueue
;
public
final
class
FrameRotationQueue
{
private
final
float
[
]
recenterMatrix
;
private
final
float
[
]
rotationMatrix
;
private
final
TimedValueQueue
<
float
[
]
>
rotations
;
private
boolean
recenterMatrixComputed
;
public
FrameRotationQueue
(
)
{
recenterMatrix
=
new
float
[
16
]
;
rotationMatrix
=
new
float
[
16
]
;
rotations
=
new
TimedValueQueue
<
>
(
)
;
}
public
void
setRotation
(
long
timestampUs
float
[
]
angleAxis
)
{
rotations
.
add
(
timestampUs
angleAxis
)
;
}
public
void
reset
(
)
{
rotations
.
clear
(
)
;
recenterMatrixComputed
=
false
;
}
public
boolean
pollRotationMatrix
(
float
[
]
matrix
long
timestampUs
)
{
float
[
]
rotation
=
rotations
.
pollFloor
(
timestampUs
)
;
if
(
rotation
=
=
null
)
{
return
false
;
}
getRotationMatrixFromAngleAxis
(
rotationMatrix
rotation
)
;
if
(
!
recenterMatrixComputed
)
{
computeRecenterMatrix
(
recenterMatrix
rotationMatrix
)
;
recenterMatrixComputed
=
true
;
}
Matrix
.
multiplyMM
(
matrix
0
recenterMatrix
0
rotationMatrix
0
)
;
return
true
;
}
public
static
void
computeRecenterMatrix
(
float
[
]
recenterMatrix
float
[
]
rotationMatrix
)
{
Matrix
.
setIdentityM
(
recenterMatrix
0
)
;
float
normRowSqr
=
rotationMatrix
[
10
]
*
rotationMatrix
[
10
]
+
rotationMatrix
[
8
]
*
rotationMatrix
[
8
]
;
float
normRow
=
(
float
)
Math
.
sqrt
(
normRowSqr
)
;
recenterMatrix
[
0
]
=
rotationMatrix
[
10
]
/
normRow
;
recenterMatrix
[
2
]
=
rotationMatrix
[
8
]
/
normRow
;
recenterMatrix
[
8
]
=
-
rotationMatrix
[
8
]
/
normRow
;
recenterMatrix
[
10
]
=
rotationMatrix
[
10
]
/
normRow
;
}
private
static
void
getRotationMatrixFromAngleAxis
(
float
[
]
matrix
float
[
]
angleAxis
)
{
float
x
=
angleAxis
[
0
]
;
float
y
=
-
angleAxis
[
1
]
;
float
z
=
-
angleAxis
[
2
]
;
float
angleRad
=
Matrix
.
length
(
x
y
z
)
;
if
(
angleRad
!
=
0
)
{
float
angleDeg
=
(
float
)
Math
.
toDegrees
(
angleRad
)
;
Matrix
.
setRotateM
(
matrix
0
angleDeg
x
/
angleRad
y
/
angleRad
z
/
angleRad
)
;
}
else
{
Matrix
.
setIdentityM
(
matrix
0
)
;
}
}
}
