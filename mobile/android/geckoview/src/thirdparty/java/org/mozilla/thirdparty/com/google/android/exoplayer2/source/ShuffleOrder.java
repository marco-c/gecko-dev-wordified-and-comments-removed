package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Random
;
public
interface
ShuffleOrder
{
class
DefaultShuffleOrder
implements
ShuffleOrder
{
private
final
Random
random
;
private
final
int
[
]
shuffled
;
private
final
int
[
]
indexInShuffled
;
public
DefaultShuffleOrder
(
int
length
)
{
this
(
length
new
Random
(
)
)
;
}
public
DefaultShuffleOrder
(
int
length
long
randomSeed
)
{
this
(
length
new
Random
(
randomSeed
)
)
;
}
public
DefaultShuffleOrder
(
int
[
]
shuffledIndices
long
randomSeed
)
{
this
(
Arrays
.
copyOf
(
shuffledIndices
shuffledIndices
.
length
)
new
Random
(
randomSeed
)
)
;
}
private
DefaultShuffleOrder
(
int
length
Random
random
)
{
this
(
createShuffledList
(
length
random
)
random
)
;
}
private
DefaultShuffleOrder
(
int
[
]
shuffled
Random
random
)
{
this
.
shuffled
=
shuffled
;
this
.
random
=
random
;
this
.
indexInShuffled
=
new
int
[
shuffled
.
length
]
;
for
(
int
i
=
0
;
i
<
shuffled
.
length
;
i
+
+
)
{
indexInShuffled
[
shuffled
[
i
]
]
=
i
;
}
}
Override
public
int
getLength
(
)
{
return
shuffled
.
length
;
}
Override
public
int
getNextIndex
(
int
index
)
{
int
shuffledIndex
=
indexInShuffled
[
index
]
;
return
+
+
shuffledIndex
<
shuffled
.
length
?
shuffled
[
shuffledIndex
]
:
C
.
INDEX_UNSET
;
}
Override
public
int
getPreviousIndex
(
int
index
)
{
int
shuffledIndex
=
indexInShuffled
[
index
]
;
return
-
-
shuffledIndex
>
=
0
?
shuffled
[
shuffledIndex
]
:
C
.
INDEX_UNSET
;
}
Override
public
int
getLastIndex
(
)
{
return
shuffled
.
length
>
0
?
shuffled
[
shuffled
.
length
-
1
]
:
C
.
INDEX_UNSET
;
}
Override
public
int
getFirstIndex
(
)
{
return
shuffled
.
length
>
0
?
shuffled
[
0
]
:
C
.
INDEX_UNSET
;
}
Override
public
ShuffleOrder
cloneAndInsert
(
int
insertionIndex
int
insertionCount
)
{
int
[
]
insertionPoints
=
new
int
[
insertionCount
]
;
int
[
]
insertionValues
=
new
int
[
insertionCount
]
;
for
(
int
i
=
0
;
i
<
insertionCount
;
i
+
+
)
{
insertionPoints
[
i
]
=
random
.
nextInt
(
shuffled
.
length
+
1
)
;
int
swapIndex
=
random
.
nextInt
(
i
+
1
)
;
insertionValues
[
i
]
=
insertionValues
[
swapIndex
]
;
insertionValues
[
swapIndex
]
=
i
+
insertionIndex
;
}
Arrays
.
sort
(
insertionPoints
)
;
int
[
]
newShuffled
=
new
int
[
shuffled
.
length
+
insertionCount
]
;
int
indexInOldShuffled
=
0
;
int
indexInInsertionList
=
0
;
for
(
int
i
=
0
;
i
<
shuffled
.
length
+
insertionCount
;
i
+
+
)
{
if
(
indexInInsertionList
<
insertionCount
&
&
indexInOldShuffled
=
=
insertionPoints
[
indexInInsertionList
]
)
{
newShuffled
[
i
]
=
insertionValues
[
indexInInsertionList
+
+
]
;
}
else
{
newShuffled
[
i
]
=
shuffled
[
indexInOldShuffled
+
+
]
;
if
(
newShuffled
[
i
]
>
=
insertionIndex
)
{
newShuffled
[
i
]
+
=
insertionCount
;
}
}
}
return
new
DefaultShuffleOrder
(
newShuffled
new
Random
(
random
.
nextLong
(
)
)
)
;
}
Override
public
ShuffleOrder
cloneAndRemove
(
int
indexFrom
int
indexToExclusive
)
{
int
numberOfElementsToRemove
=
indexToExclusive
-
indexFrom
;
int
[
]
newShuffled
=
new
int
[
shuffled
.
length
-
numberOfElementsToRemove
]
;
int
foundElementsCount
=
0
;
for
(
int
i
=
0
;
i
<
shuffled
.
length
;
i
+
+
)
{
if
(
shuffled
[
i
]
>
=
indexFrom
&
&
shuffled
[
i
]
<
indexToExclusive
)
{
foundElementsCount
+
+
;
}
else
{
newShuffled
[
i
-
foundElementsCount
]
=
shuffled
[
i
]
>
=
indexFrom
?
shuffled
[
i
]
-
numberOfElementsToRemove
:
shuffled
[
i
]
;
}
}
return
new
DefaultShuffleOrder
(
newShuffled
new
Random
(
random
.
nextLong
(
)
)
)
;
}
Override
public
ShuffleOrder
cloneAndClear
(
)
{
return
new
DefaultShuffleOrder
(
0
new
Random
(
random
.
nextLong
(
)
)
)
;
}
private
static
int
[
]
createShuffledList
(
int
length
Random
random
)
{
int
[
]
shuffled
=
new
int
[
length
]
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
int
swapIndex
=
random
.
nextInt
(
i
+
1
)
;
shuffled
[
i
]
=
shuffled
[
swapIndex
]
;
shuffled
[
swapIndex
]
=
i
;
}
return
shuffled
;
}
}
final
class
UnshuffledShuffleOrder
implements
ShuffleOrder
{
private
final
int
length
;
public
UnshuffledShuffleOrder
(
int
length
)
{
this
.
length
=
length
;
}
Override
public
int
getLength
(
)
{
return
length
;
}
Override
public
int
getNextIndex
(
int
index
)
{
return
+
+
index
<
length
?
index
:
C
.
INDEX_UNSET
;
}
Override
public
int
getPreviousIndex
(
int
index
)
{
return
-
-
index
>
=
0
?
index
:
C
.
INDEX_UNSET
;
}
Override
public
int
getLastIndex
(
)
{
return
length
>
0
?
length
-
1
:
C
.
INDEX_UNSET
;
}
Override
public
int
getFirstIndex
(
)
{
return
length
>
0
?
0
:
C
.
INDEX_UNSET
;
}
Override
public
ShuffleOrder
cloneAndInsert
(
int
insertionIndex
int
insertionCount
)
{
return
new
UnshuffledShuffleOrder
(
length
+
insertionCount
)
;
}
Override
public
ShuffleOrder
cloneAndRemove
(
int
indexFrom
int
indexToExclusive
)
{
return
new
UnshuffledShuffleOrder
(
length
-
indexToExclusive
+
indexFrom
)
;
}
Override
public
ShuffleOrder
cloneAndClear
(
)
{
return
new
UnshuffledShuffleOrder
(
0
)
;
}
}
int
getLength
(
)
;
int
getNextIndex
(
int
index
)
;
int
getPreviousIndex
(
int
index
)
;
int
getLastIndex
(
)
;
int
getFirstIndex
(
)
;
ShuffleOrder
cloneAndInsert
(
int
insertionIndex
int
insertionCount
)
;
ShuffleOrder
cloneAndRemove
(
int
indexFrom
int
indexToExclusive
)
;
ShuffleOrder
cloneAndClear
(
)
;
}
