package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
util
.
SparseArray
;
import
android
.
util
.
SparseBooleanArray
;
import
android
.
util
.
SparseIntArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
DefaultTsPayloadReaderFactory
.
Flags
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
DvbSubtitleInfo
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
EsInfo
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
TrackIdGenerator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableBitArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
public
final
class
TsExtractor
implements
Extractor
{
public
static
final
ExtractorsFactory
FACTORY
=
new
ExtractorsFactory
(
)
{
Override
public
Extractor
[
]
createExtractors
(
)
{
return
new
Extractor
[
]
{
new
TsExtractor
(
)
}
;
}
}
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
MODE_NORMAL
MODE_SINGLE_PMT
MODE_HLS
}
)
public
interface
Mode
{
}
public
static
final
int
MODE_NORMAL
=
0
;
public
static
final
int
MODE_SINGLE_PMT
=
1
;
public
static
final
int
MODE_HLS
=
2
;
public
static
final
int
TS_STREAM_TYPE_MPA
=
0x03
;
public
static
final
int
TS_STREAM_TYPE_MPA_LSF
=
0x04
;
public
static
final
int
TS_STREAM_TYPE_AAC
=
0x0F
;
public
static
final
int
TS_STREAM_TYPE_AC3
=
0x81
;
public
static
final
int
TS_STREAM_TYPE_DTS
=
0x8A
;
public
static
final
int
TS_STREAM_TYPE_HDMV_DTS
=
0x82
;
public
static
final
int
TS_STREAM_TYPE_E_AC3
=
0x87
;
public
static
final
int
TS_STREAM_TYPE_H262
=
0x02
;
public
static
final
int
TS_STREAM_TYPE_H264
=
0x1B
;
public
static
final
int
TS_STREAM_TYPE_H265
=
0x24
;
public
static
final
int
TS_STREAM_TYPE_ID3
=
0x15
;
public
static
final
int
TS_STREAM_TYPE_SPLICE_INFO
=
0x86
;
public
static
final
int
TS_STREAM_TYPE_DVBSUBS
=
0x59
;
private
static
final
int
TS_PACKET_SIZE
=
188
;
private
static
final
int
TS_SYNC_BYTE
=
0x47
;
private
static
final
int
TS_PAT_PID
=
0
;
private
static
final
int
MAX_PID_PLUS_ONE
=
0x2000
;
private
static
final
long
AC3_FORMAT_IDENTIFIER
=
Util
.
getIntegerCodeForString
(
"
AC
-
3
"
)
;
private
static
final
long
E_AC3_FORMAT_IDENTIFIER
=
Util
.
getIntegerCodeForString
(
"
EAC3
"
)
;
private
static
final
long
HEVC_FORMAT_IDENTIFIER
=
Util
.
getIntegerCodeForString
(
"
HEVC
"
)
;
private
static
final
int
BUFFER_PACKET_COUNT
=
5
;
private
static
final
int
BUFFER_SIZE
=
TS_PACKET_SIZE
*
BUFFER_PACKET_COUNT
;
Mode
private
final
int
mode
;
private
final
List
<
TimestampAdjuster
>
timestampAdjusters
;
private
final
ParsableByteArray
tsPacketBuffer
;
private
final
ParsableBitArray
tsScratch
;
private
final
SparseIntArray
continuityCounters
;
private
final
TsPayloadReader
.
Factory
payloadReaderFactory
;
private
final
SparseArray
<
TsPayloadReader
>
tsPayloadReaders
;
private
final
SparseBooleanArray
trackIds
;
private
ExtractorOutput
output
;
private
int
remainingPmts
;
private
boolean
tracksEnded
;
private
TsPayloadReader
id3Reader
;
public
TsExtractor
(
)
{
this
(
0
)
;
}
public
TsExtractor
(
Flags
int
defaultTsPayloadReaderFlags
)
{
this
(
MODE_NORMAL
new
TimestampAdjuster
(
0
)
new
DefaultTsPayloadReaderFactory
(
defaultTsPayloadReaderFlags
)
)
;
}
public
TsExtractor
(
Mode
int
mode
TimestampAdjuster
timestampAdjuster
TsPayloadReader
.
Factory
payloadReaderFactory
)
{
this
.
payloadReaderFactory
=
Assertions
.
checkNotNull
(
payloadReaderFactory
)
;
this
.
mode
=
mode
;
if
(
mode
=
=
MODE_SINGLE_PMT
|
|
mode
=
=
MODE_HLS
)
{
timestampAdjusters
=
Collections
.
singletonList
(
timestampAdjuster
)
;
}
else
{
timestampAdjusters
=
new
ArrayList
<
>
(
)
;
timestampAdjusters
.
add
(
timestampAdjuster
)
;
}
tsPacketBuffer
=
new
ParsableByteArray
(
BUFFER_SIZE
)
;
tsScratch
=
new
ParsableBitArray
(
new
byte
[
3
]
)
;
trackIds
=
new
SparseBooleanArray
(
)
;
tsPayloadReaders
=
new
SparseArray
<
>
(
)
;
continuityCounters
=
new
SparseIntArray
(
)
;
resetPayloadReaders
(
)
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
byte
[
]
buffer
=
tsPacketBuffer
.
data
;
input
.
peekFully
(
buffer
0
BUFFER_SIZE
)
;
for
(
int
j
=
0
;
j
<
TS_PACKET_SIZE
;
j
+
+
)
{
for
(
int
i
=
0
;
true
;
i
+
+
)
{
if
(
i
=
=
BUFFER_PACKET_COUNT
)
{
input
.
skipFully
(
j
)
;
return
true
;
}
if
(
buffer
[
j
+
i
*
TS_PACKET_SIZE
]
!
=
TS_SYNC_BYTE
)
{
break
;
}
}
}
return
false
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
this
.
output
=
output
;
output
.
seekMap
(
new
SeekMap
.
Unseekable
(
C
.
TIME_UNSET
)
)
;
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
int
timestampAdjustersCount
=
timestampAdjusters
.
size
(
)
;
for
(
int
i
=
0
;
i
<
timestampAdjustersCount
;
i
+
+
)
{
timestampAdjusters
.
get
(
i
)
.
reset
(
)
;
}
tsPacketBuffer
.
reset
(
)
;
continuityCounters
.
clear
(
)
;
resetPayloadReaders
(
)
;
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
byte
[
]
data
=
tsPacketBuffer
.
data
;
if
(
BUFFER_SIZE
-
tsPacketBuffer
.
getPosition
(
)
<
TS_PACKET_SIZE
)
{
int
bytesLeft
=
tsPacketBuffer
.
bytesLeft
(
)
;
if
(
bytesLeft
>
0
)
{
System
.
arraycopy
(
data
tsPacketBuffer
.
getPosition
(
)
data
0
bytesLeft
)
;
}
tsPacketBuffer
.
reset
(
data
bytesLeft
)
;
}
while
(
tsPacketBuffer
.
bytesLeft
(
)
<
TS_PACKET_SIZE
)
{
int
limit
=
tsPacketBuffer
.
limit
(
)
;
int
read
=
input
.
read
(
data
limit
BUFFER_SIZE
-
limit
)
;
if
(
read
=
=
C
.
RESULT_END_OF_INPUT
)
{
return
RESULT_END_OF_INPUT
;
}
tsPacketBuffer
.
setLimit
(
limit
+
read
)
;
}
final
int
limit
=
tsPacketBuffer
.
limit
(
)
;
int
position
=
tsPacketBuffer
.
getPosition
(
)
;
while
(
position
<
limit
&
&
data
[
position
]
!
=
TS_SYNC_BYTE
)
{
position
+
+
;
}
tsPacketBuffer
.
setPosition
(
position
)
;
int
endOfPacket
=
position
+
TS_PACKET_SIZE
;
if
(
endOfPacket
>
limit
)
{
return
RESULT_CONTINUE
;
}
tsPacketBuffer
.
skipBytes
(
1
)
;
tsPacketBuffer
.
readBytes
(
tsScratch
3
)
;
if
(
tsScratch
.
readBit
(
)
)
{
tsPacketBuffer
.
setPosition
(
endOfPacket
)
;
return
RESULT_CONTINUE
;
}
boolean
payloadUnitStartIndicator
=
tsScratch
.
readBit
(
)
;
tsScratch
.
skipBits
(
1
)
;
int
pid
=
tsScratch
.
readBits
(
13
)
;
tsScratch
.
skipBits
(
2
)
;
boolean
adaptationFieldExists
=
tsScratch
.
readBit
(
)
;
boolean
payloadExists
=
tsScratch
.
readBit
(
)
;
boolean
discontinuityFound
=
false
;
int
continuityCounter
=
tsScratch
.
readBits
(
4
)
;
if
(
mode
!
=
MODE_HLS
)
{
int
previousCounter
=
continuityCounters
.
get
(
pid
continuityCounter
-
1
)
;
continuityCounters
.
put
(
pid
continuityCounter
)
;
if
(
previousCounter
=
=
continuityCounter
)
{
if
(
payloadExists
)
{
tsPacketBuffer
.
setPosition
(
endOfPacket
)
;
return
RESULT_CONTINUE
;
}
}
else
if
(
continuityCounter
!
=
(
previousCounter
+
1
)
%
16
)
{
discontinuityFound
=
true
;
}
}
if
(
adaptationFieldExists
)
{
int
adaptationFieldLength
=
tsPacketBuffer
.
readUnsignedByte
(
)
;
tsPacketBuffer
.
skipBytes
(
adaptationFieldLength
)
;
}
if
(
payloadExists
)
{
TsPayloadReader
payloadReader
=
tsPayloadReaders
.
get
(
pid
)
;
if
(
payloadReader
!
=
null
)
{
if
(
discontinuityFound
)
{
payloadReader
.
seek
(
)
;
}
tsPacketBuffer
.
setLimit
(
endOfPacket
)
;
payloadReader
.
consume
(
tsPacketBuffer
payloadUnitStartIndicator
)
;
Assertions
.
checkState
(
tsPacketBuffer
.
getPosition
(
)
<
=
endOfPacket
)
;
tsPacketBuffer
.
setLimit
(
limit
)
;
}
}
tsPacketBuffer
.
setPosition
(
endOfPacket
)
;
return
RESULT_CONTINUE
;
}
private
void
resetPayloadReaders
(
)
{
trackIds
.
clear
(
)
;
tsPayloadReaders
.
clear
(
)
;
SparseArray
<
TsPayloadReader
>
initialPayloadReaders
=
payloadReaderFactory
.
createInitialPayloadReaders
(
)
;
int
initialPayloadReadersSize
=
initialPayloadReaders
.
size
(
)
;
for
(
int
i
=
0
;
i
<
initialPayloadReadersSize
;
i
+
+
)
{
tsPayloadReaders
.
put
(
initialPayloadReaders
.
keyAt
(
i
)
initialPayloadReaders
.
valueAt
(
i
)
)
;
}
tsPayloadReaders
.
put
(
TS_PAT_PID
new
SectionReader
(
new
PatReader
(
)
)
)
;
id3Reader
=
null
;
}
private
class
PatReader
implements
SectionPayloadReader
{
private
final
ParsableBitArray
patScratch
;
public
PatReader
(
)
{
patScratch
=
new
ParsableBitArray
(
new
byte
[
4
]
)
;
}
Override
public
void
init
(
TimestampAdjuster
timestampAdjuster
ExtractorOutput
extractorOutput
TrackIdGenerator
idGenerator
)
{
}
Override
public
void
consume
(
ParsableByteArray
sectionData
)
{
int
tableId
=
sectionData
.
readUnsignedByte
(
)
;
if
(
tableId
!
=
0x00
)
{
return
;
}
sectionData
.
skipBytes
(
7
)
;
int
programCount
=
sectionData
.
bytesLeft
(
)
/
4
;
for
(
int
i
=
0
;
i
<
programCount
;
i
+
+
)
{
sectionData
.
readBytes
(
patScratch
4
)
;
int
programNumber
=
patScratch
.
readBits
(
16
)
;
patScratch
.
skipBits
(
3
)
;
if
(
programNumber
=
=
0
)
{
patScratch
.
skipBits
(
13
)
;
}
else
{
int
pid
=
patScratch
.
readBits
(
13
)
;
tsPayloadReaders
.
put
(
pid
new
SectionReader
(
new
PmtReader
(
pid
)
)
)
;
remainingPmts
+
+
;
}
}
if
(
mode
!
=
MODE_HLS
)
{
tsPayloadReaders
.
remove
(
TS_PAT_PID
)
;
}
}
}
private
class
PmtReader
implements
SectionPayloadReader
{
private
static
final
int
TS_PMT_DESC_REGISTRATION
=
0x05
;
private
static
final
int
TS_PMT_DESC_ISO639_LANG
=
0x0A
;
private
static
final
int
TS_PMT_DESC_AC3
=
0x6A
;
private
static
final
int
TS_PMT_DESC_EAC3
=
0x7A
;
private
static
final
int
TS_PMT_DESC_DTS
=
0x7B
;
private
static
final
int
TS_PMT_DESC_DVBSUBS
=
0x59
;
private
final
ParsableBitArray
pmtScratch
;
private
final
int
pid
;
public
PmtReader
(
int
pid
)
{
pmtScratch
=
new
ParsableBitArray
(
new
byte
[
5
]
)
;
this
.
pid
=
pid
;
}
Override
public
void
init
(
TimestampAdjuster
timestampAdjuster
ExtractorOutput
extractorOutput
TrackIdGenerator
idGenerator
)
{
}
Override
public
void
consume
(
ParsableByteArray
sectionData
)
{
int
tableId
=
sectionData
.
readUnsignedByte
(
)
;
if
(
tableId
!
=
0x02
)
{
return
;
}
TimestampAdjuster
timestampAdjuster
;
if
(
mode
=
=
MODE_SINGLE_PMT
|
|
mode
=
=
MODE_HLS
|
|
remainingPmts
=
=
1
)
{
timestampAdjuster
=
timestampAdjusters
.
get
(
0
)
;
}
else
{
timestampAdjuster
=
new
TimestampAdjuster
(
timestampAdjusters
.
get
(
0
)
.
getFirstSampleTimestampUs
(
)
)
;
timestampAdjusters
.
add
(
timestampAdjuster
)
;
}
sectionData
.
skipBytes
(
2
)
;
int
programNumber
=
sectionData
.
readUnsignedShort
(
)
;
sectionData
.
skipBytes
(
5
)
;
sectionData
.
readBytes
(
pmtScratch
2
)
;
pmtScratch
.
skipBits
(
4
)
;
int
programInfoLength
=
pmtScratch
.
readBits
(
12
)
;
sectionData
.
skipBytes
(
programInfoLength
)
;
if
(
mode
=
=
MODE_HLS
&
&
id3Reader
=
=
null
)
{
EsInfo
dummyEsInfo
=
new
EsInfo
(
TS_STREAM_TYPE_ID3
null
null
new
byte
[
0
]
)
;
id3Reader
=
payloadReaderFactory
.
createPayloadReader
(
TS_STREAM_TYPE_ID3
dummyEsInfo
)
;
id3Reader
.
init
(
timestampAdjuster
output
new
TrackIdGenerator
(
programNumber
TS_STREAM_TYPE_ID3
MAX_PID_PLUS_ONE
)
)
;
}
int
remainingEntriesLength
=
sectionData
.
bytesLeft
(
)
;
while
(
remainingEntriesLength
>
0
)
{
sectionData
.
readBytes
(
pmtScratch
5
)
;
int
streamType
=
pmtScratch
.
readBits
(
8
)
;
pmtScratch
.
skipBits
(
3
)
;
int
elementaryPid
=
pmtScratch
.
readBits
(
13
)
;
pmtScratch
.
skipBits
(
4
)
;
int
esInfoLength
=
pmtScratch
.
readBits
(
12
)
;
EsInfo
esInfo
=
readEsInfo
(
sectionData
esInfoLength
)
;
if
(
streamType
=
=
0x06
)
{
streamType
=
esInfo
.
streamType
;
}
remainingEntriesLength
-
=
esInfoLength
+
5
;
int
trackId
=
mode
=
=
MODE_HLS
?
streamType
:
elementaryPid
;
if
(
trackIds
.
get
(
trackId
)
)
{
continue
;
}
trackIds
.
put
(
trackId
true
)
;
TsPayloadReader
reader
;
if
(
mode
=
=
MODE_HLS
&
&
streamType
=
=
TS_STREAM_TYPE_ID3
)
{
reader
=
id3Reader
;
}
else
{
reader
=
payloadReaderFactory
.
createPayloadReader
(
streamType
esInfo
)
;
if
(
reader
!
=
null
)
{
reader
.
init
(
timestampAdjuster
output
new
TrackIdGenerator
(
programNumber
trackId
MAX_PID_PLUS_ONE
)
)
;
}
}
if
(
reader
!
=
null
)
{
tsPayloadReaders
.
put
(
elementaryPid
reader
)
;
}
}
if
(
mode
=
=
MODE_HLS
)
{
if
(
!
tracksEnded
)
{
output
.
endTracks
(
)
;
remainingPmts
=
0
;
tracksEnded
=
true
;
}
}
else
{
tsPayloadReaders
.
remove
(
pid
)
;
remainingPmts
=
mode
=
=
MODE_SINGLE_PMT
?
0
:
remainingPmts
-
1
;
if
(
remainingPmts
=
=
0
)
{
output
.
endTracks
(
)
;
tracksEnded
=
true
;
}
}
}
private
EsInfo
readEsInfo
(
ParsableByteArray
data
int
length
)
{
int
descriptorsStartPosition
=
data
.
getPosition
(
)
;
int
descriptorsEndPosition
=
descriptorsStartPosition
+
length
;
int
streamType
=
-
1
;
String
language
=
null
;
List
<
DvbSubtitleInfo
>
dvbSubtitleInfos
=
null
;
while
(
data
.
getPosition
(
)
<
descriptorsEndPosition
)
{
int
descriptorTag
=
data
.
readUnsignedByte
(
)
;
int
descriptorLength
=
data
.
readUnsignedByte
(
)
;
int
positionOfNextDescriptor
=
data
.
getPosition
(
)
+
descriptorLength
;
if
(
descriptorTag
=
=
TS_PMT_DESC_REGISTRATION
)
{
long
formatIdentifier
=
data
.
readUnsignedInt
(
)
;
if
(
formatIdentifier
=
=
AC3_FORMAT_IDENTIFIER
)
{
streamType
=
TS_STREAM_TYPE_AC3
;
}
else
if
(
formatIdentifier
=
=
E_AC3_FORMAT_IDENTIFIER
)
{
streamType
=
TS_STREAM_TYPE_E_AC3
;
}
else
if
(
formatIdentifier
=
=
HEVC_FORMAT_IDENTIFIER
)
{
streamType
=
TS_STREAM_TYPE_H265
;
}
}
else
if
(
descriptorTag
=
=
TS_PMT_DESC_AC3
)
{
streamType
=
TS_STREAM_TYPE_AC3
;
}
else
if
(
descriptorTag
=
=
TS_PMT_DESC_EAC3
)
{
streamType
=
TS_STREAM_TYPE_E_AC3
;
}
else
if
(
descriptorTag
=
=
TS_PMT_DESC_DTS
)
{
streamType
=
TS_STREAM_TYPE_DTS
;
}
else
if
(
descriptorTag
=
=
TS_PMT_DESC_ISO639_LANG
)
{
language
=
data
.
readString
(
3
)
.
trim
(
)
;
}
else
if
(
descriptorTag
=
=
TS_PMT_DESC_DVBSUBS
)
{
streamType
=
TS_STREAM_TYPE_DVBSUBS
;
dvbSubtitleInfos
=
new
ArrayList
<
>
(
)
;
while
(
data
.
getPosition
(
)
<
positionOfNextDescriptor
)
{
String
dvbLanguage
=
data
.
readString
(
3
)
.
trim
(
)
;
int
dvbSubtitlingType
=
data
.
readUnsignedByte
(
)
;
byte
[
]
initializationData
=
new
byte
[
4
]
;
data
.
readBytes
(
initializationData
0
4
)
;
dvbSubtitleInfos
.
add
(
new
DvbSubtitleInfo
(
dvbLanguage
dvbSubtitlingType
initializationData
)
)
;
}
}
data
.
skipBytes
(
positionOfNextDescriptor
-
data
.
getPosition
(
)
)
;
}
data
.
setPosition
(
descriptorsEndPosition
)
;
return
new
EsInfo
(
streamType
language
dvbSubtitleInfos
Arrays
.
copyOfRange
(
data
.
data
descriptorsStartPosition
descriptorsEndPosition
)
)
;
}
}
}
