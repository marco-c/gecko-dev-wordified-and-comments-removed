package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
;
import
android
.
support
.
annotation
.
IntDef
;
import
android
.
util
.
Log
;
import
android
.
util
.
Pair
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmInitData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmInitData
.
SchemeData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ChunkIndex
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
.
Atom
.
ContainerAtom
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp4
.
Atom
.
LeafAtom
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
cea
.
CeaUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
NalUnitUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
Stack
;
import
java
.
util
.
UUID
;
public
final
class
FragmentedMp4Extractor
implements
Extractor
{
public
static
final
ExtractorsFactory
FACTORY
=
new
ExtractorsFactory
(
)
{
Override
public
Extractor
[
]
createExtractors
(
)
{
return
new
Extractor
[
]
{
new
FragmentedMp4Extractor
(
)
}
;
}
}
;
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
FLAG_WORKAROUND_IGNORE_TFDT_BOX
FLAG_ENABLE_EMSG_TRACK
FLAG_ENABLE_CEA608_TRACK
FLAG_SIDELOADED
}
)
public
interface
Flags
{
}
public
static
final
int
FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
=
1
;
public
static
final
int
FLAG_WORKAROUND_IGNORE_TFDT_BOX
=
2
;
public
static
final
int
FLAG_ENABLE_EMSG_TRACK
=
4
;
public
static
final
int
FLAG_ENABLE_CEA608_TRACK
=
8
;
private
static
final
int
FLAG_SIDELOADED
=
16
;
private
static
final
String
TAG
=
"
FragmentedMp4Extractor
"
;
private
static
final
int
SAMPLE_GROUP_TYPE_seig
=
Util
.
getIntegerCodeForString
(
"
seig
"
)
;
private
static
final
byte
[
]
PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE
=
new
byte
[
]
{
-
94
57
79
82
90
-
101
79
20
-
94
68
108
66
124
100
-
115
-
12
}
;
private
static
final
int
STATE_READING_ATOM_HEADER
=
0
;
private
static
final
int
STATE_READING_ATOM_PAYLOAD
=
1
;
private
static
final
int
STATE_READING_ENCRYPTION_DATA
=
2
;
private
static
final
int
STATE_READING_SAMPLE_START
=
3
;
private
static
final
int
STATE_READING_SAMPLE_CONTINUE
=
4
;
Flags
private
final
int
flags
;
private
final
Track
sideloadedTrack
;
private
final
SparseArray
<
TrackBundle
>
trackBundles
;
private
final
ParsableByteArray
nalStartCode
;
private
final
ParsableByteArray
nalPrefix
;
private
final
ParsableByteArray
nalBuffer
;
private
final
ParsableByteArray
encryptionSignalByte
;
private
final
TimestampAdjuster
timestampAdjuster
;
private
final
ParsableByteArray
atomHeader
;
private
final
byte
[
]
extendedTypeScratch
;
private
final
Stack
<
ContainerAtom
>
containerAtoms
;
private
final
LinkedList
<
MetadataSampleInfo
>
pendingMetadataSampleInfos
;
private
int
parserState
;
private
int
atomType
;
private
long
atomSize
;
private
int
atomHeaderBytesRead
;
private
ParsableByteArray
atomData
;
private
long
endOfMdatPosition
;
private
int
pendingMetadataSampleBytes
;
private
long
durationUs
;
private
long
segmentIndexEarliestPresentationTimeUs
;
private
TrackBundle
currentTrackBundle
;
private
int
sampleSize
;
private
int
sampleBytesWritten
;
private
int
sampleCurrentNalBytesRemaining
;
private
boolean
processSeiNalUnitPayload
;
private
ExtractorOutput
extractorOutput
;
private
TrackOutput
eventMessageTrackOutput
;
private
TrackOutput
[
]
cea608TrackOutputs
;
private
boolean
haveOutputSeekMap
;
public
FragmentedMp4Extractor
(
)
{
this
(
0
)
;
}
public
FragmentedMp4Extractor
(
Flags
int
flags
)
{
this
(
flags
null
)
;
}
public
FragmentedMp4Extractor
(
Flags
int
flags
TimestampAdjuster
timestampAdjuster
)
{
this
(
flags
timestampAdjuster
null
)
;
}
public
FragmentedMp4Extractor
(
Flags
int
flags
TimestampAdjuster
timestampAdjuster
Track
sideloadedTrack
)
{
this
.
flags
=
flags
|
(
sideloadedTrack
!
=
null
?
FLAG_SIDELOADED
:
0
)
;
this
.
timestampAdjuster
=
timestampAdjuster
;
this
.
sideloadedTrack
=
sideloadedTrack
;
atomHeader
=
new
ParsableByteArray
(
Atom
.
LONG_HEADER_SIZE
)
;
nalStartCode
=
new
ParsableByteArray
(
NalUnitUtil
.
NAL_START_CODE
)
;
nalPrefix
=
new
ParsableByteArray
(
5
)
;
nalBuffer
=
new
ParsableByteArray
(
)
;
encryptionSignalByte
=
new
ParsableByteArray
(
1
)
;
extendedTypeScratch
=
new
byte
[
16
]
;
containerAtoms
=
new
Stack
<
>
(
)
;
pendingMetadataSampleInfos
=
new
LinkedList
<
>
(
)
;
trackBundles
=
new
SparseArray
<
>
(
)
;
durationUs
=
C
.
TIME_UNSET
;
segmentIndexEarliestPresentationTimeUs
=
C
.
TIME_UNSET
;
enterReadingAtomHeaderState
(
)
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
return
Sniffer
.
sniffFragmented
(
input
)
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
extractorOutput
=
output
;
if
(
sideloadedTrack
!
=
null
)
{
TrackBundle
bundle
=
new
TrackBundle
(
output
.
track
(
0
sideloadedTrack
.
type
)
)
;
bundle
.
init
(
sideloadedTrack
new
DefaultSampleValues
(
0
0
0
0
)
)
;
trackBundles
.
put
(
0
bundle
)
;
maybeInitExtraTracks
(
)
;
extractorOutput
.
endTracks
(
)
;
}
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
int
trackCount
=
trackBundles
.
size
(
)
;
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
trackBundles
.
valueAt
(
i
)
.
reset
(
)
;
}
pendingMetadataSampleInfos
.
clear
(
)
;
pendingMetadataSampleBytes
=
0
;
containerAtoms
.
clear
(
)
;
enterReadingAtomHeaderState
(
)
;
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
while
(
true
)
{
switch
(
parserState
)
{
case
STATE_READING_ATOM_HEADER
:
if
(
!
readAtomHeader
(
input
)
)
{
return
Extractor
.
RESULT_END_OF_INPUT
;
}
break
;
case
STATE_READING_ATOM_PAYLOAD
:
readAtomPayload
(
input
)
;
break
;
case
STATE_READING_ENCRYPTION_DATA
:
readEncryptionData
(
input
)
;
break
;
default
:
if
(
readSample
(
input
)
)
{
return
RESULT_CONTINUE
;
}
}
}
}
private
void
enterReadingAtomHeaderState
(
)
{
parserState
=
STATE_READING_ATOM_HEADER
;
atomHeaderBytesRead
=
0
;
}
private
boolean
readAtomHeader
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
if
(
atomHeaderBytesRead
=
=
0
)
{
if
(
!
input
.
readFully
(
atomHeader
.
data
0
Atom
.
HEADER_SIZE
true
)
)
{
return
false
;
}
atomHeaderBytesRead
=
Atom
.
HEADER_SIZE
;
atomHeader
.
setPosition
(
0
)
;
atomSize
=
atomHeader
.
readUnsignedInt
(
)
;
atomType
=
atomHeader
.
readInt
(
)
;
}
if
(
atomSize
=
=
Atom
.
LONG_SIZE_PREFIX
)
{
int
headerBytesRemaining
=
Atom
.
LONG_HEADER_SIZE
-
Atom
.
HEADER_SIZE
;
input
.
readFully
(
atomHeader
.
data
Atom
.
HEADER_SIZE
headerBytesRemaining
)
;
atomHeaderBytesRead
+
=
headerBytesRemaining
;
atomSize
=
atomHeader
.
readUnsignedLongToLong
(
)
;
}
if
(
atomSize
<
atomHeaderBytesRead
)
{
throw
new
ParserException
(
"
Atom
size
less
than
header
length
(
unsupported
)
.
"
)
;
}
long
atomPosition
=
input
.
getPosition
(
)
-
atomHeaderBytesRead
;
if
(
atomType
=
=
Atom
.
TYPE_moof
)
{
int
trackCount
=
trackBundles
.
size
(
)
;
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
TrackFragment
fragment
=
trackBundles
.
valueAt
(
i
)
.
fragment
;
fragment
.
atomPosition
=
atomPosition
;
fragment
.
auxiliaryDataPosition
=
atomPosition
;
fragment
.
dataPosition
=
atomPosition
;
}
}
if
(
atomType
=
=
Atom
.
TYPE_mdat
)
{
currentTrackBundle
=
null
;
endOfMdatPosition
=
atomPosition
+
atomSize
;
if
(
!
haveOutputSeekMap
)
{
extractorOutput
.
seekMap
(
new
SeekMap
.
Unseekable
(
durationUs
)
)
;
haveOutputSeekMap
=
true
;
}
parserState
=
STATE_READING_ENCRYPTION_DATA
;
return
true
;
}
if
(
shouldParseContainerAtom
(
atomType
)
)
{
long
endPosition
=
input
.
getPosition
(
)
+
atomSize
-
Atom
.
HEADER_SIZE
;
containerAtoms
.
add
(
new
ContainerAtom
(
atomType
endPosition
)
)
;
if
(
atomSize
=
=
atomHeaderBytesRead
)
{
processAtomEnded
(
endPosition
)
;
}
else
{
enterReadingAtomHeaderState
(
)
;
}
}
else
if
(
shouldParseLeafAtom
(
atomType
)
)
{
if
(
atomHeaderBytesRead
!
=
Atom
.
HEADER_SIZE
)
{
throw
new
ParserException
(
"
Leaf
atom
defines
extended
atom
size
(
unsupported
)
.
"
)
;
}
if
(
atomSize
>
Integer
.
MAX_VALUE
)
{
throw
new
ParserException
(
"
Leaf
atom
with
length
>
2147483647
(
unsupported
)
.
"
)
;
}
atomData
=
new
ParsableByteArray
(
(
int
)
atomSize
)
;
System
.
arraycopy
(
atomHeader
.
data
0
atomData
.
data
0
Atom
.
HEADER_SIZE
)
;
parserState
=
STATE_READING_ATOM_PAYLOAD
;
}
else
{
if
(
atomSize
>
Integer
.
MAX_VALUE
)
{
throw
new
ParserException
(
"
Skipping
atom
with
length
>
2147483647
(
unsupported
)
.
"
)
;
}
atomData
=
null
;
parserState
=
STATE_READING_ATOM_PAYLOAD
;
}
return
true
;
}
private
void
readAtomPayload
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
int
atomPayloadSize
=
(
int
)
atomSize
-
atomHeaderBytesRead
;
if
(
atomData
!
=
null
)
{
input
.
readFully
(
atomData
.
data
Atom
.
HEADER_SIZE
atomPayloadSize
)
;
onLeafAtomRead
(
new
LeafAtom
(
atomType
atomData
)
input
.
getPosition
(
)
)
;
}
else
{
input
.
skipFully
(
atomPayloadSize
)
;
}
processAtomEnded
(
input
.
getPosition
(
)
)
;
}
private
void
processAtomEnded
(
long
atomEndPosition
)
throws
ParserException
{
while
(
!
containerAtoms
.
isEmpty
(
)
&
&
containerAtoms
.
peek
(
)
.
endPosition
=
=
atomEndPosition
)
{
onContainerAtomRead
(
containerAtoms
.
pop
(
)
)
;
}
enterReadingAtomHeaderState
(
)
;
}
private
void
onLeafAtomRead
(
LeafAtom
leaf
long
inputPosition
)
throws
ParserException
{
if
(
!
containerAtoms
.
isEmpty
(
)
)
{
containerAtoms
.
peek
(
)
.
add
(
leaf
)
;
}
else
if
(
leaf
.
type
=
=
Atom
.
TYPE_sidx
)
{
Pair
<
Long
ChunkIndex
>
result
=
parseSidx
(
leaf
.
data
inputPosition
)
;
segmentIndexEarliestPresentationTimeUs
=
result
.
first
;
extractorOutput
.
seekMap
(
result
.
second
)
;
haveOutputSeekMap
=
true
;
}
else
if
(
leaf
.
type
=
=
Atom
.
TYPE_emsg
)
{
onEmsgLeafAtomRead
(
leaf
.
data
)
;
}
}
private
void
onContainerAtomRead
(
ContainerAtom
container
)
throws
ParserException
{
if
(
container
.
type
=
=
Atom
.
TYPE_moov
)
{
onMoovContainerAtomRead
(
container
)
;
}
else
if
(
container
.
type
=
=
Atom
.
TYPE_moof
)
{
onMoofContainerAtomRead
(
container
)
;
}
else
if
(
!
containerAtoms
.
isEmpty
(
)
)
{
containerAtoms
.
peek
(
)
.
add
(
container
)
;
}
}
private
void
onMoovContainerAtomRead
(
ContainerAtom
moov
)
throws
ParserException
{
Assertions
.
checkState
(
sideloadedTrack
=
=
null
"
Unexpected
moov
box
.
"
)
;
DrmInitData
drmInitData
=
getDrmInitDataFromAtoms
(
moov
.
leafChildren
)
;
ContainerAtom
mvex
=
moov
.
getContainerAtomOfType
(
Atom
.
TYPE_mvex
)
;
SparseArray
<
DefaultSampleValues
>
defaultSampleValuesArray
=
new
SparseArray
<
>
(
)
;
long
duration
=
C
.
TIME_UNSET
;
int
mvexChildrenSize
=
mvex
.
leafChildren
.
size
(
)
;
for
(
int
i
=
0
;
i
<
mvexChildrenSize
;
i
+
+
)
{
Atom
.
LeafAtom
atom
=
mvex
.
leafChildren
.
get
(
i
)
;
if
(
atom
.
type
=
=
Atom
.
TYPE_trex
)
{
Pair
<
Integer
DefaultSampleValues
>
trexData
=
parseTrex
(
atom
.
data
)
;
defaultSampleValuesArray
.
put
(
trexData
.
first
trexData
.
second
)
;
}
else
if
(
atom
.
type
=
=
Atom
.
TYPE_mehd
)
{
duration
=
parseMehd
(
atom
.
data
)
;
}
}
SparseArray
<
Track
>
tracks
=
new
SparseArray
<
>
(
)
;
int
moovContainerChildrenSize
=
moov
.
containerChildren
.
size
(
)
;
for
(
int
i
=
0
;
i
<
moovContainerChildrenSize
;
i
+
+
)
{
Atom
.
ContainerAtom
atom
=
moov
.
containerChildren
.
get
(
i
)
;
if
(
atom
.
type
=
=
Atom
.
TYPE_trak
)
{
Track
track
=
AtomParsers
.
parseTrak
(
atom
moov
.
getLeafAtomOfType
(
Atom
.
TYPE_mvhd
)
duration
drmInitData
false
)
;
if
(
track
!
=
null
)
{
tracks
.
put
(
track
.
id
track
)
;
}
}
}
int
trackCount
=
tracks
.
size
(
)
;
if
(
trackBundles
.
size
(
)
=
=
0
)
{
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
Track
track
=
tracks
.
valueAt
(
i
)
;
TrackBundle
trackBundle
=
new
TrackBundle
(
extractorOutput
.
track
(
i
track
.
type
)
)
;
trackBundle
.
init
(
track
defaultSampleValuesArray
.
get
(
track
.
id
)
)
;
trackBundles
.
put
(
track
.
id
trackBundle
)
;
durationUs
=
Math
.
max
(
durationUs
track
.
durationUs
)
;
}
maybeInitExtraTracks
(
)
;
extractorOutput
.
endTracks
(
)
;
}
else
{
Assertions
.
checkState
(
trackBundles
.
size
(
)
=
=
trackCount
)
;
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
Track
track
=
tracks
.
valueAt
(
i
)
;
trackBundles
.
get
(
track
.
id
)
.
init
(
track
defaultSampleValuesArray
.
get
(
track
.
id
)
)
;
}
}
}
private
void
onMoofContainerAtomRead
(
ContainerAtom
moof
)
throws
ParserException
{
parseMoof
(
moof
trackBundles
flags
extendedTypeScratch
)
;
DrmInitData
drmInitData
=
getDrmInitDataFromAtoms
(
moof
.
leafChildren
)
;
if
(
drmInitData
!
=
null
)
{
int
trackCount
=
trackBundles
.
size
(
)
;
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
trackBundles
.
valueAt
(
i
)
.
updateDrmInitData
(
drmInitData
)
;
}
}
}
private
void
maybeInitExtraTracks
(
)
{
if
(
(
flags
&
FLAG_ENABLE_EMSG_TRACK
)
!
=
0
&
&
eventMessageTrackOutput
=
=
null
)
{
eventMessageTrackOutput
=
extractorOutput
.
track
(
trackBundles
.
size
(
)
C
.
TRACK_TYPE_METADATA
)
;
eventMessageTrackOutput
.
format
(
Format
.
createSampleFormat
(
null
MimeTypes
.
APPLICATION_EMSG
Format
.
OFFSET_SAMPLE_RELATIVE
)
)
;
}
if
(
(
flags
&
FLAG_ENABLE_CEA608_TRACK
)
!
=
0
&
&
cea608TrackOutputs
=
=
null
)
{
TrackOutput
cea608TrackOutput
=
extractorOutput
.
track
(
trackBundles
.
size
(
)
+
1
C
.
TRACK_TYPE_TEXT
)
;
cea608TrackOutput
.
format
(
Format
.
createTextSampleFormat
(
null
MimeTypes
.
APPLICATION_CEA608
null
Format
.
NO_VALUE
0
null
null
)
)
;
cea608TrackOutputs
=
new
TrackOutput
[
]
{
cea608TrackOutput
}
;
}
}
private
void
onEmsgLeafAtomRead
(
ParsableByteArray
atom
)
{
if
(
eventMessageTrackOutput
=
=
null
)
{
return
;
}
atom
.
setPosition
(
Atom
.
FULL_HEADER_SIZE
)
;
atom
.
readNullTerminatedString
(
)
;
atom
.
readNullTerminatedString
(
)
;
long
timescale
=
atom
.
readUnsignedInt
(
)
;
long
presentationTimeDeltaUs
=
Util
.
scaleLargeTimestamp
(
atom
.
readUnsignedInt
(
)
C
.
MICROS_PER_SECOND
timescale
)
;
atom
.
setPosition
(
Atom
.
FULL_HEADER_SIZE
)
;
int
sampleSize
=
atom
.
bytesLeft
(
)
;
eventMessageTrackOutput
.
sampleData
(
atom
sampleSize
)
;
if
(
segmentIndexEarliestPresentationTimeUs
!
=
C
.
TIME_UNSET
)
{
eventMessageTrackOutput
.
sampleMetadata
(
segmentIndexEarliestPresentationTimeUs
+
presentationTimeDeltaUs
C
.
BUFFER_FLAG_KEY_FRAME
sampleSize
0
null
)
;
}
else
{
pendingMetadataSampleInfos
.
addLast
(
new
MetadataSampleInfo
(
presentationTimeDeltaUs
sampleSize
)
)
;
pendingMetadataSampleBytes
+
=
sampleSize
;
}
}
private
static
Pair
<
Integer
DefaultSampleValues
>
parseTrex
(
ParsableByteArray
trex
)
{
trex
.
setPosition
(
Atom
.
FULL_HEADER_SIZE
)
;
int
trackId
=
trex
.
readInt
(
)
;
int
defaultSampleDescriptionIndex
=
trex
.
readUnsignedIntToInt
(
)
-
1
;
int
defaultSampleDuration
=
trex
.
readUnsignedIntToInt
(
)
;
int
defaultSampleSize
=
trex
.
readUnsignedIntToInt
(
)
;
int
defaultSampleFlags
=
trex
.
readInt
(
)
;
return
Pair
.
create
(
trackId
new
DefaultSampleValues
(
defaultSampleDescriptionIndex
defaultSampleDuration
defaultSampleSize
defaultSampleFlags
)
)
;
}
private
static
long
parseMehd
(
ParsableByteArray
mehd
)
{
mehd
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
mehd
.
readInt
(
)
;
int
version
=
Atom
.
parseFullAtomVersion
(
fullAtom
)
;
return
version
=
=
0
?
mehd
.
readUnsignedInt
(
)
:
mehd
.
readUnsignedLongToLong
(
)
;
}
private
static
void
parseMoof
(
ContainerAtom
moof
SparseArray
<
TrackBundle
>
trackBundleArray
Flags
int
flags
byte
[
]
extendedTypeScratch
)
throws
ParserException
{
int
moofContainerChildrenSize
=
moof
.
containerChildren
.
size
(
)
;
for
(
int
i
=
0
;
i
<
moofContainerChildrenSize
;
i
+
+
)
{
Atom
.
ContainerAtom
child
=
moof
.
containerChildren
.
get
(
i
)
;
if
(
child
.
type
=
=
Atom
.
TYPE_traf
)
{
parseTraf
(
child
trackBundleArray
flags
extendedTypeScratch
)
;
}
}
}
private
static
void
parseTraf
(
ContainerAtom
traf
SparseArray
<
TrackBundle
>
trackBundleArray
Flags
int
flags
byte
[
]
extendedTypeScratch
)
throws
ParserException
{
LeafAtom
tfhd
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_tfhd
)
;
TrackBundle
trackBundle
=
parseTfhd
(
tfhd
.
data
trackBundleArray
flags
)
;
if
(
trackBundle
=
=
null
)
{
return
;
}
TrackFragment
fragment
=
trackBundle
.
fragment
;
long
decodeTime
=
fragment
.
nextFragmentDecodeTime
;
trackBundle
.
reset
(
)
;
LeafAtom
tfdtAtom
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_tfdt
)
;
if
(
tfdtAtom
!
=
null
&
&
(
flags
&
FLAG_WORKAROUND_IGNORE_TFDT_BOX
)
=
=
0
)
{
decodeTime
=
parseTfdt
(
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_tfdt
)
.
data
)
;
}
parseTruns
(
traf
trackBundle
decodeTime
flags
)
;
LeafAtom
saiz
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_saiz
)
;
if
(
saiz
!
=
null
)
{
TrackEncryptionBox
trackEncryptionBox
=
trackBundle
.
track
.
sampleDescriptionEncryptionBoxes
[
fragment
.
header
.
sampleDescriptionIndex
]
;
parseSaiz
(
trackEncryptionBox
saiz
.
data
fragment
)
;
}
LeafAtom
saio
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_saio
)
;
if
(
saio
!
=
null
)
{
parseSaio
(
saio
.
data
fragment
)
;
}
LeafAtom
senc
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_senc
)
;
if
(
senc
!
=
null
)
{
parseSenc
(
senc
.
data
fragment
)
;
}
LeafAtom
sbgp
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_sbgp
)
;
LeafAtom
sgpd
=
traf
.
getLeafAtomOfType
(
Atom
.
TYPE_sgpd
)
;
if
(
sbgp
!
=
null
&
&
sgpd
!
=
null
)
{
parseSgpd
(
sbgp
.
data
sgpd
.
data
fragment
)
;
}
int
leafChildrenSize
=
traf
.
leafChildren
.
size
(
)
;
for
(
int
i
=
0
;
i
<
leafChildrenSize
;
i
+
+
)
{
LeafAtom
atom
=
traf
.
leafChildren
.
get
(
i
)
;
if
(
atom
.
type
=
=
Atom
.
TYPE_uuid
)
{
parseUuid
(
atom
.
data
fragment
extendedTypeScratch
)
;
}
}
}
private
static
void
parseTruns
(
ContainerAtom
traf
TrackBundle
trackBundle
long
decodeTime
Flags
int
flags
)
{
int
trunCount
=
0
;
int
totalSampleCount
=
0
;
List
<
LeafAtom
>
leafChildren
=
traf
.
leafChildren
;
int
leafChildrenSize
=
leafChildren
.
size
(
)
;
for
(
int
i
=
0
;
i
<
leafChildrenSize
;
i
+
+
)
{
LeafAtom
atom
=
leafChildren
.
get
(
i
)
;
if
(
atom
.
type
=
=
Atom
.
TYPE_trun
)
{
ParsableByteArray
trunData
=
atom
.
data
;
trunData
.
setPosition
(
Atom
.
FULL_HEADER_SIZE
)
;
int
trunSampleCount
=
trunData
.
readUnsignedIntToInt
(
)
;
if
(
trunSampleCount
>
0
)
{
totalSampleCount
+
=
trunSampleCount
;
trunCount
+
+
;
}
}
}
trackBundle
.
currentTrackRunIndex
=
0
;
trackBundle
.
currentSampleInTrackRun
=
0
;
trackBundle
.
currentSampleIndex
=
0
;
trackBundle
.
fragment
.
initTables
(
trunCount
totalSampleCount
)
;
int
trunIndex
=
0
;
int
trunStartPosition
=
0
;
for
(
int
i
=
0
;
i
<
leafChildrenSize
;
i
+
+
)
{
LeafAtom
trun
=
leafChildren
.
get
(
i
)
;
if
(
trun
.
type
=
=
Atom
.
TYPE_trun
)
{
trunStartPosition
=
parseTrun
(
trackBundle
trunIndex
+
+
decodeTime
flags
trun
.
data
trunStartPosition
)
;
}
}
}
private
static
void
parseSaiz
(
TrackEncryptionBox
encryptionBox
ParsableByteArray
saiz
TrackFragment
out
)
throws
ParserException
{
int
vectorSize
=
encryptionBox
.
initializationVectorSize
;
saiz
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
saiz
.
readInt
(
)
;
int
flags
=
Atom
.
parseFullAtomFlags
(
fullAtom
)
;
if
(
(
flags
&
0x01
)
=
=
1
)
{
saiz
.
skipBytes
(
8
)
;
}
int
defaultSampleInfoSize
=
saiz
.
readUnsignedByte
(
)
;
int
sampleCount
=
saiz
.
readUnsignedIntToInt
(
)
;
if
(
sampleCount
!
=
out
.
sampleCount
)
{
throw
new
ParserException
(
"
Length
mismatch
:
"
+
sampleCount
+
"
"
+
out
.
sampleCount
)
;
}
int
totalSize
=
0
;
if
(
defaultSampleInfoSize
=
=
0
)
{
boolean
[
]
sampleHasSubsampleEncryptionTable
=
out
.
sampleHasSubsampleEncryptionTable
;
for
(
int
i
=
0
;
i
<
sampleCount
;
i
+
+
)
{
int
sampleInfoSize
=
saiz
.
readUnsignedByte
(
)
;
totalSize
+
=
sampleInfoSize
;
sampleHasSubsampleEncryptionTable
[
i
]
=
sampleInfoSize
>
vectorSize
;
}
}
else
{
boolean
subsampleEncryption
=
defaultSampleInfoSize
>
vectorSize
;
totalSize
+
=
defaultSampleInfoSize
*
sampleCount
;
Arrays
.
fill
(
out
.
sampleHasSubsampleEncryptionTable
0
sampleCount
subsampleEncryption
)
;
}
out
.
initEncryptionData
(
totalSize
)
;
}
private
static
void
parseSaio
(
ParsableByteArray
saio
TrackFragment
out
)
throws
ParserException
{
saio
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
saio
.
readInt
(
)
;
int
flags
=
Atom
.
parseFullAtomFlags
(
fullAtom
)
;
if
(
(
flags
&
0x01
)
=
=
1
)
{
saio
.
skipBytes
(
8
)
;
}
int
entryCount
=
saio
.
readUnsignedIntToInt
(
)
;
if
(
entryCount
!
=
1
)
{
throw
new
ParserException
(
"
Unexpected
saio
entry
count
:
"
+
entryCount
)
;
}
int
version
=
Atom
.
parseFullAtomVersion
(
fullAtom
)
;
out
.
auxiliaryDataPosition
+
=
version
=
=
0
?
saio
.
readUnsignedInt
(
)
:
saio
.
readUnsignedLongToLong
(
)
;
}
private
static
TrackBundle
parseTfhd
(
ParsableByteArray
tfhd
SparseArray
<
TrackBundle
>
trackBundles
int
flags
)
{
tfhd
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
tfhd
.
readInt
(
)
;
int
atomFlags
=
Atom
.
parseFullAtomFlags
(
fullAtom
)
;
int
trackId
=
tfhd
.
readInt
(
)
;
TrackBundle
trackBundle
=
trackBundles
.
get
(
(
flags
&
FLAG_SIDELOADED
)
=
=
0
?
trackId
:
0
)
;
if
(
trackBundle
=
=
null
)
{
return
null
;
}
if
(
(
atomFlags
&
0x01
)
!
=
0
)
{
long
baseDataPosition
=
tfhd
.
readUnsignedLongToLong
(
)
;
trackBundle
.
fragment
.
dataPosition
=
baseDataPosition
;
trackBundle
.
fragment
.
auxiliaryDataPosition
=
baseDataPosition
;
}
DefaultSampleValues
defaultSampleValues
=
trackBundle
.
defaultSampleValues
;
int
defaultSampleDescriptionIndex
=
(
(
atomFlags
&
0x02
)
!
=
0
)
?
tfhd
.
readUnsignedIntToInt
(
)
-
1
:
defaultSampleValues
.
sampleDescriptionIndex
;
int
defaultSampleDuration
=
(
(
atomFlags
&
0x08
)
!
=
0
)
?
tfhd
.
readUnsignedIntToInt
(
)
:
defaultSampleValues
.
duration
;
int
defaultSampleSize
=
(
(
atomFlags
&
0x10
)
!
=
0
)
?
tfhd
.
readUnsignedIntToInt
(
)
:
defaultSampleValues
.
size
;
int
defaultSampleFlags
=
(
(
atomFlags
&
0x20
)
!
=
0
)
?
tfhd
.
readUnsignedIntToInt
(
)
:
defaultSampleValues
.
flags
;
trackBundle
.
fragment
.
header
=
new
DefaultSampleValues
(
defaultSampleDescriptionIndex
defaultSampleDuration
defaultSampleSize
defaultSampleFlags
)
;
return
trackBundle
;
}
private
static
long
parseTfdt
(
ParsableByteArray
tfdt
)
{
tfdt
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
tfdt
.
readInt
(
)
;
int
version
=
Atom
.
parseFullAtomVersion
(
fullAtom
)
;
return
version
=
=
1
?
tfdt
.
readUnsignedLongToLong
(
)
:
tfdt
.
readUnsignedInt
(
)
;
}
private
static
int
parseTrun
(
TrackBundle
trackBundle
int
index
long
decodeTime
Flags
int
flags
ParsableByteArray
trun
int
trackRunStart
)
{
trun
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
trun
.
readInt
(
)
;
int
atomFlags
=
Atom
.
parseFullAtomFlags
(
fullAtom
)
;
Track
track
=
trackBundle
.
track
;
TrackFragment
fragment
=
trackBundle
.
fragment
;
DefaultSampleValues
defaultSampleValues
=
fragment
.
header
;
fragment
.
trunLength
[
index
]
=
trun
.
readUnsignedIntToInt
(
)
;
fragment
.
trunDataPosition
[
index
]
=
fragment
.
dataPosition
;
if
(
(
atomFlags
&
0x01
)
!
=
0
)
{
fragment
.
trunDataPosition
[
index
]
+
=
trun
.
readInt
(
)
;
}
boolean
firstSampleFlagsPresent
=
(
atomFlags
&
0x04
)
!
=
0
;
int
firstSampleFlags
=
defaultSampleValues
.
flags
;
if
(
firstSampleFlagsPresent
)
{
firstSampleFlags
=
trun
.
readUnsignedIntToInt
(
)
;
}
boolean
sampleDurationsPresent
=
(
atomFlags
&
0x100
)
!
=
0
;
boolean
sampleSizesPresent
=
(
atomFlags
&
0x200
)
!
=
0
;
boolean
sampleFlagsPresent
=
(
atomFlags
&
0x400
)
!
=
0
;
boolean
sampleCompositionTimeOffsetsPresent
=
(
atomFlags
&
0x800
)
!
=
0
;
long
edtsOffset
=
0
;
if
(
track
.
editListDurations
!
=
null
&
&
track
.
editListDurations
.
length
=
=
1
&
&
track
.
editListDurations
[
0
]
=
=
0
)
{
edtsOffset
=
Util
.
scaleLargeTimestamp
(
track
.
editListMediaTimes
[
0
]
1000
track
.
timescale
)
;
}
int
[
]
sampleSizeTable
=
fragment
.
sampleSizeTable
;
int
[
]
sampleCompositionTimeOffsetTable
=
fragment
.
sampleCompositionTimeOffsetTable
;
long
[
]
sampleDecodingTimeTable
=
fragment
.
sampleDecodingTimeTable
;
boolean
[
]
sampleIsSyncFrameTable
=
fragment
.
sampleIsSyncFrameTable
;
boolean
workaroundEveryVideoFrameIsSyncFrame
=
track
.
type
=
=
C
.
TRACK_TYPE_VIDEO
&
&
(
flags
&
FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
)
!
=
0
;
int
trackRunEnd
=
trackRunStart
+
fragment
.
trunLength
[
index
]
;
long
timescale
=
track
.
timescale
;
long
cumulativeTime
=
index
>
0
?
fragment
.
nextFragmentDecodeTime
:
decodeTime
;
for
(
int
i
=
trackRunStart
;
i
<
trackRunEnd
;
i
+
+
)
{
int
sampleDuration
=
sampleDurationsPresent
?
trun
.
readUnsignedIntToInt
(
)
:
defaultSampleValues
.
duration
;
int
sampleSize
=
sampleSizesPresent
?
trun
.
readUnsignedIntToInt
(
)
:
defaultSampleValues
.
size
;
int
sampleFlags
=
(
i
=
=
0
&
&
firstSampleFlagsPresent
)
?
firstSampleFlags
:
sampleFlagsPresent
?
trun
.
readInt
(
)
:
defaultSampleValues
.
flags
;
if
(
sampleCompositionTimeOffsetsPresent
)
{
int
sampleOffset
=
trun
.
readInt
(
)
;
sampleCompositionTimeOffsetTable
[
i
]
=
(
int
)
(
(
sampleOffset
*
1000
)
/
timescale
)
;
}
else
{
sampleCompositionTimeOffsetTable
[
i
]
=
0
;
}
sampleDecodingTimeTable
[
i
]
=
Util
.
scaleLargeTimestamp
(
cumulativeTime
1000
timescale
)
-
edtsOffset
;
sampleSizeTable
[
i
]
=
sampleSize
;
sampleIsSyncFrameTable
[
i
]
=
(
(
sampleFlags
>
>
16
)
&
0x1
)
=
=
0
&
&
(
!
workaroundEveryVideoFrameIsSyncFrame
|
|
i
=
=
0
)
;
cumulativeTime
+
=
sampleDuration
;
}
fragment
.
nextFragmentDecodeTime
=
cumulativeTime
;
return
trackRunEnd
;
}
private
static
void
parseUuid
(
ParsableByteArray
uuid
TrackFragment
out
byte
[
]
extendedTypeScratch
)
throws
ParserException
{
uuid
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
uuid
.
readBytes
(
extendedTypeScratch
0
16
)
;
if
(
!
Arrays
.
equals
(
extendedTypeScratch
PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE
)
)
{
return
;
}
parseSenc
(
uuid
16
out
)
;
}
private
static
void
parseSenc
(
ParsableByteArray
senc
TrackFragment
out
)
throws
ParserException
{
parseSenc
(
senc
0
out
)
;
}
private
static
void
parseSenc
(
ParsableByteArray
senc
int
offset
TrackFragment
out
)
throws
ParserException
{
senc
.
setPosition
(
Atom
.
HEADER_SIZE
+
offset
)
;
int
fullAtom
=
senc
.
readInt
(
)
;
int
flags
=
Atom
.
parseFullAtomFlags
(
fullAtom
)
;
if
(
(
flags
&
0x01
)
!
=
0
)
{
throw
new
ParserException
(
"
Overriding
TrackEncryptionBox
parameters
is
unsupported
.
"
)
;
}
boolean
subsampleEncryption
=
(
flags
&
0x02
)
!
=
0
;
int
sampleCount
=
senc
.
readUnsignedIntToInt
(
)
;
if
(
sampleCount
!
=
out
.
sampleCount
)
{
throw
new
ParserException
(
"
Length
mismatch
:
"
+
sampleCount
+
"
"
+
out
.
sampleCount
)
;
}
Arrays
.
fill
(
out
.
sampleHasSubsampleEncryptionTable
0
sampleCount
subsampleEncryption
)
;
out
.
initEncryptionData
(
senc
.
bytesLeft
(
)
)
;
out
.
fillEncryptionData
(
senc
)
;
}
private
static
void
parseSgpd
(
ParsableByteArray
sbgp
ParsableByteArray
sgpd
TrackFragment
out
)
throws
ParserException
{
sbgp
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
sbgpFullAtom
=
sbgp
.
readInt
(
)
;
if
(
sbgp
.
readInt
(
)
!
=
SAMPLE_GROUP_TYPE_seig
)
{
return
;
}
if
(
Atom
.
parseFullAtomVersion
(
sbgpFullAtom
)
=
=
1
)
{
sbgp
.
skipBytes
(
4
)
;
}
if
(
sbgp
.
readInt
(
)
!
=
1
)
{
throw
new
ParserException
(
"
Entry
count
in
sbgp
!
=
1
(
unsupported
)
.
"
)
;
}
sgpd
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
sgpdFullAtom
=
sgpd
.
readInt
(
)
;
if
(
sgpd
.
readInt
(
)
!
=
SAMPLE_GROUP_TYPE_seig
)
{
return
;
}
int
sgpdVersion
=
Atom
.
parseFullAtomVersion
(
sgpdFullAtom
)
;
if
(
sgpdVersion
=
=
1
)
{
if
(
sgpd
.
readUnsignedInt
(
)
=
=
0
)
{
throw
new
ParserException
(
"
Variable
length
decription
in
sgpd
found
(
unsupported
)
"
)
;
}
}
else
if
(
sgpdVersion
>
=
2
)
{
sgpd
.
skipBytes
(
4
)
;
}
if
(
sgpd
.
readUnsignedInt
(
)
!
=
1
)
{
throw
new
ParserException
(
"
Entry
count
in
sgpd
!
=
1
(
unsupported
)
.
"
)
;
}
sgpd
.
skipBytes
(
2
)
;
boolean
isProtected
=
sgpd
.
readUnsignedByte
(
)
=
=
1
;
if
(
!
isProtected
)
{
return
;
}
int
initVectorSize
=
sgpd
.
readUnsignedByte
(
)
;
byte
[
]
keyId
=
new
byte
[
16
]
;
sgpd
.
readBytes
(
keyId
0
keyId
.
length
)
;
out
.
definesEncryptionData
=
true
;
out
.
trackEncryptionBox
=
new
TrackEncryptionBox
(
isProtected
initVectorSize
keyId
)
;
}
private
static
Pair
<
Long
ChunkIndex
>
parseSidx
(
ParsableByteArray
atom
long
inputPosition
)
throws
ParserException
{
atom
.
setPosition
(
Atom
.
HEADER_SIZE
)
;
int
fullAtom
=
atom
.
readInt
(
)
;
int
version
=
Atom
.
parseFullAtomVersion
(
fullAtom
)
;
atom
.
skipBytes
(
4
)
;
long
timescale
=
atom
.
readUnsignedInt
(
)
;
long
earliestPresentationTime
;
long
offset
=
inputPosition
;
if
(
version
=
=
0
)
{
earliestPresentationTime
=
atom
.
readUnsignedInt
(
)
;
offset
+
=
atom
.
readUnsignedInt
(
)
;
}
else
{
earliestPresentationTime
=
atom
.
readUnsignedLongToLong
(
)
;
offset
+
=
atom
.
readUnsignedLongToLong
(
)
;
}
long
earliestPresentationTimeUs
=
Util
.
scaleLargeTimestamp
(
earliestPresentationTime
C
.
MICROS_PER_SECOND
timescale
)
;
atom
.
skipBytes
(
2
)
;
int
referenceCount
=
atom
.
readUnsignedShort
(
)
;
int
[
]
sizes
=
new
int
[
referenceCount
]
;
long
[
]
offsets
=
new
long
[
referenceCount
]
;
long
[
]
durationsUs
=
new
long
[
referenceCount
]
;
long
[
]
timesUs
=
new
long
[
referenceCount
]
;
long
time
=
earliestPresentationTime
;
long
timeUs
=
earliestPresentationTimeUs
;
for
(
int
i
=
0
;
i
<
referenceCount
;
i
+
+
)
{
int
firstInt
=
atom
.
readInt
(
)
;
int
type
=
0x80000000
&
firstInt
;
if
(
type
!
=
0
)
{
throw
new
ParserException
(
"
Unhandled
indirect
reference
"
)
;
}
long
referenceDuration
=
atom
.
readUnsignedInt
(
)
;
sizes
[
i
]
=
0x7FFFFFFF
&
firstInt
;
offsets
[
i
]
=
offset
;
timesUs
[
i
]
=
timeUs
;
time
+
=
referenceDuration
;
timeUs
=
Util
.
scaleLargeTimestamp
(
time
C
.
MICROS_PER_SECOND
timescale
)
;
durationsUs
[
i
]
=
timeUs
-
timesUs
[
i
]
;
atom
.
skipBytes
(
4
)
;
offset
+
=
sizes
[
i
]
;
}
return
Pair
.
create
(
earliestPresentationTimeUs
new
ChunkIndex
(
sizes
offsets
durationsUs
timesUs
)
)
;
}
private
void
readEncryptionData
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
TrackBundle
nextTrackBundle
=
null
;
long
nextDataOffset
=
Long
.
MAX_VALUE
;
int
trackBundlesSize
=
trackBundles
.
size
(
)
;
for
(
int
i
=
0
;
i
<
trackBundlesSize
;
i
+
+
)
{
TrackFragment
trackFragment
=
trackBundles
.
valueAt
(
i
)
.
fragment
;
if
(
trackFragment
.
sampleEncryptionDataNeedsFill
&
&
trackFragment
.
auxiliaryDataPosition
<
nextDataOffset
)
{
nextDataOffset
=
trackFragment
.
auxiliaryDataPosition
;
nextTrackBundle
=
trackBundles
.
valueAt
(
i
)
;
}
}
if
(
nextTrackBundle
=
=
null
)
{
parserState
=
STATE_READING_SAMPLE_START
;
return
;
}
int
bytesToSkip
=
(
int
)
(
nextDataOffset
-
input
.
getPosition
(
)
)
;
if
(
bytesToSkip
<
0
)
{
throw
new
ParserException
(
"
Offset
to
encryption
data
was
negative
.
"
)
;
}
input
.
skipFully
(
bytesToSkip
)
;
nextTrackBundle
.
fragment
.
fillEncryptionData
(
input
)
;
}
private
boolean
readSample
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
if
(
parserState
=
=
STATE_READING_SAMPLE_START
)
{
if
(
currentTrackBundle
=
=
null
)
{
TrackBundle
currentTrackBundle
=
getNextFragmentRun
(
trackBundles
)
;
if
(
currentTrackBundle
=
=
null
)
{
int
bytesToSkip
=
(
int
)
(
endOfMdatPosition
-
input
.
getPosition
(
)
)
;
if
(
bytesToSkip
<
0
)
{
throw
new
ParserException
(
"
Offset
to
end
of
mdat
was
negative
.
"
)
;
}
input
.
skipFully
(
bytesToSkip
)
;
enterReadingAtomHeaderState
(
)
;
return
false
;
}
long
nextDataPosition
=
currentTrackBundle
.
fragment
.
trunDataPosition
[
currentTrackBundle
.
currentTrackRunIndex
]
;
int
bytesToSkip
=
(
int
)
(
nextDataPosition
-
input
.
getPosition
(
)
)
;
if
(
bytesToSkip
<
0
)
{
Log
.
w
(
TAG
"
Ignoring
negative
offset
to
sample
data
.
"
)
;
bytesToSkip
=
0
;
}
input
.
skipFully
(
bytesToSkip
)
;
this
.
currentTrackBundle
=
currentTrackBundle
;
}
sampleSize
=
currentTrackBundle
.
fragment
.
sampleSizeTable
[
currentTrackBundle
.
currentSampleIndex
]
;
if
(
currentTrackBundle
.
fragment
.
definesEncryptionData
)
{
sampleBytesWritten
=
appendSampleEncryptionData
(
currentTrackBundle
)
;
sampleSize
+
=
sampleBytesWritten
;
}
else
{
sampleBytesWritten
=
0
;
}
if
(
currentTrackBundle
.
track
.
sampleTransformation
=
=
Track
.
TRANSFORMATION_CEA608_CDAT
)
{
sampleSize
-
=
Atom
.
HEADER_SIZE
;
input
.
skipFully
(
Atom
.
HEADER_SIZE
)
;
}
parserState
=
STATE_READING_SAMPLE_CONTINUE
;
sampleCurrentNalBytesRemaining
=
0
;
}
TrackFragment
fragment
=
currentTrackBundle
.
fragment
;
Track
track
=
currentTrackBundle
.
track
;
TrackOutput
output
=
currentTrackBundle
.
output
;
int
sampleIndex
=
currentTrackBundle
.
currentSampleIndex
;
if
(
track
.
nalUnitLengthFieldLength
!
=
0
)
{
byte
[
]
nalPrefixData
=
nalPrefix
.
data
;
nalPrefixData
[
0
]
=
0
;
nalPrefixData
[
1
]
=
0
;
nalPrefixData
[
2
]
=
0
;
int
nalUnitPrefixLength
=
track
.
nalUnitLengthFieldLength
+
1
;
int
nalUnitLengthFieldLengthDiff
=
4
-
track
.
nalUnitLengthFieldLength
;
while
(
sampleBytesWritten
<
sampleSize
)
{
if
(
sampleCurrentNalBytesRemaining
=
=
0
)
{
input
.
readFully
(
nalPrefixData
nalUnitLengthFieldLengthDiff
nalUnitPrefixLength
)
;
nalPrefix
.
setPosition
(
0
)
;
sampleCurrentNalBytesRemaining
=
nalPrefix
.
readUnsignedIntToInt
(
)
-
1
;
nalStartCode
.
setPosition
(
0
)
;
output
.
sampleData
(
nalStartCode
4
)
;
output
.
sampleData
(
nalPrefix
1
)
;
processSeiNalUnitPayload
=
cea608TrackOutputs
!
=
null
&
&
NalUnitUtil
.
isNalUnitSei
(
track
.
format
.
sampleMimeType
nalPrefixData
[
4
]
)
;
sampleBytesWritten
+
=
5
;
sampleSize
+
=
nalUnitLengthFieldLengthDiff
;
}
else
{
int
writtenBytes
;
if
(
processSeiNalUnitPayload
)
{
nalBuffer
.
reset
(
sampleCurrentNalBytesRemaining
)
;
input
.
readFully
(
nalBuffer
.
data
0
sampleCurrentNalBytesRemaining
)
;
output
.
sampleData
(
nalBuffer
sampleCurrentNalBytesRemaining
)
;
writtenBytes
=
sampleCurrentNalBytesRemaining
;
int
unescapedLength
=
NalUnitUtil
.
unescapeStream
(
nalBuffer
.
data
nalBuffer
.
limit
(
)
)
;
nalBuffer
.
setPosition
(
MimeTypes
.
VIDEO_H265
.
equals
(
track
.
format
.
sampleMimeType
)
?
1
:
0
)
;
nalBuffer
.
setLimit
(
unescapedLength
)
;
CeaUtil
.
consume
(
fragment
.
getSamplePresentationTime
(
sampleIndex
)
*
1000L
nalBuffer
cea608TrackOutputs
)
;
}
else
{
writtenBytes
=
output
.
sampleData
(
input
sampleCurrentNalBytesRemaining
false
)
;
}
sampleBytesWritten
+
=
writtenBytes
;
sampleCurrentNalBytesRemaining
-
=
writtenBytes
;
}
}
}
else
{
while
(
sampleBytesWritten
<
sampleSize
)
{
int
writtenBytes
=
output
.
sampleData
(
input
sampleSize
-
sampleBytesWritten
false
)
;
sampleBytesWritten
+
=
writtenBytes
;
}
}
long
sampleTimeUs
=
fragment
.
getSamplePresentationTime
(
sampleIndex
)
*
1000L
;
C
.
BufferFlags
int
sampleFlags
=
(
fragment
.
definesEncryptionData
?
C
.
BUFFER_FLAG_ENCRYPTED
:
0
)
|
(
fragment
.
sampleIsSyncFrameTable
[
sampleIndex
]
?
C
.
BUFFER_FLAG_KEY_FRAME
:
0
)
;
int
sampleDescriptionIndex
=
fragment
.
header
.
sampleDescriptionIndex
;
byte
[
]
encryptionKey
=
null
;
if
(
fragment
.
definesEncryptionData
)
{
encryptionKey
=
fragment
.
trackEncryptionBox
!
=
null
?
fragment
.
trackEncryptionBox
.
keyId
:
track
.
sampleDescriptionEncryptionBoxes
[
sampleDescriptionIndex
]
.
keyId
;
}
if
(
timestampAdjuster
!
=
null
)
{
sampleTimeUs
=
timestampAdjuster
.
adjustSampleTimestamp
(
sampleTimeUs
)
;
}
output
.
sampleMetadata
(
sampleTimeUs
sampleFlags
sampleSize
0
encryptionKey
)
;
while
(
!
pendingMetadataSampleInfos
.
isEmpty
(
)
)
{
MetadataSampleInfo
sampleInfo
=
pendingMetadataSampleInfos
.
removeFirst
(
)
;
pendingMetadataSampleBytes
-
=
sampleInfo
.
size
;
eventMessageTrackOutput
.
sampleMetadata
(
sampleTimeUs
+
sampleInfo
.
presentationTimeDeltaUs
C
.
BUFFER_FLAG_KEY_FRAME
sampleInfo
.
size
pendingMetadataSampleBytes
null
)
;
}
currentTrackBundle
.
currentSampleIndex
+
+
;
currentTrackBundle
.
currentSampleInTrackRun
+
+
;
if
(
currentTrackBundle
.
currentSampleInTrackRun
=
=
fragment
.
trunLength
[
currentTrackBundle
.
currentTrackRunIndex
]
)
{
currentTrackBundle
.
currentTrackRunIndex
+
+
;
currentTrackBundle
.
currentSampleInTrackRun
=
0
;
currentTrackBundle
=
null
;
}
parserState
=
STATE_READING_SAMPLE_START
;
return
true
;
}
private
static
TrackBundle
getNextFragmentRun
(
SparseArray
<
TrackBundle
>
trackBundles
)
{
TrackBundle
nextTrackBundle
=
null
;
long
nextTrackRunOffset
=
Long
.
MAX_VALUE
;
int
trackBundlesSize
=
trackBundles
.
size
(
)
;
for
(
int
i
=
0
;
i
<
trackBundlesSize
;
i
+
+
)
{
TrackBundle
trackBundle
=
trackBundles
.
valueAt
(
i
)
;
if
(
trackBundle
.
currentTrackRunIndex
=
=
trackBundle
.
fragment
.
trunCount
)
{
}
else
{
long
trunOffset
=
trackBundle
.
fragment
.
trunDataPosition
[
trackBundle
.
currentTrackRunIndex
]
;
if
(
trunOffset
<
nextTrackRunOffset
)
{
nextTrackBundle
=
trackBundle
;
nextTrackRunOffset
=
trunOffset
;
}
}
}
return
nextTrackBundle
;
}
private
int
appendSampleEncryptionData
(
TrackBundle
trackBundle
)
{
TrackFragment
trackFragment
=
trackBundle
.
fragment
;
ParsableByteArray
sampleEncryptionData
=
trackFragment
.
sampleEncryptionData
;
int
sampleDescriptionIndex
=
trackFragment
.
header
.
sampleDescriptionIndex
;
TrackEncryptionBox
encryptionBox
=
trackFragment
.
trackEncryptionBox
!
=
null
?
trackFragment
.
trackEncryptionBox
:
trackBundle
.
track
.
sampleDescriptionEncryptionBoxes
[
sampleDescriptionIndex
]
;
int
vectorSize
=
encryptionBox
.
initializationVectorSize
;
boolean
subsampleEncryption
=
trackFragment
.
sampleHasSubsampleEncryptionTable
[
trackBundle
.
currentSampleIndex
]
;
encryptionSignalByte
.
data
[
0
]
=
(
byte
)
(
vectorSize
|
(
subsampleEncryption
?
0x80
:
0
)
)
;
encryptionSignalByte
.
setPosition
(
0
)
;
TrackOutput
output
=
trackBundle
.
output
;
output
.
sampleData
(
encryptionSignalByte
1
)
;
output
.
sampleData
(
sampleEncryptionData
vectorSize
)
;
if
(
!
subsampleEncryption
)
{
return
1
+
vectorSize
;
}
int
subsampleCount
=
sampleEncryptionData
.
readUnsignedShort
(
)
;
sampleEncryptionData
.
skipBytes
(
-
2
)
;
int
subsampleDataLength
=
2
+
6
*
subsampleCount
;
output
.
sampleData
(
sampleEncryptionData
subsampleDataLength
)
;
return
1
+
vectorSize
+
subsampleDataLength
;
}
private
static
DrmInitData
getDrmInitDataFromAtoms
(
List
<
Atom
.
LeafAtom
>
leafChildren
)
{
ArrayList
<
SchemeData
>
schemeDatas
=
null
;
int
leafChildrenSize
=
leafChildren
.
size
(
)
;
for
(
int
i
=
0
;
i
<
leafChildrenSize
;
i
+
+
)
{
LeafAtom
child
=
leafChildren
.
get
(
i
)
;
if
(
child
.
type
=
=
Atom
.
TYPE_pssh
)
{
if
(
schemeDatas
=
=
null
)
{
schemeDatas
=
new
ArrayList
<
>
(
)
;
}
byte
[
]
psshData
=
child
.
data
.
data
;
UUID
uuid
=
PsshAtomUtil
.
parseUuid
(
psshData
)
;
if
(
uuid
=
=
null
)
{
Log
.
w
(
TAG
"
Skipped
pssh
atom
(
failed
to
extract
uuid
)
"
)
;
}
else
{
schemeDatas
.
add
(
new
SchemeData
(
uuid
MimeTypes
.
VIDEO_MP4
psshData
)
)
;
}
}
}
return
schemeDatas
=
=
null
?
null
:
new
DrmInitData
(
schemeDatas
)
;
}
private
static
boolean
shouldParseLeafAtom
(
int
atom
)
{
return
atom
=
=
Atom
.
TYPE_hdlr
|
|
atom
=
=
Atom
.
TYPE_mdhd
|
|
atom
=
=
Atom
.
TYPE_mvhd
|
|
atom
=
=
Atom
.
TYPE_sidx
|
|
atom
=
=
Atom
.
TYPE_stsd
|
|
atom
=
=
Atom
.
TYPE_tfdt
|
|
atom
=
=
Atom
.
TYPE_tfhd
|
|
atom
=
=
Atom
.
TYPE_tkhd
|
|
atom
=
=
Atom
.
TYPE_trex
|
|
atom
=
=
Atom
.
TYPE_trun
|
|
atom
=
=
Atom
.
TYPE_pssh
|
|
atom
=
=
Atom
.
TYPE_saiz
|
|
atom
=
=
Atom
.
TYPE_saio
|
|
atom
=
=
Atom
.
TYPE_senc
|
|
atom
=
=
Atom
.
TYPE_uuid
|
|
atom
=
=
Atom
.
TYPE_sbgp
|
|
atom
=
=
Atom
.
TYPE_sgpd
|
|
atom
=
=
Atom
.
TYPE_elst
|
|
atom
=
=
Atom
.
TYPE_mehd
|
|
atom
=
=
Atom
.
TYPE_emsg
;
}
private
static
boolean
shouldParseContainerAtom
(
int
atom
)
{
return
atom
=
=
Atom
.
TYPE_moov
|
|
atom
=
=
Atom
.
TYPE_trak
|
|
atom
=
=
Atom
.
TYPE_mdia
|
|
atom
=
=
Atom
.
TYPE_minf
|
|
atom
=
=
Atom
.
TYPE_stbl
|
|
atom
=
=
Atom
.
TYPE_moof
|
|
atom
=
=
Atom
.
TYPE_traf
|
|
atom
=
=
Atom
.
TYPE_mvex
|
|
atom
=
=
Atom
.
TYPE_edts
;
}
private
static
final
class
MetadataSampleInfo
{
public
final
long
presentationTimeDeltaUs
;
public
final
int
size
;
public
MetadataSampleInfo
(
long
presentationTimeDeltaUs
int
size
)
{
this
.
presentationTimeDeltaUs
=
presentationTimeDeltaUs
;
this
.
size
=
size
;
}
}
private
static
final
class
TrackBundle
{
public
final
TrackFragment
fragment
;
public
final
TrackOutput
output
;
public
Track
track
;
public
DefaultSampleValues
defaultSampleValues
;
public
int
currentSampleIndex
;
public
int
currentSampleInTrackRun
;
public
int
currentTrackRunIndex
;
public
TrackBundle
(
TrackOutput
output
)
{
fragment
=
new
TrackFragment
(
)
;
this
.
output
=
output
;
}
public
void
init
(
Track
track
DefaultSampleValues
defaultSampleValues
)
{
this
.
track
=
Assertions
.
checkNotNull
(
track
)
;
this
.
defaultSampleValues
=
Assertions
.
checkNotNull
(
defaultSampleValues
)
;
output
.
format
(
track
.
format
)
;
reset
(
)
;
}
public
void
reset
(
)
{
fragment
.
reset
(
)
;
currentSampleIndex
=
0
;
currentTrackRunIndex
=
0
;
currentSampleInTrackRun
=
0
;
}
public
void
updateDrmInitData
(
DrmInitData
drmInitData
)
{
output
.
format
(
track
.
format
.
copyWithDrmInitData
(
drmInitData
)
)
;
}
}
}
