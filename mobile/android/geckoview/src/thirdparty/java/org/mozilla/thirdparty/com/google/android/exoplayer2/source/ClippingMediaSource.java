package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlayer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Timeline
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
public
final
class
ClippingMediaSource
implements
MediaSource
MediaSource
.
Listener
{
private
final
MediaSource
mediaSource
;
private
final
long
startUs
;
private
final
long
endUs
;
private
final
ArrayList
<
ClippingMediaPeriod
>
mediaPeriods
;
private
MediaSource
.
Listener
sourceListener
;
private
ClippingTimeline
clippingTimeline
;
public
ClippingMediaSource
(
MediaSource
mediaSource
long
startPositionUs
long
endPositionUs
)
{
Assertions
.
checkArgument
(
startPositionUs
>
=
0
)
;
this
.
mediaSource
=
Assertions
.
checkNotNull
(
mediaSource
)
;
startUs
=
startPositionUs
;
endUs
=
endPositionUs
;
mediaPeriods
=
new
ArrayList
<
>
(
)
;
}
Override
public
void
prepareSource
(
ExoPlayer
player
boolean
isTopLevelSource
Listener
listener
)
{
this
.
sourceListener
=
listener
;
mediaSource
.
prepareSource
(
player
false
this
)
;
}
Override
public
void
maybeThrowSourceInfoRefreshError
(
)
throws
IOException
{
mediaSource
.
maybeThrowSourceInfoRefreshError
(
)
;
}
Override
public
MediaPeriod
createPeriod
(
int
index
Allocator
allocator
long
positionUs
)
{
ClippingMediaPeriod
mediaPeriod
=
new
ClippingMediaPeriod
(
mediaSource
.
createPeriod
(
index
allocator
startUs
+
positionUs
)
)
;
mediaPeriods
.
add
(
mediaPeriod
)
;
mediaPeriod
.
setClipping
(
clippingTimeline
.
startUs
clippingTimeline
.
endUs
)
;
return
mediaPeriod
;
}
Override
public
void
releasePeriod
(
MediaPeriod
mediaPeriod
)
{
Assertions
.
checkState
(
mediaPeriods
.
remove
(
mediaPeriod
)
)
;
mediaSource
.
releasePeriod
(
(
(
ClippingMediaPeriod
)
mediaPeriod
)
.
mediaPeriod
)
;
}
Override
public
void
releaseSource
(
)
{
mediaSource
.
releaseSource
(
)
;
}
Override
public
void
onSourceInfoRefreshed
(
Timeline
timeline
Object
manifest
)
{
clippingTimeline
=
new
ClippingTimeline
(
timeline
startUs
endUs
)
;
sourceListener
.
onSourceInfoRefreshed
(
clippingTimeline
manifest
)
;
long
startUs
=
clippingTimeline
.
startUs
;
long
endUs
=
clippingTimeline
.
endUs
=
=
C
.
TIME_UNSET
?
C
.
TIME_END_OF_SOURCE
:
clippingTimeline
.
endUs
;
int
count
=
mediaPeriods
.
size
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
mediaPeriods
.
get
(
i
)
.
setClipping
(
startUs
endUs
)
;
}
}
private
static
final
class
ClippingTimeline
extends
Timeline
{
private
final
Timeline
timeline
;
private
final
long
startUs
;
private
final
long
endUs
;
public
ClippingTimeline
(
Timeline
timeline
long
startUs
long
endUs
)
{
Assertions
.
checkArgument
(
timeline
.
getWindowCount
(
)
=
=
1
)
;
Assertions
.
checkArgument
(
timeline
.
getPeriodCount
(
)
=
=
1
)
;
Window
window
=
timeline
.
getWindow
(
0
new
Window
(
)
false
)
;
Assertions
.
checkArgument
(
!
window
.
isDynamic
)
;
long
resolvedEndUs
=
endUs
=
=
C
.
TIME_END_OF_SOURCE
?
window
.
durationUs
:
endUs
;
if
(
window
.
durationUs
!
=
C
.
TIME_UNSET
)
{
Assertions
.
checkArgument
(
startUs
=
=
0
|
|
window
.
isSeekable
)
;
Assertions
.
checkArgument
(
resolvedEndUs
<
=
window
.
durationUs
)
;
Assertions
.
checkArgument
(
startUs
<
=
resolvedEndUs
)
;
}
Period
period
=
timeline
.
getPeriod
(
0
new
Period
(
)
)
;
Assertions
.
checkArgument
(
period
.
getPositionInWindowUs
(
)
=
=
0
)
;
this
.
timeline
=
timeline
;
this
.
startUs
=
startUs
;
this
.
endUs
=
resolvedEndUs
;
}
Override
public
int
getWindowCount
(
)
{
return
1
;
}
Override
public
Window
getWindow
(
int
windowIndex
Window
window
boolean
setIds
long
defaultPositionProjectionUs
)
{
window
=
timeline
.
getWindow
(
0
window
setIds
defaultPositionProjectionUs
)
;
window
.
durationUs
=
endUs
!
=
C
.
TIME_UNSET
?
endUs
-
startUs
:
C
.
TIME_UNSET
;
if
(
window
.
defaultPositionUs
!
=
C
.
TIME_UNSET
)
{
window
.
defaultPositionUs
=
Math
.
max
(
window
.
defaultPositionUs
startUs
)
;
window
.
defaultPositionUs
=
endUs
=
=
C
.
TIME_UNSET
?
window
.
defaultPositionUs
:
Math
.
min
(
window
.
defaultPositionUs
endUs
)
;
window
.
defaultPositionUs
-
=
startUs
;
}
long
startMs
=
C
.
usToMs
(
startUs
)
;
if
(
window
.
presentationStartTimeMs
!
=
C
.
TIME_UNSET
)
{
window
.
presentationStartTimeMs
+
=
startMs
;
}
if
(
window
.
windowStartTimeMs
!
=
C
.
TIME_UNSET
)
{
window
.
windowStartTimeMs
+
=
startMs
;
}
return
window
;
}
Override
public
int
getPeriodCount
(
)
{
return
1
;
}
Override
public
Period
getPeriod
(
int
periodIndex
Period
period
boolean
setIds
)
{
period
=
timeline
.
getPeriod
(
0
period
setIds
)
;
period
.
durationUs
=
endUs
!
=
C
.
TIME_UNSET
?
endUs
-
startUs
:
C
.
TIME_UNSET
;
return
period
;
}
Override
public
int
getIndexOfPeriod
(
Object
uid
)
{
return
timeline
.
getIndexOfPeriod
(
uid
)
;
}
}
}
