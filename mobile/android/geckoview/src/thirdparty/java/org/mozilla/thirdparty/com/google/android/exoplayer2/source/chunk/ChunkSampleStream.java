package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
DefaultTrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
AdaptiveMediaSourceEventListener
.
EventDispatcher
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SampleStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SequenceableLoader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Loader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Collections
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
public
class
ChunkSampleStream
<
T
extends
ChunkSource
>
implements
SampleStream
SequenceableLoader
Loader
.
Callback
<
Chunk
>
{
private
final
int
primaryTrackType
;
private
final
int
[
]
embeddedTrackTypes
;
private
final
boolean
[
]
embeddedTracksSelected
;
private
final
T
chunkSource
;
private
final
SequenceableLoader
.
Callback
<
ChunkSampleStream
<
T
>
>
callback
;
private
final
EventDispatcher
eventDispatcher
;
private
final
int
minLoadableRetryCount
;
private
final
Loader
loader
;
private
final
ChunkHolder
nextChunkHolder
;
private
final
LinkedList
<
BaseMediaChunk
>
mediaChunks
;
private
final
List
<
BaseMediaChunk
>
readOnlyMediaChunks
;
private
final
DefaultTrackOutput
primarySampleQueue
;
private
final
DefaultTrackOutput
[
]
embeddedSampleQueues
;
private
final
BaseMediaChunkOutput
mediaChunkOutput
;
private
Format
primaryDownstreamTrackFormat
;
private
long
pendingResetPositionUs
;
long
lastSeekPositionUs
;
boolean
loadingFinished
;
public
ChunkSampleStream
(
int
primaryTrackType
int
[
]
embeddedTrackTypes
T
chunkSource
Callback
<
ChunkSampleStream
<
T
>
>
callback
Allocator
allocator
long
positionUs
int
minLoadableRetryCount
EventDispatcher
eventDispatcher
)
{
this
.
primaryTrackType
=
primaryTrackType
;
this
.
embeddedTrackTypes
=
embeddedTrackTypes
;
this
.
chunkSource
=
chunkSource
;
this
.
callback
=
callback
;
this
.
eventDispatcher
=
eventDispatcher
;
this
.
minLoadableRetryCount
=
minLoadableRetryCount
;
loader
=
new
Loader
(
"
Loader
:
ChunkSampleStream
"
)
;
nextChunkHolder
=
new
ChunkHolder
(
)
;
mediaChunks
=
new
LinkedList
<
>
(
)
;
readOnlyMediaChunks
=
Collections
.
unmodifiableList
(
mediaChunks
)
;
int
embeddedTrackCount
=
embeddedTrackTypes
=
=
null
?
0
:
embeddedTrackTypes
.
length
;
embeddedSampleQueues
=
new
DefaultTrackOutput
[
embeddedTrackCount
]
;
embeddedTracksSelected
=
new
boolean
[
embeddedTrackCount
]
;
int
[
]
trackTypes
=
new
int
[
1
+
embeddedTrackCount
]
;
DefaultTrackOutput
[
]
sampleQueues
=
new
DefaultTrackOutput
[
1
+
embeddedTrackCount
]
;
primarySampleQueue
=
new
DefaultTrackOutput
(
allocator
)
;
trackTypes
[
0
]
=
primaryTrackType
;
sampleQueues
[
0
]
=
primarySampleQueue
;
for
(
int
i
=
0
;
i
<
embeddedTrackCount
;
i
+
+
)
{
DefaultTrackOutput
trackOutput
=
new
DefaultTrackOutput
(
allocator
)
;
embeddedSampleQueues
[
i
]
=
trackOutput
;
sampleQueues
[
i
+
1
]
=
trackOutput
;
trackTypes
[
i
+
1
]
=
embeddedTrackTypes
[
i
]
;
}
mediaChunkOutput
=
new
BaseMediaChunkOutput
(
trackTypes
sampleQueues
)
;
pendingResetPositionUs
=
positionUs
;
lastSeekPositionUs
=
positionUs
;
}
public
void
discardUnselectedEmbeddedTracksTo
(
long
positionUs
)
{
for
(
int
i
=
0
;
i
<
embeddedSampleQueues
.
length
;
i
+
+
)
{
if
(
!
embeddedTracksSelected
[
i
]
)
{
embeddedSampleQueues
[
i
]
.
skipToKeyframeBefore
(
positionUs
true
)
;
}
}
}
public
EmbeddedSampleStream
selectEmbeddedTrack
(
long
positionUs
int
trackType
)
{
for
(
int
i
=
0
;
i
<
embeddedSampleQueues
.
length
;
i
+
+
)
{
if
(
embeddedTrackTypes
[
i
]
=
=
trackType
)
{
Assertions
.
checkState
(
!
embeddedTracksSelected
[
i
]
)
;
embeddedTracksSelected
[
i
]
=
true
;
embeddedSampleQueues
[
i
]
.
skipToKeyframeBefore
(
positionUs
true
)
;
return
new
EmbeddedSampleStream
(
this
embeddedSampleQueues
[
i
]
i
)
;
}
}
throw
new
IllegalStateException
(
)
;
}
public
T
getChunkSource
(
)
{
return
chunkSource
;
}
public
long
getBufferedPositionUs
(
)
{
if
(
loadingFinished
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
else
if
(
isPendingReset
(
)
)
{
return
pendingResetPositionUs
;
}
else
{
long
bufferedPositionUs
=
lastSeekPositionUs
;
BaseMediaChunk
lastMediaChunk
=
mediaChunks
.
getLast
(
)
;
BaseMediaChunk
lastCompletedMediaChunk
=
lastMediaChunk
.
isLoadCompleted
(
)
?
lastMediaChunk
:
mediaChunks
.
size
(
)
>
1
?
mediaChunks
.
get
(
mediaChunks
.
size
(
)
-
2
)
:
null
;
if
(
lastCompletedMediaChunk
!
=
null
)
{
bufferedPositionUs
=
Math
.
max
(
bufferedPositionUs
lastCompletedMediaChunk
.
endTimeUs
)
;
}
return
Math
.
max
(
bufferedPositionUs
primarySampleQueue
.
getLargestQueuedTimestampUs
(
)
)
;
}
}
public
void
seekToUs
(
long
positionUs
)
{
lastSeekPositionUs
=
positionUs
;
boolean
seekInsideBuffer
=
!
isPendingReset
(
)
&
&
primarySampleQueue
.
skipToKeyframeBefore
(
positionUs
positionUs
<
getNextLoadPositionUs
(
)
)
;
if
(
seekInsideBuffer
)
{
while
(
mediaChunks
.
size
(
)
>
1
&
&
mediaChunks
.
get
(
1
)
.
getFirstSampleIndex
(
0
)
<
=
primarySampleQueue
.
getReadIndex
(
)
)
{
mediaChunks
.
removeFirst
(
)
;
}
for
(
DefaultTrackOutput
embeddedSampleQueue
:
embeddedSampleQueues
)
{
embeddedSampleQueue
.
skipToKeyframeBefore
(
positionUs
true
)
;
}
}
else
{
pendingResetPositionUs
=
positionUs
;
loadingFinished
=
false
;
mediaChunks
.
clear
(
)
;
if
(
loader
.
isLoading
(
)
)
{
loader
.
cancelLoading
(
)
;
}
else
{
primarySampleQueue
.
reset
(
true
)
;
for
(
DefaultTrackOutput
embeddedSampleQueue
:
embeddedSampleQueues
)
{
embeddedSampleQueue
.
reset
(
true
)
;
}
}
}
}
public
void
release
(
)
{
primarySampleQueue
.
disable
(
)
;
for
(
DefaultTrackOutput
embeddedSampleQueue
:
embeddedSampleQueues
)
{
embeddedSampleQueue
.
disable
(
)
;
}
loader
.
release
(
)
;
}
Override
public
boolean
isReady
(
)
{
return
loadingFinished
|
|
(
!
isPendingReset
(
)
&
&
!
primarySampleQueue
.
isEmpty
(
)
)
;
}
Override
public
void
maybeThrowError
(
)
throws
IOException
{
loader
.
maybeThrowError
(
)
;
if
(
!
loader
.
isLoading
(
)
)
{
chunkSource
.
maybeThrowError
(
)
;
}
}
Override
public
int
readData
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
)
{
if
(
isPendingReset
(
)
)
{
return
C
.
RESULT_NOTHING_READ
;
}
discardDownstreamMediaChunks
(
primarySampleQueue
.
getReadIndex
(
)
)
;
return
primarySampleQueue
.
readData
(
formatHolder
buffer
formatRequired
loadingFinished
lastSeekPositionUs
)
;
}
Override
public
void
skipData
(
long
positionUs
)
{
if
(
loadingFinished
&
&
positionUs
>
primarySampleQueue
.
getLargestQueuedTimestampUs
(
)
)
{
primarySampleQueue
.
skipAll
(
)
;
}
else
{
primarySampleQueue
.
skipToKeyframeBefore
(
positionUs
true
)
;
}
}
Override
public
void
onLoadCompleted
(
Chunk
loadable
long
elapsedRealtimeMs
long
loadDurationMs
)
{
chunkSource
.
onChunkLoadCompleted
(
loadable
)
;
eventDispatcher
.
loadCompleted
(
loadable
.
dataSpec
loadable
.
type
primaryTrackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
loadDurationMs
loadable
.
bytesLoaded
(
)
)
;
callback
.
onContinueLoadingRequested
(
this
)
;
}
Override
public
void
onLoadCanceled
(
Chunk
loadable
long
elapsedRealtimeMs
long
loadDurationMs
boolean
released
)
{
eventDispatcher
.
loadCanceled
(
loadable
.
dataSpec
loadable
.
type
primaryTrackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
loadDurationMs
loadable
.
bytesLoaded
(
)
)
;
if
(
!
released
)
{
primarySampleQueue
.
reset
(
true
)
;
for
(
DefaultTrackOutput
embeddedSampleQueue
:
embeddedSampleQueues
)
{
embeddedSampleQueue
.
reset
(
true
)
;
}
callback
.
onContinueLoadingRequested
(
this
)
;
}
}
Override
public
int
onLoadError
(
Chunk
loadable
long
elapsedRealtimeMs
long
loadDurationMs
IOException
error
)
{
long
bytesLoaded
=
loadable
.
bytesLoaded
(
)
;
boolean
isMediaChunk
=
isMediaChunk
(
loadable
)
;
boolean
cancelable
=
!
isMediaChunk
|
|
bytesLoaded
=
=
0
|
|
mediaChunks
.
size
(
)
>
1
;
boolean
canceled
=
false
;
if
(
chunkSource
.
onChunkLoadError
(
loadable
cancelable
error
)
)
{
canceled
=
true
;
if
(
isMediaChunk
)
{
BaseMediaChunk
removed
=
mediaChunks
.
removeLast
(
)
;
Assertions
.
checkState
(
removed
=
=
loadable
)
;
primarySampleQueue
.
discardUpstreamSamples
(
removed
.
getFirstSampleIndex
(
0
)
)
;
for
(
int
i
=
0
;
i
<
embeddedSampleQueues
.
length
;
i
+
+
)
{
embeddedSampleQueues
[
i
]
.
discardUpstreamSamples
(
removed
.
getFirstSampleIndex
(
i
+
1
)
)
;
}
if
(
mediaChunks
.
isEmpty
(
)
)
{
pendingResetPositionUs
=
lastSeekPositionUs
;
}
}
}
eventDispatcher
.
loadError
(
loadable
.
dataSpec
loadable
.
type
primaryTrackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
loadDurationMs
bytesLoaded
error
canceled
)
;
if
(
canceled
)
{
callback
.
onContinueLoadingRequested
(
this
)
;
return
Loader
.
DONT_RETRY
;
}
else
{
return
Loader
.
RETRY
;
}
}
Override
public
boolean
continueLoading
(
long
positionUs
)
{
if
(
loadingFinished
|
|
loader
.
isLoading
(
)
)
{
return
false
;
}
chunkSource
.
getNextChunk
(
mediaChunks
.
isEmpty
(
)
?
null
:
mediaChunks
.
getLast
(
)
pendingResetPositionUs
!
=
C
.
TIME_UNSET
?
pendingResetPositionUs
:
positionUs
nextChunkHolder
)
;
boolean
endOfStream
=
nextChunkHolder
.
endOfStream
;
Chunk
loadable
=
nextChunkHolder
.
chunk
;
nextChunkHolder
.
clear
(
)
;
if
(
endOfStream
)
{
loadingFinished
=
true
;
return
true
;
}
if
(
loadable
=
=
null
)
{
return
false
;
}
if
(
isMediaChunk
(
loadable
)
)
{
pendingResetPositionUs
=
C
.
TIME_UNSET
;
BaseMediaChunk
mediaChunk
=
(
BaseMediaChunk
)
loadable
;
mediaChunk
.
init
(
mediaChunkOutput
)
;
mediaChunks
.
add
(
mediaChunk
)
;
}
long
elapsedRealtimeMs
=
loader
.
startLoading
(
loadable
this
minLoadableRetryCount
)
;
eventDispatcher
.
loadStarted
(
loadable
.
dataSpec
loadable
.
type
primaryTrackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
)
;
return
true
;
}
Override
public
long
getNextLoadPositionUs
(
)
{
if
(
isPendingReset
(
)
)
{
return
pendingResetPositionUs
;
}
else
{
return
loadingFinished
?
C
.
TIME_END_OF_SOURCE
:
mediaChunks
.
getLast
(
)
.
endTimeUs
;
}
}
private
void
maybeDiscardUpstream
(
long
positionUs
)
{
int
queueSize
=
chunkSource
.
getPreferredQueueSize
(
positionUs
readOnlyMediaChunks
)
;
discardUpstreamMediaChunks
(
Math
.
max
(
1
queueSize
)
)
;
}
private
boolean
isMediaChunk
(
Chunk
chunk
)
{
return
chunk
instanceof
BaseMediaChunk
;
}
boolean
isPendingReset
(
)
{
return
pendingResetPositionUs
!
=
C
.
TIME_UNSET
;
}
private
void
discardDownstreamMediaChunks
(
int
primaryStreamReadIndex
)
{
while
(
mediaChunks
.
size
(
)
>
1
&
&
mediaChunks
.
get
(
1
)
.
getFirstSampleIndex
(
0
)
<
=
primaryStreamReadIndex
)
{
mediaChunks
.
removeFirst
(
)
;
}
BaseMediaChunk
currentChunk
=
mediaChunks
.
getFirst
(
)
;
Format
trackFormat
=
currentChunk
.
trackFormat
;
if
(
!
trackFormat
.
equals
(
primaryDownstreamTrackFormat
)
)
{
eventDispatcher
.
downstreamFormatChanged
(
primaryTrackType
trackFormat
currentChunk
.
trackSelectionReason
currentChunk
.
trackSelectionData
currentChunk
.
startTimeUs
)
;
}
primaryDownstreamTrackFormat
=
trackFormat
;
}
private
boolean
discardUpstreamMediaChunks
(
int
queueLength
)
{
if
(
mediaChunks
.
size
(
)
<
=
queueLength
)
{
return
false
;
}
long
startTimeUs
=
0
;
long
endTimeUs
=
mediaChunks
.
getLast
(
)
.
endTimeUs
;
BaseMediaChunk
removed
=
null
;
while
(
mediaChunks
.
size
(
)
>
queueLength
)
{
removed
=
mediaChunks
.
removeLast
(
)
;
startTimeUs
=
removed
.
startTimeUs
;
loadingFinished
=
false
;
}
primarySampleQueue
.
discardUpstreamSamples
(
removed
.
getFirstSampleIndex
(
0
)
)
;
for
(
int
i
=
0
;
i
<
embeddedSampleQueues
.
length
;
i
+
+
)
{
embeddedSampleQueues
[
i
]
.
discardUpstreamSamples
(
removed
.
getFirstSampleIndex
(
i
+
1
)
)
;
}
eventDispatcher
.
upstreamDiscarded
(
primaryTrackType
startTimeUs
endTimeUs
)
;
return
true
;
}
public
final
class
EmbeddedSampleStream
implements
SampleStream
{
public
final
ChunkSampleStream
<
T
>
parent
;
private
final
DefaultTrackOutput
sampleQueue
;
private
final
int
index
;
public
EmbeddedSampleStream
(
ChunkSampleStream
<
T
>
parent
DefaultTrackOutput
sampleQueue
int
index
)
{
this
.
parent
=
parent
;
this
.
sampleQueue
=
sampleQueue
;
this
.
index
=
index
;
}
Override
public
boolean
isReady
(
)
{
return
loadingFinished
|
|
(
!
isPendingReset
(
)
&
&
!
sampleQueue
.
isEmpty
(
)
)
;
}
Override
public
void
skipData
(
long
positionUs
)
{
if
(
loadingFinished
&
&
positionUs
>
sampleQueue
.
getLargestQueuedTimestampUs
(
)
)
{
sampleQueue
.
skipAll
(
)
;
}
else
{
sampleQueue
.
skipToKeyframeBefore
(
positionUs
true
)
;
}
}
Override
public
void
maybeThrowError
(
)
throws
IOException
{
}
Override
public
int
readData
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
)
{
if
(
isPendingReset
(
)
)
{
return
C
.
RESULT_NOTHING_READ
;
}
return
sampleQueue
.
readData
(
formatHolder
buffer
formatRequired
loadingFinished
lastSeekPositionUs
)
;
}
public
void
release
(
)
{
Assertions
.
checkState
(
embeddedTracksSelected
[
index
]
)
;
embeddedTracksSelected
[
index
]
=
false
;
}
}
}
