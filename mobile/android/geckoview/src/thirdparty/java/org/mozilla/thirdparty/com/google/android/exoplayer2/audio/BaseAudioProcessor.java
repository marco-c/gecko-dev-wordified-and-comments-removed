package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
androidx
.
annotation
.
CallSuper
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
ByteOrder
;
public
abstract
class
BaseAudioProcessor
implements
AudioProcessor
{
protected
AudioFormat
inputAudioFormat
;
protected
AudioFormat
outputAudioFormat
;
private
AudioFormat
pendingInputAudioFormat
;
private
AudioFormat
pendingOutputAudioFormat
;
private
ByteBuffer
buffer
;
private
ByteBuffer
outputBuffer
;
private
boolean
inputEnded
;
public
BaseAudioProcessor
(
)
{
buffer
=
EMPTY_BUFFER
;
outputBuffer
=
EMPTY_BUFFER
;
pendingInputAudioFormat
=
AudioFormat
.
NOT_SET
;
pendingOutputAudioFormat
=
AudioFormat
.
NOT_SET
;
inputAudioFormat
=
AudioFormat
.
NOT_SET
;
outputAudioFormat
=
AudioFormat
.
NOT_SET
;
}
Override
public
final
AudioFormat
configure
(
AudioFormat
inputAudioFormat
)
throws
UnhandledAudioFormatException
{
pendingInputAudioFormat
=
inputAudioFormat
;
pendingOutputAudioFormat
=
onConfigure
(
inputAudioFormat
)
;
return
isActive
(
)
?
pendingOutputAudioFormat
:
AudioFormat
.
NOT_SET
;
}
Override
public
boolean
isActive
(
)
{
return
pendingOutputAudioFormat
!
=
AudioFormat
.
NOT_SET
;
}
Override
public
final
void
queueEndOfStream
(
)
{
inputEnded
=
true
;
onQueueEndOfStream
(
)
;
}
CallSuper
Override
public
ByteBuffer
getOutput
(
)
{
ByteBuffer
outputBuffer
=
this
.
outputBuffer
;
this
.
outputBuffer
=
EMPTY_BUFFER
;
return
outputBuffer
;
}
CallSuper
SuppressWarnings
(
"
ReferenceEquality
"
)
Override
public
boolean
isEnded
(
)
{
return
inputEnded
&
&
outputBuffer
=
=
EMPTY_BUFFER
;
}
Override
public
final
void
flush
(
)
{
outputBuffer
=
EMPTY_BUFFER
;
inputEnded
=
false
;
inputAudioFormat
=
pendingInputAudioFormat
;
outputAudioFormat
=
pendingOutputAudioFormat
;
onFlush
(
)
;
}
Override
public
final
void
reset
(
)
{
flush
(
)
;
buffer
=
EMPTY_BUFFER
;
pendingInputAudioFormat
=
AudioFormat
.
NOT_SET
;
pendingOutputAudioFormat
=
AudioFormat
.
NOT_SET
;
inputAudioFormat
=
AudioFormat
.
NOT_SET
;
outputAudioFormat
=
AudioFormat
.
NOT_SET
;
onReset
(
)
;
}
protected
final
ByteBuffer
replaceOutputBuffer
(
int
count
)
{
if
(
buffer
.
capacity
(
)
<
count
)
{
buffer
=
ByteBuffer
.
allocateDirect
(
count
)
.
order
(
ByteOrder
.
nativeOrder
(
)
)
;
}
else
{
buffer
.
clear
(
)
;
}
outputBuffer
=
buffer
;
return
buffer
;
}
protected
final
boolean
hasPendingOutput
(
)
{
return
outputBuffer
.
hasRemaining
(
)
;
}
protected
AudioFormat
onConfigure
(
AudioFormat
inputAudioFormat
)
throws
UnhandledAudioFormatException
{
return
AudioFormat
.
NOT_SET
;
}
protected
void
onQueueEndOfStream
(
)
{
}
protected
void
onFlush
(
)
{
}
protected
void
onReset
(
)
{
}
}
