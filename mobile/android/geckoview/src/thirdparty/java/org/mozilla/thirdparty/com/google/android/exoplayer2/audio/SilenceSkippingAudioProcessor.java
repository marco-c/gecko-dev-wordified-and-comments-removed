package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
androidx
.
annotation
.
IntDef
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
nio
.
ByteBuffer
;
public
final
class
SilenceSkippingAudioProcessor
extends
BaseAudioProcessor
{
private
static
final
long
MINIMUM_SILENCE_DURATION_US
=
150_000
;
private
static
final
long
PADDING_SILENCE_US
=
20_000
;
private
static
final
short
SILENCE_THRESHOLD_LEVEL
=
1024
;
private
static
final
byte
SILENCE_THRESHOLD_LEVEL_MSB
=
(
SILENCE_THRESHOLD_LEVEL
+
128
)
>
>
8
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
STATE_NOISY
STATE_MAYBE_SILENT
STATE_SILENT
}
)
private
interface
State
{
}
private
static
final
int
STATE_NOISY
=
0
;
private
static
final
int
STATE_MAYBE_SILENT
=
1
;
private
static
final
int
STATE_SILENT
=
2
;
private
int
bytesPerFrame
;
private
boolean
enabled
;
private
byte
[
]
maybeSilenceBuffer
;
private
byte
[
]
paddingBuffer
;
State
private
int
state
;
private
int
maybeSilenceBufferSize
;
private
int
paddingSize
;
private
boolean
hasOutputNoise
;
private
long
skippedFrames
;
public
SilenceSkippingAudioProcessor
(
)
{
maybeSilenceBuffer
=
Util
.
EMPTY_BYTE_ARRAY
;
paddingBuffer
=
Util
.
EMPTY_BYTE_ARRAY
;
}
public
void
setEnabled
(
boolean
enabled
)
{
this
.
enabled
=
enabled
;
}
public
long
getSkippedFrames
(
)
{
return
skippedFrames
;
}
Override
public
AudioFormat
onConfigure
(
AudioFormat
inputAudioFormat
)
throws
UnhandledAudioFormatException
{
if
(
inputAudioFormat
.
encoding
!
=
C
.
ENCODING_PCM_16BIT
)
{
throw
new
UnhandledAudioFormatException
(
inputAudioFormat
)
;
}
return
enabled
?
inputAudioFormat
:
AudioFormat
.
NOT_SET
;
}
Override
public
boolean
isActive
(
)
{
return
enabled
;
}
Override
public
void
queueInput
(
ByteBuffer
inputBuffer
)
{
while
(
inputBuffer
.
hasRemaining
(
)
&
&
!
hasPendingOutput
(
)
)
{
switch
(
state
)
{
case
STATE_NOISY
:
processNoisy
(
inputBuffer
)
;
break
;
case
STATE_MAYBE_SILENT
:
processMaybeSilence
(
inputBuffer
)
;
break
;
case
STATE_SILENT
:
processSilence
(
inputBuffer
)
;
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
}
Override
protected
void
onQueueEndOfStream
(
)
{
if
(
maybeSilenceBufferSize
>
0
)
{
output
(
maybeSilenceBuffer
maybeSilenceBufferSize
)
;
}
if
(
!
hasOutputNoise
)
{
skippedFrames
+
=
paddingSize
/
bytesPerFrame
;
}
}
Override
protected
void
onFlush
(
)
{
if
(
enabled
)
{
bytesPerFrame
=
inputAudioFormat
.
bytesPerFrame
;
int
maybeSilenceBufferSize
=
durationUsToFrames
(
MINIMUM_SILENCE_DURATION_US
)
*
bytesPerFrame
;
if
(
maybeSilenceBuffer
.
length
!
=
maybeSilenceBufferSize
)
{
maybeSilenceBuffer
=
new
byte
[
maybeSilenceBufferSize
]
;
}
paddingSize
=
durationUsToFrames
(
PADDING_SILENCE_US
)
*
bytesPerFrame
;
if
(
paddingBuffer
.
length
!
=
paddingSize
)
{
paddingBuffer
=
new
byte
[
paddingSize
]
;
}
}
state
=
STATE_NOISY
;
skippedFrames
=
0
;
maybeSilenceBufferSize
=
0
;
hasOutputNoise
=
false
;
}
Override
protected
void
onReset
(
)
{
enabled
=
false
;
paddingSize
=
0
;
maybeSilenceBuffer
=
Util
.
EMPTY_BYTE_ARRAY
;
paddingBuffer
=
Util
.
EMPTY_BYTE_ARRAY
;
}
private
void
processNoisy
(
ByteBuffer
inputBuffer
)
{
int
limit
=
inputBuffer
.
limit
(
)
;
inputBuffer
.
limit
(
Math
.
min
(
limit
inputBuffer
.
position
(
)
+
maybeSilenceBuffer
.
length
)
)
;
int
noiseLimit
=
findNoiseLimit
(
inputBuffer
)
;
if
(
noiseLimit
=
=
inputBuffer
.
position
(
)
)
{
state
=
STATE_MAYBE_SILENT
;
}
else
{
inputBuffer
.
limit
(
noiseLimit
)
;
output
(
inputBuffer
)
;
}
inputBuffer
.
limit
(
limit
)
;
}
private
void
processMaybeSilence
(
ByteBuffer
inputBuffer
)
{
int
limit
=
inputBuffer
.
limit
(
)
;
int
noisePosition
=
findNoisePosition
(
inputBuffer
)
;
int
maybeSilenceInputSize
=
noisePosition
-
inputBuffer
.
position
(
)
;
int
maybeSilenceBufferRemaining
=
maybeSilenceBuffer
.
length
-
maybeSilenceBufferSize
;
if
(
noisePosition
<
limit
&
&
maybeSilenceInputSize
<
maybeSilenceBufferRemaining
)
{
output
(
maybeSilenceBuffer
maybeSilenceBufferSize
)
;
maybeSilenceBufferSize
=
0
;
state
=
STATE_NOISY
;
}
else
{
int
bytesToWrite
=
Math
.
min
(
maybeSilenceInputSize
maybeSilenceBufferRemaining
)
;
inputBuffer
.
limit
(
inputBuffer
.
position
(
)
+
bytesToWrite
)
;
inputBuffer
.
get
(
maybeSilenceBuffer
maybeSilenceBufferSize
bytesToWrite
)
;
maybeSilenceBufferSize
+
=
bytesToWrite
;
if
(
maybeSilenceBufferSize
=
=
maybeSilenceBuffer
.
length
)
{
if
(
hasOutputNoise
)
{
output
(
maybeSilenceBuffer
paddingSize
)
;
skippedFrames
+
=
(
maybeSilenceBufferSize
-
paddingSize
*
2
)
/
bytesPerFrame
;
}
else
{
skippedFrames
+
=
(
maybeSilenceBufferSize
-
paddingSize
)
/
bytesPerFrame
;
}
updatePaddingBuffer
(
inputBuffer
maybeSilenceBuffer
maybeSilenceBufferSize
)
;
maybeSilenceBufferSize
=
0
;
state
=
STATE_SILENT
;
}
inputBuffer
.
limit
(
limit
)
;
}
}
private
void
processSilence
(
ByteBuffer
inputBuffer
)
{
int
limit
=
inputBuffer
.
limit
(
)
;
int
noisyPosition
=
findNoisePosition
(
inputBuffer
)
;
inputBuffer
.
limit
(
noisyPosition
)
;
skippedFrames
+
=
inputBuffer
.
remaining
(
)
/
bytesPerFrame
;
updatePaddingBuffer
(
inputBuffer
paddingBuffer
paddingSize
)
;
if
(
noisyPosition
<
limit
)
{
output
(
paddingBuffer
paddingSize
)
;
state
=
STATE_NOISY
;
inputBuffer
.
limit
(
limit
)
;
}
}
private
void
output
(
byte
[
]
data
int
length
)
{
replaceOutputBuffer
(
length
)
.
put
(
data
0
length
)
.
flip
(
)
;
if
(
length
>
0
)
{
hasOutputNoise
=
true
;
}
}
private
void
output
(
ByteBuffer
data
)
{
int
length
=
data
.
remaining
(
)
;
replaceOutputBuffer
(
length
)
.
put
(
data
)
.
flip
(
)
;
if
(
length
>
0
)
{
hasOutputNoise
=
true
;
}
}
private
void
updatePaddingBuffer
(
ByteBuffer
input
byte
[
]
buffer
int
size
)
{
int
fromInputSize
=
Math
.
min
(
input
.
remaining
(
)
paddingSize
)
;
int
fromBufferSize
=
paddingSize
-
fromInputSize
;
System
.
arraycopy
(
buffer
size
-
fromBufferSize
paddingBuffer
0
fromBufferSize
)
;
input
.
position
(
input
.
limit
(
)
-
fromInputSize
)
;
input
.
get
(
paddingBuffer
fromBufferSize
fromInputSize
)
;
}
private
int
durationUsToFrames
(
long
durationUs
)
{
return
(
int
)
(
(
durationUs
*
inputAudioFormat
.
sampleRate
)
/
C
.
MICROS_PER_SECOND
)
;
}
private
int
findNoisePosition
(
ByteBuffer
buffer
)
{
for
(
int
i
=
buffer
.
position
(
)
+
1
;
i
<
buffer
.
limit
(
)
;
i
+
=
2
)
{
if
(
Math
.
abs
(
buffer
.
get
(
i
)
)
>
SILENCE_THRESHOLD_LEVEL_MSB
)
{
return
bytesPerFrame
*
(
i
/
bytesPerFrame
)
;
}
}
return
buffer
.
limit
(
)
;
}
private
int
findNoiseLimit
(
ByteBuffer
buffer
)
{
for
(
int
i
=
buffer
.
limit
(
)
-
1
;
i
>
=
buffer
.
position
(
)
;
i
-
=
2
)
{
if
(
Math
.
abs
(
buffer
.
get
(
i
)
)
>
SILENCE_THRESHOLD_LEVEL_MSB
)
{
return
bytesPerFrame
*
(
i
/
bytesPerFrame
)
+
bytesPerFrame
;
}
}
return
buffer
.
position
(
)
;
}
}
