package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
;
import
android
.
text
.
TextUtils
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
webvtt
.
WebvttParserUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
MonotonicNonNull
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
RequiresNonNull
;
public
final
class
WebvttExtractor
implements
Extractor
{
private
static
final
Pattern
LOCAL_TIMESTAMP
=
Pattern
.
compile
(
"
LOCAL
:
(
[
^
]
+
)
"
)
;
private
static
final
Pattern
MEDIA_TIMESTAMP
=
Pattern
.
compile
(
"
MPEGTS
:
(
-
?
\
\
d
+
)
"
)
;
private
static
final
int
HEADER_MIN_LENGTH
=
6
;
private
static
final
int
HEADER_MAX_LENGTH
=
3
+
HEADER_MIN_LENGTH
;
Nullable
private
final
String
language
;
private
final
TimestampAdjuster
timestampAdjuster
;
private
final
ParsableByteArray
sampleDataWrapper
;
private
MonotonicNonNull
ExtractorOutput
output
;
private
byte
[
]
sampleData
;
private
int
sampleSize
;
public
WebvttExtractor
(
Nullable
String
language
TimestampAdjuster
timestampAdjuster
)
{
this
.
language
=
language
;
this
.
timestampAdjuster
=
timestampAdjuster
;
this
.
sampleDataWrapper
=
new
ParsableByteArray
(
)
;
sampleData
=
new
byte
[
1024
]
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
input
.
peekFully
(
sampleData
0
HEADER_MIN_LENGTH
false
)
;
sampleDataWrapper
.
reset
(
sampleData
HEADER_MIN_LENGTH
)
;
if
(
WebvttParserUtil
.
isWebvttHeaderLine
(
sampleDataWrapper
)
)
{
return
true
;
}
input
.
peekFully
(
sampleData
HEADER_MIN_LENGTH
HEADER_MAX_LENGTH
-
HEADER_MIN_LENGTH
false
)
;
sampleDataWrapper
.
reset
(
sampleData
HEADER_MAX_LENGTH
)
;
return
WebvttParserUtil
.
isWebvttHeaderLine
(
sampleDataWrapper
)
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
this
.
output
=
output
;
output
.
seekMap
(
new
SeekMap
.
Unseekable
(
C
.
TIME_UNSET
)
)
;
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
throw
new
IllegalStateException
(
)
;
}
Override
public
void
release
(
)
{
}
Override
public
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
Assertions
.
checkNotNull
(
output
)
;
int
currentFileSize
=
(
int
)
input
.
getLength
(
)
;
if
(
sampleSize
=
=
sampleData
.
length
)
{
sampleData
=
Arrays
.
copyOf
(
sampleData
(
currentFileSize
!
=
C
.
LENGTH_UNSET
?
currentFileSize
:
sampleData
.
length
)
*
3
/
2
)
;
}
int
bytesRead
=
input
.
read
(
sampleData
sampleSize
sampleData
.
length
-
sampleSize
)
;
if
(
bytesRead
!
=
C
.
RESULT_END_OF_INPUT
)
{
sampleSize
+
=
bytesRead
;
if
(
currentFileSize
=
=
C
.
LENGTH_UNSET
|
|
sampleSize
!
=
currentFileSize
)
{
return
Extractor
.
RESULT_CONTINUE
;
}
}
processSample
(
)
;
return
Extractor
.
RESULT_END_OF_INPUT
;
}
RequiresNonNull
(
"
output
"
)
private
void
processSample
(
)
throws
ParserException
{
ParsableByteArray
webvttData
=
new
ParsableByteArray
(
sampleData
)
;
WebvttParserUtil
.
validateWebvttHeaderLine
(
webvttData
)
;
long
vttTimestampUs
=
0
;
long
tsTimestampUs
=
0
;
for
(
String
line
=
webvttData
.
readLine
(
)
;
!
TextUtils
.
isEmpty
(
line
)
;
line
=
webvttData
.
readLine
(
)
)
{
if
(
line
.
startsWith
(
"
X
-
TIMESTAMP
-
MAP
"
)
)
{
Matcher
localTimestampMatcher
=
LOCAL_TIMESTAMP
.
matcher
(
line
)
;
if
(
!
localTimestampMatcher
.
find
(
)
)
{
throw
new
ParserException
(
"
X
-
TIMESTAMP
-
MAP
doesn
'
t
contain
local
timestamp
:
"
+
line
)
;
}
Matcher
mediaTimestampMatcher
=
MEDIA_TIMESTAMP
.
matcher
(
line
)
;
if
(
!
mediaTimestampMatcher
.
find
(
)
)
{
throw
new
ParserException
(
"
X
-
TIMESTAMP
-
MAP
doesn
'
t
contain
media
timestamp
:
"
+
line
)
;
}
vttTimestampUs
=
WebvttParserUtil
.
parseTimestampUs
(
localTimestampMatcher
.
group
(
1
)
)
;
tsTimestampUs
=
TimestampAdjuster
.
ptsToUs
(
Long
.
parseLong
(
mediaTimestampMatcher
.
group
(
1
)
)
)
;
}
}
Matcher
cueHeaderMatcher
=
WebvttParserUtil
.
findNextCueHeader
(
webvttData
)
;
if
(
cueHeaderMatcher
=
=
null
)
{
buildTrackOutput
(
0
)
;
return
;
}
long
firstCueTimeUs
=
WebvttParserUtil
.
parseTimestampUs
(
cueHeaderMatcher
.
group
(
1
)
)
;
long
sampleTimeUs
=
timestampAdjuster
.
adjustTsTimestamp
(
TimestampAdjuster
.
usToPts
(
firstCueTimeUs
+
tsTimestampUs
-
vttTimestampUs
)
)
;
long
subsampleOffsetUs
=
sampleTimeUs
-
firstCueTimeUs
;
TrackOutput
trackOutput
=
buildTrackOutput
(
subsampleOffsetUs
)
;
sampleDataWrapper
.
reset
(
sampleData
sampleSize
)
;
trackOutput
.
sampleData
(
sampleDataWrapper
sampleSize
)
;
trackOutput
.
sampleMetadata
(
sampleTimeUs
C
.
BUFFER_FLAG_KEY_FRAME
sampleSize
0
null
)
;
}
RequiresNonNull
(
"
output
"
)
private
TrackOutput
buildTrackOutput
(
long
subsampleOffsetUs
)
{
TrackOutput
trackOutput
=
output
.
track
(
0
C
.
TRACK_TYPE_TEXT
)
;
trackOutput
.
format
(
Format
.
createTextSampleFormat
(
null
MimeTypes
.
TEXT_VTT
null
Format
.
NO_VALUE
0
language
null
subsampleOffsetUs
)
)
;
output
.
endTracks
(
)
;
return
trackOutput
;
}
}
