package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ogg
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
SuppressWarnings
(
"
UngroupedOverloads
"
)
abstract
class
StreamReader
{
private
static
final
int
STATE_READ_HEADERS
=
0
;
private
static
final
int
STATE_SKIP_HEADERS
=
1
;
private
static
final
int
STATE_READ_PAYLOAD
=
2
;
private
static
final
int
STATE_END_OF_INPUT
=
3
;
static
class
SetupData
{
Format
format
;
OggSeeker
oggSeeker
;
}
private
final
OggPacket
oggPacket
;
private
TrackOutput
trackOutput
;
private
ExtractorOutput
extractorOutput
;
private
OggSeeker
oggSeeker
;
private
long
targetGranule
;
private
long
payloadStartPosition
;
private
long
currentGranule
;
private
int
state
;
private
int
sampleRate
;
private
SetupData
setupData
;
private
long
lengthOfReadPacket
;
private
boolean
seekMapSet
;
private
boolean
formatSet
;
public
StreamReader
(
)
{
oggPacket
=
new
OggPacket
(
)
;
}
void
init
(
ExtractorOutput
output
TrackOutput
trackOutput
)
{
this
.
extractorOutput
=
output
;
this
.
trackOutput
=
trackOutput
;
reset
(
true
)
;
}
protected
void
reset
(
boolean
headerData
)
{
if
(
headerData
)
{
setupData
=
new
SetupData
(
)
;
payloadStartPosition
=
0
;
state
=
STATE_READ_HEADERS
;
}
else
{
state
=
STATE_SKIP_HEADERS
;
}
targetGranule
=
-
1
;
currentGranule
=
0
;
}
final
void
seek
(
long
position
long
timeUs
)
{
oggPacket
.
reset
(
)
;
if
(
position
=
=
0
)
{
reset
(
!
seekMapSet
)
;
}
else
{
if
(
state
!
=
STATE_READ_HEADERS
)
{
targetGranule
=
convertTimeToGranule
(
timeUs
)
;
oggSeeker
.
startSeek
(
targetGranule
)
;
state
=
STATE_READ_PAYLOAD
;
}
}
}
final
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
switch
(
state
)
{
case
STATE_READ_HEADERS
:
return
readHeaders
(
input
)
;
case
STATE_SKIP_HEADERS
:
input
.
skipFully
(
(
int
)
payloadStartPosition
)
;
state
=
STATE_READ_PAYLOAD
;
return
Extractor
.
RESULT_CONTINUE
;
case
STATE_READ_PAYLOAD
:
return
readPayload
(
input
seekPosition
)
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
private
int
readHeaders
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
boolean
readingHeaders
=
true
;
while
(
readingHeaders
)
{
if
(
!
oggPacket
.
populate
(
input
)
)
{
state
=
STATE_END_OF_INPUT
;
return
Extractor
.
RESULT_END_OF_INPUT
;
}
lengthOfReadPacket
=
input
.
getPosition
(
)
-
payloadStartPosition
;
readingHeaders
=
readHeaders
(
oggPacket
.
getPayload
(
)
payloadStartPosition
setupData
)
;
if
(
readingHeaders
)
{
payloadStartPosition
=
input
.
getPosition
(
)
;
}
}
sampleRate
=
setupData
.
format
.
sampleRate
;
if
(
!
formatSet
)
{
trackOutput
.
format
(
setupData
.
format
)
;
formatSet
=
true
;
}
if
(
setupData
.
oggSeeker
!
=
null
)
{
oggSeeker
=
setupData
.
oggSeeker
;
}
else
if
(
input
.
getLength
(
)
=
=
C
.
LENGTH_UNSET
)
{
oggSeeker
=
new
UnseekableOggSeeker
(
)
;
}
else
{
OggPageHeader
firstPayloadPageHeader
=
oggPacket
.
getPageHeader
(
)
;
boolean
isLastPage
=
(
firstPayloadPageHeader
.
type
&
0x04
)
!
=
0
;
oggSeeker
=
new
DefaultOggSeeker
(
this
payloadStartPosition
input
.
getLength
(
)
firstPayloadPageHeader
.
headerSize
+
firstPayloadPageHeader
.
bodySize
firstPayloadPageHeader
.
granulePosition
isLastPage
)
;
}
setupData
=
null
;
state
=
STATE_READ_PAYLOAD
;
oggPacket
.
trimPayload
(
)
;
return
Extractor
.
RESULT_CONTINUE
;
}
private
int
readPayload
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
long
position
=
oggSeeker
.
read
(
input
)
;
if
(
position
>
=
0
)
{
seekPosition
.
position
=
position
;
return
Extractor
.
RESULT_SEEK
;
}
else
if
(
position
<
-
1
)
{
onSeekEnd
(
-
(
position
+
2
)
)
;
}
if
(
!
seekMapSet
)
{
SeekMap
seekMap
=
oggSeeker
.
createSeekMap
(
)
;
extractorOutput
.
seekMap
(
seekMap
)
;
seekMapSet
=
true
;
}
if
(
lengthOfReadPacket
>
0
|
|
oggPacket
.
populate
(
input
)
)
{
lengthOfReadPacket
=
0
;
ParsableByteArray
payload
=
oggPacket
.
getPayload
(
)
;
long
granulesInPacket
=
preparePayload
(
payload
)
;
if
(
granulesInPacket
>
=
0
&
&
currentGranule
+
granulesInPacket
>
=
targetGranule
)
{
long
timeUs
=
convertGranuleToTime
(
currentGranule
)
;
trackOutput
.
sampleData
(
payload
payload
.
limit
(
)
)
;
trackOutput
.
sampleMetadata
(
timeUs
C
.
BUFFER_FLAG_KEY_FRAME
payload
.
limit
(
)
0
null
)
;
targetGranule
=
-
1
;
}
currentGranule
+
=
granulesInPacket
;
}
else
{
state
=
STATE_END_OF_INPUT
;
return
Extractor
.
RESULT_END_OF_INPUT
;
}
return
Extractor
.
RESULT_CONTINUE
;
}
protected
long
convertGranuleToTime
(
long
granule
)
{
return
(
granule
*
C
.
MICROS_PER_SECOND
)
/
sampleRate
;
}
protected
long
convertTimeToGranule
(
long
timeUs
)
{
return
(
sampleRate
*
timeUs
)
/
C
.
MICROS_PER_SECOND
;
}
protected
abstract
long
preparePayload
(
ParsableByteArray
packet
)
;
protected
abstract
boolean
readHeaders
(
ParsableByteArray
packet
long
position
SetupData
setupData
)
throws
IOException
InterruptedException
;
protected
void
onSeekEnd
(
long
currentGranule
)
{
this
.
currentGranule
=
currentGranule
;
}
private
static
final
class
UnseekableOggSeeker
implements
OggSeeker
{
Override
public
long
read
(
ExtractorInput
input
)
{
return
-
1
;
}
Override
public
void
startSeek
(
long
targetGranule
)
{
}
Override
public
SeekMap
createSeekMap
(
)
{
return
new
SeekMap
.
Unseekable
(
C
.
TIME_UNSET
)
;
}
}
}
