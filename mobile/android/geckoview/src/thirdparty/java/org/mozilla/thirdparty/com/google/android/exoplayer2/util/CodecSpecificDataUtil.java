package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
;
import
android
.
util
.
Pair
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ParserException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
public
final
class
CodecSpecificDataUtil
{
private
static
final
byte
[
]
NAL_START_CODE
=
new
byte
[
]
{
0
0
0
1
}
;
private
static
final
int
AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY
=
0xF
;
private
static
final
int
[
]
AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE
=
new
int
[
]
{
96000
88200
64000
48000
44100
32000
24000
22050
16000
12000
11025
8000
7350
}
;
private
static
final
int
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
=
-
1
;
private
static
final
int
[
]
AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE
=
new
int
[
]
{
0
1
2
3
4
5
6
8
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
7
8
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
8
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
}
;
private
static
final
int
AUDIO_OBJECT_TYPE_AAC_LC
=
2
;
private
static
final
int
AUDIO_OBJECT_TYPE_SBR
=
5
;
private
static
final
int
AUDIO_OBJECT_TYPE_ER_BSAC
=
22
;
private
static
final
int
AUDIO_OBJECT_TYPE_PS
=
29
;
private
static
final
int
AUDIO_OBJECT_TYPE_ESCAPE
=
31
;
private
CodecSpecificDataUtil
(
)
{
}
public
static
Pair
<
Integer
Integer
>
parseAacAudioSpecificConfig
(
byte
[
]
audioSpecificConfig
)
throws
ParserException
{
return
parseAacAudioSpecificConfig
(
new
ParsableBitArray
(
audioSpecificConfig
)
false
)
;
}
public
static
Pair
<
Integer
Integer
>
parseAacAudioSpecificConfig
(
ParsableBitArray
bitArray
boolean
forceReadToEnd
)
throws
ParserException
{
int
audioObjectType
=
getAacAudioObjectType
(
bitArray
)
;
int
sampleRate
=
getAacSamplingFrequency
(
bitArray
)
;
int
channelConfiguration
=
bitArray
.
readBits
(
4
)
;
if
(
audioObjectType
=
=
AUDIO_OBJECT_TYPE_SBR
|
|
audioObjectType
=
=
AUDIO_OBJECT_TYPE_PS
)
{
sampleRate
=
getAacSamplingFrequency
(
bitArray
)
;
audioObjectType
=
getAacAudioObjectType
(
bitArray
)
;
if
(
audioObjectType
=
=
AUDIO_OBJECT_TYPE_ER_BSAC
)
{
channelConfiguration
=
bitArray
.
readBits
(
4
)
;
}
}
if
(
forceReadToEnd
)
{
switch
(
audioObjectType
)
{
case
1
:
case
2
:
case
3
:
case
4
:
case
6
:
case
7
:
case
17
:
case
19
:
case
20
:
case
21
:
case
22
:
case
23
:
parseGaSpecificConfig
(
bitArray
audioObjectType
channelConfiguration
)
;
break
;
default
:
throw
new
ParserException
(
"
Unsupported
audio
object
type
:
"
+
audioObjectType
)
;
}
switch
(
audioObjectType
)
{
case
17
:
case
19
:
case
20
:
case
21
:
case
22
:
case
23
:
int
epConfig
=
bitArray
.
readBits
(
2
)
;
if
(
epConfig
=
=
2
|
|
epConfig
=
=
3
)
{
throw
new
ParserException
(
"
Unsupported
epConfig
:
"
+
epConfig
)
;
}
break
;
}
}
int
channelCount
=
AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE
[
channelConfiguration
]
;
Assertions
.
checkArgument
(
channelCount
!
=
AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
)
;
return
Pair
.
create
(
sampleRate
channelCount
)
;
}
public
static
byte
[
]
buildAacLcAudioSpecificConfig
(
int
sampleRate
int
channelCount
)
{
int
sampleRateIndex
=
C
.
INDEX_UNSET
;
for
(
int
i
=
0
;
i
<
AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE
.
length
;
+
+
i
)
{
if
(
sampleRate
=
=
AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE
[
i
]
)
{
sampleRateIndex
=
i
;
}
}
int
channelConfig
=
C
.
INDEX_UNSET
;
for
(
int
i
=
0
;
i
<
AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE
.
length
;
+
+
i
)
{
if
(
channelCount
=
=
AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE
[
i
]
)
{
channelConfig
=
i
;
}
}
if
(
sampleRate
=
=
C
.
INDEX_UNSET
|
|
channelConfig
=
=
C
.
INDEX_UNSET
)
{
throw
new
IllegalArgumentException
(
"
Invalid
sample
rate
or
number
of
channels
:
"
+
sampleRate
+
"
"
+
channelCount
)
;
}
return
buildAacAudioSpecificConfig
(
AUDIO_OBJECT_TYPE_AAC_LC
sampleRateIndex
channelConfig
)
;
}
public
static
byte
[
]
buildAacAudioSpecificConfig
(
int
audioObjectType
int
sampleRateIndex
int
channelConfig
)
{
byte
[
]
specificConfig
=
new
byte
[
2
]
;
specificConfig
[
0
]
=
(
byte
)
(
(
(
audioObjectType
<
<
3
)
&
0xF8
)
|
(
(
sampleRateIndex
>
>
1
)
&
0x07
)
)
;
specificConfig
[
1
]
=
(
byte
)
(
(
(
sampleRateIndex
<
<
7
)
&
0x80
)
|
(
(
channelConfig
<
<
3
)
&
0x78
)
)
;
return
specificConfig
;
}
public
static
Pair
<
Integer
Integer
>
parseAlacAudioSpecificConfig
(
byte
[
]
audioSpecificConfig
)
{
ParsableByteArray
byteArray
=
new
ParsableByteArray
(
audioSpecificConfig
)
;
byteArray
.
setPosition
(
9
)
;
int
channelCount
=
byteArray
.
readUnsignedByte
(
)
;
byteArray
.
setPosition
(
20
)
;
int
sampleRate
=
byteArray
.
readUnsignedIntToInt
(
)
;
return
Pair
.
create
(
sampleRate
channelCount
)
;
}
public
static
String
buildAvcCodecString
(
int
profileIdc
int
constraintsFlagsAndReservedZero2Bits
int
levelIdc
)
{
return
String
.
format
(
"
avc1
.
%
02X
%
02X
%
02X
"
profileIdc
constraintsFlagsAndReservedZero2Bits
levelIdc
)
;
}
public
static
byte
[
]
buildNalUnit
(
byte
[
]
data
int
offset
int
length
)
{
byte
[
]
nalUnit
=
new
byte
[
length
+
NAL_START_CODE
.
length
]
;
System
.
arraycopy
(
NAL_START_CODE
0
nalUnit
0
NAL_START_CODE
.
length
)
;
System
.
arraycopy
(
data
offset
nalUnit
NAL_START_CODE
.
length
length
)
;
return
nalUnit
;
}
public
static
Nullable
byte
[
]
[
]
splitNalUnits
(
byte
[
]
data
)
{
if
(
!
isNalStartCode
(
data
0
)
)
{
return
null
;
}
List
<
Integer
>
starts
=
new
ArrayList
<
>
(
)
;
int
nalUnitIndex
=
0
;
do
{
starts
.
add
(
nalUnitIndex
)
;
nalUnitIndex
=
findNalStartCode
(
data
nalUnitIndex
+
NAL_START_CODE
.
length
)
;
}
while
(
nalUnitIndex
!
=
C
.
INDEX_UNSET
)
;
byte
[
]
[
]
split
=
new
byte
[
starts
.
size
(
)
]
[
]
;
for
(
int
i
=
0
;
i
<
starts
.
size
(
)
;
i
+
+
)
{
int
startIndex
=
starts
.
get
(
i
)
;
int
endIndex
=
i
<
starts
.
size
(
)
-
1
?
starts
.
get
(
i
+
1
)
:
data
.
length
;
byte
[
]
nal
=
new
byte
[
endIndex
-
startIndex
]
;
System
.
arraycopy
(
data
startIndex
nal
0
nal
.
length
)
;
split
[
i
]
=
nal
;
}
return
split
;
}
private
static
int
findNalStartCode
(
byte
[
]
data
int
index
)
{
int
endIndex
=
data
.
length
-
NAL_START_CODE
.
length
;
for
(
int
i
=
index
;
i
<
=
endIndex
;
i
+
+
)
{
if
(
isNalStartCode
(
data
i
)
)
{
return
i
;
}
}
return
C
.
INDEX_UNSET
;
}
private
static
boolean
isNalStartCode
(
byte
[
]
data
int
index
)
{
if
(
data
.
length
-
index
<
=
NAL_START_CODE
.
length
)
{
return
false
;
}
for
(
int
j
=
0
;
j
<
NAL_START_CODE
.
length
;
j
+
+
)
{
if
(
data
[
index
+
j
]
!
=
NAL_START_CODE
[
j
]
)
{
return
false
;
}
}
return
true
;
}
private
static
int
getAacAudioObjectType
(
ParsableBitArray
bitArray
)
{
int
audioObjectType
=
bitArray
.
readBits
(
5
)
;
if
(
audioObjectType
=
=
AUDIO_OBJECT_TYPE_ESCAPE
)
{
audioObjectType
=
32
+
bitArray
.
readBits
(
6
)
;
}
return
audioObjectType
;
}
private
static
int
getAacSamplingFrequency
(
ParsableBitArray
bitArray
)
{
int
samplingFrequency
;
int
frequencyIndex
=
bitArray
.
readBits
(
4
)
;
if
(
frequencyIndex
=
=
AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY
)
{
samplingFrequency
=
bitArray
.
readBits
(
24
)
;
}
else
{
Assertions
.
checkArgument
(
frequencyIndex
<
13
)
;
samplingFrequency
=
AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE
[
frequencyIndex
]
;
}
return
samplingFrequency
;
}
private
static
void
parseGaSpecificConfig
(
ParsableBitArray
bitArray
int
audioObjectType
int
channelConfiguration
)
{
bitArray
.
skipBits
(
1
)
;
boolean
dependsOnCoreDecoder
=
bitArray
.
readBit
(
)
;
if
(
dependsOnCoreDecoder
)
{
bitArray
.
skipBits
(
14
)
;
}
boolean
extensionFlag
=
bitArray
.
readBit
(
)
;
if
(
channelConfiguration
=
=
0
)
{
throw
new
UnsupportedOperationException
(
)
;
}
if
(
audioObjectType
=
=
6
|
|
audioObjectType
=
=
20
)
{
bitArray
.
skipBits
(
3
)
;
}
if
(
extensionFlag
)
{
if
(
audioObjectType
=
=
22
)
{
bitArray
.
skipBits
(
16
)
;
}
if
(
audioObjectType
=
=
17
|
|
audioObjectType
=
=
19
|
|
audioObjectType
=
=
20
|
|
audioObjectType
=
=
23
)
{
bitArray
.
skipBits
(
3
)
;
}
bitArray
.
skipBits
(
1
)
;
}
}
}
