package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
;
import
android
.
net
.
Uri
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
java
.
io
.
IOException
;
import
java
.
net
.
DatagramPacket
;
import
java
.
net
.
DatagramSocket
;
import
java
.
net
.
InetAddress
;
import
java
.
net
.
InetSocketAddress
;
import
java
.
net
.
MulticastSocket
;
import
java
.
net
.
SocketException
;
public
final
class
UdpDataSource
implements
DataSource
{
public
static
final
class
UdpDataSourceException
extends
IOException
{
public
UdpDataSourceException
(
IOException
cause
)
{
super
(
cause
)
;
}
}
public
static
final
int
DEFAULT_MAX_PACKET_SIZE
=
2000
;
public
static
final
int
DEAFULT_SOCKET_TIMEOUT_MILLIS
=
8
*
1000
;
private
final
TransferListener
<
?
super
UdpDataSource
>
listener
;
private
final
int
socketTimeoutMillis
;
private
final
byte
[
]
packetBuffer
;
private
final
DatagramPacket
packet
;
private
Uri
uri
;
private
DatagramSocket
socket
;
private
MulticastSocket
multicastSocket
;
private
InetAddress
address
;
private
InetSocketAddress
socketAddress
;
private
boolean
opened
;
private
int
packetRemaining
;
public
UdpDataSource
(
TransferListener
<
?
super
UdpDataSource
>
listener
)
{
this
(
listener
DEFAULT_MAX_PACKET_SIZE
)
;
}
public
UdpDataSource
(
TransferListener
<
?
super
UdpDataSource
>
listener
int
maxPacketSize
)
{
this
(
listener
maxPacketSize
DEAFULT_SOCKET_TIMEOUT_MILLIS
)
;
}
public
UdpDataSource
(
TransferListener
<
?
super
UdpDataSource
>
listener
int
maxPacketSize
int
socketTimeoutMillis
)
{
this
.
listener
=
listener
;
this
.
socketTimeoutMillis
=
socketTimeoutMillis
;
packetBuffer
=
new
byte
[
maxPacketSize
]
;
packet
=
new
DatagramPacket
(
packetBuffer
0
maxPacketSize
)
;
}
Override
public
long
open
(
DataSpec
dataSpec
)
throws
UdpDataSourceException
{
uri
=
dataSpec
.
uri
;
String
host
=
uri
.
getHost
(
)
;
int
port
=
uri
.
getPort
(
)
;
try
{
address
=
InetAddress
.
getByName
(
host
)
;
socketAddress
=
new
InetSocketAddress
(
address
port
)
;
if
(
address
.
isMulticastAddress
(
)
)
{
multicastSocket
=
new
MulticastSocket
(
socketAddress
)
;
multicastSocket
.
joinGroup
(
address
)
;
socket
=
multicastSocket
;
}
else
{
socket
=
new
DatagramSocket
(
socketAddress
)
;
}
}
catch
(
IOException
e
)
{
throw
new
UdpDataSourceException
(
e
)
;
}
try
{
socket
.
setSoTimeout
(
socketTimeoutMillis
)
;
}
catch
(
SocketException
e
)
{
throw
new
UdpDataSourceException
(
e
)
;
}
opened
=
true
;
if
(
listener
!
=
null
)
{
listener
.
onTransferStart
(
this
dataSpec
)
;
}
return
C
.
LENGTH_UNSET
;
}
Override
public
int
read
(
byte
[
]
buffer
int
offset
int
readLength
)
throws
UdpDataSourceException
{
if
(
readLength
=
=
0
)
{
return
0
;
}
if
(
packetRemaining
=
=
0
)
{
try
{
socket
.
receive
(
packet
)
;
}
catch
(
IOException
e
)
{
throw
new
UdpDataSourceException
(
e
)
;
}
packetRemaining
=
packet
.
getLength
(
)
;
if
(
listener
!
=
null
)
{
listener
.
onBytesTransferred
(
this
packetRemaining
)
;
}
}
int
packetOffset
=
packet
.
getLength
(
)
-
packetRemaining
;
int
bytesToRead
=
Math
.
min
(
packetRemaining
readLength
)
;
System
.
arraycopy
(
packetBuffer
packetOffset
buffer
offset
bytesToRead
)
;
packetRemaining
-
=
bytesToRead
;
return
bytesToRead
;
}
Override
public
Uri
getUri
(
)
{
return
uri
;
}
Override
public
void
close
(
)
{
uri
=
null
;
if
(
multicastSocket
!
=
null
)
{
try
{
multicastSocket
.
leaveGroup
(
address
)
;
}
catch
(
IOException
e
)
{
}
multicastSocket
=
null
;
}
if
(
socket
!
=
null
)
{
socket
.
close
(
)
;
socket
=
null
;
}
address
=
null
;
socketAddress
=
null
;
packetRemaining
=
0
;
if
(
opened
)
{
opened
=
false
;
if
(
listener
!
=
null
)
{
listener
.
onTransferEnd
(
this
)
;
}
}
}
}
