package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
util
.
LinkedList
;
public
abstract
class
SimpleDecoder
<
I
extends
DecoderInputBuffer
O
extends
OutputBuffer
E
extends
Exception
>
implements
Decoder
<
I
O
E
>
{
private
final
Thread
decodeThread
;
private
final
Object
lock
;
private
final
LinkedList
<
I
>
queuedInputBuffers
;
private
final
LinkedList
<
O
>
queuedOutputBuffers
;
private
final
I
[
]
availableInputBuffers
;
private
final
O
[
]
availableOutputBuffers
;
private
int
availableInputBufferCount
;
private
int
availableOutputBufferCount
;
private
I
dequeuedInputBuffer
;
private
E
exception
;
private
boolean
flushed
;
private
boolean
released
;
private
int
skippedOutputBufferCount
;
protected
SimpleDecoder
(
I
[
]
inputBuffers
O
[
]
outputBuffers
)
{
lock
=
new
Object
(
)
;
queuedInputBuffers
=
new
LinkedList
<
>
(
)
;
queuedOutputBuffers
=
new
LinkedList
<
>
(
)
;
availableInputBuffers
=
inputBuffers
;
availableInputBufferCount
=
inputBuffers
.
length
;
for
(
int
i
=
0
;
i
<
availableInputBufferCount
;
i
+
+
)
{
availableInputBuffers
[
i
]
=
createInputBuffer
(
)
;
}
availableOutputBuffers
=
outputBuffers
;
availableOutputBufferCount
=
outputBuffers
.
length
;
for
(
int
i
=
0
;
i
<
availableOutputBufferCount
;
i
+
+
)
{
availableOutputBuffers
[
i
]
=
createOutputBuffer
(
)
;
}
decodeThread
=
new
Thread
(
)
{
Override
public
void
run
(
)
{
SimpleDecoder
.
this
.
run
(
)
;
}
}
;
decodeThread
.
start
(
)
;
}
protected
final
void
setInitialInputBufferSize
(
int
size
)
{
Assertions
.
checkState
(
availableInputBufferCount
=
=
availableInputBuffers
.
length
)
;
for
(
I
inputBuffer
:
availableInputBuffers
)
{
inputBuffer
.
ensureSpaceForWrite
(
size
)
;
}
}
Override
public
final
I
dequeueInputBuffer
(
)
throws
E
{
synchronized
(
lock
)
{
maybeThrowException
(
)
;
Assertions
.
checkState
(
dequeuedInputBuffer
=
=
null
)
;
dequeuedInputBuffer
=
availableInputBufferCount
=
=
0
?
null
:
availableInputBuffers
[
-
-
availableInputBufferCount
]
;
return
dequeuedInputBuffer
;
}
}
Override
public
final
void
queueInputBuffer
(
I
inputBuffer
)
throws
E
{
synchronized
(
lock
)
{
maybeThrowException
(
)
;
Assertions
.
checkArgument
(
inputBuffer
=
=
dequeuedInputBuffer
)
;
queuedInputBuffers
.
addLast
(
inputBuffer
)
;
maybeNotifyDecodeLoop
(
)
;
dequeuedInputBuffer
=
null
;
}
}
Override
public
final
O
dequeueOutputBuffer
(
)
throws
E
{
synchronized
(
lock
)
{
maybeThrowException
(
)
;
if
(
queuedOutputBuffers
.
isEmpty
(
)
)
{
return
null
;
}
return
queuedOutputBuffers
.
removeFirst
(
)
;
}
}
protected
void
releaseOutputBuffer
(
O
outputBuffer
)
{
synchronized
(
lock
)
{
releaseOutputBufferInternal
(
outputBuffer
)
;
maybeNotifyDecodeLoop
(
)
;
}
}
Override
public
final
void
flush
(
)
{
synchronized
(
lock
)
{
flushed
=
true
;
skippedOutputBufferCount
=
0
;
if
(
dequeuedInputBuffer
!
=
null
)
{
releaseInputBufferInternal
(
dequeuedInputBuffer
)
;
dequeuedInputBuffer
=
null
;
}
while
(
!
queuedInputBuffers
.
isEmpty
(
)
)
{
releaseInputBufferInternal
(
queuedInputBuffers
.
removeFirst
(
)
)
;
}
while
(
!
queuedOutputBuffers
.
isEmpty
(
)
)
{
releaseOutputBufferInternal
(
queuedOutputBuffers
.
removeFirst
(
)
)
;
}
}
}
Override
public
void
release
(
)
{
synchronized
(
lock
)
{
released
=
true
;
lock
.
notify
(
)
;
}
try
{
decodeThread
.
join
(
)
;
}
catch
(
InterruptedException
e
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
}
}
private
void
maybeThrowException
(
)
throws
E
{
if
(
exception
!
=
null
)
{
throw
exception
;
}
}
private
void
maybeNotifyDecodeLoop
(
)
{
if
(
canDecodeBuffer
(
)
)
{
lock
.
notify
(
)
;
}
}
private
void
run
(
)
{
try
{
while
(
decode
(
)
)
{
}
}
catch
(
InterruptedException
e
)
{
throw
new
IllegalStateException
(
e
)
;
}
}
private
boolean
decode
(
)
throws
InterruptedException
{
I
inputBuffer
;
O
outputBuffer
;
boolean
resetDecoder
;
synchronized
(
lock
)
{
while
(
!
released
&
&
!
canDecodeBuffer
(
)
)
{
lock
.
wait
(
)
;
}
if
(
released
)
{
return
false
;
}
inputBuffer
=
queuedInputBuffers
.
removeFirst
(
)
;
outputBuffer
=
availableOutputBuffers
[
-
-
availableOutputBufferCount
]
;
resetDecoder
=
flushed
;
flushed
=
false
;
}
if
(
inputBuffer
.
isEndOfStream
(
)
)
{
outputBuffer
.
addFlag
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
}
else
{
if
(
inputBuffer
.
isDecodeOnly
(
)
)
{
outputBuffer
.
addFlag
(
C
.
BUFFER_FLAG_DECODE_ONLY
)
;
}
exception
=
decode
(
inputBuffer
outputBuffer
resetDecoder
)
;
if
(
exception
!
=
null
)
{
synchronized
(
lock
)
{
}
return
false
;
}
}
synchronized
(
lock
)
{
if
(
flushed
)
{
releaseOutputBufferInternal
(
outputBuffer
)
;
}
else
if
(
outputBuffer
.
isDecodeOnly
(
)
)
{
skippedOutputBufferCount
+
+
;
releaseOutputBufferInternal
(
outputBuffer
)
;
}
else
{
outputBuffer
.
skippedOutputBufferCount
=
skippedOutputBufferCount
;
skippedOutputBufferCount
=
0
;
queuedOutputBuffers
.
addLast
(
outputBuffer
)
;
}
releaseInputBufferInternal
(
inputBuffer
)
;
}
return
true
;
}
private
boolean
canDecodeBuffer
(
)
{
return
!
queuedInputBuffers
.
isEmpty
(
)
&
&
availableOutputBufferCount
>
0
;
}
private
void
releaseInputBufferInternal
(
I
inputBuffer
)
{
inputBuffer
.
clear
(
)
;
availableInputBuffers
[
availableInputBufferCount
+
+
]
=
inputBuffer
;
}
private
void
releaseOutputBufferInternal
(
O
outputBuffer
)
{
outputBuffer
.
clear
(
)
;
availableOutputBuffers
[
availableOutputBufferCount
+
+
]
=
outputBuffer
;
}
protected
abstract
I
createInputBuffer
(
)
;
protected
abstract
O
createOutputBuffer
(
)
;
protected
abstract
E
decode
(
I
inputBuffer
O
outputBuffer
boolean
reset
)
;
}
