package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
cea
;
import
androidx
.
annotation
.
NonNull
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
Subtitle
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SubtitleDecoder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SubtitleDecoderException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SubtitleInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
text
.
SubtitleOutputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
util
.
ArrayDeque
;
import
java
.
util
.
PriorityQueue
;
abstract
class
CeaDecoder
implements
SubtitleDecoder
{
private
static
final
int
NUM_INPUT_BUFFERS
=
10
;
private
static
final
int
NUM_OUTPUT_BUFFERS
=
2
;
private
final
ArrayDeque
<
CeaInputBuffer
>
availableInputBuffers
;
private
final
ArrayDeque
<
SubtitleOutputBuffer
>
availableOutputBuffers
;
private
final
PriorityQueue
<
CeaInputBuffer
>
queuedInputBuffers
;
private
CeaInputBuffer
dequeuedInputBuffer
;
private
long
playbackPositionUs
;
private
long
queuedInputBufferCount
;
public
CeaDecoder
(
)
{
availableInputBuffers
=
new
ArrayDeque
<
>
(
)
;
for
(
int
i
=
0
;
i
<
NUM_INPUT_BUFFERS
;
i
+
+
)
{
availableInputBuffers
.
add
(
new
CeaInputBuffer
(
)
)
;
}
availableOutputBuffers
=
new
ArrayDeque
<
>
(
)
;
for
(
int
i
=
0
;
i
<
NUM_OUTPUT_BUFFERS
;
i
+
+
)
{
availableOutputBuffers
.
add
(
new
CeaOutputBuffer
(
)
)
;
}
queuedInputBuffers
=
new
PriorityQueue
<
>
(
)
;
}
Override
public
abstract
String
getName
(
)
;
Override
public
void
setPositionUs
(
long
positionUs
)
{
playbackPositionUs
=
positionUs
;
}
Override
public
SubtitleInputBuffer
dequeueInputBuffer
(
)
throws
SubtitleDecoderException
{
Assertions
.
checkState
(
dequeuedInputBuffer
=
=
null
)
;
if
(
availableInputBuffers
.
isEmpty
(
)
)
{
return
null
;
}
dequeuedInputBuffer
=
availableInputBuffers
.
pollFirst
(
)
;
return
dequeuedInputBuffer
;
}
Override
public
void
queueInputBuffer
(
SubtitleInputBuffer
inputBuffer
)
throws
SubtitleDecoderException
{
Assertions
.
checkArgument
(
inputBuffer
=
=
dequeuedInputBuffer
)
;
if
(
inputBuffer
.
isDecodeOnly
(
)
)
{
releaseInputBuffer
(
dequeuedInputBuffer
)
;
}
else
{
dequeuedInputBuffer
.
queuedInputBufferCount
=
queuedInputBufferCount
+
+
;
queuedInputBuffers
.
add
(
dequeuedInputBuffer
)
;
}
dequeuedInputBuffer
=
null
;
}
Override
public
SubtitleOutputBuffer
dequeueOutputBuffer
(
)
throws
SubtitleDecoderException
{
if
(
availableOutputBuffers
.
isEmpty
(
)
)
{
return
null
;
}
while
(
!
queuedInputBuffers
.
isEmpty
(
)
&
&
queuedInputBuffers
.
peek
(
)
.
timeUs
<
=
playbackPositionUs
)
{
CeaInputBuffer
inputBuffer
=
queuedInputBuffers
.
poll
(
)
;
if
(
inputBuffer
.
isEndOfStream
(
)
)
{
SubtitleOutputBuffer
outputBuffer
=
availableOutputBuffers
.
pollFirst
(
)
;
outputBuffer
.
addFlag
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
releaseInputBuffer
(
inputBuffer
)
;
return
outputBuffer
;
}
decode
(
inputBuffer
)
;
if
(
isNewSubtitleDataAvailable
(
)
)
{
Subtitle
subtitle
=
createSubtitle
(
)
;
if
(
!
inputBuffer
.
isDecodeOnly
(
)
)
{
SubtitleOutputBuffer
outputBuffer
=
availableOutputBuffers
.
pollFirst
(
)
;
outputBuffer
.
setContent
(
inputBuffer
.
timeUs
subtitle
Format
.
OFFSET_SAMPLE_RELATIVE
)
;
releaseInputBuffer
(
inputBuffer
)
;
return
outputBuffer
;
}
}
releaseInputBuffer
(
inputBuffer
)
;
}
return
null
;
}
private
void
releaseInputBuffer
(
CeaInputBuffer
inputBuffer
)
{
inputBuffer
.
clear
(
)
;
availableInputBuffers
.
add
(
inputBuffer
)
;
}
protected
void
releaseOutputBuffer
(
SubtitleOutputBuffer
outputBuffer
)
{
outputBuffer
.
clear
(
)
;
availableOutputBuffers
.
add
(
outputBuffer
)
;
}
Override
public
void
flush
(
)
{
queuedInputBufferCount
=
0
;
playbackPositionUs
=
0
;
while
(
!
queuedInputBuffers
.
isEmpty
(
)
)
{
releaseInputBuffer
(
queuedInputBuffers
.
poll
(
)
)
;
}
if
(
dequeuedInputBuffer
!
=
null
)
{
releaseInputBuffer
(
dequeuedInputBuffer
)
;
dequeuedInputBuffer
=
null
;
}
}
Override
public
void
release
(
)
{
}
protected
abstract
boolean
isNewSubtitleDataAvailable
(
)
;
protected
abstract
Subtitle
createSubtitle
(
)
;
protected
abstract
void
decode
(
SubtitleInputBuffer
inputBuffer
)
;
private
static
final
class
CeaInputBuffer
extends
SubtitleInputBuffer
implements
Comparable
<
CeaInputBuffer
>
{
private
long
queuedInputBufferCount
;
Override
public
int
compareTo
(
NonNull
CeaInputBuffer
other
)
{
if
(
isEndOfStream
(
)
!
=
other
.
isEndOfStream
(
)
)
{
return
isEndOfStream
(
)
?
1
:
-
1
;
}
long
delta
=
timeUs
-
other
.
timeUs
;
if
(
delta
=
=
0
)
{
delta
=
queuedInputBufferCount
-
other
.
queuedInputBufferCount
;
if
(
delta
=
=
0
)
{
return
0
;
}
}
return
delta
>
0
?
1
:
-
1
;
}
}
private
final
class
CeaOutputBuffer
extends
SubtitleOutputBuffer
{
Override
public
final
void
release
(
)
{
releaseOutputBuffer
(
this
)
;
}
}
}
