package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mkv
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
final
class
VarintReader
{
private
static
final
int
STATE_BEGIN_READING
=
0
;
private
static
final
int
STATE_READ_CONTENTS
=
1
;
private
static
final
long
[
]
VARINT_LENGTH_MASKS
=
new
long
[
]
{
0x80L
0x40L
0x20L
0x10L
0x08L
0x04L
0x02L
0x01L
}
;
private
final
byte
[
]
scratch
;
private
int
state
;
private
int
length
;
public
VarintReader
(
)
{
scratch
=
new
byte
[
8
]
;
}
public
void
reset
(
)
{
state
=
STATE_BEGIN_READING
;
length
=
0
;
}
public
long
readUnsignedVarint
(
ExtractorInput
input
boolean
allowEndOfInput
boolean
removeLengthMask
int
maximumAllowedLength
)
throws
IOException
InterruptedException
{
if
(
state
=
=
STATE_BEGIN_READING
)
{
if
(
!
input
.
readFully
(
scratch
0
1
allowEndOfInput
)
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
int
firstByte
=
scratch
[
0
]
&
0xFF
;
length
=
parseUnsignedVarintLength
(
firstByte
)
;
if
(
length
=
=
C
.
LENGTH_UNSET
)
{
throw
new
IllegalStateException
(
"
No
valid
varint
length
mask
found
"
)
;
}
state
=
STATE_READ_CONTENTS
;
}
if
(
length
>
maximumAllowedLength
)
{
state
=
STATE_BEGIN_READING
;
return
C
.
RESULT_MAX_LENGTH_EXCEEDED
;
}
if
(
length
!
=
1
)
{
input
.
readFully
(
scratch
1
length
-
1
)
;
}
state
=
STATE_BEGIN_READING
;
return
assembleVarint
(
scratch
length
removeLengthMask
)
;
}
public
int
getLastLength
(
)
{
return
length
;
}
public
static
int
parseUnsignedVarintLength
(
int
firstByte
)
{
int
varIntLength
=
C
.
LENGTH_UNSET
;
for
(
int
i
=
0
;
i
<
VARINT_LENGTH_MASKS
.
length
;
i
+
+
)
{
if
(
(
VARINT_LENGTH_MASKS
[
i
]
&
firstByte
)
!
=
0
)
{
varIntLength
=
i
+
1
;
break
;
}
}
return
varIntLength
;
}
public
static
long
assembleVarint
(
byte
[
]
varintBytes
int
varintLength
boolean
removeLengthMask
)
{
long
varint
=
varintBytes
[
0
]
&
0xFFL
;
if
(
removeLengthMask
)
{
varint
&
=
~
VARINT_LENGTH_MASKS
[
varintLength
-
1
]
;
}
for
(
int
i
=
1
;
i
<
varintLength
;
i
+
+
)
{
varint
=
(
varint
<
<
8
)
|
(
varintBytes
[
i
]
&
0xFFL
)
;
}
return
varint
;
}
}
