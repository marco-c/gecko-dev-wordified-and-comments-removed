package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
flac
;
import
static
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
.
castNonNull
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
Extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorsFactory
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
FlacFrameReader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
FlacFrameReader
.
SampleNumberHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
FlacMetadataReader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
FlacSeekTableSeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
PositionHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
Metadata
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
FlacConstants
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
FlacStreamMetadata
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
MonotonicNonNull
;
public
final
class
FlacExtractor
implements
Extractor
{
public
static
final
ExtractorsFactory
FACTORY
=
(
)
-
>
new
Extractor
[
]
{
new
FlacExtractor
(
)
}
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
flag
=
true
value
=
{
FLAG_DISABLE_ID3_METADATA
}
)
public
interface
Flags
{
}
public
static
final
int
FLAG_DISABLE_ID3_METADATA
=
1
;
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
STATE_READ_ID3_METADATA
STATE_GET_STREAM_MARKER_AND_INFO_BLOCK_BYTES
STATE_READ_STREAM_MARKER
STATE_READ_METADATA_BLOCKS
STATE_GET_FRAME_START_MARKER
STATE_READ_FRAMES
}
)
private
interface
State
{
}
private
static
final
int
STATE_READ_ID3_METADATA
=
0
;
private
static
final
int
STATE_GET_STREAM_MARKER_AND_INFO_BLOCK_BYTES
=
1
;
private
static
final
int
STATE_READ_STREAM_MARKER
=
2
;
private
static
final
int
STATE_READ_METADATA_BLOCKS
=
3
;
private
static
final
int
STATE_GET_FRAME_START_MARKER
=
4
;
private
static
final
int
STATE_READ_FRAMES
=
5
;
private
static
final
int
BUFFER_LENGTH
=
32
*
1024
;
private
static
final
int
SAMPLE_NUMBER_UNKNOWN
=
-
1
;
private
final
byte
[
]
streamMarkerAndInfoBlock
;
private
final
ParsableByteArray
buffer
;
private
final
boolean
id3MetadataDisabled
;
private
final
SampleNumberHolder
sampleNumberHolder
;
MonotonicNonNull
private
ExtractorOutput
extractorOutput
;
MonotonicNonNull
private
TrackOutput
trackOutput
;
private
State
int
state
;
Nullable
private
Metadata
id3Metadata
;
MonotonicNonNull
private
FlacStreamMetadata
flacStreamMetadata
;
private
int
minFrameSize
;
private
int
frameStartMarker
;
MonotonicNonNull
private
FlacBinarySearchSeeker
binarySearchSeeker
;
private
int
currentFrameBytesWritten
;
private
long
currentFrameFirstSampleNumber
;
public
FlacExtractor
(
)
{
this
(
0
)
;
}
public
FlacExtractor
(
int
flags
)
{
streamMarkerAndInfoBlock
=
new
byte
[
FlacConstants
.
STREAM_MARKER_SIZE
+
FlacConstants
.
STREAM_INFO_BLOCK_SIZE
]
;
buffer
=
new
ParsableByteArray
(
new
byte
[
BUFFER_LENGTH
]
0
)
;
id3MetadataDisabled
=
(
flags
&
FLAG_DISABLE_ID3_METADATA
)
!
=
0
;
sampleNumberHolder
=
new
SampleNumberHolder
(
)
;
state
=
STATE_READ_ID3_METADATA
;
}
Override
public
boolean
sniff
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
FlacMetadataReader
.
peekId3Metadata
(
input
false
)
;
return
FlacMetadataReader
.
checkAndPeekStreamMarker
(
input
)
;
}
Override
public
void
init
(
ExtractorOutput
output
)
{
extractorOutput
=
output
;
trackOutput
=
output
.
track
(
0
C
.
TRACK_TYPE_AUDIO
)
;
output
.
endTracks
(
)
;
}
Override
public
ReadResult
int
read
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
switch
(
state
)
{
case
STATE_READ_ID3_METADATA
:
readId3Metadata
(
input
)
;
return
Extractor
.
RESULT_CONTINUE
;
case
STATE_GET_STREAM_MARKER_AND_INFO_BLOCK_BYTES
:
getStreamMarkerAndInfoBlockBytes
(
input
)
;
return
Extractor
.
RESULT_CONTINUE
;
case
STATE_READ_STREAM_MARKER
:
readStreamMarker
(
input
)
;
return
Extractor
.
RESULT_CONTINUE
;
case
STATE_READ_METADATA_BLOCKS
:
readMetadataBlocks
(
input
)
;
return
Extractor
.
RESULT_CONTINUE
;
case
STATE_GET_FRAME_START_MARKER
:
getFrameStartMarker
(
input
)
;
return
Extractor
.
RESULT_CONTINUE
;
case
STATE_READ_FRAMES
:
return
readFrames
(
input
seekPosition
)
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
Override
public
void
seek
(
long
position
long
timeUs
)
{
if
(
position
=
=
0
)
{
state
=
STATE_READ_ID3_METADATA
;
}
else
if
(
binarySearchSeeker
!
=
null
)
{
binarySearchSeeker
.
setSeekTargetUs
(
timeUs
)
;
}
currentFrameFirstSampleNumber
=
timeUs
=
=
0
?
0
:
SAMPLE_NUMBER_UNKNOWN
;
currentFrameBytesWritten
=
0
;
buffer
.
reset
(
)
;
}
Override
public
void
release
(
)
{
}
private
void
readId3Metadata
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
id3Metadata
=
FlacMetadataReader
.
readId3Metadata
(
input
!
id3MetadataDisabled
)
;
state
=
STATE_GET_STREAM_MARKER_AND_INFO_BLOCK_BYTES
;
}
private
void
getStreamMarkerAndInfoBlockBytes
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
input
.
peekFully
(
streamMarkerAndInfoBlock
0
streamMarkerAndInfoBlock
.
length
)
;
input
.
resetPeekPosition
(
)
;
state
=
STATE_READ_STREAM_MARKER
;
}
private
void
readStreamMarker
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
FlacMetadataReader
.
readStreamMarker
(
input
)
;
state
=
STATE_READ_METADATA_BLOCKS
;
}
private
void
readMetadataBlocks
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
boolean
isLastMetadataBlock
=
false
;
FlacMetadataReader
.
FlacStreamMetadataHolder
metadataHolder
=
new
FlacMetadataReader
.
FlacStreamMetadataHolder
(
flacStreamMetadata
)
;
while
(
!
isLastMetadataBlock
)
{
isLastMetadataBlock
=
FlacMetadataReader
.
readMetadataBlock
(
input
metadataHolder
)
;
flacStreamMetadata
=
castNonNull
(
metadataHolder
.
flacStreamMetadata
)
;
}
Assertions
.
checkNotNull
(
flacStreamMetadata
)
;
minFrameSize
=
Math
.
max
(
flacStreamMetadata
.
minFrameSize
FlacConstants
.
MIN_FRAME_HEADER_SIZE
)
;
castNonNull
(
trackOutput
)
.
format
(
flacStreamMetadata
.
getFormat
(
streamMarkerAndInfoBlock
id3Metadata
)
)
;
state
=
STATE_GET_FRAME_START_MARKER
;
}
private
void
getFrameStartMarker
(
ExtractorInput
input
)
throws
IOException
InterruptedException
{
frameStartMarker
=
FlacMetadataReader
.
getFrameStartMarker
(
input
)
;
castNonNull
(
extractorOutput
)
.
seekMap
(
getSeekMap
(
input
.
getPosition
(
)
input
.
getLength
(
)
)
)
;
state
=
STATE_READ_FRAMES
;
}
private
ReadResult
int
readFrames
(
ExtractorInput
input
PositionHolder
seekPosition
)
throws
IOException
InterruptedException
{
Assertions
.
checkNotNull
(
trackOutput
)
;
Assertions
.
checkNotNull
(
flacStreamMetadata
)
;
if
(
binarySearchSeeker
!
=
null
&
&
binarySearchSeeker
.
isSeeking
(
)
)
{
return
binarySearchSeeker
.
handlePendingSeek
(
input
seekPosition
)
;
}
if
(
currentFrameFirstSampleNumber
=
=
SAMPLE_NUMBER_UNKNOWN
)
{
currentFrameFirstSampleNumber
=
FlacFrameReader
.
getFirstSampleNumber
(
input
flacStreamMetadata
)
;
return
Extractor
.
RESULT_CONTINUE
;
}
int
currentLimit
=
buffer
.
limit
(
)
;
boolean
foundEndOfInput
=
false
;
if
(
currentLimit
<
BUFFER_LENGTH
)
{
int
bytesRead
=
input
.
read
(
buffer
.
data
currentLimit
BUFFER_LENGTH
-
currentLimit
)
;
foundEndOfInput
=
bytesRead
=
=
C
.
RESULT_END_OF_INPUT
;
if
(
!
foundEndOfInput
)
{
buffer
.
setLimit
(
currentLimit
+
bytesRead
)
;
}
else
if
(
buffer
.
bytesLeft
(
)
=
=
0
)
{
outputSampleMetadata
(
)
;
return
Extractor
.
RESULT_END_OF_INPUT
;
}
}
int
positionBeforeFindingAFrame
=
buffer
.
getPosition
(
)
;
if
(
currentFrameBytesWritten
<
minFrameSize
)
{
buffer
.
skipBytes
(
Math
.
min
(
minFrameSize
-
currentFrameBytesWritten
buffer
.
bytesLeft
(
)
)
)
;
}
long
nextFrameFirstSampleNumber
=
findFrame
(
buffer
foundEndOfInput
)
;
int
numberOfFrameBytes
=
buffer
.
getPosition
(
)
-
positionBeforeFindingAFrame
;
buffer
.
setPosition
(
positionBeforeFindingAFrame
)
;
trackOutput
.
sampleData
(
buffer
numberOfFrameBytes
)
;
currentFrameBytesWritten
+
=
numberOfFrameBytes
;
if
(
nextFrameFirstSampleNumber
!
=
SAMPLE_NUMBER_UNKNOWN
)
{
outputSampleMetadata
(
)
;
currentFrameBytesWritten
=
0
;
currentFrameFirstSampleNumber
=
nextFrameFirstSampleNumber
;
}
if
(
buffer
.
bytesLeft
(
)
<
FlacConstants
.
MAX_FRAME_HEADER_SIZE
)
{
System
.
arraycopy
(
buffer
.
data
buffer
.
getPosition
(
)
buffer
.
data
0
buffer
.
bytesLeft
(
)
)
;
buffer
.
reset
(
buffer
.
bytesLeft
(
)
)
;
}
return
Extractor
.
RESULT_CONTINUE
;
}
private
SeekMap
getSeekMap
(
long
firstFramePosition
long
streamLength
)
{
Assertions
.
checkNotNull
(
flacStreamMetadata
)
;
if
(
flacStreamMetadata
.
seekTable
!
=
null
)
{
return
new
FlacSeekTableSeekMap
(
flacStreamMetadata
firstFramePosition
)
;
}
else
if
(
streamLength
!
=
C
.
LENGTH_UNSET
&
&
flacStreamMetadata
.
totalSamples
>
0
)
{
binarySearchSeeker
=
new
FlacBinarySearchSeeker
(
flacStreamMetadata
frameStartMarker
firstFramePosition
streamLength
)
;
return
binarySearchSeeker
.
getSeekMap
(
)
;
}
else
{
return
new
SeekMap
.
Unseekable
(
flacStreamMetadata
.
getDurationUs
(
)
)
;
}
}
private
long
findFrame
(
ParsableByteArray
data
boolean
foundEndOfInput
)
{
Assertions
.
checkNotNull
(
flacStreamMetadata
)
;
int
frameOffset
=
data
.
getPosition
(
)
;
while
(
frameOffset
<
=
data
.
limit
(
)
-
FlacConstants
.
MAX_FRAME_HEADER_SIZE
)
{
data
.
setPosition
(
frameOffset
)
;
if
(
FlacFrameReader
.
checkAndReadFrameHeader
(
data
flacStreamMetadata
frameStartMarker
sampleNumberHolder
)
)
{
data
.
setPosition
(
frameOffset
)
;
return
sampleNumberHolder
.
sampleNumber
;
}
frameOffset
+
+
;
}
if
(
foundEndOfInput
)
{
while
(
frameOffset
<
=
data
.
limit
(
)
-
minFrameSize
)
{
data
.
setPosition
(
frameOffset
)
;
boolean
frameFound
;
try
{
frameFound
=
FlacFrameReader
.
checkAndReadFrameHeader
(
data
flacStreamMetadata
frameStartMarker
sampleNumberHolder
)
;
}
catch
(
IndexOutOfBoundsException
e
)
{
frameFound
=
false
;
}
if
(
data
.
getPosition
(
)
>
data
.
limit
(
)
)
{
frameFound
=
false
;
}
if
(
frameFound
)
{
data
.
setPosition
(
frameOffset
)
;
return
sampleNumberHolder
.
sampleNumber
;
}
frameOffset
+
+
;
}
data
.
setPosition
(
data
.
limit
(
)
)
;
}
else
{
data
.
setPosition
(
frameOffset
)
;
}
return
SAMPLE_NUMBER_UNKNOWN
;
}
private
void
outputSampleMetadata
(
)
{
long
timeUs
=
currentFrameFirstSampleNumber
*
C
.
MICROS_PER_SECOND
/
castNonNull
(
flacStreamMetadata
)
.
sampleRate
;
castNonNull
(
trackOutput
)
.
sampleMetadata
(
timeUs
C
.
BUFFER_FLAG_KEY_FRAME
currentFrameBytesWritten
0
null
)
;
}
}
