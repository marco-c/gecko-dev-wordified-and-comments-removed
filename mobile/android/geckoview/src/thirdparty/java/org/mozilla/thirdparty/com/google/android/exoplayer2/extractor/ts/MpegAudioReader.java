package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
MpegAudioHeader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
TrackIdGenerator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
public
final
class
MpegAudioReader
implements
ElementaryStreamReader
{
private
static
final
int
STATE_FINDING_HEADER
=
0
;
private
static
final
int
STATE_READING_HEADER
=
1
;
private
static
final
int
STATE_READING_FRAME
=
2
;
private
static
final
int
HEADER_SIZE
=
4
;
private
final
ParsableByteArray
headerScratch
;
private
final
MpegAudioHeader
header
;
private
final
String
language
;
private
String
formatId
;
private
TrackOutput
output
;
private
int
state
;
private
int
frameBytesRead
;
private
boolean
hasOutputFormat
;
private
boolean
lastByteWasFF
;
private
long
frameDurationUs
;
private
int
frameSize
;
private
long
timeUs
;
public
MpegAudioReader
(
)
{
this
(
null
)
;
}
public
MpegAudioReader
(
String
language
)
{
state
=
STATE_FINDING_HEADER
;
headerScratch
=
new
ParsableByteArray
(
4
)
;
headerScratch
.
data
[
0
]
=
(
byte
)
0xFF
;
header
=
new
MpegAudioHeader
(
)
;
this
.
language
=
language
;
}
Override
public
void
seek
(
)
{
state
=
STATE_FINDING_HEADER
;
frameBytesRead
=
0
;
lastByteWasFF
=
false
;
}
Override
public
void
createTracks
(
ExtractorOutput
extractorOutput
TrackIdGenerator
idGenerator
)
{
idGenerator
.
generateNewId
(
)
;
formatId
=
idGenerator
.
getFormatId
(
)
;
output
=
extractorOutput
.
track
(
idGenerator
.
getTrackId
(
)
C
.
TRACK_TYPE_AUDIO
)
;
}
Override
public
void
packetStarted
(
long
pesTimeUs
TsPayloadReader
.
Flags
int
flags
)
{
timeUs
=
pesTimeUs
;
}
Override
public
void
consume
(
ParsableByteArray
data
)
{
while
(
data
.
bytesLeft
(
)
>
0
)
{
switch
(
state
)
{
case
STATE_FINDING_HEADER
:
findHeader
(
data
)
;
break
;
case
STATE_READING_HEADER
:
readHeaderRemainder
(
data
)
;
break
;
case
STATE_READING_FRAME
:
readFrameRemainder
(
data
)
;
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
}
Override
public
void
packetFinished
(
)
{
}
private
void
findHeader
(
ParsableByteArray
source
)
{
byte
[
]
data
=
source
.
data
;
int
startOffset
=
source
.
getPosition
(
)
;
int
endOffset
=
source
.
limit
(
)
;
for
(
int
i
=
startOffset
;
i
<
endOffset
;
i
+
+
)
{
boolean
byteIsFF
=
(
data
[
i
]
&
0xFF
)
=
=
0xFF
;
boolean
found
=
lastByteWasFF
&
&
(
data
[
i
]
&
0xE0
)
=
=
0xE0
;
lastByteWasFF
=
byteIsFF
;
if
(
found
)
{
source
.
setPosition
(
i
+
1
)
;
lastByteWasFF
=
false
;
headerScratch
.
data
[
1
]
=
data
[
i
]
;
frameBytesRead
=
2
;
state
=
STATE_READING_HEADER
;
return
;
}
}
source
.
setPosition
(
endOffset
)
;
}
private
void
readHeaderRemainder
(
ParsableByteArray
source
)
{
int
bytesToRead
=
Math
.
min
(
source
.
bytesLeft
(
)
HEADER_SIZE
-
frameBytesRead
)
;
source
.
readBytes
(
headerScratch
.
data
frameBytesRead
bytesToRead
)
;
frameBytesRead
+
=
bytesToRead
;
if
(
frameBytesRead
<
HEADER_SIZE
)
{
return
;
}
headerScratch
.
setPosition
(
0
)
;
boolean
parsedHeader
=
MpegAudioHeader
.
populateHeader
(
headerScratch
.
readInt
(
)
header
)
;
if
(
!
parsedHeader
)
{
frameBytesRead
=
0
;
state
=
STATE_READING_HEADER
;
return
;
}
frameSize
=
header
.
frameSize
;
if
(
!
hasOutputFormat
)
{
frameDurationUs
=
(
C
.
MICROS_PER_SECOND
*
header
.
samplesPerFrame
)
/
header
.
sampleRate
;
Format
format
=
Format
.
createAudioSampleFormat
(
formatId
header
.
mimeType
null
Format
.
NO_VALUE
MpegAudioHeader
.
MAX_FRAME_SIZE_BYTES
header
.
channels
header
.
sampleRate
null
null
0
language
)
;
output
.
format
(
format
)
;
hasOutputFormat
=
true
;
}
headerScratch
.
setPosition
(
0
)
;
output
.
sampleData
(
headerScratch
HEADER_SIZE
)
;
state
=
STATE_READING_FRAME
;
}
private
void
readFrameRemainder
(
ParsableByteArray
source
)
{
int
bytesToRead
=
Math
.
min
(
source
.
bytesLeft
(
)
frameSize
-
frameBytesRead
)
;
output
.
sampleData
(
source
bytesToRead
)
;
frameBytesRead
+
=
bytesToRead
;
if
(
frameBytesRead
<
frameSize
)
{
return
;
}
output
.
sampleMetadata
(
timeUs
C
.
BUFFER_FLAG_KEY_FRAME
frameSize
0
null
)
;
timeUs
+
=
frameDurationUs
;
frameBytesRead
=
0
;
state
=
STATE_FINDING_HEADER
;
}
}
