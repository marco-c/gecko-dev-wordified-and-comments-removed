package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
java
.
io
.
IOException
;
public
final
class
ClippingMediaPeriod
implements
MediaPeriod
MediaPeriod
.
Callback
{
public
final
MediaPeriod
mediaPeriod
;
private
MediaPeriod
.
Callback
callback
;
private
long
startUs
;
private
long
endUs
;
private
ClippingSampleStream
[
]
sampleStreams
;
private
boolean
pendingInitialDiscontinuity
;
public
ClippingMediaPeriod
(
MediaPeriod
mediaPeriod
)
{
this
.
mediaPeriod
=
mediaPeriod
;
startUs
=
C
.
TIME_UNSET
;
endUs
=
C
.
TIME_UNSET
;
sampleStreams
=
new
ClippingSampleStream
[
0
]
;
}
public
void
setClipping
(
long
startUs
long
endUs
)
{
this
.
startUs
=
startUs
;
this
.
endUs
=
endUs
;
}
Override
public
void
prepare
(
MediaPeriod
.
Callback
callback
)
{
this
.
callback
=
callback
;
mediaPeriod
.
prepare
(
this
)
;
}
Override
public
void
maybeThrowPrepareError
(
)
throws
IOException
{
mediaPeriod
.
maybeThrowPrepareError
(
)
;
}
Override
public
TrackGroupArray
getTrackGroups
(
)
{
return
mediaPeriod
.
getTrackGroups
(
)
;
}
Override
public
long
selectTracks
(
TrackSelection
[
]
selections
boolean
[
]
mayRetainStreamFlags
SampleStream
[
]
streams
boolean
[
]
streamResetFlags
long
positionUs
)
{
sampleStreams
=
new
ClippingSampleStream
[
streams
.
length
]
;
SampleStream
[
]
internalStreams
=
new
SampleStream
[
streams
.
length
]
;
for
(
int
i
=
0
;
i
<
streams
.
length
;
i
+
+
)
{
sampleStreams
[
i
]
=
(
ClippingSampleStream
)
streams
[
i
]
;
internalStreams
[
i
]
=
sampleStreams
[
i
]
!
=
null
?
sampleStreams
[
i
]
.
stream
:
null
;
}
long
enablePositionUs
=
mediaPeriod
.
selectTracks
(
selections
mayRetainStreamFlags
internalStreams
streamResetFlags
positionUs
+
startUs
)
;
Assertions
.
checkState
(
enablePositionUs
=
=
positionUs
+
startUs
|
|
(
enablePositionUs
>
=
startUs
&
&
(
endUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
enablePositionUs
<
=
endUs
)
)
)
;
for
(
int
i
=
0
;
i
<
streams
.
length
;
i
+
+
)
{
if
(
internalStreams
[
i
]
=
=
null
)
{
sampleStreams
[
i
]
=
null
;
}
else
if
(
streams
[
i
]
=
=
null
|
|
sampleStreams
[
i
]
.
stream
!
=
internalStreams
[
i
]
)
{
sampleStreams
[
i
]
=
new
ClippingSampleStream
(
this
internalStreams
[
i
]
startUs
endUs
pendingInitialDiscontinuity
)
;
}
streams
[
i
]
=
sampleStreams
[
i
]
;
}
return
enablePositionUs
-
startUs
;
}
Override
public
void
discardBuffer
(
long
positionUs
)
{
mediaPeriod
.
discardBuffer
(
positionUs
+
startUs
)
;
}
Override
public
long
readDiscontinuity
(
)
{
if
(
pendingInitialDiscontinuity
)
{
for
(
ClippingSampleStream
sampleStream
:
sampleStreams
)
{
if
(
sampleStream
!
=
null
)
{
sampleStream
.
clearPendingDiscontinuity
(
)
;
}
}
pendingInitialDiscontinuity
=
false
;
long
discontinuityUs
=
readDiscontinuity
(
)
;
return
discontinuityUs
!
=
C
.
TIME_UNSET
?
discontinuityUs
:
0
;
}
long
discontinuityUs
=
mediaPeriod
.
readDiscontinuity
(
)
;
if
(
discontinuityUs
=
=
C
.
TIME_UNSET
)
{
return
C
.
TIME_UNSET
;
}
Assertions
.
checkState
(
discontinuityUs
>
=
startUs
)
;
Assertions
.
checkState
(
endUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
discontinuityUs
<
=
endUs
)
;
return
discontinuityUs
-
startUs
;
}
Override
public
long
getBufferedPositionUs
(
)
{
long
bufferedPositionUs
=
mediaPeriod
.
getBufferedPositionUs
(
)
;
if
(
bufferedPositionUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
(
endUs
!
=
C
.
TIME_END_OF_SOURCE
&
&
bufferedPositionUs
>
=
endUs
)
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
return
Math
.
max
(
0
bufferedPositionUs
-
startUs
)
;
}
Override
public
long
seekToUs
(
long
positionUs
)
{
for
(
ClippingSampleStream
sampleStream
:
sampleStreams
)
{
if
(
sampleStream
!
=
null
)
{
sampleStream
.
clearSentEos
(
)
;
}
}
long
seekUs
=
mediaPeriod
.
seekToUs
(
positionUs
+
startUs
)
;
Assertions
.
checkState
(
seekUs
=
=
positionUs
+
startUs
|
|
(
seekUs
>
=
startUs
&
&
(
endUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
seekUs
<
=
endUs
)
)
)
;
return
seekUs
-
startUs
;
}
Override
public
long
getNextLoadPositionUs
(
)
{
long
nextLoadPositionUs
=
mediaPeriod
.
getNextLoadPositionUs
(
)
;
if
(
nextLoadPositionUs
=
=
C
.
TIME_END_OF_SOURCE
|
|
(
endUs
!
=
C
.
TIME_END_OF_SOURCE
&
&
nextLoadPositionUs
>
=
endUs
)
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
return
nextLoadPositionUs
-
startUs
;
}
Override
public
boolean
continueLoading
(
long
positionUs
)
{
return
mediaPeriod
.
continueLoading
(
positionUs
+
startUs
)
;
}
Override
public
void
onPrepared
(
MediaPeriod
mediaPeriod
)
{
Assertions
.
checkState
(
startUs
!
=
C
.
TIME_UNSET
&
&
endUs
!
=
C
.
TIME_UNSET
)
;
pendingInitialDiscontinuity
=
startUs
!
=
0
;
callback
.
onPrepared
(
this
)
;
}
Override
public
void
onContinueLoadingRequested
(
MediaPeriod
source
)
{
callback
.
onContinueLoadingRequested
(
this
)
;
}
private
static
final
class
ClippingSampleStream
implements
SampleStream
{
private
final
MediaPeriod
mediaPeriod
;
private
final
SampleStream
stream
;
private
final
long
startUs
;
private
final
long
endUs
;
private
boolean
pendingDiscontinuity
;
private
boolean
sentEos
;
public
ClippingSampleStream
(
MediaPeriod
mediaPeriod
SampleStream
stream
long
startUs
long
endUs
boolean
pendingDiscontinuity
)
{
this
.
mediaPeriod
=
mediaPeriod
;
this
.
stream
=
stream
;
this
.
startUs
=
startUs
;
this
.
endUs
=
endUs
;
this
.
pendingDiscontinuity
=
pendingDiscontinuity
;
}
public
void
clearPendingDiscontinuity
(
)
{
pendingDiscontinuity
=
false
;
}
public
void
clearSentEos
(
)
{
sentEos
=
false
;
}
Override
public
boolean
isReady
(
)
{
return
stream
.
isReady
(
)
;
}
Override
public
void
maybeThrowError
(
)
throws
IOException
{
stream
.
maybeThrowError
(
)
;
}
Override
public
int
readData
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
requireFormat
)
{
if
(
pendingDiscontinuity
)
{
return
C
.
RESULT_NOTHING_READ
;
}
if
(
sentEos
)
{
buffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
return
C
.
RESULT_BUFFER_READ
;
}
int
result
=
stream
.
readData
(
formatHolder
buffer
requireFormat
)
;
if
(
endUs
!
=
C
.
TIME_END_OF_SOURCE
&
&
(
(
result
=
=
C
.
RESULT_BUFFER_READ
&
&
buffer
.
timeUs
>
=
endUs
)
|
|
(
result
=
=
C
.
RESULT_NOTHING_READ
&
&
mediaPeriod
.
getBufferedPositionUs
(
)
=
=
C
.
TIME_END_OF_SOURCE
)
)
)
{
buffer
.
clear
(
)
;
buffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
sentEos
=
true
;
return
C
.
RESULT_BUFFER_READ
;
}
if
(
result
=
=
C
.
RESULT_BUFFER_READ
&
&
!
buffer
.
isEndOfStream
(
)
)
{
buffer
.
timeUs
-
=
startUs
;
}
return
result
;
}
Override
public
void
skipData
(
long
positionUs
)
{
stream
.
skipData
(
startUs
+
positionUs
)
;
}
}
}
