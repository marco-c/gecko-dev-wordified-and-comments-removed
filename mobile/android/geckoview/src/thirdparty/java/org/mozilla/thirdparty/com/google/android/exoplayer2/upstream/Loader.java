package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
android
.
os
.
SystemClock
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
concurrent
.
ExecutorService
;
public
final
class
Loader
implements
LoaderErrorThrower
{
public
static
final
class
UnexpectedLoaderException
extends
IOException
{
public
UnexpectedLoaderException
(
Throwable
cause
)
{
super
(
"
Unexpected
"
+
cause
.
getClass
(
)
.
getSimpleName
(
)
+
"
:
"
+
cause
.
getMessage
(
)
cause
)
;
}
}
public
interface
Loadable
{
void
cancelLoad
(
)
;
void
load
(
)
throws
IOException
InterruptedException
;
}
public
interface
Callback
<
T
extends
Loadable
>
{
void
onLoadCompleted
(
T
loadable
long
elapsedRealtimeMs
long
loadDurationMs
)
;
void
onLoadCanceled
(
T
loadable
long
elapsedRealtimeMs
long
loadDurationMs
boolean
released
)
;
LoadErrorAction
onLoadError
(
T
loadable
long
elapsedRealtimeMs
long
loadDurationMs
IOException
error
int
errorCount
)
;
}
public
interface
ReleaseCallback
{
void
onLoaderReleased
(
)
;
}
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
ACTION_TYPE_RETRY
ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT
ACTION_TYPE_DONT_RETRY
ACTION_TYPE_DONT_RETRY_FATAL
}
)
private
interface
RetryActionType
{
}
private
static
final
int
ACTION_TYPE_RETRY
=
0
;
private
static
final
int
ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT
=
1
;
private
static
final
int
ACTION_TYPE_DONT_RETRY
=
2
;
private
static
final
int
ACTION_TYPE_DONT_RETRY_FATAL
=
3
;
public
static
final
LoadErrorAction
RETRY
=
createRetryAction
(
false
C
.
TIME_UNSET
)
;
public
static
final
LoadErrorAction
RETRY_RESET_ERROR_COUNT
=
createRetryAction
(
true
C
.
TIME_UNSET
)
;
public
static
final
LoadErrorAction
DONT_RETRY
=
new
LoadErrorAction
(
ACTION_TYPE_DONT_RETRY
C
.
TIME_UNSET
)
;
public
static
final
LoadErrorAction
DONT_RETRY_FATAL
=
new
LoadErrorAction
(
ACTION_TYPE_DONT_RETRY_FATAL
C
.
TIME_UNSET
)
;
public
static
final
class
LoadErrorAction
{
private
final
RetryActionType
int
type
;
private
final
long
retryDelayMillis
;
private
LoadErrorAction
(
RetryActionType
int
type
long
retryDelayMillis
)
{
this
.
type
=
type
;
this
.
retryDelayMillis
=
retryDelayMillis
;
}
public
boolean
isRetry
(
)
{
return
type
=
=
ACTION_TYPE_RETRY
|
|
type
=
=
ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT
;
}
}
private
final
ExecutorService
downloadExecutorService
;
Nullable
private
LoadTask
<
?
extends
Loadable
>
currentTask
;
Nullable
private
IOException
fatalError
;
public
Loader
(
String
threadName
)
{
this
.
downloadExecutorService
=
Util
.
newSingleThreadExecutor
(
threadName
)
;
}
public
static
LoadErrorAction
createRetryAction
(
boolean
resetErrorCount
long
retryDelayMillis
)
{
return
new
LoadErrorAction
(
resetErrorCount
?
ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT
:
ACTION_TYPE_RETRY
retryDelayMillis
)
;
}
public
boolean
hasFatalError
(
)
{
return
fatalError
!
=
null
;
}
public
void
clearFatalError
(
)
{
fatalError
=
null
;
}
public
<
T
extends
Loadable
>
long
startLoading
(
T
loadable
Callback
<
T
>
callback
int
defaultMinRetryCount
)
{
Looper
looper
=
Assertions
.
checkStateNotNull
(
Looper
.
myLooper
(
)
)
;
fatalError
=
null
;
long
startTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
new
LoadTask
<
>
(
looper
loadable
callback
defaultMinRetryCount
startTimeMs
)
.
start
(
0
)
;
return
startTimeMs
;
}
public
boolean
isLoading
(
)
{
return
currentTask
!
=
null
;
}
public
void
cancelLoading
(
)
{
Assertions
.
checkStateNotNull
(
currentTask
)
.
cancel
(
false
)
;
}
public
void
release
(
)
{
release
(
null
)
;
}
public
void
release
(
Nullable
ReleaseCallback
callback
)
{
if
(
currentTask
!
=
null
)
{
currentTask
.
cancel
(
true
)
;
}
if
(
callback
!
=
null
)
{
downloadExecutorService
.
execute
(
new
ReleaseTask
(
callback
)
)
;
}
downloadExecutorService
.
shutdown
(
)
;
}
Override
public
void
maybeThrowError
(
)
throws
IOException
{
maybeThrowError
(
Integer
.
MIN_VALUE
)
;
}
Override
public
void
maybeThrowError
(
int
minRetryCount
)
throws
IOException
{
if
(
fatalError
!
=
null
)
{
throw
fatalError
;
}
else
if
(
currentTask
!
=
null
)
{
currentTask
.
maybeThrowError
(
minRetryCount
=
=
Integer
.
MIN_VALUE
?
currentTask
.
defaultMinRetryCount
:
minRetryCount
)
;
}
}
SuppressLint
(
"
HandlerLeak
"
)
private
final
class
LoadTask
<
T
extends
Loadable
>
extends
Handler
implements
Runnable
{
private
static
final
String
TAG
=
"
LoadTask
"
;
private
static
final
int
MSG_START
=
0
;
private
static
final
int
MSG_CANCEL
=
1
;
private
static
final
int
MSG_END_OF_SOURCE
=
2
;
private
static
final
int
MSG_IO_EXCEPTION
=
3
;
private
static
final
int
MSG_FATAL_ERROR
=
4
;
public
final
int
defaultMinRetryCount
;
private
final
T
loadable
;
private
final
long
startTimeMs
;
Nullable
private
Loader
.
Callback
<
T
>
callback
;
Nullable
private
IOException
currentError
;
private
int
errorCount
;
Nullable
private
volatile
Thread
executorThread
;
private
volatile
boolean
canceled
;
private
volatile
boolean
released
;
public
LoadTask
(
Looper
looper
T
loadable
Loader
.
Callback
<
T
>
callback
int
defaultMinRetryCount
long
startTimeMs
)
{
super
(
looper
)
;
this
.
loadable
=
loadable
;
this
.
callback
=
callback
;
this
.
defaultMinRetryCount
=
defaultMinRetryCount
;
this
.
startTimeMs
=
startTimeMs
;
}
public
void
maybeThrowError
(
int
minRetryCount
)
throws
IOException
{
if
(
currentError
!
=
null
&
&
errorCount
>
minRetryCount
)
{
throw
currentError
;
}
}
public
void
start
(
long
delayMillis
)
{
Assertions
.
checkState
(
currentTask
=
=
null
)
;
currentTask
=
this
;
if
(
delayMillis
>
0
)
{
sendEmptyMessageDelayed
(
MSG_START
delayMillis
)
;
}
else
{
execute
(
)
;
}
}
public
void
cancel
(
boolean
released
)
{
this
.
released
=
released
;
currentError
=
null
;
if
(
hasMessages
(
MSG_START
)
)
{
removeMessages
(
MSG_START
)
;
if
(
!
released
)
{
sendEmptyMessage
(
MSG_CANCEL
)
;
}
}
else
{
canceled
=
true
;
loadable
.
cancelLoad
(
)
;
Thread
executorThread
=
this
.
executorThread
;
if
(
executorThread
!
=
null
)
{
executorThread
.
interrupt
(
)
;
}
}
if
(
released
)
{
finish
(
)
;
long
nowMs
=
SystemClock
.
elapsedRealtime
(
)
;
Assertions
.
checkNotNull
(
callback
)
.
onLoadCanceled
(
loadable
nowMs
nowMs
-
startTimeMs
true
)
;
callback
=
null
;
}
}
Override
public
void
run
(
)
{
try
{
executorThread
=
Thread
.
currentThread
(
)
;
if
(
!
canceled
)
{
TraceUtil
.
beginSection
(
"
load
:
"
+
loadable
.
getClass
(
)
.
getSimpleName
(
)
)
;
try
{
loadable
.
load
(
)
;
}
finally
{
TraceUtil
.
endSection
(
)
;
}
}
if
(
!
released
)
{
sendEmptyMessage
(
MSG_END_OF_SOURCE
)
;
}
}
catch
(
IOException
e
)
{
if
(
!
released
)
{
obtainMessage
(
MSG_IO_EXCEPTION
e
)
.
sendToTarget
(
)
;
}
}
catch
(
InterruptedException
e
)
{
Assertions
.
checkState
(
canceled
)
;
if
(
!
released
)
{
sendEmptyMessage
(
MSG_END_OF_SOURCE
)
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
TAG
"
Unexpected
exception
loading
stream
"
e
)
;
if
(
!
released
)
{
obtainMessage
(
MSG_IO_EXCEPTION
new
UnexpectedLoaderException
(
e
)
)
.
sendToTarget
(
)
;
}
}
catch
(
OutOfMemoryError
e
)
{
Log
.
e
(
TAG
"
OutOfMemory
error
loading
stream
"
e
)
;
if
(
!
released
)
{
obtainMessage
(
MSG_IO_EXCEPTION
new
UnexpectedLoaderException
(
e
)
)
.
sendToTarget
(
)
;
}
}
catch
(
Error
e
)
{
Log
.
e
(
TAG
"
Unexpected
error
loading
stream
"
e
)
;
if
(
!
released
)
{
obtainMessage
(
MSG_FATAL_ERROR
e
)
.
sendToTarget
(
)
;
}
throw
e
;
}
}
Override
public
void
handleMessage
(
Message
msg
)
{
if
(
released
)
{
return
;
}
if
(
msg
.
what
=
=
MSG_START
)
{
execute
(
)
;
return
;
}
if
(
msg
.
what
=
=
MSG_FATAL_ERROR
)
{
throw
(
Error
)
msg
.
obj
;
}
finish
(
)
;
long
nowMs
=
SystemClock
.
elapsedRealtime
(
)
;
long
durationMs
=
nowMs
-
startTimeMs
;
Loader
.
Callback
<
T
>
callback
=
Assertions
.
checkNotNull
(
this
.
callback
)
;
if
(
canceled
)
{
callback
.
onLoadCanceled
(
loadable
nowMs
durationMs
false
)
;
return
;
}
switch
(
msg
.
what
)
{
case
MSG_CANCEL
:
callback
.
onLoadCanceled
(
loadable
nowMs
durationMs
false
)
;
break
;
case
MSG_END_OF_SOURCE
:
try
{
callback
.
onLoadCompleted
(
loadable
nowMs
durationMs
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
TAG
"
Unexpected
exception
handling
load
completed
"
e
)
;
fatalError
=
new
UnexpectedLoaderException
(
e
)
;
}
break
;
case
MSG_IO_EXCEPTION
:
currentError
=
(
IOException
)
msg
.
obj
;
errorCount
+
+
;
LoadErrorAction
action
=
callback
.
onLoadError
(
loadable
nowMs
durationMs
currentError
errorCount
)
;
if
(
action
.
type
=
=
ACTION_TYPE_DONT_RETRY_FATAL
)
{
fatalError
=
currentError
;
}
else
if
(
action
.
type
!
=
ACTION_TYPE_DONT_RETRY
)
{
if
(
action
.
type
=
=
ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT
)
{
errorCount
=
1
;
}
start
(
action
.
retryDelayMillis
!
=
C
.
TIME_UNSET
?
action
.
retryDelayMillis
:
getRetryDelayMillis
(
)
)
;
}
break
;
default
:
break
;
}
}
private
void
execute
(
)
{
currentError
=
null
;
downloadExecutorService
.
execute
(
Assertions
.
checkNotNull
(
currentTask
)
)
;
}
private
void
finish
(
)
{
currentTask
=
null
;
}
private
long
getRetryDelayMillis
(
)
{
return
Math
.
min
(
(
errorCount
-
1
)
*
1000
5000
)
;
}
}
private
static
final
class
ReleaseTask
implements
Runnable
{
private
final
ReleaseCallback
callback
;
public
ReleaseTask
(
ReleaseCallback
callback
)
{
this
.
callback
=
callback
;
}
Override
public
void
run
(
)
{
callback
.
onLoaderReleased
(
)
;
}
}
}
