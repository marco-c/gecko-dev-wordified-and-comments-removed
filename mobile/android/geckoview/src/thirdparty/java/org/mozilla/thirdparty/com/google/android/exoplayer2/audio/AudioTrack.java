package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
media
.
AudioAttributes
;
import
android
.
media
.
AudioFormat
;
import
android
.
media
.
AudioTimestamp
;
import
android
.
os
.
ConditionVariable
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
PlaybackParameters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
ByteOrder
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
LinkedList
;
public
final
class
AudioTrack
{
public
interface
Listener
{
void
onAudioSessionId
(
int
audioSessionId
)
;
void
onPositionDiscontinuity
(
)
;
void
onUnderrun
(
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
;
}
public
static
final
class
ConfigurationException
extends
Exception
{
public
ConfigurationException
(
Throwable
cause
)
{
super
(
cause
)
;
}
public
ConfigurationException
(
String
message
)
{
super
(
message
)
;
}
}
public
static
final
class
InitializationException
extends
Exception
{
public
final
int
audioTrackState
;
public
InitializationException
(
int
audioTrackState
int
sampleRate
int
channelConfig
int
bufferSize
)
{
super
(
"
AudioTrack
init
failed
:
"
+
audioTrackState
+
"
Config
(
"
+
sampleRate
+
"
"
+
channelConfig
+
"
"
+
bufferSize
+
"
)
"
)
;
this
.
audioTrackState
=
audioTrackState
;
}
}
public
static
final
class
WriteException
extends
Exception
{
public
final
int
errorCode
;
public
WriteException
(
int
errorCode
)
{
super
(
"
AudioTrack
write
failed
:
"
+
errorCode
)
;
this
.
errorCode
=
errorCode
;
}
}
public
static
final
class
InvalidAudioTrackTimestampException
extends
RuntimeException
{
public
InvalidAudioTrackTimestampException
(
String
detailMessage
)
{
super
(
detailMessage
)
;
}
}
public
static
final
long
CURRENT_POSITION_NOT_SET
=
Long
.
MIN_VALUE
;
private
static
final
long
MIN_BUFFER_DURATION_US
=
250000
;
private
static
final
long
MAX_BUFFER_DURATION_US
=
750000
;
private
static
final
long
PASSTHROUGH_BUFFER_DURATION_US
=
250000
;
private
static
final
int
BUFFER_MULTIPLICATION_FACTOR
=
4
;
private
static
final
int
PLAYSTATE_STOPPED
=
android
.
media
.
AudioTrack
.
PLAYSTATE_STOPPED
;
private
static
final
int
PLAYSTATE_PAUSED
=
android
.
media
.
AudioTrack
.
PLAYSTATE_PAUSED
;
private
static
final
int
PLAYSTATE_PLAYING
=
android
.
media
.
AudioTrack
.
PLAYSTATE_PLAYING
;
private
static
final
int
ERROR_BAD_VALUE
=
android
.
media
.
AudioTrack
.
ERROR_BAD_VALUE
;
private
static
final
int
MODE_STATIC
=
android
.
media
.
AudioTrack
.
MODE_STATIC
;
private
static
final
int
MODE_STREAM
=
android
.
media
.
AudioTrack
.
MODE_STREAM
;
private
static
final
int
STATE_INITIALIZED
=
android
.
media
.
AudioTrack
.
STATE_INITIALIZED
;
SuppressLint
(
"
InlinedApi
"
)
private
static
final
int
WRITE_NON_BLOCKING
=
android
.
media
.
AudioTrack
.
WRITE_NON_BLOCKING
;
private
static
final
String
TAG
=
"
AudioTrack
"
;
private
static
final
long
MAX_AUDIO_TIMESTAMP_OFFSET_US
=
5
*
C
.
MICROS_PER_SECOND
;
private
static
final
long
MAX_LATENCY_US
=
5
*
C
.
MICROS_PER_SECOND
;
private
static
final
int
START_NOT_SET
=
0
;
private
static
final
int
START_IN_SYNC
=
1
;
private
static
final
int
START_NEED_SYNC
=
2
;
private
static
final
int
MAX_PLAYHEAD_OFFSET_COUNT
=
10
;
private
static
final
int
MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US
=
30000
;
private
static
final
int
MIN_TIMESTAMP_SAMPLE_INTERVAL_US
=
500000
;
private
static
final
int
SONIC_MIN_BYTES_FOR_SPEEDUP
=
1024
;
public
static
boolean
enablePreV21AudioSessionWorkaround
=
false
;
public
static
boolean
failOnSpuriousAudioTimestamp
=
false
;
private
final
AudioCapabilities
audioCapabilities
;
private
final
ChannelMappingAudioProcessor
channelMappingAudioProcessor
;
private
final
SonicAudioProcessor
sonicAudioProcessor
;
private
final
AudioProcessor
[
]
availableAudioProcessors
;
private
final
Listener
listener
;
private
final
ConditionVariable
releasingConditionVariable
;
private
final
long
[
]
playheadOffsets
;
private
final
AudioTrackUtil
audioTrackUtil
;
private
final
LinkedList
<
PlaybackParametersCheckpoint
>
playbackParametersCheckpoints
;
private
android
.
media
.
AudioTrack
keepSessionIdAudioTrack
;
private
android
.
media
.
AudioTrack
audioTrack
;
private
int
sampleRate
;
private
int
channelConfig
;
C
.
Encoding
private
int
encoding
;
C
.
Encoding
private
int
outputEncoding
;
C
.
StreamType
private
int
streamType
;
private
boolean
passthrough
;
private
int
bufferSize
;
private
long
bufferSizeUs
;
private
PlaybackParameters
drainingPlaybackParameters
;
private
PlaybackParameters
playbackParameters
;
private
long
playbackParametersOffsetUs
;
private
long
playbackParametersPositionUs
;
private
ByteBuffer
avSyncHeader
;
private
int
bytesUntilNextAvSync
;
private
int
nextPlayheadOffsetIndex
;
private
int
playheadOffsetCount
;
private
long
smoothedPlayheadOffsetUs
;
private
long
lastPlayheadSampleTimeUs
;
private
boolean
audioTimestampSet
;
private
long
lastTimestampSampleTimeUs
;
private
Method
getLatencyMethod
;
private
int
pcmFrameSize
;
private
long
submittedPcmBytes
;
private
long
submittedEncodedFrames
;
private
int
outputPcmFrameSize
;
private
long
writtenPcmBytes
;
private
long
writtenEncodedFrames
;
private
int
framesPerEncodedSample
;
private
int
startMediaTimeState
;
private
long
startMediaTimeUs
;
private
long
resumeSystemTimeUs
;
private
long
latencyUs
;
private
float
volume
;
private
AudioProcessor
[
]
audioProcessors
;
private
ByteBuffer
[
]
outputBuffers
;
private
ByteBuffer
inputBuffer
;
private
ByteBuffer
outputBuffer
;
private
byte
[
]
preV21OutputBuffer
;
private
int
preV21OutputBufferOffset
;
private
int
drainingAudioProcessorIndex
;
private
boolean
handledEndOfStream
;
private
boolean
playing
;
private
int
audioSessionId
;
private
boolean
tunneling
;
private
boolean
hasData
;
private
long
lastFeedElapsedRealtimeMs
;
public
AudioTrack
(
AudioCapabilities
audioCapabilities
AudioProcessor
[
]
audioProcessors
Listener
listener
)
{
this
.
audioCapabilities
=
audioCapabilities
;
this
.
listener
=
listener
;
releasingConditionVariable
=
new
ConditionVariable
(
true
)
;
if
(
Util
.
SDK_INT
>
=
18
)
{
try
{
getLatencyMethod
=
android
.
media
.
AudioTrack
.
class
.
getMethod
(
"
getLatency
"
(
Class
<
?
>
[
]
)
null
)
;
}
catch
(
NoSuchMethodException
e
)
{
}
}
if
(
Util
.
SDK_INT
>
=
19
)
{
audioTrackUtil
=
new
AudioTrackUtilV19
(
)
;
}
else
{
audioTrackUtil
=
new
AudioTrackUtil
(
)
;
}
channelMappingAudioProcessor
=
new
ChannelMappingAudioProcessor
(
)
;
sonicAudioProcessor
=
new
SonicAudioProcessor
(
)
;
availableAudioProcessors
=
new
AudioProcessor
[
3
+
audioProcessors
.
length
]
;
availableAudioProcessors
[
0
]
=
new
ResamplingAudioProcessor
(
)
;
availableAudioProcessors
[
1
]
=
channelMappingAudioProcessor
;
System
.
arraycopy
(
audioProcessors
0
availableAudioProcessors
2
audioProcessors
.
length
)
;
availableAudioProcessors
[
2
+
audioProcessors
.
length
]
=
sonicAudioProcessor
;
playheadOffsets
=
new
long
[
MAX_PLAYHEAD_OFFSET_COUNT
]
;
volume
=
1
.
0f
;
startMediaTimeState
=
START_NOT_SET
;
streamType
=
C
.
STREAM_TYPE_DEFAULT
;
audioSessionId
=
C
.
AUDIO_SESSION_ID_UNSET
;
playbackParameters
=
PlaybackParameters
.
DEFAULT
;
drainingAudioProcessorIndex
=
C
.
INDEX_UNSET
;
this
.
audioProcessors
=
new
AudioProcessor
[
0
]
;
outputBuffers
=
new
ByteBuffer
[
0
]
;
playbackParametersCheckpoints
=
new
LinkedList
<
>
(
)
;
}
public
boolean
isPassthroughSupported
(
String
mimeType
)
{
return
audioCapabilities
!
=
null
&
&
audioCapabilities
.
supportsEncoding
(
getEncodingForMimeType
(
mimeType
)
)
;
}
public
long
getCurrentPositionUs
(
boolean
sourceEnded
)
{
if
(
!
hasCurrentPositionUs
(
)
)
{
return
CURRENT_POSITION_NOT_SET
;
}
if
(
audioTrack
.
getPlayState
(
)
=
=
PLAYSTATE_PLAYING
)
{
maybeSampleSyncParams
(
)
;
}
long
systemClockUs
=
System
.
nanoTime
(
)
/
1000
;
long
positionUs
;
if
(
audioTimestampSet
)
{
long
elapsedSinceTimestampUs
=
systemClockUs
-
(
audioTrackUtil
.
getTimestampNanoTime
(
)
/
1000
)
;
long
elapsedSinceTimestampFrames
=
durationUsToFrames
(
elapsedSinceTimestampUs
)
;
long
elapsedFrames
=
audioTrackUtil
.
getTimestampFramePosition
(
)
+
elapsedSinceTimestampFrames
;
positionUs
=
framesToDurationUs
(
elapsedFrames
)
;
}
else
{
if
(
playheadOffsetCount
=
=
0
)
{
positionUs
=
audioTrackUtil
.
getPositionUs
(
)
;
}
else
{
positionUs
=
systemClockUs
+
smoothedPlayheadOffsetUs
;
}
if
(
!
sourceEnded
)
{
positionUs
-
=
latencyUs
;
}
}
return
startMediaTimeUs
+
applySpeedup
(
positionUs
)
;
}
public
void
configure
(
String
mimeType
int
channelCount
int
sampleRate
C
.
PcmEncoding
int
pcmEncoding
int
specifiedBufferSize
)
throws
ConfigurationException
{
configure
(
mimeType
channelCount
sampleRate
pcmEncoding
specifiedBufferSize
null
)
;
}
public
void
configure
(
String
mimeType
int
channelCount
int
sampleRate
C
.
PcmEncoding
int
pcmEncoding
int
specifiedBufferSize
int
[
]
outputChannels
)
throws
ConfigurationException
{
boolean
passthrough
=
!
MimeTypes
.
AUDIO_RAW
.
equals
(
mimeType
)
;
C
.
Encoding
int
encoding
=
passthrough
?
getEncodingForMimeType
(
mimeType
)
:
pcmEncoding
;
boolean
flush
=
false
;
if
(
!
passthrough
)
{
pcmFrameSize
=
Util
.
getPcmFrameSize
(
pcmEncoding
channelCount
)
;
channelMappingAudioProcessor
.
setChannelMap
(
outputChannels
)
;
for
(
AudioProcessor
audioProcessor
:
availableAudioProcessors
)
{
try
{
flush
|
=
audioProcessor
.
configure
(
sampleRate
channelCount
encoding
)
;
}
catch
(
AudioProcessor
.
UnhandledFormatException
e
)
{
throw
new
ConfigurationException
(
e
)
;
}
if
(
audioProcessor
.
isActive
(
)
)
{
channelCount
=
audioProcessor
.
getOutputChannelCount
(
)
;
encoding
=
audioProcessor
.
getOutputEncoding
(
)
;
}
}
if
(
flush
)
{
resetAudioProcessors
(
)
;
}
}
int
channelConfig
;
switch
(
channelCount
)
{
case
1
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_MONO
;
break
;
case
2
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_STEREO
;
break
;
case
3
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_STEREO
|
AudioFormat
.
CHANNEL_OUT_FRONT_CENTER
;
break
;
case
4
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_QUAD
;
break
;
case
5
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_QUAD
|
AudioFormat
.
CHANNEL_OUT_FRONT_CENTER
;
break
;
case
6
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_5POINT1
;
break
;
case
7
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_5POINT1
|
AudioFormat
.
CHANNEL_OUT_BACK_CENTER
;
break
;
case
8
:
channelConfig
=
C
.
CHANNEL_OUT_7POINT1_SURROUND
;
break
;
default
:
throw
new
ConfigurationException
(
"
Unsupported
channel
count
:
"
+
channelCount
)
;
}
if
(
Util
.
SDK_INT
<
=
23
&
&
"
foster
"
.
equals
(
Util
.
DEVICE
)
&
&
"
NVIDIA
"
.
equals
(
Util
.
MANUFACTURER
)
)
{
switch
(
channelCount
)
{
case
7
:
channelConfig
=
C
.
CHANNEL_OUT_7POINT1_SURROUND
;
break
;
case
3
:
case
5
:
channelConfig
=
AudioFormat
.
CHANNEL_OUT_5POINT1
;
break
;
default
:
break
;
}
}
if
(
Util
.
SDK_INT
<
=
25
&
&
"
fugu
"
.
equals
(
Util
.
DEVICE
)
&
&
passthrough
&
&
channelCount
=
=
1
)
{
channelConfig
=
AudioFormat
.
CHANNEL_OUT_STEREO
;
}
if
(
!
flush
&
&
isInitialized
(
)
&
&
this
.
encoding
=
=
encoding
&
&
this
.
sampleRate
=
=
sampleRate
&
&
this
.
channelConfig
=
=
channelConfig
)
{
return
;
}
reset
(
)
;
this
.
encoding
=
encoding
;
this
.
passthrough
=
passthrough
;
this
.
sampleRate
=
sampleRate
;
this
.
channelConfig
=
channelConfig
;
outputEncoding
=
passthrough
?
encoding
:
C
.
ENCODING_PCM_16BIT
;
outputPcmFrameSize
=
Util
.
getPcmFrameSize
(
C
.
ENCODING_PCM_16BIT
channelCount
)
;
if
(
specifiedBufferSize
!
=
0
)
{
bufferSize
=
specifiedBufferSize
;
}
else
if
(
passthrough
)
{
if
(
outputEncoding
=
=
C
.
ENCODING_AC3
|
|
outputEncoding
=
=
C
.
ENCODING_E_AC3
)
{
bufferSize
=
(
int
)
(
PASSTHROUGH_BUFFER_DURATION_US
*
80
*
1024
/
C
.
MICROS_PER_SECOND
)
;
}
else
{
bufferSize
=
(
int
)
(
PASSTHROUGH_BUFFER_DURATION_US
*
192
*
1024
/
C
.
MICROS_PER_SECOND
)
;
}
}
else
{
int
minBufferSize
=
android
.
media
.
AudioTrack
.
getMinBufferSize
(
sampleRate
channelConfig
outputEncoding
)
;
Assertions
.
checkState
(
minBufferSize
!
=
ERROR_BAD_VALUE
)
;
int
multipliedBufferSize
=
minBufferSize
*
BUFFER_MULTIPLICATION_FACTOR
;
int
minAppBufferSize
=
(
int
)
durationUsToFrames
(
MIN_BUFFER_DURATION_US
)
*
outputPcmFrameSize
;
int
maxAppBufferSize
=
(
int
)
Math
.
max
(
minBufferSize
durationUsToFrames
(
MAX_BUFFER_DURATION_US
)
*
outputPcmFrameSize
)
;
bufferSize
=
multipliedBufferSize
<
minAppBufferSize
?
minAppBufferSize
:
multipliedBufferSize
>
maxAppBufferSize
?
maxAppBufferSize
:
multipliedBufferSize
;
}
bufferSizeUs
=
passthrough
?
C
.
TIME_UNSET
:
framesToDurationUs
(
bufferSize
/
outputPcmFrameSize
)
;
setPlaybackParameters
(
playbackParameters
)
;
}
private
void
resetAudioProcessors
(
)
{
ArrayList
<
AudioProcessor
>
newAudioProcessors
=
new
ArrayList
<
>
(
)
;
for
(
AudioProcessor
audioProcessor
:
availableAudioProcessors
)
{
if
(
audioProcessor
.
isActive
(
)
)
{
newAudioProcessors
.
add
(
audioProcessor
)
;
}
else
{
audioProcessor
.
flush
(
)
;
}
}
int
count
=
newAudioProcessors
.
size
(
)
;
audioProcessors
=
newAudioProcessors
.
toArray
(
new
AudioProcessor
[
count
]
)
;
outputBuffers
=
new
ByteBuffer
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
AudioProcessor
audioProcessor
=
audioProcessors
[
i
]
;
audioProcessor
.
flush
(
)
;
outputBuffers
[
i
]
=
audioProcessor
.
getOutput
(
)
;
}
}
private
void
initialize
(
)
throws
InitializationException
{
releasingConditionVariable
.
block
(
)
;
if
(
tunneling
)
{
audioTrack
=
createHwAvSyncAudioTrackV21
(
sampleRate
channelConfig
outputEncoding
bufferSize
audioSessionId
)
;
}
else
if
(
audioSessionId
=
=
C
.
AUDIO_SESSION_ID_UNSET
)
{
audioTrack
=
new
android
.
media
.
AudioTrack
(
streamType
sampleRate
channelConfig
outputEncoding
bufferSize
MODE_STREAM
)
;
}
else
{
audioTrack
=
new
android
.
media
.
AudioTrack
(
streamType
sampleRate
channelConfig
outputEncoding
bufferSize
MODE_STREAM
audioSessionId
)
;
}
checkAudioTrackInitialized
(
)
;
int
audioSessionId
=
audioTrack
.
getAudioSessionId
(
)
;
if
(
enablePreV21AudioSessionWorkaround
)
{
if
(
Util
.
SDK_INT
<
21
)
{
if
(
keepSessionIdAudioTrack
!
=
null
&
&
audioSessionId
!
=
keepSessionIdAudioTrack
.
getAudioSessionId
(
)
)
{
releaseKeepSessionIdAudioTrack
(
)
;
}
if
(
keepSessionIdAudioTrack
=
=
null
)
{
int
sampleRate
=
4000
;
int
channelConfig
=
AudioFormat
.
CHANNEL_OUT_MONO
;
C
.
PcmEncoding
int
encoding
=
C
.
ENCODING_PCM_16BIT
;
int
bufferSize
=
2
;
keepSessionIdAudioTrack
=
new
android
.
media
.
AudioTrack
(
streamType
sampleRate
channelConfig
encoding
bufferSize
MODE_STATIC
audioSessionId
)
;
}
}
}
if
(
this
.
audioSessionId
!
=
audioSessionId
)
{
this
.
audioSessionId
=
audioSessionId
;
listener
.
onAudioSessionId
(
audioSessionId
)
;
}
audioTrackUtil
.
reconfigure
(
audioTrack
needsPassthroughWorkarounds
(
)
)
;
setVolumeInternal
(
)
;
hasData
=
false
;
}
public
void
play
(
)
{
playing
=
true
;
if
(
isInitialized
(
)
)
{
resumeSystemTimeUs
=
System
.
nanoTime
(
)
/
1000
;
audioTrack
.
play
(
)
;
}
}
public
void
handleDiscontinuity
(
)
{
if
(
startMediaTimeState
=
=
START_IN_SYNC
)
{
startMediaTimeState
=
START_NEED_SYNC
;
}
}
SuppressWarnings
(
"
ReferenceEquality
"
)
public
boolean
handleBuffer
(
ByteBuffer
buffer
long
presentationTimeUs
)
throws
InitializationException
WriteException
{
Assertions
.
checkArgument
(
inputBuffer
=
=
null
|
|
buffer
=
=
inputBuffer
)
;
if
(
!
isInitialized
(
)
)
{
initialize
(
)
;
if
(
playing
)
{
play
(
)
;
}
}
if
(
needsPassthroughWorkarounds
(
)
)
{
if
(
audioTrack
.
getPlayState
(
)
=
=
PLAYSTATE_PAUSED
)
{
hasData
=
false
;
return
false
;
}
if
(
audioTrack
.
getPlayState
(
)
=
=
PLAYSTATE_STOPPED
&
&
audioTrackUtil
.
getPlaybackHeadPosition
(
)
!
=
0
)
{
return
false
;
}
}
boolean
hadData
=
hasData
;
hasData
=
hasPendingData
(
)
;
if
(
hadData
&
&
!
hasData
&
&
audioTrack
.
getPlayState
(
)
!
=
PLAYSTATE_STOPPED
)
{
long
elapsedSinceLastFeedMs
=
SystemClock
.
elapsedRealtime
(
)
-
lastFeedElapsedRealtimeMs
;
listener
.
onUnderrun
(
bufferSize
C
.
usToMs
(
bufferSizeUs
)
elapsedSinceLastFeedMs
)
;
}
if
(
inputBuffer
=
=
null
)
{
if
(
!
buffer
.
hasRemaining
(
)
)
{
return
true
;
}
if
(
passthrough
&
&
framesPerEncodedSample
=
=
0
)
{
framesPerEncodedSample
=
getFramesPerEncodedSample
(
outputEncoding
buffer
)
;
}
if
(
drainingPlaybackParameters
!
=
null
)
{
if
(
!
drainAudioProcessorsToEndOfStream
(
)
)
{
return
false
;
}
playbackParametersCheckpoints
.
add
(
new
PlaybackParametersCheckpoint
(
drainingPlaybackParameters
Math
.
max
(
0
presentationTimeUs
)
framesToDurationUs
(
getWrittenFrames
(
)
)
)
)
;
drainingPlaybackParameters
=
null
;
resetAudioProcessors
(
)
;
}
if
(
startMediaTimeState
=
=
START_NOT_SET
)
{
startMediaTimeUs
=
Math
.
max
(
0
presentationTimeUs
)
;
startMediaTimeState
=
START_IN_SYNC
;
}
else
{
long
expectedPresentationTimeUs
=
startMediaTimeUs
+
framesToDurationUs
(
getSubmittedFrames
(
)
)
;
if
(
startMediaTimeState
=
=
START_IN_SYNC
&
&
Math
.
abs
(
expectedPresentationTimeUs
-
presentationTimeUs
)
>
200000
)
{
Log
.
e
(
TAG
"
Discontinuity
detected
[
expected
"
+
expectedPresentationTimeUs
+
"
got
"
+
presentationTimeUs
+
"
]
"
)
;
startMediaTimeState
=
START_NEED_SYNC
;
}
if
(
startMediaTimeState
=
=
START_NEED_SYNC
)
{
startMediaTimeUs
+
=
(
presentationTimeUs
-
expectedPresentationTimeUs
)
;
startMediaTimeState
=
START_IN_SYNC
;
listener
.
onPositionDiscontinuity
(
)
;
}
}
if
(
passthrough
)
{
submittedEncodedFrames
+
=
framesPerEncodedSample
;
}
else
{
submittedPcmBytes
+
=
buffer
.
remaining
(
)
;
}
inputBuffer
=
buffer
;
}
if
(
passthrough
)
{
writeBuffer
(
inputBuffer
presentationTimeUs
)
;
}
else
{
processBuffers
(
presentationTimeUs
)
;
}
if
(
!
inputBuffer
.
hasRemaining
(
)
)
{
inputBuffer
=
null
;
return
true
;
}
return
false
;
}
private
void
processBuffers
(
long
avSyncPresentationTimeUs
)
throws
WriteException
{
int
count
=
audioProcessors
.
length
;
int
index
=
count
;
while
(
index
>
=
0
)
{
ByteBuffer
input
=
index
>
0
?
outputBuffers
[
index
-
1
]
:
(
inputBuffer
!
=
null
?
inputBuffer
:
AudioProcessor
.
EMPTY_BUFFER
)
;
if
(
index
=
=
count
)
{
writeBuffer
(
input
avSyncPresentationTimeUs
)
;
}
else
{
AudioProcessor
audioProcessor
=
audioProcessors
[
index
]
;
audioProcessor
.
queueInput
(
input
)
;
ByteBuffer
output
=
audioProcessor
.
getOutput
(
)
;
outputBuffers
[
index
]
=
output
;
if
(
output
.
hasRemaining
(
)
)
{
index
+
+
;
continue
;
}
}
if
(
input
.
hasRemaining
(
)
)
{
return
;
}
index
-
-
;
}
}
SuppressWarnings
(
"
ReferenceEquality
"
)
private
boolean
writeBuffer
(
ByteBuffer
buffer
long
avSyncPresentationTimeUs
)
throws
WriteException
{
if
(
!
buffer
.
hasRemaining
(
)
)
{
return
true
;
}
if
(
outputBuffer
!
=
null
)
{
Assertions
.
checkArgument
(
outputBuffer
=
=
buffer
)
;
}
else
{
outputBuffer
=
buffer
;
if
(
Util
.
SDK_INT
<
21
)
{
int
bytesRemaining
=
buffer
.
remaining
(
)
;
if
(
preV21OutputBuffer
=
=
null
|
|
preV21OutputBuffer
.
length
<
bytesRemaining
)
{
preV21OutputBuffer
=
new
byte
[
bytesRemaining
]
;
}
int
originalPosition
=
buffer
.
position
(
)
;
buffer
.
get
(
preV21OutputBuffer
0
bytesRemaining
)
;
buffer
.
position
(
originalPosition
)
;
preV21OutputBufferOffset
=
0
;
}
}
int
bytesRemaining
=
buffer
.
remaining
(
)
;
int
bytesWritten
=
0
;
if
(
Util
.
SDK_INT
<
21
)
{
int
bytesPending
=
(
int
)
(
writtenPcmBytes
-
(
audioTrackUtil
.
getPlaybackHeadPosition
(
)
*
outputPcmFrameSize
)
)
;
int
bytesToWrite
=
bufferSize
-
bytesPending
;
if
(
bytesToWrite
>
0
)
{
bytesToWrite
=
Math
.
min
(
bytesRemaining
bytesToWrite
)
;
bytesWritten
=
audioTrack
.
write
(
preV21OutputBuffer
preV21OutputBufferOffset
bytesToWrite
)
;
if
(
bytesWritten
>
0
)
{
preV21OutputBufferOffset
+
=
bytesWritten
;
buffer
.
position
(
buffer
.
position
(
)
+
bytesWritten
)
;
}
}
}
else
if
(
tunneling
)
{
Assertions
.
checkState
(
avSyncPresentationTimeUs
!
=
C
.
TIME_UNSET
)
;
bytesWritten
=
writeNonBlockingWithAvSyncV21
(
audioTrack
buffer
bytesRemaining
avSyncPresentationTimeUs
)
;
}
else
{
bytesWritten
=
writeNonBlockingV21
(
audioTrack
buffer
bytesRemaining
)
;
}
lastFeedElapsedRealtimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
if
(
bytesWritten
<
0
)
{
throw
new
WriteException
(
bytesWritten
)
;
}
if
(
!
passthrough
)
{
writtenPcmBytes
+
=
bytesWritten
;
}
if
(
bytesWritten
=
=
bytesRemaining
)
{
if
(
passthrough
)
{
writtenEncodedFrames
+
=
framesPerEncodedSample
;
}
outputBuffer
=
null
;
return
true
;
}
return
false
;
}
public
void
playToEndOfStream
(
)
throws
WriteException
{
if
(
handledEndOfStream
|
|
!
isInitialized
(
)
)
{
return
;
}
if
(
drainAudioProcessorsToEndOfStream
(
)
)
{
audioTrackUtil
.
handleEndOfStream
(
getWrittenFrames
(
)
)
;
bytesUntilNextAvSync
=
0
;
handledEndOfStream
=
true
;
}
}
private
boolean
drainAudioProcessorsToEndOfStream
(
)
throws
WriteException
{
boolean
audioProcessorNeedsEndOfStream
=
false
;
if
(
drainingAudioProcessorIndex
=
=
C
.
INDEX_UNSET
)
{
drainingAudioProcessorIndex
=
passthrough
?
audioProcessors
.
length
:
0
;
audioProcessorNeedsEndOfStream
=
true
;
}
while
(
drainingAudioProcessorIndex
<
audioProcessors
.
length
)
{
AudioProcessor
audioProcessor
=
audioProcessors
[
drainingAudioProcessorIndex
]
;
if
(
audioProcessorNeedsEndOfStream
)
{
audioProcessor
.
queueEndOfStream
(
)
;
}
processBuffers
(
C
.
TIME_UNSET
)
;
if
(
!
audioProcessor
.
isEnded
(
)
)
{
return
false
;
}
audioProcessorNeedsEndOfStream
=
true
;
drainingAudioProcessorIndex
+
+
;
}
if
(
outputBuffer
!
=
null
)
{
writeBuffer
(
outputBuffer
C
.
TIME_UNSET
)
;
if
(
outputBuffer
!
=
null
)
{
return
false
;
}
}
drainingAudioProcessorIndex
=
C
.
INDEX_UNSET
;
return
true
;
}
public
boolean
isEnded
(
)
{
return
!
isInitialized
(
)
|
|
(
handledEndOfStream
&
&
!
hasPendingData
(
)
)
;
}
public
boolean
hasPendingData
(
)
{
return
isInitialized
(
)
&
&
(
getWrittenFrames
(
)
>
audioTrackUtil
.
getPlaybackHeadPosition
(
)
|
|
overrideHasPendingData
(
)
)
;
}
public
PlaybackParameters
setPlaybackParameters
(
PlaybackParameters
playbackParameters
)
{
if
(
passthrough
)
{
this
.
playbackParameters
=
PlaybackParameters
.
DEFAULT
;
return
this
.
playbackParameters
;
}
playbackParameters
=
new
PlaybackParameters
(
sonicAudioProcessor
.
setSpeed
(
playbackParameters
.
speed
)
sonicAudioProcessor
.
setPitch
(
playbackParameters
.
pitch
)
)
;
PlaybackParameters
lastSetPlaybackParameters
=
drainingPlaybackParameters
!
=
null
?
drainingPlaybackParameters
:
!
playbackParametersCheckpoints
.
isEmpty
(
)
?
playbackParametersCheckpoints
.
getLast
(
)
.
playbackParameters
:
this
.
playbackParameters
;
if
(
!
playbackParameters
.
equals
(
lastSetPlaybackParameters
)
)
{
if
(
isInitialized
(
)
)
{
drainingPlaybackParameters
=
playbackParameters
;
}
else
{
this
.
playbackParameters
=
playbackParameters
;
}
}
return
this
.
playbackParameters
;
}
public
PlaybackParameters
getPlaybackParameters
(
)
{
return
playbackParameters
;
}
public
void
setStreamType
(
C
.
StreamType
int
streamType
)
{
if
(
this
.
streamType
=
=
streamType
)
{
return
;
}
this
.
streamType
=
streamType
;
if
(
tunneling
)
{
return
;
}
reset
(
)
;
audioSessionId
=
C
.
AUDIO_SESSION_ID_UNSET
;
}
public
void
setAudioSessionId
(
int
audioSessionId
)
{
if
(
this
.
audioSessionId
!
=
audioSessionId
)
{
this
.
audioSessionId
=
audioSessionId
;
reset
(
)
;
}
}
public
void
enableTunnelingV21
(
int
tunnelingAudioSessionId
)
{
Assertions
.
checkState
(
Util
.
SDK_INT
>
=
21
)
;
if
(
!
tunneling
|
|
audioSessionId
!
=
tunnelingAudioSessionId
)
{
tunneling
=
true
;
audioSessionId
=
tunnelingAudioSessionId
;
reset
(
)
;
}
}
public
void
disableTunneling
(
)
{
if
(
tunneling
)
{
tunneling
=
false
;
audioSessionId
=
C
.
AUDIO_SESSION_ID_UNSET
;
reset
(
)
;
}
}
public
void
setVolume
(
float
volume
)
{
if
(
this
.
volume
!
=
volume
)
{
this
.
volume
=
volume
;
setVolumeInternal
(
)
;
}
}
private
void
setVolumeInternal
(
)
{
if
(
!
isInitialized
(
)
)
{
}
else
if
(
Util
.
SDK_INT
>
=
21
)
{
setVolumeInternalV21
(
audioTrack
volume
)
;
}
else
{
setVolumeInternalV3
(
audioTrack
volume
)
;
}
}
public
void
pause
(
)
{
playing
=
false
;
if
(
isInitialized
(
)
)
{
resetSyncParams
(
)
;
audioTrackUtil
.
pause
(
)
;
}
}
public
void
reset
(
)
{
if
(
isInitialized
(
)
)
{
submittedPcmBytes
=
0
;
submittedEncodedFrames
=
0
;
writtenPcmBytes
=
0
;
writtenEncodedFrames
=
0
;
framesPerEncodedSample
=
0
;
if
(
drainingPlaybackParameters
!
=
null
)
{
playbackParameters
=
drainingPlaybackParameters
;
drainingPlaybackParameters
=
null
;
}
else
if
(
!
playbackParametersCheckpoints
.
isEmpty
(
)
)
{
playbackParameters
=
playbackParametersCheckpoints
.
getLast
(
)
.
playbackParameters
;
}
playbackParametersCheckpoints
.
clear
(
)
;
playbackParametersOffsetUs
=
0
;
playbackParametersPositionUs
=
0
;
inputBuffer
=
null
;
outputBuffer
=
null
;
for
(
int
i
=
0
;
i
<
audioProcessors
.
length
;
i
+
+
)
{
AudioProcessor
audioProcessor
=
audioProcessors
[
i
]
;
audioProcessor
.
flush
(
)
;
outputBuffers
[
i
]
=
audioProcessor
.
getOutput
(
)
;
}
handledEndOfStream
=
false
;
drainingAudioProcessorIndex
=
C
.
INDEX_UNSET
;
avSyncHeader
=
null
;
bytesUntilNextAvSync
=
0
;
startMediaTimeState
=
START_NOT_SET
;
latencyUs
=
0
;
resetSyncParams
(
)
;
int
playState
=
audioTrack
.
getPlayState
(
)
;
if
(
playState
=
=
PLAYSTATE_PLAYING
)
{
audioTrack
.
pause
(
)
;
}
final
android
.
media
.
AudioTrack
toRelease
=
audioTrack
;
audioTrack
=
null
;
audioTrackUtil
.
reconfigure
(
null
false
)
;
releasingConditionVariable
.
close
(
)
;
new
Thread
(
)
{
Override
public
void
run
(
)
{
try
{
toRelease
.
flush
(
)
;
toRelease
.
release
(
)
;
}
finally
{
releasingConditionVariable
.
open
(
)
;
}
}
}
.
start
(
)
;
}
}
public
void
release
(
)
{
reset
(
)
;
releaseKeepSessionIdAudioTrack
(
)
;
for
(
AudioProcessor
audioProcessor
:
availableAudioProcessors
)
{
audioProcessor
.
reset
(
)
;
}
audioSessionId
=
C
.
AUDIO_SESSION_ID_UNSET
;
playing
=
false
;
}
private
void
releaseKeepSessionIdAudioTrack
(
)
{
if
(
keepSessionIdAudioTrack
=
=
null
)
{
return
;
}
final
android
.
media
.
AudioTrack
toRelease
=
keepSessionIdAudioTrack
;
keepSessionIdAudioTrack
=
null
;
new
Thread
(
)
{
Override
public
void
run
(
)
{
toRelease
.
release
(
)
;
}
}
.
start
(
)
;
}
private
boolean
hasCurrentPositionUs
(
)
{
return
isInitialized
(
)
&
&
startMediaTimeState
!
=
START_NOT_SET
;
}
private
long
applySpeedup
(
long
positionUs
)
{
while
(
!
playbackParametersCheckpoints
.
isEmpty
(
)
&
&
positionUs
>
=
playbackParametersCheckpoints
.
getFirst
(
)
.
positionUs
)
{
PlaybackParametersCheckpoint
checkpoint
=
playbackParametersCheckpoints
.
remove
(
)
;
playbackParameters
=
checkpoint
.
playbackParameters
;
playbackParametersPositionUs
=
checkpoint
.
positionUs
;
playbackParametersOffsetUs
=
checkpoint
.
mediaTimeUs
-
startMediaTimeUs
;
}
if
(
playbackParameters
.
speed
=
=
1f
)
{
return
positionUs
+
playbackParametersOffsetUs
-
playbackParametersPositionUs
;
}
if
(
playbackParametersCheckpoints
.
isEmpty
(
)
&
&
sonicAudioProcessor
.
getOutputByteCount
(
)
>
=
SONIC_MIN_BYTES_FOR_SPEEDUP
)
{
return
playbackParametersOffsetUs
+
Util
.
scaleLargeTimestamp
(
positionUs
-
playbackParametersPositionUs
sonicAudioProcessor
.
getInputByteCount
(
)
sonicAudioProcessor
.
getOutputByteCount
(
)
)
;
}
return
playbackParametersOffsetUs
+
(
long
)
(
(
double
)
playbackParameters
.
speed
*
(
positionUs
-
playbackParametersPositionUs
)
)
;
}
private
void
maybeSampleSyncParams
(
)
{
long
playbackPositionUs
=
audioTrackUtil
.
getPositionUs
(
)
;
if
(
playbackPositionUs
=
=
0
)
{
return
;
}
long
systemClockUs
=
System
.
nanoTime
(
)
/
1000
;
if
(
systemClockUs
-
lastPlayheadSampleTimeUs
>
=
MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US
)
{
playheadOffsets
[
nextPlayheadOffsetIndex
]
=
playbackPositionUs
-
systemClockUs
;
nextPlayheadOffsetIndex
=
(
nextPlayheadOffsetIndex
+
1
)
%
MAX_PLAYHEAD_OFFSET_COUNT
;
if
(
playheadOffsetCount
<
MAX_PLAYHEAD_OFFSET_COUNT
)
{
playheadOffsetCount
+
+
;
}
lastPlayheadSampleTimeUs
=
systemClockUs
;
smoothedPlayheadOffsetUs
=
0
;
for
(
int
i
=
0
;
i
<
playheadOffsetCount
;
i
+
+
)
{
smoothedPlayheadOffsetUs
+
=
playheadOffsets
[
i
]
/
playheadOffsetCount
;
}
}
if
(
needsPassthroughWorkarounds
(
)
)
{
return
;
}
if
(
systemClockUs
-
lastTimestampSampleTimeUs
>
=
MIN_TIMESTAMP_SAMPLE_INTERVAL_US
)
{
audioTimestampSet
=
audioTrackUtil
.
updateTimestamp
(
)
;
if
(
audioTimestampSet
)
{
long
audioTimestampUs
=
audioTrackUtil
.
getTimestampNanoTime
(
)
/
1000
;
long
audioTimestampFramePosition
=
audioTrackUtil
.
getTimestampFramePosition
(
)
;
if
(
audioTimestampUs
<
resumeSystemTimeUs
)
{
audioTimestampSet
=
false
;
}
else
if
(
Math
.
abs
(
audioTimestampUs
-
systemClockUs
)
>
MAX_AUDIO_TIMESTAMP_OFFSET_US
)
{
String
message
=
"
Spurious
audio
timestamp
(
system
clock
mismatch
)
:
"
+
audioTimestampFramePosition
+
"
"
+
audioTimestampUs
+
"
"
+
systemClockUs
+
"
"
+
playbackPositionUs
;
if
(
failOnSpuriousAudioTimestamp
)
{
throw
new
InvalidAudioTrackTimestampException
(
message
)
;
}
Log
.
w
(
TAG
message
)
;
audioTimestampSet
=
false
;
}
else
if
(
Math
.
abs
(
framesToDurationUs
(
audioTimestampFramePosition
)
-
playbackPositionUs
)
>
MAX_AUDIO_TIMESTAMP_OFFSET_US
)
{
String
message
=
"
Spurious
audio
timestamp
(
frame
position
mismatch
)
:
"
+
audioTimestampFramePosition
+
"
"
+
audioTimestampUs
+
"
"
+
systemClockUs
+
"
"
+
playbackPositionUs
;
if
(
failOnSpuriousAudioTimestamp
)
{
throw
new
InvalidAudioTrackTimestampException
(
message
)
;
}
Log
.
w
(
TAG
message
)
;
audioTimestampSet
=
false
;
}
}
if
(
getLatencyMethod
!
=
null
&
&
!
passthrough
)
{
try
{
latencyUs
=
(
Integer
)
getLatencyMethod
.
invoke
(
audioTrack
(
Object
[
]
)
null
)
*
1000L
-
bufferSizeUs
;
latencyUs
=
Math
.
max
(
latencyUs
0
)
;
if
(
latencyUs
>
MAX_LATENCY_US
)
{
Log
.
w
(
TAG
"
Ignoring
impossibly
large
audio
latency
:
"
+
latencyUs
)
;
latencyUs
=
0
;
}
}
catch
(
Exception
e
)
{
getLatencyMethod
=
null
;
}
}
lastTimestampSampleTimeUs
=
systemClockUs
;
}
}
private
void
checkAudioTrackInitialized
(
)
throws
InitializationException
{
int
state
=
audioTrack
.
getState
(
)
;
if
(
state
=
=
STATE_INITIALIZED
)
{
return
;
}
try
{
audioTrack
.
release
(
)
;
}
catch
(
Exception
e
)
{
}
finally
{
audioTrack
=
null
;
}
throw
new
InitializationException
(
state
sampleRate
channelConfig
bufferSize
)
;
}
private
boolean
isInitialized
(
)
{
return
audioTrack
!
=
null
;
}
private
long
framesToDurationUs
(
long
frameCount
)
{
return
(
frameCount
*
C
.
MICROS_PER_SECOND
)
/
sampleRate
;
}
private
long
durationUsToFrames
(
long
durationUs
)
{
return
(
durationUs
*
sampleRate
)
/
C
.
MICROS_PER_SECOND
;
}
private
long
getSubmittedFrames
(
)
{
return
passthrough
?
submittedEncodedFrames
:
(
submittedPcmBytes
/
pcmFrameSize
)
;
}
private
long
getWrittenFrames
(
)
{
return
passthrough
?
writtenEncodedFrames
:
(
writtenPcmBytes
/
outputPcmFrameSize
)
;
}
private
void
resetSyncParams
(
)
{
smoothedPlayheadOffsetUs
=
0
;
playheadOffsetCount
=
0
;
nextPlayheadOffsetIndex
=
0
;
lastPlayheadSampleTimeUs
=
0
;
audioTimestampSet
=
false
;
lastTimestampSampleTimeUs
=
0
;
}
private
boolean
needsPassthroughWorkarounds
(
)
{
return
Util
.
SDK_INT
<
23
&
&
(
outputEncoding
=
=
C
.
ENCODING_AC3
|
|
outputEncoding
=
=
C
.
ENCODING_E_AC3
)
;
}
private
boolean
overrideHasPendingData
(
)
{
return
needsPassthroughWorkarounds
(
)
&
&
audioTrack
.
getPlayState
(
)
=
=
PLAYSTATE_PAUSED
&
&
audioTrack
.
getPlaybackHeadPosition
(
)
=
=
0
;
}
TargetApi
(
21
)
private
static
android
.
media
.
AudioTrack
createHwAvSyncAudioTrackV21
(
int
sampleRate
int
channelConfig
int
encoding
int
bufferSize
int
sessionId
)
{
AudioAttributes
attributesBuilder
=
new
AudioAttributes
.
Builder
(
)
.
setUsage
(
AudioAttributes
.
USAGE_MEDIA
)
.
setContentType
(
AudioAttributes
.
CONTENT_TYPE_MOVIE
)
.
setFlags
(
AudioAttributes
.
FLAG_HW_AV_SYNC
)
.
build
(
)
;
AudioFormat
format
=
new
AudioFormat
.
Builder
(
)
.
setChannelMask
(
channelConfig
)
.
setEncoding
(
encoding
)
.
setSampleRate
(
sampleRate
)
.
build
(
)
;
return
new
android
.
media
.
AudioTrack
(
attributesBuilder
format
bufferSize
MODE_STREAM
sessionId
)
;
}
C
.
Encoding
private
static
int
getEncodingForMimeType
(
String
mimeType
)
{
switch
(
mimeType
)
{
case
MimeTypes
.
AUDIO_AC3
:
return
C
.
ENCODING_AC3
;
case
MimeTypes
.
AUDIO_E_AC3
:
return
C
.
ENCODING_E_AC3
;
case
MimeTypes
.
AUDIO_DTS
:
return
C
.
ENCODING_DTS
;
case
MimeTypes
.
AUDIO_DTS_HD
:
return
C
.
ENCODING_DTS_HD
;
default
:
return
C
.
ENCODING_INVALID
;
}
}
private
static
int
getFramesPerEncodedSample
(
C
.
Encoding
int
encoding
ByteBuffer
buffer
)
{
if
(
encoding
=
=
C
.
ENCODING_DTS
|
|
encoding
=
=
C
.
ENCODING_DTS_HD
)
{
return
DtsUtil
.
parseDtsAudioSampleCount
(
buffer
)
;
}
else
if
(
encoding
=
=
C
.
ENCODING_AC3
)
{
return
Ac3Util
.
getAc3SyncframeAudioSampleCount
(
)
;
}
else
if
(
encoding
=
=
C
.
ENCODING_E_AC3
)
{
return
Ac3Util
.
parseEAc3SyncframeAudioSampleCount
(
buffer
)
;
}
else
{
throw
new
IllegalStateException
(
"
Unexpected
audio
encoding
:
"
+
encoding
)
;
}
}
TargetApi
(
21
)
private
static
int
writeNonBlockingV21
(
android
.
media
.
AudioTrack
audioTrack
ByteBuffer
buffer
int
size
)
{
return
audioTrack
.
write
(
buffer
size
WRITE_NON_BLOCKING
)
;
}
TargetApi
(
21
)
private
int
writeNonBlockingWithAvSyncV21
(
android
.
media
.
AudioTrack
audioTrack
ByteBuffer
buffer
int
size
long
presentationTimeUs
)
{
if
(
avSyncHeader
=
=
null
)
{
avSyncHeader
=
ByteBuffer
.
allocate
(
16
)
;
avSyncHeader
.
order
(
ByteOrder
.
BIG_ENDIAN
)
;
avSyncHeader
.
putInt
(
0x55550001
)
;
}
if
(
bytesUntilNextAvSync
=
=
0
)
{
avSyncHeader
.
putInt
(
4
size
)
;
avSyncHeader
.
putLong
(
8
presentationTimeUs
*
1000
)
;
avSyncHeader
.
position
(
0
)
;
bytesUntilNextAvSync
=
size
;
}
int
avSyncHeaderBytesRemaining
=
avSyncHeader
.
remaining
(
)
;
if
(
avSyncHeaderBytesRemaining
>
0
)
{
int
result
=
audioTrack
.
write
(
avSyncHeader
avSyncHeaderBytesRemaining
WRITE_NON_BLOCKING
)
;
if
(
result
<
0
)
{
bytesUntilNextAvSync
=
0
;
return
result
;
}
if
(
result
<
avSyncHeaderBytesRemaining
)
{
return
0
;
}
}
int
result
=
writeNonBlockingV21
(
audioTrack
buffer
size
)
;
if
(
result
<
0
)
{
bytesUntilNextAvSync
=
0
;
return
result
;
}
bytesUntilNextAvSync
-
=
result
;
return
result
;
}
TargetApi
(
21
)
private
static
void
setVolumeInternalV21
(
android
.
media
.
AudioTrack
audioTrack
float
volume
)
{
audioTrack
.
setVolume
(
volume
)
;
}
SuppressWarnings
(
"
deprecation
"
)
private
static
void
setVolumeInternalV3
(
android
.
media
.
AudioTrack
audioTrack
float
volume
)
{
audioTrack
.
setStereoVolume
(
volume
volume
)
;
}
private
static
class
AudioTrackUtil
{
protected
android
.
media
.
AudioTrack
audioTrack
;
private
boolean
needsPassthroughWorkaround
;
private
int
sampleRate
;
private
long
lastRawPlaybackHeadPosition
;
private
long
rawPlaybackHeadWrapCount
;
private
long
passthroughWorkaroundPauseOffset
;
private
long
stopTimestampUs
;
private
long
stopPlaybackHeadPosition
;
private
long
endPlaybackHeadPosition
;
public
void
reconfigure
(
android
.
media
.
AudioTrack
audioTrack
boolean
needsPassthroughWorkaround
)
{
this
.
audioTrack
=
audioTrack
;
this
.
needsPassthroughWorkaround
=
needsPassthroughWorkaround
;
stopTimestampUs
=
C
.
TIME_UNSET
;
lastRawPlaybackHeadPosition
=
0
;
rawPlaybackHeadWrapCount
=
0
;
passthroughWorkaroundPauseOffset
=
0
;
if
(
audioTrack
!
=
null
)
{
sampleRate
=
audioTrack
.
getSampleRate
(
)
;
}
}
public
void
handleEndOfStream
(
long
writtenFrames
)
{
stopPlaybackHeadPosition
=
getPlaybackHeadPosition
(
)
;
stopTimestampUs
=
SystemClock
.
elapsedRealtime
(
)
*
1000
;
endPlaybackHeadPosition
=
writtenFrames
;
audioTrack
.
stop
(
)
;
}
public
void
pause
(
)
{
if
(
stopTimestampUs
!
=
C
.
TIME_UNSET
)
{
return
;
}
audioTrack
.
pause
(
)
;
}
public
long
getPlaybackHeadPosition
(
)
{
if
(
stopTimestampUs
!
=
C
.
TIME_UNSET
)
{
long
elapsedTimeSinceStopUs
=
(
SystemClock
.
elapsedRealtime
(
)
*
1000
)
-
stopTimestampUs
;
long
framesSinceStop
=
(
elapsedTimeSinceStopUs
*
sampleRate
)
/
C
.
MICROS_PER_SECOND
;
return
Math
.
min
(
endPlaybackHeadPosition
stopPlaybackHeadPosition
+
framesSinceStop
)
;
}
int
state
=
audioTrack
.
getPlayState
(
)
;
if
(
state
=
=
PLAYSTATE_STOPPED
)
{
return
0
;
}
long
rawPlaybackHeadPosition
=
0xFFFFFFFFL
&
audioTrack
.
getPlaybackHeadPosition
(
)
;
if
(
needsPassthroughWorkaround
)
{
if
(
state
=
=
PLAYSTATE_PAUSED
&
&
rawPlaybackHeadPosition
=
=
0
)
{
passthroughWorkaroundPauseOffset
=
lastRawPlaybackHeadPosition
;
}
rawPlaybackHeadPosition
+
=
passthroughWorkaroundPauseOffset
;
}
if
(
lastRawPlaybackHeadPosition
>
rawPlaybackHeadPosition
)
{
rawPlaybackHeadWrapCount
+
+
;
}
lastRawPlaybackHeadPosition
=
rawPlaybackHeadPosition
;
return
rawPlaybackHeadPosition
+
(
rawPlaybackHeadWrapCount
<
<
32
)
;
}
public
long
getPositionUs
(
)
{
return
(
getPlaybackHeadPosition
(
)
*
C
.
MICROS_PER_SECOND
)
/
sampleRate
;
}
public
boolean
updateTimestamp
(
)
{
return
false
;
}
public
long
getTimestampNanoTime
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
public
long
getTimestampFramePosition
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
TargetApi
(
19
)
private
static
class
AudioTrackUtilV19
extends
AudioTrackUtil
{
private
final
AudioTimestamp
audioTimestamp
;
private
long
rawTimestampFramePositionWrapCount
;
private
long
lastRawTimestampFramePosition
;
private
long
lastTimestampFramePosition
;
public
AudioTrackUtilV19
(
)
{
audioTimestamp
=
new
AudioTimestamp
(
)
;
}
Override
public
void
reconfigure
(
android
.
media
.
AudioTrack
audioTrack
boolean
needsPassthroughWorkaround
)
{
super
.
reconfigure
(
audioTrack
needsPassthroughWorkaround
)
;
rawTimestampFramePositionWrapCount
=
0
;
lastRawTimestampFramePosition
=
0
;
lastTimestampFramePosition
=
0
;
}
Override
public
boolean
updateTimestamp
(
)
{
boolean
updated
=
audioTrack
.
getTimestamp
(
audioTimestamp
)
;
if
(
updated
)
{
long
rawFramePosition
=
audioTimestamp
.
framePosition
;
if
(
lastRawTimestampFramePosition
>
rawFramePosition
)
{
rawTimestampFramePositionWrapCount
+
+
;
}
lastRawTimestampFramePosition
=
rawFramePosition
;
lastTimestampFramePosition
=
rawFramePosition
+
(
rawTimestampFramePositionWrapCount
<
<
32
)
;
}
return
updated
;
}
Override
public
long
getTimestampNanoTime
(
)
{
return
audioTimestamp
.
nanoTime
;
}
Override
public
long
getTimestampFramePosition
(
)
{
return
lastTimestampFramePosition
;
}
}
private
static
final
class
PlaybackParametersCheckpoint
{
private
final
PlaybackParameters
playbackParameters
;
private
final
long
mediaTimeUs
;
private
final
long
positionUs
;
private
PlaybackParametersCheckpoint
(
PlaybackParameters
playbackParameters
long
mediaTimeUs
long
positionUs
)
{
this
.
playbackParameters
=
playbackParameters
;
this
.
mediaTimeUs
=
mediaTimeUs
;
this
.
positionUs
=
positionUs
;
}
}
}
