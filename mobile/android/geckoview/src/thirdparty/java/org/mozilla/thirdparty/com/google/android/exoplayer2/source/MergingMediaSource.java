package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
;
import
android
.
support
.
annotation
.
IntDef
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlayer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Timeline
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
public
final
class
MergingMediaSource
implements
MediaSource
{
public
static
final
class
IllegalMergeException
extends
IOException
{
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
REASON_WINDOWS_ARE_DYNAMIC
REASON_PERIOD_COUNT_MISMATCH
}
)
public
interface
Reason
{
}
public
static
final
int
REASON_WINDOWS_ARE_DYNAMIC
=
0
;
public
static
final
int
REASON_PERIOD_COUNT_MISMATCH
=
1
;
Reason
public
final
int
reason
;
public
IllegalMergeException
(
Reason
int
reason
)
{
this
.
reason
=
reason
;
}
}
private
static
final
int
PERIOD_COUNT_UNSET
=
-
1
;
private
final
MediaSource
[
]
mediaSources
;
private
final
ArrayList
<
MediaSource
>
pendingTimelineSources
;
private
final
Timeline
.
Window
window
;
private
Listener
listener
;
private
Timeline
primaryTimeline
;
private
Object
primaryManifest
;
private
int
periodCount
;
private
IllegalMergeException
mergeError
;
public
MergingMediaSource
(
MediaSource
.
.
.
mediaSources
)
{
this
.
mediaSources
=
mediaSources
;
pendingTimelineSources
=
new
ArrayList
<
>
(
Arrays
.
asList
(
mediaSources
)
)
;
window
=
new
Timeline
.
Window
(
)
;
periodCount
=
PERIOD_COUNT_UNSET
;
}
Override
public
void
prepareSource
(
ExoPlayer
player
boolean
isTopLevelSource
Listener
listener
)
{
this
.
listener
=
listener
;
for
(
int
i
=
0
;
i
<
mediaSources
.
length
;
i
+
+
)
{
final
int
sourceIndex
=
i
;
mediaSources
[
sourceIndex
]
.
prepareSource
(
player
false
new
Listener
(
)
{
Override
public
void
onSourceInfoRefreshed
(
Timeline
timeline
Object
manifest
)
{
handleSourceInfoRefreshed
(
sourceIndex
timeline
manifest
)
;
}
}
)
;
}
}
Override
public
void
maybeThrowSourceInfoRefreshError
(
)
throws
IOException
{
if
(
mergeError
!
=
null
)
{
throw
mergeError
;
}
for
(
MediaSource
mediaSource
:
mediaSources
)
{
mediaSource
.
maybeThrowSourceInfoRefreshError
(
)
;
}
}
Override
public
MediaPeriod
createPeriod
(
int
index
Allocator
allocator
long
positionUs
)
{
MediaPeriod
[
]
periods
=
new
MediaPeriod
[
mediaSources
.
length
]
;
for
(
int
i
=
0
;
i
<
periods
.
length
;
i
+
+
)
{
periods
[
i
]
=
mediaSources
[
i
]
.
createPeriod
(
index
allocator
positionUs
)
;
}
return
new
MergingMediaPeriod
(
periods
)
;
}
Override
public
void
releasePeriod
(
MediaPeriod
mediaPeriod
)
{
MergingMediaPeriod
mergingPeriod
=
(
MergingMediaPeriod
)
mediaPeriod
;
for
(
int
i
=
0
;
i
<
mediaSources
.
length
;
i
+
+
)
{
mediaSources
[
i
]
.
releasePeriod
(
mergingPeriod
.
periods
[
i
]
)
;
}
}
Override
public
void
releaseSource
(
)
{
for
(
MediaSource
mediaSource
:
mediaSources
)
{
mediaSource
.
releaseSource
(
)
;
}
}
private
void
handleSourceInfoRefreshed
(
int
sourceIndex
Timeline
timeline
Object
manifest
)
{
if
(
mergeError
=
=
null
)
{
mergeError
=
checkTimelineMerges
(
timeline
)
;
}
if
(
mergeError
!
=
null
)
{
return
;
}
pendingTimelineSources
.
remove
(
mediaSources
[
sourceIndex
]
)
;
if
(
sourceIndex
=
=
0
)
{
primaryTimeline
=
timeline
;
primaryManifest
=
manifest
;
}
if
(
pendingTimelineSources
.
isEmpty
(
)
)
{
listener
.
onSourceInfoRefreshed
(
primaryTimeline
primaryManifest
)
;
}
}
private
IllegalMergeException
checkTimelineMerges
(
Timeline
timeline
)
{
int
windowCount
=
timeline
.
getWindowCount
(
)
;
for
(
int
i
=
0
;
i
<
windowCount
;
i
+
+
)
{
if
(
timeline
.
getWindow
(
i
window
false
)
.
isDynamic
)
{
return
new
IllegalMergeException
(
IllegalMergeException
.
REASON_WINDOWS_ARE_DYNAMIC
)
;
}
}
if
(
periodCount
=
=
PERIOD_COUNT_UNSET
)
{
periodCount
=
timeline
.
getPeriodCount
(
)
;
}
else
if
(
timeline
.
getPeriodCount
(
)
!
=
periodCount
)
{
return
new
IllegalMergeException
(
IllegalMergeException
.
REASON_PERIOD_COUNT_MISMATCH
)
;
}
return
null
;
}
}
