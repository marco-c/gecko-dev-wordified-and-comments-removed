package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
;
import
android
.
os
.
Handler
;
import
android
.
os
.
HandlerThread
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
android
.
os
.
Process
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Pair
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
DefaultMediaClock
.
PlaybackParameterListener
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Player
.
DiscontinuityReason
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaPeriod
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
.
MediaPeriodId
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
.
MediaSourceCaller
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SampleStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroupArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelector
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelectorResult
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
BandwidthMeter
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Clock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
HandlerWrapper
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicBoolean
;
final
class
ExoPlayerImplInternal
implements
Handler
.
Callback
MediaPeriod
.
Callback
TrackSelector
.
InvalidationListener
MediaSourceCaller
PlaybackParameterListener
PlayerMessage
.
Sender
{
private
static
final
String
TAG
=
"
ExoPlayerImplInternal
"
;
public
static
final
int
MSG_PLAYBACK_INFO_CHANGED
=
0
;
public
static
final
int
MSG_PLAYBACK_PARAMETERS_CHANGED
=
1
;
private
static
final
int
MSG_PREPARE
=
0
;
private
static
final
int
MSG_SET_PLAY_WHEN_READY
=
1
;
private
static
final
int
MSG_DO_SOME_WORK
=
2
;
private
static
final
int
MSG_SEEK_TO
=
3
;
private
static
final
int
MSG_SET_PLAYBACK_PARAMETERS
=
4
;
private
static
final
int
MSG_SET_SEEK_PARAMETERS
=
5
;
private
static
final
int
MSG_STOP
=
6
;
private
static
final
int
MSG_RELEASE
=
7
;
private
static
final
int
MSG_REFRESH_SOURCE_INFO
=
8
;
private
static
final
int
MSG_PERIOD_PREPARED
=
9
;
private
static
final
int
MSG_SOURCE_CONTINUE_LOADING_REQUESTED
=
10
;
private
static
final
int
MSG_TRACK_SELECTION_INVALIDATED
=
11
;
private
static
final
int
MSG_SET_REPEAT_MODE
=
12
;
private
static
final
int
MSG_SET_SHUFFLE_ENABLED
=
13
;
private
static
final
int
MSG_SET_FOREGROUND_MODE
=
14
;
private
static
final
int
MSG_SEND_MESSAGE
=
15
;
private
static
final
int
MSG_SEND_MESSAGE_TO_TARGET_THREAD
=
16
;
private
static
final
int
MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL
=
17
;
private
static
final
int
ACTIVE_INTERVAL_MS
=
10
;
private
static
final
int
IDLE_INTERVAL_MS
=
1000
;
private
final
Renderer
[
]
renderers
;
private
final
RendererCapabilities
[
]
rendererCapabilities
;
private
final
TrackSelector
trackSelector
;
private
final
TrackSelectorResult
emptyTrackSelectorResult
;
private
final
LoadControl
loadControl
;
private
final
BandwidthMeter
bandwidthMeter
;
private
final
HandlerWrapper
handler
;
private
final
HandlerThread
internalPlaybackThread
;
private
final
Handler
eventHandler
;
private
final
Timeline
.
Window
window
;
private
final
Timeline
.
Period
period
;
private
final
long
backBufferDurationUs
;
private
final
boolean
retainBackBufferFromKeyframe
;
private
final
DefaultMediaClock
mediaClock
;
private
final
PlaybackInfoUpdate
playbackInfoUpdate
;
private
final
ArrayList
<
PendingMessageInfo
>
pendingMessages
;
private
final
Clock
clock
;
private
final
MediaPeriodQueue
queue
;
SuppressWarnings
(
"
unused
"
)
private
SeekParameters
seekParameters
;
private
PlaybackInfo
playbackInfo
;
private
MediaSource
mediaSource
;
private
Renderer
[
]
enabledRenderers
;
private
boolean
released
;
private
boolean
playWhenReady
;
private
boolean
rebuffering
;
private
boolean
shouldContinueLoading
;
Player
.
RepeatMode
private
int
repeatMode
;
private
boolean
shuffleModeEnabled
;
private
boolean
foregroundMode
;
private
int
pendingPrepareCount
;
private
SeekPosition
pendingInitialSeekPosition
;
private
long
rendererPositionUs
;
private
int
nextPendingMessageIndex
;
private
boolean
deliverPendingMessageAtStartPositionRequired
;
public
ExoPlayerImplInternal
(
Renderer
[
]
renderers
TrackSelector
trackSelector
TrackSelectorResult
emptyTrackSelectorResult
LoadControl
loadControl
BandwidthMeter
bandwidthMeter
boolean
playWhenReady
Player
.
RepeatMode
int
repeatMode
boolean
shuffleModeEnabled
Handler
eventHandler
Clock
clock
)
{
this
.
renderers
=
renderers
;
this
.
trackSelector
=
trackSelector
;
this
.
emptyTrackSelectorResult
=
emptyTrackSelectorResult
;
this
.
loadControl
=
loadControl
;
this
.
bandwidthMeter
=
bandwidthMeter
;
this
.
playWhenReady
=
playWhenReady
;
this
.
repeatMode
=
repeatMode
;
this
.
shuffleModeEnabled
=
shuffleModeEnabled
;
this
.
eventHandler
=
eventHandler
;
this
.
clock
=
clock
;
this
.
queue
=
new
MediaPeriodQueue
(
)
;
backBufferDurationUs
=
loadControl
.
getBackBufferDurationUs
(
)
;
retainBackBufferFromKeyframe
=
loadControl
.
retainBackBufferFromKeyframe
(
)
;
seekParameters
=
SeekParameters
.
DEFAULT
;
playbackInfo
=
PlaybackInfo
.
createDummy
(
C
.
TIME_UNSET
emptyTrackSelectorResult
)
;
playbackInfoUpdate
=
new
PlaybackInfoUpdate
(
)
;
rendererCapabilities
=
new
RendererCapabilities
[
renderers
.
length
]
;
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
renderers
[
i
]
.
setIndex
(
i
)
;
rendererCapabilities
[
i
]
=
renderers
[
i
]
.
getCapabilities
(
)
;
}
mediaClock
=
new
DefaultMediaClock
(
this
clock
)
;
pendingMessages
=
new
ArrayList
<
>
(
)
;
enabledRenderers
=
new
Renderer
[
0
]
;
window
=
new
Timeline
.
Window
(
)
;
period
=
new
Timeline
.
Period
(
)
;
trackSelector
.
init
(
this
bandwidthMeter
)
;
internalPlaybackThread
=
new
HandlerThread
(
"
ExoPlayerImplInternal
:
Handler
"
Process
.
THREAD_PRIORITY_AUDIO
)
;
internalPlaybackThread
.
start
(
)
;
handler
=
clock
.
createHandler
(
internalPlaybackThread
.
getLooper
(
)
this
)
;
deliverPendingMessageAtStartPositionRequired
=
true
;
}
public
void
prepare
(
MediaSource
mediaSource
boolean
resetPosition
boolean
resetState
)
{
handler
.
obtainMessage
(
MSG_PREPARE
resetPosition
?
1
:
0
resetState
?
1
:
0
mediaSource
)
.
sendToTarget
(
)
;
}
public
void
setPlayWhenReady
(
boolean
playWhenReady
)
{
handler
.
obtainMessage
(
MSG_SET_PLAY_WHEN_READY
playWhenReady
?
1
:
0
0
)
.
sendToTarget
(
)
;
}
public
void
setRepeatMode
(
Player
.
RepeatMode
int
repeatMode
)
{
handler
.
obtainMessage
(
MSG_SET_REPEAT_MODE
repeatMode
0
)
.
sendToTarget
(
)
;
}
public
void
setShuffleModeEnabled
(
boolean
shuffleModeEnabled
)
{
handler
.
obtainMessage
(
MSG_SET_SHUFFLE_ENABLED
shuffleModeEnabled
?
1
:
0
0
)
.
sendToTarget
(
)
;
}
public
void
seekTo
(
Timeline
timeline
int
windowIndex
long
positionUs
)
{
handler
.
obtainMessage
(
MSG_SEEK_TO
new
SeekPosition
(
timeline
windowIndex
positionUs
)
)
.
sendToTarget
(
)
;
}
public
void
setPlaybackParameters
(
PlaybackParameters
playbackParameters
)
{
handler
.
obtainMessage
(
MSG_SET_PLAYBACK_PARAMETERS
playbackParameters
)
.
sendToTarget
(
)
;
}
public
void
setSeekParameters
(
SeekParameters
seekParameters
)
{
handler
.
obtainMessage
(
MSG_SET_SEEK_PARAMETERS
seekParameters
)
.
sendToTarget
(
)
;
}
public
void
stop
(
boolean
reset
)
{
handler
.
obtainMessage
(
MSG_STOP
reset
?
1
:
0
0
)
.
sendToTarget
(
)
;
}
Override
public
synchronized
void
sendMessage
(
PlayerMessage
message
)
{
if
(
released
|
|
!
internalPlaybackThread
.
isAlive
(
)
)
{
Log
.
w
(
TAG
"
Ignoring
messages
sent
after
release
.
"
)
;
message
.
markAsProcessed
(
false
)
;
return
;
}
handler
.
obtainMessage
(
MSG_SEND_MESSAGE
message
)
.
sendToTarget
(
)
;
}
public
synchronized
void
setForegroundMode
(
boolean
foregroundMode
)
{
if
(
released
|
|
!
internalPlaybackThread
.
isAlive
(
)
)
{
return
;
}
if
(
foregroundMode
)
{
handler
.
obtainMessage
(
MSG_SET_FOREGROUND_MODE
1
0
)
.
sendToTarget
(
)
;
}
else
{
AtomicBoolean
processedFlag
=
new
AtomicBoolean
(
)
;
handler
.
obtainMessage
(
MSG_SET_FOREGROUND_MODE
0
0
processedFlag
)
.
sendToTarget
(
)
;
boolean
wasInterrupted
=
false
;
while
(
!
processedFlag
.
get
(
)
)
{
try
{
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
wasInterrupted
=
true
;
}
}
if
(
wasInterrupted
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
}
}
}
public
synchronized
void
release
(
)
{
if
(
released
|
|
!
internalPlaybackThread
.
isAlive
(
)
)
{
return
;
}
handler
.
sendEmptyMessage
(
MSG_RELEASE
)
;
boolean
wasInterrupted
=
false
;
while
(
!
released
)
{
try
{
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
wasInterrupted
=
true
;
}
}
if
(
wasInterrupted
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
}
}
public
Looper
getPlaybackLooper
(
)
{
return
internalPlaybackThread
.
getLooper
(
)
;
}
Override
public
void
onSourceInfoRefreshed
(
MediaSource
source
Timeline
timeline
)
{
handler
.
obtainMessage
(
MSG_REFRESH_SOURCE_INFO
new
MediaSourceRefreshInfo
(
source
timeline
)
)
.
sendToTarget
(
)
;
}
Override
public
void
onPrepared
(
MediaPeriod
source
)
{
handler
.
obtainMessage
(
MSG_PERIOD_PREPARED
source
)
.
sendToTarget
(
)
;
}
Override
public
void
onContinueLoadingRequested
(
MediaPeriod
source
)
{
handler
.
obtainMessage
(
MSG_SOURCE_CONTINUE_LOADING_REQUESTED
source
)
.
sendToTarget
(
)
;
}
Override
public
void
onTrackSelectionsInvalidated
(
)
{
handler
.
sendEmptyMessage
(
MSG_TRACK_SELECTION_INVALIDATED
)
;
}
Override
public
void
onPlaybackParametersChanged
(
PlaybackParameters
playbackParameters
)
{
sendPlaybackParametersChangedInternal
(
playbackParameters
false
)
;
}
Override
public
boolean
handleMessage
(
Message
msg
)
{
try
{
switch
(
msg
.
what
)
{
case
MSG_PREPARE
:
prepareInternal
(
(
MediaSource
)
msg
.
obj
msg
.
arg1
!
=
0
msg
.
arg2
!
=
0
)
;
break
;
case
MSG_SET_PLAY_WHEN_READY
:
setPlayWhenReadyInternal
(
msg
.
arg1
!
=
0
)
;
break
;
case
MSG_SET_REPEAT_MODE
:
setRepeatModeInternal
(
msg
.
arg1
)
;
break
;
case
MSG_SET_SHUFFLE_ENABLED
:
setShuffleModeEnabledInternal
(
msg
.
arg1
!
=
0
)
;
break
;
case
MSG_DO_SOME_WORK
:
doSomeWork
(
)
;
break
;
case
MSG_SEEK_TO
:
seekToInternal
(
(
SeekPosition
)
msg
.
obj
)
;
break
;
case
MSG_SET_PLAYBACK_PARAMETERS
:
setPlaybackParametersInternal
(
(
PlaybackParameters
)
msg
.
obj
)
;
break
;
case
MSG_SET_SEEK_PARAMETERS
:
setSeekParametersInternal
(
(
SeekParameters
)
msg
.
obj
)
;
break
;
case
MSG_SET_FOREGROUND_MODE
:
setForegroundModeInternal
(
msg
.
arg1
!
=
0
(
AtomicBoolean
)
msg
.
obj
)
;
break
;
case
MSG_STOP
:
stopInternal
(
false
msg
.
arg1
!
=
0
true
)
;
break
;
case
MSG_PERIOD_PREPARED
:
handlePeriodPrepared
(
(
MediaPeriod
)
msg
.
obj
)
;
break
;
case
MSG_REFRESH_SOURCE_INFO
:
handleSourceInfoRefreshed
(
(
MediaSourceRefreshInfo
)
msg
.
obj
)
;
break
;
case
MSG_SOURCE_CONTINUE_LOADING_REQUESTED
:
handleContinueLoadingRequested
(
(
MediaPeriod
)
msg
.
obj
)
;
break
;
case
MSG_TRACK_SELECTION_INVALIDATED
:
reselectTracksInternal
(
)
;
break
;
case
MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL
:
handlePlaybackParameters
(
(
PlaybackParameters
)
msg
.
obj
msg
.
arg1
!
=
0
)
;
break
;
case
MSG_SEND_MESSAGE
:
sendMessageInternal
(
(
PlayerMessage
)
msg
.
obj
)
;
break
;
case
MSG_SEND_MESSAGE_TO_TARGET_THREAD
:
sendMessageToTargetThread
(
(
PlayerMessage
)
msg
.
obj
)
;
break
;
case
MSG_RELEASE
:
releaseInternal
(
)
;
return
true
;
default
:
return
false
;
}
maybeNotifyPlaybackInfoChanged
(
)
;
}
catch
(
ExoPlaybackException
e
)
{
Log
.
e
(
TAG
getExoPlaybackExceptionMessage
(
e
)
e
)
;
stopInternal
(
true
false
false
)
;
playbackInfo
=
playbackInfo
.
copyWithPlaybackError
(
e
)
;
maybeNotifyPlaybackInfoChanged
(
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
TAG
"
Source
error
"
e
)
;
stopInternal
(
false
false
false
)
;
playbackInfo
=
playbackInfo
.
copyWithPlaybackError
(
ExoPlaybackException
.
createForSource
(
e
)
)
;
maybeNotifyPlaybackInfoChanged
(
)
;
}
catch
(
RuntimeException
|
OutOfMemoryError
e
)
{
Log
.
e
(
TAG
"
Internal
runtime
error
"
e
)
;
ExoPlaybackException
error
=
e
instanceof
OutOfMemoryError
?
ExoPlaybackException
.
createForOutOfMemoryError
(
(
OutOfMemoryError
)
e
)
:
ExoPlaybackException
.
createForUnexpected
(
(
RuntimeException
)
e
)
;
stopInternal
(
true
false
false
)
;
playbackInfo
=
playbackInfo
.
copyWithPlaybackError
(
error
)
;
maybeNotifyPlaybackInfoChanged
(
)
;
}
return
true
;
}
private
String
getExoPlaybackExceptionMessage
(
ExoPlaybackException
e
)
{
if
(
e
.
type
!
=
ExoPlaybackException
.
TYPE_RENDERER
)
{
return
"
Playback
error
.
"
;
}
return
"
Renderer
error
:
index
=
"
+
e
.
rendererIndex
+
"
type
=
"
+
Util
.
getTrackTypeString
(
renderers
[
e
.
rendererIndex
]
.
getTrackType
(
)
)
+
"
format
=
"
+
e
.
rendererFormat
+
"
rendererSupport
=
"
+
RendererCapabilities
.
getFormatSupportString
(
e
.
rendererFormatSupport
)
;
}
private
void
setState
(
int
state
)
{
if
(
playbackInfo
.
playbackState
!
=
state
)
{
playbackInfo
=
playbackInfo
.
copyWithPlaybackState
(
state
)
;
}
}
private
void
maybeNotifyPlaybackInfoChanged
(
)
{
if
(
playbackInfoUpdate
.
hasPendingUpdate
(
playbackInfo
)
)
{
eventHandler
.
obtainMessage
(
MSG_PLAYBACK_INFO_CHANGED
playbackInfoUpdate
.
operationAcks
playbackInfoUpdate
.
positionDiscontinuity
?
playbackInfoUpdate
.
discontinuityReason
:
C
.
INDEX_UNSET
playbackInfo
)
.
sendToTarget
(
)
;
playbackInfoUpdate
.
reset
(
playbackInfo
)
;
}
}
private
void
prepareInternal
(
MediaSource
mediaSource
boolean
resetPosition
boolean
resetState
)
{
pendingPrepareCount
+
+
;
resetInternal
(
false
true
resetPosition
resetState
true
)
;
loadControl
.
onPrepared
(
)
;
this
.
mediaSource
=
mediaSource
;
setState
(
Player
.
STATE_BUFFERING
)
;
mediaSource
.
prepareSource
(
this
bandwidthMeter
.
getTransferListener
(
)
)
;
handler
.
sendEmptyMessage
(
MSG_DO_SOME_WORK
)
;
}
private
void
setPlayWhenReadyInternal
(
boolean
playWhenReady
)
throws
ExoPlaybackException
{
rebuffering
=
false
;
this
.
playWhenReady
=
playWhenReady
;
if
(
!
playWhenReady
)
{
stopRenderers
(
)
;
updatePlaybackPositions
(
)
;
}
else
{
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_READY
)
{
startRenderers
(
)
;
handler
.
sendEmptyMessage
(
MSG_DO_SOME_WORK
)
;
}
else
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_BUFFERING
)
{
handler
.
sendEmptyMessage
(
MSG_DO_SOME_WORK
)
;
}
}
}
private
void
setRepeatModeInternal
(
Player
.
RepeatMode
int
repeatMode
)
throws
ExoPlaybackException
{
this
.
repeatMode
=
repeatMode
;
if
(
!
queue
.
updateRepeatMode
(
repeatMode
)
)
{
seekToCurrentPosition
(
true
)
;
}
handleLoadingMediaPeriodChanged
(
false
)
;
}
private
void
setShuffleModeEnabledInternal
(
boolean
shuffleModeEnabled
)
throws
ExoPlaybackException
{
this
.
shuffleModeEnabled
=
shuffleModeEnabled
;
if
(
!
queue
.
updateShuffleModeEnabled
(
shuffleModeEnabled
)
)
{
seekToCurrentPosition
(
true
)
;
}
handleLoadingMediaPeriodChanged
(
false
)
;
}
private
void
seekToCurrentPosition
(
boolean
sendDiscontinuity
)
throws
ExoPlaybackException
{
MediaPeriodId
periodId
=
queue
.
getPlayingPeriod
(
)
.
info
.
id
;
long
newPositionUs
=
seekToPeriodPosition
(
periodId
playbackInfo
.
positionUs
true
)
;
if
(
newPositionUs
!
=
playbackInfo
.
positionUs
)
{
playbackInfo
=
copyWithNewPosition
(
periodId
newPositionUs
playbackInfo
.
contentPositionUs
)
;
if
(
sendDiscontinuity
)
{
playbackInfoUpdate
.
setPositionDiscontinuity
(
Player
.
DISCONTINUITY_REASON_INTERNAL
)
;
}
}
}
private
void
startRenderers
(
)
throws
ExoPlaybackException
{
rebuffering
=
false
;
mediaClock
.
start
(
)
;
for
(
Renderer
renderer
:
enabledRenderers
)
{
renderer
.
start
(
)
;
}
}
private
void
stopRenderers
(
)
throws
ExoPlaybackException
{
mediaClock
.
stop
(
)
;
for
(
Renderer
renderer
:
enabledRenderers
)
{
ensureStopped
(
renderer
)
;
}
}
private
void
updatePlaybackPositions
(
)
throws
ExoPlaybackException
{
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
playingPeriodHolder
=
=
null
)
{
return
;
}
long
discontinuityPositionUs
=
playingPeriodHolder
.
prepared
?
playingPeriodHolder
.
mediaPeriod
.
readDiscontinuity
(
)
:
C
.
TIME_UNSET
;
if
(
discontinuityPositionUs
!
=
C
.
TIME_UNSET
)
{
resetRendererPosition
(
discontinuityPositionUs
)
;
if
(
discontinuityPositionUs
!
=
playbackInfo
.
positionUs
)
{
playbackInfo
=
copyWithNewPosition
(
playbackInfo
.
periodId
discontinuityPositionUs
playbackInfo
.
contentPositionUs
)
;
playbackInfoUpdate
.
setPositionDiscontinuity
(
Player
.
DISCONTINUITY_REASON_INTERNAL
)
;
}
}
else
{
rendererPositionUs
=
mediaClock
.
syncAndGetPositionUs
(
playingPeriodHolder
!
=
queue
.
getReadingPeriod
(
)
)
;
long
periodPositionUs
=
playingPeriodHolder
.
toPeriodTime
(
rendererPositionUs
)
;
maybeTriggerPendingMessages
(
playbackInfo
.
positionUs
periodPositionUs
)
;
playbackInfo
.
positionUs
=
periodPositionUs
;
}
MediaPeriodHolder
loadingPeriod
=
queue
.
getLoadingPeriod
(
)
;
playbackInfo
.
bufferedPositionUs
=
loadingPeriod
.
getBufferedPositionUs
(
)
;
playbackInfo
.
totalBufferedDurationUs
=
getTotalBufferedDurationUs
(
)
;
}
private
void
doSomeWork
(
)
throws
ExoPlaybackException
IOException
{
long
operationStartTimeMs
=
clock
.
uptimeMillis
(
)
;
updatePeriods
(
)
;
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_IDLE
|
|
playbackInfo
.
playbackState
=
=
Player
.
STATE_ENDED
)
{
handler
.
removeMessages
(
MSG_DO_SOME_WORK
)
;
return
;
}
Nullable
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
playingPeriodHolder
=
=
null
)
{
scheduleNextWork
(
operationStartTimeMs
ACTIVE_INTERVAL_MS
)
;
return
;
}
TraceUtil
.
beginSection
(
"
doSomeWork
"
)
;
updatePlaybackPositions
(
)
;
boolean
renderersEnded
=
true
;
boolean
renderersAllowPlayback
=
true
;
if
(
playingPeriodHolder
.
prepared
)
{
long
rendererPositionElapsedRealtimeUs
=
SystemClock
.
elapsedRealtime
(
)
*
1000
;
playingPeriodHolder
.
mediaPeriod
.
discardBuffer
(
playbackInfo
.
positionUs
-
backBufferDurationUs
retainBackBufferFromKeyframe
)
;
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
Renderer
renderer
=
renderers
[
i
]
;
if
(
renderer
.
getState
(
)
=
=
Renderer
.
STATE_DISABLED
)
{
continue
;
}
renderer
.
render
(
rendererPositionUs
rendererPositionElapsedRealtimeUs
)
;
renderersEnded
=
renderersEnded
&
&
renderer
.
isEnded
(
)
;
boolean
isReadingAhead
=
playingPeriodHolder
.
sampleStreams
[
i
]
!
=
renderer
.
getStream
(
)
;
boolean
isWaitingForNextStream
=
!
isReadingAhead
&
&
playingPeriodHolder
.
getNext
(
)
!
=
null
&
&
renderer
.
hasReadStreamToEnd
(
)
;
boolean
allowsPlayback
=
isReadingAhead
|
|
isWaitingForNextStream
|
|
renderer
.
isReady
(
)
|
|
renderer
.
isEnded
(
)
;
renderersAllowPlayback
=
renderersAllowPlayback
&
&
allowsPlayback
;
if
(
!
allowsPlayback
)
{
renderer
.
maybeThrowStreamError
(
)
;
}
}
}
else
{
playingPeriodHolder
.
mediaPeriod
.
maybeThrowPrepareError
(
)
;
}
long
playingPeriodDurationUs
=
playingPeriodHolder
.
info
.
durationUs
;
if
(
renderersEnded
&
&
playingPeriodHolder
.
prepared
&
&
(
playingPeriodDurationUs
=
=
C
.
TIME_UNSET
|
|
playingPeriodDurationUs
<
=
playbackInfo
.
positionUs
)
&
&
playingPeriodHolder
.
info
.
isFinal
)
{
setState
(
Player
.
STATE_ENDED
)
;
stopRenderers
(
)
;
}
else
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_BUFFERING
&
&
shouldTransitionToReadyState
(
renderersAllowPlayback
)
)
{
setState
(
Player
.
STATE_READY
)
;
if
(
playWhenReady
)
{
startRenderers
(
)
;
}
}
else
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_READY
&
&
!
(
enabledRenderers
.
length
=
=
0
?
isTimelineReady
(
)
:
renderersAllowPlayback
)
)
{
rebuffering
=
playWhenReady
;
setState
(
Player
.
STATE_BUFFERING
)
;
stopRenderers
(
)
;
}
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_BUFFERING
)
{
for
(
Renderer
renderer
:
enabledRenderers
)
{
renderer
.
maybeThrowStreamError
(
)
;
}
}
if
(
(
playWhenReady
&
&
playbackInfo
.
playbackState
=
=
Player
.
STATE_READY
)
|
|
playbackInfo
.
playbackState
=
=
Player
.
STATE_BUFFERING
)
{
scheduleNextWork
(
operationStartTimeMs
ACTIVE_INTERVAL_MS
)
;
}
else
if
(
enabledRenderers
.
length
!
=
0
&
&
playbackInfo
.
playbackState
!
=
Player
.
STATE_ENDED
)
{
scheduleNextWork
(
operationStartTimeMs
IDLE_INTERVAL_MS
)
;
}
else
{
handler
.
removeMessages
(
MSG_DO_SOME_WORK
)
;
}
TraceUtil
.
endSection
(
)
;
}
private
void
scheduleNextWork
(
long
thisOperationStartTimeMs
long
intervalMs
)
{
handler
.
removeMessages
(
MSG_DO_SOME_WORK
)
;
handler
.
sendEmptyMessageAtTime
(
MSG_DO_SOME_WORK
thisOperationStartTimeMs
+
intervalMs
)
;
}
private
void
seekToInternal
(
SeekPosition
seekPosition
)
throws
ExoPlaybackException
{
playbackInfoUpdate
.
incrementPendingOperationAcks
(
1
)
;
MediaPeriodId
periodId
;
long
periodPositionUs
;
long
contentPositionUs
;
boolean
seekPositionAdjusted
;
Pair
<
Object
Long
>
resolvedSeekPosition
=
resolveSeekPosition
(
seekPosition
true
)
;
if
(
resolvedSeekPosition
=
=
null
)
{
periodId
=
playbackInfo
.
getDummyFirstMediaPeriodId
(
shuffleModeEnabled
window
period
)
;
periodPositionUs
=
C
.
TIME_UNSET
;
contentPositionUs
=
C
.
TIME_UNSET
;
seekPositionAdjusted
=
true
;
}
else
{
Object
periodUid
=
resolvedSeekPosition
.
first
;
contentPositionUs
=
resolvedSeekPosition
.
second
;
periodId
=
queue
.
resolveMediaPeriodIdForAds
(
periodUid
contentPositionUs
)
;
if
(
periodId
.
isAd
(
)
)
{
periodPositionUs
=
0
;
seekPositionAdjusted
=
true
;
}
else
{
periodPositionUs
=
resolvedSeekPosition
.
second
;
seekPositionAdjusted
=
seekPosition
.
windowPositionUs
=
=
C
.
TIME_UNSET
;
}
}
try
{
if
(
mediaSource
=
=
null
|
|
pendingPrepareCount
>
0
)
{
pendingInitialSeekPosition
=
seekPosition
;
}
else
if
(
periodPositionUs
=
=
C
.
TIME_UNSET
)
{
setState
(
Player
.
STATE_ENDED
)
;
resetInternal
(
false
false
true
false
true
)
;
}
else
{
long
newPeriodPositionUs
=
periodPositionUs
;
if
(
periodId
.
equals
(
playbackInfo
.
periodId
)
)
{
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
playingPeriodHolder
!
=
null
&
&
playingPeriodHolder
.
prepared
&
&
newPeriodPositionUs
!
=
0
)
{
newPeriodPositionUs
=
playingPeriodHolder
.
mediaPeriod
.
getAdjustedSeekPositionUs
(
newPeriodPositionUs
seekParameters
)
;
}
if
(
C
.
usToMs
(
newPeriodPositionUs
)
=
=
C
.
usToMs
(
playbackInfo
.
positionUs
)
)
{
periodPositionUs
=
playbackInfo
.
positionUs
;
return
;
}
}
newPeriodPositionUs
=
seekToPeriodPosition
(
periodId
newPeriodPositionUs
)
;
seekPositionAdjusted
|
=
periodPositionUs
!
=
newPeriodPositionUs
;
periodPositionUs
=
newPeriodPositionUs
;
}
}
finally
{
playbackInfo
=
copyWithNewPosition
(
periodId
periodPositionUs
contentPositionUs
)
;
if
(
seekPositionAdjusted
)
{
playbackInfoUpdate
.
setPositionDiscontinuity
(
Player
.
DISCONTINUITY_REASON_SEEK_ADJUSTMENT
)
;
}
}
}
private
long
seekToPeriodPosition
(
MediaPeriodId
periodId
long
periodPositionUs
)
throws
ExoPlaybackException
{
return
seekToPeriodPosition
(
periodId
periodPositionUs
queue
.
getPlayingPeriod
(
)
!
=
queue
.
getReadingPeriod
(
)
)
;
}
private
long
seekToPeriodPosition
(
MediaPeriodId
periodId
long
periodPositionUs
boolean
forceDisableRenderers
)
throws
ExoPlaybackException
{
stopRenderers
(
)
;
rebuffering
=
false
;
if
(
playbackInfo
.
playbackState
!
=
Player
.
STATE_IDLE
&
&
!
playbackInfo
.
timeline
.
isEmpty
(
)
)
{
setState
(
Player
.
STATE_BUFFERING
)
;
}
MediaPeriodHolder
oldPlayingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
MediaPeriodHolder
newPlayingPeriodHolder
=
oldPlayingPeriodHolder
;
while
(
newPlayingPeriodHolder
!
=
null
)
{
if
(
periodId
.
equals
(
newPlayingPeriodHolder
.
info
.
id
)
&
&
newPlayingPeriodHolder
.
prepared
)
{
queue
.
removeAfter
(
newPlayingPeriodHolder
)
;
break
;
}
newPlayingPeriodHolder
=
queue
.
advancePlayingPeriod
(
)
;
}
if
(
forceDisableRenderers
|
|
oldPlayingPeriodHolder
!
=
newPlayingPeriodHolder
|
|
(
newPlayingPeriodHolder
!
=
null
&
&
newPlayingPeriodHolder
.
toRendererTime
(
periodPositionUs
)
<
0
)
)
{
for
(
Renderer
renderer
:
enabledRenderers
)
{
disableRenderer
(
renderer
)
;
}
enabledRenderers
=
new
Renderer
[
0
]
;
oldPlayingPeriodHolder
=
null
;
if
(
newPlayingPeriodHolder
!
=
null
)
{
newPlayingPeriodHolder
.
setRendererOffset
(
0
)
;
}
}
if
(
newPlayingPeriodHolder
!
=
null
)
{
updatePlayingPeriodRenderers
(
oldPlayingPeriodHolder
)
;
if
(
newPlayingPeriodHolder
.
hasEnabledTracks
)
{
periodPositionUs
=
newPlayingPeriodHolder
.
mediaPeriod
.
seekToUs
(
periodPositionUs
)
;
newPlayingPeriodHolder
.
mediaPeriod
.
discardBuffer
(
periodPositionUs
-
backBufferDurationUs
retainBackBufferFromKeyframe
)
;
}
resetRendererPosition
(
periodPositionUs
)
;
maybeContinueLoading
(
)
;
}
else
{
queue
.
clear
(
true
)
;
playbackInfo
=
playbackInfo
.
copyWithTrackInfo
(
TrackGroupArray
.
EMPTY
emptyTrackSelectorResult
)
;
resetRendererPosition
(
periodPositionUs
)
;
}
handleLoadingMediaPeriodChanged
(
false
)
;
handler
.
sendEmptyMessage
(
MSG_DO_SOME_WORK
)
;
return
periodPositionUs
;
}
private
void
resetRendererPosition
(
long
periodPositionUs
)
throws
ExoPlaybackException
{
MediaPeriodHolder
playingMediaPeriod
=
queue
.
getPlayingPeriod
(
)
;
rendererPositionUs
=
playingMediaPeriod
=
=
null
?
periodPositionUs
:
playingMediaPeriod
.
toRendererTime
(
periodPositionUs
)
;
mediaClock
.
resetPosition
(
rendererPositionUs
)
;
for
(
Renderer
renderer
:
enabledRenderers
)
{
renderer
.
resetPosition
(
rendererPositionUs
)
;
}
notifyTrackSelectionDiscontinuity
(
)
;
}
private
void
setPlaybackParametersInternal
(
PlaybackParameters
playbackParameters
)
{
mediaClock
.
setPlaybackParameters
(
playbackParameters
)
;
sendPlaybackParametersChangedInternal
(
mediaClock
.
getPlaybackParameters
(
)
true
)
;
}
private
void
setSeekParametersInternal
(
SeekParameters
seekParameters
)
{
this
.
seekParameters
=
seekParameters
;
}
private
void
setForegroundModeInternal
(
boolean
foregroundMode
Nullable
AtomicBoolean
processedFlag
)
{
if
(
this
.
foregroundMode
!
=
foregroundMode
)
{
this
.
foregroundMode
=
foregroundMode
;
if
(
!
foregroundMode
)
{
for
(
Renderer
renderer
:
renderers
)
{
if
(
renderer
.
getState
(
)
=
=
Renderer
.
STATE_DISABLED
)
{
renderer
.
reset
(
)
;
}
}
}
}
if
(
processedFlag
!
=
null
)
{
synchronized
(
this
)
{
processedFlag
.
set
(
true
)
;
notifyAll
(
)
;
}
}
}
private
void
stopInternal
(
boolean
forceResetRenderers
boolean
resetPositionAndState
boolean
acknowledgeStop
)
{
resetInternal
(
forceResetRenderers
|
|
!
foregroundMode
true
resetPositionAndState
resetPositionAndState
resetPositionAndState
)
;
playbackInfoUpdate
.
incrementPendingOperationAcks
(
pendingPrepareCount
+
(
acknowledgeStop
?
1
:
0
)
)
;
pendingPrepareCount
=
0
;
loadControl
.
onStopped
(
)
;
setState
(
Player
.
STATE_IDLE
)
;
}
private
void
releaseInternal
(
)
{
resetInternal
(
true
true
true
true
false
)
;
loadControl
.
onReleased
(
)
;
setState
(
Player
.
STATE_IDLE
)
;
internalPlaybackThread
.
quit
(
)
;
synchronized
(
this
)
{
released
=
true
;
notifyAll
(
)
;
}
}
private
void
resetInternal
(
boolean
resetRenderers
boolean
releaseMediaSource
boolean
resetPosition
boolean
resetState
boolean
resetError
)
{
handler
.
removeMessages
(
MSG_DO_SOME_WORK
)
;
rebuffering
=
false
;
mediaClock
.
stop
(
)
;
rendererPositionUs
=
0
;
for
(
Renderer
renderer
:
enabledRenderers
)
{
try
{
disableRenderer
(
renderer
)
;
}
catch
(
ExoPlaybackException
|
RuntimeException
e
)
{
Log
.
e
(
TAG
"
Disable
failed
.
"
e
)
;
}
}
if
(
resetRenderers
)
{
for
(
Renderer
renderer
:
renderers
)
{
try
{
renderer
.
reset
(
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
TAG
"
Reset
failed
.
"
e
)
;
}
}
}
enabledRenderers
=
new
Renderer
[
0
]
;
if
(
resetPosition
)
{
pendingInitialSeekPosition
=
null
;
}
else
if
(
resetState
)
{
resetPosition
=
true
;
if
(
pendingInitialSeekPosition
=
=
null
&
&
!
playbackInfo
.
timeline
.
isEmpty
(
)
)
{
playbackInfo
.
timeline
.
getPeriodByUid
(
playbackInfo
.
periodId
.
periodUid
period
)
;
long
windowPositionUs
=
playbackInfo
.
positionUs
+
period
.
getPositionInWindowUs
(
)
;
pendingInitialSeekPosition
=
new
SeekPosition
(
Timeline
.
EMPTY
period
.
windowIndex
windowPositionUs
)
;
}
}
queue
.
clear
(
!
resetState
)
;
shouldContinueLoading
=
false
;
if
(
resetState
)
{
queue
.
setTimeline
(
Timeline
.
EMPTY
)
;
for
(
PendingMessageInfo
pendingMessageInfo
:
pendingMessages
)
{
pendingMessageInfo
.
message
.
markAsProcessed
(
false
)
;
}
pendingMessages
.
clear
(
)
;
nextPendingMessageIndex
=
0
;
}
MediaPeriodId
mediaPeriodId
=
resetPosition
?
playbackInfo
.
getDummyFirstMediaPeriodId
(
shuffleModeEnabled
window
period
)
:
playbackInfo
.
periodId
;
long
startPositionUs
=
resetPosition
?
C
.
TIME_UNSET
:
playbackInfo
.
positionUs
;
long
contentPositionUs
=
resetPosition
?
C
.
TIME_UNSET
:
playbackInfo
.
contentPositionUs
;
playbackInfo
=
new
PlaybackInfo
(
resetState
?
Timeline
.
EMPTY
:
playbackInfo
.
timeline
mediaPeriodId
startPositionUs
contentPositionUs
playbackInfo
.
playbackState
resetError
?
null
:
playbackInfo
.
playbackError
false
resetState
?
TrackGroupArray
.
EMPTY
:
playbackInfo
.
trackGroups
resetState
?
emptyTrackSelectorResult
:
playbackInfo
.
trackSelectorResult
mediaPeriodId
startPositionUs
0
startPositionUs
)
;
if
(
releaseMediaSource
)
{
if
(
mediaSource
!
=
null
)
{
mediaSource
.
releaseSource
(
this
)
;
mediaSource
=
null
;
}
}
}
private
void
sendMessageInternal
(
PlayerMessage
message
)
throws
ExoPlaybackException
{
if
(
message
.
getPositionMs
(
)
=
=
C
.
TIME_UNSET
)
{
sendMessageToTarget
(
message
)
;
}
else
if
(
mediaSource
=
=
null
|
|
pendingPrepareCount
>
0
)
{
pendingMessages
.
add
(
new
PendingMessageInfo
(
message
)
)
;
}
else
{
PendingMessageInfo
pendingMessageInfo
=
new
PendingMessageInfo
(
message
)
;
if
(
resolvePendingMessagePosition
(
pendingMessageInfo
)
)
{
pendingMessages
.
add
(
pendingMessageInfo
)
;
Collections
.
sort
(
pendingMessages
)
;
}
else
{
message
.
markAsProcessed
(
false
)
;
}
}
}
private
void
sendMessageToTarget
(
PlayerMessage
message
)
throws
ExoPlaybackException
{
if
(
message
.
getHandler
(
)
.
getLooper
(
)
=
=
handler
.
getLooper
(
)
)
{
deliverMessage
(
message
)
;
if
(
playbackInfo
.
playbackState
=
=
Player
.
STATE_READY
|
|
playbackInfo
.
playbackState
=
=
Player
.
STATE_BUFFERING
)
{
handler
.
sendEmptyMessage
(
MSG_DO_SOME_WORK
)
;
}
}
else
{
handler
.
obtainMessage
(
MSG_SEND_MESSAGE_TO_TARGET_THREAD
message
)
.
sendToTarget
(
)
;
}
}
private
void
sendMessageToTargetThread
(
final
PlayerMessage
message
)
{
Handler
handler
=
message
.
getHandler
(
)
;
if
(
!
handler
.
getLooper
(
)
.
getThread
(
)
.
isAlive
(
)
)
{
Log
.
w
(
"
TAG
"
"
Trying
to
send
message
on
a
dead
thread
.
"
)
;
message
.
markAsProcessed
(
false
)
;
return
;
}
handler
.
post
(
(
)
-
>
{
try
{
deliverMessage
(
message
)
;
}
catch
(
ExoPlaybackException
e
)
{
Log
.
e
(
TAG
"
Unexpected
error
delivering
message
on
external
thread
.
"
e
)
;
throw
new
RuntimeException
(
e
)
;
}
}
)
;
}
private
void
deliverMessage
(
PlayerMessage
message
)
throws
ExoPlaybackException
{
if
(
message
.
isCanceled
(
)
)
{
return
;
}
try
{
message
.
getTarget
(
)
.
handleMessage
(
message
.
getType
(
)
message
.
getPayload
(
)
)
;
}
finally
{
message
.
markAsProcessed
(
true
)
;
}
}
private
void
resolvePendingMessagePositions
(
)
{
for
(
int
i
=
pendingMessages
.
size
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
!
resolvePendingMessagePosition
(
pendingMessages
.
get
(
i
)
)
)
{
pendingMessages
.
get
(
i
)
.
message
.
markAsProcessed
(
false
)
;
pendingMessages
.
remove
(
i
)
;
}
}
Collections
.
sort
(
pendingMessages
)
;
}
private
boolean
resolvePendingMessagePosition
(
PendingMessageInfo
pendingMessageInfo
)
{
if
(
pendingMessageInfo
.
resolvedPeriodUid
=
=
null
)
{
Pair
<
Object
Long
>
periodPosition
=
resolveSeekPosition
(
new
SeekPosition
(
pendingMessageInfo
.
message
.
getTimeline
(
)
pendingMessageInfo
.
message
.
getWindowIndex
(
)
C
.
msToUs
(
pendingMessageInfo
.
message
.
getPositionMs
(
)
)
)
false
)
;
if
(
periodPosition
=
=
null
)
{
return
false
;
}
pendingMessageInfo
.
setResolvedPosition
(
playbackInfo
.
timeline
.
getIndexOfPeriod
(
periodPosition
.
first
)
periodPosition
.
second
periodPosition
.
first
)
;
}
else
{
int
index
=
playbackInfo
.
timeline
.
getIndexOfPeriod
(
pendingMessageInfo
.
resolvedPeriodUid
)
;
if
(
index
=
=
C
.
INDEX_UNSET
)
{
return
false
;
}
pendingMessageInfo
.
resolvedPeriodIndex
=
index
;
}
return
true
;
}
private
void
maybeTriggerPendingMessages
(
long
oldPeriodPositionUs
long
newPeriodPositionUs
)
throws
ExoPlaybackException
{
if
(
pendingMessages
.
isEmpty
(
)
|
|
playbackInfo
.
periodId
.
isAd
(
)
)
{
return
;
}
if
(
playbackInfo
.
startPositionUs
=
=
oldPeriodPositionUs
&
&
deliverPendingMessageAtStartPositionRequired
)
{
oldPeriodPositionUs
-
-
;
}
deliverPendingMessageAtStartPositionRequired
=
false
;
int
currentPeriodIndex
=
playbackInfo
.
timeline
.
getIndexOfPeriod
(
playbackInfo
.
periodId
.
periodUid
)
;
PendingMessageInfo
previousInfo
=
nextPendingMessageIndex
>
0
?
pendingMessages
.
get
(
nextPendingMessageIndex
-
1
)
:
null
;
while
(
previousInfo
!
=
null
&
&
(
previousInfo
.
resolvedPeriodIndex
>
currentPeriodIndex
|
|
(
previousInfo
.
resolvedPeriodIndex
=
=
currentPeriodIndex
&
&
previousInfo
.
resolvedPeriodTimeUs
>
oldPeriodPositionUs
)
)
)
{
nextPendingMessageIndex
-
-
;
previousInfo
=
nextPendingMessageIndex
>
0
?
pendingMessages
.
get
(
nextPendingMessageIndex
-
1
)
:
null
;
}
PendingMessageInfo
nextInfo
=
nextPendingMessageIndex
<
pendingMessages
.
size
(
)
?
pendingMessages
.
get
(
nextPendingMessageIndex
)
:
null
;
while
(
nextInfo
!
=
null
&
&
nextInfo
.
resolvedPeriodUid
!
=
null
&
&
(
nextInfo
.
resolvedPeriodIndex
<
currentPeriodIndex
|
|
(
nextInfo
.
resolvedPeriodIndex
=
=
currentPeriodIndex
&
&
nextInfo
.
resolvedPeriodTimeUs
<
=
oldPeriodPositionUs
)
)
)
{
nextPendingMessageIndex
+
+
;
nextInfo
=
nextPendingMessageIndex
<
pendingMessages
.
size
(
)
?
pendingMessages
.
get
(
nextPendingMessageIndex
)
:
null
;
}
while
(
nextInfo
!
=
null
&
&
nextInfo
.
resolvedPeriodUid
!
=
null
&
&
nextInfo
.
resolvedPeriodIndex
=
=
currentPeriodIndex
&
&
nextInfo
.
resolvedPeriodTimeUs
>
oldPeriodPositionUs
&
&
nextInfo
.
resolvedPeriodTimeUs
<
=
newPeriodPositionUs
)
{
try
{
sendMessageToTarget
(
nextInfo
.
message
)
;
}
finally
{
if
(
nextInfo
.
message
.
getDeleteAfterDelivery
(
)
|
|
nextInfo
.
message
.
isCanceled
(
)
)
{
pendingMessages
.
remove
(
nextPendingMessageIndex
)
;
}
else
{
nextPendingMessageIndex
+
+
;
}
}
nextInfo
=
nextPendingMessageIndex
<
pendingMessages
.
size
(
)
?
pendingMessages
.
get
(
nextPendingMessageIndex
)
:
null
;
}
}
private
void
ensureStopped
(
Renderer
renderer
)
throws
ExoPlaybackException
{
if
(
renderer
.
getState
(
)
=
=
Renderer
.
STATE_STARTED
)
{
renderer
.
stop
(
)
;
}
}
private
void
disableRenderer
(
Renderer
renderer
)
throws
ExoPlaybackException
{
mediaClock
.
onRendererDisabled
(
renderer
)
;
ensureStopped
(
renderer
)
;
renderer
.
disable
(
)
;
}
private
void
reselectTracksInternal
(
)
throws
ExoPlaybackException
{
float
playbackSpeed
=
mediaClock
.
getPlaybackParameters
(
)
.
speed
;
MediaPeriodHolder
periodHolder
=
queue
.
getPlayingPeriod
(
)
;
MediaPeriodHolder
readingPeriodHolder
=
queue
.
getReadingPeriod
(
)
;
boolean
selectionsChangedForReadPeriod
=
true
;
TrackSelectorResult
newTrackSelectorResult
;
while
(
true
)
{
if
(
periodHolder
=
=
null
|
|
!
periodHolder
.
prepared
)
{
return
;
}
newTrackSelectorResult
=
periodHolder
.
selectTracks
(
playbackSpeed
playbackInfo
.
timeline
)
;
if
(
!
newTrackSelectorResult
.
isEquivalent
(
periodHolder
.
getTrackSelectorResult
(
)
)
)
{
break
;
}
if
(
periodHolder
=
=
readingPeriodHolder
)
{
selectionsChangedForReadPeriod
=
false
;
}
periodHolder
=
periodHolder
.
getNext
(
)
;
}
if
(
selectionsChangedForReadPeriod
)
{
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
boolean
recreateStreams
=
queue
.
removeAfter
(
playingPeriodHolder
)
;
boolean
[
]
streamResetFlags
=
new
boolean
[
renderers
.
length
]
;
long
periodPositionUs
=
playingPeriodHolder
.
applyTrackSelection
(
newTrackSelectorResult
playbackInfo
.
positionUs
recreateStreams
streamResetFlags
)
;
if
(
playbackInfo
.
playbackState
!
=
Player
.
STATE_ENDED
&
&
periodPositionUs
!
=
playbackInfo
.
positionUs
)
{
playbackInfo
=
copyWithNewPosition
(
playbackInfo
.
periodId
periodPositionUs
playbackInfo
.
contentPositionUs
)
;
playbackInfoUpdate
.
setPositionDiscontinuity
(
Player
.
DISCONTINUITY_REASON_INTERNAL
)
;
resetRendererPosition
(
periodPositionUs
)
;
}
int
enabledRendererCount
=
0
;
boolean
[
]
rendererWasEnabledFlags
=
new
boolean
[
renderers
.
length
]
;
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
Renderer
renderer
=
renderers
[
i
]
;
rendererWasEnabledFlags
[
i
]
=
renderer
.
getState
(
)
!
=
Renderer
.
STATE_DISABLED
;
SampleStream
sampleStream
=
playingPeriodHolder
.
sampleStreams
[
i
]
;
if
(
sampleStream
!
=
null
)
{
enabledRendererCount
+
+
;
}
if
(
rendererWasEnabledFlags
[
i
]
)
{
if
(
sampleStream
!
=
renderer
.
getStream
(
)
)
{
disableRenderer
(
renderer
)
;
}
else
if
(
streamResetFlags
[
i
]
)
{
renderer
.
resetPosition
(
rendererPositionUs
)
;
}
}
}
playbackInfo
=
playbackInfo
.
copyWithTrackInfo
(
playingPeriodHolder
.
getTrackGroups
(
)
playingPeriodHolder
.
getTrackSelectorResult
(
)
)
;
enableRenderers
(
rendererWasEnabledFlags
enabledRendererCount
)
;
}
else
{
queue
.
removeAfter
(
periodHolder
)
;
if
(
periodHolder
.
prepared
)
{
long
loadingPeriodPositionUs
=
Math
.
max
(
periodHolder
.
info
.
startPositionUs
periodHolder
.
toPeriodTime
(
rendererPositionUs
)
)
;
periodHolder
.
applyTrackSelection
(
newTrackSelectorResult
loadingPeriodPositionUs
false
)
;
}
}
handleLoadingMediaPeriodChanged
(
true
)
;
if
(
playbackInfo
.
playbackState
!
=
Player
.
STATE_ENDED
)
{
maybeContinueLoading
(
)
;
updatePlaybackPositions
(
)
;
handler
.
sendEmptyMessage
(
MSG_DO_SOME_WORK
)
;
}
}
private
void
updateTrackSelectionPlaybackSpeed
(
float
playbackSpeed
)
{
MediaPeriodHolder
periodHolder
=
queue
.
getPlayingPeriod
(
)
;
while
(
periodHolder
!
=
null
)
{
TrackSelection
[
]
trackSelections
=
periodHolder
.
getTrackSelectorResult
(
)
.
selections
.
getAll
(
)
;
for
(
TrackSelection
trackSelection
:
trackSelections
)
{
if
(
trackSelection
!
=
null
)
{
trackSelection
.
onPlaybackSpeed
(
playbackSpeed
)
;
}
}
periodHolder
=
periodHolder
.
getNext
(
)
;
}
}
private
void
notifyTrackSelectionDiscontinuity
(
)
{
MediaPeriodHolder
periodHolder
=
queue
.
getPlayingPeriod
(
)
;
while
(
periodHolder
!
=
null
)
{
TrackSelection
[
]
trackSelections
=
periodHolder
.
getTrackSelectorResult
(
)
.
selections
.
getAll
(
)
;
for
(
TrackSelection
trackSelection
:
trackSelections
)
{
if
(
trackSelection
!
=
null
)
{
trackSelection
.
onDiscontinuity
(
)
;
}
}
periodHolder
=
periodHolder
.
getNext
(
)
;
}
}
private
boolean
shouldTransitionToReadyState
(
boolean
renderersReadyOrEnded
)
{
if
(
enabledRenderers
.
length
=
=
0
)
{
return
isTimelineReady
(
)
;
}
if
(
!
renderersReadyOrEnded
)
{
return
false
;
}
if
(
!
playbackInfo
.
isLoading
)
{
return
true
;
}
MediaPeriodHolder
loadingHolder
=
queue
.
getLoadingPeriod
(
)
;
boolean
bufferedToEnd
=
loadingHolder
.
isFullyBuffered
(
)
&
&
loadingHolder
.
info
.
isFinal
;
return
bufferedToEnd
|
|
loadControl
.
shouldStartPlayback
(
getTotalBufferedDurationUs
(
)
mediaClock
.
getPlaybackParameters
(
)
.
speed
rebuffering
)
;
}
private
boolean
isTimelineReady
(
)
{
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
long
playingPeriodDurationUs
=
playingPeriodHolder
.
info
.
durationUs
;
return
playingPeriodHolder
.
prepared
&
&
(
playingPeriodDurationUs
=
=
C
.
TIME_UNSET
|
|
playbackInfo
.
positionUs
<
playingPeriodDurationUs
)
;
}
private
void
maybeThrowSourceInfoRefreshError
(
)
throws
IOException
{
MediaPeriodHolder
loadingPeriodHolder
=
queue
.
getLoadingPeriod
(
)
;
if
(
loadingPeriodHolder
!
=
null
)
{
for
(
Renderer
renderer
:
enabledRenderers
)
{
if
(
!
renderer
.
hasReadStreamToEnd
(
)
)
{
return
;
}
}
}
mediaSource
.
maybeThrowSourceInfoRefreshError
(
)
;
}
private
void
handleSourceInfoRefreshed
(
MediaSourceRefreshInfo
sourceRefreshInfo
)
throws
ExoPlaybackException
{
if
(
sourceRefreshInfo
.
source
!
=
mediaSource
)
{
return
;
}
playbackInfoUpdate
.
incrementPendingOperationAcks
(
pendingPrepareCount
)
;
pendingPrepareCount
=
0
;
Timeline
oldTimeline
=
playbackInfo
.
timeline
;
Timeline
timeline
=
sourceRefreshInfo
.
timeline
;
queue
.
setTimeline
(
timeline
)
;
playbackInfo
=
playbackInfo
.
copyWithTimeline
(
timeline
)
;
resolvePendingMessagePositions
(
)
;
MediaPeriodId
newPeriodId
=
playbackInfo
.
periodId
;
long
oldContentPositionUs
=
playbackInfo
.
periodId
.
isAd
(
)
?
playbackInfo
.
contentPositionUs
:
playbackInfo
.
positionUs
;
long
newContentPositionUs
=
oldContentPositionUs
;
if
(
pendingInitialSeekPosition
!
=
null
)
{
Pair
<
Object
Long
>
periodPosition
=
resolveSeekPosition
(
pendingInitialSeekPosition
true
)
;
pendingInitialSeekPosition
=
null
;
if
(
periodPosition
=
=
null
)
{
handleSourceInfoRefreshEndedPlayback
(
)
;
return
;
}
newContentPositionUs
=
periodPosition
.
second
;
newPeriodId
=
queue
.
resolveMediaPeriodIdForAds
(
periodPosition
.
first
newContentPositionUs
)
;
}
else
if
(
oldContentPositionUs
=
=
C
.
TIME_UNSET
&
&
!
timeline
.
isEmpty
(
)
)
{
Pair
<
Object
Long
>
defaultPosition
=
getPeriodPosition
(
timeline
timeline
.
getFirstWindowIndex
(
shuffleModeEnabled
)
C
.
TIME_UNSET
)
;
newPeriodId
=
queue
.
resolveMediaPeriodIdForAds
(
defaultPosition
.
first
defaultPosition
.
second
)
;
if
(
!
newPeriodId
.
isAd
(
)
)
{
newContentPositionUs
=
defaultPosition
.
second
;
}
}
else
if
(
timeline
.
getIndexOfPeriod
(
newPeriodId
.
periodUid
)
=
=
C
.
INDEX_UNSET
)
{
Object
newPeriodUid
=
resolveSubsequentPeriod
(
newPeriodId
.
periodUid
oldTimeline
timeline
)
;
if
(
newPeriodUid
=
=
null
)
{
handleSourceInfoRefreshEndedPlayback
(
)
;
return
;
}
Pair
<
Object
Long
>
defaultPosition
=
getPeriodPosition
(
timeline
timeline
.
getPeriodByUid
(
newPeriodUid
period
)
.
windowIndex
C
.
TIME_UNSET
)
;
newContentPositionUs
=
defaultPosition
.
second
;
newPeriodId
=
queue
.
resolveMediaPeriodIdForAds
(
defaultPosition
.
first
newContentPositionUs
)
;
}
else
{
newPeriodId
=
queue
.
resolveMediaPeriodIdForAds
(
playbackInfo
.
periodId
.
periodUid
newContentPositionUs
)
;
if
(
!
playbackInfo
.
periodId
.
isAd
(
)
&
&
!
newPeriodId
.
isAd
(
)
)
{
newPeriodId
=
playbackInfo
.
periodId
;
}
}
if
(
playbackInfo
.
periodId
.
equals
(
newPeriodId
)
&
&
oldContentPositionUs
=
=
newContentPositionUs
)
{
if
(
!
queue
.
updateQueuedPeriods
(
rendererPositionUs
getMaxRendererReadPositionUs
(
)
)
)
{
seekToCurrentPosition
(
false
)
;
}
}
else
{
MediaPeriodHolder
periodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
periodHolder
!
=
null
)
{
while
(
periodHolder
.
getNext
(
)
!
=
null
)
{
periodHolder
=
periodHolder
.
getNext
(
)
;
if
(
periodHolder
.
info
.
id
.
equals
(
newPeriodId
)
)
{
periodHolder
.
info
=
queue
.
getUpdatedMediaPeriodInfo
(
periodHolder
.
info
)
;
}
}
}
long
newPositionUs
=
newPeriodId
.
isAd
(
)
?
0
:
newContentPositionUs
;
long
seekedToPositionUs
=
seekToPeriodPosition
(
newPeriodId
newPositionUs
)
;
playbackInfo
=
copyWithNewPosition
(
newPeriodId
seekedToPositionUs
newContentPositionUs
)
;
}
handleLoadingMediaPeriodChanged
(
false
)
;
}
private
long
getMaxRendererReadPositionUs
(
)
{
MediaPeriodHolder
readingHolder
=
queue
.
getReadingPeriod
(
)
;
if
(
readingHolder
=
=
null
)
{
return
0
;
}
long
maxReadPositionUs
=
readingHolder
.
getRendererOffset
(
)
;
if
(
!
readingHolder
.
prepared
)
{
return
maxReadPositionUs
;
}
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
if
(
renderers
[
i
]
.
getState
(
)
=
=
Renderer
.
STATE_DISABLED
|
|
renderers
[
i
]
.
getStream
(
)
!
=
readingHolder
.
sampleStreams
[
i
]
)
{
continue
;
}
long
readingPositionUs
=
renderers
[
i
]
.
getReadingPositionUs
(
)
;
if
(
readingPositionUs
=
=
C
.
TIME_END_OF_SOURCE
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
else
{
maxReadPositionUs
=
Math
.
max
(
readingPositionUs
maxReadPositionUs
)
;
}
}
return
maxReadPositionUs
;
}
private
void
handleSourceInfoRefreshEndedPlayback
(
)
{
if
(
playbackInfo
.
playbackState
!
=
Player
.
STATE_IDLE
)
{
setState
(
Player
.
STATE_ENDED
)
;
}
resetInternal
(
false
false
true
false
true
)
;
}
private
Nullable
Object
resolveSubsequentPeriod
(
Object
oldPeriodUid
Timeline
oldTimeline
Timeline
newTimeline
)
{
int
oldPeriodIndex
=
oldTimeline
.
getIndexOfPeriod
(
oldPeriodUid
)
;
int
newPeriodIndex
=
C
.
INDEX_UNSET
;
int
maxIterations
=
oldTimeline
.
getPeriodCount
(
)
;
for
(
int
i
=
0
;
i
<
maxIterations
&
&
newPeriodIndex
=
=
C
.
INDEX_UNSET
;
i
+
+
)
{
oldPeriodIndex
=
oldTimeline
.
getNextPeriodIndex
(
oldPeriodIndex
period
window
repeatMode
shuffleModeEnabled
)
;
if
(
oldPeriodIndex
=
=
C
.
INDEX_UNSET
)
{
break
;
}
newPeriodIndex
=
newTimeline
.
getIndexOfPeriod
(
oldTimeline
.
getUidOfPeriod
(
oldPeriodIndex
)
)
;
}
return
newPeriodIndex
=
=
C
.
INDEX_UNSET
?
null
:
newTimeline
.
getUidOfPeriod
(
newPeriodIndex
)
;
}
Nullable
private
Pair
<
Object
Long
>
resolveSeekPosition
(
SeekPosition
seekPosition
boolean
trySubsequentPeriods
)
{
Timeline
timeline
=
playbackInfo
.
timeline
;
Timeline
seekTimeline
=
seekPosition
.
timeline
;
if
(
timeline
.
isEmpty
(
)
)
{
return
null
;
}
if
(
seekTimeline
.
isEmpty
(
)
)
{
seekTimeline
=
timeline
;
}
Pair
<
Object
Long
>
periodPosition
;
try
{
periodPosition
=
seekTimeline
.
getPeriodPosition
(
window
period
seekPosition
.
windowIndex
seekPosition
.
windowPositionUs
)
;
}
catch
(
IndexOutOfBoundsException
e
)
{
return
null
;
}
if
(
timeline
=
=
seekTimeline
)
{
return
periodPosition
;
}
int
periodIndex
=
timeline
.
getIndexOfPeriod
(
periodPosition
.
first
)
;
if
(
periodIndex
!
=
C
.
INDEX_UNSET
)
{
return
periodPosition
;
}
if
(
trySubsequentPeriods
)
{
Nullable
Object
periodUid
=
resolveSubsequentPeriod
(
periodPosition
.
first
seekTimeline
timeline
)
;
if
(
periodUid
!
=
null
)
{
return
getPeriodPosition
(
timeline
timeline
.
getPeriodByUid
(
periodUid
period
)
.
windowIndex
C
.
TIME_UNSET
)
;
}
}
return
null
;
}
private
Pair
<
Object
Long
>
getPeriodPosition
(
Timeline
timeline
int
windowIndex
long
windowPositionUs
)
{
return
timeline
.
getPeriodPosition
(
window
period
windowIndex
windowPositionUs
)
;
}
private
void
updatePeriods
(
)
throws
ExoPlaybackException
IOException
{
if
(
mediaSource
=
=
null
)
{
return
;
}
if
(
pendingPrepareCount
>
0
)
{
mediaSource
.
maybeThrowSourceInfoRefreshError
(
)
;
return
;
}
maybeUpdateLoadingPeriod
(
)
;
maybeUpdateReadingPeriod
(
)
;
maybeUpdatePlayingPeriod
(
)
;
}
private
void
maybeUpdateLoadingPeriod
(
)
throws
ExoPlaybackException
IOException
{
queue
.
reevaluateBuffer
(
rendererPositionUs
)
;
if
(
queue
.
shouldLoadNextMediaPeriod
(
)
)
{
MediaPeriodInfo
info
=
queue
.
getNextMediaPeriodInfo
(
rendererPositionUs
playbackInfo
)
;
if
(
info
=
=
null
)
{
maybeThrowSourceInfoRefreshError
(
)
;
}
else
{
MediaPeriodHolder
mediaPeriodHolder
=
queue
.
enqueueNextMediaPeriodHolder
(
rendererCapabilities
trackSelector
loadControl
.
getAllocator
(
)
mediaSource
info
emptyTrackSelectorResult
)
;
mediaPeriodHolder
.
mediaPeriod
.
prepare
(
this
info
.
startPositionUs
)
;
if
(
queue
.
getPlayingPeriod
(
)
=
=
mediaPeriodHolder
)
{
resetRendererPosition
(
mediaPeriodHolder
.
getStartPositionRendererTime
(
)
)
;
}
handleLoadingMediaPeriodChanged
(
false
)
;
}
}
if
(
shouldContinueLoading
)
{
shouldContinueLoading
=
isLoadingPossible
(
)
;
updateIsLoading
(
)
;
}
else
{
maybeContinueLoading
(
)
;
}
}
private
void
maybeUpdateReadingPeriod
(
)
throws
ExoPlaybackException
{
MediaPeriodHolder
readingPeriodHolder
=
queue
.
getReadingPeriod
(
)
;
if
(
readingPeriodHolder
=
=
null
)
{
return
;
}
if
(
readingPeriodHolder
.
getNext
(
)
=
=
null
)
{
if
(
readingPeriodHolder
.
info
.
isFinal
)
{
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
Renderer
renderer
=
renderers
[
i
]
;
SampleStream
sampleStream
=
readingPeriodHolder
.
sampleStreams
[
i
]
;
if
(
sampleStream
!
=
null
&
&
renderer
.
getStream
(
)
=
=
sampleStream
&
&
renderer
.
hasReadStreamToEnd
(
)
)
{
renderer
.
setCurrentStreamFinal
(
)
;
}
}
}
return
;
}
if
(
!
hasReadingPeriodFinishedReading
(
)
)
{
return
;
}
if
(
!
readingPeriodHolder
.
getNext
(
)
.
prepared
)
{
return
;
}
TrackSelectorResult
oldTrackSelectorResult
=
readingPeriodHolder
.
getTrackSelectorResult
(
)
;
readingPeriodHolder
=
queue
.
advanceReadingPeriod
(
)
;
TrackSelectorResult
newTrackSelectorResult
=
readingPeriodHolder
.
getTrackSelectorResult
(
)
;
if
(
readingPeriodHolder
.
mediaPeriod
.
readDiscontinuity
(
)
!
=
C
.
TIME_UNSET
)
{
setAllRendererStreamsFinal
(
)
;
return
;
}
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
Renderer
renderer
=
renderers
[
i
]
;
boolean
rendererWasEnabled
=
oldTrackSelectorResult
.
isRendererEnabled
(
i
)
;
if
(
rendererWasEnabled
&
&
!
renderer
.
isCurrentStreamFinal
(
)
)
{
TrackSelection
newSelection
=
newTrackSelectorResult
.
selections
.
get
(
i
)
;
boolean
newRendererEnabled
=
newTrackSelectorResult
.
isRendererEnabled
(
i
)
;
boolean
isNoSampleRenderer
=
rendererCapabilities
[
i
]
.
getTrackType
(
)
=
=
C
.
TRACK_TYPE_NONE
;
RendererConfiguration
oldConfig
=
oldTrackSelectorResult
.
rendererConfigurations
[
i
]
;
RendererConfiguration
newConfig
=
newTrackSelectorResult
.
rendererConfigurations
[
i
]
;
if
(
newRendererEnabled
&
&
newConfig
.
equals
(
oldConfig
)
&
&
!
isNoSampleRenderer
)
{
Format
[
]
formats
=
getFormats
(
newSelection
)
;
renderer
.
replaceStream
(
formats
readingPeriodHolder
.
sampleStreams
[
i
]
readingPeriodHolder
.
getRendererOffset
(
)
)
;
}
else
{
renderer
.
setCurrentStreamFinal
(
)
;
}
}
}
}
private
void
maybeUpdatePlayingPeriod
(
)
throws
ExoPlaybackException
{
boolean
advancedPlayingPeriod
=
false
;
while
(
shouldAdvancePlayingPeriod
(
)
)
{
if
(
advancedPlayingPeriod
)
{
maybeNotifyPlaybackInfoChanged
(
)
;
}
MediaPeriodHolder
oldPlayingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
oldPlayingPeriodHolder
=
=
queue
.
getReadingPeriod
(
)
)
{
setAllRendererStreamsFinal
(
)
;
}
MediaPeriodHolder
newPlayingPeriodHolder
=
queue
.
advancePlayingPeriod
(
)
;
updatePlayingPeriodRenderers
(
oldPlayingPeriodHolder
)
;
playbackInfo
=
copyWithNewPosition
(
newPlayingPeriodHolder
.
info
.
id
newPlayingPeriodHolder
.
info
.
startPositionUs
newPlayingPeriodHolder
.
info
.
contentPositionUs
)
;
int
discontinuityReason
=
oldPlayingPeriodHolder
.
info
.
isLastInTimelinePeriod
?
Player
.
DISCONTINUITY_REASON_PERIOD_TRANSITION
:
Player
.
DISCONTINUITY_REASON_AD_INSERTION
;
playbackInfoUpdate
.
setPositionDiscontinuity
(
discontinuityReason
)
;
updatePlaybackPositions
(
)
;
advancedPlayingPeriod
=
true
;
}
}
private
boolean
shouldAdvancePlayingPeriod
(
)
{
if
(
!
playWhenReady
)
{
return
false
;
}
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
playingPeriodHolder
=
=
null
)
{
return
false
;
}
MediaPeriodHolder
nextPlayingPeriodHolder
=
playingPeriodHolder
.
getNext
(
)
;
if
(
nextPlayingPeriodHolder
=
=
null
)
{
return
false
;
}
MediaPeriodHolder
readingPeriodHolder
=
queue
.
getReadingPeriod
(
)
;
if
(
playingPeriodHolder
=
=
readingPeriodHolder
&
&
!
hasReadingPeriodFinishedReading
(
)
)
{
return
false
;
}
return
rendererPositionUs
>
=
nextPlayingPeriodHolder
.
getStartPositionRendererTime
(
)
;
}
private
boolean
hasReadingPeriodFinishedReading
(
)
{
MediaPeriodHolder
readingPeriodHolder
=
queue
.
getReadingPeriod
(
)
;
if
(
!
readingPeriodHolder
.
prepared
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
Renderer
renderer
=
renderers
[
i
]
;
SampleStream
sampleStream
=
readingPeriodHolder
.
sampleStreams
[
i
]
;
if
(
renderer
.
getStream
(
)
!
=
sampleStream
|
|
(
sampleStream
!
=
null
&
&
!
renderer
.
hasReadStreamToEnd
(
)
)
)
{
return
false
;
}
}
return
true
;
}
private
void
setAllRendererStreamsFinal
(
)
{
for
(
Renderer
renderer
:
renderers
)
{
if
(
renderer
.
getStream
(
)
!
=
null
)
{
renderer
.
setCurrentStreamFinal
(
)
;
}
}
}
private
void
handlePeriodPrepared
(
MediaPeriod
mediaPeriod
)
throws
ExoPlaybackException
{
if
(
!
queue
.
isLoading
(
mediaPeriod
)
)
{
return
;
}
MediaPeriodHolder
loadingPeriodHolder
=
queue
.
getLoadingPeriod
(
)
;
loadingPeriodHolder
.
handlePrepared
(
mediaClock
.
getPlaybackParameters
(
)
.
speed
playbackInfo
.
timeline
)
;
updateLoadControlTrackSelection
(
loadingPeriodHolder
.
getTrackGroups
(
)
loadingPeriodHolder
.
getTrackSelectorResult
(
)
)
;
if
(
loadingPeriodHolder
=
=
queue
.
getPlayingPeriod
(
)
)
{
resetRendererPosition
(
loadingPeriodHolder
.
info
.
startPositionUs
)
;
updatePlayingPeriodRenderers
(
null
)
;
}
maybeContinueLoading
(
)
;
}
private
void
handleContinueLoadingRequested
(
MediaPeriod
mediaPeriod
)
{
if
(
!
queue
.
isLoading
(
mediaPeriod
)
)
{
return
;
}
queue
.
reevaluateBuffer
(
rendererPositionUs
)
;
maybeContinueLoading
(
)
;
}
private
void
handlePlaybackParameters
(
PlaybackParameters
playbackParameters
boolean
acknowledgeCommand
)
throws
ExoPlaybackException
{
eventHandler
.
obtainMessage
(
MSG_PLAYBACK_PARAMETERS_CHANGED
acknowledgeCommand
?
1
:
0
0
playbackParameters
)
.
sendToTarget
(
)
;
updateTrackSelectionPlaybackSpeed
(
playbackParameters
.
speed
)
;
for
(
Renderer
renderer
:
renderers
)
{
if
(
renderer
!
=
null
)
{
renderer
.
setOperatingRate
(
playbackParameters
.
speed
)
;
}
}
}
private
void
maybeContinueLoading
(
)
{
shouldContinueLoading
=
shouldContinueLoading
(
)
;
if
(
shouldContinueLoading
)
{
queue
.
getLoadingPeriod
(
)
.
continueLoading
(
rendererPositionUs
)
;
}
updateIsLoading
(
)
;
}
private
boolean
shouldContinueLoading
(
)
{
if
(
!
isLoadingPossible
(
)
)
{
return
false
;
}
long
bufferedDurationUs
=
getTotalBufferedDurationUs
(
queue
.
getLoadingPeriod
(
)
.
getNextLoadPositionUs
(
)
)
;
float
playbackSpeed
=
mediaClock
.
getPlaybackParameters
(
)
.
speed
;
return
loadControl
.
shouldContinueLoading
(
bufferedDurationUs
playbackSpeed
)
;
}
private
boolean
isLoadingPossible
(
)
{
MediaPeriodHolder
loadingPeriodHolder
=
queue
.
getLoadingPeriod
(
)
;
if
(
loadingPeriodHolder
=
=
null
)
{
return
false
;
}
long
nextLoadPositionUs
=
loadingPeriodHolder
.
getNextLoadPositionUs
(
)
;
if
(
nextLoadPositionUs
=
=
C
.
TIME_END_OF_SOURCE
)
{
return
false
;
}
return
true
;
}
private
void
updateIsLoading
(
)
{
MediaPeriodHolder
loadingPeriod
=
queue
.
getLoadingPeriod
(
)
;
boolean
isLoading
=
shouldContinueLoading
|
|
(
loadingPeriod
!
=
null
&
&
loadingPeriod
.
mediaPeriod
.
isLoading
(
)
)
;
if
(
isLoading
!
=
playbackInfo
.
isLoading
)
{
playbackInfo
=
playbackInfo
.
copyWithIsLoading
(
isLoading
)
;
}
}
private
PlaybackInfo
copyWithNewPosition
(
MediaPeriodId
mediaPeriodId
long
positionUs
long
contentPositionUs
)
{
deliverPendingMessageAtStartPositionRequired
=
true
;
return
playbackInfo
.
copyWithNewPosition
(
mediaPeriodId
positionUs
contentPositionUs
getTotalBufferedDurationUs
(
)
)
;
}
SuppressWarnings
(
"
ParameterNotNullable
"
)
private
void
updatePlayingPeriodRenderers
(
Nullable
MediaPeriodHolder
oldPlayingPeriodHolder
)
throws
ExoPlaybackException
{
MediaPeriodHolder
newPlayingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
if
(
newPlayingPeriodHolder
=
=
null
|
|
oldPlayingPeriodHolder
=
=
newPlayingPeriodHolder
)
{
return
;
}
int
enabledRendererCount
=
0
;
boolean
[
]
rendererWasEnabledFlags
=
new
boolean
[
renderers
.
length
]
;
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
Renderer
renderer
=
renderers
[
i
]
;
rendererWasEnabledFlags
[
i
]
=
renderer
.
getState
(
)
!
=
Renderer
.
STATE_DISABLED
;
if
(
newPlayingPeriodHolder
.
getTrackSelectorResult
(
)
.
isRendererEnabled
(
i
)
)
{
enabledRendererCount
+
+
;
}
if
(
rendererWasEnabledFlags
[
i
]
&
&
(
!
newPlayingPeriodHolder
.
getTrackSelectorResult
(
)
.
isRendererEnabled
(
i
)
|
|
(
renderer
.
isCurrentStreamFinal
(
)
&
&
renderer
.
getStream
(
)
=
=
oldPlayingPeriodHolder
.
sampleStreams
[
i
]
)
)
)
{
disableRenderer
(
renderer
)
;
}
}
playbackInfo
=
playbackInfo
.
copyWithTrackInfo
(
newPlayingPeriodHolder
.
getTrackGroups
(
)
newPlayingPeriodHolder
.
getTrackSelectorResult
(
)
)
;
enableRenderers
(
rendererWasEnabledFlags
enabledRendererCount
)
;
}
private
void
enableRenderers
(
boolean
[
]
rendererWasEnabledFlags
int
totalEnabledRendererCount
)
throws
ExoPlaybackException
{
enabledRenderers
=
new
Renderer
[
totalEnabledRendererCount
]
;
int
enabledRendererCount
=
0
;
TrackSelectorResult
trackSelectorResult
=
queue
.
getPlayingPeriod
(
)
.
getTrackSelectorResult
(
)
;
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
if
(
!
trackSelectorResult
.
isRendererEnabled
(
i
)
)
{
renderers
[
i
]
.
reset
(
)
;
}
}
for
(
int
i
=
0
;
i
<
renderers
.
length
;
i
+
+
)
{
if
(
trackSelectorResult
.
isRendererEnabled
(
i
)
)
{
enableRenderer
(
i
rendererWasEnabledFlags
[
i
]
enabledRendererCount
+
+
)
;
}
}
}
private
void
enableRenderer
(
int
rendererIndex
boolean
wasRendererEnabled
int
enabledRendererIndex
)
throws
ExoPlaybackException
{
MediaPeriodHolder
playingPeriodHolder
=
queue
.
getPlayingPeriod
(
)
;
Renderer
renderer
=
renderers
[
rendererIndex
]
;
enabledRenderers
[
enabledRendererIndex
]
=
renderer
;
if
(
renderer
.
getState
(
)
=
=
Renderer
.
STATE_DISABLED
)
{
TrackSelectorResult
trackSelectorResult
=
playingPeriodHolder
.
getTrackSelectorResult
(
)
;
RendererConfiguration
rendererConfiguration
=
trackSelectorResult
.
rendererConfigurations
[
rendererIndex
]
;
TrackSelection
newSelection
=
trackSelectorResult
.
selections
.
get
(
rendererIndex
)
;
Format
[
]
formats
=
getFormats
(
newSelection
)
;
boolean
playing
=
playWhenReady
&
&
playbackInfo
.
playbackState
=
=
Player
.
STATE_READY
;
boolean
joining
=
!
wasRendererEnabled
&
&
playing
;
renderer
.
enable
(
rendererConfiguration
formats
playingPeriodHolder
.
sampleStreams
[
rendererIndex
]
rendererPositionUs
joining
playingPeriodHolder
.
getRendererOffset
(
)
)
;
mediaClock
.
onRendererEnabled
(
renderer
)
;
if
(
playing
)
{
renderer
.
start
(
)
;
}
}
}
private
void
handleLoadingMediaPeriodChanged
(
boolean
loadingTrackSelectionChanged
)
{
MediaPeriodHolder
loadingMediaPeriodHolder
=
queue
.
getLoadingPeriod
(
)
;
MediaPeriodId
loadingMediaPeriodId
=
loadingMediaPeriodHolder
=
=
null
?
playbackInfo
.
periodId
:
loadingMediaPeriodHolder
.
info
.
id
;
boolean
loadingMediaPeriodChanged
=
!
playbackInfo
.
loadingMediaPeriodId
.
equals
(
loadingMediaPeriodId
)
;
if
(
loadingMediaPeriodChanged
)
{
playbackInfo
=
playbackInfo
.
copyWithLoadingMediaPeriodId
(
loadingMediaPeriodId
)
;
}
playbackInfo
.
bufferedPositionUs
=
loadingMediaPeriodHolder
=
=
null
?
playbackInfo
.
positionUs
:
loadingMediaPeriodHolder
.
getBufferedPositionUs
(
)
;
playbackInfo
.
totalBufferedDurationUs
=
getTotalBufferedDurationUs
(
)
;
if
(
(
loadingMediaPeriodChanged
|
|
loadingTrackSelectionChanged
)
&
&
loadingMediaPeriodHolder
!
=
null
&
&
loadingMediaPeriodHolder
.
prepared
)
{
updateLoadControlTrackSelection
(
loadingMediaPeriodHolder
.
getTrackGroups
(
)
loadingMediaPeriodHolder
.
getTrackSelectorResult
(
)
)
;
}
}
private
long
getTotalBufferedDurationUs
(
)
{
return
getTotalBufferedDurationUs
(
playbackInfo
.
bufferedPositionUs
)
;
}
private
long
getTotalBufferedDurationUs
(
long
bufferedPositionInLoadingPeriodUs
)
{
MediaPeriodHolder
loadingPeriodHolder
=
queue
.
getLoadingPeriod
(
)
;
if
(
loadingPeriodHolder
=
=
null
)
{
return
0
;
}
long
totalBufferedDurationUs
=
bufferedPositionInLoadingPeriodUs
-
loadingPeriodHolder
.
toPeriodTime
(
rendererPositionUs
)
;
return
Math
.
max
(
0
totalBufferedDurationUs
)
;
}
private
void
updateLoadControlTrackSelection
(
TrackGroupArray
trackGroups
TrackSelectorResult
trackSelectorResult
)
{
loadControl
.
onTracksSelected
(
renderers
trackGroups
trackSelectorResult
.
selections
)
;
}
private
void
sendPlaybackParametersChangedInternal
(
PlaybackParameters
playbackParameters
boolean
acknowledgeCommand
)
{
handler
.
obtainMessage
(
MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL
acknowledgeCommand
?
1
:
0
0
playbackParameters
)
.
sendToTarget
(
)
;
}
private
static
Format
[
]
getFormats
(
TrackSelection
newSelection
)
{
int
length
=
newSelection
!
=
null
?
newSelection
.
length
(
)
:
0
;
Format
[
]
formats
=
new
Format
[
length
]
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
formats
[
i
]
=
newSelection
.
getFormat
(
i
)
;
}
return
formats
;
}
private
static
final
class
SeekPosition
{
public
final
Timeline
timeline
;
public
final
int
windowIndex
;
public
final
long
windowPositionUs
;
public
SeekPosition
(
Timeline
timeline
int
windowIndex
long
windowPositionUs
)
{
this
.
timeline
=
timeline
;
this
.
windowIndex
=
windowIndex
;
this
.
windowPositionUs
=
windowPositionUs
;
}
}
private
static
final
class
PendingMessageInfo
implements
Comparable
<
PendingMessageInfo
>
{
public
final
PlayerMessage
message
;
public
int
resolvedPeriodIndex
;
public
long
resolvedPeriodTimeUs
;
Nullable
public
Object
resolvedPeriodUid
;
public
PendingMessageInfo
(
PlayerMessage
message
)
{
this
.
message
=
message
;
}
public
void
setResolvedPosition
(
int
periodIndex
long
periodTimeUs
Object
periodUid
)
{
resolvedPeriodIndex
=
periodIndex
;
resolvedPeriodTimeUs
=
periodTimeUs
;
resolvedPeriodUid
=
periodUid
;
}
Override
public
int
compareTo
(
PendingMessageInfo
other
)
{
if
(
(
resolvedPeriodUid
=
=
null
)
!
=
(
other
.
resolvedPeriodUid
=
=
null
)
)
{
return
resolvedPeriodUid
!
=
null
?
-
1
:
1
;
}
if
(
resolvedPeriodUid
=
=
null
)
{
return
0
;
}
int
comparePeriodIndex
=
resolvedPeriodIndex
-
other
.
resolvedPeriodIndex
;
if
(
comparePeriodIndex
!
=
0
)
{
return
comparePeriodIndex
;
}
return
Util
.
compareLong
(
resolvedPeriodTimeUs
other
.
resolvedPeriodTimeUs
)
;
}
}
private
static
final
class
MediaSourceRefreshInfo
{
public
final
MediaSource
source
;
public
final
Timeline
timeline
;
public
MediaSourceRefreshInfo
(
MediaSource
source
Timeline
timeline
)
{
this
.
source
=
source
;
this
.
timeline
=
timeline
;
}
}
private
static
final
class
PlaybackInfoUpdate
{
private
PlaybackInfo
lastPlaybackInfo
;
private
int
operationAcks
;
private
boolean
positionDiscontinuity
;
private
DiscontinuityReason
int
discontinuityReason
;
public
boolean
hasPendingUpdate
(
PlaybackInfo
playbackInfo
)
{
return
playbackInfo
!
=
lastPlaybackInfo
|
|
operationAcks
>
0
|
|
positionDiscontinuity
;
}
public
void
reset
(
PlaybackInfo
playbackInfo
)
{
lastPlaybackInfo
=
playbackInfo
;
operationAcks
=
0
;
positionDiscontinuity
=
false
;
}
public
void
incrementPendingOperationAcks
(
int
operationAcks
)
{
this
.
operationAcks
+
=
operationAcks
;
}
public
void
setPositionDiscontinuity
(
DiscontinuityReason
int
discontinuityReason
)
{
if
(
positionDiscontinuity
&
&
this
.
discontinuityReason
!
=
Player
.
DISCONTINUITY_REASON_INTERNAL
)
{
Assertions
.
checkArgument
(
discontinuityReason
=
=
Player
.
DISCONTINUITY_REASON_INTERNAL
)
;
return
;
}
positionDiscontinuity
=
true
;
this
.
discontinuityReason
=
discontinuityReason
;
}
}
}
