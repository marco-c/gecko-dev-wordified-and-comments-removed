package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
analytics
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Pair
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
PlaybackParameters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Player
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Timeline
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Timeline
.
Period
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
analytics
.
PlaybackStats
.
PlaybackState
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
.
MediaPeriodId
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSourceEventListener
.
LoadEventInfo
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSourceEventListener
.
MediaLoadData
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroupArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelectionArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
org
.
checkerframework
.
checker
.
nullness
.
compatqual
.
NullableType
;
public
final
class
PlaybackStatsListener
implements
AnalyticsListener
PlaybackSessionManager
.
Listener
{
public
interface
Callback
{
void
onPlaybackStatsReady
(
EventTime
eventTime
PlaybackStats
playbackStats
)
;
}
private
final
PlaybackSessionManager
sessionManager
;
private
final
Map
<
String
PlaybackStatsTracker
>
playbackStatsTrackers
;
private
final
Map
<
String
EventTime
>
sessionStartEventTimes
;
Nullable
private
final
Callback
callback
;
private
final
boolean
keepHistory
;
private
final
Period
period
;
private
PlaybackStats
finishedPlaybackStats
;
Nullable
private
String
activeContentPlayback
;
Nullable
private
String
activeAdPlayback
;
private
boolean
playWhenReady
;
Player
.
State
private
int
playbackState
;
private
boolean
isSuppressed
;
private
float
playbackSpeed
;
public
PlaybackStatsListener
(
boolean
keepHistory
Nullable
Callback
callback
)
{
this
.
callback
=
callback
;
this
.
keepHistory
=
keepHistory
;
sessionManager
=
new
DefaultPlaybackSessionManager
(
)
;
playbackStatsTrackers
=
new
HashMap
<
>
(
)
;
sessionStartEventTimes
=
new
HashMap
<
>
(
)
;
finishedPlaybackStats
=
PlaybackStats
.
EMPTY
;
playWhenReady
=
false
;
playbackState
=
Player
.
STATE_IDLE
;
playbackSpeed
=
1f
;
period
=
new
Period
(
)
;
sessionManager
.
setListener
(
this
)
;
}
public
PlaybackStats
getCombinedPlaybackStats
(
)
{
PlaybackStats
[
]
allPendingPlaybackStats
=
new
PlaybackStats
[
playbackStatsTrackers
.
size
(
)
+
1
]
;
allPendingPlaybackStats
[
0
]
=
finishedPlaybackStats
;
int
index
=
1
;
for
(
PlaybackStatsTracker
tracker
:
playbackStatsTrackers
.
values
(
)
)
{
allPendingPlaybackStats
[
index
+
+
]
=
tracker
.
build
(
false
)
;
}
return
PlaybackStats
.
merge
(
allPendingPlaybackStats
)
;
}
Nullable
public
PlaybackStats
getPlaybackStats
(
)
{
PlaybackStatsTracker
activeStatsTracker
=
activeAdPlayback
!
=
null
?
playbackStatsTrackers
.
get
(
activeAdPlayback
)
:
activeContentPlayback
!
=
null
?
playbackStatsTrackers
.
get
(
activeContentPlayback
)
:
null
;
return
activeStatsTracker
=
=
null
?
null
:
activeStatsTracker
.
build
(
false
)
;
}
public
void
finishAllSessions
(
)
{
HashMap
<
String
PlaybackStatsTracker
>
trackerCopy
=
new
HashMap
<
>
(
playbackStatsTrackers
)
;
EventTime
dummyEventTime
=
new
EventTime
(
SystemClock
.
elapsedRealtime
(
)
Timeline
.
EMPTY
0
null
0
0
0
)
;
for
(
String
session
:
trackerCopy
.
keySet
(
)
)
{
onSessionFinished
(
dummyEventTime
session
false
)
;
}
}
Override
public
void
onSessionCreated
(
EventTime
eventTime
String
session
)
{
PlaybackStatsTracker
tracker
=
new
PlaybackStatsTracker
(
keepHistory
eventTime
)
;
tracker
.
onPlayerStateChanged
(
eventTime
playWhenReady
playbackState
true
)
;
tracker
.
onIsSuppressedChanged
(
eventTime
isSuppressed
true
)
;
tracker
.
onPlaybackSpeedChanged
(
eventTime
playbackSpeed
)
;
playbackStatsTrackers
.
put
(
session
tracker
)
;
sessionStartEventTimes
.
put
(
session
eventTime
)
;
}
Override
public
void
onSessionActive
(
EventTime
eventTime
String
session
)
{
Assertions
.
checkNotNull
(
playbackStatsTrackers
.
get
(
session
)
)
.
onForeground
(
eventTime
)
;
if
(
eventTime
.
mediaPeriodId
!
=
null
&
&
eventTime
.
mediaPeriodId
.
isAd
(
)
)
{
activeAdPlayback
=
session
;
}
else
{
activeContentPlayback
=
session
;
}
}
Override
public
void
onAdPlaybackStarted
(
EventTime
eventTime
String
contentSession
String
adSession
)
{
Assertions
.
checkState
(
Assertions
.
checkNotNull
(
eventTime
.
mediaPeriodId
)
.
isAd
(
)
)
;
long
contentPositionUs
=
eventTime
.
timeline
.
getPeriodByUid
(
eventTime
.
mediaPeriodId
.
periodUid
period
)
.
getAdGroupTimeUs
(
eventTime
.
mediaPeriodId
.
adGroupIndex
)
;
EventTime
contentEventTime
=
new
EventTime
(
eventTime
.
realtimeMs
eventTime
.
timeline
eventTime
.
windowIndex
new
MediaPeriodId
(
eventTime
.
mediaPeriodId
.
periodUid
eventTime
.
mediaPeriodId
.
windowSequenceNumber
eventTime
.
mediaPeriodId
.
adGroupIndex
)
C
.
usToMs
(
contentPositionUs
)
eventTime
.
currentPlaybackPositionMs
eventTime
.
totalBufferedDurationMs
)
;
Assertions
.
checkNotNull
(
playbackStatsTrackers
.
get
(
contentSession
)
)
.
onInterruptedByAd
(
contentEventTime
)
;
}
Override
public
void
onSessionFinished
(
EventTime
eventTime
String
session
boolean
automaticTransition
)
{
if
(
session
.
equals
(
activeAdPlayback
)
)
{
activeAdPlayback
=
null
;
}
else
if
(
session
.
equals
(
activeContentPlayback
)
)
{
activeContentPlayback
=
null
;
}
PlaybackStatsTracker
tracker
=
Assertions
.
checkNotNull
(
playbackStatsTrackers
.
remove
(
session
)
)
;
EventTime
startEventTime
=
Assertions
.
checkNotNull
(
sessionStartEventTimes
.
remove
(
session
)
)
;
if
(
automaticTransition
)
{
tracker
.
onPlayerStateChanged
(
eventTime
true
Player
.
STATE_ENDED
false
)
;
}
tracker
.
onFinished
(
eventTime
)
;
PlaybackStats
playbackStats
=
tracker
.
build
(
true
)
;
finishedPlaybackStats
=
PlaybackStats
.
merge
(
finishedPlaybackStats
playbackStats
)
;
if
(
callback
!
=
null
)
{
callback
.
onPlaybackStatsReady
(
startEventTime
playbackStats
)
;
}
}
Override
public
void
onPlayerStateChanged
(
EventTime
eventTime
boolean
playWhenReady
Player
.
State
int
playbackState
)
{
this
.
playWhenReady
=
playWhenReady
;
this
.
playbackState
=
playbackState
;
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
boolean
belongsToPlayback
=
sessionManager
.
belongsToSession
(
eventTime
session
)
;
playbackStatsTrackers
.
get
(
session
)
.
onPlayerStateChanged
(
eventTime
playWhenReady
playbackState
belongsToPlayback
)
;
}
}
Override
public
void
onPlaybackSuppressionReasonChanged
(
EventTime
eventTime
int
playbackSuppressionReason
)
{
isSuppressed
=
playbackSuppressionReason
!
=
Player
.
PLAYBACK_SUPPRESSION_REASON_NONE
;
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
boolean
belongsToPlayback
=
sessionManager
.
belongsToSession
(
eventTime
session
)
;
playbackStatsTrackers
.
get
(
session
)
.
onIsSuppressedChanged
(
eventTime
isSuppressed
belongsToPlayback
)
;
}
}
Override
public
void
onTimelineChanged
(
EventTime
eventTime
int
reason
)
{
sessionManager
.
handleTimelineUpdate
(
eventTime
)
;
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onPositionDiscontinuity
(
eventTime
)
;
}
}
}
Override
public
void
onPositionDiscontinuity
(
EventTime
eventTime
int
reason
)
{
sessionManager
.
handlePositionDiscontinuity
(
eventTime
reason
)
;
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onPositionDiscontinuity
(
eventTime
)
;
}
}
}
Override
public
void
onSeekStarted
(
EventTime
eventTime
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onSeekStarted
(
eventTime
)
;
}
}
}
Override
public
void
onSeekProcessed
(
EventTime
eventTime
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onSeekProcessed
(
eventTime
)
;
}
}
}
Override
public
void
onPlayerError
(
EventTime
eventTime
ExoPlaybackException
error
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onFatalError
(
eventTime
error
)
;
}
}
}
Override
public
void
onPlaybackParametersChanged
(
EventTime
eventTime
PlaybackParameters
playbackParameters
)
{
playbackSpeed
=
playbackParameters
.
speed
;
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
PlaybackStatsTracker
tracker
:
playbackStatsTrackers
.
values
(
)
)
{
tracker
.
onPlaybackSpeedChanged
(
eventTime
playbackSpeed
)
;
}
}
Override
public
void
onTracksChanged
(
EventTime
eventTime
TrackGroupArray
trackGroups
TrackSelectionArray
trackSelections
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onTracksChanged
(
eventTime
trackSelections
)
;
}
}
}
Override
public
void
onLoadStarted
(
EventTime
eventTime
LoadEventInfo
loadEventInfo
MediaLoadData
mediaLoadData
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onLoadStarted
(
eventTime
)
;
}
}
}
Override
public
void
onDownstreamFormatChanged
(
EventTime
eventTime
MediaLoadData
mediaLoadData
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onDownstreamFormatChanged
(
eventTime
mediaLoadData
)
;
}
}
}
Override
public
void
onVideoSizeChanged
(
EventTime
eventTime
int
width
int
height
int
unappliedRotationDegrees
float
pixelWidthHeightRatio
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onVideoSizeChanged
(
eventTime
width
height
)
;
}
}
}
Override
public
void
onBandwidthEstimate
(
EventTime
eventTime
int
totalLoadTimeMs
long
totalBytesLoaded
long
bitrateEstimate
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onBandwidthData
(
totalLoadTimeMs
totalBytesLoaded
)
;
}
}
}
Override
public
void
onAudioUnderrun
(
EventTime
eventTime
int
bufferSize
long
bufferSizeMs
long
elapsedSinceLastFeedMs
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onAudioUnderrun
(
)
;
}
}
}
Override
public
void
onDroppedVideoFrames
(
EventTime
eventTime
int
droppedFrames
long
elapsedMs
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onDroppedVideoFrames
(
droppedFrames
)
;
}
}
}
Override
public
void
onLoadError
(
EventTime
eventTime
LoadEventInfo
loadEventInfo
MediaLoadData
mediaLoadData
IOException
error
boolean
wasCanceled
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onNonFatalError
(
eventTime
error
)
;
}
}
}
Override
public
void
onDrmSessionManagerError
(
EventTime
eventTime
Exception
error
)
{
sessionManager
.
updateSessions
(
eventTime
)
;
for
(
String
session
:
playbackStatsTrackers
.
keySet
(
)
)
{
if
(
sessionManager
.
belongsToSession
(
eventTime
session
)
)
{
playbackStatsTrackers
.
get
(
session
)
.
onNonFatalError
(
eventTime
error
)
;
}
}
}
private
static
final
class
PlaybackStatsTracker
{
private
final
boolean
keepHistory
;
private
final
long
[
]
playbackStateDurationsMs
;
private
final
List
<
Pair
<
EventTime
PlaybackState
Integer
>
>
playbackStateHistory
;
private
final
List
<
long
[
]
>
mediaTimeHistory
;
private
final
List
<
Pair
<
EventTime
NullableType
Format
>
>
videoFormatHistory
;
private
final
List
<
Pair
<
EventTime
NullableType
Format
>
>
audioFormatHistory
;
private
final
List
<
Pair
<
EventTime
Exception
>
>
fatalErrorHistory
;
private
final
List
<
Pair
<
EventTime
Exception
>
>
nonFatalErrorHistory
;
private
final
boolean
isAd
;
private
long
firstReportedTimeMs
;
private
boolean
hasBeenReady
;
private
boolean
hasEnded
;
private
boolean
isJoinTimeInvalid
;
private
int
pauseCount
;
private
int
pauseBufferCount
;
private
int
seekCount
;
private
int
rebufferCount
;
private
long
maxRebufferTimeMs
;
private
int
initialVideoFormatHeight
;
private
long
initialVideoFormatBitrate
;
private
long
initialAudioFormatBitrate
;
private
long
videoFormatHeightTimeMs
;
private
long
videoFormatHeightTimeProduct
;
private
long
videoFormatBitrateTimeMs
;
private
long
videoFormatBitrateTimeProduct
;
private
long
audioFormatTimeMs
;
private
long
audioFormatBitrateTimeProduct
;
private
long
bandwidthTimeMs
;
private
long
bandwidthBytes
;
private
long
droppedFrames
;
private
long
audioUnderruns
;
private
int
fatalErrorCount
;
private
int
nonFatalErrorCount
;
private
PlaybackState
int
currentPlaybackState
;
private
long
currentPlaybackStateStartTimeMs
;
private
boolean
isSeeking
;
private
boolean
isForeground
;
private
boolean
isInterruptedByAd
;
private
boolean
isFinished
;
private
boolean
playWhenReady
;
Player
.
State
private
int
playerPlaybackState
;
private
boolean
isSuppressed
;
private
boolean
hasFatalError
;
private
boolean
startedLoading
;
private
long
lastRebufferStartTimeMs
;
Nullable
private
Format
currentVideoFormat
;
Nullable
private
Format
currentAudioFormat
;
private
long
lastVideoFormatStartTimeMs
;
private
long
lastAudioFormatStartTimeMs
;
private
float
currentPlaybackSpeed
;
public
PlaybackStatsTracker
(
boolean
keepHistory
EventTime
startTime
)
{
this
.
keepHistory
=
keepHistory
;
playbackStateDurationsMs
=
new
long
[
PlaybackStats
.
PLAYBACK_STATE_COUNT
]
;
playbackStateHistory
=
keepHistory
?
new
ArrayList
<
>
(
)
:
Collections
.
emptyList
(
)
;
mediaTimeHistory
=
keepHistory
?
new
ArrayList
<
>
(
)
:
Collections
.
emptyList
(
)
;
videoFormatHistory
=
keepHistory
?
new
ArrayList
<
>
(
)
:
Collections
.
emptyList
(
)
;
audioFormatHistory
=
keepHistory
?
new
ArrayList
<
>
(
)
:
Collections
.
emptyList
(
)
;
fatalErrorHistory
=
keepHistory
?
new
ArrayList
<
>
(
)
:
Collections
.
emptyList
(
)
;
nonFatalErrorHistory
=
keepHistory
?
new
ArrayList
<
>
(
)
:
Collections
.
emptyList
(
)
;
currentPlaybackState
=
PlaybackStats
.
PLAYBACK_STATE_NOT_STARTED
;
currentPlaybackStateStartTimeMs
=
startTime
.
realtimeMs
;
playerPlaybackState
=
Player
.
STATE_IDLE
;
firstReportedTimeMs
=
C
.
TIME_UNSET
;
maxRebufferTimeMs
=
C
.
TIME_UNSET
;
isAd
=
startTime
.
mediaPeriodId
!
=
null
&
&
startTime
.
mediaPeriodId
.
isAd
(
)
;
initialAudioFormatBitrate
=
C
.
LENGTH_UNSET
;
initialVideoFormatBitrate
=
C
.
LENGTH_UNSET
;
initialVideoFormatHeight
=
C
.
LENGTH_UNSET
;
currentPlaybackSpeed
=
1f
;
}
public
void
onPlayerStateChanged
(
EventTime
eventTime
boolean
playWhenReady
Player
.
State
int
playbackState
boolean
belongsToPlayback
)
{
this
.
playWhenReady
=
playWhenReady
;
playerPlaybackState
=
playbackState
;
if
(
playbackState
!
=
Player
.
STATE_IDLE
)
{
hasFatalError
=
false
;
}
if
(
playbackState
=
=
Player
.
STATE_IDLE
|
|
playbackState
=
=
Player
.
STATE_ENDED
)
{
isInterruptedByAd
=
false
;
}
maybeUpdatePlaybackState
(
eventTime
belongsToPlayback
)
;
}
public
void
onIsSuppressedChanged
(
EventTime
eventTime
boolean
isSuppressed
boolean
belongsToPlayback
)
{
this
.
isSuppressed
=
isSuppressed
;
maybeUpdatePlaybackState
(
eventTime
belongsToPlayback
)
;
}
public
void
onPositionDiscontinuity
(
EventTime
eventTime
)
{
isInterruptedByAd
=
false
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onSeekStarted
(
EventTime
eventTime
)
{
isSeeking
=
true
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onSeekProcessed
(
EventTime
eventTime
)
{
isSeeking
=
false
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onFatalError
(
EventTime
eventTime
Exception
error
)
{
fatalErrorCount
+
+
;
if
(
keepHistory
)
{
fatalErrorHistory
.
add
(
Pair
.
create
(
eventTime
error
)
)
;
}
hasFatalError
=
true
;
isInterruptedByAd
=
false
;
isSeeking
=
false
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onLoadStarted
(
EventTime
eventTime
)
{
startedLoading
=
true
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onForeground
(
EventTime
eventTime
)
{
isForeground
=
true
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onInterruptedByAd
(
EventTime
eventTime
)
{
isInterruptedByAd
=
true
;
isSeeking
=
false
;
maybeUpdatePlaybackState
(
eventTime
true
)
;
}
public
void
onFinished
(
EventTime
eventTime
)
{
isFinished
=
true
;
maybeUpdatePlaybackState
(
eventTime
false
)
;
}
public
void
onTracksChanged
(
EventTime
eventTime
TrackSelectionArray
trackSelections
)
{
boolean
videoEnabled
=
false
;
boolean
audioEnabled
=
false
;
for
(
TrackSelection
trackSelection
:
trackSelections
.
getAll
(
)
)
{
if
(
trackSelection
!
=
null
&
&
trackSelection
.
length
(
)
>
0
)
{
int
trackType
=
MimeTypes
.
getTrackType
(
trackSelection
.
getFormat
(
0
)
.
sampleMimeType
)
;
if
(
trackType
=
=
C
.
TRACK_TYPE_VIDEO
)
{
videoEnabled
=
true
;
}
else
if
(
trackType
=
=
C
.
TRACK_TYPE_AUDIO
)
{
audioEnabled
=
true
;
}
}
}
if
(
!
videoEnabled
)
{
maybeUpdateVideoFormat
(
eventTime
null
)
;
}
if
(
!
audioEnabled
)
{
maybeUpdateAudioFormat
(
eventTime
null
)
;
}
}
public
void
onDownstreamFormatChanged
(
EventTime
eventTime
MediaLoadData
mediaLoadData
)
{
if
(
mediaLoadData
.
trackType
=
=
C
.
TRACK_TYPE_VIDEO
|
|
mediaLoadData
.
trackType
=
=
C
.
TRACK_TYPE_DEFAULT
)
{
maybeUpdateVideoFormat
(
eventTime
mediaLoadData
.
trackFormat
)
;
}
else
if
(
mediaLoadData
.
trackType
=
=
C
.
TRACK_TYPE_AUDIO
)
{
maybeUpdateAudioFormat
(
eventTime
mediaLoadData
.
trackFormat
)
;
}
}
public
void
onVideoSizeChanged
(
EventTime
eventTime
int
width
int
height
)
{
if
(
currentVideoFormat
!
=
null
&
&
currentVideoFormat
.
height
=
=
Format
.
NO_VALUE
)
{
Format
formatWithHeight
=
currentVideoFormat
.
copyWithVideoSize
(
width
height
)
;
maybeUpdateVideoFormat
(
eventTime
formatWithHeight
)
;
}
}
public
void
onPlaybackSpeedChanged
(
EventTime
eventTime
float
playbackSpeed
)
{
maybeUpdateMediaTimeHistory
(
eventTime
.
realtimeMs
eventTime
.
eventPlaybackPositionMs
)
;
maybeRecordVideoFormatTime
(
eventTime
.
realtimeMs
)
;
maybeRecordAudioFormatTime
(
eventTime
.
realtimeMs
)
;
currentPlaybackSpeed
=
playbackSpeed
;
}
public
void
onAudioUnderrun
(
)
{
audioUnderruns
+
+
;
}
public
void
onDroppedVideoFrames
(
int
droppedFrames
)
{
this
.
droppedFrames
+
=
droppedFrames
;
}
public
void
onBandwidthData
(
long
timeMs
long
bytes
)
{
bandwidthTimeMs
+
=
timeMs
;
bandwidthBytes
+
=
bytes
;
}
public
void
onNonFatalError
(
EventTime
eventTime
Exception
error
)
{
nonFatalErrorCount
+
+
;
if
(
keepHistory
)
{
nonFatalErrorHistory
.
add
(
Pair
.
create
(
eventTime
error
)
)
;
}
}
public
PlaybackStats
build
(
boolean
isFinal
)
{
long
[
]
playbackStateDurationsMs
=
this
.
playbackStateDurationsMs
;
List
<
long
[
]
>
mediaTimeHistory
=
this
.
mediaTimeHistory
;
if
(
!
isFinal
)
{
long
buildTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
playbackStateDurationsMs
=
Arrays
.
copyOf
(
this
.
playbackStateDurationsMs
PlaybackStats
.
PLAYBACK_STATE_COUNT
)
;
long
lastStateDurationMs
=
Math
.
max
(
0
buildTimeMs
-
currentPlaybackStateStartTimeMs
)
;
playbackStateDurationsMs
[
currentPlaybackState
]
+
=
lastStateDurationMs
;
maybeUpdateMaxRebufferTimeMs
(
buildTimeMs
)
;
maybeRecordVideoFormatTime
(
buildTimeMs
)
;
maybeRecordAudioFormatTime
(
buildTimeMs
)
;
mediaTimeHistory
=
new
ArrayList
<
>
(
this
.
mediaTimeHistory
)
;
if
(
keepHistory
&
&
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_PLAYING
)
{
mediaTimeHistory
.
add
(
guessMediaTimeBasedOnElapsedRealtime
(
buildTimeMs
)
)
;
}
}
boolean
isJoinTimeInvalid
=
this
.
isJoinTimeInvalid
|
|
!
hasBeenReady
;
long
validJoinTimeMs
=
isJoinTimeInvalid
?
C
.
TIME_UNSET
:
playbackStateDurationsMs
[
PlaybackStats
.
PLAYBACK_STATE_JOINING_FOREGROUND
]
;
boolean
hasBackgroundJoin
=
playbackStateDurationsMs
[
PlaybackStats
.
PLAYBACK_STATE_JOINING_BACKGROUND
]
>
0
;
List
<
Pair
<
EventTime
NullableType
Format
>
>
videoHistory
=
isFinal
?
videoFormatHistory
:
new
ArrayList
<
>
(
videoFormatHistory
)
;
List
<
Pair
<
EventTime
NullableType
Format
>
>
audioHistory
=
isFinal
?
audioFormatHistory
:
new
ArrayList
<
>
(
audioFormatHistory
)
;
return
new
PlaybackStats
(
1
playbackStateDurationsMs
isFinal
?
playbackStateHistory
:
new
ArrayList
<
>
(
playbackStateHistory
)
mediaTimeHistory
firstReportedTimeMs
isForeground
?
1
:
0
hasBeenReady
?
0
:
1
hasEnded
?
1
:
0
hasBackgroundJoin
?
1
:
0
validJoinTimeMs
isJoinTimeInvalid
?
0
:
1
pauseCount
pauseBufferCount
seekCount
rebufferCount
maxRebufferTimeMs
isAd
?
1
:
0
videoHistory
audioHistory
videoFormatHeightTimeMs
videoFormatHeightTimeProduct
videoFormatBitrateTimeMs
videoFormatBitrateTimeProduct
audioFormatTimeMs
audioFormatBitrateTimeProduct
initialVideoFormatHeight
=
=
C
.
LENGTH_UNSET
?
0
:
1
initialVideoFormatBitrate
=
=
C
.
LENGTH_UNSET
?
0
:
1
initialVideoFormatHeight
initialVideoFormatBitrate
initialAudioFormatBitrate
=
=
C
.
LENGTH_UNSET
?
0
:
1
initialAudioFormatBitrate
bandwidthTimeMs
bandwidthBytes
droppedFrames
audioUnderruns
fatalErrorCount
>
0
?
1
:
0
fatalErrorCount
nonFatalErrorCount
fatalErrorHistory
nonFatalErrorHistory
)
;
}
private
void
maybeUpdatePlaybackState
(
EventTime
eventTime
boolean
belongsToPlayback
)
{
PlaybackState
int
newPlaybackState
=
resolveNewPlaybackState
(
)
;
if
(
newPlaybackState
=
=
currentPlaybackState
)
{
return
;
}
Assertions
.
checkArgument
(
eventTime
.
realtimeMs
>
=
currentPlaybackStateStartTimeMs
)
;
long
stateDurationMs
=
eventTime
.
realtimeMs
-
currentPlaybackStateStartTimeMs
;
playbackStateDurationsMs
[
currentPlaybackState
]
+
=
stateDurationMs
;
if
(
firstReportedTimeMs
=
=
C
.
TIME_UNSET
)
{
firstReportedTimeMs
=
eventTime
.
realtimeMs
;
}
isJoinTimeInvalid
|
=
isInvalidJoinTransition
(
currentPlaybackState
newPlaybackState
)
;
hasBeenReady
|
=
isReadyState
(
newPlaybackState
)
;
hasEnded
|
=
newPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_ENDED
;
if
(
!
isPausedState
(
currentPlaybackState
)
&
&
isPausedState
(
newPlaybackState
)
)
{
pauseCount
+
+
;
}
if
(
newPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_SEEKING
)
{
seekCount
+
+
;
}
if
(
!
isRebufferingState
(
currentPlaybackState
)
&
&
isRebufferingState
(
newPlaybackState
)
)
{
rebufferCount
+
+
;
lastRebufferStartTimeMs
=
eventTime
.
realtimeMs
;
}
if
(
isRebufferingState
(
currentPlaybackState
)
&
&
currentPlaybackState
!
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED_BUFFERING
&
&
newPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED_BUFFERING
)
{
pauseBufferCount
+
+
;
}
maybeUpdateMediaTimeHistory
(
eventTime
.
realtimeMs
belongsToPlayback
?
eventTime
.
eventPlaybackPositionMs
:
C
.
TIME_UNSET
)
;
maybeUpdateMaxRebufferTimeMs
(
eventTime
.
realtimeMs
)
;
maybeRecordVideoFormatTime
(
eventTime
.
realtimeMs
)
;
maybeRecordAudioFormatTime
(
eventTime
.
realtimeMs
)
;
currentPlaybackState
=
newPlaybackState
;
currentPlaybackStateStartTimeMs
=
eventTime
.
realtimeMs
;
if
(
keepHistory
)
{
playbackStateHistory
.
add
(
Pair
.
create
(
eventTime
currentPlaybackState
)
)
;
}
}
private
PlaybackState
int
resolveNewPlaybackState
(
)
{
if
(
isFinished
)
{
return
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_ENDED
?
PlaybackStats
.
PLAYBACK_STATE_ENDED
:
PlaybackStats
.
PLAYBACK_STATE_ABANDONED
;
}
else
if
(
isSeeking
)
{
return
PlaybackStats
.
PLAYBACK_STATE_SEEKING
;
}
else
if
(
hasFatalError
)
{
return
PlaybackStats
.
PLAYBACK_STATE_FAILED
;
}
else
if
(
!
isForeground
)
{
return
startedLoading
?
PlaybackStats
.
PLAYBACK_STATE_JOINING_BACKGROUND
:
PlaybackStats
.
PLAYBACK_STATE_NOT_STARTED
;
}
else
if
(
isInterruptedByAd
)
{
return
PlaybackStats
.
PLAYBACK_STATE_INTERRUPTED_BY_AD
;
}
else
if
(
playerPlaybackState
=
=
Player
.
STATE_ENDED
)
{
return
PlaybackStats
.
PLAYBACK_STATE_ENDED
;
}
else
if
(
playerPlaybackState
=
=
Player
.
STATE_BUFFERING
)
{
if
(
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_NOT_STARTED
|
|
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_JOINING_BACKGROUND
|
|
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_JOINING_FOREGROUND
|
|
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_INTERRUPTED_BY_AD
)
{
return
PlaybackStats
.
PLAYBACK_STATE_JOINING_FOREGROUND
;
}
if
(
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_SEEKING
|
|
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_SEEK_BUFFERING
)
{
return
PlaybackStats
.
PLAYBACK_STATE_SEEK_BUFFERING
;
}
if
(
!
playWhenReady
)
{
return
PlaybackStats
.
PLAYBACK_STATE_PAUSED_BUFFERING
;
}
return
isSuppressed
?
PlaybackStats
.
PLAYBACK_STATE_SUPPRESSED_BUFFERING
:
PlaybackStats
.
PLAYBACK_STATE_BUFFERING
;
}
else
if
(
playerPlaybackState
=
=
Player
.
STATE_READY
)
{
if
(
!
playWhenReady
)
{
return
PlaybackStats
.
PLAYBACK_STATE_PAUSED
;
}
return
isSuppressed
?
PlaybackStats
.
PLAYBACK_STATE_SUPPRESSED
:
PlaybackStats
.
PLAYBACK_STATE_PLAYING
;
}
else
if
(
playerPlaybackState
=
=
Player
.
STATE_IDLE
&
&
currentPlaybackState
!
=
PlaybackStats
.
PLAYBACK_STATE_NOT_STARTED
)
{
return
PlaybackStats
.
PLAYBACK_STATE_STOPPED
;
}
return
currentPlaybackState
;
}
private
void
maybeUpdateMaxRebufferTimeMs
(
long
nowMs
)
{
if
(
isRebufferingState
(
currentPlaybackState
)
)
{
long
rebufferDurationMs
=
nowMs
-
lastRebufferStartTimeMs
;
if
(
maxRebufferTimeMs
=
=
C
.
TIME_UNSET
|
|
rebufferDurationMs
>
maxRebufferTimeMs
)
{
maxRebufferTimeMs
=
rebufferDurationMs
;
}
}
}
private
void
maybeUpdateMediaTimeHistory
(
long
realtimeMs
long
mediaTimeMs
)
{
if
(
!
keepHistory
)
{
return
;
}
if
(
currentPlaybackState
!
=
PlaybackStats
.
PLAYBACK_STATE_PLAYING
)
{
if
(
mediaTimeMs
=
=
C
.
TIME_UNSET
)
{
return
;
}
if
(
!
mediaTimeHistory
.
isEmpty
(
)
)
{
long
previousMediaTimeMs
=
mediaTimeHistory
.
get
(
mediaTimeHistory
.
size
(
)
-
1
)
[
1
]
;
if
(
previousMediaTimeMs
!
=
mediaTimeMs
)
{
mediaTimeHistory
.
add
(
new
long
[
]
{
realtimeMs
previousMediaTimeMs
}
)
;
}
}
}
mediaTimeHistory
.
add
(
mediaTimeMs
=
=
C
.
TIME_UNSET
?
guessMediaTimeBasedOnElapsedRealtime
(
realtimeMs
)
:
new
long
[
]
{
realtimeMs
mediaTimeMs
}
)
;
}
private
long
[
]
guessMediaTimeBasedOnElapsedRealtime
(
long
realtimeMs
)
{
long
[
]
previousKnownMediaTimeHistory
=
mediaTimeHistory
.
get
(
mediaTimeHistory
.
size
(
)
-
1
)
;
long
previousRealtimeMs
=
previousKnownMediaTimeHistory
[
0
]
;
long
previousMediaTimeMs
=
previousKnownMediaTimeHistory
[
1
]
;
long
elapsedMediaTimeEstimateMs
=
(
long
)
(
(
realtimeMs
-
previousRealtimeMs
)
*
currentPlaybackSpeed
)
;
long
mediaTimeEstimateMs
=
previousMediaTimeMs
+
elapsedMediaTimeEstimateMs
;
return
new
long
[
]
{
realtimeMs
mediaTimeEstimateMs
}
;
}
private
void
maybeUpdateVideoFormat
(
EventTime
eventTime
Nullable
Format
newFormat
)
{
if
(
Util
.
areEqual
(
currentVideoFormat
newFormat
)
)
{
return
;
}
maybeRecordVideoFormatTime
(
eventTime
.
realtimeMs
)
;
if
(
newFormat
!
=
null
)
{
if
(
initialVideoFormatHeight
=
=
C
.
LENGTH_UNSET
&
&
newFormat
.
height
!
=
Format
.
NO_VALUE
)
{
initialVideoFormatHeight
=
newFormat
.
height
;
}
if
(
initialVideoFormatBitrate
=
=
C
.
LENGTH_UNSET
&
&
newFormat
.
bitrate
!
=
Format
.
NO_VALUE
)
{
initialVideoFormatBitrate
=
newFormat
.
bitrate
;
}
}
currentVideoFormat
=
newFormat
;
if
(
keepHistory
)
{
videoFormatHistory
.
add
(
Pair
.
create
(
eventTime
currentVideoFormat
)
)
;
}
}
private
void
maybeUpdateAudioFormat
(
EventTime
eventTime
Nullable
Format
newFormat
)
{
if
(
Util
.
areEqual
(
currentAudioFormat
newFormat
)
)
{
return
;
}
maybeRecordAudioFormatTime
(
eventTime
.
realtimeMs
)
;
if
(
newFormat
!
=
null
&
&
initialAudioFormatBitrate
=
=
C
.
LENGTH_UNSET
&
&
newFormat
.
bitrate
!
=
Format
.
NO_VALUE
)
{
initialAudioFormatBitrate
=
newFormat
.
bitrate
;
}
currentAudioFormat
=
newFormat
;
if
(
keepHistory
)
{
audioFormatHistory
.
add
(
Pair
.
create
(
eventTime
currentAudioFormat
)
)
;
}
}
private
void
maybeRecordVideoFormatTime
(
long
nowMs
)
{
if
(
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_PLAYING
&
&
currentVideoFormat
!
=
null
)
{
long
mediaDurationMs
=
(
long
)
(
(
nowMs
-
lastVideoFormatStartTimeMs
)
*
currentPlaybackSpeed
)
;
if
(
currentVideoFormat
.
height
!
=
Format
.
NO_VALUE
)
{
videoFormatHeightTimeMs
+
=
mediaDurationMs
;
videoFormatHeightTimeProduct
+
=
mediaDurationMs
*
currentVideoFormat
.
height
;
}
if
(
currentVideoFormat
.
bitrate
!
=
Format
.
NO_VALUE
)
{
videoFormatBitrateTimeMs
+
=
mediaDurationMs
;
videoFormatBitrateTimeProduct
+
=
mediaDurationMs
*
currentVideoFormat
.
bitrate
;
}
}
lastVideoFormatStartTimeMs
=
nowMs
;
}
private
void
maybeRecordAudioFormatTime
(
long
nowMs
)
{
if
(
currentPlaybackState
=
=
PlaybackStats
.
PLAYBACK_STATE_PLAYING
&
&
currentAudioFormat
!
=
null
&
&
currentAudioFormat
.
bitrate
!
=
Format
.
NO_VALUE
)
{
long
mediaDurationMs
=
(
long
)
(
(
nowMs
-
lastAudioFormatStartTimeMs
)
*
currentPlaybackSpeed
)
;
audioFormatTimeMs
+
=
mediaDurationMs
;
audioFormatBitrateTimeProduct
+
=
mediaDurationMs
*
currentAudioFormat
.
bitrate
;
}
lastAudioFormatStartTimeMs
=
nowMs
;
}
private
static
boolean
isReadyState
(
PlaybackState
int
state
)
{
return
state
=
=
PlaybackStats
.
PLAYBACK_STATE_PLAYING
|
|
state
=
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED
|
|
state
=
=
PlaybackStats
.
PLAYBACK_STATE_SUPPRESSED
;
}
private
static
boolean
isPausedState
(
PlaybackState
int
state
)
{
return
state
=
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED
|
|
state
=
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED_BUFFERING
;
}
private
static
boolean
isRebufferingState
(
PlaybackState
int
state
)
{
return
state
=
=
PlaybackStats
.
PLAYBACK_STATE_BUFFERING
|
|
state
=
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED_BUFFERING
|
|
state
=
=
PlaybackStats
.
PLAYBACK_STATE_SUPPRESSED_BUFFERING
;
}
private
static
boolean
isInvalidJoinTransition
(
PlaybackState
int
oldState
PlaybackState
int
newState
)
{
if
(
oldState
!
=
PlaybackStats
.
PLAYBACK_STATE_JOINING_BACKGROUND
&
&
oldState
!
=
PlaybackStats
.
PLAYBACK_STATE_JOINING_FOREGROUND
&
&
oldState
!
=
PlaybackStats
.
PLAYBACK_STATE_INTERRUPTED_BY_AD
)
{
return
false
;
}
return
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_JOINING_BACKGROUND
&
&
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_JOINING_FOREGROUND
&
&
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_INTERRUPTED_BY_AD
&
&
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_PLAYING
&
&
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_PAUSED
&
&
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_SUPPRESSED
&
&
newState
!
=
PlaybackStats
.
PLAYBACK_STATE_ENDED
;
}
}
}
