package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
audio
;
import
android
.
annotation
.
TargetApi
;
import
android
.
media
.
AudioTimestamp
;
import
android
.
media
.
AudioTrack
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
final
class
AudioTimestampPoller
{
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
STATE_INITIALIZING
STATE_TIMESTAMP
STATE_TIMESTAMP_ADVANCING
STATE_NO_TIMESTAMP
STATE_ERROR
}
)
private
interface
State
{
}
private
static
final
int
STATE_INITIALIZING
=
0
;
private
static
final
int
STATE_TIMESTAMP
=
1
;
private
static
final
int
STATE_TIMESTAMP_ADVANCING
=
2
;
private
static
final
int
STATE_NO_TIMESTAMP
=
3
;
private
static
final
int
STATE_ERROR
=
4
;
private
static
final
int
FAST_POLL_INTERVAL_US
=
5_000
;
private
static
final
int
SLOW_POLL_INTERVAL_US
=
10_000_000
;
private
static
final
int
ERROR_POLL_INTERVAL_US
=
500_000
;
private
static
final
int
INITIALIZING_DURATION_US
=
500_000
;
Nullable
private
final
AudioTimestampV19
audioTimestamp
;
private
State
int
state
;
private
long
initializeSystemTimeUs
;
private
long
sampleIntervalUs
;
private
long
lastTimestampSampleTimeUs
;
private
long
initialTimestampPositionFrames
;
public
AudioTimestampPoller
(
AudioTrack
audioTrack
)
{
if
(
Util
.
SDK_INT
>
=
19
)
{
audioTimestamp
=
new
AudioTimestampV19
(
audioTrack
)
;
reset
(
)
;
}
else
{
audioTimestamp
=
null
;
updateState
(
STATE_NO_TIMESTAMP
)
;
}
}
public
boolean
maybePollTimestamp
(
long
systemTimeUs
)
{
if
(
audioTimestamp
=
=
null
|
|
(
systemTimeUs
-
lastTimestampSampleTimeUs
)
<
sampleIntervalUs
)
{
return
false
;
}
lastTimestampSampleTimeUs
=
systemTimeUs
;
boolean
updatedTimestamp
=
audioTimestamp
.
maybeUpdateTimestamp
(
)
;
switch
(
state
)
{
case
STATE_INITIALIZING
:
if
(
updatedTimestamp
)
{
if
(
audioTimestamp
.
getTimestampSystemTimeUs
(
)
>
=
initializeSystemTimeUs
)
{
initialTimestampPositionFrames
=
audioTimestamp
.
getTimestampPositionFrames
(
)
;
updateState
(
STATE_TIMESTAMP
)
;
}
else
{
updatedTimestamp
=
false
;
}
}
else
if
(
systemTimeUs
-
initializeSystemTimeUs
>
INITIALIZING_DURATION_US
)
{
updateState
(
STATE_NO_TIMESTAMP
)
;
}
break
;
case
STATE_TIMESTAMP
:
if
(
updatedTimestamp
)
{
long
timestampPositionFrames
=
audioTimestamp
.
getTimestampPositionFrames
(
)
;
if
(
timestampPositionFrames
>
initialTimestampPositionFrames
)
{
updateState
(
STATE_TIMESTAMP_ADVANCING
)
;
}
}
else
{
reset
(
)
;
}
break
;
case
STATE_TIMESTAMP_ADVANCING
:
if
(
!
updatedTimestamp
)
{
reset
(
)
;
}
break
;
case
STATE_NO_TIMESTAMP
:
if
(
updatedTimestamp
)
{
reset
(
)
;
}
break
;
case
STATE_ERROR
:
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
return
updatedTimestamp
;
}
public
void
rejectTimestamp
(
)
{
updateState
(
STATE_ERROR
)
;
}
public
void
acceptTimestamp
(
)
{
if
(
state
=
=
STATE_ERROR
)
{
reset
(
)
;
}
}
public
boolean
hasTimestamp
(
)
{
return
state
=
=
STATE_TIMESTAMP
|
|
state
=
=
STATE_TIMESTAMP_ADVANCING
;
}
public
boolean
isTimestampAdvancing
(
)
{
return
state
=
=
STATE_TIMESTAMP_ADVANCING
;
}
public
void
reset
(
)
{
if
(
audioTimestamp
!
=
null
)
{
updateState
(
STATE_INITIALIZING
)
;
}
}
public
long
getTimestampSystemTimeUs
(
)
{
return
audioTimestamp
!
=
null
?
audioTimestamp
.
getTimestampSystemTimeUs
(
)
:
C
.
TIME_UNSET
;
}
public
long
getTimestampPositionFrames
(
)
{
return
audioTimestamp
!
=
null
?
audioTimestamp
.
getTimestampPositionFrames
(
)
:
C
.
POSITION_UNSET
;
}
private
void
updateState
(
State
int
state
)
{
this
.
state
=
state
;
switch
(
state
)
{
case
STATE_INITIALIZING
:
lastTimestampSampleTimeUs
=
0
;
initialTimestampPositionFrames
=
C
.
POSITION_UNSET
;
initializeSystemTimeUs
=
System
.
nanoTime
(
)
/
1000
;
sampleIntervalUs
=
FAST_POLL_INTERVAL_US
;
break
;
case
STATE_TIMESTAMP
:
sampleIntervalUs
=
FAST_POLL_INTERVAL_US
;
break
;
case
STATE_TIMESTAMP_ADVANCING
:
case
STATE_NO_TIMESTAMP
:
sampleIntervalUs
=
SLOW_POLL_INTERVAL_US
;
break
;
case
STATE_ERROR
:
sampleIntervalUs
=
ERROR_POLL_INTERVAL_US
;
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
TargetApi
(
19
)
private
static
final
class
AudioTimestampV19
{
private
final
AudioTrack
audioTrack
;
private
final
AudioTimestamp
audioTimestamp
;
private
long
rawTimestampFramePositionWrapCount
;
private
long
lastTimestampRawPositionFrames
;
private
long
lastTimestampPositionFrames
;
public
AudioTimestampV19
(
AudioTrack
audioTrack
)
{
this
.
audioTrack
=
audioTrack
;
audioTimestamp
=
new
AudioTimestamp
(
)
;
}
public
boolean
maybeUpdateTimestamp
(
)
{
boolean
updated
=
audioTrack
.
getTimestamp
(
audioTimestamp
)
;
if
(
updated
)
{
long
rawPositionFrames
=
audioTimestamp
.
framePosition
;
if
(
lastTimestampRawPositionFrames
>
rawPositionFrames
)
{
rawTimestampFramePositionWrapCount
+
+
;
}
lastTimestampRawPositionFrames
=
rawPositionFrames
;
lastTimestampPositionFrames
=
rawPositionFrames
+
(
rawTimestampFramePositionWrapCount
<
<
32
)
;
}
return
updated
;
}
public
long
getTimestampSystemTimeUs
(
)
{
return
audioTimestamp
.
nanoTime
/
1000
;
}
public
long
getTimestampPositionFrames
(
)
{
return
lastTimestampPositionFrames
;
}
}
}
