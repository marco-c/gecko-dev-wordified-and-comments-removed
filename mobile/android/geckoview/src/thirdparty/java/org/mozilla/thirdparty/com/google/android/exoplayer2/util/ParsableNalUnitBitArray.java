package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
;
public
final
class
ParsableNalUnitBitArray
{
private
byte
[
]
data
;
private
int
byteLimit
;
private
int
byteOffset
;
private
int
bitOffset
;
SuppressWarnings
(
{
"
initialization
.
fields
.
uninitialized
"
"
method
.
invocation
.
invalid
"
}
)
public
ParsableNalUnitBitArray
(
byte
[
]
data
int
offset
int
limit
)
{
reset
(
data
offset
limit
)
;
}
public
void
reset
(
byte
[
]
data
int
offset
int
limit
)
{
this
.
data
=
data
;
byteOffset
=
offset
;
byteLimit
=
limit
;
bitOffset
=
0
;
assertValidOffset
(
)
;
}
public
void
skipBit
(
)
{
if
(
+
+
bitOffset
=
=
8
)
{
bitOffset
=
0
;
byteOffset
+
=
shouldSkipByte
(
byteOffset
+
1
)
?
2
:
1
;
}
assertValidOffset
(
)
;
}
public
void
skipBits
(
int
numBits
)
{
int
oldByteOffset
=
byteOffset
;
int
numBytes
=
numBits
/
8
;
byteOffset
+
=
numBytes
;
bitOffset
+
=
numBits
-
(
numBytes
*
8
)
;
if
(
bitOffset
>
7
)
{
byteOffset
+
+
;
bitOffset
-
=
8
;
}
for
(
int
i
=
oldByteOffset
+
1
;
i
<
=
byteOffset
;
i
+
+
)
{
if
(
shouldSkipByte
(
i
)
)
{
byteOffset
+
+
;
i
+
=
2
;
}
}
assertValidOffset
(
)
;
}
public
boolean
canReadBits
(
int
numBits
)
{
int
oldByteOffset
=
byteOffset
;
int
numBytes
=
numBits
/
8
;
int
newByteOffset
=
byteOffset
+
numBytes
;
int
newBitOffset
=
bitOffset
+
numBits
-
(
numBytes
*
8
)
;
if
(
newBitOffset
>
7
)
{
newByteOffset
+
+
;
newBitOffset
-
=
8
;
}
for
(
int
i
=
oldByteOffset
+
1
;
i
<
=
newByteOffset
&
&
newByteOffset
<
byteLimit
;
i
+
+
)
{
if
(
shouldSkipByte
(
i
)
)
{
newByteOffset
+
+
;
i
+
=
2
;
}
}
return
newByteOffset
<
byteLimit
|
|
(
newByteOffset
=
=
byteLimit
&
&
newBitOffset
=
=
0
)
;
}
public
boolean
readBit
(
)
{
boolean
returnValue
=
(
data
[
byteOffset
]
&
(
0x80
>
>
bitOffset
)
)
!
=
0
;
skipBit
(
)
;
return
returnValue
;
}
public
int
readBits
(
int
numBits
)
{
int
returnValue
=
0
;
bitOffset
+
=
numBits
;
while
(
bitOffset
>
8
)
{
bitOffset
-
=
8
;
returnValue
|
=
(
data
[
byteOffset
]
&
0xFF
)
<
<
bitOffset
;
byteOffset
+
=
shouldSkipByte
(
byteOffset
+
1
)
?
2
:
1
;
}
returnValue
|
=
(
data
[
byteOffset
]
&
0xFF
)
>
>
(
8
-
bitOffset
)
;
returnValue
&
=
0xFFFFFFFF
>
>
>
(
32
-
numBits
)
;
if
(
bitOffset
=
=
8
)
{
bitOffset
=
0
;
byteOffset
+
=
shouldSkipByte
(
byteOffset
+
1
)
?
2
:
1
;
}
assertValidOffset
(
)
;
return
returnValue
;
}
public
boolean
canReadExpGolombCodedNum
(
)
{
int
initialByteOffset
=
byteOffset
;
int
initialBitOffset
=
bitOffset
;
int
leadingZeros
=
0
;
while
(
byteOffset
<
byteLimit
&
&
!
readBit
(
)
)
{
leadingZeros
+
+
;
}
boolean
hitLimit
=
byteOffset
=
=
byteLimit
;
byteOffset
=
initialByteOffset
;
bitOffset
=
initialBitOffset
;
return
!
hitLimit
&
&
canReadBits
(
leadingZeros
*
2
+
1
)
;
}
public
int
readUnsignedExpGolombCodedInt
(
)
{
return
readExpGolombCodeNum
(
)
;
}
public
int
readSignedExpGolombCodedInt
(
)
{
int
codeNum
=
readExpGolombCodeNum
(
)
;
return
(
(
codeNum
%
2
)
=
=
0
?
-
1
:
1
)
*
(
(
codeNum
+
1
)
/
2
)
;
}
private
int
readExpGolombCodeNum
(
)
{
int
leadingZeros
=
0
;
while
(
!
readBit
(
)
)
{
leadingZeros
+
+
;
}
return
(
1
<
<
leadingZeros
)
-
1
+
(
leadingZeros
>
0
?
readBits
(
leadingZeros
)
:
0
)
;
}
private
boolean
shouldSkipByte
(
int
offset
)
{
return
2
<
=
offset
&
&
offset
<
byteLimit
&
&
data
[
offset
]
=
=
(
byte
)
0x03
&
&
data
[
offset
-
2
]
=
=
(
byte
)
0x00
&
&
data
[
offset
-
1
]
=
=
(
byte
)
0x00
;
}
private
void
assertValidOffset
(
)
{
Assertions
.
checkState
(
byteOffset
>
=
0
&
&
(
byteOffset
<
byteLimit
|
|
(
byteOffset
=
=
byteLimit
&
&
bitOffset
=
=
0
)
)
)
;
}
}
