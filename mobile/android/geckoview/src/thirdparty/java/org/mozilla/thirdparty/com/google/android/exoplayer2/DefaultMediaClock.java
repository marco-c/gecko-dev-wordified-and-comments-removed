package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Clock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MediaClock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
StandaloneMediaClock
;
final
class
DefaultMediaClock
implements
MediaClock
{
public
interface
PlaybackParameterListener
{
void
onPlaybackParametersChanged
(
PlaybackParameters
newPlaybackParameters
)
;
}
private
final
StandaloneMediaClock
standaloneClock
;
private
final
PlaybackParameterListener
listener
;
Nullable
private
Renderer
rendererClockSource
;
Nullable
private
MediaClock
rendererClock
;
private
boolean
isUsingStandaloneClock
;
private
boolean
standaloneClockIsStarted
;
public
DefaultMediaClock
(
PlaybackParameterListener
listener
Clock
clock
)
{
this
.
listener
=
listener
;
this
.
standaloneClock
=
new
StandaloneMediaClock
(
clock
)
;
isUsingStandaloneClock
=
true
;
}
public
void
start
(
)
{
standaloneClockIsStarted
=
true
;
standaloneClock
.
start
(
)
;
}
public
void
stop
(
)
{
standaloneClockIsStarted
=
false
;
standaloneClock
.
stop
(
)
;
}
public
void
resetPosition
(
long
positionUs
)
{
standaloneClock
.
resetPosition
(
positionUs
)
;
}
public
void
onRendererEnabled
(
Renderer
renderer
)
throws
ExoPlaybackException
{
MediaClock
rendererMediaClock
=
renderer
.
getMediaClock
(
)
;
if
(
rendererMediaClock
!
=
null
&
&
rendererMediaClock
!
=
rendererClock
)
{
if
(
rendererClock
!
=
null
)
{
throw
ExoPlaybackException
.
createForUnexpected
(
new
IllegalStateException
(
"
Multiple
renderer
media
clocks
enabled
.
"
)
)
;
}
this
.
rendererClock
=
rendererMediaClock
;
this
.
rendererClockSource
=
renderer
;
rendererClock
.
setPlaybackParameters
(
standaloneClock
.
getPlaybackParameters
(
)
)
;
}
}
public
void
onRendererDisabled
(
Renderer
renderer
)
{
if
(
renderer
=
=
rendererClockSource
)
{
this
.
rendererClock
=
null
;
this
.
rendererClockSource
=
null
;
isUsingStandaloneClock
=
true
;
}
}
public
long
syncAndGetPositionUs
(
boolean
isReadingAhead
)
{
syncClocks
(
isReadingAhead
)
;
return
getPositionUs
(
)
;
}
Override
public
long
getPositionUs
(
)
{
return
isUsingStandaloneClock
?
standaloneClock
.
getPositionUs
(
)
:
rendererClock
.
getPositionUs
(
)
;
}
Override
public
void
setPlaybackParameters
(
PlaybackParameters
playbackParameters
)
{
if
(
rendererClock
!
=
null
)
{
rendererClock
.
setPlaybackParameters
(
playbackParameters
)
;
playbackParameters
=
rendererClock
.
getPlaybackParameters
(
)
;
}
standaloneClock
.
setPlaybackParameters
(
playbackParameters
)
;
}
Override
public
PlaybackParameters
getPlaybackParameters
(
)
{
return
rendererClock
!
=
null
?
rendererClock
.
getPlaybackParameters
(
)
:
standaloneClock
.
getPlaybackParameters
(
)
;
}
private
void
syncClocks
(
boolean
isReadingAhead
)
{
if
(
shouldUseStandaloneClock
(
isReadingAhead
)
)
{
isUsingStandaloneClock
=
true
;
if
(
standaloneClockIsStarted
)
{
standaloneClock
.
start
(
)
;
}
return
;
}
long
rendererClockPositionUs
=
rendererClock
.
getPositionUs
(
)
;
if
(
isUsingStandaloneClock
)
{
if
(
rendererClockPositionUs
<
standaloneClock
.
getPositionUs
(
)
)
{
standaloneClock
.
stop
(
)
;
return
;
}
isUsingStandaloneClock
=
false
;
if
(
standaloneClockIsStarted
)
{
standaloneClock
.
start
(
)
;
}
}
standaloneClock
.
resetPosition
(
rendererClockPositionUs
)
;
PlaybackParameters
playbackParameters
=
rendererClock
.
getPlaybackParameters
(
)
;
if
(
!
playbackParameters
.
equals
(
standaloneClock
.
getPlaybackParameters
(
)
)
)
{
standaloneClock
.
setPlaybackParameters
(
playbackParameters
)
;
listener
.
onPlaybackParametersChanged
(
playbackParameters
)
;
}
}
private
boolean
shouldUseStandaloneClock
(
boolean
isReadingAhead
)
{
return
rendererClockSource
=
=
null
|
|
rendererClockSource
.
isEnded
(
)
|
|
(
!
rendererClockSource
.
isReady
(
)
&
&
(
isReadingAhead
|
|
rendererClockSource
.
hasReadStreamToEnd
(
)
)
)
;
}
}
