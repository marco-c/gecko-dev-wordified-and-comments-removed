package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
DefaultExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorInput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
public
final
class
SingleSampleMediaChunk
extends
BaseMediaChunk
{
private
final
int
trackType
;
private
final
Format
sampleFormat
;
private
volatile
int
bytesLoaded
;
private
volatile
boolean
loadCanceled
;
private
volatile
boolean
loadCompleted
;
public
SingleSampleMediaChunk
(
DataSource
dataSource
DataSpec
dataSpec
Format
trackFormat
int
trackSelectionReason
Object
trackSelectionData
long
startTimeUs
long
endTimeUs
int
chunkIndex
int
trackType
Format
sampleFormat
)
{
super
(
dataSource
dataSpec
trackFormat
trackSelectionReason
trackSelectionData
startTimeUs
endTimeUs
chunkIndex
)
;
this
.
trackType
=
trackType
;
this
.
sampleFormat
=
sampleFormat
;
}
Override
public
boolean
isLoadCompleted
(
)
{
return
loadCompleted
;
}
Override
public
long
bytesLoaded
(
)
{
return
bytesLoaded
;
}
Override
public
void
cancelLoad
(
)
{
loadCanceled
=
true
;
}
Override
public
boolean
isLoadCanceled
(
)
{
return
loadCanceled
;
}
SuppressWarnings
(
"
NonAtomicVolatileUpdate
"
)
Override
public
void
load
(
)
throws
IOException
InterruptedException
{
DataSpec
loadDataSpec
=
Util
.
getRemainderDataSpec
(
dataSpec
bytesLoaded
)
;
try
{
long
length
=
dataSource
.
open
(
loadDataSpec
)
;
if
(
length
!
=
C
.
LENGTH_UNSET
)
{
length
+
=
bytesLoaded
;
}
ExtractorInput
extractorInput
=
new
DefaultExtractorInput
(
dataSource
bytesLoaded
length
)
;
BaseMediaChunkOutput
output
=
getOutput
(
)
;
output
.
setSampleOffsetUs
(
0
)
;
TrackOutput
trackOutput
=
output
.
track
(
0
trackType
)
;
trackOutput
.
format
(
sampleFormat
)
;
int
result
=
0
;
while
(
result
!
=
C
.
RESULT_END_OF_INPUT
)
{
bytesLoaded
+
=
result
;
result
=
trackOutput
.
sampleData
(
extractorInput
Integer
.
MAX_VALUE
true
)
;
}
int
sampleSize
=
bytesLoaded
;
trackOutput
.
sampleMetadata
(
startTimeUs
C
.
BUFFER_FLAG_KEY_FRAME
sampleSize
0
null
)
;
}
finally
{
Util
.
closeQuietly
(
dataSource
)
;
}
loadCompleted
=
true
;
}
}
