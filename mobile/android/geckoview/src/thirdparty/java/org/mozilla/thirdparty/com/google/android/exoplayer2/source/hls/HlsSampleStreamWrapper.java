package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
;
import
android
.
os
.
Handler
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
DefaultTrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
DefaultTrackOutput
.
UpstreamFormatChangedListener
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekMap
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
AdaptiveMediaSourceEventListener
.
EventDispatcher
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SampleStream
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
SequenceableLoader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroupArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
Chunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMasterPlaylist
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMasterPlaylist
.
HlsUrl
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Loader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
java
.
io
.
IOException
;
import
java
.
util
.
LinkedList
;
final
class
HlsSampleStreamWrapper
implements
Loader
.
Callback
<
Chunk
>
SequenceableLoader
ExtractorOutput
UpstreamFormatChangedListener
{
public
interface
Callback
extends
SequenceableLoader
.
Callback
<
HlsSampleStreamWrapper
>
{
void
onPrepared
(
)
;
void
onPlaylistRefreshRequired
(
HlsMasterPlaylist
.
HlsUrl
playlistUrl
)
;
}
private
static
final
int
PRIMARY_TYPE_NONE
=
0
;
private
static
final
int
PRIMARY_TYPE_TEXT
=
1
;
private
static
final
int
PRIMARY_TYPE_AUDIO
=
2
;
private
static
final
int
PRIMARY_TYPE_VIDEO
=
3
;
private
final
int
trackType
;
private
final
Callback
callback
;
private
final
HlsChunkSource
chunkSource
;
private
final
Allocator
allocator
;
private
final
Format
muxedAudioFormat
;
private
final
int
minLoadableRetryCount
;
private
final
Loader
loader
;
private
final
EventDispatcher
eventDispatcher
;
private
final
HlsChunkSource
.
HlsChunkHolder
nextChunkHolder
;
private
final
SparseArray
<
DefaultTrackOutput
>
sampleQueues
;
private
final
LinkedList
<
HlsMediaChunk
>
mediaChunks
;
private
final
Runnable
maybeFinishPrepareRunnable
;
private
final
Handler
handler
;
private
boolean
sampleQueuesBuilt
;
private
boolean
prepared
;
private
int
enabledTrackCount
;
private
Format
downstreamTrackFormat
;
private
int
upstreamChunkUid
;
private
boolean
released
;
private
TrackGroupArray
trackGroups
;
private
int
primaryTrackGroupIndex
;
private
boolean
[
]
groupEnabledStates
;
private
long
lastSeekPositionUs
;
private
long
pendingResetPositionUs
;
private
boolean
loadingFinished
;
public
HlsSampleStreamWrapper
(
int
trackType
Callback
callback
HlsChunkSource
chunkSource
Allocator
allocator
long
positionUs
Format
muxedAudioFormat
int
minLoadableRetryCount
EventDispatcher
eventDispatcher
)
{
this
.
trackType
=
trackType
;
this
.
callback
=
callback
;
this
.
chunkSource
=
chunkSource
;
this
.
allocator
=
allocator
;
this
.
muxedAudioFormat
=
muxedAudioFormat
;
this
.
minLoadableRetryCount
=
minLoadableRetryCount
;
this
.
eventDispatcher
=
eventDispatcher
;
loader
=
new
Loader
(
"
Loader
:
HlsSampleStreamWrapper
"
)
;
nextChunkHolder
=
new
HlsChunkSource
.
HlsChunkHolder
(
)
;
sampleQueues
=
new
SparseArray
<
>
(
)
;
mediaChunks
=
new
LinkedList
<
>
(
)
;
maybeFinishPrepareRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
maybeFinishPrepare
(
)
;
}
}
;
handler
=
new
Handler
(
)
;
lastSeekPositionUs
=
positionUs
;
pendingResetPositionUs
=
positionUs
;
}
public
void
continuePreparing
(
)
{
if
(
!
prepared
)
{
continueLoading
(
lastSeekPositionUs
)
;
}
}
public
void
prepareSingleTrack
(
Format
format
)
{
track
(
0
C
.
TRACK_TYPE_UNKNOWN
)
.
format
(
format
)
;
sampleQueuesBuilt
=
true
;
maybeFinishPrepare
(
)
;
}
public
void
maybeThrowPrepareError
(
)
throws
IOException
{
maybeThrowError
(
)
;
}
public
TrackGroupArray
getTrackGroups
(
)
{
return
trackGroups
;
}
public
boolean
selectTracks
(
TrackSelection
[
]
selections
boolean
[
]
mayRetainStreamFlags
SampleStream
[
]
streams
boolean
[
]
streamResetFlags
boolean
isFirstTrackSelection
)
{
Assertions
.
checkState
(
prepared
)
;
for
(
int
i
=
0
;
i
<
selections
.
length
;
i
+
+
)
{
if
(
streams
[
i
]
!
=
null
&
&
(
selections
[
i
]
=
=
null
|
|
!
mayRetainStreamFlags
[
i
]
)
)
{
int
group
=
(
(
HlsSampleStream
)
streams
[
i
]
)
.
group
;
setTrackGroupEnabledState
(
group
false
)
;
sampleQueues
.
valueAt
(
group
)
.
disable
(
)
;
streams
[
i
]
=
null
;
}
}
TrackSelection
primaryTrackSelection
=
null
;
boolean
selectedNewTracks
=
false
;
for
(
int
i
=
0
;
i
<
selections
.
length
;
i
+
+
)
{
if
(
streams
[
i
]
=
=
null
&
&
selections
[
i
]
!
=
null
)
{
TrackSelection
selection
=
selections
[
i
]
;
int
group
=
trackGroups
.
indexOf
(
selection
.
getTrackGroup
(
)
)
;
setTrackGroupEnabledState
(
group
true
)
;
if
(
group
=
=
primaryTrackGroupIndex
)
{
primaryTrackSelection
=
selection
;
chunkSource
.
selectTracks
(
selection
)
;
}
streams
[
i
]
=
new
HlsSampleStream
(
this
group
)
;
streamResetFlags
[
i
]
=
true
;
selectedNewTracks
=
true
;
}
}
if
(
isFirstTrackSelection
)
{
int
sampleQueueCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sampleQueueCount
;
i
+
+
)
{
if
(
!
groupEnabledStates
[
i
]
)
{
sampleQueues
.
valueAt
(
i
)
.
disable
(
)
;
}
}
if
(
primaryTrackSelection
!
=
null
&
&
!
mediaChunks
.
isEmpty
(
)
)
{
primaryTrackSelection
.
updateSelectedTrack
(
0
)
;
int
chunkIndex
=
chunkSource
.
getTrackGroup
(
)
.
indexOf
(
mediaChunks
.
getLast
(
)
.
trackFormat
)
;
if
(
primaryTrackSelection
.
getSelectedIndexInTrackGroup
(
)
!
=
chunkIndex
)
{
seekTo
(
lastSeekPositionUs
)
;
}
}
}
if
(
enabledTrackCount
=
=
0
)
{
chunkSource
.
reset
(
)
;
downstreamTrackFormat
=
null
;
mediaChunks
.
clear
(
)
;
if
(
loader
.
isLoading
(
)
)
{
loader
.
cancelLoading
(
)
;
}
}
return
selectedNewTracks
;
}
public
void
seekTo
(
long
positionUs
)
{
lastSeekPositionUs
=
positionUs
;
pendingResetPositionUs
=
positionUs
;
loadingFinished
=
false
;
mediaChunks
.
clear
(
)
;
if
(
loader
.
isLoading
(
)
)
{
loader
.
cancelLoading
(
)
;
}
else
{
int
sampleQueueCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sampleQueueCount
;
i
+
+
)
{
sampleQueues
.
valueAt
(
i
)
.
reset
(
groupEnabledStates
[
i
]
)
;
}
}
}
public
long
getBufferedPositionUs
(
)
{
if
(
loadingFinished
)
{
return
C
.
TIME_END_OF_SOURCE
;
}
else
if
(
isPendingReset
(
)
)
{
return
pendingResetPositionUs
;
}
else
{
long
bufferedPositionUs
=
lastSeekPositionUs
;
HlsMediaChunk
lastMediaChunk
=
mediaChunks
.
getLast
(
)
;
HlsMediaChunk
lastCompletedMediaChunk
=
lastMediaChunk
.
isLoadCompleted
(
)
?
lastMediaChunk
:
mediaChunks
.
size
(
)
>
1
?
mediaChunks
.
get
(
mediaChunks
.
size
(
)
-
2
)
:
null
;
if
(
lastCompletedMediaChunk
!
=
null
)
{
bufferedPositionUs
=
Math
.
max
(
bufferedPositionUs
lastCompletedMediaChunk
.
endTimeUs
)
;
}
int
sampleQueueCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sampleQueueCount
;
i
+
+
)
{
bufferedPositionUs
=
Math
.
max
(
bufferedPositionUs
sampleQueues
.
valueAt
(
i
)
.
getLargestQueuedTimestampUs
(
)
)
;
}
return
bufferedPositionUs
;
}
}
public
void
release
(
)
{
int
sampleQueueCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sampleQueueCount
;
i
+
+
)
{
sampleQueues
.
valueAt
(
i
)
.
disable
(
)
;
}
loader
.
release
(
)
;
handler
.
removeCallbacksAndMessages
(
null
)
;
released
=
true
;
}
public
void
setIsTimestampMaster
(
boolean
isTimestampMaster
)
{
chunkSource
.
setIsTimestampMaster
(
isTimestampMaster
)
;
}
public
void
onPlaylistBlacklisted
(
HlsUrl
url
long
blacklistMs
)
{
chunkSource
.
onPlaylistBlacklisted
(
url
blacklistMs
)
;
}
boolean
isReady
(
int
group
)
{
return
loadingFinished
|
|
(
!
isPendingReset
(
)
&
&
!
sampleQueues
.
valueAt
(
group
)
.
isEmpty
(
)
)
;
}
void
maybeThrowError
(
)
throws
IOException
{
loader
.
maybeThrowError
(
)
;
chunkSource
.
maybeThrowError
(
)
;
}
int
readData
(
int
group
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
requireFormat
)
{
if
(
isPendingReset
(
)
)
{
return
C
.
RESULT_NOTHING_READ
;
}
while
(
mediaChunks
.
size
(
)
>
1
&
&
finishedReadingChunk
(
mediaChunks
.
getFirst
(
)
)
)
{
mediaChunks
.
removeFirst
(
)
;
}
HlsMediaChunk
currentChunk
=
mediaChunks
.
getFirst
(
)
;
Format
trackFormat
=
currentChunk
.
trackFormat
;
if
(
!
trackFormat
.
equals
(
downstreamTrackFormat
)
)
{
eventDispatcher
.
downstreamFormatChanged
(
trackType
trackFormat
currentChunk
.
trackSelectionReason
currentChunk
.
trackSelectionData
currentChunk
.
startTimeUs
)
;
}
downstreamTrackFormat
=
trackFormat
;
return
sampleQueues
.
valueAt
(
group
)
.
readData
(
formatHolder
buffer
requireFormat
loadingFinished
lastSeekPositionUs
)
;
}
void
skipData
(
int
group
long
positionUs
)
{
DefaultTrackOutput
sampleQueue
=
sampleQueues
.
valueAt
(
group
)
;
if
(
loadingFinished
&
&
positionUs
>
sampleQueue
.
getLargestQueuedTimestampUs
(
)
)
{
sampleQueue
.
skipAll
(
)
;
}
else
{
sampleQueue
.
skipToKeyframeBefore
(
positionUs
true
)
;
}
}
private
boolean
finishedReadingChunk
(
HlsMediaChunk
chunk
)
{
int
chunkUid
=
chunk
.
uid
;
for
(
int
i
=
0
;
i
<
sampleQueues
.
size
(
)
;
i
+
+
)
{
if
(
groupEnabledStates
[
i
]
&
&
sampleQueues
.
valueAt
(
i
)
.
peekSourceId
(
)
=
=
chunkUid
)
{
return
false
;
}
}
return
true
;
}
Override
public
boolean
continueLoading
(
long
positionUs
)
{
if
(
loadingFinished
|
|
loader
.
isLoading
(
)
)
{
return
false
;
}
chunkSource
.
getNextChunk
(
mediaChunks
.
isEmpty
(
)
?
null
:
mediaChunks
.
getLast
(
)
pendingResetPositionUs
!
=
C
.
TIME_UNSET
?
pendingResetPositionUs
:
positionUs
nextChunkHolder
)
;
boolean
endOfStream
=
nextChunkHolder
.
endOfStream
;
Chunk
loadable
=
nextChunkHolder
.
chunk
;
HlsMasterPlaylist
.
HlsUrl
playlistToLoad
=
nextChunkHolder
.
playlist
;
nextChunkHolder
.
clear
(
)
;
if
(
endOfStream
)
{
loadingFinished
=
true
;
return
true
;
}
if
(
loadable
=
=
null
)
{
if
(
playlistToLoad
!
=
null
)
{
callback
.
onPlaylistRefreshRequired
(
playlistToLoad
)
;
}
return
false
;
}
if
(
isMediaChunk
(
loadable
)
)
{
pendingResetPositionUs
=
C
.
TIME_UNSET
;
HlsMediaChunk
mediaChunk
=
(
HlsMediaChunk
)
loadable
;
mediaChunk
.
init
(
this
)
;
mediaChunks
.
add
(
mediaChunk
)
;
}
long
elapsedRealtimeMs
=
loader
.
startLoading
(
loadable
this
minLoadableRetryCount
)
;
eventDispatcher
.
loadStarted
(
loadable
.
dataSpec
loadable
.
type
trackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
)
;
return
true
;
}
Override
public
long
getNextLoadPositionUs
(
)
{
if
(
isPendingReset
(
)
)
{
return
pendingResetPositionUs
;
}
else
{
return
loadingFinished
?
C
.
TIME_END_OF_SOURCE
:
mediaChunks
.
getLast
(
)
.
endTimeUs
;
}
}
Override
public
void
onLoadCompleted
(
Chunk
loadable
long
elapsedRealtimeMs
long
loadDurationMs
)
{
chunkSource
.
onChunkLoadCompleted
(
loadable
)
;
eventDispatcher
.
loadCompleted
(
loadable
.
dataSpec
loadable
.
type
trackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
loadDurationMs
loadable
.
bytesLoaded
(
)
)
;
if
(
!
prepared
)
{
continueLoading
(
lastSeekPositionUs
)
;
}
else
{
callback
.
onContinueLoadingRequested
(
this
)
;
}
}
Override
public
void
onLoadCanceled
(
Chunk
loadable
long
elapsedRealtimeMs
long
loadDurationMs
boolean
released
)
{
eventDispatcher
.
loadCanceled
(
loadable
.
dataSpec
loadable
.
type
trackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
loadDurationMs
loadable
.
bytesLoaded
(
)
)
;
if
(
!
released
)
{
int
sampleQueueCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sampleQueueCount
;
i
+
+
)
{
sampleQueues
.
valueAt
(
i
)
.
reset
(
groupEnabledStates
[
i
]
)
;
}
callback
.
onContinueLoadingRequested
(
this
)
;
}
}
Override
public
int
onLoadError
(
Chunk
loadable
long
elapsedRealtimeMs
long
loadDurationMs
IOException
error
)
{
long
bytesLoaded
=
loadable
.
bytesLoaded
(
)
;
boolean
isMediaChunk
=
isMediaChunk
(
loadable
)
;
boolean
cancelable
=
!
isMediaChunk
|
|
bytesLoaded
=
=
0
;
boolean
canceled
=
false
;
if
(
chunkSource
.
onChunkLoadError
(
loadable
cancelable
error
)
)
{
if
(
isMediaChunk
)
{
HlsMediaChunk
removed
=
mediaChunks
.
removeLast
(
)
;
Assertions
.
checkState
(
removed
=
=
loadable
)
;
if
(
mediaChunks
.
isEmpty
(
)
)
{
pendingResetPositionUs
=
lastSeekPositionUs
;
}
}
canceled
=
true
;
}
eventDispatcher
.
loadError
(
loadable
.
dataSpec
loadable
.
type
trackType
loadable
.
trackFormat
loadable
.
trackSelectionReason
loadable
.
trackSelectionData
loadable
.
startTimeUs
loadable
.
endTimeUs
elapsedRealtimeMs
loadDurationMs
loadable
.
bytesLoaded
(
)
error
canceled
)
;
if
(
canceled
)
{
if
(
!
prepared
)
{
continueLoading
(
lastSeekPositionUs
)
;
}
else
{
callback
.
onContinueLoadingRequested
(
this
)
;
}
return
Loader
.
DONT_RETRY
;
}
else
{
return
Loader
.
RETRY
;
}
}
public
void
init
(
int
chunkUid
boolean
shouldSpliceIn
)
{
upstreamChunkUid
=
chunkUid
;
for
(
int
i
=
0
;
i
<
sampleQueues
.
size
(
)
;
i
+
+
)
{
sampleQueues
.
valueAt
(
i
)
.
sourceId
(
chunkUid
)
;
}
if
(
shouldSpliceIn
)
{
for
(
int
i
=
0
;
i
<
sampleQueues
.
size
(
)
;
i
+
+
)
{
sampleQueues
.
valueAt
(
i
)
.
splice
(
)
;
}
}
}
Override
public
DefaultTrackOutput
track
(
int
id
int
type
)
{
if
(
sampleQueues
.
indexOfKey
(
id
)
>
=
0
)
{
return
sampleQueues
.
get
(
id
)
;
}
DefaultTrackOutput
trackOutput
=
new
DefaultTrackOutput
(
allocator
)
;
trackOutput
.
setUpstreamFormatChangeListener
(
this
)
;
trackOutput
.
sourceId
(
upstreamChunkUid
)
;
sampleQueues
.
put
(
id
trackOutput
)
;
return
trackOutput
;
}
Override
public
void
endTracks
(
)
{
sampleQueuesBuilt
=
true
;
handler
.
post
(
maybeFinishPrepareRunnable
)
;
}
Override
public
void
seekMap
(
SeekMap
seekMap
)
{
}
Override
public
void
onUpstreamFormatChanged
(
Format
format
)
{
handler
.
post
(
maybeFinishPrepareRunnable
)
;
}
private
void
maybeFinishPrepare
(
)
{
if
(
released
|
|
prepared
|
|
!
sampleQueuesBuilt
)
{
return
;
}
int
sampleQueueCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sampleQueueCount
;
i
+
+
)
{
if
(
sampleQueues
.
valueAt
(
i
)
.
getUpstreamFormat
(
)
=
=
null
)
{
return
;
}
}
buildTracks
(
)
;
prepared
=
true
;
callback
.
onPrepared
(
)
;
}
private
void
buildTracks
(
)
{
int
primaryExtractorTrackType
=
PRIMARY_TYPE_NONE
;
int
primaryExtractorTrackIndex
=
C
.
INDEX_UNSET
;
int
extractorTrackCount
=
sampleQueues
.
size
(
)
;
for
(
int
i
=
0
;
i
<
extractorTrackCount
;
i
+
+
)
{
String
sampleMimeType
=
sampleQueues
.
valueAt
(
i
)
.
getUpstreamFormat
(
)
.
sampleMimeType
;
int
trackType
;
if
(
MimeTypes
.
isVideo
(
sampleMimeType
)
)
{
trackType
=
PRIMARY_TYPE_VIDEO
;
}
else
if
(
MimeTypes
.
isAudio
(
sampleMimeType
)
)
{
trackType
=
PRIMARY_TYPE_AUDIO
;
}
else
if
(
MimeTypes
.
isText
(
sampleMimeType
)
)
{
trackType
=
PRIMARY_TYPE_TEXT
;
}
else
{
trackType
=
PRIMARY_TYPE_NONE
;
}
if
(
trackType
>
primaryExtractorTrackType
)
{
primaryExtractorTrackType
=
trackType
;
primaryExtractorTrackIndex
=
i
;
}
else
if
(
trackType
=
=
primaryExtractorTrackType
&
&
primaryExtractorTrackIndex
!
=
C
.
INDEX_UNSET
)
{
primaryExtractorTrackIndex
=
C
.
INDEX_UNSET
;
}
}
TrackGroup
chunkSourceTrackGroup
=
chunkSource
.
getTrackGroup
(
)
;
int
chunkSourceTrackCount
=
chunkSourceTrackGroup
.
length
;
primaryTrackGroupIndex
=
C
.
INDEX_UNSET
;
groupEnabledStates
=
new
boolean
[
extractorTrackCount
]
;
TrackGroup
[
]
trackGroups
=
new
TrackGroup
[
extractorTrackCount
]
;
for
(
int
i
=
0
;
i
<
extractorTrackCount
;
i
+
+
)
{
Format
sampleFormat
=
sampleQueues
.
valueAt
(
i
)
.
getUpstreamFormat
(
)
;
if
(
i
=
=
primaryExtractorTrackIndex
)
{
Format
[
]
formats
=
new
Format
[
chunkSourceTrackCount
]
;
for
(
int
j
=
0
;
j
<
chunkSourceTrackCount
;
j
+
+
)
{
formats
[
j
]
=
deriveFormat
(
chunkSourceTrackGroup
.
getFormat
(
j
)
sampleFormat
)
;
}
trackGroups
[
i
]
=
new
TrackGroup
(
formats
)
;
primaryTrackGroupIndex
=
i
;
}
else
{
Format
trackFormat
=
primaryExtractorTrackType
=
=
PRIMARY_TYPE_VIDEO
&
&
MimeTypes
.
isAudio
(
sampleFormat
.
sampleMimeType
)
?
muxedAudioFormat
:
null
;
trackGroups
[
i
]
=
new
TrackGroup
(
deriveFormat
(
trackFormat
sampleFormat
)
)
;
}
}
this
.
trackGroups
=
new
TrackGroupArray
(
trackGroups
)
;
}
private
void
setTrackGroupEnabledState
(
int
group
boolean
enabledState
)
{
Assertions
.
checkState
(
groupEnabledStates
[
group
]
!
=
enabledState
)
;
groupEnabledStates
[
group
]
=
enabledState
;
enabledTrackCount
=
enabledTrackCount
+
(
enabledState
?
1
:
-
1
)
;
}
private
static
Format
deriveFormat
(
Format
containerFormat
Format
sampleFormat
)
{
if
(
containerFormat
=
=
null
)
{
return
sampleFormat
;
}
String
codecs
=
null
;
int
sampleTrackType
=
MimeTypes
.
getTrackType
(
sampleFormat
.
sampleMimeType
)
;
if
(
sampleTrackType
=
=
C
.
TRACK_TYPE_AUDIO
)
{
codecs
=
getAudioCodecs
(
containerFormat
.
codecs
)
;
}
else
if
(
sampleTrackType
=
=
C
.
TRACK_TYPE_VIDEO
)
{
codecs
=
getVideoCodecs
(
containerFormat
.
codecs
)
;
}
return
sampleFormat
.
copyWithContainerInfo
(
containerFormat
.
id
codecs
containerFormat
.
bitrate
containerFormat
.
width
containerFormat
.
height
containerFormat
.
selectionFlags
containerFormat
.
language
)
;
}
private
boolean
isMediaChunk
(
Chunk
chunk
)
{
return
chunk
instanceof
HlsMediaChunk
;
}
private
boolean
isPendingReset
(
)
{
return
pendingResetPositionUs
!
=
C
.
TIME_UNSET
;
}
private
static
String
getAudioCodecs
(
String
codecs
)
{
return
getCodecsOfType
(
codecs
C
.
TRACK_TYPE_AUDIO
)
;
}
private
static
String
getVideoCodecs
(
String
codecs
)
{
return
getCodecsOfType
(
codecs
C
.
TRACK_TYPE_VIDEO
)
;
}
private
static
String
getCodecsOfType
(
String
codecs
int
trackType
)
{
if
(
TextUtils
.
isEmpty
(
codecs
)
)
{
return
null
;
}
String
[
]
codecArray
=
codecs
.
split
(
"
(
\
\
s
*
\
\
s
*
)
|
(
\
\
s
*
)
"
)
;
StringBuilder
builder
=
new
StringBuilder
(
)
;
for
(
String
codec
:
codecArray
)
{
if
(
trackType
=
=
MimeTypes
.
getTrackTypeOfCodec
(
codec
)
)
{
if
(
builder
.
length
(
)
>
0
)
{
builder
.
append
(
"
"
)
;
}
builder
.
append
(
codec
)
;
}
}
return
builder
.
length
(
)
>
0
?
builder
.
toString
(
)
:
null
;
}
}
