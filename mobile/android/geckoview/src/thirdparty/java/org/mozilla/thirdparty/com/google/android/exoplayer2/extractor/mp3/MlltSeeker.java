package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
;
import
android
.
util
.
Pair
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekPoint
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
metadata
.
id3
.
MlltFrame
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
final
class
MlltSeeker
implements
Seeker
{
public
static
MlltSeeker
create
(
long
firstFramePosition
MlltFrame
mlltFrame
)
{
int
referenceCount
=
mlltFrame
.
bytesDeviations
.
length
;
long
[
]
referencePositions
=
new
long
[
1
+
referenceCount
]
;
long
[
]
referenceTimesMs
=
new
long
[
1
+
referenceCount
]
;
referencePositions
[
0
]
=
firstFramePosition
;
referenceTimesMs
[
0
]
=
0
;
long
position
=
firstFramePosition
;
long
timeMs
=
0
;
for
(
int
i
=
1
;
i
<
=
referenceCount
;
i
+
+
)
{
position
+
=
mlltFrame
.
bytesBetweenReference
+
mlltFrame
.
bytesDeviations
[
i
-
1
]
;
timeMs
+
=
mlltFrame
.
millisecondsBetweenReference
+
mlltFrame
.
millisecondsDeviations
[
i
-
1
]
;
referencePositions
[
i
]
=
position
;
referenceTimesMs
[
i
]
=
timeMs
;
}
return
new
MlltSeeker
(
referencePositions
referenceTimesMs
)
;
}
private
final
long
[
]
referencePositions
;
private
final
long
[
]
referenceTimesMs
;
private
final
long
durationUs
;
private
MlltSeeker
(
long
[
]
referencePositions
long
[
]
referenceTimesMs
)
{
this
.
referencePositions
=
referencePositions
;
this
.
referenceTimesMs
=
referenceTimesMs
;
durationUs
=
C
.
msToUs
(
referenceTimesMs
[
referenceTimesMs
.
length
-
1
]
)
;
}
Override
public
boolean
isSeekable
(
)
{
return
true
;
}
Override
public
SeekPoints
getSeekPoints
(
long
timeUs
)
{
timeUs
=
Util
.
constrainValue
(
timeUs
0
durationUs
)
;
Pair
<
Long
Long
>
timeMsAndPosition
=
linearlyInterpolate
(
C
.
usToMs
(
timeUs
)
referenceTimesMs
referencePositions
)
;
timeUs
=
C
.
msToUs
(
timeMsAndPosition
.
first
)
;
long
position
=
timeMsAndPosition
.
second
;
return
new
SeekPoints
(
new
SeekPoint
(
timeUs
position
)
)
;
}
Override
public
long
getTimeUs
(
long
position
)
{
Pair
<
Long
Long
>
positionAndTimeMs
=
linearlyInterpolate
(
position
referencePositions
referenceTimesMs
)
;
return
C
.
msToUs
(
positionAndTimeMs
.
second
)
;
}
Override
public
long
getDurationUs
(
)
{
return
durationUs
;
}
private
static
Pair
<
Long
Long
>
linearlyInterpolate
(
long
x
long
[
]
xReferences
long
[
]
yReferences
)
{
int
previousReferenceIndex
=
Util
.
binarySearchFloor
(
xReferences
x
true
true
)
;
long
xPreviousReference
=
xReferences
[
previousReferenceIndex
]
;
long
yPreviousReference
=
yReferences
[
previousReferenceIndex
]
;
int
nextReferenceIndex
=
previousReferenceIndex
+
1
;
if
(
nextReferenceIndex
=
=
xReferences
.
length
)
{
return
Pair
.
create
(
xPreviousReference
yPreviousReference
)
;
}
else
{
long
xNextReference
=
xReferences
[
nextReferenceIndex
]
;
long
yNextReference
=
yReferences
[
nextReferenceIndex
]
;
double
proportion
=
xNextReference
=
=
xPreviousReference
?
0
.
0
:
(
(
double
)
x
-
xPreviousReference
)
/
(
xNextReference
-
xPreviousReference
)
;
long
y
=
(
long
)
(
proportion
*
(
yNextReference
-
yPreviousReference
)
)
+
yPreviousReference
;
return
Pair
.
create
(
x
y
)
;
}
}
Override
public
long
getDataEndPosition
(
)
{
return
C
.
POSITION_UNSET
;
}
}
