package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
;
import
android
.
util
.
Pair
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Renderer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
.
AdaptiveSupport
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
.
Capabilities
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
.
FormatSupport
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererConfiguration
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Timeline
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
MediaSource
.
MediaPeriodId
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroupArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
import
java
.
util
.
Arrays
;
import
org
.
checkerframework
.
checker
.
nullness
.
compatqual
.
NullableType
;
public
abstract
class
MappingTrackSelector
extends
TrackSelector
{
public
static
final
class
MappedTrackInfo
{
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
RENDERER_SUPPORT_NO_TRACKS
RENDERER_SUPPORT_UNSUPPORTED_TRACKS
RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS
RENDERER_SUPPORT_PLAYABLE_TRACKS
}
)
interface
RendererSupport
{
}
public
static
final
int
RENDERER_SUPPORT_NO_TRACKS
=
0
;
public
static
final
int
RENDERER_SUPPORT_UNSUPPORTED_TRACKS
=
1
;
public
static
final
int
RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS
=
2
;
public
static
final
int
RENDERER_SUPPORT_PLAYABLE_TRACKS
=
3
;
Deprecated
public
final
int
length
;
private
final
int
rendererCount
;
private
final
int
[
]
rendererTrackTypes
;
private
final
TrackGroupArray
[
]
rendererTrackGroups
;
AdaptiveSupport
private
final
int
[
]
rendererMixedMimeTypeAdaptiveSupports
;
Capabilities
private
final
int
[
]
[
]
[
]
rendererFormatSupports
;
private
final
TrackGroupArray
unmappedTrackGroups
;
SuppressWarnings
(
"
deprecation
"
)
MappedTrackInfo
(
int
[
]
rendererTrackTypes
TrackGroupArray
[
]
rendererTrackGroups
AdaptiveSupport
int
[
]
rendererMixedMimeTypeAdaptiveSupports
Capabilities
int
[
]
[
]
[
]
rendererFormatSupports
TrackGroupArray
unmappedTrackGroups
)
{
this
.
rendererTrackTypes
=
rendererTrackTypes
;
this
.
rendererTrackGroups
=
rendererTrackGroups
;
this
.
rendererFormatSupports
=
rendererFormatSupports
;
this
.
rendererMixedMimeTypeAdaptiveSupports
=
rendererMixedMimeTypeAdaptiveSupports
;
this
.
unmappedTrackGroups
=
unmappedTrackGroups
;
this
.
rendererCount
=
rendererTrackTypes
.
length
;
this
.
length
=
rendererCount
;
}
public
int
getRendererCount
(
)
{
return
rendererCount
;
}
public
int
getRendererType
(
int
rendererIndex
)
{
return
rendererTrackTypes
[
rendererIndex
]
;
}
public
TrackGroupArray
getTrackGroups
(
int
rendererIndex
)
{
return
rendererTrackGroups
[
rendererIndex
]
;
}
RendererSupport
public
int
getRendererSupport
(
int
rendererIndex
)
{
RendererSupport
int
bestRendererSupport
=
RENDERER_SUPPORT_NO_TRACKS
;
Capabilities
int
[
]
[
]
rendererFormatSupport
=
rendererFormatSupports
[
rendererIndex
]
;
for
(
Capabilities
int
[
]
trackGroupFormatSupport
:
rendererFormatSupport
)
{
for
(
Capabilities
int
trackFormatSupport
:
trackGroupFormatSupport
)
{
int
trackRendererSupport
;
switch
(
RendererCapabilities
.
getFormatSupport
(
trackFormatSupport
)
)
{
case
RendererCapabilities
.
FORMAT_HANDLED
:
return
RENDERER_SUPPORT_PLAYABLE_TRACKS
;
case
RendererCapabilities
.
FORMAT_EXCEEDS_CAPABILITIES
:
trackRendererSupport
=
RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS
;
break
;
case
RendererCapabilities
.
FORMAT_UNSUPPORTED_TYPE
:
case
RendererCapabilities
.
FORMAT_UNSUPPORTED_SUBTYPE
:
case
RendererCapabilities
.
FORMAT_UNSUPPORTED_DRM
:
trackRendererSupport
=
RENDERER_SUPPORT_UNSUPPORTED_TRACKS
;
break
;
default
:
throw
new
IllegalStateException
(
)
;
}
bestRendererSupport
=
Math
.
max
(
bestRendererSupport
trackRendererSupport
)
;
}
}
return
bestRendererSupport
;
}
Deprecated
RendererSupport
public
int
getTrackTypeRendererSupport
(
int
trackType
)
{
return
getTypeSupport
(
trackType
)
;
}
RendererSupport
public
int
getTypeSupport
(
int
trackType
)
{
RendererSupport
int
bestRendererSupport
=
RENDERER_SUPPORT_NO_TRACKS
;
for
(
int
i
=
0
;
i
<
rendererCount
;
i
+
+
)
{
if
(
rendererTrackTypes
[
i
]
=
=
trackType
)
{
bestRendererSupport
=
Math
.
max
(
bestRendererSupport
getRendererSupport
(
i
)
)
;
}
}
return
bestRendererSupport
;
}
Deprecated
FormatSupport
public
int
getTrackFormatSupport
(
int
rendererIndex
int
groupIndex
int
trackIndex
)
{
return
getTrackSupport
(
rendererIndex
groupIndex
trackIndex
)
;
}
FormatSupport
public
int
getTrackSupport
(
int
rendererIndex
int
groupIndex
int
trackIndex
)
{
return
RendererCapabilities
.
getFormatSupport
(
rendererFormatSupports
[
rendererIndex
]
[
groupIndex
]
[
trackIndex
]
)
;
}
AdaptiveSupport
public
int
getAdaptiveSupport
(
int
rendererIndex
int
groupIndex
boolean
includeCapabilitiesExceededTracks
)
{
int
trackCount
=
rendererTrackGroups
[
rendererIndex
]
.
get
(
groupIndex
)
.
length
;
int
[
]
trackIndices
=
new
int
[
trackCount
]
;
int
trackIndexCount
=
0
;
for
(
int
i
=
0
;
i
<
trackCount
;
i
+
+
)
{
FormatSupport
int
fixedSupport
=
getTrackSupport
(
rendererIndex
groupIndex
i
)
;
if
(
fixedSupport
=
=
RendererCapabilities
.
FORMAT_HANDLED
|
|
(
includeCapabilitiesExceededTracks
&
&
fixedSupport
=
=
RendererCapabilities
.
FORMAT_EXCEEDS_CAPABILITIES
)
)
{
trackIndices
[
trackIndexCount
+
+
]
=
i
;
}
}
trackIndices
=
Arrays
.
copyOf
(
trackIndices
trackIndexCount
)
;
return
getAdaptiveSupport
(
rendererIndex
groupIndex
trackIndices
)
;
}
AdaptiveSupport
public
int
getAdaptiveSupport
(
int
rendererIndex
int
groupIndex
int
[
]
trackIndices
)
{
int
handledTrackCount
=
0
;
AdaptiveSupport
int
adaptiveSupport
=
RendererCapabilities
.
ADAPTIVE_SEAMLESS
;
boolean
multipleMimeTypes
=
false
;
String
firstSampleMimeType
=
null
;
for
(
int
i
=
0
;
i
<
trackIndices
.
length
;
i
+
+
)
{
int
trackIndex
=
trackIndices
[
i
]
;
String
sampleMimeType
=
rendererTrackGroups
[
rendererIndex
]
.
get
(
groupIndex
)
.
getFormat
(
trackIndex
)
.
sampleMimeType
;
if
(
handledTrackCount
+
+
=
=
0
)
{
firstSampleMimeType
=
sampleMimeType
;
}
else
{
multipleMimeTypes
|
=
!
Util
.
areEqual
(
firstSampleMimeType
sampleMimeType
)
;
}
adaptiveSupport
=
Math
.
min
(
adaptiveSupport
RendererCapabilities
.
getAdaptiveSupport
(
rendererFormatSupports
[
rendererIndex
]
[
groupIndex
]
[
i
]
)
)
;
}
return
multipleMimeTypes
?
Math
.
min
(
adaptiveSupport
rendererMixedMimeTypeAdaptiveSupports
[
rendererIndex
]
)
:
adaptiveSupport
;
}
Deprecated
public
TrackGroupArray
getUnassociatedTrackGroups
(
)
{
return
getUnmappedTrackGroups
(
)
;
}
public
TrackGroupArray
getUnmappedTrackGroups
(
)
{
return
unmappedTrackGroups
;
}
}
Nullable
private
MappedTrackInfo
currentMappedTrackInfo
;
public
final
Nullable
MappedTrackInfo
getCurrentMappedTrackInfo
(
)
{
return
currentMappedTrackInfo
;
}
Override
public
final
void
onSelectionActivated
(
Object
info
)
{
currentMappedTrackInfo
=
(
MappedTrackInfo
)
info
;
}
Override
public
final
TrackSelectorResult
selectTracks
(
RendererCapabilities
[
]
rendererCapabilities
TrackGroupArray
trackGroups
MediaPeriodId
periodId
Timeline
timeline
)
throws
ExoPlaybackException
{
int
[
]
rendererTrackGroupCounts
=
new
int
[
rendererCapabilities
.
length
+
1
]
;
TrackGroup
[
]
[
]
rendererTrackGroups
=
new
TrackGroup
[
rendererCapabilities
.
length
+
1
]
[
]
;
Capabilities
int
[
]
[
]
[
]
rendererFormatSupports
=
new
int
[
rendererCapabilities
.
length
+
1
]
[
]
[
]
;
for
(
int
i
=
0
;
i
<
rendererTrackGroups
.
length
;
i
+
+
)
{
rendererTrackGroups
[
i
]
=
new
TrackGroup
[
trackGroups
.
length
]
;
rendererFormatSupports
[
i
]
=
new
int
[
trackGroups
.
length
]
[
]
;
}
AdaptiveSupport
int
[
]
rendererMixedMimeTypeAdaptationSupports
=
getMixedMimeTypeAdaptationSupports
(
rendererCapabilities
)
;
for
(
int
groupIndex
=
0
;
groupIndex
<
trackGroups
.
length
;
groupIndex
+
+
)
{
TrackGroup
group
=
trackGroups
.
get
(
groupIndex
)
;
boolean
preferUnassociatedRenderer
=
MimeTypes
.
getTrackType
(
group
.
getFormat
(
0
)
.
sampleMimeType
)
=
=
C
.
TRACK_TYPE_METADATA
;
int
rendererIndex
=
findRenderer
(
rendererCapabilities
group
rendererTrackGroupCounts
preferUnassociatedRenderer
)
;
Capabilities
int
[
]
rendererFormatSupport
=
rendererIndex
=
=
rendererCapabilities
.
length
?
new
int
[
group
.
length
]
:
getFormatSupport
(
rendererCapabilities
[
rendererIndex
]
group
)
;
int
rendererTrackGroupCount
=
rendererTrackGroupCounts
[
rendererIndex
]
;
rendererTrackGroups
[
rendererIndex
]
[
rendererTrackGroupCount
]
=
group
;
rendererFormatSupports
[
rendererIndex
]
[
rendererTrackGroupCount
]
=
rendererFormatSupport
;
rendererTrackGroupCounts
[
rendererIndex
]
+
+
;
}
TrackGroupArray
[
]
rendererTrackGroupArrays
=
new
TrackGroupArray
[
rendererCapabilities
.
length
]
;
int
[
]
rendererTrackTypes
=
new
int
[
rendererCapabilities
.
length
]
;
for
(
int
i
=
0
;
i
<
rendererCapabilities
.
length
;
i
+
+
)
{
int
rendererTrackGroupCount
=
rendererTrackGroupCounts
[
i
]
;
rendererTrackGroupArrays
[
i
]
=
new
TrackGroupArray
(
Util
.
nullSafeArrayCopy
(
rendererTrackGroups
[
i
]
rendererTrackGroupCount
)
)
;
rendererFormatSupports
[
i
]
=
Util
.
nullSafeArrayCopy
(
rendererFormatSupports
[
i
]
rendererTrackGroupCount
)
;
rendererTrackTypes
[
i
]
=
rendererCapabilities
[
i
]
.
getTrackType
(
)
;
}
int
unmappedTrackGroupCount
=
rendererTrackGroupCounts
[
rendererCapabilities
.
length
]
;
TrackGroupArray
unmappedTrackGroupArray
=
new
TrackGroupArray
(
Util
.
nullSafeArrayCopy
(
rendererTrackGroups
[
rendererCapabilities
.
length
]
unmappedTrackGroupCount
)
)
;
MappedTrackInfo
mappedTrackInfo
=
new
MappedTrackInfo
(
rendererTrackTypes
rendererTrackGroupArrays
rendererMixedMimeTypeAdaptationSupports
rendererFormatSupports
unmappedTrackGroupArray
)
;
Pair
<
NullableType
RendererConfiguration
[
]
NullableType
TrackSelection
[
]
>
result
=
selectTracks
(
mappedTrackInfo
rendererFormatSupports
rendererMixedMimeTypeAdaptationSupports
)
;
return
new
TrackSelectorResult
(
result
.
first
result
.
second
mappedTrackInfo
)
;
}
protected
abstract
Pair
<
NullableType
RendererConfiguration
[
]
NullableType
TrackSelection
[
]
>
selectTracks
(
MappedTrackInfo
mappedTrackInfo
Capabilities
int
[
]
[
]
[
]
rendererFormatSupports
AdaptiveSupport
int
[
]
rendererMixedMimeTypeAdaptationSupport
)
throws
ExoPlaybackException
;
private
static
int
findRenderer
(
RendererCapabilities
[
]
rendererCapabilities
TrackGroup
group
int
[
]
rendererTrackGroupCounts
boolean
preferUnassociatedRenderer
)
throws
ExoPlaybackException
{
int
bestRendererIndex
=
rendererCapabilities
.
length
;
FormatSupport
int
bestFormatSupportLevel
=
RendererCapabilities
.
FORMAT_UNSUPPORTED_TYPE
;
boolean
bestRendererIsUnassociated
=
true
;
for
(
int
rendererIndex
=
0
;
rendererIndex
<
rendererCapabilities
.
length
;
rendererIndex
+
+
)
{
RendererCapabilities
rendererCapability
=
rendererCapabilities
[
rendererIndex
]
;
FormatSupport
int
formatSupportLevel
=
RendererCapabilities
.
FORMAT_UNSUPPORTED_TYPE
;
for
(
int
trackIndex
=
0
;
trackIndex
<
group
.
length
;
trackIndex
+
+
)
{
FormatSupport
int
trackFormatSupportLevel
=
RendererCapabilities
.
getFormatSupport
(
rendererCapability
.
supportsFormat
(
group
.
getFormat
(
trackIndex
)
)
)
;
formatSupportLevel
=
Math
.
max
(
formatSupportLevel
trackFormatSupportLevel
)
;
}
boolean
rendererIsUnassociated
=
rendererTrackGroupCounts
[
rendererIndex
]
=
=
0
;
if
(
formatSupportLevel
>
bestFormatSupportLevel
|
|
(
formatSupportLevel
=
=
bestFormatSupportLevel
&
&
preferUnassociatedRenderer
&
&
!
bestRendererIsUnassociated
&
&
rendererIsUnassociated
)
)
{
bestRendererIndex
=
rendererIndex
;
bestFormatSupportLevel
=
formatSupportLevel
;
bestRendererIsUnassociated
=
rendererIsUnassociated
;
}
}
return
bestRendererIndex
;
}
Capabilities
private
static
int
[
]
getFormatSupport
(
RendererCapabilities
rendererCapabilities
TrackGroup
group
)
throws
ExoPlaybackException
{
Capabilities
int
[
]
formatSupport
=
new
int
[
group
.
length
]
;
for
(
int
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
formatSupport
[
i
]
=
rendererCapabilities
.
supportsFormat
(
group
.
getFormat
(
i
)
)
;
}
return
formatSupport
;
}
AdaptiveSupport
private
static
int
[
]
getMixedMimeTypeAdaptationSupports
(
RendererCapabilities
[
]
rendererCapabilities
)
throws
ExoPlaybackException
{
AdaptiveSupport
int
[
]
mixedMimeTypeAdaptationSupport
=
new
int
[
rendererCapabilities
.
length
]
;
for
(
int
i
=
0
;
i
<
mixedMimeTypeAdaptationSupport
.
length
;
i
+
+
)
{
mixedMimeTypeAdaptationSupport
[
i
]
=
rendererCapabilities
[
i
]
.
supportsMixedMimeTypeAdaptation
(
)
;
}
return
mixedMimeTypeAdaptationSupport
;
}
}
