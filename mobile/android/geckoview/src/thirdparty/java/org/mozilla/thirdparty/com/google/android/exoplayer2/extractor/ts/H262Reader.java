package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
android
.
util
.
Pair
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
TrackIdGenerator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
NalUnitUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
public
final
class
H262Reader
implements
ElementaryStreamReader
{
private
static
final
int
START_PICTURE
=
0x00
;
private
static
final
int
START_SEQUENCE_HEADER
=
0xB3
;
private
static
final
int
START_EXTENSION
=
0xB5
;
private
static
final
int
START_GROUP
=
0xB8
;
private
String
formatId
;
private
TrackOutput
output
;
private
static
final
double
[
]
FRAME_RATE_VALUES
=
new
double
[
]
{
24000d
/
1001
24
25
30000d
/
1001
30
50
60000d
/
1001
60
}
;
private
boolean
hasOutputFormat
;
private
long
frameDurationUs
;
private
final
boolean
[
]
prefixFlags
;
private
final
CsdBuffer
csdBuffer
;
private
boolean
foundFirstFrameInGroup
;
private
long
totalBytesWritten
;
private
long
pesTimeUs
;
private
boolean
pesPtsUsAvailable
;
private
boolean
isKeyframe
;
private
long
framePosition
;
private
long
frameTimeUs
;
public
H262Reader
(
)
{
prefixFlags
=
new
boolean
[
4
]
;
csdBuffer
=
new
CsdBuffer
(
128
)
;
}
Override
public
void
seek
(
)
{
NalUnitUtil
.
clearPrefixFlags
(
prefixFlags
)
;
csdBuffer
.
reset
(
)
;
pesPtsUsAvailable
=
false
;
foundFirstFrameInGroup
=
false
;
totalBytesWritten
=
0
;
}
Override
public
void
createTracks
(
ExtractorOutput
extractorOutput
TrackIdGenerator
idGenerator
)
{
idGenerator
.
generateNewId
(
)
;
formatId
=
idGenerator
.
getFormatId
(
)
;
output
=
extractorOutput
.
track
(
idGenerator
.
getTrackId
(
)
C
.
TRACK_TYPE_VIDEO
)
;
}
Override
public
void
packetStarted
(
long
pesTimeUs
boolean
dataAlignmentIndicator
)
{
pesPtsUsAvailable
=
pesTimeUs
!
=
C
.
TIME_UNSET
;
if
(
pesPtsUsAvailable
)
{
this
.
pesTimeUs
=
pesTimeUs
;
}
}
Override
public
void
consume
(
ParsableByteArray
data
)
{
int
offset
=
data
.
getPosition
(
)
;
int
limit
=
data
.
limit
(
)
;
byte
[
]
dataArray
=
data
.
data
;
totalBytesWritten
+
=
data
.
bytesLeft
(
)
;
output
.
sampleData
(
data
data
.
bytesLeft
(
)
)
;
int
searchOffset
=
offset
;
while
(
true
)
{
int
startCodeOffset
=
NalUnitUtil
.
findNalUnit
(
dataArray
searchOffset
limit
prefixFlags
)
;
if
(
startCodeOffset
=
=
limit
)
{
if
(
!
hasOutputFormat
)
{
csdBuffer
.
onData
(
dataArray
offset
limit
)
;
}
return
;
}
int
startCodeValue
=
data
.
data
[
startCodeOffset
+
3
]
&
0xFF
;
if
(
!
hasOutputFormat
)
{
int
lengthToStartCode
=
startCodeOffset
-
offset
;
if
(
lengthToStartCode
>
0
)
{
csdBuffer
.
onData
(
dataArray
offset
startCodeOffset
)
;
}
int
bytesAlreadyPassed
=
lengthToStartCode
<
0
?
-
lengthToStartCode
:
0
;
if
(
csdBuffer
.
onStartCode
(
startCodeValue
bytesAlreadyPassed
)
)
{
Pair
<
Format
Long
>
result
=
parseCsdBuffer
(
csdBuffer
formatId
)
;
output
.
format
(
result
.
first
)
;
frameDurationUs
=
result
.
second
;
hasOutputFormat
=
true
;
}
}
if
(
hasOutputFormat
&
&
(
startCodeValue
=
=
START_GROUP
|
|
startCodeValue
=
=
START_PICTURE
)
)
{
int
bytesWrittenPastStartCode
=
limit
-
startCodeOffset
;
if
(
foundFirstFrameInGroup
)
{
C
.
BufferFlags
int
flags
=
isKeyframe
?
C
.
BUFFER_FLAG_KEY_FRAME
:
0
;
int
size
=
(
int
)
(
totalBytesWritten
-
framePosition
)
-
bytesWrittenPastStartCode
;
output
.
sampleMetadata
(
frameTimeUs
flags
size
bytesWrittenPastStartCode
null
)
;
isKeyframe
=
false
;
}
if
(
startCodeValue
=
=
START_GROUP
)
{
foundFirstFrameInGroup
=
false
;
isKeyframe
=
true
;
}
else
{
frameTimeUs
=
pesPtsUsAvailable
?
pesTimeUs
:
(
frameTimeUs
+
frameDurationUs
)
;
framePosition
=
totalBytesWritten
-
bytesWrittenPastStartCode
;
pesPtsUsAvailable
=
false
;
foundFirstFrameInGroup
=
true
;
}
}
offset
=
startCodeOffset
;
searchOffset
=
offset
+
3
;
}
}
Override
public
void
packetFinished
(
)
{
}
private
static
Pair
<
Format
Long
>
parseCsdBuffer
(
CsdBuffer
csdBuffer
String
formatId
)
{
byte
[
]
csdData
=
Arrays
.
copyOf
(
csdBuffer
.
data
csdBuffer
.
length
)
;
int
firstByte
=
csdData
[
4
]
&
0xFF
;
int
secondByte
=
csdData
[
5
]
&
0xFF
;
int
thirdByte
=
csdData
[
6
]
&
0xFF
;
int
width
=
(
firstByte
<
<
4
)
|
(
secondByte
>
>
4
)
;
int
height
=
(
secondByte
&
0x0F
)
<
<
8
|
thirdByte
;
float
pixelWidthHeightRatio
=
1f
;
int
aspectRatioCode
=
(
csdData
[
7
]
&
0xF0
)
>
>
4
;
switch
(
aspectRatioCode
)
{
case
2
:
pixelWidthHeightRatio
=
(
4
*
height
)
/
(
float
)
(
3
*
width
)
;
break
;
case
3
:
pixelWidthHeightRatio
=
(
16
*
height
)
/
(
float
)
(
9
*
width
)
;
break
;
case
4
:
pixelWidthHeightRatio
=
(
121
*
height
)
/
(
float
)
(
100
*
width
)
;
break
;
default
:
break
;
}
Format
format
=
Format
.
createVideoSampleFormat
(
formatId
MimeTypes
.
VIDEO_MPEG2
null
Format
.
NO_VALUE
Format
.
NO_VALUE
width
height
Format
.
NO_VALUE
Collections
.
singletonList
(
csdData
)
Format
.
NO_VALUE
pixelWidthHeightRatio
null
)
;
long
frameDurationUs
=
0
;
int
frameRateCodeMinusOne
=
(
csdData
[
7
]
&
0x0F
)
-
1
;
if
(
0
<
=
frameRateCodeMinusOne
&
&
frameRateCodeMinusOne
<
FRAME_RATE_VALUES
.
length
)
{
double
frameRate
=
FRAME_RATE_VALUES
[
frameRateCodeMinusOne
]
;
int
sequenceExtensionPosition
=
csdBuffer
.
sequenceExtensionPosition
;
int
frameRateExtensionN
=
(
csdData
[
sequenceExtensionPosition
+
9
]
&
0x60
)
>
>
5
;
int
frameRateExtensionD
=
(
csdData
[
sequenceExtensionPosition
+
9
]
&
0x1F
)
;
if
(
frameRateExtensionN
!
=
frameRateExtensionD
)
{
frameRate
*
=
(
frameRateExtensionN
+
1d
)
/
(
frameRateExtensionD
+
1
)
;
}
frameDurationUs
=
(
long
)
(
C
.
MICROS_PER_SECOND
/
frameRate
)
;
}
return
Pair
.
create
(
format
frameDurationUs
)
;
}
private
static
final
class
CsdBuffer
{
private
boolean
isFilling
;
public
int
length
;
public
int
sequenceExtensionPosition
;
public
byte
[
]
data
;
public
CsdBuffer
(
int
initialCapacity
)
{
data
=
new
byte
[
initialCapacity
]
;
}
public
void
reset
(
)
{
isFilling
=
false
;
length
=
0
;
sequenceExtensionPosition
=
0
;
}
public
boolean
onStartCode
(
int
startCodeValue
int
bytesAlreadyPassed
)
{
if
(
isFilling
)
{
if
(
sequenceExtensionPosition
=
=
0
&
&
startCodeValue
=
=
START_EXTENSION
)
{
sequenceExtensionPosition
=
length
;
}
else
{
length
-
=
bytesAlreadyPassed
;
isFilling
=
false
;
return
true
;
}
}
else
if
(
startCodeValue
=
=
START_SEQUENCE_HEADER
)
{
isFilling
=
true
;
}
return
false
;
}
public
void
onData
(
byte
[
]
newData
int
offset
int
limit
)
{
if
(
!
isFilling
)
{
return
;
}
int
readLength
=
limit
-
offset
;
if
(
data
.
length
<
length
+
readLength
)
{
data
=
Arrays
.
copyOf
(
data
(
length
+
readLength
)
*
2
)
;
}
System
.
arraycopy
(
newData
offset
data
length
readLength
)
;
length
+
=
readLength
;
}
}
}
