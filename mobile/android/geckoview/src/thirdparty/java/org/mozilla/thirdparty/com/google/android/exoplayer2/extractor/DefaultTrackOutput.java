package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocation
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
Allocator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
concurrent
.
LinkedBlockingDeque
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
public
final
class
DefaultTrackOutput
implements
TrackOutput
{
public
interface
UpstreamFormatChangedListener
{
void
onUpstreamFormatChanged
(
Format
format
)
;
}
private
static
final
int
INITIAL_SCRATCH_SIZE
=
32
;
private
static
final
int
STATE_ENABLED
=
0
;
private
static
final
int
STATE_ENABLED_WRITING
=
1
;
private
static
final
int
STATE_DISABLED
=
2
;
private
final
Allocator
allocator
;
private
final
int
allocationLength
;
private
final
InfoQueue
infoQueue
;
private
final
LinkedBlockingDeque
<
Allocation
>
dataQueue
;
private
final
BufferExtrasHolder
extrasHolder
;
private
final
ParsableByteArray
scratch
;
private
final
AtomicInteger
state
;
private
long
totalBytesDropped
;
private
Format
downstreamFormat
;
private
boolean
pendingFormatAdjustment
;
private
Format
lastUnadjustedFormat
;
private
long
sampleOffsetUs
;
private
long
totalBytesWritten
;
private
Allocation
lastAllocation
;
private
int
lastAllocationOffset
;
private
boolean
pendingSplice
;
private
UpstreamFormatChangedListener
upstreamFormatChangeListener
;
public
DefaultTrackOutput
(
Allocator
allocator
)
{
this
.
allocator
=
allocator
;
allocationLength
=
allocator
.
getIndividualAllocationLength
(
)
;
infoQueue
=
new
InfoQueue
(
)
;
dataQueue
=
new
LinkedBlockingDeque
<
>
(
)
;
extrasHolder
=
new
BufferExtrasHolder
(
)
;
scratch
=
new
ParsableByteArray
(
INITIAL_SCRATCH_SIZE
)
;
state
=
new
AtomicInteger
(
)
;
lastAllocationOffset
=
allocationLength
;
}
public
void
reset
(
boolean
enable
)
{
int
previousState
=
state
.
getAndSet
(
enable
?
STATE_ENABLED
:
STATE_DISABLED
)
;
clearSampleData
(
)
;
infoQueue
.
resetLargestParsedTimestamps
(
)
;
if
(
previousState
=
=
STATE_DISABLED
)
{
downstreamFormat
=
null
;
}
}
public
void
sourceId
(
int
sourceId
)
{
infoQueue
.
sourceId
(
sourceId
)
;
}
public
void
splice
(
)
{
pendingSplice
=
true
;
}
public
int
getWriteIndex
(
)
{
return
infoQueue
.
getWriteIndex
(
)
;
}
public
void
discardUpstreamSamples
(
int
discardFromIndex
)
{
totalBytesWritten
=
infoQueue
.
discardUpstreamSamples
(
discardFromIndex
)
;
dropUpstreamFrom
(
totalBytesWritten
)
;
}
private
void
dropUpstreamFrom
(
long
absolutePosition
)
{
int
relativePosition
=
(
int
)
(
absolutePosition
-
totalBytesDropped
)
;
int
allocationIndex
=
relativePosition
/
allocationLength
;
int
allocationOffset
=
relativePosition
%
allocationLength
;
int
allocationDiscardCount
=
dataQueue
.
size
(
)
-
allocationIndex
-
1
;
if
(
allocationOffset
=
=
0
)
{
allocationDiscardCount
+
+
;
}
for
(
int
i
=
0
;
i
<
allocationDiscardCount
;
i
+
+
)
{
allocator
.
release
(
dataQueue
.
removeLast
(
)
)
;
}
lastAllocation
=
dataQueue
.
peekLast
(
)
;
lastAllocationOffset
=
allocationOffset
=
=
0
?
allocationLength
:
allocationOffset
;
}
public
void
disable
(
)
{
if
(
state
.
getAndSet
(
STATE_DISABLED
)
=
=
STATE_ENABLED
)
{
clearSampleData
(
)
;
}
}
public
boolean
isEmpty
(
)
{
return
infoQueue
.
isEmpty
(
)
;
}
public
int
getReadIndex
(
)
{
return
infoQueue
.
getReadIndex
(
)
;
}
public
int
peekSourceId
(
)
{
return
infoQueue
.
peekSourceId
(
)
;
}
public
Format
getUpstreamFormat
(
)
{
return
infoQueue
.
getUpstreamFormat
(
)
;
}
public
long
getLargestQueuedTimestampUs
(
)
{
return
infoQueue
.
getLargestQueuedTimestampUs
(
)
;
}
public
void
skipAll
(
)
{
long
nextOffset
=
infoQueue
.
skipAll
(
)
;
if
(
nextOffset
!
=
C
.
POSITION_UNSET
)
{
dropDownstreamTo
(
nextOffset
)
;
}
}
public
boolean
skipToKeyframeBefore
(
long
timeUs
boolean
allowTimeBeyondBuffer
)
{
long
nextOffset
=
infoQueue
.
skipToKeyframeBefore
(
timeUs
allowTimeBeyondBuffer
)
;
if
(
nextOffset
=
=
C
.
POSITION_UNSET
)
{
return
false
;
}
dropDownstreamTo
(
nextOffset
)
;
return
true
;
}
public
int
readData
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
boolean
loadingFinished
long
decodeOnlyUntilUs
)
{
int
result
=
infoQueue
.
readData
(
formatHolder
buffer
formatRequired
loadingFinished
downstreamFormat
extrasHolder
)
;
switch
(
result
)
{
case
C
.
RESULT_FORMAT_READ
:
downstreamFormat
=
formatHolder
.
format
;
return
C
.
RESULT_FORMAT_READ
;
case
C
.
RESULT_BUFFER_READ
:
if
(
!
buffer
.
isEndOfStream
(
)
)
{
if
(
buffer
.
timeUs
<
decodeOnlyUntilUs
)
{
buffer
.
addFlag
(
C
.
BUFFER_FLAG_DECODE_ONLY
)
;
}
if
(
buffer
.
isEncrypted
(
)
)
{
readEncryptionData
(
buffer
extrasHolder
)
;
}
buffer
.
ensureSpaceForWrite
(
extrasHolder
.
size
)
;
readData
(
extrasHolder
.
offset
buffer
.
data
extrasHolder
.
size
)
;
dropDownstreamTo
(
extrasHolder
.
nextOffset
)
;
}
return
C
.
RESULT_BUFFER_READ
;
case
C
.
RESULT_NOTHING_READ
:
return
C
.
RESULT_NOTHING_READ
;
default
:
throw
new
IllegalStateException
(
)
;
}
}
private
void
readEncryptionData
(
DecoderInputBuffer
buffer
BufferExtrasHolder
extrasHolder
)
{
long
offset
=
extrasHolder
.
offset
;
scratch
.
reset
(
1
)
;
readData
(
offset
scratch
.
data
1
)
;
offset
+
+
;
byte
signalByte
=
scratch
.
data
[
0
]
;
boolean
subsampleEncryption
=
(
signalByte
&
0x80
)
!
=
0
;
int
ivSize
=
signalByte
&
0x7F
;
if
(
buffer
.
cryptoInfo
.
iv
=
=
null
)
{
buffer
.
cryptoInfo
.
iv
=
new
byte
[
16
]
;
}
readData
(
offset
buffer
.
cryptoInfo
.
iv
ivSize
)
;
offset
+
=
ivSize
;
int
subsampleCount
;
if
(
subsampleEncryption
)
{
scratch
.
reset
(
2
)
;
readData
(
offset
scratch
.
data
2
)
;
offset
+
=
2
;
subsampleCount
=
scratch
.
readUnsignedShort
(
)
;
}
else
{
subsampleCount
=
1
;
}
int
[
]
clearDataSizes
=
buffer
.
cryptoInfo
.
numBytesOfClearData
;
if
(
clearDataSizes
=
=
null
|
|
clearDataSizes
.
length
<
subsampleCount
)
{
clearDataSizes
=
new
int
[
subsampleCount
]
;
}
int
[
]
encryptedDataSizes
=
buffer
.
cryptoInfo
.
numBytesOfEncryptedData
;
if
(
encryptedDataSizes
=
=
null
|
|
encryptedDataSizes
.
length
<
subsampleCount
)
{
encryptedDataSizes
=
new
int
[
subsampleCount
]
;
}
if
(
subsampleEncryption
)
{
int
subsampleDataLength
=
6
*
subsampleCount
;
scratch
.
reset
(
subsampleDataLength
)
;
readData
(
offset
scratch
.
data
subsampleDataLength
)
;
offset
+
=
subsampleDataLength
;
scratch
.
setPosition
(
0
)
;
for
(
int
i
=
0
;
i
<
subsampleCount
;
i
+
+
)
{
clearDataSizes
[
i
]
=
scratch
.
readUnsignedShort
(
)
;
encryptedDataSizes
[
i
]
=
scratch
.
readUnsignedIntToInt
(
)
;
}
}
else
{
clearDataSizes
[
0
]
=
0
;
encryptedDataSizes
[
0
]
=
extrasHolder
.
size
-
(
int
)
(
offset
-
extrasHolder
.
offset
)
;
}
buffer
.
cryptoInfo
.
set
(
subsampleCount
clearDataSizes
encryptedDataSizes
extrasHolder
.
encryptionKeyId
buffer
.
cryptoInfo
.
iv
C
.
CRYPTO_MODE_AES_CTR
)
;
int
bytesRead
=
(
int
)
(
offset
-
extrasHolder
.
offset
)
;
extrasHolder
.
offset
+
=
bytesRead
;
extrasHolder
.
size
-
=
bytesRead
;
}
private
void
readData
(
long
absolutePosition
ByteBuffer
target
int
length
)
{
int
remaining
=
length
;
while
(
remaining
>
0
)
{
dropDownstreamTo
(
absolutePosition
)
;
int
positionInAllocation
=
(
int
)
(
absolutePosition
-
totalBytesDropped
)
;
int
toCopy
=
Math
.
min
(
remaining
allocationLength
-
positionInAllocation
)
;
Allocation
allocation
=
dataQueue
.
peek
(
)
;
target
.
put
(
allocation
.
data
allocation
.
translateOffset
(
positionInAllocation
)
toCopy
)
;
absolutePosition
+
=
toCopy
;
remaining
-
=
toCopy
;
}
}
private
void
readData
(
long
absolutePosition
byte
[
]
target
int
length
)
{
int
bytesRead
=
0
;
while
(
bytesRead
<
length
)
{
dropDownstreamTo
(
absolutePosition
)
;
int
positionInAllocation
=
(
int
)
(
absolutePosition
-
totalBytesDropped
)
;
int
toCopy
=
Math
.
min
(
length
-
bytesRead
allocationLength
-
positionInAllocation
)
;
Allocation
allocation
=
dataQueue
.
peek
(
)
;
System
.
arraycopy
(
allocation
.
data
allocation
.
translateOffset
(
positionInAllocation
)
target
bytesRead
toCopy
)
;
absolutePosition
+
=
toCopy
;
bytesRead
+
=
toCopy
;
}
}
private
void
dropDownstreamTo
(
long
absolutePosition
)
{
int
relativePosition
=
(
int
)
(
absolutePosition
-
totalBytesDropped
)
;
int
allocationIndex
=
relativePosition
/
allocationLength
;
for
(
int
i
=
0
;
i
<
allocationIndex
;
i
+
+
)
{
allocator
.
release
(
dataQueue
.
remove
(
)
)
;
totalBytesDropped
+
=
allocationLength
;
}
}
public
void
setUpstreamFormatChangeListener
(
UpstreamFormatChangedListener
listener
)
{
upstreamFormatChangeListener
=
listener
;
}
public
void
setSampleOffsetUs
(
long
sampleOffsetUs
)
{
if
(
this
.
sampleOffsetUs
!
=
sampleOffsetUs
)
{
this
.
sampleOffsetUs
=
sampleOffsetUs
;
pendingFormatAdjustment
=
true
;
}
}
Override
public
void
format
(
Format
format
)
{
Format
adjustedFormat
=
getAdjustedSampleFormat
(
format
sampleOffsetUs
)
;
boolean
formatChanged
=
infoQueue
.
format
(
adjustedFormat
)
;
lastUnadjustedFormat
=
format
;
pendingFormatAdjustment
=
false
;
if
(
upstreamFormatChangeListener
!
=
null
&
&
formatChanged
)
{
upstreamFormatChangeListener
.
onUpstreamFormatChanged
(
adjustedFormat
)
;
}
}
Override
public
int
sampleData
(
ExtractorInput
input
int
length
boolean
allowEndOfInput
)
throws
IOException
InterruptedException
{
if
(
!
startWriteOperation
(
)
)
{
int
bytesSkipped
=
input
.
skip
(
length
)
;
if
(
bytesSkipped
=
=
C
.
RESULT_END_OF_INPUT
)
{
if
(
allowEndOfInput
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
throw
new
EOFException
(
)
;
}
return
bytesSkipped
;
}
try
{
length
=
prepareForAppend
(
length
)
;
int
bytesAppended
=
input
.
read
(
lastAllocation
.
data
lastAllocation
.
translateOffset
(
lastAllocationOffset
)
length
)
;
if
(
bytesAppended
=
=
C
.
RESULT_END_OF_INPUT
)
{
if
(
allowEndOfInput
)
{
return
C
.
RESULT_END_OF_INPUT
;
}
throw
new
EOFException
(
)
;
}
lastAllocationOffset
+
=
bytesAppended
;
totalBytesWritten
+
=
bytesAppended
;
return
bytesAppended
;
}
finally
{
endWriteOperation
(
)
;
}
}
Override
public
void
sampleData
(
ParsableByteArray
buffer
int
length
)
{
if
(
!
startWriteOperation
(
)
)
{
buffer
.
skipBytes
(
length
)
;
return
;
}
while
(
length
>
0
)
{
int
thisAppendLength
=
prepareForAppend
(
length
)
;
buffer
.
readBytes
(
lastAllocation
.
data
lastAllocation
.
translateOffset
(
lastAllocationOffset
)
thisAppendLength
)
;
lastAllocationOffset
+
=
thisAppendLength
;
totalBytesWritten
+
=
thisAppendLength
;
length
-
=
thisAppendLength
;
}
endWriteOperation
(
)
;
}
Override
public
void
sampleMetadata
(
long
timeUs
C
.
BufferFlags
int
flags
int
size
int
offset
byte
[
]
encryptionKey
)
{
if
(
pendingFormatAdjustment
)
{
format
(
lastUnadjustedFormat
)
;
}
if
(
!
startWriteOperation
(
)
)
{
infoQueue
.
commitSampleTimestamp
(
timeUs
)
;
return
;
}
try
{
if
(
pendingSplice
)
{
if
(
(
flags
&
C
.
BUFFER_FLAG_KEY_FRAME
)
=
=
0
|
|
!
infoQueue
.
attemptSplice
(
timeUs
)
)
{
return
;
}
pendingSplice
=
false
;
}
timeUs
+
=
sampleOffsetUs
;
long
absoluteOffset
=
totalBytesWritten
-
size
-
offset
;
infoQueue
.
commitSample
(
timeUs
flags
absoluteOffset
size
encryptionKey
)
;
}
finally
{
endWriteOperation
(
)
;
}
}
private
boolean
startWriteOperation
(
)
{
return
state
.
compareAndSet
(
STATE_ENABLED
STATE_ENABLED_WRITING
)
;
}
private
void
endWriteOperation
(
)
{
if
(
!
state
.
compareAndSet
(
STATE_ENABLED_WRITING
STATE_ENABLED
)
)
{
clearSampleData
(
)
;
}
}
private
void
clearSampleData
(
)
{
infoQueue
.
clearSampleData
(
)
;
allocator
.
release
(
dataQueue
.
toArray
(
new
Allocation
[
dataQueue
.
size
(
)
]
)
)
;
dataQueue
.
clear
(
)
;
allocator
.
trim
(
)
;
totalBytesDropped
=
0
;
totalBytesWritten
=
0
;
lastAllocation
=
null
;
lastAllocationOffset
=
allocationLength
;
}
private
int
prepareForAppend
(
int
length
)
{
if
(
lastAllocationOffset
=
=
allocationLength
)
{
lastAllocationOffset
=
0
;
lastAllocation
=
allocator
.
allocate
(
)
;
dataQueue
.
add
(
lastAllocation
)
;
}
return
Math
.
min
(
length
allocationLength
-
lastAllocationOffset
)
;
}
private
static
Format
getAdjustedSampleFormat
(
Format
format
long
sampleOffsetUs
)
{
if
(
format
=
=
null
)
{
return
null
;
}
if
(
sampleOffsetUs
!
=
0
&
&
format
.
subsampleOffsetUs
!
=
Format
.
OFFSET_SAMPLE_RELATIVE
)
{
format
=
format
.
copyWithSubsampleOffsetUs
(
format
.
subsampleOffsetUs
+
sampleOffsetUs
)
;
}
return
format
;
}
private
static
final
class
InfoQueue
{
private
static
final
int
SAMPLE_CAPACITY_INCREMENT
=
1000
;
private
int
capacity
;
private
int
[
]
sourceIds
;
private
long
[
]
offsets
;
private
int
[
]
sizes
;
private
int
[
]
flags
;
private
long
[
]
timesUs
;
private
byte
[
]
[
]
encryptionKeys
;
private
Format
[
]
formats
;
private
int
queueSize
;
private
int
absoluteReadIndex
;
private
int
relativeReadIndex
;
private
int
relativeWriteIndex
;
private
long
largestDequeuedTimestampUs
;
private
long
largestQueuedTimestampUs
;
private
boolean
upstreamKeyframeRequired
;
private
boolean
upstreamFormatRequired
;
private
Format
upstreamFormat
;
private
int
upstreamSourceId
;
public
InfoQueue
(
)
{
capacity
=
SAMPLE_CAPACITY_INCREMENT
;
sourceIds
=
new
int
[
capacity
]
;
offsets
=
new
long
[
capacity
]
;
timesUs
=
new
long
[
capacity
]
;
flags
=
new
int
[
capacity
]
;
sizes
=
new
int
[
capacity
]
;
encryptionKeys
=
new
byte
[
capacity
]
[
]
;
formats
=
new
Format
[
capacity
]
;
largestDequeuedTimestampUs
=
Long
.
MIN_VALUE
;
largestQueuedTimestampUs
=
Long
.
MIN_VALUE
;
upstreamFormatRequired
=
true
;
upstreamKeyframeRequired
=
true
;
}
public
void
clearSampleData
(
)
{
absoluteReadIndex
=
0
;
relativeReadIndex
=
0
;
relativeWriteIndex
=
0
;
queueSize
=
0
;
upstreamKeyframeRequired
=
true
;
}
public
void
resetLargestParsedTimestamps
(
)
{
largestDequeuedTimestampUs
=
Long
.
MIN_VALUE
;
largestQueuedTimestampUs
=
Long
.
MIN_VALUE
;
}
public
int
getWriteIndex
(
)
{
return
absoluteReadIndex
+
queueSize
;
}
public
long
discardUpstreamSamples
(
int
discardFromIndex
)
{
int
discardCount
=
getWriteIndex
(
)
-
discardFromIndex
;
Assertions
.
checkArgument
(
0
<
=
discardCount
&
&
discardCount
<
=
queueSize
)
;
if
(
discardCount
=
=
0
)
{
if
(
absoluteReadIndex
=
=
0
)
{
return
0
;
}
int
lastWriteIndex
=
(
relativeWriteIndex
=
=
0
?
capacity
:
relativeWriteIndex
)
-
1
;
return
offsets
[
lastWriteIndex
]
+
sizes
[
lastWriteIndex
]
;
}
queueSize
-
=
discardCount
;
relativeWriteIndex
=
(
relativeWriteIndex
+
capacity
-
discardCount
)
%
capacity
;
largestQueuedTimestampUs
=
Long
.
MIN_VALUE
;
for
(
int
i
=
queueSize
-
1
;
i
>
=
0
;
i
-
-
)
{
int
sampleIndex
=
(
relativeReadIndex
+
i
)
%
capacity
;
largestQueuedTimestampUs
=
Math
.
max
(
largestQueuedTimestampUs
timesUs
[
sampleIndex
]
)
;
if
(
(
flags
[
sampleIndex
]
&
C
.
BUFFER_FLAG_KEY_FRAME
)
!
=
0
)
{
break
;
}
}
return
offsets
[
relativeWriteIndex
]
;
}
public
void
sourceId
(
int
sourceId
)
{
upstreamSourceId
=
sourceId
;
}
public
int
getReadIndex
(
)
{
return
absoluteReadIndex
;
}
public
int
peekSourceId
(
)
{
return
queueSize
=
=
0
?
upstreamSourceId
:
sourceIds
[
relativeReadIndex
]
;
}
public
synchronized
boolean
isEmpty
(
)
{
return
queueSize
=
=
0
;
}
public
synchronized
Format
getUpstreamFormat
(
)
{
return
upstreamFormatRequired
?
null
:
upstreamFormat
;
}
public
synchronized
long
getLargestQueuedTimestampUs
(
)
{
return
Math
.
max
(
largestDequeuedTimestampUs
largestQueuedTimestampUs
)
;
}
SuppressWarnings
(
"
ReferenceEquality
"
)
public
synchronized
int
readData
(
FormatHolder
formatHolder
DecoderInputBuffer
buffer
boolean
formatRequired
boolean
loadingFinished
Format
downstreamFormat
BufferExtrasHolder
extrasHolder
)
{
if
(
queueSize
=
=
0
)
{
if
(
loadingFinished
)
{
buffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
return
C
.
RESULT_BUFFER_READ
;
}
else
if
(
upstreamFormat
!
=
null
&
&
(
formatRequired
|
|
upstreamFormat
!
=
downstreamFormat
)
)
{
formatHolder
.
format
=
upstreamFormat
;
return
C
.
RESULT_FORMAT_READ
;
}
else
{
return
C
.
RESULT_NOTHING_READ
;
}
}
if
(
formatRequired
|
|
formats
[
relativeReadIndex
]
!
=
downstreamFormat
)
{
formatHolder
.
format
=
formats
[
relativeReadIndex
]
;
return
C
.
RESULT_FORMAT_READ
;
}
if
(
buffer
.
isFlagsOnly
(
)
)
{
return
C
.
RESULT_NOTHING_READ
;
}
buffer
.
timeUs
=
timesUs
[
relativeReadIndex
]
;
buffer
.
setFlags
(
flags
[
relativeReadIndex
]
)
;
extrasHolder
.
size
=
sizes
[
relativeReadIndex
]
;
extrasHolder
.
offset
=
offsets
[
relativeReadIndex
]
;
extrasHolder
.
encryptionKeyId
=
encryptionKeys
[
relativeReadIndex
]
;
largestDequeuedTimestampUs
=
Math
.
max
(
largestDequeuedTimestampUs
buffer
.
timeUs
)
;
queueSize
-
-
;
relativeReadIndex
+
+
;
absoluteReadIndex
+
+
;
if
(
relativeReadIndex
=
=
capacity
)
{
relativeReadIndex
=
0
;
}
extrasHolder
.
nextOffset
=
queueSize
>
0
?
offsets
[
relativeReadIndex
]
:
extrasHolder
.
offset
+
extrasHolder
.
size
;
return
C
.
RESULT_BUFFER_READ
;
}
public
synchronized
long
skipAll
(
)
{
if
(
queueSize
=
=
0
)
{
return
C
.
POSITION_UNSET
;
}
int
lastSampleIndex
=
(
relativeReadIndex
+
queueSize
-
1
)
%
capacity
;
relativeReadIndex
=
(
relativeReadIndex
+
queueSize
)
%
capacity
;
absoluteReadIndex
+
=
queueSize
;
queueSize
=
0
;
return
offsets
[
lastSampleIndex
]
+
sizes
[
lastSampleIndex
]
;
}
public
synchronized
long
skipToKeyframeBefore
(
long
timeUs
boolean
allowTimeBeyondBuffer
)
{
if
(
queueSize
=
=
0
|
|
timeUs
<
timesUs
[
relativeReadIndex
]
)
{
return
C
.
POSITION_UNSET
;
}
if
(
timeUs
>
largestQueuedTimestampUs
&
&
!
allowTimeBeyondBuffer
)
{
return
C
.
POSITION_UNSET
;
}
int
sampleCount
=
0
;
int
sampleCountToKeyframe
=
-
1
;
int
searchIndex
=
relativeReadIndex
;
while
(
searchIndex
!
=
relativeWriteIndex
)
{
if
(
timesUs
[
searchIndex
]
>
timeUs
)
{
break
;
}
else
if
(
(
flags
[
searchIndex
]
&
C
.
BUFFER_FLAG_KEY_FRAME
)
!
=
0
)
{
sampleCountToKeyframe
=
sampleCount
;
}
searchIndex
=
(
searchIndex
+
1
)
%
capacity
;
sampleCount
+
+
;
}
if
(
sampleCountToKeyframe
=
=
-
1
)
{
return
C
.
POSITION_UNSET
;
}
relativeReadIndex
=
(
relativeReadIndex
+
sampleCountToKeyframe
)
%
capacity
;
absoluteReadIndex
+
=
sampleCountToKeyframe
;
queueSize
-
=
sampleCountToKeyframe
;
return
offsets
[
relativeReadIndex
]
;
}
public
synchronized
boolean
format
(
Format
format
)
{
if
(
format
=
=
null
)
{
upstreamFormatRequired
=
true
;
return
false
;
}
upstreamFormatRequired
=
false
;
if
(
Util
.
areEqual
(
format
upstreamFormat
)
)
{
return
false
;
}
else
{
upstreamFormat
=
format
;
return
true
;
}
}
public
synchronized
void
commitSample
(
long
timeUs
C
.
BufferFlags
int
sampleFlags
long
offset
int
size
byte
[
]
encryptionKey
)
{
if
(
upstreamKeyframeRequired
)
{
if
(
(
sampleFlags
&
C
.
BUFFER_FLAG_KEY_FRAME
)
=
=
0
)
{
return
;
}
upstreamKeyframeRequired
=
false
;
}
Assertions
.
checkState
(
!
upstreamFormatRequired
)
;
commitSampleTimestamp
(
timeUs
)
;
timesUs
[
relativeWriteIndex
]
=
timeUs
;
offsets
[
relativeWriteIndex
]
=
offset
;
sizes
[
relativeWriteIndex
]
=
size
;
flags
[
relativeWriteIndex
]
=
sampleFlags
;
encryptionKeys
[
relativeWriteIndex
]
=
encryptionKey
;
formats
[
relativeWriteIndex
]
=
upstreamFormat
;
sourceIds
[
relativeWriteIndex
]
=
upstreamSourceId
;
queueSize
+
+
;
if
(
queueSize
=
=
capacity
)
{
int
newCapacity
=
capacity
+
SAMPLE_CAPACITY_INCREMENT
;
int
[
]
newSourceIds
=
new
int
[
newCapacity
]
;
long
[
]
newOffsets
=
new
long
[
newCapacity
]
;
long
[
]
newTimesUs
=
new
long
[
newCapacity
]
;
int
[
]
newFlags
=
new
int
[
newCapacity
]
;
int
[
]
newSizes
=
new
int
[
newCapacity
]
;
byte
[
]
[
]
newEncryptionKeys
=
new
byte
[
newCapacity
]
[
]
;
Format
[
]
newFormats
=
new
Format
[
newCapacity
]
;
int
beforeWrap
=
capacity
-
relativeReadIndex
;
System
.
arraycopy
(
offsets
relativeReadIndex
newOffsets
0
beforeWrap
)
;
System
.
arraycopy
(
timesUs
relativeReadIndex
newTimesUs
0
beforeWrap
)
;
System
.
arraycopy
(
flags
relativeReadIndex
newFlags
0
beforeWrap
)
;
System
.
arraycopy
(
sizes
relativeReadIndex
newSizes
0
beforeWrap
)
;
System
.
arraycopy
(
encryptionKeys
relativeReadIndex
newEncryptionKeys
0
beforeWrap
)
;
System
.
arraycopy
(
formats
relativeReadIndex
newFormats
0
beforeWrap
)
;
System
.
arraycopy
(
sourceIds
relativeReadIndex
newSourceIds
0
beforeWrap
)
;
int
afterWrap
=
relativeReadIndex
;
System
.
arraycopy
(
offsets
0
newOffsets
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
timesUs
0
newTimesUs
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
flags
0
newFlags
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
sizes
0
newSizes
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
encryptionKeys
0
newEncryptionKeys
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
formats
0
newFormats
beforeWrap
afterWrap
)
;
System
.
arraycopy
(
sourceIds
0
newSourceIds
beforeWrap
afterWrap
)
;
offsets
=
newOffsets
;
timesUs
=
newTimesUs
;
flags
=
newFlags
;
sizes
=
newSizes
;
encryptionKeys
=
newEncryptionKeys
;
formats
=
newFormats
;
sourceIds
=
newSourceIds
;
relativeReadIndex
=
0
;
relativeWriteIndex
=
capacity
;
queueSize
=
capacity
;
capacity
=
newCapacity
;
}
else
{
relativeWriteIndex
+
+
;
if
(
relativeWriteIndex
=
=
capacity
)
{
relativeWriteIndex
=
0
;
}
}
}
public
synchronized
void
commitSampleTimestamp
(
long
timeUs
)
{
largestQueuedTimestampUs
=
Math
.
max
(
largestQueuedTimestampUs
timeUs
)
;
}
public
synchronized
boolean
attemptSplice
(
long
timeUs
)
{
if
(
largestDequeuedTimestampUs
>
=
timeUs
)
{
return
false
;
}
int
retainCount
=
queueSize
;
while
(
retainCount
>
0
&
&
timesUs
[
(
relativeReadIndex
+
retainCount
-
1
)
%
capacity
]
>
=
timeUs
)
{
retainCount
-
-
;
}
discardUpstreamSamples
(
absoluteReadIndex
+
retainCount
)
;
return
true
;
}
}
private
static
final
class
BufferExtrasHolder
{
public
int
size
;
public
long
offset
;
public
long
nextOffset
;
public
byte
[
]
encryptionKeyId
;
}
}
