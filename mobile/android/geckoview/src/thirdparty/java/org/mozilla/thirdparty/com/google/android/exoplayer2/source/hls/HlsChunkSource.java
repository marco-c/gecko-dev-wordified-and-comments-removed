package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
;
import
android
.
net
.
Uri
;
import
android
.
os
.
SystemClock
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
BehindLiveWindowException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
Chunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
ChunkedTrackBlacklistUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
DataChunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMasterPlaylist
.
HlsUrl
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMediaPlaylist
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMediaPlaylist
.
Segment
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsPlaylistTracker
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
BaseTrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
UriUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
math
.
BigInteger
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
class
HlsChunkSource
{
public
static
final
class
HlsChunkHolder
{
public
HlsChunkHolder
(
)
{
clear
(
)
;
}
public
Chunk
chunk
;
public
boolean
endOfStream
;
public
HlsUrl
playlist
;
public
void
clear
(
)
{
chunk
=
null
;
endOfStream
=
false
;
playlist
=
null
;
}
}
private
final
DataSource
mediaDataSource
;
private
final
DataSource
encryptionDataSource
;
private
final
TimestampAdjusterProvider
timestampAdjusterProvider
;
private
final
HlsUrl
[
]
variants
;
private
final
HlsPlaylistTracker
playlistTracker
;
private
final
TrackGroup
trackGroup
;
private
final
List
<
Format
>
muxedCaptionFormats
;
private
boolean
isTimestampMaster
;
private
byte
[
]
scratchSpace
;
private
IOException
fatalError
;
private
Uri
encryptionKeyUri
;
private
byte
[
]
encryptionKey
;
private
String
encryptionIvString
;
private
byte
[
]
encryptionIv
;
private
TrackSelection
trackSelection
;
public
HlsChunkSource
(
HlsPlaylistTracker
playlistTracker
HlsUrl
[
]
variants
HlsDataSourceFactory
dataSourceFactory
TimestampAdjusterProvider
timestampAdjusterProvider
List
<
Format
>
muxedCaptionFormats
)
{
this
.
playlistTracker
=
playlistTracker
;
this
.
variants
=
variants
;
this
.
timestampAdjusterProvider
=
timestampAdjusterProvider
;
this
.
muxedCaptionFormats
=
muxedCaptionFormats
;
Format
[
]
variantFormats
=
new
Format
[
variants
.
length
]
;
int
[
]
initialTrackSelection
=
new
int
[
variants
.
length
]
;
for
(
int
i
=
0
;
i
<
variants
.
length
;
i
+
+
)
{
variantFormats
[
i
]
=
variants
[
i
]
.
format
;
initialTrackSelection
[
i
]
=
i
;
}
mediaDataSource
=
dataSourceFactory
.
createDataSource
(
C
.
DATA_TYPE_MEDIA
)
;
encryptionDataSource
=
dataSourceFactory
.
createDataSource
(
C
.
DATA_TYPE_DRM
)
;
trackGroup
=
new
TrackGroup
(
variantFormats
)
;
trackSelection
=
new
InitializationTrackSelection
(
trackGroup
initialTrackSelection
)
;
}
public
void
maybeThrowError
(
)
throws
IOException
{
if
(
fatalError
!
=
null
)
{
throw
fatalError
;
}
}
public
TrackGroup
getTrackGroup
(
)
{
return
trackGroup
;
}
public
void
selectTracks
(
TrackSelection
trackSelection
)
{
this
.
trackSelection
=
trackSelection
;
}
public
void
reset
(
)
{
fatalError
=
null
;
}
public
void
setIsTimestampMaster
(
boolean
isTimestampMaster
)
{
this
.
isTimestampMaster
=
isTimestampMaster
;
}
public
void
getNextChunk
(
HlsMediaChunk
previous
long
playbackPositionUs
HlsChunkHolder
out
)
{
int
oldVariantIndex
=
previous
=
=
null
?
C
.
INDEX_UNSET
:
trackGroup
.
indexOf
(
previous
.
trackFormat
)
;
long
bufferedDurationUs
=
previous
=
=
null
?
0
:
Math
.
max
(
0
previous
.
startTimeUs
-
playbackPositionUs
)
;
trackSelection
.
updateSelectedTrack
(
bufferedDurationUs
)
;
int
selectedVariantIndex
=
trackSelection
.
getSelectedIndexInTrackGroup
(
)
;
boolean
switchingVariant
=
oldVariantIndex
!
=
selectedVariantIndex
;
HlsUrl
selectedUrl
=
variants
[
selectedVariantIndex
]
;
if
(
!
playlistTracker
.
isSnapshotValid
(
selectedUrl
)
)
{
out
.
playlist
=
selectedUrl
;
return
;
}
HlsMediaPlaylist
mediaPlaylist
=
playlistTracker
.
getPlaylistSnapshot
(
selectedUrl
)
;
int
chunkMediaSequence
;
if
(
previous
=
=
null
|
|
switchingVariant
)
{
long
targetPositionUs
=
previous
=
=
null
?
playbackPositionUs
:
previous
.
startTimeUs
;
if
(
!
mediaPlaylist
.
hasEndTag
&
&
targetPositionUs
>
mediaPlaylist
.
getEndTimeUs
(
)
)
{
chunkMediaSequence
=
mediaPlaylist
.
mediaSequence
+
mediaPlaylist
.
segments
.
size
(
)
;
}
else
{
chunkMediaSequence
=
Util
.
binarySearchFloor
(
mediaPlaylist
.
segments
targetPositionUs
-
mediaPlaylist
.
startTimeUs
true
!
playlistTracker
.
isLive
(
)
|
|
previous
=
=
null
)
+
mediaPlaylist
.
mediaSequence
;
if
(
chunkMediaSequence
<
mediaPlaylist
.
mediaSequence
&
&
previous
!
=
null
)
{
selectedVariantIndex
=
oldVariantIndex
;
selectedUrl
=
variants
[
selectedVariantIndex
]
;
mediaPlaylist
=
playlistTracker
.
getPlaylistSnapshot
(
selectedUrl
)
;
chunkMediaSequence
=
previous
.
getNextChunkIndex
(
)
;
}
}
}
else
{
chunkMediaSequence
=
previous
.
getNextChunkIndex
(
)
;
}
if
(
chunkMediaSequence
<
mediaPlaylist
.
mediaSequence
)
{
fatalError
=
new
BehindLiveWindowException
(
)
;
return
;
}
int
chunkIndex
=
chunkMediaSequence
-
mediaPlaylist
.
mediaSequence
;
if
(
chunkIndex
>
=
mediaPlaylist
.
segments
.
size
(
)
)
{
if
(
mediaPlaylist
.
hasEndTag
)
{
out
.
endOfStream
=
true
;
}
else
{
out
.
playlist
=
selectedUrl
;
}
return
;
}
HlsMediaPlaylist
.
Segment
segment
=
mediaPlaylist
.
segments
.
get
(
chunkIndex
)
;
if
(
segment
.
isEncrypted
)
{
Uri
keyUri
=
UriUtil
.
resolveToUri
(
mediaPlaylist
.
baseUri
segment
.
encryptionKeyUri
)
;
if
(
!
keyUri
.
equals
(
encryptionKeyUri
)
)
{
out
.
chunk
=
newEncryptionKeyChunk
(
keyUri
segment
.
encryptionIV
selectedVariantIndex
trackSelection
.
getSelectionReason
(
)
trackSelection
.
getSelectionData
(
)
)
;
return
;
}
if
(
!
Util
.
areEqual
(
segment
.
encryptionIV
encryptionIvString
)
)
{
setEncryptionData
(
keyUri
segment
.
encryptionIV
encryptionKey
)
;
}
}
else
{
clearEncryptionData
(
)
;
}
DataSpec
initDataSpec
=
null
;
Segment
initSegment
=
mediaPlaylist
.
initializationSegment
;
if
(
initSegment
!
=
null
)
{
Uri
initSegmentUri
=
UriUtil
.
resolveToUri
(
mediaPlaylist
.
baseUri
initSegment
.
url
)
;
initDataSpec
=
new
DataSpec
(
initSegmentUri
initSegment
.
byterangeOffset
initSegment
.
byterangeLength
null
)
;
}
long
startTimeUs
=
mediaPlaylist
.
startTimeUs
+
segment
.
relativeStartTimeUs
;
int
discontinuitySequence
=
mediaPlaylist
.
discontinuitySequence
+
segment
.
relativeDiscontinuitySequence
;
TimestampAdjuster
timestampAdjuster
=
timestampAdjusterProvider
.
getAdjuster
(
discontinuitySequence
)
;
Uri
chunkUri
=
UriUtil
.
resolveToUri
(
mediaPlaylist
.
baseUri
segment
.
url
)
;
DataSpec
dataSpec
=
new
DataSpec
(
chunkUri
segment
.
byterangeOffset
segment
.
byterangeLength
null
)
;
out
.
chunk
=
new
HlsMediaChunk
(
mediaDataSource
dataSpec
initDataSpec
selectedUrl
muxedCaptionFormats
trackSelection
.
getSelectionReason
(
)
trackSelection
.
getSelectionData
(
)
startTimeUs
startTimeUs
+
segment
.
durationUs
chunkMediaSequence
discontinuitySequence
isTimestampMaster
timestampAdjuster
previous
encryptionKey
encryptionIv
)
;
}
public
void
onChunkLoadCompleted
(
Chunk
chunk
)
{
if
(
chunk
instanceof
EncryptionKeyChunk
)
{
EncryptionKeyChunk
encryptionKeyChunk
=
(
EncryptionKeyChunk
)
chunk
;
scratchSpace
=
encryptionKeyChunk
.
getDataHolder
(
)
;
setEncryptionData
(
encryptionKeyChunk
.
dataSpec
.
uri
encryptionKeyChunk
.
iv
encryptionKeyChunk
.
getResult
(
)
)
;
}
}
public
boolean
onChunkLoadError
(
Chunk
chunk
boolean
cancelable
IOException
error
)
{
return
cancelable
&
&
ChunkedTrackBlacklistUtil
.
maybeBlacklistTrack
(
trackSelection
trackSelection
.
indexOf
(
trackGroup
.
indexOf
(
chunk
.
trackFormat
)
)
error
)
;
}
public
void
onPlaylistBlacklisted
(
HlsUrl
url
long
blacklistMs
)
{
int
trackGroupIndex
=
trackGroup
.
indexOf
(
url
.
format
)
;
if
(
trackGroupIndex
!
=
C
.
INDEX_UNSET
)
{
int
trackSelectionIndex
=
trackSelection
.
indexOf
(
trackGroupIndex
)
;
if
(
trackSelectionIndex
!
=
C
.
INDEX_UNSET
)
{
trackSelection
.
blacklist
(
trackSelectionIndex
blacklistMs
)
;
}
}
}
private
EncryptionKeyChunk
newEncryptionKeyChunk
(
Uri
keyUri
String
iv
int
variantIndex
int
trackSelectionReason
Object
trackSelectionData
)
{
DataSpec
dataSpec
=
new
DataSpec
(
keyUri
0
C
.
LENGTH_UNSET
null
DataSpec
.
FLAG_ALLOW_GZIP
)
;
return
new
EncryptionKeyChunk
(
encryptionDataSource
dataSpec
variants
[
variantIndex
]
.
format
trackSelectionReason
trackSelectionData
scratchSpace
iv
)
;
}
private
void
setEncryptionData
(
Uri
keyUri
String
iv
byte
[
]
secretKey
)
{
String
trimmedIv
;
if
(
iv
.
toLowerCase
(
Locale
.
getDefault
(
)
)
.
startsWith
(
"
0x
"
)
)
{
trimmedIv
=
iv
.
substring
(
2
)
;
}
else
{
trimmedIv
=
iv
;
}
byte
[
]
ivData
=
new
BigInteger
(
trimmedIv
16
)
.
toByteArray
(
)
;
byte
[
]
ivDataWithPadding
=
new
byte
[
16
]
;
int
offset
=
ivData
.
length
>
16
?
ivData
.
length
-
16
:
0
;
System
.
arraycopy
(
ivData
offset
ivDataWithPadding
ivDataWithPadding
.
length
-
ivData
.
length
+
offset
ivData
.
length
-
offset
)
;
encryptionKeyUri
=
keyUri
;
encryptionKey
=
secretKey
;
encryptionIvString
=
iv
;
encryptionIv
=
ivDataWithPadding
;
}
private
void
clearEncryptionData
(
)
{
encryptionKeyUri
=
null
;
encryptionKey
=
null
;
encryptionIvString
=
null
;
encryptionIv
=
null
;
}
private
static
final
class
InitializationTrackSelection
extends
BaseTrackSelection
{
private
int
selectedIndex
;
public
InitializationTrackSelection
(
TrackGroup
group
int
[
]
tracks
)
{
super
(
group
tracks
)
;
selectedIndex
=
indexOf
(
group
.
getFormat
(
0
)
)
;
}
Override
public
void
updateSelectedTrack
(
long
bufferedDurationUs
)
{
long
nowMs
=
SystemClock
.
elapsedRealtime
(
)
;
if
(
!
isBlacklisted
(
selectedIndex
nowMs
)
)
{
return
;
}
for
(
int
i
=
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
!
isBlacklisted
(
i
nowMs
)
)
{
selectedIndex
=
i
;
return
;
}
}
throw
new
IllegalStateException
(
)
;
}
Override
public
int
getSelectedIndex
(
)
{
return
selectedIndex
;
}
Override
public
int
getSelectionReason
(
)
{
return
C
.
SELECTION_REASON_UNKNOWN
;
}
Override
public
Object
getSelectionData
(
)
{
return
null
;
}
}
private
static
final
class
EncryptionKeyChunk
extends
DataChunk
{
public
final
String
iv
;
private
byte
[
]
result
;
public
EncryptionKeyChunk
(
DataSource
dataSource
DataSpec
dataSpec
Format
trackFormat
int
trackSelectionReason
Object
trackSelectionData
byte
[
]
scratchSpace
String
iv
)
{
super
(
dataSource
dataSpec
C
.
DATA_TYPE_DRM
trackFormat
trackSelectionReason
trackSelectionData
scratchSpace
)
;
this
.
iv
=
iv
;
}
Override
protected
void
consume
(
byte
[
]
data
int
limit
)
throws
IOException
{
result
=
Arrays
.
copyOf
(
data
limit
)
;
}
public
byte
[
]
getResult
(
)
{
return
result
;
}
}
}
