package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
;
import
android
.
net
.
Uri
;
import
android
.
os
.
SystemClock
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
BehindLiveWindowException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
TrackGroup
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
BaseMediaChunkIterator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
Chunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
DataChunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
MediaChunk
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
chunk
.
MediaChunkIterator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMediaPlaylist
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsMediaPlaylist
.
Segment
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
source
.
hls
.
playlist
.
HlsPlaylistTracker
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
BaseTrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
trackselection
.
TrackSelection
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSource
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
DataSpec
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
upstream
.
TransferListener
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimestampAdjuster
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
UriUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
List
;
import
org
.
checkerframework
.
checker
.
nullness
.
qual
.
MonotonicNonNull
;
class
HlsChunkSource
{
public
static
final
class
HlsChunkHolder
{
public
HlsChunkHolder
(
)
{
clear
(
)
;
}
Nullable
public
Chunk
chunk
;
public
boolean
endOfStream
;
Nullable
public
Uri
playlistUrl
;
public
void
clear
(
)
{
chunk
=
null
;
endOfStream
=
false
;
playlistUrl
=
null
;
}
}
private
static
final
int
KEY_CACHE_SIZE
=
4
;
private
final
HlsExtractorFactory
extractorFactory
;
private
final
DataSource
mediaDataSource
;
private
final
DataSource
encryptionDataSource
;
private
final
TimestampAdjusterProvider
timestampAdjusterProvider
;
private
final
Uri
[
]
playlistUrls
;
private
final
Format
[
]
playlistFormats
;
private
final
HlsPlaylistTracker
playlistTracker
;
private
final
TrackGroup
trackGroup
;
Nullable
private
final
List
<
Format
>
muxedCaptionFormats
;
private
final
FullSegmentEncryptionKeyCache
keyCache
;
private
boolean
isTimestampMaster
;
private
byte
[
]
scratchSpace
;
Nullable
private
IOException
fatalError
;
Nullable
private
Uri
expectedPlaylistUrl
;
private
boolean
independentSegments
;
private
TrackSelection
trackSelection
;
private
long
liveEdgeInPeriodTimeUs
;
private
boolean
seenExpectedPlaylistError
;
public
HlsChunkSource
(
HlsExtractorFactory
extractorFactory
HlsPlaylistTracker
playlistTracker
Uri
[
]
playlistUrls
Format
[
]
playlistFormats
HlsDataSourceFactory
dataSourceFactory
Nullable
TransferListener
mediaTransferListener
TimestampAdjusterProvider
timestampAdjusterProvider
Nullable
List
<
Format
>
muxedCaptionFormats
)
{
this
.
extractorFactory
=
extractorFactory
;
this
.
playlistTracker
=
playlistTracker
;
this
.
playlistUrls
=
playlistUrls
;
this
.
playlistFormats
=
playlistFormats
;
this
.
timestampAdjusterProvider
=
timestampAdjusterProvider
;
this
.
muxedCaptionFormats
=
muxedCaptionFormats
;
keyCache
=
new
FullSegmentEncryptionKeyCache
(
KEY_CACHE_SIZE
)
;
scratchSpace
=
Util
.
EMPTY_BYTE_ARRAY
;
liveEdgeInPeriodTimeUs
=
C
.
TIME_UNSET
;
mediaDataSource
=
dataSourceFactory
.
createDataSource
(
C
.
DATA_TYPE_MEDIA
)
;
if
(
mediaTransferListener
!
=
null
)
{
mediaDataSource
.
addTransferListener
(
mediaTransferListener
)
;
}
encryptionDataSource
=
dataSourceFactory
.
createDataSource
(
C
.
DATA_TYPE_DRM
)
;
trackGroup
=
new
TrackGroup
(
playlistFormats
)
;
int
[
]
initialTrackSelection
=
new
int
[
playlistUrls
.
length
]
;
for
(
int
i
=
0
;
i
<
playlistUrls
.
length
;
i
+
+
)
{
initialTrackSelection
[
i
]
=
i
;
}
trackSelection
=
new
InitializationTrackSelection
(
trackGroup
initialTrackSelection
)
;
}
public
void
maybeThrowError
(
)
throws
IOException
{
if
(
fatalError
!
=
null
)
{
throw
fatalError
;
}
if
(
expectedPlaylistUrl
!
=
null
&
&
seenExpectedPlaylistError
)
{
playlistTracker
.
maybeThrowPlaylistRefreshError
(
expectedPlaylistUrl
)
;
}
}
public
TrackGroup
getTrackGroup
(
)
{
return
trackGroup
;
}
public
void
setTrackSelection
(
TrackSelection
trackSelection
)
{
this
.
trackSelection
=
trackSelection
;
}
public
TrackSelection
getTrackSelection
(
)
{
return
trackSelection
;
}
public
void
reset
(
)
{
fatalError
=
null
;
}
public
void
setIsTimestampMaster
(
boolean
isTimestampMaster
)
{
this
.
isTimestampMaster
=
isTimestampMaster
;
}
public
void
getNextChunk
(
long
playbackPositionUs
long
loadPositionUs
List
<
HlsMediaChunk
>
queue
boolean
allowEndOfStream
HlsChunkHolder
out
)
{
HlsMediaChunk
previous
=
queue
.
isEmpty
(
)
?
null
:
queue
.
get
(
queue
.
size
(
)
-
1
)
;
int
oldTrackIndex
=
previous
=
=
null
?
C
.
INDEX_UNSET
:
trackGroup
.
indexOf
(
previous
.
trackFormat
)
;
long
bufferedDurationUs
=
loadPositionUs
-
playbackPositionUs
;
long
timeToLiveEdgeUs
=
resolveTimeToLiveEdgeUs
(
playbackPositionUs
)
;
if
(
previous
!
=
null
&
&
!
independentSegments
)
{
long
subtractedDurationUs
=
previous
.
getDurationUs
(
)
;
bufferedDurationUs
=
Math
.
max
(
0
bufferedDurationUs
-
subtractedDurationUs
)
;
if
(
timeToLiveEdgeUs
!
=
C
.
TIME_UNSET
)
{
timeToLiveEdgeUs
=
Math
.
max
(
0
timeToLiveEdgeUs
-
subtractedDurationUs
)
;
}
}
MediaChunkIterator
[
]
mediaChunkIterators
=
createMediaChunkIterators
(
previous
loadPositionUs
)
;
trackSelection
.
updateSelectedTrack
(
playbackPositionUs
bufferedDurationUs
timeToLiveEdgeUs
queue
mediaChunkIterators
)
;
int
selectedTrackIndex
=
trackSelection
.
getSelectedIndexInTrackGroup
(
)
;
boolean
switchingTrack
=
oldTrackIndex
!
=
selectedTrackIndex
;
Uri
selectedPlaylistUrl
=
playlistUrls
[
selectedTrackIndex
]
;
if
(
!
playlistTracker
.
isSnapshotValid
(
selectedPlaylistUrl
)
)
{
out
.
playlistUrl
=
selectedPlaylistUrl
;
seenExpectedPlaylistError
&
=
selectedPlaylistUrl
.
equals
(
expectedPlaylistUrl
)
;
expectedPlaylistUrl
=
selectedPlaylistUrl
;
return
;
}
HlsMediaPlaylist
mediaPlaylist
=
playlistTracker
.
getPlaylistSnapshot
(
selectedPlaylistUrl
true
)
;
Assertions
.
checkNotNull
(
mediaPlaylist
)
;
independentSegments
=
mediaPlaylist
.
hasIndependentSegments
;
updateLiveEdgeTimeUs
(
mediaPlaylist
)
;
long
startOfPlaylistInPeriodUs
=
mediaPlaylist
.
startTimeUs
-
playlistTracker
.
getInitialStartTimeUs
(
)
;
long
chunkMediaSequence
=
getChunkMediaSequence
(
previous
switchingTrack
mediaPlaylist
startOfPlaylistInPeriodUs
loadPositionUs
)
;
if
(
chunkMediaSequence
<
mediaPlaylist
.
mediaSequence
&
&
previous
!
=
null
&
&
switchingTrack
)
{
selectedTrackIndex
=
oldTrackIndex
;
selectedPlaylistUrl
=
playlistUrls
[
selectedTrackIndex
]
;
mediaPlaylist
=
playlistTracker
.
getPlaylistSnapshot
(
selectedPlaylistUrl
true
)
;
Assertions
.
checkNotNull
(
mediaPlaylist
)
;
startOfPlaylistInPeriodUs
=
mediaPlaylist
.
startTimeUs
-
playlistTracker
.
getInitialStartTimeUs
(
)
;
chunkMediaSequence
=
previous
.
getNextChunkIndex
(
)
;
}
if
(
chunkMediaSequence
<
mediaPlaylist
.
mediaSequence
)
{
fatalError
=
new
BehindLiveWindowException
(
)
;
return
;
}
int
segmentIndexInPlaylist
=
(
int
)
(
chunkMediaSequence
-
mediaPlaylist
.
mediaSequence
)
;
int
availableSegmentCount
=
mediaPlaylist
.
segments
.
size
(
)
;
if
(
segmentIndexInPlaylist
>
=
availableSegmentCount
)
{
if
(
mediaPlaylist
.
hasEndTag
)
{
if
(
allowEndOfStream
|
|
availableSegmentCount
=
=
0
)
{
out
.
endOfStream
=
true
;
return
;
}
segmentIndexInPlaylist
=
availableSegmentCount
-
1
;
}
else
{
out
.
playlistUrl
=
selectedPlaylistUrl
;
seenExpectedPlaylistError
&
=
selectedPlaylistUrl
.
equals
(
expectedPlaylistUrl
)
;
expectedPlaylistUrl
=
selectedPlaylistUrl
;
return
;
}
}
seenExpectedPlaylistError
=
false
;
expectedPlaylistUrl
=
null
;
HlsMediaPlaylist
.
Segment
segment
=
mediaPlaylist
.
segments
.
get
(
segmentIndexInPlaylist
)
;
Uri
initSegmentKeyUri
=
getFullEncryptionKeyUri
(
mediaPlaylist
segment
.
initializationSegment
)
;
out
.
chunk
=
maybeCreateEncryptionChunkFor
(
initSegmentKeyUri
selectedTrackIndex
)
;
if
(
out
.
chunk
!
=
null
)
{
return
;
}
Uri
mediaSegmentKeyUri
=
getFullEncryptionKeyUri
(
mediaPlaylist
segment
)
;
out
.
chunk
=
maybeCreateEncryptionChunkFor
(
mediaSegmentKeyUri
selectedTrackIndex
)
;
if
(
out
.
chunk
!
=
null
)
{
return
;
}
out
.
chunk
=
HlsMediaChunk
.
createInstance
(
extractorFactory
mediaDataSource
playlistFormats
[
selectedTrackIndex
]
startOfPlaylistInPeriodUs
mediaPlaylist
segmentIndexInPlaylist
selectedPlaylistUrl
muxedCaptionFormats
trackSelection
.
getSelectionReason
(
)
trackSelection
.
getSelectionData
(
)
isTimestampMaster
timestampAdjusterProvider
previous
keyCache
.
get
(
mediaSegmentKeyUri
)
keyCache
.
get
(
initSegmentKeyUri
)
)
;
}
public
void
onChunkLoadCompleted
(
Chunk
chunk
)
{
if
(
chunk
instanceof
EncryptionKeyChunk
)
{
EncryptionKeyChunk
encryptionKeyChunk
=
(
EncryptionKeyChunk
)
chunk
;
scratchSpace
=
encryptionKeyChunk
.
getDataHolder
(
)
;
keyCache
.
put
(
encryptionKeyChunk
.
dataSpec
.
uri
Assertions
.
checkNotNull
(
encryptionKeyChunk
.
getResult
(
)
)
)
;
}
}
public
boolean
maybeBlacklistTrack
(
Chunk
chunk
long
blacklistDurationMs
)
{
return
trackSelection
.
blacklist
(
trackSelection
.
indexOf
(
trackGroup
.
indexOf
(
chunk
.
trackFormat
)
)
blacklistDurationMs
)
;
}
public
boolean
onPlaylistError
(
Uri
playlistUrl
long
blacklistDurationMs
)
{
int
trackGroupIndex
=
C
.
INDEX_UNSET
;
for
(
int
i
=
0
;
i
<
playlistUrls
.
length
;
i
+
+
)
{
if
(
playlistUrls
[
i
]
.
equals
(
playlistUrl
)
)
{
trackGroupIndex
=
i
;
break
;
}
}
if
(
trackGroupIndex
=
=
C
.
INDEX_UNSET
)
{
return
true
;
}
int
trackSelectionIndex
=
trackSelection
.
indexOf
(
trackGroupIndex
)
;
if
(
trackSelectionIndex
=
=
C
.
INDEX_UNSET
)
{
return
true
;
}
seenExpectedPlaylistError
|
=
playlistUrl
.
equals
(
expectedPlaylistUrl
)
;
return
blacklistDurationMs
=
=
C
.
TIME_UNSET
|
|
trackSelection
.
blacklist
(
trackSelectionIndex
blacklistDurationMs
)
;
}
public
MediaChunkIterator
[
]
createMediaChunkIterators
(
Nullable
HlsMediaChunk
previous
long
loadPositionUs
)
{
int
oldTrackIndex
=
previous
=
=
null
?
C
.
INDEX_UNSET
:
trackGroup
.
indexOf
(
previous
.
trackFormat
)
;
MediaChunkIterator
[
]
chunkIterators
=
new
MediaChunkIterator
[
trackSelection
.
length
(
)
]
;
for
(
int
i
=
0
;
i
<
chunkIterators
.
length
;
i
+
+
)
{
int
trackIndex
=
trackSelection
.
getIndexInTrackGroup
(
i
)
;
Uri
playlistUrl
=
playlistUrls
[
trackIndex
]
;
if
(
!
playlistTracker
.
isSnapshotValid
(
playlistUrl
)
)
{
chunkIterators
[
i
]
=
MediaChunkIterator
.
EMPTY
;
continue
;
}
HlsMediaPlaylist
playlist
=
playlistTracker
.
getPlaylistSnapshot
(
playlistUrl
false
)
;
Assertions
.
checkNotNull
(
playlist
)
;
long
startOfPlaylistInPeriodUs
=
playlist
.
startTimeUs
-
playlistTracker
.
getInitialStartTimeUs
(
)
;
boolean
switchingTrack
=
trackIndex
!
=
oldTrackIndex
;
long
chunkMediaSequence
=
getChunkMediaSequence
(
previous
switchingTrack
playlist
startOfPlaylistInPeriodUs
loadPositionUs
)
;
if
(
chunkMediaSequence
<
playlist
.
mediaSequence
)
{
chunkIterators
[
i
]
=
MediaChunkIterator
.
EMPTY
;
continue
;
}
int
chunkIndex
=
(
int
)
(
chunkMediaSequence
-
playlist
.
mediaSequence
)
;
chunkIterators
[
i
]
=
new
HlsMediaPlaylistSegmentIterator
(
playlist
startOfPlaylistInPeriodUs
chunkIndex
)
;
}
return
chunkIterators
;
}
private
long
getChunkMediaSequence
(
Nullable
HlsMediaChunk
previous
boolean
switchingTrack
HlsMediaPlaylist
mediaPlaylist
long
startOfPlaylistInPeriodUs
long
loadPositionUs
)
{
if
(
previous
=
=
null
|
|
switchingTrack
)
{
long
endOfPlaylistInPeriodUs
=
startOfPlaylistInPeriodUs
+
mediaPlaylist
.
durationUs
;
long
targetPositionInPeriodUs
=
(
previous
=
=
null
|
|
independentSegments
)
?
loadPositionUs
:
previous
.
startTimeUs
;
if
(
!
mediaPlaylist
.
hasEndTag
&
&
targetPositionInPeriodUs
>
=
endOfPlaylistInPeriodUs
)
{
return
mediaPlaylist
.
mediaSequence
+
mediaPlaylist
.
segments
.
size
(
)
;
}
long
targetPositionInPlaylistUs
=
targetPositionInPeriodUs
-
startOfPlaylistInPeriodUs
;
return
Util
.
binarySearchFloor
(
mediaPlaylist
.
segments
targetPositionInPlaylistUs
true
!
playlistTracker
.
isLive
(
)
|
|
previous
=
=
null
)
+
mediaPlaylist
.
mediaSequence
;
}
return
previous
.
getNextChunkIndex
(
)
;
}
private
long
resolveTimeToLiveEdgeUs
(
long
playbackPositionUs
)
{
final
boolean
resolveTimeToLiveEdgePossible
=
liveEdgeInPeriodTimeUs
!
=
C
.
TIME_UNSET
;
return
resolveTimeToLiveEdgePossible
?
liveEdgeInPeriodTimeUs
-
playbackPositionUs
:
C
.
TIME_UNSET
;
}
private
void
updateLiveEdgeTimeUs
(
HlsMediaPlaylist
mediaPlaylist
)
{
liveEdgeInPeriodTimeUs
=
mediaPlaylist
.
hasEndTag
?
C
.
TIME_UNSET
:
(
mediaPlaylist
.
getEndTimeUs
(
)
-
playlistTracker
.
getInitialStartTimeUs
(
)
)
;
}
Nullable
private
Chunk
maybeCreateEncryptionChunkFor
(
Nullable
Uri
keyUri
int
selectedTrackIndex
)
{
if
(
keyUri
=
=
null
)
{
return
null
;
}
byte
[
]
encryptionKey
=
keyCache
.
remove
(
keyUri
)
;
if
(
encryptionKey
!
=
null
)
{
keyCache
.
put
(
keyUri
encryptionKey
)
;
return
null
;
}
DataSpec
dataSpec
=
new
DataSpec
(
keyUri
0
C
.
LENGTH_UNSET
null
DataSpec
.
FLAG_ALLOW_GZIP
)
;
return
new
EncryptionKeyChunk
(
encryptionDataSource
dataSpec
playlistFormats
[
selectedTrackIndex
]
trackSelection
.
getSelectionReason
(
)
trackSelection
.
getSelectionData
(
)
scratchSpace
)
;
}
Nullable
private
static
Uri
getFullEncryptionKeyUri
(
HlsMediaPlaylist
playlist
Nullable
Segment
segment
)
{
if
(
segment
=
=
null
|
|
segment
.
fullSegmentEncryptionKeyUri
=
=
null
)
{
return
null
;
}
return
UriUtil
.
resolveToUri
(
playlist
.
baseUri
segment
.
fullSegmentEncryptionKeyUri
)
;
}
private
static
final
class
InitializationTrackSelection
extends
BaseTrackSelection
{
private
int
selectedIndex
;
public
InitializationTrackSelection
(
TrackGroup
group
int
[
]
tracks
)
{
super
(
group
tracks
)
;
selectedIndex
=
indexOf
(
group
.
getFormat
(
0
)
)
;
}
Override
public
void
updateSelectedTrack
(
long
playbackPositionUs
long
bufferedDurationUs
long
availableDurationUs
List
<
?
extends
MediaChunk
>
queue
MediaChunkIterator
[
]
mediaChunkIterators
)
{
long
nowMs
=
SystemClock
.
elapsedRealtime
(
)
;
if
(
!
isBlacklisted
(
selectedIndex
nowMs
)
)
{
return
;
}
for
(
int
i
=
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
!
isBlacklisted
(
i
nowMs
)
)
{
selectedIndex
=
i
;
return
;
}
}
throw
new
IllegalStateException
(
)
;
}
Override
public
int
getSelectedIndex
(
)
{
return
selectedIndex
;
}
Override
public
int
getSelectionReason
(
)
{
return
C
.
SELECTION_REASON_UNKNOWN
;
}
Override
Nullable
public
Object
getSelectionData
(
)
{
return
null
;
}
}
private
static
final
class
EncryptionKeyChunk
extends
DataChunk
{
private
byte
MonotonicNonNull
[
]
result
;
public
EncryptionKeyChunk
(
DataSource
dataSource
DataSpec
dataSpec
Format
trackFormat
int
trackSelectionReason
Nullable
Object
trackSelectionData
byte
[
]
scratchSpace
)
{
super
(
dataSource
dataSpec
C
.
DATA_TYPE_DRM
trackFormat
trackSelectionReason
trackSelectionData
scratchSpace
)
;
}
Override
protected
void
consume
(
byte
[
]
data
int
limit
)
{
result
=
Arrays
.
copyOf
(
data
limit
)
;
}
Nullable
public
byte
[
]
getResult
(
)
{
return
result
;
}
}
private
static
final
class
HlsMediaPlaylistSegmentIterator
extends
BaseMediaChunkIterator
{
private
final
HlsMediaPlaylist
playlist
;
private
final
long
startOfPlaylistInPeriodUs
;
public
HlsMediaPlaylistSegmentIterator
(
HlsMediaPlaylist
playlist
long
startOfPlaylistInPeriodUs
int
chunkIndex
)
{
super
(
chunkIndex
playlist
.
segments
.
size
(
)
-
1
)
;
this
.
playlist
=
playlist
;
this
.
startOfPlaylistInPeriodUs
=
startOfPlaylistInPeriodUs
;
}
Override
public
DataSpec
getDataSpec
(
)
{
checkInBounds
(
)
;
Segment
segment
=
playlist
.
segments
.
get
(
(
int
)
getCurrentIndex
(
)
)
;
Uri
chunkUri
=
UriUtil
.
resolveToUri
(
playlist
.
baseUri
segment
.
url
)
;
return
new
DataSpec
(
chunkUri
segment
.
byterangeOffset
segment
.
byterangeLength
null
)
;
}
Override
public
long
getChunkStartTimeUs
(
)
{
checkInBounds
(
)
;
Segment
segment
=
playlist
.
segments
.
get
(
(
int
)
getCurrentIndex
(
)
)
;
return
startOfPlaylistInPeriodUs
+
segment
.
relativeStartTimeUs
;
}
Override
public
long
getChunkEndTimeUs
(
)
{
checkInBounds
(
)
;
Segment
segment
=
playlist
.
segments
.
get
(
(
int
)
getCurrentIndex
(
)
)
;
long
segmentStartTimeInPeriodUs
=
startOfPlaylistInPeriodUs
+
segment
.
relativeStartTimeUs
;
return
segmentStartTimeInPeriodUs
+
segment
.
durationUs
;
}
}
}
