package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
;
import
android
.
os
.
Handler
;
import
android
.
os
.
SystemClock
;
import
android
.
view
.
Surface
;
import
androidx
.
annotation
.
CallSuper
;
import
androidx
.
annotation
.
IntDef
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
BaseRenderer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
ExoPlaybackException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
FormatHolder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
RendererCapabilities
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderCounters
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
DecoderInputBuffer
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
decoder
.
SimpleDecoder
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSession
.
DrmSessionException
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
DrmSessionManager
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
drm
.
ExoMediaCrypto
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TimedValueQueue
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
TraceUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
video
.
VideoRendererEventListener
.
EventDispatcher
;
import
java
.
lang
.
annotation
.
Documented
;
import
java
.
lang
.
annotation
.
Retention
;
import
java
.
lang
.
annotation
.
RetentionPolicy
;
public
abstract
class
SimpleDecoderVideoRenderer
extends
BaseRenderer
{
Documented
Retention
(
RetentionPolicy
.
SOURCE
)
IntDef
(
{
REINITIALIZATION_STATE_NONE
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
}
)
private
interface
ReinitializationState
{
}
private
static
final
int
REINITIALIZATION_STATE_NONE
=
0
;
private
static
final
int
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
=
1
;
private
static
final
int
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
=
2
;
private
final
long
allowedJoiningTimeMs
;
private
final
int
maxDroppedFramesToNotify
;
private
final
boolean
playClearSamplesWithoutKeys
;
private
final
EventDispatcher
eventDispatcher
;
private
final
TimedValueQueue
<
Format
>
formatQueue
;
private
final
DecoderInputBuffer
flagsOnlyBuffer
;
private
final
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
;
private
boolean
drmResourcesAcquired
;
private
Format
inputFormat
;
private
Format
outputFormat
;
private
SimpleDecoder
<
VideoDecoderInputBuffer
?
extends
VideoDecoderOutputBuffer
?
extends
VideoDecoderException
>
decoder
;
private
VideoDecoderInputBuffer
inputBuffer
;
private
VideoDecoderOutputBuffer
outputBuffer
;
Nullable
private
Surface
surface
;
Nullable
private
VideoDecoderOutputBufferRenderer
outputBufferRenderer
;
C
.
VideoOutputMode
private
int
outputMode
;
Nullable
private
DrmSession
<
ExoMediaCrypto
>
decoderDrmSession
;
Nullable
private
DrmSession
<
ExoMediaCrypto
>
sourceDrmSession
;
ReinitializationState
private
int
decoderReinitializationState
;
private
boolean
decoderReceivedBuffers
;
private
boolean
renderedFirstFrame
;
private
long
initialPositionUs
;
private
long
joiningDeadlineMs
;
private
boolean
waitingForKeys
;
private
boolean
waitingForFirstSampleInFormat
;
private
boolean
inputStreamEnded
;
private
boolean
outputStreamEnded
;
private
int
reportedWidth
;
private
int
reportedHeight
;
private
long
droppedFrameAccumulationStartTimeMs
;
private
int
droppedFrames
;
private
int
consecutiveDroppedFrameCount
;
private
int
buffersInCodecCount
;
private
long
lastRenderTimeUs
;
private
long
outputStreamOffsetUs
;
protected
DecoderCounters
decoderCounters
;
protected
SimpleDecoderVideoRenderer
(
long
allowedJoiningTimeMs
Nullable
Handler
eventHandler
Nullable
VideoRendererEventListener
eventListener
int
maxDroppedFramesToNotify
Nullable
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
boolean
playClearSamplesWithoutKeys
)
{
super
(
C
.
TRACK_TYPE_VIDEO
)
;
this
.
allowedJoiningTimeMs
=
allowedJoiningTimeMs
;
this
.
maxDroppedFramesToNotify
=
maxDroppedFramesToNotify
;
this
.
drmSessionManager
=
drmSessionManager
;
this
.
playClearSamplesWithoutKeys
=
playClearSamplesWithoutKeys
;
joiningDeadlineMs
=
C
.
TIME_UNSET
;
clearReportedVideoSize
(
)
;
formatQueue
=
new
TimedValueQueue
<
>
(
)
;
flagsOnlyBuffer
=
DecoderInputBuffer
.
newFlagsOnlyInstance
(
)
;
eventDispatcher
=
new
EventDispatcher
(
eventHandler
eventListener
)
;
decoderReinitializationState
=
REINITIALIZATION_STATE_NONE
;
outputMode
=
C
.
VIDEO_OUTPUT_MODE_NONE
;
}
Override
Capabilities
public
final
int
supportsFormat
(
Format
format
)
{
return
supportsFormatInternal
(
drmSessionManager
format
)
;
}
Override
public
void
render
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
{
if
(
outputStreamEnded
)
{
return
;
}
if
(
inputFormat
=
=
null
)
{
FormatHolder
formatHolder
=
getFormatHolder
(
)
;
flagsOnlyBuffer
.
clear
(
)
;
int
result
=
readSource
(
formatHolder
flagsOnlyBuffer
true
)
;
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
)
;
}
else
if
(
result
=
=
C
.
RESULT_BUFFER_READ
)
{
Assertions
.
checkState
(
flagsOnlyBuffer
.
isEndOfStream
(
)
)
;
inputStreamEnded
=
true
;
outputStreamEnded
=
true
;
return
;
}
else
{
return
;
}
}
maybeInitDecoder
(
)
;
if
(
decoder
!
=
null
)
{
try
{
TraceUtil
.
beginSection
(
"
drainAndFeed
"
)
;
while
(
drainOutputBuffer
(
positionUs
elapsedRealtimeUs
)
)
{
}
while
(
feedInputBuffer
(
)
)
{
}
TraceUtil
.
endSection
(
)
;
}
catch
(
VideoDecoderException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
decoderCounters
.
ensureUpdated
(
)
;
}
}
Override
public
boolean
isEnded
(
)
{
return
outputStreamEnded
;
}
Override
public
boolean
isReady
(
)
{
if
(
waitingForKeys
)
{
return
false
;
}
if
(
inputFormat
!
=
null
&
&
(
isSourceReady
(
)
|
|
outputBuffer
!
=
null
)
&
&
(
renderedFirstFrame
|
|
!
hasOutput
(
)
)
)
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
return
true
;
}
else
if
(
joiningDeadlineMs
=
=
C
.
TIME_UNSET
)
{
return
false
;
}
else
if
(
SystemClock
.
elapsedRealtime
(
)
<
joiningDeadlineMs
)
{
return
true
;
}
else
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
return
false
;
}
}
Override
protected
void
onEnabled
(
boolean
joining
)
throws
ExoPlaybackException
{
if
(
drmSessionManager
!
=
null
&
&
!
drmResourcesAcquired
)
{
drmResourcesAcquired
=
true
;
drmSessionManager
.
prepare
(
)
;
}
decoderCounters
=
new
DecoderCounters
(
)
;
eventDispatcher
.
enabled
(
decoderCounters
)
;
}
Override
protected
void
onPositionReset
(
long
positionUs
boolean
joining
)
throws
ExoPlaybackException
{
inputStreamEnded
=
false
;
outputStreamEnded
=
false
;
clearRenderedFirstFrame
(
)
;
initialPositionUs
=
C
.
TIME_UNSET
;
consecutiveDroppedFrameCount
=
0
;
if
(
decoder
!
=
null
)
{
flushDecoder
(
)
;
}
if
(
joining
)
{
setJoiningDeadlineMs
(
)
;
}
else
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
}
formatQueue
.
clear
(
)
;
}
Override
protected
void
onStarted
(
)
{
droppedFrames
=
0
;
droppedFrameAccumulationStartTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
lastRenderTimeUs
=
SystemClock
.
elapsedRealtime
(
)
*
1000
;
}
Override
protected
void
onStopped
(
)
{
joiningDeadlineMs
=
C
.
TIME_UNSET
;
maybeNotifyDroppedFrames
(
)
;
}
Override
protected
void
onDisabled
(
)
{
inputFormat
=
null
;
waitingForKeys
=
false
;
clearReportedVideoSize
(
)
;
clearRenderedFirstFrame
(
)
;
try
{
setSourceDrmSession
(
null
)
;
releaseDecoder
(
)
;
}
finally
{
eventDispatcher
.
disabled
(
decoderCounters
)
;
}
}
Override
protected
void
onReset
(
)
{
if
(
drmSessionManager
!
=
null
&
&
drmResourcesAcquired
)
{
drmResourcesAcquired
=
false
;
drmSessionManager
.
release
(
)
;
}
}
Override
protected
void
onStreamChanged
(
Format
[
]
formats
long
offsetUs
)
throws
ExoPlaybackException
{
outputStreamOffsetUs
=
offsetUs
;
super
.
onStreamChanged
(
formats
offsetUs
)
;
}
CallSuper
protected
void
onDecoderInitialized
(
String
name
long
initializedTimestampMs
long
initializationDurationMs
)
{
eventDispatcher
.
decoderInitialized
(
name
initializedTimestampMs
initializationDurationMs
)
;
}
CallSuper
protected
void
flushDecoder
(
)
throws
ExoPlaybackException
{
waitingForKeys
=
false
;
buffersInCodecCount
=
0
;
if
(
decoderReinitializationState
!
=
REINITIALIZATION_STATE_NONE
)
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
}
else
{
inputBuffer
=
null
;
if
(
outputBuffer
!
=
null
)
{
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
}
decoder
.
flush
(
)
;
decoderReceivedBuffers
=
false
;
}
}
CallSuper
protected
void
releaseDecoder
(
)
{
inputBuffer
=
null
;
outputBuffer
=
null
;
decoderReinitializationState
=
REINITIALIZATION_STATE_NONE
;
decoderReceivedBuffers
=
false
;
buffersInCodecCount
=
0
;
if
(
decoder
!
=
null
)
{
decoder
.
release
(
)
;
decoder
=
null
;
decoderCounters
.
decoderReleaseCount
+
+
;
}
setDecoderDrmSession
(
null
)
;
}
CallSuper
SuppressWarnings
(
"
unchecked
"
)
protected
void
onInputFormatChanged
(
FormatHolder
formatHolder
)
throws
ExoPlaybackException
{
waitingForFirstSampleInFormat
=
true
;
Format
newFormat
=
Assertions
.
checkNotNull
(
formatHolder
.
format
)
;
if
(
formatHolder
.
includesDrmSession
)
{
setSourceDrmSession
(
(
DrmSession
<
ExoMediaCrypto
>
)
formatHolder
.
drmSession
)
;
}
else
{
sourceDrmSession
=
getUpdatedSourceDrmSession
(
inputFormat
newFormat
drmSessionManager
sourceDrmSession
)
;
}
inputFormat
=
newFormat
;
if
(
sourceDrmSession
!
=
decoderDrmSession
)
{
if
(
decoderReceivedBuffers
)
{
decoderReinitializationState
=
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
;
}
else
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
}
}
eventDispatcher
.
inputFormatChanged
(
inputFormat
)
;
}
protected
void
onQueueInputBuffer
(
VideoDecoderInputBuffer
buffer
)
{
}
CallSuper
protected
void
onProcessedOutputBuffer
(
long
presentationTimeUs
)
{
buffersInCodecCount
-
-
;
}
protected
boolean
shouldDropOutputBuffer
(
long
earlyUs
long
elapsedRealtimeUs
)
{
return
isBufferLate
(
earlyUs
)
;
}
protected
boolean
shouldDropBuffersToKeyframe
(
long
earlyUs
long
elapsedRealtimeUs
)
{
return
isBufferVeryLate
(
earlyUs
)
;
}
protected
boolean
shouldForceRenderOutputBuffer
(
long
earlyUs
long
elapsedSinceLastRenderUs
)
{
return
isBufferLate
(
earlyUs
)
&
&
elapsedSinceLastRenderUs
>
100000
;
}
protected
void
skipOutputBuffer
(
VideoDecoderOutputBuffer
outputBuffer
)
{
decoderCounters
.
skippedOutputBufferCount
+
+
;
outputBuffer
.
release
(
)
;
}
protected
void
dropOutputBuffer
(
VideoDecoderOutputBuffer
outputBuffer
)
{
updateDroppedBufferCounters
(
1
)
;
outputBuffer
.
release
(
)
;
}
protected
boolean
maybeDropBuffersToKeyframe
(
long
positionUs
)
throws
ExoPlaybackException
{
int
droppedSourceBufferCount
=
skipSource
(
positionUs
)
;
if
(
droppedSourceBufferCount
=
=
0
)
{
return
false
;
}
decoderCounters
.
droppedToKeyframeCount
+
+
;
updateDroppedBufferCounters
(
buffersInCodecCount
+
droppedSourceBufferCount
)
;
flushDecoder
(
)
;
return
true
;
}
protected
void
updateDroppedBufferCounters
(
int
droppedBufferCount
)
{
decoderCounters
.
droppedBufferCount
+
=
droppedBufferCount
;
droppedFrames
+
=
droppedBufferCount
;
consecutiveDroppedFrameCount
+
=
droppedBufferCount
;
decoderCounters
.
maxConsecutiveDroppedBufferCount
=
Math
.
max
(
consecutiveDroppedFrameCount
decoderCounters
.
maxConsecutiveDroppedBufferCount
)
;
if
(
maxDroppedFramesToNotify
>
0
&
&
droppedFrames
>
=
maxDroppedFramesToNotify
)
{
maybeNotifyDroppedFrames
(
)
;
}
}
Capabilities
protected
abstract
int
supportsFormatInternal
(
Nullable
DrmSessionManager
<
ExoMediaCrypto
>
drmSessionManager
Format
format
)
;
protected
abstract
SimpleDecoder
<
VideoDecoderInputBuffer
?
extends
VideoDecoderOutputBuffer
?
extends
VideoDecoderException
>
createDecoder
(
Format
format
Nullable
ExoMediaCrypto
mediaCrypto
)
throws
VideoDecoderException
;
protected
void
renderOutputBuffer
(
VideoDecoderOutputBuffer
outputBuffer
long
presentationTimeUs
Format
outputFormat
)
throws
VideoDecoderException
{
lastRenderTimeUs
=
C
.
msToUs
(
SystemClock
.
elapsedRealtime
(
)
*
1000
)
;
int
bufferMode
=
outputBuffer
.
mode
;
boolean
renderSurface
=
bufferMode
=
=
C
.
VIDEO_OUTPUT_MODE_SURFACE_YUV
&
&
surface
!
=
null
;
boolean
renderYuv
=
bufferMode
=
=
C
.
VIDEO_OUTPUT_MODE_YUV
&
&
outputBufferRenderer
!
=
null
;
if
(
!
renderYuv
&
&
!
renderSurface
)
{
dropOutputBuffer
(
outputBuffer
)
;
}
else
{
maybeNotifyVideoSizeChanged
(
outputBuffer
.
width
outputBuffer
.
height
)
;
if
(
renderYuv
)
{
outputBufferRenderer
.
setOutputBuffer
(
outputBuffer
)
;
}
else
{
renderOutputBufferToSurface
(
outputBuffer
surface
)
;
}
consecutiveDroppedFrameCount
=
0
;
decoderCounters
.
renderedOutputBufferCount
+
+
;
maybeNotifyRenderedFirstFrame
(
)
;
}
}
protected
abstract
void
renderOutputBufferToSurface
(
VideoDecoderOutputBuffer
outputBuffer
Surface
surface
)
throws
VideoDecoderException
;
protected
final
void
setOutputSurface
(
Nullable
Surface
surface
)
{
if
(
this
.
surface
!
=
surface
)
{
this
.
surface
=
surface
;
if
(
surface
!
=
null
)
{
outputBufferRenderer
=
null
;
outputMode
=
C
.
VIDEO_OUTPUT_MODE_SURFACE_YUV
;
if
(
decoder
!
=
null
)
{
setDecoderOutputMode
(
outputMode
)
;
}
onOutputChanged
(
)
;
}
else
{
outputMode
=
C
.
VIDEO_OUTPUT_MODE_NONE
;
onOutputRemoved
(
)
;
}
}
else
if
(
surface
!
=
null
)
{
onOutputReset
(
)
;
}
}
protected
final
void
setOutputBufferRenderer
(
Nullable
VideoDecoderOutputBufferRenderer
outputBufferRenderer
)
{
if
(
this
.
outputBufferRenderer
!
=
outputBufferRenderer
)
{
this
.
outputBufferRenderer
=
outputBufferRenderer
;
if
(
outputBufferRenderer
!
=
null
)
{
surface
=
null
;
outputMode
=
C
.
VIDEO_OUTPUT_MODE_YUV
;
if
(
decoder
!
=
null
)
{
setDecoderOutputMode
(
outputMode
)
;
}
onOutputChanged
(
)
;
}
else
{
outputMode
=
C
.
VIDEO_OUTPUT_MODE_NONE
;
onOutputRemoved
(
)
;
}
}
else
if
(
outputBufferRenderer
!
=
null
)
{
onOutputReset
(
)
;
}
}
protected
abstract
void
setDecoderOutputMode
(
C
.
VideoOutputMode
int
outputMode
)
;
private
void
setSourceDrmSession
(
Nullable
DrmSession
<
ExoMediaCrypto
>
session
)
{
DrmSession
.
replaceSession
(
sourceDrmSession
session
)
;
sourceDrmSession
=
session
;
}
private
void
setDecoderDrmSession
(
Nullable
DrmSession
<
ExoMediaCrypto
>
session
)
{
DrmSession
.
replaceSession
(
decoderDrmSession
session
)
;
decoderDrmSession
=
session
;
}
private
void
maybeInitDecoder
(
)
throws
ExoPlaybackException
{
if
(
decoder
!
=
null
)
{
return
;
}
setDecoderDrmSession
(
sourceDrmSession
)
;
ExoMediaCrypto
mediaCrypto
=
null
;
if
(
decoderDrmSession
!
=
null
)
{
mediaCrypto
=
decoderDrmSession
.
getMediaCrypto
(
)
;
if
(
mediaCrypto
=
=
null
)
{
DrmSessionException
drmError
=
decoderDrmSession
.
getError
(
)
;
if
(
drmError
!
=
null
)
{
}
else
{
return
;
}
}
}
try
{
long
decoderInitializingTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
decoder
=
createDecoder
(
inputFormat
mediaCrypto
)
;
setDecoderOutputMode
(
outputMode
)
;
long
decoderInitializedTimestamp
=
SystemClock
.
elapsedRealtime
(
)
;
onDecoderInitialized
(
decoder
.
getName
(
)
decoderInitializedTimestamp
decoderInitializedTimestamp
-
decoderInitializingTimestamp
)
;
decoderCounters
.
decoderInitCount
+
+
;
}
catch
(
VideoDecoderException
e
)
{
throw
createRendererException
(
e
inputFormat
)
;
}
}
private
boolean
feedInputBuffer
(
)
throws
VideoDecoderException
ExoPlaybackException
{
if
(
decoder
=
=
null
|
|
decoderReinitializationState
=
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
|
|
inputStreamEnded
)
{
return
false
;
}
if
(
inputBuffer
=
=
null
)
{
inputBuffer
=
decoder
.
dequeueInputBuffer
(
)
;
if
(
inputBuffer
=
=
null
)
{
return
false
;
}
}
if
(
decoderReinitializationState
=
=
REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM
)
{
inputBuffer
.
setFlags
(
C
.
BUFFER_FLAG_END_OF_STREAM
)
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
inputBuffer
=
null
;
decoderReinitializationState
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
;
return
false
;
}
int
result
;
FormatHolder
formatHolder
=
getFormatHolder
(
)
;
if
(
waitingForKeys
)
{
result
=
C
.
RESULT_BUFFER_READ
;
}
else
{
result
=
readSource
(
formatHolder
inputBuffer
false
)
;
}
if
(
result
=
=
C
.
RESULT_NOTHING_READ
)
{
return
false
;
}
if
(
result
=
=
C
.
RESULT_FORMAT_READ
)
{
onInputFormatChanged
(
formatHolder
)
;
return
true
;
}
if
(
inputBuffer
.
isEndOfStream
(
)
)
{
inputStreamEnded
=
true
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
inputBuffer
=
null
;
return
false
;
}
boolean
bufferEncrypted
=
inputBuffer
.
isEncrypted
(
)
;
waitingForKeys
=
shouldWaitForKeys
(
bufferEncrypted
)
;
if
(
waitingForKeys
)
{
return
false
;
}
if
(
waitingForFirstSampleInFormat
)
{
formatQueue
.
add
(
inputBuffer
.
timeUs
inputFormat
)
;
waitingForFirstSampleInFormat
=
false
;
}
inputBuffer
.
flip
(
)
;
inputBuffer
.
colorInfo
=
inputFormat
.
colorInfo
;
onQueueInputBuffer
(
inputBuffer
)
;
decoder
.
queueInputBuffer
(
inputBuffer
)
;
buffersInCodecCount
+
+
;
decoderReceivedBuffers
=
true
;
decoderCounters
.
inputBufferCount
+
+
;
inputBuffer
=
null
;
return
true
;
}
private
boolean
drainOutputBuffer
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
VideoDecoderException
{
if
(
outputBuffer
=
=
null
)
{
outputBuffer
=
decoder
.
dequeueOutputBuffer
(
)
;
if
(
outputBuffer
=
=
null
)
{
return
false
;
}
decoderCounters
.
skippedOutputBufferCount
+
=
outputBuffer
.
skippedOutputBufferCount
;
buffersInCodecCount
-
=
outputBuffer
.
skippedOutputBufferCount
;
}
if
(
outputBuffer
.
isEndOfStream
(
)
)
{
if
(
decoderReinitializationState
=
=
REINITIALIZATION_STATE_WAIT_END_OF_STREAM
)
{
releaseDecoder
(
)
;
maybeInitDecoder
(
)
;
}
else
{
outputBuffer
.
release
(
)
;
outputBuffer
=
null
;
outputStreamEnded
=
true
;
}
return
false
;
}
boolean
processedOutputBuffer
=
processOutputBuffer
(
positionUs
elapsedRealtimeUs
)
;
if
(
processedOutputBuffer
)
{
onProcessedOutputBuffer
(
outputBuffer
.
timeUs
)
;
outputBuffer
=
null
;
}
return
processedOutputBuffer
;
}
private
boolean
processOutputBuffer
(
long
positionUs
long
elapsedRealtimeUs
)
throws
ExoPlaybackException
VideoDecoderException
{
if
(
initialPositionUs
=
=
C
.
TIME_UNSET
)
{
initialPositionUs
=
positionUs
;
}
long
earlyUs
=
outputBuffer
.
timeUs
-
positionUs
;
if
(
!
hasOutput
(
)
)
{
if
(
isBufferLate
(
earlyUs
)
)
{
skipOutputBuffer
(
outputBuffer
)
;
return
true
;
}
return
false
;
}
long
presentationTimeUs
=
outputBuffer
.
timeUs
-
outputStreamOffsetUs
;
Format
format
=
formatQueue
.
pollFloor
(
presentationTimeUs
)
;
if
(
format
!
=
null
)
{
outputFormat
=
format
;
}
long
elapsedRealtimeNowUs
=
SystemClock
.
elapsedRealtime
(
)
*
1000
;
boolean
isStarted
=
getState
(
)
=
=
STATE_STARTED
;
if
(
!
renderedFirstFrame
|
|
(
isStarted
&
&
shouldForceRenderOutputBuffer
(
earlyUs
elapsedRealtimeNowUs
-
lastRenderTimeUs
)
)
)
{
renderOutputBuffer
(
outputBuffer
presentationTimeUs
outputFormat
)
;
return
true
;
}
if
(
!
isStarted
|
|
positionUs
=
=
initialPositionUs
)
{
return
false
;
}
if
(
shouldDropBuffersToKeyframe
(
earlyUs
elapsedRealtimeUs
)
&
&
maybeDropBuffersToKeyframe
(
positionUs
)
)
{
return
false
;
}
else
if
(
shouldDropOutputBuffer
(
earlyUs
elapsedRealtimeUs
)
)
{
dropOutputBuffer
(
outputBuffer
)
;
return
true
;
}
if
(
earlyUs
<
30000
)
{
renderOutputBuffer
(
outputBuffer
presentationTimeUs
outputFormat
)
;
return
true
;
}
return
false
;
}
private
boolean
hasOutput
(
)
{
return
outputMode
!
=
C
.
VIDEO_OUTPUT_MODE_NONE
;
}
private
void
onOutputChanged
(
)
{
maybeRenotifyVideoSizeChanged
(
)
;
clearRenderedFirstFrame
(
)
;
if
(
getState
(
)
=
=
STATE_STARTED
)
{
setJoiningDeadlineMs
(
)
;
}
}
private
void
onOutputRemoved
(
)
{
clearReportedVideoSize
(
)
;
clearRenderedFirstFrame
(
)
;
}
private
void
onOutputReset
(
)
{
maybeRenotifyVideoSizeChanged
(
)
;
maybeRenotifyRenderedFirstFrame
(
)
;
}
private
boolean
shouldWaitForKeys
(
boolean
bufferEncrypted
)
throws
ExoPlaybackException
{
if
(
decoderDrmSession
=
=
null
|
|
(
!
bufferEncrypted
&
&
(
playClearSamplesWithoutKeys
|
|
decoderDrmSession
.
playClearSamplesWithoutKeys
(
)
)
)
)
{
return
false
;
}
DrmSession
.
State
int
drmSessionState
=
decoderDrmSession
.
getState
(
)
;
if
(
drmSessionState
=
=
DrmSession
.
STATE_ERROR
)
{
throw
createRendererException
(
decoderDrmSession
.
getError
(
)
inputFormat
)
;
}
return
drmSessionState
!
=
DrmSession
.
STATE_OPENED_WITH_KEYS
;
}
private
void
setJoiningDeadlineMs
(
)
{
joiningDeadlineMs
=
allowedJoiningTimeMs
>
0
?
(
SystemClock
.
elapsedRealtime
(
)
+
allowedJoiningTimeMs
)
:
C
.
TIME_UNSET
;
}
private
void
clearRenderedFirstFrame
(
)
{
renderedFirstFrame
=
false
;
}
private
void
maybeNotifyRenderedFirstFrame
(
)
{
if
(
!
renderedFirstFrame
)
{
renderedFirstFrame
=
true
;
eventDispatcher
.
renderedFirstFrame
(
surface
)
;
}
}
private
void
maybeRenotifyRenderedFirstFrame
(
)
{
if
(
renderedFirstFrame
)
{
eventDispatcher
.
renderedFirstFrame
(
surface
)
;
}
}
private
void
clearReportedVideoSize
(
)
{
reportedWidth
=
Format
.
NO_VALUE
;
reportedHeight
=
Format
.
NO_VALUE
;
}
private
void
maybeNotifyVideoSizeChanged
(
int
width
int
height
)
{
if
(
reportedWidth
!
=
width
|
|
reportedHeight
!
=
height
)
{
reportedWidth
=
width
;
reportedHeight
=
height
;
eventDispatcher
.
videoSizeChanged
(
width
height
0
1
)
;
}
}
private
void
maybeRenotifyVideoSizeChanged
(
)
{
if
(
reportedWidth
!
=
Format
.
NO_VALUE
|
|
reportedHeight
!
=
Format
.
NO_VALUE
)
{
eventDispatcher
.
videoSizeChanged
(
reportedWidth
reportedHeight
0
1
)
;
}
}
private
void
maybeNotifyDroppedFrames
(
)
{
if
(
droppedFrames
>
0
)
{
long
now
=
SystemClock
.
elapsedRealtime
(
)
;
long
elapsedMs
=
now
-
droppedFrameAccumulationStartTimeMs
;
eventDispatcher
.
droppedFrames
(
droppedFrames
elapsedMs
)
;
droppedFrames
=
0
;
droppedFrameAccumulationStartTimeMs
=
now
;
}
}
private
static
boolean
isBufferLate
(
long
earlyUs
)
{
return
earlyUs
<
-
30000
;
}
private
static
boolean
isBufferVeryLate
(
long
earlyUs
)
{
return
earlyUs
<
-
500000
;
}
}
