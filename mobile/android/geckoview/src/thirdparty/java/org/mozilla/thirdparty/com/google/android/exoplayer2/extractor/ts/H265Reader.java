package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
Format
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ExtractorOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
TrackOutput
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
ts
.
TsPayloadReader
.
TrackIdGenerator
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
MimeTypes
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
NalUnitUtil
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableNalUnitBitArray
;
import
java
.
util
.
Collections
;
public
final
class
H265Reader
implements
ElementaryStreamReader
{
private
static
final
String
TAG
=
"
H265Reader
"
;
private
static
final
int
RASL_R
=
9
;
private
static
final
int
BLA_W_LP
=
16
;
private
static
final
int
CRA_NUT
=
21
;
private
static
final
int
VPS_NUT
=
32
;
private
static
final
int
SPS_NUT
=
33
;
private
static
final
int
PPS_NUT
=
34
;
private
static
final
int
PREFIX_SEI_NUT
=
39
;
private
static
final
int
SUFFIX_SEI_NUT
=
40
;
private
final
SeiReader
seiReader
;
private
String
formatId
;
private
TrackOutput
output
;
private
SampleReader
sampleReader
;
private
boolean
hasOutputFormat
;
private
final
boolean
[
]
prefixFlags
;
private
final
NalUnitTargetBuffer
vps
;
private
final
NalUnitTargetBuffer
sps
;
private
final
NalUnitTargetBuffer
pps
;
private
final
NalUnitTargetBuffer
prefixSei
;
private
final
NalUnitTargetBuffer
suffixSei
;
private
long
totalBytesWritten
;
private
long
pesTimeUs
;
private
final
ParsableByteArray
seiWrapper
;
public
H265Reader
(
SeiReader
seiReader
)
{
this
.
seiReader
=
seiReader
;
prefixFlags
=
new
boolean
[
3
]
;
vps
=
new
NalUnitTargetBuffer
(
VPS_NUT
128
)
;
sps
=
new
NalUnitTargetBuffer
(
SPS_NUT
128
)
;
pps
=
new
NalUnitTargetBuffer
(
PPS_NUT
128
)
;
prefixSei
=
new
NalUnitTargetBuffer
(
PREFIX_SEI_NUT
128
)
;
suffixSei
=
new
NalUnitTargetBuffer
(
SUFFIX_SEI_NUT
128
)
;
seiWrapper
=
new
ParsableByteArray
(
)
;
}
Override
public
void
seek
(
)
{
NalUnitUtil
.
clearPrefixFlags
(
prefixFlags
)
;
vps
.
reset
(
)
;
sps
.
reset
(
)
;
pps
.
reset
(
)
;
prefixSei
.
reset
(
)
;
suffixSei
.
reset
(
)
;
sampleReader
.
reset
(
)
;
totalBytesWritten
=
0
;
}
Override
public
void
createTracks
(
ExtractorOutput
extractorOutput
TrackIdGenerator
idGenerator
)
{
idGenerator
.
generateNewId
(
)
;
formatId
=
idGenerator
.
getFormatId
(
)
;
output
=
extractorOutput
.
track
(
idGenerator
.
getTrackId
(
)
C
.
TRACK_TYPE_VIDEO
)
;
sampleReader
=
new
SampleReader
(
output
)
;
seiReader
.
createTracks
(
extractorOutput
idGenerator
)
;
}
Override
public
void
packetStarted
(
long
pesTimeUs
boolean
dataAlignmentIndicator
)
{
this
.
pesTimeUs
=
pesTimeUs
;
}
Override
public
void
consume
(
ParsableByteArray
data
)
{
while
(
data
.
bytesLeft
(
)
>
0
)
{
int
offset
=
data
.
getPosition
(
)
;
int
limit
=
data
.
limit
(
)
;
byte
[
]
dataArray
=
data
.
data
;
totalBytesWritten
+
=
data
.
bytesLeft
(
)
;
output
.
sampleData
(
data
data
.
bytesLeft
(
)
)
;
while
(
offset
<
limit
)
{
int
nalUnitOffset
=
NalUnitUtil
.
findNalUnit
(
dataArray
offset
limit
prefixFlags
)
;
if
(
nalUnitOffset
=
=
limit
)
{
nalUnitData
(
dataArray
offset
limit
)
;
return
;
}
int
nalUnitType
=
NalUnitUtil
.
getH265NalUnitType
(
dataArray
nalUnitOffset
)
;
int
lengthToNalUnit
=
nalUnitOffset
-
offset
;
if
(
lengthToNalUnit
>
0
)
{
nalUnitData
(
dataArray
offset
nalUnitOffset
)
;
}
int
bytesWrittenPastPosition
=
limit
-
nalUnitOffset
;
long
absolutePosition
=
totalBytesWritten
-
bytesWrittenPastPosition
;
endNalUnit
(
absolutePosition
bytesWrittenPastPosition
lengthToNalUnit
<
0
?
-
lengthToNalUnit
:
0
pesTimeUs
)
;
startNalUnit
(
absolutePosition
bytesWrittenPastPosition
nalUnitType
pesTimeUs
)
;
offset
=
nalUnitOffset
+
3
;
}
}
}
Override
public
void
packetFinished
(
)
{
}
private
void
startNalUnit
(
long
position
int
offset
int
nalUnitType
long
pesTimeUs
)
{
if
(
hasOutputFormat
)
{
sampleReader
.
startNalUnit
(
position
offset
nalUnitType
pesTimeUs
)
;
}
else
{
vps
.
startNalUnit
(
nalUnitType
)
;
sps
.
startNalUnit
(
nalUnitType
)
;
pps
.
startNalUnit
(
nalUnitType
)
;
}
prefixSei
.
startNalUnit
(
nalUnitType
)
;
suffixSei
.
startNalUnit
(
nalUnitType
)
;
}
private
void
nalUnitData
(
byte
[
]
dataArray
int
offset
int
limit
)
{
if
(
hasOutputFormat
)
{
sampleReader
.
readNalUnitData
(
dataArray
offset
limit
)
;
}
else
{
vps
.
appendToNalUnit
(
dataArray
offset
limit
)
;
sps
.
appendToNalUnit
(
dataArray
offset
limit
)
;
pps
.
appendToNalUnit
(
dataArray
offset
limit
)
;
}
prefixSei
.
appendToNalUnit
(
dataArray
offset
limit
)
;
suffixSei
.
appendToNalUnit
(
dataArray
offset
limit
)
;
}
private
void
endNalUnit
(
long
position
int
offset
int
discardPadding
long
pesTimeUs
)
{
if
(
hasOutputFormat
)
{
sampleReader
.
endNalUnit
(
position
offset
)
;
}
else
{
vps
.
endNalUnit
(
discardPadding
)
;
sps
.
endNalUnit
(
discardPadding
)
;
pps
.
endNalUnit
(
discardPadding
)
;
if
(
vps
.
isCompleted
(
)
&
&
sps
.
isCompleted
(
)
&
&
pps
.
isCompleted
(
)
)
{
output
.
format
(
parseMediaFormat
(
formatId
vps
sps
pps
)
)
;
hasOutputFormat
=
true
;
}
}
if
(
prefixSei
.
endNalUnit
(
discardPadding
)
)
{
int
unescapedLength
=
NalUnitUtil
.
unescapeStream
(
prefixSei
.
nalData
prefixSei
.
nalLength
)
;
seiWrapper
.
reset
(
prefixSei
.
nalData
unescapedLength
)
;
seiWrapper
.
skipBytes
(
5
)
;
seiReader
.
consume
(
pesTimeUs
seiWrapper
)
;
}
if
(
suffixSei
.
endNalUnit
(
discardPadding
)
)
{
int
unescapedLength
=
NalUnitUtil
.
unescapeStream
(
suffixSei
.
nalData
suffixSei
.
nalLength
)
;
seiWrapper
.
reset
(
suffixSei
.
nalData
unescapedLength
)
;
seiWrapper
.
skipBytes
(
5
)
;
seiReader
.
consume
(
pesTimeUs
seiWrapper
)
;
}
}
private
static
Format
parseMediaFormat
(
String
formatId
NalUnitTargetBuffer
vps
NalUnitTargetBuffer
sps
NalUnitTargetBuffer
pps
)
{
byte
[
]
csd
=
new
byte
[
vps
.
nalLength
+
sps
.
nalLength
+
pps
.
nalLength
]
;
System
.
arraycopy
(
vps
.
nalData
0
csd
0
vps
.
nalLength
)
;
System
.
arraycopy
(
sps
.
nalData
0
csd
vps
.
nalLength
sps
.
nalLength
)
;
System
.
arraycopy
(
pps
.
nalData
0
csd
vps
.
nalLength
+
sps
.
nalLength
pps
.
nalLength
)
;
ParsableNalUnitBitArray
bitArray
=
new
ParsableNalUnitBitArray
(
sps
.
nalData
0
sps
.
nalLength
)
;
bitArray
.
skipBits
(
40
+
4
)
;
int
maxSubLayersMinus1
=
bitArray
.
readBits
(
3
)
;
bitArray
.
skipBits
(
1
)
;
bitArray
.
skipBits
(
88
)
;
bitArray
.
skipBits
(
8
)
;
int
toSkip
=
0
;
for
(
int
i
=
0
;
i
<
maxSubLayersMinus1
;
i
+
+
)
{
if
(
bitArray
.
readBit
(
)
)
{
toSkip
+
=
89
;
}
if
(
bitArray
.
readBit
(
)
)
{
toSkip
+
=
8
;
}
}
bitArray
.
skipBits
(
toSkip
)
;
if
(
maxSubLayersMinus1
>
0
)
{
bitArray
.
skipBits
(
2
*
(
8
-
maxSubLayersMinus1
)
)
;
}
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
chromaFormatIdc
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
if
(
chromaFormatIdc
=
=
3
)
{
bitArray
.
skipBits
(
1
)
;
}
int
picWidthInLumaSamples
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
picHeightInLumaSamples
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
if
(
bitArray
.
readBit
(
)
)
{
int
confWinLeftOffset
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
confWinRightOffset
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
confWinTopOffset
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
confWinBottomOffset
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
subWidthC
=
chromaFormatIdc
=
=
1
|
|
chromaFormatIdc
=
=
2
?
2
:
1
;
int
subHeightC
=
chromaFormatIdc
=
=
1
?
2
:
1
;
picWidthInLumaSamples
-
=
subWidthC
*
(
confWinLeftOffset
+
confWinRightOffset
)
;
picHeightInLumaSamples
-
=
subHeightC
*
(
confWinTopOffset
+
confWinBottomOffset
)
;
}
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
int
log2MaxPicOrderCntLsbMinus4
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
for
(
int
i
=
bitArray
.
readBit
(
)
?
0
:
maxSubLayersMinus1
;
i
<
=
maxSubLayersMinus1
;
i
+
+
)
{
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
}
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
boolean
scalingListEnabled
=
bitArray
.
readBit
(
)
;
if
(
scalingListEnabled
&
&
bitArray
.
readBit
(
)
)
{
skipScalingList
(
bitArray
)
;
}
bitArray
.
skipBits
(
2
)
;
if
(
bitArray
.
readBit
(
)
)
{
bitArray
.
skipBits
(
8
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
skipBits
(
1
)
;
}
skipShortTermRefPicSets
(
bitArray
)
;
if
(
bitArray
.
readBit
(
)
)
{
for
(
int
i
=
0
;
i
<
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
i
+
+
)
{
int
ltRefPicPocLsbSpsLength
=
log2MaxPicOrderCntLsbMinus4
+
4
;
bitArray
.
skipBits
(
ltRefPicPocLsbSpsLength
+
1
)
;
}
}
bitArray
.
skipBits
(
2
)
;
float
pixelWidthHeightRatio
=
1
;
if
(
bitArray
.
readBit
(
)
)
{
if
(
bitArray
.
readBit
(
)
)
{
int
aspectRatioIdc
=
bitArray
.
readBits
(
8
)
;
if
(
aspectRatioIdc
=
=
NalUnitUtil
.
EXTENDED_SAR
)
{
int
sarWidth
=
bitArray
.
readBits
(
16
)
;
int
sarHeight
=
bitArray
.
readBits
(
16
)
;
if
(
sarWidth
!
=
0
&
&
sarHeight
!
=
0
)
{
pixelWidthHeightRatio
=
(
float
)
sarWidth
/
sarHeight
;
}
}
else
if
(
aspectRatioIdc
<
NalUnitUtil
.
ASPECT_RATIO_IDC_VALUES
.
length
)
{
pixelWidthHeightRatio
=
NalUnitUtil
.
ASPECT_RATIO_IDC_VALUES
[
aspectRatioIdc
]
;
}
else
{
Log
.
w
(
TAG
"
Unexpected
aspect_ratio_idc
value
:
"
+
aspectRatioIdc
)
;
}
}
}
return
Format
.
createVideoSampleFormat
(
formatId
MimeTypes
.
VIDEO_H265
null
Format
.
NO_VALUE
Format
.
NO_VALUE
picWidthInLumaSamples
picHeightInLumaSamples
Format
.
NO_VALUE
Collections
.
singletonList
(
csd
)
Format
.
NO_VALUE
pixelWidthHeightRatio
null
)
;
}
private
static
void
skipScalingList
(
ParsableNalUnitBitArray
bitArray
)
{
for
(
int
sizeId
=
0
;
sizeId
<
4
;
sizeId
+
+
)
{
for
(
int
matrixId
=
0
;
matrixId
<
6
;
matrixId
+
=
sizeId
=
=
3
?
3
:
1
)
{
if
(
!
bitArray
.
readBit
(
)
)
{
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
}
else
{
int
coefNum
=
Math
.
min
(
64
1
<
<
(
4
+
(
sizeId
<
<
1
)
)
)
;
if
(
sizeId
>
1
)
{
bitArray
.
readSignedExpGolombCodedInt
(
)
;
}
for
(
int
i
=
0
;
i
<
coefNum
;
i
+
+
)
{
bitArray
.
readSignedExpGolombCodedInt
(
)
;
}
}
}
}
}
private
static
void
skipShortTermRefPicSets
(
ParsableNalUnitBitArray
bitArray
)
{
int
numShortTermRefPicSets
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
boolean
interRefPicSetPredictionFlag
=
false
;
int
numNegativePics
;
int
numPositivePics
;
int
previousNumDeltaPocs
=
0
;
for
(
int
stRpsIdx
=
0
;
stRpsIdx
<
numShortTermRefPicSets
;
stRpsIdx
+
+
)
{
if
(
stRpsIdx
!
=
0
)
{
interRefPicSetPredictionFlag
=
bitArray
.
readBit
(
)
;
}
if
(
interRefPicSetPredictionFlag
)
{
bitArray
.
skipBits
(
1
)
;
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
for
(
int
j
=
0
;
j
<
=
previousNumDeltaPocs
;
j
+
+
)
{
if
(
bitArray
.
readBit
(
)
)
{
bitArray
.
skipBits
(
1
)
;
}
}
}
else
{
numNegativePics
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
numPositivePics
=
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
previousNumDeltaPocs
=
numNegativePics
+
numPositivePics
;
for
(
int
i
=
0
;
i
<
numNegativePics
;
i
+
+
)
{
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
skipBits
(
1
)
;
}
for
(
int
i
=
0
;
i
<
numPositivePics
;
i
+
+
)
{
bitArray
.
readUnsignedExpGolombCodedInt
(
)
;
bitArray
.
skipBits
(
1
)
;
}
}
}
}
private
static
final
class
SampleReader
{
private
static
final
int
FIRST_SLICE_FLAG_OFFSET
=
2
;
private
final
TrackOutput
output
;
private
long
nalUnitStartPosition
;
private
boolean
nalUnitHasKeyframeData
;
private
int
nalUnitBytesRead
;
private
long
nalUnitTimeUs
;
private
boolean
lookingForFirstSliceFlag
;
private
boolean
isFirstSlice
;
private
boolean
isFirstParameterSet
;
private
boolean
readingSample
;
private
boolean
writingParameterSets
;
private
long
samplePosition
;
private
long
sampleTimeUs
;
private
boolean
sampleIsKeyframe
;
public
SampleReader
(
TrackOutput
output
)
{
this
.
output
=
output
;
}
public
void
reset
(
)
{
lookingForFirstSliceFlag
=
false
;
isFirstSlice
=
false
;
isFirstParameterSet
=
false
;
readingSample
=
false
;
writingParameterSets
=
false
;
}
public
void
startNalUnit
(
long
position
int
offset
int
nalUnitType
long
pesTimeUs
)
{
isFirstSlice
=
false
;
isFirstParameterSet
=
false
;
nalUnitTimeUs
=
pesTimeUs
;
nalUnitBytesRead
=
0
;
nalUnitStartPosition
=
position
;
if
(
nalUnitType
>
=
VPS_NUT
)
{
if
(
!
writingParameterSets
&
&
readingSample
)
{
outputSample
(
offset
)
;
readingSample
=
false
;
}
if
(
nalUnitType
<
=
PPS_NUT
)
{
isFirstParameterSet
=
!
writingParameterSets
;
writingParameterSets
=
true
;
}
}
nalUnitHasKeyframeData
=
(
nalUnitType
>
=
BLA_W_LP
&
&
nalUnitType
<
=
CRA_NUT
)
;
lookingForFirstSliceFlag
=
nalUnitHasKeyframeData
|
|
nalUnitType
<
=
RASL_R
;
}
public
void
readNalUnitData
(
byte
[
]
data
int
offset
int
limit
)
{
if
(
lookingForFirstSliceFlag
)
{
int
headerOffset
=
offset
+
FIRST_SLICE_FLAG_OFFSET
-
nalUnitBytesRead
;
if
(
headerOffset
<
limit
)
{
isFirstSlice
=
(
data
[
headerOffset
]
&
0x80
)
!
=
0
;
lookingForFirstSliceFlag
=
false
;
}
else
{
nalUnitBytesRead
+
=
limit
-
offset
;
}
}
}
public
void
endNalUnit
(
long
position
int
offset
)
{
if
(
writingParameterSets
&
&
isFirstSlice
)
{
sampleIsKeyframe
=
nalUnitHasKeyframeData
;
writingParameterSets
=
false
;
}
else
if
(
isFirstParameterSet
|
|
isFirstSlice
)
{
if
(
readingSample
)
{
int
nalUnitLength
=
(
int
)
(
position
-
nalUnitStartPosition
)
;
outputSample
(
offset
+
nalUnitLength
)
;
}
samplePosition
=
nalUnitStartPosition
;
sampleTimeUs
=
nalUnitTimeUs
;
readingSample
=
true
;
sampleIsKeyframe
=
nalUnitHasKeyframeData
;
}
}
private
void
outputSample
(
int
offset
)
{
C
.
BufferFlags
int
flags
=
sampleIsKeyframe
?
C
.
BUFFER_FLAG_KEY_FRAME
:
0
;
int
size
=
(
int
)
(
nalUnitStartPosition
-
samplePosition
)
;
output
.
sampleMetadata
(
sampleTimeUs
flags
size
offset
null
)
;
}
}
}
