package
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
mp3
;
import
androidx
.
annotation
.
Nullable
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
C
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
MpegAudioHeader
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
extractor
.
SeekPoint
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Assertions
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Log
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
ParsableByteArray
;
import
org
.
mozilla
.
thirdparty
.
com
.
google
.
android
.
exoplayer2
.
util
.
Util
;
final
class
XingSeeker
implements
Seeker
{
private
static
final
String
TAG
=
"
XingSeeker
"
;
public
static
Nullable
XingSeeker
create
(
long
inputLength
long
position
MpegAudioHeader
mpegAudioHeader
ParsableByteArray
frame
)
{
int
samplesPerFrame
=
mpegAudioHeader
.
samplesPerFrame
;
int
sampleRate
=
mpegAudioHeader
.
sampleRate
;
int
flags
=
frame
.
readInt
(
)
;
int
frameCount
;
if
(
(
flags
&
0x01
)
!
=
0x01
|
|
(
frameCount
=
frame
.
readUnsignedIntToInt
(
)
)
=
=
0
)
{
return
null
;
}
long
durationUs
=
Util
.
scaleLargeTimestamp
(
frameCount
samplesPerFrame
*
C
.
MICROS_PER_SECOND
sampleRate
)
;
if
(
(
flags
&
0x06
)
!
=
0x06
)
{
return
new
XingSeeker
(
position
mpegAudioHeader
.
frameSize
durationUs
)
;
}
long
dataSize
=
frame
.
readUnsignedIntToInt
(
)
;
long
[
]
tableOfContents
=
new
long
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
i
+
+
)
{
tableOfContents
[
i
]
=
frame
.
readUnsignedByte
(
)
;
}
if
(
inputLength
!
=
C
.
LENGTH_UNSET
&
&
inputLength
!
=
position
+
dataSize
)
{
Log
.
w
(
TAG
"
XING
data
size
mismatch
:
"
+
inputLength
+
"
"
+
(
position
+
dataSize
)
)
;
}
return
new
XingSeeker
(
position
mpegAudioHeader
.
frameSize
durationUs
dataSize
tableOfContents
)
;
}
private
final
long
dataStartPosition
;
private
final
int
xingFrameSize
;
private
final
long
durationUs
;
private
final
long
dataSize
;
private
final
long
dataEndPosition
;
Nullable
private
final
long
[
]
tableOfContents
;
private
XingSeeker
(
long
dataStartPosition
int
xingFrameSize
long
durationUs
)
{
this
(
dataStartPosition
xingFrameSize
durationUs
C
.
LENGTH_UNSET
null
)
;
}
private
XingSeeker
(
long
dataStartPosition
int
xingFrameSize
long
durationUs
long
dataSize
Nullable
long
[
]
tableOfContents
)
{
this
.
dataStartPosition
=
dataStartPosition
;
this
.
xingFrameSize
=
xingFrameSize
;
this
.
durationUs
=
durationUs
;
this
.
tableOfContents
=
tableOfContents
;
this
.
dataSize
=
dataSize
;
dataEndPosition
=
dataSize
=
=
C
.
LENGTH_UNSET
?
C
.
POSITION_UNSET
:
dataStartPosition
+
dataSize
;
}
Override
public
boolean
isSeekable
(
)
{
return
tableOfContents
!
=
null
;
}
Override
public
SeekPoints
getSeekPoints
(
long
timeUs
)
{
if
(
!
isSeekable
(
)
)
{
return
new
SeekPoints
(
new
SeekPoint
(
0
dataStartPosition
+
xingFrameSize
)
)
;
}
timeUs
=
Util
.
constrainValue
(
timeUs
0
durationUs
)
;
double
percent
=
(
timeUs
*
100d
)
/
durationUs
;
double
scaledPosition
;
if
(
percent
<
=
0
)
{
scaledPosition
=
0
;
}
else
if
(
percent
>
=
100
)
{
scaledPosition
=
256
;
}
else
{
int
prevTableIndex
=
(
int
)
percent
;
long
[
]
tableOfContents
=
Assertions
.
checkNotNull
(
this
.
tableOfContents
)
;
double
prevScaledPosition
=
tableOfContents
[
prevTableIndex
]
;
double
nextScaledPosition
=
prevTableIndex
=
=
99
?
256
:
tableOfContents
[
prevTableIndex
+
1
]
;
double
interpolateFraction
=
percent
-
prevTableIndex
;
scaledPosition
=
prevScaledPosition
+
(
interpolateFraction
*
(
nextScaledPosition
-
prevScaledPosition
)
)
;
}
long
positionOffset
=
Math
.
round
(
(
scaledPosition
/
256
)
*
dataSize
)
;
positionOffset
=
Util
.
constrainValue
(
positionOffset
xingFrameSize
dataSize
-
1
)
;
return
new
SeekPoints
(
new
SeekPoint
(
timeUs
dataStartPosition
+
positionOffset
)
)
;
}
Override
public
long
getTimeUs
(
long
position
)
{
long
positionOffset
=
position
-
dataStartPosition
;
if
(
!
isSeekable
(
)
|
|
positionOffset
<
=
xingFrameSize
)
{
return
0L
;
}
long
[
]
tableOfContents
=
Assertions
.
checkNotNull
(
this
.
tableOfContents
)
;
double
scaledPosition
=
(
positionOffset
*
256d
)
/
dataSize
;
int
prevTableIndex
=
Util
.
binarySearchFloor
(
tableOfContents
(
long
)
scaledPosition
true
true
)
;
long
prevTimeUs
=
getTimeUsForTableIndex
(
prevTableIndex
)
;
long
prevScaledPosition
=
tableOfContents
[
prevTableIndex
]
;
long
nextTimeUs
=
getTimeUsForTableIndex
(
prevTableIndex
+
1
)
;
long
nextScaledPosition
=
prevTableIndex
=
=
99
?
256
:
tableOfContents
[
prevTableIndex
+
1
]
;
double
interpolateFraction
=
prevScaledPosition
=
=
nextScaledPosition
?
0
:
(
(
scaledPosition
-
prevScaledPosition
)
/
(
nextScaledPosition
-
prevScaledPosition
)
)
;
return
prevTimeUs
+
Math
.
round
(
interpolateFraction
*
(
nextTimeUs
-
prevTimeUs
)
)
;
}
Override
public
long
getDurationUs
(
)
{
return
durationUs
;
}
Override
public
long
getDataEndPosition
(
)
{
return
dataEndPosition
;
}
private
long
getTimeUsForTableIndex
(
int
tableIndex
)
{
return
(
durationUs
*
tableIndex
)
/
100
;
}
}
