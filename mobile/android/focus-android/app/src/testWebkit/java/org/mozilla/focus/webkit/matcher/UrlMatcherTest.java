package
org
.
mozilla
.
focus
.
webkit
.
matcher
;
import
android
.
app
.
Application
;
import
android
.
content
.
SharedPreferences
;
import
android
.
net
.
Uri
;
import
android
.
preference
.
PreferenceManager
;
import
junit
.
framework
.
Assert
;
import
org
.
junit
.
Test
;
import
org
.
junit
.
runner
.
RunWith
;
import
org
.
mozilla
.
focus
.
webkit
.
matcher
.
util
.
FocusString
;
import
org
.
robolectric
.
RobolectricTestRunner
;
import
org
.
robolectric
.
RuntimeEnvironment
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
import
static
org
.
junit
.
Assert
.
*
;
RunWith
(
RobolectricTestRunner
.
class
)
public
class
UrlMatcherTest
{
Test
public
void
matches
(
)
throws
Exception
{
final
UrlMatcher
matcher
=
new
UrlMatcher
(
new
String
[
]
{
"
bcd
.
random
"
}
)
;
assertTrue
(
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
bcd
.
random
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
bcd
.
random
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
www
.
bcd
.
random
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
www
.
bcd
.
random
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
foobar
.
bcd
.
random
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
foobar
.
bcd
.
random
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
other
.
random
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
other
.
random
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
www
.
other
.
random
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
www
.
other
.
random
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
bcd
.
specific
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
bcd
.
specific
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
www
.
bcd
.
specific
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
assertTrue
(
!
matcher
.
matches
(
Uri
.
parse
(
"
http
:
/
/
www
.
bcd
.
specific
/
something
"
)
Uri
.
parse
(
"
http
:
/
/
mozilla
.
org
"
)
)
)
;
}
Test
public
void
categoriesWork
(
)
{
final
Map
<
String
Trie
>
categories
=
new
HashMap
<
>
(
)
;
final
Map
<
String
String
>
categoryPrefMap
=
new
HashMap
<
>
(
)
;
final
int
CAT_COUNT
=
4
;
final
SharedPreferences
preferences
=
PreferenceManager
.
getDefaultSharedPreferences
(
RuntimeEnvironment
.
application
)
;
{
final
SharedPreferences
.
Editor
editor
=
preferences
.
edit
(
)
;
for
(
int
i
=
0
;
i
<
CAT_COUNT
;
i
+
+
)
{
final
String
domain
=
"
category
"
+
i
+
"
.
com
"
;
final
Trie
trie
=
Trie
.
createRootNode
(
)
;
trie
.
put
(
FocusString
.
create
(
domain
)
.
reverse
(
)
)
;
final
String
categoryName
=
"
category
"
+
i
;
categories
.
put
(
categoryName
trie
)
;
editor
.
putBoolean
(
categoryName
false
)
;
categoryPrefMap
.
put
(
categoryName
categoryName
)
;
}
editor
.
commit
(
)
;
}
final
UrlMatcher
matcher
=
new
UrlMatcher
(
RuntimeEnvironment
.
application
categoryPrefMap
categories
null
)
;
final
int
allEnabledPattern
=
(
1
<
<
CAT_COUNT
)
-
1
;
for
(
int
categoryPattern
=
0
;
categoryPattern
<
=
allEnabledPattern
;
categoryPattern
+
+
)
{
final
SharedPreferences
.
Editor
editor
=
preferences
.
edit
(
)
;
for
(
int
currentCategory
=
0
;
currentCategory
<
CAT_COUNT
;
currentCategory
+
+
)
{
final
int
currentBit
=
1
<
<
currentCategory
;
final
boolean
enabled
=
(
(
currentBit
&
categoryPattern
)
=
=
currentBit
)
;
editor
.
putBoolean
(
"
category
"
+
currentCategory
enabled
)
;
if
(
categoryPattern
=
=
0
)
{
assertFalse
(
"
All
categories
should
be
disabled
for
categorypattern
=
=
0
"
enabled
)
;
}
else
if
(
categoryPattern
=
=
allEnabledPattern
)
{
assertTrue
(
"
All
categories
should
be
enabled
for
categorypattern
=
=
'
111
.
.
.
.
'
"
enabled
)
;
}
else
if
(
categoryPattern
=
=
Integer
.
parseInt
(
"
1100
"
2
)
)
{
if
(
currentCategory
<
2
)
{
assertFalse
(
"
Categories
0
/
1
expected
to
be
disabled
"
enabled
)
;
}
else
{
assertTrue
(
"
Categories
>
=
2
expected
to
be
enabled
"
enabled
)
;
}
}
}
editor
.
commit
(
)
;
for
(
int
currentCategory
=
0
;
currentCategory
<
CAT_COUNT
;
currentCategory
+
+
)
{
final
int
currentBit
=
1
<
<
currentCategory
;
final
boolean
enabled
=
(
(
currentBit
&
categoryPattern
)
=
=
currentBit
)
;
final
String
url
=
"
http
:
/
/
category
"
+
currentCategory
+
"
.
com
"
;
Assert
.
assertEquals
(
"
Incorrect
category
matched
for
combo
=
"
+
categoryPattern
+
"
url
=
"
+
url
enabled
matcher
.
matches
(
Uri
.
parse
(
url
)
Uri
.
parse
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
)
)
;
}
}
}
}
