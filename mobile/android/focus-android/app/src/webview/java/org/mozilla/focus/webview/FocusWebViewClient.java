package
org
.
mozilla
.
focus
.
webview
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
net
.
Uri
;
import
android
.
net
.
http
.
SslCertificate
;
import
android
.
net
.
http
.
SslError
;
import
android
.
os
.
Bundle
;
import
android
.
text
.
TextUtils
;
import
android
.
webkit
.
SslErrorHandler
;
import
android
.
webkit
.
WebResourceRequest
;
import
android
.
webkit
.
WebResourceResponse
;
import
android
.
webkit
.
WebView
;
import
android
.
webkit
.
WebViewClient
;
import
org
.
mozilla
.
focus
.
browser
.
LocalizedContent
;
import
org
.
mozilla
.
focus
.
utils
.
IntentUtils
;
import
org
.
mozilla
.
focus
.
utils
.
UrlUtils
;
import
org
.
mozilla
.
focus
.
web
.
IWebView
;
class
FocusWebViewClient
extends
TrackingProtectionWebViewClient
{
private
static
final
String
ERROR_PROTOCOL
=
"
error
:
"
;
private
static
final
String
STATE_KEY_URL
=
"
client_last_url
"
;
private
static
final
String
STATE_KEY_CERTIFICATE
=
"
client_last_certificate
"
;
private
String
restoredUrl
;
private
SslCertificate
restoredCertificate
;
private
boolean
errorReceived
;
FocusWebViewClient
(
Context
context
)
{
super
(
context
)
;
}
private
static
final
String
CLEAR_VISITED_CSS
=
"
var
nSheets
=
document
.
styleSheets
.
length
;
"
+
"
var
foundLink
=
false
;
"
+
"
var
foundA
=
false
;
"
+
"
for
(
s
=
0
;
s
<
nSheets
;
s
+
+
)
{
"
+
"
var
stylesheet
=
document
.
styleSheets
[
s
]
;
"
+
"
var
nRules
=
stylesheet
.
cssRules
?
stylesheet
.
cssRules
.
length
:
0
;
"
+
"
for
(
i
=
nRules
-
1
;
i
>
=
0
;
i
-
-
)
{
"
+
"
var
cssRule
=
stylesheet
.
cssRules
[
i
]
;
"
+
"
if
(
cssRule
.
selectorText
&
&
cssRule
.
selectorText
.
trim
(
)
=
=
\
"
a
\
"
)
{
"
+
"
foundA
=
true
;
"
+
"
}
"
+
"
if
(
cssRule
.
selectorText
&
&
(
cssRule
.
selectorText
.
includes
(
'
:
link
'
)
|
|
cssRule
.
selectorText
.
includes
(
'
:
visited
'
)
)
)
{
"
+
"
var
tokens
=
cssRule
.
selectorText
.
split
(
'
'
)
;
"
+
"
var
j
=
tokens
.
length
;
"
+
"
while
(
j
-
-
)
{
"
+
"
if
(
tokens
[
j
]
.
includes
(
'
:
visited
'
)
)
{
"
+
"
tokens
.
splice
(
j
1
)
;
"
+
"
}
"
+
"
}
"
+
"
if
(
tokens
.
length
=
=
0
)
{
"
+
"
stylesheet
.
deleteRule
(
i
)
;
"
+
"
}
else
{
"
+
"
cssRule
.
selectorText
=
tokens
.
join
(
'
'
)
;
"
+
"
}
"
+
"
var
newTokens
=
cssRule
.
selectorText
.
split
(
'
'
)
;
"
+
"
var
k
=
newTokens
.
length
;
"
+
"
while
(
k
-
-
)
{
"
+
"
if
(
newTokens
[
k
]
.
includes
(
'
:
link
'
)
)
{
"
+
"
foundLink
=
true
;
"
+
"
var
newVisitedRule
=
newTokens
[
k
]
.
split
(
'
:
'
)
[
0
]
.
concat
(
'
:
visited
{
'
)
.
concat
(
cssRule
.
cssText
.
split
(
\
"
{
\
"
)
[
1
]
)
;
"
+
"
stylesheet
.
insertRule
(
newVisitedRule
stylesheet
.
cssRules
.
length
)
;
"
+
"
newTokens
.
splice
(
k
+
1
0
newTokens
[
k
]
.
split
(
'
:
'
)
[
0
]
.
concat
(
'
:
visited
'
)
)
;
"
+
"
}
"
+
"
}
"
+
"
cssRule
.
selectorText
=
newTokens
.
join
(
'
'
)
;
"
+
"
}
"
+
"
if
(
i
=
=
0
&
&
!
foundLink
&
&
!
foundA
)
{
"
+
"
stylesheet
.
insertRule
(
\
"
a
:
link
a
:
visited
{
color
:
#
0000EE
;
}
\
"
stylesheet
.
cssRules
.
length
)
;
"
+
"
}
"
+
"
}
"
+
"
}
"
;
Override
public
void
onLoadResource
(
WebView
view
String
url
)
{
view
.
evaluateJavascript
(
"
(
function
(
)
{
"
+
"
function
cleanupVisited
(
)
{
"
+
CLEAR_VISITED_CSS
+
"
}
"
+
"
var
links
=
document
.
getElementsByTagName
(
'
link
'
)
;
"
+
"
for
(
i
=
0
;
i
<
links
.
length
;
i
+
+
)
{
"
+
"
link
=
links
[
i
]
;
"
+
"
if
(
link
.
rel
=
=
'
stylesheet
'
)
{
"
+
"
link
.
addEventListener
(
'
load
'
cleanupVisited
false
)
;
"
+
"
}
"
+
"
}
"
+
"
}
)
(
)
;
"
null
)
;
super
.
onLoadResource
(
view
url
)
;
}
Override
public
WebResourceResponse
shouldInterceptRequest
(
WebView
view
final
WebResourceRequest
request
)
{
if
(
request
.
isForMainFrame
(
)
)
{
final
String
requestURL
=
request
.
getUrl
(
)
.
toString
(
)
;
final
String
currentURL
=
currentPageURL
;
if
(
UrlUtils
.
urlsMatchExceptForTrailingSlash
(
currentURL
requestURL
)
)
{
view
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
callback
!
=
null
)
{
callback
.
onURLChanged
(
currentURL
)
;
}
}
}
)
;
}
if
(
callback
!
=
null
)
{
callback
.
onRequest
(
request
.
hasGesture
(
)
)
;
}
}
return
super
.
shouldInterceptRequest
(
view
request
)
;
}
Override
public
void
onPageStarted
(
WebView
view
String
url
Bitmap
favicon
)
{
if
(
errorReceived
)
{
errorReceived
=
false
;
}
else
if
(
callback
!
=
null
)
{
callback
.
onPageStarted
(
url
)
;
}
super
.
onPageStarted
(
view
url
favicon
)
;
}
void
saveState
(
WebView
view
Bundle
bundle
)
{
final
SslCertificate
certificate
=
view
.
getCertificate
(
)
;
if
(
certificate
!
=
null
)
{
bundle
.
putString
(
STATE_KEY_URL
view
.
getUrl
(
)
)
;
bundle
.
putBundle
(
STATE_KEY_CERTIFICATE
SslCertificate
.
saveState
(
certificate
)
)
;
}
}
void
restoreState
(
Bundle
bundle
)
{
if
(
bundle
!
=
null
&
&
bundle
.
containsKey
(
STATE_KEY_CERTIFICATE
)
)
{
restoredUrl
=
bundle
.
getString
(
STATE_KEY_URL
)
;
restoredCertificate
=
SslCertificate
.
restoreState
(
bundle
.
getBundle
(
"
client_last_certificate
"
)
)
;
}
}
Override
public
void
onPageFinished
(
WebView
view
final
String
url
)
{
SslCertificate
certificate
=
view
.
getCertificate
(
)
;
if
(
!
TextUtils
.
isEmpty
(
restoredUrl
)
)
{
if
(
restoredUrl
.
equals
(
url
)
&
&
certificate
=
=
null
)
{
certificate
=
restoredCertificate
;
}
else
{
restoredUrl
=
null
;
restoredCertificate
=
null
;
}
}
if
(
callback
!
=
null
)
{
callback
.
onPageFinished
(
certificate
!
=
null
)
;
final
String
viewURL
=
view
.
getUrl
(
)
;
if
(
!
UrlUtils
.
isInternalErrorURL
(
viewURL
)
&
&
viewURL
!
=
null
)
{
callback
.
onURLChanged
(
viewURL
)
;
}
}
super
.
onPageFinished
(
view
url
)
;
view
.
evaluateJavascript
(
"
(
function
(
)
{
"
+
CLEAR_VISITED_CSS
+
"
}
)
(
)
;
"
null
)
;
}
Override
public
boolean
shouldOverrideUrlLoading
(
WebView
view
String
url
)
{
if
(
LocalizedContent
.
handleInternalContent
(
url
view
)
)
{
return
true
;
}
if
(
url
.
equals
(
"
about
:
blank
"
)
)
{
return
false
;
}
final
Uri
uri
=
Uri
.
parse
(
url
)
;
if
(
!
UrlUtils
.
isSupportedProtocol
(
uri
.
getScheme
(
)
)
&
&
callback
!
=
null
&
&
IntentUtils
.
handleExternalUri
(
view
.
getContext
(
)
(
IWebView
)
view
url
)
)
{
return
true
;
}
return
super
.
shouldOverrideUrlLoading
(
view
url
)
;
}
Override
public
void
onReceivedSslError
(
WebView
view
SslErrorHandler
handler
SslError
error
)
{
handler
.
cancel
(
)
;
if
(
error
.
getUrl
(
)
.
equals
(
currentPageURL
)
)
{
ErrorPage
.
loadErrorPage
(
view
error
.
getUrl
(
)
WebViewClient
.
ERROR_FAILED_SSL_HANDSHAKE
)
;
}
}
Override
public
void
onReceivedError
(
final
WebView
webView
int
errorCode
final
String
description
String
failingUrl
)
{
errorReceived
=
true
;
if
(
failingUrl
.
startsWith
(
ERROR_PROTOCOL
)
)
{
final
int
errorCodePosition
=
ERROR_PROTOCOL
.
length
(
)
;
final
String
errorCodeString
=
failingUrl
.
substring
(
errorCodePosition
)
;
int
desiredErrorCode
;
try
{
desiredErrorCode
=
Integer
.
parseInt
(
errorCodeString
)
;
if
(
!
ErrorPage
.
supportsErrorCode
(
desiredErrorCode
)
)
{
desiredErrorCode
=
WebViewClient
.
ERROR_BAD_URL
;
}
}
catch
(
final
NumberFormatException
e
)
{
desiredErrorCode
=
WebViewClient
.
ERROR_BAD_URL
;
}
ErrorPage
.
loadErrorPage
(
webView
failingUrl
desiredErrorCode
)
;
return
;
}
if
(
failingUrl
.
equals
(
currentPageURL
)
&
&
ErrorPage
.
supportsErrorCode
(
errorCode
)
)
{
ErrorPage
.
loadErrorPage
(
webView
currentPageURL
errorCode
)
;
return
;
}
super
.
onReceivedError
(
webView
errorCode
description
failingUrl
)
;
}
}
