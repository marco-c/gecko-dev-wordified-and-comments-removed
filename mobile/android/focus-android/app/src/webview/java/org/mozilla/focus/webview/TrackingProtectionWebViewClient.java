package
org
.
mozilla
.
focus
.
webview
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
net
.
Uri
;
import
android
.
os
.
AsyncTask
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
webkit
.
HttpAuthHandler
;
import
android
.
webkit
.
WebResourceRequest
;
import
android
.
webkit
.
WebResourceResponse
;
import
android
.
webkit
.
WebView
;
import
android
.
webkit
.
WebViewClient
;
import
org
.
mozilla
.
focus
.
R
;
import
org
.
mozilla
.
focus
.
web
.
IWebView
;
import
org
.
mozilla
.
focus
.
webview
.
matcher
.
UrlMatcher
;
public
class
TrackingProtectionWebViewClient
extends
WebViewClient
{
private
static
volatile
UrlMatcher
MATCHER
;
public
static
void
triggerPreload
(
final
Context
context
)
{
if
(
MATCHER
=
=
null
)
{
new
AsyncTask
<
Void
Void
Void
>
(
)
{
Override
protected
Void
doInBackground
(
Void
.
.
.
voids
)
{
getMatcher
(
context
)
;
return
null
;
}
}
.
execute
(
)
;
}
}
WorkerThread
private
static
synchronized
UrlMatcher
getMatcher
(
final
Context
context
)
{
if
(
MATCHER
=
=
null
)
{
MATCHER
=
UrlMatcher
.
loadMatcher
(
context
R
.
raw
.
blocklist
new
int
[
]
{
R
.
raw
.
google_mapping
}
R
.
raw
.
entitylist
)
;
}
return
MATCHER
;
}
private
boolean
blockingEnabled
;
String
currentPageURL
;
protected
IWebView
.
Callback
callback
;
TrackingProtectionWebViewClient
(
final
Context
context
)
{
triggerPreload
(
context
)
;
this
.
blockingEnabled
=
true
;
}
public
void
setCallback
(
IWebView
.
Callback
callback
)
{
this
.
callback
=
callback
;
}
public
void
setBlockingEnabled
(
boolean
enabled
)
{
this
.
blockingEnabled
=
enabled
;
}
public
boolean
isBlockingEnabled
(
)
{
return
blockingEnabled
;
}
Override
public
WebResourceResponse
shouldInterceptRequest
(
final
WebView
view
final
WebResourceRequest
request
)
{
if
(
!
blockingEnabled
)
{
return
super
.
shouldInterceptRequest
(
view
request
)
;
}
final
Uri
resourceUri
=
request
.
getUrl
(
)
;
final
String
scheme
=
resourceUri
.
getScheme
(
)
;
if
(
!
request
.
isForMainFrame
(
)
&
&
!
scheme
.
equals
(
"
http
"
)
&
&
!
scheme
.
equals
(
"
https
"
)
)
{
return
new
WebResourceResponse
(
null
null
null
)
;
}
final
String
path
=
resourceUri
.
getPath
(
)
;
if
(
path
!
=
null
&
&
path
.
endsWith
(
"
/
favicon
.
ico
"
)
)
{
return
new
WebResourceResponse
(
null
null
null
)
;
}
final
UrlMatcher
matcher
=
getMatcher
(
view
.
getContext
(
)
)
;
if
(
(
!
request
.
isForMainFrame
(
)
)
&
&
currentPageURL
!
=
null
&
&
matcher
.
matches
(
resourceUri
Uri
.
parse
(
currentPageURL
)
)
)
{
if
(
callback
!
=
null
)
{
callback
.
countBlockedTracker
(
)
;
}
return
new
WebResourceResponse
(
null
null
null
)
;
}
return
super
.
shouldInterceptRequest
(
view
request
)
;
}
public
void
notifyCurrentURL
(
final
String
url
)
{
currentPageURL
=
url
;
}
Override
public
void
onPageStarted
(
WebView
view
String
url
Bitmap
favicon
)
{
if
(
callback
!
=
null
)
{
callback
.
resetBlockedTrackers
(
)
;
}
currentPageURL
=
url
;
super
.
onPageStarted
(
view
url
favicon
)
;
}
Override
public
void
onReceivedHttpAuthRequest
(
WebView
view
final
HttpAuthHandler
handler
String
host
String
realm
)
{
final
IWebView
.
HttpAuthCallback
httpAuthCallback
=
new
IWebView
.
HttpAuthCallback
(
)
{
Override
public
void
proceed
(
String
username
String
password
)
{
handler
.
proceed
(
username
password
)
;
}
Override
public
void
cancel
(
)
{
handler
.
cancel
(
)
;
}
}
;
if
(
callback
!
=
null
)
{
callback
.
onHttpAuthRequest
(
httpAuthCallback
host
realm
)
;
}
}
}
