package
org
.
mozilla
.
focus
.
webview
;
import
android
.
content
.
Context
;
import
android
.
content
.
SharedPreferences
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Environment
;
import
android
.
preference
.
PreferenceManager
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
android
.
view
.
View
;
import
android
.
view
.
autofill
.
AutofillValue
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
webkit
.
CookieManager
;
import
android
.
webkit
.
DownloadListener
;
import
android
.
webkit
.
WebBackForwardList
;
import
android
.
webkit
.
WebChromeClient
;
import
android
.
webkit
.
WebStorage
;
import
android
.
webkit
.
WebView
;
import
android
.
webkit
.
WebViewDatabase
;
import
org
.
mozilla
.
focus
.
BuildConfig
;
import
org
.
mozilla
.
focus
.
session
.
Session
;
import
org
.
mozilla
.
focus
.
telemetry
.
TelemetryWrapper
;
import
org
.
mozilla
.
focus
.
utils
.
AppConstants
;
import
org
.
mozilla
.
focus
.
utils
.
FileUtils
;
import
org
.
mozilla
.
focus
.
utils
.
UrlUtils
;
import
org
.
mozilla
.
focus
.
utils
.
ViewUtils
;
import
org
.
mozilla
.
focus
.
web
.
Download
;
import
org
.
mozilla
.
focus
.
web
.
IWebView
;
import
org
.
mozilla
.
focus
.
web
.
WebViewProvider
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
import
mozilla
.
components
.
support
.
utils
.
ThreadUtils
;
public
class
SystemWebView
extends
NestedWebView
implements
IWebView
SharedPreferences
.
OnSharedPreferenceChangeListener
{
private
static
final
String
TAG
=
"
WebkitView
"
;
private
Callback
callback
;
private
FocusWebViewClient
client
;
private
final
LinkHandler
linkHandler
;
public
SystemWebView
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
client
=
new
FocusWebViewClient
(
getContext
(
)
.
getApplicationContext
(
)
)
;
setWebViewClient
(
client
)
;
setWebChromeClient
(
createWebChromeClient
(
)
)
;
setDownloadListener
(
createDownloadListener
(
)
)
;
if
(
BuildConfig
.
DEBUG
)
{
setWebContentsDebuggingEnabled
(
true
)
;
}
setLongClickable
(
true
)
;
linkHandler
=
new
LinkHandler
(
this
)
;
setOnLongClickListener
(
linkHandler
)
;
}
VisibleForTesting
public
Callback
getCallback
(
)
{
return
callback
;
}
Override
protected
void
onAttachedToWindow
(
)
{
super
.
onAttachedToWindow
(
)
;
PreferenceManager
.
getDefaultSharedPreferences
(
getContext
(
)
)
.
registerOnSharedPreferenceChangeListener
(
this
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
O
)
{
TelemetryAutofillCallback
.
INSTANCE
.
register
(
getContext
(
)
)
;
}
}
Override
protected
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
PreferenceManager
.
getDefaultSharedPreferences
(
getContext
(
)
)
.
unregisterOnSharedPreferenceChangeListener
(
this
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
O
)
{
TelemetryAutofillCallback
.
INSTANCE
.
unregister
(
getContext
(
)
)
;
}
}
Override
public
InputConnection
onCreateInputConnection
(
EditorInfo
outAttrs
)
{
final
InputConnection
connection
=
super
.
onCreateInputConnection
(
outAttrs
)
;
outAttrs
.
imeOptions
|
=
ViewUtils
.
IME_FLAG_NO_PERSONALIZED_LEARNING
;
return
connection
;
}
Override
public
void
onSharedPreferenceChanged
(
SharedPreferences
sharedPreferences
String
key
)
{
WebViewProvider
.
applyAppSettings
(
getContext
(
)
getSettings
(
)
this
)
;
}
Override
public
void
onPause
(
)
{
super
.
onPause
(
)
;
pauseTimers
(
)
;
}
Override
public
void
onResume
(
)
{
super
.
onResume
(
)
;
resumeTimers
(
)
;
}
Override
public
void
restoreWebViewState
(
Session
session
)
{
final
Bundle
stateData
=
session
.
getWebViewState
(
)
;
final
WebBackForwardList
backForwardList
=
stateData
!
=
null
?
super
.
restoreState
(
stateData
)
:
null
;
final
String
desiredURL
=
session
.
getUrl
(
)
.
getValue
(
)
;
client
.
restoreState
(
stateData
)
;
client
.
notifyCurrentURL
(
desiredURL
)
;
if
(
backForwardList
!
=
null
&
&
backForwardList
.
getCurrentItem
(
)
.
getUrl
(
)
.
equals
(
desiredURL
)
)
{
reload
(
)
;
}
else
{
loadUrl
(
desiredURL
)
;
}
}
Override
public
void
saveWebViewState
(
NonNull
Session
session
)
{
final
Bundle
stateData
=
new
Bundle
(
)
;
super
.
saveState
(
stateData
)
;
client
.
saveState
(
this
stateData
)
;
session
.
saveWebViewState
(
stateData
)
;
}
Override
public
void
setBlockingEnabled
(
boolean
enabled
)
{
client
.
setBlockingEnabled
(
enabled
)
;
if
(
enabled
)
{
WebViewProvider
.
applyAppSettings
(
getContext
(
)
getSettings
(
)
this
)
;
}
else
{
WebViewProvider
.
disableBlocking
(
getSettings
(
)
this
)
;
}
if
(
callback
!
=
null
)
{
callback
.
onBlockingStateChanged
(
enabled
)
;
}
}
Override
public
void
setCallback
(
Callback
callback
)
{
this
.
callback
=
callback
;
client
.
setCallback
(
callback
)
;
linkHandler
.
setCallback
(
callback
)
;
}
public
void
loadUrl
(
String
url
)
{
if
(
!
client
.
shouldOverrideUrlLoading
(
this
url
)
)
{
final
Map
<
String
String
>
additionalHeaders
=
new
HashMap
<
>
(
)
;
additionalHeaders
.
put
(
"
X
-
Requested
-
With
"
"
"
)
;
super
.
loadUrl
(
url
additionalHeaders
)
;
}
client
.
notifyCurrentURL
(
url
)
;
}
Override
public
void
exitFullscreen
(
)
{
}
Override
public
void
loadData
(
String
baseURL
String
data
String
mimeType
String
encoding
String
historyURL
)
{
loadDataWithBaseURL
(
baseURL
data
mimeType
encoding
historyURL
)
;
}
Override
public
void
destroy
(
)
{
super
.
destroy
(
)
;
deleteContentFromKnownLocations
(
getContext
(
)
)
;
}
Override
public
void
cleanup
(
)
{
clearFormData
(
)
;
clearHistory
(
)
;
clearMatches
(
)
;
clearSslPreferences
(
)
;
clearCache
(
true
)
;
CookieManager
.
getInstance
(
)
.
removeAllCookies
(
null
)
;
WebStorage
.
getInstance
(
)
.
deleteAllData
(
)
;
final
WebViewDatabase
webViewDatabase
=
WebViewDatabase
.
getInstance
(
getContext
(
)
)
;
webViewDatabase
.
clearFormData
(
)
;
webViewDatabase
.
clearHttpAuthUsernamePassword
(
)
;
deleteContentFromKnownLocations
(
getContext
(
)
)
;
}
Override
public
void
autofill
(
SparseArray
<
AutofillValue
>
values
)
{
super
.
autofill
(
values
)
;
TelemetryWrapper
.
autofillPerformedEvent
(
)
;
}
public
static
void
deleteContentFromKnownLocations
(
final
Context
context
)
{
ThreadUtils
.
INSTANCE
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
FileUtils
.
deleteWebViewDirectory
(
context
)
;
FileUtils
.
truncateCacheDirectory
(
context
)
;
}
}
)
;
}
private
WebChromeClient
createWebChromeClient
(
)
{
return
new
WebChromeClient
(
)
{
Override
public
void
onProgressChanged
(
WebView
view
int
newProgress
)
{
if
(
callback
!
=
null
)
{
final
String
viewURL
=
view
.
getUrl
(
)
;
if
(
!
UrlUtils
.
isInternalErrorURL
(
viewURL
)
&
&
viewURL
!
=
null
)
{
callback
.
onURLChanged
(
viewURL
)
;
}
callback
.
onProgress
(
newProgress
)
;
}
}
Override
public
void
onShowCustomView
(
View
view
final
CustomViewCallback
webviewCallback
)
{
final
FullscreenCallback
fullscreenCallback
=
new
FullscreenCallback
(
)
{
Override
public
void
fullScreenExited
(
)
{
webviewCallback
.
onCustomViewHidden
(
)
;
}
}
;
callback
.
onEnterFullScreen
(
fullscreenCallback
view
)
;
}
Override
public
void
onHideCustomView
(
)
{
callback
.
onExitFullScreen
(
)
;
}
}
;
}
private
DownloadListener
createDownloadListener
(
)
{
return
new
DownloadListener
(
)
{
Override
public
void
onDownloadStart
(
String
url
String
userAgent
String
contentDisposition
String
mimetype
long
contentLength
)
{
if
(
!
AppConstants
.
supportsDownloadingFiles
(
)
)
{
return
;
}
final
String
scheme
=
Uri
.
parse
(
url
)
.
getScheme
(
)
;
if
(
scheme
=
=
null
|
|
(
!
scheme
.
equals
(
"
http
"
)
&
&
!
scheme
.
equals
(
"
https
"
)
)
)
{
Log
.
w
(
TAG
"
Ignoring
download
from
non
http
(
s
)
URL
:
"
+
url
)
;
return
;
}
if
(
callback
!
=
null
)
{
final
Download
download
=
new
Download
(
url
userAgent
contentDisposition
mimetype
contentLength
Environment
.
DIRECTORY_DOWNLOADS
)
;
callback
.
onDownloadStart
(
download
)
;
}
}
}
;
}
}
