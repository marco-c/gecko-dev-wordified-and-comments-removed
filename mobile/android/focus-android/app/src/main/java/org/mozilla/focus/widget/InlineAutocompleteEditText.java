package
org
.
mozilla
.
focus
.
widget
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Rect
;
import
android
.
support
.
v4
.
content
.
ContextCompat
;
import
android
.
text
.
Editable
;
import
android
.
text
.
NoCopySpan
;
import
android
.
text
.
Selection
;
import
android
.
text
.
Spanned
;
import
android
.
text
.
TextUtils
;
import
android
.
text
.
TextWatcher
;
import
android
.
text
.
style
.
BackgroundColorSpan
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
accessibility
.
AccessibilityEvent
;
import
android
.
view
.
inputmethod
.
BaseInputConnection
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
import
android
.
view
.
inputmethod
.
InputConnectionWrapper
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
android
.
widget
.
TextView
;
import
org
.
mozilla
.
focus
.
R
;
import
org
.
mozilla
.
focus
.
utils
.
UrlUtils
;
public
class
InlineAutocompleteEditText
extends
android
.
support
.
v7
.
widget
.
AppCompatEditText
{
public
interface
OnCommitListener
{
void
onCommit
(
)
;
}
public
interface
OnDismissListener
{
void
onDismiss
(
)
;
}
public
interface
OnFilterListener
{
void
onFilter
(
String
searchText
InlineAutocompleteEditText
view
)
;
}
public
interface
OnSearchStateChangeListener
{
void
onSearchStateChange
(
boolean
isActive
)
;
}
public
interface
OnTextChangeListener
{
void
onTextChange
(
String
originalText
String
autocompleteText
)
;
}
private
static
final
String
LOGTAG
=
"
GeckoToolbarEditText
"
;
private
static
final
NoCopySpan
AUTOCOMPLETE_SPAN
=
new
NoCopySpan
.
Concrete
(
)
;
private
final
Context
mContext
;
private
OnCommitListener
mCommitListener
;
private
OnDismissListener
mDismissListener
;
private
OnFilterListener
mFilterListener
;
private
OnSearchStateChangeListener
mSearchStateChangeListener
;
private
OnTextChangeListener
mTextChangeListener
;
private
String
mAutoCompleteResult
=
"
"
;
private
int
mAutoCompletePrefixLength
;
private
boolean
mSettingAutoComplete
;
private
Object
[
]
mAutoCompleteSpans
;
private
boolean
mDiscardAutoCompleteResult
;
public
InlineAutocompleteEditText
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
mContext
=
context
;
}
public
void
setOnCommitListener
(
OnCommitListener
listener
)
{
mCommitListener
=
listener
;
}
public
void
setOnDismissListener
(
OnDismissListener
listener
)
{
mDismissListener
=
listener
;
}
public
void
setOnFilterListener
(
OnFilterListener
listener
)
{
mFilterListener
=
listener
;
}
void
setOnSearchStateChangeListener
(
OnSearchStateChangeListener
listener
)
{
mSearchStateChangeListener
=
listener
;
}
public
void
setOnTextChangeListener
(
OnTextChangeListener
listener
)
{
mTextChangeListener
=
listener
;
}
Override
public
void
onAttachedToWindow
(
)
{
super
.
onAttachedToWindow
(
)
;
setOnKeyListener
(
new
KeyListener
(
)
)
;
setOnKeyPreImeListener
(
new
KeyPreImeListener
(
)
)
;
setOnSelectionChangedListener
(
new
SelectionChangeListener
(
)
)
;
addTextChangedListener
(
new
TextChangeListener
(
)
)
;
}
Override
public
void
onFocusChanged
(
boolean
gainFocus
int
direction
Rect
previouslyFocusedRect
)
{
super
.
onFocusChanged
(
gainFocus
direction
previouslyFocusedRect
)
;
final
boolean
isActive
=
!
TextUtils
.
isEmpty
(
getText
(
)
)
;
if
(
mSearchStateChangeListener
!
=
null
)
{
mSearchStateChangeListener
.
onSearchStateChange
(
isActive
)
;
}
if
(
gainFocus
)
{
resetAutocompleteState
(
)
;
return
;
}
removeAutocomplete
(
getText
(
)
)
;
final
InputMethodManager
imm
=
(
InputMethodManager
)
mContext
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
;
try
{
imm
.
restartInput
(
this
)
;
imm
.
hideSoftInputFromWindow
(
getWindowToken
(
)
0
)
;
}
catch
(
NullPointerException
e
)
{
Log
.
e
(
LOGTAG
"
InputMethodManagerService
why
are
you
throwing
"
+
"
a
NullPointerException
?
See
bug
782096
"
e
)
;
}
}
Override
public
void
setText
(
final
CharSequence
text
final
TextView
.
BufferType
type
)
{
final
String
textString
=
(
text
=
=
null
)
?
"
"
:
text
.
toString
(
)
;
super
.
setText
(
textString
type
)
;
resetAutocompleteState
(
)
;
}
Override
public
void
sendAccessibilityEventUnchecked
(
AccessibilityEvent
event
)
{
if
(
event
.
getEventType
(
)
=
=
AccessibilityEvent
.
TYPE_VIEW_TEXT_SELECTION_CHANGED
&
&
getParent
(
)
!
=
null
&
&
!
isShown
(
)
)
{
onInitializeAccessibilityEvent
(
event
)
;
dispatchPopulateAccessibilityEvent
(
event
)
;
getParent
(
)
.
requestSendAccessibilityEvent
(
this
event
)
;
}
else
{
super
.
sendAccessibilityEventUnchecked
(
event
)
;
}
}
private
void
beginSettingAutocomplete
(
)
{
beginBatchEdit
(
)
;
mSettingAutoComplete
=
true
;
}
private
void
endSettingAutocomplete
(
)
{
mSettingAutoComplete
=
false
;
endBatchEdit
(
)
;
}
private
void
resetAutocompleteState
(
)
{
mAutoCompleteSpans
=
new
Object
[
]
{
AUTOCOMPLETE_SPAN
new
BackgroundColorSpan
(
ContextCompat
.
getColor
(
getContext
(
)
R
.
color
.
colorAutocompleteHighlight
)
)
}
;
mAutoCompleteResult
=
"
"
;
mAutoCompletePrefixLength
=
getText
(
)
.
length
(
)
;
setCursorVisible
(
true
)
;
}
protected
String
getNonAutocompleteText
(
)
{
return
getNonAutocompleteText
(
getText
(
)
)
;
}
private
static
String
getNonAutocompleteText
(
final
Editable
text
)
{
final
int
start
=
text
.
getSpanStart
(
AUTOCOMPLETE_SPAN
)
;
if
(
start
<
0
)
{
return
text
.
toString
(
)
;
}
return
TextUtils
.
substring
(
text
0
start
)
;
}
private
boolean
removeAutocomplete
(
final
Editable
text
)
{
final
int
start
=
text
.
getSpanStart
(
AUTOCOMPLETE_SPAN
)
;
if
(
start
<
0
)
{
return
false
;
}
beginSettingAutocomplete
(
)
;
text
.
delete
(
start
text
.
length
(
)
)
;
mAutoCompleteResult
=
"
"
;
setCursorVisible
(
true
)
;
endSettingAutocomplete
(
)
;
return
true
;
}
private
boolean
commitAutocomplete
(
final
Editable
text
)
{
final
int
start
=
text
.
getSpanStart
(
AUTOCOMPLETE_SPAN
)
;
if
(
start
<
0
)
{
return
false
;
}
beginSettingAutocomplete
(
)
;
for
(
final
Object
span
:
mAutoCompleteSpans
)
{
text
.
removeSpan
(
span
)
;
}
mAutoCompletePrefixLength
=
text
.
length
(
)
;
setCursorVisible
(
true
)
;
endSettingAutocomplete
(
)
;
if
(
mFilterListener
!
=
null
)
{
mFilterListener
.
onFilter
(
text
.
toString
(
)
null
)
;
}
return
true
;
}
public
final
void
onAutocomplete
(
final
String
result
)
{
if
(
mDiscardAutoCompleteResult
)
{
return
;
}
if
(
!
isEnabled
(
)
|
|
result
=
=
null
)
{
mAutoCompleteResult
=
"
"
;
return
;
}
final
Editable
text
=
getText
(
)
;
final
int
textLength
=
text
.
length
(
)
;
final
int
resultLength
=
result
.
length
(
)
;
final
int
autoCompleteStart
=
text
.
getSpanStart
(
AUTOCOMPLETE_SPAN
)
;
mAutoCompleteResult
=
result
;
if
(
autoCompleteStart
>
-
1
)
{
if
(
!
TextUtils
.
regionMatches
(
result
0
text
0
autoCompleteStart
)
)
{
return
;
}
beginSettingAutocomplete
(
)
;
text
.
replace
(
autoCompleteStart
textLength
result
autoCompleteStart
resultLength
)
;
if
(
autoCompleteStart
=
=
resultLength
)
{
setCursorVisible
(
true
)
;
}
endSettingAutocomplete
(
)
;
}
else
{
if
(
resultLength
<
=
textLength
|
|
!
TextUtils
.
regionMatches
(
result
0
text
0
textLength
)
)
{
return
;
}
final
Object
[
]
spans
=
text
.
getSpans
(
textLength
textLength
Object
.
class
)
;
final
int
[
]
spanStarts
=
new
int
[
spans
.
length
]
;
final
int
[
]
spanEnds
=
new
int
[
spans
.
length
]
;
final
int
[
]
spanFlags
=
new
int
[
spans
.
length
]
;
for
(
int
i
=
0
;
i
<
spans
.
length
;
i
+
+
)
{
final
Object
span
=
spans
[
i
]
;
final
int
spanFlag
=
text
.
getSpanFlags
(
span
)
;
if
(
(
spanFlag
&
Spanned
.
SPAN_COMPOSING
)
=
=
0
&
&
(
span
!
=
Selection
.
SELECTION_START
)
&
&
(
span
!
=
Selection
.
SELECTION_END
)
)
{
continue
;
}
spanStarts
[
i
]
=
text
.
getSpanStart
(
span
)
;
spanEnds
[
i
]
=
text
.
getSpanEnd
(
span
)
;
spanFlags
[
i
]
=
spanFlag
;
}
beginSettingAutocomplete
(
)
;
text
.
append
(
result
textLength
resultLength
)
;
for
(
int
i
=
0
;
i
<
spans
.
length
;
i
+
+
)
{
final
int
spanFlag
=
spanFlags
[
i
]
;
if
(
spanFlag
=
=
0
)
{
continue
;
}
text
.
setSpan
(
spans
[
i
]
spanStarts
[
i
]
spanEnds
[
i
]
spanFlag
)
;
}
for
(
final
Object
span
:
mAutoCompleteSpans
)
{
text
.
setSpan
(
span
textLength
resultLength
Spanned
.
SPAN_EXCLUSIVE_EXCLUSIVE
)
;
}
setCursorVisible
(
false
)
;
bringPointIntoView
(
resultLength
)
;
endSettingAutocomplete
(
)
;
}
announceForAccessibility
(
text
.
toString
(
)
)
;
}
public
String
getOriginalText
(
)
{
final
Editable
text
=
getText
(
)
;
return
text
.
subSequence
(
0
mAutoCompletePrefixLength
)
.
toString
(
)
;
}
private
static
boolean
hasCompositionString
(
Editable
content
)
{
Object
[
]
spans
=
content
.
getSpans
(
0
content
.
length
(
)
Object
.
class
)
;
if
(
spans
!
=
null
)
{
for
(
Object
span
:
spans
)
{
if
(
(
content
.
getSpanFlags
(
span
)
&
Spanned
.
SPAN_COMPOSING
)
!
=
0
)
{
return
true
;
}
}
}
return
false
;
}
Override
public
InputConnection
onCreateInputConnection
(
final
EditorInfo
outAttrs
)
{
final
InputConnection
ic
=
super
.
onCreateInputConnection
(
outAttrs
)
;
if
(
ic
=
=
null
)
{
return
null
;
}
return
new
InputConnectionWrapper
(
ic
false
)
{
Override
public
boolean
deleteSurroundingText
(
final
int
beforeLength
final
int
afterLength
)
{
if
(
removeAutocomplete
(
getText
(
)
)
)
{
final
InputMethodManager
imm
=
(
InputMethodManager
)
mContext
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
;
if
(
imm
!
=
null
)
{
imm
.
restartInput
(
InlineAutocompleteEditText
.
this
)
;
}
return
false
;
}
return
super
.
deleteSurroundingText
(
beforeLength
afterLength
)
;
}
private
boolean
removeAutocompleteOnComposing
(
final
CharSequence
text
)
{
final
Editable
editable
=
getText
(
)
;
final
int
composingStart
=
BaseInputConnection
.
getComposingSpanStart
(
editable
)
;
final
int
composingEnd
=
BaseInputConnection
.
getComposingSpanEnd
(
editable
)
;
if
(
composingStart
>
=
0
&
&
composingEnd
>
=
0
&
&
(
composingEnd
-
composingStart
)
>
text
.
length
(
)
&
&
removeAutocomplete
(
editable
)
)
{
finishComposingText
(
)
;
setComposingRegion
(
composingStart
composingEnd
)
;
return
true
;
}
return
false
;
}
Override
public
boolean
commitText
(
CharSequence
text
int
newCursorPosition
)
{
if
(
removeAutocompleteOnComposing
(
text
)
)
{
return
false
;
}
return
super
.
commitText
(
text
newCursorPosition
)
;
}
Override
public
boolean
setComposingText
(
final
CharSequence
text
final
int
newCursorPosition
)
{
if
(
removeAutocompleteOnComposing
(
text
)
)
{
return
false
;
}
return
super
.
setComposingText
(
text
newCursorPosition
)
;
}
}
;
}
private
class
SelectionChangeListener
implements
OnSelectionChangedListener
{
Override
public
void
onSelectionChanged
(
final
int
selStart
final
int
selEnd
)
{
final
Editable
text
=
getText
(
)
;
final
int
start
=
text
.
getSpanStart
(
AUTOCOMPLETE_SPAN
)
;
if
(
mSettingAutoComplete
|
|
start
<
0
|
|
(
start
=
=
selStart
&
&
start
=
=
selEnd
)
)
{
return
;
}
if
(
selStart
<
=
start
&
&
selEnd
<
=
start
)
{
removeAutocomplete
(
text
)
;
}
else
{
commitAutocomplete
(
text
)
;
}
}
}
private
class
TextChangeListener
implements
TextWatcher
{
Override
public
void
afterTextChanged
(
final
Editable
editable
)
{
if
(
!
isEnabled
(
)
|
|
mSettingAutoComplete
)
{
return
;
}
final
String
text
=
getNonAutocompleteText
(
editable
)
;
final
int
textLength
=
text
.
length
(
)
;
boolean
doAutocomplete
=
true
;
if
(
UrlUtils
.
isSearchQuery
(
text
)
)
{
doAutocomplete
=
false
;
}
else
if
(
mAutoCompletePrefixLength
>
textLength
)
{
doAutocomplete
=
false
;
}
mAutoCompletePrefixLength
=
textLength
;
mDiscardAutoCompleteResult
=
!
doAutocomplete
;
if
(
doAutocomplete
&
&
mAutoCompleteResult
.
startsWith
(
text
)
)
{
onAutocomplete
(
mAutoCompleteResult
)
;
doAutocomplete
=
false
;
}
else
{
removeAutocomplete
(
editable
)
;
}
if
(
mSearchStateChangeListener
!
=
null
)
{
mSearchStateChangeListener
.
onSearchStateChange
(
textLength
>
0
)
;
}
if
(
mFilterListener
!
=
null
)
{
mFilterListener
.
onFilter
(
text
doAutocomplete
?
InlineAutocompleteEditText
.
this
:
null
)
;
}
if
(
mTextChangeListener
!
=
null
)
{
mTextChangeListener
.
onTextChange
(
text
getText
(
)
.
toString
(
)
)
;
}
}
Override
public
void
beforeTextChanged
(
CharSequence
s
int
start
int
count
int
after
)
{
}
Override
public
void
onTextChanged
(
CharSequence
s
int
start
int
before
int
count
)
{
}
}
private
class
KeyPreImeListener
implements
OnKeyPreImeListener
{
Override
public
boolean
onKeyPreIme
(
View
v
int
keyCode
KeyEvent
event
)
{
if
(
event
.
getAction
(
)
!
=
KeyEvent
.
ACTION_DOWN
)
{
return
false
;
}
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_ENTER
)
{
final
Editable
content
=
getText
(
)
;
if
(
!
hasCompositionString
(
content
)
)
{
if
(
mCommitListener
!
=
null
)
{
mCommitListener
.
onCommit
(
)
;
}
return
true
;
}
}
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_BACK
)
{
removeAutocomplete
(
getText
(
)
)
;
return
false
;
}
return
false
;
}
}
private
class
KeyListener
implements
View
.
OnKeyListener
{
Override
public
boolean
onKey
(
View
v
int
keyCode
KeyEvent
event
)
{
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_ENTER
)
{
if
(
event
.
getAction
(
)
!
=
KeyEvent
.
ACTION_DOWN
)
{
return
true
;
}
if
(
mCommitListener
!
=
null
)
{
mCommitListener
.
onCommit
(
)
;
}
return
true
;
}
if
(
(
keyCode
=
=
KeyEvent
.
KEYCODE_DEL
|
|
(
keyCode
=
=
KeyEvent
.
KEYCODE_FORWARD_DEL
)
)
&
&
removeAutocomplete
(
getText
(
)
)
)
{
return
true
;
}
return
false
;
}
}
private
OnKeyPreImeListener
mOnKeyPreImeListener
;
private
OnSelectionChangedListener
mOnSelectionChangedListener
;
private
OnWindowFocusChangeListener
mOnWindowFocusChangeListener
;
public
interface
OnKeyPreImeListener
{
public
boolean
onKeyPreIme
(
View
v
int
keyCode
KeyEvent
event
)
;
}
public
void
setOnKeyPreImeListener
(
OnKeyPreImeListener
listener
)
{
mOnKeyPreImeListener
=
listener
;
}
Override
public
boolean
onKeyPreIme
(
int
keyCode
KeyEvent
event
)
{
if
(
mOnKeyPreImeListener
!
=
null
)
return
mOnKeyPreImeListener
.
onKeyPreIme
(
this
keyCode
event
)
;
return
false
;
}
public
interface
OnSelectionChangedListener
{
public
void
onSelectionChanged
(
int
selStart
int
selEnd
)
;
}
public
void
setOnSelectionChangedListener
(
OnSelectionChangedListener
listener
)
{
mOnSelectionChangedListener
=
listener
;
}
Override
protected
void
onSelectionChanged
(
int
selStart
int
selEnd
)
{
if
(
mOnSelectionChangedListener
!
=
null
)
mOnSelectionChangedListener
.
onSelectionChanged
(
selStart
selEnd
)
;
super
.
onSelectionChanged
(
selStart
selEnd
)
;
}
public
interface
OnWindowFocusChangeListener
{
public
void
onWindowFocusChanged
(
boolean
hasFocus
)
;
}
public
void
setOnWindowFocusChangeListener
(
OnWindowFocusChangeListener
listener
)
{
mOnWindowFocusChangeListener
=
listener
;
}
Override
public
void
onWindowFocusChanged
(
boolean
hasFocus
)
{
super
.
onWindowFocusChanged
(
hasFocus
)
;
if
(
mOnWindowFocusChangeListener
!
=
null
)
mOnWindowFocusChangeListener
.
onWindowFocusChanged
(
hasFocus
)
;
}
}
