package
org
.
mozilla
.
focus
.
utils
;
import
android
.
net
.
Uri
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
webkit
.
MimeTypeMap
;
import
org
.
mozilla
.
focus
.
web
.
Download
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Locale
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
class
DownloadUtils
{
public
static
String
guessFileName
(
Download
download
)
{
String
contentDisposition
=
download
.
getContentDisposition
(
)
;
String
url
=
download
.
getUrl
(
)
;
String
mimeType
=
download
.
getMimeType
(
)
;
String
filename
=
null
;
String
extension
=
null
;
if
(
contentDisposition
!
=
null
)
{
filename
=
parseContentDisposition
(
contentDisposition
)
;
if
(
filename
!
=
null
)
{
int
index
=
filename
.
lastIndexOf
(
'
/
'
)
+
1
;
if
(
index
>
0
)
{
filename
=
filename
.
substring
(
index
)
;
}
}
}
if
(
filename
=
=
null
)
{
String
decodedUrl
=
Uri
.
decode
(
url
)
;
if
(
decodedUrl
!
=
null
)
{
int
queryIndex
=
decodedUrl
.
indexOf
(
'
?
'
)
;
if
(
queryIndex
>
0
)
{
decodedUrl
=
decodedUrl
.
substring
(
0
queryIndex
)
;
}
if
(
!
decodedUrl
.
endsWith
(
"
/
"
)
)
{
int
index
=
decodedUrl
.
lastIndexOf
(
'
/
'
)
+
1
;
if
(
index
>
0
)
{
filename
=
decodedUrl
.
substring
(
index
)
;
}
}
}
}
if
(
filename
=
=
null
)
{
filename
=
"
downloadfile
"
;
}
int
dotIndex
=
filename
.
indexOf
(
'
.
'
)
;
if
(
dotIndex
<
0
)
{
if
(
mimeType
!
=
null
)
{
extension
=
MimeTypeMap
.
getSingleton
(
)
.
getExtensionFromMimeType
(
mimeType
)
;
if
(
extension
!
=
null
)
{
extension
=
"
.
"
+
extension
;
}
}
if
(
extension
=
=
null
)
{
if
(
mimeType
!
=
null
&
&
mimeType
.
toLowerCase
(
Locale
.
ROOT
)
.
startsWith
(
"
text
/
"
)
)
{
if
(
mimeType
.
equalsIgnoreCase
(
"
text
/
html
"
)
)
{
extension
=
"
.
html
"
;
}
else
{
extension
=
"
.
txt
"
;
}
}
else
{
extension
=
"
.
bin
"
;
}
}
}
else
{
if
(
mimeType
!
=
null
)
{
int
lastDotIndex
=
filename
.
lastIndexOf
(
'
.
'
)
;
String
typeFromExt
=
MimeTypeMap
.
getSingleton
(
)
.
getMimeTypeFromExtension
(
filename
.
substring
(
lastDotIndex
+
1
)
)
;
if
(
typeFromExt
!
=
null
&
&
!
typeFromExt
.
equalsIgnoreCase
(
mimeType
)
)
{
extension
=
MimeTypeMap
.
getSingleton
(
)
.
getExtensionFromMimeType
(
mimeType
)
;
if
(
extension
!
=
null
)
{
extension
=
"
.
"
+
extension
;
}
}
}
if
(
extension
=
=
null
)
{
extension
=
filename
.
substring
(
dotIndex
)
;
}
filename
=
filename
.
substring
(
0
dotIndex
)
;
}
return
filename
+
extension
;
}
private
static
final
Pattern
CONTENT_DISPOSITION_PATTERN
=
Pattern
.
compile
(
"
attachment
\
\
s
*
;
\
\
s
*
filename
\
\
s
*
=
\
\
s
*
"
+
"
(
\
"
(
(
?
:
\
\
\
\
.
|
[
^
\
"
\
\
\
\
]
)
*
)
\
"
|
[
^
;
]
*
)
\
\
s
*
"
+
"
(
?
:
;
\
\
s
*
filename
\
\
*
\
\
s
*
=
\
\
s
*
(
utf
-
8
|
iso
-
8859
-
1
)
'
[
^
'
]
*
'
(
\
\
S
*
)
)
?
"
Pattern
.
CASE_INSENSITIVE
)
;
Nullable
private
static
String
parseContentDisposition
(
String
contentDisposition
)
{
try
{
Matcher
m
=
CONTENT_DISPOSITION_PATTERN
.
matcher
(
contentDisposition
)
;
if
(
m
.
find
(
)
)
{
String
encodedFileName
=
m
.
group
(
4
)
;
String
encoding
=
m
.
group
(
3
)
;
if
(
encodedFileName
!
=
null
)
{
return
decodeHeaderField
(
encodedFileName
encoding
)
;
}
String
quotedFileName
=
m
.
group
(
2
)
;
if
(
quotedFileName
!
=
null
)
{
return
quotedFileName
.
replaceAll
(
"
\
\
\
\
(
.
)
"
"
1
"
)
;
}
return
m
.
group
(
1
)
;
}
}
catch
(
IllegalStateException
|
UnsupportedEncodingException
ex
)
{
}
return
null
;
}
private
static
final
Pattern
ENCODED_SYMBOL_PATTERN
=
Pattern
.
compile
(
"
%
[
0
-
9a
-
f
]
{
2
}
|
[
0
-
9a
-
z
!
#
&
+
-
.
^
_
|
~
]
"
Pattern
.
CASE_INSENSITIVE
)
;
private
static
String
decodeHeaderField
(
String
field
String
encoding
)
throws
UnsupportedEncodingException
{
Matcher
m
=
ENCODED_SYMBOL_PATTERN
.
matcher
(
field
)
;
ByteArrayOutputStream
stream
=
new
ByteArrayOutputStream
(
)
;
while
(
m
.
find
(
)
)
{
String
symbol
=
m
.
group
(
)
;
if
(
symbol
.
startsWith
(
"
%
"
)
)
{
stream
.
write
(
Integer
.
parseInt
(
symbol
.
substring
(
1
)
16
)
)
;
}
else
{
stream
.
write
(
symbol
.
charAt
(
0
)
)
;
}
}
return
stream
.
toString
(
encoding
)
;
}
}
