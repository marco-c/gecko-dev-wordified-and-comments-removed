package
org
.
mozilla
.
focus
.
fragment
;
import
android
.
animation
.
Animator
;
import
android
.
animation
.
AnimatorListenerAdapter
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Intent
;
import
android
.
graphics
.
Typeface
;
import
android
.
os
.
Bundle
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
v4
.
app
.
Fragment
;
import
android
.
support
.
v4
.
app
.
FragmentManager
;
import
android
.
support
.
v7
.
widget
.
PopupMenu
;
import
android
.
text
.
SpannableString
;
import
android
.
text
.
style
.
StyleSpan
;
import
android
.
view
.
Gravity
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
MenuItem
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
ViewTreeObserver
;
import
android
.
widget
.
FrameLayout
;
import
android
.
widget
.
TextView
;
import
org
.
mozilla
.
focus
.
R
;
import
org
.
mozilla
.
focus
.
activity
.
InfoActivity
;
import
org
.
mozilla
.
focus
.
autocomplete
.
UrlAutoCompleteFilter
;
import
org
.
mozilla
.
focus
.
locale
.
LocaleAwareAppCompatActivity
;
import
org
.
mozilla
.
focus
.
telemetry
.
TelemetryWrapper
;
import
org
.
mozilla
.
focus
.
utils
.
ThreadUtils
;
import
org
.
mozilla
.
focus
.
utils
.
UrlUtils
;
import
org
.
mozilla
.
focus
.
utils
.
ViewUtils
;
import
org
.
mozilla
.
focus
.
widget
.
HintFrameLayout
;
import
org
.
mozilla
.
focus
.
widget
.
InlineAutocompleteEditText
;
public
class
UrlInputFragment
extends
Fragment
implements
View
.
OnClickListener
InlineAutocompleteEditText
.
OnCommitListener
InlineAutocompleteEditText
.
OnFilterListener
PopupMenu
.
OnMenuItemClickListener
{
public
static
final
String
FRAGMENT_TAG
=
"
url_input
"
;
private
static
final
String
ARGUMENT_URL
=
"
url
"
;
private
static
final
String
ARGUMENT_ANIMATION
=
"
animation
"
;
private
static
final
String
ARGUMENT_X
=
"
x
"
;
private
static
final
String
ARGUMENT_Y
=
"
y
"
;
private
static
final
String
ARGUMENT_WIDTH
=
"
width
"
;
private
static
final
String
ARGUMENT_HEIGHT
=
"
height
"
;
private
static
final
String
ARGUMENT_OVERLAY
=
"
translucent
"
;
private
static
final
String
ANIMATION_BROWSER_SCREEN
=
"
browser_screen
"
;
private
static
final
int
ANIMATION_DURATION
=
200
;
public
static
UrlInputFragment
createWithBackground
(
)
{
final
Bundle
arguments
=
new
Bundle
(
)
;
arguments
.
putBoolean
(
ARGUMENT_OVERLAY
false
)
;
final
UrlInputFragment
fragment
=
new
UrlInputFragment
(
)
;
fragment
.
setArguments
(
arguments
)
;
return
fragment
;
}
public
static
UrlInputFragment
createAsOverlay
(
String
url
View
urlView
)
{
final
Bundle
arguments
=
new
Bundle
(
)
;
arguments
.
putString
(
ARGUMENT_ANIMATION
ANIMATION_BROWSER_SCREEN
)
;
arguments
.
putString
(
ARGUMENT_URL
url
)
;
arguments
.
putBoolean
(
ARGUMENT_OVERLAY
true
)
;
int
[
]
screenLocation
=
new
int
[
2
]
;
urlView
.
getLocationOnScreen
(
screenLocation
)
;
arguments
.
putInt
(
ARGUMENT_X
screenLocation
[
0
]
)
;
arguments
.
putInt
(
ARGUMENT_Y
screenLocation
[
1
]
)
;
arguments
.
putInt
(
ARGUMENT_WIDTH
urlView
.
getWidth
(
)
)
;
arguments
.
putInt
(
ARGUMENT_HEIGHT
urlView
.
getHeight
(
)
)
;
final
UrlInputFragment
fragment
=
new
UrlInputFragment
(
)
;
fragment
.
setArguments
(
arguments
)
;
return
fragment
;
}
private
InlineAutocompleteEditText
urlView
;
private
View
clearView
;
private
View
searchViewContainer
;
private
TextView
searchView
;
private
UrlAutoCompleteFilter
urlAutoCompleteFilter
;
private
View
dismissView
;
private
HintFrameLayout
urlInputContainerView
;
private
View
urlInputBackgroundView
;
private
View
toolbarBackgroundView
;
private
View
menuView
;
private
Nullable
PopupMenu
displayedPopupMenu
;
private
volatile
boolean
isAnimating
;
Override
public
View
onCreateView
(
LayoutInflater
inflater
Nullable
ViewGroup
container
Nullable
Bundle
savedInstanceState
)
{
final
View
view
=
inflater
.
inflate
(
R
.
layout
.
fragment_urlinput
container
false
)
;
dismissView
=
view
.
findViewById
(
R
.
id
.
dismiss
)
;
dismissView
.
setOnClickListener
(
this
)
;
clearView
=
view
.
findViewById
(
R
.
id
.
clear
)
;
clearView
.
setOnClickListener
(
this
)
;
searchViewContainer
=
view
.
findViewById
(
R
.
id
.
search_hint_container
)
;
searchView
=
(
TextView
)
view
.
findViewById
(
R
.
id
.
search_hint
)
;
searchView
.
setOnClickListener
(
this
)
;
urlAutoCompleteFilter
=
new
UrlAutoCompleteFilter
(
)
;
urlAutoCompleteFilter
.
loadDomainsInBackground
(
getContext
(
)
.
getApplicationContext
(
)
)
;
urlView
=
(
InlineAutocompleteEditText
)
view
.
findViewById
(
R
.
id
.
url_edit
)
;
urlView
.
setOnFilterListener
(
this
)
;
urlView
.
setOnFocusChangeListener
(
new
View
.
OnFocusChangeListener
(
)
{
Override
public
void
onFocusChange
(
View
v
boolean
hasFocus
)
{
if
(
hasFocus
&
&
!
isAnimating
)
{
ViewUtils
.
showKeyboard
(
urlView
)
;
}
}
}
)
;
toolbarBackgroundView
=
view
.
findViewById
(
R
.
id
.
toolbar_background
)
;
urlInputBackgroundView
=
view
.
findViewById
(
R
.
id
.
url_input_background
)
;
menuView
=
view
.
findViewById
(
R
.
id
.
menu
)
;
urlInputContainerView
=
(
HintFrameLayout
)
view
.
findViewById
(
R
.
id
.
url_input_container
)
;
urlInputContainerView
.
getViewTreeObserver
(
)
.
addOnPreDrawListener
(
new
ViewTreeObserver
.
OnPreDrawListener
(
)
{
Override
public
boolean
onPreDraw
(
)
{
urlInputContainerView
.
getViewTreeObserver
(
)
.
removeOnPreDrawListener
(
this
)
;
animateFirstDraw
(
)
;
return
true
;
}
}
)
;
if
(
isOverlay
(
)
)
{
view
.
findViewById
(
R
.
id
.
brand_background
)
.
setVisibility
(
View
.
GONE
)
;
}
else
{
dismissView
.
setVisibility
(
View
.
GONE
)
;
toolbarBackgroundView
.
setVisibility
(
View
.
GONE
)
;
menuView
.
setVisibility
(
View
.
VISIBLE
)
;
menuView
.
setOnClickListener
(
this
)
;
}
urlView
.
setOnCommitListener
(
this
)
;
if
(
getArguments
(
)
.
containsKey
(
ARGUMENT_URL
)
)
{
urlView
.
setText
(
getArguments
(
)
.
getString
(
ARGUMENT_URL
)
)
;
clearView
.
setVisibility
(
View
.
VISIBLE
)
;
}
return
view
;
}
private
boolean
isOverlay
(
)
{
return
getArguments
(
)
.
getBoolean
(
ARGUMENT_OVERLAY
false
)
;
}
public
boolean
onBackPressed
(
)
{
if
(
isOverlay
(
)
)
{
animateAndDismiss
(
)
;
return
true
;
}
return
false
;
}
Override
public
void
onStart
(
)
{
super
.
onStart
(
)
;
urlView
.
requestFocus
(
)
;
}
Override
public
void
onClick
(
View
view
)
{
switch
(
view
.
getId
(
)
)
{
case
R
.
id
.
clear
:
clear
(
)
;
break
;
case
R
.
id
.
search_hint
:
onSearch
(
)
;
break
;
case
R
.
id
.
dismiss
:
if
(
isOverlay
(
)
)
{
animateAndDismiss
(
)
;
}
else
{
clear
(
)
;
}
break
;
case
R
.
id
.
menu
:
final
PopupMenu
popupMenu
=
new
PopupMenu
(
view
.
getContext
(
)
view
)
;
popupMenu
.
getMenuInflater
(
)
.
inflate
(
R
.
menu
.
menu_home
popupMenu
.
getMenu
(
)
)
;
popupMenu
.
setOnMenuItemClickListener
(
this
)
;
popupMenu
.
setGravity
(
Gravity
.
TOP
)
;
popupMenu
.
show
(
)
;
displayedPopupMenu
=
popupMenu
;
break
;
default
:
throw
new
IllegalStateException
(
"
Unhandled
view
in
onClick
(
)
"
)
;
}
}
private
void
clear
(
)
{
urlView
.
setText
(
"
"
)
;
urlView
.
requestFocus
(
)
;
}
Override
public
void
onDetach
(
)
{
super
.
onDetach
(
)
;
if
(
displayedPopupMenu
!
=
null
)
{
displayedPopupMenu
.
dismiss
(
)
;
}
}
private
void
animateFirstDraw
(
)
{
final
String
animation
=
getArguments
(
)
.
getString
(
ARGUMENT_ANIMATION
)
;
if
(
ANIMATION_BROWSER_SCREEN
.
equals
(
animation
)
)
{
playVisibilityAnimation
(
false
)
;
}
}
private
void
animateAndDismiss
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isAnimating
)
{
return
;
}
dismissView
.
setClickable
(
false
)
;
final
String
animation
=
getArguments
(
)
.
getString
(
ARGUMENT_ANIMATION
)
;
if
(
ANIMATION_BROWSER_SCREEN
.
equals
(
animation
)
)
{
playVisibilityAnimation
(
true
)
;
}
else
{
dismiss
(
)
;
}
}
private
void
playVisibilityAnimation
(
final
boolean
reverse
)
{
if
(
isAnimating
)
{
return
;
}
isAnimating
=
true
;
{
float
xyOffset
=
isOverlay
(
)
?
(
(
FrameLayout
.
LayoutParams
)
urlInputContainerView
.
getLayoutParams
(
)
)
.
bottomMargin
:
0
;
float
width
=
urlInputBackgroundView
.
getWidth
(
)
;
float
height
=
urlInputBackgroundView
.
getHeight
(
)
;
float
widthScale
=
isOverlay
(
)
?
(
width
+
(
2
*
xyOffset
)
)
/
width
:
1
;
float
heightScale
=
isOverlay
(
)
?
(
height
+
(
2
*
xyOffset
)
)
/
height
:
1
;
if
(
!
reverse
)
{
urlInputBackgroundView
.
setPivotX
(
0
)
;
urlInputBackgroundView
.
setPivotY
(
0
)
;
urlInputBackgroundView
.
setScaleX
(
widthScale
)
;
urlInputBackgroundView
.
setScaleY
(
heightScale
)
;
urlInputBackgroundView
.
setTranslationX
(
-
xyOffset
)
;
urlInputBackgroundView
.
setTranslationY
(
-
xyOffset
)
;
urlInputContainerView
.
setAnimationOffset
(
0f
)
;
clearView
.
setAlpha
(
0
)
;
}
urlInputBackgroundView
.
animate
(
)
.
setDuration
(
ANIMATION_DURATION
)
.
scaleX
(
reverse
?
widthScale
:
1
)
.
scaleY
(
reverse
?
heightScale
:
1
)
.
alpha
(
reverse
&
&
isOverlay
(
)
?
0
:
1
)
.
translationX
(
reverse
?
-
xyOffset
:
0
)
.
translationY
(
reverse
?
-
xyOffset
:
0
)
.
setListener
(
new
AnimatorListenerAdapter
(
)
{
Override
public
void
onAnimationStart
(
Animator
animation
)
{
if
(
reverse
)
{
clearView
.
setAlpha
(
0
)
;
}
}
Override
public
void
onAnimationEnd
(
Animator
animation
)
{
if
(
reverse
)
{
if
(
isOverlay
(
)
)
{
dismiss
(
)
;
}
}
else
{
clearView
.
setAlpha
(
1
)
;
}
isAnimating
=
false
;
}
}
)
;
}
if
(
isOverlay
(
)
)
{
int
[
]
screenLocation
=
new
int
[
2
]
;
urlView
.
getLocationOnScreen
(
screenLocation
)
;
int
leftDelta
=
getArguments
(
)
.
getInt
(
ARGUMENT_X
)
-
screenLocation
[
0
]
-
urlView
.
getPaddingLeft
(
)
;
if
(
!
reverse
)
{
urlView
.
setPivotX
(
0
)
;
urlView
.
setPivotY
(
0
)
;
urlView
.
setTranslationX
(
leftDelta
)
;
}
urlView
.
animate
(
)
.
setDuration
(
ANIMATION_DURATION
)
.
translationX
(
reverse
?
leftDelta
:
0
)
;
}
if
(
!
reverse
)
{
toolbarBackgroundView
.
setAlpha
(
0
)
;
clearView
.
setAlpha
(
0
)
;
}
toolbarBackgroundView
.
animate
(
)
.
setDuration
(
ANIMATION_DURATION
)
.
alpha
(
reverse
?
0
:
1
)
.
setListener
(
new
AnimatorListenerAdapter
(
)
{
Override
public
void
onAnimationStart
(
Animator
animation
)
{
toolbarBackgroundView
.
setVisibility
(
View
.
VISIBLE
)
;
}
Override
public
void
onAnimationEnd
(
Animator
animation
)
{
if
(
reverse
)
{
toolbarBackgroundView
.
setVisibility
(
View
.
GONE
)
;
if
(
!
isOverlay
(
)
)
{
dismissView
.
setVisibility
(
View
.
GONE
)
;
menuView
.
setVisibility
(
View
.
VISIBLE
)
;
}
}
}
}
)
;
}
private
void
dismiss
(
)
{
final
Activity
activity
=
getActivity
(
)
;
if
(
activity
=
=
null
)
{
return
;
}
getActivity
(
)
.
getSupportFragmentManager
(
)
.
beginTransaction
(
)
.
remove
(
this
)
.
commitAllowingStateLoss
(
)
;
}
Override
public
void
onCommit
(
)
{
final
String
input
=
urlView
.
getText
(
)
.
toString
(
)
;
if
(
!
input
.
trim
(
)
.
isEmpty
(
)
)
{
ViewUtils
.
hideKeyboard
(
urlView
)
;
final
boolean
isUrl
=
UrlUtils
.
isUrl
(
input
)
;
final
String
url
=
isUrl
?
UrlUtils
.
normalize
(
input
)
:
UrlUtils
.
createSearchUrl
(
getContext
(
)
input
)
;
openUrl
(
url
)
;
TelemetryWrapper
.
urlBarEvent
(
isUrl
)
;
}
}
private
void
onSearch
(
)
{
final
String
searchUrl
=
UrlUtils
.
createSearchUrl
(
getContext
(
)
urlView
.
getOriginalText
(
)
)
;
openUrl
(
searchUrl
)
;
TelemetryWrapper
.
searchSelectEvent
(
)
;
}
private
void
openUrl
(
String
url
)
{
final
FragmentManager
fragmentManager
=
getActivity
(
)
.
getSupportFragmentManager
(
)
;
final
BrowserFragment
browserFragment
=
(
BrowserFragment
)
fragmentManager
.
findFragmentByTag
(
BrowserFragment
.
FRAGMENT_TAG
)
;
if
(
browserFragment
!
=
null
&
&
browserFragment
.
isVisible
(
)
)
{
browserFragment
.
loadUrl
(
url
)
;
fragmentManager
.
beginTransaction
(
)
.
remove
(
this
)
.
commit
(
)
;
}
else
{
fragmentManager
.
beginTransaction
(
)
.
replace
(
R
.
id
.
container
BrowserFragment
.
create
(
url
)
BrowserFragment
.
FRAGMENT_TAG
)
.
commit
(
)
;
}
}
Override
public
void
onFilter
(
String
searchText
InlineAutocompleteEditText
view
)
{
if
(
!
isVisible
(
)
)
{
return
;
}
urlAutoCompleteFilter
.
onFilter
(
searchText
view
)
;
if
(
searchText
.
trim
(
)
.
isEmpty
(
)
)
{
clearView
.
setVisibility
(
View
.
GONE
)
;
searchViewContainer
.
setVisibility
(
View
.
GONE
)
;
if
(
!
isOverlay
(
)
)
{
playVisibilityAnimation
(
true
)
;
}
}
else
{
clearView
.
setVisibility
(
View
.
VISIBLE
)
;
menuView
.
setVisibility
(
View
.
GONE
)
;
if
(
!
isOverlay
(
)
&
&
dismissView
.
getVisibility
(
)
!
=
View
.
VISIBLE
)
{
playVisibilityAnimation
(
false
)
;
dismissView
.
setVisibility
(
View
.
VISIBLE
)
;
}
final
String
hint
=
getString
(
R
.
string
.
search_hint
searchText
)
;
final
SpannableString
content
=
new
SpannableString
(
hint
)
;
content
.
setSpan
(
new
StyleSpan
(
Typeface
.
BOLD
)
hint
.
length
(
)
-
searchText
.
length
(
)
hint
.
length
(
)
0
)
;
searchView
.
setText
(
content
)
;
searchViewContainer
.
setVisibility
(
View
.
VISIBLE
)
;
}
}
Override
public
boolean
onMenuItemClick
(
MenuItem
item
)
{
final
int
id
=
item
.
getItemId
(
)
;
switch
(
id
)
{
case
R
.
id
.
settings
:
(
(
LocaleAwareAppCompatActivity
)
getActivity
(
)
)
.
openPreferences
(
)
;
return
true
;
case
R
.
id
.
about
:
Intent
aboutIntent
=
InfoActivity
.
getAboutIntent
(
getActivity
(
)
)
;
startActivity
(
aboutIntent
)
;
return
true
;
case
R
.
id
.
rights
:
Intent
rightsIntent
=
InfoActivity
.
getRightsIntent
(
getActivity
(
)
)
;
startActivity
(
rightsIntent
)
;
return
true
;
case
R
.
id
.
help
:
Intent
helpIntent
=
InfoActivity
.
getHelpIntent
(
getActivity
(
)
)
;
startActivity
(
helpIntent
)
;
return
true
;
default
:
throw
new
IllegalStateException
(
"
Unhandled
view
ID
in
onMenuItemClick
(
)
"
)
;
}
}
}
