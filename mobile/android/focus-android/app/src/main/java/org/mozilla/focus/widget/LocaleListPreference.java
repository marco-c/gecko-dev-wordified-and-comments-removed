package
org
.
mozilla
.
focus
.
widget
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Paint
;
import
android
.
preference
.
ListPreference
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
focus
.
R
;
import
org
.
mozilla
.
focus
.
locale
.
LocaleManager
;
import
org
.
mozilla
.
focus
.
locale
.
Locales
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
text
.
Collator
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
public
class
LocaleListPreference
extends
ListPreference
{
private
static
final
String
LOG_TAG
=
"
GeckoLocaleList
"
;
private
static
Map
<
String
String
>
languageCodeToNameMap
=
new
HashMap
<
>
(
)
;
static
{
languageCodeToNameMap
.
put
(
"
ast
"
"
Asturianu
"
)
;
languageCodeToNameMap
.
put
(
"
cak
"
"
Kaqchikel
"
)
;
languageCodeToNameMap
.
put
(
"
ia
"
"
Interlingua
"
)
;
languageCodeToNameMap
.
put
(
"
meh
"
"
Tu
un
savi
uu
Yasi
'
Yuku
Iti
"
)
;
languageCodeToNameMap
.
put
(
"
mix
"
"
Tu
'
un
savi
"
)
;
languageCodeToNameMap
.
put
(
"
trs
"
"
Triqui
"
)
;
languageCodeToNameMap
.
put
(
"
zam
"
"
D
zt
"
)
;
languageCodeToNameMap
.
put
(
"
oc
"
"
occitan
"
)
;
languageCodeToNameMap
.
put
(
"
an
"
"
Aragon
s
"
)
;
languageCodeToNameMap
.
put
(
"
tt
"
"
"
)
;
languageCodeToNameMap
.
put
(
"
wo
"
"
Wolof
"
)
;
languageCodeToNameMap
.
put
(
"
anp
"
"
"
)
;
}
private
static
class
CharacterValidator
{
private
static
final
int
BITMAP_WIDTH
=
32
;
private
static
final
int
BITMAP_HEIGHT
=
48
;
private
final
Paint
paint
=
new
Paint
(
)
;
private
final
byte
[
]
missingCharacter
;
public
CharacterValidator
(
String
missing
)
{
this
.
missingCharacter
=
getPixels
(
drawBitmap
(
missing
)
)
;
}
private
Bitmap
drawBitmap
(
String
text
)
{
Bitmap
b
=
Bitmap
.
createBitmap
(
BITMAP_WIDTH
BITMAP_HEIGHT
Bitmap
.
Config
.
ALPHA_8
)
;
Canvas
c
=
new
Canvas
(
b
)
;
c
.
drawText
(
text
0
BITMAP_HEIGHT
/
2
this
.
paint
)
;
return
b
;
}
private
static
byte
[
]
getPixels
(
final
Bitmap
b
)
{
final
int
byteCount
=
b
.
getAllocationByteCount
(
)
;
final
ByteBuffer
buffer
=
ByteBuffer
.
allocate
(
byteCount
)
;
try
{
b
.
copyPixelsToBuffer
(
buffer
)
;
}
catch
(
RuntimeException
e
)
{
if
(
"
Buffer
not
large
enough
for
pixels
"
.
equals
(
e
.
getMessage
(
)
)
)
{
return
buffer
.
array
(
)
;
}
throw
e
;
}
return
buffer
.
array
(
)
;
}
public
boolean
characterIsMissingInFont
(
String
ch
)
{
byte
[
]
rendered
=
getPixels
(
drawBitmap
(
ch
)
)
;
return
Arrays
.
equals
(
rendered
missingCharacter
)
;
}
}
private
volatile
Locale
entriesLocale
;
private
CharacterValidator
characterValidator
;
public
LocaleListPreference
(
Context
context
)
{
this
(
context
null
)
;
}
public
LocaleListPreference
(
Context
context
AttributeSet
attributes
)
{
super
(
context
attributes
)
;
}
Override
protected
void
onAttachedToActivity
(
)
{
super
.
onAttachedToActivity
(
)
;
this
.
characterValidator
=
new
CharacterValidator
(
"
"
)
;
buildList
(
)
;
}
private
static
final
class
LocaleDescriptor
implements
Comparable
<
LocaleDescriptor
>
{
private
static
final
Collator
COLLATOR
=
Collator
.
getInstance
(
Locale
.
US
)
;
public
final
String
tag
;
private
final
String
nativeName
;
public
LocaleDescriptor
(
String
tag
)
{
this
(
Locales
.
parseLocaleCode
(
tag
)
tag
)
;
}
public
LocaleDescriptor
(
Locale
locale
String
tag
)
{
this
.
tag
=
tag
;
final
String
displayName
;
if
(
languageCodeToNameMap
.
containsKey
(
locale
.
getLanguage
(
)
)
)
{
displayName
=
languageCodeToNameMap
.
get
(
locale
.
getLanguage
(
)
)
;
}
else
{
displayName
=
locale
.
getDisplayName
(
locale
)
;
}
if
(
TextUtils
.
isEmpty
(
displayName
)
)
{
Log
.
w
(
LOG_TAG
"
Display
name
is
empty
.
Using
"
+
locale
.
toString
(
)
)
;
this
.
nativeName
=
locale
.
toString
(
)
;
return
;
}
final
byte
directionality
=
Character
.
getDirectionality
(
displayName
.
charAt
(
0
)
)
;
if
(
directionality
=
=
Character
.
DIRECTIONALITY_LEFT_TO_RIGHT
)
{
this
.
nativeName
=
displayName
.
substring
(
0
1
)
.
toUpperCase
(
locale
)
+
displayName
.
substring
(
1
)
;
return
;
}
this
.
nativeName
=
displayName
;
}
public
String
getTag
(
)
{
return
this
.
tag
;
}
public
String
getDisplayName
(
)
{
return
this
.
nativeName
;
}
Override
public
String
toString
(
)
{
return
this
.
nativeName
;
}
Override
public
boolean
equals
(
Object
obj
)
{
if
(
obj
instanceof
LocaleDescriptor
)
{
return
compareTo
(
(
LocaleDescriptor
)
obj
)
=
=
0
;
}
else
{
return
false
;
}
}
Override
public
int
hashCode
(
)
{
return
tag
.
hashCode
(
)
;
}
Override
public
int
compareTo
(
LocaleDescriptor
another
)
{
return
COLLATOR
.
compare
(
this
.
nativeName
another
.
nativeName
)
;
}
public
boolean
isUsable
(
CharacterValidator
validator
)
{
if
(
this
.
tag
.
equals
(
"
bn
-
IN
"
)
)
{
if
(
!
this
.
nativeName
.
startsWith
(
"
"
)
)
{
return
false
;
}
}
if
(
this
.
tag
.
equals
(
"
or
"
)
|
|
this
.
tag
.
equals
(
"
my
"
)
|
|
this
.
tag
.
equals
(
"
pa
-
IN
"
)
|
|
this
.
tag
.
equals
(
"
gu
-
IN
"
)
|
|
this
.
tag
.
equals
(
"
bn
-
IN
"
)
)
{
if
(
validator
.
characterIsMissingInFont
(
this
.
nativeName
.
substring
(
0
1
)
)
)
{
return
false
;
}
}
return
true
;
}
}
private
LocaleDescriptor
[
]
getUsableLocales
(
)
{
final
Collection
<
String
>
shippingLocales
=
LocaleManager
.
getPackagedLocaleTags
(
getContext
(
)
)
;
final
int
initialCount
=
shippingLocales
.
size
(
)
;
final
Set
<
LocaleDescriptor
>
locales
=
new
HashSet
<
>
(
initialCount
)
;
for
(
String
tag
:
shippingLocales
)
{
final
LocaleDescriptor
descriptor
=
new
LocaleDescriptor
(
tag
)
;
if
(
!
descriptor
.
isUsable
(
this
.
characterValidator
)
)
{
Log
.
w
(
LOG_TAG
"
Skipping
locale
"
+
tag
+
"
on
this
device
.
"
)
;
continue
;
}
locales
.
add
(
descriptor
)
;
}
final
int
usableCount
=
locales
.
size
(
)
;
final
LocaleDescriptor
[
]
descriptors
=
locales
.
toArray
(
new
LocaleDescriptor
[
usableCount
]
)
;
Arrays
.
sort
(
descriptors
0
usableCount
)
;
return
descriptors
;
}
Override
protected
void
onDialogClosed
(
boolean
positiveResult
)
{
super
.
onDialogClosed
(
positiveResult
)
;
final
Locale
selectedLocale
=
getSelectedLocale
(
)
;
final
Context
context
=
getContext
(
)
;
LocaleManager
.
getInstance
(
)
.
updateConfiguration
(
context
selectedLocale
)
;
}
private
Locale
getSelectedLocale
(
)
{
final
String
tag
=
getValue
(
)
;
if
(
tag
=
=
null
|
|
tag
.
equals
(
"
"
)
)
{
return
Locale
.
getDefault
(
)
;
}
return
Locales
.
parseLocaleCode
(
tag
)
;
}
Override
public
CharSequence
getSummary
(
)
{
final
String
value
=
getValue
(
)
;
if
(
TextUtils
.
isEmpty
(
value
)
)
{
return
getContext
(
)
.
getString
(
R
.
string
.
preference_language_systemdefault
)
;
}
return
new
LocaleDescriptor
(
value
)
.
getDisplayName
(
)
;
}
private
void
buildList
(
)
{
final
Locale
currentLocale
=
Locale
.
getDefault
(
)
;
Log
.
d
(
LOG_TAG
"
Building
locales
list
.
Current
locale
:
"
+
currentLocale
)
;
if
(
currentLocale
.
equals
(
this
.
entriesLocale
)
&
&
getEntries
(
)
!
=
null
)
{
Log
.
v
(
LOG_TAG
"
No
need
to
build
list
.
"
)
;
return
;
}
final
LocaleDescriptor
[
]
descriptors
=
getUsableLocales
(
)
;
final
int
count
=
descriptors
.
length
;
this
.
entriesLocale
=
currentLocale
;
final
String
[
]
entries
=
new
String
[
count
+
1
]
;
final
String
[
]
values
=
new
String
[
count
+
1
]
;
entries
[
0
]
=
getContext
(
)
.
getString
(
R
.
string
.
preference_language_systemdefault
)
;
values
[
0
]
=
"
"
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
final
String
displayName
=
descriptors
[
i
]
.
getDisplayName
(
)
;
final
String
tag
=
descriptors
[
i
]
.
getTag
(
)
;
Log
.
v
(
LOG_TAG
displayName
+
"
=
>
"
+
tag
)
;
entries
[
i
+
1
]
=
displayName
;
values
[
i
+
1
]
=
tag
;
}
setEntries
(
entries
)
;
setEntryValues
(
values
)
;
}
}
