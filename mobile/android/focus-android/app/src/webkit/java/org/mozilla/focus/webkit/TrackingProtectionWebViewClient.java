package
org
.
mozilla
.
focus
.
webkit
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
net
.
http
.
SslError
;
import
android
.
os
.
AsyncTask
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
webkit
.
SslErrorHandler
;
import
android
.
webkit
.
WebResourceRequest
;
import
android
.
webkit
.
WebResourceResponse
;
import
android
.
webkit
.
WebView
;
import
android
.
webkit
.
WebViewClient
;
import
org
.
mozilla
.
focus
.
R
;
import
org
.
mozilla
.
focus
.
webkit
.
matcher
.
UrlMatcher
;
public
class
TrackingProtectionWebViewClient
extends
WebViewClient
{
final
static
String
ERROR_PROTOCOL
=
"
error
:
"
;
private
String
currentPageURL
;
private
static
volatile
UrlMatcher
MATCHER
;
public
static
void
triggerPreload
(
final
Context
context
)
{
if
(
MATCHER
=
=
null
)
{
new
AsyncTask
<
Void
Void
Void
>
(
)
{
Override
protected
Void
doInBackground
(
Void
.
.
.
voids
)
{
getMatcher
(
context
)
;
return
null
;
}
}
.
execute
(
)
;
}
}
WorkerThread
private
static
synchronized
UrlMatcher
getMatcher
(
final
Context
context
)
{
if
(
MATCHER
=
=
null
)
{
MATCHER
=
UrlMatcher
.
loadMatcher
(
context
R
.
raw
.
blocklist
new
int
[
]
{
R
.
raw
.
google_mapping
}
R
.
raw
.
entitylist
)
;
}
return
MATCHER
;
}
public
TrackingProtectionWebViewClient
(
final
Context
context
)
{
triggerPreload
(
context
)
;
}
Override
public
WebResourceResponse
shouldInterceptRequest
(
WebView
view
WebResourceRequest
request
)
{
final
String
scheme
=
request
.
getUrl
(
)
.
getScheme
(
)
;
if
(
!
request
.
isForMainFrame
(
)
&
&
!
scheme
.
equals
(
"
http
"
)
&
&
!
scheme
.
equals
(
"
https
"
)
)
{
return
new
WebResourceResponse
(
null
null
null
)
;
}
final
UrlMatcher
matcher
=
getMatcher
(
view
.
getContext
(
)
)
;
if
(
(
!
request
.
isForMainFrame
(
)
)
&
&
matcher
.
matches
(
request
.
getUrl
(
)
.
toString
(
)
currentPageURL
)
)
{
return
new
WebResourceResponse
(
null
null
null
)
;
}
return
super
.
shouldInterceptRequest
(
view
request
)
;
}
public
void
notifyCurrentURL
(
final
String
url
)
{
currentPageURL
=
url
;
}
Override
public
void
onPageStarted
(
WebView
view
String
url
Bitmap
favicon
)
{
currentPageURL
=
url
;
super
.
onPageStarted
(
view
url
favicon
)
;
}
Override
public
boolean
shouldOverrideUrlLoading
(
WebView
view
String
url
)
{
currentPageURL
=
url
;
return
super
.
shouldOverrideUrlLoading
(
view
url
)
;
}
Override
public
void
onReceivedError
(
final
WebView
webView
int
errorCode
final
String
description
String
failingUrl
)
{
if
(
failingUrl
.
startsWith
(
ERROR_PROTOCOL
)
)
{
final
int
errorCodePosition
=
ERROR_PROTOCOL
.
length
(
)
;
final
String
errorCodeString
=
failingUrl
.
substring
(
errorCodePosition
)
;
int
desiredErrorCode
;
try
{
desiredErrorCode
=
Integer
.
parseInt
(
errorCodeString
)
;
if
(
!
ErrorPage
.
supportsErrorCode
(
desiredErrorCode
)
)
{
desiredErrorCode
=
WebViewClient
.
ERROR_BAD_URL
;
}
}
catch
(
final
NumberFormatException
e
)
{
desiredErrorCode
=
WebViewClient
.
ERROR_BAD_URL
;
}
ErrorPage
.
loadErrorPage
(
webView
failingUrl
desiredErrorCode
)
;
return
;
}
if
(
failingUrl
.
equals
(
currentPageURL
)
&
&
ErrorPage
.
supportsErrorCode
(
errorCode
)
)
{
ErrorPage
.
loadErrorPage
(
webView
currentPageURL
errorCode
)
;
return
;
}
super
.
onReceivedError
(
webView
errorCode
description
failingUrl
)
;
}
Override
public
void
onReceivedSslError
(
WebView
view
SslErrorHandler
handler
SslError
error
)
{
handler
.
cancel
(
)
;
if
(
error
.
getUrl
(
)
.
equals
(
currentPageURL
)
)
{
ErrorPage
.
loadErrorPage
(
view
error
.
getUrl
(
)
WebViewClient
.
ERROR_FAILED_SSL_HANDSHAKE
)
;
}
}
}
