package
org
.
mozilla
.
focus
.
webkit
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
net
.
Uri
;
import
android
.
net
.
http
.
SslError
;
import
android
.
os
.
AsyncTask
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
webkit
.
SslErrorHandler
;
import
android
.
webkit
.
WebResourceRequest
;
import
android
.
webkit
.
WebResourceResponse
;
import
android
.
webkit
.
WebView
;
import
android
.
webkit
.
WebViewClient
;
import
org
.
mozilla
.
focus
.
R
;
import
org
.
mozilla
.
focus
.
web
.
BrowsingSession
;
import
org
.
mozilla
.
focus
.
webkit
.
matcher
.
UrlMatcher
;
public
class
TrackingProtectionWebViewClient
extends
WebViewClient
{
private
static
volatile
UrlMatcher
MATCHER
;
private
boolean
blockingEnabled
;
String
currentPageURL
;
public
static
void
triggerPreload
(
final
Context
context
)
{
if
(
MATCHER
=
=
null
)
{
new
AsyncTask
<
Void
Void
Void
>
(
)
{
Override
protected
Void
doInBackground
(
Void
.
.
.
voids
)
{
getMatcher
(
context
)
;
return
null
;
}
}
.
execute
(
)
;
}
}
WorkerThread
private
static
synchronized
UrlMatcher
getMatcher
(
final
Context
context
)
{
if
(
MATCHER
=
=
null
)
{
MATCHER
=
UrlMatcher
.
loadMatcher
(
context
R
.
raw
.
blocklist
new
int
[
]
{
R
.
raw
.
google_mapping
}
R
.
raw
.
entitylist
)
;
}
return
MATCHER
;
}
TrackingProtectionWebViewClient
(
final
Context
context
)
{
triggerPreload
(
context
)
;
this
.
blockingEnabled
=
true
;
}
public
void
setBlockingEnabled
(
boolean
enabled
)
{
this
.
blockingEnabled
=
enabled
;
}
public
boolean
isBlockingEnabled
(
)
{
return
blockingEnabled
;
}
Override
public
WebResourceResponse
shouldInterceptRequest
(
final
WebView
view
final
WebResourceRequest
request
)
{
if
(
!
blockingEnabled
)
{
return
super
.
shouldInterceptRequest
(
view
request
)
;
}
final
Uri
resourceUri
=
request
.
getUrl
(
)
;
final
String
scheme
=
resourceUri
.
getScheme
(
)
;
if
(
!
request
.
isForMainFrame
(
)
&
&
!
scheme
.
equals
(
"
http
"
)
&
&
!
scheme
.
equals
(
"
https
"
)
)
{
return
new
WebResourceResponse
(
null
null
null
)
;
}
final
String
path
=
resourceUri
.
getPath
(
)
;
if
(
path
!
=
null
&
&
path
.
endsWith
(
"
/
favicon
.
ico
"
)
)
{
return
new
WebResourceResponse
(
null
null
null
)
;
}
final
UrlMatcher
matcher
=
getMatcher
(
view
.
getContext
(
)
)
;
final
Uri
pageUri
=
Uri
.
parse
(
currentPageURL
)
;
if
(
(
!
request
.
isForMainFrame
(
)
)
&
&
matcher
.
matches
(
resourceUri
pageUri
)
)
{
BrowsingSession
.
getInstance
(
)
.
countBlockedTracker
(
)
;
return
new
WebResourceResponse
(
null
null
null
)
;
}
return
super
.
shouldInterceptRequest
(
view
request
)
;
}
public
void
notifyCurrentURL
(
final
String
url
)
{
currentPageURL
=
url
;
}
Override
public
void
onPageStarted
(
WebView
view
String
url
Bitmap
favicon
)
{
if
(
blockingEnabled
)
{
BrowsingSession
.
getInstance
(
)
.
resetTrackerCount
(
)
;
}
currentPageURL
=
url
;
super
.
onPageStarted
(
view
url
favicon
)
;
}
}
