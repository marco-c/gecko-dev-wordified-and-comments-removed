package
org
.
mozilla
.
focus
.
webkit
.
matcher
;
import
android
.
content
.
Context
;
import
android
.
util
.
JsonReader
;
import
org
.
mozilla
.
focus
.
webkit
.
matcher
.
util
.
FocusString
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URL
;
import
java
.
util
.
HashSet
;
public
class
UrlMatcher
{
private
final
Trie
rootTrie
=
Trie
.
createRootNode
(
)
;
private
final
EntityList
entityList
;
private
final
HashSet
<
String
>
previouslyMatched
=
new
HashSet
<
>
(
)
;
private
final
HashSet
<
String
>
previouslyUnmatched
=
new
HashSet
<
>
(
)
;
public
UrlMatcher
(
final
Context
context
final
int
blockListFile
final
int
entityListFile
)
{
{
InputStream
inputStream
=
context
.
getResources
(
)
.
openRawResource
(
blockListFile
)
;
JsonReader
jsonReader
=
new
JsonReader
(
new
InputStreamReader
(
inputStream
)
)
;
try
{
new
BlocklistProcessor
(
jsonReader
this
)
;
jsonReader
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
IllegalStateException
(
"
Unable
to
parse
blacklist
"
)
;
}
}
{
InputStream
inputStream
=
context
.
getResources
(
)
.
openRawResource
(
entityListFile
)
;
JsonReader
jsonReader
=
new
JsonReader
(
new
InputStreamReader
(
inputStream
)
)
;
try
{
entityList
=
EntityListProcessor
.
getEntityMapFromJSON
(
jsonReader
)
;
}
catch
(
IOException
e
)
{
throw
new
IllegalStateException
(
"
Unable
to
parse
entity
list
"
)
;
}
}
}
UrlMatcher
(
final
String
[
]
patterns
)
{
buildMatcher
(
patterns
)
;
entityList
=
null
;
}
private
void
buildMatcher
(
String
[
]
patterns
)
{
for
(
final
String
pattern
:
patterns
)
{
putURL
(
pattern
)
;
}
}
void
putURL
(
final
String
url
)
{
rootTrie
.
put
(
FocusString
.
create
(
url
)
.
reverse
(
)
)
;
}
public
boolean
matches
(
final
String
resourceURLString
final
String
pageURLString
)
{
if
(
previouslyUnmatched
.
contains
(
resourceURLString
)
)
{
return
false
;
}
if
(
entityList
!
=
null
&
&
entityList
.
isWhiteListed
(
pageURLString
resourceURLString
)
)
{
return
false
;
}
if
(
previouslyMatched
.
contains
(
resourceURLString
)
)
{
return
true
;
}
try
{
final
String
host
=
new
URL
(
resourceURLString
)
.
getHost
(
)
.
toString
(
)
;
final
FocusString
revhost
=
FocusString
.
create
(
host
)
.
reverse
(
)
;
if
(
rootTrie
.
findNode
(
revhost
)
!
=
null
)
{
previouslyMatched
.
add
(
resourceURLString
)
;
return
true
;
}
}
catch
(
MalformedURLException
e
)
{
throw
new
IllegalArgumentException
(
"
Unable
to
handle
malformed
resource
URL
"
)
;
}
previouslyUnmatched
.
add
(
resourceURLString
)
;
return
false
;
}
}
