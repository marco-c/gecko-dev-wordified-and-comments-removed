package
org
.
mozilla
.
focus
.
webkit
.
matcher
;
import
android
.
content
.
Context
;
import
android
.
support
.
v4
.
util
.
ArrayMap
;
import
android
.
util
.
JsonReader
;
import
org
.
mozilla
.
focus
.
webkit
.
matcher
.
util
.
FocusString
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URL
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
public
class
UrlMatcher
{
private
final
Map
<
String
Trie
>
categories
=
new
ArrayMap
<
>
(
5
)
;
private
final
Set
<
String
>
enabledCategories
=
new
HashSet
<
>
(
)
;
private
final
EntityList
entityList
;
private
final
HashSet
<
String
>
previouslyMatched
=
new
HashSet
<
>
(
)
;
private
final
HashSet
<
String
>
previouslyUnmatched
=
new
HashSet
<
>
(
)
;
public
UrlMatcher
(
final
Context
context
final
int
blockListFile
final
int
entityListFile
)
{
{
InputStream
inputStream
=
context
.
getResources
(
)
.
openRawResource
(
blockListFile
)
;
JsonReader
jsonReader
=
new
JsonReader
(
new
InputStreamReader
(
inputStream
)
)
;
try
{
new
BlocklistProcessor
(
jsonReader
this
)
;
jsonReader
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
IllegalStateException
(
"
Unable
to
parse
blacklist
"
)
;
}
}
{
InputStream
inputStream
=
context
.
getResources
(
)
.
openRawResource
(
entityListFile
)
;
JsonReader
jsonReader
=
new
JsonReader
(
new
InputStreamReader
(
inputStream
)
)
;
try
{
entityList
=
EntityListProcessor
.
getEntityMapFromJSON
(
jsonReader
)
;
}
catch
(
IOException
e
)
{
throw
new
IllegalStateException
(
"
Unable
to
parse
entity
list
"
)
;
}
}
}
UrlMatcher
(
final
String
[
]
patterns
)
{
buildMatcher
(
patterns
)
;
entityList
=
null
;
}
private
void
buildMatcher
(
String
[
]
patterns
)
{
final
Trie
defaultCategory
;
if
(
!
categories
.
containsKey
(
"
default
"
)
)
{
defaultCategory
=
Trie
.
createRootNode
(
)
;
}
else
{
defaultCategory
=
categories
.
get
(
"
default
"
)
;
}
for
(
final
String
pattern
:
patterns
)
{
defaultCategory
.
put
(
FocusString
.
create
(
pattern
)
.
reverse
(
)
)
;
}
}
void
putCategories
(
final
Map
<
String
Trie
>
categoryMap
)
{
for
(
final
Map
.
Entry
<
String
Trie
>
entry
:
categoryMap
.
entrySet
(
)
)
{
if
(
categories
.
containsKey
(
entry
.
getKey
(
)
)
)
{
throw
new
IllegalStateException
(
"
Can
'
t
add
existing
category
"
)
;
}
else
{
categories
.
put
(
entry
.
getKey
(
)
entry
.
getValue
(
)
)
;
enabledCategories
.
add
(
entry
.
getKey
(
)
)
;
}
}
}
public
Set
<
String
>
getCategories
(
)
{
return
categories
.
keySet
(
)
;
}
public
void
setCategoryEnabled
(
final
String
category
final
boolean
enabled
)
{
if
(
!
getCategories
(
)
.
contains
(
category
)
)
{
throw
new
IllegalArgumentException
(
"
Can
'
t
enable
/
disable
inexistant
category
"
)
;
}
if
(
enabled
)
{
if
(
enabledCategories
.
contains
(
category
)
)
{
return
;
}
else
{
enabledCategories
.
add
(
category
)
;
previouslyUnmatched
.
clear
(
)
;
}
}
else
{
if
(
!
enabledCategories
.
contains
(
category
)
)
{
return
;
}
else
{
enabledCategories
.
remove
(
category
)
;
previouslyMatched
.
clear
(
)
;
}
}
}
public
boolean
matches
(
final
String
resourceURLString
final
String
pageURLString
)
{
if
(
previouslyUnmatched
.
contains
(
resourceURLString
)
)
{
return
false
;
}
if
(
entityList
!
=
null
&
&
entityList
.
isWhiteListed
(
pageURLString
resourceURLString
)
)
{
return
false
;
}
if
(
previouslyMatched
.
contains
(
resourceURLString
)
)
{
return
true
;
}
try
{
final
String
host
=
new
URL
(
resourceURLString
)
.
getHost
(
)
.
toString
(
)
;
final
FocusString
revhost
=
FocusString
.
create
(
host
)
.
reverse
(
)
;
for
(
final
Map
.
Entry
<
String
Trie
>
category
:
categories
.
entrySet
(
)
)
{
if
(
enabledCategories
.
contains
(
category
.
getKey
(
)
)
)
{
if
(
category
.
getValue
(
)
.
findNode
(
revhost
)
!
=
null
)
{
previouslyMatched
.
add
(
resourceURLString
)
;
return
true
;
}
}
}
}
catch
(
MalformedURLException
e
)
{
throw
new
IllegalArgumentException
(
"
Unable
to
handle
malformed
resource
URL
"
)
;
}
previouslyUnmatched
.
add
(
resourceURLString
)
;
return
false
;
}
}
