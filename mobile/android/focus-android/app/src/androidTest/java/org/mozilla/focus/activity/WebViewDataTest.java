package
org
.
mozilla
.
focus
.
activity
;
import
android
.
content
.
Context
;
import
android
.
preference
.
PreferenceManager
;
import
android
.
support
.
test
.
InstrumentationRegistry
;
import
android
.
support
.
test
.
rule
.
ActivityTestRule
;
import
android
.
support
.
test
.
runner
.
AndroidJUnit4
;
import
android
.
support
.
test
.
uiautomator
.
UiObject
;
import
android
.
support
.
test
.
uiautomator
.
UiObjectNotFoundException
;
import
android
.
support
.
test
.
uiautomator
.
UiSelector
;
import
junit
.
framework
.
Assert
;
import
org
.
junit
.
Rule
;
import
org
.
junit
.
Test
;
import
org
.
junit
.
runner
.
RunWith
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
okhttp3
.
mockwebserver
.
MockResponse
;
import
okhttp3
.
mockwebserver
.
MockWebServer
;
import
okhttp3
.
mockwebserver
.
RecordedRequest
;
import
static
android
.
support
.
test
.
espresso
.
action
.
ViewActions
.
click
;
import
static
org
.
junit
.
Assert
.
assertFalse
;
import
static
org
.
junit
.
Assert
.
assertTrue
;
import
static
org
.
mozilla
.
focus
.
fragment
.
FirstrunFragment
.
FIRSTRUN_PREF
;
RunWith
(
AndroidJUnit4
.
class
)
public
class
WebViewDataTest
{
private
static
final
List
<
String
>
WHITELIST
=
Arrays
.
asList
(
"
cache
"
"
code_cache
"
"
shared_prefs
"
"
app_dxmaker_cache
"
"
telemetry
"
"
databases
"
)
;
private
static
final
String
TEST_PATH
=
"
/
copper
/
truck
/
destroy
?
smoke
=
violet
#
bizarre
"
;
private
static
final
List
<
String
>
TEST_TRACES
=
Arrays
.
asList
(
"
localhost
"
"
copper
"
"
truck
"
"
destroy
"
"
smoke
"
"
violet
"
"
bizarre
"
"
groovy
"
"
rabbits
"
"
gigantic
"
"
experience
"
"
birthday
"
"
armchair
"
"
sphere
"
"
battery
"
"
KANGAROO
"
)
;
private
Context
appContext
;
private
MockWebServer
webServer
;
Rule
public
ActivityTestRule
<
MainActivity
>
mActivityTestRule
=
new
ActivityTestRule
<
MainActivity
>
(
MainActivity
.
class
)
{
Override
protected
void
beforeActivityLaunched
(
)
{
super
.
beforeActivityLaunched
(
)
;
appContext
=
InstrumentationRegistry
.
getInstrumentation
(
)
.
getTargetContext
(
)
.
getApplicationContext
(
)
;
PreferenceManager
.
getDefaultSharedPreferences
(
appContext
)
.
edit
(
)
.
putBoolean
(
FIRSTRUN_PREF
true
)
.
apply
(
)
;
webServer
=
new
MockWebServer
(
)
;
try
{
webServer
.
enqueue
(
new
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
test
.
html
"
)
)
.
addHeader
(
"
Set
-
Cookie
"
"
sphere
=
battery
;
Expires
=
Wed
21
Oct
2035
07
:
28
:
00
GMT
;
"
)
)
;
webServer
.
enqueue
(
new
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
service
-
worker
.
js
"
)
)
.
setHeader
(
"
Content
-
Type
"
"
text
/
javascript
"
)
)
;
webServer
.
start
(
)
;
}
catch
(
IOException
e
)
{
throw
new
AssertionError
(
"
Could
not
start
web
server
"
e
)
;
}
}
Override
protected
void
afterActivityFinished
(
)
{
super
.
afterActivityFinished
(
)
;
try
{
webServer
.
shutdown
(
)
;
}
catch
(
IOException
e
)
{
throw
new
AssertionError
(
"
Could
not
stop
web
server
"
e
)
;
}
}
}
;
Test
public
void
DeleteWebViewDataTest
(
)
throws
InterruptedException
UiObjectNotFoundException
IOException
{
final
long
waitingTime
=
TestHelper
.
waitingTime
;
TestHelper
.
urlBar
.
waitForExists
(
waitingTime
)
;
TestHelper
.
urlBar
.
click
(
)
;
TestHelper
.
inlineAutocompleteEditText
.
waitForExists
(
waitingTime
)
;
TestHelper
.
inlineAutocompleteEditText
.
clearTextField
(
)
;
TestHelper
.
inlineAutocompleteEditText
.
setText
(
webServer
.
url
(
TEST_PATH
)
.
toString
(
)
)
;
TestHelper
.
hint
.
waitForExists
(
waitingTime
)
;
TestHelper
.
pressEnterKey
(
)
;
TestHelper
.
webView
.
waitForExists
(
waitingTime
)
;
final
UiObject
titleMsg
=
TestHelper
.
mDevice
.
findObject
(
new
UiSelector
(
)
.
description
(
"
focus
test
page
"
)
.
enabled
(
true
)
)
;
titleMsg
.
waitForExists
(
waitingTime
)
;
assertTrue
(
"
Website
title
loaded
"
titleMsg
.
exists
(
)
)
;
final
UiObject
cookieMsg
=
TestHelper
.
mDevice
.
findObject
(
new
UiSelector
(
)
.
description
(
"
Cookie
saved
"
)
.
enabled
(
true
)
)
;
cookieMsg
.
waitForExists
(
waitingTime
)
;
assertTrue
(
"
Cookie
is
saved
"
cookieMsg
.
exists
(
)
)
;
final
UiObject
serviceWorkerMsg
=
TestHelper
.
mDevice
.
findObject
(
new
UiSelector
(
)
.
description
(
"
Service
worker
installed
"
)
.
enabled
(
true
)
)
;
serviceWorkerMsg
.
waitForExists
(
waitingTime
)
;
assertTrue
(
"
Service
worker
installed
"
serviceWorkerMsg
.
exists
(
)
)
;
Thread
.
sleep
(
5000
)
;
TestHelper
.
floatingEraseButton
.
perform
(
click
(
)
)
;
TestHelper
.
erasedMsg
.
waitForExists
(
waitingTime
)
;
Assert
.
assertTrue
(
TestHelper
.
erasedMsg
.
exists
(
)
)
;
Assert
.
assertTrue
(
TestHelper
.
urlBar
.
exists
(
)
)
;
TestHelper
.
waitForIdle
(
)
;
assertPathsHaveBeenRequested
(
webServer
"
/
copper
/
truck
/
destroy
?
smoke
=
violet
"
"
/
favicon
.
ico
"
"
/
copper
/
truck
/
service
-
worker
.
js
"
)
;
final
File
dataDir
=
new
File
(
appContext
.
getApplicationInfo
(
)
.
dataDir
)
;
assertTrue
(
"
App
data
directory
should
exist
"
dataDir
.
exists
(
)
)
;
final
File
webViewDirectory
=
new
File
(
dataDir
"
app_webview
"
)
;
assertFalse
(
"
WebView
directory
should
not
exist
"
webViewDirectory
.
exists
(
)
)
;
assertIsEmpty
(
appContext
.
getCacheDir
(
)
)
;
for
(
final
String
name
:
dataDir
.
list
(
)
)
{
assertTrue
(
"
Check
'
"
+
name
+
"
'
is
in
whitelist
"
WHITELIST
.
contains
(
name
)
)
;
}
assertNoTraces
(
dataDir
)
;
}
private
void
assertPathsHaveBeenRequested
(
MockWebServer
webServer
String
.
.
.
paths
)
throws
InterruptedException
{
final
List
<
String
>
expectedPaths
=
new
ArrayList
<
>
(
paths
.
length
)
;
Collections
.
addAll
(
expectedPaths
paths
)
;
RecordedRequest
request
;
while
(
(
request
=
webServer
.
takeRequest
(
TestHelper
.
waitingTime
TimeUnit
.
MILLISECONDS
)
)
!
=
null
)
{
if
(
!
expectedPaths
.
remove
(
request
.
getPath
(
)
)
)
{
throw
new
AssertionError
(
"
Unknown
path
requested
:
"
+
request
.
getPath
(
)
)
;
}
}
if
(
!
expectedPaths
.
isEmpty
(
)
)
{
throw
new
AssertionError
(
"
Expected
paths
not
requested
:
"
+
expectedPaths
)
;
}
}
private
void
assertNoTraces
(
File
directory
)
throws
IOException
{
for
(
final
String
name
:
directory
.
list
(
)
)
{
final
File
file
=
new
File
(
directory
name
)
;
if
(
file
.
isDirectory
(
)
)
{
assertNoTraces
(
file
)
;
continue
;
}
final
String
content
=
readFileToString
(
file
)
;
for
(
String
trace
:
TEST_TRACES
)
{
assertFalse
(
"
File
'
"
+
name
+
"
'
should
not
contain
any
traces
of
browser
session
(
"
+
trace
+
"
path
=
"
+
file
.
getAbsolutePath
(
)
+
"
)
"
content
.
contains
(
trace
)
)
;
}
}
}
private
String
readFileToString
(
File
file
)
throws
IOException
{
System
.
out
.
println
(
"
Reading
file
:
"
+
file
.
getAbsolutePath
(
)
)
;
try
(
final
FileInputStream
stream
=
new
FileInputStream
(
file
)
)
{
return
readStreamIntoString
(
stream
)
;
}
}
private
void
assertIsEmpty
(
File
directory
)
{
assertTrue
(
directory
.
isDirectory
(
)
&
&
directory
.
list
(
)
.
length
=
=
0
)
;
}
private
String
readTestAsset
(
String
filename
)
throws
IOException
{
try
(
final
InputStream
stream
=
InstrumentationRegistry
.
getContext
(
)
.
getAssets
(
)
.
open
(
filename
)
)
{
return
readStreamIntoString
(
stream
)
;
}
}
private
String
readStreamIntoString
(
InputStream
stream
)
throws
IOException
{
try
(
final
BufferedReader
reader
=
new
BufferedReader
(
new
InputStreamReader
(
stream
)
)
)
{
final
StringBuilder
builder
=
new
StringBuilder
(
)
;
String
line
;
while
(
(
line
=
reader
.
readLine
(
)
)
!
=
null
)
{
builder
.
append
(
line
)
;
}
reader
.
close
(
)
;
return
builder
.
toString
(
)
;
}
}
}
