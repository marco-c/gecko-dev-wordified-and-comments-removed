package
org
.
mozilla
.
focus
.
activity
import
androidx
.
test
.
espresso
.
Espresso
import
androidx
.
test
.
espresso
.
IdlingRegistry
import
androidx
.
test
.
espresso
.
action
.
ViewActions
import
androidx
.
test
.
espresso
.
assertion
.
ViewAssertions
import
androidx
.
test
.
espresso
.
matcher
.
ViewMatchers
import
androidx
.
test
.
internal
.
runner
.
junit4
.
AndroidJUnit4ClassRunner
import
okhttp3
.
mockwebserver
.
MockResponse
import
okhttp3
.
mockwebserver
.
MockWebServer
import
org
.
hamcrest
.
Matchers
import
org
.
junit
.
After
import
org
.
junit
.
Before
import
org
.
junit
.
Rule
import
org
.
junit
.
Test
import
org
.
junit
.
runner
.
RunWith
import
org
.
mozilla
.
focus
.
R
import
org
.
mozilla
.
focus
.
helpers
.
MainActivityFirstrunTestRule
import
org
.
mozilla
.
focus
.
helpers
.
SessionLoadedIdlingResource
import
org
.
mozilla
.
focus
.
helpers
.
TestHelper
import
org
.
mozilla
.
focus
.
helpers
.
TestHelper
.
pressBackKey
import
org
.
mozilla
.
focus
.
helpers
.
TestHelper
.
readTestAsset
import
org
.
mozilla
.
focus
.
helpers
.
TestHelper
.
waitForWebContent
import
org
.
mozilla
.
focus
.
helpers
.
TestHelper
.
waitingTime
import
java
.
io
.
IOException
RunWith
(
AndroidJUnit4ClassRunner
:
:
class
)
class
ToggleBlockTest
{
private
var
webServer
:
MockWebServer
?
=
null
private
var
loadingIdlingResource
:
SessionLoadedIdlingResource
?
=
null
get
:
Rule
var
mActivityTestRule
=
MainActivityFirstrunTestRule
(
showFirstRun
=
false
)
Before
fun
setUp
(
)
{
loadingIdlingResource
=
SessionLoadedIdlingResource
(
)
IdlingRegistry
.
getInstance
(
)
.
register
(
loadingIdlingResource
)
webServer
=
MockWebServer
(
)
try
{
webServer
!
!
.
enqueue
(
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
ad
.
html
"
)
)
)
webServer
!
!
.
enqueue
(
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
ad
.
html
"
)
)
)
webServer
!
!
.
enqueue
(
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
ad
.
html
"
)
)
)
webServer
!
!
.
start
(
)
}
catch
(
e
:
IOException
)
{
throw
AssertionError
(
"
Could
not
start
web
server
"
e
)
}
}
After
fun
tearDown
(
)
{
mActivityTestRule
.
activity
.
finishAndRemoveTask
(
)
IdlingRegistry
.
getInstance
(
)
.
unregister
(
loadingIdlingResource
)
try
{
webServer
!
!
.
close
(
)
webServer
!
!
.
shutdown
(
)
}
catch
(
e
:
IOException
)
{
throw
AssertionError
(
"
Could
not
stop
web
server
"
e
)
}
}
Suppress
(
"
LongMethod
"
)
Test
fun
SimpleToggleTest
(
)
{
TestHelper
.
inlineAutocompleteEditText
.
waitForExists
(
TestHelper
.
waitingTime
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
urlView
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
isDisplayed
(
)
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
hasFocus
(
)
)
)
.
perform
(
ViewActions
.
typeText
(
webServer
!
!
.
url
(
TEST_PATH
)
.
toString
(
)
)
ViewActions
.
pressImeActionButton
(
)
)
waitForWebContent
(
)
TestHelper
.
progressBar
.
waitUntilGone
(
TestHelper
.
waitingTime
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
block
)
)
.
check
(
ViewAssertions
.
matches
(
Matchers
.
not
(
ViewMatchers
.
isDisplayed
(
)
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
menuView
)
)
.
perform
(
ViewActions
.
click
(
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
trackers_count
)
)
.
check
(
ViewAssertions
.
matches
(
Matchers
.
not
(
ViewMatchers
.
withText
(
"
-
"
)
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
blocking_switch
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
isChecked
(
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
blocking_switch
)
)
.
perform
(
ViewActions
.
click
(
)
)
waitForWebContent
(
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
block
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
isDisplayed
(
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
webview
)
)
.
perform
(
ViewActions
.
click
(
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
menuView
)
)
.
perform
(
ViewActions
.
click
(
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
blocking_switch
)
)
.
check
(
ViewAssertions
.
matches
(
Matchers
.
not
(
ViewMatchers
.
isChecked
(
)
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
trackers_count
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
withText
(
"
-
"
)
)
)
pressBackKey
(
)
TestHelper
.
floatingEraseButton
.
perform
(
ViewActions
.
click
(
)
)
TestHelper
.
erasedMsg
.
waitForExists
(
waitingTime
)
try
{
webServer
!
!
.
enqueue
(
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
ad
.
html
"
)
)
)
webServer
!
!
.
enqueue
(
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
ad
.
html
"
)
)
)
webServer
!
!
.
enqueue
(
MockResponse
(
)
.
setBody
(
readTestAsset
(
"
ad
.
html
"
)
)
)
}
catch
(
e
:
IOException
)
{
throw
AssertionError
(
"
Could
not
start
web
server
"
e
)
}
TestHelper
.
inlineAutocompleteEditText
.
waitForExists
(
TestHelper
.
waitingTime
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
urlView
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
isDisplayed
(
)
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
hasFocus
(
)
)
)
.
perform
(
ViewActions
.
typeText
(
webServer
!
!
.
url
(
TEST_PATH
)
.
toString
(
)
)
ViewActions
.
pressImeActionButton
(
)
)
waitForWebContent
(
)
TestHelper
.
progressBar
.
waitUntilGone
(
TestHelper
.
waitingTime
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
block
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
isDisplayed
(
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
menuView
)
)
.
perform
(
ViewActions
.
click
(
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
blocking_switch
)
)
.
check
(
ViewAssertions
.
matches
(
Matchers
.
not
(
ViewMatchers
.
isChecked
(
)
)
)
)
Espresso
.
onView
(
ViewMatchers
.
withId
(
R
.
id
.
trackers_count
)
)
.
check
(
ViewAssertions
.
matches
(
ViewMatchers
.
withText
(
"
-
"
)
)
)
}
companion
object
{
private
const
val
TEST_PATH
=
"
/
"
}
}
