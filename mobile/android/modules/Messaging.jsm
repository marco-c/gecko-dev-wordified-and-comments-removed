"
use
strict
"
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
sendMessageToJava
"
"
Messaging
"
"
EventDispatcher
"
]
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidgen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
function
sendMessageToJava
(
aMessage
aCallback
)
{
Cu
.
reportError
(
"
sendMessageToJava
is
deprecated
.
Use
Messaging
API
instead
.
"
)
;
if
(
aCallback
)
{
Messaging
.
sendRequestForResult
(
aMessage
)
.
then
(
result
=
>
aCallback
(
result
null
)
error
=
>
aCallback
(
null
error
)
)
;
}
else
{
Messaging
.
sendRequest
(
aMessage
)
;
}
}
function
DispatcherDelegate
(
dispatcher
)
{
this
.
_dispatcher
=
dispatcher
;
}
DispatcherDelegate
.
prototype
=
{
registerListener
:
function
(
listener
events
)
{
this
.
_dispatcher
.
registerListener
(
listener
events
)
;
}
unregisterListener
:
function
(
listener
events
)
{
this
.
_dispatcher
.
unregisterListener
(
listener
events
)
;
}
dispatch
:
function
(
event
data
callback
)
{
this
.
_dispatcher
.
dispatch
(
event
data
callback
)
;
}
sendRequest
:
function
(
msg
)
{
let
type
=
msg
.
type
;
msg
.
type
=
undefined
;
this
.
dispatch
(
type
msg
)
;
}
sendRequestForResult
:
function
(
msg
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
type
=
msg
.
type
;
msg
.
type
=
undefined
;
this
.
dispatch
(
type
msg
{
onSuccess
:
response
=
>
resolve
(
response
)
onError
:
response
=
>
reject
(
response
)
}
)
;
}
)
;
}
addListener
:
function
(
listener
event
)
{
if
(
this
.
_requestHandler
.
listeners
[
event
]
)
{
throw
new
Error
(
"
Error
in
addListener
:
A
listener
already
exists
for
event
"
+
event
)
;
}
if
(
typeof
listener
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Error
in
addListener
:
Listener
must
be
a
function
for
event
"
+
event
)
;
}
this
.
_requestHandler
.
listeners
[
event
]
=
listener
;
this
.
registerListener
(
this
.
_requestHandler
event
)
;
}
removeListener
:
function
(
event
)
{
if
(
!
this
.
_requestHandler
.
listeners
[
event
]
)
{
throw
new
Error
(
"
Error
in
removeListener
:
There
is
no
listener
for
event
"
+
event
)
;
}
this
.
_requestHandler
.
listeners
[
event
]
=
undefined
;
this
.
unregisterListener
(
this
.
_requestHandler
event
)
;
}
_requestHandler
:
{
listeners
:
{
}
onEvent
:
Task
.
async
(
function
*
(
event
data
callback
)
{
try
{
let
response
=
yield
this
.
listeners
[
event
]
(
data
.
data
)
;
callback
.
onSuccess
(
response
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
in
Messaging
handler
for
"
+
event
+
"
:
"
+
e
)
;
callback
.
onError
(
{
message
:
e
.
message
|
|
(
e
&
&
e
.
toString
(
)
)
stack
:
e
.
stack
|
|
Components
.
stack
.
formattedStack
}
)
;
}
}
)
}
}
;
var
EventDispatcher
=
{
instance
:
new
DispatcherDelegate
(
Services
.
androidBridge
)
for
:
function
(
window
)
{
let
view
=
window
&
&
window
.
arguments
&
&
window
.
arguments
[
0
]
&
&
window
.
arguments
[
0
]
.
QueryInterface
(
Ci
.
nsIAndroidView
)
;
if
(
!
view
)
{
throw
new
Error
(
"
window
is
not
a
GeckoView
-
connected
window
"
)
;
}
return
new
DispatcherDelegate
(
view
)
;
}
}
;
var
Messaging
=
{
addListener
:
function
(
aListener
aMessage
)
{
requestHandler
.
addListener
(
aListener
aMessage
)
;
}
removeListener
:
function
(
aMessage
)
{
requestHandler
.
removeListener
(
aMessage
)
;
}
sendRequest
:
function
(
aMessage
)
{
Services
.
androidBridge
.
handleGeckoMessage
(
aMessage
)
;
}
sendRequestForResult
:
function
(
aMessage
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
id
=
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
let
obs
=
{
observe
:
function
(
aSubject
aTopic
aData
)
{
let
data
=
JSON
.
parse
(
aData
)
;
if
(
data
.
__guid__
!
=
id
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
aMessage
.
type
+
"
:
Response
"
)
;
if
(
data
.
status
=
=
=
"
success
"
)
{
resolve
(
data
.
response
)
;
}
else
{
reject
(
data
.
response
)
;
}
}
}
;
aMessage
.
__guid__
=
id
;
Services
.
obs
.
addObserver
(
obs
aMessage
.
type
+
"
:
Response
"
false
)
;
this
.
sendRequest
(
aMessage
)
;
}
)
;
}
handleRequest
:
Task
.
async
(
function
*
(
aTopic
aData
aListener
)
{
let
wrapper
=
JSON
.
parse
(
aData
)
;
try
{
let
response
=
yield
aListener
(
wrapper
.
data
)
;
if
(
typeof
response
!
=
=
"
object
"
|
|
response
=
=
=
null
)
{
throw
new
Error
(
"
Gecko
request
listener
did
not
return
an
object
"
)
;
}
Messaging
.
sendRequest
(
{
type
:
"
Gecko
:
Request
"
+
wrapper
.
id
response
:
response
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
in
Messaging
handler
for
"
+
aTopic
+
"
:
"
+
e
)
;
Messaging
.
sendRequest
(
{
type
:
"
Gecko
:
Request
"
+
wrapper
.
id
error
:
{
message
:
e
.
message
|
|
(
e
&
&
e
.
toString
(
)
)
stack
:
e
.
stack
|
|
Components
.
stack
.
formattedStack
}
}
)
;
}
}
)
}
;
var
requestHandler
=
{
_listeners
:
{
}
addListener
:
function
(
aListener
aMessage
)
{
if
(
aMessage
in
this
.
_listeners
)
{
throw
new
Error
(
"
Error
in
addListener
:
A
listener
already
exists
for
message
"
+
aMessage
)
;
}
if
(
typeof
aListener
!
=
=
"
function
"
)
{
throw
new
Error
(
"
Error
in
addListener
:
Listener
must
be
a
function
for
message
"
+
aMessage
)
;
}
this
.
_listeners
[
aMessage
]
=
aListener
;
Services
.
obs
.
addObserver
(
this
aMessage
false
)
;
}
removeListener
:
function
(
aMessage
)
{
if
(
!
(
aMessage
in
this
.
_listeners
)
)
{
throw
new
Error
(
"
Error
in
removeListener
:
There
is
no
listener
for
message
"
+
aMessage
)
;
}
delete
this
.
_listeners
[
aMessage
]
;
Services
.
obs
.
removeObserver
(
this
aMessage
)
;
}
observe
:
function
(
aSubject
aTopic
aData
)
{
let
listener
=
this
.
_listeners
[
aTopic
]
;
Messaging
.
handleRequest
(
aTopic
aData
listener
)
;
}
}
;
