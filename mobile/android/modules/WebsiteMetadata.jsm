'
use
strict
'
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
this
.
EXPORTED_SYMBOLS
=
[
"
WebsiteMetadata
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Messaging
"
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
var
WebsiteMetadata
=
{
parseAsynchronously
:
function
(
doc
)
{
Task
.
spawn
(
function
(
)
{
let
metadata
=
getMetadata
(
doc
doc
.
location
.
href
)
;
let
msg
=
{
type
:
'
Website
:
Metadata
'
location
:
doc
.
location
.
href
metadata
:
metadata
}
;
Messaging
.
sendRequest
(
msg
)
;
}
)
;
}
}
;
function
makeUrlAbsolute
(
context
relative
)
{
var
a
=
context
.
doc
.
createElement
(
'
a
'
)
;
a
.
href
=
relative
;
return
a
.
href
;
}
function
buildRuleset
(
name
rules
processors
)
{
const
reversedRules
=
Array
.
from
(
rules
)
.
reverse
(
)
;
const
builtRuleset
=
ruleset
(
.
.
.
reversedRules
.
map
(
(
[
query
handler
]
order
)
=
>
rule
(
dom
(
query
)
node
=
>
[
{
score
:
order
flavor
:
name
notes
:
handler
(
node
)
}
]
)
)
)
;
return
(
doc
context
)
=
>
{
const
kb
=
builtRuleset
.
score
(
doc
)
;
const
maxNode
=
kb
.
max
(
name
)
;
if
(
maxNode
)
{
let
value
=
maxNode
.
flavors
.
get
(
name
)
;
if
(
processors
)
{
processors
.
forEach
(
processor
=
>
{
value
=
processor
(
value
context
)
;
}
)
;
}
if
(
value
)
{
if
(
value
.
trim
)
{
return
value
.
trim
(
)
;
}
return
value
;
}
}
}
;
}
const
metadataRules
=
{
description
:
{
rules
:
[
[
'
meta
[
property
=
"
og
:
description
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
name
=
"
description
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
]
}
icon_url
:
{
rules
:
[
[
'
link
[
rel
=
"
apple
-
touch
-
icon
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
[
'
link
[
rel
=
"
apple
-
touch
-
icon
-
precomposed
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
[
'
link
[
rel
=
"
icon
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
[
'
link
[
rel
=
"
fluid
-
icon
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
[
'
link
[
rel
=
"
shortcut
icon
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
[
'
link
[
rel
=
"
Shortcut
Icon
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
[
'
link
[
rel
=
"
mask
-
icon
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
]
processors
:
[
(
icon_url
context
)
=
>
makeUrlAbsolute
(
context
icon_url
)
]
}
image_url
:
{
rules
:
[
[
'
meta
[
property
=
"
og
:
image
:
secure_url
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
property
=
"
og
:
image
:
url
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
property
=
"
og
:
image
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
property
=
"
twitter
:
image
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
name
=
"
thumbnail
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
]
processors
:
[
(
image_url
context
)
=
>
makeUrlAbsolute
(
context
image_url
)
]
}
keywords
:
{
rules
:
[
[
'
meta
[
name
=
"
keywords
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
]
processors
:
[
(
keywords
)
=
>
keywords
.
split
(
'
'
)
.
map
(
(
keyword
)
=
>
keyword
.
trim
(
)
)
]
}
title
:
{
rules
:
[
[
'
meta
[
property
=
"
og
:
title
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
property
=
"
twitter
:
title
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
meta
[
name
=
"
hdl
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
title
'
node
=
>
node
.
element
.
text
]
]
}
type
:
{
rules
:
[
[
'
meta
[
property
=
"
og
:
type
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
]
}
url
:
{
rules
:
[
[
'
meta
[
property
=
"
og
:
url
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
content
'
)
]
[
'
link
[
rel
=
"
canonical
"
]
'
node
=
>
node
.
element
.
getAttribute
(
'
href
'
)
]
]
}
}
;
function
getMetadata
(
doc
url
rules
)
{
const
metadata
=
{
}
;
const
context
=
{
url
doc
}
;
const
ruleSet
=
rules
|
|
metadataRules
;
Object
.
keys
(
ruleSet
)
.
map
(
metadataKey
=
>
{
const
metadataRule
=
ruleSet
[
metadataKey
]
;
if
(
Array
.
isArray
(
metadataRule
.
rules
)
)
{
const
builtRule
=
buildRuleset
(
metadataKey
metadataRule
.
rules
metadataRule
.
processors
)
;
metadata
[
metadataKey
]
=
builtRule
(
doc
context
)
;
}
else
{
metadata
[
metadataKey
]
=
getMetadata
(
doc
url
metadataRule
)
;
}
}
)
;
return
metadata
;
}
function
forEach
(
fn
obj
)
{
for
(
let
x
of
obj
)
{
fn
(
x
)
;
}
}
function
best
(
iterable
by
isBetter
)
{
let
bestSoFar
bestKeySoFar
;
let
isFirst
=
true
;
forEach
(
function
(
item
)
{
const
key
=
by
(
item
)
;
if
(
isBetter
(
key
bestKeySoFar
)
|
|
isFirst
)
{
bestSoFar
=
item
;
bestKeySoFar
=
key
;
isFirst
=
false
;
}
}
iterable
)
;
if
(
isFirst
)
{
throw
new
Error
(
'
Tried
to
call
best
(
)
on
empty
iterable
'
)
;
}
return
bestSoFar
;
}
function
max
(
iterable
by
=
identity
)
{
return
best
(
iterable
by
(
a
b
)
=
>
a
>
b
)
;
}
function
getDefault
(
map
key
defaultMaker
)
{
if
(
map
.
has
(
key
)
)
{
return
map
.
get
(
key
)
;
}
const
defaultValue
=
defaultMaker
(
)
;
map
.
set
(
key
defaultValue
)
;
return
defaultValue
;
}
function
ruleset
(
.
.
.
rules
)
{
const
rulesByInputFlavor
=
new
Map
(
)
;
forEach
(
rule
=
>
getDefault
(
rulesByInputFlavor
rule
.
source
.
inputFlavor
(
)
=
>
[
]
)
.
push
(
rule
)
rules
)
;
return
{
score
:
function
(
tree
)
{
const
kb
=
knowledgebase
(
)
;
const
nonterminals
=
[
[
{
tree
}
'
dom
'
]
]
;
while
(
nonterminals
.
length
)
{
const
[
inNode
inFlavor
]
=
nonterminals
.
pop
(
)
;
for
(
let
rule
of
getDefault
(
rulesByInputFlavor
inFlavor
(
)
=
>
[
]
)
)
{
const
outFacts
=
resultsOf
(
rule
inNode
inFlavor
kb
)
;
for
(
let
fact
of
outFacts
)
{
const
outNode
=
kb
.
nodeForElement
(
fact
.
element
)
;
outNode
.
score
*
=
fact
.
score
;
if
(
!
outNode
.
flavors
.
has
(
fact
.
flavor
)
)
{
outNode
.
flavors
.
set
(
fact
.
flavor
fact
.
notes
)
;
kb
.
indexNodeByFlavor
(
outNode
fact
.
flavor
)
;
nonterminals
.
push
(
[
outNode
fact
.
flavor
]
)
;
}
}
}
}
return
kb
;
}
}
;
}
function
knowledgebase
(
)
{
const
nodesByFlavor
=
new
Map
(
)
;
const
nodesByElement
=
new
Map
(
)
;
return
{
nodeForElement
:
function
(
element
)
{
return
getDefault
(
nodesByElement
element
(
)
=
>
(
{
element
score
:
1
flavors
:
new
Map
(
)
}
)
)
;
}
max
:
function
(
flavor
)
{
const
nodes
=
nodesByFlavor
.
get
(
flavor
)
;
return
nodes
=
=
=
undefined
?
undefined
:
max
(
nodes
node
=
>
node
.
score
)
;
}
indexNodeByFlavor
:
function
(
node
flavor
)
{
getDefault
(
nodesByFlavor
flavor
(
)
=
>
[
]
)
.
push
(
node
)
;
}
nodesOfFlavor
:
function
(
flavor
)
{
return
getDefault
(
nodesByFlavor
flavor
(
)
=
>
[
]
)
;
}
}
;
}
function
resultsOf
(
rule
node
flavor
kb
)
{
return
rule
.
source
.
flavor
=
=
=
'
flavor
'
?
resultsOfFlavorRule
(
rule
node
flavor
)
:
resultsOfDomRule
(
rule
node
kb
)
;
}
function
*
resultsOfDomRule
(
rule
specialDomNode
kb
)
{
const
matches
=
specialDomNode
.
tree
.
querySelectorAll
(
rule
.
source
.
selector
)
;
for
(
let
i
=
0
;
i
<
matches
.
length
;
i
+
+
)
{
const
element
=
matches
[
i
]
;
const
newFacts
=
explicitFacts
(
rule
.
ranker
(
kb
.
nodeForElement
(
element
)
)
)
;
for
(
let
fact
of
newFacts
)
{
if
(
fact
.
element
=
=
=
undefined
)
{
fact
.
element
=
element
;
}
if
(
fact
.
flavor
=
=
=
undefined
)
{
throw
new
Error
(
'
Rankers
of
dom
(
)
rules
must
return
a
flavor
in
each
fact
.
Otherwise
there
is
no
way
for
that
fact
to
be
used
later
.
'
)
;
}
yield
fact
;
}
}
}
function
*
resultsOfFlavorRule
(
rule
node
flavor
)
{
const
newFacts
=
explicitFacts
(
rule
.
ranker
(
node
)
)
;
for
(
let
fact
of
newFacts
)
{
if
(
fact
.
element
=
=
=
undefined
)
{
fact
.
element
=
node
.
element
;
}
if
(
fact
.
flavor
=
=
=
undefined
)
{
fact
.
flavor
=
flavor
;
}
yield
fact
;
}
}
function
*
explicitFacts
(
rankerResult
)
{
const
array
=
(
rankerResult
=
=
=
undefined
)
?
[
]
:
(
Array
.
isArray
(
rankerResult
)
?
rankerResult
:
[
rankerResult
]
)
;
for
(
let
fact
of
array
)
{
if
(
fact
.
score
=
=
=
undefined
)
{
fact
.
score
=
1
;
}
yield
fact
;
}
}
function
dom
(
selector
)
{
return
{
flavor
:
'
dom
'
inputFlavor
:
'
dom
'
selector
}
;
}
function
flavor
(
inputFlavor
)
{
return
{
flavor
:
'
flavor
'
inputFlavor
}
;
}
function
rule
(
source
ranker
)
{
return
{
source
ranker
}
;
}
