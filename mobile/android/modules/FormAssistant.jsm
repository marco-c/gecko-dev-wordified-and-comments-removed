"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormAssistant
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
GeckoViewUtils
:
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
var
FormAssistant
=
{
_currentFocusedElement
:
null
_doingAutocomplete
:
false
_lastPanZoomState
:
"
NOTHING
"
init
:
function
(
)
{
Services
.
obs
.
addObserver
(
this
"
PanZoom
:
StateChange
"
)
;
}
_onPopupResponse
:
function
(
currentElement
message
)
{
switch
(
message
.
action
)
{
case
"
autocomplete
"
:
{
this
.
_doingAutocomplete
=
true
;
try
{
if
(
currentElement
.
editor
.
composing
)
{
currentElement
.
editor
.
forceCompositionEnd
(
)
;
}
}
catch
(
e
)
{
}
currentElement
.
setUserInput
(
message
.
value
)
;
let
event
=
currentElement
.
ownerDocument
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
DOMAutoComplete
"
true
true
)
;
currentElement
.
dispatchEvent
(
event
)
;
this
.
_doingAutocomplete
=
false
;
break
;
}
case
"
remove
"
:
{
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
currentElement
.
name
value
:
message
.
value
}
)
;
break
;
}
}
}
observe
:
function
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
PanZoom
:
StateChange
"
:
if
(
aData
=
=
"
TOUCHING
"
|
|
aData
=
=
"
WAITING_LISTENERS
"
)
{
break
;
}
let
focused
=
this
.
focusedElement
;
if
(
aData
=
=
"
NOTHING
"
)
{
if
(
!
focused
|
|
this
.
_showValidationMessage
(
focused
)
)
{
break
;
}
this
.
_showAutoCompleteSuggestions
(
focused
hasResults
=
>
{
if
(
!
hasResults
)
{
this
.
_hideFormAssistPopup
(
focused
)
;
}
}
)
;
}
else
if
(
focused
)
{
this
.
_hideFormAssistPopup
(
focused
)
;
}
this
.
_lastPanZoomState
=
aData
;
break
;
}
}
notifyInvalidSubmit
:
function
(
aFormElement
aInvalidElements
)
{
if
(
!
aInvalidElements
.
length
)
{
return
;
}
let
currentElement
=
aInvalidElements
[
0
]
;
let
focused
=
this
.
focusedElement
;
if
(
focused
&
&
focused
.
ownerGlobal
.
top
!
=
=
currentElement
.
ownerGlobal
.
top
)
{
return
;
}
currentElement
.
focus
(
)
;
}
get
focusedElement
(
)
{
return
this
.
_currentFocusedElement
&
&
this
.
_currentFocusedElement
.
get
(
)
;
}
handleEvent
:
function
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
focus
"
:
{
let
currentElement
=
aEvent
.
target
;
if
(
this
.
_showValidationMessage
(
currentElement
)
|
|
this
.
_isAutoComplete
(
currentElement
)
)
{
this
.
_currentFocusedElement
=
Cu
.
getWeakReference
(
currentElement
)
;
currentElement
.
ownerGlobal
.
addEventListener
(
"
resize
"
this
{
capture
:
true
mozSystemGroup
:
true
once
:
true
}
)
;
}
break
;
}
case
"
blur
"
:
{
let
focused
=
this
.
focusedElement
;
if
(
focused
)
{
this
.
_hideFormAssistPopup
(
focused
)
;
}
this
.
_currentFocusedElement
=
null
;
break
;
}
case
"
click
"
:
{
let
currentElement
=
aEvent
.
target
;
if
(
currentElement
!
=
=
this
.
focusedElement
)
{
break
;
}
if
(
this
.
_isValidateable
(
currentElement
)
)
{
break
;
}
let
checkResultsClick
=
hasResults
=
>
{
if
(
!
hasResults
&
&
currentElement
=
=
=
this
.
focusedElement
)
{
this
.
_hideFormAssistPopup
(
currentElement
)
;
}
}
;
this
.
_showAutoCompleteSuggestions
(
currentElement
checkResultsClick
)
;
break
;
}
case
"
input
"
:
{
let
currentElement
=
aEvent
.
target
;
if
(
currentElement
!
=
=
this
.
focusedElement
|
|
this
.
_doingAutocomplete
)
{
break
;
}
let
checkResultsInput
=
hasResults
=
>
{
if
(
hasResults
|
|
currentElement
!
=
=
this
.
focusedElement
|
|
this
.
_showValidationMessage
(
currentElement
)
)
{
return
;
}
this
.
_hideFormAssistPopup
(
currentElement
)
;
}
;
this
.
_showAutoCompleteSuggestions
(
currentElement
checkResultsInput
)
;
break
;
}
case
"
resize
"
:
{
let
focused
=
this
.
focusedElement
;
if
(
focused
&
&
focused
.
ownerGlobal
=
=
aEvent
.
target
)
{
this
.
observe
(
null
"
PanZoom
:
StateChange
"
this
.
_lastPanZoomState
)
;
focused
.
ownerGlobal
.
addEventListener
(
"
resize
"
this
{
capture
:
true
mozSystemGroup
:
true
once
:
true
}
)
;
}
break
;
}
}
}
_isAutoComplete
:
function
(
aElement
)
{
return
(
ChromeUtils
.
getClassName
(
aElement
)
=
=
=
"
HTMLInputElement
"
)
&
&
!
aElement
.
readOnly
&
&
!
this
.
_isDisabledElement
(
aElement
)
&
&
(
aElement
.
type
!
=
=
"
password
"
)
&
&
(
aElement
.
autocomplete
!
=
=
"
off
"
)
;
}
_getAutoCompleteSuggestions
:
function
(
aSearchString
aElement
aCallback
)
{
if
(
!
this
.
_formAutoCompleteService
)
{
this
.
_formAutoCompleteService
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
autocomplete
;
1
"
]
.
getService
(
Ci
.
nsIFormAutoComplete
)
;
}
let
resultsAvailable
=
function
(
results
)
{
let
suggestions
=
[
]
;
for
(
let
i
=
0
;
i
<
results
.
matchCount
;
i
+
+
)
{
let
value
=
results
.
getValueAt
(
i
)
;
if
(
value
=
=
aSearchString
)
continue
;
suggestions
.
push
(
{
label
:
value
value
:
value
}
)
;
}
aCallback
(
suggestions
)
;
}
;
this
.
_formAutoCompleteService
.
autoCompleteSearchAsync
(
aElement
.
name
|
|
aElement
.
id
aSearchString
aElement
null
null
resultsAvailable
)
;
}
_getListSuggestions
:
function
(
aElement
)
{
if
(
ChromeUtils
.
getClassName
(
aElement
)
!
=
=
"
HTMLInputElement
"
|
|
!
aElement
.
list
)
{
return
[
]
;
}
let
suggestions
=
[
]
;
let
filter
=
!
aElement
.
hasAttribute
(
"
mozNoFilter
"
)
;
let
lowerFieldValue
=
aElement
.
value
.
toLowerCase
(
)
;
let
options
=
aElement
.
list
.
options
;
let
length
=
options
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
item
=
options
.
item
(
i
)
;
let
label
=
item
.
value
;
if
(
item
.
label
)
{
label
=
item
.
label
;
}
else
if
(
item
.
text
)
{
label
=
item
.
text
;
}
if
(
filter
&
&
!
(
label
.
toLowerCase
(
)
.
includes
(
lowerFieldValue
)
)
)
{
continue
;
}
suggestions
.
push
(
{
label
:
label
value
:
item
.
value
}
)
;
}
return
suggestions
;
}
_showAutoCompleteSuggestions
:
function
(
aElement
aCallback
)
{
if
(
!
this
.
_isAutoComplete
(
aElement
)
)
{
aCallback
(
false
)
;
return
;
}
let
isEmpty
=
(
aElement
.
value
.
length
=
=
=
0
)
;
let
resultsAvailable
=
autoCompleteSuggestions
=
>
{
let
listSuggestions
=
this
.
_getListSuggestions
(
aElement
)
;
let
suggestions
=
autoCompleteSuggestions
.
concat
(
listSuggestions
)
;
if
(
!
suggestions
.
length
|
|
aElement
!
=
=
this
.
focusedElement
)
{
aCallback
(
false
)
;
return
;
}
GeckoViewUtils
.
getDispatcherForWindow
(
aElement
.
ownerGlobal
)
.
sendRequest
(
{
type
:
"
FormAssist
:
AutoCompleteResult
"
suggestions
:
suggestions
rect
:
this
.
_getBoundingContentRect
(
aElement
)
isEmpty
:
isEmpty
}
{
onSuccess
:
response
=
>
this
.
_onPopupResponse
(
aElement
response
)
onError
:
error
=
>
Cu
.
reportError
(
error
)
}
)
;
aCallback
(
true
)
;
}
;
this
.
_getAutoCompleteSuggestions
(
aElement
.
value
aElement
resultsAvailable
)
;
}
_isValidateable
:
function
(
aElement
)
{
return
(
ChromeUtils
.
getClassName
(
aElement
)
=
=
=
"
HTMLInputElement
"
|
|
ChromeUtils
.
getClassName
(
aElement
)
=
=
=
"
HTMLTextAreaElement
"
|
|
ChromeUtils
.
getClassName
(
aElement
)
=
=
=
"
HTMLSelectElement
"
|
|
ChromeUtils
.
getClassName
(
aElement
)
=
=
=
"
HTMLButtonElement
"
)
&
&
aElement
.
matches
(
"
:
-
moz
-
ui
-
invalid
"
)
&
&
aElement
.
validationMessage
;
}
_showValidationMessage
:
function
(
aElement
)
{
if
(
!
this
.
_isValidateable
(
aElement
)
)
{
return
false
;
}
GeckoViewUtils
.
getDispatcherForWindow
(
aElement
.
ownerGlobal
)
.
sendRequest
(
{
type
:
"
FormAssist
:
ValidationMessage
"
validationMessage
:
aElement
.
validationMessage
rect
:
this
.
_getBoundingContentRect
(
aElement
)
}
)
;
return
true
;
}
_hideFormAssistPopup
:
function
(
aElement
)
{
if
(
!
aElement
.
ownerGlobal
)
{
return
;
}
GeckoViewUtils
.
getDispatcherForWindow
(
aElement
.
ownerGlobal
)
.
sendRequest
(
{
type
:
"
FormAssist
:
Hide
"
}
)
;
}
_isDisabledElement
:
function
(
aElement
)
{
let
currentElement
=
aElement
;
while
(
currentElement
)
{
if
(
currentElement
.
disabled
)
{
return
true
;
}
currentElement
=
currentElement
.
parentElement
;
}
return
false
;
}
_getBoundingContentRect
:
function
(
aElement
)
{
if
(
!
aElement
)
{
return
{
x
:
0
y
:
0
w
:
0
h
:
0
}
;
}
let
document
=
aElement
.
ownerDocument
;
while
(
document
.
defaultView
.
frameElement
)
{
document
=
document
.
defaultView
.
frameElement
.
ownerDocument
;
}
let
scrollX
=
0
scrollY
=
0
;
let
r
=
aElement
.
getBoundingClientRect
(
)
;
for
(
let
frame
=
aElement
.
ownerGlobal
;
frame
.
frameElement
;
frame
=
frame
.
parent
)
{
let
rect
=
frame
.
frameElement
.
getBoundingClientRect
(
)
;
let
left
=
frame
.
getComputedStyle
(
frame
.
frameElement
)
.
borderLeftWidth
;
let
top
=
frame
.
getComputedStyle
(
frame
.
frameElement
)
.
borderTopWidth
;
scrollX
+
=
rect
.
left
+
parseInt
(
left
)
;
scrollY
+
=
rect
.
top
+
parseInt
(
top
)
;
}
let
offsetX
=
{
}
offsetY
=
{
}
;
aElement
.
ownerGlobal
.
windowUtils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
return
{
x
:
r
.
left
+
scrollX
-
offsetX
.
value
y
:
r
.
top
+
scrollY
-
offsetY
.
value
w
:
r
.
width
h
:
r
.
height
}
;
}
}
;
FormAssistant
.
init
(
)
;
