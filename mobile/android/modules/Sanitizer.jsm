ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Integration
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Accounts
:
"
resource
:
/
/
gre
/
modules
/
Accounts
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
OfflineAppCacheHelper
:
"
resource
:
/
/
gre
/
modules
/
offlineAppCache
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ServiceWorkerCleanUp
:
"
resource
:
/
/
gre
/
modules
/
ServiceWorkerCleanUp
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
quotaManagerService
:
[
"
mozilla
.
org
/
dom
/
quota
-
manager
-
service
;
1
"
"
nsIQuotaManagerService
"
]
}
)
;
Integration
.
downloads
.
defineModuleGetter
(
this
"
DownloadIntegration
"
"
resource
:
/
/
gre
/
modules
/
DownloadIntegration
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
Sanitizer
"
]
;
function
Sanitizer
(
)
{
}
Sanitizer
.
prototype
=
{
clearItem
:
function
(
aItemName
startTime
clearUnfinishedDownloads
)
{
if
(
typeof
startTime
!
=
"
undefined
"
)
{
switch
(
aItemName
)
{
case
"
downloadHistory
"
:
return
this
.
_clear
(
"
downloadFiles
"
{
startTime
deleteFiles
:
false
}
)
;
case
"
formdata
"
:
return
this
.
_clear
(
aItemName
{
startTime
}
)
;
default
:
return
Promise
.
reject
(
{
message
:
Invalid
argument
:
{
aItemName
}
does
not
support
startTime
argument
.
}
)
;
}
}
else
if
(
aItemName
=
=
=
"
downloadFiles
"
&
&
typeof
clearUnfinishedDownloads
!
=
"
undefined
"
)
{
return
this
.
_clear
(
aItemName
{
clearUnfinishedDownloads
}
)
;
}
else
{
return
this
.
_clear
(
aItemName
)
;
}
}
_clear
:
function
(
aItemName
options
)
{
let
item
=
this
.
items
[
aItemName
]
;
let
canClear
=
item
.
canClear
;
if
(
typeof
canClear
=
=
"
function
"
)
{
let
maybeDoClear
=
async
(
)
=
>
{
let
canClearResult
=
await
new
Promise
(
resolve
=
>
{
canClear
(
resolve
)
;
}
)
;
if
(
canClearResult
)
{
return
item
.
clear
(
options
)
;
}
}
;
return
maybeDoClear
(
)
;
}
else
if
(
canClear
)
{
return
item
.
clear
(
options
)
;
}
}
items
:
{
cache
:
{
clear
:
function
(
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
try
{
Services
.
cache2
.
clear
(
)
;
}
catch
(
er
)
{
}
let
imageCache
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
getImgCacheForDocument
(
null
)
;
try
{
imageCache
.
clearCache
(
false
)
;
}
catch
(
er
)
{
}
return
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
Sanitize
:
Cache
"
}
)
.
catch
(
(
err
)
=
>
{
Cu
.
reportError
(
Java
-
side
cache
clearing
failed
with
error
:
{
err
}
)
;
}
)
.
then
(
(
)
=
>
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_CACHE
"
refObj
)
;
}
)
;
}
get
canClear
(
)
{
return
true
;
}
}
cookies
:
{
clear
:
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
Services
.
cookies
.
removeAll
(
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_COOKIES_2
"
refObj
)
;
try
{
let
mediaMgr
=
Cc
[
"
mozilla
.
org
/
mediaManagerService
;
1
"
]
.
getService
(
Ci
.
nsIMediaManagerService
)
;
mediaMgr
.
sanitizeDeviceIds
(
0
)
;
}
catch
(
er
)
{
}
resolve
(
)
;
}
)
;
}
get
canClear
(
)
{
return
true
;
}
}
siteSettings
:
{
async
clear
(
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
Services
.
perms
.
removeAll
(
)
;
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
.
removeAllDomains
(
null
)
;
var
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
sss
.
clearAll
(
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
push
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
push
.
clearForDomain
(
"
*
"
status
=
>
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Error
(
"
Error
clearing
push
subscriptions
:
"
+
status
)
)
;
}
}
)
;
}
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SITESETTINGS
"
refObj
)
;
}
get
canClear
(
)
{
return
true
;
}
}
offlineApps
:
{
async
clear
(
)
{
OfflineAppCacheHelper
.
clear
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
extension
:
purge
-
localStorage
"
)
;
await
ServiceWorkerCleanUp
.
removeAll
(
)
;
let
promises
=
[
]
;
await
new
Promise
(
resolve
=
>
{
quotaManagerService
.
getUsage
(
request
=
>
{
if
(
request
.
resultCode
!
=
Cr
.
NS_OK
)
{
resolve
(
)
;
return
;
}
for
(
let
item
of
request
.
result
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
|
|
uri
.
scheme
=
=
"
file
"
)
{
promises
.
push
(
new
Promise
(
r
=
>
{
let
req
=
quotaManagerService
.
clearStoragesForPrincipal
(
principal
)
;
req
.
callback
=
(
)
=
>
{
r
(
)
;
}
;
}
)
)
;
}
}
resolve
(
)
;
}
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
get
canClear
(
)
{
return
true
;
}
}
history
:
{
clear
:
function
(
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
return
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
Sanitize
:
ClearHistory
"
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
"
Java
-
side
history
clearing
failed
:
"
+
e
)
)
.
then
(
function
(
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_HISTORY
"
refObj
)
;
try
{
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
history
"
)
;
}
catch
(
e
)
{
}
try
{
var
predictor
=
Cc
[
"
mozilla
.
org
/
network
/
predictor
;
1
"
]
.
getService
(
Ci
.
nsINetworkPredictor
)
;
predictor
.
reset
(
)
;
}
catch
(
e
)
{
}
}
)
;
}
get
canClear
(
)
{
return
true
;
}
}
openTabs
:
{
clear
:
function
(
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
return
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
Sanitize
:
OpenTabs
"
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
"
Java
-
side
tab
clearing
failed
:
"
+
e
)
)
.
then
(
function
(
)
{
try
{
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
session
-
tabs
"
)
;
}
catch
(
e
)
{
}
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_OPENWINDOWS
"
refObj
)
;
}
)
;
}
get
canClear
(
)
{
return
true
;
}
}
searchHistory
:
{
clear
:
function
(
)
{
return
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
Sanitize
:
ClearHistory
"
clearSearchHistory
:
true
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
"
Java
-
side
search
history
clearing
failed
:
"
+
e
)
)
;
}
get
canClear
(
)
{
return
true
;
}
}
formdata
:
{
clear
:
function
(
{
startTime
=
0
}
=
{
}
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
let
time
=
startTime
*
1000
;
FormHistory
.
update
(
{
op
:
"
remove
"
firstUsedStart
:
time
}
{
handleCompletion
(
)
{
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_FORMDATA
"
refObj
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
canClear
:
function
(
aCallback
)
{
let
count
=
0
;
let
countDone
=
{
handleResult
:
function
(
aResult
)
{
count
=
aResult
;
}
handleError
:
function
(
aError
)
{
Cu
.
reportError
(
aError
)
;
}
handleCompletion
:
function
(
aReason
)
{
aCallback
(
aReason
=
=
0
&
&
count
>
0
)
;
}
}
;
FormHistory
.
count
(
{
}
countDone
)
;
}
}
downloadFiles
:
{
async
clear
(
{
startTime
=
0
deleteFiles
=
true
clearUnfinishedDownloads
=
false
}
=
{
}
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
let
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
let
downloads
=
await
list
.
getAll
(
)
;
var
finalizePromises
=
[
]
;
for
(
let
download
of
downloads
)
{
let
downloadFinished
=
download
.
stopped
&
&
(
!
download
.
hasPartialData
|
|
download
.
error
)
;
if
(
(
downloadFinished
|
|
clearUnfinishedDownloads
)
&
&
download
.
startTime
.
getTime
(
)
>
=
startTime
)
{
await
list
.
remove
(
download
)
;
finalizePromises
.
push
(
download
.
finalize
(
true
)
.
then
(
(
)
=
>
null
Cu
.
reportError
)
)
;
if
(
deleteFiles
)
{
OS
.
File
.
remove
(
download
.
target
.
path
)
.
then
(
(
)
=
>
null
ex
=
>
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
&
&
ex
.
becauseNoSuchFile
)
)
{
Cu
.
reportError
(
ex
)
;
}
}
)
;
}
}
}
await
Promise
.
all
(
finalizePromises
)
;
await
DownloadIntegration
.
forceSave
(
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_DOWNLOADS
"
refObj
)
;
}
get
canClear
(
)
{
return
true
;
}
}
passwords
:
{
clear
:
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
Services
.
logins
.
removeAllLogins
(
)
;
resolve
(
)
;
}
)
;
}
get
canClear
(
)
{
let
count
=
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
;
return
(
count
>
0
)
;
}
}
sessions
:
{
clear
:
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
refObj
=
{
}
;
TelemetryStopwatch
.
start
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
var
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
sdr
.
logoutAndTeardown
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
net
:
clear
-
active
-
logins
"
)
;
TelemetryStopwatch
.
finish
(
"
FX_SANITIZE_SESSIONS
"
refObj
)
;
resolve
(
)
;
}
)
;
}
get
canClear
(
)
{
return
true
;
}
}
syncedTabs
:
{
clear
:
function
(
)
{
return
EventDispatcher
.
instance
.
sendRequestForResult
(
{
type
:
"
Sanitize
:
ClearSyncedTabs
"
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
"
Java
-
side
synced
tabs
clearing
failed
:
"
+
e
)
)
;
}
canClear
:
function
(
aCallback
)
{
Accounts
.
anySyncAccountsExist
(
)
.
then
(
aCallback
)
.
catch
(
function
(
err
)
{
Cu
.
reportError
(
"
Java
-
side
synced
tabs
clearing
failed
:
"
+
err
)
;
aCallback
(
false
)
;
}
)
;
}
}
}
}
;
var
Sanitizer
=
new
Sanitizer
(
)
;
