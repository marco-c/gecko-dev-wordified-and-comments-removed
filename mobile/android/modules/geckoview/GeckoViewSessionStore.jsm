"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewSessionStore
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
GeckoViewUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
SessionHistory
"
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
const
{
debug
warn
}
=
GeckoViewUtils
.
initLogging
(
"
SessionStore
"
)
;
const
kNoIndex
=
Number
.
MAX_SAFE_INTEGER
;
const
kLastIndex
=
Number
.
MAX_SAFE_INTEGER
-
1
;
class
SHistoryListener
{
constructor
(
browsingContext
)
{
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsISHistoryListener
"
"
nsISupportsWeakReference
"
]
)
;
this
.
_browserId
=
browsingContext
.
browserId
;
this
.
_fromIndex
=
kNoIndex
;
}
unregister
(
permanentKey
)
{
const
bc
=
BrowsingContext
.
getCurrentTopByBrowserId
(
this
.
_browserId
)
;
bc
?
.
sessionHistory
?
.
removeSHistoryListener
(
this
)
;
GeckoViewSessionStore
.
_browserSHistoryListener
?
.
delete
(
permanentKey
)
;
}
collect
(
permanentKey
browsingContext
{
collectFull
=
true
writeToCache
=
false
}
)
{
if
(
!
collectFull
&
&
this
.
_fromIndex
=
=
=
kNoIndex
)
{
return
null
;
}
const
fromIndex
=
collectFull
?
-
1
:
this
.
_fromIndex
;
this
.
_fromIndex
=
kNoIndex
;
const
historychange
=
lazy
.
SessionHistory
.
collectFromParent
(
browsingContext
.
currentURI
?
.
spec
true
browsingContext
.
sessionHistory
fromIndex
)
;
if
(
writeToCache
)
{
const
win
=
browsingContext
.
embedderElement
?
.
ownerGlobal
|
|
browsingContext
.
currentWindowGlobal
?
.
browsingContext
?
.
window
;
GeckoViewSessionStore
.
onTabStateUpdate
(
permanentKey
win
{
data
:
{
historychange
}
}
)
;
}
return
historychange
;
}
collectFrom
(
index
)
{
if
(
this
.
_fromIndex
<
=
index
)
{
return
;
}
const
bc
=
BrowsingContext
.
getCurrentTopByBrowserId
(
this
.
_browserId
)
;
if
(
bc
?
.
embedderElement
?
.
frameLoader
)
{
this
.
_fromIndex
=
index
;
bc
.
embedderElement
.
frameLoader
.
requestSHistoryUpdate
(
)
;
}
}
OnHistoryNewEntry
(
newURI
oldIndex
)
{
this
.
collectFrom
(
oldIndex
=
=
-
1
?
oldIndex
:
oldIndex
-
1
)
;
}
OnHistoryGotoIndex
(
)
{
this
.
collectFrom
(
kLastIndex
)
;
}
OnHistoryPurge
(
)
{
this
.
collectFrom
(
-
1
)
;
}
OnHistoryReload
(
)
{
this
.
collectFrom
(
-
1
)
;
return
true
;
}
OnHistoryReplaceEntry
(
)
{
this
.
collectFrom
(
-
1
)
;
}
}
var
GeckoViewSessionStore
=
{
_browserSHistoryListener
:
new
WeakMap
(
)
observe
(
aSubject
aTopic
aData
)
{
debug
observe
{
aTopic
}
;
switch
(
aTopic
)
{
case
"
browsing
-
context
-
did
-
set
-
embedder
"
:
{
if
(
aSubject
&
&
aSubject
=
=
=
aSubject
.
top
&
&
aSubject
.
isContent
&
&
aSubject
.
embedderElement
&
&
aSubject
.
embedderElement
.
permanentKey
)
{
const
permanentKey
=
aSubject
.
embedderElement
.
permanentKey
;
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
?
.
unregister
(
permanentKey
)
;
this
.
getOrCreateSHistoryListener
(
permanentKey
aSubject
true
)
;
}
break
;
}
case
"
browsing
-
context
-
discarded
"
:
const
permanentKey
=
aSubject
?
.
embedderElement
?
.
permanentKey
;
if
(
permanentKey
)
{
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
?
.
unregister
(
permanentKey
)
;
}
break
;
}
}
onTabStateUpdate
(
permanentKey
win
data
)
{
win
.
WindowEventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
StateUpdated
"
data
:
data
.
data
}
)
;
}
getOrCreateSHistoryListener
(
permanentKey
browsingContext
collectImmediately
=
false
)
{
if
(
!
permanentKey
|
|
browsingContext
!
=
=
browsingContext
.
top
)
{
return
null
;
}
const
sessionHistory
=
browsingContext
.
sessionHistory
;
if
(
!
sessionHistory
)
{
return
null
;
}
let
listener
=
this
.
_browserSHistoryListener
.
get
(
permanentKey
)
;
if
(
listener
)
{
return
listener
;
}
listener
=
new
SHistoryListener
(
browsingContext
)
;
sessionHistory
.
addSHistoryListener
(
listener
)
;
this
.
_browserSHistoryListener
.
set
(
permanentKey
listener
)
;
if
(
collectImmediately
&
&
(
!
(
browsingContext
.
currentURI
?
.
spec
=
=
=
"
about
:
blank
"
)
|
|
sessionHistory
.
count
!
=
=
0
)
)
{
listener
.
collect
(
permanentKey
browsingContext
{
writeToCache
:
true
}
)
;
}
return
listener
;
}
}
;
