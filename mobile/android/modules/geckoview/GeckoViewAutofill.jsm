"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewAutofill
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
GeckoViewUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
FormLikeFactory
:
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
LoginManagerChild
:
"
resource
:
/
/
gre
/
modules
/
LoginManagerChild
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
{
debug
warn
}
=
GeckoViewUtils
.
initLogging
(
"
Autofill
"
)
;
class
GeckoViewAutofill
{
constructor
(
aEventDispatcher
)
{
this
.
_eventDispatcher
=
aEventDispatcher
;
this
.
_autofillElements
=
undefined
;
this
.
_autofillInfos
=
undefined
;
this
.
_autofillTasks
=
undefined
;
}
addElement
(
aFormLike
)
{
this
.
_addElement
(
aFormLike
false
)
;
}
_getInfo
(
aElement
aParent
aRoot
aUsernameField
)
{
if
(
!
this
.
_autofillInfos
)
{
this
.
_autofillInfos
=
new
WeakMap
(
)
;
this
.
_autofillElements
=
new
Map
(
)
;
}
let
info
=
this
.
_autofillInfos
.
get
(
aElement
)
;
if
(
info
)
{
return
info
;
}
const
window
=
aElement
.
ownerGlobal
;
const
bounds
=
aElement
.
getBoundingClientRect
(
)
;
const
isInputElement
=
window
.
HTMLInputElement
.
isInstance
(
aElement
)
;
info
=
{
isInputElement
uuid
:
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
parentUuid
:
aParent
rootUuid
:
aRoot
tag
:
aElement
.
tagName
type
:
isInputElement
?
aElement
.
type
:
null
value
:
isInputElement
?
aElement
.
value
:
null
editable
:
isInputElement
&
&
[
"
color
"
"
date
"
"
datetime
-
local
"
"
email
"
"
month
"
"
number
"
"
password
"
"
range
"
"
search
"
"
tel
"
"
text
"
"
time
"
"
url
"
"
week
"
]
.
includes
(
aElement
.
type
)
disabled
:
isInputElement
?
aElement
.
disabled
:
null
attributes
:
Object
.
assign
(
{
}
.
.
.
Array
.
from
(
aElement
.
attributes
)
.
filter
(
attr
=
>
attr
.
localName
!
=
=
"
value
"
)
.
map
(
attr
=
>
(
{
[
attr
.
localName
]
:
attr
.
value
}
)
)
)
origin
:
aElement
.
ownerDocument
.
location
.
origin
autofillhint
:
"
"
bounds
:
{
left
:
bounds
.
left
top
:
bounds
.
top
right
:
bounds
.
right
bottom
:
bounds
.
bottom
}
}
;
if
(
aElement
=
=
=
aUsernameField
)
{
info
.
autofillhint
=
"
username
"
;
}
else
if
(
isInputElement
)
{
const
autocompleteInfo
=
aElement
.
getAutocompleteInfo
(
)
;
if
(
autocompleteInfo
)
{
const
autocompleteAttr
=
autocompleteInfo
.
fieldName
;
if
(
autocompleteAttr
=
=
"
email
"
)
{
info
.
type
=
"
email
"
;
}
}
}
this
.
_autofillInfos
.
set
(
aElement
info
)
;
this
.
_autofillElements
.
set
(
info
.
uuid
Cu
.
getWeakReference
(
aElement
)
)
;
return
info
;
}
_updateInfoValues
(
aElements
)
{
if
(
!
this
.
_autofillInfos
)
{
return
[
]
;
}
const
updated
=
[
]
;
for
(
const
element
of
aElements
)
{
const
info
=
this
.
_autofillInfos
.
get
(
element
)
;
if
(
!
info
?
.
isInputElement
|
|
info
.
value
=
=
=
element
.
value
)
{
continue
;
}
debug
Updating
value
{
info
.
value
}
to
{
element
.
value
}
;
info
.
value
=
element
.
value
;
this
.
_autofillInfos
.
set
(
element
info
)
;
updated
.
push
(
info
)
;
}
return
updated
;
}
_addElement
(
aFormLike
aFromDeferredTask
)
{
let
task
=
this
.
_autofillTasks
&
&
this
.
_autofillTasks
.
get
(
aFormLike
.
rootElement
)
;
if
(
task
&
&
!
aFromDeferredTask
)
{
debug
Canceling
previous
auto
-
fill
task
;
task
.
disarm
(
)
;
task
=
null
;
}
if
(
!
task
)
{
if
(
aFromDeferredTask
)
{
debug
Auto
-
fill
task
canceled
;
return
;
}
debug
Deferring
auto
-
fill
task
;
task
=
new
DeferredTask
(
(
)
=
>
this
.
_addElement
(
aFormLike
true
)
100
)
;
task
.
arm
(
)
;
if
(
!
this
.
_autofillTasks
)
{
this
.
_autofillTasks
=
new
WeakMap
(
)
;
}
this
.
_autofillTasks
.
set
(
aFormLike
.
rootElement
task
)
;
return
;
}
debug
Adding
auto
-
fill
{
aFormLike
.
rootElement
.
tagName
}
;
this
.
_autofillTasks
.
delete
(
aFormLike
.
rootElement
)
;
const
window
=
aFormLike
.
rootElement
.
ownerGlobal
;
let
passwordField
;
for
(
const
field
of
aFormLike
.
elements
)
{
if
(
ChromeUtils
.
getClassName
(
field
)
=
=
=
"
HTMLInputElement
"
&
&
field
.
type
=
=
"
password
"
)
{
passwordField
=
field
;
break
;
}
}
const
[
usernameField
]
=
LoginManagerChild
.
forWindow
(
window
)
.
getUserNameAndPasswordFields
(
passwordField
|
|
aFormLike
.
elements
[
0
]
)
;
const
focusedElement
=
aFormLike
.
rootElement
.
ownerDocument
.
activeElement
;
let
sendFocusEvent
=
aFormLike
.
rootElement
=
=
=
focusedElement
;
const
rootInfo
=
this
.
_getInfo
(
aFormLike
.
rootElement
null
undefined
null
)
;
rootInfo
.
rootUuid
=
rootInfo
.
uuid
;
rootInfo
.
children
=
aFormLike
.
elements
.
filter
(
element
=
>
element
.
type
!
=
"
hidden
"
&
&
(
!
usernameField
|
|
element
.
type
!
=
"
text
"
|
|
element
=
=
usernameField
|
|
(
element
.
getAutocompleteInfo
(
)
&
&
element
.
getAutocompleteInfo
(
)
.
fieldName
=
=
"
email
"
)
)
)
.
map
(
element
=
>
{
sendFocusEvent
|
=
element
=
=
=
focusedElement
;
return
this
.
_getInfo
(
element
rootInfo
.
uuid
rootInfo
.
uuid
usernameField
)
;
}
)
;
this
.
_eventDispatcher
.
dispatch
(
"
GeckoView
:
AddAutofill
"
rootInfo
{
onSuccess
:
responses
=
>
{
debug
Performing
auto
-
fill
{
Object
.
keys
(
responses
)
}
;
const
AUTOFILL_STATE
=
"
autofill
"
;
const
winUtils
=
window
.
windowUtils
;
for
(
const
uuid
in
responses
)
{
const
entry
=
this
.
_autofillElements
&
&
this
.
_autofillElements
.
get
(
uuid
)
;
const
element
=
entry
&
&
entry
.
get
(
)
;
const
value
=
responses
[
uuid
]
|
|
"
"
;
if
(
window
.
HTMLInputElement
.
isInstance
(
element
)
&
&
!
element
.
disabled
&
&
element
.
parentElement
)
{
element
.
setUserInput
(
value
)
;
if
(
winUtils
&
&
element
.
value
=
=
=
value
)
{
winUtils
.
addManuallyManagedState
(
element
AUTOFILL_STATE
)
;
element
.
addEventListener
(
"
input
"
_
=
>
winUtils
.
removeManuallyManagedState
(
element
AUTOFILL_STATE
)
{
mozSystemGroup
:
true
once
:
true
}
)
;
}
}
else
if
(
element
)
{
warn
Don
'
t
know
how
to
auto
-
fill
{
element
.
tagName
}
;
}
}
}
onError
:
error
=
>
{
warn
Cannot
perform
autofill
{
error
}
;
}
}
)
;
if
(
sendFocusEvent
)
{
this
.
onFocus
(
aFormLike
.
ownerDocument
.
activeElement
)
;
}
}
onFocus
(
aTarget
)
{
debug
Auto
-
fill
focus
on
{
aTarget
&
&
aTarget
.
tagName
}
;
const
info
=
aTarget
&
&
this
.
_autofillInfos
&
&
this
.
_autofillInfos
.
get
(
aTarget
)
;
if
(
!
aTarget
|
|
info
)
{
this
.
_eventDispatcher
.
dispatch
(
"
GeckoView
:
OnAutofillFocus
"
info
)
;
}
}
commitAutofill
(
aFormLike
)
{
if
(
!
aFormLike
)
{
throw
new
Error
(
"
null
-
form
on
autofill
commit
"
)
;
}
debug
Committing
auto
-
fill
for
{
aFormLike
.
rootElement
.
tagName
}
;
const
updatedNodeInfos
=
this
.
_updateInfoValues
(
[
aFormLike
.
rootElement
.
.
.
aFormLike
.
elements
]
)
;
for
(
const
updatedInfo
of
updatedNodeInfos
)
{
debug
Updating
node
{
updatedInfo
}
;
this
.
_eventDispatcher
.
dispatch
(
"
GeckoView
:
UpdateAutofill
"
updatedInfo
)
;
}
const
info
=
this
.
_getInfo
(
aFormLike
.
rootElement
)
;
if
(
info
)
{
debug
Committing
node
{
info
}
;
this
.
_eventDispatcher
.
dispatch
(
"
GeckoView
:
CommitAutofill
"
info
)
;
}
}
clearElements
(
)
{
debug
Clearing
auto
-
fill
;
this
.
_autofillTasks
=
undefined
;
this
.
_autofillInfos
=
undefined
;
this
.
_autofillElements
=
undefined
;
this
.
_eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
ClearAutofill
"
}
)
;
}
scanDocument
(
aDoc
)
{
const
inputs
=
aDoc
.
querySelectorAll
(
"
input
[
type
=
password
]
"
)
;
let
inputAdded
=
false
;
for
(
let
i
=
0
;
i
<
inputs
.
length
;
i
+
+
)
{
if
(
inputs
[
i
]
.
form
)
{
this
.
_addElement
(
FormLikeFactory
.
createFromForm
(
inputs
[
i
]
.
form
)
)
;
}
else
if
(
!
inputAdded
)
{
inputAdded
=
true
;
this
.
_addElement
(
FormLikeFactory
.
createFromField
(
inputs
[
i
]
)
)
;
}
}
const
frames
=
aDoc
.
defaultView
.
frames
;
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
this
.
scanDocument
(
frames
[
i
]
.
document
)
;
}
}
}
