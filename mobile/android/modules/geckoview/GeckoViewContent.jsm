"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
GeckoViewContent
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewModule
.
jsm
"
)
;
var
dump
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
d
.
bind
(
null
"
ViewContent
"
)
;
function
debug
(
aMsg
)
{
}
class
GeckoViewContent
extends
GeckoViewModule
{
init
(
)
{
this
.
frameScriptLoaded
=
false
;
}
register
(
)
{
if
(
!
this
.
frameScriptLoaded
)
{
this
.
messageManager
.
loadFrameScript
(
"
chrome
:
/
/
geckoview
/
content
/
GeckoViewContent
.
js
"
true
)
;
this
.
frameScriptLoaded
=
true
;
}
this
.
window
.
addEventListener
(
"
MozDOMFullScreen
:
Entered
"
this
true
false
)
;
this
.
window
.
addEventListener
(
"
MozDOMFullScreen
:
Exited
"
this
true
false
)
;
this
.
eventDispatcher
.
registerListener
(
this
"
GeckoViewContent
:
ExitFullScreen
"
)
;
this
.
messageManager
.
addMessageListener
(
"
GeckoView
:
DOMFullscreenExit
"
this
)
;
this
.
messageManager
.
addMessageListener
(
"
GeckoView
:
DOMFullscreenRequest
"
this
)
;
this
.
messageManager
.
addMessageListener
(
"
GeckoView
:
DOMTitleChanged
"
this
)
;
this
.
messageManager
.
addMessageListener
(
"
GeckoView
:
ContextMenu
"
this
)
;
}
onEvent
(
aEvent
aData
aCallback
)
{
debug
(
"
onEvent
:
"
+
aEvent
)
;
switch
(
aEvent
)
{
case
"
GeckoViewContent
:
ExitFullScreen
"
:
this
.
messageManager
.
sendAsyncMessage
(
"
GeckoView
:
DOMFullscreenExited
"
)
;
break
;
}
}
unregister
(
)
{
this
.
window
.
removeEventListener
(
"
MozDOMFullScreen
:
Entered
"
this
true
)
;
this
.
window
.
removeEventListener
(
"
MozDOMFullScreen
:
Exited
"
this
true
)
;
this
.
eventDispatcher
.
unregisterListener
(
this
"
GeckoViewContent
:
ExitFullScreen
"
)
;
this
.
messageManager
.
removeMessageListener
(
"
GeckoView
:
DOMFullscreenExit
"
this
)
;
this
.
messageManager
.
removeMessageListener
(
"
GeckoView
:
DOMFullscreenRequest
"
this
)
;
this
.
messageManager
.
removeMessageListener
(
"
GeckoView
:
DOMTitleChanged
"
this
)
;
this
.
messageManager
.
removeMessageListener
(
"
GeckoView
:
ContextMenu
"
this
)
;
}
handleEvent
(
aEvent
)
{
debug
(
"
handleEvent
:
aEvent
.
type
=
"
+
aEvent
.
type
)
;
switch
(
aEvent
.
type
)
{
case
"
MozDOMFullscreen
:
Entered
"
:
if
(
this
.
browser
=
=
aEvent
.
target
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
GeckoView
:
DOMFullscreenEntered
"
)
;
}
break
;
case
"
MozDOMFullscreen
:
Exited
"
:
this
.
messageManager
.
sendAsyncMessage
(
"
GeckoView
:
DOMFullscreenExited
"
)
;
break
;
}
}
receiveMessage
(
aMsg
)
{
debug
(
"
receiveMessage
"
+
aMsg
.
name
)
;
switch
(
aMsg
.
name
)
{
case
"
GeckoView
:
ContextMenu
"
:
this
.
eventDispatcher
.
sendRequest
(
{
type
:
aMsg
.
name
screenX
:
aMsg
.
data
.
screenX
screenY
:
aMsg
.
data
.
screenY
imageSrc
:
aMsg
.
data
.
imageSrc
uri
:
aMsg
.
data
.
uri
}
)
;
break
;
case
"
GeckoView
:
DOMFullscreenExit
"
:
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
remoteFrameFullscreenReverted
(
)
;
break
;
case
"
GeckoView
:
DOMFullscreenRequest
"
:
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
remoteFrameFullscreenChanged
(
aMsg
.
target
)
;
break
;
case
"
GeckoView
:
DOMTitleChanged
"
:
this
.
eventDispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
DOMTitleChanged
"
title
:
aMsg
.
data
.
title
}
)
;
break
;
}
}
}
