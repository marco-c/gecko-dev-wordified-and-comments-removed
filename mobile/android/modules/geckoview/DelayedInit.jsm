"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DelayedInit
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
MessageLoop
"
"
mozilla
.
org
/
message
-
loop
;
1
"
"
nsIMessageLoop
"
)
;
var
DelayedInit
=
{
schedule
(
fn
object
name
maxWait
)
{
return
Impl
.
scheduleInit
(
fn
object
name
maxWait
)
;
}
scheduleList
(
fns
maxWait
)
{
for
(
const
fn
of
fns
)
{
Impl
.
scheduleInit
(
fn
null
null
maxWait
)
;
}
}
}
;
const
MAX_IDLE_RUN_MS
=
50
;
var
Impl
=
{
pendingInits
:
[
]
onIdle
(
)
{
const
startTime
=
Cu
.
now
(
)
;
let
time
=
startTime
;
let
nextDue
;
for
(
const
init
of
this
.
pendingInits
)
{
if
(
init
.
complete
)
{
continue
;
}
if
(
time
-
startTime
<
MAX_IDLE_RUN_MS
)
{
init
.
maybeInit
(
)
;
time
=
Cu
.
now
(
)
;
}
else
{
nextDue
=
nextDue
?
Math
.
min
(
nextDue
init
.
due
)
:
init
.
due
;
}
}
this
.
pendingInits
=
this
.
pendingInits
.
filter
(
init
=
>
!
init
.
complete
)
;
if
(
nextDue
!
=
=
undefined
)
{
MessageLoop
.
postIdleTask
(
(
)
=
>
this
.
onIdle
(
)
Math
.
max
(
0
nextDue
-
time
)
)
;
}
}
addPendingInit
(
fn
wait
)
{
const
init
=
{
fn
due
:
Cu
.
now
(
)
+
wait
complete
:
false
maybeInit
(
)
{
if
(
this
.
complete
)
{
return
false
;
}
this
.
complete
=
true
;
this
.
fn
.
call
(
)
;
this
.
fn
=
null
;
return
true
;
}
}
;
if
(
!
this
.
pendingInits
.
length
)
{
MessageLoop
.
postIdleTask
(
(
)
=
>
this
.
onIdle
(
)
wait
)
;
}
this
.
pendingInits
.
push
(
init
)
;
return
init
;
}
scheduleInit
(
fn
object
name
wait
)
{
const
init
=
this
.
addPendingInit
(
fn
wait
)
;
if
(
!
object
|
|
!
name
)
{
return
;
}
let
prop
=
Object
.
getOwnPropertyDescriptor
(
object
name
)
|
|
{
configurable
:
true
enumerable
:
true
writable
:
true
}
;
if
(
!
prop
.
configurable
)
{
init
.
maybeInit
(
)
;
return
;
}
Object
.
defineProperty
(
object
name
{
get
:
function
proxy_getter
(
)
{
init
.
maybeInit
(
)
;
const
newProp
=
Object
.
getOwnPropertyDescriptor
(
object
name
)
;
if
(
newProp
.
get
!
=
=
proxy_getter
)
{
prop
=
newProp
;
}
else
{
Object
.
defineProperty
(
object
name
prop
)
;
}
if
(
prop
.
get
)
{
return
prop
.
get
.
call
(
object
)
;
}
return
prop
.
value
;
}
set
(
newVal
)
{
init
.
maybeInit
(
)
;
if
(
prop
.
get
|
|
prop
.
set
)
{
Object
.
defineProperty
(
object
name
prop
)
;
prop
.
set
.
call
(
object
)
;
return
;
}
prop
.
value
=
newVal
;
Object
.
defineProperty
(
object
name
prop
)
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
}
;
