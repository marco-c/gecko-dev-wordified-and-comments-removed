"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
GeckoViewProgress
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewModule
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
EventDispatcher
"
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
dump
"
(
)
=
>
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
d
.
bind
(
null
"
ViewProgress
"
)
)
;
function
debug
(
aMsg
)
{
}
var
IdentityHandler
=
{
IDENTITY_MODE_UNKNOWN
:
0
IDENTITY_MODE_IDENTIFIED
:
1
IDENTITY_MODE_VERIFIED
:
2
MIXED_MODE_UNKNOWN
:
0
MIXED_MODE_CONTENT_BLOCKED
:
1
MIXED_MODE_CONTENT_LOADED
:
2
TRACKING_MODE_UNKNOWN
:
0
TRACKING_MODE_CONTENT_BLOCKED
:
1
TRACKING_MODE_CONTENT_LOADED
:
2
_useTrackingProtection
:
false
_usePrivateMode
:
false
setUseTrackingProtection
:
function
(
aUse
)
{
this
.
_useTrackingProtection
=
aUse
;
}
setUsePrivateMode
:
function
(
aUse
)
{
this
.
_usePrivateMode
=
aUse
;
}
getIdentityMode
:
function
getIdentityMode
(
aState
)
{
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
)
{
return
this
.
IDENTITY_MODE_VERIFIED
;
}
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
)
{
return
this
.
IDENTITY_MODE_IDENTIFIED
;
}
return
this
.
IDENTITY_MODE_UNKNOWN
;
}
getMixedDisplayMode
:
function
getMixedDisplayMode
(
aState
)
{
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
{
return
this
.
MIXED_MODE_CONTENT_LOADED
;
}
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_DISPLAY_CONTENT
)
{
return
this
.
MIXED_MODE_CONTENT_BLOCKED
;
}
return
this
.
MIXED_MODE_UNKNOWN
;
}
getMixedActiveMode
:
function
getActiveDisplayMode
(
aState
)
{
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
security
.
mixed_content
.
block_active_content
"
)
)
{
return
this
.
MIXED_MODE_CONTENT_LOADED
;
}
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
{
return
this
.
MIXED_MODE_CONTENT_BLOCKED
;
}
return
this
.
MIXED_MODE_UNKNOWN
;
}
getTrackingMode
:
function
getTrackingMode
(
aState
)
{
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_TRACKING_CONTENT
)
{
return
this
.
TRACKING_MODE_CONTENT_BLOCKED
;
}
if
(
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_TRACKING_CONTENT
)
&
&
this
.
_useTrackingProtection
)
{
return
this
.
TRACKING_MODE_CONTENT_LOADED
;
}
return
this
.
TRACKING_MODE_UNKNOWN
;
}
checkIdentity
:
function
checkIdentity
(
aState
aBrowser
)
{
let
lastStatus
=
aBrowser
.
securityUI
.
QueryInterface
(
Ci
.
nsISSLStatusProvider
)
.
SSLStatus
;
let
lastLocation
=
{
}
;
try
{
let
location
=
aBrowser
.
contentWindow
.
location
;
lastLocation
.
host
=
location
.
host
;
lastLocation
.
hostname
=
location
.
hostname
;
lastLocation
.
port
=
location
.
port
;
lastLocation
.
origin
=
location
.
origin
;
}
catch
(
ex
)
{
}
let
uri
=
aBrowser
.
currentURI
;
try
{
uri
=
Services
.
uriFixup
.
createExposableURI
(
uri
)
;
}
catch
(
e
)
{
}
let
identityMode
=
this
.
getIdentityMode
(
aState
)
;
let
mixedDisplay
=
this
.
getMixedDisplayMode
(
aState
)
;
let
mixedActive
=
this
.
getMixedActiveMode
(
aState
)
;
let
trackingMode
=
this
.
getTrackingMode
(
aState
)
;
let
result
=
{
origin
:
lastLocation
.
origin
mode
:
{
identity
:
identityMode
mixed_display
:
mixedDisplay
mixed_active
:
mixedActive
tracking
:
trackingMode
}
}
;
if
(
identityMode
=
=
=
this
.
IDENTITY_MODE_UNKNOWN
|
|
aState
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
)
{
result
.
secure
=
false
;
return
result
;
}
result
.
secure
=
true
;
result
.
host
=
this
.
getEffectiveHost
(
lastLocation
uri
)
;
let
status
=
lastStatus
.
QueryInterface
(
Ci
.
nsISSLStatus
)
;
let
cert
=
status
.
serverCert
;
result
.
organization
=
cert
.
organization
;
result
.
subjectName
=
cert
.
subjectName
;
result
.
issuerOrganization
=
cert
.
issuerOrganization
;
result
.
issuerCommonName
=
cert
.
issuerCommonName
;
if
(
!
this
.
_overrideService
)
{
this
.
_overrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
}
if
(
lastLocation
.
hostname
&
&
this
.
_overrideService
.
hasMatchingOverride
(
lastLocation
.
hostname
(
lastLocation
.
port
|
|
443
)
cert
{
}
{
}
)
)
{
result
.
securityException
=
true
;
}
return
result
;
}
getEffectiveHost
:
function
getEffectiveHost
(
aLastLocation
aUri
)
{
if
(
!
this
.
_IDNService
)
{
this
.
_IDNService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
}
try
{
return
this
.
_IDNService
.
convertToDisplayIDN
(
aUri
.
host
{
}
)
;
}
catch
(
e
)
{
return
aLastLocation
.
hostname
;
}
}
}
;
class
GeckoViewProgress
extends
GeckoViewModule
{
init
(
)
{
this
.
_hostChanged
=
false
;
}
register
(
)
{
debug
(
"
register
"
)
;
let
flags
=
Ci
.
nsIWebProgress
.
NOTIFY_STATE_NETWORK
|
Ci
.
nsIWebProgress
.
NOTIFY_SECURITY
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
;
this
.
progressFilter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
this
.
progressFilter
.
addProgressListener
(
this
flags
)
;
this
.
browser
.
addProgressListener
(
this
.
progressFilter
flags
)
;
}
unregister
(
)
{
debug
(
"
unregister
"
)
;
if
(
this
.
progressFilter
)
{
this
.
progressFilter
.
removeProgressListener
(
this
)
;
this
.
browser
.
removeProgressListener
(
this
.
progressFilter
)
;
}
}
onSettingsUpdate
(
)
{
let
settings
=
this
.
settings
;
debug
(
"
onSettingsUpdate
:
"
+
JSON
.
stringify
(
settings
)
)
;
IdentityHandler
.
setUseTrackingProtection
(
!
!
settings
.
useTrackingProtection
)
;
IdentityHandler
.
setUsePrivateMode
(
!
!
settings
.
usePrivateMode
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
debug
(
"
onStateChange
(
)
"
)
;
if
(
!
aWebProgress
.
isTopLevel
)
{
return
;
}
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
let
uri
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
.
URI
;
let
message
=
{
type
:
"
GeckoView
:
PageStart
"
uri
:
uri
.
displaySpec
}
;
this
.
eventDispatcher
.
sendRequest
(
message
)
;
}
else
if
(
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
&
&
!
aWebProgress
.
isLoadingDocument
)
{
let
message
=
{
type
:
"
GeckoView
:
PageStop
"
success
:
!
aStatus
}
;
this
.
eventDispatcher
.
sendRequest
(
message
)
;
}
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
if
(
this
.
_state
=
=
=
aState
&
&
!
this
.
_hostChanged
)
{
return
;
}
this
.
_state
=
aState
;
this
.
_hostChanged
=
false
;
let
identity
=
IdentityHandler
.
checkIdentity
(
aState
this
.
browser
)
;
let
message
=
{
type
:
"
GeckoView
:
SecurityChanged
"
identity
:
identity
}
;
this
.
eventDispatcher
.
sendRequest
(
message
)
;
}
onLocationChange
(
aWebProgress
aRequest
aLocationURI
aFlags
)
{
this
.
_hostChanged
=
true
;
}
}
