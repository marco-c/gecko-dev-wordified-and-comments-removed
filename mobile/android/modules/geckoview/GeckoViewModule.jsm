"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewModule
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
)
;
GeckoViewUtils
.
initLogging
(
"
GeckoView
.
Module
"
this
)
;
class
GeckoViewModule
{
constructor
(
aModuleInfo
)
{
this
.
_info
=
aModuleInfo
;
this
.
_isContentLoaded
=
false
;
this
.
_eventProxy
=
new
EventProxy
(
this
this
.
eventDispatcher
)
;
this
.
onInitBrowser
(
)
;
}
get
name
(
)
{
return
this
.
_info
.
name
;
}
get
enabled
(
)
{
return
this
.
_info
.
enabled
;
}
get
window
(
)
{
return
this
.
_info
.
manager
.
window
;
}
get
browser
(
)
{
return
this
.
_info
.
manager
.
browser
;
}
get
messageManager
(
)
{
return
this
.
_info
.
manager
.
messageManager
;
}
get
eventDispatcher
(
)
{
return
this
.
_info
.
manager
.
eventDispatcher
;
}
get
settings
(
)
{
return
this
.
_info
.
manager
.
settings
;
}
onInitBrowser
(
)
{
}
onInit
(
)
{
}
onDestroy
(
)
{
}
onSettingsUpdate
(
)
{
}
onEnable
(
)
{
}
onDisable
(
)
{
}
onLoadContentModule
(
)
{
this
.
_eventProxy
.
enableQueuing
(
true
)
;
}
onContentModuleLoaded
(
)
{
this
.
_eventProxy
.
enableQueuing
(
false
)
;
this
.
_eventProxy
.
dispatchQueuedEvents
(
)
;
}
registerListener
(
aEventList
)
{
this
.
_eventProxy
.
registerListener
(
aEventList
)
;
}
unregisterListener
(
)
{
this
.
_eventProxy
.
unregisterListener
(
)
;
}
}
class
EventProxy
{
constructor
(
aListener
aEventDispatcher
)
{
this
.
listener
=
aListener
;
this
.
eventDispatcher
=
aEventDispatcher
;
this
.
_eventQueue
=
[
]
;
this
.
_registeredEvents
=
[
]
;
this
.
_enableQueuing
=
false
;
}
registerListener
(
aEventList
)
{
debug
registerListener
{
aEventList
}
;
this
.
eventDispatcher
.
registerListener
(
this
aEventList
)
;
this
.
_registeredEvents
=
this
.
_registeredEvents
.
concat
(
aEventList
)
;
}
unregisterListener
(
)
{
debug
unregisterListener
;
if
(
this
.
_registeredEvents
.
length
=
=
=
0
)
{
return
;
}
this
.
eventDispatcher
.
unregisterListener
(
this
this
.
_registeredEvents
)
;
this
.
_registeredEvents
=
[
]
;
}
onEvent
(
aEvent
aData
aCallback
)
{
if
(
this
.
_enableQueuing
)
{
debug
queue
{
aEvent
}
data
=
{
aData
}
;
this
.
_eventQueue
.
unshift
(
arguments
)
;
}
else
{
this
.
_dispatch
(
.
.
.
arguments
)
;
}
}
enableQueuing
(
aEnable
)
{
debug
enableQueuing
{
aEnable
}
;
this
.
_enableQueuing
=
aEnable
;
}
_dispatch
(
aEvent
aData
aCallback
)
{
debug
dispatch
{
aEvent
}
data
=
{
aData
}
;
if
(
this
.
listener
.
onEvent
)
{
this
.
listener
.
onEvent
(
.
.
.
arguments
)
;
}
else
{
this
.
listener
(
.
.
.
arguments
)
;
}
}
dispatchQueuedEvents
(
)
{
debug
dispatchQueued
;
while
(
this
.
_eventQueue
.
length
)
{
const
args
=
this
.
_eventQueue
.
pop
(
)
;
this
.
_dispatch
(
.
.
.
args
)
;
}
}
}
