"
use
strict
"
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
GeckoViewUtils
"
]
;
var
GeckoViewUtils
=
{
addLazyGetter
:
function
(
scope
name
{
script
service
module
handler
observers
ppmm
mm
ged
init
once
}
)
{
if
(
script
)
{
XPCOMUtils
.
defineLazyScriptGetter
(
scope
name
script
)
;
}
else
{
XPCOMUtils
.
defineLazyGetter
(
scope
name
_
=
>
{
let
ret
=
undefined
;
if
(
module
)
{
ret
=
Cu
.
import
(
module
{
}
)
[
name
]
;
}
else
if
(
service
)
{
ret
=
Cc
[
service
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
else
if
(
typeof
handler
=
=
=
"
function
"
)
{
ret
=
{
handleEvent
:
handler
observe
:
handler
onEvent
:
handler
receiveMessage
:
handler
}
;
}
else
if
(
handler
)
{
ret
=
handler
;
}
if
(
ret
&
&
init
)
{
init
.
call
(
scope
ret
)
;
}
return
ret
;
}
)
;
}
if
(
observers
)
{
let
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
if
(
!
once
)
{
Services
.
obs
.
addObserver
(
scope
[
name
]
topic
)
;
}
scope
[
name
]
.
observe
(
subject
topic
data
)
;
}
;
observers
.
forEach
(
topic
=
>
Services
.
obs
.
addObserver
(
observer
topic
)
)
;
}
if
(
ppmm
|
|
mm
)
{
let
target
=
ppmm
?
Services
.
ppmm
:
Services
.
mm
;
let
listener
=
msg
=
>
{
target
.
removeMessageListener
(
msg
.
name
listener
)
;
if
(
!
once
)
{
target
.
addMessageListener
(
msg
.
name
scope
[
name
]
)
;
}
scope
[
name
]
.
receiveMessage
(
msg
)
;
}
;
(
ppmm
|
|
mm
)
.
forEach
(
msg
=
>
target
.
addMessageListener
(
msg
listener
)
)
;
}
if
(
ged
)
{
let
listener
=
(
event
data
callback
)
=
>
{
EventDispatcher
.
instance
.
unregisterListener
(
listener
event
)
;
if
(
!
once
)
{
EventDispatcher
.
instance
.
registerListener
(
scope
[
name
]
event
)
;
}
scope
[
name
]
.
onEvent
(
event
data
callback
)
;
}
;
EventDispatcher
.
instance
.
registerListener
(
listener
ged
)
;
}
}
addLazyEventListener
:
function
(
target
events
{
handler
scope
name
options
}
)
{
if
(
!
handler
)
{
handler
=
(
_
=
>
Array
.
isArray
(
name
)
?
name
.
map
(
n
=
>
scope
[
n
]
)
:
scope
[
name
]
)
;
}
let
listener
=
event
=
>
{
let
handlers
=
handler
(
event
)
;
if
(
!
handlers
)
{
return
;
}
if
(
!
Array
.
isArray
(
handlers
)
)
{
handlers
=
[
handlers
]
;
}
if
(
!
options
|
|
!
options
.
once
)
{
target
.
removeEventListener
(
event
.
type
listener
options
)
;
handlers
.
forEach
(
handler
=
>
target
.
addEventListener
(
event
.
type
handler
options
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
handleEvent
(
event
)
)
;
}
;
if
(
Array
.
isArray
(
events
)
)
{
events
.
forEach
(
event
=
>
target
.
addEventListener
(
event
listener
options
)
)
;
}
else
{
target
.
addEventListener
(
events
listener
options
)
;
}
}
getChromeWindow
:
function
(
aWin
)
{
return
aWin
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
getDispatcherForWindow
:
function
(
aWin
)
{
let
win
=
this
.
getChromeWindow
(
aWin
.
top
)
;
return
win
.
WindowEventDispatcher
|
|
EventDispatcher
.
for
(
win
)
;
}
}
;
