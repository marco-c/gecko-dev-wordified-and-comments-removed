"
use
strict
"
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
GeckoViewUtils
"
]
;
var
GeckoViewUtils
=
{
addLazyGetter
:
function
(
scope
name
{
script
service
module
handler
observers
ppmm
mm
ged
init
once
}
)
{
if
(
script
)
{
XPCOMUtils
.
defineLazyScriptGetter
(
scope
name
script
)
;
}
else
{
XPCOMUtils
.
defineLazyGetter
(
scope
name
_
=
>
{
let
ret
=
undefined
;
if
(
module
)
{
ret
=
Cu
.
import
(
module
{
}
)
[
name
]
;
}
else
if
(
service
)
{
ret
=
Cc
[
service
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
else
if
(
typeof
handler
=
=
=
"
function
"
)
{
ret
=
{
handleEvent
:
handler
observe
:
handler
onEvent
:
handler
receiveMessage
:
handler
}
;
}
else
if
(
handler
)
{
ret
=
handler
;
}
if
(
ret
&
&
init
)
{
init
.
call
(
scope
ret
)
;
}
return
ret
;
}
)
;
}
if
(
observers
)
{
let
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
if
(
!
once
)
{
Services
.
obs
.
addObserver
(
scope
[
name
]
topic
)
;
}
scope
[
name
]
.
observe
(
subject
topic
data
)
;
}
;
observers
.
forEach
(
topic
=
>
Services
.
obs
.
addObserver
(
observer
topic
)
)
;
}
let
addMMListener
=
(
target
names
)
=
>
{
let
listener
=
msg
=
>
{
target
.
removeMessageListener
(
msg
.
name
listener
)
;
if
(
!
once
)
{
target
.
addMessageListener
(
msg
.
name
scope
[
name
]
)
;
}
scope
[
name
]
.
receiveMessage
(
msg
)
;
}
;
names
.
forEach
(
msg
=
>
target
.
addMessageListener
(
msg
listener
)
)
;
}
;
if
(
ppmm
)
{
addMMListener
(
Services
.
ppmm
ppmm
)
;
}
if
(
mm
)
{
addMMListener
(
Services
.
mm
mm
)
;
}
if
(
ged
)
{
let
listener
=
(
event
data
callback
)
=
>
{
EventDispatcher
.
instance
.
unregisterListener
(
listener
event
)
;
if
(
!
once
)
{
EventDispatcher
.
instance
.
registerListener
(
scope
[
name
]
event
)
;
}
scope
[
name
]
.
onEvent
(
event
data
callback
)
;
}
;
EventDispatcher
.
instance
.
registerListener
(
listener
ged
)
;
}
}
_addLazyListeners
:
function
(
events
handler
scope
name
addFn
handleFn
)
{
if
(
!
handler
)
{
handler
=
(
_
=
>
Array
.
isArray
(
name
)
?
name
.
map
(
n
=
>
scope
[
n
]
)
:
scope
[
name
]
)
;
}
let
listener
=
(
.
.
.
args
)
=
>
{
let
handlers
=
handler
(
.
.
.
args
)
;
if
(
!
handlers
)
{
return
;
}
if
(
!
Array
.
isArray
(
handlers
)
)
{
handlers
=
[
handlers
]
;
}
handleFn
(
handlers
listener
args
)
;
}
;
if
(
Array
.
isArray
(
events
)
)
{
addFn
(
events
listener
)
;
}
else
{
addFn
(
[
events
]
listener
)
;
}
}
addLazyEventListener
:
function
(
target
events
{
handler
scope
name
options
}
)
{
this
.
_addLazyListeners
(
events
handler
scope
name
(
events
listener
)
=
>
{
events
.
forEach
(
event
=
>
target
.
addEventListener
(
event
listener
options
)
)
;
}
(
handlers
listener
args
)
=
>
{
if
(
!
options
|
|
!
options
.
once
)
{
target
.
removeEventListener
(
args
[
0
]
.
type
listener
options
)
;
handlers
.
forEach
(
handler
=
>
target
.
addEventListener
(
args
[
0
]
.
type
handler
options
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
handleEvent
(
args
[
0
]
)
)
;
}
)
;
}
registerLazyWindowEventListener
:
function
(
window
events
{
handler
scope
name
once
}
)
{
let
dispatcher
=
this
.
getDispatcherForWindow
(
window
)
;
this
.
_addLazyListeners
(
events
handler
scope
name
(
events
listener
)
=
>
{
dispatcher
.
registerListener
(
listener
events
)
;
}
(
handlers
listener
args
)
=
>
{
if
(
!
once
)
{
dispatcher
.
unregisterListener
(
listener
args
[
0
]
)
;
handlers
.
forEach
(
handler
=
>
dispatcher
.
registerListener
(
handler
args
[
0
]
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
onEvent
(
.
.
.
args
)
)
;
}
)
;
}
getChromeWindow
:
function
(
aWin
)
{
if
(
!
aWin
)
{
return
null
;
}
let
docShell
;
try
{
docShell
=
aWin
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
}
catch
(
e
)
{
docShell
=
aWin
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
}
return
docShell
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
getDispatcherForWindow
:
function
(
aWin
)
{
try
{
let
win
=
this
.
getChromeWindow
(
aWin
.
top
|
|
aWin
)
;
let
dispatcher
=
win
.
WindowEventDispatcher
|
|
EventDispatcher
.
for
(
win
)
;
if
(
!
win
.
closed
&
&
dispatcher
)
{
return
dispatcher
;
}
}
catch
(
e
)
{
return
null
;
}
}
getActiveDispatcher
:
function
(
)
{
let
dispatcher
=
this
.
getDispatcherForWindow
(
Services
.
focus
.
activeWindow
)
;
if
(
dispatcher
)
{
return
dispatcher
;
}
let
iter
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
iter
.
hasMoreElements
(
)
)
{
dispatcher
=
this
.
getDispatcherForWindow
(
iter
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
)
;
if
(
dispatcher
)
{
return
dispatcher
;
}
}
return
null
;
}
}
;
