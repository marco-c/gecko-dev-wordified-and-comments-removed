"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
clearTimeout
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AndroidLog
:
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewUtils
"
]
;
class
AndroidFormatter
extends
Log
.
BasicFormatter
{
format
(
message
)
{
return
this
.
formatText
(
message
)
;
}
}
class
AndroidAppender
extends
Log
.
Appender
{
constructor
(
aFormatter
)
{
super
(
aFormatter
|
|
new
AndroidFormatter
(
)
)
;
this
.
_name
=
"
AndroidAppender
"
;
this
.
_mapping
=
{
[
Log
.
Level
.
Fatal
]
:
"
e
"
[
Log
.
Level
.
Error
]
:
"
e
"
[
Log
.
Level
.
Warn
]
:
"
w
"
[
Log
.
Level
.
Info
]
:
"
i
"
[
Log
.
Level
.
Config
]
:
"
d
"
[
Log
.
Level
.
Debug
]
:
"
d
"
[
Log
.
Level
.
Trace
]
:
"
v
"
}
;
}
append
(
aMessage
)
{
if
(
!
aMessage
)
{
return
;
}
const
tag
=
aMessage
.
loggerName
.
replace
(
/
^
Gecko
|
\
.
/
g
"
"
)
;
const
msg
=
this
.
_formatter
.
format
(
aMessage
)
;
lazy
.
AndroidLog
[
this
.
_mapping
[
aMessage
.
level
]
]
(
tag
msg
)
;
}
}
var
GeckoViewUtils
=
{
addLazyGetter
(
scope
name
{
service
module
handler
observers
ppmm
mm
ged
init
once
}
)
{
XPCOMUtils
.
defineLazyGetter
(
scope
name
_
=
>
{
let
ret
=
undefined
;
if
(
module
)
{
ret
=
ChromeUtils
.
import
(
module
)
[
name
]
;
}
else
if
(
service
)
{
ret
=
Cc
[
service
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
else
if
(
typeof
handler
=
=
=
"
function
"
)
{
ret
=
{
handleEvent
:
handler
observe
:
handler
onEvent
:
handler
receiveMessage
:
handler
}
;
}
else
if
(
handler
)
{
ret
=
handler
;
}
if
(
ret
&
&
init
)
{
init
.
call
(
scope
ret
)
;
}
return
ret
;
}
)
;
if
(
observers
)
{
const
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
if
(
!
once
)
{
Services
.
obs
.
addObserver
(
scope
[
name
]
topic
)
;
}
scope
[
name
]
.
observe
(
subject
topic
data
)
;
}
;
observers
.
forEach
(
topic
=
>
Services
.
obs
.
addObserver
(
observer
topic
)
)
;
}
if
(
!
this
.
IS_PARENT_PROCESS
)
{
return
;
}
const
addMMListener
=
(
target
names
)
=
>
{
const
listener
=
msg
=
>
{
target
.
removeMessageListener
(
msg
.
name
listener
)
;
if
(
!
once
)
{
target
.
addMessageListener
(
msg
.
name
scope
[
name
]
)
;
}
scope
[
name
]
.
receiveMessage
(
msg
)
;
}
;
names
.
forEach
(
msg
=
>
target
.
addMessageListener
(
msg
listener
)
)
;
}
;
if
(
ppmm
)
{
addMMListener
(
Services
.
ppmm
ppmm
)
;
}
if
(
mm
)
{
addMMListener
(
Services
.
mm
mm
)
;
}
if
(
ged
)
{
const
listener
=
(
event
data
callback
)
=
>
{
lazy
.
EventDispatcher
.
instance
.
unregisterListener
(
listener
event
)
;
if
(
!
once
)
{
lazy
.
EventDispatcher
.
instance
.
registerListener
(
scope
[
name
]
event
)
;
}
scope
[
name
]
.
onEvent
(
event
data
callback
)
;
}
;
lazy
.
EventDispatcher
.
instance
.
registerListener
(
listener
ged
)
;
}
}
_addLazyListeners
(
events
handler
scope
name
addFn
handleFn
)
{
if
(
!
handler
)
{
handler
=
_
=
>
Array
.
isArray
(
name
)
?
name
.
map
(
n
=
>
scope
[
n
]
)
:
scope
[
name
]
;
}
const
listener
=
(
.
.
.
args
)
=
>
{
let
handlers
=
handler
(
.
.
.
args
)
;
if
(
!
handlers
)
{
return
;
}
if
(
!
Array
.
isArray
(
handlers
)
)
{
handlers
=
[
handlers
]
;
}
handleFn
(
handlers
listener
args
)
;
}
;
if
(
Array
.
isArray
(
events
)
)
{
addFn
(
events
listener
)
;
}
else
{
addFn
(
[
events
]
listener
)
;
}
}
addLazyEventListener
(
target
events
{
handler
scope
name
options
}
)
{
this
.
_addLazyListeners
(
events
handler
scope
name
(
events
listener
)
=
>
{
events
.
forEach
(
event
=
>
target
.
addEventListener
(
event
listener
options
)
)
;
}
(
handlers
listener
args
)
=
>
{
if
(
!
options
|
|
!
options
.
once
)
{
target
.
removeEventListener
(
args
[
0
]
.
type
listener
options
)
;
handlers
.
forEach
(
handler
=
>
target
.
addEventListener
(
args
[
0
]
.
type
handler
options
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
handleEvent
(
args
[
0
]
)
)
;
}
)
;
}
addLazyPrefObserver
(
aPrefs
{
handler
scope
name
once
}
)
{
this
.
_addLazyListeners
(
aPrefs
handler
scope
name
(
prefs
observer
)
=
>
{
prefs
.
forEach
(
pref
=
>
Services
.
prefs
.
addObserver
(
pref
.
name
observer
)
)
;
prefs
.
forEach
(
pref
=
>
{
if
(
pref
.
default
=
=
=
undefined
)
{
return
;
}
let
value
;
switch
(
typeof
pref
.
default
)
{
case
"
string
"
:
value
=
Services
.
prefs
.
getCharPref
(
pref
.
name
pref
.
default
)
;
break
;
case
"
number
"
:
value
=
Services
.
prefs
.
getIntPref
(
pref
.
name
pref
.
default
)
;
break
;
case
"
boolean
"
:
value
=
Services
.
prefs
.
getBoolPref
(
pref
.
name
pref
.
default
)
;
break
;
}
if
(
pref
.
default
!
=
=
value
)
{
observer
(
Services
.
prefs
"
nsPref
:
changed
"
pref
.
name
)
;
}
}
)
;
}
(
handlers
observer
args
)
=
>
{
if
(
!
once
)
{
Services
.
prefs
.
removeObserver
(
args
[
2
]
observer
)
;
handlers
.
forEach
(
handler
=
>
Services
.
prefs
.
addObserver
(
args
[
2
]
observer
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
observe
(
.
.
.
args
)
)
;
}
)
;
}
getRootDocShell
(
aWin
)
{
if
(
!
aWin
)
{
return
null
;
}
let
docShell
;
try
{
docShell
=
aWin
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
}
catch
(
e
)
{
docShell
=
aWin
.
docShell
;
}
return
docShell
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
}
getChromeWindow
(
aWin
)
{
const
docShell
=
this
.
getRootDocShell
(
aWin
)
;
return
docShell
&
&
docShell
.
domWindow
;
}
getContentFrameMessageManager
(
aWin
)
{
const
docShell
=
this
.
getRootDocShell
(
aWin
)
;
return
docShell
&
&
docShell
.
getInterface
(
Ci
.
nsIBrowserChild
)
.
messageManager
;
}
getDispatcherForWindow
(
aWin
)
{
try
{
if
(
!
this
.
IS_PARENT_PROCESS
)
{
const
mm
=
this
.
getContentFrameMessageManager
(
aWin
.
top
|
|
aWin
)
;
return
mm
&
&
lazy
.
EventDispatcher
.
forMessageManager
(
mm
)
;
}
const
win
=
this
.
getChromeWindow
(
aWin
.
top
|
|
aWin
)
;
if
(
!
win
.
closed
)
{
return
win
.
WindowEventDispatcher
|
|
lazy
.
EventDispatcher
.
for
(
win
)
;
}
}
catch
(
e
)
{
}
return
null
;
}
waitForPanZoomState
(
aWindow
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
!
aWindow
?
.
windowUtils
.
asyncPanZoomEnabled
|
|
!
Services
.
prefs
.
getBoolPref
(
"
apz
.
zoom
-
to
-
focused
-
input
.
enabled
"
)
)
{
resolve
(
)
;
return
;
}
let
timerId
=
0
;
const
panZoomState
=
(
aSubject
aTopic
aData
)
=
>
{
if
(
timerId
!
=
0
)
{
try
{
clearTimeout
(
timerId
)
;
}
catch
(
e
)
{
}
timerId
=
0
;
}
if
(
aData
=
=
=
"
NOTHING
"
)
{
Services
.
obs
.
removeObserver
(
panZoomState
"
PanZoom
:
StateChange
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
panZoomState
"
PanZoom
:
StateChange
"
)
;
timerId
=
setTimeout
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
panZoomState
"
PanZoom
:
StateChange
"
)
;
reject
(
)
;
}
600
)
;
}
)
;
}
initLogging
(
aTag
aScope
)
{
aScope
=
aScope
|
|
{
}
;
const
tag
=
"
GeckoView
.
"
+
aTag
.
replace
(
/
^
GeckoView
\
.
?
/
"
"
)
;
for
(
const
level
of
[
"
DEBUG
"
"
WARN
"
]
)
{
const
log
=
(
strings
.
.
.
exprs
)
=
>
this
.
_log
(
log
.
logger
level
strings
exprs
)
;
XPCOMUtils
.
defineLazyGetter
(
log
"
logger
"
_
=
>
{
const
logger
=
Log
.
repository
.
getLogger
(
tag
)
;
logger
.
parent
=
this
.
rootLogger
;
return
logger
;
}
)
;
aScope
[
level
.
toLowerCase
(
)
]
=
new
Proxy
(
log
{
set
:
(
obj
prop
value
)
=
>
obj
(
[
prop
+
"
=
"
"
"
]
value
)
|
|
true
}
)
;
}
return
aScope
;
}
get
rootLogger
(
)
{
if
(
!
this
.
_rootLogger
)
{
this
.
_rootLogger
=
Log
.
repository
.
getLogger
(
"
GeckoView
"
)
;
this
.
_rootLogger
.
addAppender
(
new
AndroidAppender
(
)
)
;
this
.
_rootLogger
.
manageLevelFromPref
(
"
geckoview
.
logging
"
)
;
}
return
this
.
_rootLogger
;
}
_log
(
aLogger
aLevel
aStrings
aExprs
)
{
if
(
!
Array
.
isArray
(
aStrings
)
)
{
const
[
file
line
]
=
new
Error
(
)
.
stack
.
match
(
/
.
*
\
n
.
*
\
n
.
*
(
.
*
)
:
(
\
d
+
)
:
/
)
;
throw
Error
(
Expecting
template
literal
:
{
aLevel
}
\
foo
\
{
bar
}
\
file
+
line
)
;
}
if
(
aLogger
.
level
>
Log
.
Level
.
Numbers
[
aLevel
]
)
{
return
;
}
const
strs
=
Array
.
from
(
aStrings
)
;
const
regex
=
/
\
n
\
s
*
/
g
;
for
(
let
i
=
0
;
i
<
strs
.
length
;
i
+
+
)
{
strs
[
i
]
=
strs
[
i
]
.
replace
(
regex
"
"
)
;
}
for
(
let
i
=
0
;
i
<
aExprs
.
length
;
i
+
+
)
{
const
expr
=
aExprs
[
i
]
;
switch
(
typeof
expr
)
{
case
"
number
"
:
if
(
expr
>
0
&
&
/
\
ba
?
[
fF
]
lags
?
[
\
s
=
:
]
+
/
.
test
(
strs
[
i
]
)
)
{
aExprs
[
i
]
=
0x
{
expr
.
toString
(
0x10
)
}
;
}
else
if
(
expr
>
=
0
&
&
/
\
b
(
a
?
[
sS
]
tatus
|
rv
)
[
\
s
=
:
]
+
/
.
test
(
strs
[
i
]
)
)
{
aExprs
[
i
]
=
0x
{
expr
.
toString
(
0x10
)
}
;
for
(
const
name
in
Cr
)
{
if
(
expr
=
=
=
Cr
[
name
]
)
{
aExprs
[
i
]
=
name
;
break
;
}
}
}
break
;
}
}
aLogger
[
aLevel
.
toLowerCase
(
)
]
(
strs
.
.
.
aExprs
)
;
}
isSupportedPermissionsPrincipal
(
principal
)
{
if
(
!
principal
)
{
return
false
;
}
if
(
!
(
principal
instanceof
Ci
.
nsIPrincipal
)
)
{
throw
new
Error
(
"
Argument
passed
as
principal
is
not
an
instance
of
Ci
.
nsIPrincipal
"
)
;
}
return
this
.
isSupportedPermissionsScheme
(
principal
.
scheme
)
;
}
isSupportedPermissionsScheme
(
scheme
)
{
return
[
"
http
"
"
https
"
"
moz
-
extension
"
"
file
"
]
.
includes
(
scheme
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
GeckoViewUtils
"
IS_PARENT_PROCESS
"
_
=
>
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
;
