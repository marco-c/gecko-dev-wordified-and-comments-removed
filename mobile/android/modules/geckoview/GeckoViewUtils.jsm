"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewUtils
"
]
;
var
GeckoViewUtils
=
{
addLazyGetter
:
function
(
scope
name
{
service
module
handler
observers
ppmm
mm
ged
init
once
}
)
{
XPCOMUtils
.
defineLazyGetter
(
scope
name
_
=
>
{
let
ret
=
undefined
;
if
(
module
)
{
ret
=
ChromeUtils
.
import
(
module
{
}
)
[
name
]
;
}
else
if
(
service
)
{
ret
=
Cc
[
service
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
else
if
(
typeof
handler
=
=
=
"
function
"
)
{
ret
=
{
handleEvent
:
handler
observe
:
handler
onEvent
:
handler
receiveMessage
:
handler
}
;
}
else
if
(
handler
)
{
ret
=
handler
;
}
if
(
ret
&
&
init
)
{
init
.
call
(
scope
ret
)
;
}
return
ret
;
}
)
;
if
(
observers
)
{
let
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
if
(
!
once
)
{
Services
.
obs
.
addObserver
(
scope
[
name
]
topic
)
;
}
scope
[
name
]
.
observe
(
subject
topic
data
)
;
}
;
observers
.
forEach
(
topic
=
>
Services
.
obs
.
addObserver
(
observer
topic
)
)
;
}
let
addMMListener
=
(
target
names
)
=
>
{
let
listener
=
msg
=
>
{
target
.
removeMessageListener
(
msg
.
name
listener
)
;
if
(
!
once
)
{
target
.
addMessageListener
(
msg
.
name
scope
[
name
]
)
;
}
scope
[
name
]
.
receiveMessage
(
msg
)
;
}
;
names
.
forEach
(
msg
=
>
target
.
addMessageListener
(
msg
listener
)
)
;
}
;
if
(
ppmm
)
{
addMMListener
(
Services
.
ppmm
ppmm
)
;
}
if
(
mm
)
{
addMMListener
(
Services
.
mm
mm
)
;
}
if
(
ged
)
{
let
listener
=
(
event
data
callback
)
=
>
{
EventDispatcher
.
instance
.
unregisterListener
(
listener
event
)
;
if
(
!
once
)
{
EventDispatcher
.
instance
.
registerListener
(
scope
[
name
]
event
)
;
}
scope
[
name
]
.
onEvent
(
event
data
callback
)
;
}
;
EventDispatcher
.
instance
.
registerListener
(
listener
ged
)
;
}
}
_addLazyListeners
:
function
(
events
handler
scope
name
addFn
handleFn
)
{
if
(
!
handler
)
{
handler
=
(
_
=
>
Array
.
isArray
(
name
)
?
name
.
map
(
n
=
>
scope
[
n
]
)
:
scope
[
name
]
)
;
}
let
listener
=
(
.
.
.
args
)
=
>
{
let
handlers
=
handler
(
.
.
.
args
)
;
if
(
!
handlers
)
{
return
;
}
if
(
!
Array
.
isArray
(
handlers
)
)
{
handlers
=
[
handlers
]
;
}
handleFn
(
handlers
listener
args
)
;
}
;
if
(
Array
.
isArray
(
events
)
)
{
addFn
(
events
listener
)
;
}
else
{
addFn
(
[
events
]
listener
)
;
}
}
addLazyEventListener
:
function
(
target
events
{
handler
scope
name
options
}
)
{
this
.
_addLazyListeners
(
events
handler
scope
name
(
events
listener
)
=
>
{
events
.
forEach
(
event
=
>
target
.
addEventListener
(
event
listener
options
)
)
;
}
(
handlers
listener
args
)
=
>
{
if
(
!
options
|
|
!
options
.
once
)
{
target
.
removeEventListener
(
args
[
0
]
.
type
listener
options
)
;
handlers
.
forEach
(
handler
=
>
target
.
addEventListener
(
args
[
0
]
.
type
handler
options
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
handleEvent
(
args
[
0
]
)
)
;
}
)
;
}
registerLazyWindowEventListener
:
function
(
window
events
{
handler
scope
name
once
}
)
{
let
dispatcher
=
this
.
getDispatcherForWindow
(
window
)
;
this
.
_addLazyListeners
(
events
handler
scope
name
(
events
listener
)
=
>
{
dispatcher
.
registerListener
(
listener
events
)
;
}
(
handlers
listener
args
)
=
>
{
if
(
!
once
)
{
dispatcher
.
unregisterListener
(
listener
args
[
0
]
)
;
handlers
.
forEach
(
handler
=
>
dispatcher
.
registerListener
(
handler
args
[
0
]
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
onEvent
(
.
.
.
args
)
)
;
}
)
;
}
_getRootDocShell
:
function
(
aWin
)
{
if
(
!
aWin
)
{
return
null
;
}
let
docShell
;
try
{
docShell
=
aWin
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
}
catch
(
e
)
{
docShell
=
aWin
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
}
return
docShell
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
}
getChromeWindow
:
function
(
aWin
)
{
const
docShell
=
this
.
_getRootDocShell
(
aWin
)
;
return
docShell
&
&
docShell
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
getContentFrameMessageManager
:
function
(
aWin
)
{
const
docShell
=
this
.
_getRootDocShell
(
aWin
)
;
return
docShell
&
&
docShell
.
getInterface
(
Ci
.
nsITabChild
)
.
messageManager
;
}
getDispatcherForWindow
:
function
(
aWin
)
{
try
{
if
(
!
this
.
IS_PARENT_PROCESS
)
{
const
mm
=
this
.
getContentFrameMessageManager
(
aWin
.
top
|
|
aWin
)
;
return
mm
&
&
EventDispatcher
.
forMessageManager
(
mm
)
;
}
const
win
=
this
.
getChromeWindow
(
aWin
.
top
|
|
aWin
)
;
if
(
!
win
.
closed
)
{
return
win
.
WindowEventDispatcher
|
|
EventDispatcher
.
for
(
win
)
;
}
}
catch
(
e
)
{
}
return
null
;
}
getActiveDispatcher
:
function
(
)
{
let
dispatcher
=
this
.
getDispatcherForWindow
(
Services
.
focus
.
activeWindow
)
;
if
(
dispatcher
)
{
return
dispatcher
;
}
let
iter
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
iter
.
hasMoreElements
(
)
)
{
dispatcher
=
this
.
getDispatcherForWindow
(
iter
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
)
;
if
(
dispatcher
)
{
return
dispatcher
;
}
}
return
null
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
GeckoViewUtils
"
IS_PARENT_PROCESS
"
_
=
>
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
;
