"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GeckoViewTab
"
"
GeckoViewTabBridge
"
]
;
const
{
GeckoViewModule
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GeckoViewModule
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
class
Tab
{
constructor
(
id
browser
)
{
this
.
id
=
id
;
this
.
browser
=
browser
;
}
getActive
(
)
{
return
this
.
browser
.
docShellIsActive
;
}
}
class
BrowserAppShim
{
constructor
(
window
)
{
const
tabId
=
GeckoViewTabBridge
.
windowIdToTabId
(
window
.
windowUtils
.
outerWindowID
)
;
this
.
selectedBrowser
=
window
.
browser
;
this
.
selectedTab
=
new
Tab
(
tabId
this
.
selectedBrowser
)
;
this
.
tabs
=
[
this
.
selectedTab
]
;
}
getTabForId
(
aId
)
{
return
this
.
selectedTab
;
}
getTabForBrowser
(
aBrowser
)
{
return
this
.
selectedTab
;
}
getTabForWindow
(
aWindow
)
{
return
this
.
selectedTab
;
}
getTabForDocument
(
aDocument
)
{
return
this
.
selectedTab
;
}
getBrowserForOuterWindowID
(
aID
)
{
return
this
.
selectedBrowser
;
}
getBrowserForDocument
(
aDocument
)
{
return
this
.
selectedBrowser
;
}
get
deck
(
)
{
return
{
addEventListener
(
)
{
}
removeEventListener
(
)
{
}
}
;
}
static
getBrowserApp
(
window
)
{
let
{
BrowserApp
}
=
window
;
if
(
!
BrowserApp
)
{
BrowserApp
=
window
.
gBrowser
=
window
.
BrowserApp
=
new
BrowserAppShim
(
window
)
;
}
return
BrowserApp
;
}
}
const
TAB_ID_BASE
=
10000
;
const
GeckoViewTabBridge
=
{
windowIdToTabId
(
windowId
)
{
return
TAB_ID_BASE
+
windowId
;
}
tabIdToWindowId
(
tabId
)
{
return
tabId
-
TAB_ID_BASE
;
}
async
createNewTab
(
options
=
{
}
)
{
const
url
=
options
.
url
|
|
"
about
:
blank
"
;
if
(
!
options
.
extensionId
)
{
throw
new
Error
(
"
options
.
extensionId
missing
"
)
;
}
const
message
=
{
type
:
"
GeckoView
:
WebExtension
:
NewTab
"
uri
:
url
extensionId
:
options
.
extensionId
}
;
const
sessionId
=
await
EventDispatcher
.
instance
.
sendRequestForResult
(
message
)
;
if
(
!
sessionId
)
{
throw
new
Error
(
"
Cannot
create
new
tab
"
)
;
}
let
window
;
const
browser
=
await
new
Promise
(
resolve
=
>
{
const
handler
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
=
"
geckoview
-
window
-
created
"
&
&
aSubject
.
name
=
=
=
sessionId
)
{
Services
.
obs
.
removeObserver
(
handler
"
geckoview
-
window
-
created
"
)
;
window
=
aSubject
;
resolve
(
window
.
browser
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
handler
"
geckoview
-
window
-
created
"
)
;
}
)
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
options
.
disallowInheritPrincipal
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
browser
.
loadURI
(
url
{
flags
triggeringPrincipal
:
options
.
triggeringPrincipal
}
)
;
return
BrowserAppShim
.
getBrowserApp
(
window
)
.
selectedTab
;
}
async
closeTab
(
{
window
extensionId
}
=
{
}
)
{
if
(
!
extensionId
)
{
throw
new
Error
(
"
extensionId
is
required
"
)
;
}
if
(
!
window
)
{
throw
new
Error
(
"
window
is
required
"
)
;
}
await
window
.
WindowEventDispatcher
.
sendRequestForResult
(
{
type
:
"
GeckoView
:
WebExtension
:
CloseTab
"
extensionId
:
extensionId
}
)
;
}
}
;
class
GeckoViewTab
extends
GeckoViewModule
{
onInit
(
)
{
BrowserAppShim
.
getBrowserApp
(
this
.
window
)
;
}
}
const
{
debug
warn
}
=
GeckoViewTab
.
initLogging
(
"
GeckoViewTab
"
)
;
