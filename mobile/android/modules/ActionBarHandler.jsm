"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ActionBarHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
GeckoViewUtils
:
"
resource
:
/
/
gre
/
modules
/
GeckoViewUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Snackbars
:
"
resource
:
/
/
gre
/
modules
/
Snackbars
.
jsm
"
UITelemetry
:
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ParentalControls
"
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
"
nsIParentalControlsService
"
)
;
var
Strings
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
Strings
"
browser
"
_
=
>
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
)
;
const
PHONE_REGEX
=
/
^
\
+
?
[
0
-
9
\
s
-
.
\
(
\
)
*
#
pw
]
{
1
30
}
/
;
var
ActionBarHandler
=
{
START_TOUCH_ERROR
:
{
NO_CONTENT_WINDOW
:
"
No
valid
content
Window
found
.
"
NONE
:
"
"
}
_nextSelectionID
:
1
_selectionID
:
null
_boundingClientRect
:
null
_actionBarActions
:
null
handleEvent
:
function
(
e
)
{
e
.
stopImmediatePropagation
(
)
;
if
(
e
.
reason
=
=
=
"
presscaret
"
|
|
e
.
reason
=
=
=
"
releasecaret
"
)
{
const
dispatcher
=
this
.
_getDispatcher
(
Services
.
focus
.
focusedWindow
)
;
if
(
dispatcher
)
{
dispatcher
.
sendRequest
(
{
type
:
"
GeckoView
:
PinOnScreen
"
pinned
:
e
.
reason
=
=
=
"
presscaret
"
}
)
;
}
}
if
(
this
.
_selectionID
&
&
!
e
.
caretVisible
)
{
this
.
_uninit
(
false
)
;
return
;
}
if
(
!
this
.
_selectionID
&
&
e
.
collapsed
)
{
switch
(
e
.
reason
)
{
case
"
longpressonemptycontent
"
:
case
"
taponcaret
"
:
this
.
_init
(
e
.
boundingClientRect
)
;
break
;
case
"
updateposition
"
:
break
;
default
:
break
;
}
return
;
}
if
(
!
this
.
_selectionID
&
&
e
.
caretVisuallyVisible
)
{
this
.
_init
(
e
.
boundingClientRect
)
;
return
;
}
if
(
this
.
_selectionID
)
{
if
(
!
this
.
_selectionHasChanged
(
)
)
{
if
(
e
.
reason
=
=
"
presscaret
"
|
|
e
.
reason
=
=
"
scroll
"
)
{
this
.
_updateVisibility
(
)
;
}
else
{
this
.
_boundingClientRect
=
e
.
boundingClientRect
;
let
forceUpdate
=
e
.
reason
=
=
"
updateposition
"
|
|
e
.
reason
=
=
"
releasecaret
"
;
this
.
_sendActionBarActions
(
forceUpdate
)
;
}
}
else
{
this
.
_uninit
(
false
)
;
this
.
_init
(
e
.
boundingClientRect
)
;
}
}
}
onEvent
:
function
(
event
data
callback
)
{
switch
(
event
)
{
case
"
TextSelection
:
Action
"
:
{
if
(
!
this
.
_selectionID
)
{
break
;
}
for
(
let
type
in
this
.
actions
)
{
let
action
=
this
.
actions
[
type
]
;
if
(
action
.
id
=
=
data
.
id
)
{
action
.
action
(
this
.
_targetElement
this
.
_contentWindow
)
;
break
;
}
}
break
;
}
case
"
TextSelection
:
Get
"
:
{
try
{
callback
.
onSuccess
(
this
.
_getSelectedText
(
)
)
;
}
catch
(
e
)
{
callback
.
onError
(
e
.
toString
(
)
)
;
}
this
.
_uninit
(
)
;
break
;
}
case
"
TextSelection
:
End
"
:
{
if
(
this
.
_selectionID
=
=
data
.
selectionID
)
{
this
.
_uninit
(
)
;
}
break
;
}
}
}
_getDispatcher
:
function
(
win
)
{
try
{
return
GeckoViewUtils
.
getDispatcherForWindow
(
win
)
;
}
catch
(
e
)
{
return
null
;
}
}
_init
:
function
(
boundingClientRect
)
{
let
[
element
win
]
=
this
.
_getSelectionTargets
(
)
;
let
dispatcher
=
this
.
_getDispatcher
(
win
)
;
if
(
!
win
|
|
!
dispatcher
)
{
return
this
.
START_TOUCH_ERROR
.
NO_CONTENT_WINDOW
;
}
this
.
_selectionID
=
this
.
_nextSelectionID
+
+
;
[
this
.
_targetElement
this
.
_contentWindow
]
=
[
element
win
]
;
this
.
_boundingClientRect
=
boundingClientRect
;
dispatcher
.
sendRequest
(
{
type
:
"
TextSelection
:
ActionbarInit
"
selectionID
:
this
.
_selectionID
}
)
;
this
.
_sendActionBarActions
(
true
)
;
return
this
.
START_TOUCH_ERROR
.
NONE
;
}
_updateVisibility
:
function
(
)
{
let
win
=
this
.
_contentWindow
;
let
dispatcher
=
this
.
_getDispatcher
(
win
)
;
if
(
!
dispatcher
)
{
return
;
}
dispatcher
.
sendRequest
(
{
type
:
"
TextSelection
:
Visibility
"
selectionID
:
this
.
_selectionID
}
)
;
}
_getSelectionTargets
:
function
(
)
{
let
[
element
win
]
=
[
Services
.
focus
.
focusedElement
Services
.
focus
.
focusedWindow
]
;
if
(
!
element
)
{
return
[
null
win
]
;
}
if
(
(
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
)
&
&
element
.
mozIsTextField
(
false
)
)
|
|
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLTextAreaElement
"
)
|
|
element
.
isContentEditable
)
{
return
[
element
win
]
;
}
return
[
null
win
]
;
}
_selectionHasChanged
:
function
(
)
{
let
[
element
win
]
=
this
.
_getSelectionTargets
(
)
;
return
(
this
.
_targetElement
!
=
=
element
|
|
this
.
_contentWindow
!
=
=
win
|
|
this
.
_isInDesignMode
(
this
.
_contentWindow
)
!
=
=
this
.
_isInDesignMode
(
win
)
)
;
}
_uninit
:
function
(
clearSelection
=
true
)
{
if
(
!
this
.
_selectionID
)
{
return
;
}
let
win
=
this
.
_contentWindow
;
let
dispatcher
=
this
.
_getDispatcher
(
win
)
;
if
(
dispatcher
)
{
dispatcher
.
sendRequest
(
{
type
:
"
TextSelection
:
ActionbarUninit
"
}
)
;
}
this
.
_selectionID
=
null
;
this
.
_boundingClientRect
=
null
;
if
(
clearSelection
)
{
this
.
_clearSelection
(
)
;
}
}
_clearSelection
:
function
(
element
=
this
.
_targetElement
win
=
this
.
_contentWindow
)
{
if
(
element
)
{
let
editor
=
this
.
_getEditor
(
element
win
)
;
if
(
editor
.
composing
)
{
editor
.
forceCompositionEnd
(
)
;
}
element
.
blur
(
)
;
}
if
(
!
element
|
|
element
.
isContentEditable
)
{
this
.
_getSelection
(
)
.
removeAllRanges
(
)
;
}
}
_sendActionBarActions
:
function
(
sendAlways
)
{
let
actions
=
this
.
_getActionBarActions
(
)
;
let
actionCountUnchanged
=
this
.
_actionBarActions
&
&
actions
.
length
=
=
=
this
.
_actionBarActions
.
length
;
let
actionsMatch
=
actionCountUnchanged
&
&
this
.
_actionBarActions
.
every
(
(
e
i
)
=
>
{
return
e
.
id
=
=
=
actions
[
i
]
.
id
;
}
)
;
let
win
=
this
.
_contentWindow
;
let
dispatcher
=
this
.
_getDispatcher
(
win
)
;
if
(
!
dispatcher
)
{
return
;
}
if
(
sendAlways
|
|
!
actionsMatch
)
{
dispatcher
.
sendRequest
(
{
type
:
"
TextSelection
:
ActionbarStatus
"
selectionID
:
this
.
_selectionID
actions
:
actions
x
:
this
.
_boundingClientRect
.
x
y
:
this
.
_boundingClientRect
.
y
width
:
this
.
_boundingClientRect
.
width
height
:
this
.
_boundingClientRect
.
height
}
)
;
}
this
.
_actionBarActions
=
actions
;
}
_getActionBarActions
:
function
(
element
=
this
.
_targetElement
win
=
this
.
_contentWindow
)
{
let
actions
=
[
]
;
for
(
let
type
in
this
.
actions
)
{
let
action
=
this
.
actions
[
type
]
;
if
(
action
.
selector
.
matches
(
element
win
)
)
{
let
a
=
{
id
:
action
.
id
label
:
this
.
_getActionValue
(
action
"
label
"
"
"
element
)
icon
:
this
.
_getActionValue
(
action
"
icon
"
"
drawable
:
/
/
ic_status_logo
"
element
)
order
:
this
.
_getActionValue
(
action
"
order
"
0
element
)
floatingOrder
:
this
.
_getActionValue
(
action
"
floatingOrder
"
9
element
)
showAsAction
:
this
.
_getActionValue
(
action
"
showAsAction
"
true
element
)
}
;
actions
.
push
(
a
)
;
}
}
actions
.
sort
(
(
a
b
)
=
>
b
.
order
-
a
.
order
)
;
return
actions
;
}
_getActionValue
:
function
(
obj
name
defaultValue
element
)
{
if
(
!
(
name
in
obj
)
)
return
defaultValue
;
if
(
typeof
obj
[
name
]
=
=
"
function
"
)
return
obj
[
name
]
(
element
)
;
return
obj
[
name
]
;
}
actions
:
{
SELECT_ALL
:
{
id
:
"
selectall_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
selectAll
"
)
icon
:
"
drawable
:
/
/
ab_select_all
"
order
:
5
floatingOrder
:
5
selector
:
{
matches
:
function
(
element
win
)
{
return
(
element
)
?
element
.
textLength
!
=
0
:
true
;
}
}
action
:
function
(
element
win
)
{
if
(
element
)
{
let
editor
=
ActionBarHandler
.
_getEditor
(
element
win
)
;
if
(
editor
.
composing
)
{
element
.
blur
(
)
;
element
.
focus
(
)
;
}
}
ActionBarHandler
.
_getSelectAllController
(
element
win
)
.
selectAll
(
)
;
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
select_all
"
)
;
}
}
CUT
:
{
id
:
"
cut_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
cut
"
)
icon
:
"
drawable
:
/
/
ab_cut
"
order
:
4
floatingOrder
:
1
selector
:
{
matches
:
function
(
element
win
)
{
if
(
!
element
&
&
!
ActionBarHandler
.
_isInDesignMode
(
win
)
)
{
return
false
;
}
if
(
element
&
&
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
&
&
!
element
.
mozIsTextField
(
true
)
)
{
return
false
;
}
if
(
element
&
&
(
element
.
disabled
|
|
element
.
readOnly
)
)
{
return
false
;
}
return
(
ActionBarHandler
.
_getSelectedText
(
)
.
length
>
0
)
;
}
}
action
:
function
(
element
win
)
{
let
selectedText
=
ActionBarHandler
.
_getSelectedText
(
)
;
let
clipboard
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
clipboard
.
copyString
(
selectedText
)
;
let
msg
=
Strings
.
browser
.
GetStringFromName
(
"
selectionHelper
.
textCopied
"
)
;
Snackbars
.
show
(
msg
Snackbars
.
LENGTH_LONG
)
;
ActionBarHandler
.
_getSelection
(
element
win
)
.
deleteFromDocument
(
)
;
ActionBarHandler
.
_uninit
(
)
;
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
cut
"
)
;
}
}
COPY
:
{
id
:
"
copy_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
copy
"
)
icon
:
"
drawable
:
/
/
ab_copy
"
order
:
3
floatingOrder
:
2
selector
:
{
matches
:
function
(
element
win
)
{
if
(
element
&
&
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
&
&
!
element
.
mozIsTextField
(
true
)
)
{
return
false
;
}
return
(
ActionBarHandler
.
_getSelectedText
(
)
.
length
>
0
)
;
}
}
action
:
function
(
element
win
)
{
let
selectedText
=
ActionBarHandler
.
_getSelectedText
(
)
;
let
clipboard
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
;
clipboard
.
copyString
(
selectedText
)
;
let
msg
=
Strings
.
browser
.
GetStringFromName
(
"
selectionHelper
.
textCopied
"
)
;
Snackbars
.
show
(
msg
Snackbars
.
LENGTH_LONG
)
;
ActionBarHandler
.
_uninit
(
)
;
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
copy
"
)
;
}
}
PASTE
:
{
id
:
"
paste_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
paste
"
)
icon
:
"
drawable
:
/
/
ab_paste
"
order
:
2
floatingOrder
:
3
selector
:
{
matches
:
function
(
element
win
)
{
if
(
!
element
&
&
!
ActionBarHandler
.
_isInDesignMode
(
win
)
)
{
return
false
;
}
if
(
element
&
&
(
element
.
disabled
|
|
element
.
readOnly
)
)
{
return
false
;
}
let
flavors
=
[
"
text
/
unicode
"
]
;
return
Services
.
clipboard
.
hasDataMatchingFlavors
(
flavors
flavors
.
length
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
}
}
action
:
function
(
element
win
)
{
ActionBarHandler
.
_getEditor
(
element
win
)
.
paste
(
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
ActionBarHandler
.
_uninit
(
)
;
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
paste
"
)
;
}
}
CALL
:
{
id
:
"
call_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
call
"
)
icon
:
"
drawable
:
/
/
phone
"
order
:
1
floatingOrder
:
0
selector
:
{
matches
:
function
(
element
win
)
{
return
(
ActionBarHandler
.
_getSelectedPhoneNumber
(
)
!
=
null
)
;
}
}
action
:
function
(
element
win
)
{
let
uri
=
"
tel
:
"
+
ActionBarHandler
.
_getSelectedPhoneNumber
(
)
;
let
chrome
=
GeckoViewUtils
.
getChromeWindow
(
win
)
;
if
(
chrome
.
BrowserApp
&
&
chrome
.
BrowserApp
.
loadURI
)
{
chrome
.
BrowserApp
.
loadURI
(
uri
)
;
}
else
{
let
bwin
=
chrome
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
.
browserDOMWindow
;
if
(
bwin
)
{
bwin
.
openURI
(
Services
.
io
.
newURI
(
uri
)
win
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEW
win
.
document
.
nodePrincipal
)
;
}
}
ActionBarHandler
.
_uninit
(
)
;
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
call
"
)
;
}
}
SEARCH
:
{
id
:
"
search_action
"
label
:
(
)
=
>
Strings
.
browser
.
formatStringFromName
(
"
contextmenu
.
search
"
[
Services
.
search
.
defaultEngine
.
name
]
1
)
icon
:
"
drawable
:
/
/
ab_search
"
order
:
1
floatingOrder
:
6
selector
:
{
matches
:
function
(
element
win
)
{
return
(
ActionBarHandler
.
_getSelectedText
(
)
.
length
>
0
)
;
}
}
action
:
function
(
element
win
)
{
let
selectedText
=
BrowserUtils
.
trimSelection
(
ActionBarHandler
.
_getSelectedText
(
)
)
;
ActionBarHandler
.
_uninit
(
)
;
let
searchSubmission
=
Services
.
search
.
defaultEngine
.
getSubmission
(
selectedText
)
;
let
chrome
=
GeckoViewUtils
.
getChromeWindow
(
win
)
;
if
(
chrome
.
BrowserApp
&
&
chrome
.
BrowserApp
.
selectedTab
&
&
chrome
.
BrowserApp
.
addTab
)
{
let
parent
=
chrome
.
BrowserApp
.
selectedTab
;
let
isPrivate
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
parent
.
browser
)
;
chrome
.
BrowserApp
.
addTab
(
searchSubmission
.
uri
.
spec
{
parentId
:
parent
.
id
selected
:
true
isPrivate
:
isPrivate
}
)
;
}
else
{
let
bwin
=
chrome
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
.
browserDOMWindow
;
if
(
bwin
)
{
bwin
.
openURI
(
searchSubmission
.
uri
win
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEW
win
.
document
.
nodePrincipal
)
;
}
}
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
search
"
)
;
}
}
SEARCH_ADD
:
{
id
:
"
search_add_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
addSearchEngine3
"
)
icon
:
"
drawable
:
/
/
ab_add_search_engine
"
order
:
0
floatingOrder
:
8
selector
:
{
matches
:
function
(
element
win
)
{
let
chrome
=
GeckoViewUtils
.
getChromeWindow
(
win
)
;
if
(
!
chrome
.
SearchEngines
)
{
return
false
;
}
if
(
!
element
|
|
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLInputElement
"
)
{
return
false
;
}
let
form
=
element
.
form
;
if
(
!
form
|
|
element
.
type
=
=
"
password
"
)
{
return
false
;
}
let
method
=
form
.
method
.
toUpperCase
(
)
;
let
canAddEngine
=
(
method
=
=
"
GET
"
)
|
|
(
method
=
=
"
POST
"
&
&
(
form
.
enctype
!
=
"
text
/
plain
"
&
&
form
.
enctype
!
=
"
multipart
/
form
-
data
"
)
)
;
if
(
!
canAddEngine
)
{
return
false
;
}
if
(
chrome
.
SearchEngines
.
visibleEngineExists
(
element
)
)
{
return
false
;
}
return
true
;
}
}
action
:
function
(
element
win
)
{
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
add_search_engine
"
)
;
let
chrome
=
GeckoViewUtils
.
getChromeWindow
(
win
)
;
chrome
.
SearchEngines
.
addEngine
(
element
(
result
)
=
>
{
if
(
result
)
{
ActionBarHandler
.
_sendActionBarActions
(
true
)
;
}
}
)
;
}
}
SHARE
:
{
id
:
"
share_action
"
label
:
(
)
=
>
Strings
.
browser
.
GetStringFromName
(
"
contextmenu
.
share
"
)
icon
:
"
drawable
:
/
/
ic_menu_share
"
order
:
0
floatingOrder
:
4
selector
:
{
matches
:
function
(
element
win
)
{
if
(
!
ParentalControls
.
isAllowed
(
ParentalControls
.
SHARE
)
)
{
return
false
;
}
return
(
ActionBarHandler
.
_getSelectedText
(
)
.
length
>
0
)
;
}
}
action
:
function
(
element
win
)
{
let
title
=
win
.
document
.
title
;
if
(
title
&
&
title
.
length
>
200
)
{
let
ellipsis
=
"
\
u2026
"
;
try
{
ellipsis
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
e
)
{
}
title
=
title
.
slice
(
0
200
)
+
ellipsis
;
}
else
if
(
!
title
)
{
title
=
win
.
location
.
href
;
}
EventDispatcher
.
instance
.
sendRequest
(
{
type
:
"
Share
:
Text
"
text
:
ActionBarHandler
.
_getSelectedText
(
)
title
:
title
}
)
;
ActionBarHandler
.
_uninit
(
)
;
UITelemetry
.
addEvent
(
"
action
.
1
"
"
actionbar
"
null
"
share
"
)
;
}
}
}
get
_idService
(
)
{
delete
this
.
_idService
;
return
this
.
_idService
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
}
get
_targetElement
(
)
{
if
(
this
.
_targetElementRef
)
return
this
.
_targetElementRef
.
get
(
)
;
return
null
;
}
set
_targetElement
(
element
)
{
this
.
_targetElementRef
=
Cu
.
getWeakReference
(
element
)
;
}
get
_contentWindow
(
)
{
if
(
this
.
_contentWindowRef
)
return
this
.
_contentWindowRef
.
get
(
)
;
return
null
;
}
set
_contentWindow
(
aContentWindow
)
{
this
.
_contentWindowRef
=
Cu
.
getWeakReference
(
aContentWindow
)
;
}
_isInDesignMode
:
function
(
win
)
{
return
this
.
_selectionID
&
&
(
win
.
document
.
designMode
=
=
=
"
on
"
)
;
}
_getSelectedText
:
function
(
)
{
if
(
!
this
.
_selectionID
)
{
return
"
"
;
}
let
selection
=
this
.
_getSelection
(
)
;
if
(
this
.
_targetElement
&
&
ChromeUtils
.
getClassName
(
this
.
_targetElement
)
=
=
=
"
HTMLTextAreaElement
"
)
{
let
flags
=
Ci
.
nsIDocumentEncoder
.
OutputPreformatted
|
Ci
.
nsIDocumentEncoder
.
OutputRaw
;
return
selection
.
toStringWithFormat
(
"
text
/
plain
"
flags
0
)
;
}
return
selection
.
toString
(
)
;
}
_isElementEditable
:
function
(
element
)
{
if
(
!
element
)
{
return
false
;
}
let
elementClass
=
ChromeUtils
.
getClassName
(
element
)
;
return
elementClass
=
=
=
"
HTMLInputElement
"
|
|
elementClass
=
=
=
"
HTMLTextAreaElement
"
;
}
_getSelection
:
function
(
element
=
this
.
_targetElement
win
=
this
.
_contentWindow
)
{
return
this
.
_isElementEditable
(
element
)
?
this
.
_getEditor
(
element
)
.
selection
:
win
.
getSelection
(
)
;
}
_getEditor
:
function
(
element
=
this
.
_targetElement
win
=
this
.
_contentWindow
)
{
if
(
this
.
_isElementEditable
(
element
)
)
{
return
element
.
editor
;
}
return
win
.
docShell
.
editingSession
.
getEditorForWindow
(
win
)
;
}
_getSelectionController
:
function
(
element
=
this
.
_targetElement
win
=
this
.
_contentWindow
)
{
if
(
this
.
_isElementEditable
(
element
)
)
{
return
this
.
_getEditor
(
element
win
)
.
selectionController
;
}
return
win
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsISelectionDisplay
)
.
QueryInterface
(
Ci
.
nsISelectionController
)
;
}
_getSelectAllController
:
function
(
element
=
this
.
_targetElement
win
=
this
.
_contentWindow
)
{
let
editor
=
this
.
_getEditor
(
element
win
)
;
return
(
editor
)
?
editor
:
this
.
_getSelectionController
(
element
win
)
;
}
_getSelectedPhoneNumber
:
function
(
)
{
let
selectedText
=
this
.
_getSelectedText
(
)
.
trim
(
)
;
return
this
.
_isPhoneNumber
(
selectedText
)
?
selectedText
:
null
;
}
_isPhoneNumber
:
function
(
selectedText
)
{
return
(
PHONE_REGEX
.
test
(
selectedText
)
)
;
}
}
;
