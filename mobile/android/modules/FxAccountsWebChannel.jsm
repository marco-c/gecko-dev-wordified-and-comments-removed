"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
EnsureFxAccountsWebChannel
"
]
;
const
{
Accounts
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Accounts
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
WebChannel
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
log
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AndroidLog
.
jsm
"
{
}
)
.
AndroidLog
.
bind
(
"
FxAccounts
"
)
;
const
WEBCHANNEL_ID
=
"
account_updates
"
;
const
COMMAND_LOADED
=
"
fxaccounts
:
loaded
"
;
const
COMMAND_CAN_LINK_ACCOUNT
=
"
fxaccounts
:
can_link_account
"
;
const
COMMAND_LOGIN
=
"
fxaccounts
:
login
"
;
const
COMMAND_CHANGE_PASSWORD
=
"
fxaccounts
:
change_password
"
;
const
COMMAND_DELETE_ACCOUNT
=
"
fxaccounts
:
delete_account
"
;
const
COMMAND_PROFILE_CHANGE
=
"
profile
:
change
"
;
const
COMMAND_SYNC_PREFERENCES
=
"
fxaccounts
:
sync_preferences
"
;
const
PREF_LAST_FXA_USER
=
"
identity
.
fxaccounts
.
lastSignedInUserHash
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
strings
"
(
)
=
>
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
aboutAccounts
.
properties
"
)
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Snackbars
"
"
resource
:
/
/
gre
/
modules
/
Snackbars
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Prompt
"
"
resource
:
/
/
gre
/
modules
/
Prompt
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UITelemetry
"
"
resource
:
/
/
gre
/
modules
/
UITelemetry
.
jsm
"
)
;
this
.
FxAccountsWebChannelHelpers
=
function
(
)
{
}
;
this
.
FxAccountsWebChannelHelpers
.
prototype
=
{
getPreviousAccountNameHashPref
(
)
{
try
{
return
Services
.
prefs
.
getStringPref
(
PREF_LAST_FXA_USER
)
;
}
catch
(
_
)
{
return
"
"
;
}
}
setPreviousAccountNameHashPref
(
acctName
)
{
Services
.
prefs
.
setStringPref
(
PREF_LAST_FXA_USER
this
.
sha256
(
acctName
)
)
;
}
sha256
(
str
)
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
data
=
converter
.
convertToByteArray
(
str
{
}
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
length
)
;
return
hasher
.
finish
(
true
)
;
}
}
;
this
.
FxAccountsWebChannel
=
function
(
options
)
{
if
(
!
options
)
{
throw
new
Error
(
"
Missing
configuration
options
"
)
;
}
if
(
!
options
.
content_uri
)
{
throw
new
Error
(
"
Missing
'
content_uri
'
option
"
)
;
}
this
.
_contentUri
=
options
.
content_uri
;
if
(
!
options
.
channel_id
)
{
throw
new
Error
(
"
Missing
'
channel_id
'
option
"
)
;
}
this
.
_webChannelId
=
options
.
channel_id
;
this
.
_helpers
=
options
.
helpers
|
|
new
FxAccountsWebChannelHelpers
(
options
)
;
this
.
_setupChannel
(
)
;
}
;
this
.
FxAccountsWebChannel
.
prototype
=
{
_channel
:
null
_webChannelId
:
null
_webChannelOrigin
:
null
tearDown
(
)
{
this
.
_channel
.
stopListening
(
)
;
this
.
_channel
=
null
;
this
.
_channelCallback
=
null
;
}
_setupChannel
(
)
{
try
{
this
.
_webChannelOrigin
=
Services
.
io
.
newURI
(
this
.
_contentUri
)
;
this
.
_registerChannel
(
)
;
}
catch
(
e
)
{
log
.
e
(
e
.
toString
(
)
)
;
throw
e
;
}
}
_registerChannel
(
)
{
let
listener
=
(
webChannelId
message
sendingContext
)
=
>
{
if
(
message
)
{
let
command
=
message
.
command
;
let
data
=
message
.
data
;
log
.
d
(
"
FxAccountsWebChannel
message
received
command
:
"
+
command
)
;
let
respond
=
(
data
)
=
>
{
let
response
=
{
command
:
command
messageId
:
message
.
messageId
data
:
data
}
;
log
.
d
(
"
Sending
response
to
command
:
"
+
command
)
;
this
.
_channel
.
send
(
response
sendingContext
)
;
}
;
switch
(
command
)
{
case
COMMAND_LOADED
:
let
mm
=
sendingContext
.
browser
.
docShell
.
messageManager
;
mm
.
sendAsyncMessage
(
COMMAND_LOADED
)
;
break
;
case
COMMAND_CAN_LINK_ACCOUNT
:
Accounts
.
getFirefoxAccount
(
)
.
then
(
account
=
>
{
if
(
account
)
{
if
(
account
.
email
=
=
data
.
email
)
{
log
.
d
(
"
Relinking
existing
Android
Account
:
email
addresses
agree
.
"
)
;
respond
(
{
ok
:
true
}
)
;
}
else
{
log
.
w
(
"
Not
relinking
existing
Android
Account
:
email
addresses
disagree
!
"
)
;
let
message
=
strings
.
GetStringFromName
(
"
relinkDenied
.
message
"
)
;
let
buttonLabel
=
strings
.
GetStringFromName
(
"
relinkDenied
.
openPrefs
"
)
;
Snackbars
.
show
(
message
Snackbars
.
LENGTH_LONG
{
action
:
{
label
:
buttonLabel
callback
:
(
)
=
>
{
Accounts
.
launchSetup
(
)
;
}
}
}
)
;
respond
(
{
ok
:
false
}
)
;
}
}
else
{
let
prevAcctHash
=
this
.
_helpers
.
getPreviousAccountNameHashPref
(
)
;
let
shouldShowWarning
=
prevAcctHash
&
&
(
prevAcctHash
!
=
this
.
_helpers
.
sha256
(
data
.
email
)
)
;
if
(
shouldShowWarning
)
{
log
.
w
(
"
Warning
about
creating
a
new
Android
Account
:
previously
linked
to
different
email
address
!
"
)
;
let
message
=
strings
.
formatStringFromName
(
"
relinkVerify
.
message
"
[
data
.
email
]
1
)
;
new
Prompt
(
{
window
:
sendingContext
.
browser
&
&
sendingContext
.
browser
.
ownerGlobal
title
:
strings
.
GetStringFromName
(
"
relinkVerify
.
title
"
)
message
:
message
buttons
:
[
strings
.
GetStringFromName
(
"
relinkVerify
.
cancel
"
)
strings
.
GetStringFromName
(
"
relinkVerify
.
continue
"
)
]
}
)
.
show
(
result
=
>
respond
(
{
ok
:
result
&
&
result
.
button
=
=
1
}
)
)
;
}
else
{
log
.
d
(
"
Not
warning
about
creating
a
new
Android
Account
:
no
previously
linked
email
address
.
"
)
;
respond
(
{
ok
:
true
}
)
;
}
}
}
)
.
catch
(
e
=
>
{
log
.
e
(
e
.
toString
(
)
)
;
respond
(
{
ok
:
false
}
)
;
}
)
;
break
;
case
COMMAND_LOGIN
:
Accounts
.
getFirefoxAccount
(
)
.
then
(
account
=
>
{
if
(
!
account
)
{
return
Accounts
.
createFirefoxAccountFromJSON
(
data
)
.
then
(
success
=
>
{
if
(
!
success
)
{
throw
new
Error
(
"
Could
not
create
Firefox
Account
!
"
)
;
}
UITelemetry
.
addEvent
(
"
action
.
1
"
"
content
"
null
"
fxaccount
-
create
"
)
;
return
success
;
}
)
;
}
return
Accounts
.
updateFirefoxAccountFromJSON
(
data
)
.
then
(
success
=
>
{
if
(
!
success
)
{
throw
new
Error
(
"
Could
not
update
Firefox
Account
!
"
)
;
}
UITelemetry
.
addEvent
(
"
action
.
1
"
"
content
"
null
"
fxaccount
-
login
"
)
;
return
success
;
}
)
;
}
)
.
then
(
success
=
>
{
if
(
!
success
)
{
throw
new
Error
(
"
Could
not
create
or
update
Firefox
Account
!
"
)
;
}
this
.
_helpers
.
setPreviousAccountNameHashPref
(
data
.
email
)
;
log
.
i
(
"
Created
or
updated
Firefox
Account
.
"
)
;
}
)
.
catch
(
e
=
>
{
log
.
e
(
e
.
toString
(
)
)
;
}
)
;
break
;
case
COMMAND_CHANGE_PASSWORD
:
Accounts
.
getFirefoxAccount
(
)
.
then
(
account
=
>
{
if
(
!
account
)
{
throw
new
Error
(
"
Can
'
t
change
password
of
non
-
existent
Firefox
Account
!
"
)
;
}
return
Accounts
.
updateFirefoxAccountFromJSON
(
data
)
;
}
)
.
then
(
success
=
>
{
if
(
!
success
)
{
throw
new
Error
(
"
Could
not
change
Firefox
Account
password
!
"
)
;
}
UITelemetry
.
addEvent
(
"
action
.
1
"
"
content
"
null
"
fxaccount
-
changepassword
"
)
;
log
.
i
(
"
Changed
Firefox
Account
password
.
"
)
;
}
)
.
catch
(
e
=
>
{
log
.
e
(
e
.
toString
(
)
)
;
}
)
;
break
;
case
COMMAND_DELETE_ACCOUNT
:
Accounts
.
getFirefoxAccount
(
)
.
then
(
account
=
>
{
if
(
!
account
)
{
throw
new
Error
(
"
Can
'
t
delete
non
-
existent
Firefox
Account
!
"
)
;
}
return
Accounts
.
deleteFirefoxAccount
(
)
.
then
(
success
=
>
{
if
(
!
success
)
{
throw
new
Error
(
"
Could
not
delete
Firefox
Account
!
"
)
;
}
UITelemetry
.
addEvent
(
"
action
.
1
"
"
content
"
null
"
fxaccount
-
delete
"
)
;
log
.
i
(
"
Firefox
Account
deleted
.
"
)
;
}
)
;
}
)
.
catch
(
e
=
>
{
log
.
e
(
e
.
toString
(
)
)
;
}
)
;
break
;
case
COMMAND_PROFILE_CHANGE
:
Accounts
.
getFirefoxAccount
(
)
.
then
(
account
=
>
{
if
(
!
account
)
{
throw
new
Error
(
"
Can
'
t
change
profile
of
non
-
existent
Firefox
Account
!
"
)
;
}
UITelemetry
.
addEvent
(
"
action
.
1
"
"
content
"
null
"
fxaccount
-
changeprofile
"
)
;
return
Accounts
.
notifyFirefoxAccountProfileChanged
(
)
;
}
)
.
catch
(
e
=
>
{
log
.
e
(
e
.
toString
(
)
)
;
}
)
;
break
;
case
COMMAND_SYNC_PREFERENCES
:
UITelemetry
.
addEvent
(
"
action
.
1
"
"
content
"
null
"
fxaccount
-
syncprefs
"
)
;
Accounts
.
showSyncPreferences
(
)
.
catch
(
e
=
>
{
log
.
e
(
e
.
toString
(
)
)
;
}
)
;
break
;
default
:
log
.
w
(
"
Ignoring
unrecognized
FxAccountsWebChannel
command
:
"
+
JSON
.
stringify
(
command
)
)
;
break
;
}
}
}
;
this
.
_channelCallback
=
listener
;
this
.
_channel
=
new
WebChannel
(
this
.
_webChannelId
this
.
_webChannelOrigin
)
;
this
.
_channel
.
listen
(
listener
)
;
log
.
d
(
"
FxAccountsWebChannel
registered
:
"
+
this
.
_webChannelId
+
"
with
origin
"
+
this
.
_webChannelOrigin
.
prePath
)
;
}
}
;
var
singleton
;
var
EnsureFxAccountsWebChannel
=
(
)
=
>
{
if
(
!
singleton
)
{
let
contentUri
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
webchannel
.
uri
"
)
;
singleton
=
new
this
.
FxAccountsWebChannel
(
{
content_uri
:
contentUri
channel_id
:
WEBCHANNEL_ID
}
)
;
}
}
;
