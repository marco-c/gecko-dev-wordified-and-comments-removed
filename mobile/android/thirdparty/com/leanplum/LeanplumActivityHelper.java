package
com
.
leanplum
;
import
android
.
app
.
Activity
;
import
android
.
app
.
Application
;
import
android
.
app
.
Application
.
ActivityLifecycleCallbacks
;
import
android
.
content
.
res
.
Resources
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
com
.
leanplum
.
annotations
.
Parser
;
import
com
.
leanplum
.
callbacks
.
PostponableAction
;
import
com
.
leanplum
.
internal
.
ActionManager
;
import
com
.
leanplum
.
internal
.
LeanplumInternal
;
import
com
.
leanplum
.
internal
.
LeanplumUIEditorWrapper
;
import
com
.
leanplum
.
internal
.
OsHandler
;
import
com
.
leanplum
.
internal
.
Util
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
Queue
;
import
java
.
util
.
Set
;
public
class
LeanplumActivityHelper
{
static
boolean
isActivityPaused
;
private
static
Set
<
Class
>
ignoredActivityClasses
;
private
static
boolean
registeredCallbacks
;
static
Activity
currentActivity
;
private
final
Activity
activity
;
private
LeanplumResources
res
;
private
LeanplumInflater
inflater
;
private
static
final
Queue
<
Runnable
>
pendingActions
=
new
LinkedList
<
>
(
)
;
private
static
final
Runnable
runPendingActionsRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
runPendingActions
(
)
;
}
}
;
public
LeanplumActivityHelper
(
Activity
activity
)
{
this
.
activity
=
activity
;
Leanplum
.
setApplicationContext
(
activity
.
getApplicationContext
(
)
)
;
Parser
.
parseVariables
(
activity
)
;
}
public
static
Activity
getCurrentActivity
(
)
{
return
currentActivity
;
}
public
static
boolean
isActivityPaused
(
)
{
return
isActivityPaused
;
}
public
static
void
enableLifecycleCallbacks
(
final
Application
app
)
{
Leanplum
.
setApplicationContext
(
app
.
getApplicationContext
(
)
)
;
if
(
Build
.
VERSION
.
SDK_INT
<
14
)
{
return
;
}
app
.
registerActivityLifecycleCallbacks
(
new
ActivityLifecycleCallbacks
(
)
{
Override
public
void
onActivityStopped
(
Activity
activity
)
{
try
{
onStop
(
activity
)
;
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
Override
public
void
onActivityResumed
(
final
Activity
activity
)
{
try
{
if
(
Leanplum
.
isInterfaceEditingEnabled
(
)
)
{
OsHandler
.
getInstance
(
)
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
LeanplumUIEditorWrapper
.
getInstance
(
)
.
applyInterfaceEdits
(
activity
)
;
}
}
)
;
}
onResume
(
activity
)
;
if
(
Leanplum
.
isScreenTrackingEnabled
(
)
)
{
Leanplum
.
advanceTo
(
activity
.
getLocalClassName
(
)
)
;
}
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
Override
public
void
onActivityPaused
(
Activity
activity
)
{
try
{
onPause
(
activity
)
;
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
Override
public
void
onActivityStarted
(
Activity
activity
)
{
}
Override
public
void
onActivitySaveInstanceState
(
Activity
activity
Bundle
outState
)
{
}
Override
public
void
onActivityDestroyed
(
Activity
activity
)
{
}
Override
public
void
onActivityCreated
(
Activity
activity
Bundle
savedInstanceState
)
{
}
}
)
;
registeredCallbacks
=
true
;
}
public
LeanplumResources
getLeanplumResources
(
)
{
return
getLeanplumResources
(
null
)
;
}
public
LeanplumResources
getLeanplumResources
(
Resources
baseResources
)
{
if
(
res
!
=
null
)
{
return
res
;
}
if
(
baseResources
=
=
null
)
{
baseResources
=
activity
.
getResources
(
)
;
}
if
(
baseResources
instanceof
LeanplumResources
)
{
return
(
LeanplumResources
)
baseResources
;
}
res
=
new
LeanplumResources
(
baseResources
)
;
return
res
;
}
public
void
setContentView
(
final
int
layoutResID
)
{
if
(
inflater
=
=
null
)
{
inflater
=
LeanplumInflater
.
from
(
activity
)
;
}
activity
.
setContentView
(
inflater
.
inflate
(
layoutResID
)
)
;
}
SuppressWarnings
(
"
unused
"
)
private
static
void
onPause
(
Activity
activity
)
{
isActivityPaused
=
true
;
}
public
void
onPause
(
)
{
try
{
if
(
!
registeredCallbacks
)
{
onPause
(
activity
)
;
}
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
private
static
void
onResume
(
Activity
activity
)
{
isActivityPaused
=
false
;
currentActivity
=
activity
;
if
(
LeanplumInternal
.
isPaused
(
)
|
|
LeanplumInternal
.
hasStartedInBackground
(
)
)
{
Leanplum
.
resume
(
)
;
LocationManager
locationManager
=
ActionManager
.
getLocationManager
(
)
;
if
(
locationManager
!
=
null
)
{
locationManager
.
updateGeofencing
(
)
;
locationManager
.
updateUserLocation
(
)
;
}
}
LeanplumInternal
.
addStartIssuedHandler
(
runPendingActionsRunnable
)
;
}
public
void
onResume
(
)
{
try
{
if
(
!
registeredCallbacks
)
{
onResume
(
activity
)
;
}
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
private
static
void
onStop
(
Activity
activity
)
{
if
(
isActivityPaused
)
{
Leanplum
.
pause
(
)
;
LocationManager
locationManager
=
ActionManager
.
getLocationManager
(
)
;
if
(
locationManager
!
=
null
)
{
locationManager
.
updateGeofencing
(
)
;
}
}
if
(
currentActivity
!
=
null
&
&
currentActivity
.
equals
(
activity
)
)
{
currentActivity
=
null
;
}
}
public
void
onStop
(
)
{
try
{
if
(
!
registeredCallbacks
)
{
onStop
(
activity
)
;
}
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
public
static
void
queueActionUponActive
(
Runnable
action
)
{
try
{
if
(
currentActivity
!
=
null
&
&
!
currentActivity
.
isFinishing
(
)
&
&
!
isActivityPaused
&
&
(
!
(
action
instanceof
PostponableAction
)
|
|
!
isActivityClassIgnored
(
currentActivity
)
)
)
{
action
.
run
(
)
;
}
else
{
synchronized
(
pendingActions
)
{
pendingActions
.
add
(
action
)
;
}
}
}
catch
(
Throwable
t
)
{
Util
.
handleException
(
t
)
;
}
}
private
static
void
runPendingActions
(
)
{
if
(
isActivityPaused
|
|
currentActivity
=
=
null
)
{
return
;
}
Queue
<
Runnable
>
runningActions
;
synchronized
(
pendingActions
)
{
runningActions
=
new
LinkedList
<
>
(
pendingActions
)
;
pendingActions
.
clear
(
)
;
}
for
(
Runnable
action
:
runningActions
)
{
if
(
action
instanceof
PostponableAction
&
&
isActivityClassIgnored
(
currentActivity
)
)
{
pendingActions
.
add
(
action
)
;
}
else
{
action
.
run
(
)
;
}
}
}
private
static
boolean
isActivityClassIgnored
(
Activity
activity
)
{
return
ignoredActivityClasses
!
=
null
&
&
ignoredActivityClasses
.
contains
(
activity
.
getClass
(
)
)
;
}
public
static
void
deferMessagesForActivities
(
Class
.
.
.
activityClasses
)
{
if
(
activityClasses
=
=
null
|
|
activityClasses
.
length
=
=
0
)
{
return
;
}
if
(
ignoredActivityClasses
=
=
null
)
{
ignoredActivityClasses
=
new
HashSet
<
>
(
activityClasses
.
length
)
;
}
Collections
.
addAll
(
ignoredActivityClasses
activityClasses
)
;
}
}
