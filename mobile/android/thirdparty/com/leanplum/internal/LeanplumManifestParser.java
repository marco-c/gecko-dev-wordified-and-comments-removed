package
com
.
leanplum
.
internal
;
class
LeanplumManifestParser
{
private
static
final
int
START_TAG
=
0x00100102
;
private
static
final
int
END_TAG
=
0x00100103
;
private
static
final
String
SPACES
=
"
"
;
static
String
decompressXml
(
byte
[
]
xml
)
{
String
out
=
"
"
;
int
numbStrings
=
littleEndianValue
(
xml
4
*
4
)
;
int
sitOff
=
0x24
;
int
stOff
=
sitOff
+
numbStrings
*
4
;
int
off
=
scanForFirstStartTag
(
xml
)
;
int
indent
=
0
;
while
(
off
<
xml
.
length
)
{
int
tag0
=
littleEndianValue
(
xml
off
)
;
int
nameSi
=
littleEndianValue
(
xml
off
+
5
*
4
)
;
if
(
tag0
=
=
START_TAG
)
{
int
numbAttrs
=
littleEndianValue
(
xml
off
+
7
*
4
)
;
off
+
=
9
*
4
;
String
name
=
compXmlString
(
xml
sitOff
stOff
nameSi
)
;
StringBuilder
sb
=
new
StringBuilder
(
)
;
for
(
int
ii
=
0
;
ii
<
numbAttrs
;
ii
+
+
)
{
int
attrNameSi
=
littleEndianValue
(
xml
off
+
4
)
;
int
attrValueSi
=
littleEndianValue
(
xml
off
+
2
*
4
)
;
int
attrResId
=
littleEndianValue
(
xml
off
+
4
*
4
)
;
off
+
=
5
*
4
;
String
attrName
=
compXmlString
(
xml
sitOff
stOff
attrNameSi
)
;
String
attrValue
=
attrValueSi
!
=
-
1
?
compXmlString
(
xml
sitOff
stOff
attrValueSi
)
:
"
resourceID
0x
"
+
Integer
.
toHexString
(
attrResId
)
;
sb
.
append
(
"
"
)
.
append
(
attrName
)
.
append
(
"
=
\
"
"
)
.
append
(
attrValue
)
.
append
(
"
\
"
"
)
;
}
out
+
=
SPACES
.
substring
(
0
Math
.
min
(
indent
*
2
SPACES
.
length
(
)
)
)
+
"
<
"
+
name
+
sb
+
"
>
"
;
indent
+
+
;
}
else
if
(
tag0
=
=
END_TAG
)
{
indent
-
-
;
off
+
=
6
*
4
;
String
name
=
compXmlString
(
xml
sitOff
stOff
nameSi
)
;
out
+
=
SPACES
.
substring
(
0
Math
.
min
(
indent
*
2
SPACES
.
length
(
)
)
)
+
"
<
/
"
+
name
+
"
>
"
;
}
else
{
break
;
}
}
return
out
;
}
private
static
String
compXmlString
(
byte
[
]
xml
int
sitOff
int
stOff
int
strInd
)
{
if
(
strInd
<
0
)
return
null
;
int
strOff
=
stOff
+
littleEndianValue
(
xml
sitOff
+
strInd
*
4
)
;
return
compXmlStringAt
(
xml
strOff
)
;
}
private
static
String
compXmlStringAt
(
byte
[
]
arr
int
strOff
)
{
int
strLen
=
arr
[
strOff
+
1
]
<
<
8
&
0xff00
|
arr
[
strOff
]
&
0xff
;
byte
[
]
chars
=
new
byte
[
strLen
]
;
for
(
int
ii
=
0
;
ii
<
strLen
;
ii
+
+
)
{
chars
[
ii
]
=
arr
[
strOff
+
2
+
ii
*
2
]
;
}
return
new
String
(
chars
)
;
}
private
static
int
littleEndianValue
(
byte
[
]
arr
int
off
)
{
return
arr
[
off
+
3
]
<
<
24
&
0xff000000
|
arr
[
off
+
2
]
<
<
16
&
0xff0000
|
arr
[
off
+
1
]
<
<
8
&
0xff00
|
arr
[
off
]
&
0xFF
;
}
private
static
int
scanForFirstStartTag
(
byte
[
]
xml
)
{
int
xmlTagOff
=
littleEndianValue
(
xml
3
*
4
)
;
for
(
int
ii
=
xmlTagOff
;
ii
<
xml
.
length
-
4
;
ii
+
=
4
)
{
if
(
littleEndianValue
(
xml
ii
)
=
=
START_TAG
)
{
xmlTagOff
=
ii
;
break
;
}
}
return
xmlTagOff
;
}
}
