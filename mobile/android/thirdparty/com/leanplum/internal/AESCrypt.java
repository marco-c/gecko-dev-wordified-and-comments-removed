package
com
.
leanplum
.
internal
;
import
android
.
content
.
SharedPreferences
;
import
android
.
util
.
Pair
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
security
.
InvalidAlgorithmParameterException
;
import
java
.
security
.
InvalidKeyException
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
security
.
spec
.
InvalidKeySpecException
;
import
java
.
security
.
spec
.
KeySpec
;
import
java
.
util
.
Arrays
;
import
javax
.
crypto
.
BadPaddingException
;
import
javax
.
crypto
.
Cipher
;
import
javax
.
crypto
.
IllegalBlockSizeException
;
import
javax
.
crypto
.
NoSuchPaddingException
;
import
javax
.
crypto
.
SecretKey
;
import
javax
.
crypto
.
SecretKeyFactory
;
import
javax
.
crypto
.
spec
.
IvParameterSpec
;
import
javax
.
crypto
.
spec
.
PBEKeySpec
;
import
javax
.
crypto
.
spec
.
SecretKeySpec
;
public
class
AESCrypt
{
private
static
enum
EncryptionType
{
LEGACY_TOKEN
(
0
)
APP_ID_KEY
(
1
)
;
public
final
int
id
;
public
final
String
prefix
;
public
final
String
prefixWithBracket
;
EncryptionType
(
int
id
)
{
this
.
id
=
id
;
prefix
=
String
.
format
(
"
%
02d
"
id
)
;
prefixWithBracket
=
prefix
+
"
[
"
;
}
private
static
EncryptionType
forId
(
int
id
)
{
if
(
id
=
=
1
)
{
return
APP_ID_KEY
;
}
return
null
;
}
public
static
Pair
<
EncryptionType
String
>
parseCipherText
(
String
cipherText
)
{
if
(
cipherText
=
=
null
|
|
cipherText
.
isEmpty
(
)
)
{
return
null
;
}
if
(
cipherText
.
startsWith
(
"
[
"
)
)
{
return
Pair
.
create
(
LEGACY_TOKEN
cipherText
)
;
}
if
(
cipherText
.
startsWith
(
APP_ID_KEY
.
prefixWithBracket
)
)
{
return
Pair
.
create
(
APP_ID_KEY
cipherText
.
substring
(
APP_ID_KEY
.
prefixWithBracket
.
length
(
)
-
1
)
)
;
}
return
null
;
}
}
private
static
final
String
APP_ID_KEY_PREFIX
=
new
StringBuilder
(
)
.
append
(
"
L
"
)
.
append
(
"
q
"
)
.
append
(
3
)
.
append
(
"
f
"
)
.
append
(
"
z
"
)
.
toString
(
)
;
private
static
final
String
APP_ID_KEY_SUFFIX
=
new
StringBuilder
(
)
.
append
(
"
b
"
)
.
append
(
"
L
"
)
.
append
(
"
t
"
)
.
append
(
"
i
"
)
.
append
(
2
)
.
toString
(
)
;
private
final
String
appId
;
private
final
String
token
;
public
AESCrypt
(
String
appId
String
token
)
{
this
.
appId
=
appId
;
this
.
token
=
token
;
}
private
String
appIdKeyPassword
(
)
{
return
APP_ID_KEY_PREFIX
+
appId
+
APP_ID_KEY_SUFFIX
;
}
public
String
encrypt
(
String
plaintext
)
{
if
(
plaintext
=
=
null
)
{
return
null
;
}
if
(
appId
=
=
null
|
|
appId
.
isEmpty
(
)
)
{
Log
.
e
(
"
Encrypt
called
with
null
appId
.
"
)
;
return
null
;
}
String
cipherText
=
encryptInternal
(
appIdKeyPassword
(
)
plaintext
)
;
if
(
cipherText
=
=
null
)
{
Log
.
w
(
"
Failed
to
encrypt
.
"
)
;
return
null
;
}
if
(
cipherText
.
isEmpty
(
)
|
|
cipherText
.
equals
(
plaintext
)
|
|
!
cipherText
.
startsWith
(
"
[
"
)
)
{
Log
.
w
(
"
Invalid
ciphertext
:
"
+
cipherText
)
;
return
null
;
}
return
EncryptionType
.
APP_ID_KEY
.
prefix
+
cipherText
;
}
public
String
decodePreference
(
SharedPreferences
preferences
String
key
String
defaultValue
)
{
String
cipherText
=
preferences
.
getString
(
key
null
)
;
if
(
cipherText
=
=
null
)
{
return
defaultValue
;
}
String
decoded
=
decrypt
(
cipherText
)
;
if
(
decoded
=
=
null
)
{
return
defaultValue
;
}
return
decoded
;
}
public
String
decrypt
(
String
cipherText
)
{
Pair
<
EncryptionType
String
>
encryptionSpec
=
EncryptionType
.
parseCipherText
(
cipherText
)
;
String
result
=
null
;
if
(
encryptionSpec
=
=
null
)
{
Log
.
v
(
"
Got
null
encryptionSpec
for
encrypted
:
"
+
cipherText
)
;
}
else
{
switch
(
encryptionSpec
.
first
)
{
case
LEGACY_TOKEN
:
if
(
token
=
=
null
|
|
token
.
isEmpty
(
)
)
{
Log
.
e
(
"
Decrypt
called
with
null
token
.
"
)
;
}
else
{
result
=
decryptInternal
(
token
encryptionSpec
.
second
)
;
if
(
result
!
=
null
&
&
parseCiphertextInternal
(
result
)
!
=
null
)
{
Log
.
e
(
"
Discarding
legacy
value
that
appears
to
be
an
encrypted
value
:
"
+
result
)
;
return
null
;
}
}
break
;
case
APP_ID_KEY
:
if
(
appId
=
=
null
|
|
appId
.
isEmpty
(
)
)
{
Log
.
e
(
"
Decrypt
called
with
null
appId
.
"
)
;
}
else
{
result
=
decryptInternal
(
appIdKeyPassword
(
)
encryptionSpec
.
second
)
;
}
break
;
}
}
if
(
result
=
=
null
)
{
Log
.
w
(
"
Unable
to
decrypt
"
+
cipherText
)
;
}
return
result
;
}
public
static
String
encryptInternal
(
String
password
String
plaintext
)
{
try
{
return
Arrays
.
toString
(
performCryptOperation
(
Cipher
.
ENCRYPT_MODE
password
plaintext
.
getBytes
(
"
UTF
-
8
"
)
)
)
;
}
catch
(
UnsupportedEncodingException
e
)
{
Log
.
w
(
"
Unable
to
encrypt
"
+
plaintext
e
)
;
return
null
;
}
}
private
static
byte
[
]
parseCiphertextInternal
(
String
ciphertext
)
{
if
(
ciphertext
=
=
null
)
{
return
null
;
}
ciphertext
=
ciphertext
.
trim
(
)
;
if
(
ciphertext
.
length
(
)
<
2
)
{
return
null
;
}
try
{
String
[
]
byteStrings
=
ciphertext
.
substring
(
1
ciphertext
.
length
(
)
-
1
)
.
trim
(
)
.
split
(
"
\
\
s
*
\
\
s
*
"
)
;
byte
[
]
bytes
=
new
byte
[
byteStrings
.
length
]
;
for
(
int
i
=
0
;
i
<
byteStrings
.
length
;
i
+
+
)
{
bytes
[
i
]
=
Byte
.
parseByte
(
byteStrings
[
i
]
)
;
}
return
bytes
;
}
catch
(
NumberFormatException
e
)
{
return
null
;
}
}
private
static
String
decryptInternal
(
String
password
String
ciphertext
)
{
try
{
byte
[
]
bytes
=
parseCiphertextInternal
(
ciphertext
)
;
if
(
bytes
=
=
null
)
{
Log
.
w
(
"
Invalid
ciphertext
:
"
+
ciphertext
)
;
return
null
;
}
byte
[
]
byteResult
=
performCryptOperation
(
Cipher
.
DECRYPT_MODE
password
bytes
)
;
if
(
byteResult
!
=
null
)
{
return
new
String
(
byteResult
"
UTF
-
8
"
)
;
}
}
catch
(
UnsupportedEncodingException
e
)
{
Log
.
w
(
"
Could
not
encode
UTF8
string
.
\
n
"
+
Log
.
getStackTraceString
(
e
)
)
;
}
return
null
;
}
private
static
byte
[
]
performCryptOperation
(
int
mode
String
password
byte
[
]
text
)
{
byte
[
]
result
=
null
;
try
{
byte
[
]
SALT
=
Constants
.
Crypt
.
SALT
.
getBytes
(
"
UTF
-
8
"
)
;
byte
[
]
IV
=
Constants
.
Crypt
.
IV
.
getBytes
(
"
UTF
-
8
"
)
;
KeySpec
keySpec
=
new
PBEKeySpec
(
password
.
toCharArray
(
)
SALT
Constants
.
Crypt
.
ITER_COUNT
Constants
.
Crypt
.
KEY_LENGTH
)
;
SecretKeyFactory
keyFactory
=
SecretKeyFactory
.
getInstance
(
"
PBEWithMD5And128BitAES
-
CBC
-
OpenSSL
"
)
;
byte
[
]
keyBytes
=
keyFactory
.
generateSecret
(
keySpec
)
.
getEncoded
(
)
;
SecretKey
key
=
new
SecretKeySpec
(
keyBytes
"
AES
"
)
;
Cipher
cipher
=
Cipher
.
getInstance
(
"
AES
/
CBC
/
PKCS5Padding
"
)
;
IvParameterSpec
ivParams
=
new
IvParameterSpec
(
IV
)
;
cipher
.
init
(
mode
key
ivParams
)
;
result
=
cipher
.
doFinal
(
text
)
;
}
catch
(
InvalidKeyException
e
)
{
}
catch
(
NoSuchAlgorithmException
e
)
{
}
catch
(
NoSuchPaddingException
e
)
{
}
catch
(
InvalidAlgorithmParameterException
e
)
{
}
catch
(
IllegalBlockSizeException
e
)
{
}
catch
(
BadPaddingException
e
)
{
}
catch
(
UnsupportedEncodingException
e
)
{
}
catch
(
InvalidKeySpecException
e
)
{
}
return
result
;
}
}
