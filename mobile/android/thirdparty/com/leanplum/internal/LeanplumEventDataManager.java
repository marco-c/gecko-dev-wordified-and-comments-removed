package
com
.
leanplum
.
internal
;
import
android
.
content
.
ContentValues
;
import
android
.
content
.
Context
;
import
android
.
content
.
SharedPreferences
;
import
android
.
database
.
Cursor
;
import
android
.
database
.
DatabaseUtils
;
import
android
.
database
.
sqlite
.
SQLiteDatabase
;
import
android
.
database
.
sqlite
.
SQLiteOpenHelper
;
import
com
.
leanplum
.
Leanplum
;
import
com
.
leanplum
.
utils
.
SharedPreferencesUtil
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Map
;
import
java
.
util
.
UUID
;
public
class
LeanplumEventDataManager
{
private
static
final
String
DATABASE_NAME
=
"
__leanplum
.
db
"
;
private
static
final
int
DATABASE_VERSION
=
1
;
private
static
final
String
EVENT_TABLE_NAME
=
"
event
"
;
private
static
final
String
COLUMN_DATA
=
"
data
"
;
private
static
final
String
KEY_ROWID
=
"
rowid
"
;
private
static
SQLiteDatabase
database
;
private
static
LeanplumDataBaseManager
databaseManager
;
private
static
ContentValues
contentValues
=
new
ContentValues
(
)
;
static
boolean
willSendErrorLog
=
false
;
public
static
void
init
(
Context
context
)
{
if
(
database
!
=
null
)
{
Log
.
e
(
"
Database
is
already
initialized
.
"
)
;
return
;
}
try
{
if
(
databaseManager
=
=
null
)
{
databaseManager
=
new
LeanplumDataBaseManager
(
context
)
;
}
database
=
databaseManager
.
getWritableDatabase
(
)
;
}
catch
(
Throwable
t
)
{
handleSQLiteError
(
"
Cannot
create
database
.
"
t
)
;
}
}
static
void
insertEvent
(
String
event
)
{
if
(
database
=
=
null
)
{
return
;
}
contentValues
.
put
(
COLUMN_DATA
event
)
;
try
{
database
.
insert
(
EVENT_TABLE_NAME
null
contentValues
)
;
willSendErrorLog
=
false
;
}
catch
(
Throwable
t
)
{
handleSQLiteError
(
"
Unable
to
insert
event
to
database
.
"
t
)
;
}
contentValues
.
clear
(
)
;
Leanplum
.
countAggregator
(
)
.
incrementCount
(
"
add_event
"
)
;
}
static
List
<
Map
<
String
Object
>
>
getEvents
(
int
count
)
{
List
<
Map
<
String
Object
>
>
events
=
new
ArrayList
<
>
(
)
;
if
(
database
=
=
null
)
{
return
events
;
}
Cursor
cursor
=
null
;
try
{
cursor
=
database
.
query
(
EVENT_TABLE_NAME
new
String
[
]
{
COLUMN_DATA
}
null
null
null
null
KEY_ROWID
+
"
ASC
"
"
"
+
count
)
;
willSendErrorLog
=
false
;
while
(
cursor
.
moveToNext
(
)
)
{
Map
<
String
Object
>
requestArgs
=
JsonConverter
.
mapFromJson
(
new
JSONObject
(
cursor
.
getString
(
cursor
.
getColumnIndex
(
COLUMN_DATA
)
)
)
)
;
events
.
add
(
requestArgs
)
;
}
}
catch
(
Throwable
t
)
{
handleSQLiteError
(
"
Unable
to
get
events
from
the
table
.
"
t
)
;
}
finally
{
if
(
cursor
!
=
null
)
{
cursor
.
close
(
)
;
}
}
Leanplum
.
countAggregator
(
)
.
incrementCount
(
"
events_with_limit
"
)
;
return
events
;
}
static
void
deleteEvents
(
int
count
)
{
if
(
database
=
=
null
)
{
return
;
}
try
{
database
.
delete
(
EVENT_TABLE_NAME
KEY_ROWID
+
"
in
(
select
"
+
KEY_ROWID
+
"
from
"
+
EVENT_TABLE_NAME
+
"
ORDER
BY
"
+
KEY_ROWID
+
"
ASC
LIMIT
"
+
count
+
"
)
"
null
)
;
willSendErrorLog
=
false
;
}
catch
(
Throwable
t
)
{
handleSQLiteError
(
"
Unable
to
delete
events
from
the
table
.
"
t
)
;
}
Leanplum
.
countAggregator
(
)
.
incrementCount
(
"
delete_events_with_limit
"
)
;
}
static
long
getEventsCount
(
)
{
long
count
=
0
;
if
(
database
=
=
null
)
{
return
count
;
}
try
{
count
=
DatabaseUtils
.
queryNumEntries
(
database
EVENT_TABLE_NAME
)
;
willSendErrorLog
=
false
;
}
catch
(
Throwable
t
)
{
handleSQLiteError
(
"
Unable
to
get
a
number
of
rows
in
the
table
.
"
t
)
;
}
return
count
;
}
private
static
void
handleSQLiteError
(
String
log
Throwable
t
)
{
Log
.
e
(
log
t
)
;
if
(
!
willSendErrorLog
)
{
willSendErrorLog
=
true
;
Util
.
handleException
(
t
)
;
}
}
private
static
class
LeanplumDataBaseManager
extends
SQLiteOpenHelper
{
LeanplumDataBaseManager
(
Context
context
)
{
super
(
context
DATABASE_NAME
null
DATABASE_VERSION
)
;
}
Override
public
void
onCreate
(
SQLiteDatabase
db
)
{
db
.
execSQL
(
"
CREATE
TABLE
IF
NOT
EXISTS
"
+
EVENT_TABLE_NAME
+
"
(
"
+
COLUMN_DATA
+
"
TEXT
)
"
)
;
try
{
migrateFromSharedPreferences
(
db
)
;
}
catch
(
Throwable
t
)
{
Log
.
e
(
"
Cannot
move
old
data
from
shared
preferences
to
SQLite
table
.
"
t
)
;
Util
.
handleException
(
t
)
;
}
}
Override
public
void
onUpgrade
(
SQLiteDatabase
db
int
oldVersion
int
newVersion
)
{
}
private
static
void
migrateFromSharedPreferences
(
SQLiteDatabase
db
)
{
synchronized
(
RequestOld
.
class
)
{
Context
context
=
Leanplum
.
getContext
(
)
;
SharedPreferences
preferences
=
context
.
getSharedPreferences
(
RequestOld
.
LEANPLUM
Context
.
MODE_PRIVATE
)
;
SharedPreferences
.
Editor
editor
=
preferences
.
edit
(
)
;
int
count
=
preferences
.
getInt
(
Constants
.
Defaults
.
COUNT_KEY
0
)
;
if
(
count
=
=
0
)
{
return
;
}
List
<
Map
<
String
Object
>
>
requestData
=
new
ArrayList
<
>
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
String
itemKey
=
String
.
format
(
Locale
.
US
Constants
.
Defaults
.
ITEM_KEY
i
)
;
Map
<
String
Object
>
requestArgs
;
try
{
requestArgs
=
JsonConverter
.
mapFromJson
(
new
JSONObject
(
preferences
.
getString
(
itemKey
"
{
}
"
)
)
)
;
requestData
.
add
(
requestArgs
)
;
}
catch
(
JSONException
e
)
{
e
.
printStackTrace
(
)
;
}
editor
.
remove
(
itemKey
)
;
}
editor
.
remove
(
Constants
.
Defaults
.
COUNT_KEY
)
;
try
{
String
uuid
=
preferences
.
getString
(
Constants
.
Defaults
.
UUID_KEY
null
)
;
if
(
uuid
=
=
null
|
|
count
%
RequestOld
.
MAX_EVENTS_PER_API_CALL
=
=
0
)
{
uuid
=
UUID
.
randomUUID
(
)
.
toString
(
)
;
editor
.
putString
(
Constants
.
Defaults
.
UUID_KEY
uuid
)
;
}
for
(
Map
<
String
Object
>
event
:
requestData
)
{
event
.
put
(
RequestOld
.
UUID_KEY
uuid
)
;
contentValues
.
put
(
COLUMN_DATA
JsonConverter
.
toJson
(
event
)
)
;
db
.
insert
(
EVENT_TABLE_NAME
null
contentValues
)
;
contentValues
.
clear
(
)
;
}
SharedPreferencesUtil
.
commitChanges
(
editor
)
;
}
catch
(
Throwable
t
)
{
Log
.
e
(
"
Failed
on
migration
data
from
shared
preferences
.
"
t
)
;
Util
.
handleException
(
t
)
;
}
}
}
}
}
