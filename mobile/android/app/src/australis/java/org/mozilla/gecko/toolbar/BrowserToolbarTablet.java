package
org
.
mozilla
.
gecko
.
toolbar
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
animation
.
PropertyAnimator
;
import
org
.
mozilla
.
gecko
.
animation
.
ViewHelper
;
import
org
.
mozilla
.
gecko
.
util
.
ViewUtil
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
drawable
.
Drawable
;
import
android
.
support
.
v4
.
view
.
MarginLayoutParamsCompat
;
import
android
.
support
.
v4
.
view
.
ViewCompat
;
import
android
.
util
.
AttributeSet
;
class
BrowserToolbarTablet
extends
BrowserToolbarTabletBase
{
private
static
final
int
FORWARD_ANIMATION_DURATION
=
450
;
private
enum
ForwardButtonState
{
HIDDEN
DISPLAYED
TRANSITIONING
}
private
final
int
forwardButtonTranslationWidth
;
private
ForwardButtonState
forwardButtonState
;
private
boolean
backButtonWasEnabledOnStartEditing
;
public
BrowserToolbarTablet
(
final
Context
context
final
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
forwardButtonTranslationWidth
=
getResources
(
)
.
getDimensionPixelOffset
(
R
.
dimen
.
tablet_nav_button_width
)
;
ViewHelper
.
setTranslationX
(
forwardButton
forwardButtonTranslationWidth
*
(
isLayoutRtl
(
)
?
1
:
-
1
)
)
;
forwardButton
.
setEnabled
(
true
)
;
updateForwardButtonState
(
ForwardButtonState
.
HIDDEN
)
;
}
private
boolean
isLayoutRtl
(
)
{
return
ViewCompat
.
getLayoutDirection
(
this
)
=
=
ViewCompat
.
LAYOUT_DIRECTION_RTL
;
}
private
void
updateForwardButtonState
(
final
ForwardButtonState
state
)
{
forwardButtonState
=
state
;
forwardButton
.
setEnabled
(
forwardButtonState
=
=
ForwardButtonState
.
DISPLAYED
)
;
}
Override
public
boolean
isAnimating
(
)
{
return
false
;
}
Override
protected
void
triggerStartEditingTransition
(
final
PropertyAnimator
animator
)
{
showUrlEditLayout
(
)
;
}
Override
protected
void
triggerStopEditingTransition
(
)
{
hideUrlEditLayout
(
)
;
}
Override
protected
void
animateForwardButton
(
final
ForwardButtonAnimation
animation
)
{
final
boolean
willShowForward
=
(
animation
=
=
ForwardButtonAnimation
.
SHOW
)
;
if
(
(
forwardButtonState
!
=
ForwardButtonState
.
HIDDEN
&
&
willShowForward
)
|
|
(
forwardButtonState
!
=
ForwardButtonState
.
DISPLAYED
&
&
!
willShowForward
)
)
{
return
;
}
updateForwardButtonState
(
ForwardButtonState
.
TRANSITIONING
)
;
final
PropertyAnimator
forwardAnim
=
new
PropertyAnimator
(
isSwitchingTabs
?
10
:
FORWARD_ANIMATION_DURATION
)
;
forwardAnim
.
addPropertyAnimationListener
(
new
PropertyAnimator
.
PropertyAnimationListener
(
)
{
Override
public
void
onPropertyAnimationStart
(
)
{
if
(
!
willShowForward
)
{
MarginLayoutParams
layoutParams
=
(
MarginLayoutParams
)
urlDisplayLayout
.
getLayoutParams
(
)
;
ViewUtil
.
setMarginStart
(
layoutParams
0
isLayoutRtl
(
)
)
;
layoutParams
=
(
MarginLayoutParams
)
urlEditLayout
.
getLayoutParams
(
)
;
ViewUtil
.
setMarginStart
(
layoutParams
0
isLayoutRtl
(
)
)
;
requestLayout
(
)
;
}
}
Override
public
void
onPropertyAnimationEnd
(
)
{
final
ForwardButtonState
newForwardButtonState
;
if
(
willShowForward
)
{
MarginLayoutParams
layoutParams
=
(
MarginLayoutParams
)
urlDisplayLayout
.
getLayoutParams
(
)
;
ViewUtil
.
setMarginStart
(
layoutParams
forwardButtonTranslationWidth
isLayoutRtl
(
)
)
;
layoutParams
=
(
MarginLayoutParams
)
urlEditLayout
.
getLayoutParams
(
)
;
ViewUtil
.
setMarginStart
(
layoutParams
forwardButtonTranslationWidth
isLayoutRtl
(
)
)
;
newForwardButtonState
=
ForwardButtonState
.
DISPLAYED
;
}
else
{
newForwardButtonState
=
ForwardButtonState
.
HIDDEN
;
}
urlDisplayLayout
.
finishForwardAnimation
(
)
;
updateForwardButtonState
(
newForwardButtonState
)
;
requestLayout
(
)
;
}
}
)
;
prepareForwardAnimation
(
forwardAnim
animation
forwardButtonTranslationWidth
)
;
forwardAnim
.
start
(
)
;
}
private
void
prepareForwardAnimation
(
PropertyAnimator
anim
ForwardButtonAnimation
animation
int
width
)
{
boolean
isLayoutRtl
=
isLayoutRtl
(
)
;
if
(
animation
=
=
ForwardButtonAnimation
.
HIDE
)
{
anim
.
attach
(
forwardButton
PropertyAnimator
.
Property
.
TRANSLATION_X
width
*
(
isLayoutRtl
?
1
:
-
1
)
)
;
anim
.
attach
(
forwardButton
PropertyAnimator
.
Property
.
ALPHA
0
)
;
}
else
{
anim
.
attach
(
forwardButton
PropertyAnimator
.
Property
.
TRANSLATION_X
0
)
;
anim
.
attach
(
forwardButton
PropertyAnimator
.
Property
.
ALPHA
1
)
;
}
urlDisplayLayout
.
prepareForwardAnimation
(
anim
animation
width
)
;
}
Override
public
void
triggerTabsPanelTransition
(
final
PropertyAnimator
animator
final
boolean
areTabsShown
)
{
}
Override
public
void
startEditing
(
final
String
url
final
PropertyAnimator
animator
)
{
backButtonWasEnabledOnStartEditing
=
backButton
.
isEnabled
(
)
;
backButton
.
setEnabled
(
false
)
;
forwardButton
.
setEnabled
(
false
)
;
super
.
startEditing
(
url
animator
)
;
}
Override
public
String
commitEdit
(
)
{
stopEditingNewTablet
(
)
;
return
super
.
commitEdit
(
)
;
}
Override
public
String
cancelEdit
(
)
{
if
(
isEditing
(
)
)
{
stopEditingNewTablet
(
)
;
backButton
.
setEnabled
(
backButtonWasEnabledOnStartEditing
)
;
updateForwardButtonState
(
forwardButtonState
)
;
}
return
super
.
cancelEdit
(
)
;
}
private
void
stopEditingNewTablet
(
)
{
forwardButton
.
setEnabled
(
true
)
;
}
Override
protected
Drawable
getLWTDefaultStateSetDrawable
(
)
{
return
BrowserToolbar
.
getLightweightThemeDrawable
(
this
getTheme
(
)
R
.
color
.
toolbar_grey
)
;
}
}
