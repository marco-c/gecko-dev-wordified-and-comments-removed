package
org
.
mozilla
.
gecko
.
sync
.
repositories
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
util
.
ArrayList
;
import
org
.
mozilla
.
gecko
.
sync
.
InfoCollections
;
import
org
.
mozilla
.
gecko
.
sync
.
InfoConfiguration
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
AuthHeaderProvider
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionCreationDelegate
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
public
class
Server11Repository
extends
Repository
{
protected
String
collection
;
protected
URI
collectionURI
;
protected
final
AuthHeaderProvider
authHeaderProvider
;
protected
final
InfoCollections
infoCollections
;
private
final
InfoConfiguration
infoConfiguration
;
public
Server11Repository
(
NonNull
String
collection
NonNull
String
storageURL
AuthHeaderProvider
authHeaderProvider
NonNull
InfoCollections
infoCollections
NonNull
InfoConfiguration
infoConfiguration
)
throws
URISyntaxException
{
if
(
collection
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
collection
must
not
be
null
"
)
;
}
if
(
storageURL
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
storageURL
must
not
be
null
"
)
;
}
if
(
infoCollections
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
infoCollections
must
not
be
null
"
)
;
}
this
.
collection
=
collection
;
this
.
collectionURI
=
new
URI
(
storageURL
+
(
storageURL
.
endsWith
(
"
/
"
)
?
collection
:
"
/
"
+
collection
)
)
;
this
.
authHeaderProvider
=
authHeaderProvider
;
this
.
infoCollections
=
infoCollections
;
this
.
infoConfiguration
=
infoConfiguration
;
}
Override
public
void
createSession
(
RepositorySessionCreationDelegate
delegate
Context
context
)
{
delegate
.
onSessionCreated
(
new
Server11RepositorySession
(
this
)
)
;
}
public
URI
collectionURI
(
)
{
return
this
.
collectionURI
;
}
public
URI
collectionURI
(
boolean
full
long
newer
long
limit
String
sort
String
ids
String
offset
)
throws
URISyntaxException
{
ArrayList
<
String
>
params
=
new
ArrayList
<
String
>
(
)
;
if
(
full
)
{
params
.
add
(
"
full
=
1
"
)
;
}
if
(
newer
>
=
0
)
{
String
newerString
=
Utils
.
millisecondsToDecimalSecondsString
(
newer
)
;
params
.
add
(
"
newer
=
"
+
newerString
)
;
}
if
(
limit
>
0
)
{
params
.
add
(
"
limit
=
"
+
limit
)
;
}
if
(
sort
!
=
null
)
{
params
.
add
(
"
sort
=
"
+
sort
)
;
}
if
(
ids
!
=
null
)
{
params
.
add
(
"
ids
=
"
+
ids
)
;
}
if
(
offset
!
=
null
)
{
params
.
add
(
"
offset
=
"
+
offset
)
;
}
if
(
params
.
size
(
)
=
=
0
)
{
return
this
.
collectionURI
;
}
StringBuilder
out
=
new
StringBuilder
(
)
;
char
indicator
=
'
?
'
;
for
(
String
param
:
params
)
{
out
.
append
(
indicator
)
;
indicator
=
'
&
'
;
out
.
append
(
param
)
;
}
String
uri
=
this
.
collectionURI
+
out
.
toString
(
)
;
return
new
URI
(
uri
)
;
}
public
URI
wboURI
(
String
id
)
throws
URISyntaxException
{
return
new
URI
(
this
.
collectionURI
+
"
/
"
+
id
)
;
}
SuppressWarnings
(
"
static
-
method
"
)
public
long
getDefaultBatchLimit
(
)
{
return
-
1
;
}
SuppressWarnings
(
"
static
-
method
"
)
public
String
getDefaultSort
(
)
{
return
null
;
}
public
long
getDefaultTotalLimit
(
)
{
return
-
1
;
}
public
AuthHeaderProvider
getAuthHeaderProvider
(
)
{
return
authHeaderProvider
;
}
public
boolean
updateNeeded
(
long
lastSyncTimestamp
)
{
return
infoCollections
.
updateNeeded
(
collection
lastSyncTimestamp
)
;
}
Nullable
public
Long
getCollectionLastModified
(
)
{
return
infoCollections
.
getTimestamp
(
collection
)
;
}
public
InfoConfiguration
getInfoConfiguration
(
)
{
return
infoConfiguration
;
}
}
