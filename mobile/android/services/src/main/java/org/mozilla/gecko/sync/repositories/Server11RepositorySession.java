package
org
.
mozilla
.
gecko
.
sync
.
repositories
;
import
android
.
net
.
Uri
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionGuidsSinceDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionWipeDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
downloaders
.
BatchingDownloader
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
uploaders
.
BatchingUploader
;
public
class
Server11RepositorySession
extends
RepositorySession
{
public
static
final
String
LOG_TAG
=
"
Server11RepositorySession
"
;
protected
final
Server11Repository
serverRepository
;
private
BatchingUploader
uploader
;
private
final
BatchingDownloader
downloader
;
public
Server11RepositorySession
(
Repository
repository
)
{
super
(
repository
)
;
this
.
serverRepository
=
(
Server11Repository
)
repository
;
this
.
downloader
=
initializeDownloader
(
this
)
;
}
Override
public
void
setStoreDelegate
(
RepositorySessionStoreDelegate
storeDelegate
)
{
super
.
setStoreDelegate
(
storeDelegate
)
;
this
.
uploader
=
new
BatchingUploader
(
this
storeWorkQueue
storeDelegate
Uri
.
parse
(
serverRepository
.
collectionURI
.
toString
(
)
)
serverRepository
.
getCollectionLastModified
(
)
serverRepository
.
getInfoConfiguration
(
)
serverRepository
.
authHeaderProvider
)
;
}
Override
public
void
guidsSince
(
long
timestamp
RepositorySessionGuidsSinceDelegate
delegate
)
{
}
Override
public
void
fetchSince
(
long
sinceTimestamp
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
downloader
.
fetchSince
(
delegate
sinceTimestamp
serverRepository
.
getBatchLimit
(
)
serverRepository
.
getSortOrder
(
)
)
;
}
Override
public
void
fetchAll
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
fetchSince
(
-
1
delegate
)
;
}
Override
public
void
fetch
(
String
[
]
guids
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
downloader
.
fetch
(
guids
delegate
)
;
}
Override
public
void
wipe
(
RepositorySessionWipeDelegate
delegate
)
{
if
(
!
isActive
(
)
)
{
delegate
.
onWipeFailed
(
new
InactiveSessionException
(
)
)
;
return
;
}
}
Override
public
void
store
(
Record
record
)
throws
NoStoreDelegateException
{
if
(
storeDelegate
=
=
null
)
{
throw
new
NoStoreDelegateException
(
)
;
}
if
(
uploader
=
=
null
)
{
throw
new
IllegalStateException
(
"
Uploader
haven
'
t
been
initialized
"
)
;
}
uploader
.
process
(
record
)
;
}
Override
public
void
storeDone
(
)
{
Logger
.
debug
(
LOG_TAG
"
storeDone
(
)
.
"
)
;
if
(
uploader
=
=
null
)
{
throw
new
IllegalStateException
(
"
Uploader
haven
'
t
been
initialized
"
)
;
}
uploader
.
noMoreRecordsToUpload
(
)
;
}
Override
public
boolean
dataAvailable
(
)
{
return
serverRepository
.
updateNeeded
(
getLastSyncTimestamp
(
)
)
;
}
protected
static
BatchingDownloader
initializeDownloader
(
final
Server11RepositorySession
serverRepositorySession
)
{
return
new
BatchingDownloader
(
serverRepositorySession
.
serverRepository
.
authHeaderProvider
Uri
.
parse
(
serverRepositorySession
.
serverRepository
.
collectionURI
(
)
.
toString
(
)
)
serverRepositorySession
.
serverRepository
.
getAllowMultipleBatches
(
)
serverRepositorySession
)
;
}
}
