package
org
.
mozilla
.
gecko
.
sync
.
synchronizer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
public
class
StoreBatchTracker
{
private
final
AtomicInteger
currentStoreBatchAttempted
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
currentStoreBatchAccepted
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
currentStoreBatchFailed
=
new
AtomicInteger
(
)
;
private
final
ConcurrentLinkedQueue
<
Batch
>
completedBatches
=
new
ConcurrentLinkedQueue
<
>
(
)
;
public
static
class
Batch
{
public
final
int
sent
;
public
final
int
failed
;
public
Batch
(
final
int
sent
final
int
failed
)
{
this
.
sent
=
sent
;
this
.
failed
=
failed
;
}
}
void
reset
(
)
{
currentStoreBatchFailed
.
set
(
0
)
;
currentStoreBatchAccepted
.
set
(
0
)
;
currentStoreBatchAttempted
.
set
(
0
)
;
completedBatches
.
clear
(
)
;
}
private
boolean
haveUncommittedBatchData
(
)
{
return
currentStoreBatchAttempted
.
get
(
)
!
=
0
|
|
currentStoreBatchAccepted
.
get
(
)
!
=
0
|
|
currentStoreBatchFailed
.
get
(
)
!
=
0
;
}
void
onBatchFinished
(
)
{
final
int
sent
=
currentStoreBatchAttempted
.
getAndSet
(
0
)
;
final
int
knownFailed
=
currentStoreBatchFailed
.
getAndSet
(
0
)
;
final
int
knownSucceeded
=
currentStoreBatchAccepted
.
getAndSet
(
0
)
;
final
int
failed
=
Math
.
max
(
knownFailed
sent
-
knownSucceeded
)
;
completedBatches
.
add
(
new
Batch
(
sent
failed
)
)
;
}
void
onBatchFailed
(
)
{
if
(
currentStoreBatchFailed
.
get
(
)
=
=
0
&
&
currentStoreBatchAccepted
.
get
(
)
=
=
currentStoreBatchAttempted
.
get
(
)
)
{
currentStoreBatchFailed
.
incrementAndGet
(
)
;
}
onBatchFinished
(
)
;
}
void
onRecordStoreFailed
(
)
{
currentStoreBatchFailed
.
incrementAndGet
(
)
;
}
void
onRecordStoreSucceeded
(
)
{
currentStoreBatchAccepted
.
incrementAndGet
(
)
;
}
void
onRecordStoreAttempted
(
)
{
currentStoreBatchAttempted
.
incrementAndGet
(
)
;
}
ArrayList
<
Batch
>
getStoreBatches
(
)
{
if
(
haveUncommittedBatchData
(
)
)
{
onBatchFinished
(
)
;
}
return
new
ArrayList
<
>
(
completedBatches
)
;
}
}
