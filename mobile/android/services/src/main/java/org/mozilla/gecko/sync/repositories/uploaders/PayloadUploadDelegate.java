package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
uploaders
;
import
org
.
json
.
simple
.
JSONArray
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
HTTPFailureException
;
import
org
.
mozilla
.
gecko
.
sync
.
NonArrayJSONException
;
import
org
.
mozilla
.
gecko
.
sync
.
NonObjectJSONException
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
AuthHeaderProvider
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncResponse
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageRequestDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageResponse
;
import
java
.
util
.
ArrayList
;
class
PayloadUploadDelegate
implements
SyncStorageRequestDelegate
{
private
static
final
String
LOG_TAG
=
"
PayloadUploadDelegate
"
;
private
static
final
String
KEY_BATCH
=
"
batch
"
;
private
final
AuthHeaderProvider
headerProvider
;
private
final
PayloadDispatcher
dispatcher
;
private
ArrayList
<
String
>
postedRecordGuids
;
private
final
boolean
isCommit
;
private
final
boolean
isLastPayload
;
PayloadUploadDelegate
(
AuthHeaderProvider
headerProvider
PayloadDispatcher
dispatcher
ArrayList
<
String
>
postedRecordGuids
boolean
isCommit
boolean
isLastPayload
)
{
this
.
headerProvider
=
headerProvider
;
this
.
dispatcher
=
dispatcher
;
this
.
postedRecordGuids
=
postedRecordGuids
;
this
.
isCommit
=
isCommit
;
this
.
isLastPayload
=
isLastPayload
;
}
Override
public
AuthHeaderProvider
getAuthHeaderProvider
(
)
{
return
headerProvider
;
}
Override
public
String
ifUnmodifiedSince
(
)
{
final
Long
lastModified
=
dispatcher
.
batchWhiteboard
.
getLastModified
(
)
;
if
(
lastModified
=
=
null
)
{
return
null
;
}
else
{
return
Utils
.
millisecondsToDecimalSecondsString
(
lastModified
)
;
}
}
Override
public
void
handleRequestSuccess
(
final
SyncStorageResponse
response
)
{
if
(
response
.
getStatusCode
(
)
!
=
200
&
&
response
.
getStatusCode
(
)
!
=
202
)
{
handleRequestError
(
new
IllegalStateException
(
"
handleRequestSuccess
received
a
non
-
200
/
202
response
:
"
+
response
.
getStatusCode
(
)
)
)
;
return
;
}
if
(
!
response
.
httpResponse
(
)
.
containsHeader
(
SyncResponse
.
X_LAST_MODIFIED
)
)
{
handleRequestError
(
new
IllegalStateException
(
"
Response
did
not
have
a
Last
-
Modified
header
"
)
)
;
return
;
}
final
ExtendedJSONObject
body
;
try
{
body
=
response
.
jsonObjectBody
(
)
;
}
catch
(
Exception
e
)
{
Logger
.
error
(
LOG_TAG
"
Got
exception
parsing
POST
success
body
.
"
e
)
;
this
.
handleRequestError
(
e
)
;
return
;
}
if
(
response
.
getStatusCode
(
)
=
=
200
&
&
dispatcher
.
batchWhiteboard
.
getToken
(
)
!
=
null
)
{
if
(
dispatcher
.
batchWhiteboard
.
getInBatchingMode
(
)
&
&
!
isCommit
)
{
handleRequestError
(
new
IllegalStateException
(
"
Got
200
OK
in
batching
mode
but
this
was
not
a
commit
payload
"
)
)
;
return
;
}
}
else
if
(
response
.
getStatusCode
(
)
=
=
202
)
{
if
(
!
body
.
containsKey
(
KEY_BATCH
)
)
{
handleRequestError
(
new
IllegalStateException
(
"
Batch
response
did
not
have
a
batch
ID
"
)
)
;
return
;
}
}
if
(
dispatcher
.
batchWhiteboard
.
getInBatchingMode
(
)
=
=
null
)
{
dispatcher
.
setInBatchingMode
(
body
.
containsKey
(
KEY_BATCH
)
)
;
}
try
{
dispatcher
.
batchWhiteboard
.
setToken
(
body
.
getString
(
KEY_BATCH
)
isCommit
)
;
}
catch
(
BatchingUploader
.
BatchingUploaderException
e
)
{
handleRequestError
(
e
)
;
return
;
}
try
{
dispatcher
.
batchWhiteboard
.
setLastModified
(
response
.
normalizedTimestampForHeader
(
SyncResponse
.
X_LAST_MODIFIED
)
isCommit
|
|
!
dispatcher
.
batchWhiteboard
.
getInBatchingMode
(
)
)
;
}
catch
(
BatchingUploader
.
BatchingUploaderException
e
)
{
handleRequestError
(
e
)
;
return
;
}
JSONArray
success
;
try
{
success
=
body
.
getArray
(
"
success
"
)
;
}
catch
(
NonArrayJSONException
e
)
{
handleRequestError
(
e
)
;
return
;
}
if
(
success
!
=
null
&
&
!
success
.
isEmpty
(
)
)
{
Logger
.
trace
(
LOG_TAG
"
Successful
records
:
"
+
success
.
toString
(
)
)
;
for
(
Object
o
:
success
)
{
try
{
dispatcher
.
batchWhiteboard
.
recordSucceeded
(
(
String
)
o
)
;
}
catch
(
ClassCastException
e
)
{
Logger
.
error
(
LOG_TAG
"
Got
exception
parsing
POST
success
guid
.
"
e
)
;
}
}
}
success
=
null
;
ExtendedJSONObject
failed
;
try
{
failed
=
body
.
getObject
(
"
failed
"
)
;
}
catch
(
NonObjectJSONException
e
)
{
handleRequestError
(
e
)
;
return
;
}
if
(
failed
!
=
null
&
&
!
failed
.
object
.
isEmpty
(
)
)
{
Logger
.
debug
(
LOG_TAG
"
Failed
records
:
"
+
failed
.
object
.
toString
(
)
)
;
for
(
String
guid
:
failed
.
keySet
(
)
)
{
dispatcher
.
recordFailed
(
guid
)
;
}
}
failed
=
null
;
dispatcher
.
payloadSucceeded
(
response
dispatcher
.
batchWhiteboard
.
getSuccessRecordGuids
(
)
isCommit
isLastPayload
)
;
if
(
isCommit
&
&
!
isLastPayload
)
{
dispatcher
.
prepareForNextBatch
(
)
;
}
}
Override
public
void
handleRequestFailure
(
final
SyncStorageResponse
response
)
{
if
(
response
.
getStatusCode
(
)
=
=
412
)
{
dispatcher
.
concurrentModificationDetected
(
)
;
}
else
{
this
.
handleRequestError
(
new
HTTPFailureException
(
response
)
)
;
}
}
Override
public
void
handleRequestError
(
Exception
e
)
{
for
(
String
guid
:
postedRecordGuids
)
{
dispatcher
.
recordFailed
(
e
guid
)
;
}
postedRecordGuids
=
null
;
if
(
isLastPayload
)
{
dispatcher
.
lastPayloadFailed
(
)
;
}
}
}
