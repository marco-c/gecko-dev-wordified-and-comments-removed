package
org
.
mozilla
.
gecko
.
sync
;
import
android
.
content
.
ComponentName
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
net
.
Uri
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
v4
.
app
.
JobIntentService
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
json
.
simple
.
JSONArray
;
import
org
.
json
.
simple
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
JobIdsConstants
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
fxa
.
authenticator
.
AndroidFxAccount
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
.
ClientsDatabaseAccessor
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
ClientRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
telemetry
.
TelemetryEventCollector
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
public
class
CommandProcessor
{
private
static
final
String
LOG_TAG
=
"
Command
"
;
private
static
final
AtomicInteger
currentId
=
new
AtomicInteger
(
)
;
protected
ConcurrentHashMap
<
String
CommandRunner
>
commands
=
new
ConcurrentHashMap
<
String
CommandRunner
>
(
)
;
private
final
static
CommandProcessor
processor
=
new
CommandProcessor
(
)
;
public
static
CommandProcessor
getProcessor
(
)
{
return
processor
;
}
public
static
class
Command
{
public
final
String
commandType
;
public
final
JSONArray
args
;
private
List
<
String
>
argsList
;
Nullable
public
String
flowID
;
public
Command
(
String
commandType
JSONArray
args
Nullable
String
flowID
)
{
this
.
commandType
=
commandType
;
this
.
args
=
args
;
this
.
flowID
=
flowID
;
}
public
synchronized
List
<
String
>
getArgsList
(
)
{
if
(
argsList
=
=
null
)
{
ArrayList
<
String
>
argsList
=
new
ArrayList
<
String
>
(
args
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
args
.
size
(
)
;
i
+
+
)
{
final
Object
arg
=
args
.
get
(
i
)
;
if
(
arg
=
=
null
)
{
argsList
.
add
(
null
)
;
continue
;
}
argsList
.
add
(
arg
.
toString
(
)
)
;
}
this
.
argsList
=
argsList
;
}
return
this
.
argsList
;
}
SuppressWarnings
(
"
unchecked
"
)
public
JSONObject
asJSONObject
(
)
{
JSONObject
out
=
new
JSONObject
(
)
;
out
.
put
(
"
command
"
this
.
commandType
)
;
out
.
put
(
"
args
"
this
.
args
)
;
if
(
this
.
flowID
!
=
null
)
{
out
.
put
(
"
flowID
"
this
.
flowID
)
;
}
return
out
;
}
}
public
void
registerCommand
(
String
commandType
CommandRunner
command
)
{
commands
.
put
(
commandType
command
)
;
}
public
void
processCommand
(
final
GlobalSession
session
ExtendedJSONObject
unparsedCommand
)
{
Command
command
=
parseCommand
(
unparsedCommand
)
;
if
(
command
=
=
null
)
{
Logger
.
debug
(
LOG_TAG
"
Invalid
command
:
"
+
unparsedCommand
+
"
will
not
be
processed
.
"
)
;
return
;
}
CommandRunner
executableCommand
=
commands
.
get
(
command
.
commandType
)
;
if
(
executableCommand
=
=
null
)
{
Logger
.
debug
(
LOG_TAG
"
Command
\
"
"
+
command
.
commandType
+
"
\
"
not
registered
and
will
not
be
processed
.
"
)
;
return
;
}
try
{
recordProcessCommandTelemetryEvent
(
session
.
getContext
(
)
command
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOG_TAG
"
Could
not
record
telemetry
event
.
"
)
;
}
executableCommand
.
executeCommand
(
session
command
.
getArgsList
(
)
)
;
}
private
static
void
recordProcessCommandTelemetryEvent
(
Context
context
Command
command
)
{
final
HashMap
<
String
String
>
extra
=
new
HashMap
<
>
(
)
;
if
(
command
.
flowID
!
=
null
)
{
extra
.
put
(
"
flowID
"
command
.
flowID
)
;
}
TelemetryEventCollector
.
recordEvent
(
context
"
processcommand
"
command
.
commandType
null
extra
)
;
}
protected
static
Command
parseCommand
(
ExtendedJSONObject
unparsedCommand
)
{
String
type
=
(
String
)
unparsedCommand
.
get
(
"
command
"
)
;
if
(
type
=
=
null
)
{
return
null
;
}
try
{
JSONArray
unparsedArgs
=
unparsedCommand
.
getArray
(
"
args
"
)
;
if
(
unparsedArgs
=
=
null
)
{
return
null
;
}
final
String
flowID
=
unparsedCommand
.
getString
(
"
flowID
"
)
;
return
new
Command
(
type
unparsedArgs
flowID
)
;
}
catch
(
NonArrayJSONException
e
)
{
Logger
.
debug
(
LOG_TAG
"
Unable
to
parse
args
array
.
Invalid
command
"
)
;
return
null
;
}
}
SuppressWarnings
(
"
unchecked
"
)
public
void
sendURIToClientForDisplay
(
String
uri
String
clientID
String
title
String
sender
Context
context
)
{
Logger
.
info
(
LOG_TAG
"
Sending
URI
to
client
"
+
clientID
+
"
.
"
)
;
if
(
Logger
.
LOG_PERSONAL_INFORMATION
)
{
Logger
.
pii
(
LOG_TAG
"
URI
is
"
+
uri
+
"
;
title
is
'
"
+
title
+
"
'
.
"
)
;
}
final
JSONArray
args
=
new
JSONArray
(
)
;
args
.
add
(
uri
)
;
args
.
add
(
sender
)
;
args
.
add
(
title
)
;
final
String
flowID
=
Utils
.
generateGuid
(
)
;
final
Command
displayURICommand
=
new
Command
(
"
displayURI
"
args
flowID
)
;
this
.
sendCommand
(
clientID
displayURICommand
context
)
;
}
public
void
sendCommand
(
String
clientID
Command
command
Context
context
)
{
Logger
.
debug
(
LOG_TAG
"
In
sendCommand
.
"
)
;
CommandRunner
commandData
=
commands
.
get
(
command
.
commandType
)
;
if
(
commandData
=
=
null
)
{
Logger
.
error
(
LOG_TAG
"
Unknown
command
to
send
:
"
+
command
)
;
return
;
}
if
(
!
commandData
.
argumentsAreValid
(
command
.
getArgsList
(
)
)
)
{
Logger
.
error
(
LOG_TAG
"
Expected
"
+
commandData
.
argCount
+
"
args
for
'
"
+
command
+
"
'
but
got
"
+
command
.
args
)
;
return
;
}
if
(
clientID
!
=
null
)
{
this
.
sendCommandToClient
(
clientID
command
context
)
;
return
;
}
ClientsDatabaseAccessor
db
=
new
ClientsDatabaseAccessor
(
context
)
;
try
{
Map
<
String
ClientRecord
>
clientMap
=
db
.
fetchAllClients
(
)
;
for
(
ClientRecord
client
:
clientMap
.
values
(
)
)
{
this
.
sendCommandToClient
(
client
.
guid
command
context
)
;
}
}
catch
(
NullCursorException
e
)
{
Logger
.
error
(
LOG_TAG
"
NullCursorException
when
fetching
all
GUIDs
"
)
;
}
finally
{
db
.
close
(
)
;
}
}
private
static
void
recordSendCommandTelemetryEvent
(
Context
context
Command
command
String
clientID
)
{
final
AndroidFxAccount
fxAccount
=
AndroidFxAccount
.
fromContext
(
context
)
;
if
(
fxAccount
=
=
null
)
{
Log
.
e
(
LOG_TAG
"
Can
'
t
record
telemetry
event
:
FxAccount
doesn
'
t
exist
.
"
)
;
return
;
}
final
String
hashedFxAUID
=
fxAccount
.
getCachedHashedFxAUID
(
)
;
if
(
TextUtils
.
isEmpty
(
hashedFxAUID
)
)
{
Log
.
e
(
LOG_TAG
"
Can
'
t
record
telemetry
event
:
The
hashed
FxA
UID
is
empty
"
)
;
return
;
}
HashMap
<
String
String
>
extra
=
new
HashMap
<
>
(
)
;
if
(
!
TextUtils
.
isEmpty
(
command
.
flowID
)
)
{
extra
.
put
(
"
flowID
"
command
.
flowID
)
;
}
try
{
extra
.
put
(
"
deviceID
"
Utils
.
byte2Hex
(
Utils
.
sha256
(
clientID
.
concat
(
hashedFxAUID
)
.
getBytes
(
StringUtils
.
UTF_8
)
)
)
)
;
}
catch
(
NoSuchAlgorithmException
e
)
{
Log
.
e
(
LOG_TAG
"
SHA
-
256
is
not
supported
"
e
)
;
}
TelemetryEventCollector
.
recordEvent
(
context
"
sendcommand
"
command
.
commandType
null
extra
)
;
}
protected
void
sendCommandToClient
(
String
clientID
Command
command
Context
context
)
{
Logger
.
info
(
LOG_TAG
"
Sending
"
+
command
.
commandType
+
"
to
"
+
clientID
)
;
try
{
recordSendCommandTelemetryEvent
(
context
command
clientID
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOG_TAG
"
Could
not
record
telemetry
event
.
"
)
;
}
ClientsDatabaseAccessor
db
=
new
ClientsDatabaseAccessor
(
context
)
;
try
{
db
.
store
(
clientID
command
)
;
}
catch
(
NullCursorException
e
)
{
Logger
.
error
(
LOG_TAG
"
NullCursorException
:
Unable
to
send
command
.
"
)
;
}
finally
{
db
.
close
(
)
;
}
}
public
static
void
displayURI
(
final
List
<
String
>
args
final
Context
context
)
{
final
String
uri
=
args
.
get
(
0
)
;
final
String
clientId
=
args
.
get
(
1
)
;
Logger
.
pii
(
LOG_TAG
"
Received
a
URI
for
display
:
"
+
uri
+
"
from
"
+
clientId
)
;
if
(
uri
=
=
null
)
{
Logger
.
pii
(
LOG_TAG
"
URI
is
null
ignoring
"
)
;
return
;
}
String
title
=
null
;
if
(
args
.
size
(
)
=
=
3
)
{
title
=
args
.
get
(
2
)
;
}
final
Intent
sendTabNotificationIntent
=
new
Intent
(
)
;
sendTabNotificationIntent
.
setData
(
Uri
.
parse
(
uri
)
)
;
sendTabNotificationIntent
.
putExtra
(
Intent
.
EXTRA_TITLE
title
)
;
sendTabNotificationIntent
.
putExtra
(
BrowserContract
.
EXTRA_CLIENT_GUID
clientId
)
;
final
ComponentName
componentName
=
new
ComponentName
(
context
BrowserContract
.
TAB_RECEIVED_SERVICE_CLASS_NAME
)
;
final
int
tabReceivedServiceJobId
=
JobIdsConstants
.
getIdForTabReceivedJob
(
)
;
JobIntentService
.
enqueueWork
(
context
componentName
tabReceivedServiceJobId
sendTabNotificationIntent
)
;
}
}
