package
org
.
mozilla
.
gecko
.
sync
.
middleware
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
gecko
.
sync
.
middleware
.
storage
.
BufferStorage
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InactiveSessionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NoStoreDelegateException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
java
.
util
.
Collection
;
import
java
.
util
.
concurrent
.
ExecutorService
;
import
java
.
util
.
concurrent
.
Executors
;
class
BufferingMiddlewareRepositorySession
extends
MiddlewareRepositorySession
{
private
final
BufferStorage
bufferStorage
;
private
final
long
syncDeadlineMillis
;
private
ExecutorService
storeDelegateExecutor
=
Executors
.
newSingleThreadExecutor
(
)
;
private
volatile
boolean
storeMarkedIncomplete
=
false
;
BufferingMiddlewareRepositorySession
(
RepositorySession
repositorySession
MiddlewareRepository
repository
long
syncDeadlineMillis
BufferStorage
bufferStorage
)
{
super
(
repositorySession
repository
)
;
this
.
syncDeadlineMillis
=
syncDeadlineMillis
;
this
.
bufferStorage
=
bufferStorage
;
}
Override
public
void
fetchSince
(
long
timestamp
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
inner
.
fetchSince
(
timestamp
delegate
)
;
}
Override
public
void
fetch
(
String
[
]
guids
RepositorySessionFetchRecordsDelegate
delegate
)
throws
InactiveSessionException
{
this
.
inner
.
fetch
(
guids
delegate
)
;
}
Override
public
void
fetchAll
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
inner
.
fetchAll
(
delegate
)
;
}
Override
public
void
performCleanup
(
)
{
bufferStorage
.
clear
(
)
;
}
Override
public
void
store
(
Record
record
)
throws
NoStoreDelegateException
{
bufferStorage
.
addOrReplace
(
record
)
;
}
Override
public
void
storeIncomplete
(
)
{
storeMarkedIncomplete
=
true
;
}
Override
public
void
storeDone
(
)
{
storeDone
(
System
.
currentTimeMillis
(
)
)
;
}
Override
public
void
storeFlush
(
)
{
bufferStorage
.
flush
(
)
;
}
Override
public
void
storeDone
(
final
long
end
)
{
doStoreDonePrepare
(
)
;
if
(
storeMarkedIncomplete
|
|
!
mayProceedToMergeBuffer
(
)
)
{
super
.
abort
(
)
;
storeDelegate
.
deferredStoreDelegate
(
storeDelegateExecutor
)
.
onStoreCompleted
(
end
)
;
return
;
}
doStoreDone
(
end
)
;
}
VisibleForTesting
public
void
doStoreDonePrepare
(
)
{
bufferStorage
.
flush
(
)
;
}
VisibleForTesting
public
void
doStoreDone
(
final
long
end
)
{
final
Collection
<
Record
>
buffer
=
bufferStorage
.
all
(
)
;
if
(
buffer
.
isEmpty
(
)
)
{
super
.
storeDone
(
end
)
;
return
;
}
try
{
for
(
Record
record
:
buffer
)
{
this
.
inner
.
store
(
record
)
;
}
}
catch
(
NoStoreDelegateException
e
)
{
}
super
.
storeDone
(
end
)
;
}
Override
public
void
sourceFailed
(
Exception
e
)
{
bufferStorage
.
flush
(
)
;
super
.
sourceFailed
(
e
)
;
}
Override
public
void
abort
(
)
{
bufferStorage
.
flush
(
)
;
super
.
abort
(
)
;
}
Override
public
void
setStoreDelegate
(
RepositorySessionStoreDelegate
delegate
)
{
inner
.
setStoreDelegate
(
delegate
)
;
this
.
storeDelegate
=
delegate
;
}
Override
public
long
getHighWaterMarkTimestamp
(
)
{
return
bufferStorage
.
latestModifiedTimestamp
(
)
;
}
private
boolean
mayProceedToMergeBuffer
(
)
{
if
(
!
bufferStorage
.
isPersistent
(
)
)
{
return
true
;
}
final
long
timeLeftMillis
=
syncDeadlineMillis
-
SystemClock
.
elapsedRealtime
(
)
;
return
timeLeftMillis
>
1000
*
60
*
2
;
}
}
