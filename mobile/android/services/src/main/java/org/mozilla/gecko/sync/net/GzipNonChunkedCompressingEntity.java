package
org
.
mozilla
.
gecko
.
sync
.
net
;
import
ch
.
boye
.
httpclientandroidlib
.
HttpEntity
;
import
ch
.
boye
.
httpclientandroidlib
.
client
.
entity
.
GzipCompressingEntity
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
public
class
GzipNonChunkedCompressingEntity
extends
GzipCompressingEntity
{
final
int
MAX_BUFFER_SIZE_BYTES
=
10
*
1000
*
1000
;
private
byte
[
]
gzippedContent
;
public
GzipNonChunkedCompressingEntity
(
final
HttpEntity
entity
)
{
super
(
entity
)
;
}
Override
public
long
getContentLength
(
)
{
try
{
initBuffer
(
)
;
}
catch
(
final
IOException
e
)
{
return
-
1
;
}
return
gzippedContent
.
length
;
}
Override
public
boolean
isChunked
(
)
{
return
false
;
}
Override
public
InputStream
getContent
(
)
throws
IOException
{
initBuffer
(
)
;
return
new
ByteArrayInputStream
(
gzippedContent
)
;
}
Override
public
void
writeTo
(
final
OutputStream
outstream
)
throws
IOException
{
initBuffer
(
)
;
outstream
.
write
(
gzippedContent
)
;
}
private
void
initBuffer
(
)
throws
IOException
{
if
(
gzippedContent
!
=
null
)
{
return
;
}
final
long
unzippedContentLength
=
wrappedEntity
.
getContentLength
(
)
;
if
(
unzippedContentLength
>
MAX_BUFFER_SIZE_BYTES
)
{
throw
new
IOException
(
"
Wrapped
entity
content
length
"
+
unzippedContentLength
+
"
bytes
exceeds
max
:
"
+
MAX_BUFFER_SIZE_BYTES
)
;
}
final
ByteArrayOutputStream
s
=
new
ByteArrayOutputStream
(
(
int
)
unzippedContentLength
)
;
try
{
super
.
writeTo
(
s
)
;
}
finally
{
s
.
close
(
)
;
}
gzippedContent
=
s
.
toByteArray
(
)
;
}
}
