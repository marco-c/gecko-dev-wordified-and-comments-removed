package
org
.
mozilla
.
gecko
.
sync
.
repositories
;
import
android
.
net
.
Uri
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionGuidsSinceDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionWipeDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
downloaders
.
BatchingDownloader
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
downloaders
.
BatchingDownloaderController
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
uploaders
.
BatchingUploader
;
public
class
Server15RepositorySession
extends
RepositorySession
{
public
static
final
String
LOG_TAG
=
"
Server15RepositorySession
"
;
protected
final
Server15Repository
serverRepository
;
private
BatchingUploader
uploader
;
private
final
BatchingDownloader
downloader
;
public
Server15RepositorySession
(
Repository
repository
)
{
super
(
repository
)
;
this
.
serverRepository
=
(
Server15Repository
)
repository
;
this
.
downloader
=
new
BatchingDownloader
(
this
.
serverRepository
.
authHeaderProvider
Uri
.
parse
(
this
.
serverRepository
.
collectionURI
(
)
.
toString
(
)
)
this
.
serverRepository
.
getSyncDeadline
(
)
this
.
serverRepository
.
getAllowMultipleBatches
(
)
this
.
serverRepository
.
getAllowHighWaterMark
(
)
this
.
serverRepository
.
stateProvider
this
)
;
}
Override
public
void
setStoreDelegate
(
RepositorySessionStoreDelegate
storeDelegate
)
{
super
.
setStoreDelegate
(
storeDelegate
)
;
this
.
uploader
=
new
BatchingUploader
(
this
storeWorkQueue
storeDelegate
Uri
.
parse
(
serverRepository
.
collectionURI
.
toString
(
)
)
serverRepository
.
getCollectionLastModified
(
)
serverRepository
.
getInfoConfiguration
(
)
serverRepository
.
authHeaderProvider
)
;
}
Override
public
void
guidsSince
(
long
timestamp
RepositorySessionGuidsSinceDelegate
delegate
)
{
}
Override
public
void
fetchSince
(
long
sinceTimestamp
RepositorySessionFetchRecordsDelegate
delegate
)
{
BatchingDownloaderController
.
resumeFetchSinceIfPossible
(
this
.
downloader
this
.
serverRepository
.
stateProvider
delegate
sinceTimestamp
serverRepository
.
getBatchLimit
(
)
serverRepository
.
getSortOrder
(
)
)
;
}
Override
public
void
fetchAll
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
fetchSince
(
-
1
delegate
)
;
}
Override
public
void
fetch
(
String
[
]
guids
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
downloader
.
fetch
(
guids
delegate
)
;
}
Override
public
void
wipe
(
RepositorySessionWipeDelegate
delegate
)
{
if
(
!
isActive
(
)
)
{
delegate
.
onWipeFailed
(
new
InactiveSessionException
(
)
)
;
return
;
}
}
Override
public
void
store
(
Record
record
)
throws
NoStoreDelegateException
{
if
(
storeDelegate
=
=
null
)
{
throw
new
NoStoreDelegateException
(
)
;
}
if
(
uploader
=
=
null
)
{
throw
new
IllegalStateException
(
"
Uploader
haven
'
t
been
initialized
"
)
;
}
uploader
.
process
(
record
)
;
}
Override
public
void
storeDone
(
)
{
Logger
.
debug
(
LOG_TAG
"
storeDone
(
)
.
"
)
;
if
(
uploader
=
=
null
)
{
throw
new
IllegalStateException
(
"
Uploader
haven
'
t
been
initialized
"
)
;
}
uploader
.
noMoreRecordsToUpload
(
)
;
}
Override
public
long
getLastSyncTimestamp
(
)
{
if
(
!
serverRepository
.
getAllowHighWaterMark
(
)
|
|
!
serverRepository
.
getSortOrder
(
)
.
equals
(
"
oldest
"
)
)
{
return
super
.
getLastSyncTimestamp
(
)
;
}
final
Long
highWaterMark
=
serverRepository
.
stateProvider
.
getLong
(
RepositoryStateProvider
.
KEY_HIGH_WATER_MARK
)
;
if
(
highWaterMark
=
=
null
|
|
super
.
getLastSyncTimestamp
(
)
>
highWaterMark
)
{
return
super
.
getLastSyncTimestamp
(
)
;
}
return
highWaterMark
;
}
Override
public
boolean
dataAvailable
(
)
{
return
serverRepository
.
updateNeeded
(
getLastSyncTimestamp
(
)
)
;
}
}
