package
org
.
mozilla
.
gecko
.
sync
.
repositories
;
import
android
.
content
.
Context
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Bundle
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
java
.
util
.
concurrent
.
ExecutorService
;
public
class
VersioningDelegateHelper
{
private
final
Context
context
;
private
final
ConcurrentHashMap
<
String
Integer
>
localVersionsOfGuids
=
new
ConcurrentHashMap
<
>
(
)
;
private
final
Uri
repositoryContentUri
;
public
VersioningDelegateHelper
(
Context
context
Uri
repositoryContentUri
)
{
this
.
context
=
context
;
this
.
repositoryContentUri
=
repositoryContentUri
;
}
public
RepositorySessionFetchRecordsDelegate
getFetchDelegate
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
return
new
VersionedFetchDelegate
(
delegate
)
;
}
public
RepositorySessionStoreDelegate
getStoreDelegate
(
RepositorySessionStoreDelegate
delegate
)
{
return
new
VersionedStoreDelegate
(
delegate
)
;
}
public
void
persistSyncVersions
(
)
{
final
Bundle
data
=
new
Bundle
(
)
;
data
.
putSerializable
(
BrowserContract
.
METHOD_PARAM_DATA
this
.
localVersionsOfGuids
)
;
final
Bundle
result
=
context
.
getContentResolver
(
)
.
call
(
repositoryContentUri
BrowserContract
.
METHOD_UPDATE_SYNC_VERSIONS
repositoryContentUri
.
toString
(
)
data
)
;
if
(
result
=
=
null
)
{
throw
new
IllegalStateException
(
"
Expected
to
receive
a
result
after
decrementing
change
counters
"
)
;
}
int
changed
=
(
int
)
result
.
getSerializable
(
BrowserContract
.
METHOD_RESULT
)
;
if
(
changed
!
=
this
.
localVersionsOfGuids
.
size
(
)
)
{
throw
new
IllegalStateException
(
"
Decremented
incorrect
number
of
change
counters
"
)
;
}
}
private
class
VersionedFetchDelegate
implements
RepositorySessionFetchRecordsDelegate
{
private
final
RepositorySessionFetchRecordsDelegate
inner
;
VersionedFetchDelegate
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
inner
=
delegate
;
}
public
void
onFetchFailed
(
Exception
ex
)
{
this
.
inner
.
onFetchFailed
(
ex
)
;
}
Override
public
void
onFetchedRecord
(
Record
record
)
{
if
(
record
.
localVersion
=
=
null
)
{
throw
new
IllegalStateException
(
"
Encountered
an
unversioned
record
during
versioned
sync
.
"
)
;
}
localVersionsOfGuids
.
put
(
record
.
guid
record
.
localVersion
)
;
this
.
inner
.
onFetchedRecord
(
record
)
;
}
Override
public
void
onFetchCompleted
(
long
fetchEnd
)
{
this
.
inner
.
onFetchCompleted
(
fetchEnd
)
;
}
Override
public
void
onBatchCompleted
(
)
{
this
.
inner
.
onBatchCompleted
(
)
;
}
Override
public
RepositorySessionFetchRecordsDelegate
deferredFetchDelegate
(
ExecutorService
executor
)
{
return
this
.
inner
.
deferredFetchDelegate
(
executor
)
;
}
}
private
class
VersionedStoreDelegate
implements
RepositorySessionStoreDelegate
{
private
final
RepositorySessionStoreDelegate
inner
;
VersionedStoreDelegate
(
RepositorySessionStoreDelegate
delegate
)
{
this
.
inner
=
delegate
;
}
Override
public
void
onRecordStoreFailed
(
Exception
ex
String
recordGuid
)
{
inner
.
onRecordStoreFailed
(
ex
recordGuid
)
;
}
Override
public
void
onRecordStoreReconciled
(
String
guid
Integer
newVersion
)
{
if
(
newVersion
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Received
null
localVersion
after
reconciling
a
versioned
record
.
"
)
;
}
localVersionsOfGuids
.
put
(
guid
newVersion
)
;
inner
.
onRecordStoreReconciled
(
guid
null
)
;
}
Override
public
void
onRecordStoreSucceeded
(
String
guid
)
{
inner
.
onRecordStoreSucceeded
(
guid
)
;
}
Override
public
void
onStoreCompleted
(
long
storeEnd
)
{
inner
.
onStoreCompleted
(
storeEnd
)
;
}
Override
public
void
onStoreFailed
(
Exception
e
)
{
inner
.
onStoreFailed
(
e
)
;
}
Override
public
RepositorySessionStoreDelegate
deferredStoreDelegate
(
ExecutorService
executor
)
{
return
inner
.
deferredStoreDelegate
(
executor
)
;
}
}
}
