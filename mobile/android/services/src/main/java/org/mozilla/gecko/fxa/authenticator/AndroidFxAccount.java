package
org
.
mozilla
.
gecko
.
fxa
.
authenticator
;
import
android
.
accounts
.
Account
;
import
android
.
accounts
.
AccountManager
;
import
android
.
accounts
.
AccountManagerCallback
;
import
android
.
accounts
.
AccountManagerFuture
;
import
android
.
accounts
.
AuthenticatorException
;
import
android
.
accounts
.
OperationCanceledException
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
PeriodicSync
;
import
android
.
content
.
SharedPreferences
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Handler
;
import
android
.
os
.
ResultReceiver
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
android
.
support
.
v4
.
content
.
LocalBroadcastManager
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
GlobalConstants
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
background
.
fxa
.
FxAccountUtils
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
fxa
.
FirefoxAccounts
;
import
org
.
mozilla
.
gecko
.
fxa
.
FxAccountConstants
;
import
org
.
mozilla
.
gecko
.
fxa
.
EnvironmentUtils
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
State
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
State
.
StateLabel
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
StateFactory
;
import
org
.
mozilla
.
gecko
.
fxa
.
sync
.
FxAccountProfileService
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
NonObjectJSONException
;
import
org
.
mozilla
.
gecko
.
sync
.
ThreadPool
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
sync
.
setup
.
Constants
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
io
.
IOException
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
net
.
URISyntaxException
;
import
java
.
security
.
GeneralSecurityException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
Semaphore
;
public
class
AndroidFxAccount
{
protected
static
final
String
LOG_TAG
=
AndroidFxAccount
.
class
.
getSimpleName
(
)
;
private
static
final
int
CURRENT_SYNC_PREFS_VERSION
=
1
;
private
static
final
int
CURRENT_RL_PREFS_VERSION
=
1
;
public
static
final
int
CURRENT_ACCOUNT_VERSION
=
3
;
private
static
final
String
ACCOUNT_KEY_ACCOUNT_VERSION
=
"
version
"
;
private
static
final
String
ACCOUNT_KEY_PROFILE
=
"
profile
"
;
private
static
final
String
ACCOUNT_KEY_IDP_SERVER
=
"
idpServerURI
"
;
private
static
final
String
ACCOUNT_KEY_PROFILE_SERVER
=
"
profileServerURI
"
;
private
static
final
String
ACCOUNT_KEY_UID
=
"
uid
"
;
static
final
String
ACCOUNT_KEY_RENAME_IN_PROGRESS
=
"
accountBeingRenamed
"
;
static
final
String
ACCOUNT_VALUE_RENAME_IN_PROGRESS
=
"
true
"
;
private
static
final
String
ACCOUNT_KEY_TOKEN_SERVER
=
"
tokenServerURI
"
;
private
static
final
String
ACCOUNT_KEY_DESCRIPTOR
=
"
descriptor
"
;
public
static
final
String
ACCOUNT_KEY_FIRST_RUN_SCOPE
=
"
firstRunScope
"
;
private
static
final
int
CURRENT_BUNDLE_VERSION
=
2
;
private
static
final
String
BUNDLE_KEY_BUNDLE_VERSION
=
"
version
"
;
static
final
String
BUNDLE_KEY_STATE_LABEL
=
"
stateLabel
"
;
static
final
String
BUNDLE_KEY_STATE
=
"
state
"
;
private
static
final
String
BUNDLE_KEY_PROFILE_JSON
=
"
profile
"
;
private
static
final
String
ACCOUNT_KEY_DEVICE_ID
=
"
deviceId
"
;
private
static
final
String
ACCOUNT_KEY_DEVICE_REGISTRATION_VERSION
=
"
deviceRegistrationVersion
"
;
private
static
final
String
ACCOUNT_KEY_DEVICE_REGISTRATION_TIMESTAMP
=
"
deviceRegistrationTimestamp
"
;
private
static
final
String
ACCOUNT_KEY_DEVICE_PUSH_REGISTRATION_ERROR
=
"
devicePushRegistrationError
"
;
private
static
final
String
ACCOUNT_KEY_DEVICE_PUSH_REGISTRATION_ERROR_TIME
=
"
devicePushRegistrationErrorTime
"
;
private
static
final
String
ACCOUNT_KEY_HASHED_FXA_UID
=
"
hashedFxAUID
"
;
private
static
final
String
PROFILE_OAUTH_TOKEN_TYPE
=
"
oauth
:
:
profile
"
;
private
static
final
List
<
String
>
KNOWN_OAUTH_TOKEN_TYPES
;
static
{
final
List
<
String
>
list
=
new
ArrayList
<
>
(
)
;
list
.
add
(
PROFILE_OAUTH_TOKEN_TYPE
)
;
KNOWN_OAUTH_TOKEN_TYPES
=
Collections
.
unmodifiableList
(
list
)
;
}
public
static
final
Map
<
String
Boolean
>
DEFAULT_AUTHORITIES_TO_SYNC_AUTOMATICALLY_MAP
;
static
{
final
HashMap
<
String
Boolean
>
m
=
new
HashMap
<
String
Boolean
>
(
)
;
m
.
put
(
BrowserContract
.
AUTHORITY
true
)
;
DEFAULT_AUTHORITIES_TO_SYNC_AUTOMATICALLY_MAP
=
Collections
.
unmodifiableMap
(
m
)
;
}
private
static
final
List
<
String
>
ACCOUNT_KEY_TO_CARRY_OVER_ON_RENAME_SET
;
static
{
ArrayList
<
String
>
keysToCarryOver
=
new
ArrayList
<
>
(
6
)
;
keysToCarryOver
.
add
(
ACCOUNT_KEY_ACCOUNT_VERSION
)
;
keysToCarryOver
.
add
(
ACCOUNT_KEY_IDP_SERVER
)
;
keysToCarryOver
.
add
(
ACCOUNT_KEY_TOKEN_SERVER
)
;
keysToCarryOver
.
add
(
ACCOUNT_KEY_PROFILE_SERVER
)
;
keysToCarryOver
.
add
(
ACCOUNT_KEY_PROFILE
)
;
keysToCarryOver
.
add
(
ACCOUNT_KEY_DESCRIPTOR
)
;
ACCOUNT_KEY_TO_CARRY_OVER_ON_RENAME_SET
=
Collections
.
unmodifiableList
(
keysToCarryOver
)
;
}
private
static
final
String
PREF_KEY_LAST_SYNCED_TIMESTAMP
=
"
lastSyncedTimestamp
"
;
protected
final
Context
context
;
private
final
AccountManager
accountManager
;
private
static
final
long
neverSynced
=
-
1
;
protected
volatile
Account
account
;
public
AndroidFxAccount
(
Context
applicationContext
Account
account
)
{
this
.
context
=
applicationContext
;
this
.
account
=
account
;
this
.
accountManager
=
AccountManager
.
get
(
this
.
context
)
;
}
public
static
AndroidFxAccount
fromContext
(
Context
context
)
{
context
=
context
.
getApplicationContext
(
)
;
Account
account
=
FirefoxAccounts
.
getFirefoxAccount
(
context
)
;
if
(
account
=
=
null
)
{
return
null
;
}
return
new
AndroidFxAccount
(
context
account
)
;
}
Nullable
public
String
getUserData
(
String
key
)
{
return
accountManager
.
getUserData
(
account
key
)
;
}
public
Account
getAndroidAccount
(
)
{
return
this
.
account
;
}
private
int
getAccountVersion
(
)
{
String
v
=
accountManager
.
getUserData
(
account
ACCOUNT_KEY_ACCOUNT_VERSION
)
;
if
(
v
=
=
null
)
{
return
0
;
}
try
{
return
Integer
.
parseInt
(
v
10
)
;
}
catch
(
NumberFormatException
ex
)
{
return
0
;
}
}
private
String
getAccountUID
(
)
{
String
accountUID
=
accountManager
.
getUserData
(
account
ACCOUNT_KEY_UID
)
;
if
(
accountUID
!
=
null
)
{
return
accountUID
;
}
final
AccountPickler
.
UnpickleParams
profileParams
;
try
{
profileParams
=
AccountPickler
.
unpickleParams
(
context
FxAccountConstants
.
ACCOUNT_PICKLE_FILENAME
)
;
}
catch
(
Exception
e
)
{
throw
new
IllegalStateException
(
"
Couldn
'
t
process
account
profile
data
"
e
)
;
}
final
String
unpickledAccountUID
=
profileParams
.
getUID
(
)
;
if
(
unpickledAccountUID
=
=
null
)
{
throw
new
IllegalStateException
(
"
Unpickled
account
UID
is
null
"
)
;
}
accountManager
.
setUserData
(
account
ACCOUNT_KEY_UID
unpickledAccountUID
)
;
return
unpickledAccountUID
;
}
private
synchronized
void
persistBundle
(
ExtendedJSONObject
bundle
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DESCRIPTOR
bundle
.
toJSONString
(
)
)
;
}
synchronized
ExtendedJSONObject
unbundle
(
)
{
final
String
bundleString
=
accountManager
.
getUserData
(
account
ACCOUNT_KEY_DESCRIPTOR
)
;
final
int
version
=
getAccountVersion
(
)
;
if
(
version
<
CURRENT_ACCOUNT_VERSION
)
{
return
null
;
}
if
(
version
>
CURRENT_ACCOUNT_VERSION
)
{
throw
new
IllegalStateException
(
"
Invalid
account
bundle
version
.
Current
:
"
+
CURRENT_ACCOUNT_VERSION
+
"
bundle
version
:
"
+
version
)
;
}
if
(
bundleString
=
=
null
)
{
return
null
;
}
return
unbundleAccountV2
(
bundleString
)
;
}
private
String
getBundleData
(
String
key
)
{
ExtendedJSONObject
o
=
unbundle
(
)
;
if
(
o
=
=
null
)
{
return
null
;
}
return
o
.
getString
(
key
)
;
}
private
void
updateBundleValues
(
String
key
String
value
String
.
.
.
more
)
{
if
(
more
.
length
%
2
!
=
0
)
{
throw
new
IllegalArgumentException
(
"
more
must
be
a
list
of
key
value
pairs
"
)
;
}
ExtendedJSONObject
descriptor
=
unbundle
(
)
;
if
(
descriptor
=
=
null
)
{
return
;
}
descriptor
.
put
(
key
value
)
;
for
(
int
i
=
0
;
i
+
1
<
more
.
length
;
i
+
=
2
)
{
descriptor
.
put
(
more
[
i
]
more
[
i
+
1
]
)
;
}
persistBundle
(
descriptor
)
;
}
private
ExtendedJSONObject
unbundleAccountV1
(
String
bundle
)
{
ExtendedJSONObject
o
;
try
{
o
=
new
ExtendedJSONObject
(
bundle
)
;
}
catch
(
Exception
e
)
{
return
null
;
}
if
(
CURRENT_BUNDLE_VERSION
=
=
o
.
getIntegerSafely
(
BUNDLE_KEY_BUNDLE_VERSION
)
)
{
return
o
;
}
return
null
;
}
private
ExtendedJSONObject
unbundleAccountV2
(
String
bundle
)
{
return
unbundleAccountV1
(
bundle
)
;
}
public
String
getProfile
(
)
{
return
accountManager
.
getUserData
(
account
ACCOUNT_KEY_PROFILE
)
;
}
public
String
getAccountServerURI
(
)
{
return
accountManager
.
getUserData
(
account
ACCOUNT_KEY_IDP_SERVER
)
;
}
public
String
getTokenServerURI
(
)
{
return
accountManager
.
getUserData
(
account
ACCOUNT_KEY_TOKEN_SERVER
)
;
}
public
String
getProfileServerURI
(
)
{
String
profileURI
=
accountManager
.
getUserData
(
account
ACCOUNT_KEY_PROFILE_SERVER
)
;
if
(
profileURI
=
=
null
)
{
if
(
isStaging
(
)
)
{
return
FxAccountConstants
.
STAGE_PROFILE_SERVER_ENDPOINT
;
}
return
FxAccountConstants
.
DEFAULT_PROFILE_SERVER_ENDPOINT
;
}
return
profileURI
;
}
String
getOAuthServerURI
(
)
{
if
(
isStaging
(
)
)
{
return
FxAccountConstants
.
STAGE_OAUTH_SERVER_ENDPOINT
;
}
else
{
return
FxAccountConstants
.
DEFAULT_OAUTH_SERVER_ENDPOINT
;
}
}
private
boolean
isStaging
(
)
{
return
FxAccountConstants
.
STAGE_AUTH_SERVER_ENDPOINT
.
equals
(
getAccountServerURI
(
)
)
;
}
private
String
constructPrefsPath
(
NonNull
String
accountKey
String
product
long
version
String
extra
)
throws
GeneralSecurityException
UnsupportedEncodingException
{
String
profile
=
getProfile
(
)
;
if
(
profile
=
=
null
)
{
throw
new
IllegalStateException
(
"
Missing
profile
.
Cannot
fetch
prefs
.
"
)
;
}
if
(
accountKey
=
=
null
)
{
throw
new
IllegalStateException
(
"
Missing
accountKey
.
Cannot
fetch
prefs
.
"
)
;
}
final
String
fxaServerURI
=
getAccountServerURI
(
)
;
if
(
fxaServerURI
=
=
null
)
{
throw
new
IllegalStateException
(
"
No
account
server
URI
.
Cannot
fetch
prefs
.
"
)
;
}
final
String
serverURLThing
=
fxaServerURI
+
"
!
"
+
extra
;
return
Utils
.
getPrefsPath
(
product
accountKey
serverURLThing
profile
version
)
;
}
private
String
getSyncPrefsPath
(
final
String
accountKey
)
throws
GeneralSecurityException
UnsupportedEncodingException
{
final
String
tokenServerURI
=
getTokenServerURI
(
)
;
if
(
tokenServerURI
=
=
null
)
{
throw
new
IllegalStateException
(
"
No
token
server
URI
.
Cannot
fetch
prefs
.
"
)
;
}
final
String
product
=
GlobalConstants
.
BROWSER_INTENT_PACKAGE
+
"
.
fxa
"
;
final
long
version
=
CURRENT_SYNC_PREFS_VERSION
;
return
constructPrefsPath
(
accountKey
product
version
tokenServerURI
)
;
}
private
String
getReadingListPrefsPath
(
final
String
accountKey
)
throws
GeneralSecurityException
UnsupportedEncodingException
{
final
String
product
=
GlobalConstants
.
BROWSER_INTENT_PACKAGE
+
"
.
reading
"
;
final
long
version
=
CURRENT_RL_PREFS_VERSION
;
return
constructPrefsPath
(
accountKey
product
version
"
"
)
;
}
SuppressWarnings
(
"
unchecked
"
)
private
static
void
migrateSharedPreferencesValues
(
SharedPreferences
sharedPreferences
Map
<
String
?
>
values
)
{
final
SharedPreferences
.
Editor
editor
=
sharedPreferences
.
edit
(
)
;
for
(
String
key
:
values
.
keySet
(
)
)
{
final
Object
value
=
values
.
get
(
key
)
;
if
(
value
instanceof
String
)
{
editor
.
putString
(
key
(
String
)
value
)
;
}
else
if
(
value
instanceof
Integer
)
{
editor
.
putInt
(
key
(
(
Integer
)
value
)
)
;
}
else
if
(
value
instanceof
Float
)
{
editor
.
putFloat
(
key
(
(
Float
)
value
)
)
;
}
else
if
(
value
instanceof
Long
)
{
editor
.
putLong
(
key
(
(
Long
)
value
)
)
;
}
else
if
(
value
instanceof
Boolean
)
{
editor
.
putBoolean
(
key
(
(
Boolean
)
value
)
)
;
}
else
if
(
value
instanceof
Set
)
{
editor
.
putStringSet
(
key
(
(
Set
<
String
>
)
value
)
)
;
}
}
editor
.
apply
(
)
;
}
private
SharedPreferences
maybeMigrateSharedPreferences
(
SharedPreferences
sharedPreferences
)
throws
UnsupportedEncodingException
GeneralSecurityException
{
final
SharedPreferences
oldPreferences
=
context
.
getSharedPreferences
(
getSyncPrefsPath
(
account
.
name
)
Utils
.
SHARED_PREFERENCES_MODE
)
;
return
doMaybeMigrateSharedPreferences
(
sharedPreferences
oldPreferences
)
;
}
VisibleForTesting
static
SharedPreferences
doMaybeMigrateSharedPreferences
(
SharedPreferences
sharedPreferences
SharedPreferences
oldSharedPreferences
)
throws
UnsupportedEncodingException
GeneralSecurityException
{
if
(
sharedPreferences
.
getAll
(
)
.
size
(
)
!
=
0
)
{
return
sharedPreferences
;
}
final
Map
<
String
?
>
oldPreferenceValues
=
oldSharedPreferences
.
getAll
(
)
;
if
(
oldPreferenceValues
.
size
(
)
=
=
0
)
{
return
sharedPreferences
;
}
migrateSharedPreferencesValues
(
sharedPreferences
oldPreferenceValues
)
;
oldSharedPreferences
.
edit
(
)
.
clear
(
)
.
apply
(
)
;
return
sharedPreferences
;
}
public
SharedPreferences
getSyncPrefs
(
)
throws
UnsupportedEncodingException
GeneralSecurityException
{
final
SharedPreferences
sharedPreferences
=
context
.
getSharedPreferences
(
getSyncPrefsPath
(
getAccountUID
(
)
)
Utils
.
SHARED_PREFERENCES_MODE
)
;
maybeMigrateSharedPreferences
(
sharedPreferences
)
;
return
sharedPreferences
;
}
private
SharedPreferences
getReadingListPrefs
(
)
throws
UnsupportedEncodingException
GeneralSecurityException
{
final
SharedPreferences
sharedPreferences
=
context
.
getSharedPreferences
(
getReadingListPrefsPath
(
getAccountUID
(
)
)
Utils
.
SHARED_PREFERENCES_MODE
)
;
maybeMigrateSharedPreferences
(
sharedPreferences
)
;
return
sharedPreferences
;
}
public
ExtendedJSONObject
toJSONObject
(
)
{
ExtendedJSONObject
o
=
unbundle
(
)
;
o
.
put
(
"
email
"
account
.
name
)
;
o
.
put
(
"
emailUTF8
"
Utils
.
byte2Hex
(
account
.
name
.
getBytes
(
StringUtils
.
UTF_8
)
)
)
;
o
.
put
(
"
fxaDeviceId
"
getDeviceId
(
)
)
;
o
.
put
(
"
fxaDeviceRegistrationVersion
"
getDeviceRegistrationVersion
(
)
)
;
o
.
put
(
"
fxaDeviceRegistrationTimestamp
"
getDeviceRegistrationTimestamp
(
)
)
;
return
o
;
}
public
static
AndroidFxAccount
addAndroidAccount
(
NonNull
Context
context
NonNull
String
uid
NonNull
String
email
NonNull
String
profile
NonNull
String
idpServerURI
NonNull
String
tokenServerURI
NonNull
String
profileServerURI
NonNull
State
state
final
Map
<
String
Boolean
>
authoritiesToSyncAutomaticallyMap
)
throws
UnsupportedEncodingException
GeneralSecurityException
URISyntaxException
{
return
addAndroidAccount
(
context
uid
email
profile
idpServerURI
tokenServerURI
profileServerURI
state
authoritiesToSyncAutomaticallyMap
CURRENT_ACCOUNT_VERSION
false
null
)
;
}
static
AndroidFxAccount
addAndroidAccount
(
NonNull
Context
context
NonNull
String
uid
NonNull
String
email
NonNull
String
profile
NonNull
String
idpServerURI
NonNull
String
tokenServerURI
NonNull
String
profileServerURI
NonNull
State
state
final
Map
<
String
Boolean
>
authoritiesToSyncAutomaticallyMap
final
int
accountVersion
final
boolean
fromPickle
ExtendedJSONObject
bundle
)
throws
UnsupportedEncodingException
GeneralSecurityException
URISyntaxException
{
if
(
uid
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
uid
must
not
be
null
"
)
;
}
if
(
email
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
email
must
not
be
null
"
)
;
}
if
(
profile
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
profile
must
not
be
null
"
)
;
}
if
(
idpServerURI
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
idpServerURI
must
not
be
null
"
)
;
}
if
(
tokenServerURI
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
tokenServerURI
must
not
be
null
"
)
;
}
if
(
profileServerURI
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
profileServerURI
must
not
be
null
"
)
;
}
if
(
state
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
state
must
not
be
null
"
)
;
}
if
(
accountVersion
!
=
CURRENT_ACCOUNT_VERSION
)
{
throw
new
IllegalStateException
(
"
Could
not
create
account
of
version
"
+
accountVersion
+
"
.
Current
version
is
"
+
CURRENT_ACCOUNT_VERSION
+
"
.
"
)
;
}
Bundle
userdata
=
new
Bundle
(
)
;
userdata
.
putString
(
ACCOUNT_KEY_ACCOUNT_VERSION
"
"
+
CURRENT_ACCOUNT_VERSION
)
;
userdata
.
putString
(
ACCOUNT_KEY_IDP_SERVER
idpServerURI
)
;
userdata
.
putString
(
ACCOUNT_KEY_TOKEN_SERVER
tokenServerURI
)
;
userdata
.
putString
(
ACCOUNT_KEY_PROFILE_SERVER
profileServerURI
)
;
userdata
.
putString
(
ACCOUNT_KEY_PROFILE
profile
)
;
userdata
.
putString
(
ACCOUNT_KEY_UID
uid
)
;
if
(
bundle
=
=
null
)
{
bundle
=
new
ExtendedJSONObject
(
)
;
bundle
.
put
(
BUNDLE_KEY_BUNDLE_VERSION
CURRENT_BUNDLE_VERSION
)
;
}
bundle
.
put
(
BUNDLE_KEY_STATE_LABEL
state
.
getStateLabel
(
)
.
name
(
)
)
;
bundle
.
put
(
BUNDLE_KEY_STATE
state
.
toJSONObject
(
)
.
toJSONString
(
)
)
;
userdata
.
putString
(
ACCOUNT_KEY_DESCRIPTOR
bundle
.
toJSONString
(
)
)
;
optionallyTagWithFirstRunScope
(
context
userdata
)
;
Account
account
=
new
Account
(
email
FxAccountConstants
.
ACCOUNT_TYPE
)
;
AccountManager
accountManager
=
AccountManager
.
get
(
context
)
;
boolean
added
=
accountManager
.
addAccountExplicitly
(
account
null
userdata
)
;
if
(
!
added
)
{
return
null
;
}
for
(
String
key
:
userdata
.
keySet
(
)
)
{
accountManager
.
setUserData
(
account
key
userdata
.
getString
(
key
)
)
;
}
final
AndroidFxAccount
fxAccount
=
new
AndroidFxAccount
(
context
account
)
;
if
(
!
fromPickle
)
{
fxAccount
.
clearSyncPrefs
(
)
;
ThreadPool
.
run
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
try
{
AccountPickler
.
pickle
(
fxAccount
FxAccountConstants
.
ACCOUNT_PICKLE_FILENAME
)
;
}
catch
(
Exception
e
)
{
Logger
.
warn
(
LOG_TAG
"
Got
exception
pickling
current
account
details
;
ignoring
.
"
e
)
;
}
}
}
)
;
}
fxAccount
.
setAuthoritiesToSyncAutomaticallyMap
(
authoritiesToSyncAutomaticallyMap
)
;
return
fxAccount
;
}
private
static
void
optionallyTagWithFirstRunScope
(
final
Context
context
final
Bundle
userdata
)
{
final
String
firstRunUUID
=
EnvironmentUtils
.
firstRunUUID
(
context
)
;
if
(
firstRunUUID
!
=
null
)
{
userdata
.
putString
(
ACCOUNT_KEY_FIRST_RUN_SCOPE
firstRunUUID
)
;
}
}
public
void
updateFirstRunScope
(
final
Context
context
)
{
String
firstRunUUID
=
EnvironmentUtils
.
firstRunUUID
(
context
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_FIRST_RUN_SCOPE
firstRunUUID
)
;
}
private
void
clearSyncPrefs
(
)
throws
UnsupportedEncodingException
GeneralSecurityException
{
getSyncPrefs
(
)
.
edit
(
)
.
clear
(
)
.
apply
(
)
;
}
private
void
setAuthoritiesToSyncAutomaticallyMap
(
Map
<
String
Boolean
>
authoritiesToSyncAutomaticallyMap
)
{
if
(
authoritiesToSyncAutomaticallyMap
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
authoritiesToSyncAutomaticallyMap
must
not
be
null
"
)
;
}
for
(
String
authority
:
DEFAULT_AUTHORITIES_TO_SYNC_AUTOMATICALLY_MAP
.
keySet
(
)
)
{
boolean
authorityEnabled
=
DEFAULT_AUTHORITIES_TO_SYNC_AUTOMATICALLY_MAP
.
get
(
authority
)
;
final
Boolean
enabled
=
authoritiesToSyncAutomaticallyMap
.
get
(
authority
)
;
if
(
enabled
!
=
null
)
{
authorityEnabled
=
enabled
.
booleanValue
(
)
;
}
ContentResolver
.
setIsSyncable
(
account
authority
1
)
;
ContentResolver
.
setSyncAutomatically
(
account
authority
authorityEnabled
)
;
}
}
Map
<
String
Boolean
>
getAuthoritiesToSyncAutomaticallyMap
(
)
{
final
Map
<
String
Boolean
>
authoritiesToSync
=
new
HashMap
<
>
(
)
;
for
(
String
authority
:
DEFAULT_AUTHORITIES_TO_SYNC_AUTOMATICALLY_MAP
.
keySet
(
)
)
{
final
boolean
enabled
=
ContentResolver
.
getSyncAutomatically
(
account
authority
)
;
authoritiesToSync
.
put
(
authority
enabled
)
;
}
return
authoritiesToSync
;
}
public
boolean
isCurrentlySyncing
(
)
{
boolean
active
=
false
;
for
(
String
authority
:
AndroidFxAccount
.
DEFAULT_AUTHORITIES_TO_SYNC_AUTOMATICALLY_MAP
.
keySet
(
)
)
{
active
|
=
ContentResolver
.
isSyncActive
(
account
authority
)
;
}
return
active
;
}
public
void
requestImmediateSync
(
String
[
]
stagesToSync
String
[
]
stagesToSkip
boolean
ignoreSettings
)
{
FirefoxAccounts
.
requestImmediateSync
(
getAndroidAccount
(
)
stagesToSync
stagesToSkip
ignoreSettings
)
;
}
public
void
requestEventualSync
(
String
[
]
stagesToSync
String
[
]
stagesToSkip
)
{
FirefoxAccounts
.
requestEventualSync
(
getAndroidAccount
(
)
stagesToSync
stagesToSkip
)
;
}
public
synchronized
void
setState
(
State
state
)
{
if
(
state
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
state
must
not
be
null
"
)
;
}
Logger
.
info
(
LOG_TAG
"
Moving
account
named
like
"
+
getObfuscatedEmail
(
)
+
"
to
state
"
+
state
.
getStateLabel
(
)
.
toString
(
)
)
;
updateBundleValues
(
BUNDLE_KEY_STATE_LABEL
state
.
getStateLabel
(
)
.
name
(
)
BUNDLE_KEY_STATE
state
.
toJSONObject
(
)
.
toJSONString
(
)
)
;
broadcastAccountStateChangedIntent
(
)
;
}
private
void
broadcastAccountStateChangedIntent
(
)
{
final
Intent
intent
=
new
Intent
(
FxAccountConstants
.
ACCOUNT_STATE_CHANGED_ACTION
)
;
intent
.
putExtra
(
Constants
.
JSON_KEY_ACCOUNT
account
.
name
)
;
LocalBroadcastManager
.
getInstance
(
context
)
.
sendBroadcast
(
intent
)
;
}
public
synchronized
State
getState
(
)
{
refreshAndroidAccount
(
)
;
String
stateLabelString
=
getBundleData
(
BUNDLE_KEY_STATE_LABEL
)
;
String
stateString
=
getBundleData
(
BUNDLE_KEY_STATE
)
;
if
(
stateLabelString
=
=
null
|
|
stateString
=
=
null
)
{
throw
new
IllegalStateException
(
"
stateLabelString
and
stateString
must
not
be
null
but
:
"
+
"
(
stateLabelString
=
=
null
)
=
"
+
(
stateLabelString
=
=
null
)
+
"
and
(
stateString
=
=
null
)
=
"
+
(
stateString
=
=
null
)
)
;
}
try
{
StateLabel
stateLabel
=
StateLabel
.
valueOf
(
stateLabelString
)
;
Logger
.
debug
(
LOG_TAG
"
Account
is
in
state
"
+
stateLabel
)
;
return
StateFactory
.
fromJSONObject
(
stateLabel
new
ExtendedJSONObject
(
stateString
)
)
;
}
catch
(
Exception
e
)
{
throw
new
IllegalStateException
(
"
could
not
get
state
"
e
)
;
}
}
private
void
refreshAndroidAccount
(
)
{
final
Account
[
]
accounts
=
accountManager
.
getAccountsByType
(
FxAccountConstants
.
ACCOUNT_TYPE
)
;
if
(
accounts
.
length
=
=
0
)
{
throw
new
IllegalStateException
(
"
Unexpectedly
missing
any
accounts
of
type
"
+
FxAccountConstants
.
ACCOUNT_TYPE
)
;
}
account
=
accounts
[
0
]
;
}
public
void
dump
(
)
{
account
=
FirefoxAccounts
.
getFirefoxAccount
(
context
)
;
if
(
!
FxAccountUtils
.
LOG_PERSONAL_INFORMATION
)
{
return
;
}
ExtendedJSONObject
o
=
toJSONObject
(
)
;
ArrayList
<
String
>
list
=
new
ArrayList
<
String
>
(
o
.
keySet
(
)
)
;
Collections
.
sort
(
list
)
;
for
(
String
key
:
list
)
{
FxAccountUtils
.
pii
(
LOG_TAG
key
+
"
:
"
+
o
.
get
(
key
)
)
;
}
}
public
String
getEmail
(
)
{
return
account
.
name
;
}
public
String
getObfuscatedEmail
(
)
{
return
Utils
.
obfuscateEmail
(
account
.
name
)
;
}
Intent
populateDeletedAccountIntent
(
final
Intent
intent
)
{
final
List
<
String
>
tokens
=
new
ArrayList
<
>
(
)
;
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_VERSION_KEY
Long
.
valueOf
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_VERSION
)
)
;
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_ACCOUNT_KEY
account
.
name
)
;
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_ACCOUNT_PROFILE
getProfile
(
)
)
;
for
(
String
tokenKey
:
KNOWN_OAUTH_TOKEN_TYPES
)
{
final
String
authToken
=
accountManager
.
peekAuthToken
(
account
tokenKey
)
;
if
(
authToken
!
=
null
)
{
tokens
.
add
(
authToken
)
;
}
}
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_OAUTH_SERVICE_ENDPOINT_KEY
getOAuthServerURI
(
)
)
;
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_ACCOUNT_AUTH_TOKENS
tokens
.
toArray
(
new
String
[
tokens
.
size
(
)
]
)
)
;
try
{
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_ACCOUNT_SESSION_TOKEN
getState
(
)
.
getSessionToken
(
)
)
;
}
catch
(
State
.
NotASessionTokenState
e
)
{
}
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_ACCOUNT_SERVER_URI
getAccountServerURI
(
)
)
;
intent
.
putExtra
(
FxAccountConstants
.
ACCOUNT_DELETED_INTENT_ACCOUNT_DEVICE_ID
getDeviceId
(
)
)
;
return
intent
;
}
private
Intent
makeProfileJSONUpdatedIntent
(
)
{
final
Intent
intent
=
new
Intent
(
)
;
intent
.
setAction
(
FxAccountConstants
.
ACCOUNT_PROFILE_JSON_UPDATED_ACTION
)
;
return
intent
;
}
public
void
setLastSyncedTimestamp
(
long
now
)
{
try
{
getSyncPrefs
(
)
.
edit
(
)
.
putLong
(
PREF_KEY_LAST_SYNCED_TIMESTAMP
now
)
.
commit
(
)
;
}
catch
(
Exception
e
)
{
Logger
.
warn
(
LOG_TAG
"
Got
exception
setting
last
synced
time
;
ignoring
.
"
e
)
;
}
}
public
long
getLastSyncedTimestamp
(
)
{
try
{
return
getSyncPrefs
(
)
.
getLong
(
PREF_KEY_LAST_SYNCED_TIMESTAMP
neverSynced
)
;
}
catch
(
Exception
e
)
{
Logger
.
warn
(
LOG_TAG
"
Got
exception
getting
last
synced
time
;
ignoring
.
"
e
)
;
return
neverSynced
;
}
}
public
boolean
neverSynced
(
)
{
try
{
return
getSyncPrefs
(
)
.
getLong
(
PREF_KEY_LAST_SYNCED_TIMESTAMP
neverSynced
)
=
=
-
1
;
}
catch
(
Exception
e
)
{
Logger
.
warn
(
LOG_TAG
"
Got
exception
getting
last
synced
time
;
ignoring
.
"
e
)
;
return
false
;
}
}
public
void
unsafeTransitionToDefaultEndpoints
(
)
{
unsafeTransitionToStageEndpoints
(
FxAccountConstants
.
DEFAULT_AUTH_SERVER_ENDPOINT
FxAccountConstants
.
DEFAULT_TOKEN_SERVER_ENDPOINT
FxAccountConstants
.
DEFAULT_PROFILE_SERVER_ENDPOINT
)
;
}
public
void
unsafeTransitionToStageEndpoints
(
)
{
unsafeTransitionToStageEndpoints
(
FxAccountConstants
.
STAGE_AUTH_SERVER_ENDPOINT
FxAccountConstants
.
STAGE_TOKEN_SERVER_ENDPOINT
FxAccountConstants
.
STAGE_PROFILE_SERVER_ENDPOINT
)
;
}
private
void
unsafeTransitionToStageEndpoints
(
String
authServerEndpoint
String
tokenServerEndpoint
String
profileServerEndpoint
)
{
try
{
getReadingListPrefs
(
)
.
edit
(
)
.
clear
(
)
.
commit
(
)
;
}
catch
(
UnsupportedEncodingException
|
GeneralSecurityException
e
)
{
}
try
{
getSyncPrefs
(
)
.
edit
(
)
.
clear
(
)
.
commit
(
)
;
}
catch
(
UnsupportedEncodingException
|
GeneralSecurityException
e
)
{
}
State
state
=
getState
(
)
;
setState
(
state
.
makeSeparatedState
(
)
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_IDP_SERVER
authServerEndpoint
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_TOKEN_SERVER
tokenServerEndpoint
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_PROFILE_SERVER
profileServerEndpoint
)
;
ContentResolver
.
setIsSyncable
(
account
BrowserContract
.
READING_LIST_AUTHORITY
1
)
;
}
public
ExtendedJSONObject
getProfileJSON
(
)
{
final
String
profileString
=
getBundleData
(
BUNDLE_KEY_PROFILE_JSON
)
;
if
(
profileString
=
=
null
)
{
return
null
;
}
try
{
return
new
ExtendedJSONObject
(
profileString
)
;
}
catch
(
Exception
e
)
{
Logger
.
error
(
LOG_TAG
"
Failed
to
parse
profile
JSON
;
ignoring
and
returning
null
.
"
e
)
;
}
return
null
;
}
public
void
fetchProfileJSON
(
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
String
authToken
;
try
{
authToken
=
accountManager
.
blockingGetAuthToken
(
account
AndroidFxAccount
.
PROFILE_OAUTH_TOKEN_TYPE
true
)
;
if
(
authToken
=
=
null
)
{
throw
new
RuntimeException
(
"
Couldn
'
t
get
oauth
token
!
Aborting
profile
fetch
.
"
)
;
}
}
catch
(
Exception
e
)
{
Logger
.
error
(
LOG_TAG
"
Error
fetching
profile
information
;
ignoring
.
"
e
)
;
return
;
}
Logger
.
info
(
LOG_TAG
"
Intent
service
launched
to
fetch
profile
.
"
)
;
final
Intent
fetchProfileIntent
=
FxAccountProfileService
.
getProfileFetchingIntent
(
authToken
getProfileServerURI
(
)
new
ProfileResultReceiver
(
new
Handler
(
)
)
)
;
FxAccountProfileService
.
enqueueWork
(
context
fetchProfileIntent
)
;
}
}
)
;
}
private
long
getUserDataLong
(
String
key
long
defaultValue
)
{
final
String
numStr
=
accountManager
.
getUserData
(
account
key
)
;
if
(
TextUtils
.
isEmpty
(
numStr
)
)
{
return
defaultValue
;
}
try
{
return
Long
.
parseLong
(
numStr
)
;
}
catch
(
NumberFormatException
e
)
{
Logger
.
warn
(
LOG_TAG
"
Couldn
'
t
parse
"
+
key
+
"
;
defaulting
to
"
+
defaultValue
e
)
;
return
defaultValue
;
}
}
Nullable
public
synchronized
String
getDeviceId
(
)
{
return
accountManager
.
getUserData
(
account
ACCOUNT_KEY_DEVICE_ID
)
;
}
public
synchronized
int
getDeviceRegistrationVersion
(
)
{
final
String
numStr
=
accountManager
.
getUserData
(
account
ACCOUNT_KEY_DEVICE_REGISTRATION_VERSION
)
;
if
(
TextUtils
.
isEmpty
(
numStr
)
)
{
return
0
;
}
try
{
return
Integer
.
parseInt
(
numStr
)
;
}
catch
(
NumberFormatException
e
)
{
Logger
.
warn
(
LOG_TAG
"
Couldn
'
t
parse
ACCOUNT_KEY_DEVICE_REGISTRATION_VERSION
;
defaulting
to
0
"
e
)
;
return
0
;
}
}
public
synchronized
long
getDeviceRegistrationTimestamp
(
)
{
return
getUserDataLong
(
ACCOUNT_KEY_DEVICE_REGISTRATION_TIMESTAMP
0L
)
;
}
public
synchronized
long
getDevicePushRegistrationError
(
)
{
return
getUserDataLong
(
ACCOUNT_KEY_DEVICE_PUSH_REGISTRATION_ERROR
0L
)
;
}
public
synchronized
long
getDevicePushRegistrationErrorTime
(
)
{
return
getUserDataLong
(
ACCOUNT_KEY_DEVICE_PUSH_REGISTRATION_ERROR_TIME
0L
)
;
}
public
synchronized
void
setDeviceId
(
String
id
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_ID
id
)
;
}
private
synchronized
void
setDeviceRegistrationVersion
(
int
deviceRegistrationVersion
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_REGISTRATION_VERSION
Integer
.
toString
(
deviceRegistrationVersion
)
)
;
}
public
synchronized
void
setDeviceRegistrationTimestamp
(
long
timestamp
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_REGISTRATION_TIMESTAMP
Long
.
toString
(
timestamp
)
)
;
}
public
synchronized
void
resetDeviceRegistrationVersion
(
)
{
setDeviceRegistrationVersion
(
0
)
;
}
public
synchronized
void
setFxAUserData
(
String
id
int
deviceRegistrationVersion
long
timestamp
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_ID
id
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_REGISTRATION_VERSION
Integer
.
toString
(
deviceRegistrationVersion
)
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_REGISTRATION_TIMESTAMP
Long
.
toString
(
timestamp
)
)
;
}
public
synchronized
void
setDevicePushRegistrationError
(
long
error
long
errorTimeMs
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_PUSH_REGISTRATION_ERROR
Long
.
toString
(
error
)
)
;
accountManager
.
setUserData
(
account
ACCOUNT_KEY_DEVICE_PUSH_REGISTRATION_ERROR_TIME
Long
.
toString
(
errorTimeMs
)
)
;
}
public
synchronized
void
resetDevicePushRegistrationError
(
)
{
setDevicePushRegistrationError
(
0L
0l
)
;
}
public
synchronized
void
setCachedHashedFxAUID
(
final
String
newHashedFxAUID
)
{
accountManager
.
setUserData
(
account
ACCOUNT_KEY_HASHED_FXA_UID
newHashedFxAUID
)
;
}
public
synchronized
String
getCachedHashedFxAUID
(
)
{
return
accountManager
.
getUserData
(
account
ACCOUNT_KEY_HASHED_FXA_UID
)
;
}
SuppressLint
(
"
ParcelCreator
"
)
private
class
ProfileResultReceiver
extends
ResultReceiver
{
ProfileResultReceiver
(
Handler
handler
)
{
super
(
handler
)
;
}
Override
protected
void
onReceiveResult
(
int
resultCode
Bundle
bundle
)
{
super
.
onReceiveResult
(
resultCode
bundle
)
;
switch
(
resultCode
)
{
case
Activity
.
RESULT_OK
:
Logger
.
info
(
LOG_TAG
"
Profile
JSON
fetch
succeeded
!
"
)
;
final
String
resultData
=
bundle
.
getString
(
FxAccountProfileService
.
KEY_RESULT_STRING
)
;
FxAccountUtils
.
pii
(
LOG_TAG
"
Profile
JSON
fetch
returned
:
"
+
resultData
)
;
renameAccountIfNecessary
(
resultData
new
Runnable
(
)
{
Override
public
void
run
(
)
{
updateBundleValues
(
BUNDLE_KEY_PROFILE_JSON
resultData
)
;
LocalBroadcastManager
.
getInstance
(
context
)
.
sendBroadcast
(
makeProfileJSONUpdatedIntent
(
)
)
;
}
}
)
;
break
;
case
Activity
.
RESULT_CANCELED
:
Logger
.
warn
(
LOG_TAG
"
Failed
to
fetch
profile
JSON
;
ignoring
.
"
)
;
break
;
default
:
Logger
.
warn
(
LOG_TAG
"
Invalid
result
code
received
;
ignoring
.
"
)
;
break
;
}
}
}
private
void
renameAccountIfNecessary
(
final
String
profileData
final
Runnable
callback
)
{
final
ExtendedJSONObject
profileJSON
;
try
{
profileJSON
=
new
ExtendedJSONObject
(
profileData
)
;
}
catch
(
NonObjectJSONException
|
IOException
e
)
{
Logger
.
error
(
LOG_TAG
"
Error
processing
fetched
account
json
string
"
e
)
;
callback
.
run
(
)
;
return
;
}
if
(
!
profileJSON
.
containsKey
(
"
email
"
)
)
{
Logger
.
error
(
LOG_TAG
"
Profile
JSON
missing
email
key
"
)
;
callback
.
run
(
)
;
return
;
}
final
String
email
=
profileJSON
.
getString
(
"
email
"
)
;
try
{
acquireSharedAccountStateLock
(
LOG_TAG
)
;
}
catch
(
InterruptedException
e
)
{
Logger
.
error
(
LOG_TAG
"
Could
not
acquire
a
shared
account
state
lock
.
"
)
;
callback
.
run
(
)
;
return
;
}
try
{
account
=
FirefoxAccounts
.
getFirefoxAccount
(
context
)
;
if
(
account
.
name
.
equals
(
email
)
)
{
callback
.
run
(
)
;
return
;
}
Logger
.
info
(
LOG_TAG
"
Renaming
Android
Account
.
"
)
;
FxAccountUtils
.
pii
(
LOG_TAG
"
Renaming
Android
account
from
"
+
account
.
name
+
"
to
"
+
email
)
;
final
Map
<
String
Boolean
>
currentAuthoritiesToSync
=
getAuthoritiesToSyncAutomaticallyMap
(
)
;
final
Map
<
String
List
<
PeriodicSync
>
>
periodicSyncsForAuthorities
=
new
HashMap
<
>
(
)
;
for
(
String
authority
:
currentAuthoritiesToSync
.
keySet
(
)
)
{
periodicSyncsForAuthorities
.
put
(
authority
ContentResolver
.
getPeriodicSyncs
(
account
authority
)
)
;
}
final
Runnable
migrateSyncSettings
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
setAuthoritiesToSyncAutomaticallyMap
(
currentAuthoritiesToSync
)
;
for
(
String
authority
:
periodicSyncsForAuthorities
.
keySet
(
)
)
{
final
List
<
PeriodicSync
>
periodicSyncs
=
periodicSyncsForAuthorities
.
get
(
authority
)
;
for
(
PeriodicSync
periodicSync
:
periodicSyncs
)
{
ContentResolver
.
addPeriodicSync
(
account
periodicSync
.
authority
periodicSync
.
extras
periodicSync
.
period
)
;
}
}
}
}
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
LOLLIPOP
)
{
doOptionalProfileRename21Plus
(
email
migrateSyncSettings
callback
)
;
}
else
{
doOptionalProfileRenamePre21
(
email
migrateSyncSettings
callback
)
;
}
}
finally
{
releaseSharedAccountStateLock
(
)
;
}
}
TargetApi
(
Build
.
VERSION_CODES
.
LOLLIPOP
)
private
void
doOptionalProfileRename21Plus
(
final
String
newEmail
final
Runnable
migrateSyncSettingsCallback
final
Runnable
callback
)
{
final
Account
currentAccount
=
new
Account
(
account
.
name
account
.
type
)
;
accountManager
.
renameAccount
(
currentAccount
newEmail
new
AccountManagerCallback
<
Account
>
(
)
{
Override
public
void
run
(
AccountManagerFuture
<
Account
>
future
)
{
if
(
future
.
isCancelled
(
)
)
{
Logger
.
error
(
LOG_TAG
"
Account
rename
task
cancelled
.
"
)
;
callback
.
run
(
)
;
return
;
}
if
(
!
future
.
isDone
(
)
)
{
Logger
.
error
(
LOG_TAG
"
Account
rename
callback
invoked
by
task
is
not
finished
.
"
)
;
callback
.
run
(
)
;
return
;
}
try
{
final
Account
updatedAccount
=
future
.
getResult
(
)
;
if
(
!
updatedAccount
.
name
.
equals
(
newEmail
)
)
{
Logger
.
error
(
LOG_TAG
"
Tried
to
update
account
name
but
it
didn
'
t
seem
to
have
changed
.
"
)
;
}
else
{
account
=
updatedAccount
;
migrateSyncSettingsCallback
.
run
(
)
;
callback
.
run
(
)
;
}
}
catch
(
OperationCanceledException
|
IOException
|
AuthenticatorException
e
)
{
Logger
.
error
(
LOG_TAG
"
Unexpected
exception
while
trying
to
rename
an
account
"
e
)
;
callback
.
run
(
)
;
}
}
}
new
Handler
(
)
)
;
}
TargetApi
(
Build
.
VERSION_CODES
.
JELLY_BEAN
)
private
void
doOptionalProfileRenamePre21
(
final
String
email
final
Runnable
migrateSyncSettingsCallback
final
Runnable
callback
)
{
final
Bundle
currentUserData
=
new
Bundle
(
)
;
for
(
String
key
:
ACCOUNT_KEY_TO_CARRY_OVER_ON_RENAME_SET
)
{
currentUserData
.
putString
(
key
accountManager
.
getUserData
(
account
key
)
)
;
}
accountManager
.
setUserData
(
account
ACCOUNT_KEY_RENAME_IN_PROGRESS
ACCOUNT_VALUE_RENAME_IN_PROGRESS
)
;
final
Account
currentAccount
=
new
Account
(
account
.
name
account
.
type
)
;
accountManager
.
removeAccount
(
currentAccount
new
AccountManagerCallback
<
Boolean
>
(
)
{
Override
public
void
run
(
AccountManagerFuture
<
Boolean
>
future
)
{
boolean
accountRemovalSucceeded
=
false
;
boolean
removeResult
=
false
;
try
{
removeResult
=
future
.
getResult
(
)
;
accountRemovalSucceeded
=
!
future
.
isCancelled
(
)
&
&
future
.
isDone
(
)
&
&
removeResult
;
}
catch
(
OperationCanceledException
|
IOException
|
AuthenticatorException
e
)
{
Logger
.
error
(
LOG_TAG
"
Exception
while
obtaining
account
remove
task
results
.
Moving
on
.
"
e
)
;
}
if
(
!
accountRemovalSucceeded
)
{
if
(
future
.
isCancelled
(
)
)
{
Logger
.
error
(
LOG_TAG
"
Account
remove
task
cancelled
.
Moving
on
.
"
)
;
}
else
if
(
!
future
.
isDone
(
)
)
{
Logger
.
error
(
LOG_TAG
"
Account
remove
callback
invoked
but
task
is
not
finished
.
Moving
on
.
"
)
;
}
else
if
(
!
removeResult
)
{
Logger
.
error
(
LOG_TAG
"
Failed
to
remove
current
account
while
renaming
accounts
.
Moving
on
.
"
)
;
}
accountManager
.
setUserData
(
account
ACCOUNT_KEY_RENAME_IN_PROGRESS
null
)
;
callback
.
run
(
)
;
return
;
}
final
Account
newAccount
=
new
Account
(
email
FxAccountConstants
.
ACCOUNT_TYPE
)
;
final
boolean
didAdd
=
accountManager
.
addAccountExplicitly
(
newAccount
null
currentUserData
)
;
if
(
didAdd
)
{
account
=
newAccount
;
migrateSyncSettingsCallback
.
run
(
)
;
callback
.
run
(
)
;
return
;
}
Logger
.
error
(
LOG_TAG
"
Failed
to
add
account
with
a
new
name
after
deleting
old
account
.
"
)
;
}
}
new
Handler
(
)
)
;
}
private
static
final
Semaphore
sLock
=
new
Semaphore
(
1
true
)
;
private
String
lockTag
=
null
;
protected
boolean
locked
=
false
;
public
synchronized
void
acquireSharedAccountStateLock
(
final
String
tag
)
throws
InterruptedException
{
final
long
id
=
Thread
.
currentThread
(
)
.
getId
(
)
;
this
.
lockTag
=
tag
;
Log
.
d
(
Logger
.
DEFAULT_LOG_TAG
"
Thread
with
tag
and
thread
id
acquiring
lock
:
"
+
lockTag
+
"
"
+
id
+
"
.
.
.
"
)
;
sLock
.
acquire
(
)
;
locked
=
true
;
Log
.
d
(
Logger
.
DEFAULT_LOG_TAG
"
Thread
with
tag
and
thread
id
acquiring
lock
:
"
+
lockTag
+
"
"
+
id
+
"
.
.
.
ACQUIRED
"
)
;
}
public
synchronized
void
releaseSharedAccountStateLock
(
)
{
final
long
id
=
Thread
.
currentThread
(
)
.
getId
(
)
;
Log
.
d
(
Logger
.
DEFAULT_LOG_TAG
"
Thread
with
tag
and
thread
id
releasing
lock
:
"
+
lockTag
+
"
"
+
id
+
"
.
.
.
"
)
;
if
(
locked
)
{
sLock
.
release
(
)
;
locked
=
false
;
Log
.
d
(
Logger
.
DEFAULT_LOG_TAG
"
Thread
with
tag
and
thread
id
releasing
lock
:
"
+
lockTag
+
"
"
+
id
+
"
.
.
.
RELEASED
"
)
;
}
else
{
Log
.
d
(
Logger
.
DEFAULT_LOG_TAG
"
Thread
with
tag
and
thread
id
releasing
lock
:
"
+
lockTag
+
"
"
+
id
+
"
.
.
.
NOT
LOCKED
"
)
;
}
}
Override
protected
synchronized
void
finalize
(
)
throws
Throwable
{
super
.
finalize
(
)
;
if
(
locked
)
{
sLock
.
release
(
)
;
locked
=
false
;
final
long
id
=
Thread
.
currentThread
(
)
.
getId
(
)
;
Log
.
e
(
Logger
.
DEFAULT_LOG_TAG
"
Thread
with
tag
and
thread
id
releasing
lock
:
"
+
lockTag
+
"
"
+
id
+
"
.
.
.
RELEASED
DURING
FINALIZE
"
)
;
}
}
}
