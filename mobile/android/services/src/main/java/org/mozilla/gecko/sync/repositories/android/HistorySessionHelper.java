package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
;
import
android
.
content
.
ContentProviderClient
;
import
android
.
database
.
Cursor
;
import
android
.
os
.
RemoteException
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NoGuidForIdException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
ParentNotFoundException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
StoreTrackingRepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionWipeDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
HistoryRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
java
.
util
.
ArrayList
;
class
HistorySessionHelper
extends
SessionHelper
{
private
final
static
String
LOG_TAG
=
"
HistorySessionHelper
"
;
private
static
final
int
INSERT_RECORD_THRESHOLD
=
5000
;
private
static
final
int
RECENT_VISITS_LIMIT
=
20
;
private
final
Object
recordsBufferMonitor
=
new
Object
(
)
;
private
ArrayList
<
HistoryRecord
>
recordsBuffer
=
new
ArrayList
<
HistoryRecord
>
(
)
;
HistorySessionHelper
(
StoreTrackingRepositorySession
session
DataAccessor
dbHelper
)
{
super
(
session
dbHelper
)
;
}
Override
Record
retrieveDuringFetch
(
Cursor
cur
)
{
return
RepoUtils
.
historyFromMirrorCursor
(
cur
)
;
}
Override
Runnable
getWipeRunnable
(
RepositorySessionWipeDelegate
delegate
)
{
return
new
WipeRunnable
(
delegate
)
;
}
Override
void
storeRecordDeletion
(
RepositorySessionStoreDelegate
storeDelegate
Record
record
Record
existingRecord
)
{
dbHelper
.
purgeGuid
(
record
.
guid
)
;
storeDelegate
.
onRecordStoreSucceeded
(
record
.
guid
)
;
}
Override
boolean
shouldIgnore
(
Record
record
)
{
return
shouldIgnoreStatic
(
record
)
;
}
VisibleForTesting
static
boolean
shouldIgnoreStatic
(
Record
record
)
{
if
(
!
(
record
instanceof
HistoryRecord
)
)
{
return
true
;
}
HistoryRecord
r
=
(
HistoryRecord
)
record
;
return
!
RepoUtils
.
isValidHistoryURI
(
r
.
histURI
)
;
}
Override
Record
retrieveDuringStore
(
Cursor
cursor
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
return
RepoUtils
.
historyFromMirrorCursor
(
cursor
)
;
}
Override
void
fixupRecord
(
Record
record
)
{
}
Override
String
buildRecordString
(
Record
record
)
{
return
buildRecordStringStatic
(
record
)
;
}
VisibleForTesting
static
String
buildRecordStringStatic
(
Record
record
)
{
HistoryRecord
hist
=
(
HistoryRecord
)
record
;
return
hist
.
histURI
;
}
Override
Record
processBeforeInsertion
(
Record
toProcess
)
{
return
toProcess
;
}
void
insert
(
RepositorySessionStoreDelegate
delegate
Record
record
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
enqueueNewRecord
(
delegate
(
HistoryRecord
)
record
)
;
}
Override
Record
reconcileRecords
(
Record
remoteRecord
Record
localRecord
long
lastRemoteRetrieval
long
lastLocalRetrieval
)
{
return
session
.
reconcileRecords
(
remoteRecord
localRecord
lastRemoteRetrieval
lastLocalRetrieval
)
;
}
Override
Record
prepareRecord
(
Record
record
)
{
return
record
;
}
Override
Record
transformRecord
(
Record
record
)
{
return
addVisitsToRecord
(
record
)
;
}
Override
void
doBegin
(
)
throws
NullCursorException
{
}
Override
Runnable
getStoreDoneRunnable
(
final
RepositorySessionStoreDelegate
delegate
)
{
return
getFlushRecordsRunnabler
(
delegate
)
;
}
Override
boolean
doReplaceRecord
(
Record
toStore
Record
existingRecord
RepositorySessionStoreDelegate
delegate
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
Logger
.
debug
(
LOG_TAG
"
Replacing
existing
"
+
existingRecord
.
guid
+
(
toStore
.
deleted
?
"
with
deleted
record
"
:
"
with
record
"
)
+
toStore
.
guid
)
;
Record
preparedToStore
=
prepareRecord
(
toStore
)
;
dbHelper
.
update
(
existingRecord
.
guid
preparedToStore
)
;
updateBookkeeping
(
preparedToStore
)
;
Logger
.
debug
(
LOG_TAG
"
replace
(
)
returning
record
"
+
preparedToStore
.
guid
)
;
Logger
.
debug
(
LOG_TAG
"
Calling
delegate
callback
with
guid
"
+
preparedToStore
.
guid
+
"
(
"
+
preparedToStore
.
androidID
+
"
)
"
)
;
delegate
.
onRecordStoreReconciled
(
preparedToStore
.
guid
null
)
;
delegate
.
onRecordStoreSucceeded
(
preparedToStore
.
guid
)
;
return
true
;
}
Override
boolean
isLocallyModified
(
Record
record
)
{
return
record
.
lastModified
>
session
.
getLastSyncTimestamp
(
)
;
}
Runnable
getStoreIncompleteRunnable
(
final
RepositorySessionStoreDelegate
delegate
)
{
return
getFlushRecordsRunnabler
(
delegate
)
;
}
private
Runnable
getFlushRecordsRunnabler
(
final
RepositorySessionStoreDelegate
delegate
)
{
return
new
Runnable
(
)
{
Override
public
void
run
(
)
{
synchronized
(
recordsBufferMonitor
)
{
try
{
flushNewRecords
(
delegate
)
;
}
catch
(
Exception
e
)
{
Logger
.
warn
(
LOG_TAG
"
Error
flushing
records
to
database
.
"
e
)
;
}
}
}
}
;
}
private
void
enqueueNewRecord
(
RepositorySessionStoreDelegate
delegate
HistoryRecord
record
)
throws
NullCursorException
{
synchronized
(
recordsBufferMonitor
)
{
if
(
recordsBuffer
.
size
(
)
>
=
INSERT_RECORD_THRESHOLD
)
{
flushNewRecords
(
delegate
)
;
}
Logger
.
debug
(
LOG_TAG
"
Enqueuing
new
record
with
GUID
"
+
record
.
guid
)
;
recordsBuffer
.
add
(
record
)
;
}
}
private
Record
addVisitsToRecord
(
Record
record
)
{
Logger
.
debug
(
LOG_TAG
"
Adding
visits
for
GUID
"
+
record
.
guid
)
;
ContentProviderClient
visitsClient
=
dbHelper
.
context
.
getContentResolver
(
)
.
acquireContentProviderClient
(
BrowserContractHelpers
.
VISITS_CONTENT_URI
)
;
if
(
visitsClient
=
=
null
)
{
throw
new
IllegalStateException
(
"
Could
not
obtain
a
ContentProviderClient
for
Visits
URI
"
)
;
}
try
{
(
(
HistoryRecord
)
record
)
.
visits
=
VisitsHelper
.
getRecentHistoryVisitsForGUID
(
visitsClient
record
.
guid
RECENT_VISITS_LIMIT
)
;
}
catch
(
RemoteException
e
)
{
throw
new
IllegalStateException
(
"
Error
while
obtaining
visits
for
a
record
"
e
)
;
}
finally
{
visitsClient
.
release
(
)
;
}
return
record
;
}
private
void
flushNewRecords
(
RepositorySessionStoreDelegate
delegate
)
throws
NullCursorException
{
if
(
recordsBuffer
.
size
(
)
<
1
)
{
Logger
.
debug
(
LOG_TAG
"
No
records
to
flush
returning
.
"
)
;
return
;
}
final
ArrayList
<
HistoryRecord
>
outgoing
=
recordsBuffer
;
recordsBuffer
=
new
ArrayList
<
HistoryRecord
>
(
)
;
Logger
.
debug
(
LOG_TAG
"
Flushing
"
+
outgoing
.
size
(
)
+
"
records
to
database
.
"
)
;
boolean
transactionSuccess
=
(
(
HistoryDataAccessor
)
dbHelper
)
.
bulkInsert
(
outgoing
)
;
if
(
!
transactionSuccess
)
{
for
(
HistoryRecord
failed
:
outgoing
)
{
delegate
.
onRecordStoreFailed
(
new
RuntimeException
(
"
Failed
to
insert
history
item
with
guid
"
+
failed
.
guid
+
"
.
"
)
failed
.
guid
)
;
}
return
;
}
for
(
HistoryRecord
succeeded
:
outgoing
)
{
try
{
updateBookkeeping
(
succeeded
)
;
}
catch
(
NoGuidForIdException
|
ParentNotFoundException
e
)
{
throw
new
NullCursorException
(
e
)
;
}
catch
(
NullCursorException
e
)
{
throw
e
;
}
session
.
trackRecord
(
succeeded
)
;
delegate
.
onRecordStoreSucceeded
(
succeeded
.
guid
)
;
}
}
}
