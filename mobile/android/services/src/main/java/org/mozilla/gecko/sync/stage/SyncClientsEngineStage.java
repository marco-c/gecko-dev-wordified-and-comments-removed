package
org
.
mozilla
.
gecko
.
sync
.
stage
;
import
android
.
accounts
.
Account
;
import
android
.
content
.
Context
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
ExecutorService
;
import
java
.
util
.
concurrent
.
Executors
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
import
org
.
json
.
simple
.
JSONArray
;
import
org
.
json
.
simple
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
background
.
fxa
.
FxAccountClient
;
import
org
.
mozilla
.
gecko
.
background
.
fxa
.
FxAccountClient20
;
import
org
.
mozilla
.
gecko
.
background
.
fxa
.
FxAccountClientException
;
import
org
.
mozilla
.
gecko
.
fxa
.
FirefoxAccounts
;
import
org
.
mozilla
.
gecko
.
fxa
.
authenticator
.
AndroidFxAccount
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
State
;
import
org
.
mozilla
.
gecko
.
sync
.
CommandProcessor
;
import
org
.
mozilla
.
gecko
.
sync
.
CommandProcessor
.
Command
;
import
org
.
mozilla
.
gecko
.
sync
.
CryptoRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
HTTPFailureException
;
import
org
.
mozilla
.
gecko
.
sync
.
NoCollectionKeysSetException
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
sync
.
crypto
.
CryptoException
;
import
org
.
mozilla
.
gecko
.
sync
.
crypto
.
KeyBundle
;
import
org
.
mozilla
.
gecko
.
sync
.
delegates
.
ClientsDataDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
AuthHeaderProvider
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
BaseResource
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageCollectionRequest
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageRecordRequest
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageResponse
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
WBOCollectionRequestDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
WBORequestDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
.
ClientsDatabaseAccessor
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
.
RepoUtils
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
ClientRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
ClientRecordFactory
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
VersionConstants
;
import
org
.
mozilla
.
gecko
.
sync
.
telemetry
.
TelemetryCollector
;
import
ch
.
boye
.
httpclientandroidlib
.
HttpStatus
;
public
class
SyncClientsEngineStage
extends
AbstractSessionManagingSyncStage
{
private
static
final
String
LOG_TAG
=
"
SyncClientsEngineStage
"
;
public
static
final
String
COLLECTION_NAME
=
"
clients
"
;
public
static
final
String
STAGE_NAME
=
COLLECTION_NAME
;
public
static
final
int
CLIENTS_TTL_REFRESH
=
604800000
;
public
static
final
int
MAX_UPLOAD_FAILURE_COUNT
=
5
;
public
static
final
long
NOTIFY_TAB_SENT_TTL_SECS
=
TimeUnit
.
SECONDS
.
convert
(
1L
TimeUnit
.
HOURS
)
;
public
static
final
String
COLLECTION_MODIFIED_REASON_SENDTAB
=
"
sendtab
"
;
public
static
final
String
COLLECTION_MODIFIED_REASON_FIRSTSYNC
=
"
firstsync
"
;
protected
final
ClientRecordFactory
factory
=
new
ClientRecordFactory
(
)
;
protected
ClientUploadDelegate
clientUploadDelegate
;
protected
ClientDownloadDelegate
clientDownloadDelegate
;
protected
ClientsDatabaseAccessor
db
;
protected
volatile
boolean
shouldWipe
;
protected
volatile
boolean
shouldUploadLocalRecord
;
protected
final
AtomicInteger
uploadAttemptsCount
=
new
AtomicInteger
(
)
;
protected
final
List
<
ClientRecord
>
modifiedClientsToUpload
=
new
ArrayList
<
ClientRecord
>
(
)
;
protected
int
getClientsCount
(
)
{
return
getClientsDatabaseAccessor
(
)
.
clientsCount
(
)
;
}
protected
synchronized
ClientsDatabaseAccessor
getClientsDatabaseAccessor
(
)
{
if
(
db
=
=
null
)
{
db
=
new
ClientsDatabaseAccessor
(
session
.
getContext
(
)
)
;
}
return
db
;
}
protected
synchronized
void
closeDataAccessor
(
)
{
if
(
db
=
=
null
)
{
return
;
}
db
.
close
(
)
;
db
=
null
;
}
public
class
ClientDownloadDelegate
extends
WBOCollectionRequestDelegate
{
final
ClientsDataDelegate
clientsDelegate
=
session
.
getClientsDelegate
(
)
;
boolean
localAccountGUIDDownloaded
=
false
;
Override
public
AuthHeaderProvider
getAuthHeaderProvider
(
)
{
return
session
.
getAuthHeaderProvider
(
)
;
}
Override
public
String
ifUnmodifiedSince
(
)
{
return
null
;
}
Override
public
void
handleRequestSuccess
(
SyncStorageResponse
response
)
{
final
Context
context
=
session
.
getContext
(
)
;
final
Account
account
=
FirefoxAccounts
.
getFirefoxAccount
(
context
)
;
session
.
config
.
persistServerClientsTimestamp
(
response
.
normalizedWeaveTimestamp
(
)
)
;
BaseResource
.
consumeEntity
(
response
)
;
wipeAndStore
(
null
)
;
boolean
isFirstLocalClientRecordUpload
=
false
;
if
(
!
localAccountGUIDDownloaded
)
{
Logger
.
info
(
LOG_TAG
"
Local
client
GUID
does
not
exist
on
the
server
.
Upload
timestamp
will
be
reset
.
"
)
;
session
.
config
.
persistServerClientRecordTimestamp
(
0
)
;
isFirstLocalClientRecordUpload
=
true
;
}
localAccountGUIDDownloaded
=
false
;
final
int
clientsCount
;
try
{
clientsCount
=
getClientsCount
(
)
;
}
finally
{
closeDataAccessor
(
)
;
}
Logger
.
debug
(
LOG_TAG
"
Database
contains
"
+
clientsCount
+
"
clients
.
"
)
;
Logger
.
debug
(
LOG_TAG
"
Server
response
asserts
"
+
response
.
weaveRecords
(
)
+
"
records
.
"
)
;
clientUploadDelegate
=
new
ClientUploadDelegate
(
)
;
clientsDelegate
.
setClientsCount
(
clientsCount
)
;
if
(
modifiedClientsToUpload
.
size
(
)
>
0
)
{
final
List
<
String
>
devicesToNotify
=
new
ArrayList
<
>
(
)
;
for
(
ClientRecord
record
:
modifiedClientsToUpload
)
{
if
(
!
TextUtils
.
isEmpty
(
record
.
fxaDeviceId
)
)
{
devicesToNotify
.
add
(
record
.
fxaDeviceId
)
;
}
}
uploadRemoteRecords
(
)
;
if
(
!
isFirstLocalClientRecordUpload
&
&
account
!
=
null
)
{
final
AndroidFxAccount
fxAccount
=
new
AndroidFxAccount
(
context
account
)
;
notifyClients
(
fxAccount
devicesToNotify
NOTIFY_TAB_SENT_TTL_SECS
COLLECTION_MODIFIED_REASON_SENDTAB
)
;
}
return
;
}
checkAndUpload
(
)
;
if
(
isFirstLocalClientRecordUpload
&
&
account
!
=
null
)
{
final
AndroidFxAccount
fxAccount
=
new
AndroidFxAccount
(
context
account
)
;
notifyAllClients
(
fxAccount
0
COLLECTION_MODIFIED_REASON_FIRSTSYNC
)
;
}
}
private
void
notifyClients
(
NonNull
AndroidFxAccount
fxAccount
NonNull
List
<
String
>
devicesToNotify
long
ttl
NonNull
String
reason
)
{
final
ExtendedJSONObject
body
=
createNotifyClientsBody
(
devicesToNotify
ttl
reason
)
;
notifyClientsHelper
(
fxAccount
body
)
;
}
private
void
notifyAllClients
(
NonNull
AndroidFxAccount
fxAccount
long
ttl
NonNull
String
reason
)
{
final
ExtendedJSONObject
body
=
createNotifyAllClientsBody
(
fxAccount
.
getDeviceId
(
)
ttl
reason
)
;
notifyClientsHelper
(
fxAccount
body
)
;
}
private
void
notifyClientsHelper
(
NonNull
AndroidFxAccount
fxAccount
NonNull
ExtendedJSONObject
body
)
{
final
byte
[
]
sessionToken
;
try
{
sessionToken
=
fxAccount
.
getState
(
)
.
getSessionToken
(
)
;
}
catch
(
State
.
NotASessionTokenState
e
)
{
Log
.
e
(
LOG_TAG
"
Could
not
get
a
session
token
during
Sync
(
?
)
"
e
)
;
return
;
}
final
ExecutorService
executor
=
Executors
.
newSingleThreadExecutor
(
)
;
final
FxAccountClient
fxAccountClient
=
new
FxAccountClient20
(
fxAccount
.
getAccountServerURI
(
)
executor
)
;
fxAccountClient
.
notifyDevices
(
sessionToken
body
new
FxAccountClient20
.
RequestDelegate
<
ExtendedJSONObject
>
(
)
{
Override
public
void
handleError
(
Exception
e
)
{
Log
.
e
(
LOG_TAG
"
Error
while
notifying
devices
"
e
)
;
}
Override
public
void
handleFailure
(
FxAccountClientException
.
FxAccountClientRemoteException
e
)
{
Log
.
e
(
LOG_TAG
"
Error
while
notifying
devices
"
e
)
;
}
Override
public
void
handleSuccess
(
ExtendedJSONObject
result
)
{
Log
.
i
(
LOG_TAG
"
Devices
notified
"
)
;
}
}
)
;
}
NonNull
SuppressWarnings
(
"
unchecked
"
)
private
ExtendedJSONObject
createNotifyClientsBody
(
NonNull
List
<
String
>
devicesToNotify
long
ttl
NonNull
String
reason
)
{
final
ExtendedJSONObject
body
=
new
ExtendedJSONObject
(
)
;
final
JSONArray
to
=
new
JSONArray
(
)
;
to
.
addAll
(
devicesToNotify
)
;
body
.
put
(
"
to
"
to
)
;
createNotifyClientsHelper
(
body
ttl
reason
)
;
return
body
;
}
NonNull
SuppressWarnings
(
"
unchecked
"
)
private
ExtendedJSONObject
createNotifyAllClientsBody
(
NonNull
String
localFxADeviceId
long
ttl
NonNull
String
reason
)
{
final
ExtendedJSONObject
body
=
new
ExtendedJSONObject
(
)
;
body
.
put
(
"
to
"
"
all
"
)
;
final
JSONArray
excluded
=
new
JSONArray
(
)
;
excluded
.
add
(
localFxADeviceId
)
;
body
.
put
(
"
excluded
"
excluded
)
;
createNotifyClientsHelper
(
body
ttl
reason
)
;
return
body
;
}
private
void
createNotifyClientsHelper
(
ExtendedJSONObject
body
long
ttl
NonNull
String
reason
)
{
body
.
put
(
"
payload
"
createNotifyDevicesPayload
(
reason
)
)
;
body
.
put
(
"
TTL
"
ttl
)
;
}
NonNull
SuppressWarnings
(
"
unchecked
"
)
private
ExtendedJSONObject
createNotifyDevicesPayload
(
NonNull
String
reason
)
{
final
ExtendedJSONObject
payload
=
new
ExtendedJSONObject
(
)
;
payload
.
put
(
"
version
"
1
)
;
payload
.
put
(
"
command
"
"
sync
:
collection_changed
"
)
;
final
ExtendedJSONObject
data
=
new
ExtendedJSONObject
(
)
;
final
JSONArray
collections
=
new
JSONArray
(
)
;
collections
.
add
(
"
clients
"
)
;
data
.
put
(
"
collections
"
collections
)
;
data
.
put
(
"
reason
"
reason
)
;
payload
.
put
(
"
data
"
data
)
;
return
payload
;
}
Override
public
void
handleRequestFailure
(
SyncStorageResponse
response
)
{
BaseResource
.
consumeEntity
(
response
)
;
localAccountGUIDDownloaded
=
false
;
try
{
Logger
.
info
(
LOG_TAG
"
Client
upload
failed
.
Aborting
sync
.
"
)
;
doAbort
(
new
HTTPFailureException
(
response
)
"
Client
download
failed
.
"
)
;
}
finally
{
closeDataAccessor
(
)
;
}
}
Override
public
void
handleRequestError
(
Exception
ex
)
{
localAccountGUIDDownloaded
=
false
;
try
{
Logger
.
info
(
LOG_TAG
"
Client
upload
error
.
Aborting
sync
.
"
)
;
doAbort
(
ex
"
Failure
fetching
client
record
.
"
)
;
}
finally
{
closeDataAccessor
(
)
;
}
}
Override
public
void
handleWBO
(
CryptoRecord
record
)
{
ClientRecord
r
;
try
{
r
=
(
ClientRecord
)
factory
.
createRecord
(
record
.
decrypt
(
)
)
;
if
(
clientsDelegate
.
isLocalGUID
(
r
.
guid
)
)
{
Logger
.
info
(
LOG_TAG
"
Local
client
GUID
exists
on
server
and
was
downloaded
.
"
)
;
localAccountGUIDDownloaded
=
true
;
handleDownloadedLocalRecord
(
r
)
;
}
else
{
wipeAndStore
(
r
)
;
addCommands
(
r
)
;
telemetryStageCollector
.
getSyncCollector
(
)
.
addDevice
(
r
)
;
}
RepoUtils
.
logClient
(
r
)
;
}
catch
(
Exception
e
)
{
doAbort
(
e
"
Exception
handling
client
WBO
.
"
)
;
return
;
}
}
Override
public
KeyBundle
keyBundle
(
)
{
try
{
return
session
.
keyBundleForCollection
(
COLLECTION_NAME
)
;
}
catch
(
NoCollectionKeysSetException
e
)
{
return
null
;
}
}
}
public
class
ClientUploadDelegate
extends
WBORequestDelegate
{
protected
static
final
String
LOG_TAG
=
"
ClientUploadDelegate
"
;
public
Long
currentlyUploadingRecordTimestamp
;
public
boolean
currentlyUploadingLocalRecord
;
Override
public
AuthHeaderProvider
getAuthHeaderProvider
(
)
{
return
session
.
getAuthHeaderProvider
(
)
;
}
private
void
setUploadDetails
(
boolean
isLocalRecord
)
{
currentlyUploadingRecordTimestamp
=
session
.
config
.
getPersistedServerClientsTimestamp
(
)
;
currentlyUploadingLocalRecord
=
isLocalRecord
;
}
Override
public
String
ifUnmodifiedSince
(
)
{
Long
timestampInMilliseconds
=
currentlyUploadingRecordTimestamp
;
if
(
timestampInMilliseconds
<
=
0
)
{
return
null
;
}
return
Utils
.
millisecondsToDecimalSecondsString
(
timestampInMilliseconds
)
;
}
Override
public
void
handleRequestSuccess
(
SyncStorageResponse
response
)
{
Logger
.
debug
(
LOG_TAG
"
Upload
succeeded
.
"
)
;
uploadAttemptsCount
.
set
(
0
)
;
final
long
responseTimestamp
=
response
.
normalizedWeaveTimestamp
(
)
;
Logger
.
trace
(
LOG_TAG
"
Timestamp
from
header
is
:
"
+
responseTimestamp
)
;
if
(
responseTimestamp
=
=
-
1
)
{
final
String
message
=
"
Response
did
not
contain
a
valid
timestamp
.
"
;
doAbort
(
new
RuntimeException
(
message
)
message
)
;
return
;
}
BaseResource
.
consumeEntity
(
response
)
;
session
.
config
.
persistServerClientsTimestamp
(
responseTimestamp
)
;
if
(
!
currentlyUploadingLocalRecord
)
{
clearRecordsToUpload
(
)
;
checkAndUpload
(
)
;
return
;
}
shouldUploadLocalRecord
=
false
;
session
.
config
.
persistServerClientRecordTimestamp
(
responseTimestamp
)
;
doAdvance
(
)
;
}
Override
public
void
handleRequestFailure
(
SyncStorageResponse
response
)
{
int
statusCode
=
response
.
getStatusCode
(
)
;
if
(
!
shouldUploadLocalRecord
|
|
statusCode
=
=
HttpStatus
.
SC_PRECONDITION_FAILED
|
|
uploadAttemptsCount
.
incrementAndGet
(
)
>
MAX_UPLOAD_FAILURE_COUNT
)
{
Logger
.
debug
(
LOG_TAG
"
Client
upload
failed
.
Aborting
sync
.
"
)
;
if
(
!
currentlyUploadingLocalRecord
)
{
modifiedClientsToUpload
.
clear
(
)
;
}
BaseResource
.
consumeEntity
(
response
)
;
doAbort
(
new
HTTPFailureException
(
response
)
"
Client
upload
failed
.
"
)
;
return
;
}
Logger
.
trace
(
LOG_TAG
"
Retrying
upload
"
)
;
checkAndUpload
(
)
;
}
Override
public
void
handleRequestError
(
Exception
ex
)
{
Logger
.
info
(
LOG_TAG
"
Client
upload
error
.
Aborting
sync
.
"
)
;
doAbort
(
ex
"
Client
upload
failed
.
"
)
;
}
Override
public
KeyBundle
keyBundle
(
)
{
try
{
return
session
.
keyBundleForCollection
(
COLLECTION_NAME
)
;
}
catch
(
NoCollectionKeysSetException
e
)
{
return
null
;
}
}
}
Override
public
void
execute
(
)
throws
NoSuchStageException
{
boolean
enabledThisSync
=
session
.
isEngineLocallyEnabled
(
STAGE_NAME
)
;
if
(
!
enabledThisSync
)
{
Logger
.
debug
(
LOG_TAG
"
Stage
"
+
STAGE_NAME
+
"
disabled
just
for
this
sync
.
"
)
;
Logger
.
info
(
LOG_TAG
"
Skipping
stage
"
+
STAGE_NAME
+
"
.
"
)
;
doAdvance
(
)
;
return
;
}
if
(
shouldDownload
(
)
)
{
downloadClientRecords
(
)
;
}
else
{
}
}
Override
protected
void
resetLocal
(
)
{
session
.
config
.
persistServerClientRecordTimestamp
(
0L
)
;
session
.
config
.
persistServerClientsTimestamp
(
0L
)
;
session
.
getClientsDelegate
(
)
.
setClientsCount
(
0
)
;
try
{
getClientsDatabaseAccessor
(
)
.
wipeDB
(
)
;
}
finally
{
closeDataAccessor
(
)
;
}
}
Override
protected
void
wipeLocal
(
)
throws
Exception
{
this
.
resetLocal
(
)
;
}
Override
public
Integer
getStorageVersion
(
)
{
return
VersionConstants
.
CLIENTS_ENGINE_VERSION
;
}
protected
String
getLocalClientVersion
(
)
{
return
AppConstants
.
MOZ_APP_VERSION
;
}
SuppressWarnings
(
"
unchecked
"
)
protected
JSONArray
getLocalClientProtocols
(
)
{
final
JSONArray
protocols
=
new
JSONArray
(
)
;
protocols
.
add
(
ClientRecord
.
PROTOCOL_LEGACY_SYNC
)
;
protocols
.
add
(
ClientRecord
.
PROTOCOL_FXA_SYNC
)
;
return
protocols
;
}
protected
ClientRecord
newLocalClientRecord
(
ClientsDataDelegate
delegate
)
{
final
String
ourGUID
=
delegate
.
getAccountGUID
(
)
;
final
String
ourName
=
delegate
.
getClientName
(
)
;
ClientRecord
r
=
new
ClientRecord
(
ourGUID
)
;
r
.
name
=
ourName
;
r
.
version
=
getLocalClientVersion
(
)
;
r
.
protocols
=
getLocalClientProtocols
(
)
;
r
.
os
=
"
Android
"
;
r
.
application
=
AppConstants
.
MOZ_APP_DISPLAYNAME
;
r
.
appPackage
=
AppConstants
.
ANDROID_PACKAGE_NAME
;
r
.
device
=
android
.
os
.
Build
.
MODEL
;
r
.
formfactor
=
delegate
.
getFormFactor
(
)
;
Context
context
=
session
.
getContext
(
)
;
final
Account
account
=
FirefoxAccounts
.
getFirefoxAccount
(
context
)
;
if
(
account
!
=
null
)
{
final
AndroidFxAccount
fxAccount
=
new
AndroidFxAccount
(
context
account
)
;
final
String
deviceId
=
fxAccount
.
getDeviceId
(
)
;
if
(
!
TextUtils
.
isEmpty
(
deviceId
)
)
{
r
.
fxaDeviceId
=
deviceId
;
}
}
return
r
;
}
protected
boolean
shouldDownload
(
)
{
return
true
;
}
protected
boolean
shouldUpload
(
)
{
if
(
shouldUploadLocalRecord
)
{
return
true
;
}
long
lastUpload
=
session
.
config
.
getPersistedServerClientRecordTimestamp
(
)
;
if
(
lastUpload
=
=
0
)
{
return
true
;
}
if
(
session
.
getClientsDelegate
(
)
.
getLastModifiedTimestamp
(
)
>
lastUpload
)
{
return
true
;
}
long
now
=
System
.
currentTimeMillis
(
)
;
long
age
=
now
-
lastUpload
;
return
age
>
=
CLIENTS_TTL_REFRESH
;
}
protected
void
handleDownloadedLocalRecord
(
ClientRecord
r
)
{
session
.
config
.
persistServerClientRecordTimestamp
(
r
.
lastModified
)
;
if
(
!
getLocalClientVersion
(
)
.
equals
(
r
.
version
)
|
|
!
getLocalClientProtocols
(
)
.
equals
(
r
.
protocols
)
)
{
shouldUploadLocalRecord
=
true
;
}
processCommands
(
r
.
commands
)
;
}
protected
void
processCommands
(
JSONArray
commands
)
{
if
(
commands
=
=
null
|
|
commands
.
size
(
)
=
=
0
)
{
return
;
}
shouldUploadLocalRecord
=
true
;
CommandProcessor
processor
=
CommandProcessor
.
getProcessor
(
)
;
for
(
Object
o
:
commands
)
{
processor
.
processCommand
(
session
new
ExtendedJSONObject
(
(
JSONObject
)
o
)
)
;
}
}
SuppressWarnings
(
"
unchecked
"
)
protected
void
addCommands
(
ClientRecord
record
)
throws
NullCursorException
{
Logger
.
trace
(
LOG_TAG
"
Adding
commands
to
"
+
record
.
guid
)
;
List
<
Command
>
commands
=
db
.
fetchCommandsForClient
(
record
.
guid
)
;
if
(
commands
=
=
null
|
|
commands
.
size
(
)
=
=
0
)
{
Logger
.
trace
(
LOG_TAG
"
No
commands
to
add
.
"
)
;
return
;
}
for
(
Command
command
:
commands
)
{
JSONObject
jsonCommand
=
command
.
asJSONObject
(
)
;
if
(
record
.
commands
=
=
null
)
{
record
.
commands
=
new
JSONArray
(
)
;
}
record
.
commands
.
add
(
jsonCommand
)
;
}
modifiedClientsToUpload
.
add
(
record
)
;
}
SuppressWarnings
(
"
unchecked
"
)
protected
void
uploadRemoteRecords
(
)
{
Logger
.
trace
(
LOG_TAG
"
In
uploadRemoteRecords
.
Uploading
"
+
modifiedClientsToUpload
.
size
(
)
+
"
records
"
)
;
for
(
ClientRecord
r
:
modifiedClientsToUpload
)
{
Logger
.
trace
(
LOG_TAG
"
>
>
Uploading
record
"
+
r
.
guid
+
"
:
"
+
r
.
name
)
;
}
if
(
modifiedClientsToUpload
.
size
(
)
=
=
1
)
{
ClientRecord
record
=
modifiedClientsToUpload
.
get
(
0
)
;
Logger
.
debug
(
LOG_TAG
"
Only
1
remote
record
to
upload
.
"
)
;
Logger
.
debug
(
LOG_TAG
"
Record
last
modified
:
"
+
record
.
lastModified
)
;
CryptoRecord
cryptoRecord
=
encryptClientRecord
(
record
)
;
if
(
cryptoRecord
!
=
null
)
{
clientUploadDelegate
.
setUploadDetails
(
false
)
;
this
.
uploadClientRecord
(
cryptoRecord
)
;
}
return
;
}
JSONArray
cryptoRecords
=
new
JSONArray
(
)
;
for
(
ClientRecord
record
:
modifiedClientsToUpload
)
{
Logger
.
trace
(
LOG_TAG
"
Record
"
+
record
.
guid
+
"
is
being
uploaded
"
)
;
CryptoRecord
cryptoRecord
=
encryptClientRecord
(
record
)
;
cryptoRecords
.
add
(
cryptoRecord
.
toJSONObject
(
)
)
;
}
Logger
.
debug
(
LOG_TAG
"
Uploading
records
:
"
+
cryptoRecords
.
size
(
)
)
;
clientUploadDelegate
.
setUploadDetails
(
false
)
;
this
.
uploadClientRecords
(
cryptoRecords
)
;
}
protected
void
checkAndUpload
(
)
{
if
(
!
shouldUpload
(
)
)
{
Logger
.
debug
(
LOG_TAG
"
Not
uploading
client
record
.
"
)
;
doAdvance
(
)
;
return
;
}
final
ClientRecord
localClient
=
newLocalClientRecord
(
session
.
getClientsDelegate
(
)
)
;
clientUploadDelegate
.
setUploadDetails
(
true
)
;
CryptoRecord
cryptoRecord
=
encryptClientRecord
(
localClient
)
;
if
(
cryptoRecord
!
=
null
)
{
this
.
uploadClientRecord
(
cryptoRecord
)
;
}
}
protected
CryptoRecord
encryptClientRecord
(
ClientRecord
recordToUpload
)
{
final
String
encryptionFailure
=
"
Couldn
'
t
encrypt
new
client
record
.
"
;
try
{
CryptoRecord
cryptoRecord
=
recordToUpload
.
getEnvelope
(
)
;
cryptoRecord
.
keyBundle
=
clientUploadDelegate
.
keyBundle
(
)
;
if
(
cryptoRecord
.
keyBundle
=
=
null
)
{
doAbort
(
new
NoCollectionKeysSetException
(
)
"
No
collection
keys
set
.
"
)
;
return
null
;
}
return
cryptoRecord
.
encrypt
(
)
;
}
catch
(
CryptoException
e
)
{
doAbort
(
e
encryptionFailure
)
;
}
return
null
;
}
public
void
clearRecordsToUpload
(
)
{
try
{
getClientsDatabaseAccessor
(
)
.
wipeCommandsTable
(
)
;
modifiedClientsToUpload
.
clear
(
)
;
}
finally
{
closeDataAccessor
(
)
;
}
}
protected
void
downloadClientRecords
(
)
{
shouldWipe
=
true
;
clientDownloadDelegate
=
makeClientDownloadDelegate
(
)
;
try
{
final
URI
getURI
=
session
.
config
.
collectionURI
(
COLLECTION_NAME
true
)
;
final
SyncStorageCollectionRequest
request
=
new
SyncStorageCollectionRequest
(
getURI
)
;
request
.
delegate
=
clientDownloadDelegate
;
Logger
.
trace
(
LOG_TAG
"
Downloading
client
records
.
"
)
;
request
.
get
(
)
;
}
catch
(
URISyntaxException
e
)
{
doAbort
(
e
"
Invalid
URI
.
"
)
;
}
}
protected
void
uploadClientRecords
(
JSONArray
records
)
{
Logger
.
trace
(
LOG_TAG
"
Uploading
"
+
records
.
size
(
)
+
"
client
records
.
"
)
;
try
{
final
URI
postURI
=
session
.
config
.
collectionURI
(
COLLECTION_NAME
false
)
;
final
SyncStorageRecordRequest
request
=
new
SyncStorageRecordRequest
(
postURI
)
;
request
.
delegate
=
clientUploadDelegate
;
request
.
post
(
records
)
;
}
catch
(
URISyntaxException
e
)
{
doAbort
(
e
"
Invalid
URI
.
"
)
;
}
catch
(
Exception
e
)
{
doAbort
(
e
"
Unable
to
parse
body
.
"
)
;
}
}
protected
void
uploadClientRecord
(
CryptoRecord
record
)
{
Logger
.
debug
(
LOG_TAG
"
Uploading
client
record
"
+
record
.
guid
)
;
try
{
final
URI
postURI
=
session
.
config
.
collectionURI
(
COLLECTION_NAME
)
;
final
SyncStorageRecordRequest
request
=
new
SyncStorageRecordRequest
(
postURI
)
;
request
.
delegate
=
clientUploadDelegate
;
request
.
post
(
record
)
;
}
catch
(
URISyntaxException
e
)
{
doAbort
(
e
"
Invalid
URI
.
"
)
;
}
}
protected
ClientDownloadDelegate
makeClientDownloadDelegate
(
)
{
return
new
ClientDownloadDelegate
(
)
;
}
protected
void
wipeAndStore
(
ClientRecord
record
)
{
final
ClientsDatabaseAccessor
db
=
getClientsDatabaseAccessor
(
)
;
if
(
shouldWipe
)
{
db
.
wipeClientsTable
(
)
;
shouldWipe
=
false
;
}
if
(
record
!
=
null
)
{
db
.
store
(
record
)
;
}
}
private
void
doAdvance
(
)
{
telemetryStageCollector
.
finished
=
SystemClock
.
elapsedRealtime
(
)
;
session
.
advance
(
)
;
}
private
void
doAbort
(
Exception
e
String
reason
)
{
telemetryStageCollector
.
finished
=
SystemClock
.
elapsedRealtime
(
)
;
telemetryStageCollector
.
error
=
new
TelemetryCollector
.
StageErrorBuilder
(
)
.
setLastException
(
e
)
.
build
(
)
;
session
.
abort
(
e
reason
)
;
}
}
