package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
;
import
android
.
database
.
Cursor
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InactiveSessionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InvalidRequestException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
MultipleRecordsForGuidException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NoGuidForIdException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
ParentNotFoundException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
ProfileDatabaseException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RecordFilter
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
StoreTrackingRepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionWipeDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
abstract
class
SessionHelper
{
private
final
static
String
LOG_TAG
=
"
SessionHelper
"
;
protected
final
StoreTrackingRepositorySession
session
;
private
SparseArray
<
String
>
recordToGuid
;
final
AndroidBrowserRepositoryDataAccessor
dbHelper
;
SessionHelper
(
StoreTrackingRepositorySession
session
AndroidBrowserRepositoryDataAccessor
dbHelper
)
{
this
.
session
=
session
;
this
.
dbHelper
=
dbHelper
;
}
abstract
Record
retrieveDuringFetch
(
Cursor
cursor
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
;
abstract
Runnable
getWipeRunnable
(
RepositorySessionWipeDelegate
delegate
)
;
abstract
void
fixupRecord
(
Record
record
)
;
abstract
boolean
shouldIgnore
(
Record
record
)
;
abstract
Record
retrieveDuringStore
(
Cursor
cursor
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
;
abstract
void
storeRecordDeletion
(
RepositorySessionStoreDelegate
storeDelegate
Record
record
Record
existingRecord
)
;
abstract
String
buildRecordString
(
Record
record
)
;
abstract
Record
processBeforeInsertion
(
Record
toProcess
)
;
abstract
void
insert
(
RepositorySessionStoreDelegate
delegate
Record
record
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
;
abstract
Record
reconcileRecords
(
final
Record
remoteRecord
final
Record
localRecord
final
long
lastRemoteRetrieval
final
long
lastLocalRetrieval
)
;
abstract
Record
transformRecord
(
Record
record
)
;
abstract
Record
prepareRecord
(
Record
record
)
;
abstract
void
doBegin
(
)
throws
NullCursorException
;
abstract
Runnable
getStoreDoneRunnable
(
RepositorySessionStoreDelegate
delegate
)
;
void
updateBookkeeping
(
Record
record
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
putRecordToGuidMap
(
buildRecordString
(
record
)
record
.
guid
)
;
}
abstract
boolean
doReplaceRecord
(
Record
toStore
Record
existingRecord
RepositorySessionStoreDelegate
delegate
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
;
abstract
boolean
isLocallyModified
(
Record
record
)
;
void
checkDatabase
(
)
throws
ProfileDatabaseException
NullCursorException
{
Logger
.
debug
(
LOG_TAG
"
BEGIN
:
checking
database
.
"
)
;
try
{
dbHelper
.
fetch
(
new
String
[
]
{
"
none
"
}
)
.
close
(
)
;
Logger
.
debug
(
LOG_TAG
"
END
:
checking
database
.
"
)
;
}
catch
(
NullPointerException
e
)
{
throw
new
ProfileDatabaseException
(
e
)
;
}
}
void
finish
(
)
{
recordToGuid
=
null
;
}
private
void
putRecordToGuidMap
(
String
recordString
String
guid
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
if
(
recordString
=
=
null
)
{
return
;
}
if
(
recordToGuid
=
=
null
)
{
createRecordToGuidMap
(
)
;
}
recordToGuid
.
put
(
recordString
.
hashCode
(
)
guid
)
;
}
Runnable
getStoreRunnable
(
final
Record
record
final
RepositorySessionStoreDelegate
storeDelegate
)
{
return
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
!
session
.
isActive
(
)
)
{
Logger
.
warn
(
LOG_TAG
"
AndroidBrowserRepositorySession
is
inactive
.
Store
failing
.
"
)
;
storeDelegate
.
onRecordStoreFailed
(
new
InactiveSessionException
(
)
record
.
guid
)
;
return
;
}
if
(
shouldIgnore
(
record
)
)
{
Logger
.
debug
(
LOG_TAG
"
Ignoring
record
"
+
record
.
guid
)
;
return
;
}
long
lastLocalRetrieval
=
0
;
long
lastRemoteRetrieval
=
0
;
boolean
remotelyModified
=
record
.
lastModified
>
lastRemoteRetrieval
;
Record
existingRecord
;
try
{
final
int
maxReconcileAttempts
=
10
;
int
reconcileAttempt
=
1
;
do
{
existingRecord
=
retrieveByGUIDDuringStore
(
record
.
guid
)
;
if
(
record
.
deleted
)
{
if
(
existingRecord
=
=
null
)
{
trace
(
"
Incoming
record
"
+
record
.
guid
+
"
is
deleted
and
no
local
version
.
Bye
!
"
)
;
break
;
}
if
(
existingRecord
.
deleted
)
{
trace
(
"
Local
record
already
deleted
.
Bye
!
"
)
;
break
;
}
if
(
!
remotelyModified
)
{
trace
(
"
Ignoring
deleted
record
from
the
past
.
"
)
;
break
;
}
if
(
!
isLocallyModified
(
existingRecord
)
)
{
trace
(
"
Remote
modified
local
not
.
Deleting
.
"
)
;
storeRecordDeletion
(
storeDelegate
record
existingRecord
)
;
break
;
}
trace
(
"
Both
local
and
remote
records
have
been
modified
.
"
)
;
if
(
record
.
lastModified
>
existingRecord
.
lastModified
)
{
trace
(
"
Remote
is
newer
and
deleted
.
Deleting
local
.
"
)
;
storeRecordDeletion
(
storeDelegate
record
existingRecord
)
;
break
;
}
trace
(
"
Remote
is
older
local
is
not
deleted
.
Ignoring
.
"
)
;
break
;
}
fixupRecord
(
record
)
;
if
(
existingRecord
=
=
null
)
{
trace
(
"
Looking
up
match
for
record
"
+
record
.
guid
)
;
existingRecord
=
findExistingRecord
(
record
)
;
}
if
(
existingRecord
=
=
null
)
{
trace
(
"
No
match
.
Inserting
.
"
)
;
insert
(
storeDelegate
processBeforeInsertion
(
record
)
)
;
break
;
}
trace
(
"
Incoming
record
"
+
record
.
guid
+
"
dupes
to
local
record
"
+
existingRecord
.
guid
)
;
existingRecord
=
transformRecord
(
existingRecord
)
;
Record
toStore
=
reconcileRecords
(
record
existingRecord
lastRemoteRetrieval
lastLocalRetrieval
)
;
if
(
toStore
=
=
null
)
{
Logger
.
debug
(
LOG_TAG
"
Reconciling
returned
null
.
Not
inserting
a
record
.
"
)
;
break
;
}
Logger
.
debug
(
LOG_TAG
"
Reconcile
attempt
#
"
+
reconcileAttempt
)
;
boolean
replaceSuccessful
=
doReplaceRecord
(
toStore
existingRecord
storeDelegate
)
;
if
(
replaceSuccessful
)
{
Logger
.
debug
(
LOG_TAG
"
Successfully
reconciled
record
on
attempt
#
"
+
reconcileAttempt
)
;
break
;
}
reconcileAttempt
+
=
1
;
}
while
(
reconcileAttempt
<
=
maxReconcileAttempts
)
;
if
(
reconcileAttempt
>
maxReconcileAttempts
)
{
Logger
.
error
(
LOG_TAG
"
Failed
to
store
record
within
maximum
number
of
allowed
attempts
:
"
+
record
.
guid
)
;
storeDelegate
.
onRecordStoreFailed
(
new
IllegalStateException
(
"
Reached
maximum
storage
attempts
for
a
record
"
)
record
.
guid
)
;
}
else
{
Logger
.
info
(
LOG_TAG
"
Stored
after
reconcile
attempt
#
"
+
reconcileAttempt
)
;
}
}
catch
(
MultipleRecordsForGuidException
e
)
{
Logger
.
error
(
LOG_TAG
"
Multiple
records
returned
for
given
guid
:
"
+
record
.
guid
)
;
storeDelegate
.
onRecordStoreFailed
(
e
record
.
guid
)
;
}
catch
(
NoGuidForIdException
e
)
{
Logger
.
error
(
LOG_TAG
"
Store
failed
for
"
+
record
.
guid
e
)
;
storeDelegate
.
onRecordStoreFailed
(
e
record
.
guid
)
;
}
catch
(
Exception
e
)
{
Logger
.
error
(
LOG_TAG
"
Store
failed
for
"
+
record
.
guid
e
)
;
storeDelegate
.
onRecordStoreFailed
(
e
record
.
guid
)
;
}
}
}
;
}
private
Record
findExistingRecord
(
Record
record
)
throws
MultipleRecordsForGuidException
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
Logger
.
debug
(
LOG_TAG
"
Finding
existing
record
for
incoming
record
with
GUID
"
+
record
.
guid
)
;
String
recordString
=
buildRecordString
(
record
)
;
if
(
recordString
=
=
null
)
{
Logger
.
debug
(
LOG_TAG
"
No
record
string
for
incoming
record
"
+
record
.
guid
)
;
return
null
;
}
if
(
Logger
.
LOG_PERSONAL_INFORMATION
)
{
Logger
.
pii
(
LOG_TAG
"
Searching
with
record
string
"
+
recordString
)
;
}
else
{
Logger
.
debug
(
LOG_TAG
"
Searching
with
record
string
.
"
)
;
}
String
guid
=
getGuidForString
(
recordString
)
;
if
(
guid
=
=
null
)
{
Logger
.
debug
(
LOG_TAG
"
Failed
to
find
existing
record
for
"
+
record
.
guid
)
;
return
null
;
}
Logger
.
debug
(
LOG_TAG
"
Found
one
.
Checking
stored
record
.
"
)
;
Record
stored
=
retrieveByGUIDDuringStore
(
guid
)
;
String
storedRecordString
=
buildRecordString
(
record
)
;
if
(
recordString
.
equals
(
storedRecordString
)
)
{
Logger
.
debug
(
LOG_TAG
"
Existing
record
matches
incoming
record
.
Returning
existing
record
.
"
)
;
return
stored
;
}
Logger
.
debug
(
LOG_TAG
"
Existing
record
does
not
match
incoming
record
.
Trying
to
find
record
by
record
string
.
"
)
;
return
findByRecordString
(
recordString
)
;
}
private
Record
findByRecordString
(
String
recordString
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
Cursor
cur
=
dbHelper
.
fetchAll
(
)
;
try
{
if
(
!
cur
.
moveToFirst
(
)
)
{
return
null
;
}
while
(
!
cur
.
isAfterLast
(
)
)
{
Record
record
=
retrieveDuringStore
(
cur
)
;
if
(
record
!
=
null
)
{
final
String
storedRecordString
=
buildRecordString
(
record
)
;
if
(
recordString
.
equals
(
storedRecordString
)
)
{
return
record
;
}
}
cur
.
moveToNext
(
)
;
}
return
null
;
}
finally
{
cur
.
close
(
)
;
}
}
private
String
getGuidForString
(
String
recordString
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
if
(
recordToGuid
=
=
null
)
{
createRecordToGuidMap
(
)
;
}
return
recordToGuid
.
get
(
recordString
.
hashCode
(
)
)
;
}
private
void
createRecordToGuidMap
(
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
{
Logger
.
info
(
LOG_TAG
"
BEGIN
:
creating
record
-
>
GUID
map
.
"
)
;
recordToGuid
=
new
SparseArray
<
>
(
)
;
Cursor
cur
=
dbHelper
.
fetchAll
(
)
;
try
{
if
(
!
cur
.
moveToFirst
(
)
)
{
return
;
}
while
(
!
cur
.
isAfterLast
(
)
)
{
Record
record
=
retrieveDuringStore
(
cur
)
;
if
(
record
!
=
null
)
{
final
String
recordString
=
buildRecordString
(
record
)
;
if
(
recordString
!
=
null
)
{
recordToGuid
.
put
(
recordString
.
hashCode
(
)
record
.
guid
)
;
}
}
cur
.
moveToNext
(
)
;
}
}
finally
{
cur
.
close
(
)
;
}
Logger
.
info
(
LOG_TAG
"
END
:
creating
record
-
>
GUID
map
.
"
)
;
}
Runnable
getFetchSinceRunnable
(
long
since
long
end
RecordFilter
filter
RepositorySessionFetchRecordsDelegate
delegate
)
{
return
new
FetchSinceRunnable
(
since
end
filter
delegate
)
;
}
Runnable
getFetchRunnable
(
String
[
]
guids
long
end
RecordFilter
filter
RepositorySessionFetchRecordsDelegate
delegate
)
{
return
new
FetchRunnable
(
guids
end
filter
delegate
)
;
}
private
class
FetchSinceRunnable
extends
FetchingRunnable
{
private
final
long
since
;
private
final
long
end
;
private
final
RecordFilter
filter
;
FetchSinceRunnable
(
long
since
long
end
RecordFilter
filter
RepositorySessionFetchRecordsDelegate
delegate
)
{
super
(
delegate
)
;
this
.
since
=
since
;
this
.
end
=
end
;
this
.
filter
=
filter
;
}
Override
public
void
run
(
)
{
if
(
!
session
.
isActive
(
)
)
{
delegate
.
onFetchFailed
(
new
InactiveSessionException
(
)
)
;
return
;
}
try
{
Cursor
cursor
=
dbHelper
.
fetchSince
(
since
)
;
this
.
fetchFromCursor
(
cursor
filter
end
)
;
}
catch
(
NullCursorException
e
)
{
delegate
.
onFetchFailed
(
e
)
;
}
}
}
private
class
FetchRunnable
extends
FetchingRunnable
{
private
final
String
[
]
guids
;
private
final
long
end
;
private
final
RecordFilter
filter
;
FetchRunnable
(
String
[
]
guids
long
end
RecordFilter
filter
RepositorySessionFetchRecordsDelegate
delegate
)
{
super
(
delegate
)
;
this
.
guids
=
guids
;
this
.
end
=
end
;
this
.
filter
=
filter
;
}
Override
public
void
run
(
)
{
if
(
!
session
.
isActive
(
)
)
{
delegate
.
onFetchFailed
(
new
InactiveSessionException
(
)
)
;
return
;
}
if
(
guids
=
=
null
|
|
guids
.
length
<
1
)
{
Logger
.
error
(
LOG_TAG
"
No
guids
sent
to
fetch
"
)
;
delegate
.
onFetchFailed
(
new
InvalidRequestException
(
)
)
;
return
;
}
try
{
Cursor
cursor
=
dbHelper
.
fetch
(
guids
)
;
this
.
fetchFromCursor
(
cursor
filter
end
)
;
}
catch
(
NullCursorException
e
)
{
delegate
.
onFetchFailed
(
e
)
;
}
}
}
abstract
class
FetchingRunnable
implements
Runnable
{
protected
final
RepositorySessionFetchRecordsDelegate
delegate
;
FetchingRunnable
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
this
.
delegate
=
delegate
;
}
void
fetchFromCursor
(
Cursor
cursor
RecordFilter
filter
long
end
)
{
Logger
.
debug
(
LOG_TAG
"
Fetch
from
cursor
:
"
)
;
try
{
try
{
if
(
!
cursor
.
moveToFirst
(
)
)
{
delegate
.
onFetchCompleted
(
end
)
;
return
;
}
while
(
!
cursor
.
isAfterLast
(
)
)
{
Record
r
=
retrieveDuringFetch
(
cursor
)
;
if
(
r
!
=
null
)
{
if
(
filter
=
=
null
|
|
!
filter
.
excludeRecord
(
r
)
)
{
Logger
.
trace
(
LOG_TAG
"
Processing
record
"
+
r
.
guid
)
;
delegate
.
onFetchedRecord
(
transformRecord
(
r
)
)
;
}
else
{
Logger
.
debug
(
LOG_TAG
"
Skipping
filtered
record
"
+
r
.
guid
)
;
}
}
cursor
.
moveToNext
(
)
;
}
delegate
.
onFetchCompleted
(
end
)
;
}
catch
(
Exception
e
)
{
Logger
.
warn
(
LOG_TAG
"
Exception
in
fetchFromCursor
.
"
e
)
;
delegate
.
onFetchFailed
(
e
)
;
return
;
}
}
finally
{
Logger
.
trace
(
LOG_TAG
"
Closing
cursor
after
fetch
.
"
)
;
cursor
.
close
(
)
;
}
}
}
class
WipeRunnable
implements
Runnable
{
protected
RepositorySessionWipeDelegate
delegate
;
WipeRunnable
(
RepositorySessionWipeDelegate
delegate
)
{
this
.
delegate
=
delegate
;
}
Override
public
void
run
(
)
{
if
(
!
session
.
isActive
(
)
)
{
delegate
.
onWipeFailed
(
new
InactiveSessionException
(
)
)
;
return
;
}
dbHelper
.
wipe
(
)
;
delegate
.
onWipeSucceeded
(
)
;
}
}
private
Record
retrieveByGUIDDuringStore
(
String
guid
)
throws
NoGuidForIdException
NullCursorException
ParentNotFoundException
MultipleRecordsForGuidException
{
Cursor
cursor
=
dbHelper
.
fetch
(
new
String
[
]
{
guid
}
)
;
try
{
if
(
!
cursor
.
moveToFirst
(
)
)
{
return
null
;
}
Record
r
=
retrieveDuringStore
(
cursor
)
;
cursor
.
moveToNext
(
)
;
if
(
cursor
.
isAfterLast
(
)
)
{
return
r
;
}
throw
(
new
MultipleRecordsForGuidException
(
null
)
)
;
}
finally
{
cursor
.
close
(
)
;
}
}
protected
static
void
trace
(
String
message
)
{
Logger
.
trace
(
LOG_TAG
message
)
;
}
}
