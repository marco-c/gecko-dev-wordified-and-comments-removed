package
org
.
mozilla
.
gecko
.
sync
.
synchronizer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
ExecutorService
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicReference
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
SyncException
;
import
org
.
mozilla
.
gecko
.
sync
.
synchronizer
.
StoreBatchTracker
.
Batch
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InactiveSessionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InvalidSessionTransitionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySessionBundle
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
DeferredRepositorySessionFinishDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFinishDelegate
;
import
android
.
content
.
Context
;
public
class
SynchronizerSession
implements
RecordsChannelDelegate
RepositorySessionFinishDelegate
{
protected
static
final
String
LOG_TAG
=
"
SynchronizerSession
"
;
protected
Synchronizer
synchronizer
;
protected
SynchronizerSessionDelegate
delegate
;
protected
Context
context
;
private
RepositorySession
sessionA
;
private
RepositorySession
sessionB
;
private
RepositorySessionBundle
bundleA
;
private
RepositorySessionBundle
bundleB
;
private
long
pendingATimestamp
=
-
1
;
private
long
pendingBTimestamp
=
-
1
;
private
long
storeEndATimestamp
=
-
1
;
private
long
storeEndBTimestamp
=
-
1
;
private
boolean
flowAToBCompleted
=
false
;
private
boolean
flowBToACompleted
=
false
;
private
final
AtomicInteger
numInboundRecords
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicInteger
numInboundRecordsStored
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicInteger
numInboundRecordsFailed
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicInteger
numInboundRecordsReconciled
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicInteger
numOutboundRecords
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicInteger
numOutboundRecordsStored
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicInteger
numOutboundRecordsFailed
=
new
AtomicInteger
(
-
1
)
;
private
final
AtomicReference
<
List
<
Batch
>
>
outboundBatches
=
new
AtomicReference
<
>
(
)
;
private
Exception
fetchFailedCauseException
;
private
Exception
storeFailedCauseException
;
public
SynchronizerSession
(
Synchronizer
synchronizer
SynchronizerSessionDelegate
delegate
)
{
this
.
setSynchronizer
(
synchronizer
)
;
this
.
delegate
=
delegate
;
}
public
Synchronizer
getSynchronizer
(
)
{
return
synchronizer
;
}
public
void
setSynchronizer
(
Synchronizer
synchronizer
)
{
this
.
synchronizer
=
synchronizer
;
}
public
void
initAndSynchronize
(
Context
context
RepositorySessionBundle
bundleA
RepositorySessionBundle
bundleB
)
{
this
.
context
=
context
;
this
.
bundleA
=
bundleA
;
this
.
bundleB
=
bundleB
;
try
{
this
.
sessionA
=
this
.
getSynchronizer
(
)
.
repositoryA
.
createSession
(
context
)
;
}
catch
(
SyncException
e
)
{
this
.
context
=
null
;
this
.
delegate
.
onSynchronizeFailed
(
this
e
"
Failed
to
create
session
"
)
;
return
;
}
try
{
this
.
sessionA
.
unbundle
(
bundleA
)
;
}
catch
(
Exception
e
)
{
this
.
delegate
.
onSynchronizeFailed
(
this
new
UnbundleError
(
e
sessionA
)
"
Failed
to
unbundle
first
session
.
"
)
;
return
;
}
try
{
this
.
sessionB
=
this
.
getSynchronizer
(
)
.
repositoryB
.
createSession
(
context
)
;
}
catch
(
final
SyncException
createException
)
{
this
.
context
=
null
;
try
{
this
.
sessionA
.
finish
(
new
RepositorySessionFinishDelegate
(
)
{
Override
public
void
onFinishFailed
(
Exception
ex
)
{
SynchronizerSession
.
this
.
delegate
.
onSynchronizeFailed
(
SynchronizerSession
.
this
createException
"
Failed
to
create
second
session
.
"
)
;
}
Override
public
void
onFinishSucceeded
(
RepositorySession
session
RepositorySessionBundle
bundle
)
{
SynchronizerSession
.
this
.
delegate
.
onSynchronizeFailed
(
SynchronizerSession
.
this
createException
"
Failed
to
create
second
session
.
"
)
;
}
Override
public
RepositorySessionFinishDelegate
deferredFinishDelegate
(
ExecutorService
executor
)
{
return
new
DeferredRepositorySessionFinishDelegate
(
this
executor
)
;
}
}
)
;
}
catch
(
InactiveSessionException
finishException
)
{
SynchronizerSession
.
this
.
delegate
.
onSynchronizeFailed
(
SynchronizerSession
.
this
createException
"
Failed
to
create
second
session
.
"
)
;
}
return
;
}
try
{
this
.
sessionB
.
unbundle
(
bundleB
)
;
}
catch
(
Exception
e
)
{
this
.
delegate
.
onSynchronizeFailed
(
this
new
UnbundleError
(
e
sessionA
)
"
Failed
to
unbundle
second
session
.
"
)
;
}
synchronize
(
)
;
}
public
int
getInboundCount
(
)
{
return
numInboundRecords
.
get
(
)
;
}
public
int
getInboundCountStored
(
)
{
return
numInboundRecordsStored
.
get
(
)
;
}
public
int
getInboundCountFailed
(
)
{
return
numInboundRecordsFailed
.
get
(
)
;
}
public
int
getInboundCountReconciled
(
)
{
return
numInboundRecordsReconciled
.
get
(
)
;
}
public
List
<
Batch
>
getOutboundBatches
(
)
{
return
outboundBatches
.
get
(
)
;
}
public
int
getOutboundCount
(
)
{
return
numOutboundRecords
.
get
(
)
;
}
public
int
getOutboundCountStored
(
)
{
return
numOutboundRecordsStored
.
get
(
)
;
}
public
int
getOutboundCountFailed
(
)
{
return
numOutboundRecordsFailed
.
get
(
)
;
}
public
Exception
getFetchFailedCauseException
(
)
{
return
fetchFailedCauseException
;
}
public
Exception
getStoreFailedCauseException
(
)
{
return
storeFailedCauseException
;
}
protected
RecordsChannel
channelAToB
;
protected
RecordsChannel
channelBToA
;
private
synchronized
void
synchronize
(
)
{
numInboundRecords
.
set
(
-
1
)
;
numInboundRecordsStored
.
set
(
-
1
)
;
numInboundRecordsFailed
.
set
(
-
1
)
;
numInboundRecordsReconciled
.
set
(
-
1
)
;
numOutboundRecords
.
set
(
-
1
)
;
numOutboundRecordsStored
.
set
(
-
1
)
;
numOutboundRecordsFailed
.
set
(
-
1
)
;
outboundBatches
.
set
(
null
)
;
if
(
sessionA
.
shouldSkip
(
)
|
|
sessionB
.
shouldSkip
(
)
)
{
Logger
.
info
(
LOG_TAG
"
Session
requested
skip
.
Short
-
circuiting
sync
.
"
)
;
sessionA
.
abort
(
)
;
sessionB
.
abort
(
)
;
this
.
delegate
.
onSynchronizeSkipped
(
this
)
;
return
;
}
final
SynchronizerSession
session
=
this
;
channelBToA
=
new
RecordsChannel
(
this
.
sessionB
this
.
sessionA
this
)
;
RecordsChannelDelegate
channelAToBDelegate
=
new
RecordsChannelDelegate
(
)
{
Override
public
void
onFlowCompleted
(
RecordsChannel
recordsChannel
)
{
session
.
onFirstFlowCompleted
(
recordsChannel
)
;
}
Override
public
void
onFlowBeginFailed
(
RecordsChannel
recordsChannel
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
First
RecordsChannel
onFlowBeginFailed
.
Logging
session
error
.
"
ex
)
;
session
.
delegate
.
onSynchronizeFailed
(
session
ex
"
Failed
to
begin
first
flow
.
"
)
;
}
Override
public
void
onFlowFetchFailed
(
RecordsChannel
recordsChannel
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
First
RecordsChannel
onFlowFetchFailed
.
Logging
remote
fetch
error
.
"
ex
)
;
fetchFailedCauseException
=
ex
;
}
Override
public
void
onFlowStoreFailed
(
RecordsChannel
recordsChannel
Exception
ex
String
recordGuid
)
{
Logger
.
warn
(
LOG_TAG
"
First
RecordsChannel
onFlowStoreFailed
.
Logging
local
store
error
.
"
ex
)
;
storeFailedCauseException
=
ex
;
}
}
;
channelAToB
=
new
RecordsChannel
(
this
.
sessionA
this
.
sessionB
channelAToBDelegate
)
;
Logger
.
trace
(
LOG_TAG
"
Starting
A
to
B
flow
.
Channel
is
"
+
channelAToB
)
;
try
{
channelAToB
.
beginAndFlow
(
)
;
}
catch
(
InvalidSessionTransitionException
e
)
{
onFlowBeginFailed
(
channelAToB
e
)
;
}
}
public
void
onFirstFlowCompleted
(
RecordsChannel
recordsChannel
)
{
Logger
.
trace
(
LOG_TAG
"
First
RecordsChannel
onFlowCompleted
.
"
)
;
pendingATimestamp
=
sessionA
.
getLastFetchTimestamp
(
)
;
storeEndBTimestamp
=
sessionB
.
getLastStoreTimestamp
(
)
;
Logger
.
debug
(
LOG_TAG
"
Fetch
end
is
"
+
pendingATimestamp
+
"
.
Store
end
is
"
+
storeEndBTimestamp
+
"
.
Starting
next
.
"
)
;
numInboundRecords
.
set
(
recordsChannel
.
getFetchCount
(
)
)
;
numInboundRecordsStored
.
set
(
recordsChannel
.
getStoreAcceptedCount
(
)
)
;
numInboundRecordsFailed
.
set
(
recordsChannel
.
getStoreFailureCount
(
)
)
;
numInboundRecordsReconciled
.
set
(
recordsChannel
.
getStoreReconciledCount
(
)
)
;
flowAToBCompleted
=
true
;
channelBToA
.
flow
(
)
;
}
public
void
onSecondFlowCompleted
(
RecordsChannel
recordsChannel
)
{
Logger
.
trace
(
LOG_TAG
"
Second
RecordsChannel
onFlowCompleted
.
"
)
;
pendingBTimestamp
=
sessionB
.
getLastFetchTimestamp
(
)
;
storeEndATimestamp
=
sessionA
.
getLastStoreTimestamp
(
)
;
Logger
.
debug
(
LOG_TAG
"
Fetch
end
is
"
+
pendingBTimestamp
+
"
.
Store
end
is
"
+
storeEndATimestamp
+
"
.
Finishing
.
"
)
;
numOutboundRecords
.
set
(
recordsChannel
.
getFetchCount
(
)
)
;
numOutboundRecordsStored
.
set
(
recordsChannel
.
getStoreAcceptedCount
(
)
)
;
numOutboundRecordsFailed
.
set
(
recordsChannel
.
getStoreFailureCount
(
)
)
;
outboundBatches
.
set
(
recordsChannel
.
getStoreBatches
(
)
)
;
flowBToACompleted
=
true
;
try
{
this
.
sessionA
.
finish
(
this
)
;
}
catch
(
InactiveSessionException
e
)
{
this
.
onFinishFailed
(
e
)
;
return
;
}
}
Override
public
void
onFlowCompleted
(
RecordsChannel
recordsChannel
)
{
onSecondFlowCompleted
(
recordsChannel
)
;
}
Override
public
void
onFlowBeginFailed
(
RecordsChannel
recordsChannel
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
Second
RecordsChannel
onFlowBeginFailed
.
Logging
session
error
.
"
ex
)
;
this
.
delegate
.
onSynchronizeFailed
(
this
ex
"
Failed
to
begin
second
flow
.
"
)
;
}
Override
public
void
onFlowFetchFailed
(
RecordsChannel
recordsChannel
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
Second
RecordsChannel
onFlowFetchFailed
.
Logging
local
fetch
error
.
"
ex
)
;
}
Override
public
void
onFlowStoreFailed
(
RecordsChannel
recordsChannel
Exception
ex
String
recordGuid
)
{
Logger
.
warn
(
LOG_TAG
"
Second
RecordsChannel
onFlowStoreFailed
.
Logging
remote
store
error
.
"
ex
)
;
}
Override
public
void
onFinishFailed
(
Exception
ex
)
{
if
(
this
.
sessionB
=
=
null
)
{
Logger
.
warn
(
LOG_TAG
"
Got
exception
cleaning
up
first
after
second
session
creation
failed
.
"
ex
)
;
return
;
}
String
session
=
(
this
.
sessionA
=
=
null
)
?
"
B
"
:
"
A
"
;
this
.
delegate
.
onSynchronizeFailed
(
this
ex
"
Finish
of
session
"
+
session
+
"
failed
.
"
)
;
}
Override
public
void
onFinishSucceeded
(
RepositorySession
session
RepositorySessionBundle
bundle
)
{
Logger
.
debug
(
LOG_TAG
"
onFinishSucceeded
.
Flows
?
"
+
flowAToBCompleted
+
"
"
+
flowBToACompleted
)
;
if
(
session
=
=
sessionA
)
{
if
(
flowAToBCompleted
)
{
Logger
.
debug
(
LOG_TAG
"
onFinishSucceeded
:
bumping
session
A
'
s
timestamp
to
"
+
pendingATimestamp
+
"
or
"
+
storeEndATimestamp
)
;
bundle
.
bumpTimestamp
(
Math
.
max
(
pendingATimestamp
storeEndATimestamp
)
)
;
this
.
synchronizer
.
bundleA
=
bundle
;
}
else
{
this
.
delegate
.
onSynchronizeFailed
(
this
new
UnexpectedSessionException
(
sessionA
)
"
Failed
to
finish
first
session
.
"
)
;
return
;
}
if
(
this
.
sessionB
!
=
null
)
{
Logger
.
trace
(
LOG_TAG
"
Finishing
session
B
.
"
)
;
try
{
this
.
sessionB
.
finish
(
this
)
;
}
catch
(
InactiveSessionException
e
)
{
this
.
onFinishFailed
(
e
)
;
return
;
}
}
}
else
if
(
session
=
=
sessionB
)
{
if
(
flowBToACompleted
)
{
Logger
.
debug
(
LOG_TAG
"
onFinishSucceeded
:
bumping
session
B
'
s
timestamp
to
"
+
pendingBTimestamp
+
"
or
"
+
storeEndBTimestamp
)
;
bundle
.
bumpTimestamp
(
Math
.
max
(
pendingBTimestamp
storeEndBTimestamp
)
)
;
this
.
synchronizer
.
bundleB
=
bundle
;
Logger
.
trace
(
LOG_TAG
"
Notifying
delegate
.
onSynchronized
.
"
)
;
this
.
delegate
.
onSynchronized
(
this
)
;
}
else
{
this
.
delegate
.
onSynchronizeFailed
(
this
new
UnexpectedSessionException
(
sessionB
)
"
Failed
to
finish
second
session
.
"
)
;
return
;
}
}
else
{
}
if
(
this
.
sessionB
=
=
null
)
{
this
.
sessionA
=
null
;
}
}
Override
public
RepositorySessionFinishDelegate
deferredFinishDelegate
(
final
ExecutorService
executor
)
{
return
new
DeferredRepositorySessionFinishDelegate
(
this
executor
)
;
}
}
