package
org
.
mozilla
.
gecko
.
sync
.
validation
;
import
org
.
json
.
simple
.
JSONArray
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
BookmarkRecord
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Map
.
Entry
;
public
class
BookmarkValidator
{
private
List
<
BookmarkRecord
>
localRecords
;
private
List
<
BookmarkRecord
>
remoteRecords
;
private
Map
<
String
BookmarkRecord
>
remoteGUIDToRecord
=
new
HashMap
<
>
(
)
;
public
BookmarkValidator
(
List
<
BookmarkRecord
>
localRecords
List
<
BookmarkRecord
>
remoteRecords
)
{
this
.
localRecords
=
localRecords
;
this
.
remoteRecords
=
remoteRecords
;
for
(
BookmarkRecord
r
:
remoteRecords
)
{
remoteGUIDToRecord
.
put
(
r
.
guid
r
)
;
}
}
private
void
checkServerFolder
(
BookmarkRecord
r
BookmarkValidationResults
results
)
{
if
(
r
.
children
=
=
null
)
{
return
;
}
HashSet
<
String
>
seenChildGUIDs
=
new
HashSet
<
>
(
)
;
for
(
int
i
=
0
;
i
<
r
.
children
.
size
(
)
;
+
+
i
)
{
String
childGUID
=
(
String
)
r
.
children
.
get
(
i
)
;
if
(
seenChildGUIDs
.
contains
(
childGUID
)
)
{
results
.
duplicateChildren
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
r
.
guid
childGUID
)
)
;
continue
;
}
seenChildGUIDs
.
add
(
childGUID
)
;
BookmarkRecord
child
=
remoteGUIDToRecord
.
get
(
childGUID
)
;
if
(
child
=
=
null
)
{
results
.
missingChildren
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
r
.
guid
childGUID
)
)
;
continue
;
}
List
<
String
>
parentsContainingChild
=
results
.
multipleParents
.
get
(
childGUID
)
;
if
(
parentsContainingChild
=
=
null
)
{
parentsContainingChild
=
new
ArrayList
<
>
(
)
;
parentsContainingChild
.
add
(
r
.
guid
)
;
results
.
multipleParents
.
put
(
childGUID
parentsContainingChild
)
;
}
else
{
parentsContainingChild
.
add
(
r
.
guid
)
;
}
if
(
child
.
deleted
)
{
results
.
deletedChildren
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
r
.
guid
childGUID
)
)
;
continue
;
}
if
(
!
child
.
parentID
.
equals
(
r
.
guid
)
)
{
results
.
parentChildMismatches
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
r
.
guid
childGUID
)
)
;
}
}
}
private
void
checkServerParent
(
BookmarkRecord
record
BookmarkValidationResults
results
)
{
String
parentID
=
record
.
parentID
;
if
(
parentID
.
equals
(
"
places
"
)
)
{
return
;
}
BookmarkRecord
listedParent
=
remoteGUIDToRecord
.
get
(
parentID
)
;
if
(
listedParent
=
=
null
)
{
results
.
orphans
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
parentID
record
.
guid
)
)
;
return
;
}
if
(
listedParent
.
deleted
)
{
results
.
deletedParents
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
parentID
record
.
guid
)
)
;
}
else
if
(
!
listedParent
.
isFolder
(
)
)
{
results
.
parentNotFolder
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
parentID
record
.
guid
)
)
;
}
else
{
boolean
foundChild
=
false
;
for
(
int
i
=
0
;
i
<
listedParent
.
children
.
size
(
)
&
&
!
foundChild
;
+
+
i
)
{
String
childGUID
=
(
String
)
listedParent
.
children
.
get
(
i
)
;
foundChild
=
childGUID
.
equals
(
record
.
guid
)
;
}
if
(
!
foundChild
)
{
results
.
parentChildMismatches
.
add
(
new
BookmarkValidationResults
.
ParentChildPair
(
parentID
record
.
guid
)
)
;
}
}
}
private
void
inspectServerRecords
(
BookmarkValidationResults
results
)
{
for
(
BookmarkRecord
record
:
remoteRecords
)
{
if
(
record
.
deleted
)
{
continue
;
}
if
(
record
.
guid
.
equals
(
"
places
"
)
)
{
results
.
rootOnServer
=
true
;
continue
;
}
if
(
record
.
isFolder
(
)
)
{
checkServerFolder
(
record
results
)
;
}
checkServerParent
(
record
results
)
;
}
}
private
static
class
ClientServerPair
{
BookmarkRecord
client
;
BookmarkRecord
server
;
ClientServerPair
(
BookmarkRecord
client
BookmarkRecord
server
)
{
this
.
client
=
client
;
this
.
server
=
server
;
}
}
private
boolean
checkMissing
(
ClientServerPair
p
BookmarkValidationResults
results
)
{
boolean
clientExists
=
p
.
client
!
=
null
&
&
!
p
.
client
.
deleted
;
boolean
serverExists
=
p
.
server
!
=
null
&
&
!
p
.
server
.
deleted
;
boolean
serverTombstone
=
p
.
server
!
=
null
&
&
p
.
server
.
deleted
;
if
(
clientExists
&
&
!
serverExists
)
{
if
(
serverTombstone
)
{
results
.
serverDeleted
.
add
(
p
.
client
.
guid
)
;
}
else
{
results
.
serverMissing
.
add
(
p
.
client
.
guid
)
;
}
}
else
if
(
serverExists
&
&
!
clientExists
)
{
results
.
clientMissing
.
add
(
p
.
server
.
guid
)
;
}
return
clientExists
&
&
serverExists
;
}
private
boolean
checkStructuralDifferences
(
ClientServerPair
p
BookmarkValidationResults
results
)
{
boolean
sawDiff
=
false
;
if
(
!
p
.
client
.
parentID
.
equals
(
p
.
server
.
parentID
)
)
{
results
.
structuralDifferenceParentIDs
.
add
(
p
.
client
.
guid
)
;
sawDiff
=
true
;
}
if
(
p
.
client
.
children
!
=
null
&
&
p
.
server
.
children
!
=
null
)
{
if
(
p
.
client
.
children
.
size
(
)
=
=
p
.
server
.
children
.
size
(
)
)
{
for
(
int
i
=
0
;
i
<
p
.
client
.
children
.
size
(
)
;
+
+
i
)
{
String
clientChildGUID
=
(
String
)
p
.
client
.
children
.
get
(
i
)
;
String
serverChildGUID
=
(
String
)
p
.
server
.
children
.
get
(
i
)
;
if
(
!
clientChildGUID
.
equals
(
serverChildGUID
)
)
{
results
.
structuralDifferenceChildGUIDs
.
add
(
p
.
client
.
guid
)
;
sawDiff
=
true
;
break
;
}
}
}
else
{
sawDiff
=
true
;
results
.
structuralDifferenceChildGUIDs
.
add
(
p
.
client
.
guid
)
;
}
}
return
sawDiff
;
}
private
BookmarkRecord
normalizeRecord
(
BookmarkRecord
r
)
{
if
(
r
.
collection
=
=
null
)
{
r
.
collection
=
"
bookmarks
"
;
}
if
(
r
.
tags
=
=
null
)
{
r
.
tags
=
new
JSONArray
(
)
;
}
return
r
;
}
private
void
compareClientWithServer
(
BookmarkValidationResults
results
)
{
Map
<
String
ClientServerPair
>
pairsById
=
new
HashMap
<
>
(
)
;
for
(
BookmarkRecord
r
:
remoteRecords
)
{
pairsById
.
put
(
r
.
guid
new
ClientServerPair
(
null
normalizeRecord
(
r
)
)
)
;
}
for
(
BookmarkRecord
r
:
localRecords
)
{
if
(
r
.
deleted
)
{
continue
;
}
ClientServerPair
p
=
pairsById
.
get
(
r
.
guid
)
;
if
(
p
!
=
null
)
{
p
.
client
=
normalizeRecord
(
r
)
;
}
else
{
pairsById
.
put
(
r
.
guid
new
ClientServerPair
(
normalizeRecord
(
r
)
null
)
)
;
}
}
for
(
Entry
<
String
ClientServerPair
>
e
:
pairsById
.
entrySet
(
)
)
{
ClientServerPair
p
=
e
.
getValue
(
)
;
if
(
!
checkMissing
(
p
results
)
)
{
continue
;
}
boolean
sawStructuralDifference
=
checkStructuralDifferences
(
p
results
)
;
if
(
!
sawStructuralDifference
&
&
(
!
p
.
client
.
congruentWith
(
p
.
server
)
|
|
!
p
.
server
.
congruentWith
(
p
.
client
)
)
)
{
results
.
differences
.
add
(
p
.
client
.
guid
)
;
}
}
}
private
void
cleanupValidationResults
(
BookmarkValidationResults
results
)
{
Map
<
String
List
<
String
>
>
filteredMultipleParents
=
new
HashMap
<
>
(
)
;
for
(
Entry
<
String
List
<
String
>
>
entry
:
results
.
multipleParents
.
entrySet
(
)
)
{
if
(
entry
.
getValue
(
)
.
size
(
)
>
=
2
)
{
filteredMultipleParents
.
put
(
entry
.
getKey
(
)
entry
.
getValue
(
)
)
;
}
}
results
.
multipleParents
=
filteredMultipleParents
;
}
private
BookmarkValidationResults
validate
(
)
{
BookmarkValidationResults
results
=
new
BookmarkValidationResults
(
)
;
inspectServerRecords
(
results
)
;
compareClientWithServer
(
results
)
;
cleanupValidationResults
(
results
)
;
return
results
;
}
public
static
BookmarkValidationResults
validateClientAgainstServer
(
List
<
BookmarkRecord
>
client
List
<
BookmarkRecord
>
server
)
{
BookmarkValidator
v
=
new
BookmarkValidator
(
client
server
)
;
return
v
.
validate
(
)
;
}
public
static
BookmarkValidationResults
validateServer
(
List
<
BookmarkRecord
>
server
)
{
BookmarkValidator
v
=
new
BookmarkValidator
(
new
ArrayList
<
BookmarkRecord
>
(
)
server
)
;
BookmarkValidationResults
results
=
new
BookmarkValidationResults
(
)
;
v
.
inspectServerRecords
(
results
)
;
v
.
compareClientWithServer
(
results
)
;
return
v
.
validate
(
)
;
}
}
