package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
downloaders
;
import
android
.
net
.
Uri
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
CollectionConcurrentModificationException
;
import
org
.
mozilla
.
gecko
.
sync
.
CryptoRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
DelayedWorkTracker
;
import
org
.
mozilla
.
gecko
.
sync
.
SyncDeadlineReachedException
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
AuthHeaderProvider
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncResponse
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageCollectionRequest
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageResponse
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositoryStateProvider
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
class
BatchingDownloader
{
public
static
final
String
LOG_TAG
=
"
BatchingDownloader
"
;
private
static
final
String
DEFAULT_SORT_ORDER
=
"
index
"
;
private
final
RepositorySession
repositorySession
;
private
final
DelayedWorkTracker
workTracker
=
new
DelayedWorkTracker
(
)
;
private
final
Uri
baseCollectionUri
;
private
final
long
fetchDeadline
;
private
final
boolean
allowMultipleBatches
;
private
final
boolean
keepTrackOfHighWaterMark
;
private
RepositoryStateProvider
stateProvider
;
final
AuthHeaderProvider
authHeaderProvider
;
VisibleForTesting
protected
final
Set
<
SyncStorageCollectionRequest
>
pending
=
Collections
.
synchronizedSet
(
new
HashSet
<
SyncStorageCollectionRequest
>
(
)
)
;
private
String
lastModified
;
public
BatchingDownloader
(
AuthHeaderProvider
authHeaderProvider
Uri
baseCollectionUri
long
fetchDeadline
boolean
allowMultipleBatches
boolean
keepTrackOfHighWaterMark
RepositoryStateProvider
stateProvider
RepositorySession
repositorySession
)
{
this
.
repositorySession
=
repositorySession
;
this
.
authHeaderProvider
=
authHeaderProvider
;
this
.
baseCollectionUri
=
baseCollectionUri
;
this
.
allowMultipleBatches
=
allowMultipleBatches
;
this
.
keepTrackOfHighWaterMark
=
keepTrackOfHighWaterMark
;
this
.
fetchDeadline
=
fetchDeadline
;
this
.
stateProvider
=
stateProvider
;
}
VisibleForTesting
protected
static
String
flattenIDs
(
String
[
]
guids
)
{
if
(
guids
.
length
=
=
0
)
{
return
"
"
;
}
if
(
guids
.
length
=
=
1
)
{
return
guids
[
0
]
;
}
StringBuilder
b
=
new
StringBuilder
(
guids
.
length
*
12
+
guids
.
length
)
;
for
(
String
guid
:
guids
)
{
b
.
append
(
guid
)
;
b
.
append
(
"
"
)
;
}
return
b
.
substring
(
0
b
.
length
(
)
-
1
)
;
}
VisibleForTesting
protected
void
fetchWithParameters
(
long
newer
long
batchLimit
boolean
full
String
sort
String
ids
SyncStorageCollectionRequest
request
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
)
throws
URISyntaxException
UnsupportedEncodingException
{
request
.
delegate
=
new
BatchingDownloaderDelegate
(
this
fetchRecordsDelegate
request
newer
batchLimit
full
sort
ids
)
;
this
.
pending
.
add
(
request
)
;
request
.
get
(
)
;
}
VisibleForTesting
protected
SyncStorageCollectionRequest
makeSyncStorageCollectionRequest
(
long
newer
long
batchLimit
boolean
full
String
sort
String
ids
String
offset
)
throws
URISyntaxException
UnsupportedEncodingException
{
final
URI
collectionURI
=
buildCollectionURI
(
baseCollectionUri
full
newer
batchLimit
sort
ids
offset
)
;
Logger
.
debug
(
LOG_TAG
collectionURI
.
toString
(
)
)
;
return
new
SyncStorageCollectionRequest
(
collectionURI
)
;
}
public
void
fetchSince
(
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
long
timestamp
long
batchLimit
String
sortOrder
String
offset
)
{
try
{
SyncStorageCollectionRequest
request
=
makeSyncStorageCollectionRequest
(
timestamp
batchLimit
true
sortOrder
null
offset
)
;
this
.
fetchWithParameters
(
timestamp
batchLimit
true
sortOrder
null
request
fetchRecordsDelegate
)
;
}
catch
(
URISyntaxException
|
UnsupportedEncodingException
e
)
{
fetchRecordsDelegate
.
onFetchFailed
(
e
)
;
}
}
public
void
fetch
(
String
[
]
guids
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
)
{
String
ids
=
flattenIDs
(
guids
)
;
try
{
SyncStorageCollectionRequest
request
=
makeSyncStorageCollectionRequest
(
-
1
-
1
true
DEFAULT_SORT_ORDER
ids
null
)
;
this
.
fetchWithParameters
(
-
1
-
1
true
DEFAULT_SORT_ORDER
ids
request
fetchRecordsDelegate
)
;
}
catch
(
URISyntaxException
|
UnsupportedEncodingException
e
)
{
fetchRecordsDelegate
.
onFetchFailed
(
e
)
;
}
}
public
void
onFetchCompleted
(
SyncStorageResponse
response
final
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
final
SyncStorageCollectionRequest
request
long
newer
long
limit
boolean
full
String
sort
String
ids
)
{
removeRequestFromPending
(
request
)
;
final
String
currentLastModifiedTimestamp
=
response
.
lastModified
(
)
;
Logger
.
debug
(
LOG_TAG
"
Last
modified
timestamp
"
+
currentLastModifiedTimestamp
)
;
final
boolean
lastModifiedChanged
;
synchronized
(
this
)
{
if
(
this
.
lastModified
=
=
null
)
{
this
.
lastModified
=
currentLastModifiedTimestamp
;
}
lastModifiedChanged
=
!
this
.
lastModified
.
equals
(
currentLastModifiedTimestamp
)
;
}
if
(
lastModifiedChanged
)
{
this
.
handleFetchFailed
(
fetchRecordsDelegate
new
CollectionConcurrentModificationException
(
)
)
;
return
;
}
final
String
offset
=
response
.
weaveOffset
(
)
;
if
(
offset
=
=
null
|
|
!
allowMultipleBatches
)
{
final
long
normalizedTimestamp
=
response
.
normalizedTimestampForHeader
(
SyncResponse
.
X_LAST_MODIFIED
)
;
Logger
.
debug
(
LOG_TAG
"
Fetch
completed
.
Timestamp
is
"
+
normalizedTimestamp
)
;
if
(
!
BatchingDownloaderController
.
resetResumeContextAndCommit
(
this
.
stateProvider
)
)
{
Logger
.
warn
(
LOG_TAG
"
Failed
to
reset
resume
context
while
completing
a
batch
"
)
;
}
this
.
workTracker
.
delayWorkItem
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Logger
.
debug
(
LOG_TAG
"
Delayed
onFetchCompleted
running
.
"
)
;
fetchRecordsDelegate
.
onFetchCompleted
(
normalizedTimestamp
)
;
}
}
)
;
return
;
}
if
(
BatchingDownloaderController
.
isResumeContextSet
(
this
.
stateProvider
)
)
{
if
(
!
BatchingDownloaderController
.
updateResumeContextAndCommit
(
this
.
stateProvider
offset
)
)
{
Logger
.
warn
(
LOG_TAG
"
Failed
to
update
resume
context
while
processing
a
batch
.
"
)
;
}
}
else
{
if
(
!
BatchingDownloaderController
.
setInitialResumeContextAndCommit
(
this
.
stateProvider
offset
newer
sort
)
)
{
Logger
.
warn
(
LOG_TAG
"
Failed
to
set
initial
resume
context
while
processing
a
batch
.
"
)
;
}
}
this
.
workTracker
.
delayWorkItem
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Logger
.
debug
(
LOG_TAG
"
Running
onBatchCompleted
.
"
)
;
fetchRecordsDelegate
.
onBatchCompleted
(
)
;
}
}
)
;
if
(
!
mayProceedWithBatching
(
fetchDeadline
)
)
{
this
.
handleFetchFailed
(
fetchRecordsDelegate
new
SyncDeadlineReachedException
(
)
)
;
return
;
}
try
{
final
SyncStorageCollectionRequest
newRequest
=
makeSyncStorageCollectionRequest
(
newer
limit
full
sort
ids
offset
)
;
this
.
fetchWithParameters
(
newer
limit
full
sort
ids
newRequest
fetchRecordsDelegate
)
;
}
catch
(
final
URISyntaxException
|
UnsupportedEncodingException
e
)
{
if
(
!
this
.
stateProvider
.
commit
(
)
)
{
Logger
.
warn
(
LOG_TAG
"
Failed
to
commit
repository
state
while
handling
request
creation
error
"
)
;
}
this
.
workTracker
.
delayWorkItem
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Logger
.
debug
(
LOG_TAG
"
Delayed
onFetchCompleted
running
.
"
)
;
fetchRecordsDelegate
.
onFetchFailed
(
e
)
;
}
}
)
;
}
}
private
void
handleFetchFailed
(
final
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
final
Exception
ex
)
{
handleFetchFailed
(
fetchRecordsDelegate
ex
null
)
;
}
void
handleFetchFailed
(
final
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
final
Exception
ex
Nullable
final
SyncStorageCollectionRequest
request
)
{
this
.
removeRequestFromPending
(
request
)
;
this
.
abortRequests
(
)
;
if
(
!
(
ex
instanceof
SyncDeadlineReachedException
)
)
{
if
(
!
BatchingDownloaderController
.
resetResumeContextAndCommit
(
stateProvider
)
)
{
Logger
.
warn
(
LOG_TAG
"
Failed
to
reset
resume
context
while
processing
a
non
-
deadline
exception
"
)
;
}
}
else
{
if
(
!
this
.
stateProvider
.
commit
(
)
)
{
Logger
.
warn
(
LOG_TAG
"
Failed
to
commit
resume
context
while
processing
a
deadline
exception
"
)
;
}
}
this
.
workTracker
.
delayWorkItem
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Logger
.
debug
(
LOG_TAG
"
Running
onFetchFailed
.
"
)
;
fetchRecordsDelegate
.
onFetchFailed
(
ex
)
;
}
}
)
;
}
public
void
onFetchedRecord
(
CryptoRecord
record
RepositorySessionFetchRecordsDelegate
fetchRecordsDelegate
)
{
this
.
workTracker
.
incrementOutstanding
(
)
;
try
{
fetchRecordsDelegate
.
onFetchedRecord
(
record
)
;
if
(
this
.
keepTrackOfHighWaterMark
)
{
this
.
stateProvider
.
setLong
(
RepositoryStateProvider
.
KEY_HIGH_WATER_MARK
record
.
lastModified
)
;
}
}
catch
(
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
Got
exception
calling
onFetchedRecord
with
WBO
.
"
ex
)
;
throw
new
RuntimeException
(
ex
)
;
}
finally
{
this
.
workTracker
.
decrementOutstanding
(
)
;
}
}
private
void
removeRequestFromPending
(
SyncStorageCollectionRequest
request
)
{
if
(
request
=
=
null
)
{
return
;
}
this
.
pending
.
remove
(
request
)
;
}
VisibleForTesting
protected
void
abortRequests
(
)
{
this
.
repositorySession
.
abort
(
)
;
synchronized
(
this
.
pending
)
{
for
(
SyncStorageCollectionRequest
request
:
this
.
pending
)
{
request
.
abort
(
)
;
}
this
.
pending
.
clear
(
)
;
}
}
Nullable
protected
synchronized
String
getLastModified
(
)
{
return
this
.
lastModified
;
}
private
static
boolean
mayProceedWithBatching
(
long
deadline
)
{
final
long
timeLeft
=
deadline
-
SystemClock
.
elapsedRealtime
(
)
;
return
timeLeft
>
TimeUnit
.
MINUTES
.
toMillis
(
1
)
;
}
VisibleForTesting
public
static
URI
buildCollectionURI
(
Uri
baseCollectionUri
boolean
full
long
newer
long
limit
String
sort
String
ids
String
offset
)
throws
URISyntaxException
{
Uri
.
Builder
uriBuilder
=
baseCollectionUri
.
buildUpon
(
)
;
if
(
full
)
{
uriBuilder
.
appendQueryParameter
(
"
full
"
"
1
"
)
;
}
if
(
newer
>
=
0
)
{
String
newerString
=
Utils
.
millisecondsToDecimalSecondsString
(
newer
)
;
uriBuilder
.
appendQueryParameter
(
"
newer
"
newerString
)
;
}
if
(
limit
>
0
)
{
uriBuilder
.
appendQueryParameter
(
"
limit
"
Long
.
toString
(
limit
)
)
;
}
if
(
sort
!
=
null
)
{
uriBuilder
.
appendQueryParameter
(
"
sort
"
sort
)
;
}
if
(
ids
!
=
null
)
{
uriBuilder
.
appendQueryParameter
(
"
ids
"
ids
)
;
}
if
(
offset
!
=
null
)
{
uriBuilder
.
appendQueryParameter
(
"
offset
"
offset
)
;
}
return
new
URI
(
uriBuilder
.
build
(
)
.
toString
(
)
)
;
}
}
