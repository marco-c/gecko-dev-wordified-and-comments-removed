package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
;
import
java
.
util
.
ArrayList
;
import
org
.
json
.
simple
.
JSONArray
;
import
org
.
json
.
simple
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
HistoryRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
android
.
content
.
ContentValues
;
import
android
.
content
.
Context
;
import
android
.
net
.
Uri
;
public
class
AndroidBrowserHistoryDataAccessor
extends
AndroidBrowserRepositoryDataAccessor
{
public
AndroidBrowserHistoryDataAccessor
(
Context
context
)
{
super
(
context
)
;
}
Override
protected
Uri
getUri
(
)
{
return
BrowserContractHelpers
.
HISTORY_CONTENT_URI
;
}
Override
protected
ContentValues
getContentValues
(
Record
record
)
{
ContentValues
cv
=
new
ContentValues
(
)
;
HistoryRecord
rec
=
(
HistoryRecord
)
record
;
cv
.
put
(
BrowserContract
.
History
.
GUID
rec
.
guid
)
;
cv
.
put
(
BrowserContract
.
History
.
TITLE
rec
.
title
)
;
cv
.
put
(
BrowserContract
.
History
.
URL
rec
.
histURI
)
;
if
(
rec
.
visits
!
=
null
)
{
JSONArray
visits
=
rec
.
visits
;
long
mostRecent
=
getLastVisited
(
visits
)
;
cv
.
put
(
BrowserContract
.
History
.
DATE_LAST_VISITED
mostRecent
/
1000
)
;
cv
.
put
(
BrowserContract
.
History
.
REMOTE_DATE_LAST_VISITED
mostRecent
/
1000
)
;
cv
.
put
(
BrowserContract
.
History
.
VISITS
Long
.
toString
(
visits
.
size
(
)
)
)
;
}
return
cv
;
}
Override
protected
String
[
]
getAllColumns
(
)
{
return
BrowserContractHelpers
.
HistoryColumns
;
}
Override
public
Uri
insert
(
Record
record
)
{
HistoryRecord
rec
=
(
HistoryRecord
)
record
;
Logger
.
debug
(
LOG_TAG
"
Storing
record
"
+
record
.
guid
)
;
Uri
newRecordUri
=
super
.
insert
(
record
)
;
Logger
.
debug
(
LOG_TAG
"
Storing
visits
for
"
+
record
.
guid
)
;
context
.
getContentResolver
(
)
.
bulkInsert
(
BrowserContract
.
Visits
.
CONTENT_URI
VisitsHelper
.
getVisitsContentValues
(
rec
.
guid
rec
.
visits
)
)
;
return
newRecordUri
;
}
Override
public
void
update
(
String
oldGUID
Record
newRecord
)
{
super
.
update
(
oldGUID
newRecord
)
;
HistoryRecord
rec
=
(
HistoryRecord
)
newRecord
;
String
newGUID
=
newRecord
.
guid
;
Logger
.
debug
(
LOG_TAG
"
Storing
visits
for
"
+
newGUID
+
"
replacing
"
+
oldGUID
)
;
context
.
getContentResolver
(
)
.
bulkInsert
(
BrowserContract
.
Visits
.
CONTENT_URI
VisitsHelper
.
getVisitsContentValues
(
newGUID
rec
.
visits
)
)
;
}
public
int
bulkInsert
(
ArrayList
<
HistoryRecord
>
records
)
throws
NullCursorException
{
if
(
records
.
isEmpty
(
)
)
{
Logger
.
debug
(
LOG_TAG
"
No
records
to
insert
returning
.
"
)
;
}
int
size
=
records
.
size
(
)
;
ContentValues
[
]
cvs
=
new
ContentValues
[
size
]
;
int
index
=
0
;
for
(
Record
record
:
records
)
{
if
(
record
.
guid
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Record
with
null
GUID
passed
in
to
bulkInsert
.
"
)
;
}
cvs
[
index
]
=
getContentValues
(
record
)
;
index
+
=
1
;
}
int
inserted
=
context
.
getContentResolver
(
)
.
bulkInsert
(
getUri
(
)
cvs
)
;
if
(
inserted
=
=
size
)
{
Logger
.
debug
(
LOG_TAG
"
Inserted
"
+
inserted
+
"
records
as
expected
.
"
)
;
}
else
{
Logger
.
debug
(
LOG_TAG
"
Inserted
"
+
inserted
+
"
records
but
expected
"
+
size
+
"
records
;
continuing
to
update
visits
.
"
)
;
}
final
ContentValues
remoteVisitAggregateValues
=
new
ContentValues
(
)
;
final
Uri
historyIncrementRemoteAggregateUri
=
getUri
(
)
.
buildUpon
(
)
.
appendQueryParameter
(
BrowserContract
.
PARAM_INCREMENT_REMOTE_AGGREGATES
"
true
"
)
.
build
(
)
;
for
(
Record
record
:
records
)
{
HistoryRecord
rec
=
(
HistoryRecord
)
record
;
if
(
rec
.
visits
!
=
null
&
&
rec
.
visits
.
size
(
)
!
=
0
)
{
int
remoteVisitsInserted
=
context
.
getContentResolver
(
)
.
bulkInsert
(
BrowserContract
.
Visits
.
CONTENT_URI
VisitsHelper
.
getVisitsContentValues
(
rec
.
guid
rec
.
visits
)
)
;
if
(
remoteVisitsInserted
>
0
)
{
remoteVisitAggregateValues
.
put
(
BrowserContract
.
History
.
REMOTE_VISITS
remoteVisitsInserted
)
;
context
.
getContentResolver
(
)
.
update
(
historyIncrementRemoteAggregateUri
remoteVisitAggregateValues
BrowserContract
.
History
.
GUID
+
"
=
?
"
new
String
[
]
{
rec
.
guid
}
)
;
}
}
}
return
inserted
;
}
private
long
getLastVisited
(
JSONArray
visits
)
{
long
mostRecent
=
0
;
for
(
int
i
=
0
;
i
<
visits
.
size
(
)
;
i
+
+
)
{
final
JSONObject
visit
=
(
JSONObject
)
visits
.
get
(
i
)
;
long
visitDate
=
(
Long
)
visit
.
get
(
VisitsHelper
.
SYNC_DATE_KEY
)
;
if
(
visitDate
>
mostRecent
)
{
mostRecent
=
visitDate
;
}
}
return
mostRecent
;
}
}
