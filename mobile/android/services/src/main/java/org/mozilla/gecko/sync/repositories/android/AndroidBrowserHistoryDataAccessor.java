package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
;
import
java
.
util
.
ArrayList
;
import
org
.
json
.
simple
.
JSONArray
;
import
org
.
json
.
simple
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
HistoryRecord
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
android
.
content
.
ContentValues
;
import
android
.
content
.
Context
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Bundle
;
public
class
AndroidBrowserHistoryDataAccessor
extends
AndroidBrowserRepositoryDataAccessor
{
public
AndroidBrowserHistoryDataAccessor
(
Context
context
)
{
super
(
context
)
;
}
Override
protected
Uri
getUri
(
)
{
return
BrowserContractHelpers
.
HISTORY_CONTENT_URI
;
}
Override
protected
ContentValues
getContentValues
(
Record
record
)
{
ContentValues
cv
=
new
ContentValues
(
)
;
HistoryRecord
rec
=
(
HistoryRecord
)
record
;
cv
.
put
(
BrowserContract
.
History
.
GUID
rec
.
guid
)
;
cv
.
put
(
BrowserContract
.
History
.
TITLE
rec
.
title
)
;
cv
.
put
(
BrowserContract
.
History
.
URL
rec
.
histURI
)
;
if
(
rec
.
visits
!
=
null
)
{
JSONArray
visits
=
rec
.
visits
;
long
mostRecent
=
getLastVisited
(
visits
)
;
cv
.
put
(
BrowserContract
.
History
.
DATE_LAST_VISITED
mostRecent
/
1000
)
;
cv
.
put
(
BrowserContract
.
History
.
REMOTE_DATE_LAST_VISITED
mostRecent
/
1000
)
;
cv
.
put
(
BrowserContract
.
History
.
VISITS
visits
.
size
(
)
)
;
}
return
cv
;
}
Override
protected
String
[
]
getAllColumns
(
)
{
return
BrowserContractHelpers
.
HistoryColumns
;
}
Override
public
Uri
insert
(
Record
record
)
{
HistoryRecord
rec
=
(
HistoryRecord
)
record
;
Logger
.
debug
(
LOG_TAG
"
Storing
record
"
+
record
.
guid
)
;
Uri
newRecordUri
=
super
.
insert
(
record
)
;
Logger
.
debug
(
LOG_TAG
"
Storing
visits
for
"
+
record
.
guid
)
;
context
.
getContentResolver
(
)
.
bulkInsert
(
BrowserContract
.
Visits
.
CONTENT_URI
VisitsHelper
.
getVisitsContentValues
(
rec
.
guid
rec
.
visits
)
)
;
return
newRecordUri
;
}
Override
public
void
update
(
String
oldGUID
Record
newRecord
)
{
super
.
update
(
oldGUID
newRecord
)
;
HistoryRecord
rec
=
(
HistoryRecord
)
newRecord
;
String
newGUID
=
newRecord
.
guid
;
Logger
.
debug
(
LOG_TAG
"
Storing
visits
for
"
+
newGUID
+
"
replacing
"
+
oldGUID
)
;
context
.
getContentResolver
(
)
.
bulkInsert
(
BrowserContract
.
Visits
.
CONTENT_URI
VisitsHelper
.
getVisitsContentValues
(
newGUID
rec
.
visits
)
)
;
}
public
boolean
bulkInsert
(
ArrayList
<
HistoryRecord
>
records
)
throws
NullCursorException
{
final
Bundle
[
]
historyBundles
=
new
Bundle
[
records
.
size
(
)
]
;
int
i
=
0
;
for
(
HistoryRecord
record
:
records
)
{
if
(
record
.
guid
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Record
with
null
GUID
passed
into
bulkInsert
.
"
)
;
}
final
Bundle
historyBundle
=
new
Bundle
(
)
;
historyBundle
.
putParcelable
(
BrowserContract
.
METHOD_PARAM_OBJECT
getContentValues
(
record
)
)
;
historyBundle
.
putSerializable
(
BrowserContract
.
History
.
VISITS
VisitsHelper
.
getVisitsContentValues
(
record
.
guid
record
.
visits
)
)
;
historyBundles
[
i
]
=
historyBundle
;
i
+
+
;
}
final
Bundle
data
=
new
Bundle
(
)
;
data
.
putSerializable
(
BrowserContract
.
METHOD_PARAM_DATA
historyBundles
)
;
final
Bundle
result
=
context
.
getContentResolver
(
)
.
call
(
getUri
(
)
BrowserContract
.
METHOD_INSERT_HISTORY_WITH_VISITS_FROM_SYNC
getUri
(
)
.
toString
(
)
data
)
;
if
(
result
=
=
null
)
{
throw
new
IllegalStateException
(
"
Unexpected
null
result
while
bulk
inserting
history
"
)
;
}
final
Exception
thrownException
=
(
Exception
)
result
.
getSerializable
(
BrowserContract
.
METHOD_RESULT
)
;
return
thrownException
=
=
null
;
}
private
long
getLastVisited
(
JSONArray
visits
)
{
long
mostRecent
=
0
;
for
(
int
i
=
0
;
i
<
visits
.
size
(
)
;
i
+
+
)
{
final
JSONObject
visit
=
(
JSONObject
)
visits
.
get
(
i
)
;
long
visitDate
=
(
Long
)
visit
.
get
(
VisitsHelper
.
SYNC_DATE_KEY
)
;
if
(
visitDate
>
mostRecent
)
{
mostRecent
=
visitDate
;
}
}
return
mostRecent
;
}
}
