package
org
.
mozilla
.
gecko
.
sync
.
synchronizer
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
java
.
util
.
concurrent
.
ExecutorService
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
ReflowIsNecessaryException
;
import
org
.
mozilla
.
gecko
.
sync
.
ThreadPool
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InvalidSessionTransitionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NoStoreDelegateException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
DeferredRepositorySessionBeginDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
DeferredRepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionBeginDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
public
class
RecordsChannel
implements
RepositorySessionFetchRecordsDelegate
RepositorySessionStoreDelegate
RecordsConsumerDelegate
RepositorySessionBeginDelegate
{
private
static
final
String
LOG_TAG
=
"
RecordsChannel
"
;
public
RepositorySession
source
;
private
RepositorySession
sink
;
private
final
RecordsChannelDelegate
delegate
;
private
volatile
ReflowIsNecessaryException
reflowException
;
private
final
AtomicInteger
fetchedCount
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
fetchFailedCount
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
storeAttemptedCount
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
storeAcceptedCount
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
storeFailedCount
=
new
AtomicInteger
(
)
;
private
final
AtomicInteger
storeReconciledCount
=
new
AtomicInteger
(
)
;
public
RecordsChannel
(
RepositorySession
source
RepositorySession
sink
RecordsChannelDelegate
delegate
)
{
this
.
source
=
source
;
this
.
sink
=
sink
;
this
.
delegate
=
delegate
;
}
private
RecordConsumer
consumer
;
private
volatile
boolean
waitingForQueueDone
=
false
;
private
final
ConcurrentLinkedQueue
<
Record
>
toProcess
=
new
ConcurrentLinkedQueue
<
Record
>
(
)
;
Override
public
ConcurrentLinkedQueue
<
Record
>
getQueue
(
)
{
return
toProcess
;
}
protected
boolean
isReady
(
)
{
return
source
.
isActive
(
)
&
&
sink
.
isActive
(
)
;
}
public
int
getFetchCount
(
)
{
return
fetchedCount
.
get
(
)
;
}
public
int
getFetchFailureCount
(
)
{
return
fetchFailedCount
.
get
(
)
;
}
public
int
getStoreAttemptedCount
(
)
{
return
storeAttemptedCount
.
get
(
)
;
}
public
int
getStoreAcceptedCount
(
)
{
return
storeAcceptedCount
.
get
(
)
;
}
public
int
getStoreFailureCount
(
)
{
return
storeFailedCount
.
get
(
)
;
}
public
int
getStoreReconciledCount
(
)
{
return
storeReconciledCount
.
get
(
)
;
}
public
void
flow
(
)
{
if
(
!
isReady
(
)
)
{
RepositorySession
failed
=
source
;
if
(
source
.
isActive
(
)
)
{
failed
=
sink
;
}
this
.
delegate
.
onFlowBeginFailed
(
this
new
SessionNotBegunException
(
failed
)
)
;
return
;
}
if
(
!
source
.
dataAvailable
(
)
)
{
Logger
.
info
(
LOG_TAG
"
No
data
available
:
short
-
circuiting
flow
from
source
"
+
source
)
;
this
.
delegate
.
onFlowCompleted
(
this
)
;
return
;
}
sink
.
setStoreDelegate
(
this
)
;
fetchedCount
.
set
(
0
)
;
fetchFailedCount
.
set
(
0
)
;
storeAttemptedCount
.
set
(
0
)
;
storeAcceptedCount
.
set
(
0
)
;
storeFailedCount
.
set
(
0
)
;
storeReconciledCount
.
set
(
0
)
;
this
.
consumer
=
new
ConcurrentRecordConsumer
(
this
)
;
ThreadPool
.
run
(
this
.
consumer
)
;
waitingForQueueDone
=
true
;
source
.
fetchModified
(
this
)
;
}
public
void
beginAndFlow
(
)
throws
InvalidSessionTransitionException
{
Logger
.
trace
(
LOG_TAG
"
Beginning
source
.
"
)
;
source
.
begin
(
this
)
;
}
Override
public
void
store
(
Record
record
)
{
storeAttemptedCount
.
incrementAndGet
(
)
;
try
{
sink
.
store
(
record
)
;
}
catch
(
NoStoreDelegateException
e
)
{
Logger
.
error
(
LOG_TAG
"
Got
NoStoreDelegateException
in
RecordsChannel
.
store
(
)
.
This
should
not
occur
.
Aborting
.
"
e
)
;
delegate
.
onFlowStoreFailed
(
this
e
record
.
guid
)
;
}
}
Override
public
void
onFetchFailed
(
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
onFetchFailed
.
Calling
for
immediate
stop
.
"
ex
)
;
fetchFailedCount
.
incrementAndGet
(
)
;
if
(
ex
instanceof
ReflowIsNecessaryException
)
{
setReflowException
(
(
ReflowIsNecessaryException
)
ex
)
;
}
delegate
.
onFlowFetchFailed
(
this
ex
)
;
this
.
consumer
.
halt
(
)
;
}
Override
public
void
onFetchedRecord
(
Record
record
)
{
fetchedCount
.
incrementAndGet
(
)
;
this
.
toProcess
.
add
(
record
)
;
this
.
consumer
.
doNotify
(
)
;
}
Override
public
void
onFetchCompleted
(
)
{
Logger
.
trace
(
LOG_TAG
"
onFetchCompleted
.
Stopping
consumer
once
stores
are
done
.
"
)
;
this
.
consumer
.
queueFilled
(
)
;
}
Override
public
void
onBatchCompleted
(
)
{
this
.
sink
.
storeFlush
(
)
;
}
Override
public
void
onRecordStoreFailed
(
Exception
ex
String
recordGuid
)
{
Logger
.
trace
(
LOG_TAG
"
Failed
to
store
record
with
guid
"
+
recordGuid
)
;
storeFailedCount
.
incrementAndGet
(
)
;
this
.
consumer
.
stored
(
)
;
delegate
.
onFlowStoreFailed
(
this
ex
recordGuid
)
;
}
Override
public
void
onRecordStoreSucceeded
(
String
guid
)
{
Logger
.
trace
(
LOG_TAG
"
Stored
record
with
guid
"
+
guid
)
;
storeAcceptedCount
.
incrementAndGet
(
)
;
this
.
consumer
.
stored
(
)
;
}
Override
public
void
onRecordStoreReconciled
(
String
guid
String
oldGuid
Integer
newVersion
)
{
Logger
.
trace
(
LOG_TAG
"
Reconciled
record
with
guid
"
+
guid
)
;
storeReconciledCount
.
incrementAndGet
(
)
;
}
Override
public
void
consumerIsDoneFull
(
)
{
Logger
.
trace
(
LOG_TAG
"
Consumer
is
done
processed
all
records
.
Are
we
waiting
for
it
?
"
+
waitingForQueueDone
)
;
if
(
waitingForQueueDone
)
{
waitingForQueueDone
=
false
;
this
.
sink
.
storeDone
(
)
;
}
}
Override
public
void
consumerIsDonePartial
(
)
{
Logger
.
trace
(
LOG_TAG
"
Consumer
is
done
processed
some
records
.
Are
we
waiting
for
it
?
"
+
waitingForQueueDone
)
;
if
(
waitingForQueueDone
)
{
waitingForQueueDone
=
false
;
this
.
sink
.
storeIncomplete
(
)
;
delegate
.
onFlowCompleted
(
this
)
;
}
}
Override
public
void
onStoreCompleted
(
)
{
Logger
.
trace
(
LOG_TAG
"
onStoreCompleted
.
Notifying
delegate
of
onFlowCompleted
.
"
)
;
this
.
source
.
performCleanup
(
)
;
delegate
.
onFlowCompleted
(
this
)
;
}
Override
public
void
onStoreFailed
(
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
onStoreFailed
.
Calling
for
immediate
stop
.
"
ex
)
;
if
(
ex
instanceof
ReflowIsNecessaryException
)
{
setReflowException
(
(
ReflowIsNecessaryException
)
ex
)
;
}
waitingForQueueDone
=
false
;
this
.
consumer
.
halt
(
)
;
delegate
.
onFlowStoreFailed
(
this
ex
null
)
;
delegate
.
onFlowCompleted
(
this
)
;
}
Override
public
void
onBeginFailed
(
Exception
ex
)
{
delegate
.
onFlowBeginFailed
(
this
ex
)
;
}
Override
public
void
onBeginSucceeded
(
RepositorySession
session
)
{
if
(
session
=
=
source
)
{
Logger
.
trace
(
LOG_TAG
"
Source
session
began
.
Beginning
sink
session
.
"
)
;
try
{
sink
.
begin
(
this
)
;
}
catch
(
InvalidSessionTransitionException
e
)
{
onBeginFailed
(
e
)
;
return
;
}
}
if
(
session
=
=
sink
)
{
Logger
.
trace
(
LOG_TAG
"
Sink
session
began
.
Beginning
flow
.
"
)
;
this
.
flow
(
)
;
return
;
}
}
Override
public
RepositorySessionStoreDelegate
deferredStoreDelegate
(
final
ExecutorService
executor
)
{
return
new
DeferredRepositorySessionStoreDelegate
(
this
executor
)
;
}
Override
public
RepositorySessionBeginDelegate
deferredBeginDelegate
(
final
ExecutorService
executor
)
{
return
new
DeferredRepositorySessionBeginDelegate
(
this
executor
)
;
}
Override
public
RepositorySessionFetchRecordsDelegate
deferredFetchDelegate
(
ExecutorService
executor
)
{
return
this
;
}
Nullable
public
synchronized
ReflowIsNecessaryException
getReflowException
(
)
{
return
reflowException
;
}
private
synchronized
void
setReflowException
(
NonNull
ReflowIsNecessaryException
e
)
{
if
(
reflowException
!
=
null
)
{
throw
new
IllegalStateException
(
"
Reflow
exception
already
set
:
"
+
reflowException
)
;
}
reflowException
=
e
;
}
}
