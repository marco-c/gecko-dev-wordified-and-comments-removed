package
org
.
mozilla
.
gecko
.
sync
.
synchronizer
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
concurrent
.
ExecutorService
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicBoolean
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
ReflowIsNecessaryException
;
import
org
.
mozilla
.
gecko
.
sync
.
SyncException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InvalidSessionTransitionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NoStoreDelegateException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
RepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
DeferredRepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
public
class
RecordsChannel
implements
RepositorySessionFetchRecordsDelegate
RepositorySessionStoreDelegate
{
private
static
final
String
LOG_TAG
=
"
RecordsChannel
"
;
public
RepositorySession
source
;
RepositorySession
sink
;
private
final
RecordsChannelDelegate
delegate
;
private
volatile
ReflowIsNecessaryException
reflowException
;
final
AtomicInteger
fetchedCount
=
new
AtomicInteger
(
0
)
;
final
AtomicBoolean
fetchFailed
=
new
AtomicBoolean
(
false
)
;
private
final
AtomicBoolean
storeFailed
=
new
AtomicBoolean
(
false
)
;
private
ArrayList
<
Record
>
toProcess
=
new
ArrayList
<
>
(
)
;
final
AtomicInteger
storeAttemptedCount
=
new
AtomicInteger
(
0
)
;
private
final
AtomicInteger
storeAcceptedCount
=
new
AtomicInteger
(
0
)
;
private
final
AtomicInteger
storeFailedCount
=
new
AtomicInteger
(
0
)
;
private
final
AtomicInteger
storeReconciledCount
=
new
AtomicInteger
(
0
)
;
private
final
StoreBatchTracker
storeTracker
=
new
StoreBatchTracker
(
)
;
public
RecordsChannel
(
RepositorySession
source
RepositorySession
sink
RecordsChannelDelegate
delegate
)
{
this
.
source
=
source
;
this
.
sink
=
sink
;
this
.
delegate
=
delegate
;
}
protected
boolean
isReady
(
)
{
return
source
.
isActive
(
)
&
&
sink
.
isActive
(
)
;
}
int
getFetchCount
(
)
{
return
fetchedCount
.
get
(
)
;
}
public
boolean
didFetchFail
(
)
{
return
fetchFailed
.
get
(
)
;
}
public
int
getStoreAttemptedCount
(
)
{
return
storeAttemptedCount
.
get
(
)
;
}
int
getStoreAcceptedCount
(
)
{
return
storeAcceptedCount
.
get
(
)
;
}
public
int
getStoreFailureCount
(
)
{
return
storeFailedCount
.
get
(
)
;
}
int
getStoreReconciledCount
(
)
{
return
storeReconciledCount
.
get
(
)
;
}
public
void
flow
(
)
{
if
(
!
isReady
(
)
)
{
RepositorySession
failed
=
source
;
if
(
source
.
isActive
(
)
)
{
failed
=
sink
;
}
this
.
delegate
.
onFlowBeginFailed
(
this
new
SessionNotBegunException
(
failed
)
)
;
return
;
}
if
(
!
source
.
dataAvailable
(
)
)
{
Logger
.
info
(
LOG_TAG
"
No
data
available
:
short
-
circuiting
flow
from
source
"
+
source
)
;
this
.
delegate
.
onFlowCompleted
(
this
)
;
return
;
}
sink
.
setStoreDelegate
(
this
)
;
storeTracker
.
reset
(
)
;
source
.
fetchModified
(
this
)
;
}
public
void
beginAndFlow
(
)
throws
InvalidSessionTransitionException
{
try
{
Logger
.
trace
(
LOG_TAG
"
Beginning
source
.
"
)
;
source
.
begin
(
)
;
Logger
.
trace
(
LOG_TAG
"
Beginning
sink
.
"
)
;
sink
.
begin
(
)
;
}
catch
(
SyncException
e
)
{
delegate
.
onFlowBeginFailed
(
this
e
)
;
return
;
}
this
.
flow
(
)
;
}
ArrayList
<
StoreBatchTracker
.
Batch
>
getStoreBatches
(
)
{
return
this
.
storeTracker
.
getStoreBatches
(
)
;
}
Override
public
void
onFetchFailed
(
Exception
ex
)
{
Logger
.
warn
(
LOG_TAG
"
onFetchFailed
.
Calling
for
immediate
stop
.
"
ex
)
;
if
(
fetchFailed
.
getAndSet
(
true
)
)
{
return
;
}
if
(
ex
instanceof
ReflowIsNecessaryException
)
{
setReflowException
(
(
ReflowIsNecessaryException
)
ex
)
;
}
delegate
.
onFlowFetchFailed
(
this
ex
)
;
delegate
.
onFlowCompleted
(
this
)
;
}
Override
public
void
onFetchedRecord
(
Record
record
)
{
if
(
fetchFailed
.
get
(
)
)
{
return
;
}
this
.
toProcess
.
add
(
record
)
;
}
Override
public
void
onFetchCompleted
(
)
{
if
(
fetchFailed
.
get
(
)
)
{
return
;
}
fetchedCount
.
set
(
toProcess
.
size
(
)
)
;
Logger
.
info
(
LOG_TAG
"
onFetchCompleted
.
Fetched
"
+
fetchedCount
.
get
(
)
+
"
records
.
Storing
.
.
.
"
)
;
try
{
for
(
Record
record
:
toProcess
)
{
storeAttemptedCount
.
incrementAndGet
(
)
;
storeTracker
.
onRecordStoreAttempted
(
)
;
sink
.
store
(
record
)
;
}
}
catch
(
NoStoreDelegateException
e
)
{
throw
new
IllegalStateException
(
e
)
;
}
toProcess
=
null
;
Logger
.
trace
(
LOG_TAG
"
onFetchCompleted
.
Calling
storeDone
.
"
)
;
sink
.
storeDone
(
)
;
}
Override
public
void
onBatchCommitted
(
)
{
storeTracker
.
onBatchFinished
(
)
;
}
Override
public
void
onRecordStoreFailed
(
Exception
ex
String
recordGuid
)
{
Logger
.
trace
(
LOG_TAG
"
Failed
to
store
record
with
guid
"
+
recordGuid
)
;
storeFailedCount
.
incrementAndGet
(
)
;
storeTracker
.
onRecordStoreFailed
(
)
;
delegate
.
onFlowStoreFailed
(
this
ex
recordGuid
)
;
}
Override
public
void
onRecordStoreSucceeded
(
int
count
)
{
storeAcceptedCount
.
addAndGet
(
count
)
;
storeTracker
.
onRecordStoreSucceeded
(
count
)
;
}
Override
public
void
onRecordStoreReconciled
(
String
guid
String
oldGuid
Integer
newVersion
)
{
storeReconciledCount
.
incrementAndGet
(
)
;
}
Override
public
void
onStoreCompleted
(
)
{
Logger
.
info
(
LOG_TAG
"
Performing
source
cleanup
.
"
)
;
this
.
source
.
performCleanup
(
)
;
if
(
storeFailed
.
get
(
)
)
{
return
;
}
Logger
.
info
(
LOG_TAG
"
onStoreCompleted
.
Attempted
to
store
"
+
storeAttemptedCount
.
get
(
)
+
"
records
;
Store
accepted
"
+
storeAcceptedCount
.
get
(
)
+
"
reconciled
"
+
storeReconciledCount
.
get
(
)
+
"
failed
"
+
storeFailedCount
.
get
(
)
)
;
delegate
.
onFlowCompleted
(
this
)
;
}
Override
public
void
onStoreFailed
(
Exception
ex
)
{
if
(
storeFailed
.
getAndSet
(
true
)
)
{
return
;
}
Logger
.
info
(
LOG_TAG
"
onStoreFailed
.
Calling
for
immediate
stop
.
"
ex
)
;
if
(
ex
instanceof
ReflowIsNecessaryException
)
{
setReflowException
(
(
ReflowIsNecessaryException
)
ex
)
;
}
storeTracker
.
onBatchFailed
(
)
;
delegate
.
onFlowStoreFailed
(
this
ex
null
)
;
delegate
.
onFlowCompleted
(
this
)
;
}
Override
public
RepositorySessionStoreDelegate
deferredStoreDelegate
(
final
ExecutorService
executor
)
{
return
new
DeferredRepositorySessionStoreDelegate
(
this
executor
)
;
}
Override
public
RepositorySessionFetchRecordsDelegate
deferredFetchDelegate
(
ExecutorService
executor
)
{
return
this
;
}
Nullable
public
synchronized
ReflowIsNecessaryException
getReflowException
(
)
{
return
reflowException
;
}
private
synchronized
void
setReflowException
(
NonNull
ReflowIsNecessaryException
e
)
{
if
(
reflowException
!
=
null
)
{
throw
new
IllegalStateException
(
"
Reflow
exception
already
set
:
"
+
reflowException
)
;
}
reflowException
=
e
;
}
}
