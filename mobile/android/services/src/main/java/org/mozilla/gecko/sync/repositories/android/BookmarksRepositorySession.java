package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InactiveSessionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
InvalidSessionTransitionException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NoStoreDelegateException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
NullCursorException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
ProfileDatabaseException
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
Repository
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
StoreTrackingRepositorySession
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
VersioningDelegateHelper
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionBeginDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFetchRecordsDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionFinishDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionStoreDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
delegates
.
RepositorySessionWipeDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
domain
.
Record
;
import
android
.
content
.
Context
;
public
class
BookmarksRepositorySession
extends
StoreTrackingRepositorySession
{
private
static
final
String
LOG_TAG
=
"
AndroidBrowserBookmarksRepositorySession
"
;
private
int
storeCount
=
0
;
private
final
BookmarksDataAccessor
dataAccessor
;
private
final
BookmarksSessionHelper
sessionHelper
;
private
final
VersioningDelegateHelper
versioningDelegateHelper
;
public
static
final
String
[
]
SPECIAL_GUIDS
=
new
String
[
]
{
"
places
"
"
mobile
"
"
toolbar
"
"
menu
"
"
unfiled
"
}
;
public
static
Map
<
String
String
>
SPECIAL_GUIDS_MAP
;
protected
BookmarksRepositorySession
(
Repository
repository
Context
context
)
{
super
(
repository
)
;
if
(
SPECIAL_GUIDS_MAP
=
=
null
)
{
HashMap
<
String
String
>
m
=
new
HashMap
<
String
String
>
(
)
;
m
.
put
(
"
mobile
"
"
mobile
"
)
;
m
.
put
(
"
menu
"
context
.
getString
(
R
.
string
.
bookmarks_folder_menu
)
)
;
m
.
put
(
"
places
"
context
.
getString
(
R
.
string
.
bookmarks_folder_places
)
)
;
m
.
put
(
"
toolbar
"
context
.
getString
(
R
.
string
.
bookmarks_folder_toolbar
)
)
;
m
.
put
(
"
unfiled
"
context
.
getString
(
R
.
string
.
bookmarks_folder_unfiled
)
)
;
SPECIAL_GUIDS_MAP
=
Collections
.
unmodifiableMap
(
m
)
;
}
dataAccessor
=
new
BookmarksDataAccessor
(
context
)
;
sessionHelper
=
new
BookmarksSessionHelper
(
this
dataAccessor
)
;
versioningDelegateHelper
=
new
VersioningDelegateHelper
(
context
BrowserContractHelpers
.
BOOKMARKS_CONTENT_URI
)
;
}
Override
public
void
fetchModified
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
if
(
this
.
storeTracker
=
=
null
)
{
throw
new
IllegalStateException
(
"
Store
tracker
not
yet
initialized
!
"
)
;
}
Logger
.
debug
(
LOG_TAG
"
Running
fetchModified
.
"
)
;
delegateQueue
.
execute
(
sessionHelper
.
getFetchModifiedRunnable
(
now
(
)
this
.
storeTracker
.
getFilter
(
)
versioningDelegateHelper
.
getFetchDelegate
(
delegate
)
)
)
;
}
Override
public
void
fetch
(
String
[
]
guids
RepositorySessionFetchRecordsDelegate
delegate
)
throws
InactiveSessionException
{
executeDelegateCommand
(
sessionHelper
.
getFetchRunnable
(
guids
now
(
)
null
versioningDelegateHelper
.
getFetchDelegate
(
delegate
)
)
)
;
}
Override
public
void
fetchAll
(
RepositorySessionFetchRecordsDelegate
delegate
)
{
if
(
this
.
storeTracker
=
=
null
)
{
throw
new
IllegalStateException
(
"
Store
tracker
not
yet
initialized
!
"
)
;
}
final
long
since
=
-
1L
;
Logger
.
debug
(
LOG_TAG
"
Running
fetchSince
(
"
+
since
+
"
)
.
"
)
;
delegateQueue
.
execute
(
sessionHelper
.
getFetchSinceRunnable
(
since
now
(
)
this
.
storeTracker
.
getFilter
(
)
versioningDelegateHelper
.
getFetchDelegate
(
delegate
)
)
)
;
}
Override
public
void
setStoreDelegate
(
RepositorySessionStoreDelegate
delegate
)
{
super
.
setStoreDelegate
(
versioningDelegateHelper
.
getStoreDelegate
(
delegate
)
)
;
}
Override
public
void
store
(
Record
record
)
throws
NoStoreDelegateException
{
if
(
storeDelegate
=
=
null
)
{
throw
new
NoStoreDelegateException
(
)
;
}
if
(
record
=
=
null
)
{
Logger
.
error
(
LOG_TAG
"
Record
sent
to
store
was
null
"
)
;
throw
new
IllegalArgumentException
(
"
Null
record
passed
to
AndroidBrowserRepositorySession
.
store
(
)
.
"
)
;
}
storeCount
+
=
1
;
Logger
.
debug
(
LOG_TAG
"
Storing
record
with
GUID
"
+
record
.
guid
+
"
(
stored
"
+
storeCount
+
"
records
this
session
)
.
"
)
;
storeWorkQueue
.
execute
(
sessionHelper
.
getStoreRunnable
(
record
storeDelegate
)
)
;
}
Override
public
void
wipe
(
RepositorySessionWipeDelegate
delegate
)
{
Runnable
command
=
sessionHelper
.
getWipeRunnable
(
delegate
)
;
storeWorkQueue
.
execute
(
command
)
;
}
Override
public
void
performCleanup
(
)
{
versioningDelegateHelper
.
persistSyncVersions
(
)
;
super
.
performCleanup
(
)
;
}
Override
public
void
begin
(
RepositorySessionBeginDelegate
delegate
)
throws
InvalidSessionTransitionException
{
try
{
Logger
.
debug
(
LOG_TAG
"
Check
and
build
special
GUIDs
.
"
)
;
dataAccessor
.
checkAndBuildSpecialGuids
(
)
;
Logger
.
debug
(
LOG_TAG
"
Got
GUIDs
for
folders
.
"
)
;
}
catch
(
android
.
database
.
sqlite
.
SQLiteConstraintException
e
)
{
Logger
.
error
(
LOG_TAG
"
Got
sqlite
constraint
exception
working
with
Fennec
bookmark
DB
.
"
e
)
;
delegate
.
onBeginFailed
(
e
)
;
return
;
}
catch
(
Exception
e
)
{
delegate
.
onBeginFailed
(
e
)
;
return
;
}
try
{
sessionHelper
.
doBegin
(
)
;
}
catch
(
NullCursorException
e
)
{
delegate
.
onBeginFailed
(
e
)
;
return
;
}
RepositorySessionBeginDelegate
deferredDelegate
=
delegate
.
deferredBeginDelegate
(
delegateQueue
)
;
super
.
sharedBegin
(
)
;
try
{
sessionHelper
.
checkDatabase
(
)
;
}
catch
(
ProfileDatabaseException
e
)
{
Logger
.
error
(
LOG_TAG
"
ProfileDatabaseException
from
begin
.
Fennec
must
be
launched
once
until
this
error
is
fixed
"
)
;
deferredDelegate
.
onBeginFailed
(
e
)
;
return
;
}
catch
(
Exception
e
)
{
deferredDelegate
.
onBeginFailed
(
e
)
;
return
;
}
storeTracker
=
createStoreTracker
(
)
;
deferredDelegate
.
onBeginSucceeded
(
this
)
;
}
Override
public
void
finish
(
RepositorySessionFinishDelegate
delegate
)
throws
InactiveSessionException
{
sessionHelper
.
finish
(
)
;
super
.
finish
(
delegate
)
;
}
;
Override
public
void
storeDone
(
)
{
storeWorkQueue
.
execute
(
sessionHelper
.
getStoreDoneRunnable
(
storeDelegate
)
)
;
storeWorkQueue
.
execute
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
storeDelegate
.
onStoreCompleted
(
now
(
)
)
;
}
}
)
;
}
}
