package
org
.
mozilla
.
gecko
.
fxa
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
ContentProvider
;
import
android
.
content
.
ContentValues
;
import
android
.
content
.
Context
;
import
android
.
content
.
UriMatcher
;
import
android
.
content
.
pm
.
PackageInfo
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
Signature
;
import
android
.
database
.
Cursor
;
import
android
.
database
.
MatrixCursor
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Binder
;
import
android
.
os
.
Build
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
apache
.
commons
.
codec
.
digest
.
DigestUtils
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
fxa
.
authenticator
.
AndroidFxAccount
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
Cohabiting
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
Married
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
State
;
import
org
.
mozilla
.
gecko
.
fxa
.
login
.
TokensAndKeysState
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
public
class
AuthStateProvider
extends
ContentProvider
{
static
final
String
LOG_TAG
=
"
AuthStateProvider
"
;
static
final
String
AUTHORITY
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
fxa
.
auth
"
;
static
final
String
AUTH_STATE_CONTENT_TYPE
=
"
vnd
.
android
.
cursor
.
item
/
vnd
.
"
+
AUTHORITY
+
"
.
state
"
;
static
final
int
AUTH_STATE
=
100
;
static
final
UriMatcher
URI_MATCHER
=
new
UriMatcher
(
UriMatcher
.
NO_MATCH
)
;
static
final
String
KEY_EMAIL
=
"
email
"
;
static
final
String
KEY_SESSION_TOKEN
=
"
sessionToken
"
;
static
final
String
KEY_KSYNC
=
"
kSync
"
;
static
final
String
KEY_KXSCS
=
"
kXSCS
"
;
private
final
String
[
]
queryProjection
=
new
String
[
]
{
KEY_EMAIL
KEY_SESSION_TOKEN
KEY_KSYNC
KEY_KXSCS
}
;
static
{
URI_MATCHER
.
addURI
(
AUTHORITY
"
state
"
AUTH_STATE
)
;
}
Override
public
boolean
onCreate
(
)
{
return
true
;
}
Nullable
Override
public
Cursor
query
(
NonNull
Uri
uri
Nullable
String
[
]
projection
Nullable
String
selection
Nullable
String
[
]
selectionArgs
Nullable
String
sortOrder
)
{
final
Context
context
=
getContext
(
)
;
if
(
context
=
=
null
)
{
return
null
;
}
if
(
!
isTrustedCaller
(
context
)
)
{
Log
.
d
(
LOG_TAG
"
Caller
must
be
whitelisted
.
"
)
;
return
null
;
}
final
int
match
=
URI_MATCHER
.
match
(
uri
)
;
switch
(
match
)
{
case
AUTH_STATE
:
{
Nullable
final
AndroidFxAccount
fxaAccount
=
AndroidFxAccount
.
fromContext
(
getContext
(
)
)
;
if
(
fxaAccount
=
=
null
)
{
return
null
;
}
final
String
email
=
fxaAccount
.
getEmail
(
)
;
final
State
accountState
;
try
{
accountState
=
fxaAccount
.
getState
(
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOG_TAG
"
Failed
to
read
account
state
"
e
)
;
return
null
;
}
final
MatrixCursor
cursor
=
new
MatrixCursor
(
queryProjection
1
)
;
if
(
accountState
instanceof
Cohabiting
|
|
accountState
instanceof
Married
)
{
final
TokensAndKeysState
tokensAndKeysState
=
(
TokensAndKeysState
)
accountState
;
final
byte
[
]
sessionToken
=
tokensAndKeysState
.
getSessionToken
(
)
;
final
byte
[
]
kSync
=
tokensAndKeysState
.
getKSync
(
)
;
final
String
kXSCS
=
tokensAndKeysState
.
getKXCS
(
)
;
cursor
.
addRow
(
new
Object
[
]
{
email
sessionToken
kSync
kXSCS
}
)
;
}
else
{
cursor
.
addRow
(
new
Object
[
]
{
email
null
null
null
}
)
;
}
return
cursor
;
}
default
:
{
Log
.
e
(
LOG_TAG
"
Unknown
query
URI
"
+
uri
)
;
}
}
return
null
;
}
Nullable
Override
public
String
getType
(
NonNull
Uri
uri
)
{
final
int
match
=
URI_MATCHER
.
match
(
uri
)
;
switch
(
match
)
{
case
AUTH_STATE
:
return
AUTH_STATE_CONTENT_TYPE
;
}
return
null
;
}
Nullable
Override
public
Uri
insert
(
NonNull
Uri
uri
Nullable
ContentValues
values
)
{
throw
new
UnsupportedOperationException
(
"
Insert
operation
not
supported
"
)
;
}
Override
public
int
delete
(
NonNull
Uri
uri
Nullable
String
selection
Nullable
String
[
]
selectionArgs
)
{
throw
new
UnsupportedOperationException
(
"
Delete
operation
not
supported
"
)
;
}
Override
public
int
update
(
NonNull
Uri
uri
Nullable
ContentValues
values
Nullable
String
selection
Nullable
String
[
]
selectionArgs
)
{
throw
new
UnsupportedOperationException
(
"
Update
operation
not
supported
"
)
;
}
private
boolean
isTrustedCaller
(
NonNull
Context
context
)
{
final
PackageManager
packageManager
=
context
.
getPackageManager
(
)
;
final
HashMap
<
String
String
>
packageToSignatureWhitelist
=
new
HashMap
<
>
(
)
;
packageToSignatureWhitelist
.
put
(
"
org
.
mozilla
.
fenix
"
"
5004779088e7f988d5bc5cc5f8798febf4f8cd084a1b2a46efd4c8ee4aeaf211
"
)
;
packageToSignatureWhitelist
.
put
(
"
mozilla
.
lockbox
"
"
64d26b507078deba2fee42d6bd0bfad41d39ffc4e791f281028e5e73d3c8d2f2
"
)
;
final
Map
<
String
String
>
immutablePackageWhitelist
=
Collections
.
unmodifiableMap
(
new
HashMap
<
String
String
>
(
packageToSignatureWhitelist
)
)
;
final
String
callerPackage
=
getCallerPackage
(
packageManager
)
;
if
(
callerPackage
=
=
null
)
{
return
false
;
}
final
String
expectedHash
=
immutablePackageWhitelist
.
get
(
callerPackage
)
;
if
(
expectedHash
=
=
null
)
{
return
false
;
}
final
Signature
callerSignature
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
P
)
{
callerSignature
=
getSignaturePostAPI28
(
packageManager
callerPackage
)
;
}
else
{
callerSignature
=
getSignaturePreAPI28
(
packageManager
callerPackage
)
;
}
if
(
callerSignature
=
=
null
)
{
return
false
;
}
final
String
callerSignatureHash
=
DigestUtils
.
sha256Hex
(
callerSignature
.
toByteArray
(
)
)
;
Log
.
d
(
LOG_TAG
"
Verifying
caller
'
s
signature
:
"
+
callerSignatureHash
)
;
final
boolean
result
=
expectedHash
.
equals
(
callerSignatureHash
)
;
if
(
result
)
{
Log
.
d
(
LOG_TAG
"
Success
!
"
)
;
}
else
{
Log
.
d
(
LOG_TAG
"
Failed
!
Signature
mismatch
for
calling
package
"
+
callerPackage
)
;
}
return
result
;
}
Nullable
private
static
Signature
getSignaturePreAPI28
(
final
PackageManager
packageManager
final
String
callerPackage
)
{
final
PackageInfo
packageInfo
;
try
{
packageInfo
=
packageManager
.
getPackageInfo
(
callerPackage
PackageManager
.
GET_SIGNATURES
)
;
}
catch
(
PackageManager
.
NameNotFoundException
e
)
{
throw
new
IllegalStateException
(
"
Package
name
no
longer
present
"
)
;
}
if
(
packageInfo
.
signatures
.
length
!
=
1
)
{
return
null
;
}
return
packageInfo
.
signatures
[
0
]
;
}
TargetApi
(
Build
.
VERSION_CODES
.
P
)
Nullable
private
Signature
getSignaturePostAPI28
(
final
PackageManager
packageManager
final
String
callerPackage
)
{
final
PackageInfo
packageInfo
;
try
{
packageInfo
=
packageManager
.
getPackageInfo
(
callerPackage
PackageManager
.
GET_SIGNING_CERTIFICATES
)
;
}
catch
(
PackageManager
.
NameNotFoundException
e
)
{
throw
new
IllegalStateException
(
"
Package
name
no
longer
present
"
)
;
}
if
(
packageInfo
.
signingInfo
.
hasMultipleSigners
(
)
)
{
return
null
;
}
if
(
packageInfo
.
signingInfo
.
hasPastSigningCertificates
(
)
)
{
return
null
;
}
return
packageInfo
.
signingInfo
.
getSigningCertificateHistory
(
)
[
0
]
;
}
Nullable
private
String
getCallerPackage
(
PackageManager
packageManager
)
{
final
int
callerUid
=
Binder
.
getCallingUid
(
)
;
final
String
legacyCallingPackage
=
packageManager
.
getNameForUid
(
callerUid
)
;
if
(
legacyCallingPackage
=
=
null
)
{
return
null
;
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
KITKAT
)
{
final
String
callingPackage
=
getCallingPackage
(
)
;
if
(
callingPackage
=
=
null
)
{
Log
.
e
(
LOG_TAG
"
Manually
obtained
a
calling
package
but
got
null
from
ContentProvider
.
getCallingPackage
(
)
"
)
;
return
null
;
}
if
(
!
legacyCallingPackage
.
equals
(
callingPackage
)
)
{
Log
.
e
(
LOG_TAG
"
Calling
package
disagreement
.
Legacy
:
"
+
legacyCallingPackage
+
"
new
API
:
"
+
callingPackage
)
;
return
null
;
}
}
return
legacyCallingPackage
;
}
}
