package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
uploaders
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
gecko
.
background
.
common
.
log
.
Logger
;
import
org
.
mozilla
.
gecko
.
sync
.
CollectionConcurrentModificationException
;
import
org
.
mozilla
.
gecko
.
sync
.
Server15RecordPostFailedException
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncResponse
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
SyncStorageResponse
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
concurrent
.
Executor
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicBoolean
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicLong
;
class
PayloadDispatcher
{
private
static
final
String
LOG_TAG
=
"
PayloadDispatcher
"
;
volatile
BatchMeta
batchWhiteboard
;
private
final
AtomicLong
uploadTimestamp
=
new
AtomicLong
(
0
)
;
private
final
Executor
executor
;
private
final
BatchingUploader
uploader
;
final
AtomicBoolean
storeFailed
=
new
AtomicBoolean
(
false
)
;
PayloadDispatcher
(
Executor
executor
BatchingUploader
uploader
Nullable
Long
initialLastModified
)
{
this
.
batchWhiteboard
=
new
BatchMeta
(
initialLastModified
null
)
;
this
.
uploader
=
uploader
;
this
.
executor
=
executor
;
}
void
queue
(
final
ArrayList
<
byte
[
]
>
outgoing
final
ArrayList
<
String
>
outgoingGuids
final
long
byteCount
final
boolean
isCommit
final
boolean
isLastPayload
)
{
executor
.
execute
(
new
BatchContextRunnable
(
isCommit
)
{
Override
public
void
run
(
)
{
createRecordUploadRunnable
(
outgoing
outgoingGuids
byteCount
isCommit
isLastPayload
)
.
run
(
)
;
}
}
)
;
}
void
setInBatchingMode
(
boolean
inBatchingMode
)
{
batchWhiteboard
.
setInBatchingMode
(
inBatchingMode
)
;
uploader
.
setUnlimitedMode
(
!
inBatchingMode
)
;
}
void
payloadSucceeded
(
final
SyncStorageResponse
response
final
boolean
isCommit
final
boolean
isLastPayload
)
{
if
(
batchWhiteboard
.
getInBatchingMode
(
)
=
=
null
)
{
throw
new
IllegalStateException
(
"
Can
'
t
process
payload
success
until
we
know
if
we
'
re
in
a
batching
mode
"
)
;
}
final
String
[
]
guids
=
batchWhiteboard
.
getSuccessRecordGuids
(
)
;
if
(
!
batchWhiteboard
.
getInBatchingMode
(
)
|
|
isCommit
)
{
for
(
String
guid
:
guids
)
{
uploader
.
sessionStoreDelegate
.
onRecordStoreSucceeded
(
guid
)
;
}
bumpTimestampTo
(
uploadTimestamp
response
.
normalizedTimestampForHeader
(
SyncResponse
.
X_LAST_MODIFIED
)
)
;
uploader
.
setLastStoreTimestamp
(
uploadTimestamp
)
;
batchWhiteboard
.
clearSuccessRecordGuids
(
)
;
}
if
(
isCommit
|
|
!
batchWhiteboard
.
getInBatchingMode
(
)
)
{
uploader
.
sessionStoreDelegate
.
onBatchCommitted
(
)
;
}
if
(
isLastPayload
)
{
uploader
.
finished
(
)
;
}
}
void
payloadFailed
(
Exception
e
)
{
doStoreFailed
(
e
)
;
}
void
finalizeQueue
(
final
boolean
needToCommit
final
Runnable
finalRunnable
)
{
executor
.
execute
(
new
NonPayloadContextRunnable
(
)
{
Override
public
void
run
(
)
{
if
(
needToCommit
&
&
Boolean
.
TRUE
.
equals
(
batchWhiteboard
.
getInBatchingMode
(
)
)
)
{
finalRunnable
.
run
(
)
;
}
else
{
uploader
.
finished
(
)
;
}
}
}
)
;
}
void
recordFailed
(
final
String
recordGuid
)
{
recordFailed
(
new
Server15RecordPostFailedException
(
)
recordGuid
)
;
}
void
recordFailed
(
final
Exception
e
final
String
recordGuid
)
{
Logger
.
debug
(
LOG_TAG
"
Record
store
failed
for
guid
"
+
recordGuid
+
"
with
exception
:
"
+
e
.
toString
(
)
)
;
uploader
.
sessionStoreDelegate
.
onRecordStoreFailed
(
e
recordGuid
)
;
}
void
concurrentModificationDetected
(
)
{
doStoreFailed
(
new
CollectionConcurrentModificationException
(
)
)
;
}
void
prepareForNextBatch
(
)
{
batchWhiteboard
=
batchWhiteboard
.
nextBatchMeta
(
)
;
}
void
doStoreFailed
(
Exception
reason
)
{
if
(
storeFailed
.
getAndSet
(
true
)
)
{
return
;
}
uploader
.
abort
(
)
;
uploader
.
sessionStoreDelegate
.
onStoreFailed
(
reason
)
;
}
private
static
void
bumpTimestampTo
(
final
AtomicLong
current
long
newValue
)
{
while
(
true
)
{
long
existing
=
current
.
get
(
)
;
if
(
existing
>
newValue
)
{
return
;
}
if
(
current
.
compareAndSet
(
existing
newValue
)
)
{
return
;
}
}
}
VisibleForTesting
Runnable
createRecordUploadRunnable
(
final
ArrayList
<
byte
[
]
>
outgoing
final
ArrayList
<
String
>
outgoingGuids
final
long
byteCount
final
boolean
isCommit
final
boolean
isLastPayload
)
{
return
new
RecordUploadRunnable
(
new
BatchingAtomicUploaderMayUploadProvider
(
)
uploader
.
collectionUri
batchWhiteboard
.
getToken
(
)
new
PayloadUploadDelegate
(
uploader
.
authHeaderProvider
PayloadDispatcher
.
this
outgoingGuids
isCommit
isLastPayload
)
outgoing
byteCount
isCommit
)
;
}
VisibleForTesting
abstract
static
class
BatchContextRunnable
implements
Runnable
{
boolean
isCommit
;
BatchContextRunnable
(
boolean
isCommit
)
{
this
.
isCommit
=
isCommit
;
}
}
VisibleForTesting
abstract
static
class
NonPayloadContextRunnable
implements
Runnable
{
}
private
class
BatchingAtomicUploaderMayUploadProvider
implements
MayUploadProvider
{
public
boolean
mayUpload
(
)
{
return
!
storeFailed
.
get
(
)
;
}
}
}
