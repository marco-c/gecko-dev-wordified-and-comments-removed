package
org
.
mozilla
.
gecko
.
sync
.
repositories
.
uploaders
;
import
android
.
support
.
annotation
.
CallSuper
;
import
android
.
support
.
annotation
.
CheckResult
;
public
abstract
class
BufferSizeTracker
{
protected
final
Object
accessLock
;
private
long
byteCount
=
BatchingUploader
.
PER_PAYLOAD_OVERHEAD_BYTE_COUNT
;
private
long
recordCount
=
0
;
private
Long
smallestRecordByteCount
;
protected
final
long
maxBytes
;
protected
final
long
maxRecords
;
public
BufferSizeTracker
(
Object
accessLock
long
maxBytes
long
maxRecords
)
{
this
.
accessLock
=
accessLock
;
this
.
maxBytes
=
maxBytes
;
this
.
maxRecords
=
maxRecords
;
}
CallSuper
protected
boolean
canFit
(
long
recordDeltaByteCount
)
{
synchronized
(
accessLock
)
{
return
canFitRecordByteDelta
(
recordDeltaByteCount
recordCount
byteCount
)
;
}
}
protected
boolean
isEmpty
(
)
{
synchronized
(
accessLock
)
{
return
recordCount
=
=
0
;
}
}
CheckResult
protected
boolean
addAndEstimateIfFull
(
long
recordDeltaByteCount
)
{
synchronized
(
accessLock
)
{
if
(
!
canFitRecordByteDelta
(
recordDeltaByteCount
recordCount
byteCount
)
)
{
throw
new
IllegalStateException
(
"
Buffer
size
exceeded
"
)
;
}
byteCount
+
=
recordDeltaByteCount
;
recordCount
+
=
1
;
if
(
smallestRecordByteCount
=
=
null
|
|
smallestRecordByteCount
>
recordDeltaByteCount
)
{
smallestRecordByteCount
=
recordDeltaByteCount
;
}
return
!
canFitRecordByteDelta
(
smallestRecordByteCount
/
2
recordCount
byteCount
)
;
}
}
protected
long
getByteCount
(
)
{
synchronized
(
accessLock
)
{
if
(
recordCount
=
=
0
)
{
return
byteCount
+
BatchingUploader
.
PER_PAYLOAD_OVERHEAD_BYTE_COUNT
;
}
return
byteCount
;
}
}
protected
long
getRecordCount
(
)
{
synchronized
(
accessLock
)
{
return
recordCount
;
}
}
CallSuper
protected
boolean
canFitRecordByteDelta
(
long
byteDelta
long
recordCount
long
byteCount
)
{
return
recordCount
<
maxRecords
&
&
(
byteCount
+
byteDelta
)
<
=
maxBytes
;
}
}
