package
org
.
mozilla
.
gecko
.
dlc
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
background
.
nativecode
.
NativeCrypto
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContent
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
android
.
content
.
Context
;
import
android
.
net
.
ConnectivityManager
;
import
android
.
support
.
v4
.
net
.
ConnectivityManagerCompat
;
import
android
.
util
.
Log
;
import
ch
.
boye
.
httpclientandroidlib
.
HttpEntity
;
import
ch
.
boye
.
httpclientandroidlib
.
HttpResponse
;
import
ch
.
boye
.
httpclientandroidlib
.
HttpStatus
;
import
ch
.
boye
.
httpclientandroidlib
.
client
.
HttpClient
;
import
ch
.
boye
.
httpclientandroidlib
.
client
.
methods
.
HttpGet
;
import
ch
.
boye
.
httpclientandroidlib
.
impl
.
client
.
DefaultHttpRequestRetryHandler
;
import
ch
.
boye
.
httpclientandroidlib
.
impl
.
client
.
HttpClientBuilder
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
util
.
zip
.
GZIPInputStream
;
class
DownloadContentHelper
{
private
static
final
String
LOGTAG
=
"
GeckoDLCHelper
"
;
public
static
final
String
ACTION_STUDY_CATALOG
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
DLC
.
STUDY
"
;
public
static
final
String
ACTION_VERIFY_CONTENT
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
DLC
.
VERIFY
"
;
public
static
final
String
ACTION_DOWNLOAD_CONTENT
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
DLC
.
DOWNLOAD
"
;
private
static
final
String
CDN_BASE_URL
=
"
https
:
/
/
mobile
.
cdn
.
mozilla
.
net
/
"
;
private
static
final
String
CACHE_DIRECTORY
=
"
downloadContent
"
;
static
class
RecoverableDownloadContentException
extends
Exception
{
private
static
final
long
serialVersionUID
=
-
2246772819507370734L
;
public
RecoverableDownloadContentException
(
String
message
)
{
super
(
message
)
;
}
public
RecoverableDownloadContentException
(
Throwable
cause
)
{
super
(
cause
)
;
}
}
static
class
UnrecoverableDownloadContentException
extends
Exception
{
private
static
final
long
serialVersionUID
=
8956080754787367105L
;
public
UnrecoverableDownloadContentException
(
String
message
)
{
super
(
message
)
;
}
public
UnrecoverableDownloadContentException
(
Throwable
cause
)
{
super
(
cause
)
;
}
}
static
HttpClient
buildHttpClient
(
)
{
return
HttpClientBuilder
.
create
(
)
.
setUserAgent
(
HardwareUtils
.
isTablet
(
)
?
AppConstants
.
USER_AGENT_FENNEC_TABLET
:
AppConstants
.
USER_AGENT_FENNEC_MOBILE
)
.
setRetryHandler
(
new
DefaultHttpRequestRetryHandler
(
)
)
.
build
(
)
;
}
static
File
createTemporaryFile
(
Context
context
DownloadContent
content
)
throws
RecoverableDownloadContentException
{
File
cacheDirectory
=
new
File
(
context
.
getCacheDir
(
)
CACHE_DIRECTORY
)
;
if
(
!
cacheDirectory
.
exists
(
)
&
&
!
cacheDirectory
.
mkdirs
(
)
)
{
throw
new
RecoverableDownloadContentException
(
"
Could
not
create
cache
directory
:
"
+
cacheDirectory
)
;
}
return
new
File
(
cacheDirectory
content
.
getDownloadChecksum
(
)
+
"
-
"
+
content
.
getId
(
)
)
;
}
static
void
download
(
HttpClient
client
String
source
File
temporaryFile
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
OutputStream
outputStream
=
null
;
final
HttpGet
request
=
new
HttpGet
(
source
)
;
try
{
final
HttpResponse
response
=
client
.
execute
(
request
)
;
final
int
status
=
response
.
getStatusLine
(
)
.
getStatusCode
(
)
;
if
(
status
!
=
HttpStatus
.
SC_OK
)
{
if
(
status
>
=
500
)
{
throw
new
RecoverableDownloadContentException
(
"
(
Recoverable
)
Download
failed
.
Status
code
:
"
+
status
)
;
}
else
if
(
status
>
=
400
)
{
throw
new
UnrecoverableDownloadContentException
(
"
(
Unrecoverable
)
Download
failed
.
Status
code
:
"
+
status
)
;
}
else
{
throw
new
UnrecoverableDownloadContentException
(
"
(
Unrecoverable
)
Download
failed
.
Status
code
:
"
+
status
)
;
}
}
final
HttpEntity
entity
=
response
.
getEntity
(
)
;
if
(
entity
=
=
null
)
{
throw
new
RecoverableDownloadContentException
(
"
Null
entity
"
)
;
}
inputStream
=
new
BufferedInputStream
(
entity
.
getContent
(
)
)
;
outputStream
=
new
BufferedOutputStream
(
new
FileOutputStream
(
temporaryFile
)
)
;
IOUtils
.
copy
(
inputStream
outputStream
)
;
inputStream
.
close
(
)
;
outputStream
.
close
(
)
;
}
catch
(
IOException
e
)
{
temporaryFile
.
delete
(
)
;
throw
new
RecoverableDownloadContentException
(
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
IOUtils
.
safeStreamClose
(
outputStream
)
;
}
}
static
boolean
verify
(
File
file
String
expectedChecksum
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
try
{
inputStream
=
new
BufferedInputStream
(
new
FileInputStream
(
file
)
)
;
byte
[
]
ctx
=
NativeCrypto
.
sha256init
(
)
;
if
(
ctx
=
=
null
)
{
throw
new
RecoverableDownloadContentException
(
"
Could
not
create
SHA
-
256
context
"
)
;
}
byte
[
]
buffer
=
new
byte
[
4096
]
;
int
read
;
while
(
(
read
=
inputStream
.
read
(
buffer
)
)
!
=
-
1
)
{
NativeCrypto
.
sha256update
(
ctx
buffer
read
)
;
}
String
actualChecksum
=
Utils
.
byte2Hex
(
NativeCrypto
.
sha256finalize
(
ctx
)
)
;
if
(
!
actualChecksum
.
equalsIgnoreCase
(
expectedChecksum
)
)
{
Log
.
w
(
LOGTAG
"
Checksums
do
not
match
.
Expected
=
"
+
expectedChecksum
+
"
Actual
=
"
+
actualChecksum
)
;
return
false
;
}
return
true
;
}
catch
(
IOException
e
)
{
throw
new
RecoverableDownloadContentException
(
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
}
}
static
void
move
(
File
temporaryFile
File
destinationFile
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
if
(
!
temporaryFile
.
renameTo
(
destinationFile
)
)
{
Log
.
d
(
LOGTAG
"
Could
not
move
temporary
file
to
destination
.
Trying
to
copy
.
.
"
)
;
copy
(
temporaryFile
destinationFile
)
;
temporaryFile
.
delete
(
)
;
}
}
static
void
extract
(
File
sourceFile
File
destinationFile
String
checksum
)
throws
UnrecoverableDownloadContentException
RecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
OutputStream
outputStream
=
null
;
File
temporaryFile
=
null
;
try
{
File
destinationDirectory
=
destinationFile
.
getParentFile
(
)
;
if
(
!
destinationDirectory
.
exists
(
)
&
&
!
destinationDirectory
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Destination
directory
does
not
exist
and
cannot
be
created
"
)
;
}
temporaryFile
=
new
File
(
destinationDirectory
destinationFile
.
getName
(
)
+
"
.
tmp
"
)
;
inputStream
=
new
GZIPInputStream
(
new
BufferedInputStream
(
new
FileInputStream
(
sourceFile
)
)
)
;
outputStream
=
new
BufferedOutputStream
(
new
FileOutputStream
(
temporaryFile
)
)
;
IOUtils
.
copy
(
inputStream
outputStream
)
;
inputStream
.
close
(
)
;
outputStream
.
close
(
)
;
if
(
!
verify
(
temporaryFile
checksum
)
)
{
Log
.
w
(
LOGTAG
"
Checksum
of
extracted
file
does
not
match
.
"
)
;
return
;
}
move
(
temporaryFile
destinationFile
)
;
}
catch
(
IOException
e
)
{
throw
new
UnrecoverableDownloadContentException
(
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
IOUtils
.
safeStreamClose
(
outputStream
)
;
if
(
temporaryFile
!
=
null
&
&
temporaryFile
.
exists
(
)
)
{
temporaryFile
.
delete
(
)
;
}
}
}
private
static
void
copy
(
File
temporaryFile
File
destinationFile
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
OutputStream
outputStream
=
null
;
try
{
File
destinationDirectory
=
destinationFile
.
getParentFile
(
)
;
if
(
!
destinationDirectory
.
exists
(
)
&
&
!
destinationDirectory
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Destination
directory
does
not
exist
and
cannot
be
created
"
)
;
}
inputStream
=
new
BufferedInputStream
(
new
FileInputStream
(
temporaryFile
)
)
;
outputStream
=
new
BufferedOutputStream
(
new
FileOutputStream
(
destinationFile
)
)
;
IOUtils
.
copy
(
inputStream
outputStream
)
;
inputStream
.
close
(
)
;
outputStream
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
UnrecoverableDownloadContentException
(
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
IOUtils
.
safeStreamClose
(
outputStream
)
;
}
}
static
File
getDestinationFile
(
Context
context
DownloadContent
content
)
throws
UnrecoverableDownloadContentException
{
if
(
content
.
isFont
(
)
)
{
return
new
File
(
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
"
fonts
"
)
content
.
getFilename
(
)
)
;
}
throw
new
UnrecoverableDownloadContentException
(
"
Can
'
t
determine
destination
for
kind
:
"
+
content
.
getKind
(
)
)
;
}
static
boolean
isActiveNetworkMetered
(
Context
context
)
{
return
ConnectivityManagerCompat
.
isActiveNetworkMetered
(
(
ConnectivityManager
)
context
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
)
;
}
static
String
createDownloadURL
(
DownloadContent
content
)
{
return
CDN_BASE_URL
+
content
.
getLocation
(
)
;
}
}
