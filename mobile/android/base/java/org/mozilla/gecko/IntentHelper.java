package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
overlays
.
ui
.
ShareDialog
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityResultHandler
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
JSONUtils
;
import
org
.
mozilla
.
gecko
.
util
.
NativeEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
NativeJSObject
;
import
org
.
mozilla
.
gecko
.
util
.
WebActivityMapper
;
import
org
.
mozilla
.
gecko
.
widget
.
ExternalIntentDuringPrivateBrowsingPromptFragment
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ResolveInfo
;
import
android
.
net
.
Uri
;
import
android
.
provider
.
Browser
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
v4
.
app
.
FragmentActivity
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
webkit
.
MimeTypeMap
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
net
.
URLEncoder
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
public
final
class
IntentHelper
implements
GeckoEventListener
NativeEventListener
{
private
static
final
String
LOGTAG
=
"
GeckoIntentHelper
"
;
private
static
final
String
[
]
EVENTS
=
{
"
Intent
:
GetHandlers
"
"
Intent
:
Open
"
"
Intent
:
OpenForResult
"
"
WebActivity
:
Open
"
}
;
private
static
final
String
[
]
NATIVE_EVENTS
=
{
"
Intent
:
OpenNoHandler
"
}
;
private
static
String
MARKET_INTENT_URI_PACKAGE_PREFIX
=
"
market
:
/
/
details
?
id
=
"
;
private
static
String
EXTRA_BROWSER_FALLBACK_URL
=
"
browser_fallback_url
"
;
private
static
String
UNKNOWN_PROTOCOL_URI_PREFIX
=
"
about
:
neterror
?
e
=
unknownProtocolFound
&
u
=
"
;
private
static
IntentHelper
instance
;
private
final
FragmentActivity
activity
;
private
IntentHelper
(
final
FragmentActivity
activity
)
{
this
.
activity
=
activity
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
(
GeckoEventListener
)
this
EVENTS
)
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
(
NativeEventListener
)
this
NATIVE_EVENTS
)
;
}
public
static
IntentHelper
init
(
final
FragmentActivity
activity
)
{
if
(
instance
=
=
null
)
{
instance
=
new
IntentHelper
(
activity
)
;
}
else
{
Log
.
w
(
LOGTAG
"
IntentHelper
.
init
(
)
called
twice
ignoring
.
"
)
;
}
return
instance
;
}
public
static
void
destroy
(
)
{
if
(
instance
!
=
null
)
{
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
(
GeckoEventListener
)
instance
EVENTS
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
(
NativeEventListener
)
instance
NATIVE_EVENTS
)
;
instance
=
null
;
}
}
public
static
boolean
openUriExternal
(
String
targetURI
String
mimeType
String
packageName
String
className
String
action
String
title
final
boolean
showPromptInPrivateBrowsing
)
{
final
GeckoAppShell
.
GeckoInterface
gi
=
GeckoAppShell
.
getGeckoInterface
(
)
;
final
Context
activityContext
=
gi
!
=
null
?
gi
.
getActivity
(
)
:
null
;
final
Context
context
=
activityContext
!
=
null
?
activityContext
:
GeckoAppShell
.
getApplicationContext
(
)
;
final
Intent
intent
=
getOpenURIIntent
(
context
targetURI
mimeType
action
title
)
;
if
(
intent
=
=
null
)
{
return
false
;
}
if
(
!
TextUtils
.
isEmpty
(
className
)
)
{
if
(
!
TextUtils
.
isEmpty
(
packageName
)
)
{
intent
.
setClassName
(
packageName
className
)
;
}
else
{
intent
.
setClassName
(
context
className
)
;
}
}
if
(
!
showPromptInPrivateBrowsing
|
|
activityContext
=
=
null
)
{
if
(
activityContext
=
=
null
)
{
intent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
}
return
ActivityHandlerHelper
.
startIntentAndCatch
(
LOGTAG
context
intent
)
;
}
else
{
final
FragmentActivity
fragmentActivity
=
(
FragmentActivity
)
activityContext
;
return
ExternalIntentDuringPrivateBrowsingPromptFragment
.
showDialogOrAndroidChooser
(
context
fragmentActivity
.
getSupportFragmentManager
(
)
intent
)
;
}
}
public
static
boolean
hasHandlersForIntent
(
Intent
intent
)
{
try
{
return
!
GeckoAppShell
.
queryIntentActivities
(
intent
)
.
isEmpty
(
)
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
in
hasHandlersForIntent
"
)
;
return
false
;
}
}
public
static
String
[
]
getHandlersForIntent
(
Intent
intent
)
{
final
PackageManager
pm
=
GeckoAppShell
.
getApplicationContext
(
)
.
getPackageManager
(
)
;
try
{
final
List
<
ResolveInfo
>
list
=
GeckoAppShell
.
queryIntentActivities
(
intent
)
;
int
numAttr
=
4
;
final
String
[
]
ret
=
new
String
[
list
.
size
(
)
*
numAttr
]
;
for
(
int
i
=
0
;
i
<
list
.
size
(
)
;
i
+
+
)
{
ResolveInfo
resolveInfo
=
list
.
get
(
i
)
;
ret
[
i
*
numAttr
]
=
resolveInfo
.
loadLabel
(
pm
)
.
toString
(
)
;
if
(
resolveInfo
.
isDefault
)
ret
[
i
*
numAttr
+
1
]
=
"
default
"
;
else
ret
[
i
*
numAttr
+
1
]
=
"
"
;
ret
[
i
*
numAttr
+
2
]
=
resolveInfo
.
activityInfo
.
applicationInfo
.
packageName
;
ret
[
i
*
numAttr
+
3
]
=
resolveInfo
.
activityInfo
.
name
;
}
return
ret
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
in
getHandlersForIntent
"
)
;
return
new
String
[
0
]
;
}
}
public
static
Intent
getIntentForActionString
(
String
aAction
)
{
if
(
TextUtils
.
isEmpty
(
aAction
)
)
{
return
new
Intent
(
Intent
.
ACTION_VIEW
)
;
}
return
new
Intent
(
aAction
)
;
}
public
static
Intent
getShareIntent
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
title
)
{
Intent
shareIntent
=
getIntentForActionString
(
Intent
.
ACTION_SEND
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TEXT
targetURI
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_SUBJECT
title
)
;
shareIntent
.
putExtra
(
ShareDialog
.
INTENT_EXTRA_DEVICES_ONLY
true
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TITLE
title
)
;
if
(
mimeType
!
=
null
&
&
mimeType
.
length
(
)
>
0
)
{
shareIntent
.
setType
(
mimeType
)
;
}
return
shareIntent
;
}
static
Intent
getOpenURIIntent
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
action
final
String
title
)
{
final
Intent
intent
=
getOpenURIIntentInner
(
context
targetURI
mimeType
action
title
)
;
if
(
intent
!
=
null
)
{
intent
.
putExtra
(
Browser
.
EXTRA_APPLICATION_ID
AppConstants
.
ANDROID_PACKAGE_NAME
)
;
}
return
intent
;
}
private
static
Intent
getOpenURIIntentInner
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
action
final
String
title
)
{
if
(
action
.
equalsIgnoreCase
(
Intent
.
ACTION_SEND
)
)
{
Intent
shareIntent
=
getShareIntent
(
context
targetURI
mimeType
title
)
;
return
Intent
.
createChooser
(
shareIntent
context
.
getResources
(
)
.
getString
(
R
.
string
.
share_title
)
)
;
}
Uri
uri
=
normalizeUriScheme
(
targetURI
.
indexOf
(
'
:
'
)
>
=
0
?
Uri
.
parse
(
targetURI
)
:
new
Uri
.
Builder
(
)
.
scheme
(
targetURI
)
.
build
(
)
)
;
if
(
!
TextUtils
.
isEmpty
(
mimeType
)
)
{
Intent
intent
=
getIntentForActionString
(
action
)
;
intent
.
setDataAndType
(
uri
mimeType
)
;
return
intent
;
}
if
(
!
GeckoAppShell
.
isUriSafeForScheme
(
uri
)
)
{
return
null
;
}
final
String
scheme
=
uri
.
getScheme
(
)
;
if
(
"
intent
"
.
equals
(
scheme
)
|
|
"
android
-
app
"
.
equals
(
scheme
)
)
{
final
Intent
intent
;
try
{
intent
=
Intent
.
parseUri
(
targetURI
0
)
;
}
catch
(
final
URISyntaxException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
parse
URI
-
"
+
e
)
;
return
null
;
}
intent
.
addCategory
(
Intent
.
CATEGORY_BROWSABLE
)
;
intent
.
setComponent
(
null
)
;
nullIntentSelector
(
intent
)
;
return
intent
;
}
final
String
extension
=
MimeTypeMap
.
getFileExtensionFromUrl
(
targetURI
)
;
final
Intent
intent
=
getIntentForActionString
(
action
)
;
intent
.
setData
(
uri
)
;
if
(
"
file
"
.
equals
(
scheme
)
)
{
final
String
mimeType2
=
GeckoAppShell
.
getMimeTypeFromExtension
(
extension
)
;
intent
.
setType
(
mimeType2
)
;
return
intent
;
}
if
(
!
"
sms
"
.
equals
(
scheme
)
&
&
!
"
smsto
"
.
equals
(
scheme
)
&
&
!
"
mms
"
.
equals
(
scheme
)
&
&
!
"
mmsto
"
.
equals
(
scheme
)
)
{
return
intent
;
}
final
String
query
=
uri
.
getEncodedQuery
(
)
;
if
(
TextUtils
.
isEmpty
(
query
)
)
{
return
intent
;
}
String
currentUri
=
uri
.
toString
(
)
;
String
correctlyFormattedDataURIScheme
=
scheme
+
"
:
/
/
"
;
if
(
!
currentUri
.
contains
(
correctlyFormattedDataURIScheme
)
)
{
uri
=
Uri
.
parse
(
currentUri
.
replaceFirst
(
scheme
+
"
:
"
correctlyFormattedDataURIScheme
)
)
;
}
final
String
[
]
fields
=
query
.
split
(
"
&
"
)
;
boolean
shouldUpdateIntent
=
false
;
String
resultQuery
=
"
"
;
for
(
String
field
:
fields
)
{
if
(
field
.
startsWith
(
"
body
=
"
)
)
{
final
String
body
=
Uri
.
decode
(
field
.
substring
(
5
)
)
;
intent
.
putExtra
(
"
sms_body
"
body
)
;
shouldUpdateIntent
=
true
;
}
else
if
(
field
.
startsWith
(
"
subject
=
"
)
)
{
final
String
subject
=
Uri
.
decode
(
field
.
substring
(
8
)
)
;
intent
.
putExtra
(
"
subject
"
subject
)
;
shouldUpdateIntent
=
true
;
}
else
if
(
field
.
startsWith
(
"
cc
=
"
)
)
{
final
String
ccNumber
=
Uri
.
decode
(
field
.
substring
(
3
)
)
;
String
phoneNumber
=
uri
.
getAuthority
(
)
;
if
(
phoneNumber
!
=
null
)
{
uri
=
uri
.
buildUpon
(
)
.
encodedAuthority
(
phoneNumber
+
"
;
"
+
ccNumber
)
.
build
(
)
;
}
shouldUpdateIntent
=
true
;
}
else
{
resultQuery
=
resultQuery
.
concat
(
resultQuery
.
length
(
)
>
0
?
"
&
"
+
field
:
field
)
;
}
}
if
(
!
shouldUpdateIntent
)
{
return
intent
;
}
final
String
newQuery
=
resultQuery
.
length
(
)
>
0
?
"
?
"
+
resultQuery
:
"
"
;
final
Uri
pruned
=
uri
.
buildUpon
(
)
.
encodedQuery
(
newQuery
)
.
build
(
)
;
intent
.
setData
(
pruned
)
;
return
intent
;
}
TargetApi
(
15
)
private
static
void
nullIntentSelector
(
final
Intent
intent
)
{
if
(
!
AppConstants
.
Versions
.
feature15Plus
)
{
return
;
}
intent
.
setSelector
(
null
)
;
}
private
static
Uri
normalizeUriScheme
(
final
Uri
u
)
{
final
String
scheme
=
u
.
getScheme
(
)
;
final
String
lower
=
scheme
.
toLowerCase
(
Locale
.
US
)
;
if
(
lower
.
equals
(
scheme
)
)
{
return
u
;
}
return
u
.
buildUpon
(
)
.
scheme
(
lower
)
.
build
(
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
NativeJSObject
message
final
EventCallback
callback
)
{
if
(
event
.
equals
(
"
Intent
:
OpenNoHandler
"
)
)
{
openNoHandler
(
message
callback
)
;
}
}
Override
public
void
handleMessage
(
String
event
JSONObject
message
)
{
try
{
if
(
event
.
equals
(
"
Intent
:
GetHandlers
"
)
)
{
getHandlers
(
message
)
;
}
else
if
(
event
.
equals
(
"
Intent
:
Open
"
)
)
{
open
(
message
)
;
}
else
if
(
event
.
equals
(
"
Intent
:
OpenForResult
"
)
)
{
openForResult
(
message
)
;
}
else
if
(
event
.
equals
(
"
WebActivity
:
Open
"
)
)
{
openWebActivity
(
message
)
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Exception
handling
message
\
"
"
+
event
+
"
\
"
:
"
e
)
;
}
}
private
void
getHandlers
(
JSONObject
message
)
throws
JSONException
{
final
Intent
intent
=
getOpenURIIntent
(
activity
message
.
optString
(
"
url
"
)
message
.
optString
(
"
mime
"
)
message
.
optString
(
"
action
"
)
message
.
optString
(
"
title
"
)
)
;
final
List
<
String
>
appList
=
Arrays
.
asList
(
getHandlersForIntent
(
intent
)
)
;
final
JSONObject
response
=
new
JSONObject
(
)
;
response
.
put
(
"
apps
"
new
JSONArray
(
appList
)
)
;
EventDispatcher
.
sendResponse
(
message
response
)
;
}
private
void
open
(
JSONObject
message
)
throws
JSONException
{
openUriExternal
(
message
.
optString
(
"
url
"
)
message
.
optString
(
"
mime
"
)
message
.
optString
(
"
packageName
"
)
message
.
optString
(
"
className
"
)
message
.
optString
(
"
action
"
)
message
.
optString
(
"
title
"
)
false
)
;
}
private
void
openForResult
(
final
JSONObject
message
)
throws
JSONException
{
Intent
intent
=
getOpenURIIntent
(
activity
message
.
optString
(
"
url
"
)
message
.
optString
(
"
mime
"
)
message
.
optString
(
"
action
"
)
message
.
optString
(
"
title
"
)
)
;
intent
.
setClassName
(
message
.
optString
(
"
packageName
"
)
message
.
optString
(
"
className
"
)
)
;
intent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_CLEAR_TOP
)
;
final
ResultHandler
handler
=
new
ResultHandler
(
message
)
;
try
{
ActivityHandlerHelper
.
startIntentForActivity
(
activity
intent
handler
)
;
}
catch
(
SecurityException
e
)
{
Log
.
w
(
LOGTAG
"
Forbidden
to
launch
activity
.
"
e
)
;
}
}
private
void
openNoHandler
(
final
NativeJSObject
msg
final
EventCallback
callback
)
{
final
String
uri
=
msg
.
getString
(
"
uri
"
)
;
if
(
TextUtils
.
isEmpty
(
uri
)
)
{
Log
.
w
(
LOGTAG
"
Received
empty
URL
-
loading
about
:
neterror
"
)
;
callback
.
sendError
(
getUnknownProtocolErrorPageUri
(
"
"
)
)
;
return
;
}
final
Intent
intent
;
try
{
intent
=
Intent
.
parseUri
(
uri
0
)
;
}
catch
(
final
URISyntaxException
e
)
{
String
errorUri
;
try
{
errorUri
=
getUnknownProtocolErrorPageUri
(
URLEncoder
.
encode
(
uri
"
UTF
-
8
"
)
)
;
}
catch
(
final
UnsupportedEncodingException
encodingE
)
{
errorUri
=
getUnknownProtocolErrorPageUri
(
"
"
)
;
}
Log
.
w
(
LOGTAG
"
Unable
to
parse
Intent
URI
-
loading
about
:
neterror
"
)
;
callback
.
sendError
(
errorUri
)
;
return
;
}
final
String
fallbackUrl
=
intent
.
getStringExtra
(
EXTRA_BROWSER_FALLBACK_URL
)
;
if
(
isFallbackUrlValid
(
fallbackUrl
)
)
{
callback
.
sendError
(
fallbackUrl
)
;
}
else
if
(
intent
.
getPackage
(
)
!
=
null
)
{
final
String
marketUri
=
MARKET_INTENT_URI_PACKAGE_PREFIX
+
intent
.
getPackage
(
)
;
final
Intent
marketIntent
=
new
Intent
(
Intent
.
ACTION_VIEW
Uri
.
parse
(
marketUri
)
)
;
marketIntent
.
addCategory
(
Intent
.
CATEGORY_BROWSABLE
)
;
marketIntent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
ExternalIntentDuringPrivateBrowsingPromptFragment
.
showDialogOrAndroidChooser
(
activity
activity
.
getSupportFragmentManager
(
)
marketIntent
)
;
callback
.
sendSuccess
(
null
)
;
}
else
{
Log
.
w
(
LOGTAG
"
Unable
to
open
URI
-
ignoring
click
"
)
;
callback
.
sendSuccess
(
null
)
;
}
}
private
static
boolean
isFallbackUrlValid
(
Nullable
final
String
fallbackUrl
)
{
if
(
fallbackUrl
=
=
null
)
{
return
false
;
}
try
{
final
String
anyCaseScheme
=
new
URI
(
fallbackUrl
)
.
getScheme
(
)
;
final
String
scheme
=
(
anyCaseScheme
=
=
null
)
?
null
:
anyCaseScheme
.
toLowerCase
(
Locale
.
US
)
;
if
(
"
http
"
.
equals
(
scheme
)
|
|
"
https
"
.
equals
(
scheme
)
)
{
return
true
;
}
else
{
Log
.
w
(
LOGTAG
"
Fallback
URI
uses
unsupported
scheme
:
"
+
scheme
+
"
.
Try
http
or
https
.
"
)
;
}
}
catch
(
final
URISyntaxException
e
)
{
Log
.
w
(
LOGTAG
"
URISyntaxException
parsing
fallback
URI
"
)
;
}
return
false
;
}
private
String
getUnknownProtocolErrorPageUri
(
final
String
encodedUri
)
{
return
UNKNOWN_PROTOCOL_URI_PREFIX
+
encodedUri
;
}
private
void
openWebActivity
(
JSONObject
message
)
throws
JSONException
{
final
Intent
intent
=
WebActivityMapper
.
getIntentForWebActivity
(
message
.
getJSONObject
(
"
activity
"
)
)
;
ActivityHandlerHelper
.
startIntentForActivity
(
activity
intent
new
ResultHandler
(
message
)
)
;
}
private
static
class
ResultHandler
implements
ActivityResultHandler
{
private
final
JSONObject
message
;
public
ResultHandler
(
JSONObject
message
)
{
this
.
message
=
message
;
}
Override
public
void
onActivityResult
(
int
resultCode
Intent
data
)
{
JSONObject
response
=
new
JSONObject
(
)
;
try
{
if
(
data
!
=
null
)
{
if
(
data
.
getExtras
(
)
!
=
null
)
{
response
.
put
(
"
extras
"
JSONUtils
.
bundleToJSON
(
data
.
getExtras
(
)
)
)
;
}
if
(
data
.
getData
(
)
!
=
null
)
{
response
.
put
(
"
uri
"
data
.
getData
(
)
.
toString
(
)
)
;
}
}
response
.
put
(
"
resultCode
"
resultCode
)
;
}
catch
(
JSONException
e
)
{
Log
.
w
(
LOGTAG
"
Error
building
JSON
response
.
"
e
)
;
}
EventDispatcher
.
sendResponse
(
message
response
)
;
}
}
}
