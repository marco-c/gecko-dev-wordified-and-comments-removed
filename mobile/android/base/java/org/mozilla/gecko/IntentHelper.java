package
org
.
mozilla
.
gecko
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
overlays
.
ui
.
ShareDialog
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityResultHandler
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
webapps
.
WebAppActivity
;
import
org
.
mozilla
.
gecko
.
widget
.
ExternalIntentDuringPrivateBrowsingPromptFragment
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ResolveInfo
;
import
android
.
net
.
Uri
;
import
android
.
provider
.
Browser
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
v4
.
app
.
FragmentActivity
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
webkit
.
MimeTypeMap
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
net
.
URLEncoder
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
static
org
.
mozilla
.
gecko
.
Tabs
.
INTENT_EXTRA_SESSION_UUID
;
import
static
org
.
mozilla
.
gecko
.
Tabs
.
INTENT_EXTRA_TAB_ID
;
public
final
class
IntentHelper
implements
BundleEventListener
{
private
static
final
String
LOGTAG
=
"
GeckoIntentHelper
"
;
private
static
final
String
[
]
GECKO_EVENTS
=
{
"
Intent
:
GetHandlers
"
}
;
private
static
final
String
[
]
UI_EVENTS
=
{
"
Intent
:
Open
"
"
Intent
:
OpenForResult
"
"
Intent
:
OpenNoHandler
"
}
;
private
static
String
MARKET_INTENT_URI_PACKAGE_PREFIX
=
"
market
:
/
/
details
?
id
=
"
;
private
static
String
EXTRA_BROWSER_FALLBACK_URL
=
"
browser_fallback_url
"
;
private
static
String
UNKNOWN_PROTOCOL_URI_PREFIX
=
"
about
:
neterror
?
e
=
unknownProtocolFound
&
u
=
"
;
private
static
IntentHelper
instance
;
private
IntentHelper
(
)
{
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
this
GECKO_EVENTS
)
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
UI_EVENTS
)
;
}
public
static
IntentHelper
init
(
)
{
if
(
instance
=
=
null
)
{
instance
=
new
IntentHelper
(
)
;
}
else
{
Log
.
w
(
LOGTAG
"
IntentHelper
.
init
(
)
called
twice
ignoring
.
"
)
;
}
return
instance
;
}
private
static
FragmentActivity
getActivity
(
)
{
final
Activity
activity
=
GeckoActivityMonitor
.
getInstance
(
)
.
getCurrentActivity
(
)
;
if
(
activity
instanceof
FragmentActivity
)
{
return
(
FragmentActivity
)
activity
;
}
return
null
;
}
private
static
Context
getContext
(
)
{
final
Activity
activity
=
GeckoActivityMonitor
.
getInstance
(
)
.
getCurrentActivity
(
)
;
return
(
activity
!
=
null
)
?
activity
:
GeckoAppShell
.
getApplicationContext
(
)
;
}
public
static
boolean
openUriExternal
(
String
targetURI
String
mimeType
String
packageName
String
className
String
action
String
title
final
boolean
showPromptInPrivateBrowsing
)
{
final
Context
context
=
getContext
(
)
;
final
Intent
intent
=
getOpenURIIntent
(
context
targetURI
mimeType
action
title
)
;
if
(
intent
=
=
null
)
{
return
false
;
}
if
(
!
TextUtils
.
isEmpty
(
className
)
)
{
if
(
!
TextUtils
.
isEmpty
(
packageName
)
)
{
intent
.
setClassName
(
packageName
className
)
;
}
else
{
intent
.
setClassName
(
context
className
)
;
}
}
final
FragmentActivity
activity
=
getActivity
(
)
;
if
(
!
showPromptInPrivateBrowsing
|
|
activity
=
=
null
)
{
if
(
activity
=
=
null
)
{
intent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
}
return
ActivityHandlerHelper
.
startIntentAndCatch
(
LOGTAG
context
intent
)
;
}
else
{
return
ExternalIntentDuringPrivateBrowsingPromptFragment
.
showDialogOrAndroidChooser
(
context
activity
.
getSupportFragmentManager
(
)
intent
)
;
}
}
public
static
boolean
hasHandlersForIntent
(
Intent
intent
)
{
try
{
return
!
GeckoAppShell
.
queryIntentActivities
(
intent
)
.
isEmpty
(
)
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
in
hasHandlersForIntent
"
)
;
return
false
;
}
}
public
static
String
[
]
getHandlersForIntent
(
Intent
intent
)
{
final
PackageManager
pm
=
GeckoAppShell
.
getApplicationContext
(
)
.
getPackageManager
(
)
;
try
{
final
List
<
ResolveInfo
>
list
=
GeckoAppShell
.
queryIntentActivities
(
intent
)
;
int
numAttr
=
4
;
final
String
[
]
ret
=
new
String
[
list
.
size
(
)
*
numAttr
]
;
for
(
int
i
=
0
;
i
<
list
.
size
(
)
;
i
+
+
)
{
ResolveInfo
resolveInfo
=
list
.
get
(
i
)
;
ret
[
i
*
numAttr
]
=
resolveInfo
.
loadLabel
(
pm
)
.
toString
(
)
;
if
(
resolveInfo
.
isDefault
)
ret
[
i
*
numAttr
+
1
]
=
"
default
"
;
else
ret
[
i
*
numAttr
+
1
]
=
"
"
;
ret
[
i
*
numAttr
+
2
]
=
resolveInfo
.
activityInfo
.
applicationInfo
.
packageName
;
ret
[
i
*
numAttr
+
3
]
=
resolveInfo
.
activityInfo
.
name
;
}
return
ret
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
in
getHandlersForIntent
"
)
;
return
new
String
[
0
]
;
}
}
public
static
Intent
getIntentForActionString
(
String
aAction
)
{
if
(
TextUtils
.
isEmpty
(
aAction
)
)
{
return
new
Intent
(
Intent
.
ACTION_VIEW
)
;
}
return
new
Intent
(
aAction
)
;
}
public
static
Intent
getShareIntent
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
title
)
{
Intent
shareIntent
=
getIntentForActionString
(
Intent
.
ACTION_SEND
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TEXT
targetURI
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_SUBJECT
title
)
;
shareIntent
.
putExtra
(
ShareDialog
.
INTENT_EXTRA_DEVICES_ONLY
true
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TITLE
title
)
;
if
(
mimeType
!
=
null
&
&
mimeType
.
length
(
)
>
0
)
{
shareIntent
.
setType
(
mimeType
)
;
}
return
shareIntent
;
}
public
static
Intent
getTabSwitchIntent
(
final
Tab
tab
)
{
final
Intent
intent
=
new
Intent
(
GeckoApp
.
ACTION_SWITCH_TAB
)
;
intent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
intent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
intent
.
putExtra
(
BrowserContract
.
SKIP_TAB_QUEUE_FLAG
true
)
;
intent
.
putExtra
(
INTENT_EXTRA_TAB_ID
tab
.
getId
(
)
)
;
intent
.
putExtra
(
INTENT_EXTRA_SESSION_UUID
GeckoApplication
.
getSessionUUID
(
)
)
;
return
intent
;
}
static
Intent
getOpenURIIntent
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
action
final
String
title
)
{
final
Intent
intent
=
getOpenURIIntentInner
(
context
targetURI
mimeType
action
title
)
;
if
(
intent
!
=
null
)
{
intent
.
putExtra
(
Browser
.
EXTRA_APPLICATION_ID
AppConstants
.
ANDROID_PACKAGE_NAME
)
;
}
return
intent
;
}
private
static
Intent
getOpenURIIntentInner
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
action
final
String
title
)
{
if
(
action
.
equalsIgnoreCase
(
Intent
.
ACTION_SEND
)
)
{
Intent
shareIntent
=
getShareIntent
(
context
targetURI
mimeType
title
)
;
return
Intent
.
createChooser
(
shareIntent
context
.
getResources
(
)
.
getString
(
R
.
string
.
share_title
)
)
;
}
Uri
uri
=
normalizeUriScheme
(
targetURI
.
indexOf
(
'
:
'
)
>
=
0
?
Uri
.
parse
(
targetURI
)
:
new
Uri
.
Builder
(
)
.
scheme
(
targetURI
)
.
build
(
)
)
;
if
(
!
TextUtils
.
isEmpty
(
mimeType
)
)
{
Intent
intent
=
getIntentForActionString
(
action
)
;
intent
.
setDataAndType
(
uri
mimeType
)
;
return
intent
;
}
if
(
!
GeckoAppShell
.
isUriSafeForScheme
(
uri
)
)
{
return
null
;
}
final
String
scheme
=
uri
.
getScheme
(
)
;
if
(
"
intent
"
.
equals
(
scheme
)
|
|
"
android
-
app
"
.
equals
(
scheme
)
)
{
final
Intent
intent
;
try
{
intent
=
Intent
.
parseUri
(
targetURI
0
)
;
}
catch
(
final
URISyntaxException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
parse
URI
-
"
+
e
)
;
return
null
;
}
final
Uri
data
=
intent
.
getData
(
)
;
if
(
data
!
=
null
&
&
"
file
"
.
equals
(
normalizeUriScheme
(
data
)
.
getScheme
(
)
)
)
{
Log
.
w
(
LOGTAG
"
Blocked
intent
with
\
"
file
:
/
/
\
"
data
scheme
.
"
)
;
return
null
;
}
intent
.
addCategory
(
Intent
.
CATEGORY_BROWSABLE
)
;
intent
.
setComponent
(
null
)
;
nullIntentSelector
(
intent
)
;
return
intent
;
}
final
String
extension
=
MimeTypeMap
.
getFileExtensionFromUrl
(
targetURI
)
;
final
Intent
intent
=
getIntentForActionString
(
action
)
;
intent
.
setData
(
uri
)
;
if
(
"
file
"
.
equals
(
scheme
)
)
{
final
String
mimeType2
=
GeckoAppShell
.
getMimeTypeFromExtension
(
extension
)
;
intent
.
setType
(
mimeType2
)
;
return
intent
;
}
if
(
!
"
sms
"
.
equals
(
scheme
)
&
&
!
"
smsto
"
.
equals
(
scheme
)
&
&
!
"
mms
"
.
equals
(
scheme
)
&
&
!
"
mmsto
"
.
equals
(
scheme
)
)
{
return
intent
;
}
final
String
query
=
uri
.
getEncodedQuery
(
)
;
if
(
TextUtils
.
isEmpty
(
query
)
)
{
return
intent
;
}
String
currentUri
=
uri
.
toString
(
)
;
String
correctlyFormattedDataURIScheme
=
scheme
+
"
:
/
/
"
;
if
(
!
currentUri
.
contains
(
correctlyFormattedDataURIScheme
)
)
{
uri
=
Uri
.
parse
(
currentUri
.
replaceFirst
(
scheme
+
"
:
"
correctlyFormattedDataURIScheme
)
)
;
}
final
String
[
]
fields
=
query
.
split
(
"
&
"
)
;
boolean
shouldUpdateIntent
=
false
;
String
resultQuery
=
"
"
;
for
(
String
field
:
fields
)
{
if
(
field
.
startsWith
(
"
body
=
"
)
)
{
final
String
body
=
Uri
.
decode
(
field
.
substring
(
5
)
)
;
intent
.
putExtra
(
"
sms_body
"
body
)
;
shouldUpdateIntent
=
true
;
}
else
if
(
field
.
startsWith
(
"
subject
=
"
)
)
{
final
String
subject
=
Uri
.
decode
(
field
.
substring
(
8
)
)
;
intent
.
putExtra
(
"
subject
"
subject
)
;
shouldUpdateIntent
=
true
;
}
else
if
(
field
.
startsWith
(
"
cc
=
"
)
)
{
final
String
ccNumber
=
Uri
.
decode
(
field
.
substring
(
3
)
)
;
String
phoneNumber
=
uri
.
getAuthority
(
)
;
if
(
phoneNumber
!
=
null
)
{
uri
=
uri
.
buildUpon
(
)
.
encodedAuthority
(
phoneNumber
+
"
;
"
+
ccNumber
)
.
build
(
)
;
}
shouldUpdateIntent
=
true
;
}
else
{
resultQuery
=
resultQuery
.
concat
(
resultQuery
.
length
(
)
>
0
?
"
&
"
+
field
:
field
)
;
}
}
if
(
!
shouldUpdateIntent
)
{
return
intent
;
}
final
String
newQuery
=
resultQuery
.
length
(
)
>
0
?
"
?
"
+
resultQuery
:
"
"
;
final
Uri
pruned
=
uri
.
buildUpon
(
)
.
encodedQuery
(
newQuery
)
.
build
(
)
;
intent
.
setData
(
pruned
)
;
return
intent
;
}
TargetApi
(
15
)
private
static
void
nullIntentSelector
(
final
Intent
intent
)
{
intent
.
setSelector
(
null
)
;
}
private
static
Uri
normalizeUriScheme
(
final
Uri
u
)
{
final
String
scheme
=
u
.
getScheme
(
)
;
final
String
lower
=
scheme
.
toLowerCase
(
Locale
.
US
)
;
if
(
lower
.
equals
(
scheme
)
)
{
return
u
;
}
return
u
.
buildUpon
(
)
.
scheme
(
lower
)
.
build
(
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
Intent
:
OpenNoHandler
"
.
equals
(
event
)
)
{
openNoHandler
(
message
callback
)
;
}
else
if
(
"
Intent
:
GetHandlers
"
.
equals
(
event
)
)
{
getHandlers
(
message
callback
)
;
}
else
if
(
"
Intent
:
Open
"
.
equals
(
event
)
)
{
open
(
message
)
;
}
else
if
(
"
Intent
:
OpenForResult
"
.
equals
(
event
)
)
{
openForResult
(
message
callback
)
;
}
}
private
void
getHandlers
(
final
GeckoBundle
message
final
EventCallback
callback
)
{
final
Intent
intent
=
getOpenURIIntent
(
getContext
(
)
message
.
getString
(
"
url
"
"
"
)
message
.
getString
(
"
mime
"
"
"
)
message
.
getString
(
"
action
"
"
"
)
message
.
getString
(
"
title
"
"
"
)
)
;
callback
.
sendSuccess
(
getHandlersForIntent
(
intent
)
)
;
}
private
void
open
(
final
GeckoBundle
message
)
{
openUriExternal
(
message
.
getString
(
"
url
"
"
"
)
message
.
getString
(
"
mime
"
"
"
)
message
.
getString
(
"
packageName
"
"
"
)
message
.
getString
(
"
className
"
"
"
)
message
.
getString
(
"
action
"
"
"
)
message
.
getString
(
"
title
"
"
"
)
false
)
;
}
private
void
openForResult
(
final
GeckoBundle
message
final
EventCallback
callback
)
{
Intent
intent
=
getOpenURIIntent
(
getContext
(
)
message
.
getString
(
"
url
"
"
"
)
message
.
getString
(
"
mime
"
"
"
)
message
.
getString
(
"
action
"
"
"
)
message
.
getString
(
"
title
"
"
"
)
)
;
intent
.
setClassName
(
message
.
getString
(
"
packageName
"
"
"
)
message
.
getString
(
"
className
"
"
"
)
)
;
intent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_CLEAR_TOP
)
;
final
FragmentActivity
activity
=
getActivity
(
)
;
if
(
activity
=
=
null
)
{
callback
.
sendError
(
null
)
;
return
;
}
final
ResultHandler
handler
=
new
ResultHandler
(
callback
)
;
try
{
ActivityHandlerHelper
.
startIntentForActivity
(
activity
intent
handler
)
;
}
catch
(
SecurityException
e
)
{
Log
.
w
(
LOGTAG
"
Forbidden
to
launch
activity
.
"
e
)
;
}
}
private
void
openNoHandler
(
final
GeckoBundle
msg
final
EventCallback
callback
)
{
final
String
uri
=
msg
.
getString
(
"
uri
"
)
;
final
GeckoBundle
errorResponse
=
new
GeckoBundle
(
)
;
if
(
TextUtils
.
isEmpty
(
uri
)
)
{
Log
.
w
(
LOGTAG
"
Received
empty
URL
-
loading
about
:
neterror
"
)
;
errorResponse
.
putString
(
"
uri
"
getUnknownProtocolErrorPageUri
(
"
"
)
)
;
errorResponse
.
putBoolean
(
"
isFallback
"
false
)
;
callback
.
sendError
(
errorResponse
)
;
return
;
}
final
Intent
intent
;
try
{
intent
=
Intent
.
parseUri
(
uri
0
)
;
}
catch
(
final
URISyntaxException
e
)
{
String
errorUri
;
try
{
errorUri
=
getUnknownProtocolErrorPageUri
(
URLEncoder
.
encode
(
uri
"
UTF
-
8
"
)
)
;
}
catch
(
final
UnsupportedEncodingException
encodingE
)
{
errorUri
=
getUnknownProtocolErrorPageUri
(
"
"
)
;
}
Log
.
w
(
LOGTAG
"
Unable
to
parse
Intent
URI
-
loading
about
:
neterror
"
)
;
errorResponse
.
putString
(
"
uri
"
errorUri
)
;
errorResponse
.
putBoolean
(
"
isFallback
"
false
)
;
callback
.
sendError
(
errorResponse
)
;
return
;
}
final
String
fallbackUrl
=
intent
.
getStringExtra
(
EXTRA_BROWSER_FALLBACK_URL
)
;
if
(
isFallbackUrlValid
(
fallbackUrl
)
)
{
errorResponse
.
putString
(
"
uri
"
fallbackUrl
)
;
errorResponse
.
putBoolean
(
"
isFallback
"
true
)
;
callback
.
sendError
(
errorResponse
)
;
}
else
if
(
intent
.
getPackage
(
)
!
=
null
)
{
final
String
marketUri
=
MARKET_INTENT_URI_PACKAGE_PREFIX
+
intent
.
getPackage
(
)
;
final
Intent
marketIntent
=
new
Intent
(
Intent
.
ACTION_VIEW
Uri
.
parse
(
marketUri
)
)
;
marketIntent
.
addCategory
(
Intent
.
CATEGORY_BROWSABLE
)
;
marketIntent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
final
FragmentActivity
activity
=
getActivity
(
)
;
if
(
activity
=
=
null
)
{
callback
.
sendError
(
null
)
;
return
;
}
ExternalIntentDuringPrivateBrowsingPromptFragment
.
showDialogOrAndroidChooser
(
activity
activity
.
getSupportFragmentManager
(
)
marketIntent
)
;
callback
.
sendSuccess
(
null
)
;
}
else
{
Log
.
w
(
LOGTAG
"
Unable
to
open
URI
maybe
showing
neterror
"
)
;
errorResponse
.
putString
(
"
uri
"
getUnknownProtocolErrorPageUri
(
intent
.
getData
(
)
.
toString
(
)
)
)
;
errorResponse
.
putBoolean
(
"
isFallback
"
false
)
;
callback
.
sendError
(
errorResponse
)
;
}
}
private
static
boolean
isFallbackUrlValid
(
Nullable
final
String
fallbackUrl
)
{
if
(
fallbackUrl
=
=
null
)
{
return
false
;
}
try
{
final
String
anyCaseScheme
=
new
URI
(
fallbackUrl
)
.
getScheme
(
)
;
final
String
scheme
=
(
anyCaseScheme
=
=
null
)
?
null
:
anyCaseScheme
.
toLowerCase
(
Locale
.
US
)
;
if
(
"
http
"
.
equals
(
scheme
)
|
|
"
https
"
.
equals
(
scheme
)
)
{
return
true
;
}
else
{
Log
.
w
(
LOGTAG
"
Fallback
URI
uses
unsupported
scheme
:
"
+
scheme
+
"
.
Try
http
or
https
.
"
)
;
}
}
catch
(
final
URISyntaxException
e
)
{
Log
.
w
(
LOGTAG
"
URISyntaxException
parsing
fallback
URI
"
)
;
}
return
false
;
}
private
String
getUnknownProtocolErrorPageUri
(
final
String
encodedUri
)
{
return
UNKNOWN_PROTOCOL_URI_PREFIX
+
encodedUri
;
}
private
static
class
ResultHandler
implements
ActivityResultHandler
{
private
final
EventCallback
callback
;
public
ResultHandler
(
final
EventCallback
callback
)
{
this
.
callback
=
callback
;
}
Override
public
void
onActivityResult
(
int
resultCode
Intent
data
)
{
final
GeckoBundle
response
=
new
GeckoBundle
(
3
)
;
if
(
data
!
=
null
)
{
if
(
data
.
getExtras
(
)
!
=
null
)
{
response
.
putBundle
(
"
extras
"
GeckoBundle
.
fromBundle
(
data
.
getExtras
(
)
)
)
;
}
if
(
data
.
getData
(
)
!
=
null
)
{
response
.
putString
(
"
uri
"
data
.
getData
(
)
.
toString
(
)
)
;
}
}
response
.
putInt
(
"
resultCode
"
resultCode
)
;
callback
.
sendSuccess
(
response
)
;
}
}
}
