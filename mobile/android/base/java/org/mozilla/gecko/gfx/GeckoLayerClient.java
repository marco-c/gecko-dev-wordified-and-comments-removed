package
org
.
mozilla
.
gecko
.
gfx
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoEvent
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
.
DrawListener
;
import
org
.
mozilla
.
gecko
.
Tab
;
import
org
.
mozilla
.
gecko
.
Tabs
;
import
org
.
mozilla
.
gecko
.
ZoomConstraints
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
util
.
FloatUtils
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
PointF
;
import
android
.
graphics
.
RectF
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONObject
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
class
GeckoLayerClient
implements
LayerView
.
Listener
PanZoomTarget
{
private
static
final
String
LOGTAG
=
"
GeckoLayerClient
"
;
private
static
int
sPaintSyncId
=
1
;
private
LayerRenderer
mLayerRenderer
;
private
boolean
mLayerRendererInitialized
;
private
final
Context
mContext
;
private
IntSize
mScreenSize
;
private
IntSize
mWindowSize
;
private
DisplayPortMetrics
mDisplayPort
;
private
boolean
mRecordDrawTimes
;
private
final
DrawTimingQueue
mDrawTimingQueue
;
private
VirtualLayer
mRootLayer
;
private
ImmutableViewportMetrics
mGeckoViewport
;
private
ImmutableViewportMetrics
mFrameMetrics
;
private
final
List
<
DrawListener
>
mDrawListeners
;
private
final
ViewTransform
mCurrentViewTransform
;
private
final
ProgressiveUpdateData
mProgressiveUpdateData
;
private
DisplayPortMetrics
mProgressiveUpdateDisplayPort
;
private
boolean
mLastProgressiveUpdateWasLowPrecision
;
private
boolean
mProgressiveUpdateWasInDanger
;
private
boolean
mForceRedraw
;
private
volatile
ImmutableViewportMetrics
mViewportMetrics
;
private
ZoomConstraints
mZoomConstraints
;
private
volatile
boolean
mGeckoIsReady
;
private
final
PanZoomController
mPanZoomController
;
private
final
DynamicToolbarAnimator
mToolbarAnimator
;
private
final
LayerView
mView
;
private
volatile
boolean
mContentDocumentIsDisplayed
;
public
GeckoLayerClient
(
Context
context
LayerView
view
EventDispatcher
eventDispatcher
)
{
mContext
=
context
;
mScreenSize
=
new
IntSize
(
0
0
)
;
mWindowSize
=
new
IntSize
(
0
0
)
;
mDisplayPort
=
new
DisplayPortMetrics
(
)
;
mRecordDrawTimes
=
true
;
mDrawTimingQueue
=
new
DrawTimingQueue
(
)
;
mCurrentViewTransform
=
new
ViewTransform
(
0
0
1
)
;
mProgressiveUpdateData
=
new
ProgressiveUpdateData
(
)
;
mProgressiveUpdateDisplayPort
=
new
DisplayPortMetrics
(
)
;
mForceRedraw
=
true
;
DisplayMetrics
displayMetrics
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
;
mViewportMetrics
=
new
ImmutableViewportMetrics
(
displayMetrics
)
.
setViewportSize
(
view
.
getWidth
(
)
view
.
getHeight
(
)
)
;
mZoomConstraints
=
new
ZoomConstraints
(
false
)
;
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
mZoomConstraints
=
tab
.
getZoomConstraints
(
)
;
mViewportMetrics
=
mViewportMetrics
.
setIsRTL
(
tab
.
getIsRTL
(
)
)
;
}
mFrameMetrics
=
mViewportMetrics
;
mDrawListeners
=
new
ArrayList
<
DrawListener
>
(
)
;
mToolbarAnimator
=
new
DynamicToolbarAnimator
(
this
)
;
mPanZoomController
=
PanZoomController
.
Factory
.
create
(
this
view
eventDispatcher
)
;
mView
=
view
;
mView
.
setListener
(
this
)
;
mContentDocumentIsDisplayed
=
true
;
}
public
void
setOverscrollHandler
(
final
Overscroll
listener
)
{
mPanZoomController
.
setOverscrollHandler
(
listener
)
;
}
boolean
isGeckoReady
(
)
{
return
mGeckoIsReady
;
}
WrapForJNI
private
void
onGeckoReady
(
)
{
mGeckoIsReady
=
true
;
mRootLayer
=
new
VirtualLayer
(
new
IntSize
(
mView
.
getWidth
(
)
mView
.
getHeight
(
)
)
)
;
mLayerRenderer
=
mView
.
getRenderer
(
)
;
sendResizeEventIfNecessary
(
true
null
)
;
DisplayPortCalculator
.
initPrefs
(
)
;
mView
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mView
.
getGLController
(
)
.
updateCompositor
(
)
;
}
}
)
;
}
public
void
destroy
(
)
{
mPanZoomController
.
destroy
(
)
;
mToolbarAnimator
.
destroy
(
)
;
mDrawListeners
.
clear
(
)
;
}
private
boolean
getRedrawHint
(
)
{
if
(
mForceRedraw
)
{
mForceRedraw
=
false
;
return
true
;
}
if
(
!
mPanZoomController
.
getRedrawHint
(
)
)
{
return
false
;
}
return
DisplayPortCalculator
.
aboutToCheckerboard
(
mViewportMetrics
mPanZoomController
.
getVelocityVector
(
)
mDisplayPort
)
;
}
Layer
getRoot
(
)
{
return
mGeckoIsReady
?
mRootLayer
:
null
;
}
public
LayerView
getView
(
)
{
return
mView
;
}
public
FloatSize
getViewportSize
(
)
{
return
mViewportMetrics
.
getSize
(
)
;
}
boolean
setViewportSize
(
int
width
int
height
PointF
scrollChange
)
{
if
(
mViewportMetrics
.
viewportRectWidth
=
=
width
&
&
mViewportMetrics
.
viewportRectHeight
=
=
height
&
&
(
scrollChange
=
=
null
|
|
(
scrollChange
.
x
=
=
0
&
&
scrollChange
.
y
=
=
0
)
)
)
{
return
false
;
}
mViewportMetrics
=
mViewportMetrics
.
setViewportSize
(
width
height
)
;
if
(
scrollChange
!
=
null
)
{
mViewportMetrics
=
mViewportMetrics
.
offsetViewportByAndClamp
(
scrollChange
.
x
scrollChange
.
y
)
;
}
if
(
mGeckoIsReady
)
{
sendResizeEventIfNecessary
(
true
scrollChange
)
;
GeckoAppShell
.
viewSizeChanged
(
)
;
}
return
true
;
}
PanZoomController
getPanZoomController
(
)
{
return
mPanZoomController
;
}
DynamicToolbarAnimator
getDynamicToolbarAnimator
(
)
{
return
mToolbarAnimator
;
}
private
void
sendResizeEventIfNecessary
(
boolean
force
PointF
scrollChange
)
{
DisplayMetrics
metrics
=
mContext
.
getResources
(
)
.
getDisplayMetrics
(
)
;
IntSize
newScreenSize
=
new
IntSize
(
metrics
.
widthPixels
metrics
.
heightPixels
)
;
IntSize
newWindowSize
=
new
IntSize
(
mViewportMetrics
.
viewportRectWidth
mViewportMetrics
.
viewportRectHeight
)
;
boolean
screenSizeChanged
=
!
mScreenSize
.
equals
(
newScreenSize
)
;
boolean
windowSizeChanged
=
!
mWindowSize
.
equals
(
newWindowSize
)
;
if
(
!
force
&
&
!
screenSizeChanged
&
&
!
windowSizeChanged
)
{
return
;
}
mScreenSize
=
newScreenSize
;
mWindowSize
=
newWindowSize
;
if
(
screenSizeChanged
)
{
Log
.
d
(
LOGTAG
"
Screen
-
size
changed
to
"
+
mScreenSize
)
;
}
if
(
windowSizeChanged
)
{
Log
.
d
(
LOGTAG
"
Window
-
size
changed
to
"
+
mWindowSize
)
;
}
GeckoEvent
event
=
GeckoEvent
.
createSizeChangedEvent
(
mWindowSize
.
width
mWindowSize
.
height
mScreenSize
.
width
mScreenSize
.
height
)
;
GeckoAppShell
.
sendEventToGecko
(
event
)
;
String
json
=
"
"
;
try
{
if
(
scrollChange
!
=
null
)
{
int
id
=
+
+
sPaintSyncId
;
if
(
id
=
=
0
)
{
id
=
+
+
sPaintSyncId
;
}
JSONObject
jsonObj
=
new
JSONObject
(
)
;
jsonObj
.
put
(
"
x
"
scrollChange
.
x
/
mViewportMetrics
.
zoomFactor
)
;
jsonObj
.
put
(
"
y
"
scrollChange
.
y
/
mViewportMetrics
.
zoomFactor
)
;
jsonObj
.
put
(
"
id
"
id
)
;
json
=
jsonObj
.
toString
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
convert
point
to
JSON
for
"
+
event
e
)
;
}
GeckoAppShell
.
sendEventToGecko
(
GeckoEvent
.
createBroadcastEvent
(
"
Window
:
Resize
"
json
)
)
;
}
private
void
setPageRect
(
RectF
rect
RectF
cssRect
)
{
if
(
mViewportMetrics
.
getCssPageRect
(
)
.
equals
(
cssRect
)
)
return
;
mViewportMetrics
=
mViewportMetrics
.
setPageRect
(
rect
cssRect
)
;
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mPanZoomController
.
pageRectUpdated
(
)
;
mView
.
requestRender
(
)
;
}
}
)
;
}
private
void
adjustViewport
(
DisplayPortMetrics
displayPort
)
{
if
(
AppConstants
.
MOZ_ANDROID_APZ
)
return
;
ImmutableViewportMetrics
metrics
=
getViewportMetrics
(
)
;
ImmutableViewportMetrics
clampedMetrics
=
metrics
.
clamp
(
)
;
if
(
displayPort
=
=
null
)
{
displayPort
=
DisplayPortCalculator
.
calculate
(
metrics
mPanZoomController
.
getVelocityVector
(
)
)
;
}
mDisplayPort
=
displayPort
;
mGeckoViewport
=
clampedMetrics
;
if
(
mRecordDrawTimes
)
{
mDrawTimingQueue
.
add
(
displayPort
)
;
}
GeckoAppShell
.
sendEventToGecko
(
GeckoEvent
.
createViewportEvent
(
clampedMetrics
displayPort
)
)
;
}
private
void
abortPanZoomAnimation
(
)
{
if
(
mPanZoomController
!
=
null
)
{
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mPanZoomController
.
abortAnimation
(
)
;
}
}
)
;
}
}
private
enum
ViewportMessageType
{
UPDATE
PAGE_SIZE
}
private
DisplayPortMetrics
handleViewportMessage
(
ImmutableViewportMetrics
messageMetrics
ViewportMessageType
type
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
newMetrics
;
ImmutableViewportMetrics
oldMetrics
=
getViewportMetrics
(
)
;
switch
(
type
)
{
default
:
case
UPDATE
:
newMetrics
=
messageMetrics
.
setViewportSize
(
oldMetrics
.
viewportRectWidth
oldMetrics
.
viewportRectHeight
)
;
if
(
mToolbarAnimator
.
isResizing
(
)
)
{
newMetrics
=
newMetrics
.
setViewportOrigin
(
oldMetrics
.
viewportRectLeft
oldMetrics
.
viewportRectTop
)
;
break
;
}
if
(
!
oldMetrics
.
fuzzyEquals
(
newMetrics
)
)
{
abortPanZoomAnimation
(
)
;
}
break
;
case
PAGE_SIZE
:
float
scaleFactor
=
oldMetrics
.
zoomFactor
/
messageMetrics
.
zoomFactor
;
newMetrics
=
oldMetrics
.
setPageRect
(
RectUtils
.
scale
(
messageMetrics
.
getPageRect
(
)
scaleFactor
)
messageMetrics
.
getCssPageRect
(
)
)
;
break
;
}
final
ImmutableViewportMetrics
geckoMetrics
=
newMetrics
.
clamp
(
)
;
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mGeckoViewport
=
geckoMetrics
;
}
}
)
;
setViewportMetrics
(
newMetrics
type
=
=
ViewportMessageType
.
UPDATE
)
;
mDisplayPort
=
DisplayPortCalculator
.
calculate
(
getViewportMetrics
(
)
null
)
;
}
return
mDisplayPort
;
}
WrapForJNI
DisplayPortMetrics
getDisplayPort
(
boolean
pageSizeUpdate
boolean
isBrowserContentDisplayed
int
tabId
ImmutableViewportMetrics
metrics
)
{
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
if
(
isBrowserContentDisplayed
&
&
tabs
.
isSelectedTabId
(
tabId
)
)
{
return
handleViewportMessage
(
metrics
pageSizeUpdate
?
ViewportMessageType
.
PAGE_SIZE
:
ViewportMessageType
.
UPDATE
)
;
}
else
{
return
DisplayPortCalculator
.
calculate
(
metrics
null
)
;
}
}
WrapForJNI
void
contentDocumentChanged
(
)
{
mContentDocumentIsDisplayed
=
false
;
}
WrapForJNI
boolean
isContentDocumentDisplayed
(
)
{
return
mContentDocumentIsDisplayed
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
ProgressiveUpdateData
progressiveUpdateCallback
(
boolean
aHasPendingNewThebesContent
float
x
float
y
float
width
float
height
float
resolution
boolean
lowPrecision
)
{
if
(
lowPrecision
&
&
!
mLastProgressiveUpdateWasLowPrecision
)
{
if
(
!
mProgressiveUpdateWasInDanger
)
{
mProgressiveUpdateData
.
abort
=
true
;
return
mProgressiveUpdateData
;
}
mProgressiveUpdateWasInDanger
=
false
;
}
mLastProgressiveUpdateWasLowPrecision
=
lowPrecision
;
DisplayPortMetrics
displayPort
=
mDisplayPort
;
ImmutableViewportMetrics
viewportMetrics
=
mViewportMetrics
;
mProgressiveUpdateData
.
setViewport
(
viewportMetrics
)
;
mProgressiveUpdateData
.
abort
=
false
;
if
(
!
FloatUtils
.
fuzzyEquals
(
resolution
viewportMetrics
.
zoomFactor
)
)
{
Log
.
d
(
LOGTAG
"
Aborting
draw
due
to
resolution
change
:
"
+
resolution
+
"
!
=
"
+
viewportMetrics
.
zoomFactor
)
;
mProgressiveUpdateData
.
abort
=
true
;
return
mProgressiveUpdateData
;
}
if
(
!
lowPrecision
)
{
if
(
!
FloatUtils
.
fuzzyEquals
(
resolution
mProgressiveUpdateDisplayPort
.
resolution
)
|
|
!
FloatUtils
.
fuzzyEquals
(
x
mProgressiveUpdateDisplayPort
.
getLeft
(
)
)
|
|
!
FloatUtils
.
fuzzyEquals
(
y
mProgressiveUpdateDisplayPort
.
getTop
(
)
)
|
|
!
FloatUtils
.
fuzzyEquals
(
x
+
width
mProgressiveUpdateDisplayPort
.
getRight
(
)
)
|
|
!
FloatUtils
.
fuzzyEquals
(
y
+
height
mProgressiveUpdateDisplayPort
.
getBottom
(
)
)
)
{
mProgressiveUpdateDisplayPort
=
new
DisplayPortMetrics
(
x
y
x
+
width
y
+
height
resolution
)
;
}
}
if
(
!
lowPrecision
&
&
!
mProgressiveUpdateWasInDanger
)
{
if
(
DisplayPortCalculator
.
aboutToCheckerboard
(
viewportMetrics
mPanZoomController
.
getVelocityVector
(
)
mProgressiveUpdateDisplayPort
)
)
{
mProgressiveUpdateWasInDanger
=
true
;
}
}
if
(
Math
.
abs
(
displayPort
.
getLeft
(
)
-
mProgressiveUpdateDisplayPort
.
getLeft
(
)
)
<
=
2
&
&
Math
.
abs
(
displayPort
.
getTop
(
)
-
mProgressiveUpdateDisplayPort
.
getTop
(
)
)
<
=
2
&
&
Math
.
abs
(
displayPort
.
getBottom
(
)
-
mProgressiveUpdateDisplayPort
.
getBottom
(
)
)
<
=
2
&
&
Math
.
abs
(
displayPort
.
getRight
(
)
-
mProgressiveUpdateDisplayPort
.
getRight
(
)
)
<
=
2
)
{
return
mProgressiveUpdateData
;
}
if
(
Math
.
max
(
viewportMetrics
.
viewportRectLeft
viewportMetrics
.
pageRectLeft
)
+
1
<
x
|
|
Math
.
max
(
viewportMetrics
.
viewportRectTop
viewportMetrics
.
pageRectTop
)
+
1
<
y
|
|
Math
.
min
(
viewportMetrics
.
viewportRectRight
(
)
viewportMetrics
.
pageRectRight
)
-
1
>
x
+
width
|
|
Math
.
min
(
viewportMetrics
.
viewportRectBottom
(
)
viewportMetrics
.
pageRectBottom
)
-
1
>
y
+
height
)
{
Log
.
d
(
LOGTAG
"
Aborting
update
due
to
viewport
not
in
display
-
port
"
)
;
mProgressiveUpdateData
.
abort
=
true
;
mProgressiveUpdateWasInDanger
=
true
;
return
mProgressiveUpdateData
;
}
if
(
lowPrecision
&
&
!
aHasPendingNewThebesContent
)
{
mProgressiveUpdateData
.
abort
=
true
;
}
return
mProgressiveUpdateData
;
}
void
setZoomConstraints
(
ZoomConstraints
constraints
)
{
mZoomConstraints
=
constraints
;
}
void
setIsRTL
(
boolean
aIsRTL
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
newMetrics
=
getViewportMetrics
(
)
.
setIsRTL
(
aIsRTL
)
;
setViewportMetrics
(
newMetrics
false
)
;
}
}
WrapForJNI
(
allowMultithread
=
true
)
public
void
setFirstPaintViewport
(
float
offsetX
float
offsetY
float
zoom
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
)
{
synchronized
(
getLock
(
)
)
{
ImmutableViewportMetrics
currentMetrics
=
getViewportMetrics
(
)
;
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
RectF
pageRect
=
RectUtils
.
scaleAndRound
(
cssPageRect
zoom
)
;
final
ImmutableViewportMetrics
newMetrics
=
currentMetrics
.
setViewportOrigin
(
offsetX
offsetY
)
.
setZoomFactor
(
zoom
)
.
setPageRect
(
pageRect
cssPageRect
)
.
setIsRTL
(
tab
!
=
null
?
tab
.
getIsRTL
(
)
:
false
)
;
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mGeckoViewport
=
newMetrics
;
}
}
)
;
setViewportMetrics
(
newMetrics
)
;
if
(
tab
!
=
null
)
{
mView
.
setBackgroundColor
(
tab
.
getBackgroundColor
(
)
)
;
setZoomConstraints
(
tab
.
getZoomConstraints
(
)
)
;
}
abortPanZoomAnimation
(
)
;
Log
.
i
(
"
GeckoBug1151102
"
"
Done
first
paint
;
state
"
+
mView
.
getPaintState
(
)
)
;
if
(
mView
.
getPaintState
(
)
=
=
LayerView
.
PAINT_START
)
{
mView
.
setPaintState
(
LayerView
.
PAINT_BEFORE_FIRST
)
;
}
}
DisplayPortCalculator
.
resetPageState
(
)
;
mDrawTimingQueue
.
reset
(
)
;
mContentDocumentIsDisplayed
=
true
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
void
setPageRect
(
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
)
{
synchronized
(
getLock
(
)
)
{
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
float
ourZoom
=
getViewportMetrics
(
)
.
zoomFactor
;
setPageRect
(
RectUtils
.
scale
(
cssPageRect
ourZoom
)
cssPageRect
)
;
}
}
WrapForJNI
(
allowMultithread
=
true
)
public
ViewTransform
syncViewportInfo
(
int
x
int
y
int
width
int
height
float
resolution
boolean
layersUpdated
int
paintSyncId
)
{
mFrameMetrics
=
getViewportMetrics
(
)
;
if
(
paintSyncId
=
=
sPaintSyncId
)
{
mToolbarAnimator
.
scrollChangeResizeCompleted
(
)
;
}
mToolbarAnimator
.
populateViewTransform
(
mCurrentViewTransform
mFrameMetrics
)
;
if
(
mRootLayer
!
=
null
)
{
mRootLayer
.
setPositionAndResolution
(
x
y
x
+
width
y
+
height
resolution
)
;
}
if
(
layersUpdated
&
&
mRecordDrawTimes
)
{
DisplayPortMetrics
drawn
=
new
DisplayPortMetrics
(
x
y
x
+
width
y
+
height
resolution
)
;
long
time
=
mDrawTimingQueue
.
findTimeFor
(
drawn
)
;
if
(
time
>
=
0
)
{
long
now
=
SystemClock
.
uptimeMillis
(
)
;
time
=
now
-
time
;
mRecordDrawTimes
=
DisplayPortCalculator
.
drawTimeUpdate
(
time
width
*
height
)
;
}
}
if
(
layersUpdated
)
{
for
(
DrawListener
listener
:
mDrawListeners
)
{
listener
.
drawFinished
(
)
;
}
}
return
mCurrentViewTransform
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
ViewTransform
syncFrameMetrics
(
float
scrollX
float
scrollY
float
zoom
float
cssPageLeft
float
cssPageTop
float
cssPageRight
float
cssPageBottom
int
dpX
int
dpY
int
dpWidth
int
dpHeight
float
paintedResolution
boolean
layersUpdated
int
paintSyncId
)
{
RectF
cssPageRect
=
new
RectF
(
cssPageLeft
cssPageTop
cssPageRight
cssPageBottom
)
;
synchronized
(
getLock
(
)
)
{
mViewportMetrics
=
mViewportMetrics
.
setViewportOrigin
(
scrollX
scrollY
)
.
setZoomFactor
(
zoom
)
.
setPageRect
(
RectUtils
.
scale
(
cssPageRect
zoom
)
cssPageRect
)
;
}
return
syncViewportInfo
(
dpX
dpY
dpWidth
dpHeight
paintedResolution
layersUpdated
paintSyncId
)
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
LayerRenderer
.
Frame
createFrame
(
)
{
if
(
!
mLayerRendererInitialized
)
{
if
(
mLayerRenderer
=
=
null
)
{
return
null
;
}
mLayerRenderer
.
checkMonitoringEnabled
(
)
;
mLayerRenderer
.
createDefaultProgram
(
)
;
mLayerRendererInitialized
=
true
;
}
try
{
return
mLayerRenderer
.
createFrame
(
mFrameMetrics
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
e
)
;
return
null
;
}
}
WrapForJNI
(
allowMultithread
=
true
)
public
void
activateProgram
(
)
{
mLayerRenderer
.
activateDefaultProgram
(
)
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
void
deactivateProgramAndRestoreState
(
boolean
enableScissor
int
scissorX
int
scissorY
int
scissorW
int
scissorH
)
{
mLayerRenderer
.
deactivateDefaultProgram
(
)
;
mLayerRenderer
.
restoreState
(
enableScissor
scissorX
scissorY
scissorW
scissorH
)
;
}
private
void
geometryChanged
(
DisplayPortMetrics
displayPort
)
{
sendResizeEventIfNecessary
(
false
null
)
;
if
(
getRedrawHint
(
)
)
{
adjustViewport
(
displayPort
)
;
}
}
Override
public
void
renderRequested
(
)
{
final
GLController
glController
=
mView
.
getGLController
(
)
;
if
(
glController
!
=
null
)
{
glController
.
invalidateAndScheduleComposite
(
)
;
}
}
Override
public
void
sizeChanged
(
int
width
int
height
)
{
mView
.
getGLController
(
)
.
resumeCompositor
(
width
height
)
;
}
Override
public
void
surfaceChanged
(
int
width
int
height
)
{
IntSize
viewportSize
=
mToolbarAnimator
.
getViewportSize
(
)
;
setViewportSize
(
viewportSize
.
width
viewportSize
.
height
null
)
;
}
Override
public
ImmutableViewportMetrics
getViewportMetrics
(
)
{
return
mViewportMetrics
;
}
Override
public
ZoomConstraints
getZoomConstraints
(
)
{
return
mZoomConstraints
;
}
Override
public
FullScreenState
getFullScreenState
(
)
{
return
mView
.
getFullScreenState
(
)
;
}
Override
public
PointF
getVisibleEndOfLayerView
(
)
{
return
mToolbarAnimator
.
getVisibleEndOfLayerView
(
)
;
}
Override
public
void
setAnimationTarget
(
ImmutableViewportMetrics
metrics
)
{
if
(
mGeckoIsReady
)
{
DisplayPortMetrics
displayPort
=
DisplayPortCalculator
.
calculate
(
metrics
null
)
;
adjustViewport
(
displayPort
)
;
}
}
Override
public
void
setViewportMetrics
(
ImmutableViewportMetrics
metrics
)
{
setViewportMetrics
(
metrics
true
)
;
}
private
void
setViewportMetrics
(
ImmutableViewportMetrics
metrics
boolean
notifyGecko
)
{
metrics
=
metrics
.
setViewportSize
(
mViewportMetrics
.
viewportRectWidth
mViewportMetrics
.
viewportRectHeight
)
;
mViewportMetrics
=
metrics
;
viewportMetricsChanged
(
notifyGecko
)
;
}
private
void
viewportMetricsChanged
(
boolean
notifyGecko
)
{
mToolbarAnimator
.
onMetricsChanged
(
mViewportMetrics
)
;
mView
.
requestRender
(
)
;
if
(
notifyGecko
&
&
mGeckoIsReady
)
{
geometryChanged
(
null
)
;
}
}
void
forceViewportMetrics
(
ImmutableViewportMetrics
metrics
boolean
notifyGecko
boolean
forceRedraw
)
{
if
(
forceRedraw
)
{
mForceRedraw
=
true
;
}
mViewportMetrics
=
metrics
;
viewportMetricsChanged
(
notifyGecko
)
;
}
Override
public
void
scrollBy
(
float
dx
float
dy
)
{
mViewportMetrics
=
mViewportMetrics
.
offsetViewportBy
(
dx
dy
)
;
viewportMetricsChanged
(
true
)
;
}
Override
public
void
panZoomStopped
(
)
{
mToolbarAnimator
.
onPanZoomStopped
(
)
;
}
Override
public
void
forceRedraw
(
DisplayPortMetrics
displayPort
)
{
mForceRedraw
=
true
;
if
(
mGeckoIsReady
)
{
geometryChanged
(
displayPort
)
;
}
}
Override
public
boolean
post
(
Runnable
action
)
{
return
mView
.
post
(
action
)
;
}
Override
public
void
postRenderTask
(
RenderTask
task
)
{
mView
.
postRenderTask
(
task
)
;
}
Override
public
void
removeRenderTask
(
RenderTask
task
)
{
mView
.
removeRenderTask
(
task
)
;
}
Override
public
Object
getLock
(
)
{
return
this
;
}
Override
public
PointF
convertViewPointToLayerPoint
(
PointF
viewPoint
)
{
if
(
!
mGeckoIsReady
)
{
return
null
;
}
ImmutableViewportMetrics
viewportMetrics
=
mViewportMetrics
;
PointF
origin
=
viewportMetrics
.
getOrigin
(
)
;
float
zoom
=
viewportMetrics
.
zoomFactor
;
ImmutableViewportMetrics
geckoViewport
=
(
AppConstants
.
MOZ_ANDROID_APZ
?
mViewportMetrics
:
mGeckoViewport
)
;
PointF
geckoOrigin
=
geckoViewport
.
getOrigin
(
)
;
float
geckoZoom
=
geckoViewport
.
zoomFactor
;
PointF
layerPoint
=
new
PointF
(
(
(
viewPoint
.
x
+
origin
.
x
)
/
zoom
)
-
(
geckoOrigin
.
x
/
geckoZoom
)
(
(
viewPoint
.
y
+
origin
.
y
)
/
zoom
)
-
(
geckoOrigin
.
y
/
geckoZoom
)
)
;
return
layerPoint
;
}
public
void
addDrawListener
(
DrawListener
listener
)
{
mDrawListeners
.
add
(
listener
)
;
}
public
void
removeDrawListener
(
DrawListener
listener
)
{
mDrawListeners
.
remove
(
listener
)
;
}
}
