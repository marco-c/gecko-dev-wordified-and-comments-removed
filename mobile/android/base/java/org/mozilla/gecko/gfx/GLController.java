package
org
.
mozilla
.
gecko
.
gfx
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
util
.
Log
;
import
javax
.
microedition
.
khronos
.
egl
.
EGL10
;
import
javax
.
microedition
.
khronos
.
egl
.
EGLConfig
;
import
javax
.
microedition
.
khronos
.
egl
.
EGLContext
;
import
javax
.
microedition
.
khronos
.
egl
.
EGLDisplay
;
import
javax
.
microedition
.
khronos
.
egl
.
EGLSurface
;
public
class
GLController
extends
JNIObject
{
private
static
final
int
EGL_CONTEXT_CLIENT_VERSION
=
0x3098
;
private
static
final
String
LOGTAG
=
"
GeckoGLController
"
;
LayerView
mView
;
private
boolean
mServerSurfaceValid
;
private
int
mWidth
mHeight
;
private
volatile
boolean
mCompositorCreated
;
private
static
EGL10
sEGL
;
private
static
EGLDisplay
sEGLDisplay
;
private
static
EGLConfig
sEGLConfig
;
private
EGLSurface
mEGLSurfaceForCompositor
;
private
static
final
int
LOCAL_EGL_OPENGL_ES2_BIT
=
4
;
private
static
final
int
[
]
CONFIG_SPEC_16BPP
=
{
EGL10
.
EGL_RED_SIZE
5
EGL10
.
EGL_GREEN_SIZE
6
EGL10
.
EGL_BLUE_SIZE
5
EGL10
.
EGL_SURFACE_TYPE
EGL10
.
EGL_WINDOW_BIT
EGL10
.
EGL_RENDERABLE_TYPE
LOCAL_EGL_OPENGL_ES2_BIT
EGL10
.
EGL_NONE
}
;
private
static
final
int
[
]
CONFIG_SPEC_24BPP
=
{
EGL10
.
EGL_RED_SIZE
8
EGL10
.
EGL_GREEN_SIZE
8
EGL10
.
EGL_BLUE_SIZE
8
EGL10
.
EGL_SURFACE_TYPE
EGL10
.
EGL_WINDOW_BIT
EGL10
.
EGL_RENDERABLE_TYPE
LOCAL_EGL_OPENGL_ES2_BIT
EGL10
.
EGL_NONE
}
;
WrapForJNI
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
native
void
attachToJava
(
GeckoLayerClient
layerClient
NativePanZoomController
npzc
)
;
WrapForJNI
private
native
void
createCompositor
(
int
width
int
height
)
;
WrapForJNI
private
native
void
pauseCompositor
(
)
;
WrapForJNI
private
native
void
syncResumeResizeCompositor
(
int
width
int
height
)
;
WrapForJNI
private
native
void
syncInvalidateAndScheduleComposite
(
)
;
public
GLController
(
)
{
}
synchronized
void
serverSurfaceDestroyed
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mServerSurfaceValid
=
false
;
if
(
mEGLSurfaceForCompositor
!
=
null
)
{
sEGL
.
eglDestroySurface
(
sEGLDisplay
mEGLSurfaceForCompositor
)
;
mEGLSurfaceForCompositor
=
null
;
}
if
(
mCompositorCreated
)
{
pauseCompositor
(
)
;
}
}
synchronized
void
serverSurfaceChanged
(
int
newWidth
int
newHeight
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mWidth
=
newWidth
;
mHeight
=
newHeight
;
mServerSurfaceValid
=
true
;
mView
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
updateCompositor
(
)
;
}
}
)
;
}
void
updateCompositor
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mCompositorCreated
)
{
resumeCompositor
(
mWidth
mHeight
)
;
return
;
}
if
(
!
AttemptPreallocateEGLSurfaceForCompositor
(
)
)
{
return
;
}
if
(
mView
.
getLayerClient
(
)
.
isGeckoReady
(
)
)
{
createCompositor
(
mWidth
mHeight
)
;
}
}
void
compositorCreated
(
)
{
mCompositorCreated
=
true
;
}
public
boolean
isServerSurfaceValid
(
)
{
return
mServerSurfaceValid
;
}
private
static
void
initEGL
(
)
{
if
(
sEGL
!
=
null
)
{
return
;
}
sEGL
=
(
EGL10
)
EGLContext
.
getEGL
(
)
;
sEGLDisplay
=
sEGL
.
eglGetDisplay
(
EGL10
.
EGL_DEFAULT_DISPLAY
)
;
if
(
sEGLDisplay
=
=
EGL10
.
EGL_NO_DISPLAY
)
{
Log
.
w
(
LOGTAG
"
can
'
t
get
EGL
display
!
"
)
;
return
;
}
int
[
]
returnedVersion
=
new
int
[
2
]
;
if
(
!
sEGL
.
eglInitialize
(
sEGLDisplay
returnedVersion
)
)
{
Log
.
w
(
LOGTAG
"
eglInitialize
failed
"
)
;
return
;
}
sEGLConfig
=
chooseConfig
(
)
;
}
private
static
EGLConfig
chooseConfig
(
)
{
int
[
]
desiredConfig
;
int
rSize
gSize
bSize
;
int
[
]
numConfigs
=
new
int
[
1
]
;
switch
(
GeckoAppShell
.
getScreenDepth
(
)
)
{
case
24
:
desiredConfig
=
CONFIG_SPEC_24BPP
;
rSize
=
gSize
=
bSize
=
8
;
break
;
case
16
:
default
:
desiredConfig
=
CONFIG_SPEC_16BPP
;
rSize
=
5
;
gSize
=
6
;
bSize
=
5
;
break
;
}
if
(
!
sEGL
.
eglChooseConfig
(
sEGLDisplay
desiredConfig
null
0
numConfigs
)
|
|
numConfigs
[
0
]
<
=
0
)
{
throw
new
GLControllerException
(
"
No
available
EGL
configurations
"
+
getEGLError
(
)
)
;
}
EGLConfig
[
]
configs
=
new
EGLConfig
[
numConfigs
[
0
]
]
;
if
(
!
sEGL
.
eglChooseConfig
(
sEGLDisplay
desiredConfig
configs
numConfigs
[
0
]
numConfigs
)
)
{
throw
new
GLControllerException
(
"
No
EGL
configuration
for
that
specification
"
+
getEGLError
(
)
)
;
}
int
[
]
red
=
new
int
[
1
]
green
=
new
int
[
1
]
blue
=
new
int
[
1
]
;
for
(
EGLConfig
config
:
configs
)
{
sEGL
.
eglGetConfigAttrib
(
sEGLDisplay
config
EGL10
.
EGL_RED_SIZE
red
)
;
sEGL
.
eglGetConfigAttrib
(
sEGLDisplay
config
EGL10
.
EGL_GREEN_SIZE
green
)
;
sEGL
.
eglGetConfigAttrib
(
sEGLDisplay
config
EGL10
.
EGL_BLUE_SIZE
blue
)
;
if
(
red
[
0
]
=
=
rSize
&
&
green
[
0
]
=
=
gSize
&
&
blue
[
0
]
=
=
bSize
)
{
return
config
;
}
}
throw
new
GLControllerException
(
"
No
suitable
EGL
configuration
found
"
)
;
}
private
synchronized
boolean
AttemptPreallocateEGLSurfaceForCompositor
(
)
{
if
(
mEGLSurfaceForCompositor
=
=
null
)
{
initEGL
(
)
;
try
{
mEGLSurfaceForCompositor
=
sEGL
.
eglCreateWindowSurface
(
sEGLDisplay
sEGLConfig
mView
.
getNativeWindow
(
)
null
)
;
if
(
mEGLSurfaceForCompositor
=
=
EGL10
.
EGL_NO_SURFACE
)
{
mEGLSurfaceForCompositor
=
null
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
eglCreateWindowSurface
threw
"
e
)
;
}
}
if
(
mEGLSurfaceForCompositor
=
=
null
)
{
Log
.
w
(
LOGTAG
"
eglCreateWindowSurface
returned
no
surface
!
"
)
;
}
return
mEGLSurfaceForCompositor
!
=
null
;
}
WrapForJNI
(
allowMultithread
=
true
)
private
synchronized
EGLSurface
createEGLSurface
(
)
{
compositorCreated
(
)
;
AttemptPreallocateEGLSurfaceForCompositor
(
)
;
EGLSurface
result
=
mEGLSurfaceForCompositor
;
mEGLSurfaceForCompositor
=
null
;
return
result
;
}
private
static
String
getEGLError
(
)
{
return
"
Error
"
+
(
sEGL
=
=
null
?
"
(
no
sEGL
)
"
:
sEGL
.
eglGetError
(
)
)
;
}
void
resumeCompositor
(
int
width
int
height
)
{
if
(
mCompositorCreated
)
{
syncResumeResizeCompositor
(
width
height
)
;
mView
.
requestRender
(
)
;
}
}
void
invalidateAndScheduleComposite
(
)
{
if
(
mCompositorCreated
)
{
syncInvalidateAndScheduleComposite
(
)
;
}
}
WrapForJNI
private
void
destroy
(
)
{
mCompositorCreated
=
false
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GLController
.
this
.
disposeNative
(
)
;
}
}
)
;
}
public
static
class
GLControllerException
extends
RuntimeException
{
public
static
final
long
serialVersionUID
=
1L
;
GLControllerException
(
String
e
)
{
super
(
e
)
;
}
}
}
