package
org
.
mozilla
.
gecko
.
gfx
;
import
android
.
content
.
Context
;
import
android
.
hardware
.
SensorManager
;
import
android
.
util
.
Log
;
import
android
.
view
.
ViewConfiguration
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
WrapForJNI
(
allowMultithread
=
true
catchException
=
true
)
public
class
StackScroller
{
private
int
mMode
;
private
final
SplineStackScroller
mScrollerX
;
private
final
SplineStackScroller
mScrollerY
;
private
final
boolean
mFlywheel
;
private
static
final
int
SCROLL_MODE
=
0
;
private
static
final
int
FLING_MODE
=
1
;
private
static
float
sViscousFluidScale
;
private
static
float
sViscousFluidNormalize
;
public
StackScroller
(
Context
context
)
{
mFlywheel
=
true
;
mScrollerX
=
new
SplineStackScroller
(
context
)
;
mScrollerY
=
new
SplineStackScroller
(
context
)
;
initContants
(
)
;
}
private
static
void
initContants
(
)
{
sViscousFluidScale
=
8
.
0f
;
sViscousFluidNormalize
=
1
.
0f
;
sViscousFluidNormalize
=
1
.
0f
/
viscousFluid
(
1
.
0f
)
;
}
public
final
boolean
isFinished
(
)
{
return
mScrollerX
.
mFinished
&
&
mScrollerY
.
mFinished
;
}
public
final
void
forceFinished
(
boolean
finished
)
{
mScrollerX
.
mFinished
=
mScrollerY
.
mFinished
=
finished
;
}
public
final
int
getCurrX
(
)
{
return
mScrollerX
.
mCurrentPosition
;
}
public
final
int
getCurrY
(
)
{
return
mScrollerY
.
mCurrentPosition
;
}
public
final
int
getFinalX
(
)
{
return
mScrollerX
.
mFinal
;
}
public
final
float
getCurrSpeedX
(
)
{
return
mScrollerX
.
mCurrVelocity
;
}
public
final
float
getCurrSpeedY
(
)
{
return
mScrollerY
.
mCurrVelocity
;
}
public
final
int
getFinalY
(
)
{
return
mScrollerY
.
mFinal
;
}
public
final
void
setFinalX
(
int
x
)
{
mScrollerX
.
setFinalPosition
(
x
)
;
}
private
static
float
viscousFluid
(
float
x
)
{
x
*
=
sViscousFluidScale
;
if
(
x
<
1
.
0f
)
{
x
-
=
(
1
.
0f
-
(
float
)
Math
.
exp
(
-
x
)
)
;
}
else
{
float
start
=
0
.
36787944117f
;
x
=
1
.
0f
-
(
float
)
Math
.
exp
(
1
.
0f
-
x
)
;
x
=
start
+
x
*
(
1
.
0f
-
start
)
;
}
x
*
=
sViscousFluidNormalize
;
return
x
;
}
public
boolean
computeScrollOffset
(
long
time
)
{
if
(
isFinished
(
)
)
{
return
false
;
}
switch
(
mMode
)
{
case
SCROLL_MODE
:
final
long
elapsedTime
=
time
-
mScrollerX
.
mStartTime
;
final
int
duration
=
mScrollerX
.
mDuration
;
if
(
elapsedTime
<
duration
)
{
float
q
=
(
float
)
(
elapsedTime
)
/
duration
;
q
=
viscousFluid
(
q
)
;
mScrollerX
.
updateScroll
(
q
)
;
mScrollerY
.
updateScroll
(
q
)
;
}
else
{
abortAnimation
(
)
;
}
break
;
case
FLING_MODE
:
if
(
!
mScrollerX
.
mFinished
)
{
if
(
!
mScrollerX
.
update
(
time
)
)
{
if
(
!
mScrollerX
.
continueWhenFinished
(
time
)
)
{
mScrollerX
.
finish
(
)
;
}
}
}
if
(
!
mScrollerY
.
mFinished
)
{
if
(
!
mScrollerY
.
update
(
time
)
)
{
if
(
!
mScrollerY
.
continueWhenFinished
(
time
)
)
{
mScrollerY
.
finish
(
)
;
}
}
}
break
;
default
:
break
;
}
return
true
;
}
public
void
startScroll
(
int
startX
int
startY
int
dx
int
dy
long
startTime
int
duration
)
{
mMode
=
SCROLL_MODE
;
mScrollerX
.
startScroll
(
startX
dx
startTime
duration
)
;
mScrollerY
.
startScroll
(
startY
dy
startTime
duration
)
;
}
public
boolean
springBack
(
int
startX
int
startY
int
minX
int
maxX
int
minY
int
maxY
long
time
)
{
mMode
=
FLING_MODE
;
final
boolean
spingbackX
=
mScrollerX
.
springback
(
startX
minX
maxX
time
)
;
final
boolean
spingbackY
=
mScrollerY
.
springback
(
startY
minY
maxY
time
)
;
return
spingbackX
|
|
spingbackY
;
}
public
void
fling
(
int
startX
int
startY
int
velocityX
int
velocityY
int
minX
int
maxX
int
minY
int
maxY
int
overX
int
overY
long
time
)
{
if
(
mFlywheel
&
&
!
isFinished
(
)
)
{
float
oldVelocityX
=
mScrollerX
.
mCurrVelocity
;
float
oldVelocityY
=
mScrollerY
.
mCurrVelocity
;
if
(
Math
.
signum
(
velocityX
)
=
=
Math
.
signum
(
oldVelocityX
)
&
&
Math
.
signum
(
velocityY
)
=
=
Math
.
signum
(
oldVelocityY
)
)
{
velocityX
+
=
oldVelocityX
;
velocityY
+
=
oldVelocityY
;
}
}
mMode
=
FLING_MODE
;
mScrollerX
.
fling
(
startX
velocityX
minX
maxX
overX
time
)
;
mScrollerY
.
fling
(
startY
velocityY
minY
maxY
overY
time
)
;
}
public
void
abortAnimation
(
)
{
mScrollerX
.
finish
(
)
;
mScrollerY
.
finish
(
)
;
}
static
class
SplineStackScroller
{
private
int
mStart
;
private
int
mCurrentPosition
;
private
int
mFinal
;
private
int
mVelocity
;
private
float
mCurrVelocity
;
private
float
mDeceleration
;
private
long
mStartTime
;
private
int
mDuration
;
private
int
mSplineDuration
;
private
int
mSplineDistance
;
private
boolean
mFinished
;
private
int
mOver
;
private
final
float
mFlingFriction
=
ViewConfiguration
.
getScrollFriction
(
)
;
private
int
mState
=
SPLINE
;
private
static
final
float
GRAVITY
=
2000
.
0f
;
private
final
float
mPhysicalCoeff
;
private
static
final
float
DECELERATION_RATE
=
(
float
)
(
Math
.
log
(
0
.
78
)
/
Math
.
log
(
0
.
9
)
)
;
private
static
final
float
INFLEXION
=
0
.
35f
;
private
static
final
float
START_TENSION
=
0
.
5f
;
private
static
final
float
END_TENSION
=
1
.
0f
;
private
static
final
float
P1
=
START_TENSION
*
INFLEXION
;
private
static
final
float
P2
=
1
.
0f
-
END_TENSION
*
(
1
.
0f
-
INFLEXION
)
;
private
static
final
int
NB_SAMPLES
=
100
;
private
static
final
float
[
]
SPLINE_POSITION
=
new
float
[
NB_SAMPLES
+
1
]
;
private
static
final
float
[
]
SPLINE_TIME
=
new
float
[
NB_SAMPLES
+
1
]
;
private
static
final
int
SPLINE
=
0
;
private
static
final
int
CUBIC
=
1
;
private
static
final
int
BALLISTIC
=
2
;
static
{
float
xMin
=
0
.
0f
;
float
yMin
=
0
.
0f
;
for
(
int
i
=
0
;
i
<
NB_SAMPLES
;
i
+
+
)
{
final
float
alpha
=
(
float
)
i
/
NB_SAMPLES
;
float
xMax
=
1
.
0f
;
float
x
tx
coef
;
while
(
true
)
{
x
=
xMin
+
(
xMax
-
xMin
)
/
2
.
0f
;
coef
=
3
.
0f
*
x
*
(
1
.
0f
-
x
)
;
tx
=
coef
*
(
(
1
.
0f
-
x
)
*
P1
+
x
*
P2
)
+
x
*
x
*
x
;
if
(
Math
.
abs
(
tx
-
alpha
)
<
1E
-
5
)
break
;
if
(
tx
>
alpha
)
{
xMax
=
x
;
}
else
{
xMin
=
x
;
}
}
SPLINE_POSITION
[
i
]
=
coef
*
(
(
1
.
0f
-
x
)
*
START_TENSION
+
x
)
+
x
*
x
*
x
;
float
yMax
=
1
.
0f
;
float
y
dy
;
while
(
true
)
{
y
=
yMin
+
(
yMax
-
yMin
)
/
2
.
0f
;
coef
=
3
.
0f
*
y
*
(
1
.
0f
-
y
)
;
dy
=
coef
*
(
(
1
.
0f
-
y
)
*
START_TENSION
+
y
)
+
y
*
y
*
y
;
if
(
Math
.
abs
(
dy
-
alpha
)
<
1E
-
5
)
break
;
if
(
dy
>
alpha
)
{
yMax
=
y
;
}
else
{
yMin
=
y
;
}
}
SPLINE_TIME
[
i
]
=
coef
*
(
(
1
.
0f
-
y
)
*
P1
+
y
*
P2
)
+
y
*
y
*
y
;
}
SPLINE_POSITION
[
NB_SAMPLES
]
=
SPLINE_TIME
[
NB_SAMPLES
]
=
1
.
0f
;
}
SplineStackScroller
(
Context
context
)
{
mFinished
=
true
;
final
float
ppi
=
context
.
getResources
(
)
.
getDisplayMetrics
(
)
.
density
*
160
.
0f
;
mPhysicalCoeff
=
SensorManager
.
GRAVITY_EARTH
*
39
.
37f
*
ppi
*
0
.
84f
;
}
void
updateScroll
(
float
q
)
{
mCurrentPosition
=
mStart
+
Math
.
round
(
q
*
(
mFinal
-
mStart
)
)
;
}
private
static
float
getDeceleration
(
int
velocity
)
{
return
velocity
>
0
?
-
GRAVITY
:
GRAVITY
;
}
private
void
adjustDuration
(
int
start
int
oldFinal
int
newFinal
)
{
final
int
oldDistance
=
oldFinal
-
start
;
final
int
newDistance
=
newFinal
-
start
;
final
float
x
=
Math
.
abs
(
(
float
)
newDistance
/
oldDistance
)
;
final
int
index
=
(
int
)
(
NB_SAMPLES
*
x
)
;
if
(
index
<
NB_SAMPLES
)
{
final
float
xInf
=
(
float
)
index
/
NB_SAMPLES
;
final
float
xSup
=
(
float
)
(
index
+
1
)
/
NB_SAMPLES
;
final
float
tInf
=
SPLINE_TIME
[
index
]
;
final
float
tSup
=
SPLINE_TIME
[
index
+
1
]
;
final
float
timeCoef
=
tInf
+
(
x
-
xInf
)
/
(
xSup
-
xInf
)
*
(
tSup
-
tInf
)
;
mDuration
*
=
timeCoef
;
}
}
void
startScroll
(
int
start
int
distance
long
startTime
int
duration
)
{
mFinished
=
false
;
mStart
=
start
;
mFinal
=
start
+
distance
;
mStartTime
=
startTime
;
mDuration
=
duration
;
mDeceleration
=
0
.
0f
;
mVelocity
=
0
;
}
void
finish
(
)
{
mCurrentPosition
=
mFinal
;
mFinished
=
true
;
}
void
setFinalPosition
(
int
position
)
{
mFinal
=
position
;
mFinished
=
false
;
}
boolean
springback
(
int
start
int
min
int
max
long
time
)
{
mFinished
=
true
;
mStart
=
mFinal
=
start
;
mVelocity
=
0
;
mStartTime
=
time
;
mDuration
=
0
;
if
(
start
<
min
)
{
startSpringback
(
start
min
0
)
;
}
else
if
(
start
>
max
)
{
startSpringback
(
start
max
0
)
;
}
return
!
mFinished
;
}
private
void
startSpringback
(
int
start
int
end
int
velocity
)
{
mFinished
=
false
;
mState
=
CUBIC
;
mStart
=
start
;
mFinal
=
end
;
final
int
delta
=
start
-
end
;
mDeceleration
=
getDeceleration
(
delta
)
;
mVelocity
=
-
delta
;
mOver
=
Math
.
abs
(
delta
)
;
mDuration
=
(
int
)
(
1000
.
0
*
Math
.
sqrt
(
-
2
.
0
*
delta
/
mDeceleration
)
)
;
}
void
fling
(
int
start
int
velocity
int
min
int
max
int
over
long
time
)
{
mOver
=
over
;
mFinished
=
false
;
mCurrVelocity
=
mVelocity
=
velocity
;
mDuration
=
mSplineDuration
=
0
;
mStartTime
=
time
;
mCurrentPosition
=
mStart
=
start
;
if
(
start
>
max
|
|
start
<
min
)
{
startAfterEdge
(
start
min
max
velocity
time
)
;
return
;
}
mState
=
SPLINE
;
double
totalDistance
=
0
.
0
;
if
(
velocity
!
=
0
)
{
mDuration
=
mSplineDuration
=
getSplineFlingDuration
(
velocity
)
;
totalDistance
=
getSplineFlingDistance
(
velocity
)
;
}
mSplineDistance
=
(
int
)
(
totalDistance
*
Math
.
signum
(
velocity
)
)
;
mFinal
=
start
+
mSplineDistance
;
if
(
mFinal
<
min
)
{
adjustDuration
(
mStart
mFinal
min
)
;
mFinal
=
min
;
}
if
(
mFinal
>
max
)
{
adjustDuration
(
mStart
mFinal
max
)
;
mFinal
=
max
;
}
}
private
double
getSplineDeceleration
(
int
velocity
)
{
return
Math
.
log
(
INFLEXION
*
Math
.
abs
(
velocity
)
/
(
mFlingFriction
*
mPhysicalCoeff
)
)
;
}
private
double
getSplineFlingDistance
(
int
velocity
)
{
final
double
l
=
getSplineDeceleration
(
velocity
)
;
final
double
decelMinusOne
=
DECELERATION_RATE
-
1
.
0
;
return
mFlingFriction
*
mPhysicalCoeff
*
Math
.
exp
(
DECELERATION_RATE
/
decelMinusOne
*
l
)
;
}
private
int
getSplineFlingDuration
(
int
velocity
)
{
final
double
l
=
getSplineDeceleration
(
velocity
)
;
final
double
decelMinusOne
=
DECELERATION_RATE
-
1
.
0
;
return
(
int
)
(
1000
.
0
*
Math
.
exp
(
l
/
decelMinusOne
)
)
;
}
private
void
fitOnBounceCurve
(
int
start
int
end
int
velocity
)
{
final
float
durationToApex
=
-
velocity
/
mDeceleration
;
final
float
distanceToApex
=
velocity
*
velocity
/
2
.
0f
/
Math
.
abs
(
mDeceleration
)
;
final
float
distanceToEdge
=
Math
.
abs
(
end
-
start
)
;
final
float
totalDuration
=
(
float
)
Math
.
sqrt
(
2
.
0
*
(
distanceToApex
+
distanceToEdge
)
/
Math
.
abs
(
mDeceleration
)
)
;
mStartTime
-
=
(
int
)
(
1000
.
0f
*
(
totalDuration
-
durationToApex
)
)
;
mStart
=
end
;
mVelocity
=
(
int
)
(
-
mDeceleration
*
totalDuration
)
;
}
private
void
startBounceAfterEdge
(
int
start
int
end
int
velocity
)
{
mDeceleration
=
getDeceleration
(
velocity
=
=
0
?
start
-
end
:
velocity
)
;
fitOnBounceCurve
(
start
end
velocity
)
;
onEdgeReached
(
)
;
}
private
void
startAfterEdge
(
int
start
int
min
int
max
int
velocity
long
time
)
{
if
(
start
>
min
&
&
start
<
max
)
{
Log
.
e
(
"
StackScroller
"
"
startAfterEdge
called
from
a
valid
position
"
)
;
mFinished
=
true
;
return
;
}
final
boolean
positive
=
start
>
max
;
final
int
edge
=
positive
?
max
:
min
;
final
int
overDistance
=
start
-
edge
;
boolean
keepIncreasing
=
overDistance
*
velocity
>
=
0
;
if
(
keepIncreasing
)
{
startBounceAfterEdge
(
start
edge
velocity
)
;
}
else
{
final
double
totalDistance
=
getSplineFlingDistance
(
velocity
)
;
if
(
totalDistance
>
Math
.
abs
(
overDistance
)
)
{
fling
(
start
velocity
positive
?
min
:
start
positive
?
start
:
max
mOver
time
)
;
}
else
{
startSpringback
(
start
edge
velocity
)
;
}
}
}
private
void
onEdgeReached
(
)
{
float
distance
=
mVelocity
*
mVelocity
/
(
2
.
0f
*
Math
.
abs
(
mDeceleration
)
)
;
final
float
sign
=
Math
.
signum
(
mVelocity
)
;
if
(
distance
>
mOver
)
{
mDeceleration
=
-
sign
*
mVelocity
*
mVelocity
/
(
2
.
0f
*
mOver
)
;
distance
=
mOver
;
}
mOver
=
(
int
)
distance
;
mState
=
BALLISTIC
;
mFinal
=
mStart
+
(
int
)
(
mVelocity
>
0
?
distance
:
-
distance
)
;
mDuration
=
-
(
int
)
(
1000
.
0f
*
mVelocity
/
mDeceleration
)
;
}
boolean
continueWhenFinished
(
long
time
)
{
switch
(
mState
)
{
case
SPLINE
:
if
(
mDuration
<
mSplineDuration
)
{
mStart
=
mFinal
;
mVelocity
=
(
int
)
mCurrVelocity
;
mDeceleration
=
getDeceleration
(
mVelocity
)
;
mStartTime
+
=
mDuration
;
onEdgeReached
(
)
;
}
else
{
return
false
;
}
break
;
case
BALLISTIC
:
mStartTime
+
=
mDuration
;
startSpringback
(
mFinal
mStart
0
)
;
break
;
case
CUBIC
:
return
false
;
}
update
(
time
)
;
return
true
;
}
boolean
update
(
long
time
)
{
final
long
currentTime
=
time
-
mStartTime
;
if
(
currentTime
>
mDuration
)
{
return
false
;
}
double
distance
=
0
.
0
;
switch
(
mState
)
{
case
SPLINE
:
{
final
float
t
=
(
float
)
currentTime
/
mSplineDuration
;
final
int
index
=
(
int
)
(
NB_SAMPLES
*
t
)
;
float
distanceCoef
=
1
.
f
;
float
velocityCoef
=
0
.
f
;
if
(
index
<
NB_SAMPLES
)
{
final
float
tInf
=
(
float
)
index
/
NB_SAMPLES
;
final
float
tSup
=
(
float
)
(
index
+
1
)
/
NB_SAMPLES
;
final
float
dInf
=
SPLINE_POSITION
[
index
]
;
final
float
dSup
=
SPLINE_POSITION
[
index
+
1
]
;
velocityCoef
=
(
dSup
-
dInf
)
/
(
tSup
-
tInf
)
;
distanceCoef
=
dInf
+
(
t
-
tInf
)
*
velocityCoef
;
}
distance
=
distanceCoef
*
mSplineDistance
;
mCurrVelocity
=
velocityCoef
*
mSplineDistance
/
mSplineDuration
*
1000
.
0f
;
break
;
}
case
BALLISTIC
:
{
final
float
t
=
currentTime
/
1000
.
0f
;
mCurrVelocity
=
mVelocity
+
mDeceleration
*
t
;
distance
=
mVelocity
*
t
+
mDeceleration
*
t
*
t
/
2
.
0f
;
break
;
}
case
CUBIC
:
{
final
float
t
=
(
float
)
(
currentTime
)
/
mDuration
;
final
float
t2
=
t
*
t
;
final
float
sign
=
Math
.
signum
(
mVelocity
)
;
distance
=
sign
*
mOver
*
(
3
.
0f
*
t2
-
2
.
0f
*
t
*
t2
)
;
mCurrVelocity
=
sign
*
mOver
*
6
.
0f
*
(
-
t
+
t2
)
;
break
;
}
}
mCurrentPosition
=
mStart
+
(
int
)
Math
.
round
(
distance
)
;
return
true
;
}
}
}
