package
org
.
mozilla
.
gecko
;
import
android
.
content
.
Context
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
view
.
View
;
import
android
.
widget
.
PopupWindow
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
widget
.
AnchoredPopup
;
import
org
.
mozilla
.
gecko
.
widget
.
DoorHanger
;
import
org
.
mozilla
.
gecko
.
widget
.
DoorhangerConfig
;
import
java
.
util
.
HashSet
;
import
static
org
.
mozilla
.
gecko
.
widget
.
DoorHanger
.
Type
;
public
class
DoorHangerPopup
extends
AnchoredPopup
implements
BundleEventListener
Tabs
.
OnTabsChangedListener
PopupWindow
.
OnDismissListener
DoorHanger
.
OnButtonClickListener
{
private
static
final
String
LOGTAG
=
"
GeckoDoorHangerPopup
"
;
private
final
HashSet
<
DoorHanger
>
mDoorHangers
;
private
boolean
mDisabled
;
private
final
EventDispatcher
eventDispatcher
;
private
final
boolean
isGeckoApp
;
public
DoorHangerPopup
(
final
Context
context
final
EventDispatcher
dispatcher
)
{
super
(
context
)
;
eventDispatcher
=
dispatcher
;
isGeckoApp
=
context
instanceof
GeckoApp
;
mDoorHangers
=
new
HashSet
<
DoorHanger
>
(
)
;
eventDispatcher
.
registerUiThreadListener
(
this
"
Doorhanger
:
Add
"
"
Doorhanger
:
Remove
"
)
;
if
(
isGeckoApp
)
{
Tabs
.
registerOnTabsChangedListener
(
this
)
;
}
setOnDismissListener
(
this
)
;
}
public
void
destroy
(
)
{
eventDispatcher
.
unregisterUiThreadListener
(
this
"
Doorhanger
:
Add
"
"
Doorhanger
:
Remove
"
)
;
if
(
isGeckoApp
)
{
Tabs
.
unregisterOnTabsChangedListener
(
this
)
;
}
}
void
disable
(
)
{
mDisabled
=
true
;
updatePopup
(
)
;
}
void
enable
(
)
{
mDisabled
=
false
;
updatePopup
(
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
geckoObject
final
EventCallback
callback
)
{
if
(
event
.
equals
(
"
Doorhanger
:
Add
"
)
)
{
final
DoorhangerConfig
config
=
makeConfigFromBundle
(
geckoObject
)
;
addDoorHanger
(
config
callback
(
Integer
)
geckoObject
.
get
(
"
defaultCallback
"
)
)
;
}
else
if
(
event
.
equals
(
"
Doorhanger
:
Remove
"
)
)
{
final
int
tabId
=
geckoObject
.
getInt
(
"
tabID
"
-
1
)
;
final
String
value
=
geckoObject
.
getString
(
"
value
"
)
;
DoorHanger
doorHanger
=
getDoorHanger
(
tabId
value
)
;
if
(
doorHanger
=
=
null
)
{
return
;
}
removeDoorHanger
(
doorHanger
)
;
updatePopup
(
)
;
}
}
private
DoorhangerConfig
makeConfigFromBundle
(
final
GeckoBundle
bundle
)
{
final
int
tabId
=
bundle
.
getInt
(
"
tabID
"
-
1
)
;
final
String
id
=
bundle
.
getString
(
"
value
"
)
;
final
String
typeString
=
bundle
.
getString
(
"
category
"
)
;
final
DoorHanger
.
Type
doorhangerType
=
typeString
=
=
null
?
DoorHanger
.
Type
.
DEFAULT
:
DoorHanger
.
Type
.
valueOf
(
typeString
)
;
final
DoorhangerConfig
config
=
new
DoorhangerConfig
(
tabId
id
doorhangerType
this
)
;
config
.
setMessage
(
bundle
.
getString
(
"
message
"
)
)
;
config
.
setOptions
(
bundle
.
getBundle
(
"
options
"
)
)
;
final
GeckoBundle
[
]
buttonArray
=
bundle
.
getBundleArray
(
"
buttons
"
)
;
int
numButtons
=
buttonArray
.
length
;
if
(
numButtons
>
2
)
{
Log
.
e
(
LOGTAG
"
Doorhanger
can
have
a
maximum
of
two
buttons
!
"
)
;
numButtons
=
2
;
}
for
(
int
i
=
0
;
i
<
numButtons
;
i
+
+
)
{
final
GeckoBundle
button
=
buttonArray
[
i
]
;
final
boolean
isPositive
=
button
.
getBoolean
(
"
positive
"
false
)
;
config
.
setButton
(
button
.
getString
(
"
label
"
)
button
.
getInt
(
"
callback
"
)
isPositive
)
;
}
return
config
;
}
Override
public
void
onTabChanged
(
final
Tab
tab
final
Tabs
.
TabEvents
msg
final
String
data
)
{
switch
(
msg
)
{
case
CLOSED
:
removeTabDoorHangers
(
tab
.
getId
(
)
true
)
;
break
;
case
LOCATION_CHANGE
:
if
(
!
isShowing
(
)
|
|
!
data
.
equals
(
tab
.
getURL
(
)
)
)
removeTabDoorHangers
(
tab
.
getId
(
)
false
)
;
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
updatePopup
(
)
;
break
;
case
SELECTED
:
updatePopup
(
)
;
break
;
}
}
private
void
addDoorHanger
(
final
DoorhangerConfig
config
final
EventCallback
callback
final
Integer
defaultCallback
)
{
final
int
tabId
=
config
.
getTabId
(
)
;
if
(
isGeckoApp
&
&
Tabs
.
getInstance
(
)
.
getTab
(
tabId
)
=
=
null
)
{
return
;
}
DoorHanger
oldDoorHanger
=
getDoorHanger
(
tabId
config
.
getId
(
)
)
;
if
(
oldDoorHanger
!
=
null
)
{
removeDoorHanger
(
oldDoorHanger
)
;
}
if
(
!
mInflated
)
{
init
(
)
;
}
final
DoorHanger
newDoorHanger
=
DoorHanger
.
Get
(
mContext
config
)
;
newDoorHanger
.
callback
=
callback
;
newDoorHanger
.
defaultCallback
=
defaultCallback
;
mDoorHangers
.
add
(
newDoorHanger
)
;
mContent
.
addView
(
newDoorHanger
)
;
if
(
!
isGeckoApp
|
|
tabId
=
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
getId
(
)
)
{
updatePopup
(
)
;
}
}
Override
public
void
onButtonClick
(
final
GeckoBundle
response
DoorHanger
doorhanger
)
{
if
(
isGeckoApp
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Doorhanger
:
Reply
"
response
)
;
}
else
{
doorhanger
.
callback
.
sendSuccess
(
response
)
;
}
doorhanger
.
defaultCallback
=
null
;
removeDoorHanger
(
doorhanger
)
;
updatePopup
(
)
;
}
private
DoorHanger
getDoorHanger
(
int
tabId
String
value
)
{
for
(
DoorHanger
dh
:
mDoorHangers
)
{
if
(
dh
.
getTabId
(
)
=
=
tabId
&
&
dh
.
getIdentifier
(
)
.
equals
(
value
)
)
return
dh
;
}
return
null
;
}
private
void
removeDoorHanger
(
final
DoorHanger
doorHanger
)
{
if
(
doorHanger
.
defaultCallback
!
=
null
)
{
final
GeckoBundle
response
=
new
GeckoBundle
(
1
)
;
response
.
putInt
(
"
callback
"
doorHanger
.
defaultCallback
)
;
if
(
isGeckoApp
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Doorhanger
:
Reply
"
response
)
;
}
else
{
doorHanger
.
callback
.
sendSuccess
(
response
)
;
}
}
mDoorHangers
.
remove
(
doorHanger
)
;
mContent
.
removeView
(
doorHanger
)
;
}
private
void
removeTabDoorHangers
(
int
tabId
boolean
forceRemove
)
{
HashSet
<
DoorHanger
>
doorHangersToRemove
=
new
HashSet
<
DoorHanger
>
(
)
;
for
(
DoorHanger
dh
:
mDoorHangers
)
{
if
(
dh
.
getTabId
(
)
=
=
tabId
&
&
(
forceRemove
|
|
(
!
forceRemove
&
&
dh
.
shouldRemove
(
isShowing
(
)
)
)
)
)
{
doorHangersToRemove
.
add
(
dh
)
;
}
}
for
(
DoorHanger
dh
:
doorHangersToRemove
)
{
removeDoorHanger
(
dh
)
;
}
}
private
void
updatePopup
(
)
{
final
Tab
tab
=
isGeckoApp
?
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
:
null
;
if
(
(
isGeckoApp
&
&
tab
=
=
null
)
|
|
mDoorHangers
.
size
(
)
=
=
0
|
|
!
mInflated
|
|
mDisabled
)
{
dismiss
(
)
;
return
;
}
int
tabId
=
(
tab
!
=
null
)
?
tab
.
getId
(
)
:
-
1
;
boolean
shouldShowPopup
=
false
;
DoorHanger
firstDoorhanger
=
null
;
for
(
DoorHanger
dh
:
mDoorHangers
)
{
if
(
dh
.
getTabId
(
)
=
=
tabId
)
{
dh
.
setVisibility
(
View
.
VISIBLE
)
;
shouldShowPopup
=
true
;
if
(
firstDoorhanger
=
=
null
)
{
firstDoorhanger
=
dh
;
}
else
{
dh
.
hideTitle
(
)
;
}
}
else
{
dh
.
setVisibility
(
View
.
GONE
)
;
}
}
if
(
!
shouldShowPopup
)
{
dismiss
(
)
;
return
;
}
showDividers
(
)
;
final
String
baseDomain
=
tab
!
=
null
?
tab
.
getBaseDomain
(
)
:
null
;
if
(
firstDoorhanger
.
getType
(
)
=
=
Type
.
ADDON
)
{
firstDoorhanger
.
showTitle
(
null
mContext
.
getString
(
R
.
string
.
addons
)
)
;
}
else
if
(
TextUtils
.
isEmpty
(
baseDomain
)
)
{
firstDoorhanger
.
hideTitle
(
)
;
}
else
{
firstDoorhanger
.
showTitle
(
tab
.
getFavicon
(
)
baseDomain
)
;
}
if
(
isShowing
(
)
)
{
show
(
)
;
return
;
}
setFocusable
(
true
)
;
show
(
)
;
}
private
void
showDividers
(
)
{
int
count
=
mContent
.
getChildCount
(
)
;
DoorHanger
lastVisibleDoorHanger
=
null
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
DoorHanger
dh
=
(
DoorHanger
)
mContent
.
getChildAt
(
i
)
;
dh
.
showDivider
(
)
;
if
(
dh
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
{
lastVisibleDoorHanger
=
dh
;
}
}
if
(
lastVisibleDoorHanger
!
=
null
)
{
lastVisibleDoorHanger
.
hideDivider
(
)
;
}
}
Override
public
void
onDismiss
(
)
{
final
int
tabId
=
isGeckoApp
?
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
getId
(
)
:
-
1
;
removeTabDoorHangers
(
tabId
true
)
;
}
Override
public
void
dismiss
(
)
{
setFocusable
(
false
)
;
super
.
dismiss
(
)
;
}
}
