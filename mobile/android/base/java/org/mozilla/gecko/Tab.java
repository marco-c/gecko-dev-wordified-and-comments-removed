package
org
.
mozilla
.
gecko
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Map
;
import
java
.
util
.
concurrent
.
Future
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
customtabs
.
CustomTabsActivity
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
URLMetadata
;
import
org
.
mozilla
.
gecko
.
gfx
.
BitmapUtils
;
import
org
.
mozilla
.
gecko
.
icons
.
IconCallback
;
import
org
.
mozilla
.
gecko
.
icons
.
IconDescriptor
;
import
org
.
mozilla
.
gecko
.
icons
.
IconRequestBuilder
;
import
org
.
mozilla
.
gecko
.
icons
.
IconResponse
;
import
org
.
mozilla
.
gecko
.
icons
.
Icons
;
import
org
.
mozilla
.
gecko
.
mozglue
.
SafeIntent
;
import
org
.
mozilla
.
gecko
.
reader
.
ReaderModeUtils
;
import
org
.
mozilla
.
gecko
.
reader
.
ReadingListHelper
;
import
org
.
mozilla
.
gecko
.
toolbar
.
BrowserToolbar
.
TabEditingState
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
webapps
.
WebAppIndexer
;
import
org
.
mozilla
.
gecko
.
widget
.
SiteLogins
;
import
android
.
app
.
Activity
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
drawable
.
BitmapDrawable
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
view
.
View
;
public
class
Tab
{
private
static
final
String
LOGTAG
=
"
GeckoTab
"
;
private
static
Pattern
sColorPattern
;
private
final
int
mId
;
private
TabType
mType
;
private
final
BrowserDB
mDB
;
private
long
mLastUsed
;
private
String
mUrl
;
private
String
mBaseDomain
;
private
String
mUserRequested
;
private
String
mTitle
;
private
Bitmap
mFavicon
;
private
String
mFaviconUrl
;
private
String
mApplicationId
;
private
IconRequestBuilder
mIconRequestBuilder
;
private
Future
<
IconResponse
>
mRunningIconRequest
;
private
boolean
mHasFeeds
;
private
SafeIntent
mCustomTabIntent
;
private
String
mManifestUrl
;
private
String
mManifestPath
;
private
boolean
mHasOpenSearch
;
private
final
SiteIdentity
mSiteIdentity
;
private
SiteLogins
mSiteLogins
;
private
BitmapDrawable
mThumbnail
;
private
volatile
int
mParentId
;
private
final
boolean
mExternal
;
private
boolean
mBookmark
;
private
int
mFaviconLoadId
;
private
String
mContentType
;
private
boolean
mHasTouchListeners
;
private
final
ArrayList
<
View
>
mPluginViews
;
private
int
mState
;
private
Bitmap
mThumbnailBitmap
;
private
boolean
mDesktopMode
;
private
boolean
mEnteringReaderMode
;
private
final
Context
mAppContext
;
private
ErrorType
mErrorType
=
ErrorType
.
NONE
;
private
volatile
int
mLoadProgress
;
private
volatile
int
mRecordingCount
;
private
volatile
boolean
mIsAudioPlaying
;
private
volatile
boolean
mIsMediaPlaying
;
private
String
mMostRecentHomePanel
;
private
boolean
mShouldShowToolbarWithoutAnimationOnFirstSelection
;
private
Bundle
mMostRecentHomePanelData
;
private
boolean
mCanDoBack
;
private
boolean
mCanDoForward
;
private
boolean
mIsEditing
;
private
final
TabEditingState
mEditingState
=
new
TabEditingState
(
)
;
private
boolean
mLoadedFromCache
;
public
static
final
int
STATE_DELAYED
=
0
;
public
static
final
int
STATE_LOADING
=
1
;
public
static
final
int
STATE_SUCCESS
=
2
;
public
static
final
int
STATE_ERROR
=
3
;
public
static
final
int
LOAD_PROGRESS_INIT
=
10
;
public
static
final
int
LOAD_PROGRESS_START
=
20
;
public
static
final
int
LOAD_PROGRESS_LOCATION_CHANGE
=
60
;
public
static
final
int
LOAD_PROGRESS_LOADED
=
80
;
public
static
final
int
LOAD_PROGRESS_STOP
=
100
;
public
enum
ErrorType
{
CERT_ERROR
BLOCKED
NET_ERROR
NONE
}
public
Tab
(
Context
context
int
id
String
url
boolean
external
int
parentId
String
title
TabType
type
)
{
mAppContext
=
context
.
getApplicationContext
(
)
;
mDB
=
BrowserDB
.
from
(
context
)
;
mId
=
id
;
mType
=
type
;
mUrl
=
url
;
mBaseDomain
=
"
"
;
mUserRequested
=
"
"
;
mExternal
=
external
;
mParentId
=
parentId
;
mTitle
=
title
=
=
null
?
"
"
:
title
;
mSiteIdentity
=
new
SiteIdentity
(
)
;
mContentType
=
"
"
;
mPluginViews
=
new
ArrayList
<
View
>
(
)
;
mState
=
shouldShowProgress
(
url
)
?
STATE_LOADING
:
STATE_SUCCESS
;
mLoadProgress
=
LOAD_PROGRESS_INIT
;
mIconRequestBuilder
=
Icons
.
with
(
mAppContext
)
.
pageUrl
(
mUrl
)
;
updateBookmark
(
)
;
}
private
ContentResolver
getContentResolver
(
)
{
return
mAppContext
.
getContentResolver
(
)
;
}
public
void
onDestroy
(
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
this
Tabs
.
TabEvents
.
CLOSED
)
;
}
RobocopTarget
public
int
getId
(
)
{
return
mId
;
}
public
synchronized
void
onChange
(
)
{
mLastUsed
=
System
.
currentTimeMillis
(
)
;
}
public
synchronized
long
getLastUsed
(
)
{
return
mLastUsed
;
}
public
int
getParentId
(
)
{
return
mParentId
;
}
public
void
setParentId
(
int
parentId
)
{
mParentId
=
parentId
;
}
public
synchronized
String
getURL
(
)
{
return
mUrl
;
}
public
synchronized
String
getUserRequested
(
)
{
return
mUserRequested
;
}
public
synchronized
String
getTitle
(
)
{
return
mTitle
;
}
public
String
getDisplayTitle
(
)
{
if
(
mTitle
!
=
null
&
&
mTitle
.
length
(
)
>
0
)
{
return
mTitle
;
}
return
mUrl
;
}
public
String
getBaseDomain
(
)
{
return
mBaseDomain
;
}
public
Bitmap
getFavicon
(
)
{
return
mFavicon
;
}
protected
String
getApplicationId
(
)
{
return
mApplicationId
;
}
protected
void
setApplicationId
(
final
String
applicationId
)
{
mApplicationId
=
applicationId
;
}
public
BitmapDrawable
getThumbnail
(
)
{
return
mThumbnail
;
}
public
String
getMostRecentHomePanel
(
)
{
return
mMostRecentHomePanel
;
}
public
Bundle
getMostRecentHomePanelData
(
)
{
return
mMostRecentHomePanelData
;
}
public
void
setMostRecentHomePanel
(
String
panelId
)
{
mMostRecentHomePanel
=
panelId
;
mMostRecentHomePanelData
=
null
;
}
public
void
setMostRecentHomePanelData
(
Bundle
data
)
{
mMostRecentHomePanelData
=
data
;
}
public
Bitmap
getThumbnailBitmap
(
int
width
int
height
)
{
if
(
mThumbnailBitmap
!
=
null
)
{
boolean
honeycomb
=
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
HONEYCOMB
&
&
Build
.
VERSION
.
SDK_INT
<
=
Build
.
VERSION_CODES
.
HONEYCOMB_MR2
)
;
boolean
sizeChange
=
mThumbnailBitmap
.
getWidth
(
)
!
=
width
|
|
mThumbnailBitmap
.
getHeight
(
)
!
=
height
;
if
(
honeycomb
|
|
sizeChange
)
{
mThumbnailBitmap
=
null
;
}
}
if
(
mThumbnailBitmap
=
=
null
)
{
Bitmap
.
Config
config
=
(
GeckoAppShell
.
getScreenDepth
(
)
=
=
24
)
?
Bitmap
.
Config
.
ARGB_8888
:
Bitmap
.
Config
.
RGB_565
;
mThumbnailBitmap
=
Bitmap
.
createBitmap
(
width
height
config
)
;
}
return
mThumbnailBitmap
;
}
public
void
updateThumbnail
(
final
Bitmap
b
final
ThumbnailHelper
.
CachePolicy
cachePolicy
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
b
!
=
null
)
{
try
{
mThumbnail
=
new
BitmapDrawable
(
mAppContext
.
getResources
(
)
b
)
;
if
(
mState
=
=
Tab
.
STATE_SUCCESS
&
&
cachePolicy
=
=
ThumbnailHelper
.
CachePolicy
.
STORE
)
{
saveThumbnailToDB
(
mDB
)
;
}
else
{
clearThumbnailFromDB
(
mDB
)
;
}
}
catch
(
OutOfMemoryError
oom
)
{
Log
.
w
(
LOGTAG
"
Unable
to
create
/
scale
bitmap
.
"
oom
)
;
mThumbnail
=
null
;
}
}
else
{
mThumbnail
=
null
;
}
Tabs
.
getInstance
(
)
.
notifyListeners
(
Tab
.
this
Tabs
.
TabEvents
.
THUMBNAIL
)
;
}
}
)
;
}
public
synchronized
String
getFaviconURL
(
)
{
return
mFaviconUrl
;
}
public
boolean
hasFeeds
(
)
{
return
mHasFeeds
;
}
public
SafeIntent
getCustomTabIntent
(
)
{
return
mCustomTabIntent
;
}
public
String
getManifestUrl
(
)
{
return
mManifestUrl
;
}
public
String
getManifestPath
(
)
{
return
mManifestPath
;
}
public
boolean
hasOpenSearch
(
)
{
return
mHasOpenSearch
;
}
public
boolean
hasLoadedFromCache
(
)
{
return
mLoadedFromCache
;
}
public
SiteIdentity
getSiteIdentity
(
)
{
return
mSiteIdentity
;
}
public
void
resetSiteIdentity
(
)
{
if
(
mSiteIdentity
!
=
null
)
{
mSiteIdentity
.
reset
(
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
this
Tabs
.
TabEvents
.
SECURITY_CHANGE
)
;
}
}
public
SiteLogins
getSiteLogins
(
)
{
return
mSiteLogins
;
}
public
boolean
isBookmark
(
)
{
return
mBookmark
;
}
public
boolean
isExternal
(
)
{
return
mExternal
;
}
public
synchronized
void
updateURL
(
String
url
)
{
if
(
url
!
=
null
&
&
url
.
length
(
)
>
0
)
{
mUrl
=
url
;
}
}
public
synchronized
void
updateUserRequested
(
String
userRequested
)
{
mUserRequested
=
userRequested
;
}
public
void
setErrorType
(
String
type
)
{
if
(
"
blocked
"
.
equals
(
type
)
)
setErrorType
(
ErrorType
.
BLOCKED
)
;
else
if
(
"
certerror
"
.
equals
(
type
)
)
setErrorType
(
ErrorType
.
CERT_ERROR
)
;
else
if
(
"
neterror
"
.
equals
(
type
)
)
setErrorType
(
ErrorType
.
NET_ERROR
)
;
else
setErrorType
(
ErrorType
.
NONE
)
;
}
public
void
setErrorType
(
ErrorType
type
)
{
mErrorType
=
type
;
}
public
void
setMetadata
(
JSONObject
metadata
)
{
if
(
metadata
=
=
null
)
{
return
;
}
final
ContentResolver
cr
=
mAppContext
.
getContentResolver
(
)
;
final
URLMetadata
urlMetadata
=
mDB
.
getURLMetadata
(
)
;
final
Map
<
String
Object
>
data
=
urlMetadata
.
fromJSON
(
metadata
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
urlMetadata
.
save
(
cr
data
)
;
}
}
)
;
}
public
ErrorType
getErrorType
(
)
{
return
mErrorType
;
}
public
void
setContentType
(
String
contentType
)
{
mContentType
=
(
contentType
=
=
null
)
?
"
"
:
contentType
;
}
public
String
getContentType
(
)
{
return
mContentType
;
}
public
synchronized
void
updateTitle
(
String
title
)
{
if
(
mEnteringReaderMode
)
{
return
;
}
if
(
mTitle
!
=
null
&
&
TextUtils
.
equals
(
mTitle
title
)
)
{
return
;
}
mTitle
=
(
title
=
=
null
?
"
"
:
title
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
this
Tabs
.
TabEvents
.
TITLE
)
;
}
public
void
setState
(
int
state
)
{
mState
=
state
;
if
(
mState
!
=
Tab
.
STATE_LOADING
)
mEnteringReaderMode
=
false
;
}
public
int
getState
(
)
{
return
mState
;
}
public
void
setHasTouchListeners
(
boolean
aValue
)
{
mHasTouchListeners
=
aValue
;
}
public
boolean
getHasTouchListeners
(
)
{
return
mHasTouchListeners
;
}
public
synchronized
void
addFavicon
(
NonNull
String
faviconURL
int
faviconSize
String
mimeType
)
{
mIconRequestBuilder
.
icon
(
IconDescriptor
.
createFavicon
(
faviconURL
faviconSize
mimeType
)
)
.
deferBuild
(
)
;
}
public
synchronized
void
addTouchicon
(
NonNull
String
iconUrl
int
faviconSize
String
mimeType
)
{
mIconRequestBuilder
.
icon
(
IconDescriptor
.
createTouchicon
(
iconUrl
faviconSize
mimeType
)
)
.
deferBuild
(
)
;
}
public
void
loadFavicon
(
)
{
if
(
AboutPages
.
isBuiltinIconPage
(
mUrl
)
&
&
mFavicon
!
=
null
)
{
return
;
}
mRunningIconRequest
=
mIconRequestBuilder
.
build
(
)
.
execute
(
new
IconCallback
(
)
{
Override
public
void
onIconResponse
(
IconResponse
response
)
{
mFavicon
=
response
.
getBitmap
(
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
Tab
.
this
Tabs
.
TabEvents
.
FAVICON
)
;
}
}
)
;
}
public
synchronized
void
clearFavicon
(
)
{
if
(
mRunningIconRequest
!
=
null
)
{
mRunningIconRequest
.
cancel
(
true
)
;
}
if
(
mEnteringReaderMode
)
return
;
mFavicon
=
null
;
mFaviconUrl
=
null
;
}
public
void
setHasFeeds
(
boolean
hasFeeds
)
{
mHasFeeds
=
hasFeeds
;
}
public
void
setCustomTabIntent
(
SafeIntent
intent
)
{
mCustomTabIntent
=
intent
;
}
public
void
setManifestUrl
(
String
manifestUrl
)
{
mManifestUrl
=
manifestUrl
;
}
public
void
setManifestPath
(
String
manifestPath
)
{
mManifestPath
=
manifestPath
;
}
public
void
setHasOpenSearch
(
boolean
hasOpenSearch
)
{
mHasOpenSearch
=
hasOpenSearch
;
}
public
void
setLoadedFromCache
(
boolean
loadedFromCache
)
{
mLoadedFromCache
=
loadedFromCache
;
}
public
void
updateIdentityData
(
final
GeckoBundle
identityData
)
{
mSiteIdentity
.
update
(
identityData
)
;
}
public
void
setSiteLogins
(
SiteLogins
siteLogins
)
{
mSiteLogins
=
siteLogins
;
}
void
updateBookmark
(
)
{
if
(
getURL
(
)
=
=
null
)
{
return
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
String
url
=
getURL
(
)
;
if
(
url
=
=
null
)
{
return
;
}
final
String
pageUrl
=
ReaderModeUtils
.
stripAboutReaderUrl
(
url
)
;
mBookmark
=
mDB
.
isBookmark
(
getContentResolver
(
)
pageUrl
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
Tab
.
this
Tabs
.
TabEvents
.
MENU_UPDATED
)
;
}
}
)
;
}
public
void
addBookmark
(
)
{
final
String
url
=
getURL
(
)
;
if
(
url
=
=
null
)
{
return
;
}
final
String
pageUrl
=
ReaderModeUtils
.
stripAboutReaderUrl
(
getURL
(
)
)
;
if
(
AboutPages
.
isAboutReader
(
url
)
)
{
ReadingListHelper
.
cacheReaderItem
(
pageUrl
mId
mAppContext
)
;
}
else
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mDB
.
addBookmark
(
getContentResolver
(
)
mTitle
pageUrl
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
Tab
.
this
Tabs
.
TabEvents
.
BOOKMARK_ADDED
)
;
}
}
)
;
}
}
public
void
removeBookmark
(
)
{
final
String
url
=
getURL
(
)
;
if
(
url
=
=
null
)
{
return
;
}
final
String
pageUrl
=
ReaderModeUtils
.
stripAboutReaderUrl
(
getURL
(
)
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mDB
.
removeBookmarksWithURL
(
getContentResolver
(
)
pageUrl
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
Tab
.
this
Tabs
.
TabEvents
.
BOOKMARK_REMOVED
)
;
}
}
)
;
ReadingListHelper
.
removeCachedReaderItem
(
pageUrl
mAppContext
)
;
}
public
boolean
isEnteringReaderMode
(
)
{
return
mEnteringReaderMode
;
}
public
void
doReload
(
boolean
bypassCache
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putBoolean
(
"
bypassCache
"
bypassCache
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Session
:
Reload
"
data
)
;
}
public
boolean
canDoBack
(
)
{
return
mCanDoBack
;
}
public
boolean
doBack
(
)
{
if
(
!
canDoBack
(
)
)
return
false
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Session
:
Back
"
null
)
;
return
true
;
}
public
void
doStop
(
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Session
:
Stop
"
null
)
;
}
public
boolean
canDoForward
(
)
{
return
mCanDoForward
;
}
public
boolean
doForward
(
)
{
if
(
!
canDoForward
(
)
)
return
false
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Session
:
Forward
"
null
)
;
return
true
;
}
void
handleLocationChange
(
final
GeckoBundle
message
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
String
oldUrl
=
getURL
(
)
;
final
boolean
sameDocument
=
message
.
getBoolean
(
"
sameDocument
"
)
;
mEnteringReaderMode
=
ReaderModeUtils
.
isEnteringReaderMode
(
oldUrl
uri
)
;
handleButtonStateChange
(
message
)
;
if
(
!
TextUtils
.
equals
(
oldUrl
uri
)
)
{
updateURL
(
uri
)
;
updateBookmark
(
)
;
if
(
!
sameDocument
)
{
clearFavicon
(
)
;
mIconRequestBuilder
=
Icons
.
with
(
mAppContext
)
.
pageUrl
(
uri
)
;
if
(
AboutPages
.
isBuiltinIconPage
(
uri
)
)
{
loadFavicon
(
)
;
}
updateTitle
(
null
)
;
}
}
if
(
sameDocument
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
this
Tabs
.
TabEvents
.
LOCATION_CHANGE
oldUrl
)
;
return
;
}
setContentType
(
message
.
getString
(
"
contentType
"
)
)
;
updateUserRequested
(
message
.
getString
(
"
userRequested
"
)
)
;
mBaseDomain
=
message
.
getString
(
"
baseDomain
"
"
"
)
;
setHasFeeds
(
false
)
;
setManifestUrl
(
null
)
;
setHasOpenSearch
(
false
)
;
mSiteIdentity
.
reset
(
)
;
setSiteLogins
(
null
)
;
setHasTouchListeners
(
false
)
;
setErrorType
(
ErrorType
.
NONE
)
;
setLoadProgressIfLoading
(
LOAD_PROGRESS_LOCATION_CHANGE
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
this
Tabs
.
TabEvents
.
LOCATION_CHANGE
oldUrl
)
;
}
void
handleButtonStateChange
(
final
GeckoBundle
message
)
{
mCanDoBack
=
message
.
getBoolean
(
"
canGoBack
"
)
;
mCanDoForward
=
message
.
getBoolean
(
"
canGoForward
"
)
;
}
void
handleButtonStateChange
(
boolean
canGoBack
boolean
canGoForward
)
{
mCanDoBack
=
canGoBack
;
mCanDoForward
=
canGoForward
;
}
private
static
boolean
shouldShowProgress
(
final
String
url
)
{
return
!
AboutPages
.
isAboutPage
(
url
)
;
}
void
handleDocumentStart
(
boolean
restoring
String
url
)
{
setLoadProgress
(
LOAD_PROGRESS_START
)
;
setState
(
(
!
restoring
&
&
shouldShowProgress
(
url
)
)
?
STATE_LOADING
:
STATE_SUCCESS
)
;
mSiteIdentity
.
reset
(
)
;
}
void
handleDocumentStop
(
boolean
success
)
{
setState
(
success
?
STATE_SUCCESS
:
STATE_ERROR
)
;
final
String
oldURL
=
getURL
(
)
;
final
Tab
tab
=
this
;
tab
.
setLoadProgress
(
LOAD_PROGRESS_STOP
)
;
ThreadUtils
.
getBackgroundHandler
(
)
.
postDelayed
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
!
TextUtils
.
equals
(
oldURL
getURL
(
)
)
)
return
;
ThumbnailHelper
.
getInstance
(
)
.
getAndProcessThumbnailFor
(
tab
)
;
}
}
500
)
;
}
void
handleContentLoaded
(
)
{
setLoadProgressIfLoading
(
LOAD_PROGRESS_LOADED
)
;
}
protected
void
saveThumbnailToDB
(
final
BrowserDB
db
)
{
final
BitmapDrawable
thumbnail
=
mThumbnail
;
if
(
thumbnail
=
=
null
)
{
return
;
}
try
{
final
String
url
=
getURL
(
)
;
if
(
url
=
=
null
)
{
return
;
}
db
.
updateThumbnailForUrl
(
getContentResolver
(
)
url
thumbnail
)
;
}
catch
(
Exception
e
)
{
}
}
public
void
loadThumbnailFromDB
(
final
BrowserDB
db
)
{
try
{
final
String
url
=
getURL
(
)
;
if
(
url
=
=
null
)
{
return
;
}
byte
[
]
thumbnail
=
db
.
getThumbnailForUrl
(
getContentResolver
(
)
url
)
;
if
(
thumbnail
=
=
null
)
{
return
;
}
Bitmap
bitmap
=
BitmapUtils
.
decodeByteArray
(
thumbnail
)
;
mThumbnail
=
new
BitmapDrawable
(
mAppContext
.
getResources
(
)
bitmap
)
;
Tabs
.
getInstance
(
)
.
notifyListeners
(
Tab
.
this
Tabs
.
TabEvents
.
THUMBNAIL
)
;
}
catch
(
Exception
e
)
{
}
}
private
void
clearThumbnailFromDB
(
final
BrowserDB
db
)
{
try
{
final
String
url
=
getURL
(
)
;
if
(
url
=
=
null
)
{
return
;
}
db
.
updateThumbnailForUrl
(
getContentResolver
(
)
url
null
)
;
}
catch
(
Exception
e
)
{
}
}
public
void
addPluginView
(
View
view
)
{
mPluginViews
.
add
(
view
)
;
}
public
void
removePluginView
(
View
view
)
{
mPluginViews
.
remove
(
view
)
;
}
public
View
[
]
getPluginViews
(
)
{
return
mPluginViews
.
toArray
(
new
View
[
mPluginViews
.
size
(
)
]
)
;
}
public
void
setDesktopMode
(
boolean
enabled
)
{
mDesktopMode
=
enabled
;
}
public
boolean
getDesktopMode
(
)
{
return
mDesktopMode
;
}
public
boolean
isPrivate
(
)
{
return
false
;
}
public
TabType
getType
(
)
{
return
mType
;
}
public
enum
TabType
{
BROWSING
CUSTOMTAB
WEBAPP
}
public
boolean
matchesActivity
(
final
Activity
activity
)
{
final
String
activityName
=
activity
.
getClass
(
)
.
getName
(
)
;
return
activityName
.
equals
(
getTargetClassNameForTab
(
)
)
;
}
public
String
getTargetClassNameForTab
(
)
{
final
TabType
type
=
getType
(
)
;
switch
(
type
)
{
case
CUSTOMTAB
:
return
CustomTabsActivity
.
class
.
getName
(
)
;
case
WEBAPP
:
final
int
index
=
WebAppIndexer
.
getInstance
(
)
.
getIndexForManifest
(
getManifestPath
(
)
mAppContext
)
;
return
WebAppIndexer
.
WEBAPP_CLASS
+
index
;
default
:
return
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
;
}
}
void
setLoadProgress
(
int
progressPercentage
)
{
mLoadProgress
=
progressPercentage
;
}
void
setLoadProgressIfLoading
(
int
progressPercentage
)
{
if
(
getState
(
)
=
=
STATE_LOADING
)
{
setLoadProgress
(
progressPercentage
)
;
}
}
public
int
getLoadProgress
(
)
{
return
mLoadProgress
;
}
public
void
setRecording
(
boolean
isRecording
)
{
if
(
isRecording
)
{
mRecordingCount
+
+
;
}
else
{
mRecordingCount
-
-
;
}
}
public
boolean
isRecording
(
)
{
return
mRecordingCount
>
0
;
}
public
void
setIsMediaPlaying
(
boolean
isMediaPlaying
)
{
mIsMediaPlaying
=
isMediaPlaying
;
}
public
boolean
isMediaPlaying
(
)
{
return
mIsMediaPlaying
;
}
public
void
setIsAudioPlaying
(
boolean
isAudioPlaying
)
{
mIsAudioPlaying
=
isAudioPlaying
;
}
public
boolean
isAudioPlaying
(
)
{
return
mIsAudioPlaying
;
}
public
boolean
isEditing
(
)
{
return
mIsEditing
;
}
public
void
setIsEditing
(
final
boolean
isEditing
)
{
this
.
mIsEditing
=
isEditing
;
}
public
TabEditingState
getEditingState
(
)
{
return
mEditingState
;
}
public
void
setShouldShowToolbarWithoutAnimationOnFirstSelection
(
final
boolean
shouldShowWithoutAnimation
)
{
mShouldShowToolbarWithoutAnimationOnFirstSelection
=
shouldShowWithoutAnimation
;
}
public
boolean
getShouldShowToolbarWithoutAnimationOnFirstSelection
(
)
{
return
mShouldShowToolbarWithoutAnimationOnFirstSelection
;
}
}
