package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
AppConstants
.
Versions
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoMozillaDirectoryException
;
import
org
.
mozilla
.
gecko
.
GeckoScreenOrientation
.
ScreenOrientation
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
health
.
HealthRecorder
;
import
org
.
mozilla
.
gecko
.
health
.
SessionInformation
;
import
org
.
mozilla
.
gecko
.
health
.
StubbedHealthRecorder
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfig
.
PanelType
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenu
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenuInflater
;
import
org
.
mozilla
.
gecko
.
menu
.
MenuPanel
;
import
org
.
mozilla
.
gecko
.
mma
.
MmaDelegate
;
import
org
.
mozilla
.
gecko
.
notifications
.
NotificationHelper
;
import
org
.
mozilla
.
gecko
.
search
.
SearchWidgetProvider
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
org
.
mozilla
.
gecko
.
mozglue
.
SafeIntent
;
import
org
.
mozilla
.
gecko
.
mozglue
.
GeckoLoader
;
import
org
.
mozilla
.
gecko
.
permissions
.
Permissions
;
import
org
.
mozilla
.
gecko
.
preferences
.
ClearOnShutdownPref
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
prompts
.
PromptService
;
import
org
.
mozilla
.
gecko
.
restrictions
.
Restrictions
;
import
org
.
mozilla
.
gecko
.
tabqueue
.
TabQueueHelper
;
import
org
.
mozilla
.
gecko
.
text
.
TextSelection
;
import
org
.
mozilla
.
gecko
.
updater
.
UpdateServiceHelper
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
PrefUtils
;
import
org
.
mozilla
.
gecko
.
util
.
StrictModeContext
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ViewUtil
;
import
org
.
mozilla
.
gecko
.
widget
.
ActionModePresenter
;
import
org
.
mozilla
.
gecko
.
widget
.
AnchoredPopup
;
import
org
.
mozilla
.
geckoview
.
GeckoSession
;
import
org
.
mozilla
.
geckoview
.
GeckoSessionSettings
;
import
org
.
mozilla
.
geckoview
.
GeckoView
;
import
android
.
animation
.
Animator
;
import
android
.
animation
.
ObjectAnimator
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
app
.
AlertDialog
;
import
android
.
content
.
Context
;
import
android
.
content
.
DialogInterface
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
pm
.
ApplicationInfo
;
import
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
graphics
.
BitmapFactory
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Parcelable
;
import
android
.
os
.
StrictMode
;
import
android
.
provider
.
ContactsContract
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
support
.
design
.
widget
.
Snackbar
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
android
.
util
.
SparseBooleanArray
;
import
android
.
util
.
SparseIntArray
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
Menu
;
import
android
.
view
.
MenuInflater
;
import
android
.
view
.
MenuItem
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewTreeObserver
;
import
android
.
view
.
Window
;
import
android
.
widget
.
AdapterView
;
import
android
.
widget
.
Button
;
import
android
.
widget
.
ListView
;
import
android
.
widget
.
RelativeLayout
;
import
android
.
widget
.
SimpleAdapter
;
import
android
.
widget
.
TextView
;
import
android
.
widget
.
Toast
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
geckoview
.
GeckoViewBridge
;
import
org
.
mozilla
.
mozstumbler
.
service
.
mainthread
.
SafeReceiver
;
import
java
.
io
.
File
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
static
org
.
mozilla
.
gecko
.
Tabs
.
INTENT_EXTRA_SESSION_UUID
;
import
static
org
.
mozilla
.
gecko
.
Tabs
.
INTENT_EXTRA_TAB_ID
;
import
static
org
.
mozilla
.
gecko
.
Tabs
.
INVALID_TAB_ID
;
import
static
org
.
mozilla
.
gecko
.
mma
.
MmaDelegate
.
DOWNLOAD_MEDIA_SAVED_IMAGE
;
import
static
org
.
mozilla
.
gecko
.
mma
.
MmaDelegate
.
READER_AVAILABLE
;
import
static
org
.
mozilla
.
gecko
.
util
.
JavaUtil
.
getBundleSizeInBytes
;
public
abstract
class
GeckoApp
extends
GeckoActivity
implements
AnchoredPopup
.
OnVisibilityChangeListener
BundleEventListener
GeckoMenu
.
Callback
GeckoMenu
.
MenuPresenter
GeckoScreenOrientation
.
OrientationChangeListener
GeckoSession
.
ContentDelegate
ScreenOrientationDelegate
Tabs
.
OnTabsChangedListener
ViewTreeObserver
.
OnGlobalLayoutListener
{
private
static
final
String
LOGTAG
=
"
GeckoApp
"
;
private
static
final
long
ONE_DAY_MS
=
TimeUnit
.
MILLISECONDS
.
convert
(
1
TimeUnit
.
DAYS
)
;
public
static
final
String
ACTION_ALERT_CALLBACK
=
"
org
.
mozilla
.
gecko
.
ALERT_CALLBACK
"
;
public
static
final
String
ACTION_HOMESCREEN_SHORTCUT
=
"
org
.
mozilla
.
gecko
.
BOOKMARK
"
;
public
static
final
String
ACTION_WEBAPP
=
"
org
.
mozilla
.
gecko
.
WEBAPP
"
;
public
static
final
String
ACTION_LAUNCH_SETTINGS
=
"
org
.
mozilla
.
gecko
.
SETTINGS
"
;
public
static
final
String
ACTION_LOAD
=
"
org
.
mozilla
.
gecko
.
LOAD
"
;
public
static
final
String
ACTION_INIT_PW
=
"
org
.
mozilla
.
gecko
.
INIT_PW
"
;
public
static
final
String
ACTION_SWITCH_TAB
=
"
org
.
mozilla
.
gecko
.
SWITCH_TAB
"
;
public
static
final
String
ACTION_SHUTDOWN
=
"
org
.
mozilla
.
gecko
.
SHUTDOWN
"
;
public
static
final
String
INTENT_REGISTER_STUMBLER_LISTENER
=
"
org
.
mozilla
.
gecko
.
STUMBLER_REGISTER_LOCAL_LISTENER
"
;
private
static
final
String
GECKOVIEW_STATE_BUNDLE
=
"
geckoViewState
"
;
public
static
final
String
EXTRA_STATE_BUNDLE
=
"
stateBundle
"
;
public
static
final
String
PREFS_ALLOW_STATE_BUNDLE
=
"
allowStateBundle
"
;
public
static
final
String
PREFS_FLASH_USAGE
=
"
playFlashCount
"
;
public
static
final
String
PREFS_VERSION_CODE
=
"
versionCode
"
;
public
static
final
String
PREFS_WAS_STOPPED
=
"
wasStopped
"
;
public
static
final
String
PREFS_CRASHED_COUNT
=
"
crashedCount
"
;
public
static
final
String
PREFS_CLEANUP_TEMP_FILES
=
"
cleanupTempFiles
"
;
public
static
final
String
PREFS_IS_FIRST_RUN
=
"
telemetry
-
isFirstRun
"
;
public
static
final
String
SAVED_STATE_IN_BACKGROUND
=
"
inBackground
"
;
public
static
final
String
SAVED_STATE_PRIVATE_SESSION
=
"
privateSession
"
;
protected
static
final
int
MAX_BUNDLE_SIZE_BYTES
=
300_000
;
private
static
final
int
CLEANUP_DEFERRAL_SECONDS
=
15
;
private
static
final
int
STARTUP_PHASE_DURATION_MS
=
30
*
1000
;
private
static
boolean
sAlreadyLoaded
;
protected
RelativeLayout
mRootLayout
;
protected
RelativeLayout
mMainLayout
;
protected
RelativeLayout
mGeckoLayout
;
protected
MenuPanel
mMenuPanel
;
protected
Menu
mMenu
;
protected
boolean
mIsRestoringActivity
;
protected
boolean
mIsAbortingAppLaunch
;
protected
boolean
mDumpProfileOnShutdown
;
private
PromptService
mPromptService
;
protected
TextSelection
mTextSelection
;
protected
DoorHangerPopup
mDoorHangerPopup
;
protected
FormAssistPopup
mFormAssistPopup
;
protected
GeckoView
mLayerView
;
protected
boolean
mLastSessionCrashed
;
protected
boolean
mShouldRestore
;
private
boolean
mSessionRestoreParsingFinished
=
false
;
private
boolean
foregrounded
=
false
;
private
static
final
class
LastSessionParser
extends
SessionParser
{
private
JSONArray
tabs
;
private
JSONObject
windowObject
;
private
boolean
loadingExternalURL
;
private
boolean
selectNextTab
;
private
boolean
tabsWereSkipped
;
private
boolean
tabsWereProcessed
;
private
SparseIntArray
tabIdMap
;
public
LastSessionParser
(
JSONArray
tabs
JSONObject
windowObject
boolean
loadingExternalURL
)
{
this
.
tabs
=
tabs
;
this
.
windowObject
=
windowObject
;
this
.
loadingExternalURL
=
loadingExternalURL
;
tabIdMap
=
new
SparseIntArray
(
)
;
}
public
boolean
allTabsSkipped
(
)
{
return
tabsWereSkipped
&
&
!
tabsWereProcessed
;
}
public
int
getNewTabId
(
int
oldTabId
)
{
return
tabIdMap
.
get
(
oldTabId
INVALID_TAB_ID
)
;
}
Override
public
void
onTabRead
(
final
SessionTab
sessionTab
)
{
if
(
sessionTab
.
isAboutHomeWithoutHistory
(
)
)
{
if
(
!
loadingExternalURL
&
&
sessionTab
.
isSelected
(
)
)
{
if
(
!
Tabs
.
getInstance
(
)
.
selectLastTab
(
)
)
{
selectNextTab
=
true
;
}
}
tabsWereSkipped
=
true
;
return
;
}
tabsWereProcessed
=
true
;
JSONObject
tabObject
=
sessionTab
.
getTabObject
(
)
;
int
flags
=
Tabs
.
LOADURL_NEW_TAB
;
flags
|
=
(
(
loadingExternalURL
|
|
!
sessionTab
.
isSelected
(
)
)
?
Tabs
.
LOADURL_DELAY_LOAD
:
0
)
;
flags
|
=
(
tabObject
.
optBoolean
(
"
desktopMode
"
)
?
Tabs
.
LOADURL_DESKTOP
:
0
)
;
flags
|
=
(
tabObject
.
optBoolean
(
"
isPrivate
"
)
?
Tabs
.
LOADURL_PRIVATE
:
0
)
;
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
loadUrl
(
sessionTab
.
getUrl
(
)
flags
)
;
if
(
selectNextTab
)
{
Tabs
.
getInstance
(
)
.
selectTab
(
tab
.
getId
(
)
)
;
selectNextTab
=
false
;
}
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
tab
.
updateTitle
(
sessionTab
.
getTitle
(
)
)
;
}
}
)
;
try
{
int
oldTabId
=
tabObject
.
optInt
(
"
tabId
"
INVALID_TAB_ID
)
;
int
newTabId
=
tab
.
getId
(
)
;
tabObject
.
put
(
"
tabId
"
newTabId
)
;
if
(
oldTabId
>
=
0
)
{
tabIdMap
.
put
(
oldTabId
newTabId
)
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
JSON
error
"
e
)
;
}
tabs
.
put
(
tabObject
)
;
}
Override
public
void
onClosedTabsRead
(
final
JSONArray
closedTabData
)
throws
JSONException
{
int
closedTabId
=
Tabs
.
INVALID_TAB_ID
;
for
(
int
i
=
0
;
i
<
closedTabData
.
length
(
)
;
i
+
+
)
{
final
JSONObject
closedTab
=
closedTabData
.
getJSONObject
(
i
)
;
closedTab
.
put
(
"
tabId
"
-
-
closedTabId
)
;
}
windowObject
.
put
(
"
closedTabs
"
closedTabData
)
;
}
public
void
updateParentId
(
final
JSONArray
tabData
)
{
if
(
tabData
=
=
null
)
{
return
;
}
for
(
int
i
=
0
;
i
<
tabData
.
length
(
)
;
i
+
+
)
{
try
{
JSONObject
tabObject
=
tabData
.
getJSONObject
(
i
)
;
int
parentId
=
tabObject
.
getInt
(
"
parentId
"
)
;
int
newParentId
=
getNewTabId
(
parentId
)
;
tabObject
.
put
(
"
parentId
"
newParentId
)
;
}
catch
(
JSONException
ex
)
{
}
}
}
}
;
protected
boolean
mInitialized
;
protected
boolean
mWindowFocusInitialized
;
private
TelemetryUtils
.
Timer
mJavaUiStartupTimer
;
private
TelemetryUtils
.
Timer
mGeckoReadyStartupTimer
;
private
String
mPrivateBrowsingSession
;
private
boolean
mPrivateBrowsingSessionOutdated
;
private
static
final
int
MAX_PRIVATE_TABS_UPDATE_WAIT_MSEC
=
500
;
private
volatile
HealthRecorder
mHealthRecorder
;
private
volatile
Locale
mLastLocale
;
private
boolean
mShutdownOnDestroy
;
private
boolean
mRestartOnShutdown
;
private
boolean
mWasFirstTabShownAfterActivityUnhidden
;
private
boolean
mIsFullscreen
;
abstract
public
int
getLayout
(
)
;
abstract
public
View
getDoorhangerOverlay
(
)
;
protected
void
processTabQueue
(
)
{
}
;
protected
void
openQueuedTabs
(
)
{
}
;
SuppressWarnings
(
"
serial
"
)
static
final
class
SessionRestoreException
extends
Exception
{
public
SessionRestoreException
(
Exception
e
)
{
super
(
e
)
;
}
public
SessionRestoreException
(
String
message
)
{
super
(
message
)
;
}
}
void
toggleChrome
(
final
boolean
aShow
)
{
}
void
focusChrome
(
)
{
}
public
SharedPreferences
getSharedPreferences
(
)
{
return
GeckoSharedPrefs
.
forApp
(
this
)
;
}
public
SharedPreferences
getSharedPreferencesForProfile
(
)
{
return
GeckoSharedPrefs
.
forProfile
(
this
)
;
}
Override
public
void
onTabChanged
(
Tab
tab
Tabs
.
TabEvents
msg
String
data
)
{
switch
(
msg
)
{
case
UNSELECTED
:
break
;
case
LOCATION_CHANGE
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
resetOptionsMenu
(
)
;
resetFormAssistPopup
(
)
;
}
break
;
case
SELECTED
:
resetOptionsMenu
(
)
;
resetFormAssistPopup
(
)
;
break
;
case
DESKTOP_MODE_CHANGE
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
resetOptionsMenu
(
)
;
break
;
}
}
private
void
resetOptionsMenu
(
)
{
if
(
mInitialized
)
{
invalidateOptionsMenu
(
)
;
}
}
private
void
resetFormAssistPopup
(
)
{
if
(
mInitialized
&
&
mFormAssistPopup
!
=
null
)
{
mFormAssistPopup
.
hide
(
)
;
}
}
protected
boolean
saveAsLastSelectedTab
(
Tab
tab
)
{
return
false
;
}
public
void
refreshChrome
(
)
{
}
public
void
invalidateOptionsMenu
(
)
{
if
(
mMenu
=
=
null
)
{
return
;
}
onPrepareOptionsMenu
(
mMenu
)
;
super
.
invalidateOptionsMenu
(
)
;
}
Override
public
boolean
onCreateOptionsMenu
(
Menu
menu
)
{
mMenu
=
menu
;
MenuInflater
inflater
=
getMenuInflater
(
)
;
inflater
.
inflate
(
R
.
menu
.
gecko_app_menu
mMenu
)
;
return
true
;
}
Override
public
MenuInflater
getMenuInflater
(
)
{
return
new
GeckoMenuInflater
(
this
)
;
}
public
MenuPanel
getMenuPanel
(
)
{
if
(
mMenuPanel
=
=
null
|
|
mMenu
=
=
null
)
{
onCreatePanelMenu
(
Window
.
FEATURE_OPTIONS_PANEL
null
)
;
invalidateOptionsMenu
(
)
;
}
return
mMenuPanel
;
}
Override
public
boolean
onMenuItemClick
(
MenuItem
item
)
{
return
onOptionsItemSelected
(
item
)
;
}
Override
public
boolean
onMenuItemLongClick
(
MenuItem
item
)
{
return
false
;
}
Override
public
void
openMenu
(
)
{
openOptionsMenu
(
)
;
}
Override
public
void
showMenu
(
final
View
menu
)
{
closeMenu
(
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mMenuPanel
.
removeAllViews
(
)
;
mMenuPanel
.
addView
(
menu
)
;
openOptionsMenu
(
)
;
}
}
)
;
}
Override
public
void
closeMenu
(
)
{
closeOptionsMenu
(
)
;
}
Override
public
View
onCreatePanelView
(
int
featureId
)
{
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
if
(
mMenuPanel
=
=
null
)
{
mMenuPanel
=
new
MenuPanel
(
this
null
)
;
}
else
{
onPreparePanel
(
featureId
mMenuPanel
mMenu
)
;
}
return
mMenuPanel
;
}
return
super
.
onCreatePanelView
(
featureId
)
;
}
Override
public
boolean
onCreatePanelMenu
(
int
featureId
Menu
menu
)
{
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
if
(
mMenuPanel
=
=
null
)
{
mMenuPanel
=
(
MenuPanel
)
onCreatePanelView
(
featureId
)
;
}
GeckoMenu
gMenu
=
new
GeckoMenu
(
this
null
)
;
gMenu
.
setCallback
(
this
)
;
gMenu
.
setMenuPresenter
(
this
)
;
menu
=
gMenu
;
mMenuPanel
.
addView
(
gMenu
)
;
return
onCreateOptionsMenu
(
menu
)
;
}
return
super
.
onCreatePanelMenu
(
featureId
menu
)
;
}
Override
public
boolean
onPreparePanel
(
int
featureId
View
view
Menu
menu
)
{
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
return
onPrepareOptionsMenu
(
menu
)
;
}
return
super
.
onPreparePanel
(
featureId
view
menu
)
;
}
Override
public
boolean
onMenuOpened
(
int
featureId
Menu
menu
)
{
if
(
mIsFullscreen
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
FullScreen
:
Exit
"
null
)
;
}
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
if
(
mMenu
=
=
null
)
{
MenuPanel
panel
=
getMenuPanel
(
)
;
onPreparePanel
(
featureId
panel
mMenu
)
;
}
if
(
mMenuPanel
!
=
null
)
mMenuPanel
.
scrollTo
(
0
0
)
;
return
true
;
}
return
super
.
onMenuOpened
(
featureId
menu
)
;
}
Override
public
boolean
onOptionsItemSelected
(
MenuItem
item
)
{
if
(
item
.
getItemId
(
)
=
=
R
.
id
.
quit
)
{
GuestSession
.
hideNotification
(
this
)
;
final
SharedPreferences
prefs
=
getSharedPreferencesForProfile
(
)
;
final
Set
<
String
>
clearSet
=
PrefUtils
.
getStringSet
(
prefs
ClearOnShutdownPref
.
PREF
new
HashSet
<
String
>
(
)
)
;
final
GeckoBundle
clearObj
=
new
GeckoBundle
(
clearSet
.
size
(
)
)
;
for
(
final
String
clear
:
clearSet
)
{
clearObj
.
putBoolean
(
clear
true
)
;
}
final
GeckoBundle
res
=
new
GeckoBundle
(
2
)
;
res
.
putBundle
(
"
sanitize
"
clearObj
)
;
if
(
clearObj
.
containsKey
(
"
private
.
data
.
openTabs
"
)
)
{
res
.
putBoolean
(
"
dontSaveSession
"
true
)
;
}
else
if
(
clearObj
.
containsKey
(
"
private
.
data
.
history
"
)
)
{
final
String
sessionRestore
=
getSessionRestorePreference
(
getSharedPreferences
(
)
)
;
res
.
putBoolean
(
"
dontSaveSession
"
"
quit
"
.
equals
(
sessionRestore
)
)
;
}
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Browser
:
Quit
"
res
)
;
return
true
;
}
return
super
.
onOptionsItemSelected
(
item
)
;
}
Override
public
void
onOptionsMenuClosed
(
Menu
menu
)
{
mMenuPanel
.
removeAllViews
(
)
;
mMenuPanel
.
addView
(
(
GeckoMenu
)
mMenu
)
;
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_MENU
)
{
openOptionsMenu
(
)
;
return
true
;
}
return
super
.
onKeyDown
(
keyCode
event
)
;
}
Override
protected
void
onSaveInstanceState
(
Bundle
outState
)
{
synchronized
(
this
)
{
mPrivateBrowsingSessionOutdated
=
true
;
}
super
.
onSaveInstanceState
(
outState
)
;
if
(
!
isApplicationInBackground
(
)
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Session
:
FlushTabs
"
null
)
;
}
synchronized
(
this
)
{
if
(
GeckoThread
.
isRunning
(
)
&
&
mPrivateBrowsingSessionOutdated
)
{
try
{
wait
(
MAX_PRIVATE_TABS_UPDATE_WAIT_MSEC
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
outState
.
putString
(
SAVED_STATE_PRIVATE_SESSION
mPrivateBrowsingSession
)
;
if
(
getBundleSizeInBytes
(
outState
)
>
MAX_BUNDLE_SIZE_BYTES
)
{
outState
.
remove
(
SAVED_STATE_PRIVATE_SESSION
)
;
}
}
outState
.
putBoolean
(
SAVED_STATE_IN_BACKGROUND
isApplicationInBackground
(
)
)
;
SparseArray
<
Parcelable
>
geckoViewState
=
new
SparseArray
<
>
(
)
;
mLayerView
.
saveHierarchyState
(
geckoViewState
)
;
outState
.
putSparseParcelableArray
(
GECKOVIEW_STATE_BUNDLE
geckoViewState
)
;
getGeckoApplication
(
)
.
setSavedState
(
geckoViewState
)
;
}
public
void
addTab
(
int
flags
)
{
}
public
void
addTab
(
)
{
}
public
void
addPrivateTab
(
)
{
}
public
void
showNormalTabs
(
)
{
}
public
void
showPrivateTabs
(
)
{
}
public
void
hideTabs
(
)
{
}
public
boolean
autoHideTabs
(
)
{
return
false
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
event
.
equals
(
"
Gecko
:
Ready
"
)
)
{
mGeckoReadyStartupTimer
.
stop
(
)
;
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
recordGeckoStartupTime
(
mGeckoReadyStartupTimer
.
getElapsed
(
)
)
;
}
getGeckoApplication
(
)
.
onDelayedStartup
(
)
;
ThreadUtils
.
postDelayedToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
getSharedPreferences
(
)
.
edit
(
)
.
putInt
(
PREFS_CRASHED_COUNT
0
)
.
apply
(
)
;
}
}
STARTUP_PHASE_DURATION_MS
)
;
}
else
if
(
event
.
equals
(
"
Gecko
:
CorruptAPK
"
)
)
{
showCorruptAPKError
(
)
;
if
(
!
isFinishing
(
)
)
{
finish
(
)
;
}
}
else
if
(
"
Contact
:
Add
"
.
equals
(
event
)
)
{
final
String
email
=
message
.
getString
(
"
email
"
)
;
final
String
phone
=
message
.
getString
(
"
phone
"
)
;
if
(
email
!
=
null
)
{
Uri
contactUri
=
Uri
.
parse
(
email
)
;
Intent
i
=
new
Intent
(
ContactsContract
.
Intents
.
SHOW_OR_CREATE_CONTACT
contactUri
)
;
startActivity
(
i
)
;
}
else
if
(
phone
!
=
null
)
{
Uri
contactUri
=
Uri
.
parse
(
phone
)
;
Intent
i
=
new
Intent
(
ContactsContract
.
Intents
.
SHOW_OR_CREATE_CONTACT
contactUri
)
;
startActivity
(
i
)
;
}
else
{
Log
.
e
(
LOGTAG
"
Received
Contact
:
Add
message
with
no
email
nor
phone
number
"
)
;
}
}
else
if
(
"
DevToolsAuth
:
Scan
"
.
equals
(
event
)
)
{
DevToolsAuthHelper
.
scan
(
this
callback
)
;
}
else
if
(
"
DOMFullScreen
:
Start
"
.
equals
(
event
)
)
{
mIsFullscreen
=
true
;
}
else
if
(
"
DOMFullScreen
:
Stop
"
.
equals
(
event
)
)
{
mIsFullscreen
=
false
;
}
else
if
(
"
Locale
:
Set
"
.
equals
(
event
)
)
{
setLocale
(
message
.
getString
(
"
locale
"
)
)
;
}
else
if
(
"
Permissions
:
Data
"
.
equals
(
event
)
)
{
final
GeckoBundle
[
]
permissions
=
message
.
getBundleArray
(
"
permissions
"
)
;
showSiteSettingsDialog
(
permissions
)
;
}
else
if
(
"
PrivateBrowsing
:
Data
"
.
equals
(
event
)
)
{
synchronized
(
this
)
{
if
(
!
message
.
getBoolean
(
"
noChange
"
false
)
)
{
mPrivateBrowsingSession
=
message
.
getString
(
"
session
"
)
;
}
mPrivateBrowsingSessionOutdated
=
false
;
notifyAll
(
)
;
}
}
else
if
(
"
SystemUI
:
Visibility
"
.
equals
(
event
)
)
{
if
(
message
.
getBoolean
(
"
visible
"
true
)
)
{
mMainLayout
.
setSystemUiVisibility
(
View
.
SYSTEM_UI_FLAG_VISIBLE
)
;
}
else
{
mMainLayout
.
setSystemUiVisibility
(
View
.
SYSTEM_UI_FLAG_LOW_PROFILE
)
;
}
}
else
if
(
"
ToggleChrome
:
Focus
"
.
equals
(
event
)
)
{
focusChrome
(
)
;
}
else
if
(
"
ToggleChrome
:
Hide
"
.
equals
(
event
)
)
{
toggleChrome
(
false
)
;
}
else
if
(
"
ToggleChrome
:
Show
"
.
equals
(
event
)
)
{
toggleChrome
(
true
)
;
}
else
if
(
"
Update
:
Check
"
.
equals
(
event
)
)
{
UpdateServiceHelper
.
checkForUpdate
(
this
)
;
}
else
if
(
"
Update
:
Download
"
.
equals
(
event
)
)
{
UpdateServiceHelper
.
downloadUpdate
(
this
)
;
}
else
if
(
"
Update
:
Install
"
.
equals
(
event
)
)
{
UpdateServiceHelper
.
applyUpdate
(
this
)
;
}
else
if
(
"
Mma
:
reader_available
"
.
equals
(
event
)
)
{
MmaDelegate
.
track
(
READER_AVAILABLE
)
;
}
else
if
(
"
Mma
:
web_save_media
"
.
equals
(
event
)
|
|
"
Mma
:
web_save_image
"
.
equals
(
event
)
)
{
MmaDelegate
.
track
(
DOWNLOAD_MEDIA_SAVED_IMAGE
)
;
}
}
protected
ActionModePresenter
getTextSelectPresenter
(
)
{
return
null
;
}
private
void
showSiteSettingsDialog
(
final
GeckoBundle
[
]
permissions
)
{
final
AlertDialog
.
Builder
builder
=
new
AlertDialog
.
Builder
(
this
)
;
builder
.
setTitle
(
R
.
string
.
site_settings_title
)
;
final
ArrayList
<
HashMap
<
String
String
>
>
itemList
=
new
ArrayList
<
HashMap
<
String
String
>
>
(
)
;
for
(
final
GeckoBundle
permObj
:
permissions
)
{
final
HashMap
<
String
String
>
map
=
new
HashMap
<
String
String
>
(
)
;
map
.
put
(
"
setting
"
permObj
.
getString
(
"
setting
"
)
)
;
map
.
put
(
"
value
"
permObj
.
getString
(
"
value
"
)
)
;
itemList
.
add
(
map
)
;
}
builder
.
setSingleChoiceItems
(
new
SimpleAdapter
(
GeckoApp
.
this
itemList
R
.
layout
.
site_setting_item
new
String
[
]
{
"
setting
"
"
value
"
}
new
int
[
]
{
R
.
id
.
setting
R
.
id
.
value
}
)
-
1
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
id
)
{
}
}
)
;
builder
.
setPositiveButton
(
R
.
string
.
site_settings_clear
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
id
)
{
ListView
listView
=
(
(
AlertDialog
)
dialog
)
.
getListView
(
)
;
SparseBooleanArray
checkedItemPositions
=
listView
.
getCheckedItemPositions
(
)
;
final
ArrayList
<
Integer
>
permissionsToClear
=
new
ArrayList
<
>
(
)
;
for
(
int
i
=
0
;
i
<
checkedItemPositions
.
size
(
)
;
i
+
+
)
{
if
(
checkedItemPositions
.
valueAt
(
i
)
)
{
permissionsToClear
.
add
(
checkedItemPositions
.
keyAt
(
i
)
)
;
}
}
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putIntArray
(
"
permissions
"
permissionsToClear
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Permissions
:
Clear
"
data
)
;
}
}
)
;
builder
.
setNegativeButton
(
R
.
string
.
site_settings_cancel
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
id
)
{
dialog
.
cancel
(
)
;
}
}
)
;
AlertDialog
dialog
=
builder
.
create
(
)
;
dialog
.
show
(
)
;
final
ListView
listView
=
dialog
.
getListView
(
)
;
if
(
listView
!
=
null
)
{
listView
.
setChoiceMode
(
ListView
.
CHOICE_MODE_MULTIPLE
)
;
}
final
Button
clearButton
=
dialog
.
getButton
(
DialogInterface
.
BUTTON_POSITIVE
)
;
clearButton
.
setEnabled
(
false
)
;
dialog
.
getListView
(
)
.
setOnItemClickListener
(
new
AdapterView
.
OnItemClickListener
(
)
{
Override
public
void
onItemClick
(
AdapterView
<
?
>
adapterView
View
view
int
i
long
l
)
{
if
(
listView
.
getCheckedItemCount
(
)
=
=
0
)
{
clearButton
.
setEnabled
(
false
)
;
}
else
{
clearButton
.
setEnabled
(
true
)
;
}
}
}
)
;
}
private
int
getBitmapSampleSize
(
BitmapFactory
.
Options
options
int
idealWidth
int
idealHeight
)
{
int
width
=
options
.
outWidth
;
int
height
=
options
.
outHeight
;
int
inSampleSize
=
1
;
if
(
height
>
idealHeight
|
|
width
>
idealWidth
)
{
if
(
width
>
height
)
{
inSampleSize
=
Math
.
round
(
(
float
)
height
/
idealHeight
)
;
}
else
{
inSampleSize
=
Math
.
round
(
(
float
)
width
/
idealWidth
)
;
}
}
return
inSampleSize
;
}
Override
public
void
onTitleChange
(
final
GeckoSession
session
final
String
title
)
{
}
Override
public
void
onFocusRequest
(
final
GeckoSession
session
)
{
}
Override
public
void
onCloseRequest
(
final
GeckoSession
session
)
{
}
Override
public
void
onFullScreen
(
final
GeckoSession
session
final
boolean
fullScreen
)
{
if
(
fullScreen
)
{
SnackbarBuilder
.
builder
(
this
)
.
message
(
R
.
string
.
fullscreen_warning
)
.
duration
(
Snackbar
.
LENGTH_LONG
)
.
buildAndShow
(
)
;
}
ThreadUtils
.
assertOnUiThread
(
)
;
ActivityUtils
.
setFullScreen
(
this
fullScreen
)
;
}
Override
public
void
onContextMenu
(
final
GeckoSession
session
final
int
screenX
final
int
screenY
final
GeckoSession
.
ContentDelegate
.
ContextElement
element
)
{
}
Override
public
void
onExternalResponse
(
final
GeckoSession
session
final
GeckoSession
.
WebResponseInfo
request
)
{
}
Override
public
void
onCrash
(
final
GeckoSession
session
)
{
}
Override
public
void
onFirstComposite
(
final
GeckoSession
session
)
{
}
protected
void
setFullScreen
(
final
boolean
fullscreen
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
onFullScreen
(
mLayerView
.
getSession
(
)
fullscreen
)
;
}
}
)
;
}
protected
void
handleGeckoProfilerOptions
(
SafeIntent
intent
)
{
String
env
=
intent
.
getStringExtra
(
"
env0
"
)
;
for
(
int
i
=
1
;
env
!
=
null
;
i
+
+
)
{
if
(
env
.
startsWith
(
"
MOZ_PROFILER_STARTUP
=
"
)
)
{
if
(
!
env
.
endsWith
(
"
=
"
)
)
{
GeckoJavaSampler
.
start
(
10
1000
)
;
Log
.
d
(
LOGTAG
"
Profiling
Java
on
startup
"
)
;
}
}
else
if
(
env
.
startsWith
(
"
MOZ_PROFILER_SHUTDOWN
=
"
)
)
{
if
(
!
env
.
endsWith
(
"
=
"
)
)
{
mDumpProfileOnShutdown
=
true
;
}
}
env
=
intent
.
getStringExtra
(
"
env
"
+
i
)
;
}
}
Override
public
void
onCreate
(
Bundle
savedInstanceState
)
{
final
boolean
receivedSavedInstanceState
=
(
savedInstanceState
!
=
null
)
;
if
(
"
default
"
.
equals
(
AppConstants
.
MOZ_UPDATE_CHANNEL
)
)
{
enableStrictMode
(
)
;
}
final
boolean
corruptAPK
=
GeckoThread
.
isState
(
GeckoThread
.
State
.
CORRUPT_APK
)
;
boolean
supported
=
HardwareUtils
.
isSupportedSystem
(
)
;
if
(
supported
)
{
GeckoLoader
.
loadMozGlue
(
getApplicationContext
(
)
)
;
supported
=
GeckoLoader
.
neonCompatible
(
)
;
}
if
(
corruptAPK
|
|
!
supported
)
{
mIsAbortingAppLaunch
=
true
;
super
.
onCreate
(
savedInstanceState
)
;
if
(
corruptAPK
)
{
showCorruptAPKError
(
)
;
}
else
{
showSDKVersionError
(
)
;
}
finish
(
)
;
return
;
}
mJavaUiStartupTimer
=
new
TelemetryUtils
.
UptimeTimer
(
"
FENNEC_STARTUP_TIME_JAVAUI
"
)
;
mGeckoReadyStartupTimer
=
new
TelemetryUtils
.
UptimeTimer
(
"
FENNEC_STARTUP_TIME_GECKOREADY
"
)
;
final
SafeIntent
intent
=
new
SafeIntent
(
getIntent
(
)
)
;
handleGeckoProfilerOptions
(
intent
)
;
try
{
Class
.
forName
(
"
android
.
os
.
AsyncTask
"
)
;
}
catch
(
ClassNotFoundException
e
)
{
}
GeckoAppShell
.
setScreenOrientationDelegate
(
this
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
addListener
(
this
)
;
final
Intent
stumblerIntent
=
new
Intent
(
getApplicationContext
(
)
SafeReceiver
.
class
)
;
stumblerIntent
.
setAction
(
INTENT_REGISTER_STUMBLER_LISTENER
)
;
getApplicationContext
(
)
.
sendBroadcast
(
stumblerIntent
)
;
if
(
BrowserLocaleManager
.
getInstance
(
)
.
systemLocaleDidChange
(
)
)
{
Log
.
i
(
LOGTAG
"
System
locale
changed
.
Restarting
.
"
)
;
finishAndShutdown
(
true
)
;
return
;
}
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
this
"
Gecko
:
Ready
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
Gecko
:
CorruptAPK
"
"
Update
:
Check
"
"
Update
:
Download
"
"
Update
:
Install
"
null
)
;
if
(
sAlreadyLoaded
)
{
mIsRestoringActivity
=
true
;
Telemetry
.
addToHistogram
(
"
FENNEC_RESTORING_ACTIVITY
"
1
)
;
}
else
{
final
String
action
=
intent
.
getAction
(
)
;
final
String
[
]
args
=
GeckoApplication
.
getDefaultGeckoArgs
(
)
;
sAlreadyLoaded
=
true
;
if
(
GeckoApplication
.
getRuntime
(
)
=
=
null
)
{
GeckoApplication
.
createRuntime
(
this
intent
)
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
getProfile
(
)
;
}
}
)
;
final
String
uri
=
getURIFromIntent
(
intent
)
;
if
(
!
TextUtils
.
isEmpty
(
uri
)
)
{
GeckoThread
.
speculativeConnect
(
uri
)
;
}
}
Bundle
stateBundle
=
IntentUtils
.
getBundleExtraSafe
(
getIntent
(
)
EXTRA_STATE_BUNDLE
)
;
if
(
stateBundle
!
=
null
)
{
final
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
if
(
prefs
.
getBoolean
(
PREFS_ALLOW_STATE_BUNDLE
false
)
)
{
prefs
.
edit
(
)
.
remove
(
PREFS_ALLOW_STATE_BUNDLE
)
.
apply
(
)
;
savedInstanceState
=
stateBundle
;
}
}
else
if
(
savedInstanceState
!
=
null
)
{
setIntent
(
new
Intent
(
Intent
.
ACTION_MAIN
)
)
;
}
super
.
onCreate
(
savedInstanceState
)
;
setContentView
(
getLayout
(
)
)
;
mRootLayout
=
(
RelativeLayout
)
findViewById
(
R
.
id
.
root_layout
)
;
mGeckoLayout
=
(
RelativeLayout
)
findViewById
(
R
.
id
.
gecko_layout
)
;
mMainLayout
=
(
RelativeLayout
)
findViewById
(
R
.
id
.
main_layout
)
;
mLayerView
=
(
GeckoView
)
findViewById
(
R
.
id
.
layer_view
)
;
mLayerView
.
setSaveFromParentEnabled
(
false
)
;
final
GeckoSession
session
=
new
GeckoSession
(
new
GeckoSessionSettings
.
Builder
(
)
.
chromeUri
(
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
)
.
build
(
)
)
;
session
.
setContentDelegate
(
this
)
;
if
(
mLayerView
.
getSession
(
)
!
=
null
)
{
mLayerView
.
getSession
(
)
.
close
(
)
;
}
mLayerView
.
setSession
(
session
GeckoApplication
.
getRuntime
(
)
)
;
mLayerView
.
setOverScrollMode
(
View
.
OVER_SCROLL_NEVER
)
;
if
(
mIsRestoringActivity
&
&
!
receivedSavedInstanceState
)
{
restoreGeckoViewState
(
getGeckoApplication
(
)
.
getSavedState
(
)
)
;
}
getAppEventDispatcher
(
)
.
registerGeckoThreadListener
(
this
"
Locale
:
Set
"
"
PrivateBrowsing
:
Data
"
null
)
;
getAppEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
Contact
:
Add
"
"
DevToolsAuth
:
Scan
"
"
DOMFullScreen
:
Start
"
"
DOMFullScreen
:
Stop
"
"
Mma
:
reader_available
"
"
Mma
:
web_save_image
"
"
Mma
:
web_save_media
"
"
Permissions
:
Data
"
"
SystemUI
:
Visibility
"
"
ToggleChrome
:
Focus
"
"
ToggleChrome
:
Hide
"
"
ToggleChrome
:
Show
"
null
)
;
Tabs
.
getInstance
(
)
.
attachToContext
(
this
mLayerView
getAppEventDispatcher
(
)
)
;
Tabs
.
registerOnTabsChangedListener
(
this
)
;
mMainLayout
.
getViewTreeObserver
(
)
.
addOnGlobalLayoutListener
(
this
)
;
mTextSelection
=
TextSelection
.
Factory
.
create
(
mLayerView
getTextSelectPresenter
(
)
)
;
mTextSelection
.
create
(
)
;
final
Bundle
finalSavedInstanceState
=
savedInstanceState
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mLastSessionCrashed
=
updateCrashedState
(
)
;
mShouldRestore
=
getSessionRestoreState
(
finalSavedInstanceState
)
;
if
(
mShouldRestore
&
&
finalSavedInstanceState
!
=
null
)
{
boolean
wasInBackground
=
finalSavedInstanceState
.
getBoolean
(
SAVED_STATE_IN_BACKGROUND
false
)
;
if
(
!
wasInBackground
&
&
!
mIsRestoringActivity
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_WAS_KILLED
"
1
)
;
}
mPrivateBrowsingSession
=
finalSavedInstanceState
.
getString
(
SAVED_STATE_PRIVATE_SESSION
)
;
}
GeckoBundle
restoreMessage
=
null
;
if
(
!
mIsRestoringActivity
&
&
mShouldRestore
)
{
final
boolean
isExternalURL
=
invokedWithExternalURL
(
getIntentURI
(
new
SafeIntent
(
getIntent
(
)
)
)
)
;
try
{
restoreMessage
=
restoreSessionTabs
(
isExternalURL
false
)
;
}
catch
(
SessionRestoreException
|
OutOfMemoryError
e
)
{
if
(
mShouldRestore
)
{
Log
.
e
(
LOGTAG
"
An
error
occurred
during
restore
switching
to
backup
file
"
e
)
;
if
(
getProfile
(
)
.
sessionFileExists
(
)
&
&
!
(
e
instanceof
OutOfMemoryError
)
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_DAMAGED_SESSION_FILE
"
1
)
;
}
try
{
restoreMessage
=
restoreSessionTabs
(
isExternalURL
true
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_RESTORING_FROM_BACKUP
"
1
)
;
}
catch
(
SessionRestoreException
|
OutOfMemoryError
ex
)
{
if
(
!
mShouldRestore
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_RESTORING_FROM_BACKUP
"
1
)
;
}
else
{
Log
.
e
(
LOGTAG
"
An
error
occurred
during
restore
"
ex
)
;
mShouldRestore
=
false
;
if
(
!
getSharedPreferencesForProfile
(
)
.
getBoolean
(
PREFS_IS_FIRST_RUN
true
)
&
&
!
(
ex
instanceof
OutOfMemoryError
)
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_ALL_FILES_DAMAGED
"
1
)
;
}
}
}
}
}
}
synchronized
(
GeckoApp
.
this
)
{
mSessionRestoreParsingFinished
=
true
;
GeckoApp
.
this
.
notifyAll
(
)
;
}
if
(
!
mIsRestoringActivity
)
{
getAppEventDispatcher
(
)
.
dispatch
(
"
Session
:
Restore
"
restoreMessage
)
;
getProfile
(
)
.
updateSessionFile
(
mShouldRestore
)
;
}
}
}
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
SharedPreferences
prefs
=
GeckoApp
.
this
.
getSharedPreferences
(
)
;
final
LocaleManager
localeManager
=
BrowserLocaleManager
.
getInstance
(
)
;
localeManager
.
initialize
(
getApplicationContext
(
)
)
;
SessionInformation
previousSession
=
SessionInformation
.
fromSharedPrefs
(
prefs
)
;
if
(
previousSession
.
wasKilled
(
)
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_WAS_KILLED
"
1
)
;
}
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoAppShell
.
PREFS_OOM_EXCEPTION
false
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
false
)
;
editor
.
apply
(
)
;
final
String
profilePath
=
getProfile
(
)
.
getDir
(
)
.
getAbsolutePath
(
)
;
final
EventDispatcher
dispatcher
=
getAppEventDispatcher
(
)
;
final
Locale
osLocale
=
Locale
.
getDefault
(
)
;
final
String
osLocaleString
=
osLocale
.
getLanguage
(
)
+
"
_
"
+
osLocale
.
getCountry
(
)
;
String
appLocaleString
=
localeManager
.
getAndApplyPersistedLocale
(
GeckoApp
.
this
)
;
Log
.
d
(
LOGTAG
"
OS
locale
is
"
+
osLocaleString
+
"
app
locale
is
"
+
appLocaleString
)
;
if
(
appLocaleString
=
=
null
)
{
appLocaleString
=
osLocaleString
;
}
mHealthRecorder
=
GeckoApp
.
this
.
createHealthRecorder
(
GeckoApp
.
this
profilePath
dispatcher
osLocaleString
appLocaleString
previousSession
)
;
final
String
uiLocale
=
appLocaleString
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoApp
.
this
.
onLocaleReady
(
uiLocale
)
;
}
}
)
;
BrowserLocaleManager
.
storeAndNotifyOSLocale
(
getSharedPreferencesForProfile
(
)
osLocale
)
;
}
}
)
;
}
Override
public
void
onStart
(
)
{
super
.
onStart
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
mWasFirstTabShownAfterActivityUnhidden
=
false
;
}
Override
protected
void
onRestoreInstanceState
(
Bundle
savedInstanceState
)
{
super
.
onRestoreInstanceState
(
savedInstanceState
)
;
final
SparseArray
<
Parcelable
>
stateToRestore
=
savedInstanceState
.
getSparseParcelableArray
(
GECKOVIEW_STATE_BUNDLE
)
;
restoreGeckoViewState
(
stateToRestore
)
;
}
private
void
restoreGeckoViewState
(
final
SparseArray
<
Parcelable
>
state
)
{
if
(
state
!
=
null
)
{
mLayerView
.
restoreHierarchyState
(
state
)
;
}
getGeckoApplication
(
)
.
setSavedState
(
null
)
;
}
Override
protected
void
onStop
(
)
{
super
.
onStop
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
}
protected
void
onAfterStop
(
)
{
final
SharedPreferences
sharedPrefs
=
getSharedPreferencesForProfile
(
)
;
if
(
sharedPrefs
.
getBoolean
(
PREFS_IS_FIRST_RUN
true
)
)
{
sharedPrefs
.
edit
(
)
.
putBoolean
(
PREFS_IS_FIRST_RUN
false
)
.
apply
(
)
;
}
}
Override
public
void
onLocaleReady
(
final
String
locale
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
throw
new
RuntimeException
(
"
onLocaleReady
must
always
be
called
from
the
UI
thread
.
"
)
;
}
final
Locale
loc
=
Locales
.
parseLocaleCode
(
locale
)
;
if
(
loc
.
equals
(
mLastLocale
)
)
{
Log
.
d
(
LOGTAG
"
New
locale
same
as
old
;
onLocaleReady
has
nothing
to
do
.
"
)
;
}
BrowserLocaleManager
.
getInstance
(
)
.
updateConfiguration
(
GeckoApp
.
this
loc
)
;
ViewUtil
.
setLayoutDirection
(
getWindow
(
)
.
getDecorView
(
)
loc
)
;
refreshChrome
(
)
;
TextView
urlBar
=
(
TextView
)
findViewById
(
R
.
id
.
url_bar_title
)
;
if
(
urlBar
!
=
null
)
{
final
String
hint
=
getResources
(
)
.
getString
(
R
.
string
.
url_bar_default_text
)
;
urlBar
.
setHint
(
hint
)
;
}
else
{
Log
.
d
(
LOGTAG
"
No
URL
bar
in
GeckoApp
.
Not
loading
localized
hint
string
.
"
)
;
}
mLastLocale
=
loc
;
super
.
onConfigurationChanged
(
getResources
(
)
.
getConfiguration
(
)
)
;
}
protected
void
initializeChrome
(
)
{
mDoorHangerPopup
=
new
DoorHangerPopup
(
this
getAppEventDispatcher
(
)
)
;
mDoorHangerPopup
.
setOnVisibilityChangeListener
(
this
)
;
mFormAssistPopup
=
(
FormAssistPopup
)
findViewById
(
R
.
id
.
form_assist_popup
)
;
mFormAssistPopup
.
create
(
mLayerView
)
;
}
Override
public
void
onDoorHangerShow
(
)
{
final
View
overlay
=
getDoorhangerOverlay
(
)
;
if
(
overlay
!
=
null
)
{
final
Animator
alphaAnimator
=
ObjectAnimator
.
ofFloat
(
overlay
"
alpha
"
1
)
;
alphaAnimator
.
setDuration
(
250
)
;
alphaAnimator
.
start
(
)
;
}
}
Override
public
void
onDoorHangerHide
(
)
{
final
View
overlay
=
getDoorhangerOverlay
(
)
;
if
(
overlay
!
=
null
)
{
final
Animator
alphaAnimator
=
ObjectAnimator
.
ofFloat
(
overlay
"
alpha
"
0
)
;
alphaAnimator
.
setDuration
(
200
)
;
alphaAnimator
.
start
(
)
;
}
}
protected
void
loadStartupTab
(
final
int
flags
String
action
)
{
final
SearchWidgetProvider
.
InputType
input
=
getWidgetInputType
(
getIntent
(
)
)
;
if
(
input
!
=
null
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
"
about
:
home
"
flags
)
;
return
;
}
if
(
!
mShouldRestore
|
|
Intent
.
ACTION_VIEW
.
equals
(
action
)
)
{
if
(
mLastSessionCrashed
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
AboutPages
.
getURLForBuiltinPanelType
(
PanelType
.
DEPRECATED_RECENT_TABS
)
flags
)
;
}
else
{
Tabs
.
getInstance
(
)
.
loadUrl
(
Tabs
.
getHomepageForStartupTab
(
this
)
flags
)
;
}
}
}
protected
void
loadStartupTab
(
final
String
url
final
SafeIntent
intent
final
int
flags
)
{
if
(
url
=
=
null
)
{
loadStartupTab
(
flags
intent
.
getAction
(
)
)
;
return
;
}
Tabs
.
getInstance
(
)
.
loadUrlWithIntentExtras
(
url
intent
flags
)
;
}
protected
SearchWidgetProvider
.
InputType
getWidgetInputType
(
final
Intent
intent
)
{
final
Intent
searchIntent
=
intent
!
=
null
?
intent
:
getIntent
(
)
;
if
(
searchIntent
=
=
null
)
{
return
null
;
}
return
(
SearchWidgetProvider
.
InputType
)
searchIntent
.
getSerializableExtra
(
SearchWidgetProvider
.
INPUT_TYPE_KEY
)
;
}
protected
String
getIntentURI
(
SafeIntent
intent
)
{
final
String
passedUri
;
final
String
uri
=
getURIFromIntent
(
intent
)
;
if
(
!
TextUtils
.
isEmpty
(
uri
)
)
{
passedUri
=
uri
;
}
else
{
passedUri
=
null
;
}
return
passedUri
;
}
private
boolean
invokedWithExternalURL
(
String
uri
)
{
return
uri
!
=
null
&
&
!
AboutPages
.
isAboutHome
(
uri
)
;
}
protected
int
getNewTabFlags
(
)
{
final
boolean
isFirstTab
=
!
mWasFirstTabShownAfterActivityUnhidden
;
final
SafeIntent
intent
=
new
SafeIntent
(
getIntent
(
)
)
;
final
String
action
=
intent
.
getAction
(
)
;
int
flags
=
Tabs
.
LOADURL_NEW_TAB
|
Tabs
.
LOADURL_USER_ENTERED
|
Tabs
.
LOADURL_EXTERNAL
;
if
(
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
flags
|
=
Tabs
.
LOADURL_PINNED
;
}
if
(
isFirstTab
)
{
flags
|
=
Tabs
.
LOADURL_FIRST_AFTER_ACTIVITY_UNHIDDEN
;
}
return
flags
;
}
private
void
initialize
(
)
{
mInitialized
=
true
;
mWasFirstTabShownAfterActivityUnhidden
=
true
;
final
SafeIntent
intent
=
new
SafeIntent
(
getIntent
(
)
)
;
final
String
action
=
intent
.
getAction
(
)
;
final
String
passedUri
=
getIntentURI
(
intent
)
;
final
boolean
intentHasURL
=
passedUri
!
=
null
;
final
boolean
isAboutHomeURL
=
intentHasURL
&
&
AboutPages
.
isDefaultHomePage
(
passedUri
)
;
final
boolean
isAssistIntent
=
Intent
.
ACTION_ASSIST
.
equals
(
action
)
;
final
boolean
needsNewForegroundTab
=
intentHasURL
|
|
isAssistIntent
;
checkMigrateProfile
(
)
;
initializeChrome
(
)
;
synchronized
(
this
)
{
while
(
!
mSessionRestoreParsingFinished
)
{
try
{
wait
(
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
}
if
(
mIsRestoringActivity
&
&
hasGeckoTab
(
intent
)
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
null
Tabs
.
TabEvents
.
RESTORED
)
;
handleSelectTabIntent
(
intent
)
;
}
else
if
(
needsNewForegroundTab
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
null
Tabs
.
TabEvents
.
RESTORED
)
;
processActionViewIntent
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
isAssistIntent
)
{
Tabs
.
getInstance
(
)
.
addTab
(
Tabs
.
LOADURL_START_EDITING
|
Tabs
.
LOADURL_EXTERNAL
)
;
}
else
if
(
isAboutHomeURL
)
{
loadStartupTab
(
Tabs
.
LOADURL_NEW_TAB
action
)
;
}
else
{
final
int
flags
=
getNewTabFlags
(
)
;
loadStartupTab
(
passedUri
intent
flags
)
;
}
}
}
)
;
}
else
{
if
(
!
mIsRestoringActivity
)
{
loadStartupTab
(
Tabs
.
LOADURL_NEW_TAB
action
)
;
}
Tabs
.
getInstance
(
)
.
notifyListeners
(
null
Tabs
.
TabEvents
.
RESTORED
)
;
processTabQueue
(
)
;
}
recordStartupActionTelemetry
(
passedUri
action
)
;
if
(
ACTION_LAUNCH_SETTINGS
.
equals
(
action
)
)
{
Intent
settingsIntent
=
new
Intent
(
GeckoApp
.
this
GeckoPreferences
.
class
)
;
settingsIntent
.
putExtras
(
intent
.
getUnsafe
(
)
)
;
startActivity
(
settingsIntent
)
;
}
mPromptService
=
new
PromptService
(
this
getAppEventDispatcher
(
)
)
;
mJavaUiStartupTimer
.
stop
(
)
;
final
long
javaDuration
=
mJavaUiStartupTimer
.
getElapsed
(
)
;
ThreadUtils
.
getBackgroundHandler
(
)
.
postDelayed
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
recordJavaStartupTime
(
javaDuration
)
;
}
}
}
50
)
;
final
int
updateServiceDelay
=
30
*
1000
;
ThreadUtils
.
getBackgroundHandler
(
)
.
postDelayed
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
UpdateServiceHelper
.
registerForUpdates
(
GeckoAppShell
.
getApplicationContext
(
)
)
;
}
}
updateServiceDelay
)
;
if
(
mIsRestoringActivity
)
{
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
selectedTab
Tabs
.
TabEvents
.
SELECTED
)
;
}
}
}
TargetApi
(
Build
.
VERSION_CODES
.
JELLY_BEAN
)
Override
public
void
onGlobalLayout
(
)
{
if
(
Versions
.
preJB
)
{
mMainLayout
.
getViewTreeObserver
(
)
.
removeGlobalOnLayoutListener
(
this
)
;
}
else
{
mMainLayout
.
getViewTreeObserver
(
)
.
removeOnGlobalLayoutListener
(
this
)
;
}
if
(
!
mInitialized
)
{
initialize
(
)
;
}
}
protected
void
processActionViewIntent
(
final
Runnable
openTabsRunnable
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
TabQueueHelper
.
shouldOpenTabQueueUrls
(
GeckoApp
.
this
)
)
{
getAppEventDispatcher
(
)
.
registerUiThreadListener
(
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
String
event
GeckoBundle
message
EventCallback
callback
)
{
if
(
"
Tabs
:
TabsOpened
"
.
equals
(
event
)
)
{
getAppEventDispatcher
(
)
.
unregisterUiThreadListener
(
this
"
Tabs
:
TabsOpened
"
)
;
openTabsRunnable
.
run
(
)
;
}
}
}
"
Tabs
:
TabsOpened
"
)
;
TabQueueHelper
.
openQueuedUrls
(
GeckoApp
.
this
getProfile
(
)
TabQueueHelper
.
FILE_NAME
true
)
;
}
else
{
openTabsRunnable
.
run
(
)
;
}
}
}
)
;
}
WorkerThread
private
GeckoBundle
restoreSessionTabs
(
final
boolean
isExternalURL
boolean
useBackup
)
throws
SessionRestoreException
{
String
sessionString
=
getProfile
(
)
.
readSessionFile
(
useBackup
)
;
if
(
sessionString
=
=
null
)
{
throw
new
SessionRestoreException
(
"
Could
not
read
from
session
file
"
)
;
}
final
JSONArray
tabs
=
new
JSONArray
(
)
;
final
JSONObject
windowObject
=
new
JSONObject
(
)
;
final
boolean
sessionDataValid
;
LastSessionParser
parser
=
new
LastSessionParser
(
tabs
windowObject
isExternalURL
)
;
if
(
mPrivateBrowsingSession
=
=
null
)
{
sessionDataValid
=
parser
.
parse
(
sessionString
)
;
}
else
{
sessionDataValid
=
parser
.
parse
(
sessionString
mPrivateBrowsingSession
)
;
}
if
(
tabs
.
length
(
)
>
0
)
{
try
{
parser
.
updateParentId
(
tabs
)
;
windowObject
.
put
(
"
tabs
"
tabs
)
;
final
JSONArray
closedTabs
=
windowObject
.
optJSONArray
(
"
closedTabs
"
)
;
parser
.
updateParentId
(
closedTabs
)
;
windowObject
.
putOpt
(
"
closedTabs
"
closedTabs
)
;
sessionString
=
new
JSONObject
(
)
.
put
(
"
windows
"
new
JSONArray
(
)
.
put
(
windowObject
)
)
.
toString
(
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
SessionRestoreException
(
e
)
;
}
}
else
{
if
(
parser
.
allTabsSkipped
(
)
|
|
sessionDataValid
)
{
mShouldRestore
=
false
;
}
throw
new
SessionRestoreException
(
"
No
tabs
could
be
read
from
session
file
"
)
;
}
final
GeckoBundle
restoreData
=
new
GeckoBundle
(
1
)
;
restoreData
.
putString
(
"
sessionString
"
sessionString
)
;
return
restoreData
;
}
RobocopTarget
public
NonNull
EventDispatcher
getAppEventDispatcher
(
)
{
if
(
mLayerView
=
=
null
)
{
throw
new
IllegalStateException
(
"
Must
not
call
getAppEventDispatcher
(
)
until
after
onCreate
(
)
"
)
;
}
return
GeckoViewBridge
.
getEventDispatcher
(
mLayerView
)
;
}
protected
static
GeckoProfile
getProfile
(
)
{
return
GeckoThread
.
getActiveProfile
(
)
;
}
protected
boolean
updateCrashedState
(
)
{
try
{
File
crashFlag
=
new
File
(
GeckoProfileDirectories
.
getMozillaDirectory
(
this
)
"
CRASHED
"
)
;
if
(
crashFlag
.
exists
(
)
&
&
crashFlag
.
delete
(
)
)
{
getSharedPreferences
(
)
.
edit
(
)
.
putBoolean
(
PREFS_WAS_STOPPED
true
)
.
apply
(
)
;
return
true
;
}
}
catch
(
NoMozillaDirectoryException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
read
crash
flag
:
"
e
)
;
}
return
false
;
}
protected
boolean
getSessionRestoreState
(
Bundle
savedInstanceState
)
{
final
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
boolean
shouldRestore
=
false
;
final
int
versionCode
=
getVersionCode
(
)
;
if
(
getSessionRestoreResumeOnce
(
prefs
)
)
{
shouldRestore
=
true
;
}
else
if
(
mLastSessionCrashed
)
{
if
(
incrementCrashCount
(
prefs
)
<
=
getSessionStoreMaxCrashResumes
(
prefs
)
&
&
getSessionRestoreAfterCrashPreference
(
prefs
)
)
{
shouldRestore
=
true
;
}
else
{
shouldRestore
=
false
;
}
}
else
if
(
prefs
.
getInt
(
PREFS_VERSION_CODE
0
)
!
=
versionCode
)
{
prefs
.
edit
(
)
.
putInt
(
PREFS_VERSION_CODE
versionCode
)
.
apply
(
)
;
shouldRestore
=
true
;
}
else
if
(
savedInstanceState
!
=
null
|
|
getSessionRestorePreference
(
prefs
)
.
equals
(
"
always
"
)
|
|
getRestartFromIntent
(
)
)
{
shouldRestore
=
true
;
}
return
shouldRestore
;
}
private
boolean
getSessionRestoreResumeOnce
(
SharedPreferences
prefs
)
{
boolean
resumeOnce
=
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_RESTORE_SESSION_ONCE
false
)
;
if
(
resumeOnce
)
{
prefs
.
edit
(
)
.
putBoolean
(
GeckoPreferences
.
PREFS_RESTORE_SESSION_ONCE
false
)
.
apply
(
)
;
}
return
resumeOnce
;
}
private
int
incrementCrashCount
(
SharedPreferences
prefs
)
{
final
int
crashCount
=
getSuccessiveCrashesCount
(
prefs
)
+
1
;
prefs
.
edit
(
)
.
putInt
(
PREFS_CRASHED_COUNT
crashCount
)
.
apply
(
)
;
return
crashCount
;
}
private
int
getSuccessiveCrashesCount
(
SharedPreferences
prefs
)
{
return
prefs
.
getInt
(
PREFS_CRASHED_COUNT
0
)
;
}
private
int
getSessionStoreMaxCrashResumes
(
SharedPreferences
prefs
)
{
return
prefs
.
getInt
(
GeckoPreferences
.
PREFS_RESTORE_SESSION_MAX_CRASH_RESUMES
1
)
;
}
private
boolean
getSessionRestoreAfterCrashPreference
(
SharedPreferences
prefs
)
{
return
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_RESTORE_SESSION_FROM_CRASH
true
)
;
}
private
String
getSessionRestorePreference
(
SharedPreferences
prefs
)
{
return
prefs
.
getString
(
GeckoPreferences
.
PREFS_RESTORE_SESSION
"
always
"
)
;
}
private
boolean
getRestartFromIntent
(
)
{
return
IntentUtils
.
getBooleanExtraSafe
(
getIntent
(
)
"
didRestart
"
false
)
;
}
private
void
enableStrictMode
(
)
{
Log
.
d
(
LOGTAG
"
Enabling
Android
StrictMode
"
)
;
StrictMode
.
setThreadPolicy
(
new
StrictMode
.
ThreadPolicy
.
Builder
(
)
.
detectAll
(
)
.
penaltyLog
(
)
.
penaltyDeathOnNetwork
(
)
.
build
(
)
)
;
StrictMode
.
setVmPolicy
(
new
StrictMode
.
VmPolicy
.
Builder
(
)
.
detectAll
(
)
.
penaltyLog
(
)
.
build
(
)
)
;
}
Override
protected
void
onNewIntent
(
Intent
externalIntent
)
{
final
SafeIntent
intent
=
new
SafeIntent
(
externalIntent
)
;
final
String
action
=
intent
.
getAction
(
)
;
if
(
ACTION_SHUTDOWN
.
equals
(
action
)
)
{
PrefsHelper
.
getPref
(
GeckoPreferences
.
PREFS_SHUTDOWN_INTENT
new
PrefsHelper
.
PrefHandlerBase
(
)
{
Override
public
void
prefValue
(
String
pref
boolean
value
)
{
if
(
value
)
{
mShutdownOnDestroy
=
true
;
GeckoThread
.
forceQuit
(
)
;
}
}
}
)
;
return
;
}
final
boolean
isFirstTab
=
!
mWasFirstTabShownAfterActivityUnhidden
;
mWasFirstTabShownAfterActivityUnhidden
=
true
;
if
(
!
mInitialized
)
{
setIntent
(
externalIntent
)
;
return
;
}
final
String
uri
=
getURIFromIntent
(
intent
)
;
final
String
passedUri
;
if
(
!
TextUtils
.
isEmpty
(
uri
)
)
{
passedUri
=
uri
;
}
else
{
passedUri
=
null
;
}
if
(
hasGeckoTab
(
intent
)
)
{
handleSelectTabIntent
(
intent
)
;
}
else
if
(
ACTION_LOAD
.
equals
(
action
)
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
intent
.
getDataString
(
)
)
;
}
else
if
(
Intent
.
ACTION_VIEW
.
equals
(
action
)
)
{
processActionViewIntent
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
String
url
=
intent
.
getDataString
(
)
;
int
flags
=
Tabs
.
LOADURL_NEW_TAB
|
Tabs
.
LOADURL_USER_ENTERED
|
Tabs
.
LOADURL_EXTERNAL
;
if
(
isFirstTab
)
{
flags
|
=
Tabs
.
LOADURL_FIRST_AFTER_ACTIVITY_UNHIDDEN
;
}
Tabs
.
getInstance
(
)
.
loadUrlWithIntentExtras
(
url
intent
flags
)
;
}
}
)
;
}
else
if
(
Intent
.
ACTION_ASSIST
.
equals
(
action
)
)
{
Tabs
.
getInstance
(
)
.
addTab
(
Tabs
.
LOADURL_START_EDITING
|
Tabs
.
LOADURL_EXTERNAL
)
;
autoHideTabs
(
)
;
}
else
if
(
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
2
)
;
data
.
putString
(
"
uri
"
uri
)
;
data
.
putString
(
"
flags
"
"
OPEN_SWITCHTAB
"
)
;
getAppEventDispatcher
(
)
.
dispatch
(
"
Tab
:
OpenUri
"
data
)
;
}
else
if
(
Intent
.
ACTION_SEARCH
.
equals
(
action
)
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
2
)
;
data
.
putString
(
"
uri
"
uri
)
;
data
.
putString
(
"
flags
"
"
OPEN_NEWTAB
"
)
;
getAppEventDispatcher
(
)
.
dispatch
(
"
Tab
:
OpenUri
"
data
)
;
}
else
if
(
NotificationHelper
.
HELPER_BROADCAST_ACTION
.
equals
(
action
)
)
{
NotificationHelper
.
getInstance
(
getApplicationContext
(
)
)
.
handleNotificationIntent
(
intent
)
;
}
else
if
(
ACTION_LAUNCH_SETTINGS
.
equals
(
action
)
)
{
Intent
settingsIntent
=
new
Intent
(
GeckoApp
.
this
GeckoPreferences
.
class
)
;
settingsIntent
.
putExtras
(
intent
.
getUnsafe
(
)
)
;
startActivity
(
settingsIntent
)
;
}
recordStartupActionTelemetry
(
passedUri
action
)
;
}
protected
boolean
hasGeckoTab
(
SafeIntent
intent
)
{
final
int
tabId
=
intent
.
getIntExtra
(
INTENT_EXTRA_TAB_ID
INVALID_TAB_ID
)
;
final
String
intentSessionUUID
=
intent
.
getStringExtra
(
INTENT_EXTRA_SESSION_UUID
)
;
final
Tab
tabToCheck
=
Tabs
.
getInstance
(
)
.
getTab
(
tabId
)
;
return
tabToCheck
!
=
null
&
&
(
!
intent
.
hasExtra
(
INTENT_EXTRA_SESSION_UUID
)
|
|
GeckoApplication
.
getSessionUUID
(
)
.
equals
(
intentSessionUUID
)
)
;
}
protected
void
handleSelectTabIntent
(
SafeIntent
intent
)
{
final
int
tabId
=
intent
.
getIntExtra
(
INTENT_EXTRA_TAB_ID
INVALID_TAB_ID
)
;
Tabs
.
getInstance
(
)
.
selectTab
(
tabId
)
;
}
protected
String
getURIFromIntent
(
SafeIntent
intent
)
{
final
String
action
=
intent
.
getAction
(
)
;
if
(
ACTION_ALERT_CALLBACK
.
equals
(
action
)
|
|
NotificationHelper
.
HELPER_BROADCAST_ACTION
.
equals
(
action
)
)
{
return
null
;
}
return
intent
.
getDataString
(
)
;
}
protected
int
getOrientation
(
)
{
return
GeckoScreenOrientation
.
getInstance
(
)
.
getAndroidOrientation
(
)
;
}
WrapForJNI
(
calledFrom
=
"
gecko
"
)
public
static
void
launchOrBringToFront
(
)
{
final
Activity
activity
=
GeckoActivityMonitor
.
getInstance
(
)
.
getCurrentActivity
(
)
;
if
(
activity
instanceof
BrowserApp
&
&
(
(
GeckoApp
)
activity
)
.
foregrounded
)
{
return
;
}
Intent
intent
=
new
Intent
(
Intent
.
ACTION_MAIN
)
;
intent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
|
Intent
.
FLAG_ACTIVITY_REORDER_TO_FRONT
)
;
intent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
GeckoAppShell
.
getApplicationContext
(
)
.
startActivity
(
intent
)
;
}
Override
public
void
onResume
(
)
{
super
.
onResume
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
foregrounded
=
true
;
GeckoAppShell
.
setScreenOrientationDelegate
(
this
)
;
final
long
now
=
System
.
currentTimeMillis
(
)
;
final
long
realTime
=
android
.
os
.
SystemClock
.
elapsedRealtime
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
SessionInformation
currentSession
=
new
SessionInformation
(
now
realTime
)
;
SharedPreferences
prefs
=
GeckoApp
.
this
.
getSharedPreferences
(
)
;
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
false
)
;
if
(
!
mLastSessionCrashed
)
{
editor
.
putInt
(
GeckoApp
.
PREFS_CRASHED_COUNT
0
)
;
}
currentSession
.
recordBegin
(
editor
)
;
editor
.
apply
(
)
;
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
setCurrentSession
(
currentSession
)
;
rec
.
processDelayed
(
)
;
}
else
{
Log
.
w
(
LOGTAG
"
Can
'
t
record
session
:
rec
is
null
.
"
)
;
}
}
}
)
;
Restrictions
.
update
(
this
)
;
}
Override
public
void
onWindowFocusChanged
(
boolean
hasFocus
)
{
super
.
onWindowFocusChanged
(
hasFocus
)
;
if
(
!
mWindowFocusInitialized
&
&
hasFocus
)
{
mWindowFocusInitialized
=
true
;
mLayerView
.
setFocusable
(
false
)
;
mLayerView
.
setFocusable
(
true
)
;
mLayerView
.
setFocusableInTouchMode
(
true
)
;
getWindow
(
)
.
setBackgroundDrawable
(
null
)
;
}
}
Override
public
void
onPause
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onPause
(
)
;
return
;
}
foregrounded
=
false
;
final
HealthRecorder
rec
=
mHealthRecorder
;
final
Context
context
=
this
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
SharedPreferences
prefs
=
GeckoApp
.
this
.
getSharedPreferences
(
)
;
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
true
)
;
if
(
rec
!
=
null
)
{
rec
.
recordSessionEnd
(
"
P
"
editor
)
;
}
mLastSessionCrashed
=
false
;
if
(
prefs
.
getBoolean
(
GeckoApp
.
PREFS_CLEANUP_TEMP_FILES
true
)
)
{
File
tempDir
=
GeckoLoader
.
getGREDir
(
GeckoApp
.
this
)
;
FileUtils
.
delTree
(
tempDir
new
FileUtils
.
NameAndAgeFilter
(
null
ONE_DAY_MS
)
false
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_CLEANUP_TEMP_FILES
false
)
;
}
editor
.
apply
(
)
;
}
}
)
;
GeckoAppShell
.
setScreenOrientationDelegate
(
null
)
;
super
.
onPause
(
)
;
}
SuppressWarnings
(
"
try
"
)
Override
public
void
onRestart
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onRestart
(
)
;
return
;
}
try
(
StrictModeContext
unused
=
StrictModeContext
.
allowDiskReads
(
)
)
{
SharedPreferences
.
Editor
editor
=
GeckoApp
.
this
.
getSharedPreferences
(
)
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
false
)
;
editor
.
apply
(
)
;
}
super
.
onRestart
(
)
;
}
Override
public
void
onDestroy
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onDestroy
(
)
;
return
;
}
if
(
mFormAssistPopup
!
=
null
)
{
mFormAssistPopup
.
destroy
(
)
;
mFormAssistPopup
=
null
;
}
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
destroy
(
)
;
mDoorHangerPopup
=
null
;
}
if
(
mTextSelection
!
=
null
)
{
mTextSelection
.
destroy
(
)
;
mTextSelection
=
null
;
}
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
this
"
Gecko
:
Ready
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
"
Gecko
:
CorruptAPK
"
"
Update
:
Check
"
"
Update
:
Download
"
"
Update
:
Install
"
null
)
;
getAppEventDispatcher
(
)
.
unregisterGeckoThreadListener
(
this
"
Locale
:
Set
"
"
PrivateBrowsing
:
Data
"
null
)
;
getAppEventDispatcher
(
)
.
unregisterUiThreadListener
(
this
"
Contact
:
Add
"
"
DevToolsAuth
:
Scan
"
"
DOMFullScreen
:
Start
"
"
DOMFullScreen
:
Stop
"
"
Mma
:
reader_available
"
"
Mma
:
web_save_image
"
"
Mma
:
web_save_media
"
"
Permissions
:
Data
"
"
SystemUI
:
Visibility
"
"
ToggleChrome
:
Focus
"
"
ToggleChrome
:
Hide
"
"
ToggleChrome
:
Show
"
null
)
;
if
(
mPromptService
!
=
null
)
{
mPromptService
.
destroy
(
)
;
mPromptService
=
null
;
}
final
HealthRecorder
rec
=
mHealthRecorder
;
mHealthRecorder
=
null
;
if
(
rec
!
=
null
&
&
rec
.
isEnabled
(
)
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
rec
.
close
(
GeckoApp
.
this
)
;
}
}
)
;
}
super
.
onDestroy
(
)
;
Tabs
.
unregisterOnTabsChangedListener
(
this
)
;
Tabs
.
getInstance
(
)
.
detachFromContext
(
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
removeListener
(
this
)
;
if
(
mShutdownOnDestroy
)
{
GeckoApplication
.
shutdown
(
!
mRestartOnShutdown
?
null
:
new
Intent
(
Intent
.
ACTION_MAIN
null
getApplicationContext
(
)
getClass
(
)
)
)
;
}
}
public
void
showSDKVersionError
(
)
{
final
String
message
=
getString
(
R
.
string
.
unsupported_sdk_version
HardwareUtils
.
getRealAbi
(
)
Integer
.
toString
(
Build
.
VERSION
.
SDK_INT
)
)
;
Toast
.
makeText
(
this
message
Toast
.
LENGTH_LONG
)
.
show
(
)
;
}
private
void
showCorruptAPKError
(
)
{
Toast
.
makeText
(
this
getString
(
R
.
string
.
corrupt_apk
)
Toast
.
LENGTH_LONG
)
.
show
(
)
;
}
public
static
File
getTempDirectory
(
NonNull
Context
context
)
{
return
context
.
getApplicationContext
(
)
.
getExternalFilesDir
(
"
temp
"
)
;
}
public
static
void
deleteTempFiles
(
Context
context
)
{
File
dir
=
getTempDirectory
(
context
)
;
if
(
dir
=
=
null
)
return
;
File
[
]
files
=
dir
.
listFiles
(
)
;
if
(
files
=
=
null
)
return
;
for
(
File
file
:
files
)
{
file
.
delete
(
)
;
}
}
Override
public
void
onConfigurationChanged
(
Configuration
newConfig
)
{
Log
.
d
(
LOGTAG
"
onConfigurationChanged
:
"
+
newConfig
.
locale
)
;
final
LocaleManager
localeManager
=
BrowserLocaleManager
.
getInstance
(
)
;
final
Locale
changed
=
localeManager
.
onSystemConfigurationChanged
(
this
getResources
(
)
newConfig
mLastLocale
)
;
if
(
changed
!
=
null
)
{
onLocaleChanged
(
Locales
.
getLanguageTag
(
changed
)
)
;
}
super
.
onConfigurationChanged
(
newConfig
)
;
}
public
String
getContentProcessName
(
)
{
return
AppConstants
.
MOZ_CHILD_PROCESS_NAME
;
}
public
void
addEnvToIntent
(
Intent
intent
)
{
Map
<
String
String
>
envMap
=
System
.
getenv
(
)
;
Set
<
Map
.
Entry
<
String
String
>
>
envSet
=
envMap
.
entrySet
(
)
;
Iterator
<
Map
.
Entry
<
String
String
>
>
envIter
=
envSet
.
iterator
(
)
;
int
c
=
0
;
while
(
envIter
.
hasNext
(
)
)
{
Map
.
Entry
<
String
String
>
entry
=
envIter
.
next
(
)
;
intent
.
putExtra
(
"
env
"
+
c
entry
.
getKey
(
)
+
"
=
"
+
entry
.
getValue
(
)
)
;
c
+
+
;
}
}
TargetApi
(
Build
.
VERSION_CODES
.
JELLY_BEAN_MR1
)
protected
void
finishAndShutdown
(
final
boolean
restart
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mShutdownOnDestroy
=
true
;
mRestartOnShutdown
=
restart
;
if
(
!
isFinishing
(
)
&
&
(
Versions
.
preJBMR1
|
|
!
isDestroyed
(
)
)
)
{
finish
(
)
;
}
}
private
void
checkMigrateProfile
(
)
{
final
File
profileDir
=
getProfile
(
)
.
getDir
(
)
;
if
(
profileDir
!
=
null
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Handler
handler
=
new
Handler
(
)
;
handler
.
postDelayed
(
new
DeferredCleanupTask
(
)
CLEANUP_DEFERRAL_SECONDS
*
1000
)
;
}
}
)
;
}
}
private
static
class
DeferredCleanupTask
implements
Runnable
{
private
static
final
String
CLEANUP_VERSION
=
"
cleanup
-
version
"
;
private
static
final
int
CURRENT_CLEANUP_VERSION
=
1
;
Override
public
void
run
(
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
long
cleanupVersion
=
GeckoSharedPrefs
.
forApp
(
context
)
.
getInt
(
CLEANUP_VERSION
0
)
;
if
(
cleanupVersion
<
1
)
{
final
File
dataDir
=
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
)
;
final
File
dir
=
new
File
(
dataDir
"
res
/
fonts
"
)
;
if
(
dir
.
exists
(
)
&
&
dir
.
isDirectory
(
)
&
&
dir
.
listFiles
(
)
!
=
null
)
{
for
(
File
file
:
dir
.
listFiles
(
)
)
{
if
(
file
.
isFile
(
)
&
&
file
.
getName
(
)
.
endsWith
(
"
.
ttf
"
)
)
{
file
.
delete
(
)
;
}
}
if
(
!
dir
.
delete
(
)
)
{
Log
.
w
(
LOGTAG
"
unable
to
delete
res
/
fonts
directory
(
not
empty
?
)
"
)
;
}
}
}
if
(
cleanupVersion
!
=
CURRENT_CLEANUP_VERSION
)
{
SharedPreferences
.
Editor
editor
=
GeckoSharedPrefs
.
forApp
(
context
)
.
edit
(
)
;
editor
.
putInt
(
CLEANUP_VERSION
CURRENT_CLEANUP_VERSION
)
;
editor
.
apply
(
)
;
}
}
}
protected
void
onDone
(
)
{
moveTaskToBack
(
true
)
;
}
Override
public
void
onBackPressed
(
)
{
if
(
getSupportFragmentManager
(
)
.
getBackStackEntryCount
(
)
>
0
)
{
super
.
onBackPressed
(
)
;
return
;
}
if
(
autoHideTabs
(
)
)
{
return
;
}
if
(
mDoorHangerPopup
!
=
null
&
&
mDoorHangerPopup
.
isShowing
(
)
)
{
mDoorHangerPopup
.
dismiss
(
)
;
return
;
}
if
(
mIsFullscreen
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
FullScreen
:
Exit
"
null
)
;
return
;
}
final
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
final
Tab
tab
=
tabs
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
)
{
onDone
(
)
;
return
;
}
getAppEventDispatcher
(
)
.
dispatch
(
"
Browser
:
OnBackPressed
"
null
new
EventCallback
(
)
{
Override
public
void
sendSuccess
(
final
Object
response
)
{
if
(
!
(
(
GeckoBundle
)
response
)
.
getBoolean
(
"
handled
"
)
)
{
onDefault
(
)
;
}
}
Override
public
void
sendError
(
final
Object
error
)
{
onDefault
(
)
;
}
private
void
onDefault
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
tab
.
doBack
(
)
)
{
return
;
}
if
(
tab
.
isExternal
(
)
)
{
onDone
(
)
;
Tab
nextSelectedTab
=
Tabs
.
getInstance
(
)
.
getNextTab
(
tab
)
;
if
(
nextSelectedTab
!
=
null
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putInt
(
"
nextSelectedTabId
"
nextSelectedTab
.
getId
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Tab
:
KeepZombified
"
data
)
;
}
tabs
.
closeTab
(
tab
)
;
return
;
}
final
int
parentId
=
tab
.
getParentId
(
)
;
final
Tab
parent
=
tabs
.
getTab
(
parentId
)
;
if
(
parent
!
=
null
)
{
tabs
.
closeTab
(
tab
parent
)
;
return
;
}
onDone
(
)
;
}
}
)
;
}
Override
protected
void
onActivityResult
(
int
requestCode
int
resultCode
Intent
data
)
{
if
(
!
ActivityHandlerHelper
.
handleActivityResult
(
requestCode
resultCode
data
)
)
{
super
.
onActivityResult
(
requestCode
resultCode
data
)
;
}
}
Override
public
void
onRequestPermissionsResult
(
int
requestCode
String
[
]
permissions
int
[
]
grantResults
)
{
Permissions
.
onRequestPermissionsResult
(
this
permissions
grantResults
)
;
}
public
static
class
MainLayout
extends
RelativeLayout
{
private
TouchEventInterceptor
mTouchEventInterceptor
;
private
MotionEventInterceptor
mMotionEventInterceptor
;
public
MainLayout
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
}
Override
protected
void
onLayout
(
boolean
changed
int
left
int
top
int
right
int
bottom
)
{
super
.
onLayout
(
changed
left
top
right
bottom
)
;
}
public
void
setTouchEventInterceptor
(
TouchEventInterceptor
interceptor
)
{
mTouchEventInterceptor
=
interceptor
;
}
public
void
setMotionEventInterceptor
(
MotionEventInterceptor
interceptor
)
{
mMotionEventInterceptor
=
interceptor
;
}
Override
public
boolean
onInterceptTouchEvent
(
MotionEvent
event
)
{
if
(
mTouchEventInterceptor
!
=
null
&
&
mTouchEventInterceptor
.
onInterceptTouchEvent
(
this
event
)
)
{
return
true
;
}
return
super
.
onInterceptTouchEvent
(
event
)
;
}
Override
public
boolean
onTouchEvent
(
MotionEvent
event
)
{
if
(
mTouchEventInterceptor
!
=
null
&
&
mTouchEventInterceptor
.
onTouch
(
this
event
)
)
{
return
true
;
}
return
super
.
onTouchEvent
(
event
)
;
}
Override
public
boolean
onGenericMotionEvent
(
MotionEvent
event
)
{
if
(
mMotionEventInterceptor
!
=
null
&
&
mMotionEventInterceptor
.
onInterceptMotionEvent
(
this
event
)
)
{
return
true
;
}
return
super
.
onGenericMotionEvent
(
event
)
;
}
Override
public
void
setDrawingCacheEnabled
(
boolean
enabled
)
{
super
.
setChildrenDrawnWithCacheEnabled
(
enabled
)
;
}
}
private
int
getVersionCode
(
)
{
int
versionCode
=
0
;
try
{
versionCode
=
getPackageManager
(
)
.
getPackageInfo
(
getPackageName
(
)
0
)
.
versionCode
;
}
catch
(
NameNotFoundException
e
)
{
Log
.
wtf
(
LOGTAG
getPackageName
(
)
+
"
not
found
"
e
)
;
}
return
versionCode
;
}
private
static
final
String
SESSION_END_LOCALE_CHANGED
=
"
L
"
;
protected
void
onLocaleChanged
(
final
String
locale
)
{
final
boolean
startNewSession
=
true
;
final
boolean
shouldRestart
=
false
;
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
onAppLocaleChanged
(
locale
)
;
rec
.
onEnvironmentChanged
(
startNewSession
SESSION_END_LOCALE_CHANGED
)
;
}
final
Runnable
runnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
ThreadUtils
.
postToUiThread
(
this
)
;
return
;
}
if
(
!
shouldRestart
)
{
GeckoApp
.
this
.
onLocaleReady
(
locale
)
;
}
else
{
finishAndShutdown
(
true
)
;
}
}
}
;
if
(
!
shouldRestart
)
{
ThreadUtils
.
postToUiThread
(
runnable
)
;
}
else
{
ThreadUtils
.
postToBackgroundThread
(
runnable
)
;
}
}
protected
void
setLocale
(
final
String
locale
)
{
if
(
locale
=
=
null
)
{
return
;
}
final
String
resultant
=
BrowserLocaleManager
.
getInstance
(
)
.
setSelectedLocale
(
this
locale
)
;
if
(
resultant
=
=
null
)
{
return
;
}
onLocaleChanged
(
resultant
)
;
}
protected
HealthRecorder
createHealthRecorder
(
final
Context
context
final
String
profilePath
final
EventDispatcher
dispatcher
final
String
osLocale
final
String
appLocale
final
SessionInformation
previousSession
)
{
return
new
StubbedHealthRecorder
(
)
;
}
protected
void
recordStartupActionTelemetry
(
final
String
passedURL
final
String
action
)
{
}
public
GeckoView
getGeckoView
(
)
{
return
mLayerView
;
}
protected
GeckoApplication
getGeckoApplication
(
)
{
return
(
GeckoApplication
)
getApplicationContext
(
)
;
}
Override
public
boolean
setRequestedOrientationForCurrentActivity
(
int
requestedActivityInfoOrientation
)
{
if
(
getRequestedOrientation
(
)
=
=
requestedActivityInfoOrientation
)
{
return
false
;
}
setRequestedOrientation
(
requestedActivityInfoOrientation
)
;
return
true
;
}
Override
public
void
onScreenOrientationChanged
(
ScreenOrientation
newOrientation
)
{
if
(
mFormAssistPopup
!
=
null
)
{
mFormAssistPopup
.
hide
(
)
;
}
refreshChrome
(
)
;
}
}
