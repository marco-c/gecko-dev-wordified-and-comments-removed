package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
AppConstants
.
Versions
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoMozillaDirectoryException
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
UrlAnnotations
;
import
org
.
mozilla
.
gecko
.
gfx
.
BitmapUtils
;
import
org
.
mozilla
.
gecko
.
gfx
.
FullScreenState
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
;
import
org
.
mozilla
.
gecko
.
health
.
HealthRecorder
;
import
org
.
mozilla
.
gecko
.
health
.
SessionInformation
;
import
org
.
mozilla
.
gecko
.
health
.
StubbedHealthRecorder
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfig
.
PanelType
;
import
org
.
mozilla
.
gecko
.
icons
.
IconCallback
;
import
org
.
mozilla
.
gecko
.
icons
.
IconResponse
;
import
org
.
mozilla
.
gecko
.
icons
.
Icons
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenu
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenuInflater
;
import
org
.
mozilla
.
gecko
.
menu
.
MenuPanel
;
import
org
.
mozilla
.
gecko
.
notifications
.
NotificationClient
;
import
org
.
mozilla
.
gecko
.
notifications
.
NotificationHelper
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
org
.
mozilla
.
gecko
.
mozglue
.
SafeIntent
;
import
org
.
mozilla
.
gecko
.
mozglue
.
GeckoLoader
;
import
org
.
mozilla
.
gecko
.
permissions
.
Permissions
;
import
org
.
mozilla
.
gecko
.
preferences
.
ClearOnShutdownPref
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
prompts
.
PromptService
;
import
org
.
mozilla
.
gecko
.
restrictions
.
Restrictions
;
import
org
.
mozilla
.
gecko
.
tabqueue
.
TabQueueHelper
;
import
org
.
mozilla
.
gecko
.
text
.
FloatingToolbarTextSelection
;
import
org
.
mozilla
.
gecko
.
text
.
TextSelection
;
import
org
.
mozilla
.
gecko
.
updater
.
UpdateServiceHelper
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityResultHandler
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoRequest
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
NativeJSObject
;
import
org
.
mozilla
.
gecko
.
util
.
PrefUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
app
.
AlertDialog
;
import
android
.
content
.
Context
;
import
android
.
content
.
DialogInterface
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
BitmapFactory
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
Paint
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
hardware
.
Sensor
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Environment
;
import
android
.
os
.
Handler
;
import
android
.
os
.
PowerManager
;
import
android
.
os
.
Process
;
import
android
.
os
.
StrictMode
;
import
android
.
provider
.
ContactsContract
;
import
android
.
provider
.
MediaStore
.
Images
.
Media
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
support
.
design
.
widget
.
Snackbar
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Base64
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseBooleanArray
;
import
android
.
util
.
SparseIntArray
;
import
android
.
view
.
Gravity
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
Menu
;
import
android
.
view
.
MenuInflater
;
import
android
.
view
.
MenuItem
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
OrientationEventListener
;
import
android
.
view
.
SurfaceView
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
ViewTreeObserver
;
import
android
.
view
.
Window
;
import
android
.
widget
.
AbsoluteLayout
;
import
android
.
widget
.
AdapterView
;
import
android
.
widget
.
Button
;
import
android
.
widget
.
FrameLayout
;
import
android
.
widget
.
ListView
;
import
android
.
widget
.
RelativeLayout
;
import
android
.
widget
.
SimpleAdapter
;
import
android
.
widget
.
TextView
;
import
android
.
widget
.
Toast
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
util
.
ViewUtil
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
lang
.
ref
.
WeakReference
;
import
java
.
net
.
URL
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
abstract
class
GeckoApp
extends
GeckoActivity
implements
BundleEventListener
ContextGetter
GeckoAppShell
.
GeckoInterface
ScreenOrientationDelegate
GeckoMenu
.
Callback
GeckoMenu
.
MenuPresenter
Tabs
.
OnTabsChangedListener
ViewTreeObserver
.
OnGlobalLayoutListener
{
private
static
final
String
LOGTAG
=
"
GeckoApp
"
;
private
static
final
long
ONE_DAY_MS
=
TimeUnit
.
MILLISECONDS
.
convert
(
1
TimeUnit
.
DAYS
)
;
public
static
final
String
ACTION_ALERT_CALLBACK
=
"
org
.
mozilla
.
gecko
.
ALERT_CALLBACK
"
;
public
static
final
String
ACTION_HOMESCREEN_SHORTCUT
=
"
org
.
mozilla
.
gecko
.
BOOKMARK
"
;
public
static
final
String
ACTION_DEBUG
=
"
org
.
mozilla
.
gecko
.
DEBUG
"
;
public
static
final
String
ACTION_LAUNCH_SETTINGS
=
"
org
.
mozilla
.
gecko
.
SETTINGS
"
;
public
static
final
String
ACTION_LOAD
=
"
org
.
mozilla
.
gecko
.
LOAD
"
;
public
static
final
String
ACTION_INIT_PW
=
"
org
.
mozilla
.
gecko
.
INIT_PW
"
;
public
static
final
String
ACTION_SWITCH_TAB
=
"
org
.
mozilla
.
gecko
.
SWITCH_TAB
"
;
public
static
final
String
INTENT_REGISTER_STUMBLER_LISTENER
=
"
org
.
mozilla
.
gecko
.
STUMBLER_REGISTER_LOCAL_LISTENER
"
;
public
static
final
String
EXTRA_STATE_BUNDLE
=
"
stateBundle
"
;
public
static
final
String
LAST_SELECTED_TAB
=
"
lastSelectedTab
"
;
public
static
final
String
PREFS_ALLOW_STATE_BUNDLE
=
"
allowStateBundle
"
;
public
static
final
String
PREFS_VERSION_CODE
=
"
versionCode
"
;
public
static
final
String
PREFS_WAS_STOPPED
=
"
wasStopped
"
;
public
static
final
String
PREFS_CRASHED_COUNT
=
"
crashedCount
"
;
public
static
final
String
PREFS_CLEANUP_TEMP_FILES
=
"
cleanupTempFiles
"
;
public
static
final
String
SAVED_STATE_IN_BACKGROUND
=
"
inBackground
"
;
public
static
final
String
SAVED_STATE_PRIVATE_SESSION
=
"
privateSession
"
;
private
static
final
int
CLEANUP_DEFERRAL_SECONDS
=
15
;
private
static
boolean
sAlreadyLoaded
;
private
static
WeakReference
<
GeckoApp
>
lastActiveGeckoApp
;
protected
RelativeLayout
mRootLayout
;
protected
RelativeLayout
mMainLayout
;
protected
RelativeLayout
mGeckoLayout
;
private
OrientationEventListener
mCameraOrientationEventListener
;
public
List
<
GeckoAppShell
.
AppStateListener
>
mAppStateListeners
=
new
LinkedList
<
GeckoAppShell
.
AppStateListener
>
(
)
;
protected
MenuPanel
mMenuPanel
;
protected
Menu
mMenu
;
protected
boolean
mIsRestoringActivity
;
protected
boolean
mIsAbortingAppLaunch
;
private
PromptService
mPromptService
;
protected
TextSelection
mTextSelection
;
protected
DoorHangerPopup
mDoorHangerPopup
;
protected
FormAssistPopup
mFormAssistPopup
;
protected
GeckoView
mLayerView
;
private
AbsoluteLayout
mPluginContainer
;
private
FullScreenHolder
mFullScreenPluginContainer
;
private
View
mFullScreenPluginView
;
private
final
HashMap
<
String
PowerManager
.
WakeLock
>
mWakeLocks
=
new
HashMap
<
String
PowerManager
.
WakeLock
>
(
)
;
protected
boolean
mLastSessionCrashed
;
protected
boolean
mShouldRestore
;
private
boolean
mSessionRestoreParsingFinished
=
false
;
protected
int
lastSelectedTabId
=
-
1
;
private
boolean
foregrounded
=
false
;
private
static
final
class
LastSessionParser
extends
SessionParser
{
private
JSONArray
tabs
;
private
JSONObject
windowObject
;
private
boolean
isExternalURL
;
private
boolean
selectNextTab
;
private
boolean
tabsWereSkipped
;
private
boolean
tabsWereProcessed
;
private
SparseIntArray
tabIdMap
;
public
LastSessionParser
(
JSONArray
tabs
JSONObject
windowObject
boolean
isExternalURL
)
{
this
.
tabs
=
tabs
;
this
.
windowObject
=
windowObject
;
this
.
isExternalURL
=
isExternalURL
;
tabIdMap
=
new
SparseIntArray
(
)
;
}
public
boolean
allTabsSkipped
(
)
{
return
tabsWereSkipped
&
&
!
tabsWereProcessed
;
}
public
int
getNewTabId
(
int
oldTabId
)
{
return
tabIdMap
.
get
(
oldTabId
-
1
)
;
}
Override
public
void
onTabRead
(
final
SessionTab
sessionTab
)
{
if
(
sessionTab
.
isAboutHomeWithoutHistory
(
)
)
{
if
(
sessionTab
.
isSelected
(
)
)
{
if
(
!
Tabs
.
getInstance
(
)
.
selectLastTab
(
)
)
{
selectNextTab
=
true
;
}
}
tabsWereSkipped
=
true
;
return
;
}
tabsWereProcessed
=
true
;
JSONObject
tabObject
=
sessionTab
.
getTabObject
(
)
;
int
flags
=
Tabs
.
LOADURL_NEW_TAB
;
flags
|
=
(
(
isExternalURL
|
|
!
sessionTab
.
isSelected
(
)
)
?
Tabs
.
LOADURL_DELAY_LOAD
:
0
)
;
flags
|
=
(
tabObject
.
optBoolean
(
"
desktopMode
"
)
?
Tabs
.
LOADURL_DESKTOP
:
0
)
;
flags
|
=
(
tabObject
.
optBoolean
(
"
isPrivate
"
)
?
Tabs
.
LOADURL_PRIVATE
:
0
)
;
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
loadUrl
(
sessionTab
.
getUrl
(
)
flags
)
;
if
(
selectNextTab
)
{
Tabs
.
getInstance
(
)
.
selectTab
(
tab
.
getId
(
)
)
;
selectNextTab
=
false
;
}
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
tab
.
updateTitle
(
sessionTab
.
getTitle
(
)
)
;
}
}
)
;
try
{
int
oldTabId
=
tabObject
.
optInt
(
"
tabId
"
-
1
)
;
int
newTabId
=
tab
.
getId
(
)
;
tabObject
.
put
(
"
tabId
"
newTabId
)
;
if
(
oldTabId
>
=
0
)
{
tabIdMap
.
put
(
oldTabId
newTabId
)
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
JSON
error
"
e
)
;
}
tabs
.
put
(
tabObject
)
;
}
Override
public
void
onClosedTabsRead
(
final
JSONArray
closedTabData
)
throws
JSONException
{
windowObject
.
put
(
"
closedTabs
"
closedTabData
)
;
}
public
void
updateParentId
(
final
JSONArray
tabData
)
{
if
(
tabData
=
=
null
)
{
return
;
}
for
(
int
i
=
0
;
i
<
tabData
.
length
(
)
;
i
+
+
)
{
try
{
JSONObject
tabObject
=
tabData
.
getJSONObject
(
i
)
;
int
parentId
=
tabObject
.
getInt
(
"
parentId
"
)
;
int
newParentId
=
getNewTabId
(
parentId
)
;
tabObject
.
put
(
"
parentId
"
newParentId
)
;
}
catch
(
JSONException
ex
)
{
}
}
}
}
;
protected
boolean
mInitialized
;
protected
boolean
mWindowFocusInitialized
;
private
Telemetry
.
Timer
mJavaUiStartupTimer
;
private
Telemetry
.
Timer
mGeckoReadyStartupTimer
;
private
String
mPrivateBrowsingSession
;
private
volatile
HealthRecorder
mHealthRecorder
;
private
volatile
Locale
mLastLocale
;
protected
Intent
mRestartIntent
;
private
boolean
mWasFirstTabShownAfterActivityUnhidden
;
abstract
public
int
getLayout
(
)
;
protected
void
processTabQueue
(
)
{
}
;
protected
void
openQueuedTabs
(
)
{
}
;
SuppressWarnings
(
"
serial
"
)
class
SessionRestoreException
extends
Exception
{
public
SessionRestoreException
(
Exception
e
)
{
super
(
e
)
;
}
public
SessionRestoreException
(
String
message
)
{
super
(
message
)
;
}
}
void
toggleChrome
(
final
boolean
aShow
)
{
}
void
focusChrome
(
)
{
}
Override
public
Context
getContext
(
)
{
return
this
;
}
Override
public
SharedPreferences
getSharedPreferences
(
)
{
return
GeckoSharedPrefs
.
forApp
(
this
)
;
}
Override
public
Activity
getActivity
(
)
{
return
this
;
}
Override
public
void
addAppStateListener
(
GeckoAppShell
.
AppStateListener
listener
)
{
mAppStateListeners
.
add
(
listener
)
;
}
Override
public
void
removeAppStateListener
(
GeckoAppShell
.
AppStateListener
listener
)
{
mAppStateListeners
.
remove
(
listener
)
;
}
Override
public
void
onTabChanged
(
Tab
tab
Tabs
.
TabEvents
msg
String
data
)
{
switch
(
msg
)
{
case
UNSELECTED
:
break
;
case
LOCATION_CHANGE
:
if
(
!
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
break
;
case
SELECTED
:
invalidateOptionsMenu
(
)
;
if
(
mFormAssistPopup
!
=
null
)
mFormAssistPopup
.
hide
(
)
;
break
;
case
DESKTOP_MODE_CHANGE
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
invalidateOptionsMenu
(
)
;
break
;
}
}
public
void
refreshChrome
(
)
{
}
Override
public
void
invalidateOptionsMenu
(
)
{
if
(
mMenu
=
=
null
)
{
return
;
}
onPrepareOptionsMenu
(
mMenu
)
;
super
.
invalidateOptionsMenu
(
)
;
}
Override
public
boolean
onCreateOptionsMenu
(
Menu
menu
)
{
mMenu
=
menu
;
MenuInflater
inflater
=
getMenuInflater
(
)
;
inflater
.
inflate
(
R
.
menu
.
gecko_app_menu
mMenu
)
;
return
true
;
}
Override
public
MenuInflater
getMenuInflater
(
)
{
return
new
GeckoMenuInflater
(
this
)
;
}
public
MenuPanel
getMenuPanel
(
)
{
if
(
mMenuPanel
=
=
null
)
{
onCreatePanelMenu
(
Window
.
FEATURE_OPTIONS_PANEL
null
)
;
invalidateOptionsMenu
(
)
;
}
return
mMenuPanel
;
}
Override
public
boolean
onMenuItemClick
(
MenuItem
item
)
{
return
onOptionsItemSelected
(
item
)
;
}
Override
public
boolean
onMenuItemLongClick
(
MenuItem
item
)
{
return
false
;
}
Override
public
void
openMenu
(
)
{
openOptionsMenu
(
)
;
}
Override
public
void
showMenu
(
final
View
menu
)
{
closeMenu
(
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mMenuPanel
.
removeAllViews
(
)
;
mMenuPanel
.
addView
(
menu
)
;
openOptionsMenu
(
)
;
}
}
)
;
}
Override
public
void
closeMenu
(
)
{
closeOptionsMenu
(
)
;
}
Override
public
View
onCreatePanelView
(
int
featureId
)
{
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
if
(
mMenuPanel
=
=
null
)
{
mMenuPanel
=
new
MenuPanel
(
this
null
)
;
}
else
{
onPreparePanel
(
featureId
mMenuPanel
mMenu
)
;
}
return
mMenuPanel
;
}
return
super
.
onCreatePanelView
(
featureId
)
;
}
Override
public
boolean
onCreatePanelMenu
(
int
featureId
Menu
menu
)
{
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
if
(
mMenuPanel
=
=
null
)
{
mMenuPanel
=
(
MenuPanel
)
onCreatePanelView
(
featureId
)
;
}
GeckoMenu
gMenu
=
new
GeckoMenu
(
this
null
)
;
gMenu
.
setCallback
(
this
)
;
gMenu
.
setMenuPresenter
(
this
)
;
menu
=
gMenu
;
mMenuPanel
.
addView
(
gMenu
)
;
return
onCreateOptionsMenu
(
menu
)
;
}
return
super
.
onCreatePanelMenu
(
featureId
menu
)
;
}
Override
public
boolean
onPreparePanel
(
int
featureId
View
view
Menu
menu
)
{
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
return
onPrepareOptionsMenu
(
menu
)
;
}
return
super
.
onPreparePanel
(
featureId
view
menu
)
;
}
Override
public
boolean
onMenuOpened
(
int
featureId
Menu
menu
)
{
if
(
mLayerView
!
=
null
&
&
mLayerView
.
isFullScreen
(
)
)
{
GeckoAppShell
.
notifyObservers
(
"
FullScreen
:
Exit
"
null
)
;
}
if
(
featureId
=
=
Window
.
FEATURE_OPTIONS_PANEL
)
{
if
(
mMenu
=
=
null
)
{
MenuPanel
panel
=
getMenuPanel
(
)
;
onPreparePanel
(
featureId
panel
mMenu
)
;
}
if
(
mMenuPanel
!
=
null
)
mMenuPanel
.
scrollTo
(
0
0
)
;
return
true
;
}
return
super
.
onMenuOpened
(
featureId
menu
)
;
}
Override
public
boolean
onOptionsItemSelected
(
MenuItem
item
)
{
if
(
item
.
getItemId
(
)
=
=
R
.
id
.
quit
)
{
GuestSession
.
hideNotification
(
this
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
Set
<
String
>
clearSet
=
PrefUtils
.
getStringSet
(
prefs
ClearOnShutdownPref
.
PREF
new
HashSet
<
String
>
(
)
)
;
final
JSONObject
clearObj
=
new
JSONObject
(
)
;
for
(
String
clear
:
clearSet
)
{
try
{
clearObj
.
put
(
clear
true
)
;
}
catch
(
JSONException
ex
)
{
Log
.
e
(
LOGTAG
"
Error
adding
clear
object
"
+
clear
ex
)
;
}
}
final
JSONObject
res
=
new
JSONObject
(
)
;
try
{
res
.
put
(
"
sanitize
"
clearObj
)
;
}
catch
(
JSONException
ex
)
{
Log
.
e
(
LOGTAG
"
Error
adding
sanitize
object
"
ex
)
;
}
if
(
clearObj
.
has
(
"
private
.
data
.
history
"
)
)
{
final
String
sessionRestore
=
getSessionRestorePreference
(
getSharedPreferences
(
)
)
;
try
{
res
.
put
(
"
dontSaveSession
"
"
quit
"
.
equals
(
sessionRestore
)
)
;
}
catch
(
JSONException
ex
)
{
Log
.
e
(
LOGTAG
"
Error
adding
session
restore
data
"
ex
)
;
}
}
GeckoAppShell
.
notifyObservers
(
"
Browser
:
Quit
"
res
.
toString
(
)
)
;
return
true
;
}
return
super
.
onOptionsItemSelected
(
item
)
;
}
Override
public
void
onOptionsMenuClosed
(
Menu
menu
)
{
mMenuPanel
.
removeAllViews
(
)
;
mMenuPanel
.
addView
(
(
GeckoMenu
)
mMenu
)
;
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_MENU
)
{
openOptionsMenu
(
)
;
return
true
;
}
return
super
.
onKeyDown
(
keyCode
event
)
;
}
Override
protected
void
onSaveInstanceState
(
Bundle
outState
)
{
super
.
onSaveInstanceState
(
outState
)
;
outState
.
putBoolean
(
SAVED_STATE_IN_BACKGROUND
isApplicationInBackground
(
)
)
;
outState
.
putString
(
SAVED_STATE_PRIVATE_SESSION
mPrivateBrowsingSession
)
;
outState
.
putInt
(
LAST_SELECTED_TAB
lastSelectedTabId
)
;
}
Override
protected
void
onRestoreInstanceState
(
final
Bundle
inState
)
{
lastSelectedTabId
=
inState
.
getInt
(
LAST_SELECTED_TAB
)
;
}
public
void
addTab
(
)
{
}
public
void
addPrivateTab
(
)
{
}
public
void
showNormalTabs
(
)
{
}
public
void
showPrivateTabs
(
)
{
}
public
void
hideTabs
(
)
{
}
public
boolean
autoHideTabs
(
)
{
return
false
;
}
Override
public
boolean
areTabsShown
(
)
{
return
false
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
event
.
equals
(
"
Gecko
:
Ready
"
)
)
{
mGeckoReadyStartupTimer
.
stop
(
)
;
geckoConnected
(
)
;
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
recordGeckoStartupTime
(
mGeckoReadyStartupTimer
.
getElapsed
(
)
)
;
}
(
(
GeckoApplication
)
getApplicationContext
(
)
)
.
onDelayedStartup
(
)
;
}
else
if
(
"
Gecko
:
Exited
"
.
equals
(
event
)
)
{
doShutdown
(
)
;
}
else
if
(
"
Sanitize
:
Finished
"
.
equals
(
event
)
)
{
if
(
message
.
getBoolean
(
"
shutdown
"
false
)
)
{
doShutdown
(
)
;
}
}
else
if
(
"
Accessibility
:
Ready
"
.
equals
(
event
)
)
{
GeckoAccessibility
.
updateAccessibilitySettings
(
this
)
;
}
else
if
(
"
Accessibility
:
Event
"
.
equals
(
event
)
)
{
GeckoAccessibility
.
sendAccessibilityEvent
(
message
)
;
}
else
if
(
"
Bookmark
:
Insert
"
.
equals
(
event
)
)
{
final
BrowserDB
db
=
BrowserDB
.
from
(
getProfile
(
)
)
;
final
boolean
bookmarkAdded
=
db
.
addBookmark
(
getContentResolver
(
)
message
.
getString
(
"
title
"
)
message
.
getString
(
"
url
"
)
)
;
final
int
resId
=
bookmarkAdded
?
R
.
string
.
bookmark_added
:
R
.
string
.
bookmark_already_added
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
SnackbarBuilder
.
builder
(
GeckoApp
.
this
)
.
message
(
resId
)
.
duration
(
Snackbar
.
LENGTH_LONG
)
.
buildAndShow
(
)
;
}
}
)
;
}
else
if
(
"
Contact
:
Add
"
.
equals
(
event
)
)
{
final
String
email
=
message
.
getString
(
"
email
"
null
)
;
final
String
phone
=
message
.
getString
(
"
phone
"
null
)
;
if
(
email
!
=
null
)
{
Uri
contactUri
=
Uri
.
parse
(
email
)
;
Intent
i
=
new
Intent
(
ContactsContract
.
Intents
.
SHOW_OR_CREATE_CONTACT
contactUri
)
;
startActivity
(
i
)
;
}
else
if
(
phone
!
=
null
)
{
Uri
contactUri
=
Uri
.
parse
(
phone
)
;
Intent
i
=
new
Intent
(
ContactsContract
.
Intents
.
SHOW_OR_CREATE_CONTACT
contactUri
)
;
startActivity
(
i
)
;
}
else
{
Log
.
e
(
LOGTAG
"
Received
Contact
:
Add
message
with
no
email
nor
phone
number
"
)
;
}
}
else
if
(
"
DevToolsAuth
:
Scan
"
.
equals
(
event
)
)
{
DevToolsAuthHelper
.
scan
(
this
callback
)
;
}
else
if
(
"
DOMFullScreen
:
Start
"
.
equals
(
event
)
)
{
LayerView
layerView
=
mLayerView
;
if
(
layerView
!
=
null
)
{
layerView
.
setFullScreenState
(
message
.
getBoolean
(
"
rootElement
"
)
?
FullScreenState
.
ROOT_ELEMENT
:
FullScreenState
.
NON_ROOT_ELEMENT
)
;
}
}
else
if
(
"
DOMFullScreen
:
Stop
"
.
equals
(
event
)
)
{
LayerView
layerView
=
mLayerView
;
if
(
layerView
!
=
null
)
{
layerView
.
setFullScreenState
(
FullScreenState
.
NONE
)
;
}
}
else
if
(
"
Image
:
SetAs
"
.
equals
(
event
)
)
{
String
src
=
message
.
getString
(
"
url
"
)
;
setImageAs
(
src
)
;
}
else
if
(
"
Locale
:
Set
"
.
equals
(
event
)
)
{
setLocale
(
message
.
getString
(
"
locale
"
)
)
;
}
else
if
(
"
Permissions
:
Data
"
.
equals
(
event
)
)
{
final
GeckoBundle
[
]
permissions
=
message
.
getBundleArray
(
"
permissions
"
)
;
showSiteSettingsDialog
(
permissions
)
;
}
else
if
(
"
PrivateBrowsing
:
Data
"
.
equals
(
event
)
)
{
mPrivateBrowsingSession
=
message
.
getString
(
"
session
"
null
)
;
}
else
if
(
"
RuntimePermissions
:
Prompt
"
.
equals
(
event
)
)
{
String
[
]
permissions
=
message
.
getStringArray
(
"
permissions
"
)
;
if
(
callback
=
=
null
|
|
permissions
=
=
null
)
{
return
;
}
Permissions
.
from
(
this
)
.
withPermissions
(
permissions
)
.
andFallback
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
callback
.
sendSuccess
(
false
)
;
}
}
)
.
run
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
callback
.
sendSuccess
(
true
)
;
}
}
)
;
}
else
if
(
"
Share
:
Text
"
.
equals
(
event
)
)
{
final
String
text
=
message
.
getString
(
"
text
"
)
;
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
String
title
=
"
"
;
if
(
tab
!
=
null
)
{
title
=
tab
.
getDisplayTitle
(
)
;
}
IntentHelper
.
openUriExternal
(
text
"
text
/
plain
"
"
"
"
"
Intent
.
ACTION_SEND
title
false
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHARE
TelemetryContract
.
Method
.
LIST
"
text
"
)
;
}
else
if
(
"
Snackbar
:
Show
"
.
equals
(
event
)
)
{
SnackbarBuilder
.
builder
(
this
)
.
fromEvent
(
message
)
.
callback
(
callback
)
.
buildAndShow
(
)
;
}
else
if
(
"
SystemUI
:
Visibility
"
.
equals
(
event
)
)
{
if
(
message
.
getBoolean
(
"
visible
"
true
)
)
{
mMainLayout
.
setSystemUiVisibility
(
View
.
SYSTEM_UI_FLAG_VISIBLE
)
;
}
else
{
mMainLayout
.
setSystemUiVisibility
(
View
.
SYSTEM_UI_FLAG_LOW_PROFILE
)
;
}
}
else
if
(
"
ToggleChrome
:
Focus
"
.
equals
(
event
)
)
{
focusChrome
(
)
;
}
else
if
(
"
ToggleChrome
:
Hide
"
.
equals
(
event
)
)
{
toggleChrome
(
false
)
;
}
else
if
(
"
ToggleChrome
:
Show
"
.
equals
(
event
)
)
{
toggleChrome
(
true
)
;
}
else
if
(
"
Update
:
Check
"
.
equals
(
event
)
)
{
UpdateServiceHelper
.
checkForUpdate
(
this
)
;
}
else
if
(
"
Update
:
Download
"
.
equals
(
event
)
)
{
UpdateServiceHelper
.
downloadUpdate
(
this
)
;
}
else
if
(
"
Update
:
Install
"
.
equals
(
event
)
)
{
UpdateServiceHelper
.
applyUpdate
(
this
)
;
}
}
private
void
showSiteSettingsDialog
(
final
GeckoBundle
[
]
permissions
)
{
final
AlertDialog
.
Builder
builder
=
new
AlertDialog
.
Builder
(
this
)
;
builder
.
setTitle
(
R
.
string
.
site_settings_title
)
;
final
ArrayList
<
HashMap
<
String
String
>
>
itemList
=
new
ArrayList
<
HashMap
<
String
String
>
>
(
)
;
for
(
final
GeckoBundle
permObj
:
permissions
)
{
final
HashMap
<
String
String
>
map
=
new
HashMap
<
String
String
>
(
)
;
map
.
put
(
"
setting
"
permObj
.
getString
(
"
setting
"
)
)
;
map
.
put
(
"
value
"
permObj
.
getString
(
"
value
"
)
)
;
itemList
.
add
(
map
)
;
}
builder
.
setSingleChoiceItems
(
new
SimpleAdapter
(
GeckoApp
.
this
itemList
R
.
layout
.
site_setting_item
new
String
[
]
{
"
setting
"
"
value
"
}
new
int
[
]
{
R
.
id
.
setting
R
.
id
.
value
}
)
-
1
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
id
)
{
}
}
)
;
builder
.
setPositiveButton
(
R
.
string
.
site_settings_clear
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
id
)
{
ListView
listView
=
(
(
AlertDialog
)
dialog
)
.
getListView
(
)
;
SparseBooleanArray
checkedItemPositions
=
listView
.
getCheckedItemPositions
(
)
;
JSONArray
permissionsToClear
=
new
JSONArray
(
)
;
for
(
int
i
=
0
;
i
<
checkedItemPositions
.
size
(
)
;
i
+
+
)
if
(
checkedItemPositions
.
get
(
i
)
)
permissionsToClear
.
put
(
i
)
;
GeckoAppShell
.
notifyObservers
(
"
Permissions
:
Clear
"
permissionsToClear
.
toString
(
)
)
;
}
}
)
;
builder
.
setNegativeButton
(
R
.
string
.
site_settings_cancel
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
id
)
{
dialog
.
cancel
(
)
;
}
}
)
;
AlertDialog
dialog
=
builder
.
create
(
)
;
dialog
.
show
(
)
;
final
ListView
listView
=
dialog
.
getListView
(
)
;
if
(
listView
!
=
null
)
{
listView
.
setChoiceMode
(
ListView
.
CHOICE_MODE_MULTIPLE
)
;
}
final
Button
clearButton
=
dialog
.
getButton
(
DialogInterface
.
BUTTON_POSITIVE
)
;
clearButton
.
setEnabled
(
false
)
;
dialog
.
getListView
(
)
.
setOnItemClickListener
(
new
AdapterView
.
OnItemClickListener
(
)
{
Override
public
void
onItemClick
(
AdapterView
<
?
>
adapterView
View
view
int
i
long
l
)
{
if
(
listView
.
getCheckedItemCount
(
)
=
=
0
)
{
clearButton
.
setEnabled
(
false
)
;
}
else
{
clearButton
.
setEnabled
(
true
)
;
}
}
}
)
;
}
void
addFullScreenPluginView
(
View
view
)
{
if
(
mFullScreenPluginView
!
=
null
)
{
Log
.
w
(
LOGTAG
"
Already
have
a
fullscreen
plugin
view
"
)
;
return
;
}
setFullScreen
(
true
)
;
view
.
setWillNotDraw
(
false
)
;
if
(
view
instanceof
SurfaceView
)
{
(
(
SurfaceView
)
view
)
.
setZOrderOnTop
(
true
)
;
}
mFullScreenPluginContainer
=
new
FullScreenHolder
(
this
)
;
FrameLayout
.
LayoutParams
layoutParams
=
new
FrameLayout
.
LayoutParams
(
ViewGroup
.
LayoutParams
.
MATCH_PARENT
ViewGroup
.
LayoutParams
.
MATCH_PARENT
Gravity
.
CENTER
)
;
mFullScreenPluginContainer
.
addView
(
view
layoutParams
)
;
FrameLayout
decor
=
(
FrameLayout
)
getWindow
(
)
.
getDecorView
(
)
;
decor
.
addView
(
mFullScreenPluginContainer
layoutParams
)
;
mFullScreenPluginView
=
view
;
}
Override
public
void
addPluginView
(
final
View
view
)
{
if
(
ThreadUtils
.
isOnUiThread
(
)
)
{
addFullScreenPluginView
(
view
)
;
}
else
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
addFullScreenPluginView
(
view
)
;
}
}
)
;
}
}
void
removeFullScreenPluginView
(
View
view
)
{
if
(
mFullScreenPluginView
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Don
'
t
have
a
fullscreen
plugin
view
"
)
;
return
;
}
if
(
mFullScreenPluginView
!
=
view
)
{
Log
.
w
(
LOGTAG
"
Passed
view
is
not
the
current
full
screen
view
"
)
;
return
;
}
mFullScreenPluginContainer
.
removeView
(
mFullScreenPluginView
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mLayerView
.
showSurface
(
)
;
}
}
)
;
FrameLayout
decor
=
(
FrameLayout
)
getWindow
(
)
.
getDecorView
(
)
;
decor
.
removeView
(
mFullScreenPluginContainer
)
;
mFullScreenPluginView
=
null
;
GeckoScreenOrientation
.
getInstance
(
)
.
unlock
(
)
;
setFullScreen
(
false
)
;
}
Override
public
void
removePluginView
(
final
View
view
)
{
if
(
ThreadUtils
.
isOnUiThread
(
)
)
{
removePluginView
(
view
)
;
}
else
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
removeFullScreenPluginView
(
view
)
;
}
}
)
;
}
}
private
void
showSetImageResult
(
final
boolean
success
final
int
message
final
String
path
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
!
success
)
{
SnackbarBuilder
.
builder
(
GeckoApp
.
this
)
.
message
(
message
)
.
duration
(
Snackbar
.
LENGTH_LONG
)
.
buildAndShow
(
)
;
return
;
}
final
Intent
intent
=
new
Intent
(
Intent
.
ACTION_ATTACH_DATA
)
;
intent
.
addCategory
(
Intent
.
CATEGORY_DEFAULT
)
;
intent
.
setData
(
Uri
.
parse
(
path
)
)
;
Intent
chooser
=
Intent
.
createChooser
(
intent
getString
(
message
)
)
;
ActivityResultHandler
handler
=
new
ActivityResultHandler
(
)
{
Override
public
void
onActivityResult
(
int
resultCode
Intent
data
)
{
getContentResolver
(
)
.
delete
(
intent
.
getData
(
)
null
null
)
;
}
}
;
ActivityHandlerHelper
.
startIntentForActivity
(
GeckoApp
.
this
chooser
handler
)
;
}
}
)
;
}
private
void
setImageAs
(
final
String
aSrc
)
{
boolean
isDataURI
=
aSrc
.
startsWith
(
"
data
:
"
)
;
Bitmap
image
=
null
;
InputStream
is
=
null
;
ByteArrayOutputStream
os
=
null
;
try
{
if
(
isDataURI
)
{
int
dataStart
=
aSrc
.
indexOf
(
"
"
)
;
byte
[
]
buf
=
Base64
.
decode
(
aSrc
.
substring
(
dataStart
+
1
)
Base64
.
DEFAULT
)
;
image
=
BitmapUtils
.
decodeByteArray
(
buf
)
;
}
else
{
int
byteRead
;
byte
[
]
buf
=
new
byte
[
4192
]
;
os
=
new
ByteArrayOutputStream
(
)
;
URL
url
=
new
URL
(
aSrc
)
;
is
=
url
.
openStream
(
)
;
while
(
(
byteRead
=
is
.
read
(
buf
)
)
!
=
-
1
)
{
os
.
write
(
buf
0
byteRead
)
;
}
byte
[
]
imgBuffer
=
os
.
toByteArray
(
)
;
image
=
BitmapUtils
.
decodeByteArray
(
imgBuffer
)
;
}
if
(
image
!
=
null
)
{
File
dcimDir
=
Environment
.
getExternalStoragePublicDirectory
(
Environment
.
DIRECTORY_PICTURES
)
;
if
(
!
dcimDir
.
mkdirs
(
)
&
&
!
dcimDir
.
isDirectory
(
)
)
{
showSetImageResult
(
false
R
.
string
.
set_image_path_fail
null
)
;
return
;
}
String
path
=
Media
.
insertImage
(
getContentResolver
(
)
image
null
null
)
;
if
(
path
=
=
null
)
{
showSetImageResult
(
false
R
.
string
.
set_image_path_fail
null
)
;
return
;
}
showSetImageResult
(
true
R
.
string
.
set_image_chooser_title
path
)
;
}
else
{
showSetImageResult
(
false
R
.
string
.
set_image_fail
null
)
;
}
}
catch
(
OutOfMemoryError
ome
)
{
Log
.
e
(
LOGTAG
"
Out
of
Memory
when
converting
to
byte
array
"
ome
)
;
}
catch
(
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
I
/
O
Exception
while
setting
wallpaper
"
ioe
)
;
}
finally
{
if
(
is
!
=
null
)
{
try
{
is
.
close
(
)
;
}
catch
(
IOException
ioe
)
{
Log
.
w
(
LOGTAG
"
I
/
O
Exception
while
closing
stream
"
ioe
)
;
}
}
if
(
os
!
=
null
)
{
try
{
os
.
close
(
)
;
}
catch
(
IOException
ioe
)
{
Log
.
w
(
LOGTAG
"
I
/
O
Exception
while
closing
stream
"
ioe
)
;
}
}
}
}
private
int
getBitmapSampleSize
(
BitmapFactory
.
Options
options
int
idealWidth
int
idealHeight
)
{
int
width
=
options
.
outWidth
;
int
height
=
options
.
outHeight
;
int
inSampleSize
=
1
;
if
(
height
>
idealHeight
|
|
width
>
idealWidth
)
{
if
(
width
>
height
)
{
inSampleSize
=
Math
.
round
(
(
float
)
height
/
idealHeight
)
;
}
else
{
inSampleSize
=
Math
.
round
(
(
float
)
width
/
idealWidth
)
;
}
}
return
inSampleSize
;
}
public
void
requestRender
(
)
{
mLayerView
.
requestRender
(
)
;
}
Override
public
void
setFullScreen
(
final
boolean
fullscreen
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
ActivityUtils
.
setFullScreen
(
GeckoApp
.
this
fullscreen
)
;
}
}
)
;
}
protected
static
void
earlyStartJavaSampler
(
SafeIntent
intent
)
{
String
env
=
intent
.
getStringExtra
(
"
env0
"
)
;
for
(
int
i
=
1
;
env
!
=
null
;
i
+
+
)
{
if
(
env
.
startsWith
(
"
MOZ_PROFILER_STARTUP
=
"
)
)
{
if
(
!
env
.
endsWith
(
"
=
"
)
)
{
GeckoJavaSampler
.
start
(
10
1000
)
;
Log
.
d
(
LOGTAG
"
Profiling
Java
on
startup
"
)
;
}
break
;
}
env
=
intent
.
getStringExtra
(
"
env
"
+
i
)
;
}
}
Override
public
void
onCreate
(
Bundle
savedInstanceState
)
{
GeckoAppShell
.
ensureCrashHandling
(
)
;
if
(
"
default
"
.
equals
(
AppConstants
.
MOZ_UPDATE_CHANNEL
)
)
{
enableStrictMode
(
)
;
}
if
(
!
HardwareUtils
.
isSupportedSystem
(
)
)
{
mIsAbortingAppLaunch
=
true
;
super
.
onCreate
(
savedInstanceState
)
;
showSDKVersionError
(
)
;
finish
(
)
;
return
;
}
mJavaUiStartupTimer
=
new
Telemetry
.
UptimeTimer
(
"
FENNEC_STARTUP_TIME_JAVAUI
"
)
;
mGeckoReadyStartupTimer
=
new
Telemetry
.
UptimeTimer
(
"
FENNEC_STARTUP_TIME_GECKOREADY
"
)
;
final
SafeIntent
intent
=
new
SafeIntent
(
getIntent
(
)
)
;
earlyStartJavaSampler
(
intent
)
;
GeckoLoader
.
setLastIntent
(
intent
)
;
try
{
Class
.
forName
(
"
android
.
os
.
AsyncTask
"
)
;
}
catch
(
ClassNotFoundException
e
)
{
}
MemoryMonitor
.
getInstance
(
)
.
init
(
getApplicationContext
(
)
)
;
GeckoAppShell
.
setContextGetter
(
this
)
;
GeckoAppShell
.
setGeckoInterface
(
this
)
;
GeckoAppShell
.
setScreenOrientationDelegate
(
this
)
;
getApplicationContext
(
)
.
sendBroadcast
(
new
Intent
(
INTENT_REGISTER_STUMBLER_LISTENER
)
)
;
if
(
BrowserLocaleManager
.
getInstance
(
)
.
systemLocaleDidChange
(
)
)
{
Log
.
i
(
LOGTAG
"
System
locale
changed
.
Restarting
.
"
)
;
doRestart
(
)
;
return
;
}
if
(
sAlreadyLoaded
)
{
mIsRestoringActivity
=
true
;
Telemetry
.
addToHistogram
(
"
FENNEC_RESTORING_ACTIVITY
"
1
)
;
}
else
{
final
String
action
=
intent
.
getAction
(
)
;
final
String
args
=
intent
.
getStringExtra
(
"
args
"
)
;
sAlreadyLoaded
=
true
;
GeckoThread
.
init
(
null
args
action
ACTION_DEBUG
.
equals
(
action
)
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
getProfile
(
)
;
}
}
)
;
final
String
uri
=
getURIFromIntent
(
intent
)
;
if
(
!
TextUtils
.
isEmpty
(
uri
)
)
{
GeckoThread
.
speculativeConnect
(
uri
)
;
}
}
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
this
"
Accessibility
:
Ready
"
"
Gecko
:
Exited
"
"
Gecko
:
Ready
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
Sanitize
:
Finished
"
null
)
;
GeckoThread
.
launch
(
)
;
Bundle
stateBundle
=
IntentUtils
.
getBundleExtraSafe
(
getIntent
(
)
EXTRA_STATE_BUNDLE
)
;
if
(
stateBundle
!
=
null
)
{
final
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
if
(
prefs
.
getBoolean
(
PREFS_ALLOW_STATE_BUNDLE
false
)
)
{
prefs
.
edit
(
)
.
remove
(
PREFS_ALLOW_STATE_BUNDLE
)
.
apply
(
)
;
savedInstanceState
=
stateBundle
;
}
}
else
if
(
savedInstanceState
!
=
null
)
{
setIntent
(
new
Intent
(
Intent
.
ACTION_MAIN
)
)
;
}
super
.
onCreate
(
savedInstanceState
)
;
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
getResources
(
)
.
getConfiguration
(
)
.
orientation
)
;
setContentView
(
getLayout
(
)
)
;
mRootLayout
=
(
RelativeLayout
)
findViewById
(
R
.
id
.
root_layout
)
;
mGeckoLayout
=
(
RelativeLayout
)
findViewById
(
R
.
id
.
gecko_layout
)
;
mMainLayout
=
(
RelativeLayout
)
findViewById
(
R
.
id
.
main_layout
)
;
mLayerView
=
(
GeckoView
)
findViewById
(
R
.
id
.
layer_view
)
;
getAppEventDispatcher
(
)
.
registerGeckoThreadListener
(
this
"
Accessibility
:
Event
"
"
Locale
:
Set
"
null
)
;
getAppEventDispatcher
(
)
.
registerBackgroundThreadListener
(
this
"
Bookmark
:
Insert
"
"
Image
:
SetAs
"
null
)
;
getAppEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
Contact
:
Add
"
"
DevToolsAuth
:
Scan
"
"
DOMFullScreen
:
Start
"
"
DOMFullScreen
:
Stop
"
"
Permissions
:
Data
"
"
PrivateBrowsing
:
Data
"
"
RuntimePermissions
:
Prompt
"
"
Share
:
Text
"
"
SystemUI
:
Visibility
"
"
ToggleChrome
:
Focus
"
"
ToggleChrome
:
Hide
"
"
ToggleChrome
:
Show
"
"
Update
:
Check
"
"
Update
:
Download
"
"
Update
:
Install
"
null
)
;
Tabs
.
getInstance
(
)
.
attachToContext
(
this
mLayerView
)
;
mMainLayout
.
getViewTreeObserver
(
)
.
addOnGlobalLayoutListener
(
this
)
;
if
(
Versions
.
preMarshmallow
)
{
mTextSelection
=
new
ActionBarTextSelection
(
this
)
;
}
else
{
mTextSelection
=
new
FloatingToolbarTextSelection
(
this
mLayerView
)
;
}
mTextSelection
.
create
(
)
;
mLastSessionCrashed
=
updateCrashedState
(
)
;
mShouldRestore
=
getSessionRestoreState
(
savedInstanceState
)
;
if
(
mShouldRestore
&
&
savedInstanceState
!
=
null
)
{
boolean
wasInBackground
=
savedInstanceState
.
getBoolean
(
SAVED_STATE_IN_BACKGROUND
false
)
;
if
(
!
wasInBackground
&
&
!
mIsRestoringActivity
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_WAS_KILLED
"
1
)
;
}
mPrivateBrowsingSession
=
savedInstanceState
.
getString
(
SAVED_STATE_PRIVATE_SESSION
)
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
String
restoreMessage
=
null
;
if
(
!
mIsRestoringActivity
&
&
mShouldRestore
)
{
final
boolean
isExternalURL
=
invokedWithExternalURL
(
getIntentURI
(
new
SafeIntent
(
getIntent
(
)
)
)
)
;
try
{
restoreMessage
=
restoreSessionTabs
(
isExternalURL
false
)
;
}
catch
(
SessionRestoreException
e
)
{
if
(
mShouldRestore
)
{
Log
.
e
(
LOGTAG
"
An
error
occurred
during
restore
switching
to
backup
file
"
e
)
;
if
(
getProfile
(
)
.
sessionFileExists
(
)
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_DAMAGED_SESSION_FILE
"
1
)
;
}
try
{
restoreMessage
=
restoreSessionTabs
(
isExternalURL
true
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_RESTORING_FROM_BACKUP
"
1
)
;
}
catch
(
SessionRestoreException
ex
)
{
if
(
!
mShouldRestore
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_SESSIONSTORE_RESTORING_FROM_BACKUP
"
1
)
;
}
else
{
Log
.
e
(
LOGTAG
"
An
error
occurred
during
restore
"
ex
)
;
mShouldRestore
=
false
;
}
}
}
}
}
synchronized
(
GeckoApp
.
this
)
{
mSessionRestoreParsingFinished
=
true
;
GeckoApp
.
this
.
notifyAll
(
)
;
}
if
(
!
mIsRestoringActivity
)
{
GeckoAppShell
.
notifyObservers
(
"
Session
:
Restore
"
restoreMessage
)
;
}
getProfile
(
)
.
updateSessionFile
(
mShouldRestore
)
;
}
}
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
SharedPreferences
prefs
=
GeckoApp
.
this
.
getSharedPreferences
(
)
;
final
LocaleManager
localeManager
=
BrowserLocaleManager
.
getInstance
(
)
;
localeManager
.
initialize
(
getApplicationContext
(
)
)
;
SessionInformation
previousSession
=
SessionInformation
.
fromSharedPrefs
(
prefs
)
;
if
(
previousSession
.
wasKilled
(
)
)
{
Telemetry
.
addToHistogram
(
"
FENNEC_WAS_KILLED
"
1
)
;
}
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoAppShell
.
PREFS_OOM_EXCEPTION
false
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
false
)
;
editor
.
apply
(
)
;
final
String
profilePath
=
getProfile
(
)
.
getDir
(
)
.
getAbsolutePath
(
)
;
final
EventDispatcher
dispatcher
=
getAppEventDispatcher
(
)
;
final
Locale
osLocale
=
Locale
.
getDefault
(
)
;
final
String
osLocaleString
=
osLocale
.
toString
(
)
;
String
appLocaleString
=
localeManager
.
getAndApplyPersistedLocale
(
GeckoApp
.
this
)
;
Log
.
d
(
LOGTAG
"
OS
locale
is
"
+
osLocaleString
+
"
app
locale
is
"
+
appLocaleString
)
;
if
(
appLocaleString
=
=
null
)
{
appLocaleString
=
osLocaleString
;
}
mHealthRecorder
=
GeckoApp
.
this
.
createHealthRecorder
(
GeckoApp
.
this
profilePath
dispatcher
osLocaleString
appLocaleString
previousSession
)
;
final
String
uiLocale
=
appLocaleString
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoApp
.
this
.
onLocaleReady
(
uiLocale
)
;
}
}
)
;
BrowserLocaleManager
.
storeAndNotifyOSLocale
(
GeckoSharedPrefs
.
forProfile
(
GeckoApp
.
this
)
osLocale
)
;
}
}
)
;
IntentHelper
.
init
(
this
)
;
}
Override
public
void
onStart
(
)
{
super
.
onStart
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
mWasFirstTabShownAfterActivityUnhidden
=
false
;
}
Override
protected
void
onStop
(
)
{
super
.
onStop
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
}
Override
public
void
onLocaleReady
(
final
String
locale
)
{
if
(
!
ThreadUtils
.
isOnUiThread
(
)
)
{
throw
new
RuntimeException
(
"
onLocaleReady
must
always
be
called
from
the
UI
thread
.
"
)
;
}
final
Locale
loc
=
Locales
.
parseLocaleCode
(
locale
)
;
if
(
loc
.
equals
(
mLastLocale
)
)
{
Log
.
d
(
LOGTAG
"
New
locale
same
as
old
;
onLocaleReady
has
nothing
to
do
.
"
)
;
}
BrowserLocaleManager
.
getInstance
(
)
.
updateConfiguration
(
GeckoApp
.
this
loc
)
;
ViewUtil
.
setLayoutDirection
(
getWindow
(
)
.
getDecorView
(
)
loc
)
;
refreshChrome
(
)
;
TextView
urlBar
=
(
TextView
)
findViewById
(
R
.
id
.
url_bar_title
)
;
if
(
urlBar
!
=
null
)
{
final
String
hint
=
getResources
(
)
.
getString
(
R
.
string
.
url_bar_default_text
)
;
urlBar
.
setHint
(
hint
)
;
}
else
{
Log
.
d
(
LOGTAG
"
No
URL
bar
in
GeckoApp
.
Not
loading
localized
hint
string
.
"
)
;
}
mLastLocale
=
loc
;
super
.
onConfigurationChanged
(
getResources
(
)
.
getConfiguration
(
)
)
;
}
protected
void
initializeChrome
(
)
{
mDoorHangerPopup
=
new
DoorHangerPopup
(
this
)
;
mPluginContainer
=
(
AbsoluteLayout
)
findViewById
(
R
.
id
.
plugin_container
)
;
mFormAssistPopup
=
(
FormAssistPopup
)
findViewById
(
R
.
id
.
form_assist_popup
)
;
}
protected
void
loadStartupTab
(
final
int
flags
String
action
)
{
if
(
!
mShouldRestore
|
|
Intent
.
ACTION_VIEW
.
equals
(
action
)
)
{
if
(
mLastSessionCrashed
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
AboutPages
.
getURLForBuiltinPanelType
(
PanelType
.
DEPRECATED_RECENT_TABS
)
flags
)
;
}
else
{
final
String
homepage
=
getHomepage
(
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
!
TextUtils
.
isEmpty
(
homepage
)
?
homepage
:
AboutPages
.
HOME
flags
)
;
}
}
}
protected
void
loadStartupTab
(
final
String
url
final
SafeIntent
intent
final
int
flags
)
{
if
(
url
=
=
null
)
{
loadStartupTab
(
flags
intent
.
getAction
(
)
)
;
return
;
}
Tabs
.
getInstance
(
)
.
loadUrlWithIntentExtras
(
url
intent
flags
)
;
}
public
String
getHomepage
(
)
{
return
null
;
}
private
String
getIntentURI
(
SafeIntent
intent
)
{
final
String
passedUri
;
final
String
uri
=
getURIFromIntent
(
intent
)
;
if
(
!
TextUtils
.
isEmpty
(
uri
)
)
{
passedUri
=
uri
;
}
else
{
passedUri
=
null
;
}
return
passedUri
;
}
private
boolean
invokedWithExternalURL
(
String
uri
)
{
return
uri
!
=
null
&
&
!
AboutPages
.
isAboutHome
(
uri
)
;
}
private
void
initialize
(
)
{
mInitialized
=
true
;
final
boolean
isFirstTab
=
!
mWasFirstTabShownAfterActivityUnhidden
;
mWasFirstTabShownAfterActivityUnhidden
=
true
;
final
SafeIntent
intent
=
new
SafeIntent
(
getIntent
(
)
)
;
final
String
action
=
intent
.
getAction
(
)
;
final
String
passedUri
=
getIntentURI
(
intent
)
;
final
boolean
isExternalURL
=
invokedWithExternalURL
(
passedUri
)
;
checkMigrateProfile
(
)
;
Tabs
.
registerOnTabsChangedListener
(
this
)
;
initializeChrome
(
)
;
synchronized
(
this
)
{
while
(
!
mSessionRestoreParsingFinished
)
{
try
{
wait
(
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
}
if
(
isExternalURL
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
null
Tabs
.
TabEvents
.
RESTORED
)
;
processActionViewIntent
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
int
flags
=
Tabs
.
LOADURL_NEW_TAB
|
Tabs
.
LOADURL_USER_ENTERED
|
Tabs
.
LOADURL_EXTERNAL
;
if
(
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
flags
|
=
Tabs
.
LOADURL_PINNED
;
}
if
(
isFirstTab
)
{
flags
|
=
Tabs
.
LOADURL_FIRST_AFTER_ACTIVITY_UNHIDDEN
;
}
loadStartupTab
(
passedUri
intent
flags
)
;
}
}
)
;
}
else
{
if
(
!
mIsRestoringActivity
)
{
loadStartupTab
(
Tabs
.
LOADURL_NEW_TAB
action
)
;
}
Tabs
.
getInstance
(
)
.
notifyListeners
(
null
Tabs
.
TabEvents
.
RESTORED
)
;
processTabQueue
(
)
;
}
recordStartupActionTelemetry
(
passedUri
action
)
;
if
(
ACTION_LAUNCH_SETTINGS
.
equals
(
action
)
)
{
Intent
settingsIntent
=
new
Intent
(
GeckoApp
.
this
GeckoPreferences
.
class
)
;
settingsIntent
.
putExtras
(
intent
.
getUnsafe
(
)
)
;
startActivity
(
settingsIntent
)
;
}
mAppStateListeners
=
new
LinkedList
<
GeckoAppShell
.
AppStateListener
>
(
)
;
mPromptService
=
new
PromptService
(
this
)
;
mJavaUiStartupTimer
.
stop
(
)
;
final
long
javaDuration
=
mJavaUiStartupTimer
.
getElapsed
(
)
;
ThreadUtils
.
getBackgroundHandler
(
)
.
postDelayed
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
recordJavaStartupTime
(
javaDuration
)
;
}
}
}
50
)
;
final
int
updateServiceDelay
=
30
*
1000
;
ThreadUtils
.
getBackgroundHandler
(
)
.
postDelayed
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
UpdateServiceHelper
.
registerForUpdates
(
GeckoAppShell
.
getApplicationContext
(
)
)
;
}
}
updateServiceDelay
)
;
if
(
mIsRestoringActivity
)
{
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
Tabs
.
getInstance
(
)
.
notifyListeners
(
selectedTab
Tabs
.
TabEvents
.
SELECTED
)
;
}
if
(
GeckoThread
.
isRunning
(
)
)
{
geckoConnected
(
)
;
if
(
mLayerView
!
=
null
)
{
mLayerView
.
setPaintState
(
LayerView
.
PAINT_BEFORE_FIRST
)
;
}
}
}
}
TargetApi
(
Build
.
VERSION_CODES
.
JELLY_BEAN
)
Override
public
void
onGlobalLayout
(
)
{
if
(
Versions
.
preJB
)
{
mMainLayout
.
getViewTreeObserver
(
)
.
removeGlobalOnLayoutListener
(
this
)
;
}
else
{
mMainLayout
.
getViewTreeObserver
(
)
.
removeOnGlobalLayoutListener
(
this
)
;
}
if
(
!
mInitialized
)
{
initialize
(
)
;
}
}
protected
void
processActionViewIntent
(
final
Runnable
openTabsRunnable
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
TabQueueHelper
.
shouldOpenTabQueueUrls
(
GeckoApp
.
this
)
)
{
getAppEventDispatcher
(
)
.
registerGeckoThreadListener
(
new
BundleEventListener
(
)
{
Override
public
void
handleMessage
(
String
event
GeckoBundle
message
EventCallback
callback
)
{
if
(
"
Tabs
:
TabsOpened
"
.
equals
(
event
)
)
{
getAppEventDispatcher
(
)
.
unregisterGeckoThreadListener
(
this
"
Tabs
:
TabsOpened
"
)
;
openTabsRunnable
.
run
(
)
;
}
}
}
"
Tabs
:
TabsOpened
"
)
;
TabQueueHelper
.
openQueuedUrls
(
GeckoApp
.
this
getProfile
(
)
TabQueueHelper
.
FILE_NAME
true
)
;
}
else
{
openTabsRunnable
.
run
(
)
;
}
}
}
)
;
}
WorkerThread
private
String
restoreSessionTabs
(
final
boolean
isExternalURL
boolean
useBackup
)
throws
SessionRestoreException
{
try
{
String
sessionString
=
getProfile
(
)
.
readSessionFile
(
useBackup
)
;
if
(
sessionString
=
=
null
)
{
throw
new
SessionRestoreException
(
"
Could
not
read
from
session
file
"
)
;
}
final
JSONArray
tabs
=
new
JSONArray
(
)
;
final
JSONObject
windowObject
=
new
JSONObject
(
)
;
final
boolean
sessionDataValid
;
LastSessionParser
parser
=
new
LastSessionParser
(
tabs
windowObject
isExternalURL
)
;
if
(
mPrivateBrowsingSession
=
=
null
)
{
sessionDataValid
=
parser
.
parse
(
sessionString
)
;
}
else
{
sessionDataValid
=
parser
.
parse
(
sessionString
mPrivateBrowsingSession
)
;
}
if
(
tabs
.
length
(
)
>
0
)
{
parser
.
updateParentId
(
tabs
)
;
windowObject
.
put
(
"
tabs
"
tabs
)
;
JSONArray
closedTabs
=
windowObject
.
optJSONArray
(
"
closedTabs
"
)
;
parser
.
updateParentId
(
closedTabs
)
;
windowObject
.
putOpt
(
"
closedTabs
"
closedTabs
)
;
sessionString
=
new
JSONObject
(
)
.
put
(
"
windows
"
new
JSONArray
(
)
.
put
(
windowObject
)
)
.
toString
(
)
;
}
else
{
if
(
parser
.
allTabsSkipped
(
)
|
|
sessionDataValid
)
{
mShouldRestore
=
false
;
}
throw
new
SessionRestoreException
(
"
No
tabs
could
be
read
from
session
file
"
)
;
}
JSONObject
restoreData
=
new
JSONObject
(
)
;
restoreData
.
put
(
"
sessionString
"
sessionString
)
;
return
restoreData
.
toString
(
)
;
}
catch
(
JSONException
e
)
{
throw
new
SessionRestoreException
(
e
)
;
}
}
RobocopTarget
public
static
EventDispatcher
getEventDispatcher
(
)
{
final
GeckoApp
geckoApp
=
(
GeckoApp
)
GeckoAppShell
.
getGeckoInterface
(
)
;
return
geckoApp
.
getAppEventDispatcher
(
)
;
}
Override
public
EventDispatcher
getAppEventDispatcher
(
)
{
return
mLayerView
!
=
null
?
mLayerView
.
getEventDispatcher
(
)
:
null
;
}
Override
public
GeckoProfile
getProfile
(
)
{
return
GeckoThread
.
getActiveProfile
(
)
;
}
protected
boolean
updateCrashedState
(
)
{
try
{
File
crashFlag
=
new
File
(
GeckoProfileDirectories
.
getMozillaDirectory
(
this
)
"
CRASHED
"
)
;
if
(
crashFlag
.
exists
(
)
&
&
crashFlag
.
delete
(
)
)
{
getSharedPreferences
(
)
.
edit
(
)
.
putBoolean
(
PREFS_WAS_STOPPED
true
)
.
apply
(
)
;
return
true
;
}
}
catch
(
NoMozillaDirectoryException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
read
crash
flag
:
"
e
)
;
}
return
false
;
}
protected
boolean
getSessionRestoreState
(
Bundle
savedInstanceState
)
{
final
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
boolean
shouldRestore
=
false
;
final
int
versionCode
=
getVersionCode
(
)
;
if
(
mLastSessionCrashed
)
{
if
(
incrementCrashCount
(
prefs
)
<
=
getSessionStoreMaxCrashResumes
(
prefs
)
&
&
getSessionRestoreAfterCrashPreference
(
prefs
)
)
{
shouldRestore
=
true
;
}
else
{
shouldRestore
=
false
;
}
}
else
if
(
prefs
.
getInt
(
PREFS_VERSION_CODE
0
)
!
=
versionCode
)
{
prefs
.
edit
(
)
.
putInt
(
PREFS_VERSION_CODE
versionCode
)
.
apply
(
)
;
shouldRestore
=
true
;
}
else
if
(
savedInstanceState
!
=
null
|
|
getSessionRestorePreference
(
prefs
)
.
equals
(
"
always
"
)
|
|
getRestartFromIntent
(
)
)
{
shouldRestore
=
true
;
}
return
shouldRestore
;
}
private
int
incrementCrashCount
(
SharedPreferences
prefs
)
{
final
int
crashCount
=
getSuccessiveCrashesCount
(
prefs
)
+
1
;
prefs
.
edit
(
)
.
putInt
(
PREFS_CRASHED_COUNT
crashCount
)
.
apply
(
)
;
return
crashCount
;
}
private
int
getSuccessiveCrashesCount
(
SharedPreferences
prefs
)
{
return
prefs
.
getInt
(
PREFS_CRASHED_COUNT
0
)
;
}
private
int
getSessionStoreMaxCrashResumes
(
SharedPreferences
prefs
)
{
return
prefs
.
getInt
(
GeckoPreferences
.
PREFS_RESTORE_SESSION_MAX_CRASH_RESUMES
1
)
;
}
private
boolean
getSessionRestoreAfterCrashPreference
(
SharedPreferences
prefs
)
{
return
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_RESTORE_SESSION_FROM_CRASH
true
)
;
}
private
String
getSessionRestorePreference
(
SharedPreferences
prefs
)
{
return
prefs
.
getString
(
GeckoPreferences
.
PREFS_RESTORE_SESSION
"
always
"
)
;
}
private
boolean
getRestartFromIntent
(
)
{
return
IntentUtils
.
getBooleanExtraSafe
(
getIntent
(
)
"
didRestart
"
false
)
;
}
private
void
enableStrictMode
(
)
{
Log
.
d
(
LOGTAG
"
Enabling
Android
StrictMode
"
)
;
StrictMode
.
setThreadPolicy
(
new
StrictMode
.
ThreadPolicy
.
Builder
(
)
.
detectAll
(
)
.
penaltyLog
(
)
.
build
(
)
)
;
StrictMode
.
setVmPolicy
(
new
StrictMode
.
VmPolicy
.
Builder
(
)
.
detectAll
(
)
.
penaltyLog
(
)
.
build
(
)
)
;
}
Override
public
void
enableOrientationListener
(
)
{
mCameraOrientationEventListener
=
new
OrientationEventListener
(
this
)
{
Override
public
void
onOrientationChanged
(
int
orientation
)
{
if
(
mAppStateListeners
!
=
null
)
{
for
(
GeckoAppShell
.
AppStateListener
listener
:
mAppStateListeners
)
{
listener
.
onOrientationChanged
(
)
;
}
}
}
}
;
mCameraOrientationEventListener
.
enable
(
)
;
}
Override
public
void
disableOrientationListener
(
)
{
if
(
mCameraOrientationEventListener
!
=
null
)
{
mCameraOrientationEventListener
.
disable
(
)
;
mCameraOrientationEventListener
=
null
;
}
}
Override
public
String
getDefaultUAString
(
)
{
return
HardwareUtils
.
isTablet
(
)
?
AppConstants
.
USER_AGENT_FENNEC_TABLET
:
AppConstants
.
USER_AGENT_FENNEC_MOBILE
;
}
Override
public
void
createShortcut
(
final
String
title
final
String
url
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
.
hasManifest
(
)
)
{
final
GeckoBundle
message
=
new
GeckoBundle
(
)
;
message
.
putInt
(
"
iconSize
"
GeckoAppShell
.
getPreferredIconSize
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Browser
:
LoadManifest
"
message
)
;
return
;
}
Icons
.
with
(
this
)
.
pageUrl
(
url
)
.
skipNetwork
(
)
.
skipMemory
(
)
.
forLauncherIcon
(
)
.
build
(
)
.
execute
(
new
IconCallback
(
)
{
Override
public
void
onIconResponse
(
IconResponse
response
)
{
createShortcut
(
title
url
response
.
getBitmap
(
)
)
;
}
}
)
;
}
public
void
createShortcut
(
final
String
aTitle
final
String
aURI
final
Bitmap
aIcon
)
{
Intent
shortcutIntent
=
new
Intent
(
)
;
shortcutIntent
.
setAction
(
GeckoApp
.
ACTION_HOMESCREEN_SHORTCUT
)
;
shortcutIntent
.
setData
(
Uri
.
parse
(
aURI
)
)
;
shortcutIntent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
Intent
intent
=
new
Intent
(
)
;
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_INTENT
shortcutIntent
)
;
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_ICON
getLauncherIcon
(
aIcon
GeckoAppShell
.
getPreferredIconSize
(
)
)
)
;
if
(
aTitle
!
=
null
)
{
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_NAME
aTitle
)
;
}
else
{
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_NAME
aURI
)
;
}
intent
.
putExtra
(
"
duplicate
"
false
)
;
intent
.
setAction
(
"
com
.
android
.
launcher
.
action
.
INSTALL_SHORTCUT
"
)
;
getApplicationContext
(
)
.
sendBroadcast
(
intent
)
;
final
UrlAnnotations
urlAnnotations
=
BrowserDB
.
from
(
getApplicationContext
(
)
)
.
getUrlAnnotations
(
)
;
urlAnnotations
.
insertHomeScreenShortcut
(
getContentResolver
(
)
aURI
true
)
;
ActivityUtils
.
goToHomeScreen
(
this
)
;
}
private
Bitmap
getLauncherIcon
(
Bitmap
aSource
int
size
)
{
final
float
[
]
DEFAULT_LAUNCHER_ICON_HSV
=
{
32
.
0f
1
.
0f
1
.
0f
}
;
final
int
kOffset
=
6
;
final
int
kRadius
=
5
;
int
insetSize
=
aSource
!
=
null
?
size
*
2
/
3
:
size
;
Bitmap
bitmap
=
Bitmap
.
createBitmap
(
size
size
Bitmap
.
Config
.
ARGB_8888
)
;
Canvas
canvas
=
new
Canvas
(
bitmap
)
;
Paint
paint
=
new
Paint
(
)
;
if
(
aSource
=
=
null
)
{
paint
.
setColor
(
Color
.
HSVToColor
(
DEFAULT_LAUNCHER_ICON_HSV
)
)
;
canvas
.
drawRoundRect
(
new
RectF
(
kOffset
kOffset
size
-
kOffset
size
-
kOffset
)
kRadius
kRadius
paint
)
;
}
else
if
(
aSource
.
getWidth
(
)
>
=
insetSize
|
|
aSource
.
getHeight
(
)
>
=
insetSize
)
{
Rect
iconBounds
=
new
Rect
(
0
0
size
size
)
;
canvas
.
drawBitmap
(
aSource
null
iconBounds
null
)
;
return
bitmap
;
}
else
{
int
color
=
BitmapUtils
.
getDominantColor
(
aSource
)
;
paint
.
setColor
(
color
)
;
canvas
.
drawRoundRect
(
new
RectF
(
kOffset
kOffset
size
-
kOffset
size
-
kOffset
)
kRadius
kRadius
paint
)
;
paint
.
setColor
(
Color
.
argb
(
100
255
255
255
)
)
;
canvas
.
drawRoundRect
(
new
RectF
(
kOffset
kOffset
size
-
kOffset
size
-
kOffset
)
kRadius
kRadius
paint
)
;
}
Bitmap
overlay
=
BitmapUtils
.
decodeResource
(
this
R
.
drawable
.
home_bg
)
;
canvas
.
drawBitmap
(
overlay
null
new
Rect
(
0
0
size
size
)
null
)
;
if
(
aSource
=
=
null
)
aSource
=
BitmapUtils
.
decodeResource
(
this
R
.
drawable
.
home_star
)
;
int
sWidth
=
insetSize
/
2
;
int
sHeight
=
sWidth
;
int
halfSize
=
size
/
2
;
canvas
.
drawBitmap
(
aSource
null
new
Rect
(
halfSize
-
sWidth
halfSize
-
sHeight
halfSize
+
sWidth
halfSize
+
sHeight
)
null
)
;
return
bitmap
;
}
Override
protected
void
onNewIntent
(
Intent
externalIntent
)
{
final
SafeIntent
intent
=
new
SafeIntent
(
externalIntent
)
;
final
boolean
isFirstTab
=
!
mWasFirstTabShownAfterActivityUnhidden
;
mWasFirstTabShownAfterActivityUnhidden
=
true
;
if
(
!
mInitialized
)
{
setIntent
(
externalIntent
)
;
return
;
}
final
String
action
=
intent
.
getAction
(
)
;
final
String
uri
=
getURIFromIntent
(
intent
)
;
final
String
passedUri
;
if
(
!
TextUtils
.
isEmpty
(
uri
)
)
{
passedUri
=
uri
;
}
else
{
passedUri
=
null
;
}
if
(
ACTION_LOAD
.
equals
(
action
)
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
intent
.
getDataString
(
)
)
;
lastSelectedTabId
=
-
1
;
}
else
if
(
Intent
.
ACTION_VIEW
.
equals
(
action
)
)
{
processActionViewIntent
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
String
url
=
intent
.
getDataString
(
)
;
int
flags
=
Tabs
.
LOADURL_NEW_TAB
|
Tabs
.
LOADURL_USER_ENTERED
|
Tabs
.
LOADURL_EXTERNAL
;
if
(
isFirstTab
)
{
flags
|
=
Tabs
.
LOADURL_FIRST_AFTER_ACTIVITY_UNHIDDEN
;
}
Tabs
.
getInstance
(
)
.
loadUrlWithIntentExtras
(
url
intent
flags
)
;
}
}
)
;
lastSelectedTabId
=
-
1
;
}
else
if
(
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
mLayerView
.
loadUri
(
uri
GeckoView
.
LOAD_SWITCH_TAB
)
;
}
else
if
(
Intent
.
ACTION_SEARCH
.
equals
(
action
)
)
{
mLayerView
.
loadUri
(
uri
GeckoView
.
LOAD_NEW_TAB
)
;
}
else
if
(
NotificationHelper
.
HELPER_BROADCAST_ACTION
.
equals
(
action
)
)
{
NotificationHelper
.
getInstance
(
getApplicationContext
(
)
)
.
handleNotificationIntent
(
intent
)
;
}
else
if
(
ACTION_LAUNCH_SETTINGS
.
equals
(
action
)
)
{
Intent
settingsIntent
=
new
Intent
(
GeckoApp
.
this
GeckoPreferences
.
class
)
;
settingsIntent
.
putExtras
(
intent
.
getUnsafe
(
)
)
;
startActivity
(
settingsIntent
)
;
}
else
if
(
ACTION_SWITCH_TAB
.
equals
(
action
)
)
{
final
int
tabId
=
intent
.
getIntExtra
(
"
TabId
"
-
1
)
;
Tabs
.
getInstance
(
)
.
selectTab
(
tabId
)
;
lastSelectedTabId
=
-
1
;
}
recordStartupActionTelemetry
(
passedUri
action
)
;
}
protected
String
getURIFromIntent
(
SafeIntent
intent
)
{
final
String
action
=
intent
.
getAction
(
)
;
if
(
ACTION_ALERT_CALLBACK
.
equals
(
action
)
|
|
NotificationHelper
.
HELPER_BROADCAST_ACTION
.
equals
(
action
)
)
{
return
null
;
}
return
intent
.
getDataString
(
)
;
}
protected
int
getOrientation
(
)
{
return
GeckoScreenOrientation
.
getInstance
(
)
.
getAndroidOrientation
(
)
;
}
Override
public
boolean
isForegrounded
(
)
{
return
foregrounded
;
}
Override
public
void
onResume
(
)
{
super
.
onResume
(
)
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
Snackbar
:
Show
"
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
foregrounded
=
true
;
GeckoAppShell
.
setGeckoInterface
(
this
)
;
GeckoAppShell
.
setScreenOrientationDelegate
(
this
)
;
if
(
lastSelectedTabId
>
=
0
&
&
(
lastActiveGeckoApp
=
=
null
|
|
lastActiveGeckoApp
.
get
(
)
!
=
this
)
)
{
Tabs
.
getInstance
(
)
.
selectTab
(
lastSelectedTabId
)
;
}
int
newOrientation
=
getResources
(
)
.
getConfiguration
(
)
.
orientation
;
if
(
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
newOrientation
)
)
{
refreshChrome
(
)
;
}
if
(
mAppStateListeners
!
=
null
)
{
for
(
GeckoAppShell
.
AppStateListener
listener
:
mAppStateListeners
)
{
listener
.
onResume
(
)
;
}
}
final
long
now
=
System
.
currentTimeMillis
(
)
;
final
long
realTime
=
android
.
os
.
SystemClock
.
elapsedRealtime
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
SessionInformation
currentSession
=
new
SessionInformation
(
now
realTime
)
;
SharedPreferences
prefs
=
GeckoApp
.
this
.
getSharedPreferences
(
)
;
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
false
)
;
if
(
!
mLastSessionCrashed
)
{
editor
.
putInt
(
GeckoApp
.
PREFS_CRASHED_COUNT
0
)
;
}
currentSession
.
recordBegin
(
editor
)
;
editor
.
apply
(
)
;
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
setCurrentSession
(
currentSession
)
;
rec
.
processDelayed
(
)
;
}
else
{
Log
.
w
(
LOGTAG
"
Can
'
t
record
session
:
rec
is
null
.
"
)
;
}
}
}
)
;
Restrictions
.
update
(
this
)
;
}
Override
public
void
onWindowFocusChanged
(
boolean
hasFocus
)
{
super
.
onWindowFocusChanged
(
hasFocus
)
;
if
(
!
mWindowFocusInitialized
&
&
hasFocus
)
{
mWindowFocusInitialized
=
true
;
mLayerView
.
setFocusable
(
false
)
;
mLayerView
.
setFocusable
(
true
)
;
mLayerView
.
setFocusableInTouchMode
(
true
)
;
getWindow
(
)
.
setBackgroundDrawable
(
null
)
;
}
}
Override
public
void
onPause
(
)
{
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
"
Snackbar
:
Show
"
)
;
if
(
mIsAbortingAppLaunch
)
{
super
.
onPause
(
)
;
return
;
}
foregrounded
=
false
;
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
lastSelectedTabId
=
selectedTab
.
getId
(
)
;
}
lastActiveGeckoApp
=
new
WeakReference
<
GeckoApp
>
(
this
)
;
final
HealthRecorder
rec
=
mHealthRecorder
;
final
Context
context
=
this
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
SharedPreferences
prefs
=
GeckoApp
.
this
.
getSharedPreferences
(
)
;
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
true
)
;
if
(
rec
!
=
null
)
{
rec
.
recordSessionEnd
(
"
P
"
editor
)
;
}
mLastSessionCrashed
=
false
;
if
(
prefs
.
getBoolean
(
GeckoApp
.
PREFS_CLEANUP_TEMP_FILES
true
)
)
{
File
tempDir
=
GeckoLoader
.
getGREDir
(
GeckoApp
.
this
)
;
FileUtils
.
delTree
(
tempDir
new
FileUtils
.
NameAndAgeFilter
(
null
ONE_DAY_MS
)
false
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_CLEANUP_TEMP_FILES
false
)
;
}
editor
.
apply
(
)
;
}
}
)
;
if
(
mAppStateListeners
!
=
null
)
{
for
(
GeckoAppShell
.
AppStateListener
listener
:
mAppStateListeners
)
{
listener
.
onPause
(
)
;
}
}
super
.
onPause
(
)
;
}
Override
public
void
onRestart
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onRestart
(
)
;
return
;
}
final
StrictMode
.
ThreadPolicy
savedPolicy
=
StrictMode
.
allowThreadDiskReads
(
)
;
try
{
SharedPreferences
.
Editor
editor
=
GeckoApp
.
this
.
getSharedPreferences
(
)
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_WAS_STOPPED
false
)
;
editor
.
apply
(
)
;
}
finally
{
StrictMode
.
setThreadPolicy
(
savedPolicy
)
;
}
super
.
onRestart
(
)
;
}
Override
public
void
onDestroy
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onDestroy
(
)
;
return
;
}
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
this
"
Accessibility
:
Ready
"
"
Gecko
:
Exited
"
"
Gecko
:
Ready
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
"
Sanitize
:
Finished
"
null
)
;
getAppEventDispatcher
(
)
.
unregisterGeckoThreadListener
(
this
"
Accessibility
:
Event
"
"
Locale
:
Set
"
null
)
;
getAppEventDispatcher
(
)
.
unregisterBackgroundThreadListener
(
this
"
Bookmark
:
Insert
"
"
Image
:
SetAs
"
null
)
;
getAppEventDispatcher
(
)
.
unregisterUiThreadListener
(
this
"
Contact
:
Add
"
"
DevToolsAuth
:
Scan
"
"
DOMFullScreen
:
Start
"
"
DOMFullScreen
:
Stop
"
"
Permissions
:
Data
"
"
PrivateBrowsing
:
Data
"
"
RuntimePermissions
:
Prompt
"
"
Share
:
Text
"
"
SystemUI
:
Visibility
"
"
ToggleChrome
:
Focus
"
"
ToggleChrome
:
Hide
"
"
ToggleChrome
:
Show
"
"
Update
:
Check
"
"
Update
:
Download
"
"
Update
:
Install
"
null
)
;
if
(
mPromptService
!
=
null
)
mPromptService
.
destroy
(
)
;
final
HealthRecorder
rec
=
mHealthRecorder
;
mHealthRecorder
=
null
;
if
(
rec
!
=
null
&
&
rec
.
isEnabled
(
)
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
rec
.
close
(
GeckoApp
.
this
)
;
}
}
)
;
}
super
.
onDestroy
(
)
;
Tabs
.
unregisterOnTabsChangedListener
(
this
)
;
}
public
void
showSDKVersionError
(
)
{
final
String
message
=
getString
(
R
.
string
.
unsupported_sdk_version
Build
.
CPU_ABI
Integer
.
toString
(
Build
.
VERSION
.
SDK_INT
)
)
;
Toast
.
makeText
(
this
message
Toast
.
LENGTH_LONG
)
.
show
(
)
;
}
public
static
File
getTempDirectory
(
NonNull
Context
context
)
{
return
context
.
getApplicationContext
(
)
.
getExternalFilesDir
(
"
temp
"
)
;
}
public
static
void
deleteTempFiles
(
Context
context
)
{
File
dir
=
getTempDirectory
(
context
)
;
if
(
dir
=
=
null
)
return
;
File
[
]
files
=
dir
.
listFiles
(
)
;
if
(
files
=
=
null
)
return
;
for
(
File
file
:
files
)
{
file
.
delete
(
)
;
}
}
Override
public
void
onConfigurationChanged
(
Configuration
newConfig
)
{
Log
.
d
(
LOGTAG
"
onConfigurationChanged
:
"
+
newConfig
.
locale
)
;
final
LocaleManager
localeManager
=
BrowserLocaleManager
.
getInstance
(
)
;
final
Locale
changed
=
localeManager
.
onSystemConfigurationChanged
(
this
getResources
(
)
newConfig
mLastLocale
)
;
if
(
changed
!
=
null
)
{
onLocaleChanged
(
Locales
.
getLanguageTag
(
changed
)
)
;
}
if
(
GeckoScreenOrientation
.
getInstance
(
)
.
update
(
newConfig
.
orientation
)
)
{
if
(
mFormAssistPopup
!
=
null
)
mFormAssistPopup
.
hide
(
)
;
refreshChrome
(
)
;
}
super
.
onConfigurationChanged
(
newConfig
)
;
}
public
String
getContentProcessName
(
)
{
return
AppConstants
.
MOZ_CHILD_PROCESS_NAME
;
}
public
void
addEnvToIntent
(
Intent
intent
)
{
Map
<
String
String
>
envMap
=
System
.
getenv
(
)
;
Set
<
Map
.
Entry
<
String
String
>
>
envSet
=
envMap
.
entrySet
(
)
;
Iterator
<
Map
.
Entry
<
String
String
>
>
envIter
=
envSet
.
iterator
(
)
;
int
c
=
0
;
while
(
envIter
.
hasNext
(
)
)
{
Map
.
Entry
<
String
String
>
entry
=
envIter
.
next
(
)
;
intent
.
putExtra
(
"
env
"
+
c
entry
.
getKey
(
)
+
"
=
"
+
entry
.
getValue
(
)
)
;
c
+
+
;
}
}
Override
public
void
doRestart
(
)
{
doRestart
(
null
null
)
;
}
public
void
doRestart
(
String
args
)
{
doRestart
(
args
null
)
;
}
public
void
doRestart
(
Intent
intent
)
{
doRestart
(
null
intent
)
;
}
public
void
doRestart
(
String
args
Intent
restartIntent
)
{
if
(
restartIntent
=
=
null
)
{
restartIntent
=
new
Intent
(
Intent
.
ACTION_MAIN
)
;
}
if
(
args
!
=
null
)
{
restartIntent
.
putExtra
(
"
args
"
args
)
;
}
mRestartIntent
=
restartIntent
;
Log
.
d
(
LOGTAG
"
doRestart
(
\
"
"
+
restartIntent
+
"
\
"
)
"
)
;
doShutdown
(
)
;
}
private
void
doShutdown
(
)
{
runOnUiThread
(
new
Runnable
(
)
{
TargetApi
(
Build
.
VERSION_CODES
.
JELLY_BEAN_MR1
)
Override
public
void
run
(
)
{
if
(
!
isFinishing
(
)
&
&
(
Versions
.
preJBMR1
|
|
!
isDestroyed
(
)
)
)
{
finish
(
)
;
}
}
}
)
;
}
private
void
checkMigrateProfile
(
)
{
final
File
profileDir
=
getProfile
(
)
.
getDir
(
)
;
if
(
profileDir
!
=
null
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Handler
handler
=
new
Handler
(
)
;
handler
.
postDelayed
(
new
DeferredCleanupTask
(
)
CLEANUP_DEFERRAL_SECONDS
*
1000
)
;
}
}
)
;
}
}
private
static
class
DeferredCleanupTask
implements
Runnable
{
private
static
final
String
CLEANUP_VERSION
=
"
cleanup
-
version
"
;
private
static
final
int
CURRENT_CLEANUP_VERSION
=
1
;
Override
public
void
run
(
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
long
cleanupVersion
=
GeckoSharedPrefs
.
forApp
(
context
)
.
getInt
(
CLEANUP_VERSION
0
)
;
if
(
cleanupVersion
<
1
)
{
File
dir
=
new
File
(
"
res
/
fonts
"
)
;
if
(
dir
.
exists
(
)
&
&
dir
.
isDirectory
(
)
)
{
for
(
File
file
:
dir
.
listFiles
(
)
)
{
if
(
file
.
isFile
(
)
&
&
file
.
getName
(
)
.
endsWith
(
"
.
ttf
"
)
)
{
file
.
delete
(
)
;
}
}
if
(
!
dir
.
delete
(
)
)
{
Log
.
w
(
LOGTAG
"
unable
to
delete
res
/
fonts
directory
(
not
empty
?
)
"
)
;
}
}
}
if
(
cleanupVersion
!
=
CURRENT_CLEANUP_VERSION
)
{
SharedPreferences
.
Editor
editor
=
GeckoSharedPrefs
.
forApp
(
context
)
.
edit
(
)
;
editor
.
putInt
(
CLEANUP_VERSION
CURRENT_CLEANUP_VERSION
)
;
editor
.
apply
(
)
;
}
}
}
protected
void
onDone
(
)
{
moveTaskToBack
(
true
)
;
}
Override
public
void
onBackPressed
(
)
{
if
(
getSupportFragmentManager
(
)
.
getBackStackEntryCount
(
)
>
0
)
{
super
.
onBackPressed
(
)
;
return
;
}
if
(
autoHideTabs
(
)
)
{
return
;
}
if
(
mDoorHangerPopup
!
=
null
&
&
mDoorHangerPopup
.
isShowing
(
)
)
{
mDoorHangerPopup
.
dismiss
(
)
;
return
;
}
if
(
mFullScreenPluginView
!
=
null
)
{
GeckoAppShell
.
onFullScreenPluginHidden
(
mFullScreenPluginView
)
;
removeFullScreenPluginView
(
mFullScreenPluginView
)
;
return
;
}
if
(
mLayerView
!
=
null
&
&
mLayerView
.
isFullScreen
(
)
)
{
GeckoAppShell
.
notifyObservers
(
"
FullScreen
:
Exit
"
null
)
;
return
;
}
final
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
final
Tab
tab
=
tabs
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
)
{
onDone
(
)
;
return
;
}
GeckoAppShell
.
sendRequestToGecko
(
new
GeckoRequest
(
"
Browser
:
OnBackPressed
"
null
)
{
Override
public
void
onResponse
(
NativeJSObject
nativeJSObject
)
{
if
(
!
nativeJSObject
.
getBoolean
(
"
handled
"
)
)
{
onDefault
(
)
;
}
}
Override
public
void
onError
(
NativeJSObject
error
)
{
onDefault
(
)
;
}
private
void
onDefault
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
tab
.
doBack
(
)
)
{
return
;
}
if
(
tab
.
isExternal
(
)
)
{
onDone
(
)
;
Tab
nextSelectedTab
=
Tabs
.
getInstance
(
)
.
getNextTab
(
tab
)
;
if
(
nextSelectedTab
!
=
null
)
{
int
nextSelectedTabId
=
nextSelectedTab
.
getId
(
)
;
GeckoAppShell
.
notifyObservers
(
"
Tab
:
KeepZombified
"
Integer
.
toString
(
nextSelectedTabId
)
)
;
}
tabs
.
closeTab
(
tab
)
;
return
;
}
final
int
parentId
=
tab
.
getParentId
(
)
;
final
Tab
parent
=
tabs
.
getTab
(
parentId
)
;
if
(
parent
!
=
null
)
{
tabs
.
closeTab
(
tab
parent
)
;
return
;
}
onDone
(
)
;
}
}
)
;
}
}
)
;
}
Override
protected
void
onActivityResult
(
int
requestCode
int
resultCode
Intent
data
)
{
if
(
!
ActivityHandlerHelper
.
handleActivityResult
(
requestCode
resultCode
data
)
)
{
super
.
onActivityResult
(
requestCode
resultCode
data
)
;
}
}
Override
public
void
onRequestPermissionsResult
(
int
requestCode
String
[
]
permissions
int
[
]
grantResults
)
{
Permissions
.
onRequestPermissionsResult
(
this
permissions
grantResults
)
;
}
Override
public
AbsoluteLayout
getPluginContainer
(
)
{
return
mPluginContainer
;
}
private
static
final
String
CPU
=
"
cpu
"
;
private
static
final
String
SCREEN
=
"
screen
"
;
Override
SuppressLint
(
"
Wakelock
"
)
public
void
notifyWakeLockChanged
(
String
topic
String
state
)
{
PowerManager
.
WakeLock
wl
=
mWakeLocks
.
get
(
topic
)
;
if
(
state
.
equals
(
"
locked
-
foreground
"
)
&
&
wl
=
=
null
)
{
PowerManager
pm
=
(
PowerManager
)
getSystemService
(
Context
.
POWER_SERVICE
)
;
if
(
CPU
.
equals
(
topic
)
)
{
wl
=
pm
.
newWakeLock
(
PowerManager
.
PARTIAL_WAKE_LOCK
topic
)
;
}
else
if
(
SCREEN
.
equals
(
topic
)
)
{
wl
=
pm
.
newWakeLock
(
PowerManager
.
SCREEN_BRIGHT_WAKE_LOCK
|
PowerManager
.
ON_AFTER_RELEASE
topic
)
;
}
if
(
wl
!
=
null
)
{
wl
.
acquire
(
)
;
mWakeLocks
.
put
(
topic
wl
)
;
}
}
else
if
(
!
state
.
equals
(
"
locked
-
foreground
"
)
&
&
wl
!
=
null
)
{
wl
.
release
(
)
;
mWakeLocks
.
remove
(
topic
)
;
}
}
Override
public
void
notifyCheckUpdateResult
(
String
result
)
{
GeckoAppShell
.
notifyObservers
(
"
Update
:
CheckResult
"
result
)
;
}
private
void
geckoConnected
(
)
{
mLayerView
.
setOverScrollMode
(
View
.
OVER_SCROLL_NEVER
)
;
}
Override
public
void
setAccessibilityEnabled
(
boolean
enabled
)
{
}
Override
public
boolean
openUriExternal
(
String
targetURI
String
mimeType
String
packageName
String
className
String
action
String
title
)
{
return
IntentHelper
.
openUriExternal
(
targetURI
mimeType
packageName
className
action
title
true
)
;
}
public
static
class
MainLayout
extends
RelativeLayout
{
private
TouchEventInterceptor
mTouchEventInterceptor
;
private
MotionEventInterceptor
mMotionEventInterceptor
;
public
MainLayout
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
}
Override
protected
void
onLayout
(
boolean
changed
int
left
int
top
int
right
int
bottom
)
{
super
.
onLayout
(
changed
left
top
right
bottom
)
;
}
public
void
setTouchEventInterceptor
(
TouchEventInterceptor
interceptor
)
{
mTouchEventInterceptor
=
interceptor
;
}
public
void
setMotionEventInterceptor
(
MotionEventInterceptor
interceptor
)
{
mMotionEventInterceptor
=
interceptor
;
}
Override
public
boolean
onInterceptTouchEvent
(
MotionEvent
event
)
{
if
(
mTouchEventInterceptor
!
=
null
&
&
mTouchEventInterceptor
.
onInterceptTouchEvent
(
this
event
)
)
{
return
true
;
}
return
super
.
onInterceptTouchEvent
(
event
)
;
}
Override
public
boolean
onTouchEvent
(
MotionEvent
event
)
{
if
(
mTouchEventInterceptor
!
=
null
&
&
mTouchEventInterceptor
.
onTouch
(
this
event
)
)
{
return
true
;
}
return
super
.
onTouchEvent
(
event
)
;
}
Override
public
boolean
onGenericMotionEvent
(
MotionEvent
event
)
{
if
(
mMotionEventInterceptor
!
=
null
&
&
mMotionEventInterceptor
.
onInterceptMotionEvent
(
this
event
)
)
{
return
true
;
}
return
super
.
onGenericMotionEvent
(
event
)
;
}
Override
public
void
setDrawingCacheEnabled
(
boolean
enabled
)
{
super
.
setChildrenDrawnWithCacheEnabled
(
enabled
)
;
}
}
private
class
FullScreenHolder
extends
FrameLayout
{
public
FullScreenHolder
(
Context
ctx
)
{
super
(
ctx
)
;
setBackgroundColor
(
0xff000000
)
;
}
Override
public
void
addView
(
View
view
int
index
)
{
super
.
addView
(
view
index
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mLayerView
.
hideSurface
(
)
;
}
}
)
;
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
if
(
event
.
isSystem
(
)
)
{
return
super
.
onKeyDown
(
keyCode
event
)
;
}
mFullScreenPluginView
.
onKeyDown
(
keyCode
event
)
;
return
true
;
}
Override
public
boolean
onKeyUp
(
int
keyCode
KeyEvent
event
)
{
if
(
event
.
isSystem
(
)
)
{
return
super
.
onKeyUp
(
keyCode
event
)
;
}
mFullScreenPluginView
.
onKeyUp
(
keyCode
event
)
;
return
true
;
}
Override
public
boolean
onTouchEvent
(
MotionEvent
event
)
{
return
true
;
}
Override
public
boolean
onTrackballEvent
(
MotionEvent
event
)
{
mFullScreenPluginView
.
onTrackballEvent
(
event
)
;
return
true
;
}
}
private
int
getVersionCode
(
)
{
int
versionCode
=
0
;
try
{
versionCode
=
getPackageManager
(
)
.
getPackageInfo
(
getPackageName
(
)
0
)
.
versionCode
;
}
catch
(
NameNotFoundException
e
)
{
Log
.
wtf
(
LOGTAG
getPackageName
(
)
+
"
not
found
"
e
)
;
}
return
versionCode
;
}
private
static
final
String
SESSION_END_LOCALE_CHANGED
=
"
L
"
;
protected
void
onLocaleChanged
(
final
String
locale
)
{
final
boolean
startNewSession
=
true
;
final
boolean
shouldRestart
=
false
;
final
HealthRecorder
rec
=
mHealthRecorder
;
if
(
rec
!
=
null
)
{
rec
.
onAppLocaleChanged
(
locale
)
;
rec
.
onEnvironmentChanged
(
startNewSession
SESSION_END_LOCALE_CHANGED
)
;
}
if
(
!
shouldRestart
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoApp
.
this
.
onLocaleReady
(
locale
)
;
}
}
)
;
return
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoApp
.
this
.
doRestart
(
)
;
}
}
)
;
}
protected
void
setLocale
(
final
String
locale
)
{
if
(
locale
=
=
null
)
{
return
;
}
final
String
resultant
=
BrowserLocaleManager
.
getInstance
(
)
.
setSelectedLocale
(
this
locale
)
;
if
(
resultant
=
=
null
)
{
return
;
}
onLocaleChanged
(
resultant
)
;
}
protected
HealthRecorder
createHealthRecorder
(
final
Context
context
final
String
profilePath
final
EventDispatcher
dispatcher
final
String
osLocale
final
String
appLocale
final
SessionInformation
previousSession
)
{
return
new
StubbedHealthRecorder
(
)
;
}
protected
void
recordStartupActionTelemetry
(
final
String
passedURL
final
String
action
)
{
}
Override
public
void
checkUriVisited
(
String
uri
)
{
GlobalHistory
.
getInstance
(
)
.
checkUriVisited
(
uri
)
;
}
Override
public
void
markUriVisited
(
final
String
uri
)
{
final
Context
context
=
getApplicationContext
(
)
;
final
BrowserDB
db
=
BrowserDB
.
from
(
context
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GlobalHistory
.
getInstance
(
)
.
add
(
context
db
uri
)
;
}
}
)
;
}
Override
public
void
setUriTitle
(
final
String
uri
final
String
title
)
{
final
Context
context
=
getApplicationContext
(
)
;
final
BrowserDB
db
=
BrowserDB
.
from
(
context
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GlobalHistory
.
getInstance
(
)
.
update
(
context
.
getContentResolver
(
)
db
uri
title
)
;
}
}
)
;
}
Override
public
String
[
]
getHandlersForMimeType
(
String
mimeType
String
action
)
{
Intent
intent
=
IntentHelper
.
getIntentForActionString
(
action
)
;
if
(
mimeType
!
=
null
&
&
mimeType
.
length
(
)
>
0
)
intent
.
setType
(
mimeType
)
;
return
IntentHelper
.
getHandlersForIntent
(
intent
)
;
}
Override
public
String
[
]
getHandlersForURL
(
String
url
String
action
)
{
Uri
uri
=
url
.
indexOf
(
'
:
'
)
>
=
0
?
Uri
.
parse
(
url
)
:
new
Uri
.
Builder
(
)
.
scheme
(
url
)
.
build
(
)
;
Intent
intent
=
IntentHelper
.
getOpenURIIntent
(
getApplicationContext
(
)
uri
.
toString
(
)
"
"
TextUtils
.
isEmpty
(
action
)
?
Intent
.
ACTION_VIEW
:
action
"
"
)
;
return
IntentHelper
.
getHandlersForIntent
(
intent
)
;
}
Override
public
String
getDefaultChromeURI
(
)
{
return
null
;
}
public
GeckoView
getGeckoView
(
)
{
return
mLayerView
;
}
Override
public
boolean
setRequestedOrientationForCurrentActivity
(
int
requestedActivityInfoOrientation
)
{
if
(
getRequestedOrientation
(
)
=
=
requestedActivityInfoOrientation
)
{
return
false
;
}
setRequestedOrientation
(
requestedActivityInfoOrientation
)
;
return
true
;
}
Override
public
boolean
isOfficial
(
)
{
return
AppConstants
.
MOZILLA_OFFICIAL
;
}
}
