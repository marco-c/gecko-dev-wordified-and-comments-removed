package
org
.
mozilla
.
gecko
.
tabqueue
;
import
android
.
app
.
NotificationManager
;
import
android
.
app
.
PendingIntent
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
res
.
Resources
;
import
android
.
graphics
.
PixelFormat
;
import
android
.
support
.
v4
.
app
.
NotificationCompat
;
import
android
.
support
.
v4
.
content
.
ContextCompat
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
view
.
View
;
import
android
.
view
.
WindowManager
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoApplication
;
import
org
.
mozilla
.
gecko
.
GeckoProfile
;
import
org
.
mozilla
.
gecko
.
GeckoSharedPrefs
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
public
class
TabQueueHelper
{
private
static
final
String
LOGTAG
=
"
Gecko
"
+
TabQueueHelper
.
class
.
getSimpleName
(
)
;
public
static
final
boolean
TAB_QUEUE_ENABLED
=
true
;
public
static
final
String
FILE_NAME
=
"
tab_queue_url_list
.
json
"
;
public
static
final
String
LOAD_URLS_ACTION
=
"
TAB_QUEUE_LOAD_URLS_ACTION
"
;
public
static
final
int
TAB_QUEUE_NOTIFICATION_ID
=
R
.
id
.
tabQueueNotification
;
public
static
final
String
PREF_TAB_QUEUE_COUNT
=
"
tab_queue_count
"
;
public
static
final
String
PREF_TAB_QUEUE_LAUNCHES
=
"
tab_queue_launches
"
;
public
static
final
String
PREF_TAB_QUEUE_TIMES_PROMPT_SHOWN
=
"
tab_queue_times_prompt_shown
"
;
public
static
final
int
MAX_TIMES_TO_SHOW_PROMPT
=
3
;
public
static
final
int
EXTERNAL_LAUNCHES_BEFORE_SHOWING_PROMPT
=
3
;
private
static
final
int
MAX_NOTIFICATION_DISPLAY_COUNT
=
8
;
public
static
final
int
TAB_QUEUE_YES
=
201
;
public
static
final
int
TAB_QUEUE_NO
=
202
;
public
static
boolean
canDrawOverlays
(
Context
context
)
{
if
(
AppConstants
.
Versions
.
preMarshmallow
)
{
return
true
;
}
View
view
=
new
View
(
context
)
;
view
.
setVisibility
(
View
.
INVISIBLE
)
;
WindowManager
.
LayoutParams
layoutParams
=
new
WindowManager
.
LayoutParams
(
1
1
AppConstants
.
Versions
.
preO
?
WindowManager
.
LayoutParams
.
TYPE_PHONE
:
WindowManager
.
LayoutParams
.
TYPE_APPLICATION_OVERLAY
WindowManager
.
LayoutParams
.
FLAG_NOT_FOCUSABLE
|
WindowManager
.
LayoutParams
.
FLAG_NOT_TOUCHABLE
PixelFormat
.
TRANSLUCENT
)
;
WindowManager
windowManager
=
(
WindowManager
)
context
.
getSystemService
(
Context
.
WINDOW_SERVICE
)
;
try
{
windowManager
.
addView
(
view
layoutParams
)
;
windowManager
.
removeView
(
view
)
;
return
true
;
}
catch
(
final
SecurityException
|
WindowManager
.
BadTokenException
e
)
{
return
false
;
}
}
public
static
boolean
shouldShowTabQueuePrompt
(
Context
context
)
{
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
int
numberOfTimesTabQueuePromptSeen
=
prefs
.
getInt
(
PREF_TAB_QUEUE_TIMES_PROMPT_SHOWN
0
)
;
if
(
isTabQueueEnabled
(
prefs
)
|
|
numberOfTimesTabQueuePromptSeen
>
=
MAX_TIMES_TO_SHOW_PROMPT
)
{
return
false
;
}
final
int
viewActionIntentLaunches
=
prefs
.
getInt
(
PREF_TAB_QUEUE_LAUNCHES
0
)
+
1
;
if
(
viewActionIntentLaunches
<
EXTERNAL_LAUNCHES_BEFORE_SHOWING_PROMPT
)
{
prefs
.
edit
(
)
.
putInt
(
PREF_TAB_QUEUE_LAUNCHES
viewActionIntentLaunches
)
.
apply
(
)
;
}
else
if
(
viewActionIntentLaunches
=
=
EXTERNAL_LAUNCHES_BEFORE_SHOWING_PROMPT
)
{
final
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
remove
(
TabQueueHelper
.
PREF_TAB_QUEUE_LAUNCHES
)
;
int
timesPromptShown
=
prefs
.
getInt
(
TabQueueHelper
.
PREF_TAB_QUEUE_TIMES_PROMPT_SHOWN
0
)
+
1
;
editor
.
putInt
(
TabQueueHelper
.
PREF_TAB_QUEUE_TIMES_PROMPT_SHOWN
timesPromptShown
)
;
editor
.
apply
(
)
;
return
true
;
}
return
false
;
}
public
static
int
queueURL
(
final
GeckoProfile
profile
final
String
url
final
String
filename
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
JSONArray
jsonArray
=
profile
.
readJSONArrayFromFile
(
filename
)
;
jsonArray
.
put
(
url
)
;
profile
.
writeFile
(
filename
jsonArray
.
toString
(
)
)
;
return
jsonArray
.
length
(
)
;
}
public
static
int
removeURLFromFile
(
final
Context
context
final
String
urlToRemove
final
String
filename
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
final
GeckoProfile
profile
=
GeckoProfile
.
get
(
context
)
;
JSONArray
jsonArray
=
profile
.
readJSONArrayFromFile
(
filename
)
;
JSONArray
newArray
=
new
JSONArray
(
)
;
String
url
;
for
(
int
i
=
0
;
i
<
jsonArray
.
length
(
)
;
i
+
+
)
{
try
{
url
=
jsonArray
.
getString
(
i
)
;
}
catch
(
JSONException
e
)
{
url
=
"
"
;
}
if
(
!
TextUtils
.
isEmpty
(
url
)
&
&
!
urlToRemove
.
equals
(
url
)
)
{
newArray
.
put
(
url
)
;
}
}
profile
.
writeFile
(
filename
newArray
.
toString
(
)
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
prefs
.
edit
(
)
.
putInt
(
PREF_TAB_QUEUE_COUNT
newArray
.
length
(
)
)
.
apply
(
)
;
return
newArray
.
length
(
)
;
}
public
static
List
<
String
>
getLastURLs
(
final
Context
context
final
String
filename
)
{
final
GeckoProfile
profile
=
GeckoProfile
.
get
(
context
)
;
final
JSONArray
jsonArray
=
profile
.
readJSONArrayFromFile
(
filename
)
;
final
int
tabCount
=
Math
.
min
(
MAX_NOTIFICATION_DISPLAY_COUNT
jsonArray
.
length
(
)
)
;
final
List
<
String
>
urls
=
new
ArrayList
<
>
(
tabCount
)
;
for
(
int
i
=
0
;
i
<
tabCount
;
i
+
+
)
{
try
{
urls
.
add
(
jsonArray
.
getString
(
i
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
w
(
LOGTAG
"
Unable
to
parse
URL
from
tab
queue
array
"
e
)
;
}
}
return
urls
;
}
SuppressWarnings
(
"
NewApi
"
)
public
static
void
showNotification
(
final
Context
context
final
int
tabsQueued
final
List
<
String
>
urls
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
Intent
resultIntent
=
new
Intent
(
)
;
resultIntent
.
setClassName
(
context
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
resultIntent
.
setAction
(
TabQueueHelper
.
LOAD_URLS_ACTION
)
;
PendingIntent
pendingIntent
=
PendingIntent
.
getActivity
(
context
0
resultIntent
PendingIntent
.
FLAG_CANCEL_CURRENT
)
;
final
String
text
;
final
Resources
resources
=
context
.
getResources
(
)
;
if
(
tabsQueued
=
=
1
)
{
text
=
resources
.
getString
(
R
.
string
.
tab_queue_notification_text_singular
)
;
}
else
{
text
=
resources
.
getString
(
R
.
string
.
tab_queue_notification_text_plural
tabsQueued
)
;
}
NotificationCompat
.
InboxStyle
inboxStyle
=
new
NotificationCompat
.
InboxStyle
(
)
;
inboxStyle
.
setBigContentTitle
(
text
)
;
for
(
String
url
:
urls
)
{
inboxStyle
.
addLine
(
url
)
;
}
inboxStyle
.
setSummaryText
(
resources
.
getString
(
R
.
string
.
tab_queue_notification_title
)
)
;
NotificationCompat
.
Builder
builder
=
new
NotificationCompat
.
Builder
(
context
)
.
setSmallIcon
(
R
.
drawable
.
ic_status_logo
)
.
setContentTitle
(
text
)
.
setContentText
(
resources
.
getString
(
R
.
string
.
tab_queue_notification_title
)
)
.
setStyle
(
inboxStyle
)
.
setColor
(
ContextCompat
.
getColor
(
context
R
.
color
.
fennec_ui_accent
)
)
.
setNumber
(
tabsQueued
)
.
setContentIntent
(
pendingIntent
)
;
if
(
!
AppConstants
.
Versions
.
preO
)
{
builder
.
setChannelId
(
GeckoApplication
.
getDefaultNotificationChannel
(
)
.
getId
(
)
)
;
}
NotificationManager
notificationManager
=
(
NotificationManager
)
context
.
getSystemService
(
Context
.
NOTIFICATION_SERVICE
)
;
notificationManager
.
notify
(
TabQueueHelper
.
TAB_QUEUE_NOTIFICATION_ID
builder
.
build
(
)
)
;
}
public
static
boolean
shouldOpenTabQueueUrls
(
final
Context
context
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
int
tabsQueued
=
prefs
.
getInt
(
PREF_TAB_QUEUE_COUNT
0
)
;
return
isTabQueueEnabled
(
prefs
)
&
&
tabsQueued
>
0
;
}
public
static
int
getTabQueueLength
(
final
Context
context
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
return
prefs
.
getInt
(
PREF_TAB_QUEUE_COUNT
0
)
;
}
public
static
void
openQueuedUrls
(
final
Context
context
final
GeckoProfile
profile
final
String
filename
boolean
shouldPerformJavaScriptCallback
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
removeNotification
(
context
)
;
if
(
getTabQueueLength
(
context
)
<
1
)
{
return
;
}
JSONArray
jsonArray
=
profile
.
readJSONArrayFromFile
(
filename
)
;
final
int
len
=
jsonArray
.
length
(
)
;
if
(
len
>
0
)
{
final
String
[
]
urls
=
new
String
[
len
]
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
urls
[
i
]
=
jsonArray
.
optString
(
i
)
;
}
final
GeckoBundle
data
=
new
GeckoBundle
(
2
)
;
data
.
putStringArray
(
"
urls
"
urls
)
;
data
.
putBoolean
(
"
shouldNotifyTabsOpenedToJava
"
shouldPerformJavaScriptCallback
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Tabs
:
OpenMultiple
"
data
)
;
}
try
{
profile
.
deleteFileFromProfileDir
(
filename
)
;
}
catch
(
IllegalArgumentException
e
)
{
Log
.
e
(
LOGTAG
"
Error
deleting
Tab
Queue
data
file
.
"
e
)
;
}
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
prefs
.
edit
(
)
.
remove
(
PREF_TAB_QUEUE_COUNT
)
.
apply
(
)
;
}
protected
static
void
removeNotification
(
Context
context
)
{
NotificationManager
notificationManager
=
(
NotificationManager
)
context
.
getSystemService
(
Context
.
NOTIFICATION_SERVICE
)
;
notificationManager
.
cancel
(
TAB_QUEUE_NOTIFICATION_ID
)
;
}
public
static
boolean
processTabQueuePromptResponse
(
int
resultCode
Context
context
)
{
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
final
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
switch
(
resultCode
)
{
case
TAB_QUEUE_YES
:
editor
.
putBoolean
(
GeckoPreferences
.
PREFS_TAB_QUEUE
true
)
;
editor
.
putInt
(
TabQueueHelper
.
PREF_TAB_QUEUE_LAUNCHES
TabQueueHelper
.
EXTERNAL_LAUNCHES_BEFORE_SHOWING_PROMPT
+
1
)
;
break
;
case
TAB_QUEUE_NO
:
editor
.
putInt
(
TabQueueHelper
.
PREF_TAB_QUEUE_LAUNCHES
TabQueueHelper
.
EXTERNAL_LAUNCHES_BEFORE_SHOWING_PROMPT
+
1
)
;
editor
.
putInt
(
TabQueueHelper
.
PREF_TAB_QUEUE_TIMES_PROMPT_SHOWN
TabQueueHelper
.
MAX_TIMES_TO_SHOW_PROMPT
+
1
)
;
break
;
default
:
Log
.
w
(
LOGTAG
"
Unrecognized
result
code
received
from
the
tab
queue
prompt
:
"
+
resultCode
)
;
}
editor
.
apply
(
)
;
return
resultCode
=
=
TAB_QUEUE_YES
;
}
public
static
boolean
isTabQueueEnabled
(
Context
context
)
{
return
isTabQueueEnabled
(
GeckoSharedPrefs
.
forApp
(
context
)
)
;
}
public
static
boolean
isTabQueueEnabled
(
SharedPreferences
prefs
)
{
return
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_TAB_QUEUE
false
)
;
}
}
