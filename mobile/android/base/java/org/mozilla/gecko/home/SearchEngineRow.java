package
org
.
mozilla
.
gecko
.
home
;
import
org
.
mozilla
.
gecko
.
GeckoSharedPrefs
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
Telemetry
;
import
org
.
mozilla
.
gecko
.
TelemetryContract
;
import
org
.
mozilla
.
gecko
.
home
.
BrowserSearch
.
OnEditSuggestionListener
;
import
org
.
mozilla
.
gecko
.
home
.
BrowserSearch
.
OnSearchListener
;
import
org
.
mozilla
.
gecko
.
home
.
HomePager
.
OnUrlOpenListener
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
util
.
DrawableUtil
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
widget
.
AnimatedHeightLayout
;
import
org
.
mozilla
.
gecko
.
widget
.
FaviconView
;
import
org
.
mozilla
.
gecko
.
widget
.
FlowLayout
;
import
android
.
content
.
Context
;
import
android
.
content
.
SharedPreferences
;
import
android
.
graphics
.
drawable
.
Drawable
;
import
android
.
graphics
.
Typeface
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
text
.
TextUtils
;
import
android
.
text
.
style
.
StyleSpan
;
import
android
.
text
.
Spannable
;
import
android
.
text
.
SpannableStringBuilder
;
import
android
.
util
.
AttributeSet
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
View
;
import
android
.
view
.
animation
.
AlphaAnimation
;
import
android
.
widget
.
ImageView
;
import
android
.
widget
.
LinearLayout
;
import
android
.
widget
.
TextView
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
EnumSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
regex
.
Pattern
;
class
SearchEngineRow
extends
AnimatedHeightLayout
{
private
static
final
int
ANIMATION_DURATION
=
250
;
private
final
FlowLayout
mSuggestionView
;
private
final
FaviconView
mIconView
;
private
final
LinearLayout
mUserEnteredView
;
private
final
TextView
mUserEnteredTextView
;
private
final
LayoutInflater
mInflater
;
private
SearchEngine
mSearchEngine
;
private
final
OnClickListener
mClickListener
;
private
final
OnLongClickListener
mLongClickListener
;
private
OnUrlOpenListener
mUrlOpenListener
;
private
OnSearchListener
mSearchListener
;
private
OnEditSuggestionListener
mEditSuggestionListener
;
private
int
mSelectedView
;
private
Drawable
mSearchHistorySuggestionIcon
;
private
int
mMaxSavedSuggestions
;
private
int
mMaxSearchSuggestions
;
private
final
List
<
Integer
>
mOccurrences
=
new
ArrayList
<
Integer
>
(
)
;
public
SearchEngineRow
(
Context
context
)
{
this
(
context
null
)
;
}
public
SearchEngineRow
(
Context
context
AttributeSet
attrs
)
{
this
(
context
attrs
0
)
;
}
public
SearchEngineRow
(
Context
context
AttributeSet
attrs
int
defStyle
)
{
super
(
context
attrs
defStyle
)
;
mClickListener
=
new
OnClickListener
(
)
{
Override
public
void
onClick
(
View
v
)
{
final
String
suggestion
=
getSuggestionTextFromView
(
v
)
;
if
(
v
!
=
mUserEnteredView
&
&
!
StringUtils
.
isSearchQuery
(
suggestion
true
)
)
{
if
(
mUrlOpenListener
!
=
null
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
SUGGESTION
"
url
"
)
;
mUrlOpenListener
.
onUrlOpen
(
suggestion
EnumSet
.
noneOf
(
OnUrlOpenListener
.
Flags
.
class
)
)
;
}
}
else
if
(
mSearchListener
!
=
null
)
{
if
(
v
=
=
mUserEnteredView
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
SUGGESTION
"
user
"
)
;
}
else
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
SUGGESTION
(
String
)
v
.
getTag
(
)
)
;
}
mSearchListener
.
onSearch
(
mSearchEngine
suggestion
)
;
}
}
}
;
mLongClickListener
=
new
OnLongClickListener
(
)
{
Override
public
boolean
onLongClick
(
View
v
)
{
if
(
mEditSuggestionListener
!
=
null
)
{
final
String
suggestion
=
getSuggestionTextFromView
(
v
)
;
mEditSuggestionListener
.
onEditSuggestion
(
suggestion
)
;
return
true
;
}
return
false
;
}
}
;
mInflater
=
LayoutInflater
.
from
(
context
)
;
mInflater
.
inflate
(
R
.
layout
.
search_engine_row
this
)
;
mSuggestionView
=
(
FlowLayout
)
findViewById
(
R
.
id
.
suggestion_layout
)
;
mIconView
=
(
FaviconView
)
findViewById
(
R
.
id
.
suggestion_icon
)
;
mUserEnteredView
=
(
LinearLayout
)
findViewById
(
R
.
id
.
suggestion_user_entered
)
;
mUserEnteredView
.
setOnClickListener
(
mClickListener
)
;
mUserEnteredTextView
=
(
TextView
)
findViewById
(
R
.
id
.
suggestion_text
)
;
mSearchHistorySuggestionIcon
=
DrawableUtil
.
tintDrawableWithColorRes
(
getContext
(
)
R
.
drawable
.
icon_most_recent_empty
R
.
color
.
tabs_tray_icon_grey
)
;
mMaxSavedSuggestions
=
getResources
(
)
.
getInteger
(
R
.
integer
.
max_saved_suggestions
)
;
mMaxSearchSuggestions
=
getResources
(
)
.
getInteger
(
R
.
integer
.
max_search_suggestions
)
;
}
private
void
setDescriptionOnSuggestion
(
View
v
String
suggestion
)
{
v
.
setContentDescription
(
getResources
(
)
.
getString
(
R
.
string
.
suggestion_for_engine
mSearchEngine
.
name
suggestion
)
)
;
}
private
String
getSuggestionTextFromView
(
View
v
)
{
final
TextView
suggestionText
=
(
TextView
)
v
.
findViewById
(
R
.
id
.
suggestion_text
)
;
return
suggestionText
.
getText
(
)
.
toString
(
)
;
}
private
void
refreshOccurrencesWith
(
String
pattern
String
string
)
{
mOccurrences
.
clear
(
)
;
if
(
TextUtils
.
isEmpty
(
pattern
)
)
{
return
;
}
final
int
patternLength
=
pattern
.
length
(
)
;
int
indexOfMatch
=
0
;
int
lastIndexOfMatch
=
0
;
while
(
indexOfMatch
!
=
-
1
)
{
indexOfMatch
=
string
.
indexOf
(
pattern
lastIndexOfMatch
)
;
lastIndexOfMatch
=
indexOfMatch
+
patternLength
;
if
(
indexOfMatch
!
=
-
1
)
{
mOccurrences
.
add
(
indexOfMatch
)
;
}
}
}
private
void
setSuggestionOnView
(
View
v
String
suggestion
boolean
isUserSavedSearch
)
{
final
ImageView
historyIcon
=
(
ImageView
)
v
.
findViewById
(
R
.
id
.
suggestion_item_icon
)
;
if
(
isUserSavedSearch
)
{
historyIcon
.
setImageDrawable
(
mSearchHistorySuggestionIcon
)
;
historyIcon
.
setVisibility
(
View
.
VISIBLE
)
;
}
else
{
historyIcon
.
setVisibility
(
View
.
GONE
)
;
}
final
TextView
suggestionText
=
(
TextView
)
v
.
findViewById
(
R
.
id
.
suggestion_text
)
;
final
String
searchTerm
=
getSuggestionTextFromView
(
mUserEnteredView
)
;
final
int
searchTermLength
=
searchTerm
.
length
(
)
;
refreshOccurrencesWith
(
searchTerm
suggestion
)
;
if
(
mOccurrences
.
size
(
)
>
0
)
{
final
SpannableStringBuilder
sb
=
new
SpannableStringBuilder
(
suggestion
)
;
int
nextStartSpanIndex
=
0
;
mOccurrences
.
add
(
suggestion
.
length
(
)
)
;
for
(
int
occurrence
:
mOccurrences
)
{
StyleSpan
boldSpan
=
new
StyleSpan
(
Typeface
.
BOLD
)
;
sb
.
setSpan
(
boldSpan
nextStartSpanIndex
occurrence
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
nextStartSpanIndex
=
occurrence
+
searchTermLength
;
}
mOccurrences
.
clear
(
)
;
suggestionText
.
setText
(
sb
)
;
}
else
{
suggestionText
.
setText
(
suggestion
)
;
}
setDescriptionOnSuggestion
(
suggestionText
suggestion
)
;
}
public
void
performUserEnteredSearch
(
)
{
String
searchTerm
=
getSuggestionTextFromView
(
mUserEnteredView
)
;
if
(
mSearchListener
!
=
null
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
SUGGESTION
"
user
"
)
;
mSearchListener
.
onSearch
(
mSearchEngine
searchTerm
)
;
}
}
public
void
setSearchTerm
(
String
searchTerm
)
{
mUserEnteredTextView
.
setText
(
searchTerm
)
;
if
(
mSearchEngine
!
=
null
)
{
setDescriptionOnSuggestion
(
mUserEnteredTextView
searchTerm
)
;
}
}
public
void
setOnUrlOpenListener
(
OnUrlOpenListener
listener
)
{
mUrlOpenListener
=
listener
;
}
public
void
setOnSearchListener
(
OnSearchListener
listener
)
{
mSearchListener
=
listener
;
}
public
void
setOnEditSuggestionListener
(
OnEditSuggestionListener
listener
)
{
mEditSuggestionListener
=
listener
;
}
private
void
bindSuggestionView
(
String
suggestion
boolean
animate
int
recycledSuggestionCount
Integer
previousSuggestionChildIndex
boolean
isUserSavedSearch
String
telemetryTag
)
{
final
View
suggestionItem
;
if
(
previousSuggestionChildIndex
+
1
<
recycledSuggestionCount
)
{
suggestionItem
=
mSuggestionView
.
getChildAt
(
previousSuggestionChildIndex
+
1
)
;
suggestionItem
.
setVisibility
(
View
.
VISIBLE
)
;
}
else
{
suggestionItem
=
mInflater
.
inflate
(
R
.
layout
.
suggestion_item
null
)
;
suggestionItem
.
setOnClickListener
(
mClickListener
)
;
suggestionItem
.
setOnLongClickListener
(
mLongClickListener
)
;
suggestionItem
.
setTag
(
telemetryTag
)
;
mSuggestionView
.
addView
(
suggestionItem
)
;
}
setSuggestionOnView
(
suggestionItem
suggestion
isUserSavedSearch
)
;
if
(
animate
)
{
AlphaAnimation
anim
=
new
AlphaAnimation
(
0
1
)
;
anim
.
setDuration
(
ANIMATION_DURATION
)
;
anim
.
setStartOffset
(
previousSuggestionChildIndex
*
ANIMATION_DURATION
)
;
suggestionItem
.
startAnimation
(
anim
)
;
}
}
private
void
hideRecycledSuggestions
(
int
lastVisibleChildIndex
int
recycledSuggestionCount
)
{
for
(
int
i
=
lastVisibleChildIndex
+
1
;
i
<
recycledSuggestionCount
;
+
+
i
)
{
mSuggestionView
.
getChildAt
(
i
)
.
setVisibility
(
View
.
GONE
)
;
}
}
private
void
updateFromSavedSearches
(
List
<
String
>
savedSuggestions
boolean
animate
int
suggestionStartIndex
int
recycledSuggestionCount
)
{
if
(
savedSuggestions
=
=
null
|
|
savedSuggestions
.
isEmpty
(
)
)
{
hideRecycledSuggestions
(
suggestionStartIndex
recycledSuggestionCount
)
;
return
;
}
final
int
numSavedSearches
=
savedSuggestions
.
size
(
)
;
int
indexOfPreviousSuggestion
=
0
;
for
(
int
i
=
0
;
i
<
numSavedSearches
;
i
+
+
)
{
String
telemetryTag
=
"
history
.
"
+
i
;
final
String
suggestion
=
savedSuggestions
.
get
(
i
)
;
indexOfPreviousSuggestion
=
suggestionStartIndex
+
i
;
bindSuggestionView
(
suggestion
animate
recycledSuggestionCount
indexOfPreviousSuggestion
true
telemetryTag
)
;
}
hideRecycledSuggestions
(
indexOfPreviousSuggestion
+
1
recycledSuggestionCount
)
;
}
private
int
updateFromSearchEngine
(
boolean
animate
List
<
String
>
searchEngineSuggestions
int
recycledSuggestionCount
int
savedSuggestionCount
)
{
int
maxSuggestions
=
mMaxSearchSuggestions
;
if
(
!
HardwareUtils
.
isTablet
(
)
&
&
savedSuggestionCount
<
mMaxSavedSuggestions
)
{
maxSuggestions
+
=
mMaxSavedSuggestions
-
savedSuggestionCount
;
}
final
int
numSearchEngineSuggestions
=
searchEngineSuggestions
.
size
(
)
;
int
relativeIndex
;
for
(
relativeIndex
=
0
;
relativeIndex
<
numSearchEngineSuggestions
;
relativeIndex
+
+
)
{
if
(
relativeIndex
=
=
maxSuggestions
)
{
break
;
}
String
telemetryTag
=
"
engine
.
"
+
relativeIndex
;
final
String
suggestion
=
searchEngineSuggestions
.
get
(
relativeIndex
)
;
bindSuggestionView
(
suggestion
animate
recycledSuggestionCount
relativeIndex
false
telemetryTag
)
;
}
hideRecycledSuggestions
(
relativeIndex
+
1
recycledSuggestionCount
)
;
if
(
mSelectedView
>
=
mSuggestionView
.
getChildCount
(
)
)
{
mSelectedView
=
mSuggestionView
.
getChildCount
(
)
-
1
;
}
return
relativeIndex
;
}
public
void
updateSuggestions
(
boolean
searchSuggestionsEnabled
SearchEngine
searchEngine
Nullable
List
<
String
>
rawSearchHistorySuggestions
boolean
animate
)
{
mSearchEngine
=
searchEngine
;
mIconView
.
updateAndScaleImage
(
mSearchEngine
.
getIcon
(
)
mSearchEngine
.
getEngineIdentifier
(
)
)
;
setDescriptionOnSuggestion
(
mUserEnteredTextView
mUserEnteredTextView
.
getText
(
)
.
toString
(
)
)
;
final
int
recycledSuggestionCount
=
mSuggestionView
.
getChildCount
(
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
getContext
(
)
)
;
final
boolean
savedSearchesEnabled
=
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_HISTORY_SAVED_SEARCH
true
)
;
List
<
String
>
searchHistorySuggestions
=
(
rawSearchHistorySuggestions
!
=
null
)
?
rawSearchHistorySuggestions
:
new
ArrayList
<
String
>
(
)
;
Iterator
<
String
>
searchHistoryIterator
=
searchHistorySuggestions
.
iterator
(
)
;
while
(
searchHistoryIterator
.
hasNext
(
)
)
{
final
String
currentSearchHistory
=
searchHistoryIterator
.
next
(
)
;
if
(
currentSearchHistory
.
length
(
)
>
50
|
|
Pattern
.
matches
(
"
^
(
https
?
|
ftp
|
file
)
:
/
/
.
*
"
currentSearchHistory
)
)
{
searchHistoryIterator
.
remove
(
)
;
}
}
List
<
String
>
searchEngineSuggestions
=
new
ArrayList
<
String
>
(
)
;
for
(
String
suggestion
:
searchEngine
.
getSuggestions
(
)
)
{
searchHistorySuggestions
.
remove
(
suggestion
)
;
searchEngineSuggestions
.
add
(
suggestion
)
;
}
searchHistorySuggestions
.
remove
(
getSuggestionTextFromView
(
mUserEnteredView
)
)
;
if
(
searchHistorySuggestions
.
size
(
)
>
=
mMaxSavedSuggestions
)
{
searchHistorySuggestions
=
searchHistorySuggestions
.
subList
(
0
mMaxSavedSuggestions
)
;
}
final
int
searchHistoryCount
=
searchHistorySuggestions
.
size
(
)
;
if
(
searchSuggestionsEnabled
&
&
savedSearchesEnabled
)
{
final
int
suggestionViewCount
=
updateFromSearchEngine
(
animate
searchEngineSuggestions
recycledSuggestionCount
searchHistoryCount
)
;
updateFromSavedSearches
(
searchHistorySuggestions
animate
suggestionViewCount
recycledSuggestionCount
)
;
}
else
if
(
savedSearchesEnabled
)
{
updateFromSavedSearches
(
searchHistorySuggestions
animate
0
recycledSuggestionCount
)
;
}
else
if
(
searchSuggestionsEnabled
)
{
updateFromSearchEngine
(
animate
searchEngineSuggestions
recycledSuggestionCount
0
)
;
}
else
{
hideRecycledSuggestions
(
0
recycledSuggestionCount
)
;
}
}
Override
public
boolean
onKeyDown
(
int
keyCode
android
.
view
.
KeyEvent
event
)
{
final
View
suggestion
=
mSuggestionView
.
getChildAt
(
mSelectedView
)
;
if
(
event
.
getAction
(
)
!
=
android
.
view
.
KeyEvent
.
ACTION_DOWN
)
{
return
false
;
}
switch
(
event
.
getKeyCode
(
)
)
{
case
KeyEvent
.
KEYCODE_DPAD_RIGHT
:
final
View
nextSuggestion
=
mSuggestionView
.
getChildAt
(
mSelectedView
+
1
)
;
if
(
nextSuggestion
!
=
null
)
{
changeSelectedSuggestion
(
suggestion
nextSuggestion
)
;
mSelectedView
+
+
;
return
true
;
}
break
;
case
KeyEvent
.
KEYCODE_DPAD_LEFT
:
final
View
prevSuggestion
=
mSuggestionView
.
getChildAt
(
mSelectedView
-
1
)
;
if
(
prevSuggestion
!
=
null
)
{
changeSelectedSuggestion
(
suggestion
prevSuggestion
)
;
mSelectedView
-
-
;
return
true
;
}
break
;
case
KeyEvent
.
KEYCODE_BUTTON_A
:
return
suggestion
.
performClick
(
)
;
}
return
false
;
}
private
void
changeSelectedSuggestion
(
View
oldSuggestion
View
newSuggestion
)
{
oldSuggestion
.
setDuplicateParentStateEnabled
(
false
)
;
newSuggestion
.
setDuplicateParentStateEnabled
(
true
)
;
oldSuggestion
.
refreshDrawableState
(
)
;
newSuggestion
.
refreshDrawableState
(
)
;
}
public
void
onSelected
(
)
{
mSelectedView
=
0
;
mUserEnteredView
.
setDuplicateParentStateEnabled
(
true
)
;
mUserEnteredView
.
refreshDrawableState
(
)
;
}
public
void
onDeselected
(
)
{
final
View
suggestion
=
mSuggestionView
.
getChildAt
(
mSelectedView
)
;
suggestion
.
setDuplicateParentStateEnabled
(
false
)
;
suggestion
.
refreshDrawableState
(
)
;
}
}
