package
org
.
mozilla
.
gecko
.
distribution
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
net
.
ProtocolException
;
import
java
.
net
.
SocketException
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
net
.
UnknownHostException
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
java
.
util
.
Queue
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
java
.
util
.
jar
.
JarEntry
;
import
java
.
util
.
jar
.
JarInputStream
;
import
java
.
util
.
zip
.
ZipEntry
;
import
java
.
util
.
zip
.
ZipFile
;
import
javax
.
net
.
ssl
.
SSLException
;
import
ch
.
boye
.
httpclientandroidlib
.
protocol
.
HTTP
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
EventDispatcher
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoApplication
;
import
org
.
mozilla
.
gecko
.
GeckoSharedPrefs
;
import
org
.
mozilla
.
gecko
.
Telemetry
;
import
org
.
mozilla
.
gecko
.
annotation
.
JNITarget
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ProxySelector
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Context
;
import
android
.
content
.
SharedPreferences
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
telephony
.
TelephonyManager
;
import
android
.
util
.
Log
;
RobocopTarget
public
class
Distribution
{
private
static
final
String
LOGTAG
=
"
GeckoDistribution
"
;
public
static
final
String
PREF_KEY_PROFILE_PREFERENCES
=
"
AndroidPreferences
"
;
public
static
final
String
PREF_KEY_APPLICATION_PREFERENCES
=
"
ApplicationPreferences
"
;
private
static
final
int
STATE_UNKNOWN
=
0
;
private
static
final
int
STATE_NONE
=
1
;
private
static
final
int
STATE_SET
=
2
;
private
static
final
String
FETCH_PROTOCOL
=
"
https
"
;
private
static
final
String
FETCH_HOSTNAME
=
"
mobile
.
cdn
.
mozilla
.
net
"
;
private
static
final
String
FETCH_PATH
=
"
/
distributions
/
1
/
"
;
private
static
final
String
FETCH_EXTENSION
=
"
.
jar
"
;
private
static
final
String
EXPECTED_CONTENT_TYPE
=
"
application
/
java
-
archive
"
;
private
static
final
String
DISTRIBUTION_PATH
=
"
distribution
/
"
;
private
static
final
String
HISTOGRAM_REFERRER_INVALID
=
"
FENNEC_DISTRIBUTION_REFERRER_INVALID
"
;
private
static
final
String
HISTOGRAM_DOWNLOAD_TIME_MS
=
"
FENNEC_DISTRIBUTION_DOWNLOAD_TIME_MS
"
;
private
static
final
String
HISTOGRAM_CODE_CATEGORY
=
"
FENNEC_DISTRIBUTION_CODE_CATEGORY
"
;
private
static
final
String
SYSPROP_DISTRIBUTIONDIR
=
"
ro
.
org
.
mozilla
.
distributiondir
"
;
private
static
final
int
CODE_CATEGORY_STATUS_OUT_OF_RANGE
=
0
;
private
static
final
int
CODE_CATEGORY_OFFLINE
=
6
;
private
static
final
int
CODE_CATEGORY_FETCH_EXCEPTION
=
7
;
private
static
final
int
CODE_CATEGORY_POST_FETCH_EXCEPTION
=
8
;
private
static
final
int
CODE_CATEGORY_POST_FETCH_SECURITY_EXCEPTION
=
9
;
private
static
final
int
CODE_CATEGORY_MALFORMED_DISTRIBUTION
=
10
;
private
static
final
int
CODE_CATEGORY_FETCH_SOCKET_ERROR
=
11
;
private
static
final
int
CODE_CATEGORY_FETCH_SSL_ERROR
=
12
;
private
static
final
int
CODE_CATEGORY_FETCH_NON_SUCCESS_RESPONSE
=
13
;
private
static
final
int
CODE_CATEGORY_FETCH_INVALID_CONTENT_TYPE
=
14
;
private
static
final
long
MAX_DOWNLOAD_TIME_MSEC
=
40000
;
private
volatile
boolean
shouldDelayLateCallbacks
=
false
;
public
interface
ReadyCallback
{
WorkerThread
void
distributionNotFound
(
)
;
WorkerThread
void
distributionFound
(
Distribution
distribution
)
;
WorkerThread
void
distributionArrivedLate
(
Distribution
distribution
)
;
}
RobocopTarget
protected
static
volatile
ReferrerDescriptor
referrer
;
private
static
Distribution
instance
;
private
final
Context
context
;
private
final
String
packagePath
;
private
final
String
prefsBranch
;
volatile
int
state
=
STATE_UNKNOWN
;
private
File
distributionDir
;
private
final
Queue
<
ReadyCallback
>
onDistributionReady
=
new
ConcurrentLinkedQueue
<
>
(
)
;
private
final
Queue
<
ReadyCallback
>
onLateReady
=
new
ConcurrentLinkedQueue
<
>
(
)
;
public
static
synchronized
Distribution
getInstance
(
Context
context
)
{
if
(
instance
=
=
null
)
{
instance
=
new
Distribution
(
context
)
;
}
return
instance
;
}
RobocopTarget
public
static
class
DistributionDescriptor
{
public
final
boolean
valid
;
public
final
String
id
;
public
final
String
version
;
public
final
String
about
;
public
final
Map
<
String
String
>
localizedAbout
;
SuppressWarnings
(
"
unchecked
"
)
public
DistributionDescriptor
(
JSONObject
obj
)
{
this
.
id
=
obj
.
optString
(
"
id
"
)
;
this
.
version
=
obj
.
optString
(
"
version
"
)
;
this
.
about
=
obj
.
optString
(
"
about
"
)
;
Map
<
String
String
>
loc
=
new
HashMap
<
String
String
>
(
)
;
try
{
Iterator
<
String
>
keys
=
obj
.
keys
(
)
;
while
(
keys
.
hasNext
(
)
)
{
String
key
=
keys
.
next
(
)
;
if
(
key
.
startsWith
(
"
about
.
"
)
)
{
String
locale
=
key
.
substring
(
6
)
;
if
(
!
obj
.
isNull
(
locale
)
)
{
loc
.
put
(
locale
obj
.
getString
(
key
)
)
;
}
}
}
}
catch
(
JSONException
ex
)
{
Log
.
w
(
LOGTAG
"
Unable
to
completely
process
distribution
JSON
.
"
ex
)
;
}
this
.
localizedAbout
=
Collections
.
unmodifiableMap
(
loc
)
;
this
.
valid
=
(
null
!
=
this
.
id
)
&
&
(
null
!
=
this
.
version
)
&
&
(
null
!
=
this
.
about
)
;
}
}
private
static
Distribution
init
(
final
Distribution
distribution
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
boolean
distributionSet
=
distribution
.
doInit
(
)
;
if
(
distributionSet
)
{
GeckoBundle
data
=
null
;
try
{
final
File
descFile
=
distribution
.
getDistributionFile
(
"
preferences
.
json
"
)
;
if
(
descFile
=
=
null
)
{
throw
new
IOException
(
"
preferences
.
json
not
found
"
)
;
}
final
String
preferencesJSON
=
FileUtils
.
readStringFromFile
(
descFile
)
;
data
=
new
GeckoBundle
(
1
)
;
data
.
putString
(
"
preferences
"
preferencesJSON
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
getting
distribution
descriptor
file
.
"
e
)
;
}
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Distribution
:
Set
"
data
)
;
}
}
}
)
;
return
distribution
;
}
RobocopTarget
public
static
Distribution
init
(
final
Context
context
final
String
packagePath
final
String
prefsPath
)
{
return
init
(
new
Distribution
(
context
packagePath
prefsPath
)
)
;
}
RobocopTarget
public
static
Distribution
init
(
final
Context
context
)
{
return
init
(
Distribution
.
getInstance
(
context
)
)
;
}
public
static
JSONArray
getBookmarks
(
final
Context
context
)
{
Distribution
dist
=
new
Distribution
(
context
)
;
return
dist
.
getBookmarks
(
)
;
}
public
Distribution
(
final
Context
context
final
String
packagePath
final
String
prefsBranch
)
{
this
.
context
=
context
;
this
.
packagePath
=
packagePath
;
this
.
prefsBranch
=
prefsBranch
;
}
public
Distribution
(
final
Context
context
)
{
this
(
context
context
.
getPackageResourcePath
(
)
null
)
;
}
public
static
void
onReceivedReferrer
(
final
Context
context
final
ReferrerDescriptor
ref
)
{
referrer
=
ref
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
Distribution
distribution
=
Distribution
.
getInstance
(
context
)
;
distribution
.
processDelayedReferrer
(
ref
)
;
distribution
.
doInit
(
)
;
}
}
)
;
}
private
void
processDelayedReferrer
(
final
ReferrerDescriptor
ref
)
{
ThreadUtils
.
assertOnBackgroundThread
(
)
;
if
(
state
!
=
STATE_NONE
)
{
return
;
}
Log
.
i
(
LOGTAG
"
Processing
delayed
referrer
.
"
)
;
if
(
!
checkIntentDistribution
(
ref
)
)
{
this
.
onLateReady
.
clear
(
)
;
return
;
}
this
.
state
=
STATE_SET
;
getSharedPreferences
(
)
.
edit
(
)
.
putInt
(
getKeyName
(
)
this
.
state
)
.
apply
(
)
;
runReadyQueue
(
)
;
runLateReadyQueue
(
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Distribution
:
Changed
"
null
)
;
}
public
File
getDistributionFile
(
String
name
)
{
Log
.
d
(
LOGTAG
"
Getting
file
from
distribution
.
"
)
;
if
(
this
.
state
=
=
STATE_UNKNOWN
)
{
if
(
!
this
.
doInit
(
)
)
{
return
null
;
}
}
File
dist
=
ensureDistributionDir
(
)
;
if
(
dist
=
=
null
)
{
return
null
;
}
File
descFile
=
new
File
(
dist
name
)
;
if
(
!
descFile
.
exists
(
)
)
{
Log
.
e
(
LOGTAG
"
Distribution
directory
exists
but
no
file
named
"
+
name
)
;
return
null
;
}
return
descFile
;
}
public
DistributionDescriptor
getDescriptor
(
)
{
File
descFile
=
getDistributionFile
(
"
preferences
.
json
"
)
;
if
(
descFile
=
=
null
)
{
return
null
;
}
try
{
JSONObject
all
=
FileUtils
.
readJSONObjectFromFile
(
descFile
)
;
if
(
!
all
.
has
(
"
Global
"
)
)
{
Log
.
e
(
LOGTAG
"
Distribution
preferences
.
json
has
no
Global
entry
!
"
)
;
return
null
;
}
return
new
DistributionDescriptor
(
all
.
getJSONObject
(
"
Global
"
)
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
getting
distribution
descriptor
file
.
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_MALFORMED_DISTRIBUTION
)
;
return
null
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Error
parsing
preferences
.
json
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_MALFORMED_DISTRIBUTION
)
;
return
null
;
}
}
public
JSONObject
getPreferences
(
String
key
)
{
final
File
descFile
=
getDistributionFile
(
"
preferences
.
json
"
)
;
if
(
descFile
=
=
null
)
{
return
new
JSONObject
(
)
;
}
try
{
final
JSONObject
all
=
FileUtils
.
readJSONObjectFromFile
(
descFile
)
;
if
(
!
all
.
has
(
key
)
)
{
return
new
JSONObject
(
)
;
}
return
all
.
getJSONObject
(
key
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
getting
distribution
descriptor
file
.
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_MALFORMED_DISTRIBUTION
)
;
return
new
JSONObject
(
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Error
parsing
preferences
.
json
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_MALFORMED_DISTRIBUTION
)
;
return
new
JSONObject
(
)
;
}
}
public
JSONArray
getBookmarks
(
)
{
File
bookmarks
=
getDistributionFile
(
"
bookmarks
.
json
"
)
;
if
(
bookmarks
=
=
null
)
{
return
null
;
}
try
{
return
new
JSONArray
(
FileUtils
.
readStringFromFile
(
bookmarks
)
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
getting
bookmarks
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_MALFORMED_DISTRIBUTION
)
;
return
null
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Error
parsing
bookmarks
.
json
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_MALFORMED_DISTRIBUTION
)
;
return
null
;
}
}
RobocopTarget
protected
boolean
doInit
(
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
final
SharedPreferences
settings
=
getSharedPreferences
(
)
;
final
String
keyName
=
getKeyName
(
)
;
this
.
state
=
settings
.
getInt
(
keyName
STATE_UNKNOWN
)
;
if
(
this
.
state
=
=
STATE_NONE
)
{
runReadyQueue
(
)
;
return
false
;
}
if
(
this
.
state
=
=
STATE_SET
)
{
runReadyQueue
(
)
;
return
true
;
}
final
boolean
distributionSet
=
checkIntentDistribution
(
referrer
)
|
|
copyAndCheckAPKDistribution
(
)
|
|
checkSystemDistribution
(
)
|
|
checkDataDistribution
(
)
;
this
.
shouldDelayLateCallbacks
=
!
distributionSet
;
this
.
state
=
distributionSet
?
STATE_SET
:
STATE_NONE
;
settings
.
edit
(
)
.
putInt
(
keyName
this
.
state
)
.
apply
(
)
;
runReadyQueue
(
)
;
return
distributionSet
;
}
private
boolean
checkIntentDistribution
(
final
ReferrerDescriptor
referrer
)
{
if
(
referrer
=
=
null
)
{
return
false
;
}
URI
uri
=
getReferredDistribution
(
referrer
)
;
if
(
uri
=
=
null
)
{
return
false
;
}
long
start
=
SystemClock
.
uptimeMillis
(
)
;
Log
.
v
(
LOGTAG
"
Downloading
referred
distribution
:
"
+
uri
)
;
try
{
final
HttpURLConnection
connection
=
(
HttpURLConnection
)
ProxySelector
.
openConnectionWithProxy
(
uri
)
;
final
String
ua
=
GeckoApplication
.
getDefaultUAString
(
)
;
connection
.
setRequestProperty
(
HTTP
.
USER_AGENT
ua
)
;
connection
.
setRequestProperty
(
"
Accept
"
EXPECTED_CONTENT_TYPE
)
;
try
{
final
JarInputStream
distro
;
try
{
distro
=
fetchDistribution
(
uri
connection
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Error
fetching
distribution
from
network
.
"
e
)
;
recordFetchTelemetry
(
e
)
;
return
false
;
}
long
end
=
SystemClock
.
uptimeMillis
(
)
;
final
long
duration
=
end
-
start
;
Log
.
d
(
LOGTAG
"
Distro
fetch
took
"
+
duration
+
"
ms
;
result
?
"
+
(
distro
!
=
null
)
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_DOWNLOAD_TIME_MS
clamp
(
MAX_DOWNLOAD_TIME_MSEC
duration
)
)
;
if
(
distro
=
=
null
)
{
return
false
;
}
try
{
Log
.
d
(
LOGTAG
"
Copying
files
from
fetched
zip
.
"
)
;
if
(
copyFilesFromStream
(
distro
)
)
{
return
checkDataDistribution
(
)
;
}
}
catch
(
SecurityException
e
)
{
Log
.
e
(
LOGTAG
"
Security
exception
copying
files
.
Corrupt
or
malicious
?
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_POST_FETCH_SECURITY_EXCEPTION
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Error
copying
files
from
distribution
.
"
e
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_POST_FETCH_EXCEPTION
)
;
}
finally
{
distro
.
close
(
)
;
}
}
finally
{
connection
.
disconnect
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
copying
distribution
files
from
network
.
"
e
)
;
recordFetchTelemetry
(
e
)
;
}
return
false
;
}
private
static
final
int
clamp
(
long
v
long
c
)
{
return
(
int
)
Math
.
min
(
c
v
)
;
}
SuppressWarnings
(
"
static
-
method
"
)
RobocopTarget
protected
JarInputStream
fetchDistribution
(
URI
uri
HttpURLConnection
connection
)
throws
IOException
{
final
int
status
=
connection
.
getResponseCode
(
)
;
Log
.
d
(
LOGTAG
"
Distribution
fetch
:
"
+
status
)
;
final
int
value
;
if
(
status
>
599
|
|
status
<
100
)
{
Log
.
wtf
(
LOGTAG
"
Unexpected
HTTP
status
code
:
"
+
status
)
;
value
=
CODE_CATEGORY_STATUS_OUT_OF_RANGE
;
}
else
{
value
=
status
/
100
;
}
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
value
)
;
if
(
status
!
=
200
)
{
Log
.
w
(
LOGTAG
"
Got
status
"
+
status
+
"
fetching
distribution
.
"
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_FETCH_NON_SUCCESS_RESPONSE
)
;
return
null
;
}
final
String
contentType
=
connection
.
getContentType
(
)
;
if
(
contentType
=
=
null
|
|
!
contentType
.
startsWith
(
EXPECTED_CONTENT_TYPE
)
)
{
Log
.
w
(
LOGTAG
"
Malformed
response
:
invalid
Content
-
Type
.
"
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_FETCH_INVALID_CONTENT_TYPE
)
;
return
null
;
}
final
BufferedInputStream
bufferedInputStream
=
new
BufferedInputStream
(
connection
.
getInputStream
(
)
)
;
try
{
return
new
JarInputStream
(
bufferedInputStream
true
)
;
}
catch
(
IOException
e
)
{
bufferedInputStream
.
close
(
)
;
throw
e
;
}
}
private
static
void
recordFetchTelemetry
(
final
Exception
exception
)
{
if
(
exception
=
=
null
)
{
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_FETCH_EXCEPTION
)
;
return
;
}
if
(
exception
instanceof
UnknownHostException
)
{
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_OFFLINE
)
;
return
;
}
if
(
exception
instanceof
SSLException
)
{
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_FETCH_SSL_ERROR
)
;
return
;
}
if
(
exception
instanceof
ProtocolException
|
|
exception
instanceof
SocketException
)
{
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_FETCH_SOCKET_ERROR
)
;
return
;
}
Telemetry
.
addToHistogram
(
HISTOGRAM_CODE_CATEGORY
CODE_CATEGORY_FETCH_EXCEPTION
)
;
}
private
boolean
copyAndCheckAPKDistribution
(
)
{
try
{
if
(
copyFilesFromPackagedAssets
(
)
)
{
return
checkDataDistribution
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
copying
distribution
files
from
APK
.
"
e
)
;
}
return
false
;
}
private
boolean
checkDataDistribution
(
)
{
return
checkDirectories
(
getDataDistributionDirectories
(
context
)
)
;
}
private
boolean
checkSystemDistribution
(
)
{
return
checkDirectories
(
getSystemDistributionDirectories
(
context
)
)
;
}
public
boolean
shouldWaitForSystemDistribution
(
)
{
if
(
state
=
=
STATE_NONE
)
{
return
false
;
}
if
(
state
=
=
STATE_SET
)
{
return
true
;
}
final
String
[
]
directories
=
getSystemDistributionDirectories
(
context
)
;
for
(
String
path
:
directories
)
{
final
File
directory
=
new
File
(
path
)
;
if
(
directory
.
exists
(
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
checkDirectories
(
String
[
]
directories
)
{
for
(
String
path
:
directories
)
{
File
directory
=
new
File
(
path
)
;
if
(
directory
.
exists
(
)
)
{
distributionDir
=
directory
;
return
true
;
}
}
return
false
;
}
private
boolean
copyFilesFromStream
(
JarInputStream
jar
)
throws
FileNotFoundException
IOException
{
final
byte
[
]
buffer
=
new
byte
[
1024
]
;
boolean
distributionSet
=
false
;
JarEntry
entry
;
while
(
(
entry
=
jar
.
getNextJarEntry
(
)
)
!
=
null
)
{
final
String
name
=
entry
.
getName
(
)
;
if
(
entry
.
isDirectory
(
)
)
{
continue
;
}
if
(
!
name
.
startsWith
(
DISTRIBUTION_PATH
)
)
{
continue
;
}
File
outFile
=
getDataFile
(
name
)
;
if
(
outFile
=
=
null
)
{
continue
;
}
distributionSet
=
true
;
writeStream
(
jar
outFile
entry
.
getTime
(
)
buffer
)
;
}
return
distributionSet
;
}
private
boolean
copyFilesFromPackagedAssets
(
)
throws
IOException
{
final
File
applicationPackage
=
new
File
(
packagePath
)
;
final
ZipFile
zip
=
new
ZipFile
(
applicationPackage
)
;
final
String
assetsPrefix
=
"
assets
/
"
;
final
String
fullPrefix
=
assetsPrefix
+
DISTRIBUTION_PATH
;
boolean
distributionSet
=
false
;
try
{
final
byte
[
]
buffer
=
new
byte
[
1024
]
;
final
Enumeration
<
?
extends
ZipEntry
>
zipEntries
=
zip
.
entries
(
)
;
while
(
zipEntries
.
hasMoreElements
(
)
)
{
final
ZipEntry
fileEntry
=
zipEntries
.
nextElement
(
)
;
final
String
name
=
fileEntry
.
getName
(
)
;
if
(
fileEntry
.
isDirectory
(
)
)
{
continue
;
}
if
(
!
name
.
startsWith
(
fullPrefix
)
)
{
continue
;
}
final
String
nameWithoutPrefix
=
name
.
substring
(
assetsPrefix
.
length
(
)
)
;
final
File
outFile
=
getDataFile
(
nameWithoutPrefix
)
;
if
(
outFile
=
=
null
)
{
continue
;
}
distributionSet
=
true
;
final
InputStream
fileStream
=
zip
.
getInputStream
(
fileEntry
)
;
try
{
writeStream
(
fileStream
outFile
fileEntry
.
getTime
(
)
buffer
)
;
}
finally
{
fileStream
.
close
(
)
;
}
}
}
finally
{
zip
.
close
(
)
;
}
return
distributionSet
;
}
private
void
writeStream
(
InputStream
fileStream
File
outFile
final
long
modifiedTime
byte
[
]
buffer
)
throws
FileNotFoundException
IOException
{
final
OutputStream
outStream
=
new
FileOutputStream
(
outFile
)
;
try
{
int
count
;
while
(
(
count
=
fileStream
.
read
(
buffer
)
)
>
0
)
{
outStream
.
write
(
buffer
0
count
)
;
}
outFile
.
setLastModified
(
modifiedTime
)
;
}
finally
{
outStream
.
close
(
)
;
}
}
private
File
getDataFile
(
final
String
name
)
{
File
outFile
=
new
File
(
getDataDir
(
)
name
)
;
File
dir
=
outFile
.
getParentFile
(
)
;
if
(
!
dir
.
exists
(
)
)
{
Log
.
d
(
LOGTAG
"
Creating
"
+
dir
.
getAbsolutePath
(
)
)
;
if
(
!
dir
.
mkdirs
(
)
)
{
Log
.
e
(
LOGTAG
"
Unable
to
create
directories
:
"
+
dir
.
getAbsolutePath
(
)
)
;
return
null
;
}
}
return
outFile
;
}
private
URI
getReferredDistribution
(
ReferrerDescriptor
descriptor
)
{
final
String
content
=
descriptor
.
content
;
if
(
content
=
=
null
)
{
return
null
;
}
if
(
!
content
.
matches
(
"
^
[
a
-
zA
-
Z0
-
9_
-
]
+
"
)
)
{
Log
.
e
(
LOGTAG
"
Invalid
referrer
content
:
"
+
content
)
;
Telemetry
.
addToHistogram
(
HISTOGRAM_REFERRER_INVALID
1
)
;
return
null
;
}
try
{
return
new
URI
(
FETCH_PROTOCOL
FETCH_HOSTNAME
FETCH_PATH
+
content
+
FETCH_EXTENSION
null
)
;
}
catch
(
URISyntaxException
e
)
{
Log
.
wtf
(
LOGTAG
"
Invalid
URI
with
content
"
+
content
+
"
!
"
)
;
return
null
;
}
}
private
File
ensureDistributionDir
(
)
{
if
(
this
.
distributionDir
!
=
null
)
{
return
this
.
distributionDir
;
}
if
(
this
.
state
!
=
STATE_SET
)
{
return
null
;
}
if
(
checkDataDistribution
(
)
|
|
checkSystemDistribution
(
)
)
{
return
distributionDir
;
}
return
null
;
}
private
String
getDataDir
(
)
{
return
context
.
getApplicationInfo
(
)
.
dataDir
;
}
JNITarget
public
static
String
[
]
getDistributionDirectories
(
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
String
[
]
dataDirectories
=
getDataDistributionDirectories
(
context
)
;
final
String
[
]
systemDirectories
=
getSystemDistributionDirectories
(
context
)
;
final
String
[
]
directories
=
new
String
[
dataDirectories
.
length
+
systemDirectories
.
length
]
;
System
.
arraycopy
(
dataDirectories
0
directories
0
dataDirectories
.
length
)
;
System
.
arraycopy
(
systemDirectories
0
directories
dataDirectories
.
length
systemDirectories
.
length
)
;
return
directories
;
}
private
static
String
getDistributionDirectoryFromSystemProperty
(
)
{
try
{
SuppressWarnings
(
"
rawtypes
"
)
Class
clazz
=
Class
.
forName
(
"
android
.
os
.
SystemProperties
"
)
;
SuppressWarnings
(
"
unchecked
"
)
Method
method
=
clazz
.
getDeclaredMethod
(
"
get
"
String
.
class
)
;
String
distDirName
=
(
String
)
method
.
invoke
(
null
SYSPROP_DISTRIBUTIONDIR
)
;
if
(
!
distDirName
.
isEmpty
(
)
)
{
Log
.
d
(
LOGTAG
"
System
property
"
+
SYSPROP_DISTRIBUTIONDIR
+
"
found
with
value
"
+
distDirName
)
;
if
(
distDirName
.
charAt
(
distDirName
.
length
(
)
-
1
)
!
=
'
/
'
)
{
distDirName
+
=
'
/
'
;
}
File
distDir
=
new
File
(
distDirName
)
;
if
(
distDir
.
exists
(
)
&
&
distDir
.
isDirectory
(
)
)
{
Log
.
d
(
LOGTAG
"
Custom
distribution
directory
found
at
"
+
distDirName
)
;
return
distDirName
;
}
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Error
getting
system
property
"
+
SYSPROP_DISTRIBUTIONDIR
e
)
;
}
Log
.
d
(
LOGTAG
"
Custom
distribution
directory
not
found
.
"
)
;
return
null
;
}
private
static
String
[
]
getSystemDistributionDirectories
(
Context
context
)
{
final
String
systemPropertyBaseDirectory
=
getDistributionDirectoryFromSystemProperty
(
)
;
final
String
baseDirectory
;
if
(
systemPropertyBaseDirectory
!
=
null
)
{
baseDirectory
=
systemPropertyBaseDirectory
+
context
.
getPackageName
(
)
+
"
/
distribution
"
;
}
else
{
baseDirectory
=
"
/
system
/
"
+
context
.
getPackageName
(
)
+
"
/
distribution
"
;
}
return
getDistributionDirectoriesFromBaseDirectory
(
context
baseDirectory
)
;
}
private
static
String
[
]
getDataDistributionDirectories
(
Context
context
)
{
final
String
baseDirectory
=
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
DISTRIBUTION_PATH
)
.
getAbsolutePath
(
)
;
return
getDistributionDirectoriesFromBaseDirectory
(
context
baseDirectory
)
;
}
private
static
String
[
]
getDistributionDirectoriesFromBaseDirectory
(
Context
context
String
baseDirectory
)
{
final
TelephonyManager
telephonyManager
=
(
TelephonyManager
)
context
.
getSystemService
(
Context
.
TELEPHONY_SERVICE
)
;
if
(
telephonyManager
!
=
null
&
&
telephonyManager
.
getSimState
(
)
=
=
TelephonyManager
.
SIM_STATE_READY
)
{
final
String
simOperator
=
telephonyManager
.
getSimOperator
(
)
;
if
(
simOperator
!
=
null
&
&
simOperator
.
length
(
)
>
=
5
)
{
final
String
mcc
=
simOperator
.
substring
(
0
3
)
;
final
String
mnc
=
simOperator
.
substring
(
3
)
;
return
new
String
[
]
{
baseDirectory
+
"
/
"
+
mcc
+
"
/
"
+
mnc
baseDirectory
+
"
/
"
+
mcc
baseDirectory
+
"
/
default
"
baseDirectory
}
;
}
}
return
new
String
[
]
{
baseDirectory
+
"
/
default
"
baseDirectory
}
;
}
public
void
addOnDistributionReadyCallback
(
final
ReadyCallback
callback
)
{
if
(
state
=
=
STATE_UNKNOWN
)
{
onDistributionReady
.
add
(
callback
)
;
}
else
{
invokeCallbackDelayed
(
callback
)
;
}
}
private
void
runLateReadyQueue
(
)
{
ReadyCallback
task
;
while
(
(
task
=
onLateReady
.
poll
(
)
)
!
=
null
)
{
invokeLateCallbackDelayed
(
task
)
;
}
}
private
void
runReadyQueue
(
)
{
ReadyCallback
task
;
while
(
(
task
=
onDistributionReady
.
poll
(
)
)
!
=
null
)
{
invokeCallbackDelayed
(
task
)
;
}
}
private
void
invokeLateCallbackDelayed
(
final
ReadyCallback
callback
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
state
!
=
STATE_SET
)
{
Log
.
w
(
LOGTAG
"
Refusing
to
invoke
late
distro
callback
in
state
"
+
state
)
;
return
;
}
callback
.
distributionArrivedLate
(
Distribution
.
this
)
;
}
}
)
;
}
private
void
invokeCallbackDelayed
(
final
ReadyCallback
callback
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
WorkerThread
Override
public
void
run
(
)
{
switch
(
state
)
{
case
STATE_SET
:
callback
.
distributionFound
(
Distribution
.
this
)
;
break
;
case
STATE_NONE
:
callback
.
distributionNotFound
(
)
;
if
(
shouldDelayLateCallbacks
)
{
onLateReady
.
add
(
callback
)
;
}
break
;
default
:
throw
new
IllegalStateException
(
"
Expected
STATE_NONE
or
STATE_SET
got
"
+
state
)
;
}
}
}
)
;
}
public
boolean
exists
(
)
{
return
state
=
=
STATE_SET
;
}
private
String
getKeyName
(
)
{
return
context
.
getPackageName
(
)
+
"
.
distribution_state
"
;
}
private
SharedPreferences
getSharedPreferences
(
)
{
final
SharedPreferences
settings
;
if
(
prefsBranch
=
=
null
)
{
settings
=
GeckoSharedPrefs
.
forApp
(
context
)
;
}
else
{
settings
=
context
.
getSharedPreferences
(
prefsBranch
Activity
.
MODE_PRIVATE
)
;
}
return
settings
;
}
}
