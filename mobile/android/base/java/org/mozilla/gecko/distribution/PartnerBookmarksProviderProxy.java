package
org
.
mozilla
.
gecko
.
distribution
;
import
android
.
content
.
ContentProvider
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
ContentUris
;
import
android
.
content
.
ContentValues
;
import
android
.
content
.
Context
;
import
android
.
content
.
UriMatcher
;
import
android
.
database
.
Cursor
;
import
android
.
net
.
Uri
;
import
android
.
support
.
annotation
.
NonNull
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
public
class
PartnerBookmarksProviderProxy
extends
ContentProvider
{
public
static
class
PartnerContract
{
public
static
final
Uri
CONTENT_URI
=
Uri
.
parse
(
"
content
:
/
/
com
.
android
.
partnerbookmarks
/
bookmarks
"
)
;
public
static
final
int
TYPE_BOOKMARK
=
1
;
public
static
final
int
TYPE_FOLDER
=
2
;
public
static
final
int
PARENT_ROOT_ID
=
0
;
public
static
final
String
ID
=
"
_id
"
;
public
static
final
String
TYPE
=
"
type
"
;
public
static
final
String
URL
=
"
url
"
;
public
static
final
String
TITLE
=
"
title
"
;
public
static
final
String
FAVICON
=
"
favicon
"
;
public
static
final
String
TOUCHICON
=
"
touchicon
"
;
public
static
final
String
PARENT
=
"
parent
"
;
}
private
static
final
String
AUTHORITY_PREFIX
=
"
.
partnerbookmarks
"
;
private
static
final
int
URI_MATCH_BOOKMARKS
=
1000
;
private
static
final
int
URI_MATCH_ICON
=
1001
;
private
static
String
getAuthority
(
Context
context
)
{
return
context
.
getPackageName
(
)
+
AUTHORITY_PREFIX
;
}
public
static
Uri
getUriForBookmarks
(
Context
context
long
folderId
)
{
return
new
Uri
.
Builder
(
)
.
scheme
(
"
content
"
)
.
authority
(
getAuthority
(
context
)
)
.
appendPath
(
"
bookmarks
"
)
.
appendPath
(
String
.
valueOf
(
folderId
)
)
.
build
(
)
;
}
public
static
Uri
getUriForIcon
(
Context
context
long
bookmarkId
)
{
return
new
Uri
.
Builder
(
)
.
scheme
(
"
content
"
)
.
authority
(
getAuthority
(
context
)
)
.
appendPath
(
"
icons
"
)
.
appendPath
(
String
.
valueOf
(
bookmarkId
)
)
.
build
(
)
;
}
private
final
UriMatcher
uriMatcher
=
new
UriMatcher
(
UriMatcher
.
NO_MATCH
)
;
Override
public
boolean
onCreate
(
)
{
String
authority
=
getAuthority
(
assertAndGetContext
(
)
)
;
uriMatcher
.
addURI
(
authority
"
bookmarks
/
*
"
URI_MATCH_BOOKMARKS
)
;
uriMatcher
.
addURI
(
authority
"
icons
/
*
"
URI_MATCH_ICON
)
;
return
true
;
}
Override
public
Cursor
query
(
NonNull
Uri
uri
String
[
]
projection
String
selection
String
[
]
selectionArgs
String
sortOrder
)
{
final
int
match
=
uriMatcher
.
match
(
uri
)
;
final
ContentResolver
contentResolver
=
assertAndGetContext
(
)
.
getContentResolver
(
)
;
switch
(
match
)
{
case
URI_MATCH_BOOKMARKS
:
final
long
bookmarkId
=
ContentUris
.
parseId
(
uri
)
;
if
(
bookmarkId
=
=
-
1
)
{
throw
new
IllegalArgumentException
(
"
Bookmark
id
is
not
a
number
"
)
;
}
return
getBookmarksInFolder
(
contentResolver
bookmarkId
)
;
case
URI_MATCH_ICON
:
return
getIcon
(
contentResolver
ContentUris
.
parseId
(
uri
)
)
;
default
:
throw
new
UnsupportedOperationException
(
"
Unknown
URI
"
+
uri
.
toString
(
)
)
;
}
}
;
private
Cursor
getBookmarksInFolder
(
ContentResolver
contentResolver
long
folderId
)
{
final
long
actualFolderId
=
folderId
=
=
BrowserContract
.
Bookmarks
.
FIXED_ROOT_ID
?
PartnerContract
.
PARENT_ROOT_ID
:
BrowserContract
.
Bookmarks
.
FAKE_PARTNER_BOOKMARKS_START
-
folderId
;
return
contentResolver
.
query
(
PartnerContract
.
CONTENT_URI
new
String
[
]
{
"
(
"
+
BrowserContract
.
Bookmarks
.
FAKE_PARTNER_BOOKMARKS_START
+
"
-
"
+
PartnerContract
.
ID
+
"
)
as
"
+
BrowserContract
.
Bookmarks
.
_ID
"
(
"
+
BrowserContract
.
Bookmarks
.
FAKE_PARTNER_BOOKMARKS_START
+
"
-
"
+
PartnerContract
.
ID
+
"
)
as
"
+
BrowserContract
.
Combined
.
BOOKMARK_ID
PartnerContract
.
TITLE
+
"
as
"
+
BrowserContract
.
Bookmarks
.
TITLE
PartnerContract
.
URL
+
"
as
"
+
BrowserContract
.
Bookmarks
.
URL
"
(
"
+
BrowserContract
.
Bookmarks
.
FAKE_PARTNER_BOOKMARKS_START
+
"
-
"
+
PartnerContract
.
PARENT
+
"
)
as
"
+
BrowserContract
.
Bookmarks
.
PARENT
"
(
2
-
"
+
PartnerContract
.
TYPE
+
"
)
as
"
+
BrowserContract
.
Bookmarks
.
TYPE
PartnerContract
.
ID
+
"
as
"
+
BrowserContract
.
Bookmarks
.
GUID
}
PartnerContract
.
PARENT
+
"
=
?
"
+
"
AND
(
"
+
BrowserContract
.
Bookmarks
.
TYPE
+
"
=
?
OR
"
+
BrowserContract
.
Bookmarks
.
TYPE
+
"
=
?
)
"
+
"
AND
"
+
BrowserContract
.
Bookmarks
.
TITLE
+
"
<
>
'
'
"
new
String
[
]
{
String
.
valueOf
(
actualFolderId
)
String
.
valueOf
(
PartnerContract
.
TYPE_BOOKMARK
)
String
.
valueOf
(
PartnerContract
.
TYPE_FOLDER
)
}
BrowserContract
.
Bookmarks
.
TYPE
+
"
ASC
"
+
BrowserContract
.
Bookmarks
.
_ID
+
"
ASC
"
)
;
}
private
Cursor
getIcon
(
ContentResolver
contentResolver
long
bookmarkId
)
{
final
long
actualId
=
BrowserContract
.
Bookmarks
.
FAKE_PARTNER_BOOKMARKS_START
-
bookmarkId
;
return
contentResolver
.
query
(
PartnerContract
.
CONTENT_URI
new
String
[
]
{
PartnerContract
.
TOUCHICON
PartnerContract
.
FAVICON
}
PartnerContract
.
ID
+
"
=
?
"
new
String
[
]
{
String
.
valueOf
(
actualId
)
}
null
)
;
}
private
Context
assertAndGetContext
(
)
{
final
Context
context
=
super
.
getContext
(
)
;
if
(
context
=
=
null
)
{
throw
new
AssertionError
(
"
Context
is
null
"
)
;
}
return
context
;
}
Override
public
String
getType
(
NonNull
Uri
uri
)
{
throw
new
UnsupportedOperationException
(
)
;
}
Override
public
Uri
insert
(
NonNull
Uri
uri
ContentValues
values
)
{
throw
new
UnsupportedOperationException
(
)
;
}
Override
public
int
delete
(
NonNull
Uri
uri
String
selection
String
[
]
selectionArgs
)
{
throw
new
UnsupportedOperationException
(
)
;
}
Override
public
int
update
(
NonNull
Uri
uri
ContentValues
values
String
selection
String
[
]
selectionArgs
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
