package
org
.
mozilla
.
gecko
.
tabs
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
widget
.
GridSpacingDecoration
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Resources
;
import
android
.
support
.
v7
.
widget
.
GridLayoutManager
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
class
AutoFitTabsGridLayout
extends
TabsGridLayout
{
private
static
final
String
LOGTAG
=
"
Gecko
"
+
AutoFitTabsGridLayout
.
class
.
getSimpleName
(
)
;
private
GridSpacingDecoration
spacingDecoration
;
private
final
int
desiredItemWidth
;
private
final
int
desiredHorizontalItemSpacing
;
private
final
int
minHorizontalItemSpacing
;
private
final
int
verticalItemPadding
;
AutoFitTabsGridLayout
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
1
)
;
final
Resources
resources
=
context
.
getResources
(
)
;
desiredItemWidth
=
resources
.
getDimensionPixelSize
(
R
.
dimen
.
tab_panel_item_width
)
;
desiredHorizontalItemSpacing
=
resources
.
getDimensionPixelSize
(
R
.
dimen
.
tab_panel_grid_ideal_item_hspacing
)
;
minHorizontalItemSpacing
=
resources
.
getDimensionPixelOffset
(
R
.
dimen
.
tab_panel_grid_min_item_hspacing
)
;
verticalItemPadding
=
resources
.
getDimensionPixelSize
(
R
.
dimen
.
tab_panel_grid_item_vpadding
)
;
final
int
viewPaddingVertical
=
resources
.
getDimensionPixelSize
(
R
.
dimen
.
tab_panel_grid_vpadding
)
;
final
int
viewPaddingHorizontal
=
resources
.
getDimensionPixelSize
(
R
.
dimen
.
tab_panel_grid_hpadding
)
;
setPadding
(
viewPaddingHorizontal
viewPaddingVertical
viewPaddingHorizontal
viewPaddingVertical
)
;
}
private
void
updateSpacingDecoration
(
int
horizontalItemSpacing
)
{
if
(
spacingDecoration
!
=
null
)
{
removeItemDecoration
(
spacingDecoration
)
;
}
spacingDecoration
=
new
GridSpacingDecoration
(
horizontalItemSpacing
verticalItemPadding
)
;
addItemDecoration
(
spacingDecoration
)
;
updateSelectedPosition
(
)
;
}
Override
public
void
onSizeChanged
(
int
w
int
h
int
oldw
int
oldh
)
{
super
.
onSizeChanged
(
w
h
oldw
oldh
)
;
if
(
w
=
=
oldw
)
{
return
;
}
final
GridLayoutManager
layoutManager
=
(
GridLayoutManager
)
getLayoutManager
(
)
;
final
int
nonPaddingWidth
=
w
-
getPaddingLeft
(
)
-
getPaddingRight
(
)
;
final
int
idealSpacingSpanCount
=
Math
.
max
(
1
(
nonPaddingWidth
+
desiredHorizontalItemSpacing
)
/
(
desiredItemWidth
+
desiredHorizontalItemSpacing
)
)
;
final
int
maxSpanCount
=
Math
.
max
(
1
(
nonPaddingWidth
+
minHorizontalItemSpacing
)
/
(
desiredItemWidth
+
minHorizontalItemSpacing
)
)
;
if
(
idealSpacingSpanCount
=
=
maxSpanCount
)
{
layoutManager
.
setSpanCount
(
idealSpacingSpanCount
)
;
updateSpacingDecoration
(
desiredHorizontalItemSpacing
)
;
}
else
{
layoutManager
.
setSpanCount
(
maxSpanCount
)
;
for
(
int
spacing
=
minHorizontalItemSpacing
+
1
;
spacing
<
=
desiredHorizontalItemSpacing
;
spacing
+
+
)
{
if
(
maxSpanCount
*
desiredItemWidth
+
(
maxSpanCount
-
1
)
*
spacing
>
nonPaddingWidth
)
{
updateSpacingDecoration
(
spacing
-
1
)
;
return
;
}
}
Log
.
e
(
LOGTAG
"
Span
count
calculation
error
"
)
;
updateSpacingDecoration
(
minHorizontalItemSpacing
)
;
}
}
}
