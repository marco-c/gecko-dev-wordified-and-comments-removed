package
org
.
mozilla
.
gecko
.
prompts
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
Tab
;
import
org
.
mozilla
.
gecko
.
Tabs
;
import
android
.
app
.
AlertDialog
;
import
android
.
content
.
Context
;
import
android
.
content
.
DialogInterface
;
import
android
.
content
.
DialogInterface
.
OnCancelListener
;
import
android
.
content
.
DialogInterface
.
OnClickListener
;
import
android
.
content
.
res
.
Resources
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
view
.
Gravity
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
widget
.
AdapterView
;
import
android
.
widget
.
AdapterView
.
OnItemClickListener
;
import
android
.
widget
.
LinearLayout
;
import
android
.
widget
.
ListView
;
import
android
.
widget
.
ScrollView
;
import
java
.
util
.
ArrayList
;
public
class
Prompt
implements
OnClickListener
OnCancelListener
OnItemClickListener
PromptInput
.
OnChangeListener
Tabs
.
OnTabsChangedListener
{
private
static
final
String
LOGTAG
=
"
GeckoPromptService
"
;
private
String
[
]
mButtons
;
private
PromptInput
[
]
mInputs
;
private
AlertDialog
mDialog
;
private
int
mDoubleTapButtonType
;
private
final
LayoutInflater
mInflater
;
private
final
Context
mContext
;
private
PromptCallback
mCallback
;
private
String
mGuid
;
private
PromptListAdapter
mAdapter
;
private
static
boolean
mInitialized
;
private
static
int
mInputPaddingSize
;
private
int
mTabId
=
Tabs
.
INVALID_TAB_ID
;
private
Object
mPreviousInputValue
=
null
;
public
Prompt
(
Context
context
PromptCallback
callback
)
{
this
(
context
)
;
mCallback
=
callback
;
}
private
Prompt
(
Context
context
)
{
mContext
=
context
;
mInflater
=
LayoutInflater
.
from
(
mContext
)
;
if
(
!
mInitialized
)
{
Resources
res
=
mContext
.
getResources
(
)
;
mInputPaddingSize
=
(
int
)
(
res
.
getDimension
(
R
.
dimen
.
prompt_service_inputs_padding
)
)
;
mInitialized
=
true
;
}
}
private
View
applyInputStyle
(
View
view
PromptInput
input
)
{
if
(
input
.
canApplyInputStyle
(
)
)
{
view
.
setPadding
(
mInputPaddingSize
0
mInputPaddingSize
0
)
;
}
return
view
;
}
public
void
show
(
GeckoBundle
message
)
{
String
title
=
message
.
getString
(
"
title
"
"
"
)
;
String
text
=
message
.
getString
(
"
text
"
"
"
)
;
mGuid
=
message
.
getString
(
"
guid
"
"
"
)
;
mButtons
=
message
.
getStringArray
(
"
buttons
"
)
;
final
int
buttonCount
=
mButtons
=
=
null
?
0
:
mButtons
.
length
;
mDoubleTapButtonType
=
convertIndexToButtonType
(
message
.
getInt
(
"
doubleTapButton
"
-
1
)
buttonCount
)
;
mPreviousInputValue
=
null
;
GeckoBundle
[
]
inputs
=
message
.
getBundleArray
(
"
inputs
"
)
;
mInputs
=
new
PromptInput
[
inputs
!
=
null
?
inputs
.
length
:
0
]
;
for
(
int
i
=
0
;
i
<
mInputs
.
length
;
i
+
+
)
{
mInputs
[
i
]
=
PromptInput
.
getInput
(
inputs
[
i
]
)
;
mInputs
[
i
]
.
setListener
(
this
)
;
}
PromptListItem
[
]
menuitems
=
PromptListItem
.
getArray
(
message
.
getBundleArray
(
"
listitems
"
)
)
;
String
selected
=
message
.
getString
(
"
choiceMode
"
"
"
)
;
int
choiceMode
=
ListView
.
CHOICE_MODE_NONE
;
if
(
"
single
"
.
equals
(
selected
)
)
{
choiceMode
=
ListView
.
CHOICE_MODE_SINGLE
;
}
else
if
(
"
multiple
"
.
equals
(
selected
)
)
{
choiceMode
=
ListView
.
CHOICE_MODE_MULTIPLE
;
}
mTabId
=
message
.
getInt
(
"
tabId
"
Tabs
.
INVALID_TAB_ID
)
;
show
(
title
text
menuitems
choiceMode
)
;
}
private
int
convertIndexToButtonType
(
final
int
buttonIndex
final
int
buttonCount
)
{
if
(
buttonIndex
<
0
|
|
buttonIndex
>
=
buttonCount
)
{
return
0
;
}
switch
(
buttonIndex
)
{
case
0
:
return
DialogInterface
.
BUTTON_POSITIVE
;
case
1
:
return
DialogInterface
.
BUTTON_NEUTRAL
;
case
2
:
return
DialogInterface
.
BUTTON_NEGATIVE
;
default
:
return
0
;
}
}
public
void
show
(
String
title
String
text
PromptListItem
[
]
listItems
int
choiceMode
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
try
{
create
(
title
text
listItems
choiceMode
)
;
}
catch
(
IllegalStateException
ex
)
{
Log
.
i
(
LOGTAG
"
Error
building
dialog
"
ex
)
;
return
;
}
if
(
mTabId
!
=
Tabs
.
INVALID_TAB_ID
)
{
Tabs
.
registerOnTabsChangedListener
(
this
)
;
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getTab
(
mTabId
)
;
if
(
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
=
=
tab
)
{
mDialog
.
show
(
)
;
}
}
else
{
mDialog
.
show
(
)
;
}
}
Override
public
void
onTabChanged
(
final
Tab
tab
final
Tabs
.
TabEvents
msg
final
String
data
)
{
if
(
tab
!
=
Tabs
.
getInstance
(
)
.
getTab
(
mTabId
)
)
{
return
;
}
switch
(
msg
)
{
case
SELECTED
:
Log
.
i
(
LOGTAG
"
Selected
"
)
;
mDialog
.
show
(
)
;
break
;
case
UNSELECTED
:
Log
.
i
(
LOGTAG
"
Unselected
"
)
;
mDialog
.
hide
(
)
;
break
;
case
LOCATION_CHANGE
:
Log
.
i
(
LOGTAG
"
Location
change
"
)
;
mDialog
.
cancel
(
)
;
break
;
}
}
private
void
create
(
String
title
String
text
PromptListItem
[
]
listItems
int
choiceMode
)
throws
IllegalStateException
{
AlertDialog
.
Builder
builder
=
new
AlertDialog
.
Builder
(
mContext
)
;
if
(
!
TextUtils
.
isEmpty
(
title
)
)
{
builder
.
setTitle
(
title
.
substring
(
0
Math
.
min
(
title
.
length
(
)
256
)
)
)
;
}
if
(
!
TextUtils
.
isEmpty
(
text
)
)
{
builder
.
setMessage
(
text
)
;
}
if
(
listItems
!
=
null
&
&
listItems
.
length
>
0
)
{
addListItems
(
builder
listItems
choiceMode
)
;
}
else
if
(
!
addInputs
(
builder
)
)
{
throw
new
IllegalStateException
(
"
Could
not
add
inputs
to
dialog
"
)
;
}
int
length
=
mButtons
=
=
null
?
0
:
mButtons
.
length
;
if
(
length
>
0
)
{
builder
.
setPositiveButton
(
mButtons
[
0
]
this
)
;
if
(
length
>
1
)
{
builder
.
setNeutralButton
(
mButtons
[
1
]
this
)
;
if
(
length
>
2
)
{
builder
.
setNegativeButton
(
mButtons
[
2
]
this
)
;
}
}
}
mDialog
=
builder
.
create
(
)
;
mDialog
.
setOnCancelListener
(
Prompt
.
this
)
;
}
public
void
setButtons
(
String
[
]
buttons
)
{
mButtons
=
buttons
;
}
public
void
setInputs
(
PromptInput
[
]
inputs
)
{
mInputs
=
inputs
;
}
private
void
addListResult
(
final
GeckoBundle
result
int
which
)
{
if
(
mAdapter
=
=
null
)
{
return
;
}
final
ArrayList
<
Integer
>
selected
=
mAdapter
.
getSelected
(
)
;
if
(
result
.
getInt
(
"
button
"
-
1
)
=
=
-
1
)
{
if
(
!
selected
.
contains
(
which
)
)
{
selected
.
add
(
which
)
;
}
result
.
putInt
(
"
button
"
which
)
;
}
result
.
putIntArray
(
"
list
"
selected
)
;
}
private
void
addInputValues
(
final
GeckoBundle
result
)
{
if
(
mInputs
=
=
null
)
{
return
;
}
for
(
final
PromptInput
input
:
mInputs
)
{
if
(
input
=
=
null
)
{
continue
;
}
input
.
putInBundle
(
result
)
;
}
}
private
void
addButtonResult
(
final
GeckoBundle
result
int
which
)
{
int
button
=
-
1
;
switch
(
which
)
{
case
DialogInterface
.
BUTTON_POSITIVE
:
button
=
0
;
break
;
case
DialogInterface
.
BUTTON_NEUTRAL
:
button
=
1
;
break
;
case
DialogInterface
.
BUTTON_NEGATIVE
:
button
=
2
;
break
;
}
result
.
putInt
(
"
button
"
button
)
;
}
Override
public
void
onClick
(
DialogInterface
dialog
int
which
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
closeDialog
(
which
)
;
}
private
void
addListItems
(
AlertDialog
.
Builder
builder
PromptListItem
[
]
listItems
int
choiceMode
)
{
switch
(
choiceMode
)
{
case
ListView
.
CHOICE_MODE_MULTIPLE_MODAL
:
case
ListView
.
CHOICE_MODE_MULTIPLE
:
addMultiSelectList
(
builder
listItems
)
;
break
;
case
ListView
.
CHOICE_MODE_SINGLE
:
addSingleSelectList
(
builder
listItems
)
;
break
;
case
ListView
.
CHOICE_MODE_NONE
:
default
:
addMenuList
(
builder
listItems
)
;
}
}
private
void
addMultiSelectList
(
AlertDialog
.
Builder
builder
PromptListItem
[
]
listItems
)
{
ListView
listView
=
(
ListView
)
mInflater
.
inflate
(
R
.
layout
.
select_dialog_list
null
)
;
listView
.
setOnItemClickListener
(
this
)
;
listView
.
setChoiceMode
(
ListView
.
CHOICE_MODE_MULTIPLE
)
;
mAdapter
=
new
PromptListAdapter
(
mContext
R
.
layout
.
select_dialog_multichoice
listItems
)
;
listView
.
setAdapter
(
mAdapter
)
;
builder
.
setView
(
listView
)
;
}
private
void
addSingleSelectList
(
AlertDialog
.
Builder
builder
PromptListItem
[
]
listItems
)
{
mAdapter
=
new
PromptListAdapter
(
mContext
R
.
layout
.
select_dialog_singlechoice
listItems
)
;
builder
.
setSingleChoiceItems
(
mAdapter
mAdapter
.
getSelectedIndex
(
)
new
DialogInterface
.
OnClickListener
(
)
{
Override
public
void
onClick
(
DialogInterface
dialog
int
which
)
{
ArrayList
<
Integer
>
selected
=
mAdapter
.
getSelected
(
)
;
for
(
Integer
sel
:
selected
)
{
mAdapter
.
toggleSelected
(
sel
)
;
}
mAdapter
.
toggleSelected
(
which
)
;
closeIfNoButtons
(
which
)
;
}
}
)
;
}
private
void
addMenuList
(
AlertDialog
.
Builder
builder
PromptListItem
[
]
listItems
)
{
mAdapter
=
new
PromptListAdapter
(
mContext
android
.
R
.
layout
.
simple_list_item_1
listItems
)
;
builder
.
setAdapter
(
mAdapter
this
)
;
}
private
View
wrapInput
(
final
PromptInput
input
)
{
final
LinearLayout
linearLayout
=
new
LinearLayout
(
mContext
)
;
linearLayout
.
setOrientation
(
LinearLayout
.
VERTICAL
)
;
applyInputStyle
(
linearLayout
input
)
;
View
widget
=
input
.
getView
(
mContext
)
;
LinearLayout
.
LayoutParams
parentParams
=
new
LinearLayout
.
LayoutParams
(
ViewGroup
.
LayoutParams
.
WRAP_CONTENT
ViewGroup
.
LayoutParams
.
WRAP_CONTENT
)
;
parentParams
.
gravity
=
Gravity
.
CENTER
;
widget
.
setLayoutParams
(
parentParams
)
;
linearLayout
.
addView
(
widget
)
;
return
linearLayout
;
}
private
boolean
addInputs
(
AlertDialog
.
Builder
builder
)
{
int
length
=
mInputs
=
=
null
?
0
:
mInputs
.
length
;
if
(
length
=
=
0
)
{
return
true
;
}
try
{
View
root
=
null
;
boolean
scrollable
=
false
;
if
(
length
=
=
1
)
{
root
=
wrapInput
(
mInputs
[
0
]
)
;
scrollable
|
=
mInputs
[
0
]
.
getScrollable
(
)
;
}
else
if
(
length
>
1
)
{
LinearLayout
linearLayout
=
new
LinearLayout
(
mContext
)
;
linearLayout
.
setOrientation
(
LinearLayout
.
VERTICAL
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
View
content
=
wrapInput
(
mInputs
[
i
]
)
;
linearLayout
.
addView
(
content
)
;
scrollable
|
=
mInputs
[
i
]
.
getScrollable
(
)
;
}
root
=
linearLayout
;
}
if
(
scrollable
)
{
builder
.
setInverseBackgroundForced
(
true
)
;
builder
.
setView
(
root
)
;
}
else
{
ScrollView
view
=
new
ScrollView
(
mContext
)
;
view
.
addView
(
root
)
;
builder
.
setView
(
view
)
;
}
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Error
showing
prompt
inputs
"
ex
)
;
cancelDialog
(
)
;
return
false
;
}
return
true
;
}
Override
public
void
onItemClick
(
AdapterView
<
?
>
parent
View
view
int
position
long
id
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
mAdapter
.
toggleSelected
(
position
)
;
closeIfNoButtons
(
position
)
;
}
private
boolean
closeIfNoButtons
(
int
selected
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mButtons
=
=
null
|
|
mButtons
.
length
=
=
0
)
{
closeDialog
(
selected
)
;
return
true
;
}
return
false
;
}
Override
public
void
onCancel
(
DialogInterface
aDialog
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
cancelDialog
(
)
;
}
private
void
cancelDialog
(
)
{
final
GeckoBundle
ret
=
new
GeckoBundle
(
)
;
ret
.
putInt
(
"
button
"
-
1
)
;
addInputValues
(
ret
)
;
notifyClosing
(
ret
)
;
}
private
void
closeDialog
(
int
which
)
{
final
GeckoBundle
ret
=
new
GeckoBundle
(
)
;
mDialog
.
dismiss
(
)
;
addButtonResult
(
ret
which
)
;
addListResult
(
ret
which
)
;
addInputValues
(
ret
)
;
notifyClosing
(
ret
)
;
}
private
void
notifyClosing
(
final
GeckoBundle
ret
)
{
ret
.
putString
(
"
guid
"
mGuid
)
;
if
(
mTabId
!
=
Tabs
.
INVALID_TAB_ID
)
{
Tabs
.
unregisterOnTabsChangedListener
(
this
)
;
}
if
(
mCallback
!
=
null
)
{
mCallback
.
onPromptFinished
(
ret
)
;
}
}
Override
public
void
onChange
(
PromptInput
input
)
{
if
(
!
closeIfNoButtons
(
-
1
)
)
{
closeIfDoubleTapEnabled
(
input
.
getValue
(
)
)
;
}
}
private
boolean
closeIfDoubleTapEnabled
(
Object
inputValue
)
{
if
(
mDoubleTapButtonType
!
=
0
&
&
inputValue
=
=
mPreviousInputValue
)
{
closeDialog
(
mDoubleTapButtonType
)
;
return
true
;
}
mPreviousInputValue
=
inputValue
;
return
false
;
}
public
interface
PromptCallback
{
public
void
onPromptFinished
(
GeckoBundle
result
)
;
}
}
