package
org
.
mozilla
.
gecko
.
toolbar
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
EnumSet
;
import
java
.
util
.
List
;
import
android
.
support
.
v4
.
content
.
ContextCompat
;
import
org
.
mozilla
.
gecko
.
AboutPages
;
import
org
.
mozilla
.
gecko
.
BrowserApp
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
reader
.
ReaderModeUtils
;
import
org
.
mozilla
.
gecko
.
SiteIdentity
;
import
org
.
mozilla
.
gecko
.
Tab
;
import
org
.
mozilla
.
gecko
.
Tabs
;
import
org
.
mozilla
.
gecko
.
animation
.
PropertyAnimator
;
import
org
.
mozilla
.
gecko
.
animation
.
ViewHelper
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ViewUtil
;
import
org
.
mozilla
.
gecko
.
widget
.
themed
.
ThemedImageButton
;
import
org
.
mozilla
.
gecko
.
widget
.
themed
.
ThemedLinearLayout
;
import
org
.
mozilla
.
gecko
.
widget
.
themed
.
ThemedTextView
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
text
.
Editable
;
import
android
.
text
.
Spannable
;
import
android
.
text
.
SpannableStringBuilder
;
import
android
.
text
.
TextUtils
;
import
android
.
text
.
TextWatcher
;
import
android
.
text
.
style
.
ForegroundColorSpan
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
TypedValue
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
View
;
import
android
.
widget
.
Button
;
import
android
.
widget
.
HorizontalScrollView
;
public
class
ToolbarDisplayLayout
extends
ThemedLinearLayout
{
private
static
final
String
LOGTAG
=
"
GeckoToolbarDisplayLayout
"
;
private
static
final
int
MIN_DOMAIN_SCROLL_MARGIN_DP
=
10
;
private
boolean
mTrackingProtectionEnabled
;
enum
UpdateFlags
{
TITLE
FAVICON
PROGRESS
SITE_IDENTITY
PRIVATE_MODE
DISABLE_ANIMATIONS
}
private
enum
UIMode
{
PROGRESS
DISPLAY
}
interface
OnStopListener
{
Tab
onStop
(
)
;
}
interface
OnTitleChangeListener
{
void
onTitleChange
(
CharSequence
title
)
;
}
private
final
BrowserApp
mActivity
;
private
UIMode
mUiMode
;
private
boolean
mIsAttached
;
private
final
ThemedTextView
mTitle
;
private
final
ThemedLinearLayout
mThemeBackground
;
private
final
int
mTitlePadding
;
private
final
HorizontalScrollView
mTitleScroll
;
private
final
int
mMinUrlScrollMargin
;
private
ToolbarPrefs
mPrefs
;
private
OnTitleChangeListener
mTitleChangeListener
;
private
final
ThemedImageButton
mSiteSecurity
;
private
final
ThemedImageButton
mStop
;
private
OnStopListener
mStopListener
;
private
final
PageActionLayout
mPageActionLayout
;
private
final
SiteIdentityPopup
mSiteIdentityPopup
;
private
int
mSecurityImageLevel
;
private
final
ForegroundColorSpan
mUrlColorSpan
;
private
final
ForegroundColorSpan
mPrivateUrlColorSpan
;
private
final
ForegroundColorSpan
mBlockedColorSpan
;
private
final
ForegroundColorSpan
mPrivateBlockedColorSpan
;
private
final
ForegroundColorSpan
mDomainColorSpan
;
private
final
ForegroundColorSpan
mPrivateDomainColorSpan
;
public
ToolbarDisplayLayout
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
setOrientation
(
HORIZONTAL
)
;
mActivity
=
(
BrowserApp
)
context
;
LayoutInflater
.
from
(
context
)
.
inflate
(
R
.
layout
.
toolbar_display_layout
this
)
;
mTitle
=
(
ThemedTextView
)
findViewById
(
R
.
id
.
url_bar_title
)
;
mThemeBackground
=
(
ThemedLinearLayout
)
findViewById
(
R
.
id
.
url_bar_title_bg
)
;
mTitlePadding
=
mTitle
.
getPaddingRight
(
)
;
mTitleScroll
=
(
HorizontalScrollView
)
findViewById
(
R
.
id
.
url_bar_title_scroll_view
)
;
final
OnLayoutChangeListener
resizeListener
=
new
OnLayoutChangeListener
(
)
{
Override
public
void
onLayoutChange
(
View
v
int
left
int
top
int
right
int
bottom
int
oldLeft
int
oldTop
int
oldRight
int
oldBottom
)
{
final
int
oldWidth
=
oldRight
-
oldLeft
;
final
int
newWidth
=
right
-
left
;
if
(
newWidth
!
=
oldWidth
)
{
scrollTitle
(
)
;
}
}
}
;
mTitle
.
addTextChangedListener
(
new
TextChangeListener
(
)
)
;
mTitle
.
addOnLayoutChangeListener
(
resizeListener
)
;
mTitleScroll
.
addOnLayoutChangeListener
(
resizeListener
)
;
mMinUrlScrollMargin
=
(
int
)
TypedValue
.
applyDimension
(
TypedValue
.
COMPLEX_UNIT_DIP
MIN_DOMAIN_SCROLL_MARGIN_DP
getResources
(
)
.
getDisplayMetrics
(
)
)
;
mUrlColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_urltext
)
)
;
mPrivateUrlColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_urltext_private
)
)
;
mBlockedColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_blockedtext
)
)
;
mPrivateBlockedColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_blockedtext_private
)
)
;
mDomainColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_domaintext
)
)
;
mPrivateDomainColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_domaintext_private
)
)
;
mSiteSecurity
=
(
ThemedImageButton
)
findViewById
(
R
.
id
.
site_security
)
;
mSiteIdentityPopup
=
new
SiteIdentityPopup
(
mActivity
)
;
mSiteIdentityPopup
.
setAnchor
(
this
)
;
mSiteIdentityPopup
.
setOnVisibilityChangeListener
(
mActivity
)
;
mStop
=
(
ThemedImageButton
)
findViewById
(
R
.
id
.
stop
)
;
mPageActionLayout
=
(
PageActionLayout
)
findViewById
(
R
.
id
.
page_action_layout
)
;
}
Override
public
void
setPrivateMode
(
boolean
isPrivate
)
{
super
.
setPrivateMode
(
isPrivate
)
;
mSiteSecurity
.
setPrivateMode
(
isPrivate
)
;
mStop
.
setPrivateMode
(
isPrivate
)
;
mPageActionLayout
.
setPrivateMode
(
isPrivate
)
;
mTitle
.
setPrivateMode
(
isPrivate
)
;
mThemeBackground
.
setPrivateMode
(
isPrivate
)
;
}
Override
public
void
onAttachedToWindow
(
)
{
super
.
onAttachedToWindow
(
)
;
mIsAttached
=
true
;
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
updateFromTab
(
selectedTab
EnumSet
.
allOf
(
UpdateFlags
.
class
)
)
;
}
mSiteIdentityPopup
.
registerListeners
(
)
;
mSiteSecurity
.
setOnClickListener
(
new
Button
.
OnClickListener
(
)
{
Override
public
void
onClick
(
View
view
)
{
mSiteIdentityPopup
.
show
(
)
;
}
}
)
;
mStop
.
setOnClickListener
(
new
Button
.
OnClickListener
(
)
{
Override
public
void
onClick
(
View
v
)
{
if
(
mStopListener
!
=
null
)
{
final
Tab
tab
=
mStopListener
.
onStop
(
)
;
if
(
tab
!
=
null
)
{
updateUiMode
(
UIMode
.
DISPLAY
)
;
}
}
}
}
)
;
}
Override
public
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
mIsAttached
=
false
;
mSiteIdentityPopup
.
unregisterListeners
(
)
;
}
Override
public
void
setNextFocusDownId
(
int
nextId
)
{
mStop
.
setNextFocusDownId
(
nextId
)
;
mSiteSecurity
.
setNextFocusDownId
(
nextId
)
;
mPageActionLayout
.
setNextFocusDownId
(
nextId
)
;
}
void
setToolbarPrefs
(
final
ToolbarPrefs
prefs
)
{
mPrefs
=
prefs
;
}
void
updateFromTab
(
NonNull
Tab
tab
EnumSet
<
UpdateFlags
>
flags
)
{
if
(
!
mIsAttached
)
{
return
;
}
if
(
flags
.
contains
(
UpdateFlags
.
TITLE
)
)
{
updateTitle
(
tab
)
;
}
if
(
flags
.
contains
(
UpdateFlags
.
SITE_IDENTITY
)
)
{
updateSiteIdentity
(
tab
)
;
}
if
(
flags
.
contains
(
UpdateFlags
.
PROGRESS
)
)
{
updateProgress
(
tab
)
;
}
if
(
flags
.
contains
(
UpdateFlags
.
PRIVATE_MODE
)
)
{
mTitle
.
setPrivateMode
(
tab
.
isPrivate
(
)
)
;
mThemeBackground
.
setPrivateMode
(
tab
.
isPrivate
(
)
)
;
}
}
void
setTitle
(
CharSequence
title
)
{
mTitle
.
setText
(
title
)
;
if
(
TextUtils
.
isEmpty
(
title
)
)
{
ViewUtil
.
setTextDirection
(
mTitle
TEXT_DIRECTION_LOCALE
)
;
}
else
{
ViewUtil
.
setTextDirection
(
mTitle
TEXT_DIRECTION_FIRST_STRONG
)
;
}
if
(
mTitleChangeListener
!
=
null
)
{
mTitleChangeListener
.
onTitleChange
(
title
)
;
}
}
private
void
updateTitle
(
NonNull
Tab
tab
)
{
if
(
tab
.
isEnteringReaderMode
(
)
)
{
return
;
}
final
String
url
=
tab
.
getURL
(
)
;
if
(
AboutPages
.
isTitlelessAboutPage
(
url
)
)
{
setTitle
(
null
)
;
setContentDescription
(
null
)
;
return
;
}
if
(
tab
.
getErrorType
(
)
=
=
Tab
.
ErrorType
.
BLOCKED
)
{
final
String
title
=
tab
.
getDisplayTitle
(
)
;
final
SpannableStringBuilder
builder
=
new
SpannableStringBuilder
(
title
)
;
final
ForegroundColorSpan
fgColorSpan
=
tab
.
isPrivate
(
)
?
mPrivateBlockedColorSpan
:
mBlockedColorSpan
;
builder
.
setSpan
(
fgColorSpan
0
title
.
length
(
)
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
setTitle
(
builder
)
;
setContentDescription
(
null
)
;
return
;
}
final
String
baseDomain
=
tab
.
getHighlightDomain
(
)
;
String
strippedURL
=
stripAboutReaderURL
(
url
)
;
if
(
mPrefs
.
shouldTrimUrls
(
)
)
{
strippedURL
=
StringUtils
.
stripCommonSubdomains
(
StringUtils
.
stripScheme
(
strippedURL
)
)
;
}
strippedURL
=
StringUtils
.
forceLTR
(
strippedURL
)
;
setContentDescription
(
strippedURL
)
;
updateAndColorTitleFromFullURL
(
strippedURL
baseDomain
tab
.
isPrivate
(
)
)
;
}
private
void
updateAndColorTitleFromFullURL
(
String
url
String
baseDomain
boolean
isPrivate
)
{
if
(
TextUtils
.
isEmpty
(
baseDomain
)
)
{
setTitle
(
url
)
;
return
;
}
int
index
=
url
.
indexOf
(
baseDomain
)
;
if
(
index
=
=
-
1
)
{
setTitle
(
url
)
;
return
;
}
final
SpannableStringBuilder
builder
=
new
SpannableStringBuilder
(
url
)
;
builder
.
setSpan
(
isPrivate
?
mPrivateUrlColorSpan
:
mUrlColorSpan
0
url
.
length
(
)
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
builder
.
setSpan
(
isPrivate
?
mPrivateDomainColorSpan
:
mDomainColorSpan
index
index
+
baseDomain
.
length
(
)
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
setTitle
(
builder
)
;
}
private
String
stripAboutReaderURL
(
final
String
url
)
{
if
(
!
AboutPages
.
isAboutReader
(
url
)
)
{
return
url
;
}
return
ReaderModeUtils
.
stripAboutReaderUrl
(
url
)
;
}
private
void
updateSiteIdentity
(
NonNull
Tab
tab
)
{
final
SiteIdentity
siteIdentity
=
tab
.
getSiteIdentity
(
)
;
final
SecurityModeUtil
.
IconType
type
=
SecurityModeUtil
.
resolve
(
siteIdentity
tab
.
getURL
(
)
)
;
final
int
imageLevel
=
type
.
getImageLevel
(
)
;
mSiteIdentityPopup
.
setSiteIdentity
(
siteIdentity
)
;
mTrackingProtectionEnabled
=
SecurityModeUtil
.
isTrackingProtectionEnabled
(
siteIdentity
)
;
if
(
mSecurityImageLevel
!
=
imageLevel
)
{
mSecurityImageLevel
=
imageLevel
;
mSiteSecurity
.
setImageLevel
(
mSecurityImageLevel
)
;
updatePageActions
(
)
;
}
}
private
void
scrollTitle
(
)
{
final
Editable
text
=
mTitle
.
getEditableText
(
)
;
final
int
textViewWidth
=
mTitle
.
getWidth
(
)
;
final
int
textWidth
=
textViewWidth
-
mTitlePadding
;
final
int
scrollViewWidth
=
mTitleScroll
.
getWidth
(
)
;
if
(
textWidth
<
=
scrollViewWidth
)
{
if
(
textViewWidth
>
scrollViewWidth
)
{
mTitleScroll
.
scrollTo
(
0
0
)
;
}
return
;
}
final
ForegroundColorSpan
spanToCheck
=
mTitle
.
isPrivateMode
(
)
?
mPrivateDomainColorSpan
:
mDomainColorSpan
;
final
int
domainEnd
=
text
!
=
null
?
text
.
getSpanEnd
(
spanToCheck
)
:
-
1
;
if
(
domainEnd
=
=
-
1
)
{
mTitleScroll
.
scrollTo
(
0
0
)
;
return
;
}
final
int
domainTextWidth
=
StringUtils
.
getTextWidth
(
text
.
toString
(
)
0
domainEnd
mTitle
.
getPaint
(
)
)
;
final
int
overhang
=
textViewWidth
-
domainTextWidth
;
final
int
maxFadingEdge
=
mTitleScroll
.
getHorizontalFadingEdgeLength
(
)
;
int
targetMargin
=
overhang
/
2
;
targetMargin
=
Math
.
min
(
targetMargin
maxFadingEdge
)
;
targetMargin
=
Math
.
max
(
targetMargin
mMinUrlScrollMargin
)
;
final
int
scrollTarget
=
domainTextWidth
+
targetMargin
-
scrollViewWidth
;
mTitleScroll
.
scrollTo
(
scrollTarget
0
)
;
}
private
void
updateProgress
(
NonNull
Tab
tab
)
{
final
boolean
shouldShowThrobber
=
tab
.
getState
(
)
=
=
Tab
.
STATE_LOADING
;
updateUiMode
(
shouldShowThrobber
?
UIMode
.
PROGRESS
:
UIMode
.
DISPLAY
)
;
if
(
Tab
.
STATE_SUCCESS
=
=
tab
.
getState
(
)
&
&
mTrackingProtectionEnabled
)
{
mActivity
.
showTrackingProtectionPromptIfApplicable
(
)
;
}
}
private
void
updateUiMode
(
UIMode
uiMode
)
{
if
(
mUiMode
=
=
uiMode
)
{
return
;
}
mUiMode
=
uiMode
;
updatePageActions
(
)
;
}
private
void
updatePageActions
(
)
{
final
boolean
isShowingProgress
=
(
mUiMode
=
=
UIMode
.
PROGRESS
)
;
mStop
.
setVisibility
(
isShowingProgress
?
View
.
VISIBLE
:
View
.
GONE
)
;
mPageActionLayout
.
setVisibility
(
!
isShowingProgress
?
View
.
VISIBLE
:
View
.
GONE
)
;
mTitle
.
setPadding
(
0
0
(
!
isShowingProgress
?
mTitlePadding
:
0
)
0
)
;
}
List
<
?
extends
View
>
getFocusOrder
(
)
{
return
Arrays
.
asList
(
mSiteSecurity
mPageActionLayout
mStop
)
;
}
void
setOnStopListener
(
OnStopListener
listener
)
{
mStopListener
=
listener
;
}
void
setOnTitleChangeListener
(
OnTitleChangeListener
listener
)
{
mTitleChangeListener
=
listener
;
}
void
updateSiteIdentityAnchor
(
View
view
)
{
mSiteIdentityPopup
.
setAnchor
(
view
)
;
}
void
prepareStartEditingAnimation
(
)
{
ViewHelper
.
setAlpha
(
mPageActionLayout
0
)
;
ViewHelper
.
setAlpha
(
mStop
0
)
;
}
void
prepareStopEditingAnimation
(
PropertyAnimator
anim
)
{
anim
.
attach
(
mPageActionLayout
PropertyAnimator
.
Property
.
ALPHA
1
)
;
anim
.
attach
(
mStop
PropertyAnimator
.
Property
.
ALPHA
1
)
;
}
boolean
dismissSiteIdentityPopup
(
)
{
if
(
mSiteIdentityPopup
!
=
null
&
&
mSiteIdentityPopup
.
isShowing
(
)
)
{
mSiteIdentityPopup
.
dismiss
(
)
;
return
true
;
}
return
false
;
}
void
destroy
(
)
{
mSiteIdentityPopup
.
destroy
(
)
;
}
private
class
TextChangeListener
implements
TextWatcher
{
Override
public
void
afterTextChanged
(
Editable
text
)
{
scrollTitle
(
)
;
}
Override
public
void
beforeTextChanged
(
CharSequence
s
int
start
int
count
int
after
)
{
}
Override
public
void
onTextChanged
(
CharSequence
s
int
start
int
before
int
count
)
{
}
}
}
