package
org
.
mozilla
.
gecko
.
toolbar
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
EnumSet
;
import
java
.
util
.
List
;
import
android
.
support
.
v4
.
content
.
ContextCompat
;
import
org
.
mozilla
.
gecko
.
AboutPages
;
import
org
.
mozilla
.
gecko
.
BrowserApp
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
reader
.
ReaderModeUtils
;
import
org
.
mozilla
.
gecko
.
SiteIdentity
;
import
org
.
mozilla
.
gecko
.
Tab
;
import
org
.
mozilla
.
gecko
.
Tabs
;
import
org
.
mozilla
.
gecko
.
animation
.
PropertyAnimator
;
import
org
.
mozilla
.
gecko
.
animation
.
ViewHelper
;
import
org
.
mozilla
.
gecko
.
toolbar
.
BrowserToolbarTabletBase
.
ForwardButtonAnimation
;
import
org
.
mozilla
.
gecko
.
Experiments
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ViewUtil
;
import
org
.
mozilla
.
gecko
.
widget
.
themed
.
ThemedImageButton
;
import
org
.
mozilla
.
gecko
.
widget
.
themed
.
ThemedLinearLayout
;
import
org
.
mozilla
.
gecko
.
widget
.
themed
.
ThemedTextView
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
v4
.
view
.
ViewCompat
;
import
android
.
text
.
Spannable
;
import
android
.
text
.
SpannableString
;
import
android
.
text
.
SpannableStringBuilder
;
import
android
.
text
.
TextUtils
;
import
android
.
text
.
style
.
ForegroundColorSpan
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
View
;
import
android
.
widget
.
Button
;
import
android
.
widget
.
ImageButton
;
import
org
.
mozilla
.
gecko
.
switchboard
.
SwitchBoard
;
public
class
ToolbarDisplayLayout
extends
ThemedLinearLayout
{
private
static
final
String
LOGTAG
=
"
GeckoToolbarDisplayLayout
"
;
private
boolean
mTrackingProtectionEnabled
;
enum
UpdateFlags
{
TITLE
FAVICON
PROGRESS
SITE_IDENTITY
PRIVATE_MODE
DISABLE_ANIMATIONS
}
private
enum
UIMode
{
PROGRESS
DISPLAY
}
interface
OnStopListener
{
Tab
onStop
(
)
;
}
interface
OnTitleChangeListener
{
void
onTitleChange
(
CharSequence
title
)
;
}
private
final
BrowserApp
mActivity
;
private
UIMode
mUiMode
;
private
boolean
mIsAttached
;
private
final
ThemedTextView
mTitle
;
private
final
int
mTitlePadding
;
private
ToolbarPrefs
mPrefs
;
private
OnTitleChangeListener
mTitleChangeListener
;
private
final
ThemedImageButton
mSiteSecurity
;
private
final
ImageButton
mStop
;
private
OnStopListener
mStopListener
;
private
final
PageActionLayout
mPageActionLayout
;
private
final
SiteIdentityPopup
mSiteIdentityPopup
;
private
int
mSecurityImageLevel
;
private
static
final
int
LEVEL_DEFAULT_GLOBE
=
0
;
private
static
final
int
LEVEL_WARNING_MINOR
=
3
;
private
static
final
int
LEVEL_LOCK_DISABLED
=
4
;
private
static
final
int
LEVEL_SHIELD_ENABLED
=
5
;
private
static
final
int
LEVEL_SHIELD_DISABLED
=
6
;
private
static
final
int
LEVEL_SEARCH_ICON
=
999
;
private
final
ForegroundColorSpan
mUrlColorSpan
;
private
final
ForegroundColorSpan
mPrivateUrlColorSpan
;
private
final
ForegroundColorSpan
mBlockedColorSpan
;
private
final
ForegroundColorSpan
mPrivateBlockedColorSpan
;
private
final
ForegroundColorSpan
mDomainColorSpan
;
private
final
ForegroundColorSpan
mPrivateDomainColorSpan
;
private
final
ForegroundColorSpan
mCertificateOwnerColorSpan
;
private
final
ForegroundColorSpan
mPrivateCertificateOwnerColorSpan
;
public
ToolbarDisplayLayout
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
setOrientation
(
HORIZONTAL
)
;
mActivity
=
(
BrowserApp
)
context
;
LayoutInflater
.
from
(
context
)
.
inflate
(
R
.
layout
.
toolbar_display_layout
this
)
;
mTitle
=
(
ThemedTextView
)
findViewById
(
R
.
id
.
url_bar_title
)
;
mTitlePadding
=
mTitle
.
getPaddingRight
(
)
;
mUrlColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_urltext
)
)
;
mPrivateUrlColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_urltext_private
)
)
;
mBlockedColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_blockedtext
)
)
;
mPrivateBlockedColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_blockedtext_private
)
)
;
mDomainColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_domaintext
)
)
;
mPrivateDomainColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_domaintext_private
)
)
;
mCertificateOwnerColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_certificate_owner
)
)
;
mPrivateCertificateOwnerColorSpan
=
new
ForegroundColorSpan
(
ContextCompat
.
getColor
(
context
R
.
color
.
url_bar_certificate_owner_private
)
)
;
mSiteSecurity
=
(
ThemedImageButton
)
findViewById
(
R
.
id
.
site_security
)
;
mSiteIdentityPopup
=
new
SiteIdentityPopup
(
mActivity
)
;
mSiteIdentityPopup
.
setAnchor
(
this
)
;
mSiteIdentityPopup
.
setOnVisibilityChangeListener
(
mActivity
)
;
mStop
=
(
ImageButton
)
findViewById
(
R
.
id
.
stop
)
;
mPageActionLayout
=
(
PageActionLayout
)
findViewById
(
R
.
id
.
page_action_layout
)
;
}
Override
public
void
setPrivateMode
(
boolean
isPrivate
)
{
super
.
setPrivateMode
(
isPrivate
)
;
mSiteSecurity
.
setPrivateMode
(
isPrivate
)
;
}
Override
public
void
onAttachedToWindow
(
)
{
super
.
onAttachedToWindow
(
)
;
mIsAttached
=
true
;
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
updateFromTab
(
selectedTab
EnumSet
.
allOf
(
UpdateFlags
.
class
)
)
;
}
mSiteIdentityPopup
.
registerListeners
(
)
;
mSiteSecurity
.
setOnClickListener
(
new
Button
.
OnClickListener
(
)
{
Override
public
void
onClick
(
View
view
)
{
mSiteIdentityPopup
.
show
(
)
;
}
}
)
;
mStop
.
setOnClickListener
(
new
Button
.
OnClickListener
(
)
{
Override
public
void
onClick
(
View
v
)
{
if
(
mStopListener
!
=
null
)
{
final
Tab
tab
=
mStopListener
.
onStop
(
)
;
if
(
tab
!
=
null
)
{
updateUiMode
(
UIMode
.
DISPLAY
)
;
}
}
}
}
)
;
}
Override
public
void
onDetachedFromWindow
(
)
{
super
.
onDetachedFromWindow
(
)
;
mIsAttached
=
false
;
mSiteIdentityPopup
.
unregisterListeners
(
)
;
}
Override
public
void
setNextFocusDownId
(
int
nextId
)
{
mStop
.
setNextFocusDownId
(
nextId
)
;
mSiteSecurity
.
setNextFocusDownId
(
nextId
)
;
mPageActionLayout
.
setNextFocusDownId
(
nextId
)
;
}
void
setToolbarPrefs
(
final
ToolbarPrefs
prefs
)
{
mPrefs
=
prefs
;
}
void
updateFromTab
(
NonNull
Tab
tab
EnumSet
<
UpdateFlags
>
flags
)
{
if
(
!
mIsAttached
)
{
return
;
}
if
(
flags
.
contains
(
UpdateFlags
.
TITLE
)
)
{
updateTitle
(
tab
)
;
}
if
(
flags
.
contains
(
UpdateFlags
.
SITE_IDENTITY
)
)
{
updateSiteIdentity
(
tab
)
;
}
if
(
flags
.
contains
(
UpdateFlags
.
PROGRESS
)
)
{
updateProgress
(
tab
)
;
}
if
(
flags
.
contains
(
UpdateFlags
.
PRIVATE_MODE
)
)
{
mTitle
.
setPrivateMode
(
tab
.
isPrivate
(
)
)
;
}
}
void
setTitle
(
CharSequence
title
)
{
mTitle
.
setText
(
title
)
;
if
(
TextUtils
.
isEmpty
(
title
)
)
{
ViewUtil
.
setTextDirection
(
mTitle
TEXT_DIRECTION_LOCALE
)
;
}
else
{
ViewUtil
.
setTextDirection
(
mTitle
TEXT_DIRECTION_FIRST_STRONG
)
;
}
if
(
mTitleChangeListener
!
=
null
)
{
mTitleChangeListener
.
onTitleChange
(
title
)
;
}
}
private
void
updateTitle
(
NonNull
Tab
tab
)
{
if
(
tab
.
isEnteringReaderMode
(
)
)
{
return
;
}
final
String
url
=
tab
.
getURL
(
)
;
if
(
AboutPages
.
isTitlelessAboutPage
(
url
)
)
{
setTitle
(
null
)
;
setContentDescription
(
null
)
;
return
;
}
if
(
tab
.
getErrorType
(
)
=
=
Tab
.
ErrorType
.
BLOCKED
)
{
final
String
title
=
tab
.
getDisplayTitle
(
)
;
final
SpannableStringBuilder
builder
=
new
SpannableStringBuilder
(
title
)
;
final
ForegroundColorSpan
fgColorSpan
=
tab
.
isPrivate
(
)
?
mPrivateBlockedColorSpan
:
mBlockedColorSpan
;
builder
.
setSpan
(
fgColorSpan
0
title
.
length
(
)
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
setTitle
(
builder
)
;
setContentDescription
(
null
)
;
return
;
}
final
String
baseDomain
=
tab
.
getBaseDomain
(
)
;
String
strippedURL
=
stripAboutReaderURL
(
url
)
;
final
boolean
isHttpOrHttps
=
StringUtils
.
isHttpOrHttps
(
strippedURL
)
;
if
(
mPrefs
.
shouldTrimUrls
(
)
)
{
strippedURL
=
StringUtils
.
stripCommonSubdomains
(
StringUtils
.
stripScheme
(
strippedURL
)
)
;
}
strippedURL
=
StringUtils
.
forceLTR
(
strippedURL
)
;
setContentDescription
(
strippedURL
)
;
final
SiteIdentity
siteIdentity
=
tab
.
getSiteIdentity
(
)
;
if
(
siteIdentity
.
hasOwner
(
)
&
&
SwitchBoard
.
isInExperiment
(
mActivity
Experiments
.
URLBAR_SHOW_EV_CERT_OWNER
)
)
{
updateTitleFromSiteIdentity
(
siteIdentity
tab
.
isPrivate
(
)
)
;
}
else
if
(
isHttpOrHttps
&
&
!
HardwareUtils
.
isTablet
(
)
&
&
!
TextUtils
.
isEmpty
(
baseDomain
)
&
&
SwitchBoard
.
isInExperiment
(
mActivity
Experiments
.
URLBAR_SHOW_ORIGIN_ONLY
)
)
{
setTitle
(
baseDomain
)
;
}
else
{
updateAndColorTitleFromFullURL
(
strippedURL
baseDomain
tab
.
isPrivate
(
)
)
;
}
}
private
void
updateTitleFromSiteIdentity
(
SiteIdentity
siteIdentity
boolean
isPrivate
)
{
final
String
title
;
if
(
siteIdentity
.
hasCountry
(
)
)
{
title
=
String
.
format
(
"
%
s
(
%
s
)
"
siteIdentity
.
getOwner
(
)
siteIdentity
.
getCountry
(
)
)
;
}
else
{
title
=
siteIdentity
.
getOwner
(
)
;
}
final
SpannableString
spannable
=
new
SpannableString
(
title
)
;
final
ForegroundColorSpan
colorSpan
=
isPrivate
?
mPrivateCertificateOwnerColorSpan
:
mCertificateOwnerColorSpan
;
spannable
.
setSpan
(
colorSpan
0
title
.
length
(
)
Spannable
.
SPAN_EXCLUSIVE_EXCLUSIVE
)
;
setTitle
(
spannable
)
;
}
private
void
updateAndColorTitleFromFullURL
(
String
url
String
baseDomain
boolean
isPrivate
)
{
if
(
TextUtils
.
isEmpty
(
baseDomain
)
)
{
setTitle
(
url
)
;
return
;
}
int
index
=
url
.
indexOf
(
baseDomain
)
;
if
(
index
=
=
-
1
)
{
setTitle
(
url
)
;
return
;
}
final
SpannableStringBuilder
builder
=
new
SpannableStringBuilder
(
url
)
;
builder
.
setSpan
(
isPrivate
?
mPrivateUrlColorSpan
:
mUrlColorSpan
0
url
.
length
(
)
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
builder
.
setSpan
(
isPrivate
?
mPrivateDomainColorSpan
:
mDomainColorSpan
index
index
+
baseDomain
.
length
(
)
Spannable
.
SPAN_INCLUSIVE_INCLUSIVE
)
;
setTitle
(
builder
)
;
}
private
String
stripAboutReaderURL
(
final
String
url
)
{
if
(
!
AboutPages
.
isAboutReader
(
url
)
)
{
return
url
;
}
return
ReaderModeUtils
.
stripAboutReaderUrl
(
url
)
;
}
private
void
updateSiteIdentity
(
NonNull
Tab
tab
)
{
final
SiteIdentity
siteIdentity
=
tab
.
getSiteIdentity
(
)
;
final
SecurityModeUtil
.
IconType
type
=
SecurityModeUtil
.
resolve
(
siteIdentity
tab
.
getURL
(
)
)
;
final
int
imageLevel
=
SecurityModeUtil
.
getImageLevel
(
type
)
;
mSiteIdentityPopup
.
setSiteIdentity
(
siteIdentity
)
;
mTrackingProtectionEnabled
=
SecurityModeUtil
.
isTrackingProtectionEnabled
(
siteIdentity
)
;
if
(
mSecurityImageLevel
!
=
imageLevel
)
{
mSecurityImageLevel
=
imageLevel
;
mSiteSecurity
.
setImageLevel
(
mSecurityImageLevel
)
;
updatePageActions
(
)
;
}
}
private
void
updateProgress
(
NonNull
Tab
tab
)
{
final
boolean
shouldShowThrobber
=
tab
.
getState
(
)
=
=
Tab
.
STATE_LOADING
;
updateUiMode
(
shouldShowThrobber
?
UIMode
.
PROGRESS
:
UIMode
.
DISPLAY
)
;
if
(
Tab
.
STATE_SUCCESS
=
=
tab
.
getState
(
)
&
&
mTrackingProtectionEnabled
)
{
mActivity
.
showTrackingProtectionPromptIfApplicable
(
)
;
}
}
private
void
updateUiMode
(
UIMode
uiMode
)
{
if
(
mUiMode
=
=
uiMode
)
{
return
;
}
mUiMode
=
uiMode
;
updatePageActions
(
)
;
}
private
void
updatePageActions
(
)
{
final
boolean
isShowingProgress
=
(
mUiMode
=
=
UIMode
.
PROGRESS
)
;
mStop
.
setVisibility
(
isShowingProgress
?
View
.
VISIBLE
:
View
.
GONE
)
;
mPageActionLayout
.
setVisibility
(
!
isShowingProgress
?
View
.
VISIBLE
:
View
.
GONE
)
;
mTitle
.
setPadding
(
0
0
(
!
isShowingProgress
?
mTitlePadding
:
0
)
0
)
;
}
List
<
View
>
getFocusOrder
(
)
{
return
Arrays
.
asList
(
mSiteSecurity
mPageActionLayout
mStop
)
;
}
void
setOnStopListener
(
OnStopListener
listener
)
{
mStopListener
=
listener
;
}
void
setOnTitleChangeListener
(
OnTitleChangeListener
listener
)
{
mTitleChangeListener
=
listener
;
}
void
updateSiteIdentityAnchor
(
View
view
)
{
mSiteIdentityPopup
.
setAnchor
(
view
)
;
}
private
boolean
isLayoutRtl
(
)
{
return
ViewCompat
.
getLayoutDirection
(
this
)
=
=
ViewCompat
.
LAYOUT_DIRECTION_RTL
;
}
void
prepareForwardAnimation
(
PropertyAnimator
anim
ForwardButtonAnimation
animation
int
width
)
{
if
(
animation
=
=
ForwardButtonAnimation
.
HIDE
)
{
anim
.
attach
(
mTitle
PropertyAnimator
.
Property
.
TRANSLATION_X
isLayoutRtl
(
)
?
width
:
0
)
;
anim
.
attach
(
mSiteSecurity
PropertyAnimator
.
Property
.
TRANSLATION_X
isLayoutRtl
(
)
?
width
:
0
)
;
ViewHelper
.
setTranslationX
(
mTitle
width
)
;
ViewHelper
.
setTranslationX
(
mSiteSecurity
width
)
;
}
else
{
anim
.
attach
(
mTitle
PropertyAnimator
.
Property
.
TRANSLATION_X
isLayoutRtl
(
)
?
0
:
width
)
;
anim
.
attach
(
mSiteSecurity
PropertyAnimator
.
Property
.
TRANSLATION_X
isLayoutRtl
(
)
?
0
:
width
)
;
}
}
void
finishForwardAnimation
(
)
{
ViewHelper
.
setTranslationX
(
mTitle
0
)
;
ViewHelper
.
setTranslationX
(
mSiteSecurity
0
)
;
}
void
prepareStartEditingAnimation
(
)
{
ViewHelper
.
setAlpha
(
mPageActionLayout
0
)
;
ViewHelper
.
setAlpha
(
mStop
0
)
;
}
void
prepareStopEditingAnimation
(
PropertyAnimator
anim
)
{
anim
.
attach
(
mPageActionLayout
PropertyAnimator
.
Property
.
ALPHA
1
)
;
anim
.
attach
(
mStop
PropertyAnimator
.
Property
.
ALPHA
1
)
;
}
boolean
dismissSiteIdentityPopup
(
)
{
if
(
mSiteIdentityPopup
!
=
null
&
&
mSiteIdentityPopup
.
isShowing
(
)
)
{
mSiteIdentityPopup
.
dismiss
(
)
;
return
true
;
}
return
false
;
}
void
destroy
(
)
{
mSiteIdentityPopup
.
destroy
(
)
;
}
}
