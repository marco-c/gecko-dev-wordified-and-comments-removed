package
org
.
mozilla
.
gecko
.
favicons
.
decoders
;
import
android
.
graphics
.
Bitmap
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
gecko
.
favicons
.
Favicons
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
public
class
LoadFaviconResult
{
private
static
final
String
LOGTAG
=
"
LoadFaviconResult
"
;
byte
[
]
faviconBytes
;
int
offset
;
int
length
;
boolean
isICO
;
Iterator
<
Bitmap
>
bitmapsDecoded
;
public
Iterator
<
Bitmap
>
getBitmaps
(
)
{
return
bitmapsDecoded
;
}
public
byte
[
]
getBytesForDatabaseStorage
(
)
{
if
(
offset
!
=
0
|
|
length
!
=
faviconBytes
.
length
)
{
final
byte
[
]
normalised
=
new
byte
[
length
]
;
System
.
arraycopy
(
faviconBytes
offset
normalised
0
length
)
;
offset
=
0
;
faviconBytes
=
normalised
;
}
if
(
isICO
)
{
return
faviconBytes
;
}
final
Bitmap
favicon
=
(
(
FaviconDecoder
.
SingleBitmapIterator
)
bitmapsDecoded
)
.
peek
(
)
;
final
ByteArrayOutputStream
stream
=
new
ByteArrayOutputStream
(
)
;
try
{
if
(
favicon
.
compress
(
Bitmap
.
CompressFormat
.
PNG
100
stream
)
)
{
return
stream
.
toByteArray
(
)
;
}
}
catch
(
OutOfMemoryError
e
)
{
Log
.
w
(
LOGTAG
"
Out
of
memory
re
-
compressing
favicon
.
"
)
;
}
Log
.
w
(
LOGTAG
"
Favicon
re
-
compression
failed
.
"
)
;
return
null
;
}
public
Bitmap
getBestBitmap
(
int
targetWidthAndHeight
)
{
final
SparseArray
<
Bitmap
>
iconMap
=
new
SparseArray
<
>
(
)
;
final
List
<
Integer
>
sizes
=
new
ArrayList
<
>
(
)
;
while
(
bitmapsDecoded
.
hasNext
(
)
)
{
final
Bitmap
b
=
bitmapsDecoded
.
next
(
)
;
if
(
b
!
=
null
)
{
iconMap
.
put
(
b
.
getWidth
(
)
b
)
;
sizes
.
add
(
b
.
getWidth
(
)
)
;
}
}
int
bestSize
=
Favicons
.
selectBestSizeFromList
(
sizes
targetWidthAndHeight
)
;
if
(
bestSize
=
=
-
1
)
{
return
null
;
}
return
iconMap
.
get
(
bestSize
)
;
}
}
