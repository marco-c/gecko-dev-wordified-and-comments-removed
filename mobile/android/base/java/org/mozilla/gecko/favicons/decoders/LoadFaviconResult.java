package
org
.
mozilla
.
gecko
.
favicons
.
decoders
;
import
android
.
graphics
.
Bitmap
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
public
class
LoadFaviconResult
{
private
static
final
String
LOGTAG
=
"
LoadFaviconResult
"
;
byte
[
]
faviconBytes
;
int
offset
;
int
length
;
boolean
isICO
;
Iterator
<
Bitmap
>
bitmapsDecoded
;
public
Iterator
<
Bitmap
>
getBitmaps
(
)
{
return
bitmapsDecoded
;
}
public
byte
[
]
getBytesForDatabaseStorage
(
)
{
if
(
offset
!
=
0
|
|
length
!
=
faviconBytes
.
length
)
{
final
byte
[
]
normalised
=
new
byte
[
length
]
;
System
.
arraycopy
(
faviconBytes
offset
normalised
0
length
)
;
offset
=
0
;
faviconBytes
=
normalised
;
}
if
(
isICO
)
{
return
faviconBytes
;
}
final
Bitmap
favicon
=
(
(
FaviconDecoder
.
SingleBitmapIterator
)
bitmapsDecoded
)
.
peek
(
)
;
final
ByteArrayOutputStream
stream
=
new
ByteArrayOutputStream
(
)
;
try
{
if
(
favicon
.
compress
(
Bitmap
.
CompressFormat
.
PNG
100
stream
)
)
{
return
stream
.
toByteArray
(
)
;
}
}
catch
(
OutOfMemoryError
e
)
{
Log
.
w
(
LOGTAG
"
Out
of
memory
re
-
compressing
favicon
.
"
)
;
}
Log
.
w
(
LOGTAG
"
Favicon
re
-
compression
failed
.
"
)
;
return
null
;
}
public
Bitmap
getBestBitmap
(
int
targetWidthAndHeight
)
{
final
SparseArray
<
Bitmap
>
iconMap
=
new
SparseArray
<
>
(
)
;
final
List
<
Integer
>
sizes
=
new
ArrayList
<
>
(
)
;
while
(
bitmapsDecoded
.
hasNext
(
)
)
{
final
Bitmap
b
=
bitmapsDecoded
.
next
(
)
;
if
(
b
!
=
null
)
{
iconMap
.
put
(
b
.
getWidth
(
)
b
)
;
sizes
.
add
(
b
.
getWidth
(
)
)
;
}
}
int
bestSize
=
selectBestSizeFromList
(
sizes
targetWidthAndHeight
)
;
if
(
bestSize
=
=
-
1
)
{
return
null
;
}
return
iconMap
.
get
(
bestSize
)
;
}
public
static
int
selectBestSizeFromList
(
final
List
<
Integer
>
sizes
final
int
preferredSize
)
{
if
(
sizes
.
isEmpty
(
)
)
{
return
-
1
;
}
Collections
.
sort
(
sizes
)
;
for
(
int
size
:
sizes
)
{
if
(
size
>
=
preferredSize
)
{
return
size
;
}
}
return
sizes
.
get
(
sizes
.
size
(
)
-
1
)
;
}
}
