package
org
.
mozilla
.
gecko
.
favicons
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
database
.
Cursor
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
BitmapFactory
;
import
android
.
net
.
Uri
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoProfile
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
distribution
.
PartnerBookmarksProviderProxy
;
import
org
.
mozilla
.
gecko
.
favicons
.
decoders
.
FaviconDecoder
;
import
org
.
mozilla
.
gecko
.
favicons
.
decoders
.
LoadFaviconResult
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoJarReader
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ProxySelector
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
concurrent
.
RejectedExecutionException
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicInteger
;
import
static
org
.
mozilla
.
gecko
.
util
.
IOUtils
.
ConsumedInputStream
;
public
class
LoadFaviconTask
{
private
static
final
String
LOGTAG
=
"
LoadFaviconTask
"
;
private
static
final
HashMap
<
String
LoadFaviconTask
>
loadsInFlight
=
new
HashMap
<
>
(
)
;
public
static
final
int
FLAG_PERSIST
=
1
;
public
static
final
int
FLAG_BYPASS_CACHE_WHEN_DOWNLOADING_ICONS
=
2
;
public
static
final
int
FLAG_NO_DOWNLOAD_FROM_GUESSED_DEFAULT_URL
=
4
;
private
static
final
int
MAX_REDIRECTS_TO_FOLLOW
=
5
;
public
static
final
int
DEFAULT_FAVICON_BUFFER_SIZE
=
25000
;
private
static
final
AtomicInteger
nextFaviconLoadId
=
new
AtomicInteger
(
0
)
;
private
final
Context
context
;
private
final
int
id
;
private
final
String
pageUrl
;
private
String
faviconURL
;
private
final
OnFaviconLoadedListener
listener
;
private
final
int
flags
;
private
final
BrowserDB
db
;
private
final
boolean
onlyFromLocal
;
volatile
boolean
mCancelled
;
protected
int
targetWidthAndHeight
;
private
LinkedList
<
LoadFaviconTask
>
chainees
;
private
boolean
isChaining
;
private
static
class
Response
{
public
final
int
contentLength
;
public
final
InputStream
stream
;
private
Response
(
InputStream
stream
int
contentLength
)
{
this
.
stream
=
stream
;
this
.
contentLength
=
contentLength
;
}
}
public
LoadFaviconTask
(
Context
context
String
pageURL
String
faviconURL
int
flags
OnFaviconLoadedListener
listener
int
targetWidth
boolean
onlyFromLocal
)
{
id
=
nextFaviconLoadId
.
incrementAndGet
(
)
;
this
.
context
=
context
;
db
=
GeckoProfile
.
get
(
context
)
.
getDB
(
)
;
this
.
pageUrl
=
pageURL
;
this
.
faviconURL
=
faviconURL
;
this
.
listener
=
listener
;
this
.
flags
=
flags
;
this
.
targetWidthAndHeight
=
targetWidth
;
this
.
onlyFromLocal
=
onlyFromLocal
;
}
private
LoadFaviconResult
loadFaviconFromDb
(
final
BrowserDB
db
)
{
ContentResolver
resolver
=
context
.
getContentResolver
(
)
;
return
db
.
getFaviconForUrl
(
resolver
faviconURL
)
;
}
private
void
saveFaviconToDb
(
final
BrowserDB
db
final
byte
[
]
encodedFavicon
)
{
if
(
encodedFavicon
=
=
null
)
{
return
;
}
if
(
(
flags
&
FLAG_PERSIST
)
=
=
0
)
{
return
;
}
ContentResolver
resolver
=
context
.
getContentResolver
(
)
;
db
.
updateFaviconForUrl
(
resolver
pageUrl
encodedFavicon
faviconURL
)
;
}
private
Response
tryDownload
(
URI
faviconURI
)
throws
URISyntaxException
IOException
{
HashSet
<
String
>
visitedLinkSet
=
new
HashSet
<
>
(
)
;
visitedLinkSet
.
add
(
faviconURI
.
toString
(
)
)
;
return
tryDownloadRecurse
(
faviconURI
visitedLinkSet
)
;
}
private
Response
tryDownloadRecurse
(
URI
faviconURI
HashSet
<
String
>
visited
)
throws
URISyntaxException
IOException
{
if
(
visited
.
size
(
)
=
=
MAX_REDIRECTS_TO_FOLLOW
)
{
return
null
;
}
HttpURLConnection
connection
=
(
HttpURLConnection
)
ProxySelector
.
openConnectionWithProxy
(
faviconURI
)
;
connection
.
setRequestProperty
(
"
User
-
Agent
"
GeckoAppShell
.
getGeckoInterface
(
)
.
getDefaultUAString
(
)
)
;
connection
.
connect
(
)
;
int
status
=
connection
.
getResponseCode
(
)
;
if
(
status
>
=
300
&
&
status
<
400
)
{
final
String
newURI
=
connection
.
getHeaderField
(
"
Location
"
)
;
try
{
if
(
newURI
=
=
null
|
|
newURI
.
equals
(
faviconURI
.
toString
(
)
)
)
{
return
null
;
}
if
(
visited
.
contains
(
newURI
)
)
{
return
null
;
}
visited
.
add
(
newURI
)
;
}
finally
{
connection
.
disconnect
(
)
;
}
return
tryDownloadRecurse
(
new
URI
(
newURI
)
visited
)
;
}
if
(
status
>
=
400
)
{
connection
.
disconnect
(
)
;
return
null
;
}
return
new
Response
(
connection
.
getInputStream
(
)
connection
.
getHeaderFieldInt
(
"
Content
-
Length
"
-
1
)
)
;
}
private
Bitmap
fetchJARFavicon
(
String
uri
)
{
if
(
uri
=
=
null
)
{
return
null
;
}
if
(
uri
.
startsWith
(
"
jar
:
jar
:
"
)
)
{
Log
.
d
(
LOGTAG
"
Fetching
favicon
from
JAR
.
"
)
;
try
{
return
GeckoJarReader
.
getBitmap
(
context
context
.
getResources
(
)
uri
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Error
fetching
favicon
from
JAR
.
"
e
)
;
return
null
;
}
}
return
null
;
}
private
Bitmap
fetchContentProviderFavicon
(
String
uri
int
targetWidthAndHeight
)
{
if
(
TextUtils
.
isEmpty
(
uri
)
)
{
return
null
;
}
if
(
!
uri
.
startsWith
(
"
content
:
/
/
"
)
)
{
return
null
;
}
Cursor
cursor
=
context
.
getContentResolver
(
)
.
query
(
Uri
.
parse
(
uri
)
new
String
[
]
{
PartnerBookmarksProviderProxy
.
PartnerContract
.
TOUCHICON
PartnerBookmarksProviderProxy
.
PartnerContract
.
FAVICON
}
null
null
null
)
;
if
(
cursor
=
=
null
)
{
return
null
;
}
try
{
if
(
!
cursor
.
moveToFirst
(
)
)
{
return
null
;
}
Bitmap
icon
=
decodeFromCursor
(
cursor
PartnerBookmarksProviderProxy
.
PartnerContract
.
TOUCHICON
targetWidthAndHeight
)
;
if
(
icon
!
=
null
)
{
return
icon
;
}
icon
=
decodeFromCursor
(
cursor
PartnerBookmarksProviderProxy
.
PartnerContract
.
FAVICON
targetWidthAndHeight
)
;
if
(
icon
!
=
null
)
{
return
icon
;
}
}
finally
{
cursor
.
close
(
)
;
}
return
null
;
}
private
Bitmap
decodeFromCursor
(
Cursor
cursor
String
column
int
targetWidthAndHeight
)
{
final
int
index
=
cursor
.
getColumnIndex
(
column
)
;
if
(
index
=
=
-
1
)
{
return
null
;
}
if
(
cursor
.
isNull
(
index
)
)
{
return
null
;
}
final
byte
[
]
data
=
cursor
.
getBlob
(
index
)
;
LoadFaviconResult
result
=
FaviconDecoder
.
decodeFavicon
(
data
0
data
.
length
)
;
if
(
result
=
=
null
)
{
return
null
;
}
return
result
.
getBestBitmap
(
targetWidthAndHeight
)
;
}
private
LoadFaviconResult
downloadFavicon
(
URI
targetFaviconURI
)
{
if
(
targetFaviconURI
=
=
null
)
{
return
null
;
}
String
scheme
=
targetFaviconURI
.
getScheme
(
)
;
if
(
!
"
http
"
.
equals
(
scheme
)
&
&
!
"
https
"
.
equals
(
scheme
)
)
{
return
null
;
}
LoadFaviconResult
result
=
null
;
try
{
result
=
downloadAndDecodeImage
(
targetFaviconURI
)
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Error
reading
favicon
"
e
)
;
}
catch
(
OutOfMemoryError
e
)
{
Log
.
e
(
LOGTAG
"
Insufficient
memory
to
process
favicon
"
)
;
}
return
result
;
}
private
LoadFaviconResult
downloadAndDecodeImage
(
URI
targetFaviconURL
)
throws
IOException
URISyntaxException
{
Response
response
=
tryDownload
(
targetFaviconURL
)
;
if
(
response
=
=
null
)
{
return
null
;
}
try
{
return
decodeImageFromResponse
(
response
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
response
.
stream
)
;
}
}
private
LoadFaviconResult
decodeImageFromResponse
(
Response
response
)
throws
IOException
{
int
bufferSize
;
if
(
response
.
contentLength
>
0
)
{
bufferSize
=
response
.
contentLength
+
1
;
}
else
{
bufferSize
=
DEFAULT_FAVICON_BUFFER_SIZE
;
}
ConsumedInputStream
result
=
IOUtils
.
readFully
(
response
.
stream
bufferSize
)
;
if
(
result
=
=
null
)
{
return
null
;
}
return
FaviconDecoder
.
decodeFavicon
(
result
.
getData
(
)
0
result
.
consumedLength
)
;
}
public
final
void
execute
(
)
{
try
{
Favicons
.
longRunningExecutor
.
execute
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
Bitmap
result
=
doInBackground
(
db
)
;
ThreadUtils
.
getUiHandler
(
)
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mCancelled
)
{
onCancelled
(
)
;
}
else
{
onPostExecute
(
result
)
;
}
}
}
)
;
}
}
)
;
}
catch
(
RejectedExecutionException
e
)
{
onCancelled
(
)
;
}
}
public
final
boolean
cancel
(
)
{
mCancelled
=
true
;
return
true
;
}
public
final
boolean
isCancelled
(
)
{
return
mCancelled
;
}
Bitmap
doInBackground
(
final
BrowserDB
db
)
{
if
(
isCancelled
(
)
)
{
return
null
;
}
final
boolean
isEmpty
=
TextUtils
.
isEmpty
(
faviconURL
)
;
if
(
!
isEmpty
)
{
LoadFaviconResult
uriBitmaps
=
FaviconDecoder
.
decodeDataURI
(
faviconURL
)
;
if
(
uriBitmaps
!
=
null
)
{
return
pushToCacheAndGetResult
(
uriBitmaps
)
;
}
}
String
storedFaviconUrl
;
boolean
isUsingDefaultURL
=
false
;
if
(
isEmpty
)
{
final
ContentResolver
cr
=
context
.
getContentResolver
(
)
;
storedFaviconUrl
=
Favicons
.
getFaviconURLForPageURLFromCache
(
pageUrl
)
;
if
(
storedFaviconUrl
=
=
null
)
{
storedFaviconUrl
=
Favicons
.
getFaviconURLForPageURL
(
db
cr
pageUrl
)
;
if
(
storedFaviconUrl
!
=
null
)
{
Favicons
.
putFaviconURLForPageURLInCache
(
pageUrl
storedFaviconUrl
)
;
}
}
if
(
storedFaviconUrl
!
=
null
)
{
faviconURL
=
storedFaviconUrl
;
}
else
{
faviconURL
=
Favicons
.
guessDefaultFaviconURL
(
pageUrl
)
;
if
(
TextUtils
.
isEmpty
(
faviconURL
)
)
{
return
null
;
}
isUsingDefaultURL
=
true
;
}
}
if
(
Favicons
.
isFailedFavicon
(
faviconURL
)
)
{
return
null
;
}
if
(
isCancelled
(
)
)
{
return
null
;
}
Bitmap
image
;
synchronized
(
loadsInFlight
)
{
LoadFaviconTask
existingTask
=
loadsInFlight
.
get
(
faviconURL
)
;
if
(
existingTask
!
=
null
&
&
!
existingTask
.
isCancelled
(
)
)
{
existingTask
.
chainTasks
(
this
)
;
isChaining
=
true
;
return
null
;
}
loadsInFlight
.
put
(
faviconURL
this
)
;
}
if
(
isCancelled
(
)
)
{
return
null
;
}
LoadFaviconResult
loadedBitmaps
=
null
;
if
(
(
flags
&
FLAG_BYPASS_CACHE_WHEN_DOWNLOADING_ICONS
)
=
=
0
)
{
loadedBitmaps
=
loadFaviconFromDb
(
db
)
;
if
(
loadedBitmaps
!
=
null
)
{
return
pushToCacheAndGetResult
(
loadedBitmaps
)
;
}
}
if
(
onlyFromLocal
|
|
isCancelled
(
)
)
{
return
null
;
}
image
=
fetchJARFavicon
(
faviconURL
)
;
if
(
imageIsValid
(
image
)
)
{
Favicons
.
putFaviconInMemCache
(
faviconURL
image
)
;
return
image
;
}
image
=
fetchContentProviderFavicon
(
faviconURL
targetWidthAndHeight
)
;
if
(
imageIsValid
(
image
)
)
{
Favicons
.
putFaviconInMemCache
(
faviconURL
image
)
;
return
image
;
}
try
{
loadedBitmaps
=
downloadFavicon
(
new
URI
(
faviconURL
)
)
;
}
catch
(
URISyntaxException
e
)
{
Log
.
e
(
LOGTAG
"
The
provided
favicon
URL
is
not
valid
"
)
;
return
null
;
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Couldn
'
t
download
favicon
.
"
e
)
;
}
if
(
loadedBitmaps
!
=
null
)
{
if
(
(
flags
&
FLAG_BYPASS_CACHE_WHEN_DOWNLOADING_ICONS
)
=
=
0
)
{
saveFaviconToDb
(
db
loadedBitmaps
.
getBytesForDatabaseStorage
(
)
)
;
return
pushToCacheAndGetResult
(
loadedBitmaps
)
;
}
else
{
return
loadedBitmaps
.
getBestBitmap
(
targetWidthAndHeight
)
;
}
}
if
(
(
FLAG_NO_DOWNLOAD_FROM_GUESSED_DEFAULT_URL
&
flags
)
=
=
FLAG_NO_DOWNLOAD_FROM_GUESSED_DEFAULT_URL
)
{
return
null
;
}
if
(
isUsingDefaultURL
)
{
Favicons
.
putFaviconInFailedCache
(
faviconURL
)
;
return
null
;
}
if
(
isCancelled
(
)
)
{
return
null
;
}
final
String
guessed
=
Favicons
.
guessDefaultFaviconURL
(
pageUrl
)
;
if
(
guessed
=
=
null
)
{
Favicons
.
putFaviconInFailedCache
(
faviconURL
)
;
return
null
;
}
image
=
fetchJARFavicon
(
guessed
)
;
if
(
imageIsValid
(
image
)
)
{
Favicons
.
putFaviconInMemCache
(
faviconURL
image
)
;
return
image
;
}
try
{
loadedBitmaps
=
downloadFavicon
(
new
URI
(
guessed
)
)
;
}
catch
(
Exception
e
)
{
return
null
;
}
if
(
loadedBitmaps
!
=
null
)
{
saveFaviconToDb
(
db
loadedBitmaps
.
getBytesForDatabaseStorage
(
)
)
;
return
pushToCacheAndGetResult
(
loadedBitmaps
)
;
}
return
null
;
}
private
Bitmap
pushToCacheAndGetResult
(
LoadFaviconResult
loadedBitmaps
)
{
Favicons
.
putFaviconsInMemCache
(
faviconURL
loadedBitmaps
.
getBitmaps
(
)
)
;
return
Favicons
.
getSizedFaviconFromCache
(
faviconURL
targetWidthAndHeight
)
;
}
private
static
boolean
imageIsValid
(
final
Bitmap
image
)
{
return
image
!
=
null
&
&
image
.
getWidth
(
)
>
0
&
&
image
.
getHeight
(
)
>
0
;
}
void
onPostExecute
(
Bitmap
image
)
{
if
(
isChaining
)
{
return
;
}
processResult
(
image
)
;
synchronized
(
loadsInFlight
)
{
loadsInFlight
.
remove
(
faviconURL
)
;
}
if
(
chainees
!
=
null
)
{
for
(
LoadFaviconTask
t
:
chainees
)
{
t
.
processResult
(
image
)
;
}
}
}
private
void
processResult
(
Bitmap
image
)
{
Favicons
.
removeLoadTask
(
id
)
;
final
Bitmap
scaled
;
if
(
targetWidthAndHeight
!
=
-
1
&
&
image
!
=
null
&
&
image
.
getWidth
(
)
!
=
targetWidthAndHeight
)
{
if
(
(
flags
&
FLAG_BYPASS_CACHE_WHEN_DOWNLOADING_ICONS
)
!
=
0
)
{
scaled
=
Bitmap
.
createScaledBitmap
(
image
targetWidthAndHeight
targetWidthAndHeight
true
)
;
}
else
{
scaled
=
Favicons
.
getSizedFaviconFromCache
(
faviconURL
targetWidthAndHeight
)
;
}
}
else
{
scaled
=
image
;
}
Favicons
.
dispatchResult
(
pageUrl
faviconURL
scaled
listener
)
;
}
void
onCancelled
(
)
{
Favicons
.
removeLoadTask
(
id
)
;
synchronized
(
loadsInFlight
)
{
final
LoadFaviconTask
primary
=
loadsInFlight
.
get
(
faviconURL
)
;
if
(
primary
=
=
this
)
{
loadsInFlight
.
remove
(
faviconURL
)
;
return
;
}
if
(
primary
=
=
null
)
{
return
;
}
if
(
primary
.
chainees
!
=
null
)
{
primary
.
chainees
.
remove
(
this
)
;
}
}
}
private
void
chainTasks
(
LoadFaviconTask
aChainee
)
{
if
(
chainees
=
=
null
)
{
chainees
=
new
LinkedList
<
>
(
)
;
}
chainees
.
add
(
aChainee
)
;
}
int
getId
(
)
{
return
id
;
}
}
