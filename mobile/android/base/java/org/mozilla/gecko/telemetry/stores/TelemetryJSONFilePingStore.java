package
org
.
mozilla
.
gecko
.
telemetry
.
stores
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
NonObjectJSONException
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryPing
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FilenameFilter
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
channels
.
FileLock
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Set
;
import
java
.
util
.
SortedSet
;
import
java
.
util
.
TreeSet
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
class
TelemetryJSONFilePingStore
implements
TelemetryPingStore
{
private
static
final
String
LOGTAG
=
StringUtils
.
safeSubstring
(
"
Gecko
"
+
TelemetryJSONFilePingStore
.
class
.
getSimpleName
(
)
0
23
)
;
VisibleForTesting
static
final
int
MAX_PING_COUNT
=
40
;
private
static
final
String
FILENAME
=
"
ping
-
%
s
.
json
"
;
private
static
final
Pattern
FILENAME_PATTERN
=
Pattern
.
compile
(
"
ping
-
(
[
0
-
9
]
+
)
\
\
.
json
"
)
;
VisibleForTesting
static
final
String
KEY_PAYLOAD
=
"
p
"
;
VisibleForTesting
static
final
String
KEY_URL_PATH
=
"
u
"
;
private
final
File
storeDir
;
public
TelemetryJSONFilePingStore
(
final
File
storeDir
)
{
this
.
storeDir
=
storeDir
;
this
.
storeDir
.
mkdirs
(
)
;
}
VisibleForTesting
File
getPingFile
(
final
long
id
)
{
final
String
filename
=
String
.
format
(
Locale
.
US
FILENAME
id
)
;
return
new
File
(
storeDir
filename
)
;
}
VisibleForTesting
static
int
getIDFromFilename
(
final
String
filename
)
{
final
Matcher
matcher
=
FILENAME_PATTERN
.
matcher
(
filename
)
;
if
(
!
matcher
.
matches
(
)
)
{
return
-
1
;
}
return
Integer
.
parseInt
(
matcher
.
group
(
1
)
)
;
}
Override
public
void
storePing
(
final
TelemetryPing
ping
)
throws
IOException
{
final
String
output
;
try
{
output
=
new
JSONObject
(
)
.
put
(
KEY_PAYLOAD
ping
.
getPayload
(
)
)
.
put
(
KEY_URL_PATH
ping
.
getURLPath
(
)
)
.
toString
(
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Unable
to
create
JSON
to
store
to
disk
"
)
;
}
final
FileOutputStream
outputStream
=
new
FileOutputStream
(
getPingFile
(
ping
.
getUniqueID
(
)
)
false
)
;
blockForLockAndWriteFileAndCloseStream
(
outputStream
output
)
;
}
Override
public
void
maybePrunePings
(
)
{
final
File
[
]
files
=
storeDir
.
listFiles
(
new
PingFileFilter
(
)
)
;
if
(
files
.
length
<
MAX_PING_COUNT
)
{
return
;
}
final
SortedSet
<
Integer
>
ids
=
getIDsFromFileList
(
files
)
;
removeFilesWithSmallestIDs
(
ids
files
.
length
-
MAX_PING_COUNT
)
;
}
private
static
SortedSet
<
Integer
>
getIDsFromFileList
(
final
File
[
]
files
)
{
final
SortedSet
<
Integer
>
out
=
new
TreeSet
<
>
(
)
;
for
(
final
File
file
:
files
)
{
final
int
id
=
getIDFromFilename
(
file
.
getName
(
)
)
;
if
(
id
>
=
0
)
{
out
.
add
(
id
)
;
}
}
return
out
;
}
private
void
removeFilesWithSmallestIDs
(
final
SortedSet
<
Integer
>
ids
final
int
numFilesToRemove
)
{
final
Iterator
<
Integer
>
it
=
ids
.
iterator
(
)
;
int
i
=
0
;
while
(
i
<
numFilesToRemove
)
{
i
+
=
1
;
final
Integer
id
=
it
.
next
(
)
;
getPingFile
(
id
)
.
delete
(
)
;
}
}
Override
public
ArrayList
<
TelemetryPing
>
getAllPings
(
)
{
final
File
[
]
files
=
storeDir
.
listFiles
(
new
PingFileFilter
(
)
)
;
final
ArrayList
<
TelemetryPing
>
out
=
new
ArrayList
<
>
(
files
.
length
)
;
for
(
final
File
file
:
files
)
{
final
FileInputStream
inputStream
;
try
{
inputStream
=
new
FileInputStream
(
file
)
;
}
catch
(
final
FileNotFoundException
e
)
{
throw
new
IllegalStateException
(
"
Expected
file
to
exist
"
)
;
}
final
JSONObject
obj
;
try
{
obj
=
lockAndReadFileAndCloseStream
(
inputStream
(
int
)
file
.
length
(
)
)
;
}
catch
(
final
IOException
|
JSONException
e
)
{
Log
.
w
(
LOGTAG
"
Error
when
reading
file
:
"
+
file
.
getName
(
)
+
"
Likely
corrupted
.
Ignoring
"
)
;
continue
;
}
if
(
obj
=
=
null
)
{
Log
.
d
(
LOGTAG
"
Could
not
read
given
file
:
"
+
file
.
getName
(
)
+
"
File
is
locked
.
Ignoring
"
)
;
continue
;
}
try
{
final
String
url
=
obj
.
getString
(
KEY_URL_PATH
)
;
final
ExtendedJSONObject
payload
=
new
ExtendedJSONObject
(
obj
.
getString
(
KEY_PAYLOAD
)
)
;
final
int
id
=
getIDFromFilename
(
file
.
getName
(
)
)
;
if
(
id
<
0
)
{
throw
new
IllegalStateException
(
"
These
files
are
already
filtered
-
did
not
expect
to
see
"
+
"
an
invalid
ID
in
these
files
"
)
;
}
out
.
add
(
new
TelemetryPing
(
url
payload
id
)
)
;
}
catch
(
final
IOException
|
JSONException
|
NonObjectJSONException
e
)
{
Log
.
w
(
LOGTAG
"
Bad
json
in
ping
.
Ignoring
.
"
)
;
continue
;
}
}
return
out
;
}
Override
public
void
onUploadAttemptComplete
(
final
Set
<
Integer
>
successfulRemoveIDs
)
{
if
(
successfulRemoveIDs
.
isEmpty
(
)
)
{
return
;
}
final
File
[
]
files
=
storeDir
.
listFiles
(
new
PingFileFilter
(
successfulRemoveIDs
)
)
;
for
(
final
File
file
:
files
)
{
file
.
delete
(
)
;
}
}
private
static
void
blockForLockAndWriteFileAndCloseStream
(
final
FileOutputStream
outputStream
final
String
str
)
throws
IOException
{
try
{
final
FileLock
lock
=
outputStream
.
getChannel
(
)
.
lock
(
0
Long
.
MAX_VALUE
false
)
;
if
(
lock
!
=
null
)
{
FileUtils
.
writeStringToOutputStreamAndCloseStream
(
outputStream
str
)
;
}
}
finally
{
outputStream
.
close
(
)
;
}
}
private
static
JSONObject
lockAndReadFileAndCloseStream
(
final
FileInputStream
inputStream
final
int
fileSize
)
throws
IOException
JSONException
{
try
{
final
FileLock
lock
=
inputStream
.
getChannel
(
)
.
tryLock
(
0
Long
.
MAX_VALUE
true
)
;
if
(
lock
=
=
null
)
{
return
null
;
}
return
new
JSONObject
(
FileUtils
.
readStringFromInputStreamAndCloseStream
(
inputStream
fileSize
)
)
;
}
finally
{
inputStream
.
close
(
)
;
}
}
private
static
class
PingFileFilter
implements
FilenameFilter
{
private
final
Set
<
Integer
>
idsToFilter
;
public
PingFileFilter
(
)
{
this
(
null
)
;
}
public
PingFileFilter
(
final
Set
<
Integer
>
idsToFilter
)
{
this
.
idsToFilter
=
idsToFilter
;
}
Override
public
boolean
accept
(
final
File
dir
final
String
filename
)
{
if
(
idsToFilter
=
=
null
)
{
return
FILENAME_PATTERN
.
matcher
(
filename
)
.
matches
(
)
;
}
return
idsToFilter
.
contains
(
getIDFromFilename
(
filename
)
)
;
}
}
public
static
final
Parcelable
.
Creator
<
TelemetryJSONFilePingStore
>
CREATOR
=
new
Parcelable
.
Creator
<
TelemetryJSONFilePingStore
>
(
)
{
Override
public
TelemetryJSONFilePingStore
createFromParcel
(
final
Parcel
source
)
{
final
String
storeDirPath
=
source
.
readString
(
)
;
return
new
TelemetryJSONFilePingStore
(
new
File
(
storeDirPath
)
)
;
}
Override
public
TelemetryJSONFilePingStore
[
]
newArray
(
final
int
size
)
{
return
new
TelemetryJSONFilePingStore
[
size
]
;
}
}
;
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
final
Parcel
dest
final
int
flags
)
{
dest
.
writeString
(
storeDir
.
getAbsolutePath
(
)
)
;
}
}
