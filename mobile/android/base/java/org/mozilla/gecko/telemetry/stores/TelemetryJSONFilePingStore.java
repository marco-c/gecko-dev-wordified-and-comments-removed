package
org
.
mozilla
.
gecko
.
telemetry
.
stores
;
import
android
.
os
.
Parcel
;
import
android
.
os
.
Parcelable
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
NonObjectJSONException
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryLocalPing
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryOutgoingPing
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryPing
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
.
FileLastModifiedComparator
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
.
FilenameRegexFilter
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
.
FilenameWhitelistFilter
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
UUIDUtil
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FilenameFilter
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
channels
.
FileLock
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Set
;
public
class
TelemetryJSONFilePingStore
extends
TelemetryPingStore
{
private
static
final
String
LOGTAG
=
StringUtils
.
safeSubstring
(
"
Gecko
"
+
TelemetryJSONFilePingStore
.
class
.
getSimpleName
(
)
0
23
)
;
VisibleForTesting
static
final
int
MAX_PING_COUNT
=
40
;
VisibleForTesting
static
final
String
KEY_PAYLOAD
=
"
p
"
;
VisibleForTesting
static
final
String
KEY_URL_PATH
=
"
u
"
;
private
final
File
storeDir
;
private
final
FilenameFilter
uuidFilenameFilter
;
private
final
FileLastModifiedComparator
fileLastModifiedComparator
=
new
FileLastModifiedComparator
(
)
;
WorkerThread
public
TelemetryJSONFilePingStore
(
final
File
storeDir
final
String
profileName
)
{
super
(
profileName
)
;
if
(
storeDir
.
exists
(
)
&
&
!
storeDir
.
isDirectory
(
)
)
{
throw
new
IllegalStateException
(
"
Store
dir
unexpectedly
exists
&
is
not
a
directory
-
cannot
continue
"
)
;
}
this
.
storeDir
=
storeDir
;
this
.
storeDir
.
mkdirs
(
)
;
uuidFilenameFilter
=
new
FilenameRegexFilter
(
UUIDUtil
.
UUID_PATTERN
)
;
if
(
!
this
.
storeDir
.
canRead
(
)
|
|
!
this
.
storeDir
.
canWrite
(
)
|
|
!
this
.
storeDir
.
canExecute
(
)
)
{
throw
new
IllegalStateException
(
"
Cannot
read
write
or
execute
store
dir
:
"
+
this
.
storeDir
.
canRead
(
)
+
"
"
+
this
.
storeDir
.
canWrite
(
)
+
"
"
+
this
.
storeDir
.
canExecute
(
)
)
;
}
}
VisibleForTesting
File
getPingFile
(
final
String
docID
)
{
return
new
File
(
storeDir
docID
)
;
}
Override
public
void
storePing
(
final
TelemetryPing
ping
)
throws
IOException
{
storePing
(
ping
.
getPayload
(
)
ping
.
getDocID
(
)
ping
.
getURLPath
(
)
)
;
}
public
void
storePing
(
final
ExtendedJSONObject
payload
String
docID
Nullable
String
urlPath
)
throws
IOException
{
final
JSONObject
output
;
try
{
output
=
new
JSONObject
(
)
.
put
(
KEY_PAYLOAD
payload
)
;
if
(
urlPath
!
=
null
)
{
output
.
put
(
KEY_URL_PATH
urlPath
)
;
}
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Unable
to
create
JSON
to
store
to
disk
"
)
;
}
final
FileOutputStream
outputStream
=
new
FileOutputStream
(
getPingFile
(
docID
)
false
)
;
blockForLockAndWriteFileAndCloseStream
(
outputStream
output
.
toString
(
)
)
;
}
Override
public
void
maybePrunePings
(
)
{
final
File
[
]
files
=
storeDir
.
listFiles
(
uuidFilenameFilter
)
;
if
(
files
=
=
null
)
{
return
;
}
if
(
files
.
length
<
MAX_PING_COUNT
)
{
return
;
}
final
ArrayList
<
File
>
sortedFiles
=
new
ArrayList
<
>
(
Arrays
.
asList
(
files
)
)
;
Collections
.
sort
(
sortedFiles
fileLastModifiedComparator
)
;
deleteSmallestFiles
(
sortedFiles
files
.
length
-
MAX_PING_COUNT
)
;
}
private
void
deleteSmallestFiles
(
final
ArrayList
<
File
>
files
final
int
numFilesToRemove
)
{
final
Iterator
<
File
>
it
=
files
.
iterator
(
)
;
int
i
=
0
;
while
(
i
<
numFilesToRemove
)
{
i
+
=
1
;
final
File
file
=
it
.
next
(
)
;
file
.
delete
(
)
;
}
}
Override
public
ArrayList
<
TelemetryPing
>
getAllPings
(
)
{
final
File
[
]
fileArray
=
storeDir
.
listFiles
(
uuidFilenameFilter
)
;
if
(
fileArray
=
=
null
)
{
Log
.
w
(
LOGTAG
"
listFiles
unexpectedly
returned
null
-
unable
to
retrieve
pings
.
Debug
:
exists
?
"
+
storeDir
.
exists
(
)
+
"
;
directory
?
"
+
storeDir
.
isDirectory
(
)
)
;
return
new
ArrayList
<
>
(
1
)
;
}
final
List
<
File
>
files
=
Arrays
.
asList
(
fileArray
)
;
Collections
.
sort
(
files
fileLastModifiedComparator
)
;
final
ArrayList
<
TelemetryPing
>
out
=
new
ArrayList
<
>
(
files
.
size
(
)
)
;
for
(
final
File
file
:
files
)
{
final
JSONObject
obj
=
lockAndReadJSONFromFile
(
file
)
;
if
(
obj
=
=
null
)
{
continue
;
}
final
ExtendedJSONObject
payload
;
try
{
payload
=
new
ExtendedJSONObject
(
obj
.
getString
(
KEY_PAYLOAD
)
)
;
}
catch
(
IOException
|
JSONException
|
NonObjectJSONException
e
)
{
Log
.
w
(
LOGTAG
"
Bad
json
in
ping
.
Ignoring
.
"
)
;
continue
;
}
try
{
final
String
url
=
obj
.
getString
(
KEY_URL_PATH
)
;
out
.
add
(
new
TelemetryOutgoingPing
(
url
payload
file
.
getName
(
)
)
)
;
}
catch
(
JSONException
e
)
{
out
.
add
(
new
TelemetryLocalPing
(
payload
file
.
getName
(
)
)
)
;
}
}
return
out
;
}
Override
public
int
getCount
(
)
{
final
File
[
]
fileArray
=
storeDir
.
listFiles
(
uuidFilenameFilter
)
;
if
(
fileArray
=
=
null
)
{
Log
.
w
(
LOGTAG
"
listFiles
unexpectedly
returned
null
-
unable
to
retrieve
pings
.
Assuming
0
.
"
+
"
Debug
:
exists
?
"
+
storeDir
.
exists
(
)
+
"
;
directory
?
"
+
storeDir
.
isDirectory
(
)
)
;
return
0
;
}
return
fileArray
.
length
;
}
Override
public
Set
<
String
>
getStoredIDs
(
)
{
final
Set
<
String
>
ids
=
new
HashSet
<
>
(
)
;
final
File
[
]
fileArray
=
storeDir
.
listFiles
(
uuidFilenameFilter
)
;
if
(
fileArray
=
=
null
)
{
return
ids
;
}
for
(
File
file
:
fileArray
)
{
ids
.
add
(
file
.
getName
(
)
)
;
}
return
ids
;
}
private
JSONObject
lockAndReadJSONFromFile
(
final
File
file
)
{
if
(
file
.
length
(
)
=
=
0
)
{
Log
.
w
(
LOGTAG
"
Unexpected
empty
file
:
"
+
file
.
getName
(
)
+
"
.
Ignoring
"
)
;
return
null
;
}
final
FileInputStream
inputStream
;
try
{
inputStream
=
new
FileInputStream
(
file
)
;
}
catch
(
final
FileNotFoundException
e
)
{
String
fileInfo
=
String
.
format
(
"
existence
:
%
b
can
write
:
%
b
size
:
%
d
.
"
file
.
exists
(
)
file
.
canWrite
(
)
file
.
length
(
)
)
;
String
msg
=
String
.
format
(
"
Expected
file
to
exist
but
got
exception
in
thread
:
%
s
.
File
info
-
%
s
"
Thread
.
currentThread
(
)
.
getName
(
)
fileInfo
)
;
throw
new
IllegalStateException
(
msg
)
;
}
final
JSONObject
obj
;
try
{
obj
=
lockAndReadFileAndCloseStream
(
inputStream
(
int
)
file
.
length
(
)
)
;
}
catch
(
final
IOException
|
JSONException
e
)
{
Log
.
w
(
LOGTAG
"
Error
when
reading
file
:
"
+
file
.
getName
(
)
+
"
Likely
corrupted
.
Ignoring
"
)
;
return
null
;
}
if
(
obj
=
=
null
)
{
Log
.
d
(
LOGTAG
"
Could
not
read
given
file
:
"
+
file
.
getName
(
)
+
"
File
is
locked
.
Ignoring
"
)
;
}
return
obj
;
}
Override
public
void
onUploadAttemptComplete
(
final
Set
<
String
>
successfulRemoveIDs
)
{
if
(
successfulRemoveIDs
.
isEmpty
(
)
)
{
return
;
}
final
File
[
]
files
=
storeDir
.
listFiles
(
new
FilenameWhitelistFilter
(
successfulRemoveIDs
)
)
;
for
(
final
File
file
:
files
)
{
file
.
delete
(
)
;
}
}
private
static
void
blockForLockAndWriteFileAndCloseStream
(
final
FileOutputStream
outputStream
final
String
str
)
throws
IOException
{
try
{
final
FileLock
lock
=
outputStream
.
getChannel
(
)
.
lock
(
0
Long
.
MAX_VALUE
false
)
;
if
(
lock
!
=
null
)
{
FileUtils
.
writeStringToOutputStreamAndCloseStream
(
outputStream
str
)
;
}
}
finally
{
outputStream
.
close
(
)
;
}
}
private
static
JSONObject
lockAndReadFileAndCloseStream
(
final
FileInputStream
inputStream
final
int
fileSize
)
throws
IOException
JSONException
{
try
{
final
FileLock
lock
=
inputStream
.
getChannel
(
)
.
tryLock
(
0
Long
.
MAX_VALUE
true
)
;
if
(
lock
=
=
null
)
{
return
null
;
}
return
new
JSONObject
(
FileUtils
.
readStringFromInputStreamAndCloseStream
(
inputStream
fileSize
)
)
;
}
finally
{
inputStream
.
close
(
)
;
}
}
public
static
final
Parcelable
.
Creator
<
TelemetryJSONFilePingStore
>
CREATOR
=
new
Parcelable
.
Creator
<
TelemetryJSONFilePingStore
>
(
)
{
Override
public
TelemetryJSONFilePingStore
createFromParcel
(
final
Parcel
source
)
{
final
String
storeDirPath
=
source
.
readString
(
)
;
final
String
profileName
=
source
.
readString
(
)
;
return
new
TelemetryJSONFilePingStore
(
new
File
(
storeDirPath
)
profileName
)
;
}
Override
public
TelemetryJSONFilePingStore
[
]
newArray
(
final
int
size
)
{
return
new
TelemetryJSONFilePingStore
[
size
]
;
}
}
;
Override
public
int
describeContents
(
)
{
return
0
;
}
Override
public
void
writeToParcel
(
final
Parcel
dest
final
int
flags
)
{
dest
.
writeString
(
storeDir
.
getAbsolutePath
(
)
)
;
dest
.
writeString
(
getProfileName
(
)
)
;
}
}
