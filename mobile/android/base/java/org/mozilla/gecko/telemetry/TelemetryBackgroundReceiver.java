package
org
.
mozilla
.
gecko
.
telemetry
;
import
android
.
content
.
BroadcastReceiver
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
IntentFilter
;
import
android
.
content
.
SharedPreferences
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Parcelable
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
v4
.
content
.
LocalBroadcastManager
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
Experiments
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
switchboard
.
SwitchBoard
;
import
org
.
mozilla
.
gecko
.
sync
.
telemetry
.
TelemetryContract
;
import
org
.
mozilla
.
gecko
.
telemetry
.
pingbuilders
.
TelemetrySyncEventPingBuilder
;
import
org
.
mozilla
.
gecko
.
telemetry
.
pingbuilders
.
TelemetrySyncPingBuilder
;
import
org
.
mozilla
.
gecko
.
telemetry
.
pingbuilders
.
TelemetrySyncPingBundleBuilder
;
import
org
.
mozilla
.
gecko
.
telemetry
.
schedulers
.
TelemetryUploadAllPingsImmediatelyScheduler
;
import
org
.
mozilla
.
gecko
.
telemetry
.
schedulers
.
TelemetryUploadScheduler
;
import
org
.
mozilla
.
gecko
.
telemetry
.
stores
.
TelemetryJSONFilePingStore
;
import
org
.
mozilla
.
gecko
.
telemetry
.
stores
.
TelemetryPingStore
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Serializable
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Set
;
public
class
TelemetryBackgroundReceiver
extends
BroadcastReceiver
{
private
final
static
String
LOG_TAG
=
"
TelemetryBgReceiver
"
;
private
static
final
String
ACTION_BACKGROUND_TELEMETRY
=
"
org
.
mozilla
.
gecko
.
telemetry
.
BACKGROUND
"
;
private
static
final
String
SYNC_BUNDLE_STORE_DIR
=
"
sync
-
ping
-
data
"
;
private
static
final
String
SYNC_STORE_DIR
=
"
sync
-
data
"
;
private
static
final
String
SYNC_EVENT_STORE_DIR
=
"
sync
-
event
-
data
"
;
private
static
final
int
LOCAL_SYNC_EVENT_PING_THRESHOLD
=
100
;
private
static
final
int
LOCAL_SYNC_PING_THRESHOLD
=
100
;
private
static
final
long
MAX_TIME_BETWEEN_UPLOADS
=
12
*
60
*
60
*
1000
;
private
static
final
String
PREF_FILE_BACKGROUND_TELEMETRY
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
telemetry
.
background
"
;
private
static
final
String
PREF_IDS
=
"
ids
"
;
private
static
final
String
PREF_LAST_ATTEMPTED_UPLOADED
=
"
last_attempted_upload
"
;
private
static
final
String
DEFAULT_PROFILE
=
"
default
"
;
private
static
final
TelemetryBackgroundReceiver
instance
=
new
TelemetryBackgroundReceiver
(
)
;
private
boolean
initialized
;
public
static
TelemetryBackgroundReceiver
getInstance
(
)
{
return
instance
;
}
public
void
init
(
Context
context
)
{
if
(
initialized
)
{
return
;
}
LocalBroadcastManager
.
getInstance
(
context
)
.
registerReceiver
(
this
new
IntentFilter
(
ACTION_BACKGROUND_TELEMETRY
)
)
;
initialized
=
true
;
}
Override
public
void
onReceive
(
final
Context
context
final
Intent
intent
)
{
Log
.
i
(
LOG_TAG
"
Handling
background
telemetry
broadcast
"
)
;
if
(
!
GeckoPreferences
.
getBooleanPref
(
context
GeckoPreferences
.
PREFS_HEALTHREPORT_UPLOAD_ENABLED
false
)
)
{
Log
.
i
(
LOG_TAG
"
Telemetry
is
disabled
via
preferences
dropping
background
telemetry
.
"
)
;
return
;
}
if
(
!
SwitchBoard
.
isInExperiment
(
context
Experiments
.
ENABLE_PROCESSING_BACKGROUND_TELEMETRY
)
)
{
Log
.
i
(
LOG_TAG
"
Background
telemetry
processing
disabled
via
switchboard
.
"
)
;
return
;
}
if
(
!
intent
.
hasExtra
(
TelemetryContract
.
KEY_TELEMETRY
)
)
{
throw
new
IllegalStateException
(
"
Received
a
background
telemetry
broadcast
without
data
.
"
)
;
}
if
(
!
intent
.
hasExtra
(
TelemetryContract
.
KEY_TYPE
)
)
{
throw
new
IllegalStateException
(
"
Received
a
background
telemetry
broadcast
without
type
.
"
)
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
String
type
=
intent
.
getStringExtra
(
TelemetryContract
.
KEY_TYPE
)
;
final
TelemetryJSONFilePingStore
syncTelemetryStore
=
new
TelemetryJSONFilePingStore
(
context
.
getFileStreamPath
(
SYNC_STORE_DIR
)
DEFAULT_PROFILE
)
;
final
TelemetryJSONFilePingStore
syncEventTelemetryStore
=
new
TelemetryJSONFilePingStore
(
context
.
getFileStreamPath
(
SYNC_EVENT_STORE_DIR
)
DEFAULT_PROFILE
)
;
final
Bundle
telemetryBundle
=
intent
.
getParcelableExtra
(
TelemetryContract
.
KEY_TELEMETRY
)
;
final
String
uid
=
telemetryBundle
.
getString
(
TelemetryContract
.
KEY_LOCAL_UID
)
;
final
String
deviceID
=
telemetryBundle
.
getString
(
TelemetryContract
.
KEY_LOCAL_DEVICE_ID
)
;
final
TelemetryLocalPing
localPing
;
final
TelemetryPingStore
telemetryStore
;
switch
(
type
)
{
case
TelemetryContract
.
KEY_TYPE_SYNC
:
final
ArrayList
<
Parcelable
>
devices
=
telemetryBundle
.
getParcelableArrayList
(
TelemetryContract
.
KEY_DEVICES
)
;
final
Serializable
error
=
telemetryBundle
.
getSerializable
(
TelemetryContract
.
KEY_ERROR
)
;
final
Serializable
stages
=
telemetryBundle
.
getSerializable
(
TelemetryContract
.
KEY_STAGES
)
;
final
long
took
=
telemetryBundle
.
getLong
(
TelemetryContract
.
KEY_TOOK
)
;
final
boolean
didRestart
=
telemetryBundle
.
getBoolean
(
TelemetryContract
.
KEY_RESTARTED
)
;
telemetryStore
=
syncTelemetryStore
;
TelemetrySyncPingBuilder
localPingBuilder
=
new
TelemetrySyncPingBuilder
(
)
;
if
(
uid
!
=
null
)
{
localPingBuilder
.
setUID
(
uid
)
;
}
if
(
deviceID
!
=
null
)
{
localPingBuilder
.
setDeviceID
(
deviceID
)
;
}
if
(
devices
!
=
null
)
{
localPingBuilder
.
setDevices
(
devices
)
;
}
if
(
stages
!
=
null
)
{
localPingBuilder
.
setStages
(
stages
)
;
}
if
(
error
!
=
null
)
{
localPingBuilder
.
setError
(
error
)
;
}
localPing
=
localPingBuilder
.
setRestarted
(
didRestart
)
.
setTook
(
took
)
.
build
(
)
;
break
;
case
TelemetryContract
.
KEY_TYPE_EVENT
:
telemetryStore
=
syncEventTelemetryStore
;
localPing
=
new
TelemetrySyncEventPingBuilder
(
)
.
fromEventTelemetry
(
(
Bundle
)
intent
.
getParcelableExtra
(
TelemetryContract
.
KEY_TELEMETRY
)
)
.
build
(
)
;
break
;
default
:
throw
new
IllegalArgumentException
(
"
Unknown
background
telemetry
type
.
"
)
;
}
try
{
telemetryStore
.
storePing
(
localPing
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOG_TAG
"
Could
not
store
incoming
telemetry
.
Attempting
to
upload
already
stored
telemetry
.
"
e
)
;
}
final
SharedPreferences
sharedPreferences
=
context
.
getSharedPreferences
(
PREF_FILE_BACKGROUND_TELEMETRY
Context
.
MODE_PRIVATE
)
;
final
TelemetryPingStore
syncPingStore
=
new
TelemetryJSONFilePingStore
(
context
.
getFileStreamPath
(
SYNC_BUNDLE_STORE_DIR
)
DEFAULT_PROFILE
)
;
long
lastAttemptedSyncPingUpload
=
sharedPreferences
.
getLong
(
PREF_LAST_ATTEMPTED_UPLOADED
0L
)
;
boolean
idsChanged
=
false
;
if
(
uid
!
=
null
&
&
deviceID
!
=
null
)
{
idsChanged
=
setOrUpdateIDsIfChanged
(
sharedPreferences
uid
deviceID
)
;
}
final
String
reasonToUpload
=
reasonToUpload
(
idsChanged
syncTelemetryStore
.
getCount
(
)
syncEventTelemetryStore
.
getCount
(
)
lastAttemptedSyncPingUpload
)
;
if
(
reasonToUpload
!
=
null
)
{
final
Set
<
String
>
localSyncTelemetryToRemove
=
syncTelemetryStore
.
getStoredIDs
(
)
;
final
Set
<
String
>
localSyncEventTelemetryToRemove
=
syncEventTelemetryStore
.
getStoredIDs
(
)
;
final
TelemetryOutgoingPing
syncPing
=
new
TelemetrySyncPingBundleBuilder
(
)
.
setSyncStore
(
syncTelemetryStore
)
.
setSyncEventStore
(
syncEventTelemetryStore
)
.
setReason
(
reasonToUpload
)
.
build
(
)
;
boolean
bundledSyncPingPersisted
=
true
;
try
{
syncPingStore
.
storePing
(
syncPing
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOG_TAG
"
Unable
to
write
bundled
sync
ping
to
disk
.
Skipping
upload
.
"
e
)
;
bundledSyncPingPersisted
=
false
;
}
if
(
bundledSyncPingPersisted
)
{
syncTelemetryStore
.
onUploadAttemptComplete
(
localSyncTelemetryToRemove
)
;
syncEventTelemetryStore
.
onUploadAttemptComplete
(
localSyncEventTelemetryToRemove
)
;
}
}
if
(
reasonToUpload
!
=
null
|
|
syncPingStore
.
getCount
(
)
>
0
)
{
sharedPreferences
.
edit
(
)
.
putLong
(
PREF_LAST_ATTEMPTED_UPLOADED
System
.
currentTimeMillis
(
)
)
.
apply
(
)
;
final
TelemetryUploadScheduler
scheduler
=
new
TelemetryUploadAllPingsImmediatelyScheduler
(
)
;
if
(
scheduler
.
isReadyToUpload
(
context
syncPingStore
)
)
{
scheduler
.
scheduleUpload
(
context
syncPingStore
)
;
}
}
}
}
)
;
}
Nullable
protected
static
String
reasonToUpload
(
boolean
idsChanged
int
syncCount
int
eventCount
long
lastUploadAttempt
)
{
if
(
idsChanged
)
{
return
TelemetrySyncPingBundleBuilder
.
UPLOAD_REASON_IDCHANGE
;
}
if
(
syncCount
>
LOCAL_SYNC_PING_THRESHOLD
|
|
eventCount
>
LOCAL_SYNC_EVENT_PING_THRESHOLD
)
{
return
TelemetrySyncPingBundleBuilder
.
UPLOAD_REASON_COUNT
;
}
final
long
now
=
System
.
currentTimeMillis
(
)
;
if
(
lastUploadAttempt
=
=
0L
)
{
return
TelemetrySyncPingBundleBuilder
.
UPLOAD_REASON_FIRST
;
}
final
long
DRIFT_BUFFER_IN_MS
=
60
*
1000L
;
if
(
(
lastUploadAttempt
-
now
)
>
DRIFT_BUFFER_IN_MS
)
{
return
TelemetrySyncPingBundleBuilder
.
UPLOAD_REASON_CLOCK_DRIFT
;
}
if
(
(
now
-
lastUploadAttempt
)
>
=
MAX_TIME_BETWEEN_UPLOADS
)
{
return
TelemetrySyncPingBundleBuilder
.
UPLOAD_REASON_SCHEDULE
;
}
return
null
;
}
private
boolean
setOrUpdateIDsIfChanged
(
NonNull
SharedPreferences
prefs
NonNull
String
uid
NonNull
String
deviceID
)
{
final
String
currentIDsCombined
=
uid
.
concat
(
deviceID
)
;
final
String
previousIDsHash
=
prefs
.
getString
(
PREF_IDS
"
"
)
;
if
(
previousIDsHash
.
equals
(
"
"
)
)
{
final
SharedPreferences
.
Editor
prefsEditor
=
prefs
.
edit
(
)
;
prefsEditor
.
putString
(
PREF_IDS
currentIDsCombined
)
;
prefsEditor
.
apply
(
)
;
return
false
;
}
if
(
!
previousIDsHash
.
equals
(
currentIDsCombined
)
)
{
final
SharedPreferences
.
Editor
prefsEditor
=
prefs
.
edit
(
)
;
prefsEditor
.
putString
(
PREF_IDS
currentIDsCombined
)
;
prefsEditor
.
apply
(
)
;
return
true
;
}
return
false
;
}
}
