package
org
.
mozilla
.
gecko
.
telemetry
.
pings
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
java
.
util
.
Set
;
import
java
.
util
.
UUID
;
abstract
class
TelemetryPingBuilder
{
private
static
final
String
SERVER_INITIAL_PATH
=
"
submit
/
telemetry
"
;
private
final
String
serverUrl
;
protected
final
ExtendedJSONObject
payload
;
public
TelemetryPingBuilder
(
final
String
serverURLSchemeHostPort
)
{
serverUrl
=
getTelemetryServerURL
(
getDocType
(
)
serverURLSchemeHostPort
)
;
payload
=
new
ExtendedJSONObject
(
)
;
}
abstract
String
getDocType
(
)
;
abstract
String
[
]
getMandatoryFields
(
)
;
public
TelemetryPing
build
(
)
{
validatePayload
(
)
;
return
new
TelemetryPing
(
serverUrl
payload
)
;
}
private
void
validatePayload
(
)
{
final
Set
<
String
>
keySet
=
payload
.
keySet
(
)
;
for
(
final
String
mandatoryField
:
getMandatoryFields
(
)
)
{
if
(
!
keySet
.
contains
(
mandatoryField
)
)
{
throw
new
IllegalArgumentException
(
"
Builder
does
not
contain
mandatory
field
:
"
+
mandatoryField
)
;
}
}
}
private
static
String
getTelemetryServerURL
(
final
String
docType
final
String
serverURLSchemeHostPort
)
{
final
String
docId
=
UUID
.
randomUUID
(
)
.
toString
(
)
;
final
String
appName
=
AppConstants
.
MOZ_APP_BASENAME
;
final
String
appVersion
=
AppConstants
.
MOZ_APP_VERSION
;
final
String
appUpdateChannel
=
AppConstants
.
MOZ_UPDATE_CHANNEL
;
final
String
appBuildId
=
AppConstants
.
MOZ_APP_BUILDID
;
return
serverURLSchemeHostPort
+
'
/
'
+
SERVER_INITIAL_PATH
+
'
/
'
+
docId
+
'
/
'
+
docType
+
'
/
'
+
appName
+
'
/
'
+
appVersion
+
'
/
'
+
appUpdateChannel
+
'
/
'
+
appBuildId
;
}
}
