package
org
.
mozilla
.
gecko
.
telemetry
.
pingbuilders
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryOutgoingPing
;
import
java
.
util
.
Set
;
import
java
.
util
.
UUID
;
abstract
class
TelemetryPingBuilder
{
private
static
final
String
SERVER_INITIAL_PATH
=
"
submit
/
telemetry
"
;
private
static
final
int
DEFAULT_TELEMETRY_VERSION
=
1
;
public
static
final
int
UNIFIED_TELEMETRY_VERSION
=
4
;
private
final
String
serverPath
;
protected
final
ExtendedJSONObject
payload
;
protected
final
String
docID
;
public
TelemetryPingBuilder
(
)
{
this
(
DEFAULT_TELEMETRY_VERSION
)
;
}
public
TelemetryPingBuilder
(
int
version
)
{
docID
=
UUID
.
randomUUID
(
)
.
toString
(
)
;
serverPath
=
getTelemetryServerPath
(
getDocType
(
)
docID
version
)
;
payload
=
new
ExtendedJSONObject
(
)
;
}
public
abstract
String
getDocType
(
)
;
public
abstract
String
[
]
getMandatoryFields
(
)
;
public
TelemetryOutgoingPing
build
(
)
{
validatePayload
(
)
;
return
new
TelemetryOutgoingPing
(
serverPath
payload
docID
)
;
}
private
void
validatePayload
(
)
{
final
Set
<
String
>
keySet
=
payload
.
keySet
(
)
;
for
(
final
String
mandatoryField
:
getMandatoryFields
(
)
)
{
if
(
!
keySet
.
contains
(
mandatoryField
)
)
{
throw
new
IllegalArgumentException
(
"
Builder
does
not
contain
mandatory
field
:
"
+
mandatoryField
)
;
}
}
}
private
static
String
getTelemetryServerPath
(
final
String
docType
final
String
docID
int
version
)
{
final
String
appName
=
AppConstants
.
MOZ_APP_BASENAME
;
final
String
appVersion
=
AppConstants
.
MOZ_APP_VERSION
;
final
String
appUpdateChannel
=
AppConstants
.
MOZ_UPDATE_CHANNEL
;
final
String
appBuildId
=
AppConstants
.
MOZ_APP_BUILDID
;
return
SERVER_INITIAL_PATH
+
'
/
'
+
docID
+
'
/
'
+
docType
+
'
/
'
+
appName
+
'
/
'
+
appVersion
+
'
/
'
+
appUpdateChannel
+
'
/
'
+
appBuildId
+
(
version
=
=
UNIFIED_TELEMETRY_VERSION
?
"
?
v
=
4
"
:
"
"
)
;
}
}
