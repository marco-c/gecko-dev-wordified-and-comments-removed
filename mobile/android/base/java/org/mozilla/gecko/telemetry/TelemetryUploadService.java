package
org
.
mozilla
.
gecko
.
telemetry
;
import
android
.
app
.
IntentService
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
util
.
Log
;
import
ch
.
boye
.
httpclientandroidlib
.
HttpResponse
;
import
ch
.
boye
.
httpclientandroidlib
.
client
.
ClientProtocolException
;
import
org
.
mozilla
.
gecko
.
GeckoProfile
;
import
org
.
mozilla
.
gecko
.
GeckoSharedPrefs
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
sync
.
ExtendedJSONObject
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
BaseResource
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
BaseResourceDelegate
;
import
org
.
mozilla
.
gecko
.
sync
.
net
.
Resource
;
import
org
.
mozilla
.
gecko
.
telemetry
.
stores
.
TelemetryPingStore
;
import
org
.
mozilla
.
gecko
.
util
.
NetworkUtils
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
java
.
io
.
IOException
;
import
java
.
net
.
URISyntaxException
;
import
java
.
security
.
GeneralSecurityException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
class
TelemetryUploadService
extends
IntentService
{
private
static
final
String
LOGTAG
=
StringUtils
.
safeSubstring
(
"
Gecko
"
+
TelemetryUploadService
.
class
.
getSimpleName
(
)
0
23
)
;
private
static
final
String
WORKER_THREAD_NAME
=
LOGTAG
+
"
Worker
"
;
public
static
final
String
ACTION_UPLOAD
=
"
upload
"
;
public
static
final
String
EXTRA_STORE
=
"
store
"
;
public
TelemetryUploadService
(
)
{
super
(
WORKER_THREAD_NAME
)
;
setIntentRedelivery
(
false
)
;
}
Override
public
void
onHandleIntent
(
final
Intent
intent
)
{
Log
.
d
(
LOGTAG
"
Service
started
"
)
;
if
(
!
isReadyToUpload
(
this
intent
)
)
{
return
;
}
final
TelemetryPingStore
store
=
intent
.
getParcelableExtra
(
EXTRA_STORE
)
;
final
boolean
wereAllUploadsSuccessful
=
uploadPendingPingsFromStore
(
this
store
)
;
store
.
maybePrunePings
(
)
;
Log
.
d
(
LOGTAG
"
Service
finished
:
upload
and
prune
attempts
completed
"
)
;
if
(
!
wereAllUploadsSuccessful
)
{
Log
.
d
(
LOGTAG
"
Clearing
Intent
queue
due
to
connection
failures
"
)
;
stopSelf
(
)
;
}
}
private
static
boolean
uploadPendingPingsFromStore
(
final
Context
context
final
TelemetryPingStore
store
)
{
final
ArrayList
<
TelemetryPingFromStore
>
pingsToUpload
=
store
.
getAllPings
(
)
;
if
(
pingsToUpload
.
isEmpty
(
)
)
{
return
true
;
}
final
String
serverSchemeHostPort
=
getServerSchemeHostPort
(
context
)
;
final
HashSet
<
Integer
>
successfulUploadIDs
=
new
HashSet
<
>
(
pingsToUpload
.
size
(
)
)
;
final
PingResultDelegate
delegate
=
new
PingResultDelegate
(
successfulUploadIDs
)
;
for
(
final
TelemetryPingFromStore
ping
:
pingsToUpload
)
{
if
(
delegate
.
hadConnectionError
(
)
)
{
break
;
}
delegate
.
setPingID
(
ping
.
getUniqueID
(
)
)
;
final
String
url
=
serverSchemeHostPort
+
"
/
"
+
ping
.
getURLPath
(
)
;
uploadPayload
(
url
ping
.
getPayload
(
)
delegate
)
;
}
final
boolean
wereAllUploadsSuccessful
=
!
delegate
.
hadConnectionError
(
)
;
if
(
wereAllUploadsSuccessful
)
{
Log
.
d
(
LOGTAG
"
Telemetry
upload
success
!
"
)
;
}
store
.
onUploadAttemptComplete
(
successfulUploadIDs
)
;
return
wereAllUploadsSuccessful
;
}
private
static
String
getServerSchemeHostPort
(
final
Context
context
)
{
final
SharedPreferences
sharedPrefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
return
sharedPrefs
.
getString
(
TelemetryConstants
.
PREF_SERVER_URL
TelemetryConstants
.
DEFAULT_SERVER_URL
)
;
}
private
static
void
uploadPayload
(
final
String
url
final
ExtendedJSONObject
payload
final
ResultDelegate
delegate
)
{
final
BaseResource
resource
;
try
{
resource
=
new
BaseResource
(
url
)
;
}
catch
(
final
URISyntaxException
e
)
{
Log
.
w
(
LOGTAG
"
URISyntaxException
for
server
URL
when
creating
BaseResource
:
returning
.
"
)
;
return
;
}
delegate
.
setResource
(
resource
)
;
resource
.
delegate
=
delegate
;
resource
.
setShouldCompressUploadedEntity
(
true
)
;
resource
.
setShouldChunkUploadsHint
(
false
)
;
resource
.
postBlocking
(
payload
)
;
}
private
static
boolean
isReadyToUpload
(
final
Context
context
final
Intent
intent
)
{
if
(
!
isUploadEnabledByAppConfig
(
context
)
)
{
Log
.
w
(
LOGTAG
"
Upload
is
not
available
by
configuration
;
returning
"
)
;
return
false
;
}
if
(
!
isIntentValid
(
intent
)
)
{
Log
.
w
(
LOGTAG
"
Received
invalid
Intent
;
returning
"
)
;
return
false
;
}
if
(
!
ACTION_UPLOAD
.
equals
(
intent
.
getAction
(
)
)
)
{
Log
.
w
(
LOGTAG
"
Unknown
action
:
"
+
intent
.
getAction
(
)
+
"
.
Returning
"
)
;
return
false
;
}
return
true
;
}
public
static
boolean
isUploadEnabledByAppConfig
(
final
Context
context
)
{
if
(
!
TelemetryConstants
.
UPLOAD_ENABLED
)
{
Log
.
d
(
LOGTAG
"
Telemetry
upload
feature
is
compile
-
time
disabled
"
)
;
return
false
;
}
if
(
!
GeckoPreferences
.
getBooleanPref
(
context
GeckoPreferences
.
PREFS_HEALTHREPORT_UPLOAD_ENABLED
true
)
)
{
Log
.
d
(
LOGTAG
"
Telemetry
upload
opt
-
out
"
)
;
return
false
;
}
if
(
!
NetworkUtils
.
isBackgroundDataEnabled
(
context
)
)
{
Log
.
d
(
LOGTAG
"
Background
data
is
disabled
"
)
;
return
false
;
}
return
true
;
}
public
static
boolean
isUploadEnabledByProfileConfig
(
final
Context
context
final
GeckoProfile
profile
)
{
if
(
profile
.
inGuestMode
(
)
)
{
Log
.
d
(
LOGTAG
"
Profile
is
in
guest
mode
"
)
;
return
false
;
}
return
isUploadEnabledByAppConfig
(
context
)
;
}
private
static
boolean
isIntentValid
(
final
Intent
intent
)
{
if
(
intent
=
=
null
)
{
Log
.
d
(
LOGTAG
"
Received
null
intent
"
)
;
return
false
;
}
if
(
intent
.
getParcelableExtra
(
EXTRA_STORE
)
=
=
null
)
{
Log
.
d
(
LOGTAG
"
Received
invalid
store
in
Intent
"
)
;
return
false
;
}
return
true
;
}
private
static
class
PingResultDelegate
extends
ResultDelegate
{
private
static
final
int
SOCKET_TIMEOUT_MILLIS
=
(
int
)
TimeUnit
.
SECONDS
.
toMillis
(
30
)
;
private
static
final
int
CONNECTION_TIMEOUT_MILLIS
=
(
int
)
TimeUnit
.
SECONDS
.
toMillis
(
30
)
;
private
int
pingID
=
-
1
;
private
final
HashSet
<
Integer
>
successfulUploadIDs
;
private
boolean
hadConnectionError
=
false
;
public
PingResultDelegate
(
final
HashSet
<
Integer
>
successfulUploadIDs
)
{
super
(
)
;
this
.
successfulUploadIDs
=
successfulUploadIDs
;
}
Override
public
int
socketTimeout
(
)
{
return
SOCKET_TIMEOUT_MILLIS
;
}
Override
public
int
connectionTimeout
(
)
{
return
CONNECTION_TIMEOUT_MILLIS
;
}
private
int
getPingID
(
)
{
if
(
pingID
<
0
)
{
throw
new
IllegalStateException
(
"
Expected
ping
ID
to
have
been
updated
before
retrieval
"
)
;
}
return
pingID
;
}
public
void
setPingID
(
final
int
id
)
{
pingID
=
id
;
}
Override
public
String
getUserAgent
(
)
{
return
TelemetryConstants
.
USER_AGENT
;
}
Override
public
void
handleHttpResponse
(
final
HttpResponse
response
)
{
final
int
status
=
response
.
getStatusLine
(
)
.
getStatusCode
(
)
;
switch
(
status
)
{
case
200
:
case
201
:
successfulUploadIDs
.
add
(
getPingID
(
)
)
;
break
;
default
:
Log
.
w
(
LOGTAG
"
Telemetry
upload
failure
.
HTTP
status
:
"
+
status
)
;
hadConnectionError
=
true
;
}
}
Override
public
void
handleHttpProtocolException
(
final
ClientProtocolException
e
)
{
Log
.
w
(
LOGTAG
"
HttpProtocolException
when
trying
to
upload
telemetry
"
)
;
hadConnectionError
=
true
;
}
Override
public
void
handleHttpIOException
(
final
IOException
e
)
{
Log
.
w
(
LOGTAG
"
HttpIOException
when
trying
to
upload
telemetry
"
)
;
hadConnectionError
=
true
;
}
Override
public
void
handleTransportException
(
final
GeneralSecurityException
e
)
{
Log
.
w
(
LOGTAG
"
Transport
exception
when
trying
to
upload
telemetry
"
)
;
hadConnectionError
=
true
;
}
private
boolean
hadConnectionError
(
)
{
return
hadConnectionError
;
}
}
private
static
abstract
class
ResultDelegate
extends
BaseResourceDelegate
{
public
ResultDelegate
(
)
{
super
(
null
)
;
}
protected
void
setResource
(
final
Resource
resource
)
{
this
.
resource
=
resource
;
}
}
}
