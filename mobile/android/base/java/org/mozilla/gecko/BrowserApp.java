package
org
.
mozilla
.
gecko
;
import
android
.
Manifest
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
app
.
AlertDialog
;
import
android
.
app
.
DownloadManager
;
import
android
.
content
.
ContentProviderClient
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
content
.
DialogInterface
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
pm
.
ActivityInfo
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ResolveInfo
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
content
.
res
.
Resources
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
drawable
.
BitmapDrawable
;
import
android
.
graphics
.
drawable
.
Drawable
;
import
android
.
net
.
Uri
;
import
android
.
nfc
.
NdefMessage
;
import
android
.
nfc
.
NdefRecord
;
import
android
.
nfc
.
NfcAdapter
;
import
android
.
nfc
.
NfcEvent
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Environment
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
StringRes
;
import
android
.
support
.
design
.
widget
.
Snackbar
;
import
android
.
support
.
v4
.
app
.
Fragment
;
import
android
.
support
.
v4
.
app
.
FragmentManager
;
import
android
.
support
.
v4
.
content
.
res
.
ResourcesCompat
;
import
android
.
support
.
v4
.
view
.
MenuItemCompat
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
view
.
HapticFeedbackConstants
;
import
android
.
view
.
InputDevice
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
Menu
;
import
android
.
view
.
MenuInflater
;
import
android
.
view
.
MenuItem
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewConfiguration
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
ViewStub
;
import
android
.
view
.
ViewTreeObserver
;
import
android
.
view
.
Window
;
import
android
.
view
.
animation
.
Interpolator
;
import
android
.
widget
.
Button
;
import
android
.
widget
.
ListView
;
import
android
.
widget
.
ViewFlipper
;
import
org
.
mozilla
.
gecko
.
AppConstants
.
Versions
;
import
org
.
mozilla
.
gecko
.
DynamicToolbar
.
VisibilityTransition
;
import
org
.
mozilla
.
gecko
.
Tabs
.
TabEvents
;
import
org
.
mozilla
.
gecko
.
activitystream
.
ActivityStream
;
import
org
.
mozilla
.
gecko
.
activitystream
.
ActivityStreamTelemetry
;
import
org
.
mozilla
.
gecko
.
adjust
.
AdjustBrowserAppDelegate
;
import
org
.
mozilla
.
gecko
.
animation
.
PropertyAnimator
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
bookmarks
.
BookmarkEditFragment
;
import
org
.
mozilla
.
gecko
.
bookmarks
.
BookmarkUtils
;
import
org
.
mozilla
.
gecko
.
bookmarks
.
EditBookmarkTask
;
import
org
.
mozilla
.
gecko
.
cleanup
.
FileCleanupController
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
SuggestedSites
;
import
org
.
mozilla
.
gecko
.
delegates
.
BookmarkStateChangeDelegate
;
import
org
.
mozilla
.
gecko
.
delegates
.
BrowserAppDelegate
;
import
org
.
mozilla
.
gecko
.
delegates
.
OfflineTabStatusDelegate
;
import
org
.
mozilla
.
gecko
.
delegates
.
ScreenshotDelegate
;
import
org
.
mozilla
.
gecko
.
distribution
.
Distribution
;
import
org
.
mozilla
.
gecko
.
distribution
.
DistributionStoreCallback
;
import
org
.
mozilla
.
gecko
.
dlc
.
DlcStudyService
;
import
org
.
mozilla
.
gecko
.
dlc
.
DlcSyncService
;
import
org
.
mozilla
.
gecko
.
extensions
.
ExtensionPermissionsHelper
;
import
org
.
mozilla
.
gecko
.
firstrun
.
OnboardingHelper
;
import
org
.
mozilla
.
gecko
.
gfx
.
DynamicToolbarAnimator
;
import
org
.
mozilla
.
gecko
.
gfx
.
DynamicToolbarAnimator
.
PinReason
;
import
org
.
mozilla
.
gecko
.
home
.
BrowserSearch
;
import
org
.
mozilla
.
gecko
.
home
.
HomeBanner
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfig
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfig
.
PanelType
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfigPrefsBackend
;
import
org
.
mozilla
.
gecko
.
home
.
HomeFragment
;
import
org
.
mozilla
.
gecko
.
home
.
HomePager
.
OnUrlOpenInBackgroundListener
;
import
org
.
mozilla
.
gecko
.
home
.
HomePager
.
OnUrlOpenListener
;
import
org
.
mozilla
.
gecko
.
home
.
HomePanelsManager
;
import
org
.
mozilla
.
gecko
.
home
.
HomeScreen
;
import
org
.
mozilla
.
gecko
.
home
.
SearchEngine
;
import
org
.
mozilla
.
gecko
.
icons
.
Icons
;
import
org
.
mozilla
.
gecko
.
icons
.
IconsHelper
;
import
org
.
mozilla
.
gecko
.
icons
.
decoders
.
FaviconDecoder
;
import
org
.
mozilla
.
gecko
.
icons
.
decoders
.
IconDirectoryEntry
;
import
org
.
mozilla
.
gecko
.
icons
.
decoders
.
LoadFaviconResult
;
import
org
.
mozilla
.
gecko
.
lwt
.
LightweightTheme
;
import
org
.
mozilla
.
gecko
.
media
.
PictureInPictureController
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenu
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenuItem
;
import
org
.
mozilla
.
gecko
.
mma
.
MmaDelegate
;
import
org
.
mozilla
.
gecko
.
mozglue
.
SafeIntent
;
import
org
.
mozilla
.
gecko
.
notifications
.
NotificationHelper
;
import
org
.
mozilla
.
gecko
.
overlays
.
ui
.
ShareDialog
;
import
org
.
mozilla
.
gecko
.
permissions
.
Permissions
;
import
org
.
mozilla
.
gecko
.
preferences
.
ClearOnShutdownPref
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
promotion
.
ReaderViewBookmarkPromotion
;
import
org
.
mozilla
.
gecko
.
prompts
.
Prompt
;
import
org
.
mozilla
.
gecko
.
reader
.
ReaderModeUtils
;
import
org
.
mozilla
.
gecko
.
reader
.
ReadingListHelper
;
import
org
.
mozilla
.
gecko
.
reader
.
SavedReaderViewHelper
;
import
org
.
mozilla
.
gecko
.
restrictions
.
Restrictable
;
import
org
.
mozilla
.
gecko
.
restrictions
.
Restrictions
;
import
org
.
mozilla
.
gecko
.
search
.
SearchEngineManager
;
import
org
.
mozilla
.
gecko
.
switchboard
.
AsyncConfigLoader
;
import
org
.
mozilla
.
gecko
.
switchboard
.
SwitchBoard
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
.
FennecTabsRepository
;
import
org
.
mozilla
.
gecko
.
tabqueue
.
TabQueueHelper
;
import
org
.
mozilla
.
gecko
.
tabqueue
.
TabQueuePrompt
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryController
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryController
.
OnShowTabHistory
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryFragment
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryPage
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabsPanel
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryCorePingDelegate
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryUploadService
;
import
org
.
mozilla
.
gecko
.
telemetry
.
measurements
.
SearchCountMeasurements
;
import
org
.
mozilla
.
gecko
.
toolbar
.
AutocompleteHandler
;
import
org
.
mozilla
.
gecko
.
toolbar
.
BrowserToolbar
;
import
org
.
mozilla
.
gecko
.
toolbar
.
BrowserToolbar
.
TabEditingState
;
import
org
.
mozilla
.
gecko
.
toolbar
.
PwaConfirm
;
import
org
.
mozilla
.
gecko
.
trackingprotection
.
TrackingProtectionPrompt
;
import
org
.
mozilla
.
gecko
.
updater
.
PostUpdateHandler
;
import
org
.
mozilla
.
gecko
.
updater
.
UpdateServiceHelper
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ContextUtils
;
import
org
.
mozilla
.
gecko
.
util
.
DrawableUtil
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GamepadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
org
.
mozilla
.
gecko
.
util
.
MenuUtils
;
import
org
.
mozilla
.
gecko
.
util
.
PrefUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ShortcutUtils
;
import
org
.
mozilla
.
gecko
.
util
.
StrictModeContext
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
WindowUtil
;
import
org
.
mozilla
.
gecko
.
widget
.
ActionModePresenter
;
import
org
.
mozilla
.
gecko
.
widget
.
AnchoredPopup
;
import
org
.
mozilla
.
gecko
.
widget
.
AnimatedProgressBar
;
import
org
.
mozilla
.
gecko
.
widget
.
GeckoActionProvider
;
import
org
.
mozilla
.
gecko
.
widget
.
SplashScreen
;
import
org
.
mozilla
.
geckoview
.
GeckoSession
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
net
.
URLEncoder
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
EnumSet
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
regex
.
Pattern
;
import
static
org
.
mozilla
.
gecko
.
mma
.
MmaDelegate
.
NEW_TAB
;
import
static
org
.
mozilla
.
gecko
.
util
.
JavaUtil
.
getBundleSizeInBytes
;
public
class
BrowserApp
extends
GeckoApp
implements
ActionModePresenter
AnchoredPopup
.
OnVisibilityChangeListener
BookmarkEditFragment
.
Callbacks
BrowserSearch
.
OnEditSuggestionListener
BrowserSearch
.
OnSearchListener
DynamicToolbarAnimator
.
ToolbarChromeProxy
LayoutInflater
.
Factory
LightweightTheme
.
OnChangeListener
OnUrlOpenListener
OnUrlOpenInBackgroundListener
PropertyAnimator
.
PropertyAnimationListener
TabsPanel
.
TabsLayoutChangeListener
View
.
OnKeyListener
OnboardingHelper
.
OnboardingListener
{
private
static
final
String
LOGTAG
=
"
GeckoBrowserApp
"
;
private
static
final
int
TABS_ANIMATION_DURATION
=
450
;
private
static
final
String
INTENT_KEY_SWITCHBOARD_SERVER
=
"
switchboard
-
server
"
;
private
static
final
String
SWITCHBOARD_SERVER
=
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
/
buckets
/
fennec
/
collections
/
experiments
/
records
"
;
private
static
final
String
STATE_ABOUT_HOME_TOP_PADDING
=
"
abouthome_top_padding
"
;
private
static
final
String
BROWSER_SEARCH_TAG
=
"
browser_search
"
;
private
static
final
int
MAX_BUNDLE_SIZE
=
300000
;
public
static
final
int
ACTIVITY_REQUEST_PREFERENCES
=
1001
;
private
static
final
int
ACTIVITY_REQUEST_TAB_QUEUE
=
2001
;
public
static
final
int
ACTIVITY_REQUEST_FIRST_READERVIEW_BOOKMARK
=
3001
;
public
static
final
int
ACTIVITY_RESULT_FIRST_READERVIEW_BOOKMARKS_GOTO_BOOKMARKS
=
3002
;
public
static
final
int
ACTIVITY_RESULT_FIRST_READERVIEW_BOOKMARKS_IGNORE
=
3003
;
public
static
final
int
ACTIVITY_REQUEST_TRIPLE_READERVIEW
=
4001
;
public
static
final
int
ACTIVITY_RESULT_TRIPLE_READERVIEW_ADD_BOOKMARK
=
4002
;
public
static
final
int
ACTIVITY_RESULT_TRIPLE_READERVIEW_IGNORE
=
4003
;
public
static
final
String
ACTION_VIEW_MULTIPLE
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
action
.
VIEW_MULTIPLE
"
;
private
BrowserSearch
mBrowserSearch
;
private
View
mBrowserSearchContainer
;
public
ViewGroup
mBrowserChrome
;
public
ViewFlipper
mActionBarFlipper
;
public
ActionModeCompatView
mActionBar
;
private
PictureInPictureController
mPipController
;
private
BrowserToolbar
mBrowserToolbar
;
private
View
doorhangerOverlay
;
private
TabStripInterface
mTabStrip
;
private
AnimatedProgressBar
mProgressView
;
private
HomeScreen
mHomeScreen
;
private
TabsPanel
mTabsPanel
;
private
boolean
showSplashScreen
=
false
;
private
SplashScreen
splashScreen
;
private
ViewGroup
mHomeScreenContainer
;
private
int
mCachedRecentTabsCount
;
private
ActionModeCompat
mActionMode
;
private
TabHistoryController
tabHistoryController
;
public
static
final
String
TAB_HISTORY_FRAGMENT_TAG
=
"
tabHistoryFragment
"
;
private
boolean
mShowingToolbarChromeForActionBar
;
private
SafeIntent
safeStartingIntent
;
private
Intent
startingIntentAfterPip
;
private
boolean
isInAutomation
;
public
static
enum
GuestModeDialog
{
ENTERING
LEAVING
}
private
PropertyAnimator
mMainLayoutAnimator
;
private
static
final
Interpolator
sTabsInterpolator
=
new
Interpolator
(
)
{
Override
public
float
getInterpolation
(
float
t
)
{
t
-
=
1
.
0f
;
return
t
*
t
*
t
*
t
*
t
+
1
.
0f
;
}
}
;
private
FindInPageBar
mFindInPageBar
;
private
MediaCastingBar
mMediaCastingBar
;
private
static
final
int
FEEDBACK_LAUNCH_COUNT
=
15
;
private
int
mToolbarHeight
;
private
SharedPreferencesHelper
mSharedPreferencesHelper
;
private
ReadingListHelper
mReadingListHelper
;
private
AccountsHelper
mAccountsHelper
;
private
ExtensionPermissionsHelper
mExtensionPermissionsHelper
;
private
Integer
mTargetTabForEditingMode
;
private
final
TabEditingState
mLastTabEditingState
=
new
TabEditingState
(
)
;
private
boolean
mSuppressNextKeyUp
;
private
boolean
mHideWebContentOnAnimationEnd
;
private
final
DynamicToolbar
mDynamicToolbar
=
new
DynamicToolbar
(
)
;
private
final
TelemetryCorePingDelegate
mTelemetryCorePingDelegate
=
new
TelemetryCorePingDelegate
(
)
;
private
final
List
<
BrowserAppDelegate
>
delegates
=
Collections
.
unmodifiableList
(
Arrays
.
asList
(
new
ScreenshotDelegate
(
)
new
BookmarkStateChangeDelegate
(
)
new
ReaderViewBookmarkPromotion
(
)
new
PostUpdateHandler
(
)
mTelemetryCorePingDelegate
new
OfflineTabStatusDelegate
(
)
new
AdjustBrowserAppDelegate
(
mTelemetryCorePingDelegate
)
)
)
;
NonNull
private
SearchEngineManager
mSearchEngineManager
;
private
OnboardingHelper
mOnboardingHelper
;
private
boolean
mHasResumed
;
Override
public
View
onCreateView
(
final
View
parent
final
String
name
final
Context
context
final
AttributeSet
attrs
)
{
final
View
view
;
if
(
BrowserToolbar
.
class
.
getName
(
)
.
equals
(
name
)
)
{
view
=
BrowserToolbar
.
create
(
context
attrs
)
;
}
else
if
(
TabsPanel
.
TabsLayout
.
class
.
getName
(
)
.
equals
(
name
)
)
{
view
=
TabsPanel
.
createTabsLayout
(
context
attrs
)
;
}
else
{
view
=
super
.
onCreateView
(
name
context
attrs
)
;
}
return
view
;
}
Override
SuppressWarnings
(
"
fallthrough
"
)
public
void
onTabChanged
(
Tab
tab
TabEvents
msg
String
data
)
{
if
(
!
mInitialized
)
{
super
.
onTabChanged
(
tab
msg
data
)
;
return
;
}
if
(
tab
=
=
null
)
{
if
(
msg
!
=
Tabs
.
TabEvents
.
RESTORED
)
{
throw
new
IllegalArgumentException
(
"
onTabChanged
:
"
+
msg
+
"
must
specify
a
tab
.
"
)
;
}
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
updateHomePagerForTab
(
selectedTab
)
;
}
return
;
}
Log
.
d
(
LOGTAG
"
BrowserApp
.
onTabChanged
:
"
+
tab
.
getId
(
)
+
"
:
"
+
msg
)
;
switch
(
msg
)
{
case
SELECTED
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
&
&
mDynamicToolbar
.
isEnabled
(
)
)
{
final
VisibilityTransition
transition
=
(
tab
.
getShouldShowToolbarWithoutAnimationOnFirstSelection
(
)
)
?
VisibilityTransition
.
IMMEDIATE
:
VisibilityTransition
.
ANIMATE
;
mDynamicToolbar
.
setVisible
(
true
transition
)
;
tab
.
setShouldShowToolbarWithoutAnimationOnFirstSelection
(
false
)
;
}
case
LOCATION_CHANGE
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
updateHomePagerForTab
(
tab
)
;
}
if
(
mShowingToolbarChromeForActionBar
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
mShowingToolbarChromeForActionBar
=
false
;
}
break
;
case
START
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
invalidateOptionsMenu
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
break
;
case
LOAD_ERROR
:
case
STOP
:
case
MENU_UPDATED
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
invalidateOptionsMenu
(
)
;
}
break
;
case
PAGE_SHOW
:
tab
.
loadFavicon
(
)
;
break
;
case
UNSELECTED
:
if
(
tab
.
isEditing
(
)
)
{
tab
.
getEditingState
(
)
.
copyFrom
(
mLastTabEditingState
)
;
}
break
;
case
START_EDITING
:
enterEditingMode
(
)
;
break
;
}
if
(
HardwareUtils
.
isTablet
(
)
&
&
msg
=
=
TabEvents
.
SELECTED
)
{
updateEditingModeForTab
(
tab
)
;
}
super
.
onTabChanged
(
tab
msg
data
)
;
}
private
void
updateEditingModeForTab
(
final
Tab
selectedTab
)
{
if
(
!
Tabs
.
getInstance
(
)
.
isSelectedTab
(
selectedTab
)
)
{
Log
.
w
(
LOGTAG
"
updateEditingModeForTab
:
Given
tab
is
expected
to
be
selected
tab
"
)
;
}
saveTabEditingState
(
mLastTabEditingState
)
;
if
(
selectedTab
.
isEditing
(
)
)
{
enterEditingMode
(
)
;
restoreTabEditingState
(
selectedTab
.
getEditingState
(
)
)
;
}
else
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
}
private
void
saveTabEditingState
(
final
TabEditingState
editingState
)
{
mBrowserToolbar
.
saveTabEditingState
(
editingState
)
;
editingState
.
setIsBrowserSearchShown
(
mBrowserSearch
.
getUserVisibleHint
(
)
)
;
}
private
void
restoreTabEditingState
(
final
TabEditingState
editingState
)
{
mBrowserToolbar
.
restoreTabEditingState
(
editingState
)
;
if
(
editingState
.
isBrowserSearchShown
(
)
)
{
showBrowserSearch
(
)
;
}
else
{
hideBrowserSearch
(
)
;
}
}
Override
public
boolean
onKey
(
View
v
int
keyCode
KeyEvent
event
)
{
if
(
AndroidGamepadManager
.
handleKeyEvent
(
event
)
)
{
return
true
;
}
if
(
event
.
getAction
(
)
!
=
KeyEvent
.
ACTION_DOWN
)
{
if
(
mSuppressNextKeyUp
&
&
event
.
getAction
(
)
=
=
KeyEvent
.
ACTION_UP
)
{
mSuppressNextKeyUp
=
false
;
return
true
;
}
return
false
;
}
if
(
(
event
.
getSource
(
)
&
InputDevice
.
SOURCE_GAMEPAD
)
=
=
InputDevice
.
SOURCE_GAMEPAD
)
{
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_BUTTON_Y
:
if
(
mBrowserChrome
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
{
if
(
mDynamicToolbar
.
isEnabled
(
)
&
&
!
isHomePagerVisible
(
)
)
{
mDynamicToolbar
.
setVisible
(
false
VisibilityTransition
.
ANIMATE
)
;
if
(
mLayerView
!
=
null
)
{
mLayerView
.
requestFocus
(
)
;
}
}
else
{
mBrowserToolbar
.
requestFocusFromTouch
(
)
;
}
}
else
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
mBrowserToolbar
.
requestFocusFromTouch
(
)
;
}
return
true
;
case
KeyEvent
.
KEYCODE_BUTTON_L1
:
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
doBack
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_BUTTON_R1
:
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
doForward
(
)
;
return
true
;
}
}
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
event
.
isCtrlPressed
(
)
)
{
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_LEFT_BRACKET
:
tab
.
doBack
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_RIGHT_BRACKET
:
tab
.
doForward
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_R
:
tab
.
doReload
(
event
.
isShiftPressed
(
)
)
;
return
true
;
case
KeyEvent
.
KEYCODE_PERIOD
:
tab
.
doStop
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_T
:
int
flags
=
Tabs
.
LOADURL_START_EDITING
;
if
(
tab
.
isPrivate
(
)
)
{
flags
|
=
Tabs
.
LOADURL_PRIVATE
;
}
addTab
(
flags
)
;
return
true
;
case
KeyEvent
.
KEYCODE_N
:
addTab
(
Tabs
.
LOADURL_START_EDITING
)
;
return
true
;
case
KeyEvent
.
KEYCODE_P
:
if
(
event
.
isShiftPressed
(
)
)
{
addTab
(
Tabs
.
LOADURL_PRIVATE
|
Tabs
.
LOADURL_START_EDITING
)
;
return
true
;
}
break
;
case
KeyEvent
.
KEYCODE_W
:
Tabs
.
getInstance
(
)
.
closeTab
(
tab
)
;
return
true
;
case
KeyEvent
.
KEYCODE_F
:
mFindInPageBar
.
show
(
mBrowserToolbar
.
isPrivateMode
(
)
)
;
return
true
;
}
}
return
false
;
}
private
Runnable
mCheckLongPress
;
{
if
(
!
Versions
.
preN
)
{
mCheckLongPress
=
new
Runnable
(
)
{
public
void
run
(
)
{
handleBackLongPress
(
)
;
}
}
;
}
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
if
(
!
Versions
.
preN
&
&
keyCode
=
=
KeyEvent
.
KEYCODE_BACK
)
{
ThreadUtils
.
getUiHandler
(
)
.
removeCallbacks
(
mCheckLongPress
)
;
ThreadUtils
.
getUiHandler
(
)
.
postDelayed
(
mCheckLongPress
ViewConfiguration
.
getLongPressTimeout
(
)
)
;
}
if
(
!
mBrowserToolbar
.
isEditing
(
)
&
&
onKey
(
null
keyCode
event
)
)
{
return
true
;
}
return
super
.
onKeyDown
(
keyCode
event
)
;
}
Override
public
boolean
onKeyUp
(
int
keyCode
KeyEvent
event
)
{
if
(
!
Versions
.
preN
&
&
keyCode
=
=
KeyEvent
.
KEYCODE_BACK
)
{
ThreadUtils
.
getUiHandler
(
)
.
removeCallbacks
(
mCheckLongPress
)
;
}
if
(
AndroidGamepadManager
.
handleKeyEvent
(
event
)
)
{
return
true
;
}
return
super
.
onKeyUp
(
keyCode
event
)
;
}
Override
public
void
onCreate
(
Bundle
savedInstanceState
)
{
final
Context
appContext
=
getApplicationContext
(
)
;
showSplashScreen
=
true
;
safeStartingIntent
=
new
SafeIntent
(
getIntent
(
)
)
;
isInAutomation
=
IntentUtils
.
getIsInAutomationFromEnvironment
(
safeStartingIntent
)
;
GeckoProfile
.
setIntentArgs
(
safeStartingIntent
.
getStringExtra
(
"
args
"
)
)
;
if
(
!
isInAutomation
&
&
AppConstants
.
MOZ_ANDROID_DOWNLOAD_CONTENT_SERVICE
)
{
DlcStudyService
.
enqueueServiceWork
(
this
)
;
}
final
GeckoApplication
app
=
(
GeckoApplication
)
getApplication
(
)
;
app
.
prepareLightweightTheme
(
)
;
super
.
onCreate
(
savedInstanceState
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
mOnboardingHelper
=
new
OnboardingHelper
(
this
safeStartingIntent
)
;
initSwitchboardAndMma
(
this
safeStartingIntent
isInAutomation
)
;
initTelemetryUploader
(
isInAutomation
)
;
mBrowserChrome
=
(
ViewGroup
)
findViewById
(
R
.
id
.
browser_chrome
)
;
mActionBarFlipper
=
(
ViewFlipper
)
findViewById
(
R
.
id
.
browser_actionbar
)
;
mActionBar
=
(
ActionModeCompatView
)
findViewById
(
R
.
id
.
actionbar
)
;
mBrowserToolbar
=
(
BrowserToolbar
)
findViewById
(
R
.
id
.
browser_toolbar
)
;
mBrowserToolbar
.
setTouchEventInterceptor
(
new
TouchEventInterceptor
(
)
{
Override
public
boolean
onInterceptTouchEvent
(
View
view
MotionEvent
event
)
{
mTextSelection
.
dismiss
(
)
;
return
false
;
}
Override
public
boolean
onTouch
(
View
v
MotionEvent
event
)
{
return
false
;
}
}
)
;
app
.
getLightweightTheme
(
)
.
addListener
(
this
)
;
mProgressView
=
(
AnimatedProgressBar
)
findViewById
(
R
.
id
.
page_progress
)
;
mDynamicToolbar
.
setLayerView
(
mLayerView
)
;
mProgressView
.
setDynamicToolbar
(
mDynamicToolbar
)
;
mBrowserToolbar
.
setProgressBar
(
mProgressView
)
;
tabHistoryController
=
new
TabHistoryController
(
new
OnShowTabHistory
(
)
{
Override
public
void
onShowHistory
(
final
List
<
TabHistoryPage
>
historyPageList
final
int
toIndex
final
boolean
isPrivate
)
{
runOnUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
BrowserApp
.
this
.
isFinishing
(
)
)
{
return
;
}
final
TabHistoryFragment
fragment
=
TabHistoryFragment
.
newInstance
(
historyPageList
toIndex
isPrivate
)
;
final
FragmentManager
fragmentManager
=
getSupportFragmentManager
(
)
;
GeckoAppShell
.
getHapticFeedbackDelegate
(
)
.
performHapticFeedback
(
HapticFeedbackConstants
.
LONG_PRESS
)
;
fragment
.
show
(
R
.
id
.
tab_history_panel
fragmentManager
.
beginTransaction
(
)
TAB_HISTORY_FRAGMENT_TAG
)
;
}
}
)
;
}
}
)
;
mBrowserToolbar
.
setTabHistoryController
(
tabHistoryController
)
;
final
String
action
=
safeStartingIntent
.
getAction
(
)
;
if
(
Intent
.
ACTION_VIEW
.
equals
(
action
)
)
{
mBrowserToolbar
.
setTitle
(
safeStartingIntent
.
getDataString
(
)
)
;
showTabQueuePromptIfApplicable
(
safeStartingIntent
)
;
}
else
if
(
ACTION_VIEW_MULTIPLE
.
equals
(
action
)
&
&
savedInstanceState
=
=
null
)
{
openMultipleTabsFromIntent
(
safeStartingIntent
)
;
}
else
if
(
GuestSession
.
NOTIFICATION_INTENT
.
equals
(
action
)
)
{
GuestSession
.
onNotificationIntentReceived
(
this
)
;
}
else
if
(
TabQueueHelper
.
LOAD_URLS_ACTION
.
equals
(
action
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
NOTIFICATION
"
tabqueue
"
)
;
}
else
if
(
NotificationHelper
.
HELPER_BROADCAST_ACTION
.
equals
(
action
)
)
{
NotificationHelper
.
getInstance
(
getApplicationContext
(
)
)
.
handleNotificationIntent
(
safeStartingIntent
)
;
}
if
(
HardwareUtils
.
isTablet
(
)
)
{
mTabStrip
=
(
TabStripInterface
)
(
(
(
ViewStub
)
findViewById
(
R
.
id
.
tablet_tab_strip
)
)
.
inflate
(
)
)
;
}
(
(
GeckoApp
.
MainLayout
)
mMainLayout
)
.
setTouchEventInterceptor
(
new
HideOnTouchListener
(
)
)
;
(
(
GeckoApp
.
MainLayout
)
mMainLayout
)
.
setMotionEventInterceptor
(
new
MotionEventInterceptor
(
)
{
Override
public
boolean
onInterceptMotionEvent
(
View
view
MotionEvent
event
)
{
if
(
mLayerView
!
=
null
&
&
!
mLayerView
.
hasFocus
(
)
&
&
GamepadUtils
.
isPanningControl
(
event
)
)
{
if
(
mHomeScreen
=
=
null
)
{
return
false
;
}
if
(
isHomePagerVisible
(
)
)
{
mLayerView
.
requestFocus
(
)
;
}
else
{
mHomeScreen
.
requestFocus
(
)
;
}
}
return
false
;
}
}
)
;
mHomeScreenContainer
=
(
ViewGroup
)
findViewById
(
R
.
id
.
home_screen_container
)
;
mBrowserSearchContainer
=
findViewById
(
R
.
id
.
search_container
)
;
mBrowserSearch
=
(
BrowserSearch
)
getSupportFragmentManager
(
)
.
findFragmentByTag
(
BROWSER_SEARCH_TAG
)
;
if
(
mBrowserSearch
=
=
null
)
{
mBrowserSearch
=
BrowserSearch
.
newInstance
(
)
;
mBrowserSearch
.
setUserVisibleHint
(
false
)
;
}
setBrowserToolbarListeners
(
)
;
mPipController
=
new
PictureInPictureController
(
this
)
;
mFindInPageBar
=
(
FindInPageBar
)
findViewById
(
R
.
id
.
find_in_page
)
;
mMediaCastingBar
=
(
MediaCastingBar
)
findViewById
(
R
.
id
.
media_casting
)
;
doorhangerOverlay
=
findViewById
(
R
.
id
.
doorhanger_overlay
)
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
this
"
Search
:
Keyword
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
GeckoView
:
AccessibilityEnabled
"
"
Menu
:
Open
"
"
LightweightTheme
:
Update
"
"
Tab
:
Added
"
"
CharEncoding
:
Data
"
"
CharEncoding
:
State
"
"
Settings
:
Show
"
"
Updater
:
Launch
"
"
Sanitize
:
Finished
"
"
Sanitize
:
OpenTabs
"
"
NotificationSettings
:
FeatureTipsStatusUpdated
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
registerBackgroundThreadListener
(
this
"
Experiments
:
GetActive
"
"
Experiments
:
SetOverride
"
"
Experiments
:
ClearOverride
"
"
Favicon
:
Request
"
"
Feedback
:
MaybeLater
"
"
Sanitize
:
ClearHistory
"
"
Sanitize
:
ClearSyncedTabs
"
"
Telemetry
:
Gather
"
"
Download
:
AndroidDownloadManager
"
"
Website
:
AppInstalled
"
"
Website
:
AppInstallFailed
"
"
Website
:
Metadata
"
null
)
;
getAppEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
Prompt
:
ShowTop
"
)
;
final
GeckoProfile
profile
=
getProfile
(
)
;
final
Distribution
distribution
=
Distribution
.
init
(
getApplicationContext
(
)
)
;
distribution
.
addOnDistributionReadyCallback
(
new
DistributionStoreCallback
(
getApplicationContext
(
)
profile
.
getName
(
)
)
)
;
mSearchEngineManager
=
new
SearchEngineManager
(
this
distribution
)
;
final
SuggestedSites
suggestedSites
=
new
SuggestedSites
(
appContext
distribution
)
;
final
BrowserDB
db
=
BrowserDB
.
from
(
profile
)
;
db
.
setSuggestedSites
(
suggestedSites
)
;
mSharedPreferencesHelper
=
new
SharedPreferencesHelper
(
appContext
)
;
mReadingListHelper
=
new
ReadingListHelper
(
appContext
profile
)
;
mAccountsHelper
=
new
AccountsHelper
(
appContext
profile
)
;
mExtensionPermissionsHelper
=
new
ExtensionPermissionsHelper
(
this
)
;
if
(
AppConstants
.
MOZ_ANDROID_BEAM
)
{
NfcAdapter
nfc
=
NfcAdapter
.
getDefaultAdapter
(
this
)
;
if
(
nfc
!
=
null
)
{
nfc
.
setNdefPushMessageCallback
(
new
NfcAdapter
.
CreateNdefMessageCallback
(
)
{
Override
public
NdefMessage
createNdefMessage
(
NfcEvent
event
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
|
|
tab
.
isPrivate
(
)
)
{
return
null
;
}
return
new
NdefMessage
(
new
NdefRecord
[
]
{
NdefRecord
.
createUri
(
tab
.
getURL
(
)
)
}
)
;
}
}
this
)
;
}
}
if
(
savedInstanceState
!
=
null
)
{
mDynamicToolbar
.
onRestoreInstanceState
(
savedInstanceState
)
;
mHomeScreenContainer
.
setPadding
(
0
savedInstanceState
.
getInt
(
STATE_ABOUT_HOME_TOP_PADDING
)
0
0
)
;
}
mDynamicToolbar
.
setEnabledChangedListener
(
new
DynamicToolbar
.
OnEnabledChangedListener
(
)
{
Override
public
void
onEnabledChanged
(
boolean
enabled
)
{
setDynamicToolbarEnabled
(
enabled
)
;
}
}
)
;
IconDirectoryEntry
.
setMaxBPP
(
GeckoAppShell
.
getScreenDepth
(
)
)
;
if
(
!
AppConstants
.
RELEASE_OR_BETA
&
&
UpdateServiceHelper
.
isUpdaterEnabled
(
this
)
)
{
Permissions
.
from
(
this
)
.
withPermissions
(
Manifest
.
permission
.
WRITE_EXTERNAL_STORAGE
)
.
doNotPrompt
(
)
.
andFallback
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
showUpdaterPermissionSnackbar
(
)
;
}
}
)
.
run
(
)
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onCreate
(
this
savedInstanceState
)
;
}
final
String
installerPackageName
=
getPackageManager
(
)
.
getInstallerPackageName
(
getPackageName
(
)
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
TelemetryContract
.
Method
.
SYSTEM
"
installer_
"
+
installerPackageName
)
;
}
private
void
initSwitchboardAndMma
(
final
Context
context
final
SafeIntent
intent
final
boolean
isInAutomation
)
{
if
(
isInAutomation
)
{
Log
.
d
(
LOGTAG
"
Switchboard
disabled
-
in
automation
"
)
;
return
;
}
else
if
(
!
AppConstants
.
MOZ_SWITCHBOARD
)
{
Log
.
d
(
LOGTAG
"
Switchboard
compile
-
time
disabled
"
)
;
return
;
}
final
String
serverExtra
=
intent
.
getStringExtra
(
INTENT_KEY_SWITCHBOARD_SERVER
)
;
final
String
serverUrl
=
TextUtils
.
isEmpty
(
serverExtra
)
?
SWITCHBOARD_SERVER
:
serverExtra
;
final
SwitchBoard
.
ConfigStatusListener
configStatuslistener
=
mOnboardingHelper
;
final
MmaDelegate
.
MmaVariablesChangedListener
variablesChangedListener
=
mOnboardingHelper
;
new
AsyncConfigLoader
(
context
serverUrl
configStatuslistener
)
{
Override
protected
Void
doInBackground
(
Void
.
.
.
params
)
{
super
.
doInBackground
(
params
)
;
SwitchBoard
.
loadConfig
(
context
serverUrl
configStatuslistener
)
;
if
(
GeckoPreferences
.
isMmaAvailableAndEnabled
(
context
)
)
{
MmaDelegate
.
init
(
BrowserApp
.
this
variablesChangedListener
)
;
}
return
null
;
}
}
.
execute
(
)
;
}
private
static
void
initTelemetryUploader
(
final
boolean
isInAutomation
)
{
TelemetryUploadService
.
setDisabled
(
isInAutomation
)
;
}
private
void
showUpdaterPermissionSnackbar
(
)
{
SnackbarBuilder
.
SnackbarCallback
allowCallback
=
new
SnackbarBuilder
.
SnackbarCallback
(
)
{
Override
public
void
onClick
(
View
v
)
{
Permissions
.
from
(
BrowserApp
.
this
)
.
withPermissions
(
Manifest
.
permission
.
WRITE_EXTERNAL_STORAGE
)
.
run
(
)
;
}
}
;
SnackbarBuilder
.
builder
(
this
)
.
message
(
R
.
string
.
updater_permission_text
)
.
duration
(
Snackbar
.
LENGTH_INDEFINITE
)
.
action
(
R
.
string
.
updater_permission_allow
)
.
callback
(
allowCallback
)
.
buildAndShow
(
)
;
}
private
Class
<
?
>
getMediaPlayerManager
(
)
{
if
(
AppConstants
.
MOZ_MEDIA_PLAYER
)
{
try
{
return
Class
.
forName
(
"
org
.
mozilla
.
gecko
.
MediaPlayerManager
"
)
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
No
native
casting
support
"
ex
)
;
}
}
return
null
;
}
Override
public
void
onBackPressed
(
)
{
if
(
mTextSelection
.
dismiss
(
)
)
{
return
;
}
if
(
getSupportFragmentManager
(
)
.
getBackStackEntryCount
(
)
>
0
)
{
super
.
onBackPressed
(
)
;
return
;
}
if
(
mBrowserToolbar
.
onBackPressed
(
)
)
{
return
;
}
if
(
mActionMode
!
=
null
)
{
endActionMode
(
)
;
return
;
}
if
(
hideFirstrunPager
(
TelemetryContract
.
Method
.
BACK
)
)
{
return
;
}
super
.
onBackPressed
(
)
;
}
Override
public
void
onAttachedToWindow
(
)
{
final
SafeIntent
intent
=
new
SafeIntent
(
getIntent
(
)
)
;
if
(
!
IntentUtils
.
getIsInAutomationFromEnvironment
(
intent
)
)
{
mOnboardingHelper
.
checkFirstRun
(
)
;
}
}
Override
protected
void
processTabQueue
(
)
{
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
mInitialized
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
TabQueueHelper
.
shouldOpenTabQueueUrls
(
BrowserApp
.
this
)
)
{
openQueuedTabs
(
)
;
}
}
}
)
;
}
}
Override
protected
void
openQueuedTabs
(
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
int
queuedTabCount
=
TabQueueHelper
.
getTabQueueLength
(
BrowserApp
.
this
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_TABQUEUE_QUEUESIZE
"
queuedTabCount
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
INTENT
"
tabqueue
-
delayed
"
)
;
TabQueueHelper
.
openQueuedUrls
(
BrowserApp
.
this
getProfile
(
)
TabQueueHelper
.
FILE_NAME
false
)
;
if
(
queuedTabCount
>
1
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
showNormalTabs
(
)
;
}
}
)
;
}
}
private
void
openMultipleTabsFromIntent
(
final
SafeIntent
intent
)
{
final
List
<
String
>
urls
=
intent
.
getStringArrayListExtra
(
"
urls
"
)
;
if
(
urls
!
=
null
)
{
openUrls
(
urls
)
;
}
}
Override
public
void
onResume
(
)
{
super
.
onResume
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
if
(
!
mHasResumed
)
{
getAppEventDispatcher
(
)
.
unregisterUiThreadListener
(
this
"
Prompt
:
ShowTop
"
)
;
mHasResumed
=
true
;
}
processTabQueue
(
)
;
for
(
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onResume
(
this
)
;
}
}
Override
public
void
onPause
(
)
{
super
.
onPause
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
if
(
mHasResumed
)
{
getAppEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
Prompt
:
ShowTop
"
)
;
mHasResumed
=
false
;
}
for
(
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onPause
(
this
)
;
}
}
Override
protected
void
onUserLeaveHint
(
)
{
super
.
onUserLeaveHint
(
)
;
try
{
mPipController
.
tryEnteringPictureInPictureMode
(
)
;
}
catch
(
IllegalStateException
exception
)
{
Log
.
e
(
LOGTAG
"
Cannot
enter
in
Picture
In
Picture
mode
:
\
n
"
+
exception
.
getMessage
(
)
)
;
setRequestedOrientationForCurrentActivity
(
ActivityInfo
.
SCREEN_ORIENTATION_FULL_SENSOR
)
;
}
}
Override
public
void
onPictureInPictureModeChanged
(
boolean
isInPictureInPictureMode
Configuration
newConfig
)
{
super
.
onPictureInPictureModeChanged
(
isInPictureInPictureMode
newConfig
)
;
if
(
!
isInPictureInPictureMode
)
{
mPipController
.
cleanResources
(
)
;
if
(
startingIntentAfterPip
!
=
null
)
{
getApplication
(
)
.
startActivity
(
startingIntentAfterPip
)
;
startingIntentAfterPip
=
null
;
}
else
{
final
boolean
userReturnedToFullApp
=
!
isApplicationInBackground
(
)
;
if
(
userReturnedToFullApp
)
{
ActivityUtils
.
setFullScreen
(
this
true
)
;
}
else
{
setRequestedOrientationForCurrentActivity
(
ActivityInfo
.
SCREEN_ORIENTATION_FULL_SENSOR
)
;
}
}
}
}
Override
public
void
onRestart
(
)
{
super
.
onRestart
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onRestart
(
this
)
;
}
}
Override
public
void
onStart
(
)
{
super
.
onStart
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
GeckoProfile
profile
=
getProfile
(
)
;
if
(
profile
.
inGuestMode
(
)
)
{
GuestSession
.
showNotification
(
BrowserApp
.
this
)
;
}
else
{
GuestSession
.
hideNotification
(
BrowserApp
.
this
)
;
}
final
SharedPreferences
sharedPrefs
=
GeckoSharedPrefs
.
forProfileName
(
BrowserApp
.
this
profile
.
getName
(
)
)
;
FileCleanupController
.
startIfReady
(
BrowserApp
.
this
sharedPrefs
profile
.
getDir
(
)
.
getAbsolutePath
(
)
)
;
}
}
)
;
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onStart
(
this
)
;
}
MmaDelegate
.
track
(
MmaDelegate
.
RESUMED_FROM_BACKGROUND
)
;
MmaDelegate
.
notifyDefaultBrowserStatus
(
this
)
;
}
Override
public
void
onStop
(
)
{
super
.
onStop
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
if
(
mPipController
.
isInPipMode
(
)
)
{
moveTaskToBack
(
true
)
;
mPipController
.
cleanResources
(
)
;
}
GuestSession
.
hideNotification
(
this
)
;
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onStop
(
this
)
;
}
onAfterStop
(
)
;
}
Override
public
void
onWindowFocusChanged
(
boolean
hasFocus
)
{
super
.
onWindowFocusChanged
(
hasFocus
)
;
if
(
hasFocus
)
{
mBrowserToolbar
.
onParentFocus
(
)
;
}
}
private
void
setBrowserToolbarListeners
(
)
{
mBrowserToolbar
.
setOnActivateListener
(
new
BrowserToolbar
.
OnActivateListener
(
)
{
Override
public
void
onActivate
(
)
{
enterEditingMode
(
)
;
}
}
)
;
mBrowserToolbar
.
setOnCommitListener
(
new
BrowserToolbar
.
OnCommitListener
(
)
{
Override
public
void
onCommitByKey
(
)
{
if
(
commitEditingMode
(
)
)
{
mSuppressNextKeyUp
=
true
;
}
}
}
)
;
mBrowserToolbar
.
setOnDismissListener
(
new
BrowserToolbar
.
OnDismissListener
(
)
{
Override
public
void
onDismiss
(
)
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
}
)
;
if
(
!
isInAutomation
)
{
mBrowserToolbar
.
setOnFilterListener
(
new
BrowserToolbar
.
OnFilterListener
(
)
{
Override
public
void
onFilter
(
String
searchText
AutocompleteHandler
handler
)
{
filterEditingMode
(
searchText
handler
)
;
}
}
)
;
}
mBrowserToolbar
.
setOnFocusChangeListener
(
new
View
.
OnFocusChangeListener
(
)
{
Override
public
void
onFocusChange
(
View
v
boolean
hasFocus
)
{
if
(
isHomePagerVisible
(
)
)
{
mHomeScreen
.
onToolbarFocusChange
(
hasFocus
)
;
}
}
}
)
;
mBrowserToolbar
.
setOnStartEditingListener
(
new
BrowserToolbar
.
OnStartEditingListener
(
)
{
Override
public
void
onStartEditing
(
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
selectedTab
.
setIsEditing
(
true
)
;
}
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
disable
(
)
;
}
}
}
)
;
mBrowserToolbar
.
setOnStopEditingListener
(
new
BrowserToolbar
.
OnStopEditingListener
(
)
{
Override
public
void
onStopEditing
(
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
selectedTab
.
setIsEditing
(
false
)
;
}
selectTargetTabForEditingMode
(
)
;
hideBrowserSearch
(
)
;
hideHomePager
(
)
;
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
enable
(
)
;
}
}
}
)
;
mBrowserToolbar
.
setOnKeyListener
(
this
)
;
}
private
void
setDynamicToolbarEnabled
(
boolean
enabled
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mLayerView
!
=
null
)
{
if
(
enabled
)
{
mDynamicToolbar
.
setPinned
(
false
PinReason
.
DISABLED
)
;
}
else
{
mDynamicToolbar
.
setPinned
(
true
PinReason
.
DISABLED
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
}
refreshToolbarHeight
(
)
;
}
private
static
boolean
isAboutHome
(
final
Tab
tab
)
{
return
AboutPages
.
isAboutHome
(
tab
.
getURL
(
)
)
;
}
Override
public
boolean
onSearchRequested
(
)
{
enterEditingMode
(
)
;
return
true
;
}
Override
public
boolean
onContextItemSelected
(
MenuItem
item
)
{
final
int
itemId
=
item
.
getItemId
(
)
;
if
(
itemId
=
=
R
.
id
.
pasteandgo
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
CONTEXT_MENU
)
;
String
text
=
Clipboard
.
getText
(
this
)
;
if
(
!
TextUtils
.
isEmpty
(
text
)
)
{
loadUrlOrKeywordSearch
(
text
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
CONTEXT_MENU
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
"
pasteandgo
"
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
paste
)
{
String
text
=
Clipboard
.
getText
(
this
)
;
if
(
!
TextUtils
.
isEmpty
(
text
)
)
{
enterEditingMode
(
text
)
;
showBrowserSearch
(
)
;
mBrowserSearch
.
filter
(
text
null
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
"
paste
"
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
subscribe
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
tab
.
hasFeeds
(
)
)
{
final
GeckoBundle
args
=
new
GeckoBundle
(
1
)
;
args
.
putInt
(
"
tabId
"
tab
.
getId
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Feeds
:
Subscribe
"
args
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
add_search_engine
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
tab
.
hasOpenSearch
(
)
)
{
final
GeckoBundle
args
=
new
GeckoBundle
(
1
)
;
args
.
putInt
(
"
tabId
"
tab
.
getId
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
SearchEngines
:
Add
"
args
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
copyurl
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
String
url
=
ReaderModeUtils
.
stripAboutReaderUrl
(
tab
.
getURL
(
)
)
;
if
(
url
!
=
null
)
{
Clipboard
.
setText
(
this
url
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
"
copyurl
"
)
;
}
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
pin_to_top_sites
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
ActivityStreamTelemetry
.
Extras
.
Builder
telemetryExtraBuilder
=
ActivityStreamTelemetry
.
Extras
.
builder
(
)
;
final
BrowserDB
db
=
BrowserDB
.
from
(
BrowserApp
.
this
)
;
final
ContentResolver
cr
=
getContentResolver
(
)
;
final
String
url
=
selectedTab
.
getURL
(
)
;
final
StringRes
int
snackbarText
;
if
(
!
db
.
isPinnedForAS
(
cr
url
)
)
{
db
.
pinSiteForAS
(
getContentResolver
(
)
url
selectedTab
.
getTitle
(
)
)
;
snackbarText
=
R
.
string
.
pinned_page_to_top_sites
;
telemetryExtraBuilder
.
set
(
ActivityStreamTelemetry
.
Contract
.
ITEM
ActivityStreamTelemetry
.
Contract
.
ITEM_PIN
)
;
}
else
{
db
.
unpinSiteForAS
(
getContentResolver
(
)
url
)
;
snackbarText
=
R
.
string
.
unpinned_page_from_top_sites
;
telemetryExtraBuilder
.
set
(
ActivityStreamTelemetry
.
Contract
.
ITEM
ActivityStreamTelemetry
.
Contract
.
ITEM_UNPIN
)
;
}
SnackbarBuilder
.
builder
(
BrowserApp
.
this
)
.
message
(
snackbarText
)
.
buildAndShow
(
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
MENU
telemetryExtraBuilder
.
build
(
)
)
;
}
}
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
add_to_launcher
)
{
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
)
{
return
true
;
}
final
String
url
=
tab
.
getURL
(
)
;
final
String
title
=
tab
.
getDisplayTitle
(
)
;
if
(
url
=
=
null
|
|
title
=
=
null
)
{
return
true
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoApplication
.
createBrowserShortcut
(
title
url
)
;
}
}
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
getResources
(
)
.
getResourceEntryName
(
itemId
)
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
set_as_homepage
)
{
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
)
{
return
true
;
}
final
String
url
=
tab
.
getURL
(
)
;
if
(
url
=
=
null
)
{
return
true
;
}
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putString
(
GeckoPreferences
.
PREFS_HOMEPAGE
url
)
;
editor
.
apply
(
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
getResources
(
)
.
getResourceEntryName
(
itemId
)
)
;
return
true
;
}
return
false
;
}
Override
public
void
onDestroy
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onDestroy
(
)
;
return
;
}
if
(
mProgressView
!
=
null
)
{
mProgressView
.
setDynamicToolbar
(
null
)
;
}
mDynamicToolbar
.
destroy
(
)
;
final
GeckoApplication
app
=
(
GeckoApplication
)
getApplication
(
)
;
app
.
getLightweightTheme
(
)
.
removeListener
(
this
)
;
AddonUICache
.
getInstance
(
)
.
onDestroyOptionsMenu
(
)
;
if
(
mBrowserToolbar
!
=
null
)
mBrowserToolbar
.
onDestroy
(
)
;
if
(
mFindInPageBar
!
=
null
)
{
mFindInPageBar
.
onDestroy
(
)
;
mFindInPageBar
=
null
;
}
if
(
mMediaCastingBar
!
=
null
)
{
mMediaCastingBar
.
onDestroy
(
)
;
mMediaCastingBar
=
null
;
}
if
(
mSharedPreferencesHelper
!
=
null
)
{
mSharedPreferencesHelper
.
uninit
(
)
;
mSharedPreferencesHelper
=
null
;
}
if
(
mReadingListHelper
!
=
null
)
{
mReadingListHelper
.
uninit
(
)
;
mReadingListHelper
=
null
;
}
if
(
mAccountsHelper
!
=
null
)
{
mAccountsHelper
.
uninit
(
)
;
mAccountsHelper
=
null
;
}
if
(
mExtensionPermissionsHelper
!
=
null
)
{
mExtensionPermissionsHelper
.
uninit
(
)
;
mExtensionPermissionsHelper
=
null
;
}
mSearchEngineManager
.
unregisterListeners
(
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
this
"
Search
:
Keyword
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
"
GeckoView
:
AccessibilityEnabled
"
"
Menu
:
Open
"
"
LightweightTheme
:
Update
"
"
Tab
:
Added
"
"
CharEncoding
:
Data
"
"
CharEncoding
:
State
"
"
Settings
:
Show
"
"
Updater
:
Launch
"
"
Sanitize
:
Finished
"
"
Sanitize
:
OpenTabs
"
"
NotificationSettings
:
FeatureTipsStatusUpdated
"
null
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterBackgroundThreadListener
(
this
"
Experiments
:
GetActive
"
"
Experiments
:
SetOverride
"
"
Experiments
:
ClearOverride
"
"
Favicon
:
Request
"
"
Feedback
:
MaybeLater
"
"
Sanitize
:
ClearHistory
"
"
Sanitize
:
ClearSyncedTabs
"
"
Telemetry
:
Gather
"
"
Download
:
AndroidDownloadManager
"
"
Website
:
AppInstalled
"
"
Website
:
AppInstallFailed
"
"
Website
:
Metadata
"
null
)
;
getAppEventDispatcher
(
)
.
unregisterUiThreadListener
(
this
"
Prompt
:
ShowTop
"
)
;
if
(
AppConstants
.
MOZ_ANDROID_BEAM
)
{
NfcAdapter
nfc
=
NfcAdapter
.
getDefaultAdapter
(
this
)
;
if
(
nfc
!
=
null
)
{
nfc
.
setNdefPushMessageCallback
(
null
this
)
;
}
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onDestroy
(
this
)
;
}
deleteTempFiles
(
getApplicationContext
(
)
)
;
NotificationHelper
.
destroy
(
)
;
GeckoNetworkManager
.
destroy
(
)
;
MmaDelegate
.
flushResources
(
this
)
;
super
.
onDestroy
(
)
;
}
Override
protected
void
initializeChrome
(
)
{
super
.
initializeChrome
(
)
;
mDoorHangerPopup
.
setAnchor
(
mBrowserToolbar
.
getDoorHangerAnchor
(
)
)
;
mDoorHangerPopup
.
setOnVisibilityChangeListener
(
this
)
;
if
(
mLayerView
!
=
null
)
{
mLayerView
.
getDynamicToolbarAnimator
(
)
.
setToolbarChromeProxy
(
this
)
;
}
setDynamicToolbarEnabled
(
mDynamicToolbar
.
isEnabled
(
)
)
;
mLayerView
.
setOnKeyListener
(
this
)
;
if
(
HardwareUtils
.
isTablet
(
)
)
{
onCreatePanelMenu
(
Window
.
FEATURE_OPTIONS_PANEL
null
)
;
invalidateOptionsMenu
(
)
;
}
}
Override
public
void
onDoorHangerShow
(
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
super
.
onDoorHangerShow
(
)
;
}
Override
public
Bitmap
getBitmapOfToolbarChrome
(
)
{
if
(
mBrowserChrome
=
=
null
)
{
return
null
;
}
Bitmap
bm
=
Bitmap
.
createBitmap
(
mBrowserChrome
.
getWidth
(
)
mBrowserChrome
.
getHeight
(
)
Bitmap
.
Config
.
ARGB_8888
)
;
Canvas
canvas
=
new
Canvas
(
bm
)
;
Drawable
bgDrawable
=
mBrowserChrome
.
getBackground
(
)
;
if
(
bgDrawable
!
=
null
)
{
bgDrawable
.
draw
(
canvas
)
;
}
else
{
canvas
.
drawColor
(
Color
.
WHITE
)
;
}
mBrowserChrome
.
draw
(
canvas
)
;
return
bm
;
}
Override
public
boolean
isToolbarChromeVisible
(
)
{
return
mBrowserChrome
.
getVisibility
(
)
=
=
View
.
VISIBLE
;
}
Override
public
void
toggleToolbarChrome
(
final
boolean
aShow
)
{
if
(
aShow
)
{
mBrowserChrome
.
setVisibility
(
View
.
VISIBLE
)
;
}
else
{
mBrowserChrome
.
setVisibility
(
View
.
INVISIBLE
)
;
}
}
public
void
refreshToolbarHeight
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
int
height
=
0
;
if
(
mBrowserChrome
!
=
null
)
{
height
=
mBrowserChrome
.
getHeight
(
)
;
}
mHomeScreenContainer
.
setPadding
(
0
height
0
0
)
;
if
(
mLayerView
!
=
null
&
&
height
!
=
mToolbarHeight
)
{
mToolbarHeight
=
height
;
mLayerView
.
getDynamicToolbarAnimator
(
)
.
setMaxToolbarHeight
(
height
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
}
Override
void
toggleChrome
(
final
boolean
aShow
)
{
if
(
mDynamicToolbar
!
=
null
)
{
mDynamicToolbar
.
setVisible
(
aShow
VisibilityTransition
.
IMMEDIATE
)
;
}
super
.
toggleChrome
(
aShow
)
;
}
Override
void
focusChrome
(
)
{
if
(
mDynamicToolbar
!
=
null
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
mActionBarFlipper
.
requestFocusFromTouch
(
)
;
super
.
focusChrome
(
)
;
}
Override
public
void
refreshChrome
(
)
{
invalidateOptionsMenu
(
)
;
if
(
mTabsPanel
!
=
null
)
{
mTabsPanel
.
refresh
(
)
;
}
if
(
mTabStrip
!
=
null
)
{
mTabStrip
.
refresh
(
)
;
}
mBrowserToolbar
.
refresh
(
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
switch
(
event
)
{
case
"
Gecko
:
Ready
"
:
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
Gecko
:
DelayedStartup
"
)
;
super
.
handleMessage
(
event
message
callback
)
;
final
Menu
menu
=
mMenu
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
menu
!
=
null
)
{
menu
.
findItem
(
R
.
id
.
settings
)
.
setEnabled
(
true
)
;
menu
.
findItem
(
R
.
id
.
help
)
.
setEnabled
(
true
)
;
}
}
}
)
;
if
(
AppConstants
.
MOZ_DATA_REPORTING
&
&
Restrictions
.
isAllowed
(
this
Restrictable
.
DATA_CHOICES
)
)
{
DataReportingNotification
.
checkAndNotifyPolicy
(
this
)
;
}
break
;
case
"
Gecko
:
DelayedStartup
"
:
EventDispatcher
.
getInstance
(
)
.
unregisterUiThreadListener
(
this
"
Gecko
:
DelayedStartup
"
)
;
ensureTabsPanelExists
(
)
;
if
(
AppConstants
.
MOZ_MEDIA_PLAYER
)
{
final
Class
<
?
>
mediaManagerClass
=
getMediaPlayerManager
(
)
;
if
(
mediaManagerClass
!
=
null
)
{
try
{
final
String
tag
=
"
"
;
mediaManagerClass
.
getDeclaredField
(
"
MEDIA_PLAYER_TAG
"
)
.
get
(
tag
)
;
Log
.
i
(
LOGTAG
"
Found
tag
"
+
tag
)
;
final
Fragment
frag
=
getSupportFragmentManager
(
)
.
findFragmentByTag
(
tag
)
;
if
(
frag
=
=
null
)
{
final
Method
getInstance
=
mediaManagerClass
.
getMethod
(
"
getInstance
"
(
Class
[
]
)
null
)
;
final
Fragment
mpm
=
(
Fragment
)
getInstance
.
invoke
(
null
)
;
getSupportFragmentManager
(
)
.
beginTransaction
(
)
.
disallowAddToBackStack
(
)
.
add
(
mpm
tag
)
.
commit
(
)
;
}
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Error
initializing
media
manager
"
ex
)
;
}
}
}
if
(
AppConstants
.
MOZ_STUMBLER_BUILD_TIME_ENABLED
&
&
Restrictions
.
isAllowed
(
this
Restrictable
.
DATA_CHOICES
)
)
{
GeckoPreferences
.
broadcastStumblerPref
(
BrowserApp
.
this
)
;
}
if
(
AppConstants
.
MOZ_ANDROID_DOWNLOAD_CONTENT_SERVICE
&
&
!
IntentUtils
.
getIsInAutomationFromEnvironment
(
new
SafeIntent
(
getIntent
(
)
)
)
)
{
DlcSyncService
.
enqueueServiceWork
(
this
)
;
}
break
;
case
"
GeckoView
:
AccessibilityEnabled
"
:
mDynamicToolbar
.
setAccessibilityEnabled
(
message
.
getBoolean
(
"
touchEnabled
"
)
)
;
break
;
case
"
Menu
:
Open
"
:
if
(
mBrowserToolbar
.
isEditing
(
)
)
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
openOptionsMenu
(
)
;
break
;
case
"
LightweightTheme
:
Update
"
:
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
break
;
case
"
Search
:
Keyword
"
:
storeSearchQuery
(
message
.
getString
(
"
query
"
)
)
;
recordSearch
(
GeckoSharedPrefs
.
forProfile
(
this
)
message
.
getString
(
"
identifier
"
)
TelemetryContract
.
Method
.
ACTIONBAR
)
;
break
;
case
"
Prompt
:
ShowTop
"
:
Intent
bringToFrontIntent
=
new
Intent
(
)
;
bringToFrontIntent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
bringToFrontIntent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_REORDER_TO_FRONT
)
;
startActivity
(
bringToFrontIntent
)
;
break
;
case
"
Tab
:
Added
"
:
if
(
message
.
getBoolean
(
"
cancelEditMode
"
)
)
{
mTargetTabForEditingMode
=
null
;
mBrowserToolbar
.
cancelEdit
(
)
;
}
break
;
case
"
CharEncoding
:
Data
"
:
final
GeckoBundle
[
]
charsets
=
message
.
getBundleArray
(
"
charsets
"
)
;
final
int
selected
=
message
.
getInt
(
"
selected
"
)
;
final
String
[
]
titleArray
=
new
String
[
charsets
.
length
]
;
final
String
[
]
codeArray
=
new
String
[
charsets
.
length
]
;
for
(
int
i
=
0
;
i
<
charsets
.
length
;
i
+
+
)
{
final
GeckoBundle
charset
=
charsets
[
i
]
;
titleArray
[
i
]
=
charset
.
getString
(
"
title
"
)
;
codeArray
[
i
]
=
charset
.
getString
(
"
code
"
)
;
}
final
AlertDialog
.
Builder
dialogBuilder
=
new
AlertDialog
.
Builder
(
this
)
;
dialogBuilder
.
setSingleChoiceItems
(
titleArray
selected
new
AlertDialog
.
OnClickListener
(
)
{
Override
public
void
onClick
(
final
DialogInterface
dialog
final
int
which
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putString
(
"
encoding
"
codeArray
[
which
]
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
CharEncoding
:
Set
"
data
)
;
dialog
.
dismiss
(
)
;
}
}
)
;
dialogBuilder
.
setNegativeButton
(
R
.
string
.
button_cancel
new
AlertDialog
.
OnClickListener
(
)
{
Override
public
void
onClick
(
final
DialogInterface
dialog
final
int
which
)
{
dialog
.
dismiss
(
)
;
}
}
)
;
dialogBuilder
.
show
(
)
;
break
;
case
"
CharEncoding
:
State
"
:
final
boolean
visible
=
"
true
"
.
equals
(
message
.
getString
(
"
visible
"
)
)
;
GeckoPreferences
.
setCharEncodingState
(
visible
)
;
if
(
mMenu
!
=
null
)
{
mMenu
.
findItem
(
R
.
id
.
char_encoding
)
.
setVisible
(
visible
)
;
}
break
;
case
"
Experiments
:
GetActive
"
:
final
List
<
String
>
experiments
=
SwitchBoard
.
getActiveExperiments
(
this
)
;
callback
.
sendSuccess
(
experiments
.
toArray
(
new
String
[
experiments
.
size
(
)
]
)
)
;
break
;
case
"
Experiments
:
SetOverride
"
:
Experiments
.
setOverride
(
this
message
.
getString
(
"
name
"
)
message
.
getBoolean
(
"
isEnabled
"
)
)
;
break
;
case
"
Experiments
:
ClearOverride
"
:
Experiments
.
clearOverride
(
this
message
.
getString
(
"
name
"
)
)
;
break
;
case
"
Favicon
:
Request
"
:
final
String
url
=
message
.
getString
(
"
url
"
)
;
final
boolean
shouldSkipNetwork
=
message
.
getBoolean
(
"
skipNetwork
"
)
;
if
(
TextUtils
.
isEmpty
(
url
)
)
{
callback
.
sendError
(
null
)
;
break
;
}
Icons
.
with
(
this
)
.
pageUrl
(
url
)
.
privileged
(
false
)
.
skipNetworkIf
(
shouldSkipNetwork
)
.
executeCallbackOnBackgroundThread
(
)
.
build
(
)
.
execute
(
IconsHelper
.
createBase64EventCallback
(
callback
)
)
;
break
;
case
"
Feedback
:
MaybeLater
"
:
SharedPreferences
settings
=
getPreferences
(
Activity
.
MODE_PRIVATE
)
;
settings
.
edit
(
)
.
putInt
(
getPackageName
(
)
+
"
.
feedback_launch_count
"
0
)
.
apply
(
)
;
break
;
case
"
Sanitize
:
Finished
"
:
if
(
message
.
getBoolean
(
"
shutdown
"
false
)
)
{
finishAndShutdown
(
false
)
;
}
break
;
case
"
Sanitize
:
OpenTabs
"
:
Tabs
.
getInstance
(
)
.
closeAllTabs
(
)
;
callback
.
sendSuccess
(
null
)
;
break
;
case
"
Sanitize
:
ClearHistory
"
:
BrowserDB
.
from
(
getProfile
(
)
)
.
clearHistory
(
getContentResolver
(
)
message
.
getBoolean
(
"
clearSearchHistory
"
false
)
)
;
callback
.
sendSuccess
(
null
)
;
break
;
case
"
Sanitize
:
ClearSyncedTabs
"
:
FennecTabsRepository
.
deleteNonLocalClientsAndTabs
(
this
)
;
callback
.
sendSuccess
(
null
)
;
break
;
case
"
Settings
:
Show
"
:
final
Intent
settingsIntent
=
new
Intent
(
this
GeckoPreferences
.
class
)
;
final
String
resource
=
message
.
getString
(
GeckoPreferences
.
INTENT_EXTRA_RESOURCES
)
;
GeckoPreferences
.
setResourceToOpen
(
settingsIntent
resource
)
;
startActivityForResult
(
settingsIntent
ACTIVITY_REQUEST_PREFERENCES
)
;
if
(
HardwareUtils
.
IS_KINDLE_DEVICE
)
{
overridePendingTransition
(
0
0
)
;
}
break
;
case
"
Telemetry
:
Gather
"
:
final
BrowserDB
db
=
BrowserDB
.
from
(
getProfile
(
)
)
;
final
ContentResolver
cr
=
getContentResolver
(
)
;
Telemetry
.
addToHistogram
(
"
PLACES_PAGES_COUNT
"
db
.
getCount
(
cr
"
history
"
)
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_BOOKMARKS_COUNT
"
db
.
getCount
(
cr
"
bookmarks
"
)
)
;
Telemetry
.
addToHistogram
(
"
BROWSER_IS_USER_DEFAULT
"
(
isDefaultBrowser
(
Intent
.
ACTION_VIEW
)
?
1
:
0
)
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_CUSTOM_HOMEPAGE
"
(
Tabs
.
hasHomepage
(
this
)
?
1
:
0
)
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
boolean
hasCustomHomepanels
=
prefs
.
contains
(
HomeConfigPrefsBackend
.
PREFS_CONFIG_KEY
)
|
|
prefs
.
contains
(
HomeConfigPrefsBackend
.
PREFS_CONFIG_KEY_OLD
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_HOMEPANELS_CUSTOM
"
hasCustomHomepanels
?
1
:
0
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_READER_VIEW_CACHE_SIZE
"
SavedReaderViewHelper
.
getSavedReaderViewHelper
(
this
)
.
getDiskSpacedUsedKB
(
)
)
;
if
(
Versions
.
feature16Plus
)
{
Telemetry
.
addToHistogram
(
"
BROWSER_IS_ASSIST_DEFAULT
"
(
isDefaultBrowser
(
Intent
.
ACTION_ASSIST
)
?
1
:
0
)
)
;
}
Telemetry
.
addToHistogram
(
"
FENNEC_ORBOT_INSTALLED
"
ContextUtils
.
isPackageInstalled
(
this
"
org
.
torproject
.
android
"
)
?
1
:
0
)
;
break
;
case
"
Website
:
AppInstalled
"
:
final
String
name
=
message
.
getString
(
"
name
"
)
;
final
String
startUrl
=
message
.
getString
(
"
start_url
"
)
;
final
String
manifestPath
=
message
.
getString
(
"
manifest_path
"
)
;
final
String
manifestUrl
=
message
.
getString
(
"
manifest_url
"
)
;
final
LoadFaviconResult
loadIconResult
=
FaviconDecoder
.
decodeDataURI
(
this
message
.
getString
(
"
icon
"
)
)
;
if
(
loadIconResult
!
=
null
)
{
final
Bitmap
icon
=
loadIconResult
.
getBestBitmap
(
GeckoAppShell
.
getPreferredIconSize
(
)
)
;
GeckoApplication
.
createAppShortcut
(
name
startUrl
manifestPath
manifestUrl
icon
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
PAGEACTION
PwaConfirm
.
TELEMETRY_EXTRA_ADDED
)
;
}
else
{
Log
.
e
(
LOGTAG
"
Failed
to
load
icon
!
"
)
;
}
break
;
case
"
Website
:
AppInstallFailed
"
:
final
String
title
=
message
.
getString
(
"
title
"
)
;
final
String
bookmarkUrl
=
message
.
getString
(
"
url
"
)
;
GeckoApplication
.
createBrowserShortcut
(
title
bookmarkUrl
)
;
break
;
case
"
Updater
:
Launch
"
:
if
(
AppConstants
.
RELEASE_OR_BETA
)
{
Intent
intent
=
new
Intent
(
Intent
.
ACTION_VIEW
)
;
intent
.
setData
(
Uri
.
parse
(
"
market
:
/
/
details
?
id
=
"
+
getPackageName
(
)
)
)
;
startActivity
(
intent
)
;
break
;
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
FIREFOX
)
;
break
;
}
Log
.
w
(
LOGTAG
"
No
candidate
updater
found
;
ignoring
launch
request
.
"
)
;
break
;
case
"
Download
:
AndroidDownloadManager
"
:
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
String
filename
=
message
.
getString
(
"
filename
"
)
;
final
String
mimeType
=
message
.
getString
(
"
mimeType
"
)
;
final
DownloadManager
.
Request
request
=
new
DownloadManager
.
Request
(
Uri
.
parse
(
uri
)
)
;
request
.
setMimeType
(
mimeType
)
;
try
{
request
.
setDestinationInExternalPublicDir
(
Environment
.
DIRECTORY_DOWNLOADS
filename
)
;
}
catch
(
IllegalStateException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
create
download
directory
"
)
;
break
;
}
request
.
allowScanningByMediaScanner
(
)
;
request
.
setNotificationVisibility
(
DownloadManager
.
Request
.
VISIBILITY_VISIBLE_NOTIFY_COMPLETED
)
;
request
.
addRequestHeader
(
"
User
-
Agent
"
HardwareUtils
.
isTablet
(
)
?
AppConstants
.
USER_AGENT_FENNEC_TABLET
:
AppConstants
.
USER_AGENT_FENNEC_MOBILE
)
;
try
{
DownloadManager
manager
=
(
DownloadManager
)
getSystemService
(
Context
.
DOWNLOAD_SERVICE
)
;
manager
.
enqueue
(
request
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Download
failed
:
"
+
e
)
;
}
break
;
case
"
Website
:
Metadata
"
:
final
String
location
=
message
.
getString
(
"
location
"
)
;
final
boolean
hasImage
=
message
.
getBoolean
(
"
hasImage
"
)
;
final
String
metadata
=
message
.
getString
(
"
metadata
"
)
;
final
ContentProviderClient
contentProviderClient
=
getContentResolver
(
)
.
acquireContentProviderClient
(
BrowserContract
.
PageMetadata
.
CONTENT_URI
)
;
if
(
contentProviderClient
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Failed
to
obtain
content
provider
client
for
:
"
+
BrowserContract
.
PageMetadata
.
CONTENT_URI
)
;
return
;
}
try
{
GlobalPageMetadata
.
getInstance
(
)
.
add
(
BrowserDB
.
from
(
getProfile
(
)
)
contentProviderClient
location
hasImage
metadata
)
;
}
finally
{
contentProviderClient
.
release
(
)
;
}
break
;
case
"
NotificationSettings
:
FeatureTipsStatusUpdated
"
:
if
(
message
.
getBoolean
(
"
isMmaEnabled
"
)
)
{
initSwitchboardAndMma
(
this
safeStartingIntent
isInAutomation
)
;
}
else
{
MmaDelegate
.
stop
(
)
;
}
break
;
default
:
super
.
handleMessage
(
event
message
callback
)
;
break
;
}
}
private
boolean
isDefaultBrowser
(
String
action
)
{
final
Intent
viewIntent
=
new
Intent
(
action
Uri
.
parse
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
)
;
final
ResolveInfo
info
=
getPackageManager
(
)
.
resolveActivity
(
viewIntent
PackageManager
.
MATCH_DEFAULT_ONLY
)
;
if
(
info
=
=
null
)
{
return
false
;
}
final
String
packageName
=
info
.
activityInfo
.
packageName
;
return
(
TextUtils
.
equals
(
packageName
getPackageName
(
)
)
)
;
}
Override
public
void
addTab
(
final
int
flags
)
{
if
(
(
flags
&
Tabs
.
LOADURL_PRIVATE
)
=
=
0
)
{
MmaDelegate
.
track
(
NEW_TAB
)
;
}
Tabs
.
getInstance
(
)
.
addTab
(
flags
)
;
}
Override
public
void
addTab
(
)
{
addTab
(
Tabs
.
LOADURL_NONE
)
;
}
Override
public
void
addPrivateTab
(
)
{
Tabs
.
getInstance
(
)
.
addPrivateTab
(
)
;
}
public
void
showTrackingProtectionPromptIfApplicable
(
)
{
final
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
final
boolean
hasTrackingProtectionPromptBeShownBefore
=
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_TRACKING_PROTECTION_PROMPT_SHOWN
false
)
;
if
(
hasTrackingProtectionPromptBeShownBefore
)
{
return
;
}
prefs
.
edit
(
)
.
putBoolean
(
GeckoPreferences
.
PREFS_TRACKING_PROTECTION_PROMPT_SHOWN
true
)
.
apply
(
)
;
startActivity
(
new
Intent
(
BrowserApp
.
this
TrackingProtectionPrompt
.
class
)
)
;
}
Override
public
void
showNormalTabs
(
)
{
showTabs
(
TabsPanel
.
Panel
.
NORMAL_TABS
)
;
}
Override
public
void
showPrivateTabs
(
)
{
showTabs
(
TabsPanel
.
Panel
.
PRIVATE_TABS
)
;
}
private
boolean
ensureTabsPanelExists
(
)
{
if
(
mTabsPanel
!
=
null
)
{
return
false
;
}
ViewStub
tabsPanelStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
tabs_panel
)
;
mTabsPanel
=
(
TabsPanel
)
tabsPanelStub
.
inflate
(
)
;
mTabsPanel
.
setTabsLayoutChangeListener
(
this
)
;
return
true
;
}
private
void
showTabs
(
final
TabsPanel
.
Panel
panel
)
{
if
(
Tabs
.
getInstance
(
)
.
getDisplayCount
(
)
=
=
0
)
return
;
hideFirstrunPager
(
TelemetryContract
.
Method
.
BUTTON
)
;
if
(
ensureTabsPanelExists
(
)
)
{
ViewTreeObserver
vto
=
mTabsPanel
.
getViewTreeObserver
(
)
;
if
(
vto
.
isAlive
(
)
)
{
vto
.
addOnGlobalLayoutListener
(
new
ViewTreeObserver
.
OnGlobalLayoutListener
(
)
{
Override
public
void
onGlobalLayout
(
)
{
mTabsPanel
.
getViewTreeObserver
(
)
.
removeGlobalOnLayoutListener
(
this
)
;
showTabs
(
panel
)
;
}
}
)
;
}
}
else
{
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
disable
(
)
;
}
if
(
mTabStrip
!
=
null
)
{
mTabStrip
.
tabStripIsCovered
(
true
)
;
}
mTabsPanel
.
show
(
panel
)
;
mFindInPageBar
.
hide
(
)
;
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onTabsTrayShown
(
this
mTabsPanel
)
;
}
}
WindowUtil
.
setTabsTrayStatusBarColor
(
this
)
;
}
Override
public
void
hideTabs
(
)
{
mTabsPanel
.
hide
(
)
;
if
(
mTabStrip
!
=
null
)
{
mTabStrip
.
tabStripIsCovered
(
false
)
;
}
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
enable
(
)
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onTabsTrayHidden
(
this
mTabsPanel
)
;
}
refreshStatusBarColor
(
)
;
}
Override
public
boolean
autoHideTabs
(
)
{
if
(
areTabsShown
(
)
)
{
hideTabs
(
)
;
return
true
;
}
return
false
;
}
public
boolean
areTabsShown
(
)
{
return
(
mTabsPanel
!
=
null
&
&
mTabsPanel
.
isShown
(
)
)
;
}
TargetApi
(
Build
.
VERSION_CODES
.
JELLY_BEAN
)
Override
public
void
onTabsLayoutChange
(
int
width
int
height
)
{
int
animationLength
=
TABS_ANIMATION_DURATION
;
if
(
mMainLayoutAnimator
!
=
null
)
{
animationLength
=
Math
.
max
(
1
animationLength
-
(
int
)
mMainLayoutAnimator
.
getRemainingTime
(
)
)
;
mMainLayoutAnimator
.
stop
(
false
)
;
}
if
(
areTabsShown
(
)
)
{
mTabsPanel
.
setDescendantFocusability
(
ViewGroup
.
FOCUS_AFTER_DESCENDANTS
)
;
if
(
Versions
.
feature16Plus
)
{
mLayerView
.
setImportantForAccessibility
(
View
.
IMPORTANT_FOR_ACCESSIBILITY_NO
)
;
}
}
else
{
if
(
Versions
.
feature16Plus
)
{
mLayerView
.
setImportantForAccessibility
(
View
.
IMPORTANT_FOR_ACCESSIBILITY_YES
)
;
}
}
mMainLayoutAnimator
=
new
PropertyAnimator
(
animationLength
sTabsInterpolator
)
;
mMainLayoutAnimator
.
addPropertyAnimationListener
(
this
)
;
mMainLayoutAnimator
.
attach
(
mMainLayout
PropertyAnimator
.
Property
.
SCROLL_Y
-
height
)
;
mTabsPanel
.
prepareTabsAnimation
(
mMainLayoutAnimator
)
;
mBrowserToolbar
.
triggerTabsPanelTransition
(
mMainLayoutAnimator
areTabsShown
(
)
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
if
(
width
>
0
&
&
height
>
0
)
{
mDynamicToolbar
.
setPinned
(
true
PinReason
.
RELAYOUT
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
else
{
mDynamicToolbar
.
setPinned
(
false
PinReason
.
RELAYOUT
)
;
}
}
mMainLayoutAnimator
.
start
(
)
;
}
Override
public
void
onPropertyAnimationStart
(
)
{
}
Override
public
void
onPropertyAnimationEnd
(
)
{
if
(
!
areTabsShown
(
)
)
{
mTabsPanel
.
setVisibility
(
View
.
INVISIBLE
)
;
mTabsPanel
.
setDescendantFocusability
(
ViewGroup
.
FOCUS_BLOCK_DESCENDANTS
)
;
}
else
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
mTabsPanel
.
finishTabsAnimation
(
)
;
mMainLayoutAnimator
=
null
;
}
Override
public
void
onSaveInstanceState
(
Bundle
outState
)
{
super
.
onSaveInstanceState
(
outState
)
;
mDynamicToolbar
.
onSaveInstanceState
(
outState
)
;
outState
.
putInt
(
STATE_ABOUT_HOME_TOP_PADDING
mHomeScreenContainer
.
getPaddingTop
(
)
)
;
if
(
getBundleSizeInBytes
(
outState
)
>
MAX_BUNDLE_SIZE
)
{
outState
.
remove
(
"
android
:
viewHierarchyState
"
)
;
}
}
private
boolean
maybeSwitchToTab
(
String
url
EnumSet
<
OnUrlOpenListener
.
Flags
>
flags
)
{
if
(
!
flags
.
contains
(
OnUrlOpenListener
.
Flags
.
ALLOW_SWITCH_TO_TAB
)
)
{
return
false
;
}
final
boolean
isPrivate
=
mBrowserToolbar
.
isPrivateMode
(
)
;
final
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
final
Tab
tab
;
if
(
AboutPages
.
isAboutReader
(
url
)
)
{
tab
=
tabs
.
getFirstReaderTabForUrl
(
url
isPrivate
)
;
}
else
{
tab
=
tabs
.
getFirstTabForUrl
(
url
isPrivate
)
;
}
if
(
tab
=
=
null
)
{
return
false
;
}
return
maybeSwitchToTab
(
tab
.
getId
(
)
)
;
}
private
boolean
maybeSwitchToTab
(
int
id
)
{
final
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
final
Tab
tab
=
tabs
.
getTab
(
id
)
;
if
(
tab
=
=
null
)
{
return
false
;
}
final
Tab
oldTab
=
tabs
.
getSelectedTab
(
)
;
if
(
oldTab
!
=
null
)
{
oldTab
.
setIsEditing
(
false
)
;
}
mTargetTabForEditingMode
=
null
;
tabs
.
selectTab
(
tab
.
getId
(
)
)
;
mBrowserToolbar
.
cancelEdit
(
)
;
return
true
;
}
public
void
openUrlAndStopEditing
(
String
url
)
{
openUrlAndStopEditing
(
url
null
null
false
)
;
}
private
void
openUrlAndStopEditingWithReferrer
(
final
String
url
final
String
referrerUri
)
{
openUrlAndStopEditing
(
url
null
referrerUri
false
)
;
}
private
void
openUrlAndStopEditing
(
String
url
String
searchEngine
)
{
openUrlAndStopEditing
(
url
searchEngine
null
false
)
;
}
private
void
openUrlAndStopEditing
(
String
url
String
searchEngine
Nullable
final
String
referrerUri
boolean
newTab
)
{
int
flags
=
Tabs
.
LOADURL_NONE
;
if
(
newTab
)
{
flags
|
=
Tabs
.
LOADURL_NEW_TAB
;
if
(
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
isPrivate
(
)
)
{
flags
|
=
Tabs
.
LOADURL_PRIVATE
;
}
}
Tabs
.
getInstance
(
)
.
loadUrl
(
url
searchEngine
referrerUri
Tabs
.
INVALID_TAB_ID
null
flags
)
;
mBrowserToolbar
.
cancelEdit
(
)
;
}
private
boolean
isHomePagerVisible
(
)
{
return
(
mHomeScreen
!
=
null
&
&
mHomeScreen
.
isVisible
(
)
&
&
mHomeScreenContainer
!
=
null
&
&
mHomeScreenContainer
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
;
}
private
SplashScreen
getSplashScreen
(
)
{
final
ViewGroup
main
=
(
ViewGroup
)
findViewById
(
R
.
id
.
gecko_layout
)
;
final
View
splashLayout
=
LayoutInflater
.
from
(
this
)
.
inflate
(
R
.
layout
.
splash_screen
main
)
;
return
(
SplashScreen
)
splashLayout
.
findViewById
(
R
.
id
.
splash_root
)
;
}
private
void
enterEditingMode
(
)
{
String
url
=
"
"
;
String
telemetryMsg
=
"
urlbar
-
empty
"
;
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
final
String
userSearchTerm
=
tab
.
getUserRequested
(
)
;
final
String
tabURL
=
tab
.
getURL
(
)
;
if
(
!
TextUtils
.
isEmpty
(
userSearchTerm
)
)
{
url
=
userSearchTerm
;
telemetryMsg
=
"
urlbar
-
userentered
"
;
}
else
if
(
!
TextUtils
.
isEmpty
(
tabURL
)
)
{
url
=
tabURL
;
telemetryMsg
=
"
urlbar
-
url
"
;
if
(
splashScreen
!
=
null
)
{
splashScreen
.
setVisibility
(
View
.
GONE
)
;
}
}
}
enterEditingMode
(
url
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHOW
TelemetryContract
.
Method
.
ACTIONBAR
telemetryMsg
)
;
}
private
void
enterEditingMode
(
NonNull
String
url
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
ACTIONBAR
)
;
if
(
mBrowserToolbar
.
isEditing
(
)
|
|
mBrowserToolbar
.
isAnimating
(
)
)
{
return
;
}
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
String
panelId
;
if
(
selectedTab
!
=
null
)
{
mTargetTabForEditingMode
=
selectedTab
.
getId
(
)
;
panelId
=
selectedTab
.
getMostRecentHomePanel
(
)
;
}
else
{
mTargetTabForEditingMode
=
null
;
panelId
=
null
;
}
final
PropertyAnimator
animator
=
new
PropertyAnimator
(
250
)
;
animator
.
setUseHardwareLayer
(
false
)
;
mBrowserToolbar
.
startEditing
(
url
animator
)
;
showHomePagerWithAnimator
(
panelId
null
animator
)
;
animator
.
start
(
)
;
Telemetry
.
startUISession
(
TelemetryContract
.
Session
.
AWESOMESCREEN
)
;
}
private
boolean
commitEditingMode
(
)
{
if
(
!
mBrowserToolbar
.
isEditing
(
)
)
{
return
false
;
}
Telemetry
.
stopUISession
(
TelemetryContract
.
Session
.
AWESOMESCREEN
TelemetryContract
.
Reason
.
COMMIT
)
;
final
String
url
=
mBrowserToolbar
.
commitEdit
(
)
;
hideHomePager
(
url
)
;
loadUrlOrKeywordSearch
(
url
)
;
clearSelectedTabApplicationId
(
)
;
return
true
;
}
private
void
clearSelectedTabApplicationId
(
)
{
final
Tab
selected
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selected
!
=
null
)
{
selected
.
setApplicationId
(
null
)
;
}
}
private
void
loadUrlOrKeywordSearch
(
final
String
url
)
{
if
(
TextUtils
.
isEmpty
(
url
)
)
{
return
;
}
if
(
!
StringUtils
.
isSearchQuery
(
url
true
)
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
url
Tabs
.
LOADURL_USER_ENTERED
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
ACTIONBAR
"
user
"
)
;
return
;
}
final
SharedPreferences
sharedPrefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
BrowserDB
db
=
BrowserDB
.
from
(
getProfile
(
)
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
String
keyword
;
final
String
keywordSearch
;
final
int
index
=
url
.
indexOf
(
"
"
)
;
if
(
index
=
=
-
1
)
{
keyword
=
url
;
keywordSearch
=
"
"
;
}
else
{
keyword
=
url
.
substring
(
0
index
)
;
keywordSearch
=
url
.
substring
(
index
+
1
)
;
}
final
String
keywordUrl
=
db
.
getUrlForKeyword
(
getContentResolver
(
)
keyword
)
;
if
(
TextUtils
.
isEmpty
(
keywordUrl
)
|
|
(
!
TextUtils
.
isEmpty
(
keywordSearch
)
&
&
!
StringUtils
.
queryExists
(
keywordUrl
)
)
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
url
Tabs
.
LOADURL_USER_ENTERED
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
ACTIONBAR
"
user
"
)
;
return
;
}
final
String
searchUrl
=
keywordUrl
.
replace
(
"
%
s
"
URLEncoder
.
encode
(
keywordSearch
)
)
.
replace
(
"
%
S
"
keywordSearch
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
searchUrl
Tabs
.
LOADURL_USER_ENTERED
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
ACTIONBAR
"
keyword
"
)
;
}
}
)
;
}
private
static
void
recordSearch
(
NonNull
final
SharedPreferences
prefs
NonNull
final
String
engineIdentifier
NonNull
final
TelemetryContract
.
Method
where
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SEARCH
where
)
;
SearchCountMeasurements
.
incrementSearch
(
prefs
engineIdentifier
where
.
toString
(
)
)
;
}
private
void
storeSearchQuery
(
final
String
query
)
{
if
(
TextUtils
.
isEmpty
(
query
)
)
{
return
;
}
if
(
query
.
length
(
)
>
50
|
|
Pattern
.
matches
(
"
^
(
https
?
|
ftp
|
file
)
:
/
/
.
*
"
query
)
)
{
return
;
}
final
GeckoProfile
profile
=
getProfile
(
)
;
if
(
profile
.
inGuestMode
(
)
)
{
return
;
}
final
BrowserDB
db
=
BrowserDB
.
from
(
profile
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
db
.
getSearches
(
)
.
insert
(
getContentResolver
(
)
query
)
;
}
}
)
;
}
void
filterEditingMode
(
String
searchTerm
AutocompleteHandler
handler
)
{
if
(
TextUtils
.
isEmpty
(
searchTerm
)
)
{
hideBrowserSearch
(
)
;
}
else
{
showBrowserSearch
(
)
;
mBrowserSearch
.
filter
(
searchTerm
handler
)
;
}
}
private
void
selectTargetTabForEditingMode
(
)
{
if
(
HardwareUtils
.
isTablet
(
)
)
{
return
;
}
if
(
mTargetTabForEditingMode
!
=
null
)
{
Tabs
.
getInstance
(
)
.
selectTab
(
mTargetTabForEditingMode
)
;
}
mTargetTabForEditingMode
=
null
;
}
private
void
updateHomePagerForTab
(
Tab
tab
)
{
if
(
mBrowserToolbar
.
isEditing
(
)
)
{
return
;
}
if
(
isAboutHome
(
tab
)
)
{
if
(
!
mOnboardingHelper
.
isPreparing
(
)
&
&
splashScreen
!
=
null
&
&
splashScreen
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
{
splashScreen
.
hide
(
)
;
}
String
panelId
=
AboutPages
.
getPanelIdFromAboutHomeUrl
(
tab
.
getURL
(
)
)
;
Bundle
panelRestoreData
=
null
;
if
(
panelId
=
=
null
)
{
panelId
=
tab
.
getMostRecentHomePanel
(
)
;
panelRestoreData
=
tab
.
getMostRecentHomePanelData
(
)
;
}
else
if
(
panelId
.
equals
(
HomeConfig
.
getIdForBuiltinPanelType
(
PanelType
.
DEPRECATED_RECENT_TABS
)
)
)
{
panelId
=
HomeConfig
.
getIdForBuiltinPanelType
(
PanelType
.
COMBINED_HISTORY
)
;
panelRestoreData
=
new
Bundle
(
)
;
panelRestoreData
.
putBoolean
(
"
goToRecentTabs
"
true
)
;
}
showHomePager
(
panelId
panelRestoreData
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
showSplashScreen
=
false
;
}
else
{
if
(
showSplashScreen
&
&
!
GeckoThread
.
isRunning
(
)
)
{
if
(
splashScreen
=
=
null
)
{
splashScreen
=
getSplashScreen
(
)
;
}
showSplashScreen
=
false
;
}
else
if
(
splashScreen
!
=
null
)
{
splashScreen
.
hide
(
)
;
}
hideHomePager
(
)
;
}
}
Override
public
void
onLocaleReady
(
final
String
locale
)
{
Log
.
d
(
LOGTAG
"
onLocaleReady
:
"
+
locale
)
;
super
.
onLocaleReady
(
locale
)
;
HomePanelsManager
.
getInstance
(
)
.
onLocaleReady
(
locale
)
;
mBrowserToolbar
.
onLocaleReady
(
locale
)
;
if
(
mMenu
!
=
null
)
{
mMenu
.
clear
(
)
;
onCreateOptionsMenu
(
mMenu
)
;
}
}
Override
public
void
onActivityResult
(
int
requestCode
int
resultCode
Intent
data
)
{
Log
.
d
(
LOGTAG
"
onActivityResult
:
"
+
requestCode
+
"
"
+
resultCode
+
"
"
+
data
)
;
switch
(
requestCode
)
{
case
ACTIVITY_REQUEST_PREFERENCES
:
if
(
resultCode
!
=
GeckoPreferences
.
RESULT_CODE_LOCALE_DID_CHANGE
)
{
Log
.
d
(
LOGTAG
"
No
locale
change
returning
from
preferences
;
nothing
to
do
.
"
)
;
return
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
LocaleManager
localeManager
=
BrowserLocaleManager
.
getInstance
(
)
;
final
Locale
locale
=
localeManager
.
getCurrentLocale
(
getApplicationContext
(
)
)
;
Log
.
d
(
LOGTAG
"
Read
persisted
locale
"
+
locale
)
;
if
(
locale
=
=
null
)
{
return
;
}
onLocaleChanged
(
Locales
.
getLanguageTag
(
locale
)
)
;
}
}
)
;
break
;
case
ACTIVITY_REQUEST_TAB_QUEUE
:
TabQueueHelper
.
processTabQueuePromptResponse
(
resultCode
this
)
;
break
;
default
:
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onActivityResult
(
this
requestCode
resultCode
data
)
;
}
super
.
onActivityResult
(
requestCode
resultCode
data
)
;
}
}
private
void
showHomePager
(
String
panelId
Bundle
panelRestoreData
)
{
showHomePagerWithAnimator
(
panelId
panelRestoreData
null
)
;
}
private
void
showHomePagerWithAnimator
(
String
panelId
Bundle
panelRestoreData
PropertyAnimator
animator
)
{
if
(
isHomePagerVisible
(
)
)
{
mHomeScreen
.
showPanel
(
panelId
panelRestoreData
)
;
return
;
}
mFormAssistPopup
.
hide
(
)
;
mFindInPageBar
.
hide
(
)
;
refreshToolbarHeight
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
if
(
mHomeScreen
=
=
null
)
{
if
(
ActivityStream
.
isEnabled
(
this
)
&
&
!
ActivityStream
.
isHomePanel
(
)
)
{
final
ViewStub
asStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
activity_stream_stub
)
;
mHomeScreen
=
(
HomeScreen
)
asStub
.
inflate
(
)
;
}
else
{
final
ViewStub
homePagerStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
home_pager_stub
)
;
mHomeScreen
=
(
HomeScreen
)
homePagerStub
.
inflate
(
)
;
mHomeScreen
.
setOnPanelChangeListener
(
new
HomeScreen
.
OnPanelChangeListener
(
)
{
Override
public
void
onPanelSelected
(
String
panelId
)
{
final
Tab
currentTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
currentTab
!
=
null
)
{
currentTab
.
setMostRecentHomePanel
(
panelId
)
;
}
}
}
)
;
mHomeScreen
.
setPanelStateChangeListener
(
new
HomeFragment
.
PanelStateChangeListener
(
)
{
Override
public
void
onStateChanged
(
Bundle
bundle
)
{
final
Tab
currentTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
currentTab
!
=
null
)
{
currentTab
.
setMostRecentHomePanelData
(
bundle
)
;
}
}
Override
public
void
setCachedRecentTabsCount
(
int
count
)
{
mCachedRecentTabsCount
=
count
;
}
Override
public
int
getCachedRecentTabsCount
(
)
{
return
mCachedRecentTabsCount
;
}
}
)
;
}
if
(
!
Restrictions
.
isUserRestricted
(
)
)
{
final
ViewStub
homeBannerStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
home_banner_stub
)
;
final
HomeBanner
homeBanner
=
(
HomeBanner
)
homeBannerStub
.
inflate
(
)
;
mHomeScreen
.
setBanner
(
homeBanner
)
;
homeBanner
.
setOnDismissListener
(
new
HomeBanner
.
OnDismissListener
(
)
{
Override
public
void
onDismiss
(
)
{
mHomeScreen
.
setBanner
(
null
)
;
mHomeScreenContainer
.
removeView
(
homeBanner
)
;
}
}
)
;
}
}
mHomeScreenContainer
.
setVisibility
(
View
.
VISIBLE
)
;
mHomeScreen
.
load
(
getSupportLoaderManager
(
)
getSupportFragmentManager
(
)
panelId
panelRestoreData
animator
)
;
hideWebContentOnPropertyAnimationEnd
(
animator
)
;
}
private
void
hideWebContentOnPropertyAnimationEnd
(
final
PropertyAnimator
animator
)
{
if
(
animator
=
=
null
)
{
hideWebContent
(
)
;
return
;
}
animator
.
addPropertyAnimationListener
(
new
PropertyAnimator
.
PropertyAnimationListener
(
)
{
Override
public
void
onPropertyAnimationStart
(
)
{
mHideWebContentOnAnimationEnd
=
true
;
}
Override
public
void
onPropertyAnimationEnd
(
)
{
if
(
mHideWebContentOnAnimationEnd
)
{
hideWebContent
(
)
;
}
}
}
)
;
}
private
void
hideWebContent
(
)
{
mLayerView
.
setVisibility
(
View
.
INVISIBLE
)
;
}
private
boolean
hideFirstrunPager
(
TelemetryContract
.
Method
method
)
{
if
(
!
mOnboardingHelper
.
hideOnboarding
(
)
)
{
return
false
;
}
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
CANCEL
method
"
firstrun
-
pane
"
)
;
return
true
;
}
private
void
hideHomePager
(
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
String
url
=
(
selectedTab
!
=
null
)
?
selectedTab
.
getURL
(
)
:
null
;
hideHomePager
(
url
)
;
}
private
void
hideHomePager
(
final
String
url
)
{
if
(
!
isHomePagerVisible
(
)
|
|
AboutPages
.
isAboutHome
(
url
)
)
{
return
;
}
mHideWebContentOnAnimationEnd
=
false
;
mLayerView
.
setVisibility
(
View
.
VISIBLE
)
;
mHomeScreenContainer
.
setVisibility
(
View
.
GONE
)
;
if
(
mHomeScreen
!
=
null
)
{
mHomeScreen
.
unload
(
)
;
}
mBrowserToolbar
.
setNextFocusDownId
(
R
.
id
.
layer_view
)
;
refreshToolbarHeight
(
)
;
}
private
void
showBrowserSearchAfterAnimation
(
PropertyAnimator
animator
)
{
if
(
animator
=
=
null
)
{
showBrowserSearch
(
)
;
return
;
}
animator
.
addPropertyAnimationListener
(
new
PropertyAnimator
.
PropertyAnimationListener
(
)
{
Override
public
void
onPropertyAnimationStart
(
)
{
}
Override
public
void
onPropertyAnimationEnd
(
)
{
showBrowserSearch
(
)
;
}
}
)
;
}
private
void
showBrowserSearch
(
)
{
if
(
mBrowserSearch
.
getUserVisibleHint
(
)
)
{
return
;
}
mBrowserSearchContainer
.
setVisibility
(
View
.
VISIBLE
)
;
hideWebContent
(
)
;
mHomeScreenContainer
.
setVisibility
(
View
.
INVISIBLE
)
;
final
FragmentManager
fm
=
getSupportFragmentManager
(
)
;
fm
.
executePendingTransactions
(
)
;
Fragment
f
=
fm
.
findFragmentById
(
R
.
id
.
search_container
)
;
if
(
f
!
=
null
)
{
fm
.
beginTransaction
(
)
.
show
(
f
)
.
commitAllowingStateLoss
(
)
;
mBrowserSearch
.
resetScrollState
(
)
;
}
else
{
fm
.
beginTransaction
(
)
.
add
(
R
.
id
.
search_container
mBrowserSearch
BROWSER_SEARCH_TAG
)
.
commitAllowingStateLoss
(
)
;
}
mBrowserSearch
.
setUserVisibleHint
(
true
)
;
getWindow
(
)
.
setBackgroundDrawableResource
(
android
.
R
.
color
.
white
)
;
}
private
void
hideBrowserSearch
(
)
{
if
(
!
mBrowserSearch
.
getUserVisibleHint
(
)
)
{
return
;
}
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
String
panelId
;
final
Bundle
panelData
;
if
(
selectedTab
!
=
null
)
{
panelId
=
selectedTab
.
getMostRecentHomePanel
(
)
;
panelData
=
selectedTab
.
getMostRecentHomePanelData
(
)
;
}
else
{
panelId
=
null
;
panelData
=
null
;
}
showHomePager
(
panelId
panelData
)
;
mBrowserSearchContainer
.
setVisibility
(
View
.
INVISIBLE
)
;
getSupportFragmentManager
(
)
.
beginTransaction
(
)
.
hide
(
mBrowserSearch
)
.
commitAllowingStateLoss
(
)
;
mBrowserSearch
.
setUserVisibleHint
(
false
)
;
getWindow
(
)
.
setBackgroundDrawable
(
null
)
;
}
private
static
final
class
HideOnTouchListener
implements
TouchEventInterceptor
{
Override
public
boolean
onInterceptTouchEvent
(
View
view
MotionEvent
event
)
{
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
)
{
SnackbarBuilder
.
dismissCurrentSnackbar
(
)
;
}
return
false
;
}
Override
public
boolean
onTouch
(
View
view
MotionEvent
event
)
{
return
false
;
}
}
Override
public
boolean
onCreateOptionsMenu
(
Menu
menu
)
{
super
.
onCreateOptionsMenu
(
menu
)
;
if
(
menu
instanceof
GeckoMenu
&
&
HardwareUtils
.
isTablet
(
)
)
{
(
(
GeckoMenu
)
menu
)
.
setActionItemBarPresenter
(
mBrowserToolbar
)
;
}
MenuInflater
inflater
=
getMenuInflater
(
)
;
inflater
.
inflate
(
R
.
menu
.
browser_app_menu
mMenu
)
;
AddonUICache
.
getInstance
(
)
.
onCreateOptionsMenu
(
mMenu
)
;
GeckoMenuItem
share
=
(
GeckoMenuItem
)
mMenu
.
findItem
(
R
.
id
.
share
)
;
GeckoActionProvider
provider
=
GeckoActionProvider
.
getForType
(
GeckoActionProvider
.
DEFAULT_MIME_TYPE
this
)
;
share
.
setActionProvider
(
provider
)
;
return
true
;
}
Override
public
void
openOptionsMenu
(
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
MENU
)
;
if
(
mBrowserToolbar
.
isEditing
(
)
&
&
!
HardwareUtils
.
isTablet
(
)
)
{
return
;
}
if
(
ActivityUtils
.
isFullScreen
(
this
)
)
{
return
;
}
if
(
areTabsShown
(
)
)
{
mTabsPanel
.
showMenu
(
)
;
return
;
}
if
(
mMenuPanel
!
=
null
)
mMenuPanel
.
scrollTo
(
0
0
)
;
if
(
mMenu
instanceof
GeckoMenu
)
{
(
(
GeckoMenu
)
mMenu
)
.
setSelection
(
0
)
;
}
if
(
!
mBrowserToolbar
.
openOptionsMenu
(
)
)
super
.
openOptionsMenu
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
Override
public
void
closeOptionsMenu
(
)
{
if
(
!
mBrowserToolbar
.
closeOptionsMenu
(
)
)
super
.
closeOptionsMenu
(
)
;
}
Override
public
void
onFullScreen
(
final
GeckoSession
session
final
boolean
fullscreen
)
{
super
.
onFullScreen
(
session
fullscreen
)
;
if
(
fullscreen
)
{
mDynamicToolbar
.
setVisible
(
false
VisibilityTransition
.
IMMEDIATE
)
;
mDynamicToolbar
.
setPinned
(
true
PinReason
.
FULL_SCREEN
)
;
}
else
{
mDynamicToolbar
.
setPinned
(
false
PinReason
.
FULL_SCREEN
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
}
Override
public
boolean
onPrepareOptionsMenu
(
Menu
aMenu
)
{
if
(
aMenu
=
=
null
)
return
false
;
TabHistoryFragment
frag
=
(
TabHistoryFragment
)
getSupportFragmentManager
(
)
.
findFragmentByTag
(
TAB_HISTORY_FRAGMENT_TAG
)
;
if
(
frag
!
=
null
)
{
frag
.
dismiss
(
)
;
}
if
(
!
GeckoThread
.
isRunning
(
)
)
{
aMenu
.
findItem
(
R
.
id
.
settings
)
.
setEnabled
(
false
)
;
aMenu
.
findItem
(
R
.
id
.
help
)
.
setEnabled
(
false
)
;
}
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
MenuItem
bookmark
=
aMenu
.
findItem
(
R
.
id
.
bookmark
)
;
final
MenuItem
back
=
aMenu
.
findItem
(
R
.
id
.
back
)
;
final
MenuItem
forward
=
aMenu
.
findItem
(
R
.
id
.
forward
)
;
final
MenuItem
share
=
aMenu
.
findItem
(
R
.
id
.
share
)
;
final
MenuItem
bookmarksList
=
aMenu
.
findItem
(
R
.
id
.
bookmarks_list
)
;
final
MenuItem
historyList
=
aMenu
.
findItem
(
R
.
id
.
history_list
)
;
final
MenuItem
saveAsPDF
=
aMenu
.
findItem
(
R
.
id
.
save_as_pdf
)
;
final
MenuItem
print
=
aMenu
.
findItem
(
R
.
id
.
print
)
;
final
MenuItem
viewPageSource
=
aMenu
.
findItem
(
R
.
id
.
view_page_source
)
;
final
MenuItem
charEncoding
=
aMenu
.
findItem
(
R
.
id
.
char_encoding
)
;
final
MenuItem
findInPage
=
aMenu
.
findItem
(
R
.
id
.
find_in_page
)
;
final
MenuItem
desktopMode
=
aMenu
.
findItem
(
R
.
id
.
desktop_mode
)
;
final
MenuItem
enterGuestMode
=
aMenu
.
findItem
(
R
.
id
.
new_guest_session
)
;
final
MenuItem
exitGuestMode
=
aMenu
.
findItem
(
R
.
id
.
exit_guest_session
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
boolean
visible
=
HardwareUtils
.
isTelevision
(
)
|
|
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_SHOW_QUIT_MENU
false
)
|
|
!
PrefUtils
.
getStringSet
(
prefs
ClearOnShutdownPref
.
PREF
new
HashSet
<
String
>
(
)
)
.
isEmpty
(
)
;
aMenu
.
findItem
(
R
.
id
.
quit
)
.
setVisible
(
visible
)
;
if
(
tab
=
=
null
|
|
tab
.
getURL
(
)
=
=
null
)
{
bookmark
.
setEnabled
(
false
)
;
back
.
setEnabled
(
false
)
;
forward
.
setEnabled
(
false
)
;
share
.
setEnabled
(
false
)
;
saveAsPDF
.
setEnabled
(
false
)
;
print
.
setEnabled
(
false
)
;
findInPage
.
setEnabled
(
false
)
;
viewPageSource
.
setEnabled
(
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
page
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
subscribe
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_search_engine
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
pin_to_top_sites
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_to_launcher
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
set_as_homepage
false
)
;
final
MenuItem
pinToTopSitesItem
=
aMenu
.
findItem
(
R
.
id
.
pin_to_top_sites
)
;
if
(
pinToTopSitesItem
!
=
null
)
{
pinToTopSitesItem
.
setTitle
(
R
.
string
.
contextmenu_pin_to_top_sites
)
;
}
return
true
;
}
final
boolean
inGuestMode
=
GeckoProfile
.
get
(
this
)
.
inGuestMode
(
)
;
bookmark
.
setEnabled
(
true
)
;
bookmark
.
setVisible
(
!
inGuestMode
)
;
bookmark
.
setCheckable
(
true
)
;
bookmark
.
setChecked
(
tab
.
isBookmark
(
)
)
;
bookmark
.
setTitle
(
resolveBookmarkTitleID
(
tab
.
isBookmark
(
)
)
)
;
final
boolean
isPrivate
=
tab
.
isPrivate
(
)
;
bookmark
.
setIcon
(
resolveBookmarkIconDrawable
(
tab
.
isBookmark
(
)
resolveMenuIconTint
(
isPrivate
)
)
)
;
back
.
setEnabled
(
tab
.
canDoBack
(
)
)
;
forward
.
setEnabled
(
tab
.
canDoForward
(
)
)
;
desktopMode
.
setChecked
(
tab
.
getDesktopMode
(
)
)
;
View
backButtonView
=
MenuItemCompat
.
getActionView
(
back
)
;
if
(
backButtonView
!
=
null
)
{
backButtonView
.
setOnLongClickListener
(
new
Button
.
OnLongClickListener
(
)
{
Override
public
boolean
onLongClick
(
View
view
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
closeOptionsMenu
(
)
;
return
tabHistoryController
.
showTabHistory
(
tab
TabHistoryController
.
HistoryAction
.
BACK
)
;
}
return
false
;
}
}
)
;
}
View
forwardButtonView
=
MenuItemCompat
.
getActionView
(
forward
)
;
if
(
forwardButtonView
!
=
null
)
{
forwardButtonView
.
setOnLongClickListener
(
new
Button
.
OnLongClickListener
(
)
{
Override
public
boolean
onLongClick
(
View
view
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
closeOptionsMenu
(
)
;
return
tabHistoryController
.
showTabHistory
(
tab
TabHistoryController
.
HistoryAction
.
FORWARD
)
;
}
return
false
;
}
}
)
;
}
String
url
=
tab
.
getURL
(
)
;
if
(
AboutPages
.
isAboutReader
(
url
)
)
{
url
=
ReaderModeUtils
.
stripAboutReaderUrl
(
url
)
;
}
final
boolean
shareVisible
=
Restrictions
.
isAllowed
(
this
Restrictable
.
SHARE
)
;
share
.
setVisible
(
shareVisible
)
;
final
boolean
shareEnabled
=
StringUtils
.
isShareableUrl
(
url
)
&
&
shareVisible
;
share
.
setEnabled
(
shareEnabled
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
downloads
Restrictions
.
isAllowed
(
this
Restrictable
.
DOWNLOAD
)
)
;
final
boolean
distSetAsHomepage
=
GeckoSharedPrefs
.
forProfile
(
this
)
.
getBoolean
(
GeckoPreferences
.
PREFS_SET_AS_HOMEPAGE
false
)
;
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
set_as_homepage
distSetAsHomepage
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
page
!
isAboutHome
(
tab
)
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
subscribe
tab
.
hasFeeds
(
)
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_search_engine
tab
.
hasOpenSearch
(
)
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_to_launcher
!
isAboutHome
(
tab
)
&
&
ShortcutUtils
.
isPinShortcutSupported
(
)
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
set_as_homepage
!
isAboutHome
(
tab
)
)
;
onPrepareOptionsMenuPinToTopSites
(
aMenu
tab
)
;
final
GeckoActionProvider
provider
=
(
(
GeckoMenuItem
)
share
)
.
getGeckoActionProvider
(
)
;
if
(
provider
!
=
null
)
{
Intent
shareIntent
=
provider
.
getIntent
(
)
;
if
(
shareIntent
=
=
null
)
{
shareIntent
=
new
Intent
(
Intent
.
ACTION_SEND
)
;
shareIntent
.
setType
(
"
text
/
plain
"
)
;
provider
.
setIntent
(
shareIntent
)
;
}
shareIntent
.
putExtra
(
Intent
.
EXTRA_TEXT
url
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_SUBJECT
tab
.
getDisplayTitle
(
)
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TITLE
tab
.
getDisplayTitle
(
)
)
;
shareIntent
.
putExtra
(
ShareDialog
.
INTENT_EXTRA_DEVICES_ONLY
true
)
;
shareIntent
.
removeExtra
(
"
share_screenshot_uri
"
)
;
BitmapDrawable
drawable
=
tab
.
getThumbnail
(
)
;
if
(
drawable
!
=
null
)
{
Bitmap
thumbnail
=
drawable
.
getBitmap
(
)
;
if
(
Build
.
MANUFACTURER
.
equals
(
"
Kobo
"
)
&
&
thumbnail
!
=
null
)
{
File
cacheDir
=
getExternalCacheDir
(
)
;
if
(
cacheDir
!
=
null
)
{
File
outFile
=
new
File
(
cacheDir
"
thumbnail
.
png
"
)
;
try
{
final
java
.
io
.
FileOutputStream
out
=
new
java
.
io
.
FileOutputStream
(
outFile
)
;
try
{
thumbnail
.
compress
(
Bitmap
.
CompressFormat
.
PNG
90
out
)
;
}
finally
{
try
{
out
.
close
(
)
;
}
catch
(
final
IOException
e
)
{
}
}
}
catch
(
FileNotFoundException
e
)
{
Log
.
e
(
LOGTAG
"
File
not
found
"
e
)
;
}
shareIntent
.
putExtra
(
"
share_screenshot_uri
"
Uri
.
parse
(
outFile
.
getPath
(
)
)
)
;
}
}
}
}
final
boolean
privateTabVisible
=
Restrictions
.
isAllowed
(
this
Restrictable
.
PRIVATE_BROWSING
)
;
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
new_private_tab
privateTabVisible
)
;
boolean
allowPDF
=
(
!
(
isAboutHome
(
tab
)
|
|
tab
.
getContentType
(
)
.
equals
(
"
application
/
vnd
.
mozilla
.
xul
+
xml
"
)
|
|
tab
.
getContentType
(
)
.
startsWith
(
"
video
/
"
)
)
)
;
saveAsPDF
.
setEnabled
(
allowPDF
)
;
print
.
setEnabled
(
allowPDF
)
;
print
.
setVisible
(
Versions
.
feature19Plus
)
;
final
boolean
notInAboutHome
=
!
isAboutHome
(
tab
)
;
findInPage
.
setEnabled
(
notInAboutHome
)
;
viewPageSource
.
setEnabled
(
notInAboutHome
)
;
charEncoding
.
setVisible
(
GeckoPreferences
.
getCharEncodingState
(
)
)
;
if
(
getProfile
(
)
.
inGuestMode
(
)
)
{
exitGuestMode
.
setVisible
(
true
)
;
}
else
{
enterGuestMode
.
setVisible
(
true
)
;
}
if
(
!
Restrictions
.
isAllowed
(
this
Restrictable
.
GUEST_BROWSING
)
)
{
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
new_guest_session
false
)
;
}
if
(
SwitchBoard
.
isInExperiment
(
this
Experiments
.
TOP_ADDONS_MENU
)
)
{
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons_top_level
true
)
;
GeckoMenuItem
item
=
(
GeckoMenuItem
)
aMenu
.
findItem
(
R
.
id
.
addons_top_level
)
;
if
(
item
!
=
null
)
{
if
(
mExtensionPermissionsHelper
.
getShowUpdateIcon
(
)
)
{
item
.
setIcon
(
R
.
drawable
.
ic_addon_update
)
;
}
else
{
item
.
setIcon
(
null
)
;
}
}
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons
false
)
;
}
else
{
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons_top_level
false
)
;
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons
true
)
;
}
if
(
!
Restrictions
.
isAllowed
(
this
Restrictable
.
INSTALL_EXTENSION
)
)
{
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons
false
)
;
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons_top_level
false
)
;
}
bookmarksList
.
setVisible
(
prefs
.
getBoolean
(
HomeConfig
.
PREF_KEY_BOOKMARKS_PANEL_ENABLED
true
)
)
;
historyList
.
setVisible
(
prefs
.
getBoolean
(
HomeConfig
.
PREF_KEY_HISTORY_PANEL_ENABLED
true
)
)
;
return
true
;
}
private
void
onPrepareOptionsMenuPinToTopSites
(
final
Menu
aMenu
final
Tab
tab
)
{
final
MenuItem
item
=
aMenu
.
findItem
(
R
.
id
.
pin_to_top_sites
)
;
if
(
item
=
=
null
)
{
return
;
}
item
.
setEnabled
(
false
)
;
item
.
setTitle
(
R
.
string
.
contextmenu_pin_to_top_sites
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
boolean
isPinned
=
BrowserDB
.
from
(
BrowserApp
.
this
)
.
isPinnedForAS
(
getContentResolver
(
)
tab
.
getURL
(
)
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
item
.
setTitle
(
isPinned
?
R
.
string
.
contextmenu_unpin_from_top_sites
:
R
.
string
.
contextmenu_pin_to_top_sites
)
;
item
.
setEnabled
(
true
)
;
}
}
)
;
}
}
)
;
}
private
Drawable
resolveBookmarkIconDrawable
(
final
boolean
isBookmark
final
int
tint
)
{
if
(
isBookmark
)
{
return
ResourcesCompat
.
getDrawable
(
getResources
(
)
R
.
drawable
.
star_blue
null
)
;
}
else
{
return
DrawableUtil
.
tintDrawable
(
this
R
.
drawable
.
ic_menu_bookmark_add
tint
)
;
}
}
private
int
resolveMenuIconTint
(
final
boolean
isPrivate
)
{
final
int
tintResId
;
if
(
isPrivate
&
&
HardwareUtils
.
isLargeTablet
(
)
)
{
tintResId
=
R
.
color
.
menu_item_tint_private
;
}
else
{
tintResId
=
R
.
color
.
menu_item_tint
;
}
return
ResourcesCompat
.
getColor
(
getResources
(
)
tintResId
null
)
;
}
private
int
resolveBookmarkTitleID
(
final
boolean
isBookmark
)
{
return
(
isBookmark
?
R
.
string
.
bookmark_remove
:
R
.
string
.
bookmark
)
;
}
Override
public
boolean
onOptionsItemSelected
(
MenuItem
item
)
{
Tab
tab
=
null
;
Intent
intent
=
null
;
final
int
itemId
=
item
.
getItemId
(
)
;
String
extras
=
getResources
(
)
.
getResourceEntryName
(
itemId
)
;
if
(
TextUtils
.
equals
(
extras
"
new_private_tab
"
)
)
{
extras
=
"
new_tab
"
;
}
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
MENU
extras
)
;
mBrowserToolbar
.
cancelEdit
(
)
;
if
(
itemId
=
=
R
.
id
.
bookmark
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
final
String
extra
;
if
(
AboutPages
.
isAboutReader
(
tab
.
getURL
(
)
)
)
{
extra
=
"
bookmark_reader
"
;
}
else
{
extra
=
"
bookmark
"
;
}
final
boolean
isPrivate
=
tab
.
isPrivate
(
)
;
if
(
item
.
isChecked
(
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
UNSAVE
TelemetryContract
.
Method
.
MENU
extra
)
;
tab
.
removeBookmark
(
)
;
item
.
setTitle
(
resolveBookmarkTitleID
(
false
)
)
;
item
.
setIcon
(
resolveBookmarkIconDrawable
(
false
resolveMenuIconTint
(
isPrivate
)
)
)
;
}
else
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SAVE
TelemetryContract
.
Method
.
MENU
extra
)
;
tab
.
addBookmark
(
)
;
item
.
setTitle
(
resolveBookmarkTitleID
(
true
)
)
;
item
.
setIcon
(
resolveBookmarkIconDrawable
(
true
resolveMenuIconTint
(
isPrivate
)
)
)
;
}
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
share
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
String
url
=
tab
.
getURL
(
)
;
if
(
url
!
=
null
)
{
url
=
ReaderModeUtils
.
stripAboutReaderUrl
(
url
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHARE
TelemetryContract
.
Method
.
LIST
"
menu
"
)
;
IntentHelper
.
openUriExternal
(
url
"
text
/
plain
"
"
"
"
"
Intent
.
ACTION_SEND
tab
.
getDisplayTitle
(
)
false
)
;
}
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
reload
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
tab
.
doReload
(
false
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
back
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
tab
.
doBack
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
forward
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
tab
.
doForward
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
bookmarks_list
)
{
final
String
url
=
AboutPages
.
getURLForBuiltinPanelType
(
PanelType
.
BOOKMARKS
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
url
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
history_list
)
{
final
String
url
=
AboutPages
.
getURLForBuiltinPanelType
(
PanelType
.
COMBINED_HISTORY
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
url
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
save_as_pdf
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SAVE
TelemetryContract
.
Method
.
MENU
"
pdf
"
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
SaveAs
:
PDF
"
null
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
print
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SAVE
TelemetryContract
.
Method
.
MENU
"
print
"
)
;
PrintHelper
.
printPDF
(
this
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
view_page_source
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
GeckoBundle
args
=
new
GeckoBundle
(
1
)
;
args
.
putInt
(
"
tabId
"
tab
.
getId
(
)
)
;
getAppEventDispatcher
(
)
.
dispatch
(
"
Tab
:
ViewSource
"
args
)
;
}
if
(
itemId
=
=
R
.
id
.
settings
)
{
intent
=
new
Intent
(
this
GeckoPreferences
.
class
)
;
startActivityForResult
(
intent
ACTIVITY_REQUEST_PREFERENCES
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
help
)
{
final
String
VERSION
=
AppConstants
.
MOZ_APP_VERSION
;
final
String
OS
=
AppConstants
.
OS_TARGET
;
final
String
LOCALE
=
Locales
.
getLanguageTag
(
Locale
.
getDefault
(
)
)
;
final
String
URL
=
getResources
(
)
.
getString
(
R
.
string
.
help_link
VERSION
OS
LOCALE
)
;
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
URL
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
addons
|
|
itemId
=
=
R
.
id
.
addons_top_level
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
ADDONS
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
logins
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
LOGINS
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
downloads
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
DOWNLOADS
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
char_encoding
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
CharEncoding
:
Get
"
null
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
find_in_page
)
{
mFindInPageBar
.
show
(
mBrowserToolbar
.
isPrivateMode
(
)
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
desktop_mode
)
{
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
=
=
null
)
return
true
;
final
GeckoBundle
args
=
new
GeckoBundle
(
2
)
;
args
.
putBoolean
(
"
desktopMode
"
!
item
.
isChecked
(
)
)
;
args
.
putInt
(
"
tabId
"
selectedTab
.
getId
(
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
DesktopMode
:
Change
"
args
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
new_tab
)
{
addTab
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
new_private_tab
)
{
addPrivateTab
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
new_guest_session
)
{
showGuestModeDialog
(
GuestModeDialog
.
ENTERING
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
exit_guest_session
)
{
showGuestModeDialog
(
GuestModeDialog
.
LEAVING
)
;
return
true
;
}
if
(
onContextItemSelected
(
item
)
)
{
return
true
;
}
return
super
.
onOptionsItemSelected
(
item
)
;
}
Override
public
boolean
onMenuItemLongClick
(
MenuItem
item
)
{
if
(
item
.
getItemId
(
)
=
=
R
.
id
.
reload
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
tab
.
doReload
(
true
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
MENU
"
reload_force
"
)
;
}
return
true
;
}
return
super
.
onMenuItemLongClick
(
item
)
;
}
public
void
showGuestModeDialog
(
final
GuestModeDialog
type
)
{
if
(
(
type
=
=
GuestModeDialog
.
ENTERING
)
=
=
getProfile
(
)
.
inGuestMode
(
)
)
{
return
;
}
final
Prompt
ps
=
new
Prompt
(
this
new
Prompt
.
PromptCallback
(
)
{
Override
public
void
onPromptFinished
(
final
GeckoBundle
result
)
{
final
int
itemId
=
result
.
getInt
(
"
button
"
-
1
)
;
if
(
itemId
!
=
0
)
{
return
;
}
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
if
(
type
=
=
GuestModeDialog
.
ENTERING
)
{
GeckoProfile
.
enterGuestMode
(
context
)
;
}
else
{
GeckoProfile
.
leaveGuestMode
(
context
)
;
GuestSession
.
hideNotification
(
context
)
;
}
finishAndShutdown
(
true
)
;
}
}
)
;
Resources
res
=
getResources
(
)
;
ps
.
setButtons
(
new
String
[
]
{
res
.
getString
(
R
.
string
.
guest_session_dialog_continue
)
res
.
getString
(
R
.
string
.
guest_session_dialog_cancel
)
}
)
;
int
titleString
=
0
;
int
msgString
=
0
;
if
(
type
=
=
GuestModeDialog
.
ENTERING
)
{
titleString
=
R
.
string
.
new_guest_session_title
;
msgString
=
R
.
string
.
new_guest_session_text
;
}
else
{
titleString
=
R
.
string
.
exit_guest_session_title
;
msgString
=
R
.
string
.
exit_guest_session_text
;
}
ps
.
show
(
res
.
getString
(
titleString
)
res
.
getString
(
msgString
)
null
ListView
.
CHOICE_MODE_NONE
)
;
}
private
boolean
handleBackLongPress
(
)
{
TabHistoryFragment
frag
=
(
TabHistoryFragment
)
getSupportFragmentManager
(
)
.
findFragmentByTag
(
TAB_HISTORY_FRAGMENT_TAG
)
;
if
(
frag
!
=
null
)
{
return
true
;
}
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
!
tab
.
isEditing
(
)
)
{
return
tabHistoryController
.
showTabHistory
(
tab
TabHistoryController
.
HistoryAction
.
ALL
)
;
}
return
false
;
}
Override
public
boolean
onKeyLongPress
(
int
keyCode
KeyEvent
event
)
{
if
(
Versions
.
preN
&
&
keyCode
=
=
KeyEvent
.
KEYCODE_BACK
)
{
if
(
handleBackLongPress
(
)
)
{
return
true
;
}
}
return
super
.
onKeyLongPress
(
keyCode
event
)
;
}
SuppressWarnings
(
"
try
"
)
Override
protected
void
onNewIntent
(
Intent
externalIntent
)
{
if
(
mPipController
.
isInPipMode
(
)
)
{
startingIntentAfterPip
=
externalIntent
;
moveTaskToBack
(
true
)
;
startingIntentAfterPip
.
setFlags
(
Intent
.
FLAG_ACTIVITY_REORDER_TO_FRONT
)
;
setRequestedOrientationForCurrentActivity
(
ActivityInfo
.
SCREEN_ORIENTATION_FULL_SENSOR
)
;
return
;
}
final
SafeIntent
intent
=
new
SafeIntent
(
externalIntent
)
;
String
action
=
intent
.
getAction
(
)
;
final
boolean
isViewAction
=
Intent
.
ACTION_VIEW
.
equals
(
action
)
;
final
boolean
isBookmarkAction
=
GeckoApp
.
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
;
final
boolean
isTabQueueAction
=
TabQueueHelper
.
LOAD_URLS_ACTION
.
equals
(
action
)
;
final
boolean
isViewMultipleAction
=
ACTION_VIEW_MULTIPLE
.
equals
(
action
)
;
if
(
mInitialized
&
&
(
isViewAction
|
|
isBookmarkAction
)
)
{
mBrowserToolbar
.
cancelEdit
(
)
;
hideFirstrunPager
(
TelemetryContract
.
Method
.
NONE
)
;
if
(
isBookmarkAction
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
HOMESCREEN
)
;
}
}
showTabQueuePromptIfApplicable
(
intent
)
;
super
.
onNewIntent
(
externalIntent
)
;
if
(
AppConstants
.
MOZ_ANDROID_BEAM
&
&
NfcAdapter
.
ACTION_NDEF_DISCOVERED
.
equals
(
action
)
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
2
)
;
data
.
putString
(
"
uri
"
intent
.
getDataString
(
)
)
;
data
.
putString
(
"
flags
"
"
OPEN_NEWTAB
"
)
;
getAppEventDispatcher
(
)
.
dispatch
(
"
Tab
:
OpenUri
"
data
)
;
}
if
(
GuestSession
.
NOTIFICATION_INTENT
.
equals
(
action
)
)
{
GuestSession
.
onNotificationIntentReceived
(
this
)
;
}
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
mInitialized
&
&
isTabQueueAction
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
NOTIFICATION
"
tabqueue
"
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
openQueuedTabs
(
)
;
}
}
)
;
}
if
(
isViewMultipleAction
)
{
openMultipleTabsFromIntent
(
intent
)
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onNewIntent
(
this
intent
)
;
}
if
(
!
mInitialized
|
|
!
Intent
.
ACTION_MAIN
.
equals
(
action
)
)
{
return
;
}
final
String
keyName
=
getPackageName
(
)
+
"
.
feedback_launch_count
"
;
try
(
StrictModeContext
unused
=
StrictModeContext
.
allowDiskReads
(
)
)
{
SharedPreferences
settings
=
getPreferences
(
Activity
.
MODE_PRIVATE
)
;
int
launchCount
=
settings
.
getInt
(
keyName
0
)
;
if
(
launchCount
<
FEEDBACK_LAUNCH_COUNT
)
{
launchCount
+
+
;
settings
.
edit
(
)
.
putInt
(
keyName
launchCount
)
.
apply
(
)
;
if
(
launchCount
=
=
FEEDBACK_LAUNCH_COUNT
)
{
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Feedback
:
Show
"
null
)
;
}
}
}
}
public
void
openUrls
(
List
<
String
>
urls
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putStringArray
(
"
urls
"
urls
.
toArray
(
new
String
[
urls
.
size
(
)
]
)
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Tabs
:
OpenMultiple
"
data
)
;
}
private
void
showTabQueuePromptIfApplicable
(
final
SafeIntent
intent
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
mInitialized
&
&
Intent
.
ACTION_VIEW
.
equals
(
intent
.
getAction
(
)
)
&
&
!
intent
.
getBooleanExtra
(
BrowserContract
.
SKIP_TAB_QUEUE_FLAG
false
)
&
&
TabQueueHelper
.
shouldShowTabQueuePrompt
(
BrowserApp
.
this
)
)
{
Intent
promptIntent
=
new
Intent
(
BrowserApp
.
this
TabQueuePrompt
.
class
)
;
startActivityForResult
(
promptIntent
ACTIVITY_REQUEST_TAB_QUEUE
)
;
}
}
}
)
;
}
Override
public
void
onUrlOpen
(
String
url
EnumSet
<
OnUrlOpenListener
.
Flags
>
flags
)
{
onUrlOpenWithReferrer
(
url
null
flags
)
;
}
Override
public
void
onUrlOpenWithReferrer
(
final
String
url
Nullable
final
String
referrerUri
final
EnumSet
<
OnUrlOpenListener
.
Flags
>
flags
)
{
if
(
flags
.
contains
(
OnUrlOpenListener
.
Flags
.
OPEN_WITH_INTENT
)
)
{
Intent
intent
=
new
Intent
(
Intent
.
ACTION_VIEW
)
;
intent
.
setData
(
Uri
.
parse
(
url
)
)
;
startActivity
(
intent
)
;
}
else
{
final
String
pageURL
;
if
(
!
flags
.
contains
(
OnUrlOpenListener
.
Flags
.
NO_READER_VIEW
)
)
{
pageURL
=
SavedReaderViewHelper
.
getReaderURLIfCached
(
this
url
)
;
}
else
{
pageURL
=
url
;
}
if
(
!
maybeSwitchToTab
(
pageURL
flags
)
)
{
openUrlAndStopEditingWithReferrer
(
pageURL
referrerUri
)
;
clearSelectedTabApplicationId
(
)
;
}
}
}
Override
public
void
onUrlOpenInBackground
(
final
String
url
EnumSet
<
OnUrlOpenInBackgroundListener
.
Flags
>
flags
)
{
onUrlOpenInBackgroundWithReferrer
(
url
null
flags
)
;
}
Override
public
void
onUrlOpenInBackgroundWithReferrer
(
final
String
url
Nullable
final
String
referrerUri
final
EnumSet
<
OnUrlOpenInBackgroundListener
.
Flags
>
flags
)
{
if
(
url
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
url
must
not
be
null
"
)
;
}
if
(
flags
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
flags
must
not
be
null
"
)
;
}
final
String
pageURL
=
SavedReaderViewHelper
.
getReaderURLIfCached
(
this
url
)
;
final
boolean
isPrivate
=
flags
.
contains
(
OnUrlOpenInBackgroundListener
.
Flags
.
PRIVATE
)
;
int
loadFlags
=
Tabs
.
LOADURL_NEW_TAB
|
Tabs
.
LOADURL_BACKGROUND
;
if
(
isPrivate
)
{
loadFlags
|
=
Tabs
.
LOADURL_PRIVATE
;
}
final
Tab
newTab
=
Tabs
.
getInstance
(
)
.
loadUrl
(
pageURL
null
referrerUri
Tabs
.
INVALID_TAB_ID
null
loadFlags
)
;
final
int
newTabId
=
newTab
.
getId
(
)
;
final
SnackbarBuilder
.
SnackbarCallback
callback
=
new
SnackbarBuilder
.
SnackbarCallback
(
)
{
Override
public
void
onClick
(
View
v
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHOW
TelemetryContract
.
Method
.
TOAST
"
switchtab
"
)
;
maybeSwitchToTab
(
newTabId
)
;
}
}
;
final
String
message
=
isPrivate
?
getResources
(
)
.
getString
(
R
.
string
.
new_private_tab_opened
)
:
getResources
(
)
.
getString
(
R
.
string
.
new_tab_opened
)
;
final
String
buttonMessage
=
getResources
(
)
.
getString
(
R
.
string
.
switch_button_message
)
;
SnackbarBuilder
.
builder
(
this
)
.
message
(
message
)
.
duration
(
Snackbar
.
LENGTH_LONG
)
.
action
(
buttonMessage
)
.
callback
(
callback
)
.
buildAndShow
(
)
;
}
Override
public
void
onSearch
(
SearchEngine
engine
final
String
text
final
TelemetryContract
.
Method
method
)
{
if
(
!
mBrowserToolbar
.
isPrivateMode
(
)
)
{
storeSearchQuery
(
text
)
;
}
final
String
identifierToRecord
=
(
engine
.
identifier
!
=
null
)
?
engine
.
identifier
:
"
other
"
;
recordSearch
(
GeckoSharedPrefs
.
forProfile
(
this
)
identifierToRecord
method
)
;
openUrlAndStopEditing
(
text
engine
.
name
)
;
}
Override
public
void
onEditSuggestion
(
String
suggestion
)
{
mBrowserToolbar
.
onEditSuggestion
(
suggestion
)
;
}
Override
public
int
getLayout
(
)
{
return
R
.
layout
.
gecko_app
;
}
Override
public
View
getDoorhangerOverlay
(
)
{
return
doorhangerOverlay
;
}
public
SearchEngineManager
getSearchEngineManager
(
)
{
return
mSearchEngineManager
;
}
RobocopTarget
public
ReadingListHelper
getReadingListHelper
(
)
{
return
mReadingListHelper
;
}
Override
protected
ActionModePresenter
getTextSelectPresenter
(
)
{
return
this
;
}
Override
public
void
startActionMode
(
final
ActionModeCompat
.
Callback
callback
)
{
if
(
mActionMode
=
=
null
)
{
mActionBarFlipper
.
showNext
(
)
;
DynamicToolbarAnimator
toolbar
=
mLayerView
.
getDynamicToolbarAnimator
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
&
&
!
isToolbarChromeVisible
(
)
)
{
toggleToolbarChrome
(
true
)
;
mShowingToolbarChromeForActionBar
=
true
;
}
mDynamicToolbar
.
setPinned
(
true
PinReason
.
ACTION_MODE
)
;
}
else
{
mActionMode
.
finish
(
)
;
}
mActionMode
=
new
ActionModeCompat
(
BrowserApp
.
this
callback
mActionBar
)
;
if
(
callback
.
onCreateActionMode
(
mActionMode
mActionMode
.
getMenu
(
)
)
)
{
mActionMode
.
invalidate
(
)
;
}
mActionMode
.
animateIn
(
)
;
}
Override
public
void
endActionMode
(
)
{
if
(
mActionMode
=
=
null
)
{
return
;
}
mActionMode
.
finish
(
)
;
mActionMode
=
null
;
mDynamicToolbar
.
setPinned
(
false
PinReason
.
ACTION_MODE
)
;
mActionBarFlipper
.
showPrevious
(
)
;
if
(
mShowingToolbarChromeForActionBar
)
{
toggleToolbarChrome
(
false
)
;
mShowingToolbarChromeForActionBar
=
false
;
}
}
public
static
interface
TabStripInterface
{
public
void
refresh
(
)
;
void
tabStripIsCovered
(
boolean
covered
)
;
void
setOnTabChangedListener
(
OnTabAddedOrRemovedListener
listener
)
;
interface
OnTabAddedOrRemovedListener
{
void
onTabChanged
(
)
;
}
}
Override
protected
void
recordStartupActionTelemetry
(
final
String
passedURL
final
String
action
)
{
final
TelemetryContract
.
Method
method
;
if
(
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
method
=
TelemetryContract
.
Method
.
HOMESCREEN
;
}
else
if
(
passedURL
=
=
null
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
TelemetryContract
.
Method
.
HOMESCREEN
"
launcher
"
)
;
method
=
TelemetryContract
.
Method
.
HOMESCREEN
;
}
else
{
method
=
TelemetryContract
.
Method
.
INTENT
;
}
if
(
GeckoProfile
.
get
(
this
)
.
inGuestMode
(
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
method
"
guest
"
)
;
}
else
if
(
Restrictions
.
isRestrictedProfile
(
this
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
method
"
restricted
"
)
;
}
}
public
void
showEditBookmarkDialog
(
String
pageUrl
)
{
if
(
BookmarkUtils
.
isEnabled
(
this
)
)
{
BookmarkEditFragment
dialog
=
BookmarkEditFragment
.
newInstance
(
pageUrl
)
;
dialog
.
show
(
getSupportFragmentManager
(
)
"
edit
-
bookmark
"
)
;
}
else
{
new
EditBookmarkDialog
(
this
)
.
show
(
pageUrl
)
;
}
}
Override
public
void
onEditBookmark
(
NonNull
Bundle
bundle
)
{
new
EditBookmarkTask
(
this
bundle
)
.
execute
(
)
;
}
Override
public
void
onLightweightThemeChanged
(
)
{
refreshStatusBarColor
(
)
;
}
Override
public
void
onLightweightThemeReset
(
)
{
refreshStatusBarColor
(
)
;
}
private
void
refreshStatusBarColor
(
)
{
final
boolean
isPrivate
=
mBrowserToolbar
.
isPrivateMode
(
)
;
WindowUtil
.
setStatusBarColor
(
BrowserApp
.
this
isPrivate
)
;
}
Override
public
void
onOnboardingProcessStarted
(
)
{
if
(
splashScreen
=
=
null
)
{
splashScreen
=
getSplashScreen
(
)
;
}
splashScreen
.
show
(
OnboardingHelper
.
DELAY_SHOW_DEFAULT_ONBOARDING
)
;
}
Override
public
void
onOnboardingScreensVisible
(
)
{
mHomeScreenContainer
.
setVisibility
(
View
.
VISIBLE
)
;
if
(
HardwareUtils
.
isTablet
(
)
)
{
mTabStrip
.
setOnTabChangedListener
(
new
BrowserApp
.
TabStripInterface
.
OnTabAddedOrRemovedListener
(
)
{
Override
public
void
onTabChanged
(
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
BUTTON
)
;
mTabStrip
.
setOnTabChangedListener
(
null
)
;
}
}
)
;
}
}
Override
public
void
onFinishedOnboarding
(
final
boolean
showBrowserHint
)
{
if
(
showBrowserHint
&
&
!
Tabs
.
hasHomepage
(
this
)
)
{
enterEditingMode
(
)
;
}
}
}
