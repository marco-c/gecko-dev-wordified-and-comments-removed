package
org
.
mozilla
.
gecko
;
import
android
.
Manifest
;
import
android
.
app
.
DownloadManager
;
import
android
.
os
.
Environment
;
import
android
.
support
.
annotation
.
CheckResult
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
graphics
.
Rect
;
import
org
.
json
.
JSONArray
;
import
org
.
mozilla
.
gecko
.
activitystream
.
ActivityStream
;
import
org
.
mozilla
.
gecko
.
adjust
.
AdjustHelperInterface
;
import
org
.
mozilla
.
gecko
.
adjust
.
AttributionHelperListener
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
AppConstants
.
Versions
;
import
org
.
mozilla
.
gecko
.
DynamicToolbar
.
VisibilityTransition
;
import
org
.
mozilla
.
gecko
.
Tabs
.
TabEvents
;
import
org
.
mozilla
.
gecko
.
animation
.
PropertyAnimator
;
import
org
.
mozilla
.
gecko
.
animation
.
ViewHelper
;
import
org
.
mozilla
.
gecko
.
cleanup
.
FileCleanupController
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
SuggestedSites
;
import
org
.
mozilla
.
gecko
.
delegates
.
BrowserAppDelegate
;
import
org
.
mozilla
.
gecko
.
delegates
.
OfflineTabStatusDelegate
;
import
org
.
mozilla
.
gecko
.
delegates
.
ScreenshotDelegate
;
import
org
.
mozilla
.
gecko
.
distribution
.
Distribution
;
import
org
.
mozilla
.
gecko
.
distribution
.
DistributionStoreCallback
;
import
org
.
mozilla
.
gecko
.
distribution
.
PartnerBrowserCustomizationsClient
;
import
org
.
mozilla
.
gecko
.
dlc
.
DownloadContentService
;
import
org
.
mozilla
.
gecko
.
favicons
.
Favicons
;
import
org
.
mozilla
.
gecko
.
favicons
.
OnFaviconLoadedListener
;
import
org
.
mozilla
.
gecko
.
favicons
.
decoders
.
IconDirectoryEntry
;
import
org
.
mozilla
.
gecko
.
feeds
.
ContentNotificationsDelegate
;
import
org
.
mozilla
.
gecko
.
feeds
.
FeedService
;
import
org
.
mozilla
.
gecko
.
firstrun
.
FirstrunAnimationContainer
;
import
org
.
mozilla
.
gecko
.
gfx
.
DynamicToolbarAnimator
;
import
org
.
mozilla
.
gecko
.
gfx
.
DynamicToolbarAnimator
.
PinReason
;
import
org
.
mozilla
.
gecko
.
gfx
.
ImmutableViewportMetrics
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
;
import
org
.
mozilla
.
gecko
.
home
.
BrowserSearch
;
import
org
.
mozilla
.
gecko
.
home
.
HomeBanner
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfig
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfig
.
PanelType
;
import
org
.
mozilla
.
gecko
.
home
.
HomeConfigPrefsBackend
;
import
org
.
mozilla
.
gecko
.
home
.
HomeFragment
;
import
org
.
mozilla
.
gecko
.
home
.
HomePager
.
OnUrlOpenInBackgroundListener
;
import
org
.
mozilla
.
gecko
.
home
.
HomePager
.
OnUrlOpenListener
;
import
org
.
mozilla
.
gecko
.
home
.
HomePanelsManager
;
import
org
.
mozilla
.
gecko
.
home
.
HomeScreen
;
import
org
.
mozilla
.
gecko
.
home
.
SearchEngine
;
import
org
.
mozilla
.
gecko
.
javaaddons
.
JavaAddonManager
;
import
org
.
mozilla
.
gecko
.
media
.
VideoPlayer
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenu
;
import
org
.
mozilla
.
gecko
.
menu
.
GeckoMenuItem
;
import
org
.
mozilla
.
gecko
.
mozglue
.
SafeIntent
;
import
org
.
mozilla
.
gecko
.
notifications
.
NotificationClient
;
import
org
.
mozilla
.
gecko
.
notifications
.
ServiceNotificationClient
;
import
org
.
mozilla
.
gecko
.
overlays
.
ui
.
ShareDialog
;
import
org
.
mozilla
.
gecko
.
permissions
.
Permissions
;
import
org
.
mozilla
.
gecko
.
preferences
.
ClearOnShutdownPref
;
import
org
.
mozilla
.
gecko
.
preferences
.
GeckoPreferences
;
import
org
.
mozilla
.
gecko
.
promotion
.
AddToHomeScreenPromotion
;
import
org
.
mozilla
.
gecko
.
delegates
.
BookmarkStateChangeDelegate
;
import
org
.
mozilla
.
gecko
.
promotion
.
ReaderViewBookmarkPromotion
;
import
org
.
mozilla
.
gecko
.
prompts
.
Prompt
;
import
org
.
mozilla
.
gecko
.
reader
.
SavedReaderViewHelper
;
import
org
.
mozilla
.
gecko
.
reader
.
ReaderModeUtils
;
import
org
.
mozilla
.
gecko
.
reader
.
ReadingListHelper
;
import
org
.
mozilla
.
gecko
.
restrictions
.
Restrictable
;
import
org
.
mozilla
.
gecko
.
restrictions
.
RestrictedProfileConfiguration
;
import
org
.
mozilla
.
gecko
.
restrictions
.
Restrictions
;
import
org
.
mozilla
.
gecko
.
search
.
SearchEngineManager
;
import
org
.
mozilla
.
gecko
.
sync
.
repositories
.
android
.
FennecTabsRepository
;
import
org
.
mozilla
.
gecko
.
tabqueue
.
TabQueueHelper
;
import
org
.
mozilla
.
gecko
.
tabqueue
.
TabQueuePrompt
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryController
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryController
.
OnShowTabHistory
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryFragment
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabHistoryPage
;
import
org
.
mozilla
.
gecko
.
tabs
.
TabsPanel
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryUploadService
;
import
org
.
mozilla
.
gecko
.
telemetry
.
TelemetryCorePingDelegate
;
import
org
.
mozilla
.
gecko
.
telemetry
.
measurements
.
SearchCountMeasurements
;
import
org
.
mozilla
.
gecko
.
toolbar
.
AutocompleteHandler
;
import
org
.
mozilla
.
gecko
.
toolbar
.
BrowserToolbar
;
import
org
.
mozilla
.
gecko
.
toolbar
.
BrowserToolbar
.
TabEditingState
;
import
org
.
mozilla
.
gecko
.
toolbar
.
ToolbarProgressView
;
import
org
.
mozilla
.
gecko
.
trackingprotection
.
TrackingProtectionPrompt
;
import
org
.
mozilla
.
gecko
.
updater
.
PostUpdateHandler
;
import
org
.
mozilla
.
gecko
.
updater
.
UpdateServiceHelper
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
Clipboard
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
FloatUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GamepadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
org
.
mozilla
.
gecko
.
util
.
MenuUtils
;
import
org
.
mozilla
.
gecko
.
util
.
NativeEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
NativeJSObject
;
import
org
.
mozilla
.
gecko
.
util
.
PrefUtils
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
widget
.
AnchoredPopup
;
import
org
.
mozilla
.
gecko
.
widget
.
GeckoActionProvider
;
import
android
.
app
.
Activity
;
import
android
.
app
.
AlertDialog
;
import
android
.
app
.
Notification
;
import
android
.
app
.
NotificationManager
;
import
android
.
app
.
PendingIntent
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
content
.
DialogInterface
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
ResolveInfo
;
import
android
.
content
.
res
.
Resources
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
drawable
.
BitmapDrawable
;
import
android
.
net
.
Uri
;
import
android
.
nfc
.
NdefMessage
;
import
android
.
nfc
.
NdefRecord
;
import
android
.
nfc
.
NfcAdapter
;
import
android
.
nfc
.
NfcEvent
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
StrictMode
;
import
android
.
support
.
design
.
widget
.
Snackbar
;
import
android
.
support
.
v4
.
app
.
Fragment
;
import
android
.
support
.
v4
.
app
.
FragmentManager
;
import
android
.
support
.
v4
.
app
.
NotificationCompat
;
import
android
.
support
.
v4
.
view
.
MenuItemCompat
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Base64
;
import
android
.
util
.
Base64OutputStream
;
import
android
.
util
.
Log
;
import
android
.
view
.
InputDevice
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
Menu
;
import
android
.
view
.
MenuInflater
;
import
android
.
view
.
MenuItem
;
import
android
.
view
.
MotionEvent
;
import
android
.
view
.
SubMenu
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
ViewStub
;
import
android
.
view
.
ViewTreeObserver
;
import
android
.
view
.
Window
;
import
android
.
view
.
animation
.
Interpolator
;
import
android
.
widget
.
Button
;
import
android
.
widget
.
ListView
;
import
android
.
widget
.
RelativeLayout
;
import
android
.
widget
.
ViewFlipper
;
import
com
.
keepsafe
.
switchboard
.
AsyncConfigLoader
;
import
com
.
keepsafe
.
switchboard
.
SwitchBoard
;
import
android
.
animation
.
Animator
;
import
android
.
animation
.
ObjectAnimator
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
net
.
URLEncoder
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
EnumSet
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Vector
;
import
java
.
util
.
regex
.
Pattern
;
public
class
BrowserApp
extends
GeckoApp
implements
TabsPanel
.
TabsLayoutChangeListener
PropertyAnimator
.
PropertyAnimationListener
View
.
OnKeyListener
LayerView
.
DynamicToolbarListener
BrowserSearch
.
OnSearchListener
BrowserSearch
.
OnEditSuggestionListener
OnUrlOpenListener
OnUrlOpenInBackgroundListener
AnchoredPopup
.
OnVisibilityChangeListener
ActionModeCompat
.
Presenter
LayoutInflater
.
Factory
{
private
static
final
String
LOGTAG
=
"
GeckoBrowserApp
"
;
private
static
final
int
TABS_ANIMATION_DURATION
=
450
;
private
static
final
String
INTENT_KEY_SWITCHBOARD_SERVER
=
"
switchboard
-
server
"
;
private
static
final
String
SWITCHBOARD_SERVER
=
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
/
buckets
/
fennec
/
collections
/
experiments
/
records
"
;
private
static
final
String
STATE_ABOUT_HOME_TOP_PADDING
=
"
abouthome_top_padding
"
;
private
static
final
String
BROWSER_SEARCH_TAG
=
"
browser_search
"
;
private
static
final
int
ACTIVITY_REQUEST_PREFERENCES
=
1001
;
private
static
final
int
ACTIVITY_REQUEST_TAB_QUEUE
=
2001
;
public
static
final
int
ACTIVITY_REQUEST_FIRST_READERVIEW_BOOKMARK
=
3001
;
public
static
final
int
ACTIVITY_RESULT_FIRST_READERVIEW_BOOKMARKS_GOTO_BOOKMARKS
=
3002
;
public
static
final
int
ACTIVITY_RESULT_FIRST_READERVIEW_BOOKMARKS_IGNORE
=
3003
;
public
static
final
int
ACTIVITY_REQUEST_TRIPLE_READERVIEW
=
4001
;
public
static
final
int
ACTIVITY_RESULT_TRIPLE_READERVIEW_ADD_BOOKMARK
=
4002
;
public
static
final
int
ACTIVITY_RESULT_TRIPLE_READERVIEW_IGNORE
=
4003
;
public
static
final
String
ACTION_VIEW_MULTIPLE
=
AppConstants
.
ANDROID_PACKAGE_NAME
+
"
.
action
.
VIEW_MULTIPLE
"
;
RobocopTarget
public
static
final
String
EXTRA_SKIP_STARTPANE
=
"
skipstartpane
"
;
private
static
final
String
EOL_NOTIFIED
=
"
eol_notified
"
;
private
BrowserSearch
mBrowserSearch
;
private
View
mBrowserSearchContainer
;
public
ViewGroup
mBrowserChrome
;
public
ViewFlipper
mActionBarFlipper
;
public
ActionModeCompatView
mActionBar
;
private
VideoPlayer
mVideoPlayer
;
private
BrowserToolbar
mBrowserToolbar
;
private
View
mDoorhangerOverlay
;
private
TabStripInterface
mTabStrip
;
private
ToolbarProgressView
mProgressView
;
private
FirstrunAnimationContainer
mFirstrunAnimationContainer
;
private
HomeScreen
mHomeScreen
;
private
TabsPanel
mTabsPanel
;
private
ViewGroup
mHomeScreenContainer
;
private
ActionModeCompat
mActionMode
;
private
TabHistoryController
tabHistoryController
;
private
ZoomedView
mZoomedView
;
private
static
final
int
GECKO_TOOLS_MENU
=
-
1
;
private
static
final
int
ADDON_MENU_OFFSET
=
1000
;
public
static
final
String
TAB_HISTORY_FRAGMENT_TAG
=
"
tabHistoryFragment
"
;
private
static
class
MenuItemInfo
{
public
int
id
;
public
String
label
;
public
boolean
checkable
;
public
boolean
checked
;
public
boolean
enabled
=
true
;
public
boolean
visible
=
true
;
public
int
parent
;
public
boolean
added
;
}
public
static
enum
GuestModeDialog
{
ENTERING
LEAVING
}
private
Vector
<
MenuItemInfo
>
mAddonMenuItemsCache
;
private
PropertyAnimator
mMainLayoutAnimator
;
private
static
final
Interpolator
sTabsInterpolator
=
new
Interpolator
(
)
{
Override
public
float
getInterpolation
(
float
t
)
{
t
-
=
1
.
0f
;
return
t
*
t
*
t
*
t
*
t
+
1
.
0f
;
}
}
;
private
FindInPageBar
mFindInPageBar
;
private
MediaCastingBar
mMediaCastingBar
;
private
static
final
int
FEEDBACK_LAUNCH_COUNT
=
15
;
private
int
mToolbarHeight
;
private
SharedPreferencesHelper
mSharedPreferencesHelper
;
private
ReadingListHelper
mReadingListHelper
;
private
AccountsHelper
mAccountsHelper
;
private
Integer
mTargetTabForEditingMode
;
private
final
TabEditingState
mLastTabEditingState
=
new
TabEditingState
(
)
;
private
boolean
mHideWebContentOnAnimationEnd
;
private
final
DynamicToolbar
mDynamicToolbar
=
new
DynamicToolbar
(
)
;
private
final
TelemetryCorePingDelegate
mTelemetryCorePingDelegate
=
new
TelemetryCorePingDelegate
(
)
;
private
final
List
<
BrowserAppDelegate
>
delegates
=
Collections
.
unmodifiableList
(
Arrays
.
asList
(
(
BrowserAppDelegate
)
new
AddToHomeScreenPromotion
(
)
(
BrowserAppDelegate
)
new
ScreenshotDelegate
(
)
(
BrowserAppDelegate
)
new
BookmarkStateChangeDelegate
(
)
(
BrowserAppDelegate
)
new
ReaderViewBookmarkPromotion
(
)
(
BrowserAppDelegate
)
new
ContentNotificationsDelegate
(
)
(
BrowserAppDelegate
)
new
PostUpdateHandler
(
)
mTelemetryCorePingDelegate
new
OfflineTabStatusDelegate
(
)
)
)
;
NonNull
private
SearchEngineManager
mSearchEngineManager
;
private
boolean
mHasResumed
;
Override
public
View
onCreateView
(
final
String
name
final
Context
context
final
AttributeSet
attrs
)
{
final
View
view
;
if
(
BrowserToolbar
.
class
.
getName
(
)
.
equals
(
name
)
)
{
view
=
BrowserToolbar
.
create
(
context
attrs
)
;
}
else
if
(
TabsPanel
.
TabsLayout
.
class
.
getName
(
)
.
equals
(
name
)
)
{
view
=
TabsPanel
.
createTabsLayout
(
context
attrs
)
;
}
else
{
view
=
super
.
onCreateView
(
name
context
attrs
)
;
}
return
view
;
}
Override
public
void
onTabChanged
(
Tab
tab
TabEvents
msg
String
data
)
{
if
(
tab
=
=
null
)
{
if
(
msg
!
=
Tabs
.
TabEvents
.
RESTORED
)
{
throw
new
IllegalArgumentException
(
"
onTabChanged
:
"
+
msg
+
"
must
specify
a
tab
.
"
)
;
}
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
updateHomePagerForTab
(
selectedTab
)
;
}
return
;
}
Log
.
d
(
LOGTAG
"
BrowserApp
.
onTabChanged
:
"
+
tab
.
getId
(
)
+
"
:
"
+
msg
)
;
switch
(
msg
)
{
case
SELECTED
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
&
&
mDynamicToolbar
.
isEnabled
(
)
)
{
final
VisibilityTransition
transition
=
(
tab
.
getShouldShowToolbarWithoutAnimationOnFirstSelection
(
)
)
?
VisibilityTransition
.
IMMEDIATE
:
VisibilityTransition
.
ANIMATE
;
mDynamicToolbar
.
setVisible
(
true
transition
)
;
tab
.
setShouldShowToolbarWithoutAnimationOnFirstSelection
(
false
)
;
}
case
LOCATION_CHANGE
:
if
(
mZoomedView
!
=
null
)
{
mZoomedView
.
stopZoomDisplay
(
false
)
;
}
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
updateHomePagerForTab
(
tab
)
;
}
mDynamicToolbar
.
persistTemporaryVisibility
(
)
;
break
;
case
START
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
invalidateOptionsMenu
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
break
;
case
LOAD_ERROR
:
case
STOP
:
case
MENU_UPDATED
:
if
(
Tabs
.
getInstance
(
)
.
isSelectedTab
(
tab
)
)
{
invalidateOptionsMenu
(
)
;
}
break
;
case
PAGE_SHOW
:
tab
.
loadFavicon
(
)
;
break
;
case
UNSELECTED
:
if
(
tab
.
isEditing
(
)
)
{
tab
.
getEditingState
(
)
.
copyFrom
(
mLastTabEditingState
)
;
}
break
;
}
if
(
HardwareUtils
.
isTablet
(
)
&
&
msg
=
=
TabEvents
.
SELECTED
)
{
updateEditingModeForTab
(
tab
)
;
}
super
.
onTabChanged
(
tab
msg
data
)
;
}
private
void
updateEditingModeForTab
(
final
Tab
selectedTab
)
{
if
(
!
Tabs
.
getInstance
(
)
.
isSelectedTab
(
selectedTab
)
)
{
Log
.
w
(
LOGTAG
"
updateEditingModeForTab
:
Given
tab
is
expected
to
be
selected
tab
"
)
;
}
saveTabEditingState
(
mLastTabEditingState
)
;
if
(
selectedTab
.
isEditing
(
)
)
{
enterEditingMode
(
)
;
restoreTabEditingState
(
selectedTab
.
getEditingState
(
)
)
;
}
else
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
}
private
void
saveTabEditingState
(
final
TabEditingState
editingState
)
{
mBrowserToolbar
.
saveTabEditingState
(
editingState
)
;
editingState
.
setIsBrowserSearchShown
(
mBrowserSearch
.
getUserVisibleHint
(
)
)
;
}
private
void
restoreTabEditingState
(
final
TabEditingState
editingState
)
{
mBrowserToolbar
.
restoreTabEditingState
(
editingState
)
;
if
(
editingState
.
isBrowserSearchShown
(
)
)
{
showBrowserSearch
(
)
;
}
else
{
hideBrowserSearch
(
)
;
}
}
Override
public
boolean
onKey
(
View
v
int
keyCode
KeyEvent
event
)
{
if
(
AndroidGamepadManager
.
handleKeyEvent
(
event
)
)
{
return
true
;
}
if
(
event
.
getAction
(
)
!
=
KeyEvent
.
ACTION_DOWN
)
{
return
false
;
}
if
(
(
event
.
getSource
(
)
&
InputDevice
.
SOURCE_GAMEPAD
)
=
=
InputDevice
.
SOURCE_GAMEPAD
)
{
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_BUTTON_Y
:
if
(
mBrowserChrome
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
{
if
(
mDynamicToolbar
.
isEnabled
(
)
&
&
!
isHomePagerVisible
(
)
)
{
mDynamicToolbar
.
setVisible
(
false
VisibilityTransition
.
ANIMATE
)
;
if
(
mLayerView
!
=
null
)
{
mLayerView
.
requestFocus
(
)
;
}
}
else
{
mBrowserToolbar
.
requestFocusFromTouch
(
)
;
}
}
else
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
mBrowserToolbar
.
requestFocusFromTouch
(
)
;
}
return
true
;
case
KeyEvent
.
KEYCODE_BUTTON_L1
:
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
doBack
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_BUTTON_R1
:
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
doForward
(
)
;
return
true
;
}
}
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
Versions
.
feature11Plus
&
&
tab
!
=
null
&
&
event
.
isCtrlPressed
(
)
)
{
switch
(
keyCode
)
{
case
KeyEvent
.
KEYCODE_LEFT_BRACKET
:
tab
.
doBack
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_RIGHT_BRACKET
:
tab
.
doForward
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_R
:
tab
.
doReload
(
false
)
;
return
true
;
case
KeyEvent
.
KEYCODE_PERIOD
:
tab
.
doStop
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_T
:
addTab
(
)
;
return
true
;
case
KeyEvent
.
KEYCODE_W
:
Tabs
.
getInstance
(
)
.
closeTab
(
tab
)
;
return
true
;
case
KeyEvent
.
KEYCODE_F
:
mFindInPageBar
.
show
(
)
;
return
true
;
}
}
return
false
;
}
Override
public
boolean
onKeyDown
(
int
keyCode
KeyEvent
event
)
{
if
(
!
mBrowserToolbar
.
isEditing
(
)
&
&
onKey
(
null
keyCode
event
)
)
{
return
true
;
}
return
super
.
onKeyDown
(
keyCode
event
)
;
}
Override
public
boolean
onKeyUp
(
int
keyCode
KeyEvent
event
)
{
if
(
AndroidGamepadManager
.
handleKeyEvent
(
event
)
)
{
return
true
;
}
return
super
.
onKeyUp
(
keyCode
event
)
;
}
Override
public
void
onCreate
(
Bundle
savedInstanceState
)
{
if
(
!
HardwareUtils
.
isSupportedSystem
(
)
)
{
super
.
onCreate
(
savedInstanceState
)
;
return
;
}
final
Intent
intent
=
getIntent
(
)
;
final
boolean
isInAutomation
=
getIsInAutomationFromEnvironment
(
intent
)
;
(
(
GeckoApplication
)
getApplication
(
)
)
.
prepareLightweightTheme
(
)
;
super
.
onCreate
(
savedInstanceState
)
;
final
Context
appContext
=
getApplicationContext
(
)
;
initSwitchboard
(
this
intent
isInAutomation
)
;
initTelemetryUploader
(
isInAutomation
)
;
mBrowserChrome
=
(
ViewGroup
)
findViewById
(
R
.
id
.
browser_chrome
)
;
mActionBarFlipper
=
(
ViewFlipper
)
findViewById
(
R
.
id
.
browser_actionbar
)
;
mActionBar
=
(
ActionModeCompatView
)
findViewById
(
R
.
id
.
actionbar
)
;
mVideoPlayer
=
(
VideoPlayer
)
findViewById
(
R
.
id
.
video_player
)
;
mVideoPlayer
.
setFullScreenListener
(
new
VideoPlayer
.
FullScreenListener
(
)
{
Override
public
void
onFullScreenChanged
(
boolean
fullScreen
)
{
mVideoPlayer
.
setFullScreen
(
fullScreen
)
;
setFullScreen
(
fullScreen
)
;
}
}
)
;
mBrowserToolbar
=
(
BrowserToolbar
)
findViewById
(
R
.
id
.
browser_toolbar
)
;
mBrowserToolbar
.
setTouchEventInterceptor
(
new
TouchEventInterceptor
(
)
{
Override
public
boolean
onInterceptTouchEvent
(
View
view
MotionEvent
event
)
{
mTextSelection
.
dismiss
(
)
;
return
false
;
}
Override
public
boolean
onTouch
(
View
v
MotionEvent
event
)
{
return
false
;
}
}
)
;
mProgressView
=
(
ToolbarProgressView
)
findViewById
(
R
.
id
.
progress
)
;
mBrowserToolbar
.
setProgressBar
(
mProgressView
)
;
tabHistoryController
=
new
TabHistoryController
(
new
OnShowTabHistory
(
)
{
Override
public
void
onShowHistory
(
final
List
<
TabHistoryPage
>
historyPageList
final
int
toIndex
)
{
runOnUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
TabHistoryFragment
fragment
=
TabHistoryFragment
.
newInstance
(
historyPageList
toIndex
)
;
final
FragmentManager
fragmentManager
=
getSupportFragmentManager
(
)
;
GeckoAppShell
.
vibrateOnHapticFeedbackEnabled
(
getResources
(
)
.
getIntArray
(
R
.
array
.
long_press_vibrate_msec
)
)
;
fragment
.
show
(
R
.
id
.
tab_history_panel
fragmentManager
.
beginTransaction
(
)
TAB_HISTORY_FRAGMENT_TAG
)
;
}
}
)
;
}
}
)
;
mBrowserToolbar
.
setTabHistoryController
(
tabHistoryController
)
;
final
String
action
=
intent
.
getAction
(
)
;
if
(
Intent
.
ACTION_VIEW
.
equals
(
action
)
)
{
mBrowserToolbar
.
setTitle
(
intent
.
getDataString
(
)
)
;
showTabQueuePromptIfApplicable
(
intent
)
;
}
else
if
(
ACTION_VIEW_MULTIPLE
.
equals
(
action
)
&
&
savedInstanceState
=
=
null
)
{
openMultipleTabsFromIntent
(
intent
)
;
}
else
if
(
GuestSession
.
NOTIFICATION_INTENT
.
equals
(
action
)
)
{
GuestSession
.
handleIntent
(
this
intent
)
;
}
else
if
(
TabQueueHelper
.
LOAD_URLS_ACTION
.
equals
(
action
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
NOTIFICATION
"
tabqueue
"
)
;
}
if
(
HardwareUtils
.
isTablet
(
)
)
{
mTabStrip
=
(
TabStripInterface
)
(
(
(
ViewStub
)
findViewById
(
R
.
id
.
tablet_tab_strip
)
)
.
inflate
(
)
)
;
}
(
(
GeckoApp
.
MainLayout
)
mMainLayout
)
.
setTouchEventInterceptor
(
new
HideOnTouchListener
(
)
)
;
(
(
GeckoApp
.
MainLayout
)
mMainLayout
)
.
setMotionEventInterceptor
(
new
MotionEventInterceptor
(
)
{
Override
public
boolean
onInterceptMotionEvent
(
View
view
MotionEvent
event
)
{
if
(
mLayerView
!
=
null
&
&
!
mLayerView
.
hasFocus
(
)
&
&
GamepadUtils
.
isPanningControl
(
event
)
)
{
if
(
mHomeScreen
=
=
null
)
{
return
false
;
}
if
(
isHomePagerVisible
(
)
)
{
mLayerView
.
requestFocus
(
)
;
}
else
{
mHomeScreen
.
requestFocus
(
)
;
}
}
return
false
;
}
}
)
;
mHomeScreenContainer
=
(
ViewGroup
)
findViewById
(
R
.
id
.
home_screen_container
)
;
mBrowserSearchContainer
=
findViewById
(
R
.
id
.
search_container
)
;
mBrowserSearch
=
(
BrowserSearch
)
getSupportFragmentManager
(
)
.
findFragmentByTag
(
BROWSER_SEARCH_TAG
)
;
if
(
mBrowserSearch
=
=
null
)
{
mBrowserSearch
=
BrowserSearch
.
newInstance
(
)
;
mBrowserSearch
.
setUserVisibleHint
(
false
)
;
}
setBrowserToolbarListeners
(
)
;
mFindInPageBar
=
(
FindInPageBar
)
findViewById
(
R
.
id
.
find_in_page
)
;
mMediaCastingBar
=
(
MediaCastingBar
)
findViewById
(
R
.
id
.
media_casting
)
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
(
GeckoEventListener
)
this
"
Gecko
:
DelayedStartup
"
"
Menu
:
Open
"
"
Menu
:
Update
"
"
LightweightTheme
:
Update
"
"
Search
:
Keyword
"
"
Prompt
:
ShowTop
"
"
Video
:
Play
"
)
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
(
NativeEventListener
)
this
"
CharEncoding
:
Data
"
"
CharEncoding
:
State
"
"
Download
:
AndroidDownloadManager
"
"
Experiments
:
GetActive
"
"
Experiments
:
SetOverride
"
"
Experiments
:
ClearOverride
"
"
Favicon
:
CacheLoad
"
"
Feedback
:
MaybeLater
"
"
Menu
:
Add
"
"
Menu
:
Remove
"
"
Sanitize
:
ClearHistory
"
"
Sanitize
:
ClearSyncedTabs
"
"
Settings
:
Show
"
"
Telemetry
:
Gather
"
"
Updater
:
Launch
"
)
;
final
GeckoProfile
profile
=
getProfile
(
)
;
final
Distribution
distribution
=
Distribution
.
init
(
getApplicationContext
(
)
)
;
distribution
.
addOnDistributionReadyCallback
(
new
DistributionStoreCallback
(
getApplicationContext
(
)
profile
.
getName
(
)
)
)
;
mSearchEngineManager
=
new
SearchEngineManager
(
this
distribution
)
;
final
SuggestedSites
suggestedSites
=
new
SuggestedSites
(
appContext
distribution
)
;
final
BrowserDB
db
=
profile
.
getDB
(
)
;
db
.
setSuggestedSites
(
suggestedSites
)
;
JavaAddonManager
.
getInstance
(
)
.
init
(
appContext
)
;
mSharedPreferencesHelper
=
new
SharedPreferencesHelper
(
appContext
)
;
mReadingListHelper
=
new
ReadingListHelper
(
appContext
profile
)
;
mAccountsHelper
=
new
AccountsHelper
(
appContext
profile
)
;
initAdjustSDK
(
this
isInAutomation
mTelemetryCorePingDelegate
)
;
if
(
AppConstants
.
MOZ_ANDROID_BEAM
)
{
NfcAdapter
nfc
=
NfcAdapter
.
getDefaultAdapter
(
this
)
;
if
(
nfc
!
=
null
)
{
nfc
.
setNdefPushMessageCallback
(
new
NfcAdapter
.
CreateNdefMessageCallback
(
)
{
Override
public
NdefMessage
createNdefMessage
(
NfcEvent
event
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
|
|
tab
.
isPrivate
(
)
)
{
return
null
;
}
return
new
NdefMessage
(
new
NdefRecord
[
]
{
NdefRecord
.
createUri
(
tab
.
getURL
(
)
)
}
)
;
}
}
this
)
;
}
}
if
(
savedInstanceState
!
=
null
)
{
mDynamicToolbar
.
onRestoreInstanceState
(
savedInstanceState
)
;
mHomeScreenContainer
.
setPadding
(
0
savedInstanceState
.
getInt
(
STATE_ABOUT_HOME_TOP_PADDING
)
0
0
)
;
}
mDynamicToolbar
.
setEnabledChangedListener
(
new
DynamicToolbar
.
OnEnabledChangedListener
(
)
{
Override
public
void
onEnabledChanged
(
boolean
enabled
)
{
setDynamicToolbarEnabled
(
enabled
)
;
}
}
)
;
IconDirectoryEntry
.
setMaxBPP
(
GeckoAppShell
.
getScreenDepth
(
)
)
;
if
(
!
AppConstants
.
RELEASE_BUILD
&
&
UpdateServiceHelper
.
isUpdaterEnabled
(
this
)
)
{
Permissions
.
from
(
this
)
.
withPermissions
(
Manifest
.
permission
.
WRITE_EXTERNAL_STORAGE
)
.
doNotPrompt
(
)
.
andFallback
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
showUpdaterPermissionSnackbar
(
)
;
}
}
)
.
run
(
)
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onCreate
(
this
savedInstanceState
)
;
}
final
String
installerPackageName
=
getPackageManager
(
)
.
getInstallerPackageName
(
getPackageName
(
)
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
TelemetryContract
.
Method
.
SYSTEM
"
installer_
"
+
installerPackageName
)
;
}
CheckResult
private
boolean
getIsInAutomationFromEnvironment
(
final
Intent
intent
)
{
final
HashMap
<
String
String
>
envVars
=
IntentUtils
.
getEnvVarMap
(
intent
)
;
return
!
TextUtils
.
isEmpty
(
envVars
.
get
(
IntentUtils
.
ENV_VAR_IN_AUTOMATION
)
)
;
}
private
static
void
initSwitchboard
(
final
Context
context
final
Intent
intent
final
boolean
isInAutomation
)
{
if
(
isInAutomation
)
{
Log
.
d
(
LOGTAG
"
Switchboard
disabled
-
in
automation
"
)
;
return
;
}
else
if
(
!
AppConstants
.
MOZ_SWITCHBOARD
)
{
Log
.
d
(
LOGTAG
"
Switchboard
compile
-
time
disabled
"
)
;
return
;
}
final
String
serverExtra
=
IntentUtils
.
getStringExtraSafe
(
intent
INTENT_KEY_SWITCHBOARD_SERVER
)
;
final
String
serverUrl
=
TextUtils
.
isEmpty
(
serverExtra
)
?
SWITCHBOARD_SERVER
:
serverExtra
;
new
AsyncConfigLoader
(
context
serverUrl
)
.
execute
(
)
;
}
private
static
void
initTelemetryUploader
(
final
boolean
isInAutomation
)
{
TelemetryUploadService
.
setDisabled
(
isInAutomation
)
;
}
private
static
void
initAdjustSDK
(
final
Context
context
final
boolean
isInAutomation
final
AttributionHelperListener
listener
)
{
final
AdjustHelperInterface
adjustHelper
=
AdjustConstants
.
getAdjustHelper
(
)
;
adjustHelper
.
onCreate
(
context
AdjustConstants
.
MOZ_INSTALL_TRACKING_ADJUST_SDK_APP_TOKEN
listener
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forApp
(
context
)
;
final
boolean
enabled
=
!
isInAutomation
&
&
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_HEALTHREPORT_UPLOAD_ENABLED
true
)
;
adjustHelper
.
setEnabled
(
enabled
)
;
}
private
void
showUpdaterPermissionSnackbar
(
)
{
SnackbarBuilder
.
SnackbarCallback
allowCallback
=
new
SnackbarBuilder
.
SnackbarCallback
(
)
{
Override
public
void
onClick
(
View
v
)
{
Permissions
.
from
(
BrowserApp
.
this
)
.
withPermissions
(
Manifest
.
permission
.
WRITE_EXTERNAL_STORAGE
)
.
run
(
)
;
}
}
;
SnackbarBuilder
.
builder
(
this
)
.
message
(
R
.
string
.
updater_permission_text
)
.
duration
(
Snackbar
.
LENGTH_INDEFINITE
)
.
action
(
R
.
string
.
updater_permission_allow
)
.
callback
(
allowCallback
)
.
buildAndShow
(
)
;
}
private
void
conditionallyNotifyEOL
(
)
{
final
StrictMode
.
ThreadPolicy
savedPolicy
=
StrictMode
.
allowThreadDiskReads
(
)
;
try
{
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
if
(
!
prefs
.
contains
(
EOL_NOTIFIED
)
)
{
final
String
link
=
getString
(
R
.
string
.
eol_notification_url
AppConstants
.
MOZ_APP_VERSION
AppConstants
.
OS_TARGET
Locales
.
getLanguageTag
(
Locale
.
getDefault
(
)
)
)
;
final
Intent
intent
=
new
Intent
(
Intent
.
ACTION_VIEW
)
;
intent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
intent
.
setData
(
Uri
.
parse
(
link
)
)
;
final
PendingIntent
pendingIntent
=
PendingIntent
.
getActivity
(
this
0
intent
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
final
Notification
notification
=
new
NotificationCompat
.
Builder
(
this
)
.
setContentTitle
(
getString
(
R
.
string
.
eol_notification_title
)
)
.
setContentText
(
getString
(
R
.
string
.
eol_notification_summary
)
)
.
setSmallIcon
(
R
.
drawable
.
ic_status_logo
)
.
setAutoCancel
(
true
)
.
setContentIntent
(
pendingIntent
)
.
build
(
)
;
final
NotificationManager
notificationManager
=
(
NotificationManager
)
getSystemService
(
Context
.
NOTIFICATION_SERVICE
)
;
final
int
notificationID
=
EOL_NOTIFIED
.
hashCode
(
)
;
notificationManager
.
notify
(
notificationID
notification
)
;
GeckoSharedPrefs
.
forProfile
(
this
)
.
edit
(
)
.
putBoolean
(
EOL_NOTIFIED
true
)
.
apply
(
)
;
}
}
finally
{
StrictMode
.
setThreadPolicy
(
savedPolicy
)
;
}
}
private
void
checkFirstrun
(
Context
context
SafeIntent
intent
)
{
if
(
intent
.
getBooleanExtra
(
EXTRA_SKIP_STARTPANE
false
)
)
{
return
;
}
final
StrictMode
.
ThreadPolicy
savedPolicy
=
StrictMode
.
allowThreadDiskReads
(
)
;
try
{
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
if
(
prefs
.
getBoolean
(
FirstrunAnimationContainer
.
PREF_FIRSTRUN_ENABLED
false
)
)
{
if
(
!
Intent
.
ACTION_VIEW
.
equals
(
intent
.
getAction
(
)
)
)
{
showFirstrunPager
(
)
;
if
(
HardwareUtils
.
isTablet
(
)
)
{
mTabStrip
.
setOnTabChangedListener
(
new
TabStripInterface
.
OnTabAddedOrRemovedListener
(
)
{
Override
public
void
onTabChanged
(
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
BUTTON
)
;
mTabStrip
.
setOnTabChangedListener
(
null
)
;
}
}
)
;
}
}
prefs
.
edit
(
)
.
putBoolean
(
FirstrunAnimationContainer
.
PREF_FIRSTRUN_ENABLED
false
)
.
apply
(
)
;
}
}
finally
{
StrictMode
.
setThreadPolicy
(
savedPolicy
)
;
}
}
private
Class
<
?
>
getMediaPlayerManager
(
)
{
if
(
AppConstants
.
MOZ_MEDIA_PLAYER
)
{
try
{
return
Class
.
forName
(
"
org
.
mozilla
.
gecko
.
MediaPlayerManager
"
)
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
No
native
casting
support
"
ex
)
;
}
}
return
null
;
}
Override
public
void
onBackPressed
(
)
{
if
(
mTextSelection
.
dismiss
(
)
)
{
return
;
}
if
(
getSupportFragmentManager
(
)
.
getBackStackEntryCount
(
)
>
0
)
{
super
.
onBackPressed
(
)
;
return
;
}
if
(
mBrowserToolbar
.
onBackPressed
(
)
)
{
return
;
}
if
(
mActionMode
!
=
null
)
{
endActionModeCompat
(
)
;
return
;
}
if
(
hideFirstrunPager
(
TelemetryContract
.
Method
.
BACK
)
)
{
return
;
}
if
(
mVideoPlayer
.
isFullScreen
(
)
)
{
mVideoPlayer
.
setFullScreen
(
false
)
;
setFullScreen
(
false
)
;
return
;
}
if
(
mVideoPlayer
.
isPlaying
(
)
)
{
mVideoPlayer
.
stop
(
)
;
return
;
}
super
.
onBackPressed
(
)
;
}
Override
public
void
onAttachedToWindow
(
)
{
mDoorhangerOverlay
=
findViewById
(
R
.
id
.
doorhanger_overlay
)
;
mDoorhangerOverlay
.
setVisibility
(
View
.
VISIBLE
)
;
checkFirstrun
(
this
new
SafeIntent
(
getIntent
(
)
)
)
;
}
Override
protected
void
processTabQueue
(
)
{
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
mInitialized
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
TabQueueHelper
.
shouldOpenTabQueueUrls
(
BrowserApp
.
this
)
)
{
openQueuedTabs
(
)
;
}
}
}
)
;
}
}
Override
protected
void
openQueuedTabs
(
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
int
queuedTabCount
=
TabQueueHelper
.
getTabQueueLength
(
BrowserApp
.
this
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_TABQUEUE_QUEUESIZE
"
queuedTabCount
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
INTENT
"
tabqueue
-
delayed
"
)
;
TabQueueHelper
.
openQueuedUrls
(
BrowserApp
.
this
getProfile
(
)
TabQueueHelper
.
FILE_NAME
false
)
;
if
(
queuedTabCount
>
1
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
showNormalTabs
(
)
;
}
}
)
;
}
}
private
void
openMultipleTabsFromIntent
(
final
Intent
intent
)
{
final
List
<
String
>
urls
=
intent
.
getStringArrayListExtra
(
"
urls
"
)
;
if
(
urls
!
=
null
)
{
openUrls
(
urls
)
;
}
}
Override
public
void
onResume
(
)
{
super
.
onResume
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
AdjustConstants
.
getAdjustHelper
(
)
.
onResume
(
)
;
if
(
!
mHasResumed
)
{
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
(
GeckoEventListener
)
this
"
Prompt
:
ShowTop
"
)
;
mHasResumed
=
true
;
}
processTabQueue
(
)
;
for
(
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onResume
(
this
)
;
}
}
Override
public
void
onPause
(
)
{
super
.
onPause
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
AdjustConstants
.
getAdjustHelper
(
)
.
onPause
(
)
;
if
(
mHasResumed
)
{
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
(
GeckoEventListener
)
this
"
Prompt
:
ShowTop
"
)
;
mHasResumed
=
false
;
}
for
(
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onPause
(
this
)
;
}
}
Override
public
void
onRestart
(
)
{
super
.
onRestart
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onRestart
(
this
)
;
}
}
Override
public
void
onStart
(
)
{
super
.
onStart
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
GeckoProfile
profile
=
getProfile
(
)
;
if
(
profile
.
inGuestMode
(
)
)
{
GuestSession
.
showNotification
(
BrowserApp
.
this
)
;
}
else
{
GuestSession
.
hideNotification
(
BrowserApp
.
this
)
;
}
final
SharedPreferences
sharedPrefs
=
GeckoSharedPrefs
.
forProfileName
(
BrowserApp
.
this
profile
.
getName
(
)
)
;
FileCleanupController
.
startIfReady
(
BrowserApp
.
this
sharedPrefs
profile
.
getDir
(
)
.
getAbsolutePath
(
)
)
;
}
}
)
;
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onStart
(
this
)
;
}
}
Override
public
void
onStop
(
)
{
super
.
onStop
(
)
;
if
(
mIsAbortingAppLaunch
)
{
return
;
}
GuestSession
.
hideNotification
(
this
)
;
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onStop
(
this
)
;
}
}
Override
public
void
onWindowFocusChanged
(
boolean
hasFocus
)
{
super
.
onWindowFocusChanged
(
hasFocus
)
;
if
(
hasFocus
)
{
mBrowserToolbar
.
onParentFocus
(
)
;
}
}
private
void
setBrowserToolbarListeners
(
)
{
mBrowserToolbar
.
setOnActivateListener
(
new
BrowserToolbar
.
OnActivateListener
(
)
{
Override
public
void
onActivate
(
)
{
enterEditingMode
(
)
;
}
}
)
;
mBrowserToolbar
.
setOnCommitListener
(
new
BrowserToolbar
.
OnCommitListener
(
)
{
Override
public
void
onCommit
(
)
{
commitEditingMode
(
)
;
}
}
)
;
mBrowserToolbar
.
setOnDismissListener
(
new
BrowserToolbar
.
OnDismissListener
(
)
{
Override
public
void
onDismiss
(
)
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
}
)
;
mBrowserToolbar
.
setOnFilterListener
(
new
BrowserToolbar
.
OnFilterListener
(
)
{
Override
public
void
onFilter
(
String
searchText
AutocompleteHandler
handler
)
{
filterEditingMode
(
searchText
handler
)
;
}
}
)
;
mBrowserToolbar
.
setOnFocusChangeListener
(
new
View
.
OnFocusChangeListener
(
)
{
Override
public
void
onFocusChange
(
View
v
boolean
hasFocus
)
{
if
(
isHomePagerVisible
(
)
)
{
mHomeScreen
.
onToolbarFocusChange
(
hasFocus
)
;
}
}
}
)
;
mBrowserToolbar
.
setOnStartEditingListener
(
new
BrowserToolbar
.
OnStartEditingListener
(
)
{
Override
public
void
onStartEditing
(
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
selectedTab
.
setIsEditing
(
true
)
;
}
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
disable
(
)
;
}
}
}
)
;
mBrowserToolbar
.
setOnStopEditingListener
(
new
BrowserToolbar
.
OnStopEditingListener
(
)
{
Override
public
void
onStopEditing
(
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
!
=
null
)
{
selectedTab
.
setIsEditing
(
false
)
;
}
selectTargetTabForEditingMode
(
)
;
hideBrowserSearch
(
)
;
hideHomePager
(
)
;
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
enable
(
)
;
}
}
}
)
;
mBrowserToolbar
.
setOnKeyListener
(
this
)
;
}
private
void
setDynamicToolbarEnabled
(
boolean
enabled
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
enabled
)
{
if
(
mLayerView
!
=
null
)
{
mLayerView
.
getDynamicToolbarAnimator
(
)
.
addTranslationListener
(
this
)
;
}
setToolbarMargin
(
0
)
;
mHomeScreenContainer
.
setPadding
(
0
mBrowserChrome
.
getHeight
(
)
0
0
)
;
}
else
{
if
(
mLayerView
!
=
null
)
{
mLayerView
.
getDynamicToolbarAnimator
(
)
.
removeTranslationListener
(
this
)
;
}
mHomeScreenContainer
.
setPadding
(
0
0
0
0
)
;
if
(
mBrowserChrome
!
=
null
)
{
ViewHelper
.
setTranslationY
(
mBrowserChrome
0
)
;
}
if
(
mLayerView
!
=
null
)
{
mLayerView
.
setSurfaceTranslation
(
0
)
;
}
}
refreshToolbarHeight
(
)
;
}
private
static
boolean
isAboutHome
(
final
Tab
tab
)
{
return
AboutPages
.
isAboutHome
(
tab
.
getURL
(
)
)
;
}
Override
public
boolean
onSearchRequested
(
)
{
enterEditingMode
(
)
;
return
true
;
}
Override
public
boolean
onContextItemSelected
(
MenuItem
item
)
{
final
int
itemId
=
item
.
getItemId
(
)
;
if
(
itemId
=
=
R
.
id
.
pasteandgo
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
CONTEXT_MENU
)
;
String
text
=
Clipboard
.
getText
(
)
;
if
(
!
TextUtils
.
isEmpty
(
text
)
)
{
loadUrlOrKeywordSearch
(
text
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
CONTEXT_MENU
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
"
pasteandgo
"
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
paste
)
{
String
text
=
Clipboard
.
getText
(
)
;
if
(
!
TextUtils
.
isEmpty
(
text
)
)
{
enterEditingMode
(
text
)
;
showBrowserSearch
(
)
;
mBrowserSearch
.
filter
(
text
null
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
"
paste
"
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
subscribe
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
tab
.
hasFeeds
(
)
)
{
JSONObject
args
=
new
JSONObject
(
)
;
try
{
args
.
put
(
"
tabId
"
tab
.
getId
(
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
error
building
json
arguments
"
e
)
;
}
GeckoAppShell
.
notifyObservers
(
"
Feeds
:
Subscribe
"
args
.
toString
(
)
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
add_search_engine
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
tab
.
hasOpenSearch
(
)
)
{
JSONObject
args
=
new
JSONObject
(
)
;
try
{
args
.
put
(
"
tabId
"
tab
.
getId
(
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
error
building
json
arguments
"
e
)
;
return
true
;
}
GeckoAppShell
.
notifyObservers
(
"
SearchEngines
:
Add
"
args
.
toString
(
)
)
;
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
copyurl
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
String
url
=
ReaderModeUtils
.
stripAboutReaderUrl
(
tab
.
getURL
(
)
)
;
if
(
url
!
=
null
)
{
Clipboard
.
setText
(
url
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
"
copyurl
"
)
;
}
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
add_to_launcher
)
{
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
=
=
null
)
{
return
true
;
}
final
String
url
=
tab
.
getURL
(
)
;
final
String
title
=
tab
.
getDisplayTitle
(
)
;
if
(
url
=
=
null
|
|
title
=
=
null
)
{
return
true
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoAppShell
.
createShortcut
(
title
url
)
;
}
}
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
CONTEXT_MENU
getResources
(
)
.
getResourceEntryName
(
itemId
)
)
;
return
true
;
}
return
false
;
}
Override
public
void
setAccessibilityEnabled
(
boolean
enabled
)
{
super
.
setAccessibilityEnabled
(
enabled
)
;
mDynamicToolbar
.
setAccessibilityEnabled
(
enabled
)
;
}
Override
public
void
onDestroy
(
)
{
if
(
mIsAbortingAppLaunch
)
{
super
.
onDestroy
(
)
;
return
;
}
mDynamicToolbar
.
destroy
(
)
;
if
(
mBrowserToolbar
!
=
null
)
mBrowserToolbar
.
onDestroy
(
)
;
if
(
mFindInPageBar
!
=
null
)
{
mFindInPageBar
.
onDestroy
(
)
;
mFindInPageBar
=
null
;
}
if
(
mMediaCastingBar
!
=
null
)
{
mMediaCastingBar
.
onDestroy
(
)
;
mMediaCastingBar
=
null
;
}
if
(
mSharedPreferencesHelper
!
=
null
)
{
mSharedPreferencesHelper
.
uninit
(
)
;
mSharedPreferencesHelper
=
null
;
}
if
(
mReadingListHelper
!
=
null
)
{
mReadingListHelper
.
uninit
(
)
;
mReadingListHelper
=
null
;
}
if
(
mAccountsHelper
!
=
null
)
{
mAccountsHelper
.
uninit
(
)
;
mAccountsHelper
=
null
;
}
if
(
mZoomedView
!
=
null
)
{
mZoomedView
.
destroy
(
)
;
}
mSearchEngineManager
.
unregisterListeners
(
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
(
GeckoEventListener
)
this
"
Gecko
:
DelayedStartup
"
"
Menu
:
Open
"
"
Menu
:
Update
"
"
LightweightTheme
:
Update
"
"
Search
:
Keyword
"
"
Prompt
:
ShowTop
"
"
Video
:
Play
"
)
;
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
(
NativeEventListener
)
this
"
CharEncoding
:
Data
"
"
CharEncoding
:
State
"
"
Download
:
AndroidDownloadManager
"
"
Experiments
:
GetActive
"
"
Experiments
:
SetOverride
"
"
Experiments
:
ClearOverride
"
"
Favicon
:
CacheLoad
"
"
Feedback
:
MaybeLater
"
"
Menu
:
Add
"
"
Menu
:
Remove
"
"
Sanitize
:
ClearHistory
"
"
Sanitize
:
ClearSyncedTabs
"
"
Settings
:
Show
"
"
Telemetry
:
Gather
"
"
Updater
:
Launch
"
)
;
if
(
AppConstants
.
MOZ_ANDROID_BEAM
)
{
NfcAdapter
nfc
=
NfcAdapter
.
getDefaultAdapter
(
this
)
;
if
(
nfc
!
=
null
)
{
nfc
.
setNdefPushMessageCallback
(
null
this
)
;
}
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onDestroy
(
this
)
;
}
super
.
onDestroy
(
)
;
}
Override
protected
void
initializeChrome
(
)
{
super
.
initializeChrome
(
)
;
mDoorHangerPopup
.
setAnchor
(
mBrowserToolbar
.
getDoorHangerAnchor
(
)
)
;
mDoorHangerPopup
.
setOnVisibilityChangeListener
(
this
)
;
mDynamicToolbar
.
setLayerView
(
mLayerView
)
;
setDynamicToolbarEnabled
(
mDynamicToolbar
.
isEnabled
(
)
)
;
mLayerView
.
setOnKeyListener
(
this
)
;
if
(
HardwareUtils
.
isTablet
(
)
)
{
onCreatePanelMenu
(
Window
.
FEATURE_OPTIONS_PANEL
null
)
;
invalidateOptionsMenu
(
)
;
}
}
Override
public
void
onDoorHangerShow
(
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
final
Animator
alphaAnimator
=
ObjectAnimator
.
ofFloat
(
mDoorhangerOverlay
"
alpha
"
1
)
;
alphaAnimator
.
setDuration
(
250
)
;
alphaAnimator
.
start
(
)
;
}
Override
public
void
onDoorHangerHide
(
)
{
final
Animator
alphaAnimator
=
ObjectAnimator
.
ofFloat
(
mDoorhangerOverlay
"
alpha
"
0
)
;
alphaAnimator
.
setDuration
(
200
)
;
alphaAnimator
.
start
(
)
;
}
private
void
handleClearHistory
(
final
boolean
clearSearchHistory
)
{
final
BrowserDB
db
=
getProfile
(
)
.
getDB
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
db
.
clearHistory
(
getContentResolver
(
)
clearSearchHistory
)
;
}
}
)
;
}
private
void
handleClearSyncedTabs
(
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
FennecTabsRepository
.
deleteNonLocalClientsAndTabs
(
getContext
(
)
)
;
}
}
)
;
}
private
void
setToolbarMargin
(
int
margin
)
{
(
(
RelativeLayout
.
LayoutParams
)
mGeckoLayout
.
getLayoutParams
(
)
)
.
topMargin
=
margin
;
mGeckoLayout
.
requestLayout
(
)
;
}
Override
public
void
onTranslationChanged
(
float
aToolbarTranslation
float
aLayerViewTranslation
)
{
if
(
mBrowserChrome
=
=
null
)
{
return
;
}
final
View
browserChrome
=
mBrowserChrome
;
final
ToolbarProgressView
progressView
=
mProgressView
;
ViewHelper
.
setTranslationY
(
browserChrome
-
aToolbarTranslation
)
;
mLayerView
.
setSurfaceTranslation
(
mToolbarHeight
-
aLayerViewTranslation
)
;
final
float
offset
=
getResources
(
)
.
getDimensionPixelOffset
(
R
.
dimen
.
progress_bar_scroll_offset
)
;
final
float
progressTranslationY
=
Math
.
min
(
aToolbarTranslation
mToolbarHeight
-
offset
)
;
ViewHelper
.
setTranslationY
(
progressView
-
progressTranslationY
)
;
if
(
mFormAssistPopup
!
=
null
)
{
mFormAssistPopup
.
onTranslationChanged
(
)
;
}
}
Override
public
void
onMetricsChanged
(
ImmutableViewportMetrics
aMetrics
)
{
if
(
isHomePagerVisible
(
)
|
|
mBrowserChrome
=
=
null
)
{
return
;
}
if
(
mFormAssistPopup
!
=
null
)
{
mFormAssistPopup
.
onMetricsChanged
(
aMetrics
)
;
}
}
Override
public
void
onPanZoomStopped
(
)
{
if
(
!
mDynamicToolbar
.
isEnabled
(
)
|
|
isHomePagerVisible
(
)
|
|
mBrowserChrome
.
getVisibility
(
)
!
=
View
.
VISIBLE
)
{
return
;
}
ImmutableViewportMetrics
metrics
=
mLayerView
.
getViewportMetrics
(
)
;
float
toolbarTranslation
=
mLayerView
.
getDynamicToolbarAnimator
(
)
.
getToolbarTranslation
(
)
;
boolean
shortPage
=
metrics
.
getPageHeight
(
)
<
metrics
.
getHeight
(
)
;
boolean
atBottomOfLongPage
=
FloatUtils
.
fuzzyEquals
(
metrics
.
pageRectBottom
metrics
.
viewportRectBottom
(
)
)
&
&
(
metrics
.
pageRectBottom
>
2
*
metrics
.
getHeight
(
)
)
;
Log
.
v
(
LOGTAG
"
On
pan
/
zoom
stopped
short
page
:
"
+
shortPage
+
"
;
atBottomOfLongPage
:
"
+
atBottomOfLongPage
)
;
if
(
shortPage
|
|
atBottomOfLongPage
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
public
void
refreshToolbarHeight
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
int
height
=
0
;
if
(
mBrowserChrome
!
=
null
)
{
height
=
mBrowserChrome
.
getHeight
(
)
;
}
if
(
!
mDynamicToolbar
.
isEnabled
(
)
|
|
isHomePagerVisible
(
)
)
{
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mHomeScreenContainer
.
setPadding
(
0
height
0
0
)
;
}
else
{
setToolbarMargin
(
height
)
;
height
=
0
;
}
}
else
{
setToolbarMargin
(
0
)
;
}
if
(
mLayerView
!
=
null
&
&
height
!
=
mToolbarHeight
)
{
mToolbarHeight
=
height
;
mLayerView
.
setMaxTranslation
(
height
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
}
Override
void
toggleChrome
(
final
boolean
aShow
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
aShow
)
{
mBrowserChrome
.
setVisibility
(
View
.
VISIBLE
)
;
}
else
{
mBrowserChrome
.
setVisibility
(
View
.
GONE
)
;
}
}
}
)
;
super
.
toggleChrome
(
aShow
)
;
}
Override
void
focusChrome
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mBrowserChrome
.
setVisibility
(
View
.
VISIBLE
)
;
mActionBarFlipper
.
requestFocusFromTouch
(
)
;
}
}
)
;
}
Override
public
void
refreshChrome
(
)
{
invalidateOptionsMenu
(
)
;
if
(
mTabsPanel
!
=
null
)
{
mTabsPanel
.
refresh
(
)
;
}
if
(
mTabStrip
!
=
null
)
{
mTabStrip
.
refresh
(
)
;
}
mBrowserToolbar
.
refresh
(
)
;
}
Override
public
void
handleMessage
(
final
String
event
final
NativeJSObject
message
final
EventCallback
callback
)
{
if
(
"
CharEncoding
:
Data
"
.
equals
(
event
)
)
{
final
NativeJSObject
[
]
charsets
=
message
.
getObjectArray
(
"
charsets
"
)
;
final
int
selected
=
message
.
getInt
(
"
selected
"
)
;
final
String
[
]
titleArray
=
new
String
[
charsets
.
length
]
;
final
String
[
]
codeArray
=
new
String
[
charsets
.
length
]
;
for
(
int
i
=
0
;
i
<
charsets
.
length
;
i
+
+
)
{
final
NativeJSObject
charset
=
charsets
[
i
]
;
titleArray
[
i
]
=
charset
.
getString
(
"
title
"
)
;
codeArray
[
i
]
=
charset
.
getString
(
"
code
"
)
;
}
final
AlertDialog
.
Builder
dialogBuilder
=
new
AlertDialog
.
Builder
(
this
)
;
dialogBuilder
.
setSingleChoiceItems
(
titleArray
selected
new
AlertDialog
.
OnClickListener
(
)
{
Override
public
void
onClick
(
final
DialogInterface
dialog
final
int
which
)
{
GeckoAppShell
.
notifyObservers
(
"
CharEncoding
:
Set
"
codeArray
[
which
]
)
;
dialog
.
dismiss
(
)
;
}
}
)
;
dialogBuilder
.
setNegativeButton
(
R
.
string
.
button_cancel
new
AlertDialog
.
OnClickListener
(
)
{
Override
public
void
onClick
(
final
DialogInterface
dialog
final
int
which
)
{
dialog
.
dismiss
(
)
;
}
}
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
dialogBuilder
.
show
(
)
;
}
}
)
;
}
else
if
(
"
CharEncoding
:
State
"
.
equals
(
event
)
)
{
final
boolean
visible
=
message
.
getString
(
"
visible
"
)
.
equals
(
"
true
"
)
;
GeckoPreferences
.
setCharEncodingState
(
visible
)
;
final
Menu
menu
=
mMenu
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
menu
!
=
null
)
{
menu
.
findItem
(
R
.
id
.
char_encoding
)
.
setVisible
(
visible
)
;
}
}
}
)
;
}
else
if
(
"
Experiments
:
GetActive
"
.
equals
(
event
)
)
{
final
List
<
String
>
experiments
=
SwitchBoard
.
getActiveExperiments
(
this
)
;
final
JSONArray
json
=
new
JSONArray
(
experiments
)
;
callback
.
sendSuccess
(
json
.
toString
(
)
)
;
}
else
if
(
"
Experiments
:
SetOverride
"
.
equals
(
event
)
)
{
Experiments
.
setOverride
(
getContext
(
)
message
.
getString
(
"
name
"
)
message
.
getBoolean
(
"
isEnabled
"
)
)
;
}
else
if
(
"
Experiments
:
ClearOverride
"
.
equals
(
event
)
)
{
Experiments
.
clearOverride
(
getContext
(
)
message
.
getString
(
"
name
"
)
)
;
}
else
if
(
"
Favicon
:
CacheLoad
"
.
equals
(
event
)
)
{
final
String
url
=
message
.
getString
(
"
url
"
)
;
getFaviconFromCache
(
callback
url
)
;
}
else
if
(
"
Feedback
:
MaybeLater
"
.
equals
(
event
)
)
{
resetFeedbackLaunchCount
(
)
;
}
else
if
(
"
Menu
:
Add
"
.
equals
(
event
)
)
{
final
MenuItemInfo
info
=
new
MenuItemInfo
(
)
;
info
.
label
=
message
.
getString
(
"
name
"
)
;
info
.
id
=
message
.
getInt
(
"
id
"
)
+
ADDON_MENU_OFFSET
;
info
.
checked
=
message
.
optBoolean
(
"
checked
"
false
)
;
info
.
enabled
=
message
.
optBoolean
(
"
enabled
"
true
)
;
info
.
visible
=
message
.
optBoolean
(
"
visible
"
true
)
;
info
.
checkable
=
message
.
optBoolean
(
"
checkable
"
false
)
;
final
int
parent
=
message
.
optInt
(
"
parent
"
0
)
;
info
.
parent
=
parent
<
=
0
?
parent
:
parent
+
ADDON_MENU_OFFSET
;
final
MenuItemInfo
menuItemInfo
=
info
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
addAddonMenuItem
(
menuItemInfo
)
;
}
}
)
;
}
else
if
(
"
Menu
:
Remove
"
.
equals
(
event
)
)
{
final
int
id
=
message
.
getInt
(
"
id
"
)
+
ADDON_MENU_OFFSET
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
removeAddonMenuItem
(
id
)
;
}
}
)
;
}
else
if
(
"
Sanitize
:
ClearHistory
"
.
equals
(
event
)
)
{
handleClearHistory
(
message
.
optBoolean
(
"
clearSearchHistory
"
false
)
)
;
callback
.
sendSuccess
(
true
)
;
}
else
if
(
"
Sanitize
:
ClearSyncedTabs
"
.
equals
(
event
)
)
{
handleClearSyncedTabs
(
)
;
callback
.
sendSuccess
(
true
)
;
}
else
if
(
"
Settings
:
Show
"
.
equals
(
event
)
)
{
final
String
resource
=
message
.
optString
(
GeckoPreferences
.
INTENT_EXTRA_RESOURCES
null
)
;
final
Intent
settingsIntent
=
new
Intent
(
this
GeckoPreferences
.
class
)
;
GeckoPreferences
.
setResourceToOpen
(
settingsIntent
resource
)
;
startActivityForResult
(
settingsIntent
ACTIVITY_REQUEST_PREFERENCES
)
;
if
(
HardwareUtils
.
IS_KINDLE_DEVICE
)
{
overridePendingTransition
(
0
0
)
;
}
}
else
if
(
"
Telemetry
:
Gather
"
.
equals
(
event
)
)
{
final
BrowserDB
db
=
getProfile
(
)
.
getDB
(
)
;
final
ContentResolver
cr
=
getContentResolver
(
)
;
Telemetry
.
addToHistogram
(
"
PLACES_PAGES_COUNT
"
db
.
getCount
(
cr
"
history
"
)
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_BOOKMARKS_COUNT
"
db
.
getCount
(
cr
"
bookmarks
"
)
)
;
Telemetry
.
addToHistogram
(
"
BROWSER_IS_USER_DEFAULT
"
(
isDefaultBrowser
(
Intent
.
ACTION_VIEW
)
?
1
:
0
)
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_CUSTOM_HOMEPAGE
"
(
TextUtils
.
isEmpty
(
getHomepage
(
)
)
?
0
:
1
)
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
getContext
(
)
)
;
final
boolean
hasCustomHomepanels
=
prefs
.
contains
(
HomeConfigPrefsBackend
.
PREFS_CONFIG_KEY
)
|
|
prefs
.
contains
(
HomeConfigPrefsBackend
.
PREFS_CONFIG_KEY_OLD
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_HOMEPANELS_CUSTOM
"
hasCustomHomepanels
?
1
:
0
)
;
Telemetry
.
addToHistogram
(
"
FENNEC_READER_VIEW_CACHE_SIZE
"
SavedReaderViewHelper
.
getSavedReaderViewHelper
(
getContext
(
)
)
.
getDiskSpacedUsedKB
(
)
)
;
if
(
Versions
.
feature16Plus
)
{
Telemetry
.
addToHistogram
(
"
BROWSER_IS_ASSIST_DEFAULT
"
(
isDefaultBrowser
(
Intent
.
ACTION_ASSIST
)
?
1
:
0
)
)
;
}
}
else
if
(
"
Updater
:
Launch
"
.
equals
(
event
)
)
{
handleUpdaterLaunch
(
)
;
}
else
if
(
"
Download
:
AndroidDownloadManager
"
.
equals
(
event
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
String
filename
=
message
.
getString
(
"
filename
"
)
;
final
String
mimeType
=
message
.
getString
(
"
mimeType
"
)
;
final
DownloadManager
.
Request
request
=
new
DownloadManager
.
Request
(
Uri
.
parse
(
uri
)
)
;
request
.
setMimeType
(
mimeType
)
;
try
{
request
.
setDestinationInExternalFilesDir
(
this
Environment
.
DIRECTORY_DOWNLOADS
filename
)
;
}
catch
(
IllegalStateException
e
)
{
Log
.
e
(
LOGTAG
"
Cannot
create
download
directory
"
)
;
return
;
}
request
.
allowScanningByMediaScanner
(
)
;
request
.
setNotificationVisibility
(
DownloadManager
.
Request
.
VISIBILITY_VISIBLE_NOTIFY_COMPLETED
)
;
request
.
addRequestHeader
(
"
User
-
Agent
"
HardwareUtils
.
isTablet
(
)
?
AppConstants
.
USER_AGENT_FENNEC_TABLET
:
AppConstants
.
USER_AGENT_FENNEC_MOBILE
)
;
try
{
DownloadManager
manager
=
(
DownloadManager
)
getSystemService
(
Context
.
DOWNLOAD_SERVICE
)
;
manager
.
enqueue
(
request
)
;
Log
.
d
(
LOGTAG
"
Enqueued
download
(
Download
Manager
)
"
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
e
(
LOGTAG
"
Download
failed
:
"
+
e
)
;
}
}
else
{
super
.
handleMessage
(
event
message
callback
)
;
}
}
private
void
getFaviconFromCache
(
final
EventCallback
callback
final
String
url
)
{
final
OnFaviconLoadedListener
listener
=
new
OnFaviconLoadedListener
(
)
{
Override
public
void
onFaviconLoaded
(
final
String
url
final
String
faviconURL
final
Bitmap
favicon
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
ByteArrayOutputStream
out
=
null
;
Base64OutputStream
b64
=
null
;
if
(
favicon
=
=
null
)
{
callback
.
sendError
(
"
Failed
to
get
favicon
from
cache
"
)
;
}
else
{
try
{
out
=
new
ByteArrayOutputStream
(
)
;
out
.
write
(
"
data
:
image
/
png
;
base64
"
.
getBytes
(
)
)
;
b64
=
new
Base64OutputStream
(
out
Base64
.
NO_WRAP
)
;
favicon
.
compress
(
Bitmap
.
CompressFormat
.
PNG
100
b64
)
;
callback
.
sendSuccess
(
new
String
(
out
.
toByteArray
(
)
)
)
;
}
catch
(
IOException
e
)
{
Log
.
w
(
LOGTAG
"
Failed
to
convert
to
base64
data
URI
"
)
;
callback
.
sendError
(
"
Failed
to
convert
favicon
to
a
base64
data
URI
"
)
;
}
finally
{
try
{
if
(
out
!
=
null
)
{
out
.
close
(
)
;
}
if
(
b64
!
=
null
)
{
b64
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
w
(
LOGTAG
"
Failed
to
close
the
streams
"
)
;
}
}
}
}
}
)
;
}
}
;
Favicons
.
getSizedFaviconForPageFromLocal
(
getContext
(
)
url
listener
)
;
}
private
boolean
isDefaultBrowser
(
String
action
)
{
final
Intent
viewIntent
=
new
Intent
(
action
Uri
.
parse
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
)
;
final
ResolveInfo
info
=
getPackageManager
(
)
.
resolveActivity
(
viewIntent
PackageManager
.
MATCH_DEFAULT_ONLY
)
;
if
(
info
=
=
null
)
{
return
false
;
}
final
String
packageName
=
info
.
activityInfo
.
packageName
;
return
(
TextUtils
.
equals
(
packageName
getPackageName
(
)
)
)
;
}
Override
public
void
handleMessage
(
String
event
JSONObject
message
)
{
try
{
if
(
event
.
equals
(
"
Menu
:
Open
"
)
)
{
if
(
mBrowserToolbar
.
isEditing
(
)
)
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
openOptionsMenu
(
)
;
}
else
if
(
event
.
equals
(
"
Menu
:
Update
"
)
)
{
final
int
id
=
message
.
getInt
(
"
id
"
)
+
ADDON_MENU_OFFSET
;
final
JSONObject
options
=
message
.
getJSONObject
(
"
options
"
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
updateAddonMenuItem
(
id
options
)
;
}
}
)
;
}
else
if
(
event
.
equals
(
"
Gecko
:
DelayedStartup
"
)
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
ensureTabsPanelExists
(
)
;
if
(
AppConstants
.
NIGHTLY_BUILD
&
&
mZoomedView
=
=
null
)
{
ViewStub
stub
=
(
ViewStub
)
findViewById
(
R
.
id
.
zoomed_view_stub
)
;
mZoomedView
=
(
ZoomedView
)
stub
.
inflate
(
)
;
}
}
}
)
;
if
(
AppConstants
.
MOZ_MEDIA_PLAYER
)
{
final
Class
<
?
>
mediaManagerClass
=
getMediaPlayerManager
(
)
;
if
(
mediaManagerClass
!
=
null
)
{
try
{
final
String
tag
=
"
"
;
mediaManagerClass
.
getDeclaredField
(
"
MEDIA_PLAYER_TAG
"
)
.
get
(
tag
)
;
Log
.
i
(
LOGTAG
"
Found
tag
"
+
tag
)
;
final
Fragment
frag
=
getSupportFragmentManager
(
)
.
findFragmentByTag
(
tag
)
;
if
(
frag
=
=
null
)
{
final
Method
getInstance
=
mediaManagerClass
.
getMethod
(
"
newInstance
"
(
Class
[
]
)
null
)
;
final
Fragment
mpm
=
(
Fragment
)
getInstance
.
invoke
(
null
)
;
getSupportFragmentManager
(
)
.
beginTransaction
(
)
.
disallowAddToBackStack
(
)
.
add
(
mpm
tag
)
.
commit
(
)
;
}
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Error
initializing
media
manager
"
ex
)
;
}
}
}
if
(
AppConstants
.
MOZ_STUMBLER_BUILD_TIME_ENABLED
&
&
Restrictions
.
isAllowed
(
this
Restrictable
.
DATA_CHOICES
)
)
{
final
long
oneSecondInMillis
=
1000
;
ThreadUtils
.
getBackgroundHandler
(
)
.
postDelayed
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoPreferences
.
broadcastStumblerPref
(
BrowserApp
.
this
)
;
}
}
oneSecondInMillis
)
;
}
if
(
AppConstants
.
MOZ_ANDROID_DOWNLOAD_CONTENT_SERVICE
)
{
DownloadContentService
.
startSync
(
this
)
;
DownloadContentService
.
startVerification
(
this
)
;
}
FeedService
.
setup
(
this
)
;
super
.
handleMessage
(
event
message
)
;
}
else
if
(
event
.
equals
(
"
Gecko
:
Ready
"
)
)
{
super
.
handleMessage
(
event
message
)
;
final
Menu
menu
=
mMenu
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
menu
!
=
null
)
{
menu
.
findItem
(
R
.
id
.
settings
)
.
setEnabled
(
true
)
;
menu
.
findItem
(
R
.
id
.
help
)
.
setEnabled
(
true
)
;
}
}
}
)
;
if
(
AppConstants
.
MOZ_DATA_REPORTING
&
&
Restrictions
.
isAllowed
(
this
Restrictable
.
DATA_CHOICES
)
)
{
DataReportingNotification
.
checkAndNotifyPolicy
(
GeckoAppShell
.
getContext
(
)
)
;
}
}
else
if
(
event
.
equals
(
"
Search
:
Keyword
"
)
)
{
storeSearchQuery
(
message
.
getString
(
"
query
"
)
)
;
recordSearch
(
GeckoSharedPrefs
.
forProfile
(
this
)
message
.
getString
(
"
identifier
"
)
TelemetryContract
.
Method
.
ACTIONBAR
)
;
}
else
if
(
event
.
equals
(
"
LightweightTheme
:
Update
"
)
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
)
;
}
else
if
(
event
.
equals
(
"
Video
:
Play
"
)
)
{
final
String
uri
=
message
.
getString
(
"
uri
"
)
;
final
String
uuid
=
message
.
getString
(
"
uuid
"
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mVideoPlayer
.
start
(
Uri
.
parse
(
uri
)
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHOW
TelemetryContract
.
Method
.
CONTENT
"
playhls
"
)
;
}
}
)
;
}
else
if
(
event
.
equals
(
"
Prompt
:
ShowTop
"
)
)
{
Intent
bringToFrontIntent
=
new
Intent
(
)
;
bringToFrontIntent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
bringToFrontIntent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_REORDER_TO_FRONT
)
;
startActivity
(
bringToFrontIntent
)
;
}
else
{
super
.
handleMessage
(
event
message
)
;
}
}
catch
(
Exception
e
)
{
Log
.
e
(
LOGTAG
"
Exception
handling
message
\
"
"
+
event
+
"
\
"
:
"
e
)
;
}
}
Override
public
void
addTab
(
)
{
Tabs
.
getInstance
(
)
.
addTab
(
)
;
}
Override
public
void
addPrivateTab
(
)
{
Tabs
.
getInstance
(
)
.
addPrivateTab
(
)
;
}
public
void
showTrackingProtectionPromptIfApplicable
(
)
{
final
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
final
boolean
hasTrackingProtectionPromptBeShownBefore
=
prefs
.
getBoolean
(
GeckoPreferences
.
PREFS_TRACKING_PROTECTION_PROMPT_SHOWN
false
)
;
if
(
hasTrackingProtectionPromptBeShownBefore
)
{
return
;
}
prefs
.
edit
(
)
.
putBoolean
(
GeckoPreferences
.
PREFS_TRACKING_PROTECTION_PROMPT_SHOWN
true
)
.
apply
(
)
;
startActivity
(
new
Intent
(
BrowserApp
.
this
TrackingProtectionPrompt
.
class
)
)
;
}
Override
public
void
showNormalTabs
(
)
{
showTabs
(
TabsPanel
.
Panel
.
NORMAL_TABS
)
;
}
Override
public
void
showPrivateTabs
(
)
{
showTabs
(
TabsPanel
.
Panel
.
PRIVATE_TABS
)
;
}
private
boolean
ensureTabsPanelExists
(
)
{
if
(
mTabsPanel
!
=
null
)
{
return
false
;
}
ViewStub
tabsPanelStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
tabs_panel
)
;
mTabsPanel
=
(
TabsPanel
)
tabsPanelStub
.
inflate
(
)
;
mTabsPanel
.
setTabsLayoutChangeListener
(
this
)
;
return
true
;
}
private
void
showTabs
(
final
TabsPanel
.
Panel
panel
)
{
if
(
Tabs
.
getInstance
(
)
.
getDisplayCount
(
)
=
=
0
)
return
;
hideFirstrunPager
(
TelemetryContract
.
Method
.
BUTTON
)
;
if
(
ensureTabsPanelExists
(
)
)
{
ViewTreeObserver
vto
=
mTabsPanel
.
getViewTreeObserver
(
)
;
if
(
vto
.
isAlive
(
)
)
{
vto
.
addOnGlobalLayoutListener
(
new
ViewTreeObserver
.
OnGlobalLayoutListener
(
)
{
Override
public
void
onGlobalLayout
(
)
{
mTabsPanel
.
getViewTreeObserver
(
)
.
removeGlobalOnLayoutListener
(
this
)
;
showTabs
(
panel
)
;
}
}
)
;
}
}
else
{
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
disable
(
)
;
}
mTabsPanel
.
show
(
panel
)
;
mFindInPageBar
.
hide
(
)
;
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onTabsTrayShown
(
this
mTabsPanel
)
;
}
}
}
Override
public
void
hideTabs
(
)
{
mTabsPanel
.
hide
(
)
;
if
(
mDoorHangerPopup
!
=
null
)
{
mDoorHangerPopup
.
enable
(
)
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onTabsTrayHidden
(
this
mTabsPanel
)
;
}
}
Override
public
boolean
autoHideTabs
(
)
{
if
(
areTabsShown
(
)
)
{
hideTabs
(
)
;
return
true
;
}
return
false
;
}
Override
public
boolean
areTabsShown
(
)
{
return
(
mTabsPanel
!
=
null
&
&
mTabsPanel
.
isShown
(
)
)
;
}
Override
public
String
getHomepage
(
)
{
final
SharedPreferences
preferences
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
String
homepagePreference
=
preferences
.
getString
(
GeckoPreferences
.
PREFS_HOMEPAGE
null
)
;
final
boolean
readFromPartnerProvider
=
preferences
.
getBoolean
(
GeckoPreferences
.
PREFS_READ_PARTNER_CUSTOMIZATIONS_PROVIDER
false
)
;
if
(
!
readFromPartnerProvider
)
{
return
homepagePreference
;
}
final
String
homepagePrevious
=
preferences
.
getString
(
GeckoPreferences
.
PREFS_HOMEPAGE_PARTNER_COPY
null
)
;
if
(
homepagePrevious
!
=
null
&
&
!
homepagePrevious
.
equals
(
homepagePreference
)
)
{
return
homepagePreference
;
}
final
String
homepagePartner
=
PartnerBrowserCustomizationsClient
.
getHomepage
(
this
)
;
if
(
homepagePartner
=
=
null
)
{
return
homepagePreference
;
}
if
(
!
homepagePartner
.
equals
(
homepagePrevious
)
)
{
preferences
.
edit
(
)
.
putString
(
GeckoPreferences
.
PREFS_HOMEPAGE
homepagePartner
)
.
putString
(
GeckoPreferences
.
PREFS_HOMEPAGE_PARTNER_COPY
homepagePartner
)
.
apply
(
)
;
}
return
homepagePartner
;
}
Override
public
void
onTabsLayoutChange
(
int
width
int
height
)
{
int
animationLength
=
TABS_ANIMATION_DURATION
;
if
(
mMainLayoutAnimator
!
=
null
)
{
animationLength
=
Math
.
max
(
1
animationLength
-
(
int
)
mMainLayoutAnimator
.
getRemainingTime
(
)
)
;
mMainLayoutAnimator
.
stop
(
false
)
;
}
if
(
areTabsShown
(
)
)
{
mTabsPanel
.
setDescendantFocusability
(
ViewGroup
.
FOCUS_AFTER_DESCENDANTS
)
;
if
(
Versions
.
feature16Plus
)
{
mLayerView
.
setImportantForAccessibility
(
View
.
IMPORTANT_FOR_ACCESSIBILITY_NO
)
;
}
}
else
{
if
(
Versions
.
feature16Plus
)
{
mLayerView
.
setImportantForAccessibility
(
View
.
IMPORTANT_FOR_ACCESSIBILITY_YES
)
;
}
}
mMainLayoutAnimator
=
new
PropertyAnimator
(
animationLength
sTabsInterpolator
)
;
mMainLayoutAnimator
.
addPropertyAnimationListener
(
this
)
;
mMainLayoutAnimator
.
attach
(
mMainLayout
PropertyAnimator
.
Property
.
SCROLL_Y
-
height
)
;
mTabsPanel
.
prepareTabsAnimation
(
mMainLayoutAnimator
)
;
mBrowserToolbar
.
triggerTabsPanelTransition
(
mMainLayoutAnimator
areTabsShown
(
)
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
if
(
width
>
0
&
&
height
>
0
)
{
mDynamicToolbar
.
setPinned
(
true
PinReason
.
RELAYOUT
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
else
{
mDynamicToolbar
.
setPinned
(
false
PinReason
.
RELAYOUT
)
;
}
}
mMainLayoutAnimator
.
start
(
)
;
}
Override
public
void
onPropertyAnimationStart
(
)
{
}
Override
public
void
onPropertyAnimationEnd
(
)
{
if
(
!
areTabsShown
(
)
)
{
mTabsPanel
.
setVisibility
(
View
.
INVISIBLE
)
;
mTabsPanel
.
setDescendantFocusability
(
ViewGroup
.
FOCUS_BLOCK_DESCENDANTS
)
;
}
else
{
mBrowserToolbar
.
cancelEdit
(
)
;
}
mTabsPanel
.
finishTabsAnimation
(
)
;
mMainLayoutAnimator
=
null
;
}
Override
public
void
onSaveInstanceState
(
Bundle
outState
)
{
super
.
onSaveInstanceState
(
outState
)
;
mDynamicToolbar
.
onSaveInstanceState
(
outState
)
;
outState
.
putInt
(
STATE_ABOUT_HOME_TOP_PADDING
mHomeScreenContainer
.
getPaddingTop
(
)
)
;
}
private
boolean
maybeSwitchToTab
(
String
url
EnumSet
<
OnUrlOpenListener
.
Flags
>
flags
)
{
if
(
!
flags
.
contains
(
OnUrlOpenListener
.
Flags
.
ALLOW_SWITCH_TO_TAB
)
)
{
return
false
;
}
final
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
final
Tab
tab
;
if
(
AboutPages
.
isAboutReader
(
url
)
)
{
tab
=
tabs
.
getFirstReaderTabForUrl
(
url
tabs
.
getSelectedTab
(
)
.
isPrivate
(
)
)
;
}
else
{
tab
=
tabs
.
getFirstTabForUrl
(
url
tabs
.
getSelectedTab
(
)
.
isPrivate
(
)
)
;
}
if
(
tab
=
=
null
)
{
return
false
;
}
return
maybeSwitchToTab
(
tab
.
getId
(
)
)
;
}
private
boolean
maybeSwitchToTab
(
int
id
)
{
final
Tabs
tabs
=
Tabs
.
getInstance
(
)
;
final
Tab
tab
=
tabs
.
getTab
(
id
)
;
if
(
tab
=
=
null
)
{
return
false
;
}
final
Tab
oldTab
=
tabs
.
getSelectedTab
(
)
;
if
(
oldTab
!
=
null
)
{
oldTab
.
setIsEditing
(
false
)
;
}
mTargetTabForEditingMode
=
null
;
tabs
.
selectTab
(
tab
.
getId
(
)
)
;
mBrowserToolbar
.
cancelEdit
(
)
;
return
true
;
}
public
void
openUrlAndStopEditing
(
String
url
)
{
openUrlAndStopEditing
(
url
null
false
)
;
}
private
void
openUrlAndStopEditing
(
String
url
boolean
newTab
)
{
openUrlAndStopEditing
(
url
null
newTab
)
;
}
private
void
openUrlAndStopEditing
(
String
url
String
searchEngine
)
{
openUrlAndStopEditing
(
url
searchEngine
false
)
;
}
private
void
openUrlAndStopEditing
(
String
url
String
searchEngine
boolean
newTab
)
{
int
flags
=
Tabs
.
LOADURL_NONE
;
if
(
newTab
)
{
flags
|
=
Tabs
.
LOADURL_NEW_TAB
;
if
(
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
isPrivate
(
)
)
{
flags
|
=
Tabs
.
LOADURL_PRIVATE
;
}
}
Tabs
.
getInstance
(
)
.
loadUrl
(
url
searchEngine
-
1
flags
)
;
mBrowserToolbar
.
cancelEdit
(
)
;
}
private
boolean
isHomePagerVisible
(
)
{
return
(
mHomeScreen
!
=
null
&
&
mHomeScreen
.
isVisible
(
)
&
&
mHomeScreenContainer
!
=
null
&
&
mHomeScreenContainer
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
;
}
private
boolean
isFirstrunVisible
(
)
{
return
(
mFirstrunAnimationContainer
!
=
null
&
&
mFirstrunAnimationContainer
.
isVisible
(
)
&
&
mHomeScreenContainer
!
=
null
&
&
mHomeScreenContainer
.
getVisibility
(
)
=
=
View
.
VISIBLE
)
;
}
private
void
enterEditingMode
(
)
{
String
url
=
"
"
;
String
telemetryMsg
=
"
urlbar
-
empty
"
;
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
final
String
userSearchTerm
=
tab
.
getUserRequested
(
)
;
final
String
tabURL
=
tab
.
getURL
(
)
;
if
(
!
TextUtils
.
isEmpty
(
userSearchTerm
)
)
{
url
=
userSearchTerm
;
telemetryMsg
=
"
urlbar
-
userentered
"
;
}
else
if
(
!
TextUtils
.
isEmpty
(
tabURL
)
)
{
url
=
tabURL
;
telemetryMsg
=
"
urlbar
-
url
"
;
}
}
enterEditingMode
(
url
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHOW
TelemetryContract
.
Method
.
ACTIONBAR
telemetryMsg
)
;
}
private
void
enterEditingMode
(
NonNull
String
url
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
ACTIONBAR
)
;
if
(
mBrowserToolbar
.
isEditing
(
)
|
|
mBrowserToolbar
.
isAnimating
(
)
)
{
return
;
}
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
String
panelId
;
if
(
selectedTab
!
=
null
)
{
mTargetTabForEditingMode
=
selectedTab
.
getId
(
)
;
panelId
=
selectedTab
.
getMostRecentHomePanel
(
)
;
}
else
{
mTargetTabForEditingMode
=
null
;
panelId
=
null
;
}
final
PropertyAnimator
animator
=
new
PropertyAnimator
(
250
)
;
animator
.
setUseHardwareLayer
(
false
)
;
mBrowserToolbar
.
startEditing
(
url
animator
)
;
showHomePagerWithAnimator
(
panelId
null
animator
)
;
animator
.
start
(
)
;
Telemetry
.
startUISession
(
TelemetryContract
.
Session
.
AWESOMESCREEN
)
;
}
private
void
commitEditingMode
(
)
{
if
(
!
mBrowserToolbar
.
isEditing
(
)
)
{
return
;
}
Telemetry
.
stopUISession
(
TelemetryContract
.
Session
.
AWESOMESCREEN
TelemetryContract
.
Reason
.
COMMIT
)
;
final
String
url
=
mBrowserToolbar
.
commitEdit
(
)
;
hideHomePager
(
url
)
;
loadUrlOrKeywordSearch
(
url
)
;
clearSelectedTabApplicationId
(
)
;
}
private
void
clearSelectedTabApplicationId
(
)
{
final
Tab
selected
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selected
!
=
null
)
{
selected
.
setApplicationId
(
null
)
;
}
}
private
void
loadUrlOrKeywordSearch
(
final
String
url
)
{
if
(
TextUtils
.
isEmpty
(
url
)
)
{
return
;
}
if
(
!
StringUtils
.
isSearchQuery
(
url
true
)
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
url
Tabs
.
LOADURL_USER_ENTERED
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
ACTIONBAR
"
user
"
)
;
return
;
}
final
SharedPreferences
sharedPrefs
=
GeckoSharedPrefs
.
forProfile
(
this
)
;
final
BrowserDB
db
=
getProfile
(
)
.
getDB
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
String
keyword
;
final
String
keywordSearch
;
final
int
index
=
url
.
indexOf
(
"
"
)
;
if
(
index
=
=
-
1
)
{
keyword
=
url
;
keywordSearch
=
"
"
;
}
else
{
keyword
=
url
.
substring
(
0
index
)
;
keywordSearch
=
url
.
substring
(
index
+
1
)
;
}
final
String
keywordUrl
=
db
.
getUrlForKeyword
(
getContentResolver
(
)
keyword
)
;
if
(
TextUtils
.
isEmpty
(
keywordUrl
)
)
{
Tabs
.
getInstance
(
)
.
loadUrl
(
url
Tabs
.
LOADURL_USER_ENTERED
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
ACTIONBAR
"
user
"
)
;
return
;
}
final
String
searchUrl
=
keywordUrl
.
replace
(
"
%
s
"
URLEncoder
.
encode
(
keywordSearch
)
)
.
replace
(
"
%
S
"
keywordSearch
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
searchUrl
Tabs
.
LOADURL_USER_ENTERED
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
ACTIONBAR
"
keyword
"
)
;
}
}
)
;
}
private
static
void
recordSearch
(
NonNull
final
SharedPreferences
prefs
NonNull
final
String
engineIdentifier
NonNull
final
TelemetryContract
.
Method
where
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SEARCH
where
)
;
SearchCountMeasurements
.
incrementSearch
(
prefs
engineIdentifier
where
.
toString
(
)
)
;
}
private
void
storeSearchQuery
(
final
String
query
)
{
if
(
TextUtils
.
isEmpty
(
query
)
)
{
return
;
}
if
(
query
.
length
(
)
>
50
|
|
Pattern
.
matches
(
"
^
(
https
?
|
ftp
|
file
)
:
/
/
.
*
"
query
)
)
{
return
;
}
final
GeckoProfile
profile
=
getProfile
(
)
;
if
(
profile
.
inGuestMode
(
)
)
{
return
;
}
final
BrowserDB
db
=
profile
.
getDB
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
db
.
getSearches
(
)
.
insert
(
getContentResolver
(
)
query
)
;
}
}
)
;
}
void
filterEditingMode
(
String
searchTerm
AutocompleteHandler
handler
)
{
if
(
TextUtils
.
isEmpty
(
searchTerm
)
)
{
hideBrowserSearch
(
)
;
}
else
{
showBrowserSearch
(
)
;
mBrowserSearch
.
filter
(
searchTerm
handler
)
;
}
}
private
void
selectTargetTabForEditingMode
(
)
{
if
(
HardwareUtils
.
isTablet
(
)
)
{
return
;
}
if
(
mTargetTabForEditingMode
!
=
null
)
{
Tabs
.
getInstance
(
)
.
selectTab
(
mTargetTabForEditingMode
)
;
}
mTargetTabForEditingMode
=
null
;
}
private
void
updateHomePagerForTab
(
Tab
tab
)
{
if
(
mBrowserToolbar
.
isEditing
(
)
)
{
return
;
}
if
(
isAboutHome
(
tab
)
)
{
String
panelId
=
AboutPages
.
getPanelIdFromAboutHomeUrl
(
tab
.
getURL
(
)
)
;
Bundle
panelRestoreData
=
null
;
if
(
panelId
=
=
null
)
{
panelId
=
tab
.
getMostRecentHomePanel
(
)
;
panelRestoreData
=
tab
.
getMostRecentHomePanelData
(
)
;
}
else
if
(
panelId
.
equals
(
HomeConfig
.
getIdForBuiltinPanelType
(
PanelType
.
DEPRECATED_RECENT_TABS
)
)
)
{
panelId
=
HomeConfig
.
getIdForBuiltinPanelType
(
PanelType
.
COMBINED_HISTORY
)
;
panelRestoreData
=
new
Bundle
(
)
;
panelRestoreData
.
putBoolean
(
"
goToRecentTabs
"
true
)
;
}
showHomePager
(
panelId
panelRestoreData
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
else
{
hideHomePager
(
)
;
}
}
Override
public
void
onLocaleReady
(
final
String
locale
)
{
Log
.
d
(
LOGTAG
"
onLocaleReady
:
"
+
locale
)
;
super
.
onLocaleReady
(
locale
)
;
HomePanelsManager
.
getInstance
(
)
.
onLocaleReady
(
locale
)
;
if
(
mMenu
!
=
null
)
{
mMenu
.
clear
(
)
;
onCreateOptionsMenu
(
mMenu
)
;
}
if
(
!
Versions
.
feature14Plus
)
{
conditionallyNotifyEOL
(
)
;
}
}
Override
public
void
onActivityResult
(
int
requestCode
int
resultCode
Intent
data
)
{
Log
.
d
(
LOGTAG
"
onActivityResult
:
"
+
requestCode
+
"
"
+
resultCode
+
"
"
+
data
)
;
switch
(
requestCode
)
{
case
ACTIVITY_REQUEST_PREFERENCES
:
if
(
resultCode
!
=
GeckoPreferences
.
RESULT_CODE_LOCALE_DID_CHANGE
)
{
Log
.
d
(
LOGTAG
"
No
locale
change
returning
from
preferences
;
nothing
to
do
.
"
)
;
return
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
final
LocaleManager
localeManager
=
BrowserLocaleManager
.
getInstance
(
)
;
final
Locale
locale
=
localeManager
.
getCurrentLocale
(
getApplicationContext
(
)
)
;
Log
.
d
(
LOGTAG
"
Read
persisted
locale
"
+
locale
)
;
if
(
locale
=
=
null
)
{
return
;
}
onLocaleChanged
(
Locales
.
getLanguageTag
(
locale
)
)
;
}
}
)
;
break
;
case
ACTIVITY_REQUEST_TAB_QUEUE
:
TabQueueHelper
.
processTabQueuePromptResponse
(
resultCode
this
)
;
break
;
default
:
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onActivityResult
(
this
requestCode
resultCode
data
)
;
}
super
.
onActivityResult
(
requestCode
resultCode
data
)
;
}
}
private
void
showFirstrunPager
(
)
{
if
(
Experiments
.
isInExperimentLocal
(
getContext
(
)
Experiments
.
ONBOARDING3_A
)
)
{
Telemetry
.
startUISession
(
TelemetryContract
.
Session
.
EXPERIMENT
Experiments
.
ONBOARDING3_A
)
;
GeckoSharedPrefs
.
forProfile
(
getContext
(
)
)
.
edit
(
)
.
putString
(
Experiments
.
PREF_ONBOARDING_VERSION
Experiments
.
ONBOARDING3_A
)
.
apply
(
)
;
Telemetry
.
stopUISession
(
TelemetryContract
.
Session
.
EXPERIMENT
Experiments
.
ONBOARDING3_A
)
;
return
;
}
if
(
mFirstrunAnimationContainer
=
=
null
)
{
final
ViewStub
firstrunPagerStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
firstrun_pager_stub
)
;
mFirstrunAnimationContainer
=
(
FirstrunAnimationContainer
)
firstrunPagerStub
.
inflate
(
)
;
mFirstrunAnimationContainer
.
load
(
getApplicationContext
(
)
getSupportFragmentManager
(
)
)
;
mFirstrunAnimationContainer
.
registerOnFinishListener
(
new
FirstrunAnimationContainer
.
OnFinishListener
(
)
{
Override
public
void
onFinish
(
)
{
if
(
mFirstrunAnimationContainer
.
showBrowserHint
(
)
)
{
enterEditingMode
(
)
;
}
}
}
)
;
}
mHomeScreenContainer
.
setVisibility
(
View
.
VISIBLE
)
;
}
private
void
showHomePager
(
String
panelId
Bundle
panelRestoreData
)
{
showHomePagerWithAnimator
(
panelId
panelRestoreData
null
)
;
}
private
void
showHomePagerWithAnimator
(
String
panelId
Bundle
panelRestoreData
PropertyAnimator
animator
)
{
if
(
isHomePagerVisible
(
)
)
{
mHomeScreen
.
showPanel
(
panelId
panelRestoreData
)
;
return
;
}
mFormAssistPopup
.
hide
(
)
;
mFindInPageBar
.
hide
(
)
;
refreshToolbarHeight
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
if
(
mHomeScreen
=
=
null
)
{
if
(
ActivityStream
.
isEnabled
(
this
)
&
&
!
ActivityStream
.
isHomePanel
(
)
)
{
final
ViewStub
asStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
activity_stream_stub
)
;
mHomeScreen
=
(
HomeScreen
)
asStub
.
inflate
(
)
;
}
else
{
final
ViewStub
homePagerStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
home_pager_stub
)
;
mHomeScreen
=
(
HomeScreen
)
homePagerStub
.
inflate
(
)
;
mHomeScreen
.
setOnPanelChangeListener
(
new
HomeScreen
.
OnPanelChangeListener
(
)
{
Override
public
void
onPanelSelected
(
String
panelId
)
{
final
Tab
currentTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
currentTab
!
=
null
)
{
currentTab
.
setMostRecentHomePanel
(
panelId
)
;
}
}
}
)
;
mHomeScreen
.
setPanelStateChangeListener
(
new
HomeFragment
.
PanelStateChangeListener
(
)
{
Override
public
void
onStateChanged
(
Bundle
bundle
)
{
final
Tab
currentTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
currentTab
!
=
null
)
{
currentTab
.
setMostRecentHomePanelData
(
bundle
)
;
}
}
}
)
;
}
if
(
!
Restrictions
.
isUserRestricted
(
)
)
{
final
ViewStub
homeBannerStub
=
(
ViewStub
)
findViewById
(
R
.
id
.
home_banner_stub
)
;
final
HomeBanner
homeBanner
=
(
HomeBanner
)
homeBannerStub
.
inflate
(
)
;
mHomeScreen
.
setBanner
(
homeBanner
)
;
homeBanner
.
setOnDismissListener
(
new
HomeBanner
.
OnDismissListener
(
)
{
Override
public
void
onDismiss
(
)
{
mHomeScreen
.
setBanner
(
null
)
;
mHomeScreenContainer
.
removeView
(
homeBanner
)
;
}
}
)
;
}
}
mHomeScreenContainer
.
setVisibility
(
View
.
VISIBLE
)
;
mHomeScreen
.
load
(
getSupportLoaderManager
(
)
getSupportFragmentManager
(
)
panelId
panelRestoreData
animator
)
;
hideWebContentOnPropertyAnimationEnd
(
animator
)
;
}
private
void
hideWebContentOnPropertyAnimationEnd
(
final
PropertyAnimator
animator
)
{
if
(
animator
=
=
null
)
{
hideWebContent
(
)
;
return
;
}
animator
.
addPropertyAnimationListener
(
new
PropertyAnimator
.
PropertyAnimationListener
(
)
{
Override
public
void
onPropertyAnimationStart
(
)
{
mHideWebContentOnAnimationEnd
=
true
;
}
Override
public
void
onPropertyAnimationEnd
(
)
{
if
(
mHideWebContentOnAnimationEnd
)
{
hideWebContent
(
)
;
}
}
}
)
;
}
private
void
hideWebContent
(
)
{
mLayerView
.
setVisibility
(
View
.
INVISIBLE
)
;
}
private
boolean
hideFirstrunPager
(
TelemetryContract
.
Method
method
)
{
if
(
!
isFirstrunVisible
(
)
)
{
return
false
;
}
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
CANCEL
method
"
firstrun
-
pane
"
)
;
mFirstrunAnimationContainer
.
registerOnFinishListener
(
null
)
;
mFirstrunAnimationContainer
.
hide
(
)
;
return
true
;
}
private
void
hideHomePager
(
)
{
final
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
String
url
=
(
selectedTab
!
=
null
)
?
selectedTab
.
getURL
(
)
:
null
;
hideHomePager
(
url
)
;
}
private
void
hideHomePager
(
final
String
url
)
{
if
(
!
isHomePagerVisible
(
)
|
|
AboutPages
.
isAboutHome
(
url
)
)
{
return
;
}
mHideWebContentOnAnimationEnd
=
false
;
mLayerView
.
setVisibility
(
View
.
VISIBLE
)
;
mHomeScreenContainer
.
setVisibility
(
View
.
GONE
)
;
if
(
mHomeScreen
!
=
null
)
{
mHomeScreen
.
unload
(
)
;
}
mBrowserToolbar
.
setNextFocusDownId
(
R
.
id
.
layer_view
)
;
refreshToolbarHeight
(
)
;
}
private
void
showBrowserSearchAfterAnimation
(
PropertyAnimator
animator
)
{
if
(
animator
=
=
null
)
{
showBrowserSearch
(
)
;
return
;
}
animator
.
addPropertyAnimationListener
(
new
PropertyAnimator
.
PropertyAnimationListener
(
)
{
Override
public
void
onPropertyAnimationStart
(
)
{
}
Override
public
void
onPropertyAnimationEnd
(
)
{
showBrowserSearch
(
)
;
}
}
)
;
}
private
void
showBrowserSearch
(
)
{
if
(
mBrowserSearch
.
getUserVisibleHint
(
)
)
{
return
;
}
mBrowserSearchContainer
.
setVisibility
(
View
.
VISIBLE
)
;
hideWebContent
(
)
;
mHomeScreenContainer
.
setVisibility
(
View
.
INVISIBLE
)
;
final
FragmentManager
fm
=
getSupportFragmentManager
(
)
;
fm
.
executePendingTransactions
(
)
;
Fragment
f
=
fm
.
findFragmentById
(
R
.
id
.
search_container
)
;
if
(
f
!
=
null
)
{
fm
.
beginTransaction
(
)
.
show
(
f
)
.
commitAllowingStateLoss
(
)
;
mBrowserSearch
.
resetScrollState
(
)
;
}
else
{
fm
.
beginTransaction
(
)
.
add
(
R
.
id
.
search_container
mBrowserSearch
BROWSER_SEARCH_TAG
)
.
commitAllowingStateLoss
(
)
;
}
mBrowserSearch
.
setUserVisibleHint
(
true
)
;
getActivity
(
)
.
getWindow
(
)
.
setBackgroundDrawableResource
(
android
.
R
.
color
.
white
)
;
}
private
void
hideBrowserSearch
(
)
{
if
(
!
mBrowserSearch
.
getUserVisibleHint
(
)
)
{
return
;
}
showHomePager
(
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
getMostRecentHomePanel
(
)
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
getMostRecentHomePanelData
(
)
)
;
mBrowserSearchContainer
.
setVisibility
(
View
.
INVISIBLE
)
;
getSupportFragmentManager
(
)
.
beginTransaction
(
)
.
hide
(
mBrowserSearch
)
.
commitAllowingStateLoss
(
)
;
mBrowserSearch
.
setUserVisibleHint
(
false
)
;
getWindow
(
)
.
setBackgroundDrawable
(
null
)
;
}
private
class
HideOnTouchListener
implements
TouchEventInterceptor
{
private
boolean
mIsHidingTabs
;
private
final
Rect
mTempRect
=
new
Rect
(
)
;
Override
public
boolean
onInterceptTouchEvent
(
View
view
MotionEvent
event
)
{
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
)
{
SnackbarBuilder
.
dismissCurrentSnackbar
(
)
;
}
if
(
view
.
getScrollX
(
)
!
=
0
|
|
view
.
getScrollY
(
)
!
=
0
)
{
view
.
getHitRect
(
mTempRect
)
;
mTempRect
.
offset
(
-
view
.
getScrollX
(
)
-
view
.
getScrollY
(
)
)
;
int
[
]
viewCoords
=
new
int
[
2
]
;
view
.
getLocationOnScreen
(
viewCoords
)
;
int
x
=
(
int
)
event
.
getRawX
(
)
-
viewCoords
[
0
]
;
int
y
=
(
int
)
event
.
getRawY
(
)
-
viewCoords
[
1
]
;
if
(
!
mTempRect
.
contains
(
x
y
)
)
return
false
;
}
if
(
event
.
getActionMasked
(
)
=
=
MotionEvent
.
ACTION_DOWN
&
&
autoHideTabs
(
)
)
{
mIsHidingTabs
=
true
;
return
true
;
}
return
false
;
}
Override
public
boolean
onTouch
(
View
view
MotionEvent
event
)
{
if
(
mIsHidingTabs
)
{
int
action
=
event
.
getActionMasked
(
)
;
if
(
action
=
=
MotionEvent
.
ACTION_UP
|
|
action
=
=
MotionEvent
.
ACTION_CANCEL
)
{
mIsHidingTabs
=
false
;
}
return
true
;
}
return
false
;
}
}
private
static
Menu
findParentMenu
(
Menu
menu
MenuItem
item
)
{
final
int
itemId
=
item
.
getItemId
(
)
;
final
int
count
=
(
menu
!
=
null
)
?
menu
.
size
(
)
:
0
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
MenuItem
menuItem
=
menu
.
getItem
(
i
)
;
if
(
menuItem
.
getItemId
(
)
=
=
itemId
)
{
return
menu
;
}
if
(
menuItem
.
hasSubMenu
(
)
)
{
Menu
parent
=
findParentMenu
(
menuItem
.
getSubMenu
(
)
item
)
;
if
(
parent
!
=
null
)
{
return
parent
;
}
}
}
return
null
;
}
private
void
addAddonMenuItemToMenu
(
final
Menu
menu
final
MenuItemInfo
info
)
{
info
.
added
=
true
;
final
Menu
destination
;
if
(
info
.
parent
=
=
0
)
{
destination
=
menu
;
}
else
if
(
info
.
parent
=
=
GECKO_TOOLS_MENU
)
{
if
(
Versions
.
feature11Plus
)
{
final
MenuItem
tools
=
menu
.
findItem
(
R
.
id
.
tools
)
;
destination
=
tools
!
=
null
?
tools
.
getSubMenu
(
)
:
menu
;
}
else
{
destination
=
menu
;
}
}
else
{
final
MenuItem
parent
=
menu
.
findItem
(
info
.
parent
)
;
if
(
parent
=
=
null
)
{
return
;
}
Menu
parentMenu
=
findParentMenu
(
menu
parent
)
;
if
(
!
parent
.
hasSubMenu
(
)
)
{
parentMenu
.
removeItem
(
parent
.
getItemId
(
)
)
;
destination
=
parentMenu
.
addSubMenu
(
Menu
.
NONE
parent
.
getItemId
(
)
Menu
.
NONE
parent
.
getTitle
(
)
)
;
if
(
parent
.
getIcon
(
)
!
=
null
)
{
(
(
SubMenu
)
destination
)
.
getItem
(
)
.
setIcon
(
parent
.
getIcon
(
)
)
;
}
}
else
{
destination
=
parent
.
getSubMenu
(
)
;
}
}
final
MenuItem
item
=
destination
.
add
(
Menu
.
NONE
info
.
id
Menu
.
NONE
info
.
label
)
;
item
.
setOnMenuItemClickListener
(
new
MenuItem
.
OnMenuItemClickListener
(
)
{
Override
public
boolean
onMenuItemClick
(
MenuItem
item
)
{
GeckoAppShell
.
notifyObservers
(
"
Menu
:
Clicked
"
Integer
.
toString
(
info
.
id
-
ADDON_MENU_OFFSET
)
)
;
return
true
;
}
}
)
;
item
.
setCheckable
(
info
.
checkable
)
;
item
.
setChecked
(
info
.
checked
)
;
item
.
setEnabled
(
info
.
enabled
)
;
item
.
setVisible
(
info
.
visible
)
;
}
private
void
addAddonMenuItem
(
final
MenuItemInfo
info
)
{
if
(
mAddonMenuItemsCache
=
=
null
)
{
mAddonMenuItemsCache
=
new
Vector
<
MenuItemInfo
>
(
)
;
}
info
.
added
=
(
mMenu
!
=
null
)
;
mAddonMenuItemsCache
.
add
(
info
)
;
if
(
mMenu
=
=
null
)
{
return
;
}
addAddonMenuItemToMenu
(
mMenu
info
)
;
}
private
void
removeAddonMenuItem
(
int
id
)
{
if
(
mAddonMenuItemsCache
!
=
null
&
&
!
mAddonMenuItemsCache
.
isEmpty
(
)
)
{
for
(
MenuItemInfo
item
:
mAddonMenuItemsCache
)
{
if
(
item
.
id
=
=
id
)
{
mAddonMenuItemsCache
.
remove
(
item
)
;
break
;
}
}
}
if
(
mMenu
=
=
null
)
return
;
final
MenuItem
menuItem
=
mMenu
.
findItem
(
id
)
;
if
(
menuItem
!
=
null
)
mMenu
.
removeItem
(
id
)
;
}
private
void
updateAddonMenuItem
(
int
id
JSONObject
options
)
{
if
(
mAddonMenuItemsCache
!
=
null
&
&
!
mAddonMenuItemsCache
.
isEmpty
(
)
)
{
for
(
MenuItemInfo
item
:
mAddonMenuItemsCache
)
{
if
(
item
.
id
=
=
id
)
{
item
.
label
=
options
.
optString
(
"
name
"
item
.
label
)
;
item
.
checkable
=
options
.
optBoolean
(
"
checkable
"
item
.
checkable
)
;
item
.
checked
=
options
.
optBoolean
(
"
checked
"
item
.
checked
)
;
item
.
enabled
=
options
.
optBoolean
(
"
enabled
"
item
.
enabled
)
;
item
.
visible
=
options
.
optBoolean
(
"
visible
"
item
.
visible
)
;
item
.
added
=
(
mMenu
!
=
null
)
;
break
;
}
}
}
if
(
mMenu
=
=
null
)
{
return
;
}
final
MenuItem
menuItem
=
mMenu
.
findItem
(
id
)
;
if
(
menuItem
!
=
null
)
{
menuItem
.
setTitle
(
options
.
optString
(
"
name
"
menuItem
.
getTitle
(
)
.
toString
(
)
)
)
;
menuItem
.
setCheckable
(
options
.
optBoolean
(
"
checkable
"
menuItem
.
isCheckable
(
)
)
)
;
menuItem
.
setChecked
(
options
.
optBoolean
(
"
checked
"
menuItem
.
isChecked
(
)
)
)
;
menuItem
.
setEnabled
(
options
.
optBoolean
(
"
enabled
"
menuItem
.
isEnabled
(
)
)
)
;
menuItem
.
setVisible
(
options
.
optBoolean
(
"
visible
"
menuItem
.
isVisible
(
)
)
)
;
}
}
Override
public
boolean
onCreateOptionsMenu
(
Menu
menu
)
{
super
.
onCreateOptionsMenu
(
menu
)
;
if
(
menu
instanceof
GeckoMenu
&
&
HardwareUtils
.
isTablet
(
)
)
{
(
(
GeckoMenu
)
menu
)
.
setActionItemBarPresenter
(
mBrowserToolbar
)
;
}
MenuInflater
inflater
=
getMenuInflater
(
)
;
inflater
.
inflate
(
R
.
menu
.
browser_app_menu
mMenu
)
;
if
(
mAddonMenuItemsCache
!
=
null
&
&
!
mAddonMenuItemsCache
.
isEmpty
(
)
)
{
for
(
MenuItemInfo
item
:
mAddonMenuItemsCache
)
{
addAddonMenuItemToMenu
(
mMenu
item
)
;
}
}
if
(
Versions
.
feature14Plus
)
{
GeckoMenuItem
share
=
(
GeckoMenuItem
)
mMenu
.
findItem
(
R
.
id
.
share
)
;
GeckoActionProvider
provider
=
GeckoActionProvider
.
getForType
(
GeckoActionProvider
.
DEFAULT_MIME_TYPE
this
)
;
share
.
setActionProvider
(
provider
)
;
}
return
true
;
}
Override
public
void
openOptionsMenu
(
)
{
hideFirstrunPager
(
TelemetryContract
.
Method
.
MENU
)
;
if
(
mBrowserToolbar
.
isEditing
(
)
&
&
!
HardwareUtils
.
isTablet
(
)
)
{
return
;
}
if
(
ActivityUtils
.
isFullScreen
(
this
)
)
{
return
;
}
if
(
areTabsShown
(
)
)
{
mTabsPanel
.
showMenu
(
)
;
return
;
}
if
(
mMenuPanel
!
=
null
)
mMenuPanel
.
scrollTo
(
0
0
)
;
if
(
mMenu
instanceof
GeckoMenu
)
{
(
(
GeckoMenu
)
mMenu
)
.
setSelection
(
0
)
;
}
if
(
!
mBrowserToolbar
.
openOptionsMenu
(
)
)
super
.
openOptionsMenu
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
}
Override
public
void
closeOptionsMenu
(
)
{
if
(
!
mBrowserToolbar
.
closeOptionsMenu
(
)
)
super
.
closeOptionsMenu
(
)
;
}
Override
public
void
setFullScreen
(
final
boolean
fullscreen
)
{
super
.
setFullScreen
(
fullscreen
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
fullscreen
)
{
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setVisible
(
false
VisibilityTransition
.
IMMEDIATE
)
;
mDynamicToolbar
.
setPinned
(
true
PinReason
.
FULL_SCREEN
)
;
}
else
{
setToolbarMargin
(
0
)
;
}
mBrowserChrome
.
setVisibility
(
View
.
GONE
)
;
}
else
{
mBrowserChrome
.
setVisibility
(
View
.
VISIBLE
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
)
{
mDynamicToolbar
.
setPinned
(
false
PinReason
.
FULL_SCREEN
)
;
mDynamicToolbar
.
setVisible
(
true
VisibilityTransition
.
IMMEDIATE
)
;
}
else
{
setToolbarMargin
(
mBrowserChrome
.
getHeight
(
)
)
;
}
}
}
}
)
;
}
Override
public
boolean
onPrepareOptionsMenu
(
Menu
aMenu
)
{
if
(
aMenu
=
=
null
)
return
false
;
TabHistoryFragment
frag
=
(
TabHistoryFragment
)
getSupportFragmentManager
(
)
.
findFragmentByTag
(
TAB_HISTORY_FRAGMENT_TAG
)
;
if
(
frag
!
=
null
)
{
frag
.
dismiss
(
)
;
}
if
(
!
GeckoThread
.
isRunning
(
)
)
{
aMenu
.
findItem
(
R
.
id
.
settings
)
.
setEnabled
(
false
)
;
aMenu
.
findItem
(
R
.
id
.
help
)
.
setEnabled
(
false
)
;
}
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
final
MenuItem
bookmark
=
aMenu
.
findItem
(
R
.
id
.
bookmark
)
;
final
MenuItem
back
=
aMenu
.
findItem
(
R
.
id
.
back
)
;
final
MenuItem
forward
=
aMenu
.
findItem
(
R
.
id
.
forward
)
;
final
MenuItem
share
=
aMenu
.
findItem
(
R
.
id
.
share
)
;
final
MenuItem
bookmarksList
=
aMenu
.
findItem
(
R
.
id
.
bookmarks_list
)
;
final
MenuItem
historyList
=
aMenu
.
findItem
(
R
.
id
.
history_list
)
;
final
MenuItem
saveAsPDF
=
aMenu
.
findItem
(
R
.
id
.
save_as_pdf
)
;
final
MenuItem
print
=
aMenu
.
findItem
(
R
.
id
.
print
)
;
final
MenuItem
charEncoding
=
aMenu
.
findItem
(
R
.
id
.
char_encoding
)
;
final
MenuItem
findInPage
=
aMenu
.
findItem
(
R
.
id
.
find_in_page
)
;
final
MenuItem
desktopMode
=
aMenu
.
findItem
(
R
.
id
.
desktop_mode
)
;
final
MenuItem
enterGuestMode
=
aMenu
.
findItem
(
R
.
id
.
new_guest_session
)
;
final
MenuItem
exitGuestMode
=
aMenu
.
findItem
(
R
.
id
.
exit_guest_session
)
;
final
boolean
visible
=
HardwareUtils
.
isTelevision
(
)
|
|
!
PrefUtils
.
getStringSet
(
GeckoSharedPrefs
.
forProfile
(
this
)
ClearOnShutdownPref
.
PREF
new
HashSet
<
String
>
(
)
)
.
isEmpty
(
)
;
aMenu
.
findItem
(
R
.
id
.
quit
)
.
setVisible
(
visible
)
;
if
(
tab
=
=
null
|
|
tab
.
getURL
(
)
=
=
null
)
{
bookmark
.
setEnabled
(
false
)
;
back
.
setEnabled
(
false
)
;
forward
.
setEnabled
(
false
)
;
share
.
setEnabled
(
false
)
;
saveAsPDF
.
setEnabled
(
false
)
;
print
.
setEnabled
(
false
)
;
findInPage
.
setEnabled
(
false
)
;
if
(
Versions
.
feature11Plus
)
{
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
page
false
)
;
}
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
subscribe
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_search_engine
false
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_to_launcher
false
)
;
return
true
;
}
final
boolean
inGuestMode
=
GeckoProfile
.
get
(
this
)
.
inGuestMode
(
)
;
bookmark
.
setEnabled
(
true
)
;
bookmark
.
setVisible
(
!
inGuestMode
)
;
bookmark
.
setCheckable
(
true
)
;
bookmark
.
setChecked
(
tab
.
isBookmark
(
)
)
;
bookmark
.
setTitle
(
resolveBookmarkTitleID
(
tab
.
isBookmark
(
)
)
)
;
if
(
Versions
.
feature11Plus
)
{
bookmark
.
setIcon
(
resolveBookmarkIconID
(
tab
.
isBookmark
(
)
)
)
;
}
back
.
setEnabled
(
tab
.
canDoBack
(
)
)
;
forward
.
setEnabled
(
tab
.
canDoForward
(
)
)
;
desktopMode
.
setChecked
(
tab
.
getDesktopMode
(
)
)
;
View
backButtonView
=
MenuItemCompat
.
getActionView
(
back
)
;
if
(
backButtonView
!
=
null
)
{
backButtonView
.
setOnLongClickListener
(
new
Button
.
OnLongClickListener
(
)
{
Override
public
boolean
onLongClick
(
View
view
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
closeOptionsMenu
(
)
;
return
tabHistoryController
.
showTabHistory
(
tab
TabHistoryController
.
HistoryAction
.
BACK
)
;
}
return
false
;
}
}
)
;
}
View
forwardButtonView
=
MenuItemCompat
.
getActionView
(
forward
)
;
if
(
forwardButtonView
!
=
null
)
{
forwardButtonView
.
setOnLongClickListener
(
new
Button
.
OnLongClickListener
(
)
{
Override
public
boolean
onLongClick
(
View
view
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
closeOptionsMenu
(
)
;
return
tabHistoryController
.
showTabHistory
(
tab
TabHistoryController
.
HistoryAction
.
FORWARD
)
;
}
return
false
;
}
}
)
;
}
String
url
=
tab
.
getURL
(
)
;
if
(
AboutPages
.
isAboutReader
(
url
)
)
{
String
urlFromReader
=
ReaderModeUtils
.
getUrlFromAboutReader
(
url
)
;
if
(
urlFromReader
!
=
null
)
{
url
=
urlFromReader
;
}
}
final
boolean
shareVisible
=
Restrictions
.
isAllowed
(
this
Restrictable
.
SHARE
)
;
share
.
setVisible
(
shareVisible
)
;
final
boolean
shareEnabled
=
StringUtils
.
isShareableUrl
(
url
)
&
&
shareVisible
;
share
.
setEnabled
(
shareEnabled
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
downloads
Restrictions
.
isAllowed
(
this
Restrictable
.
DOWNLOAD
)
)
;
if
(
Versions
.
feature11Plus
)
{
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
page
!
isAboutHome
(
tab
)
)
;
}
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
subscribe
tab
.
hasFeeds
(
)
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_search_engine
tab
.
hasOpenSearch
(
)
)
;
MenuUtils
.
safeSetEnabled
(
aMenu
R
.
id
.
add_to_launcher
!
isAboutHome
(
tab
)
)
;
if
(
Versions
.
feature14Plus
)
{
final
GeckoActionProvider
provider
=
(
(
GeckoMenuItem
)
share
)
.
getGeckoActionProvider
(
)
;
if
(
provider
!
=
null
)
{
Intent
shareIntent
=
provider
.
getIntent
(
)
;
if
(
shareIntent
=
=
null
)
{
shareIntent
=
new
Intent
(
Intent
.
ACTION_SEND
)
;
shareIntent
.
setType
(
"
text
/
plain
"
)
;
provider
.
setIntent
(
shareIntent
)
;
}
shareIntent
.
putExtra
(
Intent
.
EXTRA_TEXT
url
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_SUBJECT
tab
.
getDisplayTitle
(
)
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TITLE
tab
.
getDisplayTitle
(
)
)
;
shareIntent
.
putExtra
(
ShareDialog
.
INTENT_EXTRA_DEVICES_ONLY
true
)
;
shareIntent
.
removeExtra
(
"
share_screenshot_uri
"
)
;
BitmapDrawable
drawable
=
tab
.
getThumbnail
(
)
;
if
(
drawable
!
=
null
)
{
Bitmap
thumbnail
=
drawable
.
getBitmap
(
)
;
if
(
Build
.
MANUFACTURER
.
equals
(
"
Kobo
"
)
&
&
thumbnail
!
=
null
)
{
File
cacheDir
=
getExternalCacheDir
(
)
;
if
(
cacheDir
!
=
null
)
{
File
outFile
=
new
File
(
cacheDir
"
thumbnail
.
png
"
)
;
try
{
final
java
.
io
.
FileOutputStream
out
=
new
java
.
io
.
FileOutputStream
(
outFile
)
;
try
{
thumbnail
.
compress
(
Bitmap
.
CompressFormat
.
PNG
90
out
)
;
}
finally
{
try
{
out
.
close
(
)
;
}
catch
(
final
IOException
e
)
{
}
}
}
catch
(
FileNotFoundException
e
)
{
Log
.
e
(
LOGTAG
"
File
not
found
"
e
)
;
}
shareIntent
.
putExtra
(
"
share_screenshot_uri
"
Uri
.
parse
(
outFile
.
getPath
(
)
)
)
;
}
}
}
}
}
final
boolean
privateTabVisible
=
Restrictions
.
isAllowed
(
this
Restrictable
.
PRIVATE_BROWSING
)
;
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
new_private_tab
privateTabVisible
)
;
boolean
allowPDF
=
(
!
(
isAboutHome
(
tab
)
|
|
tab
.
getContentType
(
)
.
equals
(
"
application
/
vnd
.
mozilla
.
xul
+
xml
"
)
|
|
tab
.
getContentType
(
)
.
startsWith
(
"
video
/
"
)
)
)
;
saveAsPDF
.
setEnabled
(
allowPDF
)
;
print
.
setEnabled
(
allowPDF
)
;
print
.
setVisible
(
Versions
.
feature19Plus
)
;
findInPage
.
setEnabled
(
!
isAboutHome
(
tab
)
)
;
charEncoding
.
setVisible
(
GeckoPreferences
.
getCharEncodingState
(
)
)
;
if
(
getProfile
(
)
.
inGuestMode
(
)
)
{
exitGuestMode
.
setVisible
(
true
)
;
}
else
{
enterGuestMode
.
setVisible
(
true
)
;
}
if
(
!
Restrictions
.
isAllowed
(
this
Restrictable
.
GUEST_BROWSING
)
)
{
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
new_guest_session
false
)
;
}
if
(
!
Restrictions
.
isAllowed
(
this
Restrictable
.
INSTALL_EXTENSION
)
)
{
MenuUtils
.
safeSetVisible
(
aMenu
R
.
id
.
addons
false
)
;
}
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
getContext
(
)
)
;
bookmarksList
.
setVisible
(
prefs
.
getBoolean
(
HomeConfig
.
PREF_KEY_BOOKMARKS_PANEL_ENABLED
true
)
)
;
historyList
.
setVisible
(
prefs
.
getBoolean
(
HomeConfig
.
PREF_KEY_HISTORY_PANEL_ENABLED
true
)
)
;
return
true
;
}
private
int
resolveBookmarkIconID
(
final
boolean
isBookmark
)
{
if
(
isBookmark
)
{
return
R
.
drawable
.
star_blue
;
}
else
{
return
R
.
drawable
.
ic_menu_bookmark_add
;
}
}
private
int
resolveBookmarkTitleID
(
final
boolean
isBookmark
)
{
return
(
isBookmark
?
R
.
string
.
bookmark_remove
:
R
.
string
.
bookmark
)
;
}
Override
public
boolean
onOptionsItemSelected
(
MenuItem
item
)
{
Tab
tab
=
null
;
Intent
intent
=
null
;
final
int
itemId
=
item
.
getItemId
(
)
;
String
extras
=
getResources
(
)
.
getResourceEntryName
(
itemId
)
;
if
(
TextUtils
.
equals
(
extras
"
new_private_tab
"
)
)
{
extras
=
"
new_tab
"
;
}
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
MENU
extras
)
;
mBrowserToolbar
.
cancelEdit
(
)
;
if
(
itemId
=
=
R
.
id
.
bookmark
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
final
String
extra
;
if
(
AboutPages
.
isAboutReader
(
tab
.
getURL
(
)
)
)
{
extra
=
"
bookmark_reader
"
;
}
else
{
extra
=
"
bookmark
"
;
}
if
(
item
.
isChecked
(
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
UNSAVE
TelemetryContract
.
Method
.
MENU
extra
)
;
tab
.
removeBookmark
(
)
;
item
.
setTitle
(
resolveBookmarkTitleID
(
false
)
)
;
if
(
Versions
.
feature11Plus
)
{
item
.
setIcon
(
resolveBookmarkIconID
(
false
)
)
;
}
}
else
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SAVE
TelemetryContract
.
Method
.
MENU
extra
)
;
tab
.
addBookmark
(
)
;
item
.
setTitle
(
resolveBookmarkTitleID
(
true
)
)
;
if
(
Versions
.
feature11Plus
)
{
item
.
setIcon
(
resolveBookmarkIconID
(
true
)
)
;
}
}
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
share
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
String
url
=
tab
.
getURL
(
)
;
if
(
url
!
=
null
)
{
if
(
AboutPages
.
isAboutReader
(
url
)
)
{
url
=
ReaderModeUtils
.
getUrlFromAboutReader
(
url
)
;
}
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHARE
TelemetryContract
.
Method
.
LIST
"
menu
"
)
;
IntentHelper
.
openUriExternal
(
url
"
text
/
plain
"
"
"
"
"
Intent
.
ACTION_SEND
tab
.
getDisplayTitle
(
)
false
)
;
}
}
return
true
;
}
if
(
itemId
=
=
R
.
id
.
reload
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
tab
.
doReload
(
false
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
back
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
tab
.
doBack
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
forward
)
{
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
tab
.
doForward
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
bookmarks_list
)
{
final
String
url
=
AboutPages
.
getURLForBuiltinPanelType
(
PanelType
.
BOOKMARKS
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
url
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
history_list
)
{
final
String
url
=
AboutPages
.
getURLForBuiltinPanelType
(
PanelType
.
COMBINED_HISTORY
)
;
Tabs
.
getInstance
(
)
.
loadUrl
(
url
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
save_as_pdf
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SAVE
TelemetryContract
.
Method
.
MENU
"
pdf
"
)
;
GeckoAppShell
.
notifyObservers
(
"
SaveAs
:
PDF
"
null
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
print
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SAVE
TelemetryContract
.
Method
.
MENU
"
print
"
)
;
PrintHelper
.
printPDF
(
this
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
settings
)
{
intent
=
new
Intent
(
this
GeckoPreferences
.
class
)
;
startActivityForResult
(
intent
ACTIVITY_REQUEST_PREFERENCES
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
help
)
{
final
String
VERSION
=
AppConstants
.
MOZ_APP_VERSION
;
final
String
OS
=
AppConstants
.
OS_TARGET
;
final
String
LOCALE
=
Locales
.
getLanguageTag
(
Locale
.
getDefault
(
)
)
;
final
String
URL
=
getResources
(
)
.
getString
(
R
.
string
.
help_link
VERSION
OS
LOCALE
)
;
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
URL
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
addons
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
ADDONS
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
logins
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
LOGINS
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
downloads
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
DOWNLOADS
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
char_encoding
)
{
GeckoAppShell
.
notifyObservers
(
"
CharEncoding
:
Get
"
null
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
find_in_page
)
{
mFindInPageBar
.
show
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
desktop_mode
)
{
Tab
selectedTab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
selectedTab
=
=
null
)
return
true
;
JSONObject
args
=
new
JSONObject
(
)
;
try
{
args
.
put
(
"
desktopMode
"
!
item
.
isChecked
(
)
)
;
args
.
put
(
"
tabId
"
selectedTab
.
getId
(
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
error
building
json
arguments
"
e
)
;
}
GeckoAppShell
.
notifyObservers
(
"
DesktopMode
:
Change
"
args
.
toString
(
)
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
new_tab
)
{
addTab
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
new_private_tab
)
{
addPrivateTab
(
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
new_guest_session
)
{
showGuestModeDialog
(
GuestModeDialog
.
ENTERING
)
;
return
true
;
}
if
(
itemId
=
=
R
.
id
.
exit_guest_session
)
{
showGuestModeDialog
(
GuestModeDialog
.
LEAVING
)
;
return
true
;
}
if
(
onContextItemSelected
(
item
)
)
{
return
true
;
}
return
super
.
onOptionsItemSelected
(
item
)
;
}
Override
public
boolean
onMenuItemLongClick
(
MenuItem
item
)
{
if
(
item
.
getItemId
(
)
=
=
R
.
id
.
reload
)
{
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
)
{
tab
.
doReload
(
true
)
;
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
MENU
"
reload_force
"
)
;
}
return
true
;
}
return
super
.
onMenuItemLongClick
(
item
)
;
}
public
void
showGuestModeDialog
(
final
GuestModeDialog
type
)
{
if
(
(
type
=
=
GuestModeDialog
.
ENTERING
)
=
=
getProfile
(
)
.
inGuestMode
(
)
)
{
return
;
}
final
Prompt
ps
=
new
Prompt
(
this
new
Prompt
.
PromptCallback
(
)
{
Override
public
void
onPromptFinished
(
String
result
)
{
try
{
int
itemId
=
new
JSONObject
(
result
)
.
getInt
(
"
button
"
)
;
if
(
itemId
=
=
0
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
if
(
type
=
=
GuestModeDialog
.
ENTERING
)
{
GuestSession
.
enter
(
context
)
;
}
else
{
GuestSession
.
leave
(
context
)
;
GuestSession
.
hideNotification
(
context
)
;
}
doRestart
(
)
;
}
}
catch
(
JSONException
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
reading
guest
mode
prompt
result
"
ex
)
;
}
}
}
)
;
Resources
res
=
getResources
(
)
;
ps
.
setButtons
(
new
String
[
]
{
res
.
getString
(
R
.
string
.
guest_session_dialog_continue
)
res
.
getString
(
R
.
string
.
guest_session_dialog_cancel
)
}
)
;
int
titleString
=
0
;
int
msgString
=
0
;
if
(
type
=
=
GuestModeDialog
.
ENTERING
)
{
titleString
=
R
.
string
.
new_guest_session_title
;
msgString
=
R
.
string
.
new_guest_session_text
;
}
else
{
titleString
=
R
.
string
.
exit_guest_session_title
;
msgString
=
R
.
string
.
exit_guest_session_text
;
}
ps
.
show
(
res
.
getString
(
titleString
)
res
.
getString
(
msgString
)
null
ListView
.
CHOICE_MODE_NONE
)
;
}
Override
public
boolean
onKeyLongPress
(
int
keyCode
KeyEvent
event
)
{
if
(
keyCode
=
=
KeyEvent
.
KEYCODE_BACK
)
{
TabHistoryFragment
frag
=
(
TabHistoryFragment
)
getSupportFragmentManager
(
)
.
findFragmentByTag
(
TAB_HISTORY_FRAGMENT_TAG
)
;
if
(
frag
!
=
null
)
{
return
false
;
}
Tab
tab
=
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
;
if
(
tab
!
=
null
&
&
!
tab
.
isEditing
(
)
)
{
return
tabHistoryController
.
showTabHistory
(
tab
TabHistoryController
.
HistoryAction
.
ALL
)
;
}
}
return
super
.
onKeyLongPress
(
keyCode
event
)
;
}
Override
protected
void
onNewIntent
(
Intent
intent
)
{
String
action
=
intent
.
getAction
(
)
;
final
boolean
isViewAction
=
Intent
.
ACTION_VIEW
.
equals
(
action
)
;
final
boolean
isBookmarkAction
=
GeckoApp
.
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
;
final
boolean
isTabQueueAction
=
TabQueueHelper
.
LOAD_URLS_ACTION
.
equals
(
action
)
;
final
boolean
isViewMultipleAction
=
ACTION_VIEW_MULTIPLE
.
equals
(
action
)
;
if
(
mInitialized
&
&
(
isViewAction
|
|
isBookmarkAction
)
)
{
mBrowserToolbar
.
cancelEdit
(
)
;
hideFirstrunPager
(
TelemetryContract
.
Method
.
NONE
)
;
if
(
isBookmarkAction
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LOAD_URL
TelemetryContract
.
Method
.
HOMESCREEN
)
;
}
}
showTabQueuePromptIfApplicable
(
intent
)
;
super
.
onNewIntent
(
intent
)
;
if
(
AppConstants
.
MOZ_ANDROID_BEAM
&
&
NfcAdapter
.
ACTION_NDEF_DISCOVERED
.
equals
(
action
)
)
{
String
uri
=
intent
.
getDataString
(
)
;
mLayerView
.
loadUri
(
uri
GeckoView
.
LOAD_NEW_TAB
)
;
}
if
(
GuestSession
.
NOTIFICATION_INTENT
.
equals
(
action
)
)
{
GuestSession
.
handleIntent
(
this
intent
)
;
}
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
mInitialized
&
&
isTabQueueAction
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
ACTION
TelemetryContract
.
Method
.
NOTIFICATION
"
tabqueue
"
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
openQueuedTabs
(
)
;
}
}
)
;
}
if
(
isViewMultipleAction
)
{
openMultipleTabsFromIntent
(
intent
)
;
}
for
(
final
BrowserAppDelegate
delegate
:
delegates
)
{
delegate
.
onNewIntent
(
this
intent
)
;
}
if
(
!
mInitialized
|
|
!
Intent
.
ACTION_MAIN
.
equals
(
action
)
)
{
return
;
}
final
String
keyName
=
getPackageName
(
)
+
"
.
feedback_launch_count
"
;
final
StrictMode
.
ThreadPolicy
savedPolicy
=
StrictMode
.
allowThreadDiskReads
(
)
;
try
{
SharedPreferences
settings
=
getPreferences
(
Activity
.
MODE_PRIVATE
)
;
int
launchCount
=
settings
.
getInt
(
keyName
0
)
;
if
(
launchCount
<
FEEDBACK_LAUNCH_COUNT
)
{
launchCount
+
+
;
settings
.
edit
(
)
.
putInt
(
keyName
launchCount
)
.
apply
(
)
;
if
(
launchCount
=
=
FEEDBACK_LAUNCH_COUNT
)
{
GeckoAppShell
.
notifyObservers
(
"
Feedback
:
Show
"
null
)
;
}
}
}
finally
{
StrictMode
.
setThreadPolicy
(
savedPolicy
)
;
}
}
public
void
openUrls
(
List
<
String
>
urls
)
{
try
{
JSONArray
array
=
new
JSONArray
(
)
;
for
(
String
url
:
urls
)
{
array
.
put
(
url
)
;
}
JSONObject
object
=
new
JSONObject
(
)
;
object
.
put
(
"
urls
"
array
)
;
GeckoAppShell
.
notifyObservers
(
"
Tabs
:
OpenMultiple
"
object
.
toString
(
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
create
JSON
for
opening
multiple
URLs
"
)
;
}
}
private
void
showTabQueuePromptIfApplicable
(
final
Intent
intent
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
TabQueueHelper
.
TAB_QUEUE_ENABLED
&
&
mInitialized
&
&
Intent
.
ACTION_VIEW
.
equals
(
intent
.
getAction
(
)
)
&
&
!
intent
.
getBooleanExtra
(
BrowserContract
.
SKIP_TAB_QUEUE_FLAG
false
)
&
&
TabQueueHelper
.
shouldShowTabQueuePrompt
(
BrowserApp
.
this
)
)
{
Intent
promptIntent
=
new
Intent
(
BrowserApp
.
this
TabQueuePrompt
.
class
)
;
startActivityForResult
(
promptIntent
ACTIVITY_REQUEST_TAB_QUEUE
)
;
}
}
}
)
;
}
Override
protected
NotificationClient
makeNotificationClient
(
)
{
return
new
ServiceNotificationClient
(
getApplicationContext
(
)
)
;
}
private
void
resetFeedbackLaunchCount
(
)
{
SharedPreferences
settings
=
getPreferences
(
Activity
.
MODE_PRIVATE
)
;
settings
.
edit
(
)
.
putInt
(
getPackageName
(
)
+
"
.
feedback_launch_count
"
0
)
.
apply
(
)
;
}
Override
public
void
onUrlOpen
(
String
url
EnumSet
<
OnUrlOpenListener
.
Flags
>
flags
)
{
if
(
flags
.
contains
(
OnUrlOpenListener
.
Flags
.
OPEN_WITH_INTENT
)
)
{
Intent
intent
=
new
Intent
(
Intent
.
ACTION_VIEW
)
;
intent
.
setData
(
Uri
.
parse
(
url
)
)
;
startActivity
(
intent
)
;
}
else
{
final
String
pageURL
;
if
(
!
flags
.
contains
(
OnUrlOpenListener
.
Flags
.
NO_READER_VIEW
)
)
{
pageURL
=
SavedReaderViewHelper
.
getReaderURLIfCached
(
getContext
(
)
url
)
;
}
else
{
pageURL
=
url
;
}
if
(
!
maybeSwitchToTab
(
pageURL
flags
)
)
{
openUrlAndStopEditing
(
pageURL
)
;
clearSelectedTabApplicationId
(
)
;
}
}
}
Override
public
void
onUrlOpenInBackground
(
final
String
url
EnumSet
<
OnUrlOpenInBackgroundListener
.
Flags
>
flags
)
{
if
(
url
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
url
must
not
be
null
"
)
;
}
if
(
flags
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
flags
must
not
be
null
"
)
;
}
final
String
pageURL
=
SavedReaderViewHelper
.
getReaderURLIfCached
(
getContext
(
)
url
)
;
final
boolean
isPrivate
=
flags
.
contains
(
OnUrlOpenInBackgroundListener
.
Flags
.
PRIVATE
)
;
int
loadFlags
=
Tabs
.
LOADURL_NEW_TAB
|
Tabs
.
LOADURL_BACKGROUND
;
if
(
isPrivate
)
{
loadFlags
|
=
Tabs
.
LOADURL_PRIVATE
;
}
final
Tab
newTab
=
Tabs
.
getInstance
(
)
.
loadUrl
(
pageURL
loadFlags
)
;
final
int
newTabId
=
newTab
.
getId
(
)
;
final
SnackbarBuilder
.
SnackbarCallback
callback
=
new
SnackbarBuilder
.
SnackbarCallback
(
)
{
Override
public
void
onClick
(
View
v
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
SHOW
TelemetryContract
.
Method
.
TOAST
"
switchtab
"
)
;
maybeSwitchToTab
(
newTabId
)
;
}
}
;
final
String
message
=
isPrivate
?
getResources
(
)
.
getString
(
R
.
string
.
new_private_tab_opened
)
:
getResources
(
)
.
getString
(
R
.
string
.
new_tab_opened
)
;
final
String
buttonMessage
=
getResources
(
)
.
getString
(
R
.
string
.
switch_button_message
)
;
SnackbarBuilder
.
builder
(
this
)
.
message
(
message
)
.
duration
(
Snackbar
.
LENGTH_LONG
)
.
action
(
buttonMessage
)
.
callback
(
callback
)
.
buildAndShow
(
)
;
}
Override
public
void
onSearch
(
SearchEngine
engine
final
String
text
final
TelemetryContract
.
Method
method
)
{
if
(
!
Tabs
.
getInstance
(
)
.
getSelectedTab
(
)
.
isPrivate
(
)
)
{
storeSearchQuery
(
text
)
;
}
final
String
identifierToRecord
=
(
engine
.
identifier
!
=
null
)
?
engine
.
identifier
:
"
other
"
;
recordSearch
(
GeckoSharedPrefs
.
forProfile
(
this
)
identifierToRecord
method
)
;
openUrlAndStopEditing
(
text
engine
.
name
)
;
}
Override
public
void
onEditSuggestion
(
String
suggestion
)
{
mBrowserToolbar
.
onEditSuggestion
(
suggestion
)
;
}
Override
public
int
getLayout
(
)
{
return
R
.
layout
.
gecko_app
;
}
public
SearchEngineManager
getSearchEngineManager
(
)
{
return
mSearchEngineManager
;
}
RobocopTarget
public
ReadingListHelper
getReadingListHelper
(
)
{
return
mReadingListHelper
;
}
protected
boolean
handleUpdaterLaunch
(
)
{
if
(
AppConstants
.
RELEASE_BUILD
)
{
Intent
intent
=
new
Intent
(
Intent
.
ACTION_VIEW
)
;
intent
.
setData
(
Uri
.
parse
(
"
market
:
/
/
details
?
id
=
"
+
getPackageName
(
)
)
)
;
startActivity
(
intent
)
;
return
true
;
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
Tabs
.
getInstance
(
)
.
loadUrlInTab
(
AboutPages
.
UPDATER
)
;
return
true
;
}
Log
.
w
(
LOGTAG
"
No
candidate
updater
found
;
ignoring
launch
request
.
"
)
;
return
false
;
}
Override
public
void
startActionModeCompat
(
final
ActionModeCompat
.
Callback
callback
)
{
if
(
mActionMode
=
=
null
)
{
mActionBarFlipper
.
showNext
(
)
;
DynamicToolbarAnimator
toolbar
=
mLayerView
.
getDynamicToolbarAnimator
(
)
;
if
(
mDynamicToolbar
.
isEnabled
(
)
&
&
toolbar
.
getToolbarTranslation
(
)
!
=
0
)
{
mDynamicToolbar
.
setTemporarilyVisible
(
true
VisibilityTransition
.
ANIMATE
)
;
}
mDynamicToolbar
.
setPinned
(
true
PinReason
.
ACTION_MODE
)
;
}
else
{
mActionMode
.
finish
(
)
;
}
mActionMode
=
new
ActionModeCompat
(
BrowserApp
.
this
callback
mActionBar
)
;
if
(
callback
.
onCreateActionMode
(
mActionMode
mActionMode
.
getMenu
(
)
)
)
{
mActionMode
.
invalidate
(
)
;
}
}
Override
public
void
endActionModeCompat
(
)
{
if
(
mActionMode
=
=
null
)
{
return
;
}
mActionMode
.
finish
(
)
;
mActionMode
=
null
;
mDynamicToolbar
.
setPinned
(
false
PinReason
.
ACTION_MODE
)
;
mActionBarFlipper
.
showPrevious
(
)
;
mDynamicToolbar
.
setTemporarilyVisible
(
false
VisibilityTransition
.
IMMEDIATE
)
;
}
public
static
interface
TabStripInterface
{
public
void
refresh
(
)
;
void
setOnTabChangedListener
(
OnTabAddedOrRemovedListener
listener
)
;
interface
OnTabAddedOrRemovedListener
{
void
onTabChanged
(
)
;
}
}
Override
protected
void
recordStartupActionTelemetry
(
final
String
passedURL
final
String
action
)
{
final
TelemetryContract
.
Method
method
;
if
(
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
method
=
TelemetryContract
.
Method
.
HOMESCREEN
;
}
else
if
(
passedURL
=
=
null
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
TelemetryContract
.
Method
.
HOMESCREEN
"
launcher
"
)
;
method
=
TelemetryContract
.
Method
.
HOMESCREEN
;
}
else
{
method
=
TelemetryContract
.
Method
.
INTENT
;
}
if
(
GeckoProfile
.
get
(
this
)
.
inGuestMode
(
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
method
"
guest
"
)
;
}
else
if
(
Restrictions
.
isRestrictedProfile
(
this
)
)
{
Telemetry
.
sendUIEvent
(
TelemetryContract
.
Event
.
LAUNCH
method
"
restricted
"
)
;
}
}
}
