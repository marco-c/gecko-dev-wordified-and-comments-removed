package
org
.
mozilla
.
gecko
.
dlc
;
import
android
.
content
.
Context
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
background
.
nativecode
.
NativeCrypto
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContent
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContentCatalog
;
import
org
.
mozilla
.
gecko
.
sync
.
Utils
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
public
abstract
class
BaseAction
{
private
static
final
String
LOGTAG
=
"
GeckoDLCBaseAction
"
;
static
class
RecoverableDownloadContentException
extends
Exception
{
private
static
final
long
serialVersionUID
=
-
2246772819507370734L
;
public
RecoverableDownloadContentException
(
String
message
)
{
super
(
message
)
;
}
public
RecoverableDownloadContentException
(
Throwable
cause
)
{
super
(
cause
)
;
}
}
static
class
UnrecoverableDownloadContentException
extends
Exception
{
private
static
final
long
serialVersionUID
=
8956080754787367105L
;
public
UnrecoverableDownloadContentException
(
String
message
)
{
super
(
message
)
;
}
public
UnrecoverableDownloadContentException
(
Throwable
cause
)
{
super
(
cause
)
;
}
}
public
abstract
void
perform
(
Context
context
DownloadContentCatalog
catalog
)
;
protected
File
getDestinationFile
(
Context
context
DownloadContent
content
)
throws
UnrecoverableDownloadContentException
{
if
(
content
.
isFont
(
)
)
{
return
new
File
(
new
File
(
context
.
getApplicationInfo
(
)
.
dataDir
"
fonts
"
)
content
.
getFilename
(
)
)
;
}
throw
new
UnrecoverableDownloadContentException
(
"
Can
'
t
determine
destination
for
kind
:
"
+
content
.
getKind
(
)
)
;
}
protected
boolean
verify
(
File
file
String
expectedChecksum
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
try
{
inputStream
=
new
BufferedInputStream
(
new
FileInputStream
(
file
)
)
;
byte
[
]
ctx
=
NativeCrypto
.
sha256init
(
)
;
if
(
ctx
=
=
null
)
{
throw
new
RecoverableDownloadContentException
(
"
Could
not
create
SHA
-
256
context
"
)
;
}
byte
[
]
buffer
=
new
byte
[
4096
]
;
int
read
;
while
(
(
read
=
inputStream
.
read
(
buffer
)
)
!
=
-
1
)
{
NativeCrypto
.
sha256update
(
ctx
buffer
read
)
;
}
String
actualChecksum
=
Utils
.
byte2Hex
(
NativeCrypto
.
sha256finalize
(
ctx
)
)
;
if
(
!
actualChecksum
.
equalsIgnoreCase
(
expectedChecksum
)
)
{
Log
.
w
(
LOGTAG
"
Checksums
do
not
match
.
Expected
=
"
+
expectedChecksum
+
"
Actual
=
"
+
actualChecksum
)
;
return
false
;
}
return
true
;
}
catch
(
IOException
e
)
{
throw
new
RecoverableDownloadContentException
(
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
}
}
}
