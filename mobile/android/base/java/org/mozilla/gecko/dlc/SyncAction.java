package
org
.
mozilla
.
gecko
.
dlc
;
import
android
.
content
.
Context
;
import
android
.
net
.
Uri
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
switchboard
.
SwitchBoard
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContent
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContentBuilder
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContentCatalog
;
import
org
.
mozilla
.
gecko
.
Experiments
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
net
.
HttpURLConnection
;
public
class
SyncAction
extends
BaseAction
{
private
static
final
String
LOGTAG
=
"
DLCSyncAction
"
;
private
static
final
String
KINTO_KEY_ID
=
"
id
"
;
private
static
final
String
KINTO_KEY_DELETED
=
"
deleted
"
;
private
static
final
String
KINTO_KEY_DATA
=
"
data
"
;
private
static
final
String
KINTO_KEY_ATTACHMENT
=
"
attachment
"
;
private
static
final
String
KINTO_KEY_ORIGINAL
=
"
original
"
;
private
static
final
String
KINTO_PARAMETER_SINCE
=
"
_since
"
;
private
static
final
String
KINTO_PARAMETER_FIELDS
=
"
_fields
"
;
private
static
final
String
KINTO_PARAMETER_SORT
=
"
_sort
"
;
private
static
final
String
CATALOG_ENDPOINT
=
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
/
buckets
/
fennec
/
collections
/
catalog
/
records
"
;
Override
public
void
perform
(
Context
context
DownloadContentCatalog
catalog
)
{
Log
.
d
(
LOGTAG
"
Synchronizing
catalog
.
"
)
;
if
(
!
isSyncEnabledForClient
(
context
)
)
{
Log
.
d
(
LOGTAG
"
Sync
is
not
enabled
for
client
.
Skipping
.
"
)
;
return
;
}
boolean
cleanupRequired
=
false
;
boolean
studyRequired
=
false
;
try
{
long
lastModified
=
catalog
.
getLastModified
(
)
;
JSONArray
rawCatalog
=
fetchRawCatalog
(
lastModified
)
;
Log
.
d
(
LOGTAG
"
Server
returned
"
+
rawCatalog
.
length
(
)
+
"
records
(
since
"
+
lastModified
+
"
)
"
)
;
for
(
int
i
=
0
;
i
<
rawCatalog
.
length
(
)
;
i
+
+
)
{
JSONObject
object
=
rawCatalog
.
getJSONObject
(
i
)
;
String
id
=
object
.
getString
(
KINTO_KEY_ID
)
;
final
boolean
isDeleted
=
object
.
optBoolean
(
KINTO_KEY_DELETED
false
)
;
if
(
!
isDeleted
)
{
JSONObject
attachment
=
object
.
getJSONObject
(
KINTO_KEY_ATTACHMENT
)
;
if
(
attachment
.
isNull
(
KINTO_KEY_ORIGINAL
)
)
throw
new
JSONException
(
String
.
format
(
"
Old
Attachment
Format
"
)
)
;
}
DownloadContent
existingContent
=
catalog
.
getContentById
(
id
)
;
if
(
isDeleted
)
{
cleanupRequired
|
=
deleteContent
(
catalog
id
)
;
}
else
if
(
existingContent
!
=
null
)
{
studyRequired
|
=
updateContent
(
catalog
object
existingContent
)
;
}
else
{
studyRequired
|
=
createContent
(
catalog
object
)
;
}
}
DownloadContentTelemetry
.
eventSyncSuccess
(
rawCatalog
.
length
(
)
>
0
cleanupRequired
|
|
studyRequired
)
;
}
catch
(
UnrecoverableDownloadContentException
e
)
{
Log
.
e
(
LOGTAG
"
UnrecoverableDownloadContentException
"
e
)
;
DownloadContentTelemetry
.
eventSyncFailure
(
DownloadContentTelemetry
.
ERROR_UNRECOVERABLE
)
;
}
catch
(
RecoverableDownloadContentException
e
)
{
Log
.
e
(
LOGTAG
"
RecoverableDownloadContentException
"
)
;
DownloadContentTelemetry
.
eventSyncFailure
(
e
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
JSONException
"
e
)
;
}
if
(
studyRequired
)
{
startStudyAction
(
context
)
;
}
if
(
cleanupRequired
)
{
startCleanupAction
(
context
)
;
}
Log
.
v
(
LOGTAG
"
Done
"
)
;
}
protected
void
startStudyAction
(
Context
context
)
{
DlcStudyService
.
enqueueServiceWork
(
context
)
;
}
protected
void
startCleanupAction
(
Context
context
)
{
DlcCleanupService
.
enqueueServiceWork
(
context
)
;
}
protected
JSONArray
fetchRawCatalog
(
long
lastModified
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
HttpURLConnection
connection
=
null
;
try
{
Uri
.
Builder
builder
=
Uri
.
parse
(
CATALOG_ENDPOINT
)
.
buildUpon
(
)
;
if
(
lastModified
>
0
)
{
builder
.
appendQueryParameter
(
KINTO_PARAMETER_SINCE
String
.
valueOf
(
lastModified
)
)
;
}
builder
.
appendQueryParameter
(
KINTO_PARAMETER_FIELDS
"
type
kind
attachment
.
location
attachment
.
hash
attachment
.
original
.
size
attachment
.
original
.
filename
attachment
.
original
.
hash
match
"
)
;
builder
.
appendQueryParameter
(
KINTO_PARAMETER_SORT
"
last_modified
"
)
;
connection
=
buildHttpURLConnection
(
builder
.
build
(
)
.
toString
(
)
)
;
final
int
responseCode
=
connection
.
getResponseCode
(
)
;
if
(
responseCode
!
=
HttpURLConnection
.
HTTP_OK
)
{
if
(
responseCode
>
=
500
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
SERVER
"
Server
error
(
"
+
responseCode
+
"
)
"
)
;
}
else
if
(
responseCode
=
=
410
)
{
throw
new
UnrecoverableDownloadContentException
(
"
Server
is
gone
(
410
)
"
)
;
}
else
if
(
responseCode
>
=
400
)
{
logErrorResponse
(
connection
)
;
throw
new
UnrecoverableDownloadContentException
(
"
(
Unrecoverable
)
Catalog
sync
failed
.
Status
code
:
"
+
responseCode
)
;
}
else
if
(
responseCode
<
200
)
{
logErrorResponse
(
connection
)
;
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
SERVER
"
Response
code
:
"
+
responseCode
)
;
}
else
{
throw
new
UnrecoverableDownloadContentException
(
"
(
Unrecoverable
)
Download
failed
.
Response
code
:
"
+
responseCode
)
;
}
}
return
fetchJSONResponse
(
connection
)
.
getJSONArray
(
KINTO_KEY_DATA
)
;
}
catch
(
JSONException
|
IOException
e
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
NETWORK
e
)
;
}
finally
{
if
(
connection
!
=
null
)
{
connection
.
disconnect
(
)
;
}
}
}
private
JSONObject
fetchJSONResponse
(
HttpURLConnection
connection
)
throws
IOException
JSONException
{
InputStream
inputStream
=
null
;
try
{
inputStream
=
new
BufferedInputStream
(
connection
.
getInputStream
(
)
)
;
ByteArrayOutputStream
outputStream
=
new
ByteArrayOutputStream
(
)
;
IOUtils
.
copy
(
inputStream
outputStream
)
;
return
new
JSONObject
(
outputStream
.
toString
(
"
UTF
-
8
"
)
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
}
}
protected
boolean
updateContent
(
DownloadContentCatalog
catalog
JSONObject
object
DownloadContent
existingContent
)
throws
JSONException
{
DownloadContent
content
=
existingContent
.
buildUpon
(
)
.
updateFromKinto
(
object
)
.
build
(
)
;
if
(
existingContent
.
getLastModified
(
)
>
=
content
.
getLastModified
(
)
)
{
Log
.
d
(
LOGTAG
"
Item
has
not
changed
:
"
+
content
)
;
return
false
;
}
catalog
.
update
(
content
)
;
return
true
;
}
protected
boolean
createContent
(
DownloadContentCatalog
catalog
JSONObject
object
)
throws
JSONException
{
DownloadContent
content
=
new
DownloadContentBuilder
(
)
.
updateFromKinto
(
object
)
.
build
(
)
;
catalog
.
add
(
content
)
;
return
true
;
}
protected
boolean
deleteContent
(
DownloadContentCatalog
catalog
String
id
)
{
DownloadContent
content
=
catalog
.
getContentById
(
id
)
;
if
(
content
=
=
null
)
{
return
false
;
}
catalog
.
markAsDeleted
(
content
)
;
return
true
;
}
protected
boolean
isSyncEnabledForClient
(
Context
context
)
{
return
SwitchBoard
.
isInExperiment
(
context
Experiments
.
DOWNLOAD_CONTENT_CATALOG_SYNC
)
;
}
private
void
logErrorResponse
(
HttpURLConnection
connection
)
{
try
{
JSONObject
error
=
fetchJSONResponse
(
connection
)
;
Log
.
w
(
LOGTAG
"
Server
returned
error
response
:
"
)
;
Log
.
w
(
LOGTAG
"
-
Code
:
"
+
error
.
getInt
(
"
code
"
)
)
;
Log
.
w
(
LOGTAG
"
-
Errno
:
"
+
error
.
getInt
(
"
errno
"
)
)
;
Log
.
w
(
LOGTAG
"
-
Error
:
"
+
error
.
optString
(
"
error
"
"
-
"
)
)
;
Log
.
w
(
LOGTAG
"
-
Message
:
"
+
error
.
optString
(
"
message
"
"
-
"
)
)
;
Log
.
w
(
LOGTAG
"
-
Info
:
"
+
error
.
optString
(
"
info
"
"
-
"
)
)
;
}
catch
(
JSONException
|
IOException
e
)
{
Log
.
w
(
LOGTAG
"
Could
not
fetch
error
response
"
e
)
;
}
}
}
