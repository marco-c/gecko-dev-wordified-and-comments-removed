package
org
.
mozilla
.
gecko
.
dlc
;
import
android
.
annotation
.
SuppressLint
;
import
android
.
content
.
Context
;
import
android
.
net
.
ConnectivityManager
;
import
android
.
net
.
NetworkInfo
;
import
android
.
support
.
v4
.
net
.
ConnectivityManagerCompat
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContent
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContentCatalog
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
util
.
zip
.
GZIPInputStream
;
public
class
DownloadAction
extends
BaseAction
{
private
static
final
String
LOGTAG
=
"
DLCDownloadAction
"
;
private
static
final
String
CACHE_DIRECTORY
=
"
downloadContent
"
;
private
static
final
String
CDN_BASE_URL
=
"
https
:
/
/
fennec
-
catalog
.
cdn
.
mozilla
.
net
/
"
;
public
interface
Callback
{
void
onContentDownloaded
(
DownloadContent
content
)
;
}
private
Callback
callback
;
public
DownloadAction
(
Callback
callback
)
{
this
.
callback
=
callback
;
}
public
void
perform
(
Context
context
DownloadContentCatalog
catalog
)
{
Log
.
d
(
LOGTAG
"
Downloading
content
.
.
"
)
;
if
(
!
catalog
.
hasScheduledDownloads
(
)
)
{
Log
.
d
(
LOGTAG
"
No
scheduled
downloads
.
Nothing
to
do
.
"
)
;
return
;
}
for
(
DownloadContent
content
:
catalog
.
getScheduledDownloads
(
)
)
{
Log
.
d
(
LOGTAG
"
Downloading
:
"
+
content
)
;
File
temporaryFile
=
null
;
try
{
if
(
!
isConnectedToNetwork
(
context
)
)
{
Log
.
d
(
LOGTAG
"
No
connected
network
available
.
Postponing
download
.
"
)
;
DownloadContentTelemetry
.
eventDownloadFailure
(
content
DownloadContentTelemetry
.
ERROR_NO_NETWORK
)
;
return
;
}
if
(
isActiveNetworkMetered
(
context
)
)
{
Log
.
d
(
LOGTAG
"
Network
is
metered
.
Postponing
download
.
"
)
;
DownloadContentTelemetry
.
eventDownloadFailure
(
content
DownloadContentTelemetry
.
ERROR_NETWORK_METERED
)
;
return
;
}
File
destinationFile
=
getDestinationFile
(
context
content
)
;
if
(
destinationFile
.
exists
(
)
&
&
verify
(
destinationFile
content
.
getChecksum
(
)
)
)
{
Log
.
d
(
LOGTAG
"
Content
already
exists
and
is
up
-
to
-
date
.
"
)
;
catalog
.
markAsDownloaded
(
content
)
;
DownloadContentTelemetry
.
eventDownloadSuccess
(
content
)
;
continue
;
}
temporaryFile
=
createTemporaryFile
(
context
content
)
;
if
(
!
hasEnoughDiskSpace
(
content
destinationFile
temporaryFile
)
)
{
Log
.
d
(
LOGTAG
"
Not
enough
disk
space
to
save
content
.
Skipping
download
.
"
)
;
DownloadContentTelemetry
.
eventDownloadFailure
(
content
DownloadContentTelemetry
.
ERROR_DISK_SPACE
)
;
continue
;
}
final
String
url
=
createDownloadURL
(
content
)
;
if
(
!
temporaryFile
.
exists
(
)
|
|
temporaryFile
.
length
(
)
<
content
.
getSize
(
)
)
{
download
(
url
temporaryFile
)
;
}
if
(
!
verify
(
temporaryFile
content
.
getDownloadChecksum
(
)
)
)
{
Log
.
w
(
LOGTAG
"
Wrong
checksum
after
download
content
=
"
+
content
.
getId
(
)
)
;
temporaryFile
.
delete
(
)
;
DownloadContentTelemetry
.
eventDownloadFailure
(
content
DownloadContentTelemetry
.
ERROR_CHECKSUM
)
;
continue
;
}
if
(
!
content
.
isAssetArchive
(
)
)
{
Log
.
e
(
LOGTAG
"
Downloaded
content
is
not
of
type
'
asset
-
archive
'
:
"
+
(
String
)
content
.
getType
(
)
)
;
temporaryFile
.
delete
(
)
;
DownloadContentTelemetry
.
eventDownloadFailure
(
content
DownloadContentTelemetry
.
ERROR_LOGIC
)
;
continue
;
}
extract
(
temporaryFile
destinationFile
content
.
getChecksum
(
)
)
;
catalog
.
markAsDownloaded
(
content
)
;
DownloadContentTelemetry
.
eventDownloadSuccess
(
content
)
;
Log
.
d
(
LOGTAG
"
Successfully
downloaded
:
"
+
content
)
;
if
(
callback
!
=
null
)
{
callback
.
onContentDownloaded
(
content
)
;
}
if
(
temporaryFile
!
=
null
&
&
temporaryFile
.
exists
(
)
)
{
temporaryFile
.
delete
(
)
;
}
}
catch
(
RecoverableDownloadContentException
e
)
{
Log
.
w
(
LOGTAG
"
Downloading
content
failed
(
Recoverable
)
:
"
+
content
e
)
;
if
(
e
.
shouldBeCountedAsFailure
(
)
)
{
catalog
.
rememberFailure
(
content
e
.
getErrorType
(
)
)
;
}
DownloadContentTelemetry
.
eventDownloadFailure
(
content
e
)
;
}
catch
(
UnrecoverableDownloadContentException
e
)
{
Log
.
w
(
LOGTAG
"
Downloading
content
failed
(
Unrecoverable
)
:
"
+
content
e
)
;
catalog
.
markAsPermanentlyFailed
(
content
)
;
if
(
temporaryFile
!
=
null
&
&
temporaryFile
.
exists
(
)
)
{
temporaryFile
.
delete
(
)
;
}
DownloadContentTelemetry
.
eventDownloadFailure
(
content
DownloadContentTelemetry
.
ERROR_UNRECOVERABLE
)
;
}
}
Log
.
v
(
LOGTAG
"
Done
"
)
;
}
protected
void
download
(
String
source
File
temporaryFile
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
OutputStream
outputStream
=
null
;
HttpURLConnection
connection
=
null
;
try
{
connection
=
buildHttpURLConnection
(
source
)
;
final
long
offset
=
temporaryFile
.
exists
(
)
?
temporaryFile
.
length
(
)
:
0
;
if
(
offset
>
0
)
{
connection
.
setRequestProperty
(
"
Range
"
"
bytes
=
"
+
offset
+
"
-
"
)
;
}
final
int
status
=
connection
.
getResponseCode
(
)
;
if
(
status
!
=
HttpURLConnection
.
HTTP_OK
&
&
status
!
=
HttpURLConnection
.
HTTP_PARTIAL
)
{
if
(
status
>
=
500
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
SERVER
"
(
Recoverable
)
Download
failed
.
Status
code
:
"
+
status
)
;
}
else
if
(
status
>
=
400
)
{
throw
new
UnrecoverableDownloadContentException
(
"
(
Unrecoverable
)
Download
failed
.
Status
code
:
"
+
status
)
;
}
else
{
throw
new
UnrecoverableDownloadContentException
(
"
(
Unrecoverable
)
Download
failed
.
Status
code
:
"
+
status
)
;
}
}
inputStream
=
new
BufferedInputStream
(
connection
.
getInputStream
(
)
)
;
outputStream
=
openFile
(
temporaryFile
status
=
=
HttpURLConnection
.
HTTP_PARTIAL
)
;
IOUtils
.
copy
(
inputStream
outputStream
)
;
inputStream
.
close
(
)
;
outputStream
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
NETWORK
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
IOUtils
.
safeStreamClose
(
outputStream
)
;
if
(
connection
!
=
null
)
{
connection
.
disconnect
(
)
;
}
}
}
protected
OutputStream
openFile
(
File
file
boolean
append
)
throws
FileNotFoundException
{
return
new
BufferedOutputStream
(
new
FileOutputStream
(
file
append
)
)
;
}
protected
void
extract
(
File
sourceFile
File
destinationFile
String
checksum
)
throws
UnrecoverableDownloadContentException
RecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
InputStream
gzInputStream
=
null
;
OutputStream
outputStream
=
null
;
File
temporaryFile
=
null
;
try
{
File
destinationDirectory
=
destinationFile
.
getParentFile
(
)
;
if
(
!
destinationDirectory
.
exists
(
)
&
&
!
destinationDirectory
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Destination
directory
does
not
exist
and
cannot
be
created
"
)
;
}
temporaryFile
=
new
File
(
destinationDirectory
destinationFile
.
getName
(
)
+
"
.
tmp
"
)
;
inputStream
=
new
BufferedInputStream
(
new
FileInputStream
(
sourceFile
)
)
;
gzInputStream
=
new
GZIPInputStream
(
inputStream
)
;
outputStream
=
new
BufferedOutputStream
(
new
FileOutputStream
(
temporaryFile
)
)
;
IOUtils
.
copy
(
gzInputStream
outputStream
)
;
outputStream
.
flush
(
)
;
if
(
!
verify
(
temporaryFile
checksum
)
)
{
Log
.
w
(
LOGTAG
"
Checksum
of
extracted
file
does
not
match
.
"
)
;
return
;
}
move
(
temporaryFile
destinationFile
)
;
}
catch
(
IOException
e
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
DISK_IO
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
gzInputStream
)
;
IOUtils
.
safeStreamClose
(
inputStream
)
;
IOUtils
.
safeStreamClose
(
outputStream
)
;
if
(
temporaryFile
!
=
null
&
&
temporaryFile
.
exists
(
)
)
{
temporaryFile
.
delete
(
)
;
}
}
}
protected
boolean
isConnectedToNetwork
(
Context
context
)
{
ConnectivityManager
manager
=
(
ConnectivityManager
)
context
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
;
NetworkInfo
networkInfo
=
manager
.
getActiveNetworkInfo
(
)
;
return
networkInfo
!
=
null
&
&
networkInfo
.
isConnected
(
)
;
}
protected
boolean
isActiveNetworkMetered
(
Context
context
)
{
return
ConnectivityManagerCompat
.
isActiveNetworkMetered
(
(
ConnectivityManager
)
context
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
)
;
}
protected
String
createDownloadURL
(
DownloadContent
content
)
{
return
CDN_BASE_URL
+
content
.
getLocation
(
)
;
}
protected
File
createTemporaryFile
(
Context
context
DownloadContent
content
)
throws
RecoverableDownloadContentException
{
File
cacheDirectory
=
new
File
(
context
.
getCacheDir
(
)
CACHE_DIRECTORY
)
;
if
(
!
cacheDirectory
.
exists
(
)
&
&
!
cacheDirectory
.
mkdirs
(
)
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
DISK_IO
"
Could
not
create
cache
directory
:
"
+
cacheDirectory
)
;
}
return
new
File
(
cacheDirectory
content
.
getDownloadChecksum
(
)
+
"
-
"
+
content
.
getId
(
)
)
;
}
protected
void
move
(
File
temporaryFile
File
destinationFile
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
if
(
!
temporaryFile
.
renameTo
(
destinationFile
)
)
{
Log
.
d
(
LOGTAG
"
Could
not
move
temporary
file
to
destination
.
Trying
to
copy
.
.
"
)
;
copy
(
temporaryFile
destinationFile
)
;
temporaryFile
.
delete
(
)
;
}
}
protected
void
copy
(
File
temporaryFile
File
destinationFile
)
throws
RecoverableDownloadContentException
UnrecoverableDownloadContentException
{
InputStream
inputStream
=
null
;
OutputStream
outputStream
=
null
;
try
{
File
destinationDirectory
=
destinationFile
.
getParentFile
(
)
;
if
(
!
destinationDirectory
.
exists
(
)
&
&
!
destinationDirectory
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Destination
directory
does
not
exist
and
cannot
be
created
"
)
;
}
inputStream
=
new
BufferedInputStream
(
new
FileInputStream
(
temporaryFile
)
)
;
outputStream
=
new
BufferedOutputStream
(
new
FileOutputStream
(
destinationFile
)
)
;
IOUtils
.
copy
(
inputStream
outputStream
)
;
inputStream
.
close
(
)
;
outputStream
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RecoverableDownloadContentException
(
RecoverableDownloadContentException
.
DISK_IO
e
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
inputStream
)
;
IOUtils
.
safeStreamClose
(
outputStream
)
;
}
}
protected
boolean
hasEnoughDiskSpace
(
DownloadContent
content
File
destinationFile
File
temporaryFile
)
{
final
File
temporaryDirectory
=
temporaryFile
.
getParentFile
(
)
;
if
(
temporaryDirectory
.
getUsableSpace
(
)
<
content
.
getSize
(
)
)
{
return
false
;
}
final
File
destinationDirectory
=
destinationFile
.
getParentFile
(
)
;
if
(
destinationDirectory
.
getUsableSpace
(
)
<
content
.
getSize
(
)
*
2
)
{
return
false
;
}
return
true
;
}
}
