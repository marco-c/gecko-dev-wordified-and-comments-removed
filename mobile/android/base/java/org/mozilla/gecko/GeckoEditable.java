package
org
.
mozilla
.
gecko
;
import
java
.
lang
.
reflect
.
Array
;
import
java
.
lang
.
reflect
.
Field
;
import
java
.
lang
.
reflect
.
InvocationHandler
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Proxy
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
java
.
util
.
concurrent
.
Semaphore
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
AppConstants
.
Versions
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
;
import
org
.
mozilla
.
gecko
.
mozglue
.
JNIObject
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
.
AssertBehavior
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
text
.
Editable
;
import
android
.
text
.
InputFilter
;
import
android
.
text
.
NoCopySpan
;
import
android
.
text
.
Selection
;
import
android
.
text
.
Spannable
;
import
android
.
text
.
SpannableString
;
import
android
.
text
.
SpannableStringBuilder
;
import
android
.
text
.
Spanned
;
import
android
.
text
.
TextPaint
;
import
android
.
text
.
TextUtils
;
import
android
.
text
.
style
.
CharacterStyle
;
import
android
.
util
.
Log
;
import
android
.
view
.
KeyCharacterMap
;
import
android
.
view
.
KeyEvent
;
final
class
GeckoEditable
extends
JNIObject
implements
InvocationHandler
Editable
GeckoEditableClient
GeckoEditableListener
GeckoEventListener
{
private
static
final
boolean
DEBUG
=
!
AppConstants
.
RELEASE_BUILD
;
private
static
final
String
LOGTAG
=
"
GeckoEditable
"
;
private
InputFilter
[
]
mFilters
;
private
final
SpannableStringBuilder
mText
;
private
final
Editable
mProxy
;
private
final
ActionQueue
mActionQueue
;
private
Handler
mIcRunHandler
;
private
Handler
mIcPostHandler
;
GeckoEditableListener
mListener
;
GeckoView
mView
;
boolean
mInBatchMode
;
boolean
mNeedCompositionUpdate
;
private
boolean
mFocused
;
private
boolean
mGeckoFocused
;
private
boolean
mIgnoreSelectionChange
;
private
volatile
boolean
mSuppressCompositions
;
private
volatile
boolean
mSuppressKeyUp
;
private
static
final
int
IME_RANGE_CARETPOSITION
=
1
;
private
static
final
int
IME_RANGE_RAWINPUT
=
2
;
private
static
final
int
IME_RANGE_SELECTEDRAWTEXT
=
3
;
private
static
final
int
IME_RANGE_CONVERTEDTEXT
=
4
;
private
static
final
int
IME_RANGE_SELECTEDCONVERTEDTEXT
=
5
;
private
static
final
int
IME_RANGE_LINE_NONE
=
0
;
private
static
final
int
IME_RANGE_LINE_DOTTED
=
1
;
private
static
final
int
IME_RANGE_LINE_DASHED
=
2
;
private
static
final
int
IME_RANGE_LINE_SOLID
=
3
;
private
static
final
int
IME_RANGE_LINE_DOUBLE
=
4
;
private
static
final
int
IME_RANGE_LINE_WAVY
=
5
;
private
static
final
int
IME_RANGE_UNDERLINE
=
1
;
private
static
final
int
IME_RANGE_FORECOLOR
=
2
;
private
static
final
int
IME_RANGE_BACKCOLOR
=
4
;
private
static
final
int
IME_RANGE_LINECOLOR
=
8
;
WrapForJNI
private
native
void
onKeyEvent
(
int
action
int
keyCode
int
scanCode
int
metaState
long
time
int
unicodeChar
int
baseUnicodeChar
int
domPrintableKeyValue
int
repeatCount
int
flags
boolean
isSynthesizedImeKey
)
;
private
void
onKeyEvent
(
KeyEvent
event
int
action
int
savedMetaState
boolean
isSynthesizedImeKey
)
{
final
int
metaState
=
event
.
getMetaState
(
)
|
savedMetaState
;
final
int
unmodifiedMetaState
=
metaState
&
~
(
KeyEvent
.
META_ALT_MASK
|
KeyEvent
.
META_CTRL_MASK
|
KeyEvent
.
META_META_MASK
)
;
final
int
unicodeChar
=
event
.
getUnicodeChar
(
metaState
)
;
final
int
domPrintableKeyValue
=
unicodeChar
>
=
'
'
?
unicodeChar
:
unmodifiedMetaState
!
=
metaState
?
event
.
getUnicodeChar
(
unmodifiedMetaState
)
:
0
;
onKeyEvent
(
action
event
.
getKeyCode
(
)
event
.
getScanCode
(
)
metaState
event
.
getEventTime
(
)
unicodeChar
event
.
getUnicodeChar
(
0
)
domPrintableKeyValue
event
.
getRepeatCount
(
)
event
.
getFlags
(
)
isSynthesizedImeKey
)
;
}
WrapForJNI
private
native
void
onImeSynchronize
(
)
;
WrapForJNI
private
native
void
onImeAcknowledgeFocus
(
)
;
WrapForJNI
private
native
void
onImeReplaceText
(
int
start
int
end
String
text
)
;
WrapForJNI
private
native
void
onImeAddCompositionRange
(
int
start
int
end
int
rangeType
int
rangeStyles
int
rangeLineStyle
boolean
rangeBoldLine
int
rangeForeColor
int
rangeBackColor
int
rangeLineColor
)
;
WrapForJNI
private
native
void
onImeUpdateComposition
(
int
start
int
end
)
;
private
static
final
class
Action
{
static
final
int
TYPE_EVENT
=
0
;
static
final
int
TYPE_REPLACE_TEXT
=
1
;
static
final
int
TYPE_SET_SPAN
=
2
;
static
final
int
TYPE_REMOVE_SPAN
=
3
;
static
final
int
TYPE_ACKNOWLEDGE_FOCUS
=
4
;
static
final
int
TYPE_SET_HANDLER
=
5
;
static
final
int
TYPE_UPDATE_COMPOSITION
=
6
;
final
int
mType
;
boolean
mUpdateComposition
;
int
mStart
;
int
mEnd
;
CharSequence
mSequence
;
Object
mSpanObject
;
int
mSpanFlags
;
Handler
mHandler
;
Action
(
int
type
)
{
mType
=
type
;
}
static
Action
newReplaceText
(
CharSequence
text
int
start
int
end
)
{
if
(
start
<
0
|
|
start
>
end
)
{
Log
.
e
(
LOGTAG
"
invalid
replace
text
offsets
:
"
+
start
+
"
to
"
+
end
)
;
throw
new
IllegalArgumentException
(
"
invalid
replace
text
offsets
"
)
;
}
final
Action
action
=
new
Action
(
TYPE_REPLACE_TEXT
)
;
action
.
mSequence
=
text
;
action
.
mStart
=
start
;
action
.
mEnd
=
end
;
return
action
;
}
static
Action
newSetSpan
(
Object
object
int
start
int
end
int
flags
boolean
update
)
{
if
(
start
<
0
|
|
start
>
end
)
{
Log
.
e
(
LOGTAG
"
invalid
span
offsets
:
"
+
start
+
"
to
"
+
end
)
;
throw
new
IllegalArgumentException
(
"
invalid
span
offsets
"
)
;
}
final
Action
action
=
new
Action
(
TYPE_SET_SPAN
)
;
action
.
mSpanObject
=
object
;
action
.
mStart
=
start
;
action
.
mEnd
=
end
;
action
.
mSpanFlags
=
flags
;
action
.
mUpdateComposition
=
update
;
return
action
;
}
static
Action
newRemoveSpan
(
Object
object
boolean
update
)
{
final
Action
action
=
new
Action
(
TYPE_REMOVE_SPAN
)
;
action
.
mSpanObject
=
object
;
action
.
mUpdateComposition
=
update
;
return
action
;
}
static
Action
newSetHandler
(
Handler
handler
)
{
final
Action
action
=
new
Action
(
TYPE_SET_HANDLER
)
;
action
.
mHandler
=
handler
;
return
action
;
}
static
Action
newUpdateComposition
(
int
start
int
end
)
{
final
Action
action
=
new
Action
(
TYPE_UPDATE_COMPOSITION
)
;
action
.
mStart
=
start
;
action
.
mEnd
=
end
;
return
action
;
}
}
private
final
class
ActionQueue
{
private
final
ConcurrentLinkedQueue
<
Action
>
mActions
;
private
final
Semaphore
mActionsActive
;
private
KeyCharacterMap
mKeyMap
;
ActionQueue
(
)
{
mActions
=
new
ConcurrentLinkedQueue
<
Action
>
(
)
;
mActionsActive
=
new
Semaphore
(
1
)
;
}
void
offer
(
Action
action
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
Log
.
d
(
LOGTAG
"
offer
:
Action
(
"
+
getConstantName
(
Action
.
class
"
TYPE_
"
action
.
mType
)
+
"
)
"
)
;
}
if
(
mListener
=
=
null
)
{
return
;
}
if
(
mActions
.
isEmpty
(
)
)
{
mActionsActive
.
acquireUninterruptibly
(
)
;
mActions
.
offer
(
action
)
;
}
else
synchronized
(
this
)
{
mActionsActive
.
tryAcquire
(
)
;
mActions
.
offer
(
action
)
;
}
switch
(
action
.
mType
)
{
case
Action
.
TYPE_EVENT
:
case
Action
.
TYPE_SET_SPAN
:
case
Action
.
TYPE_REMOVE_SPAN
:
case
Action
.
TYPE_SET_HANDLER
:
onImeSynchronize
(
)
;
break
;
case
Action
.
TYPE_REPLACE_TEXT
:
if
(
icMaybeSendComposition
(
action
.
mSequence
true
false
)
)
{
mNeedCompositionUpdate
=
false
;
}
else
{
sendCharKeyEvents
(
action
)
;
}
onImeReplaceText
(
action
.
mStart
action
.
mEnd
action
.
mSequence
.
toString
(
)
)
;
break
;
case
Action
.
TYPE_ACKNOWLEDGE_FOCUS
:
onImeAcknowledgeFocus
(
)
;
break
;
case
Action
.
TYPE_UPDATE_COMPOSITION
:
onImeUpdateComposition
(
action
.
mStart
action
.
mEnd
)
;
break
;
default
:
throw
new
IllegalStateException
(
"
Action
not
processed
"
)
;
}
}
private
KeyEvent
[
]
synthesizeKeyEvents
(
CharSequence
cs
)
{
try
{
if
(
mKeyMap
=
=
null
)
{
mKeyMap
=
KeyCharacterMap
.
load
(
Versions
.
preHC
?
KeyCharacterMap
.
ALPHA
:
KeyCharacterMap
.
VIRTUAL_KEYBOARD
)
;
}
}
catch
(
Exception
e
)
{
return
null
;
}
KeyEvent
[
]
keyEvents
=
mKeyMap
.
getEvents
(
cs
.
toString
(
)
.
toCharArray
(
)
)
;
if
(
keyEvents
=
=
null
|
|
keyEvents
.
length
=
=
0
)
{
return
null
;
}
return
keyEvents
;
}
private
void
sendCharKeyEvents
(
Action
action
)
{
if
(
action
.
mSequence
.
length
(
)
!
=
1
|
|
(
action
.
mSequence
instanceof
Spannable
&
&
(
(
Spannable
)
action
.
mSequence
)
.
nextSpanTransition
(
-
1
Integer
.
MAX_VALUE
null
)
<
Integer
.
MAX_VALUE
)
)
{
return
;
}
KeyEvent
[
]
keyEvents
=
synthesizeKeyEvents
(
action
.
mSequence
)
;
if
(
keyEvents
=
=
null
)
{
return
;
}
for
(
KeyEvent
event
:
keyEvents
)
{
if
(
KeyEvent
.
isModifierKey
(
event
.
getKeyCode
(
)
)
)
{
continue
;
}
if
(
event
.
getAction
(
)
=
=
KeyEvent
.
ACTION_UP
&
&
mSuppressKeyUp
)
{
continue
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
sending
:
"
+
event
)
;
}
onKeyEvent
(
event
event
.
getAction
(
)
0
true
)
;
}
}
void
poll
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
}
if
(
mActions
.
poll
(
)
=
=
null
)
{
throw
new
IllegalStateException
(
"
empty
actions
queue
"
)
;
}
synchronized
(
this
)
{
if
(
mActions
.
isEmpty
(
)
)
{
mActionsActive
.
release
(
)
;
}
}
}
Action
peek
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
}
return
mActions
.
peek
(
)
;
}
void
syncWithGecko
(
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
if
(
mFocused
&
&
!
mActions
.
isEmpty
(
)
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
syncWithGecko
blocking
on
thread
"
+
Thread
.
currentThread
(
)
.
getName
(
)
)
;
}
mActionsActive
.
acquireUninterruptibly
(
)
;
mActionsActive
.
release
(
)
;
}
else
if
(
DEBUG
&
&
!
mFocused
)
{
Log
.
d
(
LOGTAG
"
skipped
syncWithGecko
(
no
focus
)
"
)
;
}
}
boolean
isEmpty
(
)
{
return
mActions
.
isEmpty
(
)
;
}
}
WrapForJNI
GeckoEditable
(
final
GeckoView
v
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
}
mActionQueue
=
new
ActionQueue
(
)
;
mText
=
new
SpannableStringBuilder
(
)
;
final
Class
<
?
>
[
]
PROXY_INTERFACES
=
{
Editable
.
class
}
;
mProxy
=
(
Editable
)
Proxy
.
newProxyInstance
(
Editable
.
class
.
getClassLoader
(
)
PROXY_INTERFACES
this
)
;
mIcRunHandler
=
mIcPostHandler
=
ThreadUtils
.
getUiHandler
(
)
;
onViewChange
(
v
)
;
}
WrapForJNI
Override
protected
native
void
disposeNative
(
)
;
WrapForJNI
void
onViewChange
(
final
GeckoView
v
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
Log
.
d
(
LOGTAG
"
onViewChange
(
"
+
v
+
"
)
"
)
;
}
final
GeckoEditableListener
newListener
=
v
!
=
null
?
GeckoInputConnection
.
create
(
v
this
)
:
null
;
final
Runnable
setListenerRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onViewChange
(
set
listener
)
"
)
;
}
if
(
newListener
!
=
null
)
{
mActionQueue
.
syncWithGecko
(
)
;
mListener
=
newListener
;
}
else
{
mListener
=
null
;
GeckoEditable
.
this
.
disposeNative
(
)
;
}
}
}
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
onViewChange
(
set
IC
)
"
)
;
}
if
(
mView
!
=
null
)
{
mView
.
setInputConnectionListener
(
null
)
;
}
if
(
v
!
=
null
)
{
v
.
setInputConnectionListener
(
(
InputConnectionListener
)
newListener
)
;
}
mView
=
v
;
mIcPostHandler
.
post
(
setListenerRunnable
)
;
}
}
)
;
}
private
boolean
onIcThread
(
)
{
return
mIcRunHandler
.
getLooper
(
)
=
=
Looper
.
myLooper
(
)
;
}
private
void
assertOnIcThread
(
)
{
ThreadUtils
.
assertOnThread
(
mIcRunHandler
.
getLooper
(
)
.
getThread
(
)
AssertBehavior
.
THROW
)
;
}
private
void
geckoPostToIc
(
Runnable
runnable
)
{
mIcPostHandler
.
post
(
runnable
)
;
}
private
Object
getField
(
Object
obj
String
field
Object
def
)
{
try
{
return
obj
.
getClass
(
)
.
getField
(
field
)
.
get
(
obj
)
;
}
catch
(
Exception
e
)
{
return
def
;
}
}
private
boolean
icMaybeSendComposition
(
final
CharSequence
sequence
final
boolean
useEntireText
final
boolean
notifyGecko
)
{
int
selStart
=
Selection
.
getSelectionStart
(
sequence
)
;
int
selEnd
=
Selection
.
getSelectionEnd
(
sequence
)
;
if
(
sequence
instanceof
Spanned
)
{
final
Spanned
text
=
(
Spanned
)
sequence
;
final
Object
[
]
spans
=
text
.
getSpans
(
0
text
.
length
(
)
Object
.
class
)
;
boolean
found
=
false
;
int
composingStart
=
useEntireText
?
0
:
Integer
.
MAX_VALUE
;
int
composingEnd
=
useEntireText
?
text
.
length
(
)
:
0
;
for
(
Object
span
:
spans
)
{
if
(
(
text
.
getSpanFlags
(
span
)
&
Spanned
.
SPAN_COMPOSING
)
=
=
0
)
{
continue
;
}
if
(
!
useEntireText
)
{
composingStart
=
Math
.
min
(
composingStart
text
.
getSpanStart
(
span
)
)
;
composingEnd
=
Math
.
max
(
composingEnd
text
.
getSpanEnd
(
span
)
)
;
}
found
=
true
;
}
if
(
useEntireText
&
&
(
selStart
<
0
|
|
selEnd
<
0
)
)
{
selStart
=
composingEnd
;
selEnd
=
composingEnd
;
}
if
(
found
)
{
icSendComposition
(
text
selStart
selEnd
composingStart
composingEnd
)
;
if
(
notifyGecko
)
{
mActionQueue
.
offer
(
Action
.
newUpdateComposition
(
composingStart
composingEnd
)
)
;
}
return
true
;
}
}
if
(
notifyGecko
)
{
mActionQueue
.
offer
(
Action
.
newUpdateComposition
(
selStart
selEnd
)
)
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
icSendComposition
(
)
:
no
composition
"
)
;
}
return
false
;
}
private
void
icSendComposition
(
final
Spanned
text
final
int
selStart
final
int
selEnd
final
int
composingStart
final
int
composingEnd
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
Log
.
d
(
LOGTAG
"
icSendComposition
(
\
"
"
+
text
+
"
\
"
"
+
composingStart
+
"
"
+
composingEnd
+
"
)
"
)
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
range
=
"
+
composingStart
+
"
-
"
+
composingEnd
)
;
Log
.
d
(
LOGTAG
"
selection
=
"
+
selStart
+
"
-
"
+
selEnd
)
;
}
if
(
selEnd
>
=
composingStart
&
&
selEnd
<
=
composingEnd
)
{
onImeAddCompositionRange
(
selEnd
-
composingStart
selEnd
-
composingStart
IME_RANGE_CARETPOSITION
0
0
false
0
0
0
)
;
}
int
rangeStart
=
composingStart
;
TextPaint
tp
=
new
TextPaint
(
)
;
TextPaint
emptyTp
=
new
TextPaint
(
)
;
emptyTp
.
setColor
(
0
)
;
do
{
int
rangeType
rangeStyles
=
0
rangeLineStyle
=
IME_RANGE_LINE_NONE
;
boolean
rangeBoldLine
=
false
;
int
rangeForeColor
=
0
rangeBackColor
=
0
rangeLineColor
=
0
;
int
rangeEnd
=
text
.
nextSpanTransition
(
rangeStart
composingEnd
Object
.
class
)
;
if
(
selStart
>
rangeStart
&
&
selStart
<
rangeEnd
)
{
rangeEnd
=
selStart
;
}
else
if
(
selEnd
>
rangeStart
&
&
selEnd
<
rangeEnd
)
{
rangeEnd
=
selEnd
;
}
CharacterStyle
[
]
styleSpans
=
text
.
getSpans
(
rangeStart
rangeEnd
CharacterStyle
.
class
)
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
found
"
+
styleSpans
.
length
+
"
spans
"
+
rangeStart
+
"
-
"
+
rangeEnd
)
;
}
if
(
styleSpans
.
length
=
=
0
)
{
rangeType
=
(
selStart
=
=
rangeStart
&
&
selEnd
=
=
rangeEnd
)
?
IME_RANGE_SELECTEDRAWTEXT
:
IME_RANGE_RAWINPUT
;
}
else
{
rangeType
=
(
selStart
=
=
rangeStart
&
&
selEnd
=
=
rangeEnd
)
?
IME_RANGE_SELECTEDCONVERTEDTEXT
:
IME_RANGE_CONVERTEDTEXT
;
tp
.
set
(
emptyTp
)
;
for
(
CharacterStyle
span
:
styleSpans
)
{
span
.
updateDrawState
(
tp
)
;
}
int
tpUnderlineColor
=
0
;
float
tpUnderlineThickness
=
0
.
0f
;
if
(
Versions
.
feature14Plus
)
{
tpUnderlineColor
=
(
Integer
)
getField
(
tp
"
underlineColor
"
0
)
;
tpUnderlineThickness
=
(
Float
)
getField
(
tp
"
underlineThickness
"
0
.
0f
)
;
}
if
(
tpUnderlineColor
!
=
0
)
{
rangeStyles
|
=
IME_RANGE_UNDERLINE
|
IME_RANGE_LINECOLOR
;
rangeLineColor
=
tpUnderlineColor
;
if
(
tpUnderlineThickness
<
=
0
.
5f
)
{
rangeLineStyle
=
IME_RANGE_LINE_DOTTED
;
}
else
{
rangeLineStyle
=
IME_RANGE_LINE_SOLID
;
if
(
tpUnderlineThickness
>
=
2
.
0f
)
{
rangeBoldLine
=
true
;
}
}
}
else
if
(
tp
.
isUnderlineText
(
)
)
{
rangeStyles
|
=
IME_RANGE_UNDERLINE
;
rangeLineStyle
=
IME_RANGE_LINE_SOLID
;
}
if
(
tp
.
getColor
(
)
!
=
0
)
{
rangeStyles
|
=
IME_RANGE_FORECOLOR
;
rangeForeColor
=
tp
.
getColor
(
)
;
}
if
(
tp
.
bgColor
!
=
0
)
{
rangeStyles
|
=
IME_RANGE_BACKCOLOR
;
rangeBackColor
=
tp
.
bgColor
;
}
}
onImeAddCompositionRange
(
rangeStart
-
composingStart
rangeEnd
-
composingStart
rangeType
rangeStyles
rangeLineStyle
rangeBoldLine
rangeForeColor
rangeBackColor
rangeLineColor
)
;
rangeStart
=
rangeEnd
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
added
"
+
rangeType
+
"
:
"
+
Integer
.
toHexString
(
rangeStyles
)
+
"
:
"
+
Integer
.
toHexString
(
rangeForeColor
)
+
"
:
"
+
Integer
.
toHexString
(
rangeBackColor
)
)
;
}
}
while
(
rangeStart
<
composingEnd
)
;
}
Override
public
void
sendKeyEvent
(
final
KeyEvent
event
int
action
int
metaState
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
Log
.
d
(
LOGTAG
"
sendKeyEvent
(
"
+
event
+
"
"
+
action
+
"
"
+
metaState
+
"
)
"
)
;
}
if
(
mNeedCompositionUpdate
)
{
icUpdateComposition
(
)
;
}
onKeyEvent
(
event
action
metaState
false
)
;
mActionQueue
.
offer
(
new
Action
(
Action
.
TYPE_EVENT
)
)
;
}
Override
public
Editable
getEditable
(
)
{
if
(
!
onIcThread
(
)
)
{
if
(
DEBUG
)
{
Log
.
i
(
LOGTAG
"
getEditable
(
)
called
on
non
-
IC
thread
"
)
;
}
return
null
;
}
if
(
mListener
=
=
null
)
{
return
null
;
}
return
mProxy
;
}
Override
public
void
setBatchMode
(
boolean
inBatchMode
)
{
if
(
!
onIcThread
(
)
)
{
if
(
DEBUG
)
{
Log
.
i
(
LOGTAG
"
setBatchMode
(
)
called
on
non
-
IC
thread
"
)
;
}
return
;
}
if
(
!
inBatchMode
&
&
mNeedCompositionUpdate
)
{
icUpdateComposition
(
)
;
}
mInBatchMode
=
inBatchMode
;
}
private
void
icUpdateComposition
(
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
mNeedCompositionUpdate
=
false
;
mActionQueue
.
syncWithGecko
(
)
;
icMaybeSendComposition
(
mText
false
true
)
;
}
private
void
geckoScheduleCompositionUpdate
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
}
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mInBatchMode
|
|
!
mNeedCompositionUpdate
)
{
return
;
}
if
(
!
mActionQueue
.
isEmpty
(
)
)
{
mIcPostHandler
.
postDelayed
(
this
10
)
;
return
;
}
icUpdateComposition
(
)
;
}
}
)
;
}
Override
public
void
setSuppressKeyUp
(
boolean
suppress
)
{
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
mSuppressKeyUp
=
suppress
;
}
Override
public
Handler
setInputConnectionHandler
(
Handler
handler
)
{
if
(
handler
=
=
mIcPostHandler
|
|
!
mFocused
)
{
return
mIcPostHandler
;
}
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
mActionQueue
.
offer
(
Action
.
newSetHandler
(
handler
)
)
;
mActionQueue
.
syncWithGecko
(
)
;
return
handler
;
}
Override
public
void
postToInputConnection
(
final
Runnable
runnable
)
{
mIcPostHandler
.
post
(
runnable
)
;
}
private
void
geckoSetIcHandler
(
final
Handler
newHandler
)
{
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
synchronized
(
newHandler
)
{
mIcRunHandler
=
newHandler
;
newHandler
.
notify
(
)
;
}
}
}
)
;
mIcPostHandler
=
newHandler
;
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
synchronized
(
newHandler
)
{
while
(
mIcRunHandler
!
=
newHandler
)
{
try
{
newHandler
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
}
}
}
}
}
)
;
}
private
void
geckoActionReply
(
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
}
final
Action
action
=
mActionQueue
.
peek
(
)
;
if
(
action
=
=
null
)
{
throw
new
IllegalStateException
(
"
empty
actions
queue
"
)
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
reply
:
Action
(
"
+
getConstantName
(
Action
.
class
"
TYPE_
"
action
.
mType
)
+
"
)
"
)
;
}
switch
(
action
.
mType
)
{
case
Action
.
TYPE_SET_SPAN
:
mText
.
setSpan
(
action
.
mSpanObject
action
.
mStart
action
.
mEnd
action
.
mSpanFlags
)
;
break
;
case
Action
.
TYPE_REMOVE_SPAN
:
mText
.
removeSpan
(
action
.
mSpanObject
)
;
break
;
case
Action
.
TYPE_SET_HANDLER
:
geckoSetIcHandler
(
action
.
mHandler
)
;
break
;
}
if
(
action
.
mUpdateComposition
)
{
geckoScheduleCompositionUpdate
(
)
;
}
}
private
void
notifyCommitComposition
(
)
{
}
private
void
notifyCancelComposition
(
)
{
if
(
DEBUG
)
{
final
Object
[
]
spans
=
mText
.
getSpans
(
0
mText
.
length
(
)
Object
.
class
)
;
for
(
Object
span
:
spans
)
{
if
(
(
mText
.
getSpanFlags
(
span
)
&
Spanned
.
SPAN_COMPOSING
)
!
=
0
)
{
throw
new
IllegalStateException
(
"
composition
not
cancelled
"
)
;
}
}
}
}
WrapForJNI
Override
public
void
notifyIME
(
final
int
type
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
if
(
type
!
=
NOTIFY_IME_REPLY_EVENT
)
{
Log
.
d
(
LOGTAG
"
notifyIME
(
"
+
getConstantName
(
GeckoEditableListener
.
class
"
NOTIFY_IME_
"
type
)
+
"
)
"
)
;
}
}
if
(
type
=
=
NOTIFY_IME_REPLY_EVENT
)
{
try
{
if
(
mGeckoFocused
)
{
geckoActionReply
(
)
;
}
else
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
discarding
stale
reply
"
)
;
}
}
finally
{
mActionQueue
.
poll
(
)
;
}
return
;
}
else
if
(
type
=
=
NOTIFY_IME_TO_COMMIT_COMPOSITION
)
{
notifyCommitComposition
(
)
;
return
;
}
else
if
(
type
=
=
NOTIFY_IME_TO_CANCEL_COMPOSITION
)
{
notifyCancelComposition
(
)
;
return
;
}
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
type
=
=
NOTIFY_IME_OF_FOCUS
)
{
mFocused
=
true
;
mActionQueue
.
offer
(
new
Action
(
Action
.
TYPE_ACKNOWLEDGE_FOCUS
)
)
;
}
mActionQueue
.
syncWithGecko
(
)
;
if
(
mListener
!
=
null
)
{
mListener
.
notifyIME
(
type
)
;
}
if
(
type
=
=
NOTIFY_IME_OF_BLUR
)
{
mFocused
=
false
;
}
}
}
)
;
if
(
type
=
=
NOTIFY_IME_OF_BLUR
&
&
mGeckoFocused
)
{
mGeckoFocused
=
false
;
mSuppressCompositions
=
false
;
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
this
"
TextSelection
:
DraggingHandle
"
)
;
}
else
if
(
type
=
=
NOTIFY_IME_OF_FOCUS
)
{
mGeckoFocused
=
true
;
mSuppressCompositions
=
false
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
this
"
TextSelection
:
DraggingHandle
"
)
;
}
}
WrapForJNI
Override
public
void
notifyIMEContext
(
final
int
state
final
String
typeHint
final
String
modeHint
final
String
actionHint
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
Log
.
d
(
LOGTAG
"
notifyIMEContext
(
"
+
getConstantName
(
GeckoEditableListener
.
class
"
IME_STATE_
"
state
)
+
"
\
"
"
+
typeHint
+
"
\
"
\
"
"
+
modeHint
+
"
\
"
\
"
"
+
actionHint
+
"
\
"
)
"
)
;
}
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
mListener
.
notifyIMEContext
(
state
typeHint
modeHint
actionHint
)
;
}
}
)
;
}
WrapForJNI
Override
public
void
onSelectionChange
(
int
start
int
end
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
Log
.
d
(
LOGTAG
"
onSelectionChange
(
"
+
start
+
"
"
+
end
+
"
)
"
)
;
}
if
(
start
<
0
|
|
start
>
mText
.
length
(
)
|
|
end
<
0
|
|
end
>
mText
.
length
(
)
)
{
Log
.
e
(
LOGTAG
"
invalid
selection
notification
range
:
"
+
start
+
"
to
"
+
end
+
"
length
:
"
+
mText
.
length
(
)
)
;
throw
new
IllegalArgumentException
(
"
invalid
selection
notification
range
"
)
;
}
if
(
mIgnoreSelectionChange
)
{
start
=
Selection
.
getSelectionStart
(
mText
)
;
end
=
Selection
.
getSelectionEnd
(
mText
)
;
mIgnoreSelectionChange
=
false
;
}
else
{
Selection
.
setSelection
(
mText
start
end
)
;
}
final
int
newStart
=
start
;
final
int
newEnd
=
end
;
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
mListener
.
onSelectionChange
(
newStart
newEnd
)
;
}
}
)
;
}
private
void
geckoReplaceText
(
int
start
int
oldEnd
CharSequence
newText
)
{
if
(
AppConstants
.
Versions
.
preHC
)
{
mText
.
delete
(
start
oldEnd
)
;
mText
.
insert
(
start
newText
)
;
}
else
{
mText
.
replace
(
start
oldEnd
newText
)
;
}
}
private
boolean
geckoIsSameText
(
int
start
int
oldEnd
CharSequence
newText
)
{
return
oldEnd
-
start
=
=
newText
.
length
(
)
&
&
TextUtils
.
regionMatches
(
mText
start
newText
0
oldEnd
-
start
)
;
}
WrapForJNI
Override
public
void
onTextChange
(
final
CharSequence
text
final
int
start
final
int
unboundedOldEnd
final
int
unboundedNewEnd
)
{
if
(
DEBUG
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
StringBuilder
sb
=
new
StringBuilder
(
"
onTextChange
(
"
)
;
debugAppend
(
sb
text
)
;
sb
.
append
(
"
"
)
.
append
(
start
)
.
append
(
"
"
)
.
append
(
unboundedOldEnd
)
.
append
(
"
"
)
.
append
(
unboundedNewEnd
)
.
append
(
"
)
"
)
;
Log
.
d
(
LOGTAG
sb
.
toString
(
)
)
;
}
if
(
start
<
0
|
|
start
>
unboundedOldEnd
)
{
Log
.
e
(
LOGTAG
"
invalid
text
notification
range
:
"
+
start
+
"
to
"
+
unboundedOldEnd
)
;
throw
new
IllegalArgumentException
(
"
invalid
text
notification
range
"
)
;
}
final
int
oldEnd
=
unboundedOldEnd
>
mText
.
length
(
)
?
mText
.
length
(
)
:
unboundedOldEnd
;
if
(
unboundedOldEnd
<
=
mText
.
length
(
)
&
&
unboundedNewEnd
!
=
(
start
+
text
.
length
(
)
)
)
{
Log
.
e
(
LOGTAG
"
newEnd
does
not
match
text
:
"
+
unboundedNewEnd
+
"
vs
"
+
(
start
+
text
.
length
(
)
)
)
;
throw
new
IllegalArgumentException
(
"
newEnd
does
not
match
text
"
)
;
}
final
int
newEnd
=
start
+
text
.
length
(
)
;
final
Action
action
=
mActionQueue
.
peek
(
)
;
if
(
action
!
=
null
&
&
action
.
mType
=
=
Action
.
TYPE_ACKNOWLEDGE_FOCUS
)
{
mText
.
replace
(
0
mText
.
length
(
)
text
)
;
}
else
if
(
action
!
=
null
&
&
action
.
mType
=
=
Action
.
TYPE_REPLACE_TEXT
&
&
start
<
=
action
.
mStart
&
&
oldEnd
>
=
action
.
mEnd
&
&
newEnd
>
=
action
.
mStart
+
action
.
mSequence
.
length
(
)
)
{
final
int
startWithinText
=
action
.
mStart
-
start
;
int
indexInText
=
TextUtils
.
indexOf
(
text
action
.
mSequence
startWithinText
)
;
if
(
indexInText
<
0
&
&
startWithinText
>
=
action
.
mSequence
.
length
(
)
)
{
indexInText
=
text
.
toString
(
)
.
lastIndexOf
(
action
.
mSequence
.
toString
(
)
startWithinText
)
;
}
if
(
indexInText
<
0
)
{
geckoReplaceText
(
start
oldEnd
text
)
;
mIgnoreSelectionChange
=
false
;
}
else
if
(
indexInText
=
=
0
&
&
text
.
length
(
)
=
=
action
.
mSequence
.
length
(
)
)
{
geckoReplaceText
(
start
oldEnd
action
.
mSequence
)
;
mIgnoreSelectionChange
=
true
;
}
else
{
geckoReplaceText
(
start
action
.
mStart
text
.
subSequence
(
0
indexInText
)
)
;
final
int
actionStart
=
indexInText
+
start
;
geckoReplaceText
(
actionStart
actionStart
+
action
.
mEnd
-
action
.
mStart
action
.
mSequence
)
;
final
int
actionEnd
=
actionStart
+
action
.
mSequence
.
length
(
)
;
geckoReplaceText
(
actionEnd
actionEnd
+
oldEnd
-
action
.
mEnd
text
.
subSequence
(
actionEnd
-
start
text
.
length
(
)
)
)
;
}
}
else
if
(
geckoIsSameText
(
start
oldEnd
text
)
)
{
mIgnoreSelectionChange
=
mIgnoreSelectionChange
|
|
(
action
!
=
null
&
&
action
.
mType
=
=
Action
.
TYPE_UPDATE_COMPOSITION
)
;
return
;
}
else
{
geckoReplaceText
(
start
oldEnd
text
)
;
}
geckoPostToIc
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
mListener
=
=
null
)
{
return
;
}
mListener
.
onTextChange
(
text
start
oldEnd
newEnd
)
;
}
}
)
;
}
static
String
getConstantName
(
Class
<
?
>
cls
String
prefix
Object
value
)
{
for
(
Field
fld
:
cls
.
getDeclaredFields
(
)
)
{
try
{
if
(
fld
.
getName
(
)
.
startsWith
(
prefix
)
&
&
fld
.
get
(
null
)
.
equals
(
value
)
)
{
return
fld
.
getName
(
)
;
}
}
catch
(
IllegalAccessException
e
)
{
}
}
return
String
.
valueOf
(
value
)
;
}
static
StringBuilder
debugAppend
(
StringBuilder
sb
Object
obj
)
{
if
(
obj
=
=
null
)
{
sb
.
append
(
"
null
"
)
;
}
else
if
(
obj
instanceof
GeckoEditable
)
{
sb
.
append
(
"
GeckoEditable
"
)
;
}
else
if
(
Proxy
.
isProxyClass
(
obj
.
getClass
(
)
)
)
{
debugAppend
(
sb
Proxy
.
getInvocationHandler
(
obj
)
)
;
}
else
if
(
obj
instanceof
CharSequence
)
{
sb
.
append
(
'
"
'
)
.
append
(
obj
.
toString
(
)
.
replace
(
'
\
n
'
'
\
u21b2
'
)
)
.
append
(
'
"
'
)
;
}
else
if
(
obj
.
getClass
(
)
.
isArray
(
)
)
{
sb
.
append
(
obj
.
getClass
(
)
.
getComponentType
(
)
.
getSimpleName
(
)
)
.
append
(
'
[
'
)
.
append
(
Array
.
getLength
(
obj
)
)
.
append
(
'
]
'
)
;
}
else
{
sb
.
append
(
obj
)
;
}
return
sb
;
}
Override
public
Object
invoke
(
Object
proxy
Method
method
Object
[
]
args
)
throws
Throwable
{
Object
target
;
final
Class
<
?
>
methodInterface
=
method
.
getDeclaringClass
(
)
;
if
(
DEBUG
)
{
assertOnIcThread
(
)
;
}
if
(
methodInterface
=
=
Editable
.
class
|
|
methodInterface
=
=
Appendable
.
class
|
|
methodInterface
=
=
Spannable
.
class
)
{
target
=
this
;
}
else
{
mActionQueue
.
syncWithGecko
(
)
;
target
=
mText
;
}
Object
ret
;
try
{
ret
=
method
.
invoke
(
target
args
)
;
}
catch
(
InvocationTargetException
e
)
{
if
(
!
(
e
.
getCause
(
)
instanceof
IndexOutOfBoundsException
)
)
{
throw
e
;
}
Log
.
w
(
LOGTAG
"
Exception
in
GeckoEditable
.
"
+
method
.
getName
(
)
e
.
getCause
(
)
)
;
Class
<
?
>
retClass
=
method
.
getReturnType
(
)
;
if
(
retClass
=
=
Character
.
TYPE
)
{
ret
=
'
\
0
'
;
}
else
if
(
retClass
=
=
Integer
.
TYPE
)
{
ret
=
0
;
}
else
if
(
retClass
=
=
String
.
class
)
{
ret
=
"
"
;
}
else
{
ret
=
null
;
}
}
if
(
DEBUG
)
{
StringBuilder
log
=
new
StringBuilder
(
method
.
getName
(
)
)
;
log
.
append
(
"
(
"
)
;
if
(
args
!
=
null
)
{
for
(
Object
arg
:
args
)
{
debugAppend
(
log
arg
)
.
append
(
"
"
)
;
}
if
(
args
.
length
>
0
)
{
log
.
setLength
(
log
.
length
(
)
-
2
)
;
}
}
if
(
method
.
getReturnType
(
)
.
equals
(
Void
.
TYPE
)
)
{
log
.
append
(
"
)
"
)
;
}
else
{
debugAppend
(
log
.
append
(
"
)
=
"
)
ret
)
;
}
Log
.
d
(
LOGTAG
log
.
toString
(
)
)
;
}
return
ret
;
}
Override
public
void
removeSpan
(
Object
what
)
{
if
(
what
=
=
Selection
.
SELECTION_START
|
|
what
=
=
Selection
.
SELECTION_END
)
{
Log
.
w
(
LOGTAG
"
selection
removed
with
removeSpan
(
)
"
)
;
}
final
boolean
update
=
!
mNeedCompositionUpdate
&
&
what
instanceof
NoCopySpan
;
mActionQueue
.
offer
(
Action
.
newRemoveSpan
(
what
update
)
)
;
mNeedCompositionUpdate
|
=
update
;
}
Override
public
void
setSpan
(
Object
what
int
start
int
end
int
flags
)
{
final
boolean
update
=
!
mNeedCompositionUpdate
&
&
(
flags
&
Spanned
.
SPAN_INTERMEDIATE
)
=
=
0
&
&
(
(
flags
&
Spanned
.
SPAN_COMPOSING
)
!
=
0
|
|
what
=
=
Selection
.
SELECTION_START
|
|
what
=
=
Selection
.
SELECTION_END
)
;
mActionQueue
.
offer
(
Action
.
newSetSpan
(
what
start
end
flags
update
)
)
;
mNeedCompositionUpdate
|
=
update
;
}
Override
public
Editable
append
(
CharSequence
text
)
{
return
replace
(
mProxy
.
length
(
)
mProxy
.
length
(
)
text
0
text
.
length
(
)
)
;
}
Override
public
Editable
append
(
CharSequence
text
int
start
int
end
)
{
return
replace
(
mProxy
.
length
(
)
mProxy
.
length
(
)
text
start
end
)
;
}
Override
public
Editable
append
(
char
text
)
{
return
replace
(
mProxy
.
length
(
)
mProxy
.
length
(
)
String
.
valueOf
(
text
)
0
1
)
;
}
Override
public
InputFilter
[
]
getFilters
(
)
{
return
mFilters
;
}
Override
public
void
setFilters
(
InputFilter
[
]
filters
)
{
mFilters
=
filters
;
}
Override
public
void
clearSpans
(
)
{
Log
.
w
(
LOGTAG
"
selection
cleared
with
clearSpans
(
)
"
)
;
mText
.
clearSpans
(
)
;
}
Override
public
Editable
replace
(
int
st
int
en
CharSequence
source
int
start
int
end
)
{
CharSequence
text
=
source
;
if
(
start
<
0
|
|
start
>
end
|
|
end
>
text
.
length
(
)
)
{
Log
.
e
(
LOGTAG
"
invalid
replace
offsets
:
"
+
start
+
"
to
"
+
end
+
"
length
:
"
+
text
.
length
(
)
)
;
throw
new
IllegalArgumentException
(
"
invalid
replace
offsets
"
)
;
}
if
(
start
!
=
0
|
|
end
!
=
text
.
length
(
)
)
{
text
=
text
.
subSequence
(
start
end
)
;
}
if
(
mFilters
!
=
null
)
{
for
(
int
i
=
0
;
i
<
mFilters
.
length
;
+
+
i
)
{
final
CharSequence
cs
=
mFilters
[
i
]
.
filter
(
text
0
text
.
length
(
)
mProxy
st
en
)
;
if
(
cs
!
=
null
)
{
text
=
cs
;
}
}
}
if
(
text
=
=
source
)
{
text
=
new
SpannableString
(
source
)
;
}
mActionQueue
.
offer
(
Action
.
newReplaceText
(
text
Math
.
min
(
st
en
)
Math
.
max
(
st
en
)
)
)
;
return
mProxy
;
}
Override
public
void
clear
(
)
{
replace
(
0
mProxy
.
length
(
)
"
"
0
0
)
;
}
Override
public
Editable
delete
(
int
st
int
en
)
{
return
replace
(
st
en
"
"
0
0
)
;
}
Override
public
Editable
insert
(
int
where
CharSequence
text
int
start
int
end
)
{
return
replace
(
where
where
text
start
end
)
;
}
Override
public
Editable
insert
(
int
where
CharSequence
text
)
{
return
replace
(
where
where
text
0
text
.
length
(
)
)
;
}
Override
public
Editable
replace
(
int
st
int
en
CharSequence
text
)
{
return
replace
(
st
en
text
0
text
.
length
(
)
)
;
}
Override
public
void
getChars
(
int
start
int
end
char
[
]
dest
int
destoff
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
getSpanEnd
(
Object
tag
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
getSpanFlags
(
Object
tag
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
getSpanStart
(
Object
tag
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
<
T
>
T
[
]
getSpans
(
int
start
int
end
Class
<
T
>
type
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
SuppressWarnings
(
"
rawtypes
"
)
public
int
nextSpanTransition
(
int
start
int
limit
Class
type
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
char
charAt
(
int
index
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
int
length
(
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
CharSequence
subSequence
(
int
start
int
end
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
String
toString
(
)
{
throw
new
UnsupportedOperationException
(
"
method
must
be
called
through
mProxy
"
)
;
}
Override
public
void
handleMessage
(
String
event
JSONObject
message
)
{
if
(
!
"
TextSelection
:
DraggingHandle
"
.
equals
(
event
)
)
{
return
;
}
mSuppressCompositions
=
message
.
optBoolean
(
"
dragging
"
false
)
;
}
}
