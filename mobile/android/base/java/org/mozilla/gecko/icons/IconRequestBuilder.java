package
org
.
mozilla
.
gecko
.
icons
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
CheckResult
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
java
.
util
.
TreeSet
;
import
ch
.
boye
.
httpclientandroidlib
.
util
.
TextUtils
;
public
class
IconRequestBuilder
{
private
final
IconRequest
internal
;
IconRequestBuilder
(
Context
context
)
{
internal
=
new
IconRequest
(
context
)
;
}
IconRequestBuilder
(
IconRequest
request
)
{
internal
=
request
;
}
CheckResult
public
IconRequestBuilder
pageUrl
(
String
pageUrl
)
{
internal
.
pageUrl
=
pageUrl
;
return
this
;
}
CheckResult
public
IconRequestBuilder
privileged
(
boolean
privileged
)
{
internal
.
privileged
=
privileged
;
return
this
;
}
CheckResult
public
IconRequestBuilder
icon
(
IconDescriptor
descriptor
)
{
internal
.
icons
.
add
(
descriptor
)
;
return
this
;
}
CheckResult
public
IconRequestBuilder
skipNetwork
(
)
{
internal
.
skipNetwork
=
true
;
return
this
;
}
CheckResult
public
IconRequestBuilder
skipNetworkIf
(
boolean
shouldSkipNetwork
)
{
internal
.
skipNetwork
=
shouldSkipNetwork
;
return
this
;
}
CheckResult
public
IconRequestBuilder
skipDisk
(
)
{
internal
.
skipDisk
=
true
;
return
this
;
}
CheckResult
public
IconRequestBuilder
skipMemory
(
)
{
internal
.
skipMemory
=
true
;
return
this
;
}
public
IconRequestBuilder
forLauncherIcon
(
)
{
internal
.
targetSize
=
GeckoAppShell
.
getPreferredIconSize
(
)
;
return
this
;
}
CheckResult
public
IconRequestBuilder
executeCallbackOnBackgroundThread
(
)
{
internal
.
backgroundThread
=
true
;
return
this
;
}
public
IconRequestBuilder
prepareOnly
(
)
{
internal
.
prepareOnly
=
true
;
return
this
;
}
CheckResult
public
IconRequest
build
(
)
{
if
(
TextUtils
.
isEmpty
(
internal
.
pageUrl
)
)
{
throw
new
IllegalStateException
(
"
Page
URL
is
required
"
)
;
}
IconRequest
request
=
new
IconRequest
(
internal
.
getContext
(
)
)
;
request
.
pageUrl
=
internal
.
pageUrl
;
request
.
privileged
=
internal
.
privileged
;
request
.
icons
=
new
TreeSet
<
>
(
internal
.
icons
)
;
request
.
skipNetwork
=
internal
.
skipNetwork
;
request
.
backgroundThread
=
internal
.
backgroundThread
;
request
.
skipDisk
=
internal
.
skipDisk
;
request
.
skipMemory
=
internal
.
skipMemory
;
request
.
targetSize
=
internal
.
targetSize
;
request
.
prepareOnly
=
internal
.
prepareOnly
;
return
request
;
}
public
void
deferBuild
(
)
{
}
}
