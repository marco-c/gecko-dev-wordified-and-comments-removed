package
org
.
mozilla
.
gecko
.
icons
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
org
.
mozilla
.
gecko
.
R
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
TreeSet
;
import
java
.
util
.
concurrent
.
Future
;
public
class
IconRequest
{
private
Context
context
;
String
pageUrl
;
boolean
privileged
;
TreeSet
<
IconDescriptor
>
icons
;
boolean
skipNetwork
;
boolean
backgroundThread
;
boolean
skipDisk
;
boolean
skipMemory
;
int
targetSize
;
int
minimumSizePxAfterScaling
;
boolean
prepareOnly
;
private
IconCallback
callback
;
IconRequest
(
Context
context
)
{
this
.
context
=
context
.
getApplicationContext
(
)
;
this
.
icons
=
new
TreeSet
<
>
(
new
IconDescriptorComparator
(
)
)
;
this
.
privileged
=
false
;
this
.
skipMemory
=
false
;
this
.
skipDisk
=
false
;
this
.
skipNetwork
=
false
;
this
.
targetSize
=
context
.
getResources
(
)
.
getDimensionPixelSize
(
R
.
dimen
.
favicon_bg
)
;
this
.
minimumSizePxAfterScaling
=
0
;
this
.
prepareOnly
=
false
;
}
public
Future
<
IconResponse
>
execute
(
IconCallback
callback
)
{
setCallback
(
callback
)
;
return
IconRequestExecutor
.
submit
(
this
)
;
}
VisibleForTesting
void
setCallback
(
IconCallback
callback
)
{
this
.
callback
=
callback
;
}
public
Context
getContext
(
)
{
return
context
;
}
public
IconDescriptor
getBestIcon
(
)
{
return
icons
.
first
(
)
;
}
public
String
getPageUrl
(
)
{
return
pageUrl
;
}
public
boolean
isPrivileged
(
)
{
return
privileged
;
}
public
int
getIconCount
(
)
{
return
icons
.
size
(
)
;
}
public
int
getTargetSize
(
)
{
return
targetSize
;
}
public
int
getMinimumSizePxAfterScaling
(
)
{
return
minimumSizePxAfterScaling
;
}
public
boolean
shouldSkipNetwork
(
)
{
return
skipNetwork
;
}
public
boolean
shouldSkipDisk
(
)
{
return
skipDisk
;
}
public
boolean
shouldSkipMemory
(
)
{
return
skipMemory
;
}
public
Iterator
<
IconDescriptor
>
getIconIterator
(
)
{
return
icons
.
iterator
(
)
;
}
public
IconRequestBuilder
modify
(
)
{
return
new
IconRequestBuilder
(
this
)
;
}
boolean
shouldRunOnBackgroundThread
(
)
{
return
backgroundThread
;
}
IconCallback
getCallback
(
)
{
return
callback
;
}
boolean
hasIconDescriptors
(
)
{
return
!
icons
.
isEmpty
(
)
;
}
void
moveToNextIcon
(
)
{
if
(
!
icons
.
remove
(
getBestIcon
(
)
)
)
{
throw
new
IllegalStateException
(
"
Moving
to
next
icon
failed
.
Could
not
remove
first
icon
from
set
.
"
)
;
}
}
boolean
shouldPrepareOnly
(
)
{
return
prepareOnly
;
}
}
