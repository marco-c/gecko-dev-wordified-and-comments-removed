package
org
.
mozilla
.
gecko
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
PipedInputStream
;
import
java
.
io
.
PipedOutputStream
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
Proxy
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
net
.
URL
;
import
java
.
net
.
URLConnection
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Map
;
import
java
.
util
.
NoSuchElementException
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
TreeMap
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
android
.
content
.
ContentResolver
;
import
org
.
mozilla
.
gecko
.
annotation
.
JNITarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
AppConstants
.
Versions
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
LocalURLMetadata
;
import
org
.
mozilla
.
gecko
.
db
.
URLMetadataTable
;
import
org
.
mozilla
.
gecko
.
favicons
.
Favicons
;
import
org
.
mozilla
.
gecko
.
favicons
.
OnFaviconLoadedListener
;
import
org
.
mozilla
.
gecko
.
gfx
.
BitmapUtils
;
import
org
.
mozilla
.
gecko
.
gfx
.
LayerView
;
import
org
.
mozilla
.
gecko
.
gfx
.
PanZoomController
;
import
org
.
mozilla
.
gecko
.
mozglue
.
ContextUtils
;
import
org
.
mozilla
.
gecko
.
overlays
.
ui
.
ShareDialog
;
import
org
.
mozilla
.
gecko
.
permissions
.
Permissions
;
import
org
.
mozilla
.
gecko
.
prompts
.
PromptService
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoRequest
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareCodecCapabilityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
org
.
mozilla
.
gecko
.
util
.
NativeEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
NativeJSContainer
;
import
org
.
mozilla
.
gecko
.
util
.
NativeJSObject
;
import
org
.
mozilla
.
gecko
.
util
.
ProxySelector
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
widget
.
ExternalIntentDuringPrivateBrowsingPromptFragment
;
import
android
.
Manifest
;
import
android
.
annotation
.
TargetApi
;
import
android
.
app
.
Activity
;
import
android
.
app
.
ActivityManager
;
import
android
.
app
.
AlarmManager
;
import
android
.
app
.
PendingIntent
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
content
.
SharedPreferences
;
import
android
.
content
.
pm
.
ActivityInfo
;
import
android
.
content
.
pm
.
ApplicationInfo
;
import
android
.
content
.
pm
.
PackageInfo
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
;
import
android
.
content
.
pm
.
ResolveInfo
;
import
android
.
content
.
pm
.
ServiceInfo
;
import
android
.
content
.
pm
.
Signature
;
import
android
.
content
.
res
.
TypedArray
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Canvas
;
import
android
.
graphics
.
Color
;
import
android
.
graphics
.
ImageFormat
;
import
android
.
graphics
.
Paint
;
import
android
.
graphics
.
PixelFormat
;
import
android
.
graphics
.
Rect
;
import
android
.
graphics
.
RectF
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
graphics
.
drawable
.
BitmapDrawable
;
import
android
.
graphics
.
drawable
.
Drawable
;
import
android
.
hardware
.
display
.
DisplayManager
;
import
android
.
hardware
.
Sensor
;
import
android
.
hardware
.
SensorEventListener
;
import
android
.
hardware
.
SensorManager
;
import
android
.
location
.
Criteria
;
import
android
.
location
.
Location
;
import
android
.
location
.
LocationListener
;
import
android
.
location
.
LocationManager
;
import
android
.
net
.
ConnectivityManager
;
import
android
.
net
.
NetworkInfo
;
import
android
.
net
.
Uri
;
import
android
.
os
.
Build
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Environment
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
MessageQueue
;
import
android
.
os
.
SystemClock
;
import
android
.
os
.
Vibrator
;
import
android
.
provider
.
Browser
;
import
android
.
provider
.
Settings
;
import
android
.
support
.
design
.
widget
.
Snackbar
;
import
android
.
support
.
v4
.
app
.
FragmentActivity
;
import
android
.
telephony
.
TelephonyManager
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Base64
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
android
.
view
.
ContextThemeWrapper
;
import
android
.
view
.
Display
;
import
android
.
view
.
HapticFeedbackConstants
;
import
android
.
view
.
Surface
;
import
android
.
view
.
SurfaceView
;
import
android
.
view
.
TextureView
;
import
android
.
view
.
View
;
import
android
.
view
.
WindowManager
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
android
.
webkit
.
MimeTypeMap
;
import
android
.
webkit
.
URLUtil
;
import
android
.
widget
.
AbsoluteLayout
;
import
android
.
widget
.
Toast
;
public
class
GeckoAppShell
{
private
static
final
String
LOGTAG
=
"
GeckoAppShell
"
;
private
static
final
boolean
LOGGING
=
false
;
private
GeckoAppShell
(
)
{
}
private
static
final
CrashHandler
CRASH_HANDLER
=
new
CrashHandler
(
)
{
Override
protected
String
getAppPackageName
(
)
{
return
AppConstants
.
ANDROID_PACKAGE_NAME
;
}
Override
protected
Context
getAppContext
(
)
{
return
sContextGetter
!
=
null
?
getApplicationContext
(
)
:
null
;
}
Override
protected
Bundle
getCrashExtras
(
final
Thread
thread
final
Throwable
exc
)
{
final
Bundle
extras
=
super
.
getCrashExtras
(
thread
exc
)
;
extras
.
putString
(
"
ProductName
"
AppConstants
.
MOZ_APP_BASENAME
)
;
extras
.
putString
(
"
ProductID
"
AppConstants
.
MOZ_APP_ID
)
;
extras
.
putString
(
"
Version
"
AppConstants
.
MOZ_APP_VERSION
)
;
extras
.
putString
(
"
BuildID
"
AppConstants
.
MOZ_APP_BUILDID
)
;
extras
.
putString
(
"
Vendor
"
AppConstants
.
MOZ_APP_VENDOR
)
;
extras
.
putString
(
"
ReleaseChannel
"
AppConstants
.
MOZ_UPDATE_CHANNEL
)
;
return
extras
;
}
Override
public
void
uncaughtException
(
final
Thread
thread
final
Throwable
exc
)
{
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
EXITING
)
)
{
return
;
}
super
.
uncaughtException
(
thread
exc
)
;
}
Override
public
boolean
reportException
(
final
Thread
thread
final
Throwable
exc
)
{
try
{
if
(
exc
instanceof
OutOfMemoryError
)
{
SharedPreferences
prefs
=
getSharedPreferences
(
)
;
SharedPreferences
.
Editor
editor
=
prefs
.
edit
(
)
;
editor
.
putBoolean
(
GeckoApp
.
PREFS_OOM_EXCEPTION
true
)
;
editor
.
commit
(
)
;
}
reportJavaCrash
(
getExceptionStackTrace
(
exc
)
)
;
}
catch
(
final
Throwable
e
)
{
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
&
&
AppConstants
.
MOZILLA_OFFICIAL
)
{
return
super
.
reportException
(
thread
exc
)
;
}
return
false
;
}
}
;
public
static
CrashHandler
ensureCrashHandling
(
)
{
return
CRASH_HANDLER
;
}
private
static
final
Map
<
String
String
>
ALERT_COOKIES
=
new
ConcurrentHashMap
<
String
String
>
(
)
;
private
static
volatile
boolean
locationHighAccuracyEnabled
;
static
NotificationClient
notificationClient
;
private
static
final
int
HIGH_MEMORY_DEVICE_THRESHOLD_MB
=
768
;
static
private
int
sDensityDpi
;
static
private
int
sScreenDepth
;
private
static
final
float
[
]
DEFAULT_LAUNCHER_ICON_HSV
=
{
32
.
0f
1
.
0f
1
.
0f
}
;
private
static
boolean
sVibrationMaybePlaying
;
private
static
long
sVibrationEndTime
;
private
static
Sensor
gAccelerometerSensor
;
private
static
Sensor
gLinearAccelerometerSensor
;
private
static
Sensor
gGyroscopeSensor
;
private
static
Sensor
gOrientationSensor
;
private
static
Sensor
gProximitySensor
;
private
static
Sensor
gLightSensor
;
private
static
Sensor
gRotationVectorSensor
;
private
static
Sensor
gGameRotationVectorSensor
;
private
static
final
String
GECKOREQUEST_RESPONSE_KEY
=
"
response
"
;
private
static
final
String
GECKOREQUEST_ERROR_KEY
=
"
error
"
;
static
public
final
int
WPL_STATE_START
=
0x00000001
;
static
public
final
int
WPL_STATE_STOP
=
0x00000010
;
static
public
final
int
WPL_STATE_IS_DOCUMENT
=
0x00020000
;
static
public
final
int
WPL_STATE_IS_NETWORK
=
0x00040000
;
static
public
final
int
LINK_TYPE_UNKNOWN
=
0
;
static
public
final
int
LINK_TYPE_ETHERNET
=
1
;
static
public
final
int
LINK_TYPE_USB
=
2
;
static
public
final
int
LINK_TYPE_WIFI
=
3
;
static
public
final
int
LINK_TYPE_WIMAX
=
4
;
static
public
final
int
LINK_TYPE_2G
=
5
;
static
public
final
int
LINK_TYPE_3G
=
6
;
static
public
final
int
LINK_TYPE_4G
=
7
;
public
static
native
void
registerJavaUiThread
(
)
;
public
static
void
callObserver
(
String
observerKey
String
topic
String
data
)
{
sendEventToGecko
(
GeckoEvent
.
createCallObserverEvent
(
observerKey
topic
data
)
)
;
}
public
static
void
removeObserver
(
String
observerKey
)
{
sendEventToGecko
(
GeckoEvent
.
createRemoveObserverEvent
(
observerKey
)
)
;
}
public
static
native
void
onSurfaceTextureFrameAvailable
(
Object
surfaceTexture
int
id
)
;
public
static
native
void
dispatchMemoryPressure
(
)
;
private
static
native
void
reportJavaCrash
(
String
stackTrace
)
;
public
static
void
notifyUriVisited
(
String
uri
)
{
sendEventToGecko
(
GeckoEvent
.
createVisitedEvent
(
uri
)
)
;
}
public
static
native
void
notifyBatteryChange
(
double
aLevel
boolean
aCharging
double
aRemainingTime
)
;
public
static
native
void
invalidateAndScheduleComposite
(
)
;
public
static
native
float
computeRenderIntegrity
(
)
;
public
static
native
SurfaceBits
getSurfaceBits
(
Surface
surface
)
;
public
static
native
void
addPresentationSurface
(
Surface
surface
)
;
public
static
native
void
removePresentationSurface
(
Surface
surface
)
;
public
static
native
void
onFullScreenPluginHidden
(
View
view
)
;
private
static
LayerView
sLayerView
;
public
static
void
setLayerView
(
LayerView
lv
)
{
if
(
sLayerView
=
=
lv
)
{
return
;
}
sLayerView
=
lv
;
}
RobocopTarget
public
static
LayerView
getLayerView
(
)
{
return
sLayerView
;
}
RobocopTarget
public
static
void
sendEventToGecko
(
GeckoEvent
e
)
{
if
(
e
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
e
cannot
be
null
.
"
)
;
}
if
(
GeckoThread
.
isRunning
(
)
)
{
notifyGeckoOfEvent
(
e
)
;
e
.
recycle
(
)
;
return
;
}
GeckoThread
.
addPendingEvent
(
e
)
;
}
RobocopTarget
public
static
void
sendRequestToGecko
(
final
GeckoRequest
request
)
{
final
String
responseMessage
=
"
Gecko
:
Request
"
+
request
.
getId
(
)
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
new
NativeEventListener
(
)
{
Override
public
void
handleMessage
(
String
event
NativeJSObject
message
EventCallback
callback
)
{
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
this
event
)
;
if
(
!
message
.
has
(
GECKOREQUEST_RESPONSE_KEY
)
)
{
request
.
onError
(
message
.
getObject
(
GECKOREQUEST_ERROR_KEY
)
)
;
return
;
}
request
.
onResponse
(
message
.
getObject
(
GECKOREQUEST_RESPONSE_KEY
)
)
;
}
}
responseMessage
)
;
sendEventToGecko
(
GeckoEvent
.
createBroadcastEvent
(
request
.
getName
(
)
request
.
getData
(
)
)
)
;
}
public
static
native
void
notifyGeckoOfEvent
(
GeckoEvent
event
)
;
public
static
native
void
notifyGeckoObservers
(
String
subject
String
data
)
;
WrapForJNI
(
allowMultithread
=
true
noThrow
=
true
)
public
static
String
handleUncaughtException
(
Throwable
e
)
{
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
final
Throwable
exc
=
CrashHandler
.
getRootException
(
e
)
;
final
StackTraceElement
[
]
stack
=
exc
.
getStackTrace
(
)
;
if
(
stack
.
length
>
=
1
&
&
stack
[
0
]
.
isNativeMethod
(
)
)
{
CrashHandler
.
logException
(
Thread
.
currentThread
(
)
exc
)
;
return
CrashHandler
.
getExceptionStackTrace
(
exc
)
;
}
}
CRASH_HANDLER
.
uncaughtException
(
null
e
)
;
return
null
;
}
private
static
final
Object
sEventAckLock
=
new
Object
(
)
;
private
static
boolean
sWaitingForEventAck
;
public
static
void
sendEventToGeckoSync
(
GeckoEvent
e
)
{
e
.
setAckNeeded
(
true
)
;
long
time
=
SystemClock
.
uptimeMillis
(
)
;
boolean
isUiThread
=
ThreadUtils
.
isOnUiThread
(
)
;
synchronized
(
sEventAckLock
)
{
if
(
sWaitingForEventAck
)
{
Log
.
e
(
LOGTAG
"
geckoEventSync
(
)
may
have
been
called
twice
concurrently
!
"
new
Exception
(
)
)
;
}
sendEventToGecko
(
e
)
;
sWaitingForEventAck
=
true
;
while
(
true
)
{
if
(
GeckoThread
.
isStateAtLeast
(
GeckoThread
.
State
.
EXITING
)
)
{
Log
.
d
(
LOGTAG
"
Skipping
Gecko
event
sync
during
exit
"
)
;
sWaitingForEventAck
=
false
;
return
;
}
try
{
sEventAckLock
.
wait
(
1000
)
;
}
catch
(
InterruptedException
ie
)
{
}
if
(
!
sWaitingForEventAck
)
{
break
;
}
long
waited
=
SystemClock
.
uptimeMillis
(
)
-
time
;
Log
.
d
(
LOGTAG
"
Gecko
event
sync
taking
too
long
:
"
+
waited
+
"
ms
"
)
;
}
}
}
WrapForJNI
public
static
void
acknowledgeEvent
(
)
{
synchronized
(
sEventAckLock
)
{
sWaitingForEventAck
=
false
;
sEventAckLock
.
notifyAll
(
)
;
}
}
private
static
final
Runnable
sCallbackRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
long
nextDelay
=
runUiThreadCallback
(
)
;
if
(
nextDelay
>
=
0
)
{
ThreadUtils
.
getUiHandler
(
)
.
postDelayed
(
this
nextDelay
)
;
}
}
}
;
private
static
native
long
runUiThreadCallback
(
)
;
WrapForJNI
(
allowMultithread
=
true
)
private
static
void
requestUiThreadCallback
(
long
delay
)
{
ThreadUtils
.
getUiHandler
(
)
.
postDelayed
(
sCallbackRunnable
delay
)
;
}
private
static
float
getLocationAccuracy
(
Location
location
)
{
float
radius
=
location
.
getAccuracy
(
)
;
return
(
location
.
hasAccuracy
(
)
&
&
radius
>
0
)
?
radius
:
1001
;
}
private
static
Location
getLastKnownLocation
(
LocationManager
lm
)
{
Location
lastKnownLocation
=
null
;
List
<
String
>
providers
=
lm
.
getAllProviders
(
)
;
for
(
String
provider
:
providers
)
{
Location
location
=
lm
.
getLastKnownLocation
(
provider
)
;
if
(
location
=
=
null
)
{
continue
;
}
if
(
lastKnownLocation
=
=
null
)
{
lastKnownLocation
=
location
;
continue
;
}
long
timeDiff
=
location
.
getTime
(
)
-
lastKnownLocation
.
getTime
(
)
;
if
(
timeDiff
>
0
|
|
(
timeDiff
=
=
0
&
&
getLocationAccuracy
(
location
)
<
getLocationAccuracy
(
lastKnownLocation
)
)
)
{
lastKnownLocation
=
location
;
}
}
return
lastKnownLocation
;
}
WrapForJNI
public
static
void
enableLocation
(
final
boolean
enable
)
{
Permissions
.
from
(
(
Activity
)
getContext
(
)
)
.
withPermissions
(
Manifest
.
permission
.
ACCESS_FINE_LOCATION
)
.
onUIThread
(
)
.
doNotPromptIf
(
!
enable
)
.
run
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
LocationManager
lm
=
getLocationManager
(
getApplicationContext
(
)
)
;
if
(
lm
=
=
null
)
{
return
;
}
if
(
enable
)
{
Location
lastKnownLocation
=
getLastKnownLocation
(
lm
)
;
if
(
lastKnownLocation
!
=
null
)
{
getGeckoInterface
(
)
.
getLocationListener
(
)
.
onLocationChanged
(
lastKnownLocation
)
;
}
Criteria
criteria
=
new
Criteria
(
)
;
criteria
.
setSpeedRequired
(
false
)
;
criteria
.
setBearingRequired
(
false
)
;
criteria
.
setAltitudeRequired
(
false
)
;
if
(
locationHighAccuracyEnabled
)
{
criteria
.
setAccuracy
(
Criteria
.
ACCURACY_FINE
)
;
criteria
.
setCostAllowed
(
true
)
;
criteria
.
setPowerRequirement
(
Criteria
.
POWER_HIGH
)
;
}
else
{
criteria
.
setAccuracy
(
Criteria
.
ACCURACY_COARSE
)
;
criteria
.
setCostAllowed
(
false
)
;
criteria
.
setPowerRequirement
(
Criteria
.
POWER_LOW
)
;
}
String
provider
=
lm
.
getBestProvider
(
criteria
true
)
;
if
(
provider
=
=
null
)
return
;
Looper
l
=
Looper
.
getMainLooper
(
)
;
lm
.
requestLocationUpdates
(
provider
100
(
float
)
.
5
getGeckoInterface
(
)
.
getLocationListener
(
)
l
)
;
}
else
{
lm
.
removeUpdates
(
getGeckoInterface
(
)
.
getLocationListener
(
)
)
;
}
}
}
)
;
}
private
static
LocationManager
getLocationManager
(
Context
context
)
{
try
{
return
(
LocationManager
)
context
.
getSystemService
(
Context
.
LOCATION_SERVICE
)
;
}
catch
(
NoSuchFieldError
e
)
{
Log
.
e
(
LOGTAG
"
LOCATION_SERVICE
not
found
?
!
"
e
)
;
return
null
;
}
}
WrapForJNI
public
static
void
enableLocationHighAccuracy
(
final
boolean
enable
)
{
locationHighAccuracyEnabled
=
enable
;
}
WrapForJNI
public
static
boolean
setAlarm
(
int
aSeconds
int
aNanoSeconds
)
{
AlarmManager
am
=
(
AlarmManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
ALARM_SERVICE
)
;
Intent
intent
=
new
Intent
(
getApplicationContext
(
)
AlarmReceiver
.
class
)
;
PendingIntent
pi
=
PendingIntent
.
getBroadcast
(
getApplicationContext
(
)
0
intent
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
long
time
=
(
(
long
)
aSeconds
*
1000
)
+
(
(
long
)
aNanoSeconds
/
1_000_000L
)
;
am
.
setExact
(
AlarmManager
.
RTC_WAKEUP
time
pi
)
;
return
true
;
}
WrapForJNI
public
static
void
disableAlarm
(
)
{
AlarmManager
am
=
(
AlarmManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
ALARM_SERVICE
)
;
Intent
intent
=
new
Intent
(
getApplicationContext
(
)
AlarmReceiver
.
class
)
;
PendingIntent
pi
=
PendingIntent
.
getBroadcast
(
getApplicationContext
(
)
0
intent
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
am
.
cancel
(
pi
)
;
}
WrapForJNI
public
static
void
enableSensor
(
int
aSensortype
)
{
GeckoInterface
gi
=
getGeckoInterface
(
)
;
if
(
gi
=
=
null
)
{
return
;
}
SensorManager
sm
=
(
SensorManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
SENSOR_SERVICE
)
;
switch
(
aSensortype
)
{
case
GeckoHalDefines
.
SENSOR_GAME_ROTATION_VECTOR
:
if
(
gGameRotationVectorSensor
=
=
null
)
{
gGameRotationVectorSensor
=
sm
.
getDefaultSensor
(
15
)
;
}
if
(
gGameRotationVectorSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gGameRotationVectorSensor
SensorManager
.
SENSOR_DELAY_FASTEST
)
;
}
if
(
gGameRotationVectorSensor
!
=
null
)
{
break
;
}
case
GeckoHalDefines
.
SENSOR_ROTATION_VECTOR
:
if
(
gRotationVectorSensor
=
=
null
)
{
gRotationVectorSensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_ROTATION_VECTOR
)
;
}
if
(
gRotationVectorSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gRotationVectorSensor
SensorManager
.
SENSOR_DELAY_FASTEST
)
;
}
if
(
gRotationVectorSensor
!
=
null
)
{
break
;
}
case
GeckoHalDefines
.
SENSOR_ORIENTATION
:
if
(
gOrientationSensor
=
=
null
)
{
gOrientationSensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_ORIENTATION
)
;
}
if
(
gOrientationSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gOrientationSensor
SensorManager
.
SENSOR_DELAY_FASTEST
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_ACCELERATION
:
if
(
gAccelerometerSensor
=
=
null
)
{
gAccelerometerSensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_ACCELEROMETER
)
;
}
if
(
gAccelerometerSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gAccelerometerSensor
SensorManager
.
SENSOR_DELAY_FASTEST
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_PROXIMITY
:
if
(
gProximitySensor
=
=
null
)
{
gProximitySensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_PROXIMITY
)
;
}
if
(
gProximitySensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gProximitySensor
SensorManager
.
SENSOR_DELAY_NORMAL
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_LIGHT
:
if
(
gLightSensor
=
=
null
)
{
gLightSensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_LIGHT
)
;
}
if
(
gLightSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gLightSensor
SensorManager
.
SENSOR_DELAY_NORMAL
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_LINEAR_ACCELERATION
:
if
(
gLinearAccelerometerSensor
=
=
null
)
{
gLinearAccelerometerSensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_LINEAR_ACCELERATION
)
;
}
if
(
gLinearAccelerometerSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gLinearAccelerometerSensor
SensorManager
.
SENSOR_DELAY_FASTEST
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_GYROSCOPE
:
if
(
gGyroscopeSensor
=
=
null
)
{
gGyroscopeSensor
=
sm
.
getDefaultSensor
(
Sensor
.
TYPE_GYROSCOPE
)
;
}
if
(
gGyroscopeSensor
!
=
null
)
{
sm
.
registerListener
(
gi
.
getSensorEventListener
(
)
gGyroscopeSensor
SensorManager
.
SENSOR_DELAY_FASTEST
)
;
}
break
;
default
:
Log
.
w
(
LOGTAG
"
Error
!
Can
'
t
enable
unknown
SENSOR
type
"
+
aSensortype
)
;
}
}
WrapForJNI
public
static
void
disableSensor
(
int
aSensortype
)
{
GeckoInterface
gi
=
getGeckoInterface
(
)
;
if
(
gi
=
=
null
)
return
;
SensorManager
sm
=
(
SensorManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
SENSOR_SERVICE
)
;
switch
(
aSensortype
)
{
case
GeckoHalDefines
.
SENSOR_GAME_ROTATION_VECTOR
:
if
(
gGameRotationVectorSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gGameRotationVectorSensor
)
;
break
;
}
case
GeckoHalDefines
.
SENSOR_ROTATION_VECTOR
:
if
(
gRotationVectorSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gRotationVectorSensor
)
;
break
;
}
case
GeckoHalDefines
.
SENSOR_ORIENTATION
:
if
(
gOrientationSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gOrientationSensor
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_ACCELERATION
:
if
(
gAccelerometerSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gAccelerometerSensor
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_PROXIMITY
:
if
(
gProximitySensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gProximitySensor
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_LIGHT
:
if
(
gLightSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gLightSensor
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_LINEAR_ACCELERATION
:
if
(
gLinearAccelerometerSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gLinearAccelerometerSensor
)
;
}
break
;
case
GeckoHalDefines
.
SENSOR_GYROSCOPE
:
if
(
gGyroscopeSensor
!
=
null
)
{
sm
.
unregisterListener
(
gi
.
getSensorEventListener
(
)
gGyroscopeSensor
)
;
}
break
;
default
:
Log
.
w
(
LOGTAG
"
Error
!
Can
'
t
disable
unknown
SENSOR
type
"
+
aSensortype
)
;
}
}
WrapForJNI
public
static
void
startMonitoringGamepad
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
AndroidGamepadManager
.
startup
(
)
;
}
}
)
;
}
WrapForJNI
public
static
void
stopMonitoringGamepad
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
AndroidGamepadManager
.
shutdown
(
)
;
}
}
)
;
}
WrapForJNI
public
static
void
gamepadAdded
(
final
int
device_id
final
int
service_id
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
AndroidGamepadManager
.
gamepadAdded
(
device_id
service_id
)
;
}
}
)
;
}
WrapForJNI
public
static
void
moveTaskToBack
(
)
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
getActivity
(
)
.
moveTaskToBack
(
true
)
;
}
WrapForJNI
static
void
scheduleRestart
(
)
{
getGeckoInterface
(
)
.
doRestart
(
)
;
}
WrapForJNI
public
static
void
createShortcut
(
final
String
aTitle
final
String
aURI
)
{
final
BrowserDB
db
=
GeckoProfile
.
get
(
getApplicationContext
(
)
)
.
getDB
(
)
;
final
ContentResolver
cr
=
getContext
(
)
.
getContentResolver
(
)
;
final
Map
<
String
Map
<
String
Object
>
>
metadata
=
db
.
getURLMetadata
(
)
.
getForURLs
(
cr
Collections
.
singletonList
(
aURI
)
Collections
.
singletonList
(
URLMetadataTable
.
TOUCH_ICON_COLUMN
)
)
;
final
Map
<
String
Object
>
row
=
metadata
.
get
(
aURI
)
;
String
touchIconURL
=
null
;
if
(
row
!
=
null
)
{
touchIconURL
=
(
String
)
row
.
get
(
URLMetadataTable
.
TOUCH_ICON_COLUMN
)
;
}
OnFaviconLoadedListener
listener
=
new
OnFaviconLoadedListener
(
)
{
Override
public
void
onFaviconLoaded
(
String
url
String
faviconURL
Bitmap
favicon
)
{
createShortcutWithBitmap
(
aTitle
url
favicon
)
;
}
}
;
if
(
touchIconURL
!
=
null
)
{
Favicons
.
getSizedFavicon
(
getApplicationContext
(
)
aURI
touchIconURL
Integer
.
MAX_VALUE
0
listener
)
;
}
else
{
Favicons
.
getPreferredSizeFaviconForPage
(
getApplicationContext
(
)
aURI
listener
)
;
}
}
private
static
void
createShortcutWithBitmap
(
final
String
aTitle
final
String
aURI
final
Bitmap
aBitmap
)
{
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
doCreateShortcut
(
aTitle
aURI
aBitmap
)
;
}
}
)
;
}
private
static
void
doCreateShortcut
(
final
String
aTitle
final
String
aURI
final
Bitmap
aIcon
)
{
Intent
shortcutIntent
=
new
Intent
(
)
;
shortcutIntent
.
setAction
(
GeckoApp
.
ACTION_HOMESCREEN_SHORTCUT
)
;
shortcutIntent
.
setData
(
Uri
.
parse
(
aURI
)
)
;
shortcutIntent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
Intent
intent
=
new
Intent
(
)
;
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_INTENT
shortcutIntent
)
;
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_ICON
getLauncherIcon
(
aIcon
)
)
;
if
(
aTitle
!
=
null
)
{
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_NAME
aTitle
)
;
}
else
{
intent
.
putExtra
(
Intent
.
EXTRA_SHORTCUT_NAME
aURI
)
;
}
intent
.
putExtra
(
"
duplicate
"
false
)
;
intent
.
setAction
(
"
com
.
android
.
launcher
.
action
.
INSTALL_SHORTCUT
"
)
;
getApplicationContext
(
)
.
sendBroadcast
(
intent
)
;
}
JNITarget
static
public
int
getPreferredIconSize
(
)
{
if
(
Versions
.
feature11Plus
)
{
ActivityManager
am
=
(
ActivityManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
ACTIVITY_SERVICE
)
;
return
am
.
getLauncherLargeIconSize
(
)
;
}
else
{
switch
(
getDpi
(
)
)
{
case
DisplayMetrics
.
DENSITY_MEDIUM
:
return
48
;
case
DisplayMetrics
.
DENSITY_XHIGH
:
return
96
;
case
DisplayMetrics
.
DENSITY_HIGH
:
default
:
return
72
;
}
}
}
static
private
Bitmap
getLauncherIcon
(
Bitmap
aSource
)
{
final
int
kOffset
=
6
;
final
int
kRadius
=
5
;
int
size
=
getPreferredIconSize
(
)
;
int
insetSize
=
aSource
!
=
null
?
size
*
2
/
3
:
size
;
Bitmap
bitmap
=
Bitmap
.
createBitmap
(
size
size
Bitmap
.
Config
.
ARGB_8888
)
;
Canvas
canvas
=
new
Canvas
(
bitmap
)
;
Paint
paint
=
new
Paint
(
)
;
if
(
aSource
=
=
null
)
{
paint
.
setColor
(
Color
.
HSVToColor
(
DEFAULT_LAUNCHER_ICON_HSV
)
)
;
canvas
.
drawRoundRect
(
new
RectF
(
kOffset
kOffset
size
-
kOffset
size
-
kOffset
)
kRadius
kRadius
paint
)
;
}
else
if
(
aSource
.
getWidth
(
)
>
=
insetSize
|
|
aSource
.
getHeight
(
)
>
=
insetSize
)
{
Rect
iconBounds
=
new
Rect
(
0
0
size
size
)
;
canvas
.
drawBitmap
(
aSource
null
iconBounds
null
)
;
return
bitmap
;
}
else
{
int
color
=
BitmapUtils
.
getDominantColor
(
aSource
)
;
paint
.
setColor
(
color
)
;
canvas
.
drawRoundRect
(
new
RectF
(
kOffset
kOffset
size
-
kOffset
size
-
kOffset
)
kRadius
kRadius
paint
)
;
paint
.
setColor
(
Color
.
argb
(
100
255
255
255
)
)
;
canvas
.
drawRoundRect
(
new
RectF
(
kOffset
kOffset
size
-
kOffset
size
-
kOffset
)
kRadius
kRadius
paint
)
;
}
Bitmap
overlay
=
BitmapUtils
.
decodeResource
(
getApplicationContext
(
)
R
.
drawable
.
home_bg
)
;
canvas
.
drawBitmap
(
overlay
null
new
Rect
(
0
0
size
size
)
null
)
;
if
(
aSource
=
=
null
)
aSource
=
BitmapUtils
.
decodeResource
(
getApplicationContext
(
)
R
.
drawable
.
home_star
)
;
int
sWidth
=
insetSize
/
2
;
int
sHeight
=
sWidth
;
int
halfSize
=
size
/
2
;
canvas
.
drawBitmap
(
aSource
null
new
Rect
(
halfSize
-
sWidth
halfSize
-
sHeight
halfSize
+
sWidth
halfSize
+
sHeight
)
null
)
;
return
bitmap
;
}
WrapForJNI
(
stubName
=
"
GetHandlersForMimeTypeWrapper
"
)
static
String
[
]
getHandlersForMimeType
(
String
aMimeType
String
aAction
)
{
Intent
intent
=
getIntentForActionString
(
aAction
)
;
if
(
aMimeType
!
=
null
&
&
aMimeType
.
length
(
)
>
0
)
intent
.
setType
(
aMimeType
)
;
return
getHandlersForIntent
(
intent
)
;
}
WrapForJNI
(
stubName
=
"
GetHandlersForURLWrapper
"
)
static
String
[
]
getHandlersForURL
(
String
aURL
String
aAction
)
{
Uri
uri
=
aURL
.
indexOf
(
'
:
'
)
>
=
0
?
Uri
.
parse
(
aURL
)
:
new
Uri
.
Builder
(
)
.
scheme
(
aURL
)
.
build
(
)
;
Intent
intent
=
getOpenURIIntent
(
getApplicationContext
(
)
uri
.
toString
(
)
"
"
TextUtils
.
isEmpty
(
aAction
)
?
Intent
.
ACTION_VIEW
:
aAction
"
"
)
;
return
getHandlersForIntent
(
intent
)
;
}
WrapForJNI
(
stubName
=
"
GetHWEncoderCapability
"
)
static
boolean
getHWEncoderCapability
(
)
{
return
HardwareCodecCapabilityUtils
.
getHWEncoderCapability
(
)
;
}
WrapForJNI
(
stubName
=
"
GetHWDecoderCapability
"
)
static
boolean
getHWDecoderCapability
(
)
{
return
HardwareCodecCapabilityUtils
.
getHWDecoderCapability
(
)
;
}
static
List
<
ResolveInfo
>
queryIntentActivities
(
Intent
intent
)
{
final
PackageManager
pm
=
getApplicationContext
(
)
.
getPackageManager
(
)
;
final
ArrayList
<
ResolveInfo
>
list
=
new
ArrayList
<
>
(
)
;
for
(
ResolveInfo
ri
:
pm
.
queryIntentActivities
(
intent
0
)
)
{
if
(
ri
.
activityInfo
.
exported
)
{
list
.
add
(
ri
)
;
}
}
return
list
;
}
static
boolean
hasHandlersForIntent
(
Intent
intent
)
{
try
{
return
!
queryIntentActivities
(
intent
)
.
isEmpty
(
)
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
in
GeckoAppShell
.
hasHandlersForIntent
"
)
;
return
false
;
}
}
static
String
[
]
getHandlersForIntent
(
Intent
intent
)
{
final
PackageManager
pm
=
getApplicationContext
(
)
.
getPackageManager
(
)
;
try
{
final
List
<
ResolveInfo
>
list
=
queryIntentActivities
(
intent
)
;
int
numAttr
=
4
;
final
String
[
]
ret
=
new
String
[
list
.
size
(
)
*
numAttr
]
;
for
(
int
i
=
0
;
i
<
list
.
size
(
)
;
i
+
+
)
{
ResolveInfo
resolveInfo
=
list
.
get
(
i
)
;
ret
[
i
*
numAttr
]
=
resolveInfo
.
loadLabel
(
pm
)
.
toString
(
)
;
if
(
resolveInfo
.
isDefault
)
ret
[
i
*
numAttr
+
1
]
=
"
default
"
;
else
ret
[
i
*
numAttr
+
1
]
=
"
"
;
ret
[
i
*
numAttr
+
2
]
=
resolveInfo
.
activityInfo
.
applicationInfo
.
packageName
;
ret
[
i
*
numAttr
+
3
]
=
resolveInfo
.
activityInfo
.
name
;
}
return
ret
;
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
Exception
in
GeckoAppShell
.
getHandlersForIntent
"
)
;
return
new
String
[
0
]
;
}
}
static
Intent
getIntentForActionString
(
String
aAction
)
{
if
(
TextUtils
.
isEmpty
(
aAction
)
)
{
return
new
Intent
(
Intent
.
ACTION_VIEW
)
;
}
return
new
Intent
(
aAction
)
;
}
WrapForJNI
(
stubName
=
"
GetExtensionFromMimeTypeWrapper
"
)
static
String
getExtensionFromMimeType
(
String
aMimeType
)
{
return
MimeTypeMap
.
getSingleton
(
)
.
getExtensionFromMimeType
(
aMimeType
)
;
}
WrapForJNI
(
stubName
=
"
GetMimeTypeFromExtensionsWrapper
"
)
static
String
getMimeTypeFromExtensions
(
String
aFileExt
)
{
StringTokenizer
st
=
new
StringTokenizer
(
aFileExt
"
.
;
"
)
;
String
type
=
null
;
String
subType
=
null
;
while
(
st
.
hasMoreElements
(
)
)
{
String
ext
=
st
.
nextToken
(
)
;
String
mt
=
getMimeTypeFromExtension
(
ext
)
;
if
(
mt
=
=
null
)
continue
;
int
slash
=
mt
.
indexOf
(
'
/
'
)
;
String
tmpType
=
mt
.
substring
(
0
slash
)
;
if
(
!
tmpType
.
equalsIgnoreCase
(
type
)
)
type
=
type
=
=
null
?
tmpType
:
"
*
"
;
String
tmpSubType
=
mt
.
substring
(
slash
+
1
)
;
if
(
!
tmpSubType
.
equalsIgnoreCase
(
subType
)
)
subType
=
subType
=
=
null
?
tmpSubType
:
"
*
"
;
}
if
(
type
=
=
null
)
type
=
"
*
"
;
if
(
subType
=
=
null
)
subType
=
"
*
"
;
return
type
+
"
/
"
+
subType
;
}
static
boolean
isUriSafeForScheme
(
Uri
aUri
)
{
final
String
scheme
=
aUri
.
getScheme
(
)
;
if
(
"
tel
"
.
equals
(
scheme
)
|
|
"
sms
"
.
equals
(
scheme
)
)
{
final
String
number
=
aUri
.
getSchemeSpecificPart
(
)
;
if
(
number
.
contains
(
"
#
"
)
|
|
number
.
contains
(
"
*
"
)
|
|
aUri
.
getFragment
(
)
!
=
null
)
{
return
false
;
}
}
return
true
;
}
WrapForJNI
public
static
boolean
openUriExternal
(
String
targetURI
String
mimeType
String
packageName
String
className
String
action
String
title
)
{
return
openUriExternal
(
targetURI
mimeType
packageName
className
action
title
true
)
;
}
public
static
boolean
openUriExternal
(
String
targetURI
String
mimeType
String
packageName
String
className
String
action
String
title
final
boolean
showPromptInPrivateBrowsing
)
{
final
GeckoInterface
gi
=
getGeckoInterface
(
)
;
final
Context
activityContext
=
gi
!
=
null
?
gi
.
getActivity
(
)
:
null
;
final
Context
context
=
activityContext
!
=
null
?
activityContext
:
getApplicationContext
(
)
;
final
Intent
intent
=
getOpenURIIntent
(
context
targetURI
mimeType
action
title
)
;
if
(
intent
=
=
null
)
{
return
false
;
}
if
(
!
TextUtils
.
isEmpty
(
className
)
)
{
if
(
!
TextUtils
.
isEmpty
(
packageName
)
)
{
intent
.
setClassName
(
packageName
className
)
;
}
else
{
intent
.
setClassName
(
context
className
)
;
}
}
if
(
!
showPromptInPrivateBrowsing
|
|
activityContext
=
=
null
)
{
if
(
activityContext
=
=
null
)
{
intent
.
addFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
}
return
ActivityHandlerHelper
.
startIntentAndCatch
(
LOGTAG
context
intent
)
;
}
else
{
final
FragmentActivity
fragmentActivity
=
(
FragmentActivity
)
activityContext
;
return
ExternalIntentDuringPrivateBrowsingPromptFragment
.
showDialogOrAndroidChooser
(
context
fragmentActivity
.
getSupportFragmentManager
(
)
intent
)
;
}
}
static
Uri
normalizeUriScheme
(
final
Uri
u
)
{
final
String
scheme
=
u
.
getScheme
(
)
;
final
String
lower
=
scheme
.
toLowerCase
(
Locale
.
US
)
;
if
(
lower
.
equals
(
scheme
)
)
{
return
u
;
}
return
u
.
buildUpon
(
)
.
scheme
(
lower
)
.
build
(
)
;
}
public
static
Intent
getShareIntent
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
title
)
{
Intent
shareIntent
=
getIntentForActionString
(
Intent
.
ACTION_SEND
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TEXT
targetURI
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_SUBJECT
title
)
;
shareIntent
.
putExtra
(
ShareDialog
.
INTENT_EXTRA_DEVICES_ONLY
true
)
;
shareIntent
.
putExtra
(
Intent
.
EXTRA_TITLE
title
)
;
if
(
mimeType
!
=
null
&
&
mimeType
.
length
(
)
>
0
)
{
shareIntent
.
setType
(
mimeType
)
;
}
return
shareIntent
;
}
static
Intent
getOpenURIIntent
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
action
final
String
title
)
{
final
Intent
intent
=
getOpenURIIntentInner
(
context
targetURI
mimeType
action
title
)
;
if
(
intent
!
=
null
)
{
intent
.
putExtra
(
Browser
.
EXTRA_APPLICATION_ID
AppConstants
.
ANDROID_PACKAGE_NAME
)
;
}
return
intent
;
}
private
static
Intent
getOpenURIIntentInner
(
final
Context
context
final
String
targetURI
final
String
mimeType
final
String
action
final
String
title
)
{
if
(
action
.
equalsIgnoreCase
(
Intent
.
ACTION_SEND
)
)
{
Intent
shareIntent
=
getShareIntent
(
context
targetURI
mimeType
title
)
;
return
Intent
.
createChooser
(
shareIntent
context
.
getResources
(
)
.
getString
(
R
.
string
.
share_title
)
)
;
}
Uri
uri
=
normalizeUriScheme
(
targetURI
.
indexOf
(
'
:
'
)
>
=
0
?
Uri
.
parse
(
targetURI
)
:
new
Uri
.
Builder
(
)
.
scheme
(
targetURI
)
.
build
(
)
)
;
if
(
!
TextUtils
.
isEmpty
(
mimeType
)
)
{
Intent
intent
=
getIntentForActionString
(
action
)
;
intent
.
setDataAndType
(
uri
mimeType
)
;
return
intent
;
}
if
(
!
isUriSafeForScheme
(
uri
)
)
{
return
null
;
}
final
String
scheme
=
uri
.
getScheme
(
)
;
if
(
"
intent
"
.
equals
(
scheme
)
|
|
"
android
-
app
"
.
equals
(
scheme
)
)
{
final
Intent
intent
;
try
{
intent
=
Intent
.
parseUri
(
targetURI
0
)
;
}
catch
(
final
URISyntaxException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
parse
URI
-
"
+
e
)
;
return
null
;
}
intent
.
addCategory
(
Intent
.
CATEGORY_BROWSABLE
)
;
intent
.
setComponent
(
null
)
;
nullIntentSelector
(
intent
)
;
return
intent
;
}
final
String
extension
=
MimeTypeMap
.
getFileExtensionFromUrl
(
targetURI
)
;
final
Intent
intent
=
getIntentForActionString
(
action
)
;
intent
.
setData
(
uri
)
;
if
(
"
file
"
.
equals
(
scheme
)
)
{
final
String
mimeType2
=
getMimeTypeFromExtension
(
extension
)
;
intent
.
setType
(
mimeType2
)
;
return
intent
;
}
if
(
!
"
sms
"
.
equals
(
scheme
)
&
&
!
"
smsto
"
.
equals
(
scheme
)
&
&
!
"
mms
"
.
equals
(
scheme
)
&
&
!
"
mmsto
"
.
equals
(
scheme
)
)
{
return
intent
;
}
final
String
query
=
uri
.
getEncodedQuery
(
)
;
if
(
TextUtils
.
isEmpty
(
query
)
)
{
return
intent
;
}
String
currentUri
=
uri
.
toString
(
)
;
String
correctlyFormattedDataURIScheme
=
scheme
+
"
:
/
/
"
;
if
(
!
currentUri
.
contains
(
correctlyFormattedDataURIScheme
)
)
{
uri
=
Uri
.
parse
(
currentUri
.
replaceFirst
(
scheme
+
"
:
"
correctlyFormattedDataURIScheme
)
)
;
}
final
String
[
]
fields
=
query
.
split
(
"
&
"
)
;
boolean
shouldUpdateIntent
=
false
;
String
resultQuery
=
"
"
;
for
(
String
field
:
fields
)
{
if
(
field
.
startsWith
(
"
body
=
"
)
)
{
final
String
body
=
Uri
.
decode
(
field
.
substring
(
5
)
)
;
intent
.
putExtra
(
"
sms_body
"
body
)
;
shouldUpdateIntent
=
true
;
}
else
if
(
field
.
startsWith
(
"
subject
=
"
)
)
{
final
String
subject
=
Uri
.
decode
(
field
.
substring
(
8
)
)
;
intent
.
putExtra
(
"
subject
"
subject
)
;
shouldUpdateIntent
=
true
;
}
else
if
(
field
.
startsWith
(
"
cc
=
"
)
)
{
final
String
ccNumber
=
Uri
.
decode
(
field
.
substring
(
3
)
)
;
String
phoneNumber
=
uri
.
getAuthority
(
)
;
if
(
phoneNumber
!
=
null
)
{
uri
=
uri
.
buildUpon
(
)
.
encodedAuthority
(
phoneNumber
+
"
;
"
+
ccNumber
)
.
build
(
)
;
}
shouldUpdateIntent
=
true
;
}
else
{
resultQuery
=
resultQuery
.
concat
(
resultQuery
.
length
(
)
>
0
?
"
&
"
+
field
:
field
)
;
}
}
if
(
!
shouldUpdateIntent
)
{
return
intent
;
}
final
String
newQuery
=
resultQuery
.
length
(
)
>
0
?
"
?
"
+
resultQuery
:
"
"
;
final
Uri
pruned
=
uri
.
buildUpon
(
)
.
encodedQuery
(
newQuery
)
.
build
(
)
;
intent
.
setData
(
pruned
)
;
return
intent
;
}
TargetApi
(
15
)
private
static
void
nullIntentSelector
(
final
Intent
intent
)
{
if
(
!
Versions
.
feature15Plus
)
{
return
;
}
intent
.
setSelector
(
null
)
;
}
public
static
void
setNotificationClient
(
NotificationClient
client
)
{
if
(
notificationClient
=
=
null
)
{
notificationClient
=
client
;
}
else
{
Log
.
d
(
LOGTAG
"
Notification
client
already
set
"
)
;
}
}
WrapForJNI
(
stubName
=
"
ShowAlertNotificationWrapper
"
)
public
static
void
showAlertNotification
(
String
aImageUrl
String
aAlertTitle
String
aAlertText
String
aAlertCookie
String
aAlertName
String
aHost
)
{
Intent
notificationIntent
=
new
Intent
(
GeckoApp
.
ACTION_ALERT_CALLBACK
)
;
notificationIntent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
notificationIntent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
int
notificationID
=
aAlertName
.
hashCode
(
)
;
Uri
.
Builder
b
=
new
Uri
.
Builder
(
)
;
Uri
dataUri
=
b
.
scheme
(
"
alert
"
)
.
path
(
Integer
.
toString
(
notificationID
)
)
.
appendQueryParameter
(
"
name
"
aAlertName
)
.
appendQueryParameter
(
"
cookie
"
aAlertCookie
)
.
build
(
)
;
notificationIntent
.
setData
(
dataUri
)
;
PendingIntent
contentIntent
=
PendingIntent
.
getActivity
(
getContext
(
)
0
notificationIntent
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
ALERT_COOKIES
.
put
(
aAlertName
aAlertCookie
)
;
callObserver
(
aAlertName
"
alertshow
"
aAlertCookie
)
;
notificationClient
.
add
(
notificationID
aImageUrl
aHost
aAlertTitle
aAlertText
contentIntent
)
;
}
WrapForJNI
public
static
void
alertsProgressListener_OnProgress
(
String
aAlertName
long
aProgress
long
aProgressMax
String
aAlertText
)
{
int
notificationID
=
aAlertName
.
hashCode
(
)
;
notificationClient
.
update
(
notificationID
aProgress
aProgressMax
aAlertText
)
;
}
WrapForJNI
public
static
void
closeNotification
(
String
aAlertName
)
{
String
alertCookie
=
ALERT_COOKIES
.
get
(
aAlertName
)
;
if
(
alertCookie
!
=
null
)
{
callObserver
(
aAlertName
"
alertfinished
"
alertCookie
)
;
ALERT_COOKIES
.
remove
(
aAlertName
)
;
}
removeObserver
(
aAlertName
)
;
int
notificationID
=
aAlertName
.
hashCode
(
)
;
notificationClient
.
remove
(
notificationID
)
;
}
public
static
void
handleNotification
(
String
aAction
String
aAlertName
String
aAlertCookie
)
{
int
notificationID
=
aAlertName
.
hashCode
(
)
;
if
(
GeckoApp
.
ACTION_ALERT_CALLBACK
.
equals
(
aAction
)
)
{
callObserver
(
aAlertName
"
alertclickcallback
"
aAlertCookie
)
;
if
(
notificationClient
.
isOngoing
(
notificationID
)
)
{
return
;
}
}
closeNotification
(
aAlertName
)
;
}
WrapForJNI
(
stubName
=
"
GetDpiWrapper
"
)
public
static
int
getDpi
(
)
{
if
(
sDensityDpi
=
=
0
)
{
sDensityDpi
=
getApplicationContext
(
)
.
getResources
(
)
.
getDisplayMetrics
(
)
.
densityDpi
;
}
return
sDensityDpi
;
}
WrapForJNI
public
static
float
getDensity
(
)
{
return
getApplicationContext
(
)
.
getResources
(
)
.
getDisplayMetrics
(
)
.
density
;
}
private
static
boolean
isHighMemoryDevice
(
)
{
return
HardwareUtils
.
getMemSize
(
)
>
HIGH_MEMORY_DEVICE_THRESHOLD_MB
;
}
WrapForJNI
(
stubName
=
"
GetScreenDepthWrapper
"
)
public
static
synchronized
int
getScreenDepth
(
)
{
if
(
sScreenDepth
=
=
0
)
{
sScreenDepth
=
16
;
PixelFormat
info
=
new
PixelFormat
(
)
;
final
WindowManager
wm
=
(
WindowManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
WINDOW_SERVICE
)
;
PixelFormat
.
getPixelFormatInfo
(
wm
.
getDefaultDisplay
(
)
.
getPixelFormat
(
)
info
)
;
if
(
info
.
bitsPerPixel
>
=
24
&
&
isHighMemoryDevice
(
)
)
{
sScreenDepth
=
24
;
}
}
return
sScreenDepth
;
}
WrapForJNI
public
static
synchronized
void
setScreenDepthOverride
(
int
aScreenDepth
)
{
if
(
sScreenDepth
!
=
0
)
{
Log
.
e
(
LOGTAG
"
Tried
to
override
screen
depth
after
it
'
s
already
been
set
"
)
;
return
;
}
sScreenDepth
=
aScreenDepth
;
}
WrapForJNI
public
static
void
setFullScreen
(
boolean
fullscreen
)
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
setFullScreen
(
fullscreen
)
;
}
WrapForJNI
public
static
void
performHapticFeedback
(
boolean
aIsLongPress
)
{
if
(
!
sVibrationMaybePlaying
|
|
System
.
nanoTime
(
)
>
=
sVibrationEndTime
)
{
LayerView
layerView
=
getLayerView
(
)
;
layerView
.
performHapticFeedback
(
aIsLongPress
?
HapticFeedbackConstants
.
LONG_PRESS
:
HapticFeedbackConstants
.
VIRTUAL_KEY
)
;
}
}
private
static
Vibrator
vibrator
(
)
{
return
(
Vibrator
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
VIBRATOR_SERVICE
)
;
}
private
static
long
[
]
convertIntToLongArray
(
int
[
]
input
)
{
long
[
]
output
=
new
long
[
input
.
length
]
;
for
(
int
i
=
0
;
i
<
input
.
length
;
i
+
+
)
{
output
[
i
]
=
input
[
i
]
;
}
return
output
;
}
public
static
void
vibrateOnHapticFeedbackEnabled
(
int
[
]
milliseconds
)
{
if
(
Settings
.
System
.
getInt
(
getApplicationContext
(
)
.
getContentResolver
(
)
Settings
.
System
.
HAPTIC_FEEDBACK_ENABLED
0
)
>
0
)
{
vibrate
(
convertIntToLongArray
(
milliseconds
)
-
1
)
;
}
}
WrapForJNI
(
stubName
=
"
Vibrate1
"
)
public
static
void
vibrate
(
long
milliseconds
)
{
sVibrationEndTime
=
System
.
nanoTime
(
)
+
milliseconds
*
1000000
;
sVibrationMaybePlaying
=
true
;
vibrator
(
)
.
vibrate
(
milliseconds
)
;
}
WrapForJNI
(
stubName
=
"
VibrateA
"
)
public
static
void
vibrate
(
long
[
]
pattern
int
repeat
)
{
long
vibrationDuration
=
0
;
int
iterLen
=
pattern
.
length
-
(
pattern
.
length
%
2
=
=
0
?
1
:
0
)
;
for
(
int
i
=
0
;
i
<
iterLen
;
i
+
+
)
{
vibrationDuration
+
=
pattern
[
i
]
;
}
sVibrationEndTime
=
System
.
nanoTime
(
)
+
vibrationDuration
*
1000000
;
sVibrationMaybePlaying
=
true
;
vibrator
(
)
.
vibrate
(
pattern
repeat
)
;
}
WrapForJNI
public
static
void
cancelVibrate
(
)
{
sVibrationMaybePlaying
=
false
;
sVibrationEndTime
=
0
;
vibrator
(
)
.
cancel
(
)
;
}
WrapForJNI
public
static
void
showInputMethodPicker
(
)
{
InputMethodManager
imm
=
(
InputMethodManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
;
imm
.
showInputMethodPicker
(
)
;
}
WrapForJNI
public
static
void
setKeepScreenOn
(
final
boolean
on
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
}
}
)
;
}
WrapForJNI
public
static
void
notifyDefaultPrevented
(
final
boolean
defaultPrevented
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
LayerView
view
=
getLayerView
(
)
;
PanZoomController
controller
=
(
view
=
=
null
?
null
:
view
.
getPanZoomController
(
)
)
;
if
(
controller
!
=
null
)
{
controller
.
notifyDefaultActionPrevented
(
defaultPrevented
)
;
}
}
}
)
;
}
WrapForJNI
public
static
boolean
isNetworkLinkUp
(
)
{
ConnectivityManager
cm
=
(
ConnectivityManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
;
try
{
NetworkInfo
info
=
cm
.
getActiveNetworkInfo
(
)
;
if
(
info
=
=
null
|
|
!
info
.
isConnected
(
)
)
return
false
;
}
catch
(
SecurityException
se
)
{
return
false
;
}
return
true
;
}
WrapForJNI
public
static
boolean
isNetworkLinkKnown
(
)
{
ConnectivityManager
cm
=
(
ConnectivityManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
;
try
{
if
(
cm
.
getActiveNetworkInfo
(
)
=
=
null
)
return
false
;
}
catch
(
SecurityException
se
)
{
return
false
;
}
return
true
;
}
WrapForJNI
public
static
int
networkLinkType
(
)
{
ConnectivityManager
cm
=
(
ConnectivityManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
CONNECTIVITY_SERVICE
)
;
NetworkInfo
info
=
cm
.
getActiveNetworkInfo
(
)
;
if
(
info
=
=
null
)
{
return
LINK_TYPE_UNKNOWN
;
}
switch
(
info
.
getType
(
)
)
{
case
ConnectivityManager
.
TYPE_ETHERNET
:
return
LINK_TYPE_ETHERNET
;
case
ConnectivityManager
.
TYPE_WIFI
:
return
LINK_TYPE_WIFI
;
case
ConnectivityManager
.
TYPE_WIMAX
:
return
LINK_TYPE_WIMAX
;
case
ConnectivityManager
.
TYPE_MOBILE
:
break
;
default
:
Log
.
w
(
LOGTAG
"
Ignoring
the
current
network
type
.
"
)
;
return
LINK_TYPE_UNKNOWN
;
}
TelephonyManager
tm
=
(
TelephonyManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
TELEPHONY_SERVICE
)
;
if
(
tm
=
=
null
)
{
Log
.
e
(
LOGTAG
"
Telephony
service
does
not
exist
"
)
;
return
LINK_TYPE_UNKNOWN
;
}
switch
(
tm
.
getNetworkType
(
)
)
{
case
TelephonyManager
.
NETWORK_TYPE_IDEN
:
case
TelephonyManager
.
NETWORK_TYPE_CDMA
:
case
TelephonyManager
.
NETWORK_TYPE_GPRS
:
return
LINK_TYPE_2G
;
case
TelephonyManager
.
NETWORK_TYPE_1xRTT
:
case
TelephonyManager
.
NETWORK_TYPE_EDGE
:
return
LINK_TYPE_2G
;
case
TelephonyManager
.
NETWORK_TYPE_UMTS
:
case
TelephonyManager
.
NETWORK_TYPE_EVDO_0
:
return
LINK_TYPE_3G
;
case
TelephonyManager
.
NETWORK_TYPE_HSPA
:
case
TelephonyManager
.
NETWORK_TYPE_HSDPA
:
case
TelephonyManager
.
NETWORK_TYPE_HSUPA
:
case
TelephonyManager
.
NETWORK_TYPE_EVDO_A
:
case
TelephonyManager
.
NETWORK_TYPE_EVDO_B
:
case
TelephonyManager
.
NETWORK_TYPE_EHRPD
:
return
LINK_TYPE_3G
;
case
TelephonyManager
.
NETWORK_TYPE_HSPAP
:
return
LINK_TYPE_3G
;
case
TelephonyManager
.
NETWORK_TYPE_LTE
:
return
LINK_TYPE_4G
;
case
TelephonyManager
.
NETWORK_TYPE_UNKNOWN
:
default
:
Log
.
w
(
LOGTAG
"
Connected
to
an
unknown
mobile
network
!
"
)
;
return
LINK_TYPE_UNKNOWN
;
}
}
WrapForJNI
(
stubName
=
"
GetSystemColoursWrapper
"
)
public
static
int
[
]
getSystemColors
(
)
{
final
int
[
]
attrsAppearance
=
{
android
.
R
.
attr
.
textColor
android
.
R
.
attr
.
textColorPrimary
android
.
R
.
attr
.
textColorPrimaryInverse
android
.
R
.
attr
.
textColorSecondary
android
.
R
.
attr
.
textColorSecondaryInverse
android
.
R
.
attr
.
textColorTertiary
android
.
R
.
attr
.
textColorTertiaryInverse
android
.
R
.
attr
.
textColorHighlight
android
.
R
.
attr
.
colorForeground
android
.
R
.
attr
.
colorBackground
android
.
R
.
attr
.
panelColorForeground
android
.
R
.
attr
.
panelColorBackground
}
;
int
[
]
result
=
new
int
[
attrsAppearance
.
length
]
;
final
ContextThemeWrapper
contextThemeWrapper
=
new
ContextThemeWrapper
(
getApplicationContext
(
)
android
.
R
.
style
.
TextAppearance
)
;
final
TypedArray
appearance
=
contextThemeWrapper
.
getTheme
(
)
.
obtainStyledAttributes
(
attrsAppearance
)
;
if
(
appearance
!
=
null
)
{
for
(
int
i
=
0
;
i
<
appearance
.
getIndexCount
(
)
;
i
+
+
)
{
int
idx
=
appearance
.
getIndex
(
i
)
;
int
color
=
appearance
.
getColor
(
idx
0
)
;
result
[
idx
]
=
color
;
}
appearance
.
recycle
(
)
;
}
return
result
;
}
WrapForJNI
public
static
void
killAnyZombies
(
)
{
GeckoProcessesVisitor
visitor
=
new
GeckoProcessesVisitor
(
)
{
Override
public
boolean
callback
(
int
pid
)
{
if
(
pid
!
=
android
.
os
.
Process
.
myPid
(
)
)
android
.
os
.
Process
.
killProcess
(
pid
)
;
return
true
;
}
}
;
EnumerateGeckoProcesses
(
visitor
)
;
}
interface
GeckoProcessesVisitor
{
boolean
callback
(
int
pid
)
;
}
private
static
void
EnumerateGeckoProcesses
(
GeckoProcessesVisitor
visiter
)
{
int
pidColumn
=
-
1
;
int
userColumn
=
-
1
;
try
{
java
.
lang
.
Process
ps
=
Runtime
.
getRuntime
(
)
.
exec
(
"
ps
"
)
;
BufferedReader
in
=
new
BufferedReader
(
new
InputStreamReader
(
ps
.
getInputStream
(
)
)
2048
)
;
String
headerOutput
=
in
.
readLine
(
)
;
StringTokenizer
st
=
new
StringTokenizer
(
headerOutput
)
;
int
tokenSoFar
=
0
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
next
=
st
.
nextToken
(
)
;
if
(
next
.
equalsIgnoreCase
(
"
PID
"
)
)
pidColumn
=
tokenSoFar
;
else
if
(
next
.
equalsIgnoreCase
(
"
USER
"
)
)
userColumn
=
tokenSoFar
;
tokenSoFar
+
+
;
}
String
psOutput
=
null
;
while
(
(
psOutput
=
in
.
readLine
(
)
)
!
=
null
)
{
String
[
]
split
=
psOutput
.
split
(
"
\
\
s
+
"
)
;
if
(
split
.
length
<
=
pidColumn
|
|
split
.
length
<
=
userColumn
)
continue
;
int
uid
=
android
.
os
.
Process
.
getUidForName
(
split
[
userColumn
]
)
;
if
(
uid
=
=
android
.
os
.
Process
.
myUid
(
)
&
&
!
split
[
split
.
length
-
1
]
.
equalsIgnoreCase
(
"
ps
"
)
)
{
int
pid
=
Integer
.
parseInt
(
split
[
pidColumn
]
)
;
boolean
keepGoing
=
visiter
.
callback
(
pid
)
;
if
(
keepGoing
=
=
false
)
break
;
}
}
in
.
close
(
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Failed
to
enumerate
Gecko
processes
.
"
e
)
;
}
}
public
static
String
getAppNameByPID
(
int
pid
)
{
BufferedReader
cmdlineReader
=
null
;
String
path
=
"
/
proc
/
"
+
pid
+
"
/
cmdline
"
;
try
{
File
cmdlineFile
=
new
File
(
path
)
;
if
(
!
cmdlineFile
.
exists
(
)
)
return
"
"
;
cmdlineReader
=
new
BufferedReader
(
new
FileReader
(
cmdlineFile
)
)
;
return
cmdlineReader
.
readLine
(
)
.
trim
(
)
;
}
catch
(
Exception
ex
)
{
return
"
"
;
}
finally
{
if
(
null
!
=
cmdlineReader
)
{
try
{
cmdlineReader
.
close
(
)
;
}
catch
(
Exception
e
)
{
}
}
}
}
public
static
void
listOfOpenFiles
(
)
{
int
pidColumn
=
-
1
;
int
nameColumn
=
-
1
;
try
{
String
filter
=
GeckoProfile
.
get
(
getApplicationContext
(
)
)
.
getDir
(
)
.
toString
(
)
;
Log
.
d
(
LOGTAG
"
[
OPENFILE
]
Filter
:
"
+
filter
)
;
java
.
lang
.
Process
lsof
=
Runtime
.
getRuntime
(
)
.
exec
(
"
lsof
"
)
;
BufferedReader
in
=
new
BufferedReader
(
new
InputStreamReader
(
lsof
.
getInputStream
(
)
)
2048
)
;
String
headerOutput
=
in
.
readLine
(
)
;
StringTokenizer
st
=
new
StringTokenizer
(
headerOutput
)
;
int
token
=
0
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
next
=
st
.
nextToken
(
)
;
if
(
next
.
equalsIgnoreCase
(
"
PID
"
)
)
pidColumn
=
token
;
else
if
(
next
.
equalsIgnoreCase
(
"
NAME
"
)
)
nameColumn
=
token
;
token
+
+
;
}
Map
<
Integer
String
>
pidNameMap
=
new
TreeMap
<
Integer
String
>
(
)
;
String
output
=
null
;
while
(
(
output
=
in
.
readLine
(
)
)
!
=
null
)
{
String
[
]
split
=
output
.
split
(
"
\
\
s
+
"
)
;
if
(
split
.
length
<
=
pidColumn
|
|
split
.
length
<
=
nameColumn
)
continue
;
final
Integer
pid
=
Integer
.
valueOf
(
split
[
pidColumn
]
)
;
String
name
=
pidNameMap
.
get
(
pid
)
;
if
(
name
=
=
null
)
{
name
=
getAppNameByPID
(
pid
.
intValue
(
)
)
;
pidNameMap
.
put
(
pid
name
)
;
}
String
file
=
split
[
nameColumn
]
;
if
(
!
TextUtils
.
isEmpty
(
name
)
&
&
!
TextUtils
.
isEmpty
(
file
)
&
&
file
.
startsWith
(
filter
)
)
Log
.
d
(
LOGTAG
"
[
OPENFILE
]
"
+
name
+
"
(
"
+
split
[
pidColumn
]
+
"
)
:
"
+
file
)
;
}
in
.
close
(
)
;
}
catch
(
Exception
e
)
{
}
}
WrapForJNI
(
stubName
=
"
GetIconForExtensionWrapper
"
)
public
static
byte
[
]
getIconForExtension
(
String
aExt
int
iconSize
)
{
try
{
if
(
iconSize
<
=
0
)
iconSize
=
16
;
if
(
aExt
!
=
null
&
&
aExt
.
length
(
)
>
1
&
&
aExt
.
charAt
(
0
)
=
=
'
.
'
)
aExt
=
aExt
.
substring
(
1
)
;
PackageManager
pm
=
getApplicationContext
(
)
.
getPackageManager
(
)
;
Drawable
icon
=
getDrawableForExtension
(
pm
aExt
)
;
if
(
icon
=
=
null
)
{
icon
=
pm
.
getDefaultActivityIcon
(
)
;
}
Bitmap
bitmap
=
(
(
BitmapDrawable
)
icon
)
.
getBitmap
(
)
;
if
(
bitmap
.
getWidth
(
)
!
=
iconSize
|
|
bitmap
.
getHeight
(
)
!
=
iconSize
)
bitmap
=
Bitmap
.
createScaledBitmap
(
bitmap
iconSize
iconSize
true
)
;
ByteBuffer
buf
=
ByteBuffer
.
allocate
(
iconSize
*
iconSize
*
4
)
;
bitmap
.
copyPixelsToBuffer
(
buf
)
;
return
buf
.
array
(
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
getIconForExtension
failed
.
"
e
)
;
return
null
;
}
}
public
static
String
getMimeTypeFromExtension
(
String
ext
)
{
final
MimeTypeMap
mtm
=
MimeTypeMap
.
getSingleton
(
)
;
return
mtm
.
getMimeTypeFromExtension
(
ext
)
;
}
private
static
Drawable
getDrawableForExtension
(
PackageManager
pm
String
aExt
)
{
Intent
intent
=
new
Intent
(
Intent
.
ACTION_VIEW
)
;
final
String
mimeType
=
getMimeTypeFromExtension
(
aExt
)
;
if
(
mimeType
!
=
null
&
&
mimeType
.
length
(
)
>
0
)
intent
.
setType
(
mimeType
)
;
else
return
null
;
List
<
ResolveInfo
>
list
=
pm
.
queryIntentActivities
(
intent
0
)
;
if
(
list
.
size
(
)
=
=
0
)
return
null
;
ResolveInfo
resolveInfo
=
list
.
get
(
0
)
;
if
(
resolveInfo
=
=
null
)
return
null
;
ActivityInfo
activityInfo
=
resolveInfo
.
activityInfo
;
return
activityInfo
.
loadIcon
(
pm
)
;
}
WrapForJNI
public
static
boolean
getShowPasswordSetting
(
)
{
try
{
int
showPassword
=
Settings
.
System
.
getInt
(
getApplicationContext
(
)
.
getContentResolver
(
)
Settings
.
System
.
TEXT_SHOW_PASSWORD
1
)
;
return
(
showPassword
>
0
)
;
}
catch
(
Exception
e
)
{
return
true
;
}
}
WrapForJNI
(
stubName
=
"
AddPluginViewWrapper
"
)
public
static
void
addPluginView
(
View
view
float
x
float
y
float
w
float
h
boolean
isFullScreen
)
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
addPluginView
(
view
new
RectF
(
x
y
x
+
w
y
+
h
)
isFullScreen
)
;
}
WrapForJNI
public
static
void
removePluginView
(
View
view
boolean
isFullScreen
)
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
removePluginView
(
view
isFullScreen
)
;
}
public
static
final
String
PLUGIN_ACTION
=
"
android
.
webkit
.
PLUGIN
"
;
public
static
final
String
PLUGIN_PERMISSION
=
"
android
.
webkit
.
permission
.
PLUGIN
"
;
private
static
final
String
PLUGIN_SYSTEM_LIB
=
"
/
system
/
lib
/
plugins
/
"
;
private
static
final
String
PLUGIN_TYPE
=
"
type
"
;
private
static
final
String
TYPE_NATIVE
=
"
native
"
;
public
static
final
ArrayList
<
PackageInfo
>
mPackageInfoCache
=
new
ArrayList
<
>
(
)
;
static
String
[
]
getPluginDirectories
(
)
{
boolean
isTegra
=
(
new
File
(
"
/
system
/
lib
/
hw
/
gralloc
.
tegra
.
so
"
)
)
.
exists
(
)
|
|
(
new
File
(
"
/
system
/
lib
/
hw
/
gralloc
.
tegra3
.
so
"
)
)
.
exists
(
)
;
if
(
isTegra
)
{
if
(
Versions
.
feature19Plus
)
{
Log
.
w
(
LOGTAG
"
Blocking
plugins
because
of
Tegra
(
bug
957694
)
"
)
;
return
null
;
}
final
File
vfile
=
new
File
(
"
/
proc
/
version
"
)
;
try
{
if
(
vfile
.
canRead
(
)
)
{
final
BufferedReader
reader
=
new
BufferedReader
(
new
FileReader
(
vfile
)
)
;
try
{
final
String
version
=
reader
.
readLine
(
)
;
if
(
version
.
indexOf
(
"
CM9
"
)
!
=
-
1
|
|
version
.
indexOf
(
"
cyanogen
"
)
!
=
-
1
|
|
version
.
indexOf
(
"
Nova
"
)
!
=
-
1
)
{
Log
.
w
(
LOGTAG
"
Blocking
plugins
because
of
Tegra
2
+
unofficial
ICS
bug
(
bug
736421
)
"
)
;
return
null
;
}
}
finally
{
reader
.
close
(
)
;
}
}
}
catch
(
IOException
ex
)
{
}
}
ArrayList
<
String
>
directories
=
new
ArrayList
<
String
>
(
)
;
PackageManager
pm
=
getApplicationContext
(
)
.
getPackageManager
(
)
;
List
<
ResolveInfo
>
plugins
=
pm
.
queryIntentServices
(
new
Intent
(
PLUGIN_ACTION
)
PackageManager
.
GET_SERVICES
|
PackageManager
.
GET_META_DATA
)
;
synchronized
(
mPackageInfoCache
)
{
mPackageInfoCache
.
clear
(
)
;
for
(
ResolveInfo
info
:
plugins
)
{
ServiceInfo
serviceInfo
=
info
.
serviceInfo
;
if
(
serviceInfo
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Ignoring
bad
plugin
.
"
)
;
continue
;
}
if
(
serviceInfo
.
packageName
.
equals
(
"
com
.
htc
.
flashliteplugin
"
)
)
{
Log
.
w
(
LOGTAG
"
Skipping
HTC
'
s
flash
lite
plugin
"
)
;
continue
;
}
PackageInfo
pkgInfo
;
try
{
pkgInfo
=
pm
.
getPackageInfo
(
serviceInfo
.
packageName
PackageManager
.
GET_PERMISSIONS
|
PackageManager
.
GET_SIGNATURES
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Can
'
t
find
plugin
:
"
+
serviceInfo
.
packageName
)
;
continue
;
}
if
(
pkgInfo
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Not
loading
plugin
:
"
+
serviceInfo
.
packageName
+
"
.
Could
not
load
package
information
.
"
)
;
continue
;
}
String
directory
=
pkgInfo
.
applicationInfo
.
dataDir
+
"
/
lib
"
;
final
int
appFlags
=
pkgInfo
.
applicationInfo
.
flags
;
final
int
updatedSystemFlags
=
ApplicationInfo
.
FLAG_SYSTEM
|
ApplicationInfo
.
FLAG_UPDATED_SYSTEM_APP
;
if
(
(
appFlags
&
updatedSystemFlags
)
=
=
ApplicationInfo
.
FLAG_SYSTEM
)
{
directory
=
PLUGIN_SYSTEM_LIB
+
pkgInfo
.
packageName
;
}
String
permissions
[
]
=
pkgInfo
.
requestedPermissions
;
if
(
permissions
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Not
loading
plugin
:
"
+
serviceInfo
.
packageName
+
"
.
Does
not
have
required
permission
.
"
)
;
continue
;
}
boolean
permissionOk
=
false
;
for
(
String
permit
:
permissions
)
{
if
(
PLUGIN_PERMISSION
.
equals
(
permit
)
)
{
permissionOk
=
true
;
break
;
}
}
if
(
!
permissionOk
)
{
Log
.
w
(
LOGTAG
"
Not
loading
plugin
:
"
+
serviceInfo
.
packageName
+
"
.
Does
not
have
required
permission
(
2
)
.
"
)
;
continue
;
}
Signature
signatures
[
]
=
pkgInfo
.
signatures
;
if
(
signatures
=
=
null
)
{
Log
.
w
(
LOGTAG
"
Not
loading
plugin
:
"
+
serviceInfo
.
packageName
+
"
.
Not
signed
.
"
)
;
continue
;
}
if
(
serviceInfo
.
metaData
=
=
null
)
{
Log
.
e
(
LOGTAG
"
The
plugin
'
"
+
serviceInfo
.
name
+
"
'
has
no
defined
type
.
"
)
;
continue
;
}
String
pluginType
=
serviceInfo
.
metaData
.
getString
(
PLUGIN_TYPE
)
;
if
(
!
TYPE_NATIVE
.
equals
(
pluginType
)
)
{
Log
.
e
(
LOGTAG
"
Unrecognized
plugin
type
:
"
+
pluginType
)
;
continue
;
}
try
{
Class
<
?
>
cls
=
getPluginClass
(
serviceInfo
.
packageName
serviceInfo
.
name
)
;
boolean
classFound
=
true
;
if
(
!
classFound
)
{
Log
.
e
(
LOGTAG
"
The
plugin
'
s
class
'
"
+
serviceInfo
.
name
+
"
'
does
not
extend
the
appropriate
class
.
"
)
;
continue
;
}
}
catch
(
NameNotFoundException
e
)
{
Log
.
e
(
LOGTAG
"
Can
'
t
find
plugin
:
"
+
serviceInfo
.
packageName
)
;
continue
;
}
catch
(
ClassNotFoundException
e
)
{
Log
.
e
(
LOGTAG
"
Can
'
t
find
plugin
'
s
class
:
"
+
serviceInfo
.
name
)
;
continue
;
}
mPackageInfoCache
.
add
(
pkgInfo
)
;
directories
.
add
(
directory
)
;
}
}
return
directories
.
toArray
(
new
String
[
directories
.
size
(
)
]
)
;
}
static
String
getPluginPackage
(
String
pluginLib
)
{
if
(
pluginLib
=
=
null
|
|
pluginLib
.
length
(
)
=
=
0
)
{
return
null
;
}
synchronized
(
mPackageInfoCache
)
{
for
(
PackageInfo
pkgInfo
:
mPackageInfoCache
)
{
if
(
pluginLib
.
contains
(
pkgInfo
.
packageName
)
)
{
return
pkgInfo
.
packageName
;
}
}
}
return
null
;
}
static
Class
<
?
>
getPluginClass
(
String
packageName
String
className
)
throws
NameNotFoundException
ClassNotFoundException
{
Context
pluginContext
=
getApplicationContext
(
)
.
createPackageContext
(
packageName
Context
.
CONTEXT_INCLUDE_CODE
|
Context
.
CONTEXT_IGNORE_SECURITY
)
;
ClassLoader
pluginCL
=
pluginContext
.
getClassLoader
(
)
;
return
pluginCL
.
loadClass
(
className
)
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
static
Class
<
?
>
loadPluginClass
(
String
className
String
libName
)
{
if
(
getGeckoInterface
(
)
=
=
null
)
return
null
;
try
{
final
String
packageName
=
getPluginPackage
(
libName
)
;
final
int
contextFlags
=
Context
.
CONTEXT_INCLUDE_CODE
|
Context
.
CONTEXT_IGNORE_SECURITY
;
final
Context
pluginContext
=
getApplicationContext
(
)
.
createPackageContext
(
packageName
contextFlags
)
;
return
pluginContext
.
getClassLoader
(
)
.
loadClass
(
className
)
;
}
catch
(
java
.
lang
.
ClassNotFoundException
cnfe
)
{
Log
.
w
(
LOGTAG
"
Couldn
'
t
find
plugin
class
"
+
className
cnfe
)
;
return
null
;
}
catch
(
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
nnfe
)
{
Log
.
w
(
LOGTAG
"
Couldn
'
t
find
package
.
"
nnfe
)
;
return
null
;
}
}
private
static
Context
sApplicationContext
;
private
static
ContextGetter
sContextGetter
;
Deprecated
WrapForJNI
(
allowMultithread
=
true
)
public
static
Context
getContext
(
)
{
return
sContextGetter
.
getContext
(
)
;
}
public
static
void
setContextGetter
(
ContextGetter
cg
)
{
sContextGetter
=
cg
;
}
public
static
Context
getApplicationContext
(
)
{
return
sApplicationContext
;
}
public
static
void
setApplicationContext
(
final
Context
context
)
{
sApplicationContext
=
context
;
}
public
static
SharedPreferences
getSharedPreferences
(
)
{
if
(
sContextGetter
=
=
null
)
{
throw
new
IllegalStateException
(
"
No
ContextGetter
;
cannot
fetch
prefs
.
"
)
;
}
return
sContextGetter
.
getSharedPreferences
(
)
;
}
public
interface
AppStateListener
{
public
void
onPause
(
)
;
public
void
onResume
(
)
;
public
void
onOrientationChanged
(
)
;
}
public
interface
GeckoInterface
{
public
GeckoProfile
getProfile
(
)
;
public
PromptService
getPromptService
(
)
;
public
Activity
getActivity
(
)
;
public
String
getDefaultUAString
(
)
;
public
LocationListener
getLocationListener
(
)
;
public
SensorEventListener
getSensorEventListener
(
)
;
public
void
doRestart
(
)
;
public
void
setFullScreen
(
boolean
fullscreen
)
;
public
void
addPluginView
(
View
view
final
RectF
rect
final
boolean
isFullScreen
)
;
public
void
removePluginView
(
final
View
view
final
boolean
isFullScreen
)
;
public
void
enableCameraView
(
)
;
public
void
disableCameraView
(
)
;
public
void
addAppStateListener
(
AppStateListener
listener
)
;
public
void
removeAppStateListener
(
AppStateListener
listener
)
;
public
View
getCameraView
(
)
;
public
void
notifyWakeLockChanged
(
String
topic
String
state
)
;
public
FormAssistPopup
getFormAssistPopup
(
)
;
public
boolean
areTabsShown
(
)
;
public
AbsoluteLayout
getPluginContainer
(
)
;
public
void
notifyCheckUpdateResult
(
String
result
)
;
public
void
invalidateOptionsMenu
(
)
;
}
;
private
static
GeckoInterface
sGeckoInterface
;
public
static
GeckoInterface
getGeckoInterface
(
)
{
return
sGeckoInterface
;
}
public
static
void
setGeckoInterface
(
GeckoInterface
aGeckoInterface
)
{
sGeckoInterface
=
aGeckoInterface
;
}
public
static
android
.
hardware
.
Camera
sCamera
;
static
native
void
cameraCallbackBridge
(
byte
[
]
data
)
;
static
final
int
kPreferredFPS
=
25
;
static
byte
[
]
sCameraBuffer
;
WrapForJNI
(
stubName
=
"
InitCameraWrapper
"
)
static
int
[
]
initCamera
(
String
aContentType
int
aCamera
int
aWidth
int
aHeight
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
try
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
enableCameraView
(
)
;
}
catch
(
Exception
e
)
{
}
}
}
)
;
int
[
]
result
=
new
int
[
4
]
;
result
[
0
]
=
0
;
if
(
android
.
hardware
.
Camera
.
getNumberOfCameras
(
)
=
=
0
)
{
return
result
;
}
try
{
sCamera
=
android
.
hardware
.
Camera
.
open
(
aCamera
)
;
android
.
hardware
.
Camera
.
Parameters
params
=
sCamera
.
getParameters
(
)
;
params
.
setPreviewFormat
(
ImageFormat
.
NV21
)
;
int
fpsDelta
=
1000
;
try
{
Iterator
<
Integer
>
it
=
params
.
getSupportedPreviewFrameRates
(
)
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
int
nFps
=
it
.
next
(
)
;
if
(
Math
.
abs
(
nFps
-
kPreferredFPS
)
<
fpsDelta
)
{
fpsDelta
=
Math
.
abs
(
nFps
-
kPreferredFPS
)
;
params
.
setPreviewFrameRate
(
nFps
)
;
}
}
}
catch
(
Exception
e
)
{
params
.
setPreviewFrameRate
(
kPreferredFPS
)
;
}
Iterator
<
android
.
hardware
.
Camera
.
Size
>
sit
=
params
.
getSupportedPreviewSizes
(
)
.
iterator
(
)
;
int
sizeDelta
=
10000000
;
int
bufferSize
=
0
;
while
(
sit
.
hasNext
(
)
)
{
android
.
hardware
.
Camera
.
Size
size
=
sit
.
next
(
)
;
if
(
Math
.
abs
(
size
.
width
*
size
.
height
-
aWidth
*
aHeight
)
<
sizeDelta
)
{
sizeDelta
=
Math
.
abs
(
size
.
width
*
size
.
height
-
aWidth
*
aHeight
)
;
params
.
setPreviewSize
(
size
.
width
size
.
height
)
;
bufferSize
=
size
.
width
*
size
.
height
;
}
}
try
{
if
(
getGeckoInterface
(
)
!
=
null
)
{
View
cameraView
=
getGeckoInterface
(
)
.
getCameraView
(
)
;
if
(
cameraView
instanceof
SurfaceView
)
{
sCamera
.
setPreviewDisplay
(
(
(
SurfaceView
)
cameraView
)
.
getHolder
(
)
)
;
}
else
if
(
cameraView
instanceof
TextureView
)
{
sCamera
.
setPreviewTexture
(
(
(
TextureView
)
cameraView
)
.
getSurfaceTexture
(
)
)
;
}
}
}
catch
(
IOException
|
RuntimeException
e
)
{
Log
.
w
(
LOGTAG
"
Error
setPreviewXXX
:
"
e
)
;
}
sCamera
.
setParameters
(
params
)
;
sCameraBuffer
=
new
byte
[
(
bufferSize
*
12
)
/
8
]
;
sCamera
.
addCallbackBuffer
(
sCameraBuffer
)
;
sCamera
.
setPreviewCallbackWithBuffer
(
new
android
.
hardware
.
Camera
.
PreviewCallback
(
)
{
Override
public
void
onPreviewFrame
(
byte
[
]
data
android
.
hardware
.
Camera
camera
)
{
cameraCallbackBridge
(
data
)
;
if
(
sCamera
!
=
null
)
sCamera
.
addCallbackBuffer
(
sCameraBuffer
)
;
}
}
)
;
sCamera
.
startPreview
(
)
;
params
=
sCamera
.
getParameters
(
)
;
result
[
0
]
=
1
;
result
[
1
]
=
params
.
getPreviewSize
(
)
.
width
;
result
[
2
]
=
params
.
getPreviewSize
(
)
.
height
;
result
[
3
]
=
params
.
getPreviewFrameRate
(
)
;
}
catch
(
RuntimeException
e
)
{
Log
.
w
(
LOGTAG
"
initCamera
RuntimeException
.
"
e
)
;
result
[
0
]
=
result
[
1
]
=
result
[
2
]
=
result
[
3
]
=
0
;
}
return
result
;
}
WrapForJNI
static
synchronized
void
closeCamera
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
try
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
disableCameraView
(
)
;
}
catch
(
Exception
e
)
{
}
}
}
)
;
if
(
sCamera
!
=
null
)
{
sCamera
.
stopPreview
(
)
;
sCamera
.
release
(
)
;
sCamera
=
null
;
sCameraBuffer
=
null
;
}
}
WrapForJNI
public
static
void
enableBatteryNotifications
(
)
{
GeckoBatteryManager
.
enableNotifications
(
)
;
}
WrapForJNI
(
stubName
=
"
HandleGeckoMessageWrapper
"
)
public
static
void
handleGeckoMessage
(
final
NativeJSContainer
message
)
{
EventDispatcher
.
getInstance
(
)
.
dispatchEvent
(
message
)
;
message
.
disposeNative
(
)
;
}
WrapForJNI
public
static
void
disableBatteryNotifications
(
)
{
GeckoBatteryManager
.
disableNotifications
(
)
;
}
WrapForJNI
(
stubName
=
"
GetCurrentBatteryInformationWrapper
"
)
public
static
double
[
]
getCurrentBatteryInformation
(
)
{
return
GeckoBatteryManager
.
getCurrentInformation
(
)
;
}
WrapForJNI
(
stubName
=
"
CheckURIVisited
"
)
static
void
checkUriVisited
(
String
uri
)
{
GlobalHistory
.
getInstance
(
)
.
checkUriVisited
(
uri
)
;
}
WrapForJNI
(
stubName
=
"
MarkURIVisited
"
)
static
void
markUriVisited
(
final
String
uri
)
{
final
Context
context
=
getApplicationContext
(
)
;
final
BrowserDB
db
=
GeckoProfile
.
get
(
context
)
.
getDB
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GlobalHistory
.
getInstance
(
)
.
add
(
context
db
uri
)
;
}
}
)
;
}
WrapForJNI
(
stubName
=
"
SetURITitle
"
)
static
void
setUriTitle
(
final
String
uri
final
String
title
)
{
final
Context
context
=
getApplicationContext
(
)
;
final
BrowserDB
db
=
GeckoProfile
.
get
(
context
)
.
getDB
(
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GlobalHistory
.
getInstance
(
)
.
update
(
context
.
getContentResolver
(
)
db
uri
title
)
;
}
}
)
;
}
WrapForJNI
static
void
hideProgressDialog
(
)
{
}
public
static
void
sendMessage
(
String
aNumber
String
aMessage
int
aRequestId
boolean
aShouldNotify
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
send
(
aNumber
aMessage
aRequestId
aShouldNotify
)
;
}
WrapForJNI
(
stubName
=
"
SendMessageWrapper
"
)
public
static
void
sendMessage
(
String
aNumber
String
aMessage
int
aRequestId
)
{
sendMessage
(
aNumber
aMessage
aRequestId
true
)
;
}
WrapForJNI
(
stubName
=
"
GetMessageWrapper
"
)
public
static
void
getMessage
(
int
aMessageId
int
aRequestId
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
getMessage
(
aMessageId
aRequestId
)
;
}
WrapForJNI
(
stubName
=
"
DeleteMessageWrapper
"
)
public
static
void
deleteMessage
(
int
aMessageId
int
aRequestId
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
deleteMessage
(
aMessageId
aRequestId
)
;
}
WrapForJNI
public
static
void
markMessageRead
(
int
aMessageId
boolean
aValue
boolean
aSendReadReport
int
aRequestId
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
markMessageRead
(
aMessageId
aValue
aSendReadReport
aRequestId
)
;
}
WrapForJNI
(
stubName
=
"
CreateMessageCursorWrapper
"
)
public
static
void
createMessageCursor
(
long
aStartDate
long
aEndDate
String
[
]
aNumbers
int
aNumbersCount
String
aDelivery
boolean
aHasRead
boolean
aRead
boolean
aHasThreadId
long
aThreadId
boolean
aReverse
int
aRequestId
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
createMessageCursor
(
aStartDate
aEndDate
aNumbers
aNumbersCount
aDelivery
aHasRead
aRead
aHasThreadId
aThreadId
aReverse
aRequestId
)
;
}
WrapForJNI
(
stubName
=
"
GetNextMessageWrapper
"
)
public
static
void
getNextMessage
(
int
aRequestId
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
getNextMessage
(
aRequestId
)
;
}
WrapForJNI
(
stubName
=
"
CreateThreadCursorWrapper
"
)
public
static
void
createThreadCursor
(
int
aRequestId
)
{
Log
.
i
(
"
GeckoAppShell
"
"
CreateThreadCursorWrapper
!
"
)
;
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
createThreadCursor
(
aRequestId
)
;
}
WrapForJNI
(
stubName
=
"
GetNextThreadWrapper
"
)
public
static
void
getNextThread
(
int
aRequestId
)
{
if
(
!
SmsManager
.
isEnabled
(
)
)
{
return
;
}
SmsManager
.
getInstance
(
)
.
getNextThread
(
aRequestId
)
;
}
WrapForJNI
RobocopTarget
public
static
boolean
isTablet
(
)
{
return
HardwareUtils
.
isTablet
(
)
;
}
private
static
boolean
sImeWasEnabledOnLastResize
=
false
;
public
static
void
viewSizeChanged
(
)
{
GeckoView
v
=
(
GeckoView
)
getLayerView
(
)
;
if
(
v
=
=
null
)
{
return
;
}
boolean
imeIsEnabled
=
v
.
isIMEEnabled
(
)
;
if
(
imeIsEnabled
&
&
!
sImeWasEnabledOnLastResize
)
{
sendEventToGecko
(
GeckoEvent
.
createBroadcastEvent
(
"
ScrollTo
:
FocusedInput
"
"
"
)
)
;
}
sImeWasEnabledOnLastResize
=
imeIsEnabled
;
}
WrapForJNI
(
stubName
=
"
GetCurrentNetworkInformationWrapper
"
)
public
static
double
[
]
getCurrentNetworkInformation
(
)
{
return
GeckoNetworkManager
.
getInstance
(
)
.
getCurrentInformation
(
)
;
}
WrapForJNI
public
static
void
enableNetworkNotifications
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoNetworkManager
.
getInstance
(
)
.
enableNotifications
(
)
;
}
}
)
;
}
WrapForJNI
public
static
void
disableNetworkNotifications
(
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoNetworkManager
.
getInstance
(
)
.
disableNotifications
(
)
;
}
}
)
;
}
WrapForJNI
(
stubName
=
"
GetScreenOrientationWrapper
"
)
public
static
short
getScreenOrientation
(
)
{
return
GeckoScreenOrientation
.
getInstance
(
)
.
getScreenOrientation
(
)
.
value
;
}
WrapForJNI
public
static
int
getScreenAngle
(
)
{
return
GeckoScreenOrientation
.
getInstance
(
)
.
getAngle
(
)
;
}
WrapForJNI
public
static
void
enableScreenOrientationNotifications
(
)
{
GeckoScreenOrientation
.
getInstance
(
)
.
enableNotifications
(
)
;
}
WrapForJNI
public
static
void
disableScreenOrientationNotifications
(
)
{
GeckoScreenOrientation
.
getInstance
(
)
.
disableNotifications
(
)
;
}
WrapForJNI
public
static
void
lockScreenOrientation
(
int
aOrientation
)
{
GeckoScreenOrientation
.
getInstance
(
)
.
lock
(
aOrientation
)
;
}
WrapForJNI
public
static
void
unlockScreenOrientation
(
)
{
GeckoScreenOrientation
.
getInstance
(
)
.
unlock
(
)
;
}
WrapForJNI
public
static
void
notifyWakeLockChanged
(
String
topic
String
state
)
{
if
(
getGeckoInterface
(
)
!
=
null
)
getGeckoInterface
(
)
.
notifyWakeLockChanged
(
topic
state
)
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
static
void
registerSurfaceTextureFrameListener
(
Object
surfaceTexture
final
int
id
)
{
(
(
SurfaceTexture
)
surfaceTexture
)
.
setOnFrameAvailableListener
(
new
SurfaceTexture
.
OnFrameAvailableListener
(
)
{
Override
public
void
onFrameAvailable
(
SurfaceTexture
surfaceTexture
)
{
GeckoAppShell
.
onSurfaceTextureFrameAvailable
(
surfaceTexture
id
)
;
}
}
)
;
}
WrapForJNI
(
allowMultithread
=
true
)
public
static
void
unregisterSurfaceTextureFrameListener
(
Object
surfaceTexture
)
{
(
(
SurfaceTexture
)
surfaceTexture
)
.
setOnFrameAvailableListener
(
null
)
;
}
WrapForJNI
public
static
boolean
unlockProfile
(
)
{
GeckoAppShell
.
killAnyZombies
(
)
;
if
(
getGeckoInterface
(
)
!
=
null
)
{
GeckoProfile
profile
=
getGeckoInterface
(
)
.
getProfile
(
)
;
File
lock
=
profile
.
getFile
(
"
.
parentlock
"
)
;
return
lock
.
exists
(
)
&
&
lock
.
delete
(
)
;
}
return
false
;
}
WrapForJNI
(
stubName
=
"
GetProxyForURIWrapper
"
)
public
static
String
getProxyForURI
(
String
spec
String
scheme
String
host
int
port
)
{
final
ProxySelector
ps
=
new
ProxySelector
(
)
;
Proxy
proxy
=
ps
.
select
(
scheme
host
)
;
if
(
Proxy
.
NO_PROXY
.
equals
(
proxy
)
)
{
return
"
DIRECT
"
;
}
switch
(
proxy
.
type
(
)
)
{
case
HTTP
:
return
"
PROXY
"
+
proxy
.
address
(
)
.
toString
(
)
;
case
SOCKS
:
return
"
SOCKS
"
+
proxy
.
address
(
)
.
toString
(
)
;
}
return
"
DIRECT
"
;
}
public
static
void
downloadImageForIntent
(
final
Intent
intent
)
{
final
String
src
=
ContextUtils
.
getStringExtra
(
intent
Intent
.
EXTRA_TEXT
)
;
if
(
src
=
=
null
)
{
showImageShareFailureSnackbar
(
)
;
return
;
}
final
File
dir
=
GeckoApp
.
getTempDirectory
(
)
;
if
(
dir
=
=
null
)
{
showImageShareFailureSnackbar
(
)
;
return
;
}
GeckoApp
.
deleteTempFiles
(
)
;
String
type
=
intent
.
getType
(
)
;
OutputStream
os
=
null
;
try
{
if
(
src
.
startsWith
(
"
data
:
"
)
)
{
final
int
dataStart
=
src
.
indexOf
(
"
"
)
;
String
extension
=
MimeTypeMap
.
getSingleton
(
)
.
getExtensionFromMimeType
(
type
)
;
if
(
TextUtils
.
isEmpty
(
extension
)
&
&
dataStart
>
5
)
{
type
=
src
.
substring
(
5
dataStart
)
.
replace
(
"
;
base64
"
"
"
)
;
extension
=
MimeTypeMap
.
getSingleton
(
)
.
getExtensionFromMimeType
(
type
)
;
}
final
File
imageFile
=
File
.
createTempFile
(
"
image
"
"
.
"
+
extension
dir
)
;
os
=
new
FileOutputStream
(
imageFile
)
;
byte
[
]
buf
=
Base64
.
decode
(
src
.
substring
(
dataStart
+
1
)
Base64
.
DEFAULT
)
;
os
.
write
(
buf
)
;
intent
.
putExtra
(
Intent
.
EXTRA_STREAM
Uri
.
fromFile
(
imageFile
)
)
;
}
else
{
InputStream
is
=
null
;
try
{
final
byte
[
]
buf
=
new
byte
[
2048
]
;
final
URL
url
=
new
URL
(
src
)
;
final
String
filename
=
URLUtil
.
guessFileName
(
src
null
type
)
;
is
=
url
.
openStream
(
)
;
final
File
imageFile
=
new
File
(
dir
filename
)
;
os
=
new
FileOutputStream
(
imageFile
)
;
int
length
;
while
(
(
length
=
is
.
read
(
buf
)
)
!
=
-
1
)
{
os
.
write
(
buf
0
length
)
;
}
intent
.
putExtra
(
Intent
.
EXTRA_STREAM
Uri
.
fromFile
(
imageFile
)
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
is
)
;
}
}
}
catch
(
IOException
ex
)
{
}
finally
{
IOUtils
.
safeStreamClose
(
os
)
;
}
}
private
static
final
void
showImageShareFailureSnackbar
(
)
{
SnackbarHelper
.
showSnackbar
(
(
Activity
)
getContext
(
)
getApplicationContext
(
)
.
getString
(
R
.
string
.
share_image_failed
)
Snackbar
.
LENGTH_SHORT
)
;
}
WrapForJNI
(
allowMultithread
=
true
)
static
InputStream
createInputStream
(
URLConnection
connection
)
throws
IOException
{
return
connection
.
getInputStream
(
)
;
}
private
static
class
BitmapConnection
extends
URLConnection
{
private
Bitmap
bitmap
;
BitmapConnection
(
Bitmap
b
)
throws
MalformedURLException
IOException
{
super
(
null
)
;
bitmap
=
b
;
}
Override
public
void
connect
(
)
{
}
Override
public
InputStream
getInputStream
(
)
throws
IOException
{
return
new
BitmapInputStream
(
)
;
}
Override
public
String
getContentType
(
)
{
return
"
image
/
png
"
;
}
private
final
class
BitmapInputStream
extends
PipedInputStream
{
private
boolean
mHaveConnected
=
false
;
Override
public
synchronized
int
read
(
byte
[
]
buffer
int
byteOffset
int
byteCount
)
throws
IOException
{
if
(
mHaveConnected
)
{
return
super
.
read
(
buffer
byteOffset
byteCount
)
;
}
final
PipedOutputStream
output
=
new
PipedOutputStream
(
)
;
connect
(
output
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
try
{
bitmap
.
compress
(
Bitmap
.
CompressFormat
.
PNG
100
output
)
;
output
.
close
(
)
;
}
catch
(
IOException
ioe
)
{
}
}
}
)
;
mHaveConnected
=
true
;
return
super
.
read
(
buffer
byteOffset
byteCount
)
;
}
}
}
WrapForJNI
(
allowMultithread
=
true
narrowChars
=
true
)
static
URLConnection
getConnection
(
String
url
)
{
try
{
String
spec
;
if
(
url
.
startsWith
(
"
android
:
/
/
"
)
)
{
spec
=
url
.
substring
(
10
)
;
}
else
{
spec
=
url
.
substring
(
8
)
;
}
try
{
if
(
spec
.
startsWith
(
"
icon
/
"
)
)
{
String
[
]
splits
=
spec
.
split
(
"
/
"
)
;
if
(
splits
.
length
!
=
2
)
{
return
null
;
}
final
String
pkg
=
splits
[
1
]
;
final
PackageManager
pm
=
getApplicationContext
(
)
.
getPackageManager
(
)
;
final
Drawable
d
=
pm
.
getApplicationIcon
(
pkg
)
;
final
Bitmap
bitmap
=
BitmapUtils
.
getBitmapFromDrawable
(
d
)
;
return
new
BitmapConnection
(
bitmap
)
;
}
}
catch
(
Exception
ex
)
{
Log
.
e
(
LOGTAG
"
error
"
ex
)
;
}
int
colon
=
spec
.
indexOf
(
'
:
'
)
;
if
(
colon
=
=
-
1
|
|
colon
>
spec
.
indexOf
(
'
/
'
)
)
{
spec
=
spec
.
replaceFirst
(
"
/
"
"
:
/
"
)
;
}
}
catch
(
Exception
ex
)
{
return
null
;
}
return
null
;
}
WrapForJNI
(
allowMultithread
=
true
narrowChars
=
true
)
static
String
connectionGetMimeType
(
URLConnection
connection
)
{
return
connection
.
getContentType
(
)
;
}
WrapForJNI
static
String
getExternalPublicDirectory
(
final
String
type
)
{
final
String
state
=
Environment
.
getExternalStorageState
(
)
;
if
(
!
Environment
.
MEDIA_MOUNTED
.
equals
(
state
)
&
&
!
Environment
.
MEDIA_MOUNTED_READ_ONLY
.
equals
(
state
)
)
{
return
null
;
}
if
(
"
sdcard
"
.
equals
(
type
)
)
{
return
Environment
.
getExternalStorageDirectory
(
)
.
getAbsolutePath
(
)
;
}
final
String
systemType
;
if
(
"
downloads
"
.
equals
(
type
)
)
{
systemType
=
Environment
.
DIRECTORY_DOWNLOADS
;
}
else
if
(
"
pictures
"
.
equals
(
type
)
)
{
systemType
=
Environment
.
DIRECTORY_PICTURES
;
}
else
if
(
"
videos
"
.
equals
(
type
)
)
{
systemType
=
Environment
.
DIRECTORY_MOVIES
;
}
else
if
(
"
music
"
.
equals
(
type
)
)
{
systemType
=
Environment
.
DIRECTORY_MUSIC
;
}
else
if
(
"
apps
"
.
equals
(
type
)
)
{
File
appInternalStorageDirectory
=
getApplicationContext
(
)
.
getFilesDir
(
)
;
return
new
File
(
appInternalStorageDirectory
"
mozilla
"
)
.
getAbsolutePath
(
)
;
}
else
{
return
null
;
}
return
Environment
.
getExternalStoragePublicDirectory
(
systemType
)
.
getAbsolutePath
(
)
;
}
WrapForJNI
static
int
getMaxTouchPoints
(
)
{
PackageManager
pm
=
getApplicationContext
(
)
.
getPackageManager
(
)
;
if
(
pm
.
hasSystemFeature
(
PackageManager
.
FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND
)
)
{
return
5
;
}
else
if
(
pm
.
hasSystemFeature
(
PackageManager
.
FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT
)
)
{
return
2
;
}
else
if
(
pm
.
hasSystemFeature
(
PackageManager
.
FEATURE_TOUCHSCREEN_MULTITOUCH
)
)
{
return
2
;
}
else
if
(
pm
.
hasSystemFeature
(
PackageManager
.
FEATURE_TOUCHSCREEN
)
)
{
return
1
;
}
return
0
;
}
WrapForJNI
static
Rect
getScreenSize
(
)
{
final
WindowManager
wm
=
(
WindowManager
)
getApplicationContext
(
)
.
getSystemService
(
Context
.
WINDOW_SERVICE
)
;
final
Display
disp
=
wm
.
getDefaultDisplay
(
)
;
return
new
Rect
(
0
0
disp
.
getWidth
(
)
disp
.
getHeight
(
)
)
;
}
JNITarget
static
boolean
isWebAppProcess
(
)
{
return
GeckoProfile
.
get
(
getApplicationContext
(
)
)
.
isWebAppProfile
(
)
;
}
}
