package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
gfx
.
BitmapUtils
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ResourceDrawableUtils
;
import
org
.
mozilla
.
gecko
.
mozglue
.
DirectBufferAllocator
;
import
android
.
content
.
res
.
Resources
;
import
android
.
graphics
.
Bitmap
;
import
android
.
util
.
Log
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
public
final
class
ThumbnailHelper
{
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
LOGTAG
=
"
GeckoThumbnailHelper
"
;
public
static
final
float
TABS_PANEL_THUMBNAIL_ASPECT_RATIO
=
0
.
75f
;
public
static
final
float
TOP_SITES_THUMBNAIL_ASPECT_RATIO
=
0
.
571428571f
;
public
static
final
float
THUMBNAIL_ASPECT_RATIO
;
static
{
THUMBNAIL_ASPECT_RATIO
=
Math
.
max
(
TABS_PANEL_THUMBNAIL_ASPECT_RATIO
TOP_SITES_THUMBNAIL_ASPECT_RATIO
)
;
}
public
enum
CachePolicy
{
STORE
NO_STORE
}
private
static
ThumbnailHelper
sInstance
;
public
static
synchronized
ThumbnailHelper
getInstance
(
)
{
if
(
sInstance
=
=
null
)
{
sInstance
=
new
ThumbnailHelper
(
)
;
}
return
sInstance
;
}
private
final
ArrayList
<
Tab
>
mPendingThumbnails
;
private
volatile
int
mPendingWidth
;
private
int
mWidth
;
private
int
mHeight
;
private
ByteBuffer
mBuffer
;
private
ThumbnailHelper
(
)
{
final
Resources
res
=
GeckoAppShell
.
getApplicationContext
(
)
.
getResources
(
)
;
mPendingThumbnails
=
new
ArrayList
<
>
(
)
;
try
{
mPendingWidth
=
(
int
)
res
.
getDimension
(
R
.
dimen
.
tab_thumbnail_width
)
;
}
catch
(
Resources
.
NotFoundException
nfe
)
{
}
mWidth
=
-
1
;
mHeight
=
-
1
;
}
public
void
getAndProcessThumbnailFor
(
final
int
tabId
final
ResourceDrawableUtils
.
BitmapLoader
loader
)
{
final
Tab
tab
=
Tabs
.
getInstance
(
)
.
getTab
(
tabId
)
;
if
(
tab
!
=
null
)
{
getAndProcessThumbnailFor
(
tab
loader
)
;
}
}
public
void
getAndProcessThumbnailFor
(
final
Tab
tab
final
ResourceDrawableUtils
.
BitmapLoader
loader
)
{
ResourceDrawableUtils
.
runOnBitmapFoundOnUiThread
(
loader
tab
.
getThumbnail
(
)
)
;
Tabs
.
registerOnTabsChangedListener
(
new
Tabs
.
OnTabsChangedListener
(
)
{
Override
public
void
onTabChanged
(
final
Tab
t
final
Tabs
.
TabEvents
msg
final
String
data
)
{
if
(
tab
!
=
t
|
|
msg
!
=
Tabs
.
TabEvents
.
THUMBNAIL
)
{
return
;
}
Tabs
.
unregisterOnTabsChangedListener
(
this
)
;
ResourceDrawableUtils
.
runOnBitmapFoundOnUiThread
(
loader
t
.
getThumbnail
(
)
)
;
}
}
)
;
getAndProcessThumbnailFor
(
tab
)
;
}
public
void
getAndProcessThumbnailFor
(
Tab
tab
)
{
if
(
AboutPages
.
isAboutHome
(
tab
.
getURL
(
)
)
|
|
AboutPages
.
isAboutPrivateBrowsing
(
tab
.
getURL
(
)
)
)
{
tab
.
updateThumbnail
(
null
CachePolicy
.
NO_STORE
)
;
return
;
}
synchronized
(
mPendingThumbnails
)
{
if
(
mPendingThumbnails
.
lastIndexOf
(
tab
)
>
0
)
{
return
;
}
mPendingThumbnails
.
add
(
tab
)
;
if
(
mPendingThumbnails
.
size
(
)
>
1
)
{
return
;
}
requestThumbnailLocked
(
tab
)
;
}
}
public
void
setThumbnailWidth
(
int
width
)
{
if
(
GeckoAppShell
.
getScreenDepth
(
)
=
=
24
)
{
mPendingWidth
=
width
;
}
else
{
mPendingWidth
=
(
width
+
1
)
&
(
~
1
)
;
}
}
private
void
updateThumbnailSizeLocked
(
)
{
mWidth
=
mPendingWidth
;
mHeight
=
Math
.
round
(
mWidth
*
THUMBNAIL_ASPECT_RATIO
)
;
int
pixelSize
=
(
GeckoAppShell
.
getScreenDepth
(
)
=
=
24
)
?
4
:
2
;
int
capacity
=
mWidth
*
mHeight
*
pixelSize
;
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Using
new
thumbnail
size
:
"
+
capacity
+
"
(
width
"
+
mWidth
+
"
-
height
"
+
mHeight
+
"
)
"
)
;
}
if
(
mBuffer
=
=
null
|
|
mBuffer
.
capacity
(
)
!
=
capacity
)
{
if
(
mBuffer
!
=
null
)
{
mBuffer
=
DirectBufferAllocator
.
free
(
mBuffer
)
;
}
try
{
mBuffer
=
DirectBufferAllocator
.
allocate
(
capacity
)
;
}
catch
(
IllegalArgumentException
iae
)
{
Log
.
w
(
LOGTAG
iae
.
toString
(
)
)
;
}
catch
(
OutOfMemoryError
oom
)
{
Log
.
w
(
LOGTAG
"
Unable
to
allocate
thumbnail
buffer
of
capacity
"
+
capacity
)
;
}
}
}
private
void
requestThumbnailLocked
(
Tab
tab
)
{
updateThumbnailSizeLocked
(
)
;
if
(
mBuffer
=
=
null
)
{
mPendingThumbnails
.
clear
(
)
;
return
;
}
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
Sending
thumbnail
event
:
"
+
mWidth
+
"
"
+
mHeight
)
;
}
requestThumbnailLocked
(
mBuffer
tab
tab
.
getId
(
)
mWidth
mHeight
)
;
}
WrapForJNI
(
stubName
=
"
RequestThumbnail
"
dispatchTo
=
"
proxy
"
)
private
static
native
void
requestThumbnailLocked
(
ByteBuffer
data
Tab
tab
int
tabId
int
width
int
height
)
;
WrapForJNI
(
calledFrom
=
"
gecko
"
)
private
static
void
notifyThumbnail
(
final
ByteBuffer
data
final
Tab
tab
final
boolean
success
final
boolean
shouldStore
)
{
final
ThumbnailHelper
helper
=
ThumbnailHelper
.
getInstance
(
)
;
if
(
success
)
{
helper
.
handleThumbnailData
(
tab
data
shouldStore
?
CachePolicy
.
STORE
:
CachePolicy
.
NO_STORE
)
;
}
helper
.
processNextThumbnail
(
)
;
}
private
void
processNextThumbnail
(
)
{
synchronized
(
mPendingThumbnails
)
{
if
(
mPendingThumbnails
.
isEmpty
(
)
)
{
return
;
}
mPendingThumbnails
.
remove
(
0
)
;
if
(
!
mPendingThumbnails
.
isEmpty
(
)
)
{
requestThumbnailLocked
(
mPendingThumbnails
.
get
(
0
)
)
;
}
}
}
private
void
handleThumbnailData
(
Tab
tab
ByteBuffer
data
CachePolicy
cachePolicy
)
{
if
(
DEBUG
)
{
Log
.
d
(
LOGTAG
"
handleThumbnailData
:
"
+
data
.
capacity
(
)
)
;
}
if
(
data
!
=
mBuffer
)
{
Log
.
e
(
LOGTAG
"
handleThumbnailData
called
with
an
unexpected
ByteBuffer
!
"
)
;
}
processThumbnailData
(
tab
data
cachePolicy
)
;
}
private
void
processThumbnailData
(
Tab
tab
ByteBuffer
data
CachePolicy
cachePolicy
)
{
Bitmap
b
=
tab
.
getThumbnailBitmap
(
mWidth
mHeight
)
;
data
.
position
(
0
)
;
b
.
copyPixelsFromBuffer
(
data
)
;
setTabThumbnail
(
tab
b
null
cachePolicy
)
;
}
private
void
setTabThumbnail
(
Tab
tab
Bitmap
bitmap
byte
[
]
compressed
CachePolicy
cachePolicy
)
{
if
(
bitmap
=
=
null
)
{
if
(
compressed
=
=
null
)
{
Log
.
w
(
LOGTAG
"
setTabThumbnail
:
one
of
bitmap
or
compressed
must
be
non
-
null
!
"
)
;
return
;
}
bitmap
=
BitmapUtils
.
decodeByteArray
(
compressed
)
;
}
tab
.
updateThumbnail
(
bitmap
cachePolicy
)
;
}
}
