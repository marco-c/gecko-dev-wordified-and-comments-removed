package
org
.
mozilla
.
gecko
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
android
.
view
.
Menu
;
import
android
.
view
.
MenuItem
;
import
android
.
view
.
SubMenu
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
java
.
util
.
LinkedHashMap
;
import
java
.
util
.
Map
;
public
class
AddonUICache
implements
BundleEventListener
{
private
static
final
String
LOGTAG
=
"
GeckoAddonUICache
"
;
private
static
final
int
GECKO_TOOLS_MENU_ID
=
-
1
;
private
static
final
String
GECKO_TOOLS_MENU_UUID
=
"
{
115b9308
-
2023
-
44f1
-
a4e9
-
3e2197669f07
}
"
;
private
static
final
int
ADDON_MENU_OFFSET
=
1000
;
private
static
class
MenuItemInfo
{
public
int
id
;
public
String
uuid
;
public
String
label
;
public
boolean
checkable
;
public
boolean
checked
;
public
boolean
enabled
=
true
;
public
boolean
visible
=
true
;
public
int
parent
;
}
private
static
final
AddonUICache
instance
=
new
AddonUICache
(
)
;
private
final
Map
<
String
MenuItemInfo
>
mAddonMenuItemsCache
=
new
LinkedHashMap
<
>
(
)
;
private
int
mAddonMenuNextID
=
ADDON_MENU_OFFSET
;
private
Menu
mMenu
;
private
boolean
mInitialized
;
public
static
AddonUICache
getInstance
(
)
{
return
instance
;
}
private
AddonUICache
(
)
{
}
public
void
init
(
)
{
if
(
mInitialized
)
{
return
;
}
EventDispatcher
.
getInstance
(
)
.
registerUiThreadListener
(
this
"
Menu
:
Add
"
"
Menu
:
Update
"
"
Menu
:
Remove
"
null
)
;
mInitialized
=
true
;
}
Override
public
void
handleMessage
(
String
event
GeckoBundle
message
EventCallback
callback
)
{
switch
(
event
)
{
case
"
Menu
:
Add
"
:
final
MenuItemInfo
info
=
new
MenuItemInfo
(
)
;
info
.
label
=
message
.
getString
(
"
name
"
)
;
if
(
TextUtils
.
isEmpty
(
info
.
label
)
)
{
Log
.
e
(
LOGTAG
"
Invalid
menu
item
name
"
)
;
return
;
}
info
.
id
=
mAddonMenuNextID
+
+
;
info
.
uuid
=
message
.
getString
(
"
uuid
"
)
;
info
.
checked
=
message
.
getBoolean
(
"
checked
"
false
)
;
info
.
enabled
=
message
.
getBoolean
(
"
enabled
"
true
)
;
info
.
visible
=
message
.
getBoolean
(
"
visible
"
true
)
;
info
.
checkable
=
message
.
getBoolean
(
"
checkable
"
false
)
;
final
String
parentUUID
=
message
.
getString
(
"
parent
"
)
;
if
(
GECKO_TOOLS_MENU_UUID
.
equals
(
parentUUID
)
)
{
info
.
parent
=
GECKO_TOOLS_MENU_ID
;
}
else
if
(
!
TextUtils
.
isEmpty
(
parentUUID
)
)
{
MenuItemInfo
parent
=
mAddonMenuItemsCache
.
get
(
parentUUID
)
;
if
(
parent
!
=
null
)
{
info
.
parent
=
parent
.
id
;
}
}
addAddonMenuItem
(
info
)
;
break
;
case
"
Menu
:
Remove
"
:
removeAddonMenuItem
(
message
.
getString
(
"
uuid
"
)
)
;
break
;
case
"
Menu
:
Update
"
:
updateAddonMenuItem
(
message
.
getString
(
"
uuid
"
)
message
.
getBundle
(
"
options
"
)
)
;
break
;
}
}
public
void
onCreateOptionsMenu
(
Menu
menu
)
{
mMenu
=
menu
;
if
(
mMenu
!
=
null
)
{
for
(
MenuItemInfo
item
:
mAddonMenuItemsCache
.
values
(
)
)
{
addAddonMenuItemToMenu
(
mMenu
item
)
;
}
}
}
public
void
onDestroyOptionsMenu
(
)
{
mMenu
=
null
;
}
private
void
addAddonMenuItem
(
final
MenuItemInfo
info
)
{
mAddonMenuItemsCache
.
put
(
info
.
uuid
info
)
;
if
(
mMenu
=
=
null
)
{
return
;
}
addAddonMenuItemToMenu
(
mMenu
info
)
;
}
private
void
removeAddonMenuItem
(
String
uuid
)
{
final
MenuItemInfo
item
=
mAddonMenuItemsCache
.
remove
(
uuid
)
;
if
(
mMenu
=
=
null
|
|
item
=
=
null
)
{
return
;
}
final
MenuItem
menuItem
=
mMenu
.
findItem
(
item
.
id
)
;
if
(
menuItem
!
=
null
)
{
mMenu
.
removeItem
(
item
.
id
)
;
}
}
private
void
updateAddonMenuItem
(
String
uuid
final
GeckoBundle
options
)
{
final
MenuItemInfo
item
=
mAddonMenuItemsCache
.
get
(
uuid
)
;
if
(
item
!
=
null
)
{
item
.
label
=
options
.
getString
(
"
name
"
item
.
label
)
;
item
.
checkable
=
options
.
getBoolean
(
"
checkable
"
item
.
checkable
)
;
item
.
checked
=
options
.
getBoolean
(
"
checked
"
item
.
checked
)
;
item
.
enabled
=
options
.
getBoolean
(
"
enabled
"
item
.
enabled
)
;
item
.
visible
=
options
.
getBoolean
(
"
visible
"
item
.
visible
)
;
}
if
(
mMenu
=
=
null
|
|
item
=
=
null
)
{
return
;
}
final
MenuItem
menuItem
=
mMenu
.
findItem
(
item
.
id
)
;
if
(
menuItem
!
=
null
)
{
menuItem
.
setTitle
(
options
.
getString
(
"
name
"
menuItem
.
getTitle
(
)
.
toString
(
)
)
)
;
menuItem
.
setCheckable
(
options
.
getBoolean
(
"
checkable
"
menuItem
.
isCheckable
(
)
)
)
;
menuItem
.
setChecked
(
options
.
getBoolean
(
"
checked
"
menuItem
.
isChecked
(
)
)
)
;
menuItem
.
setEnabled
(
options
.
getBoolean
(
"
enabled
"
menuItem
.
isEnabled
(
)
)
)
;
menuItem
.
setVisible
(
options
.
getBoolean
(
"
visible
"
menuItem
.
isVisible
(
)
)
)
;
}
}
private
static
void
addAddonMenuItemToMenu
(
final
Menu
menu
final
MenuItemInfo
info
)
{
final
Menu
destination
;
if
(
info
.
parent
=
=
0
)
{
destination
=
menu
;
}
else
if
(
info
.
parent
=
=
GECKO_TOOLS_MENU_ID
)
{
final
MenuItem
tools
=
menu
.
findItem
(
R
.
id
.
tools
)
;
destination
=
tools
!
=
null
?
tools
.
getSubMenu
(
)
:
menu
;
}
else
{
final
MenuItem
parent
=
menu
.
findItem
(
info
.
parent
)
;
if
(
parent
=
=
null
)
{
return
;
}
Menu
parentMenu
=
findParentMenu
(
menu
parent
)
;
if
(
!
parent
.
hasSubMenu
(
)
)
{
parentMenu
.
removeItem
(
parent
.
getItemId
(
)
)
;
destination
=
parentMenu
.
addSubMenu
(
Menu
.
NONE
parent
.
getItemId
(
)
Menu
.
NONE
parent
.
getTitle
(
)
)
;
if
(
parent
.
getIcon
(
)
!
=
null
)
{
(
(
SubMenu
)
destination
)
.
getItem
(
)
.
setIcon
(
parent
.
getIcon
(
)
)
;
}
}
else
{
destination
=
parent
.
getSubMenu
(
)
;
}
}
final
MenuItem
item
=
destination
.
add
(
Menu
.
NONE
info
.
id
Menu
.
NONE
info
.
label
)
;
item
.
setOnMenuItemClickListener
(
new
MenuItem
.
OnMenuItemClickListener
(
)
{
Override
public
boolean
onMenuItemClick
(
MenuItem
item
)
{
final
GeckoBundle
data
=
new
GeckoBundle
(
1
)
;
data
.
putString
(
"
item
"
info
.
uuid
)
;
EventDispatcher
.
getInstance
(
)
.
dispatch
(
"
Menu
:
Clicked
"
data
)
;
return
true
;
}
}
)
;
item
.
setCheckable
(
info
.
checkable
)
;
item
.
setChecked
(
info
.
checked
)
;
item
.
setEnabled
(
info
.
enabled
)
;
item
.
setVisible
(
info
.
visible
)
;
}
private
static
Menu
findParentMenu
(
Menu
menu
MenuItem
item
)
{
final
int
itemId
=
item
.
getItemId
(
)
;
final
int
count
=
(
menu
!
=
null
)
?
menu
.
size
(
)
:
0
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
MenuItem
menuItem
=
menu
.
getItem
(
i
)
;
if
(
menuItem
.
getItemId
(
)
=
=
itemId
)
{
return
menu
;
}
if
(
menuItem
.
hasSubMenu
(
)
)
{
Menu
parent
=
findParentMenu
(
menuItem
.
getSubMenu
(
)
item
)
;
if
(
parent
!
=
null
)
{
return
parent
;
}
}
}
return
null
;
}
}
