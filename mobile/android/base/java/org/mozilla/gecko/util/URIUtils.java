package
org
.
mozilla
.
gecko
.
util
;
import
android
.
content
.
Context
;
import
android
.
os
.
AsyncTask
;
import
android
.
support
.
annotation
.
IntRange
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
text
.
TextUtils
;
import
ch
.
boye
.
httpclientandroidlib
.
conn
.
util
.
InetAddressUtils
;
import
org
.
mozilla
.
gecko
.
util
.
publicsuffix
.
PublicSuffix
;
import
java
.
lang
.
ref
.
WeakReference
;
import
java
.
net
.
URI
;
import
java
.
net
.
URISyntaxException
;
import
java
.
util
.
regex
.
Pattern
;
public
class
URIUtils
{
private
static
final
String
LOGTAG
=
"
GeckoURIUtils
"
;
private
static
final
Pattern
EMPTY_PATH
=
Pattern
.
compile
(
"
/
*
"
)
;
private
URIUtils
(
)
{
}
Nullable
public
static
URI
uriOrNull
(
final
String
uriString
)
{
try
{
return
new
URI
(
uriString
)
;
}
catch
(
final
URISyntaxException
e
)
{
return
null
;
}
}
public
static
boolean
isPathEmpty
(
NonNull
final
URI
uri
)
{
final
String
path
=
uri
.
getPath
(
)
;
return
TextUtils
.
isEmpty
(
path
)
|
|
EMPTY_PATH
.
matcher
(
path
)
.
matches
(
)
;
}
NonNull
WorkerThread
public
static
String
getFormattedDomain
(
NonNull
final
Context
context
NonNull
final
URI
uri
final
boolean
shouldIncludePublicSuffix
IntRange
(
from
=
0
)
final
int
subdomainCount
)
{
if
(
context
=
=
null
)
{
throw
new
NullPointerException
(
"
Expected
non
-
null
Context
argument
"
)
;
}
if
(
uri
=
=
null
)
{
throw
new
NullPointerException
(
"
Expected
non
-
null
uri
argument
"
)
;
}
if
(
subdomainCount
<
0
)
{
throw
new
IllegalArgumentException
(
"
Expected
subdomainCount
>
=
0
.
"
)
;
}
final
String
host
=
uri
.
getHost
(
)
;
if
(
TextUtils
.
isEmpty
(
host
)
)
{
return
"
"
;
}
if
(
InetAddressUtils
.
isIPv4Address
(
host
)
|
|
isIPv6
(
uri
)
|
|
!
host
.
contains
(
"
.
"
)
)
{
return
host
;
}
final
String
domainStr
=
PublicSuffix
.
getPublicSuffix
(
context
host
subdomainCount
+
1
)
;
if
(
TextUtils
.
isEmpty
(
domainStr
)
)
{
return
stripSubdomains
(
host
subdomainCount
)
;
}
if
(
!
shouldIncludePublicSuffix
)
{
return
PublicSuffix
.
stripPublicSuffix
(
context
domainStr
)
;
}
return
domainStr
;
}
private
static
String
stripSubdomains
(
String
host
final
int
desiredSubdomainCount
)
{
int
includedSubdomainCount
=
0
;
for
(
int
i
=
host
.
length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
host
.
charAt
(
i
)
=
=
'
.
'
)
{
if
(
includedSubdomainCount
>
=
desiredSubdomainCount
)
{
return
host
.
substring
(
i
+
1
host
.
length
(
)
)
;
}
includedSubdomainCount
+
=
1
;
}
}
return
host
;
}
private
static
boolean
isIPv6
(
final
URI
uri
)
{
final
String
host
=
uri
.
getHost
(
)
;
return
!
TextUtils
.
isEmpty
(
host
)
&
&
host
.
contains
(
"
:
"
)
;
}
public
static
abstract
class
GetFormattedDomainAsyncTask
extends
AsyncTask
<
Void
Void
String
>
{
protected
final
WeakReference
<
Context
>
contextWeakReference
;
protected
final
URI
uri
;
protected
final
boolean
shouldIncludePublicSuffix
;
protected
final
int
subdomainCount
;
public
GetFormattedDomainAsyncTask
(
final
Context
context
final
URI
uri
final
boolean
shouldIncludePublicSuffix
final
int
subdomainCount
)
{
this
.
contextWeakReference
=
new
WeakReference
<
>
(
context
)
;
this
.
uri
=
uri
;
this
.
shouldIncludePublicSuffix
=
shouldIncludePublicSuffix
;
this
.
subdomainCount
=
subdomainCount
;
}
Override
protected
String
doInBackground
(
final
Void
.
.
.
params
)
{
final
Context
context
=
contextWeakReference
.
get
(
)
;
if
(
context
=
=
null
)
{
return
"
"
;
}
return
URIUtils
.
getFormattedDomain
(
context
uri
shouldIncludePublicSuffix
subdomainCount
)
;
}
}
}
