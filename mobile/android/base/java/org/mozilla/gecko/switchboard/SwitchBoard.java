package
org
.
mozilla
.
gecko
.
switchboard
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URISyntaxException
;
import
java
.
net
.
URL
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
MissingResourceException
;
import
java
.
util
.
zip
.
CRC32
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
json
.
JSONArray
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
GeckoSharedPrefs
;
import
org
.
mozilla
.
gecko
.
search
.
SearchEngineManager
;
import
org
.
mozilla
.
gecko
.
util
.
HardwareUtils
;
import
org
.
mozilla
.
gecko
.
util
.
IOUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ProxySelector
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
content
.
Context
;
import
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
;
import
android
.
os
.
Build
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
public
class
SwitchBoard
{
private
static
final
String
TAG
=
"
SwitchBoard
"
;
public
static
boolean
DEBUG
=
true
;
private
static
final
String
KEY_DATA
=
"
data
"
;
private
static
final
String
KEY_NAME
=
"
name
"
;
private
static
final
String
KEY_MATCH
=
"
match
"
;
private
static
final
String
KEY_BUCKETS
=
"
buckets
"
;
private
static
final
String
KEY_VALUES
=
"
values
"
;
private
static
final
String
KEY_APP_ID
=
"
appId
"
;
private
static
final
String
KEY_COUNTRY
=
"
country
"
;
private
static
final
String
KEY_REGION
=
"
regions
"
;
private
static
final
String
KEY_DEVICE
=
"
device
"
;
private
static
final
String
KEY_LANG
=
"
lang
"
;
private
static
final
String
KEY_MANUFACTURER
=
"
manufacturer
"
;
private
static
final
String
KEY_VERSION
=
"
version
"
;
private
static
final
String
KEY_MIN
=
"
min
"
;
private
static
final
String
KEY_MAX
=
"
max
"
;
public
static
void
loadConfig
(
Context
c
NonNull
String
serverUrl
NonNull
final
ConfigStatusListener
listener
)
{
final
URL
url
;
try
{
url
=
new
URL
(
serverUrl
)
;
}
catch
(
MalformedURLException
e
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
.
onExperimentsConfigLoadFailed
(
)
;
}
}
)
;
Log
.
e
(
TAG
"
Exception
creating
server
URL
"
e
)
;
return
;
}
final
String
result
=
readFromUrlGET
(
url
)
;
if
(
DEBUG
)
Log
.
d
(
TAG
"
Result
:
"
+
result
)
;
if
(
result
=
=
null
)
{
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
.
onExperimentsConfigLoadFailed
(
)
;
}
}
)
;
return
;
}
Preferences
.
setDynamicConfigJson
(
c
result
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
.
onExperimentsConfigLoaded
(
)
;
}
}
)
;
}
public
static
boolean
isInBucket
(
Context
c
int
low
int
high
)
{
final
int
userBucket
=
getUserBucket
(
c
)
;
return
(
userBucket
>
=
low
)
&
&
(
userBucket
<
high
)
;
}
public
static
boolean
isInExperiment
(
Context
c
String
experimentName
)
{
final
Boolean
override
=
Preferences
.
getOverrideValue
(
c
experimentName
)
;
if
(
override
!
=
null
)
{
return
override
;
}
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
if
(
config
=
=
null
)
{
return
false
;
}
try
{
final
JSONArray
experiments
=
new
JSONObject
(
config
)
.
getJSONArray
(
KEY_DATA
)
;
for
(
int
i
=
0
;
i
<
experiments
.
length
(
)
;
i
+
+
)
{
JSONObject
entry
=
experiments
.
getJSONObject
(
i
)
;
final
String
name
=
entry
.
getString
(
KEY_NAME
)
;
final
boolean
isTarget
=
name
.
equals
(
experimentName
)
;
if
(
isTarget
)
{
final
boolean
isMatch
=
isMatch
(
c
entry
.
optJSONObject
(
KEY_MATCH
)
)
;
final
JSONObject
buckets
=
entry
.
getJSONObject
(
KEY_BUCKETS
)
;
final
boolean
isInBucket
=
isInBucket
(
c
buckets
.
getInt
(
KEY_MIN
)
buckets
.
getInt
(
KEY_MAX
)
)
;
if
(
isMatch
&
&
isInBucket
)
{
return
true
;
}
}
}
return
false
;
}
catch
(
JSONException
e
)
{
return
false
;
}
}
private
static
boolean
isTargetRegion
(
JSONArray
regions
String
region
)
throws
JSONException
{
if
(
regions
=
=
null
|
|
region
=
=
null
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
regions
.
length
(
)
;
i
+
+
)
{
final
String
checkingRegion
=
regions
.
getString
(
i
)
;
if
(
checkingRegion
.
equalsIgnoreCase
(
region
)
)
{
return
true
;
}
}
return
false
;
}
private
static
List
<
String
>
getExperimentNames
(
Context
c
)
throws
JSONException
{
final
List
<
String
>
returnList
=
new
ArrayList
<
>
(
)
;
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
final
JSONArray
experiments
=
new
JSONObject
(
config
)
.
getJSONArray
(
KEY_DATA
)
;
for
(
int
i
=
0
;
i
<
experiments
.
length
(
)
;
i
+
+
)
{
JSONObject
entry
=
experiments
.
getJSONObject
(
i
)
;
returnList
.
add
(
entry
.
getString
(
KEY_NAME
)
)
;
}
return
returnList
;
}
Nullable
private
static
JSONObject
getExperiment
(
Context
c
String
experimentName
)
throws
JSONException
{
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
final
JSONArray
experiments
=
new
JSONObject
(
config
)
.
getJSONArray
(
KEY_DATA
)
;
JSONObject
experiment
=
null
;
for
(
int
i
=
0
;
i
<
experiments
.
length
(
)
;
i
+
+
)
{
JSONObject
entry
=
experiments
.
getJSONObject
(
i
)
;
if
(
entry
.
getString
(
KEY_NAME
)
.
equals
(
experimentName
)
)
{
experiment
=
entry
;
break
;
}
}
return
experiment
;
}
private
static
boolean
isMatch
(
Context
context
Nullable
JSONObject
matchKeys
)
{
if
(
matchKeys
=
=
null
)
{
return
true
;
}
if
(
matchKeys
.
has
(
KEY_APP_ID
)
)
{
try
{
final
String
packageName
=
context
.
getPackageName
(
)
;
final
String
expectedAppIdPattern
=
matchKeys
.
getString
(
KEY_APP_ID
)
;
if
(
!
TextUtils
.
isEmpty
(
expectedAppIdPattern
)
&
&
!
packageName
.
matches
(
expectedAppIdPattern
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
appId
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_COUNTRY
)
)
{
try
{
final
String
country
=
Locale
.
getDefault
(
)
.
getISO3Country
(
)
;
final
String
expectedCountryPattern
=
matchKeys
.
getString
(
KEY_COUNTRY
)
;
if
(
!
TextUtils
.
isEmpty
(
expectedCountryPattern
)
&
&
!
country
.
matches
(
expectedCountryPattern
)
)
{
return
false
;
}
}
catch
(
MissingResourceException
|
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
country
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_DEVICE
)
)
{
try
{
final
String
device
=
Build
.
DEVICE
;
final
String
expectedDevicePattern
=
matchKeys
.
getString
(
KEY_DEVICE
)
;
if
(
!
TextUtils
.
isEmpty
(
expectedDevicePattern
)
&
&
!
device
.
matches
(
expectedDevicePattern
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
device
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_LANG
)
)
{
try
{
final
String
lang
=
Locale
.
getDefault
(
)
.
getISO3Language
(
)
;
final
String
expectedLanguagePattern
=
matchKeys
.
getString
(
KEY_LANG
)
;
if
(
!
TextUtils
.
isEmpty
(
expectedLanguagePattern
)
&
&
!
lang
.
matches
(
expectedLanguagePattern
)
)
{
return
false
;
}
}
catch
(
MissingResourceException
|
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
lang
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_MANUFACTURER
)
)
{
try
{
final
String
manufacturer
=
Build
.
MANUFACTURER
;
final
String
expectedManufacturerPattern
=
matchKeys
.
getString
(
KEY_MANUFACTURER
)
;
if
(
!
TextUtils
.
isEmpty
(
expectedManufacturerPattern
)
&
&
!
manufacturer
.
matches
(
expectedManufacturerPattern
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
manufacturer
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_VERSION
)
)
{
try
{
final
String
version
=
context
.
getPackageManager
(
)
.
getPackageInfo
(
context
.
getPackageName
(
)
0
)
.
versionName
;
final
String
expectedVersionPattern
=
matchKeys
.
getString
(
KEY_VERSION
)
;
if
(
!
TextUtils
.
isEmpty
(
expectedVersionPattern
)
&
&
!
version
.
matches
(
expectedVersionPattern
)
)
{
return
false
;
}
}
catch
(
NameNotFoundException
|
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
version
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_REGION
)
)
{
try
{
final
JSONArray
regions
=
matchKeys
.
getJSONArray
(
KEY_REGION
)
;
if
(
regions
.
length
(
)
<
=
0
)
{
return
true
;
}
final
String
region
=
GeckoSharedPrefs
.
forApp
(
context
)
.
getString
(
SearchEngineManager
.
PREF_REGION_KEY
null
)
;
if
(
!
isTargetRegion
(
regions
region
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
region
"
e
)
;
}
}
return
true
;
}
public
static
List
<
String
>
getActiveExperiments
(
Context
c
)
{
final
List
<
String
>
returnList
=
new
ArrayList
<
>
(
)
;
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
if
(
config
=
=
null
)
{
return
returnList
;
}
try
{
final
JSONObject
data
=
new
JSONObject
(
config
)
;
final
List
<
String
>
experiments
=
getExperimentNames
(
c
)
;
for
(
int
i
=
0
;
i
<
experiments
.
size
(
)
;
i
+
+
)
{
final
String
name
=
experiments
.
get
(
i
)
;
Boolean
isActive
=
Preferences
.
getOverrideValue
(
c
name
)
;
if
(
isActive
=
=
null
)
{
isActive
=
isInExperiment
(
c
name
)
;
}
if
(
isActive
)
{
returnList
.
add
(
name
)
;
}
}
}
catch
(
JSONException
e
)
{
}
return
returnList
;
}
public
static
boolean
hasExperimentValues
(
Context
c
String
experimentName
)
{
return
getExperimentValuesFromJson
(
c
experimentName
)
!
=
null
;
}
Nullable
public
static
JSONObject
getExperimentValuesFromJson
(
Context
c
String
experimentName
)
{
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
if
(
config
=
=
null
)
{
return
null
;
}
try
{
final
JSONObject
experiment
=
getExperiment
(
c
experimentName
)
;
if
(
experiment
=
=
null
)
{
return
null
;
}
return
experiment
.
getJSONObject
(
KEY_VALUES
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Could
not
create
JSON
object
from
config
string
"
e
)
;
}
return
null
;
}
Nullable
private
static
String
readFromUrlGET
(
URL
url
)
{
HttpURLConnection
connection
=
null
;
InputStreamReader
inputStreamReader
=
null
;
BufferedReader
bufferReader
=
null
;
try
{
connection
=
(
HttpURLConnection
)
ProxySelector
.
openConnectionWithProxy
(
url
.
toURI
(
)
)
;
connection
.
setRequestProperty
(
"
User
-
Agent
"
HardwareUtils
.
isTablet
(
)
?
AppConstants
.
USER_AGENT_FENNEC_TABLET
:
AppConstants
.
USER_AGENT_FENNEC_MOBILE
)
;
connection
.
setRequestMethod
(
"
GET
"
)
;
connection
.
setUseCaches
(
false
)
;
inputStreamReader
=
new
InputStreamReader
(
connection
.
getInputStream
(
)
)
;
bufferReader
=
new
BufferedReader
(
inputStreamReader
8192
)
;
String
line
;
StringBuilder
resultContent
=
new
StringBuilder
(
)
;
while
(
(
line
=
bufferReader
.
readLine
(
)
)
!
=
null
)
{
resultContent
.
append
(
line
)
;
}
return
resultContent
.
toString
(
)
;
}
catch
(
IOException
|
URISyntaxException
e
)
{
e
.
printStackTrace
(
)
;
}
finally
{
IOUtils
.
safeStreamClose
(
bufferReader
)
;
IOUtils
.
safeStreamClose
(
inputStreamReader
)
;
if
(
connection
!
=
null
)
{
connection
.
disconnect
(
)
;
}
}
return
null
;
}
private
static
int
getUserBucket
(
Context
c
)
{
final
DeviceUuidFactory
df
=
new
DeviceUuidFactory
(
c
)
;
final
String
uuid
=
df
.
getDeviceUuid
(
)
.
toString
(
)
;
CRC32
crc
=
new
CRC32
(
)
;
crc
.
update
(
uuid
.
getBytes
(
)
)
;
long
checksum
=
crc
.
getValue
(
)
;
return
(
int
)
(
checksum
%
100L
)
;
}
public
interface
ConfigStatusListener
{
void
onExperimentsConfigLoaded
(
)
;
void
onExperimentsConfigLoadFailed
(
)
;
}
}
