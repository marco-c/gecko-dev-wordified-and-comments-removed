package
org
.
mozilla
.
gecko
.
switchboard
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URL
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
java
.
util
.
MissingResourceException
;
import
java
.
util
.
zip
.
CRC32
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
json
.
JSONArray
;
import
android
.
content
.
Context
;
import
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
;
import
android
.
os
.
Build
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
support
.
annotation
.
Nullable
;
import
android
.
util
.
Log
;
public
class
SwitchBoard
{
private
static
final
String
TAG
=
"
SwitchBoard
"
;
public
static
boolean
DEBUG
=
true
;
private
static
final
String
KEY_DATA
=
"
data
"
;
private
static
final
String
KEY_NAME
=
"
name
"
;
private
static
final
String
KEY_MATCH
=
"
match
"
;
private
static
final
String
KEY_BUCKETS
=
"
buckets
"
;
private
static
final
String
KEY_VALUES
=
"
values
"
;
private
static
final
String
KEY_APP_ID
=
"
appId
"
;
private
static
final
String
KEY_COUNTRY
=
"
country
"
;
private
static
final
String
KEY_DEVICE
=
"
device
"
;
private
static
final
String
KEY_LANG
=
"
lang
"
;
private
static
final
String
KEY_MANUFACTURER
=
"
manufacturer
"
;
private
static
final
String
KEY_VERSION
=
"
version
"
;
private
static
final
String
KEY_MIN
=
"
min
"
;
private
static
final
String
KEY_MAX
=
"
max
"
;
static
void
loadConfig
(
Context
c
NonNull
String
serverUrl
)
{
final
URL
url
;
try
{
url
=
new
URL
(
serverUrl
)
;
}
catch
(
MalformedURLException
e
)
{
Log
.
e
(
TAG
"
Exception
creating
server
URL
"
e
)
;
return
;
}
final
String
result
=
readFromUrlGET
(
url
)
;
if
(
DEBUG
)
Log
.
d
(
TAG
"
Result
:
"
+
result
)
;
if
(
result
=
=
null
)
{
return
;
}
Preferences
.
setDynamicConfigJson
(
c
result
)
;
}
public
static
boolean
isInBucket
(
Context
c
int
low
int
high
)
{
final
int
userBucket
=
getUserBucket
(
c
)
;
return
(
userBucket
>
=
low
)
&
&
(
userBucket
<
high
)
;
}
public
static
boolean
isInExperiment
(
Context
c
String
experimentName
)
{
final
Boolean
override
=
Preferences
.
getOverrideValue
(
c
experimentName
)
;
if
(
override
!
=
null
)
{
return
override
;
}
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
if
(
config
=
=
null
)
{
return
false
;
}
try
{
final
JSONArray
experiments
=
new
JSONObject
(
config
)
.
getJSONArray
(
KEY_DATA
)
;
JSONObject
experiment
=
null
;
for
(
int
i
=
0
;
i
<
experiments
.
length
(
)
;
i
+
+
)
{
JSONObject
entry
=
experiments
.
getJSONObject
(
i
)
;
final
String
name
=
entry
.
getString
(
KEY_NAME
)
;
if
(
name
.
equals
(
experimentName
)
)
{
experiment
=
entry
;
break
;
}
}
if
(
experiment
=
=
null
)
{
return
false
;
}
if
(
!
isMatch
(
c
experiment
.
optJSONObject
(
KEY_MATCH
)
)
)
{
return
false
;
}
final
JSONObject
buckets
=
experiment
.
getJSONObject
(
KEY_BUCKETS
)
;
final
boolean
inExperiment
=
isInBucket
(
c
buckets
.
getInt
(
KEY_MIN
)
buckets
.
getInt
(
KEY_MAX
)
)
;
if
(
DEBUG
)
{
Log
.
d
(
TAG
experimentName
+
"
=
"
+
inExperiment
)
;
}
return
inExperiment
;
}
catch
(
JSONException
e
)
{
return
false
;
}
}
private
static
List
<
String
>
getExperimentNames
(
Context
c
)
throws
JSONException
{
final
List
<
String
>
returnList
=
new
ArrayList
<
>
(
)
;
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
final
JSONArray
experiments
=
new
JSONObject
(
config
)
.
getJSONArray
(
KEY_DATA
)
;
for
(
int
i
=
0
;
i
<
experiments
.
length
(
)
;
i
+
+
)
{
JSONObject
entry
=
experiments
.
getJSONObject
(
i
)
;
returnList
.
add
(
entry
.
getString
(
KEY_NAME
)
)
;
}
return
returnList
;
}
Nullable
private
static
JSONObject
getExperiment
(
Context
c
String
experimentName
)
throws
JSONException
{
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
final
JSONArray
experiments
=
new
JSONObject
(
config
)
.
getJSONArray
(
KEY_DATA
)
;
JSONObject
experiment
=
null
;
for
(
int
i
=
0
;
i
<
experiments
.
length
(
)
;
i
+
+
)
{
JSONObject
entry
=
experiments
.
getJSONObject
(
i
)
;
if
(
entry
.
getString
(
KEY_NAME
)
.
equals
(
experimentName
)
)
{
experiment
=
entry
;
break
;
}
}
return
experiment
;
}
private
static
boolean
isMatch
(
Context
c
Nullable
JSONObject
matchKeys
)
{
if
(
matchKeys
=
=
null
)
{
return
true
;
}
if
(
matchKeys
.
has
(
KEY_APP_ID
)
)
{
final
String
packageName
=
c
.
getPackageName
(
)
;
try
{
if
(
!
packageName
.
matches
(
matchKeys
.
getString
(
KEY_APP_ID
)
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
appId
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_COUNTRY
)
)
{
try
{
final
String
country
=
Locale
.
getDefault
(
)
.
getISO3Country
(
)
;
if
(
!
country
.
matches
(
matchKeys
.
getString
(
KEY_COUNTRY
)
)
)
{
return
false
;
}
}
catch
(
MissingResourceException
|
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
country
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_DEVICE
)
)
{
final
String
device
=
Build
.
DEVICE
;
try
{
if
(
!
device
.
matches
(
matchKeys
.
getString
(
KEY_DEVICE
)
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
device
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_LANG
)
)
{
try
{
final
String
lang
=
Locale
.
getDefault
(
)
.
getISO3Language
(
)
;
if
(
!
lang
.
matches
(
matchKeys
.
getString
(
KEY_LANG
)
)
)
{
return
false
;
}
}
catch
(
MissingResourceException
|
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
lang
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_MANUFACTURER
)
)
{
final
String
manufacturer
=
Build
.
MANUFACTURER
;
try
{
if
(
!
manufacturer
.
matches
(
matchKeys
.
getString
(
KEY_MANUFACTURER
)
)
)
{
return
false
;
}
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
manufacturer
"
e
)
;
}
}
if
(
matchKeys
.
has
(
KEY_VERSION
)
)
{
try
{
final
String
version
=
c
.
getPackageManager
(
)
.
getPackageInfo
(
c
.
getPackageName
(
)
0
)
.
versionName
;
if
(
!
version
.
matches
(
matchKeys
.
getString
(
KEY_VERSION
)
)
)
{
return
false
;
}
}
catch
(
NameNotFoundException
|
JSONException
e
)
{
Log
.
e
(
TAG
"
Exception
matching
version
"
e
)
;
}
}
return
true
;
}
public
static
List
<
String
>
getActiveExperiments
(
Context
c
)
{
final
List
<
String
>
returnList
=
new
ArrayList
<
>
(
)
;
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
if
(
config
=
=
null
)
{
return
returnList
;
}
try
{
final
JSONObject
data
=
new
JSONObject
(
config
)
;
final
List
<
String
>
experiments
=
getExperimentNames
(
c
)
;
for
(
int
i
=
0
;
i
<
experiments
.
size
(
)
;
i
+
+
)
{
final
String
name
=
experiments
.
get
(
i
)
;
Boolean
isActive
=
Preferences
.
getOverrideValue
(
c
name
)
;
if
(
isActive
=
=
null
)
{
isActive
=
isInExperiment
(
c
name
)
;
}
if
(
isActive
)
{
returnList
.
add
(
name
)
;
}
}
}
catch
(
JSONException
e
)
{
}
return
returnList
;
}
public
static
boolean
hasExperimentValues
(
Context
c
String
experimentName
)
{
return
getExperimentValuesFromJson
(
c
experimentName
)
!
=
null
;
}
Nullable
public
static
JSONObject
getExperimentValuesFromJson
(
Context
c
String
experimentName
)
{
final
String
config
=
Preferences
.
getDynamicConfigJson
(
c
)
;
if
(
config
=
=
null
)
{
return
null
;
}
try
{
final
JSONObject
experiment
=
getExperiment
(
c
experimentName
)
;
if
(
experiment
=
=
null
)
{
return
null
;
}
return
experiment
.
getJSONObject
(
KEY_VALUES
)
;
}
catch
(
JSONException
e
)
{
Log
.
e
(
TAG
"
Could
not
create
JSON
object
from
config
string
"
e
)
;
}
return
null
;
}
Nullable
private
static
String
readFromUrlGET
(
URL
url
)
{
try
{
HttpURLConnection
connection
=
(
HttpURLConnection
)
url
.
openConnection
(
)
;
connection
.
setRequestMethod
(
"
GET
"
)
;
connection
.
setUseCaches
(
false
)
;
InputStream
is
=
connection
.
getInputStream
(
)
;
InputStreamReader
inputStreamReader
=
new
InputStreamReader
(
is
)
;
BufferedReader
bufferReader
=
new
BufferedReader
(
inputStreamReader
8192
)
;
String
line
;
StringBuilder
resultContent
=
new
StringBuilder
(
)
;
while
(
(
line
=
bufferReader
.
readLine
(
)
)
!
=
null
)
{
resultContent
.
append
(
line
)
;
}
bufferReader
.
close
(
)
;
return
resultContent
.
toString
(
)
;
}
catch
(
IOException
e
)
{
e
.
printStackTrace
(
)
;
}
return
null
;
}
private
static
int
getUserBucket
(
Context
c
)
{
final
DeviceUuidFactory
df
=
new
DeviceUuidFactory
(
c
)
;
final
String
uuid
=
df
.
getDeviceUuid
(
)
.
toString
(
)
;
CRC32
crc
=
new
CRC32
(
)
;
crc
.
update
(
uuid
.
getBytes
(
)
)
;
long
checksum
=
crc
.
getValue
(
)
;
return
(
int
)
(
checksum
%
100L
)
;
}
}
