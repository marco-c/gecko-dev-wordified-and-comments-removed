package
org
.
mozilla
.
gecko
.
activitystream
.
homepanel
;
import
android
.
content
.
Context
;
import
android
.
database
.
ContentObserver
;
import
android
.
database
.
Cursor
;
import
android
.
os
.
SystemClock
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
support
.
v4
.
content
.
AsyncTaskLoader
;
import
org
.
mozilla
.
gecko
.
Telemetry
;
import
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightsRanking
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserContract
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
activitystream
.
homepanel
.
model
.
Highlight
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
class
HighlightsLoader
extends
AsyncTaskLoader
<
List
<
Highlight
>
>
{
private
static
final
String
TELEMETRY_HISTOGRAM_ACTIVITY_STREAM_HIGHLIGHTS
=
"
FENNEC_ACTIVITY_STREAM_HIGHLIGHTS_LOADER_TIME_MS
"
;
private
final
Context
context
;
private
final
int
candidatesLimit
;
private
final
int
highlightsLimit
;
private
final
ContentObserver
observer
;
HighlightsLoader
(
Context
context
int
candidatesLimit
int
highlightsLimit
)
{
super
(
context
)
;
this
.
context
=
context
;
this
.
candidatesLimit
=
candidatesLimit
;
this
.
highlightsLimit
=
highlightsLimit
;
this
.
observer
=
new
ForceLoadContentObserver
(
)
;
}
Override
public
List
<
Highlight
>
loadInBackground
(
)
{
final
long
startTime
=
SystemClock
.
uptimeMillis
(
)
;
final
Cursor
candidatesCursor
=
BrowserDB
.
from
(
context
)
.
getHighlightCandidates
(
context
.
getContentResolver
(
)
candidatesLimit
)
;
if
(
candidatesCursor
=
=
null
)
{
return
Collections
.
emptyList
(
)
;
}
try
{
enableContentUpdates
(
)
;
final
List
<
Highlight
>
highlights
=
HighlightsRanking
.
rank
(
candidatesCursor
highlightsLimit
)
;
forceLoadHighlightMetadata
(
highlights
)
;
addToPerformanceHistogram
(
startTime
)
;
return
highlights
;
}
finally
{
candidatesCursor
.
close
(
)
;
}
}
WorkerThread
private
static
void
forceLoadHighlightMetadata
(
final
List
<
Highlight
>
highlights
)
{
ThreadUtils
.
assertNotOnUiThread
(
)
;
for
(
final
Highlight
highlight
:
highlights
)
{
highlight
.
getMetadataSlow
(
)
;
}
}
private
void
addToPerformanceHistogram
(
long
startTime
)
{
final
long
took
=
SystemClock
.
uptimeMillis
(
)
-
startTime
;
Telemetry
.
addToHistogram
(
TELEMETRY_HISTOGRAM_ACTIVITY_STREAM_HIGHLIGHTS
(
int
)
Math
.
min
(
took
Integer
.
MAX_VALUE
)
)
;
}
Override
protected
void
onReset
(
)
{
disableContentUpdates
(
)
;
}
Override
protected
void
onStartLoading
(
)
{
forceLoad
(
)
;
}
private
void
enableContentUpdates
(
)
{
context
.
getContentResolver
(
)
.
registerContentObserver
(
BrowserContract
.
AUTHORITY_URI
true
observer
)
;
}
private
void
disableContentUpdates
(
)
{
context
.
getContentResolver
(
)
.
unregisterContentObserver
(
observer
)
;
}
}
