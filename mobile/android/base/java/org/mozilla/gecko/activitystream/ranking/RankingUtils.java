package
org
.
mozilla
.
gecko
.
activitystream
.
ranking
;
import
android
.
database
.
Cursor
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
class
RankingUtils
{
interface
Action1
<
T
>
{
void
call
(
T
t
)
;
}
interface
Action2
<
T1
T2
>
{
void
call
(
T1
t1
T2
t2
)
;
}
interface
Func1
<
T
R
>
{
R
call
(
T
t
)
;
}
interface
Func2
<
T1
T2
R
>
{
R
call
(
T1
t
T2
a
)
;
}
static
<
T
>
void
filter
(
List
<
T
>
items
Func1
<
T
Boolean
>
filter
)
{
final
Iterator
<
T
>
iterator
=
items
.
iterator
(
)
;
while
(
iterator
.
hasNext
(
)
)
{
if
(
!
filter
.
call
(
iterator
.
next
(
)
)
)
{
iterator
.
remove
(
)
;
}
}
}
static
<
T
>
void
apply
(
List
<
T
>
items
Action1
<
T
>
action
)
{
for
(
T
item
:
items
)
{
action
.
call
(
item
)
;
}
}
static
<
T1
T2
>
void
apply2D
(
List
<
T1
>
items1
List
<
T2
>
items2
Action2
<
T1
T2
>
action
)
{
for
(
T1
candidate
:
items1
)
{
for
(
T2
items
:
items2
)
{
action
.
call
(
candidate
items
)
;
}
}
}
static
<
T
>
void
applyInPairs
(
List
<
T
>
items
Action2
<
T
T
>
action
)
{
if
(
items
.
size
(
)
<
2
)
{
return
;
}
for
(
int
i
=
1
;
i
<
items
.
size
(
)
;
i
+
+
)
{
action
.
call
(
items
.
get
(
i
-
1
)
items
.
get
(
i
)
)
;
}
}
static
<
T
R
>
R
reduce
(
Collection
<
T
>
items
Func2
<
T
R
R
>
func
R
initial
)
{
R
result
=
initial
;
for
(
T
item
:
items
)
{
result
=
func
.
call
(
item
result
)
;
}
return
result
;
}
static
<
T
R
>
List
<
R
>
mapWithLimit
(
List
<
T
>
items
Func1
<
T
R
>
func
int
limit
)
{
List
<
R
>
newItems
=
new
ArrayList
<
>
(
items
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
items
.
size
(
)
&
&
i
<
limit
;
i
+
+
)
{
newItems
.
add
(
func
.
call
(
items
.
get
(
i
)
)
)
;
}
return
newItems
;
}
static
<
T
>
List
<
T
>
looselyMapCursor
(
Cursor
cursor
Func1
<
Cursor
T
>
func
)
{
List
<
T
>
items
=
new
ArrayList
<
>
(
cursor
.
getCount
(
)
)
;
if
(
cursor
.
getCount
(
)
=
=
0
)
{
return
items
;
}
cursor
.
moveToFirst
(
)
;
do
{
T
item
=
func
.
call
(
cursor
)
;
if
(
item
!
=
null
)
{
items
.
add
(
item
)
;
}
}
while
(
cursor
.
moveToNext
(
)
)
;
return
items
;
}
static
double
normalize
(
double
value
double
min
double
max
)
{
if
(
max
>
min
)
{
if
(
value
<
min
|
|
value
>
max
)
{
throw
new
IllegalArgumentException
(
"
value
"
+
value
+
"
not
in
range
[
"
+
min
+
"
"
+
max
+
"
]
"
)
;
}
double
delta
=
max
-
min
;
return
(
value
-
min
)
/
delta
;
}
return
0
;
}
}
