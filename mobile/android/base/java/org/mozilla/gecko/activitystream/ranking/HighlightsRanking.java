package
org
.
mozilla
.
gecko
.
activitystream
.
ranking
;
import
android
.
database
.
Cursor
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
android
.
util
.
Log
;
import
android
.
util
.
SparseArray
;
import
org
.
mozilla
.
gecko
.
activitystream
.
homepanel
.
model
.
Highlight
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Set
;
import
static
java
.
util
.
Collections
.
sort
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_AGE_IN_DAYS
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_BOOKMARK_AGE_IN_MILLISECONDS
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_DESCRIPTION_LENGTH
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_DOMAIN_FREQUENCY
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_IMAGE_COUNT
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_IMAGE_SIZE
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_PATH_LENGTH
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_QUERY_LENGTH
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
HighlightCandidate
.
FEATURE_VISITS_COUNT
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Action1
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Action2
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Func1
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
apply
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
applyInPairs
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
filter
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
looselyMapCursor
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
mapWithLimit
;
public
class
HighlightsRanking
{
private
static
final
String
LOG_TAG
=
"
HighlightsRanking
"
;
private
static
final
int
[
]
HIGHLIGHT_WEIGHT_FEATURES
;
private
static
final
HighlightCandidate
.
Features
HIGHLIGHT_WEIGHTS
=
new
HighlightCandidate
.
Features
(
)
;
static
{
final
SparseArray
<
Double
>
tmpWeights
=
new
SparseArray
<
>
(
)
;
tmpWeights
.
put
(
FEATURE_VISITS_COUNT
-
0
.
1
)
;
tmpWeights
.
put
(
FEATURE_DESCRIPTION_LENGTH
-
0
.
1
)
;
tmpWeights
.
put
(
FEATURE_PATH_LENGTH
-
0
.
1
)
;
tmpWeights
.
put
(
FEATURE_QUERY_LENGTH
0
.
4
)
;
tmpWeights
.
put
(
FEATURE_IMAGE_SIZE
0
.
2
)
;
HIGHLIGHT_WEIGHT_FEATURES
=
new
int
[
tmpWeights
.
size
(
)
]
;
for
(
int
i
=
0
;
i
<
tmpWeights
.
size
(
)
;
+
+
i
)
{
final
HighlightCandidate
.
FeatureName
int
featureName
=
tmpWeights
.
keyAt
(
i
)
;
final
Double
featureWeight
=
tmpWeights
.
get
(
featureName
)
;
HIGHLIGHT_WEIGHTS
.
put
(
featureName
featureWeight
)
;
HIGHLIGHT_WEIGHT_FEATURES
[
i
]
=
featureName
;
}
}
private
static
final
int
[
]
NORMALIZATION_FEATURES
=
new
int
[
]
{
FEATURE_DESCRIPTION_LENGTH
FEATURE_PATH_LENGTH
FEATURE_IMAGE_SIZE
}
;
private
static
final
double
BOOKMARK_AGE_DIVIDEND
=
3
*
24
*
60
*
60
*
1000
;
public
static
List
<
Highlight
>
rank
(
Cursor
cursor
int
limit
)
{
List
<
HighlightCandidate
>
highlights
=
extractFeatures
(
cursor
)
;
normalize
(
highlights
)
;
scoreEntries
(
highlights
)
;
filterOutItemsWithNoScore
(
highlights
)
;
sortDescendingByScore
(
highlights
)
;
adjustConsecutiveEntries
(
highlights
)
;
dedupeSites
(
highlights
)
;
sortDescendingByScore
(
highlights
)
;
return
createHighlightsList
(
highlights
limit
)
;
}
VisibleForTesting
static
List
<
HighlightCandidate
>
extractFeatures
(
final
Cursor
cursor
)
{
final
HighlightCandidateCursorIndices
cursorIndices
=
new
HighlightCandidateCursorIndices
(
cursor
)
;
return
looselyMapCursor
(
cursor
new
Func1
<
Cursor
HighlightCandidate
>
(
)
{
Override
public
HighlightCandidate
call
(
Cursor
cursor
)
{
try
{
return
HighlightCandidate
.
fromCursor
(
cursor
cursorIndices
)
;
}
catch
(
HighlightCandidate
.
InvalidHighlightCandidateException
e
)
{
Log
.
w
(
LOG_TAG
"
Skipping
invalid
highlight
item
"
e
)
;
return
null
;
}
}
}
)
;
}
VisibleForTesting
static
void
normalize
(
List
<
HighlightCandidate
>
candidates
)
{
for
(
final
int
feature
:
NORMALIZATION_FEATURES
)
{
double
minForFeature
=
Double
.
MAX_VALUE
;
double
maxForFeature
=
Double
.
MIN_VALUE
;
for
(
final
HighlightCandidate
candidate
:
candidates
)
{
minForFeature
=
Math
.
min
(
minForFeature
candidate
.
features
.
get
(
feature
)
)
;
maxForFeature
=
Math
.
max
(
maxForFeature
candidate
.
features
.
get
(
feature
)
)
;
}
for
(
final
HighlightCandidate
candidate
:
candidates
)
{
final
double
value
=
candidate
.
features
.
get
(
feature
)
;
candidate
.
features
.
put
(
feature
RankingUtils
.
normalize
(
value
minForFeature
maxForFeature
)
)
;
}
}
}
VisibleForTesting
static
void
scoreEntries
(
List
<
HighlightCandidate
>
highlights
)
{
apply
(
highlights
new
Action1
<
HighlightCandidate
>
(
)
{
Override
public
void
call
(
HighlightCandidate
candidate
)
{
final
double
initialScore
=
candidate
.
features
.
get
(
FEATURE_VISITS_COUNT
)
*
candidate
.
features
.
get
(
FEATURE_DOMAIN_FREQUENCY
)
;
final
double
score
=
adjustScore
(
decay
(
initialScore
candidate
.
features
HIGHLIGHT_WEIGHTS
)
candidate
)
;
candidate
.
updateScore
(
score
)
;
}
}
)
;
}
VisibleForTesting
static
void
sortDescendingByScore
(
List
<
HighlightCandidate
>
candidates
)
{
sort
(
candidates
new
Comparator
<
HighlightCandidate
>
(
)
{
Override
public
int
compare
(
HighlightCandidate
lhs
HighlightCandidate
rhs
)
{
if
(
lhs
.
getScore
(
)
>
rhs
.
getScore
(
)
)
{
return
-
1
;
}
else
if
(
rhs
.
getScore
(
)
>
lhs
.
getScore
(
)
)
{
return
1
;
}
else
{
return
0
;
}
}
}
)
;
}
VisibleForTesting
static
void
filterOutItemsWithNoScore
(
List
<
HighlightCandidate
>
candidates
)
{
filter
(
candidates
new
Func1
<
HighlightCandidate
Boolean
>
(
)
{
Override
public
Boolean
call
(
HighlightCandidate
candidate
)
{
return
candidate
.
getScore
(
)
>
0
;
}
}
)
;
}
VisibleForTesting
static
void
adjustConsecutiveEntries
(
List
<
HighlightCandidate
>
candidates
)
{
if
(
candidates
.
size
(
)
<
2
)
{
return
;
}
final
double
[
]
penalty
=
new
double
[
]
{
0
.
8
}
;
applyInPairs
(
candidates
new
Action2
<
HighlightCandidate
HighlightCandidate
>
(
)
{
Override
public
void
call
(
HighlightCandidate
previous
HighlightCandidate
next
)
{
boolean
hasImage
=
previous
.
features
.
get
(
FEATURE_IMAGE_COUNT
)
>
0
&
&
next
.
features
.
get
(
FEATURE_IMAGE_COUNT
)
>
0
;
boolean
similar
=
previous
.
getHost
(
)
.
equals
(
next
.
getHost
(
)
)
;
similar
|
=
hasImage
&
&
next
.
getFastImageUrlForComparison
(
)
.
equals
(
previous
.
getFastImageUrlForComparison
(
)
)
;
if
(
similar
)
{
next
.
updateScore
(
next
.
getScore
(
)
*
penalty
[
0
]
)
;
penalty
[
0
]
-
=
0
.
2
;
}
else
{
penalty
[
0
]
=
0
.
8
;
}
}
}
)
;
}
VisibleForTesting
static
void
dedupeSites
(
List
<
HighlightCandidate
>
candidates
)
{
final
Set
<
String
>
knownHosts
=
new
HashSet
<
String
>
(
)
;
filter
(
candidates
new
Func1
<
HighlightCandidate
Boolean
>
(
)
{
Override
public
Boolean
call
(
HighlightCandidate
candidate
)
{
return
knownHosts
.
add
(
candidate
.
getHost
(
)
)
;
}
}
)
;
}
VisibleForTesting
static
List
<
Highlight
>
createHighlightsList
(
List
<
HighlightCandidate
>
candidates
int
limit
)
{
return
mapWithLimit
(
candidates
new
Func1
<
HighlightCandidate
Highlight
>
(
)
{
Override
public
Highlight
call
(
HighlightCandidate
candidate
)
{
return
candidate
.
getHighlight
(
)
;
}
}
limit
)
;
}
private
static
double
decay
(
double
initialScore
HighlightCandidate
.
Features
features
final
HighlightCandidate
.
Features
weights
)
{
double
sumOfWeightedFeatures
=
0
;
for
(
int
i
=
0
;
i
<
HIGHLIGHT_WEIGHT_FEATURES
.
length
;
i
+
+
)
{
final
HighlightCandidate
.
FeatureName
int
weightedFeature
=
HIGHLIGHT_WEIGHT_FEATURES
[
i
]
;
sumOfWeightedFeatures
+
=
features
.
get
(
weightedFeature
)
+
weights
.
get
(
weightedFeature
)
;
}
return
initialScore
*
Math
.
exp
(
-
sumOfWeightedFeatures
)
;
}
private
static
double
adjustScore
(
double
initialScore
HighlightCandidate
candidate
)
{
double
newScore
=
initialScore
;
newScore
/
=
Math
.
pow
(
1
+
candidate
.
features
.
get
(
FEATURE_AGE_IN_DAYS
)
2
)
;
if
(
candidate
.
features
.
get
(
FEATURE_IMAGE_COUNT
)
=
=
0
)
{
newScore
=
0
;
}
if
(
candidate
.
features
.
get
(
FEATURE_PATH_LENGTH
)
=
=
0
|
|
candidate
.
features
.
get
(
FEATURE_DESCRIPTION_LENGTH
)
=
=
0
)
{
newScore
*
=
0
.
2
;
}
final
double
bookmarkAge
=
candidate
.
features
.
get
(
FEATURE_BOOKMARK_AGE_IN_MILLISECONDS
)
;
if
(
bookmarkAge
>
0
)
{
newScore
+
=
BOOKMARK_AGE_DIVIDEND
/
bookmarkAge
;
}
return
newScore
;
}
}
