package
org
.
mozilla
.
gecko
.
activitystream
.
ranking
;
import
android
.
database
.
Cursor
;
import
android
.
support
.
annotation
.
VisibleForTesting
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
activitystream
.
homepanel
.
model
.
Highlight
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
static
java
.
util
.
Collections
.
sort
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Action1
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Action2
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Func1
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
Func2
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
apply
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
apply2D
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
applyInPairs
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
filter
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
looselyMapCursor
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
mapWithLimit
;
import
static
org
.
mozilla
.
gecko
.
activitystream
.
ranking
.
RankingUtils
.
reduce
;
public
class
HighlightsRanking
{
private
static
final
String
LOG_TAG
=
"
HighlightsRanking
"
;
private
static
final
Map
<
String
Double
>
HIGHLIGHT_WEIGHTS
=
new
HashMap
<
>
(
)
;
static
{
HIGHLIGHT_WEIGHTS
.
put
(
HighlightCandidate
.
FEATURE_VISITS_COUNT
-
0
.
1
)
;
HIGHLIGHT_WEIGHTS
.
put
(
HighlightCandidate
.
FEATURE_DESCRIPTION_LENGTH
-
0
.
1
)
;
HIGHLIGHT_WEIGHTS
.
put
(
HighlightCandidate
.
FEATURE_PATH_LENGTH
-
0
.
1
)
;
HIGHLIGHT_WEIGHTS
.
put
(
HighlightCandidate
.
FEATURE_QUERY_LENGTH
0
.
4
)
;
HIGHLIGHT_WEIGHTS
.
put
(
HighlightCandidate
.
FEATURE_IMAGE_SIZE
0
.
2
)
;
}
private
static
final
List
<
String
>
NORMALIZATION_FEATURES
=
Arrays
.
asList
(
HighlightCandidate
.
FEATURE_DESCRIPTION_LENGTH
HighlightCandidate
.
FEATURE_PATH_LENGTH
HighlightCandidate
.
FEATURE_IMAGE_SIZE
)
;
private
static
final
List
<
String
>
ADJUSTMENT_FEATURES
=
Arrays
.
asList
(
HighlightCandidate
.
FEATURE_BOOKMARK_AGE_IN_MILLISECONDS
HighlightCandidate
.
FEATURE_IMAGE_COUNT
HighlightCandidate
.
FEATURE_AGE_IN_DAYS
HighlightCandidate
.
FEATURE_DOMAIN_FREQUENCY
)
;
private
static
final
double
BOOKMARK_AGE_DIVIDEND
=
3
*
24
*
60
*
60
*
1000
;
public
static
List
<
Highlight
>
rank
(
Cursor
cursor
int
limit
)
{
List
<
HighlightCandidate
>
highlights
=
extractFeatures
(
cursor
)
;
normalize
(
highlights
)
;
scoreEntries
(
highlights
)
;
filterOutItemsWithNoScore
(
highlights
)
;
sortDescendingByScore
(
highlights
)
;
adjustConsecutiveEntries
(
highlights
)
;
dedupeSites
(
highlights
)
;
sortDescendingByScore
(
highlights
)
;
return
createHighlightsList
(
highlights
limit
)
;
}
VisibleForTesting
static
List
<
HighlightCandidate
>
extractFeatures
(
final
Cursor
cursor
)
{
final
HighlightCandidateCursorIndices
cursorIndices
=
new
HighlightCandidateCursorIndices
(
cursor
)
;
return
looselyMapCursor
(
cursor
new
Func1
<
Cursor
HighlightCandidate
>
(
)
{
Override
public
HighlightCandidate
call
(
Cursor
cursor
)
{
try
{
return
HighlightCandidate
.
fromCursor
(
cursor
cursorIndices
)
;
}
catch
(
HighlightCandidate
.
InvalidHighlightCandidateException
e
)
{
Log
.
w
(
LOG_TAG
"
Skipping
invalid
highlight
item
"
e
)
;
return
null
;
}
}
}
)
;
}
VisibleForTesting
static
void
normalize
(
List
<
HighlightCandidate
>
candidates
)
{
final
HashMap
<
String
double
[
]
>
minMaxValues
=
new
HashMap
<
>
(
)
;
apply2D
(
candidates
NORMALIZATION_FEATURES
new
Action2
<
HighlightCandidate
String
>
(
)
{
Override
public
void
call
(
HighlightCandidate
candidate
String
feature
)
{
double
[
]
minMaxForFeature
=
minMaxValues
.
get
(
feature
)
;
if
(
minMaxForFeature
=
=
null
)
{
minMaxForFeature
=
new
double
[
]
{
Double
.
MAX_VALUE
Double
.
MIN_VALUE
}
;
minMaxValues
.
put
(
feature
minMaxForFeature
)
;
}
minMaxForFeature
[
0
]
=
Math
.
min
(
minMaxForFeature
[
0
]
candidate
.
getFeatureValue
(
feature
)
)
;
minMaxForFeature
[
1
]
=
Math
.
max
(
minMaxForFeature
[
1
]
candidate
.
getFeatureValue
(
feature
)
)
;
}
}
)
;
apply2D
(
candidates
NORMALIZATION_FEATURES
new
Action2
<
HighlightCandidate
String
>
(
)
{
Override
public
void
call
(
HighlightCandidate
candidate
String
feature
)
{
double
[
]
minMaxForFeature
=
minMaxValues
.
get
(
feature
)
;
double
value
=
candidate
.
getFeatureValue
(
feature
)
;
candidate
.
setFeatureValue
(
feature
RankingUtils
.
normalize
(
value
minMaxForFeature
[
0
]
minMaxForFeature
[
1
]
)
)
;
}
}
)
;
}
VisibleForTesting
static
void
scoreEntries
(
List
<
HighlightCandidate
>
highlights
)
{
apply
(
highlights
new
Action1
<
HighlightCandidate
>
(
)
{
Override
public
void
call
(
HighlightCandidate
candidate
)
{
final
Map
<
String
Double
>
featuresForWeighting
=
candidate
.
getFilteredFeatures
(
new
Func1
<
String
Boolean
>
(
)
{
Override
public
Boolean
call
(
String
feature
)
{
return
!
ADJUSTMENT_FEATURES
.
contains
(
feature
)
;
}
}
)
;
final
double
initialScore
=
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_VISITS_COUNT
)
*
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_DOMAIN_FREQUENCY
)
;
final
double
score
=
adjustScore
(
decay
(
initialScore
featuresForWeighting
HIGHLIGHT_WEIGHTS
)
candidate
)
;
candidate
.
updateScore
(
score
)
;
}
}
)
;
}
VisibleForTesting
static
void
sortDescendingByScore
(
List
<
HighlightCandidate
>
candidates
)
{
sort
(
candidates
new
Comparator
<
HighlightCandidate
>
(
)
{
Override
public
int
compare
(
HighlightCandidate
lhs
HighlightCandidate
rhs
)
{
if
(
lhs
.
getScore
(
)
>
rhs
.
getScore
(
)
)
{
return
-
1
;
}
else
if
(
rhs
.
getScore
(
)
>
lhs
.
getScore
(
)
)
{
return
1
;
}
else
{
return
0
;
}
}
}
)
;
}
VisibleForTesting
static
void
filterOutItemsWithNoScore
(
List
<
HighlightCandidate
>
candidates
)
{
filter
(
candidates
new
Func1
<
HighlightCandidate
Boolean
>
(
)
{
Override
public
Boolean
call
(
HighlightCandidate
candidate
)
{
return
candidate
.
getScore
(
)
>
0
;
}
}
)
;
}
VisibleForTesting
static
void
adjustConsecutiveEntries
(
List
<
HighlightCandidate
>
candidates
)
{
if
(
candidates
.
size
(
)
<
2
)
{
return
;
}
final
double
[
]
penalty
=
new
double
[
]
{
0
.
8
}
;
applyInPairs
(
candidates
new
Action2
<
HighlightCandidate
HighlightCandidate
>
(
)
{
Override
public
void
call
(
HighlightCandidate
previous
HighlightCandidate
next
)
{
boolean
hasImage
=
previous
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_IMAGE_COUNT
)
>
0
&
&
next
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_IMAGE_COUNT
)
>
0
;
boolean
similar
=
previous
.
getHost
(
)
.
equals
(
next
.
getHost
(
)
)
;
similar
|
=
hasImage
&
&
next
.
getImageUrl
(
)
.
equals
(
previous
.
getImageUrl
(
)
)
;
if
(
similar
)
{
next
.
updateScore
(
next
.
getScore
(
)
*
penalty
[
0
]
)
;
penalty
[
0
]
-
=
0
.
2
;
}
else
{
penalty
[
0
]
=
0
.
8
;
}
}
}
)
;
}
VisibleForTesting
static
void
dedupeSites
(
List
<
HighlightCandidate
>
candidates
)
{
final
Set
<
String
>
knownHosts
=
new
HashSet
<
String
>
(
)
;
filter
(
candidates
new
Func1
<
HighlightCandidate
Boolean
>
(
)
{
Override
public
Boolean
call
(
HighlightCandidate
candidate
)
{
return
knownHosts
.
add
(
candidate
.
getHost
(
)
)
;
}
}
)
;
}
VisibleForTesting
static
List
<
Highlight
>
createHighlightsList
(
List
<
HighlightCandidate
>
candidates
int
limit
)
{
return
mapWithLimit
(
candidates
new
Func1
<
HighlightCandidate
Highlight
>
(
)
{
Override
public
Highlight
call
(
HighlightCandidate
candidate
)
{
return
candidate
.
getHighlight
(
)
;
}
}
limit
)
;
}
private
static
double
decay
(
double
initialScore
Map
<
String
Double
>
features
final
Map
<
String
Double
>
weights
)
{
if
(
features
.
size
(
)
!
=
weights
.
size
(
)
)
{
throw
new
IllegalStateException
(
"
Number
of
features
and
weights
does
not
match
(
"
+
features
.
size
(
)
+
"
!
=
"
+
weights
.
size
(
)
)
;
}
double
sumOfWeightedFeatures
=
reduce
(
features
.
entrySet
(
)
new
Func2
<
Map
.
Entry
<
String
Double
>
Double
Double
>
(
)
{
Override
public
Double
call
(
Map
.
Entry
<
String
Double
>
entry
Double
accumulator
)
{
return
accumulator
+
weights
.
get
(
entry
.
getKey
(
)
)
*
entry
.
getValue
(
)
;
}
}
0d
)
;
return
initialScore
*
Math
.
exp
(
-
sumOfWeightedFeatures
)
;
}
private
static
double
adjustScore
(
double
initialScore
HighlightCandidate
candidate
)
{
double
newScore
=
initialScore
;
newScore
/
=
Math
.
pow
(
1
+
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_AGE_IN_DAYS
)
2
)
;
if
(
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_IMAGE_COUNT
)
=
=
0
)
{
newScore
=
0
;
}
if
(
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_PATH_LENGTH
)
=
=
0
|
|
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_DESCRIPTION_LENGTH
)
=
=
0
)
{
newScore
*
=
0
.
2
;
}
double
bookmarkAge
=
candidate
.
getFeatureValue
(
HighlightCandidate
.
FEATURE_BOOKMARK_AGE_IN_MILLISECONDS
)
;
if
(
bookmarkAge
>
0
)
{
newScore
+
=
BOOKMARK_AGE_DIVIDEND
/
bookmarkAge
;
}
return
newScore
;
}
}
