package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
animation
.
ViewHelper
;
import
org
.
mozilla
.
gecko
.
gfx
.
FloatSize
;
import
org
.
mozilla
.
gecko
.
gfx
.
ImmutableViewportMetrics
;
import
org
.
mozilla
.
gecko
.
util
.
ActivityUtils
;
import
org
.
mozilla
.
gecko
.
util
.
BundleEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
EventCallback
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
mozilla
.
gecko
.
widget
.
SwipeDismissListViewTouchListener
;
import
org
.
mozilla
.
gecko
.
widget
.
SwipeDismissListViewTouchListener
.
OnDismissCallback
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Resources
;
import
android
.
graphics
.
PointF
;
import
android
.
util
.
AttributeSet
;
import
android
.
util
.
Log
;
import
android
.
util
.
Pair
;
import
android
.
view
.
LayoutInflater
;
import
android
.
view
.
View
;
import
android
.
view
.
ViewGroup
;
import
android
.
view
.
animation
.
Animation
;
import
android
.
view
.
animation
.
AnimationUtils
;
import
android
.
view
.
inputmethod
.
InputMethodManager
;
import
android
.
widget
.
AdapterView
;
import
android
.
widget
.
AdapterView
.
OnItemClickListener
;
import
android
.
widget
.
ArrayAdapter
;
import
android
.
widget
.
ImageView
;
import
android
.
widget
.
ListView
;
import
android
.
widget
.
RelativeLayout
;
import
android
.
widget
.
RelativeLayout
.
LayoutParams
;
import
android
.
widget
.
TextView
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
public
class
FormAssistPopup
extends
RelativeLayout
implements
BundleEventListener
{
private
final
Animation
mAnimation
;
private
ListView
mAutoCompleteList
;
private
RelativeLayout
mValidationMessage
;
private
TextView
mValidationMessageText
;
private
ImageView
mValidationMessageArrow
;
private
ImageView
mValidationMessageArrowInverted
;
private
GeckoView
mGeckoView
;
private
EventCallback
mAutoCompleteCallback
;
private
double
mX
;
private
double
mY
;
private
double
mW
;
private
double
mH
;
private
enum
PopupType
{
AUTOCOMPLETE
VALIDATIONMESSAGE
;
}
private
PopupType
mPopupType
;
private
static
final
int
MAX_VISIBLE_ROWS
=
5
;
private
static
int
sAutoCompleteMinWidth
;
private
static
int
sAutoCompleteRowHeight
;
private
static
int
sValidationMessageHeight
;
private
static
int
sValidationTextMarginTop
;
private
static
LayoutParams
sValidationTextLayoutNormal
;
private
static
LayoutParams
sValidationTextLayoutInverted
;
private
static
final
String
LOGTAG
=
"
GeckoFormAssistPopup
"
;
private
static
final
Collection
<
String
>
sInputMethodBlocklist
=
Arrays
.
asList
(
InputMethods
.
METHOD_GOOGLE_JAPANESE_INPUT
InputMethods
.
METHOD_OPENWNN_PLUS
InputMethods
.
METHOD_SIMEJI
InputMethods
.
METHOD_SWYPE
InputMethods
.
METHOD_SWYPE_BETA
)
;
public
FormAssistPopup
(
Context
context
AttributeSet
attrs
)
{
super
(
context
attrs
)
;
mAnimation
=
AnimationUtils
.
loadAnimation
(
context
R
.
anim
.
grow_fade_in
)
;
mAnimation
.
setDuration
(
75
)
;
setFocusable
(
false
)
;
}
public
void
create
(
final
GeckoView
view
)
{
mGeckoView
=
view
;
mGeckoView
.
getEventDispatcher
(
)
.
registerUiThreadListener
(
this
"
FormAssist
:
AutoCompleteResult
"
"
FormAssist
:
ValidationMessage
"
"
FormAssist
:
Hide
"
)
;
}
public
void
destroy
(
)
{
mGeckoView
.
getEventDispatcher
(
)
.
unregisterUiThreadListener
(
this
"
FormAssist
:
AutoCompleteResult
"
"
FormAssist
:
ValidationMessage
"
"
FormAssist
:
Hide
"
)
;
mGeckoView
=
null
;
}
Override
public
void
handleMessage
(
final
String
event
final
GeckoBundle
message
final
EventCallback
callback
)
{
if
(
"
FormAssist
:
AutoCompleteResult
"
.
equals
(
event
)
)
{
mAutoCompleteCallback
=
callback
;
showAutoCompleteSuggestions
(
message
.
getBundleArray
(
"
suggestions
"
)
message
.
getBundle
(
"
rect
"
)
message
.
getBoolean
(
"
isEmpty
"
)
)
;
}
else
if
(
"
FormAssist
:
ValidationMessage
"
.
equals
(
event
)
)
{
showValidationMessage
(
message
.
getString
(
"
validationMessage
"
)
message
.
getBundle
(
"
rect
"
)
)
;
}
else
if
(
"
FormAssist
:
Hide
"
.
equals
(
event
)
)
{
hide
(
)
;
}
}
private
void
showAutoCompleteSuggestions
(
final
GeckoBundle
[
]
suggestions
final
GeckoBundle
rect
final
boolean
isEmpty
)
{
final
String
inputMethod
=
InputMethods
.
getCurrentInputMethod
(
getContext
(
)
)
;
if
(
!
isEmpty
&
&
sInputMethodBlocklist
.
contains
(
inputMethod
)
)
{
hide
(
)
;
return
;
}
if
(
mAutoCompleteList
=
=
null
)
{
LayoutInflater
inflater
=
LayoutInflater
.
from
(
getContext
(
)
)
;
mAutoCompleteList
=
(
ListView
)
inflater
.
inflate
(
R
.
layout
.
autocomplete_list
null
)
;
mAutoCompleteList
.
setOnItemClickListener
(
new
OnItemClickListener
(
)
{
Override
public
void
onItemClick
(
final
AdapterView
<
?
>
parentView
final
View
view
final
int
position
final
long
id
)
{
if
(
mAutoCompleteCallback
=
=
null
)
{
hide
(
)
;
return
;
}
final
TextView
textView
=
(
TextView
)
view
;
final
GeckoBundle
message
=
new
GeckoBundle
(
2
)
;
message
.
putString
(
"
action
"
"
autocomplete
"
)
;
message
.
putString
(
"
value
"
(
String
)
textView
.
getTag
(
)
)
;
mAutoCompleteCallback
.
sendSuccess
(
message
)
;
hide
(
)
;
}
}
)
;
final
SwipeDismissListViewTouchListener
touchListener
=
new
SwipeDismissListViewTouchListener
(
mAutoCompleteList
new
OnDismissCallback
(
)
{
Override
public
void
onDismiss
(
ListView
listView
final
int
position
)
{
if
(
mAutoCompleteCallback
=
=
null
)
{
return
;
}
AutoCompleteListAdapter
adapter
=
(
AutoCompleteListAdapter
)
listView
.
getAdapter
(
)
;
Pair
<
String
String
>
item
=
adapter
.
getItem
(
position
)
;
final
GeckoBundle
message
=
new
GeckoBundle
(
2
)
;
message
.
putString
(
"
action
"
"
remove
"
)
;
message
.
putString
(
"
value
"
item
.
second
)
;
mAutoCompleteCallback
.
sendSuccess
(
message
)
;
adapter
.
remove
(
item
)
;
adapter
.
notifyDataSetChanged
(
)
;
positionAndShowPopup
(
)
;
}
}
)
;
mAutoCompleteList
.
setOnTouchListener
(
touchListener
)
;
mAutoCompleteList
.
setOnScrollListener
(
touchListener
.
makeScrollListener
(
)
)
;
mAutoCompleteList
.
setRecyclerListener
(
touchListener
.
makeRecyclerListener
(
)
)
;
addView
(
mAutoCompleteList
)
;
}
AutoCompleteListAdapter
adapter
=
new
AutoCompleteListAdapter
(
getContext
(
)
R
.
layout
.
autocomplete_list_item
)
;
adapter
.
populateSuggestionsList
(
suggestions
)
;
mAutoCompleteList
.
setAdapter
(
adapter
)
;
if
(
setGeckoPositionData
(
rect
true
)
)
{
positionAndShowPopup
(
)
;
}
}
private
void
showValidationMessage
(
final
String
validationMessage
final
GeckoBundle
rect
)
{
if
(
mValidationMessage
=
=
null
)
{
LayoutInflater
inflater
=
LayoutInflater
.
from
(
getContext
(
)
)
;
mValidationMessage
=
(
RelativeLayout
)
inflater
.
inflate
(
R
.
layout
.
validation_message
null
)
;
addView
(
mValidationMessage
)
;
mValidationMessageText
=
(
TextView
)
mValidationMessage
.
findViewById
(
R
.
id
.
validation_message_text
)
;
sValidationTextMarginTop
=
(
int
)
(
getContext
(
)
.
getResources
(
)
.
getDimension
(
R
.
dimen
.
validation_message_margin_top
)
)
;
sValidationTextLayoutNormal
=
new
LayoutParams
(
mValidationMessageText
.
getLayoutParams
(
)
)
;
sValidationTextLayoutNormal
.
setMargins
(
0
sValidationTextMarginTop
0
0
)
;
sValidationTextLayoutInverted
=
new
LayoutParams
(
(
ViewGroup
.
MarginLayoutParams
)
sValidationTextLayoutNormal
)
;
sValidationTextLayoutInverted
.
setMargins
(
0
0
0
0
)
;
mValidationMessageArrow
=
(
ImageView
)
mValidationMessage
.
findViewById
(
R
.
id
.
validation_message_arrow
)
;
mValidationMessageArrowInverted
=
(
ImageView
)
mValidationMessage
.
findViewById
(
R
.
id
.
validation_message_arrow_inverted
)
;
}
mValidationMessageText
.
setText
(
validationMessage
)
;
mValidationMessageText
.
setSelected
(
true
)
;
if
(
setGeckoPositionData
(
rect
false
)
)
{
positionAndShowPopup
(
)
;
}
}
private
boolean
setGeckoPositionData
(
final
GeckoBundle
rect
final
boolean
isAutoComplete
)
{
mX
=
rect
.
getDouble
(
"
x
"
)
;
mY
=
rect
.
getDouble
(
"
y
"
)
;
mW
=
rect
.
getDouble
(
"
w
"
)
;
mH
=
rect
.
getDouble
(
"
h
"
)
;
mPopupType
=
(
isAutoComplete
?
PopupType
.
AUTOCOMPLETE
:
PopupType
.
VALIDATIONMESSAGE
)
;
return
true
;
}
private
void
positionAndShowPopup
(
)
{
positionAndShowPopup
(
mGeckoView
.
getViewportMetrics
(
)
)
;
}
private
void
positionAndShowPopup
(
ImmutableViewportMetrics
aMetrics
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
InputMethodManager
imm
=
(
InputMethodManager
)
getContext
(
)
.
getSystemService
(
Context
.
INPUT_METHOD_SERVICE
)
;
if
(
imm
.
isFullscreenMode
(
)
)
{
return
;
}
if
(
mAutoCompleteList
!
=
null
)
{
mAutoCompleteList
.
setVisibility
(
(
mPopupType
=
=
PopupType
.
AUTOCOMPLETE
)
?
VISIBLE
:
GONE
)
;
}
if
(
mValidationMessage
!
=
null
)
{
mValidationMessage
.
setVisibility
(
(
mPopupType
=
=
PopupType
.
AUTOCOMPLETE
)
?
GONE
:
VISIBLE
)
;
}
if
(
sAutoCompleteMinWidth
=
=
0
)
{
Resources
res
=
getContext
(
)
.
getResources
(
)
;
sAutoCompleteMinWidth
=
(
int
)
(
res
.
getDimension
(
R
.
dimen
.
autocomplete_min_width
)
)
;
sAutoCompleteRowHeight
=
(
int
)
(
res
.
getDimension
(
R
.
dimen
.
autocomplete_row_height
)
)
;
sValidationMessageHeight
=
(
int
)
(
res
.
getDimension
(
R
.
dimen
.
validation_message_height
)
)
;
}
float
zoom
=
aMetrics
.
zoomFactor
;
int
left
=
(
int
)
(
mX
*
zoom
-
aMetrics
.
viewportRectLeft
)
;
int
top
=
(
int
)
(
mY
*
zoom
-
aMetrics
.
viewportRectTop
+
mGeckoView
.
getTop
(
)
+
mGeckoView
.
getCurrentToolbarHeight
(
)
)
;
int
width
=
(
int
)
(
mW
*
zoom
)
;
int
height
=
(
int
)
(
mH
*
zoom
)
;
int
popupWidth
=
LayoutParams
.
MATCH_PARENT
;
int
popupLeft
=
left
<
0
?
0
:
left
;
FloatSize
viewport
=
aMetrics
.
getSize
(
)
;
if
(
(
mPopupType
=
=
PopupType
.
AUTOCOMPLETE
)
&
&
(
left
+
width
)
<
viewport
.
width
)
{
popupWidth
=
left
<
0
?
left
+
width
:
width
;
if
(
popupWidth
<
sAutoCompleteMinWidth
)
{
popupWidth
=
sAutoCompleteMinWidth
;
if
(
(
popupLeft
+
popupWidth
)
>
viewport
.
width
)
{
popupLeft
=
(
int
)
(
viewport
.
width
-
popupWidth
)
;
}
}
}
int
popupHeight
;
if
(
mPopupType
=
=
PopupType
.
AUTOCOMPLETE
)
{
int
rows
=
mAutoCompleteList
.
getAdapter
(
)
.
getCount
(
)
;
if
(
rows
>
MAX_VISIBLE_ROWS
)
{
rows
=
MAX_VISIBLE_ROWS
;
}
popupHeight
=
sAutoCompleteRowHeight
*
rows
;
}
else
{
popupHeight
=
sValidationMessageHeight
;
}
int
popupTop
=
top
+
height
;
if
(
mPopupType
=
=
PopupType
.
VALIDATIONMESSAGE
)
{
mValidationMessageText
.
setLayoutParams
(
sValidationTextLayoutNormal
)
;
mValidationMessageArrow
.
setVisibility
(
VISIBLE
)
;
mValidationMessageArrowInverted
.
setVisibility
(
GONE
)
;
}
if
(
(
popupTop
+
popupHeight
)
>
(
mGeckoView
.
getTop
(
)
+
viewport
.
height
)
)
{
if
(
(
viewport
.
height
-
popupTop
)
>
top
)
{
popupHeight
=
(
int
)
(
viewport
.
height
-
popupTop
)
;
}
else
{
if
(
popupHeight
<
top
)
{
popupTop
=
(
top
-
popupHeight
)
;
}
else
{
popupTop
=
0
;
popupHeight
=
top
;
}
if
(
mPopupType
=
=
PopupType
.
VALIDATIONMESSAGE
)
{
mValidationMessageText
.
setLayoutParams
(
sValidationTextLayoutInverted
)
;
mValidationMessageArrow
.
setVisibility
(
GONE
)
;
mValidationMessageArrowInverted
.
setVisibility
(
VISIBLE
)
;
}
}
}
LayoutParams
layoutParams
=
new
LayoutParams
(
popupWidth
popupHeight
)
;
layoutParams
.
setMargins
(
popupLeft
popupTop
0
0
)
;
setLayoutParams
(
layoutParams
)
;
requestLayout
(
)
;
if
(
!
isShown
(
)
)
{
setVisibility
(
VISIBLE
)
;
startAnimation
(
mAnimation
)
;
}
}
public
void
hide
(
)
{
if
(
isShown
(
)
)
{
setVisibility
(
GONE
)
;
}
mAutoCompleteCallback
=
null
;
}
void
onTranslationChanged
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
!
isShown
(
)
)
{
return
;
}
positionAndShowPopup
(
)
;
}
void
onMetricsChanged
(
final
ImmutableViewportMetrics
aMetrics
)
{
if
(
!
isShown
(
)
)
{
return
;
}
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
positionAndShowPopup
(
aMetrics
)
;
}
}
)
;
}
private
static
final
class
AutoCompleteListAdapter
extends
ArrayAdapter
<
Pair
<
String
String
>
>
{
private
final
LayoutInflater
mInflater
;
private
final
int
mTextViewResourceId
;
public
AutoCompleteListAdapter
(
Context
context
int
textViewResourceId
)
{
super
(
context
textViewResourceId
)
;
mInflater
=
(
LayoutInflater
)
context
.
getSystemService
(
Context
.
LAYOUT_INFLATER_SERVICE
)
;
mTextViewResourceId
=
textViewResourceId
;
}
public
void
populateSuggestionsList
(
final
GeckoBundle
[
]
suggestions
)
{
for
(
int
i
=
0
;
i
<
suggestions
.
length
;
i
+
+
)
{
final
GeckoBundle
suggestion
=
suggestions
[
i
]
;
final
String
label
=
suggestion
.
getString
(
"
label
"
)
;
final
String
value
=
suggestion
.
getString
(
"
value
"
)
;
add
(
new
Pair
<
String
String
>
(
label
value
)
)
;
}
}
Override
public
View
getView
(
int
position
View
convertView
ViewGroup
parent
)
{
if
(
convertView
=
=
null
)
{
convertView
=
mInflater
.
inflate
(
mTextViewResourceId
null
)
;
}
Pair
<
String
String
>
item
=
getItem
(
position
)
;
TextView
itemView
=
(
TextView
)
convertView
;
itemView
.
setText
(
item
.
first
)
;
itemView
.
setTag
(
item
.
second
)
;
return
convertView
;
}
}
}
