package
org
.
mozilla
.
gecko
.
notifications
;
import
android
.
app
.
Notification
;
import
android
.
app
.
PendingIntent
;
import
android
.
content
.
Context
;
import
android
.
content
.
Intent
;
import
android
.
net
.
Uri
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
org
.
mozilla
.
gecko
.
AppConstants
;
import
org
.
mozilla
.
gecko
.
GeckoApp
;
import
org
.
mozilla
.
gecko
.
GeckoAppShell
;
import
org
.
mozilla
.
gecko
.
GeckoService
;
import
org
.
mozilla
.
gecko
.
NotificationListener
;
public
abstract
class
NotificationClient
implements
NotificationListener
{
private
static
final
String
LOGTAG
=
"
GeckoNotificationClient
"
;
private
volatile
NotificationHandler
mHandler
;
private
boolean
mReady
;
private
final
LinkedList
<
Runnable
>
mTaskQueue
=
new
LinkedList
<
Runnable
>
(
)
;
Override
public
void
showNotification
(
String
name
String
cookie
String
title
String
text
String
host
String
imageUrl
)
{
final
Intent
notificationIntent
=
new
Intent
(
GeckoApp
.
ACTION_ALERT_CALLBACK
)
;
notificationIntent
.
setClassName
(
AppConstants
.
ANDROID_PACKAGE_NAME
AppConstants
.
MOZ_ANDROID_BROWSER_INTENT_CLASS
)
;
notificationIntent
.
setFlags
(
Intent
.
FLAG_ACTIVITY_NEW_TASK
)
;
final
Uri
.
Builder
b
=
new
Uri
.
Builder
(
)
;
final
Uri
dataUri
=
b
.
scheme
(
"
alert
"
)
.
appendQueryParameter
(
"
name
"
name
)
.
appendQueryParameter
(
"
cookie
"
cookie
)
.
build
(
)
;
notificationIntent
.
setData
(
dataUri
)
;
final
PendingIntent
clickIntent
=
PendingIntent
.
getActivity
(
GeckoAppShell
.
getApplicationContext
(
)
0
notificationIntent
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
add
(
name
imageUrl
host
title
text
clickIntent
null
)
;
GeckoAppShell
.
onNotificationShow
(
name
)
;
}
Override
public
void
showPersistentNotification
(
String
name
String
cookie
String
title
String
text
String
host
String
imageUrl
String
data
)
{
final
Context
context
=
GeckoAppShell
.
getApplicationContext
(
)
;
final
PendingIntent
clickIntent
=
PendingIntent
.
getService
(
context
0
GeckoService
.
getIntentToCreateServices
(
context
"
persistent
-
notification
-
click
"
data
)
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
final
PendingIntent
closeIntent
=
PendingIntent
.
getService
(
context
0
GeckoService
.
getIntentToCreateServices
(
context
"
persistent
-
notification
-
close
"
data
)
PendingIntent
.
FLAG_UPDATE_CURRENT
)
;
add
(
name
imageUrl
host
title
text
clickIntent
closeIntent
)
;
GeckoAppShell
.
onNotificationShow
(
name
)
;
}
Override
public
void
closeNotification
(
String
name
)
{
remove
(
name
)
;
GeckoAppShell
.
onNotificationClose
(
name
)
;
}
public
void
onNotificationClick
(
String
name
)
{
GeckoAppShell
.
onNotificationClick
(
name
)
;
if
(
isOngoing
(
name
)
)
{
return
;
}
closeNotification
(
name
)
;
}
public
synchronized
void
add
(
final
String
aName
final
String
aImageUrl
final
String
aHost
final
String
aAlertTitle
final
String
aAlertText
final
PendingIntent
contentIntent
final
PendingIntent
deleteIntent
)
{
mTaskQueue
.
add
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mHandler
.
add
(
aName
aImageUrl
aHost
aAlertTitle
aAlertText
contentIntent
deleteIntent
)
;
}
}
)
;
notify
(
)
;
if
(
!
mReady
)
{
bind
(
)
;
}
}
public
synchronized
void
add
(
final
String
name
final
Notification
notification
)
{
mTaskQueue
.
add
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mHandler
.
add
(
name
notification
)
;
}
}
)
;
notify
(
)
;
if
(
!
mReady
)
{
bind
(
)
;
}
}
public
synchronized
void
remove
(
final
String
name
)
{
mTaskQueue
.
add
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mHandler
.
remove
(
name
)
;
}
}
)
;
if
(
!
mReady
)
{
bind
(
)
;
}
notify
(
)
;
}
public
boolean
isOngoing
(
String
name
)
{
final
NotificationHandler
handler
=
mHandler
;
return
handler
!
=
null
&
&
handler
.
isOngoing
(
name
)
;
}
protected
void
bind
(
)
{
mReady
=
true
;
}
protected
void
unbind
(
)
{
mReady
=
false
;
}
protected
void
connectHandler
(
NotificationHandler
handler
)
{
mHandler
=
handler
;
new
Thread
(
new
NotificationRunnable
(
)
)
.
start
(
)
;
}
private
class
NotificationRunnable
implements
Runnable
{
Override
public
void
run
(
)
{
Runnable
r
;
try
{
while
(
true
)
{
synchronized
(
NotificationClient
.
this
)
{
r
=
mTaskQueue
.
poll
(
)
;
while
(
r
=
=
null
)
{
if
(
mHandler
.
isDone
(
)
)
{
unbind
(
)
;
return
;
}
NotificationClient
.
this
.
wait
(
)
;
r
=
mTaskQueue
.
poll
(
)
;
}
}
r
.
run
(
)
;
}
}
catch
(
InterruptedException
e
)
{
Log
.
e
(
LOGTAG
"
Notification
task
queue
processing
interrupted
"
e
)
;
}
}
}
}
