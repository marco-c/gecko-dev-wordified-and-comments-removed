package
org
.
mozilla
.
gecko
.
reader
;
import
android
.
content
.
Context
;
import
android
.
support
.
annotation
.
NonNull
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
GeckoProfile
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
db
.
UrlAnnotations
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Iterator
;
public
class
SavedReaderViewHelper
{
private
static
final
String
LOG_TAG
=
"
SavedReaderViewHelper
"
;
private
static
final
String
PATH
=
"
path
"
;
private
static
final
String
SIZE
=
"
size
"
;
private
static
final
String
DIRECTORY
=
"
readercache
"
;
private
static
final
String
FILE_NAME
=
"
items
.
json
"
;
private
static
final
String
FILE_PATH
=
DIRECTORY
+
"
/
"
+
FILE_NAME
;
private
JSONObject
mItems
=
null
;
private
final
Context
mContext
;
private
static
SavedReaderViewHelper
instance
=
null
;
private
SavedReaderViewHelper
(
Context
context
)
{
mContext
=
context
;
}
public
static
synchronized
SavedReaderViewHelper
getSavedReaderViewHelper
(
final
Context
context
)
{
if
(
instance
=
=
null
)
{
instance
=
new
SavedReaderViewHelper
(
context
)
;
}
return
instance
;
}
public
synchronized
void
loadItems
(
)
{
if
(
mItems
!
=
null
)
{
return
;
}
try
{
mItems
=
GeckoProfile
.
get
(
mContext
)
.
readJSONObjectFromFile
(
FILE_PATH
)
;
}
catch
(
IOException
e
)
{
mItems
=
new
JSONObject
(
)
;
}
}
private
synchronized
void
assertItemsLoaded
(
)
{
if
(
mItems
=
=
null
)
{
throw
new
IllegalStateException
(
"
SavedReaderView
items
must
be
explicitly
loaded
using
loadItems
(
)
before
access
.
"
)
;
}
}
private
JSONObject
makeItem
(
NonNull
String
path
long
size
)
throws
JSONException
{
final
JSONObject
item
=
new
JSONObject
(
)
;
item
.
put
(
PATH
path
)
;
item
.
put
(
SIZE
size
)
;
return
item
;
}
public
synchronized
boolean
isURLCached
(
NonNull
final
String
URL
)
{
assertItemsLoaded
(
)
;
return
mItems
.
has
(
URL
)
;
}
public
synchronized
void
put
(
NonNull
final
String
pageURL
NonNull
final
String
path
final
long
size
)
{
assertItemsLoaded
(
)
;
try
{
mItems
.
put
(
pageURL
makeItem
(
path
size
)
)
;
}
catch
(
JSONException
e
)
{
Log
.
w
(
LOG_TAG
"
Item
insertion
failed
:
"
e
)
;
throw
new
IllegalStateException
(
"
Failure
inserting
into
SavedReaderViewHelper
json
"
)
;
}
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
UrlAnnotations
annotations
=
GeckoProfile
.
get
(
mContext
)
.
getDB
(
)
.
getUrlAnnotations
(
)
;
annotations
.
insertReaderViewUrl
(
mContext
.
getContentResolver
(
)
pageURL
)
;
commit
(
)
;
}
}
)
;
}
protected
synchronized
void
remove
(
NonNull
final
String
pageURL
)
{
assertItemsLoaded
(
)
;
mItems
.
remove
(
pageURL
)
;
ThreadUtils
.
postToBackgroundThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
UrlAnnotations
annotations
=
GeckoProfile
.
get
(
mContext
)
.
getDB
(
)
.
getUrlAnnotations
(
)
;
annotations
.
deleteReaderViewUrl
(
mContext
.
getContentResolver
(
)
pageURL
)
;
commit
(
)
;
}
}
)
;
}
RobocopTarget
public
synchronized
int
size
(
)
{
assertItemsLoaded
(
)
;
return
mItems
.
length
(
)
;
}
private
synchronized
void
commit
(
)
{
ThreadUtils
.
assertOnBackgroundThread
(
)
;
GeckoProfile
profile
=
GeckoProfile
.
get
(
mContext
)
;
File
cacheDir
=
new
File
(
profile
.
getDir
(
)
DIRECTORY
)
;
if
(
!
cacheDir
.
exists
(
)
)
{
Log
.
i
(
LOG_TAG
"
No
preexisting
cache
directory
creating
now
"
)
;
boolean
cacheDirCreated
=
cacheDir
.
mkdir
(
)
;
if
(
!
cacheDirCreated
)
{
throw
new
IllegalStateException
(
"
Couldn
'
t
create
cache
directory
unable
to
track
reader
view
cache
"
)
;
}
}
profile
.
writeFile
(
FILE_PATH
mItems
.
toString
(
)
)
;
}
public
static
String
getReaderURLIfCached
(
final
Context
context
NonNull
final
String
pageURL
)
{
SavedReaderViewHelper
rvh
=
getSavedReaderViewHelper
(
context
)
;
if
(
rvh
.
isURLCached
(
pageURL
)
)
{
return
ReaderModeUtils
.
getAboutReaderForUrl
(
pageURL
)
;
}
else
{
return
pageURL
;
}
}
public
synchronized
int
getDiskSpacedUsedKB
(
)
{
final
Iterator
<
String
>
keys
=
mItems
.
keys
(
)
;
long
bytes
=
0
;
while
(
keys
.
hasNext
(
)
)
{
final
String
pageURL
=
keys
.
next
(
)
;
try
{
final
JSONObject
item
=
mItems
.
getJSONObject
(
pageURL
)
;
bytes
+
=
item
.
getLong
(
SIZE
)
;
if
(
bytes
<
0
)
{
return
Integer
.
MAX_VALUE
;
}
}
catch
(
JSONException
e
)
{
throw
new
IllegalStateException
(
"
Must
be
able
to
access
items
in
saved
reader
view
list
"
e
)
;
}
}
long
kb
=
bytes
/
1024
;
if
(
kb
>
Integer
.
MAX_VALUE
)
{
return
Integer
.
MAX_VALUE
;
}
else
{
return
(
int
)
kb
;
}
}
}
