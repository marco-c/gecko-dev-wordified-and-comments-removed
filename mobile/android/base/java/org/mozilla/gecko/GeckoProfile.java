package
org
.
mozilla
.
gecko
;
import
android
.
app
.
Activity
;
import
android
.
content
.
ContentResolver
;
import
android
.
content
.
Context
;
import
android
.
content
.
SharedPreferences
;
import
android
.
support
.
annotation
.
WorkerThread
;
import
android
.
text
.
TextUtils
;
import
android
.
util
.
Log
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoMozillaDirectoryException
;
import
org
.
mozilla
.
gecko
.
GeckoProfileDirectories
.
NoSuchProfileException
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
db
.
BrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
LocalBrowserDB
;
import
org
.
mozilla
.
gecko
.
db
.
StubBrowserDB
;
import
org
.
mozilla
.
gecko
.
distribution
.
Distribution
;
import
org
.
mozilla
.
gecko
.
firstrun
.
FirstrunAnimationContainer
;
import
org
.
mozilla
.
gecko
.
preferences
.
DistroSharedPrefsImport
;
import
org
.
mozilla
.
gecko
.
util
.
FileUtils
;
import
org
.
mozilla
.
gecko
.
util
.
INIParser
;
import
org
.
mozilla
.
gecko
.
util
.
INISection
;
import
org
.
mozilla
.
gecko
.
util
.
IntentUtils
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
UUID
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
final
class
GeckoProfile
{
private
static
final
String
LOGTAG
=
"
GeckoProfile
"
;
private
static
final
String
CLIENT_ID_FILE_PATH
=
"
datareporting
/
state
.
json
"
;
private
static
final
String
FHR_CLIENT_ID_FILE_PATH
=
"
healthreport
/
state
.
json
"
;
private
static
final
String
CLIENT_ID_JSON_ATTR
=
"
clientID
"
;
private
static
final
String
TIMES_PATH
=
"
times
.
json
"
;
private
static
final
String
PROFILE_CREATION_DATE_JSON_ATTR
=
"
created
"
;
private
static
volatile
boolean
sAcceptDirectoryChanges
=
true
;
RobocopTarget
public
static
void
enableDirectoryChanges
(
)
{
Log
.
w
(
LOGTAG
"
Directory
changes
should
only
be
enabled
for
tests
.
And
even
then
it
'
s
a
bad
idea
.
"
)
;
sAcceptDirectoryChanges
=
true
;
}
public
static
final
String
DEFAULT_PROFILE
=
"
default
"
;
public
static
final
String
CUSTOM_PROFILE
=
"
"
;
public
static
final
String
GUEST_PROFILE_DIR
=
"
guest
"
;
private
static
final
String
SESSION_FILE
=
"
sessionstore
.
js
"
;
private
static
final
String
SESSION_FILE_BACKUP
=
"
sessionstore
.
bak
"
;
private
static
final
long
MAX_BACKUP_FILE_AGE
=
1000
*
3600
*
24
;
private
boolean
mOldSessionDataProcessed
=
false
;
private
static
final
HashMap
<
String
GeckoProfile
>
sProfileCache
=
new
HashMap
<
String
GeckoProfile
>
(
)
;
private
static
String
sDefaultProfileName
;
private
final
String
mName
;
private
final
File
mMozillaDir
;
private
final
Context
mApplicationContext
;
private
final
BrowserDB
mDB
;
private
File
mProfileDir
;
private
Boolean
mInGuestMode
;
public
static
GeckoProfile
initFromArgs
(
final
Context
context
final
String
args
)
{
if
(
GuestSession
.
shouldUse
(
context
)
)
{
final
GeckoProfile
guestProfile
=
getGuestProfile
(
context
)
;
if
(
guestProfile
!
=
null
)
{
return
guestProfile
;
}
GuestSession
.
leave
(
context
)
;
}
if
(
getGuestDir
(
context
)
.
isDirectory
(
)
)
{
final
GeckoProfile
guestProfile
=
getGuestProfile
(
context
)
;
if
(
guestProfile
!
=
null
)
{
removeProfile
(
context
guestProfile
)
;
}
}
String
profileName
=
null
;
String
profilePath
=
null
;
if
(
args
!
=
null
&
&
args
.
contains
(
"
-
P
"
)
)
{
final
Pattern
p
=
Pattern
.
compile
(
"
(
?
:
-
P
\
\
s
*
)
(
\
\
w
*
)
(
\
\
s
*
)
"
)
;
final
Matcher
m
=
p
.
matcher
(
args
)
;
if
(
m
.
find
(
)
)
{
profileName
=
m
.
group
(
1
)
;
}
}
if
(
args
!
=
null
&
&
args
.
contains
(
"
-
profile
"
)
)
{
final
Pattern
p
=
Pattern
.
compile
(
"
(
?
:
-
profile
\
\
s
*
)
(
\
\
S
*
)
(
\
\
s
*
)
"
)
;
final
Matcher
m
=
p
.
matcher
(
args
)
;
if
(
m
.
find
(
)
)
{
profilePath
=
m
.
group
(
1
)
;
}
}
if
(
profileName
=
=
null
&
&
profilePath
=
=
null
)
{
return
getDefaultProfile
(
context
)
;
}
return
GeckoProfile
.
get
(
context
profileName
profilePath
)
;
}
private
static
GeckoProfile
getDefaultProfile
(
Context
context
)
{
try
{
return
get
(
context
getDefaultProfileName
(
context
)
)
;
}
catch
(
final
NoMozillaDirectoryException
e
)
{
Log
.
wtf
(
LOGTAG
"
Unable
to
get
default
profile
name
.
"
e
)
;
throw
new
RuntimeException
(
e
)
;
}
}
public
static
GeckoProfile
get
(
Context
context
)
{
return
get
(
context
null
null
null
)
;
}
public
static
GeckoProfile
get
(
Context
context
String
profileName
)
{
synchronized
(
sProfileCache
)
{
GeckoProfile
profile
=
sProfileCache
.
get
(
profileName
)
;
if
(
profile
!
=
null
)
return
profile
;
}
return
get
(
context
profileName
(
File
)
null
)
;
}
RobocopTarget
public
static
GeckoProfile
get
(
Context
context
String
profileName
String
profilePath
)
{
File
dir
=
null
;
if
(
!
TextUtils
.
isEmpty
(
profilePath
)
)
{
dir
=
new
File
(
profilePath
)
;
if
(
!
dir
.
exists
(
)
|
|
!
dir
.
isDirectory
(
)
)
{
Log
.
w
(
LOGTAG
"
requested
profile
directory
missing
:
"
+
profilePath
)
;
}
}
return
get
(
context
profileName
dir
)
;
}
private
static
volatile
BrowserDB
.
Factory
sDBFactory
;
public
static
void
setBrowserDBFactory
(
BrowserDB
.
Factory
factory
)
{
sDBFactory
=
factory
;
}
RobocopTarget
public
static
GeckoProfile
get
(
Context
context
String
profileName
File
profileDir
)
{
if
(
sDBFactory
=
=
null
)
{
Log
.
d
(
LOGTAG
"
Defaulting
to
StubBrowserDB
.
"
)
;
sDBFactory
=
StubBrowserDB
.
getFactory
(
)
;
}
return
GeckoProfile
.
get
(
context
profileName
profileDir
sDBFactory
)
;
}
public
static
GeckoProfile
get
(
Context
context
String
profileName
File
profileDir
BrowserDB
.
Factory
dbFactory
)
{
if
(
context
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
context
must
be
non
-
null
"
)
;
}
if
(
profileName
=
=
null
&
&
profileDir
=
=
null
)
{
final
GeckoProfile
profile
=
GeckoThread
.
getActiveProfile
(
)
;
if
(
profile
!
=
null
)
{
return
profile
;
}
final
String
args
;
if
(
context
instanceof
Activity
)
{
args
=
IntentUtils
.
getStringExtraSafe
(
(
(
Activity
)
context
)
.
getIntent
(
)
"
args
"
)
;
}
else
{
args
=
null
;
}
return
GeckoProfile
.
initFromArgs
(
context
args
)
;
}
else
if
(
profileName
=
=
null
)
{
profileName
=
CUSTOM_PROFILE
;
}
else
if
(
AppConstants
.
DEBUG_BUILD
)
{
Log
.
v
(
LOGTAG
"
Fetching
profile
:
'
"
+
profileName
+
"
'
'
"
+
profileDir
+
"
'
"
)
;
}
synchronized
(
sProfileCache
)
{
final
boolean
init
=
profileDir
!
=
null
&
&
profileDir
.
mkdirs
(
)
;
GeckoProfile
profile
=
sProfileCache
.
get
(
profileName
)
;
if
(
profile
=
=
null
)
{
try
{
profile
=
new
GeckoProfile
(
context
profileName
profileDir
dbFactory
)
;
}
catch
(
NoMozillaDirectoryException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
sProfileCache
.
put
(
profileName
profile
)
;
}
else
if
(
profileDir
!
=
null
)
{
boolean
consistent
=
false
;
try
{
consistent
=
profile
.
getDir
(
)
.
getCanonicalPath
(
)
.
equals
(
profileDir
.
getCanonicalPath
(
)
)
;
}
catch
(
final
IOException
e
)
{
}
if
(
!
consistent
)
{
if
(
!
sAcceptDirectoryChanges
|
|
!
profileDir
.
isDirectory
(
)
)
{
throw
new
IllegalStateException
(
"
Refusing
to
reuse
profile
with
a
different
directory
.
"
)
;
}
if
(
AppConstants
.
RELEASE_BUILD
)
{
Log
.
e
(
LOGTAG
"
Release
build
trying
to
switch
out
profile
dir
.
"
+
"
This
is
an
error
but
let
'
s
do
what
we
can
.
"
)
;
}
profile
.
setDir
(
profileDir
)
;
}
}
if
(
init
)
{
profile
.
enqueueInitialization
(
profileDir
)
;
}
return
profile
;
}
}
RobocopTarget
public
static
boolean
removeProfile
(
final
Context
context
final
GeckoProfile
profile
)
{
final
boolean
success
=
profile
.
remove
(
)
;
if
(
success
)
{
GeckoSharedPrefs
.
forProfileName
(
context
profile
.
getName
(
)
)
.
edit
(
)
.
clear
(
)
.
apply
(
)
;
}
return
success
;
}
private
static
File
getGuestDir
(
final
Context
context
)
{
return
context
.
getFileStreamPath
(
GUEST_PROFILE_DIR
)
;
}
RobocopTarget
public
static
GeckoProfile
getGuestProfile
(
final
Context
context
)
{
return
get
(
context
CUSTOM_PROFILE
getGuestDir
(
context
)
)
;
}
public
static
boolean
isGuestProfile
(
final
Context
context
final
String
profileName
final
File
profileDir
)
{
if
(
profileDir
=
=
null
|
|
!
CUSTOM_PROFILE
.
equals
(
profileName
)
)
{
return
false
;
}
try
{
return
profileDir
.
getCanonicalPath
(
)
.
equals
(
getGuestDir
(
context
)
.
getCanonicalPath
(
)
)
;
}
catch
(
final
IOException
e
)
{
return
false
;
}
}
private
GeckoProfile
(
Context
context
String
profileName
File
profileDir
BrowserDB
.
Factory
dbFactory
)
throws
NoMozillaDirectoryException
{
if
(
profileName
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Unable
to
create
GeckoProfile
for
empty
profile
name
.
"
)
;
}
else
if
(
CUSTOM_PROFILE
.
equals
(
profileName
)
&
&
profileDir
=
=
null
)
{
throw
new
IllegalArgumentException
(
"
Custom
profile
must
have
a
directory
"
)
;
}
mApplicationContext
=
context
.
getApplicationContext
(
)
;
mName
=
profileName
;
mMozillaDir
=
GeckoProfileDirectories
.
getMozillaDirectory
(
context
)
;
mProfileDir
=
profileDir
;
if
(
profileDir
!
=
null
&
&
!
profileDir
.
isDirectory
(
)
)
{
throw
new
IllegalArgumentException
(
"
Profile
directory
must
exist
if
specified
.
"
)
;
}
mDB
=
dbFactory
.
get
(
profileName
mProfileDir
)
;
}
RobocopTarget
public
BrowserDB
getDB
(
)
{
return
mDB
;
}
private
void
setDir
(
File
dir
)
{
if
(
dir
!
=
null
&
&
dir
.
exists
(
)
&
&
dir
.
isDirectory
(
)
)
{
synchronized
(
this
)
{
mProfileDir
=
dir
;
mInGuestMode
=
null
;
}
}
}
RobocopTarget
public
String
getName
(
)
{
return
mName
;
}
public
boolean
isCustomProfile
(
)
{
return
CUSTOM_PROFILE
.
equals
(
mName
)
;
}
RobocopTarget
public
boolean
inGuestMode
(
)
{
if
(
mInGuestMode
=
=
null
)
{
mInGuestMode
=
isGuestProfile
(
GeckoAppShell
.
getApplicationContext
(
)
mName
mProfileDir
)
;
}
return
mInGuestMode
;
}
RobocopTarget
public
synchronized
File
getDir
(
)
{
forceCreate
(
)
;
return
mProfileDir
;
}
private
synchronized
GeckoProfile
forceCreate
(
)
{
if
(
mProfileDir
!
=
null
)
{
return
this
;
}
try
{
try
{
mProfileDir
=
findProfileDir
(
)
;
Log
.
d
(
LOGTAG
"
Found
profile
dir
.
"
)
;
}
catch
(
NoSuchProfileException
noSuchProfile
)
{
mProfileDir
=
createProfileDir
(
)
;
}
}
catch
(
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Error
getting
profile
dir
"
ioe
)
;
}
return
this
;
}
public
File
getFile
(
String
aFile
)
{
File
f
=
getDir
(
)
;
if
(
f
=
=
null
)
return
null
;
return
new
File
(
f
aFile
)
;
}
WorkerThread
public
String
getClientId
(
)
throws
IOException
{
try
{
return
getValidClientIdFromDisk
(
CLIENT_ID_FILE_PATH
)
;
}
catch
(
final
IOException
e
)
{
Log
.
d
(
LOGTAG
"
Could
not
get
client
ID
-
attempting
to
migrate
ID
from
FHR
:
"
+
e
.
getLocalizedMessage
(
)
)
;
}
String
clientIdToWrite
;
try
{
clientIdToWrite
=
getValidClientIdFromDisk
(
FHR_CLIENT_ID_FILE_PATH
)
;
}
catch
(
final
IOException
e
)
{
Log
.
d
(
LOGTAG
"
Could
not
migrate
client
ID
from
FHR
creating
a
new
one
:
"
+
e
.
getLocalizedMessage
(
)
)
;
clientIdToWrite
=
generateNewClientId
(
)
;
}
persistClientId
(
clientIdToWrite
)
;
return
getValidClientIdFromDisk
(
CLIENT_ID_FILE_PATH
)
;
}
protected
static
String
generateNewClientId
(
)
{
return
UUID
.
randomUUID
(
)
.
toString
(
)
;
}
WorkerThread
private
String
getValidClientIdFromDisk
(
final
String
filePath
)
throws
IOException
{
final
JSONObject
obj
=
readJSONObjectFromFile
(
filePath
)
;
final
String
clientId
=
obj
.
optString
(
CLIENT_ID_JSON_ATTR
)
;
if
(
isClientIdValid
(
clientId
)
)
{
return
clientId
;
}
throw
new
IOException
(
"
Received
client
ID
is
invalid
:
"
+
clientId
)
;
}
WorkerThread
private
void
persistClientId
(
final
String
clientId
)
throws
IOException
{
if
(
!
ensureParentDirs
(
CLIENT_ID_FILE_PATH
)
)
{
throw
new
IOException
(
"
Could
not
create
client
ID
parent
directories
"
)
;
}
final
JSONObject
obj
=
new
JSONObject
(
)
;
try
{
obj
.
put
(
CLIENT_ID_JSON_ATTR
clientId
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Could
not
create
client
ID
JSON
object
"
e
)
;
}
Log
.
d
(
LOGTAG
"
Attempting
to
write
new
client
ID
"
)
;
writeFile
(
CLIENT_ID_FILE_PATH
obj
.
toString
(
)
)
;
}
public
static
boolean
isClientIdValid
(
final
String
clientId
)
{
if
(
TextUtils
.
isEmpty
(
clientId
)
)
{
return
false
;
}
return
clientId
.
matches
(
"
(
?
i
:
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
)
"
)
;
}
WorkerThread
public
long
getAndPersistProfileCreationDate
(
final
Context
context
)
{
try
{
return
getProfileCreationDateFromTimesFile
(
)
;
}
catch
(
final
IOException
e
)
{
Log
.
d
(
LOGTAG
"
Unable
to
retrieve
profile
creation
date
from
times
.
json
.
Getting
from
system
.
.
.
"
)
;
final
long
packageInstallMillis
=
org
.
mozilla
.
gecko
.
util
.
ContextUtils
.
getCurrentPackageInfo
(
context
)
.
firstInstallTime
;
try
{
persistProfileCreationDateToTimesFile
(
packageInstallMillis
)
;
}
catch
(
final
IOException
ioEx
)
{
Log
.
w
(
LOGTAG
"
Unable
to
persist
profile
creation
date
-
returning
-
1
"
)
;
return
-
1
;
}
return
packageInstallMillis
;
}
}
WorkerThread
private
long
getProfileCreationDateFromTimesFile
(
)
throws
IOException
{
final
JSONObject
obj
=
readJSONObjectFromFile
(
TIMES_PATH
)
;
try
{
return
obj
.
getLong
(
PROFILE_CREATION_DATE_JSON_ATTR
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Profile
creation
does
not
exist
in
JSONObject
"
)
;
}
}
WorkerThread
private
void
persistProfileCreationDateToTimesFile
(
final
long
profileCreationMillis
)
throws
IOException
{
final
JSONObject
obj
=
new
JSONObject
(
)
;
try
{
obj
.
put
(
PROFILE_CREATION_DATE_JSON_ATTR
profileCreationMillis
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Unable
to
persist
profile
creation
date
to
times
file
"
)
;
}
Log
.
d
(
LOGTAG
"
Attempting
to
write
new
profile
creation
date
"
)
;
writeFile
(
TIMES_PATH
obj
.
toString
(
)
)
;
}
public
void
updateSessionFile
(
boolean
shouldRestore
)
{
File
sessionFileBackup
=
getFile
(
SESSION_FILE_BACKUP
)
;
if
(
!
shouldRestore
)
{
File
sessionFile
=
getFile
(
SESSION_FILE
)
;
if
(
sessionFile
!
=
null
&
&
sessionFile
.
exists
(
)
)
{
sessionFile
.
renameTo
(
sessionFileBackup
)
;
}
}
else
{
if
(
sessionFileBackup
!
=
null
&
&
sessionFileBackup
.
exists
(
)
&
&
System
.
currentTimeMillis
(
)
-
sessionFileBackup
.
lastModified
(
)
>
MAX_BACKUP_FILE_AGE
)
{
sessionFileBackup
.
delete
(
)
;
}
}
synchronized
(
this
)
{
mOldSessionDataProcessed
=
true
;
notifyAll
(
)
;
}
}
public
void
waitForOldSessionDataProcessing
(
)
{
synchronized
(
this
)
{
while
(
!
mOldSessionDataProcessed
)
{
try
{
wait
(
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
}
}
public
String
readSessionFile
(
boolean
readBackup
)
{
File
sessionFile
=
getFile
(
readBackup
?
SESSION_FILE_BACKUP
:
SESSION_FILE
)
;
try
{
if
(
sessionFile
!
=
null
&
&
sessionFile
.
exists
(
)
)
{
return
readFile
(
sessionFile
)
;
}
}
catch
(
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
Unable
to
read
session
file
"
ioe
)
;
}
return
null
;
}
WorkerThread
protected
boolean
ensureParentDirs
(
final
String
filename
)
{
final
File
file
=
new
File
(
getDir
(
)
filename
)
;
final
File
parentFile
=
file
.
getParentFile
(
)
;
return
parentFile
.
mkdirs
(
)
|
|
parentFile
.
isDirectory
(
)
;
}
public
void
writeFile
(
final
String
filename
final
String
data
)
{
File
file
=
new
File
(
getDir
(
)
filename
)
;
BufferedWriter
bufferedWriter
=
null
;
try
{
bufferedWriter
=
new
BufferedWriter
(
new
FileWriter
(
file
false
)
)
;
bufferedWriter
.
write
(
data
)
;
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Unable
to
write
to
file
"
e
)
;
}
finally
{
try
{
if
(
bufferedWriter
!
=
null
)
{
bufferedWriter
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
Log
.
e
(
LOGTAG
"
Error
closing
writer
while
writing
to
file
"
e
)
;
}
}
}
WorkerThread
public
JSONObject
readJSONObjectFromFile
(
final
String
filename
)
throws
IOException
{
final
String
fileContents
;
try
{
fileContents
=
readFile
(
filename
)
;
}
catch
(
final
IOException
e
)
{
throw
new
IOException
(
"
Could
not
access
given
file
to
retrieve
JSONObject
"
)
;
}
try
{
return
new
JSONObject
(
fileContents
)
;
}
catch
(
final
JSONException
e
)
{
throw
new
IOException
(
"
Could
not
parse
JSON
to
retrieve
JSONObject
"
)
;
}
}
public
JSONArray
readJSONArrayFromFile
(
final
String
filename
)
{
String
fileContent
;
try
{
fileContent
=
readFile
(
filename
)
;
}
catch
(
IOException
expected
)
{
return
new
JSONArray
(
)
;
}
JSONArray
jsonArray
;
try
{
jsonArray
=
new
JSONArray
(
fileContent
)
;
}
catch
(
JSONException
e
)
{
jsonArray
=
new
JSONArray
(
)
;
}
return
jsonArray
;
}
public
String
readFile
(
String
filename
)
throws
IOException
{
File
dir
=
getDir
(
)
;
if
(
dir
=
=
null
)
{
throw
new
IOException
(
"
No
profile
directory
found
"
)
;
}
File
target
=
new
File
(
dir
filename
)
;
return
readFile
(
target
)
;
}
private
String
readFile
(
File
target
)
throws
IOException
{
FileReader
fr
=
new
FileReader
(
target
)
;
try
{
StringBuilder
sb
=
new
StringBuilder
(
)
;
char
[
]
buf
=
new
char
[
8192
]
;
int
read
=
fr
.
read
(
buf
)
;
while
(
read
>
=
0
)
{
sb
.
append
(
buf
0
read
)
;
read
=
fr
.
read
(
buf
)
;
}
return
sb
.
toString
(
)
;
}
finally
{
fr
.
close
(
)
;
}
}
public
boolean
deleteFileFromProfileDir
(
String
fileName
)
throws
IllegalArgumentException
{
if
(
TextUtils
.
isEmpty
(
fileName
)
)
{
throw
new
IllegalArgumentException
(
"
Filename
cannot
be
empty
.
"
)
;
}
File
file
=
new
File
(
getDir
(
)
fileName
)
;
return
file
.
delete
(
)
;
}
private
boolean
remove
(
)
{
try
{
synchronized
(
this
)
{
if
(
mProfileDir
!
=
null
&
&
mProfileDir
.
exists
(
)
)
{
FileUtils
.
delete
(
mProfileDir
)
;
}
if
(
isCustomProfile
(
)
)
{
return
true
;
}
try
{
findProfileDir
(
)
;
mProfileDir
=
null
;
}
catch
(
final
NoSuchProfileException
e
)
{
return
true
;
}
}
final
INIParser
parser
=
GeckoProfileDirectories
.
getProfilesINI
(
mMozillaDir
)
;
final
Hashtable
<
String
INISection
>
sections
=
parser
.
getSections
(
)
;
for
(
Enumeration
<
INISection
>
e
=
sections
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
final
INISection
section
=
e
.
nextElement
(
)
;
String
name
=
section
.
getStringProperty
(
"
Name
"
)
;
if
(
name
=
=
null
|
|
!
name
.
equals
(
mName
)
)
{
continue
;
}
if
(
section
.
getName
(
)
.
startsWith
(
"
Profile
"
)
)
{
try
{
int
sectionNumber
=
Integer
.
parseInt
(
section
.
getName
(
)
.
substring
(
"
Profile
"
.
length
(
)
)
)
;
String
curSection
=
"
Profile
"
+
sectionNumber
;
String
nextSection
=
"
Profile
"
+
(
sectionNumber
+
1
)
;
sections
.
remove
(
curSection
)
;
while
(
sections
.
containsKey
(
nextSection
)
)
{
parser
.
renameSection
(
nextSection
curSection
)
;
sectionNumber
+
+
;
curSection
=
nextSection
;
nextSection
=
"
Profile
"
+
(
sectionNumber
+
1
)
;
}
}
catch
(
NumberFormatException
nex
)
{
Log
.
e
(
LOGTAG
"
Malformed
section
name
in
profiles
.
ini
:
"
+
section
.
getName
(
)
)
;
return
false
;
}
}
else
{
parser
.
removeSection
(
mName
)
;
}
break
;
}
parser
.
write
(
)
;
return
true
;
}
catch
(
IOException
ex
)
{
Log
.
w
(
LOGTAG
"
Failed
to
remove
profile
.
"
ex
)
;
return
false
;
}
}
public
static
String
getDefaultProfileName
(
final
Context
context
)
throws
NoMozillaDirectoryException
{
if
(
sDefaultProfileName
!
=
null
)
{
return
sDefaultProfileName
;
}
final
String
profileName
=
GeckoProfileDirectories
.
findDefaultProfileName
(
context
)
;
if
(
profileName
=
=
null
)
{
sDefaultProfileName
=
DEFAULT_PROFILE
;
return
DEFAULT_PROFILE
;
}
sDefaultProfileName
=
profileName
;
return
sDefaultProfileName
;
}
private
File
findProfileDir
(
)
throws
NoSuchProfileException
{
if
(
isCustomProfile
(
)
)
{
return
mProfileDir
;
}
return
GeckoProfileDirectories
.
findProfileDir
(
mMozillaDir
mName
)
;
}
WorkerThread
private
File
createProfileDir
(
)
throws
IOException
{
if
(
isCustomProfile
(
)
)
{
return
mProfileDir
;
}
INIParser
parser
=
GeckoProfileDirectories
.
getProfilesINI
(
mMozillaDir
)
;
String
saltedName
=
GeckoProfileDirectories
.
saltProfileName
(
mName
)
;
File
profileDir
=
new
File
(
mMozillaDir
saltedName
)
;
while
(
profileDir
.
exists
(
)
)
{
saltedName
=
GeckoProfileDirectories
.
saltProfileName
(
mName
)
;
profileDir
=
new
File
(
mMozillaDir
saltedName
)
;
}
if
(
!
profileDir
.
mkdirs
(
)
)
{
throw
new
IOException
(
"
Unable
to
create
profile
.
"
)
;
}
Log
.
d
(
LOGTAG
"
Created
new
profile
dir
.
"
)
;
int
profileNum
=
0
;
boolean
isDefaultSet
=
false
;
INISection
profileSection
;
while
(
(
profileSection
=
parser
.
getSection
(
"
Profile
"
+
profileNum
)
)
!
=
null
)
{
profileNum
+
+
;
if
(
profileSection
.
getProperty
(
"
Default
"
)
!
=
null
)
{
isDefaultSet
=
true
;
}
}
profileSection
=
new
INISection
(
"
Profile
"
+
profileNum
)
;
profileSection
.
setProperty
(
"
Name
"
mName
)
;
profileSection
.
setProperty
(
"
IsRelative
"
1
)
;
profileSection
.
setProperty
(
"
Path
"
saltedName
)
;
if
(
parser
.
getSection
(
"
General
"
)
=
=
null
)
{
INISection
generalSection
=
new
INISection
(
"
General
"
)
;
generalSection
.
setProperty
(
"
StartWithLastProfile
"
1
)
;
parser
.
addSection
(
generalSection
)
;
}
if
(
!
isDefaultSet
)
{
profileSection
.
setProperty
(
"
Default
"
1
)
;
Telemetry
.
startUISession
(
TelemetryContract
.
Session
.
FIRSTRUN
)
;
}
parser
.
addSection
(
profileSection
)
;
parser
.
write
(
)
;
enqueueInitialization
(
profileDir
)
;
try
{
FileOutputStream
stream
=
new
FileOutputStream
(
profileDir
.
getAbsolutePath
(
)
+
File
.
separator
+
TIMES_PATH
)
;
OutputStreamWriter
writer
=
new
OutputStreamWriter
(
stream
Charset
.
forName
(
"
UTF
-
8
"
)
)
;
try
{
writer
.
append
(
"
{
\
"
created
\
"
:
"
+
System
.
currentTimeMillis
(
)
+
"
}
\
n
"
)
;
}
finally
{
writer
.
close
(
)
;
}
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Couldn
'
t
write
"
+
TIMES_PATH
e
)
;
}
persistClientId
(
generateNewClientId
(
)
)
;
final
SharedPreferences
prefs
=
GeckoSharedPrefs
.
forProfile
(
mApplicationContext
)
;
prefs
.
edit
(
)
.
putBoolean
(
FirstrunAnimationContainer
.
PREF_FIRSTRUN_ENABLED
true
)
.
apply
(
)
;
return
profileDir
;
}
RobocopTarget
public
void
enqueueInitialization
(
final
File
profileDir
)
{
Log
.
i
(
LOGTAG
"
Enqueuing
profile
init
.
"
)
;
final
Context
context
=
mApplicationContext
;
final
Distribution
distribution
=
Distribution
.
getInstance
(
context
)
;
distribution
.
addOnDistributionReadyCallback
(
new
Distribution
.
ReadyCallback
(
)
{
Override
public
void
distributionNotFound
(
)
{
this
.
distributionFound
(
null
)
;
}
Override
public
void
distributionFound
(
Distribution
distribution
)
{
Log
.
d
(
LOGTAG
"
Running
post
-
distribution
task
:
bookmarks
.
"
)
;
final
ContentResolver
cr
=
context
.
getContentResolver
(
)
;
synchronized
(
GeckoProfile
.
this
)
{
if
(
!
profileDir
.
exists
(
)
)
{
return
;
}
final
LocalBrowserDB
db
=
new
LocalBrowserDB
(
getName
(
)
)
;
final
int
offset
=
distribution
=
=
null
?
0
:
db
.
addDistributionBookmarks
(
cr
distribution
0
)
;
db
.
addDefaultBookmarks
(
context
cr
offset
)
;
Log
.
d
(
LOGTAG
"
Running
post
-
distribution
task
:
android
preferences
.
"
)
;
DistroSharedPrefsImport
.
importPreferences
(
context
distribution
)
;
}
}
Override
public
void
distributionArrivedLate
(
Distribution
distribution
)
{
Log
.
d
(
LOGTAG
"
Running
late
distribution
task
:
bookmarks
.
"
)
;
synchronized
(
GeckoProfile
.
this
)
{
if
(
!
profileDir
.
exists
(
)
)
{
return
;
}
final
LocalBrowserDB
db
=
new
LocalBrowserDB
(
getName
(
)
)
;
final
ContentResolver
cr
=
context
.
getContentResolver
(
)
;
final
int
offset
=
db
.
getCount
(
cr
"
bookmarks
"
)
;
db
.
addDistributionBookmarks
(
cr
distribution
offset
)
;
Log
.
d
(
LOGTAG
"
Running
late
distribution
task
:
android
preferences
.
"
)
;
DistroSharedPrefsImport
.
importPreferences
(
context
distribution
)
;
}
}
}
)
;
}
}
