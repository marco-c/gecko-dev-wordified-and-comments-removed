package
org
.
mozilla
.
gecko
.
gfx
;
import
org
.
mozilla
.
gecko
.
PrefsHelper
;
import
org
.
mozilla
.
gecko
.
util
.
FloatUtils
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
android
.
graphics
.
PointF
;
import
android
.
util
.
Log
;
import
android
.
view
.
animation
.
DecelerateInterpolator
;
import
android
.
view
.
MotionEvent
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
public
class
DynamicToolbarAnimator
{
private
static
final
String
LOGTAG
=
"
GeckoDynamicToolbarAnimator
"
;
private
static
final
String
PREF_SCROLL_TOOLBAR_THRESHOLD
=
"
browser
.
ui
.
scroll
-
toolbar
-
threshold
"
;
private
static
final
long
ANIMATION_DURATION
=
250000000
;
private
final
GeckoLayerClient
mTarget
;
private
final
List
<
LayerView
.
DynamicToolbarListener
>
mListeners
;
private
float
mToolbarTranslation
;
private
float
mLayerViewTranslation
;
private
float
mMaxTranslation
;
private
boolean
mPinned
;
private
DecelerateInterpolator
mInterpolator
;
private
float
SCROLL_TOOLBAR_THRESHOLD
=
0
.
20f
;
private
Integer
mPrefObserverId
;
private
DynamicToolbarAnimationTask
mAnimationTask
;
private
PointF
mTouchStart
;
private
float
mLastTouch
;
public
DynamicToolbarAnimator
(
GeckoLayerClient
aTarget
)
{
mTarget
=
aTarget
;
mListeners
=
new
ArrayList
<
LayerView
.
DynamicToolbarListener
>
(
)
;
mInterpolator
=
new
DecelerateInterpolator
(
)
;
mPrefObserverId
=
PrefsHelper
.
getPref
(
PREF_SCROLL_TOOLBAR_THRESHOLD
new
PrefsHelper
.
PrefHandlerBase
(
)
{
Override
public
void
prefValue
(
String
pref
int
value
)
{
SCROLL_TOOLBAR_THRESHOLD
=
value
/
100
.
0f
;
}
Override
public
boolean
isObserver
(
)
{
return
true
;
}
}
)
;
}
public
void
destroy
(
)
{
if
(
mPrefObserverId
!
=
null
)
{
PrefsHelper
.
removeObserver
(
mPrefObserverId
)
;
mPrefObserverId
=
null
;
}
}
public
void
addTranslationListener
(
LayerView
.
DynamicToolbarListener
aListener
)
{
mListeners
.
add
(
aListener
)
;
}
public
void
removeTranslationListener
(
LayerView
.
DynamicToolbarListener
aListener
)
{
mListeners
.
remove
(
aListener
)
;
}
private
void
fireListeners
(
)
{
for
(
LayerView
.
DynamicToolbarListener
listener
:
mListeners
)
{
listener
.
onTranslationChanged
(
mToolbarTranslation
mLayerViewTranslation
)
;
}
}
void
onPanZoomStopped
(
)
{
for
(
LayerView
.
DynamicToolbarListener
listener
:
mListeners
)
{
listener
.
onPanZoomStopped
(
)
;
}
}
public
void
setMaxTranslation
(
float
maxTranslation
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
maxTranslation
<
0
)
{
Log
.
e
(
LOGTAG
"
Got
a
negative
max
-
translation
value
:
"
+
maxTranslation
+
"
;
clamping
to
zero
"
)
;
mMaxTranslation
=
0
;
}
else
{
mMaxTranslation
=
maxTranslation
;
}
}
public
float
getToolbarTranslation
(
)
{
return
mToolbarTranslation
;
}
public
void
setPinned
(
boolean
pinned
)
{
mPinned
=
pinned
;
}
public
boolean
isPinned
(
)
{
return
mPinned
;
}
public
void
showToolbar
(
boolean
immediately
)
{
animateToolbar
(
0
immediately
)
;
}
public
void
hideToolbar
(
boolean
immediately
)
{
animateToolbar
(
mMaxTranslation
immediately
)
;
}
private
void
animateToolbar
(
final
float
translation
boolean
immediately
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
mAnimationTask
!
=
null
)
{
mTarget
.
getView
(
)
.
removeRenderTask
(
mAnimationTask
)
;
mAnimationTask
=
null
;
}
Log
.
v
(
LOGTAG
"
Requested
"
+
(
immediately
?
"
immedate
"
:
"
"
)
+
"
toolbar
animation
to
translation
"
+
translation
)
;
if
(
FloatUtils
.
fuzzyEquals
(
mToolbarTranslation
translation
)
)
{
immediately
=
true
;
Log
.
v
(
LOGTAG
"
Changing
animation
to
immediate
jump
"
)
;
}
if
(
immediately
)
{
mToolbarTranslation
=
translation
;
fireListeners
(
)
;
resizeViewport
(
)
;
mTarget
.
getView
(
)
.
requestRender
(
)
;
return
;
}
Log
.
v
(
LOGTAG
"
Kicking
off
animation
.
.
.
"
)
;
mAnimationTask
=
new
DynamicToolbarAnimationTask
(
false
translation
)
;
mTarget
.
getView
(
)
.
postRenderTask
(
mAnimationTask
)
;
}
private
void
resizeViewport
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
synchronized
(
mTarget
.
getLock
(
)
)
{
int
viewWidth
=
mTarget
.
getView
(
)
.
getWidth
(
)
;
int
viewHeight
=
mTarget
.
getView
(
)
.
getHeight
(
)
;
int
viewHeightVisible
=
viewHeight
-
Math
.
round
(
mMaxTranslation
-
mToolbarTranslation
)
;
Log
.
v
(
LOGTAG
"
Resize
viewport
to
dimensions
"
+
viewWidth
+
"
x
"
+
viewHeightVisible
)
;
mTarget
.
setViewportSize
(
viewWidth
viewHeightVisible
)
;
}
}
private
static
float
shrinkAbs
(
float
aValue
float
aShrinkAmount
)
{
if
(
aShrinkAmount
<
=
0
)
{
return
aValue
;
}
float
shrinkBy
=
Math
.
min
(
Math
.
abs
(
aValue
)
aShrinkAmount
)
;
return
(
aValue
<
0
?
aValue
+
shrinkBy
:
aValue
-
shrinkBy
)
;
}
private
float
decideTranslation
(
float
aDelta
ImmutableViewportMetrics
aMetrics
float
aTouchTravelDistance
)
{
float
exposeThreshold
=
aMetrics
.
getHeight
(
)
*
SCROLL_TOOLBAR_THRESHOLD
;
float
translation
=
aDelta
;
if
(
translation
<
0
)
{
translation
=
shrinkAbs
(
translation
aMetrics
.
getOverscroll
(
)
.
top
)
;
boolean
inBetween
=
(
mToolbarTranslation
!
=
0
&
&
mToolbarTranslation
!
=
mMaxTranslation
)
;
boolean
reachedThreshold
=
-
aTouchTravelDistance
>
=
exposeThreshold
;
boolean
atBottomOfPage
=
aMetrics
.
viewportRectBottom
(
)
>
=
aMetrics
.
pageRectBottom
;
if
(
inBetween
|
|
(
reachedThreshold
&
&
!
atBottomOfPage
)
)
{
return
translation
;
}
}
else
{
translation
=
shrinkAbs
(
translation
aMetrics
.
getOverscroll
(
)
.
bottom
)
;
boolean
inBetween
=
(
mToolbarTranslation
!
=
0
&
&
mToolbarTranslation
!
=
mMaxTranslation
)
;
boolean
reachedThreshold
=
aTouchTravelDistance
>
=
exposeThreshold
;
boolean
atTopOfPage
=
aMetrics
.
viewportRectTop
<
=
aMetrics
.
pageRectTop
;
boolean
isToolbarTranslated
=
(
mToolbarTranslation
!
=
0
)
;
if
(
inBetween
|
|
reachedThreshold
|
|
(
atTopOfPage
&
&
isToolbarTranslated
)
)
{
return
translation
;
}
}
return
0
;
}
boolean
onInterceptTouchEvent
(
MotionEvent
event
)
{
if
(
mPinned
)
{
return
false
;
}
if
(
mAnimationTask
!
=
null
)
{
mTarget
.
getView
(
)
.
removeRenderTask
(
mAnimationTask
)
;
mAnimationTask
=
null
;
}
if
(
event
.
getActionMasked
(
)
!
=
MotionEvent
.
ACTION_MOVE
|
|
event
.
getPointerCount
(
)
!
=
1
)
{
if
(
mTouchStart
!
=
null
)
{
Log
.
v
(
LOGTAG
"
Resetting
touch
sequence
due
to
non
-
move
"
)
;
mTouchStart
=
null
;
}
return
false
;
}
if
(
mTouchStart
!
=
null
)
{
float
prevDir
=
mLastTouch
-
mTouchStart
.
y
;
float
newDir
=
event
.
getRawY
(
)
-
mLastTouch
;
if
(
prevDir
!
=
0
&
&
newDir
!
=
0
&
&
(
(
prevDir
<
0
)
!
=
(
newDir
<
0
)
)
)
{
Log
.
v
(
LOGTAG
"
Direction
changed
:
"
+
mTouchStart
.
y
+
"
-
>
"
+
mLastTouch
+
"
-
>
"
+
event
.
getRawY
(
)
)
;
mTouchStart
=
null
;
}
}
if
(
mTouchStart
=
=
null
)
{
mTouchStart
=
new
PointF
(
event
.
getRawX
(
)
event
.
getRawY
(
)
)
;
mLastTouch
=
event
.
getRawY
(
)
;
return
false
;
}
float
deltaY
=
event
.
getRawY
(
)
-
mLastTouch
;
mLastTouch
=
event
.
getRawY
(
)
;
float
travelDistance
=
event
.
getRawY
(
)
-
mTouchStart
.
y
;
ImmutableViewportMetrics
metrics
=
mTarget
.
getViewportMetrics
(
)
;
if
(
metrics
.
getPageHeight
(
)
<
metrics
.
getHeight
(
)
)
{
return
false
;
}
float
translation
=
decideTranslation
(
deltaY
metrics
travelDistance
)
;
Log
.
v
(
LOGTAG
"
Got
vertical
translation
"
+
translation
)
;
float
oldToolbarTranslation
=
mToolbarTranslation
;
float
oldLayerViewTranslation
=
mLayerViewTranslation
;
mToolbarTranslation
=
FloatUtils
.
clamp
(
mToolbarTranslation
-
translation
0
mMaxTranslation
)
;
mLayerViewTranslation
=
FloatUtils
.
clamp
(
mLayerViewTranslation
-
translation
0
mMaxTranslation
)
;
if
(
oldToolbarTranslation
=
=
mToolbarTranslation
&
&
oldLayerViewTranslation
=
=
mLayerViewTranslation
)
{
return
false
;
}
fireListeners
(
)
;
mTarget
.
getView
(
)
.
requestRender
(
)
;
return
true
;
}
class
DynamicToolbarAnimationTask
extends
RenderTask
{
private
final
float
mStartTranslation
;
private
final
float
mEndTranslation
;
private
boolean
mContinueAnimation
;
public
DynamicToolbarAnimationTask
(
boolean
aRunAfter
float
aTranslation
)
{
super
(
aRunAfter
)
;
mContinueAnimation
=
true
;
mStartTranslation
=
mToolbarTranslation
;
mEndTranslation
=
aTranslation
;
}
Override
public
boolean
internalRun
(
long
timeDelta
long
currentFrameStartTime
)
{
if
(
!
mContinueAnimation
)
{
return
false
;
}
final
float
progress
=
mInterpolator
.
getInterpolation
(
Math
.
min
(
1
.
0f
(
System
.
nanoTime
(
)
-
getStartTime
(
)
)
/
(
float
)
ANIMATION_DURATION
)
)
;
ThreadUtils
.
assertNotOnUiThread
(
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
mToolbarTranslation
=
FloatUtils
.
interpolate
(
mStartTranslation
mEndTranslation
progress
)
;
mLayerViewTranslation
=
Math
.
max
(
mLayerViewTranslation
mToolbarTranslation
)
;
fireListeners
(
)
;
if
(
progress
>
=
1
.
0f
)
{
resizeViewport
(
)
;
}
}
}
)
;
mTarget
.
getView
(
)
.
requestRender
(
)
;
if
(
progress
>
=
1
.
0f
)
{
mContinueAnimation
=
false
;
}
return
mContinueAnimation
;
}
}
}
