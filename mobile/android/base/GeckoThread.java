package
org
.
mozilla
.
gecko
;
import
org
.
mozilla
.
gecko
.
annotation
.
RobocopTarget
;
import
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
;
import
org
.
mozilla
.
gecko
.
mozglue
.
GeckoLoader
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoEventListener
;
import
org
.
mozilla
.
gecko
.
util
.
ThreadUtils
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
android
.
content
.
Context
;
import
android
.
content
.
res
.
Configuration
;
import
android
.
content
.
res
.
Resources
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
android
.
os
.
MessageQueue
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
DisplayMetrics
;
import
android
.
util
.
Log
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Queue
;
import
java
.
util
.
concurrent
.
ConcurrentLinkedQueue
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicReference
;
public
class
GeckoThread
extends
Thread
implements
GeckoEventListener
{
private
static
final
String
LOGTAG
=
"
GeckoThread
"
;
WrapForJNI
public
enum
State
{
INITIAL
LAUNCHED
MOZGLUE_READY
LIBS_READY
JNI_READY
PROFILE_READY
RUNNING
EXITING
EXITED
;
public
boolean
is
(
final
State
other
)
{
return
this
=
=
other
;
}
public
boolean
isAtLeast
(
final
State
other
)
{
return
ordinal
(
)
>
=
other
.
ordinal
(
)
;
}
public
boolean
isAtMost
(
final
State
other
)
{
return
ordinal
(
)
<
=
other
.
ordinal
(
)
;
}
public
boolean
isBetween
(
final
State
min
final
State
max
)
{
final
int
ord
=
ordinal
(
)
;
return
ord
>
=
min
.
ordinal
(
)
&
&
ord
<
=
max
.
ordinal
(
)
;
}
}
public
static
final
State
MIN_STATE
=
State
.
INITIAL
;
public
static
final
State
MAX_STATE
=
State
.
EXITED
;
private
static
final
AtomicReference
<
State
>
sState
=
new
AtomicReference
<
>
(
State
.
INITIAL
)
;
private
static
class
QueuedCall
{
public
Method
method
;
public
Object
target
;
public
Object
[
]
args
;
public
State
state
;
public
QueuedCall
(
final
Method
method
final
Object
target
final
Object
[
]
args
final
State
state
)
{
this
.
method
=
method
;
this
.
target
=
target
;
this
.
args
=
args
;
this
.
state
=
state
;
}
}
private
static
final
int
QUEUED_CALLS_COUNT
=
16
;
private
static
final
ArrayList
<
QueuedCall
>
QUEUED_CALLS
=
new
ArrayList
<
>
(
QUEUED_CALLS_COUNT
)
;
private
static
GeckoThread
sGeckoThread
;
WrapForJNI
private
static
final
ClassLoader
clsLoader
=
GeckoThread
.
class
.
getClassLoader
(
)
;
WrapForJNI
private
static
MessageQueue
msgQueue
;
private
final
String
mArgs
;
private
final
String
mAction
;
private
final
String
mUri
;
private
final
boolean
mDebugging
;
GeckoThread
(
String
args
String
action
String
uri
boolean
debugging
)
{
mArgs
=
args
;
mAction
=
action
;
mUri
=
uri
;
mDebugging
=
debugging
;
setName
(
"
Gecko
"
)
;
EventDispatcher
.
getInstance
(
)
.
registerGeckoThreadListener
(
this
"
Gecko
:
Ready
"
)
;
}
public
static
boolean
ensureInit
(
String
args
String
action
String
uri
)
{
return
ensureInit
(
args
action
uri
false
)
;
}
public
static
boolean
ensureInit
(
String
args
String
action
String
uri
boolean
debugging
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
isState
(
State
.
INITIAL
)
&
&
sGeckoThread
=
=
null
)
{
sGeckoThread
=
new
GeckoThread
(
args
action
uri
debugging
)
;
return
true
;
}
return
false
;
}
public
static
boolean
launch
(
)
{
ThreadUtils
.
assertOnUiThread
(
)
;
if
(
checkAndSetState
(
State
.
INITIAL
State
.
LAUNCHED
)
)
{
sGeckoThread
.
start
(
)
;
return
true
;
}
return
false
;
}
public
static
boolean
isLaunched
(
)
{
return
!
isState
(
State
.
INITIAL
)
;
}
RobocopTarget
public
static
boolean
isRunning
(
)
{
return
isState
(
State
.
RUNNING
)
;
}
private
static
void
invokeMethod
(
final
Method
method
final
Object
obj
final
Object
[
]
args
)
{
try
{
method
.
invoke
(
obj
args
)
;
}
catch
(
final
IllegalAccessException
e
)
{
throw
new
IllegalStateException
(
"
Unexpected
exception
"
e
)
;
}
catch
(
final
InvocationTargetException
e
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
make
call
"
e
.
getCause
(
)
)
;
}
}
private
static
void
queueNativeCallLocked
(
final
Class
<
?
>
cls
final
String
methodName
final
Object
obj
final
Object
[
]
args
final
State
state
)
{
final
Class
<
?
>
[
]
argTypes
=
new
Class
<
?
>
[
args
.
length
]
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
+
+
)
{
Class
<
?
>
argType
=
args
[
i
]
.
getClass
(
)
;
if
(
argType
=
=
Boolean
.
class
)
argType
=
Boolean
.
TYPE
;
else
if
(
argType
=
=
Byte
.
class
)
argType
=
Byte
.
TYPE
;
else
if
(
argType
=
=
Character
.
class
)
argType
=
Character
.
TYPE
;
else
if
(
argType
=
=
Double
.
class
)
argType
=
Double
.
TYPE
;
else
if
(
argType
=
=
Float
.
class
)
argType
=
Float
.
TYPE
;
else
if
(
argType
=
=
Integer
.
class
)
argType
=
Integer
.
TYPE
;
else
if
(
argType
=
=
Long
.
class
)
argType
=
Long
.
TYPE
;
else
if
(
argType
=
=
Short
.
class
)
argType
=
Short
.
TYPE
;
argTypes
[
i
]
=
argType
;
}
final
Method
method
;
try
{
method
=
cls
.
getDeclaredMethod
(
methodName
argTypes
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
find
method
"
e
)
;
}
if
(
QUEUED_CALLS
.
size
(
)
=
=
0
&
&
isStateAtLeast
(
state
)
)
{
invokeMethod
(
method
obj
args
)
;
return
;
}
QUEUED_CALLS
.
add
(
new
QueuedCall
(
method
obj
args
state
)
)
;
}
public
static
void
queueNativeCallUntil
(
final
State
state
final
Class
<
?
>
cls
final
String
methodName
final
Object
.
.
.
args
)
{
synchronized
(
QUEUED_CALLS
)
{
queueNativeCallLocked
(
cls
methodName
null
args
state
)
;
}
}
public
static
void
queueNativeCall
(
final
Class
<
?
>
cls
final
String
methodName
final
Object
.
.
.
args
)
{
synchronized
(
QUEUED_CALLS
)
{
queueNativeCallLocked
(
cls
methodName
null
args
State
.
RUNNING
)
;
}
}
public
static
void
queueNativeCallUntil
(
final
State
state
final
Object
obj
final
String
methodName
final
Object
.
.
.
args
)
{
synchronized
(
QUEUED_CALLS
)
{
queueNativeCallLocked
(
obj
.
getClass
(
)
methodName
obj
args
state
)
;
}
}
public
static
void
queueNativeCall
(
final
Object
obj
final
String
methodName
final
Object
.
.
.
args
)
{
synchronized
(
QUEUED_CALLS
)
{
queueNativeCallLocked
(
obj
.
getClass
(
)
methodName
obj
args
State
.
RUNNING
)
;
}
}
private
static
void
flushQueuedNativeCalls
(
final
State
state
)
{
synchronized
(
QUEUED_CALLS
)
{
int
lastSkipped
=
-
1
;
for
(
int
i
=
0
;
i
<
QUEUED_CALLS
.
size
(
)
;
i
+
+
)
{
final
QueuedCall
call
=
QUEUED_CALLS
.
get
(
i
)
;
if
(
call
=
=
null
)
{
continue
;
}
if
(
!
state
.
isAtLeast
(
call
.
state
)
)
{
lastSkipped
=
i
;
continue
;
}
QUEUED_CALLS
.
set
(
i
null
)
;
if
(
call
.
method
=
=
null
)
{
final
GeckoEvent
e
=
(
GeckoEvent
)
call
.
target
;
GeckoAppShell
.
notifyGeckoOfEvent
(
e
)
;
e
.
recycle
(
)
;
continue
;
}
invokeMethod
(
call
.
method
call
.
target
call
.
args
)
;
}
if
(
lastSkipped
<
0
)
{
QUEUED_CALLS
.
clear
(
)
;
QUEUED_CALLS
.
trimToSize
(
)
;
}
else
if
(
lastSkipped
<
QUEUED_CALLS
.
size
(
)
-
1
)
{
QUEUED_CALLS
.
subList
(
lastSkipped
+
1
QUEUED_CALLS
.
size
(
)
)
.
clear
(
)
;
}
}
}
private
static
String
initGeckoEnvironment
(
)
{
final
Context
context
=
GeckoAppShell
.
getContext
(
)
;
GeckoLoader
.
loadMozGlue
(
context
)
;
setState
(
State
.
MOZGLUE_READY
)
;
final
Locale
locale
=
Locale
.
getDefault
(
)
;
final
Resources
res
=
context
.
getResources
(
)
;
if
(
locale
.
toString
(
)
.
equalsIgnoreCase
(
"
zh_hk
"
)
)
{
final
Locale
mappedLocale
=
Locale
.
TRADITIONAL_CHINESE
;
Locale
.
setDefault
(
mappedLocale
)
;
Configuration
config
=
res
.
getConfiguration
(
)
;
config
.
locale
=
mappedLocale
;
res
.
updateConfiguration
(
config
null
)
;
}
String
[
]
pluginDirs
=
null
;
try
{
pluginDirs
=
GeckoAppShell
.
getPluginDirectories
(
)
;
}
catch
(
Exception
e
)
{
Log
.
w
(
LOGTAG
"
Caught
exception
getting
plugin
dirs
.
"
e
)
;
}
final
String
resourcePath
=
context
.
getPackageResourcePath
(
)
;
GeckoLoader
.
setupGeckoEnvironment
(
context
pluginDirs
context
.
getFilesDir
(
)
.
getPath
(
)
)
;
GeckoLoader
.
loadSQLiteLibs
(
context
resourcePath
)
;
GeckoLoader
.
loadNSSLibs
(
context
resourcePath
)
;
GeckoLoader
.
loadGeckoLibs
(
context
resourcePath
)
;
setState
(
State
.
LIBS_READY
)
;
return
resourcePath
;
}
private
static
String
getTypeFromAction
(
String
action
)
{
if
(
GeckoApp
.
ACTION_HOMESCREEN_SHORTCUT
.
equals
(
action
)
)
{
return
"
-
bookmark
"
;
}
return
null
;
}
private
static
String
addCustomProfileArg
(
String
args
)
{
String
profileArg
=
"
"
;
String
guestArg
=
"
"
;
if
(
GeckoAppShell
.
getGeckoInterface
(
)
!
=
null
)
{
final
GeckoProfile
profile
=
GeckoAppShell
.
getGeckoInterface
(
)
.
getProfile
(
)
;
if
(
profile
.
inGuestMode
(
)
)
{
try
{
profileArg
=
"
-
profile
"
+
profile
.
getDir
(
)
.
getCanonicalPath
(
)
;
}
catch
(
final
IOException
ioe
)
{
Log
.
e
(
LOGTAG
"
error
getting
guest
profile
path
"
ioe
)
;
}
if
(
args
=
=
null
|
|
!
args
.
contains
(
BrowserApp
.
GUEST_BROWSING_ARG
)
)
{
guestArg
=
"
"
+
BrowserApp
.
GUEST_BROWSING_ARG
;
}
}
else
if
(
!
GeckoProfile
.
sIsUsingCustomProfile
)
{
profileArg
=
"
-
P
"
+
profile
.
forceCreate
(
)
.
getName
(
)
;
}
}
return
(
args
!
=
null
?
args
:
"
"
)
+
profileArg
+
guestArg
;
}
private
String
getGeckoArgs
(
final
String
apkPath
)
{
final
StringBuilder
args
=
new
StringBuilder
(
apkPath
)
;
args
.
append
(
"
-
greomni
"
)
.
append
(
apkPath
)
;
final
String
userArgs
=
addCustomProfileArg
(
mArgs
)
;
if
(
userArgs
!
=
null
)
{
args
.
append
(
'
'
)
.
append
(
userArgs
)
;
}
if
(
mUri
!
=
null
)
{
args
.
append
(
"
-
url
"
)
.
append
(
mUri
)
;
}
final
String
type
=
getTypeFromAction
(
mAction
)
;
if
(
type
!
=
null
)
{
args
.
append
(
"
"
)
.
append
(
type
)
;
}
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
{
Log
.
w
(
LOGTAG
"
STARTUP
PERFORMANCE
WARNING
:
un
-
official
build
:
purging
the
"
+
"
startup
(
JavaScript
)
caches
.
"
)
;
args
.
append
(
"
-
purgecaches
"
)
;
}
final
DisplayMetrics
metrics
=
GeckoAppShell
.
getContext
(
)
.
getResources
(
)
.
getDisplayMetrics
(
)
;
args
.
append
(
"
-
width
"
)
.
append
(
metrics
.
widthPixels
)
.
append
(
"
-
height
"
)
.
append
(
metrics
.
heightPixels
)
;
return
args
.
toString
(
)
;
}
Override
public
void
run
(
)
{
Looper
.
prepare
(
)
;
GeckoThread
.
msgQueue
=
Looper
.
myQueue
(
)
;
ThreadUtils
.
sGeckoThread
=
this
;
ThreadUtils
.
sGeckoHandler
=
new
Handler
(
)
;
final
MessageQueue
.
IdleHandler
idleHandler
=
new
MessageQueue
.
IdleHandler
(
)
{
Override
public
boolean
queueIdle
(
)
{
final
Handler
geckoHandler
=
ThreadUtils
.
sGeckoHandler
;
Message
idleMsg
=
Message
.
obtain
(
geckoHandler
)
;
idleMsg
.
obj
=
geckoHandler
;
geckoHandler
.
sendMessageAtFrontOfQueue
(
idleMsg
)
;
return
true
;
}
}
;
Looper
.
myQueue
(
)
.
addIdleHandler
(
idleHandler
)
;
if
(
mDebugging
)
{
try
{
Thread
.
sleep
(
5
*
1000
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
final
String
args
=
getGeckoArgs
(
initGeckoEnvironment
(
)
)
;
ThreadUtils
.
postToUiThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
GeckoAppShell
.
registerJavaUiThread
(
)
;
}
}
)
;
Log
.
w
(
LOGTAG
"
zerdatime
"
+
SystemClock
.
uptimeMillis
(
)
+
"
-
runGecko
"
)
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
{
Log
.
i
(
LOGTAG
"
RunGecko
-
args
=
"
+
args
)
;
}
GeckoLoader
.
nativeRun
(
args
)
;
setState
(
State
.
EXITED
)
;
try
{
final
JSONObject
msg
=
new
JSONObject
(
)
;
msg
.
put
(
"
type
"
"
Gecko
:
Exited
"
)
;
EventDispatcher
.
getInstance
(
)
.
dispatchEvent
(
msg
null
)
;
}
catch
(
final
JSONException
e
)
{
Log
.
e
(
LOGTAG
"
unable
to
dispatch
event
"
e
)
;
}
Looper
.
myQueue
(
)
.
removeIdleHandler
(
idleHandler
)
;
}
public
static
void
addPendingEvent
(
final
GeckoEvent
e
)
{
synchronized
(
QUEUED_CALLS
)
{
if
(
QUEUED_CALLS
.
size
(
)
=
=
0
&
&
isRunning
(
)
)
{
GeckoAppShell
.
notifyGeckoOfEvent
(
e
)
;
e
.
recycle
(
)
;
}
else
{
QUEUED_CALLS
.
add
(
new
QueuedCall
(
null
e
null
State
.
RUNNING
)
)
;
}
}
}
WrapForJNI
private
static
boolean
pumpMessageLoop
(
final
Message
msg
)
{
final
Handler
geckoHandler
=
ThreadUtils
.
sGeckoHandler
;
if
(
msg
.
obj
=
=
geckoHandler
&
&
msg
.
getTarget
(
)
=
=
geckoHandler
)
{
return
false
;
}
if
(
msg
.
getTarget
(
)
=
=
null
)
{
Looper
.
myLooper
(
)
.
quit
(
)
;
}
else
{
msg
.
getTarget
(
)
.
dispatchMessage
(
msg
)
;
}
return
true
;
}
Override
public
void
handleMessage
(
String
event
JSONObject
message
)
{
if
(
"
Gecko
:
Ready
"
.
equals
(
event
)
)
{
EventDispatcher
.
getInstance
(
)
.
unregisterGeckoThreadListener
(
this
event
)
;
setState
(
State
.
RUNNING
)
;
}
}
public
static
boolean
isState
(
final
State
state
)
{
return
sState
.
get
(
)
.
is
(
state
)
;
}
public
static
boolean
isStateAtLeast
(
final
State
state
)
{
return
sState
.
get
(
)
.
isAtLeast
(
state
)
;
}
public
static
boolean
isStateAtMost
(
final
State
state
)
{
return
sState
.
get
(
)
.
isAtMost
(
state
)
;
}
public
static
boolean
isStateBetween
(
final
State
minState
final
State
maxState
)
{
return
sState
.
get
(
)
.
isBetween
(
minState
maxState
)
;
}
WrapForJNI
private
static
void
setState
(
final
State
newState
)
{
ThreadUtils
.
assertOnGeckoThread
(
)
;
sState
.
set
(
newState
)
;
flushQueuedNativeCalls
(
newState
)
;
}
private
static
boolean
checkAndSetState
(
final
State
currentState
final
State
newState
)
{
if
(
!
sState
.
compareAndSet
(
currentState
newState
)
)
{
return
false
;
}
flushQueuedNativeCalls
(
newState
)
;
return
true
;
}
WrapForJNI
(
stubName
=
"
SpeculativeConnect
"
)
private
static
native
void
speculativeConnectNative
(
String
uri
)
;
public
static
void
speculativeConnect
(
final
String
uri
)
{
queueNativeCallUntil
(
State
.
PROFILE_READY
GeckoThread
.
class
"
speculativeConnectNative
"
uri
)
;
}
}
