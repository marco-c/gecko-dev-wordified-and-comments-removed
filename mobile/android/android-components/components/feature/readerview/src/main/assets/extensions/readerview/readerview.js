const
preservedClasses
=
[
"
caption
"
"
emoji
"
"
hidden
"
"
invisible
"
"
sr
-
only
"
"
visually
-
hidden
"
"
visuallyhidden
"
"
wp
-
caption
"
"
wp
-
caption
-
text
"
"
wp
-
smiley
"
]
;
class
ReaderView
{
static
get
MIN_FONT_SIZE
(
)
{
return
1
;
}
static
get
MAX_FONT_SIZE
(
)
{
return
9
;
}
show
(
doc
url
options
=
{
fontSize
:
4
fontType
:
"
sans
-
serif
"
colorScheme
:
"
light
"
}
)
{
let
result
=
new
Readability
(
doc
{
classesToPreserve
:
preservedClasses
}
)
.
parse
(
)
;
result
.
language
=
doc
.
documentElement
.
lang
;
document
.
title
=
result
.
title
;
let
article
=
Object
.
assign
(
result
{
url
:
new
URL
(
url
)
}
{
readingTime
:
this
.
getReadingTime
(
result
.
length
result
.
language
)
}
{
byline
:
this
.
getByline
(
result
)
}
{
dir
:
this
.
getTextDirection
(
result
)
}
{
title
:
this
.
getTitle
(
result
)
}
)
;
document
.
body
.
outerHTML
=
this
.
createHtmlBody
(
article
)
;
this
.
setFontSize
(
options
.
fontSize
)
;
this
.
setFontType
(
options
.
fontType
)
;
this
.
setColorScheme
(
options
.
colorScheme
)
;
}
changeFontSize
(
changeAmount
)
{
var
size
=
Math
.
max
(
ReaderView
.
MIN_FONT_SIZE
Math
.
min
(
ReaderView
.
MAX_FONT_SIZE
this
.
fontSize
+
changeAmount
)
)
;
this
.
setFontSize
(
size
)
;
}
setFontSize
(
fontSize
)
{
let
size
=
(
10
+
2
*
fontSize
)
+
"
px
"
;
let
readerView
=
document
.
getElementById
(
"
mozac
-
readerview
-
container
"
)
;
readerView
.
style
.
setProperty
(
"
font
-
size
"
size
)
;
this
.
fontSize
=
fontSize
;
}
setFontType
(
fontType
)
{
let
bodyClasses
=
document
.
body
.
classList
;
if
(
this
.
fontType
)
{
bodyClasses
.
remove
(
this
.
fontType
)
;
}
this
.
fontType
=
fontType
;
bodyClasses
.
add
(
this
.
fontType
)
;
}
setColorScheme
(
colorScheme
)
{
if
(
!
[
'
light
'
'
sepia
'
'
dark
'
]
.
includes
(
colorScheme
)
)
{
console
.
error
(
Invalid
color
scheme
specified
:
{
colorScheme
}
)
return
;
}
let
bodyClasses
=
document
.
body
.
classList
;
if
(
this
.
colorScheme
)
{
bodyClasses
.
remove
(
this
.
colorScheme
)
;
}
this
.
colorScheme
=
colorScheme
;
bodyClasses
.
add
(
this
.
colorScheme
)
;
}
createHtmlBody
(
article
)
{
const
safeDir
=
this
.
escapeHTML
(
article
.
dir
)
;
const
safeTitle
=
this
.
escapeHTML
(
article
.
title
)
;
const
safeByline
=
this
.
escapeHTML
(
article
.
byline
)
;
const
safeReadingTime
=
this
.
escapeHTML
(
article
.
readingTime
)
;
return
<
body
class
=
"
mozac
-
readerview
-
body
"
>
<
div
id
=
"
mozac
-
readerview
-
container
"
class
=
"
container
"
dir
=
"
{
safeDir
}
"
>
<
div
class
=
"
header
"
>
<
a
class
=
"
domain
"
href
=
"
{
article
.
url
.
href
}
"
>
{
article
.
url
.
hostname
}
<
/
a
>
<
div
class
=
"
domain
-
border
"
>
<
/
div
>
<
h1
>
{
safeTitle
}
<
/
h1
>
<
div
class
=
"
credits
"
>
{
safeByline
}
<
/
div
>
<
div
>
<
div
>
{
safeReadingTime
}
<
/
div
>
<
/
div
>
<
/
div
>
<
hr
>
<
div
class
=
"
content
"
>
<
div
class
=
"
mozac
-
readerview
-
content
"
>
{
article
.
content
}
<
/
div
>
<
/
div
>
<
/
div
>
<
/
body
>
}
getReadingTime
(
length
lang
=
"
en
"
)
{
const
readingSpeed
=
this
.
getReadingSpeedForLanguage
(
lang
)
;
const
charactersPerMinuteLow
=
readingSpeed
.
cpm
-
readingSpeed
.
variance
;
const
charactersPerMinuteHigh
=
readingSpeed
.
cpm
+
readingSpeed
.
variance
;
const
readingTimeMinsSlow
=
Math
.
ceil
(
length
/
charactersPerMinuteLow
)
;
const
readingTimeMinsFast
=
Math
.
ceil
(
length
/
charactersPerMinuteHigh
)
;
try
{
var
parts
=
new
Intl
.
RelativeTimeFormat
(
lang
)
.
formatToParts
(
readingTimeMinsSlow
'
minute
'
)
;
if
(
parts
.
length
=
=
3
)
{
var
readingTime
=
parts
[
1
]
.
value
;
var
minutesLiteral
=
parts
[
2
]
.
value
;
var
readingTimeString
=
{
readingTime
}
{
minutesLiteral
}
;
if
(
readingTimeMinsSlow
!
=
readingTimeMinsFast
)
{
readingTimeString
=
{
readingTimeMinsFast
}
-
{
readingTimeString
}
;
}
return
readingTimeString
;
}
}
catch
(
error
)
{
console
.
error
(
Failed
to
format
reading
time
:
{
error
}
)
;
}
return
"
"
;
}
getReadingSpeedForLanguage
(
lang
)
{
const
readingSpeed
=
new
Map
(
[
[
"
en
"
{
cpm
:
987
variance
:
118
}
]
[
"
ar
"
{
cpm
:
612
variance
:
88
}
]
[
"
de
"
{
cpm
:
920
variance
:
86
}
]
[
"
es
"
{
cpm
:
1025
variance
:
127
}
]
[
"
fi
"
{
cpm
:
1078
variance
:
121
}
]
[
"
fr
"
{
cpm
:
998
variance
:
126
}
]
[
"
he
"
{
cpm
:
833
variance
:
130
}
]
[
"
it
"
{
cpm
:
950
variance
:
140
}
]
[
"
jw
"
{
cpm
:
357
variance
:
56
}
]
[
"
nl
"
{
cpm
:
978
variance
:
143
}
]
[
"
pl
"
{
cpm
:
916
variance
:
126
}
]
[
"
pt
"
{
cpm
:
913
variance
:
145
}
]
[
"
ru
"
{
cpm
:
986
variance
:
175
}
]
[
"
sk
"
{
cpm
:
885
variance
:
145
}
]
[
"
sv
"
{
cpm
:
917
variance
:
156
}
]
[
"
tr
"
{
cpm
:
1054
variance
:
156
}
]
[
"
zh
"
{
cpm
:
255
variance
:
29
}
]
]
)
;
return
readingSpeed
.
get
(
lang
)
|
|
readingSpeed
.
get
(
"
en
"
)
;
}
getByline
(
article
)
{
return
article
.
byline
|
|
"
"
;
}
getTextDirection
(
article
)
{
if
(
article
.
dir
)
{
return
article
.
dir
;
}
if
(
[
"
ar
"
"
fa
"
"
he
"
"
ug
"
"
ur
"
]
.
includes
(
article
.
language
)
)
{
return
"
rtl
"
;
}
return
"
ltr
"
;
}
getTitle
(
article
)
{
return
article
.
title
|
|
"
"
;
}
escapeHTML
(
text
)
{
return
text
.
replace
(
/
\
&
/
g
"
&
amp
;
"
)
.
replace
(
/
\
<
/
g
"
&
lt
;
"
)
.
replace
(
/
\
>
/
g
"
&
gt
;
"
)
.
replace
(
/
\
"
/
g
"
&
quot
;
"
)
.
replace
(
/
\
'
/
g
"
&
#
039
;
"
)
;
}
}
function
fetchDocument
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
onerror
=
evt
=
>
reject
(
evt
.
error
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
onload
=
evt
=
>
{
if
(
xhr
.
status
!
=
=
200
)
{
reject
(
"
Reader
mode
XHR
failed
with
status
:
"
+
xhr
.
status
)
;
return
;
}
let
doc
=
xhr
.
responseXML
;
if
(
!
doc
)
{
reject
(
"
Reader
mode
XHR
didn
'
t
return
a
document
"
)
;
return
;
}
resolve
(
doc
)
;
}
;
xhr
.
send
(
)
;
}
)
;
}
function
getPreparedDocument
(
id
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
browser
.
runtime
.
sendMessage
(
{
action
:
"
getSerializedDoc
"
id
:
id
}
)
.
then
(
(
serializedDoc
)
=
>
{
if
(
serializedDoc
)
{
let
doc
=
new
JSDOMParser
(
)
.
parse
(
serializedDoc
url
)
;
resolve
(
doc
)
;
}
else
{
reject
(
)
;
}
}
)
;
}
)
;
}
let
readerView
=
new
ReaderView
(
)
;
connectNativePort
(
)
;
prepareBody
(
)
;
function
connectNativePort
(
)
{
let
url
=
new
URL
(
window
.
location
.
href
)
;
let
articleUrl
=
url
.
searchParams
.
get
(
"
url
"
)
;
let
id
=
url
.
searchParams
.
get
(
"
id
"
)
;
let
baseUrl
=
browser
.
runtime
.
getURL
(
"
/
"
)
;
let
port
=
browser
.
runtime
.
connectNative
(
"
mozacReaderviewActive
"
)
;
port
.
onMessage
.
addListener
(
(
message
)
=
>
{
switch
(
message
.
action
)
{
case
'
show
'
:
async
function
showAsync
(
options
)
{
try
{
let
doc
;
if
(
typeof
Promise
.
any
=
=
=
"
function
"
)
{
doc
=
await
Promise
.
any
(
[
fetchDocument
(
articleUrl
)
getPreparedDocument
(
id
articleUrl
)
]
)
;
}
else
{
try
{
doc
=
await
getPreparedDocument
(
id
articleUrl
)
;
}
catch
(
e
)
{
doc
=
await
fetchDocument
(
articleUrl
)
;
}
}
readerView
.
show
(
doc
articleUrl
options
)
;
}
catch
(
e
)
{
console
.
log
(
e
)
;
window
.
location
.
href
=
articleUrl
;
}
}
showAsync
(
message
.
value
)
;
break
;
case
'
hide
'
:
window
.
location
.
href
=
articleUrl
;
case
'
setColorScheme
'
:
readerView
.
setColorScheme
(
message
.
value
.
toLowerCase
(
)
)
;
break
;
case
'
changeFontSize
'
:
readerView
.
changeFontSize
(
message
.
value
)
;
break
;
case
'
setFontType
'
:
readerView
.
setFontType
(
message
.
value
.
toLowerCase
(
)
)
;
break
;
case
'
checkReaderState
'
:
port
.
postMessage
(
{
baseUrl
:
baseUrl
activeUrl
:
articleUrl
readerable
:
true
}
)
;
break
;
default
:
console
.
error
(
Received
invalid
action
{
message
.
action
}
)
;
}
}
)
;
}
function
prepareBody
(
)
{
let
url
=
new
URL
(
window
.
location
.
href
)
;
let
colorScheme
=
url
.
searchParams
.
get
(
"
colorScheme
"
)
;
let
body
=
document
.
createElement
(
"
body
"
)
;
body
.
classList
.
add
(
"
mozac
-
readerview
-
body
"
)
;
body
.
classList
.
add
(
colorScheme
)
;
document
.
body
=
body
;
}
