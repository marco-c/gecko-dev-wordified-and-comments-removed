const
preservedClasses
=
[
"
caption
"
"
emoji
"
"
hidden
"
"
invisble
"
"
sr
-
only
"
"
visually
-
hidden
"
"
visuallyhidden
"
"
wp
-
caption
"
"
wp
-
caption
-
text
"
"
wp
-
smiley
"
]
;
class
ReaderView
{
static
get
MIN_FONT_SIZE
(
)
{
return
1
;
}
static
get
MAX_FONT_SIZE
(
)
{
return
9
;
}
show
(
doc
url
options
=
{
fontSize
:
4
fontType
:
"
sans
-
serif
"
colorScheme
:
"
light
"
}
)
{
let
result
=
new
Readability
(
doc
{
classesToPreserve
:
preservedClasses
}
)
.
parse
(
)
;
result
.
language
=
doc
.
documentElement
.
lang
;
let
article
=
Object
.
assign
(
result
{
url
:
new
URL
(
url
)
.
hostname
}
{
readingTime
:
this
.
getReadingTime
(
result
.
length
result
.
language
)
}
{
byline
:
this
.
getByline
(
)
}
{
dir
:
this
.
getTextDirection
(
result
)
}
)
;
document
.
body
.
outerHTML
=
this
.
createHtmlBody
(
article
)
;
this
.
setFontSize
(
options
.
fontSize
)
;
this
.
setFontType
(
options
.
fontType
)
;
this
.
setColorScheme
(
options
.
colorScheme
)
;
document
.
title
=
article
.
title
;
}
changeFontSize
(
changeAmount
)
{
var
size
=
Math
.
max
(
ReaderView
.
MIN_FONT_SIZE
Math
.
min
(
ReaderView
.
MAX_FONT_SIZE
this
.
fontSize
+
changeAmount
)
)
;
this
.
setFontSize
(
size
)
;
}
setFontSize
(
fontSize
)
{
let
size
=
(
10
+
2
*
fontSize
)
+
"
px
"
;
let
readerView
=
document
.
getElementById
(
"
mozac
-
readerview
-
container
"
)
;
readerView
.
style
.
setProperty
(
"
font
-
size
"
size
)
;
this
.
fontSize
=
fontSize
;
}
setFontType
(
fontType
)
{
let
bodyClasses
=
document
.
body
.
classList
;
if
(
this
.
fontType
)
{
bodyClasses
.
remove
(
this
.
fontType
)
}
this
.
fontType
=
fontType
bodyClasses
.
add
(
this
.
fontType
)
}
setColorScheme
(
colorScheme
)
{
if
(
!
[
'
light
'
'
sepia
'
'
dark
'
]
.
includes
(
colorScheme
)
)
{
console
.
error
(
Invalid
color
scheme
specified
:
{
colorScheme
}
)
return
;
}
let
bodyClasses
=
document
.
body
.
classList
;
if
(
this
.
colorScheme
)
{
bodyClasses
.
remove
(
this
.
colorScheme
)
}
this
.
colorScheme
=
colorScheme
bodyClasses
.
add
(
this
.
colorScheme
)
}
createHtmlBody
(
article
)
{
return
<
body
class
=
"
mozac
-
readerview
-
body
"
>
<
div
id
=
"
mozac
-
readerview
-
container
"
class
=
"
container
"
dir
=
{
article
.
dir
}
>
<
div
class
=
"
header
"
>
<
a
class
=
"
domain
"
>
{
article
.
url
}
<
/
a
>
<
div
class
=
"
domain
-
border
"
>
<
/
div
>
<
h1
>
{
article
.
title
}
<
/
h1
>
<
div
class
=
"
credits
"
>
{
article
.
byline
}
<
/
div
>
<
div
>
<
div
>
{
article
.
readingTime
}
<
/
div
>
<
/
div
>
<
/
div
>
<
hr
>
<
div
class
=
"
content
"
>
<
div
class
=
"
mozac
-
readerview
-
content
"
>
{
article
.
content
}
<
/
div
>
<
/
div
>
<
/
div
>
<
/
body
>
}
getReadingTime
(
length
lang
=
"
en
"
)
{
const
readingSpeed
=
this
.
getReadingSpeedForLanguage
(
lang
)
;
const
charactersPerMinuteLow
=
readingSpeed
.
cpm
-
readingSpeed
.
variance
;
const
charactersPerMinuteHigh
=
readingSpeed
.
cpm
+
readingSpeed
.
variance
;
const
readingTimeMinsSlow
=
Math
.
ceil
(
length
/
charactersPerMinuteLow
)
;
const
readingTimeMinsFast
=
Math
.
ceil
(
length
/
charactersPerMinuteHigh
)
;
try
{
var
parts
=
new
Intl
.
RelativeTimeFormat
(
lang
)
.
formatToParts
(
readingTimeMinsSlow
'
minute
'
)
;
if
(
parts
.
length
=
=
3
)
{
var
readingTime
=
parts
[
1
]
.
value
;
var
minutesLiteral
=
parts
[
2
]
.
value
;
var
readingTimeString
=
{
readingTime
}
{
minutesLiteral
}
;
if
(
readingTimeMinsSlow
!
=
readingTimeMinsFast
)
{
readingTimeString
=
{
readingTimeMinsFast
}
-
{
readingTimeString
}
;
}
return
readingTimeString
;
}
}
catch
(
error
)
{
console
.
error
(
Failed
to
format
reading
time
:
{
error
}
)
;
}
return
"
"
;
}
getReadingSpeedForLanguage
(
lang
)
{
const
readingSpeed
=
new
Map
(
[
[
"
en
"
{
cpm
:
987
variance
:
118
}
]
[
"
ar
"
{
cpm
:
612
variance
:
88
}
]
[
"
de
"
{
cpm
:
920
variance
:
86
}
]
[
"
es
"
{
cpm
:
1025
variance
:
127
}
]
[
"
fi
"
{
cpm
:
1078
variance
:
121
}
]
[
"
fr
"
{
cpm
:
998
variance
:
126
}
]
[
"
he
"
{
cpm
:
833
variance
:
130
}
]
[
"
it
"
{
cpm
:
950
variance
:
140
}
]
[
"
jw
"
{
cpm
:
357
variance
:
56
}
]
[
"
nl
"
{
cpm
:
978
variance
:
143
}
]
[
"
pl
"
{
cpm
:
916
variance
:
126
}
]
[
"
pt
"
{
cpm
:
913
variance
:
145
}
]
[
"
ru
"
{
cpm
:
986
variance
:
175
}
]
[
"
sk
"
{
cpm
:
885
variance
:
145
}
]
[
"
sv
"
{
cpm
:
917
variance
:
156
}
]
[
"
tr
"
{
cpm
:
1054
variance
:
156
}
]
[
"
zh
"
{
cpm
:
255
variance
:
29
}
]
]
)
;
return
readingSpeed
.
get
(
lang
)
|
|
readingSpeed
.
get
(
"
en
"
)
;
}
getByline
(
)
{
var
metadata
=
{
}
;
var
values
=
{
}
;
var
metaElements
=
[
.
.
.
document
.
getElementsByTagName
(
"
meta
"
)
]
;
var
propertyPattern
=
/
\
s
*
(
dc
|
dcterm
|
og
|
twitter
)
\
s
*
:
\
s
*
(
author
|
creator
|
description
|
title
|
site_name
)
\
s
*
/
gi
;
var
namePattern
=
/
^
\
s
*
(
?
:
(
dc
|
dcterm
|
og
|
twitter
|
weibo
:
(
article
|
webpage
)
)
\
s
*
[
\
.
:
]
\
s
*
)
?
(
author
|
creator
|
description
|
title
|
site_name
)
\
s
*
/
i
;
metaElements
.
forEach
(
(
element
)
=
>
{
var
elementName
=
element
.
getAttribute
(
"
name
"
)
;
var
elementProperty
=
element
.
getAttribute
(
"
property
"
)
;
var
content
=
element
.
getAttribute
(
"
content
"
)
;
if
(
!
content
)
{
return
;
}
var
matches
=
null
;
var
name
=
null
;
if
(
elementProperty
)
{
matches
=
elementProperty
.
match
(
propertyPattern
)
;
if
(
matches
)
{
for
(
var
i
=
matches
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
name
=
matches
[
i
]
.
toLowerCase
(
)
.
replace
(
/
\
s
/
g
"
"
)
;
values
[
name
]
=
content
.
trim
(
)
;
}
}
}
if
(
!
matches
&
&
elementName
&
&
namePattern
.
test
(
elementName
)
)
{
name
=
elementName
;
if
(
content
)
{
name
=
name
.
toLowerCase
(
)
.
replace
(
/
\
s
/
g
"
"
)
.
replace
(
/
\
.
/
g
"
:
"
)
;
values
[
name
]
=
content
.
trim
(
)
;
}
}
}
)
;
return
values
[
"
dc
:
creator
"
]
|
|
values
[
"
dcterm
:
creator
"
]
|
|
values
[
"
author
"
]
|
|
"
"
;
}
getTextDirection
(
article
)
{
if
(
article
.
dir
)
{
return
article
.
dir
}
if
(
[
"
ar
"
"
fa
"
"
he
"
"
ug
"
"
ur
"
]
.
includes
(
article
.
language
)
)
{
return
"
rtl
"
;
}
return
"
ltr
"
;
}
}
function
fetchDocument
(
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
onerror
=
evt
=
>
reject
(
evt
.
error
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
onload
=
evt
=
>
{
if
(
xhr
.
status
!
=
=
200
)
{
reject
(
"
Reader
mode
XHR
failed
with
status
:
"
+
xhr
.
status
)
;
return
;
}
let
doc
=
xhr
.
responseXML
;
if
(
!
doc
)
{
reject
(
"
Reader
mode
XHR
didn
'
t
return
a
document
"
)
;
return
;
}
resolve
(
doc
)
;
}
;
xhr
.
send
(
)
;
}
)
;
}
function
getPreparedDocument
(
id
url
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
browser
.
runtime
.
sendMessage
(
{
action
:
"
getSerializedDoc
"
id
:
id
}
)
.
then
(
(
serializedDoc
)
=
>
{
if
(
serializedDoc
)
{
let
doc
=
new
JSDOMParser
(
)
.
parse
(
serializedDoc
url
)
;
resolve
(
doc
)
;
}
else
{
reject
(
)
;
}
}
)
;
}
)
;
}
let
readerView
=
new
ReaderView
(
)
;
connectNativePort
(
)
;
function
connectNativePort
(
)
{
let
url
=
new
URL
(
window
.
location
.
href
)
;
let
articleUrl
=
decodeURIComponent
(
url
.
searchParams
.
get
(
"
url
"
)
)
;
let
id
=
url
.
searchParams
.
get
(
"
id
"
)
;
let
baseUrl
=
browser
.
runtime
.
getURL
(
"
/
"
)
;
let
port
=
browser
.
runtime
.
connectNative
(
"
mozacReaderview
"
)
;
port
.
onMessage
.
addListener
(
(
message
)
=
>
{
switch
(
message
.
action
)
{
case
'
show
'
:
async
function
showAsync
(
options
)
{
try
{
let
doc
=
await
Promise
.
any
(
[
fetchDocument
(
articleUrl
)
getPreparedDocument
(
id
articleUrl
)
]
)
;
readerView
.
show
(
doc
articleUrl
options
)
;
}
catch
(
e
)
{
console
.
log
(
e
)
;
window
.
location
.
href
=
articleUrl
;
}
}
showAsync
(
message
.
value
)
;
break
;
case
'
hide
'
:
window
.
location
.
href
=
articleUrl
;
case
'
setColorScheme
'
:
readerView
.
setColorScheme
(
message
.
value
.
toLowerCase
(
)
)
;
break
;
case
'
changeFontSize
'
:
readerView
.
changeFontSize
(
message
.
value
)
;
break
;
case
'
setFontType
'
:
readerView
.
setFontType
(
message
.
value
.
toLowerCase
(
)
)
;
break
;
case
'
checkReaderState
'
:
port
.
postMessage
(
{
baseUrl
:
baseUrl
activeUrl
:
articleUrl
readerable
:
true
}
)
;
break
;
default
:
console
.
error
(
Received
invalid
action
{
message
.
action
}
)
;
}
}
)
;
window
.
addEventListener
(
"
unload
"
(
event
)
=
>
{
port
.
disconnect
(
)
}
false
)
;
}
