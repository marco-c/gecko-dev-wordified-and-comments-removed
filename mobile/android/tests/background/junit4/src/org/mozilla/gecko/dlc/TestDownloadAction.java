package
org
.
mozilla
.
gecko
.
dlc
;
import
android
.
content
.
Context
;
import
org
.
junit
.
Assert
;
import
org
.
junit
.
Test
;
import
org
.
junit
.
runner
.
RunWith
;
import
org
.
mozilla
.
gecko
.
background
.
testhelpers
.
TestRunner
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContent
;
import
org
.
mozilla
.
gecko
.
dlc
.
catalog
.
DownloadContentCatalog
;
import
org
.
robolectric
.
RuntimeEnvironment
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
static
org
.
mockito
.
Matchers
.
*
;
import
static
org
.
mockito
.
Mockito
.
*
;
RunWith
(
TestRunner
.
class
)
public
class
TestDownloadAction
{
private
static
final
String
TEST_URL
=
"
http
:
/
/
example
.
org
"
;
private
static
final
int
STATUS_OK
=
200
;
private
static
final
int
STATUS_PARTIAL_CONTENT
=
206
;
Test
public
void
testNothingIsDoneOnMeteredNetwork
(
)
throws
Exception
{
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
true
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
action
.
perform
(
RuntimeEnvironment
.
application
null
)
;
verify
(
action
never
(
)
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
verify
(
action
never
(
)
)
.
download
(
anyString
(
)
any
(
File
.
class
)
)
;
}
Test
public
void
testNothingIsDoneIfNoNetworkIsAvailable
(
)
throws
Exception
{
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isConnectedToNetwork
(
RuntimeEnvironment
.
application
)
;
action
.
perform
(
RuntimeEnvironment
.
application
null
)
;
verify
(
action
never
(
)
)
.
isActiveNetworkMetered
(
any
(
Context
.
class
)
)
;
verify
(
action
never
(
)
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
verify
(
action
never
(
)
)
.
download
(
anyString
(
)
any
(
File
.
class
)
)
;
}
Test
public
void
testExistingAndVerifiedFilesAreNotDownloadedAgain
(
)
throws
Exception
{
DownloadContent
content
=
new
DownloadContent
.
Builder
(
)
.
build
(
)
;
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Collections
.
singletonList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
File
file
=
mock
(
File
.
class
)
;
doReturn
(
true
)
.
when
(
file
)
.
exists
(
)
;
doReturn
(
file
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
file
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
true
)
.
when
(
action
)
.
verify
(
eq
(
file
)
anyString
(
)
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
action
never
(
)
)
.
download
(
anyString
(
)
any
(
File
.
class
)
)
;
verify
(
catalog
)
.
markAsDownloaded
(
content
)
;
}
Test
(
expected
=
BaseAction
.
RecoverableDownloadContentException
.
class
)
public
void
testServerErrorsAreRecoverable
(
)
throws
Exception
{
HttpURLConnection
connection
=
mockHttpURLConnection
(
500
"
"
)
;
File
temporaryFile
=
mock
(
File
.
class
)
;
doReturn
(
false
)
.
when
(
temporaryFile
)
.
exists
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
connection
)
.
when
(
action
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
action
.
download
(
TEST_URL
temporaryFile
)
;
verify
(
connection
)
.
getInputStream
(
)
;
}
Test
(
expected
=
BaseAction
.
UnrecoverableDownloadContentException
.
class
)
public
void
testClientErrorsAreUnrecoverable
(
)
throws
Exception
{
HttpURLConnection
connection
=
mockHttpURLConnection
(
404
"
"
)
;
File
temporaryFile
=
mock
(
File
.
class
)
;
doReturn
(
false
)
.
when
(
temporaryFile
)
.
exists
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
connection
)
.
when
(
action
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
action
.
download
(
TEST_URL
temporaryFile
)
;
verify
(
connection
)
.
getInputStream
(
)
;
}
Test
public
void
testSuccessfulDownloadsAreMarkedAsDownloaded
(
)
throws
Exception
{
DownloadContent
content
=
new
DownloadContent
.
Builder
(
)
.
setKind
(
DownloadContent
.
KIND_FONT
)
.
setType
(
DownloadContent
.
TYPE_ASSET_ARCHIVE
)
.
build
(
)
;
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Collections
.
singletonList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
File
file
=
mockNotExistingFile
(
)
;
doReturn
(
file
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
file
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
false
)
.
when
(
action
)
.
verify
(
eq
(
file
)
anyString
(
)
)
;
doNothing
(
)
.
when
(
action
)
.
download
(
anyString
(
)
eq
(
file
)
)
;
doReturn
(
true
)
.
when
(
action
)
.
verify
(
eq
(
file
)
anyString
(
)
)
;
doNothing
(
)
.
when
(
action
)
.
extract
(
eq
(
file
)
eq
(
file
)
anyString
(
)
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
action
)
.
download
(
anyString
(
)
eq
(
file
)
)
;
verify
(
action
)
.
extract
(
eq
(
file
)
eq
(
file
)
anyString
(
)
)
;
verify
(
catalog
)
.
markAsDownloaded
(
content
)
;
}
Test
public
void
testResumingDownloadFromExistingFile
(
)
throws
Exception
{
DownloadContent
content
=
new
DownloadContent
.
Builder
(
)
.
setKind
(
DownloadContent
.
KIND_FONT
)
.
setType
(
DownloadContent
.
TYPE_ASSET_ARCHIVE
)
.
setSize
(
4223
)
.
build
(
)
;
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Collections
.
singletonList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
File
temporaryFile
=
mockFileWithSize
(
1337L
)
;
doReturn
(
temporaryFile
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
ByteArrayOutputStream
outputStream
=
new
ByteArrayOutputStream
(
)
;
doReturn
(
outputStream
)
.
when
(
action
)
.
openFile
(
eq
(
temporaryFile
)
anyBoolean
(
)
)
;
HttpURLConnection
connection
=
mockHttpURLConnection
(
STATUS_PARTIAL_CONTENT
"
HelloWorld
"
)
;
doReturn
(
connection
)
.
when
(
action
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
File
destinationFile
=
mockNotExistingFile
(
)
;
doReturn
(
destinationFile
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
true
)
.
when
(
action
)
.
verify
(
eq
(
temporaryFile
)
anyString
(
)
)
;
doNothing
(
)
.
when
(
action
)
.
extract
(
eq
(
temporaryFile
)
eq
(
destinationFile
)
anyString
(
)
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
connection
)
.
getInputStream
(
)
;
verify
(
connection
)
.
setRequestProperty
(
"
Range
"
"
bytes
=
1337
-
"
)
;
Assert
.
assertEquals
(
"
HelloWorld
"
new
String
(
outputStream
.
toByteArray
(
)
"
UTF
-
8
"
)
)
;
verify
(
action
)
.
openFile
(
eq
(
temporaryFile
)
eq
(
true
)
)
;
verify
(
catalog
)
.
markAsDownloaded
(
content
)
;
verify
(
temporaryFile
)
.
delete
(
)
;
}
Test
public
void
testTemporaryFileIsNotDeletedAfterDownloadAborted
(
)
throws
Exception
{
DownloadContent
content
=
new
DownloadContent
.
Builder
(
)
.
setKind
(
DownloadContent
.
KIND_FONT
)
.
setType
(
DownloadContent
.
TYPE_ASSET_ARCHIVE
)
.
setSize
(
4223
)
.
build
(
)
;
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Collections
.
singletonList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
File
temporaryFile
=
mockFileWithSize
(
1337L
)
;
doReturn
(
temporaryFile
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
ByteArrayOutputStream
outputStream
=
spy
(
new
ByteArrayOutputStream
(
)
)
;
doReturn
(
outputStream
)
.
when
(
action
)
.
openFile
(
eq
(
temporaryFile
)
anyBoolean
(
)
)
;
doThrow
(
IOException
.
class
)
.
when
(
outputStream
)
.
write
(
any
(
byte
[
]
.
class
)
anyInt
(
)
anyInt
(
)
)
;
HttpURLConnection
connection
=
mockHttpURLConnection
(
STATUS_PARTIAL_CONTENT
"
HelloWorld
"
)
;
doReturn
(
connection
)
.
when
(
action
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
doReturn
(
mockNotExistingFile
(
)
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
catalog
never
(
)
)
.
markAsDownloaded
(
content
)
;
verify
(
action
never
(
)
)
.
verify
(
any
(
File
.
class
)
anyString
(
)
)
;
verify
(
temporaryFile
never
(
)
)
.
delete
(
)
;
}
Test
public
void
testNoRequestIsSentIfFileIsAlreadyComplete
(
)
throws
Exception
{
DownloadContent
content
=
new
DownloadContent
.
Builder
(
)
.
setKind
(
DownloadContent
.
KIND_FONT
)
.
setType
(
DownloadContent
.
TYPE_ASSET_ARCHIVE
)
.
setSize
(
1337L
)
.
build
(
)
;
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Collections
.
singletonList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
File
temporaryFile
=
mockFileWithSize
(
1337L
)
;
doReturn
(
temporaryFile
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
File
destinationFile
=
mockNotExistingFile
(
)
;
doReturn
(
destinationFile
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
true
)
.
when
(
action
)
.
verify
(
eq
(
temporaryFile
)
anyString
(
)
)
;
doNothing
(
)
.
when
(
action
)
.
extract
(
eq
(
temporaryFile
)
eq
(
destinationFile
)
anyString
(
)
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
action
never
(
)
)
.
download
(
anyString
(
)
eq
(
temporaryFile
)
)
;
verify
(
action
)
.
verify
(
eq
(
temporaryFile
)
anyString
(
)
)
;
verify
(
action
)
.
extract
(
eq
(
temporaryFile
)
eq
(
destinationFile
)
anyString
(
)
)
;
verify
(
catalog
)
.
markAsDownloaded
(
content
)
;
}
Test
public
void
testTemporaryFileWillBeDeletedIfVerificationFails
(
)
throws
Exception
{
DownloadContent
content
=
new
DownloadContent
.
Builder
(
)
.
setKind
(
DownloadContent
.
KIND_FONT
)
.
setType
(
DownloadContent
.
TYPE_ASSET_ARCHIVE
)
.
setSize
(
1337L
)
.
build
(
)
;
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Collections
.
singletonList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
doNothing
(
)
.
when
(
action
)
.
download
(
anyString
(
)
any
(
File
.
class
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
verify
(
any
(
File
.
class
)
anyString
(
)
)
;
File
temporaryFile
=
mockNotExistingFile
(
)
;
doReturn
(
temporaryFile
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
File
destinationFile
=
mockNotExistingFile
(
)
;
doReturn
(
destinationFile
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
temporaryFile
)
.
delete
(
)
;
verify
(
action
never
(
)
)
.
extract
(
any
(
File
.
class
)
any
(
File
.
class
)
anyString
(
)
)
;
verify
(
catalog
never
(
)
)
.
markAsDownloaded
(
content
)
;
}
Test
public
void
testNoDownloadIsPerformedIfNotEnoughStorageIsAvailable
(
)
throws
Exception
{
DownloadContent
content
=
createFontWithSize
(
1337L
)
;
DownloadContentCatalog
catalog
=
mockCatalogWithScheduledDownloads
(
content
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
doReturn
(
true
)
.
when
(
action
)
.
isConnectedToNetwork
(
RuntimeEnvironment
.
application
)
;
File
temporaryFile
=
mockNotExistingFile
(
)
;
doReturn
(
temporaryFile
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
File
destinationFile
=
mockNotExistingFile
(
)
;
doReturn
(
destinationFile
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
true
)
.
when
(
action
)
.
hasEnoughDiskSpace
(
content
destinationFile
temporaryFile
)
;
verify
(
action
never
(
)
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
verify
(
action
never
(
)
)
.
download
(
anyString
(
)
any
(
File
.
class
)
)
;
verify
(
action
never
(
)
)
.
verify
(
any
(
File
.
class
)
anyString
(
)
)
;
verify
(
catalog
never
(
)
)
.
markAsDownloaded
(
content
)
;
}
Test
public
void
testWithNotEnoughSpaceForTemporaryFile
(
)
throws
Exception
{
DownloadContent
content
=
createFontWithSize
(
2048
)
;
File
destinationFile
=
mockNotExistingFile
(
)
;
File
temporaryFile
=
mockNotExistingFileWithUsableSpace
(
1024
)
;
DownloadAction
action
=
new
DownloadAction
(
null
)
;
Assert
.
assertFalse
(
action
.
hasEnoughDiskSpace
(
content
destinationFile
temporaryFile
)
)
;
}
Test
public
void
testWithNotEnoughSpaceForDestinationFile
(
)
throws
Exception
{
DownloadContent
content
=
createFontWithSize
(
2048
)
;
File
destinationFile
=
mockNotExistingFileWithUsableSpace
(
1024
)
;
File
temporaryFile
=
mockNotExistingFile
(
)
;
DownloadAction
action
=
new
DownloadAction
(
null
)
;
Assert
.
assertFalse
(
action
.
hasEnoughDiskSpace
(
content
destinationFile
temporaryFile
)
)
;
}
Test
public
void
testWithEnoughSpaceForEverything
(
)
throws
Exception
{
DownloadContent
content
=
createFontWithSize
(
2048
)
;
File
destinationFile
=
mockNotExistingFileWithUsableSpace
(
4096
)
;
File
temporaryFile
=
mockNotExistingFileWithUsableSpace
(
4096
)
;
DownloadAction
action
=
new
DownloadAction
(
null
)
;
Assert
.
assertTrue
(
action
.
hasEnoughDiskSpace
(
content
destinationFile
temporaryFile
)
)
;
}
Test
public
void
testNetworkErrorIsNotCountedAsFailure
(
)
throws
Exception
{
DownloadContent
content
=
createFont
(
)
;
DownloadContentCatalog
catalog
=
mockCatalogWithScheduledDownloads
(
content
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
true
)
.
when
(
action
)
.
isConnectedToNetwork
(
RuntimeEnvironment
.
application
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
doReturn
(
mockNotExistingFile
(
)
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
mockNotExistingFile
(
)
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
true
)
.
when
(
action
)
.
hasEnoughDiskSpace
(
eq
(
content
)
any
(
File
.
class
)
any
(
File
.
class
)
)
;
HttpURLConnection
connection
=
mockHttpURLConnection
(
STATUS_OK
"
"
)
;
doThrow
(
IOException
.
class
)
.
when
(
connection
)
.
getInputStream
(
)
;
doReturn
(
connection
)
.
when
(
action
)
.
buildHttpURLConnection
(
anyString
(
)
)
;
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
verify
(
catalog
never
(
)
)
.
rememberFailure
(
eq
(
content
)
anyInt
(
)
)
;
verify
(
catalog
never
(
)
)
.
markAsDownloaded
(
content
)
;
}
Test
public
void
testDiskIOErrorIsCountedAsFailure
(
)
throws
Exception
{
DownloadContent
content
=
createFont
(
)
;
DownloadContentCatalog
catalog
=
mockCatalogWithScheduledDownloads
(
content
)
;
doCallRealMethod
(
)
.
when
(
catalog
)
.
rememberFailure
(
eq
(
content
)
anyInt
(
)
)
;
doCallRealMethod
(
)
.
when
(
catalog
)
.
markAsPermanentlyFailed
(
content
)
;
Assert
.
assertEquals
(
DownloadContent
.
STATE_NONE
content
.
getState
(
)
)
;
DownloadAction
action
=
spy
(
new
DownloadAction
(
null
)
)
;
doReturn
(
true
)
.
when
(
action
)
.
isConnectedToNetwork
(
RuntimeEnvironment
.
application
)
;
doReturn
(
false
)
.
when
(
action
)
.
isActiveNetworkMetered
(
RuntimeEnvironment
.
application
)
;
doReturn
(
mockNotExistingFile
(
)
)
.
when
(
action
)
.
createTemporaryFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
mockNotExistingFile
(
)
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
doReturn
(
true
)
.
when
(
action
)
.
hasEnoughDiskSpace
(
eq
(
content
)
any
(
File
.
class
)
any
(
File
.
class
)
)
;
doNothing
(
)
.
when
(
action
)
.
download
(
anyString
(
)
any
(
File
.
class
)
)
;
doReturn
(
true
)
.
when
(
action
)
.
verify
(
any
(
File
.
class
)
anyString
(
)
)
;
File
destinationFile
=
mock
(
File
.
class
)
;
doReturn
(
false
)
.
when
(
destinationFile
)
.
exists
(
)
;
File
parentFile
=
mock
(
File
.
class
)
;
doReturn
(
false
)
.
when
(
parentFile
)
.
mkdirs
(
)
;
doReturn
(
false
)
.
when
(
parentFile
)
.
exists
(
)
;
doReturn
(
parentFile
)
.
when
(
destinationFile
)
.
getParentFile
(
)
;
doReturn
(
destinationFile
)
.
when
(
action
)
.
getDestinationFile
(
RuntimeEnvironment
.
application
content
)
;
for
(
int
i
=
0
;
i
<
10
;
i
+
+
)
{
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
Assert
.
assertEquals
(
DownloadContent
.
STATE_NONE
content
.
getState
(
)
)
;
}
action
.
perform
(
RuntimeEnvironment
.
application
catalog
)
;
Assert
.
assertEquals
(
DownloadContent
.
STATE_FAILED
content
.
getState
(
)
)
;
verify
(
catalog
times
(
11
)
)
.
rememberFailure
(
eq
(
content
)
anyInt
(
)
)
;
}
private
DownloadContent
createFont
(
)
{
return
createFontWithSize
(
102400L
)
;
}
private
DownloadContent
createFontWithSize
(
long
size
)
{
return
new
DownloadContent
.
Builder
(
)
.
setKind
(
DownloadContent
.
KIND_FONT
)
.
setType
(
DownloadContent
.
TYPE_ASSET_ARCHIVE
)
.
setSize
(
size
)
.
build
(
)
;
}
private
DownloadContentCatalog
mockCatalogWithScheduledDownloads
(
DownloadContent
.
.
.
content
)
{
DownloadContentCatalog
catalog
=
mock
(
DownloadContentCatalog
.
class
)
;
doReturn
(
Arrays
.
asList
(
content
)
)
.
when
(
catalog
)
.
getScheduledDownloads
(
)
;
return
catalog
;
}
private
static
File
mockNotExistingFile
(
)
{
return
mockFileWithUsableSpace
(
false
0
Long
.
MAX_VALUE
)
;
}
private
static
File
mockNotExistingFileWithUsableSpace
(
long
usableSpace
)
{
return
mockFileWithUsableSpace
(
false
0
usableSpace
)
;
}
private
static
File
mockFileWithSize
(
long
length
)
{
return
mockFileWithUsableSpace
(
true
length
Long
.
MAX_VALUE
)
;
}
private
static
File
mockFileWithUsableSpace
(
boolean
exists
long
length
long
usableSpace
)
{
File
file
=
mock
(
File
.
class
)
;
doReturn
(
exists
)
.
when
(
file
)
.
exists
(
)
;
doReturn
(
length
)
.
when
(
file
)
.
length
(
)
;
File
parentFile
=
mock
(
File
.
class
)
;
doReturn
(
usableSpace
)
.
when
(
parentFile
)
.
getUsableSpace
(
)
;
doReturn
(
parentFile
)
.
when
(
file
)
.
getParentFile
(
)
;
return
file
;
}
private
static
HttpURLConnection
mockHttpURLConnection
(
int
statusCode
String
content
)
throws
Exception
{
HttpURLConnection
connection
=
mock
(
HttpURLConnection
.
class
)
;
doReturn
(
statusCode
)
.
when
(
connection
)
.
getResponseCode
(
)
;
doReturn
(
new
ByteArrayInputStream
(
content
.
getBytes
(
"
UTF
-
8
"
)
)
)
.
when
(
connection
)
.
getInputStream
(
)
;
return
connection
;
}
}
