{
let
c
=
Object
.
getOwnPropertyDescriptor
(
this
"
Components
"
)
;
if
(
(
!
c
.
value
|
|
c
.
writable
)
&
&
typeof
SpecialPowers
=
=
=
"
object
"
)
Components
=
SpecialPowers
.
wrap
(
SpecialPowers
.
Components
)
;
}
var
_quit
=
false
;
var
_tests_pending
=
0
;
var
_pendingTimers
=
[
]
;
var
_cleanupFunctions
=
[
]
;
function
_dump
(
str
)
{
let
start
=
/
^
TEST
-
/
.
test
(
str
)
?
"
\
n
"
:
"
"
;
dump
(
start
+
str
)
;
}
{
let
ios
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIIOService2
)
;
ios
.
manageOfflineStatus
=
false
;
ios
.
offline
=
false
;
}
var
runningInParent
=
true
;
try
{
runningInParent
=
Components
.
classes
[
"
mozilla
.
org
/
xre
/
runtime
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIXULRuntime
)
.
processType
=
=
Components
.
interfaces
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
}
catch
(
e
)
{
}
try
{
if
(
runningInParent
)
{
let
prefs
=
Components
.
classes
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIPrefBranch
)
;
prefs
.
setBoolPref
(
"
network
.
disable
.
ipc
.
security
"
true
)
;
if
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
in
Components
.
classes
)
{
prefs
.
setCharPref
(
"
network
.
dns
.
ipv4OnlyDomains
"
"
localhost
"
)
;
}
}
}
catch
(
e
)
{
}
try
{
if
(
runningInParent
&
&
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
in
Components
.
classes
)
{
let
crashReporter
=
Components
.
classes
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsICrashReporter
)
;
crashReporter
.
enabled
=
true
;
crashReporter
.
minidumpPath
=
do_get_cwd
(
)
;
}
}
catch
(
e
)
{
}
const
_timerFuzz
=
15
;
function
_Timer
(
func
delay
)
{
delay
=
Number
(
delay
)
;
if
(
delay
<
0
)
do_throw
(
"
do_timeout
(
)
delay
must
be
nonnegative
"
)
;
if
(
typeof
func
!
=
=
"
function
"
)
do_throw
(
"
string
callbacks
no
longer
accepted
;
use
a
function
!
"
)
;
this
.
_func
=
func
;
this
.
_start
=
Date
.
now
(
)
;
this
.
_delay
=
delay
;
var
timer
=
Components
.
classes
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsITimer
)
;
timer
.
initWithCallback
(
this
delay
+
_timerFuzz
timer
.
TYPE_ONE_SHOT
)
;
_pendingTimers
.
push
(
timer
)
;
}
_Timer
.
prototype
=
{
QueryInterface
:
function
(
iid
)
{
if
(
iid
.
equals
(
Components
.
interfaces
.
nsITimerCallback
)
|
|
iid
.
equals
(
Components
.
interfaces
.
nsISupports
)
)
return
this
;
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
}
notify
:
function
(
timer
)
{
_pendingTimers
.
splice
(
_pendingTimers
.
indexOf
(
timer
)
1
)
;
var
end
=
Date
.
now
(
)
;
var
elapsed
=
end
-
this
.
_start
;
if
(
elapsed
>
=
this
.
_delay
)
{
try
{
this
.
_func
.
call
(
null
)
;
}
catch
(
e
)
{
do_throw
(
"
exception
thrown
from
do_timeout
callback
:
"
+
e
)
;
}
return
;
}
var
newDelay
=
this
.
_delay
-
elapsed
;
do_timeout
(
newDelay
this
.
_func
)
;
}
}
;
function
_do_quit
(
)
{
_dump
(
"
TEST
-
INFO
|
(
xpcshell
/
head
.
js
)
|
exiting
test
\
n
"
)
;
_quit
=
true
;
}
function
_dump_exception_stack
(
stack
)
{
stack
.
split
(
"
\
n
"
)
.
forEach
(
function
(
frame
)
{
if
(
!
frame
)
return
;
let
frame_regexp
=
new
RegExp
(
"
(
.
*
)
\
\
(
.
*
\
\
)
(
.
*
)
:
(
\
\
d
*
)
"
"
g
"
)
;
let
parts
=
frame_regexp
.
exec
(
frame
)
;
if
(
parts
)
dump
(
"
JS
frame
:
:
"
+
parts
[
2
]
+
"
:
:
"
+
(
parts
[
1
]
?
parts
[
1
]
:
"
anonymous
"
)
+
"
:
:
line
"
+
parts
[
3
]
+
"
\
n
"
)
;
else
dump
(
"
JS
frame
:
:
"
+
frame
+
"
\
n
"
)
;
}
)
;
}
function
do_print
(
msg
)
{
var
caller_stack
=
Components
.
stack
.
caller
;
_dump
(
"
TEST
-
INFO
|
"
+
caller_stack
.
filename
+
"
|
"
+
msg
+
"
\
n
"
)
;
}
function
do_timeout
(
delay
func
)
{
new
_Timer
(
func
Number
(
delay
)
)
;
}
function
do_execute_soon
(
callback
)
{
do_test_pending
(
)
;
var
tm
=
Components
.
classes
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIThreadManager
)
;
tm
.
dispatchToMainThread
(
{
run
:
function
(
)
{
try
{
callback
(
)
;
}
catch
(
e
)
{
if
(
!
_quit
|
|
e
!
=
Components
.
results
.
NS_ERROR_ABORT
)
{
_dump
(
"
TEST
-
UNEXPECTED
-
FAIL
|
(
xpcshell
/
head
.
js
)
|
"
+
e
)
;
if
(
e
.
stack
)
{
dump
(
"
-
See
following
stack
:
\
n
"
)
;
_dump_exception_stack
(
e
.
stack
)
;
}
else
{
dump
(
"
\
n
"
)
;
}
_do_quit
(
)
;
}
}
finally
{
do_test_finished
(
)
;
}
}
}
)
;
}
function
do_throw
(
text
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
_dump
(
"
TEST
-
UNEXPECTED
-
FAIL
|
"
+
stack
.
filename
+
"
|
"
+
text
+
"
-
See
following
stack
:
\
n
"
)
;
var
frame
=
Components
.
stack
;
while
(
frame
!
=
null
)
{
_dump
(
frame
+
"
\
n
"
)
;
frame
=
frame
.
caller
;
}
_do_quit
(
)
;
throw
Components
.
results
.
NS_ERROR_ABORT
;
}
function
do_throw_todo
(
text
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
_dump
(
"
TEST
-
UNEXPECTED
-
PASS
|
"
+
stack
.
filename
+
"
|
"
+
text
+
"
-
See
following
stack
:
\
n
"
)
;
var
frame
=
Components
.
stack
;
while
(
frame
!
=
null
)
{
_dump
(
frame
+
"
\
n
"
)
;
frame
=
frame
.
caller
;
}
_do_quit
(
)
;
throw
Components
.
results
.
NS_ERROR_ABORT
;
}
function
do_report_unexpected_exception
(
ex
text
)
{
var
caller_stack
=
Components
.
stack
.
caller
;
text
=
text
?
text
+
"
-
"
:
"
"
;
_dump
(
"
TEST
-
UNEXPECTED
-
FAIL
|
"
+
caller_stack
.
filename
+
"
|
"
+
text
+
"
Unexpected
exception
"
+
ex
+
"
see
following
stack
:
\
n
"
+
ex
.
stack
+
"
\
n
"
)
;
_do_quit
(
)
;
throw
Components
.
results
.
NS_ERROR_ABORT
;
}
function
do_note_exception
(
ex
text
)
{
var
caller_stack
=
Components
.
stack
.
caller
;
text
=
text
?
text
+
"
-
"
:
"
"
;
_dump
(
"
TEST
-
INFO
|
"
+
caller_stack
.
filename
+
"
|
"
+
text
+
"
Swallowed
exception
"
+
ex
+
"
see
following
stack
:
\
n
"
+
ex
.
stack
+
"
\
n
"
)
;
}
function
_do_check_neq
(
left
right
stack
todo
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
var
text
=
left
+
"
!
=
"
+
right
;
if
(
left
=
=
right
)
{
if
(
!
todo
)
{
do_throw
(
text
stack
)
;
}
else
{
_dump
(
"
TEST
-
KNOWN
-
FAIL
|
"
+
stack
.
filename
+
"
|
[
"
+
stack
.
name
+
"
:
"
+
stack
.
lineNumber
+
"
]
"
+
text
+
"
\
n
"
)
;
}
}
else
if
(
!
todo
)
{
_dump
(
"
TEST
-
PASS
|
"
+
stack
.
filename
+
"
|
[
"
+
stack
.
name
+
"
:
"
+
stack
.
lineNumber
+
"
]
"
+
text
+
"
\
n
"
)
;
}
else
{
do_throw_todo
(
text
stack
)
;
}
}
function
do_check_neq
(
left
right
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
_do_check_neq
(
left
right
stack
false
)
;
}
function
todo_check_neq
(
left
right
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
_do_check_neq
(
left
right
stack
true
)
;
}
function
do_report_result
(
passed
text
stack
todo
)
{
if
(
passed
)
{
if
(
todo
)
{
do_throw_todo
(
text
stack
)
;
}
else
{
_dump
(
"
TEST
-
PASS
|
"
+
stack
.
filename
+
"
|
[
"
+
stack
.
name
+
"
:
"
+
stack
.
lineNumber
+
"
]
"
+
text
+
"
\
n
"
)
;
}
}
else
if
(
todo
)
{
_dump
(
"
TEST
-
KNOWN
-
FAIL
|
"
+
stack
.
filename
+
"
|
[
"
+
stack
.
name
+
"
:
"
+
stack
.
lineNumber
+
"
]
"
+
text
+
"
\
n
"
)
;
}
else
{
do_throw
(
text
stack
)
;
}
}
function
ok
(
condition
msg
)
{
do_report_result
(
condition
msg
Components
.
stack
.
caller
false
)
;
}
function
is
(
left
right
msg
)
{
do_report_result
(
left
=
=
=
right
"
[
"
+
left
+
"
=
=
=
"
+
right
+
"
]
"
+
msg
Components
.
stack
.
caller
false
)
;
}
function
_do_check_eq
(
left
right
stack
todo
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
var
text
=
left
+
"
=
=
"
+
right
;
do_report_result
(
left
=
=
right
text
stack
todo
)
;
}
function
do_check_eq
(
left
right
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
_do_check_eq
(
left
right
stack
false
)
;
}
function
todo_check_eq
(
left
right
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
_do_check_eq
(
left
right
stack
true
)
;
}
function
do_check_true
(
condition
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
do_check_eq
(
condition
true
stack
)
;
}
function
todo_check_true
(
condition
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
todo_check_eq
(
condition
true
stack
)
;
}
function
do_check_false
(
condition
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
do_check_eq
(
condition
false
stack
)
;
}
function
todo_check_false
(
condition
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
todo_check_eq
(
condition
false
stack
)
;
}
function
do_check_null
(
condition
stack
=
Components
.
stack
.
caller
)
{
do_check_eq
(
condition
null
stack
)
;
}
function
todo_check_null
(
condition
stack
=
Components
.
stack
.
caller
)
{
todo_check_eq
(
condition
null
stack
)
;
}
function
do_check_matches
(
pattern
value
stack
=
Components
.
stack
.
caller
todo
=
false
)
{
var
matcher
=
pattern_matcher
(
pattern
)
;
var
text
=
"
VALUE
:
"
+
uneval
(
value
)
+
"
\
nPATTERN
:
"
+
uneval
(
pattern
)
+
"
\
n
"
;
var
diagnosis
=
[
]
if
(
matcher
(
value
diagnosis
)
)
{
do_report_result
(
true
"
value
matches
pattern
:
\
n
"
+
text
stack
todo
)
;
}
else
{
text
=
(
"
value
doesn
'
t
match
pattern
:
\
n
"
+
text
+
"
DIAGNOSIS
:
"
+
format_pattern_match_failure
(
diagnosis
[
0
]
)
+
"
\
n
"
)
;
do_report_result
(
false
text
stack
todo
)
;
}
}
function
todo_check_matches
(
pattern
value
stack
=
Components
.
stack
.
caller
)
{
do_check_matches
(
pattern
value
stack
true
)
;
}
function
pattern_matcher
(
pattern
)
{
function
explain
(
diagnosis
reason
)
{
if
(
diagnosis
)
{
diagnosis
[
0
]
=
reason
;
}
return
false
;
}
if
(
typeof
pattern
=
=
"
function
"
)
{
return
pattern
;
}
else
if
(
typeof
pattern
=
=
"
object
"
&
&
pattern
)
{
var
matchers
=
[
]
;
for
(
let
p
in
pattern
)
{
matchers
.
push
(
[
p
pattern_matcher
(
pattern
[
p
]
)
]
)
;
}
ld
=
Object
.
getOwnPropertyDescriptor
(
pattern
"
length
"
)
;
if
(
ld
&
&
!
ld
.
enumerable
)
{
matchers
.
push
(
[
"
length
"
pattern_matcher
(
pattern
.
length
)
]
)
}
return
function
(
value
diagnosis
)
{
if
(
!
(
value
&
&
typeof
value
=
=
"
object
"
)
)
{
return
explain
(
diagnosis
"
value
not
object
"
)
;
}
for
(
let
[
p
m
]
of
matchers
)
{
var
element_diagnosis
=
[
]
;
if
(
!
(
p
in
value
&
&
m
(
value
[
p
]
element_diagnosis
)
)
)
{
return
explain
(
diagnosis
{
property
:
p
diagnosis
:
element_diagnosis
[
0
]
}
)
;
}
}
return
true
;
}
;
}
else
if
(
pattern
=
=
=
undefined
)
{
return
function
(
value
)
{
return
true
;
}
;
}
return
function
(
value
diagnosis
)
{
if
(
value
!
=
=
pattern
)
{
return
explain
(
diagnosis
"
pattern
"
+
uneval
(
pattern
)
+
"
not
=
=
=
to
value
"
+
uneval
(
value
)
)
;
}
return
true
;
}
;
}
function
format_pattern_match_failure
(
diagnosis
indent
=
"
"
)
{
var
a
;
if
(
!
diagnosis
)
{
a
=
"
Matcher
did
not
explain
reason
for
mismatch
.
"
;
}
else
if
(
typeof
diagnosis
=
=
"
string
"
)
{
a
=
diagnosis
;
}
else
if
(
diagnosis
.
property
)
{
a
=
"
Property
"
+
uneval
(
diagnosis
.
property
)
+
"
of
object
didn
'
t
match
:
\
n
"
;
a
+
=
format_pattern_match_failure
(
diagnosis
.
diagnosis
indent
+
"
"
)
;
}
return
indent
+
a
;
}
function
do_test_pending
(
)
{
+
+
_tests_pending
;
_dump
(
"
TEST
-
INFO
|
(
xpcshell
/
head
.
js
)
|
test
"
+
_tests_pending
+
"
pending
\
n
"
)
;
}
function
do_test_finished
(
)
{
_dump
(
"
TEST
-
INFO
|
(
xpcshell
/
head
.
js
)
|
test
"
+
_tests_pending
+
"
finished
\
n
"
)
;
if
(
-
-
_tests_pending
=
=
0
)
{
_do_execute_cleanup
(
)
;
_do_quit
(
)
;
}
}
function
do_get_file
(
path
allowNonexistent
)
{
try
{
let
lf
=
Components
.
classes
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIProperties
)
.
get
(
"
CurWorkD
"
Components
.
interfaces
.
nsIFile
)
;
let
bits
=
path
.
split
(
"
/
"
)
;
for
(
let
i
=
0
;
i
<
bits
.
length
;
i
+
+
)
{
if
(
bits
[
i
]
)
{
if
(
bits
[
i
]
=
=
"
.
.
"
)
lf
=
lf
.
parent
;
else
lf
.
append
(
bits
[
i
]
)
;
}
}
if
(
!
allowNonexistent
&
&
!
lf
.
exists
(
)
)
{
var
stack
=
Components
.
stack
.
caller
;
_dump
(
"
TEST
-
UNEXPECTED
-
FAIL
|
"
+
stack
.
filename
+
"
|
[
"
+
stack
.
name
+
"
:
"
+
stack
.
lineNumber
+
"
]
"
+
lf
.
path
+
"
does
not
exist
\
n
"
)
;
}
return
lf
;
}
catch
(
ex
)
{
do_throw
(
ex
.
toString
(
)
Components
.
stack
.
caller
)
;
}
return
null
;
}
function
do_get_cwd
(
)
{
return
do_get_file
(
"
"
)
;
}
function
do_load_manifest
(
path
)
{
var
lf
=
do_get_file
(
path
)
;
const
nsIComponentRegistrar
=
Components
.
interfaces
.
nsIComponentRegistrar
;
do_check_true
(
Components
.
manager
instanceof
nsIComponentRegistrar
)
;
Components
.
manager
.
autoRegister
(
lf
)
;
}
function
do_register_cleanup
(
func
)
{
_dump
(
"
TEST
-
INFO
|
"
+
_TEST_FILE
+
"
|
"
+
(
_gRunningTest
?
_gRunningTest
.
name
+
"
"
:
"
"
)
+
"
registering
cleanup
function
.
"
)
;
_cleanupFunctions
.
push
(
func
)
;
}
function
_do_execute_cleanup
(
)
{
let
func
;
while
(
(
func
=
_cleanupFunctions
.
pop
(
)
)
)
{
_dump
(
"
TEST
-
INFO
|
"
+
_TEST_FILE
+
"
|
executing
cleanup
function
.
"
)
;
func
(
)
;
}
}
var
_gTests
=
[
]
;
function
add_test
(
func
)
{
_gTests
.
push
(
[
false
func
]
)
;
return
func
;
}
var
_Task
;
function
add_task
(
func
)
{
if
(
!
_Task
)
{
let
ns
=
{
}
;
_Task
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
ns
)
.
Task
;
}
_gTests
.
push
(
[
true
func
]
)
;
}
var
_gRunningTest
=
null
;
var
_gTestIndex
=
0
;
function
run_next_test
(
)
{
function
_run_next_test
(
)
{
if
(
_gTestIndex
<
_gTests
.
length
)
{
do_test_pending
(
)
;
let
_isTask
;
[
_isTask
_gRunningTest
]
=
_gTests
[
_gTestIndex
+
+
]
;
_dump
(
"
TEST
-
INFO
|
"
+
_TEST_FILE
+
"
|
Starting
"
+
_gRunningTest
.
name
)
;
if
(
_isTask
)
{
_Task
.
spawn
(
_gRunningTest
)
.
then
(
run_next_test
do_report_unexpected_exception
)
;
}
else
{
try
{
_gRunningTest
(
)
;
}
catch
(
e
)
{
do_throw
(
e
)
;
}
}
}
}
do_execute_soon
(
_run_next_test
)
;
if
(
_gRunningTest
!
=
=
null
)
{
do_test_finished
(
)
;
}
}
function
JavaBridge
(
obj
)
{
this
.
_EVENT_TYPE
=
"
Robocop
:
JS
"
;
this
.
_JAVA_EVENT_TYPE
=
"
Robocop
:
Java
"
;
this
.
_target
=
obj
;
this
.
_repliesNeeded
=
0
;
this
.
_EventDispatcher
.
registerListener
(
this
this
.
_EVENT_TYPE
)
;
this
.
_sendMessage
(
"
notify
-
loaded
"
[
]
)
;
}
JavaBridge
.
prototype
=
{
_Services
:
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
.
Services
_EventDispatcher
:
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
{
}
)
.
EventDispatcher
.
instance
_getArgs
:
function
(
args
)
{
let
out
=
{
length
:
Math
.
max
(
0
args
.
length
-
1
)
}
;
for
(
let
i
=
1
;
i
<
args
.
length
;
i
+
+
)
{
out
[
i
-
1
]
=
args
[
i
]
;
}
return
out
;
}
_sendMessage
:
function
(
innerType
args
)
{
this
.
_EventDispatcher
.
dispatch
(
this
.
_JAVA_EVENT_TYPE
{
innerType
:
innerType
method
:
args
[
0
]
args
:
this
.
_getArgs
(
args
)
}
)
;
}
onEvent
:
function
(
event
message
callback
)
{
if
(
typeof
SpecialPowers
=
=
=
"
object
"
)
{
message
=
SpecialPowers
.
wrap
(
message
)
;
}
if
(
message
.
innerType
=
=
=
"
sync
-
reply
"
)
{
this
.
_repliesNeeded
-
-
;
return
;
}
try
{
this
.
_target
[
message
.
method
]
.
apply
(
this
.
_target
message
.
args
)
;
}
catch
(
e
)
{
do_report_unexpected_exception
(
e
"
Failed
to
call
"
+
message
.
method
)
;
}
if
(
message
.
innerType
=
=
=
"
sync
-
call
"
)
{
this
.
_sendMessage
(
"
sync
-
reply
"
[
message
.
method
]
)
;
}
}
syncCall
:
function
(
methodName
)
{
this
.
_sendMessage
(
"
sync
-
call
"
arguments
)
;
let
thread
=
this
.
_Services
.
tm
.
currentThread
;
let
initialReplies
=
this
.
_repliesNeeded
;
this
.
_repliesNeeded
+
+
;
this
.
_Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
this
.
_repliesNeeded
<
=
initialReplies
)
;
}
asyncCall
:
function
(
methodName
)
{
this
.
_sendMessage
(
"
async
-
call
"
arguments
)
;
}
disconnect
:
function
(
)
{
this
.
_EventDispatcher
.
unregisterListener
(
this
this
.
_EVENT_TYPE
)
;
}
}
;
