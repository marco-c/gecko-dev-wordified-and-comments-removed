package
org
.
mozilla
.
gecko
.
tests
;
import
android
.
graphics
.
Bitmap
;
import
org
.
mozilla
.
gecko
.
icons
.
decoders
.
ICODecoder
;
import
org
.
mozilla
.
gecko
.
icons
.
decoders
.
IconDirectoryEntry
;
import
org
.
mozilla
.
gecko
.
icons
.
decoders
.
LoadFaviconResult
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
AssertionHelper
.
fAssertEquals
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
AssertionHelper
.
fAssertNull
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
AssertionHelper
.
fAssertNotNull
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
AssertionHelper
.
fAssertTrue
;
public
class
testICODecoder
extends
UITest
{
private
int
mGolemNumIconDirEntries
;
public
void
testICODecoder
(
)
throws
IOException
{
testMicrosoftFavicon
(
)
;
testNvidiaFavicon
(
)
;
testGolemFavicon
(
)
;
testMissingHeader
(
)
;
testCorruptIconDirectory
(
)
;
}
private
void
testMicrosoftFavicon
(
)
throws
IOException
{
byte
[
]
icoBytes
=
readICO
(
"
microsoft_favicon
.
ico
"
)
;
fAssertEquals
(
"
Expecting
Microsoft
favicon
to
be
17174
bytes
.
"
17174
icoBytes
.
length
)
;
ICODecoder
decoder
=
new
ICODecoder
(
getInstrumentation
(
)
.
getTargetContext
(
)
icoBytes
0
icoBytes
.
length
)
;
LoadFaviconResult
result
=
decoder
.
decode
(
)
;
fAssertNotNull
(
"
Expecting
Microsoft
favicon
to
not
fail
decoding
.
"
result
)
;
int
largestBitmap
=
Integer
.
MAX_VALUE
;
int
[
]
possibleSizes
=
{
16
24
32
48
72
128
}
;
for
(
int
i
=
0
;
i
<
possibleSizes
.
length
;
i
+
+
)
{
if
(
possibleSizes
[
i
]
>
decoder
.
getLargestFaviconSize
(
)
)
{
largestBitmap
=
possibleSizes
[
i
]
;
for
(
int
j
=
i
+
1
;
j
<
possibleSizes
.
length
;
j
+
+
)
{
Bitmap
selectedBitmap
=
result
.
getBestBitmap
(
possibleSizes
[
j
]
)
;
fAssertNotNull
(
"
Expecting
a
best
bitmap
to
be
found
for
"
+
possibleSizes
[
j
]
+
"
x
"
+
possibleSizes
[
j
]
selectedBitmap
)
;
fAssertEquals
(
"
Expecting
best
bitmap
to
have
width
"
+
possibleSizes
[
i
]
possibleSizes
[
i
]
selectedBitmap
.
getWidth
(
)
)
;
fAssertEquals
(
"
Expecting
best
bitmap
to
have
height
"
+
possibleSizes
[
i
]
possibleSizes
[
i
]
selectedBitmap
.
getHeight
(
)
)
;
result
=
decoder
.
decode
(
)
;
}
break
;
}
}
int
[
]
expectedSizes
=
{
33
48
24
24
8
16
}
;
for
(
int
i
=
0
;
i
<
expectedSizes
.
length
-
1
;
i
+
=
2
)
{
if
(
expectedSizes
[
i
+
1
]
>
largestBitmap
)
{
continue
;
}
Bitmap
selectedBitmap
=
result
.
getBestBitmap
(
expectedSizes
[
i
]
)
;
fAssertNotNull
(
"
Expecting
a
best
bitmap
to
have
been
found
for
"
+
expectedSizes
[
i
]
+
"
x
"
+
expectedSizes
[
i
]
selectedBitmap
)
;
fAssertEquals
(
"
Expecting
best
bitmap
to
have
width
"
+
expectedSizes
[
i
+
1
]
expectedSizes
[
i
+
1
]
selectedBitmap
.
getWidth
(
)
)
;
fAssertEquals
(
"
Expecting
best
bitmap
to
have
height
"
+
expectedSizes
[
i
+
1
]
expectedSizes
[
i
+
1
]
selectedBitmap
.
getHeight
(
)
)
;
result
=
decoder
.
decode
(
)
;
}
}
private
void
testNvidiaFavicon
(
)
throws
IOException
{
byte
[
]
icoBytes
=
readICO
(
"
nvidia_favicon
.
ico
"
)
;
fAssertEquals
(
"
Expecting
NVIDIA
favicon
to
be
25214
bytes
.
"
25214
icoBytes
.
length
)
;
ICODecoder
decoder
=
new
ICODecoder
(
getInstrumentation
(
)
.
getTargetContext
(
)
icoBytes
0
icoBytes
.
length
)
;
fAssertNotNull
(
"
Expecting
NVIDIA
favicon
to
not
fail
decoding
.
"
decoder
.
decode
(
)
)
;
IconDirectoryEntry
[
]
expectedEntries
=
{
new
IconDirectoryEntry
(
16
16
0
32
1128
24086
false
)
new
IconDirectoryEntry
(
32
32
0
32
4264
19822
false
)
new
IconDirectoryEntry
(
48
48
0
32
9640
10182
false
)
}
;
IconDirectoryEntry
[
]
directory
=
decoder
.
getIconDirectory
(
)
;
fAssertTrue
(
"
NVIDIA
icon
directory
must
contain
at
least
one
entry
.
"
directory
.
length
>
0
)
;
for
(
int
i
=
0
;
i
<
directory
.
length
;
i
+
+
)
{
if
(
expectedEntries
[
i
]
.
getWidth
(
)
>
directory
[
directory
.
length
-
1
]
.
getWidth
(
)
)
{
fAssertTrue
(
"
At
least
one
test
-
case
should
not
have
been
discarded
.
"
i
>
0
)
;
break
;
}
fAssertEquals
(
directory
[
i
]
+
"
is
expected
to
be
equal
to
"
+
expectedEntries
[
i
]
0
directory
[
i
]
.
compareTo
(
expectedEntries
[
i
]
)
)
;
}
}
private
void
testGolemFavicon
(
)
throws
IOException
{
byte
[
]
icoBytes
=
readICO
(
"
golem_favicon
.
ico
"
)
;
fAssertEquals
(
"
Expecting
Golem
favicon
to
be
40648
bytes
.
"
40648
icoBytes
.
length
)
;
ICODecoder
decoder
=
new
ICODecoder
(
getInstrumentation
(
)
.
getTargetContext
(
)
icoBytes
0
icoBytes
.
length
)
;
fAssertNotNull
(
"
Expecting
Golem
favicon
to
not
fail
decoding
.
"
decoder
.
decode
(
)
)
;
IconDirectoryEntry
[
]
expectedEntries
=
{
new
IconDirectoryEntry
(
16
16
0
32
1128
39250
false
)
new
IconDirectoryEntry
(
24
24
0
32
2488
37032
false
)
new
IconDirectoryEntry
(
32
32
0
32
4392
32640
false
)
new
IconDirectoryEntry
(
48
48
0
32
9832
22808
false
)
new
IconDirectoryEntry
(
256
256
0
32
22722
86
true
)
}
;
IconDirectoryEntry
[
]
directory
=
decoder
.
getIconDirectory
(
)
;
fAssertTrue
(
"
Golem
icon
directory
must
contain
at
least
one
entry
.
"
directory
.
length
>
0
)
;
for
(
int
i
=
0
;
i
<
directory
.
length
;
i
+
+
)
{
if
(
expectedEntries
[
i
]
.
getWidth
(
)
>
directory
[
directory
.
length
-
1
]
.
getWidth
(
)
)
{
fAssertTrue
(
"
At
least
one
test
-
case
should
not
have
been
discarded
.
"
i
>
0
)
;
break
;
}
fAssertEquals
(
directory
[
i
]
+
"
is
expected
to
be
equal
to
"
+
expectedEntries
[
i
]
0
directory
[
i
]
.
compareTo
(
expectedEntries
[
i
]
)
)
;
}
mGolemNumIconDirEntries
=
directory
.
length
;
}
private
void
testMissingHeader
(
)
throws
IOException
{
byte
[
]
icoBytes
=
readICO
(
"
microsoft_favicon
.
ico
"
)
;
fAssertEquals
(
"
Expecting
Microsoft
favicon
to
be
17174
bytes
.
"
17174
icoBytes
.
length
)
;
int
offsetNoHeader
=
ICODecoder
.
ICO_HEADER_LENGTH_BYTES
;
int
lenNoHeader
=
icoBytes
.
length
-
ICODecoder
.
ICO_HEADER_LENGTH_BYTES
;
ICODecoder
decoder
=
new
ICODecoder
(
getInstrumentation
(
)
.
getTargetContext
(
)
icoBytes
offsetNoHeader
lenNoHeader
)
;
fAssertNull
(
"
Expecting
Microsoft
favicon
to
fail
decoding
.
"
decoder
.
decode
(
)
)
;
}
private
void
testCorruptIconDirectory
(
)
throws
IOException
{
byte
[
]
icoBytes
=
readICO
(
"
golem_favicon
.
ico
"
)
;
fAssertEquals
(
"
Expecting
Golem
favicon
to
be
40648
bytes
.
"
40648
icoBytes
.
length
)
;
byte
[
]
icoMaimed
=
new
byte
[
icoBytes
.
length
-
ICODecoder
.
ICO_ICONDIRENTRY_LENGTH_BYTES
]
;
System
.
arraycopy
(
icoBytes
0
icoMaimed
0
ICODecoder
.
ICO_HEADER_LENGTH_BYTES
+
4
*
ICODecoder
.
ICO_ICONDIRENTRY_LENGTH_BYTES
)
;
System
.
arraycopy
(
icoBytes
ICODecoder
.
ICO_HEADER_LENGTH_BYTES
+
5
*
ICODecoder
.
ICO_ICONDIRENTRY_LENGTH_BYTES
icoMaimed
ICODecoder
.
ICO_HEADER_LENGTH_BYTES
+
4
*
ICODecoder
.
ICO_ICONDIRENTRY_LENGTH_BYTES
icoBytes
.
length
-
ICODecoder
.
ICO_HEADER_LENGTH_BYTES
-
5
*
ICODecoder
.
ICO_ICONDIRENTRY_LENGTH_BYTES
)
;
ICODecoder
decoder
=
new
ICODecoder
(
getInstrumentation
(
)
.
getTargetContext
(
)
icoMaimed
0
icoMaimed
.
length
)
;
fAssertNotNull
(
"
Expecting
Golem
favicon
to
not
fail
decoding
.
"
decoder
.
decode
(
)
)
;
fAssertEquals
(
"
Expecting
Golem
favicon
icon
directory
to
contain
one
less
bitmap
.
"
mGolemNumIconDirEntries
-
1
decoder
.
getIconDirectory
(
)
.
length
)
;
}
private
byte
[
]
readICO
(
String
fileName
)
throws
IOException
{
String
filePath
=
"
ico_decoder_favicons
"
+
File
.
separator
+
fileName
;
InputStream
icoStream
=
getInstrumentation
(
)
.
getContext
(
)
.
getAssets
(
)
.
open
(
filePath
)
;
ByteArrayOutputStream
byteStream
=
new
ByteArrayOutputStream
(
icoStream
.
available
(
)
)
;
int
readByte
;
while
(
(
readByte
=
icoStream
.
read
(
)
)
!
=
-
1
)
{
byteStream
.
write
(
readByte
)
;
}
return
byteStream
.
toByteArray
(
)
;
}
}
