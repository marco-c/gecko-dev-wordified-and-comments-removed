package
org
.
mozilla
.
gecko
.
tests
;
import
org
.
mozilla
.
gecko
.
Actions
;
import
org
.
mozilla
.
gecko
.
Element
;
import
org
.
mozilla
.
gecko
.
R
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
import
org
.
mozilla
.
gecko
.
util
.
StringUtils
;
public
class
testBookmarksPanel
extends
AboutHomeTest
{
public
void
testBookmarksPanel
(
)
{
final
String
BOOKMARK_URL
=
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_BLANK_PAGE_01_URL
)
;
GeckoBundle
data
=
null
;
initializeProfile
(
)
;
mDatabaseHelper
.
addMobileBookmark
(
mStringHelper
.
ROBOCOP_BLANK_PAGE_01_TITLE
BOOKMARK_URL
)
;
openAboutHomeTab
(
AboutHomeTabs
.
BOOKMARKS
)
;
for
(
String
url
:
mStringHelper
.
DEFAULT_BOOKMARKS_URLS
)
{
isBookmarkDisplayed
(
url
)
;
}
assertAllContextMenuOptionsArePresent
(
mStringHelper
.
DEFAULT_BOOKMARKS_URLS
[
1
]
mStringHelper
.
DEFAULT_BOOKMARKS_URLS
[
0
]
)
;
openBookmarkContextMenu
(
mStringHelper
.
DEFAULT_BOOKMARKS_URLS
[
0
]
)
;
final
Element
tabCount
=
mDriver
.
findElement
(
getActivity
(
)
R
.
id
.
tabs_counter
)
;
final
int
tabCountInt
=
Integer
.
parseInt
(
tabCount
.
getText
(
)
)
;
Actions
.
EventExpecter
tabEventExpecter
=
mActions
.
expectGlobalEvent
(
Actions
.
EventType
.
UI
"
Tab
:
Added
"
)
;
mSolo
.
clickOnText
(
mStringHelper
.
BOOKMARK_CONTEXT_MENU_ITEMS
[
0
]
)
;
data
=
tabEventExpecter
.
blockForBundle
(
)
;
tabEventExpecter
.
unregisterListener
(
)
;
mAsserter
.
ok
(
mSolo
.
searchText
(
mStringHelper
.
TITLE_PLACE_HOLDER
)
"
Checking
that
the
tab
is
not
changed
"
"
The
tab
was
not
changed
"
)
;
mAsserter
.
is
(
mStringHelper
.
ABOUT_FIREFOX_URL
data
.
getString
(
"
uri
"
)
"
Checking
tab
uri
"
)
;
closeTab
(
data
.
getInt
(
"
tabID
"
)
)
;
openBookmarkContextMenu
(
mStringHelper
.
DEFAULT_BOOKMARKS_URLS
[
0
]
)
;
tabEventExpecter
=
mActions
.
expectGlobalEvent
(
Actions
.
EventType
.
UI
"
Tab
:
Added
"
)
;
mSolo
.
clickOnText
(
mStringHelper
.
BOOKMARK_CONTEXT_MENU_ITEMS
[
1
]
)
;
data
=
tabEventExpecter
.
blockForBundle
(
)
;
tabEventExpecter
.
unregisterListener
(
)
;
mAsserter
.
ok
(
mSolo
.
searchText
(
mStringHelper
.
TITLE_PLACE_HOLDER
)
"
Checking
that
the
tab
is
not
changed
"
"
The
tab
was
not
changed
"
)
;
mAsserter
.
is
(
mStringHelper
.
ABOUT_FIREFOX_URL
data
.
getString
(
"
uri
"
)
"
Checking
tab
uri
"
)
;
String
[
]
editedBookmarkValues
=
new
String
[
]
{
"
New
bookmark
title
"
"
www
.
NewBookmark
.
url
"
"
newBookmarkKeyword
"
}
;
editBookmark
(
BOOKMARK_URL
editedBookmarkValues
)
;
checkBookmarkEdit
(
editedBookmarkValues
[
1
]
editedBookmarkValues
)
;
openBookmarkContextMenu
(
editedBookmarkValues
[
1
]
)
;
mSolo
.
clickOnText
(
mStringHelper
.
BOOKMARK_CONTEXT_MENU_ITEMS
[
5
]
)
;
waitForText
(
mStringHelper
.
BOOKMARK_REMOVED_LABEL
)
;
mAsserter
.
ok
(
!
mDatabaseHelper
.
isBookmark
(
editedBookmarkValues
[
1
]
)
"
Checking
that
the
bookmark
was
removed
"
"
The
bookmark
was
removed
"
)
;
}
private
void
assertAllContextMenuOptionsArePresent
(
final
String
shareableURL
final
String
nonShareableURL
)
{
mAsserter
.
ok
(
StringUtils
.
isShareableUrl
(
shareableURL
)
"
Ensuring
url
is
shareable
"
"
"
)
;
mAsserter
.
ok
(
!
StringUtils
.
isShareableUrl
(
nonShareableURL
)
"
Ensuring
url
is
not
shareable
"
"
"
)
;
openBookmarkContextMenu
(
shareableURL
)
;
for
(
String
contextMenuOption
:
mStringHelper
.
BOOKMARK_CONTEXT_MENU_ITEMS
)
{
mAsserter
.
ok
(
mSolo
.
searchText
(
contextMenuOption
)
"
Checking
that
the
context
menu
option
is
present
"
contextMenuOption
+
"
is
present
"
)
;
}
mSolo
.
goBack
(
)
;
openBookmarkContextMenu
(
nonShareableURL
)
;
for
(
String
contextMenuOption
:
mStringHelper
.
BOOKMARK_CONTEXT_MENU_ITEMS
)
{
if
(
"
Share
"
.
equals
(
contextMenuOption
)
)
{
continue
;
}
mAsserter
.
ok
(
mSolo
.
searchText
(
contextMenuOption
)
"
Checking
that
the
context
menu
option
is
present
"
contextMenuOption
+
"
is
present
"
)
;
}
mAsserter
.
ok
(
!
mSolo
.
searchText
(
"
Share
"
)
"
Checking
that
the
Share
option
is
not
present
"
"
Share
option
is
not
present
"
)
;
mSolo
.
goBack
(
)
;
}
private
void
editBookmark
(
String
bookmarkUrl
String
[
]
values
)
{
openBookmarkContextMenu
(
bookmarkUrl
)
;
mSolo
.
clickOnText
(
mStringHelper
.
CONTEXT_MENU_EDIT
)
;
waitForText
(
mStringHelper
.
EDIT_BOOKMARK
)
;
for
(
int
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
mSolo
.
clearEditText
(
i
)
;
mSolo
.
clickOnEditText
(
i
)
;
mActions
.
sendKeys
(
values
[
i
]
)
;
}
mSolo
.
clickOnButton
(
mStringHelper
.
OK
)
;
waitForText
(
mStringHelper
.
BOOKMARK_UPDATED_LABEL
)
;
}
private
void
checkBookmarkEdit
(
String
bookmarkUrl
String
[
]
values
)
{
openBookmarkContextMenu
(
bookmarkUrl
)
;
mSolo
.
clickOnText
(
mStringHelper
.
CONTEXT_MENU_EDIT
)
;
waitForText
(
mStringHelper
.
EDIT_BOOKMARK
)
;
for
(
String
value
:
values
)
{
mAsserter
.
ok
(
mSolo
.
searchText
(
value
)
"
Checking
that
the
value
is
correct
"
"
The
value
=
"
+
value
+
"
is
correct
"
)
;
}
mSolo
.
clickOnButton
(
"
Cancel
"
)
;
waitForText
(
mStringHelper
.
BOOKMARKS_LABEL
)
;
}
}
