package
org
.
mozilla
.
gecko
.
tests
;
import
android
.
widget
.
CheckBox
;
import
android
.
view
.
View
;
import
com
.
jayway
.
android
.
robotium
.
solo
.
Condition
;
import
org
.
json
.
JSONArray
;
import
org
.
json
.
JSONException
;
import
org
.
json
.
JSONObject
;
import
org
.
mozilla
.
gecko
.
Actions
;
public
class
testDoorHanger
extends
BaseTest
{
private
boolean
offlineAllowedByDefault
=
true
;
public
void
testDoorHanger
(
)
{
String
GEO_URL
=
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_GEOLOCATION_URL
)
;
String
BLANK_URL
=
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_BLANK_PAGE_01_URL
)
;
String
OFFLINE_STORAGE_URL
=
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_OFFLINE_STORAGE_URL
)
;
blockForGeckoReady
(
)
;
loadUrlAndWait
(
GEO_URL
)
;
waitForText
(
mStringHelper
.
GEO_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
GEO_MESSAGE
)
true
"
Geolocation
doorhanger
has
been
displayed
"
)
;
waitForCheckBox
(
)
;
mSolo
.
clickOnCheckBox
(
0
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
GEO_ALLOW
)
;
waitForTextDismissed
(
mStringHelper
.
GEO_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
GEO_MESSAGE
)
false
"
Geolocation
doorhanger
has
been
hidden
when
allowing
share
"
)
;
loadUrlAndWait
(
GEO_URL
)
;
waitForText
(
mStringHelper
.
GEO_MESSAGE
)
;
waitForCheckBox
(
)
;
mSolo
.
clickOnCheckBox
(
0
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
GEO_DENY
)
;
waitForTextDismissed
(
mStringHelper
.
GEO_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
GEO_MESSAGE
)
false
"
Geolocation
doorhanger
has
been
hidden
when
denying
share
"
)
;
mActions
.
getPrefs
(
new
String
[
]
{
"
offline
-
apps
.
allow_by_default
"
}
new
Actions
.
PrefHandlerBase
(
)
{
Override
public
void
prefValue
(
String
pref
boolean
value
)
{
mAsserter
.
is
(
pref
"
offline
-
apps
.
allow_by_default
"
"
Expecting
correct
pref
name
"
)
;
offlineAllowedByDefault
=
value
;
}
}
)
.
waitForFinish
(
)
;
setPreferenceAndWaitForChange
(
"
offline
-
apps
.
allow_by_default
"
false
)
;
loadUrlAndWait
(
OFFLINE_STORAGE_URL
)
;
waitForText
(
mStringHelper
.
OFFLINE_MESSAGE
)
;
waitForCheckBox
(
)
;
mSolo
.
clickOnCheckBox
(
0
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
OFFLINE_DENY
)
;
waitForTextDismissed
(
mStringHelper
.
OFFLINE_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
OFFLINE_MESSAGE
)
false
"
Offline
storage
doorhanger
notification
is
hidden
when
denying
storage
"
)
;
loadUrlAndWait
(
OFFLINE_STORAGE_URL
)
;
waitForText
(
mStringHelper
.
OFFLINE_MESSAGE
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
OFFLINE_ALLOW
)
;
waitForTextDismissed
(
mStringHelper
.
OFFLINE_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
OFFLINE_MESSAGE
)
false
"
Offline
storage
doorhanger
notification
is
hidden
when
allowing
storage
"
)
;
loadUrlAndWait
(
OFFLINE_STORAGE_URL
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
OFFLINE_MESSAGE
)
false
"
Offline
storage
doorhanger
is
no
longer
triggered
"
)
;
setPreferenceAndWaitForChange
(
"
offline
-
apps
.
allow_by_default
"
offlineAllowedByDefault
)
;
loadUrlAndWait
(
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_LOGIN_01_URL
)
)
;
waitForText
(
mStringHelper
.
LOGIN_MESSAGE
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
LOGIN_ALLOW
)
;
waitForTextDismissed
(
mStringHelper
.
LOGIN_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
LOGIN_MESSAGE
)
false
"
Login
doorhanger
notification
is
hidden
when
allowing
saving
password
"
)
;
loadUrlAndWait
(
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_LOGIN_02_URL
)
)
;
waitForText
(
mStringHelper
.
LOGIN_MESSAGE
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
LOGIN_DENY
)
;
waitForTextDismissed
(
mStringHelper
.
LOGIN_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
LOGIN_MESSAGE
)
false
"
Login
doorhanger
notification
is
hidden
when
denying
saving
password
"
)
;
testPopupBlocking
(
)
;
}
private
void
testPopupBlocking
(
)
{
String
POPUP_URL
=
getAbsoluteUrl
(
mStringHelper
.
ROBOCOP_POPUP_URL
)
;
setPreferenceAndWaitForChange
(
"
dom
.
disable_open_during_load
"
true
)
;
loadUrlAndWait
(
POPUP_URL
)
;
waitForText
(
mStringHelper
.
POPUP_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
POPUP_MESSAGE
)
true
"
Popup
blocker
is
displayed
"
)
;
Actions
.
EventExpecter
tabEventExpecter
=
mActions
.
expectGeckoEvent
(
"
Tab
:
Added
"
)
;
waitForCheckBox
(
)
;
mSolo
.
clickOnCheckBox
(
0
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
POPUP_ALLOW
)
;
waitForTextDismissed
(
mStringHelper
.
POPUP_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
POPUP_MESSAGE
)
false
"
Popup
blocker
is
hidden
when
popup
allowed
"
)
;
try
{
final
JSONObject
data
=
new
JSONObject
(
tabEventExpecter
.
blockForEventData
(
)
)
;
mAsserter
.
is
(
"
data
:
text
/
plain
;
charset
=
utf
-
8
a
"
data
.
getString
(
"
uri
"
)
"
Checking
popup
URL
"
)
;
closeTab
(
data
.
getInt
(
"
tabID
"
)
)
;
}
catch
(
JSONException
e
)
{
mAsserter
.
ok
(
false
"
exception
getting
event
data
"
e
.
toString
(
)
)
;
}
tabEventExpecter
.
unregisterListener
(
)
;
loadUrlAndWait
(
POPUP_URL
)
;
waitForText
(
mStringHelper
.
POPUP_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
POPUP_MESSAGE
)
true
"
Popup
blocker
is
displayed
"
)
;
waitForCheckBox
(
)
;
mSolo
.
clickOnCheckBox
(
0
)
;
mSolo
.
clickOnButton
(
mStringHelper
.
POPUP_DENY
)
;
waitForTextDismissed
(
mStringHelper
.
POPUP_MESSAGE
)
;
mAsserter
.
is
(
mSolo
.
searchText
(
mStringHelper
.
POPUP_MESSAGE
)
false
"
Popup
blocker
is
hidden
when
popup
denied
"
)
;
verifyUrl
(
POPUP_URL
)
;
setPreferenceAndWaitForChange
(
"
dom
.
disable_open_during_load
"
false
)
;
}
private
void
waitForCheckBox
(
)
{
waitForCondition
(
new
Condition
(
)
{
Override
public
boolean
isSatisfied
(
)
{
for
(
CheckBox
view
:
mSolo
.
getCurrentViews
(
CheckBox
.
class
)
)
{
if
(
view
.
isClickable
(
)
&
&
view
.
getVisibility
(
)
=
=
View
.
VISIBLE
&
&
view
.
getWidth
(
)
>
0
&
&
view
.
getHeight
(
)
>
0
)
{
return
true
;
}
}
return
false
;
}
}
MAX_WAIT_MS
)
;
}
private
void
waitForTextDismissed
(
final
String
text
)
{
waitForCondition
(
new
Condition
(
)
{
Override
public
boolean
isSatisfied
(
)
{
return
!
mSolo
.
searchText
(
text
)
;
}
}
MAX_WAIT_MS
)
;
}
}
