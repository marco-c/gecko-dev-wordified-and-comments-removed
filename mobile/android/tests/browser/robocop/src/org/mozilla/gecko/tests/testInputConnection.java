package
org
.
mozilla
.
gecko
.
tests
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
AssertionHelper
.
fAssertEquals
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
TextInputHelper
.
assertSelection
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
TextInputHelper
.
assertSelectionAt
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
TextInputHelper
.
assertText
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
TextInputHelper
.
assertTextAndSelection
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
TextInputHelper
.
assertTextAndSelectionAt
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
TextInputHelper
.
getText
;
import
static
org
.
mozilla
.
gecko
.
tests
.
helpers
.
WaitHelper
.
waitFor
;
import
org
.
mozilla
.
gecko
.
tests
.
components
.
GeckoViewComponent
.
InputConnectionTest
;
import
org
.
mozilla
.
gecko
.
tests
.
helpers
.
GeckoHelper
;
import
org
.
mozilla
.
gecko
.
tests
.
helpers
.
JavascriptBridge
;
import
org
.
mozilla
.
gecko
.
tests
.
helpers
.
NavigationHelper
;
import
com
.
jayway
.
android
.
robotium
.
solo
.
Condition
;
import
android
.
view
.
KeyEvent
;
import
android
.
view
.
inputmethod
.
EditorInfo
;
import
android
.
view
.
inputmethod
.
InputConnection
;
public
class
testInputConnection
extends
UITest
{
private
static
final
String
INITIAL_TEXT
=
"
foo
"
;
private
JavascriptBridge
js
;
Override
public
void
setUp
(
)
throws
Exception
{
super
.
setUp
(
)
;
js
=
new
JavascriptBridge
(
this
)
;
}
Override
public
void
tearDown
(
)
throws
Exception
{
js
.
disconnect
(
)
;
super
.
tearDown
(
)
;
}
public
void
testInputConnection
(
)
throws
InterruptedException
{
GeckoHelper
.
blockForReady
(
)
;
final
String
url
=
mStringHelper
.
ROBOCOP_INPUT_URL
;
NavigationHelper
.
enterAndLoadUrl
(
url
)
;
mToolbar
.
assertTitle
(
url
)
;
js
.
syncCall
(
"
focus_input
"
INITIAL_TEXT
)
;
mGeckoView
.
mTextInput
.
waitForInputConnection
(
)
.
testInputConnection
(
new
BasicInputConnectionTest
(
)
)
;
js
.
syncCall
(
"
focus_resetting_input
"
"
"
)
;
mGeckoView
.
mTextInput
.
waitForInputConnection
(
)
.
testInputConnection
(
new
ResettingInputConnectionTest
(
)
)
;
js
.
syncCall
(
"
finish_test
"
)
;
}
private
class
BasicInputConnectionTest
extends
InputConnectionTest
{
Override
public
void
test
(
InputConnection
ic
EditorInfo
info
)
{
assertText
(
"
Initial
text
matches
URL
hash
"
ic
INITIAL_TEXT
)
;
ic
.
setSelection
(
0
3
)
;
assertSelection
(
"
Can
set
selection
to
range
"
ic
0
3
)
;
ic
.
setSelection
(
-
3
6
)
;
assertTextAndSelection
(
"
Can
handle
invalid
range
"
ic
INITIAL_TEXT
0
3
)
;
ic
.
setSelection
(
3
3
)
;
assertSelectionAt
(
"
Can
collapse
selection
"
ic
3
)
;
ic
.
setSelection
(
4
4
)
;
assertTextAndSelectionAt
(
"
Can
handle
invalid
cursor
"
ic
INITIAL_TEXT
3
)
;
ic
.
commitText
(
"
"
10
)
;
assertTextAndSelectionAt
(
"
Can
commit
empty
text
"
ic
"
foo
"
3
)
;
ic
.
commitText
(
"
bar
"
1
)
;
assertTextAndSelectionAt
(
"
Can
commit
text
(
select
after
)
"
ic
"
foobar
"
6
)
;
ic
.
commitText
(
"
foo
"
-
1
)
;
assertTextAndSelectionAt
(
"
Can
commit
text
(
select
before
)
"
ic
"
foobarfoo
"
5
)
;
ic
.
deleteSurroundingText
(
1
0
)
;
assertTextAndSelectionAt
(
"
Can
delete
text
before
"
ic
"
foobrfoo
"
4
)
;
ic
.
deleteSurroundingText
(
1
1
)
;
assertTextAndSelectionAt
(
"
Can
delete
text
before
/
after
"
ic
"
foofoo
"
3
)
;
ic
.
deleteSurroundingText
(
0
10
)
;
assertTextAndSelectionAt
(
"
Can
delete
text
after
"
ic
"
foo
"
3
)
;
ic
.
deleteSurroundingText
(
0
0
)
;
assertTextAndSelectionAt
(
"
Can
delete
empty
text
"
ic
"
foo
"
3
)
;
ic
.
setComposingText
(
"
foo
"
1
)
;
assertTextAndSelectionAt
(
"
Can
start
composition
"
ic
"
foofoo
"
6
)
;
ic
.
setComposingText
(
"
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
empty
composition
"
ic
"
foo
"
3
)
;
ic
.
setComposingText
(
"
bar
"
1
)
;
assertTextAndSelectionAt
(
"
Can
update
composition
"
ic
"
foobar
"
6
)
;
ic
.
finishComposingText
(
)
;
assertTextAndSelectionAt
(
"
Can
finish
composition
"
ic
"
foobar
"
6
)
;
ic
.
setComposingRegion
(
0
3
)
;
assertTextAndSelectionAt
(
"
Can
set
composing
region
"
ic
"
foobar
"
6
)
;
ic
.
setComposingText
(
"
far
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
composing
region
text
"
ic
"
farbar
"
3
)
;
ic
.
setComposingRegion
(
1
4
)
;
assertTextAndSelectionAt
(
"
Can
set
existing
composing
region
"
ic
"
farbar
"
3
)
;
ic
.
setComposingText
(
"
rab
"
3
)
;
assertTextAndSelectionAt
(
"
Can
set
new
composing
region
text
"
ic
"
frabar
"
6
)
;
fAssertEquals
(
"
Can
retrieve
text
before
cursor
"
"
bar
"
ic
.
getTextBeforeCursor
(
3
0
)
)
;
fAssertEquals
(
"
Can
retrieve
text
after
cursor
"
"
"
ic
.
getTextAfterCursor
(
3
0
)
)
;
ic
.
finishComposingText
(
)
;
assertTextAndSelectionAt
(
"
Can
finish
composition
"
ic
"
frabar
"
6
)
;
final
KeyEvent
shiftKey
=
new
KeyEvent
(
KeyEvent
.
ACTION_DOWN
KeyEvent
.
KEYCODE_SHIFT_LEFT
)
;
final
KeyEvent
leftKey
=
new
KeyEvent
(
KeyEvent
.
ACTION_DOWN
KeyEvent
.
KEYCODE_DPAD_LEFT
)
;
final
KeyEvent
tKey
=
new
KeyEvent
(
KeyEvent
.
ACTION_DOWN
KeyEvent
.
KEYCODE_T
)
;
ic
.
sendKeyEvent
(
shiftKey
)
;
ic
.
sendKeyEvent
(
leftKey
)
;
ic
.
sendKeyEvent
(
KeyEvent
.
changeAction
(
leftKey
KeyEvent
.
ACTION_UP
)
)
;
ic
.
sendKeyEvent
(
KeyEvent
.
changeAction
(
shiftKey
KeyEvent
.
ACTION_UP
)
)
;
assertTextAndSelection
(
"
Can
select
using
key
event
"
ic
"
frabar
"
6
5
)
;
ic
.
sendKeyEvent
(
tKey
)
;
ic
.
sendKeyEvent
(
KeyEvent
.
changeAction
(
tKey
KeyEvent
.
ACTION_UP
)
)
;
assertTextAndSelectionAt
(
"
Can
type
using
event
"
ic
"
frabat
"
6
)
;
ic
.
deleteSurroundingText
(
6
0
)
;
assertTextAndSelectionAt
(
"
Can
clear
text
"
ic
"
"
0
)
;
ic
.
setComposingText
(
"
foo
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
the
composing
text
"
ic
"
foo
"
3
)
;
ic
.
setComposingText
(
"
foo
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
the
same
composing
text
"
ic
"
foo
"
3
)
;
ic
.
setComposingText
(
"
bar
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
different
composing
text
"
ic
"
bar
"
3
)
;
ic
.
setComposingText
(
"
bar
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
the
same
composing
text
"
ic
"
bar
"
3
)
;
ic
.
setComposingText
(
"
bar
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
the
same
composing
text
again
"
ic
"
bar
"
3
)
;
ic
.
finishComposingText
(
)
;
assertTextAndSelectionAt
(
"
Can
finish
composing
text
"
ic
"
bar
"
3
)
;
ic
.
deleteSurroundingText
(
3
0
)
;
assertTextAndSelectionAt
(
"
Can
clear
text
"
ic
"
"
0
)
;
ic
.
commitText
(
"
\
u3000
"
1
)
;
assertTextAndSelectionAt
(
"
Can
commit
ideographic
space
"
ic
"
\
u3000
"
1
)
;
ic
.
deleteSurroundingText
(
1
0
)
;
assertTextAndSelectionAt
(
"
Can
clear
text
"
ic
"
"
0
)
;
ic
.
setComposingText
(
"
bad
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
the
composing
text
"
ic
"
bad
"
3
)
;
js
.
asyncCall
(
"
test_reflush_changes
"
)
;
processGeckoEvents
(
ic
)
;
assertTextAndSelectionAt
(
"
Can
re
-
flush
text
changes
"
ic
"
good
"
4
)
;
ic
.
setComposingText
(
"
done
"
1
)
;
assertTextAndSelectionAt
(
"
Can
update
composition
after
re
-
flushing
"
ic
"
done
"
4
)
;
ic
.
finishComposingText
(
)
;
assertTextAndSelectionAt
(
"
Can
finish
composing
text
"
ic
"
done
"
4
)
;
ic
.
deleteSurroundingText
(
4
0
)
;
assertTextAndSelectionAt
(
"
Can
clear
text
"
ic
"
"
0
)
;
ic
.
setComposingText
(
"
foobar
"
1
)
;
assertTextAndSelectionAt
(
"
Can
set
the
composing
text
"
ic
"
foobar
"
6
)
;
js
.
asyncCall
(
"
test_set_selection
"
)
;
processGeckoEvents
(
ic
)
;
assertTextAndSelectionAt
(
"
Can
select
after
committing
"
ic
"
foobar
"
3
)
;
ic
.
setComposingText
(
"
barfoo
"
1
)
;
assertTextAndSelectionAt
(
"
Can
compose
after
selecting
"
ic
"
barfoo
"
6
)
;
ic
.
beginBatchEdit
(
)
;
ic
.
setSelection
(
3
3
)
;
ic
.
finishComposingText
(
)
;
ic
.
deleteSurroundingText
(
1
1
)
;
ic
.
endBatchEdit
(
)
;
assertTextAndSelectionAt
(
"
Can
delete
after
committing
"
ic
"
baoo
"
2
)
;
ic
.
deleteSurroundingText
(
2
2
)
;
assertTextAndSelectionAt
(
"
Can
clear
text
"
ic
"
"
0
)
;
processGeckoEvents
(
ic
)
;
processInputConnectionEvents
(
)
;
}
}
private
class
ResettingInputConnectionTest
extends
InputConnectionTest
{
Override
public
void
test
(
final
InputConnection
ic
EditorInfo
info
)
{
waitFor
(
"
focus
change
"
new
Condition
(
)
{
Override
public
boolean
isSatisfied
(
)
{
return
"
"
.
equals
(
getText
(
ic
)
)
;
}
}
)
;
ic
.
commitText
(
"
foo
"
1
)
;
assertTextAndSelectionAt
(
"
Can
commit
text
(
resetting
)
"
ic
"
foo
"
3
)
;
ic
.
setComposingRegion
(
0
3
)
;
processGeckoEvents
(
ic
)
;
processInputConnectionEvents
(
)
;
processGeckoEvents
(
ic
)
;
assertTextAndSelectionAt
(
"
Can
set
composing
region
(
resetting
)
"
ic
"
foo
"
3
)
;
ic
.
setComposingText
(
"
foobar
"
1
)
;
processGeckoEvents
(
ic
)
;
processInputConnectionEvents
(
)
;
processGeckoEvents
(
ic
)
;
assertTextAndSelectionAt
(
"
Can
change
composing
text
(
resetting
)
"
ic
"
foobar
"
6
)
;
ic
.
setComposingText
(
"
baz
"
1
)
;
processGeckoEvents
(
ic
)
;
processInputConnectionEvents
(
)
;
processGeckoEvents
(
ic
)
;
assertTextAndSelectionAt
(
"
Can
reset
composing
text
(
resetting
)
"
ic
"
baz
"
3
)
;
ic
.
finishComposingText
(
)
;
assertTextAndSelectionAt
(
"
Can
finish
composing
text
(
resetting
)
"
ic
"
baz
"
3
)
;
ic
.
deleteSurroundingText
(
3
0
)
;
assertTextAndSelectionAt
(
"
Can
clear
text
"
ic
"
"
0
)
;
}
}
}
