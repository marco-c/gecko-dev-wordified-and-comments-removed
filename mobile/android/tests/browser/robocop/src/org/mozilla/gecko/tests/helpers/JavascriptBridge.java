package
org
.
mozilla
.
gecko
.
tests
.
helpers
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
junit
.
framework
.
AssertionFailedError
;
import
org
.
mozilla
.
gecko
.
Actions
;
import
org
.
mozilla
.
gecko
.
Actions
.
EventExpecter
;
import
org
.
mozilla
.
gecko
.
Assert
;
import
org
.
mozilla
.
gecko
.
tests
.
UITestContext
;
import
org
.
mozilla
.
gecko
.
util
.
GeckoBundle
;
public
final
class
JavascriptBridge
{
private
static
enum
MessageStatus
{
QUEUE_EMPTY
PROCESSED
REPLIED
SAVED
}
;
SuppressWarnings
(
"
serial
"
)
public
static
class
CallException
extends
RuntimeException
{
public
CallException
(
)
{
super
(
)
;
}
public
CallException
(
final
String
msg
)
{
super
(
msg
)
;
}
public
CallException
(
final
String
msg
final
Throwable
e
)
{
super
(
msg
e
)
;
}
public
CallException
(
final
Throwable
e
)
{
super
(
e
)
;
}
}
public
static
final
String
EVENT_TYPE
=
"
Robocop
:
Java
"
;
public
static
final
String
JS_EVENT_TYPE
=
"
Robocop
:
JS
"
;
private
static
Actions
sActions
;
private
static
Assert
sAsserter
;
private
final
Object
mTarget
;
private
final
Method
[
]
mMethods
;
private
final
JavascriptMessageParser
mLogParser
;
private
final
EventExpecter
mExpecter
;
private
GeckoBundle
mSavedAsyncMessage
;
private
int
mCallStackDepth
;
private
boolean
mJavaBridgeLoaded
;
static
void
init
(
final
UITestContext
context
)
{
sActions
=
context
.
getActions
(
)
;
sAsserter
=
context
.
getAsserter
(
)
;
}
public
JavascriptBridge
(
final
Object
target
)
{
mTarget
=
target
;
mMethods
=
target
.
getClass
(
)
.
getMethods
(
)
;
mExpecter
=
sActions
.
expectGlobalEvent
(
Actions
.
EventType
.
GECKO
EVENT_TYPE
)
;
mLogParser
=
new
JavascriptMessageParser
(
sAsserter
true
)
;
}
public
void
syncCall
(
final
String
method
final
Object
.
.
.
args
)
{
mCallStackDepth
+
+
;
sendMessage
(
"
sync
-
call
"
method
args
)
;
try
{
while
(
processPendingMessage
(
)
!
=
MessageStatus
.
REPLIED
)
{
}
}
catch
(
final
AssertionFailedError
e
)
{
throw
new
CallException
(
"
Cannot
call
"
+
method
e
)
;
}
if
(
mCallStackDepth
=
=
1
)
{
finishPendingCalls
(
)
;
}
mCallStackDepth
-
-
;
}
public
void
asyncCall
(
final
String
method
final
Object
.
.
.
args
)
{
sendMessage
(
"
async
-
call
"
method
args
)
;
}
public
void
disconnect
(
)
{
mExpecter
.
unregisterListener
(
)
;
}
private
MessageStatus
processPendingMessage
(
)
{
return
processMessage
(
mExpecter
.
blockForBundle
(
)
)
;
}
private
MessageStatus
maybeProcessPendingMessage
(
)
{
final
GeckoBundle
message
=
mExpecter
.
blockForBundleWithTimeout
(
0
)
;
if
(
message
!
=
null
)
{
return
processMessage
(
message
)
;
}
if
(
mSavedAsyncMessage
!
=
null
)
{
return
processMessage
(
mSavedAsyncMessage
)
;
}
return
MessageStatus
.
QUEUE_EMPTY
;
}
private
void
finishPendingCalls
(
)
{
MessageStatus
result
;
do
{
result
=
maybeProcessPendingMessage
(
)
;
if
(
result
=
=
MessageStatus
.
REPLIED
)
{
throw
new
IllegalStateException
(
"
Sync
reply
was
unexpected
"
)
;
}
}
while
(
result
!
=
MessageStatus
.
QUEUE_EMPTY
)
;
}
private
void
ensureJavaBridgeLoaded
(
)
{
while
(
!
mJavaBridgeLoaded
)
{
processPendingMessage
(
)
;
}
}
private
void
sendMessage
(
final
String
innerType
final
String
method
final
Object
[
]
args
)
{
ensureJavaBridgeLoaded
(
)
;
final
GeckoBundle
message
=
new
GeckoBundle
(
)
;
final
GeckoBundle
bundleArgs
=
new
GeckoBundle
(
)
;
if
(
args
=
=
null
)
{
bundleArgs
.
putInt
(
"
length
"
0
)
;
}
else
{
for
(
int
i
=
0
;
i
<
args
.
length
;
i
+
+
)
{
putInBundle
(
bundleArgs
String
.
valueOf
(
i
)
args
[
i
]
)
;
}
bundleArgs
.
putInt
(
"
length
"
args
.
length
)
;
}
message
.
putString
(
"
type
"
JS_EVENT_TYPE
)
;
message
.
putString
(
"
innerType
"
innerType
)
;
message
.
putString
(
"
method
"
method
)
;
message
.
putBundle
(
"
args
"
bundleArgs
)
;
sActions
.
sendGlobalEvent
(
JS_EVENT_TYPE
message
)
;
}
private
MessageStatus
processMessage
(
GeckoBundle
message
)
{
final
String
type
;
final
String
methodName
;
final
GeckoBundle
argsArray
;
final
Object
[
]
args
;
type
=
message
.
getString
(
"
innerType
"
)
;
switch
(
type
)
{
case
"
progress
"
:
mLogParser
.
logMessage
(
message
.
getString
(
"
message
"
)
)
;
return
MessageStatus
.
PROCESSED
;
case
"
notify
-
loaded
"
:
mJavaBridgeLoaded
=
true
;
return
MessageStatus
.
PROCESSED
;
case
"
sync
-
reply
"
:
return
MessageStatus
.
REPLIED
;
case
"
sync
-
call
"
:
case
"
async
-
call
"
:
if
(
"
async
-
call
"
.
equals
(
type
)
)
{
final
GeckoBundle
newSavedMessage
=
(
message
!
=
mSavedAsyncMessage
?
message
:
null
)
;
message
=
mSavedAsyncMessage
;
mSavedAsyncMessage
=
newSavedMessage
;
if
(
message
=
=
null
)
{
return
MessageStatus
.
SAVED
;
}
}
methodName
=
message
.
getString
(
"
method
"
)
;
argsArray
=
message
.
getBundle
(
"
args
"
)
;
args
=
new
Object
[
argsArray
.
getInt
(
"
length
"
)
]
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
+
+
)
{
args
[
i
]
=
argsArray
.
get
(
String
.
valueOf
(
i
)
)
;
}
invokeMethod
(
methodName
args
)
;
if
(
"
sync
-
call
"
.
equals
(
type
)
)
{
sendMessage
(
"
sync
-
reply
"
methodName
null
)
;
}
return
MessageStatus
.
PROCESSED
;
}
throw
new
IllegalStateException
(
"
Message
type
is
unexpected
"
)
;
}
private
Object
invokeMethod
(
final
String
methodName
final
Object
[
]
args
)
{
final
Class
<
?
>
[
]
argTypes
=
new
Class
<
?
>
[
args
.
length
]
;
for
(
int
i
=
0
;
i
<
argTypes
.
length
;
i
+
+
)
{
if
(
args
[
i
]
=
=
null
)
{
argTypes
[
i
]
=
Object
.
class
;
}
else
{
argTypes
[
i
]
=
args
[
i
]
.
getClass
(
)
;
}
}
try
{
return
invokeMethod
(
mTarget
.
getClass
(
)
.
getMethod
(
methodName
argTypes
)
args
)
;
}
catch
(
final
NoSuchMethodException
e
)
{
}
Throwable
lastException
=
null
;
for
(
final
Method
method
:
mMethods
)
{
if
(
!
method
.
getName
(
)
.
equals
(
methodName
)
)
{
continue
;
}
try
{
return
invokeMethod
(
method
args
)
;
}
catch
(
final
IllegalArgumentException
e
)
{
lastException
=
e
;
}
catch
(
final
UnsupportedOperationException
e
)
{
lastException
=
e
;
}
}
throw
new
UnsupportedOperationException
(
"
Cannot
call
method
"
+
methodName
+
"
(
not
public
?
wrong
argument
types
?
)
"
lastException
)
;
}
private
Object
invokeMethod
(
final
Method
method
final
Object
[
]
args
)
{
try
{
return
method
.
invoke
(
mTarget
args
)
;
}
catch
(
final
IllegalAccessException
e
)
{
throw
new
UnsupportedOperationException
(
"
Cannot
access
method
"
+
method
.
getName
(
)
e
)
;
}
catch
(
final
InvocationTargetException
e
)
{
final
Throwable
cause
=
e
.
getCause
(
)
;
if
(
cause
instanceof
CallException
)
{
throw
(
CallException
)
cause
;
}
throw
new
CallException
(
"
Failed
to
invoke
"
+
method
.
getName
(
)
cause
)
;
}
}
private
void
putInBundle
(
final
GeckoBundle
bundle
final
String
key
final
Object
value
)
{
if
(
value
=
=
null
)
{
bundle
.
putBundle
(
key
null
)
;
}
else
if
(
value
instanceof
Boolean
)
{
bundle
.
putBoolean
(
key
(
Boolean
)
value
)
;
}
else
if
(
value
instanceof
boolean
[
]
)
{
bundle
.
putBooleanArray
(
key
(
boolean
[
]
)
value
)
;
}
else
if
(
value
instanceof
Double
)
{
bundle
.
putDouble
(
key
(
Double
)
value
)
;
}
else
if
(
value
instanceof
double
[
]
)
{
bundle
.
putDoubleArray
(
key
(
double
[
]
)
value
)
;
}
else
if
(
value
instanceof
Integer
)
{
bundle
.
putInt
(
key
(
Integer
)
value
)
;
}
else
if
(
value
instanceof
int
[
]
)
{
bundle
.
putIntArray
(
key
(
int
[
]
)
value
)
;
}
else
if
(
value
instanceof
CharSequence
)
{
bundle
.
putString
(
key
value
.
toString
(
)
)
;
}
else
if
(
value
instanceof
String
[
]
)
{
bundle
.
putStringArray
(
key
(
String
[
]
)
value
)
;
}
else
if
(
value
instanceof
GeckoBundle
)
{
bundle
.
putBundle
(
key
(
GeckoBundle
)
value
)
;
}
else
if
(
value
instanceof
GeckoBundle
[
]
)
{
bundle
.
putBundleArray
(
key
(
GeckoBundle
[
]
)
value
)
;
}
else
{
throw
new
UnsupportedOperationException
(
)
;
}
}
}
