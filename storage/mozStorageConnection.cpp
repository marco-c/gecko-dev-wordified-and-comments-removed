#
include
<
stdio
.
h
>
#
include
"
nsError
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaObject
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozIStorageAggregateFunction
.
h
"
#
include
"
mozIStorageCompletionCallback
.
h
"
#
include
"
mozIStorageFunction
.
h
"
#
include
"
mozStorageAsyncStatementExecution
.
h
"
#
include
"
mozStorageSQLFunctions
.
h
"
#
include
"
mozStorageConnection
.
h
"
#
include
"
mozStorageService
.
h
"
#
include
"
mozStorageStatement
.
h
"
#
include
"
mozStorageAsyncStatement
.
h
"
#
include
"
mozStorageArgValueArray
.
h
"
#
include
"
mozStoragePrivateHelpers
.
h
"
#
include
"
mozStorageStatementData
.
h
"
#
include
"
StorageBaseStatementInternal
.
h
"
#
include
"
SQLCollations
.
h
"
#
include
"
FileSystemModule
.
h
"
#
include
"
mozStorageHelper
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
<
algorithm
>
#
define
MIN_AVAILABLE_BYTES_PER_CHUNKED_GROWTH
524288000
/
/
500
MiB
#
define
MAX_CACHE_SIZE_KIBIBYTES
2048
/
/
2
MiB
mozilla
:
:
LazyLogModule
gStorageLog
(
"
mozStorage
"
)
;
#
ifdef
DEBUG
#
define
CHECK_MAINTHREAD_ABUSE
(
)
\
do
{
\
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
\
NS_WARNING_ASSERTION
(
\
threadOpenedOn
=
=
mainThread
|
|
!
NS_IsMainThread
(
)
\
"
Using
Storage
synchronous
API
on
main
-
thread
but
the
connection
was
"
\
"
opened
on
another
thread
.
"
)
;
\
}
while
(
0
)
#
else
#
define
CHECK_MAINTHREAD_ABUSE
(
)
do
{
/
*
Nothing
*
/
}
while
(
0
)
#
endif
namespace
mozilla
{
namespace
storage
{
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaObject
;
namespace
{
int
nsresultToSQLiteResult
(
nsresult
aXPCOMResultCode
)
{
if
(
NS_SUCCEEDED
(
aXPCOMResultCode
)
)
{
return
SQLITE_OK
;
}
switch
(
aXPCOMResultCode
)
{
case
NS_ERROR_FILE_CORRUPTED
:
return
SQLITE_CORRUPT
;
case
NS_ERROR_FILE_ACCESS_DENIED
:
return
SQLITE_CANTOPEN
;
case
NS_ERROR_STORAGE_BUSY
:
return
SQLITE_BUSY
;
case
NS_ERROR_FILE_IS_LOCKED
:
return
SQLITE_LOCKED
;
case
NS_ERROR_FILE_READ_ONLY
:
return
SQLITE_READONLY
;
case
NS_ERROR_STORAGE_IOERR
:
return
SQLITE_IOERR
;
case
NS_ERROR_FILE_NO_DEVICE_SPACE
:
return
SQLITE_FULL
;
case
NS_ERROR_OUT_OF_MEMORY
:
return
SQLITE_NOMEM
;
case
NS_ERROR_UNEXPECTED
:
return
SQLITE_MISUSE
;
case
NS_ERROR_ABORT
:
return
SQLITE_ABORT
;
case
NS_ERROR_STORAGE_CONSTRAINT
:
return
SQLITE_CONSTRAINT
;
default
:
return
SQLITE_ERROR
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Must
return
in
switch
above
!
"
)
;
}
int
sqlite3_T_int
(
sqlite3_context
*
aCtx
int
aValue
)
{
:
:
sqlite3_result_int
(
aCtx
aValue
)
;
return
SQLITE_OK
;
}
int
sqlite3_T_int64
(
sqlite3_context
*
aCtx
sqlite3_int64
aValue
)
{
:
:
sqlite3_result_int64
(
aCtx
aValue
)
;
return
SQLITE_OK
;
}
int
sqlite3_T_double
(
sqlite3_context
*
aCtx
double
aValue
)
{
:
:
sqlite3_result_double
(
aCtx
aValue
)
;
return
SQLITE_OK
;
}
int
sqlite3_T_text
(
sqlite3_context
*
aCtx
const
nsCString
&
aValue
)
{
:
:
sqlite3_result_text
(
aCtx
aValue
.
get
(
)
aValue
.
Length
(
)
SQLITE_TRANSIENT
)
;
return
SQLITE_OK
;
}
int
sqlite3_T_text16
(
sqlite3_context
*
aCtx
const
nsString
&
aValue
)
{
:
:
sqlite3_result_text16
(
aCtx
aValue
.
get
(
)
aValue
.
Length
(
)
*
2
SQLITE_TRANSIENT
)
;
return
SQLITE_OK
;
}
int
sqlite3_T_null
(
sqlite3_context
*
aCtx
)
{
:
:
sqlite3_result_null
(
aCtx
)
;
return
SQLITE_OK
;
}
int
sqlite3_T_blob
(
sqlite3_context
*
aCtx
const
void
*
aData
int
aSize
)
{
:
:
sqlite3_result_blob
(
aCtx
aData
aSize
free
)
;
return
SQLITE_OK
;
}
#
include
"
variantToSQLiteT_impl
.
h
"
struct
Module
{
const
char
*
name
;
int
(
*
registerFunc
)
(
sqlite3
*
const
char
*
)
;
}
;
Module
gModules
[
]
=
{
{
"
filesystem
"
RegisterFileSystemModule
}
}
;
int
tracefunc
(
unsigned
aReason
void
*
aClosure
void
*
aP
void
*
aX
)
{
switch
(
aReason
)
{
case
SQLITE_TRACE_STMT
:
{
sqlite3_stmt
*
stmt
=
static_cast
<
sqlite3_stmt
*
>
(
aP
)
;
char
*
expanded
=
static_cast
<
char
*
>
(
aX
)
;
if
(
!
:
:
strncmp
(
expanded
"
-
-
"
2
)
)
{
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Debug
(
"
TRACE_STMT
on
%
p
:
'
%
s
'
"
aClosure
expanded
)
)
;
}
else
{
char
*
sql
=
:
:
sqlite3_expanded_sql
(
stmt
)
;
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Debug
(
"
TRACE_STMT
on
%
p
:
'
%
s
'
"
aClosure
sql
)
)
;
:
:
sqlite3_free
(
sql
)
;
}
break
;
}
case
SQLITE_TRACE_PROFILE
:
{
sqlite_int64
time
=
*
(
static_cast
<
sqlite_int64
*
>
(
aX
)
)
/
1000000
;
if
(
time
>
0
)
{
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Debug
(
"
TRACE_TIME
on
%
p
:
%
lldms
"
aClosure
time
)
)
;
}
break
;
}
}
return
0
;
}
void
basicFunctionHelper
(
sqlite3_context
*
aCtx
int
aArgc
sqlite3_value
*
*
aArgv
)
{
void
*
userData
=
:
:
sqlite3_user_data
(
aCtx
)
;
mozIStorageFunction
*
func
=
static_cast
<
mozIStorageFunction
*
>
(
userData
)
;
RefPtr
<
ArgValueArray
>
arguments
(
new
ArgValueArray
(
aArgc
aArgv
)
)
;
if
(
!
arguments
)
return
;
nsCOMPtr
<
nsIVariant
>
result
;
nsresult
rv
=
func
-
>
OnFunctionCall
(
arguments
getter_AddRefs
(
result
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoCString
errorMessage
;
GetErrorName
(
rv
errorMessage
)
;
errorMessage
.
InsertLiteral
(
"
User
function
returned
"
0
)
;
errorMessage
.
Append
(
'
!
'
)
;
NS_WARNING
(
errorMessage
.
get
(
)
)
;
:
:
sqlite3_result_error
(
aCtx
errorMessage
.
get
(
)
-
1
)
;
:
:
sqlite3_result_error_code
(
aCtx
nsresultToSQLiteResult
(
rv
)
)
;
return
;
}
int
retcode
=
variantToSQLiteT
(
aCtx
result
)
;
if
(
retcode
=
=
SQLITE_IGNORE
)
{
:
:
sqlite3_result_int
(
aCtx
SQLITE_IGNORE
)
;
}
else
if
(
retcode
!
=
SQLITE_OK
)
{
NS_WARNING
(
"
User
function
returned
invalid
data
type
!
"
)
;
:
:
sqlite3_result_error
(
aCtx
"
User
function
returned
invalid
data
type
"
-
1
)
;
}
}
void
aggregateFunctionStepHelper
(
sqlite3_context
*
aCtx
int
aArgc
sqlite3_value
*
*
aArgv
)
{
void
*
userData
=
:
:
sqlite3_user_data
(
aCtx
)
;
mozIStorageAggregateFunction
*
func
=
static_cast
<
mozIStorageAggregateFunction
*
>
(
userData
)
;
RefPtr
<
ArgValueArray
>
arguments
(
new
ArgValueArray
(
aArgc
aArgv
)
)
;
if
(
!
arguments
)
return
;
if
(
NS_FAILED
(
func
-
>
OnStep
(
arguments
)
)
)
NS_WARNING
(
"
User
aggregate
step
function
returned
error
code
!
"
)
;
}
void
aggregateFunctionFinalHelper
(
sqlite3_context
*
aCtx
)
{
void
*
userData
=
:
:
sqlite3_user_data
(
aCtx
)
;
mozIStorageAggregateFunction
*
func
=
static_cast
<
mozIStorageAggregateFunction
*
>
(
userData
)
;
RefPtr
<
nsIVariant
>
result
;
if
(
NS_FAILED
(
func
-
>
OnFinal
(
getter_AddRefs
(
result
)
)
)
)
{
NS_WARNING
(
"
User
aggregate
final
function
returned
error
code
!
"
)
;
:
:
sqlite3_result_error
(
aCtx
"
User
aggregate
final
function
returned
error
code
"
-
1
)
;
return
;
}
if
(
variantToSQLiteT
(
aCtx
result
)
!
=
SQLITE_OK
)
{
NS_WARNING
(
"
User
aggregate
final
function
returned
invalid
data
type
!
"
)
;
:
:
sqlite3_result_error
(
aCtx
"
User
aggregate
final
function
returned
invalid
data
type
"
-
1
)
;
}
}
class
UnlockNotification
{
public
:
UnlockNotification
(
)
:
mMutex
(
"
UnlockNotification
mMutex
"
)
mCondVar
(
mMutex
"
UnlockNotification
condVar
"
)
mSignaled
(
false
)
{
}
void
Wait
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
while
(
!
mSignaled
)
{
(
void
)
mCondVar
.
Wait
(
)
;
}
}
void
Signal
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mSignaled
=
true
;
(
void
)
mCondVar
.
Notify
(
)
;
}
private
:
Mutex
mMutex
;
CondVar
mCondVar
;
bool
mSignaled
;
}
;
void
UnlockNotifyCallback
(
void
*
*
aArgs
int
aArgsSize
)
{
for
(
int
i
=
0
;
i
<
aArgsSize
;
i
+
+
)
{
UnlockNotification
*
notification
=
static_cast
<
UnlockNotification
*
>
(
aArgs
[
i
]
)
;
notification
-
>
Signal
(
)
;
}
}
int
WaitForUnlockNotify
(
sqlite3
*
aDatabase
)
{
UnlockNotification
notification
;
int
srv
=
:
:
sqlite3_unlock_notify
(
aDatabase
UnlockNotifyCallback
&
notification
)
;
MOZ_ASSERT
(
srv
=
=
SQLITE_LOCKED
|
|
srv
=
=
SQLITE_OK
)
;
if
(
srv
=
=
SQLITE_OK
)
{
notification
.
Wait
(
)
;
}
return
srv
;
}
class
AsyncCloseConnection
final
:
public
Runnable
{
public
:
AsyncCloseConnection
(
Connection
*
aConnection
sqlite3
*
aNativeConnection
nsIRunnable
*
aCallbackEvent
)
:
Runnable
(
"
storage
:
:
AsyncCloseConnection
"
)
mConnection
(
aConnection
)
mNativeConnection
(
aNativeConnection
)
mCallbackEvent
(
aCallbackEvent
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
!
=
mConnection
-
>
threadOpenedOn
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
storage
:
:
Connection
:
:
shutdownAsyncThread
"
mConnection
&
Connection
:
:
shutdownAsyncThread
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
event
)
)
;
(
void
)
mConnection
-
>
internalClose
(
mNativeConnection
)
;
if
(
mCallbackEvent
)
{
nsCOMPtr
<
nsIThread
>
thread
;
(
void
)
NS_GetMainThread
(
getter_AddRefs
(
thread
)
)
;
(
void
)
thread
-
>
Dispatch
(
mCallbackEvent
NS_DISPATCH_NORMAL
)
;
}
return
NS_OK
;
}
~
AsyncCloseConnection
(
)
override
{
NS_ReleaseOnMainThreadSystemGroup
(
"
AsyncCloseConnection
:
:
mConnection
"
mConnection
.
forget
(
)
)
;
NS_ReleaseOnMainThreadSystemGroup
(
"
AsyncCloseConnection
:
:
mCallbackEvent
"
mCallbackEvent
.
forget
(
)
)
;
}
private
:
RefPtr
<
Connection
>
mConnection
;
sqlite3
*
mNativeConnection
;
nsCOMPtr
<
nsIRunnable
>
mCallbackEvent
;
}
;
class
AsyncInitializeClone
final
:
public
Runnable
{
public
:
AsyncInitializeClone
(
Connection
*
aConnection
Connection
*
aClone
const
bool
aReadOnly
mozIStorageCompletionCallback
*
aCallback
)
:
Runnable
(
"
storage
:
:
AsyncInitializeClone
"
)
mConnection
(
aConnection
)
mClone
(
aClone
)
mReadOnly
(
aReadOnly
)
mCallback
(
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
mConnection
-
>
initializeClone
(
mClone
mReadOnly
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Dispatch
(
rv
nullptr
)
;
}
return
Dispatch
(
NS_OK
NS_ISUPPORTS_CAST
(
mozIStorageAsyncConnection
*
mClone
)
)
;
}
private
:
nsresult
Dispatch
(
nsresult
aResult
nsISupports
*
aValue
)
{
RefPtr
<
CallbackComplete
>
event
=
new
CallbackComplete
(
aResult
aValue
mCallback
.
forget
(
)
)
;
return
mClone
-
>
threadOpenedOn
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
~
AsyncInitializeClone
(
)
override
{
nsCOMPtr
<
nsIThread
>
thread
;
DebugOnly
<
nsresult
>
rv
=
NS_GetMainThread
(
getter_AddRefs
(
thread
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
NS_ProxyRelease
(
"
AsyncInitializeClone
:
:
mConnection
"
thread
mConnection
.
forget
(
)
)
;
NS_ProxyRelease
(
"
AsyncInitializeClone
:
:
mClone
"
thread
mClone
.
forget
(
)
)
;
NS_ProxyRelease
(
"
AsyncInitializeClone
:
:
mCallback
"
thread
mCallback
.
forget
(
)
)
;
}
RefPtr
<
Connection
>
mConnection
;
RefPtr
<
Connection
>
mClone
;
const
bool
mReadOnly
;
nsCOMPtr
<
mozIStorageCompletionCallback
>
mCallback
;
}
;
class
CloseListener
final
:
public
mozIStorageCompletionCallback
{
public
:
NS_DECL_ISUPPORTS
CloseListener
(
)
:
mClosed
(
false
)
{
}
NS_IMETHOD
Complete
(
nsresult
nsISupports
*
)
override
{
mClosed
=
true
;
return
NS_OK
;
}
bool
mClosed
;
private
:
~
CloseListener
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
CloseListener
mozIStorageCompletionCallback
)
}
Connection
:
:
Connection
(
Service
*
aService
int
aFlags
bool
aAsyncOnly
bool
aIgnoreLockingMode
)
:
sharedAsyncExecutionMutex
(
"
Connection
:
:
sharedAsyncExecutionMutex
"
)
sharedDBMutex
(
"
Connection
:
:
sharedDBMutex
"
)
threadOpenedOn
(
do_GetCurrentThread
(
)
)
mDBConn
(
nullptr
)
mAsyncExecutionThreadShuttingDown
(
false
)
mConnectionClosed
(
false
)
mTransactionInProgress
(
false
)
mProgressHandler
(
nullptr
)
mFlags
(
aFlags
)
mIgnoreLockingMode
(
aIgnoreLockingMode
)
mStorageService
(
aService
)
mAsyncOnly
(
aAsyncOnly
)
{
MOZ_ASSERT
(
!
mIgnoreLockingMode
|
|
mFlags
&
SQLITE_OPEN_READONLY
"
Can
'
t
ignore
locking
for
a
non
-
readonly
connection
!
"
)
;
mStorageService
-
>
registerConnection
(
this
)
;
}
Connection
:
:
~
Connection
(
)
{
Unused
<
<
Close
(
)
;
MOZ_ASSERT
(
!
mAsyncExecutionThread
"
The
async
thread
has
not
been
shutdown
properly
!
"
)
;
}
NS_IMPL_ADDREF
(
Connection
)
NS_INTERFACE_MAP_BEGIN
(
Connection
)
NS_INTERFACE_MAP_ENTRY
(
mozIStorageAsyncConnection
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
mozIStorageConnection
!
mAsyncOnly
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
mozIStorageConnection
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP_
(
MozExternalRefCountType
)
Connection
:
:
Release
(
void
)
{
NS_PRECONDITION
(
0
!
=
mRefCnt
"
dup
release
"
)
;
nsrefcnt
count
=
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
count
"
Connection
"
)
;
if
(
1
=
=
count
)
{
mStorageService
-
>
unregisterConnection
(
this
)
;
}
else
if
(
0
=
=
count
)
{
mRefCnt
=
1
;
#
if
0
NS_ASSERT_OWNINGTHREAD
(
Connection
)
;
#
endif
delete
(
this
)
;
return
0
;
}
return
count
;
}
int32_t
Connection
:
:
getSqliteRuntimeStatus
(
int32_t
aStatusOption
int32_t
*
aMaxValue
)
{
MOZ_ASSERT
(
mDBConn
"
A
connection
must
exist
at
this
point
"
)
;
int
curr
=
0
max
=
0
;
DebugOnly
<
int
>
rc
=
:
:
sqlite3_db_status
(
mDBConn
aStatusOption
&
curr
&
max
0
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
convertResultCode
(
rc
)
)
)
;
if
(
aMaxValue
)
*
aMaxValue
=
max
;
return
curr
;
}
nsIEventTarget
*
Connection
:
:
getAsyncExecutionTarget
(
)
{
NS_ENSURE_TRUE
(
threadOpenedOn
=
=
NS_GetCurrentThread
(
)
nullptr
)
;
if
(
mAsyncExecutionThreadShuttingDown
)
{
return
nullptr
;
}
if
(
!
mAsyncExecutionThread
)
{
static
nsThreadPoolNaming
naming
;
nsresult
rv
=
NS_NewNamedThread
(
naming
.
GetNextThreadName
(
"
mozStorage
"
)
getter_AddRefs
(
mAsyncExecutionThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
async
thread
.
"
)
;
return
nullptr
;
}
}
return
mAsyncExecutionThread
;
}
nsresult
Connection
:
:
initialize
(
)
{
NS_ASSERTION
(
!
mDBConn
"
Initialize
called
on
already
opened
database
!
"
)
;
MOZ_ASSERT
(
!
mIgnoreLockingMode
"
Can
'
t
ignore
locking
on
an
in
-
memory
db
.
"
)
;
AUTO_PROFILER_LABEL
(
"
Connection
:
:
initialize
"
STORAGE
)
;
int
srv
=
:
:
sqlite3_open_v2
(
"
:
memory
:
"
&
mDBConn
mFlags
nullptr
)
;
if
(
srv
!
=
SQLITE_OK
)
{
mDBConn
=
nullptr
;
return
convertResultCode
(
srv
)
;
}
nsresult
rv
=
initializeInternal
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Connection
:
:
initialize
(
nsIFile
*
aDatabaseFile
)
{
NS_ASSERTION
(
aDatabaseFile
"
Passed
null
file
!
"
)
;
NS_ASSERTION
(
!
mDBConn
"
Initialize
called
on
already
opened
database
!
"
)
;
AUTO_PROFILER_LABEL
(
"
Connection
:
:
initialize
"
STORAGE
)
;
mDatabaseFile
=
aDatabaseFile
;
nsAutoString
path
;
nsresult
rv
=
aDatabaseFile
-
>
GetPath
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
ifdef
XP_WIN
static
const
char
*
sIgnoreLockingVFS
=
"
win32
-
none
"
;
#
else
static
const
char
*
sIgnoreLockingVFS
=
"
unix
-
none
"
;
#
endif
const
char
*
vfs
=
mIgnoreLockingMode
?
sIgnoreLockingVFS
:
nullptr
;
int
srv
=
:
:
sqlite3_open_v2
(
NS_ConvertUTF16toUTF8
(
path
)
.
get
(
)
&
mDBConn
mFlags
vfs
)
;
if
(
srv
!
=
SQLITE_OK
)
{
mDBConn
=
nullptr
;
return
convertResultCode
(
srv
)
;
}
mDatabaseFile
=
aDatabaseFile
;
rv
=
initializeInternal
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Connection
:
:
initialize
(
nsIFileURL
*
aFileURL
)
{
NS_ASSERTION
(
aFileURL
"
Passed
null
file
URL
!
"
)
;
NS_ASSERTION
(
!
mDBConn
"
Initialize
called
on
already
opened
database
!
"
)
;
AUTO_PROFILER_LABEL
(
"
Connection
:
:
initialize
"
STORAGE
)
;
nsCOMPtr
<
nsIFile
>
databaseFile
;
nsresult
rv
=
aFileURL
-
>
GetFile
(
getter_AddRefs
(
databaseFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
spec
;
rv
=
aFileURL
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int
srv
=
:
:
sqlite3_open_v2
(
spec
.
get
(
)
&
mDBConn
mFlags
nullptr
)
;
if
(
srv
!
=
SQLITE_OK
)
{
mDBConn
=
nullptr
;
return
convertResultCode
(
srv
)
;
}
mFileURL
=
aFileURL
;
mDatabaseFile
=
databaseFile
;
rv
=
initializeInternal
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
Connection
:
:
initializeInternal
(
)
{
MOZ_ASSERT
(
mDBConn
)
;
auto
guard
=
MakeScopeExit
(
[
&
]
(
)
{
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
mConnectionClosed
=
true
;
}
MOZ_ALWAYS_TRUE
(
:
:
sqlite3_close
(
mDBConn
)
=
=
SQLITE_OK
)
;
mDBConn
=
nullptr
;
sharedDBMutex
.
destroy
(
)
;
}
)
;
if
(
mFileURL
)
{
const
char
*
dbPath
=
:
:
sqlite3_db_filename
(
mDBConn
"
main
"
)
;
MOZ_ASSERT
(
dbPath
)
;
const
char
*
telemetryFilename
=
:
:
sqlite3_uri_parameter
(
dbPath
"
telemetryFilename
"
)
;
if
(
telemetryFilename
)
{
if
(
NS_WARN_IF
(
*
telemetryFilename
=
=
'
\
0
'
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mTelemetryFilename
=
telemetryFilename
;
}
}
if
(
mTelemetryFilename
.
IsEmpty
(
)
)
{
mTelemetryFilename
=
getFilename
(
)
;
MOZ_ASSERT
(
!
mTelemetryFilename
.
IsEmpty
(
)
)
;
}
sharedDBMutex
.
initWithMutex
(
sqlite3_db_mutex
(
mDBConn
)
)
;
if
(
MOZ_LOG_TEST
(
gStorageLog
LogLevel
:
:
Debug
)
)
{
:
:
sqlite3_trace_v2
(
mDBConn
SQLITE_TRACE_STMT
|
SQLITE_TRACE_PROFILE
tracefunc
this
)
;
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Debug
(
"
Opening
connection
to
'
%
s
'
(
%
p
)
"
mTelemetryFilename
.
get
(
)
this
)
)
;
}
int64_t
pageSize
=
Service
:
:
getDefaultPageSize
(
)
;
nsAutoCString
pageSizeQuery
(
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
PRAGMA
page_size
=
"
)
;
pageSizeQuery
.
AppendInt
(
pageSize
)
;
int
srv
=
executeSql
(
mDBConn
pageSizeQuery
.
get
(
)
)
;
if
(
srv
!
=
SQLITE_OK
)
{
return
convertResultCode
(
srv
)
;
}
nsAutoCString
cacheSizeQuery
(
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
PRAGMA
cache_size
=
"
)
;
cacheSizeQuery
.
AppendInt
(
-
MAX_CACHE_SIZE_KIBIBYTES
)
;
srv
=
executeSql
(
mDBConn
cacheSizeQuery
.
get
(
)
)
;
if
(
srv
!
=
SQLITE_OK
)
{
return
convertResultCode
(
srv
)
;
}
#
if
defined
(
MOZ_MEMORY_TEMP_STORE_PRAGMA
)
(
void
)
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
temp_store
=
2
;
"
)
)
;
#
endif
srv
=
registerFunctions
(
mDBConn
)
;
if
(
srv
!
=
SQLITE_OK
)
{
return
convertResultCode
(
srv
)
;
}
srv
=
registerCollations
(
mDBConn
mStorageService
)
;
if
(
srv
!
=
SQLITE_OK
)
{
return
convertResultCode
(
srv
)
;
}
switch
(
Service
:
:
getSynchronousPref
(
)
)
{
case
2
:
(
void
)
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
synchronous
=
FULL
;
"
)
)
;
break
;
case
0
:
(
void
)
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
synchronous
=
OFF
;
"
)
)
;
break
;
case
1
:
default
:
(
void
)
ExecuteSimpleSQL
(
NS_LITERAL_CSTRING
(
"
PRAGMA
synchronous
=
NORMAL
;
"
)
)
;
break
;
}
guard
.
release
(
)
;
return
NS_OK
;
}
nsresult
Connection
:
:
initializeOnAsyncThread
(
nsIFile
*
aStorageFile
)
{
MOZ_ASSERT
(
threadOpenedOn
!
=
NS_GetCurrentThread
(
)
)
;
nsresult
rv
=
aStorageFile
?
initialize
(
aStorageFile
)
:
initialize
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
mAsyncExecutionThreadShuttingDown
=
true
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
Connection
:
:
shutdownAsyncThread
"
this
&
Connection
:
:
shutdownAsyncThread
)
;
Unused
<
<
NS_DispatchToMainThread
(
event
)
;
}
return
rv
;
}
nsresult
Connection
:
:
databaseElementExists
(
enum
DatabaseElementType
aElementType
const
nsACString
&
aElementName
bool
*
_exists
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
nsCString
query
(
"
SELECT
name
FROM
(
SELECT
*
FROM
"
)
;
nsDependentCSubstring
element
;
int32_t
ind
=
aElementName
.
FindChar
(
'
.
'
)
;
if
(
ind
=
=
kNotFound
)
{
element
.
Assign
(
aElementName
)
;
}
else
{
nsDependentCSubstring
db
(
Substring
(
aElementName
0
ind
+
1
)
)
;
element
.
Assign
(
Substring
(
aElementName
ind
+
1
aElementName
.
Length
(
)
)
)
;
query
.
Append
(
db
)
;
}
query
.
AppendLiteral
(
"
sqlite_master
UNION
ALL
SELECT
*
FROM
sqlite_temp_master
)
WHERE
type
=
'
"
)
;
switch
(
aElementType
)
{
case
INDEX
:
query
.
AppendLiteral
(
"
index
"
)
;
break
;
case
TABLE
:
query
.
AppendLiteral
(
"
table
"
)
;
break
;
}
query
.
AppendLiteral
(
"
'
AND
name
=
'
"
)
;
query
.
Append
(
element
)
;
query
.
Append
(
'
\
'
'
)
;
sqlite3_stmt
*
stmt
;
int
srv
=
prepareStatement
(
mDBConn
query
&
stmt
)
;
if
(
srv
!
=
SQLITE_OK
)
return
convertResultCode
(
srv
)
;
srv
=
stepStatement
(
mDBConn
stmt
)
;
(
void
)
:
:
sqlite3_finalize
(
stmt
)
;
if
(
srv
=
=
SQLITE_ROW
)
{
*
_exists
=
true
;
return
NS_OK
;
}
if
(
srv
=
=
SQLITE_DONE
)
{
*
_exists
=
false
;
return
NS_OK
;
}
return
convertResultCode
(
srv
)
;
}
bool
Connection
:
:
findFunctionByInstance
(
nsISupports
*
aInstance
)
{
sharedDBMutex
.
assertCurrentThreadOwns
(
)
;
for
(
auto
iter
=
mFunctions
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
UserData
(
)
.
function
=
=
aInstance
)
{
return
true
;
}
}
return
false
;
}
int
Connection
:
:
sProgressHelper
(
void
*
aArg
)
{
Connection
*
_this
=
static_cast
<
Connection
*
>
(
aArg
)
;
return
_this
-
>
progressHandler
(
)
;
}
int
Connection
:
:
progressHandler
(
)
{
sharedDBMutex
.
assertCurrentThreadOwns
(
)
;
if
(
mProgressHandler
)
{
bool
result
;
nsresult
rv
=
mProgressHandler
-
>
OnProgress
(
this
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
return
0
;
return
result
?
1
:
0
;
}
return
0
;
}
nsresult
Connection
:
:
setClosedState
(
)
{
bool
onOpenedThread
;
nsresult
rv
=
threadOpenedOn
-
>
IsOnCurrentThread
(
&
onOpenedThread
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
onOpenedThread
)
{
NS_ERROR
(
"
Must
close
the
database
on
the
thread
that
you
opened
it
with
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
NS_ENSURE_FALSE
(
mAsyncExecutionThreadShuttingDown
NS_ERROR_UNEXPECTED
)
;
mAsyncExecutionThreadShuttingDown
=
true
;
mDBConn
=
nullptr
;
}
return
NS_OK
;
}
bool
Connection
:
:
connectionReady
(
)
{
return
mDBConn
!
=
nullptr
;
}
bool
Connection
:
:
isConnectionReadyOnThisThread
(
)
{
MOZ_ASSERT_IF
(
mDBConn
!
mConnectionClosed
)
;
if
(
mAsyncExecutionThread
&
&
mAsyncExecutionThread
-
>
IsOnCurrentThread
(
)
)
{
return
true
;
}
return
connectionReady
(
)
;
}
bool
Connection
:
:
isClosing
(
)
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
return
mAsyncExecutionThreadShuttingDown
&
&
!
mConnectionClosed
;
}
bool
Connection
:
:
isClosed
(
)
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
return
mConnectionClosed
;
}
bool
Connection
:
:
isClosed
(
MutexAutoLock
&
lock
)
{
return
mConnectionClosed
;
}
bool
Connection
:
:
isAsyncExecutionThreadAvailable
(
)
{
MOZ_ASSERT
(
threadOpenedOn
=
=
NS_GetCurrentThread
(
)
)
;
return
mAsyncExecutionThread
&
&
!
mAsyncExecutionThreadShuttingDown
;
}
void
Connection
:
:
shutdownAsyncThread
(
)
{
MOZ_ASSERT
(
threadOpenedOn
=
=
NS_GetCurrentThread
(
)
)
;
MOZ_ASSERT
(
mAsyncExecutionThread
)
;
MOZ_ASSERT
(
mAsyncExecutionThreadShuttingDown
)
;
MOZ_ALWAYS_SUCCEEDS
(
mAsyncExecutionThread
-
>
Shutdown
(
)
)
;
mAsyncExecutionThread
=
nullptr
;
}
nsresult
Connection
:
:
internalClose
(
sqlite3
*
aNativeConnection
)
{
#
ifdef
DEBUG
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
MOZ_ASSERT
(
mAsyncExecutionThreadShuttingDown
"
Did
not
call
setClosedState
!
"
)
;
MOZ_ASSERT
(
!
isClosed
(
lockedScope
)
"
Unexpected
closed
state
"
)
;
}
#
endif
if
(
MOZ_LOG_TEST
(
gStorageLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
leafName
(
"
:
memory
"
)
;
if
(
mDatabaseFile
)
(
void
)
mDatabaseFile
-
>
GetNativeLeafName
(
leafName
)
;
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Debug
(
"
Closing
connection
to
'
%
s
'
"
leafName
.
get
(
)
)
)
;
}
{
MutexAutoLock
lockedScope
(
sharedAsyncExecutionMutex
)
;
mConnectionClosed
=
true
;
}
if
(
!
aNativeConnection
)
return
NS_OK
;
int
srv
=
:
:
sqlite3_close
(
aNativeConnection
)
;
if
(
srv
=
=
SQLITE_BUSY
)
{
{
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
sqlite3_stmt
*
stmt
=
nullptr
;
while
(
(
stmt
=
:
:
sqlite3_next_stmt
(
aNativeConnection
stmt
)
)
)
{
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Debug
(
"
Auto
-
finalizing
SQL
statement
'
%
s
'
(
%
p
)
"
:
:
sqlite3_sql
(
stmt
)
stmt
)
)
;
#
ifdef
DEBUG
SmprintfPointer
msg
=
:
:
mozilla
:
:
Smprintf
(
"
SQL
statement
'
%
s
'
(
%
p
)
should
have
been
finalized
before
closing
the
connection
"
:
:
sqlite3_sql
(
stmt
)
stmt
)
;
NS_WARNING
(
msg
.
get
(
)
)
;
#
endif
srv
=
:
:
sqlite3_finalize
(
stmt
)
;
#
ifdef
DEBUG
if
(
srv
!
=
SQLITE_OK
)
{
SmprintfPointer
msg
=
:
:
mozilla
:
:
Smprintf
(
"
Could
not
finalize
SQL
statement
(
%
p
)
"
stmt
)
;
NS_WARNING
(
msg
.
get
(
)
)
;
}
#
endif
if
(
srv
=
=
SQLITE_OK
)
{
stmt
=
nullptr
;
}
}
}
srv
=
:
:
sqlite3_close
(
aNativeConnection
)
;
MOZ_ASSERT
(
false
"
Had
to
forcibly
close
the
database
connection
because
not
all
the
statements
have
been
finalized
.
"
)
;
}
if
(
srv
=
=
SQLITE_OK
)
{
sharedDBMutex
.
destroy
(
)
;
}
else
{
MOZ_ASSERT
(
false
"
sqlite3_close
failed
.
There
are
probably
outstanding
statements
that
are
listed
above
!
"
)
;
}
return
convertResultCode
(
srv
)
;
}
nsCString
Connection
:
:
getFilename
(
)
{
nsCString
leafname
(
"
:
memory
:
"
)
;
if
(
mDatabaseFile
)
{
(
void
)
mDatabaseFile
-
>
GetNativeLeafName
(
leafname
)
;
}
return
leafname
;
}
int
Connection
:
:
stepStatement
(
sqlite3
*
aNativeConnection
sqlite3_stmt
*
aStatement
)
{
MOZ_ASSERT
(
aStatement
)
;
bool
checkedMainThread
=
false
;
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
if
(
!
isConnectionReadyOnThisThread
(
)
)
return
SQLITE_MISUSE
;
(
void
)
:
:
sqlite3_extended_result_codes
(
aNativeConnection
1
)
;
int
srv
;
while
(
(
srv
=
:
:
sqlite3_step
(
aStatement
)
)
=
=
SQLITE_LOCKED_SHAREDCACHE
)
{
if
(
!
checkedMainThread
)
{
checkedMainThread
=
true
;
if
(
:
:
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
We
won
'
t
allow
blocking
on
the
main
thread
!
"
)
;
break
;
}
}
srv
=
WaitForUnlockNotify
(
aNativeConnection
)
;
if
(
srv
!
=
SQLITE_OK
)
{
break
;
}
:
:
sqlite3_reset
(
aStatement
)
;
}
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
startTime
;
const
uint32_t
threshold
=
NS_IsMainThread
(
)
?
Telemetry
:
:
kSlowSQLThresholdForMainThread
:
Telemetry
:
:
kSlowSQLThresholdForHelperThreads
;
if
(
duration
.
ToMilliseconds
(
)
>
=
threshold
)
{
nsDependentCString
statementString
(
:
:
sqlite3_sql
(
aStatement
)
)
;
Telemetry
:
:
RecordSlowSQLStatement
(
statementString
mTelemetryFilename
duration
.
ToMilliseconds
(
)
)
;
}
(
void
)
:
:
sqlite3_extended_result_codes
(
aNativeConnection
0
)
;
return
srv
&
0xFF
;
}
int
Connection
:
:
prepareStatement
(
sqlite3
*
aNativeConnection
const
nsCString
&
aSQL
sqlite3_stmt
*
*
_stmt
)
{
if
(
!
isConnectionReadyOnThisThread
(
)
)
return
SQLITE_MISUSE
;
bool
checkedMainThread
=
false
;
(
void
)
:
:
sqlite3_extended_result_codes
(
aNativeConnection
1
)
;
int
srv
;
while
(
(
srv
=
:
:
sqlite3_prepare_v2
(
aNativeConnection
aSQL
.
get
(
)
-
1
_stmt
nullptr
)
)
=
=
SQLITE_LOCKED_SHAREDCACHE
)
{
if
(
!
checkedMainThread
)
{
checkedMainThread
=
true
;
if
(
:
:
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
We
won
'
t
allow
blocking
on
the
main
thread
!
"
)
;
break
;
}
}
srv
=
WaitForUnlockNotify
(
aNativeConnection
)
;
if
(
srv
!
=
SQLITE_OK
)
{
break
;
}
}
if
(
srv
!
=
SQLITE_OK
)
{
nsCString
warnMsg
;
warnMsg
.
AppendLiteral
(
"
The
SQL
statement
'
"
)
;
warnMsg
.
Append
(
aSQL
)
;
warnMsg
.
AppendLiteral
(
"
'
could
not
be
compiled
due
to
an
error
:
"
)
;
warnMsg
.
Append
(
:
:
sqlite3_errmsg
(
aNativeConnection
)
)
;
#
ifdef
DEBUG
NS_WARNING
(
warnMsg
.
get
(
)
)
;
#
endif
MOZ_LOG
(
gStorageLog
LogLevel
:
:
Error
(
"
%
s
"
warnMsg
.
get
(
)
)
)
;
}
(
void
)
:
:
sqlite3_extended_result_codes
(
aNativeConnection
0
)
;
int
rc
=
srv
&
0xFF
;
if
(
rc
=
=
SQLITE_OK
&
&
*
_stmt
=
=
nullptr
)
{
return
SQLITE_MISUSE
;
}
return
rc
;
}
int
Connection
:
:
executeSql
(
sqlite3
*
aNativeConnection
const
char
*
aSqlString
)
{
if
(
!
isConnectionReadyOnThisThread
(
)
)
return
SQLITE_MISUSE
;
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
int
srv
=
:
:
sqlite3_exec
(
aNativeConnection
aSqlString
nullptr
nullptr
nullptr
)
;
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
startTime
;
const
uint32_t
threshold
=
NS_IsMainThread
(
)
?
Telemetry
:
:
kSlowSQLThresholdForMainThread
:
Telemetry
:
:
kSlowSQLThresholdForHelperThreads
;
if
(
duration
.
ToMilliseconds
(
)
>
=
threshold
)
{
nsDependentCString
statementString
(
aSqlString
)
;
Telemetry
:
:
RecordSlowSQLStatement
(
statementString
mTelemetryFilename
duration
.
ToMilliseconds
(
)
)
;
}
return
srv
;
}
NS_IMETHODIMP
Connection
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
_result
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIEventTarget
)
)
)
{
nsIEventTarget
*
background
=
getAsyncExecutionTarget
(
)
;
NS_IF_ADDREF
(
background
)
;
*
_result
=
background
;
return
NS_OK
;
}
return
NS_ERROR_NO_INTERFACE
;
}
NS_IMETHODIMP
Connection
:
:
Close
(
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
#
ifdef
DEBUG
bool
onOpenerThread
=
false
;
(
void
)
threadOpenedOn
-
>
IsOnCurrentThread
(
&
onOpenerThread
)
;
MOZ_ASSERT
(
onOpenerThread
)
;
#
endif
if
(
isAsyncExecutionThreadAvailable
(
)
)
{
#
ifdef
DEBUG
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIXPConnect
>
xpc
=
do_GetService
(
nsIXPConnect
:
:
GetCID
(
)
)
;
Unused
<
<
xpc
-
>
DebugDumpJSStack
(
false
false
false
)
;
}
#
endif
MOZ_ASSERT
(
false
"
Close
(
)
was
invoked
on
a
connection
that
executed
asynchronous
statements
.
"
"
Should
have
used
asyncClose
(
)
.
"
)
;
Unused
<
<
SpinningSynchronousClose
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
sqlite3
*
nativeConn
=
mDBConn
;
nsresult
rv
=
setClosedState
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
internalClose
(
nativeConn
)
;
}
NS_IMETHODIMP
Connection
:
:
SpinningSynchronousClose
(
)
{
if
(
threadOpenedOn
!
=
NS_GetCurrentThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
MOZ_DIAGNOSTIC_ASSERT
(
connectionReady
(
)
)
;
if
(
!
connectionReady
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
CloseListener
>
listener
=
new
CloseListener
(
)
;
nsresult
rv
=
AsyncClose
(
listener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
[
&
]
(
)
{
return
listener
-
>
mClosed
;
}
)
)
;
MOZ_ASSERT
(
isClosed
(
)
"
The
connection
should
be
closed
at
this
point
"
)
;
return
rv
;
}
NS_IMETHODIMP
Connection
:
:
AsyncClose
(
mozIStorageCompletionCallback
*
aCallback
)
{
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_NOT_SAME_THREAD
)
;
if
(
!
mDBConn
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsIEventTarget
*
asyncThread
=
getAsyncExecutionTarget
(
)
;
nsCOMPtr
<
nsIRunnable
>
completeEvent
;
if
(
aCallback
)
{
completeEvent
=
newCompletionEvent
(
aCallback
)
;
}
if
(
!
asyncThread
)
{
if
(
completeEvent
)
{
Unused
<
<
NS_DispatchToMainThread
(
completeEvent
.
forget
(
)
)
;
}
MOZ_ALWAYS_SUCCEEDS
(
Close
(
)
)
;
return
NS_OK
;
}
sqlite3
*
nativeConn
=
mDBConn
;
nsresult
rv
=
setClosedState
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIRunnable
>
closeEvent
=
new
AsyncCloseConnection
(
this
nativeConn
completeEvent
)
;
rv
=
asyncThread
-
>
Dispatch
(
closeEvent
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
AsyncClone
(
bool
aReadOnly
mozIStorageCompletionCallback
*
aCallback
)
{
AUTO_PROFILER_LABEL
(
"
Connection
:
:
AsyncClone
"
STORAGE
)
;
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_NOT_SAME_THREAD
)
;
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
if
(
!
mDatabaseFile
)
return
NS_ERROR_UNEXPECTED
;
int
flags
=
mFlags
;
if
(
aReadOnly
)
{
flags
=
(
~
SQLITE_OPEN_READWRITE
&
flags
)
|
SQLITE_OPEN_READONLY
;
flags
=
(
~
SQLITE_OPEN_CREATE
&
flags
)
;
}
RefPtr
<
Connection
>
clone
=
new
Connection
(
mStorageService
flags
true
)
;
RefPtr
<
AsyncInitializeClone
>
initEvent
=
new
AsyncInitializeClone
(
this
clone
aReadOnly
aCallback
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
getAsyncExecutionTarget
(
)
;
if
(
!
target
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
target
-
>
Dispatch
(
initEvent
NS_DISPATCH_NORMAL
)
;
}
nsresult
Connection
:
:
initializeClone
(
Connection
*
aClone
bool
aReadOnly
)
{
nsresult
rv
=
mFileURL
?
aClone
-
>
initialize
(
mFileURL
)
:
aClone
-
>
initialize
(
mDatabaseFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
CreateStatement
(
NS_LITERAL_CSTRING
(
"
PRAGMA
database_list
"
)
getter_AddRefs
(
stmt
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
hasResult
=
false
;
while
(
stmt
&
&
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
nsAutoCString
name
;
rv
=
stmt
-
>
GetUTF8String
(
1
name
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
name
.
EqualsLiteral
(
"
main
"
)
&
&
!
name
.
EqualsLiteral
(
"
temp
"
)
)
{
nsCString
path
;
rv
=
stmt
-
>
GetUTF8String
(
2
path
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
path
.
IsEmpty
(
)
)
{
nsCOMPtr
<
mozIStorageStatement
>
attachStmt
;
rv
=
aClone
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
ATTACH
DATABASE
:
path
AS
"
)
+
name
getter_AddRefs
(
attachStmt
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
attachStmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
path
"
)
path
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
attachStmt
-
>
Execute
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
couldn
'
t
re
-
attach
database
to
cloned
connection
"
)
;
}
}
}
}
static
const
char
*
pragmas
[
]
=
{
"
cache_size
"
"
temp_store
"
"
foreign_keys
"
"
journal_size_limit
"
"
synchronous
"
"
wal_autocheckpoint
"
"
busy_timeout
"
}
;
for
(
auto
&
pragma
:
pragmas
)
{
if
(
aReadOnly
&
&
:
:
strcmp
(
pragma
"
cache_size
"
)
!
=
0
&
&
:
:
strcmp
(
pragma
"
temp_store
"
)
!
=
0
)
{
continue
;
}
nsAutoCString
pragmaQuery
(
"
PRAGMA
"
)
;
pragmaQuery
.
Append
(
pragma
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
CreateStatement
(
pragmaQuery
getter_AddRefs
(
stmt
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
bool
hasResult
=
false
;
if
(
stmt
&
&
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
pragmaQuery
.
AppendLiteral
(
"
=
"
)
;
pragmaQuery
.
AppendInt
(
stmt
-
>
AsInt32
(
0
)
)
;
rv
=
aClone
-
>
ExecuteSimpleSQL
(
pragmaQuery
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
for
(
auto
iter
=
mFunctions
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsACString
&
key
=
iter
.
Key
(
)
;
Connection
:
:
FunctionInfo
data
=
iter
.
UserData
(
)
;
MOZ_ASSERT
(
data
.
type
=
=
Connection
:
:
FunctionInfo
:
:
SIMPLE
|
|
data
.
type
=
=
Connection
:
:
FunctionInfo
:
:
AGGREGATE
"
Invalid
function
type
!
"
)
;
if
(
data
.
type
=
=
Connection
:
:
FunctionInfo
:
:
SIMPLE
)
{
mozIStorageFunction
*
function
=
static_cast
<
mozIStorageFunction
*
>
(
data
.
function
.
get
(
)
)
;
rv
=
aClone
-
>
CreateFunction
(
key
data
.
numArgs
function
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
copy
function
to
cloned
connection
"
)
;
}
}
else
{
mozIStorageAggregateFunction
*
function
=
static_cast
<
mozIStorageAggregateFunction
*
>
(
data
.
function
.
get
(
)
)
;
rv
=
aClone
-
>
CreateAggregateFunction
(
key
data
.
numArgs
function
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
copy
aggregate
function
to
cloned
connection
"
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
Clone
(
bool
aReadOnly
mozIStorageConnection
*
*
_connection
)
{
MOZ_ASSERT
(
threadOpenedOn
=
=
NS_GetCurrentThread
(
)
)
;
AUTO_PROFILER_LABEL
(
"
Connection
:
:
Clone
"
STORAGE
)
;
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
if
(
!
mDatabaseFile
)
return
NS_ERROR_UNEXPECTED
;
int
flags
=
mFlags
;
if
(
aReadOnly
)
{
flags
=
(
~
SQLITE_OPEN_READWRITE
&
flags
)
|
SQLITE_OPEN_READONLY
;
flags
=
(
~
SQLITE_OPEN_CREATE
&
flags
)
;
}
RefPtr
<
Connection
>
clone
=
new
Connection
(
mStorageService
flags
mAsyncOnly
)
;
nsresult
rv
=
initializeClone
(
clone
aReadOnly
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_IF_ADDREF
(
*
_connection
=
clone
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
Interrupt
(
)
{
MOZ_ASSERT
(
threadOpenedOn
=
=
NS_GetCurrentThread
(
)
)
;
if
(
!
mDBConn
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
mAsyncOnly
|
|
!
(
mFlags
&
SQLITE_OPEN_READONLY
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
:
:
sqlite3_interrupt
(
mDBConn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetDefaultPageSize
(
int32_t
*
_defaultPageSize
)
{
*
_defaultPageSize
=
Service
:
:
getDefaultPageSize
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetConnectionReady
(
bool
*
_ready
)
{
MOZ_ASSERT
(
threadOpenedOn
=
=
NS_GetCurrentThread
(
)
)
;
*
_ready
=
connectionReady
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetDatabaseFile
(
nsIFile
*
*
_dbFile
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
NS_IF_ADDREF
(
*
_dbFile
=
mDatabaseFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetLastInsertRowID
(
int64_t
*
_id
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
sqlite_int64
id
=
:
:
sqlite3_last_insert_rowid
(
mDBConn
)
;
*
_id
=
id
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetAffectedRows
(
int32_t
*
_rows
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
*
_rows
=
:
:
sqlite3_changes
(
mDBConn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetLastError
(
int32_t
*
_error
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
*
_error
=
:
:
sqlite3_errcode
(
mDBConn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetLastErrorString
(
nsACString
&
_errorString
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
const
char
*
serr
=
:
:
sqlite3_errmsg
(
mDBConn
)
;
_errorString
.
Assign
(
serr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
GetSchemaVersion
(
int32_t
*
_version
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
(
void
)
CreateStatement
(
NS_LITERAL_CSTRING
(
"
PRAGMA
user_version
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_TRUE
(
stmt
NS_ERROR_OUT_OF_MEMORY
)
;
*
_version
=
0
;
bool
hasResult
;
if
(
NS_SUCCEEDED
(
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
*
_version
=
stmt
-
>
AsInt32
(
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
SetSchemaVersion
(
int32_t
aVersion
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
nsAutoCString
stmt
(
NS_LITERAL_CSTRING
(
"
PRAGMA
user_version
=
"
)
)
;
stmt
.
AppendInt
(
aVersion
)
;
return
ExecuteSimpleSQL
(
stmt
)
;
}
NS_IMETHODIMP
Connection
:
:
CreateStatement
(
const
nsACString
&
aSQLStatement
mozIStorageStatement
*
*
_stmt
)
{
NS_ENSURE_ARG_POINTER
(
_stmt
)
;
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
RefPtr
<
Statement
>
statement
(
new
Statement
(
)
)
;
NS_ENSURE_TRUE
(
statement
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
statement
-
>
initialize
(
this
mDBConn
aSQLStatement
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Statement
*
rawPtr
;
statement
.
forget
(
&
rawPtr
)
;
*
_stmt
=
rawPtr
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
CreateAsyncStatement
(
const
nsACString
&
aSQLStatement
mozIStorageAsyncStatement
*
*
_stmt
)
{
NS_ENSURE_ARG_POINTER
(
_stmt
)
;
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
RefPtr
<
AsyncStatement
>
statement
(
new
AsyncStatement
(
)
)
;
NS_ENSURE_TRUE
(
statement
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
statement
-
>
initialize
(
this
mDBConn
aSQLStatement
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AsyncStatement
*
rawPtr
;
statement
.
forget
(
&
rawPtr
)
;
*
_stmt
=
rawPtr
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
ExecuteSimpleSQL
(
const
nsACString
&
aSQLStatement
)
{
CHECK_MAINTHREAD_ABUSE
(
)
;
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
int
srv
=
executeSql
(
mDBConn
PromiseFlatCString
(
aSQLStatement
)
.
get
(
)
)
;
return
convertResultCode
(
srv
)
;
}
NS_IMETHODIMP
Connection
:
:
ExecuteAsync
(
mozIStorageBaseStatement
*
*
aStatements
uint32_t
aNumStatements
mozIStorageStatementCallback
*
aCallback
mozIStoragePendingStatement
*
*
_handle
)
{
nsTArray
<
StatementData
>
stmts
(
aNumStatements
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumStatements
;
i
+
+
)
{
nsCOMPtr
<
StorageBaseStatementInternal
>
stmt
=
do_QueryInterface
(
aStatements
[
i
]
)
;
StatementData
data
;
nsresult
rv
=
stmt
-
>
getAsynchronousStatementData
(
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
stmt
-
>
getOwner
(
)
=
=
this
"
Statement
must
be
from
this
database
connection
!
"
)
;
NS_ENSURE_TRUE
(
stmts
.
AppendElement
(
data
)
NS_ERROR_OUT_OF_MEMORY
)
;
}
return
AsyncExecuteStatements
:
:
execute
(
stmts
this
mDBConn
aCallback
_handle
)
;
}
NS_IMETHODIMP
Connection
:
:
ExecuteSimpleSQLAsync
(
const
nsACString
&
aSQLStatement
mozIStorageStatementCallback
*
aCallback
mozIStoragePendingStatement
*
*
_handle
)
{
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_NOT_SAME_THREAD
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
nsresult
rv
=
CreateAsyncStatement
(
aSQLStatement
getter_AddRefs
(
stmt
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStoragePendingStatement
>
pendingStatement
;
rv
=
stmt
-
>
ExecuteAsync
(
aCallback
getter_AddRefs
(
pendingStatement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
pendingStatement
.
forget
(
_handle
)
;
return
rv
;
}
NS_IMETHODIMP
Connection
:
:
TableExists
(
const
nsACString
&
aTableName
bool
*
_exists
)
{
return
databaseElementExists
(
TABLE
aTableName
_exists
)
;
}
NS_IMETHODIMP
Connection
:
:
IndexExists
(
const
nsACString
&
aIndexName
bool
*
_exists
)
{
return
databaseElementExists
(
INDEX
aIndexName
_exists
)
;
}
NS_IMETHODIMP
Connection
:
:
GetTransactionInProgress
(
bool
*
_inProgress
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
*
_inProgress
=
mTransactionInProgress
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
BeginTransaction
(
)
{
return
BeginTransactionAs
(
mozIStorageConnection
:
:
TRANSACTION_DEFERRED
)
;
}
NS_IMETHODIMP
Connection
:
:
BeginTransactionAs
(
int32_t
aTransactionType
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
return
beginTransactionInternal
(
mDBConn
aTransactionType
)
;
}
nsresult
Connection
:
:
beginTransactionInternal
(
sqlite3
*
aNativeConnection
int32_t
aTransactionType
)
{
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
if
(
mTransactionInProgress
)
return
NS_ERROR_FAILURE
;
nsresult
rv
;
switch
(
aTransactionType
)
{
case
TRANSACTION_DEFERRED
:
rv
=
convertResultCode
(
executeSql
(
aNativeConnection
"
BEGIN
DEFERRED
"
)
)
;
break
;
case
TRANSACTION_IMMEDIATE
:
rv
=
convertResultCode
(
executeSql
(
aNativeConnection
"
BEGIN
IMMEDIATE
"
)
)
;
break
;
case
TRANSACTION_EXCLUSIVE
:
rv
=
convertResultCode
(
executeSql
(
aNativeConnection
"
BEGIN
EXCLUSIVE
"
)
)
;
break
;
default
:
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
mTransactionInProgress
=
true
;
return
rv
;
}
NS_IMETHODIMP
Connection
:
:
CommitTransaction
(
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
return
commitTransactionInternal
(
mDBConn
)
;
}
nsresult
Connection
:
:
commitTransactionInternal
(
sqlite3
*
aNativeConnection
)
{
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
if
(
!
mTransactionInProgress
)
return
NS_ERROR_UNEXPECTED
;
nsresult
rv
=
convertResultCode
(
executeSql
(
aNativeConnection
"
COMMIT
TRANSACTION
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
mTransactionInProgress
=
false
;
return
rv
;
}
NS_IMETHODIMP
Connection
:
:
RollbackTransaction
(
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
return
rollbackTransactionInternal
(
mDBConn
)
;
}
nsresult
Connection
:
:
rollbackTransactionInternal
(
sqlite3
*
aNativeConnection
)
{
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
if
(
!
mTransactionInProgress
)
return
NS_ERROR_UNEXPECTED
;
nsresult
rv
=
convertResultCode
(
executeSql
(
aNativeConnection
"
ROLLBACK
TRANSACTION
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
mTransactionInProgress
=
false
;
return
rv
;
}
NS_IMETHODIMP
Connection
:
:
CreateTable
(
const
char
*
aTableName
const
char
*
aTableSchema
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SmprintfPointer
buf
=
:
:
mozilla
:
:
Smprintf
(
"
CREATE
TABLE
%
s
(
%
s
)
"
aTableName
aTableSchema
)
;
if
(
!
buf
)
return
NS_ERROR_OUT_OF_MEMORY
;
int
srv
=
executeSql
(
mDBConn
buf
.
get
(
)
)
;
return
convertResultCode
(
srv
)
;
}
NS_IMETHODIMP
Connection
:
:
CreateFunction
(
const
nsACString
&
aFunctionName
int32_t
aNumArguments
mozIStorageFunction
*
aFunction
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
NS_ENSURE_FALSE
(
mFunctions
.
Get
(
aFunctionName
nullptr
)
NS_ERROR_FAILURE
)
;
int
srv
=
:
:
sqlite3_create_function
(
mDBConn
nsPromiseFlatCString
(
aFunctionName
)
.
get
(
)
aNumArguments
SQLITE_ANY
aFunction
basicFunctionHelper
nullptr
nullptr
)
;
if
(
srv
!
=
SQLITE_OK
)
return
convertResultCode
(
srv
)
;
FunctionInfo
info
=
{
aFunction
Connection
:
:
FunctionInfo
:
:
SIMPLE
aNumArguments
}
;
mFunctions
.
Put
(
aFunctionName
info
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
CreateAggregateFunction
(
const
nsACString
&
aFunctionName
int32_t
aNumArguments
mozIStorageAggregateFunction
*
aFunction
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
NS_ENSURE_FALSE
(
mFunctions
.
Get
(
aFunctionName
nullptr
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_FALSE
(
findFunctionByInstance
(
aFunction
)
NS_ERROR_FAILURE
)
;
int
srv
=
:
:
sqlite3_create_function
(
mDBConn
nsPromiseFlatCString
(
aFunctionName
)
.
get
(
)
aNumArguments
SQLITE_ANY
aFunction
nullptr
aggregateFunctionStepHelper
aggregateFunctionFinalHelper
)
;
if
(
srv
!
=
SQLITE_OK
)
return
convertResultCode
(
srv
)
;
FunctionInfo
info
=
{
aFunction
Connection
:
:
FunctionInfo
:
:
AGGREGATE
aNumArguments
}
;
mFunctions
.
Put
(
aFunctionName
info
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
RemoveFunction
(
const
nsACString
&
aFunctionName
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
NS_ENSURE_TRUE
(
mFunctions
.
Get
(
aFunctionName
nullptr
)
NS_ERROR_FAILURE
)
;
int
srv
=
:
:
sqlite3_create_function
(
mDBConn
nsPromiseFlatCString
(
aFunctionName
)
.
get
(
)
0
SQLITE_ANY
nullptr
nullptr
nullptr
nullptr
)
;
if
(
srv
!
=
SQLITE_OK
)
return
convertResultCode
(
srv
)
;
mFunctions
.
Remove
(
aFunctionName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
SetProgressHandler
(
int32_t
aGranularity
mozIStorageProgressHandler
*
aHandler
mozIStorageProgressHandler
*
*
_oldHandler
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
NS_IF_ADDREF
(
*
_oldHandler
=
mProgressHandler
)
;
if
(
!
aHandler
|
|
aGranularity
<
=
0
)
{
aHandler
=
nullptr
;
aGranularity
=
0
;
}
mProgressHandler
=
aHandler
;
:
:
sqlite3_progress_handler
(
mDBConn
aGranularity
sProgressHelper
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
RemoveProgressHandler
(
mozIStorageProgressHandler
*
*
_oldHandler
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
SQLiteMutexAutoLock
lockedScope
(
sharedDBMutex
)
;
NS_IF_ADDREF
(
*
_oldHandler
=
mProgressHandler
)
;
mProgressHandler
=
nullptr
;
:
:
sqlite3_progress_handler
(
mDBConn
0
nullptr
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
SetGrowthIncrement
(
int32_t
aChunkSize
const
nsACString
&
aDatabaseName
)
{
#
if
!
defined
(
ANDROID
)
&
&
!
defined
(
MOZ_PLATFORM_MAEMO
)
int64_t
bytesAvailable
;
nsresult
rv
=
mDatabaseFile
-
>
GetDiskSpaceAvailable
(
&
bytesAvailable
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
bytesAvailable
<
MIN_AVAILABLE_BYTES_PER_CHUNKED_GROWTH
)
{
return
NS_ERROR_FILE_TOO_BIG
;
}
(
void
)
:
:
sqlite3_file_control
(
mDBConn
aDatabaseName
.
Length
(
)
?
nsPromiseFlatCString
(
aDatabaseName
)
.
get
(
)
:
nullptr
SQLITE_FCNTL_CHUNK_SIZE
&
aChunkSize
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
EnableModule
(
const
nsACString
&
aModuleName
)
{
if
(
!
mDBConn
)
return
NS_ERROR_NOT_INITIALIZED
;
for
(
auto
&
gModule
:
gModules
)
{
struct
Module
*
m
=
&
gModule
;
if
(
aModuleName
.
Equals
(
m
-
>
name
)
)
{
int
srv
=
m
-
>
registerFunc
(
mDBConn
m
-
>
name
)
;
if
(
srv
!
=
SQLITE_OK
)
return
convertResultCode
(
srv
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
already_AddRefed
<
QuotaObject
>
GetQuotaObjectForFile
(
sqlite3_file
*
pFile
)
;
NS_IMETHODIMP
Connection
:
:
GetQuotaObjects
(
QuotaObject
*
*
aDatabaseQuotaObject
QuotaObject
*
*
aJournalQuotaObject
)
{
MOZ_ASSERT
(
aDatabaseQuotaObject
)
;
MOZ_ASSERT
(
aJournalQuotaObject
)
;
if
(
!
mDBConn
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
sqlite3_file
*
file
;
int
srv
=
:
:
sqlite3_file_control
(
mDBConn
nullptr
SQLITE_FCNTL_FILE_POINTER
&
file
)
;
if
(
srv
!
=
SQLITE_OK
)
{
return
convertResultCode
(
srv
)
;
}
RefPtr
<
QuotaObject
>
databaseQuotaObject
=
GetQuotaObjectForFile
(
file
)
;
srv
=
:
:
sqlite3_file_control
(
mDBConn
nullptr
SQLITE_FCNTL_JOURNAL_POINTER
&
file
)
;
if
(
srv
!
=
SQLITE_OK
)
{
return
convertResultCode
(
srv
)
;
}
RefPtr
<
QuotaObject
>
journalQuotaObject
=
GetQuotaObjectForFile
(
file
)
;
databaseQuotaObject
.
forget
(
aDatabaseQuotaObject
)
;
journalQuotaObject
.
forget
(
aJournalQuotaObject
)
;
return
NS_OK
;
}
}
}
