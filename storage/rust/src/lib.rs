#
!
[
allow
(
non_snake_case
)
]
use
std
:
:
{
borrow
:
:
Cow
convert
:
:
TryFrom
error
fmt
ops
:
:
Deref
result
}
;
use
nserror
:
:
{
nsresult
NS_ERROR_NO_INTERFACE
NS_ERROR_UNEXPECTED
}
;
use
nsstring
:
:
nsCString
;
use
storage_variant
:
:
VariantType
;
use
xpcom
:
:
{
getter_addrefs
interfaces
:
:
{
mozIStorageAsyncConnection
mozIStorageConnection
mozIStorageStatement
nsIEventTarget
nsIThread
}
RefPtr
XpCom
}
;
const
SQLITE_OK
:
i32
=
0
;
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
Error
>
;
#
[
derive
(
Clone
)
]
pub
struct
Conn
{
handle
:
RefPtr
<
mozIStorageConnection
>
}
unsafe
impl
Send
for
Conn
{
}
unsafe
impl
Sync
for
Conn
{
}
impl
Conn
{
#
[
inline
]
pub
fn
wrap
(
connection
:
RefPtr
<
mozIStorageConnection
>
)
-
>
Conn
{
Conn
{
handle
:
connection
}
}
#
[
inline
]
pub
fn
connection
(
&
self
)
-
>
&
mozIStorageConnection
{
&
self
.
handle
}
pub
fn
variable_limit
(
&
self
)
-
>
Result
<
usize
>
{
let
mut
limit
=
0i32
;
let
rv
=
unsafe
{
self
.
handle
.
GetVariableLimit
(
&
mut
limit
)
}
;
if
rv
.
failed
(
)
{
return
Err
(
Error
:
:
Limit
)
;
}
usize
:
:
try_from
(
limit
)
.
map_err
(
|
_
|
Error
:
:
Limit
)
}
pub
fn
thread
(
&
self
)
-
>
Result
<
RefPtr
<
nsIThread
>
>
{
let
target
=
self
.
handle
.
get_interface
:
:
<
nsIEventTarget
>
(
)
;
target
.
and_then
(
|
t
|
t
.
query_interface
:
:
<
nsIThread
>
(
)
)
.
ok_or
(
Error
:
:
NoThread
)
}
pub
fn
prepare
<
Q
:
AsRef
<
str
>
>
(
&
self
query
:
Q
)
-
>
Result
<
Statement
>
{
let
statement
=
self
.
call_and_wrap_error
(
DatabaseOp
:
:
Prepare
|
|
{
getter_addrefs
(
|
p
|
unsafe
{
self
.
handle
.
CreateStatement
(
&
*
nsCString
:
:
from
(
query
.
as_ref
(
)
)
p
)
}
)
}
)
?
;
Ok
(
Statement
{
conn
:
self
handle
:
statement
}
)
}
pub
fn
exec
<
Q
:
AsRef
<
str
>
>
(
&
self
query
:
Q
)
-
>
Result
<
(
)
>
{
self
.
call_and_wrap_error
(
DatabaseOp
:
:
Exec
|
|
{
unsafe
{
self
.
handle
.
ExecuteSimpleSQL
(
&
*
nsCString
:
:
from
(
query
.
as_ref
(
)
)
)
}
.
to_result
(
)
}
)
}
pub
fn
transaction
(
&
mut
self
)
-
>
Result
<
Transaction
>
{
let
behavior
=
self
.
get_default_transaction_behavior
(
)
;
Transaction
:
:
new
(
self
behavior
)
}
pub
fn
transaction_in_progress
(
&
self
)
-
>
Result
<
bool
>
{
let
mut
in_progress
=
false
;
unsafe
{
self
.
handle
.
GetTransactionInProgress
(
&
mut
in_progress
)
}
.
to_result
(
)
?
;
Ok
(
in_progress
)
}
pub
fn
transaction_with_behavior
(
&
mut
self
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
>
{
Transaction
:
:
new
(
self
behavior
)
}
fn
get_default_transaction_behavior
(
&
self
)
-
>
TransactionBehavior
{
let
mut
typ
=
0i32
;
let
rv
=
unsafe
{
self
.
handle
.
GetDefaultTransactionType
(
&
mut
typ
)
}
;
if
rv
.
failed
(
)
{
return
TransactionBehavior
:
:
Deferred
;
}
match
typ
{
mozIStorageAsyncConnection
:
:
TRANSACTION_IMMEDIATE
=
>
TransactionBehavior
:
:
Immediate
mozIStorageAsyncConnection
:
:
TRANSACTION_EXCLUSIVE
=
>
TransactionBehavior
:
:
Exclusive
_
=
>
TransactionBehavior
:
:
Deferred
}
}
fn
call_and_wrap_error
<
T
>
(
&
self
op
:
DatabaseOp
func
:
impl
FnOnce
(
)
-
>
result
:
:
Result
<
T
nsresult
>
)
-
>
Result
<
T
>
{
func
(
)
.
or_else
(
|
rv
|
-
>
Result
<
T
>
{
let
mut
code
=
0i32
;
unsafe
{
self
.
handle
.
GetLastError
(
&
mut
code
)
}
.
to_result
(
)
?
;
Err
(
if
code
!
=
SQLITE_OK
{
let
mut
message
=
nsCString
:
:
new
(
)
;
unsafe
{
self
.
handle
.
GetLastErrorString
(
&
mut
*
message
)
}
.
to_result
(
)
?
;
Error
:
:
Database
{
rv
op
code
message
}
}
else
{
rv
.
into
(
)
}
)
}
)
}
}
pub
enum
TransactionBehavior
{
Deferred
Immediate
Exclusive
}
pub
struct
Transaction
<
'
c
>
{
conn
:
&
'
c
mut
Conn
active
:
bool
}
impl
<
'
c
>
Transaction
<
'
c
>
{
fn
new
(
conn
:
&
'
c
mut
Conn
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
<
'
c
>
>
{
conn
.
exec
(
match
behavior
{
TransactionBehavior
:
:
Deferred
=
>
"
BEGIN
DEFERRED
"
TransactionBehavior
:
:
Immediate
=
>
"
BEGIN
IMMEDIATE
"
TransactionBehavior
:
:
Exclusive
=
>
"
BEGIN
EXCLUSIVE
"
}
)
?
;
Ok
(
Transaction
{
conn
active
:
true
}
)
}
pub
fn
commit
(
mut
self
)
-
>
Result
<
(
)
>
{
if
self
.
active
{
self
.
conn
.
exec
(
"
COMMIT
"
)
?
;
self
.
active
=
false
;
}
Ok
(
(
)
)
}
pub
fn
rollback
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
abort
(
)
}
fn
abort
(
&
mut
self
)
-
>
Result
<
(
)
>
{
if
self
.
active
{
self
.
conn
.
exec
(
"
ROLLBACK
"
)
?
;
self
.
active
=
false
;
}
Ok
(
(
)
)
}
}
impl
<
'
c
>
Deref
for
Transaction
<
'
c
>
{
type
Target
=
Conn
;
fn
deref
(
&
self
)
-
>
&
Conn
{
self
.
conn
}
}
impl
<
'
c
>
Drop
for
Transaction
<
'
c
>
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
abort
(
)
;
}
}
pub
struct
Statement
<
'
c
>
{
conn
:
&
'
c
Conn
handle
:
RefPtr
<
mozIStorageStatement
>
}
impl
<
'
c
>
Statement
<
'
c
>
{
pub
fn
bind_by_index
<
V
:
VariantType
>
(
&
mut
self
index
:
u32
value
:
V
)
-
>
Result
<
(
)
>
{
let
variant
=
value
.
into_variant
(
)
;
unsafe
{
self
.
handle
.
BindByIndex
(
index
as
u32
variant
.
coerce
(
)
)
}
.
to_result
(
)
.
map_err
(
|
rv
|
Error
:
:
BindByIndex
{
rv
data_type
:
V
:
:
type_name
(
)
index
}
)
}
pub
fn
bind_by_name
<
N
:
AsRef
<
str
>
V
:
VariantType
>
(
&
mut
self
name
:
N
value
:
V
)
-
>
Result
<
(
)
>
{
let
name
=
name
.
as_ref
(
)
;
let
variant
=
value
.
into_variant
(
)
;
unsafe
{
self
.
handle
.
BindByName
(
&
*
nsCString
:
:
from
(
name
)
variant
.
coerce
(
)
)
}
.
to_result
(
)
.
map_err
(
|
rv
|
Error
:
:
BindByName
{
rv
data_type
:
V
:
:
type_name
(
)
name
:
name
.
into
(
)
}
)
}
pub
fn
step
<
'
s
>
(
&
'
s
mut
self
)
-
>
Result
<
Option
<
Step
<
'
c
'
s
>
>
>
{
let
has_more
=
self
.
conn
.
call_and_wrap_error
(
DatabaseOp
:
:
Step
|
|
{
let
mut
has_more
=
false
;
unsafe
{
self
.
handle
.
ExecuteStep
(
&
mut
has_more
)
}
.
to_result
(
)
?
;
Ok
(
has_more
)
}
)
?
;
Ok
(
if
has_more
{
Some
(
Step
(
self
)
)
}
else
{
None
}
)
}
pub
fn
execute
(
&
mut
self
)
-
>
Result
<
(
)
>
{
self
.
conn
.
call_and_wrap_error
(
DatabaseOp
:
:
Execute
|
|
{
unsafe
{
self
.
handle
.
Execute
(
)
}
.
to_result
(
)
}
)
}
pub
fn
reset
(
&
mut
self
)
-
>
Result
<
(
)
>
{
unsafe
{
self
.
handle
.
Reset
(
)
}
.
to_result
(
)
?
;
Ok
(
(
)
)
}
fn
get_column_index
(
&
self
name
:
&
str
)
-
>
Result
<
u32
>
{
let
mut
index
=
0u32
;
let
rv
=
unsafe
{
self
.
handle
.
GetColumnIndex
(
&
*
nsCString
:
:
from
(
name
)
&
mut
index
)
}
;
if
rv
.
succeeded
(
)
{
Ok
(
index
)
}
else
{
Err
(
Error
:
:
InvalidColumn
{
rv
name
:
name
.
into
(
)
}
)
}
}
fn
get_column_value
<
T
:
VariantType
>
(
&
self
index
:
u32
)
-
>
result
:
:
Result
<
T
nsresult
>
{
let
variant
=
getter_addrefs
(
|
p
|
unsafe
{
self
.
handle
.
GetVariant
(
index
p
)
}
)
?
;
let
value
=
T
:
:
from_variant
(
variant
.
coerce
(
)
)
?
;
Ok
(
value
)
}
}
impl
<
'
c
>
Drop
for
Statement
<
'
c
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
handle
.
Finalize
(
)
}
;
}
}
pub
struct
Step
<
'
c
'
s
>
(
&
'
s
mut
Statement
<
'
c
>
)
;
impl
<
'
c
'
s
>
Step
<
'
c
'
s
>
{
pub
fn
get_by_index
<
T
:
VariantType
>
(
&
self
index
:
u32
)
-
>
Result
<
T
>
{
self
.
0
.
get_column_value
(
index
)
.
map_err
(
|
rv
|
Error
:
:
GetByIndex
{
rv
data_type
:
T
:
:
type_name
(
)
index
}
)
}
pub
fn
get_by_index_or_default
<
T
:
VariantType
+
Default
>
(
&
self
index
:
u32
)
-
>
T
{
self
.
get_by_index
(
index
)
.
unwrap_or_default
(
)
}
pub
fn
get_by_name
<
N
:
AsRef
<
str
>
T
:
VariantType
>
(
&
self
name
:
N
)
-
>
Result
<
T
>
{
let
name
=
name
.
as_ref
(
)
;
let
index
=
self
.
0
.
get_column_index
(
name
)
?
;
self
.
0
.
get_column_value
(
index
)
.
map_err
(
|
rv
|
Error
:
:
GetByName
{
rv
data_type
:
T
:
:
type_name
(
)
name
:
name
.
into
(
)
}
)
}
pub
fn
get_by_name_or_default
<
N
:
AsRef
<
str
>
T
:
VariantType
+
Default
>
(
&
self
name
:
N
)
-
>
T
{
self
.
get_by_name
(
name
)
.
unwrap_or_default
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
DatabaseOp
{
Exec
Prepare
Step
Execute
}
impl
DatabaseOp
{
pub
fn
what
(
&
self
)
-
>
&
'
static
str
{
match
self
{
DatabaseOp
:
:
Exec
=
>
"
execute
SQL
string
"
DatabaseOp
:
:
Prepare
=
>
"
prepare
statement
"
DatabaseOp
:
:
Step
=
>
"
step
statement
"
DatabaseOp
:
:
Execute
=
>
"
execute
statement
"
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
Error
{
NoThread
Limit
Database
{
rv
:
nsresult
op
:
DatabaseOp
code
:
i32
message
:
nsCString
}
BindByIndex
{
rv
:
nsresult
data_type
:
Cow
<
'
static
str
>
index
:
u32
}
BindByName
{
rv
:
nsresult
data_type
:
Cow
<
'
static
str
>
name
:
String
}
InvalidColumn
{
rv
:
nsresult
name
:
String
}
GetByIndex
{
rv
:
nsresult
data_type
:
Cow
<
'
static
str
>
index
:
u32
}
GetByName
{
rv
:
nsresult
data_type
:
Cow
<
'
static
str
>
name
:
String
}
Other
(
nsresult
)
}
impl
error
:
:
Error
for
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
None
}
}
impl
From
<
nsresult
>
for
Error
{
fn
from
(
rv
:
nsresult
)
-
>
Error
{
Error
:
:
Other
(
rv
)
}
}
impl
From
<
Error
>
for
nsresult
{
fn
from
(
err
:
Error
)
-
>
nsresult
{
match
err
{
Error
:
:
NoThread
=
>
NS_ERROR_NO_INTERFACE
Error
:
:
Limit
=
>
NS_ERROR_UNEXPECTED
Error
:
:
Database
{
rv
.
.
}
|
Error
:
:
BindByIndex
{
rv
.
.
}
|
Error
:
:
BindByName
{
rv
.
.
}
|
Error
:
:
InvalidColumn
{
rv
.
.
}
|
Error
:
:
GetByIndex
{
rv
.
.
}
|
Error
:
:
GetByName
{
rv
.
.
}
|
Error
:
:
Other
(
rv
)
=
>
rv
}
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
Error
:
:
NoThread
=
>
f
.
write_str
(
"
Async
thread
unavailable
for
storage
connection
"
)
Error
:
:
Limit
=
>
f
.
write_str
(
"
Failed
to
get
limit
for
storage
connection
"
)
Error
:
:
Database
{
op
code
message
.
.
}
=
>
{
if
message
.
is_empty
(
)
{
write
!
(
f
"
Failed
to
{
}
with
code
{
}
"
op
.
what
(
)
code
)
}
else
{
write
!
(
f
"
Failed
to
{
}
with
code
{
}
(
{
}
)
"
op
.
what
(
)
code
message
)
}
}
Error
:
:
BindByIndex
{
data_type
index
.
.
}
=
>
write
!
(
f
"
Can
'
t
bind
{
}
at
{
}
"
data_type
index
)
Error
:
:
BindByName
{
data_type
name
.
.
}
=
>
write
!
(
f
"
Can
'
t
bind
{
}
to
named
parameter
{
}
"
data_type
name
)
Error
:
:
InvalidColumn
{
name
.
.
}
=
>
write
!
(
f
"
Column
{
}
doesn
'
t
exist
"
name
)
Error
:
:
GetByIndex
{
data_type
index
.
.
}
=
>
write
!
(
f
"
Can
'
t
get
{
}
at
{
}
"
data_type
index
)
Error
:
:
GetByName
{
data_type
name
.
.
}
=
>
write
!
(
f
"
Can
'
t
get
{
}
for
column
{
}
"
data_type
name
)
Error
:
:
Other
(
rv
)
=
>
write
!
(
f
"
Storage
operation
failed
with
{
}
"
rv
.
error_name
(
)
)
}
}
}
