#
!
[
allow
(
non_snake_case
)
]
use
std
:
:
{
ops
:
:
Deref
result
}
;
use
nserror
:
:
{
nsresult
NS_ERROR_NO_INTERFACE
}
;
use
nsstring
:
:
nsCString
;
use
storage_variant
:
:
VariantType
;
use
xpcom
:
:
{
getter_addrefs
interfaces
:
:
{
mozIStorageAsyncConnection
mozIStorageConnection
mozIStorageStatement
nsIEventTarget
nsIThread
}
RefPtr
XpCom
}
;
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
nsresult
>
;
#
[
derive
(
Clone
)
]
pub
struct
Conn
{
handle
:
RefPtr
<
mozIStorageConnection
>
}
unsafe
impl
Send
for
Conn
{
}
unsafe
impl
Sync
for
Conn
{
}
impl
Conn
{
#
[
inline
]
pub
fn
wrap
(
connection
:
RefPtr
<
mozIStorageConnection
>
)
-
>
Conn
{
Conn
{
handle
:
connection
}
}
#
[
inline
]
pub
fn
connection
(
&
self
)
-
>
&
mozIStorageConnection
{
&
self
.
handle
}
pub
fn
thread
(
&
self
)
-
>
Result
<
RefPtr
<
nsIThread
>
>
{
let
target
=
self
.
handle
.
get_interface
:
:
<
nsIEventTarget
>
(
)
;
target
.
and_then
(
|
t
|
t
.
query_interface
:
:
<
nsIThread
>
(
)
)
.
ok_or
(
NS_ERROR_NO_INTERFACE
)
}
pub
fn
prepare
<
Q
:
AsRef
<
str
>
>
(
&
self
query
:
Q
)
-
>
Result
<
Statement
>
{
let
statement
=
getter_addrefs
(
|
p
|
unsafe
{
self
.
handle
.
CreateStatement
(
&
*
nsCString
:
:
from
(
query
.
as_ref
(
)
)
p
)
}
)
?
;
Ok
(
Statement
{
handle
:
statement
}
)
}
pub
fn
exec
<
Q
:
AsRef
<
str
>
>
(
&
self
query
:
Q
)
-
>
Result
<
(
)
>
{
unsafe
{
self
.
handle
.
ExecuteSimpleSQL
(
&
*
nsCString
:
:
from
(
query
.
as_ref
(
)
)
)
}
.
to_result
(
)
}
pub
fn
transaction
(
&
mut
self
)
-
>
Result
<
Transaction
>
{
let
behavior
=
self
.
get_default_transaction_behavior
(
)
;
Transaction
:
:
new
(
self
behavior
)
}
pub
fn
transaction_with_behavior
(
&
mut
self
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
>
{
Transaction
:
:
new
(
self
behavior
)
}
fn
get_default_transaction_behavior
(
&
self
)
-
>
TransactionBehavior
{
let
mut
typ
=
0i32
;
let
rv
=
unsafe
{
self
.
handle
.
GetDefaultTransactionType
(
&
mut
typ
)
}
;
if
rv
.
failed
(
)
{
return
TransactionBehavior
:
:
Deferred
;
}
match
typ
as
i64
{
mozIStorageAsyncConnection
:
:
TRANSACTION_IMMEDIATE
=
>
TransactionBehavior
:
:
Immediate
mozIStorageAsyncConnection
:
:
TRANSACTION_EXCLUSIVE
=
>
TransactionBehavior
:
:
Exclusive
_
=
>
TransactionBehavior
:
:
Deferred
}
}
}
pub
enum
TransactionBehavior
{
Deferred
Immediate
Exclusive
}
pub
struct
Transaction
<
'
c
>
{
conn
:
&
'
c
mut
Conn
active
:
bool
}
impl
<
'
c
>
Transaction
<
'
c
>
{
fn
new
(
conn
:
&
'
c
mut
Conn
behavior
:
TransactionBehavior
)
-
>
Result
<
Transaction
<
'
c
>
>
{
conn
.
exec
(
match
behavior
{
TransactionBehavior
:
:
Deferred
=
>
"
BEGIN
DEFERRED
"
TransactionBehavior
:
:
Immediate
=
>
"
BEGIN
IMMEDIATE
"
TransactionBehavior
:
:
Exclusive
=
>
"
BEGIN
EXCLUSIVE
"
}
)
?
;
Ok
(
Transaction
{
conn
active
:
true
}
)
}
pub
fn
commit
(
mut
self
)
-
>
Result
<
(
)
>
{
if
self
.
active
{
self
.
conn
.
exec
(
"
COMMIT
"
)
?
;
self
.
active
=
false
;
}
Ok
(
(
)
)
}
pub
fn
rollback
(
mut
self
)
-
>
Result
<
(
)
>
{
self
.
abort
(
)
}
fn
abort
(
&
mut
self
)
-
>
Result
<
(
)
>
{
if
self
.
active
{
self
.
conn
.
exec
(
"
ROLLBACK
"
)
?
;
self
.
active
=
false
;
}
Ok
(
(
)
)
}
}
impl
<
'
c
>
Deref
for
Transaction
<
'
c
>
{
type
Target
=
Conn
;
fn
deref
(
&
self
)
-
>
&
Conn
{
self
.
conn
}
}
impl
<
'
c
>
Drop
for
Transaction
<
'
c
>
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
abort
(
)
;
}
}
pub
struct
Statement
{
handle
:
RefPtr
<
mozIStorageStatement
>
}
impl
Statement
{
pub
fn
bind_by_index
<
V
:
VariantType
>
(
&
mut
self
index
:
u32
value
:
V
)
-
>
Result
<
(
)
>
{
let
variant
=
value
.
into_variant
(
)
;
unsafe
{
self
.
handle
.
BindByIndex
(
index
as
u32
variant
.
coerce
(
)
)
}
.
to_result
(
)
}
pub
fn
bind_by_name
<
N
:
AsRef
<
str
>
V
:
VariantType
>
(
&
mut
self
name
:
N
value
:
V
)
-
>
Result
<
(
)
>
{
let
variant
=
value
.
into_variant
(
)
;
unsafe
{
self
.
handle
.
BindByName
(
&
*
nsCString
:
:
from
(
name
.
as_ref
(
)
)
variant
.
coerce
(
)
)
}
.
to_result
(
)
}
pub
fn
step
<
'
a
>
(
&
'
a
mut
self
)
-
>
Result
<
Option
<
Step
<
'
a
>
>
>
{
let
mut
has_more
=
false
;
unsafe
{
self
.
handle
.
ExecuteStep
(
&
mut
has_more
)
}
.
to_result
(
)
?
;
Ok
(
if
has_more
{
Some
(
Step
(
self
)
)
}
else
{
None
}
)
}
pub
fn
execute
(
&
mut
self
)
-
>
Result
<
(
)
>
{
unsafe
{
self
.
handle
.
Execute
(
)
}
.
to_result
(
)
}
pub
fn
reset
(
&
mut
self
)
-
>
Result
<
(
)
>
{
unsafe
{
self
.
handle
.
Reset
(
)
}
.
to_result
(
)
}
fn
get_column_index
<
N
:
AsRef
<
str
>
>
(
&
self
name
:
N
)
-
>
Result
<
u32
>
{
let
mut
index
=
0u32
;
unsafe
{
self
.
handle
.
GetColumnIndex
(
&
*
nsCString
:
:
from
(
name
.
as_ref
(
)
)
&
mut
index
)
}
.
to_result
(
)
.
map
(
|
_
|
index
)
}
fn
get_variant
<
T
:
VariantType
>
(
&
self
index
:
u32
)
-
>
Result
<
T
>
{
let
variant
=
getter_addrefs
(
|
p
|
unsafe
{
self
.
handle
.
GetVariant
(
index
p
)
}
)
?
;
T
:
:
from_variant
(
variant
.
coerce
(
)
)
}
}
impl
Drop
for
Statement
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
handle
.
Finalize
(
)
}
;
}
}
pub
struct
Step
<
'
a
>
(
&
'
a
mut
Statement
)
;
impl
<
'
a
>
Step
<
'
a
>
{
pub
fn
get_by_index
<
'
s
T
:
VariantType
>
(
&
'
s
self
index
:
u32
)
-
>
Result
<
T
>
{
self
.
0
.
get_variant
(
index
)
}
pub
fn
get_by_index_or_default
<
'
s
T
:
VariantType
+
Default
>
(
&
'
s
self
index
:
u32
)
-
>
T
{
self
.
get_by_index
(
index
)
.
unwrap_or_default
(
)
}
pub
fn
get_by_name
<
'
s
N
:
AsRef
<
str
>
T
:
VariantType
>
(
&
'
s
self
name
:
N
)
-
>
Result
<
T
>
{
let
index
=
self
.
0
.
get_column_index
(
name
)
?
;
self
.
0
.
get_variant
(
index
)
}
pub
fn
get_by_name_or_default
<
'
s
N
:
AsRef
<
str
>
T
:
VariantType
+
Default
>
(
&
'
s
self
name
:
N
)
-
>
T
{
self
.
get_by_name
(
name
)
.
unwrap_or_default
(
)
}
}
