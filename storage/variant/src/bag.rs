use
nserror
:
:
{
nsresult
NS_ERROR_CANNOT_CONVERT_DATA
NS_OK
}
;
use
nsstring
:
:
nsString
;
use
xpcom
:
:
{
getter_addrefs
interfaces
:
:
{
nsIProperty
nsIPropertyBag
nsIWritablePropertyBag
}
RefPtr
XpCom
}
;
use
crate
:
:
{
NsIVariantExt
VariantType
}
;
extern
"
C
"
{
fn
NS_NewHashPropertyBag
(
bag
:
*
mut
*
const
nsIWritablePropertyBag
)
;
}
pub
struct
HashPropertyBag
(
RefPtr
<
nsIWritablePropertyBag
>
)
;
unsafe
impl
Send
for
HashPropertyBag
{
}
unsafe
impl
Sync
for
HashPropertyBag
{
}
impl
Default
for
HashPropertyBag
{
fn
default
(
)
-
>
HashPropertyBag
{
let
bag
=
getter_addrefs
(
|
p
|
{
unsafe
{
NS_NewHashPropertyBag
(
p
)
}
;
NS_OK
}
)
.
unwrap
(
)
;
HashPropertyBag
(
bag
)
}
}
impl
HashPropertyBag
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
clone_from_bag
(
source
:
&
nsIPropertyBag
)
-
>
Result
<
Self
nsresult
>
{
let
enumerator
=
getter_addrefs
(
|
p
|
unsafe
{
source
.
GetEnumerator
(
p
)
}
)
?
;
let
b
=
HashPropertyBag
:
:
new
(
)
;
while
{
let
mut
has_more
=
false
;
unsafe
{
enumerator
.
HasMoreElements
(
&
mut
has_more
)
}
.
to_result
(
)
?
;
has_more
}
{
let
element
=
getter_addrefs
(
|
p
|
unsafe
{
enumerator
.
GetNext
(
p
)
}
)
?
;
let
property
=
element
.
query_interface
:
:
<
nsIProperty
>
(
)
.
ok_or
(
NS_ERROR_CANNOT_CONVERT_DATA
)
?
;
let
mut
name
=
nsString
:
:
new
(
)
;
unsafe
{
property
.
GetName
(
&
mut
*
name
)
}
.
to_result
(
)
?
;
let
value
=
getter_addrefs
(
|
p
|
unsafe
{
property
.
GetValue
(
p
)
}
)
?
;
unsafe
{
b
.
0
.
SetProperty
(
&
*
name
value
.
try_clone
(
)
?
.
coerce
(
)
)
}
.
to_result
(
)
?
;
}
Ok
(
b
)
}
pub
fn
get
<
K
V
>
(
&
self
name
:
K
)
-
>
Result
<
V
nsresult
>
where
K
:
AsRef
<
str
>
V
:
VariantType
{
getter_addrefs
(
|
p
|
unsafe
{
self
.
0
.
GetProperty
(
&
*
nsString
:
:
from
(
name
.
as_ref
(
)
)
p
)
}
)
.
and_then
(
|
v
|
V
:
:
from_variant
(
v
.
coerce
(
)
)
)
}
#
[
inline
]
pub
fn
get_or_default
<
K
V
>
(
&
self
name
:
K
)
-
>
V
where
K
:
AsRef
<
str
>
V
:
VariantType
+
Default
{
self
.
get
(
name
)
.
unwrap_or_default
(
)
}
pub
fn
set
<
K
V
>
(
&
mut
self
name
:
K
value
:
V
)
where
K
:
AsRef
<
str
>
V
:
VariantType
{
let
v
=
value
.
into_variant
(
)
;
unsafe
{
self
.
0
.
SetProperty
(
&
*
nsString
:
:
from
(
name
.
as_ref
(
)
)
v
.
coerce
(
)
)
.
to_result
(
)
.
unwrap
(
)
}
}
pub
fn
delete
(
&
mut
self
name
:
impl
AsRef
<
str
>
)
-
>
bool
{
unsafe
{
self
.
0
.
DeleteProperty
(
&
*
nsString
:
:
from
(
name
.
as_ref
(
)
)
)
.
to_result
(
)
.
is_ok
(
)
}
}
#
[
inline
]
pub
fn
bag
(
&
self
)
-
>
&
nsIWritablePropertyBag
{
&
self
.
0
}
}
