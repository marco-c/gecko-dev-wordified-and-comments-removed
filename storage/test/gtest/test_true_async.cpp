#
include
"
storage_test_harness
.
h
"
TEST
(
storage_true_async
TrueAsyncStatement
)
{
HookSqliteMutex
hook
;
nsCOMPtr
<
mozIStorageConnection
>
db
(
getMemoryDatabase
(
)
)
;
watch_for_mutex_use_on_this_thread
(
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
db
-
>
CreateAsyncStatement
(
"
CREATE
TABLE
test
(
id
INTEGER
PRIMARY
KEY
)
"
_ns
getter_AddRefs
(
stmt
)
)
;
blocking_async_execute
(
stmt
)
;
stmt
-
>
Finalize
(
)
;
do_check_false
(
mutex_used_on_watched_thread
)
;
db
-
>
CreateAsyncStatement
(
"
INSERT
INTO
test
(
id
)
VALUES
(
?
)
"
_ns
getter_AddRefs
(
stmt
)
)
;
stmt
-
>
BindInt32ByIndex
(
0
1
)
;
blocking_async_execute
(
stmt
)
;
stmt
-
>
Finalize
(
)
;
do_check_false
(
mutex_used_on_watched_thread
)
;
db
-
>
CreateAsyncStatement
(
"
INSERT
INTO
test
(
id
)
VALUES
(
:
id
)
"
_ns
getter_AddRefs
(
stmt
)
)
;
nsCOMPtr
<
mozIStorageBindingParamsArray
>
paramsArray
;
stmt
-
>
NewBindingParamsArray
(
getter_AddRefs
(
paramsArray
)
)
;
nsCOMPtr
<
mozIStorageBindingParams
>
params
;
paramsArray
-
>
NewBindingParams
(
getter_AddRefs
(
params
)
)
;
params
-
>
BindInt32ByName
(
"
id
"
_ns
2
)
;
paramsArray
-
>
AddParams
(
params
)
;
params
=
nullptr
;
stmt
-
>
BindParameters
(
paramsArray
)
;
paramsArray
=
nullptr
;
blocking_async_execute
(
stmt
)
;
stmt
-
>
Finalize
(
)
;
do_check_false
(
mutex_used_on_watched_thread
)
;
nsCOMPtr
<
mozIStorageStatement
>
syncStmt
;
db
-
>
CreateStatement
(
"
SELECT
*
FROM
test
"
_ns
getter_AddRefs
(
syncStmt
)
)
;
syncStmt
-
>
Finalize
(
)
;
do_check_true
(
mutex_used_on_watched_thread
)
;
blocking_async_close
(
db
)
;
}
TEST
(
storage_true_async
AsyncCancellation
)
{
HookSqliteMutex
hook
;
nsCOMPtr
<
mozIStorageConnection
>
db
(
getMemoryDatabase
(
)
)
;
nsCOMPtr
<
nsIThread
>
target
(
get_conn_async_thread
(
db
)
)
;
do_check_true
(
target
)
;
RefPtr
<
ThreadWedger
>
wedger
(
new
ThreadWedger
(
target
)
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
asyncStmt
;
db
-
>
CreateAsyncStatement
(
"
CREATE
TABLE
asyncTable
(
id
INTEGER
PRIMARY
KEY
)
"
_ns
getter_AddRefs
(
asyncStmt
)
)
;
RefPtr
<
AsyncStatementSpinner
>
asyncSpin
(
new
AsyncStatementSpinner
(
)
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
asyncPend
;
(
void
)
asyncStmt
-
>
ExecuteAsync
(
asyncSpin
getter_AddRefs
(
asyncPend
)
)
;
do_check_true
(
asyncPend
)
;
asyncPend
-
>
Cancel
(
)
;
nsCOMPtr
<
mozIStorageStatement
>
syncStmt
;
db
-
>
CreateStatement
(
"
CREATE
TABLE
syncTable
(
id
INTEGER
PRIMARY
KEY
)
"
_ns
getter_AddRefs
(
syncStmt
)
)
;
RefPtr
<
AsyncStatementSpinner
>
syncSpin
(
new
AsyncStatementSpinner
(
)
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
syncPend
;
(
void
)
syncStmt
-
>
ExecuteAsync
(
syncSpin
getter_AddRefs
(
syncPend
)
)
;
do_check_true
(
syncPend
)
;
syncPend
-
>
Cancel
(
)
;
wedger
-
>
unwedge
(
)
;
asyncSpin
-
>
SpinUntilCompleted
(
)
;
do_check_true
(
asyncSpin
-
>
completionReason
=
=
mozIStorageStatementCallback
:
:
REASON_CANCELED
)
;
syncSpin
-
>
SpinUntilCompleted
(
)
;
do_check_true
(
syncSpin
-
>
completionReason
=
=
mozIStorageStatementCallback
:
:
REASON_CANCELED
)
;
nsresult
rv
;
bool
exists
;
rv
=
db
-
>
TableExists
(
"
asyncTable
"
_ns
&
exists
)
;
do_check_true
(
rv
=
=
NS_OK
)
;
do_check_false
(
exists
)
;
rv
=
db
-
>
TableExists
(
"
syncTable
"
_ns
&
exists
)
;
do_check_true
(
rv
=
=
NS_OK
)
;
do_check_false
(
exists
)
;
asyncStmt
-
>
Finalize
(
)
;
syncStmt
-
>
Finalize
(
)
;
blocking_async_close
(
db
)
;
}
TEST
(
storage_true_async
AsyncDestructorFinalizesOnAsyncThread
)
{
HookSqliteMutex
hook
;
nsCOMPtr
<
mozIStorageConnection
>
db
(
getMemoryDatabase
(
)
)
;
watch_for_mutex_use_on_this_thread
(
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
db
-
>
CreateAsyncStatement
(
"
CREATE
TABLE
test
(
id
INTEGER
PRIMARY
KEY
)
"
_ns
getter_AddRefs
(
stmt
)
)
;
blocking_async_execute
(
stmt
)
;
do_check_false
(
mutex_used_on_watched_thread
)
;
stmt
=
nullptr
;
do_check_false
(
mutex_used_on_watched_thread
)
;
blocking_async_close
(
db
)
;
}
