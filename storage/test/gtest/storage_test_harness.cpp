#
ifndef
storage_test_harness_
#
define
storage_test_harness_
#
include
"
storage_test_harness
.
h
"
already_AddRefed
<
mozIStorageService
>
getService
(
)
{
nsCOMPtr
<
mozIStorageService
>
ss
=
do_CreateInstance
(
"
mozilla
.
org
/
storage
/
service
;
1
"
)
;
do_check_true
(
ss
)
;
return
ss
.
forget
(
)
;
}
already_AddRefed
<
mozIStorageConnection
>
getMemoryDatabase
(
)
{
nsCOMPtr
<
mozIStorageService
>
ss
=
getService
(
)
;
nsCOMPtr
<
mozIStorageConnection
>
conn
;
nsresult
rv
=
ss
-
>
OpenSpecialDatabase
(
kMozStorageMemoryStorageKey
VoidCString
(
)
mozIStorageService
:
:
CONNECTION_DEFAULT
getter_AddRefs
(
conn
)
)
;
do_check_success
(
rv
)
;
return
conn
.
forget
(
)
;
}
already_AddRefed
<
mozIStorageConnection
>
getDatabase
(
nsIFile
*
aDBFile
uint32_t
aConnectionFlags
)
{
nsCOMPtr
<
nsIFile
>
dbFile
;
nsresult
rv
;
if
(
!
aDBFile
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
Can
'
t
get
tmp
dir
off
mainthread
.
"
)
;
(
void
)
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
dbFile
)
)
;
NS_ASSERTION
(
dbFile
"
The
directory
doesn
'
t
exists
?
!
"
)
;
rv
=
dbFile
-
>
Append
(
u
"
storage_test_db
.
sqlite
"
_ns
)
;
do_check_success
(
rv
)
;
}
else
{
dbFile
=
aDBFile
;
}
nsCOMPtr
<
mozIStorageService
>
ss
=
getService
(
)
;
nsCOMPtr
<
mozIStorageConnection
>
conn
;
rv
=
ss
-
>
OpenDatabase
(
dbFile
aConnectionFlags
getter_AddRefs
(
conn
)
)
;
do_check_success
(
rv
)
;
return
conn
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS
(
AsyncStatementSpinner
mozIStorageStatementCallback
mozIStorageCompletionCallback
)
AsyncStatementSpinner
:
:
AsyncStatementSpinner
(
)
:
completionReason
(
0
)
mCompleted
(
false
)
{
}
NS_IMETHODIMP
AsyncStatementSpinner
:
:
HandleResult
(
mozIStorageResultSet
*
aResultSet
)
{
return
NS_OK
;
}
NS_IMETHODIMP
AsyncStatementSpinner
:
:
HandleError
(
mozIStorageError
*
aError
)
{
int32_t
result
;
nsresult
rv
=
aError
-
>
GetResult
(
&
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
message
;
rv
=
aError
-
>
GetMessage
(
message
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
warnMsg
;
warnMsg
.
AppendLiteral
(
"
An
error
occurred
while
executing
an
async
statement
:
"
)
;
warnMsg
.
AppendInt
(
result
)
;
warnMsg
.
Append
(
'
'
)
;
warnMsg
.
Append
(
message
)
;
NS_WARNING
(
warnMsg
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AsyncStatementSpinner
:
:
HandleCompletion
(
uint16_t
aReason
)
{
completionReason
=
aReason
;
mCompleted
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
AsyncStatementSpinner
:
:
Complete
(
nsresult
nsISupports
*
)
{
mCompleted
=
true
;
return
NS_OK
;
}
void
AsyncStatementSpinner
:
:
SpinUntilCompleted
(
)
{
nsCOMPtr
<
nsIThread
>
thread
(
:
:
do_GetCurrentThread
(
)
)
;
nsresult
rv
=
NS_OK
;
bool
processed
=
true
;
while
(
!
mCompleted
&
&
NS_SUCCEEDED
(
rv
)
)
{
rv
=
thread
-
>
ProcessNextEvent
(
true
&
processed
)
;
}
}
#
define
NS_DECL_ASYNCSTATEMENTSPINNER
\
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
aResultSet
)
override
;
NS_IMPL_ISUPPORTS
(
AsyncCompletionSpinner
mozIStorageCompletionCallback
)
AsyncCompletionSpinner
:
:
AsyncCompletionSpinner
(
)
:
mCompletionReason
(
NS_OK
)
mCompleted
(
false
)
{
}
NS_IMETHODIMP
AsyncCompletionSpinner
:
:
Complete
(
nsresult
reason
nsISupports
*
value
)
{
mCompleted
=
true
;
mCompletionReason
=
reason
;
mCompletionValue
=
value
;
return
NS_OK
;
}
void
AsyncCompletionSpinner
:
:
SpinUntilCompleted
(
)
{
nsCOMPtr
<
nsIThread
>
thread
(
:
:
do_GetCurrentThread
(
)
)
;
nsresult
rv
=
NS_OK
;
bool
processed
=
true
;
while
(
!
mCompleted
&
&
NS_SUCCEEDED
(
rv
)
)
{
rv
=
thread
-
>
ProcessNextEvent
(
true
&
processed
)
;
}
}
void
blocking_async_execute
(
mozIStorageBaseStatement
*
stmt
)
{
RefPtr
<
AsyncStatementSpinner
>
spinner
(
new
AsyncStatementSpinner
(
)
)
;
nsCOMPtr
<
mozIStoragePendingStatement
>
pendy
;
(
void
)
stmt
-
>
ExecuteAsync
(
spinner
getter_AddRefs
(
pendy
)
)
;
spinner
-
>
SpinUntilCompleted
(
)
;
}
void
blocking_async_close
(
mozIStorageConnection
*
db
)
{
RefPtr
<
AsyncStatementSpinner
>
spinner
(
new
AsyncStatementSpinner
(
)
)
;
db
-
>
AsyncClose
(
spinner
)
;
spinner
-
>
SpinUntilCompleted
(
)
;
}
sqlite3_mutex_methods
orig_mutex_methods
;
sqlite3_mutex_methods
wrapped_mutex_methods
;
bool
mutex_used_on_watched_thread
=
false
;
PRThread
*
watched_thread
=
nullptr
;
nsIThread
*
last_non_watched_thread
=
nullptr
;
extern
"
C
"
void
wrapped_MutexEnter
(
sqlite3_mutex
*
mutex
)
{
if
(
PR_GetCurrentThread
(
)
=
=
watched_thread
)
{
mutex_used_on_watched_thread
=
true
;
}
else
{
last_non_watched_thread
=
NS_GetCurrentThread
(
)
;
}
orig_mutex_methods
.
xMutexEnter
(
mutex
)
;
}
extern
"
C
"
int
wrapped_MutexTry
(
sqlite3_mutex
*
mutex
)
{
if
(
:
:
PR_GetCurrentThread
(
)
=
=
watched_thread
)
{
mutex_used_on_watched_thread
=
true
;
}
return
orig_mutex_methods
.
xMutexTry
(
mutex
)
;
}
void
watch_for_mutex_use_on_this_thread
(
)
{
watched_thread
=
:
:
PR_GetCurrentThread
(
)
;
mutex_used_on_watched_thread
=
false
;
}
already_AddRefed
<
nsIThread
>
get_conn_async_thread
(
mozIStorageConnection
*
db
)
{
watch_for_mutex_use_on_this_thread
(
)
;
nsCOMPtr
<
mozIStorageAsyncStatement
>
stmt
;
db
-
>
CreateAsyncStatement
(
"
SELECT
1
"
_ns
getter_AddRefs
(
stmt
)
)
;
blocking_async_execute
(
stmt
)
;
stmt
-
>
Finalize
(
)
;
nsCOMPtr
<
nsIThread
>
asyncThread
=
last_non_watched_thread
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetInterface
(
db
)
;
nsCOMPtr
<
nsIThread
>
allegedAsyncThread
=
do_QueryInterface
(
target
)
;
do_check_eq
(
allegedAsyncThread
asyncThread
)
;
return
asyncThread
.
forget
(
)
;
}
#
endif
