#
ifndef
storage_test_harness_h__
#
define
storage_test_harness_h__
#
include
"
gtest
/
gtest
.
h
"
#
include
"
prthread
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozIStorageService
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozIStorageStatementCallback
.
h
"
#
include
"
mozIStorageCompletionCallback
.
h
"
#
include
"
mozIStorageBindingParamsArray
.
h
"
#
include
"
mozIStorageBindingParams
.
h
"
#
include
"
mozIStorageAsyncStatement
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozIStoragePendingStatement
.
h
"
#
include
"
mozIStorageError
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
sqlite3
.
h
"
#
define
do_check_true
(
aCondition
)
EXPECT_TRUE
(
aCondition
)
#
define
do_check_false
(
aCondition
)
EXPECT_FALSE
(
aCondition
)
#
define
do_check_success
(
aResult
)
do_check_true
(
NS_SUCCEEDED
(
aResult
)
)
#
define
do_check_eq
(
aExpected
aActual
)
do_check_true
(
aExpected
=
=
aActual
)
#
define
do_check_ok
(
aInvoc
)
do_check_true
(
(
aInvoc
)
=
=
SQLITE_OK
)
already_AddRefed
<
mozIStorageService
>
getService
(
)
;
already_AddRefed
<
mozIStorageConnection
>
getMemoryDatabase
(
)
;
already_AddRefed
<
mozIStorageConnection
>
getDatabase
(
nsIFile
*
aDBFile
=
nullptr
uint32_t
aConnectionFlags
=
mozIStorageService
:
:
CONNECTION_DEFAULT
)
;
class
AsyncStatementSpinner
:
public
mozIStorageStatementCallback
public
mozIStorageCompletionCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGESTATEMENTCALLBACK
NS_DECL_MOZISTORAGECOMPLETIONCALLBACK
AsyncStatementSpinner
(
)
;
void
SpinUntilCompleted
(
)
;
uint16_t
completionReason
;
protected
:
virtual
~
AsyncStatementSpinner
(
)
{
}
volatile
bool
mCompleted
;
}
;
#
define
NS_DECL_ASYNCSTATEMENTSPINNER
\
NS_IMETHOD
HandleResult
(
mozIStorageResultSet
*
aResultSet
)
override
;
void
blocking_async_execute
(
mozIStorageBaseStatement
*
stmt
)
;
void
blocking_async_close
(
mozIStorageConnection
*
db
)
;
extern
sqlite3_mutex_methods
orig_mutex_methods
;
extern
sqlite3_mutex_methods
wrapped_mutex_methods
;
extern
bool
mutex_used_on_watched_thread
;
extern
PRThread
*
watched_thread
;
extern
nsIThread
*
last_non_watched_thread
;
extern
"
C
"
void
wrapped_MutexEnter
(
sqlite3_mutex
*
mutex
)
;
extern
"
C
"
int
wrapped_MutexTry
(
sqlite3_mutex
*
mutex
)
;
class
HookSqliteMutex
{
public
:
HookSqliteMutex
(
)
{
do_check_ok
(
sqlite3_initialize
(
)
)
;
do_check_ok
(
sqlite3_shutdown
(
)
)
;
do_check_ok
(
:
:
sqlite3_config
(
SQLITE_CONFIG_GETMUTEX
&
orig_mutex_methods
)
)
;
do_check_ok
(
:
:
sqlite3_config
(
SQLITE_CONFIG_GETMUTEX
&
wrapped_mutex_methods
)
)
;
wrapped_mutex_methods
.
xMutexEnter
=
wrapped_MutexEnter
;
wrapped_mutex_methods
.
xMutexTry
=
wrapped_MutexTry
;
do_check_ok
(
:
:
sqlite3_config
(
SQLITE_CONFIG_MUTEX
&
wrapped_mutex_methods
)
)
;
}
~
HookSqliteMutex
(
)
{
do_check_ok
(
sqlite3_shutdown
(
)
)
;
do_check_ok
(
:
:
sqlite3_config
(
SQLITE_CONFIG_MUTEX
&
orig_mutex_methods
)
)
;
do_check_ok
(
sqlite3_initialize
(
)
)
;
}
}
;
void
watch_for_mutex_use_on_this_thread
(
)
;
class
ThreadWedger
:
public
mozilla
:
:
Runnable
{
public
:
explicit
ThreadWedger
(
nsIEventTarget
*
aTarget
)
:
mozilla
:
:
Runnable
(
"
ThreadWedger
"
)
mReentrantMonitor
(
"
thread
wedger
"
)
unwedged
(
false
)
{
aTarget
-
>
Dispatch
(
this
aTarget
-
>
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
ReentrantMonitorAutoEnter
automon
(
mReentrantMonitor
)
;
if
(
!
unwedged
)
automon
.
Wait
(
)
;
return
NS_OK
;
}
void
unwedge
(
)
{
mozilla
:
:
ReentrantMonitorAutoEnter
automon
(
mReentrantMonitor
)
;
unwedged
=
true
;
automon
.
Notify
(
)
;
}
private
:
mozilla
:
:
ReentrantMonitor
mReentrantMonitor
MOZ_UNANNOTATED
;
bool
unwedged
;
}
;
already_AddRefed
<
nsIThread
>
get_conn_async_thread
(
mozIStorageConnection
*
db
)
;
#
endif
