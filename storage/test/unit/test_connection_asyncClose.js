add_task
(
function
*
test_asyncClose_does_not_complete_before_statements
(
)
{
let
db
=
getService
(
)
.
openDatabase
(
getTestDB
(
)
)
;
let
stmt
=
db
.
createStatement
(
"
SELECT
*
FROM
sqlite_master
"
)
;
let
asyncStatementPromise
=
executeAsync
(
stmt
)
;
stmt
.
finalize
(
)
;
yield
asyncClose
(
db
)
;
equal
(
(
yield
asyncStatementPromise
)
Ci
.
mozIStorageStatementCallback
.
REASON_FINISHED
)
;
}
)
;
add_task
(
function
test_double_asyncClose_throws
(
)
{
let
db
=
yield
openAsyncDatabase
(
getTestDB
(
)
)
;
let
realClosePromise
=
yield
asyncClose
(
db
)
;
try
{
db
.
asyncClose
(
)
;
ok
(
false
"
should
have
thrown
"
)
;
}
catch
(
e
)
{
equal
(
e
.
result
Cr
.
NS_ERROR_NOT_INITIALIZED
)
;
}
yield
realClosePromise
;
}
)
;
add_task
(
function
*
test_asyncClose_on_sync_db
(
)
{
let
db
=
getService
(
)
.
openDatabase
(
getTestDB
(
)
)
;
yield
asyncClose
(
db
)
;
ok
(
true
'
closed
sync
connection
asynchronously
'
)
;
}
)
;
add_task
(
function
*
test_asyncClose_failed_open
(
)
{
let
openPromise
=
openAsyncDatabase
(
getFakeDB
(
)
)
;
yield
openPromise
.
then
(
(
)
=
>
{
ok
(
false
'
we
should
have
failed
to
open
the
db
;
this
test
is
broken
!
'
)
;
}
(
)
=
>
{
ok
(
true
'
correctly
failed
to
open
db
;
bg
asyncClose
should
happen
'
)
;
}
)
;
}
)
;
add_task
(
function
test_asyncClose_does_not_throw_without_callback
(
)
{
let
db
=
yield
openAsyncDatabase
(
getTestDB
(
)
)
;
db
.
asyncClose
(
)
;
ok
(
true
'
if
we
shutdown
cleanly
and
do
not
crash
then
we
succeeded
'
)
;
}
)
;
