"
use
strict
"
;
const
BACKUP_FILE_NAME
=
"
test_storage
.
sqlite
.
backup
"
;
const
TEST_ROWS
=
10
;
const
TEST_PAGE_SIZE
=
512
;
add_setup
(
async
(
)
=
>
{
let
conn
=
await
openAsyncDatabase
(
getTestDB
(
)
)
;
Assert
.
notEqual
(
conn
.
defaultPageSize
TEST_PAGE_SIZE
"
Should
not
default
to
having
the
TEST_PAGE_SIZE
"
)
;
await
executeSimpleSQLAsync
(
conn
"
PRAGMA
page_size
=
"
+
TEST_PAGE_SIZE
)
;
let
createStmt
=
conn
.
createAsyncStatement
(
"
CREATE
TABLE
test
(
name
TEXT
)
"
)
;
await
executeAsync
(
createStmt
)
;
createStmt
.
finalize
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
asyncClose
(
conn
)
;
}
)
;
}
)
;
async
function
prepareSourceDatabase
(
connection
)
{
await
executeSimpleSQLAsync
(
connection
"
DELETE
from
test
"
)
;
for
(
let
i
=
0
;
i
<
TEST_ROWS
;
+
+
i
)
{
let
name
=
Database
row
#
{
i
}
;
let
stmt
=
connection
.
createAsyncStatement
(
"
INSERT
INTO
test
(
name
)
VALUES
(
:
name
)
"
)
;
stmt
.
params
.
name
=
name
;
let
result
=
await
executeAsync
(
stmt
)
;
stmt
.
finalize
(
)
;
Assert
.
ok
(
Components
.
isSuccessCode
(
result
)
Inserted
test
row
#
{
i
}
)
;
}
}
async
function
getPreparedAsyncDatabase
(
)
{
let
connection
=
await
openAsyncDatabase
(
getTestDB
(
)
)
;
await
prepareSourceDatabase
(
connection
)
;
return
connection
;
}
async
function
createCopy
(
connection
pagesPerStep
stepDelayMs
)
{
let
destFilePath
=
PathUtils
.
join
(
PathUtils
.
profileDir
BACKUP_FILE_NAME
)
;
let
destFile
=
await
IOUtils
.
getFile
(
destFilePath
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
destFilePath
)
)
"
Backup
file
shouldn
'
t
exist
yet
.
"
)
;
await
new
Promise
(
resolve
=
>
{
connection
.
backupToFileAsync
(
destFile
result
=
>
{
Assert
.
ok
(
Components
.
isSuccessCode
(
result
)
)
;
resolve
(
result
)
;
}
pagesPerStep
stepDelayMs
)
;
}
)
;
return
destFile
;
}
async
function
assertSuccessfulCopy
(
file
expectedEntries
=
TEST_ROWS
)
{
let
conn
=
await
openAsyncDatabase
(
file
)
;
await
executeSimpleSQLAsync
(
conn
"
PRAGMA
page_size
"
resultSet
=
>
{
let
result
=
resultSet
.
getNextRow
(
)
;
Assert
.
equal
(
TEST_PAGE_SIZE
result
.
getResultByIndex
(
0
)
)
;
}
)
;
let
stmt
=
conn
.
createAsyncStatement
(
"
SELECT
COUNT
(
*
)
FROM
test
"
)
;
let
results
=
await
new
Promise
(
resolve
=
>
{
executeAsync
(
stmt
resolve
)
;
}
)
;
stmt
.
finalize
(
)
;
let
row
=
results
.
getNextRow
(
)
;
let
count
=
row
.
getResultByName
(
"
COUNT
(
*
)
"
)
;
Assert
.
equal
(
count
expectedEntries
"
Got
the
expected
entries
"
)
;
Assert
.
ok
(
!
file
.
leafName
.
endsWith
(
"
.
tmp
"
)
"
Should
not
end
in
.
tmp
extension
"
)
;
await
asyncClose
(
conn
)
;
}
add_task
(
async
function
test_backupToFileAsync
(
)
{
let
newConnection
=
await
getPreparedAsyncDatabase
(
)
;
let
copyFile
=
await
createCopy
(
newConnection
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copyFile
.
path
)
"
A
new
file
was
created
by
backupToFileAsync
"
)
;
await
assertSuccessfulCopy
(
copyFile
)
;
await
IOUtils
.
remove
(
copyFile
.
path
)
;
await
asyncClose
(
newConnection
)
;
}
)
;
add_task
(
async
function
test_backupToFileAsync_during_insert
(
)
{
let
newConnection
=
await
getPreparedAsyncDatabase
(
)
;
const
NEW_ENTRIES
=
5
;
let
copyFilePromise
=
createCopy
(
newConnection
)
;
let
inserts
=
[
]
;
for
(
let
i
=
0
;
i
<
NEW_ENTRIES
;
+
+
i
)
{
let
name
=
New
database
row
#
{
i
}
;
let
stmt
=
newConnection
.
createAsyncStatement
(
"
INSERT
INTO
test
(
name
)
VALUES
(
:
name
)
"
)
;
stmt
.
params
.
name
=
name
;
inserts
.
push
(
executeAsync
(
stmt
)
)
;
stmt
.
finalize
(
)
;
}
await
Promise
.
all
(
inserts
)
;
let
copyFile
=
await
copyFilePromise
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copyFile
.
path
)
"
A
new
file
was
created
by
backupToFileAsync
"
)
;
await
assertSuccessfulCopy
(
copyFile
TEST_ROWS
+
NEW_ENTRIES
)
;
await
IOUtils
.
remove
(
copyFile
.
path
)
;
await
asyncClose
(
newConnection
)
;
}
)
;
add_task
(
async
function
test_backupToFileAsync_during_insert
(
)
{
let
newConnection
=
await
getPreparedAsyncDatabase
(
)
;
let
copyFile
=
await
createCopy
(
newConnection
15
500
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copyFile
.
path
)
"
A
new
file
was
created
by
backupToFileAsync
"
)
;
await
assertSuccessfulCopy
(
copyFile
)
;
await
IOUtils
.
remove
(
copyFile
.
path
)
;
copyFile
=
await
createCopy
(
newConnection
1
25
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copyFile
.
path
)
"
A
new
file
was
created
by
backupToFileAsync
"
)
;
await
assertSuccessfulCopy
(
copyFile
)
;
await
IOUtils
.
remove
(
copyFile
.
path
)
;
await
asyncClose
(
newConnection
)
;
}
)
;
add_task
(
async
function
test_backupToFileAsync_via_Sqlite_module
(
)
{
let
xpcomConnection
=
await
getPreparedAsyncDatabase
(
)
;
let
moduleConnection
=
await
Sqlite
.
openConnection
(
{
path
:
xpcomConnection
.
databaseFile
.
path
}
)
;
let
copyFilePath
=
PathUtils
.
join
(
PathUtils
.
profileDir
BACKUP_FILE_NAME
)
;
await
moduleConnection
.
backup
(
copyFilePath
)
;
let
copyFile
=
await
IOUtils
.
getFile
(
copyFilePath
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copyFilePath
)
"
A
new
file
was
created
"
)
;
await
assertSuccessfulCopy
(
copyFile
)
;
await
IOUtils
.
remove
(
copyFile
.
path
)
;
await
moduleConnection
.
backup
(
copyFilePath
15
500
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copyFilePath
)
"
A
new
file
was
created
"
)
;
await
assertSuccessfulCopy
(
copyFile
)
;
await
IOUtils
.
remove
(
copyFile
.
path
)
;
await
moduleConnection
.
close
(
)
;
await
asyncClose
(
xpcomConnection
)
;
}
)
;
