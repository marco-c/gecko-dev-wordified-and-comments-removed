const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cr
=
Components
.
results
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
do_get_profile
(
)
;
var
gDBConn
=
null
;
function
getTestDB
(
)
{
var
db
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
db
.
append
(
"
test_storage
.
sqlite
"
)
;
return
db
;
}
function
getCorruptDB
(
)
{
return
do_get_file
(
"
corruptDB
.
sqlite
"
)
;
}
function
getFakeDB
(
)
{
return
do_get_file
(
"
fakeDB
.
sqlite
"
)
;
}
function
deleteTestDB
(
)
{
print
(
"
*
*
*
Storage
Tests
:
Trying
to
remove
file
!
"
)
;
var
dbFile
=
getTestDB
(
)
;
if
(
dbFile
.
exists
(
)
)
try
{
dbFile
.
remove
(
false
)
;
}
catch
(
e
)
{
}
}
function
cleanup
(
)
{
print
(
"
*
*
*
Storage
Tests
:
Trying
to
close
!
"
)
;
getOpenedDatabase
(
)
.
close
(
)
;
gDBConn
=
null
;
deleteTestDB
(
)
;
}
function
asyncCleanup
(
)
{
let
closed
=
false
;
print
(
"
*
*
*
Storage
Tests
:
Trying
to
asyncClose
!
"
)
;
getOpenedDatabase
(
)
.
asyncClose
(
function
(
)
{
closed
=
true
;
}
)
;
let
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
tm
.
spinEventLoopUntil
(
(
)
=
>
closed
)
;
gDBConn
=
null
;
deleteTestDB
(
)
;
}
function
getOpenedDatabase
(
)
{
if
(
!
gDBConn
)
{
gDBConn
=
Services
.
storage
.
openDatabase
(
getTestDB
(
)
)
;
}
return
gDBConn
;
}
function
getOpenedUnsharedDatabase
(
)
{
if
(
!
gDBConn
)
{
gDBConn
=
Services
.
storage
.
openUnsharedDatabase
(
getTestDB
(
)
)
;
}
return
gDBConn
;
}
function
getDatabase
(
aFile
)
{
return
Services
.
storage
.
openDatabase
(
aFile
)
;
}
function
createStatement
(
aSQL
)
{
return
getOpenedDatabase
(
)
.
createStatement
(
aSQL
)
;
}
function
createAsyncStatement
(
aSQL
)
{
return
getOpenedDatabase
(
)
.
createAsyncStatement
(
aSQL
)
;
}
function
expectError
(
aErrorCode
aFunction
)
{
let
exceptionCaught
=
false
;
try
{
aFunction
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
aErrorCode
)
{
do_throw
(
"
Got
an
exception
but
the
result
code
was
not
the
expected
"
+
"
one
.
Expected
"
+
aErrorCode
+
"
got
"
+
e
.
result
)
;
}
exceptionCaught
=
true
;
}
if
(
!
exceptionCaught
)
do_throw
(
aFunction
+
"
should
have
thrown
an
exception
but
did
not
!
"
)
;
}
function
verifyQuery
(
aSQLString
aBind
aResults
)
{
let
stmt
=
getOpenedDatabase
(
)
.
createStatement
(
aSQLString
)
;
stmt
.
bindByIndex
(
0
aBind
)
;
try
{
do_check_true
(
stmt
.
executeStep
(
)
)
;
let
nCols
=
stmt
.
numEntries
;
if
(
aResults
.
length
!
=
nCols
)
do_throw
(
"
Expected
"
+
aResults
.
length
+
"
columns
in
result
but
"
+
"
there
are
only
"
+
aResults
.
length
+
"
!
"
)
;
for
(
let
iCol
=
0
;
iCol
<
nCols
;
iCol
+
+
)
{
let
expectedVal
=
aResults
[
iCol
]
;
let
valType
=
stmt
.
getTypeOfIndex
(
iCol
)
;
if
(
expectedVal
=
=
=
null
)
{
do_check_eq
(
stmt
.
VALUE_TYPE_NULL
valType
)
;
do_check_true
(
stmt
.
getIsNull
(
iCol
)
)
;
}
else
if
(
typeof
expectedVal
=
=
"
number
"
)
{
if
(
Math
.
floor
(
expectedVal
)
=
=
expectedVal
)
{
do_check_eq
(
stmt
.
VALUE_TYPE_INTEGER
valType
)
;
do_check_eq
(
expectedVal
stmt
.
getInt32
(
iCol
)
)
;
}
else
{
do_check_eq
(
stmt
.
VALUE_TYPE_FLOAT
valType
)
;
do_check_eq
(
expectedVal
stmt
.
getDouble
(
iCol
)
)
;
}
}
else
if
(
typeof
expectedVal
=
=
"
string
"
)
{
do_check_eq
(
stmt
.
VALUE_TYPE_TEXT
valType
)
;
do_check_eq
(
expectedVal
stmt
.
getUTF8String
(
iCol
)
)
;
}
else
{
do_check_eq
(
stmt
.
VALUE_TYPE_BLOB
valType
)
;
let
count
=
{
value
:
0
}
blob
=
{
value
:
null
}
;
stmt
.
getBlob
(
iCol
count
blob
)
;
do_check_eq
(
count
.
value
expectedVal
.
length
)
;
for
(
let
i
=
0
;
i
<
count
.
value
;
i
+
+
)
{
do_check_eq
(
expectedVal
[
i
]
blob
.
value
[
i
]
)
;
}
}
}
}
finally
{
stmt
.
finalize
(
)
;
}
}
function
getTableRowCount
(
aTableName
)
{
var
currentRows
=
0
;
var
countStmt
=
getOpenedDatabase
(
)
.
createStatement
(
"
SELECT
COUNT
(
1
)
AS
count
FROM
"
+
aTableName
)
;
try
{
do_check_true
(
countStmt
.
executeStep
(
)
)
;
currentRows
=
countStmt
.
row
.
count
;
}
finally
{
countStmt
.
finalize
(
)
;
}
return
currentRows
;
}
function
asyncClone
(
db
readOnly
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
asyncClone
(
readOnly
function
(
status
db2
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
db2
)
;
}
else
{
reject
(
status
)
;
}
}
)
;
}
)
;
}
function
asyncClose
(
db
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
asyncClose
(
function
(
status
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
)
;
}
else
{
reject
(
status
)
;
}
}
)
;
}
)
;
}
function
openAsyncDatabase
(
file
options
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
properties
;
if
(
options
)
{
properties
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
for
(
let
k
in
options
)
{
properties
.
setProperty
(
k
options
[
k
]
)
;
}
}
Services
.
storage
.
openAsyncDatabase
(
file
properties
function
(
status
db
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
db
.
QueryInterface
(
Ci
.
mozIStorageAsyncConnection
)
)
;
}
else
{
reject
(
status
)
;
}
}
)
;
}
)
;
}
function
executeAsync
(
statement
onResult
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
statement
.
executeAsync
(
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
if
(
onResult
)
{
onResult
(
result
)
;
}
}
handleCompletion
(
result
)
{
resolve
(
result
)
;
}
}
)
;
}
)
;
}
function
executeMultipleStatementsAsync
(
db
statements
onResult
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
executeAsync
(
statements
statements
.
length
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
if
(
onResult
)
{
onResult
(
result
)
;
}
}
handleCompletion
(
result
)
{
resolve
(
result
)
;
}
}
)
;
}
)
;
}
function
executeSimpleSQLAsync
(
db
query
onResult
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
executeSimpleSQLAsync
(
query
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
if
(
onResult
)
{
onResult
(
result
)
;
}
else
{
do_throw
(
"
No
results
were
expected
"
)
;
}
}
handleCompletion
(
result
)
{
resolve
(
result
)
;
}
}
)
;
}
)
;
}
cleanup
(
)
;
