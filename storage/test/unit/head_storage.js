var
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
var
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
}
)
;
const
OPEN_HISTOGRAM
=
"
SQLITE_STORE_OPEN
"
;
const
QUERY_HISTOGRAM
=
"
SQLITE_STORE_QUERY
"
;
const
TELEMETRY_VALUES
=
{
success
:
0
failure
:
1
access
:
2
diskio
:
3
corrupt
:
4
busy
:
5
misuse
:
6
diskspace
:
7
}
;
do_get_profile
(
)
;
var
gDBConn
=
null
;
const
TEST_DB_NAME
=
"
test_storage
.
sqlite
"
;
function
getTestDB
(
)
{
var
db
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
db
.
append
(
TEST_DB_NAME
)
;
return
db
;
}
function
getCorruptDB
(
)
{
return
do_get_file
(
"
corruptDB
.
sqlite
"
)
;
}
function
getFakeDB
(
)
{
return
do_get_file
(
"
fakeDB
.
sqlite
"
)
;
}
function
deleteTestDB
(
)
{
print
(
"
*
*
*
Storage
Tests
:
Trying
to
remove
file
!
"
)
;
var
dbFile
=
getTestDB
(
)
;
if
(
dbFile
.
exists
(
)
)
{
try
{
dbFile
.
remove
(
false
)
;
}
catch
(
e
)
{
}
}
}
function
cleanup
(
)
{
print
(
"
*
*
*
Storage
Tests
:
Trying
to
close
!
"
)
;
getOpenedDatabase
(
)
.
close
(
)
;
gDBConn
=
null
;
deleteTestDB
(
)
;
}
function
asyncCleanup
(
)
{
let
closed
=
false
;
print
(
"
*
*
*
Storage
Tests
:
Trying
to
asyncClose
!
"
)
;
getOpenedDatabase
(
)
.
asyncClose
(
function
(
)
{
closed
=
true
;
}
)
;
let
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
tm
.
spinEventLoopUntil
(
"
Test
(
head_storage
.
js
:
asyncCleanup
)
"
(
)
=
>
closed
)
;
gDBConn
=
null
;
deleteTestDB
(
)
;
}
function
getOpenedDatabase
(
connectionFlags
=
0
)
{
if
(
!
gDBConn
)
{
gDBConn
=
Services
.
storage
.
openDatabase
(
getTestDB
(
)
connectionFlags
)
;
TelemetryTestUtils
.
getAndClearKeyedHistogram
(
OPEN_HISTOGRAM
)
;
TelemetryTestUtils
.
getAndClearKeyedHistogram
(
QUERY_HISTOGRAM
)
;
}
return
gDBConn
;
}
function
getOpenedUnsharedDatabase
(
)
{
if
(
!
gDBConn
)
{
gDBConn
=
Services
.
storage
.
openUnsharedDatabase
(
getTestDB
(
)
)
;
}
return
gDBConn
;
}
function
getDatabase
(
aFile
)
{
return
Services
.
storage
.
openDatabase
(
aFile
)
;
}
function
createStatement
(
aSQL
)
{
return
getOpenedDatabase
(
)
.
createStatement
(
aSQL
)
;
}
function
createAsyncStatement
(
aSQL
)
{
return
getOpenedDatabase
(
)
.
createAsyncStatement
(
aSQL
)
;
}
function
expectError
(
aErrorCode
aFunction
)
{
let
exceptionCaught
=
false
;
try
{
aFunction
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
aErrorCode
)
{
do_throw
(
"
Got
an
exception
but
the
result
code
was
not
the
expected
"
+
"
one
.
Expected
"
+
aErrorCode
+
"
got
"
+
e
.
result
)
;
}
exceptionCaught
=
true
;
}
if
(
!
exceptionCaught
)
{
do_throw
(
aFunction
+
"
should
have
thrown
an
exception
but
did
not
!
"
)
;
}
}
function
verifyQuery
(
aSQLString
aBind
aResults
)
{
let
stmt
=
getOpenedDatabase
(
)
.
createStatement
(
aSQLString
)
;
stmt
.
bindByIndex
(
0
aBind
)
;
try
{
Assert
.
ok
(
stmt
.
executeStep
(
)
)
;
let
nCols
=
stmt
.
numEntries
;
if
(
aResults
.
length
!
=
nCols
)
{
do_throw
(
"
Expected
"
+
aResults
.
length
+
"
columns
in
result
but
"
+
"
there
are
only
"
+
aResults
.
length
+
"
!
"
)
;
}
for
(
let
iCol
=
0
;
iCol
<
nCols
;
iCol
+
+
)
{
let
expectedVal
=
aResults
[
iCol
]
;
let
valType
=
stmt
.
getTypeOfIndex
(
iCol
)
;
if
(
expectedVal
=
=
=
null
)
{
Assert
.
equal
(
stmt
.
VALUE_TYPE_NULL
valType
)
;
Assert
.
ok
(
stmt
.
getIsNull
(
iCol
)
)
;
}
else
if
(
typeof
expectedVal
=
=
"
number
"
)
{
if
(
Math
.
floor
(
expectedVal
)
=
=
expectedVal
)
{
Assert
.
equal
(
stmt
.
VALUE_TYPE_INTEGER
valType
)
;
Assert
.
equal
(
expectedVal
stmt
.
getInt32
(
iCol
)
)
;
}
else
{
Assert
.
equal
(
stmt
.
VALUE_TYPE_FLOAT
valType
)
;
Assert
.
equal
(
expectedVal
stmt
.
getDouble
(
iCol
)
)
;
}
}
else
if
(
typeof
expectedVal
=
=
"
string
"
)
{
Assert
.
equal
(
stmt
.
VALUE_TYPE_TEXT
valType
)
;
Assert
.
equal
(
expectedVal
stmt
.
getUTF8String
(
iCol
)
)
;
}
else
{
Assert
.
equal
(
stmt
.
VALUE_TYPE_BLOB
valType
)
;
let
count
=
{
value
:
0
}
blob
=
{
value
:
null
}
;
stmt
.
getBlob
(
iCol
count
blob
)
;
Assert
.
equal
(
count
.
value
expectedVal
.
length
)
;
for
(
let
i
=
0
;
i
<
count
.
value
;
i
+
+
)
{
Assert
.
equal
(
expectedVal
[
i
]
blob
.
value
[
i
]
)
;
}
}
}
}
finally
{
stmt
.
finalize
(
)
;
}
}
function
getTableRowCount
(
aTableName
)
{
var
currentRows
=
0
;
var
countStmt
=
getOpenedDatabase
(
)
.
createStatement
(
"
SELECT
COUNT
(
1
)
AS
count
FROM
"
+
aTableName
)
;
try
{
Assert
.
ok
(
countStmt
.
executeStep
(
)
)
;
currentRows
=
countStmt
.
row
.
count
;
}
finally
{
countStmt
.
finalize
(
)
;
}
return
currentRows
;
}
function
asyncClone
(
db
readOnly
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
asyncClone
(
readOnly
function
(
status
db2
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
db2
)
;
}
else
{
reject
(
status
)
;
}
}
)
;
}
)
;
}
function
asyncClose
(
db
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
asyncClose
(
function
(
status
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
)
;
}
else
{
reject
(
status
)
;
}
}
)
;
}
)
;
}
function
mapOptionsToFlags
(
aOptions
aMapping
)
{
let
result
=
aMapping
.
default
;
Object
.
entries
(
aOptions
|
|
{
}
)
.
forEach
(
(
[
optionName
isTrue
]
)
=
>
{
if
(
aMapping
.
hasOwnProperty
(
optionName
)
&
&
isTrue
)
{
result
|
=
aMapping
[
optionName
]
;
}
}
)
;
return
result
;
}
function
getOpenFlagsMap
(
)
{
return
{
default
:
Ci
.
mozIStorageService
.
OPEN_DEFAULT
shared
:
Ci
.
mozIStorageService
.
OPEN_SHARED
readOnly
:
Ci
.
mozIStorageService
.
OPEN_READONLY
ignoreLockingMode
:
Ci
.
mozIStorageService
.
OPEN_IGNORE_LOCKING_MODE
}
;
}
function
getConnectionFlagsMap
(
)
{
return
{
default
:
Ci
.
mozIStorageService
.
CONNECTION_DEFAULT
interruptible
:
Ci
.
mozIStorageService
.
CONNECTION_INTERRUPTIBLE
}
;
}
function
openAsyncDatabase
(
file
options
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
openFlags
=
mapOptionsToFlags
(
options
getOpenFlagsMap
(
)
)
;
const
connectionFlags
=
mapOptionsToFlags
(
options
getConnectionFlagsMap
(
)
)
;
Services
.
storage
.
openAsyncDatabase
(
file
openFlags
connectionFlags
function
(
status
db
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
resolve
(
db
.
QueryInterface
(
Ci
.
mozIStorageAsyncConnection
)
)
;
}
else
{
reject
(
status
)
;
}
}
)
;
}
)
;
}
function
executeAsync
(
statement
onResult
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
statement
.
executeAsync
(
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
if
(
onResult
)
{
onResult
(
result
)
;
}
}
handleCompletion
(
result
)
{
resolve
(
result
)
;
}
}
)
;
}
)
;
}
function
executeMultipleStatementsAsync
(
db
statements
onResult
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
executeAsync
(
statements
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
if
(
onResult
)
{
onResult
(
result
)
;
}
}
handleCompletion
(
result
)
{
resolve
(
result
)
;
}
}
)
;
}
)
;
}
function
executeSimpleSQLAsync
(
db
query
onResult
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
db
.
executeSimpleSQLAsync
(
query
{
handleError
(
error
)
{
reject
(
error
)
;
}
handleResult
(
result
)
{
if
(
onResult
)
{
onResult
(
result
)
;
}
else
{
do_throw
(
"
No
results
were
expected
"
)
;
}
}
handleCompletion
(
result
)
{
resolve
(
result
)
;
}
}
)
;
}
)
;
}
cleanup
(
)
;
