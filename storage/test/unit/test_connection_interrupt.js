add_task
(
async
function
test_wr_async_conn
(
)
{
let
db
=
await
openAsyncDatabase
(
getTestDB
(
)
)
;
await
db
.
interrupt
(
)
;
info
(
"
should
be
able
to
interrupt
a
R
/
W
async
connection
"
)
;
await
asyncClose
(
db
)
;
}
)
;
add_task
(
async
function
test_closed_conn
(
)
{
let
db
=
await
openAsyncDatabase
(
getTestDB
(
)
{
readOnly
:
true
}
)
;
await
asyncClose
(
db
)
;
Assert
.
throws
(
(
)
=
>
db
.
interrupt
(
)
/
NS_ERROR_NOT_INITIALIZED
/
"
interrupt
(
)
should
throw
if
invoked
on
a
closed
connection
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
}
async
function
test_async_conn
(
)
{
let
db
=
await
openAsyncDatabase
(
getTestDB
(
)
{
readOnly
:
true
}
)
;
let
stmt
=
db
.
createAsyncStatement
(
WITH
RECURSIVE
test
(
n
)
AS
(
VALUES
(
1
)
UNION
ALL
SELECT
n
+
1
FROM
test
)
SELECT
t
.
n
FROM
test
test
AS
t
)
;
let
completePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
handleResult
(
aResultSet
)
{
reject
(
)
;
}
handleError
(
aError
)
{
reject
(
)
;
}
handleCompletion
(
aReason
)
{
resolve
(
aReason
)
;
}
}
;
stmt
.
executeAsync
(
listener
)
;
stmt
.
finalize
(
)
;
}
)
;
await
new
Promise
(
resolve
=
>
do_timeout
(
500
resolve
)
)
;
db
.
interrupt
(
)
;
Assert
.
equal
(
await
completePromise
Ci
.
mozIStorageStatementCallback
.
REASON_CANCELED
"
Should
have
been
canceled
"
)
;
await
asyncClose
(
db
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
AppConstants
.
platform
=
=
"
android
"
}
async
function
test_async_conn
(
)
{
let
db
=
await
openAsyncDatabase
(
getTestDB
(
)
)
;
let
stmt
=
db
.
createAsyncStatement
(
WITH
RECURSIVE
test
(
n
)
AS
(
VALUES
(
1
)
UNION
ALL
SELECT
n
+
1
FROM
test
)
SELECT
t
.
n
FROM
test
test
AS
t
)
;
let
completePromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
listener
=
{
handleResult
(
aResultSet
)
{
reject
(
)
;
}
handleError
(
aError
)
{
reject
(
)
;
}
handleCompletion
(
aReason
)
{
resolve
(
aReason
)
;
}
}
;
stmt
.
executeAsync
(
listener
)
;
stmt
.
finalize
(
)
;
}
)
;
await
new
Promise
(
resolve
=
>
do_timeout
(
500
resolve
)
)
;
db
.
interrupt
(
)
;
Assert
.
equal
(
await
completePromise
Ci
.
mozIStorageStatementCallback
.
REASON_CANCELED
"
Should
have
been
able
to
cancel
even
for
R
/
W
database
"
)
;
await
asyncClose
(
db
)
;
}
)
;
