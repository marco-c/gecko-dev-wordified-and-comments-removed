ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
load_test_vacuum_component
(
)
{
const
CATEGORY_NAME
=
"
vacuum
-
participant
"
;
do_load_manifest
(
"
vacuumParticipant
.
manifest
"
)
;
const
EXPECTED_ENTRIES
=
[
"
vacuumParticipant
"
]
;
let
catMan
=
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
.
getService
(
Ci
.
nsICategoryManager
)
;
let
found
=
false
;
for
(
let
{
data
:
entry
}
of
catMan
.
enumerateCategory
(
CATEGORY_NAME
)
)
{
print
(
"
Check
if
the
found
category
entry
(
"
+
entry
+
"
)
is
expected
.
"
)
;
if
(
EXPECTED_ENTRIES
.
includes
(
entry
)
)
{
print
(
"
Check
that
only
one
test
entry
exists
.
"
)
;
Assert
.
ok
(
!
found
)
;
found
=
true
;
}
else
{
catMan
.
deleteCategoryEntry
(
"
vacuum
-
participant
"
entry
false
)
;
}
}
print
(
"
Check
the
test
entry
exists
.
"
)
;
Assert
.
ok
(
found
)
;
}
function
synthesize_idle_daily
(
)
{
let
vm
=
Cc
[
"
mozilla
.
org
/
storage
/
vacuum
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
vm
.
observe
(
null
"
idle
-
daily
"
null
)
;
}
function
new_db_file
(
name
)
{
let
file
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
file
.
append
(
name
+
"
.
sqlite
"
)
;
return
file
;
}
function
run_test
(
)
{
do_test_pending
(
)
;
let
conn
=
getDatabase
(
new_db_file
(
"
testVacuum
"
)
)
;
conn
.
executeSimpleSQL
(
"
PRAGMA
page_size
=
1024
"
)
;
print
(
"
Check
current
page
size
.
"
)
;
let
stmt
=
conn
.
createStatement
(
"
PRAGMA
page_size
"
)
;
try
{
while
(
stmt
.
executeStep
(
)
)
{
Assert
.
equal
(
stmt
.
row
.
page_size
1024
)
;
}
}
finally
{
stmt
.
finalize
(
)
;
}
load_test_vacuum_component
(
)
;
run_next_test
(
)
;
}
const
TESTS
=
[
function
test_common_vacuum
(
)
{
print
(
"
\
n
*
*
*
Test
that
a
VACUUM
correctly
happens
and
all
notifications
are
fired
.
"
)
;
let
beginVacuumReceived
=
false
;
Services
.
obs
.
addObserver
(
function
onVacuum
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
onVacuum
aTopic
)
;
beginVacuumReceived
=
true
;
}
"
test
-
begin
-
vacuum
"
)
;
let
heavyIOTaskBeginReceived
=
false
;
let
heavyIOTaskEndReceived
=
false
;
Services
.
obs
.
addObserver
(
function
onVacuum
(
aSubject
aTopic
aData
)
{
if
(
heavyIOTaskBeginReceived
&
&
heavyIOTaskEndReceived
)
{
Services
.
obs
.
removeObserver
(
onVacuum
aTopic
)
;
}
if
(
aData
=
=
"
vacuum
-
begin
"
)
{
heavyIOTaskBeginReceived
=
true
;
}
else
if
(
aData
=
=
"
vacuum
-
end
"
)
{
heavyIOTaskEndReceived
=
true
;
}
}
"
heavy
-
io
-
task
"
)
;
Services
.
obs
.
addObserver
(
function
onVacuum
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
onVacuum
aTopic
)
;
print
(
"
Check
we
received
onBeginVacuum
"
)
;
Assert
.
ok
(
beginVacuumReceived
)
;
print
(
"
Check
we
received
heavy
-
io
-
task
notifications
"
)
;
Assert
.
ok
(
heavyIOTaskBeginReceived
)
;
Assert
.
ok
(
heavyIOTaskEndReceived
)
;
print
(
"
Received
onEndVacuum
"
)
;
run_next_test
(
)
;
}
"
test
-
end
-
vacuum
"
)
;
synthesize_idle_daily
(
)
;
}
function
test_skipped_if_recent_vacuum
(
)
{
print
(
"
\
n
*
*
*
Test
that
a
VACUUM
is
skipped
if
it
was
run
recently
.
"
)
;
Services
.
prefs
.
setIntPref
(
"
storage
.
vacuum
.
last
.
testVacuum
.
sqlite
"
parseInt
(
Date
.
now
(
)
/
1000
)
)
;
let
vacuumObserver
=
{
gotNotification
:
false
observe
:
function
VO_observe
(
aSubject
aTopic
aData
)
{
this
.
gotNotification
=
true
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
Services
.
obs
.
addObserver
(
vacuumObserver
"
test
-
begin
-
vacuum
"
)
;
do_timeout
(
2000
function
(
)
{
print
(
"
Check
VACUUM
did
not
run
.
"
)
;
Assert
.
ok
(
!
vacuumObserver
.
gotNotification
)
;
Services
.
obs
.
removeObserver
(
vacuumObserver
"
test
-
begin
-
vacuum
"
)
;
run_next_test
(
)
;
}
)
;
synthesize_idle_daily
(
)
;
}
function
test_page_size_change
(
)
{
print
(
"
\
n
*
*
*
Test
that
a
VACUUM
changes
page_size
"
)
;
print
(
"
Check
that
page
size
was
updated
.
"
)
;
let
conn
=
getDatabase
(
new_db_file
(
"
testVacuum
"
)
)
;
let
stmt
=
conn
.
createStatement
(
"
PRAGMA
page_size
"
)
;
try
{
while
(
stmt
.
executeStep
(
)
)
{
Assert
.
equal
(
stmt
.
row
.
page_size
conn
.
defaultPageSize
)
;
}
}
finally
{
stmt
.
finalize
(
)
;
}
run_next_test
(
)
;
}
function
test_skipped_optout_vacuum
(
)
{
print
(
"
\
n
*
*
*
Test
that
a
VACUUM
is
skipped
if
the
participant
wants
to
opt
-
out
.
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
test
-
options
"
"
opt
-
out
"
)
;
let
vacuumObserver
=
{
gotNotification
:
false
observe
:
function
VO_observe
(
aSubject
aTopic
aData
)
{
this
.
gotNotification
=
true
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
Services
.
obs
.
addObserver
(
vacuumObserver
"
test
-
begin
-
vacuum
"
)
;
do_timeout
(
2000
function
(
)
{
print
(
"
Check
VACUUM
did
not
run
.
"
)
;
Assert
.
ok
(
!
vacuumObserver
.
gotNotification
)
;
Services
.
obs
.
removeObserver
(
vacuumObserver
"
test
-
begin
-
vacuum
"
)
;
run_next_test
(
)
;
}
)
;
synthesize_idle_daily
(
)
;
}
function
test_memory_database_crash
(
)
{
print
(
"
\
n
*
*
*
Test
that
we
don
'
t
crash
trying
to
vacuum
a
memory
database
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
test
-
options
"
"
memory
"
)
;
let
vacuumObserver
=
{
gotNotification
:
false
observe
:
function
VO_observe
(
aSubject
aTopic
aData
)
{
this
.
gotNotification
=
true
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
Services
.
obs
.
addObserver
(
vacuumObserver
"
test
-
begin
-
vacuum
"
)
;
do_timeout
(
2000
function
(
)
{
print
(
"
Check
VACUUM
did
not
run
.
"
)
;
Assert
.
ok
(
!
vacuumObserver
.
gotNotification
)
;
Services
.
obs
.
removeObserver
(
vacuumObserver
"
test
-
begin
-
vacuum
"
)
;
run_next_test
(
)
;
}
)
;
synthesize_idle_daily
(
)
;
}
]
;
function
run_next_test
(
)
{
if
(
TESTS
.
length
=
=
0
)
{
Services
.
obs
.
notifyObservers
(
null
"
test
-
options
"
"
dispose
"
)
;
do_test_finished
(
)
;
}
else
{
Services
.
prefs
.
setIntPref
(
"
storage
.
vacuum
.
last
.
testVacuum
.
sqlite
"
parseInt
(
Date
.
now
(
)
/
1000
-
31
*
86400
)
)
;
executeSoon
(
TESTS
.
shift
(
)
)
;
}
}
