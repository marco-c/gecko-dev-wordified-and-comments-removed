#
ifndef
mozilla_storage_Connection_h
#
define
mozilla_storage_Connection_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
mozIStorageProgressHandler
.
h
"
#
include
"
SQLiteMutex
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozStorageService
.
h
"
#
include
"
mozIStorageAsyncConnection
.
h
"
#
include
"
mozIStorageCompletionCallback
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
sqlite3
.
h
"
class
nsIFile
;
class
nsIFileURL
;
class
nsIEventTarget
;
class
nsIThread
;
namespace
mozilla
{
namespace
storage
{
class
Connection
final
:
public
mozIStorageConnection
public
nsIInterfaceRequestor
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_MOZISTORAGEASYNCCONNECTION
NS_DECL_MOZISTORAGECONNECTION
NS_DECL_NSIINTERFACEREQUESTOR
enum
ConnectionOperation
{
ASYNCHRONOUS
SYNCHRONOUS
}
;
struct
FunctionInfo
{
nsCOMPtr
<
mozIStorageFunction
>
function
;
int32_t
numArgs
;
}
;
Connection
(
Service
*
aService
int
aFlags
ConnectionOperation
aSupportedOperations
bool
aInterruptible
=
false
bool
aIgnoreLockingMode
=
false
)
;
nsresult
initialize
(
const
nsACString
&
aStorageKey
const
nsACString
&
aName
)
;
nsresult
initialize
(
nsIFile
*
aDatabaseFile
)
;
nsresult
initialize
(
nsIFileURL
*
aFileURL
const
nsACString
&
aTelemetryFilename
)
;
nsresult
initializeOnAsyncThread
(
nsIFile
*
aStorageFile
)
;
int32_t
getSqliteRuntimeStatus
(
int32_t
aStatusOption
int32_t
*
aMaxValue
=
nullptr
)
;
void
setCommitHook
(
int
(
*
aCallbackFn
)
(
void
*
)
void
*
aData
=
nullptr
)
{
MOZ_ASSERT
(
mDBConn
"
A
connection
must
exist
at
this
point
"
)
;
:
:
sqlite3_commit_hook
(
mDBConn
aCallbackFn
aData
)
;
}
;
bool
getAutocommit
(
)
{
return
mDBConn
&
&
static_cast
<
bool
>
(
:
:
sqlite3_get_autocommit
(
mDBConn
)
)
;
}
;
nsIEventTarget
*
getAsyncExecutionTarget
(
)
;
Mutex
sharedAsyncExecutionMutex
;
SQLiteMutex
sharedDBMutex
;
const
nsCOMPtr
<
nsIThread
>
threadOpenedOn
;
nsresult
internalClose
(
sqlite3
*
aDBConn
)
;
void
shutdownAsyncThread
(
)
;
nsCString
getFilename
(
)
;
int
prepareStatement
(
sqlite3
*
aNativeConnection
const
nsCString
&
aSQL
sqlite3_stmt
*
*
_stmt
)
;
int
stepStatement
(
sqlite3
*
aNativeConnection
sqlite3_stmt
*
aStatement
)
;
nsresult
beginTransactionInternal
(
const
SQLiteMutexAutoLock
&
aProofOfLock
sqlite3
*
aNativeConnection
int32_t
aTransactionType
=
TRANSACTION_DEFERRED
)
;
nsresult
commitTransactionInternal
(
const
SQLiteMutexAutoLock
&
aProofOfLock
sqlite3
*
aNativeConnection
)
;
nsresult
rollbackTransactionInternal
(
const
SQLiteMutexAutoLock
&
aProofOfLock
sqlite3
*
aNativeConnection
)
;
inline
bool
connectionReady
(
)
{
return
mDBConn
!
=
nullptr
;
}
inline
bool
transactionInProgress
(
const
SQLiteMutexAutoLock
&
aProofOfLock
)
{
return
!
getAutocommit
(
)
;
}
bool
operationSupported
(
ConnectionOperation
aOperationType
)
;
bool
isConnectionReadyOnThisThread
(
)
;
bool
isClosing
(
)
;
bool
isClosed
(
)
;
bool
isClosed
(
MutexAutoLock
&
lock
)
;
bool
isAsyncExecutionThreadAvailable
(
)
;
nsresult
initializeClone
(
Connection
*
aClone
bool
aReadOnly
)
;
void
RecordQueryStatus
(
int
srv
)
;
private
:
~
Connection
(
)
;
nsresult
initializeInternal
(
)
;
void
initializeFailed
(
)
;
void
RecordOpenStatus
(
nsresult
rv
)
;
nsresult
setClosedState
(
)
;
int
executeSql
(
sqlite3
*
aNativeConnection
const
char
*
aSqlString
)
;
enum
DatabaseElementType
{
INDEX
TABLE
}
;
nsresult
databaseElementExists
(
enum
DatabaseElementType
aElementType
const
nsACString
&
aElementName
bool
*
_exists
)
;
bool
findFunctionByInstance
(
mozIStorageFunction
*
aInstance
)
;
static
int
sProgressHelper
(
void
*
aArg
)
;
int
progressHandler
(
)
;
nsresult
ensureOperationSupported
(
ConnectionOperation
aOperationType
)
;
sqlite3
*
mDBConn
;
nsCString
mStorageKey
;
nsCString
mName
;
nsCOMPtr
<
nsIFileURL
>
mFileURL
;
nsCOMPtr
<
nsIFile
>
mDatabaseFile
;
nsCOMPtr
<
nsIThread
>
mAsyncExecutionThread
;
nsCString
mTelemetryFilename
;
mozilla
:
:
Atomic
<
int32_t
>
mDefaultTransactionType
;
mozilla
:
:
Atomic
<
bool
>
mDestroying
;
nsTHashMap
<
nsCStringHashKey
FunctionInfo
>
mFunctions
;
nsCOMPtr
<
mozIStorageProgressHandler
>
mProgressHandler
;
RefPtr
<
Service
>
mStorageService
;
nsresult
synchronousClose
(
)
;
const
int
mFlags
;
uint32_t
mTransactionNestingLevel
;
const
ConnectionOperation
mSupportedOperations
;
const
bool
mInterruptible
;
const
bool
mIgnoreLockingMode
;
bool
mAsyncExecutionThreadShuttingDown
;
bool
mConnectionClosed
;
}
;
class
CallbackComplete
final
:
public
Runnable
{
public
:
CallbackComplete
(
nsresult
aStatus
nsISupports
*
aValue
already_AddRefed
<
mozIStorageCompletionCallback
>
aCallback
)
:
Runnable
(
"
storage
:
:
CallbackComplete
"
)
mStatus
(
aStatus
)
mValue
(
aValue
)
mCallback
(
aCallback
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
mCallback
-
>
Complete
(
mStatus
mValue
)
;
mValue
=
nullptr
;
mCallback
=
nullptr
;
return
rv
;
}
private
:
nsresult
mStatus
;
nsCOMPtr
<
nsISupports
>
mValue
;
RefPtr
<
mozIStorageCompletionCallback
>
mCallback
;
}
;
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
storage
:
:
Connection
*
p
)
{
return
NS_ISUPPORTS_CAST
(
mozIStorageAsyncConnection
*
p
)
;
}
#
endif
