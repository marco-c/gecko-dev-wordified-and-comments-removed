#
ifndef
MOZSTORAGEHELPER_H
#
define
MOZSTORAGEHELPER_H
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
storage
/
SQLiteMutex
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozIStoragePendingStatement
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsError
.
h
"
class
mozStorageTransaction
{
using
SQLiteMutexAutoLock
=
mozilla
:
:
storage
:
:
SQLiteMutexAutoLock
;
public
:
mozStorageTransaction
(
mozIStorageConnection
*
aConnection
bool
aCommitOnComplete
int32_t
aType
=
mozIStorageConnection
:
:
TRANSACTION_DEFAULT
bool
aAsyncCommit
=
false
)
:
mConnection
(
aConnection
)
mType
(
aType
)
mNestingLevel
(
0
)
mHasTransaction
(
false
)
mCommitOnComplete
(
aCommitOnComplete
)
mCompleted
(
false
)
mAsyncCommit
(
aAsyncCommit
)
{
}
~
mozStorageTransaction
(
)
{
if
(
mConnection
&
&
mHasTransaction
&
&
!
mCompleted
)
{
if
(
mCommitOnComplete
)
{
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
Commit
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
A
transaction
didn
'
t
commit
correctly
"
)
;
}
else
{
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
Rollback
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
A
transaction
didn
'
t
rollback
correctly
"
)
;
}
}
}
nsresult
Start
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mHasTransaction
)
;
if
(
!
mConnection
|
|
mCompleted
)
{
return
NS_OK
;
}
SQLiteMutexAutoLock
lock
(
mConnection
-
>
GetSharedDBMutex
(
)
)
;
TransactionStarted
(
lock
)
;
auto
autoFinishTransaction
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
TransactionFinished
(
lock
)
;
}
)
;
nsAutoCString
query
;
if
(
TopLevelTransaction
(
lock
)
)
{
query
.
Assign
(
"
BEGIN
"
)
;
int32_t
type
=
mType
;
if
(
type
=
=
mozIStorageConnection
:
:
TRANSACTION_DEFAULT
)
{
MOZ_ALWAYS_SUCCEEDS
(
mConnection
-
>
GetDefaultTransactionType
(
&
type
)
)
;
}
switch
(
type
)
{
case
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
:
query
.
AppendLiteral
(
"
IMMEDIATE
"
)
;
break
;
case
mozIStorageConnection
:
:
TRANSACTION_EXCLUSIVE
:
query
.
AppendLiteral
(
"
EXCLUSIVE
"
)
;
break
;
case
mozIStorageConnection
:
:
TRANSACTION_DEFERRED
:
query
.
AppendLiteral
(
"
DEFERRED
"
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unknown
transaction
type
"
)
;
}
}
else
{
query
.
Assign
(
"
SAVEPOINT
sp
"
_ns
+
IntToCString
(
mNestingLevel
)
)
;
}
nsresult
rv
=
mConnection
-
>
ExecuteSimpleSQL
(
query
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
autoFinishTransaction
.
release
(
)
;
return
NS_OK
;
}
nsresult
Commit
(
)
{
if
(
!
mConnection
|
|
mCompleted
|
|
!
mHasTransaction
)
return
NS_OK
;
SQLiteMutexAutoLock
lock
(
mConnection
-
>
GetSharedDBMutex
(
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_DIAGNOSTIC_ASSERT
(
CurrentTransaction
(
lock
)
)
;
#
else
if
(
!
CurrentTransaction
(
lock
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
endif
mCompleted
=
true
;
nsresult
rv
;
if
(
TopLevelTransaction
(
lock
)
)
{
if
(
mAsyncCommit
)
{
nsCOMPtr
<
mozIStoragePendingStatement
>
ps
;
rv
=
mConnection
-
>
ExecuteSimpleSQLAsync
(
"
COMMIT
"
_ns
nullptr
getter_AddRefs
(
ps
)
)
;
}
else
{
rv
=
mConnection
-
>
ExecuteSimpleSQL
(
"
COMMIT
"
_ns
)
;
}
}
else
{
rv
=
mConnection
-
>
ExecuteSimpleSQL
(
"
RELEASE
sp
"
_ns
+
IntToCString
(
mNestingLevel
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
TransactionFinished
(
lock
)
;
return
NS_OK
;
}
nsresult
Rollback
(
)
{
if
(
!
mConnection
|
|
mCompleted
|
|
!
mHasTransaction
)
return
NS_OK
;
SQLiteMutexAutoLock
lock
(
mConnection
-
>
GetSharedDBMutex
(
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_DIAGNOSTIC_ASSERT
(
CurrentTransaction
(
lock
)
)
;
#
else
if
(
!
CurrentTransaction
(
lock
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
endif
mCompleted
=
true
;
nsresult
rv
;
if
(
TopLevelTransaction
(
lock
)
)
{
do
{
rv
=
mConnection
-
>
ExecuteSimpleSQL
(
"
ROLLBACK
"
_ns
)
;
if
(
rv
=
=
NS_ERROR_STORAGE_BUSY
)
(
void
)
PR_Sleep
(
PR_INTERVAL_NO_WAIT
)
;
}
while
(
rv
=
=
NS_ERROR_STORAGE_BUSY
)
;
}
else
{
const
auto
nestingLevelCString
=
IntToCString
(
mNestingLevel
)
;
rv
=
mConnection
-
>
ExecuteSimpleSQL
(
"
ROLLBACK
TO
sp
"
_ns
+
nestingLevelCString
+
"
;
RELEASE
sp
"
_ns
+
nestingLevelCString
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
TransactionFinished
(
lock
)
;
return
NS_OK
;
}
protected
:
void
TransactionStarted
(
const
SQLiteMutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
!
mHasTransaction
)
;
MOZ_ASSERT
(
mNestingLevel
=
=
0
)
;
mHasTransaction
=
true
;
mNestingLevel
=
mConnection
-
>
IncreaseTransactionNestingLevel
(
aProofOfLock
)
;
}
bool
CurrentTransaction
(
const
SQLiteMutexAutoLock
&
aProofOfLock
)
const
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mHasTransaction
)
;
MOZ_ASSERT
(
mNestingLevel
>
0
)
;
return
mNestingLevel
=
=
mConnection
-
>
GetTransactionNestingLevel
(
aProofOfLock
)
;
}
bool
TopLevelTransaction
(
const
SQLiteMutexAutoLock
&
aProofOfLock
)
const
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mHasTransaction
)
;
MOZ_ASSERT
(
mNestingLevel
>
0
)
;
MOZ_ASSERT
(
CurrentTransaction
(
aProofOfLock
)
)
;
return
mNestingLevel
=
=
1
;
}
void
TransactionFinished
(
const
SQLiteMutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mHasTransaction
)
;
MOZ_ASSERT
(
mNestingLevel
>
0
)
;
MOZ_ASSERT
(
CurrentTransaction
(
aProofOfLock
)
)
;
mConnection
-
>
DecreaseTransactionNestingLevel
(
aProofOfLock
)
;
mNestingLevel
=
0
;
mHasTransaction
=
false
;
}
nsCOMPtr
<
mozIStorageConnection
>
mConnection
;
int32_t
mType
;
uint32_t
mNestingLevel
;
bool
mHasTransaction
;
bool
mCommitOnComplete
;
bool
mCompleted
;
bool
mAsyncCommit
;
}
;
class
MOZ_STACK_CLASS
mozStorageStatementScoper
{
public
:
explicit
mozStorageStatementScoper
(
mozIStorageStatement
*
aStatement
)
:
mStatement
(
aStatement
)
{
}
~
mozStorageStatementScoper
(
)
{
if
(
mStatement
)
mStatement
-
>
Reset
(
)
;
}
mozStorageStatementScoper
(
mozStorageStatementScoper
&
&
)
=
default
;
mozStorageStatementScoper
&
operator
=
(
mozStorageStatementScoper
&
&
)
=
default
;
mozStorageStatementScoper
(
const
mozStorageStatementScoper
&
)
=
delete
;
mozStorageStatementScoper
&
operator
=
(
const
mozStorageStatementScoper
&
)
=
delete
;
void
Abandon
(
)
{
mStatement
=
nullptr
;
}
protected
:
nsCOMPtr
<
mozIStorageStatement
>
mStatement
;
}
;
#
define
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
/
*
"
__FILE__
"
*
/
"
#
endif
