#
include
"
StorageBaseStatementInternal
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
mozStorageBindingParamsArray
.
h
"
#
include
"
mozStorageStatementData
.
h
"
#
include
"
mozStorageAsyncStatementExecution
.
h
"
namespace
mozilla
{
namespace
storage
{
class
AsyncStatementFinalizer
:
public
Runnable
{
public
:
AsyncStatementFinalizer
(
StorageBaseStatementInternal
*
aStatement
Connection
*
aConnection
)
:
mStatement
(
aStatement
)
mConnection
(
aConnection
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mStatement
-
>
mAsyncStatement
)
{
sqlite3_finalize
(
mStatement
-
>
mAsyncStatement
)
;
mStatement
-
>
mAsyncStatement
=
nullptr
;
}
nsCOMPtr
<
nsIThread
>
targetThread
(
mConnection
-
>
threadOpenedOn
)
;
NS_ProxyRelease
(
"
AsyncStatementFinalizer
:
:
mStatement
"
targetThread
mStatement
.
forget
(
)
)
;
return
NS_OK
;
}
private
:
RefPtr
<
StorageBaseStatementInternal
>
mStatement
;
RefPtr
<
Connection
>
mConnection
;
}
;
class
LastDitchSqliteStatementFinalizer
:
public
Runnable
{
public
:
LastDitchSqliteStatementFinalizer
(
RefPtr
<
Connection
>
&
aConnection
sqlite3_stmt
*
aStatement
)
:
mConnection
(
aConnection
)
mAsyncStatement
(
aStatement
)
{
NS_PRECONDITION
(
aConnection
"
You
must
provide
a
Connection
"
)
;
}
NS_IMETHOD
Run
(
)
override
{
(
void
)
:
:
sqlite3_finalize
(
mAsyncStatement
)
;
mAsyncStatement
=
nullptr
;
nsCOMPtr
<
nsIThread
>
target
(
mConnection
-
>
threadOpenedOn
)
;
(
void
)
:
:
NS_ProxyRelease
(
"
LastDitchSqliteStatementFinalizer
:
:
mConnection
"
target
mConnection
.
forget
(
)
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Connection
>
mConnection
;
sqlite3_stmt
*
mAsyncStatement
;
}
;
StorageBaseStatementInternal
:
:
StorageBaseStatementInternal
(
)
:
mAsyncStatement
(
nullptr
)
{
}
void
StorageBaseStatementInternal
:
:
asyncFinalize
(
)
{
nsIEventTarget
*
target
=
mDBConnection
-
>
getAsyncExecutionTarget
(
)
;
if
(
target
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncStatementFinalizer
(
this
mDBConnection
)
;
(
void
)
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
}
void
StorageBaseStatementInternal
:
:
destructorAsyncFinalize
(
)
{
if
(
!
mAsyncStatement
)
return
;
nsIEventTarget
*
target
=
mDBConnection
-
>
getAsyncExecutionTarget
(
)
;
if
(
target
)
{
bool
isAsyncThread
=
false
;
(
void
)
target
-
>
IsOnCurrentThread
(
&
isAsyncThread
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
LastDitchSqliteStatementFinalizer
(
mDBConnection
mAsyncStatement
)
;
if
(
isAsyncThread
)
{
(
void
)
event
-
>
Run
(
)
;
}
else
{
(
void
)
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
}
mAsyncStatement
=
nullptr
;
}
NS_IMETHODIMP
StorageBaseStatementInternal
:
:
NewBindingParamsArray
(
mozIStorageBindingParamsArray
*
*
_array
)
{
nsCOMPtr
<
mozIStorageBindingParamsArray
>
array
=
new
BindingParamsArray
(
this
)
;
NS_ENSURE_TRUE
(
array
NS_ERROR_OUT_OF_MEMORY
)
;
array
.
forget
(
_array
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageBaseStatementInternal
:
:
ExecuteAsync
(
mozIStorageStatementCallback
*
aCallback
mozIStoragePendingStatement
*
*
_stmt
)
{
nsTArray
<
StatementData
>
stmts
(
1
)
;
StatementData
data
;
nsresult
rv
=
getAsynchronousStatementData
(
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
stmts
.
AppendElement
(
data
)
NS_ERROR_OUT_OF_MEMORY
)
;
return
AsyncExecuteStatements
:
:
execute
(
stmts
mDBConnection
mNativeConnection
aCallback
_stmt
)
;
}
NS_IMETHODIMP
StorageBaseStatementInternal
:
:
EscapeStringForLIKE
(
const
nsAString
&
aValue
const
char16_t
aEscapeChar
nsAString
&
_escapedString
)
{
const
char16_t
MATCH_ALL
(
'
%
'
)
;
const
char16_t
MATCH_ONE
(
'
_
'
)
;
_escapedString
.
Truncate
(
0
)
;
for
(
uint32_t
i
=
0
;
i
<
aValue
.
Length
(
)
;
i
+
+
)
{
if
(
aValue
[
i
]
=
=
aEscapeChar
|
|
aValue
[
i
]
=
=
MATCH_ALL
|
|
aValue
[
i
]
=
=
MATCH_ONE
)
{
_escapedString
+
=
aEscapeChar
;
}
_escapedString
+
=
aValue
[
i
]
;
}
return
NS_OK
;
}
}
}
