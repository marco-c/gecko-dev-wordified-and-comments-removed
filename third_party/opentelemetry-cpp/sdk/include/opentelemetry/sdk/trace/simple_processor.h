#
pragma
once
#
include
<
atomic
>
#
include
<
chrono
>
#
include
<
memory
>
#
include
<
mutex
>
#
include
<
utility
>
#
include
"
opentelemetry
/
common
/
spin_lock_mutex
.
h
"
#
include
"
opentelemetry
/
nostd
/
span
.
h
"
#
include
"
opentelemetry
/
sdk
/
common
/
exporter_utils
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
exporter
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
processor
.
h
"
#
include
"
opentelemetry
/
sdk
/
trace
/
recordable
.
h
"
#
include
"
opentelemetry
/
trace
/
span_context
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
sdk
{
namespace
trace
{
class
SimpleSpanProcessor
:
public
SpanProcessor
{
public
:
explicit
SimpleSpanProcessor
(
std
:
:
unique_ptr
<
SpanExporter
>
&
&
exporter
)
noexcept
:
exporter_
(
std
:
:
move
(
exporter
)
)
{
}
std
:
:
unique_ptr
<
Recordable
>
MakeRecordable
(
)
noexcept
override
{
return
exporter_
-
>
MakeRecordable
(
)
;
}
void
OnStart
(
Recordable
&
const
opentelemetry
:
:
trace
:
:
SpanContext
&
)
noexcept
override
{
}
void
OnEnd
(
std
:
:
unique_ptr
<
Recordable
>
&
&
span
)
noexcept
override
{
nostd
:
:
span
<
std
:
:
unique_ptr
<
Recordable
>
>
batch
(
&
span
1
)
;
const
std
:
:
lock_guard
<
opentelemetry
:
:
common
:
:
SpinLockMutex
>
locked
(
lock_
)
;
if
(
exporter_
-
>
Export
(
batch
)
=
=
sdk
:
:
common
:
:
ExportResult
:
:
kFailure
)
{
}
}
bool
ForceFlush
(
std
:
:
chrono
:
:
microseconds
timeout
=
(
std
:
:
chrono
:
:
microseconds
:
:
max
)
(
)
)
noexcept
override
{
if
(
exporter_
!
=
nullptr
)
{
return
exporter_
-
>
ForceFlush
(
timeout
)
;
}
return
true
;
}
bool
Shutdown
(
std
:
:
chrono
:
:
microseconds
timeout
=
(
std
:
:
chrono
:
:
microseconds
:
:
max
)
(
)
)
noexcept
override
{
if
(
exporter_
!
=
nullptr
&
&
!
shutdown_latch_
.
test_and_set
(
std
:
:
memory_order_acquire
)
)
{
return
exporter_
-
>
Shutdown
(
timeout
)
;
}
return
true
;
}
~
SimpleSpanProcessor
(
)
override
{
Shutdown
(
)
;
}
private
:
std
:
:
unique_ptr
<
SpanExporter
>
exporter_
;
opentelemetry
:
:
common
:
:
SpinLockMutex
lock_
;
#
if
defined
(
__cpp_lib_atomic_value_initialization
)
&
&
\
__cpp_lib_atomic_value_initialization
>
=
201911L
std
:
:
atomic_flag
shutdown_latch_
{
}
;
#
else
std
:
:
atomic_flag
shutdown_latch_
=
ATOMIC_FLAG_INIT
;
#
endif
}
;
}
}
OPENTELEMETRY_END_NAMESPACE
