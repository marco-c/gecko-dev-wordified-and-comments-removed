#
pragma
once
#
include
<
stddef
.
h
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
opentelemetry
/
common
/
attribute_value
.
h
"
#
include
"
opentelemetry
/
common
/
key_value_iterable
.
h
"
#
include
"
opentelemetry
/
nostd
/
function_ref
.
h
"
#
include
"
opentelemetry
/
nostd
/
span
.
h
"
#
include
"
opentelemetry
/
nostd
/
string_view
.
h
"
#
include
"
opentelemetry
/
nostd
/
type_traits
.
h
"
#
include
"
opentelemetry
/
nostd
/
utility
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
common
{
namespace
detail
{
inline
void
take_key_value
(
nostd
:
:
string_view
common
:
:
AttributeValue
)
{
}
template
<
class
T
>
auto
is_key_value_iterable_impl
(
T
iterable
)
-
>
decltype
(
take_key_value
(
std
:
:
begin
(
iterable
)
-
>
first
std
:
:
begin
(
iterable
)
-
>
second
)
nostd
:
:
size
(
iterable
)
std
:
:
true_type
{
}
)
;
std
:
:
false_type
is_key_value_iterable_impl
(
.
.
.
)
;
template
<
class
T
>
struct
is_key_value_iterable
{
static
const
bool
value
=
decltype
(
detail
:
:
is_key_value_iterable_impl
(
std
:
:
declval
<
T
>
(
)
)
)
:
:
value
;
}
;
}
template
<
class
T
>
class
KeyValueIterableView
final
:
public
KeyValueIterable
{
public
:
explicit
KeyValueIterableView
(
const
T
&
container
)
noexcept
:
container_
{
&
container
}
{
}
bool
ForEachKeyValue
(
nostd
:
:
function_ref
<
bool
(
nostd
:
:
string_view
common
:
:
AttributeValue
)
>
callback
)
const
noexcept
override
{
auto
iter
=
std
:
:
begin
(
*
container_
)
;
auto
last
=
std
:
:
end
(
*
container_
)
;
for
(
;
iter
!
=
last
;
+
+
iter
)
{
if
(
!
callback
(
iter
-
>
first
iter
-
>
second
)
)
{
return
false
;
}
}
return
true
;
}
size_t
size
(
)
const
noexcept
override
{
return
nostd
:
:
size
(
*
container_
)
;
}
private
:
const
T
*
container_
;
}
;
template
<
class
T
nostd
:
:
enable_if_t
<
detail
:
:
is_key_value_iterable
<
T
>
:
:
value
>
*
=
nullptr
>
KeyValueIterableView
<
T
>
MakeKeyValueIterableView
(
const
T
&
container
)
noexcept
{
return
KeyValueIterableView
<
T
>
(
container
)
;
}
inline
static
nostd
:
:
span
<
const
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
MakeAttributes
(
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
attributes
)
noexcept
{
return
nostd
:
:
span
<
const
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
{
attributes
.
begin
(
)
attributes
.
end
(
)
}
;
}
inline
static
nostd
:
:
span
<
const
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
MakeAttributes
(
nostd
:
:
span
<
const
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
attributes
)
noexcept
{
return
attributes
;
}
inline
static
const
common
:
:
KeyValueIterable
&
MakeAttributes
(
const
common
:
:
KeyValueIterable
&
attributes
)
noexcept
{
return
attributes
;
}
template
<
class
ArgumentType
nostd
:
:
enable_if_t
<
common
:
:
detail
:
:
is_key_value_iterable
<
ArgumentType
>
:
:
value
>
*
=
nullptr
>
inline
static
common
:
:
KeyValueIterableView
<
ArgumentType
>
MakeAttributes
(
const
ArgumentType
&
attributes
)
noexcept
{
return
common
:
:
KeyValueIterableView
<
ArgumentType
>
(
attributes
)
;
}
}
OPENTELEMETRY_END_NAMESPACE
