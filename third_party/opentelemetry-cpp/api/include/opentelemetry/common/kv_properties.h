#
pragma
once
#
include
"
opentelemetry
/
common
/
key_value_iterable_view
.
h
"
#
include
"
opentelemetry
/
common
/
string_util
.
h
"
#
include
"
opentelemetry
/
nostd
/
function_ref
.
h
"
#
include
"
opentelemetry
/
nostd
/
string_view
.
h
"
#
include
"
opentelemetry
/
nostd
/
unique_ptr
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
#
include
<
cstring
>
#
include
<
string
>
#
include
<
type_traits
>
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
common
{
struct
KeyValueStringTokenizerOptions
{
char
member_separator
=
'
'
;
char
key_value_separator
=
'
=
'
;
bool
ignore_empty_members
=
true
;
}
;
class
KeyValueStringTokenizer
{
public
:
KeyValueStringTokenizer
(
nostd
:
:
string_view
str
const
KeyValueStringTokenizerOptions
&
opts
=
KeyValueStringTokenizerOptions
(
)
)
noexcept
:
str_
(
str
)
opts_
(
opts
)
index_
(
0
)
{
}
static
nostd
:
:
string_view
GetDefaultKeyOrValue
(
)
{
static
std
:
:
string
default_str
=
"
"
;
return
default_str
;
}
bool
next
(
bool
&
valid_kv
nostd
:
:
string_view
&
key
nostd
:
:
string_view
&
value
)
noexcept
{
valid_kv
=
true
;
while
(
index_
<
str_
.
size
(
)
)
{
bool
is_empty_pair
=
false
;
size_t
end
=
str_
.
find
(
opts_
.
member_separator
index_
)
;
if
(
end
=
=
std
:
:
string
:
:
npos
)
{
end
=
str_
.
size
(
)
-
1
;
}
else
if
(
end
=
=
index_
)
{
is_empty_pair
=
true
;
}
else
{
end
-
-
;
}
auto
list_member
=
StringUtil
:
:
Trim
(
str_
index_
end
)
;
if
(
list_member
.
size
(
)
=
=
0
|
|
is_empty_pair
)
{
index_
=
end
+
2
-
is_empty_pair
;
if
(
opts_
.
ignore_empty_members
)
{
continue
;
}
valid_kv
=
true
;
key
=
GetDefaultKeyOrValue
(
)
;
value
=
GetDefaultKeyOrValue
(
)
;
return
true
;
}
auto
key_end_pos
=
list_member
.
find
(
opts_
.
key_value_separator
)
;
if
(
key_end_pos
=
=
std
:
:
string
:
:
npos
)
{
valid_kv
=
false
;
}
else
{
key
=
list_member
.
substr
(
0
key_end_pos
)
;
value
=
list_member
.
substr
(
key_end_pos
+
1
)
;
}
index_
=
end
+
2
;
return
true
;
}
return
false
;
}
size_t
NumTokens
(
)
const
noexcept
{
size_t
cnt
=
0
begin
=
0
;
while
(
begin
<
str_
.
size
(
)
)
{
+
+
cnt
;
size_t
end
=
str_
.
find
(
opts_
.
member_separator
begin
)
;
if
(
end
=
=
std
:
:
string
:
:
npos
)
{
break
;
}
begin
=
end
+
1
;
}
return
cnt
;
}
void
reset
(
)
noexcept
{
index_
=
0
;
}
private
:
nostd
:
:
string_view
str_
;
KeyValueStringTokenizerOptions
opts_
;
size_t
index_
;
}
;
class
KeyValueProperties
{
public
:
class
Entry
{
public
:
Entry
(
)
:
key_
(
nullptr
)
value_
(
nullptr
)
{
}
Entry
(
const
Entry
&
copy
)
{
key_
=
CopyStringToPointer
(
copy
.
key_
.
get
(
)
)
;
value_
=
CopyStringToPointer
(
copy
.
value_
.
get
(
)
)
;
}
Entry
&
operator
=
(
Entry
&
other
)
{
key_
=
CopyStringToPointer
(
other
.
key_
.
get
(
)
)
;
value_
=
CopyStringToPointer
(
other
.
value_
.
get
(
)
)
;
return
*
this
;
}
Entry
(
Entry
&
&
other
)
=
default
;
Entry
&
operator
=
(
Entry
&
&
other
)
=
default
;
Entry
(
nostd
:
:
string_view
key
nostd
:
:
string_view
value
)
{
key_
=
CopyStringToPointer
(
key
)
;
value_
=
CopyStringToPointer
(
value
)
;
}
nostd
:
:
string_view
GetKey
(
)
const
noexcept
{
return
key_
.
get
(
)
;
}
nostd
:
:
string_view
GetValue
(
)
const
noexcept
{
return
value_
.
get
(
)
;
}
void
SetValue
(
nostd
:
:
string_view
value
)
noexcept
{
value_
=
CopyStringToPointer
(
value
)
;
}
private
:
nostd
:
:
unique_ptr
<
const
char
[
]
>
key_
;
nostd
:
:
unique_ptr
<
const
char
[
]
>
value_
;
nostd
:
:
unique_ptr
<
const
char
[
]
>
CopyStringToPointer
(
nostd
:
:
string_view
str
)
{
char
*
temp
=
new
char
[
str
.
size
(
)
+
1
]
;
memcpy
(
temp
str
.
data
(
)
str
.
size
(
)
)
;
temp
[
str
.
size
(
)
]
=
'
\
0
'
;
return
nostd
:
:
unique_ptr
<
const
char
[
]
>
(
temp
)
;
}
}
;
size_t
num_entries_
;
size_t
max_num_entries_
;
nostd
:
:
unique_ptr
<
Entry
[
]
>
entries_
;
public
:
KeyValueProperties
(
size_t
size
)
noexcept
:
num_entries_
(
0
)
max_num_entries_
(
size
)
entries_
(
new
Entry
[
size
]
)
{
}
KeyValueProperties
(
)
noexcept
:
num_entries_
(
0
)
max_num_entries_
(
0
)
entries_
(
nullptr
)
{
}
template
<
class
T
class
=
typename
std
:
:
enable_if
<
detail
:
:
is_key_value_iterable
<
T
>
:
:
value
>
:
:
type
>
KeyValueProperties
(
const
T
&
keys_and_values
)
noexcept
:
num_entries_
(
0
)
max_num_entries_
(
keys_and_values
.
size
(
)
)
entries_
(
new
Entry
[
max_num_entries_
]
)
{
for
(
auto
&
e
:
keys_and_values
)
{
Entry
entry
(
e
.
first
e
.
second
)
;
(
entries_
.
get
(
)
)
[
num_entries_
+
+
]
=
std
:
:
move
(
entry
)
;
}
}
void
AddEntry
(
nostd
:
:
string_view
key
nostd
:
:
string_view
value
)
noexcept
{
if
(
num_entries_
<
max_num_entries_
)
{
Entry
entry
(
key
value
)
;
(
entries_
.
get
(
)
)
[
num_entries_
+
+
]
=
std
:
:
move
(
entry
)
;
}
}
bool
GetAllEntries
(
nostd
:
:
function_ref
<
bool
(
nostd
:
:
string_view
nostd
:
:
string_view
)
>
callback
)
const
noexcept
{
for
(
size_t
i
=
0
;
i
<
num_entries_
;
i
+
+
)
{
auto
&
entry
=
(
entries_
.
get
(
)
)
[
i
]
;
if
(
!
callback
(
entry
.
GetKey
(
)
entry
.
GetValue
(
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
GetValue
(
nostd
:
:
string_view
key
std
:
:
string
&
value
)
const
noexcept
{
for
(
size_t
i
=
0
;
i
<
num_entries_
;
i
+
+
)
{
auto
&
entry
=
(
entries_
.
get
(
)
)
[
i
]
;
if
(
entry
.
GetKey
(
)
=
=
key
)
{
const
auto
&
entry_value
=
entry
.
GetValue
(
)
;
value
=
std
:
:
string
(
entry_value
.
data
(
)
entry_value
.
size
(
)
)
;
return
true
;
}
}
return
false
;
}
size_t
Size
(
)
const
noexcept
{
return
num_entries_
;
}
}
;
}
OPENTELEMETRY_END_NAMESPACE
