#
pragma
once
#
include
<
stddef
.
h
>
#
include
<
algorithm
>
#
include
"
opentelemetry
/
common
/
macros
.
h
"
#
include
"
opentelemetry
/
context
/
context
.
h
"
#
include
"
opentelemetry
/
context
/
context_value
.
h
"
#
include
"
opentelemetry
/
nostd
/
shared_ptr
.
h
"
#
include
"
opentelemetry
/
nostd
/
string_view
.
h
"
#
include
"
opentelemetry
/
nostd
/
unique_ptr
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
context
{
class
Token
{
public
:
bool
operator
=
=
(
const
Context
&
other
)
const
noexcept
{
return
context_
=
=
other
;
}
~
Token
(
)
noexcept
;
private
:
friend
class
RuntimeContextStorage
;
Token
(
const
Context
&
context
)
:
context_
(
context
)
{
}
const
Context
context_
;
}
;
class
OPENTELEMETRY_EXPORT
RuntimeContextStorage
{
public
:
virtual
Context
GetCurrent
(
)
noexcept
=
0
;
virtual
nostd
:
:
unique_ptr
<
Token
>
Attach
(
const
Context
&
context
)
noexcept
=
0
;
virtual
bool
Detach
(
Token
&
token
)
noexcept
=
0
;
virtual
~
RuntimeContextStorage
(
)
{
}
protected
:
nostd
:
:
unique_ptr
<
Token
>
CreateToken
(
const
Context
&
context
)
noexcept
{
return
nostd
:
:
unique_ptr
<
Token
>
(
new
Token
(
context
)
)
;
}
}
;
static
RuntimeContextStorage
*
GetDefaultStorage
(
)
noexcept
;
class
OPENTELEMETRY_EXPORT
RuntimeContext
{
public
:
static
Context
GetCurrent
(
)
noexcept
{
return
GetRuntimeContextStorage
(
)
-
>
GetCurrent
(
)
;
}
static
nostd
:
:
unique_ptr
<
Token
>
Attach
(
const
Context
&
context
)
noexcept
{
return
GetRuntimeContextStorage
(
)
-
>
Attach
(
context
)
;
}
static
bool
Detach
(
Token
&
token
)
noexcept
{
return
GetRuntimeContextStorage
(
)
-
>
Detach
(
token
)
;
}
static
Context
SetValue
(
nostd
:
:
string_view
key
const
ContextValue
&
value
Context
*
context
=
nullptr
)
noexcept
{
Context
temp_context
;
if
(
context
=
=
nullptr
)
{
temp_context
=
GetCurrent
(
)
;
}
else
{
temp_context
=
*
context
;
}
return
temp_context
.
SetValue
(
key
value
)
;
}
static
ContextValue
GetValue
(
nostd
:
:
string_view
key
Context
*
context
=
nullptr
)
noexcept
{
Context
temp_context
;
if
(
context
=
=
nullptr
)
{
temp_context
=
GetCurrent
(
)
;
}
else
{
temp_context
=
*
context
;
}
return
temp_context
.
GetValue
(
key
)
;
}
static
void
SetRuntimeContextStorage
(
nostd
:
:
shared_ptr
<
RuntimeContextStorage
>
storage
)
noexcept
{
GetStorage
(
)
=
storage
;
}
static
nostd
:
:
shared_ptr
<
const
RuntimeContextStorage
>
GetConstRuntimeContextStorage
(
)
noexcept
{
return
GetRuntimeContextStorage
(
)
;
}
private
:
static
nostd
:
:
shared_ptr
<
RuntimeContextStorage
>
GetRuntimeContextStorage
(
)
noexcept
{
return
GetStorage
(
)
;
}
OPENTELEMETRY_API_SINGLETON
static
nostd
:
:
shared_ptr
<
RuntimeContextStorage
>
&
GetStorage
(
)
noexcept
{
static
nostd
:
:
shared_ptr
<
RuntimeContextStorage
>
context
(
GetDefaultStorage
(
)
)
;
return
context
;
}
}
;
inline
Token
:
:
~
Token
(
)
noexcept
{
context
:
:
RuntimeContext
:
:
Detach
(
*
this
)
;
}
class
ThreadLocalContextStorage
:
public
RuntimeContextStorage
{
public
:
ThreadLocalContextStorage
(
)
noexcept
=
default
;
Context
GetCurrent
(
)
noexcept
override
{
return
GetStack
(
)
.
Top
(
)
;
}
bool
Detach
(
Token
&
token
)
noexcept
override
{
if
(
token
=
=
GetStack
(
)
.
Top
(
)
)
{
GetStack
(
)
.
Pop
(
)
;
return
true
;
}
if
(
!
GetStack
(
)
.
Contains
(
token
)
)
{
return
false
;
}
while
(
!
(
token
=
=
GetStack
(
)
.
Top
(
)
)
)
{
GetStack
(
)
.
Pop
(
)
;
}
GetStack
(
)
.
Pop
(
)
;
return
true
;
}
nostd
:
:
unique_ptr
<
Token
>
Attach
(
const
Context
&
context
)
noexcept
override
{
GetStack
(
)
.
Push
(
context
)
;
return
CreateToken
(
context
)
;
}
private
:
class
Stack
{
friend
class
ThreadLocalContextStorage
;
Stack
(
)
noexcept
:
size_
(
0
)
capacity_
(
0
)
base_
(
nullptr
)
{
}
void
Pop
(
)
noexcept
{
if
(
size_
=
=
0
)
{
return
;
}
base_
[
size_
-
1
]
=
Context
(
)
;
size_
-
=
1
;
}
bool
Contains
(
const
Token
&
token
)
const
noexcept
{
for
(
size_t
pos
=
size_
;
pos
>
0
;
-
-
pos
)
{
if
(
token
=
=
base_
[
pos
-
1
]
)
{
return
true
;
}
}
return
false
;
}
Context
Top
(
)
const
noexcept
{
if
(
size_
=
=
0
)
{
return
Context
(
)
;
}
return
base_
[
size_
-
1
]
;
}
void
Push
(
const
Context
&
context
)
noexcept
{
size_
+
+
;
if
(
size_
>
capacity_
)
{
Resize
(
size_
*
2
)
;
}
base_
[
size_
-
1
]
=
context
;
}
void
Resize
(
size_t
new_capacity
)
noexcept
{
size_t
old_size
=
size_
-
1
;
if
(
new_capacity
=
=
0
)
{
new_capacity
=
2
;
}
Context
*
temp
=
new
Context
[
new_capacity
]
;
if
(
base_
!
=
nullptr
)
{
for
(
size_t
i
=
0
;
i
<
(
std
:
:
min
)
(
old_size
new_capacity
)
;
i
+
+
)
{
temp
[
i
]
=
base_
[
i
]
;
}
delete
[
]
base_
;
}
base_
=
temp
;
capacity_
=
new_capacity
;
}
~
Stack
(
)
noexcept
{
delete
[
]
base_
;
}
size_t
size_
;
size_t
capacity_
;
Context
*
base_
;
}
;
OPENTELEMETRY_API_SINGLETON
Stack
&
GetStack
(
)
{
static
thread_local
Stack
stack_
=
Stack
(
)
;
return
stack_
;
}
}
;
static
RuntimeContextStorage
*
GetDefaultStorage
(
)
noexcept
{
return
new
ThreadLocalContextStorage
(
)
;
}
}
OPENTELEMETRY_END_NAMESPACE
