#
pragma
once
#
include
<
cstring
>
#
include
<
utility
>
#
include
"
opentelemetry
/
context
/
context_value
.
h
"
#
include
"
opentelemetry
/
nostd
/
shared_ptr
.
h
"
#
include
"
opentelemetry
/
nostd
/
string_view
.
h
"
#
include
"
opentelemetry
/
nostd
/
variant
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
context
{
class
Context
{
public
:
Context
(
)
=
default
;
template
<
class
T
>
Context
(
const
T
&
keys_and_values
)
noexcept
:
head_
{
nostd
:
:
shared_ptr
<
DataList
>
{
new
DataList
(
keys_and_values
)
}
}
{
}
Context
(
nostd
:
:
string_view
key
ContextValue
value
)
noexcept
:
head_
{
nostd
:
:
shared_ptr
<
DataList
>
{
new
DataList
(
key
value
)
}
}
{
}
template
<
class
T
>
Context
SetValues
(
T
&
values
)
noexcept
{
Context
context
=
Context
(
values
)
;
nostd
:
:
shared_ptr
<
DataList
>
last
=
context
.
head_
;
while
(
last
-
>
next_
!
=
nullptr
)
{
last
=
last
-
>
next_
;
}
last
-
>
next_
=
head_
;
return
context
;
}
Context
SetValue
(
nostd
:
:
string_view
key
ContextValue
value
)
noexcept
{
Context
context
=
Context
(
key
value
)
;
context
.
head_
-
>
next_
=
head_
;
return
context
;
}
context
:
:
ContextValue
GetValue
(
const
nostd
:
:
string_view
key
)
const
noexcept
{
for
(
DataList
*
data
=
head_
.
get
(
)
;
data
!
=
nullptr
;
data
=
data
-
>
next_
.
get
(
)
)
{
if
(
key
.
size
(
)
=
=
data
-
>
key_length_
)
{
if
(
std
:
:
memcmp
(
key
.
data
(
)
data
-
>
key_
data
-
>
key_length_
)
=
=
0
)
{
return
data
-
>
value_
;
}
}
}
return
ContextValue
{
}
;
}
bool
HasKey
(
const
nostd
:
:
string_view
key
)
const
noexcept
{
return
!
nostd
:
:
holds_alternative
<
nostd
:
:
monostate
>
(
GetValue
(
key
)
)
;
}
bool
operator
=
=
(
const
Context
&
other
)
const
noexcept
{
return
(
head_
=
=
other
.
head_
)
;
}
private
:
struct
DataList
{
char
*
key_
=
nullptr
;
nostd
:
:
shared_ptr
<
DataList
>
next_
{
nullptr
}
;
size_t
key_length_
=
0UL
;
ContextValue
value_
;
DataList
(
)
=
default
;
template
<
class
T
>
DataList
(
const
T
&
keys_and_vals
)
{
bool
first
=
true
;
auto
*
node
=
this
;
for
(
auto
&
iter
:
keys_and_vals
)
{
if
(
first
)
{
*
node
=
DataList
(
iter
.
first
iter
.
second
)
;
first
=
false
;
}
else
{
node
-
>
next_
=
nostd
:
:
shared_ptr
<
DataList
>
(
new
DataList
(
iter
.
first
iter
.
second
)
)
;
node
=
node
-
>
next_
.
get
(
)
;
}
}
}
DataList
(
nostd
:
:
string_view
key
const
ContextValue
&
value
)
{
key_
=
new
char
[
key
.
size
(
)
]
;
key_length_
=
key
.
size
(
)
;
std
:
:
memcpy
(
key_
key
.
data
(
)
key
.
size
(
)
*
sizeof
(
char
)
)
;
next_
=
nostd
:
:
shared_ptr
<
DataList
>
{
nullptr
}
;
value_
=
value
;
}
DataList
(
const
DataList
&
other
)
:
key_
(
new
char
[
other
.
key_length_
]
)
next_
(
other
.
next_
)
key_length_
(
other
.
key_length_
)
value_
(
other
.
value_
)
{
std
:
:
memcpy
(
key_
other
.
key_
other
.
key_length_
*
sizeof
(
char
)
)
;
}
DataList
&
operator
=
(
DataList
&
&
other
)
noexcept
{
key_length_
=
other
.
key_length_
;
value_
=
std
:
:
move
(
other
.
value_
)
;
next_
=
std
:
:
move
(
other
.
next_
)
;
key_
=
other
.
key_
;
other
.
key_
=
nullptr
;
return
*
this
;
}
~
DataList
(
)
{
if
(
key_
!
=
nullptr
)
{
delete
[
]
key_
;
}
}
}
;
nostd
:
:
shared_ptr
<
DataList
>
head_
;
}
;
}
OPENTELEMETRY_END_NAMESPACE
