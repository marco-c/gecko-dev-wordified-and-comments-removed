#
pragma
once
#
include
<
ctype
.
h
>
#
include
<
cstddef
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
opentelemetry
/
common
/
kv_properties
.
h
"
#
include
"
opentelemetry
/
nostd
/
function_ref
.
h
"
#
include
"
opentelemetry
/
nostd
/
shared_ptr
.
h
"
#
include
"
opentelemetry
/
nostd
/
string_view
.
h
"
#
include
"
opentelemetry
/
nostd
/
unique_ptr
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
#
if
OPENTELEMETRY_HAVE_WORKING_REGEX
#
include
<
regex
>
#
endif
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
trace
{
class
OPENTELEMETRY_EXPORT
TraceState
{
public
:
static
constexpr
int
kKeyMaxSize
=
256
;
static
constexpr
int
kValueMaxSize
=
256
;
static
constexpr
int
kMaxKeyValuePairs
=
32
;
static
constexpr
auto
kKeyValueSeparator
=
'
=
'
;
static
constexpr
auto
kMembersSeparator
=
'
'
;
OPENTELEMETRY_API_SINGLETON
static
nostd
:
:
shared_ptr
<
TraceState
>
GetDefault
(
)
{
static
nostd
:
:
shared_ptr
<
TraceState
>
ts
{
new
TraceState
(
)
}
;
return
ts
;
}
static
nostd
:
:
shared_ptr
<
TraceState
>
FromHeader
(
nostd
:
:
string_view
header
)
noexcept
{
common
:
:
KeyValueStringTokenizer
kv_str_tokenizer
(
header
)
;
size_t
cnt
=
kv_str_tokenizer
.
NumTokens
(
)
;
if
(
cnt
>
kMaxKeyValuePairs
)
{
return
GetDefault
(
)
;
}
nostd
:
:
shared_ptr
<
TraceState
>
ts
(
new
TraceState
(
cnt
)
)
;
bool
kv_valid
;
nostd
:
:
string_view
key
value
;
while
(
kv_str_tokenizer
.
next
(
kv_valid
key
value
)
&
&
ts
-
>
kv_properties_
-
>
Size
(
)
<
cnt
)
{
if
(
kv_valid
=
=
false
)
{
return
GetDefault
(
)
;
}
if
(
!
IsValidKey
(
key
)
|
|
!
IsValidValue
(
value
)
)
{
ts
-
>
kv_properties_
.
reset
(
new
common
:
:
KeyValueProperties
(
)
)
;
break
;
}
ts
-
>
kv_properties_
-
>
AddEntry
(
key
value
)
;
}
return
ts
;
}
std
:
:
string
ToHeader
(
)
const
noexcept
{
std
:
:
string
header_s
;
bool
first
=
true
;
kv_properties_
-
>
GetAllEntries
(
[
&
header_s
&
first
]
(
nostd
:
:
string_view
key
nostd
:
:
string_view
value
)
noexcept
{
if
(
!
first
)
{
header_s
.
append
(
1
kMembersSeparator
)
;
}
else
{
first
=
false
;
}
header_s
.
append
(
std
:
:
string
(
key
.
data
(
)
key
.
size
(
)
)
)
;
header_s
.
append
(
1
kKeyValueSeparator
)
;
header_s
.
append
(
std
:
:
string
(
value
.
data
(
)
value
.
size
(
)
)
)
;
return
true
;
}
)
;
return
header_s
;
}
bool
Get
(
nostd
:
:
string_view
key
std
:
:
string
&
value
)
const
noexcept
{
if
(
!
IsValidKey
(
key
)
)
{
return
false
;
}
return
kv_properties_
-
>
GetValue
(
key
value
)
;
}
nostd
:
:
shared_ptr
<
TraceState
>
Set
(
const
nostd
:
:
string_view
&
key
const
nostd
:
:
string_view
&
value
)
noexcept
{
auto
curr_size
=
kv_properties_
-
>
Size
(
)
;
if
(
!
IsValidKey
(
key
)
|
|
!
IsValidValue
(
value
)
)
{
return
TraceState
:
:
GetDefault
(
)
;
}
auto
allocate_size
=
curr_size
;
if
(
curr_size
<
kMaxKeyValuePairs
)
{
allocate_size
+
=
1
;
}
nostd
:
:
shared_ptr
<
TraceState
>
ts
(
new
TraceState
(
allocate_size
)
)
;
if
(
curr_size
<
kMaxKeyValuePairs
)
{
ts
-
>
kv_properties_
-
>
AddEntry
(
key
value
)
;
}
kv_properties_
-
>
GetAllEntries
(
[
&
ts
]
(
nostd
:
:
string_view
key
nostd
:
:
string_view
value
)
{
ts
-
>
kv_properties_
-
>
AddEntry
(
key
value
)
;
return
true
;
}
)
;
return
ts
;
}
nostd
:
:
shared_ptr
<
TraceState
>
Delete
(
const
nostd
:
:
string_view
&
key
)
noexcept
{
if
(
!
IsValidKey
(
key
)
)
{
return
TraceState
:
:
GetDefault
(
)
;
}
auto
curr_size
=
kv_properties_
-
>
Size
(
)
;
auto
allocate_size
=
curr_size
;
std
:
:
string
unused
;
if
(
kv_properties_
-
>
GetValue
(
key
unused
)
)
{
allocate_size
-
=
1
;
}
nostd
:
:
shared_ptr
<
TraceState
>
ts
(
new
TraceState
(
allocate_size
)
)
;
kv_properties_
-
>
GetAllEntries
(
[
&
ts
&
key
]
(
nostd
:
:
string_view
e_key
nostd
:
:
string_view
e_value
)
{
if
(
key
!
=
e_key
)
ts
-
>
kv_properties_
-
>
AddEntry
(
e_key
e_value
)
;
return
true
;
}
)
;
return
ts
;
}
bool
Empty
(
)
const
noexcept
{
return
kv_properties_
-
>
Size
(
)
=
=
0
;
}
bool
GetAllEntries
(
nostd
:
:
function_ref
<
bool
(
nostd
:
:
string_view
nostd
:
:
string_view
)
>
callback
)
const
noexcept
{
return
kv_properties_
-
>
GetAllEntries
(
callback
)
;
}
static
bool
IsValidKey
(
nostd
:
:
string_view
key
)
{
#
if
OPENTELEMETRY_HAVE_WORKING_REGEX
return
IsValidKeyRegEx
(
key
)
;
#
else
return
IsValidKeyNonRegEx
(
key
)
;
#
endif
}
static
bool
IsValidValue
(
nostd
:
:
string_view
value
)
{
#
if
OPENTELEMETRY_HAVE_WORKING_REGEX
return
IsValidValueRegEx
(
value
)
;
#
else
return
IsValidValueNonRegEx
(
value
)
;
#
endif
}
private
:
TraceState
(
)
:
kv_properties_
(
new
common
:
:
KeyValueProperties
(
)
)
{
}
TraceState
(
size_t
size
)
:
kv_properties_
(
new
common
:
:
KeyValueProperties
(
size
)
)
{
}
static
nostd
:
:
string_view
TrimString
(
nostd
:
:
string_view
str
size_t
left
size_t
right
)
{
while
(
str
[
static_cast
<
std
:
:
size_t
>
(
right
)
]
=
=
'
'
&
&
left
<
right
)
{
right
-
-
;
}
while
(
str
[
static_cast
<
std
:
:
size_t
>
(
left
)
]
=
=
'
'
&
&
left
<
right
)
{
left
+
+
;
}
return
str
.
substr
(
left
right
-
left
+
1
)
;
}
#
if
OPENTELEMETRY_HAVE_WORKING_REGEX
static
bool
IsValidKeyRegEx
(
nostd
:
:
string_view
key
)
{
static
std
:
:
regex
reg_key
(
"
^
[
a
-
z0
-
9
]
[
a
-
z0
-
9
*
_
\
\
-
/
]
{
0
255
}
"
)
;
static
std
:
:
regex
reg_key_multitenant
(
"
^
[
a
-
z0
-
9
]
[
a
-
z0
-
9
*
_
\
\
-
/
]
{
0
240
}
(
)
[
a
-
z0
-
9
]
[
a
-
z0
-
9
*
_
\
\
-
/
]
{
0
13
}
"
)
;
std
:
:
string
key_s
(
key
.
data
(
)
key
.
size
(
)
)
;
if
(
std
:
:
regex_match
(
key_s
reg_key
)
|
|
std
:
:
regex_match
(
key_s
reg_key_multitenant
)
)
{
return
true
;
}
return
false
;
}
static
bool
IsValidValueRegEx
(
nostd
:
:
string_view
value
)
{
static
std
:
:
regex
reg_value
(
"
^
[
\
\
x20
-
\
\
x2B
\
\
x2D
-
\
\
x3C
\
\
x3E
-
\
\
x7E
]
{
0
255
}
[
\
\
x21
-
\
\
x2B
\
\
x2D
-
\
\
x3C
\
\
x3E
-
\
\
x7E
]
"
)
;
return
std
:
:
regex_match
(
std
:
:
string
(
value
.
data
(
)
value
.
size
(
)
)
reg_value
)
;
}
#
else
static
bool
IsValidKeyNonRegEx
(
nostd
:
:
string_view
key
)
{
if
(
key
.
empty
(
)
|
|
key
.
size
(
)
>
kKeyMaxSize
|
|
!
IsLowerCaseAlphaOrDigit
(
key
[
0
]
)
)
{
return
false
;
}
int
ats
=
0
;
for
(
const
char
c
:
key
)
{
if
(
!
IsLowerCaseAlphaOrDigit
(
c
)
&
&
c
!
=
'
_
'
&
&
c
!
=
'
-
'
&
&
c
!
=
'
'
&
&
c
!
=
'
*
'
&
&
c
!
=
'
/
'
)
{
return
false
;
}
if
(
(
c
=
=
'
'
)
&
&
(
+
+
ats
>
1
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsValidValueNonRegEx
(
nostd
:
:
string_view
value
)
{
if
(
value
.
empty
(
)
|
|
value
.
size
(
)
>
kValueMaxSize
)
{
return
false
;
}
for
(
const
char
c
:
value
)
{
if
(
c
<
'
'
|
|
c
>
'
~
'
|
|
c
=
=
'
'
|
|
c
=
=
'
=
'
)
{
return
false
;
}
}
return
true
;
}
#
endif
static
bool
IsLowerCaseAlphaOrDigit
(
char
c
)
{
return
isdigit
(
c
)
|
|
islower
(
c
)
;
}
private
:
nostd
:
:
unique_ptr
<
common
:
:
KeyValueProperties
>
kv_properties_
;
}
;
}
OPENTELEMETRY_END_NAMESPACE
