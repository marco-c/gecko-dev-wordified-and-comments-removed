#
pragma
once
#
include
<
chrono
>
#
include
"
opentelemetry
/
context
/
context
.
h
"
#
include
"
opentelemetry
/
nostd
/
shared_ptr
.
h
"
#
include
"
opentelemetry
/
nostd
/
string_view
.
h
"
#
include
"
opentelemetry
/
trace
/
default_span
.
h
"
#
include
"
opentelemetry
/
trace
/
scope
.
h
"
#
include
"
opentelemetry
/
trace
/
span
.
h
"
#
include
"
opentelemetry
/
trace
/
span_context_kv_iterable_view
.
h
"
#
include
"
opentelemetry
/
trace
/
span_startoptions
.
h
"
#
include
"
opentelemetry
/
version
.
h
"
OPENTELEMETRY_BEGIN_NAMESPACE
namespace
trace
{
class
Tracer
{
public
:
virtual
~
Tracer
(
)
=
default
;
virtual
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
const
common
:
:
KeyValueIterable
&
attributes
const
SpanContextKeyValueIterable
&
links
const
StartSpanOptions
&
options
=
{
}
)
noexcept
=
0
;
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
{
}
{
}
options
)
;
}
template
<
class
T
nostd
:
:
enable_if_t
<
common
:
:
detail
:
:
is_key_value_iterable
<
T
>
:
:
value
>
*
=
nullptr
>
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
const
T
&
attributes
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
attributes
{
}
options
)
;
}
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
const
common
:
:
KeyValueIterable
&
attributes
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
attributes
NullSpanContext
(
)
options
)
;
}
template
<
class
T
class
U
nostd
:
:
enable_if_t
<
common
:
:
detail
:
:
is_key_value_iterable
<
T
>
:
:
value
>
*
=
nullptr
nostd
:
:
enable_if_t
<
detail
:
:
is_span_context_kv_iterable
<
U
>
:
:
value
>
*
=
nullptr
>
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
const
T
&
attributes
const
U
&
links
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
common
:
:
KeyValueIterableView
<
T
>
(
attributes
)
SpanContextKeyValueIterableView
<
U
>
(
links
)
options
)
;
}
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
attributes
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
attributes
{
}
options
)
;
}
template
<
class
T
nostd
:
:
enable_if_t
<
common
:
:
detail
:
:
is_key_value_iterable
<
T
>
:
:
value
>
*
=
nullptr
>
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
const
T
&
attributes
std
:
:
initializer_list
<
std
:
:
pair
<
SpanContext
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
>
>
links
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
attributes
nostd
:
:
span
<
const
std
:
:
pair
<
SpanContext
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
>
>
{
links
.
begin
(
)
links
.
end
(
)
}
options
)
;
}
template
<
class
T
nostd
:
:
enable_if_t
<
common
:
:
detail
:
:
is_key_value_iterable
<
T
>
:
:
value
>
*
=
nullptr
>
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
attributes
const
T
&
links
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
nostd
:
:
span
<
const
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
{
attributes
.
begin
(
)
attributes
.
end
(
)
}
links
options
)
;
}
nostd
:
:
shared_ptr
<
Span
>
StartSpan
(
nostd
:
:
string_view
name
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
attributes
std
:
:
initializer_list
<
std
:
:
pair
<
SpanContext
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
>
>
links
const
StartSpanOptions
&
options
=
{
}
)
noexcept
{
return
this
-
>
StartSpan
(
name
nostd
:
:
span
<
const
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
{
attributes
.
begin
(
)
attributes
.
end
(
)
}
nostd
:
:
span
<
const
std
:
:
pair
<
SpanContext
std
:
:
initializer_list
<
std
:
:
pair
<
nostd
:
:
string_view
common
:
:
AttributeValue
>
>
>
>
{
links
.
begin
(
)
links
.
end
(
)
}
options
)
;
}
static
Scope
WithActiveSpan
(
nostd
:
:
shared_ptr
<
Span
>
&
span
)
noexcept
{
return
Scope
{
span
}
;
}
static
nostd
:
:
shared_ptr
<
Span
>
GetCurrentSpan
(
)
noexcept
{
context
:
:
ContextValue
active_span
=
context
:
:
RuntimeContext
:
:
GetValue
(
kSpanKey
)
;
if
(
nostd
:
:
holds_alternative
<
nostd
:
:
shared_ptr
<
Span
>
>
(
active_span
)
)
{
return
nostd
:
:
get
<
nostd
:
:
shared_ptr
<
Span
>
>
(
active_span
)
;
}
else
{
return
nostd
:
:
shared_ptr
<
Span
>
(
new
DefaultSpan
(
SpanContext
:
:
GetInvalid
(
)
)
)
;
}
}
#
if
OPENTELEMETRY_ABI_VERSION_NO
>
=
2
bool
Enabled
(
)
const
noexcept
{
return
OPENTELEMETRY_ATOMIC_READ_8
(
&
this
-
>
enabled_
)
!
=
0
;
}
#
endif
#
if
OPENTELEMETRY_ABI_VERSION_NO
=
=
1
template
<
class
Rep
class
Period
>
void
ForceFlush
(
std
:
:
chrono
:
:
duration
<
Rep
Period
>
timeout
)
noexcept
{
this
-
>
ForceFlushWithMicroseconds
(
static_cast
<
uint64_t
>
(
std
:
:
chrono
:
:
duration_cast
<
std
:
:
chrono
:
:
microseconds
>
(
timeout
)
.
count
(
)
)
)
;
}
virtual
void
ForceFlushWithMicroseconds
(
uint64_t
timeout
)
noexcept
=
0
;
template
<
class
Rep
class
Period
>
void
Close
(
std
:
:
chrono
:
:
duration
<
Rep
Period
>
timeout
)
noexcept
{
this
-
>
CloseWithMicroseconds
(
static_cast
<
uint64_t
>
(
std
:
:
chrono
:
:
duration_cast
<
std
:
:
chrono
:
:
microseconds
>
(
timeout
)
.
count
(
)
)
)
;
}
virtual
void
CloseWithMicroseconds
(
uint64_t
timeout
)
noexcept
=
0
;
#
endif
protected
:
#
if
OPENTELEMETRY_ABI_VERSION_NO
>
=
2
void
UpdateEnabled
(
const
bool
enabled
)
noexcept
{
OPENTELEMETRY_ATOMIC_WRITE_8
(
&
this
-
>
enabled_
enabled
)
;
}
#
endif
private
:
#
if
OPENTELEMETRY_ABI_VERSION_NO
>
=
2
mutable
bool
enabled_
=
true
;
#
endif
}
;
}
OPENTELEMETRY_END_NAMESPACE
