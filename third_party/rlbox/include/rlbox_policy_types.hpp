#
pragma
once
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
rlbox_helpers
.
hpp
"
#
include
"
rlbox_struct_support
.
hpp
"
#
include
"
rlbox_types
.
hpp
"
namespace
rlbox
{
namespace
callback_detail
{
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
using
T_Cb
=
std
:
:
conditional_t
<
std
:
:
is_void_v
<
T_Ret
>
void
tainted
<
T_Ret
T_Sbx
>
>
(
*
)
(
rlbox_sandbox
<
T_Sbx
>
&
tainted
<
T_Args
T_Sbx
>
.
.
.
)
;
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
T_Cb
<
T_Sbx
T_Ret
T_Args
.
.
.
>
callback_type_helper
(
T_Ret
(
*
)
(
T_Args
.
.
.
)
)
;
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
using
T_I
=
detail
:
:
convert_to_sandbox_equivalent_t
<
T_Ret
T_Sbx
>
(
*
)
(
detail
:
:
convert_to_sandbox_equivalent_t
<
T_Args
T_Sbx
>
.
.
.
)
;
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
T_I
<
T_Sbx
T_Ret
T_Args
.
.
.
>
interceptor_type_helper
(
T_Ret
(
*
)
(
T_Args
.
.
.
)
)
;
}
template
<
typename
T
typename
T_Sbx
>
class
sandbox_callback
{
KEEP_CLASSES_FRIENDLY
private
:
rlbox_sandbox
<
T_Sbx
>
*
sandbox
;
using
T_Callback
=
decltype
(
callback_detail
:
:
callback_type_helper
<
T_Sbx
>
(
std
:
:
declval
<
T
>
(
)
)
)
;
T_Callback
callback
;
using
T_Interceptor
=
decltype
(
callback_detail
:
:
interceptor_type_helper
<
T_Sbx
>
(
std
:
:
declval
<
T
>
(
)
)
)
;
T_Interceptor
callback_interceptor
;
using
T_Trampoline
=
detail
:
:
convert_to_sandbox_equivalent_t
<
T
T_Sbx
>
;
T_Trampoline
callback_trampoline
;
void
*
key
;
inline
void
move_obj
(
sandbox_callback
&
&
other
)
{
sandbox
=
other
.
sandbox
;
callback
=
other
.
callback
;
callback_interceptor
=
other
.
callback_interceptor
;
callback_trampoline
=
other
.
callback_trampoline
;
key
=
other
.
key
;
other
.
sandbox
=
nullptr
;
other
.
callback
=
nullptr
;
other
.
callback_interceptor
=
nullptr
;
other
.
callback_trampoline
=
0
;
other
.
key
=
nullptr
;
}
template
<
typename
T_Ret
typename
.
.
.
T_Args
>
inline
void
unregister_helper
(
T_Ret
(
*
)
(
T_Args
.
.
.
)
)
{
if
(
callback
!
=
nullptr
)
{
sandbox
-
>
template
unregister_callback
<
T_Ret
T_Args
.
.
.
>
(
key
)
;
sandbox
=
nullptr
;
callback
=
nullptr
;
callback_interceptor
=
nullptr
;
callback_trampoline
=
0
;
key
=
nullptr
;
}
}
inline
T_Callback
get_raw_value
(
)
const
noexcept
{
return
callback
;
}
inline
T_Trampoline
get_raw_sandbox_value
(
)
const
noexcept
{
return
callback_trampoline
;
}
sandbox_callback
(
rlbox_sandbox
<
T_Sbx
>
*
p_sandbox
T_Callback
p_callback
T_Interceptor
p_callback_interceptor
T_Trampoline
p_callback_trampoline
void
*
p_key
)
:
sandbox
(
p_sandbox
)
callback
(
p_callback
)
callback_interceptor
(
p_callback_interceptor
)
callback_trampoline
(
p_callback_trampoline
)
key
(
p_key
)
{
detail
:
:
dynamic_check
(
sandbox
!
=
nullptr
"
Unexpected
null
sandbox
when
creating
a
callback
"
)
;
}
public
:
sandbox_callback
(
)
:
sandbox
(
nullptr
)
callback
(
nullptr
)
callback_interceptor
(
nullptr
)
callback_trampoline
(
0
)
key
(
nullptr
)
{
}
sandbox_callback
(
sandbox_callback
&
&
other
)
{
move_obj
(
std
:
:
forward
<
sandbox_callback
>
(
other
)
)
;
}
inline
sandbox_callback
&
operator
=
(
sandbox_callback
&
&
other
)
{
if
(
this
!
=
&
other
)
{
move_obj
(
std
:
:
forward
<
sandbox_callback
>
(
other
)
)
;
}
return
*
this
;
}
void
unregister
(
)
{
T
dummy
=
nullptr
;
unregister_helper
(
dummy
)
;
}
~
sandbox_callback
(
)
{
unregister
(
)
;
}
inline
bool
is_unregistered
(
)
const
noexcept
{
return
get_raw_value
(
)
=
=
nullptr
;
}
inline
auto
UNSAFE_unverified
(
)
const
noexcept
{
return
get_raw_value
(
)
;
}
inline
auto
UNSAFE_sandboxed
(
rlbox_sandbox
<
T_Sbx
>
&
sandbox
)
const
noexcept
{
RLBOX_UNUSED
(
sandbox
)
;
return
get_raw_sandbox_value
(
)
;
}
}
;
template
<
typename
T
typename
T_Sbx
>
class
app_pointer
{
KEEP_CLASSES_FRIENDLY
private
:
app_pointer_map
<
typename
T_Sbx
:
:
T_PointerType
>
*
map
;
typename
T_Sbx
:
:
T_PointerType
idx
;
T
idx_unsandboxed
;
inline
void
move_obj
(
app_pointer
&
&
other
)
{
map
=
other
.
map
;
idx
=
other
.
idx
;
idx_unsandboxed
=
other
.
idx_unsandboxed
;
other
.
map
=
nullptr
;
other
.
idx
=
0
;
other
.
idx_unsandboxed
=
nullptr
;
}
inline
T
get_raw_value
(
)
const
noexcept
{
return
to_tainted
(
)
.
get_raw_value
(
)
;
}
inline
typename
T_Sbx
:
:
T_PointerType
get_raw_sandbox_value
(
)
const
noexcept
{
return
idx
;
}
app_pointer
(
app_pointer_map
<
typename
T_Sbx
:
:
T_PointerType
>
*
a_map
typename
T_Sbx
:
:
T_PointerType
a_idx
T
a_idx_unsandboxed
)
:
map
(
a_map
)
idx
(
a_idx
)
idx_unsandboxed
(
a_idx_unsandboxed
)
{
}
public
:
app_pointer
(
)
:
map
(
nullptr
)
idx
(
0
)
idx_unsandboxed
(
0
)
{
}
~
app_pointer
(
)
{
unregister
(
)
;
}
app_pointer
(
app_pointer
&
&
other
)
{
move_obj
(
std
:
:
forward
<
app_pointer
>
(
other
)
)
;
}
inline
app_pointer
&
operator
=
(
app_pointer
&
&
other
)
{
if
(
this
!
=
&
other
)
{
move_obj
(
std
:
:
forward
<
app_pointer
>
(
other
)
)
;
}
return
*
this
;
}
void
unregister
(
)
{
if
(
idx
!
=
0
)
{
map
-
>
remove_app_ptr
(
idx
)
;
map
=
nullptr
;
idx
=
0
;
idx_unsandboxed
=
nullptr
;
}
}
tainted
<
T
T_Sbx
>
to_tainted
(
)
{
return
tainted
<
T
T_Sbx
>
:
:
internal_factory
(
reinterpret_cast
<
T
>
(
idx_unsandboxed
)
)
;
}
inline
bool
is_unregistered
(
)
const
noexcept
{
return
idx
=
=
0
;
}
inline
auto
UNSAFE_unverified
(
)
const
noexcept
{
return
get_raw_value
(
)
;
}
inline
auto
UNSAFE_sandboxed
(
rlbox_sandbox
<
T_Sbx
>
&
sandbox
)
const
noexcept
{
RLBOX_UNUSED
(
sandbox
)
;
return
get_raw_sandbox_value
(
)
;
}
}
;
class
tainted_boolean_hint
{
private
:
bool
val
;
public
:
tainted_boolean_hint
(
bool
init
)
:
val
(
init
)
{
}
tainted_boolean_hint
(
const
tainted_boolean_hint
&
)
=
default
;
inline
tainted_boolean_hint
&
operator
=
(
bool
rhs
)
{
val
=
rhs
;
return
*
this
;
}
inline
tainted_boolean_hint
operator
!
(
)
const
{
return
tainted_boolean_hint
(
!
val
)
;
}
template
<
size_t
N
>
inline
bool
unverified_safe_because
(
const
char
(
&
reason
)
[
N
]
)
const
{
(
void
)
reason
;
return
val
;
}
inline
bool
UNSAFE_unverified
(
)
const
{
return
val
;
}
inline
auto
INTERNAL_unverified_safe
(
)
const
{
return
UNSAFE_unverified
(
)
;
}
template
<
typename
T
=
void
>
inline
bool
copy_and_verify
(
.
.
.
)
const
{
rlbox_detail_static_fail_because
(
detail
:
:
true_v
<
T
>
"
You
can
'
t
call
copy_and_verify
on
this
value
as
this
is
a
result
of
a
"
"
comparison
with
memory
accessible
by
the
sandbox
.
\
n
"
"
The
sandbox
could
unexpectedly
change
the
value
leading
to
"
"
time
-
of
-
check
-
time
-
of
-
use
attacks
.
\
n
"
"
You
can
avoid
this
by
making
a
local
copy
of
the
data
.
"
"
For
example
if
your
original
code
looked
like
\
n
"
"
if
(
(
tainted_ptr
-
>
member
=
=
5
)
.
copy_and_verify
(
.
.
.
)
)
{
.
.
.
}
\
n
\
n
"
"
Change
this
to
\
n
\
n
"
"
tainted
<
int
>
val
=
tainted_ptr
-
>
member
\
n
"
"
if
(
(
val
=
=
5
)
.
copy_and_verify
(
.
.
.
)
)
{
.
.
.
}
\
n
\
n
"
"
tainted
<
int
T_Sbx
>
foo
(
rlbox_sandbox
<
T_Sbx
>
&
sandbox
)
{
.
.
.
}
\
n
\
n
"
"
Alternately
if
you
are
sure
your
code
is
safe
you
can
use
the
"
"
unverified_safe_because
API
to
remove
tainting
\
n
"
)
;
return
false
;
}
}
;
class
tainted_int_hint
{
private
:
int
val
;
public
:
tainted_int_hint
(
int
init
)
:
val
(
init
)
{
}
tainted_int_hint
(
const
tainted_int_hint
&
)
=
default
;
inline
tainted_int_hint
&
operator
=
(
int
rhs
)
{
val
=
rhs
;
return
*
this
;
}
inline
tainted_boolean_hint
operator
!
(
)
const
{
return
tainted_boolean_hint
(
!
val
)
;
}
template
<
size_t
N
>
inline
int
unverified_safe_because
(
const
char
(
&
reason
)
[
N
]
)
const
{
(
void
)
reason
;
return
val
;
}
inline
int
UNSAFE_unverified
(
)
const
{
return
val
;
}
inline
auto
INTERNAL_unverified_safe
(
)
const
{
return
UNSAFE_unverified
(
)
;
}
template
<
typename
T
=
void
>
inline
int
copy_and_verify
(
.
.
.
)
const
{
rlbox_detail_static_fail_because
(
detail
:
:
true_v
<
T
>
"
You
can
'
t
call
copy_and_verify
on
this
value
as
this
is
a
result
of
a
"
"
comparison
with
memory
accessible
by
the
sandbox
.
\
n
"
"
The
sandbox
could
unexpectedly
change
the
value
leading
to
"
"
time
-
of
-
check
-
time
-
of
-
use
attacks
.
\
n
"
"
You
can
avoid
this
by
making
a
local
copy
of
the
data
.
"
"
For
example
if
your
original
code
looked
like
\
n
"
"
if
(
(
tainted_ptr
-
>
member
=
=
5
)
.
copy_and_verify
(
.
.
.
)
)
{
.
.
.
}
\
n
\
n
"
"
Change
this
to
\
n
\
n
"
"
tainted
<
int
>
val
=
tainted_ptr
-
>
member
\
n
"
"
if
(
(
val
=
=
5
)
.
copy_and_verify
(
.
.
.
)
)
{
.
.
.
}
\
n
\
n
"
"
tainted
<
int
T_Sbx
>
foo
(
rlbox_sandbox
<
T_Sbx
>
&
sandbox
)
{
.
.
.
}
\
n
\
n
"
"
Alternately
if
you
are
sure
your
code
is
safe
you
can
use
the
"
"
unverified_safe_because
API
to
remove
tainting
\
n
"
)
;
return
0
;
}
}
;
}
