#
pragma
once
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
rlbox_helpers
.
hpp
"
#
include
"
rlbox_struct_support
.
hpp
"
#
include
"
rlbox_types
.
hpp
"
namespace
rlbox
{
namespace
callback_detail
{
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
using
T_Cb
=
std
:
:
conditional_t
<
std
:
:
is_void_v
<
T_Ret
>
void
tainted
<
T_Ret
T_Sbx
>
>
(
*
)
(
rlbox_sandbox
<
T_Sbx
>
&
tainted
<
T_Args
T_Sbx
>
.
.
.
)
;
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
T_Cb
<
T_Sbx
T_Ret
T_Args
.
.
.
>
callback_type_helper
(
T_Ret
(
*
)
(
T_Args
.
.
.
)
)
;
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
using
T_I
=
detail
:
:
convert_to_sandbox_equivalent_t
<
T_Ret
T_Sbx
>
(
*
)
(
detail
:
:
convert_to_sandbox_equivalent_t
<
T_Args
T_Sbx
>
.
.
.
)
;
template
<
typename
T_Sbx
typename
T_Ret
typename
.
.
.
T_Args
>
T_I
<
T_Sbx
T_Ret
T_Args
.
.
.
>
interceptor_type_helper
(
T_Ret
(
*
)
(
T_Args
.
.
.
)
)
;
}
template
<
typename
T
typename
T_Sbx
>
class
sandbox_callback
{
KEEP_CLASSES_FRIENDLY
private
:
rlbox_sandbox
<
T_Sbx
>
*
sandbox
;
using
T_Callback
=
decltype
(
callback_detail
:
:
callback_type_helper
<
T_Sbx
>
(
std
:
:
declval
<
T
>
(
)
)
)
;
T_Callback
callback
;
using
T_Interceptor
=
decltype
(
callback_detail
:
:
interceptor_type_helper
<
T_Sbx
>
(
std
:
:
declval
<
T
>
(
)
)
)
;
T_Interceptor
callback_interceptor
;
using
T_Trampoline
=
detail
:
:
convert_to_sandbox_equivalent_t
<
T
T_Sbx
>
;
T_Trampoline
callback_trampoline
;
void
*
key
;
inline
void
move_obj
(
sandbox_callback
&
&
other
)
{
sandbox
=
other
.
sandbox
;
callback
=
other
.
callback
;
callback_interceptor
=
other
.
callback_interceptor
;
callback_trampoline
=
other
.
callback_trampoline
;
key
=
other
.
key
;
other
.
sandbox
=
nullptr
;
other
.
callback
=
nullptr
;
other
.
callback_interceptor
=
nullptr
;
other
.
callback_trampoline
=
0
;
other
.
key
=
nullptr
;
}
template
<
typename
T_Ret
typename
.
.
.
T_Args
>
inline
void
unregister_helper
(
T_Ret
(
*
)
(
T_Args
.
.
.
)
)
{
if
(
callback
!
=
nullptr
)
{
sandbox
-
>
template
unregister_callback
<
T_Ret
T_Args
.
.
.
>
(
key
)
;
sandbox
=
nullptr
;
callback
=
nullptr
;
callback_interceptor
=
nullptr
;
callback_trampoline
=
0
;
key
=
nullptr
;
}
}
inline
T_Callback
get_raw_value
(
)
const
noexcept
{
return
callback
;
}
inline
T_Trampoline
get_raw_sandbox_value
(
)
const
noexcept
{
return
callback_trampoline
;
}
inline
T_Callback
get_raw_value
(
)
noexcept
{
return
callback
;
}
inline
T_Trampoline
get_raw_sandbox_value
(
)
noexcept
{
return
callback_trampoline
;
}
sandbox_callback
(
rlbox_sandbox
<
T_Sbx
>
*
p_sandbox
T_Callback
p_callback
T_Interceptor
p_callback_interceptor
T_Trampoline
p_callback_trampoline
void
*
p_key
)
:
sandbox
(
p_sandbox
)
callback
(
p_callback
)
callback_interceptor
(
p_callback_interceptor
)
callback_trampoline
(
p_callback_trampoline
)
key
(
p_key
)
{
detail
:
:
dynamic_check
(
sandbox
!
=
nullptr
"
Unexpected
null
sandbox
when
creating
a
callback
"
)
;
}
public
:
sandbox_callback
(
)
:
sandbox
(
nullptr
)
callback
(
nullptr
)
callback_interceptor
(
nullptr
)
callback_trampoline
(
0
)
key
(
nullptr
)
{
}
sandbox_callback
(
sandbox_callback
&
&
other
)
{
move_obj
(
std
:
:
forward
<
sandbox_callback
>
(
other
)
)
;
}
inline
sandbox_callback
&
operator
=
(
sandbox_callback
&
&
other
)
{
if
(
this
!
=
&
other
)
{
move_obj
(
std
:
:
forward
<
sandbox_callback
>
(
other
)
)
;
}
return
*
this
;
}
void
unregister
(
)
{
T
dummy
=
nullptr
;
unregister_helper
(
dummy
)
;
}
~
sandbox_callback
(
)
{
unregister
(
)
;
}
inline
auto
UNSAFE_unverified
(
)
const
noexcept
{
return
get_raw_value
(
)
;
}
inline
auto
UNSAFE_sandboxed
(
rlbox_sandbox
<
T_Sbx
>
&
sandbox
)
const
noexcept
{
RLBOX_UNUSED
(
sandbox
)
;
return
get_raw_sandbox_value
(
)
;
}
inline
auto
UNSAFE_unverified
(
)
noexcept
{
return
get_raw_value
(
)
;
}
inline
auto
UNSAFE_sandboxed
(
rlbox_sandbox
<
T_Sbx
>
&
sandbox
)
noexcept
{
RLBOX_UNUSED
(
sandbox
)
;
return
get_raw_sandbox_value
(
)
;
}
}
;
}
