(
function
(
e
)
{
if
(
"
function
"
=
=
typeof
bootstrap
)
bootstrap
(
"
react
"
e
)
;
else
if
(
"
object
"
=
=
typeof
exports
)
module
.
exports
=
e
(
)
;
else
if
(
"
function
"
=
=
typeof
define
&
&
define
.
amd
)
define
(
e
)
;
else
if
(
"
undefined
"
!
=
typeof
ses
)
{
if
(
!
ses
.
ok
(
)
)
return
;
ses
.
makeReact
=
e
}
else
"
undefined
"
!
=
typeof
window
?
window
.
React
=
e
(
)
:
global
.
React
=
e
(
)
}
)
(
function
(
)
{
var
define
ses
bootstrap
module
exports
;
return
(
function
(
e
t
n
)
{
function
i
(
n
s
)
{
if
(
!
t
[
n
]
)
{
if
(
!
e
[
n
]
)
{
var
o
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
s
&
&
o
)
return
o
(
n
!
0
)
;
if
(
r
)
return
r
(
n
!
0
)
;
throw
new
Error
(
"
Cannot
find
module
'
"
+
n
+
"
'
"
)
}
var
u
=
t
[
n
]
=
{
exports
:
{
}
}
;
e
[
n
]
[
0
]
.
call
(
u
.
exports
function
(
t
)
{
var
r
=
e
[
n
]
[
1
]
[
t
]
;
return
i
(
r
?
r
:
t
)
}
u
u
.
exports
)
}
return
t
[
n
]
.
exports
}
var
r
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
s
=
0
;
s
<
n
.
length
;
s
+
+
)
i
(
n
[
s
]
)
;
return
i
}
)
(
{
1
:
[
function
(
require
module
exports
)
{
var
ge
=
require
(
"
.
/
ge
"
)
;
var
ex
=
require
(
"
.
/
ex
"
)
;
function
(
id
)
{
var
element
=
ge
(
id
)
;
if
(
!
element
)
{
throw
new
Error
(
ex
(
'
Tried
to
get
element
with
id
of
"
%
s
"
but
it
is
not
present
on
the
page
.
'
id
)
)
;
}
return
element
;
}
module
.
exports
=
;
}
{
"
.
/
ex
"
:
66
"
.
/
ge
"
:
69
}
]
2
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
isUnitlessNumber
=
{
fillOpacity
:
true
fontWeight
:
true
opacity
:
true
orphans
:
true
zIndex
:
true
zoom
:
true
}
;
var
shorthandPropertyExpansions
=
{
background
:
{
backgroundImage
:
true
backgroundPosition
:
true
backgroundRepeat
:
true
backgroundColor
:
true
}
border
:
{
borderWidth
:
true
borderStyle
:
true
borderColor
:
true
}
borderBottom
:
{
borderBottomWidth
:
true
borderBottomStyle
:
true
borderBottomColor
:
true
}
borderLeft
:
{
borderLeftWidth
:
true
borderLeftStyle
:
true
borderLeftColor
:
true
}
borderRight
:
{
borderRightWidth
:
true
borderRightStyle
:
true
borderRightColor
:
true
}
borderTop
:
{
borderTopWidth
:
true
borderTopStyle
:
true
borderTopColor
:
true
}
font
:
{
fontStyle
:
true
fontVariant
:
true
fontWeight
:
true
fontSize
:
true
lineHeight
:
true
fontFamily
:
true
}
}
;
var
CSSProperty
=
{
isUnitlessNumber
:
isUnitlessNumber
shorthandPropertyExpansions
:
shorthandPropertyExpansions
}
;
module
.
exports
=
CSSProperty
;
}
{
}
]
3
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
CSSProperty
=
require
(
"
.
/
CSSProperty
"
)
;
var
dangerousStyleValue
=
require
(
"
.
/
dangerousStyleValue
"
)
;
var
escapeTextForBrowser
=
require
(
"
.
/
escapeTextForBrowser
"
)
;
var
hyphenate
=
require
(
"
.
/
hyphenate
"
)
;
var
memoizeStringOnly
=
require
(
"
.
/
memoizeStringOnly
"
)
;
var
processStyleName
=
memoizeStringOnly
(
function
(
styleName
)
{
return
escapeTextForBrowser
(
hyphenate
(
styleName
)
)
;
}
)
;
var
CSSPropertyOperations
=
{
createMarkupForStyles
:
function
(
styles
)
{
var
serialized
=
'
'
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
styleValue
=
styles
[
styleName
]
;
if
(
styleValue
!
=
null
)
{
serialized
+
=
processStyleName
(
styleName
)
+
'
:
'
;
serialized
+
=
dangerousStyleValue
(
styleName
styleValue
)
+
'
;
'
;
}
}
return
serialized
|
|
null
;
}
setValueForStyles
:
function
(
node
styles
)
{
var
style
=
node
.
style
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
styleValue
=
dangerousStyleValue
(
styleName
styles
[
styleName
]
)
;
if
(
styleValue
)
{
style
[
styleName
]
=
styleValue
;
}
else
{
var
expansion
=
CSSProperty
.
shorthandPropertyExpansions
[
styleName
]
;
if
(
expansion
)
{
for
(
var
individualStyleName
in
expansion
)
{
style
[
individualStyleName
]
=
'
'
;
}
}
else
{
style
[
styleName
]
=
'
'
;
}
}
}
}
}
;
module
.
exports
=
CSSPropertyOperations
;
}
{
"
.
/
CSSProperty
"
:
2
"
.
/
dangerousStyleValue
"
:
63
"
.
/
escapeTextForBrowser
"
:
65
"
.
/
hyphenate
"
:
73
"
.
/
memoizeStringOnly
"
:
80
}
]
4
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
listenerBank
=
{
}
;
var
CallbackRegistry
=
{
putListener
:
function
(
id
registrationName
listener
)
{
var
bankForRegistrationName
=
listenerBank
[
registrationName
]
|
|
(
listenerBank
[
registrationName
]
=
{
}
)
;
bankForRegistrationName
[
id
]
=
listener
;
}
getListener
:
function
(
id
registrationName
)
{
var
bankForRegistrationName
=
listenerBank
[
registrationName
]
;
return
bankForRegistrationName
&
&
bankForRegistrationName
[
id
]
;
}
deleteListener
:
function
(
id
registrationName
)
{
var
bankForRegistrationName
=
listenerBank
[
registrationName
]
;
if
(
bankForRegistrationName
)
{
delete
bankForRegistrationName
[
id
]
;
}
}
deleteAllListeners
:
function
(
id
)
{
for
(
var
registrationName
in
listenerBank
)
{
delete
listenerBank
[
registrationName
]
[
id
]
;
}
}
__purge
:
function
(
)
{
listenerBank
=
{
}
;
}
}
;
module
.
exports
=
CallbackRegistry
;
}
{
}
]
5
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
EventPluginHub
=
require
(
"
.
/
EventPluginHub
"
)
;
var
EventPropagators
=
require
(
"
.
/
EventPropagators
"
)
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
SyntheticEvent
=
require
(
"
.
/
SyntheticEvent
"
)
;
var
isEventSupported
=
require
(
"
.
/
isEventSupported
"
)
;
var
keyOf
=
require
(
"
.
/
keyOf
"
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
eventTypes
=
{
change
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onChange
:
null
}
)
captured
:
keyOf
(
{
onChangeCapture
:
null
}
)
}
}
}
;
var
activeElement
=
null
;
var
activeElementID
=
null
;
var
activeElementValue
=
null
;
var
activeElementValueProp
=
null
;
function
shouldUseChangeEvent
(
elem
)
{
return
(
elem
.
nodeName
=
=
=
'
SELECT
'
|
|
(
elem
.
nodeName
=
=
=
'
INPUT
'
&
&
elem
.
type
=
=
=
'
file
'
)
)
;
}
var
doesChangeEventBubble
=
false
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
doesChangeEventBubble
=
isEventSupported
(
'
change
'
)
&
&
(
!
(
'
documentMode
'
in
document
)
|
|
document
.
documentMode
>
8
)
;
}
function
manualDispatchChangeEvent
(
nativeEvent
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
.
change
activeElementID
nativeEvent
)
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
EventPluginHub
.
enqueueEvents
(
event
)
;
EventPluginHub
.
processEventQueue
(
)
;
}
function
startWatchingForChangeEventIE8
(
target
targetID
)
{
activeElement
=
target
;
activeElementID
=
targetID
;
activeElement
.
attachEvent
(
'
onchange
'
manualDispatchChangeEvent
)
;
}
function
stopWatchingForChangeEventIE8
(
)
{
if
(
!
activeElement
)
{
return
;
}
activeElement
.
detachEvent
(
'
onchange
'
manualDispatchChangeEvent
)
;
activeElement
=
null
;
activeElementID
=
null
;
}
function
getTargetIDForChangeEvent
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topChange
)
{
return
topLevelTargetID
;
}
}
function
handleEventsForChangeEventIE8
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topFocus
)
{
stopWatchingForChangeEventIE8
(
)
;
startWatchingForChangeEventIE8
(
topLevelTarget
topLevelTargetID
)
;
}
else
if
(
topLevelType
=
=
=
topLevelTypes
.
topBlur
)
{
stopWatchingForChangeEventIE8
(
)
;
}
}
var
isInputEventSupported
=
false
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
isInputEventSupported
=
isEventSupported
(
'
input
'
)
&
&
(
!
(
'
documentMode
'
in
document
)
|
|
document
.
documentMode
>
9
)
;
}
var
supportedInputTypes
=
{
'
color
'
:
true
'
date
'
:
true
'
datetime
'
:
true
'
datetime
-
local
'
:
true
'
email
'
:
true
'
month
'
:
true
'
number
'
:
true
'
password
'
:
true
'
range
'
:
true
'
search
'
:
true
'
tel
'
:
true
'
text
'
:
true
'
time
'
:
true
'
url
'
:
true
'
week
'
:
true
}
;
function
shouldUseInputEvent
(
elem
)
{
return
(
(
elem
.
nodeName
=
=
=
'
INPUT
'
&
&
supportedInputTypes
[
elem
.
type
]
)
|
|
elem
.
nodeName
=
=
=
'
TEXTAREA
'
)
;
}
var
newValueProp
=
{
get
:
function
(
)
{
return
activeElementValueProp
.
get
.
call
(
this
)
;
}
set
:
function
(
val
)
{
activeElementValue
=
'
'
+
val
;
activeElementValueProp
.
set
.
call
(
this
val
)
;
}
}
;
function
startWatchingForValueChange
(
target
targetID
)
{
activeElement
=
target
;
activeElementID
=
targetID
;
activeElementValue
=
target
.
value
;
activeElementValueProp
=
Object
.
getOwnPropertyDescriptor
(
target
.
constructor
.
prototype
'
value
'
)
;
Object
.
defineProperty
(
activeElement
'
value
'
newValueProp
)
;
activeElement
.
attachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
}
function
stopWatchingForValueChange
(
)
{
if
(
!
activeElement
)
{
return
;
}
delete
activeElement
.
value
;
activeElement
.
detachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
activeElement
=
null
;
activeElementID
=
null
;
activeElementValue
=
null
;
activeElementValueProp
=
null
;
}
function
handlePropertyChange
(
nativeEvent
)
{
if
(
nativeEvent
.
propertyName
!
=
=
'
value
'
)
{
return
;
}
var
value
=
nativeEvent
.
srcElement
.
value
;
if
(
value
=
=
=
activeElementValue
)
{
return
;
}
activeElementValue
=
value
;
manualDispatchChangeEvent
(
nativeEvent
)
;
}
function
getTargetIDForInputEvent
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topInput
)
{
return
topLevelTargetID
;
}
}
function
handleEventsForInputEventIE
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topFocus
)
{
stopWatchingForValueChange
(
)
;
startWatchingForValueChange
(
topLevelTarget
topLevelTargetID
)
;
}
else
if
(
topLevelType
=
=
=
topLevelTypes
.
topBlur
)
{
stopWatchingForValueChange
(
)
;
}
}
function
getTargetIDForInputEventIE
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topSelectionChange
|
|
topLevelType
=
=
=
topLevelTypes
.
topKeyUp
|
|
topLevelType
=
=
=
topLevelTypes
.
topKeyDown
)
{
if
(
activeElement
&
&
activeElement
.
value
!
=
=
activeElementValue
)
{
activeElementValue
=
activeElement
.
value
;
return
activeElementID
;
}
}
}
function
shouldUseClickEvent
(
elem
)
{
return
(
elem
.
nodeName
=
=
=
'
INPUT
'
&
&
(
elem
.
type
=
=
=
'
checkbox
'
|
|
elem
.
type
=
=
=
'
radio
'
)
)
;
}
function
getTargetIDForClickEvent
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topClick
)
{
return
topLevelTargetID
;
}
}
var
ChangeEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
{
var
getTargetIDFunc
handleEventFunc
;
if
(
shouldUseChangeEvent
(
topLevelTarget
)
)
{
if
(
doesChangeEventBubble
)
{
getTargetIDFunc
=
getTargetIDForChangeEvent
;
}
else
{
handleEventFunc
=
handleEventsForChangeEventIE8
;
}
}
else
if
(
shouldUseInputEvent
(
topLevelTarget
)
)
{
if
(
isInputEventSupported
)
{
getTargetIDFunc
=
getTargetIDForInputEvent
;
}
else
{
getTargetIDFunc
=
getTargetIDForInputEventIE
;
handleEventFunc
=
handleEventsForInputEventIE
;
}
}
else
if
(
shouldUseClickEvent
(
topLevelTarget
)
)
{
getTargetIDFunc
=
getTargetIDForClickEvent
;
}
if
(
getTargetIDFunc
)
{
var
targetID
=
getTargetIDFunc
(
topLevelType
topLevelTarget
topLevelTargetID
)
;
if
(
targetID
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
.
change
targetID
nativeEvent
)
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
if
(
handleEventFunc
)
{
handleEventFunc
(
topLevelType
topLevelTarget
topLevelTargetID
)
;
}
}
}
;
module
.
exports
=
ChangeEventPlugin
;
}
)
(
)
}
{
"
.
/
EventConstants
"
:
13
"
.
/
EventPluginHub
"
:
15
"
.
/
EventPropagators
"
:
18
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
SyntheticEvent
"
:
50
"
.
/
isEventSupported
"
:
76
"
.
/
keyOf
"
:
79
}
]
6
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
Danger
=
require
(
"
.
/
Danger
"
)
;
var
insertNodeAt
=
require
(
"
.
/
insertNodeAt
"
)
;
var
keyOf
=
require
(
"
.
/
keyOf
"
)
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
NON_INCREASING_OPERATIONS
;
if
(
true
)
{
NON_INCREASING_OPERATIONS
=
'
DOM
child
management
operations
must
be
provided
in
order
'
+
'
of
increasing
destination
index
.
This
is
likely
an
issue
with
'
+
'
the
core
framework
.
'
;
}
var
MOVE_NODE_AT_ORIG_INDEX
=
keyOf
(
{
moveFrom
:
null
}
)
;
var
INSERT_MARKUP
=
keyOf
(
{
insertMarkup
:
null
}
)
;
var
REMOVE_AT
=
keyOf
(
{
removeAt
:
null
}
)
;
var
_getNodesByOriginalIndex
=
function
(
parent
childOperations
)
{
var
nodesByOriginalIndex
;
var
childOperation
;
var
origIndex
;
for
(
var
i
=
0
;
i
<
childOperations
.
length
;
i
+
+
)
{
childOperation
=
childOperations
[
i
]
;
if
(
MOVE_NODE_AT_ORIG_INDEX
in
childOperation
)
{
nodesByOriginalIndex
=
nodesByOriginalIndex
|
|
[
]
;
origIndex
=
childOperation
.
moveFrom
;
nodesByOriginalIndex
[
origIndex
]
=
parent
.
childNodes
[
origIndex
]
;
}
else
if
(
REMOVE_AT
in
childOperation
)
{
nodesByOriginalIndex
=
nodesByOriginalIndex
|
|
[
]
;
origIndex
=
childOperation
.
removeAt
;
nodesByOriginalIndex
[
origIndex
]
=
parent
.
childNodes
[
origIndex
]
;
}
}
return
nodesByOriginalIndex
;
}
;
var
_removeChildrenByOriginalIndex
=
function
(
parent
nodesByOriginalIndex
)
{
for
(
var
j
=
0
;
j
<
nodesByOriginalIndex
.
length
;
j
+
+
)
{
var
nodeToRemove
=
nodesByOriginalIndex
[
j
]
;
if
(
nodeToRemove
)
{
parent
.
removeChild
(
nodesByOriginalIndex
[
j
]
)
;
}
}
}
;
var
_placeNodesAtDestination
=
function
(
parent
childOperations
nodesByOriginalIndex
)
{
var
origNode
;
var
finalIndex
;
var
lastFinalIndex
=
-
1
;
var
childOperation
;
for
(
var
k
=
0
;
k
<
childOperations
.
length
;
k
+
+
)
{
childOperation
=
childOperations
[
k
]
;
if
(
MOVE_NODE_AT_ORIG_INDEX
in
childOperation
)
{
origNode
=
nodesByOriginalIndex
[
childOperation
.
moveFrom
]
;
finalIndex
=
childOperation
.
finalIndex
;
insertNodeAt
(
parent
origNode
finalIndex
)
;
if
(
true
)
{
throwIf
(
finalIndex
<
=
lastFinalIndex
NON_INCREASING_OPERATIONS
)
;
lastFinalIndex
=
finalIndex
;
}
}
else
if
(
REMOVE_AT
in
childOperation
)
{
}
else
if
(
INSERT_MARKUP
in
childOperation
)
{
finalIndex
=
childOperation
.
finalIndex
;
var
markup
=
childOperation
.
insertMarkup
;
Danger
.
dangerouslyInsertMarkupAt
(
parent
markup
finalIndex
)
;
if
(
true
)
{
throwIf
(
finalIndex
<
=
lastFinalIndex
NON_INCREASING_OPERATIONS
)
;
lastFinalIndex
=
finalIndex
;
}
}
}
}
;
var
manageChildren
=
function
(
parent
childOperations
)
{
var
nodesByOriginalIndex
=
_getNodesByOriginalIndex
(
parent
childOperations
)
;
if
(
nodesByOriginalIndex
)
{
_removeChildrenByOriginalIndex
(
parent
nodesByOriginalIndex
)
;
}
_placeNodesAtDestination
(
parent
childOperations
nodesByOriginalIndex
)
;
}
;
var
DOMChildrenOperations
=
{
dangerouslyReplaceNodeWithMarkup
:
Danger
.
dangerouslyReplaceNodeWithMarkup
manageChildren
:
manageChildren
}
;
module
.
exports
=
DOMChildrenOperations
;
}
)
(
)
}
{
"
.
/
Danger
"
:
9
"
.
/
insertNodeAt
"
:
74
"
.
/
keyOf
"
:
79
"
.
/
throwIf
"
:
86
}
]
7
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
DOMPropertyInjection
=
{
MUST_USE_ATTRIBUTE
:
0x1
MUST_USE_PROPERTY
:
0x2
HAS_BOOLEAN_VALUE
:
0x4
HAS_SIDE_EFFECTS
:
0x8
injectDOMPropertyConfig
:
function
(
domPropertyConfig
)
{
var
Properties
=
domPropertyConfig
.
Properties
|
|
{
}
;
var
DOMAttributeNames
=
domPropertyConfig
.
DOMAttributeNames
|
|
{
}
;
var
DOMPropertyNames
=
domPropertyConfig
.
DOMPropertyNames
|
|
{
}
;
var
DOMMutationMethods
=
domPropertyConfig
.
DOMMutationMethods
|
|
{
}
;
if
(
domPropertyConfig
.
isCustomAttribute
)
{
DOMProperty
.
_isCustomAttributeFunctions
.
push
(
domPropertyConfig
.
isCustomAttribute
)
;
}
for
(
var
propName
in
Properties
)
{
invariant
(
!
DOMProperty
.
isStandardName
[
propName
]
'
injectDOMPropertyConfig
(
.
.
.
)
:
You
\
'
re
trying
to
inject
DOM
property
'
+
'
\
'
%
s
\
'
which
has
already
been
injected
.
You
may
be
accidentally
'
+
'
injecting
the
same
DOM
property
config
twice
or
you
may
be
'
+
'
injecting
two
configs
that
have
conflicting
property
names
.
'
propName
)
;
DOMProperty
.
isStandardName
[
propName
]
=
true
;
DOMProperty
.
getAttributeName
[
propName
]
=
DOMAttributeNames
[
propName
]
|
|
propName
.
toLowerCase
(
)
;
DOMProperty
.
getPropertyName
[
propName
]
=
DOMPropertyNames
[
propName
]
|
|
propName
;
var
mutationMethod
=
DOMMutationMethods
[
propName
]
;
if
(
mutationMethod
)
{
DOMProperty
.
getMutationMethod
[
propName
]
=
mutationMethod
;
}
var
propConfig
=
Properties
[
propName
]
;
DOMProperty
.
mustUseAttribute
[
propName
]
=
propConfig
&
DOMPropertyInjection
.
MUST_USE_ATTRIBUTE
;
DOMProperty
.
mustUseProperty
[
propName
]
=
propConfig
&
DOMPropertyInjection
.
MUST_USE_PROPERTY
;
DOMProperty
.
hasBooleanValue
[
propName
]
=
propConfig
&
DOMPropertyInjection
.
HAS_BOOLEAN_VALUE
;
DOMProperty
.
hasSideEffects
[
propName
]
=
propConfig
&
DOMPropertyInjection
.
HAS_SIDE_EFFECTS
;
invariant
(
!
DOMProperty
.
mustUseAttribute
[
propName
]
|
|
!
DOMProperty
.
mustUseProperty
[
propName
]
'
DOMProperty
:
Cannot
use
require
using
both
attribute
and
property
:
%
s
'
propName
)
;
invariant
(
DOMProperty
.
mustUseProperty
[
propName
]
|
|
!
DOMProperty
.
hasSideEffects
[
propName
]
'
DOMProperty
:
Properties
that
have
side
effects
must
use
property
:
%
s
'
propName
)
;
}
}
}
;
var
defaultValueCache
=
{
}
;
var
DOMProperty
=
{
isStandardName
:
{
}
getAttributeName
:
{
}
getPropertyName
:
{
}
getMutationMethod
:
{
}
mustUseAttribute
:
{
}
mustUseProperty
:
{
}
hasBooleanValue
:
{
}
hasSideEffects
:
{
}
_isCustomAttributeFunctions
:
[
]
isCustomAttribute
:
function
(
attributeName
)
{
return
DOMProperty
.
_isCustomAttributeFunctions
.
some
(
function
(
isCustomAttributeFn
)
{
return
isCustomAttributeFn
.
call
(
null
attributeName
)
;
}
)
;
}
getDefaultValueForProperty
:
function
(
nodeName
prop
)
{
var
nodeDefaults
=
defaultValueCache
[
nodeName
]
;
var
testElement
;
if
(
!
nodeDefaults
)
{
defaultValueCache
[
nodeName
]
=
nodeDefaults
=
{
}
;
}
if
(
!
(
prop
in
nodeDefaults
)
)
{
testElement
=
document
.
createElement
(
nodeName
)
;
nodeDefaults
[
prop
]
=
testElement
[
prop
]
;
}
return
nodeDefaults
[
prop
]
;
}
injection
:
DOMPropertyInjection
}
;
module
.
exports
=
DOMProperty
;
}
{
"
.
/
invariant
"
:
75
}
]
8
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
DOMProperty
=
require
(
"
.
/
DOMProperty
"
)
;
var
escapeTextForBrowser
=
require
(
"
.
/
escapeTextForBrowser
"
)
;
var
memoizeStringOnly
=
require
(
"
.
/
memoizeStringOnly
"
)
;
var
processAttributeNameAndPrefix
=
memoizeStringOnly
(
function
(
name
)
{
return
escapeTextForBrowser
(
name
)
+
'
=
"
'
;
}
)
;
var
DOMPropertyOperations
=
{
createMarkupForProperty
:
function
(
name
value
)
{
if
(
DOMProperty
.
isStandardName
[
name
]
)
{
if
(
value
=
=
null
|
|
DOMProperty
.
hasBooleanValue
[
name
]
&
&
!
value
)
{
return
'
'
;
}
var
attributeName
=
DOMProperty
.
getAttributeName
[
name
]
;
return
processAttributeNameAndPrefix
(
attributeName
)
+
escapeTextForBrowser
(
value
)
+
'
"
'
;
}
else
if
(
DOMProperty
.
isCustomAttribute
(
name
)
)
{
if
(
value
=
=
null
)
{
return
'
'
;
}
return
processAttributeNameAndPrefix
(
name
)
+
escapeTextForBrowser
(
value
)
+
'
"
'
;
}
else
{
return
null
;
}
}
setValueForProperty
:
function
(
node
name
value
)
{
if
(
DOMProperty
.
isStandardName
[
name
]
)
{
var
mutationMethod
=
DOMProperty
.
getMutationMethod
[
name
]
;
if
(
mutationMethod
)
{
mutationMethod
(
node
value
)
;
}
else
if
(
DOMProperty
.
mustUseAttribute
[
name
]
)
{
if
(
DOMProperty
.
hasBooleanValue
[
name
]
&
&
!
value
)
{
node
.
removeAttribute
(
DOMProperty
.
getAttributeName
[
name
]
)
;
}
else
{
node
.
setAttribute
(
DOMProperty
.
getAttributeName
[
name
]
value
)
;
}
}
else
{
var
propName
=
DOMProperty
.
getPropertyName
[
name
]
;
if
(
!
DOMProperty
.
hasSideEffects
[
name
]
|
|
node
[
propName
]
!
=
=
value
)
{
node
[
propName
]
=
value
;
}
}
}
else
if
(
DOMProperty
.
isCustomAttribute
(
name
)
)
{
node
.
setAttribute
(
name
value
)
;
}
}
deleteValueForProperty
:
function
(
node
name
)
{
if
(
DOMProperty
.
isStandardName
[
name
]
)
{
var
mutationMethod
=
DOMProperty
.
getMutationMethod
[
name
]
;
if
(
mutationMethod
)
{
mutationMethod
(
node
undefined
)
;
}
else
if
(
DOMProperty
.
mustUseAttribute
[
name
]
)
{
node
.
removeAttribute
(
DOMProperty
.
getAttributeName
[
name
]
)
;
}
else
{
var
propName
=
DOMProperty
.
getPropertyName
[
name
]
;
node
[
propName
]
=
DOMProperty
.
getDefaultValueForProperty
(
node
.
nodeName
name
)
;
}
}
else
if
(
DOMProperty
.
isCustomAttribute
(
name
)
)
{
node
.
removeAttribute
(
name
)
;
}
}
}
;
module
.
exports
=
DOMPropertyOperations
;
}
{
"
.
/
DOMProperty
"
:
7
"
.
/
escapeTextForBrowser
"
:
65
"
.
/
memoizeStringOnly
"
:
80
}
]
9
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
DOM_UNSUPPORTED
;
var
NO_MARKUP_PARENT
;
var
NO_MULTI_MARKUP
;
if
(
true
)
{
DOM_UNSUPPORTED
=
'
You
may
not
insert
markup
into
the
document
while
you
are
in
a
worker
'
+
'
thread
.
It
\
'
s
not
you
it
\
'
s
me
.
This
is
likely
the
fault
of
the
'
+
'
framework
.
Please
report
this
immediately
.
'
;
NO_MARKUP_PARENT
=
'
You
have
attempted
to
inject
markup
without
a
suitable
parent
.
This
is
'
+
'
likely
the
fault
of
the
framework
-
please
report
immediately
.
'
;
NO_MULTI_MARKUP
=
'
The
framework
has
attempted
to
either
insert
zero
or
multiple
markup
'
+
'
roots
into
a
single
location
when
it
should
not
.
This
is
a
serious
'
+
'
error
-
a
fault
of
the
framework
-
please
report
immediately
.
'
;
}
var
validateMarkupParams
;
if
(
true
)
{
validateMarkupParams
=
function
(
parentNode
markup
)
{
throwIf
(
!
ExecutionEnvironment
.
canUseDOM
DOM_UNSUPPORTED
)
;
throwIf
(
!
parentNode
|
|
!
parentNode
.
tagName
NO_MARKUP_PARENT
)
;
throwIf
(
!
markup
NO_MULTI_MARKUP
)
;
}
;
}
var
dummyNode
=
ExecutionEnvironment
.
canUseDOM
?
document
.
createElement
(
'
div
'
)
:
null
;
var
markupWrap
=
{
'
option
'
:
[
1
'
<
select
multiple
=
"
true
"
>
'
'
<
/
select
>
'
]
'
legend
'
:
[
1
'
<
fieldset
>
'
'
<
/
fieldset
>
'
]
'
area
'
:
[
1
'
<
map
>
'
'
<
/
map
>
'
]
'
param
'
:
[
1
'
<
object
>
'
'
<
/
object
>
'
]
'
thead
'
:
[
1
'
<
table
>
'
'
<
/
table
>
'
]
'
tr
'
:
[
2
'
<
table
>
<
tbody
>
'
'
<
/
tbody
>
<
/
table
>
'
]
'
col
'
:
[
2
'
<
table
>
<
tbody
>
<
/
tbody
>
<
colgroup
>
'
'
<
/
colgroup
>
<
/
table
>
'
]
'
td
'
:
[
3
'
<
table
>
<
tbody
>
<
tr
>
'
'
<
/
tr
>
<
/
tbody
>
<
/
table
>
'
]
}
;
markupWrap
[
'
optgroup
'
]
=
markupWrap
[
'
option
'
]
;
markupWrap
[
'
tbody
'
]
=
markupWrap
[
'
thead
'
]
;
markupWrap
[
'
tfoot
'
]
=
markupWrap
[
'
thead
'
]
;
markupWrap
[
'
colgroup
'
]
=
markupWrap
[
'
thead
'
]
;
markupWrap
[
'
caption
'
]
=
markupWrap
[
'
thead
'
]
;
markupWrap
[
'
th
'
]
=
markupWrap
[
'
td
'
]
;
var
defaultWrap
=
[
1
'
?
<
div
>
'
'
<
/
div
>
'
]
;
if
(
dummyNode
)
{
for
(
var
nodeName
in
markupWrap
)
{
if
(
!
markupWrap
.
hasOwnProperty
(
nodeName
)
)
{
continue
;
}
dummyNode
.
innerHTML
=
'
<
'
+
nodeName
+
'
>
<
/
'
+
nodeName
+
'
>
'
;
if
(
dummyNode
.
firstChild
)
{
markupWrap
[
nodeName
]
=
null
;
}
}
dummyNode
.
innerHTML
=
'
<
link
/
>
'
;
if
(
dummyNode
.
firstChild
)
{
defaultWrap
=
null
;
}
}
function
renderMarkup
(
markup
)
{
var
node
=
dummyNode
;
var
nodeName
=
markup
.
substring
(
1
markup
.
indexOf
(
'
'
)
)
;
var
wrap
=
markupWrap
[
nodeName
.
toLowerCase
(
)
]
|
|
defaultWrap
;
if
(
wrap
)
{
node
.
innerHTML
=
wrap
[
1
]
+
markup
+
wrap
[
2
]
;
var
wrapDepth
=
wrap
[
0
]
;
while
(
wrapDepth
-
-
)
{
node
=
node
.
lastChild
;
}
}
else
{
node
.
innerHTML
=
markup
;
}
return
node
.
childNodes
;
}
function
insertNodeAfterNode
(
elem
insert
after
)
{
if
(
true
)
{
throwIf
(
!
ExecutionEnvironment
.
canUseDOM
DOM_UNSUPPORTED
)
;
}
if
(
after
)
{
if
(
after
.
nextSibling
)
{
return
elem
.
insertBefore
(
insert
after
.
nextSibling
)
;
}
else
{
return
elem
.
appendChild
(
insert
)
;
}
}
else
{
return
elem
.
insertBefore
(
insert
elem
.
firstChild
)
;
}
}
function
inefficientlyInsertHTMLCollectionAfter
(
parentRootDomNode
htmlCollection
after
)
{
if
(
true
)
{
throwIf
(
!
ExecutionEnvironment
.
canUseDOM
DOM_UNSUPPORTED
)
;
}
var
ret
;
var
originalLength
=
htmlCollection
.
length
;
for
(
var
i
=
0
;
i
<
originalLength
;
i
+
+
)
{
ret
=
insertNodeAfterNode
(
parentRootDomNode
htmlCollection
[
0
]
ret
|
|
after
)
;
}
}
function
dangerouslyInsertMarkupAt
(
parentNode
markup
index
)
{
if
(
true
)
{
validateMarkupParams
(
parentNode
markup
)
;
}
var
htmlCollection
=
renderMarkup
(
markup
)
;
var
afterNode
=
index
?
parentNode
.
childNodes
[
index
-
1
]
:
null
;
inefficientlyInsertHTMLCollectionAfter
(
parentNode
htmlCollection
afterNode
)
;
}
function
dangerouslyReplaceNodeWithMarkup
(
childNode
markup
)
{
var
parentNode
=
childNode
.
parentNode
;
if
(
true
)
{
validateMarkupParams
(
parentNode
markup
)
;
}
var
htmlCollection
=
renderMarkup
(
markup
)
;
if
(
true
)
{
throwIf
(
htmlCollection
.
length
!
=
=
1
NO_MULTI_MARKUP
)
;
}
parentNode
.
replaceChild
(
htmlCollection
[
0
]
childNode
)
;
}
var
Danger
=
{
dangerouslyInsertMarkupAt
:
dangerouslyInsertMarkupAt
dangerouslyReplaceNodeWithMarkup
:
dangerouslyReplaceNodeWithMarkup
}
;
module
.
exports
=
Danger
;
}
{
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
throwIf
"
:
86
}
]
10
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
DOMProperty
=
require
(
"
.
/
DOMProperty
"
)
;
var
MUST_USE_ATTRIBUTE
=
DOMProperty
.
injection
.
MUST_USE_ATTRIBUTE
;
var
MUST_USE_PROPERTY
=
DOMProperty
.
injection
.
MUST_USE_PROPERTY
;
var
HAS_BOOLEAN_VALUE
=
DOMProperty
.
injection
.
HAS_BOOLEAN_VALUE
;
var
HAS_SIDE_EFFECTS
=
DOMProperty
.
injection
.
HAS_SIDE_EFFECTS
;
var
DefaultDOMPropertyConfig
=
{
isCustomAttribute
:
RegExp
.
prototype
.
test
.
bind
(
/
^
(
data
|
aria
)
-
[
a
-
z_
]
[
a
-
z
\
d_
.
\
-
]
*
/
)
Properties
:
{
accessKey
:
null
accept
:
null
action
:
null
ajaxify
:
MUST_USE_ATTRIBUTE
allowFullScreen
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
alt
:
null
autoComplete
:
null
autoFocus
:
HAS_BOOLEAN_VALUE
autoPlay
:
HAS_BOOLEAN_VALUE
cellPadding
:
null
cellSpacing
:
null
checked
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
className
:
MUST_USE_PROPERTY
colSpan
:
null
contentEditable
:
null
contextMenu
:
MUST_USE_ATTRIBUTE
controls
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
data
:
null
dateTime
:
MUST_USE_ATTRIBUTE
dir
:
null
disabled
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
draggable
:
null
encType
:
null
height
:
MUST_USE_ATTRIBUTE
hidden
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
href
:
null
htmlFor
:
null
icon
:
null
id
:
MUST_USE_PROPERTY
label
:
null
lang
:
null
list
:
null
max
:
null
maxLength
:
MUST_USE_ATTRIBUTE
method
:
null
min
:
null
multiple
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
name
:
null
pattern
:
null
poster
:
null
preload
:
null
placeholder
:
null
radioGroup
:
null
rel
:
null
readOnly
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
required
:
HAS_BOOLEAN_VALUE
role
:
MUST_USE_ATTRIBUTE
scrollLeft
:
MUST_USE_PROPERTY
scrollTop
:
MUST_USE_PROPERTY
selected
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
size
:
null
spellCheck
:
null
src
:
null
step
:
null
style
:
null
tabIndex
:
null
target
:
null
title
:
null
type
:
null
value
:
MUST_USE_PROPERTY
|
HAS_SIDE_EFFECTS
width
:
MUST_USE_ATTRIBUTE
wmode
:
MUST_USE_ATTRIBUTE
cx
:
MUST_USE_PROPERTY
cy
:
MUST_USE_PROPERTY
d
:
MUST_USE_PROPERTY
fill
:
MUST_USE_PROPERTY
fx
:
MUST_USE_PROPERTY
fy
:
MUST_USE_PROPERTY
points
:
MUST_USE_PROPERTY
r
:
MUST_USE_PROPERTY
stroke
:
MUST_USE_PROPERTY
strokeLinecap
:
MUST_USE_PROPERTY
strokeWidth
:
MUST_USE_PROPERTY
transform
:
MUST_USE_PROPERTY
x
:
MUST_USE_PROPERTY
x1
:
MUST_USE_PROPERTY
x2
:
MUST_USE_PROPERTY
version
:
MUST_USE_PROPERTY
viewBox
:
MUST_USE_PROPERTY
y
:
MUST_USE_PROPERTY
y1
:
MUST_USE_PROPERTY
y2
:
MUST_USE_PROPERTY
spreadMethod
:
MUST_USE_PROPERTY
offset
:
MUST_USE_PROPERTY
stopColor
:
MUST_USE_PROPERTY
stopOpacity
:
MUST_USE_PROPERTY
gradientUnits
:
MUST_USE_PROPERTY
gradientTransform
:
MUST_USE_PROPERTY
}
DOMAttributeNames
:
{
className
:
'
class
'
htmlFor
:
'
for
'
strokeLinecap
:
'
stroke
-
linecap
'
strokeWidth
:
'
stroke
-
width
'
stopColor
:
'
stop
-
color
'
stopOpacity
:
'
stop
-
opacity
'
}
DOMPropertyNames
:
{
autoComplete
:
'
autocomplete
'
autoFocus
:
'
autofocus
'
autoPlay
:
'
autoplay
'
encType
:
'
enctype
'
radioGroup
:
'
radiogroup
'
spellCheck
:
'
spellcheck
'
}
DOMMutationMethods
:
{
className
:
function
(
node
value
)
{
node
.
className
=
value
|
|
'
'
;
}
}
}
;
module
.
exports
=
DefaultDOMPropertyConfig
;
}
{
"
.
/
DOMProperty
"
:
7
}
]
11
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
keyOf
=
require
(
"
.
/
keyOf
"
)
;
var
DefaultEventPluginOrder
=
[
keyOf
(
{
ResponderEventPlugin
:
null
}
)
keyOf
(
{
SimpleEventPlugin
:
null
}
)
keyOf
(
{
TapEventPlugin
:
null
}
)
keyOf
(
{
EnterLeaveEventPlugin
:
null
}
)
keyOf
(
{
ChangeEventPlugin
:
null
}
)
keyOf
(
{
AnalyticsEventPlugin
:
null
}
)
]
;
module
.
exports
=
DefaultEventPluginOrder
;
}
{
"
.
/
keyOf
"
:
79
}
]
12
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
EventPropagators
=
require
(
"
.
/
EventPropagators
"
)
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
ReactInstanceHandles
=
require
(
"
.
/
ReactInstanceHandles
"
)
;
var
SyntheticMouseEvent
=
require
(
"
.
/
SyntheticMouseEvent
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
keyOf
=
require
(
"
.
/
keyOf
"
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
getFirstReactDOM
=
ReactInstanceHandles
.
getFirstReactDOM
;
var
eventTypes
=
{
mouseEnter
:
{
registrationName
:
keyOf
(
{
onMouseEnter
:
null
}
)
}
mouseLeave
:
{
registrationName
:
keyOf
(
{
onMouseLeave
:
null
}
)
}
}
;
var
EnterLeaveEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topMouseOver
&
&
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
fromElement
)
)
{
return
null
;
}
if
(
topLevelType
!
=
=
topLevelTypes
.
topMouseOut
&
&
topLevelType
!
=
=
topLevelTypes
.
topMouseOver
)
{
return
null
;
}
var
from
to
;
if
(
topLevelType
=
=
=
topLevelTypes
.
topMouseOut
)
{
from
=
topLevelTarget
;
to
=
getFirstReactDOM
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
toElement
)
|
|
ExecutionEnvironment
.
global
;
}
else
{
from
=
ExecutionEnvironment
.
global
;
to
=
topLevelTarget
;
}
if
(
from
=
=
=
to
)
{
return
null
;
}
var
fromID
=
from
?
ReactID
.
getID
(
from
)
:
'
'
;
var
toID
=
to
?
ReactID
.
getID
(
to
)
:
'
'
;
var
leave
=
SyntheticMouseEvent
.
getPooled
(
eventTypes
.
mouseLeave
fromID
nativeEvent
)
;
var
enter
=
SyntheticMouseEvent
.
getPooled
(
eventTypes
.
mouseEnter
toID
nativeEvent
)
;
EventPropagators
.
accumulateEnterLeaveDispatches
(
leave
enter
fromID
toID
)
;
return
[
leave
enter
]
;
}
}
;
module
.
exports
=
EnterLeaveEventPlugin
;
}
)
(
)
}
{
"
.
/
EventConstants
"
:
13
"
.
/
EventPropagators
"
:
18
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
ReactID
"
:
35
"
.
/
ReactInstanceHandles
"
:
37
"
.
/
SyntheticMouseEvent
"
:
53
"
.
/
keyOf
"
:
79
}
]
13
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
keyMirror
=
require
(
"
.
/
keyMirror
"
)
;
var
PropagationPhases
=
keyMirror
(
{
bubbled
:
null
captured
:
null
}
)
;
var
topLevelTypes
=
keyMirror
(
{
topBlur
:
null
topChange
:
null
topClick
:
null
topDOMCharacterDataModified
:
null
topDoubleClick
:
null
topDrag
:
null
topDragEnd
:
null
topDragEnter
:
null
topDragExit
:
null
topDragLeave
:
null
topDragOver
:
null
topDragStart
:
null
topDrop
:
null
topFocus
:
null
topInput
:
null
topKeyDown
:
null
topKeyPress
:
null
topKeyUp
:
null
topMouseDown
:
null
topMouseMove
:
null
topMouseOut
:
null
topMouseOver
:
null
topMouseUp
:
null
topScroll
:
null
topSelectionChange
:
null
topSubmit
:
null
topTouchCancel
:
null
topTouchEnd
:
null
topTouchMove
:
null
topTouchStart
:
null
topWheel
:
null
}
)
;
var
EventConstants
=
{
topLevelTypes
:
topLevelTypes
PropagationPhases
:
PropagationPhases
}
;
module
.
exports
=
EventConstants
;
}
{
"
.
/
keyMirror
"
:
78
}
]
14
:
[
function
(
require
module
exports
)
{
var
EventListener
=
{
listen
:
function
(
el
handlerBaseName
cb
)
{
if
(
el
.
addEventListener
)
{
el
.
addEventListener
(
handlerBaseName
cb
false
)
;
}
else
if
(
el
.
attachEvent
)
{
el
.
attachEvent
(
'
on
'
+
handlerBaseName
cb
)
;
}
}
capture
:
function
(
el
handlerBaseName
cb
)
{
if
(
!
el
.
addEventListener
)
{
if
(
true
)
{
console
.
error
(
'
You
are
attempting
to
use
addEventlistener
'
+
'
in
a
browser
that
does
not
support
it
support
it
.
'
+
'
This
likely
means
that
you
will
not
receive
events
that
'
+
'
your
application
relies
on
(
such
as
scroll
)
.
'
)
;
}
return
;
}
else
{
el
.
addEventListener
(
handlerBaseName
cb
true
)
;
}
}
}
;
module
.
exports
=
EventListener
;
}
{
}
]
15
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
CallbackRegistry
=
require
(
"
.
/
CallbackRegistry
"
)
;
var
EventPluginRegistry
=
require
(
"
.
/
EventPluginRegistry
"
)
;
var
EventPluginUtils
=
require
(
"
.
/
EventPluginUtils
"
)
;
var
EventPropagators
=
require
(
"
.
/
EventPropagators
"
)
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
accumulate
=
require
(
"
.
/
accumulate
"
)
;
var
forEachAccumulated
=
require
(
"
.
/
forEachAccumulated
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
eventQueue
=
null
;
var
executeDispatchesAndRelease
=
function
(
event
)
{
if
(
event
)
{
var
executeDispatch
=
EventPluginUtils
.
executeDispatch
;
var
PluginModule
=
EventPluginRegistry
.
getPluginModuleForEvent
(
event
)
;
if
(
PluginModule
&
&
PluginModule
.
executeDispatch
)
{
executeDispatch
=
PluginModule
.
executeDispatch
;
}
EventPluginUtils
.
executeDispatchesInOrder
(
event
executeDispatch
)
;
if
(
!
event
.
isPersistent
(
)
)
{
event
.
constructor
.
release
(
event
)
;
}
}
}
;
var
EventPluginHub
=
{
injection
:
{
injectInstanceHandle
:
EventPropagators
.
injection
.
injectInstanceHandle
injectEventPluginOrder
:
EventPluginRegistry
.
injectEventPluginOrder
injectEventPluginsByName
:
EventPluginRegistry
.
injectEventPluginsByName
}
registrationNames
:
EventPluginRegistry
.
registrationNames
putListener
:
CallbackRegistry
.
putListener
getListener
:
CallbackRegistry
.
getListener
deleteListener
:
CallbackRegistry
.
deleteListener
deleteAllListeners
:
CallbackRegistry
.
deleteAllListeners
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
{
var
events
;
var
plugins
=
EventPluginRegistry
.
plugins
;
for
(
var
i
=
0
l
=
plugins
.
length
;
i
<
l
;
i
+
+
)
{
var
possiblePlugin
=
plugins
[
i
]
;
if
(
possiblePlugin
)
{
var
extractedEvents
=
possiblePlugin
.
extractEvents
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
;
if
(
extractedEvents
)
{
events
=
accumulate
(
events
extractedEvents
)
;
}
}
}
return
events
;
}
enqueueEvents
:
function
(
events
)
{
if
(
events
)
{
eventQueue
=
accumulate
(
eventQueue
events
)
;
}
}
processEventQueue
:
function
(
)
{
var
processingEventQueue
=
eventQueue
;
eventQueue
=
null
;
forEachAccumulated
(
processingEventQueue
executeDispatchesAndRelease
)
;
invariant
(
!
eventQueue
'
processEventQueue
(
)
:
Additional
events
were
enqueued
while
processing
'
+
'
an
event
queue
.
Support
for
this
has
not
yet
been
implemented
.
'
)
;
}
}
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
window
.
EventPluginHub
=
EventPluginHub
;
}
module
.
exports
=
EventPluginHub
;
}
{
"
.
/
CallbackRegistry
"
:
4
"
.
/
EventPluginRegistry
"
:
16
"
.
/
EventPluginUtils
"
:
17
"
.
/
EventPropagators
"
:
18
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
accumulate
"
:
60
"
.
/
forEachAccumulated
"
:
68
"
.
/
invariant
"
:
75
}
]
16
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
EventPluginOrder
=
null
;
var
namesToPlugins
=
{
}
;
function
recomputePluginOrdering
(
)
{
if
(
!
EventPluginOrder
)
{
return
;
}
for
(
var
pluginName
in
namesToPlugins
)
{
var
PluginModule
=
namesToPlugins
[
pluginName
]
;
var
pluginIndex
=
EventPluginOrder
.
indexOf
(
pluginName
)
;
invariant
(
pluginIndex
>
-
1
'
EventPluginRegistry
:
Cannot
inject
event
plugins
that
do
not
exist
in
'
+
'
the
plugin
ordering
%
s
.
'
pluginName
)
;
if
(
EventPluginRegistry
.
plugins
[
pluginIndex
]
)
{
continue
;
}
invariant
(
PluginModule
.
extractEvents
'
EventPluginRegistry
:
Event
plugins
must
implement
an
extractEvents
'
+
'
method
but
%
s
does
not
.
'
pluginName
)
;
EventPluginRegistry
.
plugins
[
pluginIndex
]
=
PluginModule
;
var
publishedEvents
=
PluginModule
.
eventTypes
;
for
(
var
eventName
in
publishedEvents
)
{
invariant
(
publishEventForPlugin
(
publishedEvents
[
eventName
]
PluginModule
)
'
EventPluginRegistry
:
Failed
to
publish
event
%
s
for
plugin
%
s
.
'
eventName
pluginName
)
;
}
}
}
function
publishEventForPlugin
(
dispatchConfig
PluginModule
)
{
var
phasedRegistrationNames
=
dispatchConfig
.
phasedRegistrationNames
;
if
(
phasedRegistrationNames
)
{
for
(
var
phaseName
in
phasedRegistrationNames
)
{
if
(
phasedRegistrationNames
.
hasOwnProperty
(
phaseName
)
)
{
var
phasedRegistrationName
=
phasedRegistrationNames
[
phaseName
]
;
publishRegistrationName
(
phasedRegistrationName
PluginModule
)
;
}
}
return
true
;
}
else
if
(
dispatchConfig
.
registrationName
)
{
publishRegistrationName
(
dispatchConfig
.
registrationName
PluginModule
)
;
return
true
;
}
return
false
;
}
function
publishRegistrationName
(
registrationName
PluginModule
)
{
invariant
(
!
EventPluginRegistry
.
registrationNames
[
registrationName
]
'
EventPluginHub
:
More
than
one
plugin
attempted
to
publish
the
same
'
+
'
registration
name
%
s
.
'
registrationName
)
;
EventPluginRegistry
.
registrationNames
[
registrationName
]
=
PluginModule
;
EventPluginRegistry
.
registrationNamesKeys
.
push
(
registrationName
)
;
}
var
EventPluginRegistry
=
{
plugins
:
[
]
registrationNames
:
{
}
registrationNamesKeys
:
[
]
injectEventPluginOrder
:
function
(
InjectedEventPluginOrder
)
{
invariant
(
!
EventPluginOrder
'
EventPluginRegistry
:
Cannot
inject
event
plugin
ordering
more
than
once
.
'
)
;
EventPluginOrder
=
Array
.
prototype
.
slice
.
call
(
InjectedEventPluginOrder
)
;
recomputePluginOrdering
(
)
;
}
injectEventPluginsByName
:
function
(
injectedNamesToPlugins
)
{
var
isOrderingDirty
=
false
;
for
(
var
pluginName
in
injectedNamesToPlugins
)
{
if
(
!
injectedNamesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
continue
;
}
var
PluginModule
=
injectedNamesToPlugins
[
pluginName
]
;
if
(
namesToPlugins
[
pluginName
]
!
=
=
PluginModule
)
{
invariant
(
!
namesToPlugins
[
pluginName
]
'
EventPluginRegistry
:
Cannot
inject
two
different
event
plugins
'
+
'
using
the
same
name
%
s
.
'
pluginName
)
;
namesToPlugins
[
pluginName
]
=
PluginModule
;
isOrderingDirty
=
true
;
}
}
if
(
isOrderingDirty
)
{
recomputePluginOrdering
(
)
;
}
}
getPluginModuleForEvent
:
function
(
event
)
{
var
dispatchConfig
=
event
.
dispatchConfig
;
if
(
dispatchConfig
.
registrationName
)
{
return
EventPluginRegistry
.
registrationNames
[
dispatchConfig
.
registrationName
]
|
|
null
;
}
for
(
var
phase
in
dispatchConfig
.
phasedRegistrationNames
)
{
if
(
!
dispatchConfig
.
phasedRegistrationNames
.
hasOwnProperty
(
phase
)
)
{
continue
;
}
var
PluginModule
=
EventPluginRegistry
.
registrationNames
[
dispatchConfig
.
phasedRegistrationNames
[
phase
]
]
;
if
(
PluginModule
)
{
return
PluginModule
;
}
}
return
null
;
}
_resetEventPlugins
:
function
(
)
{
EventPluginOrder
=
null
;
for
(
var
pluginName
in
namesToPlugins
)
{
if
(
namesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
delete
namesToPlugins
[
pluginName
]
;
}
}
EventPluginRegistry
.
plugins
.
length
=
0
;
var
registrationNames
=
EventPluginRegistry
.
registrationNames
;
for
(
var
registrationName
in
registrationNames
)
{
if
(
registrationNames
.
hasOwnProperty
(
registrationName
)
)
{
delete
registrationNames
[
registrationName
]
;
}
}
EventPluginRegistry
.
registrationNamesKeys
.
length
=
0
;
}
}
;
module
.
exports
=
EventPluginRegistry
;
}
{
"
.
/
invariant
"
:
75
}
]
17
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
function
isEndish
(
topLevelType
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topMouseUp
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchEnd
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchCancel
;
}
function
isMoveish
(
topLevelType
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topMouseMove
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchMove
;
}
function
isStartish
(
topLevelType
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topMouseDown
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchStart
;
}
var
validateEventDispatches
;
if
(
true
)
{
validateEventDispatches
=
function
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchIDs
=
event
.
_dispatchIDs
;
var
listenersIsArr
=
Array
.
isArray
(
dispatchListeners
)
;
var
idsIsArr
=
Array
.
isArray
(
dispatchIDs
)
;
var
IDsLen
=
idsIsArr
?
dispatchIDs
.
length
:
dispatchIDs
?
1
:
0
;
var
listenersLen
=
listenersIsArr
?
dispatchListeners
.
length
:
dispatchListeners
?
1
:
0
;
invariant
(
idsIsArr
=
=
=
listenersIsArr
&
&
IDsLen
=
=
=
listenersLen
'
EventPluginUtils
:
Invalid
event
.
'
)
;
}
;
}
function
forEachEventDispatch
(
event
cb
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchIDs
=
event
.
_dispatchIDs
;
if
(
true
)
{
validateEventDispatches
(
event
)
;
}
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
cb
(
event
dispatchListeners
[
i
]
dispatchIDs
[
i
]
)
;
}
}
else
if
(
dispatchListeners
)
{
cb
(
event
dispatchListeners
dispatchIDs
)
;
}
}
function
executeDispatch
(
event
listener
domID
)
{
listener
(
event
domID
)
;
}
function
executeDispatchesInOrder
(
event
executeDispatch
)
{
forEachEventDispatch
(
event
executeDispatch
)
;
event
.
_dispatchListeners
=
null
;
event
.
_dispatchIDs
=
null
;
}
function
executeDispatchesInOrderStopAtTrue
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchIDs
=
event
.
_dispatchIDs
;
if
(
true
)
{
validateEventDispatches
(
event
)
;
}
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
if
(
dispatchListeners
[
i
]
(
event
dispatchIDs
[
i
]
)
)
{
return
dispatchIDs
[
i
]
;
}
}
}
else
if
(
dispatchListeners
)
{
if
(
dispatchListeners
(
event
dispatchIDs
)
)
{
return
dispatchIDs
;
}
}
return
null
;
}
function
executeDirectDispatch
(
event
)
{
if
(
true
)
{
validateEventDispatches
(
event
)
;
}
var
dispatchListener
=
event
.
_dispatchListeners
;
var
dispatchID
=
event
.
_dispatchIDs
;
invariant
(
!
Array
.
isArray
(
dispatchListener
)
'
executeDirectDispatch
(
.
.
.
)
:
Invalid
event
.
'
)
;
var
res
=
dispatchListener
?
dispatchListener
(
event
dispatchID
)
:
null
;
event
.
_dispatchListeners
=
null
;
event
.
_dispatchIDs
=
null
;
return
res
;
}
function
hasDispatches
(
event
)
{
return
!
!
event
.
_dispatchListeners
;
}
var
EventPluginUtils
=
{
isEndish
:
isEndish
isMoveish
:
isMoveish
isStartish
:
isStartish
executeDispatchesInOrder
:
executeDispatchesInOrder
executeDispatchesInOrderStopAtTrue
:
executeDispatchesInOrderStopAtTrue
executeDirectDispatch
:
executeDirectDispatch
hasDispatches
:
hasDispatches
executeDispatch
:
executeDispatch
}
;
module
.
exports
=
EventPluginUtils
;
}
{
"
.
/
EventConstants
"
:
13
"
.
/
invariant
"
:
75
}
]
18
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
CallbackRegistry
=
require
(
"
.
/
CallbackRegistry
"
)
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
accumulate
=
require
(
"
.
/
accumulate
"
)
;
var
forEachAccumulated
=
require
(
"
.
/
forEachAccumulated
"
)
;
var
getListener
=
CallbackRegistry
.
getListener
;
var
PropagationPhases
=
EventConstants
.
PropagationPhases
;
var
injection
=
{
InstanceHandle
:
null
injectInstanceHandle
:
function
(
InjectedInstanceHandle
)
{
injection
.
InstanceHandle
=
InjectedInstanceHandle
;
if
(
true
)
{
injection
.
validate
(
)
;
}
}
validate
:
function
(
)
{
var
invalid
=
!
injection
.
InstanceHandle
|
|
!
injection
.
InstanceHandle
.
traverseTwoPhase
|
|
!
injection
.
InstanceHandle
.
traverseEnterLeave
;
if
(
invalid
)
{
throw
new
Error
(
'
InstanceHandle
not
injected
before
use
!
'
)
;
}
}
}
;
function
listenerAtPhase
(
id
event
propagationPhase
)
{
var
registrationName
=
event
.
dispatchConfig
.
phasedRegistrationNames
[
propagationPhase
]
;
return
getListener
(
id
registrationName
)
;
}
function
accumulateDirectionalDispatches
(
domID
upwards
event
)
{
if
(
true
)
{
if
(
!
domID
)
{
throw
new
Error
(
'
Dispatching
id
must
not
be
null
'
)
;
}
injection
.
validate
(
)
;
}
var
phase
=
upwards
?
PropagationPhases
.
bubbled
:
PropagationPhases
.
captured
;
var
listener
=
listenerAtPhase
(
domID
event
phase
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulate
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchIDs
=
accumulate
(
event
.
_dispatchIDs
domID
)
;
}
}
function
accumulateTwoPhaseDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
injection
.
InstanceHandle
.
traverseTwoPhase
(
event
.
dispatchMarker
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateDispatches
(
id
ignoredDirection
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
var
registrationName
=
event
.
dispatchConfig
.
registrationName
;
var
listener
=
getListener
(
id
registrationName
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulate
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchIDs
=
accumulate
(
event
.
_dispatchIDs
id
)
;
}
}
}
function
accumulateDirectDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
accumulateDispatches
(
event
.
dispatchMarker
null
event
)
;
}
}
function
accumulateTwoPhaseDispatches
(
events
)
{
if
(
true
)
{
injection
.
validate
(
)
;
}
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingle
)
;
}
function
accumulateEnterLeaveDispatches
(
leave
enter
fromID
toID
)
{
if
(
true
)
{
injection
.
validate
(
)
;
}
injection
.
InstanceHandle
.
traverseEnterLeave
(
fromID
toID
accumulateDispatches
leave
enter
)
;
}
function
accumulateDirectDispatches
(
events
)
{
if
(
true
)
{
injection
.
validate
(
)
;
}
forEachAccumulated
(
events
accumulateDirectDispatchesSingle
)
;
}
var
EventPropagators
=
{
accumulateTwoPhaseDispatches
:
accumulateTwoPhaseDispatches
accumulateDirectDispatches
:
accumulateDirectDispatches
accumulateEnterLeaveDispatches
:
accumulateEnterLeaveDispatches
injection
:
injection
}
;
module
.
exports
=
EventPropagators
;
}
{
"
.
/
CallbackRegistry
"
:
4
"
.
/
EventConstants
"
:
13
"
.
/
accumulate
"
:
60
"
.
/
forEachAccumulated
"
:
68
}
]
19
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
canUseDOM
=
typeof
window
!
=
=
'
undefined
'
;
var
ExecutionEnvironment
=
{
canUseDOM
:
canUseDOM
canUseWorkers
:
typeof
Worker
!
=
=
'
undefined
'
isInWorker
:
!
canUseDOM
global
:
new
Function
(
'
return
this
;
'
)
(
)
}
;
module
.
exports
=
ExecutionEnvironment
;
}
)
(
)
}
{
}
]
20
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
oneArgumentPooler
=
function
(
copyFieldsFrom
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
copyFieldsFrom
)
;
return
instance
;
}
else
{
return
new
Klass
(
copyFieldsFrom
)
;
}
}
;
var
twoArgumentPooler
=
function
(
a1
a2
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
)
;
}
}
;
var
threeArgumentPooler
=
function
(
a1
a2
a3
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
a3
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
a3
)
;
}
}
;
var
fiveArgumentPooler
=
function
(
a1
a2
a3
a4
a5
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
a3
a4
a5
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
a3
a4
a5
)
;
}
}
;
var
standardReleaser
=
function
(
instance
)
{
var
Klass
=
this
;
if
(
instance
.
destructor
)
{
instance
.
destructor
(
)
;
}
if
(
Klass
.
instancePool
.
length
<
Klass
.
poolSize
)
{
Klass
.
instancePool
.
push
(
instance
)
;
}
}
;
var
DEFAULT_POOL_SIZE
=
10
;
var
DEFAULT_POOLER
=
oneArgumentPooler
;
var
addPoolingTo
=
function
(
CopyConstructor
pooler
)
{
var
NewKlass
=
CopyConstructor
;
NewKlass
.
instancePool
=
[
]
;
NewKlass
.
getPooled
=
pooler
|
|
DEFAULT_POOLER
;
if
(
!
NewKlass
.
poolSize
)
{
NewKlass
.
poolSize
=
DEFAULT_POOL_SIZE
;
}
NewKlass
.
release
=
standardReleaser
;
return
NewKlass
;
}
;
var
PooledClass
=
{
addPoolingTo
:
addPoolingTo
oneArgumentPooler
:
oneArgumentPooler
twoArgumentPooler
:
twoArgumentPooler
threeArgumentPooler
:
threeArgumentPooler
fiveArgumentPooler
:
fiveArgumentPooler
}
;
module
.
exports
=
PooledClass
;
}
{
}
]
21
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactCompositeComponent
=
require
(
"
.
/
ReactCompositeComponent
"
)
;
var
ReactComponent
=
require
(
"
.
/
ReactComponent
"
)
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
ReactMount
=
require
(
"
.
/
ReactMount
"
)
;
var
ReactPropTypes
=
require
(
"
.
/
ReactPropTypes
"
)
;
var
ReactServerRendering
=
require
(
"
.
/
ReactServerRendering
"
)
;
var
ReactDefaultInjection
=
require
(
"
.
/
ReactDefaultInjection
"
)
;
ReactDefaultInjection
.
inject
(
)
;
var
React
=
{
DOM
:
ReactDOM
PropTypes
:
ReactPropTypes
initializeTouchEvents
:
function
(
shouldUseTouch
)
{
ReactMount
.
useTouchEvents
=
shouldUseTouch
;
}
autoBind
:
ReactCompositeComponent
.
autoBind
createClass
:
ReactCompositeComponent
.
createClass
constructAndRenderComponent
:
ReactMount
.
constructAndRenderComponent
constructAndRenderComponentByID
:
ReactMount
.
constructAndRenderComponentByID
renderComponent
:
ReactMount
.
renderComponent
renderComponentToString
:
ReactServerRendering
.
renderComponentToString
unmountAndReleaseReactRootNode
:
ReactMount
.
unmountAndReleaseReactRootNode
isValidComponent
:
ReactComponent
.
isValidComponent
}
;
module
.
exports
=
React
;
}
{
"
.
/
ReactComponent
"
:
22
"
.
/
ReactCompositeComponent
"
:
23
"
.
/
ReactDOM
"
:
25
"
.
/
ReactDefaultInjection
"
:
32
"
.
/
ReactMount
"
:
38
"
.
/
ReactPropTypes
"
:
44
"
.
/
ReactServerRendering
"
:
46
}
]
22
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactCurrentOwner
=
require
(
"
.
/
ReactCurrentOwner
"
)
;
var
ReactDOMIDOperations
=
require
(
"
.
/
ReactDOMIDOperations
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
ReactMount
=
require
(
"
.
/
ReactMount
"
)
;
var
ReactOwner
=
require
(
"
.
/
ReactOwner
"
)
;
var
ReactReconcileTransaction
=
require
(
"
.
/
ReactReconcileTransaction
"
)
;
var
ReactUpdates
=
require
(
"
.
/
ReactUpdates
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
keyMirror
=
require
(
"
.
/
keyMirror
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
OWNER
=
'
{
owner
}
'
;
var
IS_KEY_VALIDATED
=
'
{
is
.
key
.
validated
}
'
;
var
ComponentLifeCycle
=
keyMirror
(
{
MOUNTED
:
null
UNMOUNTED
:
null
}
)
;
var
ownerHasWarned
=
{
}
;
function
validateExplicitKey
(
component
)
{
if
(
component
[
IS_KEY_VALIDATED
]
|
|
component
.
props
.
key
!
=
null
)
{
return
;
}
component
[
IS_KEY_VALIDATED
]
=
true
;
if
(
!
ReactCurrentOwner
.
current
)
{
return
;
}
var
currentName
=
ReactCurrentOwner
.
current
.
constructor
.
displayName
;
if
(
ownerHasWarned
.
hasOwnProperty
(
currentName
)
)
{
return
;
}
ownerHasWarned
[
currentName
]
=
true
;
var
message
=
'
Each
child
in
an
array
should
have
a
unique
"
key
"
prop
.
'
+
'
Check
the
render
method
of
'
+
currentName
+
'
.
'
;
if
(
!
component
.
isOwnedBy
(
ReactCurrentOwner
.
current
)
)
{
var
childOwnerName
=
component
.
props
[
OWNER
]
&
&
component
.
props
[
OWNER
]
.
constructor
.
displayName
;
message
+
=
'
It
was
passed
a
child
from
'
+
childOwnerName
+
'
.
'
;
}
console
.
warn
(
message
)
;
}
function
validateChildKeys
(
component
)
{
if
(
Array
.
isArray
(
component
)
)
{
for
(
var
i
=
0
;
i
<
component
.
length
;
i
+
+
)
{
var
child
=
component
[
i
]
;
if
(
ReactComponent
.
isValidComponent
(
child
)
)
{
validateExplicitKey
(
child
)
;
}
}
}
else
if
(
ReactComponent
.
isValidComponent
(
component
)
)
{
component
[
IS_KEY_VALIDATED
]
=
true
;
}
}
var
ReactComponent
=
{
isValidComponent
:
function
(
object
)
{
return
!
!
(
object
&
&
typeof
object
.
mountComponentIntoNode
=
=
=
'
function
'
&
&
typeof
object
.
receiveProps
=
=
=
'
function
'
)
;
}
getKey
:
function
(
component
index
)
{
if
(
component
&
&
component
.
props
&
&
component
.
props
.
key
!
=
null
)
{
return
'
'
+
component
.
props
.
key
;
}
return
'
'
+
index
;
}
LifeCycle
:
ComponentLifeCycle
DOMIDOperations
:
ReactDOMIDOperations
ReactReconcileTransaction
:
ReactReconcileTransaction
setDOMOperations
:
function
(
DOMIDOperations
)
{
ReactComponent
.
DOMIDOperations
=
DOMIDOperations
;
}
setReactReconcileTransaction
:
function
(
ReactReconcileTransaction
)
{
ReactComponent
.
ReactReconcileTransaction
=
ReactReconcileTransaction
;
}
Mixin
:
{
isMounted
:
function
(
)
{
return
this
.
_lifeCycleState
=
=
=
ComponentLifeCycle
.
MOUNTED
;
}
getDOMNode
:
function
(
)
{
invariant
(
this
.
isMounted
(
)
'
getDOMNode
(
)
:
A
component
must
be
mounted
to
have
a
DOM
node
.
'
)
;
return
ReactID
.
getNode
(
this
.
_rootNodeID
)
;
}
setProps
:
function
(
partialProps
callback
)
{
this
.
replaceProps
(
merge
(
this
.
_pendingProps
|
|
this
.
props
partialProps
)
callback
)
;
}
replaceProps
:
function
(
props
callback
)
{
invariant
(
!
this
.
props
[
OWNER
]
'
replaceProps
(
.
.
.
)
:
You
called
setProps
or
replaceProps
on
a
'
+
'
component
with
an
owner
.
This
is
an
anti
-
pattern
since
props
will
'
+
'
get
reactively
updated
when
rendered
.
Instead
change
the
owner
\
'
s
'
+
'
render
method
to
pass
the
correct
value
as
props
to
the
component
'
+
'
where
it
is
created
.
'
)
;
this
.
_pendingProps
=
props
;
ReactUpdates
.
enqueueUpdate
(
this
callback
)
;
}
construct
:
function
(
initialProps
children
)
{
this
.
props
=
initialProps
|
|
{
}
;
this
.
props
[
OWNER
]
=
ReactCurrentOwner
.
current
;
this
.
_lifeCycleState
=
ComponentLifeCycle
.
UNMOUNTED
;
this
.
_pendingProps
=
null
;
this
.
_pendingCallbacks
=
null
;
var
childrenLength
=
arguments
.
length
-
1
;
if
(
childrenLength
=
=
=
1
)
{
if
(
true
)
{
validateChildKeys
(
children
)
;
}
this
.
props
.
children
=
children
;
}
else
if
(
childrenLength
>
1
)
{
var
childArray
=
Array
(
childrenLength
)
;
for
(
var
i
=
0
;
i
<
childrenLength
;
i
+
+
)
{
if
(
true
)
{
validateChildKeys
(
arguments
[
i
+
1
]
)
;
}
childArray
[
i
]
=
arguments
[
i
+
1
]
;
}
this
.
props
.
children
=
childArray
;
}
}
mountComponent
:
function
(
rootID
transaction
)
{
invariant
(
!
this
.
isMounted
(
)
'
mountComponent
(
%
s
.
.
.
)
:
Can
only
mount
an
unmounted
component
.
'
rootID
)
;
var
props
=
this
.
props
;
if
(
props
.
ref
!
=
null
)
{
ReactOwner
.
addComponentAsRefTo
(
this
props
.
ref
props
[
OWNER
]
)
;
}
this
.
_rootNodeID
=
rootID
;
this
.
_lifeCycleState
=
ComponentLifeCycle
.
MOUNTED
;
}
unmountComponent
:
function
(
)
{
invariant
(
this
.
isMounted
(
)
'
unmountComponent
(
)
:
Can
only
unmount
a
mounted
component
.
'
)
;
var
props
=
this
.
props
;
if
(
props
.
ref
!
=
null
)
{
ReactOwner
.
removeComponentAsRefFrom
(
this
props
.
ref
props
[
OWNER
]
)
;
}
ReactID
.
purgeID
(
this
.
_rootNodeID
)
;
this
.
_rootNodeID
=
null
;
this
.
_lifeCycleState
=
ComponentLifeCycle
.
UNMOUNTED
;
}
receiveProps
:
function
(
nextProps
transaction
)
{
invariant
(
this
.
isMounted
(
)
'
receiveProps
(
.
.
.
)
:
Can
only
update
a
mounted
component
.
'
)
;
this
.
_pendingProps
=
nextProps
;
this
.
_performUpdateIfNecessary
(
transaction
)
;
}
performUpdateIfNecessary
:
function
(
)
{
var
transaction
=
ReactComponent
.
ReactReconcileTransaction
.
getPooled
(
)
;
transaction
.
perform
(
this
.
_performUpdateIfNecessary
this
transaction
)
;
ReactComponent
.
ReactReconcileTransaction
.
release
(
transaction
)
;
}
_performUpdateIfNecessary
:
function
(
transaction
)
{
if
(
this
.
_pendingProps
=
=
null
)
{
return
;
}
var
prevProps
=
this
.
props
;
this
.
props
=
this
.
_pendingProps
;
this
.
_pendingProps
=
null
;
this
.
updateComponent
(
transaction
prevProps
)
;
}
updateComponent
:
function
(
transaction
prevProps
)
{
var
props
=
this
.
props
;
if
(
props
[
OWNER
]
!
=
=
prevProps
[
OWNER
]
|
|
props
.
ref
!
=
=
prevProps
.
ref
)
{
if
(
prevProps
.
ref
!
=
null
)
{
ReactOwner
.
removeComponentAsRefFrom
(
this
prevProps
.
ref
prevProps
[
OWNER
]
)
;
}
if
(
props
.
ref
!
=
null
)
{
ReactOwner
.
addComponentAsRefTo
(
this
props
.
ref
props
[
OWNER
]
)
;
}
}
}
mountComponentIntoNode
:
function
(
rootID
container
shouldReuseMarkup
)
{
var
transaction
=
ReactComponent
.
ReactReconcileTransaction
.
getPooled
(
)
;
transaction
.
perform
(
this
.
_mountComponentIntoNode
this
rootID
container
transaction
shouldReuseMarkup
)
;
ReactComponent
.
ReactReconcileTransaction
.
release
(
transaction
)
;
}
_mountComponentIntoNode
:
function
(
rootID
container
transaction
shouldReuseMarkup
)
{
invariant
(
container
&
&
container
.
nodeType
=
=
=
1
'
mountComponentIntoNode
(
.
.
.
)
:
Target
container
is
not
a
DOM
element
.
'
)
;
var
renderStart
=
Date
.
now
(
)
;
var
markup
=
this
.
mountComponent
(
rootID
transaction
)
;
ReactMount
.
totalInstantiationTime
+
=
(
Date
.
now
(
)
-
renderStart
)
;
if
(
shouldReuseMarkup
)
{
return
;
}
var
injectionStart
=
Date
.
now
(
)
;
var
parent
=
container
.
parentNode
;
if
(
parent
)
{
var
next
=
container
.
nextSibling
;
parent
.
removeChild
(
container
)
;
container
.
innerHTML
=
markup
;
if
(
next
)
{
parent
.
insertBefore
(
container
next
)
;
}
else
{
parent
.
appendChild
(
container
)
;
}
}
else
{
container
.
innerHTML
=
markup
;
}
ReactMount
.
totalInjectionTime
+
=
(
Date
.
now
(
)
-
injectionStart
)
;
}
unmountComponentFromNode
:
function
(
container
)
{
this
.
unmountComponent
(
)
;
while
(
container
.
lastChild
)
{
container
.
removeChild
(
container
.
lastChild
)
;
}
}
isOwnedBy
:
function
(
owner
)
{
return
this
.
props
[
OWNER
]
=
=
=
owner
;
}
getSiblingByRef
:
function
(
ref
)
{
var
owner
=
this
.
props
[
OWNER
]
;
if
(
!
owner
|
|
!
owner
.
refs
)
{
return
null
;
}
return
owner
.
refs
[
ref
]
;
}
}
}
;
module
.
exports
=
ReactComponent
;
}
{
"
.
/
ReactCurrentOwner
"
:
24
"
.
/
ReactDOMIDOperations
"
:
27
"
.
/
ReactID
"
:
35
"
.
/
ReactMount
"
:
38
"
.
/
ReactOwner
"
:
42
"
.
/
ReactReconcileTransaction
"
:
45
"
.
/
ReactUpdates
"
:
48
"
.
/
invariant
"
:
75
"
.
/
keyMirror
"
:
78
"
.
/
merge
"
:
81
}
]
23
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
ReactComponent
=
require
(
"
.
/
ReactComponent
"
)
;
var
ReactCurrentOwner
=
require
(
"
.
/
ReactCurrentOwner
"
)
;
var
ReactOwner
=
require
(
"
.
/
ReactOwner
"
)
;
var
ReactPropTransferer
=
require
(
"
.
/
ReactPropTransferer
"
)
;
var
ReactUpdates
=
require
(
"
.
/
ReactUpdates
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
keyMirror
=
require
(
"
.
/
keyMirror
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
mixInto
=
require
(
"
.
/
mixInto
"
)
;
var
SpecPolicy
=
keyMirror
(
{
DEFINE_ONCE
:
null
DEFINE_MANY
:
null
OVERRIDE_BASE
:
null
}
)
;
var
ReactCompositeComponentInterface
=
{
mixins
:
SpecPolicy
.
DEFINE_MANY
propTypes
:
SpecPolicy
.
DEFINE_ONCE
getDefaultProps
:
SpecPolicy
.
DEFINE_ONCE
getInitialState
:
SpecPolicy
.
DEFINE_ONCE
render
:
SpecPolicy
.
DEFINE_ONCE
componentWillMount
:
SpecPolicy
.
DEFINE_MANY
componentDidMount
:
SpecPolicy
.
DEFINE_MANY
componentWillReceiveProps
:
SpecPolicy
.
DEFINE_MANY
shouldComponentUpdate
:
SpecPolicy
.
DEFINE_ONCE
componentWillUpdate
:
SpecPolicy
.
DEFINE_MANY
componentDidUpdate
:
SpecPolicy
.
DEFINE_MANY
componentWillUnmount
:
SpecPolicy
.
DEFINE_MANY
updateComponent
:
SpecPolicy
.
OVERRIDE_BASE
}
;
var
RESERVED_SPEC_KEYS
=
{
displayName
:
function
(
Constructor
displayName
)
{
Constructor
.
displayName
=
displayName
;
}
mixins
:
function
(
Constructor
mixins
)
{
if
(
mixins
)
{
for
(
var
i
=
0
;
i
<
mixins
.
length
;
i
+
+
)
{
mixSpecIntoComponent
(
Constructor
mixins
[
i
]
)
;
}
}
}
propTypes
:
function
(
Constructor
propTypes
)
{
Constructor
.
propTypes
=
propTypes
;
}
}
;
function
validateMethodOverride
(
proto
name
)
{
var
specPolicy
=
ReactCompositeComponentInterface
[
name
]
;
if
(
ReactCompositeComponentMixin
.
hasOwnProperty
(
name
)
)
{
invariant
(
specPolicy
=
=
=
SpecPolicy
.
OVERRIDE_BASE
'
ReactCompositeComponentInterface
:
You
are
attempting
to
override
'
+
'
%
s
from
your
class
specification
.
Ensure
that
your
method
names
'
+
'
do
not
overlap
with
React
methods
.
'
name
)
;
}
if
(
proto
.
hasOwnProperty
(
name
)
)
{
invariant
(
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY
'
ReactCompositeComponentInterface
:
You
are
attempting
to
define
'
+
'
%
s
on
your
component
more
than
once
.
This
conflict
may
be
due
'
+
'
to
a
mixin
.
'
name
)
;
}
}
function
validateLifeCycleOnReplaceState
(
instance
)
{
var
compositeLifeCycleState
=
instance
.
_compositeLifeCycleState
;
invariant
(
instance
.
isMounted
(
)
|
|
compositeLifeCycleState
=
=
=
CompositeLifeCycle
.
MOUNTING
'
replaceState
(
.
.
.
)
:
Can
only
update
a
mounted
or
mounting
component
.
'
)
;
invariant
(
compositeLifeCycleState
!
=
=
CompositeLifeCycle
.
RECEIVING_STATE
&
&
compositeLifeCycleState
!
=
=
CompositeLifeCycle
.
UNMOUNTING
'
replaceState
(
.
.
.
)
:
Cannot
update
while
unmounting
component
or
during
'
+
'
an
existing
state
transition
(
such
as
within
render
)
.
'
)
;
}
function
mixSpecIntoComponent
(
Constructor
spec
)
{
var
proto
=
Constructor
.
prototype
;
for
(
var
name
in
spec
)
{
var
property
=
spec
[
name
]
;
if
(
!
spec
.
hasOwnProperty
(
name
)
|
|
!
property
)
{
continue
;
}
validateMethodOverride
(
proto
name
)
;
if
(
RESERVED_SPEC_KEYS
.
hasOwnProperty
(
name
)
)
{
RESERVED_SPEC_KEYS
[
name
]
(
Constructor
property
)
;
}
else
{
var
isCompositeComponentMethod
=
name
in
ReactCompositeComponentInterface
;
var
isInherited
=
name
in
proto
;
var
markedDontBind
=
property
.
__reactDontBind
;
var
isFunction
=
typeof
property
=
=
=
'
function
'
;
var
shouldAutoBind
=
isFunction
&
&
!
isCompositeComponentMethod
&
&
!
isInherited
&
&
!
markedDontBind
;
if
(
shouldAutoBind
)
{
if
(
!
proto
.
__reactAutoBindMap
)
{
proto
.
__reactAutoBindMap
=
{
}
;
}
proto
.
__reactAutoBindMap
[
name
]
=
property
;
proto
[
name
]
=
property
;
}
else
{
if
(
isInherited
)
{
proto
[
name
]
=
createChainedFunction
(
proto
[
name
]
property
)
;
}
else
{
proto
[
name
]
=
property
;
}
}
}
}
}
function
createChainedFunction
(
one
two
)
{
return
function
chainedFunction
(
)
{
one
.
apply
(
this
arguments
)
;
two
.
apply
(
this
arguments
)
;
}
;
}
var
CompositeLifeCycle
=
keyMirror
(
{
MOUNTING
:
null
UNMOUNTING
:
null
RECEIVING_PROPS
:
null
RECEIVING_STATE
:
null
}
)
;
var
ReactCompositeComponentMixin
=
{
construct
:
function
(
initialProps
children
)
{
ReactComponent
.
Mixin
.
construct
.
apply
(
this
arguments
)
;
this
.
state
=
null
;
this
.
_pendingState
=
null
;
this
.
_compositeLifeCycleState
=
null
;
}
isMounted
:
function
(
)
{
return
ReactComponent
.
Mixin
.
isMounted
.
call
(
this
)
&
&
this
.
_compositeLifeCycleState
!
=
=
CompositeLifeCycle
.
MOUNTING
;
}
mountComponent
:
function
(
rootID
transaction
)
{
ReactComponent
.
Mixin
.
mountComponent
.
call
(
this
rootID
transaction
)
;
this
.
_compositeLifeCycleState
=
CompositeLifeCycle
.
MOUNTING
;
this
.
_defaultProps
=
this
.
getDefaultProps
?
this
.
getDefaultProps
(
)
:
null
;
this
.
_processProps
(
this
.
props
)
;
if
(
this
.
__reactAutoBindMap
)
{
this
.
_bindAutoBindMethods
(
)
;
}
this
.
state
=
this
.
getInitialState
?
this
.
getInitialState
(
)
:
null
;
this
.
_pendingState
=
null
;
this
.
_pendingForceUpdate
=
false
;
if
(
this
.
componentWillMount
)
{
this
.
componentWillMount
(
)
;
if
(
this
.
_pendingState
)
{
this
.
state
=
this
.
_pendingState
;
this
.
_pendingState
=
null
;
}
}
this
.
_renderedComponent
=
this
.
_renderValidatedComponent
(
)
;
this
.
_compositeLifeCycleState
=
null
;
var
markup
=
this
.
_renderedComponent
.
mountComponent
(
rootID
transaction
)
;
if
(
this
.
componentDidMount
)
{
transaction
.
getReactOnDOMReady
(
)
.
enqueue
(
this
this
.
componentDidMount
)
;
}
return
markup
;
}
unmountComponent
:
function
(
)
{
this
.
_compositeLifeCycleState
=
CompositeLifeCycle
.
UNMOUNTING
;
if
(
this
.
componentWillUnmount
)
{
this
.
componentWillUnmount
(
)
;
}
this
.
_compositeLifeCycleState
=
null
;
this
.
_defaultProps
=
null
;
ReactComponent
.
Mixin
.
unmountComponent
.
call
(
this
)
;
this
.
_renderedComponent
.
unmountComponent
(
)
;
this
.
_renderedComponent
=
null
;
if
(
this
.
refs
)
{
this
.
refs
=
null
;
}
}
setState
:
function
(
partialState
callback
)
{
this
.
replaceState
(
merge
(
this
.
_pendingState
|
|
this
.
state
partialState
)
callback
)
;
}
replaceState
:
function
(
completeState
callback
)
{
validateLifeCycleOnReplaceState
(
this
)
;
this
.
_pendingState
=
completeState
;
ReactUpdates
.
enqueueUpdate
(
this
callback
)
;
}
_processProps
:
function
(
props
)
{
var
propName
;
var
defaultProps
=
this
.
_defaultProps
;
for
(
propName
in
defaultProps
)
{
if
(
!
(
propName
in
props
)
)
{
props
[
propName
]
=
defaultProps
[
propName
]
;
}
}
var
propTypes
=
this
.
constructor
.
propTypes
;
if
(
propTypes
)
{
var
componentName
=
this
.
constructor
.
displayName
;
for
(
propName
in
propTypes
)
{
var
checkProp
=
propTypes
[
propName
]
;
if
(
checkProp
)
{
checkProp
(
props
propName
componentName
)
;
}
}
}
}
performUpdateIfNecessary
:
function
(
)
{
var
compositeLifeCycleState
=
this
.
_compositeLifeCycleState
;
if
(
compositeLifeCycleState
=
=
=
CompositeLifeCycle
.
MOUNTING
|
|
compositeLifeCycleState
=
=
=
CompositeLifeCycle
.
RECEIVING_PROPS
)
{
return
;
}
ReactComponent
.
Mixin
.
performUpdateIfNecessary
.
call
(
this
)
;
}
_performUpdateIfNecessary
:
function
(
transaction
)
{
if
(
this
.
_pendingProps
=
=
null
&
&
this
.
_pendingState
=
=
null
&
&
!
this
.
_pendingForceUpdate
)
{
return
;
}
var
nextProps
=
this
.
props
;
if
(
this
.
_pendingProps
!
=
null
)
{
nextProps
=
this
.
_pendingProps
;
this
.
_processProps
(
nextProps
)
;
this
.
_pendingProps
=
null
;
this
.
_compositeLifeCycleState
=
CompositeLifeCycle
.
RECEIVING_PROPS
;
if
(
this
.
componentWillReceiveProps
)
{
this
.
componentWillReceiveProps
(
nextProps
transaction
)
;
}
}
this
.
_compositeLifeCycleState
=
CompositeLifeCycle
.
RECEIVING_STATE
;
var
nextState
=
this
.
_pendingState
|
|
this
.
state
;
this
.
_pendingState
=
null
;
if
(
this
.
_pendingForceUpdate
|
|
!
this
.
shouldComponentUpdate
|
|
this
.
shouldComponentUpdate
(
nextProps
nextState
)
)
{
this
.
_pendingForceUpdate
=
false
;
this
.
_performComponentUpdate
(
nextProps
nextState
transaction
)
;
}
else
{
this
.
props
=
nextProps
;
this
.
state
=
nextState
;
}
this
.
_compositeLifeCycleState
=
null
;
}
_performComponentUpdate
:
function
(
nextProps
nextState
transaction
)
{
var
prevProps
=
this
.
props
;
var
prevState
=
this
.
state
;
if
(
this
.
componentWillUpdate
)
{
this
.
componentWillUpdate
(
nextProps
nextState
transaction
)
;
}
this
.
props
=
nextProps
;
this
.
state
=
nextState
;
this
.
updateComponent
(
transaction
prevProps
prevState
)
;
if
(
this
.
componentDidUpdate
)
{
transaction
.
getReactOnDOMReady
(
)
.
enqueue
(
this
this
.
componentDidUpdate
.
bind
(
this
prevProps
prevState
)
)
;
}
}
updateComponent
:
function
(
transaction
prevProps
prevState
)
{
ReactComponent
.
Mixin
.
updateComponent
.
call
(
this
transaction
prevProps
)
;
var
currentComponent
=
this
.
_renderedComponent
;
var
nextComponent
=
this
.
_renderValidatedComponent
(
)
;
if
(
currentComponent
.
constructor
=
=
=
nextComponent
.
constructor
)
{
currentComponent
.
receiveProps
(
nextComponent
.
props
transaction
)
;
}
else
{
var
thisID
=
this
.
_rootNodeID
;
var
currentComponentID
=
currentComponent
.
_rootNodeID
;
currentComponent
.
unmountComponent
(
)
;
var
nextMarkup
=
nextComponent
.
mountComponent
(
thisID
transaction
)
;
ReactComponent
.
DOMIDOperations
.
dangerouslyReplaceNodeWithMarkupByID
(
currentComponentID
nextMarkup
)
;
this
.
_renderedComponent
=
nextComponent
;
}
}
forceUpdate
:
function
(
callback
)
{
var
compositeLifeCycleState
=
this
.
_compositeLifeCycleState
;
invariant
(
this
.
isMounted
(
)
|
|
compositeLifeCycleState
=
=
=
CompositeLifeCycle
.
MOUNTING
'
forceUpdate
(
.
.
.
)
:
Can
only
force
an
update
on
mounted
or
mounting
'
+
'
components
.
'
)
;
invariant
(
compositeLifeCycleState
!
=
=
CompositeLifeCycle
.
RECEIVING_STATE
&
&
compositeLifeCycleState
!
=
=
CompositeLifeCycle
.
UNMOUNTING
'
forceUpdate
(
.
.
.
)
:
Cannot
force
an
update
while
unmounting
component
'
+
'
or
during
an
existing
state
transition
(
such
as
within
render
)
.
'
)
;
this
.
_pendingForceUpdate
=
true
;
ReactUpdates
.
enqueueUpdate
(
this
callback
)
;
}
_renderValidatedComponent
:
function
(
)
{
var
renderedComponent
;
ReactCurrentOwner
.
current
=
this
;
try
{
renderedComponent
=
this
.
render
(
)
;
}
catch
(
error
)
{
throw
error
;
}
finally
{
ReactCurrentOwner
.
current
=
null
;
}
invariant
(
ReactComponent
.
isValidComponent
(
renderedComponent
)
'
%
s
.
render
(
)
:
A
valid
ReactComponent
must
be
returned
.
'
this
.
constructor
.
displayName
|
|
'
ReactCompositeComponent
'
)
;
return
renderedComponent
;
}
_bindAutoBindMethods
:
function
(
)
{
for
(
var
autoBindKey
in
this
.
__reactAutoBindMap
)
{
if
(
!
this
.
__reactAutoBindMap
.
hasOwnProperty
(
autoBindKey
)
)
{
continue
;
}
var
method
=
this
.
__reactAutoBindMap
[
autoBindKey
]
;
this
[
autoBindKey
]
=
this
.
_bindAutoBindMethod
(
method
)
;
}
}
_bindAutoBindMethod
:
function
(
method
)
{
var
component
=
this
;
var
boundMethod
=
function
(
)
{
return
method
.
apply
(
component
arguments
)
;
}
;
if
(
true
)
{
var
componentName
=
component
.
constructor
.
displayName
;
var
_bind
=
boundMethod
.
bind
;
boundMethod
.
bind
=
function
(
newThis
)
{
if
(
newThis
!
=
=
component
)
{
console
.
warn
(
'
bind
(
)
:
React
component
methods
may
only
be
bound
to
the
'
+
'
component
instance
.
See
'
+
componentName
)
;
}
else
if
(
arguments
.
length
=
=
=
1
)
{
console
.
warn
(
'
bind
(
)
:
You
are
binding
a
component
method
to
the
component
.
'
+
'
React
does
this
for
you
automatically
in
a
high
-
performance
'
+
'
way
so
you
can
safely
remove
this
call
.
See
'
+
componentName
)
;
return
boundMethod
;
}
return
_bind
.
apply
(
boundMethod
arguments
)
;
}
;
}
return
boundMethod
;
}
}
;
var
ReactCompositeComponentBase
=
function
(
)
{
}
;
mixInto
(
ReactCompositeComponentBase
ReactComponent
.
Mixin
)
;
mixInto
(
ReactCompositeComponentBase
ReactOwner
.
Mixin
)
;
mixInto
(
ReactCompositeComponentBase
ReactPropTransferer
.
Mixin
)
;
mixInto
(
ReactCompositeComponentBase
ReactCompositeComponentMixin
)
;
var
ReactCompositeComponent
=
{
LifeCycle
:
CompositeLifeCycle
Base
:
ReactCompositeComponentBase
createClass
:
function
(
spec
)
{
var
Constructor
=
function
(
)
{
}
;
Constructor
.
prototype
=
new
ReactCompositeComponentBase
(
)
;
Constructor
.
prototype
.
constructor
=
Constructor
;
mixSpecIntoComponent
(
Constructor
spec
)
;
invariant
(
Constructor
.
prototype
.
render
'
createClass
(
.
.
.
)
:
Class
specification
must
implement
a
render
method
.
'
)
;
for
(
var
methodName
in
ReactCompositeComponentInterface
)
{
if
(
!
Constructor
.
prototype
[
methodName
]
)
{
Constructor
.
prototype
[
methodName
]
=
null
;
}
}
var
ConvenienceConstructor
=
function
(
props
children
)
{
var
instance
=
new
Constructor
(
)
;
instance
.
construct
.
apply
(
instance
arguments
)
;
return
instance
;
}
;
ConvenienceConstructor
.
componentConstructor
=
Constructor
;
ConvenienceConstructor
.
originalSpec
=
spec
;
return
ConvenienceConstructor
;
}
autoBind
:
function
(
method
)
{
if
(
true
)
{
console
.
warn
(
'
React
.
autoBind
(
)
is
now
deprecated
.
All
React
component
methods
'
+
'
are
auto
bound
by
default
so
React
.
autoBind
(
)
is
a
no
-
op
.
It
'
+
'
will
be
removed
in
the
next
version
of
React
'
)
;
}
return
method
;
}
}
;
module
.
exports
=
ReactCompositeComponent
;
}
)
(
)
}
{
"
.
/
ReactComponent
"
:
22
"
.
/
ReactCurrentOwner
"
:
24
"
.
/
ReactOwner
"
:
42
"
.
/
ReactPropTransferer
"
:
43
"
.
/
ReactUpdates
"
:
48
"
.
/
invariant
"
:
75
"
.
/
keyMirror
"
:
78
"
.
/
merge
"
:
81
"
.
/
mixInto
"
:
84
}
]
24
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactCurrentOwner
=
{
current
:
null
}
;
module
.
exports
=
ReactCurrentOwner
;
}
{
}
]
25
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactNativeComponent
=
require
(
"
.
/
ReactNativeComponent
"
)
;
var
mergeInto
=
require
(
"
.
/
mergeInto
"
)
;
var
objMapKeyVal
=
require
(
"
.
/
objMapKeyVal
"
)
;
function
createDOMComponentClass
(
tag
omitClose
)
{
var
Constructor
=
function
(
)
{
}
;
Constructor
.
prototype
=
new
ReactNativeComponent
(
tag
omitClose
)
;
Constructor
.
prototype
.
constructor
=
Constructor
;
var
ConvenienceConstructor
=
function
(
props
children
)
{
var
instance
=
new
Constructor
(
)
;
instance
.
construct
.
apply
(
instance
arguments
)
;
return
instance
;
}
;
ConvenienceConstructor
.
componentConstructor
=
Constructor
;
return
ConvenienceConstructor
;
}
var
ReactDOM
=
objMapKeyVal
(
{
a
:
false
abbr
:
false
address
:
false
area
:
false
article
:
false
aside
:
false
audio
:
false
b
:
false
base
:
false
bdi
:
false
bdo
:
false
big
:
false
blockquote
:
false
body
:
false
br
:
true
button
:
false
canvas
:
false
caption
:
false
cite
:
false
code
:
false
col
:
true
colgroup
:
false
data
:
false
datalist
:
false
dd
:
false
del
:
false
details
:
false
dfn
:
false
div
:
false
dl
:
false
dt
:
false
em
:
false
embed
:
true
fieldset
:
false
figcaption
:
false
figure
:
false
footer
:
false
form
:
false
h1
:
false
h2
:
false
h3
:
false
h4
:
false
h5
:
false
h6
:
false
head
:
false
header
:
false
hr
:
true
html
:
false
i
:
false
iframe
:
false
img
:
true
input
:
true
ins
:
false
kbd
:
false
keygen
:
true
label
:
false
legend
:
false
li
:
false
link
:
false
main
:
false
map
:
false
mark
:
false
menu
:
false
menuitem
:
false
meta
:
true
meter
:
false
nav
:
false
noscript
:
false
object
:
false
ol
:
false
optgroup
:
false
option
:
false
output
:
false
p
:
false
param
:
true
pre
:
false
progress
:
false
q
:
false
rp
:
false
rt
:
false
ruby
:
false
s
:
false
samp
:
false
script
:
false
section
:
false
select
:
false
small
:
false
source
:
false
span
:
false
strong
:
false
style
:
false
sub
:
false
summary
:
false
sup
:
false
table
:
false
tbody
:
false
td
:
false
textarea
:
false
tfoot
:
false
th
:
false
thead
:
false
time
:
false
title
:
false
tr
:
false
track
:
true
u
:
false
ul
:
false
'
var
'
:
false
video
:
false
wbr
:
false
circle
:
false
g
:
false
line
:
false
path
:
false
polyline
:
false
rect
:
false
svg
:
false
text
:
false
}
createDOMComponentClass
)
;
var
injection
=
{
injectComponentClasses
:
function
(
componentClasses
)
{
mergeInto
(
ReactDOM
componentClasses
)
;
}
}
;
ReactDOM
.
injection
=
injection
;
module
.
exports
=
ReactDOM
;
}
{
"
.
/
ReactNativeComponent
"
:
40
"
.
/
mergeInto
"
:
83
"
.
/
objMapKeyVal
"
:
85
}
]
26
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactCompositeComponent
=
require
(
"
.
/
ReactCompositeComponent
"
)
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
ReactEventEmitter
=
require
(
"
.
/
ReactEventEmitter
"
)
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
form
=
ReactDOM
.
form
;
var
ReactDOMForm
=
ReactCompositeComponent
.
createClass
(
{
render
:
function
(
)
{
return
this
.
transferPropsTo
(
form
(
null
this
.
props
.
children
)
)
;
}
componentDidMount
:
function
(
node
)
{
ReactEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
.
topSubmit
'
submit
'
node
)
;
}
}
)
;
module
.
exports
=
ReactDOMForm
;
}
{
"
.
/
EventConstants
"
:
13
"
.
/
ReactCompositeComponent
"
:
23
"
.
/
ReactDOM
"
:
25
"
.
/
ReactEventEmitter
"
:
33
}
]
27
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
CSSPropertyOperations
=
require
(
"
.
/
CSSPropertyOperations
"
)
;
var
DOMChildrenOperations
=
require
(
"
.
/
DOMChildrenOperations
"
)
;
var
DOMPropertyOperations
=
require
(
"
.
/
DOMPropertyOperations
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
getTextContentAccessor
=
require
(
"
.
/
getTextContentAccessor
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
INVALID_PROPERTY_ERRORS
=
{
dangerouslySetInnerHTML
:
'
dangerouslySetInnerHTML
must
be
set
using
updateInnerHTMLByID
(
)
.
'
style
:
'
style
must
be
set
using
updateStylesByID
(
)
.
'
}
;
var
textContentAccessor
=
getTextContentAccessor
(
)
|
|
'
NA
'
;
var
ReactDOMIDOperations
=
{
updatePropertyByID
:
function
(
id
name
value
)
{
var
node
=
ReactID
.
getNode
(
id
)
;
invariant
(
!
INVALID_PROPERTY_ERRORS
.
hasOwnProperty
(
name
)
'
updatePropertyByID
(
.
.
.
)
:
%
s
'
INVALID_PROPERTY_ERRORS
[
name
]
)
;
DOMPropertyOperations
.
setValueForProperty
(
node
name
value
)
;
}
deletePropertyByID
:
function
(
id
name
value
)
{
var
node
=
ReactID
.
getNode
(
id
)
;
invariant
(
!
INVALID_PROPERTY_ERRORS
.
hasOwnProperty
(
name
)
'
updatePropertyByID
(
.
.
.
)
:
%
s
'
INVALID_PROPERTY_ERRORS
[
name
]
)
;
DOMPropertyOperations
.
deleteValueForProperty
(
node
name
value
)
;
}
updatePropertiesByID
:
function
(
id
properties
)
{
for
(
var
name
in
properties
)
{
if
(
!
properties
.
hasOwnProperty
(
name
)
)
{
continue
;
}
ReactDOMIDOperations
.
updatePropertiesByID
(
id
name
properties
[
name
]
)
;
}
}
updateStylesByID
:
function
(
id
styles
)
{
var
node
=
ReactID
.
getNode
(
id
)
;
CSSPropertyOperations
.
setValueForStyles
(
node
styles
)
;
}
updateInnerHTMLByID
:
function
(
id
html
)
{
var
node
=
ReactID
.
getNode
(
id
)
;
node
.
innerHTML
=
(
html
&
&
html
.
__html
|
|
'
'
)
.
replace
(
/
^
/
g
'
&
nbsp
;
'
)
;
}
updateTextContentByID
:
function
(
id
content
)
{
var
node
=
ReactID
.
getNode
(
id
)
;
node
[
textContentAccessor
]
=
content
;
}
dangerouslyReplaceNodeWithMarkupByID
:
function
(
id
markup
)
{
var
node
=
ReactID
.
getNode
(
id
)
;
DOMChildrenOperations
.
dangerouslyReplaceNodeWithMarkup
(
node
markup
)
;
}
manageChildrenByParentID
:
function
(
parentID
domOperations
)
{
var
parent
=
ReactID
.
getNode
(
parentID
)
;
DOMChildrenOperations
.
manageChildren
(
parent
domOperations
)
;
}
}
;
module
.
exports
=
ReactDOMIDOperations
;
}
)
(
)
}
{
"
.
/
CSSPropertyOperations
"
:
3
"
.
/
DOMChildrenOperations
"
:
6
"
.
/
DOMPropertyOperations
"
:
8
"
.
/
ReactID
"
:
35
"
.
/
getTextContentAccessor
"
:
71
"
.
/
invariant
"
:
75
}
]
28
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
DOMPropertyOperations
=
require
(
"
.
/
DOMPropertyOperations
"
)
;
var
ReactCompositeComponent
=
require
(
"
.
/
ReactCompositeComponent
"
)
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
input
=
ReactDOM
.
input
;
var
ReactDOMInput
=
ReactCompositeComponent
.
createClass
(
{
getInitialState
:
function
(
)
{
return
{
checked
:
this
.
props
.
defaultChecked
|
|
false
value
:
this
.
props
.
defaultValue
|
|
'
'
}
;
}
shouldComponentUpdate
:
function
(
)
{
return
!
this
.
_isChanging
;
}
getChecked
:
function
(
)
{
return
this
.
props
.
checked
!
=
null
?
this
.
props
.
checked
:
this
.
state
.
checked
;
}
getValue
:
function
(
)
{
return
this
.
props
.
value
!
=
null
?
'
'
+
this
.
props
.
value
:
this
.
state
.
value
;
}
render
:
function
(
)
{
var
props
=
merge
(
this
.
props
)
;
props
.
checked
=
this
.
getChecked
(
)
;
props
.
value
=
this
.
getValue
(
)
;
props
.
onChange
=
this
.
handleChange
;
return
input
(
props
this
.
props
.
children
)
;
}
componentDidUpdate
:
function
(
prevProps
prevState
rootNode
)
{
if
(
this
.
props
.
checked
!
=
null
)
{
DOMPropertyOperations
.
setValueForProperty
(
rootNode
'
checked
'
this
.
props
.
checked
|
|
false
)
;
}
if
(
this
.
props
.
value
!
=
null
)
{
DOMPropertyOperations
.
setValueForProperty
(
rootNode
'
value
'
'
'
+
this
.
props
.
value
|
|
'
'
)
;
}
}
handleChange
:
function
(
event
)
{
var
returnValue
;
if
(
this
.
props
.
onChange
)
{
this
.
_isChanging
=
true
;
returnValue
=
this
.
props
.
onChange
(
event
)
;
this
.
_isChanging
=
false
;
}
this
.
setState
(
{
checked
:
event
.
target
.
checked
value
:
event
.
target
.
value
}
)
;
return
returnValue
;
}
}
)
;
module
.
exports
=
ReactDOMInput
;
}
{
"
.
/
DOMPropertyOperations
"
:
8
"
.
/
ReactCompositeComponent
"
:
23
"
.
/
ReactDOM
"
:
25
"
.
/
merge
"
:
81
}
]
29
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactCompositeComponent
=
require
(
"
.
/
ReactCompositeComponent
"
)
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
option
=
ReactDOM
.
option
;
var
ReactDOMOption
=
ReactCompositeComponent
.
createClass
(
{
componentWillMount
:
function
(
)
{
if
(
this
.
props
.
selected
!
=
null
)
{
if
(
true
)
{
console
.
warn
(
'
Use
the
defaultValue
or
value
props
on
<
select
>
instead
of
'
+
'
setting
selected
on
<
option
>
.
'
)
;
}
}
}
render
:
function
(
)
{
return
option
(
this
.
props
this
.
props
.
children
)
;
}
}
)
;
module
.
exports
=
ReactDOMOption
;
}
{
"
.
/
ReactCompositeComponent
"
:
23
"
.
/
ReactDOM
"
:
25
}
]
30
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactCompositeComponent
=
require
(
"
.
/
ReactCompositeComponent
"
)
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
select
=
ReactDOM
.
select
;
function
selectValueType
(
props
propName
componentName
)
{
if
(
props
[
propName
]
=
=
null
)
{
return
;
}
if
(
props
.
multiple
)
{
invariant
(
Array
.
isArray
(
props
[
propName
]
)
'
The
%
s
prop
supplied
to
<
select
>
must
be
an
array
if
multiple
is
'
+
'
true
.
'
propName
)
;
}
else
{
invariant
(
!
Array
.
isArray
(
props
[
propName
]
)
'
The
%
s
prop
supplied
to
<
select
>
must
be
a
scalar
value
if
'
+
'
multiple
is
false
.
'
propName
)
;
}
}
function
updateOptions
(
)
{
if
(
this
.
props
.
value
=
=
null
)
{
return
;
}
var
options
=
this
.
getDOMNode
(
)
.
options
;
var
selectedValue
=
'
'
+
this
.
props
.
value
;
for
(
var
i
=
0
l
=
options
.
length
;
i
<
l
;
i
+
+
)
{
var
selected
=
this
.
props
.
multiple
?
selectedValue
.
indexOf
(
options
[
i
]
.
value
)
>
=
0
:
selected
=
options
[
i
]
.
value
=
=
=
selectedValue
;
if
(
selected
!
=
=
options
[
i
]
.
selected
)
{
options
[
i
]
.
selected
=
selected
;
}
}
}
var
ReactDOMSelect
=
ReactCompositeComponent
.
createClass
(
{
propTypes
:
{
defaultValue
:
selectValueType
value
:
selectValueType
}
getInitialState
:
function
(
)
{
return
{
value
:
this
.
props
.
defaultValue
|
|
(
this
.
props
.
multiple
?
[
]
:
'
'
)
}
;
}
componentWillReceiveProps
:
function
(
nextProps
)
{
if
(
!
this
.
props
.
multiple
&
&
nextProps
.
multiple
)
{
this
.
setState
(
{
value
:
[
this
.
state
.
value
]
}
)
;
}
else
if
(
this
.
props
.
multiple
&
&
!
nextProps
.
multiple
)
{
this
.
setState
(
{
value
:
this
.
state
.
value
[
0
]
}
)
;
}
}
shouldComponentUpdate
:
function
(
)
{
return
!
this
.
_isChanging
;
}
render
:
function
(
)
{
var
props
=
merge
(
this
.
props
)
;
props
.
onChange
=
this
.
handleChange
;
props
.
value
=
null
;
return
select
(
props
this
.
props
.
children
)
;
}
componentDidMount
:
updateOptions
componentDidUpdate
:
updateOptions
handleChange
:
function
(
event
)
{
var
returnValue
;
if
(
this
.
props
.
onChange
)
{
this
.
_isChanging
=
true
;
returnValue
=
this
.
props
.
onChange
(
event
)
;
this
.
_isChanging
=
false
;
}
var
selectedValue
;
if
(
this
.
props
.
multiple
)
{
selectedValue
=
[
]
;
var
options
=
event
.
target
.
options
;
for
(
var
i
=
0
l
=
options
.
length
;
i
<
l
;
i
+
+
)
{
if
(
options
[
i
]
.
selected
)
{
selectedValue
.
push
(
options
[
i
]
.
value
)
;
}
}
}
else
{
selectedValue
=
event
.
target
.
value
;
}
this
.
setState
(
{
value
:
selectedValue
}
)
;
return
returnValue
;
}
}
)
;
module
.
exports
=
ReactDOMSelect
;
}
{
"
.
/
ReactCompositeComponent
"
:
23
"
.
/
ReactDOM
"
:
25
"
.
/
invariant
"
:
75
"
.
/
merge
"
:
81
}
]
31
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
DOMPropertyOperations
=
require
(
"
.
/
DOMPropertyOperations
"
)
;
var
ReactCompositeComponent
=
require
(
"
.
/
ReactCompositeComponent
"
)
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
textarea
=
ReactDOM
.
textarea
;
var
CONTENT_TYPES
=
{
'
string
'
:
true
'
number
'
:
true
}
;
var
ReactDOMTextarea
=
ReactCompositeComponent
.
createClass
(
{
getInitialState
:
function
(
)
{
var
defaultValue
=
this
.
props
.
defaultValue
;
var
children
=
this
.
props
.
children
;
if
(
children
!
=
null
)
{
if
(
true
)
{
console
.
warn
(
'
Use
the
defaultValue
or
value
props
instead
of
setting
'
+
'
children
on
<
textarea
>
.
'
)
;
}
invariant
(
defaultValue
=
=
null
'
If
you
supply
defaultValue
on
a
<
textarea
>
do
not
pass
children
.
'
)
;
if
(
Array
.
isArray
(
children
)
)
{
invariant
(
children
.
length
<
=
1
'
<
textarea
>
can
only
have
at
most
one
child
.
'
)
;
children
=
children
[
0
]
;
}
invariant
(
CONTENT_TYPES
[
typeof
children
]
'
If
you
specify
children
to
<
textarea
>
it
must
be
a
single
string
'
+
'
or
number
.
not
an
array
or
object
.
'
)
;
defaultValue
=
'
'
+
children
;
}
defaultValue
=
defaultValue
|
|
'
'
;
return
{
initialValue
:
this
.
props
.
value
!
=
null
?
this
.
props
.
value
:
defaultValue
value
:
defaultValue
}
;
}
shouldComponentUpdate
:
function
(
)
{
return
!
this
.
_isChanging
;
}
getValue
:
function
(
)
{
return
this
.
props
.
value
!
=
null
?
this
.
props
.
value
:
this
.
state
.
value
;
}
render
:
function
(
)
{
var
props
=
merge
(
this
.
props
)
;
invariant
(
props
.
dangerouslySetInnerHTML
=
=
null
'
dangerouslySetInnerHTML
does
not
make
sense
on
<
textarea
>
.
'
)
;
props
.
value
=
this
.
getValue
(
)
;
props
.
onChange
=
this
.
handleChange
;
return
textarea
(
props
this
.
state
.
initialValue
)
;
}
componentDidUpdate
:
function
(
prevProps
prevState
rootNode
)
{
if
(
this
.
props
.
value
!
=
null
)
{
DOMPropertyOperations
.
setValueForProperty
(
rootNode
'
value
'
this
.
props
.
value
|
|
'
'
)
;
}
}
handleChange
:
function
(
event
)
{
var
returnValue
;
if
(
this
.
props
.
onChange
)
{
this
.
_isChanging
=
true
;
returnValue
=
this
.
props
.
onChange
(
event
)
;
this
.
_isChanging
=
false
;
}
this
.
setState
(
{
value
:
event
.
target
.
value
}
)
;
return
returnValue
;
}
}
)
;
module
.
exports
=
ReactDOMTextarea
;
}
{
"
.
/
DOMPropertyOperations
"
:
8
"
.
/
ReactCompositeComponent
"
:
23
"
.
/
ReactDOM
"
:
25
"
.
/
invariant
"
:
75
"
.
/
merge
"
:
81
}
]
32
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactDOM
=
require
(
"
.
/
ReactDOM
"
)
;
var
ReactDOMForm
=
require
(
"
.
/
ReactDOMForm
"
)
;
var
ReactDOMInput
=
require
(
"
.
/
ReactDOMInput
"
)
;
var
ReactDOMOption
=
require
(
"
.
/
ReactDOMOption
"
)
;
var
ReactDOMSelect
=
require
(
"
.
/
ReactDOMSelect
"
)
;
var
ReactDOMTextarea
=
require
(
"
.
/
ReactDOMTextarea
"
)
;
var
DefaultDOMPropertyConfig
=
require
(
"
.
/
DefaultDOMPropertyConfig
"
)
;
var
DOMProperty
=
require
(
"
.
/
DOMProperty
"
)
;
var
DefaultEventPluginOrder
=
require
(
"
.
/
DefaultEventPluginOrder
"
)
;
var
EnterLeaveEventPlugin
=
require
(
"
.
/
EnterLeaveEventPlugin
"
)
;
var
ChangeEventPlugin
=
require
(
"
.
/
ChangeEventPlugin
"
)
;
var
EventPluginHub
=
require
(
"
.
/
EventPluginHub
"
)
;
var
ReactInstanceHandles
=
require
(
"
.
/
ReactInstanceHandles
"
)
;
var
SimpleEventPlugin
=
require
(
"
.
/
SimpleEventPlugin
"
)
;
function
inject
(
)
{
EventPluginHub
.
injection
.
injectEventPluginOrder
(
DefaultEventPluginOrder
)
;
EventPluginHub
.
injection
.
injectInstanceHandle
(
ReactInstanceHandles
)
;
EventPluginHub
.
injection
.
injectEventPluginsByName
(
{
'
SimpleEventPlugin
'
:
SimpleEventPlugin
'
EnterLeaveEventPlugin
'
:
EnterLeaveEventPlugin
'
ChangeEventPlugin
'
:
ChangeEventPlugin
}
)
;
ReactDOM
.
injection
.
injectComponentClasses
(
{
form
:
ReactDOMForm
input
:
ReactDOMInput
option
:
ReactDOMOption
select
:
ReactDOMSelect
textarea
:
ReactDOMTextarea
}
)
;
DOMProperty
.
injection
.
injectDOMPropertyConfig
(
DefaultDOMPropertyConfig
)
;
}
module
.
exports
=
{
inject
:
inject
}
;
}
{
"
.
/
ChangeEventPlugin
"
:
5
"
.
/
DOMProperty
"
:
7
"
.
/
DefaultDOMPropertyConfig
"
:
10
"
.
/
DefaultEventPluginOrder
"
:
11
"
.
/
EnterLeaveEventPlugin
"
:
12
"
.
/
EventPluginHub
"
:
15
"
.
/
ReactDOM
"
:
25
"
.
/
ReactDOMForm
"
:
26
"
.
/
ReactDOMInput
"
:
28
"
.
/
ReactDOMOption
"
:
29
"
.
/
ReactDOMSelect
"
:
30
"
.
/
ReactDOMTextarea
"
:
31
"
.
/
ReactInstanceHandles
"
:
37
"
.
/
SimpleEventPlugin
"
:
49
}
]
33
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
EventListener
=
require
(
"
.
/
EventListener
"
)
;
var
EventPluginHub
=
require
(
"
.
/
EventPluginHub
"
)
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
ReactUpdates
=
require
(
"
.
/
ReactUpdates
"
)
;
var
ViewportMetrics
=
require
(
"
.
/
ViewportMetrics
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
isEventSupported
=
require
(
"
.
/
isEventSupported
"
)
;
var
_isListening
=
false
;
function
trapBubbledEvent
(
topLevelType
handlerBaseName
element
)
{
EventListener
.
listen
(
element
handlerBaseName
ReactEventEmitter
.
TopLevelCallbackCreator
.
createTopLevelCallback
(
topLevelType
)
)
;
}
function
trapCapturedEvent
(
topLevelType
handlerBaseName
element
)
{
EventListener
.
capture
(
element
handlerBaseName
ReactEventEmitter
.
TopLevelCallbackCreator
.
createTopLevelCallback
(
topLevelType
)
)
;
}
function
registerScrollValueMonitoring
(
)
{
var
refresh
=
ViewportMetrics
.
refreshScrollValues
;
EventListener
.
listen
(
window
'
scroll
'
refresh
)
;
EventListener
.
listen
(
window
'
resize
'
refresh
)
;
}
function
listenAtTopLevel
(
touchNotMouse
)
{
invariant
(
!
_isListening
'
listenAtTopLevel
(
.
.
.
)
:
Cannot
setup
top
-
level
listener
more
than
once
.
'
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
mountAt
=
document
;
registerScrollValueMonitoring
(
)
;
trapBubbledEvent
(
topLevelTypes
.
topMouseOver
'
mouseover
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topMouseDown
'
mousedown
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topMouseUp
'
mouseup
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topMouseMove
'
mousemove
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topMouseOut
'
mouseout
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topClick
'
click
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDoubleClick
'
dblclick
'
mountAt
)
;
if
(
touchNotMouse
)
{
trapBubbledEvent
(
topLevelTypes
.
topTouchStart
'
touchstart
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topTouchEnd
'
touchend
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topTouchMove
'
touchmove
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topTouchCancel
'
touchcancel
'
mountAt
)
;
}
trapBubbledEvent
(
topLevelTypes
.
topKeyUp
'
keyup
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topKeyPress
'
keypress
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topKeyDown
'
keydown
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topInput
'
input
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topChange
'
change
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topSelectionChange
'
selectionchange
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDOMCharacterDataModified
'
DOMCharacterDataModified
'
mountAt
)
;
if
(
isEventSupported
(
'
drag
'
)
)
{
trapBubbledEvent
(
topLevelTypes
.
topDrag
'
drag
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDragEnd
'
dragend
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDragEnter
'
dragenter
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDragExit
'
dragexit
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDragLeave
'
dragleave
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDragOver
'
dragover
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDragStart
'
dragstart
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topDrop
'
drop
'
mountAt
)
;
}
if
(
isEventSupported
(
'
wheel
'
)
)
{
trapBubbledEvent
(
topLevelTypes
.
topWheel
'
wheel
'
mountAt
)
;
}
else
if
(
isEventSupported
(
'
mousewheel
'
)
)
{
trapBubbledEvent
(
topLevelTypes
.
topWheel
'
mousewheel
'
mountAt
)
;
}
else
{
trapBubbledEvent
(
topLevelTypes
.
topWheel
'
DOMMouseScroll
'
mountAt
)
;
}
if
(
isEventSupported
(
'
scroll
'
true
)
)
{
trapCapturedEvent
(
topLevelTypes
.
topScroll
'
scroll
'
mountAt
)
;
}
else
{
trapBubbledEvent
(
topLevelTypes
.
topScroll
'
scroll
'
window
)
;
}
if
(
isEventSupported
(
'
focus
'
true
)
)
{
trapCapturedEvent
(
topLevelTypes
.
topFocus
'
focus
'
mountAt
)
;
trapCapturedEvent
(
topLevelTypes
.
topBlur
'
blur
'
mountAt
)
;
}
else
if
(
isEventSupported
(
'
focusin
'
)
)
{
trapBubbledEvent
(
topLevelTypes
.
topFocus
'
focusin
'
mountAt
)
;
trapBubbledEvent
(
topLevelTypes
.
topBlur
'
focusout
'
mountAt
)
;
}
}
var
ReactEventEmitter
=
{
TopLevelCallbackCreator
:
null
ensureListening
:
function
(
touchNotMouse
TopLevelCallbackCreator
)
{
invariant
(
ExecutionEnvironment
.
canUseDOM
'
ensureListening
(
.
.
.
)
:
Cannot
toggle
event
listening
in
a
Worker
'
+
'
thread
.
This
is
likely
a
bug
in
the
framework
.
Please
report
'
+
'
immediately
.
'
)
;
if
(
!
_isListening
)
{
ReactEventEmitter
.
TopLevelCallbackCreator
=
TopLevelCallbackCreator
;
listenAtTopLevel
(
touchNotMouse
)
;
_isListening
=
true
;
}
}
setEnabled
:
function
(
enabled
)
{
invariant
(
ExecutionEnvironment
.
canUseDOM
'
setEnabled
(
.
.
.
)
:
Cannot
toggle
event
listening
in
a
Worker
thread
.
'
+
'
This
is
likely
a
bug
in
the
framework
.
Please
report
immediately
.
'
)
;
if
(
ReactEventEmitter
.
TopLevelCallbackCreator
)
{
ReactEventEmitter
.
TopLevelCallbackCreator
.
setEnabled
(
enabled
)
;
}
}
isEnabled
:
function
(
)
{
return
!
!
(
ReactEventEmitter
.
TopLevelCallbackCreator
&
&
ReactEventEmitter
.
TopLevelCallbackCreator
.
isEnabled
(
)
)
;
}
handleTopLevel
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
{
var
events
=
EventPluginHub
.
extractEvents
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
;
ReactUpdates
.
batchedUpdates
(
function
(
)
{
EventPluginHub
.
enqueueEvents
(
events
)
;
EventPluginHub
.
processEventQueue
(
)
;
}
)
;
}
registrationNames
:
EventPluginHub
.
registrationNames
putListener
:
EventPluginHub
.
putListener
getListener
:
EventPluginHub
.
getListener
deleteListener
:
EventPluginHub
.
deleteListener
deleteAllListeners
:
EventPluginHub
.
deleteAllListeners
trapBubbledEvent
:
trapBubbledEvent
trapCapturedEvent
:
trapCapturedEvent
}
;
module
.
exports
=
ReactEventEmitter
;
}
)
(
)
}
{
"
.
/
EventConstants
"
:
13
"
.
/
EventListener
"
:
14
"
.
/
EventPluginHub
"
:
15
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
ReactUpdates
"
:
48
"
.
/
ViewportMetrics
"
:
59
"
.
/
invariant
"
:
75
"
.
/
isEventSupported
"
:
76
}
]
34
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
ReactEventEmitter
=
require
(
"
.
/
ReactEventEmitter
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
ReactInstanceHandles
=
require
(
"
.
/
ReactInstanceHandles
"
)
;
var
getEventTarget
=
require
(
"
.
/
getEventTarget
"
)
;
var
_topLevelListenersEnabled
=
true
;
var
ReactEventTopLevelCallback
=
{
setEnabled
:
function
(
enabled
)
{
_topLevelListenersEnabled
=
!
!
enabled
;
}
isEnabled
:
function
(
)
{
return
_topLevelListenersEnabled
;
}
createTopLevelCallback
:
function
(
topLevelType
)
{
return
function
(
nativeEvent
)
{
if
(
!
_topLevelListenersEnabled
)
{
return
;
}
if
(
nativeEvent
.
srcElement
&
&
nativeEvent
.
srcElement
!
=
=
nativeEvent
.
target
)
{
nativeEvent
.
target
=
nativeEvent
.
srcElement
;
}
var
topLevelTarget
=
ReactInstanceHandles
.
getFirstReactDOM
(
getEventTarget
(
nativeEvent
)
)
|
|
ExecutionEnvironment
.
global
;
var
topLevelTargetID
=
ReactID
.
getID
(
topLevelTarget
)
|
|
'
'
;
ReactEventEmitter
.
handleTopLevel
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
;
}
;
}
}
;
module
.
exports
=
ReactEventTopLevelCallback
;
}
)
(
)
}
{
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
ReactEventEmitter
"
:
33
"
.
/
ReactID
"
:
35
"
.
/
ReactInstanceHandles
"
:
37
"
.
/
getEventTarget
"
:
70
}
]
35
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
ReactMount
=
require
(
"
.
/
ReactMount
"
)
;
var
ATTR_NAME
=
'
data
-
reactid
'
;
var
nodeCache
=
{
}
;
function
getID
(
node
)
{
var
id
=
internalGetID
(
node
)
;
if
(
id
)
{
if
(
nodeCache
.
hasOwnProperty
(
id
)
)
{
var
cached
=
nodeCache
[
id
]
;
if
(
cached
!
=
=
node
)
{
invariant
(
!
isValid
(
cached
id
)
'
ReactID
:
Two
valid
but
unequal
nodes
with
the
same
%
s
:
%
s
'
ATTR_NAME
id
)
;
nodeCache
[
id
]
=
node
;
}
}
else
{
nodeCache
[
id
]
=
node
;
}
}
return
id
;
}
function
internalGetID
(
node
)
{
if
(
node
&
&
node
.
getAttributeNode
)
{
var
attributeNode
=
node
.
getAttributeNode
(
ATTR_NAME
)
;
if
(
attributeNode
)
{
return
attributeNode
.
value
|
|
'
'
;
}
}
return
'
'
;
}
function
setID
(
node
id
)
{
var
oldID
=
internalGetID
(
node
)
;
if
(
oldID
!
=
=
id
)
{
delete
nodeCache
[
oldID
]
;
}
node
.
setAttribute
(
ATTR_NAME
id
)
;
nodeCache
[
id
]
=
node
;
}
function
getNode
(
id
)
{
if
(
!
nodeCache
.
hasOwnProperty
(
id
)
|
|
!
isValid
(
nodeCache
[
id
]
id
)
)
{
nodeCache
[
id
]
=
ReactMount
.
findReactNodeByID
(
id
)
;
}
return
nodeCache
[
id
]
;
}
function
isValid
(
node
id
)
{
if
(
node
)
{
invariant
(
internalGetID
(
node
)
=
=
=
id
'
ReactID
:
Unexpected
modification
of
%
s
'
ATTR_NAME
)
;
var
container
=
ReactMount
.
findReactContainerForID
(
id
)
;
if
(
container
&
&
contains
(
container
node
)
)
{
return
true
;
}
}
return
false
;
}
function
contains
(
ancestor
descendant
)
{
if
(
ancestor
.
contains
)
{
return
ancestor
.
contains
(
descendant
)
;
}
if
(
descendant
=
=
=
ancestor
)
{
return
true
;
}
if
(
descendant
.
nodeType
=
=
=
3
)
{
descendant
=
descendant
.
parentNode
;
}
while
(
descendant
&
&
descendant
.
nodeType
=
=
=
1
)
{
if
(
descendant
=
=
=
ancestor
)
{
return
true
;
}
descendant
=
descendant
.
parentNode
;
}
return
false
;
}
function
purgeID
(
id
)
{
delete
nodeCache
[
id
]
;
}
exports
.
ATTR_NAME
=
ATTR_NAME
;
exports
.
getID
=
getID
;
exports
.
rawGetID
=
internalGetID
;
exports
.
setID
=
setID
;
exports
.
getNode
=
getNode
;
exports
.
purgeID
=
purgeID
;
}
{
"
.
/
ReactMount
"
:
38
"
.
/
invariant
"
:
75
}
]
36
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
function
getActiveElement
(
)
{
try
{
return
document
.
activeElement
;
}
catch
(
e
)
{
}
}
function
isInDocument
(
node
)
{
return
document
.
documentElement
.
contains
(
node
)
;
}
var
ReactInputSelection
=
{
hasSelectionCapabilities
:
function
(
elem
)
{
return
elem
&
&
(
(
elem
.
nodeName
=
=
=
'
INPUT
'
&
&
elem
.
type
=
=
=
'
text
'
)
|
|
elem
.
nodeName
=
=
=
'
TEXTAREA
'
|
|
elem
.
contentEditable
=
=
=
'
true
'
)
;
}
getSelectionInformation
:
function
(
)
{
var
focusedElem
=
getActiveElement
(
)
;
return
{
focusedElem
:
focusedElem
selectionRange
:
ReactInputSelection
.
hasSelectionCapabilities
(
focusedElem
)
?
ReactInputSelection
.
getSelection
(
focusedElem
)
:
null
}
;
}
restoreSelection
:
function
(
priorSelectionInformation
)
{
var
curFocusedElem
=
getActiveElement
(
)
;
var
priorFocusedElem
=
priorSelectionInformation
.
focusedElem
;
var
priorSelectionRange
=
priorSelectionInformation
.
selectionRange
;
if
(
curFocusedElem
!
=
=
priorFocusedElem
&
&
isInDocument
(
priorFocusedElem
)
)
{
if
(
ReactInputSelection
.
hasSelectionCapabilities
(
priorFocusedElem
)
)
{
ReactInputSelection
.
setSelection
(
priorFocusedElem
priorSelectionRange
)
;
}
priorFocusedElem
.
focus
(
)
;
}
}
getSelection
:
function
(
input
)
{
var
range
;
if
(
input
.
contentEditable
=
=
=
'
true
'
&
&
window
.
getSelection
)
{
range
=
window
.
getSelection
(
)
.
getRangeAt
(
0
)
;
var
commonAncestor
=
range
.
commonAncestorContainer
;
if
(
commonAncestor
&
&
commonAncestor
.
nodeType
=
=
=
3
)
{
commonAncestor
=
commonAncestor
.
parentNode
;
}
if
(
commonAncestor
!
=
=
input
)
{
return
{
start
:
0
end
:
0
}
;
}
else
{
return
{
start
:
range
.
startOffset
end
:
range
.
endOffset
}
;
}
}
if
(
!
document
.
selection
)
{
return
{
start
:
input
.
selectionStart
end
:
input
.
selectionEnd
}
;
}
range
=
document
.
selection
.
createRange
(
)
;
if
(
range
.
parentElement
(
)
!
=
=
input
)
{
return
{
start
:
0
end
:
0
}
;
}
var
length
=
input
.
value
.
length
;
if
(
input
.
nodeName
=
=
=
'
INPUT
'
)
{
return
{
start
:
-
range
.
moveStart
(
'
character
'
-
length
)
end
:
-
range
.
moveEnd
(
'
character
'
-
length
)
}
;
}
else
{
var
range2
=
range
.
duplicate
(
)
;
range2
.
moveToElementText
(
input
)
;
range2
.
setEndPoint
(
'
StartToEnd
'
range
)
;
var
end
=
length
-
range2
.
text
.
length
;
range2
.
setEndPoint
(
'
StartToStart
'
range
)
;
return
{
start
:
length
-
range2
.
text
.
length
end
:
end
}
;
}
}
setSelection
:
function
(
input
rangeObj
)
{
var
range
;
var
start
=
rangeObj
.
start
;
var
end
=
rangeObj
.
end
;
if
(
typeof
end
=
=
=
'
undefined
'
)
{
end
=
start
;
}
if
(
document
.
selection
)
{
if
(
input
.
tagName
=
=
=
'
TEXTAREA
'
)
{
var
cr_before
=
(
input
.
value
.
slice
(
0
start
)
.
match
(
/
\
r
/
g
)
|
|
[
]
)
.
length
;
var
cr_inside
=
(
input
.
value
.
slice
(
start
end
)
.
match
(
/
\
r
/
g
)
|
|
[
]
)
.
length
;
start
-
=
cr_before
;
end
-
=
cr_before
+
cr_inside
;
}
range
=
input
.
createTextRange
(
)
;
range
.
collapse
(
true
)
;
range
.
moveStart
(
'
character
'
start
)
;
range
.
moveEnd
(
'
character
'
end
-
start
)
;
range
.
select
(
)
;
}
else
{
if
(
input
.
contentEditable
=
=
=
'
true
'
)
{
if
(
input
.
childNodes
.
length
=
=
=
1
)
{
range
=
document
.
createRange
(
)
;
range
.
setStart
(
input
.
childNodes
[
0
]
start
)
;
range
.
setEnd
(
input
.
childNodes
[
0
]
end
)
;
var
sel
=
window
.
getSelection
(
)
;
sel
.
removeAllRanges
(
)
;
sel
.
addRange
(
range
)
;
}
}
else
{
input
.
selectionStart
=
start
;
input
.
selectionEnd
=
Math
.
min
(
end
input
.
value
.
length
)
;
input
.
focus
(
)
;
}
}
}
}
;
module
.
exports
=
ReactInputSelection
;
}
{
}
]
37
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
SEPARATOR
=
'
.
'
;
var
SEPARATOR_LENGTH
=
SEPARATOR
.
length
;
var
MAX_TREE_DEPTH
=
100
;
var
GLOBAL_MOUNT_POINT_MAX
=
9999999
;
function
getReactRootIDString
(
index
)
{
return
SEPARATOR
+
'
r
[
'
+
index
.
toString
(
36
)
+
'
]
'
;
}
function
isBoundary
(
id
index
)
{
return
id
.
charAt
(
index
)
=
=
=
SEPARATOR
|
|
index
=
=
=
id
.
length
;
}
function
isValidID
(
id
)
{
return
id
=
=
=
'
'
|
|
(
id
.
charAt
(
0
)
=
=
=
SEPARATOR
&
&
id
.
charAt
(
id
.
length
-
1
)
!
=
=
SEPARATOR
)
;
}
function
isAncestorIDOf
(
ancestorID
descendantID
)
{
return
(
descendantID
.
indexOf
(
ancestorID
)
=
=
=
0
&
&
isBoundary
(
descendantID
ancestorID
.
length
)
)
;
}
function
getParentID
(
id
)
{
return
id
?
id
.
substr
(
0
id
.
lastIndexOf
(
SEPARATOR
)
)
:
'
'
;
}
function
getNextDescendantID
(
ancestorID
destinationID
)
{
invariant
(
isValidID
(
ancestorID
)
&
&
isValidID
(
destinationID
)
'
getNextDescendantID
(
%
s
%
s
)
:
Received
an
invalid
React
DOM
ID
.
'
ancestorID
destinationID
)
;
invariant
(
isAncestorIDOf
(
ancestorID
destinationID
)
'
getNextDescendantID
(
.
.
.
)
:
React
has
made
an
invalid
assumption
about
'
+
'
the
DOM
hierarchy
.
Expected
%
s
to
be
an
ancestor
of
%
s
.
'
ancestorID
destinationID
)
;
if
(
ancestorID
=
=
=
destinationID
)
{
return
ancestorID
;
}
var
start
=
ancestorID
.
length
+
SEPARATOR_LENGTH
;
for
(
var
i
=
start
;
i
<
destinationID
.
length
;
i
+
+
)
{
if
(
isBoundary
(
destinationID
i
)
)
{
break
;
}
}
return
destinationID
.
substr
(
0
i
)
;
}
function
getFirstCommonAncestorID
(
oneID
twoID
)
{
var
minLength
=
Math
.
min
(
oneID
.
length
twoID
.
length
)
;
if
(
minLength
=
=
=
0
)
{
return
'
'
;
}
var
lastCommonMarkerIndex
=
0
;
for
(
var
i
=
0
;
i
<
=
minLength
;
i
+
+
)
{
if
(
isBoundary
(
oneID
i
)
&
&
isBoundary
(
twoID
i
)
)
{
lastCommonMarkerIndex
=
i
;
}
else
if
(
oneID
.
charAt
(
i
)
!
=
=
twoID
.
charAt
(
i
)
)
{
break
;
}
}
var
longestCommonID
=
oneID
.
substr
(
0
lastCommonMarkerIndex
)
;
invariant
(
isValidID
(
longestCommonID
)
'
getFirstCommonAncestorID
(
%
s
%
s
)
:
Expected
a
valid
React
DOM
ID
:
%
s
'
oneID
twoID
longestCommonID
)
;
return
longestCommonID
;
}
function
traverseParentPath
(
start
stop
cb
arg
skipFirst
skipLast
)
{
start
=
start
|
|
'
'
;
stop
=
stop
|
|
'
'
;
invariant
(
start
!
=
=
stop
'
traverseParentPath
(
.
.
.
)
:
Cannot
traverse
from
and
to
the
same
ID
%
s
.
'
start
)
;
var
traverseUp
=
isAncestorIDOf
(
stop
start
)
;
invariant
(
traverseUp
|
|
isAncestorIDOf
(
start
stop
)
'
traverseParentPath
(
%
s
%
s
.
.
.
)
:
Cannot
traverse
from
two
IDs
that
do
'
+
'
not
have
a
parent
path
.
'
start
stop
)
;
var
depth
=
0
;
var
traverse
=
traverseUp
?
getParentID
:
getNextDescendantID
;
for
(
var
id
=
start
;
;
id
=
traverse
(
id
stop
)
)
{
if
(
(
!
skipFirst
|
|
id
!
=
=
start
)
&
&
(
!
skipLast
|
|
id
!
=
=
stop
)
)
{
cb
(
id
traverseUp
arg
)
;
}
if
(
id
=
=
=
stop
)
{
break
;
}
invariant
(
depth
+
+
<
MAX_TREE_DEPTH
'
traverseParentPath
(
%
s
%
s
.
.
.
)
:
Detected
an
infinite
loop
while
'
+
'
traversing
the
React
DOM
ID
tree
.
This
may
be
due
to
malformed
IDs
:
%
s
'
start
stop
)
;
}
}
var
ReactInstanceHandles
=
{
separator
:
SEPARATOR
createReactRootID
:
function
(
)
{
return
getReactRootIDString
(
Math
.
ceil
(
Math
.
random
(
)
*
GLOBAL_MOUNT_POINT_MAX
)
)
;
}
isRenderedByReact
:
function
(
node
)
{
if
(
node
.
nodeType
!
=
=
1
)
{
return
false
;
}
var
id
=
ReactID
.
getID
(
node
)
;
return
id
?
id
.
charAt
(
0
)
=
=
=
SEPARATOR
:
false
;
}
getFirstReactDOM
:
function
(
node
)
{
var
current
=
node
;
while
(
current
&
&
current
.
parentNode
!
=
=
current
)
{
if
(
ReactInstanceHandles
.
isRenderedByReact
(
current
)
)
{
return
current
;
}
current
=
current
.
parentNode
;
}
return
null
;
}
findComponentRoot
:
function
(
ancestorNode
id
)
{
var
firstChildren
=
[
ancestorNode
.
firstChild
]
;
var
childIndex
=
0
;
while
(
childIndex
<
firstChildren
.
length
)
{
var
child
=
firstChildren
[
childIndex
+
+
]
;
while
(
child
)
{
var
childID
=
ReactID
.
getID
(
child
)
;
if
(
childID
)
{
if
(
id
=
=
=
childID
)
{
return
child
;
}
else
if
(
isAncestorIDOf
(
childID
id
)
)
{
firstChildren
.
length
=
childIndex
=
0
;
firstChildren
.
push
(
child
.
firstChild
)
;
break
;
}
else
{
firstChildren
.
push
(
child
.
firstChild
)
;
}
}
else
{
firstChildren
.
push
(
child
.
firstChild
)
;
}
child
=
child
.
nextSibling
;
}
}
if
(
true
)
{
console
.
error
(
'
Error
while
invoking
findComponentRoot
with
the
following
'
+
'
ancestor
node
:
'
ancestorNode
)
;
}
invariant
(
false
'
findComponentRoot
(
.
.
.
%
s
)
:
Unable
to
find
element
.
This
probably
'
+
'
means
the
DOM
was
unexpectedly
mutated
(
e
.
g
.
by
the
browser
)
.
'
id
ReactID
.
getID
(
ancestorNode
)
)
;
}
getReactRootIDFromNodeID
:
function
(
id
)
{
var
regexResult
=
/
\
.
r
\
[
[
^
\
]
]
+
\
]
/
.
exec
(
id
)
;
return
regexResult
&
&
regexResult
[
0
]
;
}
traverseEnterLeave
:
function
(
leaveID
enterID
cb
upArg
downArg
)
{
var
ancestorID
=
getFirstCommonAncestorID
(
leaveID
enterID
)
;
if
(
ancestorID
!
=
=
leaveID
)
{
traverseParentPath
(
leaveID
ancestorID
cb
upArg
false
true
)
;
}
if
(
ancestorID
!
=
=
enterID
)
{
traverseParentPath
(
ancestorID
enterID
cb
downArg
true
false
)
;
}
}
traverseTwoPhase
:
function
(
targetID
cb
arg
)
{
if
(
targetID
)
{
traverseParentPath
(
'
'
targetID
cb
arg
true
false
)
;
traverseParentPath
(
targetID
'
'
cb
arg
false
true
)
;
}
}
_getFirstCommonAncestorID
:
getFirstCommonAncestorID
_getNextDescendantID
:
getNextDescendantID
}
;
module
.
exports
=
ReactInstanceHandles
;
}
{
"
.
/
ReactID
"
:
35
"
.
/
invariant
"
:
75
}
]
38
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
ReactEventEmitter
=
require
(
"
.
/
ReactEventEmitter
"
)
;
var
ReactInstanceHandles
=
require
(
"
.
/
ReactInstanceHandles
"
)
;
var
ReactEventTopLevelCallback
=
require
(
"
.
/
ReactEventTopLevelCallback
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
=
require
(
"
.
/
"
)
;
var
instanceByReactRootID
=
{
}
;
var
containersByReactRootID
=
{
}
;
if
(
true
)
{
var
rootElementsByReactRootID
=
{
}
;
}
function
getReactRootElementInContainer
(
container
)
{
return
container
&
&
container
.
firstChild
;
}
function
getReactRootID
(
container
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
return
rootElement
&
&
ReactID
.
getID
(
rootElement
)
;
}
var
ReactMount
=
{
totalInstantiationTime
:
0
totalInjectionTime
:
0
useTouchEvents
:
false
scrollMonitor
:
function
(
container
renderCallback
)
{
renderCallback
(
)
;
}
prepareTopLevelEvents
:
function
(
TopLevelCallbackCreator
)
{
ReactEventEmitter
.
ensureListening
(
ReactMount
.
useTouchEvents
TopLevelCallbackCreator
)
;
}
_updateRootComponent
:
function
(
prevComponent
nextComponent
container
callback
)
{
var
nextProps
=
nextComponent
.
props
;
ReactMount
.
scrollMonitor
(
container
function
(
)
{
prevComponent
.
replaceProps
(
nextProps
callback
)
;
}
)
;
if
(
true
)
{
rootElementsByReactRootID
[
getReactRootID
(
container
)
]
=
getReactRootElementInContainer
(
container
)
;
}
return
prevComponent
;
}
_registerComponent
:
function
(
nextComponent
container
)
{
ReactMount
.
prepareTopLevelEvents
(
ReactEventTopLevelCallback
)
;
var
reactRootID
=
ReactMount
.
registerContainer
(
container
)
;
instanceByReactRootID
[
reactRootID
]
=
nextComponent
;
return
reactRootID
;
}
_renderNewRootComponent
:
function
(
nextComponent
container
shouldReuseMarkup
)
{
var
reactRootID
=
ReactMount
.
_registerComponent
(
nextComponent
container
)
;
nextComponent
.
mountComponentIntoNode
(
reactRootID
container
shouldReuseMarkup
)
;
if
(
true
)
{
rootElementsByReactRootID
[
reactRootID
]
=
getReactRootElementInContainer
(
container
)
;
}
return
nextComponent
;
}
renderComponent
:
function
(
nextComponent
container
callback
)
{
var
registeredComponent
=
instanceByReactRootID
[
getReactRootID
(
container
)
]
;
if
(
registeredComponent
)
{
if
(
registeredComponent
.
constructor
=
=
=
nextComponent
.
constructor
)
{
return
ReactMount
.
_updateRootComponent
(
registeredComponent
nextComponent
container
callback
)
;
}
else
{
ReactMount
.
unmountAndReleaseReactRootNode
(
container
)
;
}
}
var
reactRootElement
=
getReactRootElementInContainer
(
container
)
;
var
containerHasReactMarkup
=
reactRootElement
&
&
ReactInstanceHandles
.
isRenderedByReact
(
reactRootElement
)
;
var
shouldReuseMarkup
=
containerHasReactMarkup
&
&
!
registeredComponent
;
var
component
=
ReactMount
.
_renderNewRootComponent
(
nextComponent
container
shouldReuseMarkup
)
;
callback
&
&
callback
(
)
;
return
component
;
}
constructAndRenderComponent
:
function
(
constructor
props
container
)
{
return
ReactMount
.
renderComponent
(
constructor
(
props
)
container
)
;
}
constructAndRenderComponentByID
:
function
(
constructor
props
id
)
{
return
ReactMount
.
constructAndRenderComponent
(
constructor
props
(
id
)
)
;
}
registerContainer
:
function
(
container
)
{
var
reactRootID
=
getReactRootID
(
container
)
;
if
(
reactRootID
)
{
reactRootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
reactRootID
)
;
}
if
(
!
reactRootID
)
{
reactRootID
=
ReactInstanceHandles
.
createReactRootID
(
)
;
}
containersByReactRootID
[
reactRootID
]
=
container
;
return
reactRootID
;
}
unmountAndReleaseReactRootNode
:
function
(
container
)
{
var
reactRootID
=
getReactRootID
(
container
)
;
var
component
=
instanceByReactRootID
[
reactRootID
]
;
if
(
!
component
)
{
return
false
;
}
component
.
unmountComponentFromNode
(
container
)
;
delete
instanceByReactRootID
[
reactRootID
]
;
delete
containersByReactRootID
[
reactRootID
]
;
if
(
true
)
{
delete
rootElementsByReactRootID
[
reactRootID
]
;
}
return
true
;
}
findReactContainerForID
:
function
(
id
)
{
var
reactRootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
id
)
;
var
container
=
containersByReactRootID
[
reactRootID
]
;
if
(
true
)
{
var
rootElement
=
rootElementsByReactRootID
[
reactRootID
]
;
if
(
rootElement
&
&
rootElement
.
parentNode
!
=
=
container
)
{
invariant
(
ReactID
.
rawGetID
(
rootElement
)
=
=
=
reactRootID
'
ReactMount
:
Root
element
ID
differed
from
reactRootID
.
'
)
;
var
containerChild
=
container
.
firstChild
;
if
(
containerChild
&
&
reactRootID
=
=
=
ReactID
.
rawGetID
(
containerChild
)
)
{
rootElementsByReactRootID
[
reactRootID
]
=
containerChild
;
}
else
{
console
.
warn
(
'
ReactMount
:
Root
element
has
been
removed
from
its
original
'
+
'
container
.
New
container
:
'
rootElement
.
parentNode
)
;
}
}
}
return
container
;
}
findReactNodeByID
:
function
(
id
)
{
var
reactRoot
=
ReactMount
.
findReactContainerForID
(
id
)
;
return
ReactInstanceHandles
.
findComponentRoot
(
reactRoot
id
)
;
}
}
;
module
.
exports
=
ReactMount
;
}
)
(
)
}
{
"
.
/
"
:
1
"
.
/
ReactEventEmitter
"
:
33
"
.
/
ReactEventTopLevelCallback
"
:
34
"
.
/
ReactID
"
:
35
"
.
/
ReactInstanceHandles
"
:
37
"
.
/
invariant
"
:
75
}
]
39
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
ReactComponent
=
require
(
"
.
/
ReactComponent
"
)
;
function
shouldManageExisting
(
curChild
newChild
)
{
return
curChild
&
&
newChild
&
&
curChild
.
constructor
=
=
=
newChild
.
constructor
;
}
var
ReactMultiChildMixin
=
{
enqueueMarkupAt
:
function
(
markup
insertAt
)
{
this
.
domOperations
=
this
.
domOperations
|
|
[
]
;
this
.
domOperations
.
push
(
{
insertMarkup
:
markup
finalIndex
:
insertAt
}
)
;
}
enqueueMove
:
function
(
originalIndex
finalIndex
)
{
this
.
domOperations
=
this
.
domOperations
|
|
[
]
;
this
.
domOperations
.
push
(
{
moveFrom
:
originalIndex
finalIndex
:
finalIndex
}
)
;
}
enqueueUnmountChildByName
:
function
(
name
removeChild
)
{
if
(
ReactComponent
.
isValidComponent
(
removeChild
)
)
{
this
.
domOperations
=
this
.
domOperations
|
|
[
]
;
this
.
domOperations
.
push
(
{
removeAt
:
removeChild
.
_domIndex
}
)
;
removeChild
.
unmountComponent
&
&
removeChild
.
unmountComponent
(
)
;
delete
this
.
_renderedChildren
[
name
]
;
}
}
processChildDOMOperationsQueue
:
function
(
)
{
if
(
this
.
domOperations
)
{
ReactComponent
.
DOMIDOperations
.
manageChildrenByParentID
(
this
.
_rootNodeID
this
.
domOperations
)
;
this
.
domOperations
=
null
;
}
}
unmountMultiChild
:
function
(
)
{
var
renderedChildren
=
this
.
_renderedChildren
;
for
(
var
name
in
renderedChildren
)
{
if
(
renderedChildren
.
hasOwnProperty
(
name
)
&
&
renderedChildren
[
name
]
)
{
var
renderedChild
=
renderedChildren
[
name
]
;
renderedChild
.
unmountComponent
&
&
renderedChild
.
unmountComponent
(
)
;
}
}
this
.
_renderedChildren
=
null
;
}
mountMultiChild
:
function
(
children
transaction
)
{
var
accum
=
'
'
;
var
index
=
0
;
for
(
var
name
in
children
)
{
var
child
=
children
[
name
]
;
if
(
children
.
hasOwnProperty
(
name
)
&
&
child
)
{
accum
+
=
child
.
mountComponent
(
this
.
_rootNodeID
+
'
.
'
+
name
transaction
)
;
child
.
_domIndex
=
index
;
index
+
+
;
}
}
this
.
_renderedChildren
=
children
;
this
.
domOperations
=
null
;
return
accum
;
}
updateMultiChild
:
function
(
nextChildren
transaction
)
{
if
(
!
nextChildren
&
&
!
this
.
_renderedChildren
)
{
return
;
}
else
if
(
nextChildren
&
&
!
this
.
_renderedChildren
)
{
this
.
_renderedChildren
=
{
}
;
}
else
if
(
!
nextChildren
&
&
this
.
_renderedChildren
)
{
nextChildren
=
{
}
;
}
var
rootDomIdDot
=
this
.
_rootNodeID
+
'
.
'
;
var
markupBuffer
=
null
;
var
numPendingInsert
=
0
;
var
loopDomIndex
=
0
;
var
curChildrenDOMIndex
=
0
;
for
(
var
name
in
nextChildren
)
{
if
(
!
nextChildren
.
hasOwnProperty
(
name
)
)
{
continue
;
}
var
curChild
=
this
.
_renderedChildren
[
name
]
;
var
nextChild
=
nextChildren
[
name
]
;
if
(
shouldManageExisting
(
curChild
nextChild
)
)
{
if
(
markupBuffer
)
{
this
.
enqueueMarkupAt
(
markupBuffer
loopDomIndex
-
numPendingInsert
)
;
markupBuffer
=
null
;
}
numPendingInsert
=
0
;
if
(
curChild
.
_domIndex
<
curChildrenDOMIndex
)
{
this
.
enqueueMove
(
curChild
.
_domIndex
loopDomIndex
)
;
}
curChildrenDOMIndex
=
Math
.
max
(
curChild
.
_domIndex
curChildrenDOMIndex
)
;
curChild
.
receiveProps
(
nextChild
.
props
transaction
)
;
curChild
.
_domIndex
=
loopDomIndex
;
}
else
{
if
(
curChild
)
{
this
.
enqueueUnmountChildByName
(
name
curChild
)
;
curChildrenDOMIndex
=
Math
.
max
(
curChild
.
_domIndex
curChildrenDOMIndex
)
;
}
if
(
nextChild
)
{
this
.
_renderedChildren
[
name
]
=
nextChild
;
var
nextMarkup
=
nextChild
.
mountComponent
(
rootDomIdDot
+
name
transaction
)
;
markupBuffer
=
markupBuffer
?
markupBuffer
+
nextMarkup
:
nextMarkup
;
numPendingInsert
+
+
;
nextChild
.
_domIndex
=
loopDomIndex
;
}
}
loopDomIndex
=
nextChild
?
loopDomIndex
+
1
:
loopDomIndex
;
}
if
(
markupBuffer
)
{
this
.
enqueueMarkupAt
(
markupBuffer
loopDomIndex
-
numPendingInsert
)
;
}
for
(
var
childName
in
this
.
_renderedChildren
)
{
if
(
!
this
.
_renderedChildren
.
hasOwnProperty
(
childName
)
)
{
continue
;
}
var
child
=
this
.
_renderedChildren
[
childName
]
;
if
(
child
&
&
!
nextChildren
[
childName
]
)
{
this
.
enqueueUnmountChildByName
(
childName
child
)
;
}
}
this
.
processChildDOMOperationsQueue
(
)
;
}
}
;
var
ReactMultiChild
=
{
Mixin
:
ReactMultiChildMixin
}
;
module
.
exports
=
ReactMultiChild
;
}
)
(
)
}
{
"
.
/
ReactComponent
"
:
22
}
]
40
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
CSSPropertyOperations
=
require
(
"
.
/
CSSPropertyOperations
"
)
;
var
DOMProperty
=
require
(
"
.
/
DOMProperty
"
)
;
var
DOMPropertyOperations
=
require
(
"
.
/
DOMPropertyOperations
"
)
;
var
ReactComponent
=
require
(
"
.
/
ReactComponent
"
)
;
var
ReactEventEmitter
=
require
(
"
.
/
ReactEventEmitter
"
)
;
var
ReactMultiChild
=
require
(
"
.
/
ReactMultiChild
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
escapeTextForBrowser
=
require
(
"
.
/
escapeTextForBrowser
"
)
;
var
flattenChildren
=
require
(
"
.
/
flattenChildren
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
keyOf
=
require
(
"
.
/
keyOf
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
mixInto
=
require
(
"
.
/
mixInto
"
)
;
var
putListener
=
ReactEventEmitter
.
putListener
;
var
deleteListener
=
ReactEventEmitter
.
deleteListener
;
var
registrationNames
=
ReactEventEmitter
.
registrationNames
;
var
CONTENT_TYPES
=
{
'
string
'
:
true
'
number
'
:
true
}
;
var
DANGEROUSLY_SET_INNER_HTML
=
keyOf
(
{
dangerouslySetInnerHTML
:
null
}
)
;
var
STYLE
=
keyOf
(
{
style
:
null
}
)
;
function
assertValidProps
(
props
)
{
if
(
!
props
)
{
return
;
}
invariant
(
props
.
children
=
=
null
|
|
props
.
dangerouslySetInnerHTML
=
=
null
'
Can
only
set
one
of
children
or
props
.
dangerouslySetInnerHTML
.
'
)
;
invariant
(
props
.
style
=
=
null
|
|
typeof
props
.
style
=
=
=
'
object
'
'
The
style
prop
expects
a
mapping
from
style
properties
to
values
'
+
'
not
a
string
.
'
)
;
}
function
ReactNativeComponent
(
tag
omitClose
)
{
this
.
_tagOpen
=
'
<
'
+
tag
;
this
.
_tagClose
=
omitClose
?
'
'
:
'
<
/
'
+
tag
+
'
>
'
;
this
.
tagName
=
tag
.
toUpperCase
(
)
;
}
ReactNativeComponent
.
Mixin
=
{
mountComponent
:
function
(
rootID
transaction
)
{
ReactComponent
.
Mixin
.
mountComponent
.
call
(
this
rootID
transaction
)
;
assertValidProps
(
this
.
props
)
;
return
(
this
.
_createOpenTagMarkup
(
)
+
this
.
_createContentMarkup
(
transaction
)
+
this
.
_tagClose
)
;
}
_createOpenTagMarkup
:
function
(
)
{
var
props
=
this
.
props
;
var
ret
=
this
.
_tagOpen
;
for
(
var
propKey
in
props
)
{
if
(
!
props
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
propValue
=
props
[
propKey
]
;
if
(
propValue
=
=
null
)
{
continue
;
}
if
(
registrationNames
[
propKey
]
)
{
putListener
(
this
.
_rootNodeID
propKey
propValue
)
;
}
else
{
if
(
propKey
=
=
=
STYLE
)
{
if
(
propValue
)
{
propValue
=
props
.
style
=
merge
(
props
.
style
)
;
}
propValue
=
CSSPropertyOperations
.
createMarkupForStyles
(
propValue
)
;
}
var
markup
=
DOMPropertyOperations
.
createMarkupForProperty
(
propKey
propValue
)
;
if
(
markup
)
{
ret
+
=
'
'
+
markup
;
}
}
}
var
escapedID
=
escapeTextForBrowser
(
this
.
_rootNodeID
)
;
return
ret
+
'
'
+
ReactID
.
ATTR_NAME
+
'
=
"
'
+
escapedID
+
'
"
>
'
;
}
_createContentMarkup
:
function
(
transaction
)
{
var
innerHTML
=
this
.
props
.
dangerouslySetInnerHTML
;
if
(
innerHTML
!
=
null
)
{
if
(
innerHTML
.
__html
!
=
null
)
{
return
innerHTML
.
__html
;
}
}
else
{
var
contentToUse
=
CONTENT_TYPES
[
typeof
this
.
props
.
children
]
?
this
.
props
.
children
:
null
;
var
childrenToUse
=
contentToUse
!
=
null
?
null
:
this
.
props
.
children
;
if
(
contentToUse
!
=
null
)
{
return
escapeTextForBrowser
(
contentToUse
)
;
}
else
if
(
childrenToUse
!
=
null
)
{
return
this
.
mountMultiChild
(
flattenChildren
(
childrenToUse
)
transaction
)
;
}
}
return
'
'
;
}
receiveProps
:
function
(
nextProps
transaction
)
{
assertValidProps
(
nextProps
)
;
ReactComponent
.
Mixin
.
receiveProps
.
call
(
this
nextProps
transaction
)
;
}
updateComponent
:
function
(
transaction
prevProps
)
{
ReactComponent
.
Mixin
.
updateComponent
.
call
(
this
transaction
prevProps
)
;
this
.
_updateDOMProperties
(
prevProps
)
;
this
.
_updateDOMChildren
(
prevProps
transaction
)
;
}
_updateDOMProperties
:
function
(
lastProps
)
{
var
nextProps
=
this
.
props
;
var
propKey
;
var
styleName
;
var
styleUpdates
;
for
(
propKey
in
lastProps
)
{
if
(
nextProps
.
hasOwnProperty
(
propKey
)
|
|
!
lastProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
var
lastStyle
=
lastProps
[
propKey
]
;
for
(
styleName
in
lastStyle
)
{
if
(
lastStyle
.
hasOwnProperty
(
styleName
)
)
{
styleUpdates
=
styleUpdates
|
|
{
}
;
styleUpdates
[
styleName
]
=
'
'
;
}
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
ReactComponent
.
DOMIDOperations
.
updateTextContentByID
(
this
.
_rootNodeID
'
'
)
;
}
else
if
(
registrationNames
[
propKey
]
)
{
deleteListener
(
this
.
_rootNodeID
propKey
)
;
}
else
{
ReactComponent
.
DOMIDOperations
.
deletePropertyByID
(
this
.
_rootNodeID
propKey
)
;
}
}
for
(
propKey
in
nextProps
)
{
var
nextProp
=
nextProps
[
propKey
]
;
var
lastProp
=
lastProps
[
propKey
]
;
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
|
|
nextProp
=
=
=
lastProp
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
if
(
nextProp
)
{
nextProp
=
nextProps
.
style
=
merge
(
nextProp
)
;
}
if
(
lastProp
)
{
for
(
styleName
in
lastProp
)
{
if
(
lastProp
.
hasOwnProperty
(
styleName
)
&
&
!
nextProp
.
hasOwnProperty
(
styleName
)
)
{
styleUpdates
=
styleUpdates
|
|
{
}
;
styleUpdates
[
styleName
]
=
'
'
;
}
}
for
(
styleName
in
nextProp
)
{
if
(
nextProp
.
hasOwnProperty
(
styleName
)
&
&
lastProp
[
styleName
]
!
=
=
nextProp
[
styleName
]
)
{
styleUpdates
=
styleUpdates
|
|
{
}
;
styleUpdates
[
styleName
]
=
nextProp
[
styleName
]
;
}
}
}
else
{
styleUpdates
=
nextProp
;
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
lastHtml
=
lastProp
&
&
lastProp
.
__html
;
var
nextHtml
=
nextProp
&
&
nextProp
.
__html
;
if
(
lastHtml
!
=
=
nextHtml
)
{
ReactComponent
.
DOMIDOperations
.
updateInnerHTMLByID
(
this
.
_rootNodeID
nextProp
)
;
}
}
else
if
(
registrationNames
[
propKey
]
)
{
putListener
(
this
.
_rootNodeID
propKey
nextProp
)
;
}
else
if
(
DOMProperty
.
isStandardName
[
propKey
]
|
|
DOMProperty
.
isCustomAttribute
(
propKey
)
)
{
ReactComponent
.
DOMIDOperations
.
updatePropertyByID
(
this
.
_rootNodeID
propKey
nextProp
)
;
}
}
if
(
styleUpdates
)
{
ReactComponent
.
DOMIDOperations
.
updateStylesByID
(
this
.
_rootNodeID
styleUpdates
)
;
}
}
_updateDOMChildren
:
function
(
lastProps
transaction
)
{
var
nextProps
=
this
.
props
;
var
lastUsedContent
=
CONTENT_TYPES
[
typeof
lastProps
.
children
]
?
lastProps
.
children
:
null
;
var
contentToUse
=
CONTENT_TYPES
[
typeof
nextProps
.
children
]
?
nextProps
.
children
:
null
;
var
lastUsedChildren
=
lastUsedContent
!
=
null
?
null
:
lastProps
.
children
;
var
childrenToUse
=
contentToUse
!
=
null
?
null
:
nextProps
.
children
;
if
(
contentToUse
!
=
null
)
{
var
childrenRemoved
=
lastUsedChildren
!
=
null
&
&
childrenToUse
=
=
null
;
if
(
childrenRemoved
)
{
this
.
updateMultiChild
(
null
transaction
)
;
}
if
(
lastUsedContent
!
=
=
contentToUse
)
{
ReactComponent
.
DOMIDOperations
.
updateTextContentByID
(
this
.
_rootNodeID
'
'
+
contentToUse
)
;
}
}
else
{
var
contentRemoved
=
lastUsedContent
!
=
null
&
&
contentToUse
=
=
null
;
if
(
contentRemoved
)
{
ReactComponent
.
DOMIDOperations
.
updateTextContentByID
(
this
.
_rootNodeID
'
'
)
;
}
this
.
updateMultiChild
(
flattenChildren
(
nextProps
.
children
)
transaction
)
;
}
}
unmountComponent
:
function
(
)
{
ReactEventEmitter
.
deleteAllListeners
(
this
.
_rootNodeID
)
;
ReactComponent
.
Mixin
.
unmountComponent
.
call
(
this
)
;
this
.
unmountMultiChild
(
)
;
}
}
;
mixInto
(
ReactNativeComponent
ReactComponent
.
Mixin
)
;
mixInto
(
ReactNativeComponent
ReactNativeComponent
.
Mixin
)
;
mixInto
(
ReactNativeComponent
ReactMultiChild
.
Mixin
)
;
module
.
exports
=
ReactNativeComponent
;
}
{
"
.
/
CSSPropertyOperations
"
:
3
"
.
/
DOMProperty
"
:
7
"
.
/
DOMPropertyOperations
"
:
8
"
.
/
ReactComponent
"
:
22
"
.
/
ReactEventEmitter
"
:
33
"
.
/
ReactID
"
:
35
"
.
/
ReactMultiChild
"
:
39
"
.
/
escapeTextForBrowser
"
:
65
"
.
/
flattenChildren
"
:
67
"
.
/
invariant
"
:
75
"
.
/
keyOf
"
:
79
"
.
/
merge
"
:
81
"
.
/
mixInto
"
:
84
}
]
41
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
PooledClass
=
require
(
"
.
/
PooledClass
"
)
;
var
mixInto
=
require
(
"
.
/
mixInto
"
)
;
function
ReactOnDOMReady
(
initialCollection
)
{
this
.
_queue
=
initialCollection
|
|
null
;
}
mixInto
(
ReactOnDOMReady
{
enqueue
:
function
(
component
callback
)
{
this
.
_queue
=
this
.
_queue
|
|
[
]
;
this
.
_queue
.
push
(
{
component
:
component
callback
:
callback
}
)
;
}
notifyAll
:
function
(
)
{
var
queue
=
this
.
_queue
;
if
(
queue
)
{
this
.
_queue
=
null
;
for
(
var
i
=
0
l
=
queue
.
length
;
i
<
l
;
i
+
+
)
{
var
component
=
queue
[
i
]
.
component
;
var
callback
=
queue
[
i
]
.
callback
;
callback
.
call
(
component
component
.
getDOMNode
(
)
)
;
}
queue
.
length
=
0
;
}
}
reset
:
function
(
)
{
this
.
_queue
=
null
;
}
destructor
:
function
(
)
{
this
.
reset
(
)
;
}
}
)
;
PooledClass
.
addPoolingTo
(
ReactOnDOMReady
)
;
module
.
exports
=
ReactOnDOMReady
;
}
{
"
.
/
PooledClass
"
:
20
"
.
/
mixInto
"
:
84
}
]
42
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
ReactOwner
=
{
isValidOwner
:
function
(
object
)
{
return
!
!
(
object
&
&
typeof
object
.
attachRef
=
=
=
'
function
'
&
&
typeof
object
.
detachRef
=
=
=
'
function
'
)
;
}
addComponentAsRefTo
:
function
(
component
ref
owner
)
{
invariant
(
ReactOwner
.
isValidOwner
(
owner
)
'
addComponentAsRefTo
(
.
.
.
)
:
Only
a
ReactOwner
can
have
refs
.
'
)
;
owner
.
attachRef
(
ref
component
)
;
}
removeComponentAsRefFrom
:
function
(
component
ref
owner
)
{
invariant
(
ReactOwner
.
isValidOwner
(
owner
)
'
removeComponentAsRefFrom
(
.
.
.
)
:
Only
a
ReactOwner
can
have
refs
.
'
)
;
if
(
owner
.
refs
[
ref
]
=
=
=
component
)
{
owner
.
detachRef
(
ref
)
;
}
}
Mixin
:
{
attachRef
:
function
(
ref
component
)
{
invariant
(
component
.
isOwnedBy
(
this
)
'
attachRef
(
%
s
.
.
.
)
:
Only
a
component
\
'
s
owner
can
store
a
ref
to
it
.
'
ref
)
;
var
refs
=
this
.
refs
|
|
(
this
.
refs
=
{
}
)
;
refs
[
ref
]
=
component
;
}
detachRef
:
function
(
ref
)
{
delete
this
.
refs
[
ref
]
;
}
}
}
;
module
.
exports
=
ReactOwner
;
}
{
"
.
/
invariant
"
:
75
}
]
43
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
emptyFunction
=
require
(
"
.
/
emptyFunction
"
)
;
var
joinClasses
=
require
(
"
.
/
joinClasses
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
function
createTransferStrategy
(
mergeStrategy
)
{
return
function
(
props
key
value
)
{
if
(
!
props
.
hasOwnProperty
(
key
)
)
{
props
[
key
]
=
value
;
}
else
{
props
[
key
]
=
mergeStrategy
(
props
[
key
]
value
)
;
}
}
;
}
var
TransferStrategies
=
{
children
:
emptyFunction
className
:
createTransferStrategy
(
joinClasses
)
ref
:
emptyFunction
style
:
createTransferStrategy
(
merge
)
}
;
var
ReactPropTransferer
=
{
TransferStrategies
:
TransferStrategies
Mixin
:
{
transferPropsTo
:
function
(
component
)
{
var
props
=
{
}
;
for
(
var
thatKey
in
component
.
props
)
{
if
(
component
.
props
.
hasOwnProperty
(
thatKey
)
)
{
props
[
thatKey
]
=
component
.
props
[
thatKey
]
;
}
}
for
(
var
thisKey
in
this
.
props
)
{
if
(
!
this
.
props
.
hasOwnProperty
(
thisKey
)
)
{
continue
;
}
var
transferStrategy
=
TransferStrategies
[
thisKey
]
;
if
(
transferStrategy
)
{
transferStrategy
(
props
thisKey
this
.
props
[
thisKey
]
)
;
}
else
if
(
!
props
.
hasOwnProperty
(
thisKey
)
)
{
props
[
thisKey
]
=
this
.
props
[
thisKey
]
;
}
}
component
.
props
=
props
;
return
component
;
}
}
}
;
module
.
exports
=
ReactPropTransferer
;
}
{
"
.
/
emptyFunction
"
:
64
"
.
/
joinClasses
"
:
77
"
.
/
merge
"
:
81
}
]
44
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
createObjectFrom
=
require
(
"
.
/
createObjectFrom
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
Props
=
{
array
:
createPrimitiveTypeChecker
(
'
array
'
)
bool
:
createPrimitiveTypeChecker
(
'
boolean
'
)
func
:
createPrimitiveTypeChecker
(
'
function
'
)
number
:
createPrimitiveTypeChecker
(
'
number
'
)
object
:
createPrimitiveTypeChecker
(
'
object
'
)
string
:
createPrimitiveTypeChecker
(
'
string
'
)
oneOf
:
createEnumTypeChecker
instanceOf
:
createInstanceTypeChecker
}
;
var
ANONYMOUS
=
'
<
<
anonymous
>
>
'
;
function
createPrimitiveTypeChecker
(
expectedType
)
{
function
validatePrimitiveType
(
propValue
propName
componentName
)
{
var
propType
=
typeof
propValue
;
if
(
propType
=
=
=
'
object
'
&
&
Array
.
isArray
(
propValue
)
)
{
propType
=
'
array
'
;
}
invariant
(
propType
=
=
=
expectedType
'
Invalid
prop
%
s
of
type
%
s
supplied
to
%
s
expected
%
s
.
'
propName
propType
componentName
expectedType
)
;
}
return
createChainableTypeChecker
(
validatePrimitiveType
)
;
}
function
createEnumTypeChecker
(
expectedValues
)
{
var
expectedEnum
=
createObjectFrom
(
expectedValues
)
;
function
validateEnumType
(
propValue
propName
componentName
)
{
invariant
(
expectedEnum
[
propValue
]
'
Invalid
prop
%
s
supplied
to
%
s
expected
one
of
%
s
.
'
propName
componentName
JSON
.
stringify
(
Object
.
keys
(
expectedEnum
)
)
)
;
}
return
createChainableTypeChecker
(
validateEnumType
)
;
}
function
createInstanceTypeChecker
(
expectedClass
)
{
function
validateInstanceType
(
propValue
propName
componentName
)
{
invariant
(
propValue
instanceof
expectedClass
'
Invalid
prop
%
s
supplied
to
%
s
expected
instance
of
%
s
.
'
propName
componentName
expectedClass
.
name
|
|
ANONYMOUS
)
;
}
return
createChainableTypeChecker
(
validateInstanceType
)
;
}
function
createChainableTypeChecker
(
validate
)
{
function
createTypeChecker
(
isRequired
)
{
function
checkType
(
props
propName
componentName
)
{
var
propValue
=
props
[
propName
]
;
if
(
propValue
!
=
null
)
{
validate
(
propValue
propName
componentName
|
|
ANONYMOUS
)
;
}
else
{
invariant
(
!
isRequired
'
Required
prop
%
s
was
not
specified
in
%
s
.
'
propName
componentName
|
|
ANONYMOUS
)
;
}
}
if
(
!
isRequired
)
{
checkType
.
isRequired
=
createTypeChecker
(
true
)
;
}
return
checkType
;
}
return
createTypeChecker
(
false
)
;
}
module
.
exports
=
Props
;
}
{
"
.
/
createObjectFrom
"
:
62
"
.
/
invariant
"
:
75
}
]
45
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
PooledClass
=
require
(
"
.
/
PooledClass
"
)
;
var
ReactEventEmitter
=
require
(
"
.
/
ReactEventEmitter
"
)
;
var
ReactInputSelection
=
require
(
"
.
/
ReactInputSelection
"
)
;
var
ReactOnDOMReady
=
require
(
"
.
/
ReactOnDOMReady
"
)
;
var
Transaction
=
require
(
"
.
/
Transaction
"
)
;
var
mixInto
=
require
(
"
.
/
mixInto
"
)
;
var
SELECTION_RESTORATION
=
{
initialize
:
ReactInputSelection
.
getSelectionInformation
close
:
ReactInputSelection
.
restoreSelection
}
;
var
EVENT_SUPPRESSION
=
{
initialize
:
function
(
)
{
var
currentlyEnabled
=
ReactEventEmitter
.
isEnabled
(
)
;
ReactEventEmitter
.
setEnabled
(
false
)
;
return
currentlyEnabled
;
}
close
:
function
(
previouslyEnabled
)
{
ReactEventEmitter
.
setEnabled
(
previouslyEnabled
)
;
}
}
;
var
ON_DOM_READY_QUEUEING
=
{
initialize
:
function
(
)
{
this
.
reactOnDOMReady
.
reset
(
)
;
}
close
:
function
(
)
{
this
.
reactOnDOMReady
.
notifyAll
(
)
;
}
}
;
var
TRANSACTION_WRAPPERS
=
[
SELECTION_RESTORATION
EVENT_SUPPRESSION
ON_DOM_READY_QUEUEING
]
;
function
ReactReconcileTransaction
(
)
{
this
.
reinitializeTransaction
(
)
;
this
.
reactOnDOMReady
=
ReactOnDOMReady
.
getPooled
(
null
)
;
}
var
Mixin
=
{
getTransactionWrappers
:
function
(
)
{
if
(
ExecutionEnvironment
.
canUseDOM
)
{
return
TRANSACTION_WRAPPERS
;
}
else
{
return
[
]
;
}
}
getReactOnDOMReady
:
function
(
)
{
return
this
.
reactOnDOMReady
;
}
destructor
:
function
(
)
{
ReactOnDOMReady
.
release
(
this
.
reactOnDOMReady
)
;
this
.
reactOnDOMReady
=
null
;
}
}
;
mixInto
(
ReactReconcileTransaction
Transaction
.
Mixin
)
;
mixInto
(
ReactReconcileTransaction
Mixin
)
;
PooledClass
.
addPoolingTo
(
ReactReconcileTransaction
)
;
module
.
exports
=
ReactReconcileTransaction
;
}
{
"
.
/
ExecutionEnvironment
"
:
19
"
.
/
PooledClass
"
:
20
"
.
/
ReactEventEmitter
"
:
33
"
.
/
ReactInputSelection
"
:
36
"
.
/
ReactOnDOMReady
"
:
41
"
.
/
Transaction
"
:
58
"
.
/
mixInto
"
:
84
}
]
46
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactReconcileTransaction
=
require
(
"
.
/
ReactReconcileTransaction
"
)
;
var
ReactInstanceHandles
=
require
(
"
.
/
ReactInstanceHandles
"
)
;
function
renderComponentToString
(
component
callback
)
{
var
id
=
ReactInstanceHandles
.
createReactRootID
(
)
;
var
transaction
=
ReactReconcileTransaction
.
getPooled
(
)
;
transaction
.
reinitializeTransaction
(
)
;
try
{
transaction
.
perform
(
function
(
)
{
callback
(
component
.
mountComponent
(
id
transaction
)
)
;
}
null
)
;
}
finally
{
ReactReconcileTransaction
.
release
(
transaction
)
;
}
}
module
.
exports
=
{
renderComponentToString
:
renderComponentToString
}
;
}
{
"
.
/
ReactInstanceHandles
"
:
37
"
.
/
ReactReconcileTransaction
"
:
45
}
]
47
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ReactComponent
=
require
(
"
.
/
ReactComponent
"
)
;
var
ReactID
=
require
(
"
.
/
ReactID
"
)
;
var
escapeTextForBrowser
=
require
(
"
.
/
escapeTextForBrowser
"
)
;
var
mixInto
=
require
(
"
.
/
mixInto
"
)
;
var
ReactTextComponent
=
function
(
initialText
)
{
this
.
construct
(
{
text
:
initialText
}
)
;
}
;
mixInto
(
ReactTextComponent
ReactComponent
.
Mixin
)
;
mixInto
(
ReactTextComponent
{
mountComponent
:
function
(
rootID
)
{
ReactComponent
.
Mixin
.
mountComponent
.
call
(
this
rootID
)
;
return
(
'
<
span
'
+
ReactID
.
ATTR_NAME
+
'
=
"
'
+
rootID
+
'
"
>
'
+
escapeTextForBrowser
(
this
.
props
.
text
)
+
'
<
/
span
>
'
)
;
}
receiveProps
:
function
(
nextProps
transaction
)
{
if
(
nextProps
.
text
!
=
=
this
.
props
.
text
)
{
this
.
props
.
text
=
nextProps
.
text
;
ReactComponent
.
DOMIDOperations
.
updateTextContentByID
(
this
.
_rootNodeID
nextProps
.
text
)
;
}
}
}
)
;
module
.
exports
=
ReactTextComponent
;
}
{
"
.
/
ReactComponent
"
:
22
"
.
/
ReactID
"
:
35
"
.
/
escapeTextForBrowser
"
:
65
"
.
/
mixInto
"
:
84
}
]
48
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
isBatchingUpdates
=
false
;
var
dirtyComponents
=
[
]
;
function
batchedUpdates
(
callback
)
{
if
(
isBatchingUpdates
)
{
callback
(
)
;
return
;
}
isBatchingUpdates
=
true
;
try
{
callback
(
)
;
for
(
var
i
=
0
;
i
<
dirtyComponents
.
length
;
i
+
+
)
{
var
component
=
dirtyComponents
[
i
]
;
if
(
component
.
isMounted
(
)
)
{
var
callbacks
=
component
.
_pendingCallbacks
;
component
.
_pendingCallbacks
=
null
;
component
.
performUpdateIfNecessary
(
)
;
if
(
callbacks
)
{
for
(
var
j
=
0
;
j
<
callbacks
.
length
;
j
+
+
)
{
callbacks
[
j
]
(
)
;
}
}
}
}
}
catch
(
error
)
{
throw
error
;
}
finally
{
dirtyComponents
.
length
=
0
;
isBatchingUpdates
=
false
;
}
}
function
enqueueUpdate
(
component
callback
)
{
invariant
(
!
callback
|
|
typeof
callback
=
=
=
"
function
"
'
enqueueUpdate
(
.
.
.
)
:
You
called
setProps
replaceProps
'
+
'
setState
replaceState
or
forceUpdate
with
a
callback
that
'
+
'
isn
\
'
t
callable
.
'
)
;
if
(
!
isBatchingUpdates
)
{
component
.
performUpdateIfNecessary
(
)
;
callback
&
&
callback
(
)
;
return
;
}
dirtyComponents
.
push
(
component
)
;
if
(
callback
)
{
if
(
component
.
_pendingCallbacks
)
{
component
.
_pendingCallbacks
.
push
(
callback
)
;
}
else
{
component
.
_pendingCallbacks
=
[
callback
]
;
}
}
}
var
ReactUpdates
=
{
batchedUpdates
:
batchedUpdates
enqueueUpdate
:
enqueueUpdate
}
;
module
.
exports
=
ReactUpdates
;
}
{
"
.
/
invariant
"
:
75
}
]
49
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
EventConstants
=
require
(
"
.
/
EventConstants
"
)
;
var
EventPropagators
=
require
(
"
.
/
EventPropagators
"
)
;
var
SyntheticEvent
=
require
(
"
.
/
SyntheticEvent
"
)
;
var
SyntheticFocusEvent
=
require
(
"
.
/
SyntheticFocusEvent
"
)
;
var
SyntheticKeyboardEvent
=
require
(
"
.
/
SyntheticKeyboardEvent
"
)
;
var
SyntheticMouseEvent
=
require
(
"
.
/
SyntheticMouseEvent
"
)
;
var
SyntheticMutationEvent
=
require
(
"
.
/
SyntheticMutationEvent
"
)
;
var
SyntheticTouchEvent
=
require
(
"
.
/
SyntheticTouchEvent
"
)
;
var
SyntheticUIEvent
=
require
(
"
.
/
SyntheticUIEvent
"
)
;
var
SyntheticWheelEvent
=
require
(
"
.
/
SyntheticWheelEvent
"
)
;
var
invariant
=
require
(
"
.
/
invariant
"
)
;
var
keyOf
=
require
(
"
.
/
keyOf
"
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
eventTypes
=
{
blur
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onBlur
:
true
}
)
captured
:
keyOf
(
{
onBlurCapture
:
true
}
)
}
}
click
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onClick
:
true
}
)
captured
:
keyOf
(
{
onClickCapture
:
true
}
)
}
}
doubleClick
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDoubleClick
:
true
}
)
captured
:
keyOf
(
{
onDoubleClickCapture
:
true
}
)
}
}
drag
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDrag
:
true
}
)
captured
:
keyOf
(
{
onDragCapture
:
true
}
)
}
}
dragEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragEnd
:
true
}
)
captured
:
keyOf
(
{
onDragEndCapture
:
true
}
)
}
}
dragEnter
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragEnter
:
true
}
)
captured
:
keyOf
(
{
onDragEnterCapture
:
true
}
)
}
}
dragExit
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragExit
:
true
}
)
captured
:
keyOf
(
{
onDragExitCapture
:
true
}
)
}
}
dragLeave
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragLeave
:
true
}
)
captured
:
keyOf
(
{
onDragLeaveCapture
:
true
}
)
}
}
dragOver
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragOver
:
true
}
)
captured
:
keyOf
(
{
onDragOverCapture
:
true
}
)
}
}
dragStart
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragStart
:
true
}
)
captured
:
keyOf
(
{
onDragStartCapture
:
true
}
)
}
}
drop
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDrop
:
true
}
)
captured
:
keyOf
(
{
onDropCapture
:
true
}
)
}
}
DOMCharacterDataModified
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDOMCharacterDataModified
:
true
}
)
captured
:
keyOf
(
{
onDOMCharacterDataModifiedCapture
:
true
}
)
}
}
focus
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onFocus
:
true
}
)
captured
:
keyOf
(
{
onFocusCapture
:
true
}
)
}
}
input
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onInput
:
true
}
)
captured
:
keyOf
(
{
onInputCapture
:
true
}
)
}
}
keyDown
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onKeyDown
:
true
}
)
captured
:
keyOf
(
{
onKeyDownCapture
:
true
}
)
}
}
keyPress
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onKeyPress
:
true
}
)
captured
:
keyOf
(
{
onKeyPressCapture
:
true
}
)
}
}
keyUp
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onKeyUp
:
true
}
)
captured
:
keyOf
(
{
onKeyUpCapture
:
true
}
)
}
}
mouseDown
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseDown
:
true
}
)
captured
:
keyOf
(
{
onMouseDownCapture
:
true
}
)
}
}
mouseMove
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseMove
:
true
}
)
captured
:
keyOf
(
{
onMouseMoveCapture
:
true
}
)
}
}
mouseUp
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseUp
:
true
}
)
captured
:
keyOf
(
{
onMouseUpCapture
:
true
}
)
}
}
scroll
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onScroll
:
true
}
)
captured
:
keyOf
(
{
onScrollCapture
:
true
}
)
}
}
submit
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onSubmit
:
true
}
)
captured
:
keyOf
(
{
onSubmitCapture
:
true
}
)
}
}
touchCancel
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchCancel
:
true
}
)
captured
:
keyOf
(
{
onTouchCancelCapture
:
true
}
)
}
}
touchEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchEnd
:
true
}
)
captured
:
keyOf
(
{
onTouchEndCapture
:
true
}
)
}
}
touchMove
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchMove
:
true
}
)
captured
:
keyOf
(
{
onTouchMoveCapture
:
true
}
)
}
}
touchStart
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchStart
:
true
}
)
captured
:
keyOf
(
{
onTouchStartCapture
:
true
}
)
}
}
wheel
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onWheel
:
true
}
)
captured
:
keyOf
(
{
onWheelCapture
:
true
}
)
}
}
}
;
var
topLevelEventsToDispatchConfig
=
{
topBlur
:
eventTypes
.
blur
topClick
:
eventTypes
.
click
topDoubleClick
:
eventTypes
.
doubleClick
topDOMCharacterDataModified
:
eventTypes
.
DOMCharacterDataModified
topDrag
:
eventTypes
.
drag
topDragEnd
:
eventTypes
.
dragEnd
topDragEnter
:
eventTypes
.
dragEnter
topDragExit
:
eventTypes
.
dragExit
topDragLeave
:
eventTypes
.
dragLeave
topDragOver
:
eventTypes
.
dragOver
topDragStart
:
eventTypes
.
dragStart
topDrop
:
eventTypes
.
drop
topFocus
:
eventTypes
.
focus
topInput
:
eventTypes
.
input
topKeyDown
:
eventTypes
.
keyDown
topKeyPress
:
eventTypes
.
keyPress
topKeyUp
:
eventTypes
.
keyUp
topMouseDown
:
eventTypes
.
mouseDown
topMouseMove
:
eventTypes
.
mouseMove
topMouseUp
:
eventTypes
.
mouseUp
topScroll
:
eventTypes
.
scroll
topSubmit
:
eventTypes
.
submit
topTouchCancel
:
eventTypes
.
touchCancel
topTouchEnd
:
eventTypes
.
touchEnd
topTouchMove
:
eventTypes
.
touchMove
topTouchStart
:
eventTypes
.
touchStart
topWheel
:
eventTypes
.
wheel
}
;
var
SimpleEventPlugin
=
{
eventTypes
:
eventTypes
executeDispatch
:
function
(
event
listener
domID
)
{
var
returnValue
=
listener
(
event
domID
)
;
if
(
returnValue
=
=
=
false
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
)
{
var
dispatchConfig
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
if
(
!
dispatchConfig
)
{
return
null
;
}
var
EventConstructor
;
switch
(
topLevelType
)
{
case
topLevelTypes
.
topInput
:
case
topLevelTypes
.
topSubmit
:
EventConstructor
=
SyntheticEvent
;
break
;
case
topLevelTypes
.
topKeyDown
:
case
topLevelTypes
.
topKeyPress
:
case
topLevelTypes
.
topKeyUp
:
EventConstructor
=
SyntheticKeyboardEvent
;
break
;
case
topLevelTypes
.
topBlur
:
case
topLevelTypes
.
topFocus
:
EventConstructor
=
SyntheticFocusEvent
;
break
;
case
topLevelTypes
.
topClick
:
case
topLevelTypes
.
topDoubleClick
:
case
topLevelTypes
.
topDrag
:
case
topLevelTypes
.
topDragEnd
:
case
topLevelTypes
.
topDragEnter
:
case
topLevelTypes
.
topDragExit
:
case
topLevelTypes
.
topDragLeave
:
case
topLevelTypes
.
topDragOver
:
case
topLevelTypes
.
topDragStart
:
case
topLevelTypes
.
topDrop
:
case
topLevelTypes
.
topMouseDown
:
case
topLevelTypes
.
topMouseMove
:
case
topLevelTypes
.
topMouseUp
:
EventConstructor
=
SyntheticMouseEvent
;
break
;
case
topLevelTypes
.
topDOMCharacterDataModified
:
EventConstructor
=
SyntheticMutationEvent
;
break
;
case
topLevelTypes
.
topTouchCancel
:
case
topLevelTypes
.
topTouchEnd
:
case
topLevelTypes
.
topTouchMove
:
case
topLevelTypes
.
topTouchStart
:
EventConstructor
=
SyntheticTouchEvent
;
break
;
case
topLevelTypes
.
topScroll
:
EventConstructor
=
SyntheticUIEvent
;
break
;
case
topLevelTypes
.
topWheel
:
EventConstructor
=
SyntheticWheelEvent
;
break
;
}
invariant
(
EventConstructor
'
SimpleEventPlugin
:
Unhandled
event
type
%
s
.
'
topLevelType
)
;
var
event
=
EventConstructor
.
getPooled
(
dispatchConfig
topLevelTargetID
nativeEvent
)
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
;
module
.
exports
=
SimpleEventPlugin
;
}
{
"
.
/
EventConstants
"
:
13
"
.
/
EventPropagators
"
:
18
"
.
/
SyntheticEvent
"
:
50
"
.
/
SyntheticFocusEvent
"
:
51
"
.
/
SyntheticKeyboardEvent
"
:
52
"
.
/
SyntheticMouseEvent
"
:
53
"
.
/
SyntheticMutationEvent
"
:
54
"
.
/
SyntheticTouchEvent
"
:
55
"
.
/
SyntheticUIEvent
"
:
56
"
.
/
SyntheticWheelEvent
"
:
57
"
.
/
invariant
"
:
75
"
.
/
keyOf
"
:
79
}
]
50
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
PooledClass
=
require
(
"
.
/
PooledClass
"
)
;
var
emptyFunction
=
require
(
"
.
/
emptyFunction
"
)
;
var
getEventTarget
=
require
(
"
.
/
getEventTarget
"
)
;
var
merge
=
require
(
"
.
/
merge
"
)
;
var
mergeInto
=
require
(
"
.
/
mergeInto
"
)
;
var
EventInterface
=
{
type
:
null
target
:
getEventTarget
currentTarget
:
null
eventPhase
:
null
bubbles
:
null
cancelable
:
null
timeStamp
:
function
(
event
)
{
return
event
.
timeStamp
|
|
Date
.
now
(
)
;
}
defaultPrevented
:
null
isTrusted
:
null
}
;
function
SyntheticEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
this
.
dispatchConfig
=
dispatchConfig
;
this
.
dispatchMarker
=
dispatchMarker
;
this
.
nativeEvent
=
nativeEvent
;
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
var
normalize
=
Interface
[
propName
]
;
if
(
normalize
)
{
this
[
propName
]
=
normalize
(
nativeEvent
)
;
}
else
{
this
[
propName
]
=
nativeEvent
[
propName
]
;
}
}
if
(
nativeEvent
.
defaultPrevented
|
|
nativeEvent
.
returnValue
=
=
=
false
)
{
this
.
isDefaultPrevented
=
emptyFunction
.
thatReturnsTrue
;
}
else
{
this
.
isDefaultPrevented
=
emptyFunction
.
thatReturnsFalse
;
}
this
.
isPropagationStopped
=
emptyFunction
.
thatReturnsFalse
;
}
mergeInto
(
SyntheticEvent
.
prototype
{
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
var
event
=
this
.
nativeEvent
;
event
.
preventDefault
?
event
.
preventDefault
(
)
:
event
.
returnValue
=
false
;
this
.
isDefaultPrevented
=
emptyFunction
.
thatReturnsTrue
;
}
stopPropagation
:
function
(
)
{
var
event
=
this
.
nativeEvent
;
event
.
stopPropagation
?
event
.
stopPropagation
(
)
:
event
.
cancelBubble
=
true
;
this
.
isPropagationStopped
=
emptyFunction
.
thatReturnsTrue
;
}
persist
:
function
(
)
{
this
.
isPersistent
=
emptyFunction
.
thatReturnsTrue
;
}
isPersistent
:
emptyFunction
.
thatReturnsFalse
destructor
:
function
(
)
{
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
this
[
propName
]
=
null
;
}
this
.
dispatchConfig
=
null
;
this
.
dispatchMarker
=
null
;
this
.
nativeEvent
=
null
;
}
}
)
;
SyntheticEvent
.
Interface
=
EventInterface
;
SyntheticEvent
.
augmentClass
=
function
(
Class
Interface
)
{
var
Super
=
this
;
var
prototype
=
Object
.
create
(
Super
.
prototype
)
;
mergeInto
(
prototype
Class
.
prototype
)
;
Class
.
prototype
=
prototype
;
Class
.
prototype
.
constructor
=
Class
;
Class
.
Interface
=
merge
(
Super
.
Interface
Interface
)
;
Class
.
augmentClass
=
Super
.
augmentClass
;
PooledClass
.
addPoolingTo
(
Class
PooledClass
.
threeArgumentPooler
)
;
}
;
PooledClass
.
addPoolingTo
(
SyntheticEvent
PooledClass
.
threeArgumentPooler
)
;
module
.
exports
=
SyntheticEvent
;
}
{
"
.
/
PooledClass
"
:
20
"
.
/
emptyFunction
"
:
64
"
.
/
getEventTarget
"
:
70
"
.
/
merge
"
:
81
"
.
/
mergeInto
"
:
83
}
]
51
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticUIEvent
=
require
(
"
.
/
SyntheticUIEvent
"
)
;
var
FocusEventInterface
=
{
relatedTarget
:
null
}
;
function
SyntheticFocusEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticFocusEvent
FocusEventInterface
)
;
module
.
exports
=
SyntheticFocusEvent
;
}
{
"
.
/
SyntheticUIEvent
"
:
56
}
]
52
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticUIEvent
=
require
(
"
.
/
SyntheticUIEvent
"
)
;
var
KeyboardEventInterface
=
{
'
char
'
:
null
key
:
null
location
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
repeat
:
null
locale
:
null
charCode
:
null
keyCode
:
null
which
:
null
}
;
function
SyntheticKeyboardEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticKeyboardEvent
KeyboardEventInterface
)
;
module
.
exports
=
SyntheticKeyboardEvent
;
}
{
"
.
/
SyntheticUIEvent
"
:
56
}
]
53
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticUIEvent
=
require
(
"
.
/
SyntheticUIEvent
"
)
;
var
ViewportMetrics
=
require
(
"
.
/
ViewportMetrics
"
)
;
var
MouseEventInterface
=
{
screenX
:
null
screenY
:
null
clientX
:
null
clientY
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
button
:
function
(
event
)
{
var
button
=
event
.
button
;
if
(
'
which
'
in
event
)
{
return
button
;
}
return
button
=
=
=
2
?
2
:
button
=
=
=
4
?
1
:
0
;
}
buttons
:
null
relatedTarget
:
function
(
event
)
{
return
event
.
relatedTarget
|
|
(
event
.
fromElement
=
=
=
event
.
srcElement
?
event
.
toElement
:
event
.
fromElement
)
;
}
pageX
:
function
(
event
)
{
return
'
pageX
'
in
event
?
event
.
pageX
:
event
.
clientX
+
ViewportMetrics
.
currentScrollLeft
;
}
pageY
:
function
(
event
)
{
return
'
pageY
'
in
event
?
event
.
pageY
:
event
.
clientY
+
ViewportMetrics
.
currentScrollTop
;
}
}
;
function
SyntheticMouseEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticMouseEvent
MouseEventInterface
)
;
module
.
exports
=
SyntheticMouseEvent
;
}
{
"
.
/
SyntheticUIEvent
"
:
56
"
.
/
ViewportMetrics
"
:
59
}
]
54
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticEvent
=
require
(
"
.
/
SyntheticEvent
"
)
;
var
MutationEventInterface
=
{
relatedNode
:
null
prevValue
:
null
newValue
:
null
attrName
:
null
attrChange
:
null
}
;
function
SyntheticMutationEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticMutationEvent
MutationEventInterface
)
;
module
.
exports
=
SyntheticMutationEvent
;
}
{
"
.
/
SyntheticEvent
"
:
50
}
]
55
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticUIEvent
=
require
(
"
.
/
SyntheticUIEvent
"
)
;
var
TouchEventInterface
=
{
touches
:
null
targetTouches
:
null
changedTouches
:
null
altKey
:
null
metaKey
:
null
ctrlKey
:
null
shiftKey
:
null
}
;
function
SyntheticTouchEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticTouchEvent
TouchEventInterface
)
;
module
.
exports
=
SyntheticTouchEvent
;
}
{
"
.
/
SyntheticUIEvent
"
:
56
}
]
56
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticEvent
=
require
(
"
.
/
SyntheticEvent
"
)
;
var
UIEventInterface
=
{
view
:
null
detail
:
null
}
;
function
SyntheticUIEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticUIEvent
UIEventInterface
)
;
module
.
exports
=
SyntheticUIEvent
;
}
{
"
.
/
SyntheticEvent
"
:
50
}
]
57
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
SyntheticMouseEvent
=
require
(
"
.
/
SyntheticMouseEvent
"
)
;
var
WheelEventInterface
=
{
deltaX
:
function
(
event
)
{
return
(
'
deltaX
'
in
event
?
event
.
deltaX
:
'
wheelDeltaX
'
in
event
?
-
event
.
wheelDeltaX
:
0
)
;
}
deltaY
:
function
(
event
)
{
return
(
'
deltaY
'
in
event
?
-
event
.
deltaY
:
'
wheelDeltaY
'
in
event
?
event
.
wheelDeltaY
:
'
wheelDelta
'
in
event
?
event
.
wheelData
:
0
)
;
}
deltaZ
:
null
deltaMode
:
null
}
;
function
SyntheticWheelEvent
(
dispatchConfig
dispatchMarker
nativeEvent
)
{
SyntheticMouseEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
)
;
}
SyntheticMouseEvent
.
augmentClass
(
SyntheticWheelEvent
WheelEventInterface
)
;
module
.
exports
=
SyntheticWheelEvent
;
}
{
"
.
/
SyntheticMouseEvent
"
:
53
}
]
58
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
DUAL_TRANSACTION
=
'
DUAL_TRANSACTION
'
;
var
MISSING_TRANSACTION
=
'
MISSING_TRANSACTION
'
;
if
(
true
)
{
DUAL_TRANSACTION
=
'
Cannot
initialize
transaction
when
there
is
already
an
outstanding
'
+
'
transaction
.
Common
causes
of
this
are
trying
to
render
a
component
'
+
'
when
you
are
already
rendering
a
component
or
attempting
a
state
'
+
'
transition
while
in
a
render
function
.
Another
possibility
is
that
'
+
'
you
are
rendering
new
content
(
or
state
transitioning
)
in
a
'
+
'
componentDidRender
callback
.
If
this
is
not
the
case
please
report
the
'
+
'
issue
immediately
.
'
;
MISSING_TRANSACTION
=
'
Cannot
close
transaction
when
there
is
none
open
.
'
;
}
var
Mixin
=
{
reinitializeTransaction
:
function
(
)
{
this
.
transactionWrappers
=
this
.
getTransactionWrappers
(
)
;
if
(
!
this
.
wrapperInitData
)
{
this
.
wrapperInitData
=
[
]
;
}
else
{
this
.
wrapperInitData
.
length
=
0
;
}
if
(
!
this
.
timingMetrics
)
{
this
.
timingMetrics
=
{
}
;
}
this
.
timingMetrics
.
methodInvocationTime
=
0
;
if
(
!
this
.
timingMetrics
.
wrapperInitTimes
)
{
this
.
timingMetrics
.
wrapperInitTimes
=
[
]
;
}
else
{
this
.
timingMetrics
.
wrapperInitTimes
.
length
=
0
;
}
if
(
!
this
.
timingMetrics
.
wrapperCloseTimes
)
{
this
.
timingMetrics
.
wrapperCloseTimes
=
[
]
;
}
else
{
this
.
timingMetrics
.
wrapperCloseTimes
.
length
=
0
;
}
this
.
_isInTransaction
=
false
;
}
_isInTransaction
:
false
getTransactionWrappers
:
null
isInTransaction
:
function
(
)
{
return
!
!
this
.
_isInTransaction
;
}
perform
:
function
(
method
scope
a
b
c
d
e
f
)
{
throwIf
(
this
.
isInTransaction
(
)
DUAL_TRANSACTION
)
;
var
memberStart
=
Date
.
now
(
)
;
var
err
=
null
;
var
ret
;
try
{
this
.
initializeAll
(
)
;
ret
=
method
.
call
(
scope
a
b
c
d
e
f
)
;
}
catch
(
ie_requires_catch
)
{
err
=
ie_requires_catch
;
}
finally
{
var
memberEnd
=
Date
.
now
(
)
;
this
.
methodInvocationTime
+
=
(
memberEnd
-
memberStart
)
;
try
{
this
.
closeAll
(
)
;
}
catch
(
closeAllErr
)
{
err
=
err
|
|
closeAllErr
;
}
}
if
(
err
)
{
throw
err
;
}
return
ret
;
}
initializeAll
:
function
(
)
{
this
.
_isInTransaction
=
true
;
var
transactionWrappers
=
this
.
transactionWrappers
;
var
wrapperInitTimes
=
this
.
timingMetrics
.
wrapperInitTimes
;
var
err
=
null
;
for
(
var
i
=
0
;
i
<
transactionWrappers
.
length
;
i
+
+
)
{
var
initStart
=
Date
.
now
(
)
;
var
wrapper
=
transactionWrappers
[
i
]
;
try
{
this
.
wrapperInitData
[
i
]
=
wrapper
.
initialize
?
wrapper
.
initialize
.
call
(
this
)
:
null
;
}
catch
(
initErr
)
{
err
=
err
|
|
initErr
;
this
.
wrapperInitData
[
i
]
=
Transaction
.
OBSERVED_ERROR
;
}
finally
{
var
curInitTime
=
wrapperInitTimes
[
i
]
;
var
initEnd
=
Date
.
now
(
)
;
wrapperInitTimes
[
i
]
=
(
curInitTime
|
|
0
)
+
(
initEnd
-
initStart
)
;
}
}
if
(
err
)
{
throw
err
;
}
}
closeAll
:
function
(
)
{
throwIf
(
!
this
.
isInTransaction
(
)
MISSING_TRANSACTION
)
;
var
transactionWrappers
=
this
.
transactionWrappers
;
var
wrapperCloseTimes
=
this
.
timingMetrics
.
wrapperCloseTimes
;
var
err
=
null
;
for
(
var
i
=
0
;
i
<
transactionWrappers
.
length
;
i
+
+
)
{
var
wrapper
=
transactionWrappers
[
i
]
;
var
closeStart
=
Date
.
now
(
)
;
var
initData
=
this
.
wrapperInitData
[
i
]
;
try
{
if
(
initData
!
=
=
Transaction
.
OBSERVED_ERROR
)
{
wrapper
.
close
&
&
wrapper
.
close
.
call
(
this
initData
)
;
}
}
catch
(
closeErr
)
{
err
=
err
|
|
closeErr
;
}
finally
{
var
closeEnd
=
Date
.
now
(
)
;
var
curCloseTime
=
wrapperCloseTimes
[
i
]
;
wrapperCloseTimes
[
i
]
=
(
curCloseTime
|
|
0
)
+
(
closeEnd
-
closeStart
)
;
}
}
this
.
wrapperInitData
.
length
=
0
;
this
.
_isInTransaction
=
false
;
if
(
err
)
{
throw
err
;
}
}
}
;
var
Transaction
=
{
Mixin
:
Mixin
OBSERVED_ERROR
:
{
}
}
;
module
.
exports
=
Transaction
;
}
)
(
)
}
{
"
.
/
throwIf
"
:
86
}
]
59
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ViewportMetrics
=
{
currentScrollLeft
:
0
currentScrollTop
:
0
refreshScrollValues
:
function
(
)
{
ViewportMetrics
.
currentScrollLeft
=
document
.
body
.
scrollLeft
+
document
.
documentElement
.
scrollLeft
;
ViewportMetrics
.
currentScrollTop
=
document
.
body
.
scrollTop
+
document
.
documentElement
.
scrollTop
;
}
}
;
module
.
exports
=
ViewportMetrics
;
}
{
}
]
60
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
INVALID_ARGS
=
'
INVALID_ACCUM_ARGS
'
;
if
(
true
)
{
INVALID_ARGS
=
'
accumulate
requires
non
empty
(
non
-
null
defined
)
next
'
+
'
values
.
All
arrays
accumulated
must
not
contain
any
empty
items
.
'
;
}
function
accumulate
(
cur
next
)
{
var
curValIsEmpty
=
cur
=
=
null
;
var
nextValIsEmpty
=
next
=
=
=
null
;
if
(
true
)
{
throwIf
(
nextValIsEmpty
INVALID_ARGS
)
;
}
if
(
nextValIsEmpty
)
{
return
cur
;
}
else
{
if
(
curValIsEmpty
)
{
return
next
;
}
else
{
var
curIsArray
=
Array
.
isArray
(
cur
)
;
var
nextIsArray
=
Array
.
isArray
(
next
)
;
if
(
curIsArray
)
{
return
cur
.
concat
(
next
)
;
}
else
{
if
(
nextIsArray
)
{
return
[
cur
]
.
concat
(
next
)
;
}
else
{
return
[
cur
next
]
;
}
}
}
}
}
module
.
exports
=
accumulate
;
}
{
"
.
/
throwIf
"
:
86
}
]
61
:
[
function
(
require
module
exports
)
{
function
copyProperties
(
obj
a
b
c
d
e
f
)
{
obj
=
obj
|
|
{
}
;
if
(
true
)
{
if
(
f
)
{
throw
new
Error
(
'
Too
many
arguments
passed
to
copyProperties
'
)
;
}
}
var
args
=
[
a
b
c
d
e
]
;
var
ii
=
0
v
;
while
(
args
[
ii
]
)
{
v
=
args
[
ii
+
+
]
;
for
(
var
k
in
v
)
{
obj
[
k
]
=
v
[
k
]
;
}
if
(
v
.
hasOwnProperty
&
&
v
.
hasOwnProperty
(
'
toString
'
)
&
&
(
typeof
v
.
toString
!
=
'
undefined
'
)
&
&
(
obj
.
toString
!
=
=
v
.
toString
)
)
{
obj
.
toString
=
v
.
toString
;
}
}
return
obj
;
}
module
.
exports
=
copyProperties
;
}
{
}
]
62
:
[
function
(
require
module
exports
)
{
var
hasArrayNature
=
require
(
"
.
/
hasArrayNature
"
)
;
function
createObjectFrom
(
keys
values
)
{
if
(
true
)
{
if
(
!
hasArrayNature
(
keys
)
)
{
throw
new
TypeError
(
'
Must
pass
an
array
of
keys
.
'
)
;
}
}
var
object
=
{
}
;
var
is_array
=
hasArrayNature
(
values
)
;
if
(
typeof
values
=
=
'
undefined
'
)
{
values
=
true
;
}
for
(
var
ii
=
keys
.
length
;
ii
-
-
;
)
{
object
[
keys
[
ii
]
]
=
is_array
?
values
[
ii
]
:
values
;
}
return
object
;
}
module
.
exports
=
createObjectFrom
;
}
{
"
.
/
hasArrayNature
"
:
72
}
]
63
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
CSSProperty
=
require
(
"
.
/
CSSProperty
"
)
;
function
dangerousStyleValue
(
styleName
value
)
{
var
isEmpty
=
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
if
(
isEmpty
)
{
return
'
'
;
}
var
isNonNumeric
=
isNaN
(
value
)
;
if
(
isNonNumeric
|
|
value
=
=
=
0
|
|
CSSProperty
.
isUnitlessNumber
[
styleName
]
)
{
return
'
'
+
value
;
}
return
value
+
'
px
'
;
}
module
.
exports
=
dangerousStyleValue
;
}
{
"
.
/
CSSProperty
"
:
2
}
]
64
:
[
function
(
require
module
exports
)
{
var
copyProperties
=
require
(
"
.
/
copyProperties
"
)
;
function
makeEmptyFunction
(
arg
)
{
return
function
(
)
{
return
arg
;
}
;
}
function
emptyFunction
(
)
{
}
copyProperties
(
emptyFunction
{
thatReturns
:
makeEmptyFunction
thatReturnsFalse
:
makeEmptyFunction
(
false
)
thatReturnsTrue
:
makeEmptyFunction
(
true
)
thatReturnsNull
:
makeEmptyFunction
(
null
)
thatReturnsThis
:
function
(
)
{
return
this
;
}
thatReturnsArgument
:
function
(
arg
)
{
return
arg
;
}
}
)
;
module
.
exports
=
emptyFunction
;
}
{
"
.
/
copyProperties
"
:
61
}
]
65
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
ESCAPE_TYPE_ERR
;
if
(
true
)
{
ESCAPE_TYPE_ERR
=
'
The
React
core
has
attempted
to
escape
content
that
is
of
a
'
+
'
mysterious
type
(
object
etc
)
Escaping
only
works
on
numbers
and
strings
'
;
}
var
ESCAPE_LOOKUP
=
{
"
&
"
:
"
&
amp
;
"
"
>
"
:
"
&
gt
;
"
"
<
"
:
"
&
lt
;
"
"
\
"
"
:
"
&
quot
;
"
"
'
"
:
"
&
#
x27
;
"
"
/
"
:
"
&
#
x2f
;
"
}
;
function
escaper
(
match
)
{
return
ESCAPE_LOOKUP
[
match
]
;
}
var
escapeTextForBrowser
=
function
(
text
)
{
var
type
=
typeof
text
;
var
invalid
=
type
=
=
=
'
object
'
;
if
(
true
)
{
throwIf
(
invalid
ESCAPE_TYPE_ERR
)
;
}
if
(
text
=
=
=
'
'
|
|
invalid
)
{
return
'
'
;
}
else
{
if
(
type
=
=
=
'
string
'
)
{
return
text
.
replace
(
/
[
&
>
<
"
'
\
/
]
/
g
escaper
)
;
}
else
{
return
(
'
'
+
text
)
.
replace
(
/
[
&
>
<
"
'
\
/
]
/
g
escaper
)
;
}
}
}
;
module
.
exports
=
escapeTextForBrowser
;
}
{
"
.
/
throwIf
"
:
86
}
]
66
:
[
function
(
require
module
exports
)
{
var
ex
=
function
(
errorMessage
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
.
map
(
function
(
arg
)
{
return
String
(
arg
)
;
}
)
;
var
expectedLength
=
errorMessage
.
split
(
'
%
s
'
)
.
length
-
1
;
if
(
expectedLength
!
=
=
args
.
length
-
1
)
{
return
ex
(
'
ex
args
number
mismatch
:
%
s
'
JSON
.
stringify
(
args
)
)
;
}
return
ex
.
_prefix
+
JSON
.
stringify
(
args
)
+
ex
.
_suffix
;
}
;
ex
.
_prefix
=
'
<
!
[
EX
[
'
;
ex
.
_suffix
=
'
]
]
>
'
;
module
.
exports
=
ex
;
}
{
}
]
67
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
traverseAllChildren
=
require
(
"
.
/
traverseAllChildren
"
)
;
function
flattenSingleChildIntoContext
(
traverseContext
child
name
)
{
var
result
=
traverseContext
;
if
(
true
)
{
throwIf
(
result
.
hasOwnProperty
(
name
)
traverseAllChildren
.
DUPLICATE_KEY_ERROR
)
;
}
result
[
name
]
=
child
;
}
function
flattenChildren
(
children
)
{
if
(
children
=
=
=
null
|
|
children
=
=
=
undefined
)
{
return
children
;
}
var
result
=
{
}
;
traverseAllChildren
(
children
flattenSingleChildIntoContext
result
)
;
return
result
;
}
module
.
exports
=
flattenChildren
;
}
{
"
.
/
throwIf
"
:
86
"
.
/
traverseAllChildren
"
:
87
}
]
68
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
forEachAccumulated
=
function
(
arr
cb
scope
)
{
if
(
Array
.
isArray
(
arr
)
)
{
arr
.
forEach
(
cb
scope
)
;
}
else
if
(
arr
)
{
cb
.
call
(
scope
arr
)
;
}
}
;
module
.
exports
=
forEachAccumulated
;
}
{
}
]
69
:
[
function
(
require
module
exports
)
{
function
ge
(
arg
root
tag
)
{
return
typeof
arg
!
=
'
string
'
?
arg
:
!
root
?
document
.
getElementById
(
arg
)
:
_geFromSubtree
(
arg
root
tag
)
;
}
function
_geFromSubtree
(
id
root
tag
)
{
var
elem
children
ii
;
if
(
_getNodeID
(
root
)
=
=
id
)
{
return
root
;
}
else
if
(
root
.
getElementsByTagName
)
{
children
=
root
.
getElementsByTagName
(
tag
|
|
'
*
'
)
;
for
(
ii
=
0
;
ii
<
children
.
length
;
ii
+
+
)
{
if
(
_getNodeID
(
children
[
ii
]
)
=
=
id
)
{
return
children
[
ii
]
;
}
}
}
else
{
children
=
root
.
childNodes
;
for
(
ii
=
0
;
ii
<
children
.
length
;
ii
+
+
)
{
elem
=
_geFromSubtree
(
id
children
[
ii
]
)
;
if
(
elem
)
{
return
elem
;
}
}
}
return
null
;
}
function
_getNodeID
(
node
)
{
var
id
=
node
.
getAttributeNode
&
&
node
.
getAttributeNode
(
'
id
'
)
;
return
id
?
id
.
value
:
null
;
}
module
.
exports
=
ge
;
}
{
}
]
70
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
function
getEventTarget
(
nativeEvent
)
{
var
target
=
nativeEvent
.
target
|
|
nativeEvent
.
srcElement
|
|
ExecutionEnvironment
.
global
;
return
target
.
nodeType
=
=
=
3
?
target
.
parentNode
:
target
;
}
module
.
exports
=
getEventTarget
;
}
)
(
)
}
{
"
.
/
ExecutionEnvironment
"
:
19
}
]
71
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
contentKey
=
null
;
function
getTextContentAccessor
(
)
{
if
(
!
contentKey
&
&
ExecutionEnvironment
.
canUseDOM
)
{
contentKey
=
'
innerText
'
in
document
.
createElement
(
'
div
'
)
?
'
innerText
'
:
'
textContent
'
;
}
return
contentKey
;
}
module
.
exports
=
getTextContentAccessor
;
}
{
"
.
/
ExecutionEnvironment
"
:
19
}
]
72
:
[
function
(
require
module
exports
)
{
function
hasArrayNature
(
obj
)
{
return
(
!
!
obj
&
&
(
typeof
obj
=
=
'
object
'
|
|
typeof
obj
=
=
'
function
'
)
&
&
(
'
length
'
in
obj
)
&
&
!
(
'
setInterval
'
in
obj
)
&
&
(
typeof
obj
.
nodeType
!
=
'
number
'
)
&
&
(
(
Array
.
isArray
(
obj
)
|
|
(
'
callee
'
in
obj
)
|
|
'
item
'
in
obj
)
)
)
;
}
module
.
exports
=
hasArrayNature
;
}
{
}
]
73
:
[
function
(
require
module
exports
)
{
var
_uppercasePattern
=
/
(
[
A
-
Z
]
)
/
g
;
function
hyphenate
(
string
)
{
return
string
.
replace
(
_uppercasePattern
'
-
1
'
)
.
toLowerCase
(
)
;
}
module
.
exports
=
hyphenate
;
}
{
}
]
74
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
function
insertNodeAt
(
root
node
atIndex
)
{
var
childNodes
=
root
.
childNodes
;
var
curAtIndex
=
root
.
childNodes
[
atIndex
]
;
if
(
curAtIndex
=
=
=
node
)
{
return
node
;
}
if
(
node
.
parentNode
)
{
node
.
parentNode
.
removeChild
(
node
)
;
}
if
(
atIndex
>
=
childNodes
.
length
)
{
root
.
appendChild
(
node
)
;
}
else
{
root
.
insertBefore
(
node
childNodes
[
atIndex
]
)
;
}
return
node
;
}
module
.
exports
=
insertNodeAt
;
}
{
}
]
75
:
[
function
(
require
module
exports
)
{
function
invariant
(
condition
)
{
if
(
!
condition
)
{
throw
new
Error
(
'
Invariant
Violation
'
)
;
}
}
module
.
exports
=
invariant
;
if
(
true
)
{
var
invariantDev
=
function
(
condition
format
a
b
c
d
e
f
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
invariant
requires
an
error
message
argument
'
)
;
}
if
(
!
condition
)
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
throw
new
Error
(
'
Invariant
Violation
:
'
+
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
}
}
;
module
.
exports
=
invariantDev
;
}
}
{
}
]
76
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
ExecutionEnvironment
=
require
(
"
.
/
ExecutionEnvironment
"
)
;
var
testNode
useHasFeature
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
testNode
=
document
.
createElement
(
'
div
'
)
;
useHasFeature
=
document
.
implementation
&
&
document
.
implementation
.
hasFeature
&
&
document
.
implementation
.
hasFeature
(
'
'
'
'
)
!
=
=
true
;
}
function
isEventSupported
(
eventNameSuffix
capture
)
{
if
(
!
testNode
|
|
(
capture
&
&
!
testNode
.
addEventListener
)
)
{
return
false
;
}
var
element
=
document
.
createElement
(
'
div
'
)
;
var
eventName
=
'
on
'
+
eventNameSuffix
;
var
isSupported
=
eventName
in
element
;
if
(
!
isSupported
)
{
element
.
setAttribute
(
eventName
'
'
)
;
isSupported
=
typeof
element
[
eventName
]
=
=
=
'
function
'
;
if
(
typeof
element
[
eventName
]
!
=
=
'
undefined
'
)
{
element
[
eventName
]
=
undefined
;
}
element
.
removeAttribute
(
eventName
)
;
}
if
(
!
isSupported
&
&
useHasFeature
&
&
eventNameSuffix
=
=
=
'
wheel
'
)
{
isSupported
=
document
.
implementation
.
hasFeature
(
'
Events
.
wheel
'
'
3
.
0
'
)
;
}
element
=
null
;
return
isSupported
;
}
module
.
exports
=
isEventSupported
;
}
{
"
.
/
ExecutionEnvironment
"
:
19
}
]
77
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
function
joinClasses
(
className
)
{
if
(
!
className
)
{
className
=
'
'
;
}
var
nextClass
;
var
argLength
=
arguments
.
length
;
if
(
argLength
>
1
)
{
for
(
var
ii
=
1
;
ii
<
argLength
;
ii
+
+
)
{
nextClass
=
arguments
[
ii
]
;
nextClass
&
&
(
className
+
=
'
'
+
nextClass
)
;
}
}
return
className
;
}
module
.
exports
=
joinClasses
;
}
{
}
]
78
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
NOT_OBJECT_ERROR
=
'
NOT_OBJECT_ERROR
'
;
if
(
true
)
{
NOT_OBJECT_ERROR
=
'
keyMirror
only
works
on
objects
'
;
}
var
keyMirror
=
function
(
obj
)
{
var
ret
=
{
}
;
var
key
;
throwIf
(
!
(
obj
instanceof
Object
)
|
|
Array
.
isArray
(
obj
)
NOT_OBJECT_ERROR
)
;
for
(
key
in
obj
)
{
if
(
!
obj
.
hasOwnProperty
(
key
)
)
{
continue
;
}
ret
[
key
]
=
key
;
}
return
ret
;
}
;
module
.
exports
=
keyMirror
;
}
{
"
.
/
throwIf
"
:
86
}
]
79
:
[
function
(
require
module
exports
)
{
var
keyOf
=
function
(
oneKeyObj
)
{
var
key
;
for
(
key
in
oneKeyObj
)
{
if
(
!
oneKeyObj
.
hasOwnProperty
(
key
)
)
{
continue
;
}
return
key
;
}
return
null
;
}
;
module
.
exports
=
keyOf
;
}
{
}
]
80
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
function
memoizeStringOnly
(
callback
)
{
var
cache
=
{
}
;
return
function
(
string
)
{
if
(
cache
.
hasOwnProperty
(
string
)
)
{
return
cache
[
string
]
;
}
else
{
return
cache
[
string
]
=
callback
.
call
(
this
string
)
;
}
}
;
}
module
.
exports
=
memoizeStringOnly
;
}
{
}
]
81
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
mergeInto
=
require
(
"
.
/
mergeInto
"
)
;
var
merge
=
function
(
one
two
)
{
var
result
=
{
}
;
mergeInto
(
result
one
)
;
mergeInto
(
result
two
)
;
return
result
;
}
;
module
.
exports
=
merge
;
}
{
"
.
/
mergeInto
"
:
83
}
]
82
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
keyMirror
=
require
(
"
.
/
keyMirror
"
)
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
MAX_MERGE_DEPTH
=
36
;
var
ERRORS
=
keyMirror
(
{
MERGE_ARRAY_FAIL
:
null
MERGE_CORE_FAILURE
:
null
MERGE_TYPE_USAGE_FAILURE
:
null
MERGE_DEEP_MAX_LEVELS
:
null
MERGE_DEEP_NO_ARR_STRATEGY
:
null
}
)
;
if
(
true
)
{
ERRORS
=
{
MERGE_ARRAY_FAIL
:
'
Unsupported
type
passed
to
a
merge
function
.
You
may
have
passed
a
'
+
'
structure
that
contains
an
array
and
the
merge
function
does
not
know
'
+
'
how
to
merge
arrays
.
'
MERGE_CORE_FAILURE
:
'
Critical
assumptions
about
the
merge
functions
have
been
violated
.
'
+
'
This
is
the
fault
of
the
merge
functions
themselves
not
necessarily
'
+
'
the
callers
.
'
MERGE_TYPE_USAGE_FAILURE
:
'
Calling
merge
function
with
invalid
types
.
You
may
call
merge
'
+
'
functions
(
non
-
array
non
-
terminal
)
OR
(
null
/
undefined
)
arguments
.
'
+
'
mergeInto
functions
have
the
same
requirements
but
with
an
added
'
+
'
restriction
that
the
first
parameter
must
not
be
null
/
undefined
.
'
MERGE_DEEP_MAX_LEVELS
:
'
Maximum
deep
merge
depth
exceeded
.
You
may
attempting
to
merge
'
+
'
circular
structures
in
an
unsupported
way
.
'
MERGE_DEEP_NO_ARR_STRATEGY
:
'
You
must
provide
an
array
strategy
to
deep
merge
functions
to
'
+
'
instruct
the
deep
merge
how
to
resolve
merging
two
arrays
.
'
}
;
}
var
isTerminal
=
function
(
o
)
{
return
typeof
o
!
=
=
'
object
'
|
|
o
=
=
=
null
;
}
;
var
mergeHelpers
=
{
MAX_MERGE_DEPTH
:
MAX_MERGE_DEPTH
isTerminal
:
isTerminal
normalizeMergeArg
:
function
(
arg
)
{
return
arg
=
=
=
undefined
|
|
arg
=
=
=
null
?
{
}
:
arg
;
}
checkMergeArrayArgs
:
function
(
one
two
)
{
throwIf
(
!
Array
.
isArray
(
one
)
|
|
!
Array
.
isArray
(
two
)
ERRORS
.
MERGE_CORE_FAILURE
)
;
}
checkMergeObjectArgs
:
function
(
one
two
)
{
mergeHelpers
.
checkMergeObjectArg
(
one
)
;
mergeHelpers
.
checkMergeObjectArg
(
two
)
;
}
checkMergeObjectArg
:
function
(
arg
)
{
throwIf
(
isTerminal
(
arg
)
|
|
Array
.
isArray
(
arg
)
ERRORS
.
MERGE_CORE_FAILURE
)
;
}
checkMergeLevel
:
function
(
level
)
{
throwIf
(
level
>
=
MAX_MERGE_DEPTH
ERRORS
.
MERGE_DEEP_MAX_LEVELS
)
;
}
checkArrayStrategy
:
function
(
strategy
)
{
throwIf
(
strategy
!
=
=
undefined
&
&
!
(
strategy
in
mergeHelpers
.
ArrayStrategies
)
ERRORS
.
MERGE_DEEP_NO_ARR_STRATEGY
)
;
}
ArrayStrategies
:
keyMirror
(
{
Clobber
:
true
IndexByIndex
:
true
}
)
ERRORS
:
ERRORS
}
;
module
.
exports
=
mergeHelpers
;
}
{
"
.
/
keyMirror
"
:
78
"
.
/
throwIf
"
:
86
}
]
83
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
mergeHelpers
=
require
(
"
.
/
mergeHelpers
"
)
;
var
checkMergeObjectArg
=
mergeHelpers
.
checkMergeObjectArg
;
function
mergeInto
(
one
two
)
{
checkMergeObjectArg
(
one
)
;
if
(
two
!
=
null
)
{
checkMergeObjectArg
(
two
)
;
for
(
var
key
in
two
)
{
if
(
!
two
.
hasOwnProperty
(
key
)
)
{
continue
;
}
one
[
key
]
=
two
[
key
]
;
}
}
}
module
.
exports
=
mergeInto
;
}
{
"
.
/
mergeHelpers
"
:
82
}
]
84
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
mixInto
=
function
(
constructor
methodBag
)
{
var
methodName
;
for
(
methodName
in
methodBag
)
{
if
(
!
methodBag
.
hasOwnProperty
(
methodName
)
)
{
continue
;
}
constructor
.
prototype
[
methodName
]
=
methodBag
[
methodName
]
;
}
}
;
module
.
exports
=
mixInto
;
}
{
}
]
85
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
function
objMapKeyVal
(
obj
func
context
)
{
if
(
!
obj
)
{
return
null
;
}
var
i
=
0
;
var
ret
=
{
}
;
for
(
var
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
)
{
ret
[
key
]
=
func
.
call
(
context
key
obj
[
key
]
i
+
+
)
;
}
}
return
ret
;
}
module
.
exports
=
objMapKeyVal
;
}
{
}
]
86
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
var
throwIf
=
function
(
condition
err
)
{
if
(
condition
)
{
throw
new
Error
(
err
)
;
}
}
;
module
.
exports
=
throwIf
;
}
{
}
]
87
:
[
function
(
require
module
exports
)
{
(
function
(
)
{
"
use
strict
"
;
var
ReactComponent
=
require
(
"
.
/
ReactComponent
"
)
;
var
ReactTextComponent
=
require
(
"
.
/
ReactTextComponent
"
)
;
var
throwIf
=
require
(
"
.
/
throwIf
"
)
;
var
DUPLICATE_KEY_ERROR
=
'
DUPLICATE_KEY_ERROR
'
;
var
INVALID_CHILD
=
'
INVALID_CHILD
'
;
if
(
true
)
{
INVALID_CHILD
=
'
You
may
not
pass
a
child
of
that
type
to
a
React
component
.
It
'
+
'
is
a
common
mistake
to
try
to
pass
a
standard
browser
DOM
element
'
+
'
as
a
child
of
a
React
component
.
'
;
DUPLICATE_KEY_ERROR
=
'
You
have
two
children
with
identical
keys
.
Make
sure
that
you
set
the
'
+
'
"
key
"
property
to
a
unique
value
such
as
a
row
ID
.
'
;
}
var
traverseAllChildrenImpl
=
function
(
children
nameSoFar
indexSoFar
callback
traverseContext
)
{
var
subtreeCount
=
0
;
if
(
Array
.
isArray
(
children
)
)
{
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
child
=
children
[
i
]
;
var
nextName
=
nameSoFar
+
'
[
'
+
ReactComponent
.
getKey
(
child
i
)
+
'
]
'
;
var
nextIndex
=
indexSoFar
+
subtreeCount
;
subtreeCount
+
=
traverseAllChildrenImpl
(
child
nextName
nextIndex
callback
traverseContext
)
;
}
}
else
{
var
type
=
typeof
children
;
var
isOnlyChild
=
nameSoFar
=
=
=
'
'
;
var
storageName
=
isOnlyChild
?
'
[
'
+
ReactComponent
.
getKey
(
children
0
)
+
'
]
'
:
nameSoFar
;
if
(
children
=
=
=
null
|
|
children
=
=
=
undefined
|
|
type
=
=
=
'
boolean
'
)
{
callback
(
traverseContext
null
storageName
indexSoFar
)
;
subtreeCount
=
1
;
}
else
if
(
children
.
mountComponentIntoNode
)
{
callback
(
traverseContext
children
storageName
indexSoFar
)
;
subtreeCount
=
1
;
}
else
{
if
(
type
=
=
=
'
object
'
)
{
throwIf
(
children
&
&
children
.
nodeType
=
=
=
1
INVALID_CHILD
)
;
for
(
var
key
in
children
)
{
if
(
children
.
hasOwnProperty
(
key
)
)
{
subtreeCount
+
=
traverseAllChildrenImpl
(
children
[
key
]
nameSoFar
+
'
{
'
+
key
+
'
}
'
indexSoFar
+
subtreeCount
callback
traverseContext
)
;
}
}
}
else
if
(
type
=
=
=
'
string
'
)
{
var
normalizedText
=
new
ReactTextComponent
(
children
)
;
callback
(
traverseContext
normalizedText
storageName
indexSoFar
)
;
subtreeCount
+
=
1
;
}
else
if
(
type
=
=
=
'
number
'
)
{
var
normalizedNumber
=
new
ReactTextComponent
(
'
'
+
children
)
;
callback
(
traverseContext
normalizedNumber
storageName
indexSoFar
)
;
subtreeCount
+
=
1
;
}
}
}
return
subtreeCount
;
}
;
function
traverseAllChildren
(
children
callback
traverseContext
)
{
if
(
children
!
=
=
null
&
&
children
!
=
=
undefined
)
{
traverseAllChildrenImpl
(
children
'
'
0
callback
traverseContext
)
;
}
}
traverseAllChildren
.
DUPLICATE_KEY_ERROR
=
DUPLICATE_KEY_ERROR
;
module
.
exports
=
traverseAllChildren
;
}
)
(
)
}
{
"
.
/
ReactComponent
"
:
22
"
.
/
ReactTextComponent
"
:
47
"
.
/
throwIf
"
:
86
}
]
}
{
}
[
21
]
)
(
21
)
}
)
;
;
