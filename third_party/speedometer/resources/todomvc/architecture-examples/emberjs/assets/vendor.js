window
.
EmberENV
=
{
"
FEATURES
"
:
{
}
}
;
var
runningTests
=
false
;
;
var
loader
define
requireModule
require
requirejs
;
(
function
(
global
)
{
'
use
strict
'
;
var
heimdall
=
global
.
heimdall
;
function
dict
(
)
{
var
obj
=
Object
.
create
(
null
)
;
obj
[
'
__
'
]
=
undefined
;
delete
obj
[
'
__
'
]
;
return
obj
;
}
var
oldGlobals
=
{
loader
:
loader
define
:
define
requireModule
:
requireModule
require
:
require
requirejs
:
requirejs
}
;
requirejs
=
require
=
requireModule
=
function
(
name
)
{
var
pending
=
[
]
;
var
mod
=
findModule
(
name
'
(
require
)
'
pending
)
;
for
(
var
i
=
pending
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
pending
[
i
]
.
exports
(
)
;
}
return
mod
.
module
.
exports
;
}
;
loader
=
{
noConflict
:
function
(
aliases
)
{
var
oldName
newName
;
for
(
oldName
in
aliases
)
{
if
(
aliases
.
hasOwnProperty
(
oldName
)
)
{
if
(
oldGlobals
.
hasOwnProperty
(
oldName
)
)
{
newName
=
aliases
[
oldName
]
;
global
[
newName
]
=
global
[
oldName
]
;
global
[
oldName
]
=
oldGlobals
[
oldName
]
;
}
}
}
}
}
;
var
_isArray
;
if
(
!
Array
.
isArray
)
{
_isArray
=
function
(
x
)
{
return
Object
.
prototype
.
toString
.
call
(
x
)
=
=
=
'
[
object
Array
]
'
;
}
;
}
else
{
_isArray
=
Array
.
isArray
;
}
var
registry
=
dict
(
)
;
var
seen
=
dict
(
)
;
var
uuid
=
0
;
function
unsupportedModule
(
length
)
{
throw
new
Error
(
'
an
unsupported
module
was
defined
expected
define
(
name
deps
module
)
instead
got
:
'
+
length
+
'
arguments
to
define
'
)
;
}
var
defaultDeps
=
[
'
require
'
'
exports
'
'
module
'
]
;
function
Module
(
name
deps
callback
alias
)
{
this
.
id
=
uuid
+
+
;
this
.
name
=
name
;
this
.
deps
=
!
deps
.
length
&
&
callback
.
length
?
defaultDeps
:
deps
;
this
.
module
=
{
exports
:
{
}
}
;
this
.
callback
=
callback
;
this
.
hasExportsAsDep
=
false
;
this
.
isAlias
=
alias
;
this
.
reified
=
new
Array
(
deps
.
length
)
;
this
.
state
=
'
new
'
;
}
Module
.
prototype
.
makeDefaultExport
=
function
(
)
{
var
exports
=
this
.
module
.
exports
;
if
(
exports
!
=
=
null
&
&
(
typeof
exports
=
=
=
'
object
'
|
|
typeof
exports
=
=
=
'
function
'
)
&
&
exports
[
'
default
'
]
=
=
=
undefined
&
&
Object
.
isExtensible
(
exports
)
)
{
exports
[
'
default
'
]
=
exports
;
}
}
;
Module
.
prototype
.
exports
=
function
(
)
{
if
(
this
.
state
=
=
=
'
finalized
'
|
|
this
.
state
=
=
=
'
reifying
'
)
{
return
this
.
module
.
exports
;
}
if
(
loader
.
wrapModules
)
{
this
.
callback
=
loader
.
wrapModules
(
this
.
name
this
.
callback
)
;
}
this
.
reify
(
)
;
var
result
=
this
.
callback
.
apply
(
this
this
.
reified
)
;
this
.
state
=
'
finalized
'
;
if
(
!
(
this
.
hasExportsAsDep
&
&
result
=
=
=
undefined
)
)
{
this
.
module
.
exports
=
result
;
}
this
.
makeDefaultExport
(
)
;
return
this
.
module
.
exports
;
}
;
Module
.
prototype
.
unsee
=
function
(
)
{
this
.
state
=
'
new
'
;
this
.
module
=
{
exports
:
{
}
}
;
}
;
Module
.
prototype
.
reify
=
function
(
)
{
if
(
this
.
state
=
=
=
'
reified
'
)
{
return
;
}
this
.
state
=
'
reifying
'
;
try
{
this
.
reified
=
this
.
_reify
(
)
;
this
.
state
=
'
reified
'
;
}
finally
{
if
(
this
.
state
=
=
=
'
reifying
'
)
{
this
.
state
=
'
errored
'
;
}
}
}
;
Module
.
prototype
.
_reify
=
function
(
)
{
var
reified
=
this
.
reified
.
slice
(
)
;
for
(
var
i
=
0
;
i
<
reified
.
length
;
i
+
+
)
{
var
mod
=
reified
[
i
]
;
reified
[
i
]
=
mod
.
exports
?
mod
.
exports
:
mod
.
module
.
exports
(
)
;
}
return
reified
;
}
;
Module
.
prototype
.
findDeps
=
function
(
pending
)
{
if
(
this
.
state
!
=
=
'
new
'
)
{
return
;
}
this
.
state
=
'
pending
'
;
var
deps
=
this
.
deps
;
for
(
var
i
=
0
;
i
<
deps
.
length
;
i
+
+
)
{
var
dep
=
deps
[
i
]
;
var
entry
=
this
.
reified
[
i
]
=
{
exports
:
undefined
module
:
undefined
}
;
if
(
dep
=
=
=
'
exports
'
)
{
this
.
hasExportsAsDep
=
true
;
entry
.
exports
=
this
.
module
.
exports
;
}
else
if
(
dep
=
=
=
'
require
'
)
{
entry
.
exports
=
this
.
makeRequire
(
)
;
}
else
if
(
dep
=
=
=
'
module
'
)
{
entry
.
exports
=
this
.
module
;
}
else
{
entry
.
module
=
findModule
(
resolve
(
dep
this
.
name
)
this
.
name
pending
)
;
}
}
}
;
Module
.
prototype
.
makeRequire
=
function
(
)
{
var
name
=
this
.
name
;
var
r
=
function
(
dep
)
{
return
require
(
resolve
(
dep
name
)
)
;
}
;
r
[
'
default
'
]
=
r
;
r
.
has
=
function
(
dep
)
{
return
has
(
resolve
(
dep
name
)
)
;
}
;
return
r
;
}
;
define
=
function
(
name
deps
callback
)
{
var
module
=
registry
[
name
]
;
if
(
module
&
&
module
.
state
!
=
=
'
new
'
)
{
return
;
}
if
(
arguments
.
length
<
2
)
{
unsupportedModule
(
arguments
.
length
)
;
}
if
(
!
_isArray
(
deps
)
)
{
callback
=
deps
;
deps
=
[
]
;
}
if
(
callback
instanceof
Alias
)
{
registry
[
name
]
=
new
Module
(
callback
.
name
deps
callback
true
)
;
}
else
{
registry
[
name
]
=
new
Module
(
name
deps
callback
false
)
;
}
}
;
function
Alias
(
path
)
{
this
.
name
=
path
;
}
define
.
alias
=
function
(
path
target
)
{
if
(
arguments
.
length
=
=
=
2
)
{
return
define
(
target
new
Alias
(
path
)
)
;
}
return
new
Alias
(
path
)
;
}
;
function
missingModule
(
name
referrer
)
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
+
'
imported
from
'
+
referrer
+
'
'
)
;
}
function
findModule
(
name
referrer
pending
)
{
var
mod
=
registry
[
name
]
|
|
registry
[
name
+
'
/
index
'
]
;
while
(
mod
&
&
mod
.
isAlias
)
{
mod
=
registry
[
mod
.
name
]
;
}
if
(
!
mod
)
{
missingModule
(
name
referrer
)
;
}
if
(
pending
&
&
mod
.
state
!
=
=
'
pending
'
&
&
mod
.
state
!
=
=
'
finalized
'
)
{
mod
.
findDeps
(
pending
)
;
pending
.
push
(
mod
)
;
}
return
mod
;
}
function
resolve
(
child
name
)
{
if
(
child
.
charAt
(
0
)
!
=
=
'
.
'
)
{
return
child
;
}
var
parts
=
child
.
split
(
'
/
'
)
;
var
nameParts
=
name
.
split
(
'
/
'
)
;
var
parentBase
=
nameParts
.
slice
(
0
-
1
)
;
for
(
var
i
=
0
l
=
parts
.
length
;
i
<
l
;
i
+
+
)
{
var
part
=
parts
[
i
]
;
if
(
part
=
=
=
'
.
.
'
)
{
if
(
parentBase
.
length
=
=
=
0
)
{
throw
new
Error
(
'
Cannot
access
parent
module
of
root
'
)
;
}
parentBase
.
pop
(
)
;
}
else
if
(
part
=
=
=
'
.
'
)
{
continue
;
}
else
{
parentBase
.
push
(
part
)
;
}
}
return
parentBase
.
join
(
'
/
'
)
;
}
function
has
(
name
)
{
return
!
!
(
registry
[
name
]
|
|
registry
[
name
+
'
/
index
'
]
)
;
}
requirejs
.
entries
=
requirejs
.
_eak_seen
=
registry
;
requirejs
.
has
=
has
;
requirejs
.
unsee
=
function
(
moduleName
)
{
findModule
(
moduleName
'
(
unsee
)
'
false
)
.
unsee
(
)
;
}
;
requirejs
.
clear
=
function
(
)
{
requirejs
.
entries
=
requirejs
.
_eak_seen
=
registry
=
dict
(
)
;
seen
=
dict
(
)
;
}
;
define
(
'
foo
'
function
(
)
{
}
)
;
define
(
'
foo
/
bar
'
[
]
function
(
)
{
}
)
;
define
(
'
foo
/
asdf
'
[
'
module
'
'
exports
'
'
require
'
]
function
(
module
exports
require
)
{
if
(
require
.
has
(
'
foo
/
bar
'
)
)
{
require
(
'
foo
/
bar
'
)
;
}
}
)
;
define
(
'
foo
/
baz
'
[
]
define
.
alias
(
'
foo
'
)
)
;
define
(
'
foo
/
quz
'
define
.
alias
(
'
foo
'
)
)
;
define
.
alias
(
'
foo
'
'
foo
/
qux
'
)
;
define
(
'
foo
/
bar
'
[
'
foo
'
'
.
/
quz
'
'
.
/
baz
'
'
.
/
asdf
'
'
.
/
bar
'
'
.
.
/
foo
'
]
function
(
)
{
}
)
;
define
(
'
foo
/
main
'
[
'
foo
/
bar
'
]
function
(
)
{
}
)
;
require
(
'
foo
/
main
'
)
;
require
.
unsee
(
'
foo
/
bar
'
)
;
requirejs
.
clear
(
)
;
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
&
&
module
.
exports
)
{
module
.
exports
=
{
require
:
require
define
:
define
}
;
}
}
)
(
this
)
;
;
(
function
(
global
factory
)
{
if
(
typeof
module
=
=
=
"
object
"
&
&
typeof
module
.
exports
=
=
=
"
object
"
)
{
module
.
exports
=
global
.
document
?
factory
(
global
true
)
:
function
(
w
)
{
if
(
!
w
.
document
)
{
throw
new
Error
(
"
jQuery
requires
a
window
with
a
document
"
)
;
}
return
factory
(
w
)
;
}
;
}
else
{
factory
(
global
)
;
}
}
(
typeof
window
!
=
=
"
undefined
"
?
window
:
this
function
(
window
noGlobal
)
{
var
arr
=
[
]
;
var
document
=
window
.
document
;
var
slice
=
arr
.
slice
;
var
concat
=
arr
.
concat
;
var
push
=
arr
.
push
;
var
indexOf
=
arr
.
indexOf
;
var
class2type
=
{
}
;
var
toString
=
class2type
.
toString
;
var
hasOwn
=
class2type
.
hasOwnProperty
;
var
support
=
{
}
;
var
version
=
"
2
.
2
.
4
"
jQuery
=
function
(
selector
context
)
{
return
new
jQuery
.
fn
.
init
(
selector
context
)
;
}
rtrim
=
/
^
[
\
s
\
uFEFF
\
xA0
]
+
|
[
\
s
\
uFEFF
\
xA0
]
+
/
g
rmsPrefix
=
/
^
-
ms
-
/
rdashAlpha
=
/
-
(
[
\
da
-
z
]
)
/
gi
fcamelCase
=
function
(
all
letter
)
{
return
letter
.
toUpperCase
(
)
;
}
;
jQuery
.
fn
=
jQuery
.
prototype
=
{
jquery
:
version
constructor
:
jQuery
selector
:
"
"
length
:
0
toArray
:
function
(
)
{
return
slice
.
call
(
this
)
;
}
get
:
function
(
num
)
{
return
num
!
=
null
?
(
num
<
0
?
this
[
num
+
this
.
length
]
:
this
[
num
]
)
:
slice
.
call
(
this
)
;
}
pushStack
:
function
(
elems
)
{
var
ret
=
jQuery
.
merge
(
this
.
constructor
(
)
elems
)
;
ret
.
prevObject
=
this
;
ret
.
context
=
this
.
context
;
return
ret
;
}
each
:
function
(
callback
)
{
return
jQuery
.
each
(
this
callback
)
;
}
map
:
function
(
callback
)
{
return
this
.
pushStack
(
jQuery
.
map
(
this
function
(
elem
i
)
{
return
callback
.
call
(
elem
i
elem
)
;
}
)
)
;
}
slice
:
function
(
)
{
return
this
.
pushStack
(
slice
.
apply
(
this
arguments
)
)
;
}
first
:
function
(
)
{
return
this
.
eq
(
0
)
;
}
last
:
function
(
)
{
return
this
.
eq
(
-
1
)
;
}
eq
:
function
(
i
)
{
var
len
=
this
.
length
j
=
+
i
+
(
i
<
0
?
len
:
0
)
;
return
this
.
pushStack
(
j
>
=
0
&
&
j
<
len
?
[
this
[
j
]
]
:
[
]
)
;
}
end
:
function
(
)
{
return
this
.
prevObject
|
|
this
.
constructor
(
)
;
}
push
:
push
sort
:
arr
.
sort
splice
:
arr
.
splice
}
;
jQuery
.
extend
=
jQuery
.
fn
.
extend
=
function
(
)
{
var
options
name
src
copy
copyIsArray
clone
target
=
arguments
[
0
]
|
|
{
}
i
=
1
length
=
arguments
.
length
deep
=
false
;
if
(
typeof
target
=
=
=
"
boolean
"
)
{
deep
=
target
;
target
=
arguments
[
i
]
|
|
{
}
;
i
+
+
;
}
if
(
typeof
target
!
=
=
"
object
"
&
&
!
jQuery
.
isFunction
(
target
)
)
{
target
=
{
}
;
}
if
(
i
=
=
=
length
)
{
target
=
this
;
i
-
-
;
}
for
(
;
i
<
length
;
i
+
+
)
{
if
(
(
options
=
arguments
[
i
]
)
!
=
null
)
{
for
(
name
in
options
)
{
src
=
target
[
name
]
;
copy
=
options
[
name
]
;
if
(
target
=
=
=
copy
)
{
continue
;
}
if
(
deep
&
&
copy
&
&
(
jQuery
.
isPlainObject
(
copy
)
|
|
(
copyIsArray
=
jQuery
.
isArray
(
copy
)
)
)
)
{
if
(
copyIsArray
)
{
copyIsArray
=
false
;
clone
=
src
&
&
jQuery
.
isArray
(
src
)
?
src
:
[
]
;
}
else
{
clone
=
src
&
&
jQuery
.
isPlainObject
(
src
)
?
src
:
{
}
;
}
target
[
name
]
=
jQuery
.
extend
(
deep
clone
copy
)
;
}
else
if
(
copy
!
=
=
undefined
)
{
target
[
name
]
=
copy
;
}
}
}
}
return
target
;
}
;
jQuery
.
extend
(
{
expando
:
"
jQuery
"
+
(
version
+
Math
.
random
(
)
)
.
replace
(
/
\
D
/
g
"
"
)
isReady
:
true
error
:
function
(
msg
)
{
throw
new
Error
(
msg
)
;
}
noop
:
function
(
)
{
}
isFunction
:
function
(
obj
)
{
return
jQuery
.
type
(
obj
)
=
=
=
"
function
"
;
}
isArray
:
Array
.
isArray
isWindow
:
function
(
obj
)
{
return
obj
!
=
null
&
&
obj
=
=
=
obj
.
window
;
}
isNumeric
:
function
(
obj
)
{
var
realStringObj
=
obj
&
&
obj
.
toString
(
)
;
return
!
jQuery
.
isArray
(
obj
)
&
&
(
realStringObj
-
parseFloat
(
realStringObj
)
+
1
)
>
=
0
;
}
isPlainObject
:
function
(
obj
)
{
var
key
;
if
(
jQuery
.
type
(
obj
)
!
=
=
"
object
"
|
|
obj
.
nodeType
|
|
jQuery
.
isWindow
(
obj
)
)
{
return
false
;
}
if
(
obj
.
constructor
&
&
!
hasOwn
.
call
(
obj
"
constructor
"
)
&
&
!
hasOwn
.
call
(
obj
.
constructor
.
prototype
|
|
{
}
"
isPrototypeOf
"
)
)
{
return
false
;
}
for
(
key
in
obj
)
{
}
return
key
=
=
=
undefined
|
|
hasOwn
.
call
(
obj
key
)
;
}
isEmptyObject
:
function
(
obj
)
{
var
name
;
for
(
name
in
obj
)
{
return
false
;
}
return
true
;
}
type
:
function
(
obj
)
{
if
(
obj
=
=
null
)
{
return
obj
+
"
"
;
}
return
typeof
obj
=
=
=
"
object
"
|
|
typeof
obj
=
=
=
"
function
"
?
class2type
[
toString
.
call
(
obj
)
]
|
|
"
object
"
:
typeof
obj
;
}
globalEval
:
function
(
code
)
{
var
script
indirect
=
eval
;
code
=
jQuery
.
trim
(
code
)
;
if
(
code
)
{
if
(
code
.
indexOf
(
"
use
strict
"
)
=
=
=
1
)
{
script
=
document
.
createElement
(
"
script
"
)
;
script
.
text
=
code
;
document
.
head
.
appendChild
(
script
)
.
parentNode
.
removeChild
(
script
)
;
}
else
{
indirect
(
code
)
;
}
}
}
camelCase
:
function
(
string
)
{
return
string
.
replace
(
rmsPrefix
"
ms
-
"
)
.
replace
(
rdashAlpha
fcamelCase
)
;
}
nodeName
:
function
(
elem
name
)
{
return
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
name
.
toLowerCase
(
)
;
}
each
:
function
(
obj
callback
)
{
var
length
i
=
0
;
if
(
isArrayLike
(
obj
)
)
{
length
=
obj
.
length
;
for
(
;
i
<
length
;
i
+
+
)
{
if
(
callback
.
call
(
obj
[
i
]
i
obj
[
i
]
)
=
=
=
false
)
{
break
;
}
}
}
else
{
for
(
i
in
obj
)
{
if
(
callback
.
call
(
obj
[
i
]
i
obj
[
i
]
)
=
=
=
false
)
{
break
;
}
}
}
return
obj
;
}
trim
:
function
(
text
)
{
return
text
=
=
null
?
"
"
:
(
text
+
"
"
)
.
replace
(
rtrim
"
"
)
;
}
makeArray
:
function
(
arr
results
)
{
var
ret
=
results
|
|
[
]
;
if
(
arr
!
=
null
)
{
if
(
isArrayLike
(
Object
(
arr
)
)
)
{
jQuery
.
merge
(
ret
typeof
arr
=
=
=
"
string
"
?
[
arr
]
:
arr
)
;
}
else
{
push
.
call
(
ret
arr
)
;
}
}
return
ret
;
}
inArray
:
function
(
elem
arr
i
)
{
return
arr
=
=
null
?
-
1
:
indexOf
.
call
(
arr
elem
i
)
;
}
merge
:
function
(
first
second
)
{
var
len
=
+
second
.
length
j
=
0
i
=
first
.
length
;
for
(
;
j
<
len
;
j
+
+
)
{
first
[
i
+
+
]
=
second
[
j
]
;
}
first
.
length
=
i
;
return
first
;
}
grep
:
function
(
elems
callback
invert
)
{
var
callbackInverse
matches
=
[
]
i
=
0
length
=
elems
.
length
callbackExpect
=
!
invert
;
for
(
;
i
<
length
;
i
+
+
)
{
callbackInverse
=
!
callback
(
elems
[
i
]
i
)
;
if
(
callbackInverse
!
=
=
callbackExpect
)
{
matches
.
push
(
elems
[
i
]
)
;
}
}
return
matches
;
}
map
:
function
(
elems
callback
arg
)
{
var
length
value
i
=
0
ret
=
[
]
;
if
(
isArrayLike
(
elems
)
)
{
length
=
elems
.
length
;
for
(
;
i
<
length
;
i
+
+
)
{
value
=
callback
(
elems
[
i
]
i
arg
)
;
if
(
value
!
=
null
)
{
ret
.
push
(
value
)
;
}
}
}
else
{
for
(
i
in
elems
)
{
value
=
callback
(
elems
[
i
]
i
arg
)
;
if
(
value
!
=
null
)
{
ret
.
push
(
value
)
;
}
}
}
return
concat
.
apply
(
[
]
ret
)
;
}
guid
:
1
proxy
:
function
(
fn
context
)
{
var
tmp
args
proxy
;
if
(
typeof
context
=
=
=
"
string
"
)
{
tmp
=
fn
[
context
]
;
context
=
fn
;
fn
=
tmp
;
}
if
(
!
jQuery
.
isFunction
(
fn
)
)
{
return
undefined
;
}
args
=
slice
.
call
(
arguments
2
)
;
proxy
=
function
(
)
{
return
fn
.
apply
(
context
|
|
this
args
.
concat
(
slice
.
call
(
arguments
)
)
)
;
}
;
proxy
.
guid
=
fn
.
guid
=
fn
.
guid
|
|
jQuery
.
guid
+
+
;
return
proxy
;
}
now
:
Date
.
now
support
:
support
}
)
;
if
(
typeof
Symbol
=
=
=
"
function
"
)
{
jQuery
.
fn
[
Symbol
.
iterator
]
=
arr
[
Symbol
.
iterator
]
;
}
jQuery
.
each
(
"
Boolean
Number
String
Function
Array
Date
RegExp
Object
Error
Symbol
"
.
split
(
"
"
)
function
(
i
name
)
{
class2type
[
"
[
object
"
+
name
+
"
]
"
]
=
name
.
toLowerCase
(
)
;
}
)
;
function
isArrayLike
(
obj
)
{
var
length
=
!
!
obj
&
&
"
length
"
in
obj
&
&
obj
.
length
type
=
jQuery
.
type
(
obj
)
;
if
(
type
=
=
=
"
function
"
|
|
jQuery
.
isWindow
(
obj
)
)
{
return
false
;
}
return
type
=
=
=
"
array
"
|
|
length
=
=
=
0
|
|
typeof
length
=
=
=
"
number
"
&
&
length
>
0
&
&
(
length
-
1
)
in
obj
;
}
var
Sizzle
=
(
function
(
window
)
{
var
i
support
Expr
getText
isXML
tokenize
compile
select
outermostContext
sortInput
hasDuplicate
setDocument
document
docElem
documentIsHTML
rbuggyQSA
rbuggyMatches
matches
contains
expando
=
"
sizzle
"
+
1
*
new
Date
(
)
preferredDoc
=
window
.
document
dirruns
=
0
done
=
0
classCache
=
createCache
(
)
tokenCache
=
createCache
(
)
compilerCache
=
createCache
(
)
sortOrder
=
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
hasDuplicate
=
true
;
}
return
0
;
}
MAX_NEGATIVE
=
1
<
<
31
hasOwn
=
(
{
}
)
.
hasOwnProperty
arr
=
[
]
pop
=
arr
.
pop
push_native
=
arr
.
push
push
=
arr
.
push
slice
=
arr
.
slice
indexOf
=
function
(
list
elem
)
{
var
i
=
0
len
=
list
.
length
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
list
[
i
]
=
=
=
elem
)
{
return
i
;
}
}
return
-
1
;
}
booleans
=
"
checked
|
selected
|
async
|
autofocus
|
autoplay
|
controls
|
defer
|
disabled
|
hidden
|
ismap
|
loop
|
multiple
|
open
|
readonly
|
required
|
scoped
"
whitespace
=
"
[
\
\
x20
\
\
t
\
\
r
\
\
n
\
\
f
]
"
identifier
=
"
(
?
:
\
\
\
\
.
|
[
\
\
w
-
]
|
[
^
\
\
x00
-
\
\
xa0
]
)
+
"
attributes
=
"
\
\
[
"
+
whitespace
+
"
*
(
"
+
identifier
+
"
)
(
?
:
"
+
whitespace
+
"
*
(
[
*
^
|
!
~
]
?
=
)
"
+
whitespace
+
"
*
(
?
:
'
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
'
]
)
*
)
'
|
\
"
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
\
"
]
)
*
)
\
"
|
(
"
+
identifier
+
"
)
)
|
)
"
+
whitespace
+
"
*
\
\
]
"
pseudos
=
"
:
(
"
+
identifier
+
"
)
(
?
:
\
\
(
(
"
+
"
(
'
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
'
]
)
*
)
'
|
\
"
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
\
"
]
)
*
)
\
"
)
|
"
+
"
(
(
?
:
\
\
\
\
.
|
[
^
\
\
\
\
(
)
[
\
\
]
]
|
"
+
attributes
+
"
)
*
)
|
"
+
"
.
*
"
+
"
)
\
\
)
|
)
"
rwhitespace
=
new
RegExp
(
whitespace
+
"
+
"
"
g
"
)
rtrim
=
new
RegExp
(
"
^
"
+
whitespace
+
"
+
|
(
(
?
:
^
|
[
^
\
\
\
\
]
)
(
?
:
\
\
\
\
.
)
*
)
"
+
whitespace
+
"
+
"
"
g
"
)
rcomma
=
new
RegExp
(
"
^
"
+
whitespace
+
"
*
"
+
whitespace
+
"
*
"
)
rcombinators
=
new
RegExp
(
"
^
"
+
whitespace
+
"
*
(
[
>
+
~
]
|
"
+
whitespace
+
"
)
"
+
whitespace
+
"
*
"
)
rattributeQuotes
=
new
RegExp
(
"
=
"
+
whitespace
+
"
*
(
[
^
\
\
]
'
\
"
]
*
?
)
"
+
whitespace
+
"
*
\
\
]
"
"
g
"
)
rpseudo
=
new
RegExp
(
pseudos
)
ridentifier
=
new
RegExp
(
"
^
"
+
identifier
+
"
"
)
matchExpr
=
{
"
ID
"
:
new
RegExp
(
"
^
#
(
"
+
identifier
+
"
)
"
)
"
CLASS
"
:
new
RegExp
(
"
^
\
\
.
(
"
+
identifier
+
"
)
"
)
"
TAG
"
:
new
RegExp
(
"
^
(
"
+
identifier
+
"
|
[
*
]
)
"
)
"
ATTR
"
:
new
RegExp
(
"
^
"
+
attributes
)
"
PSEUDO
"
:
new
RegExp
(
"
^
"
+
pseudos
)
"
CHILD
"
:
new
RegExp
(
"
^
:
(
only
|
first
|
last
|
nth
|
nth
-
last
)
-
(
child
|
of
-
type
)
(
?
:
\
\
(
"
+
whitespace
+
"
*
(
even
|
odd
|
(
(
[
+
-
]
|
)
(
\
\
d
*
)
n
|
)
"
+
whitespace
+
"
*
(
?
:
(
[
+
-
]
|
)
"
+
whitespace
+
"
*
(
\
\
d
+
)
|
)
)
"
+
whitespace
+
"
*
\
\
)
|
)
"
"
i
"
)
"
bool
"
:
new
RegExp
(
"
^
(
?
:
"
+
booleans
+
"
)
"
"
i
"
)
"
needsContext
"
:
new
RegExp
(
"
^
"
+
whitespace
+
"
*
[
>
+
~
]
|
:
(
even
|
odd
|
eq
|
gt
|
lt
|
nth
|
first
|
last
)
(
?
:
\
\
(
"
+
whitespace
+
"
*
(
(
?
:
-
\
\
d
)
?
\
\
d
*
)
"
+
whitespace
+
"
*
\
\
)
|
)
(
?
=
[
^
-
]
|
)
"
"
i
"
)
}
rinputs
=
/
^
(
?
:
input
|
select
|
textarea
|
button
)
/
i
rheader
=
/
^
h
\
d
/
i
rnative
=
/
^
[
^
{
]
+
\
{
\
s
*
\
[
native
\
w
/
rquickExpr
=
/
^
(
?
:
#
(
[
\
w
-
]
+
)
|
(
\
w
+
)
|
\
.
(
[
\
w
-
]
+
)
)
/
rsibling
=
/
[
+
~
]
/
rescape
=
/
'
|
\
\
/
g
runescape
=
new
RegExp
(
"
\
\
\
\
(
[
\
\
da
-
f
]
{
1
6
}
"
+
whitespace
+
"
?
|
(
"
+
whitespace
+
"
)
|
.
)
"
"
ig
"
)
funescape
=
function
(
_
escaped
escapedWhitespace
)
{
var
high
=
"
0x
"
+
escaped
-
0x10000
;
return
high
!
=
=
high
|
|
escapedWhitespace
?
escaped
:
high
<
0
?
String
.
fromCharCode
(
high
+
0x10000
)
:
String
.
fromCharCode
(
high
>
>
10
|
0xD800
high
&
0x3FF
|
0xDC00
)
;
}
unloadHandler
=
function
(
)
{
setDocument
(
)
;
}
;
try
{
push
.
apply
(
(
arr
=
slice
.
call
(
preferredDoc
.
childNodes
)
)
preferredDoc
.
childNodes
)
;
arr
[
preferredDoc
.
childNodes
.
length
]
.
nodeType
;
}
catch
(
e
)
{
push
=
{
apply
:
arr
.
length
?
function
(
target
els
)
{
push_native
.
apply
(
target
slice
.
call
(
els
)
)
;
}
:
function
(
target
els
)
{
var
j
=
target
.
length
i
=
0
;
while
(
(
target
[
j
+
+
]
=
els
[
i
+
+
]
)
)
{
}
target
.
length
=
j
-
1
;
}
}
;
}
function
Sizzle
(
selector
context
results
seed
)
{
var
m
i
elem
nid
nidselect
match
groups
newSelector
newContext
=
context
&
&
context
.
ownerDocument
nodeType
=
context
?
context
.
nodeType
:
9
;
results
=
results
|
|
[
]
;
if
(
typeof
selector
!
=
=
"
string
"
|
|
!
selector
|
|
nodeType
!
=
=
1
&
&
nodeType
!
=
=
9
&
&
nodeType
!
=
=
11
)
{
return
results
;
}
if
(
!
seed
)
{
if
(
(
context
?
context
.
ownerDocument
|
|
context
:
preferredDoc
)
!
=
=
document
)
{
setDocument
(
context
)
;
}
context
=
context
|
|
document
;
if
(
documentIsHTML
)
{
if
(
nodeType
!
=
=
11
&
&
(
match
=
rquickExpr
.
exec
(
selector
)
)
)
{
if
(
(
m
=
match
[
1
]
)
)
{
if
(
nodeType
=
=
=
9
)
{
if
(
(
elem
=
context
.
getElementById
(
m
)
)
)
{
if
(
elem
.
id
=
=
=
m
)
{
results
.
push
(
elem
)
;
return
results
;
}
}
else
{
return
results
;
}
}
else
{
if
(
newContext
&
&
(
elem
=
newContext
.
getElementById
(
m
)
)
&
&
contains
(
context
elem
)
&
&
elem
.
id
=
=
=
m
)
{
results
.
push
(
elem
)
;
return
results
;
}
}
}
else
if
(
match
[
2
]
)
{
push
.
apply
(
results
context
.
getElementsByTagName
(
selector
)
)
;
return
results
;
}
else
if
(
(
m
=
match
[
3
]
)
&
&
support
.
getElementsByClassName
&
&
context
.
getElementsByClassName
)
{
push
.
apply
(
results
context
.
getElementsByClassName
(
m
)
)
;
return
results
;
}
}
if
(
support
.
qsa
&
&
!
compilerCache
[
selector
+
"
"
]
&
&
(
!
rbuggyQSA
|
|
!
rbuggyQSA
.
test
(
selector
)
)
)
{
if
(
nodeType
!
=
=
1
)
{
newContext
=
context
;
newSelector
=
selector
;
}
else
if
(
context
.
nodeName
.
toLowerCase
(
)
!
=
=
"
object
"
)
{
if
(
(
nid
=
context
.
getAttribute
(
"
id
"
)
)
)
{
nid
=
nid
.
replace
(
rescape
"
\
\
&
"
)
;
}
else
{
context
.
setAttribute
(
"
id
"
(
nid
=
expando
)
)
;
}
groups
=
tokenize
(
selector
)
;
i
=
groups
.
length
;
nidselect
=
ridentifier
.
test
(
nid
)
?
"
#
"
+
nid
:
"
[
id
=
'
"
+
nid
+
"
'
]
"
;
while
(
i
-
-
)
{
groups
[
i
]
=
nidselect
+
"
"
+
toSelector
(
groups
[
i
]
)
;
}
newSelector
=
groups
.
join
(
"
"
)
;
newContext
=
rsibling
.
test
(
selector
)
&
&
testContext
(
context
.
parentNode
)
|
|
context
;
}
if
(
newSelector
)
{
try
{
push
.
apply
(
results
newContext
.
querySelectorAll
(
newSelector
)
)
;
return
results
;
}
catch
(
qsaError
)
{
}
finally
{
if
(
nid
=
=
=
expando
)
{
context
.
removeAttribute
(
"
id
"
)
;
}
}
}
}
}
}
return
select
(
selector
.
replace
(
rtrim
"
1
"
)
context
results
seed
)
;
}
function
createCache
(
)
{
var
keys
=
[
]
;
function
cache
(
key
value
)
{
if
(
keys
.
push
(
key
+
"
"
)
>
Expr
.
cacheLength
)
{
delete
cache
[
keys
.
shift
(
)
]
;
}
return
(
cache
[
key
+
"
"
]
=
value
)
;
}
return
cache
;
}
function
markFunction
(
fn
)
{
fn
[
expando
]
=
true
;
return
fn
;
}
function
assert
(
fn
)
{
var
div
=
document
.
createElement
(
"
div
"
)
;
try
{
return
!
!
fn
(
div
)
;
}
catch
(
e
)
{
return
false
;
}
finally
{
if
(
div
.
parentNode
)
{
div
.
parentNode
.
removeChild
(
div
)
;
}
div
=
null
;
}
}
function
addHandle
(
attrs
handler
)
{
var
arr
=
attrs
.
split
(
"
|
"
)
i
=
arr
.
length
;
while
(
i
-
-
)
{
Expr
.
attrHandle
[
arr
[
i
]
]
=
handler
;
}
}
function
siblingCheck
(
a
b
)
{
var
cur
=
b
&
&
a
diff
=
cur
&
&
a
.
nodeType
=
=
=
1
&
&
b
.
nodeType
=
=
=
1
&
&
(
~
b
.
sourceIndex
|
|
MAX_NEGATIVE
)
-
(
~
a
.
sourceIndex
|
|
MAX_NEGATIVE
)
;
if
(
diff
)
{
return
diff
;
}
if
(
cur
)
{
while
(
(
cur
=
cur
.
nextSibling
)
)
{
if
(
cur
=
=
=
b
)
{
return
-
1
;
}
}
}
return
a
?
1
:
-
1
;
}
function
createInputPseudo
(
type
)
{
return
function
(
elem
)
{
var
name
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
&
&
elem
.
type
=
=
=
type
;
}
;
}
function
createButtonPseudo
(
type
)
{
return
function
(
elem
)
{
var
name
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
(
name
=
=
=
"
input
"
|
|
name
=
=
=
"
button
"
)
&
&
elem
.
type
=
=
=
type
;
}
;
}
function
createPositionalPseudo
(
fn
)
{
return
markFunction
(
function
(
argument
)
{
argument
=
+
argument
;
return
markFunction
(
function
(
seed
matches
)
{
var
j
matchIndexes
=
fn
(
[
]
seed
.
length
argument
)
i
=
matchIndexes
.
length
;
while
(
i
-
-
)
{
if
(
seed
[
(
j
=
matchIndexes
[
i
]
)
]
)
{
seed
[
j
]
=
!
(
matches
[
j
]
=
seed
[
j
]
)
;
}
}
}
)
;
}
)
;
}
function
testContext
(
context
)
{
return
context
&
&
typeof
context
.
getElementsByTagName
!
=
=
"
undefined
"
&
&
context
;
}
support
=
Sizzle
.
support
=
{
}
;
isXML
=
Sizzle
.
isXML
=
function
(
elem
)
{
var
documentElement
=
elem
&
&
(
elem
.
ownerDocument
|
|
elem
)
.
documentElement
;
return
documentElement
?
documentElement
.
nodeName
!
=
=
"
HTML
"
:
false
;
}
;
setDocument
=
Sizzle
.
setDocument
=
function
(
node
)
{
var
hasCompare
parent
doc
=
node
?
node
.
ownerDocument
|
|
node
:
preferredDoc
;
if
(
doc
=
=
=
document
|
|
doc
.
nodeType
!
=
=
9
|
|
!
doc
.
documentElement
)
{
return
document
;
}
document
=
doc
;
docElem
=
document
.
documentElement
;
documentIsHTML
=
!
isXML
(
document
)
;
if
(
(
parent
=
document
.
defaultView
)
&
&
parent
.
top
!
=
=
parent
)
{
if
(
parent
.
addEventListener
)
{
parent
.
addEventListener
(
"
unload
"
unloadHandler
false
)
;
}
else
if
(
parent
.
attachEvent
)
{
parent
.
attachEvent
(
"
onunload
"
unloadHandler
)
;
}
}
support
.
attributes
=
assert
(
function
(
div
)
{
div
.
className
=
"
i
"
;
return
!
div
.
getAttribute
(
"
className
"
)
;
}
)
;
support
.
getElementsByTagName
=
assert
(
function
(
div
)
{
div
.
appendChild
(
document
.
createComment
(
"
"
)
)
;
return
!
div
.
getElementsByTagName
(
"
*
"
)
.
length
;
}
)
;
support
.
getElementsByClassName
=
rnative
.
test
(
document
.
getElementsByClassName
)
;
support
.
getById
=
assert
(
function
(
div
)
{
docElem
.
appendChild
(
div
)
.
id
=
expando
;
return
!
document
.
getElementsByName
|
|
!
document
.
getElementsByName
(
expando
)
.
length
;
}
)
;
if
(
support
.
getById
)
{
Expr
.
find
[
"
ID
"
]
=
function
(
id
context
)
{
if
(
typeof
context
.
getElementById
!
=
=
"
undefined
"
&
&
documentIsHTML
)
{
var
m
=
context
.
getElementById
(
id
)
;
return
m
?
[
m
]
:
[
]
;
}
}
;
Expr
.
filter
[
"
ID
"
]
=
function
(
id
)
{
var
attrId
=
id
.
replace
(
runescape
funescape
)
;
return
function
(
elem
)
{
return
elem
.
getAttribute
(
"
id
"
)
=
=
=
attrId
;
}
;
}
;
}
else
{
delete
Expr
.
find
[
"
ID
"
]
;
Expr
.
filter
[
"
ID
"
]
=
function
(
id
)
{
var
attrId
=
id
.
replace
(
runescape
funescape
)
;
return
function
(
elem
)
{
var
node
=
typeof
elem
.
getAttributeNode
!
=
=
"
undefined
"
&
&
elem
.
getAttributeNode
(
"
id
"
)
;
return
node
&
&
node
.
value
=
=
=
attrId
;
}
;
}
;
}
Expr
.
find
[
"
TAG
"
]
=
support
.
getElementsByTagName
?
function
(
tag
context
)
{
if
(
typeof
context
.
getElementsByTagName
!
=
=
"
undefined
"
)
{
return
context
.
getElementsByTagName
(
tag
)
;
}
else
if
(
support
.
qsa
)
{
return
context
.
querySelectorAll
(
tag
)
;
}
}
:
function
(
tag
context
)
{
var
elem
tmp
=
[
]
i
=
0
results
=
context
.
getElementsByTagName
(
tag
)
;
if
(
tag
=
=
=
"
*
"
)
{
while
(
(
elem
=
results
[
i
+
+
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
)
{
tmp
.
push
(
elem
)
;
}
}
return
tmp
;
}
return
results
;
}
;
Expr
.
find
[
"
CLASS
"
]
=
support
.
getElementsByClassName
&
&
function
(
className
context
)
{
if
(
typeof
context
.
getElementsByClassName
!
=
=
"
undefined
"
&
&
documentIsHTML
)
{
return
context
.
getElementsByClassName
(
className
)
;
}
}
;
rbuggyMatches
=
[
]
;
rbuggyQSA
=
[
]
;
if
(
(
support
.
qsa
=
rnative
.
test
(
document
.
querySelectorAll
)
)
)
{
assert
(
function
(
div
)
{
docElem
.
appendChild
(
div
)
.
innerHTML
=
"
<
a
id
=
'
"
+
expando
+
"
'
>
<
/
a
>
"
+
"
<
select
id
=
'
"
+
expando
+
"
-
\
r
\
\
'
msallowcapture
=
'
'
>
"
+
"
<
option
selected
=
'
'
>
<
/
option
>
<
/
select
>
"
;
if
(
div
.
querySelectorAll
(
"
[
msallowcapture
^
=
'
'
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
[
*
^
]
=
"
+
whitespace
+
"
*
(
?
:
'
'
|
\
"
\
"
)
"
)
;
}
if
(
!
div
.
querySelectorAll
(
"
[
selected
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
\
\
[
"
+
whitespace
+
"
*
(
?
:
value
|
"
+
booleans
+
"
)
"
)
;
}
if
(
!
div
.
querySelectorAll
(
"
[
id
~
=
"
+
expando
+
"
-
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
~
=
"
)
;
}
if
(
!
div
.
querySelectorAll
(
"
:
checked
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
:
checked
"
)
;
}
if
(
!
div
.
querySelectorAll
(
"
a
#
"
+
expando
+
"
+
*
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
.
#
.
+
[
+
~
]
"
)
;
}
}
)
;
assert
(
function
(
div
)
{
var
input
=
document
.
createElement
(
"
input
"
)
;
input
.
setAttribute
(
"
type
"
"
hidden
"
)
;
div
.
appendChild
(
input
)
.
setAttribute
(
"
name
"
"
D
"
)
;
if
(
div
.
querySelectorAll
(
"
[
name
=
d
]
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
name
"
+
whitespace
+
"
*
[
*
^
|
!
~
]
?
=
"
)
;
}
if
(
!
div
.
querySelectorAll
(
"
:
enabled
"
)
.
length
)
{
rbuggyQSA
.
push
(
"
:
enabled
"
"
:
disabled
"
)
;
}
div
.
querySelectorAll
(
"
*
:
x
"
)
;
rbuggyQSA
.
push
(
"
.
*
:
"
)
;
}
)
;
}
if
(
(
support
.
matchesSelector
=
rnative
.
test
(
(
matches
=
docElem
.
matches
|
|
docElem
.
webkitMatchesSelector
|
|
docElem
.
mozMatchesSelector
|
|
docElem
.
oMatchesSelector
|
|
docElem
.
msMatchesSelector
)
)
)
)
{
assert
(
function
(
div
)
{
support
.
disconnectedMatch
=
matches
.
call
(
div
"
div
"
)
;
matches
.
call
(
div
"
[
s
!
=
'
'
]
:
x
"
)
;
rbuggyMatches
.
push
(
"
!
=
"
pseudos
)
;
}
)
;
}
rbuggyQSA
=
rbuggyQSA
.
length
&
&
new
RegExp
(
rbuggyQSA
.
join
(
"
|
"
)
)
;
rbuggyMatches
=
rbuggyMatches
.
length
&
&
new
RegExp
(
rbuggyMatches
.
join
(
"
|
"
)
)
;
hasCompare
=
rnative
.
test
(
docElem
.
compareDocumentPosition
)
;
contains
=
hasCompare
|
|
rnative
.
test
(
docElem
.
contains
)
?
function
(
a
b
)
{
var
adown
=
a
.
nodeType
=
=
=
9
?
a
.
documentElement
:
a
bup
=
b
&
&
b
.
parentNode
;
return
a
=
=
=
bup
|
|
!
!
(
bup
&
&
bup
.
nodeType
=
=
=
1
&
&
(
adown
.
contains
?
adown
.
contains
(
bup
)
:
a
.
compareDocumentPosition
&
&
a
.
compareDocumentPosition
(
bup
)
&
16
)
)
;
}
:
function
(
a
b
)
{
if
(
b
)
{
while
(
(
b
=
b
.
parentNode
)
)
{
if
(
b
=
=
=
a
)
{
return
true
;
}
}
}
return
false
;
}
;
sortOrder
=
hasCompare
?
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
hasDuplicate
=
true
;
return
0
;
}
var
compare
=
!
a
.
compareDocumentPosition
-
!
b
.
compareDocumentPosition
;
if
(
compare
)
{
return
compare
;
}
compare
=
(
a
.
ownerDocument
|
|
a
)
=
=
=
(
b
.
ownerDocument
|
|
b
)
?
a
.
compareDocumentPosition
(
b
)
:
1
;
if
(
compare
&
1
|
|
(
!
support
.
sortDetached
&
&
b
.
compareDocumentPosition
(
a
)
=
=
=
compare
)
)
{
if
(
a
=
=
=
document
|
|
a
.
ownerDocument
=
=
=
preferredDoc
&
&
contains
(
preferredDoc
a
)
)
{
return
-
1
;
}
if
(
b
=
=
=
document
|
|
b
.
ownerDocument
=
=
=
preferredDoc
&
&
contains
(
preferredDoc
b
)
)
{
return
1
;
}
return
sortInput
?
(
indexOf
(
sortInput
a
)
-
indexOf
(
sortInput
b
)
)
:
0
;
}
return
compare
&
4
?
-
1
:
1
;
}
:
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
hasDuplicate
=
true
;
return
0
;
}
var
cur
i
=
0
aup
=
a
.
parentNode
bup
=
b
.
parentNode
ap
=
[
a
]
bp
=
[
b
]
;
if
(
!
aup
|
|
!
bup
)
{
return
a
=
=
=
document
?
-
1
:
b
=
=
=
document
?
1
:
aup
?
-
1
:
bup
?
1
:
sortInput
?
(
indexOf
(
sortInput
a
)
-
indexOf
(
sortInput
b
)
)
:
0
;
}
else
if
(
aup
=
=
=
bup
)
{
return
siblingCheck
(
a
b
)
;
}
cur
=
a
;
while
(
(
cur
=
cur
.
parentNode
)
)
{
ap
.
unshift
(
cur
)
;
}
cur
=
b
;
while
(
(
cur
=
cur
.
parentNode
)
)
{
bp
.
unshift
(
cur
)
;
}
while
(
ap
[
i
]
=
=
=
bp
[
i
]
)
{
i
+
+
;
}
return
i
?
siblingCheck
(
ap
[
i
]
bp
[
i
]
)
:
ap
[
i
]
=
=
=
preferredDoc
?
-
1
:
bp
[
i
]
=
=
=
preferredDoc
?
1
:
0
;
}
;
return
document
;
}
;
Sizzle
.
matches
=
function
(
expr
elements
)
{
return
Sizzle
(
expr
null
null
elements
)
;
}
;
Sizzle
.
matchesSelector
=
function
(
elem
expr
)
{
if
(
(
elem
.
ownerDocument
|
|
elem
)
!
=
=
document
)
{
setDocument
(
elem
)
;
}
expr
=
expr
.
replace
(
rattributeQuotes
"
=
'
1
'
]
"
)
;
if
(
support
.
matchesSelector
&
&
documentIsHTML
&
&
!
compilerCache
[
expr
+
"
"
]
&
&
(
!
rbuggyMatches
|
|
!
rbuggyMatches
.
test
(
expr
)
)
&
&
(
!
rbuggyQSA
|
|
!
rbuggyQSA
.
test
(
expr
)
)
)
{
try
{
var
ret
=
matches
.
call
(
elem
expr
)
;
if
(
ret
|
|
support
.
disconnectedMatch
|
|
elem
.
document
&
&
elem
.
document
.
nodeType
!
=
=
11
)
{
return
ret
;
}
}
catch
(
e
)
{
}
}
return
Sizzle
(
expr
document
null
[
elem
]
)
.
length
>
0
;
}
;
Sizzle
.
contains
=
function
(
context
elem
)
{
if
(
(
context
.
ownerDocument
|
|
context
)
!
=
=
document
)
{
setDocument
(
context
)
;
}
return
contains
(
context
elem
)
;
}
;
Sizzle
.
attr
=
function
(
elem
name
)
{
if
(
(
elem
.
ownerDocument
|
|
elem
)
!
=
=
document
)
{
setDocument
(
elem
)
;
}
var
fn
=
Expr
.
attrHandle
[
name
.
toLowerCase
(
)
]
val
=
fn
&
&
hasOwn
.
call
(
Expr
.
attrHandle
name
.
toLowerCase
(
)
)
?
fn
(
elem
name
!
documentIsHTML
)
:
undefined
;
return
val
!
=
=
undefined
?
val
:
support
.
attributes
|
|
!
documentIsHTML
?
elem
.
getAttribute
(
name
)
:
(
val
=
elem
.
getAttributeNode
(
name
)
)
&
&
val
.
specified
?
val
.
value
:
null
;
}
;
Sizzle
.
error
=
function
(
msg
)
{
throw
new
Error
(
"
Syntax
error
unrecognized
expression
:
"
+
msg
)
;
}
;
Sizzle
.
uniqueSort
=
function
(
results
)
{
var
elem
duplicates
=
[
]
j
=
0
i
=
0
;
hasDuplicate
=
!
support
.
detectDuplicates
;
sortInput
=
!
support
.
sortStable
&
&
results
.
slice
(
0
)
;
results
.
sort
(
sortOrder
)
;
if
(
hasDuplicate
)
{
while
(
(
elem
=
results
[
i
+
+
]
)
)
{
if
(
elem
=
=
=
results
[
i
]
)
{
j
=
duplicates
.
push
(
i
)
;
}
}
while
(
j
-
-
)
{
results
.
splice
(
duplicates
[
j
]
1
)
;
}
}
sortInput
=
null
;
return
results
;
}
;
getText
=
Sizzle
.
getText
=
function
(
elem
)
{
var
node
ret
=
"
"
i
=
0
nodeType
=
elem
.
nodeType
;
if
(
!
nodeType
)
{
while
(
(
node
=
elem
[
i
+
+
]
)
)
{
ret
+
=
getText
(
node
)
;
}
}
else
if
(
nodeType
=
=
=
1
|
|
nodeType
=
=
=
9
|
|
nodeType
=
=
=
11
)
{
if
(
typeof
elem
.
textContent
=
=
=
"
string
"
)
{
return
elem
.
textContent
;
}
else
{
for
(
elem
=
elem
.
firstChild
;
elem
;
elem
=
elem
.
nextSibling
)
{
ret
+
=
getText
(
elem
)
;
}
}
}
else
if
(
nodeType
=
=
=
3
|
|
nodeType
=
=
=
4
)
{
return
elem
.
nodeValue
;
}
return
ret
;
}
;
Expr
=
Sizzle
.
selectors
=
{
cacheLength
:
50
createPseudo
:
markFunction
match
:
matchExpr
attrHandle
:
{
}
find
:
{
}
relative
:
{
"
>
"
:
{
dir
:
"
parentNode
"
first
:
true
}
"
"
:
{
dir
:
"
parentNode
"
}
"
+
"
:
{
dir
:
"
previousSibling
"
first
:
true
}
"
~
"
:
{
dir
:
"
previousSibling
"
}
}
preFilter
:
{
"
ATTR
"
:
function
(
match
)
{
match
[
1
]
=
match
[
1
]
.
replace
(
runescape
funescape
)
;
match
[
3
]
=
(
match
[
3
]
|
|
match
[
4
]
|
|
match
[
5
]
|
|
"
"
)
.
replace
(
runescape
funescape
)
;
if
(
match
[
2
]
=
=
=
"
~
=
"
)
{
match
[
3
]
=
"
"
+
match
[
3
]
+
"
"
;
}
return
match
.
slice
(
0
4
)
;
}
"
CHILD
"
:
function
(
match
)
{
match
[
1
]
=
match
[
1
]
.
toLowerCase
(
)
;
if
(
match
[
1
]
.
slice
(
0
3
)
=
=
=
"
nth
"
)
{
if
(
!
match
[
3
]
)
{
Sizzle
.
error
(
match
[
0
]
)
;
}
match
[
4
]
=
+
(
match
[
4
]
?
match
[
5
]
+
(
match
[
6
]
|
|
1
)
:
2
*
(
match
[
3
]
=
=
=
"
even
"
|
|
match
[
3
]
=
=
=
"
odd
"
)
)
;
match
[
5
]
=
+
(
(
match
[
7
]
+
match
[
8
]
)
|
|
match
[
3
]
=
=
=
"
odd
"
)
;
}
else
if
(
match
[
3
]
)
{
Sizzle
.
error
(
match
[
0
]
)
;
}
return
match
;
}
"
PSEUDO
"
:
function
(
match
)
{
var
excess
unquoted
=
!
match
[
6
]
&
&
match
[
2
]
;
if
(
matchExpr
[
"
CHILD
"
]
.
test
(
match
[
0
]
)
)
{
return
null
;
}
if
(
match
[
3
]
)
{
match
[
2
]
=
match
[
4
]
|
|
match
[
5
]
|
|
"
"
;
}
else
if
(
unquoted
&
&
rpseudo
.
test
(
unquoted
)
&
&
(
excess
=
tokenize
(
unquoted
true
)
)
&
&
(
excess
=
unquoted
.
indexOf
(
"
)
"
unquoted
.
length
-
excess
)
-
unquoted
.
length
)
)
{
match
[
0
]
=
match
[
0
]
.
slice
(
0
excess
)
;
match
[
2
]
=
unquoted
.
slice
(
0
excess
)
;
}
return
match
.
slice
(
0
3
)
;
}
}
filter
:
{
"
TAG
"
:
function
(
nodeNameSelector
)
{
var
nodeName
=
nodeNameSelector
.
replace
(
runescape
funescape
)
.
toLowerCase
(
)
;
return
nodeNameSelector
=
=
=
"
*
"
?
function
(
)
{
return
true
;
}
:
function
(
elem
)
{
return
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
nodeName
;
}
;
}
"
CLASS
"
:
function
(
className
)
{
var
pattern
=
classCache
[
className
+
"
"
]
;
return
pattern
|
|
(
pattern
=
new
RegExp
(
"
(
^
|
"
+
whitespace
+
"
)
"
+
className
+
"
(
"
+
whitespace
+
"
|
)
"
)
)
&
&
classCache
(
className
function
(
elem
)
{
return
pattern
.
test
(
typeof
elem
.
className
=
=
=
"
string
"
&
&
elem
.
className
|
|
typeof
elem
.
getAttribute
!
=
=
"
undefined
"
&
&
elem
.
getAttribute
(
"
class
"
)
|
|
"
"
)
;
}
)
;
}
"
ATTR
"
:
function
(
name
operator
check
)
{
return
function
(
elem
)
{
var
result
=
Sizzle
.
attr
(
elem
name
)
;
if
(
result
=
=
null
)
{
return
operator
=
=
=
"
!
=
"
;
}
if
(
!
operator
)
{
return
true
;
}
result
+
=
"
"
;
return
operator
=
=
=
"
=
"
?
result
=
=
=
check
:
operator
=
=
=
"
!
=
"
?
result
!
=
=
check
:
operator
=
=
=
"
^
=
"
?
check
&
&
result
.
indexOf
(
check
)
=
=
=
0
:
operator
=
=
=
"
*
=
"
?
check
&
&
result
.
indexOf
(
check
)
>
-
1
:
operator
=
=
=
"
=
"
?
check
&
&
result
.
slice
(
-
check
.
length
)
=
=
=
check
:
operator
=
=
=
"
~
=
"
?
(
"
"
+
result
.
replace
(
rwhitespace
"
"
)
+
"
"
)
.
indexOf
(
check
)
>
-
1
:
operator
=
=
=
"
|
=
"
?
result
=
=
=
check
|
|
result
.
slice
(
0
check
.
length
+
1
)
=
=
=
check
+
"
-
"
:
false
;
}
;
}
"
CHILD
"
:
function
(
type
what
argument
first
last
)
{
var
simple
=
type
.
slice
(
0
3
)
!
=
=
"
nth
"
forward
=
type
.
slice
(
-
4
)
!
=
=
"
last
"
ofType
=
what
=
=
=
"
of
-
type
"
;
return
first
=
=
=
1
&
&
last
=
=
=
0
?
function
(
elem
)
{
return
!
!
elem
.
parentNode
;
}
:
function
(
elem
context
xml
)
{
var
cache
uniqueCache
outerCache
node
nodeIndex
start
dir
=
simple
!
=
=
forward
?
"
nextSibling
"
:
"
previousSibling
"
parent
=
elem
.
parentNode
name
=
ofType
&
&
elem
.
nodeName
.
toLowerCase
(
)
useCache
=
!
xml
&
&
!
ofType
diff
=
false
;
if
(
parent
)
{
if
(
simple
)
{
while
(
dir
)
{
node
=
elem
;
while
(
(
node
=
node
[
dir
]
)
)
{
if
(
ofType
?
node
.
nodeName
.
toLowerCase
(
)
=
=
=
name
:
node
.
nodeType
=
=
=
1
)
{
return
false
;
}
}
start
=
dir
=
type
=
=
=
"
only
"
&
&
!
start
&
&
"
nextSibling
"
;
}
return
true
;
}
start
=
[
forward
?
parent
.
firstChild
:
parent
.
lastChild
]
;
if
(
forward
&
&
useCache
)
{
node
=
parent
;
outerCache
=
node
[
expando
]
|
|
(
node
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
node
.
uniqueID
]
|
|
(
outerCache
[
node
.
uniqueID
]
=
{
}
)
;
cache
=
uniqueCache
[
type
]
|
|
[
]
;
nodeIndex
=
cache
[
0
]
=
=
=
dirruns
&
&
cache
[
1
]
;
diff
=
nodeIndex
&
&
cache
[
2
]
;
node
=
nodeIndex
&
&
parent
.
childNodes
[
nodeIndex
]
;
while
(
(
node
=
+
+
nodeIndex
&
&
node
&
&
node
[
dir
]
|
|
(
diff
=
nodeIndex
=
0
)
|
|
start
.
pop
(
)
)
)
{
if
(
node
.
nodeType
=
=
=
1
&
&
+
+
diff
&
&
node
=
=
=
elem
)
{
uniqueCache
[
type
]
=
[
dirruns
nodeIndex
diff
]
;
break
;
}
}
}
else
{
if
(
useCache
)
{
node
=
elem
;
outerCache
=
node
[
expando
]
|
|
(
node
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
node
.
uniqueID
]
|
|
(
outerCache
[
node
.
uniqueID
]
=
{
}
)
;
cache
=
uniqueCache
[
type
]
|
|
[
]
;
nodeIndex
=
cache
[
0
]
=
=
=
dirruns
&
&
cache
[
1
]
;
diff
=
nodeIndex
;
}
if
(
diff
=
=
=
false
)
{
while
(
(
node
=
+
+
nodeIndex
&
&
node
&
&
node
[
dir
]
|
|
(
diff
=
nodeIndex
=
0
)
|
|
start
.
pop
(
)
)
)
{
if
(
(
ofType
?
node
.
nodeName
.
toLowerCase
(
)
=
=
=
name
:
node
.
nodeType
=
=
=
1
)
&
&
+
+
diff
)
{
if
(
useCache
)
{
outerCache
=
node
[
expando
]
|
|
(
node
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
node
.
uniqueID
]
|
|
(
outerCache
[
node
.
uniqueID
]
=
{
}
)
;
uniqueCache
[
type
]
=
[
dirruns
diff
]
;
}
if
(
node
=
=
=
elem
)
{
break
;
}
}
}
}
}
diff
-
=
last
;
return
diff
=
=
=
first
|
|
(
diff
%
first
=
=
=
0
&
&
diff
/
first
>
=
0
)
;
}
}
;
}
"
PSEUDO
"
:
function
(
pseudo
argument
)
{
var
args
fn
=
Expr
.
pseudos
[
pseudo
]
|
|
Expr
.
setFilters
[
pseudo
.
toLowerCase
(
)
]
|
|
Sizzle
.
error
(
"
unsupported
pseudo
:
"
+
pseudo
)
;
if
(
fn
[
expando
]
)
{
return
fn
(
argument
)
;
}
if
(
fn
.
length
>
1
)
{
args
=
[
pseudo
pseudo
"
"
argument
]
;
return
Expr
.
setFilters
.
hasOwnProperty
(
pseudo
.
toLowerCase
(
)
)
?
markFunction
(
function
(
seed
matches
)
{
var
idx
matched
=
fn
(
seed
argument
)
i
=
matched
.
length
;
while
(
i
-
-
)
{
idx
=
indexOf
(
seed
matched
[
i
]
)
;
seed
[
idx
]
=
!
(
matches
[
idx
]
=
matched
[
i
]
)
;
}
}
)
:
function
(
elem
)
{
return
fn
(
elem
0
args
)
;
}
;
}
return
fn
;
}
}
pseudos
:
{
"
not
"
:
markFunction
(
function
(
selector
)
{
var
input
=
[
]
results
=
[
]
matcher
=
compile
(
selector
.
replace
(
rtrim
"
1
"
)
)
;
return
matcher
[
expando
]
?
markFunction
(
function
(
seed
matches
context
xml
)
{
var
elem
unmatched
=
matcher
(
seed
null
xml
[
]
)
i
=
seed
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
unmatched
[
i
]
)
)
{
seed
[
i
]
=
!
(
matches
[
i
]
=
elem
)
;
}
}
}
)
:
function
(
elem
context
xml
)
{
input
[
0
]
=
elem
;
matcher
(
input
null
xml
results
)
;
input
[
0
]
=
null
;
return
!
results
.
pop
(
)
;
}
;
}
)
"
has
"
:
markFunction
(
function
(
selector
)
{
return
function
(
elem
)
{
return
Sizzle
(
selector
elem
)
.
length
>
0
;
}
;
}
)
"
contains
"
:
markFunction
(
function
(
text
)
{
text
=
text
.
replace
(
runescape
funescape
)
;
return
function
(
elem
)
{
return
(
elem
.
textContent
|
|
elem
.
innerText
|
|
getText
(
elem
)
)
.
indexOf
(
text
)
>
-
1
;
}
;
}
)
"
lang
"
:
markFunction
(
function
(
lang
)
{
if
(
!
ridentifier
.
test
(
lang
|
|
"
"
)
)
{
Sizzle
.
error
(
"
unsupported
lang
:
"
+
lang
)
;
}
lang
=
lang
.
replace
(
runescape
funescape
)
.
toLowerCase
(
)
;
return
function
(
elem
)
{
var
elemLang
;
do
{
if
(
(
elemLang
=
documentIsHTML
?
elem
.
lang
:
elem
.
getAttribute
(
"
xml
:
lang
"
)
|
|
elem
.
getAttribute
(
"
lang
"
)
)
)
{
elemLang
=
elemLang
.
toLowerCase
(
)
;
return
elemLang
=
=
=
lang
|
|
elemLang
.
indexOf
(
lang
+
"
-
"
)
=
=
=
0
;
}
}
while
(
(
elem
=
elem
.
parentNode
)
&
&
elem
.
nodeType
=
=
=
1
)
;
return
false
;
}
;
}
)
"
target
"
:
function
(
elem
)
{
var
hash
=
window
.
location
&
&
window
.
location
.
hash
;
return
hash
&
&
hash
.
slice
(
1
)
=
=
=
elem
.
id
;
}
"
root
"
:
function
(
elem
)
{
return
elem
=
=
=
docElem
;
}
"
focus
"
:
function
(
elem
)
{
return
elem
=
=
=
document
.
activeElement
&
&
(
!
document
.
hasFocus
|
|
document
.
hasFocus
(
)
)
&
&
!
!
(
elem
.
type
|
|
elem
.
href
|
|
~
elem
.
tabIndex
)
;
}
"
enabled
"
:
function
(
elem
)
{
return
elem
.
disabled
=
=
=
false
;
}
"
disabled
"
:
function
(
elem
)
{
return
elem
.
disabled
=
=
=
true
;
}
"
checked
"
:
function
(
elem
)
{
var
nodeName
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
(
nodeName
=
=
=
"
input
"
&
&
!
!
elem
.
checked
)
|
|
(
nodeName
=
=
=
"
option
"
&
&
!
!
elem
.
selected
)
;
}
"
selected
"
:
function
(
elem
)
{
if
(
elem
.
parentNode
)
{
elem
.
parentNode
.
selectedIndex
;
}
return
elem
.
selected
=
=
=
true
;
}
"
empty
"
:
function
(
elem
)
{
for
(
elem
=
elem
.
firstChild
;
elem
;
elem
=
elem
.
nextSibling
)
{
if
(
elem
.
nodeType
<
6
)
{
return
false
;
}
}
return
true
;
}
"
parent
"
:
function
(
elem
)
{
return
!
Expr
.
pseudos
[
"
empty
"
]
(
elem
)
;
}
"
header
"
:
function
(
elem
)
{
return
rheader
.
test
(
elem
.
nodeName
)
;
}
"
input
"
:
function
(
elem
)
{
return
rinputs
.
test
(
elem
.
nodeName
)
;
}
"
button
"
:
function
(
elem
)
{
var
name
=
elem
.
nodeName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
&
&
elem
.
type
=
=
=
"
button
"
|
|
name
=
=
=
"
button
"
;
}
"
text
"
:
function
(
elem
)
{
var
attr
;
return
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
"
input
"
&
&
elem
.
type
=
=
=
"
text
"
&
&
(
(
attr
=
elem
.
getAttribute
(
"
type
"
)
)
=
=
null
|
|
attr
.
toLowerCase
(
)
=
=
=
"
text
"
)
;
}
"
first
"
:
createPositionalPseudo
(
function
(
)
{
return
[
0
]
;
}
)
"
last
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
)
{
return
[
length
-
1
]
;
}
)
"
eq
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
argument
)
{
return
[
argument
<
0
?
argument
+
length
:
argument
]
;
}
)
"
even
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
)
{
var
i
=
0
;
for
(
;
i
<
length
;
i
+
=
2
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
"
odd
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
)
{
var
i
=
1
;
for
(
;
i
<
length
;
i
+
=
2
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
"
lt
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
argument
)
{
var
i
=
argument
<
0
?
argument
+
length
:
argument
;
for
(
;
-
-
i
>
=
0
;
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
"
gt
"
:
createPositionalPseudo
(
function
(
matchIndexes
length
argument
)
{
var
i
=
argument
<
0
?
argument
+
length
:
argument
;
for
(
;
+
+
i
<
length
;
)
{
matchIndexes
.
push
(
i
)
;
}
return
matchIndexes
;
}
)
}
}
;
Expr
.
pseudos
[
"
nth
"
]
=
Expr
.
pseudos
[
"
eq
"
]
;
for
(
i
in
{
radio
:
true
checkbox
:
true
file
:
true
password
:
true
image
:
true
}
)
{
Expr
.
pseudos
[
i
]
=
createInputPseudo
(
i
)
;
}
for
(
i
in
{
submit
:
true
reset
:
true
}
)
{
Expr
.
pseudos
[
i
]
=
createButtonPseudo
(
i
)
;
}
function
setFilters
(
)
{
}
setFilters
.
prototype
=
Expr
.
filters
=
Expr
.
pseudos
;
Expr
.
setFilters
=
new
setFilters
(
)
;
tokenize
=
Sizzle
.
tokenize
=
function
(
selector
parseOnly
)
{
var
matched
match
tokens
type
soFar
groups
preFilters
cached
=
tokenCache
[
selector
+
"
"
]
;
if
(
cached
)
{
return
parseOnly
?
0
:
cached
.
slice
(
0
)
;
}
soFar
=
selector
;
groups
=
[
]
;
preFilters
=
Expr
.
preFilter
;
while
(
soFar
)
{
if
(
!
matched
|
|
(
match
=
rcomma
.
exec
(
soFar
)
)
)
{
if
(
match
)
{
soFar
=
soFar
.
slice
(
match
[
0
]
.
length
)
|
|
soFar
;
}
groups
.
push
(
(
tokens
=
[
]
)
)
;
}
matched
=
false
;
if
(
(
match
=
rcombinators
.
exec
(
soFar
)
)
)
{
matched
=
match
.
shift
(
)
;
tokens
.
push
(
{
value
:
matched
type
:
match
[
0
]
.
replace
(
rtrim
"
"
)
}
)
;
soFar
=
soFar
.
slice
(
matched
.
length
)
;
}
for
(
type
in
Expr
.
filter
)
{
if
(
(
match
=
matchExpr
[
type
]
.
exec
(
soFar
)
)
&
&
(
!
preFilters
[
type
]
|
|
(
match
=
preFilters
[
type
]
(
match
)
)
)
)
{
matched
=
match
.
shift
(
)
;
tokens
.
push
(
{
value
:
matched
type
:
type
matches
:
match
}
)
;
soFar
=
soFar
.
slice
(
matched
.
length
)
;
}
}
if
(
!
matched
)
{
break
;
}
}
return
parseOnly
?
soFar
.
length
:
soFar
?
Sizzle
.
error
(
selector
)
:
tokenCache
(
selector
groups
)
.
slice
(
0
)
;
}
;
function
toSelector
(
tokens
)
{
var
i
=
0
len
=
tokens
.
length
selector
=
"
"
;
for
(
;
i
<
len
;
i
+
+
)
{
selector
+
=
tokens
[
i
]
.
value
;
}
return
selector
;
}
function
addCombinator
(
matcher
combinator
base
)
{
var
dir
=
combinator
.
dir
checkNonElements
=
base
&
&
dir
=
=
=
"
parentNode
"
doneName
=
done
+
+
;
return
combinator
.
first
?
function
(
elem
context
xml
)
{
while
(
(
elem
=
elem
[
dir
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
|
|
checkNonElements
)
{
return
matcher
(
elem
context
xml
)
;
}
}
}
:
function
(
elem
context
xml
)
{
var
oldCache
uniqueCache
outerCache
newCache
=
[
dirruns
doneName
]
;
if
(
xml
)
{
while
(
(
elem
=
elem
[
dir
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
|
|
checkNonElements
)
{
if
(
matcher
(
elem
context
xml
)
)
{
return
true
;
}
}
}
}
else
{
while
(
(
elem
=
elem
[
dir
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
|
|
checkNonElements
)
{
outerCache
=
elem
[
expando
]
|
|
(
elem
[
expando
]
=
{
}
)
;
uniqueCache
=
outerCache
[
elem
.
uniqueID
]
|
|
(
outerCache
[
elem
.
uniqueID
]
=
{
}
)
;
if
(
(
oldCache
=
uniqueCache
[
dir
]
)
&
&
oldCache
[
0
]
=
=
=
dirruns
&
&
oldCache
[
1
]
=
=
=
doneName
)
{
return
(
newCache
[
2
]
=
oldCache
[
2
]
)
;
}
else
{
uniqueCache
[
dir
]
=
newCache
;
if
(
(
newCache
[
2
]
=
matcher
(
elem
context
xml
)
)
)
{
return
true
;
}
}
}
}
}
}
;
}
function
elementMatcher
(
matchers
)
{
return
matchers
.
length
>
1
?
function
(
elem
context
xml
)
{
var
i
=
matchers
.
length
;
while
(
i
-
-
)
{
if
(
!
matchers
[
i
]
(
elem
context
xml
)
)
{
return
false
;
}
}
return
true
;
}
:
matchers
[
0
]
;
}
function
multipleContexts
(
selector
contexts
results
)
{
var
i
=
0
len
=
contexts
.
length
;
for
(
;
i
<
len
;
i
+
+
)
{
Sizzle
(
selector
contexts
[
i
]
results
)
;
}
return
results
;
}
function
condense
(
unmatched
map
filter
context
xml
)
{
var
elem
newUnmatched
=
[
]
i
=
0
len
=
unmatched
.
length
mapped
=
map
!
=
null
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
(
elem
=
unmatched
[
i
]
)
)
{
if
(
!
filter
|
|
filter
(
elem
context
xml
)
)
{
newUnmatched
.
push
(
elem
)
;
if
(
mapped
)
{
map
.
push
(
i
)
;
}
}
}
}
return
newUnmatched
;
}
function
setMatcher
(
preFilter
selector
matcher
postFilter
postFinder
postSelector
)
{
if
(
postFilter
&
&
!
postFilter
[
expando
]
)
{
postFilter
=
setMatcher
(
postFilter
)
;
}
if
(
postFinder
&
&
!
postFinder
[
expando
]
)
{
postFinder
=
setMatcher
(
postFinder
postSelector
)
;
}
return
markFunction
(
function
(
seed
results
context
xml
)
{
var
temp
i
elem
preMap
=
[
]
postMap
=
[
]
preexisting
=
results
.
length
elems
=
seed
|
|
multipleContexts
(
selector
|
|
"
*
"
context
.
nodeType
?
[
context
]
:
context
[
]
)
matcherIn
=
preFilter
&
&
(
seed
|
|
!
selector
)
?
condense
(
elems
preMap
preFilter
context
xml
)
:
elems
matcherOut
=
matcher
?
postFinder
|
|
(
seed
?
preFilter
:
preexisting
|
|
postFilter
)
?
[
]
:
results
:
matcherIn
;
if
(
matcher
)
{
matcher
(
matcherIn
matcherOut
context
xml
)
;
}
if
(
postFilter
)
{
temp
=
condense
(
matcherOut
postMap
)
;
postFilter
(
temp
[
]
context
xml
)
;
i
=
temp
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
temp
[
i
]
)
)
{
matcherOut
[
postMap
[
i
]
]
=
!
(
matcherIn
[
postMap
[
i
]
]
=
elem
)
;
}
}
}
if
(
seed
)
{
if
(
postFinder
|
|
preFilter
)
{
if
(
postFinder
)
{
temp
=
[
]
;
i
=
matcherOut
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
matcherOut
[
i
]
)
)
{
temp
.
push
(
(
matcherIn
[
i
]
=
elem
)
)
;
}
}
postFinder
(
null
(
matcherOut
=
[
]
)
temp
xml
)
;
}
i
=
matcherOut
.
length
;
while
(
i
-
-
)
{
if
(
(
elem
=
matcherOut
[
i
]
)
&
&
(
temp
=
postFinder
?
indexOf
(
seed
elem
)
:
preMap
[
i
]
)
>
-
1
)
{
seed
[
temp
]
=
!
(
results
[
temp
]
=
elem
)
;
}
}
}
}
else
{
matcherOut
=
condense
(
matcherOut
=
=
=
results
?
matcherOut
.
splice
(
preexisting
matcherOut
.
length
)
:
matcherOut
)
;
if
(
postFinder
)
{
postFinder
(
null
results
matcherOut
xml
)
;
}
else
{
push
.
apply
(
results
matcherOut
)
;
}
}
}
)
;
}
function
matcherFromTokens
(
tokens
)
{
var
checkContext
matcher
j
len
=
tokens
.
length
leadingRelative
=
Expr
.
relative
[
tokens
[
0
]
.
type
]
implicitRelative
=
leadingRelative
|
|
Expr
.
relative
[
"
"
]
i
=
leadingRelative
?
1
:
0
matchContext
=
addCombinator
(
function
(
elem
)
{
return
elem
=
=
=
checkContext
;
}
implicitRelative
true
)
matchAnyContext
=
addCombinator
(
function
(
elem
)
{
return
indexOf
(
checkContext
elem
)
>
-
1
;
}
implicitRelative
true
)
matchers
=
[
function
(
elem
context
xml
)
{
var
ret
=
(
!
leadingRelative
&
&
(
xml
|
|
context
!
=
=
outermostContext
)
)
|
|
(
(
checkContext
=
context
)
.
nodeType
?
matchContext
(
elem
context
xml
)
:
matchAnyContext
(
elem
context
xml
)
)
;
checkContext
=
null
;
return
ret
;
}
]
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
(
matcher
=
Expr
.
relative
[
tokens
[
i
]
.
type
]
)
)
{
matchers
=
[
addCombinator
(
elementMatcher
(
matchers
)
matcher
)
]
;
}
else
{
matcher
=
Expr
.
filter
[
tokens
[
i
]
.
type
]
.
apply
(
null
tokens
[
i
]
.
matches
)
;
if
(
matcher
[
expando
]
)
{
j
=
+
+
i
;
for
(
;
j
<
len
;
j
+
+
)
{
if
(
Expr
.
relative
[
tokens
[
j
]
.
type
]
)
{
break
;
}
}
return
setMatcher
(
i
>
1
&
&
elementMatcher
(
matchers
)
i
>
1
&
&
toSelector
(
tokens
.
slice
(
0
i
-
1
)
.
concat
(
{
value
:
tokens
[
i
-
2
]
.
type
=
=
=
"
"
?
"
*
"
:
"
"
}
)
)
.
replace
(
rtrim
"
1
"
)
matcher
i
<
j
&
&
matcherFromTokens
(
tokens
.
slice
(
i
j
)
)
j
<
len
&
&
matcherFromTokens
(
(
tokens
=
tokens
.
slice
(
j
)
)
)
j
<
len
&
&
toSelector
(
tokens
)
)
;
}
matchers
.
push
(
matcher
)
;
}
}
return
elementMatcher
(
matchers
)
;
}
function
matcherFromGroupMatchers
(
elementMatchers
setMatchers
)
{
var
bySet
=
setMatchers
.
length
>
0
byElement
=
elementMatchers
.
length
>
0
superMatcher
=
function
(
seed
context
xml
results
outermost
)
{
var
elem
j
matcher
matchedCount
=
0
i
=
"
0
"
unmatched
=
seed
&
&
[
]
setMatched
=
[
]
contextBackup
=
outermostContext
elems
=
seed
|
|
byElement
&
&
Expr
.
find
[
"
TAG
"
]
(
"
*
"
outermost
)
dirrunsUnique
=
(
dirruns
+
=
contextBackup
=
=
null
?
1
:
Math
.
random
(
)
|
|
0
.
1
)
len
=
elems
.
length
;
if
(
outermost
)
{
outermostContext
=
context
=
=
=
document
|
|
context
|
|
outermost
;
}
for
(
;
i
!
=
=
len
&
&
(
elem
=
elems
[
i
]
)
!
=
null
;
i
+
+
)
{
if
(
byElement
&
&
elem
)
{
j
=
0
;
if
(
!
context
&
&
elem
.
ownerDocument
!
=
=
document
)
{
setDocument
(
elem
)
;
xml
=
!
documentIsHTML
;
}
while
(
(
matcher
=
elementMatchers
[
j
+
+
]
)
)
{
if
(
matcher
(
elem
context
|
|
document
xml
)
)
{
results
.
push
(
elem
)
;
break
;
}
}
if
(
outermost
)
{
dirruns
=
dirrunsUnique
;
}
}
if
(
bySet
)
{
if
(
(
elem
=
!
matcher
&
&
elem
)
)
{
matchedCount
-
-
;
}
if
(
seed
)
{
unmatched
.
push
(
elem
)
;
}
}
}
matchedCount
+
=
i
;
if
(
bySet
&
&
i
!
=
=
matchedCount
)
{
j
=
0
;
while
(
(
matcher
=
setMatchers
[
j
+
+
]
)
)
{
matcher
(
unmatched
setMatched
context
xml
)
;
}
if
(
seed
)
{
if
(
matchedCount
>
0
)
{
while
(
i
-
-
)
{
if
(
!
(
unmatched
[
i
]
|
|
setMatched
[
i
]
)
)
{
setMatched
[
i
]
=
pop
.
call
(
results
)
;
}
}
}
setMatched
=
condense
(
setMatched
)
;
}
push
.
apply
(
results
setMatched
)
;
if
(
outermost
&
&
!
seed
&
&
setMatched
.
length
>
0
&
&
(
matchedCount
+
setMatchers
.
length
)
>
1
)
{
Sizzle
.
uniqueSort
(
results
)
;
}
}
if
(
outermost
)
{
dirruns
=
dirrunsUnique
;
outermostContext
=
contextBackup
;
}
return
unmatched
;
}
;
return
bySet
?
markFunction
(
superMatcher
)
:
superMatcher
;
}
compile
=
Sizzle
.
compile
=
function
(
selector
match
)
{
var
i
setMatchers
=
[
]
elementMatchers
=
[
]
cached
=
compilerCache
[
selector
+
"
"
]
;
if
(
!
cached
)
{
if
(
!
match
)
{
match
=
tokenize
(
selector
)
;
}
i
=
match
.
length
;
while
(
i
-
-
)
{
cached
=
matcherFromTokens
(
match
[
i
]
)
;
if
(
cached
[
expando
]
)
{
setMatchers
.
push
(
cached
)
;
}
else
{
elementMatchers
.
push
(
cached
)
;
}
}
cached
=
compilerCache
(
selector
matcherFromGroupMatchers
(
elementMatchers
setMatchers
)
)
;
cached
.
selector
=
selector
;
}
return
cached
;
}
;
select
=
Sizzle
.
select
=
function
(
selector
context
results
seed
)
{
var
i
tokens
token
type
find
compiled
=
typeof
selector
=
=
=
"
function
"
&
&
selector
match
=
!
seed
&
&
tokenize
(
(
selector
=
compiled
.
selector
|
|
selector
)
)
;
results
=
results
|
|
[
]
;
if
(
match
.
length
=
=
=
1
)
{
tokens
=
match
[
0
]
=
match
[
0
]
.
slice
(
0
)
;
if
(
tokens
.
length
>
2
&
&
(
token
=
tokens
[
0
]
)
.
type
=
=
=
"
ID
"
&
&
support
.
getById
&
&
context
.
nodeType
=
=
=
9
&
&
documentIsHTML
&
&
Expr
.
relative
[
tokens
[
1
]
.
type
]
)
{
context
=
(
Expr
.
find
[
"
ID
"
]
(
token
.
matches
[
0
]
.
replace
(
runescape
funescape
)
context
)
|
|
[
]
)
[
0
]
;
if
(
!
context
)
{
return
results
;
}
else
if
(
compiled
)
{
context
=
context
.
parentNode
;
}
selector
=
selector
.
slice
(
tokens
.
shift
(
)
.
value
.
length
)
;
}
i
=
matchExpr
[
"
needsContext
"
]
.
test
(
selector
)
?
0
:
tokens
.
length
;
while
(
i
-
-
)
{
token
=
tokens
[
i
]
;
if
(
Expr
.
relative
[
(
type
=
token
.
type
)
]
)
{
break
;
}
if
(
(
find
=
Expr
.
find
[
type
]
)
)
{
if
(
(
seed
=
find
(
token
.
matches
[
0
]
.
replace
(
runescape
funescape
)
rsibling
.
test
(
tokens
[
0
]
.
type
)
&
&
testContext
(
context
.
parentNode
)
|
|
context
)
)
)
{
tokens
.
splice
(
i
1
)
;
selector
=
seed
.
length
&
&
toSelector
(
tokens
)
;
if
(
!
selector
)
{
push
.
apply
(
results
seed
)
;
return
results
;
}
break
;
}
}
}
}
(
compiled
|
|
compile
(
selector
match
)
)
(
seed
context
!
documentIsHTML
results
!
context
|
|
rsibling
.
test
(
selector
)
&
&
testContext
(
context
.
parentNode
)
|
|
context
)
;
return
results
;
}
;
support
.
sortStable
=
expando
.
split
(
"
"
)
.
sort
(
sortOrder
)
.
join
(
"
"
)
=
=
=
expando
;
support
.
detectDuplicates
=
!
!
hasDuplicate
;
setDocument
(
)
;
support
.
sortDetached
=
assert
(
function
(
div1
)
{
return
div1
.
compareDocumentPosition
(
document
.
createElement
(
"
div
"
)
)
&
1
;
}
)
;
if
(
!
assert
(
function
(
div
)
{
div
.
innerHTML
=
"
<
a
href
=
'
#
'
>
<
/
a
>
"
;
return
div
.
firstChild
.
getAttribute
(
"
href
"
)
=
=
=
"
#
"
;
}
)
)
{
addHandle
(
"
type
|
href
|
height
|
width
"
function
(
elem
name
isXML
)
{
if
(
!
isXML
)
{
return
elem
.
getAttribute
(
name
name
.
toLowerCase
(
)
=
=
=
"
type
"
?
1
:
2
)
;
}
}
)
;
}
if
(
!
support
.
attributes
|
|
!
assert
(
function
(
div
)
{
div
.
innerHTML
=
"
<
input
/
>
"
;
div
.
firstChild
.
setAttribute
(
"
value
"
"
"
)
;
return
div
.
firstChild
.
getAttribute
(
"
value
"
)
=
=
=
"
"
;
}
)
)
{
addHandle
(
"
value
"
function
(
elem
name
isXML
)
{
if
(
!
isXML
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
"
input
"
)
{
return
elem
.
defaultValue
;
}
}
)
;
}
if
(
!
assert
(
function
(
div
)
{
return
div
.
getAttribute
(
"
disabled
"
)
=
=
null
;
}
)
)
{
addHandle
(
booleans
function
(
elem
name
isXML
)
{
var
val
;
if
(
!
isXML
)
{
return
elem
[
name
]
=
=
=
true
?
name
.
toLowerCase
(
)
:
(
val
=
elem
.
getAttributeNode
(
name
)
)
&
&
val
.
specified
?
val
.
value
:
null
;
}
}
)
;
}
return
Sizzle
;
}
)
(
window
)
;
jQuery
.
find
=
Sizzle
;
jQuery
.
expr
=
Sizzle
.
selectors
;
jQuery
.
expr
[
"
:
"
]
=
jQuery
.
expr
.
pseudos
;
jQuery
.
uniqueSort
=
jQuery
.
unique
=
Sizzle
.
uniqueSort
;
jQuery
.
text
=
Sizzle
.
getText
;
jQuery
.
isXMLDoc
=
Sizzle
.
isXML
;
jQuery
.
contains
=
Sizzle
.
contains
;
var
dir
=
function
(
elem
dir
until
)
{
var
matched
=
[
]
truncate
=
until
!
=
=
undefined
;
while
(
(
elem
=
elem
[
dir
]
)
&
&
elem
.
nodeType
!
=
=
9
)
{
if
(
elem
.
nodeType
=
=
=
1
)
{
if
(
truncate
&
&
jQuery
(
elem
)
.
is
(
until
)
)
{
break
;
}
matched
.
push
(
elem
)
;
}
}
return
matched
;
}
;
var
siblings
=
function
(
n
elem
)
{
var
matched
=
[
]
;
for
(
;
n
;
n
=
n
.
nextSibling
)
{
if
(
n
.
nodeType
=
=
=
1
&
&
n
!
=
=
elem
)
{
matched
.
push
(
n
)
;
}
}
return
matched
;
}
;
var
rneedsContext
=
jQuery
.
expr
.
match
.
needsContext
;
var
rsingleTag
=
(
/
^
<
(
[
\
w
-
]
+
)
\
s
*
\
/
?
>
(
?
:
<
\
/
\
1
>
|
)
/
)
;
var
risSimple
=
/
^
.
[
^
:
#
\
[
\
.
]
*
/
;
function
winnow
(
elements
qualifier
not
)
{
if
(
jQuery
.
isFunction
(
qualifier
)
)
{
return
jQuery
.
grep
(
elements
function
(
elem
i
)
{
return
!
!
qualifier
.
call
(
elem
i
elem
)
!
=
=
not
;
}
)
;
}
if
(
qualifier
.
nodeType
)
{
return
jQuery
.
grep
(
elements
function
(
elem
)
{
return
(
elem
=
=
=
qualifier
)
!
=
=
not
;
}
)
;
}
if
(
typeof
qualifier
=
=
=
"
string
"
)
{
if
(
risSimple
.
test
(
qualifier
)
)
{
return
jQuery
.
filter
(
qualifier
elements
not
)
;
}
qualifier
=
jQuery
.
filter
(
qualifier
elements
)
;
}
return
jQuery
.
grep
(
elements
function
(
elem
)
{
return
(
indexOf
.
call
(
qualifier
elem
)
>
-
1
)
!
=
=
not
;
}
)
;
}
jQuery
.
filter
=
function
(
expr
elems
not
)
{
var
elem
=
elems
[
0
]
;
if
(
not
)
{
expr
=
"
:
not
(
"
+
expr
+
"
)
"
;
}
return
elems
.
length
=
=
=
1
&
&
elem
.
nodeType
=
=
=
1
?
jQuery
.
find
.
matchesSelector
(
elem
expr
)
?
[
elem
]
:
[
]
:
jQuery
.
find
.
matches
(
expr
jQuery
.
grep
(
elems
function
(
elem
)
{
return
elem
.
nodeType
=
=
=
1
;
}
)
)
;
}
;
jQuery
.
fn
.
extend
(
{
find
:
function
(
selector
)
{
var
i
len
=
this
.
length
ret
=
[
]
self
=
this
;
if
(
typeof
selector
!
=
=
"
string
"
)
{
return
this
.
pushStack
(
jQuery
(
selector
)
.
filter
(
function
(
)
{
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
jQuery
.
contains
(
self
[
i
]
this
)
)
{
return
true
;
}
}
}
)
)
;
}
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
jQuery
.
find
(
selector
self
[
i
]
ret
)
;
}
ret
=
this
.
pushStack
(
len
>
1
?
jQuery
.
unique
(
ret
)
:
ret
)
;
ret
.
selector
=
this
.
selector
?
this
.
selector
+
"
"
+
selector
:
selector
;
return
ret
;
}
filter
:
function
(
selector
)
{
return
this
.
pushStack
(
winnow
(
this
selector
|
|
[
]
false
)
)
;
}
not
:
function
(
selector
)
{
return
this
.
pushStack
(
winnow
(
this
selector
|
|
[
]
true
)
)
;
}
is
:
function
(
selector
)
{
return
!
!
winnow
(
this
typeof
selector
=
=
=
"
string
"
&
&
rneedsContext
.
test
(
selector
)
?
jQuery
(
selector
)
:
selector
|
|
[
]
false
)
.
length
;
}
}
)
;
var
rootjQuery
rquickExpr
=
/
^
(
?
:
\
s
*
(
<
[
\
w
\
W
]
+
>
)
[
^
>
]
*
|
#
(
[
\
w
-
]
*
)
)
/
init
=
jQuery
.
fn
.
init
=
function
(
selector
context
root
)
{
var
match
elem
;
if
(
!
selector
)
{
return
this
;
}
root
=
root
|
|
rootjQuery
;
if
(
typeof
selector
=
=
=
"
string
"
)
{
if
(
selector
[
0
]
=
=
=
"
<
"
&
&
selector
[
selector
.
length
-
1
]
=
=
=
"
>
"
&
&
selector
.
length
>
=
3
)
{
match
=
[
null
selector
null
]
;
}
else
{
match
=
rquickExpr
.
exec
(
selector
)
;
}
if
(
match
&
&
(
match
[
1
]
|
|
!
context
)
)
{
if
(
match
[
1
]
)
{
context
=
context
instanceof
jQuery
?
context
[
0
]
:
context
;
jQuery
.
merge
(
this
jQuery
.
parseHTML
(
match
[
1
]
context
&
&
context
.
nodeType
?
context
.
ownerDocument
|
|
context
:
document
true
)
)
;
if
(
rsingleTag
.
test
(
match
[
1
]
)
&
&
jQuery
.
isPlainObject
(
context
)
)
{
for
(
match
in
context
)
{
if
(
jQuery
.
isFunction
(
this
[
match
]
)
)
{
this
[
match
]
(
context
[
match
]
)
;
}
else
{
this
.
attr
(
match
context
[
match
]
)
;
}
}
}
return
this
;
}
else
{
elem
=
document
.
getElementById
(
match
[
2
]
)
;
if
(
elem
&
&
elem
.
parentNode
)
{
this
.
length
=
1
;
this
[
0
]
=
elem
;
}
this
.
context
=
document
;
this
.
selector
=
selector
;
return
this
;
}
}
else
if
(
!
context
|
|
context
.
jquery
)
{
return
(
context
|
|
root
)
.
find
(
selector
)
;
}
else
{
return
this
.
constructor
(
context
)
.
find
(
selector
)
;
}
}
else
if
(
selector
.
nodeType
)
{
this
.
context
=
this
[
0
]
=
selector
;
this
.
length
=
1
;
return
this
;
}
else
if
(
jQuery
.
isFunction
(
selector
)
)
{
return
root
.
ready
!
=
=
undefined
?
root
.
ready
(
selector
)
:
selector
(
jQuery
)
;
}
if
(
selector
.
selector
!
=
=
undefined
)
{
this
.
selector
=
selector
.
selector
;
this
.
context
=
selector
.
context
;
}
return
jQuery
.
makeArray
(
selector
this
)
;
}
;
init
.
prototype
=
jQuery
.
fn
;
rootjQuery
=
jQuery
(
document
)
;
var
rparentsprev
=
/
^
(
?
:
parents
|
prev
(
?
:
Until
|
All
)
)
/
guaranteedUnique
=
{
children
:
true
contents
:
true
next
:
true
prev
:
true
}
;
jQuery
.
fn
.
extend
(
{
has
:
function
(
target
)
{
var
targets
=
jQuery
(
target
this
)
l
=
targets
.
length
;
return
this
.
filter
(
function
(
)
{
var
i
=
0
;
for
(
;
i
<
l
;
i
+
+
)
{
if
(
jQuery
.
contains
(
this
targets
[
i
]
)
)
{
return
true
;
}
}
}
)
;
}
closest
:
function
(
selectors
context
)
{
var
cur
i
=
0
l
=
this
.
length
matched
=
[
]
pos
=
rneedsContext
.
test
(
selectors
)
|
|
typeof
selectors
!
=
=
"
string
"
?
jQuery
(
selectors
context
|
|
this
.
context
)
:
0
;
for
(
;
i
<
l
;
i
+
+
)
{
for
(
cur
=
this
[
i
]
;
cur
&
&
cur
!
=
=
context
;
cur
=
cur
.
parentNode
)
{
if
(
cur
.
nodeType
<
11
&
&
(
pos
?
pos
.
index
(
cur
)
>
-
1
:
cur
.
nodeType
=
=
=
1
&
&
jQuery
.
find
.
matchesSelector
(
cur
selectors
)
)
)
{
matched
.
push
(
cur
)
;
break
;
}
}
}
return
this
.
pushStack
(
matched
.
length
>
1
?
jQuery
.
uniqueSort
(
matched
)
:
matched
)
;
}
index
:
function
(
elem
)
{
if
(
!
elem
)
{
return
(
this
[
0
]
&
&
this
[
0
]
.
parentNode
)
?
this
.
first
(
)
.
prevAll
(
)
.
length
:
-
1
;
}
if
(
typeof
elem
=
=
=
"
string
"
)
{
return
indexOf
.
call
(
jQuery
(
elem
)
this
[
0
]
)
;
}
return
indexOf
.
call
(
this
elem
.
jquery
?
elem
[
0
]
:
elem
)
;
}
add
:
function
(
selector
context
)
{
return
this
.
pushStack
(
jQuery
.
uniqueSort
(
jQuery
.
merge
(
this
.
get
(
)
jQuery
(
selector
context
)
)
)
)
;
}
addBack
:
function
(
selector
)
{
return
this
.
add
(
selector
=
=
null
?
this
.
prevObject
:
this
.
prevObject
.
filter
(
selector
)
)
;
}
}
)
;
function
sibling
(
cur
dir
)
{
while
(
(
cur
=
cur
[
dir
]
)
&
&
cur
.
nodeType
!
=
=
1
)
{
}
return
cur
;
}
jQuery
.
each
(
{
parent
:
function
(
elem
)
{
var
parent
=
elem
.
parentNode
;
return
parent
&
&
parent
.
nodeType
!
=
=
11
?
parent
:
null
;
}
parents
:
function
(
elem
)
{
return
dir
(
elem
"
parentNode
"
)
;
}
parentsUntil
:
function
(
elem
i
until
)
{
return
dir
(
elem
"
parentNode
"
until
)
;
}
next
:
function
(
elem
)
{
return
sibling
(
elem
"
nextSibling
"
)
;
}
prev
:
function
(
elem
)
{
return
sibling
(
elem
"
previousSibling
"
)
;
}
nextAll
:
function
(
elem
)
{
return
dir
(
elem
"
nextSibling
"
)
;
}
prevAll
:
function
(
elem
)
{
return
dir
(
elem
"
previousSibling
"
)
;
}
nextUntil
:
function
(
elem
i
until
)
{
return
dir
(
elem
"
nextSibling
"
until
)
;
}
prevUntil
:
function
(
elem
i
until
)
{
return
dir
(
elem
"
previousSibling
"
until
)
;
}
siblings
:
function
(
elem
)
{
return
siblings
(
(
elem
.
parentNode
|
|
{
}
)
.
firstChild
elem
)
;
}
children
:
function
(
elem
)
{
return
siblings
(
elem
.
firstChild
)
;
}
contents
:
function
(
elem
)
{
return
elem
.
contentDocument
|
|
jQuery
.
merge
(
[
]
elem
.
childNodes
)
;
}
}
function
(
name
fn
)
{
jQuery
.
fn
[
name
]
=
function
(
until
selector
)
{
var
matched
=
jQuery
.
map
(
this
fn
until
)
;
if
(
name
.
slice
(
-
5
)
!
=
=
"
Until
"
)
{
selector
=
until
;
}
if
(
selector
&
&
typeof
selector
=
=
=
"
string
"
)
{
matched
=
jQuery
.
filter
(
selector
matched
)
;
}
if
(
this
.
length
>
1
)
{
if
(
!
guaranteedUnique
[
name
]
)
{
jQuery
.
uniqueSort
(
matched
)
;
}
if
(
rparentsprev
.
test
(
name
)
)
{
matched
.
reverse
(
)
;
}
}
return
this
.
pushStack
(
matched
)
;
}
;
}
)
;
var
rnotwhite
=
(
/
\
S
+
/
g
)
;
function
createOptions
(
options
)
{
var
object
=
{
}
;
jQuery
.
each
(
options
.
match
(
rnotwhite
)
|
|
[
]
function
(
_
flag
)
{
object
[
flag
]
=
true
;
}
)
;
return
object
;
}
jQuery
.
Callbacks
=
function
(
options
)
{
options
=
typeof
options
=
=
=
"
string
"
?
createOptions
(
options
)
:
jQuery
.
extend
(
{
}
options
)
;
var
firing
memory
fired
locked
list
=
[
]
queue
=
[
]
firingIndex
=
-
1
fire
=
function
(
)
{
locked
=
options
.
once
;
fired
=
firing
=
true
;
for
(
;
queue
.
length
;
firingIndex
=
-
1
)
{
memory
=
queue
.
shift
(
)
;
while
(
+
+
firingIndex
<
list
.
length
)
{
if
(
list
[
firingIndex
]
.
apply
(
memory
[
0
]
memory
[
1
]
)
=
=
=
false
&
&
options
.
stopOnFalse
)
{
firingIndex
=
list
.
length
;
memory
=
false
;
}
}
}
if
(
!
options
.
memory
)
{
memory
=
false
;
}
firing
=
false
;
if
(
locked
)
{
if
(
memory
)
{
list
=
[
]
;
}
else
{
list
=
"
"
;
}
}
}
self
=
{
add
:
function
(
)
{
if
(
list
)
{
if
(
memory
&
&
!
firing
)
{
firingIndex
=
list
.
length
-
1
;
queue
.
push
(
memory
)
;
}
(
function
add
(
args
)
{
jQuery
.
each
(
args
function
(
_
arg
)
{
if
(
jQuery
.
isFunction
(
arg
)
)
{
if
(
!
options
.
unique
|
|
!
self
.
has
(
arg
)
)
{
list
.
push
(
arg
)
;
}
}
else
if
(
arg
&
&
arg
.
length
&
&
jQuery
.
type
(
arg
)
!
=
=
"
string
"
)
{
add
(
arg
)
;
}
}
)
;
}
)
(
arguments
)
;
if
(
memory
&
&
!
firing
)
{
fire
(
)
;
}
}
return
this
;
}
remove
:
function
(
)
{
jQuery
.
each
(
arguments
function
(
_
arg
)
{
var
index
;
while
(
(
index
=
jQuery
.
inArray
(
arg
list
index
)
)
>
-
1
)
{
list
.
splice
(
index
1
)
;
if
(
index
<
=
firingIndex
)
{
firingIndex
-
-
;
}
}
}
)
;
return
this
;
}
has
:
function
(
fn
)
{
return
fn
?
jQuery
.
inArray
(
fn
list
)
>
-
1
:
list
.
length
>
0
;
}
empty
:
function
(
)
{
if
(
list
)
{
list
=
[
]
;
}
return
this
;
}
disable
:
function
(
)
{
locked
=
queue
=
[
]
;
list
=
memory
=
"
"
;
return
this
;
}
disabled
:
function
(
)
{
return
!
list
;
}
lock
:
function
(
)
{
locked
=
queue
=
[
]
;
if
(
!
memory
)
{
list
=
memory
=
"
"
;
}
return
this
;
}
locked
:
function
(
)
{
return
!
!
locked
;
}
fireWith
:
function
(
context
args
)
{
if
(
!
locked
)
{
args
=
args
|
|
[
]
;
args
=
[
context
args
.
slice
?
args
.
slice
(
)
:
args
]
;
queue
.
push
(
args
)
;
if
(
!
firing
)
{
fire
(
)
;
}
}
return
this
;
}
fire
:
function
(
)
{
self
.
fireWith
(
this
arguments
)
;
return
this
;
}
fired
:
function
(
)
{
return
!
!
fired
;
}
}
;
return
self
;
}
;
jQuery
.
extend
(
{
Deferred
:
function
(
func
)
{
var
tuples
=
[
[
"
resolve
"
"
done
"
jQuery
.
Callbacks
(
"
once
memory
"
)
"
resolved
"
]
[
"
reject
"
"
fail
"
jQuery
.
Callbacks
(
"
once
memory
"
)
"
rejected
"
]
[
"
notify
"
"
progress
"
jQuery
.
Callbacks
(
"
memory
"
)
]
]
state
=
"
pending
"
promise
=
{
state
:
function
(
)
{
return
state
;
}
always
:
function
(
)
{
deferred
.
done
(
arguments
)
.
fail
(
arguments
)
;
return
this
;
}
then
:
function
(
)
{
var
fns
=
arguments
;
return
jQuery
.
Deferred
(
function
(
newDefer
)
{
jQuery
.
each
(
tuples
function
(
i
tuple
)
{
var
fn
=
jQuery
.
isFunction
(
fns
[
i
]
)
&
&
fns
[
i
]
;
deferred
[
tuple
[
1
]
]
(
function
(
)
{
var
returned
=
fn
&
&
fn
.
apply
(
this
arguments
)
;
if
(
returned
&
&
jQuery
.
isFunction
(
returned
.
promise
)
)
{
returned
.
promise
(
)
.
progress
(
newDefer
.
notify
)
.
done
(
newDefer
.
resolve
)
.
fail
(
newDefer
.
reject
)
;
}
else
{
newDefer
[
tuple
[
0
]
+
"
With
"
]
(
this
=
=
=
promise
?
newDefer
.
promise
(
)
:
this
fn
?
[
returned
]
:
arguments
)
;
}
}
)
;
}
)
;
fns
=
null
;
}
)
.
promise
(
)
;
}
promise
:
function
(
obj
)
{
return
obj
!
=
null
?
jQuery
.
extend
(
obj
promise
)
:
promise
;
}
}
deferred
=
{
}
;
promise
.
pipe
=
promise
.
then
;
jQuery
.
each
(
tuples
function
(
i
tuple
)
{
var
list
=
tuple
[
2
]
stateString
=
tuple
[
3
]
;
promise
[
tuple
[
1
]
]
=
list
.
add
;
if
(
stateString
)
{
list
.
add
(
function
(
)
{
state
=
stateString
;
}
tuples
[
i
^
1
]
[
2
]
.
disable
tuples
[
2
]
[
2
]
.
lock
)
;
}
deferred
[
tuple
[
0
]
]
=
function
(
)
{
deferred
[
tuple
[
0
]
+
"
With
"
]
(
this
=
=
=
deferred
?
promise
:
this
arguments
)
;
return
this
;
}
;
deferred
[
tuple
[
0
]
+
"
With
"
]
=
list
.
fireWith
;
}
)
;
promise
.
promise
(
deferred
)
;
if
(
func
)
{
func
.
call
(
deferred
deferred
)
;
}
return
deferred
;
}
when
:
function
(
subordinate
)
{
var
i
=
0
resolveValues
=
slice
.
call
(
arguments
)
length
=
resolveValues
.
length
remaining
=
length
!
=
=
1
|
|
(
subordinate
&
&
jQuery
.
isFunction
(
subordinate
.
promise
)
)
?
length
:
0
deferred
=
remaining
=
=
=
1
?
subordinate
:
jQuery
.
Deferred
(
)
updateFunc
=
function
(
i
contexts
values
)
{
return
function
(
value
)
{
contexts
[
i
]
=
this
;
values
[
i
]
=
arguments
.
length
>
1
?
slice
.
call
(
arguments
)
:
value
;
if
(
values
=
=
=
progressValues
)
{
deferred
.
notifyWith
(
contexts
values
)
;
}
else
if
(
!
(
-
-
remaining
)
)
{
deferred
.
resolveWith
(
contexts
values
)
;
}
}
;
}
progressValues
progressContexts
resolveContexts
;
if
(
length
>
1
)
{
progressValues
=
new
Array
(
length
)
;
progressContexts
=
new
Array
(
length
)
;
resolveContexts
=
new
Array
(
length
)
;
for
(
;
i
<
length
;
i
+
+
)
{
if
(
resolveValues
[
i
]
&
&
jQuery
.
isFunction
(
resolveValues
[
i
]
.
promise
)
)
{
resolveValues
[
i
]
.
promise
(
)
.
progress
(
updateFunc
(
i
progressContexts
progressValues
)
)
.
done
(
updateFunc
(
i
resolveContexts
resolveValues
)
)
.
fail
(
deferred
.
reject
)
;
}
else
{
-
-
remaining
;
}
}
}
if
(
!
remaining
)
{
deferred
.
resolveWith
(
resolveContexts
resolveValues
)
;
}
return
deferred
.
promise
(
)
;
}
}
)
;
var
readyList
;
jQuery
.
fn
.
ready
=
function
(
fn
)
{
jQuery
.
ready
.
promise
(
)
.
done
(
fn
)
;
return
this
;
}
;
jQuery
.
extend
(
{
isReady
:
false
readyWait
:
1
holdReady
:
function
(
hold
)
{
if
(
hold
)
{
jQuery
.
readyWait
+
+
;
}
else
{
jQuery
.
ready
(
true
)
;
}
}
ready
:
function
(
wait
)
{
if
(
wait
=
=
=
true
?
-
-
jQuery
.
readyWait
:
jQuery
.
isReady
)
{
return
;
}
jQuery
.
isReady
=
true
;
if
(
wait
!
=
=
true
&
&
-
-
jQuery
.
readyWait
>
0
)
{
return
;
}
readyList
.
resolveWith
(
document
[
jQuery
]
)
;
if
(
jQuery
.
fn
.
triggerHandler
)
{
jQuery
(
document
)
.
triggerHandler
(
"
ready
"
)
;
jQuery
(
document
)
.
off
(
"
ready
"
)
;
}
}
}
)
;
function
completed
(
)
{
document
.
removeEventListener
(
"
DOMContentLoaded
"
completed
)
;
window
.
removeEventListener
(
"
load
"
completed
)
;
jQuery
.
ready
(
)
;
}
jQuery
.
ready
.
promise
=
function
(
obj
)
{
if
(
!
readyList
)
{
readyList
=
jQuery
.
Deferred
(
)
;
if
(
document
.
readyState
=
=
=
"
complete
"
|
|
(
document
.
readyState
!
=
=
"
loading
"
&
&
!
document
.
documentElement
.
doScroll
)
)
{
window
.
setTimeout
(
jQuery
.
ready
)
;
}
else
{
document
.
addEventListener
(
"
DOMContentLoaded
"
completed
)
;
window
.
addEventListener
(
"
load
"
completed
)
;
}
}
return
readyList
.
promise
(
obj
)
;
}
;
jQuery
.
ready
.
promise
(
)
;
var
access
=
function
(
elems
fn
key
value
chainable
emptyGet
raw
)
{
var
i
=
0
len
=
elems
.
length
bulk
=
key
=
=
null
;
if
(
jQuery
.
type
(
key
)
=
=
=
"
object
"
)
{
chainable
=
true
;
for
(
i
in
key
)
{
access
(
elems
fn
i
key
[
i
]
true
emptyGet
raw
)
;
}
}
else
if
(
value
!
=
=
undefined
)
{
chainable
=
true
;
if
(
!
jQuery
.
isFunction
(
value
)
)
{
raw
=
true
;
}
if
(
bulk
)
{
if
(
raw
)
{
fn
.
call
(
elems
value
)
;
fn
=
null
;
}
else
{
bulk
=
fn
;
fn
=
function
(
elem
key
value
)
{
return
bulk
.
call
(
jQuery
(
elem
)
value
)
;
}
;
}
}
if
(
fn
)
{
for
(
;
i
<
len
;
i
+
+
)
{
fn
(
elems
[
i
]
key
raw
?
value
:
value
.
call
(
elems
[
i
]
i
fn
(
elems
[
i
]
key
)
)
)
;
}
}
}
return
chainable
?
elems
:
bulk
?
fn
.
call
(
elems
)
:
len
?
fn
(
elems
[
0
]
key
)
:
emptyGet
;
}
;
var
acceptData
=
function
(
owner
)
{
return
owner
.
nodeType
=
=
=
1
|
|
owner
.
nodeType
=
=
=
9
|
|
!
(
+
owner
.
nodeType
)
;
}
;
function
Data
(
)
{
this
.
expando
=
jQuery
.
expando
+
Data
.
uid
+
+
;
}
Data
.
uid
=
1
;
Data
.
prototype
=
{
register
:
function
(
owner
initial
)
{
var
value
=
initial
|
|
{
}
;
if
(
owner
.
nodeType
)
{
owner
[
this
.
expando
]
=
value
;
}
else
{
Object
.
defineProperty
(
owner
this
.
expando
{
value
:
value
writable
:
true
configurable
:
true
}
)
;
}
return
owner
[
this
.
expando
]
;
}
cache
:
function
(
owner
)
{
if
(
!
acceptData
(
owner
)
)
{
return
{
}
;
}
var
value
=
owner
[
this
.
expando
]
;
if
(
!
value
)
{
value
=
{
}
;
if
(
acceptData
(
owner
)
)
{
if
(
owner
.
nodeType
)
{
owner
[
this
.
expando
]
=
value
;
}
else
{
Object
.
defineProperty
(
owner
this
.
expando
{
value
:
value
configurable
:
true
}
)
;
}
}
}
return
value
;
}
set
:
function
(
owner
data
value
)
{
var
prop
cache
=
this
.
cache
(
owner
)
;
if
(
typeof
data
=
=
=
"
string
"
)
{
cache
[
data
]
=
value
;
}
else
{
for
(
prop
in
data
)
{
cache
[
prop
]
=
data
[
prop
]
;
}
}
return
cache
;
}
get
:
function
(
owner
key
)
{
return
key
=
=
=
undefined
?
this
.
cache
(
owner
)
:
owner
[
this
.
expando
]
&
&
owner
[
this
.
expando
]
[
key
]
;
}
access
:
function
(
owner
key
value
)
{
var
stored
;
if
(
key
=
=
=
undefined
|
|
(
(
key
&
&
typeof
key
=
=
=
"
string
"
)
&
&
value
=
=
=
undefined
)
)
{
stored
=
this
.
get
(
owner
key
)
;
return
stored
!
=
=
undefined
?
stored
:
this
.
get
(
owner
jQuery
.
camelCase
(
key
)
)
;
}
this
.
set
(
owner
key
value
)
;
return
value
!
=
=
undefined
?
value
:
key
;
}
remove
:
function
(
owner
key
)
{
var
i
name
camel
cache
=
owner
[
this
.
expando
]
;
if
(
cache
=
=
=
undefined
)
{
return
;
}
if
(
key
=
=
=
undefined
)
{
this
.
register
(
owner
)
;
}
else
{
if
(
jQuery
.
isArray
(
key
)
)
{
name
=
key
.
concat
(
key
.
map
(
jQuery
.
camelCase
)
)
;
}
else
{
camel
=
jQuery
.
camelCase
(
key
)
;
if
(
key
in
cache
)
{
name
=
[
key
camel
]
;
}
else
{
name
=
camel
;
name
=
name
in
cache
?
[
name
]
:
(
name
.
match
(
rnotwhite
)
|
|
[
]
)
;
}
}
i
=
name
.
length
;
while
(
i
-
-
)
{
delete
cache
[
name
[
i
]
]
;
}
}
if
(
key
=
=
=
undefined
|
|
jQuery
.
isEmptyObject
(
cache
)
)
{
if
(
owner
.
nodeType
)
{
owner
[
this
.
expando
]
=
undefined
;
}
else
{
delete
owner
[
this
.
expando
]
;
}
}
}
hasData
:
function
(
owner
)
{
var
cache
=
owner
[
this
.
expando
]
;
return
cache
!
=
=
undefined
&
&
!
jQuery
.
isEmptyObject
(
cache
)
;
}
}
;
var
dataPriv
=
new
Data
(
)
;
var
dataUser
=
new
Data
(
)
;
var
rbrace
=
/
^
(
?
:
\
{
[
\
w
\
W
]
*
\
}
|
\
[
[
\
w
\
W
]
*
\
]
)
/
rmultiDash
=
/
[
A
-
Z
]
/
g
;
function
dataAttr
(
elem
key
data
)
{
var
name
;
if
(
data
=
=
=
undefined
&
&
elem
.
nodeType
=
=
=
1
)
{
name
=
"
data
-
"
+
key
.
replace
(
rmultiDash
"
-
&
"
)
.
toLowerCase
(
)
;
data
=
elem
.
getAttribute
(
name
)
;
if
(
typeof
data
=
=
=
"
string
"
)
{
try
{
data
=
data
=
=
=
"
true
"
?
true
:
data
=
=
=
"
false
"
?
false
:
data
=
=
=
"
null
"
?
null
:
+
data
+
"
"
=
=
=
data
?
+
data
:
rbrace
.
test
(
data
)
?
jQuery
.
parseJSON
(
data
)
:
data
;
}
catch
(
e
)
{
}
dataUser
.
set
(
elem
key
data
)
;
}
else
{
data
=
undefined
;
}
}
return
data
;
}
jQuery
.
extend
(
{
hasData
:
function
(
elem
)
{
return
dataUser
.
hasData
(
elem
)
|
|
dataPriv
.
hasData
(
elem
)
;
}
data
:
function
(
elem
name
data
)
{
return
dataUser
.
access
(
elem
name
data
)
;
}
removeData
:
function
(
elem
name
)
{
dataUser
.
remove
(
elem
name
)
;
}
_data
:
function
(
elem
name
data
)
{
return
dataPriv
.
access
(
elem
name
data
)
;
}
_removeData
:
function
(
elem
name
)
{
dataPriv
.
remove
(
elem
name
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
data
:
function
(
key
value
)
{
var
i
name
data
elem
=
this
[
0
]
attrs
=
elem
&
&
elem
.
attributes
;
if
(
key
=
=
=
undefined
)
{
if
(
this
.
length
)
{
data
=
dataUser
.
get
(
elem
)
;
if
(
elem
.
nodeType
=
=
=
1
&
&
!
dataPriv
.
get
(
elem
"
hasDataAttrs
"
)
)
{
i
=
attrs
.
length
;
while
(
i
-
-
)
{
if
(
attrs
[
i
]
)
{
name
=
attrs
[
i
]
.
name
;
if
(
name
.
indexOf
(
"
data
-
"
)
=
=
=
0
)
{
name
=
jQuery
.
camelCase
(
name
.
slice
(
5
)
)
;
dataAttr
(
elem
name
data
[
name
]
)
;
}
}
}
dataPriv
.
set
(
elem
"
hasDataAttrs
"
true
)
;
}
}
return
data
;
}
if
(
typeof
key
=
=
=
"
object
"
)
{
return
this
.
each
(
function
(
)
{
dataUser
.
set
(
this
key
)
;
}
)
;
}
return
access
(
this
function
(
value
)
{
var
data
camelKey
;
if
(
elem
&
&
value
=
=
=
undefined
)
{
data
=
dataUser
.
get
(
elem
key
)
|
|
dataUser
.
get
(
elem
key
.
replace
(
rmultiDash
"
-
&
"
)
.
toLowerCase
(
)
)
;
if
(
data
!
=
=
undefined
)
{
return
data
;
}
camelKey
=
jQuery
.
camelCase
(
key
)
;
data
=
dataUser
.
get
(
elem
camelKey
)
;
if
(
data
!
=
=
undefined
)
{
return
data
;
}
data
=
dataAttr
(
elem
camelKey
undefined
)
;
if
(
data
!
=
=
undefined
)
{
return
data
;
}
return
;
}
camelKey
=
jQuery
.
camelCase
(
key
)
;
this
.
each
(
function
(
)
{
var
data
=
dataUser
.
get
(
this
camelKey
)
;
dataUser
.
set
(
this
camelKey
value
)
;
if
(
key
.
indexOf
(
"
-
"
)
>
-
1
&
&
data
!
=
=
undefined
)
{
dataUser
.
set
(
this
key
value
)
;
}
}
)
;
}
null
value
arguments
.
length
>
1
null
true
)
;
}
removeData
:
function
(
key
)
{
return
this
.
each
(
function
(
)
{
dataUser
.
remove
(
this
key
)
;
}
)
;
}
}
)
;
jQuery
.
extend
(
{
queue
:
function
(
elem
type
data
)
{
var
queue
;
if
(
elem
)
{
type
=
(
type
|
|
"
fx
"
)
+
"
queue
"
;
queue
=
dataPriv
.
get
(
elem
type
)
;
if
(
data
)
{
if
(
!
queue
|
|
jQuery
.
isArray
(
data
)
)
{
queue
=
dataPriv
.
access
(
elem
type
jQuery
.
makeArray
(
data
)
)
;
}
else
{
queue
.
push
(
data
)
;
}
}
return
queue
|
|
[
]
;
}
}
dequeue
:
function
(
elem
type
)
{
type
=
type
|
|
"
fx
"
;
var
queue
=
jQuery
.
queue
(
elem
type
)
startLength
=
queue
.
length
fn
=
queue
.
shift
(
)
hooks
=
jQuery
.
_queueHooks
(
elem
type
)
next
=
function
(
)
{
jQuery
.
dequeue
(
elem
type
)
;
}
;
if
(
fn
=
=
=
"
inprogress
"
)
{
fn
=
queue
.
shift
(
)
;
startLength
-
-
;
}
if
(
fn
)
{
if
(
type
=
=
=
"
fx
"
)
{
queue
.
unshift
(
"
inprogress
"
)
;
}
delete
hooks
.
stop
;
fn
.
call
(
elem
next
hooks
)
;
}
if
(
!
startLength
&
&
hooks
)
{
hooks
.
empty
.
fire
(
)
;
}
}
_queueHooks
:
function
(
elem
type
)
{
var
key
=
type
+
"
queueHooks
"
;
return
dataPriv
.
get
(
elem
key
)
|
|
dataPriv
.
access
(
elem
key
{
empty
:
jQuery
.
Callbacks
(
"
once
memory
"
)
.
add
(
function
(
)
{
dataPriv
.
remove
(
elem
[
type
+
"
queue
"
key
]
)
;
}
)
}
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
queue
:
function
(
type
data
)
{
var
setter
=
2
;
if
(
typeof
type
!
=
=
"
string
"
)
{
data
=
type
;
type
=
"
fx
"
;
setter
-
-
;
}
if
(
arguments
.
length
<
setter
)
{
return
jQuery
.
queue
(
this
[
0
]
type
)
;
}
return
data
=
=
=
undefined
?
this
:
this
.
each
(
function
(
)
{
var
queue
=
jQuery
.
queue
(
this
type
data
)
;
jQuery
.
_queueHooks
(
this
type
)
;
if
(
type
=
=
=
"
fx
"
&
&
queue
[
0
]
!
=
=
"
inprogress
"
)
{
jQuery
.
dequeue
(
this
type
)
;
}
}
)
;
}
dequeue
:
function
(
type
)
{
return
this
.
each
(
function
(
)
{
jQuery
.
dequeue
(
this
type
)
;
}
)
;
}
clearQueue
:
function
(
type
)
{
return
this
.
queue
(
type
|
|
"
fx
"
[
]
)
;
}
promise
:
function
(
type
obj
)
{
var
tmp
count
=
1
defer
=
jQuery
.
Deferred
(
)
elements
=
this
i
=
this
.
length
resolve
=
function
(
)
{
if
(
!
(
-
-
count
)
)
{
defer
.
resolveWith
(
elements
[
elements
]
)
;
}
}
;
if
(
typeof
type
!
=
=
"
string
"
)
{
obj
=
type
;
type
=
undefined
;
}
type
=
type
|
|
"
fx
"
;
while
(
i
-
-
)
{
tmp
=
dataPriv
.
get
(
elements
[
i
]
type
+
"
queueHooks
"
)
;
if
(
tmp
&
&
tmp
.
empty
)
{
count
+
+
;
tmp
.
empty
.
add
(
resolve
)
;
}
}
resolve
(
)
;
return
defer
.
promise
(
obj
)
;
}
}
)
;
var
pnum
=
(
/
[
+
-
]
?
(
?
:
\
d
*
\
.
|
)
\
d
+
(
?
:
[
eE
]
[
+
-
]
?
\
d
+
|
)
/
)
.
source
;
var
rcssNum
=
new
RegExp
(
"
^
(
?
:
(
[
+
-
]
)
=
|
)
(
"
+
pnum
+
"
)
(
[
a
-
z
%
]
*
)
"
"
i
"
)
;
var
cssExpand
=
[
"
Top
"
"
Right
"
"
Bottom
"
"
Left
"
]
;
var
isHidden
=
function
(
elem
el
)
{
elem
=
el
|
|
elem
;
return
jQuery
.
css
(
elem
"
display
"
)
=
=
=
"
none
"
|
|
!
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
;
}
;
function
adjustCSS
(
elem
prop
valueParts
tween
)
{
var
adjusted
scale
=
1
maxIterations
=
20
currentValue
=
tween
?
function
(
)
{
return
tween
.
cur
(
)
;
}
:
function
(
)
{
return
jQuery
.
css
(
elem
prop
"
"
)
;
}
initial
=
currentValue
(
)
unit
=
valueParts
&
&
valueParts
[
3
]
|
|
(
jQuery
.
cssNumber
[
prop
]
?
"
"
:
"
px
"
)
initialInUnit
=
(
jQuery
.
cssNumber
[
prop
]
|
|
unit
!
=
=
"
px
"
&
&
+
initial
)
&
&
rcssNum
.
exec
(
jQuery
.
css
(
elem
prop
)
)
;
if
(
initialInUnit
&
&
initialInUnit
[
3
]
!
=
=
unit
)
{
unit
=
unit
|
|
initialInUnit
[
3
]
;
valueParts
=
valueParts
|
|
[
]
;
initialInUnit
=
+
initial
|
|
1
;
do
{
scale
=
scale
|
|
"
.
5
"
;
initialInUnit
=
initialInUnit
/
scale
;
jQuery
.
style
(
elem
prop
initialInUnit
+
unit
)
;
}
while
(
scale
!
=
=
(
scale
=
currentValue
(
)
/
initial
)
&
&
scale
!
=
=
1
&
&
-
-
maxIterations
)
;
}
if
(
valueParts
)
{
initialInUnit
=
+
initialInUnit
|
|
+
initial
|
|
0
;
adjusted
=
valueParts
[
1
]
?
initialInUnit
+
(
valueParts
[
1
]
+
1
)
*
valueParts
[
2
]
:
+
valueParts
[
2
]
;
if
(
tween
)
{
tween
.
unit
=
unit
;
tween
.
start
=
initialInUnit
;
tween
.
end
=
adjusted
;
}
}
return
adjusted
;
}
var
rcheckableType
=
(
/
^
(
?
:
checkbox
|
radio
)
/
i
)
;
var
rtagName
=
(
/
<
(
[
\
w
:
-
]
+
)
/
)
;
var
rscriptType
=
(
/
^
|
\
/
(
?
:
java
|
ecma
)
script
/
i
)
;
var
wrapMap
=
{
option
:
[
1
"
<
select
multiple
=
'
multiple
'
>
"
"
<
/
select
>
"
]
thead
:
[
1
"
<
table
>
"
"
<
/
table
>
"
]
col
:
[
2
"
<
table
>
<
colgroup
>
"
"
<
/
colgroup
>
<
/
table
>
"
]
tr
:
[
2
"
<
table
>
<
tbody
>
"
"
<
/
tbody
>
<
/
table
>
"
]
td
:
[
3
"
<
table
>
<
tbody
>
<
tr
>
"
"
<
/
tr
>
<
/
tbody
>
<
/
table
>
"
]
_default
:
[
0
"
"
"
"
]
}
;
wrapMap
.
optgroup
=
wrapMap
.
option
;
wrapMap
.
tbody
=
wrapMap
.
tfoot
=
wrapMap
.
colgroup
=
wrapMap
.
caption
=
wrapMap
.
thead
;
wrapMap
.
th
=
wrapMap
.
td
;
function
getAll
(
context
tag
)
{
var
ret
=
typeof
context
.
getElementsByTagName
!
=
=
"
undefined
"
?
context
.
getElementsByTagName
(
tag
|
|
"
*
"
)
:
typeof
context
.
querySelectorAll
!
=
=
"
undefined
"
?
context
.
querySelectorAll
(
tag
|
|
"
*
"
)
:
[
]
;
return
tag
=
=
=
undefined
|
|
tag
&
&
jQuery
.
nodeName
(
context
tag
)
?
jQuery
.
merge
(
[
context
]
ret
)
:
ret
;
}
function
setGlobalEval
(
elems
refElements
)
{
var
i
=
0
l
=
elems
.
length
;
for
(
;
i
<
l
;
i
+
+
)
{
dataPriv
.
set
(
elems
[
i
]
"
globalEval
"
!
refElements
|
|
dataPriv
.
get
(
refElements
[
i
]
"
globalEval
"
)
)
;
}
}
var
rhtml
=
/
<
|
&
#
?
\
w
+
;
/
;
function
buildFragment
(
elems
context
scripts
selection
ignored
)
{
var
elem
tmp
tag
wrap
contains
j
fragment
=
context
.
createDocumentFragment
(
)
nodes
=
[
]
i
=
0
l
=
elems
.
length
;
for
(
;
i
<
l
;
i
+
+
)
{
elem
=
elems
[
i
]
;
if
(
elem
|
|
elem
=
=
=
0
)
{
if
(
jQuery
.
type
(
elem
)
=
=
=
"
object
"
)
{
jQuery
.
merge
(
nodes
elem
.
nodeType
?
[
elem
]
:
elem
)
;
}
else
if
(
!
rhtml
.
test
(
elem
)
)
{
nodes
.
push
(
context
.
createTextNode
(
elem
)
)
;
}
else
{
tmp
=
tmp
|
|
fragment
.
appendChild
(
context
.
createElement
(
"
div
"
)
)
;
tag
=
(
rtagName
.
exec
(
elem
)
|
|
[
"
"
"
"
]
)
[
1
]
.
toLowerCase
(
)
;
wrap
=
wrapMap
[
tag
]
|
|
wrapMap
.
_default
;
tmp
.
innerHTML
=
wrap
[
1
]
+
jQuery
.
htmlPrefilter
(
elem
)
+
wrap
[
2
]
;
j
=
wrap
[
0
]
;
while
(
j
-
-
)
{
tmp
=
tmp
.
lastChild
;
}
jQuery
.
merge
(
nodes
tmp
.
childNodes
)
;
tmp
=
fragment
.
firstChild
;
tmp
.
textContent
=
"
"
;
}
}
}
fragment
.
textContent
=
"
"
;
i
=
0
;
while
(
(
elem
=
nodes
[
i
+
+
]
)
)
{
if
(
selection
&
&
jQuery
.
inArray
(
elem
selection
)
>
-
1
)
{
if
(
ignored
)
{
ignored
.
push
(
elem
)
;
}
continue
;
}
contains
=
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
;
tmp
=
getAll
(
fragment
.
appendChild
(
elem
)
"
script
"
)
;
if
(
contains
)
{
setGlobalEval
(
tmp
)
;
}
if
(
scripts
)
{
j
=
0
;
while
(
(
elem
=
tmp
[
j
+
+
]
)
)
{
if
(
rscriptType
.
test
(
elem
.
type
|
|
"
"
)
)
{
scripts
.
push
(
elem
)
;
}
}
}
}
return
fragment
;
}
(
function
(
)
{
var
fragment
=
document
.
createDocumentFragment
(
)
div
=
fragment
.
appendChild
(
document
.
createElement
(
"
div
"
)
)
input
=
document
.
createElement
(
"
input
"
)
;
input
.
setAttribute
(
"
type
"
"
radio
"
)
;
input
.
setAttribute
(
"
checked
"
"
checked
"
)
;
input
.
setAttribute
(
"
name
"
"
t
"
)
;
div
.
appendChild
(
input
)
;
support
.
checkClone
=
div
.
cloneNode
(
true
)
.
cloneNode
(
true
)
.
lastChild
.
checked
;
div
.
innerHTML
=
"
<
textarea
>
x
<
/
textarea
>
"
;
support
.
noCloneChecked
=
!
!
div
.
cloneNode
(
true
)
.
lastChild
.
defaultValue
;
}
)
(
)
;
var
rkeyEvent
=
/
^
key
/
rmouseEvent
=
/
^
(
?
:
mouse
|
pointer
|
contextmenu
|
drag
|
drop
)
|
click
/
rtypenamespace
=
/
^
(
[
^
.
]
*
)
(
?
:
\
.
(
.
+
)
|
)
/
;
function
returnTrue
(
)
{
return
true
;
}
function
returnFalse
(
)
{
return
false
;
}
function
safeActiveElement
(
)
{
try
{
return
document
.
activeElement
;
}
catch
(
err
)
{
}
}
function
on
(
elem
types
selector
data
fn
one
)
{
var
origFn
type
;
if
(
typeof
types
=
=
=
"
object
"
)
{
if
(
typeof
selector
!
=
=
"
string
"
)
{
data
=
data
|
|
selector
;
selector
=
undefined
;
}
for
(
type
in
types
)
{
on
(
elem
type
selector
data
types
[
type
]
one
)
;
}
return
elem
;
}
if
(
data
=
=
null
&
&
fn
=
=
null
)
{
fn
=
selector
;
data
=
selector
=
undefined
;
}
else
if
(
fn
=
=
null
)
{
if
(
typeof
selector
=
=
=
"
string
"
)
{
fn
=
data
;
data
=
undefined
;
}
else
{
fn
=
data
;
data
=
selector
;
selector
=
undefined
;
}
}
if
(
fn
=
=
=
false
)
{
fn
=
returnFalse
;
}
else
if
(
!
fn
)
{
return
elem
;
}
if
(
one
=
=
=
1
)
{
origFn
=
fn
;
fn
=
function
(
event
)
{
jQuery
(
)
.
off
(
event
)
;
return
origFn
.
apply
(
this
arguments
)
;
}
;
fn
.
guid
=
origFn
.
guid
|
|
(
origFn
.
guid
=
jQuery
.
guid
+
+
)
;
}
return
elem
.
each
(
function
(
)
{
jQuery
.
event
.
add
(
this
types
fn
data
selector
)
;
}
)
;
}
jQuery
.
event
=
{
global
:
{
}
add
:
function
(
elem
types
handler
data
selector
)
{
var
handleObjIn
eventHandle
tmp
events
t
handleObj
special
handlers
type
namespaces
origType
elemData
=
dataPriv
.
get
(
elem
)
;
if
(
!
elemData
)
{
return
;
}
if
(
handler
.
handler
)
{
handleObjIn
=
handler
;
handler
=
handleObjIn
.
handler
;
selector
=
handleObjIn
.
selector
;
}
if
(
!
handler
.
guid
)
{
handler
.
guid
=
jQuery
.
guid
+
+
;
}
if
(
!
(
events
=
elemData
.
events
)
)
{
events
=
elemData
.
events
=
{
}
;
}
if
(
!
(
eventHandle
=
elemData
.
handle
)
)
{
eventHandle
=
elemData
.
handle
=
function
(
e
)
{
return
typeof
jQuery
!
=
=
"
undefined
"
&
&
jQuery
.
event
.
triggered
!
=
=
e
.
type
?
jQuery
.
event
.
dispatch
.
apply
(
elem
arguments
)
:
undefined
;
}
;
}
types
=
(
types
|
|
"
"
)
.
match
(
rnotwhite
)
|
|
[
"
"
]
;
t
=
types
.
length
;
while
(
t
-
-
)
{
tmp
=
rtypenamespace
.
exec
(
types
[
t
]
)
|
|
[
]
;
type
=
origType
=
tmp
[
1
]
;
namespaces
=
(
tmp
[
2
]
|
|
"
"
)
.
split
(
"
.
"
)
.
sort
(
)
;
if
(
!
type
)
{
continue
;
}
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
type
=
(
selector
?
special
.
delegateType
:
special
.
bindType
)
|
|
type
;
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
handleObj
=
jQuery
.
extend
(
{
type
:
type
origType
:
origType
data
:
data
handler
:
handler
guid
:
handler
.
guid
selector
:
selector
needsContext
:
selector
&
&
jQuery
.
expr
.
match
.
needsContext
.
test
(
selector
)
namespace
:
namespaces
.
join
(
"
.
"
)
}
handleObjIn
)
;
if
(
!
(
handlers
=
events
[
type
]
)
)
{
handlers
=
events
[
type
]
=
[
]
;
handlers
.
delegateCount
=
0
;
if
(
!
special
.
setup
|
|
special
.
setup
.
call
(
elem
data
namespaces
eventHandle
)
=
=
=
false
)
{
if
(
elem
.
addEventListener
)
{
elem
.
addEventListener
(
type
eventHandle
)
;
}
}
}
if
(
special
.
add
)
{
special
.
add
.
call
(
elem
handleObj
)
;
if
(
!
handleObj
.
handler
.
guid
)
{
handleObj
.
handler
.
guid
=
handler
.
guid
;
}
}
if
(
selector
)
{
handlers
.
splice
(
handlers
.
delegateCount
+
+
0
handleObj
)
;
}
else
{
handlers
.
push
(
handleObj
)
;
}
jQuery
.
event
.
global
[
type
]
=
true
;
}
}
remove
:
function
(
elem
types
handler
selector
mappedTypes
)
{
var
j
origCount
tmp
events
t
handleObj
special
handlers
type
namespaces
origType
elemData
=
dataPriv
.
hasData
(
elem
)
&
&
dataPriv
.
get
(
elem
)
;
if
(
!
elemData
|
|
!
(
events
=
elemData
.
events
)
)
{
return
;
}
types
=
(
types
|
|
"
"
)
.
match
(
rnotwhite
)
|
|
[
"
"
]
;
t
=
types
.
length
;
while
(
t
-
-
)
{
tmp
=
rtypenamespace
.
exec
(
types
[
t
]
)
|
|
[
]
;
type
=
origType
=
tmp
[
1
]
;
namespaces
=
(
tmp
[
2
]
|
|
"
"
)
.
split
(
"
.
"
)
.
sort
(
)
;
if
(
!
type
)
{
for
(
type
in
events
)
{
jQuery
.
event
.
remove
(
elem
type
+
types
[
t
]
handler
selector
true
)
;
}
continue
;
}
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
type
=
(
selector
?
special
.
delegateType
:
special
.
bindType
)
|
|
type
;
handlers
=
events
[
type
]
|
|
[
]
;
tmp
=
tmp
[
2
]
&
&
new
RegExp
(
"
(
^
|
\
\
.
)
"
+
namespaces
.
join
(
"
\
\
.
(
?
:
.
*
\
\
.
|
)
"
)
+
"
(
\
\
.
|
)
"
)
;
origCount
=
j
=
handlers
.
length
;
while
(
j
-
-
)
{
handleObj
=
handlers
[
j
]
;
if
(
(
mappedTypes
|
|
origType
=
=
=
handleObj
.
origType
)
&
&
(
!
handler
|
|
handler
.
guid
=
=
=
handleObj
.
guid
)
&
&
(
!
tmp
|
|
tmp
.
test
(
handleObj
.
namespace
)
)
&
&
(
!
selector
|
|
selector
=
=
=
handleObj
.
selector
|
|
selector
=
=
=
"
*
*
"
&
&
handleObj
.
selector
)
)
{
handlers
.
splice
(
j
1
)
;
if
(
handleObj
.
selector
)
{
handlers
.
delegateCount
-
-
;
}
if
(
special
.
remove
)
{
special
.
remove
.
call
(
elem
handleObj
)
;
}
}
}
if
(
origCount
&
&
!
handlers
.
length
)
{
if
(
!
special
.
teardown
|
|
special
.
teardown
.
call
(
elem
namespaces
elemData
.
handle
)
=
=
=
false
)
{
jQuery
.
removeEvent
(
elem
type
elemData
.
handle
)
;
}
delete
events
[
type
]
;
}
}
if
(
jQuery
.
isEmptyObject
(
events
)
)
{
dataPriv
.
remove
(
elem
"
handle
events
"
)
;
}
}
dispatch
:
function
(
event
)
{
event
=
jQuery
.
event
.
fix
(
event
)
;
var
i
j
ret
matched
handleObj
handlerQueue
=
[
]
args
=
slice
.
call
(
arguments
)
handlers
=
(
dataPriv
.
get
(
this
"
events
"
)
|
|
{
}
)
[
event
.
type
]
|
|
[
]
special
=
jQuery
.
event
.
special
[
event
.
type
]
|
|
{
}
;
args
[
0
]
=
event
;
event
.
delegateTarget
=
this
;
if
(
special
.
preDispatch
&
&
special
.
preDispatch
.
call
(
this
event
)
=
=
=
false
)
{
return
;
}
handlerQueue
=
jQuery
.
event
.
handlers
.
call
(
this
event
handlers
)
;
i
=
0
;
while
(
(
matched
=
handlerQueue
[
i
+
+
]
)
&
&
!
event
.
isPropagationStopped
(
)
)
{
event
.
currentTarget
=
matched
.
elem
;
j
=
0
;
while
(
(
handleObj
=
matched
.
handlers
[
j
+
+
]
)
&
&
!
event
.
isImmediatePropagationStopped
(
)
)
{
if
(
!
event
.
rnamespace
|
|
event
.
rnamespace
.
test
(
handleObj
.
namespace
)
)
{
event
.
handleObj
=
handleObj
;
event
.
data
=
handleObj
.
data
;
ret
=
(
(
jQuery
.
event
.
special
[
handleObj
.
origType
]
|
|
{
}
)
.
handle
|
|
handleObj
.
handler
)
.
apply
(
matched
.
elem
args
)
;
if
(
ret
!
=
=
undefined
)
{
if
(
(
event
.
result
=
ret
)
=
=
=
false
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
}
}
}
if
(
special
.
postDispatch
)
{
special
.
postDispatch
.
call
(
this
event
)
;
}
return
event
.
result
;
}
handlers
:
function
(
event
handlers
)
{
var
i
matches
sel
handleObj
handlerQueue
=
[
]
delegateCount
=
handlers
.
delegateCount
cur
=
event
.
target
;
if
(
delegateCount
&
&
cur
.
nodeType
&
&
(
event
.
type
!
=
=
"
click
"
|
|
isNaN
(
event
.
button
)
|
|
event
.
button
<
1
)
)
{
for
(
;
cur
!
=
=
this
;
cur
=
cur
.
parentNode
|
|
this
)
{
if
(
cur
.
nodeType
=
=
=
1
&
&
(
cur
.
disabled
!
=
=
true
|
|
event
.
type
!
=
=
"
click
"
)
)
{
matches
=
[
]
;
for
(
i
=
0
;
i
<
delegateCount
;
i
+
+
)
{
handleObj
=
handlers
[
i
]
;
sel
=
handleObj
.
selector
+
"
"
;
if
(
matches
[
sel
]
=
=
=
undefined
)
{
matches
[
sel
]
=
handleObj
.
needsContext
?
jQuery
(
sel
this
)
.
index
(
cur
)
>
-
1
:
jQuery
.
find
(
sel
this
null
[
cur
]
)
.
length
;
}
if
(
matches
[
sel
]
)
{
matches
.
push
(
handleObj
)
;
}
}
if
(
matches
.
length
)
{
handlerQueue
.
push
(
{
elem
:
cur
handlers
:
matches
}
)
;
}
}
}
}
if
(
delegateCount
<
handlers
.
length
)
{
handlerQueue
.
push
(
{
elem
:
this
handlers
:
handlers
.
slice
(
delegateCount
)
}
)
;
}
return
handlerQueue
;
}
props
:
(
"
altKey
bubbles
cancelable
ctrlKey
currentTarget
detail
eventPhase
"
+
"
metaKey
relatedTarget
shiftKey
target
timeStamp
view
which
"
)
.
split
(
"
"
)
fixHooks
:
{
}
keyHooks
:
{
props
:
"
char
charCode
key
keyCode
"
.
split
(
"
"
)
filter
:
function
(
event
original
)
{
if
(
event
.
which
=
=
null
)
{
event
.
which
=
original
.
charCode
!
=
null
?
original
.
charCode
:
original
.
keyCode
;
}
return
event
;
}
}
mouseHooks
:
{
props
:
(
"
button
buttons
clientX
clientY
offsetX
offsetY
pageX
pageY
"
+
"
screenX
screenY
toElement
"
)
.
split
(
"
"
)
filter
:
function
(
event
original
)
{
var
eventDoc
doc
body
button
=
original
.
button
;
if
(
event
.
pageX
=
=
null
&
&
original
.
clientX
!
=
null
)
{
eventDoc
=
event
.
target
.
ownerDocument
|
|
document
;
doc
=
eventDoc
.
documentElement
;
body
=
eventDoc
.
body
;
event
.
pageX
=
original
.
clientX
+
(
doc
&
&
doc
.
scrollLeft
|
|
body
&
&
body
.
scrollLeft
|
|
0
)
-
(
doc
&
&
doc
.
clientLeft
|
|
body
&
&
body
.
clientLeft
|
|
0
)
;
event
.
pageY
=
original
.
clientY
+
(
doc
&
&
doc
.
scrollTop
|
|
body
&
&
body
.
scrollTop
|
|
0
)
-
(
doc
&
&
doc
.
clientTop
|
|
body
&
&
body
.
clientTop
|
|
0
)
;
}
if
(
!
event
.
which
&
&
button
!
=
=
undefined
)
{
event
.
which
=
(
button
&
1
?
1
:
(
button
&
2
?
3
:
(
button
&
4
?
2
:
0
)
)
)
;
}
return
event
;
}
}
fix
:
function
(
event
)
{
if
(
event
[
jQuery
.
expando
]
)
{
return
event
;
}
var
i
prop
copy
type
=
event
.
type
originalEvent
=
event
fixHook
=
this
.
fixHooks
[
type
]
;
if
(
!
fixHook
)
{
this
.
fixHooks
[
type
]
=
fixHook
=
rmouseEvent
.
test
(
type
)
?
this
.
mouseHooks
:
rkeyEvent
.
test
(
type
)
?
this
.
keyHooks
:
{
}
;
}
copy
=
fixHook
.
props
?
this
.
props
.
concat
(
fixHook
.
props
)
:
this
.
props
;
event
=
new
jQuery
.
Event
(
originalEvent
)
;
i
=
copy
.
length
;
while
(
i
-
-
)
{
prop
=
copy
[
i
]
;
event
[
prop
]
=
originalEvent
[
prop
]
;
}
if
(
!
event
.
target
)
{
event
.
target
=
document
;
}
if
(
event
.
target
.
nodeType
=
=
=
3
)
{
event
.
target
=
event
.
target
.
parentNode
;
}
return
fixHook
.
filter
?
fixHook
.
filter
(
event
originalEvent
)
:
event
;
}
special
:
{
load
:
{
noBubble
:
true
}
focus
:
{
trigger
:
function
(
)
{
if
(
this
!
=
=
safeActiveElement
(
)
&
&
this
.
focus
)
{
this
.
focus
(
)
;
return
false
;
}
}
delegateType
:
"
focusin
"
}
blur
:
{
trigger
:
function
(
)
{
if
(
this
=
=
=
safeActiveElement
(
)
&
&
this
.
blur
)
{
this
.
blur
(
)
;
return
false
;
}
}
delegateType
:
"
focusout
"
}
click
:
{
trigger
:
function
(
)
{
if
(
this
.
type
=
=
=
"
checkbox
"
&
&
this
.
click
&
&
jQuery
.
nodeName
(
this
"
input
"
)
)
{
this
.
click
(
)
;
return
false
;
}
}
_default
:
function
(
event
)
{
return
jQuery
.
nodeName
(
event
.
target
"
a
"
)
;
}
}
beforeunload
:
{
postDispatch
:
function
(
event
)
{
if
(
event
.
result
!
=
=
undefined
&
&
event
.
originalEvent
)
{
event
.
originalEvent
.
returnValue
=
event
.
result
;
}
}
}
}
}
;
jQuery
.
removeEvent
=
function
(
elem
type
handle
)
{
if
(
elem
.
removeEventListener
)
{
elem
.
removeEventListener
(
type
handle
)
;
}
}
;
jQuery
.
Event
=
function
(
src
props
)
{
if
(
!
(
this
instanceof
jQuery
.
Event
)
)
{
return
new
jQuery
.
Event
(
src
props
)
;
}
if
(
src
&
&
src
.
type
)
{
this
.
originalEvent
=
src
;
this
.
type
=
src
.
type
;
this
.
isDefaultPrevented
=
src
.
defaultPrevented
|
|
src
.
defaultPrevented
=
=
=
undefined
&
&
src
.
returnValue
=
=
=
false
?
returnTrue
:
returnFalse
;
}
else
{
this
.
type
=
src
;
}
if
(
props
)
{
jQuery
.
extend
(
this
props
)
;
}
this
.
timeStamp
=
src
&
&
src
.
timeStamp
|
|
jQuery
.
now
(
)
;
this
[
jQuery
.
expando
]
=
true
;
}
;
jQuery
.
Event
.
prototype
=
{
constructor
:
jQuery
.
Event
isDefaultPrevented
:
returnFalse
isPropagationStopped
:
returnFalse
isImmediatePropagationStopped
:
returnFalse
isSimulated
:
false
preventDefault
:
function
(
)
{
var
e
=
this
.
originalEvent
;
this
.
isDefaultPrevented
=
returnTrue
;
if
(
e
&
&
!
this
.
isSimulated
)
{
e
.
preventDefault
(
)
;
}
}
stopPropagation
:
function
(
)
{
var
e
=
this
.
originalEvent
;
this
.
isPropagationStopped
=
returnTrue
;
if
(
e
&
&
!
this
.
isSimulated
)
{
e
.
stopPropagation
(
)
;
}
}
stopImmediatePropagation
:
function
(
)
{
var
e
=
this
.
originalEvent
;
this
.
isImmediatePropagationStopped
=
returnTrue
;
if
(
e
&
&
!
this
.
isSimulated
)
{
e
.
stopImmediatePropagation
(
)
;
}
this
.
stopPropagation
(
)
;
}
}
;
jQuery
.
each
(
{
mouseenter
:
"
mouseover
"
mouseleave
:
"
mouseout
"
pointerenter
:
"
pointerover
"
pointerleave
:
"
pointerout
"
}
function
(
orig
fix
)
{
jQuery
.
event
.
special
[
orig
]
=
{
delegateType
:
fix
bindType
:
fix
handle
:
function
(
event
)
{
var
ret
target
=
this
related
=
event
.
relatedTarget
handleObj
=
event
.
handleObj
;
if
(
!
related
|
|
(
related
!
=
=
target
&
&
!
jQuery
.
contains
(
target
related
)
)
)
{
event
.
type
=
handleObj
.
origType
;
ret
=
handleObj
.
handler
.
apply
(
this
arguments
)
;
event
.
type
=
fix
;
}
return
ret
;
}
}
;
}
)
;
jQuery
.
fn
.
extend
(
{
on
:
function
(
types
selector
data
fn
)
{
return
on
(
this
types
selector
data
fn
)
;
}
one
:
function
(
types
selector
data
fn
)
{
return
on
(
this
types
selector
data
fn
1
)
;
}
off
:
function
(
types
selector
fn
)
{
var
handleObj
type
;
if
(
types
&
&
types
.
preventDefault
&
&
types
.
handleObj
)
{
handleObj
=
types
.
handleObj
;
jQuery
(
types
.
delegateTarget
)
.
off
(
handleObj
.
namespace
?
handleObj
.
origType
+
"
.
"
+
handleObj
.
namespace
:
handleObj
.
origType
handleObj
.
selector
handleObj
.
handler
)
;
return
this
;
}
if
(
typeof
types
=
=
=
"
object
"
)
{
for
(
type
in
types
)
{
this
.
off
(
type
selector
types
[
type
]
)
;
}
return
this
;
}
if
(
selector
=
=
=
false
|
|
typeof
selector
=
=
=
"
function
"
)
{
fn
=
selector
;
selector
=
undefined
;
}
if
(
fn
=
=
=
false
)
{
fn
=
returnFalse
;
}
return
this
.
each
(
function
(
)
{
jQuery
.
event
.
remove
(
this
types
fn
selector
)
;
}
)
;
}
}
)
;
var
rxhtmlTag
=
/
<
(
?
!
area
|
br
|
col
|
embed
|
hr
|
img
|
input
|
link
|
meta
|
param
)
(
(
[
\
w
:
-
]
+
)
[
^
>
]
*
)
\
/
>
/
gi
rnoInnerhtml
=
/
<
script
|
<
style
|
<
link
/
i
rchecked
=
/
checked
\
s
*
(
?
:
[
^
=
]
|
=
\
s
*
.
checked
.
)
/
i
rscriptTypeMasked
=
/
^
true
\
/
(
.
*
)
/
rcleanScript
=
/
^
\
s
*
<
!
(
?
:
\
[
CDATA
\
[
|
-
-
)
|
(
?
:
\
]
\
]
|
-
-
)
>
\
s
*
/
g
;
function
manipulationTarget
(
elem
content
)
{
return
jQuery
.
nodeName
(
elem
"
table
"
)
&
&
jQuery
.
nodeName
(
content
.
nodeType
!
=
=
11
?
content
:
content
.
firstChild
"
tr
"
)
?
elem
.
getElementsByTagName
(
"
tbody
"
)
[
0
]
|
|
elem
.
appendChild
(
elem
.
ownerDocument
.
createElement
(
"
tbody
"
)
)
:
elem
;
}
function
disableScript
(
elem
)
{
elem
.
type
=
(
elem
.
getAttribute
(
"
type
"
)
!
=
=
null
)
+
"
/
"
+
elem
.
type
;
return
elem
;
}
function
restoreScript
(
elem
)
{
var
match
=
rscriptTypeMasked
.
exec
(
elem
.
type
)
;
if
(
match
)
{
elem
.
type
=
match
[
1
]
;
}
else
{
elem
.
removeAttribute
(
"
type
"
)
;
}
return
elem
;
}
function
cloneCopyEvent
(
src
dest
)
{
var
i
l
type
pdataOld
pdataCur
udataOld
udataCur
events
;
if
(
dest
.
nodeType
!
=
=
1
)
{
return
;
}
if
(
dataPriv
.
hasData
(
src
)
)
{
pdataOld
=
dataPriv
.
access
(
src
)
;
pdataCur
=
dataPriv
.
set
(
dest
pdataOld
)
;
events
=
pdataOld
.
events
;
if
(
events
)
{
delete
pdataCur
.
handle
;
pdataCur
.
events
=
{
}
;
for
(
type
in
events
)
{
for
(
i
=
0
l
=
events
[
type
]
.
length
;
i
<
l
;
i
+
+
)
{
jQuery
.
event
.
add
(
dest
type
events
[
type
]
[
i
]
)
;
}
}
}
}
if
(
dataUser
.
hasData
(
src
)
)
{
udataOld
=
dataUser
.
access
(
src
)
;
udataCur
=
jQuery
.
extend
(
{
}
udataOld
)
;
dataUser
.
set
(
dest
udataCur
)
;
}
}
function
fixInput
(
src
dest
)
{
var
nodeName
=
dest
.
nodeName
.
toLowerCase
(
)
;
if
(
nodeName
=
=
=
"
input
"
&
&
rcheckableType
.
test
(
src
.
type
)
)
{
dest
.
checked
=
src
.
checked
;
}
else
if
(
nodeName
=
=
=
"
input
"
|
|
nodeName
=
=
=
"
textarea
"
)
{
dest
.
defaultValue
=
src
.
defaultValue
;
}
}
function
domManip
(
collection
args
callback
ignored
)
{
args
=
concat
.
apply
(
[
]
args
)
;
var
fragment
first
scripts
hasScripts
node
doc
i
=
0
l
=
collection
.
length
iNoClone
=
l
-
1
value
=
args
[
0
]
isFunction
=
jQuery
.
isFunction
(
value
)
;
if
(
isFunction
|
|
(
l
>
1
&
&
typeof
value
=
=
=
"
string
"
&
&
!
support
.
checkClone
&
&
rchecked
.
test
(
value
)
)
)
{
return
collection
.
each
(
function
(
index
)
{
var
self
=
collection
.
eq
(
index
)
;
if
(
isFunction
)
{
args
[
0
]
=
value
.
call
(
this
index
self
.
html
(
)
)
;
}
domManip
(
self
args
callback
ignored
)
;
}
)
;
}
if
(
l
)
{
fragment
=
buildFragment
(
args
collection
[
0
]
.
ownerDocument
false
collection
ignored
)
;
first
=
fragment
.
firstChild
;
if
(
fragment
.
childNodes
.
length
=
=
=
1
)
{
fragment
=
first
;
}
if
(
first
|
|
ignored
)
{
scripts
=
jQuery
.
map
(
getAll
(
fragment
"
script
"
)
disableScript
)
;
hasScripts
=
scripts
.
length
;
for
(
;
i
<
l
;
i
+
+
)
{
node
=
fragment
;
if
(
i
!
=
=
iNoClone
)
{
node
=
jQuery
.
clone
(
node
true
true
)
;
if
(
hasScripts
)
{
jQuery
.
merge
(
scripts
getAll
(
node
"
script
"
)
)
;
}
}
callback
.
call
(
collection
[
i
]
node
i
)
;
}
if
(
hasScripts
)
{
doc
=
scripts
[
scripts
.
length
-
1
]
.
ownerDocument
;
jQuery
.
map
(
scripts
restoreScript
)
;
for
(
i
=
0
;
i
<
hasScripts
;
i
+
+
)
{
node
=
scripts
[
i
]
;
if
(
rscriptType
.
test
(
node
.
type
|
|
"
"
)
&
&
!
dataPriv
.
access
(
node
"
globalEval
"
)
&
&
jQuery
.
contains
(
doc
node
)
)
{
if
(
node
.
src
)
{
if
(
jQuery
.
_evalUrl
)
{
jQuery
.
_evalUrl
(
node
.
src
)
;
}
}
else
{
jQuery
.
globalEval
(
node
.
textContent
.
replace
(
rcleanScript
"
"
)
)
;
}
}
}
}
}
}
return
collection
;
}
function
remove
(
elem
selector
keepData
)
{
var
node
nodes
=
selector
?
jQuery
.
filter
(
selector
elem
)
:
elem
i
=
0
;
for
(
;
(
node
=
nodes
[
i
]
)
!
=
null
;
i
+
+
)
{
if
(
!
keepData
&
&
node
.
nodeType
=
=
=
1
)
{
jQuery
.
cleanData
(
getAll
(
node
)
)
;
}
if
(
node
.
parentNode
)
{
if
(
keepData
&
&
jQuery
.
contains
(
node
.
ownerDocument
node
)
)
{
setGlobalEval
(
getAll
(
node
"
script
"
)
)
;
}
node
.
parentNode
.
removeChild
(
node
)
;
}
}
return
elem
;
}
jQuery
.
extend
(
{
htmlPrefilter
:
function
(
html
)
{
return
html
.
replace
(
rxhtmlTag
"
<
1
>
<
/
2
>
"
)
;
}
clone
:
function
(
elem
dataAndEvents
deepDataAndEvents
)
{
var
i
l
srcElements
destElements
clone
=
elem
.
cloneNode
(
true
)
inPage
=
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
;
if
(
!
support
.
noCloneChecked
&
&
(
elem
.
nodeType
=
=
=
1
|
|
elem
.
nodeType
=
=
=
11
)
&
&
!
jQuery
.
isXMLDoc
(
elem
)
)
{
destElements
=
getAll
(
clone
)
;
srcElements
=
getAll
(
elem
)
;
for
(
i
=
0
l
=
srcElements
.
length
;
i
<
l
;
i
+
+
)
{
fixInput
(
srcElements
[
i
]
destElements
[
i
]
)
;
}
}
if
(
dataAndEvents
)
{
if
(
deepDataAndEvents
)
{
srcElements
=
srcElements
|
|
getAll
(
elem
)
;
destElements
=
destElements
|
|
getAll
(
clone
)
;
for
(
i
=
0
l
=
srcElements
.
length
;
i
<
l
;
i
+
+
)
{
cloneCopyEvent
(
srcElements
[
i
]
destElements
[
i
]
)
;
}
}
else
{
cloneCopyEvent
(
elem
clone
)
;
}
}
destElements
=
getAll
(
clone
"
script
"
)
;
if
(
destElements
.
length
>
0
)
{
setGlobalEval
(
destElements
!
inPage
&
&
getAll
(
elem
"
script
"
)
)
;
}
return
clone
;
}
cleanData
:
function
(
elems
)
{
var
data
elem
type
special
=
jQuery
.
event
.
special
i
=
0
;
for
(
;
(
elem
=
elems
[
i
]
)
!
=
=
undefined
;
i
+
+
)
{
if
(
acceptData
(
elem
)
)
{
if
(
(
data
=
elem
[
dataPriv
.
expando
]
)
)
{
if
(
data
.
events
)
{
for
(
type
in
data
.
events
)
{
if
(
special
[
type
]
)
{
jQuery
.
event
.
remove
(
elem
type
)
;
}
else
{
jQuery
.
removeEvent
(
elem
type
data
.
handle
)
;
}
}
}
elem
[
dataPriv
.
expando
]
=
undefined
;
}
if
(
elem
[
dataUser
.
expando
]
)
{
elem
[
dataUser
.
expando
]
=
undefined
;
}
}
}
}
}
)
;
jQuery
.
fn
.
extend
(
{
domManip
:
domManip
detach
:
function
(
selector
)
{
return
remove
(
this
selector
true
)
;
}
remove
:
function
(
selector
)
{
return
remove
(
this
selector
)
;
}
text
:
function
(
value
)
{
return
access
(
this
function
(
value
)
{
return
value
=
=
=
undefined
?
jQuery
.
text
(
this
)
:
this
.
empty
(
)
.
each
(
function
(
)
{
if
(
this
.
nodeType
=
=
=
1
|
|
this
.
nodeType
=
=
=
11
|
|
this
.
nodeType
=
=
=
9
)
{
this
.
textContent
=
value
;
}
}
)
;
}
null
value
arguments
.
length
)
;
}
append
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
nodeType
=
=
=
1
|
|
this
.
nodeType
=
=
=
11
|
|
this
.
nodeType
=
=
=
9
)
{
var
target
=
manipulationTarget
(
this
elem
)
;
target
.
appendChild
(
elem
)
;
}
}
)
;
}
prepend
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
nodeType
=
=
=
1
|
|
this
.
nodeType
=
=
=
11
|
|
this
.
nodeType
=
=
=
9
)
{
var
target
=
manipulationTarget
(
this
elem
)
;
target
.
insertBefore
(
elem
target
.
firstChild
)
;
}
}
)
;
}
before
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
parentNode
)
{
this
.
parentNode
.
insertBefore
(
elem
this
)
;
}
}
)
;
}
after
:
function
(
)
{
return
domManip
(
this
arguments
function
(
elem
)
{
if
(
this
.
parentNode
)
{
this
.
parentNode
.
insertBefore
(
elem
this
.
nextSibling
)
;
}
}
)
;
}
empty
:
function
(
)
{
var
elem
i
=
0
;
for
(
;
(
elem
=
this
[
i
]
)
!
=
null
;
i
+
+
)
{
if
(
elem
.
nodeType
=
=
=
1
)
{
jQuery
.
cleanData
(
getAll
(
elem
false
)
)
;
elem
.
textContent
=
"
"
;
}
}
return
this
;
}
clone
:
function
(
dataAndEvents
deepDataAndEvents
)
{
dataAndEvents
=
dataAndEvents
=
=
null
?
false
:
dataAndEvents
;
deepDataAndEvents
=
deepDataAndEvents
=
=
null
?
dataAndEvents
:
deepDataAndEvents
;
return
this
.
map
(
function
(
)
{
return
jQuery
.
clone
(
this
dataAndEvents
deepDataAndEvents
)
;
}
)
;
}
html
:
function
(
value
)
{
return
access
(
this
function
(
value
)
{
var
elem
=
this
[
0
]
|
|
{
}
i
=
0
l
=
this
.
length
;
if
(
value
=
=
=
undefined
&
&
elem
.
nodeType
=
=
=
1
)
{
return
elem
.
innerHTML
;
}
if
(
typeof
value
=
=
=
"
string
"
&
&
!
rnoInnerhtml
.
test
(
value
)
&
&
!
wrapMap
[
(
rtagName
.
exec
(
value
)
|
|
[
"
"
"
"
]
)
[
1
]
.
toLowerCase
(
)
]
)
{
value
=
jQuery
.
htmlPrefilter
(
value
)
;
try
{
for
(
;
i
<
l
;
i
+
+
)
{
elem
=
this
[
i
]
|
|
{
}
;
if
(
elem
.
nodeType
=
=
=
1
)
{
jQuery
.
cleanData
(
getAll
(
elem
false
)
)
;
elem
.
innerHTML
=
value
;
}
}
elem
=
0
;
}
catch
(
e
)
{
}
}
if
(
elem
)
{
this
.
empty
(
)
.
append
(
value
)
;
}
}
null
value
arguments
.
length
)
;
}
replaceWith
:
function
(
)
{
var
ignored
=
[
]
;
return
domManip
(
this
arguments
function
(
elem
)
{
var
parent
=
this
.
parentNode
;
if
(
jQuery
.
inArray
(
this
ignored
)
<
0
)
{
jQuery
.
cleanData
(
getAll
(
this
)
)
;
if
(
parent
)
{
parent
.
replaceChild
(
elem
this
)
;
}
}
}
ignored
)
;
}
}
)
;
jQuery
.
each
(
{
appendTo
:
"
append
"
prependTo
:
"
prepend
"
insertBefore
:
"
before
"
insertAfter
:
"
after
"
replaceAll
:
"
replaceWith
"
}
function
(
name
original
)
{
jQuery
.
fn
[
name
]
=
function
(
selector
)
{
var
elems
ret
=
[
]
insert
=
jQuery
(
selector
)
last
=
insert
.
length
-
1
i
=
0
;
for
(
;
i
<
=
last
;
i
+
+
)
{
elems
=
i
=
=
=
last
?
this
:
this
.
clone
(
true
)
;
jQuery
(
insert
[
i
]
)
[
original
]
(
elems
)
;
push
.
apply
(
ret
elems
.
get
(
)
)
;
}
return
this
.
pushStack
(
ret
)
;
}
;
}
)
;
var
iframe
elemdisplay
=
{
HTML
:
"
block
"
BODY
:
"
block
"
}
;
function
actualDisplay
(
name
doc
)
{
var
elem
=
jQuery
(
doc
.
createElement
(
name
)
)
.
appendTo
(
doc
.
body
)
display
=
jQuery
.
css
(
elem
[
0
]
"
display
"
)
;
elem
.
detach
(
)
;
return
display
;
}
function
defaultDisplay
(
nodeName
)
{
var
doc
=
document
display
=
elemdisplay
[
nodeName
]
;
if
(
!
display
)
{
display
=
actualDisplay
(
nodeName
doc
)
;
if
(
display
=
=
=
"
none
"
|
|
!
display
)
{
iframe
=
(
iframe
|
|
jQuery
(
"
<
iframe
frameborder
=
'
0
'
width
=
'
0
'
height
=
'
0
'
/
>
"
)
)
.
appendTo
(
doc
.
documentElement
)
;
doc
=
iframe
[
0
]
.
contentDocument
;
doc
.
write
(
)
;
doc
.
close
(
)
;
display
=
actualDisplay
(
nodeName
doc
)
;
iframe
.
detach
(
)
;
}
elemdisplay
[
nodeName
]
=
display
;
}
return
display
;
}
var
rmargin
=
(
/
^
margin
/
)
;
var
rnumnonpx
=
new
RegExp
(
"
^
(
"
+
pnum
+
"
)
(
?
!
px
)
[
a
-
z
%
]
+
"
"
i
"
)
;
var
getStyles
=
function
(
elem
)
{
var
view
=
elem
.
ownerDocument
.
defaultView
;
if
(
!
view
|
|
!
view
.
opener
)
{
view
=
window
;
}
return
view
.
getComputedStyle
(
elem
)
;
}
;
var
swap
=
function
(
elem
options
callback
args
)
{
var
ret
name
old
=
{
}
;
for
(
name
in
options
)
{
old
[
name
]
=
elem
.
style
[
name
]
;
elem
.
style
[
name
]
=
options
[
name
]
;
}
ret
=
callback
.
apply
(
elem
args
|
|
[
]
)
;
for
(
name
in
options
)
{
elem
.
style
[
name
]
=
old
[
name
]
;
}
return
ret
;
}
;
var
documentElement
=
document
.
documentElement
;
(
function
(
)
{
var
pixelPositionVal
boxSizingReliableVal
pixelMarginRightVal
reliableMarginLeftVal
container
=
document
.
createElement
(
"
div
"
)
div
=
document
.
createElement
(
"
div
"
)
;
if
(
!
div
.
style
)
{
return
;
}
div
.
style
.
backgroundClip
=
"
content
-
box
"
;
div
.
cloneNode
(
true
)
.
style
.
backgroundClip
=
"
"
;
support
.
clearCloneStyle
=
div
.
style
.
backgroundClip
=
=
=
"
content
-
box
"
;
container
.
style
.
cssText
=
"
border
:
0
;
width
:
8px
;
height
:
0
;
top
:
0
;
left
:
-
9999px
;
"
+
"
padding
:
0
;
margin
-
top
:
1px
;
position
:
absolute
"
;
container
.
appendChild
(
div
)
;
function
computeStyleTests
(
)
{
div
.
style
.
cssText
=
"
-
webkit
-
box
-
sizing
:
border
-
box
;
-
moz
-
box
-
sizing
:
border
-
box
;
box
-
sizing
:
border
-
box
;
"
+
"
position
:
relative
;
display
:
block
;
"
+
"
margin
:
auto
;
border
:
1px
;
padding
:
1px
;
"
+
"
top
:
1
%
;
width
:
50
%
"
;
div
.
innerHTML
=
"
"
;
documentElement
.
appendChild
(
container
)
;
var
divStyle
=
window
.
getComputedStyle
(
div
)
;
pixelPositionVal
=
divStyle
.
top
!
=
=
"
1
%
"
;
reliableMarginLeftVal
=
divStyle
.
marginLeft
=
=
=
"
2px
"
;
boxSizingReliableVal
=
divStyle
.
width
=
=
=
"
4px
"
;
div
.
style
.
marginRight
=
"
50
%
"
;
pixelMarginRightVal
=
divStyle
.
marginRight
=
=
=
"
4px
"
;
documentElement
.
removeChild
(
container
)
;
}
jQuery
.
extend
(
support
{
pixelPosition
:
function
(
)
{
computeStyleTests
(
)
;
return
pixelPositionVal
;
}
boxSizingReliable
:
function
(
)
{
if
(
boxSizingReliableVal
=
=
null
)
{
computeStyleTests
(
)
;
}
return
boxSizingReliableVal
;
}
pixelMarginRight
:
function
(
)
{
if
(
boxSizingReliableVal
=
=
null
)
{
computeStyleTests
(
)
;
}
return
pixelMarginRightVal
;
}
reliableMarginLeft
:
function
(
)
{
if
(
boxSizingReliableVal
=
=
null
)
{
computeStyleTests
(
)
;
}
return
reliableMarginLeftVal
;
}
reliableMarginRight
:
function
(
)
{
var
ret
marginDiv
=
div
.
appendChild
(
document
.
createElement
(
"
div
"
)
)
;
marginDiv
.
style
.
cssText
=
div
.
style
.
cssText
=
"
-
webkit
-
box
-
sizing
:
content
-
box
;
box
-
sizing
:
content
-
box
;
"
+
"
display
:
block
;
margin
:
0
;
border
:
0
;
padding
:
0
"
;
marginDiv
.
style
.
marginRight
=
marginDiv
.
style
.
width
=
"
0
"
;
div
.
style
.
width
=
"
1px
"
;
documentElement
.
appendChild
(
container
)
;
ret
=
!
parseFloat
(
window
.
getComputedStyle
(
marginDiv
)
.
marginRight
)
;
documentElement
.
removeChild
(
container
)
;
div
.
removeChild
(
marginDiv
)
;
return
ret
;
}
}
)
;
}
)
(
)
;
function
curCSS
(
elem
name
computed
)
{
var
width
minWidth
maxWidth
ret
style
=
elem
.
style
;
computed
=
computed
|
|
getStyles
(
elem
)
;
ret
=
computed
?
computed
.
getPropertyValue
(
name
)
|
|
computed
[
name
]
:
undefined
;
if
(
(
ret
=
=
=
"
"
|
|
ret
=
=
=
undefined
)
&
&
!
jQuery
.
contains
(
elem
.
ownerDocument
elem
)
)
{
ret
=
jQuery
.
style
(
elem
name
)
;
}
if
(
computed
)
{
if
(
!
support
.
pixelMarginRight
(
)
&
&
rnumnonpx
.
test
(
ret
)
&
&
rmargin
.
test
(
name
)
)
{
width
=
style
.
width
;
minWidth
=
style
.
minWidth
;
maxWidth
=
style
.
maxWidth
;
style
.
minWidth
=
style
.
maxWidth
=
style
.
width
=
ret
;
ret
=
computed
.
width
;
style
.
width
=
width
;
style
.
minWidth
=
minWidth
;
style
.
maxWidth
=
maxWidth
;
}
}
return
ret
!
=
=
undefined
?
ret
+
"
"
:
ret
;
}
function
addGetHookIf
(
conditionFn
hookFn
)
{
return
{
get
:
function
(
)
{
if
(
conditionFn
(
)
)
{
delete
this
.
get
;
return
;
}
return
(
this
.
get
=
hookFn
)
.
apply
(
this
arguments
)
;
}
}
;
}
var
rdisplayswap
=
/
^
(
none
|
table
(
?
!
-
c
[
ea
]
)
.
+
)
/
cssShow
=
{
position
:
"
absolute
"
visibility
:
"
hidden
"
display
:
"
block
"
}
cssNormalTransform
=
{
letterSpacing
:
"
0
"
fontWeight
:
"
400
"
}
cssPrefixes
=
[
"
Webkit
"
"
O
"
"
Moz
"
"
ms
"
]
emptyStyle
=
document
.
createElement
(
"
div
"
)
.
style
;
function
vendorPropName
(
name
)
{
if
(
name
in
emptyStyle
)
{
return
name
;
}
var
capName
=
name
[
0
]
.
toUpperCase
(
)
+
name
.
slice
(
1
)
i
=
cssPrefixes
.
length
;
while
(
i
-
-
)
{
name
=
cssPrefixes
[
i
]
+
capName
;
if
(
name
in
emptyStyle
)
{
return
name
;
}
}
}
function
setPositiveNumber
(
elem
value
subtract
)
{
var
matches
=
rcssNum
.
exec
(
value
)
;
return
matches
?
Math
.
max
(
0
matches
[
2
]
-
(
subtract
|
|
0
)
)
+
(
matches
[
3
]
|
|
"
px
"
)
:
value
;
}
function
augmentWidthOrHeight
(
elem
name
extra
isBorderBox
styles
)
{
var
i
=
extra
=
=
=
(
isBorderBox
?
"
border
"
:
"
content
"
)
?
4
:
name
=
=
=
"
width
"
?
1
:
0
val
=
0
;
for
(
;
i
<
4
;
i
+
=
2
)
{
if
(
extra
=
=
=
"
margin
"
)
{
val
+
=
jQuery
.
css
(
elem
extra
+
cssExpand
[
i
]
true
styles
)
;
}
if
(
isBorderBox
)
{
if
(
extra
=
=
=
"
content
"
)
{
val
-
=
jQuery
.
css
(
elem
"
padding
"
+
cssExpand
[
i
]
true
styles
)
;
}
if
(
extra
!
=
=
"
margin
"
)
{
val
-
=
jQuery
.
css
(
elem
"
border
"
+
cssExpand
[
i
]
+
"
Width
"
true
styles
)
;
}
}
else
{
val
+
=
jQuery
.
css
(
elem
"
padding
"
+
cssExpand
[
i
]
true
styles
)
;
if
(
extra
!
=
=
"
padding
"
)
{
val
+
=
jQuery
.
css
(
elem
"
border
"
+
cssExpand
[
i
]
+
"
Width
"
true
styles
)
;
}
}
}
return
val
;
}
function
getWidthOrHeight
(
elem
name
extra
)
{
var
valueIsBorderBox
=
true
val
=
name
=
=
=
"
width
"
?
elem
.
offsetWidth
:
elem
.
offsetHeight
styles
=
getStyles
(
elem
)
isBorderBox
=
jQuery
.
css
(
elem
"
boxSizing
"
false
styles
)
=
=
=
"
border
-
box
"
;
if
(
val
<
=
0
|
|
val
=
=
null
)
{
val
=
curCSS
(
elem
name
styles
)
;
if
(
val
<
0
|
|
val
=
=
null
)
{
val
=
elem
.
style
[
name
]
;
}
if
(
rnumnonpx
.
test
(
val
)
)
{
return
val
;
}
valueIsBorderBox
=
isBorderBox
&
&
(
support
.
boxSizingReliable
(
)
|
|
val
=
=
=
elem
.
style
[
name
]
)
;
val
=
parseFloat
(
val
)
|
|
0
;
}
return
(
val
+
augmentWidthOrHeight
(
elem
name
extra
|
|
(
isBorderBox
?
"
border
"
:
"
content
"
)
valueIsBorderBox
styles
)
)
+
"
px
"
;
}
function
showHide
(
elements
show
)
{
var
display
elem
hidden
values
=
[
]
index
=
0
length
=
elements
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
elem
=
elements
[
index
]
;
if
(
!
elem
.
style
)
{
continue
;
}
values
[
index
]
=
dataPriv
.
get
(
elem
"
olddisplay
"
)
;
display
=
elem
.
style
.
display
;
if
(
show
)
{
if
(
!
values
[
index
]
&
&
display
=
=
=
"
none
"
)
{
elem
.
style
.
display
=
"
"
;
}
if
(
elem
.
style
.
display
=
=
=
"
"
&
&
isHidden
(
elem
)
)
{
values
[
index
]
=
dataPriv
.
access
(
elem
"
olddisplay
"
defaultDisplay
(
elem
.
nodeName
)
)
;
}
}
else
{
hidden
=
isHidden
(
elem
)
;
if
(
display
!
=
=
"
none
"
|
|
!
hidden
)
{
dataPriv
.
set
(
elem
"
olddisplay
"
hidden
?
display
:
jQuery
.
css
(
elem
"
display
"
)
)
;
}
}
}
for
(
index
=
0
;
index
<
length
;
index
+
+
)
{
elem
=
elements
[
index
]
;
if
(
!
elem
.
style
)
{
continue
;
}
if
(
!
show
|
|
elem
.
style
.
display
=
=
=
"
none
"
|
|
elem
.
style
.
display
=
=
=
"
"
)
{
elem
.
style
.
display
=
show
?
values
[
index
]
|
|
"
"
:
"
none
"
;
}
}
return
elements
;
}
jQuery
.
extend
(
{
cssHooks
:
{
opacity
:
{
get
:
function
(
elem
computed
)
{
if
(
computed
)
{
var
ret
=
curCSS
(
elem
"
opacity
"
)
;
return
ret
=
=
=
"
"
?
"
1
"
:
ret
;
}
}
}
}
cssNumber
:
{
"
animationIterationCount
"
:
true
"
columnCount
"
:
true
"
fillOpacity
"
:
true
"
flexGrow
"
:
true
"
flexShrink
"
:
true
"
fontWeight
"
:
true
"
lineHeight
"
:
true
"
opacity
"
:
true
"
order
"
:
true
"
orphans
"
:
true
"
widows
"
:
true
"
zIndex
"
:
true
"
zoom
"
:
true
}
cssProps
:
{
"
float
"
:
"
cssFloat
"
}
style
:
function
(
elem
name
value
extra
)
{
if
(
!
elem
|
|
elem
.
nodeType
=
=
=
3
|
|
elem
.
nodeType
=
=
=
8
|
|
!
elem
.
style
)
{
return
;
}
var
ret
type
hooks
origName
=
jQuery
.
camelCase
(
name
)
style
=
elem
.
style
;
name
=
jQuery
.
cssProps
[
origName
]
|
|
(
jQuery
.
cssProps
[
origName
]
=
vendorPropName
(
origName
)
|
|
origName
)
;
hooks
=
jQuery
.
cssHooks
[
name
]
|
|
jQuery
.
cssHooks
[
origName
]
;
if
(
value
!
=
=
undefined
)
{
type
=
typeof
value
;
if
(
type
=
=
=
"
string
"
&
&
(
ret
=
rcssNum
.
exec
(
value
)
)
&
&
ret
[
1
]
)
{
value
=
adjustCSS
(
elem
name
ret
)
;
type
=
"
number
"
;
}
if
(
value
=
=
null
|
|
value
!
=
=
value
)
{
return
;
}
if
(
type
=
=
=
"
number
"
)
{
value
+
=
ret
&
&
ret
[
3
]
|
|
(
jQuery
.
cssNumber
[
origName
]
?
"
"
:
"
px
"
)
;
}
if
(
!
support
.
clearCloneStyle
&
&
value
=
=
=
"
"
&
&
name
.
indexOf
(
"
background
"
)
=
=
=
0
)
{
style
[
name
]
=
"
inherit
"
;
}
if
(
!
hooks
|
|
!
(
"
set
"
in
hooks
)
|
|
(
value
=
hooks
.
set
(
elem
value
extra
)
)
!
=
=
undefined
)
{
style
[
name
]
=
value
;
}
}
else
{
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
false
extra
)
)
!
=
=
undefined
)
{
return
ret
;
}
return
style
[
name
]
;
}
}
css
:
function
(
elem
name
extra
styles
)
{
var
val
num
hooks
origName
=
jQuery
.
camelCase
(
name
)
;
name
=
jQuery
.
cssProps
[
origName
]
|
|
(
jQuery
.
cssProps
[
origName
]
=
vendorPropName
(
origName
)
|
|
origName
)
;
hooks
=
jQuery
.
cssHooks
[
name
]
|
|
jQuery
.
cssHooks
[
origName
]
;
if
(
hooks
&
&
"
get
"
in
hooks
)
{
val
=
hooks
.
get
(
elem
true
extra
)
;
}
if
(
val
=
=
=
undefined
)
{
val
=
curCSS
(
elem
name
styles
)
;
}
if
(
val
=
=
=
"
normal
"
&
&
name
in
cssNormalTransform
)
{
val
=
cssNormalTransform
[
name
]
;
}
if
(
extra
=
=
=
"
"
|
|
extra
)
{
num
=
parseFloat
(
val
)
;
return
extra
=
=
=
true
|
|
isFinite
(
num
)
?
num
|
|
0
:
val
;
}
return
val
;
}
}
)
;
jQuery
.
each
(
[
"
height
"
"
width
"
]
function
(
i
name
)
{
jQuery
.
cssHooks
[
name
]
=
{
get
:
function
(
elem
computed
extra
)
{
if
(
computed
)
{
return
rdisplayswap
.
test
(
jQuery
.
css
(
elem
"
display
"
)
)
&
&
elem
.
offsetWidth
=
=
=
0
?
swap
(
elem
cssShow
function
(
)
{
return
getWidthOrHeight
(
elem
name
extra
)
;
}
)
:
getWidthOrHeight
(
elem
name
extra
)
;
}
}
set
:
function
(
elem
value
extra
)
{
var
matches
styles
=
extra
&
&
getStyles
(
elem
)
subtract
=
extra
&
&
augmentWidthOrHeight
(
elem
name
extra
jQuery
.
css
(
elem
"
boxSizing
"
false
styles
)
=
=
=
"
border
-
box
"
styles
)
;
if
(
subtract
&
&
(
matches
=
rcssNum
.
exec
(
value
)
)
&
&
(
matches
[
3
]
|
|
"
px
"
)
!
=
=
"
px
"
)
{
elem
.
style
[
name
]
=
value
;
value
=
jQuery
.
css
(
elem
name
)
;
}
return
setPositiveNumber
(
elem
value
subtract
)
;
}
}
;
}
)
;
jQuery
.
cssHooks
.
marginLeft
=
addGetHookIf
(
support
.
reliableMarginLeft
function
(
elem
computed
)
{
if
(
computed
)
{
return
(
parseFloat
(
curCSS
(
elem
"
marginLeft
"
)
)
|
|
elem
.
getBoundingClientRect
(
)
.
left
-
swap
(
elem
{
marginLeft
:
0
}
function
(
)
{
return
elem
.
getBoundingClientRect
(
)
.
left
;
}
)
)
+
"
px
"
;
}
}
)
;
jQuery
.
cssHooks
.
marginRight
=
addGetHookIf
(
support
.
reliableMarginRight
function
(
elem
computed
)
{
if
(
computed
)
{
return
swap
(
elem
{
"
display
"
:
"
inline
-
block
"
}
curCSS
[
elem
"
marginRight
"
]
)
;
}
}
)
;
jQuery
.
each
(
{
margin
:
"
"
padding
:
"
"
border
:
"
Width
"
}
function
(
prefix
suffix
)
{
jQuery
.
cssHooks
[
prefix
+
suffix
]
=
{
expand
:
function
(
value
)
{
var
i
=
0
expanded
=
{
}
parts
=
typeof
value
=
=
=
"
string
"
?
value
.
split
(
"
"
)
:
[
value
]
;
for
(
;
i
<
4
;
i
+
+
)
{
expanded
[
prefix
+
cssExpand
[
i
]
+
suffix
]
=
parts
[
i
]
|
|
parts
[
i
-
2
]
|
|
parts
[
0
]
;
}
return
expanded
;
}
}
;
if
(
!
rmargin
.
test
(
prefix
)
)
{
jQuery
.
cssHooks
[
prefix
+
suffix
]
.
set
=
setPositiveNumber
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
css
:
function
(
name
value
)
{
return
access
(
this
function
(
elem
name
value
)
{
var
styles
len
map
=
{
}
i
=
0
;
if
(
jQuery
.
isArray
(
name
)
)
{
styles
=
getStyles
(
elem
)
;
len
=
name
.
length
;
for
(
;
i
<
len
;
i
+
+
)
{
map
[
name
[
i
]
]
=
jQuery
.
css
(
elem
name
[
i
]
false
styles
)
;
}
return
map
;
}
return
value
!
=
=
undefined
?
jQuery
.
style
(
elem
name
value
)
:
jQuery
.
css
(
elem
name
)
;
}
name
value
arguments
.
length
>
1
)
;
}
show
:
function
(
)
{
return
showHide
(
this
true
)
;
}
hide
:
function
(
)
{
return
showHide
(
this
)
;
}
toggle
:
function
(
state
)
{
if
(
typeof
state
=
=
=
"
boolean
"
)
{
return
state
?
this
.
show
(
)
:
this
.
hide
(
)
;
}
return
this
.
each
(
function
(
)
{
if
(
isHidden
(
this
)
)
{
jQuery
(
this
)
.
show
(
)
;
}
else
{
jQuery
(
this
)
.
hide
(
)
;
}
}
)
;
}
}
)
;
function
Tween
(
elem
options
prop
end
easing
)
{
return
new
Tween
.
prototype
.
init
(
elem
options
prop
end
easing
)
;
}
jQuery
.
Tween
=
Tween
;
Tween
.
prototype
=
{
constructor
:
Tween
init
:
function
(
elem
options
prop
end
easing
unit
)
{
this
.
elem
=
elem
;
this
.
prop
=
prop
;
this
.
easing
=
easing
|
|
jQuery
.
easing
.
_default
;
this
.
options
=
options
;
this
.
start
=
this
.
now
=
this
.
cur
(
)
;
this
.
end
=
end
;
this
.
unit
=
unit
|
|
(
jQuery
.
cssNumber
[
prop
]
?
"
"
:
"
px
"
)
;
}
cur
:
function
(
)
{
var
hooks
=
Tween
.
propHooks
[
this
.
prop
]
;
return
hooks
&
&
hooks
.
get
?
hooks
.
get
(
this
)
:
Tween
.
propHooks
.
_default
.
get
(
this
)
;
}
run
:
function
(
percent
)
{
var
eased
hooks
=
Tween
.
propHooks
[
this
.
prop
]
;
if
(
this
.
options
.
duration
)
{
this
.
pos
=
eased
=
jQuery
.
easing
[
this
.
easing
]
(
percent
this
.
options
.
duration
*
percent
0
1
this
.
options
.
duration
)
;
}
else
{
this
.
pos
=
eased
=
percent
;
}
this
.
now
=
(
this
.
end
-
this
.
start
)
*
eased
+
this
.
start
;
if
(
this
.
options
.
step
)
{
this
.
options
.
step
.
call
(
this
.
elem
this
.
now
this
)
;
}
if
(
hooks
&
&
hooks
.
set
)
{
hooks
.
set
(
this
)
;
}
else
{
Tween
.
propHooks
.
_default
.
set
(
this
)
;
}
return
this
;
}
}
;
Tween
.
prototype
.
init
.
prototype
=
Tween
.
prototype
;
Tween
.
propHooks
=
{
_default
:
{
get
:
function
(
tween
)
{
var
result
;
if
(
tween
.
elem
.
nodeType
!
=
=
1
|
|
tween
.
elem
[
tween
.
prop
]
!
=
null
&
&
tween
.
elem
.
style
[
tween
.
prop
]
=
=
null
)
{
return
tween
.
elem
[
tween
.
prop
]
;
}
result
=
jQuery
.
css
(
tween
.
elem
tween
.
prop
"
"
)
;
return
!
result
|
|
result
=
=
=
"
auto
"
?
0
:
result
;
}
set
:
function
(
tween
)
{
if
(
jQuery
.
fx
.
step
[
tween
.
prop
]
)
{
jQuery
.
fx
.
step
[
tween
.
prop
]
(
tween
)
;
}
else
if
(
tween
.
elem
.
nodeType
=
=
=
1
&
&
(
tween
.
elem
.
style
[
jQuery
.
cssProps
[
tween
.
prop
]
]
!
=
null
|
|
jQuery
.
cssHooks
[
tween
.
prop
]
)
)
{
jQuery
.
style
(
tween
.
elem
tween
.
prop
tween
.
now
+
tween
.
unit
)
;
}
else
{
tween
.
elem
[
tween
.
prop
]
=
tween
.
now
;
}
}
}
}
;
Tween
.
propHooks
.
scrollTop
=
Tween
.
propHooks
.
scrollLeft
=
{
set
:
function
(
tween
)
{
if
(
tween
.
elem
.
nodeType
&
&
tween
.
elem
.
parentNode
)
{
tween
.
elem
[
tween
.
prop
]
=
tween
.
now
;
}
}
}
;
jQuery
.
easing
=
{
linear
:
function
(
p
)
{
return
p
;
}
swing
:
function
(
p
)
{
return
0
.
5
-
Math
.
cos
(
p
*
Math
.
PI
)
/
2
;
}
_default
:
"
swing
"
}
;
jQuery
.
fx
=
Tween
.
prototype
.
init
;
jQuery
.
fx
.
step
=
{
}
;
var
fxNow
timerId
rfxtypes
=
/
^
(
?
:
toggle
|
show
|
hide
)
/
rrun
=
/
queueHooks
/
;
function
createFxNow
(
)
{
window
.
setTimeout
(
function
(
)
{
fxNow
=
undefined
;
}
)
;
return
(
fxNow
=
jQuery
.
now
(
)
)
;
}
function
genFx
(
type
includeWidth
)
{
var
which
i
=
0
attrs
=
{
height
:
type
}
;
includeWidth
=
includeWidth
?
1
:
0
;
for
(
;
i
<
4
;
i
+
=
2
-
includeWidth
)
{
which
=
cssExpand
[
i
]
;
attrs
[
"
margin
"
+
which
]
=
attrs
[
"
padding
"
+
which
]
=
type
;
}
if
(
includeWidth
)
{
attrs
.
opacity
=
attrs
.
width
=
type
;
}
return
attrs
;
}
function
createTween
(
value
prop
animation
)
{
var
tween
collection
=
(
Animation
.
tweeners
[
prop
]
|
|
[
]
)
.
concat
(
Animation
.
tweeners
[
"
*
"
]
)
index
=
0
length
=
collection
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
if
(
(
tween
=
collection
[
index
]
.
call
(
animation
prop
value
)
)
)
{
return
tween
;
}
}
}
function
defaultPrefilter
(
elem
props
opts
)
{
var
prop
value
toggle
tween
hooks
oldfire
display
checkDisplay
anim
=
this
orig
=
{
}
style
=
elem
.
style
hidden
=
elem
.
nodeType
&
&
isHidden
(
elem
)
dataShow
=
dataPriv
.
get
(
elem
"
fxshow
"
)
;
if
(
!
opts
.
queue
)
{
hooks
=
jQuery
.
_queueHooks
(
elem
"
fx
"
)
;
if
(
hooks
.
unqueued
=
=
null
)
{
hooks
.
unqueued
=
0
;
oldfire
=
hooks
.
empty
.
fire
;
hooks
.
empty
.
fire
=
function
(
)
{
if
(
!
hooks
.
unqueued
)
{
oldfire
(
)
;
}
}
;
}
hooks
.
unqueued
+
+
;
anim
.
always
(
function
(
)
{
anim
.
always
(
function
(
)
{
hooks
.
unqueued
-
-
;
if
(
!
jQuery
.
queue
(
elem
"
fx
"
)
.
length
)
{
hooks
.
empty
.
fire
(
)
;
}
}
)
;
}
)
;
}
if
(
elem
.
nodeType
=
=
=
1
&
&
(
"
height
"
in
props
|
|
"
width
"
in
props
)
)
{
opts
.
overflow
=
[
style
.
overflow
style
.
overflowX
style
.
overflowY
]
;
display
=
jQuery
.
css
(
elem
"
display
"
)
;
checkDisplay
=
display
=
=
=
"
none
"
?
dataPriv
.
get
(
elem
"
olddisplay
"
)
|
|
defaultDisplay
(
elem
.
nodeName
)
:
display
;
if
(
checkDisplay
=
=
=
"
inline
"
&
&
jQuery
.
css
(
elem
"
float
"
)
=
=
=
"
none
"
)
{
style
.
display
=
"
inline
-
block
"
;
}
}
if
(
opts
.
overflow
)
{
style
.
overflow
=
"
hidden
"
;
anim
.
always
(
function
(
)
{
style
.
overflow
=
opts
.
overflow
[
0
]
;
style
.
overflowX
=
opts
.
overflow
[
1
]
;
style
.
overflowY
=
opts
.
overflow
[
2
]
;
}
)
;
}
for
(
prop
in
props
)
{
value
=
props
[
prop
]
;
if
(
rfxtypes
.
exec
(
value
)
)
{
delete
props
[
prop
]
;
toggle
=
toggle
|
|
value
=
=
=
"
toggle
"
;
if
(
value
=
=
=
(
hidden
?
"
hide
"
:
"
show
"
)
)
{
if
(
value
=
=
=
"
show
"
&
&
dataShow
&
&
dataShow
[
prop
]
!
=
=
undefined
)
{
hidden
=
true
;
}
else
{
continue
;
}
}
orig
[
prop
]
=
dataShow
&
&
dataShow
[
prop
]
|
|
jQuery
.
style
(
elem
prop
)
;
}
else
{
display
=
undefined
;
}
}
if
(
!
jQuery
.
isEmptyObject
(
orig
)
)
{
if
(
dataShow
)
{
if
(
"
hidden
"
in
dataShow
)
{
hidden
=
dataShow
.
hidden
;
}
}
else
{
dataShow
=
dataPriv
.
access
(
elem
"
fxshow
"
{
}
)
;
}
if
(
toggle
)
{
dataShow
.
hidden
=
!
hidden
;
}
if
(
hidden
)
{
jQuery
(
elem
)
.
show
(
)
;
}
else
{
anim
.
done
(
function
(
)
{
jQuery
(
elem
)
.
hide
(
)
;
}
)
;
}
anim
.
done
(
function
(
)
{
var
prop
;
dataPriv
.
remove
(
elem
"
fxshow
"
)
;
for
(
prop
in
orig
)
{
jQuery
.
style
(
elem
prop
orig
[
prop
]
)
;
}
}
)
;
for
(
prop
in
orig
)
{
tween
=
createTween
(
hidden
?
dataShow
[
prop
]
:
0
prop
anim
)
;
if
(
!
(
prop
in
dataShow
)
)
{
dataShow
[
prop
]
=
tween
.
start
;
if
(
hidden
)
{
tween
.
end
=
tween
.
start
;
tween
.
start
=
prop
=
=
=
"
width
"
|
|
prop
=
=
=
"
height
"
?
1
:
0
;
}
}
}
}
else
if
(
(
display
=
=
=
"
none
"
?
defaultDisplay
(
elem
.
nodeName
)
:
display
)
=
=
=
"
inline
"
)
{
style
.
display
=
display
;
}
}
function
propFilter
(
props
specialEasing
)
{
var
index
name
easing
value
hooks
;
for
(
index
in
props
)
{
name
=
jQuery
.
camelCase
(
index
)
;
easing
=
specialEasing
[
name
]
;
value
=
props
[
index
]
;
if
(
jQuery
.
isArray
(
value
)
)
{
easing
=
value
[
1
]
;
value
=
props
[
index
]
=
value
[
0
]
;
}
if
(
index
!
=
=
name
)
{
props
[
name
]
=
value
;
delete
props
[
index
]
;
}
hooks
=
jQuery
.
cssHooks
[
name
]
;
if
(
hooks
&
&
"
expand
"
in
hooks
)
{
value
=
hooks
.
expand
(
value
)
;
delete
props
[
name
]
;
for
(
index
in
value
)
{
if
(
!
(
index
in
props
)
)
{
props
[
index
]
=
value
[
index
]
;
specialEasing
[
index
]
=
easing
;
}
}
}
else
{
specialEasing
[
name
]
=
easing
;
}
}
}
function
Animation
(
elem
properties
options
)
{
var
result
stopped
index
=
0
length
=
Animation
.
prefilters
.
length
deferred
=
jQuery
.
Deferred
(
)
.
always
(
function
(
)
{
delete
tick
.
elem
;
}
)
tick
=
function
(
)
{
if
(
stopped
)
{
return
false
;
}
var
currentTime
=
fxNow
|
|
createFxNow
(
)
remaining
=
Math
.
max
(
0
animation
.
startTime
+
animation
.
duration
-
currentTime
)
temp
=
remaining
/
animation
.
duration
|
|
0
percent
=
1
-
temp
index
=
0
length
=
animation
.
tweens
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
animation
.
tweens
[
index
]
.
run
(
percent
)
;
}
deferred
.
notifyWith
(
elem
[
animation
percent
remaining
]
)
;
if
(
percent
<
1
&
&
length
)
{
return
remaining
;
}
else
{
deferred
.
resolveWith
(
elem
[
animation
]
)
;
return
false
;
}
}
animation
=
deferred
.
promise
(
{
elem
:
elem
props
:
jQuery
.
extend
(
{
}
properties
)
opts
:
jQuery
.
extend
(
true
{
specialEasing
:
{
}
easing
:
jQuery
.
easing
.
_default
}
options
)
originalProperties
:
properties
originalOptions
:
options
startTime
:
fxNow
|
|
createFxNow
(
)
duration
:
options
.
duration
tweens
:
[
]
createTween
:
function
(
prop
end
)
{
var
tween
=
jQuery
.
Tween
(
elem
animation
.
opts
prop
end
animation
.
opts
.
specialEasing
[
prop
]
|
|
animation
.
opts
.
easing
)
;
animation
.
tweens
.
push
(
tween
)
;
return
tween
;
}
stop
:
function
(
gotoEnd
)
{
var
index
=
0
length
=
gotoEnd
?
animation
.
tweens
.
length
:
0
;
if
(
stopped
)
{
return
this
;
}
stopped
=
true
;
for
(
;
index
<
length
;
index
+
+
)
{
animation
.
tweens
[
index
]
.
run
(
1
)
;
}
if
(
gotoEnd
)
{
deferred
.
notifyWith
(
elem
[
animation
1
0
]
)
;
deferred
.
resolveWith
(
elem
[
animation
gotoEnd
]
)
;
}
else
{
deferred
.
rejectWith
(
elem
[
animation
gotoEnd
]
)
;
}
return
this
;
}
}
)
props
=
animation
.
props
;
propFilter
(
props
animation
.
opts
.
specialEasing
)
;
for
(
;
index
<
length
;
index
+
+
)
{
result
=
Animation
.
prefilters
[
index
]
.
call
(
animation
elem
props
animation
.
opts
)
;
if
(
result
)
{
if
(
jQuery
.
isFunction
(
result
.
stop
)
)
{
jQuery
.
_queueHooks
(
animation
.
elem
animation
.
opts
.
queue
)
.
stop
=
jQuery
.
proxy
(
result
.
stop
result
)
;
}
return
result
;
}
}
jQuery
.
map
(
props
createTween
animation
)
;
if
(
jQuery
.
isFunction
(
animation
.
opts
.
start
)
)
{
animation
.
opts
.
start
.
call
(
elem
animation
)
;
}
jQuery
.
fx
.
timer
(
jQuery
.
extend
(
tick
{
elem
:
elem
anim
:
animation
queue
:
animation
.
opts
.
queue
}
)
)
;
return
animation
.
progress
(
animation
.
opts
.
progress
)
.
done
(
animation
.
opts
.
done
animation
.
opts
.
complete
)
.
fail
(
animation
.
opts
.
fail
)
.
always
(
animation
.
opts
.
always
)
;
}
jQuery
.
Animation
=
jQuery
.
extend
(
Animation
{
tweeners
:
{
"
*
"
:
[
function
(
prop
value
)
{
var
tween
=
this
.
createTween
(
prop
value
)
;
adjustCSS
(
tween
.
elem
prop
rcssNum
.
exec
(
value
)
tween
)
;
return
tween
;
}
]
}
tweener
:
function
(
props
callback
)
{
if
(
jQuery
.
isFunction
(
props
)
)
{
callback
=
props
;
props
=
[
"
*
"
]
;
}
else
{
props
=
props
.
match
(
rnotwhite
)
;
}
var
prop
index
=
0
length
=
props
.
length
;
for
(
;
index
<
length
;
index
+
+
)
{
prop
=
props
[
index
]
;
Animation
.
tweeners
[
prop
]
=
Animation
.
tweeners
[
prop
]
|
|
[
]
;
Animation
.
tweeners
[
prop
]
.
unshift
(
callback
)
;
}
}
prefilters
:
[
defaultPrefilter
]
prefilter
:
function
(
callback
prepend
)
{
if
(
prepend
)
{
Animation
.
prefilters
.
unshift
(
callback
)
;
}
else
{
Animation
.
prefilters
.
push
(
callback
)
;
}
}
}
)
;
jQuery
.
speed
=
function
(
speed
easing
fn
)
{
var
opt
=
speed
&
&
typeof
speed
=
=
=
"
object
"
?
jQuery
.
extend
(
{
}
speed
)
:
{
complete
:
fn
|
|
!
fn
&
&
easing
|
|
jQuery
.
isFunction
(
speed
)
&
&
speed
duration
:
speed
easing
:
fn
&
&
easing
|
|
easing
&
&
!
jQuery
.
isFunction
(
easing
)
&
&
easing
}
;
opt
.
duration
=
jQuery
.
fx
.
off
?
0
:
typeof
opt
.
duration
=
=
=
"
number
"
?
opt
.
duration
:
opt
.
duration
in
jQuery
.
fx
.
speeds
?
jQuery
.
fx
.
speeds
[
opt
.
duration
]
:
jQuery
.
fx
.
speeds
.
_default
;
if
(
opt
.
queue
=
=
null
|
|
opt
.
queue
=
=
=
true
)
{
opt
.
queue
=
"
fx
"
;
}
opt
.
old
=
opt
.
complete
;
opt
.
complete
=
function
(
)
{
if
(
jQuery
.
isFunction
(
opt
.
old
)
)
{
opt
.
old
.
call
(
this
)
;
}
if
(
opt
.
queue
)
{
jQuery
.
dequeue
(
this
opt
.
queue
)
;
}
}
;
return
opt
;
}
;
jQuery
.
fn
.
extend
(
{
fadeTo
:
function
(
speed
to
easing
callback
)
{
return
this
.
filter
(
isHidden
)
.
css
(
"
opacity
"
0
)
.
show
(
)
.
end
(
)
.
animate
(
{
opacity
:
to
}
speed
easing
callback
)
;
}
animate
:
function
(
prop
speed
easing
callback
)
{
var
empty
=
jQuery
.
isEmptyObject
(
prop
)
optall
=
jQuery
.
speed
(
speed
easing
callback
)
doAnimation
=
function
(
)
{
var
anim
=
Animation
(
this
jQuery
.
extend
(
{
}
prop
)
optall
)
;
if
(
empty
|
|
dataPriv
.
get
(
this
"
finish
"
)
)
{
anim
.
stop
(
true
)
;
}
}
;
doAnimation
.
finish
=
doAnimation
;
return
empty
|
|
optall
.
queue
=
=
=
false
?
this
.
each
(
doAnimation
)
:
this
.
queue
(
optall
.
queue
doAnimation
)
;
}
stop
:
function
(
type
clearQueue
gotoEnd
)
{
var
stopQueue
=
function
(
hooks
)
{
var
stop
=
hooks
.
stop
;
delete
hooks
.
stop
;
stop
(
gotoEnd
)
;
}
;
if
(
typeof
type
!
=
=
"
string
"
)
{
gotoEnd
=
clearQueue
;
clearQueue
=
type
;
type
=
undefined
;
}
if
(
clearQueue
&
&
type
!
=
=
false
)
{
this
.
queue
(
type
|
|
"
fx
"
[
]
)
;
}
return
this
.
each
(
function
(
)
{
var
dequeue
=
true
index
=
type
!
=
null
&
&
type
+
"
queueHooks
"
timers
=
jQuery
.
timers
data
=
dataPriv
.
get
(
this
)
;
if
(
index
)
{
if
(
data
[
index
]
&
&
data
[
index
]
.
stop
)
{
stopQueue
(
data
[
index
]
)
;
}
}
else
{
for
(
index
in
data
)
{
if
(
data
[
index
]
&
&
data
[
index
]
.
stop
&
&
rrun
.
test
(
index
)
)
{
stopQueue
(
data
[
index
]
)
;
}
}
}
for
(
index
=
timers
.
length
;
index
-
-
;
)
{
if
(
timers
[
index
]
.
elem
=
=
=
this
&
&
(
type
=
=
null
|
|
timers
[
index
]
.
queue
=
=
=
type
)
)
{
timers
[
index
]
.
anim
.
stop
(
gotoEnd
)
;
dequeue
=
false
;
timers
.
splice
(
index
1
)
;
}
}
if
(
dequeue
|
|
!
gotoEnd
)
{
jQuery
.
dequeue
(
this
type
)
;
}
}
)
;
}
finish
:
function
(
type
)
{
if
(
type
!
=
=
false
)
{
type
=
type
|
|
"
fx
"
;
}
return
this
.
each
(
function
(
)
{
var
index
data
=
dataPriv
.
get
(
this
)
queue
=
data
[
type
+
"
queue
"
]
hooks
=
data
[
type
+
"
queueHooks
"
]
timers
=
jQuery
.
timers
length
=
queue
?
queue
.
length
:
0
;
data
.
finish
=
true
;
jQuery
.
queue
(
this
type
[
]
)
;
if
(
hooks
&
&
hooks
.
stop
)
{
hooks
.
stop
.
call
(
this
true
)
;
}
for
(
index
=
timers
.
length
;
index
-
-
;
)
{
if
(
timers
[
index
]
.
elem
=
=
=
this
&
&
timers
[
index
]
.
queue
=
=
=
type
)
{
timers
[
index
]
.
anim
.
stop
(
true
)
;
timers
.
splice
(
index
1
)
;
}
}
for
(
index
=
0
;
index
<
length
;
index
+
+
)
{
if
(
queue
[
index
]
&
&
queue
[
index
]
.
finish
)
{
queue
[
index
]
.
finish
.
call
(
this
)
;
}
}
delete
data
.
finish
;
}
)
;
}
}
)
;
jQuery
.
each
(
[
"
toggle
"
"
show
"
"
hide
"
]
function
(
i
name
)
{
var
cssFn
=
jQuery
.
fn
[
name
]
;
jQuery
.
fn
[
name
]
=
function
(
speed
easing
callback
)
{
return
speed
=
=
null
|
|
typeof
speed
=
=
=
"
boolean
"
?
cssFn
.
apply
(
this
arguments
)
:
this
.
animate
(
genFx
(
name
true
)
speed
easing
callback
)
;
}
;
}
)
;
jQuery
.
each
(
{
slideDown
:
genFx
(
"
show
"
)
slideUp
:
genFx
(
"
hide
"
)
slideToggle
:
genFx
(
"
toggle
"
)
fadeIn
:
{
opacity
:
"
show
"
}
fadeOut
:
{
opacity
:
"
hide
"
}
fadeToggle
:
{
opacity
:
"
toggle
"
}
}
function
(
name
props
)
{
jQuery
.
fn
[
name
]
=
function
(
speed
easing
callback
)
{
return
this
.
animate
(
props
speed
easing
callback
)
;
}
;
}
)
;
jQuery
.
timers
=
[
]
;
jQuery
.
fx
.
tick
=
function
(
)
{
var
timer
i
=
0
timers
=
jQuery
.
timers
;
fxNow
=
jQuery
.
now
(
)
;
for
(
;
i
<
timers
.
length
;
i
+
+
)
{
timer
=
timers
[
i
]
;
if
(
!
timer
(
)
&
&
timers
[
i
]
=
=
=
timer
)
{
timers
.
splice
(
i
-
-
1
)
;
}
}
if
(
!
timers
.
length
)
{
jQuery
.
fx
.
stop
(
)
;
}
fxNow
=
undefined
;
}
;
jQuery
.
fx
.
timer
=
function
(
timer
)
{
jQuery
.
timers
.
push
(
timer
)
;
if
(
timer
(
)
)
{
jQuery
.
fx
.
start
(
)
;
}
else
{
jQuery
.
timers
.
pop
(
)
;
}
}
;
jQuery
.
fx
.
interval
=
13
;
jQuery
.
fx
.
start
=
function
(
)
{
if
(
!
timerId
)
{
timerId
=
window
.
setInterval
(
jQuery
.
fx
.
tick
jQuery
.
fx
.
interval
)
;
}
}
;
jQuery
.
fx
.
stop
=
function
(
)
{
window
.
clearInterval
(
timerId
)
;
timerId
=
null
;
}
;
jQuery
.
fx
.
speeds
=
{
slow
:
600
fast
:
200
_default
:
400
}
;
jQuery
.
fn
.
delay
=
function
(
time
type
)
{
time
=
jQuery
.
fx
?
jQuery
.
fx
.
speeds
[
time
]
|
|
time
:
time
;
type
=
type
|
|
"
fx
"
;
return
this
.
queue
(
type
function
(
next
hooks
)
{
var
timeout
=
window
.
setTimeout
(
next
time
)
;
hooks
.
stop
=
function
(
)
{
window
.
clearTimeout
(
timeout
)
;
}
;
}
)
;
}
;
(
function
(
)
{
var
input
=
document
.
createElement
(
"
input
"
)
select
=
document
.
createElement
(
"
select
"
)
opt
=
select
.
appendChild
(
document
.
createElement
(
"
option
"
)
)
;
input
.
type
=
"
checkbox
"
;
support
.
checkOn
=
input
.
value
!
=
=
"
"
;
support
.
optSelected
=
opt
.
selected
;
select
.
disabled
=
true
;
support
.
optDisabled
=
!
opt
.
disabled
;
input
=
document
.
createElement
(
"
input
"
)
;
input
.
value
=
"
t
"
;
input
.
type
=
"
radio
"
;
support
.
radioValue
=
input
.
value
=
=
=
"
t
"
;
}
)
(
)
;
var
boolHook
attrHandle
=
jQuery
.
expr
.
attrHandle
;
jQuery
.
fn
.
extend
(
{
attr
:
function
(
name
value
)
{
return
access
(
this
jQuery
.
attr
name
value
arguments
.
length
>
1
)
;
}
removeAttr
:
function
(
name
)
{
return
this
.
each
(
function
(
)
{
jQuery
.
removeAttr
(
this
name
)
;
}
)
;
}
}
)
;
jQuery
.
extend
(
{
attr
:
function
(
elem
name
value
)
{
var
ret
hooks
nType
=
elem
.
nodeType
;
if
(
nType
=
=
=
3
|
|
nType
=
=
=
8
|
|
nType
=
=
=
2
)
{
return
;
}
if
(
typeof
elem
.
getAttribute
=
=
=
"
undefined
"
)
{
return
jQuery
.
prop
(
elem
name
value
)
;
}
if
(
nType
!
=
=
1
|
|
!
jQuery
.
isXMLDoc
(
elem
)
)
{
name
=
name
.
toLowerCase
(
)
;
hooks
=
jQuery
.
attrHooks
[
name
]
|
|
(
jQuery
.
expr
.
match
.
bool
.
test
(
name
)
?
boolHook
:
undefined
)
;
}
if
(
value
!
=
=
undefined
)
{
if
(
value
=
=
=
null
)
{
jQuery
.
removeAttr
(
elem
name
)
;
return
;
}
if
(
hooks
&
&
"
set
"
in
hooks
&
&
(
ret
=
hooks
.
set
(
elem
value
name
)
)
!
=
=
undefined
)
{
return
ret
;
}
elem
.
setAttribute
(
name
value
+
"
"
)
;
return
value
;
}
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
name
)
)
!
=
=
null
)
{
return
ret
;
}
ret
=
jQuery
.
find
.
attr
(
elem
name
)
;
return
ret
=
=
null
?
undefined
:
ret
;
}
attrHooks
:
{
type
:
{
set
:
function
(
elem
value
)
{
if
(
!
support
.
radioValue
&
&
value
=
=
=
"
radio
"
&
&
jQuery
.
nodeName
(
elem
"
input
"
)
)
{
var
val
=
elem
.
value
;
elem
.
setAttribute
(
"
type
"
value
)
;
if
(
val
)
{
elem
.
value
=
val
;
}
return
value
;
}
}
}
}
removeAttr
:
function
(
elem
value
)
{
var
name
propName
i
=
0
attrNames
=
value
&
&
value
.
match
(
rnotwhite
)
;
if
(
attrNames
&
&
elem
.
nodeType
=
=
=
1
)
{
while
(
(
name
=
attrNames
[
i
+
+
]
)
)
{
propName
=
jQuery
.
propFix
[
name
]
|
|
name
;
if
(
jQuery
.
expr
.
match
.
bool
.
test
(
name
)
)
{
elem
[
propName
]
=
false
;
}
elem
.
removeAttribute
(
name
)
;
}
}
}
}
)
;
boolHook
=
{
set
:
function
(
elem
value
name
)
{
if
(
value
=
=
=
false
)
{
jQuery
.
removeAttr
(
elem
name
)
;
}
else
{
elem
.
setAttribute
(
name
name
)
;
}
return
name
;
}
}
;
jQuery
.
each
(
jQuery
.
expr
.
match
.
bool
.
source
.
match
(
/
\
w
+
/
g
)
function
(
i
name
)
{
var
getter
=
attrHandle
[
name
]
|
|
jQuery
.
find
.
attr
;
attrHandle
[
name
]
=
function
(
elem
name
isXML
)
{
var
ret
handle
;
if
(
!
isXML
)
{
handle
=
attrHandle
[
name
]
;
attrHandle
[
name
]
=
ret
;
ret
=
getter
(
elem
name
isXML
)
!
=
null
?
name
.
toLowerCase
(
)
:
null
;
attrHandle
[
name
]
=
handle
;
}
return
ret
;
}
;
}
)
;
var
rfocusable
=
/
^
(
?
:
input
|
select
|
textarea
|
button
)
/
i
rclickable
=
/
^
(
?
:
a
|
area
)
/
i
;
jQuery
.
fn
.
extend
(
{
prop
:
function
(
name
value
)
{
return
access
(
this
jQuery
.
prop
name
value
arguments
.
length
>
1
)
;
}
removeProp
:
function
(
name
)
{
return
this
.
each
(
function
(
)
{
delete
this
[
jQuery
.
propFix
[
name
]
|
|
name
]
;
}
)
;
}
}
)
;
jQuery
.
extend
(
{
prop
:
function
(
elem
name
value
)
{
var
ret
hooks
nType
=
elem
.
nodeType
;
if
(
nType
=
=
=
3
|
|
nType
=
=
=
8
|
|
nType
=
=
=
2
)
{
return
;
}
if
(
nType
!
=
=
1
|
|
!
jQuery
.
isXMLDoc
(
elem
)
)
{
name
=
jQuery
.
propFix
[
name
]
|
|
name
;
hooks
=
jQuery
.
propHooks
[
name
]
;
}
if
(
value
!
=
=
undefined
)
{
if
(
hooks
&
&
"
set
"
in
hooks
&
&
(
ret
=
hooks
.
set
(
elem
value
name
)
)
!
=
=
undefined
)
{
return
ret
;
}
return
(
elem
[
name
]
=
value
)
;
}
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
name
)
)
!
=
=
null
)
{
return
ret
;
}
return
elem
[
name
]
;
}
propHooks
:
{
tabIndex
:
{
get
:
function
(
elem
)
{
var
tabindex
=
jQuery
.
find
.
attr
(
elem
"
tabindex
"
)
;
return
tabindex
?
parseInt
(
tabindex
10
)
:
rfocusable
.
test
(
elem
.
nodeName
)
|
|
rclickable
.
test
(
elem
.
nodeName
)
&
&
elem
.
href
?
0
:
-
1
;
}
}
}
propFix
:
{
"
for
"
:
"
htmlFor
"
"
class
"
:
"
className
"
}
}
)
;
if
(
!
support
.
optSelected
)
{
jQuery
.
propHooks
.
selected
=
{
get
:
function
(
elem
)
{
var
parent
=
elem
.
parentNode
;
if
(
parent
&
&
parent
.
parentNode
)
{
parent
.
parentNode
.
selectedIndex
;
}
return
null
;
}
set
:
function
(
elem
)
{
var
parent
=
elem
.
parentNode
;
if
(
parent
)
{
parent
.
selectedIndex
;
if
(
parent
.
parentNode
)
{
parent
.
parentNode
.
selectedIndex
;
}
}
}
}
;
}
jQuery
.
each
(
[
"
tabIndex
"
"
readOnly
"
"
maxLength
"
"
cellSpacing
"
"
cellPadding
"
"
rowSpan
"
"
colSpan
"
"
useMap
"
"
frameBorder
"
"
contentEditable
"
]
function
(
)
{
jQuery
.
propFix
[
this
.
toLowerCase
(
)
]
=
this
;
}
)
;
var
rclass
=
/
[
\
t
\
r
\
n
\
f
]
/
g
;
function
getClass
(
elem
)
{
return
elem
.
getAttribute
&
&
elem
.
getAttribute
(
"
class
"
)
|
|
"
"
;
}
jQuery
.
fn
.
extend
(
{
addClass
:
function
(
value
)
{
var
classes
elem
cur
curValue
clazz
j
finalValue
i
=
0
;
if
(
jQuery
.
isFunction
(
value
)
)
{
return
this
.
each
(
function
(
j
)
{
jQuery
(
this
)
.
addClass
(
value
.
call
(
this
j
getClass
(
this
)
)
)
;
}
)
;
}
if
(
typeof
value
=
=
=
"
string
"
&
&
value
)
{
classes
=
value
.
match
(
rnotwhite
)
|
|
[
]
;
while
(
(
elem
=
this
[
i
+
+
]
)
)
{
curValue
=
getClass
(
elem
)
;
cur
=
elem
.
nodeType
=
=
=
1
&
&
(
"
"
+
curValue
+
"
"
)
.
replace
(
rclass
"
"
)
;
if
(
cur
)
{
j
=
0
;
while
(
(
clazz
=
classes
[
j
+
+
]
)
)
{
if
(
cur
.
indexOf
(
"
"
+
clazz
+
"
"
)
<
0
)
{
cur
+
=
clazz
+
"
"
;
}
}
finalValue
=
jQuery
.
trim
(
cur
)
;
if
(
curValue
!
=
=
finalValue
)
{
elem
.
setAttribute
(
"
class
"
finalValue
)
;
}
}
}
}
return
this
;
}
removeClass
:
function
(
value
)
{
var
classes
elem
cur
curValue
clazz
j
finalValue
i
=
0
;
if
(
jQuery
.
isFunction
(
value
)
)
{
return
this
.
each
(
function
(
j
)
{
jQuery
(
this
)
.
removeClass
(
value
.
call
(
this
j
getClass
(
this
)
)
)
;
}
)
;
}
if
(
!
arguments
.
length
)
{
return
this
.
attr
(
"
class
"
"
"
)
;
}
if
(
typeof
value
=
=
=
"
string
"
&
&
value
)
{
classes
=
value
.
match
(
rnotwhite
)
|
|
[
]
;
while
(
(
elem
=
this
[
i
+
+
]
)
)
{
curValue
=
getClass
(
elem
)
;
cur
=
elem
.
nodeType
=
=
=
1
&
&
(
"
"
+
curValue
+
"
"
)
.
replace
(
rclass
"
"
)
;
if
(
cur
)
{
j
=
0
;
while
(
(
clazz
=
classes
[
j
+
+
]
)
)
{
while
(
cur
.
indexOf
(
"
"
+
clazz
+
"
"
)
>
-
1
)
{
cur
=
cur
.
replace
(
"
"
+
clazz
+
"
"
"
"
)
;
}
}
finalValue
=
jQuery
.
trim
(
cur
)
;
if
(
curValue
!
=
=
finalValue
)
{
elem
.
setAttribute
(
"
class
"
finalValue
)
;
}
}
}
}
return
this
;
}
toggleClass
:
function
(
value
stateVal
)
{
var
type
=
typeof
value
;
if
(
typeof
stateVal
=
=
=
"
boolean
"
&
&
type
=
=
=
"
string
"
)
{
return
stateVal
?
this
.
addClass
(
value
)
:
this
.
removeClass
(
value
)
;
}
if
(
jQuery
.
isFunction
(
value
)
)
{
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
toggleClass
(
value
.
call
(
this
i
getClass
(
this
)
stateVal
)
stateVal
)
;
}
)
;
}
return
this
.
each
(
function
(
)
{
var
className
i
self
classNames
;
if
(
type
=
=
=
"
string
"
)
{
i
=
0
;
self
=
jQuery
(
this
)
;
classNames
=
value
.
match
(
rnotwhite
)
|
|
[
]
;
while
(
(
className
=
classNames
[
i
+
+
]
)
)
{
if
(
self
.
hasClass
(
className
)
)
{
self
.
removeClass
(
className
)
;
}
else
{
self
.
addClass
(
className
)
;
}
}
}
else
if
(
value
=
=
=
undefined
|
|
type
=
=
=
"
boolean
"
)
{
className
=
getClass
(
this
)
;
if
(
className
)
{
dataPriv
.
set
(
this
"
__className__
"
className
)
;
}
if
(
this
.
setAttribute
)
{
this
.
setAttribute
(
"
class
"
className
|
|
value
=
=
=
false
?
"
"
:
dataPriv
.
get
(
this
"
__className__
"
)
|
|
"
"
)
;
}
}
}
)
;
}
hasClass
:
function
(
selector
)
{
var
className
elem
i
=
0
;
className
=
"
"
+
selector
+
"
"
;
while
(
(
elem
=
this
[
i
+
+
]
)
)
{
if
(
elem
.
nodeType
=
=
=
1
&
&
(
"
"
+
getClass
(
elem
)
+
"
"
)
.
replace
(
rclass
"
"
)
.
indexOf
(
className
)
>
-
1
)
{
return
true
;
}
}
return
false
;
}
}
)
;
var
rreturn
=
/
\
r
/
g
rspaces
=
/
[
\
x20
\
t
\
r
\
n
\
f
]
+
/
g
;
jQuery
.
fn
.
extend
(
{
val
:
function
(
value
)
{
var
hooks
ret
isFunction
elem
=
this
[
0
]
;
if
(
!
arguments
.
length
)
{
if
(
elem
)
{
hooks
=
jQuery
.
valHooks
[
elem
.
type
]
|
|
jQuery
.
valHooks
[
elem
.
nodeName
.
toLowerCase
(
)
]
;
if
(
hooks
&
&
"
get
"
in
hooks
&
&
(
ret
=
hooks
.
get
(
elem
"
value
"
)
)
!
=
=
undefined
)
{
return
ret
;
}
ret
=
elem
.
value
;
return
typeof
ret
=
=
=
"
string
"
?
ret
.
replace
(
rreturn
"
"
)
:
ret
=
=
null
?
"
"
:
ret
;
}
return
;
}
isFunction
=
jQuery
.
isFunction
(
value
)
;
return
this
.
each
(
function
(
i
)
{
var
val
;
if
(
this
.
nodeType
!
=
=
1
)
{
return
;
}
if
(
isFunction
)
{
val
=
value
.
call
(
this
i
jQuery
(
this
)
.
val
(
)
)
;
}
else
{
val
=
value
;
}
if
(
val
=
=
null
)
{
val
=
"
"
;
}
else
if
(
typeof
val
=
=
=
"
number
"
)
{
val
+
=
"
"
;
}
else
if
(
jQuery
.
isArray
(
val
)
)
{
val
=
jQuery
.
map
(
val
function
(
value
)
{
return
value
=
=
null
?
"
"
:
value
+
"
"
;
}
)
;
}
hooks
=
jQuery
.
valHooks
[
this
.
type
]
|
|
jQuery
.
valHooks
[
this
.
nodeName
.
toLowerCase
(
)
]
;
if
(
!
hooks
|
|
!
(
"
set
"
in
hooks
)
|
|
hooks
.
set
(
this
val
"
value
"
)
=
=
=
undefined
)
{
this
.
value
=
val
;
}
}
)
;
}
}
)
;
jQuery
.
extend
(
{
valHooks
:
{
option
:
{
get
:
function
(
elem
)
{
var
val
=
jQuery
.
find
.
attr
(
elem
"
value
"
)
;
return
val
!
=
null
?
val
:
jQuery
.
trim
(
jQuery
.
text
(
elem
)
)
.
replace
(
rspaces
"
"
)
;
}
}
select
:
{
get
:
function
(
elem
)
{
var
value
option
options
=
elem
.
options
index
=
elem
.
selectedIndex
one
=
elem
.
type
=
=
=
"
select
-
one
"
|
|
index
<
0
values
=
one
?
null
:
[
]
max
=
one
?
index
+
1
:
options
.
length
i
=
index
<
0
?
max
:
one
?
index
:
0
;
for
(
;
i
<
max
;
i
+
+
)
{
option
=
options
[
i
]
;
if
(
(
option
.
selected
|
|
i
=
=
=
index
)
&
&
(
support
.
optDisabled
?
!
option
.
disabled
:
option
.
getAttribute
(
"
disabled
"
)
=
=
=
null
)
&
&
(
!
option
.
parentNode
.
disabled
|
|
!
jQuery
.
nodeName
(
option
.
parentNode
"
optgroup
"
)
)
)
{
value
=
jQuery
(
option
)
.
val
(
)
;
if
(
one
)
{
return
value
;
}
values
.
push
(
value
)
;
}
}
return
values
;
}
set
:
function
(
elem
value
)
{
var
optionSet
option
options
=
elem
.
options
values
=
jQuery
.
makeArray
(
value
)
i
=
options
.
length
;
while
(
i
-
-
)
{
option
=
options
[
i
]
;
if
(
option
.
selected
=
jQuery
.
inArray
(
jQuery
.
valHooks
.
option
.
get
(
option
)
values
)
>
-
1
)
{
optionSet
=
true
;
}
}
if
(
!
optionSet
)
{
elem
.
selectedIndex
=
-
1
;
}
return
values
;
}
}
}
}
)
;
jQuery
.
each
(
[
"
radio
"
"
checkbox
"
]
function
(
)
{
jQuery
.
valHooks
[
this
]
=
{
set
:
function
(
elem
value
)
{
if
(
jQuery
.
isArray
(
value
)
)
{
return
(
elem
.
checked
=
jQuery
.
inArray
(
jQuery
(
elem
)
.
val
(
)
value
)
>
-
1
)
;
}
}
}
;
if
(
!
support
.
checkOn
)
{
jQuery
.
valHooks
[
this
]
.
get
=
function
(
elem
)
{
return
elem
.
getAttribute
(
"
value
"
)
=
=
=
null
?
"
on
"
:
elem
.
value
;
}
;
}
}
)
;
var
rfocusMorph
=
/
^
(
?
:
focusinfocus
|
focusoutblur
)
/
;
jQuery
.
extend
(
jQuery
.
event
{
trigger
:
function
(
event
data
elem
onlyHandlers
)
{
var
i
cur
tmp
bubbleType
ontype
handle
special
eventPath
=
[
elem
|
|
document
]
type
=
hasOwn
.
call
(
event
"
type
"
)
?
event
.
type
:
event
namespaces
=
hasOwn
.
call
(
event
"
namespace
"
)
?
event
.
namespace
.
split
(
"
.
"
)
:
[
]
;
cur
=
tmp
=
elem
=
elem
|
|
document
;
if
(
elem
.
nodeType
=
=
=
3
|
|
elem
.
nodeType
=
=
=
8
)
{
return
;
}
if
(
rfocusMorph
.
test
(
type
+
jQuery
.
event
.
triggered
)
)
{
return
;
}
if
(
type
.
indexOf
(
"
.
"
)
>
-
1
)
{
namespaces
=
type
.
split
(
"
.
"
)
;
type
=
namespaces
.
shift
(
)
;
namespaces
.
sort
(
)
;
}
ontype
=
type
.
indexOf
(
"
:
"
)
<
0
&
&
"
on
"
+
type
;
event
=
event
[
jQuery
.
expando
]
?
event
:
new
jQuery
.
Event
(
type
typeof
event
=
=
=
"
object
"
&
&
event
)
;
event
.
isTrigger
=
onlyHandlers
?
2
:
3
;
event
.
namespace
=
namespaces
.
join
(
"
.
"
)
;
event
.
rnamespace
=
event
.
namespace
?
new
RegExp
(
"
(
^
|
\
\
.
)
"
+
namespaces
.
join
(
"
\
\
.
(
?
:
.
*
\
\
.
|
)
"
)
+
"
(
\
\
.
|
)
"
)
:
null
;
event
.
result
=
undefined
;
if
(
!
event
.
target
)
{
event
.
target
=
elem
;
}
data
=
data
=
=
null
?
[
event
]
:
jQuery
.
makeArray
(
data
[
event
]
)
;
special
=
jQuery
.
event
.
special
[
type
]
|
|
{
}
;
if
(
!
onlyHandlers
&
&
special
.
trigger
&
&
special
.
trigger
.
apply
(
elem
data
)
=
=
=
false
)
{
return
;
}
if
(
!
onlyHandlers
&
&
!
special
.
noBubble
&
&
!
jQuery
.
isWindow
(
elem
)
)
{
bubbleType
=
special
.
delegateType
|
|
type
;
if
(
!
rfocusMorph
.
test
(
bubbleType
+
type
)
)
{
cur
=
cur
.
parentNode
;
}
for
(
;
cur
;
cur
=
cur
.
parentNode
)
{
eventPath
.
push
(
cur
)
;
tmp
=
cur
;
}
if
(
tmp
=
=
=
(
elem
.
ownerDocument
|
|
document
)
)
{
eventPath
.
push
(
tmp
.
defaultView
|
|
tmp
.
parentWindow
|
|
window
)
;
}
}
i
=
0
;
while
(
(
cur
=
eventPath
[
i
+
+
]
)
&
&
!
event
.
isPropagationStopped
(
)
)
{
event
.
type
=
i
>
1
?
bubbleType
:
special
.
bindType
|
|
type
;
handle
=
(
dataPriv
.
get
(
cur
"
events
"
)
|
|
{
}
)
[
event
.
type
]
&
&
dataPriv
.
get
(
cur
"
handle
"
)
;
if
(
handle
)
{
handle
.
apply
(
cur
data
)
;
}
handle
=
ontype
&
&
cur
[
ontype
]
;
if
(
handle
&
&
handle
.
apply
&
&
acceptData
(
cur
)
)
{
event
.
result
=
handle
.
apply
(
cur
data
)
;
if
(
event
.
result
=
=
=
false
)
{
event
.
preventDefault
(
)
;
}
}
}
event
.
type
=
type
;
if
(
!
onlyHandlers
&
&
!
event
.
isDefaultPrevented
(
)
)
{
if
(
(
!
special
.
_default
|
|
special
.
_default
.
apply
(
eventPath
.
pop
(
)
data
)
=
=
=
false
)
&
&
acceptData
(
elem
)
)
{
if
(
ontype
&
&
jQuery
.
isFunction
(
elem
[
type
]
)
&
&
!
jQuery
.
isWindow
(
elem
)
)
{
tmp
=
elem
[
ontype
]
;
if
(
tmp
)
{
elem
[
ontype
]
=
null
;
}
jQuery
.
event
.
triggered
=
type
;
elem
[
type
]
(
)
;
jQuery
.
event
.
triggered
=
undefined
;
if
(
tmp
)
{
elem
[
ontype
]
=
tmp
;
}
}
}
}
return
event
.
result
;
}
simulate
:
function
(
type
elem
event
)
{
var
e
=
jQuery
.
extend
(
new
jQuery
.
Event
(
)
event
{
type
:
type
isSimulated
:
true
}
)
;
jQuery
.
event
.
trigger
(
e
null
elem
)
;
}
}
)
;
jQuery
.
fn
.
extend
(
{
trigger
:
function
(
type
data
)
{
return
this
.
each
(
function
(
)
{
jQuery
.
event
.
trigger
(
type
data
this
)
;
}
)
;
}
triggerHandler
:
function
(
type
data
)
{
var
elem
=
this
[
0
]
;
if
(
elem
)
{
return
jQuery
.
event
.
trigger
(
type
data
elem
true
)
;
}
}
}
)
;
jQuery
.
each
(
(
"
blur
focus
focusin
focusout
load
resize
scroll
unload
click
dblclick
"
+
"
mousedown
mouseup
mousemove
mouseover
mouseout
mouseenter
mouseleave
"
+
"
change
select
submit
keydown
keypress
keyup
error
contextmenu
"
)
.
split
(
"
"
)
function
(
i
name
)
{
jQuery
.
fn
[
name
]
=
function
(
data
fn
)
{
return
arguments
.
length
>
0
?
this
.
on
(
name
null
data
fn
)
:
this
.
trigger
(
name
)
;
}
;
}
)
;
jQuery
.
fn
.
extend
(
{
hover
:
function
(
fnOver
fnOut
)
{
return
this
.
mouseenter
(
fnOver
)
.
mouseleave
(
fnOut
|
|
fnOver
)
;
}
}
)
;
support
.
focusin
=
"
onfocusin
"
in
window
;
if
(
!
support
.
focusin
)
{
jQuery
.
each
(
{
focus
:
"
focusin
"
blur
:
"
focusout
"
}
function
(
orig
fix
)
{
var
handler
=
function
(
event
)
{
jQuery
.
event
.
simulate
(
fix
event
.
target
jQuery
.
event
.
fix
(
event
)
)
;
}
;
jQuery
.
event
.
special
[
fix
]
=
{
setup
:
function
(
)
{
var
doc
=
this
.
ownerDocument
|
|
this
attaches
=
dataPriv
.
access
(
doc
fix
)
;
if
(
!
attaches
)
{
doc
.
addEventListener
(
orig
handler
true
)
;
}
dataPriv
.
access
(
doc
fix
(
attaches
|
|
0
)
+
1
)
;
}
teardown
:
function
(
)
{
var
doc
=
this
.
ownerDocument
|
|
this
attaches
=
dataPriv
.
access
(
doc
fix
)
-
1
;
if
(
!
attaches
)
{
doc
.
removeEventListener
(
orig
handler
true
)
;
dataPriv
.
remove
(
doc
fix
)
;
}
else
{
dataPriv
.
access
(
doc
fix
attaches
)
;
}
}
}
;
}
)
;
}
var
location
=
window
.
location
;
var
nonce
=
jQuery
.
now
(
)
;
var
rquery
=
(
/
\
?
/
)
;
jQuery
.
parseJSON
=
function
(
data
)
{
return
JSON
.
parse
(
data
+
"
"
)
;
}
;
jQuery
.
parseXML
=
function
(
data
)
{
var
xml
;
if
(
!
data
|
|
typeof
data
!
=
=
"
string
"
)
{
return
null
;
}
try
{
xml
=
(
new
window
.
DOMParser
(
)
)
.
parseFromString
(
data
"
text
/
xml
"
)
;
}
catch
(
e
)
{
xml
=
undefined
;
}
if
(
!
xml
|
|
xml
.
getElementsByTagName
(
"
parsererror
"
)
.
length
)
{
jQuery
.
error
(
"
Invalid
XML
:
"
+
data
)
;
}
return
xml
;
}
;
var
rhash
=
/
#
.
*
/
rts
=
/
(
[
?
&
]
)
_
=
[
^
&
]
*
/
rheaders
=
/
^
(
.
*
?
)
:
[
\
t
]
*
(
[
^
\
r
\
n
]
*
)
/
mg
rlocalProtocol
=
/
^
(
?
:
about
|
app
|
app
-
storage
|
.
+
-
extension
|
file
|
res
|
widget
)
:
/
rnoContent
=
/
^
(
?
:
GET
|
HEAD
)
/
rprotocol
=
/
^
\
/
\
/
/
prefilters
=
{
}
transports
=
{
}
allTypes
=
"
*
/
"
.
concat
(
"
*
"
)
originAnchor
=
document
.
createElement
(
"
a
"
)
;
originAnchor
.
href
=
location
.
href
;
function
addToPrefiltersOrTransports
(
structure
)
{
return
function
(
dataTypeExpression
func
)
{
if
(
typeof
dataTypeExpression
!
=
=
"
string
"
)
{
func
=
dataTypeExpression
;
dataTypeExpression
=
"
*
"
;
}
var
dataType
i
=
0
dataTypes
=
dataTypeExpression
.
toLowerCase
(
)
.
match
(
rnotwhite
)
|
|
[
]
;
if
(
jQuery
.
isFunction
(
func
)
)
{
while
(
(
dataType
=
dataTypes
[
i
+
+
]
)
)
{
if
(
dataType
[
0
]
=
=
=
"
+
"
)
{
dataType
=
dataType
.
slice
(
1
)
|
|
"
*
"
;
(
structure
[
dataType
]
=
structure
[
dataType
]
|
|
[
]
)
.
unshift
(
func
)
;
}
else
{
(
structure
[
dataType
]
=
structure
[
dataType
]
|
|
[
]
)
.
push
(
func
)
;
}
}
}
}
;
}
function
inspectPrefiltersOrTransports
(
structure
options
originalOptions
jqXHR
)
{
var
inspected
=
{
}
seekingTransport
=
(
structure
=
=
=
transports
)
;
function
inspect
(
dataType
)
{
var
selected
;
inspected
[
dataType
]
=
true
;
jQuery
.
each
(
structure
[
dataType
]
|
|
[
]
function
(
_
prefilterOrFactory
)
{
var
dataTypeOrTransport
=
prefilterOrFactory
(
options
originalOptions
jqXHR
)
;
if
(
typeof
dataTypeOrTransport
=
=
=
"
string
"
&
&
!
seekingTransport
&
&
!
inspected
[
dataTypeOrTransport
]
)
{
options
.
dataTypes
.
unshift
(
dataTypeOrTransport
)
;
inspect
(
dataTypeOrTransport
)
;
return
false
;
}
else
if
(
seekingTransport
)
{
return
!
(
selected
=
dataTypeOrTransport
)
;
}
}
)
;
return
selected
;
}
return
inspect
(
options
.
dataTypes
[
0
]
)
|
|
!
inspected
[
"
*
"
]
&
&
inspect
(
"
*
"
)
;
}
function
ajaxExtend
(
target
src
)
{
var
key
deep
flatOptions
=
jQuery
.
ajaxSettings
.
flatOptions
|
|
{
}
;
for
(
key
in
src
)
{
if
(
src
[
key
]
!
=
=
undefined
)
{
(
flatOptions
[
key
]
?
target
:
(
deep
|
|
(
deep
=
{
}
)
)
)
[
key
]
=
src
[
key
]
;
}
}
if
(
deep
)
{
jQuery
.
extend
(
true
target
deep
)
;
}
return
target
;
}
function
ajaxHandleResponses
(
s
jqXHR
responses
)
{
var
ct
type
finalDataType
firstDataType
contents
=
s
.
contents
dataTypes
=
s
.
dataTypes
;
while
(
dataTypes
[
0
]
=
=
=
"
*
"
)
{
dataTypes
.
shift
(
)
;
if
(
ct
=
=
=
undefined
)
{
ct
=
s
.
mimeType
|
|
jqXHR
.
getResponseHeader
(
"
Content
-
Type
"
)
;
}
}
if
(
ct
)
{
for
(
type
in
contents
)
{
if
(
contents
[
type
]
&
&
contents
[
type
]
.
test
(
ct
)
)
{
dataTypes
.
unshift
(
type
)
;
break
;
}
}
}
if
(
dataTypes
[
0
]
in
responses
)
{
finalDataType
=
dataTypes
[
0
]
;
}
else
{
for
(
type
in
responses
)
{
if
(
!
dataTypes
[
0
]
|
|
s
.
converters
[
type
+
"
"
+
dataTypes
[
0
]
]
)
{
finalDataType
=
type
;
break
;
}
if
(
!
firstDataType
)
{
firstDataType
=
type
;
}
}
finalDataType
=
finalDataType
|
|
firstDataType
;
}
if
(
finalDataType
)
{
if
(
finalDataType
!
=
=
dataTypes
[
0
]
)
{
dataTypes
.
unshift
(
finalDataType
)
;
}
return
responses
[
finalDataType
]
;
}
}
function
ajaxConvert
(
s
response
jqXHR
isSuccess
)
{
var
conv2
current
conv
tmp
prev
converters
=
{
}
dataTypes
=
s
.
dataTypes
.
slice
(
)
;
if
(
dataTypes
[
1
]
)
{
for
(
conv
in
s
.
converters
)
{
converters
[
conv
.
toLowerCase
(
)
]
=
s
.
converters
[
conv
]
;
}
}
current
=
dataTypes
.
shift
(
)
;
while
(
current
)
{
if
(
s
.
responseFields
[
current
]
)
{
jqXHR
[
s
.
responseFields
[
current
]
]
=
response
;
}
if
(
!
prev
&
&
isSuccess
&
&
s
.
dataFilter
)
{
response
=
s
.
dataFilter
(
response
s
.
dataType
)
;
}
prev
=
current
;
current
=
dataTypes
.
shift
(
)
;
if
(
current
)
{
if
(
current
=
=
=
"
*
"
)
{
current
=
prev
;
}
else
if
(
prev
!
=
=
"
*
"
&
&
prev
!
=
=
current
)
{
conv
=
converters
[
prev
+
"
"
+
current
]
|
|
converters
[
"
*
"
+
current
]
;
if
(
!
conv
)
{
for
(
conv2
in
converters
)
{
tmp
=
conv2
.
split
(
"
"
)
;
if
(
tmp
[
1
]
=
=
=
current
)
{
conv
=
converters
[
prev
+
"
"
+
tmp
[
0
]
]
|
|
converters
[
"
*
"
+
tmp
[
0
]
]
;
if
(
conv
)
{
if
(
conv
=
=
=
true
)
{
conv
=
converters
[
conv2
]
;
}
else
if
(
converters
[
conv2
]
!
=
=
true
)
{
current
=
tmp
[
0
]
;
dataTypes
.
unshift
(
tmp
[
1
]
)
;
}
break
;
}
}
}
}
if
(
conv
!
=
=
true
)
{
if
(
conv
&
&
s
.
throws
)
{
response
=
conv
(
response
)
;
}
else
{
try
{
response
=
conv
(
response
)
;
}
catch
(
e
)
{
return
{
state
:
"
parsererror
"
error
:
conv
?
e
:
"
No
conversion
from
"
+
prev
+
"
to
"
+
current
}
;
}
}
}
}
}
}
return
{
state
:
"
success
"
data
:
response
}
;
}
jQuery
.
extend
(
{
active
:
0
lastModified
:
{
}
etag
:
{
}
ajaxSettings
:
{
url
:
location
.
href
type
:
"
GET
"
isLocal
:
rlocalProtocol
.
test
(
location
.
protocol
)
global
:
true
processData
:
true
async
:
true
contentType
:
"
application
/
x
-
www
-
form
-
urlencoded
;
charset
=
UTF
-
8
"
accepts
:
{
"
*
"
:
allTypes
text
:
"
text
/
plain
"
html
:
"
text
/
html
"
xml
:
"
application
/
xml
text
/
xml
"
json
:
"
application
/
json
text
/
javascript
"
}
contents
:
{
xml
:
/
\
bxml
\
b
/
html
:
/
\
bhtml
/
json
:
/
\
bjson
\
b
/
}
responseFields
:
{
xml
:
"
responseXML
"
text
:
"
responseText
"
json
:
"
responseJSON
"
}
converters
:
{
"
*
text
"
:
String
"
text
html
"
:
true
"
text
json
"
:
jQuery
.
parseJSON
"
text
xml
"
:
jQuery
.
parseXML
}
flatOptions
:
{
url
:
true
context
:
true
}
}
ajaxSetup
:
function
(
target
settings
)
{
return
settings
?
ajaxExtend
(
ajaxExtend
(
target
jQuery
.
ajaxSettings
)
settings
)
:
ajaxExtend
(
jQuery
.
ajaxSettings
target
)
;
}
ajaxPrefilter
:
addToPrefiltersOrTransports
(
prefilters
)
ajaxTransport
:
addToPrefiltersOrTransports
(
transports
)
ajax
:
function
(
url
options
)
{
if
(
typeof
url
=
=
=
"
object
"
)
{
options
=
url
;
url
=
undefined
;
}
options
=
options
|
|
{
}
;
var
transport
cacheURL
responseHeadersString
responseHeaders
timeoutTimer
urlAnchor
fireGlobals
i
s
=
jQuery
.
ajaxSetup
(
{
}
options
)
callbackContext
=
s
.
context
|
|
s
globalEventContext
=
s
.
context
&
&
(
callbackContext
.
nodeType
|
|
callbackContext
.
jquery
)
?
jQuery
(
callbackContext
)
:
jQuery
.
event
deferred
=
jQuery
.
Deferred
(
)
completeDeferred
=
jQuery
.
Callbacks
(
"
once
memory
"
)
statusCode
=
s
.
statusCode
|
|
{
}
requestHeaders
=
{
}
requestHeadersNames
=
{
}
state
=
0
strAbort
=
"
canceled
"
jqXHR
=
{
readyState
:
0
getResponseHeader
:
function
(
key
)
{
var
match
;
if
(
state
=
=
=
2
)
{
if
(
!
responseHeaders
)
{
responseHeaders
=
{
}
;
while
(
(
match
=
rheaders
.
exec
(
responseHeadersString
)
)
)
{
responseHeaders
[
match
[
1
]
.
toLowerCase
(
)
]
=
match
[
2
]
;
}
}
match
=
responseHeaders
[
key
.
toLowerCase
(
)
]
;
}
return
match
=
=
null
?
null
:
match
;
}
getAllResponseHeaders
:
function
(
)
{
return
state
=
=
=
2
?
responseHeadersString
:
null
;
}
setRequestHeader
:
function
(
name
value
)
{
var
lname
=
name
.
toLowerCase
(
)
;
if
(
!
state
)
{
name
=
requestHeadersNames
[
lname
]
=
requestHeadersNames
[
lname
]
|
|
name
;
requestHeaders
[
name
]
=
value
;
}
return
this
;
}
overrideMimeType
:
function
(
type
)
{
if
(
!
state
)
{
s
.
mimeType
=
type
;
}
return
this
;
}
statusCode
:
function
(
map
)
{
var
code
;
if
(
map
)
{
if
(
state
<
2
)
{
for
(
code
in
map
)
{
statusCode
[
code
]
=
[
statusCode
[
code
]
map
[
code
]
]
;
}
}
else
{
jqXHR
.
always
(
map
[
jqXHR
.
status
]
)
;
}
}
return
this
;
}
abort
:
function
(
statusText
)
{
var
finalText
=
statusText
|
|
strAbort
;
if
(
transport
)
{
transport
.
abort
(
finalText
)
;
}
done
(
0
finalText
)
;
return
this
;
}
}
;
deferred
.
promise
(
jqXHR
)
.
complete
=
completeDeferred
.
add
;
jqXHR
.
success
=
jqXHR
.
done
;
jqXHR
.
error
=
jqXHR
.
fail
;
s
.
url
=
(
(
url
|
|
s
.
url
|
|
location
.
href
)
+
"
"
)
.
replace
(
rhash
"
"
)
.
replace
(
rprotocol
location
.
protocol
+
"
/
/
"
)
;
s
.
type
=
options
.
method
|
|
options
.
type
|
|
s
.
method
|
|
s
.
type
;
s
.
dataTypes
=
jQuery
.
trim
(
s
.
dataType
|
|
"
*
"
)
.
toLowerCase
(
)
.
match
(
rnotwhite
)
|
|
[
"
"
]
;
if
(
s
.
crossDomain
=
=
null
)
{
urlAnchor
=
document
.
createElement
(
"
a
"
)
;
try
{
urlAnchor
.
href
=
s
.
url
;
urlAnchor
.
href
=
urlAnchor
.
href
;
s
.
crossDomain
=
originAnchor
.
protocol
+
"
/
/
"
+
originAnchor
.
host
!
=
=
urlAnchor
.
protocol
+
"
/
/
"
+
urlAnchor
.
host
;
}
catch
(
e
)
{
s
.
crossDomain
=
true
;
}
}
if
(
s
.
data
&
&
s
.
processData
&
&
typeof
s
.
data
!
=
=
"
string
"
)
{
s
.
data
=
jQuery
.
param
(
s
.
data
s
.
traditional
)
;
}
inspectPrefiltersOrTransports
(
prefilters
s
options
jqXHR
)
;
if
(
state
=
=
=
2
)
{
return
jqXHR
;
}
fireGlobals
=
jQuery
.
event
&
&
s
.
global
;
if
(
fireGlobals
&
&
jQuery
.
active
+
+
=
=
=
0
)
{
jQuery
.
event
.
trigger
(
"
ajaxStart
"
)
;
}
s
.
type
=
s
.
type
.
toUpperCase
(
)
;
s
.
hasContent
=
!
rnoContent
.
test
(
s
.
type
)
;
cacheURL
=
s
.
url
;
if
(
!
s
.
hasContent
)
{
if
(
s
.
data
)
{
cacheURL
=
(
s
.
url
+
=
(
rquery
.
test
(
cacheURL
)
?
"
&
"
:
"
?
"
)
+
s
.
data
)
;
delete
s
.
data
;
}
if
(
s
.
cache
=
=
=
false
)
{
s
.
url
=
rts
.
test
(
cacheURL
)
?
cacheURL
.
replace
(
rts
"
1_
=
"
+
nonce
+
+
)
:
cacheURL
+
(
rquery
.
test
(
cacheURL
)
?
"
&
"
:
"
?
"
)
+
"
_
=
"
+
nonce
+
+
;
}
}
if
(
s
.
ifModified
)
{
if
(
jQuery
.
lastModified
[
cacheURL
]
)
{
jqXHR
.
setRequestHeader
(
"
If
-
Modified
-
Since
"
jQuery
.
lastModified
[
cacheURL
]
)
;
}
if
(
jQuery
.
etag
[
cacheURL
]
)
{
jqXHR
.
setRequestHeader
(
"
If
-
None
-
Match
"
jQuery
.
etag
[
cacheURL
]
)
;
}
}
if
(
s
.
data
&
&
s
.
hasContent
&
&
s
.
contentType
!
=
=
false
|
|
options
.
contentType
)
{
jqXHR
.
setRequestHeader
(
"
Content
-
Type
"
s
.
contentType
)
;
}
jqXHR
.
setRequestHeader
(
"
Accept
"
s
.
dataTypes
[
0
]
&
&
s
.
accepts
[
s
.
dataTypes
[
0
]
]
?
s
.
accepts
[
s
.
dataTypes
[
0
]
]
+
(
s
.
dataTypes
[
0
]
!
=
=
"
*
"
?
"
"
+
allTypes
+
"
;
q
=
0
.
01
"
:
"
"
)
:
s
.
accepts
[
"
*
"
]
)
;
for
(
i
in
s
.
headers
)
{
jqXHR
.
setRequestHeader
(
i
s
.
headers
[
i
]
)
;
}
if
(
s
.
beforeSend
&
&
(
s
.
beforeSend
.
call
(
callbackContext
jqXHR
s
)
=
=
=
false
|
|
state
=
=
=
2
)
)
{
return
jqXHR
.
abort
(
)
;
}
strAbort
=
"
abort
"
;
for
(
i
in
{
success
:
1
error
:
1
complete
:
1
}
)
{
jqXHR
[
i
]
(
s
[
i
]
)
;
}
transport
=
inspectPrefiltersOrTransports
(
transports
s
options
jqXHR
)
;
if
(
!
transport
)
{
done
(
-
1
"
No
Transport
"
)
;
}
else
{
jqXHR
.
readyState
=
1
;
if
(
fireGlobals
)
{
globalEventContext
.
trigger
(
"
ajaxSend
"
[
jqXHR
s
]
)
;
}
if
(
state
=
=
=
2
)
{
return
jqXHR
;
}
if
(
s
.
async
&
&
s
.
timeout
>
0
)
{
timeoutTimer
=
window
.
setTimeout
(
function
(
)
{
jqXHR
.
abort
(
"
timeout
"
)
;
}
s
.
timeout
)
;
}
try
{
state
=
1
;
transport
.
send
(
requestHeaders
done
)
;
}
catch
(
e
)
{
if
(
state
<
2
)
{
done
(
-
1
e
)
;
}
else
{
throw
e
;
}
}
}
function
done
(
status
nativeStatusText
responses
headers
)
{
var
isSuccess
success
error
response
modified
statusText
=
nativeStatusText
;
if
(
state
=
=
=
2
)
{
return
;
}
state
=
2
;
if
(
timeoutTimer
)
{
window
.
clearTimeout
(
timeoutTimer
)
;
}
transport
=
undefined
;
responseHeadersString
=
headers
|
|
"
"
;
jqXHR
.
readyState
=
status
>
0
?
4
:
0
;
isSuccess
=
status
>
=
200
&
&
status
<
300
|
|
status
=
=
=
304
;
if
(
responses
)
{
response
=
ajaxHandleResponses
(
s
jqXHR
responses
)
;
}
response
=
ajaxConvert
(
s
response
jqXHR
isSuccess
)
;
if
(
isSuccess
)
{
if
(
s
.
ifModified
)
{
modified
=
jqXHR
.
getResponseHeader
(
"
Last
-
Modified
"
)
;
if
(
modified
)
{
jQuery
.
lastModified
[
cacheURL
]
=
modified
;
}
modified
=
jqXHR
.
getResponseHeader
(
"
etag
"
)
;
if
(
modified
)
{
jQuery
.
etag
[
cacheURL
]
=
modified
;
}
}
if
(
status
=
=
=
204
|
|
s
.
type
=
=
=
"
HEAD
"
)
{
statusText
=
"
nocontent
"
;
}
else
if
(
status
=
=
=
304
)
{
statusText
=
"
notmodified
"
;
}
else
{
statusText
=
response
.
state
;
success
=
response
.
data
;
error
=
response
.
error
;
isSuccess
=
!
error
;
}
}
else
{
error
=
statusText
;
if
(
status
|
|
!
statusText
)
{
statusText
=
"
error
"
;
if
(
status
<
0
)
{
status
=
0
;
}
}
}
jqXHR
.
status
=
status
;
jqXHR
.
statusText
=
(
nativeStatusText
|
|
statusText
)
+
"
"
;
if
(
isSuccess
)
{
deferred
.
resolveWith
(
callbackContext
[
success
statusText
jqXHR
]
)
;
}
else
{
deferred
.
rejectWith
(
callbackContext
[
jqXHR
statusText
error
]
)
;
}
jqXHR
.
statusCode
(
statusCode
)
;
statusCode
=
undefined
;
if
(
fireGlobals
)
{
globalEventContext
.
trigger
(
isSuccess
?
"
ajaxSuccess
"
:
"
ajaxError
"
[
jqXHR
s
isSuccess
?
success
:
error
]
)
;
}
completeDeferred
.
fireWith
(
callbackContext
[
jqXHR
statusText
]
)
;
if
(
fireGlobals
)
{
globalEventContext
.
trigger
(
"
ajaxComplete
"
[
jqXHR
s
]
)
;
if
(
!
(
-
-
jQuery
.
active
)
)
{
jQuery
.
event
.
trigger
(
"
ajaxStop
"
)
;
}
}
}
return
jqXHR
;
}
getJSON
:
function
(
url
data
callback
)
{
return
jQuery
.
get
(
url
data
callback
"
json
"
)
;
}
getScript
:
function
(
url
callback
)
{
return
jQuery
.
get
(
url
undefined
callback
"
script
"
)
;
}
}
)
;
jQuery
.
each
(
[
"
get
"
"
post
"
]
function
(
i
method
)
{
jQuery
[
method
]
=
function
(
url
data
callback
type
)
{
if
(
jQuery
.
isFunction
(
data
)
)
{
type
=
type
|
|
callback
;
callback
=
data
;
data
=
undefined
;
}
return
jQuery
.
ajax
(
jQuery
.
extend
(
{
url
:
url
type
:
method
dataType
:
type
data
:
data
success
:
callback
}
jQuery
.
isPlainObject
(
url
)
&
&
url
)
)
;
}
;
}
)
;
jQuery
.
_evalUrl
=
function
(
url
)
{
return
jQuery
.
ajax
(
{
url
:
url
type
:
"
GET
"
dataType
:
"
script
"
async
:
false
global
:
false
"
throws
"
:
true
}
)
;
}
;
jQuery
.
fn
.
extend
(
{
wrapAll
:
function
(
html
)
{
var
wrap
;
if
(
jQuery
.
isFunction
(
html
)
)
{
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
wrapAll
(
html
.
call
(
this
i
)
)
;
}
)
;
}
if
(
this
[
0
]
)
{
wrap
=
jQuery
(
html
this
[
0
]
.
ownerDocument
)
.
eq
(
0
)
.
clone
(
true
)
;
if
(
this
[
0
]
.
parentNode
)
{
wrap
.
insertBefore
(
this
[
0
]
)
;
}
wrap
.
map
(
function
(
)
{
var
elem
=
this
;
while
(
elem
.
firstElementChild
)
{
elem
=
elem
.
firstElementChild
;
}
return
elem
;
}
)
.
append
(
this
)
;
}
return
this
;
}
wrapInner
:
function
(
html
)
{
if
(
jQuery
.
isFunction
(
html
)
)
{
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
wrapInner
(
html
.
call
(
this
i
)
)
;
}
)
;
}
return
this
.
each
(
function
(
)
{
var
self
=
jQuery
(
this
)
contents
=
self
.
contents
(
)
;
if
(
contents
.
length
)
{
contents
.
wrapAll
(
html
)
;
}
else
{
self
.
append
(
html
)
;
}
}
)
;
}
wrap
:
function
(
html
)
{
var
isFunction
=
jQuery
.
isFunction
(
html
)
;
return
this
.
each
(
function
(
i
)
{
jQuery
(
this
)
.
wrapAll
(
isFunction
?
html
.
call
(
this
i
)
:
html
)
;
}
)
;
}
unwrap
:
function
(
)
{
return
this
.
parent
(
)
.
each
(
function
(
)
{
if
(
!
jQuery
.
nodeName
(
this
"
body
"
)
)
{
jQuery
(
this
)
.
replaceWith
(
this
.
childNodes
)
;
}
}
)
.
end
(
)
;
}
}
)
;
jQuery
.
expr
.
filters
.
hidden
=
function
(
elem
)
{
return
!
jQuery
.
expr
.
filters
.
visible
(
elem
)
;
}
;
jQuery
.
expr
.
filters
.
visible
=
function
(
elem
)
{
return
elem
.
offsetWidth
>
0
|
|
elem
.
offsetHeight
>
0
|
|
elem
.
getClientRects
(
)
.
length
>
0
;
}
;
var
r20
=
/
%
20
/
g
rbracket
=
/
\
[
\
]
/
rCRLF
=
/
\
r
?
\
n
/
g
rsubmitterTypes
=
/
^
(
?
:
submit
|
button
|
image
|
reset
|
file
)
/
i
rsubmittable
=
/
^
(
?
:
input
|
select
|
textarea
|
keygen
)
/
i
;
function
buildParams
(
prefix
obj
traditional
add
)
{
var
name
;
if
(
jQuery
.
isArray
(
obj
)
)
{
jQuery
.
each
(
obj
function
(
i
v
)
{
if
(
traditional
|
|
rbracket
.
test
(
prefix
)
)
{
add
(
prefix
v
)
;
}
else
{
buildParams
(
prefix
+
"
[
"
+
(
typeof
v
=
=
=
"
object
"
&
&
v
!
=
null
?
i
:
"
"
)
+
"
]
"
v
traditional
add
)
;
}
}
)
;
}
else
if
(
!
traditional
&
&
jQuery
.
type
(
obj
)
=
=
=
"
object
"
)
{
for
(
name
in
obj
)
{
buildParams
(
prefix
+
"
[
"
+
name
+
"
]
"
obj
[
name
]
traditional
add
)
;
}
}
else
{
add
(
prefix
obj
)
;
}
}
jQuery
.
param
=
function
(
a
traditional
)
{
var
prefix
s
=
[
]
add
=
function
(
key
value
)
{
value
=
jQuery
.
isFunction
(
value
)
?
value
(
)
:
(
value
=
=
null
?
"
"
:
value
)
;
s
[
s
.
length
]
=
encodeURIComponent
(
key
)
+
"
=
"
+
encodeURIComponent
(
value
)
;
}
;
if
(
traditional
=
=
=
undefined
)
{
traditional
=
jQuery
.
ajaxSettings
&
&
jQuery
.
ajaxSettings
.
traditional
;
}
if
(
jQuery
.
isArray
(
a
)
|
|
(
a
.
jquery
&
&
!
jQuery
.
isPlainObject
(
a
)
)
)
{
jQuery
.
each
(
a
function
(
)
{
add
(
this
.
name
this
.
value
)
;
}
)
;
}
else
{
for
(
prefix
in
a
)
{
buildParams
(
prefix
a
[
prefix
]
traditional
add
)
;
}
}
return
s
.
join
(
"
&
"
)
.
replace
(
r20
"
+
"
)
;
}
;
jQuery
.
fn
.
extend
(
{
serialize
:
function
(
)
{
return
jQuery
.
param
(
this
.
serializeArray
(
)
)
;
}
serializeArray
:
function
(
)
{
return
this
.
map
(
function
(
)
{
var
elements
=
jQuery
.
prop
(
this
"
elements
"
)
;
return
elements
?
jQuery
.
makeArray
(
elements
)
:
this
;
}
)
.
filter
(
function
(
)
{
var
type
=
this
.
type
;
return
this
.
name
&
&
!
jQuery
(
this
)
.
is
(
"
:
disabled
"
)
&
&
rsubmittable
.
test
(
this
.
nodeName
)
&
&
!
rsubmitterTypes
.
test
(
type
)
&
&
(
this
.
checked
|
|
!
rcheckableType
.
test
(
type
)
)
;
}
)
.
map
(
function
(
i
elem
)
{
var
val
=
jQuery
(
this
)
.
val
(
)
;
return
val
=
=
null
?
null
:
jQuery
.
isArray
(
val
)
?
jQuery
.
map
(
val
function
(
val
)
{
return
{
name
:
elem
.
name
value
:
val
.
replace
(
rCRLF
"
\
r
\
n
"
)
}
;
}
)
:
{
name
:
elem
.
name
value
:
val
.
replace
(
rCRLF
"
\
r
\
n
"
)
}
;
}
)
.
get
(
)
;
}
}
)
;
jQuery
.
ajaxSettings
.
xhr
=
function
(
)
{
try
{
return
new
window
.
XMLHttpRequest
(
)
;
}
catch
(
e
)
{
}
}
;
var
xhrSuccessStatus
=
{
0
:
200
1223
:
204
}
xhrSupported
=
jQuery
.
ajaxSettings
.
xhr
(
)
;
support
.
cors
=
!
!
xhrSupported
&
&
(
"
withCredentials
"
in
xhrSupported
)
;
support
.
ajax
=
xhrSupported
=
!
!
xhrSupported
;
jQuery
.
ajaxTransport
(
function
(
options
)
{
var
callback
errorCallback
;
if
(
support
.
cors
|
|
xhrSupported
&
&
!
options
.
crossDomain
)
{
return
{
send
:
function
(
headers
complete
)
{
var
i
xhr
=
options
.
xhr
(
)
;
xhr
.
open
(
options
.
type
options
.
url
options
.
async
options
.
username
options
.
password
)
;
if
(
options
.
xhrFields
)
{
for
(
i
in
options
.
xhrFields
)
{
xhr
[
i
]
=
options
.
xhrFields
[
i
]
;
}
}
if
(
options
.
mimeType
&
&
xhr
.
overrideMimeType
)
{
xhr
.
overrideMimeType
(
options
.
mimeType
)
;
}
if
(
!
options
.
crossDomain
&
&
!
headers
[
"
X
-
Requested
-
With
"
]
)
{
headers
[
"
X
-
Requested
-
With
"
]
=
"
XMLHttpRequest
"
;
}
for
(
i
in
headers
)
{
xhr
.
setRequestHeader
(
i
headers
[
i
]
)
;
}
callback
=
function
(
type
)
{
return
function
(
)
{
if
(
callback
)
{
callback
=
errorCallback
=
xhr
.
onload
=
xhr
.
onerror
=
xhr
.
onabort
=
xhr
.
onreadystatechange
=
null
;
if
(
type
=
=
=
"
abort
"
)
{
xhr
.
abort
(
)
;
}
else
if
(
type
=
=
=
"
error
"
)
{
if
(
typeof
xhr
.
status
!
=
=
"
number
"
)
{
complete
(
0
"
error
"
)
;
}
else
{
complete
(
xhr
.
status
xhr
.
statusText
)
;
}
}
else
{
complete
(
xhrSuccessStatus
[
xhr
.
status
]
|
|
xhr
.
status
xhr
.
statusText
(
xhr
.
responseType
|
|
"
text
"
)
!
=
=
"
text
"
|
|
typeof
xhr
.
responseText
!
=
=
"
string
"
?
{
binary
:
xhr
.
response
}
:
{
text
:
xhr
.
responseText
}
xhr
.
getAllResponseHeaders
(
)
)
;
}
}
}
;
}
;
xhr
.
onload
=
callback
(
)
;
errorCallback
=
xhr
.
onerror
=
callback
(
"
error
"
)
;
if
(
xhr
.
onabort
!
=
=
undefined
)
{
xhr
.
onabort
=
errorCallback
;
}
else
{
xhr
.
onreadystatechange
=
function
(
)
{
if
(
xhr
.
readyState
=
=
=
4
)
{
window
.
setTimeout
(
function
(
)
{
if
(
callback
)
{
errorCallback
(
)
;
}
}
)
;
}
}
;
}
callback
=
callback
(
"
abort
"
)
;
try
{
xhr
.
send
(
options
.
hasContent
&
&
options
.
data
|
|
null
)
;
}
catch
(
e
)
{
if
(
callback
)
{
throw
e
;
}
}
}
abort
:
function
(
)
{
if
(
callback
)
{
callback
(
)
;
}
}
}
;
}
}
)
;
jQuery
.
ajaxSetup
(
{
accepts
:
{
script
:
"
text
/
javascript
application
/
javascript
"
+
"
application
/
ecmascript
application
/
x
-
ecmascript
"
}
contents
:
{
script
:
/
\
b
(
?
:
java
|
ecma
)
script
\
b
/
}
converters
:
{
"
text
script
"
:
function
(
text
)
{
jQuery
.
globalEval
(
text
)
;
return
text
;
}
}
}
)
;
jQuery
.
ajaxPrefilter
(
"
script
"
function
(
s
)
{
if
(
s
.
cache
=
=
=
undefined
)
{
s
.
cache
=
false
;
}
if
(
s
.
crossDomain
)
{
s
.
type
=
"
GET
"
;
}
}
)
;
jQuery
.
ajaxTransport
(
"
script
"
function
(
s
)
{
if
(
s
.
crossDomain
)
{
var
script
callback
;
return
{
send
:
function
(
_
complete
)
{
script
=
jQuery
(
"
<
script
>
"
)
.
prop
(
{
charset
:
s
.
scriptCharset
src
:
s
.
url
}
)
.
on
(
"
load
error
"
callback
=
function
(
evt
)
{
script
.
remove
(
)
;
callback
=
null
;
if
(
evt
)
{
complete
(
evt
.
type
=
=
=
"
error
"
?
404
:
200
evt
.
type
)
;
}
}
)
;
document
.
head
.
appendChild
(
script
[
0
]
)
;
}
abort
:
function
(
)
{
if
(
callback
)
{
callback
(
)
;
}
}
}
;
}
}
)
;
var
oldCallbacks
=
[
]
rjsonp
=
/
(
=
)
\
?
(
?
=
&
|
)
|
\
?
\
?
/
;
jQuery
.
ajaxSetup
(
{
jsonp
:
"
callback
"
jsonpCallback
:
function
(
)
{
var
callback
=
oldCallbacks
.
pop
(
)
|
|
(
jQuery
.
expando
+
"
_
"
+
(
nonce
+
+
)
)
;
this
[
callback
]
=
true
;
return
callback
;
}
}
)
;
jQuery
.
ajaxPrefilter
(
"
json
jsonp
"
function
(
s
originalSettings
jqXHR
)
{
var
callbackName
overwritten
responseContainer
jsonProp
=
s
.
jsonp
!
=
=
false
&
&
(
rjsonp
.
test
(
s
.
url
)
?
"
url
"
:
typeof
s
.
data
=
=
=
"
string
"
&
&
(
s
.
contentType
|
|
"
"
)
.
indexOf
(
"
application
/
x
-
www
-
form
-
urlencoded
"
)
=
=
=
0
&
&
rjsonp
.
test
(
s
.
data
)
&
&
"
data
"
)
;
if
(
jsonProp
|
|
s
.
dataTypes
[
0
]
=
=
=
"
jsonp
"
)
{
callbackName
=
s
.
jsonpCallback
=
jQuery
.
isFunction
(
s
.
jsonpCallback
)
?
s
.
jsonpCallback
(
)
:
s
.
jsonpCallback
;
if
(
jsonProp
)
{
s
[
jsonProp
]
=
s
[
jsonProp
]
.
replace
(
rjsonp
"
1
"
+
callbackName
)
;
}
else
if
(
s
.
jsonp
!
=
=
false
)
{
s
.
url
+
=
(
rquery
.
test
(
s
.
url
)
?
"
&
"
:
"
?
"
)
+
s
.
jsonp
+
"
=
"
+
callbackName
;
}
s
.
converters
[
"
script
json
"
]
=
function
(
)
{
if
(
!
responseContainer
)
{
jQuery
.
error
(
callbackName
+
"
was
not
called
"
)
;
}
return
responseContainer
[
0
]
;
}
;
s
.
dataTypes
[
0
]
=
"
json
"
;
overwritten
=
window
[
callbackName
]
;
window
[
callbackName
]
=
function
(
)
{
responseContainer
=
arguments
;
}
;
jqXHR
.
always
(
function
(
)
{
if
(
overwritten
=
=
=
undefined
)
{
jQuery
(
window
)
.
removeProp
(
callbackName
)
;
}
else
{
window
[
callbackName
]
=
overwritten
;
}
if
(
s
[
callbackName
]
)
{
s
.
jsonpCallback
=
originalSettings
.
jsonpCallback
;
oldCallbacks
.
push
(
callbackName
)
;
}
if
(
responseContainer
&
&
jQuery
.
isFunction
(
overwritten
)
)
{
overwritten
(
responseContainer
[
0
]
)
;
}
responseContainer
=
overwritten
=
undefined
;
}
)
;
return
"
script
"
;
}
}
)
;
jQuery
.
parseHTML
=
function
(
data
context
keepScripts
)
{
if
(
!
data
|
|
typeof
data
!
=
=
"
string
"
)
{
return
null
;
}
if
(
typeof
context
=
=
=
"
boolean
"
)
{
keepScripts
=
context
;
context
=
false
;
}
context
=
context
|
|
document
;
var
parsed
=
rsingleTag
.
exec
(
data
)
scripts
=
!
keepScripts
&
&
[
]
;
if
(
parsed
)
{
return
[
context
.
createElement
(
parsed
[
1
]
)
]
;
}
parsed
=
buildFragment
(
[
data
]
context
scripts
)
;
if
(
scripts
&
&
scripts
.
length
)
{
jQuery
(
scripts
)
.
remove
(
)
;
}
return
jQuery
.
merge
(
[
]
parsed
.
childNodes
)
;
}
;
var
_load
=
jQuery
.
fn
.
load
;
jQuery
.
fn
.
load
=
function
(
url
params
callback
)
{
if
(
typeof
url
!
=
=
"
string
"
&
&
_load
)
{
return
_load
.
apply
(
this
arguments
)
;
}
var
selector
type
response
self
=
this
off
=
url
.
indexOf
(
"
"
)
;
if
(
off
>
-
1
)
{
selector
=
jQuery
.
trim
(
url
.
slice
(
off
)
)
;
url
=
url
.
slice
(
0
off
)
;
}
if
(
jQuery
.
isFunction
(
params
)
)
{
callback
=
params
;
params
=
undefined
;
}
else
if
(
params
&
&
typeof
params
=
=
=
"
object
"
)
{
type
=
"
POST
"
;
}
if
(
self
.
length
>
0
)
{
jQuery
.
ajax
(
{
url
:
url
type
:
type
|
|
"
GET
"
dataType
:
"
html
"
data
:
params
}
)
.
done
(
function
(
responseText
)
{
response
=
arguments
;
self
.
html
(
selector
?
jQuery
(
"
<
div
>
"
)
.
append
(
jQuery
.
parseHTML
(
responseText
)
)
.
find
(
selector
)
:
responseText
)
;
}
)
.
always
(
callback
&
&
function
(
jqXHR
status
)
{
self
.
each
(
function
(
)
{
callback
.
apply
(
this
response
|
|
[
jqXHR
.
responseText
status
jqXHR
]
)
;
}
)
;
}
)
;
}
return
this
;
}
;
jQuery
.
each
(
[
"
ajaxStart
"
"
ajaxStop
"
"
ajaxComplete
"
"
ajaxError
"
"
ajaxSuccess
"
"
ajaxSend
"
]
function
(
i
type
)
{
jQuery
.
fn
[
type
]
=
function
(
fn
)
{
return
this
.
on
(
type
fn
)
;
}
;
}
)
;
jQuery
.
expr
.
filters
.
animated
=
function
(
elem
)
{
return
jQuery
.
grep
(
jQuery
.
timers
function
(
fn
)
{
return
elem
=
=
=
fn
.
elem
;
}
)
.
length
;
}
;
function
getWindow
(
elem
)
{
return
jQuery
.
isWindow
(
elem
)
?
elem
:
elem
.
nodeType
=
=
=
9
&
&
elem
.
defaultView
;
}
jQuery
.
offset
=
{
setOffset
:
function
(
elem
options
i
)
{
var
curPosition
curLeft
curCSSTop
curTop
curOffset
curCSSLeft
calculatePosition
position
=
jQuery
.
css
(
elem
"
position
"
)
curElem
=
jQuery
(
elem
)
props
=
{
}
;
if
(
position
=
=
=
"
static
"
)
{
elem
.
style
.
position
=
"
relative
"
;
}
curOffset
=
curElem
.
offset
(
)
;
curCSSTop
=
jQuery
.
css
(
elem
"
top
"
)
;
curCSSLeft
=
jQuery
.
css
(
elem
"
left
"
)
;
calculatePosition
=
(
position
=
=
=
"
absolute
"
|
|
position
=
=
=
"
fixed
"
)
&
&
(
curCSSTop
+
curCSSLeft
)
.
indexOf
(
"
auto
"
)
>
-
1
;
if
(
calculatePosition
)
{
curPosition
=
curElem
.
position
(
)
;
curTop
=
curPosition
.
top
;
curLeft
=
curPosition
.
left
;
}
else
{
curTop
=
parseFloat
(
curCSSTop
)
|
|
0
;
curLeft
=
parseFloat
(
curCSSLeft
)
|
|
0
;
}
if
(
jQuery
.
isFunction
(
options
)
)
{
options
=
options
.
call
(
elem
i
jQuery
.
extend
(
{
}
curOffset
)
)
;
}
if
(
options
.
top
!
=
null
)
{
props
.
top
=
(
options
.
top
-
curOffset
.
top
)
+
curTop
;
}
if
(
options
.
left
!
=
null
)
{
props
.
left
=
(
options
.
left
-
curOffset
.
left
)
+
curLeft
;
}
if
(
"
using
"
in
options
)
{
options
.
using
.
call
(
elem
props
)
;
}
else
{
curElem
.
css
(
props
)
;
}
}
}
;
jQuery
.
fn
.
extend
(
{
offset
:
function
(
options
)
{
if
(
arguments
.
length
)
{
return
options
=
=
=
undefined
?
this
:
this
.
each
(
function
(
i
)
{
jQuery
.
offset
.
setOffset
(
this
options
i
)
;
}
)
;
}
var
docElem
win
elem
=
this
[
0
]
box
=
{
top
:
0
left
:
0
}
doc
=
elem
&
&
elem
.
ownerDocument
;
if
(
!
doc
)
{
return
;
}
docElem
=
doc
.
documentElement
;
if
(
!
jQuery
.
contains
(
docElem
elem
)
)
{
return
box
;
}
box
=
elem
.
getBoundingClientRect
(
)
;
win
=
getWindow
(
doc
)
;
return
{
top
:
box
.
top
+
win
.
pageYOffset
-
docElem
.
clientTop
left
:
box
.
left
+
win
.
pageXOffset
-
docElem
.
clientLeft
}
;
}
position
:
function
(
)
{
if
(
!
this
[
0
]
)
{
return
;
}
var
offsetParent
offset
elem
=
this
[
0
]
parentOffset
=
{
top
:
0
left
:
0
}
;
if
(
jQuery
.
css
(
elem
"
position
"
)
=
=
=
"
fixed
"
)
{
offset
=
elem
.
getBoundingClientRect
(
)
;
}
else
{
offsetParent
=
this
.
offsetParent
(
)
;
offset
=
this
.
offset
(
)
;
if
(
!
jQuery
.
nodeName
(
offsetParent
[
0
]
"
html
"
)
)
{
parentOffset
=
offsetParent
.
offset
(
)
;
}
parentOffset
.
top
+
=
jQuery
.
css
(
offsetParent
[
0
]
"
borderTopWidth
"
true
)
;
parentOffset
.
left
+
=
jQuery
.
css
(
offsetParent
[
0
]
"
borderLeftWidth
"
true
)
;
}
return
{
top
:
offset
.
top
-
parentOffset
.
top
-
jQuery
.
css
(
elem
"
marginTop
"
true
)
left
:
offset
.
left
-
parentOffset
.
left
-
jQuery
.
css
(
elem
"
marginLeft
"
true
)
}
;
}
offsetParent
:
function
(
)
{
return
this
.
map
(
function
(
)
{
var
offsetParent
=
this
.
offsetParent
;
while
(
offsetParent
&
&
jQuery
.
css
(
offsetParent
"
position
"
)
=
=
=
"
static
"
)
{
offsetParent
=
offsetParent
.
offsetParent
;
}
return
offsetParent
|
|
documentElement
;
}
)
;
}
}
)
;
jQuery
.
each
(
{
scrollLeft
:
"
pageXOffset
"
scrollTop
:
"
pageYOffset
"
}
function
(
method
prop
)
{
var
top
=
"
pageYOffset
"
=
=
=
prop
;
jQuery
.
fn
[
method
]
=
function
(
val
)
{
return
access
(
this
function
(
elem
method
val
)
{
var
win
=
getWindow
(
elem
)
;
if
(
val
=
=
=
undefined
)
{
return
win
?
win
[
prop
]
:
elem
[
method
]
;
}
if
(
win
)
{
win
.
scrollTo
(
!
top
?
val
:
win
.
pageXOffset
top
?
val
:
win
.
pageYOffset
)
;
}
else
{
elem
[
method
]
=
val
;
}
}
method
val
arguments
.
length
)
;
}
;
}
)
;
jQuery
.
each
(
[
"
top
"
"
left
"
]
function
(
i
prop
)
{
jQuery
.
cssHooks
[
prop
]
=
addGetHookIf
(
support
.
pixelPosition
function
(
elem
computed
)
{
if
(
computed
)
{
computed
=
curCSS
(
elem
prop
)
;
return
rnumnonpx
.
test
(
computed
)
?
jQuery
(
elem
)
.
position
(
)
[
prop
]
+
"
px
"
:
computed
;
}
}
)
;
}
)
;
jQuery
.
each
(
{
Height
:
"
height
"
Width
:
"
width
"
}
function
(
name
type
)
{
jQuery
.
each
(
{
padding
:
"
inner
"
+
name
content
:
type
"
"
:
"
outer
"
+
name
}
function
(
defaultExtra
funcName
)
{
jQuery
.
fn
[
funcName
]
=
function
(
margin
value
)
{
var
chainable
=
arguments
.
length
&
&
(
defaultExtra
|
|
typeof
margin
!
=
=
"
boolean
"
)
extra
=
defaultExtra
|
|
(
margin
=
=
=
true
|
|
value
=
=
=
true
?
"
margin
"
:
"
border
"
)
;
return
access
(
this
function
(
elem
type
value
)
{
var
doc
;
if
(
jQuery
.
isWindow
(
elem
)
)
{
return
elem
.
document
.
documentElement
[
"
client
"
+
name
]
;
}
if
(
elem
.
nodeType
=
=
=
9
)
{
doc
=
elem
.
documentElement
;
return
Math
.
max
(
elem
.
body
[
"
scroll
"
+
name
]
doc
[
"
scroll
"
+
name
]
elem
.
body
[
"
offset
"
+
name
]
doc
[
"
offset
"
+
name
]
doc
[
"
client
"
+
name
]
)
;
}
return
value
=
=
=
undefined
?
jQuery
.
css
(
elem
type
extra
)
:
jQuery
.
style
(
elem
type
value
extra
)
;
}
type
chainable
?
margin
:
undefined
chainable
null
)
;
}
;
}
)
;
}
)
;
jQuery
.
fn
.
extend
(
{
bind
:
function
(
types
data
fn
)
{
return
this
.
on
(
types
null
data
fn
)
;
}
unbind
:
function
(
types
fn
)
{
return
this
.
off
(
types
null
fn
)
;
}
delegate
:
function
(
selector
types
data
fn
)
{
return
this
.
on
(
types
selector
data
fn
)
;
}
undelegate
:
function
(
selector
types
fn
)
{
return
arguments
.
length
=
=
=
1
?
this
.
off
(
selector
"
*
*
"
)
:
this
.
off
(
types
selector
|
|
"
*
*
"
fn
)
;
}
size
:
function
(
)
{
return
this
.
length
;
}
}
)
;
jQuery
.
fn
.
andSelf
=
jQuery
.
fn
.
addBack
;
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
"
jquery
"
[
]
function
(
)
{
return
jQuery
;
}
)
;
}
var
_jQuery
=
window
.
jQuery
_
=
window
.
;
jQuery
.
noConflict
=
function
(
deep
)
{
if
(
window
.
=
=
=
jQuery
)
{
window
.
=
_
;
}
if
(
deep
&
&
window
.
jQuery
=
=
=
jQuery
)
{
window
.
jQuery
=
_jQuery
;
}
return
jQuery
;
}
;
if
(
!
noGlobal
)
{
window
.
jQuery
=
window
.
=
jQuery
;
}
return
jQuery
;
}
)
)
;
;
;
(
function
(
)
{
var
enifed
requireModule
require
Ember
;
var
mainContext
=
this
;
(
function
(
)
{
var
isNode
=
typeof
window
=
=
=
'
undefined
'
&
&
typeof
process
!
=
=
'
undefined
'
&
&
{
}
.
toString
.
call
(
process
)
=
=
=
'
[
object
process
]
'
;
if
(
!
isNode
)
{
Ember
=
this
.
Ember
=
this
.
Ember
|
|
{
}
;
}
if
(
typeof
Ember
=
=
=
'
undefined
'
)
{
Ember
=
{
}
;
}
if
(
typeof
Ember
.
__loader
=
=
=
'
undefined
'
)
{
var
registry
=
{
}
;
var
seen
=
{
}
;
enifed
=
function
(
name
deps
callback
)
{
var
value
=
{
}
;
if
(
!
callback
)
{
value
.
deps
=
[
]
;
value
.
callback
=
deps
;
}
else
{
value
.
deps
=
deps
;
value
.
callback
=
callback
;
}
registry
[
name
]
=
value
;
}
;
require
=
requireModule
=
function
(
name
)
{
return
internalRequire
(
name
null
)
;
}
;
require
[
'
default
'
]
=
require
;
require
.
has
=
function
registryHas
(
moduleName
)
{
return
!
!
registry
[
moduleName
]
|
|
!
!
registry
[
moduleName
+
'
/
index
'
]
;
}
;
function
missingModule
(
name
referrerName
)
{
if
(
referrerName
)
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
+
'
required
by
:
'
+
referrerName
)
;
}
else
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
)
;
}
}
function
internalRequire
(
_name
referrerName
)
{
var
name
=
_name
;
var
mod
=
registry
[
name
]
;
if
(
!
mod
)
{
name
=
name
+
'
/
index
'
;
mod
=
registry
[
name
]
;
}
var
exports
=
seen
[
name
]
;
if
(
exports
!
=
=
undefined
)
{
return
exports
;
}
exports
=
seen
[
name
]
=
{
}
;
if
(
!
mod
)
{
missingModule
(
_name
referrerName
)
;
}
var
deps
=
mod
.
deps
;
var
callback
=
mod
.
callback
;
var
length
=
deps
.
length
;
var
reified
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
deps
[
i
]
=
=
=
'
exports
'
)
{
reified
[
i
]
=
exports
;
}
else
if
(
deps
[
i
]
=
=
=
'
require
'
)
{
reified
[
i
]
=
require
;
}
else
{
reified
[
i
]
=
internalRequire
(
deps
[
i
]
name
)
;
}
}
callback
.
apply
(
this
reified
)
;
return
exports
;
}
requireModule
.
_eak_seen
=
registry
;
Ember
.
__loader
=
{
define
:
enifed
require
:
require
registry
:
registry
}
;
}
else
{
enifed
=
Ember
.
__loader
.
define
;
require
=
requireModule
=
Ember
.
__loader
.
require
;
}
}
)
(
)
;
enifed
(
'
backburner
'
[
'
exports
'
'
backburner
/
utils
'
'
backburner
/
platform
'
'
backburner
/
binary
-
search
'
'
backburner
/
deferred
-
action
-
queues
'
]
function
(
exports
_backburnerUtils
_backburnerPlatform
_backburnerBinarySearch
_backburnerDeferredActionQueues
)
{
'
use
strict
'
;
exports
.
default
=
Backburner
;
function
Backburner
(
queueNames
options
)
{
this
.
queueNames
=
queueNames
;
this
.
options
=
options
|
|
{
}
;
if
(
!
this
.
options
.
defaultQueue
)
{
this
.
options
.
defaultQueue
=
queueNames
[
0
]
;
}
this
.
instanceStack
=
[
]
;
this
.
_debouncees
=
[
]
;
this
.
_throttlers
=
[
]
;
this
.
_eventCallbacks
=
{
end
:
[
]
begin
:
[
]
}
;
var
_this
=
this
;
this
.
_boundClearItems
=
function
(
)
{
clearItems
(
)
;
}
;
this
.
_timerTimeoutId
=
undefined
;
this
.
_timers
=
[
]
;
this
.
_platform
=
this
.
options
.
_platform
|
|
_backburnerPlatform
.
default
;
this
.
_boundRunExpiredTimers
=
function
(
)
{
_this
.
_runExpiredTimers
(
)
;
}
;
}
Backburner
.
prototype
=
{
begin
:
function
(
)
{
var
options
=
this
.
options
;
var
onBegin
=
options
&
&
options
.
onBegin
;
var
previousInstance
=
this
.
currentInstance
;
if
(
previousInstance
)
{
this
.
instanceStack
.
push
(
previousInstance
)
;
}
this
.
currentInstance
=
new
_backburnerDeferredActionQueues
.
default
(
this
.
queueNames
options
)
;
this
.
_trigger
(
'
begin
'
this
.
currentInstance
previousInstance
)
;
if
(
onBegin
)
{
onBegin
(
this
.
currentInstance
previousInstance
)
;
}
}
end
:
function
(
)
{
var
options
=
this
.
options
;
var
onEnd
=
options
&
&
options
.
onEnd
;
var
currentInstance
=
this
.
currentInstance
;
var
nextInstance
=
null
;
var
finallyAlreadyCalled
=
false
;
try
{
currentInstance
.
flush
(
)
;
}
finally
{
if
(
!
finallyAlreadyCalled
)
{
finallyAlreadyCalled
=
true
;
this
.
currentInstance
=
null
;
if
(
this
.
instanceStack
.
length
)
{
nextInstance
=
this
.
instanceStack
.
pop
(
)
;
this
.
currentInstance
=
nextInstance
;
}
this
.
_trigger
(
'
end
'
currentInstance
nextInstance
)
;
if
(
onEnd
)
{
onEnd
(
currentInstance
nextInstance
)
;
}
}
}
}
_trigger
:
function
(
eventName
arg1
arg2
)
{
var
callbacks
=
this
.
_eventCallbacks
[
eventName
]
;
if
(
callbacks
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callbacks
[
i
]
(
arg1
arg2
)
;
}
}
}
on
:
function
(
eventName
callback
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
TypeError
(
'
Callback
must
be
a
function
'
)
;
}
var
callbacks
=
this
.
_eventCallbacks
[
eventName
]
;
if
(
callbacks
)
{
callbacks
.
push
(
callback
)
;
}
else
{
throw
new
TypeError
(
'
Cannot
on
(
)
event
"
'
+
eventName
+
'
"
because
it
does
not
exist
'
)
;
}
}
off
:
function
(
eventName
callback
)
{
if
(
eventName
)
{
var
callbacks
=
this
.
_eventCallbacks
[
eventName
]
;
var
callbackFound
=
false
;
if
(
!
callbacks
)
return
;
if
(
callback
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
if
(
callbacks
[
i
]
=
=
=
callback
)
{
callbackFound
=
true
;
callbacks
.
splice
(
i
1
)
;
i
-
-
;
}
}
}
if
(
!
callbackFound
)
{
throw
new
TypeError
(
'
Cannot
off
(
)
callback
that
does
not
exist
'
)
;
}
}
else
{
throw
new
TypeError
(
'
Cannot
off
(
)
event
"
'
+
eventName
+
'
"
because
it
does
not
exist
'
)
;
}
}
run
:
function
(
)
{
var
length
=
arguments
.
length
;
var
method
target
args
;
if
(
length
=
=
=
1
)
{
method
=
arguments
[
0
]
;
target
=
null
;
}
else
{
target
=
arguments
[
0
]
;
method
=
arguments
[
1
]
;
}
if
(
_backburnerUtils
.
isString
(
method
)
)
{
method
=
target
[
method
]
;
}
if
(
length
>
2
)
{
args
=
new
Array
(
length
-
2
)
;
for
(
var
i
=
0
l
=
length
-
2
;
i
<
l
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
+
2
]
;
}
}
else
{
args
=
[
]
;
}
var
onError
=
getOnError
(
this
.
options
)
;
this
.
begin
(
)
;
var
didFinally
=
false
;
if
(
onError
)
{
try
{
return
method
.
apply
(
target
args
)
;
}
catch
(
error
)
{
onError
(
error
)
;
}
finally
{
if
(
!
didFinally
)
{
didFinally
=
true
;
this
.
end
(
)
;
}
}
}
else
{
try
{
return
method
.
apply
(
target
args
)
;
}
finally
{
if
(
!
didFinally
)
{
didFinally
=
true
;
this
.
end
(
)
;
}
}
}
}
join
:
function
(
)
{
if
(
!
this
.
currentInstance
)
{
return
this
.
run
.
apply
(
this
arguments
)
;
}
var
length
=
arguments
.
length
;
var
method
target
;
if
(
length
=
=
=
1
)
{
method
=
arguments
[
0
]
;
target
=
null
;
}
else
{
target
=
arguments
[
0
]
;
method
=
arguments
[
1
]
;
}
if
(
_backburnerUtils
.
isString
(
method
)
)
{
method
=
target
[
method
]
;
}
if
(
length
=
=
=
1
)
{
return
method
(
)
;
}
else
if
(
length
=
=
=
2
)
{
return
method
.
call
(
target
)
;
}
else
{
var
args
=
new
Array
(
length
-
2
)
;
for
(
var
i
=
0
l
=
length
-
2
;
i
<
l
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
+
2
]
;
}
return
method
.
apply
(
target
args
)
;
}
}
defer
:
function
(
queueName
)
{
var
length
=
arguments
.
length
;
var
method
target
args
;
if
(
length
=
=
=
2
)
{
method
=
arguments
[
1
]
;
target
=
null
;
}
else
{
target
=
arguments
[
1
]
;
method
=
arguments
[
2
]
;
}
if
(
_backburnerUtils
.
isString
(
method
)
)
{
method
=
target
[
method
]
;
}
var
stack
=
this
.
DEBUG
?
new
Error
(
)
:
undefined
;
if
(
length
>
3
)
{
args
=
new
Array
(
length
-
3
)
;
for
(
var
i
=
3
;
i
<
length
;
i
+
+
)
{
args
[
i
-
3
]
=
arguments
[
i
]
;
}
}
else
{
args
=
undefined
;
}
if
(
!
this
.
currentInstance
)
{
createAutorun
(
this
)
;
}
return
this
.
currentInstance
.
schedule
(
queueName
target
method
args
false
stack
)
;
}
deferOnce
:
function
(
queueName
)
{
var
length
=
arguments
.
length
;
var
method
target
args
;
if
(
length
=
=
=
2
)
{
method
=
arguments
[
1
]
;
target
=
null
;
}
else
{
target
=
arguments
[
1
]
;
method
=
arguments
[
2
]
;
}
if
(
_backburnerUtils
.
isString
(
method
)
)
{
method
=
target
[
method
]
;
}
var
stack
=
this
.
DEBUG
?
new
Error
(
)
:
undefined
;
if
(
length
>
3
)
{
args
=
new
Array
(
length
-
3
)
;
for
(
var
i
=
3
;
i
<
length
;
i
+
+
)
{
args
[
i
-
3
]
=
arguments
[
i
]
;
}
}
else
{
args
=
undefined
;
}
if
(
!
this
.
currentInstance
)
{
createAutorun
(
this
)
;
}
return
this
.
currentInstance
.
schedule
(
queueName
target
method
args
true
stack
)
;
}
setTimeout
:
function
(
)
{
var
l
=
arguments
.
length
;
var
args
=
new
Array
(
l
)
;
for
(
var
x
=
0
;
x
<
l
;
x
+
+
)
{
args
[
x
]
=
arguments
[
x
]
;
}
var
length
=
args
.
length
method
wait
target
methodOrTarget
methodOrWait
methodOrArgs
;
if
(
length
=
=
=
0
)
{
return
;
}
else
if
(
length
=
=
=
1
)
{
method
=
args
.
shift
(
)
;
wait
=
0
;
}
else
if
(
length
=
=
=
2
)
{
methodOrTarget
=
args
[
0
]
;
methodOrWait
=
args
[
1
]
;
if
(
_backburnerUtils
.
isFunction
(
methodOrWait
)
|
|
_backburnerUtils
.
isFunction
(
methodOrTarget
[
methodOrWait
]
)
)
{
target
=
args
.
shift
(
)
;
method
=
args
.
shift
(
)
;
wait
=
0
;
}
else
if
(
_backburnerUtils
.
isCoercableNumber
(
methodOrWait
)
)
{
method
=
args
.
shift
(
)
;
wait
=
args
.
shift
(
)
;
}
else
{
method
=
args
.
shift
(
)
;
wait
=
0
;
}
}
else
{
var
last
=
args
[
args
.
length
-
1
]
;
if
(
_backburnerUtils
.
isCoercableNumber
(
last
)
)
{
wait
=
args
.
pop
(
)
;
}
else
{
wait
=
0
;
}
methodOrTarget
=
args
[
0
]
;
methodOrArgs
=
args
[
1
]
;
if
(
_backburnerUtils
.
isFunction
(
methodOrArgs
)
|
|
_backburnerUtils
.
isString
(
methodOrArgs
)
&
&
methodOrTarget
!
=
=
null
&
&
methodOrArgs
in
methodOrTarget
)
{
target
=
args
.
shift
(
)
;
method
=
args
.
shift
(
)
;
}
else
{
method
=
args
.
shift
(
)
;
}
}
var
executeAt
=
Date
.
now
(
)
+
parseInt
(
wait
!
=
=
wait
?
0
:
wait
10
)
;
if
(
_backburnerUtils
.
isString
(
method
)
)
{
method
=
target
[
method
]
;
}
var
onError
=
getOnError
(
this
.
options
)
;
function
fn
(
)
{
if
(
onError
)
{
try
{
method
.
apply
(
target
args
)
;
}
catch
(
e
)
{
onError
(
e
)
;
}
}
else
{
method
.
apply
(
target
args
)
;
}
}
return
this
.
_setTimeout
(
fn
executeAt
)
;
}
_setTimeout
:
function
(
fn
executeAt
)
{
if
(
this
.
_timers
.
length
=
=
=
0
)
{
this
.
_timers
.
push
(
executeAt
fn
)
;
this
.
_installTimerTimeout
(
)
;
return
fn
;
}
var
i
=
_backburnerBinarySearch
.
default
(
executeAt
this
.
_timers
)
;
this
.
_timers
.
splice
(
i
0
executeAt
fn
)
;
if
(
i
=
=
=
0
)
{
this
.
_reinstallTimerTimeout
(
)
;
}
return
fn
;
}
throttle
:
function
(
target
method
)
{
var
backburner
=
this
;
var
args
=
new
Array
(
arguments
.
length
)
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
]
;
}
var
immediate
=
args
.
pop
(
)
;
var
wait
throttler
index
timer
;
if
(
_backburnerUtils
.
isNumber
(
immediate
)
|
|
_backburnerUtils
.
isString
(
immediate
)
)
{
wait
=
immediate
;
immediate
=
true
;
}
else
{
wait
=
args
.
pop
(
)
;
}
wait
=
parseInt
(
wait
10
)
;
index
=
findThrottler
(
target
method
this
.
_throttlers
)
;
if
(
index
>
-
1
)
{
return
this
.
_throttlers
[
index
]
;
}
timer
=
this
.
_platform
.
setTimeout
(
function
(
)
{
if
(
!
immediate
)
{
backburner
.
run
.
apply
(
backburner
args
)
;
}
var
index
=
findThrottler
(
target
method
backburner
.
_throttlers
)
;
if
(
index
>
-
1
)
{
backburner
.
_throttlers
.
splice
(
index
1
)
;
}
}
wait
)
;
if
(
immediate
)
{
this
.
run
.
apply
(
this
args
)
;
}
throttler
=
[
target
method
timer
]
;
this
.
_throttlers
.
push
(
throttler
)
;
return
throttler
;
}
debounce
:
function
(
target
method
)
{
var
backburner
=
this
;
var
args
=
new
Array
(
arguments
.
length
)
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
]
;
}
var
immediate
=
args
.
pop
(
)
;
var
wait
index
debouncee
timer
;
if
(
_backburnerUtils
.
isNumber
(
immediate
)
|
|
_backburnerUtils
.
isString
(
immediate
)
)
{
wait
=
immediate
;
immediate
=
false
;
}
else
{
wait
=
args
.
pop
(
)
;
}
wait
=
parseInt
(
wait
10
)
;
index
=
findDebouncee
(
target
method
this
.
_debouncees
)
;
if
(
index
>
-
1
)
{
debouncee
=
this
.
_debouncees
[
index
]
;
this
.
_debouncees
.
splice
(
index
1
)
;
this
.
_platform
.
clearTimeout
(
debouncee
[
2
]
)
;
}
timer
=
this
.
_platform
.
setTimeout
(
function
(
)
{
if
(
!
immediate
)
{
backburner
.
run
.
apply
(
backburner
args
)
;
}
var
index
=
findDebouncee
(
target
method
backburner
.
_debouncees
)
;
if
(
index
>
-
1
)
{
backburner
.
_debouncees
.
splice
(
index
1
)
;
}
}
wait
)
;
if
(
immediate
&
&
index
=
=
=
-
1
)
{
backburner
.
run
.
apply
(
backburner
args
)
;
}
debouncee
=
[
target
method
timer
]
;
backburner
.
_debouncees
.
push
(
debouncee
)
;
return
debouncee
;
}
cancelTimers
:
function
(
)
{
_backburnerUtils
.
each
(
this
.
_throttlers
this
.
_boundClearItems
)
;
this
.
_throttlers
=
[
]
;
_backburnerUtils
.
each
(
this
.
_debouncees
this
.
_boundClearItems
)
;
this
.
_debouncees
=
[
]
;
this
.
_clearTimerTimeout
(
)
;
this
.
_timers
=
[
]
;
if
(
this
.
_autorun
)
{
this
.
_platform
.
clearTimeout
(
this
.
_autorun
)
;
this
.
_autorun
=
null
;
}
}
hasTimers
:
function
(
)
{
return
!
!
this
.
_timers
.
length
|
|
!
!
this
.
_debouncees
.
length
|
|
!
!
this
.
_throttlers
.
length
|
|
this
.
_autorun
;
}
cancel
:
function
(
timer
)
{
var
timerType
=
typeof
timer
;
if
(
timer
&
&
timerType
=
=
=
'
object
'
&
&
timer
.
queue
&
&
timer
.
method
)
{
return
timer
.
queue
.
cancel
(
timer
)
;
}
else
if
(
timerType
=
=
=
'
function
'
)
{
for
(
var
i
=
0
l
=
this
.
_timers
.
length
;
i
<
l
;
i
+
=
2
)
{
if
(
this
.
_timers
[
i
+
1
]
=
=
=
timer
)
{
this
.
_timers
.
splice
(
i
2
)
;
if
(
i
=
=
=
0
)
{
this
.
_reinstallTimerTimeout
(
)
;
}
return
true
;
}
}
}
else
if
(
Object
.
prototype
.
toString
.
call
(
timer
)
=
=
=
'
[
object
Array
]
'
)
{
return
this
.
_cancelItem
(
findThrottler
this
.
_throttlers
timer
)
|
|
this
.
_cancelItem
(
findDebouncee
this
.
_debouncees
timer
)
;
}
else
{
return
;
}
}
_cancelItem
:
function
(
findMethod
array
timer
)
{
var
item
index
;
if
(
timer
.
length
<
3
)
{
return
false
;
}
index
=
findMethod
(
timer
[
0
]
timer
[
1
]
array
)
;
if
(
index
>
-
1
)
{
item
=
array
[
index
]
;
if
(
item
[
2
]
=
=
=
timer
[
2
]
)
{
array
.
splice
(
index
1
)
;
this
.
_platform
.
clearTimeout
(
timer
[
2
]
)
;
return
true
;
}
}
return
false
;
}
_runExpiredTimers
:
function
(
)
{
this
.
_timerTimeoutId
=
undefined
;
this
.
run
(
this
this
.
_scheduleExpiredTimers
)
;
}
_scheduleExpiredTimers
:
function
(
)
{
var
n
=
Date
.
now
(
)
;
var
timers
=
this
.
_timers
;
var
i
=
0
;
var
l
=
timers
.
length
;
for
(
;
i
<
l
;
i
+
=
2
)
{
var
executeAt
=
timers
[
i
]
;
var
fn
=
timers
[
i
+
1
]
;
if
(
executeAt
<
=
n
)
{
this
.
schedule
(
this
.
options
.
defaultQueue
null
fn
)
;
}
else
{
break
;
}
}
timers
.
splice
(
0
i
)
;
this
.
_installTimerTimeout
(
)
;
}
_reinstallTimerTimeout
:
function
(
)
{
this
.
_clearTimerTimeout
(
)
;
this
.
_installTimerTimeout
(
)
;
}
_clearTimerTimeout
:
function
(
)
{
if
(
!
this
.
_timerTimeoutId
)
{
return
;
}
this
.
_platform
.
clearTimeout
(
this
.
_timerTimeoutId
)
;
this
.
_timerTimeoutId
=
undefined
;
}
_installTimerTimeout
:
function
(
)
{
if
(
!
this
.
_timers
.
length
)
{
return
;
}
var
minExpiresAt
=
this
.
_timers
[
0
]
;
var
n
=
Date
.
now
(
)
;
var
wait
=
Math
.
max
(
0
minExpiresAt
-
n
)
;
this
.
_timerTimeoutId
=
this
.
_platform
.
setTimeout
(
this
.
_boundRunExpiredTimers
wait
)
;
}
}
;
Backburner
.
prototype
.
schedule
=
Backburner
.
prototype
.
defer
;
Backburner
.
prototype
.
scheduleOnce
=
Backburner
.
prototype
.
deferOnce
;
Backburner
.
prototype
.
later
=
Backburner
.
prototype
.
setTimeout
;
function
getOnError
(
options
)
{
return
options
.
onError
|
|
options
.
onErrorTarget
&
&
options
.
onErrorTarget
[
options
.
onErrorMethod
]
;
}
function
createAutorun
(
backburner
)
{
backburner
.
begin
(
)
;
backburner
.
_autorun
=
backburner
.
_platform
.
setTimeout
(
function
(
)
{
backburner
.
_autorun
=
null
;
backburner
.
end
(
)
;
}
)
;
}
function
findDebouncee
(
target
method
debouncees
)
{
return
findItem
(
target
method
debouncees
)
;
}
function
findThrottler
(
target
method
throttlers
)
{
return
findItem
(
target
method
throttlers
)
;
}
function
findItem
(
target
method
collection
)
{
var
item
;
var
index
=
-
1
;
for
(
var
i
=
0
l
=
collection
.
length
;
i
<
l
;
i
+
+
)
{
item
=
collection
[
i
]
;
if
(
item
[
0
]
=
=
=
target
&
&
item
[
1
]
=
=
=
method
)
{
index
=
i
;
break
;
}
}
return
index
;
}
function
clearItems
(
item
)
{
this
.
_platform
.
clearTimeout
(
item
[
2
]
)
;
}
}
)
;
enifed
(
"
backburner
/
binary
-
search
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
binarySearch
;
function
binarySearch
(
time
timers
)
{
var
start
=
0
;
var
end
=
timers
.
length
-
2
;
var
middle
l
;
while
(
start
<
end
)
{
l
=
(
end
-
start
)
/
2
;
middle
=
start
+
l
-
l
%
2
;
if
(
time
>
=
timers
[
middle
]
)
{
start
=
middle
+
2
;
}
else
{
end
=
middle
;
}
}
return
time
>
=
timers
[
start
]
?
start
+
2
:
start
;
}
}
)
;
enifed
(
'
backburner
/
deferred
-
action
-
queues
'
[
'
exports
'
'
backburner
/
utils
'
'
backburner
/
queue
'
]
function
(
exports
_backburnerUtils
_backburnerQueue
)
{
'
use
strict
'
;
exports
.
default
=
DeferredActionQueues
;
function
DeferredActionQueues
(
queueNames
options
)
{
var
queues
=
this
.
queues
=
{
}
;
this
.
queueNames
=
queueNames
=
queueNames
|
|
[
]
;
this
.
options
=
options
;
_backburnerUtils
.
each
(
queueNames
function
(
queueName
)
{
queues
[
queueName
]
=
new
_backburnerQueue
.
default
(
queueName
options
[
queueName
]
options
)
;
}
)
;
}
function
noSuchQueue
(
name
)
{
throw
new
Error
(
'
You
attempted
to
schedule
an
action
in
a
queue
(
'
+
name
+
'
)
that
doesn
\
'
t
exist
'
)
;
}
function
noSuchMethod
(
name
)
{
throw
new
Error
(
'
You
attempted
to
schedule
an
action
in
a
queue
(
'
+
name
+
'
)
for
a
method
that
doesn
\
'
t
exist
'
)
;
}
DeferredActionQueues
.
prototype
=
{
schedule
:
function
(
name
target
method
args
onceFlag
stack
)
{
var
queues
=
this
.
queues
;
var
queue
=
queues
[
name
]
;
if
(
!
queue
)
{
noSuchQueue
(
name
)
;
}
if
(
!
method
)
{
noSuchMethod
(
name
)
;
}
if
(
onceFlag
)
{
return
queue
.
pushUnique
(
target
method
args
stack
)
;
}
else
{
return
queue
.
push
(
target
method
args
stack
)
;
}
}
flush
:
function
(
)
{
var
queues
=
this
.
queues
;
var
queueNames
=
this
.
queueNames
;
var
queueName
queue
;
var
queueNameIndex
=
0
;
var
numberOfQueues
=
queueNames
.
length
;
while
(
queueNameIndex
<
numberOfQueues
)
{
queueName
=
queueNames
[
queueNameIndex
]
;
queue
=
queues
[
queueName
]
;
var
numberOfQueueItems
=
queue
.
_queue
.
length
;
if
(
numberOfQueueItems
=
=
=
0
)
{
queueNameIndex
+
+
;
}
else
{
queue
.
flush
(
false
)
;
queueNameIndex
=
0
;
}
}
}
}
;
}
)
;
enifed
(
'
backburner
/
platform
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
GlobalContext
;
if
(
typeof
self
=
=
=
'
object
'
)
{
GlobalContext
=
self
;
}
else
if
(
typeof
global
=
=
=
'
object
'
)
{
GlobalContext
=
global
;
}
else
if
(
typeof
window
=
=
=
'
object
'
)
{
GlobalContext
=
window
;
}
else
{
throw
new
Error
(
'
no
global
:
self
global
nor
window
was
found
'
)
;
}
exports
.
default
=
GlobalContext
;
}
)
;
enifed
(
'
backburner
/
queue
'
[
'
exports
'
'
backburner
/
utils
'
]
function
(
exports
_backburnerUtils
)
{
'
use
strict
'
;
exports
.
default
=
Queue
;
function
Queue
(
name
options
globalOptions
)
{
this
.
name
=
name
;
this
.
globalOptions
=
globalOptions
|
|
{
}
;
this
.
options
=
options
;
this
.
_queue
=
[
]
;
this
.
targetQueues
=
{
}
;
this
.
_queueBeingFlushed
=
undefined
;
}
Queue
.
prototype
=
{
push
:
function
(
target
method
args
stack
)
{
var
queue
=
this
.
_queue
;
queue
.
push
(
target
method
args
stack
)
;
return
{
queue
:
this
target
:
target
method
:
method
}
;
}
pushUniqueWithoutGuid
:
function
(
target
method
args
stack
)
{
var
queue
=
this
.
_queue
;
for
(
var
i
=
0
l
=
queue
.
length
;
i
<
l
;
i
+
=
4
)
{
var
currentTarget
=
queue
[
i
]
;
var
currentMethod
=
queue
[
i
+
1
]
;
if
(
currentTarget
=
=
=
target
&
&
currentMethod
=
=
=
method
)
{
queue
[
i
+
2
]
=
args
;
queue
[
i
+
3
]
=
stack
;
return
;
}
}
queue
.
push
(
target
method
args
stack
)
;
}
targetQueue
:
function
(
targetQueue
target
method
args
stack
)
{
var
queue
=
this
.
_queue
;
for
(
var
i
=
0
l
=
targetQueue
.
length
;
i
<
l
;
i
+
=
2
)
{
var
currentMethod
=
targetQueue
[
i
]
;
var
currentIndex
=
targetQueue
[
i
+
1
]
;
if
(
currentMethod
=
=
=
method
)
{
queue
[
currentIndex
+
2
]
=
args
;
queue
[
currentIndex
+
3
]
=
stack
;
return
;
}
}
targetQueue
.
push
(
method
queue
.
push
(
target
method
args
stack
)
-
4
)
;
}
pushUniqueWithGuid
:
function
(
guid
target
method
args
stack
)
{
var
hasLocalQueue
=
this
.
targetQueues
[
guid
]
;
if
(
hasLocalQueue
)
{
this
.
targetQueue
(
hasLocalQueue
target
method
args
stack
)
;
}
else
{
this
.
targetQueues
[
guid
]
=
[
method
this
.
_queue
.
push
(
target
method
args
stack
)
-
4
]
;
}
return
{
queue
:
this
target
:
target
method
:
method
}
;
}
pushUnique
:
function
(
target
method
args
stack
)
{
var
KEY
=
this
.
globalOptions
.
GUID_KEY
;
if
(
target
&
&
KEY
)
{
var
guid
=
target
[
KEY
]
;
if
(
guid
)
{
return
this
.
pushUniqueWithGuid
(
guid
target
method
args
stack
)
;
}
}
this
.
pushUniqueWithoutGuid
(
target
method
args
stack
)
;
return
{
queue
:
this
target
:
target
method
:
method
}
;
}
invoke
:
function
(
target
method
args
_
_errorRecordedForStack
)
{
if
(
args
&
&
args
.
length
>
0
)
{
method
.
apply
(
target
args
)
;
}
else
{
method
.
call
(
target
)
;
}
}
invokeWithOnError
:
function
(
target
method
args
onError
errorRecordedForStack
)
{
try
{
if
(
args
&
&
args
.
length
>
0
)
{
method
.
apply
(
target
args
)
;
}
else
{
method
.
call
(
target
)
;
}
}
catch
(
error
)
{
onError
(
error
errorRecordedForStack
)
;
}
}
flush
:
function
(
sync
)
{
var
queue
=
this
.
_queue
;
var
length
=
queue
.
length
;
if
(
length
=
=
=
0
)
{
return
;
}
var
globalOptions
=
this
.
globalOptions
;
var
options
=
this
.
options
;
var
before
=
options
&
&
options
.
before
;
var
after
=
options
&
&
options
.
after
;
var
onError
=
globalOptions
.
onError
|
|
globalOptions
.
onErrorTarget
&
&
globalOptions
.
onErrorTarget
[
globalOptions
.
onErrorMethod
]
;
var
target
method
args
errorRecordedForStack
;
var
invoke
=
onError
?
this
.
invokeWithOnError
:
this
.
invoke
;
this
.
targetQueues
=
Object
.
create
(
null
)
;
var
queueItems
=
this
.
_queueBeingFlushed
=
this
.
_queue
.
slice
(
)
;
this
.
_queue
=
[
]
;
if
(
before
)
{
before
(
)
;
}
for
(
var
i
=
0
;
i
<
length
;
i
+
=
4
)
{
target
=
queueItems
[
i
]
;
method
=
queueItems
[
i
+
1
]
;
args
=
queueItems
[
i
+
2
]
;
errorRecordedForStack
=
queueItems
[
i
+
3
]
;
if
(
_backburnerUtils
.
isString
(
method
)
)
{
method
=
target
[
method
]
;
}
if
(
method
)
{
invoke
(
target
method
args
onError
errorRecordedForStack
)
;
}
}
if
(
after
)
{
after
(
)
;
}
this
.
_queueBeingFlushed
=
undefined
;
if
(
sync
!
=
=
false
&
&
this
.
_queue
.
length
>
0
)
{
this
.
flush
(
true
)
;
}
}
cancel
:
function
(
actionToCancel
)
{
var
queue
=
this
.
_queue
currentTarget
currentMethod
i
l
;
var
target
=
actionToCancel
.
target
;
var
method
=
actionToCancel
.
method
;
var
GUID_KEY
=
this
.
globalOptions
.
GUID_KEY
;
if
(
GUID_KEY
&
&
this
.
targetQueues
&
&
target
)
{
var
targetQueue
=
this
.
targetQueues
[
target
[
GUID_KEY
]
]
;
if
(
targetQueue
)
{
for
(
i
=
0
l
=
targetQueue
.
length
;
i
<
l
;
i
+
+
)
{
if
(
targetQueue
[
i
]
=
=
=
method
)
{
targetQueue
.
splice
(
i
1
)
;
}
}
}
}
for
(
i
=
0
l
=
queue
.
length
;
i
<
l
;
i
+
=
4
)
{
currentTarget
=
queue
[
i
]
;
currentMethod
=
queue
[
i
+
1
]
;
if
(
currentTarget
=
=
=
target
&
&
currentMethod
=
=
=
method
)
{
queue
.
splice
(
i
4
)
;
return
true
;
}
}
queue
=
this
.
_queueBeingFlushed
;
if
(
!
queue
)
{
return
;
}
for
(
i
=
0
l
=
queue
.
length
;
i
<
l
;
i
+
=
4
)
{
currentTarget
=
queue
[
i
]
;
currentMethod
=
queue
[
i
+
1
]
;
if
(
currentTarget
=
=
=
target
&
&
currentMethod
=
=
=
method
)
{
queue
[
i
+
1
]
=
null
;
return
true
;
}
}
}
}
;
}
)
;
enifed
(
'
backburner
/
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
each
=
each
;
exports
.
isString
=
isString
;
exports
.
isFunction
=
isFunction
;
exports
.
isNumber
=
isNumber
;
exports
.
isCoercableNumber
=
isCoercableNumber
;
var
NUMBER
=
/
\
d
+
/
;
function
each
(
collection
callback
)
{
for
(
var
i
=
0
;
i
<
collection
.
length
;
i
+
+
)
{
callback
(
collection
[
i
]
)
;
}
}
function
isString
(
suspect
)
{
return
typeof
suspect
=
=
=
'
string
'
;
}
function
isFunction
(
suspect
)
{
return
typeof
suspect
=
=
=
'
function
'
;
}
function
isNumber
(
suspect
)
{
return
typeof
suspect
=
=
=
'
number
'
;
}
function
isCoercableNumber
(
number
)
{
return
isNumber
(
number
)
|
|
NUMBER
.
test
(
number
)
;
}
}
)
;
enifed
(
'
container
/
container
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
dictionary
'
'
ember
-
metal
/
features
'
'
container
/
owner
'
'
ember
-
runtime
/
mixins
/
container_proxy
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberMetalDictionary
_emberMetalFeatures
_containerOwner
_emberRuntimeMixinsContainer_proxy
_emberMetalSymbol
)
{
'
use
strict
'
;
var
CONTAINER_OVERRIDE
=
_emberMetalSymbol
.
default
(
'
CONTAINER_OVERRIDE
'
)
;
function
Container
(
registry
options
)
{
this
.
registry
=
registry
;
this
.
owner
=
options
&
&
options
.
owner
?
options
.
owner
:
null
;
this
.
cache
=
_emberMetalDictionary
.
default
(
options
&
&
options
.
cache
?
options
.
cache
:
null
)
;
this
.
factoryCache
=
_emberMetalDictionary
.
default
(
options
&
&
options
.
factoryCache
?
options
.
factoryCache
:
null
)
;
this
.
validationCache
=
_emberMetalDictionary
.
default
(
options
&
&
options
.
validationCache
?
options
.
validationCache
:
null
)
;
this
.
_fakeContainerToInject
=
_emberRuntimeMixinsContainer_proxy
.
buildFakeContainerWithDeprecations
(
this
)
;
this
[
CONTAINER_OVERRIDE
]
=
undefined
;
}
Container
.
prototype
=
{
owner
:
null
registry
:
null
cache
:
null
factoryCache
:
null
validationCache
:
null
lookup
:
function
(
fullName
options
)
{
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
registry
.
validateFullName
(
fullName
)
)
;
return
lookup
(
this
this
.
registry
.
normalize
(
fullName
)
options
)
;
}
lookupFactory
:
function
(
fullName
options
)
{
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
registry
.
validateFullName
(
fullName
)
)
;
return
factoryFor
(
this
this
.
registry
.
normalize
(
fullName
)
options
)
;
}
destroy
:
function
(
)
{
eachDestroyable
(
this
function
(
item
)
{
if
(
item
.
destroy
)
{
item
.
destroy
(
)
;
}
}
)
;
this
.
isDestroyed
=
true
;
}
reset
:
function
(
fullName
)
{
if
(
arguments
.
length
>
0
)
{
resetMember
(
this
this
.
registry
.
normalize
(
fullName
)
)
;
}
else
{
resetCache
(
this
)
;
}
}
ownerInjection
:
function
(
)
{
var
_ref
;
return
_ref
=
{
}
_ref
[
_containerOwner
.
OWNER
]
=
this
.
owner
_ref
;
}
}
;
function
isSingleton
(
container
fullName
)
{
return
container
.
registry
.
getOption
(
fullName
'
singleton
'
)
!
=
=
false
;
}
function
lookup
(
container
fullName
)
{
var
options
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
{
}
:
arguments
[
2
]
;
if
(
options
.
source
)
{
fullName
=
container
.
registry
.
expandLocalLookup
(
fullName
options
)
;
if
(
!
fullName
)
{
return
;
}
}
if
(
container
.
cache
[
fullName
]
!
=
=
undefined
&
&
options
.
singleton
!
=
=
false
)
{
return
container
.
cache
[
fullName
]
;
}
var
value
=
instantiate
(
container
fullName
)
;
if
(
value
=
=
=
undefined
)
{
return
;
}
if
(
isSingleton
(
container
fullName
)
&
&
options
.
singleton
!
=
=
false
)
{
container
.
cache
[
fullName
]
=
value
;
}
return
value
;
}
function
markInjectionsAsDynamic
(
injections
)
{
injections
.
_dynamic
=
true
;
}
function
areInjectionsDynamic
(
injections
)
{
return
!
!
injections
.
_dynamic
;
}
function
buildInjections
(
)
{
var
hash
=
{
}
;
if
(
arguments
.
length
>
1
)
{
var
container
=
arguments
[
0
]
;
var
injections
=
[
]
;
var
injection
;
for
(
var
i
=
1
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
if
(
arguments
[
i
]
)
{
injections
=
injections
.
concat
(
arguments
[
i
]
)
;
}
}
container
.
registry
.
validateInjections
(
injections
)
;
for
(
i
=
0
l
=
injections
.
length
;
i
<
l
;
i
+
+
)
{
injection
=
injections
[
i
]
;
hash
[
injection
.
property
]
=
lookup
(
container
injection
.
fullName
)
;
if
(
!
isSingleton
(
container
injection
.
fullName
)
)
{
markInjectionsAsDynamic
(
hash
)
;
}
}
}
return
hash
;
}
function
factoryFor
(
container
fullName
)
{
var
options
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
{
}
:
arguments
[
2
]
;
var
registry
=
container
.
registry
;
if
(
options
.
source
)
{
fullName
=
registry
.
expandLocalLookup
(
fullName
options
)
;
if
(
!
fullName
)
{
return
;
}
}
var
cache
=
container
.
factoryCache
;
if
(
cache
[
fullName
]
)
{
return
cache
[
fullName
]
;
}
var
factory
=
registry
.
resolve
(
fullName
)
;
if
(
factory
=
=
=
undefined
)
{
return
;
}
var
type
=
fullName
.
split
(
'
:
'
)
[
0
]
;
if
(
!
factory
|
|
typeof
factory
.
extend
!
=
=
'
function
'
|
|
!
_emberMetalCore
.
default
.
MODEL_FACTORY_INJECTIONS
&
&
type
=
=
=
'
model
'
)
{
if
(
factory
&
&
typeof
factory
.
_onLookup
=
=
=
'
function
'
)
{
factory
.
_onLookup
(
fullName
)
;
}
cache
[
fullName
]
=
factory
;
return
factory
;
}
else
{
var
injections
=
injectionsFor
(
container
fullName
)
;
var
factoryInjections
=
factoryInjectionsFor
(
container
fullName
)
;
var
cacheable
=
!
areInjectionsDynamic
(
injections
)
&
&
!
areInjectionsDynamic
(
factoryInjections
)
;
factoryInjections
.
_toString
=
registry
.
makeToString
(
factory
fullName
)
;
var
injectedFactory
=
factory
.
extend
(
injections
)
;
injectDeprecatedContainer
(
injectedFactory
.
prototype
container
)
;
injectedFactory
.
reopenClass
(
factoryInjections
)
;
if
(
factory
&
&
typeof
factory
.
_onLookup
=
=
=
'
function
'
)
{
factory
.
_onLookup
(
fullName
)
;
}
if
(
cacheable
)
{
cache
[
fullName
]
=
injectedFactory
;
}
return
injectedFactory
;
}
}
function
injectionsFor
(
container
fullName
)
{
var
registry
=
container
.
registry
;
var
splitName
=
fullName
.
split
(
'
:
'
)
;
var
type
=
splitName
[
0
]
;
var
injections
=
buildInjections
(
container
registry
.
getTypeInjections
(
type
)
registry
.
getInjections
(
fullName
)
)
;
injections
.
_debugContainerKey
=
fullName
;
_containerOwner
.
setOwner
(
injections
container
.
owner
)
;
return
injections
;
}
function
factoryInjectionsFor
(
container
fullName
)
{
var
registry
=
container
.
registry
;
var
splitName
=
fullName
.
split
(
'
:
'
)
;
var
type
=
splitName
[
0
]
;
var
factoryInjections
=
buildInjections
(
container
registry
.
getFactoryTypeInjections
(
type
)
registry
.
getFactoryInjections
(
fullName
)
)
;
factoryInjections
.
_debugContainerKey
=
fullName
;
return
factoryInjections
;
}
function
instantiate
(
container
fullName
)
{
var
factory
=
factoryFor
(
container
fullName
)
;
var
lazyInjections
validationCache
;
if
(
container
.
registry
.
getOption
(
fullName
'
instantiate
'
)
=
=
=
false
)
{
return
factory
;
}
if
(
factory
)
{
if
(
typeof
factory
.
create
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Failed
to
create
an
instance
of
\
'
'
+
fullName
+
'
\
'
.
'
+
'
Most
likely
an
improperly
defined
class
or
an
invalid
module
export
.
'
)
;
}
validationCache
=
container
.
validationCache
;
_emberMetalDebug
.
runInDebug
(
function
(
)
{
if
(
!
validationCache
[
fullName
]
&
&
typeof
factory
.
_lazyInjections
=
=
=
'
function
'
)
{
lazyInjections
=
factory
.
_lazyInjections
(
)
;
lazyInjections
=
container
.
registry
.
normalizeInjectionsHash
(
lazyInjections
)
;
container
.
registry
.
validateInjections
(
lazyInjections
)
;
}
}
)
;
validationCache
[
fullName
]
=
true
;
var
obj
=
undefined
;
if
(
typeof
factory
.
extend
=
=
=
'
function
'
)
{
obj
=
factory
.
create
(
)
;
}
else
{
var
injections
=
injectionsFor
(
container
fullName
)
;
injections
.
container
=
container
.
_fakeContainerToInject
;
obj
=
factory
.
create
(
injections
)
;
if
(
!
Object
.
isFrozen
(
obj
)
&
&
'
container
'
in
obj
)
{
injectDeprecatedContainer
(
obj
container
)
;
}
}
return
obj
;
}
}
function
injectDeprecatedContainer
(
object
container
)
{
Object
.
defineProperty
(
object
'
container
'
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
Using
the
injected
container
is
deprecated
.
Please
use
the
getOwner
helper
instead
to
access
the
owner
of
this
object
.
'
false
{
id
:
'
ember
-
application
.
injected
-
container
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_injected
-
container
-
access
'
}
)
;
return
this
[
CONTAINER_OVERRIDE
]
|
|
container
;
}
set
:
function
(
value
)
{
_emberMetalDebug
.
deprecate
(
'
Providing
the
container
property
to
'
+
this
+
'
is
deprecated
.
Please
use
Ember
.
setOwner
or
owner
.
ownerInjection
(
)
instead
to
provide
an
owner
to
the
instance
being
created
.
'
false
{
id
:
'
ember
-
application
.
injected
-
container
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_injected
-
container
-
access
'
}
)
;
this
[
CONTAINER_OVERRIDE
]
=
value
;
return
value
;
}
}
)
;
}
function
eachDestroyable
(
container
callback
)
{
var
cache
=
container
.
cache
;
var
keys
=
Object
.
keys
(
cache
)
;
var
key
value
;
for
(
var
i
=
0
l
=
keys
.
length
;
i
<
l
;
i
+
+
)
{
key
=
keys
[
i
]
;
value
=
cache
[
key
]
;
if
(
container
.
registry
.
getOption
(
key
'
instantiate
'
)
!
=
=
false
)
{
callback
(
value
)
;
}
}
}
function
resetCache
(
container
)
{
eachDestroyable
(
container
function
(
value
)
{
if
(
value
.
destroy
)
{
value
.
destroy
(
)
;
}
}
)
;
container
.
cache
.
dict
=
_emberMetalDictionary
.
default
(
null
)
;
}
function
resetMember
(
container
fullName
)
{
var
member
=
container
.
cache
[
fullName
]
;
delete
container
.
factoryCache
[
fullName
]
;
if
(
member
)
{
delete
container
.
cache
[
fullName
]
;
if
(
member
.
destroy
)
{
member
.
destroy
(
)
;
}
}
}
exports
.
default
=
Container
;
}
)
;
enifed
(
'
container
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
container
/
registry
'
'
container
/
container
'
'
container
/
owner
'
]
function
(
exports
_emberMetalCore
_containerRegistry
_containerContainer
_containerOwner
)
{
'
use
strict
'
;
_emberMetalCore
.
default
.
MODEL_FACTORY_INJECTIONS
=
false
;
if
(
_emberMetalCore
.
default
.
ENV
&
&
typeof
_emberMetalCore
.
default
.
ENV
.
MODEL_FACTORY_INJECTIONS
!
=
=
'
undefined
'
)
{
_emberMetalCore
.
default
.
MODEL_FACTORY_INJECTIONS
=
!
!
_emberMetalCore
.
default
.
ENV
.
MODEL_FACTORY_INJECTIONS
;
}
exports
.
Registry
=
_containerRegistry
.
default
;
exports
.
Container
=
_containerContainer
.
default
;
exports
.
getOwner
=
_containerOwner
.
getOwner
;
exports
.
setOwner
=
_containerOwner
.
setOwner
;
}
)
;
enifed
(
'
container
/
owner
'
[
'
exports
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberMetalSymbol
)
{
'
use
strict
'
;
exports
.
getOwner
=
getOwner
;
exports
.
setOwner
=
setOwner
;
var
OWNER
=
_emberMetalSymbol
.
default
(
'
OWNER
'
)
;
exports
.
OWNER
=
OWNER
;
function
getOwner
(
object
)
{
return
object
[
OWNER
]
;
}
function
setOwner
(
object
owner
)
{
object
[
OWNER
]
=
owner
;
}
}
)
;
enifed
(
'
container
/
registry
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
dictionary
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
assign
'
'
container
/
container
'
'
ember
-
metal
/
utils
'
]
function
(
exports
_emberMetalFeatures
_emberMetalDebug
_emberMetalDictionary
_emberMetalEmpty_object
_emberMetalAssign
_containerContainer
_emberMetalUtils
)
{
'
use
strict
'
;
exports
.
privatize
=
privatize
;
var
VALID_FULL_NAME_REGEXP
=
/
^
[
^
:
]
+
:
[
^
:
]
+
/
;
function
Registry
(
options
)
{
this
.
fallback
=
options
&
&
options
.
fallback
?
options
.
fallback
:
null
;
if
(
options
&
&
options
.
resolver
)
{
this
.
resolver
=
options
.
resolver
;
if
(
typeof
this
.
resolver
=
=
=
'
function
'
)
{
deprecateResolverFunction
(
this
)
;
}
}
this
.
registrations
=
_emberMetalDictionary
.
default
(
options
&
&
options
.
registrations
?
options
.
registrations
:
null
)
;
this
.
_typeInjections
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_injections
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_factoryTypeInjections
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_factoryInjections
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_localLookupCache
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
_normalizeCache
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_resolveCache
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_failCache
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_options
=
_emberMetalDictionary
.
default
(
null
)
;
this
.
_typeOptions
=
_emberMetalDictionary
.
default
(
null
)
;
}
Registry
.
prototype
=
{
fallback
:
null
resolver
:
null
registrations
:
null
_typeInjections
:
null
_injections
:
null
_factoryTypeInjections
:
null
_factoryInjections
:
null
_normalizeCache
:
null
_resolveCache
:
null
_options
:
null
_typeOptions
:
null
container
:
function
(
options
)
{
return
new
_containerContainer
.
default
(
this
options
)
;
}
register
:
function
(
fullName
factory
)
{
var
options
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
{
}
:
arguments
[
2
]
;
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
validateFullName
(
fullName
)
)
;
if
(
factory
=
=
=
undefined
)
{
throw
new
TypeError
(
'
Attempting
to
register
an
unknown
factory
:
'
+
fullName
+
'
'
)
;
}
var
normalizedName
=
this
.
normalize
(
fullName
)
;
if
(
this
.
_resolveCache
[
normalizedName
]
)
{
throw
new
Error
(
'
Cannot
re
-
register
:
'
+
fullName
+
'
as
it
has
already
been
resolved
.
'
)
;
}
delete
this
.
_failCache
[
normalizedName
]
;
this
.
registrations
[
normalizedName
]
=
factory
;
this
.
_options
[
normalizedName
]
=
options
;
}
unregister
:
function
(
fullName
)
{
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
validateFullName
(
fullName
)
)
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
this
.
_localLookupCache
=
new
_emberMetalEmpty_object
.
default
(
)
;
delete
this
.
registrations
[
normalizedName
]
;
delete
this
.
_resolveCache
[
normalizedName
]
;
delete
this
.
_failCache
[
normalizedName
]
;
delete
this
.
_options
[
normalizedName
]
;
}
resolve
:
function
(
fullName
options
)
{
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
validateFullName
(
fullName
)
)
;
var
factory
=
resolve
(
this
this
.
normalize
(
fullName
)
options
)
;
if
(
factory
=
=
=
undefined
&
&
this
.
fallback
)
{
var
_fallback
;
factory
=
(
_fallback
=
this
.
fallback
)
.
resolve
.
apply
(
_fallback
arguments
)
;
}
return
factory
;
}
describe
:
function
(
fullName
)
{
if
(
this
.
resolver
&
&
this
.
resolver
.
lookupDescription
)
{
return
this
.
resolver
.
lookupDescription
(
fullName
)
;
}
else
if
(
this
.
fallback
)
{
return
this
.
fallback
.
describe
(
fullName
)
;
}
else
{
return
fullName
;
}
}
normalizeFullName
:
function
(
fullName
)
{
if
(
this
.
resolver
&
&
this
.
resolver
.
normalize
)
{
return
this
.
resolver
.
normalize
(
fullName
)
;
}
else
if
(
this
.
fallback
)
{
return
this
.
fallback
.
normalizeFullName
(
fullName
)
;
}
else
{
return
fullName
;
}
}
normalize
:
function
(
fullName
)
{
return
this
.
_normalizeCache
[
fullName
]
|
|
(
this
.
_normalizeCache
[
fullName
]
=
this
.
normalizeFullName
(
fullName
)
)
;
}
makeToString
:
function
(
factory
fullName
)
{
if
(
this
.
resolver
&
&
this
.
resolver
.
makeToString
)
{
return
this
.
resolver
.
makeToString
(
factory
fullName
)
;
}
else
if
(
this
.
fallback
)
{
return
this
.
fallback
.
makeToString
(
factory
fullName
)
;
}
else
{
return
factory
.
toString
(
)
;
}
}
has
:
function
(
fullName
options
)
{
if
(
!
this
.
isValidFullName
(
fullName
)
)
{
return
false
;
}
var
source
=
undefined
;
source
=
options
&
&
options
.
source
&
&
this
.
normalize
(
options
.
source
)
;
return
has
(
this
this
.
normalize
(
fullName
)
source
)
;
}
optionsForType
:
function
(
type
options
)
{
this
.
_typeOptions
[
type
]
=
options
;
}
getOptionsForType
:
function
(
type
)
{
var
optionsForType
=
this
.
_typeOptions
[
type
]
;
if
(
optionsForType
=
=
=
undefined
&
&
this
.
fallback
)
{
optionsForType
=
this
.
fallback
.
getOptionsForType
(
type
)
;
}
return
optionsForType
;
}
options
:
function
(
fullName
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
this
.
_options
[
normalizedName
]
=
options
;
}
getOptions
:
function
(
fullName
)
{
var
normalizedName
=
this
.
normalize
(
fullName
)
;
var
options
=
this
.
_options
[
normalizedName
]
;
if
(
options
=
=
=
undefined
&
&
this
.
fallback
)
{
options
=
this
.
fallback
.
getOptions
(
fullName
)
;
}
return
options
;
}
getOption
:
function
(
fullName
optionName
)
{
var
options
=
this
.
_options
[
fullName
]
;
if
(
options
&
&
options
[
optionName
]
!
=
=
undefined
)
{
return
options
[
optionName
]
;
}
var
type
=
fullName
.
split
(
'
:
'
)
[
0
]
;
options
=
this
.
_typeOptions
[
type
]
;
if
(
options
&
&
options
[
optionName
]
!
=
=
undefined
)
{
return
options
[
optionName
]
;
}
else
if
(
this
.
fallback
)
{
return
this
.
fallback
.
getOption
(
fullName
optionName
)
;
}
}
typeInjection
:
function
(
type
property
fullName
)
{
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
validateFullName
(
fullName
)
)
;
var
fullNameType
=
fullName
.
split
(
'
:
'
)
[
0
]
;
if
(
fullNameType
=
=
=
type
)
{
throw
new
Error
(
'
Cannot
inject
a
'
+
fullName
+
'
on
other
'
+
type
+
'
(
s
)
.
'
)
;
}
var
injections
=
this
.
_typeInjections
[
type
]
|
|
(
this
.
_typeInjections
[
type
]
=
[
]
)
;
injections
.
push
(
{
property
:
property
fullName
:
fullName
}
)
;
}
injection
:
function
(
fullName
property
injectionName
)
{
this
.
validateFullName
(
injectionName
)
;
var
normalizedInjectionName
=
this
.
normalize
(
injectionName
)
;
if
(
fullName
.
indexOf
(
'
:
'
)
=
=
=
-
1
)
{
return
this
.
typeInjection
(
fullName
property
normalizedInjectionName
)
;
}
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
validateFullName
(
fullName
)
)
;
var
normalizedName
=
this
.
normalize
(
fullName
)
;
var
injections
=
this
.
_injections
[
normalizedName
]
|
|
(
this
.
_injections
[
normalizedName
]
=
[
]
)
;
injections
.
push
(
{
property
:
property
fullName
:
normalizedInjectionName
}
)
;
}
factoryTypeInjection
:
function
(
type
property
fullName
)
{
var
injections
=
this
.
_factoryTypeInjections
[
type
]
|
|
(
this
.
_factoryTypeInjections
[
type
]
=
[
]
)
;
injections
.
push
(
{
property
:
property
fullName
:
this
.
normalize
(
fullName
)
}
)
;
}
factoryInjection
:
function
(
fullName
property
injectionName
)
{
var
normalizedName
=
this
.
normalize
(
fullName
)
;
var
normalizedInjectionName
=
this
.
normalize
(
injectionName
)
;
this
.
validateFullName
(
injectionName
)
;
if
(
fullName
.
indexOf
(
'
:
'
)
=
=
=
-
1
)
{
return
this
.
factoryTypeInjection
(
normalizedName
property
normalizedInjectionName
)
;
}
var
injections
=
this
.
_factoryInjections
[
normalizedName
]
|
|
(
this
.
_factoryInjections
[
normalizedName
]
=
[
]
)
;
injections
.
push
(
{
property
:
property
fullName
:
normalizedInjectionName
}
)
;
}
knownForType
:
function
(
type
)
{
var
fallbackKnown
=
undefined
resolverKnown
=
undefined
;
var
localKnown
=
_emberMetalDictionary
.
default
(
null
)
;
var
registeredNames
=
Object
.
keys
(
this
.
registrations
)
;
for
(
var
index
=
0
_length
=
registeredNames
.
length
;
index
<
_length
;
index
+
+
)
{
var
fullName
=
registeredNames
[
index
]
;
var
itemType
=
fullName
.
split
(
'
:
'
)
[
0
]
;
if
(
itemType
=
=
=
type
)
{
localKnown
[
fullName
]
=
true
;
}
}
if
(
this
.
fallback
)
{
fallbackKnown
=
this
.
fallback
.
knownForType
(
type
)
;
}
if
(
this
.
resolver
&
&
this
.
resolver
.
knownForType
)
{
resolverKnown
=
this
.
resolver
.
knownForType
(
type
)
;
}
return
_emberMetalAssign
.
default
(
{
}
fallbackKnown
localKnown
resolverKnown
)
;
}
validateFullName
:
function
(
fullName
)
{
if
(
!
this
.
isValidFullName
(
fullName
)
)
{
throw
new
TypeError
(
'
Invalid
Fullname
expected
:
type
:
name
got
:
'
+
fullName
)
;
}
return
true
;
}
isValidFullName
:
function
(
fullName
)
{
return
!
!
VALID_FULL_NAME_REGEXP
.
test
(
fullName
)
;
}
validateInjections
:
function
(
injections
)
{
if
(
!
injections
)
{
return
;
}
var
fullName
;
for
(
var
i
=
0
length
=
injections
.
length
;
i
<
length
;
i
+
+
)
{
fullName
=
injections
[
i
]
.
fullName
;
if
(
!
this
.
has
(
fullName
)
)
{
throw
new
Error
(
'
Attempting
to
inject
an
unknown
injection
:
'
+
fullName
+
'
'
)
;
}
}
}
normalizeInjectionsHash
:
function
(
hash
)
{
var
injections
=
[
]
;
for
(
var
key
in
hash
)
{
if
(
hash
.
hasOwnProperty
(
key
)
)
{
_emberMetalDebug
.
assert
(
'
Expected
a
proper
full
name
given
\
'
'
+
hash
[
key
]
+
'
\
'
'
this
.
validateFullName
(
hash
[
key
]
)
)
;
injections
.
push
(
{
property
:
key
fullName
:
hash
[
key
]
}
)
;
}
}
return
injections
;
}
getInjections
:
function
(
fullName
)
{
var
injections
=
this
.
_injections
[
fullName
]
|
|
[
]
;
if
(
this
.
fallback
)
{
injections
=
injections
.
concat
(
this
.
fallback
.
getInjections
(
fullName
)
)
;
}
return
injections
;
}
getTypeInjections
:
function
(
type
)
{
var
injections
=
this
.
_typeInjections
[
type
]
|
|
[
]
;
if
(
this
.
fallback
)
{
injections
=
injections
.
concat
(
this
.
fallback
.
getTypeInjections
(
type
)
)
;
}
return
injections
;
}
getFactoryInjections
:
function
(
fullName
)
{
var
injections
=
this
.
_factoryInjections
[
fullName
]
|
|
[
]
;
if
(
this
.
fallback
)
{
injections
=
injections
.
concat
(
this
.
fallback
.
getFactoryInjections
(
fullName
)
)
;
}
return
injections
;
}
getFactoryTypeInjections
:
function
(
type
)
{
var
injections
=
this
.
_factoryTypeInjections
[
type
]
|
|
[
]
;
if
(
this
.
fallback
)
{
injections
=
injections
.
concat
(
this
.
fallback
.
getFactoryTypeInjections
(
type
)
)
;
}
return
injections
;
}
}
;
function
deprecateResolverFunction
(
registry
)
{
_emberMetalDebug
.
deprecate
(
'
Passing
a
resolver
function
into
a
Registry
is
deprecated
.
Please
pass
in
a
Resolver
object
with
a
resolve
method
.
'
false
{
id
:
'
ember
-
application
.
registry
-
resolver
-
as
-
function
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_registry
-
resolver
-
as
-
function
'
}
)
;
registry
.
resolver
=
{
resolve
:
registry
.
resolver
}
;
}
Registry
.
prototype
.
expandLocalLookup
=
function
Registry_expandLocalLookup
(
fullName
options
)
{
if
(
this
.
resolver
&
&
this
.
resolver
.
expandLocalLookup
)
{
_emberMetalDebug
.
assert
(
'
fullName
must
be
a
proper
full
name
'
this
.
validateFullName
(
fullName
)
)
;
_emberMetalDebug
.
assert
(
'
options
.
source
must
be
provided
to
expandLocalLookup
'
options
&
&
options
.
source
)
;
_emberMetalDebug
.
assert
(
'
options
.
source
must
be
a
proper
full
name
'
this
.
validateFullName
(
options
.
source
)
)
;
var
normalizedFullName
=
this
.
normalize
(
fullName
)
;
var
normalizedSource
=
this
.
normalize
(
options
.
source
)
;
return
expandLocalLookup
(
this
normalizedFullName
normalizedSource
)
;
}
else
if
(
this
.
fallback
)
{
return
this
.
fallback
.
expandLocalLookup
(
fullName
options
)
;
}
else
{
return
null
;
}
}
;
function
expandLocalLookup
(
registry
normalizedName
normalizedSource
)
{
var
cache
=
registry
.
_localLookupCache
;
var
normalizedNameCache
=
cache
[
normalizedName
]
;
if
(
!
normalizedNameCache
)
{
normalizedNameCache
=
cache
[
normalizedName
]
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
var
cached
=
normalizedNameCache
[
normalizedSource
]
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
var
expanded
=
registry
.
resolver
.
expandLocalLookup
(
normalizedName
normalizedSource
)
;
return
normalizedNameCache
[
normalizedSource
]
=
expanded
;
}
function
resolve
(
registry
normalizedName
options
)
{
if
(
options
&
&
options
.
source
)
{
normalizedName
=
registry
.
expandLocalLookup
(
normalizedName
options
)
;
if
(
!
normalizedName
)
{
return
;
}
}
var
cached
=
registry
.
_resolveCache
[
normalizedName
]
;
if
(
cached
!
=
=
undefined
)
{
return
cached
;
}
if
(
registry
.
_failCache
[
normalizedName
]
)
{
return
;
}
var
resolved
=
undefined
;
if
(
registry
.
resolver
)
{
resolved
=
registry
.
resolver
.
resolve
(
normalizedName
)
;
}
if
(
resolved
=
=
=
undefined
)
{
resolved
=
registry
.
registrations
[
normalizedName
]
;
}
if
(
resolved
=
=
=
undefined
)
{
registry
.
_failCache
[
normalizedName
]
=
true
;
}
else
{
registry
.
_resolveCache
[
normalizedName
]
=
resolved
;
}
return
resolved
;
}
function
has
(
registry
fullName
source
)
{
return
registry
.
resolve
(
fullName
{
source
:
source
}
)
!
=
=
undefined
;
}
var
privateNames
=
_emberMetalDictionary
.
default
(
null
)
;
var
privateSuffix
=
Math
.
floor
(
Math
.
random
(
)
*
new
Date
(
)
)
+
'
'
;
function
privatize
(
_ref
)
{
var
fullName
=
_ref
[
0
]
;
var
name
=
privateNames
[
fullName
]
;
if
(
name
)
{
return
name
;
}
var
_fullName
split
=
fullName
.
split
(
'
:
'
)
;
var
type
=
_fullName
split
[
0
]
;
var
rawName
=
_fullName
split
[
1
]
;
return
privateNames
[
fullName
]
=
_emberMetalUtils
.
intern
(
type
+
'
:
'
+
rawName
+
'
-
'
+
privateSuffix
)
;
}
exports
.
default
=
Registry
;
}
)
;
enifed
(
'
dag
-
map
'
[
'
exports
'
'
vertex
'
'
visit
'
]
function
(
exports
_vertex
_visit
)
{
'
use
strict
'
;
exports
.
default
=
DAG
;
function
DAG
(
)
{
this
.
names
=
[
]
;
this
.
vertices
=
Object
.
create
(
null
)
;
}
DAG
.
prototype
.
add
=
function
(
name
)
{
if
(
!
name
)
{
throw
new
Error
(
"
Can
'
t
add
Vertex
without
name
"
)
;
}
if
(
this
.
vertices
[
name
]
!
=
=
undefined
)
{
return
this
.
vertices
[
name
]
;
}
var
vertex
=
new
_vertex
.
default
(
name
)
;
this
.
vertices
[
name
]
=
vertex
;
this
.
names
.
push
(
name
)
;
return
vertex
;
}
;
DAG
.
prototype
.
map
=
function
(
name
value
)
{
this
.
add
(
name
)
.
value
=
value
;
}
;
DAG
.
prototype
.
addEdge
=
function
(
fromName
toName
)
{
if
(
!
fromName
|
|
!
toName
|
|
fromName
=
=
=
toName
)
{
return
;
}
var
from
=
this
.
add
(
fromName
)
;
var
to
=
this
.
add
(
toName
)
;
if
(
to
.
incoming
.
hasOwnProperty
(
fromName
)
)
{
return
;
}
function
checkCycle
(
vertex
path
)
{
if
(
vertex
.
name
=
=
=
toName
)
{
throw
new
Error
(
"
cycle
detected
:
"
+
toName
+
"
<
-
"
+
path
.
join
(
"
<
-
"
)
)
;
}
}
_visit
.
default
(
from
checkCycle
)
;
from
.
hasOutgoing
=
true
;
to
.
incoming
[
fromName
]
=
from
;
to
.
incomingNames
.
push
(
fromName
)
;
}
;
DAG
.
prototype
.
topsort
=
function
(
fn
)
{
var
visited
=
{
}
;
var
vertices
=
this
.
vertices
;
var
names
=
this
.
names
;
var
len
=
names
.
length
;
var
i
vertex
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
vertex
=
vertices
[
names
[
i
]
]
;
if
(
!
vertex
.
hasOutgoing
)
{
_visit
.
default
(
vertex
fn
visited
)
;
}
}
}
;
DAG
.
prototype
.
addEdges
=
function
(
name
value
before
after
)
{
var
i
;
this
.
map
(
name
value
)
;
if
(
before
)
{
if
(
typeof
before
=
=
=
'
string
'
)
{
this
.
addEdge
(
name
before
)
;
}
else
{
for
(
i
=
0
;
i
<
before
.
length
;
i
+
+
)
{
this
.
addEdge
(
name
before
[
i
]
)
;
}
}
}
if
(
after
)
{
if
(
typeof
after
=
=
=
'
string
'
)
{
this
.
addEdge
(
after
name
)
;
}
else
{
for
(
i
=
0
;
i
<
after
.
length
;
i
+
+
)
{
this
.
addEdge
(
after
[
i
]
name
)
;
}
}
}
}
;
}
)
;
enifed
(
'
dag
-
map
.
umd
'
[
'
exports
'
'
dag
-
map
/
platform
'
'
dag
-
map
'
]
function
(
exports
_dagMapPlatform
_dagMap
)
{
'
use
strict
'
;
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
{
define
(
function
(
)
{
return
_dagMap
.
default
;
}
)
;
}
else
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
module
.
exports
=
_dagMap
.
default
;
}
else
if
(
typeof
_dagMapPlatform
.
default
!
=
=
'
undefined
'
)
{
_dagMapPlatform
.
default
[
'
DAG
'
]
=
_dagMap
.
default
;
}
}
)
;
enifed
(
'
dag
-
map
/
platform
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
platform
;
if
(
typeof
self
=
=
=
'
object
'
)
{
platform
=
self
;
}
else
if
(
typeof
global
=
=
=
'
object
'
)
{
platform
=
global
;
}
else
{
throw
new
Error
(
'
no
global
:
self
or
global
found
'
)
;
}
exports
.
default
=
platform
;
}
)
;
enifed
(
"
dom
-
helper
"
[
"
exports
"
"
htmlbars
-
runtime
/
morph
"
"
morph
-
attr
"
"
dom
-
helper
/
build
-
html
-
dom
"
"
dom
-
helper
/
classes
"
"
dom
-
helper
/
prop
"
]
function
(
exports
_htmlbarsRuntimeMorph
_morphAttr
_domHelperBuildHtmlDom
_domHelperClasses
_domHelperProp
)
{
"
use
strict
"
;
var
doc
=
typeof
document
=
=
=
'
undefined
'
?
false
:
document
;
var
deletesBlankTextNodes
=
doc
&
&
(
function
(
document
)
{
var
element
=
document
.
createElement
(
'
div
'
)
;
element
.
appendChild
(
document
.
createTextNode
(
'
'
)
)
;
var
clonedElement
=
element
.
cloneNode
(
true
)
;
return
clonedElement
.
childNodes
.
length
=
=
=
0
;
}
)
(
doc
)
;
var
ignoresCheckedAttribute
=
doc
&
&
(
function
(
document
)
{
var
element
=
document
.
createElement
(
'
input
'
)
;
element
.
setAttribute
(
'
checked
'
'
checked
'
)
;
var
clonedElement
=
element
.
cloneNode
(
false
)
;
return
!
clonedElement
.
checked
;
}
)
(
doc
)
;
var
canRemoveSvgViewBoxAttribute
=
doc
&
&
(
doc
.
createElementNS
?
(
function
(
document
)
{
var
element
=
document
.
createElementNS
(
_domHelperBuildHtmlDom
.
svgNamespace
'
svg
'
)
;
element
.
setAttribute
(
'
viewBox
'
'
0
0
100
100
'
)
;
element
.
removeAttribute
(
'
viewBox
'
)
;
return
!
element
.
getAttribute
(
'
viewBox
'
)
;
}
)
(
doc
)
:
true
)
;
var
canClone
=
doc
&
&
(
function
(
document
)
{
var
element
=
document
.
createElement
(
'
div
'
)
;
element
.
appendChild
(
document
.
createTextNode
(
'
'
)
)
;
element
.
appendChild
(
document
.
createTextNode
(
'
'
)
)
;
var
clonedElement
=
element
.
cloneNode
(
true
)
;
return
clonedElement
.
childNodes
[
0
]
.
nodeValue
=
=
=
'
'
;
}
)
(
doc
)
;
function
interiorNamespace
(
element
)
{
if
(
element
&
&
element
.
namespaceURI
=
=
=
_domHelperBuildHtmlDom
.
svgNamespace
&
&
!
_domHelperBuildHtmlDom
.
svgHTMLIntegrationPoints
[
element
.
tagName
]
)
{
return
_domHelperBuildHtmlDom
.
svgNamespace
;
}
else
{
return
null
;
}
}
var
omittedStartTagChildTest
=
/
<
(
[
\
w
:
]
+
)
/
;
function
detectOmittedStartTag
(
string
contextualElement
)
{
if
(
contextualElement
.
tagName
=
=
=
'
TABLE
'
)
{
var
omittedStartTagChildMatch
=
omittedStartTagChildTest
.
exec
(
string
)
;
if
(
omittedStartTagChildMatch
)
{
var
omittedStartTagChild
=
omittedStartTagChildMatch
[
1
]
;
return
omittedStartTagChild
=
=
=
'
tr
'
|
|
omittedStartTagChild
=
=
=
'
col
'
;
}
}
}
function
buildSVGDOM
(
html
dom
)
{
var
div
=
dom
.
document
.
createElement
(
'
div
'
)
;
div
.
innerHTML
=
'
<
svg
>
'
+
html
+
'
<
/
svg
>
'
;
return
div
.
firstChild
.
childNodes
;
}
var
guid
=
1
;
function
ElementMorph
(
element
dom
namespace
)
{
this
.
element
=
element
;
this
.
dom
=
dom
;
this
.
namespace
=
namespace
;
this
.
guid
=
"
element
"
+
guid
+
+
;
this
.
_state
=
undefined
;
this
.
isDirty
=
true
;
}
ElementMorph
.
prototype
.
getState
=
function
(
)
{
if
(
!
this
.
_state
)
{
this
.
_state
=
{
}
;
}
return
this
.
_state
;
}
;
ElementMorph
.
prototype
.
setState
=
function
(
newState
)
{
return
this
.
_state
=
newState
;
}
;
ElementMorph
.
prototype
.
clear
=
function
(
)
{
}
;
ElementMorph
.
prototype
.
destroy
=
function
(
)
{
this
.
element
=
null
;
this
.
dom
=
null
;
}
;
function
DOMHelper
(
_document
)
{
this
.
document
=
_document
|
|
document
;
if
(
!
this
.
document
)
{
throw
new
Error
(
"
A
document
object
must
be
passed
to
the
DOMHelper
or
available
on
the
global
scope
"
)
;
}
this
.
canClone
=
canClone
;
this
.
namespace
=
null
;
installEnvironmentSpecificMethods
(
this
)
;
}
var
prototype
=
DOMHelper
.
prototype
;
prototype
.
constructor
=
DOMHelper
;
prototype
.
getElementById
=
function
(
id
rootNode
)
{
rootNode
=
rootNode
|
|
this
.
document
;
return
rootNode
.
getElementById
(
id
)
;
}
;
prototype
.
insertBefore
=
function
(
element
childElement
referenceChild
)
{
return
element
.
insertBefore
(
childElement
referenceChild
)
;
}
;
prototype
.
appendChild
=
function
(
element
childElement
)
{
return
element
.
appendChild
(
childElement
)
;
}
;
var
itemAt
;
if
(
typeof
navigator
!
=
=
'
undefined
'
&
&
navigator
.
userAgent
.
indexOf
(
'
PhantomJS
'
)
)
{
itemAt
=
function
(
nodes
index
)
{
return
nodes
[
index
]
;
}
;
}
else
{
itemAt
=
function
(
nodes
index
)
{
return
nodes
.
item
(
index
)
;
}
;
}
prototype
.
childAt
=
function
(
element
indices
)
{
var
child
=
element
;
for
(
var
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
{
child
=
itemAt
(
child
.
childNodes
indices
[
i
]
)
;
}
return
child
;
}
;
prototype
.
childAtIndex
=
function
(
element
index
)
{
var
node
=
element
.
firstChild
;
for
(
var
idx
=
0
;
node
&
&
idx
<
index
;
idx
+
+
)
{
node
=
node
.
nextSibling
;
}
return
node
;
}
;
prototype
.
appendText
=
function
(
element
text
)
{
return
element
.
appendChild
(
this
.
document
.
createTextNode
(
text
)
)
;
}
;
prototype
.
setAttribute
=
function
(
element
name
value
)
{
element
.
setAttribute
(
name
String
(
value
)
)
;
}
;
prototype
.
getAttribute
=
function
(
element
name
)
{
return
element
.
getAttribute
(
name
)
;
}
;
prototype
.
setAttributeNS
=
function
(
element
namespace
name
value
)
{
element
.
setAttributeNS
(
namespace
name
String
(
value
)
)
;
}
;
prototype
.
getAttributeNS
=
function
(
element
namespace
name
)
{
return
element
.
getAttributeNS
(
namespace
name
)
;
}
;
if
(
canRemoveSvgViewBoxAttribute
)
{
prototype
.
removeAttribute
=
function
(
element
name
)
{
element
.
removeAttribute
(
name
)
;
}
;
}
else
{
prototype
.
removeAttribute
=
function
(
element
name
)
{
if
(
element
.
tagName
=
=
=
'
svg
'
&
&
name
=
=
=
'
viewBox
'
)
{
element
.
setAttribute
(
name
null
)
;
}
else
{
element
.
removeAttribute
(
name
)
;
}
}
;
}
prototype
.
setPropertyStrict
=
function
(
element
name
value
)
{
if
(
value
=
=
=
undefined
)
{
value
=
null
;
}
if
(
value
=
=
=
null
&
&
(
name
=
=
=
'
value
'
|
|
name
=
=
=
'
type
'
|
|
name
=
=
=
'
src
'
)
)
{
value
=
'
'
;
}
element
[
name
]
=
value
;
}
;
prototype
.
getPropertyStrict
=
function
(
element
name
)
{
return
element
[
name
]
;
}
;
prototype
.
setProperty
=
function
(
element
name
value
namespace
)
{
if
(
element
.
namespaceURI
=
=
=
_domHelperBuildHtmlDom
.
svgNamespace
)
{
if
(
_domHelperProp
.
isAttrRemovalValue
(
value
)
)
{
element
.
removeAttribute
(
name
)
;
}
else
{
if
(
namespace
)
{
element
.
setAttributeNS
(
namespace
name
value
)
;
}
else
{
element
.
setAttribute
(
name
value
)
;
}
}
}
else
{
var
_normalizeProperty
=
_domHelperProp
.
normalizeProperty
(
element
name
)
;
var
normalized
=
_normalizeProperty
.
normalized
;
var
type
=
_normalizeProperty
.
type
;
if
(
type
=
=
=
'
prop
'
)
{
element
[
normalized
]
=
value
;
}
else
{
if
(
_domHelperProp
.
isAttrRemovalValue
(
value
)
)
{
element
.
removeAttribute
(
name
)
;
}
else
{
if
(
namespace
&
&
element
.
setAttributeNS
)
{
element
.
setAttributeNS
(
namespace
name
value
)
;
}
else
{
element
.
setAttribute
(
name
value
)
;
}
}
}
}
}
;
if
(
doc
&
&
doc
.
createElementNS
)
{
prototype
.
createElement
=
function
(
tagName
contextualElement
)
{
var
namespace
=
this
.
namespace
;
if
(
contextualElement
)
{
if
(
tagName
=
=
=
'
svg
'
)
{
namespace
=
_domHelperBuildHtmlDom
.
svgNamespace
;
}
else
{
namespace
=
interiorNamespace
(
contextualElement
)
;
}
}
if
(
namespace
)
{
return
this
.
document
.
createElementNS
(
namespace
tagName
)
;
}
else
{
return
this
.
document
.
createElement
(
tagName
)
;
}
}
;
prototype
.
setAttributeNS
=
function
(
element
namespace
name
value
)
{
element
.
setAttributeNS
(
namespace
name
String
(
value
)
)
;
}
;
}
else
{
prototype
.
createElement
=
function
(
tagName
)
{
return
this
.
document
.
createElement
(
tagName
)
;
}
;
prototype
.
setAttributeNS
=
function
(
element
namespace
name
value
)
{
element
.
setAttribute
(
name
String
(
value
)
)
;
}
;
}
prototype
.
addClasses
=
_domHelperClasses
.
addClasses
;
prototype
.
removeClasses
=
_domHelperClasses
.
removeClasses
;
prototype
.
setNamespace
=
function
(
ns
)
{
this
.
namespace
=
ns
;
}
;
prototype
.
detectNamespace
=
function
(
element
)
{
this
.
namespace
=
interiorNamespace
(
element
)
;
}
;
prototype
.
createDocumentFragment
=
function
(
)
{
return
this
.
document
.
createDocumentFragment
(
)
;
}
;
prototype
.
createTextNode
=
function
(
text
)
{
return
this
.
document
.
createTextNode
(
text
)
;
}
;
prototype
.
createComment
=
function
(
text
)
{
return
this
.
document
.
createComment
(
text
)
;
}
;
prototype
.
repairClonedNode
=
function
(
element
blankChildTextNodes
isChecked
)
{
if
(
deletesBlankTextNodes
&
&
blankChildTextNodes
.
length
>
0
)
{
for
(
var
i
=
0
len
=
blankChildTextNodes
.
length
;
i
<
len
;
i
+
+
)
{
var
textNode
=
this
.
document
.
createTextNode
(
'
'
)
offset
=
blankChildTextNodes
[
i
]
before
=
this
.
childAtIndex
(
element
offset
)
;
if
(
before
)
{
element
.
insertBefore
(
textNode
before
)
;
}
else
{
element
.
appendChild
(
textNode
)
;
}
}
}
if
(
ignoresCheckedAttribute
&
&
isChecked
)
{
element
.
setAttribute
(
'
checked
'
'
checked
'
)
;
}
}
;
prototype
.
cloneNode
=
function
(
element
deep
)
{
var
clone
=
element
.
cloneNode
(
!
!
deep
)
;
return
clone
;
}
;
prototype
.
AttrMorphClass
=
_morphAttr
.
default
;
prototype
.
createAttrMorph
=
function
(
element
attrName
namespace
)
{
return
this
.
AttrMorphClass
.
create
(
element
attrName
this
namespace
)
;
}
;
prototype
.
ElementMorphClass
=
ElementMorph
;
prototype
.
createElementMorph
=
function
(
element
namespace
)
{
return
new
this
.
ElementMorphClass
(
element
this
namespace
)
;
}
;
prototype
.
createUnsafeAttrMorph
=
function
(
element
attrName
namespace
)
{
var
morph
=
this
.
createAttrMorph
(
element
attrName
namespace
)
;
morph
.
escaped
=
false
;
return
morph
;
}
;
prototype
.
MorphClass
=
_htmlbarsRuntimeMorph
.
default
;
prototype
.
createMorph
=
function
(
parent
start
end
contextualElement
)
{
if
(
contextualElement
&
&
contextualElement
.
nodeType
=
=
=
11
)
{
throw
new
Error
(
"
Cannot
pass
a
fragment
as
the
contextual
element
to
createMorph
"
)
;
}
if
(
!
contextualElement
&
&
parent
&
&
parent
.
nodeType
=
=
=
1
)
{
contextualElement
=
parent
;
}
var
morph
=
new
this
.
MorphClass
(
this
contextualElement
)
;
morph
.
firstNode
=
start
;
morph
.
lastNode
=
end
;
return
morph
;
}
;
prototype
.
createFragmentMorph
=
function
(
contextualElement
)
{
if
(
contextualElement
&
&
contextualElement
.
nodeType
=
=
=
11
)
{
throw
new
Error
(
"
Cannot
pass
a
fragment
as
the
contextual
element
to
createMorph
"
)
;
}
var
fragment
=
this
.
createDocumentFragment
(
)
;
return
_htmlbarsRuntimeMorph
.
default
.
create
(
this
contextualElement
fragment
)
;
}
;
prototype
.
replaceContentWithMorph
=
function
(
element
)
{
var
firstChild
=
element
.
firstChild
;
if
(
!
firstChild
)
{
var
comment
=
this
.
createComment
(
'
'
)
;
this
.
appendChild
(
element
comment
)
;
return
_htmlbarsRuntimeMorph
.
default
.
create
(
this
element
comment
)
;
}
else
{
var
morph
=
_htmlbarsRuntimeMorph
.
default
.
attach
(
this
element
firstChild
element
.
lastChild
)
;
morph
.
clear
(
)
;
return
morph
;
}
}
;
prototype
.
createUnsafeMorph
=
function
(
parent
start
end
contextualElement
)
{
var
morph
=
this
.
createMorph
(
parent
start
end
contextualElement
)
;
morph
.
parseTextAsHTML
=
true
;
return
morph
;
}
;
prototype
.
createMorphAt
=
function
(
parent
startIndex
endIndex
contextualElement
)
{
var
single
=
startIndex
=
=
=
endIndex
;
var
start
=
this
.
childAtIndex
(
parent
startIndex
)
;
var
end
=
single
?
start
:
this
.
childAtIndex
(
parent
endIndex
)
;
return
this
.
createMorph
(
parent
start
end
contextualElement
)
;
}
;
prototype
.
createUnsafeMorphAt
=
function
(
parent
startIndex
endIndex
contextualElement
)
{
var
morph
=
this
.
createMorphAt
(
parent
startIndex
endIndex
contextualElement
)
;
morph
.
parseTextAsHTML
=
true
;
return
morph
;
}
;
prototype
.
insertMorphBefore
=
function
(
element
referenceChild
contextualElement
)
{
var
insertion
=
this
.
document
.
createComment
(
'
'
)
;
element
.
insertBefore
(
insertion
referenceChild
)
;
return
this
.
createMorph
(
element
insertion
insertion
contextualElement
)
;
}
;
prototype
.
appendMorph
=
function
(
element
contextualElement
)
{
var
insertion
=
this
.
document
.
createComment
(
'
'
)
;
element
.
appendChild
(
insertion
)
;
return
this
.
createMorph
(
element
insertion
insertion
contextualElement
)
;
}
;
prototype
.
insertBoundary
=
function
(
fragment
index
)
{
var
child
=
index
=
=
=
null
?
null
:
this
.
childAtIndex
(
fragment
index
)
;
this
.
insertBefore
(
fragment
this
.
createTextNode
(
'
'
)
child
)
;
}
;
prototype
.
setMorphHTML
=
function
(
morph
html
)
{
morph
.
setHTML
(
html
)
;
}
;
prototype
.
parseHTML
=
function
(
html
contextualElement
)
{
var
childNodes
;
if
(
interiorNamespace
(
contextualElement
)
=
=
=
_domHelperBuildHtmlDom
.
svgNamespace
)
{
childNodes
=
buildSVGDOM
(
html
this
)
;
}
else
{
var
nodes
=
_domHelperBuildHtmlDom
.
buildHTMLDOM
(
html
contextualElement
this
)
;
if
(
detectOmittedStartTag
(
html
contextualElement
)
)
{
var
node
=
nodes
[
0
]
;
while
(
node
&
&
node
.
nodeType
!
=
=
1
)
{
node
=
node
.
nextSibling
;
}
childNodes
=
node
.
childNodes
;
}
else
{
childNodes
=
nodes
;
}
}
var
fragment
=
this
.
document
.
createDocumentFragment
(
)
;
if
(
childNodes
&
&
childNodes
.
length
>
0
)
{
var
currentNode
=
childNodes
[
0
]
;
if
(
contextualElement
.
tagName
=
=
=
'
SELECT
'
)
{
currentNode
=
currentNode
.
nextSibling
;
}
while
(
currentNode
)
{
var
tempNode
=
currentNode
;
currentNode
=
currentNode
.
nextSibling
;
fragment
.
appendChild
(
tempNode
)
;
}
}
return
fragment
;
}
;
var
nodeURL
;
var
parsingNode
;
function
installEnvironmentSpecificMethods
(
domHelper
)
{
var
protocol
=
browserProtocolForURL
.
call
(
domHelper
'
foobar
:
baz
'
)
;
if
(
protocol
=
=
=
'
foobar
:
'
)
{
domHelper
.
protocolForURL
=
browserProtocolForURL
;
}
else
if
(
typeof
URL
=
=
=
'
object
'
)
{
nodeURL
=
URL
;
domHelper
.
protocolForURL
=
nodeProtocolForURL
;
}
else
if
(
typeof
module
=
=
=
'
object
'
&
&
typeof
module
.
require
=
=
=
'
function
'
)
{
nodeURL
=
module
.
require
(
'
url
'
)
;
domHelper
.
protocolForURL
=
nodeProtocolForURL
;
}
else
{
throw
new
Error
(
"
DOM
Helper
could
not
find
valid
URL
parsing
mechanism
"
)
;
}
if
(
domHelper
.
document
.
createRawHTMLSection
)
{
domHelper
.
setMorphHTML
=
nodeSetMorphHTML
;
}
}
function
nodeSetMorphHTML
(
morph
html
)
{
var
section
=
this
.
document
.
createRawHTMLSection
(
html
)
;
morph
.
setNode
(
section
)
;
}
function
browserProtocolForURL
(
url
)
{
if
(
!
parsingNode
)
{
parsingNode
=
this
.
document
.
createElement
(
'
a
'
)
;
}
parsingNode
.
href
=
url
;
return
parsingNode
.
protocol
;
}
function
nodeProtocolForURL
(
url
)
{
var
protocol
=
nodeURL
.
parse
(
url
)
.
protocol
;
return
protocol
=
=
=
null
?
'
:
'
:
protocol
;
}
exports
.
default
=
DOMHelper
;
}
)
;
enifed
(
'
dom
-
helper
/
build
-
html
-
dom
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
svgHTMLIntegrationPoints
=
{
foreignObject
:
1
desc
:
1
title
:
1
}
;
exports
.
svgHTMLIntegrationPoints
=
svgHTMLIntegrationPoints
;
var
svgNamespace
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
exports
.
svgNamespace
=
svgNamespace
;
var
doc
=
typeof
document
=
=
=
'
undefined
'
?
false
:
document
;
var
needsIntegrationPointFix
=
doc
&
&
(
function
(
document
)
{
if
(
document
.
createElementNS
=
=
=
undefined
)
{
return
;
}
var
testEl
=
document
.
createElementNS
(
svgNamespace
'
title
'
)
;
testEl
.
innerHTML
=
"
<
div
>
<
/
div
>
"
;
return
testEl
.
childNodes
.
length
=
=
=
0
|
|
testEl
.
childNodes
[
0
]
.
nodeType
!
=
=
1
;
}
)
(
doc
)
;
var
needsShy
=
doc
&
&
(
function
(
document
)
{
var
testEl
=
document
.
createElement
(
'
div
'
)
;
testEl
.
innerHTML
=
"
<
div
>
<
/
div
>
"
;
testEl
.
firstChild
.
innerHTML
=
"
<
script
>
<
\
/
script
>
"
;
return
testEl
.
firstChild
.
innerHTML
=
=
=
'
'
;
}
)
(
doc
)
;
var
movesWhitespace
=
doc
&
&
(
function
(
document
)
{
var
testEl
=
document
.
createElement
(
'
div
'
)
;
testEl
.
innerHTML
=
"
Test
:
<
script
type
=
'
text
/
x
-
placeholder
'
>
<
\
/
script
>
Value
"
;
return
testEl
.
childNodes
[
0
]
.
nodeValue
=
=
=
'
Test
:
'
&
&
testEl
.
childNodes
[
2
]
.
nodeValue
=
=
=
'
Value
'
;
}
)
(
doc
)
;
var
tagNamesRequiringInnerHTMLFix
=
doc
&
&
(
function
(
document
)
{
var
tagNamesRequiringInnerHTMLFix
;
var
tableNeedsInnerHTMLFix
;
var
tableInnerHTMLTestElement
=
document
.
createElement
(
'
table
'
)
;
try
{
tableInnerHTMLTestElement
.
innerHTML
=
'
<
tbody
>
<
/
tbody
>
'
;
}
catch
(
e
)
{
}
finally
{
tableNeedsInnerHTMLFix
=
tableInnerHTMLTestElement
.
childNodes
.
length
=
=
=
0
;
}
if
(
tableNeedsInnerHTMLFix
)
{
tagNamesRequiringInnerHTMLFix
=
{
colgroup
:
[
'
table
'
]
table
:
[
]
tbody
:
[
'
table
'
]
tfoot
:
[
'
table
'
]
thead
:
[
'
table
'
]
tr
:
[
'
table
'
'
tbody
'
]
}
;
}
var
selectInnerHTMLTestElement
=
document
.
createElement
(
'
select
'
)
;
selectInnerHTMLTestElement
.
innerHTML
=
'
<
option
>
<
/
option
>
'
;
if
(
!
selectInnerHTMLTestElement
.
childNodes
[
0
]
)
{
tagNamesRequiringInnerHTMLFix
=
tagNamesRequiringInnerHTMLFix
|
|
{
}
;
tagNamesRequiringInnerHTMLFix
.
select
=
[
]
;
}
return
tagNamesRequiringInnerHTMLFix
;
}
)
(
doc
)
;
function
scriptSafeInnerHTML
(
element
html
)
{
html
=
'
&
shy
;
'
+
html
;
element
.
innerHTML
=
html
;
var
nodes
=
element
.
childNodes
;
var
shyElement
=
nodes
[
0
]
;
while
(
shyElement
.
nodeType
=
=
=
1
&
&
!
shyElement
.
nodeName
)
{
shyElement
=
shyElement
.
firstChild
;
}
if
(
shyElement
.
nodeType
=
=
=
3
&
&
shyElement
.
nodeValue
.
charAt
(
0
)
=
=
=
"
\
u00AD
"
)
{
var
newValue
=
shyElement
.
nodeValue
.
slice
(
1
)
;
if
(
newValue
.
length
)
{
shyElement
.
nodeValue
=
shyElement
.
nodeValue
.
slice
(
1
)
;
}
else
{
shyElement
.
parentNode
.
removeChild
(
shyElement
)
;
}
}
return
nodes
;
}
function
buildDOMWithFix
(
html
contextualElement
)
{
var
tagName
=
contextualElement
.
tagName
;
var
outerHTML
=
contextualElement
.
outerHTML
|
|
new
XMLSerializer
(
)
.
serializeToString
(
contextualElement
)
;
if
(
!
outerHTML
)
{
throw
"
Can
'
t
set
innerHTML
on
"
+
tagName
+
"
in
this
browser
"
;
}
html
=
fixSelect
(
html
contextualElement
)
;
var
wrappingTags
=
tagNamesRequiringInnerHTMLFix
[
tagName
.
toLowerCase
(
)
]
;
var
startTag
=
outerHTML
.
match
(
new
RegExp
(
"
<
"
+
tagName
+
"
(
[
^
>
]
*
)
>
"
'
i
'
)
)
[
0
]
;
var
endTag
=
'
<
/
'
+
tagName
+
'
>
'
;
var
wrappedHTML
=
[
startTag
html
endTag
]
;
var
i
=
wrappingTags
.
length
;
var
wrappedDepth
=
1
+
i
;
while
(
i
-
-
)
{
wrappedHTML
.
unshift
(
'
<
'
+
wrappingTags
[
i
]
+
'
>
'
)
;
wrappedHTML
.
push
(
'
<
/
'
+
wrappingTags
[
i
]
+
'
>
'
)
;
}
var
wrapper
=
document
.
createElement
(
'
div
'
)
;
scriptSafeInnerHTML
(
wrapper
wrappedHTML
.
join
(
'
'
)
)
;
var
element
=
wrapper
;
while
(
wrappedDepth
-
-
)
{
element
=
element
.
firstChild
;
while
(
element
&
&
element
.
nodeType
!
=
=
1
)
{
element
=
element
.
nextSibling
;
}
}
while
(
element
&
&
element
.
tagName
!
=
=
tagName
)
{
element
=
element
.
nextSibling
;
}
return
element
?
element
.
childNodes
:
[
]
;
}
var
buildDOM
;
if
(
needsShy
)
{
buildDOM
=
function
buildDOM
(
html
contextualElement
dom
)
{
html
=
fixSelect
(
html
contextualElement
)
;
contextualElement
=
dom
.
cloneNode
(
contextualElement
false
)
;
scriptSafeInnerHTML
(
contextualElement
html
)
;
return
contextualElement
.
childNodes
;
}
;
}
else
{
buildDOM
=
function
buildDOM
(
html
contextualElement
dom
)
{
html
=
fixSelect
(
html
contextualElement
)
;
contextualElement
=
dom
.
cloneNode
(
contextualElement
false
)
;
contextualElement
.
innerHTML
=
html
;
return
contextualElement
.
childNodes
;
}
;
}
function
fixSelect
(
html
contextualElement
)
{
if
(
contextualElement
.
tagName
=
=
=
'
SELECT
'
)
{
html
=
"
<
option
>
<
/
option
>
"
+
html
;
}
return
html
;
}
var
buildIESafeDOM
;
if
(
tagNamesRequiringInnerHTMLFix
|
|
movesWhitespace
)
{
buildIESafeDOM
=
function
buildIESafeDOM
(
html
contextualElement
dom
)
{
var
spacesBefore
=
[
]
;
var
spacesAfter
=
[
]
;
if
(
typeof
html
=
=
=
'
string
'
)
{
html
=
html
.
replace
(
/
(
\
s
*
)
(
<
script
)
/
g
function
(
match
spaces
tag
)
{
spacesBefore
.
push
(
spaces
)
;
return
tag
;
}
)
;
html
=
html
.
replace
(
/
(
<
\
/
script
>
)
(
\
s
*
)
/
g
function
(
match
tag
spaces
)
{
spacesAfter
.
push
(
spaces
)
;
return
tag
;
}
)
;
}
var
nodes
;
if
(
tagNamesRequiringInnerHTMLFix
[
contextualElement
.
tagName
.
toLowerCase
(
)
]
)
{
nodes
=
buildDOMWithFix
(
html
contextualElement
)
;
}
else
{
nodes
=
buildDOM
(
html
contextualElement
dom
)
;
}
var
i
j
node
nodeScriptNodes
;
var
scriptNodes
=
[
]
;
for
(
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
node
=
nodes
[
i
]
;
if
(
node
.
nodeType
!
=
=
1
)
{
continue
;
}
if
(
node
.
tagName
=
=
=
'
SCRIPT
'
)
{
scriptNodes
.
push
(
node
)
;
}
else
{
nodeScriptNodes
=
node
.
getElementsByTagName
(
'
script
'
)
;
for
(
j
=
0
;
j
<
nodeScriptNodes
.
length
;
j
+
+
)
{
scriptNodes
.
push
(
nodeScriptNodes
[
j
]
)
;
}
}
}
var
scriptNode
textNode
spaceBefore
spaceAfter
;
for
(
i
=
0
;
i
<
scriptNodes
.
length
;
i
+
+
)
{
scriptNode
=
scriptNodes
[
i
]
;
spaceBefore
=
spacesBefore
[
i
]
;
if
(
spaceBefore
&
&
spaceBefore
.
length
>
0
)
{
textNode
=
dom
.
document
.
createTextNode
(
spaceBefore
)
;
scriptNode
.
parentNode
.
insertBefore
(
textNode
scriptNode
)
;
}
spaceAfter
=
spacesAfter
[
i
]
;
if
(
spaceAfter
&
&
spaceAfter
.
length
>
0
)
{
textNode
=
dom
.
document
.
createTextNode
(
spaceAfter
)
;
scriptNode
.
parentNode
.
insertBefore
(
textNode
scriptNode
.
nextSibling
)
;
}
}
return
nodes
;
}
;
}
else
{
buildIESafeDOM
=
buildDOM
;
}
var
buildHTMLDOM
;
if
(
needsIntegrationPointFix
)
{
exports
.
buildHTMLDOM
=
buildHTMLDOM
=
function
buildHTMLDOM
(
html
contextualElement
dom
)
{
if
(
svgHTMLIntegrationPoints
[
contextualElement
.
tagName
]
)
{
return
buildIESafeDOM
(
html
document
.
createElement
(
'
div
'
)
dom
)
;
}
else
{
return
buildIESafeDOM
(
html
contextualElement
dom
)
;
}
}
;
}
else
{
exports
.
buildHTMLDOM
=
buildHTMLDOM
=
buildIESafeDOM
;
}
exports
.
buildHTMLDOM
=
buildHTMLDOM
;
}
)
;
enifed
(
'
dom
-
helper
/
classes
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
doc
=
typeof
document
=
=
=
'
undefined
'
?
false
:
document
;
var
canClassList
=
doc
&
&
(
function
(
)
{
var
d
=
document
.
createElement
(
'
div
'
)
;
if
(
!
d
.
classList
)
{
return
false
;
}
d
.
classList
.
add
(
'
boo
'
)
;
d
.
classList
.
add
(
'
boo
'
'
baz
'
)
;
return
d
.
className
=
=
=
'
boo
baz
'
;
}
)
(
)
;
function
buildClassList
(
element
)
{
var
classString
=
element
.
getAttribute
(
'
class
'
)
|
|
'
'
;
return
classString
!
=
=
'
'
&
&
classString
!
=
=
'
'
?
classString
.
split
(
'
'
)
:
[
]
;
}
function
intersect
(
containingArray
valuesArray
)
{
var
containingIndex
=
0
;
var
containingLength
=
containingArray
.
length
;
var
valuesIndex
=
0
;
var
valuesLength
=
valuesArray
.
length
;
var
intersection
=
new
Array
(
valuesLength
)
;
for
(
;
containingIndex
<
containingLength
;
containingIndex
+
+
)
{
valuesIndex
=
0
;
for
(
;
valuesIndex
<
valuesLength
;
valuesIndex
+
+
)
{
if
(
valuesArray
[
valuesIndex
]
=
=
=
containingArray
[
containingIndex
]
)
{
intersection
[
valuesIndex
]
=
containingIndex
;
break
;
}
}
}
return
intersection
;
}
function
addClassesViaAttribute
(
element
classNames
)
{
var
existingClasses
=
buildClassList
(
element
)
;
var
indexes
=
intersect
(
existingClasses
classNames
)
;
var
didChange
=
false
;
for
(
var
i
=
0
l
=
classNames
.
length
;
i
<
l
;
i
+
+
)
{
if
(
indexes
[
i
]
=
=
=
undefined
)
{
didChange
=
true
;
existingClasses
.
push
(
classNames
[
i
]
)
;
}
}
if
(
didChange
)
{
element
.
setAttribute
(
'
class
'
existingClasses
.
length
>
0
?
existingClasses
.
join
(
'
'
)
:
'
'
)
;
}
}
function
removeClassesViaAttribute
(
element
classNames
)
{
var
existingClasses
=
buildClassList
(
element
)
;
var
indexes
=
intersect
(
classNames
existingClasses
)
;
var
didChange
=
false
;
var
newClasses
=
[
]
;
for
(
var
i
=
0
l
=
existingClasses
.
length
;
i
<
l
;
i
+
+
)
{
if
(
indexes
[
i
]
=
=
=
undefined
)
{
newClasses
.
push
(
existingClasses
[
i
]
)
;
}
else
{
didChange
=
true
;
}
}
if
(
didChange
)
{
element
.
setAttribute
(
'
class
'
newClasses
.
length
>
0
?
newClasses
.
join
(
'
'
)
:
'
'
)
;
}
}
var
addClasses
removeClasses
;
if
(
canClassList
)
{
exports
.
addClasses
=
addClasses
=
function
addClasses
(
element
classNames
)
{
if
(
element
.
classList
)
{
if
(
classNames
.
length
=
=
=
1
)
{
element
.
classList
.
add
(
classNames
[
0
]
)
;
}
else
if
(
classNames
.
length
=
=
=
2
)
{
element
.
classList
.
add
(
classNames
[
0
]
classNames
[
1
]
)
;
}
else
{
element
.
classList
.
add
.
apply
(
element
.
classList
classNames
)
;
}
}
else
{
addClassesViaAttribute
(
element
classNames
)
;
}
}
;
exports
.
removeClasses
=
removeClasses
=
function
removeClasses
(
element
classNames
)
{
if
(
element
.
classList
)
{
if
(
classNames
.
length
=
=
=
1
)
{
element
.
classList
.
remove
(
classNames
[
0
]
)
;
}
else
if
(
classNames
.
length
=
=
=
2
)
{
element
.
classList
.
remove
(
classNames
[
0
]
classNames
[
1
]
)
;
}
else
{
element
.
classList
.
remove
.
apply
(
element
.
classList
classNames
)
;
}
}
else
{
removeClassesViaAttribute
(
element
classNames
)
;
}
}
;
}
else
{
exports
.
addClasses
=
addClasses
=
addClassesViaAttribute
;
exports
.
removeClasses
=
removeClasses
=
removeClassesViaAttribute
;
}
exports
.
addClasses
=
addClasses
;
exports
.
removeClasses
=
removeClasses
;
}
)
;
enifed
(
'
dom
-
helper
/
prop
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
isAttrRemovalValue
=
isAttrRemovalValue
;
exports
.
normalizeProperty
=
normalizeProperty
;
function
isAttrRemovalValue
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
;
}
function
normalizeProperty
(
element
slotName
)
{
var
type
normalized
;
if
(
slotName
in
element
)
{
normalized
=
slotName
;
type
=
'
prop
'
;
}
else
{
var
lower
=
slotName
.
toLowerCase
(
)
;
if
(
lower
in
element
)
{
type
=
'
prop
'
;
normalized
=
lower
;
}
else
{
type
=
'
attr
'
;
normalized
=
slotName
;
}
}
if
(
type
=
=
=
'
prop
'
&
&
(
normalized
.
toLowerCase
(
)
=
=
=
'
style
'
|
|
preferAttr
(
element
.
tagName
normalized
)
)
)
{
type
=
'
attr
'
;
}
return
{
normalized
:
normalized
type
:
type
}
;
}
var
ATTR_OVERRIDES
=
{
BUTTON
:
{
type
:
true
form
:
true
}
INPUT
:
{
list
:
true
type
:
true
form
:
true
autocorrect
:
true
}
SELECT
:
{
form
:
true
}
OPTION
:
{
form
:
true
}
TEXTAREA
:
{
form
:
true
}
LABEL
:
{
form
:
true
}
FIELDSET
:
{
form
:
true
}
LEGEND
:
{
form
:
true
}
OBJECT
:
{
form
:
true
}
}
;
function
preferAttr
(
tagName
propName
)
{
var
tag
=
ATTR_OVERRIDES
[
tagName
.
toUpperCase
(
)
]
;
return
tag
&
&
tag
[
propName
.
toLowerCase
(
)
]
|
|
false
;
}
}
)
;
enifed
(
'
ember
-
application
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
features
'
'
ember
-
runtime
/
system
/
lazy_load
'
'
ember
-
application
/
system
/
resolver
'
'
ember
-
application
/
system
/
application
'
'
ember
-
application
/
system
/
application
-
instance
'
'
ember
-
application
/
system
/
engine
'
'
ember
-
application
/
system
/
engine
-
instance
'
]
function
(
exports
_emberMetalCore
_emberMetalFeatures
_emberRuntimeSystemLazy_load
_emberApplicationSystemResolver
_emberApplicationSystemApplication
_emberApplicationSystemApplicationInstance
_emberApplicationSystemEngine
_emberApplicationSystemEngineInstance
)
{
'
use
strict
'
;
_emberMetalCore
.
default
.
Application
=
_emberApplicationSystemApplication
.
default
;
_emberMetalCore
.
default
.
Resolver
=
_emberApplicationSystemResolver
.
Resolver
;
_emberMetalCore
.
default
.
DefaultResolver
=
_emberApplicationSystemResolver
.
default
;
_emberRuntimeSystemLazy_load
.
runLoadHooks
(
'
Ember
.
Application
'
_emberApplicationSystemApplication
.
default
)
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
application
-
instance
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
symbol
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
computed
'
'
ember
-
runtime
/
mixins
/
registry_proxy
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
environment
'
'
ember
-
runtime
/
ext
/
rsvp
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
application
/
system
/
engine
-
instance
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalSymbol
_emberMetalRun_loop
_emberMetalComputed
_emberRuntimeMixinsRegistry_proxy
_emberMetalAssign
_emberMetalEnvironment
_emberRuntimeExtRsvp
_emberViewsSystemJquery
_emberApplicationSystemEngineInstance
)
{
'
use
strict
'
;
var
INTERNAL_BOOT_OPTIONS
=
_emberMetalSymbol
.
default
(
'
INTERNAL_BOOT_OPTIONS
'
)
;
exports
.
INTERNAL_BOOT_OPTIONS
=
INTERNAL_BOOT_OPTIONS
;
var
BootOptions
=
undefined
;
var
ApplicationInstance
=
_emberApplicationSystemEngineInstance
.
default
.
extend
(
{
application
:
null
customEvents
:
null
rootElement
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
register
(
'
-
application
-
instance
:
main
'
this
{
instantiate
:
false
}
)
;
this
.
_booted
=
false
;
}
boot
:
function
(
)
{
var
_this
=
this
;
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
if
(
this
.
_bootPromise
)
{
return
this
.
_bootPromise
;
}
this
.
_bootPromise
=
new
_emberRuntimeExtRsvp
.
default
.
Promise
(
function
(
resolve
)
{
return
resolve
(
_this
.
_bootSync
(
options
)
)
;
}
)
;
return
this
.
_bootPromise
;
}
_bootSync
:
function
(
options
)
{
if
(
this
.
_booted
)
{
return
this
;
}
options
=
new
BootOptions
(
options
)
;
var
registry
=
this
.
__registry__
;
registry
.
register
(
'
-
environment
:
main
'
options
.
toEnvironment
(
)
{
instantiate
:
false
}
)
;
registry
.
injection
(
'
view
'
'
_environment
'
'
-
environment
:
main
'
)
;
registry
.
injection
(
'
route
'
'
_environment
'
'
-
environment
:
main
'
)
;
registry
.
register
(
'
service
:
-
document
'
options
.
document
{
instantiate
:
false
}
)
;
if
(
options
.
isInteractive
)
{
registry
.
injection
(
'
view
'
'
renderer
'
'
renderer
:
-
dom
'
)
;
registry
.
injection
(
'
component
'
'
renderer
'
'
renderer
:
-
dom
'
)
;
}
else
{
registry
.
injection
(
'
view
'
'
renderer
'
'
renderer
:
-
inert
'
)
;
registry
.
injection
(
'
component
'
'
renderer
'
'
renderer
:
-
inert
'
)
;
}
if
(
options
.
rootElement
)
{
this
.
rootElement
=
options
.
rootElement
;
}
else
{
this
.
rootElement
=
this
.
application
.
rootElement
;
}
if
(
options
.
location
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
_emberMetalProperty_set
.
set
(
router
'
location
'
options
.
location
)
;
}
this
.
application
.
runInstanceInitializers
(
this
)
;
if
(
options
.
isInteractive
)
{
this
.
setupEventDispatcher
(
)
;
}
this
.
_booted
=
true
;
return
this
;
}
router
:
_emberMetalComputed
.
computed
(
function
(
)
{
return
this
.
lookup
(
'
router
:
main
'
)
;
}
)
.
readOnly
(
)
didCreateRootView
:
function
(
view
)
{
view
.
appendTo
(
this
.
rootElement
)
;
}
startRouting
:
function
(
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
router
.
startRouting
(
)
;
this
.
_didSetupRouter
=
true
;
}
setupRouter
:
function
(
)
{
if
(
this
.
_didSetupRouter
)
{
return
;
}
this
.
_didSetupRouter
=
true
;
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
router
.
setupRouter
(
)
;
}
handleURL
:
function
(
url
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
this
.
setupRouter
(
)
;
return
router
.
handleURL
(
url
)
;
}
setupEventDispatcher
:
function
(
)
{
var
dispatcher
=
this
.
lookup
(
'
event_dispatcher
:
main
'
)
;
var
applicationCustomEvents
=
_emberMetalProperty_get
.
get
(
this
.
application
'
customEvents
'
)
;
var
instanceCustomEvents
=
_emberMetalProperty_get
.
get
(
this
'
customEvents
'
)
;
var
customEvents
=
_emberMetalAssign
.
default
(
{
}
applicationCustomEvents
instanceCustomEvents
)
;
dispatcher
.
setup
(
customEvents
this
.
rootElement
)
;
return
dispatcher
;
}
getURL
:
function
(
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
return
_emberMetalProperty_get
.
get
(
router
'
url
'
)
;
}
visit
:
function
(
url
)
{
var
_this2
=
this
;
this
.
setupRouter
(
)
;
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
var
handleResolve
=
function
(
)
{
return
new
_emberRuntimeExtRsvp
.
default
.
Promise
(
function
(
resolve
)
{
_emberMetalRun_loop
.
default
.
next
(
null
resolve
_this2
)
;
}
)
;
}
;
var
handleReject
=
function
(
error
)
{
if
(
error
.
error
)
{
throw
error
.
error
;
}
else
if
(
error
.
name
=
=
=
'
TransitionAborted
'
&
&
router
.
router
.
activeTransition
)
{
return
router
.
router
.
activeTransition
.
then
(
handleResolve
handleReject
)
;
}
else
if
(
error
.
name
=
=
=
'
TransitionAborted
'
)
{
throw
new
Error
(
error
.
message
)
;
}
else
{
throw
error
;
}
}
;
var
location
=
_emberMetalProperty_get
.
get
(
router
'
location
'
)
;
location
.
setURL
(
url
)
;
return
router
.
handleURL
(
location
.
getURL
(
)
)
.
then
(
handleResolve
handleReject
)
;
}
}
)
;
BootOptions
=
function
BootOptions
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
this
.
jQuery
=
_emberViewsSystemJquery
.
default
;
this
.
isInteractive
=
_emberMetalEnvironment
.
default
.
hasDOM
;
if
(
options
.
isBrowser
!
=
=
undefined
)
{
this
.
isBrowser
=
!
!
options
.
isBrowser
;
}
else
{
this
.
isBrowser
=
_emberMetalEnvironment
.
default
.
hasDOM
;
}
if
(
!
this
.
isBrowser
)
{
this
.
jQuery
=
null
;
this
.
isInteractive
=
false
;
this
.
location
=
'
none
'
;
}
if
(
options
.
shouldRender
!
=
=
undefined
)
{
this
.
shouldRender
=
!
!
options
.
shouldRender
;
}
else
{
this
.
shouldRender
=
true
;
}
if
(
!
this
.
shouldRender
)
{
this
.
jQuery
=
null
;
this
.
isInteractive
=
false
;
}
if
(
options
.
document
)
{
this
.
document
=
options
.
document
;
}
else
{
this
.
document
=
typeof
document
!
=
=
'
undefined
'
?
document
:
null
;
}
if
(
options
.
rootElement
)
{
this
.
rootElement
=
options
.
rootElement
;
}
if
(
options
.
location
!
=
=
undefined
)
{
this
.
location
=
options
.
location
;
}
if
(
options
.
jQuery
!
=
=
undefined
)
{
this
.
jQuery
=
options
.
jQuery
;
}
if
(
options
.
isInteractive
!
=
=
undefined
)
{
this
.
isInteractive
=
!
!
options
.
isInteractive
;
}
}
;
BootOptions
.
prototype
.
toEnvironment
=
function
(
)
{
var
env
=
_emberMetalAssign
.
default
(
{
}
_emberMetalEnvironment
.
default
)
;
env
.
hasDOM
=
this
.
isBrowser
;
env
.
options
=
this
;
return
env
;
}
;
Object
.
defineProperty
(
ApplicationInstance
.
prototype
'
container
'
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
var
instance
=
this
;
return
{
lookup
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
Using
ApplicationInstance
.
container
.
lookup
is
deprecated
.
Please
use
ApplicationInstance
.
lookup
instead
.
'
false
{
id
:
'
ember
-
application
.
app
-
instance
-
container
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
applicationinstance
-
container
'
}
)
;
return
instance
.
lookup
.
apply
(
instance
arguments
)
;
}
}
;
}
}
)
;
Object
.
defineProperty
(
ApplicationInstance
.
prototype
'
registry
'
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
return
_emberRuntimeMixinsRegistry_proxy
.
buildFakeRegistryWithDeprecations
(
this
'
ApplicationInstance
'
)
;
}
}
)
;
exports
.
default
=
ApplicationInstance
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
application
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
runtime
/
system
/
lazy_load
'
'
ember
-
metal
/
run_loop
'
'
ember
-
runtime
/
controllers
/
controller
'
'
ember
-
htmlbars
/
system
/
dom
-
helper
'
'
ember
-
metal
-
views
'
'
ember
-
htmlbars
/
templates
/
top
-
level
-
view
'
'
ember
-
routing
-
views
/
views
/
outlet
'
'
ember
-
views
/
views
/
view
'
'
ember
-
views
/
system
/
event_dispatcher
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
routing
/
system
/
route
'
'
ember
-
routing
/
system
/
router
'
'
ember
-
routing
/
location
/
hash_location
'
'
ember
-
routing
/
location
/
history_location
'
'
ember
-
routing
/
location
/
auto_location
'
'
ember
-
routing
/
location
/
none_location
'
'
ember
-
routing
/
system
/
cache
'
'
ember
-
application
/
system
/
application
-
instance
'
'
ember
-
views
/
views
/
text_field
'
'
ember
-
views
/
views
/
text_area
'
'
ember
-
views
/
views
/
checkbox
'
'
ember
-
routing
-
views
/
components
/
link
-
to
'
'
ember
-
routing
/
services
/
routing
'
'
ember
-
extension
-
support
/
container_debug_adapter
'
'
ember
-
runtime
/
mixins
/
registry_proxy
'
'
container
/
registry
'
'
ember
-
metal
/
environment
'
'
ember
-
runtime
/
ext
/
rsvp
'
'
ember
-
application
/
system
/
engine
'
'
require
'
]
function
(
exports
_emberMetal
_emberMetalDebug
_emberMetalProperty_get
_emberRuntimeSystemLazy_load
_emberMetalRun_loop
_emberRuntimeControllersController
_emberHtmlbarsSystemDomHelper
_emberMetalViews
_emberHtmlbarsTemplatesTopLevelView
_emberRoutingViewsViewsOutlet
_emberViewsViewsView
_emberViewsSystemEvent_dispatcher
_emberViewsSystemJquery
_emberRoutingSystemRoute
_emberRoutingSystemRouter
_emberRoutingLocationHash_location
_emberRoutingLocationHistory_location
_emberRoutingLocationAuto_location
_emberRoutingLocationNone_location
_emberRoutingSystemCache
_emberApplicationSystemApplicationInstance
_emberViewsViewsText_field
_emberViewsViewsText_area
_emberViewsViewsCheckbox
_emberRoutingViewsComponentsLinkTo
_emberRoutingServicesRouting
_emberExtensionSupportContainer_debug_adapter
_emberRuntimeMixinsRegistry_proxy
_containerRegistry
_emberMetalEnvironment
_emberRuntimeExtRsvp
_emberApplicationSystemEngine
_require2
)
{
'
use
strict
'
;
exports
.
_resetLegacyAddonWarnings
=
_resetLegacyAddonWarnings
;
var
_templateObject
=
_taggedTemplateLiteralLoose
(
[
'
-
bucket
-
cache
:
main
'
]
[
'
-
bucket
-
cache
:
main
'
]
)
_templateObject2
=
_taggedTemplateLiteralLoose
(
[
'
template
:
components
/
-
default
'
]
[
'
template
:
components
/
-
default
'
]
)
;
function
_taggedTemplateLiteralLoose
(
strings
raw
)
{
strings
.
raw
=
raw
;
return
strings
;
}
var
librariesRegistered
=
false
;
var
warnedAboutLegacyViewAddon
=
false
;
var
warnedAboutLegacyControllerAddon
=
false
;
function
_resetLegacyAddonWarnings
(
)
{
warnedAboutLegacyViewAddon
=
false
;
warnedAboutLegacyControllerAddon
=
false
;
}
var
Application
=
_emberApplicationSystemEngine
.
default
.
extend
(
{
_suppressDeferredDeprecation
:
true
rootElement
:
'
body
'
eventDispatcher
:
null
customEvents
:
null
autoboot
:
true
_globalsMode
:
true
init
:
function
(
options
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
!
this
.
)
{
this
.
=
_emberViewsSystemJquery
.
default
;
}
registerLibraries
(
)
;
logLibraryVersions
(
)
;
this
.
_readinessDeferrals
=
1
;
this
.
_booted
=
false
;
this
.
autoboot
=
this
.
_globalsMode
=
!
!
this
.
autoboot
;
if
(
this
.
_globalsMode
)
{
this
.
_prepareForGlobalsMode
(
)
;
}
if
(
this
.
autoboot
)
{
this
.
waitForDOMReady
(
)
;
}
}
buildInstance
:
function
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
options
.
base
=
this
;
options
.
application
=
this
;
return
_emberApplicationSystemApplicationInstance
.
default
.
create
(
options
)
;
}
_prepareForGlobalsMode
:
function
(
)
{
this
.
Router
=
(
this
.
Router
|
|
_emberRoutingSystemRouter
.
default
)
.
extend
(
)
;
this
.
_buildDeprecatedInstance
(
)
;
}
_buildDeprecatedInstance
:
function
(
)
{
var
instance
=
this
.
buildInstance
(
)
;
this
.
__deprecatedInstance__
=
instance
;
this
.
__container__
=
instance
.
__container__
;
_emberViewsViewsView
.
default
.
views
=
instance
.
lookup
(
'
-
view
-
registry
:
main
'
)
;
}
waitForDOMReady
:
function
(
)
{
if
(
!
this
.
|
|
this
.
.
isReady
)
{
_emberMetalRun_loop
.
default
.
schedule
(
'
actions
'
this
'
domReady
'
)
;
}
else
{
this
.
(
)
.
ready
(
_emberMetalRun_loop
.
default
.
bind
(
this
'
domReady
'
)
)
;
}
}
domReady
:
function
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
this
.
_bootSync
(
)
;
}
deferReadiness
:
function
(
)
{
_emberMetalDebug
.
assert
(
'
You
must
call
deferReadiness
on
an
instance
of
Ember
.
Application
'
this
instanceof
Application
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
defer
readiness
since
the
ready
(
)
hook
has
already
been
called
.
'
this
.
_readinessDeferrals
>
0
)
;
this
.
_readinessDeferrals
+
+
;
}
advanceReadiness
:
function
(
)
{
_emberMetalDebug
.
assert
(
'
You
must
call
advanceReadiness
on
an
instance
of
Ember
.
Application
'
this
instanceof
Application
)
;
this
.
_readinessDeferrals
-
-
;
if
(
this
.
_readinessDeferrals
=
=
=
0
)
{
_emberMetalRun_loop
.
default
.
once
(
this
this
.
didBecomeReady
)
;
}
}
boot
:
function
(
)
{
if
(
this
.
_bootPromise
)
{
return
this
.
_bootPromise
;
}
try
{
this
.
_bootSync
(
)
;
}
catch
(
_
)
{
}
return
this
.
_bootPromise
;
}
_bootSync
:
function
(
)
{
if
(
this
.
_booted
)
{
return
;
}
if
(
_emberMetal
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
&
&
!
warnedAboutLegacyViewAddon
)
{
_emberMetalDebug
.
deprecate
(
'
Support
for
the
ember
-
legacy
-
views
addon
will
end
soon
please
remove
it
from
your
application
.
'
false
{
id
:
'
ember
-
legacy
-
views
'
until
:
'
2
.
6
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v1
.
x
/
#
toc_ember
-
view
'
}
)
;
warnedAboutLegacyViewAddon
=
true
;
}
if
(
_emberMetal
.
default
.
ENV
.
_ENABLE_LEGACY_CONTROLLER_SUPPORT
&
&
!
warnedAboutLegacyControllerAddon
)
{
_emberMetalDebug
.
warn
(
'
Support
for
the
ember
-
legacy
-
controllers
has
been
removed
please
remove
it
from
your
application
.
'
false
{
id
:
'
ember
-
legacy
-
controllers
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v1
.
x
/
#
toc_objectcontroller
'
}
)
;
warnedAboutLegacyControllerAddon
=
true
;
}
var
defer
=
this
.
_bootResolver
=
new
_emberRuntimeExtRsvp
.
default
.
defer
(
)
;
this
.
_bootPromise
=
defer
.
promise
;
try
{
this
.
runInitializers
(
)
;
_emberRuntimeSystemLazy_load
.
runLoadHooks
(
'
application
'
this
)
;
this
.
advanceReadiness
(
)
;
}
catch
(
error
)
{
defer
.
reject
(
error
)
;
throw
error
;
}
}
reset
:
function
(
)
{
_emberMetalDebug
.
assert
(
'
Calling
reset
(
)
on
instances
of
Ember
.
Application
is
not
\
n
supported
when
globals
mode
is
disabled
;
call
visit
(
)
to
\
n
create
new
Ember
.
ApplicationInstance
s
and
dispose
them
\
n
via
their
destroy
(
)
method
instead
.
'
this
.
_globalsMode
&
&
this
.
autoboot
)
;
var
instance
=
this
.
__deprecatedInstance__
;
this
.
_readinessDeferrals
=
1
;
this
.
_bootPromise
=
null
;
this
.
_bootResolver
=
null
;
this
.
_booted
=
false
;
function
handleReset
(
)
{
_emberMetalRun_loop
.
default
(
instance
'
destroy
'
)
;
this
.
_buildDeprecatedInstance
(
)
;
_emberMetalRun_loop
.
default
.
schedule
(
'
actions
'
this
'
_bootSync
'
)
;
}
_emberMetalRun_loop
.
default
.
join
(
this
handleReset
)
;
}
didBecomeReady
:
function
(
)
{
try
{
if
(
!
_emberMetal
.
default
.
testing
)
{
_emberMetal
.
default
.
Namespace
.
processAll
(
)
;
_emberMetal
.
default
.
BOOTED
=
true
;
}
if
(
this
.
autoboot
)
{
var
instance
=
undefined
;
if
(
this
.
_globalsMode
)
{
instance
=
this
.
__deprecatedInstance__
;
}
else
{
instance
=
this
.
buildInstance
(
)
;
}
instance
.
_bootSync
(
)
;
this
.
ready
(
)
;
instance
.
startRouting
(
)
;
}
this
.
_bootResolver
.
resolve
(
this
)
;
this
.
_booted
=
true
;
}
catch
(
error
)
{
this
.
_bootResolver
.
reject
(
error
)
;
throw
error
;
}
}
ready
:
function
(
)
{
return
this
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
_emberMetal
.
default
.
BOOTED
=
false
;
this
.
_booted
=
false
;
this
.
_bootPromise
=
null
;
this
.
_bootResolver
=
null
;
if
(
_emberRuntimeSystemLazy_load
.
_loaded
.
application
=
=
=
this
)
{
_emberRuntimeSystemLazy_load
.
_loaded
.
application
=
undefined
;
}
if
(
this
.
_globalsMode
&
&
this
.
__deprecatedInstance__
)
{
this
.
__deprecatedInstance__
.
destroy
(
)
;
}
}
visit
:
function
(
url
options
)
{
var
_this
=
this
;
return
this
.
boot
(
)
.
then
(
function
(
)
{
return
_this
.
buildInstance
(
)
.
boot
(
options
)
.
then
(
function
(
instance
)
{
return
instance
.
visit
(
url
)
;
}
)
;
}
)
;
}
}
)
;
Object
.
defineProperty
(
Application
.
prototype
'
registry
'
{
configurable
:
true
enumerable
:
false
get
:
function
(
)
{
return
_emberRuntimeMixinsRegistry_proxy
.
buildFakeRegistryWithDeprecations
(
this
'
Application
'
)
;
}
}
)
;
Application
.
reopenClass
(
{
buildRegistry
:
function
(
application
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
registry
=
this
.
_super
.
apply
(
this
arguments
)
;
registry
.
register
(
'
application
:
main
'
application
{
instantiate
:
false
}
)
;
if
(
options
[
_emberApplicationSystemEngine
.
GLIMMER
]
)
{
glimmerSetupRegistry
(
registry
)
;
}
else
{
htmlbarsSetupRegistry
(
registry
)
;
}
return
registry
;
}
}
)
;
function
commonSetupRegistry
(
registry
)
{
registry
.
optionsForType
(
'
component
'
{
singleton
:
false
}
)
;
registry
.
optionsForType
(
'
view
'
{
singleton
:
false
}
)
;
registry
.
injection
(
'
renderer
'
'
dom
'
'
service
:
-
dom
-
helper
'
)
;
registry
.
register
(
'
controller
:
basic
'
_emberRuntimeControllersController
.
default
{
instantiate
:
false
}
)
;
registry
.
injection
(
'
service
:
-
dom
-
helper
'
'
document
'
'
service
:
-
document
'
)
;
registry
.
register
(
'
-
view
-
registry
:
main
'
{
create
:
function
(
)
{
return
{
}
;
}
}
)
;
registry
.
injection
(
'
view
'
'
_viewRegistry
'
'
-
view
-
registry
:
main
'
)
;
registry
.
injection
(
'
route
'
'
_topLevelViewTemplate
'
'
template
:
-
outlet
'
)
;
registry
.
register
(
'
route
:
basic
'
_emberRoutingSystemRoute
.
default
)
;
registry
.
register
(
'
event_dispatcher
:
main
'
_emberViewsSystemEvent_dispatcher
.
default
)
;
registry
.
injection
(
'
router
:
main
'
'
namespace
'
'
application
:
main
'
)
;
registry
.
injection
(
'
view
:
-
outlet
'
'
namespace
'
'
application
:
main
'
)
;
registry
.
register
(
'
location
:
auto
'
_emberRoutingLocationAuto_location
.
default
)
;
registry
.
register
(
'
location
:
hash
'
_emberRoutingLocationHash_location
.
default
)
;
registry
.
register
(
'
location
:
history
'
_emberRoutingLocationHistory_location
.
default
)
;
registry
.
register
(
'
location
:
none
'
_emberRoutingLocationNone_location
.
default
)
;
registry
.
injection
(
'
controller
'
'
target
'
'
router
:
main
'
)
;
registry
.
injection
(
'
controller
'
'
namespace
'
'
application
:
main
'
)
;
registry
.
register
(
_containerRegistry
.
privatize
(
_templateObject
)
_emberRoutingSystemCache
.
default
)
;
registry
.
injection
(
'
router
'
'
_bucketCache
'
_containerRegistry
.
privatize
(
_templateObject
)
)
;
registry
.
injection
(
'
route
'
'
_bucketCache
'
_containerRegistry
.
privatize
(
_templateObject
)
)
;
registry
.
injection
(
'
controller
'
'
_bucketCache
'
_containerRegistry
.
privatize
(
_templateObject
)
)
;
registry
.
injection
(
'
route
'
'
router
'
'
router
:
main
'
)
;
registry
.
register
(
'
component
:
-
text
-
field
'
_emberViewsViewsText_field
.
default
)
;
registry
.
register
(
'
component
:
-
text
-
area
'
_emberViewsViewsText_area
.
default
)
;
registry
.
register
(
'
component
:
-
checkbox
'
_emberViewsViewsCheckbox
.
default
)
;
registry
.
register
(
'
component
:
link
-
to
'
_emberRoutingViewsComponentsLinkTo
.
default
)
;
registry
.
register
(
'
service
:
-
routing
'
_emberRoutingServicesRouting
.
default
)
;
registry
.
injection
(
'
service
:
-
routing
'
'
router
'
'
router
:
main
'
)
;
registry
.
register
(
'
resolver
-
for
-
debugging
:
main
'
registry
.
resolver
{
instantiate
:
false
}
)
;
registry
.
injection
(
'
container
-
debug
-
adapter
:
main
'
'
resolver
'
'
resolver
-
for
-
debugging
:
main
'
)
;
registry
.
injection
(
'
data
-
adapter
:
main
'
'
containerDebugAdapter
'
'
container
-
debug
-
adapter
:
main
'
)
;
registry
.
register
(
'
container
-
debug
-
adapter
:
main
'
_emberExtensionSupportContainer_debug_adapter
.
default
)
;
}
function
glimmerSetupRegistry
(
registry
)
{
commonSetupRegistry
(
registry
)
;
var
Environment
=
_require2
.
default
(
'
ember
-
glimmer
/
environment
'
)
.
default
;
registry
.
register
(
'
service
:
-
glimmer
-
environment
'
Environment
)
;
registry
.
injection
(
'
service
:
-
glimmer
-
environment
'
'
dom
'
'
service
:
-
dom
-
helper
'
)
;
registry
.
injection
(
'
renderer
'
'
env
'
'
service
:
-
glimmer
-
environment
'
)
;
var
OutletView
=
_require2
.
default
(
'
ember
-
glimmer
/
ember
-
routing
-
view
'
)
.
OutletView
;
registry
.
register
(
'
view
:
-
outlet
'
OutletView
)
;
var
_require
=
_require2
.
default
(
'
ember
-
glimmer
/
ember
-
metal
-
views
'
)
;
var
InteractiveRenderer
=
_require
.
InteractiveRenderer
;
var
InertRenderer
=
_require
.
InertRenderer
;
registry
.
register
(
'
renderer
:
-
dom
'
InteractiveRenderer
)
;
registry
.
register
(
'
renderer
:
-
inert
'
InertRenderer
)
;
var
DOMHelper
=
_require2
.
default
(
'
ember
-
glimmer
/
dom
'
)
.
default
;
registry
.
register
(
'
service
:
-
dom
-
helper
'
{
create
:
function
(
_ref
)
{
var
document
=
_ref
.
document
;
return
new
DOMHelper
(
document
)
;
}
}
)
;
var
glimmerOutletTemplate
=
_require2
.
default
(
'
ember
-
glimmer
/
templates
/
outlet
'
)
.
default
;
var
glimmerComponentTemplate
=
_require2
.
default
(
'
ember
-
glimmer
/
templates
/
component
'
)
.
default
;
registry
.
register
(
_containerRegistry
.
privatize
(
_templateObject2
)
glimmerComponentTemplate
)
;
registry
.
register
(
'
template
:
-
outlet
'
glimmerOutletTemplate
)
;
registry
.
injection
(
'
view
:
-
outlet
'
'
template
'
'
template
:
-
outlet
'
)
;
registry
.
injection
(
'
template
'
'
env
'
'
service
:
-
glimmer
-
environment
'
)
;
registry
.
optionsForType
(
'
helper
'
{
instantiate
:
false
}
)
;
}
function
htmlbarsSetupRegistry
(
registry
)
{
commonSetupRegistry
(
registry
)
;
registry
.
optionsForType
(
'
template
'
{
instantiate
:
false
}
)
;
registry
.
register
(
'
view
:
-
outlet
'
_emberRoutingViewsViewsOutlet
.
OutletView
)
;
var
InteractiveRenderer
=
_emberMetalViews
.
InteractiveRenderer
;
var
InertRenderer
=
_emberMetalViews
.
InertRenderer
;
registry
.
register
(
'
renderer
:
-
dom
'
InteractiveRenderer
)
;
registry
.
register
(
'
renderer
:
-
inert
'
InertRenderer
)
;
registry
.
register
(
'
service
:
-
dom
-
helper
'
{
create
:
function
(
_ref2
)
{
var
document
=
_ref2
.
document
;
return
new
_emberHtmlbarsSystemDomHelper
.
default
(
document
)
;
}
}
)
;
registry
.
register
(
'
template
:
-
outlet
'
_emberHtmlbarsTemplatesTopLevelView
.
default
)
;
registry
.
register
(
'
view
:
toplevel
'
_emberViewsViewsView
.
default
.
extend
(
)
)
;
}
function
registerLibraries
(
)
{
if
(
!
librariesRegistered
)
{
librariesRegistered
=
true
;
if
(
_emberMetalEnvironment
.
default
.
hasDOM
)
{
_emberMetal
.
default
.
libraries
.
registerCoreLibrary
(
'
jQuery
'
_emberViewsSystemJquery
.
default
(
)
.
jquery
)
;
}
}
}
function
logLibraryVersions
(
)
{
if
(
_emberMetal
.
default
.
LOG_VERSION
)
{
_emberMetal
.
default
.
LOG_VERSION
=
false
;
var
libs
=
_emberMetal
.
default
.
libraries
.
_registry
;
var
nameLengths
=
libs
.
map
(
function
(
item
)
{
return
_emberMetalProperty_get
.
get
(
item
'
name
.
length
'
)
;
}
)
;
var
maxNameLength
=
Math
.
max
.
apply
(
this
nameLengths
)
;
_emberMetalDebug
.
debug
(
'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
'
)
;
for
(
var
i
=
0
l
=
libs
.
length
;
i
<
l
;
i
+
+
)
{
var
lib
=
libs
[
i
]
;
var
spaces
=
new
Array
(
maxNameLength
-
lib
.
name
.
length
+
1
)
.
join
(
'
'
)
;
_emberMetalDebug
.
debug
(
[
lib
.
name
spaces
'
:
'
lib
.
version
]
.
join
(
'
'
)
)
;
}
_emberMetalDebug
.
debug
(
'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
'
)
;
}
}
exports
.
default
=
Application
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
engine
-
instance
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
container
/
registry
'
'
ember
-
runtime
/
mixins
/
container_proxy
'
'
ember
-
runtime
/
mixins
/
registry_proxy
'
'
ember
-
metal
/
run_loop
'
]
function
(
exports
_emberRuntimeSystemObject
_containerRegistry
_emberRuntimeMixinsContainer_proxy
_emberRuntimeMixinsRegistry_proxy
_emberMetalRun_loop
)
{
'
use
strict
'
;
var
EngineInstance
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsRegistry_proxy
.
default
_emberRuntimeMixinsContainer_proxy
.
default
{
base
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
base
=
this
.
base
;
if
(
!
base
)
{
base
=
this
.
application
;
this
.
base
=
base
;
}
var
registry
=
this
.
__registry__
=
new
_containerRegistry
.
default
(
{
fallback
:
base
.
__registry__
}
)
;
this
.
__container__
=
registry
.
container
(
{
owner
:
this
}
)
;
}
unregister
:
function
(
fullName
)
{
this
.
__container__
.
reset
(
fullName
)
;
this
.
_super
.
apply
(
this
arguments
)
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
_emberMetalRun_loop
.
default
(
this
.
__container__
'
destroy
'
)
;
}
}
)
;
exports
.
default
=
EngineInstance
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
engine
'
[
'
exports
'
'
ember
-
runtime
/
system
/
namespace
'
'
container
/
registry
'
'
ember
-
runtime
/
mixins
/
registry_proxy
'
'
dag
-
map
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
empty_object
'
'
ember
-
application
/
system
/
resolver
'
'
ember
-
application
/
system
/
engine
-
instance
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberRuntimeSystemNamespace
_containerRegistry
_emberRuntimeMixinsRegistry_proxy
_dagMap
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalDebug
_emberMetalUtils
_emberMetalEmpty_object
_emberApplicationSystemResolver
_emberApplicationSystemEngineInstance
_emberMetalFeatures
_emberMetalSymbol
)
{
'
use
strict
'
;
var
GLIMMER
=
_emberMetalSymbol
.
default
(
'
GLIMMER
'
)
;
exports
.
GLIMMER
=
GLIMMER
;
function
props
(
obj
)
{
var
properties
=
[
]
;
for
(
var
key
in
obj
)
{
properties
.
push
(
key
)
;
}
return
properties
;
}
var
Engine
=
_emberRuntimeSystemNamespace
.
default
.
extend
(
_emberRuntimeMixinsRegistry_proxy
.
default
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
this
[
GLIMMER
]
=
=
=
undefined
)
{
this
[
GLIMMER
]
=
_emberMetalFeatures
.
default
(
'
ember
-
glimmer
'
)
;
}
this
.
buildRegistry
(
)
;
}
buildInstance
:
function
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
options
.
base
=
this
;
return
_emberApplicationSystemEngineInstance
.
default
.
create
(
options
)
;
}
buildRegistry
:
function
(
)
{
var
_constructor
buildRegistry
;
var
registry
=
this
.
__registry__
=
this
.
constructor
.
buildRegistry
(
this
(
_constructor
buildRegistry
=
{
}
_constructor
buildRegistry
[
GLIMMER
]
=
this
[
GLIMMER
]
_constructor
buildRegistry
)
)
;
return
registry
;
}
initializer
:
function
(
options
)
{
this
.
constructor
.
initializer
(
options
)
;
}
instanceInitializer
:
function
(
options
)
{
this
.
constructor
.
instanceInitializer
(
options
)
;
}
runInitializers
:
function
(
)
{
var
_this
=
this
;
this
.
_runInitializer
(
'
initializers
'
function
(
name
initializer
)
{
_emberMetalDebug
.
assert
(
'
No
application
initializer
named
\
'
'
+
name
+
'
\
'
'
!
!
initializer
)
;
if
(
initializer
.
initialize
.
length
=
=
=
2
)
{
_emberMetalDebug
.
deprecate
(
'
The
initialize
method
for
Application
initializer
\
'
'
+
name
+
'
\
'
should
take
only
one
argument
-
App
an
instance
of
an
Application
.
'
false
{
id
:
'
ember
-
application
.
app
-
initializer
-
initialize
-
arguments
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_initializer
-
arity
'
}
)
;
initializer
.
initialize
(
_this
.
__registry__
_this
)
;
}
else
{
initializer
.
initialize
(
_this
)
;
}
}
)
;
}
runInstanceInitializers
:
function
(
instance
)
{
this
.
_runInitializer
(
'
instanceInitializers
'
function
(
name
initializer
)
{
_emberMetalDebug
.
assert
(
'
No
instance
initializer
named
\
'
'
+
name
+
'
\
'
'
!
!
initializer
)
;
initializer
.
initialize
(
instance
)
;
}
)
;
}
_runInitializer
:
function
(
bucketName
cb
)
{
var
initializersByName
=
_emberMetalProperty_get
.
get
(
this
.
constructor
bucketName
)
;
var
initializers
=
props
(
initializersByName
)
;
var
graph
=
new
_dagMap
.
default
(
)
;
var
initializer
;
for
(
var
i
=
0
;
i
<
initializers
.
length
;
i
+
+
)
{
initializer
=
initializersByName
[
initializers
[
i
]
]
;
graph
.
addEdges
(
initializer
.
name
initializer
initializer
.
before
initializer
.
after
)
;
}
graph
.
topsort
(
function
(
vertex
)
{
cb
(
vertex
.
name
vertex
.
value
)
;
}
)
;
}
}
)
;
Engine
.
reopenClass
(
{
initializers
:
new
_emberMetalEmpty_object
.
default
(
)
instanceInitializers
:
new
_emberMetalEmpty_object
.
default
(
)
initializer
:
buildInitializerMethod
(
'
initializers
'
'
initializer
'
)
instanceInitializer
:
buildInitializerMethod
(
'
instanceInitializers
'
'
instance
initializer
'
)
buildRegistry
:
function
(
namespace
)
{
var
registry
=
new
_containerRegistry
.
default
(
{
resolver
:
resolverFor
(
namespace
)
}
)
;
registry
.
set
=
_emberMetalProperty_set
.
set
;
return
registry
;
}
resolver
:
null
Resolver
:
null
}
)
;
function
resolverFor
(
namespace
)
{
var
ResolverClass
=
namespace
.
get
(
'
Resolver
'
)
|
|
_emberApplicationSystemResolver
.
default
;
return
ResolverClass
.
create
(
{
namespace
:
namespace
}
)
;
}
function
buildInitializerMethod
(
bucketName
humanName
)
{
return
function
(
initializer
)
{
if
(
this
.
superclass
[
bucketName
]
!
=
=
undefined
&
&
this
.
superclass
[
bucketName
]
=
=
=
this
[
bucketName
]
)
{
var
attrs
=
{
}
;
attrs
[
bucketName
]
=
Object
.
create
(
this
[
bucketName
]
)
;
this
.
reopenClass
(
attrs
)
;
}
_emberMetalDebug
.
assert
(
'
The
'
+
humanName
+
'
\
'
'
+
initializer
.
name
+
'
\
'
has
already
been
registered
'
!
this
[
bucketName
]
[
initializer
.
name
]
)
;
_emberMetalDebug
.
assert
(
'
An
'
+
humanName
+
'
cannot
be
registered
without
an
initialize
function
'
_emberMetalUtils
.
canInvoke
(
initializer
'
initialize
'
)
)
;
_emberMetalDebug
.
assert
(
'
An
'
+
humanName
+
'
cannot
be
registered
without
a
name
property
'
initializer
.
name
!
=
=
undefined
)
;
this
[
bucketName
]
[
initializer
.
name
]
=
initializer
;
}
;
}
exports
.
default
=
Engine
;
}
)
;
enifed
(
'
ember
-
application
/
system
/
resolver
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
system
/
namespace
'
'
ember
-
htmlbars
/
helpers
'
'
ember
-
application
/
utils
/
validate
-
type
'
'
ember
-
metal
/
dictionary
'
'
ember
-
htmlbars
/
template_registry
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberRuntimeSystemString
_emberRuntimeSystemObject
_emberRuntimeSystemNamespace
_emberHtmlbarsHelpers
_emberApplicationUtilsValidateType
_emberMetalDictionary
_emberHtmlbarsTemplate_registry
)
{
'
use
strict
'
;
var
Resolver
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
namespace
:
null
normalize
:
null
resolve
:
null
parseName
:
null
lookupDescription
:
null
makeToString
:
null
resolveOther
:
null
_logLookup
:
null
}
)
;
exports
.
Resolver
=
Resolver
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
namespace
:
null
init
:
function
(
)
{
this
.
_parseNameCache
=
_emberMetalDictionary
.
default
(
null
)
;
}
normalize
:
function
(
fullName
)
{
var
_fullName
split
=
fullName
.
split
(
'
:
'
2
)
;
var
type
=
_fullName
split
[
0
]
;
var
name
=
_fullName
split
[
1
]
;
_emberMetalDebug
.
assert
(
'
Tried
to
normalize
a
container
name
without
a
colon
(
:
)
in
it
.
'
+
'
You
probably
tried
to
lookup
a
name
that
did
not
contain
a
type
'
+
'
a
colon
and
a
name
.
A
proper
lookup
name
would
be
view
:
post
.
'
fullName
.
split
(
'
:
'
)
.
length
=
=
=
2
)
;
if
(
type
!
=
=
'
template
'
)
{
var
result
=
name
;
if
(
result
.
indexOf
(
'
.
'
)
>
-
1
)
{
result
=
result
.
replace
(
/
\
.
(
.
)
/
g
function
(
m
)
{
return
m
.
charAt
(
1
)
.
toUpperCase
(
)
;
}
)
;
}
if
(
name
.
indexOf
(
'
_
'
)
>
-
1
)
{
result
=
result
.
replace
(
/
_
(
.
)
/
g
function
(
m
)
{
return
m
.
charAt
(
1
)
.
toUpperCase
(
)
;
}
)
;
}
if
(
name
.
indexOf
(
'
-
'
)
>
-
1
)
{
result
=
result
.
replace
(
/
-
(
.
)
/
g
function
(
m
)
{
return
m
.
charAt
(
1
)
.
toUpperCase
(
)
;
}
)
;
}
return
type
+
'
:
'
+
result
;
}
else
{
return
fullName
;
}
}
resolve
:
function
(
fullName
)
{
var
parsedName
=
this
.
parseName
(
fullName
)
;
var
resolveMethodName
=
parsedName
.
resolveMethodName
;
var
resolved
;
if
(
this
[
resolveMethodName
]
)
{
resolved
=
this
[
resolveMethodName
]
(
parsedName
)
;
}
resolved
=
resolved
|
|
this
.
resolveOther
(
parsedName
)
;
if
(
parsedName
.
root
&
&
parsedName
.
root
.
LOG_RESOLVER
)
{
this
.
_logLookup
(
resolved
parsedName
)
;
}
if
(
resolved
)
{
_emberApplicationUtilsValidateType
.
default
(
resolved
parsedName
)
;
}
return
resolved
;
}
parseName
:
function
(
fullName
)
{
return
this
.
_parseNameCache
[
fullName
]
|
|
(
this
.
_parseNameCache
[
fullName
]
=
this
.
_parseName
(
fullName
)
)
;
}
_parseName
:
function
(
fullName
)
{
var
_fullName
split2
=
fullName
.
split
(
'
:
'
)
;
var
type
=
_fullName
split2
[
0
]
;
var
fullNameWithoutType
=
_fullName
split2
[
1
]
;
var
name
=
fullNameWithoutType
;
var
namespace
=
_emberMetalProperty_get
.
get
(
this
'
namespace
'
)
;
var
root
=
namespace
;
var
lastSlashIndex
=
name
.
lastIndexOf
(
'
/
'
)
;
var
dirname
=
lastSlashIndex
!
=
=
-
1
?
name
.
slice
(
0
lastSlashIndex
)
:
null
;
if
(
type
!
=
=
'
template
'
&
&
lastSlashIndex
!
=
=
-
1
)
{
var
parts
=
name
.
split
(
'
/
'
)
;
name
=
parts
[
parts
.
length
-
1
]
;
var
namespaceName
=
_emberRuntimeSystemString
.
capitalize
(
parts
.
slice
(
0
-
1
)
.
join
(
'
.
'
)
)
;
root
=
_emberRuntimeSystemNamespace
.
default
.
byName
(
namespaceName
)
;
_emberMetalDebug
.
assert
(
'
You
are
looking
for
a
'
+
name
+
'
'
+
type
+
'
in
the
'
+
namespaceName
+
'
namespace
but
the
namespace
could
not
be
found
'
root
)
;
}
var
resolveMethodName
=
fullNameWithoutType
=
=
=
'
main
'
?
'
Main
'
:
_emberRuntimeSystemString
.
classify
(
type
)
;
if
(
!
(
name
&
&
type
)
)
{
throw
new
TypeError
(
'
Invalid
fullName
:
'
+
fullName
+
'
must
be
of
the
form
type
:
name
'
)
;
}
return
{
fullName
:
fullName
type
:
type
fullNameWithoutType
:
fullNameWithoutType
dirname
:
dirname
name
:
name
root
:
root
resolveMethodName
:
'
resolve
'
+
resolveMethodName
}
;
}
lookupDescription
:
function
(
fullName
)
{
var
parsedName
=
this
.
parseName
(
fullName
)
;
var
description
;
if
(
parsedName
.
type
=
=
=
'
template
'
)
{
return
'
template
at
'
+
parsedName
.
fullNameWithoutType
.
replace
(
/
\
.
/
g
'
/
'
)
;
}
description
=
parsedName
.
root
+
'
.
'
+
_emberRuntimeSystemString
.
classify
(
parsedName
.
name
)
.
replace
(
/
\
.
/
g
'
'
)
;
if
(
parsedName
.
type
!
=
=
'
model
'
)
{
description
+
=
_emberRuntimeSystemString
.
classify
(
parsedName
.
type
)
;
}
return
description
;
}
makeToString
:
function
(
factory
fullName
)
{
return
factory
.
toString
(
)
;
}
useRouterNaming
:
function
(
parsedName
)
{
parsedName
.
name
=
parsedName
.
name
.
replace
(
/
\
.
/
g
'
_
'
)
;
if
(
parsedName
.
name
=
=
=
'
basic
'
)
{
parsedName
.
name
=
'
'
;
}
}
resolveTemplate
:
function
(
parsedName
)
{
var
templateName
=
parsedName
.
fullNameWithoutType
.
replace
(
/
\
.
/
g
'
/
'
)
;
return
_emberHtmlbarsTemplate_registry
.
get
(
templateName
)
|
|
_emberHtmlbarsTemplate_registry
.
get
(
_emberRuntimeSystemString
.
decamelize
(
templateName
)
)
;
}
resolveView
:
function
(
parsedName
)
{
this
.
useRouterNaming
(
parsedName
)
;
return
this
.
resolveOther
(
parsedName
)
;
}
resolveController
:
function
(
parsedName
)
{
this
.
useRouterNaming
(
parsedName
)
;
return
this
.
resolveOther
(
parsedName
)
;
}
resolveRoute
:
function
(
parsedName
)
{
this
.
useRouterNaming
(
parsedName
)
;
return
this
.
resolveOther
(
parsedName
)
;
}
resolveModel
:
function
(
parsedName
)
{
var
className
=
_emberRuntimeSystemString
.
classify
(
parsedName
.
name
)
;
var
factory
=
_emberMetalProperty_get
.
get
(
parsedName
.
root
className
)
;
if
(
factory
)
{
return
factory
;
}
}
resolveHelper
:
function
(
parsedName
)
{
return
this
.
resolveOther
(
parsedName
)
|
|
_emberHtmlbarsHelpers
.
default
[
parsedName
.
fullNameWithoutType
]
;
}
resolveOther
:
function
(
parsedName
)
{
var
className
=
_emberRuntimeSystemString
.
classify
(
parsedName
.
name
)
+
_emberRuntimeSystemString
.
classify
(
parsedName
.
type
)
;
var
factory
=
_emberMetalProperty_get
.
get
(
parsedName
.
root
className
)
;
if
(
factory
)
{
return
factory
;
}
}
resolveMain
:
function
(
parsedName
)
{
var
className
=
_emberRuntimeSystemString
.
classify
(
parsedName
.
type
)
;
return
_emberMetalProperty_get
.
get
(
parsedName
.
root
className
)
;
}
_logLookup
:
function
(
found
parsedName
)
{
var
symbol
padding
;
if
(
found
)
{
symbol
=
'
[
]
'
;
}
else
{
symbol
=
'
[
]
'
;
}
if
(
parsedName
.
fullName
.
length
>
60
)
{
padding
=
'
.
'
;
}
else
{
padding
=
new
Array
(
60
-
parsedName
.
fullName
.
length
)
.
join
(
'
.
'
)
;
}
_emberMetalDebug
.
info
(
symbol
parsedName
.
fullName
padding
this
.
lookupDescription
(
parsedName
.
fullName
)
)
;
}
knownForType
:
function
(
type
)
{
var
namespace
=
_emberMetalProperty_get
.
get
(
this
'
namespace
'
)
;
var
suffix
=
_emberRuntimeSystemString
.
classify
(
type
)
;
var
typeRegexp
=
new
RegExp
(
suffix
+
'
'
)
;
var
known
=
_emberMetalDictionary
.
default
(
null
)
;
var
knownKeys
=
Object
.
keys
(
namespace
)
;
for
(
var
index
=
0
_length
=
knownKeys
.
length
;
index
<
_length
;
index
+
+
)
{
var
_name
=
knownKeys
[
index
]
;
if
(
typeRegexp
.
test
(
_name
)
)
{
var
containerName
=
this
.
translateToContainerFullname
(
type
_name
)
;
known
[
containerName
]
=
true
;
}
}
return
known
;
}
translateToContainerFullname
:
function
(
type
name
)
{
var
suffix
=
_emberRuntimeSystemString
.
classify
(
type
)
;
var
namePrefix
=
name
.
slice
(
0
suffix
.
length
*
-
1
)
;
var
dasherizedName
=
_emberRuntimeSystemString
.
dasherize
(
namePrefix
)
;
return
type
+
'
:
'
+
dasherizedName
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
application
/
utils
/
validate
-
type
'
[
'
exports
'
'
ember
-
metal
/
debug
'
]
function
(
exports
_emberMetalDebug
)
{
'
use
strict
'
;
exports
.
default
=
validateType
;
var
VALIDATED_TYPES
=
{
route
:
[
'
assert
'
'
isRouteFactory
'
'
Ember
.
Route
'
]
component
:
[
'
deprecate
'
'
isComponentFactory
'
'
Ember
.
Component
'
]
view
:
[
'
deprecate
'
'
isViewFactory
'
'
Ember
.
View
'
]
service
:
[
'
deprecate
'
'
isServiceFactory
'
'
Ember
.
Service
'
]
}
;
function
validateType
(
resolvedType
parsedName
)
{
var
validationAttributes
=
VALIDATED_TYPES
[
parsedName
.
type
]
;
if
(
!
validationAttributes
)
{
return
;
}
var
action
=
validationAttributes
[
0
]
;
var
factoryFlag
=
validationAttributes
[
1
]
;
var
expectedType
=
validationAttributes
[
2
]
;
if
(
action
=
=
=
'
deprecate
'
)
{
_emberMetalDebug
.
deprecate
(
'
In
Ember
2
.
0
'
+
parsedName
.
type
+
'
factories
must
have
an
'
+
factoryFlag
+
'
'
+
(
'
property
set
to
true
.
You
registered
'
+
resolvedType
+
'
as
a
'
+
parsedName
.
type
+
'
'
)
+
(
'
factory
.
Either
add
the
'
+
factoryFlag
+
'
property
to
this
factory
or
'
)
+
(
'
extend
from
'
+
expectedType
+
'
.
'
)
!
!
resolvedType
[
factoryFlag
]
{
id
:
'
ember
-
application
.
validate
-
type
'
until
:
'
3
.
0
.
0
'
}
)
;
}
else
{
_emberMetalDebug
.
assert
(
'
Expected
'
+
parsedName
.
fullName
+
'
to
resolve
to
an
'
+
expectedType
+
'
but
'
+
(
'
instead
it
was
'
+
resolvedType
+
'
.
'
)
!
!
resolvedType
[
factoryFlag
]
)
;
}
}
}
)
;
enifed
(
'
ember
-
debug
/
deprecate
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
logger
'
'
ember
-
debug
/
handlers
'
]
function
(
exports
_emberMetalCore
_emberMetalError
_emberMetalLogger
_emberDebugHandlers
)
{
'
use
strict
'
;
var
_slice
=
Array
.
prototype
.
slice
;
exports
.
registerHandler
=
registerHandler
;
exports
.
default
=
deprecate
;
function
registerHandler
(
handler
)
{
_emberDebugHandlers
.
registerHandler
(
'
deprecate
'
handler
)
;
}
function
formatMessage
(
_message
options
)
{
var
message
=
_message
;
if
(
options
&
&
options
.
id
)
{
message
=
message
+
(
'
[
deprecation
id
:
'
+
options
.
id
+
'
]
'
)
;
}
if
(
options
&
&
options
.
url
)
{
message
+
=
'
See
'
+
options
.
url
+
'
for
more
details
.
'
;
}
return
message
;
}
registerHandler
(
function
logDeprecationToConsole
(
message
options
)
{
var
updatedMessage
=
formatMessage
(
message
options
)
;
_emberMetalLogger
.
default
.
warn
(
'
DEPRECATION
:
'
+
updatedMessage
)
;
}
)
;
var
captureErrorForStack
=
undefined
;
if
(
new
Error
(
)
.
stack
)
{
captureErrorForStack
=
function
(
)
{
return
new
Error
(
)
;
}
;
}
else
{
captureErrorForStack
=
function
(
)
{
try
{
__fail__
.
fail
(
)
;
}
catch
(
e
)
{
return
e
;
}
}
;
}
registerHandler
(
function
logDeprecationStackTrace
(
message
options
next
)
{
if
(
_emberMetalCore
.
default
.
LOG_STACKTRACE_ON_DEPRECATION
)
{
var
stackStr
=
'
'
;
var
error
=
captureErrorForStack
(
)
;
var
stack
=
undefined
;
if
(
error
.
stack
)
{
if
(
error
[
'
arguments
'
]
)
{
stack
=
error
.
stack
.
replace
(
/
^
\
s
+
at
\
s
+
/
gm
'
'
)
.
replace
(
/
^
(
[
^
\
(
]
+
?
)
(
[
\
n
]
)
/
gm
'
{
anonymous
}
(
1
)
2
'
)
.
replace
(
/
^
Object
.
<
anonymous
>
\
s
*
\
(
(
[
^
\
)
]
+
)
\
)
/
gm
'
{
anonymous
}
(
1
)
'
)
.
split
(
'
\
n
'
)
;
stack
.
shift
(
)
;
}
else
{
stack
=
error
.
stack
.
replace
(
/
(
?
:
\
n
:
0
)
?
\
s
+
/
m
'
'
)
.
replace
(
/
^
\
(
/
gm
'
{
anonymous
}
(
'
)
.
split
(
'
\
n
'
)
;
}
stackStr
=
'
\
n
'
+
stack
.
slice
(
2
)
.
join
(
'
\
n
'
)
;
}
var
updatedMessage
=
formatMessage
(
message
options
)
;
_emberMetalLogger
.
default
.
warn
(
'
DEPRECATION
:
'
+
updatedMessage
+
stackStr
)
;
}
else
{
next
.
apply
(
undefined
arguments
)
;
}
}
)
;
registerHandler
(
function
raiseOnDeprecation
(
message
options
next
)
{
if
(
_emberMetalCore
.
default
.
ENV
.
RAISE_ON_DEPRECATION
)
{
var
updatedMessage
=
formatMessage
(
message
)
;
throw
new
_emberMetalError
.
default
(
updatedMessage
)
;
}
else
{
next
.
apply
(
undefined
arguments
)
;
}
}
)
;
var
missingOptionsDeprecation
=
'
When
calling
Ember
.
deprecate
you
'
+
'
must
provide
an
options
hash
as
the
third
parameter
.
'
+
'
options
should
include
id
and
until
properties
.
'
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
;
var
missingOptionsIdDeprecation
=
'
When
calling
Ember
.
deprecate
you
must
provide
id
in
options
.
'
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
;
var
missingOptionsUntilDeprecation
=
'
When
calling
Ember
.
deprecate
you
must
provide
until
in
options
.
'
;
exports
.
missingOptionsUntilDeprecation
=
missingOptionsUntilDeprecation
;
function
deprecate
(
message
test
options
)
{
if
(
!
options
|
|
!
options
.
id
&
&
!
options
.
until
)
{
deprecate
(
missingOptionsDeprecation
false
{
id
:
'
ember
-
debug
.
deprecate
-
options
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
id
)
{
deprecate
(
missingOptionsIdDeprecation
false
{
id
:
'
ember
-
debug
.
deprecate
-
id
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
until
)
{
deprecate
(
missingOptionsUntilDeprecation
options
&
&
options
.
until
{
id
:
'
ember
-
debug
.
deprecate
-
until
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
_emberDebugHandlers
.
invoke
.
apply
(
undefined
[
'
deprecate
'
]
.
concat
(
_slice
.
call
(
arguments
)
)
)
;
}
}
)
;
enifed
(
"
ember
-
debug
/
handlers
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
registerHandler
=
registerHandler
;
exports
.
invoke
=
invoke
;
var
HANDLERS
=
{
}
;
exports
.
HANDLERS
=
HANDLERS
;
function
registerHandler
(
type
callback
)
{
var
nextHandler
=
HANDLERS
[
type
]
|
|
function
(
)
{
}
;
HANDLERS
[
type
]
=
function
(
message
options
)
{
callback
(
message
options
nextHandler
)
;
}
;
}
function
invoke
(
type
message
test
options
)
{
if
(
test
)
{
return
;
}
var
handlerForType
=
HANDLERS
[
type
]
;
if
(
!
handlerForType
)
{
return
;
}
if
(
handlerForType
)
{
handlerForType
(
message
options
)
;
}
}
}
)
;
enifed
(
'
ember
-
debug
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
environment
'
'
ember
-
debug
/
deprecate
'
'
ember
-
debug
/
warn
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberMetalFeatures
_emberMetalError
_emberMetalLogger
_emberMetalEnvironment
_emberDebugDeprecate
_emberDebugWarn
)
{
'
use
strict
'
;
exports
.
_warnIfUsingStrippedFeatureFlags
=
_warnIfUsingStrippedFeatureFlags
;
_emberMetalDebug
.
setDebugFunction
(
'
assert
'
function
assert
(
desc
test
)
{
if
(
!
test
)
{
throw
new
_emberMetalError
.
default
(
'
Assertion
Failed
:
'
+
desc
)
;
}
}
)
;
_emberMetalDebug
.
setDebugFunction
(
'
debug
'
function
debug
(
message
)
{
_emberMetalLogger
.
default
.
debug
(
'
DEBUG
:
'
+
message
)
;
}
)
;
_emberMetalDebug
.
setDebugFunction
(
'
info
'
function
info
(
)
{
_emberMetalLogger
.
default
.
info
.
apply
(
undefined
arguments
)
;
}
)
;
_emberMetalDebug
.
setDebugFunction
(
'
deprecateFunc
'
function
deprecateFunc
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
args
.
length
=
=
=
3
)
{
var
_ret
=
(
function
(
)
{
var
message
=
args
[
0
]
;
var
options
=
args
[
1
]
;
var
func
=
args
[
2
]
;
return
{
v
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
message
false
options
)
;
return
func
.
apply
(
this
arguments
)
;
}
}
;
}
)
(
)
;
if
(
typeof
_ret
=
=
=
'
object
'
)
return
_ret
.
v
;
}
else
{
var
_ret2
=
(
function
(
)
{
var
message
=
args
[
0
]
;
var
func
=
args
[
1
]
;
return
{
v
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
message
)
;
return
func
.
apply
(
this
arguments
)
;
}
}
;
}
)
(
)
;
if
(
typeof
_ret2
=
=
=
'
object
'
)
return
_ret2
.
v
;
}
}
)
;
_emberMetalDebug
.
setDebugFunction
(
'
runInDebug
'
function
runInDebug
(
func
)
{
func
(
)
;
}
)
;
_emberMetalDebug
.
setDebugFunction
(
'
debugSeal
'
function
debugSeal
(
obj
)
{
Object
.
seal
(
obj
)
;
}
)
;
_emberMetalDebug
.
setDebugFunction
(
'
deprecate
'
_emberDebugDeprecate
.
default
)
;
_emberMetalDebug
.
setDebugFunction
(
'
warn
'
_emberDebugWarn
.
default
)
;
function
_warnIfUsingStrippedFeatureFlags
(
FEATURES
knownFeatures
featuresWereStripped
)
{
if
(
featuresWereStripped
)
{
_emberMetalDebug
.
warn
(
'
Ember
.
ENV
.
ENABLE_OPTIONAL_FEATURES
is
only
available
in
canary
builds
.
'
!
_emberMetalCore
.
default
.
ENV
.
ENABLE_OPTIONAL_FEATURES
{
id
:
'
ember
-
debug
.
feature
-
flag
-
with
-
features
-
stripped
'
}
)
;
var
keys
=
Object
.
keys
(
FEATURES
|
|
{
}
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
if
(
key
=
=
=
'
isEnabled
'
|
|
!
(
key
in
knownFeatures
)
)
{
continue
;
}
_emberMetalDebug
.
warn
(
'
FEATURE
[
"
'
+
key
+
'
"
]
is
set
as
enabled
but
FEATURE
flags
are
only
available
in
canary
builds
.
'
!
FEATURES
[
key
]
{
id
:
'
ember
-
debug
.
feature
-
flag
-
with
-
features
-
stripped
'
}
)
;
}
}
}
if
(
!
_emberMetalCore
.
default
.
testing
)
{
_emberMetalFeatures
.
FEATURES
[
'
features
-
stripped
-
test
'
]
=
true
;
var
featuresWereStripped
=
true
;
delete
_emberMetalFeatures
.
FEATURES
[
'
features
-
stripped
-
test
'
]
;
_warnIfUsingStrippedFeatureFlags
(
_emberMetalCore
.
default
.
ENV
.
FEATURES
_emberMetalFeatures
.
KNOWN_FEATURES
featuresWereStripped
)
;
var
isFirefox
=
_emberMetalEnvironment
.
default
.
isFirefox
;
var
isChrome
=
_emberMetalEnvironment
.
default
.
isChrome
;
if
(
typeof
window
!
=
=
'
undefined
'
&
&
(
isFirefox
|
|
isChrome
)
&
&
window
.
addEventListener
)
{
window
.
addEventListener
(
'
load
'
function
(
)
{
if
(
document
.
documentElement
&
&
document
.
documentElement
.
dataset
&
&
!
document
.
documentElement
.
dataset
.
emberExtension
)
{
var
downloadURL
;
if
(
isChrome
)
{
downloadURL
=
'
https
:
/
/
chrome
.
google
.
com
/
webstore
/
detail
/
ember
-
inspector
/
bmdblncegkenkacieihfhpjfppoconhi
'
;
}
else
if
(
isFirefox
)
{
downloadURL
=
'
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
firefox
/
addon
/
ember
-
inspector
/
'
;
}
_emberMetalDebug
.
debug
(
'
For
more
advanced
debugging
install
the
Ember
Inspector
from
'
+
downloadURL
)
;
}
}
false
)
;
}
}
_emberMetalCore
.
default
.
Debug
=
{
}
;
_emberMetalCore
.
default
.
Debug
.
registerDeprecationHandler
=
_emberDebugDeprecate
.
registerHandler
;
_emberMetalCore
.
default
.
Debug
.
registerWarnHandler
=
_emberDebugWarn
.
registerHandler
;
var
runningNonEmberDebugJS
=
false
;
exports
.
runningNonEmberDebugJS
=
runningNonEmberDebugJS
;
if
(
runningNonEmberDebugJS
)
{
_emberMetalDebug
.
warn
(
'
Please
use
ember
.
debug
.
js
instead
of
ember
.
js
for
development
and
debugging
.
'
)
;
}
}
)
;
enifed
(
'
ember
-
debug
/
warn
'
[
'
exports
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
debug
'
'
ember
-
debug
/
handlers
'
]
function
(
exports
_emberMetalLogger
_emberMetalDebug
_emberDebugHandlers
)
{
'
use
strict
'
;
var
_slice
=
Array
.
prototype
.
slice
;
exports
.
registerHandler
=
registerHandler
;
exports
.
default
=
warn
;
function
registerHandler
(
handler
)
{
_emberDebugHandlers
.
registerHandler
(
'
warn
'
handler
)
;
}
registerHandler
(
function
logWarning
(
message
options
)
{
_emberMetalLogger
.
default
.
warn
(
'
WARNING
:
'
+
message
)
;
if
(
'
trace
'
in
_emberMetalLogger
.
default
)
{
_emberMetalLogger
.
default
.
trace
(
)
;
}
}
)
;
var
missingOptionsDeprecation
=
'
When
calling
Ember
.
warn
you
'
+
'
must
provide
an
options
hash
as
the
third
parameter
.
'
+
'
options
should
include
an
id
property
.
'
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
;
var
missingOptionsIdDeprecation
=
'
When
calling
Ember
.
warn
you
must
provide
id
in
options
.
'
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
;
function
warn
(
message
test
options
)
{
if
(
!
options
)
{
_emberMetalDebug
.
deprecate
(
missingOptionsDeprecation
false
{
id
:
'
ember
-
debug
.
warn
-
options
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
id
)
{
_emberMetalDebug
.
deprecate
(
missingOptionsIdDeprecation
false
{
id
:
'
ember
-
debug
.
warn
-
id
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
_emberDebugHandlers
.
invoke
.
apply
(
undefined
[
'
warn
'
]
.
concat
(
_slice
.
call
(
arguments
)
)
)
;
}
}
)
;
enifed
(
'
ember
-
extension
-
support
/
container_debug_adapter
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
runtime
/
system
/
native_array
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
runtime
/
system
/
namespace
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberMetalCore
_emberRuntimeSystemNative_array
_emberRuntimeUtils
_emberRuntimeSystemString
_emberRuntimeSystemNamespace
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
resolver
:
null
canCatalogEntriesByType
:
function
(
type
)
{
if
(
type
=
=
=
'
model
'
|
|
type
=
=
=
'
template
'
)
{
return
false
;
}
return
true
;
}
catalogEntriesByType
:
function
(
type
)
{
var
namespaces
=
_emberRuntimeSystemNative_array
.
A
(
_emberRuntimeSystemNamespace
.
default
.
NAMESPACES
)
;
var
types
=
_emberRuntimeSystemNative_array
.
A
(
)
;
var
typeSuffixRegex
=
new
RegExp
(
_emberRuntimeSystemString
.
classify
(
type
)
+
'
'
)
;
namespaces
.
forEach
(
function
(
namespace
)
{
if
(
namespace
!
=
=
_emberMetalCore
.
default
)
{
for
(
var
key
in
namespace
)
{
if
(
!
namespace
.
hasOwnProperty
(
key
)
)
{
continue
;
}
if
(
typeSuffixRegex
.
test
(
key
)
)
{
var
klass
=
namespace
[
key
]
;
if
(
_emberRuntimeUtils
.
typeOf
(
klass
)
=
=
=
'
class
'
)
{
types
.
push
(
_emberRuntimeSystemString
.
dasherize
(
key
.
replace
(
typeSuffixRegex
'
'
)
)
)
;
}
}
}
}
}
)
;
return
types
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
extension
-
support
/
data_adapter
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
run_loop
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
runtime
/
system
/
namespace
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
system
/
native_array
'
'
ember
-
application
/
system
/
application
'
'
container
/
owner
'
'
ember
-
runtime
/
mixins
/
array
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalRun_loop
_emberRuntimeSystemString
_emberRuntimeSystemNamespace
_emberRuntimeSystemObject
_emberRuntimeSystemNative_array
_emberApplicationSystemApplication
_containerOwner
_emberRuntimeMixinsArray
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
releaseMethods
=
_emberRuntimeSystemNative_array
.
A
(
)
;
}
containerDebugAdapter
:
undefined
attributeLimit
:
3
acceptsModelName
:
true
releaseMethods
:
_emberRuntimeSystemNative_array
.
A
(
)
getFilters
:
function
(
)
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
watchModelTypes
:
function
(
typesAdded
typesUpdated
)
{
var
_this
=
this
;
var
modelTypes
=
this
.
getModelTypes
(
)
;
var
releaseMethods
=
_emberRuntimeSystemNative_array
.
A
(
)
;
var
typesToSend
;
typesToSend
=
modelTypes
.
map
(
function
(
type
)
{
var
klass
=
type
.
klass
;
var
wrapped
=
_this
.
wrapModelType
(
klass
type
.
name
)
;
releaseMethods
.
push
(
_this
.
observeModelType
(
type
.
name
typesUpdated
)
)
;
return
wrapped
;
}
)
;
typesAdded
(
typesToSend
)
;
var
release
=
function
(
)
{
releaseMethods
.
forEach
(
function
(
fn
)
{
return
fn
(
)
;
}
)
;
_this
.
releaseMethods
.
removeObject
(
release
)
;
}
;
this
.
releaseMethods
.
pushObject
(
release
)
;
return
release
;
}
_nameToClass
:
function
(
type
)
{
if
(
typeof
type
=
=
=
'
string
'
)
{
type
=
_containerOwner
.
getOwner
(
this
)
.
_lookupFactory
(
'
model
:
'
+
type
)
;
}
return
type
;
}
watchRecords
:
function
(
modelName
recordsAdded
recordsUpdated
recordsRemoved
)
{
var
_this2
=
this
;
var
releaseMethods
=
_emberRuntimeSystemNative_array
.
A
(
)
;
var
klass
=
this
.
_nameToClass
(
modelName
)
;
var
records
=
this
.
getRecords
(
klass
modelName
)
;
var
release
;
var
recordUpdated
=
function
(
updatedRecord
)
{
recordsUpdated
(
[
updatedRecord
]
)
;
}
;
var
recordsToSend
=
records
.
map
(
function
(
record
)
{
releaseMethods
.
push
(
_this2
.
observeRecord
(
record
recordUpdated
)
)
;
return
_this2
.
wrapRecord
(
record
)
;
}
)
;
var
contentDidChange
=
function
(
array
idx
removedCount
addedCount
)
{
for
(
var
i
=
idx
;
i
<
idx
+
addedCount
;
i
+
+
)
{
var
record
=
_emberRuntimeMixinsArray
.
objectAt
(
array
i
)
;
var
wrapped
=
_this2
.
wrapRecord
(
record
)
;
releaseMethods
.
push
(
_this2
.
observeRecord
(
record
recordUpdated
)
)
;
recordsAdded
(
[
wrapped
]
)
;
}
if
(
removedCount
)
{
recordsRemoved
(
idx
removedCount
)
;
}
}
;
var
observer
=
{
didChange
:
contentDidChange
willChange
:
function
(
)
{
return
this
;
}
}
;
_emberRuntimeMixinsArray
.
addArrayObserver
(
records
this
observer
)
;
release
=
function
(
)
{
releaseMethods
.
forEach
(
function
(
fn
)
{
fn
(
)
;
}
)
;
_emberRuntimeMixinsArray
.
removeArrayObserver
(
records
_this2
observer
)
;
_this2
.
releaseMethods
.
removeObject
(
release
)
;
}
;
recordsAdded
(
recordsToSend
)
;
this
.
releaseMethods
.
pushObject
(
release
)
;
return
release
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
releaseMethods
.
forEach
(
function
(
fn
)
{
fn
(
)
;
}
)
;
}
detect
:
function
(
klass
)
{
return
false
;
}
columnsForType
:
function
(
type
)
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
observeModelType
:
function
(
modelName
typesUpdated
)
{
var
_this3
=
this
;
var
klass
=
this
.
_nameToClass
(
modelName
)
;
var
records
=
this
.
getRecords
(
klass
modelName
)
;
var
onChange
=
function
(
)
{
typesUpdated
(
[
_this3
.
wrapModelType
(
klass
modelName
)
]
)
;
}
;
var
observer
=
{
didChange
:
function
(
)
{
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
actions
'
this
onChange
)
;
}
willChange
:
function
(
)
{
return
this
;
}
}
;
_emberRuntimeMixinsArray
.
addArrayObserver
(
records
this
observer
)
;
var
release
=
function
(
)
{
_emberRuntimeMixinsArray
.
removeArrayObserver
(
records
_this3
observer
)
;
}
;
return
release
;
}
wrapModelType
:
function
(
klass
name
)
{
var
records
=
this
.
getRecords
(
klass
name
)
;
var
typeToSend
;
typeToSend
=
{
name
:
name
count
:
_emberMetalProperty_get
.
get
(
records
'
length
'
)
columns
:
this
.
columnsForType
(
klass
)
object
:
klass
}
;
return
typeToSend
;
}
getModelTypes
:
function
(
)
{
var
_this4
=
this
;
var
containerDebugAdapter
=
this
.
get
(
'
containerDebugAdapter
'
)
;
var
types
;
if
(
containerDebugAdapter
.
canCatalogEntriesByType
(
'
model
'
)
)
{
types
=
containerDebugAdapter
.
catalogEntriesByType
(
'
model
'
)
;
}
else
{
types
=
this
.
_getObjectsOnNamespaces
(
)
;
}
types
=
_emberRuntimeSystemNative_array
.
A
(
types
)
.
map
(
function
(
name
)
{
return
{
klass
:
_this4
.
_nameToClass
(
name
)
name
:
name
}
;
}
)
;
types
=
_emberRuntimeSystemNative_array
.
A
(
types
)
.
filter
(
function
(
type
)
{
return
_this4
.
detect
(
type
.
klass
)
;
}
)
;
return
_emberRuntimeSystemNative_array
.
A
(
types
)
;
}
_getObjectsOnNamespaces
:
function
(
)
{
var
_this5
=
this
;
var
namespaces
=
_emberRuntimeSystemNative_array
.
A
(
_emberRuntimeSystemNamespace
.
default
.
NAMESPACES
)
;
var
types
=
_emberRuntimeSystemNative_array
.
A
(
)
;
namespaces
.
forEach
(
function
(
namespace
)
{
for
(
var
key
in
namespace
)
{
if
(
!
namespace
.
hasOwnProperty
(
key
)
)
{
continue
;
}
if
(
!
_this5
.
detect
(
namespace
[
key
]
)
)
{
continue
;
}
var
name
=
_emberRuntimeSystemString
.
dasherize
(
key
)
;
if
(
!
(
namespace
instanceof
_emberApplicationSystemApplication
.
default
)
&
&
namespace
.
toString
(
)
)
{
name
=
namespace
+
'
/
'
+
name
;
}
types
.
push
(
name
)
;
}
}
)
;
return
types
;
}
getRecords
:
function
(
type
)
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
wrapRecord
:
function
(
record
)
{
var
recordToSend
=
{
object
:
record
}
;
recordToSend
.
columnValues
=
this
.
getRecordColumnValues
(
record
)
;
recordToSend
.
searchKeywords
=
this
.
getRecordKeywords
(
record
)
;
recordToSend
.
filterValues
=
this
.
getRecordFilterValues
(
record
)
;
recordToSend
.
color
=
this
.
getRecordColor
(
record
)
;
return
recordToSend
;
}
getRecordColumnValues
:
function
(
record
)
{
return
{
}
;
}
getRecordKeywords
:
function
(
record
)
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
getRecordFilterValues
:
function
(
record
)
{
return
{
}
;
}
getRecordColor
:
function
(
record
)
{
return
null
;
}
observeRecord
:
function
(
record
recordUpdated
)
{
return
function
(
)
{
}
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
extension
-
support
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
extension
-
support
/
data_adapter
'
'
ember
-
extension
-
support
/
container_debug_adapter
'
]
function
(
exports
_emberMetalCore
_emberExtensionSupportData_adapter
_emberExtensionSupportContainer_debug_adapter
)
{
'
use
strict
'
;
_emberMetalCore
.
default
.
DataAdapter
=
_emberExtensionSupportData_adapter
.
default
;
_emberMetalCore
.
default
.
ContainerDebugAdapter
=
_emberExtensionSupportContainer_debug_adapter
.
default
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
compat
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
htmlbars
/
utils
/
string
'
]
function
(
exports
_emberMetalCore
_emberHtmlbarsUtilsString
)
{
'
use
strict
'
;
var
EmberHandlebars
=
_emberMetalCore
.
default
.
Handlebars
=
_emberMetalCore
.
default
.
Handlebars
|
|
{
}
;
EmberHandlebars
.
SafeString
=
_emberHtmlbarsUtilsString
.
SafeString
;
EmberHandlebars
.
Utils
=
{
escapeExpression
:
_emberHtmlbarsUtilsString
.
escapeExpression
}
;
exports
.
default
=
EmberHandlebars
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
env
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
metal
/
environment
'
'
htmlbars
-
runtime
'
'
ember
-
metal
/
assign
'
'
ember
-
htmlbars
/
hooks
/
subexpr
'
'
ember
-
htmlbars
/
hooks
/
concat
'
'
ember
-
htmlbars
/
hooks
/
link
-
render
-
node
'
'
ember
-
htmlbars
/
hooks
/
create
-
fresh
-
scope
'
'
ember
-
htmlbars
/
hooks
/
bind
-
shadow
-
scope
'
'
ember
-
htmlbars
/
hooks
/
bind
-
self
'
'
ember
-
htmlbars
/
hooks
/
bind
-
scope
'
'
ember
-
htmlbars
/
hooks
/
bind
-
local
'
'
ember
-
htmlbars
/
hooks
/
bind
-
block
'
'
ember
-
htmlbars
/
hooks
/
update
-
self
'
'
ember
-
htmlbars
/
hooks
/
get
-
root
'
'
ember
-
htmlbars
/
hooks
/
get
-
child
'
'
ember
-
htmlbars
/
hooks
/
get
-
block
'
'
ember
-
htmlbars
/
hooks
/
get
-
value
'
'
ember
-
htmlbars
/
hooks
/
get
-
cell
-
or
-
value
'
'
ember
-
htmlbars
/
hooks
/
cleanup
-
render
-
node
'
'
ember
-
htmlbars
/
hooks
/
destroy
-
render
-
node
'
'
ember
-
htmlbars
/
hooks
/
did
-
render
-
node
'
'
ember
-
htmlbars
/
hooks
/
will
-
cleanup
-
tree
'
'
ember
-
htmlbars
/
hooks
/
did
-
cleanup
-
tree
'
'
ember
-
htmlbars
/
hooks
/
classify
'
'
ember
-
htmlbars
/
hooks
/
component
'
'
ember
-
htmlbars
/
hooks
/
lookup
-
helper
'
'
ember
-
htmlbars
/
hooks
/
has
-
helper
'
'
ember
-
htmlbars
/
hooks
/
invoke
-
helper
'
'
ember
-
htmlbars
/
hooks
/
element
'
'
ember
-
htmlbars
/
helpers
'
'
ember
-
htmlbars
/
keywords
'
'
ember
-
htmlbars
/
system
/
dom
-
helper
'
'
ember
-
htmlbars
/
keywords
/
debugger
'
'
ember
-
htmlbars
/
keywords
/
with
'
'
ember
-
htmlbars
/
keywords
/
outlet
'
'
ember
-
htmlbars
/
keywords
/
unbound
'
'
ember
-
htmlbars
/
keywords
/
view
'
'
ember
-
htmlbars
/
keywords
/
component
'
'
ember
-
htmlbars
/
keywords
/
element
-
component
'
'
ember
-
htmlbars
/
keywords
/
partial
'
'
ember
-
htmlbars
/
keywords
/
input
'
'
ember
-
htmlbars
/
keywords
/
textarea
'
'
ember
-
htmlbars
/
keywords
/
yield
'
'
ember
-
htmlbars
/
keywords
/
mut
'
'
ember
-
htmlbars
/
keywords
/
readonly
'
'
ember
-
htmlbars
/
keywords
/
get
'
]
function
(
exports
_emberMetal
_emberMetalEnvironment
_htmlbarsRuntime
_emberMetalAssign
_emberHtmlbarsHooksSubexpr
_emberHtmlbarsHooksConcat
_emberHtmlbarsHooksLinkRenderNode
_emberHtmlbarsHooksCreateFreshScope
_emberHtmlbarsHooksBindShadowScope
_emberHtmlbarsHooksBindSelf
_emberHtmlbarsHooksBindScope
_emberHtmlbarsHooksBindLocal
_emberHtmlbarsHooksBindBlock
_emberHtmlbarsHooksUpdateSelf
_emberHtmlbarsHooksGetRoot
_emberHtmlbarsHooksGetChild
_emberHtmlbarsHooksGetBlock
_emberHtmlbarsHooksGetValue
_emberHtmlbarsHooksGetCellOrValue
_emberHtmlbarsHooksCleanupRenderNode
_emberHtmlbarsHooksDestroyRenderNode
_emberHtmlbarsHooksDidRenderNode
_emberHtmlbarsHooksWillCleanupTree
_emberHtmlbarsHooksDidCleanupTree
_emberHtmlbarsHooksClassify
_emberHtmlbarsHooksComponent
_emberHtmlbarsHooksLookupHelper
_emberHtmlbarsHooksHasHelper
_emberHtmlbarsHooksInvokeHelper
_emberHtmlbarsHooksElement
_emberHtmlbarsHelpers
_emberHtmlbarsKeywords
_emberHtmlbarsSystemDomHelper
_emberHtmlbarsKeywordsDebugger
_emberHtmlbarsKeywordsWith
_emberHtmlbarsKeywordsOutlet
_emberHtmlbarsKeywordsUnbound
_emberHtmlbarsKeywordsView
_emberHtmlbarsKeywordsComponent
_emberHtmlbarsKeywordsElementComponent
_emberHtmlbarsKeywordsPartial
_emberHtmlbarsKeywordsInput
_emberHtmlbarsKeywordsTextarea
_emberHtmlbarsKeywordsYield
_emberHtmlbarsKeywordsMut
_emberHtmlbarsKeywordsReadonly
_emberHtmlbarsKeywordsGet
)
{
'
use
strict
'
;
var
emberHooks
=
_emberMetalAssign
.
default
(
{
}
_htmlbarsRuntime
.
hooks
)
;
emberHooks
.
keywords
=
_emberHtmlbarsKeywords
.
default
;
_emberMetalAssign
.
default
(
emberHooks
{
linkRenderNode
:
_emberHtmlbarsHooksLinkRenderNode
.
default
createFreshScope
:
_emberHtmlbarsHooksCreateFreshScope
.
default
createChildScope
:
_emberHtmlbarsHooksCreateFreshScope
.
createChildScope
bindShadowScope
:
_emberHtmlbarsHooksBindShadowScope
.
default
bindSelf
:
_emberHtmlbarsHooksBindSelf
.
default
bindScope
:
_emberHtmlbarsHooksBindScope
.
default
bindLocal
:
_emberHtmlbarsHooksBindLocal
.
default
bindBlock
:
_emberHtmlbarsHooksBindBlock
.
default
updateSelf
:
_emberHtmlbarsHooksUpdateSelf
.
default
getBlock
:
_emberHtmlbarsHooksGetBlock
.
default
getRoot
:
_emberHtmlbarsHooksGetRoot
.
default
getChild
:
_emberHtmlbarsHooksGetChild
.
default
getValue
:
_emberHtmlbarsHooksGetValue
.
default
getCellOrValue
:
_emberHtmlbarsHooksGetCellOrValue
.
default
subexpr
:
_emberHtmlbarsHooksSubexpr
.
default
concat
:
_emberHtmlbarsHooksConcat
.
default
cleanupRenderNode
:
_emberHtmlbarsHooksCleanupRenderNode
.
default
destroyRenderNode
:
_emberHtmlbarsHooksDestroyRenderNode
.
default
willCleanupTree
:
_emberHtmlbarsHooksWillCleanupTree
.
default
didCleanupTree
:
_emberHtmlbarsHooksDidCleanupTree
.
default
didRenderNode
:
_emberHtmlbarsHooksDidRenderNode
.
default
classify
:
_emberHtmlbarsHooksClassify
.
default
component
:
_emberHtmlbarsHooksComponent
.
default
lookupHelper
:
_emberHtmlbarsHooksLookupHelper
.
default
hasHelper
:
_emberHtmlbarsHooksHasHelper
.
default
invokeHelper
:
_emberHtmlbarsHooksInvokeHelper
.
default
element
:
_emberHtmlbarsHooksElement
.
default
}
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
debugger
'
_emberHtmlbarsKeywordsDebugger
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
with
'
_emberHtmlbarsKeywordsWith
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
outlet
'
_emberHtmlbarsKeywordsOutlet
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
unbound
'
_emberHtmlbarsKeywordsUnbound
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
component
'
_emberHtmlbarsKeywordsComponent
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
element_component
'
_emberHtmlbarsKeywordsElementComponent
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
partial
'
_emberHtmlbarsKeywordsPartial
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
input
'
_emberHtmlbarsKeywordsInput
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
textarea
'
_emberHtmlbarsKeywordsTextarea
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
yield
'
_emberHtmlbarsKeywordsYield
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
mut
'
_emberHtmlbarsKeywordsMut
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
mut
'
_emberHtmlbarsKeywordsMut
.
privateMut
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
readonly
'
_emberHtmlbarsKeywordsReadonly
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
get
'
_emberHtmlbarsKeywordsGet
.
default
)
;
if
(
_emberMetal
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
)
{
_emberHtmlbarsKeywords
.
registerKeyword
(
'
view
'
_emberHtmlbarsKeywordsView
.
default
)
;
}
exports
.
default
=
{
hooks
:
emberHooks
helpers
:
_emberHtmlbarsHelpers
.
default
useFragmentCache
:
true
}
;
var
domHelper
=
_emberMetalEnvironment
.
default
.
hasDOM
?
new
_emberHtmlbarsSystemDomHelper
.
default
(
)
:
null
;
exports
.
domHelper
=
domHelper
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
glimmer
-
component
'
[
'
exports
'
'
ember
-
views
/
views
/
core_view
'
'
ember
-
views
/
mixins
/
view_child_views_support
'
'
ember
-
views
/
mixins
/
view_state_support
'
'
ember
-
views
/
mixins
/
template_rendering_support
'
'
ember
-
views
/
mixins
/
class_names_support
'
'
ember
-
views
/
mixins
/
instrumentation_support
'
'
ember
-
views
/
mixins
/
aria_role_support
'
'
ember
-
views
/
mixins
/
view_support
'
'
ember
-
views
/
views
/
view
'
]
function
(
exports
_emberViewsViewsCore_view
_emberViewsMixinsView_child_views_support
_emberViewsMixinsView_state_support
_emberViewsMixinsTemplate_rendering_support
_emberViewsMixinsClass_names_support
_emberViewsMixinsInstrumentation_support
_emberViewsMixinsAria_role_support
_emberViewsMixinsView_support
_emberViewsViewsView
)
{
'
use
strict
'
;
exports
.
default
=
_emberViewsViewsCore_view
.
default
.
extend
(
_emberViewsMixinsView_child_views_support
.
default
_emberViewsMixinsView_state_support
.
default
_emberViewsMixinsTemplate_rendering_support
.
default
_emberViewsMixinsClass_names_support
.
default
_emberViewsMixinsInstrumentation_support
.
default
_emberViewsMixinsAria_role_support
.
default
_emberViewsMixinsView_support
.
default
{
isComponent
:
true
isGlimmerComponent
:
true
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_viewRegistry
=
this
.
_viewRegistry
|
|
_emberViewsViewsView
.
default
.
views
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
helper
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
exports
.
helper
=
helper
;
var
Helper
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
isHelperInstance
:
true
recompute
:
function
(
)
{
this
.
_stream
.
notify
(
)
;
}
}
)
;
Helper
.
reopenClass
(
{
isHelperFactory
:
true
}
)
;
function
helper
(
helperFn
)
{
return
{
isHelperInstance
:
true
compute
:
helperFn
}
;
}
exports
.
default
=
Helper
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
'
[
'
exports
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalEmpty_object
)
{
'
use
strict
'
;
exports
.
registerHelper
=
registerHelper
;
var
helpers
=
new
_emberMetalEmpty_object
.
default
(
)
;
function
registerHelper
(
name
helperFunc
)
{
helpers
[
name
]
=
helperFunc
;
}
exports
.
default
=
helpers
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
-
html
-
safe
'
[
'
exports
'
'
htmlbars
-
util
/
safe
-
string
'
]
function
(
exports
_htmlbarsUtilSafeString
)
{
'
use
strict
'
;
exports
.
default
=
htmlSafeHelper
;
function
htmlSafeHelper
(
_ref
)
{
var
value
=
_ref
[
0
]
;
return
new
_htmlbarsUtilSafeString
.
default
(
value
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
-
join
-
classes
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
joinClasses
;
function
joinClasses
(
classNames
)
{
var
result
=
[
]
;
for
(
var
i
=
0
l
=
classNames
.
length
;
i
<
l
;
i
+
+
)
{
var
className
=
classNames
[
i
]
;
if
(
className
)
{
result
.
push
(
className
)
;
}
}
return
result
.
join
(
'
'
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
-
normalize
-
class
'
[
'
exports
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
metal
/
path_cache
'
]
function
(
exports
_emberRuntimeSystemString
_emberMetalPath_cache
)
{
'
use
strict
'
;
exports
.
default
=
normalizeClass
;
function
normalizeClass
(
params
hash
)
{
var
propName
=
params
[
0
]
;
var
value
=
params
[
1
]
;
var
activeClass
=
hash
.
activeClass
;
var
inactiveClass
=
hash
.
inactiveClass
;
if
(
activeClass
|
|
inactiveClass
)
{
if
(
!
!
value
)
{
return
activeClass
;
}
else
{
return
inactiveClass
;
}
}
else
if
(
value
=
=
=
true
)
{
if
(
propName
&
&
_emberMetalPath_cache
.
isPath
(
propName
)
)
{
var
segments
=
propName
.
split
(
'
.
'
)
;
propName
=
segments
[
segments
.
length
-
1
]
;
}
return
_emberRuntimeSystemString
.
dasherize
(
propName
)
;
}
else
if
(
value
!
=
=
false
&
&
value
!
=
null
)
{
return
value
;
}
else
{
return
null
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
concat
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
concat
;
function
concat
(
params
)
{
return
params
.
join
(
'
'
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
each
-
in
'
[
'
exports
'
'
ember
-
views
/
streams
/
should_display
'
]
function
(
exports
_emberViewsStreamsShould_display
)
{
'
use
strict
'
;
var
eachInHelper
=
function
(
_ref
hash
blocks
)
{
var
object
=
_ref
[
0
]
;
var
objKeys
prop
i
;
objKeys
=
object
?
Object
.
keys
(
object
)
:
[
]
;
if
(
_emberViewsStreamsShould_display
.
default
(
objKeys
)
)
{
for
(
i
=
0
;
i
<
objKeys
.
length
;
i
+
+
)
{
prop
=
objKeys
[
i
]
;
blocks
.
template
.
yieldItem
(
prop
[
prop
object
[
prop
]
]
)
;
}
}
else
if
(
blocks
.
inverse
.
yield
)
{
blocks
.
inverse
.
yield
(
)
;
}
}
;
exports
.
default
=
eachInHelper
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
each
'
[
'
exports
'
'
ember
-
views
/
streams
/
should_display
'
'
ember
-
htmlbars
/
utils
/
decode
-
each
-
key
'
]
function
(
exports
_emberViewsStreamsShould_display
_emberHtmlbarsUtilsDecodeEachKey
)
{
'
use
strict
'
;
exports
.
default
=
eachHelper
;
function
eachHelper
(
params
hash
blocks
)
{
var
list
=
params
[
0
]
;
var
keyPath
=
hash
.
key
;
if
(
_emberViewsStreamsShould_display
.
default
(
list
)
)
{
forEach
(
list
function
(
item
i
)
{
var
key
=
_emberHtmlbarsUtilsDecodeEachKey
.
default
(
item
keyPath
i
)
;
blocks
.
template
.
yieldItem
(
key
[
item
i
]
)
;
}
)
;
}
else
if
(
blocks
.
inverse
.
yield
)
{
blocks
.
inverse
.
yield
(
)
;
}
}
function
forEach
(
iterable
cb
)
{
return
iterable
.
forEach
?
iterable
.
forEach
(
cb
)
:
Array
.
prototype
.
forEach
.
call
(
iterable
cb
)
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
helpers
/
hash
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
hashHelper
;
function
hashHelper
(
params
hash
options
)
{
return
hash
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
if_unless
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
views
/
streams
/
should_display
'
]
function
(
exports
_emberMetalDebug
_emberViewsStreamsShould_display
)
{
'
use
strict
'
;
function
ifHelper
(
params
hash
options
)
{
return
ifUnless
(
params
hash
options
_emberViewsStreamsShould_display
.
default
(
params
[
0
]
)
)
;
}
function
unlessHelper
(
params
hash
options
)
{
return
ifUnless
(
params
hash
options
!
_emberViewsStreamsShould_display
.
default
(
params
[
0
]
)
)
;
}
function
ifUnless
(
params
hash
options
truthy
)
{
_emberMetalDebug
.
assert
(
'
The
block
form
of
the
if
and
unless
helpers
expect
exactly
one
'
+
'
argument
e
.
g
.
{
{
#
if
newMessages
}
}
You
have
new
messages
.
{
{
/
if
}
}
.
'
!
options
.
template
.
yield
|
|
params
.
length
=
=
=
1
)
;
_emberMetalDebug
.
assert
(
'
The
inline
form
of
the
if
and
unless
helpers
expect
two
or
'
+
'
three
arguments
e
.
g
.
{
{
if
trialExpired
\
'
Expired
\
'
expiryDate
}
}
'
+
'
or
{
{
unless
isFirstLogin
\
'
Welcome
back
!
\
'
}
}
.
'
!
!
options
.
template
.
yield
|
|
params
.
length
=
=
=
2
|
|
params
.
length
=
=
=
3
)
;
if
(
truthy
)
{
if
(
options
.
template
.
yield
)
{
options
.
template
.
yield
(
)
;
}
else
{
return
params
[
1
]
;
}
}
else
{
if
(
options
.
inverse
.
yield
)
{
options
.
inverse
.
yield
(
)
;
}
else
{
return
params
[
2
]
;
}
}
}
exports
.
ifHelper
=
ifHelper
;
exports
.
unlessHelper
=
unlessHelper
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
loc
'
[
'
exports
'
'
ember
-
htmlbars
/
helper
'
'
ember
-
runtime
/
system
/
string
'
]
function
(
exports
_emberHtmlbarsHelper
_emberRuntimeSystemString
)
{
'
use
strict
'
;
function
locHelper
(
params
)
{
return
_emberRuntimeSystemString
.
loc
.
apply
(
null
params
)
;
}
exports
.
default
=
_emberHtmlbarsHelper
.
helper
(
locHelper
)
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
log
'
[
'
exports
'
'
ember
-
metal
/
logger
'
]
function
(
exports
_emberMetalLogger
)
{
'
use
strict
'
;
exports
.
default
=
logHelper
;
function
logHelper
(
values
)
{
_emberMetalLogger
.
default
.
log
.
apply
(
null
values
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
helpers
/
with
'
[
'
exports
'
'
ember
-
views
/
streams
/
should_display
'
]
function
(
exports
_emberViewsStreamsShould_display
)
{
'
use
strict
'
;
exports
.
default
=
withHelper
;
function
withHelper
(
params
hash
options
)
{
if
(
_emberViewsStreamsShould_display
.
default
(
params
[
0
]
)
)
{
options
.
template
.
yield
(
[
params
[
0
]
]
)
;
}
else
if
(
options
.
inverse
&
&
options
.
inverse
.
yield
)
{
options
.
inverse
.
yield
(
[
]
)
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
bind
-
block
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
bindBlock
;
function
bindBlock
(
env
scope
block
)
{
var
name
=
arguments
.
length
<
=
3
|
|
arguments
[
3
]
=
=
=
undefined
?
'
default
'
:
arguments
[
3
]
;
scope
.
bindBlock
(
name
block
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
bind
-
local
'
[
'
exports
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
]
function
(
exports
_emberMetalStreamsStream
_emberMetalStreamsProxyStream
)
{
'
use
strict
'
;
exports
.
default
=
bindLocal
;
function
bindLocal
(
env
scope
key
value
)
{
if
(
scope
.
hasOwnLocal
(
key
)
)
{
var
existing
=
scope
.
getLocal
(
key
)
;
if
(
existing
!
=
=
value
)
{
existing
.
setSource
(
value
)
;
}
}
else
{
var
newValue
=
_emberMetalStreamsStream
.
wrap
(
value
_emberMetalStreamsProxyStream
.
default
key
)
;
scope
.
bindLocal
(
key
newValue
)
;
}
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
bind
-
scope
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
bindScope
;
function
bindScope
(
env
scope
)
{
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
bind
-
self
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
]
function
(
exports
_emberMetal
_emberMetalStreamsProxyStream
)
{
'
use
strict
'
;
exports
.
default
=
bindSelf
;
function
bindSelf
(
env
scope
self
)
{
if
(
self
&
&
self
.
isView
)
{
if
(
!
!
_emberMetal
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
)
{
scope
.
bindLocal
(
'
view
'
newStream
(
self
'
view
'
)
)
;
}
var
_selfStream
=
newStream
(
self
'
'
)
;
if
(
self
.
isGlimmerComponent
)
{
scope
.
bindSelf
(
_selfStream
)
;
}
else
{
scope
.
bindSelf
(
newStream
(
_selfStream
.
getKey
(
'
context
'
)
'
'
)
)
;
}
return
;
}
var
selfStream
=
newStream
(
self
'
'
)
;
scope
.
bindSelf
(
selfStream
)
;
}
function
newStream
(
newValue
key
)
{
return
new
_emberMetalStreamsProxyStream
.
default
(
newValue
key
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
bind
-
shadow
-
scope
'
[
'
exports
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
]
function
(
exports
_emberMetalStreamsProxyStream
)
{
'
use
strict
'
;
exports
.
default
=
bindShadowScope
;
function
bindShadowScope
(
env
parentScope
shadowScope
options
)
{
if
(
!
options
)
{
return
;
}
var
view
=
options
.
view
;
if
(
view
&
&
!
view
.
isComponent
)
{
shadowScope
.
bindLocal
(
'
view
'
newStream
(
view
'
view
'
)
)
;
if
(
view
.
isView
)
{
shadowScope
.
bindSelf
(
newStream
(
shadowScope
.
getLocal
(
'
view
'
)
.
getKey
(
'
context
'
)
'
'
)
)
;
}
}
shadowScope
.
bindView
(
view
)
;
if
(
view
&
&
options
.
attrs
)
{
shadowScope
.
bindComponent
(
view
)
;
}
if
(
'
attrs
'
in
options
)
{
shadowScope
.
bindAttrs
(
options
.
attrs
)
;
}
return
shadowScope
;
}
function
newStream
(
newValue
key
)
{
return
new
_emberMetalStreamsProxyStream
.
default
(
newValue
key
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
classify
'
[
'
exports
'
'
ember
-
htmlbars
/
utils
/
is
-
component
'
]
function
(
exports
_emberHtmlbarsUtilsIsComponent
)
{
'
use
strict
'
;
exports
.
default
=
classify
;
function
classify
(
env
scope
path
)
{
if
(
_emberHtmlbarsUtilsIsComponent
.
default
(
env
scope
path
)
)
{
return
'
component
'
;
}
return
null
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
cleanup
-
render
-
node
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
cleanupRenderNode
;
function
cleanupRenderNode
(
renderNode
)
{
if
(
renderNode
.
cleanup
)
{
renderNode
.
cleanup
(
)
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
component
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
debug
'
'
ember
-
htmlbars
/
node
-
managers
/
component
-
node
-
manager
'
'
ember
-
views
/
system
/
build
-
component
-
template
'
'
ember
-
htmlbars
/
utils
/
lookup
-
component
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
cache
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
'
ember
-
htmlbars
/
utils
/
extract
-
positional
-
params
'
'
ember
-
htmlbars
/
keywords
/
closure
-
component
'
]
function
(
exports
_emberMetalFeatures
_emberMetalDebug
_emberHtmlbarsNodeManagersComponentNodeManager
_emberViewsSystemBuildComponentTemplate
_emberHtmlbarsUtilsLookupComponent
_emberMetalAssign
_emberMetalEmpty_object
_emberMetalCache
_emberHtmlbarsSystemLookupHelper
_emberHtmlbarsUtilsExtractPositionalParams
_emberHtmlbarsKeywordsClosureComponent
)
{
'
use
strict
'
;
exports
.
default
=
componentHook
;
var
IS_ANGLE_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
key
.
match
(
/
^
(
?
)
<
(
.
*
)
>
/
)
;
}
)
;
function
componentHook
(
renderNode
env
scope
_tagName
params
attrs
templates
visitor
)
{
var
state
=
renderNode
.
getState
(
)
;
var
tagName
=
_tagName
;
if
(
_emberHtmlbarsSystemLookupHelper
.
CONTAINS_DOT_CACHE
.
get
(
tagName
)
)
{
var
stream
=
env
.
hooks
.
get
(
env
scope
tagName
)
;
var
componentCell
=
stream
.
value
(
)
;
if
(
_emberHtmlbarsKeywordsClosureComponent
.
isComponentCell
(
componentCell
)
)
{
tagName
=
componentCell
[
_emberHtmlbarsKeywordsClosureComponent
.
COMPONENT_PATH
]
;
var
newAttrs
=
_emberMetalAssign
.
default
(
new
_emberMetalEmpty_object
.
default
(
)
attrs
)
;
_emberHtmlbarsKeywordsClosureComponent
.
processPositionalParamsFromCell
(
componentCell
params
newAttrs
)
;
params
=
[
]
;
attrs
=
_emberHtmlbarsKeywordsClosureComponent
.
mergeInNewHash
(
componentCell
[
_emberHtmlbarsKeywordsClosureComponent
.
COMPONENT_HASH
]
newAttrs
)
;
}
}
if
(
state
.
manager
)
{
var
sm
=
state
.
manager
;
var
templateMeta
=
null
;
if
(
sm
.
block
)
{
templateMeta
=
sm
.
block
.
template
.
meta
;
}
else
if
(
sm
.
scope
&
&
sm
.
scope
.
_view
)
{
templateMeta
=
sm
.
scope
.
_view
.
template
.
meta
;
}
env
.
meta
.
moduleName
=
templateMeta
&
&
templateMeta
.
moduleName
|
|
env
.
meta
&
&
env
.
meta
.
moduleName
;
_emberHtmlbarsUtilsExtractPositionalParams
.
default
(
renderNode
sm
.
component
.
constructor
params
attrs
false
)
;
state
.
manager
.
rerender
(
env
attrs
visitor
)
;
return
;
}
var
isAngleBracket
=
false
;
var
isTopLevel
=
false
;
var
isDasherized
=
false
;
var
angles
=
IS_ANGLE_CACHE
.
get
(
tagName
)
;
if
(
angles
)
{
tagName
=
angles
[
2
]
;
isAngleBracket
=
true
;
isTopLevel
=
!
!
angles
[
1
]
;
}
if
(
_emberHtmlbarsSystemLookupHelper
.
CONTAINS_DASH_CACHE
.
get
(
tagName
)
)
{
isDasherized
=
true
;
}
var
parentView
=
env
.
view
;
var
currentComponent
=
env
.
view
;
var
isInvokedWithAngles
=
currentComponent
&
&
currentComponent
.
_isAngleBracket
;
var
isInvokedWithCurlies
=
currentComponent
&
&
!
currentComponent
.
_isAngleBracket
;
var
isComponentHTMLElement
=
isAngleBracket
&
&
!
isDasherized
&
&
isInvokedWithAngles
;
var
isComponentIdentityElement
=
isAngleBracket
&
&
isTopLevel
&
&
tagName
=
=
=
env
.
view
.
tagName
;
var
isNormalHTMLElement
=
isAngleBracket
&
&
!
isDasherized
&
&
isInvokedWithCurlies
;
var
component
=
undefined
layout
=
undefined
;
if
(
isDasherized
|
|
!
isAngleBracket
)
{
var
options
=
{
}
;
var
moduleName
=
env
.
meta
&
&
env
.
meta
.
moduleName
;
if
(
moduleName
)
{
options
.
source
=
'
template
:
'
+
moduleName
;
}
var
result
=
_emberHtmlbarsUtilsLookupComponent
.
default
(
env
.
owner
tagName
options
)
;
component
=
result
.
component
;
layout
=
result
.
layout
;
if
(
isAngleBracket
&
&
isDasherized
&
&
!
component
&
&
!
layout
)
{
isComponentHTMLElement
=
true
;
}
else
{
_emberMetalDebug
.
assert
(
'
HTMLBars
error
:
Could
not
find
component
named
"
'
+
tagName
+
'
"
(
no
component
or
template
with
that
name
was
found
)
'
!
!
(
component
|
|
layout
)
)
;
}
}
if
(
isComponentIdentityElement
|
|
isComponentHTMLElement
)
{
var
templateOptions
=
{
component
:
currentComponent
tagName
:
tagName
isAngleBracket
:
true
isComponentElement
:
true
outerAttrs
:
scope
.
getAttrs
(
)
parentScope
:
scope
}
;
var
contentOptions
=
{
templates
:
templates
scope
:
scope
}
;
var
_buildComponentTemplate
=
_emberViewsSystemBuildComponentTemplate
.
default
(
templateOptions
attrs
contentOptions
)
;
var
block
=
_buildComponentTemplate
.
block
;
block
.
invoke
(
env
[
]
undefined
renderNode
scope
visitor
)
;
}
else
if
(
isNormalHTMLElement
)
{
var
block
=
_emberViewsSystemBuildComponentTemplate
.
buildHTMLTemplate
(
tagName
attrs
{
templates
:
templates
scope
:
scope
}
)
;
block
.
invoke
(
env
[
]
undefined
renderNode
scope
visitor
)
;
}
else
{
var
manager
=
_emberHtmlbarsNodeManagersComponentNodeManager
.
default
.
create
(
renderNode
env
{
tagName
:
tagName
params
:
params
attrs
:
attrs
parentView
:
parentView
templates
:
templates
isAngleBracket
:
isAngleBracket
isTopLevel
:
isTopLevel
component
:
component
layout
:
layout
parentScope
:
scope
}
)
;
state
.
manager
=
manager
;
manager
.
render
(
env
visitor
)
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
concat
'
[
'
exports
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
concat
;
function
concat
(
env
parts
)
{
return
_emberMetalStreamsUtils
.
concat
(
parts
'
'
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
create
-
fresh
-
scope
'
[
'
exports
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalStreamsProxyStream
_emberMetalEmpty_object
)
{
'
use
strict
'
;
exports
.
default
=
createFreshScope
;
exports
.
createChildScope
=
createChildScope
;
function
Scope
(
parent
)
{
this
.
_self
=
undefined
;
this
.
_blocks
=
undefined
;
this
.
_component
=
undefined
;
this
.
_view
=
undefined
;
this
.
_attrs
=
undefined
;
this
.
_locals
=
undefined
;
this
.
_localPresent
=
undefined
;
this
.
overrideController
=
undefined
;
this
.
parent
=
parent
;
}
var
proto
=
Scope
.
prototype
;
proto
.
getSelf
=
function
(
)
{
return
this
.
_self
|
|
this
.
parent
.
getSelf
(
)
;
}
;
proto
.
bindSelf
=
function
(
self
)
{
this
.
_self
=
self
;
}
;
proto
.
updateSelf
=
function
(
self
key
)
{
var
existing
=
this
.
_self
;
if
(
existing
)
{
existing
.
setSource
(
self
)
;
}
else
{
this
.
_self
=
new
_emberMetalStreamsProxyStream
.
default
(
self
key
)
;
}
}
;
proto
.
getBlock
=
function
(
name
)
{
if
(
!
this
.
_blocks
)
{
return
this
.
parent
.
getBlock
(
name
)
;
}
return
this
.
_blocks
[
name
]
|
|
this
.
parent
.
getBlock
(
name
)
;
}
;
proto
.
hasBlock
=
function
(
name
)
{
if
(
!
this
.
_blocks
)
{
return
this
.
parent
.
hasBlock
(
name
)
;
}
return
!
!
(
this
.
_blocks
[
name
]
|
|
this
.
parent
.
hasBlock
(
name
)
)
;
}
;
proto
.
bindBlock
=
function
(
name
block
)
{
if
(
!
this
.
_blocks
)
{
this
.
_blocks
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
this
.
_blocks
[
name
]
=
block
;
}
;
proto
.
getComponent
=
function
(
)
{
return
this
.
_component
|
|
this
.
parent
.
getComponent
(
)
;
}
;
proto
.
bindComponent
=
function
(
component
)
{
this
.
_component
=
component
;
}
;
proto
.
getView
=
function
(
)
{
return
this
.
_view
|
|
this
.
parent
.
getView
(
)
;
}
;
proto
.
bindView
=
function
(
view
)
{
this
.
_view
=
view
;
}
;
proto
.
getAttrs
=
function
(
)
{
return
this
.
_attrs
|
|
this
.
parent
.
getAttrs
(
)
;
}
;
proto
.
bindAttrs
=
function
(
attrs
)
{
this
.
_attrs
=
attrs
;
}
;
proto
.
hasLocal
=
function
(
name
)
{
if
(
!
this
.
_localPresent
)
{
return
this
.
parent
.
hasLocal
(
name
)
;
}
return
this
.
_localPresent
[
name
]
|
|
this
.
parent
.
hasLocal
(
name
)
;
}
;
proto
.
hasOwnLocal
=
function
(
name
)
{
return
this
.
_localPresent
&
&
this
.
_localPresent
[
name
]
;
}
;
proto
.
getLocal
=
function
(
name
)
{
if
(
!
this
.
_localPresent
)
{
return
this
.
parent
.
getLocal
(
name
)
;
}
return
this
.
_localPresent
[
name
]
?
this
.
_locals
[
name
]
:
this
.
parent
.
getLocal
(
name
)
;
}
;
proto
.
bindLocal
=
function
(
name
value
)
{
if
(
!
this
.
_localPresent
)
{
this
.
_localPresent
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
_locals
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
this
.
_localPresent
[
name
]
=
true
;
this
.
_locals
[
name
]
=
value
;
}
;
var
EMPTY
=
{
_self
:
undefined
_blocks
:
undefined
_component
:
undefined
_view
:
undefined
_attrs
:
undefined
_locals
:
undefined
_localPresent
:
undefined
overrideController
:
undefined
getSelf
:
function
(
)
{
return
null
;
}
bindSelf
:
function
(
self
)
{
return
null
;
}
updateSelf
:
function
(
self
key
)
{
return
null
;
}
getBlock
:
function
(
name
)
{
return
null
;
}
bindBlock
:
function
(
name
block
)
{
return
null
;
}
hasBlock
:
function
(
name
)
{
return
false
;
}
getComponent
:
function
(
)
{
return
null
;
}
bindComponent
:
function
(
)
{
return
null
;
}
getView
:
function
(
)
{
return
null
;
}
bindView
:
function
(
view
)
{
return
null
;
}
getAttrs
:
function
(
)
{
return
null
;
}
bindAttrs
:
function
(
attrs
)
{
return
null
;
}
hasLocal
:
function
(
name
)
{
return
false
;
}
hasOwnLocal
:
function
(
name
)
{
return
false
;
}
getLocal
:
function
(
name
)
{
return
null
;
}
bindLocal
:
function
(
name
value
)
{
return
null
;
}
}
;
function
createFreshScope
(
)
{
return
new
Scope
(
EMPTY
)
;
}
function
createChildScope
(
parent
)
{
return
new
Scope
(
parent
)
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
destroy
-
render
-
node
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
destroyRenderNode
;
function
destroyRenderNode
(
renderNode
)
{
if
(
renderNode
.
emberView
)
{
renderNode
.
emberView
.
destroy
(
)
;
}
var
streamUnsubscribers
=
renderNode
.
streamUnsubscribers
;
if
(
streamUnsubscribers
)
{
for
(
var
i
=
0
l
=
streamUnsubscribers
.
length
;
i
<
l
;
i
+
+
)
{
streamUnsubscribers
[
i
]
(
)
;
}
}
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
did
-
cleanup
-
tree
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
didCleanupTree
;
function
didCleanupTree
(
env
)
{
env
.
view
.
ownerView
.
_destroyingSubtreeForView
=
null
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
did
-
render
-
node
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
didRenderNode
;
function
didRenderNode
(
morph
env
)
{
env
.
renderedNodes
.
add
(
morph
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
element
'
[
'
exports
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
'
htmlbars
-
runtime
/
hooks
'
'
ember
-
htmlbars
/
system
/
invoke
-
helper
'
]
function
(
exports
_emberHtmlbarsSystemLookupHelper
_htmlbarsRuntimeHooks
_emberHtmlbarsSystemInvokeHelper
)
{
'
use
strict
'
;
exports
.
default
=
emberElement
;
function
emberElement
(
morph
env
scope
path
params
hash
visitor
)
{
if
(
_htmlbarsRuntimeHooks
.
handleRedirect
(
morph
env
scope
path
params
hash
null
null
visitor
)
)
{
return
;
}
var
result
;
var
helper
=
_emberHtmlbarsSystemLookupHelper
.
findHelper
(
path
scope
.
getSelf
(
)
env
)
;
if
(
helper
)
{
var
helperStream
=
_emberHtmlbarsSystemInvokeHelper
.
buildHelperStream
(
helper
params
hash
{
element
:
morph
.
element
}
env
scope
path
)
;
result
=
helperStream
.
value
(
)
;
}
else
{
result
=
env
.
hooks
.
get
(
env
scope
path
)
;
}
env
.
hooks
.
getValue
(
result
)
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
get
-
block
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
getBlock
;
function
getBlock
(
scope
key
)
{
return
scope
.
getBlock
(
key
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
get
-
cell
-
or
-
value
'
[
'
exports
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
htmlbars
/
keywords
/
mut
'
]
function
(
exports
_emberMetalStreamsUtils
_emberHtmlbarsKeywordsMut
)
{
'
use
strict
'
;
exports
.
default
=
getCellOrValue
;
function
getCellOrValue
(
ref
)
{
if
(
ref
&
&
ref
[
_emberHtmlbarsKeywordsMut
.
MUTABLE_REFERENCE
]
)
{
return
ref
.
cell
(
)
;
}
return
_emberMetalStreamsUtils
.
read
(
ref
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
get
-
child
'
[
'
exports
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
getChild
;
function
getChild
(
parent
key
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
parent
)
)
{
return
parent
.
getKey
(
key
)
;
}
return
parent
[
key
]
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
get
-
root
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
getRoot
;
function
getRoot
(
scope
key
)
{
if
(
key
=
=
=
'
this
'
)
{
return
[
scope
.
getSelf
(
)
]
;
}
else
if
(
key
=
=
=
'
hasBlock
'
)
{
return
[
!
!
scope
.
hasBlock
(
'
default
'
)
]
;
}
else
if
(
key
=
=
=
'
hasBlockParams
'
)
{
var
block
=
scope
.
getBlock
(
'
default
'
)
;
return
[
!
!
block
&
&
block
.
arity
]
;
}
else
if
(
scope
.
hasLocal
(
key
)
)
{
return
[
scope
.
getLocal
(
key
)
]
;
}
else
{
return
[
getKey
(
scope
key
)
]
;
}
}
function
getKey
(
scope
key
)
{
if
(
key
=
=
=
'
attrs
'
)
{
var
_attrs
=
scope
.
getAttrs
(
)
;
if
(
_attrs
)
{
return
_attrs
;
}
}
var
self
=
scope
.
getSelf
(
)
|
|
scope
.
getLocal
(
'
view
'
)
;
if
(
self
)
{
return
self
.
getKey
(
key
)
;
}
var
attrs
=
scope
.
getAttrs
(
)
;
if
(
attrs
&
&
key
in
attrs
)
{
return
attrs
[
key
]
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
get
-
value
'
[
'
exports
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
]
function
(
exports
_emberMetalStreamsUtils
_emberViewsCompatAttrsProxy
)
{
'
use
strict
'
;
exports
.
default
=
getValue
;
function
getValue
(
ref
)
{
var
value
=
_emberMetalStreamsUtils
.
read
(
ref
)
;
if
(
value
&
&
value
[
_emberViewsCompatAttrsProxy
.
MUTABLE_CELL
]
)
{
return
value
.
value
;
}
return
value
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
has
-
helper
'
[
'
exports
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
]
function
(
exports
_emberHtmlbarsSystemLookupHelper
)
{
'
use
strict
'
;
exports
.
default
=
hasHelperHook
;
function
hasHelperHook
(
env
scope
helperName
)
{
if
(
env
.
helpers
[
helperName
]
)
{
return
true
;
}
var
owner
=
env
.
owner
;
if
(
_emberHtmlbarsSystemLookupHelper
.
validateLazyHelperName
(
helperName
owner
env
.
hooks
.
keywords
)
)
{
var
registrationName
=
'
helper
:
'
+
helperName
;
if
(
owner
.
hasRegistration
(
registrationName
)
)
{
return
true
;
}
var
options
=
{
}
;
var
moduleName
=
env
.
meta
&
&
env
.
meta
.
moduleName
;
if
(
moduleName
)
{
options
.
source
=
'
template
:
'
+
moduleName
;
}
if
(
owner
.
hasRegistration
(
registrationName
options
)
)
{
return
true
;
}
}
return
false
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
invoke
-
helper
'
[
'
exports
'
'
ember
-
htmlbars
/
system
/
invoke
-
helper
'
'
ember
-
htmlbars
/
utils
/
subscribe
'
]
function
(
exports
_emberHtmlbarsSystemInvokeHelper
_emberHtmlbarsUtilsSubscribe
)
{
'
use
strict
'
;
exports
.
default
=
invokeHelper
;
function
invokeHelper
(
morph
env
scope
visitor
params
hash
helper
templates
context
)
{
var
helperStream
=
_emberHtmlbarsSystemInvokeHelper
.
buildHelperStream
(
helper
params
hash
templates
env
scope
)
;
if
(
helperStream
.
linkable
)
{
if
(
morph
)
{
var
addedDependency
=
false
;
for
(
var
i
=
0
l
=
params
.
length
;
i
<
l
;
i
+
+
)
{
addedDependency
=
true
;
helperStream
.
addDependency
(
params
[
i
]
)
;
}
for
(
var
key
in
hash
)
{
addedDependency
=
true
;
helperStream
.
addDependency
(
hash
[
key
]
)
;
}
if
(
addedDependency
)
{
_emberHtmlbarsUtilsSubscribe
.
default
(
morph
env
scope
helperStream
)
;
}
}
return
{
link
:
true
value
:
helperStream
}
;
}
return
{
value
:
helperStream
.
value
(
)
}
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
link
-
render
-
node
'
[
'
exports
'
'
ember
-
htmlbars
/
utils
/
subscribe
'
'
ember
-
runtime
/
utils
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
'
ember
-
htmlbars
/
keywords
/
closure
-
component
'
]
function
(
exports
_emberHtmlbarsUtilsSubscribe
_emberRuntimeUtils
_emberMetalStreamsUtils
_emberHtmlbarsSystemLookupHelper
_emberHtmlbarsKeywordsClosureComponent
)
{
'
use
strict
'
;
exports
.
default
=
linkRenderNode
;
exports
.
linkParamsFor
=
linkParamsFor
;
function
linkRenderNode
(
renderNode
env
scope
path
params
hash
)
{
if
(
renderNode
.
streamUnsubscribers
)
{
return
true
;
}
var
keyword
=
env
.
hooks
.
keywords
[
path
]
;
if
(
keyword
&
&
keyword
.
link
)
{
keyword
.
link
(
renderNode
.
getState
(
)
params
hash
)
;
}
else
if
(
path
=
=
=
'
unbound
'
)
{
return
true
;
}
else
{
linkParamsFor
(
path
params
)
;
}
if
(
_emberHtmlbarsSystemLookupHelper
.
CONTAINS_DOT_CACHE
.
get
(
path
)
)
{
var
stream
=
env
.
hooks
.
get
(
env
scope
path
)
;
var
componentCell
=
stream
.
value
(
)
;
if
(
_emberHtmlbarsKeywordsClosureComponent
.
isComponentCell
(
componentCell
)
)
{
var
closureAttrs
=
_emberHtmlbarsKeywordsClosureComponent
.
mergeInNewHash
(
componentCell
[
_emberHtmlbarsKeywordsClosureComponent
.
COMPONENT_HASH
]
hash
)
;
for
(
var
key
in
closureAttrs
)
{
_emberHtmlbarsUtilsSubscribe
.
default
(
renderNode
env
scope
closureAttrs
[
key
]
)
;
}
}
}
if
(
params
&
&
params
.
length
)
{
for
(
var
i
=
0
;
i
<
params
.
length
;
i
+
+
)
{
_emberHtmlbarsUtilsSubscribe
.
default
(
renderNode
env
scope
params
[
i
]
)
;
}
}
if
(
hash
)
{
for
(
var
key
in
hash
)
{
_emberHtmlbarsUtilsSubscribe
.
default
(
renderNode
env
scope
hash
[
key
]
)
;
}
}
return
true
;
}
function
linkParamsFor
(
path
params
)
{
switch
(
path
)
{
case
'
unless
'
:
case
'
if
'
:
params
[
0
]
=
shouldDisplay
(
params
[
0
]
toBool
)
;
break
;
case
'
each
'
:
params
[
0
]
=
eachParam
(
params
[
0
]
)
;
break
;
case
'
with
'
:
params
[
0
]
=
shouldDisplay
(
params
[
0
]
identity
)
;
break
;
}
}
function
eachParam
(
list
)
{
var
listChange
=
getKey
(
list
'
[
]
'
)
;
var
stream
=
_emberMetalStreamsUtils
.
chain
(
list
function
(
)
{
_emberMetalStreamsUtils
.
read
(
listChange
)
;
return
_emberMetalStreamsUtils
.
read
(
list
)
;
}
'
each
'
)
;
stream
.
addDependency
(
listChange
)
;
return
stream
;
}
function
shouldDisplay
(
predicate
coercer
)
{
var
length
=
getKey
(
predicate
'
length
'
)
;
var
isTruthy
=
getKey
(
predicate
'
isTruthy
'
)
;
var
stream
=
_emberMetalStreamsUtils
.
chain
(
predicate
function
(
)
{
var
predicateVal
=
_emberMetalStreamsUtils
.
read
(
predicate
)
;
var
lengthVal
=
_emberMetalStreamsUtils
.
read
(
length
)
;
var
isTruthyVal
=
_emberMetalStreamsUtils
.
read
(
isTruthy
)
;
if
(
_emberRuntimeUtils
.
isArray
(
predicateVal
)
)
{
return
lengthVal
>
0
?
coercer
(
predicateVal
)
:
false
;
}
if
(
typeof
isTruthyVal
=
=
=
'
boolean
'
)
{
return
isTruthyVal
?
coercer
(
predicateVal
)
:
false
;
}
return
coercer
(
predicateVal
)
;
}
'
ShouldDisplay
'
)
;
_emberMetalStreamsUtils
.
addDependency
(
stream
length
)
;
_emberMetalStreamsUtils
.
addDependency
(
stream
isTruthy
)
;
return
stream
;
}
function
toBool
(
value
)
{
return
!
!
value
;
}
function
identity
(
value
)
{
return
value
;
}
function
getKey
(
obj
key
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
obj
)
)
{
return
obj
.
getKey
(
key
)
;
}
else
{
return
obj
&
&
obj
[
key
]
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
lookup
-
helper
'
[
'
exports
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
]
function
(
exports
_emberHtmlbarsSystemLookupHelper
)
{
'
use
strict
'
;
exports
.
default
=
lookupHelperHook
;
function
lookupHelperHook
(
env
scope
helperName
)
{
return
_emberHtmlbarsSystemLookupHelper
.
default
(
helperName
scope
.
getSelf
(
)
env
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
subexpr
'
[
'
exports
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
'
ember
-
htmlbars
/
system
/
invoke
-
helper
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
htmlbars
/
hooks
/
link
-
render
-
node
'
]
function
(
exports
_emberHtmlbarsSystemLookupHelper
_emberHtmlbarsSystemInvokeHelper
_emberMetalStreamsUtils
_emberHtmlbarsHooksLinkRenderNode
)
{
'
use
strict
'
;
exports
.
default
=
subexpr
;
exports
.
labelForSubexpr
=
labelForSubexpr
;
function
subexpr
(
env
scope
helperName
params
hash
)
{
var
keyword
=
env
.
hooks
.
keywords
[
helperName
]
;
if
(
keyword
)
{
return
keyword
(
null
env
scope
params
hash
null
null
)
;
}
_emberHtmlbarsHooksLinkRenderNode
.
linkParamsFor
(
helperName
params
)
;
var
label
=
labelForSubexpr
(
params
hash
helperName
)
;
var
helper
=
_emberHtmlbarsSystemLookupHelper
.
default
(
helperName
scope
.
getSelf
(
)
env
)
;
var
helperStream
=
_emberHtmlbarsSystemInvokeHelper
.
buildHelperStream
(
helper
params
hash
null
env
scope
label
)
;
for
(
var
i
=
0
l
=
params
.
length
;
i
<
l
;
i
+
+
)
{
helperStream
.
addDependency
(
params
[
i
]
)
;
}
for
(
var
key
in
hash
)
{
helperStream
.
addDependency
(
hash
[
key
]
)
;
}
return
helperStream
;
}
function
labelForSubexpr
(
params
hash
helperName
)
{
var
paramsLabels
=
labelsForParams
(
params
)
;
var
hashLabels
=
labelsForHash
(
hash
)
;
var
label
=
'
(
'
+
helperName
;
if
(
paramsLabels
)
{
label
+
=
'
'
+
paramsLabels
;
}
if
(
hashLabels
)
{
label
+
=
'
'
+
hashLabels
;
}
return
label
+
'
)
'
;
}
function
labelsForParams
(
params
)
{
return
_emberMetalStreamsUtils
.
labelsFor
(
params
)
.
join
(
'
'
)
;
}
function
labelsForHash
(
hash
)
{
var
out
=
[
]
;
for
(
var
prop
in
hash
)
{
out
.
push
(
prop
+
'
=
'
+
_emberMetalStreamsUtils
.
labelFor
(
hash
[
prop
]
)
)
;
}
return
out
.
join
(
'
'
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
hooks
/
update
-
self
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
)
{
'
use
strict
'
;
exports
.
default
=
updateSelf
;
function
updateSelf
(
env
scope
_self
)
{
var
self
=
_self
;
if
(
self
&
&
self
.
hasBoundController
)
{
var
_self2
=
self
;
var
controller
=
_self2
.
controller
;
self
=
self
.
self
;
scope
.
updateLocal
(
'
controller
'
controller
|
|
self
)
;
}
_emberMetalDebug
.
assert
(
'
BUG
:
scope
.
attrs
and
self
.
isView
should
not
both
be
true
'
!
(
scope
.
attrs
&
&
self
.
isView
)
)
;
if
(
self
&
&
self
.
isView
)
{
scope
.
updateLocal
(
'
view
'
self
)
;
scope
.
updateSelf
(
_emberMetalProperty_get
.
get
(
self
'
context
'
)
'
'
)
;
return
;
}
scope
.
updateSelf
(
self
)
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
hooks
/
will
-
cleanup
-
tree
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
willCleanupTree
;
function
willCleanupTree
(
env
)
{
var
view
=
env
.
view
;
view
.
ownerView
.
_destroyingSubtreeForView
=
view
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
template
-
compiler
'
'
ember
-
htmlbars
/
system
/
make_bound_helper
'
'
ember
-
htmlbars
/
helpers
'
'
ember
-
htmlbars
/
helpers
/
if_unless
'
'
ember
-
htmlbars
/
helpers
/
with
'
'
ember
-
htmlbars
/
helpers
/
loc
'
'
ember
-
htmlbars
/
helpers
/
log
'
'
ember
-
htmlbars
/
helpers
/
each
'
'
ember
-
htmlbars
/
helpers
/
each
-
in
'
'
ember
-
htmlbars
/
helpers
/
-
normalize
-
class
'
'
ember
-
htmlbars
/
helpers
/
concat
'
'
ember
-
htmlbars
/
helpers
/
-
join
-
classes
'
'
ember
-
htmlbars
/
helpers
/
-
html
-
safe
'
'
ember
-
htmlbars
/
helpers
/
hash
'
'
ember
-
htmlbars
/
system
/
dom
-
helper
'
'
ember
-
htmlbars
/
helper
'
'
ember
-
htmlbars
/
template_registry
'
'
ember
-
htmlbars
/
system
/
bootstrap
'
'
ember
-
htmlbars
/
compat
'
]
function
(
exports
_emberMetalCore
_emberTemplateCompiler
_emberHtmlbarsSystemMake_bound_helper
_emberHtmlbarsHelpers
_emberHtmlbarsHelpersIf_unless
_emberHtmlbarsHelpersWith
_emberHtmlbarsHelpersLoc
_emberHtmlbarsHelpersLog
_emberHtmlbarsHelpersEach
_emberHtmlbarsHelpersEachIn
_emberHtmlbarsHelpersNormalizeClass
_emberHtmlbarsHelpersConcat
_emberHtmlbarsHelpersJoinClasses
_emberHtmlbarsHelpersHtmlSafe
_emberHtmlbarsHelpersHash
_emberHtmlbarsSystemDomHelper
_emberHtmlbarsHelper
_emberHtmlbarsTemplate_registry
_emberHtmlbarsSystemBootstrap
_emberHtmlbarsCompat
)
{
'
use
strict
'
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
if
'
_emberHtmlbarsHelpersIf_unless
.
ifHelper
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
unless
'
_emberHtmlbarsHelpersIf_unless
.
unlessHelper
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
with
'
_emberHtmlbarsHelpersWith
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
loc
'
_emberHtmlbarsHelpersLoc
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
log
'
_emberHtmlbarsHelpersLog
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
each
'
_emberHtmlbarsHelpersEach
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
each
-
in
'
_emberHtmlbarsHelpersEachIn
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
-
normalize
-
class
'
_emberHtmlbarsHelpersNormalizeClass
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
concat
'
_emberHtmlbarsHelpersConcat
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
-
join
-
classes
'
_emberHtmlbarsHelpersJoinClasses
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
-
html
-
safe
'
_emberHtmlbarsHelpersHtmlSafe
.
default
)
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
hash
'
_emberHtmlbarsHelpersHash
.
default
)
;
_emberMetalCore
.
default
.
HTMLBars
=
{
template
:
_emberTemplateCompiler
.
template
compile
:
_emberTemplateCompiler
.
compile
precompile
:
_emberTemplateCompiler
.
precompile
makeBoundHelper
:
_emberHtmlbarsSystemMake_bound_helper
.
default
registerPlugin
:
_emberTemplateCompiler
.
registerPlugin
DOMHelper
:
_emberHtmlbarsSystemDomHelper
.
default
}
;
_emberHtmlbarsHelper
.
default
.
helper
=
_emberHtmlbarsHelper
.
helper
;
_emberMetalCore
.
default
.
Helper
=
_emberHtmlbarsHelper
.
default
;
Object
.
defineProperty
(
_emberMetalCore
.
default
'
TEMPLATES
'
{
configurable
:
false
get
:
_emberHtmlbarsTemplate_registry
.
getTemplates
set
:
_emberHtmlbarsTemplate_registry
.
setTemplates
}
)
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
'
[
'
exports
'
'
htmlbars
-
runtime
'
]
function
(
exports
_htmlbarsRuntime
)
{
'
use
strict
'
;
exports
.
registerKeyword
=
registerKeyword
;
var
keywords
=
Object
.
create
(
_htmlbarsRuntime
.
hooks
.
keywords
)
;
function
registerKeyword
(
name
keyword
)
{
keywords
[
name
]
=
keyword
;
}
exports
.
default
=
keywords
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
closure
-
component
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
symbol
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
htmlbars
/
hooks
/
subexpr
'
'
ember
-
metal
/
assign
'
'
ember
-
htmlbars
/
utils
/
extract
-
positional
-
params
'
'
ember
-
htmlbars
/
utils
/
lookup
-
component
'
]
function
(
exports
_emberMetalDebug
_emberMetalIs_none
_emberMetalSymbol
_emberMetalStreamsStream
_emberMetalEmpty_object
_emberMetalStreamsUtils
_emberHtmlbarsHooksSubexpr
_emberMetalAssign
_emberHtmlbarsUtilsExtractPositionalParams
_emberHtmlbarsUtilsLookupComponent
)
{
'
use
strict
'
;
exports
.
default
=
closureComponent
;
exports
.
isComponentCell
=
isComponentCell
;
exports
.
processPositionalParamsFromCell
=
processPositionalParamsFromCell
;
exports
.
mergeInNewHash
=
mergeInNewHash
;
var
COMPONENT_REFERENCE
=
_emberMetalSymbol
.
default
(
'
COMPONENT_REFERENCE
'
)
;
exports
.
COMPONENT_REFERENCE
=
COMPONENT_REFERENCE
;
var
COMPONENT_CELL
=
_emberMetalSymbol
.
default
(
'
COMPONENT_CELL
'
)
;
exports
.
COMPONENT_CELL
=
COMPONENT_CELL
;
var
COMPONENT_PATH
=
_emberMetalSymbol
.
default
(
'
COMPONENT_PATH
'
)
;
exports
.
COMPONENT_PATH
=
COMPONENT_PATH
;
var
COMPONENT_POSITIONAL_PARAMS
=
_emberMetalSymbol
.
default
(
'
COMPONENT_POSITIONAL_PARAMS
'
)
;
exports
.
COMPONENT_POSITIONAL_PARAMS
=
COMPONENT_POSITIONAL_PARAMS
;
var
COMPONENT_HASH
=
_emberMetalSymbol
.
default
(
'
COMPONENT_HASH
'
)
;
exports
.
COMPONENT_HASH
=
COMPONENT_HASH
;
var
ClosureComponentStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
env
path
params
hash
)
{
this
.
_env
=
env
;
this
.
_path
=
path
;
this
.
_params
=
params
;
this
.
_hash
=
hash
;
this
.
label
=
_emberHtmlbarsHooksSubexpr
.
labelForSubexpr
(
[
path
]
.
concat
(
params
)
hash
'
component
'
)
;
this
[
COMPONENT_REFERENCE
]
=
true
;
}
compute
:
function
(
)
{
return
createClosureComponentCell
(
this
.
_env
this
.
_path
this
.
_params
this
.
_hash
this
.
label
)
;
}
}
)
;
function
closureComponent
(
env
_ref3
hash
)
{
var
path
=
_ref3
[
0
]
;
var
params
=
_ref3
.
slice
(
1
)
;
var
s
=
new
ClosureComponentStream
(
env
path
params
hash
)
;
s
.
addDependency
(
path
)
;
params
.
forEach
(
function
(
item
)
{
return
s
.
addDependency
(
item
)
;
}
)
;
Object
.
keys
(
hash
)
.
forEach
(
function
(
key
)
{
return
s
.
addDependency
(
hash
[
key
]
)
;
}
)
;
return
s
;
}
function
createClosureComponentCell
(
env
originalComponentPath
params
hash
label
)
{
var
componentPath
=
_emberMetalStreamsUtils
.
read
(
originalComponentPath
)
;
_emberMetalDebug
.
assert
(
'
Component
path
cannot
be
null
in
'
+
label
!
_emberMetalIs_none
.
default
(
componentPath
)
)
;
var
newHash
=
_emberMetalAssign
.
default
(
new
_emberMetalEmpty_object
.
default
(
)
hash
)
;
if
(
isComponentCell
(
componentPath
)
)
{
return
createNestedClosureComponentCell
(
componentPath
params
newHash
)
;
}
else
{
_emberMetalDebug
.
assert
(
'
The
component
helper
cannot
be
used
without
a
valid
component
name
.
You
used
"
'
+
componentPath
+
'
"
via
'
+
label
isValidComponentPath
(
env
componentPath
)
)
;
return
createNewClosureComponentCell
(
env
componentPath
params
newHash
)
;
}
}
function
isValidComponentPath
(
env
path
)
{
var
result
=
_emberHtmlbarsUtilsLookupComponent
.
default
(
env
.
owner
path
)
;
return
!
!
(
result
.
component
|
|
result
.
layout
)
;
}
function
isComponentCell
(
component
)
{
return
component
&
&
component
[
COMPONENT_CELL
]
;
}
function
createNestedClosureComponentCell
(
componentCell
params
hash
)
{
var
_ref
;
processPositionalParamsFromCell
(
componentCell
params
hash
)
;
return
_ref
=
{
}
_ref
[
COMPONENT_PATH
]
=
componentCell
[
COMPONENT_PATH
]
_ref
[
COMPONENT_HASH
]
=
mergeInNewHash
(
componentCell
[
COMPONENT_HASH
]
hash
)
_ref
[
COMPONENT_POSITIONAL_PARAMS
]
=
componentCell
[
COMPONENT_POSITIONAL_PARAMS
]
_ref
[
COMPONENT_CELL
]
=
true
_ref
;
}
function
processPositionalParamsFromCell
(
componentCell
params
hash
)
{
var
positionalParams
=
componentCell
[
COMPONENT_POSITIONAL_PARAMS
]
;
_emberHtmlbarsUtilsExtractPositionalParams
.
processPositionalParams
(
null
positionalParams
params
hash
)
;
}
function
createNewClosureComponentCell
(
env
componentPath
params
hash
)
{
var
_ref2
;
var
positionalParams
=
getPositionalParams
(
env
.
owner
componentPath
)
;
_emberHtmlbarsUtilsExtractPositionalParams
.
processPositionalParams
(
null
positionalParams
params
hash
)
;
return
_ref2
=
{
}
_ref2
[
COMPONENT_PATH
]
=
componentPath
_ref2
[
COMPONENT_HASH
]
=
hash
_ref2
[
COMPONENT_POSITIONAL_PARAMS
]
=
positionalParams
_ref2
[
COMPONENT_CELL
]
=
true
_ref2
;
}
function
getPositionalParams
(
container
componentPath
)
{
if
(
!
componentPath
)
{
return
[
]
;
}
var
result
=
_emberHtmlbarsUtilsLookupComponent
.
default
(
container
componentPath
)
;
var
component
=
result
.
component
;
if
(
component
&
&
component
.
positionalParams
)
{
return
component
.
positionalParams
;
}
else
{
return
[
]
;
}
}
function
mergeInNewHash
(
original
updates
)
{
return
_emberMetalAssign
.
default
(
{
}
original
updates
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
component
'
[
'
exports
'
'
htmlbars
-
runtime
/
hooks
'
'
ember
-
htmlbars
/
keywords
/
closure
-
component
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_htmlbarsRuntimeHooks
_emberHtmlbarsKeywordsClosureComponent
_emberMetalEmpty_object
_emberMetalAssign
)
{
'
use
strict
'
;
exports
.
default
=
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
if
(
!
morph
)
{
return
_emberHtmlbarsKeywordsClosureComponent
.
default
(
env
params
hash
)
;
}
var
newHash
=
_emberMetalAssign
.
default
(
new
_emberMetalEmpty_object
.
default
(
)
hash
)
;
_htmlbarsRuntimeHooks
.
keyword
(
'
element_component
'
morph
env
scope
params
newHash
template
inverse
visitor
)
;
return
true
;
}
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
debugger
'
[
'
exports
'
'
ember
-
metal
/
debug
'
]
function
(
exports
_emberMetalDebug
)
{
'
use
strict
'
;
exports
.
default
=
debuggerKeyword
;
function
debuggerKeyword
(
morph
env
scope
)
{
var
view
=
env
.
hooks
.
getValue
(
scope
.
getLocal
(
'
view
'
)
)
;
var
context
=
env
.
hooks
.
getValue
(
scope
.
getSelf
(
)
)
;
function
get
(
path
)
{
return
env
.
hooks
.
getValue
(
env
.
hooks
.
get
(
env
scope
path
)
)
;
}
_emberMetalDebug
.
info
(
'
Use
view
context
and
get
(
<
path
>
)
to
debug
this
template
.
'
)
;
debugger
;
return
true
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
element
-
component
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
htmlbars
/
keywords
/
closure
-
component
'
'
ember
-
htmlbars
/
utils
/
lookup
-
component
'
'
ember
-
htmlbars
/
utils
/
extract
-
positional
-
params
'
]
function
(
exports
_emberMetalAssign
_emberHtmlbarsKeywordsClosureComponent
_emberHtmlbarsUtilsLookupComponent
_emberHtmlbarsUtilsExtractPositionalParams
)
{
'
use
strict
'
;
exports
.
default
=
{
setupState
:
function
(
lastState
env
scope
params
hash
)
{
var
componentPath
=
getComponentPath
(
params
[
0
]
env
)
;
return
_emberMetalAssign
.
default
(
{
}
lastState
{
componentPath
:
componentPath
isComponentHelper
:
true
}
)
;
}
render
:
function
(
morph
)
{
var
state
=
morph
.
getState
(
)
;
if
(
state
.
manager
)
{
state
.
manager
.
destroy
(
)
;
}
state
.
manager
=
null
;
for
(
var
_len
=
arguments
.
length
rest
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
rest
[
_key
-
1
]
=
arguments
[
_key
]
;
}
render
.
apply
(
undefined
[
morph
]
.
concat
(
rest
)
)
;
}
rerender
:
render
}
;
function
getComponentPath
(
param
env
)
{
var
path
=
env
.
hooks
.
getValue
(
param
)
;
if
(
_emberHtmlbarsKeywordsClosureComponent
.
isComponentCell
(
path
)
)
{
path
=
path
[
_emberHtmlbarsKeywordsClosureComponent
.
COMPONENT_PATH
]
;
}
return
path
;
}
function
render
(
morph
env
scope
_ref
hash
template
inverse
visitor
)
{
var
path
=
_ref
[
0
]
;
var
params
=
_ref
.
slice
(
1
)
;
var
isRerender
=
arguments
.
length
<
=
8
|
|
arguments
[
8
]
=
=
=
undefined
?
false
:
arguments
[
8
]
;
var
_morph
getState
=
morph
.
getState
(
)
;
var
componentPath
=
_morph
getState
.
componentPath
;
if
(
componentPath
=
=
=
undefined
|
|
componentPath
=
=
=
null
)
{
return
;
}
path
=
env
.
hooks
.
getValue
(
path
)
;
if
(
isRerender
)
{
var
result
=
_emberHtmlbarsUtilsLookupComponent
.
default
(
env
.
owner
componentPath
)
;
var
component
=
result
.
component
;
_emberHtmlbarsUtilsExtractPositionalParams
.
default
(
null
component
params
hash
)
;
}
if
(
_emberHtmlbarsKeywordsClosureComponent
.
isComponentCell
(
path
)
)
{
var
closureComponent
=
env
.
hooks
.
getValue
(
path
)
;
_emberHtmlbarsKeywordsClosureComponent
.
processPositionalParamsFromCell
(
closureComponent
params
hash
)
;
params
=
[
]
;
hash
=
_emberHtmlbarsKeywordsClosureComponent
.
mergeInNewHash
(
closureComponent
[
_emberHtmlbarsKeywordsClosureComponent
.
COMPONENT_HASH
]
hash
)
;
}
var
templates
=
{
default
:
template
inverse
:
inverse
}
;
env
.
hooks
.
component
(
morph
env
scope
componentPath
params
hash
templates
visitor
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
get
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
htmlbars
/
utils
/
subscribe
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
observer
'
]
function
(
exports
_emberMetalDebug
_emberMetalStreamsStream
_emberMetalStreamsUtils
_emberHtmlbarsUtilsSubscribe
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalObserver
)
{
'
use
strict
'
;
function
labelFor
(
source
key
)
{
var
sourceLabel
=
source
.
label
?
source
.
label
:
'
'
;
var
keyLabel
=
key
.
label
?
key
.
label
:
'
'
;
return
'
(
get
'
+
sourceLabel
+
'
'
+
keyLabel
+
'
)
'
;
}
var
DynamicKeyStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
source
keySource
)
{
var
label
=
labelFor
(
source
keySource
)
;
this
.
label
=
label
;
this
.
path
=
label
;
this
.
sourceDep
=
this
.
addMutableDependency
(
source
)
;
this
.
keyDep
=
this
.
addMutableDependency
(
keySource
)
;
this
.
observedObject
=
null
;
this
.
observedKey
=
null
;
}
key
:
function
(
)
{
var
key
=
this
.
keyDep
.
getValue
(
)
;
if
(
typeof
key
=
=
=
'
string
'
)
{
return
key
;
}
}
compute
:
function
(
)
{
var
object
=
this
.
sourceDep
.
getValue
(
)
;
var
key
=
this
.
key
(
)
;
if
(
object
&
&
key
)
{
return
_emberMetalProperty_get
.
get
(
object
key
)
;
}
}
setValue
:
function
(
value
)
{
var
object
=
this
.
sourceDep
.
getValue
(
)
;
var
key
=
this
.
key
(
)
;
if
(
object
)
{
_emberMetalProperty_set
.
set
(
object
key
value
)
;
}
}
_super
revalidate
:
_emberMetalStreamsStream
.
default
.
prototype
.
revalidate
revalidate
:
function
(
value
)
{
this
.
_super
revalidate
(
value
)
;
var
object
=
this
.
sourceDep
.
getValue
(
)
;
var
key
=
this
.
key
(
)
;
if
(
object
!
=
=
this
.
observedObject
|
|
key
!
=
=
this
.
observedKey
)
{
this
.
_clearObservedObject
(
)
;
if
(
object
&
&
typeof
object
=
=
=
'
object
'
&
&
key
)
{
_emberMetalObserver
.
addObserver
(
object
key
this
this
.
notify
)
;
this
.
observedObject
=
object
;
this
.
observedKey
=
key
;
}
}
}
_clearObservedObject
:
function
(
)
{
if
(
this
.
observedObject
)
{
_emberMetalObserver
.
removeObserver
(
this
.
observedObject
this
.
observedKey
this
this
.
notify
)
;
this
.
observedObject
=
null
;
this
.
observedKey
=
null
;
}
}
}
)
;
var
buildStream
=
function
buildStream
(
params
)
{
var
objRef
=
params
[
0
]
;
var
pathRef
=
params
[
1
]
;
_emberMetalDebug
.
assert
(
'
The
first
argument
to
{
{
get
}
}
must
be
a
stream
'
_emberMetalStreamsUtils
.
isStream
(
objRef
)
)
;
_emberMetalDebug
.
assert
(
'
{
{
get
}
}
requires
at
least
two
arguments
'
params
.
length
>
1
)
;
var
stream
=
buildDynamicKeyStream
(
objRef
pathRef
)
;
return
stream
;
}
;
function
buildDynamicKeyStream
(
source
keySource
)
{
if
(
!
_emberMetalStreamsUtils
.
isStream
(
keySource
)
)
{
return
source
.
get
(
keySource
)
;
}
else
{
return
new
DynamicKeyStream
(
source
keySource
)
;
}
}
function
getKeyword
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
if
(
morph
=
=
=
null
)
{
return
buildStream
(
params
)
;
}
else
{
var
stream
=
undefined
;
if
(
morph
.
linkedResult
)
{
stream
=
morph
.
linkedResult
;
}
else
{
stream
=
buildStream
(
params
)
;
_emberHtmlbarsUtilsSubscribe
.
default
(
morph
env
scope
stream
)
;
env
.
hooks
.
linkRenderNode
(
morph
env
scope
null
params
hash
)
;
morph
.
linkedResult
=
stream
;
}
env
.
hooks
.
range
(
morph
env
scope
null
stream
visitor
)
;
}
return
true
;
}
exports
.
default
=
getKeyword
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
input
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_emberMetalDebug
_emberMetalAssign
)
{
'
use
strict
'
;
exports
.
default
=
{
setupState
:
function
(
lastState
env
scope
params
hash
)
{
var
type
=
env
.
hooks
.
getValue
(
hash
.
type
)
;
var
componentName
=
componentNameMap
[
type
]
|
|
defaultComponentName
;
_emberMetalDebug
.
assert
(
'
{
{
input
type
=
\
'
checkbox
\
'
}
}
does
not
support
setting
value
=
someBooleanValue
;
'
+
'
you
must
use
checked
=
someBooleanValue
instead
.
'
!
(
type
=
=
=
'
checkbox
'
&
&
hash
.
hasOwnProperty
(
'
value
'
)
)
)
;
return
_emberMetalAssign
.
default
(
{
}
lastState
{
componentName
:
componentName
}
)
;
}
render
:
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
env
.
hooks
.
component
(
morph
env
scope
morph
.
getState
(
)
.
componentName
params
hash
{
default
:
template
inverse
:
inverse
}
visitor
)
;
}
rerender
:
function
(
)
{
this
.
render
.
apply
(
this
arguments
)
;
}
}
;
var
defaultComponentName
=
'
-
text
-
field
'
;
var
componentNameMap
=
{
'
checkbox
'
:
'
-
checkbox
'
}
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
mut
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
symbol
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
'
ember
-
routing
-
htmlbars
/
keywords
/
closure
-
action
'
]
function
(
exports
_emberMetalDebug
_emberMetalSymbol
_emberMetalStreamsProxyStream
_emberMetalStreamsStream
_emberMetalStreamsUtils
_emberViewsCompatAttrsProxy
_emberRoutingHtmlbarsKeywordsClosureAction
)
{
'
use
strict
'
;
var
_ProxyStream
extend
;
exports
.
default
=
mut
;
exports
.
privateMut
=
privateMut
;
var
MUTABLE_REFERENCE
=
_emberMetalSymbol
.
default
(
'
MUTABLE_REFERENCE
'
)
;
exports
.
MUTABLE_REFERENCE
=
MUTABLE_REFERENCE
;
var
MutStream
=
_emberMetalStreamsProxyStream
.
default
.
extend
(
(
_ProxyStream
extend
=
{
init
:
function
(
stream
)
{
this
.
label
=
'
(
mut
'
+
stream
.
label
+
'
)
'
;
this
.
path
=
stream
.
path
;
this
.
sourceDep
=
this
.
addMutableDependency
(
stream
)
;
this
[
MUTABLE_REFERENCE
]
=
true
;
}
cell
:
function
(
)
{
var
source
=
this
;
var
value
=
source
.
value
(
)
;
if
(
value
&
&
value
[
_emberRoutingHtmlbarsKeywordsClosureAction
.
ACTION
]
)
{
return
value
;
}
var
val
=
{
value
:
value
update
:
function
(
val
)
{
source
.
setValue
(
val
)
;
}
}
;
val
[
_emberViewsCompatAttrsProxy
.
MUTABLE_CELL
]
=
true
;
return
val
;
}
}
_ProxyStream
extend
[
_emberRoutingHtmlbarsKeywordsClosureAction
.
INVOKE
]
=
function
(
val
)
{
this
.
setValue
(
val
)
;
}
_ProxyStream
extend
)
)
;
function
mut
(
morph
env
scope
originalParams
hash
template
inverse
)
{
if
(
morph
=
=
=
null
)
{
var
valueStream
=
originalParams
[
0
]
;
return
mutParam
(
env
.
hooks
.
getValue
valueStream
)
;
}
return
true
;
}
function
privateMut
(
morph
env
scope
originalParams
hash
template
inverse
)
{
if
(
morph
=
=
=
null
)
{
var
valueStream
=
originalParams
[
0
]
;
return
mutParam
(
env
.
hooks
.
getValue
valueStream
true
)
;
}
return
true
;
}
var
LiteralStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
literal
)
{
this
.
literal
=
literal
;
this
.
label
=
'
(
literal
'
+
literal
+
'
)
'
;
}
compute
:
function
(
)
{
return
this
.
literal
;
}
setValue
:
function
(
val
)
{
this
.
literal
=
val
;
this
.
notify
(
)
;
}
}
)
;
function
mutParam
(
read
stream
internal
)
{
if
(
internal
)
{
if
(
!
_emberMetalStreamsUtils
.
isStream
(
stream
)
)
{
var
literal
=
stream
;
stream
=
new
LiteralStream
(
literal
)
;
}
}
else
{
_emberMetalDebug
.
assert
(
'
You
can
only
pass
a
path
to
mut
'
_emberMetalStreamsUtils
.
isStream
(
stream
)
)
;
}
if
(
stream
[
MUTABLE_REFERENCE
]
)
{
return
stream
;
}
return
new
MutStream
(
stream
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
outlet
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
htmlbars
/
node
-
managers
/
view
-
node
-
manager
'
'
ember
-
htmlbars
/
templates
/
top
-
level
-
view
'
'
ember
-
metal
/
features
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberHtmlbarsNodeManagersViewNodeManager
_emberHtmlbarsTemplatesTopLevelView
_emberMetalFeatures
)
{
'
use
strict
'
;
_emberHtmlbarsTemplatesTopLevelView
.
default
.
meta
.
revision
=
'
Ember
2
.
6
.
2
'
;
exports
.
default
=
{
willRender
:
function
(
renderNode
env
)
{
env
.
view
.
ownerView
.
_outlets
.
push
(
renderNode
)
;
}
setupState
:
function
(
state
env
scope
params
hash
)
{
var
outletState
=
env
.
outletState
;
var
read
=
env
.
hooks
.
getValue
;
var
outletName
=
read
(
params
[
0
]
)
|
|
'
main
'
;
var
selectedOutletState
=
outletState
[
outletName
]
;
return
{
outletState
:
selectedOutletState
hasParentOutlet
:
env
.
hasParentOutlet
manager
:
state
.
manager
}
;
}
childEnv
:
function
(
state
env
)
{
var
outletState
=
state
.
outletState
;
var
toRender
=
outletState
&
&
outletState
.
render
;
var
meta
=
toRender
&
&
toRender
.
template
&
&
toRender
.
template
.
meta
;
return
env
.
childWithOutletState
(
outletState
&
&
outletState
.
outlets
true
meta
)
;
}
isStable
:
function
(
lastState
nextState
)
{
return
isStable
(
lastState
.
outletState
nextState
.
outletState
)
;
}
isEmpty
:
function
(
state
)
{
return
isEmpty
(
state
.
outletState
)
;
}
render
:
function
(
renderNode
env
scope
params
hash
template
inverse
visitor
)
{
var
state
=
renderNode
.
getState
(
)
;
var
parentView
=
env
.
view
;
var
outletState
=
state
.
outletState
;
var
toRender
=
outletState
.
render
;
var
namespace
=
env
.
owner
.
lookup
(
'
application
:
main
'
)
;
var
LOG_VIEW_LOOKUPS
=
_emberMetalProperty_get
.
get
(
namespace
'
LOG_VIEW_LOOKUPS
'
)
;
var
ViewClass
=
outletState
.
render
.
ViewClass
;
if
(
!
state
.
hasParentOutlet
&
&
!
ViewClass
)
{
ViewClass
=
env
.
owner
.
_lookupFactory
(
'
view
:
toplevel
'
)
;
}
var
Component
;
var
options
;
var
attrs
=
{
}
;
if
(
Component
)
{
options
=
{
component
:
Component
}
;
attrs
=
toRender
.
attrs
;
}
else
{
options
=
{
component
:
ViewClass
self
:
toRender
.
controller
createOptions
:
{
controller
:
toRender
.
controller
}
}
;
template
=
template
|
|
toRender
.
template
&
&
toRender
.
template
.
raw
;
if
(
LOG_VIEW_LOOKUPS
&
&
ViewClass
)
{
_emberMetalDebug
.
info
(
'
Rendering
'
+
toRender
.
name
+
'
with
'
+
ViewClass
{
fullName
:
'
view
:
'
+
toRender
.
name
}
)
;
}
}
if
(
state
.
manager
)
{
state
.
manager
.
destroy
(
)
;
state
.
manager
=
null
;
}
var
nodeManager
=
_emberHtmlbarsNodeManagersViewNodeManager
.
default
.
create
(
renderNode
env
attrs
options
parentView
null
null
template
)
;
state
.
manager
=
nodeManager
;
nodeManager
.
render
(
env
hash
visitor
)
;
}
}
;
function
isEmpty
(
outletState
)
{
return
!
outletState
|
|
!
outletState
.
render
.
ViewClass
&
&
!
outletState
.
render
.
template
;
}
function
isStable
(
a
b
)
{
if
(
!
a
&
&
!
b
)
{
return
true
;
}
if
(
!
a
|
|
!
b
)
{
return
false
;
}
a
=
a
.
render
;
b
=
b
.
render
;
for
(
var
key
in
a
)
{
if
(
a
.
hasOwnProperty
(
key
)
)
{
if
(
a
[
key
]
!
=
=
b
[
key
]
&
&
key
!
=
=
'
name
'
)
{
return
false
;
}
}
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
partial
'
[
'
exports
'
'
ember
-
views
/
system
/
lookup_partial
'
'
htmlbars
-
runtime
'
]
function
(
exports
_emberViewsSystemLookup_partial
_htmlbarsRuntime
)
{
'
use
strict
'
;
exports
.
default
=
{
setupState
:
function
(
state
env
scope
params
hash
)
{
return
{
partialName
:
env
.
hooks
.
getValue
(
params
[
0
]
)
}
;
}
render
:
function
(
renderNode
env
scope
params
hash
template
inverse
visitor
)
{
var
state
=
renderNode
.
getState
(
)
;
if
(
!
state
.
partialName
)
{
return
true
;
}
var
found
=
_emberViewsSystemLookup_partial
.
default
(
env
state
.
partialName
)
;
if
(
!
found
)
{
return
true
;
}
_htmlbarsRuntime
.
internal
.
hostBlock
(
renderNode
env
scope
found
.
raw
null
null
visitor
function
(
options
)
{
options
.
templates
.
template
.
yield
(
)
;
}
)
;
}
}
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
readonly
'
[
'
exports
'
'
ember
-
htmlbars
/
keywords
/
mut
'
]
function
(
exports
_emberHtmlbarsKeywordsMut
)
{
'
use
strict
'
;
exports
.
default
=
readonly
;
function
readonly
(
morph
env
scope
originalParams
hash
template
inverse
)
{
if
(
morph
=
=
=
null
)
{
var
stream
=
originalParams
[
0
]
;
if
(
stream
&
&
stream
[
_emberHtmlbarsKeywordsMut
.
MUTABLE_REFERENCE
]
)
{
return
stream
.
sourceDep
.
dependee
;
}
return
stream
;
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
textarea
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
textarea
;
function
textarea
(
morph
env
scope
originalParams
hash
template
inverse
visitor
)
{
env
.
hooks
.
component
(
morph
env
scope
'
-
text
-
area
'
originalParams
hash
{
default
:
template
inverse
:
inverse
}
visitor
)
;
return
true
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
unbound
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalDebug
_emberMetalStreamsStream
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
unbound
;
var
VolatileStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
source
)
{
this
.
label
=
'
(
volatile
'
+
source
.
label
+
'
)
'
;
this
.
source
=
source
;
this
.
addDependency
(
source
)
;
}
value
:
function
(
)
{
return
_emberMetalStreamsUtils
.
read
(
this
.
source
)
;
}
notify
:
function
(
)
{
}
}
)
;
function
unbound
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
_emberMetalDebug
.
assert
(
'
unbound
helper
cannot
be
called
with
multiple
params
or
hash
params
'
params
.
length
=
=
=
1
&
&
Object
.
keys
(
hash
)
.
length
=
=
=
0
)
;
_emberMetalDebug
.
assert
(
'
unbound
helper
cannot
be
called
as
a
block
'
!
template
)
;
if
(
morph
=
=
=
null
)
{
return
new
VolatileStream
(
params
[
0
]
)
;
}
var
stream
=
undefined
;
if
(
morph
.
linkedResult
)
{
stream
=
morph
.
linkedResult
;
}
else
{
stream
=
new
VolatileStream
(
params
[
0
]
)
;
morph
.
linkedResult
=
stream
;
}
env
.
hooks
.
range
(
morph
env
scope
null
stream
visitor
)
;
return
true
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
view
'
[
'
exports
'
'
ember
-
views
/
streams
/
utils
'
'
ember
-
views
/
views
/
view
'
'
ember
-
htmlbars
/
node
-
managers
/
view
-
node
-
manager
'
]
function
(
exports
_emberViewsStreamsUtils
_emberViewsViewsView
_emberHtmlbarsNodeManagersViewNodeManager
)
{
'
use
strict
'
;
exports
.
default
=
{
setupState
:
function
(
state
env
scope
params
hash
)
{
var
read
=
env
.
hooks
.
getValue
;
var
targetObject
=
read
(
scope
.
getSelf
(
)
)
;
var
viewClassOrInstance
=
state
.
viewClassOrInstance
;
if
(
!
viewClassOrInstance
)
{
viewClassOrInstance
=
getView
(
read
(
params
[
0
]
)
env
.
owner
)
;
}
var
controller
=
scope
.
hasLocal
(
'
view
'
)
?
null
:
read
(
scope
.
getSelf
(
)
)
;
return
{
manager
:
state
.
manager
parentView
:
env
.
view
controller
:
controller
targetObject
:
targetObject
viewClassOrInstance
:
viewClassOrInstance
}
;
}
rerender
:
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
if
(
Object
.
keys
(
hash
)
.
length
)
{
return
morph
.
getState
(
)
.
manager
.
rerender
(
env
hash
visitor
true
)
;
}
}
render
:
function
(
node
env
scope
params
hash
template
inverse
visitor
)
{
if
(
hash
.
tag
)
{
hash
=
swapKey
(
hash
'
tag
'
'
tagName
'
)
;
}
if
(
hash
.
classNameBindings
)
{
hash
.
classNameBindings
=
hash
.
classNameBindings
.
split
(
'
'
)
;
}
var
state
=
node
.
getState
(
)
;
var
parentView
=
state
.
parentView
;
var
options
=
{
component
:
state
.
viewClassOrInstance
layout
:
null
}
;
options
.
createOptions
=
{
}
;
if
(
state
.
controller
)
{
options
.
createOptions
.
_controller
=
state
.
controller
;
}
if
(
state
.
targetObject
)
{
options
.
createOptions
.
_targetObject
=
state
.
targetObject
;
}
if
(
state
.
manager
)
{
state
.
manager
.
destroy
(
)
;
state
.
manager
=
null
;
}
var
nodeManager
=
_emberHtmlbarsNodeManagersViewNodeManager
.
default
.
create
(
node
env
hash
options
parentView
null
scope
template
)
;
state
.
manager
=
nodeManager
;
nodeManager
.
render
(
env
hash
visitor
)
;
}
}
;
function
getView
(
viewPath
owner
)
{
var
viewClassOrInstance
;
if
(
!
viewPath
)
{
if
(
owner
)
{
viewClassOrInstance
=
owner
.
_lookupFactory
(
'
view
:
toplevel
'
)
;
}
else
{
viewClassOrInstance
=
_emberViewsViewsView
.
default
;
}
}
else
{
viewClassOrInstance
=
_emberViewsStreamsUtils
.
readViewFactory
(
viewPath
owner
)
;
}
return
viewClassOrInstance
;
}
function
swapKey
(
hash
original
update
)
{
var
newHash
=
{
}
;
for
(
var
prop
in
hash
)
{
if
(
prop
=
=
=
original
)
{
newHash
[
update
]
=
hash
[
prop
]
;
}
else
{
newHash
[
prop
]
=
hash
[
prop
]
;
}
}
return
newHash
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
with
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
htmlbars
-
runtime
'
]
function
(
exports
_emberMetalDebug
_htmlbarsRuntime
)
{
'
use
strict
'
;
exports
.
default
=
{
isStable
:
function
(
)
{
return
true
;
}
isEmpty
:
function
(
state
)
{
return
false
;
}
render
:
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
_emberMetalDebug
.
assert
(
'
{
{
#
with
foo
}
}
must
be
called
with
a
single
argument
or
the
use
the
'
+
'
{
{
#
with
foo
as
|
bar
|
}
}
syntax
'
params
.
length
=
=
=
1
)
;
_emberMetalDebug
.
assert
(
'
The
{
{
#
with
}
}
helper
must
be
called
with
a
block
'
!
!
template
)
;
_htmlbarsRuntime
.
internal
.
continueBlock
(
morph
env
scope
'
with
'
params
hash
template
inverse
visitor
)
;
}
rerender
:
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
_htmlbarsRuntime
.
internal
.
continueBlock
(
morph
env
scope
'
with
'
params
hash
template
inverse
visitor
)
;
}
}
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
keywords
/
yield
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
yieldKeyword
;
function
yieldKeyword
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
var
to
=
env
.
hooks
.
getValue
(
hash
.
to
)
|
|
'
default
'
;
var
block
=
scope
.
getBlock
(
to
)
;
if
(
block
)
{
block
.
invoke
(
env
params
hash
.
self
morph
scope
visitor
)
;
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
morphs
/
attr
-
morph
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
dom
-
helper
'
'
ember
-
metal
/
is_none
'
]
function
(
exports
_emberMetalDebug
_domHelper
_emberMetalIs_none
)
{
'
use
strict
'
;
var
HTMLBarsAttrMorph
=
_domHelper
.
default
.
prototype
.
AttrMorphClass
;
var
styleWarning
=
'
'
+
'
Binding
style
attributes
may
introduce
cross
-
site
scripting
vulnerabilities
;
'
+
'
please
ensure
that
values
being
bound
are
properly
escaped
.
For
more
information
'
+
'
including
how
to
disable
this
warning
see
'
+
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v1
.
x
/
#
toc_binding
-
style
-
attributes
.
'
;
exports
.
styleWarning
=
styleWarning
;
var
proto
=
HTMLBarsAttrMorph
.
prototype
;
proto
.
didInit
=
function
(
)
{
this
.
streamUnsubscribers
=
null
;
_emberMetalDebug
.
debugSeal
(
this
)
;
}
;
function
deprecateEscapedStyle
(
morph
value
)
{
_emberMetalDebug
.
warn
(
styleWarning
(
function
(
name
value
escaped
)
{
if
(
_emberMetalIs_none
.
default
(
value
)
|
|
value
&
&
value
.
toHTML
)
{
return
true
;
}
if
(
name
!
=
=
'
style
'
)
{
return
true
;
}
return
!
escaped
;
}
)
(
morph
.
attrName
value
morph
.
escaped
)
{
id
:
'
ember
-
htmlbars
.
style
-
xss
-
warning
'
}
)
;
}
proto
.
willSetContent
=
function
(
value
)
{
deprecateEscapedStyle
(
this
value
)
;
}
;
exports
.
default
=
HTMLBarsAttrMorph
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
morphs
/
morph
'
[
'
exports
'
'
dom
-
helper
'
'
ember
-
metal
/
debug
'
]
function
(
exports
_domHelper
_emberMetalDebug
)
{
'
use
strict
'
;
var
HTMLBarsMorph
=
_domHelper
.
default
.
prototype
.
MorphClass
;
var
guid
=
1
;
function
EmberMorph
(
DOMHelper
contextualElement
)
{
this
.
HTMLBarsMorph
constructor
(
DOMHelper
contextualElement
)
;
this
.
emberView
=
null
;
this
.
emberToDestroy
=
null
;
this
.
streamUnsubscribers
=
null
;
this
.
guid
=
guid
+
+
;
this
.
shouldReceiveAttrs
=
false
;
_emberMetalDebug
.
debugSeal
(
this
)
;
}
var
proto
=
EmberMorph
.
prototype
=
Object
.
create
(
HTMLBarsMorph
.
prototype
)
;
proto
.
HTMLBarsMorph
constructor
=
HTMLBarsMorph
;
proto
.
HTMLBarsMorph
clear
=
HTMLBarsMorph
.
prototype
.
clear
;
proto
.
addDestruction
=
function
(
toDestroy
)
{
this
.
emberToDestroy
=
this
.
emberToDestroy
|
|
[
]
;
this
.
emberToDestroy
.
push
(
toDestroy
)
;
}
;
proto
.
cleanup
=
function
(
)
{
var
view
=
this
.
emberView
;
if
(
view
)
{
var
parentView
=
view
.
parentView
;
if
(
parentView
&
&
view
.
ownerView
.
_destroyingSubtreeForView
=
=
=
parentView
)
{
parentView
.
removeChild
(
view
)
;
}
}
var
toDestroy
=
this
.
emberToDestroy
;
if
(
toDestroy
)
{
for
(
var
i
=
0
l
=
toDestroy
.
length
;
i
<
l
;
i
+
+
)
{
toDestroy
[
i
]
.
destroy
(
)
;
}
this
.
emberToDestroy
=
null
;
}
}
;
proto
.
didRender
=
function
(
env
scope
)
{
env
.
renderedNodes
.
add
(
this
)
;
}
;
exports
.
default
=
EmberMorph
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
node
-
managers
/
component
-
node
-
manager
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
views
/
system
/
build
-
component
-
template
'
'
ember
-
htmlbars
/
hooks
/
get
-
cell
-
or
-
value
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
'
ember
-
htmlbars
/
system
/
instrumentation
-
support
'
'
ember
-
views
/
components
/
component
'
'
ember
-
htmlbars
/
glimmer
-
component
'
'
ember
-
htmlbars
/
utils
/
extract
-
positional
-
params
'
'
ember
-
metal
/
symbol
'
'
container
/
owner
'
'
ember
-
htmlbars
/
hooks
/
get
-
value
'
]
function
(
exports
_emberMetalDebug
_emberViewsSystemBuildComponentTemplate
_emberHtmlbarsHooksGetCellOrValue
_emberMetalProperty_get
_emberMetalProperty_set
_emberViewsCompatAttrsProxy
_emberHtmlbarsSystemInstrumentationSupport
_emberViewsComponentsComponent
_emberHtmlbarsGlimmerComponent
_emberHtmlbarsUtilsExtractPositionalParams
_emberMetalSymbol
_containerOwner
_emberHtmlbarsHooksGetValue
)
{
'
use
strict
'
;
exports
.
createComponent
=
createComponent
;
exports
.
takeLegacySnapshot
=
takeLegacySnapshot
;
var
HAS_BLOCK
=
_emberMetalSymbol
.
default
(
'
HAS_BLOCK
'
)
;
exports
.
HAS_BLOCK
=
HAS_BLOCK
;
function
ComponentNodeManager
(
component
isAngleBracket
scope
renderNode
attrs
block
expectElement
)
{
this
.
component
=
component
;
this
.
isAngleBracket
=
isAngleBracket
;
this
.
scope
=
scope
;
this
.
renderNode
=
renderNode
;
this
.
attrs
=
attrs
;
this
.
block
=
block
;
this
.
expectElement
=
expectElement
;
}
exports
.
default
=
ComponentNodeManager
;
ComponentNodeManager
.
create
=
function
ComponentNodeManager_create
(
renderNode
env
options
)
{
var
_createOptions
;
var
tagName
=
options
.
tagName
;
var
params
=
options
.
params
;
var
_options
attrs
=
options
.
attrs
;
var
attrs
=
_options
attrs
=
=
=
undefined
?
{
}
:
_options
attrs
;
var
parentView
=
options
.
parentView
;
var
parentScope
=
options
.
parentScope
;
var
isAngleBracket
=
options
.
isAngleBracket
;
var
component
=
options
.
component
;
var
layout
=
options
.
layout
;
var
templates
=
options
.
templates
;
component
=
component
|
|
(
isAngleBracket
?
_emberHtmlbarsGlimmerComponent
.
default
:
_emberViewsComponentsComponent
.
default
)
;
var
createOptions
=
(
_createOptions
=
{
parentView
:
parentView
}
_createOptions
[
HAS_BLOCK
]
=
!
!
templates
.
default
_createOptions
)
;
configureTagName
(
attrs
tagName
component
isAngleBracket
createOptions
)
;
configureCreateOptions
(
attrs
createOptions
)
;
if
(
parentScope
.
hasLocal
(
'
controller
'
)
)
{
createOptions
.
_controller
=
_emberHtmlbarsHooksGetValue
.
default
(
parentScope
.
getLocal
(
'
controller
'
)
)
;
}
else
{
createOptions
.
_targetObject
=
_emberHtmlbarsHooksGetValue
.
default
(
parentScope
.
getSelf
(
)
)
;
}
_emberHtmlbarsUtilsExtractPositionalParams
.
default
(
renderNode
component
params
attrs
)
;
component
=
createComponent
(
component
isAngleBracket
createOptions
renderNode
env
attrs
)
;
if
(
!
layout
)
{
layout
=
_emberMetalProperty_get
.
get
(
component
'
layout
'
)
;
}
_emberMetalDebug
.
runInDebug
(
function
(
)
{
if
(
isAngleBracket
)
{
_emberMetalDebug
.
assert
(
'
You
cannot
invoke
the
\
'
'
+
tagName
+
'
\
'
component
with
angle
brackets
because
it
\
'
s
a
subclass
of
Component
.
Please
upgrade
to
GlimmerComponent
.
Alternatively
you
can
invoke
as
\
'
{
{
'
+
tagName
+
'
}
}
\
'
.
'
component
.
isGlimmerComponent
)
;
}
else
{
_emberMetalDebug
.
assert
(
'
You
cannot
invoke
the
\
'
'
+
tagName
+
'
\
'
component
with
curly
braces
because
it
\
'
s
a
subclass
of
GlimmerComponent
.
Please
invoke
it
as
\
'
<
'
+
tagName
+
'
>
\
'
instead
.
'
!
component
.
isGlimmerComponent
)
;
}
if
(
!
layout
)
{
return
;
}
var
fragmentReason
=
layout
.
meta
.
fragmentReason
;
if
(
isAngleBracket
&
&
fragmentReason
)
{
switch
(
fragmentReason
.
name
)
{
case
'
missing
-
wrapper
'
:
_emberMetalDebug
.
assert
(
'
The
<
'
+
tagName
+
'
>
template
must
have
a
single
top
-
level
element
because
it
is
a
GlimmerComponent
.
'
)
;
break
;
case
'
modifiers
'
:
var
modifiers
=
fragmentReason
.
modifiers
.
map
(
function
(
m
)
{
return
'
{
{
'
+
m
+
'
.
.
.
}
}
'
;
}
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
use
'
+
modifiers
.
join
(
'
'
)
+
'
in
the
top
-
level
element
of
the
<
'
+
tagName
+
'
>
template
because
it
is
a
GlimmerComponent
.
'
)
;
break
;
case
'
triple
-
curlies
'
:
_emberMetalDebug
.
assert
(
'
You
cannot
use
triple
curlies
(
e
.
g
.
style
=
{
{
{
.
.
.
}
}
}
)
in
the
top
-
level
element
of
the
<
'
+
tagName
+
'
>
template
because
it
is
a
GlimmerComponent
.
'
)
;
break
;
}
}
}
)
;
var
results
=
_emberViewsSystemBuildComponentTemplate
.
default
(
{
layout
:
layout
component
:
component
isAngleBracket
:
isAngleBracket
}
attrs
{
templates
:
templates
scope
:
parentScope
}
)
;
return
new
ComponentNodeManager
(
component
isAngleBracket
parentScope
renderNode
attrs
results
.
block
results
.
createdElement
)
;
}
;
function
configureTagName
(
attrs
tagName
component
isAngleBracket
createOptions
)
{
if
(
isAngleBracket
)
{
createOptions
.
tagName
=
tagName
;
}
else
if
(
attrs
.
tagName
)
{
createOptions
.
tagName
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
tagName
)
;
}
}
function
configureCreateOptions
(
attrs
createOptions
)
{
if
(
attrs
.
id
)
{
createOptions
.
elementId
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
id
)
;
}
if
(
attrs
.
_defaultTagName
)
{
createOptions
.
_defaultTagName
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
_defaultTagName
)
;
}
if
(
attrs
.
viewName
)
{
createOptions
.
viewName
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
viewName
)
;
}
}
ComponentNodeManager
.
prototype
.
render
=
function
ComponentNodeManager_render
(
_env
visitor
)
{
var
component
=
this
.
component
;
return
_emberHtmlbarsSystemInstrumentationSupport
.
instrument
(
component
function
ComponentNodeManager_render_instrument
(
)
{
var
meta
=
this
.
block
&
&
this
.
block
.
template
.
meta
;
var
env
=
_env
.
childWithView
(
component
meta
)
;
env
.
renderer
.
componentWillRender
(
component
)
;
env
.
renderedViews
.
push
(
component
.
elementId
)
;
if
(
this
.
block
)
{
this
.
block
.
invoke
(
env
[
]
undefined
this
.
renderNode
this
.
scope
visitor
)
;
}
var
element
=
undefined
;
if
(
this
.
expectElement
|
|
component
.
isGlimmerComponent
)
{
element
=
this
.
renderNode
.
firstNode
;
if
(
element
&
&
element
.
nodeType
!
=
=
1
)
{
element
=
nextElementSibling
(
element
)
;
}
}
if
(
env
.
destinedForDOM
)
{
env
.
renderer
.
didCreateElement
(
component
element
)
;
env
.
renderer
.
willInsertElement
(
component
element
)
;
env
.
lifecycleHooks
.
push
(
{
type
:
'
didInsertElement
'
view
:
component
}
)
;
}
}
this
)
;
}
;
function
nextElementSibling
(
node
)
{
var
current
=
node
;
while
(
current
)
{
if
(
current
.
nodeType
=
=
=
1
)
{
return
current
;
}
current
=
node
.
nextSibling
;
}
}
ComponentNodeManager
.
prototype
.
rerender
=
function
ComponentNodeManager_rerender
(
_env
attrs
visitor
)
{
var
component
=
this
.
component
;
return
_emberHtmlbarsSystemInstrumentationSupport
.
instrument
(
component
function
ComponentNodeManager_rerender_instrument
(
)
{
var
env
=
_env
.
childWithView
(
component
)
;
var
snapshot
=
takeSnapshot
(
attrs
)
;
if
(
component
.
_renderNode
.
shouldReceiveAttrs
)
{
if
(
component
.
_propagateAttrsToThis
)
{
component
.
_propagateAttrsToThis
(
takeLegacySnapshot
(
attrs
)
)
;
}
env
.
renderer
.
componentUpdateAttrs
(
component
snapshot
)
;
component
.
_renderNode
.
shouldReceiveAttrs
=
false
;
}
env
.
renderer
.
componentWillUpdate
(
component
snapshot
)
;
env
.
renderer
.
componentWillRender
(
component
)
;
env
.
renderedViews
.
push
(
component
.
elementId
)
;
if
(
this
.
block
)
{
this
.
block
.
invoke
(
env
[
]
undefined
this
.
renderNode
this
.
scope
visitor
)
;
}
env
.
lifecycleHooks
.
push
(
{
type
:
'
didUpdate
'
view
:
component
}
)
;
return
env
;
}
this
)
;
}
;
ComponentNodeManager
.
prototype
.
destroy
=
function
ComponentNodeManager_destroy
(
)
{
var
component
=
this
.
component
;
component
.
_renderNode
=
null
;
component
.
destroy
(
)
;
}
;
function
createComponent
(
_component
isAngleBracket
props
renderNode
env
)
{
var
attrs
=
arguments
.
length
<
=
5
|
|
arguments
[
5
]
=
=
=
undefined
?
{
}
:
arguments
[
5
]
;
if
(
!
isAngleBracket
)
{
_emberMetalDebug
.
assert
(
'
controller
=
is
no
longer
supported
'
!
(
'
controller
'
in
attrs
)
)
;
snapshotAndUpdateTarget
(
attrs
props
)
;
}
else
{
props
.
attrs
=
takeSnapshot
(
attrs
)
;
props
.
_isAngleBracket
=
true
;
}
_containerOwner
.
setOwner
(
props
env
.
owner
)
;
props
.
renderer
=
props
.
parentView
?
props
.
parentView
.
renderer
:
env
.
owner
.
lookup
(
'
renderer
:
-
dom
'
)
;
props
.
_viewRegistry
=
props
.
parentView
?
props
.
parentView
.
_viewRegistry
:
env
.
owner
.
lookup
(
'
-
view
-
registry
:
main
'
)
;
var
component
=
_component
.
create
(
props
)
;
if
(
props
.
parentView
)
{
props
.
parentView
.
appendChild
(
component
)
;
if
(
props
.
viewName
)
{
_emberMetalProperty_set
.
set
(
props
.
parentView
props
.
viewName
component
)
;
}
}
component
.
_renderNode
=
renderNode
;
renderNode
.
emberView
=
component
;
renderNode
.
buildChildEnv
=
buildChildEnv
;
return
component
;
}
function
takeSnapshot
(
attrs
)
{
var
hash
=
{
}
;
for
(
var
prop
in
attrs
)
{
hash
[
prop
]
=
_emberHtmlbarsHooksGetCellOrValue
.
default
(
attrs
[
prop
]
)
;
}
return
hash
;
}
function
takeLegacySnapshot
(
attrs
)
{
var
hash
=
{
}
;
for
(
var
prop
in
attrs
)
{
hash
[
prop
]
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
[
prop
]
)
;
}
return
hash
;
}
function
snapshotAndUpdateTarget
(
rawAttrs
target
)
{
var
attrs
=
{
}
;
for
(
var
prop
in
rawAttrs
)
{
var
value
=
_emberHtmlbarsHooksGetCellOrValue
.
default
(
rawAttrs
[
prop
]
)
;
attrs
[
prop
]
=
value
;
if
(
prop
=
=
=
'
attrs
'
)
{
_emberMetalDebug
.
warn
(
'
Invoking
a
component
with
a
hash
attribute
named
attrs
is
not
supported
.
Please
refactor
usage
of
'
+
target
+
'
to
avoid
passing
attrs
as
a
hash
parameter
.
'
false
{
id
:
'
ember
-
htmlbars
.
component
-
unsupported
-
attrs
'
}
)
;
continue
;
}
if
(
value
&
&
value
[
_emberViewsCompatAttrsProxy
.
MUTABLE_CELL
]
)
{
value
=
value
.
value
;
}
target
[
prop
]
=
value
;
}
return
target
.
attrs
=
attrs
;
}
function
buildChildEnv
(
state
env
)
{
return
env
.
childWithView
(
this
.
emberView
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
node
-
managers
/
view
-
node
-
manager
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
debug
'
'
ember
-
views
/
system
/
build
-
component
-
template
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
set_properties
'
'
ember
-
views
/
views
/
view
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
'
ember
-
htmlbars
/
hooks
/
get
-
cell
-
or
-
value
'
'
ember
-
htmlbars
/
system
/
instrumentation
-
support
'
'
ember
-
htmlbars
/
node
-
managers
/
component
-
node
-
manager
'
'
container
/
owner
'
'
ember
-
htmlbars
/
hooks
/
get
-
value
'
]
function
(
exports
_emberMetalAssign
_emberMetalDebug
_emberViewsSystemBuildComponentTemplate
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalSet_properties
_emberViewsViewsView
_emberViewsCompatAttrsProxy
_emberHtmlbarsHooksGetCellOrValue
_emberHtmlbarsSystemInstrumentationSupport
_emberHtmlbarsNodeManagersComponentNodeManager
_containerOwner
_emberHtmlbarsHooksGetValue
)
{
'
use
strict
'
;
exports
.
createOrUpdateComponent
=
createOrUpdateComponent
;
function
ViewNodeManager
(
component
scope
renderNode
block
expectElement
)
{
this
.
component
=
component
;
this
.
scope
=
scope
;
this
.
renderNode
=
renderNode
;
this
.
block
=
block
;
this
.
expectElement
=
expectElement
;
}
exports
.
default
=
ViewNodeManager
;
ViewNodeManager
.
create
=
function
ViewNodeManager_create
(
renderNode
env
attrs
found
parentView
path
contentScope
contentTemplate
)
{
_emberMetalDebug
.
assert
(
'
HTMLBars
error
:
Could
not
find
component
named
"
'
+
path
+
'
"
(
no
component
or
template
with
that
name
was
found
)
'
!
!
(
function
(
)
{
if
(
path
)
{
return
found
.
component
|
|
found
.
layout
;
}
else
{
return
found
.
component
|
|
found
.
layout
|
|
contentTemplate
;
}
}
)
(
)
)
;
var
component
;
var
componentInfo
=
{
layout
:
found
.
layout
}
;
if
(
found
.
component
)
{
var
options
=
{
parentView
:
parentView
}
;
if
(
attrs
&
&
attrs
.
id
)
{
options
.
elementId
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
id
)
;
}
if
(
attrs
&
&
attrs
.
tagName
)
{
options
.
tagName
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
tagName
)
;
}
if
(
attrs
&
&
attrs
.
_defaultTagName
)
{
options
.
_defaultTagName
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
_defaultTagName
)
;
}
if
(
attrs
&
&
attrs
.
viewName
)
{
options
.
viewName
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
viewName
)
;
}
if
(
found
.
component
.
create
&
&
contentScope
)
{
var
_self
=
contentScope
.
getSelf
(
)
;
if
(
_self
)
{
options
.
_context
=
_emberHtmlbarsHooksGetValue
.
default
(
contentScope
.
getSelf
(
)
)
;
}
}
if
(
found
.
self
)
{
options
.
_context
=
_emberHtmlbarsHooksGetValue
.
default
(
found
.
self
)
;
}
component
=
componentInfo
.
component
=
createOrUpdateComponent
(
found
.
component
options
found
.
createOptions
renderNode
env
attrs
)
;
var
layout
=
_emberMetalProperty_get
.
get
(
component
'
layout
'
)
;
if
(
layout
)
{
componentInfo
.
layout
=
layout
;
}
else
{
componentInfo
.
layout
=
getTemplate
(
component
)
|
|
componentInfo
.
layout
;
}
renderNode
.
emberView
=
component
;
}
_emberMetalDebug
.
assert
(
'
BUG
:
ViewNodeManager
.
create
can
take
a
scope
or
a
self
but
not
both
'
!
(
contentScope
&
&
found
.
self
)
)
;
var
results
=
_emberViewsSystemBuildComponentTemplate
.
default
(
componentInfo
attrs
{
templates
:
{
default
:
contentTemplate
}
scope
:
contentScope
self
:
found
.
self
}
)
;
return
new
ViewNodeManager
(
component
contentScope
renderNode
results
.
block
results
.
createdElement
)
;
}
;
ViewNodeManager
.
prototype
.
render
=
function
ViewNodeManager_render
(
env
attrs
visitor
)
{
var
component
=
this
.
component
;
return
_emberHtmlbarsSystemInstrumentationSupport
.
instrument
(
component
function
ViewNodeManager_render_instrument
(
)
{
var
newEnv
=
env
;
if
(
component
)
{
newEnv
=
env
.
childWithView
(
component
)
;
}
else
{
var
meta
=
this
.
block
&
&
this
.
block
.
template
.
meta
;
newEnv
=
env
.
childWithMeta
(
meta
)
;
}
if
(
component
)
{
env
.
renderer
.
willRender
(
component
)
;
env
.
renderedViews
.
push
(
component
.
elementId
)
;
}
if
(
this
.
block
)
{
this
.
block
.
invoke
(
newEnv
[
]
undefined
this
.
renderNode
this
.
scope
visitor
)
;
}
if
(
component
)
{
var
element
=
this
.
expectElement
&
&
this
.
renderNode
.
firstNode
;
if
(
env
.
destinedForDOM
)
{
env
.
renderer
.
didCreateElement
(
component
element
)
;
env
.
renderer
.
willInsertElement
(
component
element
)
;
env
.
lifecycleHooks
.
push
(
{
type
:
'
didInsertElement
'
view
:
component
}
)
;
}
}
}
this
)
;
}
;
ViewNodeManager
.
prototype
.
rerender
=
function
ViewNodeManager_rerender
(
env
attrs
visitor
)
{
var
component
=
this
.
component
;
return
_emberHtmlbarsSystemInstrumentationSupport
.
instrument
(
component
function
ViewNodeManager_rerender_instrument
(
)
{
var
newEnv
=
env
;
if
(
component
)
{
newEnv
=
env
.
childWithView
(
component
)
;
var
snapshot
=
takeSnapshot
(
attrs
)
;
env
.
renderer
.
willUpdate
(
component
snapshot
)
;
if
(
component
.
_renderNode
.
shouldReceiveAttrs
)
{
if
(
component
.
_propagateAttrsToThis
)
{
component
.
_propagateAttrsToThis
(
_emberHtmlbarsNodeManagersComponentNodeManager
.
takeLegacySnapshot
(
attrs
)
)
;
}
env
.
renderer
.
componentUpdateAttrs
(
component
snapshot
)
;
component
.
_renderNode
.
shouldReceiveAttrs
=
false
;
}
env
.
renderer
.
willRender
(
component
)
;
env
.
renderedViews
.
push
(
component
.
elementId
)
;
}
else
{
var
meta
=
this
.
block
&
&
this
.
block
.
template
.
meta
;
newEnv
=
env
.
childWithMeta
(
meta
)
;
}
if
(
this
.
block
)
{
this
.
block
.
invoke
(
newEnv
[
]
undefined
this
.
renderNode
this
.
scope
visitor
)
;
}
return
newEnv
;
}
this
)
;
}
;
ViewNodeManager
.
prototype
.
destroy
=
function
ViewNodeManager_destroy
(
)
{
if
(
this
.
component
)
{
this
.
component
.
destroy
(
)
;
this
.
component
=
null
;
}
}
;
function
getTemplate
(
componentOrView
)
{
if
(
!
componentOrView
.
isComponent
)
{
return
_emberMetalProperty_get
.
get
(
componentOrView
'
template
'
)
;
}
return
null
;
}
function
createOrUpdateComponent
(
component
options
createOptions
renderNode
env
)
{
var
attrs
=
arguments
.
length
<
=
5
|
|
arguments
[
5
]
=
=
=
undefined
?
{
}
:
arguments
[
5
]
;
var
snapshot
=
takeSnapshot
(
attrs
)
;
var
props
=
_emberMetalAssign
.
default
(
{
}
options
)
;
var
defaultController
=
_emberViewsViewsView
.
default
.
proto
(
)
.
controller
;
var
hasSuppliedController
=
'
controller
'
in
attrs
|
|
'
controller
'
in
props
;
if
(
!
props
.
ownerView
&
&
options
.
parentView
)
{
props
.
ownerView
=
options
.
parentView
.
ownerView
;
}
props
.
attrs
=
snapshot
;
if
(
component
.
create
)
{
var
proto
=
component
.
proto
(
)
;
if
(
createOptions
)
{
_emberMetalAssign
.
default
(
props
createOptions
)
;
}
mergeBindings
(
props
snapshot
)
;
var
owner
=
env
.
owner
;
_containerOwner
.
setOwner
(
props
owner
)
;
props
.
renderer
=
options
.
parentView
?
options
.
parentView
.
renderer
:
owner
&
&
owner
.
lookup
(
'
renderer
:
-
dom
'
)
;
props
.
_viewRegistry
=
options
.
parentView
?
options
.
parentView
.
_viewRegistry
:
owner
&
&
owner
.
lookup
(
'
-
view
-
registry
:
main
'
)
;
if
(
proto
.
controller
!
=
=
defaultController
|
|
hasSuppliedController
)
{
delete
props
.
_context
;
}
component
=
component
.
create
(
props
)
;
}
else
{
env
.
renderer
.
componentUpdateAttrs
(
component
snapshot
)
;
_emberMetalSet_properties
.
default
(
component
props
)
;
if
(
component
.
_propagateAttrsToThis
)
{
component
.
_propagateAttrsToThis
(
_emberHtmlbarsNodeManagersComponentNodeManager
.
takeLegacySnapshot
(
attrs
)
)
;
}
}
if
(
options
.
parentView
)
{
options
.
parentView
.
appendChild
(
component
)
;
if
(
options
.
viewName
)
{
_emberMetalProperty_set
.
set
(
options
.
parentView
options
.
viewName
component
)
;
}
}
component
.
_renderNode
=
renderNode
;
renderNode
.
emberView
=
component
;
return
component
;
}
function
takeSnapshot
(
attrs
)
{
var
hash
=
{
}
;
for
(
var
prop
in
attrs
)
{
hash
[
prop
]
=
_emberHtmlbarsHooksGetCellOrValue
.
default
(
attrs
[
prop
]
)
;
}
return
hash
;
}
function
mergeBindings
(
target
attrs
)
{
for
(
var
prop
in
attrs
)
{
if
(
!
attrs
.
hasOwnProperty
(
prop
)
)
{
continue
;
}
if
(
prop
=
=
=
'
attrs
'
)
{
_emberMetalDebug
.
warn
(
'
Invoking
a
component
with
a
hash
attribute
named
attrs
is
not
supported
.
Please
refactor
usage
of
'
+
target
+
'
to
avoid
passing
attrs
as
a
hash
parameter
.
'
false
{
id
:
'
ember
-
htmlbars
.
view
-
unsupported
-
attrs
'
}
)
;
continue
;
}
var
value
=
attrs
[
prop
]
;
if
(
value
&
&
value
[
_emberViewsCompatAttrsProxy
.
MUTABLE_CELL
]
)
{
target
[
prop
]
=
value
.
value
;
}
else
{
target
[
prop
]
=
value
;
}
}
return
target
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
streams
/
built
-
in
-
helper
'
[
'
exports
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
htmlbars
/
streams
/
utils
'
]
function
(
exports
_emberMetalStreamsStream
_emberHtmlbarsStreamsUtils
)
{
'
use
strict
'
;
var
BuiltInHelperStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
helper
params
hash
templates
env
scope
label
)
{
this
.
helper
=
helper
;
this
.
params
=
params
;
this
.
templates
=
templates
;
this
.
env
=
env
;
this
.
scope
=
scope
;
this
.
hash
=
hash
;
this
.
label
=
label
;
}
compute
:
function
(
)
{
return
this
.
helper
(
_emberHtmlbarsStreamsUtils
.
getArrayValues
(
this
.
params
)
_emberHtmlbarsStreamsUtils
.
getHashValues
(
this
.
hash
)
this
.
templates
this
.
env
this
.
scope
)
;
}
}
)
;
exports
.
default
=
BuiltInHelperStream
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
streams
/
helper
-
factory
'
[
'
exports
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
htmlbars
/
streams
/
utils
'
]
function
(
exports
_emberMetalStreamsStream
_emberHtmlbarsStreamsUtils
)
{
'
use
strict
'
;
var
HelperFactoryStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
helperFactory
params
hash
label
)
{
this
.
helperFactory
=
helperFactory
;
this
.
params
=
params
;
this
.
hash
=
hash
;
this
.
linkable
=
true
;
this
.
helper
=
null
;
this
.
label
=
label
;
}
compute
:
function
(
)
{
if
(
!
this
.
helper
)
{
this
.
helper
=
this
.
helperFactory
.
create
(
{
_stream
:
this
}
)
;
}
return
this
.
helper
.
compute
(
_emberHtmlbarsStreamsUtils
.
getArrayValues
(
this
.
params
)
_emberHtmlbarsStreamsUtils
.
getHashValues
(
this
.
hash
)
)
;
}
deactivate
:
function
(
)
{
this
.
super
deactivate
(
)
;
if
(
this
.
helper
)
{
this
.
helper
.
destroy
(
)
;
this
.
helper
=
null
;
}
}
super
deactivate
:
_emberMetalStreamsStream
.
default
.
prototype
.
deactivate
}
)
;
exports
.
default
=
HelperFactoryStream
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
streams
/
helper
-
instance
'
[
'
exports
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
htmlbars
/
streams
/
utils
'
]
function
(
exports
_emberMetalStreamsStream
_emberHtmlbarsStreamsUtils
)
{
'
use
strict
'
;
var
HelperInstanceStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
helper
params
hash
label
)
{
this
.
helper
=
helper
;
this
.
params
=
params
;
this
.
hash
=
hash
;
this
.
linkable
=
true
;
this
.
label
=
label
;
}
compute
:
function
(
)
{
return
this
.
helper
.
compute
(
_emberHtmlbarsStreamsUtils
.
getArrayValues
(
this
.
params
)
_emberHtmlbarsStreamsUtils
.
getHashValues
(
this
.
hash
)
)
;
}
}
)
;
exports
.
default
=
HelperInstanceStream
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
streams
/
utils
'
[
'
exports
'
'
ember
-
htmlbars
/
hooks
/
get
-
value
'
]
function
(
exports
_emberHtmlbarsHooksGetValue
)
{
'
use
strict
'
;
exports
.
getArrayValues
=
getArrayValues
;
exports
.
getHashValues
=
getHashValues
;
function
getArrayValues
(
params
)
{
var
l
=
params
.
length
;
var
out
=
new
Array
(
l
)
;
for
(
var
i
=
0
;
i
<
l
;
i
+
+
)
{
out
[
i
]
=
_emberHtmlbarsHooksGetValue
.
default
(
params
[
i
]
)
;
}
return
out
;
}
function
getHashValues
(
hash
)
{
var
out
=
{
}
;
for
(
var
prop
in
hash
)
{
out
[
prop
]
=
_emberHtmlbarsHooksGetValue
.
default
(
hash
[
prop
]
)
;
}
return
out
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
append
-
templated
-
view
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
views
/
views
/
view
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberViewsViewsView
)
{
'
use
strict
'
;
exports
.
default
=
appendTemplatedView
;
function
appendTemplatedView
(
parentView
morph
viewClassOrInstance
props
)
{
var
viewProto
;
if
(
_emberViewsViewsView
.
default
.
detectInstance
(
viewClassOrInstance
)
)
{
viewProto
=
viewClassOrInstance
;
}
else
{
viewProto
=
viewClassOrInstance
.
proto
(
)
;
}
_emberMetalDebug
.
assert
(
'
You
cannot
provide
a
template
block
if
you
also
specified
a
templateName
'
!
props
.
template
|
|
!
_emberMetalProperty_get
.
get
(
props
'
templateName
'
)
&
&
!
_emberMetalProperty_get
.
get
(
viewProto
'
templateName
'
)
)
;
var
noControllerInProto
=
!
viewProto
.
controller
;
if
(
viewProto
.
controller
&
&
viewProto
.
controller
.
isDescriptor
)
{
noControllerInProto
=
true
;
}
if
(
noControllerInProto
&
&
!
viewProto
.
controllerBinding
&
&
!
props
.
controller
&
&
!
props
.
controllerBinding
)
{
props
.
_context
=
_emberMetalProperty_get
.
get
(
parentView
'
context
'
)
;
}
props
.
_morph
=
morph
;
return
parentView
.
appendChild
(
viewClassOrInstance
props
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
bootstrap
'
[
'
exports
'
'
ember
-
views
/
component_lookup
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
metal
/
error
'
'
ember
-
runtime
/
system
/
lazy_load
'
'
ember
-
template
-
compiler
/
system
/
compile
'
'
ember
-
metal
/
environment
'
'
ember
-
htmlbars
/
template_registry
'
]
function
(
exports
_emberViewsComponent_lookup
_emberViewsSystemJquery
_emberMetalError
_emberRuntimeSystemLazy_load
_emberTemplateCompilerSystemCompile
_emberMetalEnvironment
_emberHtmlbarsTemplate_registry
)
{
'
use
strict
'
;
function
bootstrap
(
ctx
)
{
var
selectors
=
'
script
[
type
=
"
text
/
x
-
handlebars
"
]
script
[
type
=
"
text
/
x
-
raw
-
handlebars
"
]
'
;
_emberViewsSystemJquery
.
default
(
selectors
ctx
)
.
each
(
function
(
)
{
var
script
=
_emberViewsSystemJquery
.
default
(
this
)
;
var
templateName
=
script
.
attr
(
'
data
-
template
-
name
'
)
|
|
script
.
attr
(
'
id
'
)
|
|
'
application
'
;
var
template
compile
;
if
(
script
.
attr
(
'
type
'
)
=
=
=
'
text
/
x
-
raw
-
handlebars
'
)
{
compile
=
_emberViewsSystemJquery
.
default
.
proxy
(
Handlebars
.
compile
Handlebars
)
;
template
=
compile
(
script
.
html
(
)
)
;
}
else
{
template
=
_emberTemplateCompilerSystemCompile
.
default
(
script
.
html
(
)
{
moduleName
:
templateName
}
)
;
}
if
(
_emberHtmlbarsTemplate_registry
.
has
(
templateName
)
)
{
throw
new
_emberMetalError
.
default
(
'
Template
named
"
'
+
templateName
+
'
"
already
exists
.
'
)
;
}
_emberHtmlbarsTemplate_registry
.
set
(
templateName
template
)
;
script
.
remove
(
)
;
}
)
;
}
function
_bootstrap
(
)
{
bootstrap
(
_emberViewsSystemJquery
.
default
(
document
)
)
;
}
function
registerComponentLookup
(
app
)
{
app
.
register
(
'
component
-
lookup
:
main
'
_emberViewsComponent_lookup
.
default
)
;
}
_emberRuntimeSystemLazy_load
.
onLoad
(
'
Ember
.
Application
'
function
(
Application
)
{
Application
.
initializer
(
{
name
:
'
domTemplates
'
initialize
:
_emberMetalEnvironment
.
default
.
hasDOM
?
_bootstrap
:
function
(
)
{
}
}
)
;
Application
.
instanceInitializer
(
{
name
:
'
registerComponentLookup
'
initialize
:
registerComponentLookup
}
)
;
}
)
;
exports
.
default
=
bootstrap
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
dom
-
helper
'
[
'
exports
'
'
dom
-
helper
'
'
ember
-
htmlbars
/
morphs
/
morph
'
'
ember
-
htmlbars
/
morphs
/
attr
-
morph
'
]
function
(
exports
_domHelper
_emberHtmlbarsMorphsMorph
_emberHtmlbarsMorphsAttrMorph
)
{
'
use
strict
'
;
function
EmberDOMHelper
(
_document
)
{
_domHelper
.
default
.
call
(
this
_document
)
;
}
var
proto
=
EmberDOMHelper
.
prototype
=
Object
.
create
(
_domHelper
.
default
.
prototype
)
;
proto
.
MorphClass
=
_emberHtmlbarsMorphsMorph
.
default
;
proto
.
AttrMorphClass
=
_emberHtmlbarsMorphsAttrMorph
.
default
;
exports
.
default
=
EmberDOMHelper
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
instrumentation
-
support
'
[
'
exports
'
'
ember
-
metal
/
instrumentation
'
]
function
(
exports
_emberMetalInstrumentation
)
{
'
use
strict
'
;
exports
.
instrument
=
instrument
;
function
instrument
(
component
callback
context
)
{
var
instrumentName
val
details
end
;
if
(
_emberMetalInstrumentation
.
subscribers
.
length
)
{
if
(
component
)
{
instrumentName
=
component
.
instrumentName
;
}
else
{
instrumentName
=
'
node
'
;
}
details
=
{
}
;
if
(
component
)
{
component
.
instrumentDetails
(
details
)
;
}
end
=
_emberMetalInstrumentation
.
_instrumentStart
(
'
render
.
'
+
instrumentName
function
viewInstrumentDetails
(
)
{
return
details
;
}
)
;
val
=
callback
.
call
(
context
)
;
if
(
end
)
{
end
(
)
;
}
return
val
;
}
else
{
return
callback
.
call
(
context
)
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
invoke
-
helper
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
htmlbars
/
streams
/
helper
-
instance
'
'
ember
-
htmlbars
/
streams
/
helper
-
factory
'
'
ember
-
htmlbars
/
streams
/
built
-
in
-
helper
'
]
function
(
exports
_emberMetalDebug
_emberHtmlbarsStreamsHelperInstance
_emberHtmlbarsStreamsHelperFactory
_emberHtmlbarsStreamsBuiltInHelper
)
{
'
use
strict
'
;
exports
.
buildHelperStream
=
buildHelperStream
;
function
buildHelperStream
(
helper
params
hash
templates
env
scope
label
)
{
var
isAnyKindOfHelper
=
helper
.
isHelperInstance
|
|
helper
.
isHelperFactory
;
_emberMetalDebug
.
assert
(
'
Helpers
may
not
be
used
in
the
block
form
for
example
{
{
#
my
-
helper
}
}
{
{
/
my
-
helper
}
}
.
Please
use
a
component
or
alternatively
use
the
helper
in
combination
with
a
built
-
in
Ember
helper
for
example
{
{
#
if
(
my
-
helper
)
}
}
{
{
/
if
}
}
.
'
!
(
isAnyKindOfHelper
&
&
templates
&
&
templates
.
template
&
&
templates
.
template
.
meta
)
)
;
_emberMetalDebug
.
assert
(
'
Helpers
may
not
be
used
in
the
element
form
for
example
<
div
{
{
my
-
helper
}
}
>
.
'
!
(
isAnyKindOfHelper
&
&
templates
&
&
templates
.
element
)
)
;
if
(
helper
.
isHelperFactory
)
{
return
new
_emberHtmlbarsStreamsHelperFactory
.
default
(
helper
params
hash
label
)
;
}
else
if
(
helper
.
isHelperInstance
)
{
return
new
_emberHtmlbarsStreamsHelperInstance
.
default
(
helper
params
hash
label
)
;
}
else
{
templates
=
templates
|
|
{
template
:
{
}
inverse
:
{
}
}
;
return
new
_emberHtmlbarsStreamsBuiltInHelper
.
default
(
helper
params
hash
templates
env
scope
label
)
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
cache
'
]
function
(
exports
_emberMetalDebug
_emberMetalCache
)
{
'
use
strict
'
;
exports
.
validateLazyHelperName
=
validateLazyHelperName
;
exports
.
findHelper
=
findHelper
;
exports
.
default
=
lookupHelper
;
var
CONTAINS_DASH_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
key
.
indexOf
(
'
-
'
)
!
=
=
-
1
;
}
)
;
exports
.
CONTAINS_DASH_CACHE
=
CONTAINS_DASH_CACHE
;
var
CONTAINS_DOT_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
key
.
indexOf
(
'
.
'
)
!
=
=
-
1
;
}
)
;
exports
.
CONTAINS_DOT_CACHE
=
CONTAINS_DOT_CACHE
;
function
validateLazyHelperName
(
helperName
container
keywords
)
{
return
container
&
&
!
(
helperName
in
keywords
)
;
}
function
_findHelper
(
name
view
env
options
)
{
var
helper
=
env
.
helpers
[
name
]
;
if
(
!
helper
)
{
var
owner
=
env
.
owner
;
if
(
validateLazyHelperName
(
name
owner
env
.
hooks
.
keywords
)
)
{
var
helperName
=
'
helper
:
'
+
name
;
var
registered
=
owner
.
hasRegistration
(
helperName
options
)
;
if
(
registered
)
{
helper
=
owner
.
_lookupFactory
(
helperName
options
)
;
_emberMetalDebug
.
assert
(
'
Expected
to
find
an
Ember
.
Helper
with
the
name
'
+
helperName
+
'
but
found
an
object
of
type
'
+
typeof
helper
+
'
instead
.
'
helper
.
isHelperFactory
|
|
helper
.
isHelperInstance
)
;
}
}
}
return
helper
;
}
function
findHelper
(
name
view
env
)
{
var
options
=
{
}
;
var
moduleName
=
env
.
meta
&
&
env
.
meta
.
moduleName
;
if
(
moduleName
)
{
options
.
source
=
'
template
:
'
+
moduleName
;
}
var
localHelper
=
_findHelper
(
name
view
env
options
)
;
if
(
localHelper
)
{
return
localHelper
;
}
return
_findHelper
(
name
view
env
)
;
}
function
lookupHelper
(
name
view
env
)
{
var
helper
=
findHelper
(
name
view
env
)
;
_emberMetalDebug
.
assert
(
'
A
helper
named
\
'
'
+
name
+
'
\
'
could
not
be
found
'
!
!
helper
)
;
return
helper
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
make_bound_helper
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
htmlbars
/
helper
'
]
function
(
exports
_emberMetalDebug
_emberHtmlbarsHelper
)
{
'
use
strict
'
;
exports
.
default
=
makeBoundHelper
;
function
makeBoundHelper
(
fn
)
{
_emberMetalDebug
.
deprecate
(
'
Using
Ember
.
HTMLBars
.
makeBoundHelper
is
deprecated
.
Please
refactor
to
use
Ember
.
Helper
or
Ember
.
Helper
.
helper
.
'
false
{
id
:
'
ember
-
htmlbars
.
make
-
bound
-
helper
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_emberHtmlbarsHelper
.
helper
(
fn
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
render
-
env
'
[
'
exports
'
'
ember
-
htmlbars
/
env
'
'
ember
-
metal
-
views
'
'
container
/
owner
'
]
function
(
exports
_emberHtmlbarsEnv
_emberMetalViews
_containerOwner
)
{
'
use
strict
'
;
exports
.
default
=
RenderEnv
;
function
RenderEnv
(
options
)
{
this
.
lifecycleHooks
=
options
.
lifecycleHooks
|
|
[
]
;
this
.
renderedViews
=
options
.
renderedViews
|
|
[
]
;
this
.
renderedNodes
=
options
.
renderedNodes
|
|
new
_emberMetalViews
.
MorphSet
(
)
;
this
.
hasParentOutlet
=
options
.
hasParentOutlet
|
|
false
;
this
.
view
=
options
.
view
;
this
.
outletState
=
options
.
outletState
;
this
.
owner
=
options
.
owner
;
this
.
renderer
=
options
.
renderer
;
this
.
dom
=
options
.
dom
;
this
.
meta
=
options
.
meta
;
this
.
hooks
=
_emberHtmlbarsEnv
.
default
.
hooks
;
this
.
helpers
=
_emberHtmlbarsEnv
.
default
.
helpers
;
this
.
useFragmentCache
=
_emberHtmlbarsEnv
.
default
.
useFragmentCache
;
this
.
destinedForDOM
=
this
.
renderer
.
_destinedForDOM
;
}
RenderEnv
.
build
=
function
(
view
meta
)
{
return
new
RenderEnv
(
{
view
:
view
outletState
:
view
.
outletState
owner
:
_containerOwner
.
getOwner
(
view
)
renderer
:
view
.
renderer
dom
:
view
.
renderer
.
_dom
meta
:
meta
}
)
;
}
;
RenderEnv
.
prototype
.
childWithMeta
=
function
(
meta
)
{
return
new
RenderEnv
(
{
view
:
this
.
view
outletState
:
this
.
outletState
owner
:
this
.
owner
renderer
:
this
.
renderer
dom
:
this
.
dom
lifecycleHooks
:
this
.
lifecycleHooks
renderedViews
:
this
.
renderedViews
renderedNodes
:
this
.
renderedNodes
hasParentOutlet
:
this
.
hasParentOutlet
meta
:
meta
}
)
;
}
;
RenderEnv
.
prototype
.
childWithView
=
function
(
view
)
{
var
meta
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
this
.
meta
:
arguments
[
1
]
;
return
new
RenderEnv
(
{
view
:
view
outletState
:
this
.
outletState
owner
:
this
.
owner
renderer
:
this
.
renderer
dom
:
this
.
dom
lifecycleHooks
:
this
.
lifecycleHooks
renderedViews
:
this
.
renderedViews
renderedNodes
:
this
.
renderedNodes
hasParentOutlet
:
this
.
hasParentOutlet
meta
:
meta
}
)
;
}
;
RenderEnv
.
prototype
.
childWithOutletState
=
function
(
outletState
)
{
var
hasParentOutlet
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
this
.
hasParentOutlet
:
arguments
[
1
]
;
var
meta
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
this
.
meta
:
arguments
[
2
]
;
return
new
RenderEnv
(
{
view
:
this
.
view
outletState
:
outletState
owner
:
this
.
owner
renderer
:
this
.
renderer
dom
:
this
.
dom
lifecycleHooks
:
this
.
lifecycleHooks
renderedViews
:
this
.
renderedViews
renderedNodes
:
this
.
renderedNodes
hasParentOutlet
:
hasParentOutlet
meta
:
meta
}
)
;
}
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
system
/
render
-
view
'
[
'
exports
'
'
ember
-
htmlbars
/
node
-
managers
/
view
-
node
-
manager
'
'
ember
-
htmlbars
/
system
/
render
-
env
'
]
function
(
exports
_emberHtmlbarsNodeManagersViewNodeManager
_emberHtmlbarsSystemRenderEnv
)
{
'
use
strict
'
;
exports
.
renderHTMLBarsBlock
=
renderHTMLBarsBlock
;
function
renderHTMLBarsBlock
(
view
block
renderNode
)
{
var
meta
=
block
&
&
block
.
template
&
&
block
.
template
.
meta
;
var
env
=
_emberHtmlbarsSystemRenderEnv
.
default
.
build
(
view
meta
)
;
view
.
env
=
env
;
_emberHtmlbarsNodeManagersViewNodeManager
.
createOrUpdateComponent
(
view
{
}
null
renderNode
env
)
;
var
nodeManager
=
new
_emberHtmlbarsNodeManagersViewNodeManager
.
default
(
view
null
renderNode
block
view
.
tagName
!
=
=
'
'
)
;
nodeManager
.
render
(
env
{
}
)
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
template_registry
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
setTemplates
=
setTemplates
;
exports
.
getTemplates
=
getTemplates
;
exports
.
get
=
get
;
exports
.
has
=
has
;
exports
.
set
=
set
;
var
TEMPLATES
=
{
}
;
function
setTemplates
(
templates
)
{
TEMPLATES
=
templates
;
}
function
getTemplates
(
)
{
return
TEMPLATES
;
}
function
get
(
name
)
{
if
(
TEMPLATES
.
hasOwnProperty
(
name
)
)
{
return
TEMPLATES
[
name
]
;
}
}
function
has
(
name
)
{
return
TEMPLATES
.
hasOwnProperty
(
name
)
;
}
function
set
(
name
template
)
{
return
TEMPLATES
[
name
]
=
template
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
templates
/
component
"
[
"
exports
"
"
ember
-
template
-
compiler
/
system
/
template
"
]
function
(
exports
_emberTemplateCompilerSystemTemplate
)
{
"
use
strict
"
;
exports
.
default
=
_emberTemplateCompilerSystemTemplate
.
default
(
(
function
(
)
{
return
{
meta
:
{
}
isEmpty
:
false
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
var
el1
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
contextualElement
)
{
var
morphs
=
new
Array
(
1
)
;
morphs
[
0
]
=
dom
.
createMorphAt
(
fragment
0
0
contextualElement
)
;
dom
.
insertBoundary
(
fragment
0
)
;
dom
.
insertBoundary
(
fragment
null
)
;
return
morphs
;
}
statements
:
[
[
"
content
"
"
yield
"
[
"
loc
"
[
null
[
1
0
]
[
1
9
]
]
]
]
]
locals
:
[
]
templates
:
[
]
}
;
}
)
(
)
)
;
}
)
;
enifed
(
"
ember
-
htmlbars
/
templates
/
empty
"
[
"
exports
"
"
ember
-
template
-
compiler
/
system
/
template
"
]
function
(
exports
_emberTemplateCompilerSystemTemplate
)
{
"
use
strict
"
;
exports
.
default
=
_emberTemplateCompilerSystemTemplate
.
default
(
(
function
(
)
{
return
{
meta
:
{
}
isEmpty
:
true
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
)
{
return
[
]
;
}
statements
:
[
]
locals
:
[
]
templates
:
[
]
}
;
}
)
(
)
)
;
}
)
;
enifed
(
"
ember
-
htmlbars
/
templates
/
link
-
to
"
[
"
exports
"
"
ember
-
template
-
compiler
/
system
/
template
"
]
function
(
exports
_emberTemplateCompilerSystemTemplate
)
{
"
use
strict
"
;
exports
.
default
=
_emberTemplateCompilerSystemTemplate
.
default
(
(
function
(
)
{
var
child0
=
(
function
(
)
{
return
{
meta
:
{
}
isEmpty
:
false
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
var
el1
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
contextualElement
)
{
var
morphs
=
new
Array
(
1
)
;
morphs
[
0
]
=
dom
.
createMorphAt
(
fragment
0
0
contextualElement
)
;
dom
.
insertBoundary
(
fragment
0
)
;
dom
.
insertBoundary
(
fragment
null
)
;
return
morphs
;
}
statements
:
[
[
"
content
"
"
linkTitle
"
[
"
loc
"
[
null
[
1
17
]
[
1
30
]
]
]
]
]
locals
:
[
]
templates
:
[
]
}
;
}
)
(
)
;
var
child1
=
(
function
(
)
{
return
{
meta
:
{
}
isEmpty
:
false
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
var
el1
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
contextualElement
)
{
var
morphs
=
new
Array
(
1
)
;
morphs
[
0
]
=
dom
.
createMorphAt
(
fragment
0
0
contextualElement
)
;
dom
.
insertBoundary
(
fragment
0
)
;
dom
.
insertBoundary
(
fragment
null
)
;
return
morphs
;
}
statements
:
[
[
"
content
"
"
yield
"
[
"
loc
"
[
null
[
1
38
]
[
1
47
]
]
]
]
]
locals
:
[
]
templates
:
[
]
}
;
}
)
(
)
;
return
{
meta
:
{
}
isEmpty
:
false
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
var
el1
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
contextualElement
)
{
var
morphs
=
new
Array
(
1
)
;
morphs
[
0
]
=
dom
.
createMorphAt
(
fragment
0
0
contextualElement
)
;
dom
.
insertBoundary
(
fragment
0
)
;
dom
.
insertBoundary
(
fragment
null
)
;
return
morphs
;
}
statements
:
[
[
"
block
"
"
if
"
[
[
"
get
"
"
linkTitle
"
[
"
loc
"
[
null
[
1
6
]
[
1
15
]
]
]
]
]
[
]
0
1
[
"
loc
"
[
null
[
1
0
]
[
1
54
]
]
]
]
]
locals
:
[
]
templates
:
[
child0
child1
]
}
;
}
)
(
)
)
;
}
)
;
enifed
(
"
ember
-
htmlbars
/
templates
/
top
-
level
-
view
"
[
"
exports
"
"
ember
-
template
-
compiler
/
system
/
template
"
]
function
(
exports
_emberTemplateCompilerSystemTemplate
)
{
"
use
strict
"
;
exports
.
default
=
_emberTemplateCompilerSystemTemplate
.
default
(
(
function
(
)
{
return
{
meta
:
{
}
isEmpty
:
false
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
var
el1
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
contextualElement
)
{
var
morphs
=
new
Array
(
1
)
;
morphs
[
0
]
=
dom
.
createMorphAt
(
fragment
0
0
contextualElement
)
;
dom
.
insertBoundary
(
fragment
0
)
;
dom
.
insertBoundary
(
fragment
null
)
;
return
morphs
;
}
statements
:
[
[
"
content
"
"
outlet
"
[
"
loc
"
[
null
[
1
0
]
[
1
10
]
]
]
]
]
locals
:
[
]
templates
:
[
]
}
;
}
)
(
)
)
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
decode
-
each
-
key
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
utils
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalUtils
)
{
'
use
strict
'
;
exports
.
default
=
decodeEachKey
;
function
identity
(
item
)
{
var
key
=
undefined
;
var
type
=
typeof
item
;
if
(
type
=
=
=
'
string
'
|
|
type
=
=
=
'
number
'
)
{
key
=
item
;
}
else
{
key
=
_emberMetalUtils
.
guidFor
(
item
)
;
}
return
key
;
}
function
decodeEachKey
(
item
keyPath
index
)
{
var
key
;
switch
(
keyPath
)
{
case
'
index
'
:
key
=
index
;
break
;
case
'
identity
'
:
key
=
identity
(
item
)
;
break
;
default
:
if
(
keyPath
)
{
key
=
_emberMetalProperty_get
.
get
(
item
keyPath
)
;
}
else
{
key
=
identity
(
item
)
;
}
}
if
(
typeof
key
=
=
=
'
number
'
)
{
key
=
String
(
key
)
;
}
return
key
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
extract
-
positional
-
params
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalDebug
_emberMetalStreamsStream
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
extractPositionalParams
;
exports
.
processPositionalParams
=
processPositionalParams
;
function
extractPositionalParams
(
renderNode
component
params
attrs
)
{
var
raiseAssertions
=
arguments
.
length
<
=
4
|
|
arguments
[
4
]
=
=
=
undefined
?
true
:
arguments
[
4
]
;
var
positionalParams
=
component
.
positionalParams
;
if
(
positionalParams
)
{
processPositionalParams
(
renderNode
positionalParams
params
attrs
raiseAssertions
)
;
}
}
function
processPositionalParams
(
renderNode
positionalParams
params
attrs
)
{
var
raiseAssertions
=
arguments
.
length
<
=
4
|
|
arguments
[
4
]
=
=
=
undefined
?
true
:
arguments
[
4
]
;
var
isRest
=
typeof
positionalParams
=
=
=
'
string
'
;
if
(
isRest
)
{
processRestPositionalParameters
(
renderNode
positionalParams
params
attrs
raiseAssertions
)
;
}
else
{
processNamedPositionalParameters
(
renderNode
positionalParams
params
attrs
raiseAssertions
)
;
}
}
function
processNamedPositionalParameters
(
renderNode
positionalParams
params
attrs
raiseAssertions
)
{
var
limit
=
Math
.
min
(
params
.
length
positionalParams
.
length
)
;
for
(
var
i
=
0
;
i
<
limit
;
i
+
+
)
{
var
param
=
params
[
i
]
;
_emberMetalDebug
.
assert
(
'
You
cannot
specify
both
a
positional
param
(
at
position
'
+
i
+
'
)
and
the
hash
argument
'
+
positionalParams
[
i
]
+
'
.
'
!
(
positionalParams
[
i
]
in
attrs
&
&
raiseAssertions
)
)
;
attrs
[
positionalParams
[
i
]
]
=
param
;
}
}
function
processRestPositionalParameters
(
renderNode
positionalParamsName
params
attrs
raiseAssertions
)
{
var
nameInAttrs
=
(
positionalParamsName
in
attrs
)
;
if
(
params
.
length
=
=
=
0
&
&
nameInAttrs
)
{
return
;
}
_emberMetalDebug
.
assert
(
'
You
cannot
specify
positional
parameters
and
the
hash
argument
'
+
positionalParamsName
+
'
.
'
!
(
nameInAttrs
&
&
raiseAssertions
)
)
;
var
paramsStream
=
new
_emberMetalStreamsStream
.
Stream
(
function
(
)
{
return
_emberMetalStreamsUtils
.
readArray
(
params
.
slice
(
0
)
)
;
}
'
params
'
)
;
attrs
[
positionalParamsName
]
=
paramsStream
;
for
(
var
i
=
0
;
i
<
params
.
length
;
i
+
+
)
{
var
param
=
params
[
i
]
;
paramsStream
.
addDependency
(
param
)
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
is
-
component
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
'
ember
-
htmlbars
/
keywords
/
closure
-
component
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalFeatures
_emberHtmlbarsSystemLookupHelper
_emberHtmlbarsKeywordsClosureComponent
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
isComponent
;
function
hasComponentOrTemplate
(
owner
path
options
)
{
return
owner
.
hasRegistration
(
'
component
:
'
+
path
options
)
|
|
owner
.
hasRegistration
(
'
template
:
components
/
'
+
path
options
)
;
}
function
isComponent
(
env
scope
path
)
{
var
owner
=
env
.
owner
;
if
(
!
owner
)
{
return
false
;
}
if
(
typeof
path
=
=
=
'
string
'
)
{
if
(
_emberHtmlbarsSystemLookupHelper
.
CONTAINS_DOT_CACHE
.
get
(
path
)
)
{
var
stream
=
env
.
hooks
.
get
(
env
scope
path
)
;
if
(
_emberMetalStreamsUtils
.
isStream
(
stream
)
)
{
var
cell
=
stream
.
value
(
)
;
if
(
_emberHtmlbarsKeywordsClosureComponent
.
isComponentCell
(
cell
)
)
{
return
true
;
}
}
}
if
(
!
_emberHtmlbarsSystemLookupHelper
.
CONTAINS_DASH_CACHE
.
get
(
path
)
)
{
return
false
;
}
if
(
hasComponentOrTemplate
(
owner
path
)
)
{
return
true
;
}
else
{
var
moduleName
=
env
.
meta
&
&
env
.
meta
.
moduleName
;
if
(
!
moduleName
)
{
return
false
;
}
var
options
=
{
source
:
'
template
:
'
+
moduleName
}
;
return
hasComponentOrTemplate
(
owner
path
options
)
;
}
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
lookup
-
component
'
[
'
exports
'
'
ember
-
metal
/
features
'
]
function
(
exports
_emberMetalFeatures
)
{
'
use
strict
'
;
exports
.
default
=
lookupComponent
;
function
lookupComponentPair
(
componentLookup
owner
name
options
)
{
return
{
component
:
componentLookup
.
componentFor
(
name
owner
options
)
layout
:
componentLookup
.
layoutFor
(
name
owner
options
)
}
;
}
function
lookupComponent
(
owner
name
options
)
{
var
componentLookup
=
owner
.
lookup
(
'
component
-
lookup
:
main
'
)
;
var
source
=
options
&
&
options
.
source
;
if
(
source
)
{
var
localResult
=
lookupComponentPair
(
componentLookup
owner
name
options
)
;
if
(
localResult
.
component
|
|
localResult
.
layout
)
{
return
localResult
;
}
}
return
lookupComponentPair
(
componentLookup
owner
name
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
new
-
stream
'
[
'
exports
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
'
ember
-
htmlbars
/
utils
/
subscribe
'
]
function
(
exports
_emberMetalStreamsProxyStream
_emberHtmlbarsUtilsSubscribe
)
{
'
use
strict
'
;
exports
.
default
=
newStream
;
function
newStream
(
scope
key
newValue
renderNode
isSelf
)
{
var
stream
=
new
_emberMetalStreamsProxyStream
.
default
(
newValue
isSelf
?
'
'
:
key
)
;
if
(
renderNode
)
{
_emberHtmlbarsUtilsSubscribe
.
default
(
renderNode
scope
stream
)
;
}
scope
[
key
]
=
stream
;
}
}
)
;
enifed
(
"
ember
-
htmlbars
/
utils
/
normalize
-
self
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
normalizeSelf
;
function
normalizeSelf
(
self
)
{
if
(
self
=
=
=
undefined
)
{
return
null
;
}
else
{
return
self
;
}
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
string
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
runtime
/
system
/
string
'
'
htmlbars
-
util
'
]
function
(
exports
_emberMetalCore
_emberRuntimeSystemString
_htmlbarsUtil
)
{
'
use
strict
'
;
function
htmlSafe
(
str
)
{
if
(
str
=
=
=
null
|
|
str
=
=
=
undefined
)
{
str
=
'
'
;
}
else
if
(
typeof
str
!
=
=
'
string
'
)
{
str
=
'
'
+
str
;
}
return
new
_htmlbarsUtil
.
SafeString
(
str
)
;
}
_emberRuntimeSystemString
.
default
.
htmlSafe
=
htmlSafe
;
if
(
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
=
=
=
true
|
|
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
.
String
)
{
String
.
prototype
.
htmlSafe
=
function
(
)
{
return
htmlSafe
(
this
)
;
}
;
}
exports
.
SafeString
=
_htmlbarsUtil
.
SafeString
;
exports
.
htmlSafe
=
htmlSafe
;
exports
.
escapeExpression
=
_htmlbarsUtil
.
escapeExpression
;
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
subscribe
'
[
'
exports
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
subscribe
;
function
subscribe
(
node
env
scope
stream
)
{
if
(
!
_emberMetalStreamsUtils
.
isStream
(
stream
)
)
{
return
;
}
var
component
=
scope
.
getComponent
(
)
;
var
unsubscribers
=
node
.
streamUnsubscribers
=
node
.
streamUnsubscribers
|
|
[
]
;
unsubscribers
.
push
(
stream
.
subscribe
(
function
(
)
{
node
.
isDirty
=
true
;
if
(
component
&
&
component
.
_renderNode
)
{
component
.
_renderNode
.
isDirty
=
true
;
}
if
(
node
.
getState
(
)
.
manager
)
{
node
.
shouldReceiveAttrs
=
true
;
}
node
.
ownerNode
.
emberView
.
scheduleRevalidate
(
node
_emberMetalStreamsUtils
.
labelFor
(
stream
)
)
;
}
)
)
;
}
}
)
;
enifed
(
'
ember
-
htmlbars
/
utils
/
update
-
scope
'
[
'
exports
'
'
ember
-
metal
/
streams
/
proxy
-
stream
'
'
ember
-
htmlbars
/
utils
/
subscribe
'
]
function
(
exports
_emberMetalStreamsProxyStream
_emberHtmlbarsUtilsSubscribe
)
{
'
use
strict
'
;
exports
.
default
=
updateScope
;
function
updateScope
(
scope
key
newValue
renderNode
isSelf
)
{
var
existing
=
scope
[
key
]
;
if
(
existing
)
{
existing
.
setSource
(
newValue
)
;
}
else
{
var
stream
=
new
_emberMetalStreamsProxyStream
.
default
(
newValue
isSelf
?
null
:
key
)
;
if
(
renderNode
)
{
_emberHtmlbarsUtilsSubscribe
.
default
(
renderNode
scope
stream
)
;
}
scope
[
key
]
=
stream
;
}
}
}
)
;
enifed
(
'
ember
-
metal
-
views
/
htmlbars
-
renderer
'
[
'
exports
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
set_properties
'
'
ember
-
views
/
system
/
build
-
component
-
template
'
'
ember
-
metal
/
environment
'
'
htmlbars
-
runtime
'
]
function
(
exports
_emberMetalRun_loop
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalAssign
_emberMetalSet_properties
_emberViewsSystemBuildComponentTemplate
_emberMetalEnvironment
_htmlbarsRuntime
)
{
'
use
strict
'
;
exports
.
Renderer
=
Renderer
;
exports
.
MorphSet
=
MorphSet
;
function
Renderer
(
domHelper
)
{
var
_ref
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
destinedForDOM
=
_ref
.
destinedForDOM
;
this
.
_dom
=
domHelper
;
this
.
_destinedForDOM
=
destinedForDOM
=
=
=
undefined
?
_emberMetalEnvironment
.
default
.
hasDOM
:
destinedForDOM
;
}
Renderer
.
prototype
.
prerenderTopLevelView
=
function
Renderer_prerenderTopLevelView
(
view
renderNode
)
{
if
(
view
.
_state
=
=
=
'
inDOM
'
)
{
throw
new
Error
(
'
You
cannot
insert
a
View
that
has
already
been
rendered
'
)
;
}
view
.
ownerView
=
renderNode
.
emberView
=
view
;
view
.
_renderNode
=
renderNode
;
var
layout
=
_emberMetalProperty_get
.
get
(
view
'
layout
'
)
;
var
template
=
_emberMetalProperty_get
.
get
(
view
'
template
'
)
;
var
componentInfo
=
{
component
:
view
layout
:
layout
}
;
var
block
=
_emberViewsSystemBuildComponentTemplate
.
default
(
componentInfo
{
}
{
self
:
view
templates
:
template
?
{
default
:
template
.
raw
}
:
undefined
}
)
.
block
;
view
.
renderBlock
(
block
renderNode
)
;
view
.
lastResult
=
renderNode
.
lastResult
;
this
.
clearRenderedViews
(
view
.
env
)
;
}
;
Renderer
.
prototype
.
renderTopLevelView
=
function
Renderer_renderTopLevelView
(
view
renderNode
)
{
if
(
view
.
_willInsert
)
{
view
.
_willInsert
=
false
;
this
.
prerenderTopLevelView
(
view
renderNode
)
;
this
.
dispatchLifecycleHooks
(
view
.
env
)
;
}
}
;
Renderer
.
prototype
.
revalidateTopLevelView
=
function
Renderer_revalidateTopLevelView
(
view
)
{
if
(
view
.
_renderNode
.
lastResult
)
{
view
.
_renderNode
.
lastResult
.
revalidate
(
view
.
env
)
;
if
(
view
.
_state
=
=
=
'
inDOM
'
)
{
this
.
dispatchLifecycleHooks
(
view
.
env
)
;
}
this
.
clearRenderedViews
(
view
.
env
)
;
}
}
;
Renderer
.
prototype
.
dispatchLifecycleHooks
=
function
Renderer_dispatchLifecycleHooks
(
env
)
{
var
ownerView
=
env
.
view
;
var
lifecycleHooks
=
env
.
lifecycleHooks
;
var
i
hook
;
for
(
i
=
0
;
i
<
lifecycleHooks
.
length
;
i
+
+
)
{
hook
=
lifecycleHooks
[
i
]
;
ownerView
.
_dispatching
=
hook
.
type
;
switch
(
hook
.
type
)
{
case
'
didInsertElement
'
:
this
.
didInsertElement
(
hook
.
view
)
;
break
;
case
'
didUpdate
'
:
this
.
didUpdate
(
hook
.
view
)
;
break
;
}
this
.
didRender
(
hook
.
view
)
;
}
ownerView
.
_dispatching
=
null
;
env
.
lifecycleHooks
.
length
=
0
;
}
;
Renderer
.
prototype
.
ensureViewNotRendering
=
function
Renderer_ensureViewNotRendering
(
view
)
{
var
env
=
view
.
ownerView
.
env
;
if
(
env
&
&
env
.
renderedViews
.
indexOf
(
view
.
elementId
)
!
=
=
-
1
)
{
throw
new
Error
(
'
Something
you
did
caused
a
view
to
re
-
render
after
it
rendered
but
before
it
was
inserted
into
the
DOM
.
'
)
;
}
}
;
function
MorphSet
(
)
{
this
.
morphs
=
[
]
;
}
MorphSet
.
prototype
.
add
=
function
(
morph
)
{
this
.
morphs
.
push
(
morph
)
;
morph
.
seen
=
true
;
}
;
MorphSet
.
prototype
.
has
=
function
(
morph
)
{
return
morph
.
seen
;
}
;
MorphSet
.
prototype
.
clear
=
function
(
)
{
var
morphs
=
this
.
morphs
;
for
(
var
i
=
0
l
=
morphs
.
length
;
i
<
l
;
i
+
+
)
{
morphs
[
i
]
.
seen
=
false
;
}
this
.
morphs
=
[
]
;
}
;
Renderer
.
prototype
.
clearRenderedViews
=
function
Renderer_clearRenderedViews
(
env
)
{
env
.
renderedNodes
.
clear
(
)
;
env
.
renderedViews
.
length
=
0
;
}
;
Renderer
.
prototype
.
appendTo
=
function
Renderer_appendTo
(
view
target
)
{
var
morph
=
this
.
_dom
.
appendMorph
(
target
)
;
morph
.
ownerNode
=
morph
;
view
.
_willInsert
=
true
;
_emberMetalRun_loop
.
default
.
schedule
(
'
render
'
this
this
.
renderTopLevelView
view
morph
)
;
}
;
Renderer
.
prototype
.
replaceIn
=
function
Renderer_replaceIn
(
view
target
)
{
var
morph
=
this
.
_dom
.
replaceContentWithMorph
(
target
)
;
morph
.
ownerNode
=
morph
;
view
.
_willInsert
=
true
;
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
render
'
this
this
.
renderTopLevelView
view
morph
)
;
}
;
Renderer
.
prototype
.
createElement
=
function
Renderer_createElement
(
view
)
{
var
morph
=
this
.
_dom
.
createFragmentMorph
(
)
;
morph
.
ownerNode
=
morph
;
this
.
prerenderTopLevelView
(
view
morph
)
;
}
;
Renderer
.
prototype
.
didCreateElement
=
function
(
view
element
)
{
if
(
element
)
{
view
.
element
=
element
;
}
if
(
view
.
_transitionTo
)
{
view
.
_transitionTo
(
'
hasElement
'
)
;
}
}
;
Renderer
.
prototype
.
willInsertElement
=
function
(
view
)
{
if
(
view
.
trigger
)
{
view
.
trigger
(
'
willInsertElement
'
)
;
}
}
;
Renderer
.
prototype
.
setAttrs
=
function
(
view
attrs
)
{
_emberMetalProperty_set
.
set
(
view
'
attrs
'
attrs
)
;
}
;
Renderer
.
prototype
.
componentInitAttrs
=
function
(
component
attrs
)
{
component
.
trigger
(
'
didInitAttrs
'
{
attrs
:
attrs
}
)
;
component
.
trigger
(
'
didReceiveAttrs
'
{
newAttrs
:
attrs
}
)
;
}
;
Renderer
.
prototype
.
didInsertElement
=
function
(
view
)
{
if
(
view
.
_transitionTo
)
{
view
.
_transitionTo
(
'
inDOM
'
)
;
}
if
(
view
.
trigger
)
{
view
.
trigger
(
'
didInsertElement
'
)
;
}
}
;
Renderer
.
prototype
.
didUpdate
=
function
(
view
)
{
if
(
view
.
trigger
)
{
view
.
trigger
(
'
didUpdate
'
)
;
}
}
;
Renderer
.
prototype
.
didRender
=
function
(
view
)
{
if
(
view
.
trigger
)
{
view
.
trigger
(
'
didRender
'
)
;
}
}
;
Renderer
.
prototype
.
updateAttrs
=
function
(
view
attrs
)
{
this
.
setAttrs
(
view
attrs
)
;
}
;
Renderer
.
prototype
.
componentUpdateAttrs
=
function
(
component
newAttrs
)
{
var
oldAttrs
=
null
;
if
(
component
.
attrs
)
{
oldAttrs
=
_emberMetalAssign
.
default
(
{
}
component
.
attrs
)
;
_emberMetalSet_properties
.
default
(
component
.
attrs
newAttrs
)
;
}
else
{
_emberMetalProperty_set
.
set
(
component
'
attrs
'
newAttrs
)
;
}
component
.
trigger
(
'
didUpdateAttrs
'
{
oldAttrs
:
oldAttrs
newAttrs
:
newAttrs
}
)
;
component
.
trigger
(
'
didReceiveAttrs
'
{
oldAttrs
:
oldAttrs
newAttrs
:
newAttrs
}
)
;
}
;
Renderer
.
prototype
.
willUpdate
=
function
(
view
attrs
)
{
if
(
view
.
_willUpdate
)
{
view
.
_willUpdate
(
attrs
)
;
}
}
;
Renderer
.
prototype
.
componentWillUpdate
=
function
(
component
)
{
component
.
trigger
(
'
willUpdate
'
)
;
}
;
Renderer
.
prototype
.
willRender
=
function
(
view
)
{
if
(
view
.
_willRender
)
{
view
.
_willRender
(
)
;
}
}
;
Renderer
.
prototype
.
componentWillRender
=
function
(
component
)
{
component
.
trigger
(
'
willRender
'
)
;
}
;
Renderer
.
prototype
.
rerender
=
function
(
view
)
{
var
renderNode
=
view
.
_renderNode
;
renderNode
.
isDirty
=
true
;
_htmlbarsRuntime
.
internal
.
visitChildren
(
renderNode
.
childNodes
function
(
node
)
{
if
(
node
.
getState
(
)
.
manager
)
{
node
.
shouldReceiveAttrs
=
true
;
}
node
.
isDirty
=
true
;
}
)
;
renderNode
.
ownerNode
.
emberView
.
scheduleRevalidate
(
renderNode
view
.
toString
(
)
'
rerendering
'
)
;
}
;
Renderer
.
prototype
.
remove
=
function
(
view
shouldDestroy
)
{
this
.
willDestroyElement
(
view
)
;
view
.
_willRemoveElement
=
true
;
_emberMetalRun_loop
.
default
.
schedule
(
'
render
'
this
this
.
renderElementRemoval
view
)
;
}
;
Renderer
.
prototype
.
renderElementRemoval
=
function
Renderer_renderElementRemoval
(
view
)
{
if
(
view
.
_willRemoveElement
)
{
view
.
_willRemoveElement
=
false
;
if
(
view
.
_renderNode
&
&
view
.
element
&
&
view
.
element
.
parentNode
)
{
view
.
_renderNode
.
clear
(
)
;
}
this
.
didDestroyElement
(
view
)
;
}
}
;
Renderer
.
prototype
.
willRemoveElement
=
function
(
)
{
}
;
Renderer
.
prototype
.
willDestroyElement
=
function
(
view
)
{
if
(
view
.
_willDestroyElement
)
{
view
.
_willDestroyElement
(
)
;
}
if
(
view
.
trigger
)
{
view
.
trigger
(
'
willDestroyElement
'
)
;
view
.
trigger
(
'
willClearRender
'
)
;
}
if
(
view
.
_transitionTo
)
{
view
.
_transitionTo
(
'
destroying
'
)
;
}
}
;
Renderer
.
prototype
.
didDestroyElement
=
function
(
view
)
{
view
.
element
=
null
;
if
(
view
.
_state
!
=
=
'
destroying
'
&
&
view
.
_transitionTo
)
{
view
.
_transitionTo
(
'
preRender
'
)
;
}
if
(
view
.
trigger
)
{
view
.
trigger
(
'
didDestroyElement
'
)
;
}
}
;
var
InertRenderer
=
{
create
:
function
(
_ref2
)
{
var
dom
=
_ref2
.
dom
;
return
new
Renderer
(
dom
{
destinedForDOM
:
false
}
)
;
}
}
;
exports
.
InertRenderer
=
InertRenderer
;
var
InteractiveRenderer
=
{
create
:
function
(
_ref3
)
{
var
dom
=
_ref3
.
dom
;
return
new
Renderer
(
dom
{
destinedForDOM
:
true
}
)
;
}
}
;
exports
.
InteractiveRenderer
=
InteractiveRenderer
;
}
)
;
enifed
(
'
ember
-
metal
-
views
/
index
'
[
'
exports
'
'
ember
-
metal
-
views
/
htmlbars
-
renderer
'
]
function
(
exports
_emberMetalViewsHtmlbarsRenderer
)
{
'
use
strict
'
;
function
_interopExportWildcard
(
obj
defaults
)
{
var
newObj
=
defaults
(
{
}
obj
)
;
delete
newObj
[
'
default
'
]
;
return
newObj
;
}
function
_defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
_defaults
(
exports
_interopExportWildcard
(
_emberMetalViewsHtmlbarsRenderer
_defaults
)
)
;
}
)
;
enifed
(
'
ember
-
metal
/
alias
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
dependent_keys
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalError
_emberMetalProperties
_emberMetalComputed
_emberMetalUtils
_emberMetalMeta
_emberMetalDependent_keys
)
{
'
use
strict
'
;
exports
.
default
=
alias
;
exports
.
AliasedProperty
=
AliasedProperty
;
function
alias
(
altKey
)
{
return
new
AliasedProperty
(
altKey
)
;
}
function
AliasedProperty
(
altKey
)
{
this
.
isDescriptor
=
true
;
this
.
altKey
=
altKey
;
this
.
_dependentKeys
=
[
altKey
]
;
}
AliasedProperty
.
prototype
=
Object
.
create
(
_emberMetalProperties
.
Descriptor
.
prototype
)
;
AliasedProperty
.
prototype
.
get
=
function
AliasedProperty_get
(
obj
keyName
)
{
return
_emberMetalProperty_get
.
get
(
obj
this
.
altKey
)
;
}
;
AliasedProperty
.
prototype
.
set
=
function
AliasedProperty_set
(
obj
keyName
value
)
{
return
_emberMetalProperty_set
.
set
(
obj
this
.
altKey
value
)
;
}
;
AliasedProperty
.
prototype
.
willWatch
=
function
(
obj
keyName
)
{
_emberMetalDependent_keys
.
addDependentKeys
(
this
obj
keyName
_emberMetalMeta
.
meta
(
obj
)
)
;
}
;
AliasedProperty
.
prototype
.
didUnwatch
=
function
(
obj
keyName
)
{
_emberMetalDependent_keys
.
removeDependentKeys
(
this
obj
keyName
_emberMetalMeta
.
meta
(
obj
)
)
;
}
;
AliasedProperty
.
prototype
.
setup
=
function
(
obj
keyName
)
{
_emberMetalDebug
.
assert
(
'
Setting
alias
\
'
'
+
keyName
+
'
\
'
on
self
'
this
.
altKey
!
=
=
keyName
)
;
var
m
=
_emberMetalMeta
.
meta
(
obj
)
;
if
(
m
.
peekWatching
(
keyName
)
)
{
_emberMetalDependent_keys
.
addDependentKeys
(
this
obj
keyName
m
)
;
}
}
;
AliasedProperty
.
prototype
.
teardown
=
function
(
obj
keyName
)
{
var
m
=
_emberMetalMeta
.
meta
(
obj
)
;
if
(
m
.
peekWatching
(
keyName
)
)
{
_emberMetalDependent_keys
.
removeDependentKeys
(
this
obj
keyName
m
)
;
}
}
;
AliasedProperty
.
prototype
.
readOnly
=
function
(
)
{
this
.
set
=
AliasedProperty_readOnlySet
;
return
this
;
}
;
function
AliasedProperty_readOnlySet
(
obj
keyName
value
)
{
throw
new
_emberMetalError
.
default
(
'
Cannot
set
read
-
only
property
\
'
'
+
keyName
+
'
\
'
on
object
:
'
+
_emberMetalUtils
.
inspect
(
obj
)
)
;
}
AliasedProperty
.
prototype
.
oneWay
=
function
(
)
{
this
.
set
=
AliasedProperty_oneWaySet
;
return
this
;
}
;
function
AliasedProperty_oneWaySet
(
obj
keyName
value
)
{
_emberMetalProperties
.
defineProperty
(
obj
keyName
null
)
;
return
_emberMetalProperty_set
.
set
(
obj
keyName
value
)
;
}
AliasedProperty
.
prototype
.
_meta
=
undefined
;
AliasedProperty
.
prototype
.
meta
=
_emberMetalComputed
.
ComputedProperty
.
prototype
.
meta
;
}
)
;
enifed
(
"
ember
-
metal
/
assign
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
assign
;
function
assign
(
original
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
for
(
var
i
=
0
l
=
args
.
length
;
i
<
l
;
i
+
+
)
{
var
arg
=
args
[
i
]
;
if
(
!
arg
)
{
continue
;
}
var
updates
=
Object
.
keys
(
arg
)
;
for
(
var
_i
=
0
_l
=
updates
.
length
;
_i
<
_l
;
_i
+
+
)
{
var
prop
=
updates
[
_i
]
;
original
[
prop
]
=
arg
[
prop
]
;
}
}
return
original
;
}
}
)
;
enifed
(
'
ember
-
metal
/
binding
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
path_cache
'
]
function
(
exports
_emberMetalCore
_emberMetalLogger
_emberMetalRun_loop
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalUtils
_emberMetalEvents
_emberMetalObserver
_emberMetalPath_cache
)
{
'
use
strict
'
;
exports
.
bind
=
bind
;
_emberMetalCore
.
default
.
LOG_BINDINGS
=
false
|
|
!
!
_emberMetalCore
.
default
.
ENV
.
LOG_BINDINGS
;
function
Binding
(
toPath
fromPath
)
{
this
.
_from
=
fromPath
;
this
.
_to
=
toPath
;
this
.
_oneWay
=
undefined
;
this
.
_direction
=
undefined
;
this
.
_readyToSync
=
undefined
;
this
.
_fromObj
=
undefined
;
this
.
_fromPath
=
undefined
;
this
.
_toObj
=
undefined
;
}
Binding
.
prototype
=
{
copy
:
function
(
)
{
var
copy
=
new
Binding
(
this
.
_to
this
.
_from
)
;
if
(
this
.
_oneWay
)
{
copy
.
_oneWay
=
true
;
}
return
copy
;
}
from
:
function
(
path
)
{
this
.
_from
=
path
;
return
this
;
}
to
:
function
(
path
)
{
this
.
_to
=
path
;
return
this
;
}
oneWay
:
function
(
)
{
this
.
_oneWay
=
true
;
return
this
;
}
toString
:
function
(
)
{
var
oneWay
=
this
.
_oneWay
?
'
[
oneWay
]
'
:
'
'
;
return
'
Ember
.
Binding
<
'
+
_emberMetalUtils
.
guidFor
(
this
)
+
'
>
(
'
+
this
.
_from
+
'
-
>
'
+
this
.
_to
+
'
)
'
+
oneWay
;
}
connect
:
function
(
obj
)
{
_emberMetalDebug
.
assert
(
'
Must
pass
a
valid
object
to
Ember
.
Binding
.
connect
(
)
'
!
!
obj
)
;
var
fromObj
=
undefined
fromPath
=
undefined
;
if
(
_emberMetalPath_cache
.
isGlobalPath
(
this
.
_from
)
)
{
var
_name
=
_emberMetalPath_cache
.
getFirstKey
(
this
.
_from
)
;
var
possibleGlobal
=
_emberMetalCore
.
default
.
lookup
[
_name
]
;
if
(
possibleGlobal
)
{
fromObj
=
possibleGlobal
;
fromPath
=
_emberMetalPath_cache
.
getTailPath
(
this
.
_from
)
;
}
}
if
(
fromObj
=
=
=
undefined
)
{
fromObj
=
obj
;
fromPath
=
this
.
_from
;
}
_emberMetalProperty_set
.
trySet
(
obj
this
.
_to
_emberMetalProperty_get
.
get
(
fromObj
fromPath
)
)
;
_emberMetalObserver
.
addObserver
(
fromObj
fromPath
this
'
fromDidChange
'
)
;
if
(
!
this
.
_oneWay
)
{
_emberMetalObserver
.
addObserver
(
obj
this
.
_to
this
'
toDidChange
'
)
;
}
_emberMetalEvents
.
addListener
(
obj
'
willDestroy
'
this
'
disconnect
'
)
;
this
.
_readyToSync
=
true
;
this
.
_fromObj
=
fromObj
;
this
.
_fromPath
=
fromPath
;
this
.
_toObj
=
obj
;
return
this
;
}
disconnect
:
function
(
)
{
_emberMetalDebug
.
assert
(
'
Must
pass
a
valid
object
to
Ember
.
Binding
.
disconnect
(
)
'
!
!
this
.
_toObj
)
;
_emberMetalObserver
.
removeObserver
(
this
.
_fromObj
this
.
_fromPath
this
'
fromDidChange
'
)
;
if
(
!
this
.
_oneWay
)
{
_emberMetalObserver
.
removeObserver
(
this
.
_toObj
this
.
_to
this
'
toDidChange
'
)
;
}
this
.
_readyToSync
=
false
;
return
this
;
}
fromDidChange
:
function
(
target
)
{
this
.
_scheduleSync
(
'
fwd
'
)
;
}
toDidChange
:
function
(
target
)
{
this
.
_scheduleSync
(
'
back
'
)
;
}
_scheduleSync
:
function
(
dir
)
{
var
existingDir
=
this
.
_direction
;
if
(
existingDir
=
=
=
undefined
)
{
_emberMetalRun_loop
.
default
.
schedule
(
'
sync
'
this
'
_sync
'
)
;
this
.
_direction
=
dir
;
}
if
(
existingDir
=
=
=
'
back
'
&
&
dir
=
=
=
'
fwd
'
)
{
this
.
_direction
=
'
fwd
'
;
}
}
_sync
:
function
(
)
{
var
log
=
_emberMetalCore
.
default
.
LOG_BINDINGS
;
var
toObj
=
this
.
_toObj
;
if
(
toObj
.
isDestroyed
|
|
!
this
.
_readyToSync
)
{
return
;
}
var
direction
=
this
.
_direction
;
var
fromObj
=
this
.
_fromObj
;
var
fromPath
=
this
.
_fromPath
;
this
.
_direction
=
undefined
;
if
(
direction
=
=
=
'
fwd
'
)
{
var
fromValue
=
_emberMetalProperty_get
.
get
(
fromObj
fromPath
)
;
if
(
log
)
{
_emberMetalLogger
.
default
.
log
(
'
'
this
.
toString
(
)
'
-
>
'
fromValue
fromObj
)
;
}
if
(
this
.
_oneWay
)
{
_emberMetalProperty_set
.
trySet
(
toObj
this
.
_to
fromValue
)
;
}
else
{
_emberMetalObserver
.
_suspendObserver
(
toObj
this
.
_to
this
'
toDidChange
'
function
(
)
{
_emberMetalProperty_set
.
trySet
(
toObj
this
.
_to
fromValue
)
;
}
)
;
}
}
else
if
(
direction
=
=
=
'
back
'
)
{
var
toValue
=
_emberMetalProperty_get
.
get
(
toObj
this
.
_to
)
;
if
(
log
)
{
_emberMetalLogger
.
default
.
log
(
'
'
this
.
toString
(
)
'
<
-
'
toValue
toObj
)
;
}
_emberMetalObserver
.
_suspendObserver
(
fromObj
fromPath
this
'
fromDidChange
'
function
(
)
{
_emberMetalProperty_set
.
trySet
(
fromObj
fromPath
toValue
)
;
}
)
;
}
}
}
;
function
mixinProperties
(
to
from
)
{
for
(
var
key
in
from
)
{
if
(
from
.
hasOwnProperty
(
key
)
)
{
to
[
key
]
=
from
[
key
]
;
}
}
}
mixinProperties
(
Binding
{
from
:
function
(
from
)
{
var
C
=
this
;
return
new
C
(
undefined
from
)
;
}
to
:
function
(
to
)
{
var
C
=
this
;
return
new
C
(
to
undefined
)
;
}
}
)
;
function
bind
(
obj
to
from
)
{
return
new
Binding
(
to
from
)
.
connect
(
obj
)
;
}
exports
.
Binding
=
Binding
;
}
)
;
enifed
(
'
ember
-
metal
/
cache
'
[
'
exports
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalEmpty_object
)
{
'
use
strict
'
;
exports
.
default
=
Cache
;
function
Cache
(
limit
func
)
{
this
.
store
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
size
=
0
;
this
.
misses
=
0
;
this
.
hits
=
0
;
this
.
limit
=
limit
;
this
.
func
=
func
;
}
var
UNDEFINED
=
function
(
)
{
}
;
Cache
.
prototype
=
{
set
:
function
(
key
value
)
{
if
(
this
.
limit
>
this
.
size
)
{
this
.
size
+
+
;
if
(
value
=
=
=
undefined
)
{
this
.
store
[
key
]
=
UNDEFINED
;
}
else
{
this
.
store
[
key
]
=
value
;
}
}
return
value
;
}
get
:
function
(
key
)
{
var
value
=
this
.
store
[
key
]
;
if
(
value
=
=
=
undefined
)
{
this
.
misses
+
+
;
value
=
this
.
set
(
key
this
.
func
(
key
)
)
;
}
else
if
(
value
=
=
=
UNDEFINED
)
{
this
.
hits
+
+
;
value
=
undefined
;
}
else
{
this
.
hits
+
+
;
}
return
value
;
}
purge
:
function
(
)
{
this
.
store
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
size
=
0
;
this
.
hits
=
0
;
this
.
misses
=
0
;
}
}
;
}
)
;
enifed
(
'
ember
-
metal
/
chains
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
watch_key
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalMeta
_emberMetalWatch_key
_emberMetalEmpty_object
)
{
'
use
strict
'
;
exports
.
finishChains
=
finishChains
;
var
FIRST_KEY
=
/
^
(
[
^
\
.
]
+
)
/
;
function
firstKey
(
path
)
{
return
path
.
match
(
FIRST_KEY
)
[
0
]
;
}
function
isObject
(
obj
)
{
return
obj
&
&
typeof
obj
=
=
=
'
object
'
;
}
function
isVolatile
(
obj
)
{
return
!
(
isObject
(
obj
)
&
&
obj
.
isDescriptor
&
&
obj
.
_volatile
=
=
=
false
)
;
}
function
ChainWatchers
(
)
{
this
.
chains
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
ChainWatchers
.
prototype
=
{
add
:
function
(
key
node
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
=
=
=
undefined
)
{
this
.
chains
[
key
]
=
[
node
]
;
}
else
{
nodes
.
push
(
node
)
;
}
}
remove
:
function
(
key
node
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
)
{
for
(
var
i
=
0
l
=
nodes
.
length
;
i
<
l
;
i
+
+
)
{
if
(
nodes
[
i
]
=
=
=
node
)
{
nodes
.
splice
(
i
1
)
;
break
;
}
}
}
}
has
:
function
(
key
node
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
)
{
for
(
var
i
=
0
l
=
nodes
.
length
;
i
<
l
;
i
+
+
)
{
if
(
nodes
[
i
]
=
=
=
node
)
{
return
true
;
}
}
}
return
false
;
}
revalidateAll
:
function
(
)
{
for
(
var
key
in
this
.
chains
)
{
this
.
notify
(
key
true
undefined
)
;
}
}
revalidate
:
function
(
key
)
{
this
.
notify
(
key
true
undefined
)
;
}
notify
:
function
(
key
revalidate
callback
)
{
var
nodes
=
this
.
chains
[
key
]
;
if
(
nodes
=
=
=
undefined
|
|
nodes
.
length
=
=
=
0
)
{
return
;
}
var
affected
=
undefined
;
if
(
callback
)
{
affected
=
[
]
;
}
for
(
var
i
=
0
l
=
nodes
.
length
;
i
<
l
;
i
+
+
)
{
nodes
[
i
]
.
notify
(
revalidate
affected
)
;
}
if
(
callback
=
=
=
undefined
)
{
return
;
}
for
(
var
i
=
0
l
=
affected
.
length
;
i
<
l
;
i
+
=
2
)
{
var
obj
=
affected
[
i
]
;
var
path
=
affected
[
i
+
1
]
;
callback
(
obj
path
)
;
}
}
}
;
function
makeChainWatcher
(
)
{
return
new
ChainWatchers
(
)
;
}
function
addChainWatcher
(
obj
keyName
node
)
{
if
(
!
isObject
(
obj
)
)
{
return
;
}
var
m
=
_emberMetalMeta
.
meta
(
obj
)
;
m
.
writableChainWatchers
(
makeChainWatcher
)
.
add
(
keyName
node
)
;
_emberMetalWatch_key
.
watchKey
(
obj
keyName
m
)
;
}
function
removeChainWatcher
(
obj
keyName
node
)
{
if
(
!
isObject
(
obj
)
)
{
return
;
}
var
m
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
!
m
|
|
!
m
.
readableChainWatchers
(
)
)
{
return
;
}
m
=
_emberMetalMeta
.
meta
(
obj
)
;
m
.
readableChainWatchers
(
)
.
remove
(
keyName
node
)
;
_emberMetalWatch_key
.
unwatchKey
(
obj
keyName
m
)
;
}
function
ChainNode
(
parent
key
value
)
{
this
.
_parent
=
parent
;
this
.
_key
=
key
;
this
.
_watching
=
value
=
=
=
undefined
;
this
.
_chains
=
undefined
;
this
.
_object
=
undefined
;
this
.
count
=
0
;
this
.
_value
=
value
;
this
.
_paths
=
{
}
;
if
(
this
.
_watching
)
{
this
.
_object
=
parent
.
value
(
)
;
if
(
this
.
_object
)
{
addChainWatcher
(
this
.
_object
this
.
_key
this
)
;
}
}
}
function
lazyGet
(
obj
key
)
{
if
(
!
obj
)
{
return
;
}
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
meta
&
&
meta
.
proto
=
=
=
obj
)
{
return
;
}
if
(
isVolatile
(
obj
[
key
]
)
)
{
return
_emberMetalProperty_get
.
get
(
obj
key
)
;
}
else
{
var
cache
=
meta
.
readableCache
(
)
;
if
(
cache
&
&
key
in
cache
)
{
return
cache
[
key
]
;
}
}
}
ChainNode
.
prototype
=
{
value
:
function
(
)
{
if
(
this
.
_value
=
=
=
undefined
&
&
this
.
_watching
)
{
var
obj
=
this
.
_parent
.
value
(
)
;
this
.
_value
=
lazyGet
(
obj
this
.
_key
)
;
}
return
this
.
_value
;
}
destroy
:
function
(
)
{
if
(
this
.
_watching
)
{
var
obj
=
this
.
_object
;
if
(
obj
)
{
removeChainWatcher
(
obj
this
.
_key
this
)
;
}
this
.
_watching
=
false
;
}
}
copy
:
function
(
obj
)
{
var
ret
=
new
ChainNode
(
null
null
obj
)
;
var
paths
=
this
.
_paths
;
var
path
;
for
(
path
in
paths
)
{
if
(
paths
[
path
]
<
=
0
)
{
continue
;
}
ret
.
add
(
path
)
;
}
return
ret
;
}
add
:
function
(
path
)
{
var
paths
=
this
.
_paths
;
paths
[
path
]
=
(
paths
[
path
]
|
|
0
)
+
1
;
var
key
=
firstKey
(
path
)
;
var
tail
=
path
.
slice
(
key
.
length
+
1
)
;
this
.
chain
(
key
tail
)
;
}
remove
:
function
(
path
)
{
var
paths
=
this
.
_paths
;
if
(
paths
[
path
]
>
0
)
{
paths
[
path
]
-
-
;
}
var
key
=
firstKey
(
path
)
;
var
tail
=
path
.
slice
(
key
.
length
+
1
)
;
this
.
unchain
(
key
tail
)
;
}
chain
:
function
(
key
path
)
{
var
chains
=
this
.
_chains
;
var
node
;
if
(
chains
=
=
=
undefined
)
{
chains
=
this
.
_chains
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
else
{
node
=
chains
[
key
]
;
}
if
(
node
=
=
=
undefined
)
{
node
=
chains
[
key
]
=
new
ChainNode
(
this
key
undefined
)
;
}
node
.
count
+
+
;
if
(
path
)
{
key
=
firstKey
(
path
)
;
path
=
path
.
slice
(
key
.
length
+
1
)
;
node
.
chain
(
key
path
)
;
}
}
unchain
:
function
(
key
path
)
{
var
chains
=
this
.
_chains
;
var
node
=
chains
[
key
]
;
if
(
path
&
&
path
.
length
>
1
)
{
var
nextKey
=
firstKey
(
path
)
;
var
nextPath
=
path
.
slice
(
nextKey
.
length
+
1
)
;
node
.
unchain
(
nextKey
nextPath
)
;
}
node
.
count
-
-
;
if
(
node
.
count
<
=
0
)
{
chains
[
node
.
_key
]
=
undefined
;
node
.
destroy
(
)
;
}
}
notify
:
function
(
revalidate
affected
)
{
if
(
revalidate
&
&
this
.
_watching
)
{
var
obj
=
this
.
_parent
.
value
(
)
;
if
(
obj
!
=
=
this
.
_object
)
{
removeChainWatcher
(
this
.
_object
this
.
_key
this
)
;
this
.
_object
=
obj
;
addChainWatcher
(
obj
this
.
_key
this
)
;
}
this
.
_value
=
undefined
;
}
var
chains
=
this
.
_chains
;
var
node
;
if
(
chains
)
{
for
(
var
key
in
chains
)
{
node
=
chains
[
key
]
;
if
(
node
!
=
=
undefined
)
{
node
.
notify
(
revalidate
affected
)
;
}
}
}
if
(
affected
&
&
this
.
_parent
)
{
this
.
_parent
.
populateAffected
(
this
.
_key
1
affected
)
;
}
}
populateAffected
:
function
(
path
depth
affected
)
{
if
(
this
.
_key
)
{
path
=
this
.
_key
+
'
.
'
+
path
;
}
if
(
this
.
_parent
)
{
this
.
_parent
.
populateAffected
(
path
depth
+
1
affected
)
;
}
else
{
if
(
depth
>
1
)
{
affected
.
push
(
this
.
value
(
)
path
)
;
}
}
}
}
;
function
finishChains
(
obj
)
{
var
m
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
m
)
{
m
=
_emberMetalMeta
.
meta
(
obj
)
;
var
chainWatchers
=
m
.
readableChainWatchers
(
)
;
if
(
chainWatchers
)
{
chainWatchers
.
revalidateAll
(
)
;
}
if
(
m
.
readableChains
(
)
)
{
m
.
writableChains
(
)
;
}
}
}
exports
.
removeChainWatcher
=
removeChainWatcher
;
exports
.
ChainNode
=
ChainNode
;
}
)
;
enifed
(
'
ember
-
metal
/
computed
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
expand_properties
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
dependent_keys
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_set
_emberMetalUtils
_emberMetalMeta
_emberMetalExpand_properties
_emberMetalError
_emberMetalProperties
_emberMetalProperty_events
_emberMetalDependent_keys
)
{
'
use
strict
'
;
exports
.
default
=
computed
;
function
UNDEFINED
(
)
{
}
var
DEEP_EACH_REGEX
=
/
\
.
each
\
.
[
^
.
]
+
\
.
/
;
function
ComputedProperty
(
config
opts
)
{
this
.
isDescriptor
=
true
;
if
(
typeof
config
=
=
=
'
function
'
)
{
this
.
_getter
=
config
;
}
else
{
_emberMetalDebug
.
assert
(
'
Ember
.
computed
expects
a
function
or
an
object
as
last
argument
.
'
typeof
config
=
=
=
'
object
'
&
&
!
Array
.
isArray
(
config
)
)
;
_emberMetalDebug
.
assert
(
'
Config
object
pased
to
a
Ember
.
computed
can
only
contain
get
or
set
keys
.
'
(
function
(
)
{
var
keys
=
Object
.
keys
(
config
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
if
(
keys
[
i
]
!
=
=
'
get
'
&
&
keys
[
i
]
!
=
=
'
set
'
)
{
return
false
;
}
}
return
true
;
}
)
(
)
)
;
this
.
_getter
=
config
.
get
;
this
.
_setter
=
config
.
set
;
}
_emberMetalDebug
.
assert
(
'
Computed
properties
must
receive
a
getter
or
a
setter
you
passed
none
.
'
!
!
this
.
_getter
|
|
!
!
this
.
_setter
)
;
this
.
_dependentKeys
=
undefined
;
this
.
_suspended
=
undefined
;
this
.
_meta
=
undefined
;
this
.
_volatile
=
false
;
this
.
_dependentKeys
=
opts
&
&
opts
.
dependentKeys
;
this
.
_readOnly
=
false
;
}
ComputedProperty
.
prototype
=
new
_emberMetalProperties
.
Descriptor
(
)
;
var
ComputedPropertyPrototype
=
ComputedProperty
.
prototype
;
ComputedPropertyPrototype
.
volatile
=
function
(
)
{
this
.
_volatile
=
true
;
return
this
;
}
;
ComputedPropertyPrototype
.
readOnly
=
function
(
)
{
this
.
_readOnly
=
true
;
_emberMetalDebug
.
assert
(
'
Computed
properties
that
define
a
setter
using
the
new
syntax
cannot
be
read
-
only
'
!
(
this
.
_readOnly
&
&
this
.
_setter
&
&
this
.
_setter
!
=
=
this
.
_getter
)
)
;
return
this
;
}
;
ComputedPropertyPrototype
.
property
=
function
(
)
{
var
args
;
var
addArg
=
function
(
property
)
{
_emberMetalDebug
.
warn
(
'
Dependent
keys
containing
each
only
work
one
level
deep
.
'
+
'
You
cannot
use
nested
forms
like
todos
.
each
.
owner
.
name
or
todos
.
each
.
owner
.
each
.
name
.
'
+
'
Please
create
an
intermediary
computed
property
.
'
DEEP_EACH_REGEX
.
test
(
property
)
=
=
=
false
{
id
:
'
ember
-
metal
.
computed
-
deep
-
each
'
}
)
;
args
.
push
(
property
)
;
}
;
args
=
[
]
;
for
(
var
i
=
0
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
_emberMetalExpand_properties
.
default
(
arguments
[
i
]
addArg
)
;
}
this
.
_dependentKeys
=
args
;
return
this
;
}
;
ComputedPropertyPrototype
.
meta
=
function
(
meta
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
.
_meta
|
|
{
}
;
}
else
{
this
.
_meta
=
meta
;
return
this
;
}
}
;
ComputedPropertyPrototype
.
didChange
=
function
(
obj
keyName
)
{
if
(
this
.
_volatile
|
|
this
.
_suspended
=
=
=
obj
)
{
return
;
}
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
!
meta
|
|
meta
.
source
!
=
=
obj
)
{
return
;
}
var
cache
=
meta
.
readableCache
(
)
;
if
(
cache
&
&
cache
[
keyName
]
!
=
=
undefined
)
{
cache
[
keyName
]
=
undefined
;
_emberMetalDependent_keys
.
removeDependentKeys
(
this
obj
keyName
meta
)
;
}
}
;
ComputedPropertyPrototype
.
get
=
function
(
obj
keyName
)
{
if
(
this
.
_volatile
)
{
return
this
.
_getter
.
call
(
obj
keyName
)
;
}
var
meta
=
_emberMetalMeta
.
meta
(
obj
)
;
var
cache
=
meta
.
writableCache
(
)
;
var
result
=
cache
[
keyName
]
;
if
(
result
=
=
=
UNDEFINED
)
{
return
undefined
;
}
else
if
(
result
!
=
=
undefined
)
{
return
result
;
}
var
ret
=
this
.
_getter
.
call
(
obj
keyName
)
;
if
(
ret
=
=
=
undefined
)
{
cache
[
keyName
]
=
UNDEFINED
;
}
else
{
cache
[
keyName
]
=
ret
;
}
var
chainWatchers
=
meta
.
readableChainWatchers
(
)
;
if
(
chainWatchers
)
{
chainWatchers
.
revalidate
(
keyName
)
;
}
_emberMetalDependent_keys
.
addDependentKeys
(
this
obj
keyName
meta
)
;
return
ret
;
}
;
ComputedPropertyPrototype
.
set
=
function
computedPropertySetEntry
(
obj
keyName
value
)
{
if
(
this
.
_readOnly
)
{
this
.
_throwReadOnlyError
(
obj
keyName
)
;
}
if
(
!
this
.
_setter
)
{
return
this
.
clobberSet
(
obj
keyName
value
)
;
}
if
(
this
.
_volatile
)
{
return
this
.
volatileSet
(
obj
keyName
value
)
;
}
return
this
.
setWithSuspend
(
obj
keyName
value
)
;
}
;
ComputedPropertyPrototype
.
_throwReadOnlyError
=
function
computedPropertyThrowReadOnlyError
(
obj
keyName
)
{
throw
new
_emberMetalError
.
default
(
'
Cannot
set
read
-
only
property
"
'
+
keyName
+
'
"
on
object
:
'
+
_emberMetalUtils
.
inspect
(
obj
)
)
;
}
;
ComputedPropertyPrototype
.
clobberSet
=
function
computedPropertyClobberSet
(
obj
keyName
value
)
{
var
cachedValue
=
cacheFor
(
obj
keyName
)
;
_emberMetalProperties
.
defineProperty
(
obj
keyName
null
cachedValue
)
;
_emberMetalProperty_set
.
set
(
obj
keyName
value
)
;
return
value
;
}
;
ComputedPropertyPrototype
.
volatileSet
=
function
computedPropertyVolatileSet
(
obj
keyName
value
)
{
return
this
.
_setter
.
call
(
obj
keyName
value
)
;
}
;
ComputedPropertyPrototype
.
setWithSuspend
=
function
computedPropertySetWithSuspend
(
obj
keyName
value
)
{
var
oldSuspended
=
this
.
_suspended
;
this
.
_suspended
=
obj
;
try
{
return
this
.
_set
(
obj
keyName
value
)
;
}
finally
{
this
.
_suspended
=
oldSuspended
;
}
}
;
ComputedPropertyPrototype
.
_set
=
function
computedPropertySet
(
obj
keyName
value
)
{
var
meta
=
_emberMetalMeta
.
meta
(
obj
)
;
var
cache
=
meta
.
writableCache
(
)
;
var
hadCachedValue
=
false
;
var
cachedValue
=
undefined
;
if
(
cache
[
keyName
]
!
=
=
undefined
)
{
if
(
cache
[
keyName
]
!
=
=
UNDEFINED
)
{
cachedValue
=
cache
[
keyName
]
;
}
hadCachedValue
=
true
;
}
var
ret
=
this
.
_setter
.
call
(
obj
keyName
value
cachedValue
)
;
if
(
hadCachedValue
&
&
cachedValue
=
=
=
ret
)
{
return
ret
;
}
var
watched
=
meta
.
peekWatching
(
keyName
)
;
if
(
watched
)
{
_emberMetalProperty_events
.
propertyWillChange
(
obj
keyName
)
;
}
if
(
hadCachedValue
)
{
cache
[
keyName
]
=
undefined
;
}
if
(
!
hadCachedValue
)
{
_emberMetalDependent_keys
.
addDependentKeys
(
this
obj
keyName
meta
)
;
}
if
(
ret
=
=
=
undefined
)
{
cache
[
keyName
]
=
UNDEFINED
;
}
else
{
cache
[
keyName
]
=
ret
;
}
if
(
watched
)
{
_emberMetalProperty_events
.
propertyDidChange
(
obj
keyName
)
;
}
return
ret
;
}
;
ComputedPropertyPrototype
.
teardown
=
function
(
obj
keyName
)
{
if
(
this
.
_volatile
)
{
return
;
}
var
meta
=
_emberMetalMeta
.
meta
(
obj
)
;
var
cache
=
meta
.
readableCache
(
)
;
if
(
cache
&
&
cache
[
keyName
]
!
=
=
undefined
)
{
_emberMetalDependent_keys
.
removeDependentKeys
(
this
obj
keyName
meta
)
;
cache
[
keyName
]
=
undefined
;
}
}
;
function
computed
(
func
)
{
var
args
;
if
(
arguments
.
length
>
1
)
{
args
=
[
]
.
slice
.
call
(
arguments
)
;
func
=
args
.
pop
(
)
;
}
var
cp
=
new
ComputedProperty
(
func
)
;
if
(
args
)
{
cp
.
property
.
apply
(
cp
args
)
;
}
return
cp
;
}
function
cacheFor
(
obj
key
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
var
cache
=
meta
&
&
meta
.
source
=
=
=
obj
&
&
meta
.
readableCache
(
)
;
var
ret
=
cache
&
&
cache
[
key
]
;
if
(
ret
=
=
=
UNDEFINED
)
{
return
undefined
;
}
return
ret
;
}
cacheFor
.
set
=
function
(
cache
key
value
)
{
if
(
value
=
=
=
undefined
)
{
cache
[
key
]
=
UNDEFINED
;
}
else
{
cache
[
key
]
=
value
;
}
}
;
cacheFor
.
get
=
function
(
cache
key
)
{
var
ret
=
cache
[
key
]
;
if
(
ret
=
=
=
UNDEFINED
)
{
return
undefined
;
}
return
ret
;
}
;
cacheFor
.
remove
=
function
(
cache
key
)
{
cache
[
key
]
=
undefined
;
}
;
exports
.
ComputedProperty
=
ComputedProperty
;
exports
.
computed
=
computed
;
exports
.
cacheFor
=
cacheFor
;
}
)
;
enifed
(
'
ember
-
metal
/
computed_macros
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
is_empty
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
alias
'
'
ember
-
metal
/
expand_properties
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalComputed
_emberMetalIs_empty
_emberMetalIs_none
_emberMetalAlias
_emberMetalExpand_properties
)
{
'
use
strict
'
;
exports
.
empty
=
empty
;
exports
.
notEmpty
=
notEmpty
;
exports
.
none
=
none
;
exports
.
not
=
not
;
exports
.
bool
=
bool
;
exports
.
match
=
match
;
exports
.
equal
=
equal
;
exports
.
gt
=
gt
;
exports
.
gte
=
gte
;
exports
.
lt
=
lt
;
exports
.
lte
=
lte
;
exports
.
oneWay
=
oneWay
;
exports
.
readOnly
=
readOnly
;
exports
.
deprecatingAlias
=
deprecatingAlias
;
function
getProperties
(
self
propertyNames
)
{
var
ret
=
{
}
;
for
(
var
i
=
0
;
i
<
propertyNames
.
length
;
i
+
+
)
{
ret
[
propertyNames
[
i
]
]
=
_emberMetalProperty_get
.
get
(
self
propertyNames
[
i
]
)
;
}
return
ret
;
}
function
generateComputedWithProperties
(
macro
)
{
return
function
(
)
{
var
expandedProperties
=
[
]
;
var
computedFunc
=
_emberMetalComputed
.
computed
(
function
(
)
{
return
macro
.
apply
(
this
[
getProperties
(
this
expandedProperties
)
]
)
;
}
)
;
function
extractProperty
(
entry
)
{
expandedProperties
.
push
(
entry
)
;
}
for
(
var
_len
=
arguments
.
length
properties
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
properties
[
_key
]
=
arguments
[
_key
]
;
}
for
(
var
i
=
0
;
i
<
properties
.
length
;
i
+
+
)
{
_emberMetalExpand_properties
.
default
(
properties
[
i
]
extractProperty
)
;
}
return
computedFunc
.
property
.
apply
(
computedFunc
expandedProperties
)
;
}
;
}
function
empty
(
dependentKey
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
+
'
.
length
'
function
(
)
{
return
_emberMetalIs_empty
.
default
(
_emberMetalProperty_get
.
get
(
this
dependentKey
)
)
;
}
)
;
}
function
notEmpty
(
dependentKey
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
+
'
.
length
'
function
(
)
{
return
!
_emberMetalIs_empty
.
default
(
_emberMetalProperty_get
.
get
(
this
dependentKey
)
)
;
}
)
;
}
function
none
(
dependentKey
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
_emberMetalIs_none
.
default
(
_emberMetalProperty_get
.
get
(
this
dependentKey
)
)
;
}
)
;
}
function
not
(
dependentKey
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
!
_emberMetalProperty_get
.
get
(
this
dependentKey
)
;
}
)
;
}
function
bool
(
dependentKey
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
!
!
_emberMetalProperty_get
.
get
(
this
dependentKey
)
;
}
)
;
}
function
match
(
dependentKey
regexp
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
var
value
=
_emberMetalProperty_get
.
get
(
this
dependentKey
)
;
return
typeof
value
=
=
=
'
string
'
?
regexp
.
test
(
value
)
:
false
;
}
)
;
}
function
equal
(
dependentKey
value
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
dependentKey
)
=
=
=
value
;
}
)
;
}
function
gt
(
dependentKey
value
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
dependentKey
)
>
value
;
}
)
;
}
function
gte
(
dependentKey
value
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
dependentKey
)
>
=
value
;
}
)
;
}
function
lt
(
dependentKey
value
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
dependentKey
)
<
value
;
}
)
;
}
function
lte
(
dependentKey
value
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
dependentKey
)
<
=
value
;
}
)
;
}
var
and
=
generateComputedWithProperties
(
function
(
properties
)
{
var
value
;
for
(
var
key
in
properties
)
{
value
=
properties
[
key
]
;
if
(
properties
.
hasOwnProperty
(
key
)
&
&
!
value
)
{
return
value
;
}
}
return
value
;
}
)
;
exports
.
and
=
and
;
var
or
=
generateComputedWithProperties
(
function
(
properties
)
{
var
value
;
for
(
var
key
in
properties
)
{
value
=
properties
[
key
]
;
if
(
properties
.
hasOwnProperty
(
key
)
&
&
value
)
{
return
value
;
}
}
return
value
;
}
)
;
exports
.
or
=
or
;
function
oneWay
(
dependentKey
)
{
return
_emberMetalAlias
.
default
(
dependentKey
)
.
oneWay
(
)
;
}
function
readOnly
(
dependentKey
)
{
return
_emberMetalAlias
.
default
(
dependentKey
)
.
readOnly
(
)
;
}
function
deprecatingAlias
(
dependentKey
options
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
{
get
:
function
(
key
)
{
_emberMetalDebug
.
deprecate
(
'
Usage
of
'
+
key
+
'
is
deprecated
use
'
+
dependentKey
+
'
instead
.
'
false
options
)
;
return
_emberMetalProperty_get
.
get
(
this
dependentKey
)
;
}
set
:
function
(
key
value
)
{
_emberMetalDebug
.
deprecate
(
'
Usage
of
'
+
key
+
'
is
deprecated
use
'
+
dependentKey
+
'
instead
.
'
false
options
)
;
_emberMetalProperty_set
.
set
(
this
dependentKey
value
)
;
return
value
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
core
'
[
'
exports
'
'
require
'
]
function
(
exports
_require
)
{
'
use
strict
'
;
if
(
'
undefined
'
=
=
=
typeof
Ember
)
{
Ember
=
{
}
;
}
var
global
=
mainContext
|
|
{
}
;
Ember
.
imports
=
Ember
.
imports
|
|
global
;
Ember
.
lookup
=
Ember
.
lookup
|
|
global
;
var
emExports
=
Ember
.
exports
=
Ember
.
exports
|
|
global
;
emExports
.
Em
=
emExports
.
Ember
=
Ember
;
Ember
.
isNamespace
=
true
;
Ember
.
toString
=
function
(
)
{
return
'
Ember
'
;
}
;
var
debugModule
=
_require
.
default
(
'
ember
-
metal
/
debug
'
)
;
Ember
.
assert
=
debugModule
.
assert
;
Ember
.
warn
=
debugModule
.
warn
;
Ember
.
debug
=
debugModule
.
debug
;
Ember
.
deprecate
=
debugModule
.
deprecate
;
Ember
.
deprecateFunc
=
debugModule
.
deprecateFunc
;
Ember
.
runInDebug
=
debugModule
.
runInDebug
;
Ember
.
VERSION
=
'
2
.
6
.
2
'
;
if
(
Ember
.
ENV
)
{
Ember
.
assert
(
'
Ember
.
ENV
should
be
an
object
.
'
'
object
'
!
=
=
typeof
Ember
.
ENV
)
;
}
else
if
(
'
undefined
'
!
=
=
typeof
EmberENV
)
{
Ember
.
ENV
=
EmberENV
;
}
else
if
(
'
undefined
'
!
=
=
typeof
ENV
)
{
Ember
.
ENV
=
ENV
;
}
else
{
Ember
.
ENV
=
{
}
;
}
if
(
Ember
.
ENV
.
ENABLE_ALL_FEATURES
)
{
Ember
.
ENV
.
ENABLE_OPTIONAL_FEATURES
=
Ember
.
ENV
.
ENABLE_ALL_FEATURES
;
}
Ember
.
config
=
Ember
.
config
|
|
{
}
;
Ember
.
EXTEND_PROTOTYPES
=
Ember
.
ENV
.
EXTEND_PROTOTYPES
;
if
(
typeof
Ember
.
EXTEND_PROTOTYPES
=
=
=
'
undefined
'
)
{
Ember
.
EXTEND_PROTOTYPES
=
true
;
}
Ember
.
LOG_STACKTRACE_ON_DEPRECATION
=
Ember
.
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
!
=
=
false
;
Ember
.
LOG_VERSION
=
Ember
.
ENV
.
LOG_VERSION
=
=
=
false
?
false
:
true
;
function
K
(
)
{
return
this
;
}
exports
.
K
=
K
;
Ember
.
K
=
K
;
exports
.
default
=
Ember
;
}
)
;
enifed
(
"
ember
-
metal
/
debug
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
getDebugFunction
=
getDebugFunction
;
exports
.
setDebugFunction
=
setDebugFunction
;
exports
.
assert
=
assert
;
exports
.
info
=
info
;
exports
.
warn
=
warn
;
exports
.
debug
=
debug
;
exports
.
deprecate
=
deprecate
;
exports
.
deprecateFunc
=
deprecateFunc
;
exports
.
runInDebug
=
runInDebug
;
exports
.
debugSeal
=
debugSeal
;
var
debugFunctions
=
{
assert
:
function
(
)
{
}
info
:
function
(
)
{
}
warn
:
function
(
)
{
}
debug
:
function
(
)
{
}
deprecate
:
function
(
)
{
}
deprecateFunc
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
args
[
args
.
length
-
1
]
;
}
runInDebug
:
function
(
)
{
}
debugSeal
:
function
(
)
{
}
}
;
exports
.
debugFunctions
=
debugFunctions
;
function
getDebugFunction
(
name
)
{
return
debugFunctions
[
name
]
;
}
function
setDebugFunction
(
name
fn
)
{
debugFunctions
[
name
]
=
fn
;
}
function
assert
(
)
{
return
debugFunctions
.
assert
.
apply
(
undefined
arguments
)
;
}
function
info
(
)
{
return
debugFunctions
.
info
.
apply
(
undefined
arguments
)
;
}
function
warn
(
)
{
return
debugFunctions
.
warn
.
apply
(
undefined
arguments
)
;
}
function
debug
(
)
{
return
debugFunctions
.
debug
.
apply
(
undefined
arguments
)
;
}
function
deprecate
(
)
{
return
debugFunctions
.
deprecate
.
apply
(
undefined
arguments
)
;
}
function
deprecateFunc
(
)
{
return
debugFunctions
.
deprecateFunc
.
apply
(
undefined
arguments
)
;
}
function
runInDebug
(
)
{
return
debugFunctions
.
runInDebug
.
apply
(
undefined
arguments
)
;
}
function
debugSeal
(
)
{
return
debugFunctions
.
debugSeal
.
apply
(
undefined
arguments
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
dependent_keys
'
[
'
exports
'
'
ember
-
metal
/
watching
'
]
function
(
exports
_emberMetalWatching
)
{
'
no
use
strict
'
;
exports
.
addDependentKeys
=
addDependentKeys
;
exports
.
removeDependentKeys
=
removeDependentKeys
;
function
addDependentKeys
(
desc
obj
keyName
meta
)
{
var
idx
len
depKey
;
var
depKeys
=
desc
.
_dependentKeys
;
if
(
!
depKeys
)
{
return
;
}
for
(
idx
=
0
len
=
depKeys
.
length
;
idx
<
len
;
idx
+
+
)
{
depKey
=
depKeys
[
idx
]
;
meta
.
writeDeps
(
depKey
keyName
(
meta
.
peekDeps
(
depKey
keyName
)
|
|
0
)
+
1
)
;
_emberMetalWatching
.
watch
(
obj
depKey
meta
)
;
}
}
function
removeDependentKeys
(
desc
obj
keyName
meta
)
{
var
depKeys
=
desc
.
_dependentKeys
;
var
idx
len
depKey
;
if
(
!
depKeys
)
{
return
;
}
for
(
idx
=
0
len
=
depKeys
.
length
;
idx
<
len
;
idx
+
+
)
{
depKey
=
depKeys
[
idx
]
;
meta
.
writeDeps
(
depKey
keyName
(
meta
.
peekDeps
(
depKey
keyName
)
|
|
0
)
-
1
)
;
_emberMetalWatching
.
unwatch
(
obj
depKey
meta
)
;
}
}
}
)
;
enifed
(
'
ember
-
metal
/
deprecate_property
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
)
{
'
use
strict
'
;
exports
.
deprecateProperty
=
deprecateProperty
;
function
deprecateProperty
(
object
deprecatedKey
newKey
options
)
{
function
_deprecate
(
)
{
_emberMetalDebug
.
deprecate
(
'
Usage
of
'
+
deprecatedKey
+
'
is
deprecated
use
'
+
newKey
+
'
instead
.
'
false
options
)
;
}
Object
.
defineProperty
(
object
deprecatedKey
{
configurable
:
true
enumerable
:
false
set
:
function
(
value
)
{
_deprecate
(
)
;
_emberMetalProperty_set
.
set
(
this
newKey
value
)
;
}
get
:
function
(
)
{
_deprecate
(
)
;
return
_emberMetalProperty_get
.
get
(
this
newKey
)
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
dictionary
'
[
'
exports
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalEmpty_object
)
{
'
use
strict
'
;
exports
.
default
=
makeDictionary
;
function
makeDictionary
(
parent
)
{
var
dict
;
if
(
parent
=
=
=
null
)
{
dict
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
else
{
dict
=
Object
.
create
(
parent
)
;
}
dict
[
'
_dict
'
]
=
null
;
delete
dict
[
'
_dict
'
]
;
return
dict
;
}
}
)
;
enifed
(
"
ember
-
metal
/
empty_object
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
proto
=
Object
.
create
(
null
{
constructor
:
{
value
:
undefined
enumerable
:
false
writable
:
true
}
}
)
;
function
EmptyObject
(
)
{
}
EmptyObject
.
prototype
=
proto
;
exports
.
default
=
EmptyObject
;
}
)
;
enifed
(
'
ember
-
metal
/
environment
'
[
'
exports
'
'
ember
-
metal
/
core
'
]
function
(
exports
_emberMetalCore
)
{
'
use
strict
'
;
var
environment
;
var
hasDOM
=
typeof
window
!
=
=
'
undefined
'
&
&
typeof
document
!
=
=
'
undefined
'
&
&
typeof
document
.
createElement
!
=
=
'
undefined
'
&
&
!
_emberMetalCore
.
default
.
ENV
.
disableBrowserEnvironment
;
if
(
hasDOM
)
{
environment
=
{
hasDOM
:
true
isChrome
:
!
!
window
.
chrome
&
&
!
window
.
opera
isFirefox
:
typeof
InstallTrigger
!
=
=
'
undefined
'
isPhantom
:
!
!
window
.
callPhantom
location
:
window
.
location
history
:
window
.
history
userAgent
:
window
.
navigator
.
userAgent
global
:
window
}
;
}
else
{
environment
=
{
hasDOM
:
false
isChrome
:
false
isFirefox
:
false
isPhantom
:
false
location
:
null
history
:
null
userAgent
:
'
Lynx
(
textmode
)
'
global
:
null
}
;
}
exports
.
default
=
environment
;
}
)
;
enifed
(
'
ember
-
metal
/
error
'
[
'
exports
'
'
ember
-
metal
/
core
'
]
function
(
exports
_emberMetalCore
)
{
'
use
strict
'
;
exports
.
default
=
EmberError
;
var
errorProps
=
[
'
description
'
'
fileName
'
'
lineNumber
'
'
message
'
'
name
'
'
number
'
'
stack
'
]
;
function
EmberError
(
)
{
var
tmp
=
Error
.
apply
(
this
arguments
)
;
if
(
Error
.
captureStackTrace
)
{
Error
.
captureStackTrace
(
this
_emberMetalCore
.
default
.
Error
)
;
}
for
(
var
idx
=
0
;
idx
<
errorProps
.
length
;
idx
+
+
)
{
this
[
errorProps
[
idx
]
]
=
tmp
[
errorProps
[
idx
]
]
;
}
}
EmberError
.
prototype
=
Object
.
create
(
Error
.
prototype
)
;
}
)
;
enifed
(
'
ember
-
metal
/
events
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
meta_listeners
'
]
function
(
exports
_emberMetalDebug
_emberMetalUtils
_emberMetalMeta
_emberMetalMeta_listeners
)
{
'
no
use
strict
'
;
exports
.
accumulateListeners
=
accumulateListeners
;
exports
.
addListener
=
addListener
;
exports
.
removeListener
=
removeListener
;
exports
.
suspendListener
=
suspendListener
;
exports
.
suspendListeners
=
suspendListeners
;
exports
.
watchedEvents
=
watchedEvents
;
exports
.
sendEvent
=
sendEvent
;
exports
.
hasListeners
=
hasListeners
;
exports
.
listenersFor
=
listenersFor
;
exports
.
on
=
on
;
function
indexOf
(
array
target
method
)
{
var
index
=
-
1
;
for
(
var
i
=
array
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
if
(
target
=
=
=
array
[
i
]
&
&
method
=
=
=
array
[
i
+
1
]
)
{
index
=
i
;
break
;
}
}
return
index
;
}
function
accumulateListeners
(
obj
eventName
otherActions
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
!
meta
)
{
return
;
}
var
actions
=
meta
.
matchingListeners
(
eventName
)
;
var
newActions
=
[
]
;
for
(
var
i
=
actions
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
var
target
=
actions
[
i
]
;
var
method
=
actions
[
i
+
1
]
;
var
flags
=
actions
[
i
+
2
]
;
var
actionIndex
=
indexOf
(
otherActions
target
method
)
;
if
(
actionIndex
=
=
=
-
1
)
{
otherActions
.
push
(
target
method
flags
)
;
newActions
.
push
(
target
method
flags
)
;
}
}
return
newActions
;
}
function
addListener
(
obj
eventName
target
method
once
)
{
_emberMetalDebug
.
assert
(
'
You
must
pass
at
least
an
object
and
event
name
to
Ember
.
addListener
'
!
!
obj
&
&
!
!
eventName
)
;
_emberMetalDebug
.
deprecate
(
'
didInitAttrs
called
in
'
+
(
obj
&
&
obj
.
toString
&
&
obj
.
toString
(
)
)
+
'
.
'
eventName
!
=
=
'
didInitAttrs
'
{
id
:
'
ember
-
views
.
did
-
init
-
attrs
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_ember
-
component
-
didinitattrs
'
}
)
;
if
(
!
method
&
&
'
function
'
=
=
=
typeof
target
)
{
method
=
target
;
target
=
null
;
}
var
flags
=
0
;
if
(
once
)
{
flags
|
=
_emberMetalMeta_listeners
.
ONCE
;
}
_emberMetalMeta
.
meta
(
obj
)
.
addToListeners
(
eventName
target
method
flags
)
;
if
(
'
function
'
=
=
=
typeof
obj
.
didAddListener
)
{
obj
.
didAddListener
(
eventName
target
method
)
;
}
}
function
removeListener
(
obj
eventName
target
method
)
{
_emberMetalDebug
.
assert
(
'
You
must
pass
at
least
an
object
and
event
name
to
Ember
.
removeListener
'
!
!
obj
&
&
!
!
eventName
)
;
if
(
!
method
&
&
'
function
'
=
=
=
typeof
target
)
{
method
=
target
;
target
=
null
;
}
_emberMetalMeta
.
meta
(
obj
)
.
removeFromListeners
(
eventName
target
method
function
(
)
{
if
(
'
function
'
=
=
=
typeof
obj
.
didRemoveListener
)
{
obj
.
didRemoveListener
.
apply
(
obj
arguments
)
;
}
}
)
;
}
function
suspendListener
(
obj
eventName
target
method
callback
)
{
return
suspendListeners
(
obj
[
eventName
]
target
method
callback
)
;
}
function
suspendListeners
(
obj
eventNames
target
method
callback
)
{
if
(
!
method
&
&
'
function
'
=
=
=
typeof
target
)
{
method
=
target
;
target
=
null
;
}
return
_emberMetalMeta
.
meta
(
obj
)
.
suspendListeners
(
eventNames
target
method
callback
)
;
}
function
watchedEvents
(
obj
)
{
return
_emberMetalMeta
.
meta
(
obj
)
.
watchedEvents
(
)
;
}
function
sendEvent
(
obj
eventName
params
actions
)
{
if
(
!
actions
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
actions
=
meta
&
&
meta
.
matchingListeners
(
eventName
)
;
}
if
(
!
actions
|
|
actions
.
length
=
=
=
0
)
{
return
;
}
for
(
var
i
=
actions
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
var
target
=
actions
[
i
]
;
var
method
=
actions
[
i
+
1
]
;
var
flags
=
actions
[
i
+
2
]
;
if
(
!
method
)
{
continue
;
}
if
(
flags
&
_emberMetalMeta_listeners
.
SUSPENDED
)
{
continue
;
}
if
(
flags
&
_emberMetalMeta_listeners
.
ONCE
)
{
removeListener
(
obj
eventName
target
method
)
;
}
if
(
!
target
)
{
target
=
obj
;
}
if
(
'
string
'
=
=
=
typeof
method
)
{
if
(
params
)
{
_emberMetalUtils
.
applyStr
(
target
method
params
)
;
}
else
{
target
[
method
]
(
)
;
}
}
else
{
if
(
params
)
{
method
.
apply
(
target
params
)
;
}
else
{
method
.
call
(
target
)
;
}
}
}
return
true
;
}
function
hasListeners
(
obj
eventName
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
!
meta
)
{
return
false
;
}
return
meta
.
matchingListeners
(
eventName
)
.
length
>
0
;
}
function
listenersFor
(
obj
eventName
)
{
var
ret
=
[
]
;
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
var
actions
=
meta
&
&
meta
.
matchingListeners
(
eventName
)
;
if
(
!
actions
)
{
return
ret
;
}
for
(
var
i
=
0
l
=
actions
.
length
;
i
<
l
;
i
+
=
3
)
{
var
target
=
actions
[
i
]
;
var
method
=
actions
[
i
+
1
]
;
ret
.
push
(
[
target
method
]
)
;
}
return
ret
;
}
function
on
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
var
func
=
args
.
pop
(
)
;
var
events
=
args
;
func
.
__ember_listens__
=
events
;
return
func
;
}
}
)
;
enifed
(
'
ember
-
metal
/
expand_properties
'
[
'
exports
'
'
ember
-
metal
/
debug
'
]
function
(
exports
_emberMetalDebug
)
{
'
use
strict
'
;
exports
.
default
=
expandProperties
;
var
SPLIT_REGEX
=
/
\
{
|
\
}
/
;
var
END_WITH_EACH_REGEX
=
/
\
.
each
/
;
function
expandProperties
(
pattern
callback
)
{
_emberMetalDebug
.
assert
(
'
A
computed
property
key
must
be
a
string
'
typeof
pattern
=
=
=
'
string
'
)
;
_emberMetalDebug
.
assert
(
'
Brace
expanded
properties
cannot
contain
spaces
e
.
g
.
"
user
.
{
firstName
lastName
}
"
should
be
"
user
.
{
firstName
lastName
}
"
'
pattern
.
indexOf
(
'
'
)
=
=
=
-
1
)
;
var
parts
=
pattern
.
split
(
SPLIT_REGEX
)
;
var
properties
=
[
parts
]
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
var
part
=
parts
[
i
]
;
if
(
part
.
indexOf
(
'
'
)
>
=
0
)
{
properties
=
duplicateAndReplace
(
properties
part
.
split
(
'
'
)
i
)
;
}
}
for
(
var
i
=
0
;
i
<
properties
.
length
;
i
+
+
)
{
callback
(
properties
[
i
]
.
join
(
'
'
)
.
replace
(
END_WITH_EACH_REGEX
'
.
[
]
'
)
)
;
}
}
function
duplicateAndReplace
(
properties
currentParts
index
)
{
var
all
=
[
]
;
properties
.
forEach
(
function
(
property
)
{
currentParts
.
forEach
(
function
(
part
)
{
var
current
=
property
.
slice
(
0
)
;
current
[
index
]
=
part
;
all
.
push
(
current
)
;
}
)
;
}
)
;
return
all
;
}
}
)
;
enifed
(
'
ember
-
metal
/
features
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_emberMetalCore
_emberMetalAssign
)
{
'
use
strict
'
;
exports
.
default
=
isEnabled
;
var
KNOWN_FEATURES
=
{
}
;
exports
.
KNOWN_FEATURES
=
KNOWN_FEATURES
;
var
FEATURES
=
_emberMetalAssign
.
default
(
KNOWN_FEATURES
_emberMetalCore
.
default
.
ENV
.
FEATURES
)
;
exports
.
FEATURES
=
FEATURES
;
function
isEnabled
(
feature
)
{
var
featureValue
=
FEATURES
[
feature
]
;
if
(
featureValue
=
=
=
true
|
|
featureValue
=
=
=
false
|
|
featureValue
=
=
=
undefined
)
{
return
featureValue
;
}
else
if
(
_emberMetalCore
.
default
.
ENV
.
ENABLE_OPTIONAL_FEATURES
)
{
return
true
;
}
else
{
return
false
;
}
}
}
)
;
enifed
(
'
ember
-
metal
/
get_properties
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalProperty_get
)
{
'
use
strict
'
;
exports
.
default
=
getProperties
;
function
getProperties
(
obj
)
{
var
ret
=
{
}
;
var
propertyNames
=
arguments
;
var
i
=
1
;
if
(
arguments
.
length
=
=
=
2
&
&
Array
.
isArray
(
arguments
[
1
]
)
)
{
i
=
0
;
propertyNames
=
arguments
[
1
]
;
}
for
(
var
len
=
propertyNames
.
length
;
i
<
len
;
i
+
+
)
{
ret
[
propertyNames
[
i
]
]
=
_emberMetalProperty_get
.
get
(
obj
propertyNames
[
i
]
)
;
}
return
ret
;
}
}
)
;
enifed
(
'
ember
-
metal
/
index
'
[
'
exports
'
'
require
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
merge
'
'
ember
-
metal
/
instrumentation
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
cache
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
observer_set
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
map
'
'
ember
-
metal
/
get_properties
'
'
ember
-
metal
/
set_properties
'
'
ember
-
metal
/
watch_key
'
'
ember
-
metal
/
chains
'
'
ember
-
metal
/
watch_path
'
'
ember
-
metal
/
watching
'
'
ember
-
metal
/
expand_properties
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
alias
'
'
ember
-
metal
/
computed_macros
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
binding
'
'
ember
-
metal
/
path_cache
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
libraries
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
is_empty
'
'
ember
-
metal
/
is_blank
'
'
ember
-
metal
/
is_present
'
'
backburner
'
]
function
(
exports
_require
_emberMetalCore
_emberMetalDebug
_emberMetalFeatures
_emberMetalAssign
_emberMetalMerge
_emberMetalInstrumentation
_emberMetalUtils
_emberMetalMeta
_emberMetalError
_emberMetalCache
_emberMetalLogger
_emberMetalProperty_get
_emberMetalEvents
_emberMetalObserver_set
_emberMetalProperty_events
_emberMetalProperties
_emberMetalProperty_set
_emberMetalMap
_emberMetalGet_properties
_emberMetalSet_properties
_emberMetalWatch_key
_emberMetalChains
_emberMetalWatch_path
_emberMetalWatching
_emberMetalExpand_properties
_emberMetalComputed
_emberMetalAlias
_emberMetalComputed_macros
_emberMetalObserver
_emberMetalMixin
_emberMetalBinding
_emberMetalPath_cache
_emberMetalRun_loop
_emberMetalLibraries
_emberMetalIs_none
_emberMetalIs_empty
_emberMetalIs_blank
_emberMetalIs_present
_backburner
)
{
'
use
strict
'
;
_emberMetalComputed
.
computed
.
empty
=
_emberMetalComputed_macros
.
empty
;
_emberMetalComputed
.
computed
.
notEmpty
=
_emberMetalComputed_macros
.
notEmpty
;
_emberMetalComputed
.
computed
.
none
=
_emberMetalComputed_macros
.
none
;
_emberMetalComputed
.
computed
.
not
=
_emberMetalComputed_macros
.
not
;
_emberMetalComputed
.
computed
.
bool
=
_emberMetalComputed_macros
.
bool
;
_emberMetalComputed
.
computed
.
match
=
_emberMetalComputed_macros
.
match
;
_emberMetalComputed
.
computed
.
equal
=
_emberMetalComputed_macros
.
equal
;
_emberMetalComputed
.
computed
.
gt
=
_emberMetalComputed_macros
.
gt
;
_emberMetalComputed
.
computed
.
gte
=
_emberMetalComputed_macros
.
gte
;
_emberMetalComputed
.
computed
.
lt
=
_emberMetalComputed_macros
.
lt
;
_emberMetalComputed
.
computed
.
lte
=
_emberMetalComputed_macros
.
lte
;
_emberMetalComputed
.
computed
.
alias
=
_emberMetalAlias
.
default
;
_emberMetalComputed
.
computed
.
oneWay
=
_emberMetalComputed_macros
.
oneWay
;
_emberMetalComputed
.
computed
.
reads
=
_emberMetalComputed_macros
.
oneWay
;
_emberMetalComputed
.
computed
.
readOnly
=
_emberMetalComputed_macros
.
readOnly
;
_emberMetalComputed
.
computed
.
defaultTo
=
_emberMetalComputed_macros
.
defaultTo
;
_emberMetalComputed
.
computed
.
deprecatingAlias
=
_emberMetalComputed_macros
.
deprecatingAlias
;
_emberMetalComputed
.
computed
.
and
=
_emberMetalComputed_macros
.
and
;
_emberMetalComputed
.
computed
.
or
=
_emberMetalComputed_macros
.
or
;
_emberMetalComputed
.
computed
.
any
=
_emberMetalComputed_macros
.
any
;
var
EmberInstrumentation
=
_emberMetalCore
.
default
.
Instrumentation
=
{
}
;
EmberInstrumentation
.
instrument
=
_emberMetalInstrumentation
.
instrument
;
EmberInstrumentation
.
subscribe
=
_emberMetalInstrumentation
.
subscribe
;
EmberInstrumentation
.
unsubscribe
=
_emberMetalInstrumentation
.
unsubscribe
;
EmberInstrumentation
.
reset
=
_emberMetalInstrumentation
.
reset
;
_emberMetalCore
.
default
.
instrument
=
_emberMetalInstrumentation
.
instrument
;
_emberMetalCore
.
default
.
subscribe
=
_emberMetalInstrumentation
.
subscribe
;
_emberMetalCore
.
default
.
_Cache
=
_emberMetalCache
.
default
;
_emberMetalCore
.
default
.
generateGuid
=
_emberMetalUtils
.
generateGuid
;
_emberMetalCore
.
default
.
GUID_KEY
=
_emberMetalUtils
.
GUID_KEY
;
_emberMetalCore
.
default
.
platform
=
{
defineProperty
:
true
hasPropertyAccessors
:
true
}
;
_emberMetalCore
.
default
.
Error
=
_emberMetalError
.
default
;
_emberMetalCore
.
default
.
guidFor
=
_emberMetalUtils
.
guidFor
;
_emberMetalCore
.
default
.
META_DESC
=
_emberMetalMeta
.
META_DESC
;
_emberMetalCore
.
default
.
meta
=
_emberMetalMeta
.
meta
;
_emberMetalCore
.
default
.
inspect
=
_emberMetalUtils
.
inspect
;
_emberMetalCore
.
default
.
tryCatchFinally
=
_emberMetalUtils
.
deprecatedTryCatchFinally
;
_emberMetalCore
.
default
.
makeArray
=
_emberMetalUtils
.
makeArray
;
_emberMetalCore
.
default
.
canInvoke
=
_emberMetalUtils
.
canInvoke
;
_emberMetalCore
.
default
.
tryInvoke
=
_emberMetalUtils
.
tryInvoke
;
_emberMetalCore
.
default
.
wrap
=
_emberMetalUtils
.
wrap
;
_emberMetalCore
.
default
.
apply
=
_emberMetalUtils
.
apply
;
_emberMetalCore
.
default
.
applyStr
=
_emberMetalUtils
.
applyStr
;
_emberMetalCore
.
default
.
uuid
=
_emberMetalUtils
.
uuid
;
_emberMetalCore
.
default
.
Logger
=
_emberMetalLogger
.
default
;
_emberMetalCore
.
default
.
get
=
_emberMetalProperty_get
.
get
;
_emberMetalCore
.
default
.
getWithDefault
=
_emberMetalProperty_get
.
getWithDefault
;
_emberMetalCore
.
default
.
_getPath
=
_emberMetalProperty_get
.
_getPath
;
_emberMetalCore
.
default
.
on
=
_emberMetalEvents
.
on
;
_emberMetalCore
.
default
.
addListener
=
_emberMetalEvents
.
addListener
;
_emberMetalCore
.
default
.
removeListener
=
_emberMetalEvents
.
removeListener
;
_emberMetalCore
.
default
.
_suspendListener
=
_emberMetalEvents
.
suspendListener
;
_emberMetalCore
.
default
.
_suspendListeners
=
_emberMetalEvents
.
suspendListeners
;
_emberMetalCore
.
default
.
sendEvent
=
_emberMetalEvents
.
sendEvent
;
_emberMetalCore
.
default
.
hasListeners
=
_emberMetalEvents
.
hasListeners
;
_emberMetalCore
.
default
.
watchedEvents
=
_emberMetalEvents
.
watchedEvents
;
_emberMetalCore
.
default
.
listenersFor
=
_emberMetalEvents
.
listenersFor
;
_emberMetalCore
.
default
.
accumulateListeners
=
_emberMetalEvents
.
accumulateListeners
;
_emberMetalCore
.
default
.
_ObserverSet
=
_emberMetalObserver_set
.
default
;
_emberMetalCore
.
default
.
propertyWillChange
=
_emberMetalProperty_events
.
propertyWillChange
;
_emberMetalCore
.
default
.
propertyDidChange
=
_emberMetalProperty_events
.
propertyDidChange
;
_emberMetalCore
.
default
.
overrideChains
=
_emberMetalProperty_events
.
overrideChains
;
_emberMetalCore
.
default
.
beginPropertyChanges
=
_emberMetalProperty_events
.
beginPropertyChanges
;
_emberMetalCore
.
default
.
endPropertyChanges
=
_emberMetalProperty_events
.
endPropertyChanges
;
_emberMetalCore
.
default
.
changeProperties
=
_emberMetalProperty_events
.
changeProperties
;
_emberMetalCore
.
default
.
defineProperty
=
_emberMetalProperties
.
defineProperty
;
_emberMetalCore
.
default
.
set
=
_emberMetalProperty_set
.
set
;
_emberMetalCore
.
default
.
trySet
=
_emberMetalProperty_set
.
trySet
;
_emberMetalCore
.
default
.
OrderedSet
=
_emberMetalMap
.
OrderedSet
;
_emberMetalCore
.
default
.
Map
=
_emberMetalMap
.
Map
;
_emberMetalCore
.
default
.
MapWithDefault
=
_emberMetalMap
.
MapWithDefault
;
_emberMetalCore
.
default
.
getProperties
=
_emberMetalGet_properties
.
default
;
_emberMetalCore
.
default
.
setProperties
=
_emberMetalSet_properties
.
default
;
_emberMetalCore
.
default
.
watchKey
=
_emberMetalWatch_key
.
watchKey
;
_emberMetalCore
.
default
.
unwatchKey
=
_emberMetalWatch_key
.
unwatchKey
;
_emberMetalCore
.
default
.
removeChainWatcher
=
_emberMetalChains
.
removeChainWatcher
;
_emberMetalCore
.
default
.
_ChainNode
=
_emberMetalChains
.
ChainNode
;
_emberMetalCore
.
default
.
finishChains
=
_emberMetalChains
.
finishChains
;
_emberMetalCore
.
default
.
watchPath
=
_emberMetalWatch_path
.
watchPath
;
_emberMetalCore
.
default
.
unwatchPath
=
_emberMetalWatch_path
.
unwatchPath
;
_emberMetalCore
.
default
.
watch
=
_emberMetalWatching
.
watch
;
_emberMetalCore
.
default
.
isWatching
=
_emberMetalWatching
.
isWatching
;
_emberMetalCore
.
default
.
unwatch
=
_emberMetalWatching
.
unwatch
;
_emberMetalCore
.
default
.
rewatch
=
_emberMetalWatching
.
rewatch
;
_emberMetalCore
.
default
.
destroy
=
_emberMetalWatching
.
destroy
;
_emberMetalCore
.
default
.
expandProperties
=
_emberMetalExpand_properties
.
default
;
_emberMetalCore
.
default
.
ComputedProperty
=
_emberMetalComputed
.
ComputedProperty
;
_emberMetalCore
.
default
.
computed
=
_emberMetalComputed
.
computed
;
_emberMetalCore
.
default
.
cacheFor
=
_emberMetalComputed
.
cacheFor
;
_emberMetalCore
.
default
.
addObserver
=
_emberMetalObserver
.
addObserver
;
_emberMetalCore
.
default
.
observersFor
=
_emberMetalObserver
.
observersFor
;
_emberMetalCore
.
default
.
removeObserver
=
_emberMetalObserver
.
removeObserver
;
_emberMetalCore
.
default
.
_suspendObserver
=
_emberMetalObserver
.
_suspendObserver
;
_emberMetalCore
.
default
.
_suspendObservers
=
_emberMetalObserver
.
_suspendObservers
;
_emberMetalCore
.
default
.
IS_BINDING
=
_emberMetalMixin
.
IS_BINDING
;
_emberMetalCore
.
default
.
required
=
_emberMetalMixin
.
required
;
_emberMetalCore
.
default
.
aliasMethod
=
_emberMetalMixin
.
aliasMethod
;
_emberMetalCore
.
default
.
observer
=
_emberMetalMixin
.
observer
;
_emberMetalCore
.
default
.
immediateObserver
=
_emberMetalMixin
.
_immediateObserver
;
_emberMetalCore
.
default
.
mixin
=
_emberMetalMixin
.
mixin
;
_emberMetalCore
.
default
.
Mixin
=
_emberMetalMixin
.
Mixin
;
_emberMetalCore
.
default
.
bind
=
_emberMetalBinding
.
bind
;
_emberMetalCore
.
default
.
Binding
=
_emberMetalBinding
.
Binding
;
_emberMetalCore
.
default
.
isGlobalPath
=
_emberMetalPath_cache
.
isGlobalPath
;
_emberMetalCore
.
default
.
run
=
_emberMetalRun_loop
.
default
;
_emberMetalCore
.
default
.
Backburner
=
_backburner
.
default
;
_emberMetalCore
.
default
.
_Backburner
=
_backburner
.
default
;
_emberMetalCore
.
default
.
libraries
=
new
_emberMetalLibraries
.
default
(
)
;
_emberMetalCore
.
default
.
libraries
.
registerCoreLibrary
(
'
Ember
'
_emberMetalCore
.
default
.
VERSION
)
;
_emberMetalCore
.
default
.
isNone
=
_emberMetalIs_none
.
default
;
_emberMetalCore
.
default
.
isEmpty
=
_emberMetalIs_empty
.
default
;
_emberMetalCore
.
default
.
isBlank
=
_emberMetalIs_blank
.
default
;
_emberMetalCore
.
default
.
isPresent
=
_emberMetalIs_present
.
default
;
_emberMetalCore
.
default
.
assign
=
Object
.
assign
|
|
_emberMetalAssign
.
default
;
_emberMetalCore
.
default
.
merge
=
_emberMetalMerge
.
default
;
_emberMetalCore
.
default
.
FEATURES
=
_emberMetalFeatures
.
FEATURES
;
_emberMetalCore
.
default
.
FEATURES
.
isEnabled
=
_emberMetalFeatures
.
default
;
_emberMetalCore
.
default
.
onerror
=
null
;
if
(
_require
.
has
(
'
ember
-
debug
'
)
)
{
_require
.
default
(
'
ember
-
debug
'
)
;
}
else
{
_emberMetalCore
.
default
.
Debug
=
{
}
;
_emberMetalCore
.
default
.
Debug
.
registerDeprecationHandler
=
function
(
)
{
}
;
_emberMetalCore
.
default
.
Debug
.
registerWarnHandler
=
function
(
)
{
}
;
}
_emberMetalCore
.
default
.
create
=
_emberMetalDebug
.
deprecateFunc
(
'
Ember
.
create
is
deprecated
in
favor
of
Object
.
create
'
{
id
:
'
ember
-
metal
.
ember
-
create
'
until
:
'
3
.
0
.
0
'
}
Object
.
create
)
;
_emberMetalCore
.
default
.
keys
=
_emberMetalDebug
.
deprecateFunc
(
'
Ember
.
keys
is
deprecated
in
favor
of
Object
.
keys
'
{
id
:
'
ember
-
metal
.
ember
.
keys
'
until
:
'
3
.
0
.
0
'
}
Object
.
keys
)
;
exports
.
default
=
_emberMetalCore
.
default
;
}
)
;
enifed
(
'
ember
-
metal
/
injected_property
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
alias
'
'
ember
-
metal
/
properties
'
'
container
/
owner
'
]
function
(
exports
_emberMetalDebug
_emberMetalComputed
_emberMetalAlias
_emberMetalProperties
_containerOwner
)
{
'
use
strict
'
;
function
InjectedProperty
(
type
name
)
{
this
.
type
=
type
;
this
.
name
=
name
;
this
.
_super
Constructor
(
injectedPropertyGet
)
;
AliasedPropertyPrototype
.
oneWay
.
call
(
this
)
;
}
function
injectedPropertyGet
(
keyName
)
{
var
desc
=
this
[
keyName
]
;
var
owner
=
_containerOwner
.
getOwner
(
this
)
|
|
this
.
container
;
_emberMetalDebug
.
assert
(
'
InjectedProperties
should
be
defined
with
the
Ember
.
inject
computed
property
macros
.
'
desc
&
&
desc
.
isDescriptor
&
&
desc
.
type
)
;
_emberMetalDebug
.
assert
(
'
Attempting
to
lookup
an
injected
property
on
an
object
without
a
container
ensure
that
the
object
was
instantiated
via
a
container
.
'
owner
)
;
return
owner
.
lookup
(
desc
.
type
+
'
:
'
+
(
desc
.
name
|
|
keyName
)
)
;
}
InjectedProperty
.
prototype
=
Object
.
create
(
_emberMetalProperties
.
Descriptor
.
prototype
)
;
var
InjectedPropertyPrototype
=
InjectedProperty
.
prototype
;
var
ComputedPropertyPrototype
=
_emberMetalComputed
.
ComputedProperty
.
prototype
;
var
AliasedPropertyPrototype
=
_emberMetalAlias
.
AliasedProperty
.
prototype
;
InjectedPropertyPrototype
.
_super
Constructor
=
_emberMetalComputed
.
ComputedProperty
;
InjectedPropertyPrototype
.
get
=
ComputedPropertyPrototype
.
get
;
InjectedPropertyPrototype
.
readOnly
=
ComputedPropertyPrototype
.
readOnly
;
InjectedPropertyPrototype
.
teardown
=
ComputedPropertyPrototype
.
teardown
;
exports
.
default
=
InjectedProperty
;
}
)
;
enifed
(
'
ember
-
metal
/
instrumentation
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
features
'
]
function
(
exports
_emberMetalCore
_emberMetalFeatures
)
{
'
use
strict
'
;
exports
.
instrument
=
instrument
;
exports
.
_instrumentStart
=
_instrumentStart
;
exports
.
subscribe
=
subscribe
;
exports
.
unsubscribe
=
unsubscribe
;
exports
.
reset
=
reset
;
var
subscribers
=
[
]
;
exports
.
subscribers
=
subscribers
;
var
cache
=
{
}
;
var
populateListeners
=
function
(
name
)
{
var
listeners
=
[
]
;
var
subscriber
;
for
(
var
i
=
0
l
=
subscribers
.
length
;
i
<
l
;
i
+
+
)
{
subscriber
=
subscribers
[
i
]
;
if
(
subscriber
.
regex
.
test
(
name
)
)
{
listeners
.
push
(
subscriber
.
object
)
;
}
}
cache
[
name
]
=
listeners
;
return
listeners
;
}
;
var
time
=
(
function
(
)
{
var
perf
=
'
undefined
'
!
=
=
typeof
window
?
window
.
performance
|
|
{
}
:
{
}
;
var
fn
=
perf
.
now
|
|
perf
.
mozNow
|
|
perf
.
webkitNow
|
|
perf
.
msNow
|
|
perf
.
oNow
;
return
fn
?
fn
.
bind
(
perf
)
:
function
(
)
{
return
+
new
Date
(
)
;
}
;
}
)
(
)
;
function
instrument
(
name
_payload
callback
binding
)
{
if
(
arguments
.
length
<
=
3
&
&
typeof
_payload
=
=
=
'
function
'
)
{
binding
=
callback
;
callback
=
_payload
;
_payload
=
undefined
;
}
if
(
subscribers
.
length
=
=
=
0
)
{
return
callback
.
call
(
binding
)
;
}
var
payload
=
_payload
|
|
{
}
;
var
finalizer
=
_instrumentStart
(
name
function
(
)
{
return
payload
;
}
)
;
if
(
finalizer
)
{
return
withFinalizer
(
callback
finalizer
payload
binding
)
;
}
else
{
return
callback
.
call
(
binding
)
;
}
}
var
flaggedInstrument
;
exports
.
flaggedInstrument
=
flaggedInstrument
=
function
(
name
payload
callback
)
{
return
callback
(
)
;
}
;
exports
.
flaggedInstrument
=
flaggedInstrument
;
function
withFinalizer
(
callback
finalizer
payload
binding
)
{
var
result
=
undefined
;
try
{
result
=
callback
.
call
(
binding
)
;
}
catch
(
e
)
{
payload
.
exception
=
e
;
result
=
payload
;
}
finally
{
finalizer
(
)
;
return
result
;
}
}
function
_instrumentStart
(
name
_payload
)
{
var
listeners
=
cache
[
name
]
;
if
(
!
listeners
)
{
listeners
=
populateListeners
(
name
)
;
}
if
(
listeners
.
length
=
=
=
0
)
{
return
;
}
var
payload
=
_payload
(
)
;
var
STRUCTURED_PROFILE
=
_emberMetalCore
.
default
.
STRUCTURED_PROFILE
;
var
timeName
;
if
(
STRUCTURED_PROFILE
)
{
timeName
=
name
+
'
:
'
+
payload
.
object
;
console
.
time
(
timeName
)
;
}
var
l
=
listeners
.
length
;
var
beforeValues
=
new
Array
(
l
)
;
var
i
listener
;
var
timestamp
=
time
(
)
;
for
(
i
=
0
;
i
<
l
;
i
+
+
)
{
listener
=
listeners
[
i
]
;
beforeValues
[
i
]
=
listener
.
before
(
name
timestamp
payload
)
;
}
return
function
_instrumentEnd
(
)
{
var
i
l
listener
;
var
timestamp
=
time
(
)
;
for
(
i
=
0
l
=
listeners
.
length
;
i
<
l
;
i
+
+
)
{
listener
=
listeners
[
i
]
;
if
(
typeof
listener
.
after
=
=
=
'
function
'
)
{
listener
.
after
(
name
timestamp
payload
beforeValues
[
i
]
)
;
}
}
if
(
STRUCTURED_PROFILE
)
{
console
.
timeEnd
(
timeName
)
;
}
}
;
}
function
subscribe
(
pattern
object
)
{
var
paths
=
pattern
.
split
(
'
.
'
)
;
var
path
;
var
regex
=
[
]
;
for
(
var
i
=
0
l
=
paths
.
length
;
i
<
l
;
i
+
+
)
{
path
=
paths
[
i
]
;
if
(
path
=
=
=
'
*
'
)
{
regex
.
push
(
'
[
^
\
\
.
]
*
'
)
;
}
else
{
regex
.
push
(
path
)
;
}
}
regex
=
regex
.
join
(
'
\
\
.
'
)
;
regex
=
regex
+
'
(
\
\
.
.
*
)
?
'
;
var
subscriber
=
{
pattern
:
pattern
regex
:
new
RegExp
(
'
^
'
+
regex
+
'
'
)
object
:
object
}
;
subscribers
.
push
(
subscriber
)
;
cache
=
{
}
;
return
subscriber
;
}
function
unsubscribe
(
subscriber
)
{
var
index
;
for
(
var
i
=
0
l
=
subscribers
.
length
;
i
<
l
;
i
+
+
)
{
if
(
subscribers
[
i
]
=
=
=
subscriber
)
{
index
=
i
;
}
}
subscribers
.
splice
(
index
1
)
;
cache
=
{
}
;
}
function
reset
(
)
{
subscribers
.
length
=
0
;
cache
=
{
}
;
}
}
)
;
enifed
(
'
ember
-
metal
/
is_blank
'
[
'
exports
'
'
ember
-
metal
/
is_empty
'
]
function
(
exports
_emberMetalIs_empty
)
{
'
use
strict
'
;
exports
.
default
=
isBlank
;
function
isBlank
(
obj
)
{
return
_emberMetalIs_empty
.
default
(
obj
)
|
|
typeof
obj
=
=
=
'
string
'
&
&
obj
.
match
(
/
\
S
/
)
=
=
=
null
;
}
}
)
;
enifed
(
'
ember
-
metal
/
is_empty
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
is_none
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalIs_none
)
{
'
use
strict
'
;
function
isEmpty
(
obj
)
{
var
none
=
_emberMetalIs_none
.
default
(
obj
)
;
if
(
none
)
{
return
none
;
}
if
(
typeof
obj
.
size
=
=
=
'
number
'
)
{
return
!
obj
.
size
;
}
var
objectType
=
typeof
obj
;
if
(
objectType
=
=
=
'
object
'
)
{
var
size
=
_emberMetalProperty_get
.
get
(
obj
'
size
'
)
;
if
(
typeof
size
=
=
=
'
number
'
)
{
return
!
size
;
}
}
if
(
typeof
obj
.
length
=
=
=
'
number
'
&
&
objectType
!
=
=
'
function
'
)
{
return
!
obj
.
length
;
}
if
(
objectType
=
=
=
'
object
'
)
{
var
length
=
_emberMetalProperty_get
.
get
(
obj
'
length
'
)
;
if
(
typeof
length
=
=
=
'
number
'
)
{
return
!
length
;
}
}
return
false
;
}
exports
.
default
=
isEmpty
;
}
)
;
enifed
(
"
ember
-
metal
/
is_none
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
isNone
;
function
isNone
(
obj
)
{
return
obj
=
=
=
null
|
|
obj
=
=
=
undefined
;
}
}
)
;
enifed
(
'
ember
-
metal
/
is_present
'
[
'
exports
'
'
ember
-
metal
/
is_blank
'
]
function
(
exports
_emberMetalIs_blank
)
{
'
use
strict
'
;
exports
.
default
=
isPresent
;
function
isPresent
(
obj
)
{
return
!
_emberMetalIs_blank
.
default
(
obj
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
libraries
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
]
function
(
exports
_emberMetalDebug
_emberMetalFeatures
)
{
'
use
strict
'
;
function
Libraries
(
)
{
this
.
_registry
=
[
]
;
this
.
_coreLibIndex
=
0
;
}
Libraries
.
prototype
=
{
constructor
:
Libraries
_getLibraryByName
:
function
(
name
)
{
var
libs
=
this
.
_registry
;
var
count
=
libs
.
length
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
libs
[
i
]
.
name
=
=
=
name
)
{
return
libs
[
i
]
;
}
}
}
register
:
function
(
name
version
isCoreLibrary
)
{
var
index
=
this
.
_registry
.
length
;
if
(
!
this
.
_getLibraryByName
(
name
)
)
{
if
(
isCoreLibrary
)
{
index
=
this
.
_coreLibIndex
+
+
;
}
this
.
_registry
.
splice
(
index
0
{
name
:
name
version
:
version
}
)
;
}
else
{
_emberMetalDebug
.
warn
(
'
Library
"
'
+
name
+
'
"
is
already
registered
with
Ember
.
'
false
{
id
:
'
ember
-
metal
.
libraries
-
register
'
}
)
;
}
}
registerCoreLibrary
:
function
(
name
version
)
{
this
.
register
(
name
version
true
)
;
}
deRegister
:
function
(
name
)
{
var
lib
=
this
.
_getLibraryByName
(
name
)
;
var
index
;
if
(
lib
)
{
index
=
this
.
_registry
.
indexOf
(
lib
)
;
this
.
_registry
.
splice
(
index
1
)
;
}
}
}
;
exports
.
default
=
Libraries
;
}
)
;
enifed
(
'
ember
-
metal
/
logger
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
error
'
]
function
(
exports
_emberMetalCore
_emberMetalError
)
{
'
use
strict
'
;
function
K
(
)
{
return
this
;
}
function
consoleMethod
(
name
)
{
var
consoleObj
logToConsole
;
if
(
_emberMetalCore
.
default
.
imports
.
console
)
{
consoleObj
=
_emberMetalCore
.
default
.
imports
.
console
;
}
else
if
(
typeof
console
!
=
=
'
undefined
'
)
{
consoleObj
=
console
;
}
var
method
=
typeof
consoleObj
=
=
=
'
object
'
?
consoleObj
[
name
]
:
null
;
if
(
method
)
{
if
(
typeof
method
.
bind
=
=
=
'
function
'
)
{
logToConsole
=
method
.
bind
(
consoleObj
)
;
logToConsole
.
displayName
=
'
console
.
'
+
name
;
return
logToConsole
;
}
else
if
(
typeof
method
.
apply
=
=
=
'
function
'
)
{
logToConsole
=
function
(
)
{
method
.
apply
(
consoleObj
arguments
)
;
}
;
logToConsole
.
displayName
=
'
console
.
'
+
name
;
return
logToConsole
;
}
else
{
return
function
(
)
{
var
message
=
Array
.
prototype
.
join
.
call
(
arguments
'
'
)
;
method
(
message
)
;
}
;
}
}
}
function
assertPolyfill
(
test
message
)
{
if
(
!
test
)
{
try
{
throw
new
_emberMetalError
.
default
(
'
assertion
failed
:
'
+
message
)
;
}
catch
(
error
)
{
setTimeout
(
function
(
)
{
throw
error
;
}
0
)
;
}
}
}
exports
.
default
=
{
log
:
consoleMethod
(
'
log
'
)
|
|
K
warn
:
consoleMethod
(
'
warn
'
)
|
|
K
error
:
consoleMethod
(
'
error
'
)
|
|
K
info
:
consoleMethod
(
'
info
'
)
|
|
K
debug
:
consoleMethod
(
'
debug
'
)
|
|
consoleMethod
(
'
info
'
)
|
|
K
assert
:
consoleMethod
(
'
assert
'
)
|
|
assertPolyfill
}
;
}
)
;
enifed
(
'
ember
-
metal
/
map
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalCore
_emberMetalUtils
_emberMetalEmpty_object
)
{
'
use
strict
'
;
function
missingFunction
(
fn
)
{
throw
new
TypeError
(
Object
.
prototype
.
toString
.
call
(
fn
)
+
'
is
not
a
function
'
)
;
}
function
missingNew
(
name
)
{
throw
new
TypeError
(
'
Constructor
'
+
name
+
'
requires
\
'
new
\
'
'
)
;
}
function
copyNull
(
obj
)
{
var
output
=
new
_emberMetalEmpty_object
.
default
(
)
;
for
(
var
prop
in
obj
)
{
output
[
prop
]
=
obj
[
prop
]
;
}
return
output
;
}
function
copyMap
(
original
newObject
)
{
var
keys
=
original
.
_keys
.
copy
(
)
;
var
values
=
copyNull
(
original
.
_values
)
;
newObject
.
_keys
=
keys
;
newObject
.
_values
=
values
;
newObject
.
size
=
original
.
size
;
return
newObject
;
}
function
OrderedSet
(
)
{
if
(
this
instanceof
OrderedSet
)
{
this
.
clear
(
)
;
this
.
_silenceRemoveDeprecation
=
false
;
}
else
{
missingNew
(
'
OrderedSet
'
)
;
}
}
OrderedSet
.
create
=
function
(
)
{
var
Constructor
=
this
;
return
new
Constructor
(
)
;
}
;
OrderedSet
.
prototype
=
{
constructor
:
OrderedSet
clear
:
function
(
)
{
this
.
presenceSet
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
list
=
[
]
;
this
.
size
=
0
;
}
add
:
function
(
obj
_guid
)
{
var
guid
=
_guid
|
|
_emberMetalUtils
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
var
list
=
this
.
list
;
if
(
presenceSet
[
guid
]
!
=
=
true
)
{
presenceSet
[
guid
]
=
true
;
this
.
size
=
list
.
push
(
obj
)
;
}
return
this
;
}
delete
:
function
(
obj
_guid
)
{
var
guid
=
_guid
|
|
_emberMetalUtils
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
var
list
=
this
.
list
;
if
(
presenceSet
[
guid
]
=
=
=
true
)
{
delete
presenceSet
[
guid
]
;
var
index
=
list
.
indexOf
(
obj
)
;
if
(
index
>
-
1
)
{
list
.
splice
(
index
1
)
;
}
this
.
size
=
list
.
length
;
return
true
;
}
else
{
return
false
;
}
}
isEmpty
:
function
(
)
{
return
this
.
size
=
=
=
0
;
}
has
:
function
(
obj
)
{
if
(
this
.
size
=
=
=
0
)
{
return
false
;
}
var
guid
=
_emberMetalUtils
.
guidFor
(
obj
)
;
var
presenceSet
=
this
.
presenceSet
;
return
presenceSet
[
guid
]
=
=
=
true
;
}
forEach
:
function
(
fn
)
{
if
(
typeof
fn
!
=
=
'
function
'
)
{
missingFunction
(
fn
)
;
}
if
(
this
.
size
=
=
=
0
)
{
return
;
}
var
list
=
this
.
list
;
var
length
=
arguments
.
length
;
var
i
;
if
(
length
=
=
=
2
)
{
for
(
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
fn
.
call
(
arguments
[
1
]
list
[
i
]
)
;
}
}
else
{
for
(
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
fn
(
list
[
i
]
)
;
}
}
}
toArray
:
function
(
)
{
return
this
.
list
.
slice
(
)
;
}
copy
:
function
(
)
{
var
Constructor
=
this
.
constructor
;
var
set
=
new
Constructor
(
)
;
set
.
_silenceRemoveDeprecation
=
this
.
_silenceRemoveDeprecation
;
set
.
presenceSet
=
copyNull
(
this
.
presenceSet
)
;
set
.
list
=
this
.
toArray
(
)
;
set
.
size
=
this
.
size
;
return
set
;
}
}
;
function
Map
(
)
{
if
(
this
instanceof
this
.
constructor
)
{
this
.
_keys
=
OrderedSet
.
create
(
)
;
this
.
_keys
.
_silenceRemoveDeprecation
=
true
;
this
.
_values
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
size
=
0
;
}
else
{
missingNew
(
'
OrderedSet
'
)
;
}
}
_emberMetalCore
.
default
.
Map
=
Map
;
Map
.
create
=
function
(
)
{
var
Constructor
=
this
;
return
new
Constructor
(
)
;
}
;
Map
.
prototype
=
{
constructor
:
Map
size
:
0
get
:
function
(
key
)
{
if
(
this
.
size
=
=
=
0
)
{
return
;
}
var
values
=
this
.
_values
;
var
guid
=
_emberMetalUtils
.
guidFor
(
key
)
;
return
values
[
guid
]
;
}
set
:
function
(
key
value
)
{
var
keys
=
this
.
_keys
;
var
values
=
this
.
_values
;
var
guid
=
_emberMetalUtils
.
guidFor
(
key
)
;
var
k
=
key
=
=
=
-
0
?
0
:
key
;
keys
.
add
(
k
guid
)
;
values
[
guid
]
=
value
;
this
.
size
=
keys
.
size
;
return
this
;
}
delete
:
function
(
key
)
{
if
(
this
.
size
=
=
=
0
)
{
return
false
;
}
var
keys
=
this
.
_keys
;
var
values
=
this
.
_values
;
var
guid
=
_emberMetalUtils
.
guidFor
(
key
)
;
if
(
keys
.
delete
(
key
guid
)
)
{
delete
values
[
guid
]
;
this
.
size
=
keys
.
size
;
return
true
;
}
else
{
return
false
;
}
}
has
:
function
(
key
)
{
return
this
.
_keys
.
has
(
key
)
;
}
forEach
:
function
(
callback
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
missingFunction
(
callback
)
;
}
if
(
this
.
size
=
=
=
0
)
{
return
;
}
var
length
=
arguments
.
length
;
var
map
=
this
;
var
cb
thisArg
;
if
(
length
=
=
=
2
)
{
thisArg
=
arguments
[
1
]
;
cb
=
function
(
key
)
{
callback
.
call
(
thisArg
map
.
get
(
key
)
key
map
)
;
}
;
}
else
{
cb
=
function
(
key
)
{
callback
(
map
.
get
(
key
)
key
map
)
;
}
;
}
this
.
_keys
.
forEach
(
cb
)
;
}
clear
:
function
(
)
{
this
.
_keys
.
clear
(
)
;
this
.
_values
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
size
=
0
;
}
copy
:
function
(
)
{
return
copyMap
(
this
new
Map
(
)
)
;
}
}
;
function
MapWithDefault
(
options
)
{
this
.
_super
constructor
(
)
;
this
.
defaultValue
=
options
.
defaultValue
;
}
MapWithDefault
.
create
=
function
(
options
)
{
if
(
options
)
{
return
new
MapWithDefault
(
options
)
;
}
else
{
return
new
Map
(
)
;
}
}
;
MapWithDefault
.
prototype
=
Object
.
create
(
Map
.
prototype
)
;
MapWithDefault
.
prototype
.
constructor
=
MapWithDefault
;
MapWithDefault
.
prototype
.
_super
constructor
=
Map
;
MapWithDefault
.
prototype
.
_super
get
=
Map
.
prototype
.
get
;
MapWithDefault
.
prototype
.
get
=
function
(
key
)
{
var
hasValue
=
this
.
has
(
key
)
;
if
(
hasValue
)
{
return
this
.
_super
get
(
key
)
;
}
else
{
var
defaultValue
=
this
.
defaultValue
(
key
)
;
this
.
set
(
key
defaultValue
)
;
return
defaultValue
;
}
}
;
MapWithDefault
.
prototype
.
copy
=
function
(
)
{
var
Constructor
=
this
.
constructor
;
return
copyMap
(
this
new
Constructor
(
{
defaultValue
:
this
.
defaultValue
}
)
)
;
}
;
exports
.
default
=
Map
;
exports
.
OrderedSet
=
OrderedSet
;
exports
.
Map
=
Map
;
exports
.
MapWithDefault
=
MapWithDefault
;
}
)
;
enifed
(
'
ember
-
metal
/
merge
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
merge
;
function
merge
(
original
updates
)
{
if
(
!
updates
|
|
typeof
updates
!
=
=
'
object
'
)
{
return
original
;
}
var
props
=
Object
.
keys
(
updates
)
;
var
prop
;
var
length
=
props
.
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
prop
=
props
[
i
]
;
original
[
prop
]
=
updates
[
prop
]
;
}
return
original
;
}
}
)
;
enifed
(
'
ember
-
metal
/
meta
'
[
'
exports
'
'
ember
-
metal
/
meta_listeners
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalMeta_listeners
_emberMetalEmpty_object
)
{
'
no
use
strict
'
;
exports
.
meta
=
meta
;
exports
.
peekMeta
=
peekMeta
;
exports
.
deleteMeta
=
deleteMeta
;
var
members
=
{
cache
:
ownMap
weak
:
ownMap
watching
:
inheritedMap
mixins
:
inheritedMap
bindings
:
inheritedMap
values
:
inheritedMap
deps
:
inheritedMapOfMaps
chainWatchers
:
ownCustomObject
chains
:
inheritedCustomObject
tag
:
ownCustomObject
}
;
var
memberNames
=
Object
.
keys
(
members
)
;
var
META_FIELD
=
'
__ember_meta__
'
;
function
Meta
(
obj
parentMeta
)
{
this
.
_cache
=
undefined
;
this
.
_weak
=
undefined
;
this
.
_watching
=
undefined
;
this
.
_mixins
=
undefined
;
this
.
_bindings
=
undefined
;
this
.
_values
=
undefined
;
this
.
_deps
=
undefined
;
this
.
_chainWatchers
=
undefined
;
this
.
_chains
=
undefined
;
this
.
_tag
=
undefined
;
this
.
source
=
obj
;
this
.
proto
=
undefined
;
this
.
parent
=
parentMeta
;
this
.
_initializeListeners
(
)
;
}
for
(
var
_name
in
_emberMetalMeta_listeners
.
protoMethods
)
{
Meta
.
prototype
[
_name
]
=
_emberMetalMeta_listeners
.
protoMethods
[
_name
]
;
}
memberNames
.
forEach
(
function
(
name
)
{
return
members
[
name
]
(
name
Meta
)
;
}
)
;
function
ownMap
(
name
Meta
)
{
var
key
=
memberProperty
(
name
)
;
var
capitalized
=
capitalize
(
name
)
;
Meta
.
prototype
[
'
writable
'
+
capitalized
]
=
function
(
)
{
return
this
.
_getOrCreateOwnMap
(
key
)
;
}
;
Meta
.
prototype
[
'
readable
'
+
capitalized
]
=
function
(
)
{
return
this
[
key
]
;
}
;
}
Meta
.
prototype
.
_getOrCreateOwnMap
=
function
(
key
)
{
var
ret
=
this
[
key
]
;
if
(
!
ret
)
{
ret
=
this
[
key
]
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
return
ret
;
}
;
function
inheritedMap
(
name
Meta
)
{
var
key
=
memberProperty
(
name
)
;
var
capitalized
=
capitalize
(
name
)
;
Meta
.
prototype
[
'
write
'
+
capitalized
]
=
function
(
subkey
value
)
{
var
map
=
this
.
_getOrCreateOwnMap
(
key
)
;
map
[
subkey
]
=
value
;
}
;
Meta
.
prototype
[
'
peek
'
+
capitalized
]
=
function
(
subkey
)
{
return
this
.
_findInherited
(
key
subkey
)
;
}
;
Meta
.
prototype
[
'
forEach
'
+
capitalized
]
=
function
(
fn
)
{
var
pointer
=
this
;
var
seen
=
new
_emberMetalEmpty_object
.
default
(
)
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
)
{
for
(
var
_key
in
map
)
{
if
(
!
seen
[
_key
]
)
{
seen
[
_key
]
=
true
;
fn
(
_key
map
[
_key
]
)
;
}
}
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
[
'
clear
'
+
capitalized
]
=
function
(
)
{
this
[
key
]
=
undefined
;
}
;
Meta
.
prototype
[
'
deleteFrom
'
+
capitalized
]
=
function
(
subkey
)
{
delete
this
.
_getOrCreateOwnMap
(
key
)
[
subkey
]
;
}
;
Meta
.
prototype
[
'
hasIn
'
+
capitalized
]
=
function
(
subkey
)
{
return
this
.
_findInherited
(
key
subkey
)
!
=
=
undefined
;
}
;
}
Meta
.
prototype
.
_getInherited
=
function
(
key
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
if
(
pointer
[
key
]
)
{
return
pointer
[
key
]
;
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
.
_findInherited
=
function
(
key
subkey
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
)
{
var
value
=
map
[
subkey
]
;
if
(
value
!
=
=
undefined
)
{
return
value
;
}
}
pointer
=
pointer
.
parent
;
}
}
;
function
inheritedMapOfMaps
(
name
Meta
)
{
var
key
=
memberProperty
(
name
)
;
var
capitalized
=
capitalize
(
name
)
;
Meta
.
prototype
[
'
write
'
+
capitalized
]
=
function
(
subkey
itemkey
value
)
{
var
outerMap
=
this
.
_getOrCreateOwnMap
(
key
)
;
var
innerMap
=
outerMap
[
subkey
]
;
if
(
!
innerMap
)
{
innerMap
=
outerMap
[
subkey
]
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
innerMap
[
itemkey
]
=
value
;
}
;
Meta
.
prototype
[
'
peek
'
+
capitalized
]
=
function
(
subkey
itemkey
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
)
{
var
value
=
map
[
subkey
]
;
if
(
value
)
{
if
(
value
[
itemkey
]
!
=
=
undefined
)
{
return
value
[
itemkey
]
;
}
}
}
pointer
=
pointer
.
parent
;
}
}
;
Meta
.
prototype
[
'
has
'
+
capitalized
]
=
function
(
subkey
)
{
var
pointer
=
this
;
while
(
pointer
!
=
=
undefined
)
{
if
(
pointer
[
key
]
&
&
pointer
[
key
]
[
subkey
]
)
{
return
true
;
}
pointer
=
pointer
.
parent
;
}
return
false
;
}
;
Meta
.
prototype
[
'
forEachIn
'
+
capitalized
]
=
function
(
subkey
fn
)
{
return
this
.
_forEachIn
(
key
subkey
fn
)
;
}
;
}
Meta
.
prototype
.
_forEachIn
=
function
(
key
subkey
fn
)
{
var
pointer
=
this
;
var
seen
=
new
_emberMetalEmpty_object
.
default
(
)
;
var
calls
=
[
]
;
while
(
pointer
!
=
=
undefined
)
{
var
map
=
pointer
[
key
]
;
if
(
map
)
{
var
innerMap
=
map
[
subkey
]
;
if
(
innerMap
)
{
for
(
var
innerKey
in
innerMap
)
{
if
(
!
seen
[
innerKey
]
)
{
seen
[
innerKey
]
=
true
;
calls
.
push
(
[
innerKey
innerMap
[
innerKey
]
]
)
;
}
}
}
}
pointer
=
pointer
.
parent
;
}
for
(
var
i
=
0
;
i
<
calls
.
length
;
i
+
+
)
{
var
_calls
i
=
calls
[
i
]
;
var
innerKey
=
_calls
i
[
0
]
;
var
value
=
_calls
i
[
1
]
;
fn
(
innerKey
value
)
;
}
}
;
function
ownCustomObject
(
name
Meta
)
{
var
key
=
memberProperty
(
name
)
;
var
capitalized
=
capitalize
(
name
)
;
Meta
.
prototype
[
'
writable
'
+
capitalized
]
=
function
(
create
)
{
var
ret
=
this
[
key
]
;
if
(
!
ret
)
{
ret
=
this
[
key
]
=
create
(
this
.
source
)
;
}
return
ret
;
}
;
Meta
.
prototype
[
'
readable
'
+
capitalized
]
=
function
(
)
{
return
this
[
key
]
;
}
;
}
function
inheritedCustomObject
(
name
Meta
)
{
var
key
=
memberProperty
(
name
)
;
var
capitalized
=
capitalize
(
name
)
;
Meta
.
prototype
[
'
writable
'
+
capitalized
]
=
function
(
create
)
{
var
ret
=
this
[
key
]
;
if
(
!
ret
)
{
if
(
this
.
parent
)
{
ret
=
this
[
key
]
=
this
.
parent
[
'
writable
'
+
capitalized
]
(
create
)
.
copy
(
this
.
source
)
;
}
else
{
ret
=
this
[
key
]
=
create
(
this
.
source
)
;
}
}
return
ret
;
}
;
Meta
.
prototype
[
'
readable
'
+
capitalized
]
=
function
(
)
{
return
this
.
_getInherited
(
key
)
;
}
;
}
function
memberProperty
(
name
)
{
return
'
_
'
+
name
;
}
function
capitalize
(
name
)
{
return
name
.
replace
(
/
^
\
w
/
function
(
m
)
{
return
m
.
toUpperCase
(
)
;
}
)
;
}
var
META_DESC
=
{
writable
:
true
configurable
:
true
enumerable
:
false
value
:
null
}
;
exports
.
META_DESC
=
META_DESC
;
var
EMBER_META_PROPERTY
=
{
name
:
META_FIELD
descriptor
:
META_DESC
}
;
var
setMeta
=
function
(
obj
meta
)
{
if
(
obj
[
META_FIELD
]
!
=
=
null
)
{
if
(
obj
.
__defineNonEnumerable
)
{
obj
.
__defineNonEnumerable
(
EMBER_META_PROPERTY
)
;
}
else
{
Object
.
defineProperty
(
obj
META_FIELD
META_DESC
)
;
}
}
obj
[
META_FIELD
]
=
meta
;
}
;
function
meta
(
obj
)
{
var
maybeMeta
=
peekMeta
(
obj
)
;
var
parent
=
undefined
;
if
(
maybeMeta
)
{
if
(
maybeMeta
.
source
=
=
=
obj
)
{
return
maybeMeta
;
}
parent
=
maybeMeta
;
}
var
newMeta
=
new
Meta
(
obj
parent
)
;
setMeta
(
obj
newMeta
)
;
return
newMeta
;
}
function
peekMeta
(
obj
)
{
return
obj
[
META_FIELD
]
;
}
function
deleteMeta
(
obj
)
{
if
(
typeof
obj
[
META_FIELD
]
!
=
=
'
object
'
)
{
return
;
}
obj
[
META_FIELD
]
=
null
;
}
}
)
;
enifed
(
'
ember
-
metal
/
meta_listeners
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
ONCE
=
1
;
exports
.
ONCE
=
ONCE
;
var
SUSPENDED
=
2
;
exports
.
SUSPENDED
=
SUSPENDED
;
var
protoMethods
=
{
addToListeners
:
function
(
eventName
target
method
flags
)
{
if
(
!
this
.
_listeners
)
{
this
.
_listeners
=
[
]
;
}
this
.
_listeners
.
push
(
eventName
target
method
flags
)
;
}
_finalizeListeners
:
function
(
)
{
if
(
this
.
_listenersFinalized
)
{
return
;
}
if
(
!
this
.
_listeners
)
{
this
.
_listeners
=
[
]
;
}
var
pointer
=
this
.
parent
;
while
(
pointer
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
)
{
this
.
_listeners
=
this
.
_listeners
.
concat
(
listeners
)
;
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
this
.
_listenersFinalized
=
true
;
}
removeFromListeners
:
function
(
eventName
target
method
didRemove
)
{
var
pointer
=
this
;
while
(
pointer
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
)
{
for
(
var
index
=
listeners
.
length
-
4
;
index
>
=
0
;
index
-
=
4
)
{
if
(
listeners
[
index
]
=
=
=
eventName
&
&
(
!
method
|
|
listeners
[
index
+
1
]
=
=
=
target
&
&
listeners
[
index
+
2
]
=
=
=
method
)
)
{
if
(
pointer
=
=
=
this
)
{
if
(
typeof
didRemove
=
=
=
'
function
'
)
{
didRemove
(
eventName
target
listeners
[
index
+
2
]
)
;
}
listeners
.
splice
(
index
4
)
;
}
else
{
this
.
_finalizeListeners
(
)
;
return
this
.
removeFromListeners
(
eventName
target
method
)
;
}
}
}
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
}
matchingListeners
:
function
(
eventName
)
{
var
pointer
=
this
;
var
result
=
[
]
;
while
(
pointer
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
)
{
for
(
var
index
=
0
;
index
<
listeners
.
length
-
3
;
index
+
=
4
)
{
if
(
listeners
[
index
]
=
=
=
eventName
)
{
pushUniqueListener
(
result
listeners
index
)
;
}
}
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
var
sus
=
this
.
_suspendedListeners
;
if
(
sus
)
{
for
(
var
susIndex
=
0
;
susIndex
<
sus
.
length
-
2
;
susIndex
+
=
3
)
{
if
(
eventName
=
=
=
sus
[
susIndex
]
)
{
for
(
var
resultIndex
=
0
;
resultIndex
<
result
.
length
-
2
;
resultIndex
+
=
3
)
{
if
(
result
[
resultIndex
]
=
=
=
sus
[
susIndex
+
1
]
&
&
result
[
resultIndex
+
1
]
=
=
=
sus
[
susIndex
+
2
]
)
{
result
[
resultIndex
+
2
]
|
=
SUSPENDED
;
}
}
}
}
}
return
result
;
}
suspendListeners
:
function
(
eventNames
target
method
callback
)
{
var
sus
=
this
.
_suspendedListeners
;
if
(
!
sus
)
{
sus
=
this
.
_suspendedListeners
=
[
]
;
}
for
(
var
i
=
0
;
i
<
eventNames
.
length
;
i
+
+
)
{
sus
.
push
(
eventNames
[
i
]
target
method
)
;
}
try
{
return
callback
.
call
(
target
)
;
}
finally
{
if
(
sus
.
length
=
=
=
eventNames
.
length
)
{
this
.
_suspendedListeners
=
undefined
;
}
else
{
for
(
var
i
=
sus
.
length
-
3
;
i
>
=
0
;
i
-
=
3
)
{
if
(
sus
[
i
+
1
]
=
=
=
target
&
&
sus
[
i
+
2
]
=
=
=
method
&
&
eventNames
.
indexOf
(
sus
[
i
]
)
!
=
=
-
1
)
{
sus
.
splice
(
i
3
)
;
}
}
}
}
}
watchedEvents
:
function
(
)
{
var
pointer
=
this
;
var
names
=
{
}
;
while
(
pointer
)
{
var
listeners
=
pointer
.
_listeners
;
if
(
listeners
)
{
for
(
var
index
=
0
;
index
<
listeners
.
length
-
3
;
index
+
=
4
)
{
names
[
listeners
[
index
]
]
=
true
;
}
}
if
(
pointer
.
_listenersFinalized
)
{
break
;
}
pointer
=
pointer
.
parent
;
}
return
Object
.
keys
(
names
)
;
}
_initializeListeners
:
function
(
)
{
this
.
_listeners
=
undefined
;
this
.
_listenersFinalized
=
undefined
;
this
.
_suspendedListeners
=
undefined
;
}
}
;
exports
.
protoMethods
=
protoMethods
;
function
pushUniqueListener
(
destination
source
index
)
{
var
target
=
source
[
index
+
1
]
;
var
method
=
source
[
index
+
2
]
;
for
(
var
destinationIndex
=
0
;
destinationIndex
<
destination
.
length
-
2
;
destinationIndex
+
=
3
)
{
if
(
destination
[
destinationIndex
]
=
=
=
target
&
&
destination
[
destinationIndex
+
1
]
=
=
=
method
)
{
return
;
}
}
destination
.
push
(
target
method
source
[
index
+
3
]
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
mixin
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
expand_properties
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
binding
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalCore
_emberMetalError
_emberMetalDebug
_emberMetalAssign
_emberMetalEmpty_object
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalUtils
_emberMetalMeta
_emberMetalExpand_properties
_emberMetalProperties
_emberMetalComputed
_emberMetalBinding
_emberMetalObserver
_emberMetalEvents
_emberMetalStreamsUtils
)
{
'
no
use
strict
'
;
exports
.
mixin
=
mixin
;
exports
.
default
=
Mixin
;
exports
.
required
=
required
;
exports
.
aliasMethod
=
aliasMethod
;
exports
.
observer
=
observer
;
exports
.
_immediateObserver
=
_immediateObserver
;
exports
.
_beforeObserver
=
_beforeObserver
;
function
ROOT
(
)
{
}
ROOT
.
__hasSuper
=
false
;
var
REQUIRED
;
var
a_slice
=
[
]
.
slice
;
function
isMethod
(
obj
)
{
return
'
function
'
=
=
=
typeof
obj
&
&
obj
.
isMethod
!
=
=
false
&
&
obj
!
=
=
Boolean
&
&
obj
!
=
=
Object
&
&
obj
!
=
=
Number
&
&
obj
!
=
=
Array
&
&
obj
!
=
=
Date
&
&
obj
!
=
=
String
;
}
var
CONTINUE
=
{
}
;
function
mixinProperties
(
mixinsMeta
mixin
)
{
var
guid
;
if
(
mixin
instanceof
Mixin
)
{
guid
=
_emberMetalUtils
.
guidFor
(
mixin
)
;
if
(
mixinsMeta
.
peekMixins
(
guid
)
)
{
return
CONTINUE
;
}
mixinsMeta
.
writeMixins
(
guid
mixin
)
;
return
mixin
.
properties
;
}
else
{
return
mixin
;
}
}
function
concatenatedMixinProperties
(
concatProp
props
values
base
)
{
var
concats
;
concats
=
values
[
concatProp
]
|
|
base
[
concatProp
]
;
if
(
props
[
concatProp
]
)
{
concats
=
concats
?
concats
.
concat
(
props
[
concatProp
]
)
:
props
[
concatProp
]
;
}
return
concats
;
}
function
giveDescriptorSuper
(
meta
key
property
values
descs
base
)
{
var
superProperty
;
if
(
values
[
key
]
=
=
=
undefined
)
{
superProperty
=
descs
[
key
]
;
}
if
(
!
superProperty
)
{
var
possibleDesc
=
base
[
key
]
;
var
superDesc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
superProperty
=
superDesc
;
}
if
(
superProperty
=
=
=
undefined
|
|
!
(
superProperty
instanceof
_emberMetalComputed
.
ComputedProperty
)
)
{
return
property
;
}
property
=
Object
.
create
(
property
)
;
property
.
_getter
=
_emberMetalUtils
.
wrap
(
property
.
_getter
superProperty
.
_getter
)
;
if
(
superProperty
.
_setter
)
{
if
(
property
.
_setter
)
{
property
.
_setter
=
_emberMetalUtils
.
wrap
(
property
.
_setter
superProperty
.
_setter
)
;
}
else
{
property
.
_setter
=
superProperty
.
_setter
;
}
}
return
property
;
}
function
giveMethodSuper
(
obj
key
method
values
descs
)
{
var
superMethod
;
if
(
descs
[
key
]
=
=
=
undefined
)
{
superMethod
=
values
[
key
]
;
}
superMethod
=
superMethod
|
|
obj
[
key
]
;
if
(
superMethod
=
=
=
undefined
|
|
'
function
'
!
=
=
typeof
superMethod
)
{
return
method
;
}
return
_emberMetalUtils
.
wrap
(
method
superMethod
)
;
}
function
applyConcatenatedProperties
(
obj
key
value
values
)
{
var
baseValue
=
values
[
key
]
|
|
obj
[
key
]
;
if
(
baseValue
)
{
if
(
'
function
'
=
=
=
typeof
baseValue
.
concat
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
baseValue
;
}
else
{
return
baseValue
.
concat
(
value
)
;
}
}
else
{
return
_emberMetalUtils
.
makeArray
(
baseValue
)
.
concat
(
value
)
;
}
}
else
{
return
_emberMetalUtils
.
makeArray
(
value
)
;
}
}
function
applyMergedProperties
(
obj
key
value
values
)
{
var
baseValue
=
values
[
key
]
|
|
obj
[
key
]
;
_emberMetalDebug
.
runInDebug
(
function
(
)
{
if
(
Array
.
isArray
(
value
)
)
{
_emberMetalDebug
.
assert
(
'
You
passed
in
'
+
JSON
.
stringify
(
value
)
+
'
as
the
value
for
'
+
key
+
'
but
'
+
key
+
'
cannot
be
an
Array
'
false
)
;
}
}
)
;
if
(
!
baseValue
)
{
return
value
;
}
var
newBase
=
_emberMetalAssign
.
default
(
{
}
baseValue
)
;
var
hasFunction
=
false
;
for
(
var
prop
in
value
)
{
if
(
!
value
.
hasOwnProperty
(
prop
)
)
{
continue
;
}
var
propValue
=
value
[
prop
]
;
if
(
isMethod
(
propValue
)
)
{
hasFunction
=
true
;
newBase
[
prop
]
=
giveMethodSuper
(
obj
prop
propValue
baseValue
{
}
)
;
}
else
{
newBase
[
prop
]
=
propValue
;
}
}
if
(
hasFunction
)
{
newBase
.
_super
=
ROOT
;
}
return
newBase
;
}
function
addNormalizedProperty
(
base
key
value
meta
descs
values
concats
mergings
)
{
if
(
value
instanceof
_emberMetalProperties
.
Descriptor
)
{
if
(
value
=
=
=
REQUIRED
&
&
descs
[
key
]
)
{
return
CONTINUE
;
}
if
(
value
.
_getter
)
{
value
=
giveDescriptorSuper
(
meta
key
value
values
descs
base
)
;
}
descs
[
key
]
=
value
;
values
[
key
]
=
undefined
;
}
else
{
if
(
concats
&
&
concats
.
indexOf
(
key
)
>
=
0
|
|
key
=
=
=
'
concatenatedProperties
'
|
|
key
=
=
=
'
mergedProperties
'
)
{
value
=
applyConcatenatedProperties
(
base
key
value
values
)
;
}
else
if
(
mergings
&
&
mergings
.
indexOf
(
key
)
>
=
0
)
{
value
=
applyMergedProperties
(
base
key
value
values
)
;
}
else
if
(
isMethod
(
value
)
)
{
value
=
giveMethodSuper
(
base
key
value
values
descs
)
;
}
descs
[
key
]
=
undefined
;
values
[
key
]
=
value
;
}
}
function
mergeMixins
(
mixins
m
descs
values
base
keys
)
{
var
currentMixin
props
key
concats
mergings
meta
;
function
removeKeys
(
keyName
)
{
delete
descs
[
keyName
]
;
delete
values
[
keyName
]
;
}
for
(
var
i
=
0
l
=
mixins
.
length
;
i
<
l
;
i
+
+
)
{
currentMixin
=
mixins
[
i
]
;
_emberMetalDebug
.
assert
(
'
Expected
hash
or
Mixin
instance
got
'
+
Object
.
prototype
.
toString
.
call
(
currentMixin
)
typeof
currentMixin
=
=
=
'
object
'
&
&
currentMixin
!
=
=
null
&
&
Object
.
prototype
.
toString
.
call
(
currentMixin
)
!
=
=
'
[
object
Array
]
'
)
;
props
=
mixinProperties
(
m
currentMixin
)
;
if
(
props
=
=
=
CONTINUE
)
{
continue
;
}
if
(
props
)
{
meta
=
_emberMetalMeta
.
meta
(
base
)
;
if
(
base
.
willMergeMixin
)
{
base
.
willMergeMixin
(
props
)
;
}
concats
=
concatenatedMixinProperties
(
'
concatenatedProperties
'
props
values
base
)
;
mergings
=
concatenatedMixinProperties
(
'
mergedProperties
'
props
values
base
)
;
for
(
key
in
props
)
{
if
(
!
props
.
hasOwnProperty
(
key
)
)
{
continue
;
}
keys
.
push
(
key
)
;
addNormalizedProperty
(
base
key
props
[
key
]
meta
descs
values
concats
mergings
)
;
}
if
(
props
.
hasOwnProperty
(
'
toString
'
)
)
{
base
.
toString
=
props
.
toString
;
}
}
else
if
(
currentMixin
.
mixins
)
{
mergeMixins
(
currentMixin
.
mixins
m
descs
values
base
keys
)
;
if
(
currentMixin
.
_without
)
{
currentMixin
.
_without
.
forEach
(
removeKeys
)
;
}
}
}
}
var
IS_BINDING
=
/
^
.
+
Binding
/
;
function
detectBinding
(
obj
key
value
m
)
{
if
(
IS_BINDING
.
test
(
key
)
)
{
m
.
writeBindings
(
key
value
)
;
}
}
function
connectStreamBinding
(
obj
key
stream
)
{
var
onNotify
=
function
(
stream
)
{
_emberMetalObserver
.
_suspendObserver
(
obj
key
null
didChange
function
(
)
{
_emberMetalProperty_set
.
trySet
(
obj
key
stream
.
value
(
)
)
;
}
)
;
}
;
var
didChange
=
function
(
)
{
stream
.
setValue
(
_emberMetalProperty_get
.
get
(
obj
key
)
onNotify
)
;
}
;
_emberMetalProperty_set
.
set
(
obj
key
stream
.
value
(
)
)
;
_emberMetalObserver
.
addObserver
(
obj
key
null
didChange
)
;
stream
.
subscribe
(
onNotify
)
;
if
(
obj
.
_streamBindingSubscriptions
=
=
=
undefined
)
{
obj
.
_streamBindingSubscriptions
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
obj
.
_streamBindingSubscriptions
[
key
]
=
onNotify
;
}
function
connectBindings
(
obj
m
)
{
m
.
forEachBindings
(
function
(
key
binding
)
{
if
(
binding
)
{
var
to
=
key
.
slice
(
0
-
7
)
;
if
(
_emberMetalStreamsUtils
.
isStream
(
binding
)
)
{
connectStreamBinding
(
obj
to
binding
)
;
return
;
}
else
if
(
binding
instanceof
_emberMetalBinding
.
Binding
)
{
binding
=
binding
.
copy
(
)
;
binding
.
to
(
to
)
;
}
else
{
binding
=
new
_emberMetalBinding
.
Binding
(
to
binding
)
;
}
binding
.
connect
(
obj
)
;
obj
[
key
]
=
binding
;
}
}
)
;
m
.
clearBindings
(
)
;
}
function
finishPartial
(
obj
m
)
{
connectBindings
(
obj
m
|
|
_emberMetalMeta
.
meta
(
obj
)
)
;
return
obj
;
}
function
followAlias
(
obj
desc
m
descs
values
)
{
var
altKey
=
desc
.
methodName
;
var
value
;
var
possibleDesc
;
if
(
descs
[
altKey
]
|
|
values
[
altKey
]
)
{
value
=
values
[
altKey
]
;
desc
=
descs
[
altKey
]
;
}
else
if
(
(
possibleDesc
=
obj
[
altKey
]
)
&
&
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
)
{
desc
=
possibleDesc
;
value
=
undefined
;
}
else
{
desc
=
undefined
;
value
=
obj
[
altKey
]
;
}
return
{
desc
:
desc
value
:
value
}
;
}
function
updateObserversAndListeners
(
obj
key
observerOrListener
pathsKey
updateMethod
)
{
var
paths
=
observerOrListener
[
pathsKey
]
;
if
(
paths
)
{
for
(
var
i
=
0
l
=
paths
.
length
;
i
<
l
;
i
+
+
)
{
updateMethod
(
obj
paths
[
i
]
null
key
)
;
}
}
}
function
replaceObserversAndListeners
(
obj
key
observerOrListener
)
{
var
prev
=
obj
[
key
]
;
if
(
'
function
'
=
=
=
typeof
prev
)
{
updateObserversAndListeners
(
obj
key
prev
'
__ember_observesBefore__
'
_emberMetalObserver
.
_removeBeforeObserver
)
;
updateObserversAndListeners
(
obj
key
prev
'
__ember_observes__
'
_emberMetalObserver
.
removeObserver
)
;
updateObserversAndListeners
(
obj
key
prev
'
__ember_listens__
'
_emberMetalEvents
.
removeListener
)
;
}
if
(
'
function
'
=
=
=
typeof
observerOrListener
)
{
updateObserversAndListeners
(
obj
key
observerOrListener
'
__ember_observesBefore__
'
_emberMetalObserver
.
_addBeforeObserver
)
;
updateObserversAndListeners
(
obj
key
observerOrListener
'
__ember_observes__
'
_emberMetalObserver
.
addObserver
)
;
updateObserversAndListeners
(
obj
key
observerOrListener
'
__ember_listens__
'
_emberMetalEvents
.
addListener
)
;
}
}
function
applyMixin
(
obj
mixins
partial
)
{
var
descs
=
{
}
;
var
values
=
{
}
;
var
m
=
_emberMetalMeta
.
meta
(
obj
)
;
var
keys
=
[
]
;
var
key
value
desc
;
obj
.
_super
=
ROOT
;
mergeMixins
(
mixins
m
descs
values
obj
keys
)
;
for
(
var
i
=
0
l
=
keys
.
length
;
i
<
l
;
i
+
+
)
{
key
=
keys
[
i
]
;
if
(
key
=
=
=
'
constructor
'
|
|
!
values
.
hasOwnProperty
(
key
)
)
{
continue
;
}
desc
=
descs
[
key
]
;
value
=
values
[
key
]
;
if
(
desc
=
=
=
REQUIRED
)
{
continue
;
}
while
(
desc
&
&
desc
instanceof
Alias
)
{
var
followed
=
followAlias
(
obj
desc
m
descs
values
)
;
desc
=
followed
.
desc
;
value
=
followed
.
value
;
}
if
(
desc
=
=
=
undefined
&
&
value
=
=
=
undefined
)
{
continue
;
}
replaceObserversAndListeners
(
obj
key
value
)
;
detectBinding
(
obj
key
value
m
)
;
_emberMetalProperties
.
defineProperty
(
obj
key
desc
value
m
)
;
}
if
(
!
partial
)
{
finishPartial
(
obj
m
)
;
}
return
obj
;
}
function
mixin
(
obj
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
applyMixin
(
obj
args
false
)
;
return
obj
;
}
function
Mixin
(
args
properties
)
{
this
.
properties
=
properties
;
var
length
=
args
&
&
args
.
length
;
if
(
length
>
0
)
{
var
m
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
var
x
=
args
[
i
]
;
if
(
x
instanceof
Mixin
)
{
m
[
i
]
=
x
;
}
else
{
m
[
i
]
=
new
Mixin
(
undefined
x
)
;
}
}
this
.
mixins
=
m
;
}
else
{
this
.
mixins
=
undefined
;
}
this
.
ownerConstructor
=
undefined
;
this
.
_without
=
undefined
;
this
[
_emberMetalUtils
.
GUID_KEY
]
=
null
;
this
[
_emberMetalUtils
.
GUID_KEY
+
'
_name
'
]
=
null
;
_emberMetalDebug
.
debugSeal
(
this
)
;
}
Mixin
.
_apply
=
applyMixin
;
Mixin
.
applyPartial
=
function
(
obj
)
{
var
args
=
a_slice
.
call
(
arguments
1
)
;
return
applyMixin
(
obj
args
true
)
;
}
;
Mixin
.
finishPartial
=
finishPartial
;
_emberMetalCore
.
default
.
anyUnprocessedMixins
=
false
;
Mixin
.
create
=
function
(
)
{
_emberMetalCore
.
default
.
anyUnprocessedMixins
=
true
;
var
M
=
this
;
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
new
M
(
args
undefined
)
;
}
;
var
MixinPrototype
=
Mixin
.
prototype
;
MixinPrototype
.
reopen
=
function
(
)
{
var
currentMixin
;
if
(
this
.
properties
)
{
currentMixin
=
new
Mixin
(
undefined
this
.
properties
)
;
this
.
properties
=
undefined
;
this
.
mixins
=
[
currentMixin
]
;
}
else
if
(
!
this
.
mixins
)
{
this
.
mixins
=
[
]
;
}
var
len
=
arguments
.
length
;
var
mixins
=
this
.
mixins
;
var
idx
;
for
(
idx
=
0
;
idx
<
len
;
idx
+
+
)
{
currentMixin
=
arguments
[
idx
]
;
_emberMetalDebug
.
assert
(
'
Expected
hash
or
Mixin
instance
got
'
+
Object
.
prototype
.
toString
.
call
(
currentMixin
)
typeof
currentMixin
=
=
=
'
object
'
&
&
currentMixin
!
=
=
null
&
&
Object
.
prototype
.
toString
.
call
(
currentMixin
)
!
=
=
'
[
object
Array
]
'
)
;
if
(
currentMixin
instanceof
Mixin
)
{
mixins
.
push
(
currentMixin
)
;
}
else
{
mixins
.
push
(
new
Mixin
(
undefined
currentMixin
)
)
;
}
}
return
this
;
}
;
MixinPrototype
.
apply
=
function
(
obj
)
{
return
applyMixin
(
obj
[
this
]
false
)
;
}
;
MixinPrototype
.
applyPartial
=
function
(
obj
)
{
return
applyMixin
(
obj
[
this
]
true
)
;
}
;
MixinPrototype
.
toString
=
function
Mixin_toString
(
)
{
return
'
(
unknown
mixin
)
'
;
}
;
function
_detect
(
curMixin
targetMixin
seen
)
{
var
guid
=
_emberMetalUtils
.
guidFor
(
curMixin
)
;
if
(
seen
[
guid
]
)
{
return
false
;
}
seen
[
guid
]
=
true
;
if
(
curMixin
=
=
=
targetMixin
)
{
return
true
;
}
var
mixins
=
curMixin
.
mixins
;
var
loc
=
mixins
?
mixins
.
length
:
0
;
while
(
-
-
loc
>
=
0
)
{
if
(
_detect
(
mixins
[
loc
]
targetMixin
seen
)
)
{
return
true
;
}
}
return
false
;
}
MixinPrototype
.
detect
=
function
(
obj
)
{
if
(
!
obj
)
{
return
false
;
}
if
(
obj
instanceof
Mixin
)
{
return
_detect
(
obj
this
{
}
)
;
}
var
m
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
!
m
)
{
return
false
;
}
return
!
!
m
.
peekMixins
(
_emberMetalUtils
.
guidFor
(
this
)
)
;
}
;
MixinPrototype
.
without
=
function
(
)
{
var
ret
=
new
Mixin
(
[
this
]
)
;
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
ret
.
_without
=
args
;
return
ret
;
}
;
function
_keys
(
ret
mixin
seen
)
{
if
(
seen
[
_emberMetalUtils
.
guidFor
(
mixin
)
]
)
{
return
;
}
seen
[
_emberMetalUtils
.
guidFor
(
mixin
)
]
=
true
;
if
(
mixin
.
properties
)
{
var
props
=
Object
.
keys
(
mixin
.
properties
)
;
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
key
=
props
[
i
]
;
ret
[
key
]
=
true
;
}
}
else
if
(
mixin
.
mixins
)
{
mixin
.
mixins
.
forEach
(
function
(
x
)
{
return
_keys
(
ret
x
seen
)
;
}
)
;
}
}
MixinPrototype
.
keys
=
function
(
)
{
var
keys
=
{
}
;
var
seen
=
{
}
;
_keys
(
keys
this
seen
)
;
var
ret
=
Object
.
keys
(
keys
)
;
return
ret
;
}
;
_emberMetalDebug
.
debugSeal
(
MixinPrototype
)
;
Mixin
.
mixins
=
function
(
obj
)
{
var
m
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
var
ret
=
[
]
;
if
(
!
m
)
{
return
ret
;
}
m
.
forEachMixins
(
function
(
key
currentMixin
)
{
if
(
!
currentMixin
.
properties
)
{
ret
.
push
(
currentMixin
)
;
}
}
)
;
return
ret
;
}
;
exports
.
REQUIRED
=
REQUIRED
=
new
_emberMetalProperties
.
Descriptor
(
)
;
REQUIRED
.
toString
=
function
(
)
{
return
'
(
Required
Property
)
'
;
}
;
function
required
(
)
{
_emberMetalDebug
.
deprecate
(
'
Ember
.
required
is
deprecated
as
its
behavior
is
inconsistent
and
unreliable
.
'
false
{
id
:
'
ember
-
metal
.
required
'
until
:
'
3
.
0
.
0
'
}
)
;
return
REQUIRED
;
}
function
Alias
(
methodName
)
{
this
.
isDescriptor
=
true
;
this
.
methodName
=
methodName
;
}
Alias
.
prototype
=
new
_emberMetalProperties
.
Descriptor
(
)
;
function
aliasMethod
(
methodName
)
{
return
new
Alias
(
methodName
)
;
}
function
observer
(
)
{
for
(
var
_len4
=
arguments
.
length
args
=
Array
(
_len4
)
_key4
=
0
;
_key4
<
_len4
;
_key4
+
+
)
{
args
[
_key4
]
=
arguments
[
_key4
]
;
}
var
func
=
args
.
slice
(
-
1
)
[
0
]
;
var
paths
;
var
addWatchedProperty
=
function
(
path
)
{
paths
.
push
(
path
)
;
}
;
var
_paths
=
args
.
slice
(
0
-
1
)
;
if
(
typeof
func
!
=
=
'
function
'
)
{
_emberMetalDebug
.
deprecate
(
'
Passing
the
dependentKeys
after
the
callback
function
in
Ember
.
observer
is
deprecated
.
Ensure
the
callback
function
is
the
last
argument
.
'
false
{
id
:
'
ember
-
metal
.
observer
-
argument
-
order
'
until
:
'
3
.
0
.
0
'
}
)
;
func
=
args
[
0
]
;
_paths
=
args
.
slice
(
1
)
;
}
paths
=
[
]
;
for
(
var
i
=
0
;
i
<
_paths
.
length
;
+
+
i
)
{
_emberMetalExpand_properties
.
default
(
_paths
[
i
]
addWatchedProperty
)
;
}
if
(
typeof
func
!
=
=
'
function
'
)
{
throw
new
_emberMetalError
.
default
(
'
Ember
.
observer
called
without
a
function
'
)
;
}
func
.
__ember_observes__
=
paths
;
return
func
;
}
function
_immediateObserver
(
)
{
_emberMetalDebug
.
deprecate
(
'
Usage
of
Ember
.
immediateObserver
is
deprecated
use
Ember
.
observer
instead
.
'
false
{
id
:
'
ember
-
metal
.
immediate
-
observer
'
until
:
'
3
.
0
.
0
'
}
)
;
for
(
var
i
=
0
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
_emberMetalDebug
.
assert
(
'
Immediate
observers
must
observe
internal
properties
only
not
properties
on
other
objects
.
'
typeof
arg
!
=
=
'
string
'
|
|
arg
.
indexOf
(
'
.
'
)
=
=
=
-
1
)
;
}
return
observer
.
apply
(
this
arguments
)
;
}
function
_beforeObserver
(
)
{
for
(
var
_len5
=
arguments
.
length
args
=
Array
(
_len5
)
_key5
=
0
;
_key5
<
_len5
;
_key5
+
+
)
{
args
[
_key5
]
=
arguments
[
_key5
]
;
}
var
func
=
args
.
slice
(
-
1
)
[
0
]
;
var
paths
;
var
addWatchedProperty
=
function
(
path
)
{
paths
.
push
(
path
)
;
}
;
var
_paths
=
args
.
slice
(
0
-
1
)
;
if
(
typeof
func
!
=
=
'
function
'
)
{
func
=
args
[
0
]
;
_paths
=
args
.
slice
(
1
)
;
}
paths
=
[
]
;
for
(
var
i
=
0
;
i
<
_paths
.
length
;
+
+
i
)
{
_emberMetalExpand_properties
.
default
(
_paths
[
i
]
addWatchedProperty
)
;
}
if
(
typeof
func
!
=
=
'
function
'
)
{
throw
new
_emberMetalCore
.
default
.
Error
(
'
Ember
.
beforeObserver
called
without
a
function
'
)
;
}
func
.
__ember_observesBefore__
=
paths
;
return
func
;
}
exports
.
IS_BINDING
=
IS_BINDING
;
exports
.
Mixin
=
Mixin
;
exports
.
required
=
required
;
exports
.
REQUIRED
=
REQUIRED
;
}
)
;
enifed
(
'
ember
-
metal
/
observer
'
[
'
exports
'
'
ember
-
metal
/
watching
'
'
ember
-
metal
/
events
'
]
function
(
exports
_emberMetalWatching
_emberMetalEvents
)
{
'
use
strict
'
;
exports
.
addObserver
=
addObserver
;
exports
.
observersFor
=
observersFor
;
exports
.
removeObserver
=
removeObserver
;
exports
.
_addBeforeObserver
=
_addBeforeObserver
;
exports
.
_suspendObserver
=
_suspendObserver
;
exports
.
_suspendObservers
=
_suspendObservers
;
exports
.
_removeBeforeObserver
=
_removeBeforeObserver
;
var
AFTER_OBSERVERS
=
'
:
change
'
;
var
BEFORE_OBSERVERS
=
'
:
before
'
;
function
changeEvent
(
keyName
)
{
return
keyName
+
AFTER_OBSERVERS
;
}
function
beforeEvent
(
keyName
)
{
return
keyName
+
BEFORE_OBSERVERS
;
}
function
addObserver
(
obj
_path
target
method
)
{
_emberMetalEvents
.
addListener
(
obj
changeEvent
(
_path
)
target
method
)
;
_emberMetalWatching
.
watch
(
obj
_path
)
;
return
this
;
}
function
observersFor
(
obj
path
)
{
return
_emberMetalEvents
.
listenersFor
(
obj
changeEvent
(
path
)
)
;
}
function
removeObserver
(
obj
path
target
method
)
{
_emberMetalWatching
.
unwatch
(
obj
path
)
;
_emberMetalEvents
.
removeListener
(
obj
changeEvent
(
path
)
target
method
)
;
return
this
;
}
function
_addBeforeObserver
(
obj
path
target
method
)
{
_emberMetalEvents
.
addListener
(
obj
beforeEvent
(
path
)
target
method
)
;
_emberMetalWatching
.
watch
(
obj
path
)
;
return
this
;
}
function
_suspendObserver
(
obj
path
target
method
callback
)
{
return
_emberMetalEvents
.
suspendListener
(
obj
changeEvent
(
path
)
target
method
callback
)
;
}
function
_suspendObservers
(
obj
paths
target
method
callback
)
{
var
events
=
paths
.
map
(
changeEvent
)
;
return
_emberMetalEvents
.
suspendListeners
(
obj
events
target
method
callback
)
;
}
function
_removeBeforeObserver
(
obj
path
target
method
)
{
_emberMetalWatching
.
unwatch
(
obj
path
)
;
_emberMetalEvents
.
removeListener
(
obj
beforeEvent
(
path
)
target
method
)
;
return
this
;
}
}
)
;
enifed
(
'
ember
-
metal
/
observer_set
'
[
'
exports
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
events
'
]
function
(
exports
_emberMetalUtils
_emberMetalEvents
)
{
'
use
strict
'
;
exports
.
default
=
ObserverSet
;
function
ObserverSet
(
)
{
this
.
clear
(
)
;
}
ObserverSet
.
prototype
.
add
=
function
(
sender
keyName
eventName
)
{
var
observerSet
=
this
.
observerSet
;
var
observers
=
this
.
observers
;
var
senderGuid
=
_emberMetalUtils
.
guidFor
(
sender
)
;
var
keySet
=
observerSet
[
senderGuid
]
;
var
index
;
if
(
!
keySet
)
{
observerSet
[
senderGuid
]
=
keySet
=
{
}
;
}
index
=
keySet
[
keyName
]
;
if
(
index
=
=
=
undefined
)
{
index
=
observers
.
push
(
{
sender
:
sender
keyName
:
keyName
eventName
:
eventName
listeners
:
[
]
}
)
-
1
;
keySet
[
keyName
]
=
index
;
}
return
observers
[
index
]
.
listeners
;
}
;
ObserverSet
.
prototype
.
flush
=
function
(
)
{
var
observers
=
this
.
observers
;
var
i
len
observer
sender
;
this
.
clear
(
)
;
for
(
i
=
0
len
=
observers
.
length
;
i
<
len
;
+
+
i
)
{
observer
=
observers
[
i
]
;
sender
=
observer
.
sender
;
if
(
sender
.
isDestroying
|
|
sender
.
isDestroyed
)
{
continue
;
}
_emberMetalEvents
.
sendEvent
(
sender
observer
.
eventName
[
sender
observer
.
keyName
]
observer
.
listeners
)
;
}
}
;
ObserverSet
.
prototype
.
clear
=
function
(
)
{
this
.
observerSet
=
{
}
;
this
.
observers
=
[
]
;
}
;
}
)
;
enifed
(
'
ember
-
metal
/
path_cache
'
[
'
exports
'
'
ember
-
metal
/
cache
'
]
function
(
exports
_emberMetalCache
)
{
'
use
strict
'
;
exports
.
isGlobal
=
isGlobal
;
exports
.
isGlobalPath
=
isGlobalPath
;
exports
.
hasThis
=
hasThis
;
exports
.
isPath
=
isPath
;
exports
.
getFirstKey
=
getFirstKey
;
exports
.
getTailPath
=
getTailPath
;
var
IS_GLOBAL
=
/
^
[
A
-
Z
]
/
;
var
IS_GLOBAL_PATH
=
/
^
[
A
-
Z
]
.
*
[
\
.
]
/
;
var
HAS_THIS
=
'
this
.
'
;
var
isGlobalCache
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
IS_GLOBAL
.
test
(
key
)
;
}
)
;
var
isGlobalPathCache
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
IS_GLOBAL_PATH
.
test
(
key
)
;
}
)
;
var
hasThisCache
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
key
.
lastIndexOf
(
HAS_THIS
0
)
=
=
=
0
;
}
)
;
var
firstDotIndexCache
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
key
.
indexOf
(
'
.
'
)
;
}
)
;
var
firstKeyCache
=
new
_emberMetalCache
.
default
(
1000
function
(
path
)
{
var
index
=
firstDotIndexCache
.
get
(
path
)
;
if
(
index
=
=
=
-
1
)
{
return
path
;
}
else
{
return
path
.
slice
(
0
index
)
;
}
}
)
;
var
tailPathCache
=
new
_emberMetalCache
.
default
(
1000
function
(
path
)
{
var
index
=
firstDotIndexCache
.
get
(
path
)
;
if
(
index
!
=
=
-
1
)
{
return
path
.
slice
(
index
+
1
)
;
}
}
)
;
var
caches
=
{
isGlobalCache
:
isGlobalCache
isGlobalPathCache
:
isGlobalPathCache
hasThisCache
:
hasThisCache
firstDotIndexCache
:
firstDotIndexCache
firstKeyCache
:
firstKeyCache
tailPathCache
:
tailPathCache
}
;
exports
.
caches
=
caches
;
function
isGlobal
(
path
)
{
return
isGlobalCache
.
get
(
path
)
;
}
function
isGlobalPath
(
path
)
{
return
isGlobalPathCache
.
get
(
path
)
;
}
function
hasThis
(
path
)
{
return
hasThisCache
.
get
(
path
)
;
}
function
isPath
(
path
)
{
return
firstDotIndexCache
.
get
(
path
)
!
=
=
-
1
;
}
function
getFirstKey
(
path
)
{
return
firstKeyCache
.
get
(
path
)
;
}
function
getTailPath
(
path
)
{
return
tailPathCache
.
get
(
path
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
properties
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
property_events
'
]
function
(
exports
_emberMetalDebug
_emberMetalFeatures
_emberMetalMeta
_emberMetalProperty_events
)
{
'
use
strict
'
;
exports
.
Descriptor
=
Descriptor
;
exports
.
MANDATORY_SETTER_FUNCTION
=
MANDATORY_SETTER_FUNCTION
;
exports
.
DEFAULT_GETTER_FUNCTION
=
DEFAULT_GETTER_FUNCTION
;
exports
.
INHERITING_GETTER_FUNCTION
=
INHERITING_GETTER_FUNCTION
;
exports
.
defineProperty
=
defineProperty
;
function
Descriptor
(
)
{
this
.
isDescriptor
=
true
;
}
var
REDEFINE_SUPPORTED
=
(
function
(
)
{
var
a
=
Object
.
create
(
Object
.
prototype
{
prop
:
{
configurable
:
true
value
:
1
}
}
)
;
Object
.
defineProperty
(
a
'
prop
'
{
configurable
:
true
value
:
2
}
)
;
return
a
.
prop
=
=
=
2
;
}
)
(
)
;
function
MANDATORY_SETTER_FUNCTION
(
name
)
{
function
SETTER_FUNCTION
(
value
)
{
_emberMetalDebug
.
assert
(
'
You
must
use
Ember
.
set
(
)
to
set
the
'
+
name
+
'
property
(
of
'
+
this
+
'
)
to
'
+
value
+
'
.
'
false
)
;
}
SETTER_FUNCTION
.
isMandatorySetter
=
true
;
return
SETTER_FUNCTION
;
}
function
DEFAULT_GETTER_FUNCTION
(
name
)
{
return
function
GETTER_FUNCTION
(
)
{
var
meta
=
this
[
'
__ember_meta__
'
]
;
return
meta
&
&
meta
.
peekValues
(
name
)
;
}
;
}
function
INHERITING_GETTER_FUNCTION
(
name
)
{
function
IGETTER_FUNCTION
(
)
{
var
proto
=
Object
.
getPrototypeOf
(
this
)
;
return
proto
&
&
proto
[
name
]
;
}
IGETTER_FUNCTION
.
isInheritingGetter
=
true
;
return
IGETTER_FUNCTION
;
}
function
defineProperty
(
obj
keyName
desc
data
meta
)
{
var
possibleDesc
existingDesc
watching
value
;
if
(
!
meta
)
{
meta
=
_emberMetalMeta
.
meta
(
obj
)
;
}
var
watchEntry
=
meta
.
peekWatching
(
keyName
)
;
possibleDesc
=
obj
[
keyName
]
;
existingDesc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
watching
=
watchEntry
!
=
=
undefined
&
&
watchEntry
>
0
;
if
(
existingDesc
)
{
existingDesc
.
teardown
(
obj
keyName
)
;
}
if
(
desc
instanceof
Descriptor
)
{
value
=
desc
;
if
(
watching
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
true
writable
:
true
value
:
value
}
)
;
}
else
{
obj
[
keyName
]
=
value
;
}
if
(
desc
.
setup
)
{
desc
.
setup
(
obj
keyName
)
;
}
}
else
{
if
(
desc
=
=
null
)
{
value
=
data
;
if
(
watching
)
{
meta
.
writeValues
(
keyName
data
)
;
var
defaultDescriptor
=
{
configurable
:
true
enumerable
:
true
set
:
MANDATORY_SETTER_FUNCTION
(
keyName
)
get
:
DEFAULT_GETTER_FUNCTION
(
keyName
)
}
;
if
(
REDEFINE_SUPPORTED
)
{
Object
.
defineProperty
(
obj
keyName
defaultDescriptor
)
;
}
else
{
handleBrokenPhantomDefineProperty
(
obj
keyName
defaultDescriptor
)
;
}
}
else
{
obj
[
keyName
]
=
data
;
}
}
else
{
value
=
desc
;
Object
.
defineProperty
(
obj
keyName
desc
)
;
}
}
if
(
watching
)
{
_emberMetalProperty_events
.
overrideChains
(
obj
keyName
meta
)
;
}
if
(
obj
.
didDefineProperty
)
{
obj
.
didDefineProperty
(
obj
keyName
value
)
;
}
return
this
;
}
function
handleBrokenPhantomDefineProperty
(
obj
keyName
desc
)
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
writable
:
true
value
:
'
iCry
'
}
)
;
Object
.
defineProperty
(
obj
keyName
desc
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
property_events
'
[
'
exports
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
observer_set
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberMetalUtils
_emberMetalMeta
_emberMetalEvents
_emberMetalObserver_set
_emberMetalSymbol
)
{
'
use
strict
'
;
var
PROPERTY_DID_CHANGE
=
_emberMetalSymbol
.
default
(
'
PROPERTY_DID_CHANGE
'
)
;
exports
.
PROPERTY_DID_CHANGE
=
PROPERTY_DID_CHANGE
;
var
beforeObserverSet
=
new
_emberMetalObserver_set
.
default
(
)
;
var
observerSet
=
new
_emberMetalObserver_set
.
default
(
)
;
var
deferred
=
0
;
function
propertyWillChange
(
obj
keyName
)
{
var
m
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
var
watching
=
m
&
&
m
.
peekWatching
(
keyName
)
>
0
|
|
keyName
=
=
=
'
length
'
;
var
proto
=
m
&
&
m
.
proto
;
var
possibleDesc
=
obj
[
keyName
]
;
var
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
if
(
!
watching
)
{
return
;
}
if
(
proto
=
=
=
obj
)
{
return
;
}
if
(
desc
&
&
desc
.
willChange
)
{
desc
.
willChange
(
obj
keyName
)
;
}
dependentKeysWillChange
(
obj
keyName
m
)
;
chainsWillChange
(
obj
keyName
m
)
;
notifyBeforeObservers
(
obj
keyName
)
;
}
function
propertyDidChange
(
obj
keyName
)
{
var
m
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
var
watching
=
m
&
&
m
.
peekWatching
(
keyName
)
>
0
|
|
keyName
=
=
=
'
length
'
;
var
proto
=
m
&
&
m
.
proto
;
var
possibleDesc
=
obj
[
keyName
]
;
var
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
if
(
proto
=
=
=
obj
)
{
return
;
}
if
(
desc
&
&
desc
.
didChange
)
{
desc
.
didChange
(
obj
keyName
)
;
}
if
(
obj
[
PROPERTY_DID_CHANGE
]
)
{
obj
[
PROPERTY_DID_CHANGE
]
(
keyName
)
;
}
if
(
!
watching
&
&
keyName
!
=
=
'
length
'
)
{
return
;
}
if
(
m
&
&
m
.
hasDeps
(
keyName
)
)
{
dependentKeysDidChange
(
obj
keyName
m
)
;
}
chainsDidChange
(
obj
keyName
m
false
)
;
notifyObservers
(
obj
keyName
)
;
}
var
WILL_SEEN
DID_SEEN
;
function
dependentKeysWillChange
(
obj
depKey
meta
)
{
if
(
obj
.
isDestroying
)
{
return
;
}
if
(
meta
&
&
meta
.
hasDeps
(
depKey
)
)
{
var
seen
=
WILL_SEEN
;
var
top
=
!
seen
;
if
(
top
)
{
seen
=
WILL_SEEN
=
{
}
;
}
iterDeps
(
propertyWillChange
obj
depKey
seen
meta
)
;
if
(
top
)
{
WILL_SEEN
=
null
;
}
}
}
function
dependentKeysDidChange
(
obj
depKey
meta
)
{
if
(
obj
.
isDestroying
)
{
return
;
}
if
(
meta
&
&
meta
.
hasDeps
(
depKey
)
)
{
var
seen
=
DID_SEEN
;
var
top
=
!
seen
;
if
(
top
)
{
seen
=
DID_SEEN
=
{
}
;
}
iterDeps
(
propertyDidChange
obj
depKey
seen
meta
)
;
if
(
top
)
{
DID_SEEN
=
null
;
}
}
}
function
iterDeps
(
method
obj
depKey
seen
meta
)
{
var
possibleDesc
desc
;
var
guid
=
_emberMetalUtils
.
guidFor
(
obj
)
;
var
current
=
seen
[
guid
]
;
if
(
!
current
)
{
current
=
seen
[
guid
]
=
{
}
;
}
if
(
current
[
depKey
]
)
{
return
;
}
current
[
depKey
]
=
true
;
meta
.
forEachInDeps
(
depKey
function
(
key
value
)
{
if
(
!
value
)
{
return
;
}
possibleDesc
=
obj
[
key
]
;
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
if
(
desc
&
&
desc
.
_suspended
=
=
=
obj
)
{
return
;
}
method
(
obj
key
)
;
}
)
;
}
function
chainsWillChange
(
obj
keyName
m
)
{
var
c
=
m
.
readableChainWatchers
(
)
;
if
(
c
)
{
c
.
notify
(
keyName
false
propertyWillChange
)
;
}
}
function
chainsDidChange
(
obj
keyName
m
)
{
var
c
=
m
.
readableChainWatchers
(
)
;
if
(
c
)
{
c
.
notify
(
keyName
true
propertyDidChange
)
;
}
}
function
overrideChains
(
obj
keyName
m
)
{
var
c
=
m
.
readableChainWatchers
(
)
;
if
(
c
)
{
c
.
revalidate
(
keyName
)
;
}
}
function
beginPropertyChanges
(
)
{
deferred
+
+
;
}
function
endPropertyChanges
(
)
{
deferred
-
-
;
if
(
deferred
<
=
0
)
{
beforeObserverSet
.
clear
(
)
;
observerSet
.
flush
(
)
;
}
}
function
changeProperties
(
callback
binding
)
{
beginPropertyChanges
(
)
;
try
{
callback
.
call
(
binding
)
;
}
finally
{
endPropertyChanges
.
call
(
binding
)
;
}
}
function
notifyBeforeObservers
(
obj
keyName
)
{
if
(
obj
.
isDestroying
)
{
return
;
}
var
eventName
=
keyName
+
'
:
before
'
;
var
listeners
added
;
if
(
deferred
)
{
listeners
=
beforeObserverSet
.
add
(
obj
keyName
eventName
)
;
added
=
_emberMetalEvents
.
accumulateListeners
(
obj
eventName
listeners
)
;
_emberMetalEvents
.
sendEvent
(
obj
eventName
[
obj
keyName
]
added
)
;
}
else
{
_emberMetalEvents
.
sendEvent
(
obj
eventName
[
obj
keyName
]
)
;
}
}
function
notifyObservers
(
obj
keyName
)
{
if
(
obj
.
isDestroying
)
{
return
;
}
var
eventName
=
keyName
+
'
:
change
'
;
var
listeners
;
if
(
deferred
)
{
listeners
=
observerSet
.
add
(
obj
keyName
eventName
)
;
_emberMetalEvents
.
accumulateListeners
(
obj
eventName
listeners
)
;
}
else
{
_emberMetalEvents
.
sendEvent
(
obj
eventName
[
obj
keyName
]
)
;
}
}
exports
.
propertyWillChange
=
propertyWillChange
;
exports
.
propertyDidChange
=
propertyDidChange
;
exports
.
overrideChains
=
overrideChains
;
exports
.
beginPropertyChanges
=
beginPropertyChanges
;
exports
.
endPropertyChanges
=
endPropertyChanges
;
exports
.
changeProperties
=
changeProperties
;
}
)
;
enifed
(
'
ember
-
metal
/
property_get
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
path_cache
'
]
function
(
exports
_emberMetalDebug
_emberMetalPath_cache
)
{
'
use
strict
'
;
exports
.
get
=
get
;
exports
.
_getPath
=
_getPath
;
exports
.
getWithDefault
=
getWithDefault
;
var
ALLOWABLE_TYPES
=
{
object
:
true
function
:
true
string
:
true
}
;
function
get
(
obj
keyName
)
{
_emberMetalDebug
.
assert
(
'
Get
must
be
called
with
two
arguments
;
an
object
and
a
property
key
'
arguments
.
length
=
=
=
2
)
;
_emberMetalDebug
.
assert
(
'
Cannot
call
get
with
\
'
'
+
keyName
+
'
\
'
on
an
undefined
object
.
'
obj
!
=
=
undefined
&
&
obj
!
=
=
null
)
;
_emberMetalDebug
.
assert
(
'
The
key
provided
to
get
must
be
a
string
you
passed
'
+
keyName
typeof
keyName
=
=
=
'
string
'
)
;
_emberMetalDebug
.
assert
(
'
\
'
this
\
'
in
paths
is
not
supported
'
!
_emberMetalPath_cache
.
hasThis
(
keyName
)
)
;
if
(
keyName
=
=
=
'
'
)
{
return
obj
;
}
var
value
=
obj
[
keyName
]
;
var
desc
=
value
!
=
=
null
&
&
typeof
value
=
=
=
'
object
'
&
&
value
.
isDescriptor
?
value
:
undefined
;
var
ret
;
if
(
desc
=
=
=
undefined
&
&
_emberMetalPath_cache
.
isPath
(
keyName
)
)
{
return
_getPath
(
obj
keyName
)
;
}
if
(
desc
)
{
return
desc
.
get
(
obj
keyName
)
;
}
else
{
ret
=
value
;
if
(
ret
=
=
=
undefined
&
&
'
object
'
=
=
=
typeof
obj
&
&
!
(
keyName
in
obj
)
&
&
'
function
'
=
=
=
typeof
obj
.
unknownProperty
)
{
return
obj
.
unknownProperty
(
keyName
)
;
}
return
ret
;
}
}
function
_getPath
(
root
path
)
{
var
obj
=
root
;
var
parts
=
path
.
split
(
'
.
'
)
;
for
(
var
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
if
(
!
isGettable
(
obj
)
)
{
return
undefined
;
}
obj
=
get
(
obj
parts
[
i
]
)
;
if
(
obj
&
&
obj
.
isDestroyed
)
{
return
undefined
;
}
}
return
obj
;
}
function
isGettable
(
obj
)
{
if
(
obj
=
=
null
)
{
return
false
;
}
return
ALLOWABLE_TYPES
[
typeof
obj
]
;
}
function
getWithDefault
(
root
key
defaultValue
)
{
var
value
=
get
(
root
key
)
;
if
(
value
=
=
=
undefined
)
{
return
defaultValue
;
}
return
value
;
}
exports
.
default
=
get
;
}
)
;
enifed
(
'
ember
-
metal
/
property_set
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
path_cache
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
tags
'
]
function
(
exports
_emberMetalDebug
_emberMetalFeatures
_emberMetalProperty_get
_emberMetalProperty_events
_emberMetalProperties
_emberMetalError
_emberMetalPath_cache
_emberMetalMeta
_emberMetalUtils
_emberMetalTags
)
{
'
use
strict
'
;
exports
.
set
=
set
;
exports
.
trySet
=
trySet
;
function
set
(
obj
keyName
value
tolerant
)
{
_emberMetalDebug
.
assert
(
'
Set
must
be
called
with
three
or
four
arguments
;
an
object
a
property
key
a
value
and
tolerant
true
/
false
'
arguments
.
length
=
=
=
3
|
|
arguments
.
length
=
=
=
4
)
;
_emberMetalDebug
.
assert
(
'
Cannot
call
set
with
\
'
'
+
keyName
+
'
\
'
on
an
undefined
object
.
'
obj
!
=
=
undefined
&
&
obj
!
=
=
null
)
;
_emberMetalDebug
.
assert
(
'
The
key
provided
to
set
must
be
a
string
you
passed
'
+
keyName
typeof
keyName
=
=
=
'
string
'
)
;
_emberMetalDebug
.
assert
(
'
\
'
this
\
'
in
paths
is
not
supported
'
!
_emberMetalPath_cache
.
hasThis
(
keyName
)
)
;
var
meta
=
undefined
possibleDesc
=
undefined
desc
=
undefined
;
if
(
obj
)
{
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
possibleDesc
=
obj
[
keyName
]
;
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
_emberMetalTags
.
markObjectAsDirty
(
meta
)
;
}
var
isUnknown
currentValue
;
if
(
desc
=
=
=
undefined
&
&
_emberMetalPath_cache
.
isPath
(
keyName
)
)
{
return
setPath
(
obj
keyName
value
tolerant
)
;
}
_emberMetalDebug
.
assert
(
'
calling
set
on
destroyed
object
:
'
+
_emberMetalUtils
.
toString
(
obj
)
+
'
.
'
+
keyName
+
'
=
'
+
_emberMetalUtils
.
toString
(
value
)
!
obj
.
isDestroyed
)
;
if
(
desc
)
{
desc
.
set
(
obj
keyName
value
)
;
}
else
{
if
(
value
!
=
=
undefined
&
&
typeof
obj
=
=
=
'
object
'
&
&
obj
[
keyName
]
=
=
=
value
)
{
return
value
;
}
isUnknown
=
'
object
'
=
=
=
typeof
obj
&
&
!
(
keyName
in
obj
)
;
if
(
isUnknown
&
&
'
function
'
=
=
=
typeof
obj
.
setUnknownProperty
)
{
obj
.
setUnknownProperty
(
keyName
value
)
;
}
else
if
(
meta
&
&
meta
.
peekWatching
(
keyName
)
>
0
)
{
if
(
meta
.
proto
!
=
=
obj
)
{
currentValue
=
obj
[
keyName
]
;
}
if
(
value
!
=
=
currentValue
)
{
_emberMetalProperty_events
.
propertyWillChange
(
obj
keyName
)
;
if
(
currentValue
=
=
=
undefined
&
&
!
(
keyName
in
obj
)
|
|
!
Object
.
prototype
.
propertyIsEnumerable
.
call
(
obj
keyName
)
)
{
_emberMetalProperties
.
defineProperty
(
obj
keyName
null
value
)
;
}
else
{
var
descriptor
=
_emberMetalUtils
.
lookupDescriptor
(
obj
keyName
)
;
var
isMandatorySetter
=
descriptor
&
&
descriptor
.
set
&
&
descriptor
.
set
.
isMandatorySetter
;
if
(
isMandatorySetter
)
{
meta
.
writeValues
(
keyName
value
)
;
}
else
{
obj
[
keyName
]
=
value
;
}
}
_emberMetalProperty_events
.
propertyDidChange
(
obj
keyName
)
;
}
}
else
{
obj
[
keyName
]
=
value
;
if
(
obj
[
_emberMetalProperty_events
.
PROPERTY_DID_CHANGE
]
)
{
obj
[
_emberMetalProperty_events
.
PROPERTY_DID_CHANGE
]
(
keyName
)
;
}
}
}
return
value
;
}
function
setPath
(
root
path
value
tolerant
)
{
var
keyName
;
keyName
=
path
.
slice
(
path
.
lastIndexOf
(
'
.
'
)
+
1
)
;
path
=
path
=
=
=
keyName
?
keyName
:
path
.
slice
(
0
path
.
length
-
(
keyName
.
length
+
1
)
)
;
if
(
path
!
=
=
'
this
'
)
{
root
=
_emberMetalProperty_get
.
_getPath
(
root
path
)
;
}
if
(
!
keyName
|
|
keyName
.
length
=
=
=
0
)
{
throw
new
_emberMetalError
.
default
(
'
Property
set
failed
:
You
passed
an
empty
path
'
)
;
}
if
(
!
root
)
{
if
(
tolerant
)
{
return
;
}
else
{
throw
new
_emberMetalError
.
default
(
'
Property
set
failed
:
object
in
path
"
'
+
path
+
'
"
could
not
be
found
or
was
destroyed
.
'
)
;
}
}
return
set
(
root
keyName
value
)
;
}
function
trySet
(
root
path
value
)
{
return
set
(
root
path
value
true
)
;
}
}
)
;
enifed
(
"
ember
-
metal
/
replace
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
_replace
=
_replace
;
exports
.
default
=
replace
;
var
splice
=
Array
.
prototype
.
splice
;
function
_replace
(
array
idx
amt
objects
)
{
var
args
=
[
]
.
concat
(
objects
)
;
var
ret
=
[
]
;
var
size
=
60000
;
var
start
=
idx
;
var
ends
=
amt
;
var
count
chunk
;
while
(
args
.
length
)
{
count
=
ends
>
size
?
size
:
ends
;
if
(
count
<
=
0
)
{
count
=
0
;
}
chunk
=
args
.
splice
(
0
size
)
;
chunk
=
[
start
count
]
.
concat
(
chunk
)
;
start
+
=
size
;
ends
-
=
count
;
ret
=
ret
.
concat
(
splice
.
apply
(
array
chunk
)
)
;
}
return
ret
;
}
function
replace
(
array
idx
amt
objects
)
{
if
(
array
.
replace
)
{
return
array
.
replace
(
idx
amt
objects
)
;
}
else
{
return
_replace
(
array
idx
amt
objects
)
;
}
}
}
)
;
enifed
(
'
ember
-
metal
/
run_loop
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
property_events
'
'
backburner
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberMetalUtils
_emberMetalProperty_events
_backburner
)
{
'
use
strict
'
;
exports
.
default
=
run
;
function
onBegin
(
current
)
{
run
.
currentRunLoop
=
current
;
}
function
onEnd
(
current
next
)
{
run
.
currentRunLoop
=
next
;
}
var
backburner
=
new
_backburner
.
default
(
[
'
sync
'
'
actions
'
'
destroy
'
]
{
GUID_KEY
:
_emberMetalUtils
.
GUID_KEY
sync
:
{
before
:
_emberMetalProperty_events
.
beginPropertyChanges
after
:
_emberMetalProperty_events
.
endPropertyChanges
}
defaultQueue
:
'
actions
'
onBegin
:
onBegin
onEnd
:
onEnd
onErrorTarget
:
_emberMetalCore
.
default
onErrorMethod
:
'
onerror
'
}
)
;
function
run
(
)
{
return
backburner
.
run
.
apply
(
backburner
arguments
)
;
}
run
.
join
=
function
(
)
{
return
backburner
.
join
.
apply
(
backburner
arguments
)
;
}
;
run
.
bind
=
function
(
)
{
for
(
var
_len
=
arguments
.
length
curried
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
curried
[
_key
]
=
arguments
[
_key
]
;
}
return
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
run
.
join
.
apply
(
run
curried
.
concat
(
args
)
)
;
}
;
}
;
run
.
backburner
=
backburner
;
run
.
currentRunLoop
=
null
;
run
.
queues
=
backburner
.
queueNames
;
run
.
begin
=
function
(
)
{
backburner
.
begin
(
)
;
}
;
run
.
end
=
function
(
)
{
backburner
.
end
(
)
;
}
;
run
.
schedule
=
function
(
)
{
checkAutoRun
(
)
;
backburner
.
schedule
.
apply
(
backburner
arguments
)
;
}
;
run
.
hasScheduledTimers
=
function
(
)
{
return
backburner
.
hasTimers
(
)
;
}
;
run
.
cancelTimers
=
function
(
)
{
backburner
.
cancelTimers
(
)
;
}
;
run
.
sync
=
function
(
)
{
if
(
backburner
.
currentInstance
)
{
backburner
.
currentInstance
.
queues
.
sync
.
flush
(
)
;
}
}
;
run
.
later
=
function
(
)
{
return
backburner
.
later
.
apply
(
backburner
arguments
)
;
}
;
run
.
once
=
function
(
)
{
checkAutoRun
(
)
;
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
args
.
unshift
(
'
actions
'
)
;
return
backburner
.
scheduleOnce
.
apply
(
backburner
args
)
;
}
;
run
.
scheduleOnce
=
function
(
)
{
checkAutoRun
(
)
;
return
backburner
.
scheduleOnce
.
apply
(
backburner
arguments
)
;
}
;
run
.
next
=
function
(
)
{
for
(
var
_len4
=
arguments
.
length
args
=
Array
(
_len4
)
_key4
=
0
;
_key4
<
_len4
;
_key4
+
+
)
{
args
[
_key4
]
=
arguments
[
_key4
]
;
}
args
.
push
(
1
)
;
return
backburner
.
later
.
apply
(
backburner
args
)
;
}
;
run
.
cancel
=
function
(
timer
)
{
return
backburner
.
cancel
(
timer
)
;
}
;
run
.
debounce
=
function
(
)
{
return
backburner
.
debounce
.
apply
(
backburner
arguments
)
;
}
;
run
.
throttle
=
function
(
)
{
return
backburner
.
throttle
.
apply
(
backburner
arguments
)
;
}
;
function
checkAutoRun
(
)
{
if
(
!
run
.
currentRunLoop
)
{
_emberMetalDebug
.
assert
(
'
You
have
turned
on
testing
mode
which
disabled
the
run
-
loop
\
'
s
autorun
.
'
+
'
You
will
need
to
wrap
any
code
with
asynchronous
side
-
effects
in
a
run
'
!
_emberMetalCore
.
default
.
testing
)
;
}
}
run
.
_addQueue
=
function
(
name
after
)
{
if
(
run
.
queues
.
indexOf
(
name
)
=
=
=
-
1
)
{
run
.
queues
.
splice
(
run
.
queues
.
indexOf
(
after
)
+
1
0
name
)
;
}
}
;
}
)
;
enifed
(
'
ember
-
metal
/
set_properties
'
[
'
exports
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
property_set
'
]
function
(
exports
_emberMetalProperty_events
_emberMetalProperty_set
)
{
'
use
strict
'
;
exports
.
default
=
setProperties
;
function
setProperties
(
obj
properties
)
{
if
(
!
properties
|
|
typeof
properties
!
=
=
'
object
'
)
{
return
properties
;
}
_emberMetalProperty_events
.
changeProperties
(
function
(
)
{
var
props
=
Object
.
keys
(
properties
)
;
var
propertyName
;
for
(
var
i
=
0
l
=
props
.
length
;
i
<
l
;
i
+
+
)
{
propertyName
=
props
[
i
]
;
_emberMetalProperty_set
.
set
(
obj
propertyName
properties
[
propertyName
]
)
;
}
}
)
;
return
properties
;
}
}
)
;
enifed
(
'
ember
-
metal
/
streams
/
dependency
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalDebug
_emberMetalAssign
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
function
Dependency
(
depender
dependee
)
{
_emberMetalDebug
.
assert
(
'
Dependency
error
:
Depender
must
be
a
stream
'
_emberMetalStreamsUtils
.
isStream
(
depender
)
)
;
this
.
next
=
null
;
this
.
prev
=
null
;
this
.
depender
=
depender
;
this
.
dependee
=
dependee
;
this
.
unsubscription
=
null
;
}
_emberMetalAssign
.
default
(
Dependency
.
prototype
{
subscribe
:
function
(
)
{
_emberMetalDebug
.
assert
(
'
Dependency
error
:
Dependency
tried
to
subscribe
while
already
subscribed
'
!
this
.
unsubscription
)
;
this
.
unsubscription
=
_emberMetalStreamsUtils
.
subscribe
(
this
.
dependee
this
.
depender
.
notify
this
.
depender
)
;
}
unsubscribe
:
function
(
)
{
if
(
this
.
unsubscription
)
{
this
.
unsubscription
(
)
;
this
.
unsubscription
=
null
;
}
}
replace
:
function
(
dependee
)
{
if
(
this
.
dependee
!
=
=
dependee
)
{
this
.
dependee
=
dependee
;
if
(
this
.
unsubscription
)
{
this
.
unsubscribe
(
)
;
this
.
subscribe
(
)
;
}
return
true
;
}
return
false
;
}
getValue
:
function
(
)
{
return
_emberMetalStreamsUtils
.
read
(
this
.
dependee
)
;
}
setValue
:
function
(
value
)
{
return
_emberMetalStreamsUtils
.
setValue
(
this
.
dependee
value
)
;
}
}
)
;
exports
.
default
=
Dependency
;
}
)
;
enifed
(
'
ember
-
metal
/
streams
/
key
-
stream
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalObserver
_emberMetalStreamsStream
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
function
labelFor
(
source
key
)
{
return
source
.
label
?
source
.
label
+
'
.
'
+
key
:
key
;
}
exports
.
default
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
source
key
)
{
_emberMetalDebug
.
assert
(
'
KeyStream
error
:
source
must
be
a
stream
'
_emberMetalStreamsUtils
.
isStream
(
source
)
)
;
_emberMetalDebug
.
assert
(
'
KeyStream
error
:
key
must
be
a
non
-
empty
string
'
typeof
key
=
=
=
'
string
'
&
&
key
.
length
>
0
)
;
_emberMetalDebug
.
assert
(
'
KeyStream
error
:
key
must
not
have
a
\
'
.
\
'
'
key
.
indexOf
(
'
.
'
)
=
=
=
-
1
)
;
var
label
=
labelFor
(
source
key
)
;
this
.
path
=
label
;
this
.
observedObject
=
null
;
this
.
key
=
key
;
this
.
sourceDep
=
this
.
addMutableDependency
(
source
)
;
this
.
label
=
label
;
}
compute
:
function
(
)
{
var
object
=
this
.
sourceDep
.
getValue
(
)
;
var
type
=
typeof
object
;
if
(
!
object
|
|
type
=
=
=
'
boolean
'
)
{
return
;
}
if
(
type
=
=
=
'
object
'
)
{
return
_emberMetalProperty_get
.
get
(
object
this
.
key
)
;
}
return
object
[
this
.
key
]
;
}
setValue
:
function
(
value
)
{
var
object
=
this
.
sourceDep
.
getValue
(
)
;
if
(
object
)
{
_emberMetalProperty_set
.
set
(
object
this
.
key
value
)
;
}
}
setSource
:
function
(
source
)
{
this
.
sourceDep
.
replace
(
source
)
;
this
.
notify
(
)
;
}
_super
revalidate
:
_emberMetalStreamsStream
.
default
.
prototype
.
revalidate
revalidate
:
function
(
value
)
{
this
.
_super
revalidate
(
value
)
;
var
object
=
this
.
sourceDep
.
getValue
(
)
;
if
(
object
!
=
=
this
.
observedObject
)
{
this
.
_clearObservedObject
(
)
;
if
(
object
&
&
typeof
object
=
=
=
'
object
'
)
{
_emberMetalObserver
.
addObserver
(
object
this
.
key
this
this
.
notify
)
;
this
.
observedObject
=
object
;
}
}
}
_super
deactivate
:
_emberMetalStreamsStream
.
default
.
prototype
.
deactivate
_clearObservedObject
:
function
(
)
{
if
(
this
.
observedObject
)
{
_emberMetalObserver
.
removeObserver
(
this
.
observedObject
this
.
key
this
this
.
notify
)
;
this
.
observedObject
=
null
;
}
}
deactivate
:
function
(
)
{
this
.
_super
deactivate
(
)
;
this
.
_clearObservedObject
(
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
metal
/
streams
/
proxy
-
stream
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
metal
/
streams
/
stream
'
]
function
(
exports
_emberRuntimeSystemObject
_emberMetalStreamsStream
)
{
'
use
strict
'
;
var
ProxyStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
source
label
)
{
this
.
label
=
label
;
this
.
sourceDep
=
this
.
addMutableDependency
(
source
)
;
}
compute
:
function
(
)
{
return
this
.
sourceDep
.
getValue
(
)
;
}
setValue
:
function
(
value
)
{
this
.
sourceDep
.
setValue
(
value
)
;
}
setSource
:
function
(
source
)
{
var
didChange
=
this
.
sourceDep
.
replace
(
source
)
;
if
(
didChange
|
|
!
(
source
instanceof
_emberRuntimeSystemObject
.
default
)
)
{
this
.
notify
(
)
;
}
}
}
)
;
ProxyStream
.
extend
=
_emberMetalStreamsStream
.
default
.
extend
;
exports
.
default
=
ProxyStream
;
}
)
;
enifed
(
'
ember
-
metal
/
streams
/
stream
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
path_cache
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
streams
/
subscriber
'
'
ember
-
metal
/
streams
/
dependency
'
'
ember
-
metal
/
utils
'
'
require
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberMetalAssign
_emberMetalDebug
_emberMetalPath_cache
_emberMetalObserver
_emberMetalStreamsUtils
_emberMetalEmpty_object
_emberMetalStreamsSubscriber
_emberMetalStreamsDependency
_emberMetalUtils
_require
_emberMetalSymbol
)
{
'
use
strict
'
;
exports
.
wrap
=
wrap
;
var
IS_STREAM
=
_emberMetalSymbol
.
default
(
'
IS_STREAM
'
)
;
exports
.
IS_STREAM
=
IS_STREAM
;
function
BasicStream
(
label
)
{
this
.
_init
(
label
)
;
}
var
KeyStream
;
var
ProxyMixin
;
BasicStream
.
prototype
=
{
_init
:
function
(
label
)
{
this
[
IS_STREAM
]
=
true
;
this
.
label
=
makeLabel
(
label
)
;
this
.
isActive
=
false
;
this
.
isDirty
=
true
;
this
.
isDestroyed
=
false
;
this
.
cache
=
undefined
;
this
.
children
=
undefined
;
this
.
subscriberHead
=
null
;
this
.
subscriberTail
=
null
;
this
.
dependencyHead
=
null
;
this
.
dependencyTail
=
null
;
this
.
observedProxy
=
null
;
this
.
__ember_meta__
=
null
;
this
[
_emberMetalUtils
.
GUID_KEY
]
=
null
;
}
_makeChildStream
:
function
(
key
)
{
KeyStream
=
KeyStream
|
|
_require
.
default
(
'
ember
-
metal
/
streams
/
key
-
stream
'
)
.
default
;
return
new
KeyStream
(
this
key
)
;
}
removeChild
:
function
(
key
)
{
delete
this
.
children
[
key
]
;
}
getKey
:
function
(
key
)
{
if
(
this
.
children
=
=
=
undefined
)
{
this
.
children
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
var
keyStream
=
this
.
children
[
key
]
;
if
(
keyStream
=
=
=
undefined
)
{
keyStream
=
this
.
_makeChildStream
(
key
)
;
this
.
children
[
key
]
=
keyStream
;
}
return
keyStream
;
}
get
:
function
(
path
)
{
var
firstKey
=
_emberMetalPath_cache
.
getFirstKey
(
path
)
;
var
tailPath
=
_emberMetalPath_cache
.
getTailPath
(
path
)
;
if
(
this
.
children
=
=
=
undefined
)
{
this
.
children
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
var
keyStream
=
this
.
children
[
firstKey
]
;
if
(
keyStream
=
=
=
undefined
)
{
keyStream
=
this
.
_makeChildStream
(
firstKey
path
)
;
this
.
children
[
firstKey
]
=
keyStream
;
}
if
(
tailPath
=
=
=
undefined
)
{
return
keyStream
;
}
else
{
return
keyStream
.
get
(
tailPath
)
;
}
}
value
:
function
(
)
{
if
(
!
this
.
isActive
)
{
this
.
isDirty
=
true
;
}
var
willRevalidate
=
false
;
if
(
!
this
.
isActive
&
&
this
.
subscriberHead
)
{
this
.
activate
(
)
;
willRevalidate
=
true
;
}
if
(
this
.
isDirty
)
{
if
(
this
.
isActive
)
{
willRevalidate
=
true
;
}
this
.
cache
=
this
.
compute
(
)
;
this
.
isDirty
=
false
;
}
if
(
willRevalidate
)
{
this
.
revalidate
(
this
.
cache
)
;
}
return
this
.
cache
;
}
addMutableDependency
:
function
(
object
)
{
var
dependency
=
new
_emberMetalStreamsDependency
.
default
(
this
object
)
;
if
(
this
.
isActive
)
{
dependency
.
subscribe
(
)
;
}
if
(
this
.
dependencyHead
=
=
=
null
)
{
this
.
dependencyHead
=
this
.
dependencyTail
=
dependency
;
}
else
{
var
tail
=
this
.
dependencyTail
;
tail
.
next
=
dependency
;
dependency
.
prev
=
tail
;
this
.
dependencyTail
=
dependency
;
}
return
dependency
;
}
addDependency
:
function
(
object
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
object
)
)
{
this
.
addMutableDependency
(
object
)
;
}
}
subscribeDependencies
:
function
(
)
{
var
dependency
=
this
.
dependencyHead
;
while
(
dependency
)
{
var
next
=
dependency
.
next
;
dependency
.
subscribe
(
)
;
dependency
=
next
;
}
}
unsubscribeDependencies
:
function
(
)
{
var
dependency
=
this
.
dependencyHead
;
while
(
dependency
)
{
var
next
=
dependency
.
next
;
dependency
.
unsubscribe
(
)
;
dependency
=
next
;
}
}
maybeDeactivate
:
function
(
)
{
if
(
!
this
.
subscriberHead
&
&
this
.
isActive
)
{
this
.
isActive
=
false
;
this
.
unsubscribeDependencies
(
)
;
this
.
deactivate
(
)
;
}
}
activate
:
function
(
)
{
this
.
isActive
=
true
;
this
.
subscribeDependencies
(
)
;
}
revalidate
:
function
(
value
)
{
if
(
value
!
=
=
this
.
observedProxy
)
{
this
.
_clearObservedProxy
(
)
;
ProxyMixin
=
ProxyMixin
|
|
_require
.
default
(
'
ember
-
runtime
/
mixins
/
-
proxy
'
)
.
default
;
if
(
ProxyMixin
.
detect
(
value
)
)
{
_emberMetalObserver
.
addObserver
(
value
'
content
'
this
this
.
notify
)
;
this
.
observedProxy
=
value
;
}
}
}
_clearObservedProxy
:
function
(
)
{
if
(
this
.
observedProxy
)
{
_emberMetalObserver
.
removeObserver
(
this
.
observedProxy
'
content
'
this
this
.
notify
)
;
this
.
observedProxy
=
null
;
}
}
deactivate
:
function
(
)
{
this
.
_clearObservedProxy
(
)
;
}
compute
:
function
(
)
{
throw
new
Error
(
'
Stream
error
:
compute
not
implemented
'
)
;
}
setValue
:
function
(
)
{
throw
new
Error
(
'
Stream
error
:
setValue
not
implemented
'
)
;
}
notify
:
function
(
)
{
this
.
notifyExcept
(
)
;
}
notifyExcept
:
function
(
callbackToSkip
contextToSkip
)
{
if
(
!
this
.
isDirty
)
{
this
.
isDirty
=
true
;
this
.
notifySubscribers
(
callbackToSkip
contextToSkip
)
;
}
}
subscribe
:
function
(
callback
context
)
{
_emberMetalDebug
.
assert
(
'
You
tried
to
subscribe
to
a
stream
but
the
callback
provided
was
not
a
function
.
'
typeof
callback
=
=
=
'
function
'
)
;
var
subscriber
=
new
_emberMetalStreamsSubscriber
.
default
(
callback
context
this
)
;
if
(
this
.
subscriberHead
=
=
=
null
)
{
this
.
subscriberHead
=
this
.
subscriberTail
=
subscriber
;
}
else
{
var
tail
=
this
.
subscriberTail
;
tail
.
next
=
subscriber
;
subscriber
.
prev
=
tail
;
this
.
subscriberTail
=
subscriber
;
}
var
stream
=
this
;
return
function
(
prune
)
{
subscriber
.
removeFrom
(
stream
)
;
if
(
prune
)
{
stream
.
prune
(
)
;
}
}
;
}
prune
:
function
(
)
{
if
(
this
.
subscriberHead
=
=
=
null
)
{
this
.
destroy
(
true
)
;
}
}
unsubscribe
:
function
(
callback
context
)
{
var
subscriber
=
this
.
subscriberHead
;
while
(
subscriber
)
{
var
next
=
subscriber
.
next
;
if
(
subscriber
.
callback
=
=
=
callback
&
&
subscriber
.
context
=
=
=
context
)
{
subscriber
.
removeFrom
(
this
)
;
}
subscriber
=
next
;
}
}
notifySubscribers
:
function
(
callbackToSkip
contextToSkip
)
{
var
subscriber
=
this
.
subscriberHead
;
while
(
subscriber
)
{
var
next
=
subscriber
.
next
;
var
callback
=
subscriber
.
callback
;
var
context
=
subscriber
.
context
;
subscriber
=
next
;
if
(
callback
=
=
=
callbackToSkip
&
&
context
=
=
=
contextToSkip
)
{
continue
;
}
if
(
context
=
=
=
undefined
)
{
callback
(
this
)
;
}
else
{
callback
.
call
(
context
this
)
;
}
}
}
destroy
:
function
(
prune
)
{
if
(
!
this
.
isDestroyed
)
{
this
.
isDestroyed
=
true
;
this
.
subscriberHead
=
this
.
subscriberTail
=
null
;
this
.
maybeDeactivate
(
)
;
var
dependencies
=
this
.
dependencies
;
if
(
dependencies
)
{
for
(
var
i
=
0
l
=
dependencies
.
length
;
i
<
l
;
i
+
+
)
{
dependencies
[
i
]
(
prune
)
;
}
}
return
true
;
}
}
}
;
BasicStream
.
extend
=
function
(
object
)
{
var
Child
=
function
(
)
{
this
.
_init
(
)
;
this
.
init
.
apply
(
this
arguments
)
;
_emberMetalDebug
.
debugSeal
(
this
)
;
}
;
Child
.
prototype
=
Object
.
create
(
this
.
prototype
)
;
_emberMetalAssign
.
default
(
Child
.
prototype
object
)
;
Child
.
extend
=
BasicStream
.
extend
;
return
Child
;
}
;
var
Stream
=
BasicStream
.
extend
(
{
init
:
function
(
fn
label
)
{
this
.
_compute
=
fn
;
this
.
label
=
label
;
}
compute
:
function
(
)
{
return
this
.
_compute
(
)
;
}
}
)
;
function
wrap
(
value
Kind
param
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
value
)
)
{
return
value
;
}
else
{
return
new
Kind
(
value
param
)
;
}
}
function
makeLabel
(
label
)
{
if
(
label
=
=
=
undefined
)
{
return
'
(
no
label
)
'
;
}
else
{
return
label
;
}
}
exports
.
default
=
BasicStream
;
exports
.
Stream
=
Stream
;
}
)
;
enifed
(
'
ember
-
metal
/
streams
/
subscriber
'
[
'
exports
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_emberMetalAssign
)
{
'
use
strict
'
;
function
Subscriber
(
callback
context
)
{
this
.
next
=
null
;
this
.
prev
=
null
;
this
.
callback
=
callback
;
this
.
context
=
context
;
}
_emberMetalAssign
.
default
(
Subscriber
.
prototype
{
removeFrom
:
function
(
stream
)
{
var
next
=
this
.
next
;
var
prev
=
this
.
prev
;
if
(
prev
)
{
prev
.
next
=
next
;
}
else
{
stream
.
subscriberHead
=
next
;
}
if
(
next
)
{
next
.
prev
=
prev
;
}
else
{
stream
.
subscriberTail
=
prev
;
}
stream
.
maybeDeactivate
(
)
;
}
}
)
;
exports
.
default
=
Subscriber
;
}
)
;
enifed
(
'
ember
-
metal
/
streams
/
utils
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
streams
/
stream
'
]
function
(
exports
_emberMetalDebug
_emberMetalStreamsStream
)
{
'
use
strict
'
;
exports
.
isStream
=
isStream
;
exports
.
subscribe
=
subscribe
;
exports
.
unsubscribe
=
unsubscribe
;
exports
.
read
=
read
;
exports
.
readArray
=
readArray
;
exports
.
readHash
=
readHash
;
exports
.
scanArray
=
scanArray
;
exports
.
scanHash
=
scanHash
;
exports
.
concat
=
concat
;
exports
.
labelsFor
=
labelsFor
;
exports
.
labelsForObject
=
labelsForObject
;
exports
.
labelFor
=
labelFor
;
exports
.
or
=
or
;
exports
.
addDependency
=
addDependency
;
exports
.
zip
=
zip
;
exports
.
zipHash
=
zipHash
;
exports
.
chain
=
chain
;
exports
.
setValue
=
setValue
;
function
isStream
(
object
)
{
return
object
&
&
object
[
_emberMetalStreamsStream
.
IS_STREAM
]
;
}
function
subscribe
(
object
callback
context
)
{
if
(
object
&
&
object
[
_emberMetalStreamsStream
.
IS_STREAM
]
)
{
return
object
.
subscribe
(
callback
context
)
;
}
}
function
unsubscribe
(
object
callback
context
)
{
if
(
object
&
&
object
[
_emberMetalStreamsStream
.
IS_STREAM
]
)
{
object
.
unsubscribe
(
callback
context
)
;
}
}
function
read
(
object
)
{
if
(
object
&
&
object
[
_emberMetalStreamsStream
.
IS_STREAM
]
)
{
return
object
.
value
(
)
;
}
else
{
return
object
;
}
}
function
readArray
(
array
)
{
var
length
=
array
.
length
;
var
ret
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
ret
[
i
]
=
read
(
array
[
i
]
)
;
}
return
ret
;
}
function
readHash
(
object
)
{
var
ret
=
{
}
;
for
(
var
key
in
object
)
{
ret
[
key
]
=
read
(
object
[
key
]
)
;
}
return
ret
;
}
function
scanArray
(
array
)
{
var
length
=
array
.
length
;
var
containsStream
=
false
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
isStream
(
array
[
i
]
)
)
{
containsStream
=
true
;
break
;
}
}
return
containsStream
;
}
function
scanHash
(
hash
)
{
var
containsStream
=
false
;
for
(
var
prop
in
hash
)
{
if
(
isStream
(
hash
[
prop
]
)
)
{
containsStream
=
true
;
break
;
}
}
return
containsStream
;
}
var
ConcatStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
array
separator
)
{
this
.
array
=
array
;
this
.
separator
=
separator
;
this
.
isConcat
=
true
;
}
label
:
function
(
)
{
var
labels
=
labelsFor
(
this
.
array
)
;
return
'
concat
(
[
'
+
labels
.
join
(
'
'
)
+
'
]
;
separator
=
'
+
inspect
(
this
.
separator
)
+
'
)
'
;
}
compute
:
function
(
)
{
return
concat
(
readArray
(
this
.
array
)
this
.
separator
)
;
}
}
)
;
function
concat
(
array
separator
)
{
var
hasStream
=
scanArray
(
array
)
;
if
(
hasStream
)
{
var
stream
=
new
ConcatStream
(
array
separator
)
;
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
addDependency
(
stream
array
[
i
]
)
;
}
return
stream
;
}
else
{
return
array
.
join
(
separator
)
;
}
}
function
labelsFor
(
streams
)
{
var
labels
=
[
]
;
for
(
var
i
=
0
l
=
streams
.
length
;
i
<
l
;
i
+
+
)
{
var
stream
=
streams
[
i
]
;
labels
.
push
(
labelFor
(
stream
)
)
;
}
return
labels
;
}
function
labelsForObject
(
streams
)
{
var
labels
=
[
]
;
for
(
var
prop
in
streams
)
{
labels
.
push
(
prop
+
'
:
'
+
inspect
(
streams
[
prop
]
)
)
;
}
return
labels
.
length
?
'
{
'
+
labels
.
join
(
'
'
)
+
'
}
'
:
'
{
}
'
;
}
function
labelFor
(
maybeStream
)
{
if
(
isStream
(
maybeStream
)
)
{
var
stream
=
maybeStream
;
return
typeof
stream
.
label
=
=
=
'
function
'
?
stream
.
label
(
)
:
stream
.
label
;
}
else
{
return
inspect
(
maybeStream
)
;
}
}
function
inspect
(
value
)
{
switch
(
typeof
value
)
{
case
'
string
'
:
return
'
"
'
+
value
+
'
"
'
;
case
'
object
'
:
return
'
{
.
.
.
}
'
;
case
'
function
'
:
return
'
function
(
)
{
.
.
.
}
'
;
default
:
return
String
(
value
)
;
}
}
function
or
(
first
second
)
{
var
stream
=
new
_emberMetalStreamsStream
.
Stream
(
function
(
)
{
return
first
.
value
(
)
|
|
second
.
value
(
)
;
}
function
(
)
{
return
labelFor
(
first
)
+
'
|
|
'
+
labelFor
(
second
)
;
}
)
;
stream
.
addDependency
(
first
)
;
stream
.
addDependency
(
second
)
;
return
stream
;
}
function
addDependency
(
stream
dependency
)
{
_emberMetalDebug
.
assert
(
'
Cannot
add
a
stream
as
a
dependency
to
a
non
-
stream
'
isStream
(
stream
)
|
|
!
isStream
(
dependency
)
)
;
if
(
isStream
(
stream
)
)
{
stream
.
addDependency
(
dependency
)
;
}
}
function
zip
(
streams
callback
label
)
{
_emberMetalDebug
.
assert
(
'
Must
call
zip
with
a
label
'
!
!
label
)
;
var
stream
=
new
_emberMetalStreamsStream
.
Stream
(
function
(
)
{
var
array
=
readArray
(
streams
)
;
return
callback
?
callback
(
array
)
:
array
;
}
function
(
)
{
return
label
+
'
(
'
+
labelsFor
(
streams
)
+
'
)
'
;
}
)
;
for
(
var
i
=
0
l
=
streams
.
length
;
i
<
l
;
i
+
+
)
{
stream
.
addDependency
(
streams
[
i
]
)
;
}
return
stream
;
}
function
zipHash
(
object
callback
label
)
{
_emberMetalDebug
.
assert
(
'
Must
call
zipHash
with
a
label
'
!
!
label
)
;
var
stream
=
new
_emberMetalStreamsStream
.
Stream
(
function
(
)
{
var
hash
=
readHash
(
object
)
;
return
callback
?
callback
(
hash
)
:
hash
;
}
function
(
)
{
return
label
+
'
(
'
+
labelsForObject
(
object
)
+
'
)
'
;
}
)
;
for
(
var
prop
in
object
)
{
stream
.
addDependency
(
object
[
prop
]
)
;
}
return
stream
;
}
function
chain
(
value
fn
label
)
{
_emberMetalDebug
.
assert
(
'
Must
call
chain
with
a
label
'
!
!
label
)
;
if
(
isStream
(
value
)
)
{
var
stream
=
new
_emberMetalStreamsStream
.
Stream
(
fn
function
(
)
{
return
label
+
'
(
'
+
labelFor
(
value
)
+
'
)
'
;
}
)
;
stream
.
addDependency
(
value
)
;
return
stream
;
}
else
{
return
fn
(
)
;
}
}
function
setValue
(
object
value
)
{
if
(
object
&
&
object
[
_emberMetalStreamsStream
.
IS_STREAM
]
)
{
object
.
setValue
(
value
)
;
}
}
}
)
;
enifed
(
'
ember
-
metal
/
symbol
'
[
'
exports
'
'
ember
-
metal
/
utils
'
]
function
(
exports
_emberMetalUtils
)
{
'
use
strict
'
;
exports
.
default
=
symbol
;
function
symbol
(
debugName
)
{
return
_emberMetalUtils
.
intern
(
debugName
+
'
[
id
=
'
+
_emberMetalUtils
.
GUID_KEY
+
Math
.
floor
(
Math
.
random
(
)
*
new
Date
(
)
)
+
'
]
'
)
;
}
}
)
;
enifed
(
'
ember
-
metal
/
tags
'
[
'
exports
'
'
ember
-
metal
/
meta
'
'
require
'
]
function
(
exports
_emberMetalMeta
_require2
)
{
'
use
strict
'
;
exports
.
tagFor
=
tagFor
;
var
hasGlimmer
=
_require2
.
has
(
'
glimmer
-
reference
'
)
;
var
CONSTANT_TAG
=
undefined
CURRENT_TAG
=
undefined
DirtyableTag
=
undefined
makeTag
=
undefined
;
var
markObjectAsDirty
=
undefined
;
exports
.
markObjectAsDirty
=
markObjectAsDirty
;
function
tagFor
(
object
_meta
)
{
if
(
!
hasGlimmer
)
{
throw
new
Error
(
'
Cannot
call
tagFor
without
Glimmer
'
)
;
}
if
(
object
&
&
typeof
object
=
=
=
'
object
'
)
{
var
meta
=
_meta
|
|
_emberMetalMeta
.
meta
(
object
)
;
return
meta
.
writableTag
(
makeTag
)
;
}
else
{
return
CONSTANT_TAG
;
}
}
if
(
hasGlimmer
)
{
var
_require
=
_require2
.
default
(
'
glimmer
-
reference
'
)
;
DirtyableTag
=
_require
.
DirtyableTag
;
CONSTANT_TAG
=
_require
.
CONSTANT_TAG
;
CURRENT_TAG
=
_require
.
CURRENT_TAG
;
makeTag
=
function
(
)
{
return
new
DirtyableTag
(
)
;
}
;
exports
.
markObjectAsDirty
=
markObjectAsDirty
=
function
(
meta
)
{
var
tag
=
meta
&
&
meta
.
readableTag
(
)
|
|
CURRENT_TAG
;
tag
.
dirty
(
)
;
}
;
}
else
{
exports
.
markObjectAsDirty
=
markObjectAsDirty
=
function
(
)
{
}
;
}
}
)
;
enifed
(
'
ember
-
metal
/
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
no
use
strict
'
;
exports
.
uuid
=
uuid
;
exports
.
intern
=
intern
;
exports
.
generateGuid
=
generateGuid
;
exports
.
guidFor
=
guidFor
;
exports
.
wrap
=
wrap
;
exports
.
tryInvoke
=
tryInvoke
;
exports
.
makeArray
=
makeArray
;
exports
.
inspect
=
inspect
;
exports
.
applyStr
=
applyStr
;
exports
.
lookupDescriptor
=
lookupDescriptor
;
exports
.
toString
=
toString
;
var
_uuid
=
0
;
function
uuid
(
)
{
return
+
+
_uuid
;
}
var
GUID_PREFIX
=
'
ember
'
;
var
numberCache
=
[
]
;
var
stringCache
=
{
}
;
function
intern
(
str
)
{
var
obj
=
{
}
;
obj
[
str
]
=
1
;
for
(
var
key
in
obj
)
{
if
(
key
=
=
=
str
)
{
return
key
;
}
}
return
str
;
}
var
GUID_KEY
=
intern
(
'
__ember
'
+
+
new
Date
(
)
)
;
var
GUID_DESC
=
{
writable
:
true
configurable
:
true
enumerable
:
false
value
:
null
}
;
exports
.
GUID_DESC
=
GUID_DESC
;
var
nullDescriptor
=
{
configurable
:
true
writable
:
true
enumerable
:
false
value
:
null
}
;
var
GUID_KEY_PROPERTY
=
{
name
:
GUID_KEY
descriptor
:
nullDescriptor
}
;
exports
.
GUID_KEY_PROPERTY
=
GUID_KEY_PROPERTY
;
function
generateGuid
(
obj
prefix
)
{
if
(
!
prefix
)
{
prefix
=
GUID_PREFIX
;
}
var
ret
=
prefix
+
uuid
(
)
;
if
(
obj
)
{
if
(
obj
[
GUID_KEY
]
=
=
=
null
)
{
obj
[
GUID_KEY
]
=
ret
;
}
else
{
GUID_DESC
.
value
=
ret
;
if
(
obj
.
__defineNonEnumerable
)
{
obj
.
__defineNonEnumerable
(
GUID_KEY_PROPERTY
)
;
}
else
{
Object
.
defineProperty
(
obj
GUID_KEY
GUID_DESC
)
;
}
}
}
return
ret
;
}
function
guidFor
(
obj
)
{
if
(
obj
&
&
obj
[
GUID_KEY
]
)
{
return
obj
[
GUID_KEY
]
;
}
if
(
obj
=
=
=
undefined
)
{
return
'
(
undefined
)
'
;
}
if
(
obj
=
=
=
null
)
{
return
'
(
null
)
'
;
}
var
ret
;
var
type
=
typeof
obj
;
switch
(
type
)
{
case
'
number
'
:
ret
=
numberCache
[
obj
]
;
if
(
!
ret
)
{
ret
=
numberCache
[
obj
]
=
'
nu
'
+
obj
;
}
return
ret
;
case
'
string
'
:
ret
=
stringCache
[
obj
]
;
if
(
!
ret
)
{
ret
=
stringCache
[
obj
]
=
'
st
'
+
uuid
(
)
;
}
return
ret
;
case
'
boolean
'
:
return
obj
?
'
(
true
)
'
:
'
(
false
)
'
;
default
:
if
(
obj
=
=
=
Object
)
{
return
'
(
Object
)
'
;
}
if
(
obj
=
=
=
Array
)
{
return
'
(
Array
)
'
;
}
ret
=
GUID_PREFIX
+
uuid
(
)
;
if
(
obj
[
GUID_KEY
]
=
=
=
null
)
{
obj
[
GUID_KEY
]
=
ret
;
}
else
{
GUID_DESC
.
value
=
ret
;
if
(
obj
.
__defineNonEnumerable
)
{
obj
.
__defineNonEnumerable
(
GUID_KEY_PROPERTY
)
;
}
else
{
Object
.
defineProperty
(
obj
GUID_KEY
GUID_DESC
)
;
}
}
return
ret
;
}
}
var
HAS_SUPER_PATTERN
=
/
\
.
(
_super
|
call
\
(
this
|
apply
\
(
this
)
/
;
var
fnToString
=
Function
.
prototype
.
toString
;
var
checkHasSuper
=
(
function
(
)
{
var
sourceAvailable
=
fnToString
.
call
(
function
(
)
{
return
this
;
}
)
.
indexOf
(
'
return
this
'
)
>
-
1
;
if
(
sourceAvailable
)
{
return
function
checkHasSuper
(
func
)
{
return
HAS_SUPER_PATTERN
.
test
(
fnToString
.
call
(
func
)
)
;
}
;
}
return
function
checkHasSuper
(
)
{
return
true
;
}
;
}
)
(
)
;
exports
.
checkHasSuper
=
checkHasSuper
;
function
ROOT
(
)
{
}
ROOT
.
__hasSuper
=
false
;
function
hasSuper
(
func
)
{
if
(
func
.
__hasSuper
=
=
=
undefined
)
{
func
.
__hasSuper
=
checkHasSuper
(
func
)
;
}
return
func
.
__hasSuper
;
}
function
wrap
(
func
superFunc
)
{
if
(
!
hasSuper
(
func
)
)
{
return
func
;
}
if
(
!
superFunc
.
wrappedFunction
&
&
hasSuper
(
superFunc
)
)
{
return
_wrap
(
func
_wrap
(
superFunc
ROOT
)
)
;
}
return
_wrap
(
func
superFunc
)
;
}
function
_wrap
(
func
superFunc
)
{
function
superWrapper
(
)
{
var
orig
=
this
.
_super
;
this
.
_super
=
superFunc
;
var
ret
=
func
.
apply
(
this
arguments
)
;
this
.
_super
=
orig
;
return
ret
;
}
superWrapper
.
wrappedFunction
=
func
;
superWrapper
.
__ember_observes__
=
func
.
__ember_observes__
;
superWrapper
.
__ember_observesBefore__
=
func
.
__ember_observesBefore__
;
superWrapper
.
__ember_listens__
=
func
.
__ember_listens__
;
return
superWrapper
;
}
function
canInvoke
(
obj
methodName
)
{
return
!
!
(
obj
&
&
typeof
obj
[
methodName
]
=
=
=
'
function
'
)
;
}
function
tryInvoke
(
obj
methodName
args
)
{
if
(
canInvoke
(
obj
methodName
)
)
{
return
args
?
applyStr
(
obj
methodName
args
)
:
applyStr
(
obj
methodName
)
;
}
}
var
objectToString
=
Object
.
prototype
.
toString
;
function
makeArray
(
obj
)
{
if
(
obj
=
=
=
null
|
|
obj
=
=
=
undefined
)
{
return
[
]
;
}
return
Array
.
isArray
(
obj
)
?
obj
:
[
obj
]
;
}
function
inspect
(
obj
)
{
if
(
obj
=
=
=
null
)
{
return
'
null
'
;
}
if
(
obj
=
=
=
undefined
)
{
return
'
undefined
'
;
}
if
(
Array
.
isArray
(
obj
)
)
{
return
'
[
'
+
obj
+
'
]
'
;
}
var
type
=
typeof
obj
;
if
(
type
!
=
=
'
object
'
&
&
type
!
=
=
'
symbol
'
)
{
return
'
'
+
obj
;
}
if
(
typeof
obj
.
toString
=
=
=
'
function
'
&
&
obj
.
toString
!
=
=
objectToString
)
{
return
obj
.
toString
(
)
;
}
var
v
;
var
ret
=
[
]
;
for
(
var
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
)
{
v
=
obj
[
key
]
;
if
(
v
=
=
=
'
toString
'
)
{
continue
;
}
if
(
typeof
v
=
=
=
'
function
'
)
{
v
=
'
function
(
)
{
.
.
.
}
'
;
}
if
(
v
&
&
typeof
v
.
toString
!
=
=
'
function
'
)
{
ret
.
push
(
key
+
'
:
'
+
objectToString
.
call
(
v
)
)
;
}
else
{
ret
.
push
(
key
+
'
:
'
+
v
)
;
}
}
}
return
'
{
'
+
ret
.
join
(
'
'
)
+
'
}
'
;
}
function
applyStr
(
t
m
a
)
{
var
l
=
a
&
&
a
.
length
;
if
(
!
a
|
|
!
l
)
{
return
t
[
m
]
(
)
;
}
switch
(
l
)
{
case
1
:
return
t
[
m
]
(
a
[
0
]
)
;
case
2
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
)
;
case
3
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
a
[
2
]
)
;
case
4
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
a
[
2
]
a
[
3
]
)
;
case
5
:
return
t
[
m
]
(
a
[
0
]
a
[
1
]
a
[
2
]
a
[
3
]
a
[
4
]
)
;
default
:
return
t
[
m
]
.
apply
(
t
a
)
;
}
}
function
lookupDescriptor
(
obj
keyName
)
{
var
current
=
obj
;
while
(
current
)
{
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
current
keyName
)
;
if
(
descriptor
)
{
return
descriptor
;
}
current
=
Object
.
getPrototypeOf
(
current
)
;
}
return
null
;
}
function
toString
(
obj
)
{
if
(
obj
&
&
obj
.
toString
)
{
return
obj
.
toString
(
)
;
}
else
{
return
objectToString
.
call
(
obj
)
;
}
}
exports
.
GUID_KEY
=
GUID_KEY
;
exports
.
makeArray
=
makeArray
;
exports
.
canInvoke
=
canInvoke
;
}
)
;
enifed
(
'
ember
-
metal
/
watch_key
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
utils
'
]
function
(
exports
_emberMetalFeatures
_emberMetalMeta
_emberMetalProperties
_emberMetalUtils
)
{
'
use
strict
'
;
exports
.
watchKey
=
watchKey
;
exports
.
unwatchKey
=
unwatchKey
;
var
handleMandatorySetter
=
undefined
;
function
watchKey
(
obj
keyName
meta
)
{
if
(
keyName
=
=
=
'
length
'
&
&
Array
.
isArray
(
obj
)
)
{
return
;
}
var
m
=
meta
|
|
_emberMetalMeta
.
meta
(
obj
)
;
if
(
!
m
.
peekWatching
(
keyName
)
)
{
m
.
writeWatching
(
keyName
1
)
;
var
possibleDesc
=
obj
[
keyName
]
;
var
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
if
(
desc
&
&
desc
.
willWatch
)
{
desc
.
willWatch
(
obj
keyName
)
;
}
if
(
'
function
'
=
=
=
typeof
obj
.
willWatchProperty
)
{
obj
.
willWatchProperty
(
keyName
)
;
}
handleMandatorySetter
(
m
obj
keyName
)
;
}
else
{
m
.
writeWatching
(
keyName
(
m
.
peekWatching
(
keyName
)
|
|
0
)
+
1
)
;
}
}
handleMandatorySetter
=
function
handleMandatorySetter
(
m
obj
keyName
)
{
var
descriptor
=
_emberMetalUtils
.
lookupDescriptor
(
obj
keyName
)
;
var
configurable
=
descriptor
?
descriptor
.
configurable
:
true
;
var
isWritable
=
descriptor
?
descriptor
.
writable
:
true
;
var
hasValue
=
descriptor
?
'
value
'
in
descriptor
:
true
;
var
possibleDesc
=
descriptor
&
&
descriptor
.
value
;
var
isDescriptor
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
;
if
(
isDescriptor
)
{
return
;
}
if
(
configurable
&
&
isWritable
&
&
hasValue
&
&
keyName
in
obj
)
{
var
desc
=
{
configurable
:
true
enumerable
:
Object
.
prototype
.
propertyIsEnumerable
.
call
(
obj
keyName
)
set
:
_emberMetalProperties
.
MANDATORY_SETTER_FUNCTION
(
keyName
)
get
:
undefined
}
;
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
keyName
)
)
{
m
.
writeValues
(
keyName
obj
[
keyName
]
)
;
desc
.
get
=
_emberMetalProperties
.
DEFAULT_GETTER_FUNCTION
(
keyName
)
;
}
else
{
desc
.
get
=
_emberMetalProperties
.
INHERITING_GETTER_FUNCTION
(
keyName
)
;
}
Object
.
defineProperty
(
obj
keyName
desc
)
;
}
}
;
function
unwatchKey
(
obj
keyName
meta
)
{
var
m
=
meta
|
|
_emberMetalMeta
.
meta
(
obj
)
;
var
count
=
m
.
peekWatching
(
keyName
)
;
if
(
count
=
=
=
1
)
{
m
.
writeWatching
(
keyName
0
)
;
var
possibleDesc
=
obj
[
keyName
]
;
var
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
if
(
desc
&
&
desc
.
didUnwatch
)
{
desc
.
didUnwatch
(
obj
keyName
)
;
}
if
(
'
function
'
=
=
=
typeof
obj
.
didUnwatchProperty
)
{
obj
.
didUnwatchProperty
(
keyName
)
;
}
if
(
!
desc
&
&
keyName
in
obj
)
{
var
maybeMandatoryDescriptor
=
_emberMetalUtils
.
lookupDescriptor
(
obj
keyName
)
;
if
(
maybeMandatoryDescriptor
.
set
&
&
maybeMandatoryDescriptor
.
set
.
isMandatorySetter
)
{
if
(
maybeMandatoryDescriptor
.
get
&
&
maybeMandatoryDescriptor
.
get
.
isInheritingGetter
)
{
delete
obj
[
keyName
]
;
}
else
{
Object
.
defineProperty
(
obj
keyName
{
configurable
:
true
enumerable
:
Object
.
prototype
.
propertyIsEnumerable
.
call
(
obj
keyName
)
writable
:
true
value
:
m
.
peekValues
(
keyName
)
}
)
;
m
.
deleteFromValues
(
keyName
)
;
}
}
}
}
else
if
(
count
>
1
)
{
m
.
writeWatching
(
keyName
count
-
1
)
;
}
}
}
)
;
enifed
(
'
ember
-
metal
/
watch_path
'
[
'
exports
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
chains
'
]
function
(
exports
_emberMetalMeta
_emberMetalChains
)
{
'
use
strict
'
;
exports
.
watchPath
=
watchPath
;
exports
.
unwatchPath
=
unwatchPath
;
function
chainsFor
(
obj
meta
)
{
return
(
meta
|
|
_emberMetalMeta
.
meta
(
obj
)
)
.
writableChains
(
makeChainNode
)
;
}
function
makeChainNode
(
obj
)
{
return
new
_emberMetalChains
.
ChainNode
(
null
null
obj
)
;
}
function
watchPath
(
obj
keyPath
meta
)
{
if
(
keyPath
=
=
=
'
length
'
&
&
Array
.
isArray
(
obj
)
)
{
return
;
}
var
m
=
meta
|
|
_emberMetalMeta
.
meta
(
obj
)
;
var
counter
=
m
.
peekWatching
(
keyPath
)
|
|
0
;
if
(
!
counter
)
{
m
.
writeWatching
(
keyPath
1
)
;
chainsFor
(
obj
m
)
.
add
(
keyPath
)
;
}
else
{
m
.
writeWatching
(
keyPath
counter
+
1
)
;
}
}
function
unwatchPath
(
obj
keyPath
meta
)
{
var
m
=
meta
|
|
_emberMetalMeta
.
meta
(
obj
)
;
var
counter
=
m
.
peekWatching
(
keyPath
)
|
|
0
;
if
(
counter
=
=
=
1
)
{
m
.
writeWatching
(
keyPath
0
)
;
chainsFor
(
obj
m
)
.
remove
(
keyPath
)
;
}
else
if
(
counter
>
1
)
{
m
.
writeWatching
(
keyPath
counter
-
1
)
;
}
}
}
)
;
enifed
(
'
ember
-
metal
/
watching
'
[
'
exports
'
'
ember
-
metal
/
chains
'
'
ember
-
metal
/
watch_key
'
'
ember
-
metal
/
watch_path
'
'
ember
-
metal
/
path_cache
'
'
ember
-
metal
/
meta
'
]
function
(
exports
_emberMetalChains
_emberMetalWatch_key
_emberMetalWatch_path
_emberMetalPath_cache
_emberMetalMeta
)
{
'
use
strict
'
;
exports
.
isWatching
=
isWatching
;
exports
.
watcherCount
=
watcherCount
;
exports
.
unwatch
=
unwatch
;
exports
.
destroy
=
destroy
;
function
watch
(
obj
_keyPath
m
)
{
if
(
_keyPath
=
=
=
'
length
'
&
&
Array
.
isArray
(
obj
)
)
{
return
;
}
if
(
!
_emberMetalPath_cache
.
isPath
(
_keyPath
)
)
{
_emberMetalWatch_key
.
watchKey
(
obj
_keyPath
m
)
;
}
else
{
_emberMetalWatch_path
.
watchPath
(
obj
_keyPath
m
)
;
}
}
exports
.
watch
=
watch
;
function
isWatching
(
obj
key
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
return
(
meta
&
&
meta
.
peekWatching
(
key
)
)
>
0
;
}
function
watcherCount
(
obj
key
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
return
meta
&
&
meta
.
peekWatching
(
key
)
|
|
0
;
}
function
unwatch
(
obj
_keyPath
m
)
{
if
(
_keyPath
=
=
=
'
length
'
&
&
Array
.
isArray
(
obj
)
)
{
return
;
}
if
(
!
_emberMetalPath_cache
.
isPath
(
_keyPath
)
)
{
_emberMetalWatch_key
.
unwatchKey
(
obj
_keyPath
m
)
;
}
else
{
_emberMetalWatch_path
.
unwatchPath
(
obj
_keyPath
m
)
;
}
}
var
NODE_STACK
=
[
]
;
function
destroy
(
obj
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
var
node
nodes
key
nodeObject
;
if
(
meta
)
{
_emberMetalMeta
.
deleteMeta
(
obj
)
;
node
=
meta
.
readableChains
(
)
;
if
(
node
)
{
NODE_STACK
.
push
(
node
)
;
while
(
NODE_STACK
.
length
>
0
)
{
node
=
NODE_STACK
.
pop
(
)
;
nodes
=
node
.
_chains
;
if
(
nodes
)
{
for
(
key
in
nodes
)
{
if
(
nodes
[
key
]
!
=
=
undefined
)
{
NODE_STACK
.
push
(
nodes
[
key
]
)
;
}
}
}
if
(
node
.
_watching
)
{
nodeObject
=
node
.
_object
;
if
(
nodeObject
)
{
_emberMetalChains
.
removeChainWatcher
(
nodeObject
node
.
_key
node
)
;
}
}
}
}
}
}
}
)
;
enifed
(
'
ember
-
metal
/
weak_map
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
]
function
(
exports
_emberMetalDebug
_emberMetalUtils
_emberMetalMeta
)
{
'
use
strict
'
;
exports
.
default
=
WeakMap
;
var
id
=
0
;
function
UNDEFINED
(
)
{
}
function
WeakMap
(
)
{
_emberMetalDebug
.
assert
(
'
Invoking
the
WeakMap
constructor
with
arguments
is
not
supported
at
this
time
'
arguments
.
length
=
=
=
0
)
;
this
.
_id
=
_emberMetalUtils
.
GUID_KEY
+
id
+
+
;
}
WeakMap
.
prototype
.
get
=
function
(
obj
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
meta
)
{
var
map
=
meta
.
readableWeak
(
)
;
if
(
map
)
{
if
(
map
[
this
.
_id
]
=
=
=
UNDEFINED
)
{
return
undefined
;
}
return
map
[
this
.
_id
]
;
}
}
}
;
WeakMap
.
prototype
.
set
=
function
(
obj
value
)
{
_emberMetalDebug
.
assert
(
'
Uncaught
TypeError
:
Invalid
value
used
as
weak
map
key
'
obj
&
&
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
)
;
if
(
value
=
=
=
undefined
)
{
value
=
UNDEFINED
;
}
_emberMetalMeta
.
meta
(
obj
)
.
writableWeak
(
)
[
this
.
_id
]
=
value
;
return
this
;
}
;
WeakMap
.
prototype
.
has
=
function
(
obj
)
{
var
meta
=
_emberMetalMeta
.
peekMeta
(
obj
)
;
if
(
meta
)
{
var
map
=
meta
.
readableWeak
(
)
;
if
(
map
)
{
return
map
[
this
.
_id
]
!
=
=
undefined
;
}
}
return
false
;
}
;
WeakMap
.
prototype
.
delete
=
function
(
obj
)
{
if
(
this
.
has
(
obj
)
)
{
delete
_emberMetalMeta
.
meta
(
obj
)
.
writableWeak
(
)
[
this
.
_id
]
;
return
true
;
}
else
{
return
false
;
}
}
;
}
)
;
enifed
(
'
ember
-
routing
-
htmlbars
/
helpers
/
query
-
params
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
routing
/
system
/
query_params
'
]
function
(
exports
_emberMetalDebug
_emberRoutingSystemQuery_params
)
{
'
use
strict
'
;
exports
.
queryParamsHelper
=
queryParamsHelper
;
function
queryParamsHelper
(
params
hash
)
{
_emberMetalDebug
.
assert
(
'
The
query
-
params
helper
only
accepts
hash
parameters
e
.
g
.
(
query
-
params
queryParamPropertyName
=
\
'
foo
\
'
)
as
opposed
to
just
(
query
-
params
\
'
foo
\
'
)
'
params
.
length
=
=
=
0
)
;
return
_emberRoutingSystemQuery_params
.
default
.
create
(
{
values
:
hash
}
)
;
}
}
)
;
enifed
(
'
ember
-
routing
-
htmlbars
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
htmlbars
/
helpers
'
'
ember
-
htmlbars
/
keywords
'
'
ember
-
routing
-
htmlbars
/
helpers
/
query
-
params
'
'
ember
-
routing
-
htmlbars
/
keywords
/
action
'
'
ember
-
routing
-
htmlbars
/
keywords
/
element
-
action
'
'
ember
-
routing
-
htmlbars
/
keywords
/
render
'
]
function
(
exports
_emberMetalCore
_emberHtmlbarsHelpers
_emberHtmlbarsKeywords
_emberRoutingHtmlbarsHelpersQueryParams
_emberRoutingHtmlbarsKeywordsAction
_emberRoutingHtmlbarsKeywordsElementAction
_emberRoutingHtmlbarsKeywordsRender
)
{
'
use
strict
'
;
_emberHtmlbarsHelpers
.
registerHelper
(
'
query
-
params
'
_emberRoutingHtmlbarsHelpersQueryParams
.
queryParamsHelper
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
action
'
_emberRoutingHtmlbarsKeywordsAction
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
element_action
'
_emberRoutingHtmlbarsKeywordsElementAction
.
default
)
;
_emberHtmlbarsKeywords
.
registerKeyword
(
'
render
'
_emberRoutingHtmlbarsKeywordsRender
.
default
)
;
exports
.
default
=
_emberMetalCore
.
default
;
}
)
;
enifed
(
'
ember
-
routing
-
htmlbars
/
keywords
/
action
'
[
'
exports
'
'
htmlbars
-
runtime
/
hooks
'
'
ember
-
routing
-
htmlbars
/
keywords
/
closure
-
action
'
]
function
(
exports
_htmlbarsRuntimeHooks
_emberRoutingHtmlbarsKeywordsClosureAction
)
{
'
use
strict
'
;
exports
.
default
=
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
if
(
morph
)
{
_htmlbarsRuntimeHooks
.
keyword
(
'
element_action
'
morph
env
scope
params
hash
template
inverse
visitor
)
;
return
true
;
}
return
_emberRoutingHtmlbarsKeywordsClosureAction
.
default
(
morph
env
scope
params
hash
template
inverse
visitor
)
;
}
;
}
)
;
enifed
(
'
ember
-
routing
-
htmlbars
/
keywords
/
closure
-
action
'
[
'
exports
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
metal
/
symbol
'
'
ember
-
metal
/
property_get
'
'
ember
-
htmlbars
/
hooks
/
subexpr
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
instrumentation
'
'
ember
-
metal
/
is_none
'
]
function
(
exports
_emberMetalStreamsStream
_emberMetalStreamsUtils
_emberMetalSymbol
_emberMetalProperty_get
_emberHtmlbarsHooksSubexpr
_emberMetalError
_emberMetalRun_loop
_emberMetalInstrumentation
_emberMetalIs_none
)
{
'
use
strict
'
;
exports
.
default
=
closureAction
;
var
INVOKE
=
_emberMetalSymbol
.
default
(
'
INVOKE
'
)
;
exports
.
INVOKE
=
INVOKE
;
var
ACTION
=
_emberMetalSymbol
.
default
(
'
ACTION
'
)
;
exports
.
ACTION
=
ACTION
;
function
closureAction
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
var
s
=
new
_emberMetalStreamsStream
.
Stream
(
function
(
)
{
var
rawAction
=
params
[
0
]
;
var
actionArguments
=
_emberMetalStreamsUtils
.
readArray
(
params
.
slice
(
1
params
.
length
)
)
;
var
target
=
undefined
action
=
undefined
valuePath
=
undefined
;
if
(
_emberMetalIs_none
.
default
(
rawAction
)
)
{
var
label
=
_emberHtmlbarsHooksSubexpr
.
labelForSubexpr
(
params
hash
'
action
'
)
;
throw
new
_emberMetalError
.
default
(
'
Action
passed
is
null
or
undefined
in
'
+
label
+
'
from
'
+
_emberMetalStreamsUtils
.
read
(
scope
.
getSelf
(
)
)
+
'
.
'
)
;
}
else
if
(
rawAction
[
INVOKE
]
)
{
target
=
rawAction
;
action
=
rawAction
[
INVOKE
]
;
}
else
{
target
=
_emberMetalStreamsUtils
.
read
(
scope
.
getSelf
(
)
)
;
action
=
_emberMetalStreamsUtils
.
read
(
rawAction
)
;
var
actionType
=
typeof
action
;
if
(
actionType
=
=
=
'
string
'
)
{
var
actionName
=
action
;
action
=
null
;
if
(
hash
.
target
)
{
target
=
_emberMetalStreamsUtils
.
read
(
hash
.
target
)
;
}
if
(
target
.
actions
)
{
action
=
target
.
actions
[
actionName
]
;
}
if
(
!
action
)
{
throw
new
_emberMetalError
.
default
(
'
An
action
named
\
'
'
+
actionName
+
'
\
'
was
not
found
in
'
+
target
+
'
.
'
)
;
}
}
else
if
(
action
&
&
typeof
action
[
INVOKE
]
=
=
=
'
function
'
)
{
target
=
action
;
action
=
action
[
INVOKE
]
;
}
else
if
(
actionType
!
=
=
'
function
'
)
{
throw
new
_emberMetalError
.
default
(
'
An
action
could
not
be
made
for
'
+
rawAction
.
label
+
'
in
'
+
target
+
'
.
Please
confirm
that
you
are
using
either
a
quoted
action
name
(
i
.
e
.
(
action
\
'
'
+
rawAction
.
label
+
'
\
'
)
)
or
a
function
available
in
'
+
target
+
'
.
'
)
;
}
}
if
(
hash
.
value
)
{
valuePath
=
_emberMetalStreamsUtils
.
read
(
hash
.
value
)
;
}
return
createClosureAction
(
this
target
action
valuePath
actionArguments
)
;
}
function
(
)
{
return
_emberHtmlbarsHooksSubexpr
.
labelForSubexpr
(
params
hash
'
action
'
)
;
}
)
;
params
.
forEach
(
s
.
addDependency
s
)
;
Object
.
keys
(
hash
)
.
forEach
(
function
(
item
)
{
return
s
.
addDependency
(
item
)
;
}
)
;
return
s
;
}
function
createClosureAction
(
stream
target
action
valuePath
actionArguments
)
{
var
closureAction
;
if
(
actionArguments
.
length
>
0
)
{
closureAction
=
function
(
)
{
var
args
=
actionArguments
;
for
(
var
_len
=
arguments
.
length
passedArguments
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
passedArguments
[
_key
]
=
arguments
[
_key
]
;
}
if
(
passedArguments
.
length
>
0
)
{
args
=
actionArguments
.
concat
(
passedArguments
)
;
}
if
(
valuePath
&
&
args
.
length
>
0
)
{
args
[
0
]
=
_emberMetalProperty_get
.
get
(
args
[
0
]
valuePath
)
;
}
var
payload
=
{
target
:
target
args
:
args
label
:
_emberMetalStreamsUtils
.
labelFor
(
stream
)
}
;
return
_emberMetalInstrumentation
.
flaggedInstrument
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
return
_emberMetalRun_loop
.
default
.
join
.
apply
(
_emberMetalRun_loop
.
default
[
target
action
]
.
concat
(
args
)
)
;
}
)
;
}
;
}
else
{
closureAction
=
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
if
(
valuePath
&
&
args
.
length
>
0
)
{
args
[
0
]
=
_emberMetalProperty_get
.
get
(
args
[
0
]
valuePath
)
;
}
var
payload
=
{
target
:
target
args
:
args
label
:
_emberMetalStreamsUtils
.
labelFor
(
stream
)
}
;
return
_emberMetalInstrumentation
.
flaggedInstrument
(
'
interaction
.
ember
-
action
'
payload
function
(
)
{
return
_emberMetalRun_loop
.
default
.
join
.
apply
(
_emberMetalRun_loop
.
default
[
target
action
]
.
concat
(
args
)
)
;
}
)
;
}
;
}
closureAction
[
ACTION
]
=
true
;
return
closureAction
;
}
}
)
;
enifed
(
'
ember
-
routing
-
htmlbars
/
keywords
/
element
-
action
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
metal
/
run_loop
'
'
ember
-
views
/
streams
/
utils
'
'
ember
-
views
/
system
/
utils
'
'
ember
-
views
/
system
/
action_manager
'
]
function
(
exports
_emberMetalDebug
_emberMetalUtils
_emberMetalStreamsUtils
_emberMetalRun_loop
_emberViewsStreamsUtils
_emberViewsSystemUtils
_emberViewsSystemAction_manager
)
{
'
use
strict
'
;
exports
.
default
=
{
setupState
:
function
(
state
env
scope
params
hash
)
{
var
getStream
=
env
.
hooks
.
get
;
var
read
=
env
.
hooks
.
getValue
;
var
actionName
=
read
(
params
[
0
]
)
;
_emberMetalDebug
.
assert
(
'
You
specified
a
quoteless
path
to
the
{
{
action
}
}
helper
'
+
'
which
did
not
resolve
to
an
action
name
(
a
string
)
.
'
+
'
Perhaps
you
meant
to
use
a
quoted
actionName
?
(
e
.
g
.
{
{
action
\
'
save
\
'
}
}
)
.
'
typeof
actionName
=
=
=
'
string
'
|
|
typeof
actionName
=
=
=
'
function
'
)
;
var
actionArgs
=
[
]
;
for
(
var
i
=
1
l
=
params
.
length
;
i
<
l
;
i
+
+
)
{
actionArgs
.
push
(
_emberViewsStreamsUtils
.
readUnwrappedModel
(
params
[
i
]
)
)
;
}
var
target
;
if
(
hash
.
target
)
{
if
(
typeof
hash
.
target
=
=
=
'
string
'
)
{
target
=
read
(
getStream
(
env
scope
hash
.
target
)
)
;
}
else
{
target
=
read
(
hash
.
target
)
;
}
}
else
{
target
=
read
(
scope
.
getLocal
(
'
controller
'
)
)
|
|
read
(
scope
.
getSelf
(
)
)
;
}
return
{
actionName
:
actionName
actionArgs
:
actionArgs
target
:
target
}
;
}
isStable
:
function
(
state
env
scope
params
hash
)
{
return
true
;
}
render
:
function
(
node
env
scope
params
hash
template
inverse
visitor
)
{
var
actionId
=
env
.
dom
.
getAttribute
(
node
.
element
'
data
-
ember
-
action
'
)
|
|
_emberMetalUtils
.
uuid
(
)
;
ActionHelper
.
registerAction
(
{
actionId
:
actionId
node
:
node
eventName
:
hash
.
on
|
|
'
click
'
bubbles
:
hash
.
bubbles
preventDefault
:
hash
.
preventDefault
withKeyCode
:
hash
.
withKeyCode
allowedKeys
:
hash
.
allowedKeys
}
)
;
node
.
cleanup
=
function
(
)
{
ActionHelper
.
unregisterAction
(
actionId
)
;
}
;
env
.
dom
.
setAttribute
(
node
.
element
'
data
-
ember
-
action
'
actionId
)
;
}
}
;
var
ActionHelper
=
{
}
;
exports
.
ActionHelper
=
ActionHelper
;
ActionHelper
.
registeredActions
=
_emberViewsSystemAction_manager
.
default
.
registeredActions
;
ActionHelper
.
registerAction
=
function
(
_ref
)
{
var
actionId
=
_ref
.
actionId
;
var
node
=
_ref
.
node
;
var
eventName
=
_ref
.
eventName
;
var
preventDefault
=
_ref
.
preventDefault
;
var
bubbles
=
_ref
.
bubbles
;
var
allowedKeys
=
_ref
.
allowedKeys
;
var
actions
=
_emberViewsSystemAction_manager
.
default
.
registeredActions
[
actionId
]
;
if
(
!
actions
)
{
actions
=
_emberViewsSystemAction_manager
.
default
.
registeredActions
[
actionId
]
=
[
]
;
}
actions
.
push
(
{
eventName
:
eventName
handler
:
function
(
event
)
{
if
(
!
isAllowedEvent
(
event
_emberMetalStreamsUtils
.
read
(
allowedKeys
)
)
)
{
return
true
;
}
if
(
_emberMetalStreamsUtils
.
read
(
preventDefault
)
!
=
=
false
)
{
event
.
preventDefault
(
)
;
}
if
(
_emberMetalStreamsUtils
.
read
(
bubbles
)
=
=
=
false
)
{
event
.
stopPropagation
(
)
;
}
var
_node
getState
=
node
.
getState
(
)
;
var
target
=
_node
getState
.
target
;
var
actionName
=
_node
getState
.
actionName
;
var
actionArgs
=
_node
getState
.
actionArgs
;
_emberMetalRun_loop
.
default
(
function
runRegisteredAction
(
)
{
if
(
typeof
actionName
=
=
=
'
function
'
)
{
actionName
.
apply
(
target
actionArgs
)
;
return
;
}
if
(
target
.
send
)
{
target
.
send
.
apply
(
target
[
actionName
]
.
concat
(
actionArgs
)
)
;
}
else
{
_emberMetalDebug
.
assert
(
'
The
action
\
'
'
+
actionName
+
'
\
'
did
not
exist
on
'
+
target
typeof
target
[
actionName
]
=
=
=
'
function
'
)
;
target
[
actionName
]
.
apply
(
target
actionArgs
)
;
}
}
)
;
}
}
)
;
return
actionId
;
}
;
ActionHelper
.
unregisterAction
=
function
(
actionId
)
{
delete
_emberViewsSystemAction_manager
.
default
.
registeredActions
[
actionId
]
;
}
;
var
MODIFIERS
=
[
'
alt
'
'
shift
'
'
meta
'
'
ctrl
'
]
;
var
POINTER_EVENT_TYPE_REGEX
=
/
^
click
|
mouse
|
touch
/
;
function
isAllowedEvent
(
event
allowedKeys
)
{
if
(
typeof
allowedKeys
=
=
=
'
undefined
'
)
{
if
(
POINTER_EVENT_TYPE_REGEX
.
test
(
event
.
type
)
)
{
return
_emberViewsSystemUtils
.
isSimpleClick
(
event
)
;
}
else
{
allowedKeys
=
'
'
;
}
}
if
(
allowedKeys
.
indexOf
(
'
any
'
)
>
=
0
)
{
return
true
;
}
for
(
var
i
=
0
l
=
MODIFIERS
.
length
;
i
<
l
;
i
+
+
)
{
if
(
event
[
MODIFIERS
[
i
]
+
'
Key
'
]
&
&
allowedKeys
.
indexOf
(
MODIFIERS
[
i
]
)
=
=
=
-
1
)
{
return
false
;
}
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
routing
-
htmlbars
/
keywords
/
render
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
routing
/
system
/
generate_controller
'
'
ember
-
htmlbars
/
node
-
managers
/
view
-
node
-
manager
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalEmpty_object
_emberMetalError
_emberMetalStreamsUtils
_emberRuntimeSystemString
_emberRoutingSystemGenerate_controller
_emberHtmlbarsNodeManagersViewNodeManager
)
{
'
use
strict
'
;
exports
.
default
=
{
willRender
:
function
(
renderNode
env
)
{
if
(
env
.
view
.
ownerView
.
_outlets
)
{
env
.
view
.
ownerView
.
_outlets
.
push
(
renderNode
)
;
}
}
setupState
:
function
(
prevState
env
scope
params
hash
)
{
var
name
=
params
[
0
]
;
_emberMetalDebug
.
assert
(
'
The
first
argument
of
{
{
render
}
}
must
be
quoted
e
.
g
.
{
{
render
"
sidebar
"
}
}
.
'
typeof
name
=
=
=
'
string
'
)
;
return
{
parentView
:
env
.
view
manager
:
prevState
.
manager
controller
:
prevState
.
controller
childOutletState
:
childOutletState
(
name
env
)
}
;
}
childEnv
:
function
(
state
env
)
{
return
env
.
childWithOutletState
(
state
.
childOutletState
)
;
}
isStable
:
function
(
lastState
nextState
)
{
return
isStable
(
lastState
.
childOutletState
nextState
.
childOutletState
)
;
}
isEmpty
:
function
(
state
)
{
return
false
;
}
render
:
function
(
node
env
scope
params
hash
template
inverse
visitor
)
{
var
state
=
node
.
getState
(
)
;
var
name
=
params
[
0
]
;
var
context
=
params
[
1
]
;
var
owner
=
env
.
owner
;
var
router
=
owner
.
lookup
(
'
router
:
main
'
)
;
_emberMetalDebug
.
assert
(
'
The
second
argument
of
{
{
render
}
}
must
be
a
path
e
.
g
.
{
{
render
"
post
"
post
}
}
.
'
params
.
length
<
2
|
|
_emberMetalStreamsUtils
.
isStream
(
params
[
1
]
)
)
;
if
(
params
.
length
=
=
=
1
)
{
_emberMetalDebug
.
assert
(
'
You
can
only
use
the
{
{
render
}
}
helper
once
without
a
model
object
as
'
+
'
its
second
argument
as
in
{
{
render
"
post
"
post
}
}
.
'
!
router
|
|
!
router
.
_lookupActiveComponentNode
(
name
)
)
;
}
else
if
(
params
.
length
!
=
=
2
)
{
throw
new
_emberMetalError
.
default
(
'
You
must
pass
a
templateName
to
render
'
)
;
}
var
templateName
=
'
template
:
'
+
name
;
_emberMetalDebug
.
assert
(
'
You
used
{
{
render
\
'
'
+
name
+
'
\
'
}
}
but
\
'
'
+
name
+
'
\
'
can
not
be
'
+
'
found
as
either
a
template
or
a
view
.
'
owner
.
hasRegistration
(
'
view
:
'
+
name
)
|
|
owner
.
hasRegistration
(
templateName
)
|
|
!
!
template
)
;
var
view
=
owner
.
lookup
(
'
view
:
'
+
name
)
;
if
(
!
view
)
{
view
=
owner
.
lookup
(
'
view
:
default
'
)
;
}
var
viewHasTemplateSpecified
=
view
&
&
!
!
_emberMetalProperty_get
.
get
(
view
'
template
'
)
;
if
(
!
template
&
&
!
viewHasTemplateSpecified
)
{
template
=
owner
.
lookup
(
templateName
)
;
}
if
(
view
)
{
view
.
ownerView
=
env
.
view
.
ownerView
;
}
var
controllerName
;
var
controllerFullName
;
if
(
hash
.
controller
)
{
controllerName
=
hash
.
controller
;
controllerFullName
=
'
controller
:
'
+
controllerName
;
delete
hash
.
controller
;
_emberMetalDebug
.
assert
(
'
The
controller
name
you
supplied
\
'
'
+
controllerName
+
'
\
'
'
+
'
did
not
resolve
to
a
controller
.
'
owner
.
hasRegistration
(
controllerFullName
)
)
;
}
else
{
controllerName
=
name
;
controllerFullName
=
'
controller
:
'
+
controllerName
;
}
var
target
=
router
;
var
controller
;
if
(
params
.
length
>
1
)
{
var
factory
=
owner
.
_lookupFactory
(
controllerFullName
)
|
|
_emberRoutingSystemGenerate_controller
.
generateControllerFactory
(
owner
controllerName
)
;
controller
=
factory
.
create
(
{
model
:
_emberMetalStreamsUtils
.
read
(
context
)
target
:
target
}
)
;
node
.
addDestruction
(
controller
)
;
}
else
{
controller
=
owner
.
lookup
(
controllerFullName
)
|
|
_emberRoutingSystemGenerate_controller
.
default
(
owner
controllerName
)
;
controller
.
setProperties
(
{
target
:
target
}
)
;
}
if
(
view
)
{
view
.
set
(
'
controller
'
controller
)
;
}
state
.
controller
=
controller
;
hash
.
viewName
=
_emberRuntimeSystemString
.
camelize
(
name
)
;
if
(
template
&
&
template
.
raw
)
{
template
=
template
.
raw
;
}
var
options
=
{
layout
:
null
self
:
controller
}
;
if
(
view
)
{
options
.
component
=
view
;
}
var
nodeManager
=
_emberHtmlbarsNodeManagersViewNodeManager
.
default
.
create
(
node
env
hash
options
state
.
parentView
null
null
template
)
;
state
.
manager
=
nodeManager
;
if
(
router
&
&
params
.
length
=
=
=
1
)
{
router
.
_connectActiveComponentNode
(
name
nodeManager
)
;
}
nodeManager
.
render
(
env
hash
visitor
)
;
}
rerender
:
function
(
node
env
scope
params
hash
template
inverse
visitor
)
{
if
(
params
.
length
>
1
)
{
var
model
=
_emberMetalStreamsUtils
.
read
(
params
[
1
]
)
;
node
.
getState
(
)
.
controller
.
set
(
'
model
'
model
)
;
}
}
}
;
function
childOutletState
(
name
env
)
{
var
topLevel
=
env
.
view
.
ownerView
;
if
(
!
topLevel
|
|
!
topLevel
.
outletState
)
{
return
;
}
var
outletState
=
topLevel
.
outletState
;
if
(
!
outletState
.
main
)
{
return
;
}
var
selectedOutletState
=
outletState
.
main
.
outlets
[
'
__ember_orphans__
'
]
;
if
(
!
selectedOutletState
)
{
return
;
}
var
matched
=
selectedOutletState
.
outlets
[
name
]
;
if
(
matched
)
{
var
childState
=
new
_emberMetalEmpty_object
.
default
(
)
;
childState
[
matched
.
render
.
outlet
]
=
matched
;
matched
.
wasUsed
=
true
;
return
childState
;
}
}
function
isStable
(
a
b
)
{
if
(
!
a
&
&
!
b
)
{
return
true
;
}
if
(
!
a
|
|
!
b
)
{
return
false
;
}
for
(
var
outletName
in
a
)
{
if
(
!
isStableOutlet
(
a
[
outletName
]
b
[
outletName
]
)
)
{
return
false
;
}
}
return
true
;
}
function
isStableOutlet
(
a
b
)
{
if
(
!
a
&
&
!
b
)
{
return
true
;
}
if
(
!
a
|
|
!
b
)
{
return
false
;
}
a
=
a
.
render
;
b
=
b
.
render
;
for
(
var
key
in
a
)
{
if
(
a
.
hasOwnProperty
(
key
)
)
{
if
(
a
[
key
]
!
=
=
b
[
key
]
&
&
key
!
=
=
'
name
'
)
{
return
false
;
}
}
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
routing
-
views
/
components
/
link
-
to
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
computed_macros
'
'
ember
-
views
/
system
/
utils
'
'
ember
-
views
/
components
/
component
'
'
ember
-
runtime
/
inject
'
'
ember
-
runtime
/
system
/
service
'
'
ember
-
runtime
/
mixins
/
controller
'
'
ember
-
htmlbars
/
node
-
managers
/
component
-
node
-
manager
'
'
ember
-
htmlbars
/
templates
/
link
-
to
'
'
require
'
]
function
(
exports
_emberMetalFeatures
_emberMetalLogger
_emberMetalDebug
_emberMetalProperty_get
_emberMetalComputed
_emberMetalComputed_macros
_emberViewsSystemUtils
_emberViewsComponentsComponent
_emberRuntimeInject
_emberRuntimeSystemService
_emberRuntimeMixinsController
_emberHtmlbarsNodeManagersComponentNodeManager
_emberHtmlbarsTemplatesLinkTo
_require
)
{
'
use
strict
'
;
var
layout
=
_emberHtmlbarsTemplatesLinkTo
.
default
;
var
LinkComponent
=
_emberViewsComponentsComponent
.
default
.
extend
(
{
layout
:
layout
tagName
:
'
a
'
currentWhen
:
_emberMetalComputed_macros
.
deprecatingAlias
(
'
current
-
when
'
{
id
:
'
ember
-
routing
-
view
.
deprecated
-
current
-
when
'
until
:
'
3
.
0
.
0
'
}
)
'
current
-
when
'
:
null
title
:
null
rel
:
null
tabindex
:
null
target
:
null
activeClass
:
'
active
'
loadingClass
:
'
loading
'
disabledClass
:
'
disabled
'
_isDisabled
:
false
replace
:
false
attributeBindings
:
[
'
href
'
'
title
'
'
rel
'
'
tabindex
'
'
target
'
]
classNameBindings
:
[
'
active
'
'
loading
'
'
disabled
'
'
transitioningIn
'
'
transitioningOut
'
]
eventName
:
'
click
'
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
eventName
=
_emberMetalProperty_get
.
get
(
this
'
eventName
'
)
;
this
.
on
(
eventName
this
this
.
_invoke
)
;
}
_routing
:
_emberRuntimeInject
.
default
.
service
(
'
-
routing
'
)
disabled
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
key
value
)
{
return
false
;
}
set
:
function
(
key
value
)
{
if
(
value
!
=
=
undefined
)
{
this
.
set
(
'
_isDisabled
'
value
)
;
}
return
value
?
_emberMetalProperty_get
.
get
(
this
'
disabledClass
'
)
:
false
;
}
}
)
_computeActive
:
function
(
routerState
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
loading
'
)
)
{
return
false
;
}
var
routing
=
_emberMetalProperty_get
.
get
(
this
'
_routing
'
)
;
var
models
=
_emberMetalProperty_get
.
get
(
this
'
models
'
)
;
var
resolvedQueryParams
=
_emberMetalProperty_get
.
get
(
this
'
resolvedQueryParams
'
)
;
var
currentWhen
=
_emberMetalProperty_get
.
get
(
this
'
current
-
when
'
)
;
var
isCurrentWhenSpecified
=
!
!
currentWhen
;
currentWhen
=
currentWhen
|
|
_emberMetalProperty_get
.
get
(
this
'
qualifiedRouteName
'
)
;
currentWhen
=
currentWhen
.
split
(
'
'
)
;
for
(
var
i
=
0
len
=
currentWhen
.
length
;
i
<
len
;
i
+
+
)
{
if
(
routing
.
isActiveForRoute
(
models
resolvedQueryParams
currentWhen
[
i
]
routerState
isCurrentWhenSpecified
)
)
{
return
_emberMetalProperty_get
.
get
(
this
'
activeClass
'
)
;
}
}
return
false
;
}
active
:
_emberMetalComputed
.
computed
(
'
attrs
.
params
'
'
_routing
.
currentState
'
function
computeLinkToComponentActive
(
)
{
var
currentState
=
_emberMetalProperty_get
.
get
(
this
'
_routing
.
currentState
'
)
;
if
(
!
currentState
)
{
return
false
;
}
return
this
.
_computeActive
(
currentState
)
;
}
)
willBeActive
:
_emberMetalComputed
.
computed
(
'
_routing
.
targetState
'
function
computeLinkToComponentWillBeActive
(
)
{
var
routing
=
_emberMetalProperty_get
.
get
(
this
'
_routing
'
)
;
var
targetState
=
_emberMetalProperty_get
.
get
(
routing
'
targetState
'
)
;
if
(
_emberMetalProperty_get
.
get
(
routing
'
currentState
'
)
=
=
=
targetState
)
{
return
;
}
return
!
!
this
.
_computeActive
(
targetState
)
;
}
)
transitioningIn
:
_emberMetalComputed
.
computed
(
'
active
'
'
willBeActive
'
function
computeLinkToComponentTransitioningIn
(
)
{
var
willBeActive
=
_emberMetalProperty_get
.
get
(
this
'
willBeActive
'
)
;
if
(
typeof
willBeActive
=
=
=
'
undefined
'
)
{
return
false
;
}
return
!
_emberMetalProperty_get
.
get
(
this
'
active
'
)
&
&
willBeActive
&
&
'
ember
-
transitioning
-
in
'
;
}
)
transitioningOut
:
_emberMetalComputed
.
computed
(
'
active
'
'
willBeActive
'
function
computeLinkToComponentTransitioningOut
(
)
{
var
willBeActive
=
_emberMetalProperty_get
.
get
(
this
'
willBeActive
'
)
;
if
(
typeof
willBeActive
=
=
=
'
undefined
'
)
{
return
false
;
}
return
_emberMetalProperty_get
.
get
(
this
'
active
'
)
&
&
!
willBeActive
&
&
'
ember
-
transitioning
-
out
'
;
}
)
_invoke
:
function
(
event
)
{
if
(
!
_emberViewsSystemUtils
.
isSimpleClick
(
event
)
)
{
return
true
;
}
var
preventDefault
=
_emberMetalProperty_get
.
get
(
this
'
preventDefault
'
)
;
var
targetAttribute
=
_emberMetalProperty_get
.
get
(
this
'
target
'
)
;
if
(
preventDefault
!
=
=
false
)
{
if
(
!
targetAttribute
|
|
targetAttribute
=
=
=
'
_self
'
)
{
event
.
preventDefault
(
)
;
}
}
if
(
_emberMetalProperty_get
.
get
(
this
'
bubbles
'
)
=
=
=
false
)
{
event
.
stopPropagation
(
)
;
}
if
(
_emberMetalProperty_get
.
get
(
this
'
_isDisabled
'
)
)
{
return
false
;
}
if
(
_emberMetalProperty_get
.
get
(
this
'
loading
'
)
)
{
_emberMetalLogger
.
default
.
warn
(
'
This
link
-
to
is
in
an
inactive
loading
state
because
at
least
one
of
its
parameters
presently
has
a
null
/
undefined
value
or
the
provided
route
name
is
invalid
.
'
)
;
return
false
;
}
if
(
targetAttribute
&
&
targetAttribute
!
=
=
'
_self
'
)
{
return
false
;
}
var
routing
=
_emberMetalProperty_get
.
get
(
this
'
_routing
'
)
;
var
qualifiedRouteName
=
_emberMetalProperty_get
.
get
(
this
'
qualifiedRouteName
'
)
;
var
models
=
_emberMetalProperty_get
.
get
(
this
'
models
'
)
;
var
queryParamValues
=
_emberMetalProperty_get
.
get
(
this
'
queryParams
.
values
'
)
;
var
shouldReplace
=
_emberMetalProperty_get
.
get
(
this
'
replace
'
)
;
routing
.
transitionTo
(
qualifiedRouteName
models
queryParamValues
shouldReplace
)
;
}
queryParams
:
null
qualifiedRouteName
:
_emberMetalComputed
.
computed
(
'
targetRouteName
'
'
_routing
.
currentState
'
function
computeLinkToComponentQualifiedRouteName
(
)
{
var
params
=
_emberMetalProperty_get
.
get
(
this
'
params
'
)
.
slice
(
)
;
var
lastParam
=
params
[
params
.
length
-
1
]
;
if
(
lastParam
&
&
lastParam
.
isQueryParams
)
{
params
.
pop
(
)
;
}
var
onlyQueryParamsSupplied
=
this
[
_emberHtmlbarsNodeManagersComponentNodeManager
.
HAS_BLOCK
]
?
params
.
length
=
=
=
0
:
params
.
length
=
=
=
1
;
if
(
onlyQueryParamsSupplied
)
{
return
_emberMetalProperty_get
.
get
(
this
'
_routing
.
currentRouteName
'
)
;
}
return
_emberMetalProperty_get
.
get
(
this
'
targetRouteName
'
)
;
}
)
resolvedQueryParams
:
_emberMetalComputed
.
computed
(
'
queryParams
'
function
computeLinkToComponentResolvedQueryParams
(
)
{
var
resolvedQueryParams
=
{
}
;
var
queryParams
=
_emberMetalProperty_get
.
get
(
this
'
queryParams
'
)
;
if
(
!
queryParams
)
{
return
resolvedQueryParams
;
}
var
values
=
queryParams
.
values
;
for
(
var
key
in
values
)
{
if
(
!
values
.
hasOwnProperty
(
key
)
)
{
continue
;
}
resolvedQueryParams
[
key
]
=
values
[
key
]
;
}
return
resolvedQueryParams
;
}
)
href
:
_emberMetalComputed
.
computed
(
'
models
'
'
qualifiedRouteName
'
function
computeLinkToComponentHref
(
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
tagName
'
)
!
=
=
'
a
'
)
{
return
;
}
var
qualifiedRouteName
=
_emberMetalProperty_get
.
get
(
this
'
qualifiedRouteName
'
)
;
var
models
=
_emberMetalProperty_get
.
get
(
this
'
models
'
)
;
if
(
_emberMetalProperty_get
.
get
(
this
'
loading
'
)
)
{
return
_emberMetalProperty_get
.
get
(
this
'
loadingHref
'
)
;
}
var
routing
=
_emberMetalProperty_get
.
get
(
this
'
_routing
'
)
;
var
queryParams
=
_emberMetalProperty_get
.
get
(
this
'
queryParams
.
values
'
)
;
return
routing
.
generateURL
(
qualifiedRouteName
models
queryParams
)
;
}
)
loading
:
_emberMetalComputed
.
computed
(
'
_modelsAreLoaded
'
'
qualifiedRouteName
'
function
computeLinkToComponentLoading
(
)
{
var
qualifiedRouteName
=
_emberMetalProperty_get
.
get
(
this
'
qualifiedRouteName
'
)
;
var
modelsAreLoaded
=
_emberMetalProperty_get
.
get
(
this
'
_modelsAreLoaded
'
)
;
if
(
!
modelsAreLoaded
|
|
qualifiedRouteName
=
=
null
)
{
return
_emberMetalProperty_get
.
get
(
this
'
loadingClass
'
)
;
}
}
)
_modelsAreLoaded
:
_emberMetalComputed
.
computed
(
'
models
'
function
computeLinkToComponentModelsAreLoaded
(
)
{
var
models
=
_emberMetalProperty_get
.
get
(
this
'
models
'
)
;
for
(
var
i
=
0
l
=
models
.
length
;
i
<
l
;
i
+
+
)
{
if
(
models
[
i
]
=
=
null
)
{
return
false
;
}
}
return
true
;
}
)
_getModels
:
function
(
params
)
{
var
modelCount
=
params
.
length
-
1
;
var
models
=
new
Array
(
modelCount
)
;
for
(
var
i
=
0
;
i
<
modelCount
;
i
+
+
)
{
var
value
=
params
[
i
+
1
]
;
while
(
_emberRuntimeMixinsController
.
default
.
detect
(
value
)
)
{
_emberMetalDebug
.
deprecate
(
'
Providing
{
{
link
-
to
}
}
with
a
param
that
is
wrapped
in
a
controller
is
deprecated
.
'
+
(
this
.
parentView
?
'
Please
update
'
+
this
.
parentView
+
'
to
use
{
{
link
-
to
"
post
"
someController
.
model
}
}
instead
.
'
:
'
'
)
false
{
id
:
'
ember
-
routing
-
views
.
controller
-
wrapped
-
param
'
until
:
'
3
.
0
.
0
'
}
)
;
value
=
value
.
get
(
'
model
'
)
;
}
models
[
i
]
=
value
;
}
return
models
;
}
loadingHref
:
'
#
'
willRender
:
function
(
)
{
var
queryParams
=
undefined
;
var
params
=
_emberMetalProperty_get
.
get
(
this
'
params
'
)
.
slice
(
)
;
_emberMetalDebug
.
assert
(
'
You
must
provide
one
or
more
parameters
to
the
link
-
to
component
.
'
params
.
length
)
;
var
disabledWhen
=
_emberMetalProperty_get
.
get
(
this
'
disabledWhen
'
)
;
if
(
disabledWhen
!
=
=
undefined
)
{
this
.
set
(
'
disabled
'
disabledWhen
)
;
}
if
(
!
this
[
_emberHtmlbarsNodeManagersComponentNodeManager
.
HAS_BLOCK
]
)
{
this
.
set
(
'
linkTitle
'
params
.
shift
(
)
)
;
}
this
.
set
(
'
targetRouteName
'
params
[
0
]
)
;
var
lastParam
=
params
[
params
.
length
-
1
]
;
if
(
lastParam
&
&
lastParam
.
isQueryParams
)
{
queryParams
=
params
.
pop
(
)
;
}
else
{
queryParams
=
{
}
;
}
this
.
set
(
'
queryParams
'
queryParams
)
;
if
(
params
.
length
>
1
)
{
this
.
set
(
'
models
'
this
.
_getModels
(
params
)
)
;
}
else
{
this
.
set
(
'
models
'
[
]
)
;
}
}
}
)
;
LinkComponent
.
toString
=
function
(
)
{
return
'
LinkComponent
'
;
}
;
LinkComponent
.
reopenClass
(
{
positionalParams
:
'
params
'
}
)
;
exports
.
default
=
LinkComponent
;
}
)
;
enifed
(
'
ember
-
routing
-
views
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
routing
-
views
/
components
/
link
-
to
'
'
ember
-
routing
-
views
/
views
/
outlet
'
]
function
(
exports
_emberMetalCore
_emberRoutingViewsComponentsLinkTo
_emberRoutingViewsViewsOutlet
)
{
'
use
strict
'
;
_emberMetalCore
.
default
.
LinkComponent
=
_emberRoutingViewsComponentsLinkTo
.
default
;
_emberMetalCore
.
default
.
OutletView
=
_emberRoutingViewsViewsOutlet
.
OutletView
;
exports
.
default
=
_emberMetalCore
.
default
;
}
)
;
enifed
(
'
ember
-
routing
-
views
/
views
/
outlet
'
[
'
exports
'
'
ember
-
views
/
views
/
view
'
'
ember
-
htmlbars
/
templates
/
top
-
level
-
view
'
]
function
(
exports
_emberViewsViewsView
_emberHtmlbarsTemplatesTopLevelView
)
{
'
use
strict
'
;
var
CoreOutletView
=
_emberViewsViewsView
.
default
.
extend
(
{
defaultTemplate
:
_emberHtmlbarsTemplatesTopLevelView
.
default
init
:
function
(
)
{
this
.
_super
(
)
;
this
.
_outlets
=
[
]
;
}
setOutletState
:
function
(
state
)
{
this
.
outletState
=
{
main
:
state
}
;
if
(
this
.
env
)
{
this
.
env
.
outletState
=
this
.
outletState
;
}
if
(
this
.
lastResult
)
{
this
.
dirtyOutlets
(
)
;
this
.
_outlets
=
[
]
;
this
.
scheduleRevalidate
(
null
null
)
;
}
}
dirtyOutlets
:
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
_outlets
.
length
;
i
+
+
)
{
this
.
_outlets
[
i
]
.
isDirty
=
true
;
}
}
}
)
;
exports
.
CoreOutletView
=
CoreOutletView
;
var
OutletView
=
CoreOutletView
.
extend
(
{
tagName
:
'
'
}
)
;
exports
.
OutletView
=
OutletView
;
}
)
;
enifed
(
'
ember
-
routing
/
ext
/
controller
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
runtime
/
mixins
/
controller
'
]
function
(
exports
_emberMetalProperty_get
_emberRuntimeMixinsController
)
{
'
use
strict
'
;
_emberRuntimeMixinsController
.
default
.
reopen
(
{
concatenatedProperties
:
[
'
queryParams
'
]
queryParams
:
null
_qpDelegate
:
null
_qpChanged
:
function
(
controller
_prop
)
{
var
prop
=
_prop
.
substr
(
0
_prop
.
length
-
3
)
;
var
delegate
=
controller
.
_qpDelegate
;
var
value
=
_emberMetalProperty_get
.
get
(
controller
prop
)
;
delegate
(
prop
value
)
;
}
transitionToRoute
:
function
(
)
{
var
target
=
_emberMetalProperty_get
.
get
(
this
'
target
'
)
;
var
method
=
target
.
transitionToRoute
|
|
target
.
transitionTo
;
return
method
.
apply
(
target
arguments
)
;
}
replaceRoute
:
function
(
)
{
var
target
=
_emberMetalProperty_get
.
get
(
this
'
target
'
)
;
var
method
=
target
.
replaceRoute
|
|
target
.
replaceWith
;
return
method
.
apply
(
target
arguments
)
;
}
}
)
;
exports
.
default
=
_emberRuntimeMixinsController
.
default
;
}
)
;
enifed
(
'
ember
-
routing
/
ext
/
run_loop
'
[
'
exports
'
'
ember
-
metal
/
run_loop
'
]
function
(
exports
_emberMetalRun_loop
)
{
'
use
strict
'
;
_emberMetalRun_loop
.
default
.
_addQueue
(
'
routerTransitions
'
'
actions
'
)
;
}
)
;
enifed
(
'
ember
-
routing
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
routing
/
ext
/
run_loop
'
'
ember
-
routing
/
ext
/
controller
'
'
ember
-
routing
/
location
/
api
'
'
ember
-
routing
/
location
/
none_location
'
'
ember
-
routing
/
location
/
hash_location
'
'
ember
-
routing
/
location
/
history_location
'
'
ember
-
routing
/
location
/
auto_location
'
'
ember
-
routing
/
system
/
generate_controller
'
'
ember
-
routing
/
system
/
controller_for
'
'
ember
-
routing
/
system
/
dsl
'
'
ember
-
routing
/
system
/
router
'
'
ember
-
routing
/
system
/
route
'
]
function
(
exports
_emberMetalCore
_emberRoutingExtRun_loop
_emberRoutingExtController
_emberRoutingLocationApi
_emberRoutingLocationNone_location
_emberRoutingLocationHash_location
_emberRoutingLocationHistory_location
_emberRoutingLocationAuto_location
_emberRoutingSystemGenerate_controller
_emberRoutingSystemController_for
_emberRoutingSystemDsl
_emberRoutingSystemRouter
_emberRoutingSystemRoute
)
{
'
use
strict
'
;
_emberMetalCore
.
default
.
Location
=
_emberRoutingLocationApi
.
default
;
_emberMetalCore
.
default
.
AutoLocation
=
_emberRoutingLocationAuto_location
.
default
;
_emberMetalCore
.
default
.
HashLocation
=
_emberRoutingLocationHash_location
.
default
;
_emberMetalCore
.
default
.
HistoryLocation
=
_emberRoutingLocationHistory_location
.
default
;
_emberMetalCore
.
default
.
NoneLocation
=
_emberRoutingLocationNone_location
.
default
;
_emberMetalCore
.
default
.
controllerFor
=
_emberRoutingSystemController_for
.
default
;
_emberMetalCore
.
default
.
generateControllerFactory
=
_emberRoutingSystemGenerate_controller
.
generateControllerFactory
;
_emberMetalCore
.
default
.
generateController
=
_emberRoutingSystemGenerate_controller
.
default
;
_emberMetalCore
.
default
.
RouterDSL
=
_emberRoutingSystemDsl
.
default
;
_emberMetalCore
.
default
.
Router
=
_emberRoutingSystemRouter
.
default
;
_emberMetalCore
.
default
.
Route
=
_emberRoutingSystemRoute
.
default
;
exports
.
default
=
_emberMetalCore
.
default
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
api
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
environment
'
'
ember
-
routing
/
location
/
util
'
]
function
(
exports
_emberMetalDebug
_emberMetalEnvironment
_emberRoutingLocationUtil
)
{
'
use
strict
'
;
exports
.
default
=
{
create
:
function
(
options
)
{
var
implementation
=
options
&
&
options
.
implementation
;
_emberMetalDebug
.
assert
(
'
Ember
.
Location
.
create
:
you
must
specify
a
\
'
implementation
\
'
option
'
!
!
implementation
)
;
var
implementationClass
=
this
.
implementations
[
implementation
]
;
_emberMetalDebug
.
assert
(
'
Ember
.
Location
.
create
:
'
+
implementation
+
'
is
not
a
valid
implementation
'
!
!
implementationClass
)
;
return
implementationClass
.
create
.
apply
(
implementationClass
arguments
)
;
}
implementations
:
{
}
_location
:
_emberMetalEnvironment
.
default
.
location
_getHash
:
function
(
)
{
return
_emberRoutingLocationUtil
.
getHash
(
this
.
location
)
;
}
}
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
auto_location
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
utils
'
'
container
/
owner
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
metal
/
environment
'
'
ember
-
routing
/
location
/
util
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalUtils
_containerOwner
_emberRuntimeSystemObject
_emberMetalEnvironment
_emberRoutingLocationUtil
)
{
'
use
strict
'
;
exports
.
getHistoryPath
=
getHistoryPath
;
exports
.
getHashPath
=
getHashPath
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
location
:
_emberMetalEnvironment
.
default
.
location
history
:
_emberMetalEnvironment
.
default
.
history
global
:
_emberMetalEnvironment
.
default
.
global
userAgent
:
_emberMetalEnvironment
.
default
.
userAgent
cancelRouterSetup
:
false
rootURL
:
'
/
'
detect
:
function
(
)
{
var
rootURL
=
this
.
rootURL
;
_emberMetalDebug
.
assert
(
'
rootURL
must
end
with
a
trailing
forward
slash
e
.
g
.
"
/
app
/
"
'
rootURL
.
charAt
(
rootURL
.
length
-
1
)
=
=
=
'
/
'
)
;
var
implementation
=
detectImplementation
(
{
location
:
this
.
location
history
:
this
.
history
userAgent
:
this
.
userAgent
rootURL
:
rootURL
documentMode
:
this
.
documentMode
global
:
this
.
global
}
)
;
if
(
implementation
=
=
=
false
)
{
_emberMetalProperty_set
.
set
(
this
'
cancelRouterSetup
'
true
)
;
implementation
=
'
none
'
;
}
var
concrete
=
_containerOwner
.
getOwner
(
this
)
.
lookup
(
'
location
:
'
+
implementation
)
;
_emberMetalProperty_set
.
set
(
concrete
'
rootURL
'
rootURL
)
;
_emberMetalDebug
.
assert
(
'
Could
not
find
location
\
'
'
+
implementation
+
'
\
'
.
'
!
!
concrete
)
;
_emberMetalProperty_set
.
set
(
this
'
concreteImplementation
'
concrete
)
;
}
initState
:
delegateToConcreteImplementation
(
'
initState
'
)
getURL
:
delegateToConcreteImplementation
(
'
getURL
'
)
setURL
:
delegateToConcreteImplementation
(
'
setURL
'
)
replaceURL
:
delegateToConcreteImplementation
(
'
replaceURL
'
)
onUpdateURL
:
delegateToConcreteImplementation
(
'
onUpdateURL
'
)
formatURL
:
delegateToConcreteImplementation
(
'
formatURL
'
)
willDestroy
:
function
(
)
{
var
concreteImplementation
=
_emberMetalProperty_get
.
get
(
this
'
concreteImplementation
'
)
;
if
(
concreteImplementation
)
{
concreteImplementation
.
destroy
(
)
;
}
}
}
)
;
function
delegateToConcreteImplementation
(
methodName
)
{
return
function
(
)
{
var
concreteImplementation
=
_emberMetalProperty_get
.
get
(
this
'
concreteImplementation
'
)
;
_emberMetalDebug
.
assert
(
'
AutoLocation
\
'
s
detect
(
)
method
should
be
called
before
calling
any
other
hooks
.
'
!
!
concreteImplementation
)
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
_emberMetalUtils
.
tryInvoke
(
concreteImplementation
methodName
args
)
;
}
;
}
function
detectImplementation
(
options
)
{
var
location
=
options
.
location
;
var
userAgent
=
options
.
userAgent
;
var
history
=
options
.
history
;
var
documentMode
=
options
.
documentMode
;
var
global
=
options
.
global
;
var
rootURL
=
options
.
rootURL
;
var
implementation
=
'
none
'
;
var
cancelRouterSetup
=
false
;
var
currentPath
=
_emberRoutingLocationUtil
.
getFullPath
(
location
)
;
if
(
_emberRoutingLocationUtil
.
supportsHistory
(
userAgent
history
)
)
{
var
historyPath
=
getHistoryPath
(
rootURL
location
)
;
if
(
currentPath
=
=
=
historyPath
)
{
return
'
history
'
;
}
else
{
if
(
currentPath
.
substr
(
0
2
)
=
=
=
'
/
#
'
)
{
history
.
replaceState
(
{
path
:
historyPath
}
null
historyPath
)
;
implementation
=
'
history
'
;
}
else
{
cancelRouterSetup
=
true
;
_emberRoutingLocationUtil
.
replacePath
(
location
historyPath
)
;
}
}
}
else
if
(
_emberRoutingLocationUtil
.
supportsHashChange
(
documentMode
global
)
)
{
var
hashPath
=
getHashPath
(
rootURL
location
)
;
if
(
currentPath
=
=
=
hashPath
|
|
currentPath
=
=
=
'
/
'
&
&
hashPath
=
=
=
'
/
#
/
'
)
{
implementation
=
'
hash
'
;
}
else
{
cancelRouterSetup
=
true
;
_emberRoutingLocationUtil
.
replacePath
(
location
hashPath
)
;
}
}
if
(
cancelRouterSetup
)
{
return
false
;
}
return
implementation
;
}
function
getHistoryPath
(
rootURL
location
)
{
var
path
=
_emberRoutingLocationUtil
.
getPath
(
location
)
;
var
hash
=
_emberRoutingLocationUtil
.
getHash
(
location
)
;
var
query
=
_emberRoutingLocationUtil
.
getQuery
(
location
)
;
var
rootURLIndex
=
path
.
indexOf
(
rootURL
)
;
var
routeHash
hashParts
;
_emberMetalDebug
.
assert
(
'
Path
'
+
path
+
'
does
not
start
with
the
provided
rootURL
'
+
rootURL
rootURLIndex
=
=
=
0
)
;
if
(
hash
.
substr
(
0
2
)
=
=
=
'
#
/
'
)
{
hashParts
=
hash
.
substr
(
1
)
.
split
(
'
#
'
)
;
routeHash
=
hashParts
.
shift
(
)
;
if
(
path
.
slice
(
-
1
)
=
=
=
'
/
'
)
{
routeHash
=
routeHash
.
substr
(
1
)
;
}
path
=
path
+
routeHash
+
query
;
if
(
hashParts
.
length
)
{
path
+
=
'
#
'
+
hashParts
.
join
(
'
#
'
)
;
}
}
else
{
path
=
path
+
query
+
hash
;
}
return
path
;
}
function
getHashPath
(
rootURL
location
)
{
var
path
=
rootURL
;
var
historyPath
=
getHistoryPath
(
rootURL
location
)
;
var
routePath
=
historyPath
.
substr
(
rootURL
.
length
)
;
if
(
routePath
!
=
=
'
'
)
{
if
(
routePath
.
charAt
(
0
)
!
=
=
'
/
'
)
{
routePath
=
'
/
'
+
routePath
;
}
path
+
=
'
#
'
+
routePath
;
}
return
path
;
}
}
)
;
enifed
(
'
ember
-
routing
/
location
/
hash_location
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
utils
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
routing
/
location
/
api
'
'
ember
-
views
/
system
/
jquery
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalRun_loop
_emberMetalUtils
_emberRuntimeSystemObject
_emberRoutingLocationApi
_emberViewsSystemJquery
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
implementation
:
'
hash
'
init
:
function
(
)
{
_emberMetalProperty_set
.
set
(
this
'
location
'
_emberMetalProperty_get
.
get
(
this
'
_location
'
)
|
|
window
.
location
)
;
}
getHash
:
_emberRoutingLocationApi
.
default
.
_getHash
getURL
:
function
(
)
{
var
originalPath
=
this
.
getHash
(
)
.
substr
(
1
)
;
var
outPath
=
originalPath
;
if
(
outPath
.
charAt
(
0
)
!
=
=
'
/
'
)
{
outPath
=
'
/
'
;
if
(
originalPath
)
{
outPath
+
=
'
#
'
+
originalPath
;
}
}
return
outPath
;
}
setURL
:
function
(
path
)
{
_emberMetalProperty_get
.
get
(
this
'
location
'
)
.
hash
=
path
;
_emberMetalProperty_set
.
set
(
this
'
lastSetURL
'
path
)
;
}
replaceURL
:
function
(
path
)
{
_emberMetalProperty_get
.
get
(
this
'
location
'
)
.
replace
(
'
#
'
+
path
)
;
_emberMetalProperty_set
.
set
(
this
'
lastSetURL
'
path
)
;
}
onUpdateURL
:
function
(
callback
)
{
var
_this
=
this
;
var
guid
=
_emberMetalUtils
.
guidFor
(
this
)
;
_emberViewsSystemJquery
.
default
(
window
)
.
on
(
'
hashchange
.
ember
-
location
-
'
+
guid
function
(
)
{
_emberMetalRun_loop
.
default
(
function
(
)
{
var
path
=
_this
.
getURL
(
)
;
if
(
_emberMetalProperty_get
.
get
(
_this
'
lastSetURL
'
)
=
=
=
path
)
{
return
;
}
_emberMetalProperty_set
.
set
(
_this
'
lastSetURL
'
null
)
;
callback
(
path
)
;
}
)
;
}
)
;
}
formatURL
:
function
(
url
)
{
return
'
#
'
+
url
;
}
willDestroy
:
function
(
)
{
var
guid
=
_emberMetalUtils
.
guidFor
(
this
)
;
_emberViewsSystemJquery
.
default
(
window
)
.
off
(
'
hashchange
.
ember
-
location
-
'
+
guid
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
history_location
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
utils
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
routing
/
location
/
api
'
'
ember
-
views
/
system
/
jquery
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalUtils
_emberRuntimeSystemObject
_emberRoutingLocationApi
_emberViewsSystemJquery
)
{
'
use
strict
'
;
var
popstateFired
=
false
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
implementation
:
'
history
'
init
:
function
(
)
{
_emberMetalProperty_set
.
set
(
this
'
location
'
_emberMetalProperty_get
.
get
(
this
'
location
'
)
|
|
window
.
location
)
;
_emberMetalProperty_set
.
set
(
this
'
baseURL
'
_emberViewsSystemJquery
.
default
(
'
base
'
)
.
attr
(
'
href
'
)
|
|
'
'
)
;
}
initState
:
function
(
)
{
var
history
=
_emberMetalProperty_get
.
get
(
this
'
history
'
)
|
|
window
.
history
;
_emberMetalProperty_set
.
set
(
this
'
history
'
history
)
;
if
(
history
&
&
'
state
'
in
history
)
{
this
.
supportsHistory
=
true
;
}
this
.
replaceState
(
this
.
formatURL
(
this
.
getURL
(
)
)
)
;
}
rootURL
:
'
/
'
getURL
:
function
(
)
{
var
location
=
_emberMetalProperty_get
.
get
(
this
'
location
'
)
;
var
path
=
location
.
pathname
;
var
rootURL
=
_emberMetalProperty_get
.
get
(
this
'
rootURL
'
)
;
var
baseURL
=
_emberMetalProperty_get
.
get
(
this
'
baseURL
'
)
;
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
baseURL
=
baseURL
.
replace
(
/
\
/
/
'
'
)
;
var
url
=
path
.
replace
(
new
RegExp
(
'
^
'
+
baseURL
+
'
(
?
=
/
|
)
'
)
'
'
)
.
replace
(
new
RegExp
(
'
^
'
+
rootURL
+
'
(
?
=
/
|
)
'
)
'
'
)
;
var
search
=
location
.
search
|
|
'
'
;
url
+
=
search
;
url
+
=
this
.
getHash
(
)
;
return
url
;
}
setURL
:
function
(
path
)
{
var
state
=
this
.
getState
(
)
;
path
=
this
.
formatURL
(
path
)
;
if
(
!
state
|
|
state
.
path
!
=
=
path
)
{
this
.
pushState
(
path
)
;
}
}
replaceURL
:
function
(
path
)
{
var
state
=
this
.
getState
(
)
;
path
=
this
.
formatURL
(
path
)
;
if
(
!
state
|
|
state
.
path
!
=
=
path
)
{
this
.
replaceState
(
path
)
;
}
}
getState
:
function
(
)
{
if
(
this
.
supportsHistory
)
{
return
_emberMetalProperty_get
.
get
(
this
'
history
'
)
.
state
;
}
return
this
.
_historyState
;
}
pushState
:
function
(
path
)
{
var
state
=
{
path
:
path
}
;
_emberMetalProperty_get
.
get
(
this
'
history
'
)
.
pushState
(
state
null
path
)
;
this
.
_historyState
=
state
;
this
.
_previousURL
=
this
.
getURL
(
)
;
}
replaceState
:
function
(
path
)
{
var
state
=
{
path
:
path
}
;
_emberMetalProperty_get
.
get
(
this
'
history
'
)
.
replaceState
(
state
null
path
)
;
this
.
_historyState
=
state
;
this
.
_previousURL
=
this
.
getURL
(
)
;
}
onUpdateURL
:
function
(
callback
)
{
var
_this
=
this
;
var
guid
=
_emberMetalUtils
.
guidFor
(
this
)
;
_emberViewsSystemJquery
.
default
(
window
)
.
on
(
'
popstate
.
ember
-
location
-
'
+
guid
function
(
e
)
{
if
(
!
popstateFired
)
{
popstateFired
=
true
;
if
(
_this
.
getURL
(
)
=
=
=
_this
.
_previousURL
)
{
return
;
}
}
callback
(
_this
.
getURL
(
)
)
;
}
)
;
}
formatURL
:
function
(
url
)
{
var
rootURL
=
_emberMetalProperty_get
.
get
(
this
'
rootURL
'
)
;
var
baseURL
=
_emberMetalProperty_get
.
get
(
this
'
baseURL
'
)
;
if
(
url
!
=
=
'
'
)
{
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
baseURL
=
baseURL
.
replace
(
/
\
/
/
'
'
)
;
}
else
if
(
baseURL
.
match
(
/
^
\
/
/
)
&
&
rootURL
.
match
(
/
^
\
/
/
)
)
{
baseURL
=
baseURL
.
replace
(
/
\
/
/
'
'
)
;
}
return
baseURL
+
rootURL
+
url
;
}
willDestroy
:
function
(
)
{
var
guid
=
_emberMetalUtils
.
guidFor
(
this
)
;
_emberViewsSystemJquery
.
default
(
window
)
.
off
(
'
popstate
.
ember
-
location
-
'
+
guid
)
;
}
getHash
:
_emberRoutingLocationApi
.
default
.
_getHash
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
none_location
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
implementation
:
'
none
'
path
:
'
'
detect
:
function
(
)
{
var
rootURL
=
this
.
rootURL
;
_emberMetalDebug
.
assert
(
'
rootURL
must
end
with
a
trailing
forward
slash
e
.
g
.
"
/
app
/
"
'
rootURL
.
charAt
(
rootURL
.
length
-
1
)
=
=
=
'
/
'
)
;
}
rootURL
:
'
/
'
getURL
:
function
(
)
{
var
path
=
_emberMetalProperty_get
.
get
(
this
'
path
'
)
;
var
rootURL
=
_emberMetalProperty_get
.
get
(
this
'
rootURL
'
)
;
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
return
path
.
replace
(
new
RegExp
(
'
^
'
+
rootURL
+
'
(
?
=
/
|
)
'
)
'
'
)
;
}
setURL
:
function
(
path
)
{
_emberMetalProperty_set
.
set
(
this
'
path
'
path
)
;
}
onUpdateURL
:
function
(
callback
)
{
this
.
updateCallback
=
callback
;
}
handleURL
:
function
(
url
)
{
_emberMetalProperty_set
.
set
(
this
'
path
'
url
)
;
this
.
updateCallback
(
url
)
;
}
formatURL
:
function
(
url
)
{
var
rootURL
=
_emberMetalProperty_get
.
get
(
this
'
rootURL
'
)
;
if
(
url
!
=
=
'
'
)
{
rootURL
=
rootURL
.
replace
(
/
\
/
/
'
'
)
;
}
return
rootURL
+
url
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
location
/
util
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
getPath
=
getPath
;
exports
.
getQuery
=
getQuery
;
exports
.
getHash
=
getHash
;
exports
.
getFullPath
=
getFullPath
;
exports
.
getOrigin
=
getOrigin
;
exports
.
supportsHashChange
=
supportsHashChange
;
exports
.
supportsHistory
=
supportsHistory
;
exports
.
replacePath
=
replacePath
;
function
getPath
(
location
)
{
var
pathname
=
location
.
pathname
;
if
(
pathname
.
charAt
(
0
)
!
=
=
'
/
'
)
{
pathname
=
'
/
'
+
pathname
;
}
return
pathname
;
}
function
getQuery
(
location
)
{
return
location
.
search
;
}
function
getHash
(
location
)
{
var
href
=
location
.
href
;
var
hashIndex
=
href
.
indexOf
(
'
#
'
)
;
if
(
hashIndex
=
=
=
-
1
)
{
return
'
'
;
}
else
{
return
href
.
substr
(
hashIndex
)
;
}
}
function
getFullPath
(
location
)
{
return
getPath
(
location
)
+
getQuery
(
location
)
+
getHash
(
location
)
;
}
function
getOrigin
(
location
)
{
var
origin
=
location
.
origin
;
if
(
!
origin
)
{
origin
=
location
.
protocol
+
'
/
/
'
+
location
.
hostname
;
if
(
location
.
port
)
{
origin
+
=
'
:
'
+
location
.
port
;
}
}
return
origin
;
}
function
supportsHashChange
(
documentMode
global
)
{
return
'
onhashchange
'
in
global
&
&
(
documentMode
=
=
=
undefined
|
|
documentMode
>
7
)
;
}
function
supportsHistory
(
userAgent
history
)
{
if
(
(
userAgent
.
indexOf
(
'
Android
2
.
'
)
!
=
=
-
1
|
|
userAgent
.
indexOf
(
'
Android
4
.
0
'
)
!
=
=
-
1
)
&
&
userAgent
.
indexOf
(
'
Mobile
Safari
'
)
!
=
=
-
1
&
&
userAgent
.
indexOf
(
'
Chrome
'
)
=
=
=
-
1
&
&
userAgent
.
indexOf
(
'
Windows
Phone
'
)
=
=
=
-
1
)
{
return
false
;
}
return
!
!
(
history
&
&
'
pushState
'
in
history
)
;
}
function
replacePath
(
location
path
)
{
location
.
replace
(
getOrigin
(
location
)
+
path
)
;
}
}
)
;
enifed
(
'
ember
-
routing
/
services
/
routing
'
[
'
exports
'
'
ember
-
runtime
/
system
/
service
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
computed_macros
'
'
ember
-
routing
/
utils
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_emberRuntimeSystemService
_emberMetalProperty_get
_emberMetalComputed_macros
_emberRoutingUtils
_emberMetalAssign
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemService
.
default
.
extend
(
{
router
:
null
targetState
:
_emberMetalComputed_macros
.
readOnly
(
'
router
.
targetState
'
)
currentState
:
_emberMetalComputed_macros
.
readOnly
(
'
router
.
currentState
'
)
currentRouteName
:
_emberMetalComputed_macros
.
readOnly
(
'
router
.
currentRouteName
'
)
currentPath
:
_emberMetalComputed_macros
.
readOnly
(
'
router
.
currentPath
'
)
availableRoutes
:
function
(
)
{
return
Object
.
keys
(
_emberMetalProperty_get
.
get
(
this
'
router
'
)
.
router
.
recognizer
.
names
)
;
}
hasRoute
:
function
(
routeName
)
{
return
_emberMetalProperty_get
.
get
(
this
'
router
'
)
.
hasRoute
(
routeName
)
;
}
transitionTo
:
function
(
routeName
models
queryParams
shouldReplace
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
var
transition
=
router
.
_doTransition
(
routeName
models
queryParams
)
;
if
(
shouldReplace
)
{
transition
.
method
(
'
replace
'
)
;
}
}
normalizeQueryParams
:
function
(
routeName
models
queryParams
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
router
.
_prepareQueryParams
(
routeName
models
queryParams
)
;
}
generateURL
:
function
(
routeName
models
queryParams
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
if
(
!
router
.
router
)
{
return
;
}
var
visibleQueryParams
=
{
}
;
_emberMetalAssign
.
default
(
visibleQueryParams
queryParams
)
;
this
.
normalizeQueryParams
(
routeName
models
visibleQueryParams
)
;
var
args
=
_emberRoutingUtils
.
routeArgs
(
routeName
models
visibleQueryParams
)
;
return
router
.
generate
.
apply
(
router
args
)
;
}
isActiveForRoute
:
function
(
contexts
queryParams
routeName
routerState
isCurrentWhenSpecified
)
{
var
router
=
_emberMetalProperty_get
.
get
(
this
'
router
'
)
;
var
handlers
=
router
.
router
.
recognizer
.
handlersFor
(
routeName
)
;
var
leafName
=
handlers
[
handlers
.
length
-
1
]
.
handler
;
var
maximumContexts
=
numberOfContextsAcceptedByHandler
(
routeName
handlers
)
;
if
(
contexts
.
length
>
maximumContexts
)
{
routeName
=
leafName
;
}
return
routerState
.
isActiveIntent
(
routeName
contexts
queryParams
!
isCurrentWhenSpecified
)
;
}
}
)
;
function
numberOfContextsAcceptedByHandler
(
handler
handlerInfos
)
{
var
req
=
0
;
for
(
var
i
=
0
l
=
handlerInfos
.
length
;
i
<
l
;
i
+
+
)
{
req
=
req
+
handlerInfos
[
i
]
.
names
.
length
;
if
(
handlerInfos
[
i
]
.
handler
=
=
=
handler
)
{
break
;
}
}
return
req
;
}
}
)
;
enifed
(
'
ember
-
routing
/
system
/
cache
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
init
:
function
(
)
{
this
.
cache
=
{
}
;
}
has
:
function
(
bucketKey
)
{
return
bucketKey
in
this
.
cache
;
}
stash
:
function
(
bucketKey
key
value
)
{
var
bucket
=
this
.
cache
[
bucketKey
]
;
if
(
!
bucket
)
{
bucket
=
this
.
cache
[
bucketKey
]
=
{
}
;
}
bucket
[
key
]
=
value
;
}
lookup
:
function
(
bucketKey
prop
defaultValue
)
{
var
cache
=
this
.
cache
;
if
(
!
(
bucketKey
in
cache
)
)
{
return
defaultValue
;
}
var
bucket
=
cache
[
bucketKey
]
;
if
(
prop
in
bucket
)
{
return
bucket
[
prop
]
;
}
else
{
return
defaultValue
;
}
}
cache
:
null
}
)
;
}
)
;
enifed
(
"
ember
-
routing
/
system
/
controller_for
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
controllerFor
;
function
controllerFor
(
container
controllerName
lookupOptions
)
{
return
container
.
lookup
(
"
controller
:
"
+
controllerName
lookupOptions
)
;
}
}
)
;
enifed
(
'
ember
-
routing
/
system
/
dsl
'
[
'
exports
'
'
ember
-
metal
/
debug
'
]
function
(
exports
_emberMetalDebug
)
{
'
use
strict
'
;
function
DSL
(
name
options
)
{
this
.
parent
=
name
;
this
.
enableLoadingSubstates
=
options
&
&
options
.
enableLoadingSubstates
;
this
.
matches
=
[
]
;
this
.
explicitIndex
=
undefined
;
this
.
options
=
options
;
}
exports
.
default
=
DSL
;
DSL
.
prototype
=
{
route
:
function
(
name
options
callback
)
{
var
dummyErrorRoute
=
'
/
_unused_dummy_error_path_route_
'
+
name
+
'
/
:
error
'
;
if
(
arguments
.
length
=
=
=
2
&
&
typeof
options
=
=
=
'
function
'
)
{
callback
=
options
;
options
=
{
}
;
}
if
(
arguments
.
length
=
=
=
1
)
{
options
=
{
}
;
}
_emberMetalDebug
.
assert
(
'
\
'
'
+
name
+
'
\
'
cannot
be
used
as
a
route
name
.
'
(
function
(
)
{
if
(
options
.
overrideNameAssertion
=
=
=
true
)
{
return
true
;
}
return
[
'
array
'
'
basic
'
'
object
'
'
application
'
]
.
indexOf
(
name
)
=
=
=
-
1
;
}
)
(
)
)
;
if
(
this
.
enableLoadingSubstates
)
{
createRoute
(
this
name
+
'
_loading
'
{
resetNamespace
:
options
.
resetNamespace
}
)
;
createRoute
(
this
name
+
'
_error
'
{
path
:
dummyErrorRoute
}
)
;
}
if
(
callback
)
{
var
fullName
=
getFullName
(
this
name
options
.
resetNamespace
)
;
var
dsl
=
new
DSL
(
fullName
this
.
options
)
;
createRoute
(
dsl
'
loading
'
)
;
createRoute
(
dsl
'
error
'
{
path
:
dummyErrorRoute
}
)
;
callback
.
call
(
dsl
)
;
createRoute
(
this
name
options
dsl
.
generate
(
)
)
;
}
else
{
createRoute
(
this
name
options
)
;
}
}
push
:
function
(
url
name
callback
)
{
var
parts
=
name
.
split
(
'
.
'
)
;
if
(
url
=
=
=
'
'
|
|
url
=
=
=
'
/
'
|
|
parts
[
parts
.
length
-
1
]
=
=
=
'
index
'
)
{
this
.
explicitIndex
=
true
;
}
this
.
matches
.
push
(
[
url
name
callback
]
)
;
}
resource
:
function
(
name
options
callback
)
{
if
(
arguments
.
length
=
=
=
2
&
&
typeof
options
=
=
=
'
function
'
)
{
callback
=
options
;
options
=
{
}
;
}
if
(
arguments
.
length
=
=
=
1
)
{
options
=
{
}
;
}
options
.
resetNamespace
=
true
;
_emberMetalDebug
.
deprecate
(
'
this
.
resource
(
)
is
deprecated
.
Use
this
.
route
(
\
'
name
\
'
{
resetNamespace
:
true
}
function
(
)
{
}
)
instead
.
'
false
{
id
:
'
ember
-
routing
.
router
-
resource
'
until
:
'
3
.
0
.
0
'
}
)
;
this
.
route
(
name
options
callback
)
;
}
generate
:
function
(
)
{
var
dslMatches
=
this
.
matches
;
if
(
!
this
.
explicitIndex
)
{
this
.
route
(
'
index
'
{
path
:
'
/
'
}
)
;
}
return
function
(
match
)
{
for
(
var
i
=
0
l
=
dslMatches
.
length
;
i
<
l
;
i
+
+
)
{
var
dslMatch
=
dslMatches
[
i
]
;
match
(
dslMatch
[
0
]
)
.
to
(
dslMatch
[
1
]
dslMatch
[
2
]
)
;
}
}
;
}
}
;
function
canNest
(
dsl
)
{
return
dsl
.
parent
&
&
dsl
.
parent
!
=
=
'
application
'
;
}
function
getFullName
(
dsl
name
resetNamespace
)
{
if
(
canNest
(
dsl
)
&
&
resetNamespace
!
=
=
true
)
{
return
dsl
.
parent
+
'
.
'
+
name
;
}
else
{
return
name
;
}
}
function
createRoute
(
dsl
name
options
callback
)
{
options
=
options
|
|
{
}
;
var
fullName
=
getFullName
(
dsl
name
options
.
resetNamespace
)
;
if
(
typeof
options
.
path
!
=
=
'
string
'
)
{
options
.
path
=
'
/
'
+
name
;
}
dsl
.
push
(
options
.
path
fullName
callback
)
;
}
DSL
.
map
=
function
(
callback
)
{
var
dsl
=
new
DSL
(
)
;
callback
.
call
(
dsl
)
;
return
dsl
;
}
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
generate_controller
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
)
{
'
use
strict
'
;
exports
.
generateControllerFactory
=
generateControllerFactory
;
exports
.
default
=
generateController
;
function
generateControllerFactory
(
owner
controllerName
context
)
{
var
Factory
fullName
;
Factory
=
owner
.
_lookupFactory
(
'
controller
:
basic
'
)
.
extend
(
{
isGenerated
:
true
toString
:
function
(
)
{
return
'
(
generated
'
+
controllerName
+
'
controller
)
'
;
}
}
)
;
fullName
=
'
controller
:
'
+
controllerName
;
owner
.
register
(
fullName
Factory
)
;
return
Factory
;
}
function
generateController
(
owner
controllerName
context
)
{
generateControllerFactory
(
owner
controllerName
context
)
;
var
fullName
=
'
controller
:
'
+
controllerName
;
var
instance
=
owner
.
lookup
(
fullName
)
;
if
(
_emberMetalProperty_get
.
get
(
instance
'
namespace
.
LOG_ACTIVE_GENERATION
'
)
)
{
_emberMetalDebug
.
info
(
'
generated
-
>
'
+
fullName
{
fullName
:
fullName
}
)
;
}
return
instance
;
}
}
)
;
enifed
(
'
ember
-
routing
/
system
/
query_params
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
isQueryParams
:
true
values
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
route
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
get_properties
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
assign
'
'
ember
-
runtime
/
utils
'
'
ember
-
metal
/
run_loop
'
'
ember
-
runtime
/
copy
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
system
/
native_array
'
'
ember
-
runtime
/
mixins
/
evented
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
routing
/
system
/
generate_controller
'
'
ember
-
routing
/
utils
'
'
container
/
owner
'
'
ember
-
metal
/
is_empty
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberMetalFeatures
_emberMetalError
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalGet_properties
_emberMetalIs_none
_emberMetalComputed
_emberMetalAssign
_emberRuntimeUtils
_emberMetalRun_loop
_emberRuntimeCopy
_emberRuntimeSystemString
_emberRuntimeSystemObject
_emberRuntimeSystemNative_array
_emberRuntimeMixinsEvented
_emberRuntimeMixinsAction_handler
_emberRoutingSystemGenerate_controller
_emberRoutingUtils
_containerOwner
_emberMetalIs_empty
)
{
'
use
strict
'
;
var
slice
=
Array
.
prototype
.
slice
;
function
K
(
)
{
return
this
;
}
var
Route
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsAction_handler
.
default
_emberRuntimeMixinsEvented
.
default
{
queryParams
:
{
}
_qp
:
_emberMetalComputed
.
computed
(
function
(
)
{
var
_this
=
this
;
var
controllerProto
combinedQueryParameterConfiguration
;
var
controllerName
=
this
.
controllerName
|
|
this
.
routeName
;
var
definedControllerClass
=
_containerOwner
.
getOwner
(
this
)
.
_lookupFactory
(
'
controller
:
'
+
controllerName
)
;
var
queryParameterConfiguraton
=
_emberMetalProperty_get
.
get
(
this
'
queryParams
'
)
;
var
hasRouterDefinedQueryParams
=
!
!
Object
.
keys
(
queryParameterConfiguraton
)
.
length
;
if
(
definedControllerClass
)
{
controllerProto
=
definedControllerClass
.
proto
(
)
;
var
controllerDefinedQueryParameterConfiguration
=
_emberMetalProperty_get
.
get
(
controllerProto
'
queryParams
'
)
;
var
normalizedControllerQueryParameterConfiguration
=
_emberRoutingUtils
.
normalizeControllerQueryParams
(
controllerDefinedQueryParameterConfiguration
)
;
combinedQueryParameterConfiguration
=
mergeEachQueryParams
(
normalizedControllerQueryParameterConfiguration
queryParameterConfiguraton
)
;
}
else
if
(
hasRouterDefinedQueryParams
)
{
var
generatedControllerClass
=
_emberRoutingSystemGenerate_controller
.
generateControllerFactory
(
_containerOwner
.
getOwner
(
this
)
controllerName
)
;
controllerProto
=
generatedControllerClass
.
proto
(
)
;
combinedQueryParameterConfiguration
=
queryParameterConfiguraton
;
}
var
qps
=
[
]
;
var
map
=
{
}
;
var
propertyNames
=
[
]
;
for
(
var
propName
in
combinedQueryParameterConfiguration
)
{
if
(
!
combinedQueryParameterConfiguration
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
if
(
propName
=
=
=
'
unknownProperty
'
|
|
propName
=
=
=
'
_super
'
)
{
continue
;
}
var
desc
=
combinedQueryParameterConfiguration
[
propName
]
;
var
scope
=
desc
.
scope
|
|
'
model
'
;
var
parts
;
if
(
scope
=
=
=
'
controller
'
)
{
parts
=
[
]
;
}
var
urlKey
=
desc
.
as
|
|
this
.
serializeQueryParamKey
(
propName
)
;
var
defaultValue
=
_emberMetalProperty_get
.
get
(
controllerProto
propName
)
;
if
(
Array
.
isArray
(
defaultValue
)
)
{
defaultValue
=
_emberRuntimeSystemNative_array
.
A
(
defaultValue
.
slice
(
)
)
;
}
var
type
=
desc
.
type
|
|
_emberRuntimeUtils
.
typeOf
(
defaultValue
)
;
var
defaultValueSerialized
=
this
.
serializeQueryParam
(
defaultValue
urlKey
type
)
;
var
scopedPropertyName
=
controllerName
+
'
:
'
+
propName
;
var
qp
=
{
undecoratedDefaultValue
:
_emberMetalProperty_get
.
get
(
controllerProto
propName
)
defaultValue
:
defaultValue
serializedDefaultValue
:
defaultValueSerialized
serializedValue
:
defaultValueSerialized
type
:
type
urlKey
:
urlKey
prop
:
propName
scopedPropertyName
:
scopedPropertyName
ctrl
:
controllerName
route
:
this
parts
:
parts
values
:
null
scope
:
scope
prefix
:
'
'
}
;
map
[
propName
]
=
map
[
urlKey
]
=
map
[
scopedPropertyName
]
=
qp
;
qps
.
push
(
qp
)
;
propertyNames
.
push
(
propName
)
;
}
return
{
qps
:
qps
map
:
map
propertyNames
:
propertyNames
states
:
{
inactive
:
function
(
prop
value
)
{
var
qp
=
map
[
prop
]
;
_this
.
_qpChanged
(
prop
value
qp
)
;
}
active
:
function
(
prop
value
)
{
var
qp
=
map
[
prop
]
;
_this
.
_qpChanged
(
prop
value
qp
)
;
return
_this
.
_activeQPChanged
(
map
[
prop
]
value
)
;
}
allowOverrides
:
function
(
prop
value
)
{
var
qp
=
map
[
prop
]
;
_this
.
_qpChanged
(
prop
value
qp
)
;
return
_this
.
_updatingQPChanged
(
map
[
prop
]
)
;
}
}
}
;
}
)
_names
:
null
_stashNames
:
function
(
_handlerInfo
dynamicParent
)
{
var
handlerInfo
=
_handlerInfo
;
if
(
this
.
_names
)
{
return
;
}
var
names
=
this
.
_names
=
handlerInfo
.
_names
;
if
(
!
names
.
length
)
{
handlerInfo
=
dynamicParent
;
names
=
handlerInfo
&
&
handlerInfo
.
_names
|
|
[
]
;
}
var
qps
=
_emberMetalProperty_get
.
get
(
this
'
_qp
.
qps
'
)
;
var
len
=
qps
.
length
;
var
namePaths
=
new
Array
(
names
.
length
)
;
for
(
var
a
=
0
nlen
=
names
.
length
;
a
<
nlen
;
+
+
a
)
{
namePaths
[
a
]
=
handlerInfo
.
name
+
'
.
'
+
names
[
a
]
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
qp
=
qps
[
i
]
;
if
(
qp
.
scope
=
=
=
'
model
'
)
{
qp
.
parts
=
namePaths
;
}
qp
.
prefix
=
qp
.
ctrl
;
}
}
_activeQPChanged
:
function
(
qp
value
)
{
var
router
=
this
.
router
;
router
.
_activeQPChanged
(
qp
.
scopedPropertyName
value
)
;
}
_updatingQPChanged
:
function
(
qp
)
{
var
router
=
this
.
router
;
router
.
_updatingQPChanged
(
qp
.
urlKey
)
;
}
mergedProperties
:
[
'
queryParams
'
]
paramsFor
:
function
(
name
)
{
var
route
=
_containerOwner
.
getOwner
(
this
)
.
lookup
(
'
route
:
'
+
name
)
;
if
(
!
route
)
{
return
{
}
;
}
var
transition
=
this
.
router
.
router
.
activeTransition
;
var
state
=
transition
?
transition
.
state
:
this
.
router
.
router
.
state
;
var
params
=
{
}
;
_emberMetalAssign
.
default
(
params
state
.
params
[
name
]
)
;
_emberMetalAssign
.
default
(
params
getQueryParamsFor
(
route
state
)
)
;
return
params
;
}
serializeQueryParamKey
:
function
(
controllerPropertyName
)
{
return
controllerPropertyName
;
}
serializeQueryParam
:
function
(
value
urlKey
defaultValueType
)
{
if
(
defaultValueType
=
=
=
'
array
'
)
{
return
JSON
.
stringify
(
value
)
;
}
return
'
'
+
value
;
}
deserializeQueryParam
:
function
(
value
urlKey
defaultValueType
)
{
if
(
defaultValueType
=
=
=
'
boolean
'
)
{
return
value
=
=
=
'
true
'
?
true
:
false
;
}
else
if
(
defaultValueType
=
=
=
'
number
'
)
{
return
Number
(
value
)
.
valueOf
(
)
;
}
else
if
(
defaultValueType
=
=
=
'
array
'
)
{
return
_emberRuntimeSystemNative_array
.
A
(
JSON
.
parse
(
value
)
)
;
}
return
value
;
}
_optionsForQueryParam
:
function
(
qp
)
{
return
_emberMetalProperty_get
.
get
(
this
'
queryParams
.
'
+
qp
.
urlKey
)
|
|
_emberMetalProperty_get
.
get
(
this
'
queryParams
.
'
+
qp
.
prop
)
|
|
{
}
;
}
resetController
:
K
exit
:
function
(
)
{
this
.
deactivate
(
)
;
this
.
trigger
(
'
deactivate
'
)
;
this
.
teardownViews
(
)
;
}
_reset
:
function
(
isExiting
transition
)
{
var
controller
=
this
.
controller
;
controller
.
_qpDelegate
=
_emberMetalProperty_get
.
get
(
this
'
_qp
.
states
.
inactive
'
)
;
this
.
resetController
(
controller
isExiting
transition
)
;
}
enter
:
function
(
)
{
this
.
connections
=
[
]
;
this
.
activate
(
)
;
this
.
trigger
(
'
activate
'
)
;
}
viewName
:
null
templateName
:
null
controllerName
:
null
actions
:
{
queryParamsDidChange
:
function
(
changed
totalPresent
removed
)
{
var
qpMap
=
_emberMetalProperty_get
.
get
(
this
'
_qp
'
)
.
map
;
var
totalChanged
=
Object
.
keys
(
changed
)
.
concat
(
Object
.
keys
(
removed
)
)
;
for
(
var
i
=
0
len
=
totalChanged
.
length
;
i
<
len
;
+
+
i
)
{
var
qp
=
qpMap
[
totalChanged
[
i
]
]
;
if
(
qp
&
&
_emberMetalProperty_get
.
get
(
this
.
_optionsForQueryParam
(
qp
)
'
refreshModel
'
)
&
&
this
.
router
.
currentState
)
{
this
.
refresh
(
)
;
}
}
return
true
;
}
finalizeQueryParamChange
:
function
(
params
finalParams
transition
)
{
if
(
this
.
routeName
!
=
=
'
application
'
)
{
return
true
;
}
if
(
!
transition
)
{
return
;
}
var
handlerInfos
=
transition
.
state
.
handlerInfos
;
var
router
=
this
.
router
;
var
qpMeta
=
router
.
_queryParamsFor
(
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
)
;
var
changes
=
router
.
_qpUpdates
;
var
replaceUrl
;
_emberRoutingUtils
.
stashParamNames
(
router
handlerInfos
)
;
for
(
var
i
=
0
len
=
qpMeta
.
qps
.
length
;
i
<
len
;
+
+
i
)
{
var
qp
=
qpMeta
.
qps
[
i
]
;
var
route
=
qp
.
route
;
var
controller
=
route
.
controller
;
var
presentKey
=
qp
.
urlKey
in
params
&
&
qp
.
urlKey
;
var
value
svalue
;
if
(
changes
&
&
qp
.
urlKey
in
changes
)
{
value
=
_emberMetalProperty_get
.
get
(
controller
qp
.
prop
)
;
svalue
=
route
.
serializeQueryParam
(
value
qp
.
urlKey
qp
.
type
)
;
}
else
{
if
(
presentKey
)
{
svalue
=
params
[
presentKey
]
;
value
=
route
.
deserializeQueryParam
(
svalue
qp
.
urlKey
qp
.
type
)
;
}
else
{
svalue
=
qp
.
serializedDefaultValue
;
value
=
copyDefaultValue
(
qp
.
defaultValue
)
;
}
}
controller
.
_qpDelegate
=
_emberMetalProperty_get
.
get
(
route
'
_qp
.
states
.
inactive
'
)
;
var
thisQueryParamChanged
=
svalue
!
=
=
qp
.
serializedValue
;
if
(
thisQueryParamChanged
)
{
if
(
transition
.
queryParamsOnly
&
&
replaceUrl
!
=
=
false
)
{
var
options
=
route
.
_optionsForQueryParam
(
qp
)
;
var
replaceConfigValue
=
_emberMetalProperty_get
.
get
(
options
'
replace
'
)
;
if
(
replaceConfigValue
)
{
replaceUrl
=
true
;
}
else
if
(
replaceConfigValue
=
=
=
false
)
{
replaceUrl
=
false
;
}
}
_emberMetalProperty_set
.
set
(
controller
qp
.
prop
value
)
;
}
qp
.
serializedValue
=
svalue
;
var
thisQueryParamHasDefaultValue
=
qp
.
serializedDefaultValue
=
=
=
svalue
;
if
(
!
thisQueryParamHasDefaultValue
)
{
finalParams
.
push
(
{
value
:
svalue
visible
:
true
key
:
presentKey
|
|
qp
.
urlKey
}
)
;
}
}
if
(
replaceUrl
)
{
transition
.
method
(
'
replace
'
)
;
}
qpMeta
.
qps
.
forEach
(
function
(
qp
)
{
var
routeQpMeta
=
_emberMetalProperty_get
.
get
(
qp
.
route
'
_qp
'
)
;
var
finalizedController
=
qp
.
route
.
controller
;
finalizedController
.
_qpDelegate
=
_emberMetalProperty_get
.
get
(
routeQpMeta
'
states
.
active
'
)
;
}
)
;
router
.
_qpUpdates
=
null
;
}
}
deactivate
:
K
activate
:
K
transitionTo
:
function
(
name
context
)
{
var
router
=
this
.
router
;
return
router
.
transitionTo
.
apply
(
router
arguments
)
;
}
intermediateTransitionTo
:
function
(
)
{
var
router
=
this
.
router
;
router
.
intermediateTransitionTo
.
apply
(
router
arguments
)
;
}
refresh
:
function
(
)
{
return
this
.
router
.
router
.
refresh
(
this
)
;
}
replaceWith
:
function
(
)
{
var
router
=
this
.
router
;
return
router
.
replaceWith
.
apply
(
router
arguments
)
;
}
send
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
this
.
router
&
&
this
.
router
.
router
|
|
!
_emberMetalCore
.
default
.
testing
)
{
var
_router
;
(
_router
=
this
.
router
)
.
send
.
apply
(
_router
args
)
;
}
else
{
var
name
=
args
[
0
]
;
args
=
slice
.
call
(
args
1
)
;
var
action
=
this
.
actions
[
name
]
;
if
(
action
)
{
return
this
.
actions
[
name
]
.
apply
(
this
args
)
;
}
}
}
setup
:
function
(
context
transition
)
{
var
controller
;
var
controllerName
=
this
.
controllerName
|
|
this
.
routeName
;
var
definedController
=
this
.
controllerFor
(
controllerName
true
)
;
if
(
!
definedController
)
{
controller
=
this
.
generateController
(
controllerName
context
)
;
}
else
{
controller
=
definedController
;
}
if
(
!
this
.
controller
)
{
var
propNames
=
_emberMetalProperty_get
.
get
(
this
'
_qp
.
propertyNames
'
)
;
addQueryParamsObservers
(
controller
propNames
)
;
this
.
controller
=
controller
;
}
var
queryParams
=
_emberMetalProperty_get
.
get
(
this
'
_qp
'
)
;
var
states
=
queryParams
.
states
;
if
(
transition
)
{
_emberRoutingUtils
.
stashParamNames
(
this
.
router
transition
.
state
.
handlerInfos
)
;
var
params
=
transition
.
params
;
var
allParams
=
queryParams
.
propertyNames
;
var
cache
=
this
.
_bucketCache
;
allParams
.
forEach
(
function
(
prop
)
{
var
aQp
=
queryParams
.
map
[
prop
]
;
aQp
.
values
=
params
;
var
cacheKey
=
_emberRoutingUtils
.
calculateCacheKey
(
aQp
.
prefix
aQp
.
parts
aQp
.
values
)
;
if
(
cache
)
{
var
value
=
cache
.
lookup
(
cacheKey
prop
aQp
.
undecoratedDefaultValue
)
;
_emberMetalProperty_set
.
set
(
controller
prop
value
)
;
}
}
)
;
}
controller
.
_qpDelegate
=
states
.
allowOverrides
;
if
(
transition
)
{
var
qpValues
=
getQueryParamsFor
(
this
transition
.
state
)
;
controller
.
setProperties
(
qpValues
)
;
}
this
.
setupController
(
controller
context
transition
)
;
if
(
!
this
.
_environment
|
|
this
.
_environment
.
options
.
shouldRender
)
{
this
.
renderTemplate
(
controller
context
)
;
}
}
_qpChanged
:
function
(
prop
value
qp
)
{
if
(
!
qp
)
{
return
;
}
var
cacheKey
=
_emberRoutingUtils
.
calculateCacheKey
(
qp
.
prefix
|
|
'
'
qp
.
parts
qp
.
values
)
;
var
cache
=
this
.
_bucketCache
;
if
(
cache
)
{
cache
.
stash
(
cacheKey
prop
value
)
;
}
}
beforeModel
:
K
afterModel
:
K
redirect
:
K
contextDidChange
:
function
(
)
{
this
.
currentModel
=
this
.
context
;
}
model
:
function
(
params
transition
)
{
var
match
name
sawParams
value
;
var
queryParams
=
_emberMetalProperty_get
.
get
(
this
'
_qp
.
map
'
)
;
for
(
var
prop
in
params
)
{
if
(
prop
=
=
=
'
queryParams
'
|
|
queryParams
&
&
prop
in
queryParams
)
{
continue
;
}
if
(
match
=
prop
.
match
(
/
^
(
.
*
)
_id
/
)
)
{
name
=
match
[
1
]
;
value
=
params
[
prop
]
;
}
sawParams
=
true
;
}
if
(
!
name
&
&
sawParams
)
{
return
_emberRuntimeCopy
.
default
(
params
)
;
}
else
if
(
!
name
)
{
if
(
transition
.
resolveIndex
<
1
)
{
return
;
}
var
parentModel
=
transition
.
state
.
handlerInfos
[
transition
.
resolveIndex
-
1
]
.
context
;
return
parentModel
;
}
return
this
.
findModel
(
name
value
)
;
}
deserialize
:
function
(
params
transition
)
{
return
this
.
model
(
this
.
paramsFor
(
this
.
routeName
)
transition
)
;
}
findModel
:
function
(
)
{
var
store
=
_emberMetalProperty_get
.
get
(
this
'
store
'
)
;
return
store
.
find
.
apply
(
store
arguments
)
;
}
store
:
_emberMetalComputed
.
computed
(
function
(
)
{
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
var
routeName
=
this
.
routeName
;
var
namespace
=
_emberMetalProperty_get
.
get
(
this
'
router
.
namespace
'
)
;
return
{
find
:
function
(
name
value
)
{
var
modelClass
=
owner
.
_lookupFactory
(
'
model
:
'
+
name
)
;
_emberMetalDebug
.
assert
(
'
You
used
the
dynamic
segment
'
+
name
+
'
_id
in
your
route
'
+
routeName
+
'
but
'
+
namespace
+
'
.
'
+
_emberRuntimeSystemString
.
classify
(
name
)
+
'
did
not
exist
and
you
did
not
override
your
route
\
'
s
model
hook
.
'
!
!
modelClass
)
;
if
(
!
modelClass
)
{
return
;
}
_emberMetalDebug
.
assert
(
_emberRuntimeSystemString
.
classify
(
name
)
+
'
has
no
method
find
.
'
typeof
modelClass
.
find
=
=
=
'
function
'
)
;
return
modelClass
.
find
(
value
)
;
}
}
;
}
)
serialize
:
function
(
model
params
)
{
if
(
params
.
length
<
1
)
{
return
;
}
if
(
!
model
)
{
return
;
}
var
name
=
params
[
0
]
;
var
object
=
{
}
;
if
(
params
.
length
=
=
=
1
)
{
if
(
name
in
model
)
{
object
[
name
]
=
_emberMetalProperty_get
.
get
(
model
name
)
;
}
else
if
(
/
_id
/
.
test
(
name
)
)
{
object
[
name
]
=
_emberMetalProperty_get
.
get
(
model
'
id
'
)
;
}
}
else
{
object
=
_emberMetalGet_properties
.
default
(
model
params
)
;
}
return
object
;
}
setupController
:
function
(
controller
context
transition
)
{
if
(
controller
&
&
context
!
=
=
undefined
)
{
_emberMetalProperty_set
.
set
(
controller
'
model
'
context
)
;
}
}
controllerFor
:
function
(
name
_skipAssert
)
{
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
var
route
=
owner
.
lookup
(
'
route
:
'
+
name
)
;
var
controller
;
if
(
route
&
&
route
.
controllerName
)
{
name
=
route
.
controllerName
;
}
controller
=
owner
.
lookup
(
'
controller
:
'
+
name
)
;
_emberMetalDebug
.
assert
(
'
The
controller
named
\
'
'
+
name
+
'
\
'
could
not
be
found
.
Make
sure
that
this
route
exists
and
has
already
been
entered
at
least
once
.
If
you
are
accessing
a
controller
not
associated
with
a
route
make
sure
the
controller
class
is
explicitly
defined
.
'
controller
|
|
_skipAssert
=
=
=
true
)
;
return
controller
;
}
generateController
:
function
(
name
model
)
{
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
model
=
model
|
|
this
.
modelFor
(
name
)
;
return
_emberRoutingSystemGenerate_controller
.
default
(
owner
name
model
)
;
}
modelFor
:
function
(
name
)
{
var
route
=
_containerOwner
.
getOwner
(
this
)
.
lookup
(
'
route
:
'
+
name
)
;
var
transition
=
this
.
router
?
this
.
router
.
router
.
activeTransition
:
null
;
if
(
transition
)
{
var
modelLookupName
=
route
&
&
route
.
routeName
|
|
name
;
if
(
transition
.
resolvedModels
.
hasOwnProperty
(
modelLookupName
)
)
{
return
transition
.
resolvedModels
[
modelLookupName
]
;
}
}
return
route
&
&
route
.
currentModel
;
}
renderTemplate
:
function
(
controller
model
)
{
this
.
render
(
)
;
}
render
:
function
(
_name
options
)
{
_emberMetalDebug
.
assert
(
'
The
name
in
the
given
arguments
is
undefined
'
arguments
.
length
>
0
?
!
_emberMetalIs_none
.
default
(
arguments
[
0
]
)
:
true
)
;
var
namePassed
=
typeof
_name
=
=
=
'
string
'
&
&
!
!
_name
;
var
isDefaultRender
=
arguments
.
length
=
=
=
0
|
|
_emberMetalIs_empty
.
default
(
arguments
[
0
]
)
;
var
name
;
if
(
typeof
_name
=
=
=
'
object
'
&
&
!
options
)
{
name
=
this
.
routeName
;
options
=
_name
;
}
else
{
name
=
_name
;
}
var
renderOptions
=
buildRenderOptions
(
this
namePassed
isDefaultRender
name
options
)
;
this
.
connections
.
push
(
renderOptions
)
;
_emberMetalRun_loop
.
default
.
once
(
this
.
router
'
_setOutlets
'
)
;
}
disconnectOutlet
:
function
(
options
)
{
var
outletName
;
var
parentView
;
if
(
!
options
|
|
typeof
options
=
=
=
'
string
'
)
{
outletName
=
options
;
}
else
{
outletName
=
options
.
outlet
;
parentView
=
options
.
parentView
;
if
(
options
&
&
Object
.
keys
(
options
)
.
indexOf
(
'
outlet
'
)
!
=
=
-
1
&
&
typeof
options
.
outlet
=
=
=
'
undefined
'
)
{
throw
new
_emberMetalError
.
default
(
'
You
passed
undefined
as
the
outlet
name
.
'
)
;
}
}
parentView
=
parentView
&
&
parentView
.
replace
(
/
\
/
/
g
'
.
'
)
;
outletName
=
outletName
|
|
'
main
'
;
this
.
_disconnectOutlet
(
outletName
parentView
)
;
for
(
var
i
=
0
;
i
<
this
.
router
.
router
.
currentHandlerInfos
.
length
;
i
+
+
)
{
this
.
router
.
router
.
currentHandlerInfos
[
i
]
.
handler
.
_disconnectOutlet
(
outletName
parentView
)
;
}
}
_disconnectOutlet
:
function
(
outletName
parentView
)
{
var
parent
=
parentRoute
(
this
)
;
if
(
parent
&
&
parentView
=
=
=
parent
.
routeName
)
{
parentView
=
undefined
;
}
for
(
var
i
=
0
;
i
<
this
.
connections
.
length
;
i
+
+
)
{
var
connection
=
this
.
connections
[
i
]
;
if
(
connection
.
outlet
=
=
=
outletName
&
&
connection
.
into
=
=
=
parentView
)
{
this
.
connections
[
i
]
=
{
owner
:
connection
.
owner
into
:
connection
.
into
outlet
:
connection
.
outlet
name
:
connection
.
name
controller
:
undefined
template
:
undefined
ViewClass
:
undefined
}
;
_emberMetalRun_loop
.
default
.
once
(
this
.
router
'
_setOutlets
'
)
;
}
}
}
willDestroy
:
function
(
)
{
this
.
teardownViews
(
)
;
}
teardownViews
:
function
(
)
{
if
(
this
.
connections
&
&
this
.
connections
.
length
>
0
)
{
this
.
connections
=
[
]
;
_emberMetalRun_loop
.
default
.
once
(
this
.
router
'
_setOutlets
'
)
;
}
}
}
)
;
_emberRuntimeMixinsAction_handler
.
deprecateUnderscoreActions
(
Route
)
;
Route
.
reopenClass
(
{
isRouteFactory
:
true
}
)
;
function
parentRoute
(
route
)
{
var
handlerInfo
=
handlerInfoFor
(
route
route
.
router
.
router
.
state
.
handlerInfos
-
1
)
;
return
handlerInfo
&
&
handlerInfo
.
handler
;
}
function
handlerInfoFor
(
route
handlerInfos
_offset
)
{
if
(
!
handlerInfos
)
{
return
;
}
var
offset
=
_offset
|
|
0
;
var
current
;
for
(
var
i
=
0
l
=
handlerInfos
.
length
;
i
<
l
;
i
+
+
)
{
current
=
handlerInfos
[
i
]
.
handler
;
if
(
current
=
=
=
route
)
{
return
handlerInfos
[
i
+
offset
]
;
}
}
}
function
buildRenderOptions
(
route
namePassed
isDefaultRender
name
options
)
{
var
controller
=
options
&
&
options
.
controller
;
var
templateName
;
var
viewName
;
var
ViewClass
;
var
template
;
var
LOG_VIEW_LOOKUPS
=
_emberMetalProperty_get
.
get
(
route
.
router
'
namespace
.
LOG_VIEW_LOOKUPS
'
)
;
var
into
=
options
&
&
options
.
into
&
&
options
.
into
.
replace
(
/
\
/
/
g
'
.
'
)
;
var
outlet
=
options
&
&
options
.
outlet
|
|
'
main
'
;
var
owner
=
_containerOwner
.
getOwner
(
route
)
;
if
(
name
)
{
name
=
name
.
replace
(
/
\
/
/
g
'
.
'
)
;
templateName
=
name
;
}
else
{
name
=
route
.
routeName
;
templateName
=
route
.
templateName
|
|
name
;
}
if
(
!
controller
)
{
if
(
namePassed
)
{
controller
=
owner
.
lookup
(
'
controller
:
'
+
name
)
|
|
route
.
controllerName
|
|
route
.
routeName
;
}
else
{
controller
=
route
.
controllerName
|
|
owner
.
lookup
(
'
controller
:
'
+
name
)
;
}
}
if
(
typeof
controller
=
=
=
'
string
'
)
{
var
controllerName
=
controller
;
controller
=
owner
.
lookup
(
'
controller
:
'
+
controllerName
)
;
if
(
!
controller
)
{
throw
new
_emberMetalError
.
default
(
'
You
passed
controller
:
\
'
'
+
controllerName
+
'
\
'
into
the
render
method
but
no
such
controller
could
be
found
.
'
)
;
}
}
if
(
options
&
&
Object
.
keys
(
options
)
.
indexOf
(
'
outlet
'
)
!
=
=
-
1
&
&
typeof
options
.
outlet
=
=
=
'
undefined
'
)
{
throw
new
_emberMetalError
.
default
(
'
You
passed
undefined
as
the
outlet
name
.
'
)
;
}
if
(
options
&
&
options
.
model
)
{
controller
.
set
(
'
model
'
options
.
model
)
;
}
viewName
=
options
&
&
options
.
view
|
|
namePassed
&
&
name
|
|
route
.
viewName
|
|
name
;
ViewClass
=
owner
.
_lookupFactory
(
'
view
:
'
+
viewName
)
;
template
=
owner
.
lookup
(
'
template
:
'
+
templateName
)
;
var
parent
;
if
(
into
&
&
(
parent
=
parentRoute
(
route
)
)
&
&
into
=
=
=
parentRoute
(
route
)
.
routeName
)
{
into
=
undefined
;
}
var
renderOptions
=
{
owner
:
owner
into
:
into
outlet
:
outlet
name
:
name
controller
:
controller
ViewClass
:
ViewClass
template
:
template
|
|
route
.
_topLevelViewTemplate
}
;
var
Component
=
undefined
;
if
(
!
ViewClass
&
&
!
template
&
&
!
Component
)
{
_emberMetalDebug
.
assert
(
'
Could
not
find
"
'
+
name
+
'
"
template
view
or
component
.
'
isDefaultRender
)
;
if
(
LOG_VIEW_LOOKUPS
)
{
var
fullName
=
'
template
:
'
+
name
;
_emberMetalDebug
.
info
(
'
Could
not
find
"
'
+
name
+
'
"
template
or
view
.
Nothing
will
be
rendered
'
{
fullName
:
fullName
}
)
;
}
}
return
renderOptions
;
}
function
getFullQueryParams
(
router
state
)
{
if
(
state
.
fullQueryParams
)
{
return
state
.
fullQueryParams
;
}
state
.
fullQueryParams
=
{
}
;
_emberMetalAssign
.
default
(
state
.
fullQueryParams
state
.
queryParams
)
;
var
targetRouteName
=
state
.
handlerInfos
[
state
.
handlerInfos
.
length
-
1
]
.
name
;
router
.
_deserializeQueryParams
(
targetRouteName
state
.
fullQueryParams
)
;
return
state
.
fullQueryParams
;
}
function
getQueryParamsFor
(
route
state
)
{
state
.
queryParamsFor
=
state
.
queryParamsFor
|
|
{
}
;
var
name
=
route
.
routeName
;
if
(
state
.
queryParamsFor
[
name
]
)
{
return
state
.
queryParamsFor
[
name
]
;
}
var
fullQueryParams
=
getFullQueryParams
(
route
.
router
state
)
;
var
params
=
state
.
queryParamsFor
[
name
]
=
{
}
;
var
qpMeta
=
_emberMetalProperty_get
.
get
(
route
'
_qp
'
)
;
var
qps
=
qpMeta
.
qps
;
for
(
var
i
=
0
len
=
qps
.
length
;
i
<
len
;
+
+
i
)
{
var
qp
=
qps
[
i
]
;
var
qpValueWasPassedIn
=
(
qp
.
prop
in
fullQueryParams
)
;
params
[
qp
.
prop
]
=
qpValueWasPassedIn
?
fullQueryParams
[
qp
.
prop
]
:
copyDefaultValue
(
qp
.
defaultValue
)
;
}
return
params
;
}
function
copyDefaultValue
(
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
_emberRuntimeSystemNative_array
.
A
(
value
.
slice
(
)
)
;
}
return
value
;
}
function
mergeEachQueryParams
(
controllerQP
routeQP
)
{
var
keysAlreadyMergedOrSkippable
;
var
qps
=
{
}
;
keysAlreadyMergedOrSkippable
=
{
defaultValue
:
true
type
:
true
scope
:
true
as
:
true
}
;
for
(
var
cqpName
in
controllerQP
)
{
if
(
!
controllerQP
.
hasOwnProperty
(
cqpName
)
)
{
continue
;
}
var
newControllerParameterConfiguration
=
{
}
;
_emberMetalAssign
.
default
(
newControllerParameterConfiguration
controllerQP
[
cqpName
]
)
;
_emberMetalAssign
.
default
(
newControllerParameterConfiguration
routeQP
[
cqpName
]
)
;
qps
[
cqpName
]
=
newControllerParameterConfiguration
;
keysAlreadyMergedOrSkippable
[
cqpName
]
=
true
;
}
for
(
var
rqpName
in
routeQP
)
{
if
(
!
routeQP
.
hasOwnProperty
(
rqpName
)
|
|
keysAlreadyMergedOrSkippable
[
rqpName
]
)
{
continue
;
}
var
newRouteParameterConfiguration
=
{
}
;
_emberMetalAssign
.
default
(
newRouteParameterConfiguration
routeQP
[
rqpName
]
controllerQP
[
rqpName
]
)
;
qps
[
rqpName
]
=
newRouteParameterConfiguration
;
}
return
qps
;
}
function
addQueryParamsObservers
(
controller
propNames
)
{
propNames
.
forEach
(
function
(
prop
)
{
controller
.
addObserver
(
prop
+
'
.
[
]
'
controller
controller
.
_qpChanged
)
;
}
)
;
}
function
deprecateQueryParamDefaultValuesSetOnController
(
controllerName
routeName
propName
)
{
_emberMetalDebug
.
deprecate
(
'
Configuring
query
parameter
default
values
on
controllers
is
deprecated
.
Please
move
the
value
for
the
property
\
'
'
+
propName
+
'
\
'
from
the
\
'
'
+
controllerName
+
'
\
'
controller
to
the
\
'
'
+
routeName
+
'
\
'
route
in
the
format
:
{
queryParams
:
'
+
propName
+
'
:
{
defaultValue
:
<
default
value
>
}
}
'
false
{
id
:
'
ember
-
routing
.
deprecate
-
query
-
param
-
default
-
values
-
set
-
on
-
controller
'
until
:
'
3
.
0
.
0
'
}
)
;
}
exports
.
default
=
Route
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
router
'
[
'
exports
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
run_loop
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
evented
'
'
ember
-
routing
/
system
/
dsl
'
'
ember
-
routing
/
location
/
api
'
'
ember
-
routing
/
utils
'
'
ember
-
metal
/
utils
'
'
ember
-
routing
/
system
/
router_state
'
'
container
/
owner
'
'
ember
-
metal
/
dictionary
'
'
router
'
'
router
/
transition
'
]
function
(
exports
_emberMetalLogger
_emberMetalDebug
_emberMetalError
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalProperties
_emberMetalEmpty_object
_emberMetalComputed
_emberMetalAssign
_emberMetalRun_loop
_emberRuntimeSystemObject
_emberRuntimeMixinsEvented
_emberRoutingSystemDsl
_emberRoutingLocationApi
_emberRoutingUtils
_emberMetalUtils
_emberRoutingSystemRouter_state
_containerOwner
_emberMetalDictionary
_router4
_routerTransition
)
{
'
use
strict
'
;
exports
.
triggerEvent
=
triggerEvent
;
function
K
(
)
{
return
this
;
}
var
slice
=
[
]
.
slice
;
var
EmberRouter
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsEvented
.
default
{
location
:
'
hash
'
rootURL
:
'
/
'
_initRouterJs
:
function
(
)
{
var
router
=
this
.
router
=
new
_router4
.
default
(
)
;
router
.
triggerEvent
=
triggerEvent
;
router
.
_triggerWillChangeContext
=
K
;
router
.
_triggerWillLeave
=
K
;
var
dslCallbacks
=
this
.
constructor
.
dslCallbacks
|
|
[
K
]
;
var
dsl
=
this
.
_buildDSL
(
)
;
dsl
.
route
(
'
application
'
{
path
:
'
/
'
resetNamespace
:
true
overrideNameAssertion
:
true
}
function
(
)
{
for
(
var
i
=
0
;
i
<
dslCallbacks
.
length
;
i
+
+
)
{
dslCallbacks
[
i
]
.
call
(
this
)
;
}
}
)
;
if
(
_emberMetalProperty_get
.
get
(
this
'
namespace
.
LOG_TRANSITIONS_INTERNAL
'
)
)
{
router
.
log
=
_emberMetalLogger
.
default
.
debug
;
}
router
.
map
(
dsl
.
generate
(
)
)
;
}
_buildDSL
:
function
(
)
{
var
moduleBasedResolver
=
this
.
_hasModuleBasedResolver
(
)
;
return
new
_emberRoutingSystemDsl
.
default
(
null
{
enableLoadingSubstates
:
!
!
moduleBasedResolver
}
)
;
}
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_activeViews
=
{
}
;
this
.
_qpCache
=
new
_emberMetalEmpty_object
.
default
(
)
;
this
.
_resetQueuedQueryParameterChanges
(
)
;
this
.
_handledErrors
=
_emberMetalDictionary
.
default
(
null
)
;
}
_resetQueuedQueryParameterChanges
:
function
(
)
{
this
.
_queuedQPChanges
=
{
}
;
}
url
:
_emberMetalComputed
.
computed
(
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
'
location
'
)
.
getURL
(
)
;
}
)
_hasModuleBasedResolver
:
function
(
)
{
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
if
(
!
owner
)
{
return
false
;
}
var
resolver
=
owner
.
application
&
&
owner
.
application
.
__registry__
&
&
owner
.
application
.
__registry__
.
resolver
;
if
(
!
resolver
)
{
return
false
;
}
return
!
!
resolver
.
moduleBasedResolver
;
}
startRouting
:
function
(
)
{
var
initialURL
=
_emberMetalProperty_get
.
get
(
this
'
initialURL
'
)
;
if
(
this
.
setupRouter
(
)
)
{
if
(
typeof
initialURL
=
=
=
'
undefined
'
)
{
initialURL
=
_emberMetalProperty_get
.
get
(
this
'
location
'
)
.
getURL
(
)
;
}
var
initialTransition
=
this
.
handleURL
(
initialURL
)
;
if
(
initialTransition
&
&
initialTransition
.
error
)
{
throw
initialTransition
.
error
;
}
}
}
setupRouter
:
function
(
)
{
var
_this
=
this
;
this
.
_initRouterJs
(
)
;
this
.
_setupLocation
(
)
;
var
router
=
this
.
router
;
var
location
=
_emberMetalProperty_get
.
get
(
this
'
location
'
)
;
if
(
_emberMetalProperty_get
.
get
(
location
'
cancelRouterSetup
'
)
)
{
return
false
;
}
this
.
_setupRouter
(
router
location
)
;
location
.
onUpdateURL
(
function
(
url
)
{
_this
.
handleURL
(
url
)
;
}
)
;
return
true
;
}
didTransition
:
function
(
infos
)
{
updatePaths
(
this
)
;
this
.
_cancelSlowTransitionTimer
(
)
;
this
.
notifyPropertyChange
(
'
url
'
)
;
this
.
set
(
'
currentState
'
this
.
targetState
)
;
_emberMetalRun_loop
.
default
.
once
(
this
this
.
trigger
'
didTransition
'
)
;
if
(
_emberMetalProperty_get
.
get
(
this
'
namespace
'
)
.
LOG_TRANSITIONS
)
{
_emberMetalLogger
.
default
.
log
(
'
Transitioned
into
\
'
'
+
EmberRouter
.
_routePath
(
infos
)
+
'
\
'
'
)
;
}
}
_setOutlets
:
function
(
)
{
var
handlerInfos
=
this
.
router
.
currentHandlerInfos
;
var
route
;
var
defaultParentState
;
var
liveRoutes
=
null
;
if
(
!
handlerInfos
)
{
return
;
}
for
(
var
i
=
0
;
i
<
handlerInfos
.
length
;
i
+
+
)
{
route
=
handlerInfos
[
i
]
.
handler
;
var
connections
=
route
.
connections
;
var
ownState
;
for
(
var
j
=
0
;
j
<
connections
.
length
;
j
+
+
)
{
var
appended
=
appendLiveRoute
(
liveRoutes
defaultParentState
connections
[
j
]
)
;
liveRoutes
=
appended
.
liveRoutes
;
if
(
appended
.
ownState
.
render
.
name
=
=
=
route
.
routeName
|
|
appended
.
ownState
.
render
.
outlet
=
=
=
'
main
'
)
{
ownState
=
appended
.
ownState
;
}
}
if
(
connections
.
length
=
=
=
0
)
{
ownState
=
representEmptyRoute
(
liveRoutes
defaultParentState
route
)
;
}
defaultParentState
=
ownState
;
}
if
(
!
this
.
_toplevelView
)
{
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
var
OutletView
=
owner
.
_lookupFactory
(
'
view
:
-
outlet
'
)
;
this
.
_toplevelView
=
OutletView
.
create
(
)
;
this
.
_toplevelView
.
setOutletState
(
liveRoutes
)
;
var
instance
=
owner
.
lookup
(
'
-
application
-
instance
:
main
'
)
;
instance
.
didCreateRootView
(
this
.
_toplevelView
)
;
}
else
{
this
.
_toplevelView
.
setOutletState
(
liveRoutes
)
;
}
}
willTransition
:
function
(
oldInfos
newInfos
transition
)
{
_emberMetalRun_loop
.
default
.
once
(
this
this
.
trigger
'
willTransition
'
transition
)
;
if
(
_emberMetalProperty_get
.
get
(
this
'
namespace
'
)
.
LOG_TRANSITIONS
)
{
_emberMetalLogger
.
default
.
log
(
'
Preparing
to
transition
from
\
'
'
+
EmberRouter
.
_routePath
(
oldInfos
)
+
'
\
'
to
\
'
'
+
EmberRouter
.
_routePath
(
newInfos
)
+
'
\
'
'
)
;
}
}
handleURL
:
function
(
url
)
{
url
=
url
.
split
(
/
#
(
.
+
)
?
/
)
[
0
]
;
return
this
.
_doURLTransition
(
'
handleURL
'
url
)
;
}
_doURLTransition
:
function
(
routerJsMethod
url
)
{
var
transition
=
this
.
router
[
routerJsMethod
]
(
url
|
|
'
/
'
)
;
didBeginTransition
(
transition
this
)
;
return
transition
;
}
transitionTo
:
function
(
)
{
var
queryParams
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
resemblesURL
(
args
[
0
]
)
)
{
return
this
.
_doURLTransition
(
'
transitionTo
'
args
[
0
]
)
;
}
var
possibleQueryParams
=
args
[
args
.
length
-
1
]
;
if
(
possibleQueryParams
&
&
possibleQueryParams
.
hasOwnProperty
(
'
queryParams
'
)
)
{
queryParams
=
args
.
pop
(
)
.
queryParams
;
}
else
{
queryParams
=
{
}
;
}
var
targetRouteName
=
args
.
shift
(
)
;
return
this
.
_doTransition
(
targetRouteName
args
queryParams
)
;
}
intermediateTransitionTo
:
function
(
)
{
var
_router
;
(
_router
=
this
.
router
)
.
intermediateTransitionTo
.
apply
(
_router
arguments
)
;
updatePaths
(
this
)
;
var
infos
=
this
.
router
.
currentHandlerInfos
;
if
(
_emberMetalProperty_get
.
get
(
this
'
namespace
'
)
.
LOG_TRANSITIONS
)
{
_emberMetalLogger
.
default
.
log
(
'
Intermediate
-
transitioned
into
\
'
'
+
EmberRouter
.
_routePath
(
infos
)
+
'
\
'
'
)
;
}
}
replaceWith
:
function
(
)
{
return
this
.
transitionTo
.
apply
(
this
arguments
)
.
method
(
'
replace
'
)
;
}
generate
:
function
(
)
{
var
_router2
;
var
url
=
(
_router2
=
this
.
router
)
.
generate
.
apply
(
_router2
arguments
)
;
return
this
.
location
.
formatURL
(
url
)
;
}
isActive
:
function
(
routeName
)
{
var
router
=
this
.
router
;
return
router
.
isActive
.
apply
(
router
arguments
)
;
}
isActiveIntent
:
function
(
routeName
models
queryParams
)
{
return
this
.
currentState
.
isActiveIntent
(
routeName
models
queryParams
)
;
}
send
:
function
(
name
context
)
{
var
_router3
;
(
_router3
=
this
.
router
)
.
trigger
.
apply
(
_router3
arguments
)
;
}
hasRoute
:
function
(
route
)
{
return
this
.
router
.
hasRoute
(
route
)
;
}
reset
:
function
(
)
{
if
(
this
.
router
)
{
this
.
router
.
reset
(
)
;
}
}
willDestroy
:
function
(
)
{
if
(
this
.
_toplevelView
)
{
this
.
_toplevelView
.
destroy
(
)
;
this
.
_toplevelView
=
null
;
}
this
.
_super
.
apply
(
this
arguments
)
;
this
.
reset
(
)
;
}
_lookupActiveComponentNode
:
function
(
templateName
)
{
return
this
.
_activeViews
[
templateName
]
;
}
_activeQPChanged
:
function
(
queryParameterName
newValue
)
{
this
.
_queuedQPChanges
[
queryParameterName
]
=
newValue
;
_emberMetalRun_loop
.
default
.
once
(
this
this
.
_fireQueryParamTransition
)
;
}
_updatingQPChanged
:
function
(
queryParameterName
)
{
if
(
!
this
.
_qpUpdates
)
{
this
.
_qpUpdates
=
{
}
;
}
this
.
_qpUpdates
[
queryParameterName
]
=
true
;
}
_fireQueryParamTransition
:
function
(
)
{
this
.
transitionTo
(
{
queryParams
:
this
.
_queuedQPChanges
}
)
;
this
.
_resetQueuedQueryParameterChanges
(
)
;
}
_connectActiveComponentNode
:
function
(
templateName
componentNode
)
{
_emberMetalDebug
.
assert
(
'
cannot
connect
an
activeView
that
already
exists
'
!
this
.
_activeViews
[
templateName
]
)
;
var
_activeViews
=
this
.
_activeViews
;
function
disconnectActiveView
(
)
{
delete
_activeViews
[
templateName
]
;
}
this
.
_activeViews
[
templateName
]
=
componentNode
;
componentNode
.
renderNode
.
addDestruction
(
{
destroy
:
disconnectActiveView
}
)
;
}
_setupLocation
:
function
(
)
{
var
location
=
_emberMetalProperty_get
.
get
(
this
'
location
'
)
;
var
rootURL
=
_emberMetalProperty_get
.
get
(
this
'
rootURL
'
)
;
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
if
(
'
string
'
=
=
=
typeof
location
&
&
owner
)
{
var
resolvedLocation
=
owner
.
lookup
(
'
location
:
'
+
location
)
;
if
(
'
undefined
'
!
=
=
typeof
resolvedLocation
)
{
location
=
_emberMetalProperty_set
.
set
(
this
'
location
'
resolvedLocation
)
;
}
else
{
var
options
=
{
implementation
:
location
}
;
location
=
_emberMetalProperty_set
.
set
(
this
'
location
'
_emberRoutingLocationApi
.
default
.
create
(
options
)
)
;
}
}
if
(
location
!
=
=
null
&
&
typeof
location
=
=
=
'
object
'
)
{
if
(
rootURL
)
{
_emberMetalProperty_set
.
set
(
location
'
rootURL
'
rootURL
)
;
}
if
(
typeof
location
.
detect
=
=
=
'
function
'
)
{
location
.
detect
(
)
;
}
if
(
typeof
location
.
initState
=
=
=
'
function
'
)
{
location
.
initState
(
)
;
}
}
}
_getHandlerFunction
:
function
(
)
{
var
_this2
=
this
;
var
seen
=
new
_emberMetalEmpty_object
.
default
(
)
;
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
var
DefaultRoute
=
owner
.
_lookupFactory
(
'
route
:
basic
'
)
;
return
function
(
name
)
{
var
routeName
=
'
route
:
'
+
name
;
var
handler
=
owner
.
lookup
(
routeName
)
;
if
(
seen
[
name
]
)
{
return
handler
;
}
seen
[
name
]
=
true
;
if
(
!
handler
)
{
owner
.
register
(
routeName
DefaultRoute
.
extend
(
)
)
;
handler
=
owner
.
lookup
(
routeName
)
;
if
(
_emberMetalProperty_get
.
get
(
_this2
'
namespace
.
LOG_ACTIVE_GENERATION
'
)
)
{
_emberMetalDebug
.
info
(
'
generated
-
>
'
+
routeName
{
fullName
:
routeName
}
)
;
}
}
handler
.
routeName
=
name
;
return
handler
;
}
;
}
_setupRouter
:
function
(
router
location
)
{
var
lastURL
;
var
emberRouter
=
this
;
router
.
getHandler
=
this
.
_getHandlerFunction
(
)
;
var
doUpdateURL
=
function
(
)
{
location
.
setURL
(
lastURL
)
;
}
;
router
.
updateURL
=
function
(
path
)
{
lastURL
=
path
;
_emberMetalRun_loop
.
default
.
once
(
doUpdateURL
)
;
}
;
if
(
location
.
replaceURL
)
{
var
doReplaceURL
=
function
(
)
{
location
.
replaceURL
(
lastURL
)
;
}
;
router
.
replaceURL
=
function
(
path
)
{
lastURL
=
path
;
_emberMetalRun_loop
.
default
.
once
(
doReplaceURL
)
;
}
;
}
router
.
didTransition
=
function
(
infos
)
{
emberRouter
.
didTransition
(
infos
)
;
}
;
router
.
willTransition
=
function
(
oldInfos
newInfos
transition
)
{
emberRouter
.
willTransition
(
oldInfos
newInfos
transition
)
;
}
;
}
_serializeQueryParams
:
function
(
targetRouteName
queryParams
)
{
var
groupedByUrlKey
=
{
}
;
forEachQueryParam
(
this
targetRouteName
queryParams
function
(
key
value
qp
)
{
var
urlKey
=
qp
.
urlKey
;
if
(
!
groupedByUrlKey
[
urlKey
]
)
{
groupedByUrlKey
[
urlKey
]
=
[
]
;
}
groupedByUrlKey
[
urlKey
]
.
push
(
{
qp
:
qp
value
:
value
}
)
;
delete
queryParams
[
key
]
;
}
)
;
for
(
var
key
in
groupedByUrlKey
)
{
var
qps
=
groupedByUrlKey
[
key
]
;
_emberMetalDebug
.
assert
(
'
You
\
'
re
not
allowed
to
have
more
than
one
controller
property
map
to
the
same
query
param
key
but
both
'
+
qps
[
0
]
.
qp
.
scopedPropertyName
+
'
and
'
+
(
qps
[
1
]
?
qps
[
1
]
.
qp
.
scopedPropertyName
:
'
'
)
+
'
map
to
'
+
qps
[
0
]
.
qp
.
urlKey
+
'
.
You
can
fix
this
by
mapping
one
of
the
controller
properties
to
a
different
query
param
key
via
the
as
config
option
e
.
g
.
'
+
qps
[
0
]
.
qp
.
prop
+
'
:
{
as
:
\
'
other
-
'
+
qps
[
0
]
.
qp
.
prop
+
'
\
'
}
'
qps
.
length
<
=
1
)
;
var
qp
=
qps
[
0
]
.
qp
;
queryParams
[
qp
.
urlKey
]
=
qp
.
route
.
serializeQueryParam
(
qps
[
0
]
.
value
qp
.
urlKey
qp
.
type
)
;
}
}
_deserializeQueryParams
:
function
(
targetRouteName
queryParams
)
{
forEachQueryParam
(
this
targetRouteName
queryParams
function
(
key
value
qp
)
{
delete
queryParams
[
key
]
;
queryParams
[
qp
.
prop
]
=
qp
.
route
.
deserializeQueryParam
(
value
qp
.
urlKey
qp
.
type
)
;
}
)
;
}
_pruneDefaultQueryParamValues
:
function
(
targetRouteName
queryParams
)
{
var
qps
=
this
.
_queryParamsFor
(
targetRouteName
)
;
for
(
var
key
in
queryParams
)
{
var
qp
=
qps
.
map
[
key
]
;
if
(
qp
&
&
qp
.
serializedDefaultValue
=
=
=
queryParams
[
key
]
)
{
delete
queryParams
[
key
]
;
}
}
}
_doTransition
:
function
(
_targetRouteName
models
_queryParams
)
{
var
targetRouteName
=
_targetRouteName
|
|
_emberRoutingUtils
.
getActiveTargetName
(
this
.
router
)
;
_emberMetalDebug
.
assert
(
'
The
route
'
+
targetRouteName
+
'
was
not
found
'
targetRouteName
&
&
this
.
router
.
hasRoute
(
targetRouteName
)
)
;
var
queryParams
=
{
}
;
if
(
this
.
router
.
activeTransition
)
{
_emberMetalAssign
.
default
(
queryParams
this
.
router
.
activeTransition
.
queryParams
)
;
}
_emberMetalAssign
.
default
(
queryParams
_queryParams
)
;
this
.
_prepareQueryParams
(
targetRouteName
models
queryParams
)
;
var
transitionArgs
=
_emberRoutingUtils
.
routeArgs
(
targetRouteName
models
queryParams
)
;
var
transition
=
this
.
router
.
transitionTo
.
apply
(
this
.
router
transitionArgs
)
;
didBeginTransition
(
transition
this
)
;
return
transition
;
}
_prepareQueryParams
:
function
(
targetRouteName
models
queryParams
)
{
this
.
_hydrateUnsuppliedQueryParams
(
targetRouteName
models
queryParams
)
;
this
.
_serializeQueryParams
(
targetRouteName
queryParams
)
;
this
.
_pruneDefaultQueryParamValues
(
targetRouteName
queryParams
)
;
}
_queryParamsFor
:
function
(
leafRouteName
)
{
if
(
this
.
_qpCache
[
leafRouteName
]
)
{
return
this
.
_qpCache
[
leafRouteName
]
;
}
var
map
=
{
}
;
var
qps
=
[
]
;
this
.
_qpCache
[
leafRouteName
]
=
{
map
:
map
qps
:
qps
}
;
var
routerjs
=
this
.
router
;
var
recogHandlerInfos
=
routerjs
.
recognizer
.
handlersFor
(
leafRouteName
)
;
for
(
var
i
=
0
len
=
recogHandlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
recogHandler
=
recogHandlerInfos
[
i
]
;
var
route
=
routerjs
.
getHandler
(
recogHandler
.
handler
)
;
var
qpMeta
=
_emberMetalProperty_get
.
get
(
route
'
_qp
'
)
;
if
(
!
qpMeta
)
{
continue
;
}
_emberMetalAssign
.
default
(
map
qpMeta
.
map
)
;
qps
.
push
.
apply
(
qps
qpMeta
.
qps
)
;
}
return
{
qps
:
qps
map
:
map
}
;
}
_hydrateUnsuppliedQueryParams
:
function
(
leafRouteName
contexts
queryParams
)
{
var
state
=
calculatePostTransitionState
(
this
leafRouteName
contexts
)
;
var
handlerInfos
=
state
.
handlerInfos
;
var
appCache
=
this
.
_bucketCache
;
_emberRoutingUtils
.
stashParamNames
(
this
handlerInfos
)
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
route
=
handlerInfos
[
i
]
.
handler
;
var
qpMeta
=
_emberMetalProperty_get
.
get
(
route
'
_qp
'
)
;
for
(
var
j
=
0
qpLen
=
qpMeta
.
qps
.
length
;
j
<
qpLen
;
+
+
j
)
{
var
qp
=
qpMeta
.
qps
[
j
]
;
var
presentProp
=
qp
.
prop
in
queryParams
&
&
qp
.
prop
|
|
qp
.
scopedPropertyName
in
queryParams
&
&
qp
.
scopedPropertyName
;
if
(
presentProp
)
{
if
(
presentProp
!
=
=
qp
.
scopedPropertyName
)
{
queryParams
[
qp
.
scopedPropertyName
]
=
queryParams
[
presentProp
]
;
delete
queryParams
[
presentProp
]
;
}
}
else
{
var
cacheKey
=
_emberRoutingUtils
.
calculateCacheKey
(
qp
.
ctrl
qp
.
parts
state
.
params
)
;
queryParams
[
qp
.
scopedPropertyName
]
=
appCache
.
lookup
(
cacheKey
qp
.
prop
qp
.
defaultValue
)
;
}
}
}
}
_scheduleLoadingEvent
:
function
(
transition
originRoute
)
{
this
.
_cancelSlowTransitionTimer
(
)
;
this
.
_slowTransitionTimer
=
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
routerTransitions
'
this
'
_handleSlowTransition
'
transition
originRoute
)
;
}
currentState
:
null
targetState
:
null
_handleSlowTransition
:
function
(
transition
originRoute
)
{
if
(
!
this
.
router
.
activeTransition
)
{
return
;
}
this
.
set
(
'
targetState
'
_emberRoutingSystemRouter_state
.
default
.
create
(
{
emberRouter
:
this
routerJs
:
this
.
router
routerJsState
:
this
.
router
.
activeTransition
.
state
}
)
)
;
transition
.
trigger
(
true
'
loading
'
transition
originRoute
)
;
}
_cancelSlowTransitionTimer
:
function
(
)
{
if
(
this
.
_slowTransitionTimer
)
{
_emberMetalRun_loop
.
default
.
cancel
(
this
.
_slowTransitionTimer
)
;
}
this
.
_slowTransitionTimer
=
null
;
}
_markErrorAsHandled
:
function
(
errorGuid
)
{
this
.
_handledErrors
[
errorGuid
]
=
true
;
}
_isErrorHandled
:
function
(
errorGuid
)
{
return
this
.
_handledErrors
[
errorGuid
]
;
}
_clearHandledError
:
function
(
errorGuid
)
{
delete
this
.
_handledErrors
[
errorGuid
]
;
}
}
)
;
function
forEachRouteAbove
(
originRoute
transition
callback
)
{
var
handlerInfos
=
transition
.
state
.
handlerInfos
;
var
originRouteFound
=
false
;
var
handlerInfo
route
;
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
handlerInfo
=
handlerInfos
[
i
]
;
route
=
handlerInfo
.
handler
;
if
(
!
originRouteFound
)
{
if
(
originRoute
=
=
=
route
)
{
originRouteFound
=
true
;
}
continue
;
}
if
(
callback
(
route
handlerInfos
[
i
+
1
]
.
handler
)
!
=
=
true
)
{
return
false
;
}
}
return
true
;
}
var
defaultActionHandlers
=
{
willResolveModel
:
function
(
transition
originRoute
)
{
originRoute
.
router
.
_scheduleLoadingEvent
(
transition
originRoute
)
;
}
error
:
function
(
error
transition
originRoute
)
{
var
router
=
originRoute
.
router
;
var
tryTopLevel
=
forEachRouteAbove
(
originRoute
transition
function
(
route
childRoute
)
{
var
childErrorRouteName
=
findChildRouteName
(
route
childRoute
'
error
'
)
;
if
(
childErrorRouteName
)
{
router
.
intermediateTransitionTo
(
childErrorRouteName
error
)
;
return
;
}
return
true
;
}
)
;
if
(
tryTopLevel
)
{
if
(
routeHasBeenDefined
(
originRoute
.
router
'
application_error
'
)
)
{
router
.
intermediateTransitionTo
(
'
application_error
'
error
)
;
return
;
}
}
logError
(
error
'
Error
while
processing
route
:
'
+
transition
.
targetName
)
;
}
loading
:
function
(
transition
originRoute
)
{
var
router
=
originRoute
.
router
;
var
tryTopLevel
=
forEachRouteAbove
(
originRoute
transition
function
(
route
childRoute
)
{
var
childLoadingRouteName
=
findChildRouteName
(
route
childRoute
'
loading
'
)
;
if
(
childLoadingRouteName
)
{
router
.
intermediateTransitionTo
(
childLoadingRouteName
)
;
return
;
}
if
(
transition
.
pivotHandler
!
=
=
route
)
{
return
true
;
}
}
)
;
if
(
tryTopLevel
)
{
if
(
routeHasBeenDefined
(
originRoute
.
router
'
application_loading
'
)
)
{
router
.
intermediateTransitionTo
(
'
application_loading
'
)
;
return
;
}
}
}
}
;
function
logError
(
_error
initialMessage
)
{
var
errorArgs
=
[
]
;
var
error
;
if
(
_error
&
&
typeof
_error
=
=
=
'
object
'
&
&
typeof
_error
.
errorThrown
=
=
=
'
object
'
)
{
error
=
_error
.
errorThrown
;
}
else
{
error
=
_error
;
}
if
(
initialMessage
)
{
errorArgs
.
push
(
initialMessage
)
;
}
if
(
error
)
{
if
(
error
.
message
)
{
errorArgs
.
push
(
error
.
message
)
;
}
if
(
error
.
stack
)
{
errorArgs
.
push
(
error
.
stack
)
;
}
if
(
typeof
error
=
=
=
'
string
'
)
{
errorArgs
.
push
(
error
)
;
}
}
_emberMetalLogger
.
default
.
error
.
apply
(
this
errorArgs
)
;
}
function
findChildRouteName
(
parentRoute
originatingChildRoute
name
)
{
var
router
=
parentRoute
.
router
;
var
childName
;
var
targetChildRouteName
=
originatingChildRoute
.
routeName
.
split
(
'
.
'
)
.
pop
(
)
;
var
namespace
=
parentRoute
.
routeName
=
=
=
'
application
'
?
'
'
:
parentRoute
.
routeName
+
'
.
'
;
childName
=
namespace
+
targetChildRouteName
+
'
_
'
+
name
;
if
(
routeHasBeenDefined
(
router
childName
)
)
{
return
childName
;
}
childName
=
namespace
+
name
;
if
(
routeHasBeenDefined
(
router
childName
)
)
{
return
childName
;
}
}
function
routeHasBeenDefined
(
router
name
)
{
var
owner
=
_containerOwner
.
getOwner
(
router
)
;
return
router
.
hasRoute
(
name
)
&
&
(
owner
.
hasRegistration
(
'
template
:
'
+
name
)
|
|
owner
.
hasRegistration
(
'
route
:
'
+
name
)
)
;
}
function
triggerEvent
(
handlerInfos
ignoreFailure
args
)
{
var
name
=
args
.
shift
(
)
;
if
(
!
handlerInfos
)
{
if
(
ignoreFailure
)
{
return
;
}
throw
new
_emberMetalError
.
default
(
'
Can
\
'
t
trigger
action
\
'
'
+
name
+
'
\
'
because
your
app
hasn
\
'
t
finished
transitioning
into
its
first
route
.
To
trigger
an
action
on
destination
routes
during
a
transition
you
can
call
.
send
(
)
on
the
Transition
object
passed
to
the
model
/
beforeModel
/
afterModel
hooks
.
'
)
;
}
var
eventWasHandled
=
false
;
var
handlerInfo
handler
;
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
handlerInfo
=
handlerInfos
[
i
]
;
handler
=
handlerInfo
.
handler
;
if
(
handler
.
actions
&
&
handler
.
actions
[
name
]
)
{
if
(
handler
.
actions
[
name
]
.
apply
(
handler
args
)
=
=
=
true
)
{
eventWasHandled
=
true
;
}
else
{
if
(
name
=
=
=
'
error
'
)
{
var
errorId
=
_emberMetalUtils
.
guidFor
(
args
[
0
]
)
;
handler
.
router
.
_markErrorAsHandled
(
errorId
)
;
}
return
;
}
}
}
if
(
defaultActionHandlers
[
name
]
)
{
defaultActionHandlers
[
name
]
.
apply
(
null
args
)
;
return
;
}
if
(
!
eventWasHandled
&
&
!
ignoreFailure
)
{
throw
new
_emberMetalError
.
default
(
'
Nothing
handled
the
action
\
'
'
+
name
+
'
\
'
.
If
you
did
handle
the
action
this
error
can
be
caused
by
returning
true
from
an
action
handler
in
a
controller
causing
the
action
to
bubble
.
'
)
;
}
}
function
calculatePostTransitionState
(
emberRouter
leafRouteName
contexts
)
{
var
routerjs
=
emberRouter
.
router
;
var
state
=
routerjs
.
applyIntent
(
leafRouteName
contexts
)
;
var
handlerInfos
=
state
.
handlerInfos
;
var
params
=
state
.
params
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
if
(
!
handlerInfo
.
isResolved
)
{
handlerInfo
=
handlerInfo
.
becomeResolved
(
null
handlerInfo
.
context
)
;
}
params
[
handlerInfo
.
name
]
=
handlerInfo
.
params
;
}
return
state
;
}
function
updatePaths
(
router
)
{
var
infos
=
router
.
router
.
currentHandlerInfos
;
var
path
=
EmberRouter
.
_routePath
(
infos
)
;
var
currentRouteName
=
infos
[
infos
.
length
-
1
]
.
name
;
_emberMetalProperty_set
.
set
(
router
'
currentPath
'
path
)
;
_emberMetalProperty_set
.
set
(
router
'
currentRouteName
'
currentRouteName
)
;
var
appController
=
_containerOwner
.
getOwner
(
router
)
.
lookup
(
'
controller
:
application
'
)
;
if
(
!
appController
)
{
return
;
}
if
(
!
(
'
currentPath
'
in
appController
)
)
{
_emberMetalProperties
.
defineProperty
(
appController
'
currentPath
'
)
;
}
_emberMetalProperty_set
.
set
(
appController
'
currentPath
'
path
)
;
if
(
!
(
'
currentRouteName
'
in
appController
)
)
{
_emberMetalProperties
.
defineProperty
(
appController
'
currentRouteName
'
)
;
}
_emberMetalProperty_set
.
set
(
appController
'
currentRouteName
'
currentRouteName
)
;
}
EmberRouter
.
reopenClass
(
{
router
:
null
map
:
function
(
callback
)
{
if
(
!
this
.
dslCallbacks
)
{
this
.
dslCallbacks
=
[
]
;
this
.
reopenClass
(
{
dslCallbacks
:
this
.
dslCallbacks
}
)
;
}
this
.
dslCallbacks
.
push
(
callback
)
;
return
this
;
}
_routePath
:
function
(
handlerInfos
)
{
var
path
=
[
]
;
function
intersectionMatches
(
a1
a2
)
{
for
(
var
i
=
0
len
=
a1
.
length
;
i
<
len
;
+
+
i
)
{
if
(
a1
[
i
]
!
=
=
a2
[
i
]
)
{
return
false
;
}
}
return
true
;
}
var
name
nameParts
oldNameParts
;
for
(
var
i
=
1
l
=
handlerInfos
.
length
;
i
<
l
;
i
+
+
)
{
name
=
handlerInfos
[
i
]
.
name
;
nameParts
=
name
.
split
(
'
.
'
)
;
oldNameParts
=
slice
.
call
(
path
)
;
while
(
oldNameParts
.
length
)
{
if
(
intersectionMatches
(
oldNameParts
nameParts
)
)
{
break
;
}
oldNameParts
.
shift
(
)
;
}
path
.
push
.
apply
(
path
nameParts
.
slice
(
oldNameParts
.
length
)
)
;
}
return
path
.
join
(
'
.
'
)
;
}
}
)
;
function
didBeginTransition
(
transition
router
)
{
var
routerState
=
_emberRoutingSystemRouter_state
.
default
.
create
(
{
emberRouter
:
router
routerJs
:
router
.
router
routerJsState
:
transition
.
state
}
)
;
if
(
!
router
.
currentState
)
{
router
.
set
(
'
currentState
'
routerState
)
;
}
router
.
set
(
'
targetState
'
routerState
)
;
transition
.
promise
=
transition
.
catch
(
function
(
error
)
{
var
errorId
=
_emberMetalUtils
.
guidFor
(
error
)
;
if
(
router
.
_isErrorHandled
(
errorId
)
)
{
router
.
_clearHandledError
(
errorId
)
;
}
else
{
throw
error
;
}
}
)
;
}
function
resemblesURL
(
str
)
{
return
typeof
str
=
=
=
'
string
'
&
&
(
str
=
=
=
'
'
|
|
str
.
charAt
(
0
)
=
=
=
'
/
'
)
;
}
function
forEachQueryParam
(
router
targetRouteName
queryParams
callback
)
{
var
qpCache
=
router
.
_queryParamsFor
(
targetRouteName
)
;
for
(
var
key
in
queryParams
)
{
if
(
!
queryParams
.
hasOwnProperty
(
key
)
)
{
continue
;
}
var
value
=
queryParams
[
key
]
;
var
qp
=
qpCache
.
map
[
key
]
;
if
(
qp
)
{
callback
(
key
value
qp
)
;
}
}
}
function
findLiveRoute
(
liveRoutes
name
)
{
if
(
!
liveRoutes
)
{
return
;
}
var
stack
=
[
liveRoutes
]
;
while
(
stack
.
length
>
0
)
{
var
test
=
stack
.
shift
(
)
;
if
(
test
.
render
.
name
=
=
=
name
)
{
return
test
;
}
var
outlets
=
test
.
outlets
;
for
(
var
outletName
in
outlets
)
{
stack
.
push
(
outlets
[
outletName
]
)
;
}
}
}
function
appendLiveRoute
(
liveRoutes
defaultParentState
renderOptions
)
{
var
target
;
var
myState
=
{
render
:
renderOptions
outlets
:
new
_emberMetalEmpty_object
.
default
(
)
}
;
if
(
renderOptions
.
into
)
{
target
=
findLiveRoute
(
liveRoutes
renderOptions
.
into
)
;
}
else
{
target
=
defaultParentState
;
}
if
(
target
)
{
_emberMetalProperty_set
.
set
(
target
.
outlets
renderOptions
.
outlet
myState
)
;
}
else
{
if
(
renderOptions
.
into
)
{
appendOrphan
(
liveRoutes
renderOptions
.
into
myState
)
;
}
else
{
liveRoutes
=
myState
;
}
}
return
{
liveRoutes
:
liveRoutes
ownState
:
myState
}
;
}
function
appendOrphan
(
liveRoutes
into
myState
)
{
if
(
!
liveRoutes
.
outlets
.
__ember_orphans__
)
{
liveRoutes
.
outlets
.
__ember_orphans__
=
{
render
:
{
name
:
'
__ember_orphans__
'
}
outlets
:
new
_emberMetalEmpty_object
.
default
(
)
}
;
}
liveRoutes
.
outlets
.
__ember_orphans__
.
outlets
[
into
]
=
myState
;
_emberMetalRun_loop
.
default
.
schedule
(
'
afterRender
'
function
(
)
{
_emberMetalDebug
.
assert
(
'
You
attempted
to
render
into
\
'
'
+
into
+
'
\
'
but
it
was
not
found
'
liveRoutes
.
outlets
.
__ember_orphans__
.
outlets
[
into
]
.
wasUsed
)
;
}
)
;
}
function
representEmptyRoute
(
liveRoutes
defaultParentState
route
)
{
var
alreadyAppended
=
findLiveRoute
(
liveRoutes
route
.
routeName
)
;
if
(
alreadyAppended
)
{
return
alreadyAppended
;
}
else
{
defaultParentState
.
outlets
.
main
=
{
render
:
{
name
:
route
.
routeName
outlet
:
'
main
'
}
outlets
:
{
}
}
;
return
defaultParentState
;
}
}
exports
.
default
=
EmberRouter
;
}
)
;
enifed
(
'
ember
-
routing
/
system
/
router_state
'
[
'
exports
'
'
ember
-
metal
/
is_empty
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_emberMetalIs_empty
_emberRuntimeSystemObject
_emberMetalAssign
)
{
'
use
strict
'
;
var
keys
=
Object
.
keys
;
var
RouterState
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
emberRouter
:
null
routerJs
:
null
routerJsState
:
null
isActiveIntent
:
function
(
routeName
models
queryParams
queryParamsMustMatch
)
{
var
state
=
this
.
routerJsState
;
if
(
!
this
.
routerJs
.
isActiveIntent
(
routeName
models
null
state
)
)
{
return
false
;
}
var
emptyQueryParams
=
_emberMetalIs_empty
.
default
(
keys
(
queryParams
)
)
;
if
(
queryParamsMustMatch
&
&
!
emptyQueryParams
)
{
var
visibleQueryParams
=
{
}
;
_emberMetalAssign
.
default
(
visibleQueryParams
queryParams
)
;
this
.
emberRouter
.
_prepareQueryParams
(
routeName
models
visibleQueryParams
)
;
return
shallowEqual
(
visibleQueryParams
state
.
queryParams
)
;
}
return
true
;
}
}
)
;
function
shallowEqual
(
a
b
)
{
var
k
;
for
(
k
in
a
)
{
if
(
a
.
hasOwnProperty
(
k
)
&
&
a
[
k
]
!
=
=
b
[
k
]
)
{
return
false
;
}
}
for
(
k
in
b
)
{
if
(
b
.
hasOwnProperty
(
k
)
&
&
a
[
k
]
!
=
=
b
[
k
]
)
{
return
false
;
}
}
return
true
;
}
exports
.
default
=
RouterState
;
}
)
;
enifed
(
'
ember
-
routing
/
utils
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalAssign
_emberMetalProperty_get
)
{
'
use
strict
'
;
exports
.
routeArgs
=
routeArgs
;
exports
.
getActiveTargetName
=
getActiveTargetName
;
exports
.
stashParamNames
=
stashParamNames
;
exports
.
calculateCacheKey
=
calculateCacheKey
;
exports
.
normalizeControllerQueryParams
=
normalizeControllerQueryParams
;
function
routeArgs
(
targetRouteName
models
queryParams
)
{
var
args
=
[
]
;
if
(
typeof
targetRouteName
=
=
=
'
string
'
)
{
args
.
push
(
'
'
+
targetRouteName
)
;
}
args
.
push
.
apply
(
args
models
)
;
args
.
push
(
{
queryParams
:
queryParams
}
)
;
return
args
;
}
function
getActiveTargetName
(
router
)
{
var
handlerInfos
=
router
.
activeTransition
?
router
.
activeTransition
.
state
.
handlerInfos
:
router
.
state
.
handlerInfos
;
return
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
;
}
function
stashParamNames
(
router
handlerInfos
)
{
if
(
handlerInfos
.
_namesStashed
)
{
return
;
}
var
targetRouteName
=
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
;
var
recogHandlers
=
router
.
router
.
recognizer
.
handlersFor
(
targetRouteName
)
;
var
dynamicParent
=
null
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
var
names
=
recogHandlers
[
i
]
.
names
;
if
(
names
.
length
)
{
dynamicParent
=
handlerInfo
;
}
handlerInfo
.
_names
=
names
;
var
route
=
handlerInfo
.
handler
;
route
.
_stashNames
(
handlerInfo
dynamicParent
)
;
}
handlerInfos
.
_namesStashed
=
true
;
}
function
_calculateCacheValuePrefix
(
prefix
part
)
{
var
prefixParts
=
prefix
.
split
(
'
.
'
)
;
var
currPrefix
=
'
'
;
for
(
var
i
=
0
len
=
prefixParts
.
length
;
i
<
len
;
i
+
+
)
{
var
currPart
=
prefixParts
.
slice
(
0
i
+
1
)
.
join
(
'
.
'
)
;
if
(
part
.
indexOf
(
currPart
)
!
=
=
0
)
{
break
;
}
currPrefix
=
currPart
;
}
return
currPrefix
;
}
function
calculateCacheKey
(
prefix
_parts
values
)
{
var
parts
=
_parts
|
|
[
]
;
var
suffixes
=
'
'
;
for
(
var
i
=
0
len
=
parts
.
length
;
i
<
len
;
+
+
i
)
{
var
part
=
parts
[
i
]
;
var
cacheValuePrefix
=
_calculateCacheValuePrefix
(
prefix
part
)
;
var
value
;
if
(
values
)
{
if
(
cacheValuePrefix
&
&
cacheValuePrefix
in
values
)
{
var
partRemovedPrefix
=
part
.
indexOf
(
cacheValuePrefix
)
=
=
=
0
?
part
.
substr
(
cacheValuePrefix
.
length
+
1
)
:
part
;
value
=
_emberMetalProperty_get
.
get
(
values
[
cacheValuePrefix
]
partRemovedPrefix
)
;
}
else
{
value
=
_emberMetalProperty_get
.
get
(
values
part
)
;
}
}
suffixes
+
=
'
:
:
'
+
part
+
'
:
'
+
value
;
}
return
prefix
+
suffixes
.
replace
(
ALL_PERIODS_REGEX
'
-
'
)
;
}
var
ALL_PERIODS_REGEX
=
/
\
.
/
g
;
function
normalizeControllerQueryParams
(
queryParams
)
{
if
(
queryParams
.
_qpMap
)
{
return
queryParams
.
_qpMap
;
}
var
qpMap
=
queryParams
.
_qpMap
=
{
}
;
for
(
var
i
=
0
len
=
queryParams
.
length
;
i
<
len
;
+
+
i
)
{
accumulateQueryParamDescriptors
(
queryParams
[
i
]
qpMap
)
;
}
return
qpMap
;
}
function
accumulateQueryParamDescriptors
(
_desc
accum
)
{
var
desc
=
_desc
;
var
tmp
;
if
(
typeof
desc
=
=
=
'
string
'
)
{
tmp
=
{
}
;
tmp
[
desc
]
=
{
as
:
null
}
;
desc
=
tmp
;
}
for
(
var
key
in
desc
)
{
if
(
!
desc
.
hasOwnProperty
(
key
)
)
{
return
;
}
var
singleDesc
=
desc
[
key
]
;
if
(
typeof
singleDesc
=
=
=
'
string
'
)
{
singleDesc
=
{
as
:
singleDesc
}
;
}
tmp
=
accum
[
key
]
|
|
{
as
:
null
scope
:
'
model
'
}
;
_emberMetalAssign
.
default
(
tmp
singleDesc
)
;
accum
[
key
]
=
tmp
;
}
}
}
)
;
enifed
(
'
ember
-
runtime
/
compare
'
[
'
exports
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
mixins
/
comparable
'
]
function
(
exports
_emberRuntimeUtils
_emberRuntimeMixinsComparable
)
{
'
use
strict
'
;
exports
.
default
=
compare
;
var
TYPE_ORDER
=
{
'
undefined
'
:
0
'
null
'
:
1
'
boolean
'
:
2
'
number
'
:
3
'
string
'
:
4
'
array
'
:
5
'
object
'
:
6
'
instance
'
:
7
'
function
'
:
8
'
class
'
:
9
'
date
'
:
10
}
;
function
spaceship
(
a
b
)
{
var
diff
=
a
-
b
;
return
(
diff
>
0
)
-
(
diff
<
0
)
;
}
function
compare
(
v
w
)
{
if
(
v
=
=
=
w
)
{
return
0
;
}
var
type1
=
_emberRuntimeUtils
.
typeOf
(
v
)
;
var
type2
=
_emberRuntimeUtils
.
typeOf
(
w
)
;
if
(
_emberRuntimeMixinsComparable
.
default
)
{
if
(
type1
=
=
=
'
instance
'
&
&
_emberRuntimeMixinsComparable
.
default
.
detect
(
v
)
&
&
v
.
constructor
.
compare
)
{
return
v
.
constructor
.
compare
(
v
w
)
;
}
if
(
type2
=
=
=
'
instance
'
&
&
_emberRuntimeMixinsComparable
.
default
.
detect
(
w
)
&
&
w
.
constructor
.
compare
)
{
return
w
.
constructor
.
compare
(
w
v
)
*
-
1
;
}
}
var
res
=
spaceship
(
TYPE_ORDER
[
type1
]
TYPE_ORDER
[
type2
]
)
;
if
(
res
!
=
=
0
)
{
return
res
;
}
switch
(
type1
)
{
case
'
boolean
'
:
case
'
number
'
:
return
spaceship
(
v
w
)
;
case
'
string
'
:
return
spaceship
(
v
.
localeCompare
(
w
)
0
)
;
case
'
array
'
:
var
vLen
=
v
.
length
;
var
wLen
=
w
.
length
;
var
len
=
Math
.
min
(
vLen
wLen
)
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
r
=
compare
(
v
[
i
]
w
[
i
]
)
;
if
(
r
!
=
=
0
)
{
return
r
;
}
}
return
spaceship
(
vLen
wLen
)
;
case
'
instance
'
:
if
(
_emberRuntimeMixinsComparable
.
default
&
&
_emberRuntimeMixinsComparable
.
default
.
detect
(
v
)
)
{
return
v
.
compare
(
v
w
)
;
}
return
0
;
case
'
date
'
:
return
spaceship
(
v
.
getTime
(
)
w
.
getTime
(
)
)
;
default
:
return
0
;
}
}
}
)
;
enifed
(
'
ember
-
runtime
/
computed
/
reduce_computed_macros
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
observer
'
'
ember
-
runtime
/
compare
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
system
/
native_array
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
get_properties
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
weak_map
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalError
_emberMetalComputed
_emberMetalObserver
_emberRuntimeCompare
_emberRuntimeUtils
_emberRuntimeSystemNative_array
_emberMetalIs_none
_emberMetalGet_properties
_emberMetalEmpty_object
_emberMetalUtils
_emberMetalWeak_map
)
{
'
use
strict
'
;
exports
.
sum
=
sum
;
exports
.
max
=
max
;
exports
.
min
=
min
;
exports
.
map
=
map
;
exports
.
mapBy
=
mapBy
;
exports
.
filter
=
filter
;
exports
.
filterBy
=
filterBy
;
exports
.
uniq
=
uniq
;
exports
.
uniqBy
=
uniqBy
;
exports
.
intersect
=
intersect
;
exports
.
setDiff
=
setDiff
;
exports
.
collect
=
collect
;
exports
.
sort
=
sort
;
function
reduceMacro
(
dependentKey
callback
initialValue
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
+
'
.
[
]
'
function
(
)
{
var
_this
=
this
;
var
arr
=
_emberMetalProperty_get
.
get
(
this
dependentKey
)
;
if
(
arr
=
=
=
null
|
|
typeof
arr
!
=
=
'
object
'
)
{
return
initialValue
;
}
return
arr
.
reduce
(
function
(
previousValue
currentValue
index
array
)
{
return
callback
.
call
(
_this
previousValue
currentValue
index
array
)
;
}
initialValue
)
;
}
)
.
readOnly
(
)
;
}
function
arrayMacro
(
dependentKey
callback
)
{
var
propertyName
;
if
(
/
each
/
.
test
(
dependentKey
)
)
{
propertyName
=
dependentKey
.
replace
(
/
\
.
each
.
*
/
'
'
)
;
}
else
{
propertyName
=
dependentKey
;
dependentKey
+
=
'
.
[
]
'
;
}
return
_emberMetalComputed
.
computed
(
dependentKey
function
(
)
{
var
value
=
_emberMetalProperty_get
.
get
(
this
propertyName
)
;
if
(
_emberRuntimeUtils
.
isArray
(
value
)
)
{
return
_emberRuntimeSystemNative_array
.
A
(
callback
.
call
(
this
value
)
)
;
}
else
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
}
)
.
readOnly
(
)
;
}
function
multiArrayMacro
(
dependentKeys
callback
)
{
var
args
=
dependentKeys
.
map
(
function
(
key
)
{
return
key
+
'
.
[
]
'
;
}
)
;
args
.
push
(
function
(
)
{
return
_emberRuntimeSystemNative_array
.
A
(
callback
.
call
(
this
dependentKeys
)
)
;
}
)
;
return
_emberMetalComputed
.
computed
.
apply
(
this
args
)
.
readOnly
(
)
;
}
function
sum
(
dependentKey
)
{
return
reduceMacro
(
dependentKey
function
(
sum
item
)
{
return
sum
+
item
;
}
0
)
;
}
function
max
(
dependentKey
)
{
return
reduceMacro
(
dependentKey
function
(
max
item
)
{
return
Math
.
max
(
max
item
)
;
}
-
Infinity
)
;
}
function
min
(
dependentKey
)
{
return
reduceMacro
(
dependentKey
function
(
min
item
)
{
return
Math
.
min
(
min
item
)
;
}
Infinity
)
;
}
function
map
(
dependentKey
callback
)
{
return
arrayMacro
(
dependentKey
function
(
value
)
{
return
value
.
map
(
callback
this
)
;
}
)
;
}
function
mapBy
(
dependentKey
propertyKey
)
{
_emberMetalDebug
.
assert
(
'
Ember
.
computed
.
mapBy
expects
a
property
string
for
its
second
argument
'
+
'
perhaps
you
meant
to
use
"
map
"
'
typeof
propertyKey
=
=
=
'
string
'
)
;
return
map
(
dependentKey
+
'
.
each
.
'
+
propertyKey
function
(
item
)
{
return
_emberMetalProperty_get
.
get
(
item
propertyKey
)
;
}
)
;
}
function
filter
(
dependentKey
callback
)
{
return
arrayMacro
(
dependentKey
function
(
value
)
{
return
value
.
filter
(
callback
this
)
;
}
)
;
}
function
filterBy
(
dependentKey
propertyKey
value
)
{
var
callback
;
if
(
arguments
.
length
=
=
=
2
)
{
callback
=
function
(
item
)
{
return
_emberMetalProperty_get
.
get
(
item
propertyKey
)
;
}
;
}
else
{
callback
=
function
(
item
)
{
return
_emberMetalProperty_get
.
get
(
item
propertyKey
)
=
=
=
value
;
}
;
}
return
filter
(
dependentKey
+
'
.
each
.
'
+
propertyKey
callback
)
;
}
function
uniq
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
multiArrayMacro
(
args
function
(
dependentKeys
)
{
var
_this2
=
this
;
var
uniq
=
_emberRuntimeSystemNative_array
.
A
(
)
;
dependentKeys
.
forEach
(
function
(
dependentKey
)
{
var
value
=
_emberMetalProperty_get
.
get
(
_this2
dependentKey
)
;
if
(
_emberRuntimeUtils
.
isArray
(
value
)
)
{
value
.
forEach
(
function
(
item
)
{
if
(
uniq
.
indexOf
(
item
)
=
=
=
-
1
)
{
uniq
.
push
(
item
)
;
}
}
)
;
}
}
)
;
return
uniq
;
}
)
;
}
function
uniqBy
(
dependentKey
propertyKey
)
{
return
_emberMetalComputed
.
computed
(
dependentKey
+
'
.
[
]
'
function
(
)
{
var
uniq
=
_emberRuntimeSystemNative_array
.
A
(
)
;
var
seen
=
new
_emberMetalEmpty_object
.
default
(
)
;
var
list
=
_emberMetalProperty_get
.
get
(
this
dependentKey
)
;
if
(
_emberRuntimeUtils
.
isArray
(
list
)
)
{
list
.
forEach
(
function
(
item
)
{
var
guid
=
_emberMetalUtils
.
guidFor
(
_emberMetalProperty_get
.
get
(
item
propertyKey
)
)
;
if
(
!
(
guid
in
seen
)
)
{
seen
[
guid
]
=
true
;
uniq
.
push
(
item
)
;
}
}
)
;
}
return
uniq
;
}
)
.
readOnly
(
)
;
}
var
union
=
uniq
;
exports
.
union
=
union
;
function
intersect
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
multiArrayMacro
(
args
function
(
dependentKeys
)
{
var
_this3
=
this
;
var
arrays
=
dependentKeys
.
map
(
function
(
dependentKey
)
{
var
array
=
_emberMetalProperty_get
.
get
(
_this3
dependentKey
)
;
return
_emberRuntimeUtils
.
isArray
(
array
)
?
array
:
[
]
;
}
)
;
var
results
=
arrays
.
pop
(
)
.
filter
(
function
(
candidate
)
{
for
(
var
i
=
0
;
i
<
arrays
.
length
;
i
+
+
)
{
var
found
=
false
;
var
array
=
arrays
[
i
]
;
for
(
var
j
=
0
;
j
<
array
.
length
;
j
+
+
)
{
if
(
array
[
j
]
=
=
=
candidate
)
{
found
=
true
;
break
;
}
}
if
(
found
=
=
=
false
)
{
return
false
;
}
}
return
true
;
}
)
;
return
_emberRuntimeSystemNative_array
.
A
(
results
)
;
}
)
;
}
function
setDiff
(
setAProperty
setBProperty
)
{
if
(
arguments
.
length
!
=
=
2
)
{
throw
new
_emberMetalError
.
default
(
'
setDiff
requires
exactly
two
dependent
arrays
.
'
)
;
}
return
_emberMetalComputed
.
computed
(
setAProperty
+
'
.
[
]
'
setBProperty
+
'
.
[
]
'
function
(
)
{
var
setA
=
this
.
get
(
setAProperty
)
;
var
setB
=
this
.
get
(
setBProperty
)
;
if
(
!
_emberRuntimeUtils
.
isArray
(
setA
)
)
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
if
(
!
_emberRuntimeUtils
.
isArray
(
setB
)
)
{
return
_emberRuntimeSystemNative_array
.
A
(
setA
)
;
}
return
setA
.
filter
(
function
(
x
)
{
return
setB
.
indexOf
(
x
)
=
=
=
-
1
;
}
)
;
}
)
.
readOnly
(
)
;
}
function
collect
(
)
{
for
(
var
_len3
=
arguments
.
length
dependentKeys
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
dependentKeys
[
_key3
]
=
arguments
[
_key3
]
;
}
return
multiArrayMacro
(
dependentKeys
function
(
)
{
var
properties
=
_emberMetalGet_properties
.
default
(
this
dependentKeys
)
;
var
res
=
_emberRuntimeSystemNative_array
.
A
(
)
;
for
(
var
key
in
properties
)
{
if
(
properties
.
hasOwnProperty
(
key
)
)
{
if
(
_emberMetalIs_none
.
default
(
properties
[
key
]
)
)
{
res
.
push
(
null
)
;
}
else
{
res
.
push
(
properties
[
key
]
)
;
}
}
}
return
res
;
}
)
;
}
function
sort
(
itemsKey
sortDefinition
)
{
_emberMetalDebug
.
assert
(
'
Ember
.
computed
.
sort
requires
two
arguments
:
an
array
key
to
sort
and
'
+
'
either
a
sort
properties
key
or
sort
function
'
arguments
.
length
=
=
=
2
)
;
if
(
typeof
sortDefinition
=
=
=
'
function
'
)
{
return
customSort
(
itemsKey
sortDefinition
)
;
}
else
{
return
propertySort
(
itemsKey
sortDefinition
)
;
}
}
function
customSort
(
itemsKey
comparator
)
{
return
arrayMacro
(
itemsKey
function
(
value
)
{
var
_this4
=
this
;
return
value
.
slice
(
)
.
sort
(
function
(
x
y
)
{
return
comparator
.
call
(
_this4
x
y
)
;
}
)
;
}
)
;
}
function
propertySort
(
itemsKey
sortPropertiesKey
)
{
var
cp
=
new
_emberMetalComputed
.
ComputedProperty
(
function
(
key
)
{
var
_this5
=
this
;
var
itemsKeyIsAtThis
=
itemsKey
=
=
=
'
this
'
;
var
sortProperties
=
_emberMetalProperty_get
.
get
(
this
sortPropertiesKey
)
;
_emberMetalDebug
.
assert
(
'
The
sort
definition
for
\
'
'
+
key
+
'
\
'
on
'
+
this
+
'
must
be
a
function
or
an
array
of
strings
'
_emberRuntimeUtils
.
isArray
(
sortProperties
)
&
&
sortProperties
.
every
(
function
(
s
)
{
return
typeof
s
=
=
=
'
string
'
;
}
)
)
;
var
normalizedSortProperties
=
normalizeSortProperties
(
sortProperties
)
;
var
activeObserversMap
=
cp
.
_activeObserverMap
|
|
(
cp
.
_activeObserverMap
=
new
_emberMetalWeak_map
.
default
(
)
)
;
var
activeObservers
=
activeObserversMap
.
get
(
this
)
;
if
(
activeObservers
)
{
activeObservers
.
forEach
(
function
(
args
)
{
_emberMetalObserver
.
removeObserver
.
apply
(
null
args
)
;
}
)
;
}
function
sortPropertyDidChange
(
)
{
this
.
notifyPropertyChange
(
key
)
;
}
activeObservers
=
normalizedSortProperties
.
map
(
function
(
_ref
)
{
var
prop
=
_ref
[
0
]
;
var
path
=
itemsKeyIsAtThis
?
'
each
.
'
+
prop
:
itemsKey
+
'
.
each
.
'
+
prop
;
var
args
=
[
_this5
path
sortPropertyDidChange
]
;
_emberMetalObserver
.
addObserver
.
apply
(
null
args
)
;
return
args
;
}
)
;
activeObserversMap
.
set
(
this
activeObservers
)
;
var
items
=
itemsKeyIsAtThis
?
this
:
_emberMetalProperty_get
.
get
(
this
itemsKey
)
;
if
(
_emberRuntimeUtils
.
isArray
(
items
)
)
{
return
sortByNormalizedSortProperties
(
items
normalizedSortProperties
)
;
}
else
{
return
_emberRuntimeSystemNative_array
.
A
(
)
;
}
}
)
;
cp
.
_activeObserverMap
=
undefined
;
return
cp
.
property
(
sortPropertiesKey
+
'
.
[
]
'
)
.
readOnly
(
)
;
}
function
normalizeSortProperties
(
sortProperties
)
{
return
sortProperties
.
map
(
function
(
p
)
{
var
_p
split
=
p
.
split
(
'
:
'
)
;
var
prop
=
_p
split
[
0
]
;
var
direction
=
_p
split
[
1
]
;
direction
=
direction
|
|
'
asc
'
;
return
[
prop
direction
]
;
}
)
;
}
function
sortByNormalizedSortProperties
(
items
normalizedSortProperties
)
{
return
_emberRuntimeSystemNative_array
.
A
(
items
.
slice
(
)
.
sort
(
function
(
itemA
itemB
)
{
for
(
var
i
=
0
;
i
<
normalizedSortProperties
.
length
;
i
+
+
)
{
var
_normalizedSortProperties
i
=
normalizedSortProperties
[
i
]
;
var
prop
=
_normalizedSortProperties
i
[
0
]
;
var
direction
=
_normalizedSortProperties
i
[
1
]
;
var
result
=
_emberRuntimeCompare
.
default
(
_emberMetalProperty_get
.
get
(
itemA
prop
)
_emberMetalProperty_get
.
get
(
itemB
prop
)
)
;
if
(
result
!
=
=
0
)
{
return
direction
=
=
=
'
desc
'
?
-
1
*
result
:
result
;
}
}
return
0
;
}
)
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
controllers
/
controller
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
controller
'
'
ember
-
runtime
/
inject
'
'
ember
-
runtime
/
mixins
/
action_handler
'
]
function
(
exports
_emberMetalDebug
_emberRuntimeSystemObject
_emberRuntimeMixinsController
_emberRuntimeInject
_emberRuntimeMixinsAction_handler
)
{
'
use
strict
'
;
var
Controller
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsController
.
default
)
;
_emberRuntimeMixinsAction_handler
.
deprecateUnderscoreActions
(
Controller
)
;
function
controllerInjectionHelper
(
factory
)
{
_emberMetalDebug
.
assert
(
'
Defining
an
injected
controller
property
on
a
'
+
'
non
-
controller
is
not
allowed
.
'
_emberRuntimeMixinsController
.
default
.
detect
(
factory
.
PrototypeMixin
)
)
;
}
_emberRuntimeInject
.
createInjectionHelper
(
'
controller
'
controllerInjectionHelper
)
;
exports
.
default
=
Controller
;
}
)
;
enifed
(
'
ember
-
runtime
/
copy
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
copyable
'
]
function
(
exports
_emberMetalDebug
_emberRuntimeSystemObject
_emberRuntimeMixinsCopyable
)
{
'
use
strict
'
;
exports
.
default
=
copy
;
function
_copy
(
obj
deep
seen
copies
)
{
var
ret
loc
key
;
if
(
typeof
obj
!
=
=
'
object
'
|
|
obj
=
=
=
null
)
{
return
obj
;
}
if
(
deep
&
&
(
loc
=
seen
.
indexOf
(
obj
)
)
>
=
0
)
{
return
copies
[
loc
]
;
}
_emberMetalDebug
.
assert
(
'
Cannot
clone
an
Ember
.
Object
that
does
not
implement
Ember
.
Copyable
'
!
(
obj
instanceof
_emberRuntimeSystemObject
.
default
)
|
|
_emberRuntimeMixinsCopyable
.
default
&
&
_emberRuntimeMixinsCopyable
.
default
.
detect
(
obj
)
)
;
if
(
Array
.
isArray
(
obj
)
)
{
ret
=
obj
.
slice
(
)
;
if
(
deep
)
{
loc
=
ret
.
length
;
while
(
-
-
loc
>
=
0
)
{
ret
[
loc
]
=
_copy
(
ret
[
loc
]
deep
seen
copies
)
;
}
}
}
else
if
(
_emberRuntimeMixinsCopyable
.
default
&
&
_emberRuntimeMixinsCopyable
.
default
.
detect
(
obj
)
)
{
ret
=
obj
.
copy
(
deep
seen
copies
)
;
}
else
if
(
obj
instanceof
Date
)
{
ret
=
new
Date
(
obj
.
getTime
(
)
)
;
}
else
{
ret
=
{
}
;
for
(
key
in
obj
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
continue
;
}
if
(
key
.
substring
(
0
2
)
=
=
=
'
__
'
)
{
continue
;
}
ret
[
key
]
=
deep
?
_copy
(
obj
[
key
]
deep
seen
copies
)
:
obj
[
key
]
;
}
}
if
(
deep
)
{
seen
.
push
(
obj
)
;
copies
.
push
(
ret
)
;
}
return
ret
;
}
function
copy
(
obj
deep
)
{
if
(
'
object
'
!
=
=
typeof
obj
|
|
obj
=
=
=
null
)
{
return
obj
;
}
if
(
_emberRuntimeMixinsCopyable
.
default
&
&
_emberRuntimeMixinsCopyable
.
default
.
detect
(
obj
)
)
{
return
obj
.
copy
(
deep
)
;
}
return
_copy
(
obj
deep
deep
?
[
]
:
null
deep
?
[
]
:
null
)
;
}
}
)
;
enifed
(
"
ember
-
runtime
/
core
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
}
)
;
enifed
(
'
ember
-
runtime
/
ext
/
function
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberMetalComputed
_emberMetalMixin
)
{
'
use
strict
'
;
var
a_slice
=
Array
.
prototype
.
slice
;
var
FunctionPrototype
=
Function
.
prototype
;
if
(
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
=
=
=
true
|
|
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
.
Function
)
{
FunctionPrototype
.
property
=
function
(
)
{
var
ret
=
_emberMetalComputed
.
computed
(
this
)
;
return
ret
.
property
.
apply
(
ret
arguments
)
;
}
;
FunctionPrototype
.
observes
=
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
args
.
push
(
this
)
;
return
_emberMetalMixin
.
observer
.
apply
(
this
args
)
;
}
;
FunctionPrototype
.
_observesImmediately
=
function
(
)
{
_emberMetalDebug
.
assert
(
'
Immediate
observers
must
observe
internal
properties
only
'
+
'
not
properties
on
other
objects
.
'
function
checkIsInternalProperty
(
)
{
for
(
var
i
=
0
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
if
(
arguments
[
i
]
.
indexOf
(
'
.
'
)
!
=
=
-
1
)
{
return
false
;
}
}
return
true
;
}
)
;
return
this
.
observes
.
apply
(
this
arguments
)
;
}
;
FunctionPrototype
.
observesImmediately
=
_emberMetalDebug
.
deprecateFunc
(
'
Function
#
observesImmediately
is
deprecated
.
Use
Function
#
observes
instead
'
{
id
:
'
ember
-
runtime
.
ext
-
function
'
until
:
'
3
.
0
.
0
'
}
FunctionPrototype
.
_observesImmediately
)
;
FunctionPrototype
.
on
=
function
(
)
{
var
events
=
a_slice
.
call
(
arguments
)
;
this
.
__ember_listens__
=
events
;
return
this
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
ext
/
rsvp
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
require
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
logger
'
'
ember
-
metal
/
run_loop
'
'
rsvp
'
]
function
(
exports
_emberMetalCore
_require
_emberMetalDebug
_emberMetalLogger
_emberMetalRun_loop
_rsvp
)
{
'
use
strict
'
;
exports
.
onerrorDefault
=
onerrorDefault
;
exports
.
after
=
after
;
var
testModuleName
=
'
ember
-
testing
/
test
'
;
var
Test
;
var
asyncStart
=
function
(
)
{
if
(
_emberMetalCore
.
default
.
Test
&
&
_emberMetalCore
.
default
.
Test
.
adapter
)
{
_emberMetalCore
.
default
.
Test
.
adapter
.
asyncStart
(
)
;
}
}
;
var
asyncEnd
=
function
(
)
{
if
(
_emberMetalCore
.
default
.
Test
&
&
_emberMetalCore
.
default
.
Test
.
adapter
)
{
_emberMetalCore
.
default
.
Test
.
adapter
.
asyncEnd
(
)
;
}
}
;
_rsvp
.
configure
(
'
async
'
function
(
callback
promise
)
{
var
async
=
!
_emberMetalRun_loop
.
default
.
currentRunLoop
;
if
(
_emberMetalCore
.
default
.
testing
&
&
async
)
{
asyncStart
(
)
;
}
_emberMetalRun_loop
.
default
.
backburner
.
schedule
(
'
actions
'
function
(
)
{
if
(
_emberMetalCore
.
default
.
testing
&
&
async
)
{
asyncEnd
(
)
;
}
callback
(
promise
)
;
}
)
;
}
)
;
function
onerrorDefault
(
reason
)
{
var
error
;
if
(
reason
&
&
reason
.
errorThrown
)
{
error
=
reason
.
errorThrown
;
if
(
typeof
error
=
=
=
'
string
'
)
{
error
=
new
Error
(
error
)
;
}
Object
.
defineProperty
(
error
'
__reason_with_error_thrown__
'
{
value
:
reason
enumerable
:
false
}
)
;
}
else
{
error
=
reason
;
}
if
(
error
&
&
error
.
name
=
=
=
'
UnrecognizedURLError
'
)
{
_emberMetalDebug
.
assert
(
'
The
URL
\
'
'
+
error
.
message
+
'
\
'
did
not
match
any
routes
in
your
application
'
false
)
;
return
;
}
if
(
error
&
&
error
.
name
!
=
=
'
TransitionAborted
'
)
{
if
(
_emberMetalCore
.
default
.
testing
)
{
if
(
!
Test
&
&
_require
.
has
(
testModuleName
)
)
{
Test
=
_require
.
default
(
testModuleName
)
[
'
default
'
]
;
}
if
(
Test
&
&
Test
.
adapter
)
{
Test
.
adapter
.
exception
(
error
)
;
_emberMetalLogger
.
default
.
error
(
error
.
stack
)
;
}
else
{
throw
error
;
}
}
else
if
(
_emberMetalCore
.
default
.
onerror
)
{
_emberMetalCore
.
default
.
onerror
(
error
)
;
}
else
{
_emberMetalLogger
.
default
.
error
(
error
.
stack
)
;
}
}
}
function
after
(
cb
)
{
_emberMetalRun_loop
.
default
.
schedule
(
_emberMetalRun_loop
.
default
.
queues
[
_emberMetalRun_loop
.
default
.
queues
.
length
-
1
]
cb
)
;
}
_rsvp
.
on
(
'
error
'
onerrorDefault
)
;
_rsvp
.
configure
(
'
after
'
after
)
;
exports
.
default
=
_rsvp
;
}
)
;
enifed
(
'
ember
-
runtime
/
ext
/
string
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
runtime
/
system
/
string
'
]
function
(
exports
_emberMetalCore
_emberRuntimeSystemString
)
{
'
use
strict
'
;
var
StringPrototype
=
String
.
prototype
;
if
(
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
=
=
=
true
|
|
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
.
String
)
{
StringPrototype
.
fmt
=
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
_emberRuntimeSystemString
.
fmt
(
this
args
)
;
}
;
StringPrototype
.
w
=
function
(
)
{
return
_emberRuntimeSystemString
.
w
(
this
)
;
}
;
StringPrototype
.
loc
=
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
_emberRuntimeSystemString
.
loc
(
this
args
)
;
}
;
StringPrototype
.
camelize
=
function
(
)
{
return
_emberRuntimeSystemString
.
camelize
(
this
)
;
}
;
StringPrototype
.
decamelize
=
function
(
)
{
return
_emberRuntimeSystemString
.
decamelize
(
this
)
;
}
;
StringPrototype
.
dasherize
=
function
(
)
{
return
_emberRuntimeSystemString
.
dasherize
(
this
)
;
}
;
StringPrototype
.
underscore
=
function
(
)
{
return
_emberRuntimeSystemString
.
underscore
(
this
)
;
}
;
StringPrototype
.
classify
=
function
(
)
{
return
_emberRuntimeSystemString
.
classify
(
this
)
;
}
;
StringPrototype
.
capitalize
=
function
(
)
{
return
_emberRuntimeSystemString
.
capitalize
(
this
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
index
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
/
is
-
equal
'
'
ember
-
runtime
/
compare
'
'
ember
-
runtime
/
copy
'
'
ember
-
runtime
/
inject
'
'
ember
-
runtime
/
system
/
namespace
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
system
/
container
'
'
ember
-
runtime
/
system
/
array_proxy
'
'
ember
-
runtime
/
system
/
object_proxy
'
'
ember
-
runtime
/
system
/
core_object
'
'
ember
-
runtime
/
system
/
native_array
'
'
ember
-
runtime
/
system
/
string
'
'
ember
-
runtime
/
system
/
lazy_load
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
mixins
/
comparable
'
'
ember
-
runtime
/
mixins
/
copyable
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
runtime
/
mixins
/
freezable
'
'
ember
-
runtime
/
mixins
/
-
proxy
'
'
ember
-
runtime
/
mixins
/
observable
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
runtime
/
mixins
/
mutable_enumerable
'
'
ember
-
runtime
/
mixins
/
mutable_array
'
'
ember
-
runtime
/
mixins
/
target_action_support
'
'
ember
-
runtime
/
mixins
/
evented
'
'
ember
-
runtime
/
mixins
/
promise_proxy
'
'
ember
-
metal
/
features
'
'
ember
-
runtime
/
computed
/
reduce_computed_macros
'
'
ember
-
runtime
/
controllers
/
controller
'
'
ember
-
runtime
/
mixins
/
controller
'
'
ember
-
runtime
/
system
/
service
'
'
ember
-
runtime
/
ext
/
rsvp
'
'
ember
-
runtime
/
ext
/
string
'
'
ember
-
runtime
/
ext
/
function
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
mixins
/
registry_proxy
'
'
ember
-
runtime
/
mixins
/
container_proxy
'
'
ember
-
runtime
/
string_registry
'
]
function
(
exports
_emberMetal
_emberRuntimeIsEqual
_emberRuntimeCompare
_emberRuntimeCopy
_emberRuntimeInject
_emberRuntimeSystemNamespace
_emberRuntimeSystemObject
_emberRuntimeSystemContainer
_emberRuntimeSystemArray_proxy
_emberRuntimeSystemObject_proxy
_emberRuntimeSystemCore_object
_emberRuntimeSystemNative_array
_emberRuntimeSystemString
_emberRuntimeSystemLazy_load
_emberRuntimeMixinsArray
_emberRuntimeMixinsComparable
_emberRuntimeMixinsCopyable
_emberRuntimeMixinsEnumerable
_emberRuntimeMixinsFreezable
_emberRuntimeMixinsProxy
_emberRuntimeMixinsObservable
_emberRuntimeMixinsAction_handler
_emberRuntimeMixinsMutable_enumerable
_emberRuntimeMixinsMutable_array
_emberRuntimeMixinsTarget_action_support
_emberRuntimeMixinsEvented
_emberRuntimeMixinsPromise_proxy
_emberMetalFeatures
_emberRuntimeComputedReduce_computed_macros
_emberRuntimeControllersController
_emberRuntimeMixinsController
_emberRuntimeSystemService
_emberRuntimeExtRsvp
_emberRuntimeExtString
_emberRuntimeExtFunction
_emberRuntimeUtils
_emberRuntimeMixinsRegistry_proxy
_emberRuntimeMixinsContainer_proxy
_emberRuntimeString_registry
)
{
'
use
strict
'
;
_emberMetal
.
default
.
compare
=
_emberRuntimeCompare
.
default
;
_emberMetal
.
default
.
copy
=
_emberRuntimeCopy
.
default
;
_emberMetal
.
default
.
isEqual
=
_emberRuntimeIsEqual
.
default
;
_emberMetal
.
default
.
inject
=
_emberRuntimeInject
.
default
;
_emberMetal
.
default
.
Array
=
_emberRuntimeMixinsArray
.
default
;
_emberMetal
.
default
.
Comparable
=
_emberRuntimeMixinsComparable
.
default
;
_emberMetal
.
default
.
Copyable
=
_emberRuntimeMixinsCopyable
.
default
;
_emberMetal
.
default
.
Freezable
=
_emberRuntimeMixinsFreezable
.
Freezable
;
_emberMetal
.
default
.
FROZEN_ERROR
=
_emberRuntimeMixinsFreezable
.
FROZEN_ERROR
;
_emberMetal
.
default
.
MutableEnumerable
=
_emberRuntimeMixinsMutable_enumerable
.
default
;
_emberMetal
.
default
.
MutableArray
=
_emberRuntimeMixinsMutable_array
.
default
;
_emberMetal
.
default
.
TargetActionSupport
=
_emberRuntimeMixinsTarget_action_support
.
default
;
_emberMetal
.
default
.
Evented
=
_emberRuntimeMixinsEvented
.
default
;
_emberMetal
.
default
.
PromiseProxyMixin
=
_emberRuntimeMixinsPromise_proxy
.
default
;
_emberMetal
.
default
.
Observable
=
_emberRuntimeMixinsObservable
.
default
;
_emberMetal
.
default
.
typeOf
=
_emberRuntimeUtils
.
typeOf
;
_emberMetal
.
default
.
isArray
=
_emberRuntimeUtils
.
isArray
;
var
EmComputed
=
_emberMetal
.
default
.
computed
;
EmComputed
.
sum
=
_emberRuntimeComputedReduce_computed_macros
.
sum
;
EmComputed
.
min
=
_emberRuntimeComputedReduce_computed_macros
.
min
;
EmComputed
.
max
=
_emberRuntimeComputedReduce_computed_macros
.
max
;
EmComputed
.
map
=
_emberRuntimeComputedReduce_computed_macros
.
map
;
EmComputed
.
sort
=
_emberRuntimeComputedReduce_computed_macros
.
sort
;
EmComputed
.
setDiff
=
_emberRuntimeComputedReduce_computed_macros
.
setDiff
;
EmComputed
.
mapBy
=
_emberRuntimeComputedReduce_computed_macros
.
mapBy
;
EmComputed
.
filter
=
_emberRuntimeComputedReduce_computed_macros
.
filter
;
EmComputed
.
filterBy
=
_emberRuntimeComputedReduce_computed_macros
.
filterBy
;
EmComputed
.
uniq
=
_emberRuntimeComputedReduce_computed_macros
.
uniq
;
EmComputed
.
union
=
_emberRuntimeComputedReduce_computed_macros
.
union
;
EmComputed
.
intersect
=
_emberRuntimeComputedReduce_computed_macros
.
intersect
;
EmComputed
.
collect
=
_emberRuntimeComputedReduce_computed_macros
.
collect
;
_emberMetal
.
default
.
String
=
_emberRuntimeSystemString
.
default
;
_emberMetal
.
default
.
Object
=
_emberRuntimeSystemObject
.
default
;
_emberMetal
.
default
.
Container
=
_emberRuntimeSystemContainer
.
Container
;
_emberMetal
.
default
.
Registry
=
_emberRuntimeSystemContainer
.
Registry
;
_emberMetal
.
default
.
getOwner
=
_emberRuntimeSystemContainer
.
getOwner
;
_emberMetal
.
default
.
setOwner
=
_emberRuntimeSystemContainer
.
setOwner
;
_emberMetal
.
default
.
_RegistryProxyMixin
=
_emberRuntimeMixinsRegistry_proxy
.
default
;
_emberMetal
.
default
.
_ContainerProxyMixin
=
_emberRuntimeMixinsContainer_proxy
.
default
;
_emberMetal
.
default
.
Namespace
=
_emberRuntimeSystemNamespace
.
default
;
_emberMetal
.
default
.
Enumerable
=
_emberRuntimeMixinsEnumerable
.
default
;
_emberMetal
.
default
.
ArrayProxy
=
_emberRuntimeSystemArray_proxy
.
default
;
_emberMetal
.
default
.
ObjectProxy
=
_emberRuntimeSystemObject_proxy
.
default
;
_emberMetal
.
default
.
ActionHandler
=
_emberRuntimeMixinsAction_handler
.
default
;
_emberMetal
.
default
.
CoreObject
=
_emberRuntimeSystemCore_object
.
default
;
_emberMetal
.
default
.
NativeArray
=
_emberRuntimeSystemNative_array
.
default
;
_emberMetal
.
default
.
onLoad
=
_emberRuntimeSystemLazy_load
.
onLoad
;
_emberMetal
.
default
.
runLoadHooks
=
_emberRuntimeSystemLazy_load
.
runLoadHooks
;
_emberMetal
.
default
.
Controller
=
_emberRuntimeControllersController
.
default
;
_emberMetal
.
default
.
ControllerMixin
=
_emberRuntimeMixinsController
.
default
;
_emberMetal
.
default
.
Service
=
_emberRuntimeSystemService
.
default
;
_emberMetal
.
default
.
_ProxyMixin
=
_emberRuntimeMixinsProxy
.
default
;
_emberMetal
.
default
.
RSVP
=
_emberRuntimeExtRsvp
.
default
;
Object
.
defineProperty
(
_emberMetal
.
default
'
STRINGS
'
{
configurable
:
false
get
:
_emberRuntimeString_registry
.
getStrings
set
:
_emberRuntimeString_registry
.
setStrings
}
)
;
exports
.
default
=
_emberMetal
.
default
;
}
)
;
enifed
(
'
ember
-
runtime
/
inject
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
injected_property
'
]
function
(
exports
_emberMetalDebug
_emberMetalInjected_property
)
{
'
use
strict
'
;
exports
.
default
=
inject
;
exports
.
createInjectionHelper
=
createInjectionHelper
;
exports
.
validatePropertyInjections
=
validatePropertyInjections
;
function
inject
(
)
{
_emberMetalDebug
.
assert
(
'
Injected
properties
must
be
created
through
helpers
see
\
'
'
+
Object
.
keys
(
inject
)
.
join
(
'
"
'
'
"
'
)
+
'
\
'
'
)
;
}
var
typeValidators
=
{
}
;
function
createInjectionHelper
(
type
validator
)
{
typeValidators
[
type
]
=
validator
;
inject
[
type
]
=
function
(
name
)
{
return
new
_emberMetalInjected_property
.
default
(
type
name
)
;
}
;
}
function
validatePropertyInjections
(
factory
)
{
var
proto
=
factory
.
proto
(
)
;
var
types
=
[
]
;
var
key
desc
validator
i
l
;
for
(
key
in
proto
)
{
desc
=
proto
[
key
]
;
if
(
desc
instanceof
_emberMetalInjected_property
.
default
&
&
types
.
indexOf
(
desc
.
type
)
=
=
=
-
1
)
{
types
.
push
(
desc
.
type
)
;
}
}
if
(
types
.
length
)
{
for
(
i
=
0
l
=
types
.
length
;
i
<
l
;
i
+
+
)
{
validator
=
typeValidators
[
types
[
i
]
]
;
if
(
typeof
validator
=
=
=
'
function
'
)
{
validator
(
factory
)
;
}
}
}
return
true
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
is
-
equal
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
isEqual
;
function
isEqual
(
a
b
)
{
if
(
a
&
&
typeof
a
.
isEqual
=
=
=
'
function
'
)
{
return
a
.
isEqual
(
b
)
;
}
if
(
a
instanceof
Date
&
&
b
instanceof
Date
)
{
return
a
.
getTime
(
)
=
=
=
b
.
getTime
(
)
;
}
return
a
=
=
=
b
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
-
proxy
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalMeta
_emberMetalObserver
_emberMetalProperty_events
_emberMetalComputed
_emberMetalProperties
_emberMetalMixin
_emberMetalSymbol
)
{
'
use
strict
'
;
var
_Mixin
create
;
exports
.
isProxy
=
isProxy
;
var
IS_PROXY
=
_emberMetalSymbol
.
default
(
'
IS_PROXY
'
)
;
function
isProxy
(
value
)
{
return
value
&
&
value
[
IS_PROXY
]
;
}
function
contentPropertyWillChange
(
content
contentKey
)
{
var
key
=
contentKey
.
slice
(
8
)
;
if
(
key
in
this
)
{
return
;
}
_emberMetalProperty_events
.
propertyWillChange
(
this
key
)
;
}
function
contentPropertyDidChange
(
content
contentKey
)
{
var
key
=
contentKey
.
slice
(
8
)
;
if
(
key
in
this
)
{
return
;
}
_emberMetalProperty_events
.
propertyDidChange
(
this
key
)
;
}
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
(
_Mixin
create
=
{
}
_Mixin
create
[
IS_PROXY
]
=
true
_Mixin
create
.
content
=
null
_Mixin
create
.
_contentDidChange
=
_emberMetalMixin
.
observer
(
'
content
'
function
(
)
{
_emberMetalDebug
.
assert
(
'
Can
\
'
t
set
Proxy
\
'
s
content
to
itself
'
_emberMetalProperty_get
.
get
(
this
'
content
'
)
!
=
=
this
)
;
}
)
_Mixin
create
.
isTruthy
=
_emberMetalComputed
.
computed
.
bool
(
'
content
'
)
_Mixin
create
.
_debugContainerKey
=
null
_Mixin
create
.
willWatchProperty
=
function
(
key
)
{
var
contentKey
=
'
content
.
'
+
key
;
_emberMetalObserver
.
_addBeforeObserver
(
this
contentKey
null
contentPropertyWillChange
)
;
_emberMetalObserver
.
addObserver
(
this
contentKey
null
contentPropertyDidChange
)
;
}
_Mixin
create
.
didUnwatchProperty
=
function
(
key
)
{
var
contentKey
=
'
content
.
'
+
key
;
_emberMetalObserver
.
_removeBeforeObserver
(
this
contentKey
null
contentPropertyWillChange
)
;
_emberMetalObserver
.
removeObserver
(
this
contentKey
null
contentPropertyDidChange
)
;
}
_Mixin
create
.
unknownProperty
=
function
(
key
)
{
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
if
(
content
)
{
_emberMetalDebug
.
deprecate
(
'
You
attempted
to
access
'
+
key
+
'
from
'
+
this
+
'
but
object
proxying
is
deprecated
.
Please
use
model
.
'
+
key
+
'
instead
.
'
!
this
.
isController
{
id
:
'
ember
-
runtime
.
controller
-
proxy
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_emberMetalProperty_get
.
get
(
content
key
)
;
}
}
_Mixin
create
.
setUnknownProperty
=
function
(
key
value
)
{
var
m
=
_emberMetalMeta
.
meta
(
this
)
;
if
(
m
.
proto
=
=
=
this
)
{
_emberMetalProperties
.
defineProperty
(
this
key
null
value
)
;
return
value
;
}
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
_emberMetalDebug
.
assert
(
'
Cannot
delegate
set
(
\
'
'
+
key
+
'
\
'
'
+
value
+
'
)
to
the
\
'
content
\
'
property
of
object
proxy
'
+
this
+
'
:
its
\
'
content
\
'
is
undefined
.
'
content
)
;
_emberMetalDebug
.
deprecate
(
'
You
attempted
to
set
'
+
key
+
'
from
'
+
this
+
'
but
object
proxying
is
deprecated
.
Please
use
model
.
'
+
key
+
'
instead
.
'
!
this
.
isController
{
id
:
'
ember
-
runtime
.
controller
-
proxy
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_emberMetalProperty_set
.
set
(
content
key
value
)
;
}
_Mixin
create
)
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
action_handler
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
_emberMetalProperty_get
)
{
'
use
strict
'
;
exports
.
deprecateUnderscoreActions
=
deprecateUnderscoreActions
;
var
ActionHandler
=
_emberMetalMixin
.
Mixin
.
create
(
{
mergedProperties
:
[
'
actions
'
]
send
:
function
(
actionName
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
target
;
if
(
this
.
actions
&
&
this
.
actions
[
actionName
]
)
{
var
shouldBubble
=
this
.
actions
[
actionName
]
.
apply
(
this
args
)
=
=
=
true
;
if
(
!
shouldBubble
)
{
return
;
}
}
if
(
target
=
_emberMetalProperty_get
.
get
(
this
'
target
'
)
)
{
var
_target
;
_emberMetalDebug
.
assert
(
'
The
target
for
'
+
this
+
'
(
'
+
target
+
'
)
does
not
have
a
send
method
'
typeof
target
.
send
=
=
=
'
function
'
)
;
(
_target
=
target
)
.
send
.
apply
(
_target
arguments
)
;
}
}
willMergeMixin
:
function
(
props
)
{
_emberMetalDebug
.
assert
(
'
Specifying
_actions
and
actions
in
the
same
mixin
is
not
supported
.
'
!
props
.
actions
|
|
!
props
.
_actions
)
;
if
(
props
.
_actions
)
{
_emberMetalDebug
.
deprecate
(
'
Specifying
actions
in
_actions
is
deprecated
please
use
actions
instead
.
'
false
{
id
:
'
ember
-
runtime
.
action
-
handler
-
_actions
'
until
:
'
3
.
0
.
0
'
}
)
;
props
.
actions
=
props
.
_actions
;
delete
props
.
_actions
;
}
}
}
)
;
exports
.
default
=
ActionHandler
;
function
deprecateUnderscoreActions
(
factory
)
{
Object
.
defineProperty
(
factory
.
prototype
'
_actions
'
{
configurable
:
true
enumerable
:
false
set
:
function
(
value
)
{
_emberMetalDebug
.
assert
(
'
You
cannot
set
_actions
on
'
+
this
+
'
please
use
actions
instead
.
'
)
;
}
get
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
Usage
of
_actions
is
deprecated
use
actions
instead
.
'
false
{
id
:
'
ember
-
runtime
.
action
-
handler
-
_actions
'
until
:
'
3
.
0
.
0
'
}
)
;
return
_emberMetalProperty_get
.
get
(
this
'
actions
'
)
;
}
}
)
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
array
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
symbol
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
is_none
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
tags
'
'
ember
-
runtime
/
system
/
each_proxy
'
]
function
(
exports
_emberMetalCore
_emberMetalSymbol
_emberMetalProperty_get
_emberMetalComputed
_emberMetalIs_none
_emberRuntimeMixinsEnumerable
_emberMetalMixin
_emberMetalProperty_events
_emberMetalEvents
_emberMetalMeta
_emberMetalTags
_emberRuntimeSystemEach_proxy
)
{
'
use
strict
'
;
var
_Mixin
create
;
exports
.
addArrayObserver
=
addArrayObserver
;
exports
.
removeArrayObserver
=
removeArrayObserver
;
exports
.
objectAt
=
objectAt
;
exports
.
isEmberArray
=
isEmberArray
;
function
arrayObserversHelper
(
obj
target
opts
operation
notify
)
{
var
willChange
=
opts
&
&
opts
.
willChange
|
|
'
arrayWillChange
'
;
var
didChange
=
opts
&
&
opts
.
didChange
|
|
'
arrayDidChange
'
;
var
hasObservers
=
_emberMetalProperty_get
.
get
(
obj
'
hasArrayObservers
'
)
;
if
(
hasObservers
=
=
=
notify
)
{
_emberMetalProperty_events
.
propertyWillChange
(
obj
'
hasArrayObservers
'
)
;
}
operation
(
obj
'
array
:
before
'
target
willChange
)
;
operation
(
obj
'
array
:
change
'
target
didChange
)
;
if
(
hasObservers
=
=
=
notify
)
{
_emberMetalProperty_events
.
propertyDidChange
(
obj
'
hasArrayObservers
'
)
;
}
return
obj
;
}
function
addArrayObserver
(
array
target
opts
)
{
return
arrayObserversHelper
(
array
target
opts
_emberMetalEvents
.
addListener
false
)
;
}
function
removeArrayObserver
(
array
target
opts
)
{
return
arrayObserversHelper
(
array
target
opts
_emberMetalEvents
.
removeListener
true
)
;
}
function
objectAt
(
content
idx
)
{
if
(
content
.
objectAt
)
{
return
content
.
objectAt
(
idx
)
;
}
return
content
[
idx
]
;
}
var
EMBER_ARRAY
=
_emberMetalSymbol
.
default
(
'
EMBER_ARRAY
'
)
;
function
isEmberArray
(
obj
)
{
return
obj
&
&
!
!
obj
[
EMBER_ARRAY
]
;
}
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsEnumerable
.
default
(
_Mixin
create
=
{
}
_Mixin
create
[
EMBER_ARRAY
]
=
true
_Mixin
create
.
length
=
null
_Mixin
create
.
objectAt
=
function
(
idx
)
{
if
(
idx
<
0
|
|
idx
>
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
)
{
return
undefined
;
}
return
_emberMetalProperty_get
.
get
(
this
idx
)
;
}
_Mixin
create
.
objectsAt
=
function
(
indexes
)
{
var
_this
=
this
;
return
indexes
.
map
(
function
(
idx
)
{
return
objectAt
(
_this
idx
)
;
}
)
;
}
_Mixin
create
.
nextObject
=
function
(
idx
)
{
return
objectAt
(
this
idx
)
;
}
_Mixin
create
[
'
[
]
'
]
=
_emberMetalComputed
.
computed
(
{
get
:
function
(
key
)
{
return
this
;
}
set
:
function
(
key
value
)
{
this
.
replace
(
0
_emberMetalProperty_get
.
get
(
this
'
length
'
)
value
)
;
return
this
;
}
}
)
_Mixin
create
.
firstObject
=
_emberMetalComputed
.
computed
(
function
(
)
{
return
objectAt
(
this
0
)
;
}
)
.
readOnly
(
)
_Mixin
create
.
lastObject
=
_emberMetalComputed
.
computed
(
function
(
)
{
return
objectAt
(
this
_emberMetalProperty_get
.
get
(
this
'
length
'
)
-
1
)
;
}
)
.
readOnly
(
)
_Mixin
create
.
contains
=
function
(
obj
)
{
return
this
.
indexOf
(
obj
)
>
=
0
;
}
_Mixin
create
.
slice
=
function
(
beginIndex
endIndex
)
{
var
ret
=
_emberMetalCore
.
default
.
A
(
)
;
var
length
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
if
(
_emberMetalIs_none
.
default
(
beginIndex
)
)
{
beginIndex
=
0
;
}
if
(
_emberMetalIs_none
.
default
(
endIndex
)
|
|
endIndex
>
length
)
{
endIndex
=
length
;
}
if
(
beginIndex
<
0
)
{
beginIndex
=
length
+
beginIndex
;
}
if
(
endIndex
<
0
)
{
endIndex
=
length
+
endIndex
;
}
while
(
beginIndex
<
endIndex
)
{
ret
[
ret
.
length
]
=
objectAt
(
this
beginIndex
+
+
)
;
}
return
ret
;
}
_Mixin
create
.
indexOf
=
function
(
object
startAt
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
var
idx
;
if
(
startAt
=
=
=
undefined
)
{
startAt
=
0
;
}
if
(
startAt
<
0
)
{
startAt
+
=
len
;
}
for
(
idx
=
startAt
;
idx
<
len
;
idx
+
+
)
{
if
(
objectAt
(
this
idx
)
=
=
=
object
)
{
return
idx
;
}
}
return
-
1
;
}
_Mixin
create
.
lastIndexOf
=
function
(
object
startAt
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
var
idx
;
if
(
startAt
=
=
=
undefined
|
|
startAt
>
=
len
)
{
startAt
=
len
-
1
;
}
if
(
startAt
<
0
)
{
startAt
+
=
len
;
}
for
(
idx
=
startAt
;
idx
>
=
0
;
idx
-
-
)
{
if
(
objectAt
(
this
idx
)
=
=
=
object
)
{
return
idx
;
}
}
return
-
1
;
}
_Mixin
create
.
addArrayObserver
=
function
(
target
opts
)
{
return
addArrayObserver
(
this
target
opts
)
;
}
_Mixin
create
.
removeArrayObserver
=
function
(
target
opts
)
{
return
removeArrayObserver
(
this
target
opts
)
;
}
_Mixin
create
.
hasArrayObservers
=
_emberMetalComputed
.
computed
(
function
(
)
{
return
_emberMetalEvents
.
hasListeners
(
this
'
array
:
change
'
)
|
|
_emberMetalEvents
.
hasListeners
(
this
'
array
:
before
'
)
;
}
)
_Mixin
create
.
arrayContentWillChange
=
function
(
startIdx
removeAmt
addAmt
)
{
var
removing
lim
;
if
(
startIdx
=
=
=
undefined
)
{
startIdx
=
0
;
removeAmt
=
addAmt
=
-
1
;
}
else
{
if
(
removeAmt
=
=
=
undefined
)
{
removeAmt
=
-
1
;
}
if
(
addAmt
=
=
=
undefined
)
{
addAmt
=
-
1
;
}
}
if
(
this
.
__each
)
{
this
.
__each
.
arrayWillChange
(
this
startIdx
removeAmt
addAmt
)
;
}
_emberMetalEvents
.
sendEvent
(
this
'
array
:
before
'
[
this
startIdx
removeAmt
addAmt
]
)
;
if
(
startIdx
>
=
0
&
&
removeAmt
>
=
0
&
&
_emberMetalProperty_get
.
get
(
this
'
hasEnumerableObservers
'
)
)
{
removing
=
[
]
;
lim
=
startIdx
+
removeAmt
;
for
(
var
idx
=
startIdx
;
idx
<
lim
;
idx
+
+
)
{
removing
.
push
(
objectAt
(
this
idx
)
)
;
}
}
else
{
removing
=
removeAmt
;
}
this
.
enumerableContentWillChange
(
removing
addAmt
)
;
return
this
;
}
_Mixin
create
.
arrayContentDidChange
=
function
(
startIdx
removeAmt
addAmt
)
{
var
adding
lim
;
_emberMetalTags
.
markObjectAsDirty
(
_emberMetalMeta
.
meta
(
this
)
)
;
if
(
startIdx
=
=
=
undefined
)
{
startIdx
=
0
;
removeAmt
=
addAmt
=
-
1
;
}
else
{
if
(
removeAmt
=
=
=
undefined
)
{
removeAmt
=
-
1
;
}
if
(
addAmt
=
=
=
undefined
)
{
addAmt
=
-
1
;
}
}
if
(
startIdx
>
=
0
&
&
addAmt
>
=
0
&
&
_emberMetalProperty_get
.
get
(
this
'
hasEnumerableObservers
'
)
)
{
adding
=
[
]
;
lim
=
startIdx
+
addAmt
;
for
(
var
idx
=
startIdx
;
idx
<
lim
;
idx
+
+
)
{
adding
.
push
(
objectAt
(
this
idx
)
)
;
}
}
else
{
adding
=
addAmt
;
}
this
.
enumerableContentDidChange
(
removeAmt
adding
)
;
if
(
this
.
__each
)
{
this
.
__each
.
arrayDidChange
(
this
startIdx
removeAmt
addAmt
)
;
}
_emberMetalEvents
.
sendEvent
(
this
'
array
:
change
'
[
this
startIdx
removeAmt
addAmt
]
)
;
var
length
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
var
cachedFirst
=
_emberMetalComputed
.
cacheFor
(
this
'
firstObject
'
)
;
var
cachedLast
=
_emberMetalComputed
.
cacheFor
(
this
'
lastObject
'
)
;
if
(
objectAt
(
this
0
)
!
=
=
cachedFirst
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
'
firstObject
'
)
;
_emberMetalProperty_events
.
propertyDidChange
(
this
'
firstObject
'
)
;
}
if
(
objectAt
(
this
length
-
1
)
!
=
=
cachedLast
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
'
lastObject
'
)
;
_emberMetalProperty_events
.
propertyDidChange
(
this
'
lastObject
'
)
;
}
return
this
;
}
_Mixin
create
[
'
each
'
]
=
_emberMetalComputed
.
computed
(
function
(
)
{
if
(
!
this
.
__each
)
{
this
.
__each
=
new
_emberRuntimeSystemEach_proxy
.
default
(
this
)
;
}
return
this
.
__each
;
}
)
.
volatile
(
)
_Mixin
create
)
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
comparable
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalMixin
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
compare
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
container_proxy
'
[
'
exports
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalRun_loop
_emberMetalDebug
_emberMetalMixin
)
{
'
use
strict
'
;
exports
.
buildFakeContainerWithDeprecations
=
buildFakeContainerWithDeprecations
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
__container__
:
null
ownerInjection
:
function
(
)
{
return
this
.
__container__
.
ownerInjection
(
)
;
}
lookup
:
function
(
fullName
options
)
{
return
this
.
__container__
.
lookup
(
fullName
options
)
;
}
_lookupFactory
:
function
(
fullName
options
)
{
return
this
.
__container__
.
lookupFactory
(
fullName
options
)
;
}
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
this
.
__container__
)
{
_emberMetalRun_loop
.
default
(
this
.
__container__
'
destroy
'
)
;
}
}
}
)
;
function
buildFakeContainerWithDeprecations
(
container
)
{
var
fakeContainer
=
{
}
;
var
propertyMappings
=
{
lookup
:
'
lookup
'
lookupFactory
:
'
_lookupFactory
'
}
;
for
(
var
containerProperty
in
propertyMappings
)
{
fakeContainer
[
containerProperty
]
=
buildFakeContainerFunction
(
container
containerProperty
propertyMappings
[
containerProperty
]
)
;
}
return
fakeContainer
;
}
function
buildFakeContainerFunction
(
container
containerProperty
ownerProperty
)
{
return
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
Using
the
injected
container
is
deprecated
.
Please
use
the
getOwner
helper
to
access
the
owner
of
this
object
and
then
call
'
+
ownerProperty
+
'
instead
.
'
false
{
id
:
'
ember
-
application
.
injected
-
container
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_injected
-
container
-
access
'
}
)
;
return
container
[
containerProperty
]
.
apply
(
container
arguments
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
controller
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
alias
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
runtime
/
mixins
/
controller_content_model_alias_deprecation
'
]
function
(
exports
_emberMetalMixin
_emberMetalAlias
_emberRuntimeMixinsAction_handler
_emberRuntimeMixinsController_content_model_alias_deprecation
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsAction_handler
.
default
_emberRuntimeMixinsController_content_model_alias_deprecation
.
default
{
isController
:
true
target
:
null
parentController
:
null
store
:
null
model
:
null
content
:
_emberMetalAlias
.
default
(
'
model
'
)
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
controller_content_model_alias_deprecation
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
willMergeMixin
:
function
(
props
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
modelSpecified
=
!
!
props
.
model
;
if
(
props
.
content
&
&
!
modelSpecified
)
{
props
.
model
=
props
.
content
;
delete
props
[
'
content
'
]
;
_emberMetalDebug
.
deprecate
(
'
Do
not
specify
content
on
a
Controller
use
model
instead
.
'
false
{
id
:
'
ember
-
runtime
.
will
-
merge
-
mixin
'
until
:
'
3
.
0
.
0
'
}
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
copyable
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
mixins
/
freezable
'
'
ember
-
metal
/
error
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalMixin
_emberRuntimeMixinsFreezable
_emberMetalError
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
copy
:
null
frozenCopy
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
frozenCopy
is
deprecated
use
Object
.
freeze
instead
.
'
false
{
id
:
'
ember
-
runtime
.
frozen
-
copy
'
until
:
'
3
.
0
.
0
'
}
)
;
if
(
_emberRuntimeMixinsFreezable
.
Freezable
&
&
_emberRuntimeMixinsFreezable
.
Freezable
.
detect
(
this
)
)
{
return
_emberMetalProperty_get
.
get
(
this
'
isFrozen
'
)
?
this
:
this
.
copy
(
)
.
freeze
(
)
;
}
else
{
throw
new
_emberMetalError
.
default
(
this
+
'
does
not
support
freezing
'
)
;
}
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
enumerable
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
empty_object
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
events
'
'
ember
-
runtime
/
compare
'
'
require
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalMixin
_emberMetalUtils
_emberMetalComputed
_emberMetalEmpty_object
_emberMetalFeatures
_emberMetalProperty_events
_emberMetalEvents
_emberRuntimeCompare
_require
)
{
'
use
strict
'
;
var
_emberA
=
undefined
;
function
emberA
(
)
{
return
(
_emberA
|
|
(
_emberA
=
_require
.
default
(
'
ember
-
runtime
/
system
/
native_array
'
)
.
A
)
)
(
)
;
}
var
contexts
=
[
]
;
function
popCtx
(
)
{
return
contexts
.
length
=
=
=
0
?
{
}
:
contexts
.
pop
(
)
;
}
function
pushCtx
(
ctx
)
{
contexts
.
push
(
ctx
)
;
return
null
;
}
function
iter
(
key
value
)
{
var
valueProvided
=
arguments
.
length
=
=
=
2
;
function
i
(
item
)
{
var
cur
=
_emberMetalProperty_get
.
get
(
item
key
)
;
return
valueProvided
?
value
=
=
=
cur
:
!
!
cur
;
}
return
i
;
}
var
Enumerable
=
_emberMetalMixin
.
Mixin
.
create
(
{
nextObject
:
null
firstObject
:
_emberMetalComputed
.
computed
(
'
[
]
'
function
(
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
length
'
)
=
=
=
0
)
{
return
undefined
;
}
var
context
=
popCtx
(
)
;
var
ret
=
this
.
nextObject
(
0
null
context
)
;
pushCtx
(
context
)
;
return
ret
;
}
)
.
readOnly
(
)
lastObject
:
_emberMetalComputed
.
computed
(
'
[
]
'
function
(
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
undefined
;
}
var
context
=
popCtx
(
)
;
var
idx
=
0
;
var
last
=
null
;
var
cur
;
do
{
last
=
cur
;
cur
=
this
.
nextObject
(
idx
+
+
last
context
)
;
}
while
(
cur
!
=
=
undefined
)
;
pushCtx
(
context
)
;
return
last
;
}
)
.
readOnly
(
)
contains
:
function
(
obj
)
{
var
found
=
this
.
find
(
function
(
item
)
{
return
item
=
=
=
obj
;
}
)
;
return
found
!
=
=
undefined
;
}
forEach
:
function
(
callback
target
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
TypeError
(
)
;
}
var
context
=
popCtx
(
)
;
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
var
last
=
null
;
if
(
target
=
=
=
undefined
)
{
target
=
null
;
}
for
(
var
idx
=
0
;
idx
<
len
;
idx
+
+
)
{
var
next
=
this
.
nextObject
(
idx
last
context
)
;
callback
.
call
(
target
next
idx
this
)
;
last
=
next
;
}
last
=
null
;
context
=
pushCtx
(
context
)
;
return
this
;
}
getEach
:
_emberMetalMixin
.
aliasMethod
(
'
mapBy
'
)
setEach
:
function
(
key
value
)
{
return
this
.
forEach
(
function
(
item
)
{
_emberMetalProperty_set
.
set
(
item
key
value
)
;
}
)
;
}
map
:
function
(
callback
target
)
{
var
ret
=
emberA
(
)
;
this
.
forEach
(
function
(
x
idx
i
)
{
ret
[
idx
]
=
callback
.
call
(
target
x
idx
i
)
;
}
)
;
return
ret
;
}
mapBy
:
function
(
key
)
{
return
this
.
map
(
function
(
next
)
{
return
_emberMetalProperty_get
.
get
(
next
key
)
;
}
)
;
}
filter
:
function
(
callback
target
)
{
var
ret
=
emberA
(
)
;
this
.
forEach
(
function
(
x
idx
i
)
{
if
(
callback
.
call
(
target
x
idx
i
)
)
{
ret
.
push
(
x
)
;
}
}
)
;
return
ret
;
}
reject
:
function
(
callback
target
)
{
return
this
.
filter
(
function
(
)
{
return
!
callback
.
apply
(
target
arguments
)
;
}
)
;
}
filterBy
:
function
(
key
value
)
{
return
this
.
filter
(
iter
.
apply
(
this
arguments
)
)
;
}
rejectBy
:
function
(
key
value
)
{
var
exactValue
=
function
(
item
)
{
return
_emberMetalProperty_get
.
get
(
item
key
)
=
=
=
value
;
}
;
var
hasValue
=
function
(
item
)
{
return
!
!
_emberMetalProperty_get
.
get
(
item
key
)
;
}
;
var
use
=
arguments
.
length
=
=
=
2
?
exactValue
:
hasValue
;
return
this
.
reject
(
use
)
;
}
find
:
function
(
callback
target
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
if
(
target
=
=
=
undefined
)
{
target
=
null
;
}
var
context
=
popCtx
(
)
;
var
found
=
false
;
var
last
=
null
;
var
next
ret
;
for
(
var
idx
=
0
;
idx
<
len
&
&
!
found
;
idx
+
+
)
{
next
=
this
.
nextObject
(
idx
last
context
)
;
if
(
found
=
callback
.
call
(
target
next
idx
this
)
)
{
ret
=
next
;
}
last
=
next
;
}
next
=
last
=
null
;
context
=
pushCtx
(
context
)
;
return
ret
;
}
findBy
:
function
(
key
value
)
{
return
this
.
find
(
iter
.
apply
(
this
arguments
)
)
;
}
every
:
function
(
callback
target
)
{
return
!
this
.
find
(
function
(
x
idx
i
)
{
return
!
callback
.
call
(
target
x
idx
i
)
;
}
)
;
}
isEvery
:
function
(
key
value
)
{
return
this
.
every
(
iter
.
apply
(
this
arguments
)
)
;
}
any
:
function
(
callback
target
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
var
context
=
popCtx
(
)
;
var
found
=
false
;
var
last
=
null
;
var
next
idx
;
if
(
target
=
=
=
undefined
)
{
target
=
null
;
}
for
(
idx
=
0
;
idx
<
len
&
&
!
found
;
idx
+
+
)
{
next
=
this
.
nextObject
(
idx
last
context
)
;
found
=
callback
.
call
(
target
next
idx
this
)
;
last
=
next
;
}
next
=
last
=
null
;
context
=
pushCtx
(
context
)
;
return
found
;
}
isAny
:
function
(
key
value
)
{
return
this
.
any
(
iter
.
apply
(
this
arguments
)
)
;
}
reduce
:
function
(
callback
initialValue
reducerProperty
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
TypeError
(
)
;
}
var
ret
=
initialValue
;
this
.
forEach
(
function
(
item
i
)
{
ret
=
callback
(
ret
item
i
this
reducerProperty
)
;
}
this
)
;
return
ret
;
}
invoke
:
function
(
methodName
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
ret
=
emberA
(
)
;
this
.
forEach
(
function
(
x
idx
)
{
var
method
=
x
&
&
x
[
methodName
]
;
if
(
'
function
'
=
=
=
typeof
method
)
{
ret
[
idx
]
=
args
?
method
.
apply
(
x
args
)
:
x
[
methodName
]
(
)
;
}
}
this
)
;
return
ret
;
}
toArray
:
function
(
)
{
var
ret
=
emberA
(
)
;
this
.
forEach
(
function
(
o
idx
)
{
ret
[
idx
]
=
o
;
}
)
;
return
ret
;
}
compact
:
function
(
)
{
return
this
.
filter
(
function
(
value
)
{
return
value
!
=
null
;
}
)
;
}
without
:
function
(
value
)
{
if
(
!
this
.
contains
(
value
)
)
{
return
this
;
}
var
ret
=
emberA
(
)
;
this
.
forEach
(
function
(
k
)
{
if
(
k
!
=
=
value
)
{
ret
[
ret
.
length
]
=
k
;
}
}
)
;
return
ret
;
}
uniq
:
function
(
)
{
var
ret
=
emberA
(
)
;
this
.
forEach
(
function
(
k
)
{
if
(
ret
.
indexOf
(
k
)
<
0
)
{
ret
.
push
(
k
)
;
}
}
)
;
return
ret
;
}
'
[
]
'
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
key
)
{
return
this
;
}
}
)
addEnumerableObserver
:
function
(
target
opts
)
{
var
willChange
=
opts
&
&
opts
.
willChange
|
|
'
enumerableWillChange
'
;
var
didChange
=
opts
&
&
opts
.
didChange
|
|
'
enumerableDidChange
'
;
var
hasObservers
=
_emberMetalProperty_get
.
get
(
this
'
hasEnumerableObservers
'
)
;
if
(
!
hasObservers
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
'
hasEnumerableObservers
'
)
;
}
_emberMetalEvents
.
addListener
(
this
'
enumerable
:
before
'
target
willChange
)
;
_emberMetalEvents
.
addListener
(
this
'
enumerable
:
change
'
target
didChange
)
;
if
(
!
hasObservers
)
{
_emberMetalProperty_events
.
propertyDidChange
(
this
'
hasEnumerableObservers
'
)
;
}
return
this
;
}
removeEnumerableObserver
:
function
(
target
opts
)
{
var
willChange
=
opts
&
&
opts
.
willChange
|
|
'
enumerableWillChange
'
;
var
didChange
=
opts
&
&
opts
.
didChange
|
|
'
enumerableDidChange
'
;
var
hasObservers
=
_emberMetalProperty_get
.
get
(
this
'
hasEnumerableObservers
'
)
;
if
(
hasObservers
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
'
hasEnumerableObservers
'
)
;
}
_emberMetalEvents
.
removeListener
(
this
'
enumerable
:
before
'
target
willChange
)
;
_emberMetalEvents
.
removeListener
(
this
'
enumerable
:
change
'
target
didChange
)
;
if
(
hasObservers
)
{
_emberMetalProperty_events
.
propertyDidChange
(
this
'
hasEnumerableObservers
'
)
;
}
return
this
;
}
hasEnumerableObservers
:
_emberMetalComputed
.
computed
(
function
(
)
{
return
_emberMetalEvents
.
hasListeners
(
this
'
enumerable
:
change
'
)
|
|
_emberMetalEvents
.
hasListeners
(
this
'
enumerable
:
before
'
)
;
}
)
enumerableContentWillChange
:
function
(
removing
adding
)
{
var
removeCnt
addCnt
hasDelta
;
if
(
'
number
'
=
=
=
typeof
removing
)
{
removeCnt
=
removing
;
}
else
if
(
removing
)
{
removeCnt
=
_emberMetalProperty_get
.
get
(
removing
'
length
'
)
;
}
else
{
removeCnt
=
removing
=
-
1
;
}
if
(
'
number
'
=
=
=
typeof
adding
)
{
addCnt
=
adding
;
}
else
if
(
adding
)
{
addCnt
=
_emberMetalProperty_get
.
get
(
adding
'
length
'
)
;
}
else
{
addCnt
=
adding
=
-
1
;
}
hasDelta
=
addCnt
<
0
|
|
removeCnt
<
0
|
|
addCnt
-
removeCnt
!
=
=
0
;
if
(
removing
=
=
=
-
1
)
{
removing
=
null
;
}
if
(
adding
=
=
=
-
1
)
{
adding
=
null
;
}
_emberMetalProperty_events
.
propertyWillChange
(
this
'
[
]
'
)
;
if
(
hasDelta
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
'
length
'
)
;
}
_emberMetalEvents
.
sendEvent
(
this
'
enumerable
:
before
'
[
this
removing
adding
]
)
;
return
this
;
}
enumerableContentDidChange
:
function
(
removing
adding
)
{
var
removeCnt
addCnt
hasDelta
;
if
(
'
number
'
=
=
=
typeof
removing
)
{
removeCnt
=
removing
;
}
else
if
(
removing
)
{
removeCnt
=
_emberMetalProperty_get
.
get
(
removing
'
length
'
)
;
}
else
{
removeCnt
=
removing
=
-
1
;
}
if
(
'
number
'
=
=
=
typeof
adding
)
{
addCnt
=
adding
;
}
else
if
(
adding
)
{
addCnt
=
_emberMetalProperty_get
.
get
(
adding
'
length
'
)
;
}
else
{
addCnt
=
adding
=
-
1
;
}
hasDelta
=
addCnt
<
0
|
|
removeCnt
<
0
|
|
addCnt
-
removeCnt
!
=
=
0
;
if
(
removing
=
=
=
-
1
)
{
removing
=
null
;
}
if
(
adding
=
=
=
-
1
)
{
adding
=
null
;
}
_emberMetalEvents
.
sendEvent
(
this
'
enumerable
:
change
'
[
this
removing
adding
]
)
;
if
(
hasDelta
)
{
_emberMetalProperty_events
.
propertyDidChange
(
this
'
length
'
)
;
}
_emberMetalProperty_events
.
propertyDidChange
(
this
'
[
]
'
)
;
return
this
;
}
sortBy
:
function
(
)
{
var
sortKeys
=
arguments
;
return
this
.
toArray
(
)
.
sort
(
function
(
a
b
)
{
for
(
var
i
=
0
;
i
<
sortKeys
.
length
;
i
+
+
)
{
var
key
=
sortKeys
[
i
]
;
var
propA
=
_emberMetalProperty_get
.
get
(
a
key
)
;
var
propB
=
_emberMetalProperty_get
.
get
(
b
key
)
;
var
compareValue
=
_emberRuntimeCompare
.
default
(
propA
propB
)
;
if
(
compareValue
)
{
return
compareValue
;
}
}
return
0
;
}
)
;
}
}
)
;
exports
.
default
=
Enumerable
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
evented
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
events
'
]
function
(
exports
_emberMetalMixin
_emberMetalEvents
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
on
:
function
(
name
target
method
)
{
_emberMetalEvents
.
addListener
(
this
name
target
method
)
;
return
this
;
}
one
:
function
(
name
target
method
)
{
if
(
!
method
)
{
method
=
target
;
target
=
null
;
}
_emberMetalEvents
.
addListener
(
this
name
target
method
true
)
;
return
this
;
}
trigger
:
function
(
name
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
_emberMetalEvents
.
sendEvent
(
this
name
args
)
;
}
off
:
function
(
name
target
method
)
{
_emberMetalEvents
.
removeListener
(
this
name
target
method
)
;
return
this
;
}
has
:
function
(
name
)
{
return
_emberMetalEvents
.
hasListeners
(
this
name
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
freezable
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
_emberMetalProperty_get
_emberMetalProperty_set
)
{
'
use
strict
'
;
var
Freezable
=
_emberMetalMixin
.
Mixin
.
create
(
{
init
:
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
Ember
.
Freezable
is
deprecated
use
Object
.
freeze
instead
.
'
false
{
id
:
'
ember
-
runtime
.
freezable
-
init
'
until
:
'
3
.
0
.
0
'
}
)
;
this
.
_super
.
apply
(
this
arguments
)
;
}
isFrozen
:
false
freeze
:
function
(
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
isFrozen
'
)
)
{
return
this
;
}
_emberMetalProperty_set
.
set
(
this
'
isFrozen
'
true
)
;
return
this
;
}
}
)
;
exports
.
Freezable
=
Freezable
;
var
FROZEN_ERROR
=
'
Frozen
object
cannot
be
modified
.
'
;
exports
.
FROZEN_ERROR
=
FROZEN_ERROR
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
mutable_array
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
mixins
/
mutable_enumerable
'
'
ember
-
runtime
/
mixins
/
enumerable
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalError
_emberMetalMixin
_emberRuntimeMixinsArray
_emberRuntimeMixinsMutable_enumerable
_emberRuntimeMixinsEnumerable
)
{
'
use
strict
'
;
var
OUT_OF_RANGE_EXCEPTION
=
'
Index
out
of
range
'
;
var
EMPTY
=
[
]
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsArray
.
default
_emberRuntimeMixinsMutable_enumerable
.
default
{
replace
:
null
clear
:
function
(
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
this
;
}
this
.
replace
(
0
len
EMPTY
)
;
return
this
;
}
insertAt
:
function
(
idx
object
)
{
if
(
idx
>
_emberMetalProperty_get
.
get
(
this
'
length
'
)
)
{
throw
new
_emberMetalError
.
default
(
OUT_OF_RANGE_EXCEPTION
)
;
}
this
.
replace
(
idx
0
[
object
]
)
;
return
this
;
}
removeAt
:
function
(
start
len
)
{
if
(
'
number
'
=
=
=
typeof
start
)
{
if
(
start
<
0
|
|
start
>
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
)
{
throw
new
_emberMetalError
.
default
(
OUT_OF_RANGE_EXCEPTION
)
;
}
if
(
len
=
=
=
undefined
)
{
len
=
1
;
}
this
.
replace
(
start
len
EMPTY
)
;
}
return
this
;
}
pushObject
:
function
(
obj
)
{
this
.
insertAt
(
_emberMetalProperty_get
.
get
(
this
'
length
'
)
obj
)
;
return
obj
;
}
pushObjects
:
function
(
objects
)
{
if
(
!
(
_emberRuntimeMixinsEnumerable
.
default
.
detect
(
objects
)
|
|
Array
.
isArray
(
objects
)
)
)
{
throw
new
TypeError
(
'
Must
pass
Ember
.
Enumerable
to
Ember
.
MutableArray
#
pushObjects
'
)
;
}
this
.
replace
(
_emberMetalProperty_get
.
get
(
this
'
length
'
)
0
objects
)
;
return
this
;
}
popObject
:
function
(
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
null
;
}
var
ret
=
_emberRuntimeMixinsArray
.
objectAt
(
this
len
-
1
)
;
this
.
removeAt
(
len
-
1
1
)
;
return
ret
;
}
shiftObject
:
function
(
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
length
'
)
=
=
=
0
)
{
return
null
;
}
var
ret
=
_emberRuntimeMixinsArray
.
objectAt
(
this
0
)
;
this
.
removeAt
(
0
)
;
return
ret
;
}
unshiftObject
:
function
(
obj
)
{
this
.
insertAt
(
0
obj
)
;
return
obj
;
}
unshiftObjects
:
function
(
objects
)
{
this
.
replace
(
0
0
objects
)
;
return
this
;
}
reverseObjects
:
function
(
)
{
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
if
(
len
=
=
=
0
)
{
return
this
;
}
var
objects
=
this
.
toArray
(
)
.
reverse
(
)
;
this
.
replace
(
0
len
objects
)
;
return
this
;
}
setObjects
:
function
(
objects
)
{
if
(
objects
.
length
=
=
=
0
)
{
return
this
.
clear
(
)
;
}
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
this
.
replace
(
0
len
objects
)
;
return
this
;
}
removeObject
:
function
(
obj
)
{
var
loc
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
|
|
0
;
while
(
-
-
loc
>
=
0
)
{
var
curObject
=
_emberRuntimeMixinsArray
.
objectAt
(
this
loc
)
;
if
(
curObject
=
=
=
obj
)
{
this
.
removeAt
(
loc
)
;
}
}
return
this
;
}
addObject
:
function
(
obj
)
{
if
(
!
this
.
contains
(
obj
)
)
{
this
.
pushObject
(
obj
)
;
}
return
this
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
mutable_enumerable
'
[
'
exports
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_events
'
]
function
(
exports
_emberRuntimeMixinsEnumerable
_emberMetalMixin
_emberMetalProperty_events
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsEnumerable
.
default
{
addObject
:
null
addObjects
:
function
(
objects
)
{
var
_this
=
this
;
_emberMetalProperty_events
.
beginPropertyChanges
(
this
)
;
objects
.
forEach
(
function
(
obj
)
{
return
_this
.
addObject
(
obj
)
;
}
)
;
_emberMetalProperty_events
.
endPropertyChanges
(
this
)
;
return
this
;
}
removeObject
:
null
removeObjects
:
function
(
objects
)
{
_emberMetalProperty_events
.
beginPropertyChanges
(
this
)
;
for
(
var
i
=
objects
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
removeObject
(
objects
[
i
]
)
;
}
_emberMetalProperty_events
.
endPropertyChanges
(
this
)
;
return
this
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
observable
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
get_properties
'
'
ember
-
metal
/
set_properties
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
is_none
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalGet_properties
_emberMetalSet_properties
_emberMetalMixin
_emberMetalEvents
_emberMetalProperty_events
_emberMetalObserver
_emberMetalComputed
_emberMetalIs_none
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
get
:
function
(
keyName
)
{
return
_emberMetalProperty_get
.
get
(
this
keyName
)
;
}
getProperties
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
_emberMetalGet_properties
.
default
.
apply
(
null
[
this
]
.
concat
(
args
)
)
;
}
set
:
function
(
keyName
value
)
{
return
_emberMetalProperty_set
.
set
(
this
keyName
value
)
;
}
setProperties
:
function
(
hash
)
{
return
_emberMetalSet_properties
.
default
(
this
hash
)
;
}
beginPropertyChanges
:
function
(
)
{
_emberMetalProperty_events
.
beginPropertyChanges
(
)
;
return
this
;
}
endPropertyChanges
:
function
(
)
{
_emberMetalProperty_events
.
endPropertyChanges
(
)
;
return
this
;
}
propertyWillChange
:
function
(
keyName
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
keyName
)
;
return
this
;
}
propertyDidChange
:
function
(
keyName
)
{
_emberMetalProperty_events
.
propertyDidChange
(
this
keyName
)
;
return
this
;
}
notifyPropertyChange
:
function
(
keyName
)
{
this
.
propertyWillChange
(
keyName
)
;
this
.
propertyDidChange
(
keyName
)
;
return
this
;
}
addObserver
:
function
(
key
target
method
)
{
_emberMetalObserver
.
addObserver
(
this
key
target
method
)
;
}
removeObserver
:
function
(
key
target
method
)
{
_emberMetalObserver
.
removeObserver
(
this
key
target
method
)
;
}
hasObserverFor
:
function
(
key
)
{
return
_emberMetalEvents
.
hasListeners
(
this
key
+
'
:
change
'
)
;
}
getWithDefault
:
function
(
keyName
defaultValue
)
{
return
_emberMetalProperty_get
.
getWithDefault
(
this
keyName
defaultValue
)
;
}
incrementProperty
:
function
(
keyName
increment
)
{
if
(
_emberMetalIs_none
.
default
(
increment
)
)
{
increment
=
1
;
}
_emberMetalDebug
.
assert
(
'
Must
pass
a
numeric
value
to
incrementProperty
'
!
isNaN
(
parseFloat
(
increment
)
)
&
&
isFinite
(
increment
)
)
;
return
_emberMetalProperty_set
.
set
(
this
keyName
(
parseFloat
(
_emberMetalProperty_get
.
get
(
this
keyName
)
)
|
|
0
)
+
increment
)
;
}
decrementProperty
:
function
(
keyName
decrement
)
{
if
(
_emberMetalIs_none
.
default
(
decrement
)
)
{
decrement
=
1
;
}
_emberMetalDebug
.
assert
(
'
Must
pass
a
numeric
value
to
decrementProperty
'
!
isNaN
(
parseFloat
(
decrement
)
)
&
&
isFinite
(
decrement
)
)
;
return
_emberMetalProperty_set
.
set
(
this
keyName
(
_emberMetalProperty_get
.
get
(
this
keyName
)
|
|
0
)
-
decrement
)
;
}
toggleProperty
:
function
(
keyName
)
{
return
_emberMetalProperty_set
.
set
(
this
keyName
!
_emberMetalProperty_get
.
get
(
this
keyName
)
)
;
}
cacheFor
:
function
(
keyName
)
{
return
_emberMetalComputed
.
cacheFor
(
this
keyName
)
;
}
observersForKey
:
function
(
keyName
)
{
return
_emberMetalObserver
.
observersFor
(
this
keyName
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
promise_proxy
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
set_properties
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
error
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalSet_properties
_emberMetalComputed
_emberMetalMixin
_emberMetalError
)
{
'
use
strict
'
;
var
not
=
_emberMetalComputed
.
computed
.
not
;
var
or
=
_emberMetalComputed
.
computed
.
or
;
function
tap
(
proxy
promise
)
{
_emberMetalSet_properties
.
default
(
proxy
{
isFulfilled
:
false
isRejected
:
false
}
)
;
return
promise
.
then
(
function
(
value
)
{
_emberMetalSet_properties
.
default
(
proxy
{
content
:
value
isFulfilled
:
true
}
)
;
return
value
;
}
function
(
reason
)
{
_emberMetalSet_properties
.
default
(
proxy
{
reason
:
reason
isRejected
:
true
}
)
;
throw
reason
;
}
'
Ember
:
PromiseProxy
'
)
;
}
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
reason
:
null
isPending
:
not
(
'
isSettled
'
)
.
readOnly
(
)
isSettled
:
or
(
'
isRejected
'
'
isFulfilled
'
)
.
readOnly
(
)
isRejected
:
false
isFulfilled
:
false
promise
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
)
{
throw
new
_emberMetalError
.
default
(
'
PromiseProxy
\
'
s
promise
must
be
set
'
)
;
}
set
:
function
(
key
promise
)
{
return
tap
(
this
promise
)
;
}
}
)
then
:
promiseAlias
(
'
then
'
)
'
catch
'
:
promiseAlias
(
'
catch
'
)
'
finally
'
:
promiseAlias
(
'
finally
'
)
}
)
;
function
promiseAlias
(
name
)
{
return
function
(
)
{
var
promise
=
_emberMetalProperty_get
.
get
(
this
'
promise
'
)
;
return
promise
[
name
]
.
apply
(
promise
arguments
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
registry_proxy
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
)
{
'
use
strict
'
;
exports
.
buildFakeRegistryWithDeprecations
=
buildFakeRegistryWithDeprecations
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
__registry__
:
null
resolveRegistration
:
registryAlias
(
'
resolve
'
)
register
:
registryAlias
(
'
register
'
)
unregister
:
registryAlias
(
'
unregister
'
)
hasRegistration
:
registryAlias
(
'
has
'
)
registerOption
:
registryAlias
(
'
option
'
)
registeredOption
:
registryAlias
(
'
getOption
'
)
registerOptions
:
registryAlias
(
'
options
'
)
registeredOptions
:
registryAlias
(
'
getOptions
'
)
registerOptionsForType
:
registryAlias
(
'
optionsForType
'
)
registeredOptionsForType
:
registryAlias
(
'
getOptionsForType
'
)
inject
:
registryAlias
(
'
injection
'
)
}
)
;
function
registryAlias
(
name
)
{
return
function
(
)
{
var
_registry__
;
return
(
_registry__
=
this
.
__registry__
)
[
name
]
.
apply
(
_registry__
arguments
)
;
}
;
}
function
buildFakeRegistryWithDeprecations
(
instance
typeForMessage
)
{
var
fakeRegistry
=
{
}
;
var
registryProps
=
{
resolve
:
'
resolveRegistration
'
register
:
'
register
'
unregister
:
'
unregister
'
has
:
'
hasRegistration
'
option
:
'
registerOption
'
options
:
'
registerOptions
'
getOptions
:
'
registeredOptions
'
optionsForType
:
'
registerOptionsForType
'
getOptionsForType
:
'
registeredOptionsForType
'
injection
:
'
inject
'
}
;
for
(
var
deprecatedProperty
in
registryProps
)
{
fakeRegistry
[
deprecatedProperty
]
=
buildFakeRegistryFunction
(
instance
typeForMessage
deprecatedProperty
registryProps
[
deprecatedProperty
]
)
;
}
return
fakeRegistry
;
}
function
buildFakeRegistryFunction
(
instance
typeForMessage
deprecatedProperty
nonDeprecatedProperty
)
{
return
function
(
)
{
_emberMetalDebug
.
deprecate
(
'
Using
'
+
typeForMessage
+
'
.
registry
.
'
+
deprecatedProperty
+
'
is
deprecated
.
Please
use
'
+
typeForMessage
+
'
.
'
+
nonDeprecatedProperty
+
'
instead
.
'
false
{
id
:
'
ember
-
application
.
app
-
instance
-
registry
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
application
-
registry
-
ember
-
applicationinstance
-
registry
'
}
)
;
return
instance
[
nonDeprecatedProperty
]
.
apply
(
instance
arguments
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
mixins
/
target_action_support
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
computed
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberMetalProperty_get
_emberMetalMixin
_emberMetalComputed
)
{
'
use
strict
'
;
var
TargetActionSupport
=
_emberMetalMixin
.
Mixin
.
create
(
{
target
:
null
action
:
null
actionContext
:
null
targetObject
:
_emberMetalComputed
.
computed
(
'
target
'
function
(
)
{
if
(
this
.
_targetObject
)
{
return
this
.
_targetObject
;
}
var
target
=
_emberMetalProperty_get
.
get
(
this
'
target
'
)
;
if
(
typeof
target
=
=
=
'
string
'
)
{
var
value
=
_emberMetalProperty_get
.
get
(
this
target
)
;
if
(
value
=
=
=
undefined
)
{
value
=
_emberMetalProperty_get
.
get
(
_emberMetalCore
.
default
.
lookup
target
)
;
}
return
value
;
}
else
{
return
target
;
}
}
)
actionContextObject
:
_emberMetalComputed
.
computed
(
function
(
)
{
var
actionContext
=
_emberMetalProperty_get
.
get
(
this
'
actionContext
'
)
;
if
(
typeof
actionContext
=
=
=
'
string
'
)
{
var
value
=
_emberMetalProperty_get
.
get
(
this
actionContext
)
;
if
(
value
=
=
=
undefined
)
{
value
=
_emberMetalProperty_get
.
get
(
_emberMetalCore
.
default
.
lookup
actionContext
)
;
}
return
value
;
}
else
{
return
actionContext
;
}
}
)
.
property
(
'
actionContext
'
)
triggerAction
:
function
(
)
{
var
opts
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
var
action
=
opts
.
action
|
|
_emberMetalProperty_get
.
get
(
this
'
action
'
)
;
var
target
=
opts
.
target
|
|
_emberMetalProperty_get
.
get
(
this
'
targetObject
'
)
;
var
actionContext
=
opts
.
actionContext
;
function
args
(
options
actionName
)
{
var
ret
=
[
]
;
if
(
actionName
)
{
ret
.
push
(
actionName
)
;
}
return
ret
.
concat
(
options
)
;
}
if
(
typeof
actionContext
=
=
=
'
undefined
'
)
{
actionContext
=
_emberMetalProperty_get
.
get
(
this
'
actionContextObject
'
)
|
|
this
;
}
if
(
target
&
&
action
)
{
var
ret
;
if
(
target
.
send
)
{
ret
=
target
.
send
.
apply
(
target
args
(
actionContext
action
)
)
;
}
else
{
_emberMetalDebug
.
assert
(
'
The
action
\
'
'
+
action
+
'
\
'
did
not
exist
on
'
+
target
typeof
target
[
action
]
=
=
=
'
function
'
)
;
ret
=
target
[
action
]
.
apply
(
target
args
(
actionContext
)
)
;
}
if
(
ret
!
=
=
false
)
{
ret
=
true
;
}
return
ret
;
}
else
{
return
false
;
}
}
}
)
;
exports
.
default
=
TargetActionSupport
;
}
)
;
enifed
(
"
ember
-
runtime
/
string_registry
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
setStrings
=
setStrings
;
exports
.
getStrings
=
getStrings
;
exports
.
get
=
get
;
var
STRINGS
=
{
}
;
function
setStrings
(
strings
)
{
STRINGS
=
strings
;
}
function
getStrings
(
)
{
return
STRINGS
;
}
function
get
(
name
)
{
return
STRINGS
[
name
]
;
}
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
application
'
[
'
exports
'
'
ember
-
runtime
/
system
/
namespace
'
]
function
(
exports
_emberRuntimeSystemNamespace
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemNamespace
.
default
.
extend
(
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
array_proxy
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
runtime
/
utils
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
error
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
mutable_array
'
'
ember
-
runtime
/
mixins
/
enumerable
'
'
ember
-
metal
/
alias
'
'
ember
-
runtime
/
mixins
/
array
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberRuntimeUtils
_emberMetalComputed
_emberMetalMixin
_emberMetalProperty_events
_emberMetalError
_emberRuntimeSystemObject
_emberRuntimeMixinsMutable_array
_emberRuntimeMixinsEnumerable
_emberMetalAlias
_emberRuntimeMixinsArray
)
{
'
use
strict
'
;
var
OUT_OF_RANGE_EXCEPTION
=
'
Index
out
of
range
'
;
var
EMPTY
=
[
]
;
function
K
(
)
{
return
this
;
}
var
ArrayProxy
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsMutable_array
.
default
{
content
:
null
arrangedContent
:
_emberMetalAlias
.
default
(
'
content
'
)
objectAtContent
:
function
(
idx
)
{
return
_emberRuntimeMixinsArray
.
objectAt
(
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
idx
)
;
}
replaceContent
:
function
(
idx
amt
objects
)
{
_emberMetalProperty_get
.
get
(
this
'
content
'
)
.
replace
(
idx
amt
objects
)
;
}
_contentWillChange
:
_emberMetalMixin
.
_beforeObserver
(
'
content
'
function
(
)
{
this
.
_teardownContent
(
)
;
}
)
_teardownContent
:
function
(
)
{
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
if
(
content
)
{
_emberRuntimeMixinsArray
.
removeArrayObserver
(
content
this
{
willChange
:
'
contentArrayWillChange
'
didChange
:
'
contentArrayDidChange
'
}
)
;
}
}
contentArrayWillChange
:
K
contentArrayDidChange
:
K
_contentDidChange
:
_emberMetalMixin
.
observer
(
'
content
'
function
(
)
{
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
_emberMetalDebug
.
assert
(
'
Can
\
'
t
set
ArrayProxy
\
'
s
content
to
itself
'
content
!
=
=
this
)
;
this
.
_setupContent
(
)
;
}
)
_setupContent
:
function
(
)
{
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
if
(
content
)
{
_emberMetalDebug
.
assert
(
'
ArrayProxy
expects
an
Array
or
Ember
.
ArrayProxy
but
you
passed
'
+
typeof
content
_emberRuntimeUtils
.
isArray
(
content
)
|
|
content
.
isDestroyed
)
;
_emberRuntimeMixinsArray
.
addArrayObserver
(
content
this
{
willChange
:
'
contentArrayWillChange
'
didChange
:
'
contentArrayDidChange
'
}
)
;
}
}
_arrangedContentWillChange
:
_emberMetalMixin
.
_beforeObserver
(
'
arrangedContent
'
function
(
)
{
var
arrangedContent
=
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
;
var
len
=
arrangedContent
?
_emberMetalProperty_get
.
get
(
arrangedContent
'
length
'
)
:
0
;
this
.
arrangedContentArrayWillChange
(
this
0
len
undefined
)
;
this
.
arrangedContentWillChange
(
this
)
;
this
.
_teardownArrangedContent
(
arrangedContent
)
;
}
)
_arrangedContentDidChange
:
_emberMetalMixin
.
observer
(
'
arrangedContent
'
function
(
)
{
var
arrangedContent
=
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
;
var
len
=
arrangedContent
?
_emberMetalProperty_get
.
get
(
arrangedContent
'
length
'
)
:
0
;
_emberMetalDebug
.
assert
(
'
Can
\
'
t
set
ArrayProxy
\
'
s
content
to
itself
'
arrangedContent
!
=
=
this
)
;
this
.
_setupArrangedContent
(
)
;
this
.
arrangedContentDidChange
(
this
)
;
this
.
arrangedContentArrayDidChange
(
this
0
undefined
len
)
;
}
)
_setupArrangedContent
:
function
(
)
{
var
arrangedContent
=
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
;
if
(
arrangedContent
)
{
_emberMetalDebug
.
assert
(
'
ArrayProxy
expects
an
Array
or
Ember
.
ArrayProxy
but
you
passed
'
+
typeof
arrangedContent
_emberRuntimeUtils
.
isArray
(
arrangedContent
)
|
|
arrangedContent
.
isDestroyed
)
;
_emberRuntimeMixinsArray
.
addArrayObserver
(
arrangedContent
this
{
willChange
:
'
arrangedContentArrayWillChange
'
didChange
:
'
arrangedContentArrayDidChange
'
}
)
;
}
}
_teardownArrangedContent
:
function
(
)
{
var
arrangedContent
=
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
;
if
(
arrangedContent
)
{
_emberRuntimeMixinsArray
.
removeArrayObserver
(
arrangedContent
this
{
willChange
:
'
arrangedContentArrayWillChange
'
didChange
:
'
arrangedContentArrayDidChange
'
}
)
;
}
}
arrangedContentWillChange
:
K
arrangedContentDidChange
:
K
objectAt
:
function
(
idx
)
{
return
_emberMetalProperty_get
.
get
(
this
'
content
'
)
&
&
this
.
objectAtContent
(
idx
)
;
}
length
:
_emberMetalComputed
.
computed
(
function
(
)
{
var
arrangedContent
=
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
;
return
arrangedContent
?
_emberMetalProperty_get
.
get
(
arrangedContent
'
length
'
)
:
0
;
}
)
_replace
:
function
(
idx
amt
objects
)
{
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
_emberMetalDebug
.
assert
(
'
The
content
property
of
'
+
this
.
constructor
+
'
should
be
set
before
modifying
it
'
content
)
;
if
(
content
)
{
this
.
replaceContent
(
idx
amt
objects
)
;
}
return
this
;
}
replace
:
function
(
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
=
=
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
)
{
this
.
_replace
.
apply
(
this
arguments
)
;
}
else
{
throw
new
_emberMetalError
.
default
(
'
Using
replace
on
an
arranged
ArrayProxy
is
not
allowed
.
'
)
;
}
}
_insertAt
:
function
(
idx
object
)
{
if
(
idx
>
_emberMetalProperty_get
.
get
(
this
'
content
.
length
'
)
)
{
throw
new
_emberMetalError
.
default
(
OUT_OF_RANGE_EXCEPTION
)
;
}
this
.
_replace
(
idx
0
[
object
]
)
;
return
this
;
}
insertAt
:
function
(
idx
object
)
{
if
(
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
=
=
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
)
{
return
this
.
_insertAt
(
idx
object
)
;
}
else
{
throw
new
_emberMetalError
.
default
(
'
Using
insertAt
on
an
arranged
ArrayProxy
is
not
allowed
.
'
)
;
}
}
removeAt
:
function
(
start
len
)
{
if
(
'
number
'
=
=
=
typeof
start
)
{
var
content
=
_emberMetalProperty_get
.
get
(
this
'
content
'
)
;
var
arrangedContent
=
_emberMetalProperty_get
.
get
(
this
'
arrangedContent
'
)
;
var
indices
=
[
]
;
var
i
;
if
(
start
<
0
|
|
start
>
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
)
{
throw
new
_emberMetalError
.
default
(
OUT_OF_RANGE_EXCEPTION
)
;
}
if
(
len
=
=
=
undefined
)
{
len
=
1
;
}
for
(
i
=
start
;
i
<
start
+
len
;
i
+
+
)
{
indices
.
push
(
content
.
indexOf
(
_emberRuntimeMixinsArray
.
objectAt
(
arrangedContent
i
)
)
)
;
}
indices
.
sort
(
function
(
a
b
)
{
return
b
-
a
;
}
)
;
_emberMetalProperty_events
.
beginPropertyChanges
(
)
;
for
(
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
{
this
.
_replace
(
indices
[
i
]
1
EMPTY
)
;
}
_emberMetalProperty_events
.
endPropertyChanges
(
)
;
}
return
this
;
}
pushObject
:
function
(
obj
)
{
this
.
_insertAt
(
_emberMetalProperty_get
.
get
(
this
'
content
.
length
'
)
obj
)
;
return
obj
;
}
pushObjects
:
function
(
objects
)
{
if
(
!
(
_emberRuntimeMixinsEnumerable
.
default
.
detect
(
objects
)
|
|
_emberRuntimeUtils
.
isArray
(
objects
)
)
)
{
throw
new
TypeError
(
'
Must
pass
Ember
.
Enumerable
to
Ember
.
MutableArray
#
pushObjects
'
)
;
}
this
.
_replace
(
_emberMetalProperty_get
.
get
(
this
'
length
'
)
0
objects
)
;
return
this
;
}
setObjects
:
function
(
objects
)
{
if
(
objects
.
length
=
=
=
0
)
{
return
this
.
clear
(
)
;
}
var
len
=
_emberMetalProperty_get
.
get
(
this
'
length
'
)
;
this
.
_replace
(
0
len
objects
)
;
return
this
;
}
unshiftObject
:
function
(
obj
)
{
this
.
_insertAt
(
0
obj
)
;
return
obj
;
}
unshiftObjects
:
function
(
objects
)
{
this
.
_replace
(
0
0
objects
)
;
return
this
;
}
slice
:
function
(
)
{
var
arr
=
this
.
toArray
(
)
;
return
arr
.
slice
.
apply
(
arr
arguments
)
;
}
arrangedContentArrayWillChange
:
function
(
item
idx
removedCnt
addedCnt
)
{
this
.
arrayContentWillChange
(
idx
removedCnt
addedCnt
)
;
}
arrangedContentArrayDidChange
:
function
(
item
idx
removedCnt
addedCnt
)
{
this
.
arrayContentDidChange
(
idx
removedCnt
addedCnt
)
;
}
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_setupContent
(
)
;
this
.
_setupArrangedContent
(
)
;
}
willDestroy
:
function
(
)
{
this
.
_teardownArrangedContent
(
)
;
this
.
_teardownContent
(
)
;
}
}
)
;
exports
.
default
=
ArrayProxy
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
container
'
[
'
exports
'
'
ember
-
metal
/
property_set
'
'
container
/
registry
'
'
container
/
container
'
'
container
/
owner
'
]
function
(
exports
_emberMetalProperty_set
_containerRegistry
_containerContainer
_containerOwner
)
{
'
use
strict
'
;
_containerRegistry
.
default
.
set
=
_emberMetalProperty_set
.
set
;
_containerContainer
.
default
.
set
=
_emberMetalProperty_set
.
set
;
exports
.
Registry
=
_containerRegistry
.
default
;
exports
.
Container
=
_containerContainer
.
default
;
exports
.
getOwner
=
_containerOwner
.
getOwner
;
exports
.
setOwner
=
_containerOwner
.
setOwner
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
core_object
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
features
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
meta
'
'
ember
-
metal
/
chains
'
'
ember
-
metal
/
events
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
error
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
metal
/
properties
'
'
ember
-
metal
/
binding
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
injected_property
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
watching
'
'
ember
-
metal
/
core
'
'
ember
-
runtime
/
inject
'
'
ember
-
metal
/
symbol
'
]
function
(
exports
_emberMetalDebug
_emberMetalFeatures
_emberMetalAssign
_emberMetalProperty_get
_emberMetalUtils
_emberMetalMeta
_emberMetalChains
_emberMetalEvents
_emberMetalMixin
_emberMetalError
_emberRuntimeMixinsAction_handler
_emberMetalProperties
_emberMetalBinding
_emberMetalComputed
_emberMetalInjected_property
_emberMetalRun_loop
_emberMetalWatching
_emberMetalCore
_emberRuntimeInject
_emberMetalSymbol
)
{
'
no
use
strict
'
;
var
_Mixin
create
;
var
POST_INIT
=
_emberMetalSymbol
.
default
(
'
POST_INIT
'
)
;
exports
.
POST_INIT
=
POST_INIT
;
var
schedule
=
_emberMetalRun_loop
.
default
.
schedule
;
var
applyMixin
=
_emberMetalMixin
.
Mixin
.
_apply
;
var
finishPartial
=
_emberMetalMixin
.
Mixin
.
finishPartial
;
var
reopen
=
_emberMetalMixin
.
Mixin
.
prototype
.
reopen
;
var
hasCachedComputedProperties
=
false
;
function
makeCtor
(
)
{
var
wasApplied
=
false
;
var
initProperties
;
var
Class
=
function
(
)
{
if
(
!
wasApplied
)
{
Class
.
proto
(
)
;
}
if
(
arguments
.
length
>
0
)
{
initProperties
=
[
arguments
[
0
]
]
;
}
this
.
__defineNonEnumerable
(
_emberMetalUtils
.
GUID_KEY_PROPERTY
)
;
var
m
=
_emberMetalMeta
.
meta
(
this
)
;
var
proto
=
m
.
proto
;
m
.
proto
=
this
;
if
(
initProperties
)
{
var
props
=
initProperties
;
initProperties
=
null
;
var
concatenatedProperties
=
this
.
concatenatedProperties
;
var
mergedProperties
=
this
.
mergedProperties
;
for
(
var
i
=
0
l
=
props
.
length
;
i
<
l
;
i
+
+
)
{
var
properties
=
props
[
i
]
;
_emberMetalDebug
.
assert
(
'
Ember
.
Object
.
create
no
longer
supports
mixing
in
other
'
+
'
definitions
use
.
extend
&
.
create
separately
instead
.
'
!
(
properties
instanceof
_emberMetalMixin
.
Mixin
)
)
;
if
(
typeof
properties
!
=
=
'
object
'
&
&
properties
!
=
=
undefined
)
{
throw
new
_emberMetalError
.
default
(
'
Ember
.
Object
.
create
only
accepts
objects
.
'
)
;
}
if
(
!
properties
)
{
continue
;
}
var
keyNames
=
Object
.
keys
(
properties
)
;
for
(
var
j
=
0
ll
=
keyNames
.
length
;
j
<
ll
;
j
+
+
)
{
var
keyName
=
keyNames
[
j
]
;
var
value
=
properties
[
keyName
]
;
if
(
_emberMetalMixin
.
IS_BINDING
.
test
(
keyName
)
)
{
m
.
writeBindings
(
keyName
value
)
;
}
var
possibleDesc
=
this
[
keyName
]
;
var
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
_emberMetalDebug
.
assert
(
'
Ember
.
Object
.
create
no
longer
supports
defining
computed
'
+
'
properties
.
Define
computed
properties
using
extend
(
)
or
reopen
(
)
'
+
'
before
calling
create
(
)
.
'
!
(
value
instanceof
_emberMetalComputed
.
ComputedProperty
)
)
;
_emberMetalDebug
.
assert
(
'
Ember
.
Object
.
create
no
longer
supports
defining
methods
that
call
_super
.
'
!
(
typeof
value
=
=
=
'
function
'
&
&
value
.
toString
(
)
.
indexOf
(
'
.
_super
'
)
!
=
=
-
1
)
)
;
_emberMetalDebug
.
assert
(
'
actions
must
be
provided
at
extend
time
not
at
create
time
'
+
'
when
Ember
.
ActionHandler
is
used
(
i
.
e
.
views
controllers
&
routes
)
.
'
!
(
keyName
=
=
=
'
actions
'
&
&
_emberRuntimeMixinsAction_handler
.
default
.
detect
(
this
)
)
)
;
if
(
concatenatedProperties
&
&
concatenatedProperties
.
length
>
0
&
&
concatenatedProperties
.
indexOf
(
keyName
)
>
=
0
)
{
var
baseValue
=
this
[
keyName
]
;
if
(
baseValue
)
{
if
(
'
function
'
=
=
=
typeof
baseValue
.
concat
)
{
value
=
baseValue
.
concat
(
value
)
;
}
else
{
value
=
_emberMetalUtils
.
makeArray
(
baseValue
)
.
concat
(
value
)
;
}
}
else
{
value
=
_emberMetalUtils
.
makeArray
(
value
)
;
}
}
if
(
mergedProperties
&
&
mergedProperties
.
length
&
&
mergedProperties
.
indexOf
(
keyName
)
>
=
0
)
{
var
originalValue
=
this
[
keyName
]
;
value
=
_emberMetalAssign
.
default
(
{
}
originalValue
value
)
;
}
if
(
desc
)
{
desc
.
set
(
this
keyName
value
)
;
}
else
{
if
(
typeof
this
.
setUnknownProperty
=
=
=
'
function
'
&
&
!
(
keyName
in
this
)
)
{
this
.
setUnknownProperty
(
keyName
value
)
;
}
else
{
_emberMetalProperties
.
defineProperty
(
this
keyName
null
value
)
;
}
}
}
}
}
finishPartial
(
this
m
)
;
var
length
=
arguments
.
length
;
if
(
length
=
=
=
0
)
{
this
.
init
(
)
;
}
else
if
(
length
=
=
=
1
)
{
this
.
init
(
arguments
[
0
]
)
;
}
else
{
var
args
=
new
Array
(
length
)
;
for
(
var
x
=
0
;
x
<
length
;
x
+
+
)
{
args
[
x
]
=
arguments
[
x
]
;
}
this
.
init
.
apply
(
this
args
)
;
}
this
[
POST_INIT
]
(
)
;
m
.
proto
=
proto
;
_emberMetalChains
.
finishChains
(
this
)
;
_emberMetalEvents
.
sendEvent
(
this
'
init
'
)
;
}
;
Class
.
toString
=
_emberMetalMixin
.
Mixin
.
prototype
.
toString
;
Class
.
willReopen
=
function
(
)
{
if
(
wasApplied
)
{
Class
.
PrototypeMixin
=
_emberMetalMixin
.
Mixin
.
create
(
Class
.
PrototypeMixin
)
;
}
wasApplied
=
false
;
}
;
Class
.
_initProperties
=
function
(
args
)
{
initProperties
=
args
;
}
;
Class
.
proto
=
function
(
)
{
var
superclass
=
Class
.
superclass
;
if
(
superclass
)
{
superclass
.
proto
(
)
;
}
if
(
!
wasApplied
)
{
wasApplied
=
true
;
Class
.
PrototypeMixin
.
applyPartial
(
Class
.
prototype
)
;
}
return
this
.
prototype
;
}
;
return
Class
;
}
var
CoreObject
=
makeCtor
(
)
;
CoreObject
.
toString
=
function
(
)
{
return
'
Ember
.
CoreObject
'
;
}
;
CoreObject
.
PrototypeMixin
=
_emberMetalMixin
.
Mixin
.
create
(
(
_Mixin
create
=
{
reopen
:
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
applyMixin
(
this
args
true
)
;
return
this
;
}
init
:
function
(
)
{
}
}
_Mixin
create
[
POST_INIT
]
=
function
(
)
{
}
_Mixin
create
.
__defineNonEnumerable
=
function
(
property
)
{
Object
.
defineProperty
(
this
property
.
name
property
.
descriptor
)
;
}
_Mixin
create
.
concatenatedProperties
=
null
_Mixin
create
.
mergedProperties
=
null
_Mixin
create
.
isDestroyed
=
false
_Mixin
create
.
isDestroying
=
false
_Mixin
create
.
destroy
=
function
(
)
{
if
(
this
.
isDestroying
)
{
return
;
}
this
.
isDestroying
=
true
;
schedule
(
'
actions
'
this
this
.
willDestroy
)
;
schedule
(
'
destroy
'
this
this
.
_scheduledDestroy
)
;
return
this
;
}
_Mixin
create
.
willDestroy
=
_emberMetalCore
.
K
_Mixin
create
.
_scheduledDestroy
=
function
(
)
{
if
(
this
.
isDestroyed
)
{
return
;
}
_emberMetalWatching
.
destroy
(
this
)
;
this
.
isDestroyed
=
true
;
}
_Mixin
create
.
bind
=
function
(
to
from
)
{
if
(
!
(
from
instanceof
_emberMetalBinding
.
Binding
)
)
{
from
=
_emberMetalBinding
.
Binding
.
from
(
from
)
;
}
from
.
to
(
to
)
.
connect
(
this
)
;
return
from
;
}
_Mixin
create
.
toString
=
function
(
)
{
var
hasToStringExtension
=
typeof
this
.
toStringExtension
=
=
=
'
function
'
;
var
extension
=
hasToStringExtension
?
'
:
'
+
this
.
toStringExtension
(
)
:
'
'
;
var
ret
=
'
<
'
+
this
.
constructor
.
toString
(
)
+
'
:
'
+
_emberMetalUtils
.
guidFor
(
this
)
+
extension
+
'
>
'
;
return
ret
;
}
_Mixin
create
)
)
;
CoreObject
.
PrototypeMixin
.
ownerConstructor
=
CoreObject
;
CoreObject
.
__super__
=
null
;
var
ClassMixinProps
=
{
ClassMixin
:
_emberMetalMixin
.
REQUIRED
PrototypeMixin
:
_emberMetalMixin
.
REQUIRED
isClass
:
true
isMethod
:
false
extend
:
function
(
)
{
var
Class
=
makeCtor
(
)
;
var
proto
;
Class
.
ClassMixin
=
_emberMetalMixin
.
Mixin
.
create
(
this
.
ClassMixin
)
;
Class
.
PrototypeMixin
=
_emberMetalMixin
.
Mixin
.
create
(
this
.
PrototypeMixin
)
;
Class
.
ClassMixin
.
ownerConstructor
=
Class
;
Class
.
PrototypeMixin
.
ownerConstructor
=
Class
;
reopen
.
apply
(
Class
.
PrototypeMixin
arguments
)
;
Class
.
superclass
=
this
;
Class
.
__super__
=
this
.
prototype
;
proto
=
Class
.
prototype
=
Object
.
create
(
this
.
prototype
)
;
proto
.
constructor
=
Class
;
_emberMetalUtils
.
generateGuid
(
proto
)
;
_emberMetalMeta
.
meta
(
proto
)
.
proto
=
proto
;
Class
.
ClassMixin
.
apply
(
Class
)
;
return
Class
;
}
create
:
function
(
)
{
var
C
=
this
;
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
if
(
args
.
length
>
0
)
{
this
.
_initProperties
(
args
)
;
}
return
new
C
(
)
;
}
reopen
:
function
(
)
{
this
.
willReopen
(
)
;
reopen
.
apply
(
this
.
PrototypeMixin
arguments
)
;
return
this
;
}
reopenClass
:
function
(
)
{
reopen
.
apply
(
this
.
ClassMixin
arguments
)
;
applyMixin
(
this
arguments
false
)
;
return
this
;
}
detect
:
function
(
obj
)
{
if
(
'
function
'
!
=
=
typeof
obj
)
{
return
false
;
}
while
(
obj
)
{
if
(
obj
=
=
=
this
)
{
return
true
;
}
obj
=
obj
.
superclass
;
}
return
false
;
}
detectInstance
:
function
(
obj
)
{
return
obj
instanceof
this
;
}
metaForProperty
:
function
(
key
)
{
var
proto
=
this
.
proto
(
)
;
var
possibleDesc
=
proto
[
key
]
;
var
desc
=
possibleDesc
!
=
=
null
&
&
typeof
possibleDesc
=
=
=
'
object
'
&
&
possibleDesc
.
isDescriptor
?
possibleDesc
:
undefined
;
_emberMetalDebug
.
assert
(
'
metaForProperty
(
)
could
not
find
a
computed
property
'
+
'
with
key
\
'
'
+
key
+
'
\
'
.
'
!
!
desc
&
&
desc
instanceof
_emberMetalComputed
.
ComputedProperty
)
;
return
desc
.
_meta
|
|
{
}
;
}
_computedProperties
:
_emberMetalComputed
.
computed
(
function
(
)
{
hasCachedComputedProperties
=
true
;
var
proto
=
this
.
proto
(
)
;
var
property
;
var
properties
=
[
]
;
for
(
var
name
in
proto
)
{
property
=
proto
[
name
]
;
if
(
property
&
&
property
.
isDescriptor
)
{
properties
.
push
(
{
name
:
name
meta
:
property
.
_meta
}
)
;
}
}
return
properties
;
}
)
.
readOnly
(
)
eachComputedProperty
:
function
(
callback
binding
)
{
var
property
;
var
empty
=
{
}
;
var
properties
=
_emberMetalProperty_get
.
get
(
this
'
_computedProperties
'
)
;
for
(
var
i
=
0
length
=
properties
.
length
;
i
<
length
;
i
+
+
)
{
property
=
properties
[
i
]
;
callback
.
call
(
binding
|
|
this
property
.
name
property
.
meta
|
|
empty
)
;
}
}
}
;
function
injectedPropertyAssertion
(
)
{
_emberMetalDebug
.
assert
(
'
Injected
properties
are
invalid
'
_emberRuntimeInject
.
validatePropertyInjections
(
this
)
)
;
}
_emberMetalDebug
.
runInDebug
(
function
(
)
{
ClassMixinProps
.
_onLookup
=
injectedPropertyAssertion
;
}
)
;
ClassMixinProps
.
_lazyInjections
=
function
(
)
{
var
injections
=
{
}
;
var
proto
=
this
.
proto
(
)
;
var
key
desc
;
for
(
key
in
proto
)
{
desc
=
proto
[
key
]
;
if
(
desc
instanceof
_emberMetalInjected_property
.
default
)
{
injections
[
key
]
=
desc
.
type
+
'
:
'
+
(
desc
.
name
|
|
key
)
;
}
}
return
injections
;
}
;
var
ClassMixin
=
_emberMetalMixin
.
Mixin
.
create
(
ClassMixinProps
)
;
ClassMixin
.
ownerConstructor
=
CoreObject
;
CoreObject
.
ClassMixin
=
ClassMixin
;
ClassMixin
.
apply
(
CoreObject
)
;
CoreObject
.
reopen
(
{
didDefineProperty
:
function
(
proto
key
value
)
{
if
(
hasCachedComputedProperties
=
=
=
false
)
{
return
;
}
if
(
value
instanceof
_emberMetalComputed
.
ComputedProperty
)
{
var
cache
=
_emberMetalMeta
.
meta
(
this
.
constructor
)
.
readableCache
(
)
;
if
(
cache
&
&
cache
.
_computedProperties
!
=
=
undefined
)
{
cache
.
_computedProperties
=
undefined
;
}
}
}
}
)
;
exports
.
default
=
CoreObject
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
each_proxy
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
property_events
'
'
ember
-
metal
/
empty_object
'
'
ember
-
runtime
/
mixins
/
array
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalObserver
_emberMetalProperty_events
_emberMetalEmpty_object
_emberRuntimeMixinsArray
)
{
'
use
strict
'
;
function
EachProxy
(
content
)
{
this
.
_content
=
content
;
this
.
_keys
=
undefined
;
this
.
__ember_meta__
=
null
;
}
EachProxy
.
prototype
=
{
__defineNonEnumerable
:
function
(
property
)
{
this
[
property
.
name
]
=
property
.
descriptor
.
value
;
}
arrayWillChange
:
function
(
content
idx
removedCnt
addedCnt
)
{
var
keys
=
this
.
_keys
;
var
lim
=
removedCnt
>
0
?
idx
+
removedCnt
:
-
1
;
for
(
var
key
in
keys
)
{
if
(
lim
>
0
)
{
removeObserverForContentKey
(
content
key
this
idx
lim
)
;
}
_emberMetalProperty_events
.
propertyWillChange
(
this
key
)
;
}
}
arrayDidChange
:
function
(
content
idx
removedCnt
addedCnt
)
{
var
keys
=
this
.
_keys
;
var
lim
=
addedCnt
>
0
?
idx
+
addedCnt
:
-
1
;
for
(
var
key
in
keys
)
{
if
(
lim
>
0
)
{
addObserverForContentKey
(
content
key
this
idx
lim
)
;
}
_emberMetalProperty_events
.
propertyDidChange
(
this
key
)
;
}
}
willWatchProperty
:
function
(
property
)
{
this
.
beginObservingContentKey
(
property
)
;
}
didUnwatchProperty
:
function
(
property
)
{
this
.
stopObservingContentKey
(
property
)
;
}
beginObservingContentKey
:
function
(
keyName
)
{
var
keys
=
this
.
_keys
;
if
(
!
keys
)
{
keys
=
this
.
_keys
=
new
_emberMetalEmpty_object
.
default
(
)
;
}
if
(
!
keys
[
keyName
]
)
{
keys
[
keyName
]
=
1
;
var
content
=
this
.
_content
;
var
len
=
_emberMetalProperty_get
.
get
(
content
'
length
'
)
;
addObserverForContentKey
(
content
keyName
this
0
len
)
;
}
else
{
keys
[
keyName
]
+
+
;
}
}
stopObservingContentKey
:
function
(
keyName
)
{
var
keys
=
this
.
_keys
;
if
(
keys
&
&
keys
[
keyName
]
>
0
&
&
-
-
keys
[
keyName
]
<
=
0
)
{
var
content
=
this
.
_content
;
var
len
=
_emberMetalProperty_get
.
get
(
content
'
length
'
)
;
removeObserverForContentKey
(
content
keyName
this
0
len
)
;
}
}
contentKeyWillChange
:
function
(
obj
keyName
)
{
_emberMetalProperty_events
.
propertyWillChange
(
this
keyName
)
;
}
contentKeyDidChange
:
function
(
obj
keyName
)
{
_emberMetalProperty_events
.
propertyDidChange
(
this
keyName
)
;
}
}
;
function
addObserverForContentKey
(
content
keyName
proxy
idx
loc
)
{
while
(
-
-
loc
>
=
idx
)
{
var
item
=
_emberRuntimeMixinsArray
.
objectAt
(
content
loc
)
;
if
(
item
)
{
_emberMetalDebug
.
assert
(
'
When
using
each
to
observe
the
array
'
+
content
+
'
the
array
must
return
an
object
'
typeof
item
=
=
=
'
object
'
)
;
_emberMetalObserver
.
_addBeforeObserver
(
item
keyName
proxy
'
contentKeyWillChange
'
)
;
_emberMetalObserver
.
addObserver
(
item
keyName
proxy
'
contentKeyDidChange
'
)
;
}
}
}
function
removeObserverForContentKey
(
content
keyName
proxy
idx
loc
)
{
while
(
-
-
loc
>
=
idx
)
{
var
item
=
_emberRuntimeMixinsArray
.
objectAt
(
content
loc
)
;
if
(
item
)
{
_emberMetalObserver
.
_removeBeforeObserver
(
item
keyName
proxy
'
contentKeyWillChange
'
)
;
_emberMetalObserver
.
removeObserver
(
item
keyName
proxy
'
contentKeyDidChange
'
)
;
}
}
}
exports
.
default
=
EachProxy
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
lazy_load
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
runtime
/
system
/
native_array
'
]
function
(
exports
_emberMetalCore
_emberRuntimeSystemNative_array
)
{
'
use
strict
'
;
exports
.
onLoad
=
onLoad
;
exports
.
runLoadHooks
=
runLoadHooks
;
var
loadHooks
=
_emberMetalCore
.
default
.
ENV
.
EMBER_LOAD_HOOKS
|
|
{
}
;
var
loaded
=
{
}
;
var
_loaded
=
loaded
;
exports
.
_loaded
=
_loaded
;
function
onLoad
(
name
callback
)
{
var
object
=
loaded
[
name
]
;
loadHooks
[
name
]
=
loadHooks
[
name
]
|
|
_emberRuntimeSystemNative_array
.
A
(
)
;
loadHooks
[
name
]
.
pushObject
(
callback
)
;
if
(
object
)
{
callback
(
object
)
;
}
}
function
runLoadHooks
(
name
object
)
{
loaded
[
name
]
=
object
;
if
(
typeof
window
=
=
=
'
object
'
&
&
typeof
window
.
dispatchEvent
=
=
=
'
function
'
&
&
typeof
CustomEvent
=
=
=
'
function
'
)
{
var
event
=
new
CustomEvent
(
name
{
detail
:
object
name
:
name
}
)
;
window
.
dispatchEvent
(
event
)
;
}
if
(
loadHooks
[
name
]
)
{
loadHooks
[
name
]
.
forEach
(
function
(
callback
)
{
return
callback
(
object
)
;
}
)
;
}
}
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
namespace
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberMetalCore
_emberMetalProperty_get
_emberMetalUtils
_emberMetalMixin
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
var
Namespace
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
isNamespace
:
true
init
:
function
(
)
{
Namespace
.
NAMESPACES
.
push
(
this
)
;
Namespace
.
PROCESSED
=
false
;
}
toString
:
function
(
)
{
var
name
=
_emberMetalProperty_get
.
get
(
this
'
name
'
)
|
|
_emberMetalProperty_get
.
get
(
this
'
modulePrefix
'
)
;
if
(
name
)
{
return
name
;
}
findNamespaces
(
)
;
return
this
[
NAME_KEY
]
;
}
nameClasses
:
function
(
)
{
processNamespace
(
[
this
.
toString
(
)
]
this
{
}
)
;
}
destroy
:
function
(
)
{
var
namespaces
=
Namespace
.
NAMESPACES
;
var
toString
=
this
.
toString
(
)
;
if
(
toString
)
{
_emberMetalCore
.
default
.
lookup
[
toString
]
=
undefined
;
delete
Namespace
.
NAMESPACES_BY_ID
[
toString
]
;
}
namespaces
.
splice
(
namespaces
.
indexOf
(
this
)
1
)
;
this
.
_super
.
apply
(
this
arguments
)
;
}
}
)
;
Namespace
.
reopenClass
(
{
NAMESPACES
:
[
_emberMetalCore
.
default
]
NAMESPACES_BY_ID
:
{
}
PROCESSED
:
false
processAll
:
processAllNamespaces
byName
:
function
(
name
)
{
if
(
!
_emberMetalCore
.
default
.
BOOTED
)
{
processAllNamespaces
(
)
;
}
return
NAMESPACES_BY_ID
[
name
]
;
}
}
)
;
var
NAMESPACES_BY_ID
=
Namespace
.
NAMESPACES_BY_ID
;
var
hasOwnProp
=
(
{
}
)
.
hasOwnProperty
;
function
processNamespace
(
paths
root
seen
)
{
var
idx
=
paths
.
length
;
NAMESPACES_BY_ID
[
paths
.
join
(
'
.
'
)
]
=
root
;
for
(
var
key
in
root
)
{
if
(
!
hasOwnProp
.
call
(
root
key
)
)
{
continue
;
}
var
obj
=
root
[
key
]
;
paths
[
idx
]
=
key
;
if
(
obj
&
&
obj
.
toString
=
=
=
classToString
&
&
!
obj
[
NAME_KEY
]
)
{
obj
[
NAME_KEY
]
=
paths
.
join
(
'
.
'
)
;
}
else
if
(
obj
&
&
obj
.
isNamespace
)
{
if
(
seen
[
_emberMetalUtils
.
guidFor
(
obj
)
]
)
{
continue
;
}
seen
[
_emberMetalUtils
.
guidFor
(
obj
)
]
=
true
;
processNamespace
(
paths
obj
seen
)
;
}
}
paths
.
length
=
idx
;
}
var
STARTS_WITH_UPPERCASE
=
/
^
[
A
-
Z
]
/
;
function
tryIsNamespace
(
lookup
prop
)
{
try
{
var
obj
=
lookup
[
prop
]
;
return
obj
&
&
obj
.
isNamespace
&
&
obj
;
}
catch
(
e
)
{
}
}
function
findNamespaces
(
)
{
var
lookup
=
_emberMetalCore
.
default
.
lookup
;
var
obj
;
if
(
Namespace
.
PROCESSED
)
{
return
;
}
for
(
var
prop
in
lookup
)
{
if
(
!
STARTS_WITH_UPPERCASE
.
test
(
prop
)
)
{
continue
;
}
if
(
lookup
.
hasOwnProperty
&
&
!
lookup
.
hasOwnProperty
(
prop
)
)
{
continue
;
}
obj
=
tryIsNamespace
(
lookup
prop
)
;
if
(
obj
)
{
obj
[
NAME_KEY
]
=
prop
;
}
}
}
var
NAME_KEY
=
_emberMetalCore
.
default
.
NAME_KEY
=
_emberMetalUtils
.
GUID_KEY
+
'
_name
'
;
function
superClassString
(
mixin
)
{
var
superclass
=
mixin
.
superclass
;
if
(
superclass
)
{
if
(
superclass
[
NAME_KEY
]
)
{
return
superclass
[
NAME_KEY
]
;
}
else
{
return
superClassString
(
superclass
)
;
}
}
else
{
return
;
}
}
function
classToString
(
)
{
if
(
!
_emberMetalCore
.
default
.
BOOTED
&
&
!
this
[
NAME_KEY
]
)
{
processAllNamespaces
(
)
;
}
var
ret
;
if
(
this
[
NAME_KEY
]
)
{
ret
=
this
[
NAME_KEY
]
;
}
else
if
(
this
.
_toString
)
{
ret
=
this
.
_toString
;
}
else
{
var
str
=
superClassString
(
this
)
;
if
(
str
)
{
ret
=
'
(
subclass
of
'
+
str
+
'
)
'
;
}
else
{
ret
=
'
(
unknown
mixin
)
'
;
}
this
.
toString
=
makeToString
(
ret
)
;
}
return
ret
;
}
function
processAllNamespaces
(
)
{
var
unprocessedNamespaces
=
!
Namespace
.
PROCESSED
;
var
unprocessedMixins
=
_emberMetalCore
.
default
.
anyUnprocessedMixins
;
if
(
unprocessedNamespaces
)
{
findNamespaces
(
)
;
Namespace
.
PROCESSED
=
true
;
}
if
(
unprocessedNamespaces
|
|
unprocessedMixins
)
{
var
namespaces
=
Namespace
.
NAMESPACES
;
var
namespace
;
for
(
var
i
=
0
l
=
namespaces
.
length
;
i
<
l
;
i
+
+
)
{
namespace
=
namespaces
[
i
]
;
processNamespace
(
[
namespace
.
toString
(
)
]
namespace
{
}
)
;
}
_emberMetalCore
.
default
.
anyUnprocessedMixins
=
false
;
}
}
function
makeToString
(
ret
)
{
return
function
(
)
{
return
ret
;
}
;
}
_emberMetalMixin
.
Mixin
.
prototype
.
toString
=
classToString
;
exports
.
default
=
Namespace
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
native_array
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
replace
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
mixins
/
mutable_array
'
'
ember
-
runtime
/
mixins
/
observable
'
'
ember
-
runtime
/
mixins
/
copyable
'
'
ember
-
runtime
/
mixins
/
freezable
'
'
ember
-
runtime
/
copy
'
]
function
(
exports
_emberMetalCore
_emberMetalReplace
_emberMetalProperty_get
_emberMetalMixin
_emberRuntimeMixinsArray
_emberRuntimeMixinsMutable_array
_emberRuntimeMixinsObservable
_emberRuntimeMixinsCopyable
_emberRuntimeMixinsFreezable
_emberRuntimeCopy
)
{
'
use
strict
'
;
var
NativeArray
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsMutable_array
.
default
_emberRuntimeMixinsObservable
.
default
_emberRuntimeMixinsCopyable
.
default
{
get
:
function
(
key
)
{
if
(
key
=
=
=
'
length
'
)
{
return
this
.
length
;
}
else
if
(
'
number
'
=
=
=
typeof
key
)
{
return
this
[
key
]
;
}
else
{
return
this
.
_super
(
key
)
;
}
}
objectAt
:
function
(
idx
)
{
return
this
[
idx
]
;
}
replace
:
function
(
idx
amt
objects
)
{
if
(
this
.
isFrozen
)
{
throw
_emberRuntimeMixinsFreezable
.
FROZEN_ERROR
;
}
var
len
=
objects
?
_emberMetalProperty_get
.
get
(
objects
'
length
'
)
:
0
;
this
.
arrayContentWillChange
(
idx
amt
len
)
;
if
(
len
=
=
=
0
)
{
this
.
splice
(
idx
amt
)
;
}
else
{
_emberMetalReplace
.
_replace
(
this
idx
amt
objects
)
;
}
this
.
arrayContentDidChange
(
idx
amt
len
)
;
return
this
;
}
unknownProperty
:
function
(
key
value
)
{
var
ret
;
if
(
value
!
=
=
undefined
&
&
ret
=
=
=
undefined
)
{
ret
=
this
[
key
]
=
value
;
}
return
ret
;
}
indexOf
:
Array
.
prototype
.
indexOf
lastIndexOf
:
Array
.
prototype
.
lastIndexOf
copy
:
function
(
deep
)
{
if
(
deep
)
{
return
this
.
map
(
function
(
item
)
{
return
_emberRuntimeCopy
.
default
(
item
true
)
;
}
)
;
}
return
this
.
slice
(
)
;
}
}
)
;
var
ignore
=
[
'
length
'
]
;
NativeArray
.
keys
(
)
.
forEach
(
function
(
methodName
)
{
if
(
Array
.
prototype
[
methodName
]
)
{
ignore
.
push
(
methodName
)
;
}
}
)
;
exports
.
NativeArray
=
NativeArray
=
NativeArray
.
without
.
apply
(
NativeArray
ignore
)
;
var
A
;
if
(
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
=
=
=
true
|
|
_emberMetalCore
.
default
.
EXTEND_PROTOTYPES
.
Array
)
{
NativeArray
.
apply
(
Array
.
prototype
)
;
exports
.
A
=
A
=
function
(
arr
)
{
return
arr
|
|
[
]
;
}
;
}
else
{
exports
.
A
=
A
=
function
(
arr
)
{
if
(
!
arr
)
{
arr
=
[
]
;
}
return
_emberRuntimeMixinsArray
.
default
.
detect
(
arr
)
?
arr
:
NativeArray
.
apply
(
arr
)
;
}
;
}
_emberMetalCore
.
default
.
A
=
A
;
exports
.
A
=
A
;
exports
.
NativeArray
=
NativeArray
;
exports
.
default
=
NativeArray
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
object
'
[
'
exports
'
'
ember
-
runtime
/
system
/
core_object
'
'
ember
-
runtime
/
mixins
/
observable
'
]
function
(
exports
_emberRuntimeSystemCore_object
_emberRuntimeMixinsObservable
)
{
'
use
strict
'
;
var
EmberObject
=
_emberRuntimeSystemCore_object
.
default
.
extend
(
_emberRuntimeMixinsObservable
.
default
)
;
EmberObject
.
toString
=
function
(
)
{
return
'
Ember
.
Object
'
;
}
;
exports
.
default
=
EmberObject
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
object_proxy
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
-
proxy
'
]
function
(
exports
_emberRuntimeSystemObject
_emberRuntimeMixinsProxy
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsProxy
.
default
)
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
service
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
inject
'
]
function
(
exports
_emberRuntimeSystemObject
_emberRuntimeInject
)
{
'
use
strict
'
;
_emberRuntimeInject
.
createInjectionHelper
(
'
service
'
)
;
var
Service
=
_emberRuntimeSystemObject
.
default
.
extend
(
)
;
Service
.
reopenClass
(
{
isServiceFactory
:
true
}
)
;
exports
.
default
=
Service
;
}
)
;
enifed
(
'
ember
-
runtime
/
system
/
string
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
utils
'
'
ember
-
runtime
/
utils
'
'
ember
-
runtime
/
string_registry
'
'
ember
-
metal
/
cache
'
]
function
(
exports
_emberMetalDebug
_emberMetalUtils
_emberRuntimeUtils
_emberRuntimeString_registry
_emberMetalCache
)
{
'
use
strict
'
;
var
STRING_DASHERIZE_REGEXP
=
/
[
_
]
/
g
;
var
STRING_DASHERIZE_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
decamelize
(
key
)
.
replace
(
STRING_DASHERIZE_REGEXP
'
-
'
)
;
}
)
;
var
STRING_CAMELIZE_REGEXP_1
=
/
(
\
-
|
\
_
|
\
.
|
\
s
)
+
(
.
)
?
/
g
;
var
STRING_CAMELIZE_REGEXP_2
=
/
(
^
|
\
/
)
(
[
A
-
Z
]
)
/
g
;
var
CAMELIZE_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
key
)
{
return
key
.
replace
(
STRING_CAMELIZE_REGEXP_1
function
(
match
separator
chr
)
{
return
chr
?
chr
.
toUpperCase
(
)
:
'
'
;
}
)
.
replace
(
STRING_CAMELIZE_REGEXP_2
function
(
match
separator
chr
)
{
return
match
.
toLowerCase
(
)
;
}
)
;
}
)
;
var
STRING_CLASSIFY_REGEXP_1
=
/
^
(
\
-
|
_
)
+
(
.
)
?
/
;
var
STRING_CLASSIFY_REGEXP_2
=
/
(
.
)
(
\
-
|
\
_
|
\
.
|
\
s
)
+
(
.
)
?
/
g
;
var
STRING_CLASSIFY_REGEXP_3
=
/
(
^
|
\
/
|
\
.
)
(
[
a
-
z
]
)
/
g
;
var
CLASSIFY_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
str
)
{
var
replace1
=
function
(
match
separator
chr
)
{
return
chr
?
'
_
'
+
chr
.
toUpperCase
(
)
:
'
'
;
}
;
var
replace2
=
function
(
match
initialChar
separator
chr
)
{
return
initialChar
+
(
chr
?
chr
.
toUpperCase
(
)
:
'
'
)
;
}
;
var
parts
=
str
.
split
(
'
/
'
)
;
for
(
var
i
=
0
len
=
parts
.
length
;
i
<
len
;
i
+
+
)
{
parts
[
i
]
=
parts
[
i
]
.
replace
(
STRING_CLASSIFY_REGEXP_1
replace1
)
.
replace
(
STRING_CLASSIFY_REGEXP_2
replace2
)
;
}
return
parts
.
join
(
'
/
'
)
.
replace
(
STRING_CLASSIFY_REGEXP_3
function
(
match
separator
chr
)
{
return
match
.
toUpperCase
(
)
;
}
)
;
}
)
;
var
STRING_UNDERSCORE_REGEXP_1
=
/
(
[
a
-
z
\
d
]
)
(
[
A
-
Z
]
+
)
/
g
;
var
STRING_UNDERSCORE_REGEXP_2
=
/
\
-
|
\
s
+
/
g
;
var
UNDERSCORE_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
str
)
{
return
str
.
replace
(
STRING_UNDERSCORE_REGEXP_1
'
1_
2
'
)
.
replace
(
STRING_UNDERSCORE_REGEXP_2
'
_
'
)
.
toLowerCase
(
)
;
}
)
;
var
STRING_CAPITALIZE_REGEXP
=
/
(
^
|
\
/
)
(
[
a
-
z
]
)
/
g
;
var
CAPITALIZE_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
str
)
{
return
str
.
replace
(
STRING_CAPITALIZE_REGEXP
function
(
match
separator
chr
)
{
return
match
.
toUpperCase
(
)
;
}
)
;
}
)
;
var
STRING_DECAMELIZE_REGEXP
=
/
(
[
a
-
z
\
d
]
)
(
[
A
-
Z
]
)
/
g
;
var
DECAMELIZE_CACHE
=
new
_emberMetalCache
.
default
(
1000
function
(
str
)
{
return
str
.
replace
(
STRING_DECAMELIZE_REGEXP
'
1_
2
'
)
.
toLowerCase
(
)
;
}
)
;
function
_fmt
(
str
formats
)
{
var
cachedFormats
=
formats
;
if
(
!
_emberRuntimeUtils
.
isArray
(
cachedFormats
)
|
|
arguments
.
length
>
2
)
{
cachedFormats
=
new
Array
(
arguments
.
length
-
1
)
;
for
(
var
i
=
1
l
=
arguments
.
length
;
i
<
l
;
i
+
+
)
{
cachedFormats
[
i
-
1
]
=
arguments
[
i
]
;
}
}
var
idx
=
0
;
return
str
.
replace
(
/
%
(
[
0
-
9
]
+
)
?
/
g
function
(
s
argIndex
)
{
argIndex
=
argIndex
?
parseInt
(
argIndex
10
)
-
1
:
idx
+
+
;
s
=
cachedFormats
[
argIndex
]
;
return
s
=
=
=
null
?
'
(
null
)
'
:
s
=
=
=
undefined
?
'
'
:
_emberMetalUtils
.
inspect
(
s
)
;
}
)
;
}
function
fmt
(
str
formats
)
{
_emberMetalDebug
.
deprecate
(
'
Ember
.
String
.
fmt
is
deprecated
use
ES6
template
strings
instead
.
'
false
{
id
:
'
ember
-
string
-
utils
.
fmt
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
babeljs
.
io
/
docs
/
learn
-
es2015
/
#
template
-
strings
'
}
)
;
return
_fmt
.
apply
(
undefined
arguments
)
;
}
function
loc
(
str
formats
)
{
if
(
!
_emberRuntimeUtils
.
isArray
(
formats
)
|
|
arguments
.
length
>
2
)
{
formats
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
}
str
=
_emberRuntimeString_registry
.
get
(
str
)
|
|
str
;
return
_fmt
(
str
formats
)
;
}
function
w
(
str
)
{
return
str
.
split
(
/
\
s
+
/
)
;
}
function
decamelize
(
str
)
{
return
DECAMELIZE_CACHE
.
get
(
str
)
;
}
function
dasherize
(
str
)
{
return
STRING_DASHERIZE_CACHE
.
get
(
str
)
;
}
function
camelize
(
str
)
{
return
CAMELIZE_CACHE
.
get
(
str
)
;
}
function
classify
(
str
)
{
return
CLASSIFY_CACHE
.
get
(
str
)
;
}
function
underscore
(
str
)
{
return
UNDERSCORE_CACHE
.
get
(
str
)
;
}
function
capitalize
(
str
)
{
return
CAPITALIZE_CACHE
.
get
(
str
)
;
}
exports
.
default
=
{
fmt
:
fmt
loc
:
loc
w
:
w
decamelize
:
decamelize
dasherize
:
dasherize
camelize
:
camelize
classify
:
classify
underscore
:
underscore
capitalize
:
capitalize
}
;
exports
.
fmt
=
fmt
;
exports
.
loc
=
loc
;
exports
.
w
=
w
;
exports
.
decamelize
=
decamelize
;
exports
.
dasherize
=
dasherize
;
exports
.
camelize
=
camelize
;
exports
.
classify
=
classify
;
exports
.
underscore
=
underscore
;
exports
.
capitalize
=
capitalize
;
}
)
;
enifed
(
'
ember
-
runtime
/
utils
'
[
'
exports
'
'
ember
-
runtime
/
mixins
/
array
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberRuntimeMixinsArray
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
exports
.
isArray
=
isArray
;
exports
.
typeOf
=
typeOf
;
var
TYPE_MAP
=
{
'
[
object
Boolean
]
'
:
'
boolean
'
'
[
object
Number
]
'
:
'
number
'
'
[
object
String
]
'
:
'
string
'
'
[
object
Function
]
'
:
'
function
'
'
[
object
Array
]
'
:
'
array
'
'
[
object
Date
]
'
:
'
date
'
'
[
object
RegExp
]
'
:
'
regexp
'
'
[
object
Object
]
'
:
'
object
'
}
;
var
toString
=
Object
.
prototype
.
toString
;
function
isArray
(
obj
)
{
if
(
!
obj
|
|
obj
.
setInterval
)
{
return
false
;
}
if
(
Array
.
isArray
(
obj
)
)
{
return
true
;
}
if
(
_emberRuntimeMixinsArray
.
default
.
detect
(
obj
)
)
{
return
true
;
}
var
type
=
typeOf
(
obj
)
;
if
(
'
array
'
=
=
=
type
)
{
return
true
;
}
if
(
obj
.
length
!
=
=
undefined
&
&
'
object
'
=
=
=
type
)
{
return
true
;
}
return
false
;
}
function
typeOf
(
item
)
{
if
(
item
=
=
=
null
)
{
return
'
null
'
;
}
if
(
item
=
=
=
undefined
)
{
return
'
undefined
'
;
}
var
ret
=
TYPE_MAP
[
toString
.
call
(
item
)
]
|
|
'
object
'
;
if
(
ret
=
=
=
'
function
'
)
{
if
(
_emberRuntimeSystemObject
.
default
.
detect
(
item
)
)
{
ret
=
'
class
'
;
}
}
else
if
(
ret
=
=
=
'
object
'
)
{
if
(
item
instanceof
Error
)
{
ret
=
'
error
'
;
}
else
if
(
item
instanceof
_emberRuntimeSystemObject
.
default
)
{
ret
=
'
instance
'
;
}
else
if
(
item
instanceof
Date
)
{
ret
=
'
date
'
;
}
}
return
ret
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
compat
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
template
-
compiler
/
compat
/
precompile
'
'
ember
-
template
-
compiler
/
system
/
compile
'
'
ember
-
template
-
compiler
/
system
/
template
'
]
function
(
exports
_emberMetalCore
_emberTemplateCompilerCompatPrecompile
_emberTemplateCompilerSystemCompile
_emberTemplateCompilerSystemTemplate
)
{
'
use
strict
'
;
var
EmberHandlebars
=
_emberMetalCore
.
default
.
Handlebars
=
_emberMetalCore
.
default
.
Handlebars
|
|
{
}
;
EmberHandlebars
.
precompile
=
_emberTemplateCompilerCompatPrecompile
.
default
;
EmberHandlebars
.
compile
=
_emberTemplateCompilerSystemCompile
.
default
;
EmberHandlebars
.
template
=
_emberTemplateCompilerSystemTemplate
.
default
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
compat
/
precompile
'
[
'
exports
'
'
require
'
'
ember
-
template
-
compiler
/
system
/
compile_options
'
]
function
(
exports
_require
_emberTemplateCompilerSystemCompile_options
)
{
'
use
strict
'
;
var
compile
compileSpec
;
exports
.
default
=
function
(
string
)
{
if
(
(
!
compile
|
|
!
compileSpec
)
&
&
_require
.
has
(
'
htmlbars
-
compiler
/
compiler
'
)
)
{
var
Compiler
=
_require
.
default
(
'
htmlbars
-
compiler
/
compiler
'
)
;
compile
=
Compiler
.
compile
;
compileSpec
=
Compiler
.
compileSpec
;
}
if
(
!
compile
|
|
!
compileSpec
)
{
throw
new
Error
(
'
Cannot
call
precompile
without
the
template
compiler
loaded
.
Please
load
ember
-
template
-
compiler
.
js
prior
to
calling
precompile
.
'
)
;
}
var
asObject
=
arguments
[
1
]
=
=
=
undefined
?
true
:
arguments
[
1
]
;
var
compileFunc
=
asObject
?
compile
:
compileSpec
;
return
compileFunc
(
string
_emberTemplateCompilerSystemCompile_options
.
default
(
)
)
;
}
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
index
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
template
-
compiler
/
system
/
precompile
'
'
ember
-
template
-
compiler
/
system
/
compile
'
'
ember
-
template
-
compiler
/
system
/
template
'
'
ember
-
template
-
compiler
/
plugins
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
binding
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
class
-
binding
-
syntax
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
item
-
class
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
closure
-
component
-
attrs
-
into
-
mut
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
component
-
attrs
-
into
-
mut
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
component
-
curly
-
to
-
readonly
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
angle
-
bracket
-
components
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
input
-
on
-
to
-
onEvent
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
top
-
level
-
components
'
'
ember
-
template
-
compiler
/
plugins
/
deprecate
-
render
-
model
'
'
ember
-
template
-
compiler
/
plugins
/
prevent
-
render
-
block
'
'
ember
-
template
-
compiler
/
plugins
/
transform
-
inline
-
link
-
to
'
'
ember
-
template
-
compiler
/
plugins
/
assert
-
no
-
view
-
and
-
controller
-
paths
'
'
ember
-
template
-
compiler
/
plugins
/
assert
-
no
-
view
-
helper
'
'
ember
-
template
-
compiler
/
plugins
/
assert
-
no
-
each
-
in
'
'
ember
-
template
-
compiler
/
compat
'
]
function
(
exports
_emberMetal
_emberTemplateCompilerSystemPrecompile
_emberTemplateCompilerSystemCompile
_emberTemplateCompilerSystemTemplate
_emberTemplateCompilerPlugins
_emberTemplateCompilerPluginsTransformOldBindingSyntax
_emberTemplateCompilerPluginsTransformOldClassBindingSyntax
_emberTemplateCompilerPluginsTransformItemClass
_emberTemplateCompilerPluginsTransformClosureComponentAttrsIntoMut
_emberTemplateCompilerPluginsTransformComponentAttrsIntoMut
_emberTemplateCompilerPluginsTransformComponentCurlyToReadonly
_emberTemplateCompilerPluginsTransformAngleBracketComponents
_emberTemplateCompilerPluginsTransformInputOnToOnEvent
_emberTemplateCompilerPluginsTransformTopLevelComponents
_emberTemplateCompilerPluginsDeprecateRenderModel
_emberTemplateCompilerPluginsPreventRenderBlock
_emberTemplateCompilerPluginsTransformInlineLinkTo
_emberTemplateCompilerPluginsAssertNoViewAndControllerPaths
_emberTemplateCompilerPluginsAssertNoViewHelper
_emberTemplateCompilerPluginsAssertNoEachIn
_emberTemplateCompilerCompat
)
{
'
use
strict
'
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformOldBindingSyntax
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformOldClassBindingSyntax
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformItemClass
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformClosureComponentAttrsIntoMut
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformComponentAttrsIntoMut
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformComponentCurlyToReadonly
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformAngleBracketComponents
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformInputOnToOnEvent
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformTopLevelComponents
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsDeprecateRenderModel
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsPreventRenderBlock
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsAssertNoEachIn
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsTransformInlineLinkTo
.
default
)
;
if
(
!
_emberMetal
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
)
{
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsAssertNoViewAndControllerPaths
.
default
)
;
_emberTemplateCompilerPlugins
.
registerPlugin
(
'
ast
'
_emberTemplateCompilerPluginsAssertNoViewHelper
.
default
)
;
}
exports
.
_Ember
=
_emberMetal
.
default
;
exports
.
precompile
=
_emberTemplateCompilerSystemPrecompile
.
default
;
exports
.
compile
=
_emberTemplateCompilerSystemCompile
.
default
;
exports
.
template
=
_emberTemplateCompilerSystemTemplate
.
default
;
exports
.
registerPlugin
=
_emberTemplateCompilerPlugins
.
registerPlugin
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
registerPlugin
=
registerPlugin
;
var
plugins
=
{
ast
:
[
]
}
;
function
registerPlugin
(
type
Plugin
)
{
if
(
!
plugins
[
type
]
)
{
throw
new
Error
(
'
Attempting
to
register
"
'
+
Plugin
+
'
"
as
"
'
+
type
+
'
"
which
is
not
a
valid
HTMLBars
plugin
type
.
'
)
;
}
plugins
[
type
]
.
push
(
Plugin
)
;
}
exports
.
default
=
plugins
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
assert
-
no
-
each
-
in
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
function
AssertNoEachIn
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
this
.
syntax
=
null
;
this
.
options
=
options
;
}
AssertNoEachIn
.
prototype
.
transform
=
function
AssertNoEachIn_transform
(
ast
)
{
if
(
!
!
_emberMetalCore
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
)
{
return
ast
;
}
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
var
moduleName
=
this
.
options
&
&
this
.
options
.
moduleName
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
assertHelper
(
moduleName
node
)
;
}
)
;
return
ast
;
}
;
function
assertHelper
(
moduleName
node
)
{
var
moduleInfo
=
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
node
.
loc
)
;
var
singular
=
node
.
params
[
0
]
.
original
;
var
plural
=
node
.
params
[
2
]
.
original
;
_emberMetalDebug
.
assert
(
'
Using
{
{
#
each
'
+
singular
+
'
in
'
+
plural
+
'
}
}
'
+
moduleInfo
+
'
is
no
longer
supported
in
Ember
2
.
0
+
please
use
{
{
#
each
'
+
plural
+
'
as
|
'
+
singular
+
'
|
}
}
'
)
;
}
function
validate
(
node
)
{
return
(
node
.
type
=
=
=
'
BlockStatement
'
|
|
node
.
type
=
=
=
'
MustacheStatement
'
)
&
&
node
.
path
.
original
=
=
=
'
each
'
&
&
node
.
params
.
length
=
=
=
3
&
&
node
.
params
[
1
]
.
type
=
=
=
'
PathExpression
'
&
&
node
.
params
[
1
]
.
original
=
=
=
'
in
'
;
}
exports
.
default
=
AssertNoEachIn
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
assert
-
no
-
view
-
and
-
controller
-
paths
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
function
AssertNoViewAndControllerPaths
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
this
.
syntax
=
null
;
this
.
options
=
options
;
}
AssertNoViewAndControllerPaths
.
prototype
.
transform
=
function
AssertNoViewAndControllerPaths_transform
(
ast
)
{
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
var
moduleName
=
this
.
options
&
&
this
.
options
.
moduleName
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
assertPath
(
moduleName
node
node
.
path
)
;
assertPaths
(
moduleName
node
node
.
params
)
;
assertHash
(
moduleName
node
node
.
hash
)
;
}
)
;
return
ast
;
}
;
function
assertHash
(
moduleName
node
hash
)
{
if
(
!
hash
|
|
!
hash
.
pairs
)
{
return
;
}
var
i
l
pair
paths
;
for
(
i
=
0
l
=
hash
.
pairs
.
length
;
i
<
l
;
i
+
+
)
{
pair
=
hash
.
pairs
[
i
]
;
paths
=
pair
.
value
.
params
;
assertPaths
(
moduleName
pair
paths
)
;
}
}
function
assertPaths
(
moduleName
node
paths
)
{
if
(
!
paths
)
{
return
;
}
var
i
l
path
;
for
(
i
=
0
l
=
paths
.
length
;
i
<
l
;
i
+
+
)
{
path
=
paths
[
i
]
;
assertPath
(
moduleName
node
path
)
;
}
}
function
assertPath
(
moduleName
node
path
)
{
_emberMetalDebug
.
assert
(
'
Using
{
{
'
+
(
path
&
&
path
.
type
=
=
=
'
PathExpression
'
&
&
path
.
parts
[
0
]
)
+
'
}
}
or
any
path
based
on
it
'
+
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
node
.
loc
)
+
'
has
been
removed
in
Ember
2
.
0
'
(
function
(
)
{
var
noAssertion
=
true
;
var
viewKeyword
=
path
&
&
path
.
type
=
=
=
'
PathExpression
'
&
&
path
.
parts
&
&
path
.
parts
[
0
]
;
if
(
viewKeyword
=
=
=
'
view
'
)
{
noAssertion
=
_emberMetalCore
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
;
}
return
noAssertion
;
}
)
(
)
{
id
:
path
.
parts
&
&
path
.
parts
[
0
]
=
=
=
'
view
'
?
'
view
.
keyword
.
view
'
:
'
view
.
keyword
.
controller
'
until
:
'
2
.
0
.
0
'
}
)
;
}
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
MustacheStatement
'
|
|
node
.
type
=
=
=
'
BlockStatement
'
;
}
exports
.
default
=
AssertNoViewAndControllerPaths
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
assert
-
no
-
view
-
helper
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
function
AssertNoViewHelper
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
this
.
syntax
=
null
;
this
.
options
=
options
;
}
AssertNoViewHelper
.
prototype
.
transform
=
function
AssertNoViewHelper_transform
(
ast
)
{
if
(
!
!
_emberMetalCore
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
)
{
return
ast
;
}
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
var
moduleName
=
this
.
options
&
&
this
.
options
.
moduleName
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
assertHelper
(
moduleName
node
)
;
}
)
;
return
ast
;
}
;
function
assertHelper
(
moduleName
node
)
{
var
paramValue
=
node
.
params
.
length
&
&
node
.
params
[
0
]
.
value
;
if
(
!
paramValue
)
{
return
;
}
else
{
_emberMetalDebug
.
assert
(
'
Using
the
{
{
view
"
string
"
}
}
helper
is
removed
in
2
.
0
.
'
+
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
node
.
loc
)
_emberMetalCore
.
default
.
ENV
.
_ENABLE_LEGACY_VIEW_SUPPORT
{
id
:
'
view
.
helper
'
until
:
'
2
.
0
.
0
'
}
)
;
}
}
function
validate
(
node
)
{
return
(
node
.
type
=
=
=
'
MustacheStatement
'
|
|
node
.
type
=
=
=
'
BlockStatement
'
)
&
&
node
.
path
.
parts
[
0
]
=
=
=
'
view
'
;
}
exports
.
default
=
AssertNoViewHelper
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
deprecate
-
render
-
model
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalDebug
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
DeprecateRenderModel
;
function
DeprecateRenderModel
(
options
)
{
this
.
syntax
=
null
;
this
.
options
=
options
;
}
DeprecateRenderModel
.
prototype
.
transform
=
function
DeprecateRenderModel_transform
(
ast
)
{
var
moduleName
=
this
.
options
.
moduleName
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
each
(
node
.
params
function
(
param
)
{
if
(
param
.
type
!
=
=
'
PathExpression
'
)
{
return
;
}
_emberMetalDebug
.
deprecate
(
deprecationMessage
(
moduleName
node
param
)
false
{
id
:
'
ember
-
template
-
compiler
.
deprecate
-
render
-
model
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_model
-
param
-
in
-
code
-
render
-
code
-
helper
'
}
)
;
}
)
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
MustacheStatement
'
&
&
node
.
path
.
original
=
=
=
'
render
'
&
&
node
.
params
.
length
>
1
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
function
deprecationMessage
(
moduleName
node
param
)
{
var
sourceInformation
=
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
node
.
loc
)
;
var
componentName
=
node
.
params
[
0
]
.
original
;
var
modelName
=
param
.
original
;
var
original
=
'
{
{
render
"
'
+
componentName
+
'
"
'
+
modelName
+
'
}
}
'
;
var
preferred
=
'
{
{
'
+
componentName
+
'
model
=
'
+
modelName
+
'
}
}
'
;
return
'
Please
refactor
'
+
original
+
'
to
a
component
and
invoke
via
'
+
(
'
'
+
preferred
+
'
.
'
+
sourceInformation
)
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
prevent
-
render
-
block
'
[
'
exports
'
'
ember
-
metal
/
error
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalError
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
PreventRenderBlock
;
function
PreventRenderBlock
(
options
)
{
this
.
syntax
=
null
;
this
.
options
=
options
;
}
PreventRenderBlock
.
prototype
.
transform
=
function
PreventRenderBlock_transform
(
ast
)
{
var
moduleName
=
this
.
options
.
moduleName
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
throw
new
_emberMetalError
.
default
(
assertionMessage
(
moduleName
node
)
)
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
BlockStatement
'
&
&
node
.
path
.
original
=
=
=
'
render
'
;
}
function
assertionMessage
(
moduleName
node
)
{
var
sourceInformation
=
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
node
.
loc
)
;
return
'
Usage
of
render
in
block
form
is
unsupported
'
+
sourceInformation
+
'
.
'
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
angle
-
bracket
-
components
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
TransformAngleBracketComponents
(
)
{
this
.
syntax
=
null
;
}
TransformAngleBracketComponents
.
prototype
.
transform
=
function
TransformAngleBracketComponents_transform
(
ast
)
{
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
node
.
tag
=
'
<
'
+
node
.
tag
+
'
>
'
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
ComponentNode
'
;
}
exports
.
default
=
TransformAngleBracketComponents
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
closure
-
component
-
attrs
-
into
-
mut
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
TransformClosureComponentAttrsIntoMut
(
)
{
this
.
syntax
=
null
;
}
TransformClosureComponentAttrsIntoMut
.
prototype
.
transform
=
function
TransformClosureComponentAttrsIntoMut_transform
(
ast
)
{
var
b
=
this
.
syntax
.
builders
;
this
.
syntax
.
traverse
(
ast
{
SubExpression
:
function
(
node
)
{
if
(
isComponentClosure
(
node
)
)
{
mutParameters
(
b
node
)
;
}
}
}
)
;
return
ast
;
}
;
function
isComponentClosure
(
node
)
{
return
node
.
type
=
=
=
'
SubExpression
'
&
&
node
.
path
.
original
=
=
=
'
component
'
;
}
function
mutParameters
(
builder
node
)
{
for
(
var
i
=
1
;
i
<
node
.
params
.
length
;
i
+
+
)
{
if
(
node
.
params
[
i
]
.
type
=
=
=
'
PathExpression
'
)
{
node
.
params
[
i
]
=
builder
.
sexpr
(
builder
.
path
(
'
mut
'
)
[
node
.
params
[
i
]
]
)
;
}
}
each
(
node
.
hash
.
pairs
function
(
pair
)
{
var
value
=
pair
.
value
;
if
(
value
.
type
=
=
=
'
PathExpression
'
)
{
pair
.
value
=
builder
.
sexpr
(
builder
.
path
(
'
mut
'
)
[
pair
.
value
]
)
;
}
}
)
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
exports
.
default
=
TransformClosureComponentAttrsIntoMut
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
component
-
attrs
-
into
-
mut
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
TransformComponentAttrsIntoMut
(
)
{
this
.
syntax
=
null
;
}
TransformComponentAttrsIntoMut
.
prototype
.
transform
=
function
TransformComponentAttrsIntoMut_transform
(
ast
)
{
var
b
=
this
.
syntax
.
builders
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
each
(
node
.
hash
.
pairs
function
(
pair
)
{
var
value
=
pair
.
value
;
if
(
value
.
type
=
=
=
'
PathExpression
'
)
{
pair
.
value
=
b
.
sexpr
(
b
.
path
(
'
mut
'
)
[
pair
.
value
]
)
;
}
}
)
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
BlockStatement
'
|
|
node
.
type
=
=
=
'
MustacheStatement
'
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
exports
.
default
=
TransformComponentAttrsIntoMut
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
component
-
curly
-
to
-
readonly
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
TransformComponentCurlyToReadonly
(
)
{
this
.
syntax
=
null
;
}
TransformComponentCurlyToReadonly
.
prototype
.
transform
=
function
TransformComponetnCurlyToReadonly_transform
(
ast
)
{
var
b
=
this
.
syntax
.
builders
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
each
(
node
.
attributes
function
(
attr
)
{
if
(
attr
.
value
.
type
!
=
=
'
MustacheStatement
'
)
{
return
;
}
if
(
attr
.
value
.
params
.
length
|
|
attr
.
value
.
hash
.
pairs
.
length
)
{
return
;
}
attr
.
value
=
b
.
mustache
(
b
.
path
(
'
readonly
'
)
[
attr
.
value
.
path
]
null
!
attr
.
value
.
escape
)
;
}
)
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
ComponentNode
'
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
exports
.
default
=
TransformComponentCurlyToReadonly
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
inline
-
link
-
to
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
TransformInlineLinkTo
;
function
TransformInlineLinkTo
(
options
)
{
this
.
options
=
options
;
this
.
syntax
=
null
;
}
TransformInlineLinkTo
.
prototype
.
transform
=
function
TransformInlineLinkTo_transform
(
ast
)
{
var
_syntax
=
this
.
syntax
;
var
traverse
=
_syntax
.
traverse
;
var
b
=
_syntax
.
builders
;
function
buildProgram
(
content
loc
)
{
return
b
.
program
(
[
buildStatement
(
content
loc
)
]
null
loc
)
;
}
function
buildStatement
(
content
loc
)
{
switch
(
content
.
type
)
{
case
'
PathExpression
'
:
return
b
.
mustache
(
content
null
null
null
loc
)
;
case
'
SubExpression
'
:
return
b
.
mustache
(
content
.
path
content
.
params
content
.
hash
null
loc
)
;
default
:
return
b
.
text
(
'
'
+
content
.
value
loc
)
;
}
}
function
unsafeHtml
(
expr
)
{
return
b
.
sexpr
(
'
-
html
-
safe
'
[
expr
]
)
;
}
traverse
(
ast
{
MustacheStatement
:
function
(
node
)
{
if
(
node
.
path
.
original
=
=
=
'
link
-
to
'
)
{
var
content
=
node
.
escaped
?
node
.
params
[
0
]
:
unsafeHtml
(
node
.
params
[
0
]
)
;
return
b
.
block
(
'
link
-
to
'
node
.
params
.
slice
(
1
)
node
.
hash
buildProgram
(
content
node
.
loc
)
null
node
.
loc
)
;
}
}
}
)
;
return
ast
;
}
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
input
-
on
-
to
-
onEvent
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalDebug
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
function
TransformInputOnToOnEvent
(
)
{
var
options
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
this
.
syntax
=
null
;
this
.
options
=
options
;
}
TransformInputOnToOnEvent
.
prototype
.
transform
=
function
TransformInputOnToOnEvent_transform
(
ast
)
{
var
pluginContext
=
this
;
var
b
=
pluginContext
.
syntax
.
builders
;
var
walker
=
new
pluginContext
.
syntax
.
Walker
(
)
;
var
moduleName
=
pluginContext
.
options
.
moduleName
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
pluginContext
.
validate
(
node
)
)
{
var
action
=
hashPairForKey
(
node
.
hash
'
action
'
)
;
var
on
=
hashPairForKey
(
node
.
hash
'
on
'
)
;
var
onEvent
=
hashPairForKey
(
node
.
hash
'
onEvent
'
)
;
var
normalizedOn
=
on
|
|
onEvent
;
var
moduleInfo
=
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
node
.
loc
)
;
if
(
normalizedOn
&
&
normalizedOn
.
value
.
type
!
=
=
'
StringLiteral
'
)
{
_emberMetalDebug
.
deprecate
(
'
Using
a
dynamic
value
for
\
'
#
{
normalizedOn
.
key
}
=
\
'
with
the
\
'
{
{
input
}
}
\
'
helper
'
+
moduleInfo
+
'
is
deprecated
.
'
false
{
id
:
'
ember
-
template
-
compiler
.
transform
-
input
-
on
-
to
-
onEvent
.
dynamic
-
value
'
until
:
'
3
.
0
.
0
'
}
)
;
normalizedOn
.
key
=
'
onEvent
'
;
return
;
}
removeFromHash
(
node
.
hash
normalizedOn
)
;
removeFromHash
(
node
.
hash
action
)
;
if
(
!
action
)
{
_emberMetalDebug
.
deprecate
(
'
Using
\
'
{
{
input
'
+
normalizedOn
.
key
+
'
=
"
'
+
normalizedOn
.
value
.
value
+
'
"
.
.
.
}
}
\
'
without
specifying
an
action
'
+
moduleInfo
+
'
will
do
nothing
.
'
false
{
id
:
'
ember
-
template
-
compiler
.
transform
-
input
-
on
-
to
-
onEvent
.
no
-
action
'
until
:
'
3
.
0
.
0
'
}
)
;
return
;
}
var
specifiedOn
=
normalizedOn
?
normalizedOn
.
key
+
'
=
"
'
+
normalizedOn
.
value
.
value
+
'
"
'
:
'
'
;
if
(
normalizedOn
&
&
normalizedOn
.
value
.
value
=
=
=
'
keyPress
'
)
{
normalizedOn
.
value
.
value
=
'
key
-
press
'
;
}
var
expected
=
(
normalizedOn
?
normalizedOn
.
value
.
value
:
'
enter
'
)
+
'
=
"
'
+
action
.
value
.
original
+
'
"
'
;
_emberMetalDebug
.
deprecate
(
'
Using
\
'
{
{
input
'
+
specifiedOn
+
'
action
=
"
'
+
action
.
value
.
original
+
'
"
}
}
\
'
'
+
moduleInfo
+
'
is
deprecated
.
Please
use
\
'
{
{
input
'
+
expected
+
'
}
}
\
'
instead
.
'
false
{
id
:
'
ember
-
template
-
compiler
.
transform
-
input
-
on
-
to
-
onEvent
.
normalized
-
on
'
until
:
'
3
.
0
.
0
'
}
)
;
if
(
!
normalizedOn
)
{
normalizedOn
=
b
.
pair
(
'
onEvent
'
b
.
string
(
'
enter
'
)
)
;
}
node
.
hash
.
pairs
.
push
(
b
.
pair
(
normalizedOn
.
value
.
value
action
.
value
)
)
;
}
}
)
;
return
ast
;
}
;
TransformInputOnToOnEvent
.
prototype
.
validate
=
function
TransformWithAsToHash_validate
(
node
)
{
return
node
.
type
=
=
=
'
MustacheStatement
'
&
&
node
.
path
.
original
=
=
=
'
input
'
&
&
(
hashPairForKey
(
node
.
hash
'
action
'
)
|
|
hashPairForKey
(
node
.
hash
'
on
'
)
|
|
hashPairForKey
(
node
.
hash
'
onEvent
'
)
)
;
}
;
function
hashPairForKey
(
hash
key
)
{
for
(
var
i
=
0
l
=
hash
.
pairs
.
length
;
i
<
l
;
i
+
+
)
{
var
pair
=
hash
.
pairs
[
i
]
;
if
(
pair
.
key
=
=
=
key
)
{
return
pair
;
}
}
return
false
;
}
function
removeFromHash
(
hash
pairToRemove
)
{
var
newPairs
=
[
]
;
for
(
var
i
=
0
l
=
hash
.
pairs
.
length
;
i
<
l
;
i
+
+
)
{
var
pair
=
hash
.
pairs
[
i
]
;
if
(
pair
!
=
=
pairToRemove
)
{
newPairs
.
push
(
pair
)
;
}
}
hash
.
pairs
=
newPairs
;
}
exports
.
default
=
TransformInputOnToOnEvent
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
item
-
class
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
TransformItemClass
;
function
TransformItemClass
(
)
{
this
.
syntax
=
null
;
}
TransformItemClass
.
prototype
.
transform
=
function
TransformItemClass_transform
(
ast
)
{
var
b
=
this
.
syntax
.
builders
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
each
(
node
.
hash
.
pairs
function
(
pair
)
{
var
key
=
pair
.
key
;
var
value
=
pair
.
value
;
if
(
key
!
=
=
'
itemClass
'
)
{
return
;
}
if
(
value
.
type
=
=
=
'
StringLiteral
'
)
{
return
;
}
var
propName
=
value
.
original
;
var
params
=
[
value
]
;
var
sexprParams
=
[
b
.
string
(
propName
)
b
.
path
(
propName
)
]
;
params
.
push
(
b
.
sexpr
(
b
.
string
(
'
-
normalize
-
class
'
)
sexprParams
)
)
;
var
sexpr
=
b
.
sexpr
(
b
.
string
(
'
if
'
)
params
)
;
pair
.
value
=
sexpr
;
}
)
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
(
node
.
type
=
=
=
'
BlockStatement
'
|
|
node
.
type
=
=
=
'
MustacheStatement
'
)
&
&
node
.
path
.
original
=
=
=
'
collection
'
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
binding
-
syntax
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
]
function
(
exports
_emberMetalDebug
_emberTemplateCompilerSystemCalculateLocationDisplay
)
{
'
use
strict
'
;
exports
.
default
=
TransformOldBindingSyntax
;
function
TransformOldBindingSyntax
(
options
)
{
this
.
syntax
=
null
;
this
.
options
=
options
;
}
TransformOldBindingSyntax
.
prototype
.
transform
=
function
TransformOldBindingSyntax_transform
(
ast
)
{
var
moduleName
=
this
.
options
.
moduleName
;
var
b
=
this
.
syntax
.
builders
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
each
(
node
.
hash
.
pairs
function
(
pair
)
{
var
key
=
pair
.
key
;
var
value
=
pair
.
value
;
var
sourceInformation
=
_emberTemplateCompilerSystemCalculateLocationDisplay
.
default
(
moduleName
pair
.
loc
)
;
if
(
key
=
=
=
'
classBinding
'
)
{
return
;
}
_emberMetalDebug
.
assert
(
'
Setting
\
'
attributeBindings
\
'
via
template
helpers
is
not
allowed
'
+
sourceInformation
key
!
=
=
'
attributeBindings
'
)
;
if
(
key
.
substr
(
-
7
)
=
=
=
'
Binding
'
)
{
var
newKey
=
key
.
slice
(
0
-
7
)
;
_emberMetalDebug
.
deprecate
(
'
You
\
'
re
using
legacy
binding
syntax
:
'
+
key
+
'
=
'
+
exprToString
(
value
)
+
'
'
+
sourceInformation
+
'
.
Please
replace
with
'
+
newKey
+
'
=
'
+
value
.
original
false
{
id
:
'
ember
-
template
-
compiler
.
transform
-
old
-
binding
-
syntax
'
until
:
'
3
.
0
.
0
'
}
)
;
pair
.
key
=
newKey
;
if
(
value
.
type
=
=
=
'
StringLiteral
'
)
{
pair
.
value
=
b
.
path
(
value
.
original
)
;
}
}
}
)
;
}
)
;
return
ast
;
}
;
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
BlockStatement
'
|
|
node
.
type
=
=
=
'
MustacheStatement
'
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
)
;
}
}
function
exprToString
(
expr
)
{
switch
(
expr
.
type
)
{
case
'
StringLiteral
'
:
return
'
"
'
+
expr
.
original
+
'
"
'
;
case
'
PathExpression
'
:
return
expr
.
original
;
}
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
old
-
class
-
binding
-
syntax
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
TransformOldClassBindingSyntax
;
function
TransformOldClassBindingSyntax
(
options
)
{
this
.
syntax
=
null
;
this
.
options
=
options
;
}
TransformOldClassBindingSyntax
.
prototype
.
transform
=
function
TransformOldClassBindingSyntax_transform
(
ast
)
{
var
b
=
this
.
syntax
.
builders
;
var
walker
=
new
this
.
syntax
.
Walker
(
)
;
walker
.
visit
(
ast
function
(
node
)
{
if
(
!
validate
(
node
)
)
{
return
;
}
var
allOfTheMicrosyntaxes
=
[
]
;
var
allOfTheMicrosyntaxIndexes
=
[
]
;
var
classPair
=
undefined
;
each
(
node
.
hash
.
pairs
function
(
pair
index
)
{
var
key
=
pair
.
key
;
if
(
key
=
=
=
'
classBinding
'
|
|
key
=
=
=
'
classNameBindings
'
)
{
allOfTheMicrosyntaxIndexes
.
push
(
index
)
;
allOfTheMicrosyntaxes
.
push
(
pair
)
;
}
else
if
(
key
=
=
=
'
class
'
)
{
classPair
=
pair
;
}
}
)
;
if
(
allOfTheMicrosyntaxes
.
length
=
=
=
0
)
{
return
;
}
var
classValue
=
[
]
;
if
(
classPair
)
{
classValue
.
push
(
classPair
.
value
)
;
classValue
.
push
(
b
.
string
(
'
'
)
)
;
}
else
{
classPair
=
b
.
pair
(
'
class
'
null
)
;
node
.
hash
.
pairs
.
push
(
classPair
)
;
}
each
(
allOfTheMicrosyntaxIndexes
function
(
index
)
{
node
.
hash
.
pairs
.
splice
(
index
1
)
;
}
)
;
each
(
allOfTheMicrosyntaxes
function
(
_ref
)
{
var
value
=
_ref
.
value
;
var
loc
=
_ref
.
loc
;
var
sexprs
=
[
]
;
if
(
value
.
type
=
=
=
'
StringLiteral
'
)
{
var
microsyntax
=
parseMicrosyntax
(
value
.
original
)
;
buildSexprs
(
microsyntax
sexprs
b
)
;
classValue
.
push
.
apply
(
classValue
sexprs
)
;
}
}
)
;
var
hash
=
b
.
hash
(
)
;
classPair
.
value
=
b
.
sexpr
(
b
.
string
(
'
concat
'
)
classValue
hash
)
;
}
)
;
return
ast
;
}
;
function
buildSexprs
(
microsyntax
sexprs
b
)
{
for
(
var
i
=
0
l
=
microsyntax
.
length
;
i
<
l
;
i
+
+
)
{
var
_microsyntax
i
=
microsyntax
[
i
]
;
var
propName
=
_microsyntax
i
[
0
]
;
var
activeClass
=
_microsyntax
i
[
1
]
;
var
inactiveClass
=
_microsyntax
i
[
2
]
;
var
sexpr
=
undefined
;
if
(
propName
=
=
=
'
'
)
{
sexpr
=
b
.
string
(
activeClass
)
;
}
else
{
var
params
=
[
b
.
path
(
propName
)
]
;
if
(
activeClass
)
{
params
.
push
(
b
.
string
(
activeClass
)
)
;
}
else
{
var
sexprParams
=
[
b
.
string
(
propName
)
b
.
path
(
propName
)
]
;
var
hash
=
b
.
hash
(
)
;
if
(
activeClass
!
=
=
undefined
)
{
hash
.
pairs
.
push
(
b
.
pair
(
'
activeClass
'
b
.
string
(
activeClass
)
)
)
;
}
if
(
inactiveClass
!
=
=
undefined
)
{
hash
.
pairs
.
push
(
b
.
pair
(
'
inactiveClass
'
b
.
string
(
inactiveClass
)
)
)
;
}
params
.
push
(
b
.
sexpr
(
b
.
string
(
'
-
normalize
-
class
'
)
sexprParams
hash
)
)
;
}
if
(
inactiveClass
)
{
params
.
push
(
b
.
string
(
inactiveClass
)
)
;
}
sexpr
=
b
.
sexpr
(
b
.
string
(
'
if
'
)
params
)
;
}
sexprs
.
push
(
sexpr
)
;
sexprs
.
push
(
b
.
string
(
'
'
)
)
;
}
}
function
validate
(
node
)
{
return
node
.
type
=
=
=
'
BlockStatement
'
|
|
node
.
type
=
=
=
'
MustacheStatement
'
;
}
function
each
(
list
callback
)
{
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
list
[
i
]
i
)
;
}
}
function
parseMicrosyntax
(
string
)
{
var
segments
=
string
.
split
(
'
'
)
;
for
(
var
i
=
0
l
=
segments
.
length
;
i
<
l
;
i
+
+
)
{
segments
[
i
]
=
segments
[
i
]
.
split
(
'
:
'
)
;
}
return
segments
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
plugins
/
transform
-
top
-
level
-
components
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
TransformTopLevelComponents
(
)
{
this
.
syntax
=
null
;
}
TransformTopLevelComponents
.
prototype
.
transform
=
function
TransformTopLevelComponents_transform
(
ast
)
{
var
b
=
this
.
syntax
.
builders
;
hasSingleComponentNode
(
ast
function
(
component
)
{
if
(
component
.
type
=
=
=
'
ComponentNode
'
)
{
component
.
tag
=
'
'
+
component
.
tag
;
component
.
isStatic
=
true
;
}
}
function
(
element
)
{
var
hasTripleCurlies
=
element
.
attributes
.
some
(
function
(
attr
)
{
return
attr
.
value
.
escaped
=
=
=
false
;
}
)
;
if
(
element
.
modifiers
.
length
|
|
hasTripleCurlies
)
{
return
element
;
}
else
{
var
program
=
b
.
program
(
element
.
children
)
;
var
component
=
b
.
component
(
'
<
'
+
element
.
tag
+
'
>
'
element
.
attributes
program
element
.
loc
)
;
component
.
isStatic
=
true
;
return
component
;
}
}
)
;
return
ast
;
}
;
function
hasSingleComponentNode
(
program
componentCallback
elementCallback
)
{
var
loc
=
program
.
loc
;
var
body
=
program
.
body
;
if
(
!
loc
|
|
loc
.
start
.
line
!
=
=
1
|
|
loc
.
start
.
column
!
=
=
0
)
{
return
;
}
var
lastComponentNode
=
undefined
;
var
lastIndex
=
undefined
;
var
nodeCount
=
0
;
for
(
var
i
=
0
l
=
body
.
length
;
i
<
l
;
i
+
+
)
{
var
curr
=
body
[
i
]
;
if
(
curr
.
type
=
=
=
'
TextNode
'
&
&
/
^
[
\
s
]
*
/
.
test
(
curr
.
chars
)
)
{
continue
;
}
if
(
nodeCount
+
+
>
0
)
{
return
false
;
}
if
(
curr
.
type
=
=
=
'
ComponentNode
'
|
|
curr
.
type
=
=
=
'
ElementNode
'
)
{
lastComponentNode
=
curr
;
lastIndex
=
i
;
}
}
if
(
!
lastComponentNode
)
{
return
;
}
if
(
lastComponentNode
.
type
=
=
=
'
ComponentNode
'
)
{
componentCallback
(
lastComponentNode
)
;
}
}
exports
.
default
=
TransformTopLevelComponents
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
calculate
-
location
-
display
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
calculateLocationDisplay
;
function
calculateLocationDisplay
(
moduleName
_loc
)
{
var
loc
=
_loc
|
|
{
}
;
var
_ref
=
loc
.
start
|
|
{
}
;
var
column
=
_ref
.
column
;
var
line
=
_ref
.
line
;
var
moduleInfo
=
'
'
;
if
(
moduleName
)
{
moduleInfo
+
=
'
\
'
'
+
moduleName
+
'
\
'
'
;
}
if
(
line
!
=
=
undefined
&
&
column
!
=
=
undefined
)
{
if
(
moduleName
)
{
moduleInfo
+
=
'
'
;
}
moduleInfo
+
=
'
L
'
+
line
+
'
:
C
'
+
column
;
}
if
(
moduleInfo
)
{
moduleInfo
=
'
(
'
+
moduleInfo
+
'
)
'
;
}
return
moduleInfo
;
}
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
compile
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
require
'
'
ember
-
template
-
compiler
/
system
/
compile_options
'
'
ember
-
template
-
compiler
/
system
/
template
'
]
function
(
exports
_emberMetalFeatures
_require
_emberTemplateCompilerSystemCompile_options
_emberTemplateCompilerSystemTemplate
)
{
'
use
strict
'
;
var
compile
;
exports
.
default
=
function
(
templateString
options
)
{
if
(
!
compile
&
&
_require
.
has
(
'
htmlbars
-
compiler
/
compiler
'
)
)
{
compile
=
_require
.
default
(
'
htmlbars
-
compiler
/
compiler
'
)
.
compile
;
}
if
(
!
compile
)
{
throw
new
Error
(
'
Cannot
call
compile
without
the
template
compiler
loaded
.
Please
load
ember
-
template
-
compiler
.
js
prior
to
calling
compile
.
'
)
;
}
var
templateSpec
=
compile
(
templateString
_emberTemplateCompilerSystemCompile_options
.
default
(
options
)
)
;
return
_emberTemplateCompilerSystemTemplate
.
default
(
templateSpec
)
;
}
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
compile_options
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
template
-
compiler
/
plugins
'
]
function
(
exports
_emberMetalAssign
_emberTemplateCompilerPlugins
)
{
'
use
strict
'
;
var
compileOptions
=
undefined
;
var
fragmentReason
=
undefined
;
compileOptions
=
function
(
_options
)
{
var
disableComponentGeneration
=
true
;
var
options
=
undefined
;
if
(
_options
=
=
=
true
)
{
options
=
{
}
;
}
else
{
options
=
_emberMetalAssign
.
default
(
{
}
_options
)
;
}
options
.
disableComponentGeneration
=
disableComponentGeneration
;
var
plugins
=
{
ast
:
_emberTemplateCompilerPlugins
.
default
.
ast
.
slice
(
)
}
;
if
(
options
.
plugins
&
&
options
.
plugins
.
ast
)
{
plugins
.
ast
=
plugins
.
ast
.
concat
(
options
.
plugins
.
ast
)
;
}
options
.
plugins
=
plugins
;
options
.
buildMeta
=
function
buildMeta
(
program
)
{
return
{
fragmentReason
:
fragmentReason
(
program
)
revision
:
'
Ember
2
.
6
.
2
'
loc
:
program
.
loc
moduleName
:
options
.
moduleName
}
;
}
;
return
options
;
}
;
fragmentReason
=
function
(
program
)
{
var
loc
=
program
.
loc
;
var
body
=
program
.
body
;
if
(
!
loc
|
|
loc
.
start
.
line
!
=
=
1
|
|
loc
.
start
.
column
!
=
=
0
)
{
return
false
;
}
var
candidate
=
undefined
;
var
nodeCount
=
0
;
var
problems
=
{
}
;
for
(
var
i
=
0
l
=
body
.
length
;
i
<
l
;
i
+
+
)
{
var
curr
=
body
[
i
]
;
if
(
curr
.
type
=
=
=
'
TextNode
'
&
&
/
^
[
\
s
]
*
/
.
test
(
curr
.
chars
)
)
{
continue
;
}
if
(
nodeCount
+
+
>
0
)
{
problems
[
'
multiple
-
nodes
'
]
=
true
;
}
if
(
curr
.
type
=
=
=
'
ComponentNode
'
|
|
curr
.
type
=
=
=
'
ElementNode
'
)
{
candidate
=
curr
;
}
else
{
problems
[
'
wrong
-
type
'
]
=
true
;
}
}
if
(
nodeCount
=
=
=
0
)
{
return
{
name
:
'
missing
-
wrapper
'
problems
:
[
'
empty
-
body
'
]
}
;
}
var
problemList
=
Object
.
keys
(
problems
)
;
if
(
problemList
.
length
)
{
return
{
name
:
'
missing
-
wrapper
'
problems
:
problemList
}
;
}
if
(
candidate
.
type
=
=
=
'
ComponentNode
'
)
{
return
false
;
}
else
if
(
candidate
.
modifiers
.
length
)
{
return
{
name
:
'
modifiers
'
modifiers
:
candidate
.
modifiers
.
map
(
function
(
m
)
{
return
m
.
path
.
original
;
}
)
}
;
}
else
if
(
candidate
.
attributes
.
some
(
function
(
attr
)
{
return
!
attr
.
value
.
escaped
;
}
)
)
{
return
{
name
:
'
triple
-
curlies
'
}
;
}
else
{
return
false
;
}
}
;
exports
.
default
=
compileOptions
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
precompile
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
require
'
'
ember
-
template
-
compiler
/
system
/
compile_options
'
]
function
(
exports
_emberMetalFeatures
_require
_emberTemplateCompilerSystemCompile_options
)
{
'
use
strict
'
;
var
compileSpec
;
exports
.
default
=
function
(
templateString
options
)
{
if
(
!
compileSpec
&
&
_require
.
has
(
'
htmlbars
-
compiler
/
compiler
'
)
)
{
compileSpec
=
_require
.
default
(
'
htmlbars
-
compiler
/
compiler
'
)
.
compileSpec
;
}
if
(
!
compileSpec
)
{
throw
new
Error
(
'
Cannot
call
compileSpec
without
the
template
compiler
loaded
.
Please
load
ember
-
template
-
compiler
.
js
prior
to
calling
compileSpec
.
'
)
;
}
return
compileSpec
(
templateString
_emberTemplateCompilerSystemCompile_options
.
default
(
options
)
)
;
}
;
}
)
;
enifed
(
'
ember
-
template
-
compiler
/
system
/
template
'
[
'
exports
'
'
ember
-
metal
/
features
'
'
require
'
]
function
(
exports
_emberMetalFeatures
_require2
)
{
'
use
strict
'
;
var
template
=
undefined
;
var
_require
=
_require2
.
default
(
'
htmlbars
-
runtime
/
hooks
'
)
;
var
wrap
=
_require
.
wrap
;
template
=
function
(
templateSpec
)
{
if
(
!
templateSpec
.
render
)
{
templateSpec
=
wrap
(
templateSpec
)
;
}
templateSpec
.
isTop
=
true
;
templateSpec
.
isMethod
=
false
;
return
templateSpec
;
}
;
exports
.
default
=
template
;
}
)
;
enifed
(
'
ember
-
testing
/
adapters
/
adapter
'
[
'
exports
'
'
ember
-
runtime
/
system
/
object
'
]
function
(
exports
_emberRuntimeSystemObject
)
{
'
use
strict
'
;
function
K
(
)
{
return
this
;
}
var
Adapter
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
asyncStart
:
K
asyncEnd
:
K
exception
:
function
(
error
)
{
throw
error
;
}
}
)
;
exports
.
default
=
Adapter
;
}
)
;
enifed
(
'
ember
-
testing
/
adapters
/
qunit
'
[
'
exports
'
'
ember
-
testing
/
adapters
/
adapter
'
'
ember
-
metal
/
utils
'
]
function
(
exports
_emberTestingAdaptersAdapter
_emberMetalUtils
)
{
'
use
strict
'
;
exports
.
default
=
_emberTestingAdaptersAdapter
.
default
.
extend
(
{
asyncStart
:
function
(
)
{
QUnit
.
stop
(
)
;
}
asyncEnd
:
function
(
)
{
QUnit
.
start
(
)
;
}
exception
:
function
(
error
)
{
ok
(
false
_emberMetalUtils
.
inspect
(
error
)
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
helpers
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
run_loop
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
testing
/
test
'
'
ember
-
runtime
/
ext
/
rsvp
'
'
ember
-
metal
/
features
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalError
_emberMetalRun_loop
_emberViewsSystemJquery
_emberTestingTest
_emberRuntimeExtRsvp
_emberMetalFeatures
)
{
'
use
strict
'
;
var
helper
=
_emberTestingTest
.
default
.
registerHelper
;
var
asyncHelper
=
_emberTestingTest
.
default
.
registerAsyncHelper
;
var
keyboardEventTypes
mouseEventTypes
buildKeyboardEvent
buildMouseEvent
buildBasicEvent
fireEvent
focus
;
var
defaultEventOptions
=
{
canBubble
:
true
cancelable
:
true
}
;
keyboardEventTypes
=
[
'
keydown
'
'
keypress
'
'
keyup
'
]
;
mouseEventTypes
=
[
'
click
'
'
mousedown
'
'
mouseup
'
'
dblclick
'
'
mouseenter
'
'
mouseleave
'
'
mousemove
'
'
mouseout
'
'
mouseover
'
]
;
buildKeyboardEvent
=
function
buildKeyboardEvent
(
type
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
event
=
undefined
;
try
{
event
=
document
.
createEvent
(
'
KeyEvents
'
)
;
var
eventOpts
=
_emberViewsSystemJquery
.
default
.
extend
(
{
}
defaultEventOptions
options
)
;
event
.
initKeyEvent
(
type
eventOpts
.
canBubble
eventOpts
.
cancelable
window
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
keyCode
eventOpts
.
charCode
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
;
buildMouseEvent
=
function
buildMouseEvent
(
type
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
event
=
undefined
;
try
{
event
=
document
.
createEvent
(
'
MouseEvents
'
)
;
var
eventOpts
=
_emberViewsSystemJquery
.
default
.
extend
(
{
}
defaultEventOptions
options
)
;
event
.
initMouseEvent
(
type
eventOpts
.
canBubble
eventOpts
.
cancelable
window
eventOpts
.
detail
eventOpts
.
screenX
eventOpts
.
screenY
eventOpts
.
clientX
eventOpts
.
clientY
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
button
eventOpts
.
relatedTarget
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
;
buildBasicEvent
=
function
buildBasicEvent
(
type
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
event
=
document
.
createEvent
(
'
Events
'
)
;
event
.
initEvent
(
type
true
true
)
;
_emberViewsSystemJquery
.
default
.
extend
(
event
options
)
;
return
event
;
}
;
fireEvent
=
function
fireEvent
(
element
type
)
{
var
options
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
{
}
:
arguments
[
2
]
;
if
(
!
element
)
{
return
;
}
var
event
=
undefined
;
if
(
keyboardEventTypes
.
indexOf
(
type
)
>
-
1
)
{
event
=
buildKeyboardEvent
(
type
options
)
;
}
else
if
(
mouseEventTypes
.
indexOf
(
type
)
>
-
1
)
{
var
rect
=
element
.
getBoundingClientRect
(
)
;
var
x
=
rect
.
left
+
1
;
var
y
=
rect
.
top
+
1
;
var
simulatedCoordinates
=
{
screenX
:
x
+
5
screenY
:
y
+
95
clientX
:
x
clientY
:
y
}
;
event
=
buildMouseEvent
(
type
_emberViewsSystemJquery
.
default
.
extend
(
simulatedCoordinates
options
)
)
;
}
else
{
event
=
buildBasicEvent
(
type
options
)
;
}
element
.
dispatchEvent
(
event
)
;
}
;
focus
=
function
focus
(
el
)
{
if
(
!
el
)
{
return
;
}
var
el
=
_emberViewsSystemJquery
.
default
(
el
)
;
if
(
el
.
is
(
'
:
input
[
contenteditable
=
true
]
'
)
)
{
var
type
=
el
.
prop
(
'
type
'
)
;
if
(
type
!
=
=
'
checkbox
'
&
&
type
!
=
=
'
radio
'
&
&
type
!
=
=
'
hidden
'
)
{
_emberMetalRun_loop
.
default
(
null
function
(
)
{
if
(
!
document
.
hasFocus
|
|
document
.
hasFocus
(
)
)
{
el
.
focus
(
)
;
}
else
{
el
.
trigger
(
'
focusin
'
)
;
}
}
)
;
}
}
}
;
function
currentRouteName
(
app
)
{
var
routingService
=
app
.
__container__
.
lookup
(
'
service
:
-
routing
'
)
;
return
_emberMetalProperty_get
.
get
(
routingService
'
currentRouteName
'
)
;
}
function
currentPath
(
app
)
{
var
routingService
=
app
.
__container__
.
lookup
(
'
service
:
-
routing
'
)
;
return
_emberMetalProperty_get
.
get
(
routingService
'
currentPath
'
)
;
}
function
currentURL
(
app
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
return
_emberMetalProperty_get
.
get
(
router
'
location
'
)
.
getURL
(
)
;
}
function
pauseTest
(
)
{
_emberTestingTest
.
default
.
adapter
.
asyncStart
(
)
;
return
new
_emberRuntimeExtRsvp
.
default
.
Promise
(
function
(
)
{
}
'
TestAdapter
paused
promise
'
)
;
}
function
visit
(
app
url
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
var
shouldHandleURL
=
false
;
app
.
boot
(
)
.
then
(
function
(
)
{
router
.
location
.
setURL
(
url
)
;
if
(
shouldHandleURL
)
{
_emberMetalRun_loop
.
default
(
app
.
__deprecatedInstance__
'
handleURL
'
url
)
;
}
}
)
;
if
(
app
.
_readinessDeferrals
>
0
)
{
router
[
'
initialURL
'
]
=
url
;
_emberMetalRun_loop
.
default
(
app
'
advanceReadiness
'
)
;
delete
router
[
'
initialURL
'
]
;
}
else
{
shouldHandleURL
=
true
;
}
return
app
.
testHelpers
.
wait
(
)
;
}
function
click
(
app
selector
context
)
{
var
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
var
el
=
el
[
0
]
;
_emberMetalRun_loop
.
default
(
null
fireEvent
el
'
mousedown
'
)
;
focus
(
el
)
;
_emberMetalRun_loop
.
default
(
null
fireEvent
el
'
mouseup
'
)
;
_emberMetalRun_loop
.
default
(
null
fireEvent
el
'
click
'
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
function
triggerEvent
(
app
selector
contextOrType
typeOrOptions
possibleOptions
)
{
var
arity
=
arguments
.
length
;
var
context
type
options
;
if
(
arity
=
=
=
3
)
{
context
=
null
;
type
=
contextOrType
;
options
=
{
}
;
}
else
if
(
arity
=
=
=
4
)
{
if
(
typeof
typeOrOptions
=
=
=
'
object
'
)
{
context
=
null
;
type
=
contextOrType
;
options
=
typeOrOptions
;
}
else
{
context
=
contextOrType
;
type
=
typeOrOptions
;
options
=
{
}
;
}
}
else
{
context
=
contextOrType
;
type
=
typeOrOptions
;
options
=
possibleOptions
;
}
var
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
var
el
=
el
[
0
]
;
_emberMetalRun_loop
.
default
(
null
fireEvent
el
type
options
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
function
keyEvent
(
app
selector
contextOrType
typeOrKeyCode
keyCode
)
{
var
context
type
;
if
(
typeof
keyCode
=
=
=
'
undefined
'
)
{
context
=
null
;
keyCode
=
typeOrKeyCode
;
type
=
contextOrType
;
}
else
{
context
=
contextOrType
;
type
=
typeOrKeyCode
;
}
return
app
.
testHelpers
.
triggerEvent
(
selector
context
type
{
keyCode
:
keyCode
which
:
keyCode
}
)
;
}
function
fillIn
(
app
selector
contextOrText
text
)
{
var
el
el
context
;
if
(
typeof
text
=
=
=
'
undefined
'
)
{
text
=
contextOrText
;
}
else
{
context
=
contextOrText
;
}
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
el
=
el
[
0
]
;
focus
(
el
)
;
_emberMetalRun_loop
.
default
(
function
(
)
{
el
.
val
(
text
)
;
fireEvent
(
el
'
input
'
)
;
fireEvent
(
el
'
change
'
)
;
}
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
function
findWithAssert
(
app
selector
context
)
{
var
el
=
app
.
testHelpers
.
find
(
selector
context
)
;
if
(
el
.
length
=
=
=
0
)
{
throw
new
_emberMetalError
.
default
(
'
Element
'
+
selector
+
'
not
found
.
'
)
;
}
return
el
;
}
function
find
(
app
selector
context
)
{
var
el
;
context
=
context
|
|
_emberMetalProperty_get
.
get
(
app
'
rootElement
'
)
;
el
=
app
.
(
selector
context
)
;
return
el
;
}
function
andThen
(
app
callback
)
{
return
app
.
testHelpers
.
wait
(
callback
(
app
)
)
;
}
function
wait
(
app
value
)
{
return
new
_emberRuntimeExtRsvp
.
default
.
Promise
(
function
(
resolve
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
var
watcher
=
setInterval
(
function
(
)
{
var
routerIsLoading
=
router
.
router
&
&
!
!
router
.
router
.
activeTransition
;
if
(
routerIsLoading
)
{
return
;
}
if
(
_emberTestingTest
.
default
.
pendingAjaxRequests
)
{
return
;
}
if
(
_emberMetalRun_loop
.
default
.
hasScheduledTimers
(
)
|
|
_emberMetalRun_loop
.
default
.
currentRunLoop
)
{
return
;
}
if
(
_emberTestingTest
.
default
.
waiters
&
&
_emberTestingTest
.
default
.
waiters
.
any
(
function
(
waiter
)
{
var
context
=
waiter
[
0
]
;
var
callback
=
waiter
[
1
]
;
return
!
callback
.
call
(
context
)
;
}
)
)
{
return
;
}
clearInterval
(
watcher
)
;
_emberMetalRun_loop
.
default
(
null
resolve
value
)
;
}
10
)
;
}
)
;
}
asyncHelper
(
'
visit
'
visit
)
;
asyncHelper
(
'
click
'
click
)
;
asyncHelper
(
'
keyEvent
'
keyEvent
)
;
asyncHelper
(
'
fillIn
'
fillIn
)
;
helper
(
'
find
'
find
)
;
helper
(
'
findWithAssert
'
findWithAssert
)
;
asyncHelper
(
'
wait
'
wait
)
;
asyncHelper
(
'
andThen
'
andThen
)
;
helper
(
'
currentRouteName
'
currentRouteName
)
;
helper
(
'
currentPath
'
currentPath
)
;
helper
(
'
currentURL
'
currentURL
)
;
helper
(
'
pauseTest
'
pauseTest
)
;
asyncHelper
(
'
triggerEvent
'
triggerEvent
)
;
}
)
;
enifed
(
'
ember
-
testing
/
index
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
testing
/
initializers
'
'
ember
-
testing
/
support
'
'
ember
-
testing
/
setup_for_testing
'
'
ember
-
testing
/
test
'
'
ember
-
testing
/
adapters
/
adapter
'
'
ember
-
testing
/
adapters
/
qunit
'
'
ember
-
testing
/
helpers
'
]
function
(
exports
_emberMetalCore
_emberTestingInitializers
_emberTestingSupport
_emberTestingSetup_for_testing
_emberTestingTest
_emberTestingAdaptersAdapter
_emberTestingAdaptersQunit
_emberTestingHelpers
)
{
'
use
strict
'
;
_emberMetalCore
.
default
.
Test
=
_emberTestingTest
.
default
;
_emberMetalCore
.
default
.
Test
.
Adapter
=
_emberTestingAdaptersAdapter
.
default
;
_emberMetalCore
.
default
.
Test
.
QUnitAdapter
=
_emberTestingAdaptersQunit
.
default
;
_emberMetalCore
.
default
.
setupForTesting
=
_emberTestingSetup_for_testing
.
default
;
}
)
;
enifed
(
'
ember
-
testing
/
initializers
'
[
'
exports
'
'
ember
-
runtime
/
system
/
lazy_load
'
]
function
(
exports
_emberRuntimeSystemLazy_load
)
{
'
use
strict
'
;
var
name
=
'
deferReadiness
in
testing
mode
'
;
_emberRuntimeSystemLazy_load
.
onLoad
(
'
Ember
.
Application
'
function
(
Application
)
{
if
(
!
Application
.
initializers
[
name
]
)
{
Application
.
initializer
(
{
name
:
name
initialize
:
function
(
application
)
{
if
(
application
.
testing
)
{
application
.
deferReadiness
(
)
;
}
}
}
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
setup_for_testing
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
testing
/
adapters
/
qunit
'
'
ember
-
views
/
system
/
jquery
'
]
function
(
exports
_emberMetalCore
_emberTestingAdaptersQunit
_emberViewsSystemJquery
)
{
'
use
strict
'
;
exports
.
default
=
setupForTesting
;
var
Test
requests
;
function
incrementAjaxPendingRequests
(
_
xhr
)
{
requests
.
push
(
xhr
)
;
Test
.
pendingAjaxRequests
=
requests
.
length
;
}
function
decrementAjaxPendingRequests
(
_
xhr
)
{
for
(
var
i
=
0
;
i
<
requests
.
length
;
i
+
+
)
{
if
(
xhr
=
=
=
requests
[
i
]
)
{
requests
.
splice
(
i
1
)
;
}
}
Test
.
pendingAjaxRequests
=
requests
.
length
;
}
function
setupForTesting
(
)
{
if
(
!
Test
)
{
Test
=
requireModule
(
'
ember
-
testing
/
test
'
)
[
'
default
'
]
;
}
_emberMetalCore
.
default
.
testing
=
true
;
if
(
!
Test
.
adapter
)
{
Test
.
adapter
=
_emberTestingAdaptersQunit
.
default
.
create
(
)
;
}
requests
=
[
]
;
Test
.
pendingAjaxRequests
=
requests
.
length
;
_emberViewsSystemJquery
.
default
(
document
)
.
off
(
'
ajaxSend
'
incrementAjaxPendingRequests
)
;
_emberViewsSystemJquery
.
default
(
document
)
.
off
(
'
ajaxComplete
'
decrementAjaxPendingRequests
)
;
_emberViewsSystemJquery
.
default
(
document
)
.
on
(
'
ajaxSend
'
incrementAjaxPendingRequests
)
;
_emberViewsSystemJquery
.
default
(
document
)
.
on
(
'
ajaxComplete
'
decrementAjaxPendingRequests
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
support
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
metal
/
environment
'
]
function
(
exports
_emberMetalDebug
_emberViewsSystemJquery
_emberMetalEnvironment
)
{
'
use
strict
'
;
var
=
_emberViewsSystemJquery
.
default
;
function
testCheckboxClick
(
handler
)
{
(
'
<
input
type
=
"
checkbox
"
>
'
)
.
css
(
{
position
:
'
absolute
'
left
:
'
-
1000px
'
top
:
'
-
1000px
'
}
)
.
appendTo
(
'
body
'
)
.
on
(
'
click
'
handler
)
.
trigger
(
'
click
'
)
.
remove
(
)
;
}
if
(
_emberMetalEnvironment
.
default
.
hasDOM
)
{
(
function
(
)
{
testCheckboxClick
(
function
(
)
{
if
(
!
this
.
checked
&
&
!
.
event
.
special
.
click
)
{
.
event
.
special
.
click
=
{
trigger
:
function
(
)
{
if
(
.
nodeName
(
this
'
input
'
)
&
&
this
.
type
=
=
=
'
checkbox
'
&
&
this
.
click
)
{
this
.
click
(
)
;
return
false
;
}
}
}
;
}
}
)
;
testCheckboxClick
(
function
(
)
{
_emberMetalDebug
.
warn
(
'
clicked
checkboxes
should
be
checked
!
the
jQuery
patch
didn
\
'
t
work
'
this
.
checked
{
id
:
'
ember
-
testing
.
test
-
checkbox
-
click
'
}
)
;
}
)
;
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
test
'
[
'
exports
'
'
ember
-
metal
/
run_loop
'
'
ember
-
runtime
/
ext
/
rsvp
'
'
ember
-
testing
/
setup_for_testing
'
'
ember
-
application
/
system
/
application
'
'
ember
-
runtime
/
system
/
native_array
'
]
function
(
exports
_emberMetalRun_loop
_emberRuntimeExtRsvp
_emberTestingSetup_for_testing
_emberApplicationSystemApplication
_emberRuntimeSystemNative_array
)
{
'
use
strict
'
;
var
helpers
=
{
}
;
var
injectHelpersCallbacks
=
[
]
;
var
Test
=
{
_helpers
:
helpers
registerHelper
:
function
(
name
helperMethod
)
{
helpers
[
name
]
=
{
method
:
helperMethod
meta
:
{
wait
:
false
}
}
;
}
registerAsyncHelper
:
function
(
name
helperMethod
)
{
helpers
[
name
]
=
{
method
:
helperMethod
meta
:
{
wait
:
true
}
}
;
}
unregisterHelper
:
function
(
name
)
{
delete
helpers
[
name
]
;
delete
Test
.
Promise
.
prototype
[
name
]
;
}
onInjectHelpers
:
function
(
callback
)
{
injectHelpersCallbacks
.
push
(
callback
)
;
}
promise
:
function
(
resolver
label
)
{
var
fullLabel
=
'
Ember
.
Test
.
promise
:
'
+
(
label
|
|
'
<
Unknown
Promise
>
'
)
;
return
new
Test
.
Promise
(
resolver
fullLabel
)
;
}
adapter
:
null
resolve
:
function
(
val
)
{
return
Test
.
promise
(
function
(
resolve
)
{
return
resolve
(
val
)
;
}
)
;
}
registerWaiter
:
function
(
context
callback
)
{
if
(
arguments
.
length
=
=
=
1
)
{
callback
=
context
;
context
=
null
;
}
if
(
!
this
.
waiters
)
{
this
.
waiters
=
_emberRuntimeSystemNative_array
.
A
(
)
;
}
this
.
waiters
.
push
(
[
context
callback
]
)
;
}
unregisterWaiter
:
function
(
context
callback
)
{
if
(
!
this
.
waiters
)
{
return
;
}
if
(
arguments
.
length
=
=
=
1
)
{
callback
=
context
;
context
=
null
;
}
this
.
waiters
=
_emberRuntimeSystemNative_array
.
A
(
this
.
waiters
.
filter
(
function
(
elt
)
{
return
!
(
elt
[
0
]
=
=
=
context
&
&
elt
[
1
]
=
=
=
callback
)
;
}
)
)
;
}
}
;
function
helper
(
app
name
)
{
var
fn
=
helpers
[
name
]
.
method
;
var
meta
=
helpers
[
name
]
.
meta
;
return
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
var
lastPromise
;
args
.
unshift
(
app
)
;
if
(
!
meta
.
wait
)
{
return
fn
.
apply
(
app
args
)
;
}
lastPromise
=
run
(
function
(
)
{
return
Test
.
resolve
(
Test
.
lastPromise
)
;
}
)
;
Test
.
adapter
.
asyncStart
(
)
;
return
lastPromise
.
then
(
function
(
)
{
return
fn
.
apply
(
app
args
)
;
}
)
.
finally
(
function
(
)
{
Test
.
adapter
.
asyncEnd
(
)
;
}
)
;
}
;
}
function
run
(
fn
)
{
if
(
!
_emberMetalRun_loop
.
default
.
currentRunLoop
)
{
return
_emberMetalRun_loop
.
default
(
fn
)
;
}
else
{
return
fn
(
)
;
}
}
_emberApplicationSystemApplication
.
default
.
reopen
(
{
testHelpers
:
{
}
originalMethods
:
{
}
testing
:
false
setupForTesting
:
function
(
)
{
_emberTestingSetup_for_testing
.
default
(
)
;
this
.
testing
=
true
;
this
.
Router
.
reopen
(
{
location
:
'
none
'
}
)
;
}
helperContainer
:
null
injectTestHelpers
:
function
(
helperContainer
)
{
if
(
helperContainer
)
{
this
.
helperContainer
=
helperContainer
;
}
else
{
this
.
helperContainer
=
window
;
}
this
.
reopen
(
{
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
removeTestHelpers
(
)
;
}
}
)
;
this
.
testHelpers
=
{
}
;
for
(
var
name
in
helpers
)
{
this
.
originalMethods
[
name
]
=
this
.
helperContainer
[
name
]
;
this
.
testHelpers
[
name
]
=
this
.
helperContainer
[
name
]
=
helper
(
this
name
)
;
protoWrap
(
Test
.
Promise
.
prototype
name
helper
(
this
name
)
helpers
[
name
]
.
meta
.
wait
)
;
}
for
(
var
i
=
0
l
=
injectHelpersCallbacks
.
length
;
i
<
l
;
i
+
+
)
{
injectHelpersCallbacks
[
i
]
(
this
)
;
}
}
removeTestHelpers
:
function
(
)
{
if
(
!
this
.
helperContainer
)
{
return
;
}
for
(
var
name
in
helpers
)
{
this
.
helperContainer
[
name
]
=
this
.
originalMethods
[
name
]
;
delete
Test
.
Promise
.
prototype
[
name
]
;
delete
this
.
testHelpers
[
name
]
;
delete
this
.
originalMethods
[
name
]
;
}
}
}
)
;
function
protoWrap
(
proto
name
callback
isAsync
)
{
proto
[
name
]
=
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
if
(
isAsync
)
{
return
callback
.
apply
(
this
args
)
;
}
else
{
return
this
.
then
(
function
(
)
{
return
callback
.
apply
(
this
args
)
;
}
)
;
}
}
;
}
Test
.
Promise
=
function
(
)
{
_emberRuntimeExtRsvp
.
default
.
Promise
.
apply
(
this
arguments
)
;
Test
.
lastPromise
=
this
;
}
;
Test
.
Promise
.
prototype
=
Object
.
create
(
_emberRuntimeExtRsvp
.
default
.
Promise
.
prototype
)
;
Test
.
Promise
.
prototype
.
constructor
=
Test
.
Promise
;
Test
.
Promise
.
resolve
=
Test
.
resolve
;
var
originalThen
=
_emberRuntimeExtRsvp
.
default
.
Promise
.
prototype
.
then
;
Test
.
Promise
.
prototype
.
then
=
function
(
onSuccess
onFailure
)
{
return
originalThen
.
call
(
this
function
(
val
)
{
return
isolate
(
onSuccess
val
)
;
}
onFailure
)
;
}
;
function
isolate
(
fn
val
)
{
var
value
lastPromise
;
Test
.
lastPromise
=
null
;
value
=
fn
(
val
)
;
lastPromise
=
Test
.
lastPromise
;
Test
.
lastPromise
=
null
;
if
(
value
&
&
value
instanceof
Test
.
Promise
|
|
!
lastPromise
)
{
return
value
;
}
else
{
return
run
(
function
(
)
{
return
Test
.
resolve
(
lastPromise
)
.
then
(
function
(
)
{
return
value
;
}
)
;
}
)
;
}
}
exports
.
default
=
Test
;
}
)
;
enifed
(
'
ember
-
views
/
compat
/
attrs
-
proxy
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
symbol
'
'
ember
-
metal
/
property_events
'
]
function
(
exports
_emberMetalMixin
_emberMetalSymbol
_emberMetalProperty_events
)
{
'
use
strict
'
;
exports
.
deprecation
=
deprecation
;
function
deprecation
(
key
)
{
return
'
You
tried
to
look
up
an
attribute
directly
on
the
component
.
This
is
deprecated
.
Use
attrs
.
'
+
key
+
'
instead
.
'
;
}
var
MUTABLE_CELL
=
_emberMetalSymbol
.
default
(
'
MUTABLE_CELL
'
)
;
exports
.
MUTABLE_CELL
=
MUTABLE_CELL
;
function
isCell
(
val
)
{
return
val
&
&
val
[
MUTABLE_CELL
]
;
}
var
AttrsProxyMixin
=
{
attrs
:
null
getAttr
:
function
(
key
)
{
var
attrs
=
this
.
attrs
;
if
(
!
attrs
)
{
return
;
}
return
this
.
getAttrFor
(
attrs
key
)
;
}
getAttrFor
:
function
(
attrs
key
)
{
var
val
=
attrs
[
key
]
;
return
isCell
(
val
)
?
val
.
value
:
val
;
}
setAttr
:
function
(
key
value
)
{
var
attrs
=
this
.
attrs
;
var
val
=
attrs
[
key
]
;
if
(
!
isCell
(
val
)
)
{
throw
new
Error
(
'
You
can
\
'
t
update
attrs
.
'
+
key
+
'
because
it
\
'
s
not
mutable
'
)
;
}
val
.
update
(
value
)
;
}
_propagateAttrsToThis
:
function
(
attrs
)
{
this
.
_isDispatchingAttrs
=
true
;
this
.
setProperties
(
attrs
)
;
this
.
_isDispatchingAttrs
=
false
;
}
}
;
AttrsProxyMixin
[
_emberMetalProperty_events
.
PROPERTY_DID_CHANGE
]
=
function
(
key
)
{
if
(
this
.
_isAngleBracket
)
{
return
;
}
if
(
this
.
_isDispatchingAttrs
)
{
return
;
}
if
(
this
.
_currentState
)
{
this
.
_currentState
.
legacyPropertyDidChange
(
this
key
)
;
}
}
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
AttrsProxyMixin
)
;
}
)
;
enifed
(
'
ember
-
views
/
component_lookup
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
debug
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
htmlbars
/
system
/
lookup
-
helper
'
'
container
/
owner
'
]
function
(
exports
_emberMetalCore
_emberMetalDebug
_emberRuntimeSystemObject
_emberHtmlbarsSystemLookupHelper
_containerOwner
)
{
'
use
strict
'
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
invalidName
:
function
(
name
)
{
if
(
!
_emberHtmlbarsSystemLookupHelper
.
CONTAINS_DASH_CACHE
.
get
(
name
)
)
{
_emberMetalDebug
.
assert
(
'
You
cannot
use
\
'
'
+
name
+
'
\
'
as
a
component
name
.
Component
names
must
contain
a
hyphen
.
'
)
;
return
true
;
}
}
lookupFactory
:
function
(
name
owner
)
{
owner
=
owner
|
|
_containerOwner
.
getOwner
(
this
)
;
var
fullName
=
'
component
:
'
+
name
;
var
templateFullName
=
'
template
:
components
/
'
+
name
;
var
templateRegistered
=
owner
&
&
owner
.
hasRegistration
(
templateFullName
)
;
if
(
templateRegistered
)
{
owner
.
inject
(
fullName
'
layout
'
templateFullName
)
;
}
var
Component
=
owner
.
_lookupFactory
(
fullName
)
;
if
(
templateRegistered
|
|
Component
)
{
if
(
!
Component
)
{
owner
.
register
(
fullName
_emberMetalCore
.
default
.
Component
)
;
Component
=
owner
.
_lookupFactory
(
fullName
)
;
}
return
Component
;
}
}
componentFor
:
function
(
name
owner
options
)
{
if
(
this
.
invalidName
(
name
)
)
{
return
;
}
var
fullName
=
'
component
:
'
+
name
;
return
owner
.
_lookupFactory
(
fullName
options
)
;
}
layoutFor
:
function
(
name
owner
options
)
{
if
(
this
.
invalidName
(
name
)
)
{
return
;
}
var
templateFullName
=
'
template
:
components
/
'
+
name
;
return
owner
.
lookup
(
templateFullName
options
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
components
/
component
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
environment
'
'
ember
-
runtime
/
mixins
/
target_action_support
'
'
ember
-
views
/
views
/
view
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
computed
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
'
container
/
owner
'
]
function
(
exports
_emberMetalDebug
_emberMetalEnvironment
_emberRuntimeMixinsTarget_action_support
_emberViewsViewsView
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalIs_none
_emberMetalUtils
_emberMetalComputed
_emberViewsCompatAttrsProxy
_containerOwner
)
{
'
use
strict
'
;
function
validateAction
(
component
actionName
)
{
if
(
actionName
&
&
actionName
[
_emberViewsCompatAttrsProxy
.
MUTABLE_CELL
]
)
{
actionName
=
actionName
.
value
;
}
_emberMetalDebug
.
assert
(
'
The
default
action
was
triggered
on
the
component
'
+
component
.
toString
(
)
+
'
but
the
action
name
(
'
+
actionName
+
'
)
was
not
a
string
.
'
_emberMetalIs_none
.
default
(
actionName
)
|
|
typeof
actionName
=
=
=
'
string
'
|
|
typeof
actionName
=
=
=
'
function
'
)
;
return
actionName
;
}
var
Component
=
_emberViewsViewsView
.
default
.
extend
(
_emberRuntimeMixinsTarget_action_support
.
default
{
isComponent
:
true
controller
:
null
context
:
null
instrumentName
:
'
component
'
instrumentDisplay
:
_emberMetalComputed
.
computed
(
function
(
)
{
if
(
this
.
_debugContainerKey
)
{
return
'
{
{
'
+
this
.
_debugContainerKey
.
split
(
'
:
'
)
[
1
]
+
'
}
}
'
;
}
}
)
init
:
function
(
)
{
var
_this
=
this
;
this
.
_super
.
apply
(
this
arguments
)
;
_emberMetalProperty_set
.
set
(
this
'
controller
'
this
)
;
_emberMetalProperty_set
.
set
(
this
'
context
'
this
)
;
if
(
!
this
.
layout
&
&
this
.
layoutName
&
&
_containerOwner
.
getOwner
(
this
)
)
{
var
layoutName
=
_emberMetalProperty_get
.
get
(
this
'
layoutName
'
)
;
this
.
layout
=
this
.
templateForName
(
layoutName
)
;
}
if
(
this
.
defaultLayout
&
&
!
this
.
layout
)
{
_emberMetalDebug
.
deprecate
(
'
Specifying
defaultLayout
to
'
+
this
+
'
is
deprecated
.
Please
use
layout
instead
.
'
false
{
id
:
'
ember
-
views
.
component
.
defaultLayout
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
component
-
defaultlayout
'
}
)
;
this
.
layout
=
this
.
defaultLayout
;
}
_emberMetalDebug
.
assert
(
'
You
can
not
define
a
function
that
handles
DOM
events
in
the
'
+
this
+
'
tagless
component
since
it
doesn
\
'
t
have
any
DOM
element
.
'
this
.
tagName
!
=
=
'
'
|
|
!
_emberMetalEnvironment
.
default
.
hasDOM
|
|
!
(
function
(
)
{
var
eventDispatcher
=
_containerOwner
.
getOwner
(
_this
)
.
lookup
(
'
event_dispatcher
:
main
'
)
;
var
events
=
eventDispatcher
&
&
eventDispatcher
.
_finalEvents
|
|
{
}
;
for
(
var
key
in
events
)
{
var
methodName
=
events
[
key
]
;
if
(
typeof
_this
[
methodName
]
=
=
=
'
function
'
)
{
return
true
;
}
}
}
)
(
)
)
;
}
template
:
null
layoutName
:
null
layout
:
null
targetObject
:
_emberMetalComputed
.
computed
(
'
controller
'
function
(
key
)
{
if
(
this
.
_targetObject
)
{
return
this
.
_targetObject
;
}
if
(
this
.
_controller
)
{
return
this
.
_controller
;
}
var
parentView
=
_emberMetalProperty_get
.
get
(
this
'
parentView
'
)
;
return
parentView
?
_emberMetalProperty_get
.
get
(
parentView
'
controller
'
)
:
null
;
}
)
sendAction
:
function
(
action
)
{
for
(
var
_len
=
arguments
.
length
contexts
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
contexts
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
actionName
;
if
(
action
=
=
=
undefined
)
{
action
=
'
action
'
;
}
actionName
=
_emberMetalProperty_get
.
get
(
this
'
attrs
.
'
+
action
)
|
|
_emberMetalProperty_get
.
get
(
this
action
)
;
actionName
=
validateAction
(
this
actionName
)
;
if
(
actionName
=
=
=
undefined
)
{
return
;
}
if
(
typeof
actionName
=
=
=
'
function
'
)
{
actionName
.
apply
(
undefined
contexts
)
;
}
else
{
this
.
triggerAction
(
{
action
:
actionName
actionContext
:
contexts
}
)
;
}
}
send
:
function
(
actionName
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
>
1
?
_len2
-
1
:
0
)
_key2
=
1
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
-
1
]
=
arguments
[
_key2
]
;
}
var
target
;
var
action
=
this
.
actions
&
&
this
.
actions
[
actionName
]
;
if
(
action
)
{
var
shouldBubble
=
action
.
apply
(
this
args
)
=
=
=
true
;
if
(
!
shouldBubble
)
{
return
;
}
}
if
(
target
=
_emberMetalProperty_get
.
get
(
this
'
target
'
)
)
{
var
_target
;
_emberMetalDebug
.
assert
(
'
The
target
for
'
+
this
+
'
(
'
+
target
+
'
)
does
not
have
a
send
method
'
typeof
target
.
send
=
=
=
'
function
'
)
;
(
_target
=
target
)
.
send
.
apply
(
_target
arguments
)
;
}
else
{
if
(
!
action
)
{
throw
new
Error
(
_emberMetalUtils
.
inspect
(
this
)
+
'
had
no
action
handler
for
:
'
+
actionName
)
;
}
}
}
}
)
;
Component
.
reopenClass
(
{
isComponentFactory
:
true
}
)
;
exports
.
default
=
Component
;
}
)
;
enifed
(
'
ember
-
views
/
index
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
views
/
system
/
utils
'
'
ember
-
views
/
system
/
ext
'
'
ember
-
metal
-
views
'
'
ember
-
views
/
components
/
component
'
'
ember
-
views
/
system
/
event_dispatcher
'
'
ember
-
views
/
mixins
/
view_target_action_support
'
'
ember
-
views
/
component_lookup
'
'
ember
-
views
/
views
/
checkbox
'
'
ember
-
views
/
mixins
/
text_support
'
'
ember
-
views
/
views
/
text_field
'
'
ember
-
views
/
views
/
text_area
'
]
function
(
exports
_emberRuntime
_emberViewsSystemJquery
_emberViewsSystemUtils
_emberViewsSystemExt
_emberMetalViews
_emberViewsComponentsComponent
_emberViewsSystemEvent_dispatcher
_emberViewsMixinsView_target_action_support
_emberViewsComponent_lookup
_emberViewsViewsCheckbox
_emberViewsMixinsText_support
_emberViewsViewsText_field
_emberViewsViewsText_area
)
{
'
use
strict
'
;
_emberRuntime
.
default
.
=
_emberViewsSystemJquery
.
default
;
_emberRuntime
.
default
.
ViewTargetActionSupport
=
_emberViewsMixinsView_target_action_support
.
default
;
var
ViewUtils
=
_emberRuntime
.
default
.
ViewUtils
=
{
}
;
ViewUtils
.
isSimpleClick
=
_emberViewsSystemUtils
.
isSimpleClick
;
ViewUtils
.
getViewClientRects
=
_emberViewsSystemUtils
.
getViewClientRects
;
ViewUtils
.
getViewBoundingClientRect
=
_emberViewsSystemUtils
.
getViewBoundingClientRect
;
_emberRuntime
.
default
.
_Renderer
=
_emberMetalViews
.
Renderer
;
_emberRuntime
.
default
.
Checkbox
=
_emberViewsViewsCheckbox
.
default
;
_emberRuntime
.
default
.
TextField
=
_emberViewsViewsText_field
.
default
;
_emberRuntime
.
default
.
TextArea
=
_emberViewsViewsText_area
.
default
;
_emberRuntime
.
default
.
TextSupport
=
_emberViewsMixinsText_support
.
default
;
_emberRuntime
.
default
.
ComponentLookup
=
_emberViewsComponent_lookup
.
default
;
_emberRuntime
.
default
.
Component
=
_emberViewsComponentsComponent
.
default
;
_emberRuntime
.
default
.
EventDispatcher
=
_emberViewsSystemEvent_dispatcher
.
default
;
exports
.
default
=
_emberRuntime
.
default
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
aria_role_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalMixin
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
attributeBindings
:
[
'
ariaRole
:
role
'
]
ariaRole
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
class_names_support
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
system
/
native_array
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
_emberRuntimeSystemNative_array
)
{
'
use
strict
'
;
var
EMPTY_ARRAY
=
[
]
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
concatenatedProperties
:
[
'
classNames
'
'
classNameBindings
'
]
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
_emberMetalDebug
.
assert
(
'
Only
arrays
are
allowed
for
\
'
classNameBindings
\
'
'
Array
.
isArray
(
this
.
classNameBindings
)
)
;
this
.
classNameBindings
=
_emberRuntimeSystemNative_array
.
A
(
this
.
classNameBindings
.
slice
(
)
)
;
_emberMetalDebug
.
assert
(
'
Only
arrays
of
static
class
strings
are
allowed
for
\
'
classNames
\
'
.
For
dynamic
classes
use
\
'
classNameBindings
\
'
.
'
Array
.
isArray
(
this
.
classNames
)
)
;
this
.
classNames
=
_emberRuntimeSystemNative_array
.
A
(
this
.
classNames
.
slice
(
)
)
;
}
classNames
:
[
'
ember
-
view
'
]
classNameBindings
:
EMPTY_ARRAY
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
instrumentation_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalMixin
_emberMetalProperty_get
)
{
'
use
strict
'
;
var
InstrumentationSupport
=
_emberMetalMixin
.
Mixin
.
create
(
{
instrumentDisplay
:
'
'
instrumentName
:
'
view
'
instrumentDetails
:
function
(
hash
)
{
hash
.
template
=
_emberMetalProperty_get
.
get
(
this
'
templateName
'
)
;
this
.
_super
(
hash
)
;
}
}
)
;
exports
.
default
=
InstrumentationSupport
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
legacy_child_views_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
container
/
owner
'
]
function
(
exports
_emberMetalMixin
_emberMetalProperty_get
_emberMetalProperty_set
_containerOwner
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
linkChild
:
function
(
instance
)
{
if
(
!
instance
[
_containerOwner
.
OWNER
]
)
{
_containerOwner
.
setOwner
(
instance
_containerOwner
.
getOwner
(
this
)
)
;
}
if
(
_emberMetalProperty_get
.
get
(
instance
'
parentView
'
)
!
=
=
this
)
{
_emberMetalProperty_set
.
set
(
instance
'
parentView
'
this
)
;
instance
.
trigger
(
'
parentViewDidChange
'
)
;
}
instance
.
ownerView
=
this
.
ownerView
;
}
unlinkChild
:
function
(
instance
)
{
_emberMetalProperty_set
.
set
(
instance
'
parentView
'
null
)
;
instance
.
trigger
(
'
parentViewDidChange
'
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
legacy_view_support
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
_emberMetalProperty_get
)
{
'
use
strict
'
;
var
LegacyViewSupport
=
_emberMetalMixin
.
Mixin
.
create
(
{
mutateChildViews
:
function
(
callback
)
{
var
childViews
=
_emberMetalProperty_get
.
get
(
this
'
childViews
'
)
;
var
idx
=
childViews
.
length
;
var
view
;
while
(
-
-
idx
>
=
0
)
{
view
=
childViews
[
idx
]
;
callback
(
this
view
idx
)
;
}
return
this
;
}
removeAllChildren
:
function
(
)
{
return
this
.
mutateChildViews
(
function
(
parentView
view
)
{
parentView
.
removeChild
(
view
)
;
}
)
;
}
destroyAllChildren
:
function
(
)
{
return
this
.
mutateChildViews
(
function
(
parentView
view
)
{
view
.
destroy
(
)
;
}
)
;
}
nearestChildOf
:
function
(
klass
)
{
_emberMetalDebug
.
deprecate
(
'
nearestChildOf
has
been
deprecated
.
'
false
{
id
:
'
ember
-
views
.
nearest
-
child
-
of
'
until
:
'
3
.
0
.
0
'
}
)
;
var
view
=
_emberMetalProperty_get
.
get
(
this
'
parentView
'
)
;
while
(
view
)
{
if
(
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
instanceof
klass
)
{
return
view
;
}
view
=
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
;
}
}
nearestInstanceOf
:
function
(
klass
)
{
_emberMetalDebug
.
deprecate
(
'
nearestInstanceOf
is
deprecated
and
will
be
removed
from
future
releases
.
Use
nearestOfType
.
'
false
{
id
:
'
ember
-
views
.
nearest
-
instance
-
of
'
until
:
'
3
.
0
.
0
'
}
)
;
var
view
=
_emberMetalProperty_get
.
get
(
this
'
parentView
'
)
;
while
(
view
)
{
if
(
view
instanceof
klass
)
{
return
view
;
}
view
=
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
;
}
}
_contextDidChange
:
_emberMetalMixin
.
observer
(
'
context
'
function
(
)
{
this
.
rerender
(
)
;
}
)
}
)
;
exports
.
default
=
LegacyViewSupport
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
template_rendering_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalMixin
)
{
'
use
strict
'
;
var
_renderView
;
var
TemplateRenderingSupport
=
_emberMetalMixin
.
Mixin
.
create
(
{
renderBlock
:
function
(
block
renderNode
)
{
if
(
_renderView
=
=
=
undefined
)
{
_renderView
=
require
(
'
ember
-
htmlbars
/
system
/
render
-
view
'
)
;
}
return
_renderView
.
renderHTMLBarsBlock
(
this
block
renderNode
)
;
}
}
)
;
exports
.
default
=
TemplateRenderingSupport
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
text_support
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
mixins
/
target_action_support
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalMixin
_emberRuntimeMixinsTarget_action_support
)
{
'
use
strict
'
;
var
KEY_EVENTS
=
{
13
:
'
insertNewline
'
27
:
'
cancel
'
}
;
var
TextSupport
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsTarget_action_support
.
default
{
value
:
'
'
attributeBindings
:
[
'
autocapitalize
'
'
autocorrect
'
'
autofocus
'
'
disabled
'
'
form
'
'
maxlength
'
'
placeholder
'
'
readonly
'
'
required
'
'
selectionDirection
'
'
spellcheck
'
'
tabindex
'
'
title
'
]
placeholder
:
null
disabled
:
false
maxlength
:
null
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
on
(
'
paste
'
this
this
.
_elementValueDidChange
)
;
this
.
on
(
'
cut
'
this
this
.
_elementValueDidChange
)
;
this
.
on
(
'
input
'
this
this
.
_elementValueDidChange
)
;
}
action
:
null
onEvent
:
'
enter
'
bubbles
:
false
interpretKeyEvents
:
function
(
event
)
{
var
map
=
KEY_EVENTS
;
var
method
=
map
[
event
.
keyCode
]
;
this
.
_elementValueDidChange
(
)
;
if
(
method
)
{
return
this
[
method
]
(
event
)
;
}
}
_elementValueDidChange
:
function
(
)
{
_emberMetalProperty_set
.
set
(
this
'
value
'
this
.
readDOMAttr
(
'
value
'
)
)
;
}
change
:
function
(
event
)
{
this
.
_elementValueDidChange
(
event
)
;
}
insertNewline
:
function
(
event
)
{
sendAction
(
'
enter
'
this
event
)
;
sendAction
(
'
insert
-
newline
'
this
event
)
;
}
cancel
:
function
(
event
)
{
sendAction
(
'
escape
-
press
'
this
event
)
;
}
focusIn
:
function
(
event
)
{
sendAction
(
'
focus
-
in
'
this
event
)
;
}
focusOut
:
function
(
event
)
{
this
.
_elementValueDidChange
(
event
)
;
sendAction
(
'
focus
-
out
'
this
event
)
;
}
keyPress
:
function
(
event
)
{
sendAction
(
'
key
-
press
'
this
event
)
;
}
keyUp
:
function
(
event
)
{
this
.
interpretKeyEvents
(
event
)
;
this
.
sendAction
(
'
key
-
up
'
_emberMetalProperty_get
.
get
(
this
'
value
'
)
event
)
;
}
keyDown
:
function
(
event
)
{
this
.
sendAction
(
'
key
-
down
'
_emberMetalProperty_get
.
get
(
this
'
value
'
)
event
)
;
}
}
)
;
function
sendAction
(
eventName
view
event
)
{
var
action
=
_emberMetalProperty_get
.
get
(
view
'
attrs
.
'
+
eventName
)
|
|
_emberMetalProperty_get
.
get
(
view
eventName
)
;
var
on
=
_emberMetalProperty_get
.
get
(
view
'
onEvent
'
)
;
var
value
=
_emberMetalProperty_get
.
get
(
view
'
value
'
)
;
if
(
on
=
=
=
eventName
|
|
on
=
=
=
'
keyPress
'
&
&
eventName
=
=
=
'
key
-
press
'
)
{
view
.
sendAction
(
'
action
'
value
)
;
}
view
.
sendAction
(
eventName
value
)
;
if
(
action
|
|
on
=
=
=
eventName
)
{
if
(
!
_emberMetalProperty_get
.
get
(
view
'
bubbles
'
)
)
{
event
.
stopPropagation
(
)
;
}
}
}
exports
.
default
=
TextSupport
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_child_views_support
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
set_properties
'
'
ember
-
runtime
/
system
/
native_array
'
'
container
/
owner
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalSet_properties
_emberRuntimeSystemNative_array
_containerOwner
)
{
'
use
strict
'
;
var
EMPTY_ARRAY
=
[
]
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
{
childViews
:
EMPTY_ARRAY
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
childViews
=
_emberRuntimeSystemNative_array
.
A
(
this
.
childViews
.
slice
(
)
)
;
this
.
ownerView
=
this
.
ownerView
|
|
this
;
}
appendChild
:
function
(
view
)
{
this
.
linkChild
(
view
)
;
this
.
childViews
.
push
(
view
)
;
}
destroyChild
:
function
(
view
)
{
view
.
destroy
(
)
;
}
removeChild
:
function
(
view
)
{
if
(
this
.
isDestroying
)
{
return
;
}
this
.
unlinkChild
(
view
)
;
var
childViews
=
_emberMetalProperty_get
.
get
(
this
'
childViews
'
)
;
var
index
=
childViews
.
indexOf
(
view
)
;
if
(
index
!
=
=
-
1
)
{
childViews
.
splice
(
index
1
)
;
}
return
this
;
}
createChildView
:
function
(
maybeViewClass
)
{
var
attrs
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
if
(
!
maybeViewClass
)
{
throw
new
TypeError
(
'
createChildViews
first
argument
must
exist
'
)
;
}
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
if
(
maybeViewClass
.
isView
&
&
maybeViewClass
.
parentView
=
=
=
this
&
&
_containerOwner
.
getOwner
(
maybeViewClass
)
=
=
=
owner
)
{
return
maybeViewClass
;
}
var
view
;
attrs
.
parentView
=
this
;
attrs
.
renderer
=
this
.
renderer
;
attrs
.
_viewRegistry
=
this
.
_viewRegistry
;
if
(
maybeViewClass
.
isViewFactory
)
{
_containerOwner
.
setOwner
(
attrs
owner
)
;
view
=
maybeViewClass
.
create
(
attrs
)
;
if
(
view
.
viewName
)
{
_emberMetalProperty_set
.
set
(
this
view
.
viewName
view
)
;
}
}
else
if
(
'
string
'
=
=
=
typeof
maybeViewClass
)
{
var
fullName
=
'
view
:
'
+
maybeViewClass
;
var
ViewKlass
=
owner
.
_lookupFactory
(
fullName
)
;
_emberMetalDebug
.
assert
(
'
Could
not
find
view
:
\
'
'
+
fullName
+
'
\
'
'
!
!
ViewKlass
)
;
view
=
ViewKlass
.
create
(
attrs
)
;
}
else
{
view
=
maybeViewClass
;
_emberMetalDebug
.
assert
(
'
You
must
pass
instance
or
subclass
of
View
'
view
.
isView
)
;
_containerOwner
.
setOwner
(
attrs
owner
)
;
_emberMetalSet_properties
.
default
(
view
attrs
)
;
}
this
.
linkChild
(
view
)
;
return
view
;
}
linkChild
:
function
(
instance
)
{
if
(
!
instance
[
_containerOwner
.
OWNER
]
)
{
_containerOwner
.
setOwner
(
instance
_containerOwner
.
getOwner
(
this
)
)
;
}
instance
.
parentView
=
this
;
instance
.
ownerView
=
this
.
ownerView
;
}
unlinkChild
:
function
(
instance
)
{
instance
.
parentView
=
null
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_context_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
views
/
mixins
/
legacy_view_support
'
'
ember
-
metal
/
events
'
]
function
(
exports
_emberMetalMixin
_emberMetalComputed
_emberMetalProperty_get
_emberMetalProperty_set
_emberViewsMixinsLegacy_view_support
_emberMetalEvents
)
{
'
use
strict
'
;
var
ViewContextSupport
=
_emberMetalMixin
.
Mixin
.
create
(
_emberViewsMixinsLegacy_view_support
.
default
{
context
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
)
{
return
_emberMetalProperty_get
.
get
(
this
'
_context
'
)
;
}
set
:
function
(
key
value
)
{
_emberMetalProperty_set
.
set
(
this
'
_context
'
value
)
;
return
value
;
}
}
)
_context
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
)
{
var
parentView
controller
;
if
(
controller
=
_emberMetalProperty_get
.
get
(
this
'
controller
'
)
)
{
return
controller
;
}
parentView
=
this
.
parentView
;
if
(
parentView
)
{
return
_emberMetalProperty_get
.
get
(
parentView
'
_context
'
)
;
}
return
null
;
}
set
:
function
(
key
value
)
{
return
value
;
}
}
)
_controller
:
null
controller
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
)
{
if
(
this
.
_controller
)
{
return
this
.
_controller
;
}
return
this
.
parentView
?
_emberMetalProperty_get
.
get
(
this
.
parentView
'
controller
'
)
:
null
;
}
set
:
function
(
_
value
)
{
this
.
_controller
=
value
;
return
value
;
}
}
)
_legacyControllerDidChange
:
_emberMetalMixin
.
observer
(
'
controller
'
function
(
)
{
this
.
childViews
.
forEach
(
function
(
view
)
{
return
view
.
notifyPropertyChange
(
'
controller
'
)
;
}
)
;
}
)
_notifyControllerChange
:
_emberMetalEvents
.
on
(
'
parentViewDidChange
'
function
(
)
{
this
.
notifyPropertyChange
(
'
controller
'
)
;
}
)
}
)
;
exports
.
default
=
ViewContextSupport
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_state_support
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
mixin
'
]
function
(
exports
_emberMetalDebug
_emberMetalMixin
)
{
'
use
strict
'
;
var
ViewStateSupport
=
_emberMetalMixin
.
Mixin
.
create
(
{
transitionTo
:
function
(
state
)
{
_emberMetalDebug
.
deprecate
(
'
Ember
.
View
#
transitionTo
has
been
deprecated
it
is
for
internal
use
only
'
false
{
id
:
'
ember
-
views
.
view
-
transition
-
to
'
until
:
'
2
.
4
.
0
'
}
)
;
this
.
_transitionTo
(
state
)
;
}
_transitionTo
:
function
(
state
)
{
var
priorState
=
this
.
_currentState
;
var
currentState
=
this
.
_currentState
=
this
.
_states
[
state
]
;
this
.
_state
=
state
;
if
(
priorState
&
&
priorState
.
exit
)
{
priorState
.
exit
(
this
)
;
}
if
(
currentState
.
enter
)
{
currentState
.
enter
(
this
)
;
}
}
}
)
;
exports
.
default
=
ViewStateSupport
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_support
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
observer
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
system
/
core_object
'
'
ember
-
metal
/
symbol
'
'
container
/
owner
'
'
ember
-
views
/
system
/
jquery
'
]
function
(
exports
_emberMetalDebug
_emberMetalError
_emberMetalProperty_get
_emberMetalRun_loop
_emberMetalObserver
_emberMetalUtils
_emberMetalComputed
_emberMetalMixin
_emberRuntimeSystemCore_object
_emberMetalSymbol
_containerOwner
_emberViewsSystemJquery
)
{
'
use
strict
'
;
var
_Mixin
create
;
var
INIT_WAS_CALLED
=
_emberMetalSymbol
.
default
(
'
INIT_WAS_CALLED
'
)
;
function
K
(
)
{
return
this
;
}
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
(
_Mixin
create
=
{
concatenatedProperties
:
[
'
attributeBindings
'
]
isView
:
true
templateName
:
null
layoutName
:
null
template
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
)
{
var
templateName
=
_emberMetalProperty_get
.
get
(
this
'
templateName
'
)
;
var
template
=
this
.
templateForName
(
templateName
'
template
'
)
;
_emberMetalDebug
.
assert
(
'
You
specified
the
templateName
'
+
templateName
+
'
for
'
+
this
+
'
but
it
did
not
exist
.
'
!
templateName
|
|
!
!
template
)
;
return
template
|
|
_emberMetalProperty_get
.
get
(
this
'
defaultTemplate
'
)
;
}
set
:
function
(
key
value
)
{
if
(
value
!
=
=
undefined
)
{
return
value
;
}
return
_emberMetalProperty_get
.
get
(
this
key
)
;
}
}
)
layout
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
key
)
{
var
layoutName
=
_emberMetalProperty_get
.
get
(
this
'
layoutName
'
)
;
var
layout
=
this
.
templateForName
(
layoutName
'
layout
'
)
;
_emberMetalDebug
.
assert
(
'
You
specified
the
layoutName
'
+
layoutName
+
'
for
'
+
this
+
'
but
it
did
not
exist
.
'
!
layoutName
|
|
!
!
layout
)
;
return
layout
|
|
_emberMetalProperty_get
.
get
(
this
'
defaultLayout
'
)
;
}
set
:
function
(
key
value
)
{
return
value
;
}
}
)
templateForName
:
function
(
name
type
)
{
if
(
!
name
)
{
return
;
}
_emberMetalDebug
.
assert
(
'
templateNames
are
not
allowed
to
contain
periods
:
'
+
name
name
.
indexOf
(
'
.
'
)
=
=
=
-
1
)
;
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
if
(
!
owner
)
{
throw
new
_emberMetalError
.
default
(
'
Container
was
not
found
when
looking
up
a
views
template
.
'
+
'
This
is
most
likely
due
to
manually
instantiating
an
Ember
.
View
.
'
+
'
See
:
http
:
/
/
git
.
io
/
EKPpnA
'
)
;
}
return
owner
.
lookup
(
'
template
:
'
+
name
)
;
}
nearestOfType
:
function
(
klass
)
{
var
view
=
_emberMetalProperty_get
.
get
(
this
'
parentView
'
)
;
var
isOfType
=
klass
instanceof
_emberMetalMixin
.
Mixin
?
function
(
view
)
{
return
klass
.
detect
(
view
)
;
}
:
function
(
view
)
{
return
klass
.
detect
(
view
.
constructor
)
;
}
;
while
(
view
)
{
if
(
isOfType
(
view
)
)
{
return
view
;
}
view
=
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
;
}
}
nearestWithProperty
:
function
(
property
)
{
var
view
=
_emberMetalProperty_get
.
get
(
this
'
parentView
'
)
;
while
(
view
)
{
if
(
property
in
view
)
{
return
view
;
}
view
=
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
;
}
}
rerender
:
function
(
)
{
return
this
.
_currentState
.
rerender
(
this
)
;
}
element
:
null
:
function
(
sel
)
{
_emberMetalDebug
.
assert
(
'
You
cannot
access
this
.
(
)
on
a
component
with
tagName
:
\
'
\
'
specified
.
'
this
.
tagName
!
=
=
'
'
)
;
return
this
.
_currentState
.
(
this
sel
)
;
}
forEachChildView
:
function
(
callback
)
{
var
childViews
=
this
.
childViews
;
if
(
!
childViews
)
{
return
this
;
}
var
len
=
childViews
.
length
;
var
view
idx
;
for
(
idx
=
0
;
idx
<
len
;
idx
+
+
)
{
view
=
childViews
[
idx
]
;
callback
(
view
)
;
}
return
this
;
}
appendTo
:
function
(
selector
)
{
var
=
this
.
_environment
?
this
.
_environment
.
options
.
jQuery
:
_emberViewsSystemJquery
.
default
;
if
(
)
{
var
target
=
(
selector
)
;
_emberMetalDebug
.
assert
(
'
You
tried
to
append
to
(
'
+
selector
+
'
)
but
that
isn
\
'
t
in
the
DOM
'
target
.
length
>
0
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
append
to
an
existing
Ember
.
View
.
'
!
target
.
is
(
'
.
ember
-
view
'
)
&
&
!
target
.
parents
(
)
.
is
(
'
.
ember
-
view
'
)
)
;
this
.
renderer
.
appendTo
(
this
target
[
0
]
)
;
}
else
{
var
target
=
selector
;
_emberMetalDebug
.
assert
(
'
You
tried
to
append
to
a
selector
string
(
'
+
selector
+
'
)
in
an
environment
without
jQuery
'
typeof
target
!
=
=
'
string
'
)
;
_emberMetalDebug
.
assert
(
'
You
tried
to
append
to
a
non
-
Element
(
'
+
selector
+
'
)
in
an
environment
without
jQuery
'
typeof
selector
.
appendChild
=
=
=
'
function
'
)
;
this
.
renderer
.
appendTo
(
this
target
)
;
}
return
this
;
}
renderToElement
:
function
(
tagName
)
{
tagName
=
tagName
|
|
'
body
'
;
var
element
=
this
.
renderer
.
_dom
.
createElement
(
tagName
)
;
this
.
renderer
.
appendTo
(
this
element
)
;
return
element
;
}
replaceIn
:
function
(
selector
)
{
var
target
=
_emberViewsSystemJquery
.
default
(
selector
)
;
_emberMetalDebug
.
assert
(
'
You
tried
to
replace
in
(
'
+
selector
+
'
)
but
that
isn
\
'
t
in
the
DOM
'
target
.
length
>
0
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
replace
an
existing
Ember
.
View
.
'
!
target
.
is
(
'
.
ember
-
view
'
)
&
&
!
target
.
parents
(
)
.
is
(
'
.
ember
-
view
'
)
)
;
this
.
renderer
.
replaceIn
(
this
target
[
0
]
)
;
return
this
;
}
append
:
function
(
)
{
return
this
.
appendTo
(
document
.
body
)
;
}
remove
:
function
(
)
{
if
(
!
this
.
removedFromDOM
)
{
this
.
destroyElement
(
)
;
}
this
.
_willInsert
=
false
;
}
elementId
:
null
findElementInParentElement
:
function
(
parentElem
)
{
var
id
=
'
#
'
+
this
.
elementId
;
return
_emberViewsSystemJquery
.
default
(
id
)
[
0
]
|
|
_emberViewsSystemJquery
.
default
(
id
parentElem
)
[
0
]
;
}
createElement
:
function
(
)
{
if
(
this
.
element
)
{
return
this
;
}
this
.
renderer
.
createElement
(
this
)
;
return
this
;
}
willInsertElement
:
K
didInsertElement
:
K
willClearRender
:
K
destroyElement
:
function
(
)
{
return
this
.
_currentState
.
destroyElement
(
this
)
;
}
willDestroyElement
:
K
parentViewDidChange
:
K
tagName
:
null
readDOMAttr
:
function
(
name
)
{
var
attr
=
this
.
_renderNode
.
childNodes
.
filter
(
function
(
node
)
{
return
node
.
attrName
=
=
=
name
;
}
)
[
0
]
;
if
(
!
attr
)
{
return
null
;
}
return
attr
.
getContent
(
)
;
}
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
!
this
.
elementId
)
{
this
.
elementId
=
_emberMetalUtils
.
guidFor
(
this
)
;
}
this
.
scheduledRevalidation
=
false
;
this
[
INIT_WAS_CALLED
]
=
true
;
if
(
typeof
this
.
didInitAttrs
=
=
=
'
function
'
)
{
_emberMetalDebug
.
deprecate
(
'
[
DEPRECATED
]
didInitAttrs
called
in
'
+
this
.
toString
(
)
+
'
.
'
false
{
id
:
'
ember
-
views
.
did
-
init
-
attrs
'
until
:
'
3
.
0
.
0
'
url
:
'
http
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
#
toc_ember
-
component
-
didinitattrs
'
}
)
;
}
_emberMetalDebug
.
assert
(
'
Using
a
custom
.
render
function
is
no
longer
supported
.
'
!
this
.
render
)
;
}
}
_Mixin
create
[
_emberRuntimeSystemCore_object
.
POST_INIT
]
=
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
_emberMetalDebug
.
assert
(
'
You
must
call
this
.
_super
(
.
.
.
arguments
)
;
when
implementing
init
in
a
component
.
Please
update
'
+
this
+
'
to
call
this
.
_super
from
init
.
'
this
[
INIT_WAS_CALLED
]
)
;
this
.
renderer
.
componentInitAttrs
(
this
this
.
attrs
|
|
{
}
)
;
}
_Mixin
create
.
__defineNonEnumerable
=
function
(
property
)
{
this
[
property
.
name
]
=
property
.
descriptor
.
value
;
}
_Mixin
create
.
revalidate
=
function
(
)
{
this
.
renderer
.
revalidateTopLevelView
(
this
)
;
this
.
scheduledRevalidation
=
false
;
}
_Mixin
create
.
scheduleRevalidate
=
function
(
node
label
manualRerender
)
{
if
(
node
&
&
!
this
.
_dispatching
&
&
this
.
env
.
renderedNodes
.
has
(
node
)
)
{
if
(
manualRerender
)
{
_emberMetalDebug
.
deprecate
(
'
You
manually
rerendered
'
+
label
+
'
(
a
parent
component
)
from
a
child
component
during
the
rendering
process
.
This
rarely
worked
in
Ember
1
.
x
and
will
be
removed
in
Ember
3
.
0
'
false
{
id
:
'
ember
-
views
.
manual
-
parent
-
rerender
'
until
:
'
3
.
0
.
0
'
}
)
;
}
else
{
_emberMetalDebug
.
deprecate
(
'
You
modified
'
+
label
+
'
twice
in
a
single
render
.
This
was
unreliable
in
Ember
1
.
x
and
will
be
removed
in
Ember
3
.
0
'
false
{
id
:
'
ember
-
views
.
render
-
double
-
modify
'
until
:
'
3
.
0
.
0
'
}
)
;
}
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
render
'
this
this
.
revalidate
)
;
return
;
}
_emberMetalDebug
.
deprecate
(
'
A
property
of
'
+
this
+
'
was
modified
inside
the
'
+
this
.
_dispatching
+
'
hook
.
You
should
never
change
properties
on
components
services
or
models
during
'
+
this
.
_dispatching
+
'
because
it
causes
significant
performance
degradation
.
'
!
this
.
_dispatching
{
id
:
'
ember
-
views
.
dispatching
-
modify
-
property
'
until
:
'
3
.
0
.
0
'
}
)
;
if
(
!
this
.
scheduledRevalidation
|
|
this
.
_dispatching
)
{
this
.
scheduledRevalidation
=
true
;
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
render
'
this
this
.
revalidate
)
;
}
}
_Mixin
create
.
templateRenderer
=
null
_Mixin
create
.
removeFromParent
=
function
(
)
{
var
parent
=
this
.
parentView
;
this
.
remove
(
)
;
if
(
parent
)
{
parent
.
removeChild
(
this
)
;
}
return
this
;
}
_Mixin
create
.
destroy
=
function
(
)
{
var
parentView
=
this
.
parentView
;
var
viewName
=
this
.
viewName
;
if
(
!
this
.
_super
.
apply
(
this
arguments
)
)
{
return
;
}
if
(
viewName
&
&
parentView
)
{
parentView
.
set
(
viewName
null
)
;
}
if
(
this
.
lastResult
)
{
this
.
lastResult
.
destroy
(
)
;
}
return
this
;
}
_Mixin
create
.
handleEvent
=
function
(
eventName
evt
)
{
return
this
.
_currentState
.
handleEvent
(
this
eventName
evt
)
;
}
_Mixin
create
.
_register
=
function
(
)
{
_emberMetalDebug
.
assert
(
'
Attempted
to
register
a
view
with
an
id
already
in
use
:
'
+
this
.
elementId
!
this
.
_viewRegistry
[
this
.
elementId
]
)
;
this
.
_viewRegistry
[
this
.
elementId
]
=
this
;
}
_Mixin
create
.
_unregister
=
function
(
)
{
delete
this
.
_viewRegistry
[
this
.
elementId
]
;
}
_Mixin
create
.
registerObserver
=
function
(
root
path
target
observer
)
{
if
(
!
observer
&
&
'
function
'
=
=
=
typeof
target
)
{
observer
=
target
;
target
=
null
;
}
if
(
!
root
|
|
typeof
root
!
=
=
'
object
'
)
{
return
;
}
var
scheduledObserver
=
this
.
_wrapAsScheduled
(
observer
)
;
_emberMetalObserver
.
addObserver
(
root
path
target
scheduledObserver
)
;
this
.
one
(
'
willClearRender
'
function
(
)
{
_emberMetalObserver
.
removeObserver
(
root
path
target
scheduledObserver
)
;
}
)
;
}
_Mixin
create
.
_wrapAsScheduled
=
function
(
fn
)
{
var
view
=
this
;
var
stateCheckedFn
=
function
(
)
{
view
.
_currentState
.
invokeObserver
(
this
fn
)
;
}
;
var
scheduledFn
=
function
(
)
{
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
render
'
this
stateCheckedFn
)
;
}
;
return
scheduledFn
;
}
_Mixin
create
)
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
view_target_action_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
runtime
/
mixins
/
target_action_support
'
'
ember
-
metal
/
alias
'
]
function
(
exports
_emberMetalMixin
_emberRuntimeMixinsTarget_action_support
_emberMetalAlias
)
{
'
use
strict
'
;
exports
.
default
=
_emberMetalMixin
.
Mixin
.
create
(
_emberRuntimeMixinsTarget_action_support
.
default
{
target
:
_emberMetalAlias
.
default
(
'
controller
'
)
actionContext
:
_emberMetalAlias
.
default
(
'
context
'
)
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
mixins
/
visibility_support
'
[
'
exports
'
'
ember
-
metal
/
mixin
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
run_loop
'
]
function
(
exports
_emberMetalMixin
_emberMetalProperty_get
_emberMetalRun_loop
)
{
'
use
strict
'
;
function
K
(
)
{
return
this
;
}
var
VisibilitySupport
=
_emberMetalMixin
.
Mixin
.
create
(
{
isVisible
:
true
becameVisible
:
K
becameHidden
:
K
_isVisibleDidChange
:
_emberMetalMixin
.
observer
(
'
isVisible
'
function
(
)
{
if
(
this
.
_isVisible
=
=
=
_emberMetalProperty_get
.
get
(
this
'
isVisible
'
)
)
{
return
;
}
_emberMetalRun_loop
.
default
.
scheduleOnce
(
'
render
'
this
this
.
_toggleVisibility
)
;
}
)
_toggleVisibility
:
function
(
)
{
var
el
=
this
.
(
)
;
var
isVisible
=
_emberMetalProperty_get
.
get
(
this
'
isVisible
'
)
;
if
(
this
.
_isVisible
=
=
=
isVisible
)
{
return
;
}
this
.
_isVisible
=
isVisible
;
if
(
!
el
)
{
return
;
}
el
.
toggle
(
isVisible
)
;
if
(
this
.
_isAncestorHidden
(
)
)
{
return
;
}
if
(
isVisible
)
{
this
.
_notifyBecameVisible
(
)
;
}
else
{
this
.
_notifyBecameHidden
(
)
;
}
}
_notifyBecameVisible
:
function
(
)
{
this
.
trigger
(
'
becameVisible
'
)
;
this
.
forEachChildView
(
function
(
view
)
{
var
isVisible
=
_emberMetalProperty_get
.
get
(
view
'
isVisible
'
)
;
if
(
isVisible
|
|
isVisible
=
=
=
null
)
{
view
.
_notifyBecameVisible
(
)
;
}
}
)
;
}
_notifyBecameHidden
:
function
(
)
{
this
.
trigger
(
'
becameHidden
'
)
;
this
.
forEachChildView
(
function
(
view
)
{
var
isVisible
=
_emberMetalProperty_get
.
get
(
view
'
isVisible
'
)
;
if
(
isVisible
|
|
isVisible
=
=
=
null
)
{
view
.
_notifyBecameHidden
(
)
;
}
}
)
;
}
_isAncestorHidden
:
function
(
)
{
var
parent
=
_emberMetalProperty_get
.
get
(
this
'
parentView
'
)
;
while
(
parent
)
{
if
(
_emberMetalProperty_get
.
get
(
parent
'
isVisible
'
)
=
=
=
false
)
{
return
true
;
}
parent
=
_emberMetalProperty_get
.
get
(
parent
'
parentView
'
)
;
}
return
false
;
}
}
)
;
exports
.
default
=
VisibilitySupport
;
}
)
;
enifed
(
'
ember
-
views
/
streams
/
class_name_binding
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
utils
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
runtime
/
system
/
string
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalUtils
_emberMetalStreamsUtils
_emberRuntimeSystemString
)
{
'
use
strict
'
;
exports
.
parsePropertyPath
=
parsePropertyPath
;
exports
.
classStringForValue
=
classStringForValue
;
exports
.
streamifyClassNameBinding
=
streamifyClassNameBinding
;
function
parsePropertyPath
(
path
)
{
var
split
=
path
.
split
(
'
:
'
)
;
var
propertyPath
=
split
[
0
]
;
var
classNames
=
'
'
;
var
className
falsyClassName
;
if
(
split
.
length
>
1
)
{
className
=
split
[
1
]
;
if
(
split
.
length
=
=
=
3
)
{
falsyClassName
=
split
[
2
]
;
}
classNames
=
'
:
'
+
className
;
if
(
falsyClassName
)
{
classNames
+
=
'
:
'
+
falsyClassName
;
}
}
return
{
path
:
propertyPath
classNames
:
classNames
className
:
className
=
=
=
'
'
?
undefined
:
className
falsyClassName
:
falsyClassName
}
;
}
function
classStringForValue
(
path
val
className
falsyClassName
)
{
if
(
_emberMetalUtils
.
isArray
(
val
)
)
{
val
=
_emberMetalProperty_get
.
get
(
val
'
length
'
)
!
=
=
0
;
}
if
(
className
|
|
falsyClassName
)
{
if
(
className
&
&
!
!
val
)
{
return
className
;
}
else
if
(
falsyClassName
&
&
!
val
)
{
return
falsyClassName
;
}
else
{
return
null
;
}
}
else
if
(
val
=
=
=
true
)
{
var
parts
=
path
.
split
(
'
.
'
)
;
return
_emberRuntimeSystemString
.
dasherize
(
parts
[
parts
.
length
-
1
]
)
;
}
else
if
(
val
!
=
=
false
&
&
val
!
=
null
)
{
return
val
;
}
else
{
return
null
;
}
}
function
streamifyClassNameBinding
(
view
classNameBinding
prefix
)
{
prefix
=
prefix
|
|
'
'
;
_emberMetalDebug
.
assert
(
'
classNameBindings
must
not
have
spaces
in
them
.
Multiple
class
name
bindings
can
be
provided
as
elements
of
an
array
e
.
g
.
[
\
'
foo
\
'
\
'
:
bar
\
'
]
'
classNameBinding
.
indexOf
(
'
'
)
=
=
=
-
1
)
;
var
parsedPath
=
parsePropertyPath
(
classNameBinding
)
;
if
(
parsedPath
.
path
=
=
=
'
'
)
{
return
classStringForValue
(
parsedPath
.
path
true
parsedPath
.
className
parsedPath
.
falsyClassName
)
;
}
else
{
var
pathValue
=
view
.
getStream
(
prefix
+
parsedPath
.
path
)
;
return
_emberMetalStreamsUtils
.
chain
(
pathValue
function
(
)
{
return
classStringForValue
(
parsedPath
.
path
_emberMetalStreamsUtils
.
read
(
pathValue
)
parsedPath
.
className
parsedPath
.
falsyClassName
)
;
}
)
;
}
}
}
)
;
enifed
(
'
ember
-
views
/
streams
/
should_display
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
runtime
/
utils
'
'
ember
-
metal
/
streams
/
stream
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberRuntimeUtils
_emberMetalStreamsStream
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
shouldDisplay
;
var
ShouldDisplayStream
=
_emberMetalStreamsStream
.
default
.
extend
(
{
init
:
function
(
predicate
)
{
_emberMetalDebug
.
assert
(
'
ShouldDisplayStream
error
:
predicate
must
be
a
stream
'
_emberMetalStreamsUtils
.
isStream
(
predicate
)
)
;
var
isTruthy
=
predicate
.
get
(
'
isTruthy
'
)
;
this
.
init
(
)
;
this
.
predicate
=
predicate
;
this
.
isTruthy
=
isTruthy
;
this
.
lengthDep
=
null
;
this
.
addDependency
(
predicate
)
;
this
.
addDependency
(
isTruthy
)
;
}
compute
:
function
(
)
{
var
truthy
=
_emberMetalStreamsUtils
.
read
(
this
.
isTruthy
)
;
if
(
typeof
truthy
=
=
=
'
boolean
'
)
{
return
truthy
;
}
if
(
this
.
lengthDep
)
{
return
this
.
lengthDep
.
getValue
(
)
!
=
=
0
;
}
else
{
return
!
!
_emberMetalStreamsUtils
.
read
(
this
.
predicate
)
;
}
}
revalidate
:
function
(
)
{
if
(
_emberRuntimeUtils
.
isArray
(
_emberMetalStreamsUtils
.
read
(
this
.
predicate
)
)
)
{
if
(
!
this
.
lengthDep
)
{
this
.
lengthDep
=
this
.
addMutableDependency
(
this
.
predicate
.
get
(
'
length
'
)
)
;
}
}
else
{
if
(
this
.
lengthDep
)
{
this
.
lengthDep
.
destroy
(
)
;
this
.
lengthDep
=
null
;
}
}
}
}
)
;
function
shouldDisplay
(
predicate
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
predicate
)
)
{
return
new
ShouldDisplayStream
(
predicate
)
;
}
var
type
=
typeof
predicate
;
if
(
type
=
=
=
'
boolean
'
)
{
return
predicate
;
}
if
(
type
&
&
type
=
=
=
'
object
'
&
&
predicate
!
=
=
null
)
{
var
isTruthy
=
_emberMetalProperty_get
.
get
(
predicate
'
isTruthy
'
)
;
if
(
typeof
isTruthy
=
=
=
'
boolean
'
)
{
return
isTruthy
;
}
}
if
(
_emberRuntimeUtils
.
isArray
(
predicate
)
)
{
return
_emberMetalProperty_get
.
get
(
predicate
'
length
'
)
!
=
=
0
;
}
else
{
return
!
!
predicate
;
}
}
}
)
;
enifed
(
'
ember
-
views
/
streams
/
utils
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
streams
/
utils
'
'
ember
-
runtime
/
mixins
/
controller
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalStreamsUtils
_emberRuntimeMixinsController
)
{
'
use
strict
'
;
exports
.
readViewFactory
=
readViewFactory
;
exports
.
readComponentFactory
=
readComponentFactory
;
exports
.
readUnwrappedModel
=
readUnwrappedModel
;
function
readViewFactory
(
object
owner
)
{
var
value
=
_emberMetalStreamsUtils
.
read
(
object
)
;
var
viewClass
;
if
(
typeof
value
=
=
=
'
string
'
)
{
_emberMetalDebug
.
assert
(
'
View
requires
an
owner
to
resolve
views
not
passed
in
through
the
context
'
!
!
owner
)
;
viewClass
=
owner
.
_lookupFactory
(
'
view
:
'
+
value
)
;
}
else
{
viewClass
=
value
;
}
_emberMetalDebug
.
assert
(
value
+
'
must
be
a
subclass
or
an
instance
of
Ember
.
View
not
'
+
viewClass
(
function
(
viewClass
)
{
return
viewClass
&
&
(
viewClass
.
isViewFactory
|
|
viewClass
.
isView
|
|
viewClass
.
isComponentFactory
|
|
viewClass
.
isComponent
)
;
}
)
(
viewClass
)
)
;
return
viewClass
;
}
function
readComponentFactory
(
nameOrStream
owner
)
{
var
name
=
_emberMetalStreamsUtils
.
read
(
nameOrStream
)
;
var
componentLookup
=
owner
.
lookup
(
'
component
-
lookup
:
main
'
)
;
_emberMetalDebug
.
assert
(
'
Could
not
find
\
'
component
-
lookup
:
main
\
'
on
the
provided
container
'
+
'
which
is
necessary
for
performing
component
lookups
'
componentLookup
)
;
return
componentLookup
.
lookupFactory
(
name
owner
)
;
}
function
readUnwrappedModel
(
object
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
object
)
)
{
var
result
=
object
.
value
(
)
;
if
(
object
.
label
!
=
=
'
controller
'
)
{
while
(
_emberRuntimeMixinsController
.
default
.
detect
(
result
)
)
{
result
=
_emberMetalProperty_get
.
get
(
result
'
model
'
)
;
}
}
return
result
;
}
else
{
return
object
;
}
}
}
)
;
enifed
(
"
ember
-
views
/
system
/
action_manager
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
function
ActionManager
(
)
{
}
ActionManager
.
registeredActions
=
{
}
;
exports
.
default
=
ActionManager
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
build
-
component
-
template
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
assign
'
'
htmlbars
-
runtime
'
'
ember
-
htmlbars
/
hooks
/
get
-
value
'
'
ember
-
metal
/
streams
/
utils
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalAssign
_htmlbarsRuntime
_emberHtmlbarsHooksGetValue
_emberMetalStreamsUtils
)
{
'
use
strict
'
;
exports
.
default
=
buildComponentTemplate
;
exports
.
buildHTMLTemplate
=
buildHTMLTemplate
;
function
buildComponentTemplate
(
_ref
attrs
content
)
{
var
component
=
_ref
.
component
;
var
tagName
=
_ref
.
tagName
;
var
layout
=
_ref
.
layout
;
var
isAngleBracket
=
_ref
.
isAngleBracket
;
var
isComponentElement
=
_ref
.
isComponentElement
;
var
outerAttrs
=
_ref
.
outerAttrs
;
var
blockToRender
meta
;
if
(
component
=
=
=
undefined
)
{
component
=
null
;
}
if
(
layout
&
&
layout
.
raw
)
{
var
yieldTo
=
createContentBlocks
(
content
.
templates
content
.
scope
content
.
self
component
)
;
blockToRender
=
createLayoutBlock
(
layout
.
raw
yieldTo
content
.
self
component
attrs
)
;
meta
=
layout
.
raw
.
meta
;
}
else
if
(
content
.
templates
&
&
content
.
templates
.
default
)
{
blockToRender
=
createContentBlock
(
content
.
templates
.
default
content
.
scope
content
.
self
component
)
;
meta
=
content
.
templates
.
default
.
meta
;
}
if
(
component
&
&
!
component
.
_isAngleBracket
|
|
isComponentElement
)
{
tagName
=
tagName
|
|
tagNameFor
(
component
)
;
if
(
tagName
!
=
=
'
'
)
{
if
(
isComponentElement
)
{
attrs
=
mergeAttrs
(
attrs
outerAttrs
)
;
}
var
attributes
=
normalizeComponentAttributes
(
component
isAngleBracket
attrs
)
;
var
elementTemplate
=
_htmlbarsRuntime
.
internal
.
manualElement
(
tagName
attributes
)
;
elementTemplate
.
meta
=
meta
;
blockToRender
=
createElementBlock
(
elementTemplate
blockToRender
component
)
;
}
else
{
validateTaglessComponent
(
component
)
;
}
}
return
{
createdElement
:
!
!
tagName
block
:
blockToRender
}
;
}
function
buildHTMLTemplate
(
tagName
_attrs
content
)
{
var
attrs
=
{
}
;
for
(
var
prop
in
_attrs
)
{
var
val
=
_attrs
[
prop
]
;
if
(
typeof
val
=
=
=
'
string
'
)
{
attrs
[
prop
]
=
val
;
}
else
{
attrs
[
prop
]
=
[
'
value
'
val
]
;
}
}
var
childTemplate
=
content
.
templates
.
default
;
var
elementTemplate
=
_htmlbarsRuntime
.
internal
.
manualElement
(
tagName
attrs
childTemplate
.
isEmpty
)
;
if
(
childTemplate
.
isEmpty
)
{
return
blockFor
(
elementTemplate
{
scope
:
content
.
scope
}
)
;
}
else
{
var
blockToRender
=
blockFor
(
content
.
templates
.
default
content
)
;
return
blockFor
(
elementTemplate
{
yieldTo
:
blockToRender
scope
:
content
.
scope
}
)
;
}
}
function
mergeAttrs
(
innerAttrs
outerAttrs
)
{
var
result
=
_emberMetalAssign
.
default
(
{
}
innerAttrs
outerAttrs
)
;
if
(
innerAttrs
.
class
&
&
outerAttrs
.
class
)
{
result
.
class
=
[
'
subexpr
'
'
-
join
-
classes
'
[
[
'
value
'
innerAttrs
.
class
]
[
'
value
'
outerAttrs
.
class
]
]
[
]
]
;
}
return
result
;
}
function
blockFor
(
template
options
)
{
_emberMetalDebug
.
assert
(
'
BUG
:
Must
pass
a
template
to
blockFor
'
!
!
template
)
;
return
_htmlbarsRuntime
.
internal
.
blockFor
(
_htmlbarsRuntime
.
render
template
options
)
;
}
function
createContentBlock
(
template
scope
self
component
)
{
_emberMetalDebug
.
assert
(
'
BUG
:
buildComponentTemplate
can
take
a
scope
or
a
self
but
not
both
'
!
(
scope
&
&
self
)
)
;
return
blockFor
(
template
{
scope
:
scope
self
:
self
options
:
{
view
:
component
}
}
)
;
}
function
createContentBlocks
(
templates
scope
self
component
)
{
if
(
!
templates
)
{
return
;
}
var
output
=
{
}
;
for
(
var
name
in
templates
)
{
if
(
templates
.
hasOwnProperty
(
name
)
)
{
var
template
=
templates
[
name
]
;
if
(
template
)
{
output
[
name
]
=
createContentBlock
(
templates
[
name
]
scope
self
component
)
;
}
}
}
return
output
;
}
function
createLayoutBlock
(
template
yieldTo
self
component
attrs
)
{
return
blockFor
(
template
{
yieldTo
:
yieldTo
self
:
self
|
|
component
options
:
{
view
:
component
attrs
:
attrs
}
}
)
;
}
function
createElementBlock
(
template
yieldTo
component
)
{
return
blockFor
(
template
{
yieldTo
:
yieldTo
self
:
component
options
:
{
view
:
component
}
}
)
;
}
function
tagNameFor
(
view
)
{
var
tagName
=
view
.
tagName
;
if
(
tagName
!
=
=
null
&
&
typeof
tagName
=
=
=
'
object
'
&
&
tagName
.
isDescriptor
)
{
tagName
=
_emberMetalProperty_get
.
get
(
view
'
tagName
'
)
;
_emberMetalDebug
.
deprecate
(
'
In
the
future
using
a
computed
property
to
define
tagName
will
not
be
permitted
.
That
value
will
be
respected
but
changing
it
will
not
update
the
element
.
'
!
tagName
{
id
:
'
ember
-
views
.
computed
-
tag
-
name
'
until
:
'
2
.
0
.
0
'
}
)
;
}
if
(
tagName
=
=
=
null
|
|
tagName
=
=
=
undefined
)
{
tagName
=
view
.
_defaultTagName
|
|
'
div
'
;
}
return
tagName
;
}
function
normalizeComponentAttributes
(
component
isAngleBracket
attrs
)
{
var
normalized
=
{
}
;
var
attributeBindings
=
component
.
attributeBindings
;
var
streamBasePath
=
component
.
isComponent
?
'
'
:
'
view
.
'
;
var
i
l
;
if
(
attrs
.
id
&
&
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
id
)
)
{
normalized
.
id
=
_emberHtmlbarsHooksGetValue
.
default
(
attrs
.
id
)
;
component
.
elementId
=
normalized
.
id
;
}
else
{
normalized
.
id
=
component
.
elementId
;
}
if
(
attributeBindings
)
{
for
(
i
=
0
l
=
attributeBindings
.
length
;
i
<
l
;
i
+
+
)
{
var
attr
=
attributeBindings
[
i
]
;
var
colonIndex
=
attr
.
indexOf
(
'
:
'
)
;
var
attrName
expression
;
if
(
colonIndex
!
=
=
-
1
)
{
var
attrProperty
=
attr
.
substring
(
0
colonIndex
)
;
attrName
=
attr
.
substring
(
colonIndex
+
1
)
;
expression
=
[
'
get
'
'
'
+
streamBasePath
+
attrProperty
]
;
}
else
if
(
attrs
[
attr
]
)
{
attrName
=
attr
;
expression
=
[
'
value
'
attrs
[
attr
]
]
;
}
else
{
attrName
=
attr
;
expression
=
[
'
get
'
'
'
+
streamBasePath
+
attr
]
;
}
_emberMetalDebug
.
assert
(
'
You
cannot
use
class
as
an
attributeBinding
use
classNameBindings
instead
.
'
attrName
!
=
=
'
class
'
)
;
normalized
[
attrName
]
=
expression
;
}
}
if
(
isAngleBracket
)
{
for
(
var
prop
in
attrs
)
{
var
val
=
attrs
[
prop
]
;
if
(
!
val
)
{
continue
;
}
if
(
typeof
val
=
=
=
'
string
'
|
|
val
.
isConcat
)
{
normalized
[
prop
]
=
[
'
value
'
val
]
;
}
}
}
if
(
attrs
.
tagName
)
{
component
.
tagName
=
attrs
.
tagName
;
}
var
normalizedClass
=
normalizeClass
(
component
attrs
streamBasePath
)
;
if
(
normalizedClass
)
{
normalized
.
class
=
normalizedClass
;
}
if
(
_emberMetalProperty_get
.
get
(
component
'
isVisible
'
)
=
=
=
false
)
{
var
hiddenStyle
=
[
'
subexpr
'
'
-
html
-
safe
'
[
'
display
:
none
;
'
]
[
]
]
;
var
existingStyle
=
normalized
.
style
;
if
(
existingStyle
)
{
normalized
.
style
=
[
'
subexpr
'
'
concat
'
[
existingStyle
'
'
hiddenStyle
]
[
]
]
;
}
else
{
normalized
.
style
=
hiddenStyle
;
}
}
return
normalized
;
}
function
normalizeClass
(
component
attrs
streamBasePath
)
{
var
i
l
;
var
normalizedClass
=
[
]
;
var
classNames
=
_emberMetalProperty_get
.
get
(
component
'
classNames
'
)
;
var
classNameBindings
=
_emberMetalProperty_get
.
get
(
component
'
classNameBindings
'
)
;
if
(
attrs
.
class
)
{
if
(
_emberMetalStreamsUtils
.
isStream
(
attrs
.
class
)
)
{
normalizedClass
.
push
(
[
'
subexpr
'
'
-
normalize
-
class
'
[
[
'
value
'
attrs
.
class
.
path
]
[
'
value
'
attrs
.
class
]
]
[
]
]
)
;
}
else
{
normalizedClass
.
push
(
attrs
.
class
)
;
}
}
if
(
attrs
.
classBinding
)
{
normalizeClasses
(
attrs
.
classBinding
.
split
(
'
'
)
normalizedClass
streamBasePath
)
;
}
if
(
classNames
)
{
for
(
i
=
0
l
=
classNames
.
length
;
i
<
l
;
i
+
+
)
{
normalizedClass
.
push
(
classNames
[
i
]
)
;
}
}
if
(
classNameBindings
)
{
normalizeClasses
(
classNameBindings
normalizedClass
streamBasePath
)
;
}
if
(
normalizeClass
.
length
)
{
return
[
'
subexpr
'
'
-
join
-
classes
'
normalizedClass
[
]
]
;
}
}
function
normalizeClasses
(
classes
output
streamBasePath
)
{
var
i
l
;
for
(
i
=
0
l
=
classes
.
length
;
i
<
l
;
i
+
+
)
{
var
className
=
classes
[
i
]
;
_emberMetalDebug
.
assert
(
'
classNameBindings
must
not
have
spaces
in
them
.
Multiple
class
name
bindings
can
be
provided
as
elements
of
an
array
e
.
g
.
[
\
'
foo
\
'
\
'
:
bar
\
'
]
'
className
.
indexOf
(
'
'
)
=
=
=
-
1
)
;
var
_className
split
=
className
.
split
(
'
:
'
)
;
var
propName
=
_className
split
[
0
]
;
var
activeClass
=
_className
split
[
1
]
;
var
inactiveClass
=
_className
split
[
2
]
;
if
(
propName
=
=
=
'
'
)
{
output
.
push
(
activeClass
)
;
continue
;
}
var
prop
=
'
'
+
streamBasePath
+
propName
;
output
.
push
(
[
'
subexpr
'
'
-
normalize
-
class
'
[
[
'
value
'
propName
]
[
'
get
'
prop
]
]
[
'
activeClass
'
activeClass
'
inactiveClass
'
inactiveClass
]
]
)
;
}
}
function
validateTaglessComponent
(
component
)
{
_emberMetalDebug
.
assert
(
'
You
cannot
use
classNameBindings
on
a
tag
-
less
component
:
'
+
component
.
toString
(
)
(
function
(
)
{
var
classNameBindings
=
component
.
classNameBindings
;
return
!
classNameBindings
|
|
classNameBindings
.
length
=
=
=
0
;
}
)
(
)
)
;
}
}
)
;
enifed
(
'
ember
-
views
/
system
/
event_dispatcher
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
metal
/
is_none
'
'
ember
-
metal
/
run_loop
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
views
/
system
/
action_manager
'
'
ember
-
views
/
views
/
view
'
'
ember
-
metal
/
assign
'
'
container
/
owner
'
'
ember
-
metal
/
environment
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberMetalProperty_set
_emberMetalIs_none
_emberMetalRun_loop
_emberRuntimeSystemObject
_emberViewsSystemJquery
_emberViewsSystemAction_manager
_emberViewsViewsView
_emberMetalAssign
_containerOwner
_emberMetalEnvironment
)
{
'
use
strict
'
;
var
ROOT_ELEMENT_CLASS
=
'
ember
-
application
'
;
var
ROOT_ELEMENT_SELECTOR
=
'
.
'
+
ROOT_ELEMENT_CLASS
;
exports
.
default
=
_emberRuntimeSystemObject
.
default
.
extend
(
{
events
:
{
touchstart
:
'
touchStart
'
touchmove
:
'
touchMove
'
touchend
:
'
touchEnd
'
touchcancel
:
'
touchCancel
'
keydown
:
'
keyDown
'
keyup
:
'
keyUp
'
keypress
:
'
keyPress
'
mousedown
:
'
mouseDown
'
mouseup
:
'
mouseUp
'
contextmenu
:
'
contextMenu
'
click
:
'
click
'
dblclick
:
'
doubleClick
'
mousemove
:
'
mouseMove
'
focusin
:
'
focusIn
'
focusout
:
'
focusOut
'
mouseenter
:
'
mouseEnter
'
mouseleave
:
'
mouseLeave
'
submit
:
'
submit
'
input
:
'
input
'
change
:
'
change
'
dragstart
:
'
dragStart
'
drag
:
'
drag
'
dragenter
:
'
dragEnter
'
dragleave
:
'
dragLeave
'
dragover
:
'
dragOver
'
drop
:
'
drop
'
dragend
:
'
dragEnd
'
}
rootElement
:
'
body
'
canDispatchToEventManager
:
true
init
:
function
(
)
{
this
.
_super
(
)
;
_emberMetalDebug
.
assert
(
'
EventDispatcher
should
never
be
instantiated
in
fastboot
mode
.
Please
report
this
as
an
Ember
bug
.
'
_emberMetalEnvironment
.
default
.
hasDOM
)
;
}
setup
:
function
(
addedEvents
rootElement
)
{
var
event
;
var
events
=
this
.
_finalEvents
=
_emberMetalAssign
.
default
(
{
}
_emberMetalProperty_get
.
get
(
this
'
events
'
)
addedEvents
)
;
if
(
!
_emberMetalIs_none
.
default
(
rootElement
)
)
{
_emberMetalProperty_set
.
set
(
this
'
rootElement
'
rootElement
)
;
}
rootElement
=
_emberViewsSystemJquery
.
default
(
_emberMetalProperty_get
.
get
(
this
'
rootElement
'
)
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
use
the
same
root
element
(
'
+
(
rootElement
.
selector
|
|
rootElement
[
0
]
.
tagName
)
+
'
)
multiple
times
in
an
Ember
.
Application
'
!
rootElement
.
is
(
ROOT_ELEMENT_SELECTOR
)
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
make
a
new
Ember
.
Application
using
a
root
element
that
is
a
descendent
of
an
existing
Ember
.
Application
'
!
rootElement
.
closest
(
ROOT_ELEMENT_SELECTOR
)
.
length
)
;
_emberMetalDebug
.
assert
(
'
You
cannot
make
a
new
Ember
.
Application
using
a
root
element
that
is
an
ancestor
of
an
existing
Ember
.
Application
'
!
rootElement
.
find
(
ROOT_ELEMENT_SELECTOR
)
.
length
)
;
rootElement
.
addClass
(
ROOT_ELEMENT_CLASS
)
;
_emberMetalDebug
.
assert
(
'
Unable
to
add
\
'
'
+
ROOT_ELEMENT_CLASS
+
'
\
'
class
to
rootElement
.
Make
sure
you
set
rootElement
to
the
body
or
an
element
in
the
body
.
'
rootElement
.
is
(
ROOT_ELEMENT_SELECTOR
)
)
;
for
(
event
in
events
)
{
if
(
events
.
hasOwnProperty
(
event
)
)
{
this
.
setupHandler
(
rootElement
event
events
[
event
]
)
;
}
}
}
setupHandler
:
function
(
rootElement
event
eventName
)
{
var
self
=
this
;
var
owner
=
_containerOwner
.
getOwner
(
this
)
;
var
viewRegistry
=
owner
&
&
owner
.
lookup
(
'
-
view
-
registry
:
main
'
)
|
|
_emberViewsViewsView
.
default
.
views
;
if
(
eventName
=
=
=
null
)
{
return
;
}
rootElement
.
on
(
event
+
'
.
ember
'
'
.
ember
-
view
'
function
(
evt
triggeringManager
)
{
var
view
=
viewRegistry
[
this
.
id
]
;
var
result
=
true
;
var
manager
=
self
.
canDispatchToEventManager
?
self
.
_findNearestEventManager
(
view
eventName
)
:
null
;
if
(
manager
&
&
manager
!
=
=
triggeringManager
)
{
result
=
self
.
_dispatchEvent
(
manager
evt
eventName
view
)
;
}
else
if
(
view
)
{
result
=
self
.
_bubbleEvent
(
view
evt
eventName
)
;
}
return
result
;
}
)
;
rootElement
.
on
(
event
+
'
.
ember
'
'
[
data
-
ember
-
action
]
'
function
(
evt
)
{
var
actionId
=
_emberViewsSystemJquery
.
default
(
evt
.
currentTarget
)
.
attr
(
'
data
-
ember
-
action
'
)
;
var
actions
=
_emberViewsSystemAction_manager
.
default
.
registeredActions
[
actionId
]
;
if
(
!
actions
)
{
return
;
}
for
(
var
index
=
0
_length
=
actions
.
length
;
index
<
_length
;
index
+
+
)
{
var
action
=
actions
[
index
]
;
if
(
action
&
&
action
.
eventName
=
=
=
eventName
)
{
return
action
.
handler
(
evt
)
;
}
}
}
)
;
}
_findNearestEventManager
:
function
(
view
eventName
)
{
var
manager
=
null
;
while
(
view
)
{
manager
=
_emberMetalProperty_get
.
get
(
view
'
eventManager
'
)
;
if
(
manager
&
&
manager
[
eventName
]
)
{
break
;
}
view
=
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
;
}
return
manager
;
}
_dispatchEvent
:
function
(
object
evt
eventName
view
)
{
var
result
=
true
;
var
handler
=
object
[
eventName
]
;
if
(
typeof
handler
=
=
=
'
function
'
)
{
result
=
_emberMetalRun_loop
.
default
(
object
handler
evt
view
)
;
evt
.
stopPropagation
(
)
;
}
else
{
result
=
this
.
_bubbleEvent
(
view
evt
eventName
)
;
}
return
result
;
}
_bubbleEvent
:
function
(
view
evt
eventName
)
{
return
view
.
handleEvent
(
eventName
evt
)
;
}
destroy
:
function
(
)
{
var
rootElement
=
_emberMetalProperty_get
.
get
(
this
'
rootElement
'
)
;
_emberViewsSystemJquery
.
default
(
rootElement
)
.
off
(
'
.
ember
'
'
*
*
'
)
.
removeClass
(
ROOT_ELEMENT_CLASS
)
;
return
this
.
_super
.
apply
(
this
arguments
)
;
}
toString
:
function
(
)
{
return
'
(
EventDispatcher
)
'
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
ext
'
[
'
exports
'
'
ember
-
metal
/
run_loop
'
]
function
(
exports
_emberMetalRun_loop
)
{
'
use
strict
'
;
_emberMetalRun_loop
.
default
.
_addQueue
(
'
render
'
'
actions
'
)
;
_emberMetalRun_loop
.
default
.
_addQueue
(
'
afterRender
'
'
render
'
)
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
jquery
'
[
'
exports
'
'
ember
-
metal
/
core
'
'
ember
-
metal
/
environment
'
]
function
(
exports
_emberMetalCore
_emberMetalEnvironment
)
{
'
use
strict
'
;
var
jQuery
;
if
(
_emberMetalEnvironment
.
default
.
hasDOM
)
{
jQuery
=
_emberMetalCore
.
default
.
imports
&
&
_emberMetalCore
.
default
.
imports
.
jQuery
|
|
mainContext
&
&
mainContext
.
jQuery
;
if
(
!
jQuery
&
&
typeof
require
=
=
=
'
function
'
)
{
jQuery
=
require
(
'
jquery
'
)
;
}
if
(
jQuery
)
{
var
dragEvents
=
[
'
dragstart
'
'
drag
'
'
dragenter
'
'
dragleave
'
'
dragover
'
'
drop
'
'
dragend
'
]
;
dragEvents
.
forEach
(
function
(
eventName
)
{
jQuery
.
event
.
fixHooks
[
eventName
]
=
{
props
:
[
'
dataTransfer
'
]
}
;
}
)
;
}
}
exports
.
default
=
jQuery
;
}
)
;
enifed
(
'
ember
-
views
/
system
/
lookup_partial
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
error
'
]
function
(
exports
_emberMetalDebug
_emberMetalError
)
{
'
use
strict
'
;
exports
.
default
=
lookupPartial
;
function
lookupPartial
(
env
templateName
)
{
if
(
templateName
=
=
null
)
{
return
;
}
var
nameParts
=
templateName
.
split
(
'
/
'
)
;
var
lastPart
=
nameParts
[
nameParts
.
length
-
1
]
;
nameParts
[
nameParts
.
length
-
1
]
=
'
_
'
+
lastPart
;
var
underscoredName
=
nameParts
.
join
(
'
/
'
)
;
var
template
=
templateFor
(
env
underscoredName
templateName
)
;
_emberMetalDebug
.
assert
(
'
Unable
to
find
partial
with
name
"
'
+
templateName
+
'
"
'
!
!
template
)
;
return
template
;
}
function
templateFor
(
env
underscored
name
)
{
if
(
!
name
)
{
return
;
}
_emberMetalDebug
.
assert
(
'
templateNames
are
not
allowed
to
contain
periods
:
'
+
name
name
.
indexOf
(
'
.
'
)
=
=
=
-
1
)
;
if
(
!
env
.
owner
)
{
throw
new
_emberMetalError
.
default
(
'
Container
was
not
found
when
looking
up
a
views
template
.
'
+
'
This
is
most
likely
due
to
manually
instantiating
an
Ember
.
View
.
'
+
'
See
:
http
:
/
/
git
.
io
/
EKPpnA
'
)
;
}
return
env
.
owner
.
lookup
(
'
template
:
'
+
underscored
)
|
|
env
.
owner
.
lookup
(
'
template
:
'
+
name
)
;
}
}
)
;
enifed
(
'
ember
-
views
/
system
/
platform
'
[
'
exports
'
'
ember
-
metal
/
environment
'
]
function
(
exports
_emberMetalEnvironment
)
{
'
use
strict
'
;
var
canSetNameOnInputs
=
_emberMetalEnvironment
.
default
.
hasDOM
&
&
(
function
(
)
{
var
div
=
document
.
createElement
(
'
div
'
)
;
var
el
=
document
.
createElement
(
'
input
'
)
;
el
.
setAttribute
(
'
name
'
'
foo
'
)
;
div
.
appendChild
(
el
)
;
return
!
!
div
.
innerHTML
.
match
(
'
foo
'
)
;
}
)
(
)
;
exports
.
canSetNameOnInputs
=
canSetNameOnInputs
;
}
)
;
enifed
(
"
ember
-
views
/
system
/
utils
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
isSimpleClick
=
isSimpleClick
;
exports
.
getViewClientRects
=
getViewClientRects
;
exports
.
getViewBoundingClientRect
=
getViewBoundingClientRect
;
function
isSimpleClick
(
event
)
{
var
modifier
=
event
.
shiftKey
|
|
event
.
metaKey
|
|
event
.
altKey
|
|
event
.
ctrlKey
;
var
secondaryClick
=
event
.
which
>
1
;
return
!
modifier
&
&
!
secondaryClick
;
}
function
getViewRange
(
view
)
{
var
range
=
document
.
createRange
(
)
;
range
.
setStartBefore
(
view
.
_renderNode
.
firstNode
)
;
range
.
setEndAfter
(
view
.
_renderNode
.
lastNode
)
;
return
range
;
}
function
getViewClientRects
(
view
)
{
var
range
=
getViewRange
(
view
)
;
return
range
.
getClientRects
(
)
;
}
function
getViewBoundingClientRect
(
view
)
{
var
range
=
getViewRange
(
view
)
;
return
range
.
getBoundingClientRect
(
)
;
}
}
)
;
enifed
(
'
ember
-
views
/
views
/
checkbox
'
[
'
exports
'
'
ember
-
metal
/
property_get
'
'
ember
-
metal
/
property_set
'
'
ember
-
views
/
components
/
component
'
]
function
(
exports
_emberMetalProperty_get
_emberMetalProperty_set
_emberViewsComponentsComponent
)
{
'
use
strict
'
;
exports
.
default
=
_emberViewsComponentsComponent
.
default
.
extend
(
{
instrumentDisplay
:
'
{
{
input
type
=
"
checkbox
"
}
}
'
classNames
:
[
'
ember
-
checkbox
'
]
tagName
:
'
input
'
attributeBindings
:
[
'
type
'
'
checked
'
'
indeterminate
'
'
disabled
'
'
tabindex
'
'
name
'
'
autofocus
'
'
required
'
'
form
'
]
type
:
'
checkbox
'
checked
:
false
disabled
:
false
indeterminate
:
false
didInsertElement
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
_emberMetalProperty_get
.
get
(
this
'
element
'
)
.
indeterminate
=
!
!
_emberMetalProperty_get
.
get
(
this
'
indeterminate
'
)
;
}
change
:
function
(
)
{
_emberMetalProperty_set
.
set
(
this
'
checked
'
this
.
(
)
.
prop
(
'
checked
'
)
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
core_view
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
property_get
'
'
ember
-
runtime
/
system
/
object
'
'
ember
-
runtime
/
mixins
/
evented
'
'
ember
-
runtime
/
mixins
/
action_handler
'
'
ember
-
runtime
/
utils
'
'
ember
-
metal
-
views
'
'
ember
-
views
/
views
/
states
'
'
htmlbars
-
runtime
'
'
require
'
]
function
(
exports
_emberMetalDebug
_emberMetalProperty_get
_emberRuntimeSystemObject
_emberRuntimeMixinsEvented
_emberRuntimeMixinsAction_handler
_emberRuntimeUtils
_emberMetalViews
_emberViewsViewsStates
_htmlbarsRuntime
_require
)
{
'
use
strict
'
;
var
renderer
;
var
CoreView
=
_emberRuntimeSystemObject
.
default
.
extend
(
_emberRuntimeMixinsEvented
.
default
_emberRuntimeMixinsAction_handler
.
default
{
isView
:
true
_states
:
_emberViewsViewsStates
.
cloneStates
(
_emberViewsViewsStates
.
states
)
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
_state
=
'
preRender
'
;
this
.
_currentState
=
this
.
_states
.
preRender
;
this
.
_isVisible
=
_emberMetalProperty_get
.
get
(
this
'
isVisible
'
)
;
if
(
!
this
.
renderer
)
{
var
DOMHelper
=
domHelper
(
)
;
renderer
=
renderer
|
|
_emberMetalViews
.
InteractiveRenderer
.
create
(
{
dom
:
new
DOMHelper
(
)
}
)
;
this
.
renderer
=
renderer
;
}
this
.
_destroyingSubtreeForView
=
null
;
this
.
_dispatching
=
null
;
}
parentView
:
null
instrumentName
:
'
core_view
'
instrumentDetails
:
function
(
hash
)
{
hash
.
object
=
this
.
toString
(
)
;
hash
.
containerKey
=
this
.
_debugContainerKey
;
hash
.
view
=
this
;
}
trigger
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
var
name
=
arguments
[
0
]
;
var
method
=
this
[
name
]
;
if
(
method
)
{
var
length
=
arguments
.
length
;
var
args
=
new
Array
(
length
-
1
)
;
for
(
var
i
=
1
;
i
<
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
return
method
.
apply
(
this
args
)
;
}
}
has
:
function
(
name
)
{
return
_emberRuntimeUtils
.
typeOf
(
this
[
name
]
)
=
=
=
'
function
'
|
|
this
.
_super
(
name
)
;
}
destroy
:
function
(
)
{
if
(
!
this
.
_super
.
apply
(
this
arguments
)
)
{
return
;
}
this
.
_currentState
.
cleanup
(
this
)
;
if
(
!
this
.
ownerView
.
_destroyingSubtreeForView
&
&
this
.
_renderNode
)
{
_emberMetalDebug
.
assert
(
'
BUG
:
Render
node
exists
without
concomitant
env
.
'
this
.
ownerView
.
env
)
;
_htmlbarsRuntime
.
internal
.
clearMorph
(
this
.
_renderNode
this
.
ownerView
.
env
true
)
;
}
return
this
;
}
}
)
;
_emberRuntimeMixinsAction_handler
.
deprecateUnderscoreActions
(
CoreView
)
;
CoreView
.
reopenClass
(
{
isViewFactory
:
true
}
)
;
var
_domHelper
;
function
domHelper
(
)
{
return
_domHelper
=
_domHelper
|
|
_require
.
default
(
'
ember
-
htmlbars
/
system
/
dom
-
helper
'
)
.
default
;
}
exports
.
default
=
CoreView
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
views
/
views
/
states
/
default
'
'
ember
-
views
/
views
/
states
/
pre_render
'
'
ember
-
views
/
views
/
states
/
has_element
'
'
ember
-
views
/
views
/
states
/
in_dom
'
'
ember
-
views
/
views
/
states
/
destroying
'
]
function
(
exports
_emberMetalAssign
_emberViewsViewsStatesDefault
_emberViewsViewsStatesPre_render
_emberViewsViewsStatesHas_element
_emberViewsViewsStatesIn_dom
_emberViewsViewsStatesDestroying
)
{
'
use
strict
'
;
exports
.
cloneStates
=
cloneStates
;
function
cloneStates
(
from
)
{
var
into
=
{
}
;
into
.
_default
=
{
}
;
into
.
preRender
=
Object
.
create
(
into
.
_default
)
;
into
.
destroying
=
Object
.
create
(
into
.
_default
)
;
into
.
hasElement
=
Object
.
create
(
into
.
_default
)
;
into
.
inDOM
=
Object
.
create
(
into
.
hasElement
)
;
for
(
var
stateName
in
from
)
{
if
(
!
from
.
hasOwnProperty
(
stateName
)
)
{
continue
;
}
_emberMetalAssign
.
default
(
into
[
stateName
]
from
[
stateName
]
)
;
}
return
into
;
}
var
states
=
{
_default
:
_emberViewsViewsStatesDefault
.
default
preRender
:
_emberViewsViewsStatesPre_render
.
default
inDOM
:
_emberViewsViewsStatesIn_dom
.
default
hasElement
:
_emberViewsViewsStatesHas_element
.
default
destroying
:
_emberViewsViewsStatesDestroying
.
default
}
;
exports
.
states
=
states
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
default
'
[
'
exports
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
property_get
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
]
function
(
exports
_emberMetalError
_emberMetalProperty_get
_emberViewsCompatAttrsProxy
)
{
'
use
strict
'
;
exports
.
default
=
{
appendChild
:
function
(
)
{
throw
new
_emberMetalError
.
default
(
'
You
can
\
'
t
use
appendChild
outside
of
the
rendering
process
'
)
;
}
:
function
(
)
{
return
undefined
;
}
getElement
:
function
(
)
{
return
null
;
}
legacyPropertyDidChange
:
function
(
view
key
)
{
var
attrs
=
view
.
attrs
;
if
(
attrs
&
&
key
in
attrs
)
{
var
possibleCell
=
attrs
[
key
]
;
if
(
possibleCell
&
&
possibleCell
[
_emberViewsCompatAttrsProxy
.
MUTABLE_CELL
]
)
{
var
value
=
_emberMetalProperty_get
.
get
(
view
key
)
;
if
(
value
=
=
=
possibleCell
.
value
)
{
return
;
}
possibleCell
.
update
(
value
)
;
}
}
}
handleEvent
:
function
(
)
{
return
true
;
}
cleanup
:
function
(
)
{
}
destroyElement
:
function
(
)
{
}
rerender
:
function
(
view
)
{
view
.
renderer
.
ensureViewNotRendering
(
view
)
;
}
invokeObserver
:
function
(
)
{
}
}
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
destroying
'
[
'
exports
'
'
ember
-
metal
/
assign
'
'
ember
-
views
/
views
/
states
/
default
'
'
ember
-
metal
/
error
'
]
function
(
exports
_emberMetalAssign
_emberViewsViewsStatesDefault
_emberMetalError
)
{
'
use
strict
'
;
var
destroying
=
Object
.
create
(
_emberViewsViewsStatesDefault
.
default
)
;
_emberMetalAssign
.
default
(
destroying
{
appendChild
:
function
(
)
{
throw
new
_emberMetalError
.
default
(
'
You
can
\
'
t
call
appendChild
on
a
view
being
destroyed
'
)
;
}
rerender
:
function
(
)
{
throw
new
_emberMetalError
.
default
(
'
You
can
\
'
t
call
rerender
on
a
view
being
destroyed
'
)
;
}
destroyElement
:
function
(
)
{
throw
new
_emberMetalError
.
default
(
'
You
can
\
'
t
call
destroyElement
on
a
view
being
destroyed
'
)
;
}
}
)
;
exports
.
default
=
destroying
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
has_element
'
[
'
exports
'
'
ember
-
views
/
views
/
states
/
default
'
'
ember
-
metal
/
assign
'
'
ember
-
views
/
system
/
jquery
'
'
ember
-
metal
/
run_loop
'
'
ember
-
metal
/
instrumentation
'
'
ember
-
metal
/
property_get
'
]
function
(
exports
_emberViewsViewsStatesDefault
_emberMetalAssign
_emberViewsSystemJquery
_emberMetalRun_loop
_emberMetalInstrumentation
_emberMetalProperty_get
)
{
'
use
strict
'
;
var
hasElement
=
Object
.
create
(
_emberViewsViewsStatesDefault
.
default
)
;
_emberMetalAssign
.
default
(
hasElement
{
:
function
(
view
sel
)
{
var
elem
=
view
.
element
;
return
sel
?
_emberViewsSystemJquery
.
default
(
sel
elem
)
:
_emberViewsSystemJquery
.
default
(
elem
)
;
}
getElement
:
function
(
view
)
{
var
parent
=
_emberMetalProperty_get
.
get
(
view
'
parentView
'
)
;
if
(
parent
)
{
parent
=
_emberMetalProperty_get
.
get
(
parent
'
element
'
)
;
}
if
(
parent
)
{
return
view
.
findElementInParentElement
(
parent
)
;
}
return
_emberViewsSystemJquery
.
default
(
'
#
'
+
_emberMetalProperty_get
.
get
(
view
'
elementId
'
)
)
[
0
]
;
}
rerender
:
function
(
view
)
{
view
.
renderer
.
ensureViewNotRendering
(
view
)
;
view
.
renderer
.
rerender
(
view
)
;
}
cleanup
:
function
(
view
)
{
view
.
_currentState
.
destroyElement
(
view
)
;
}
destroyElement
:
function
(
view
)
{
view
.
renderer
.
remove
(
view
false
)
;
return
view
;
}
handleEvent
:
function
(
view
eventName
event
)
{
if
(
view
.
has
(
eventName
)
)
{
return
_emberMetalInstrumentation
.
flaggedInstrument
(
'
interaction
.
'
+
eventName
{
event
:
event
view
:
view
}
function
(
)
{
return
_emberMetalRun_loop
.
default
.
join
(
view
view
.
trigger
eventName
event
)
;
}
)
;
}
else
{
return
true
;
}
}
invokeObserver
:
function
(
target
observer
)
{
observer
.
call
(
target
)
;
}
}
)
;
exports
.
default
=
hasElement
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
in_dom
'
[
'
exports
'
'
ember
-
metal
/
debug
'
'
ember
-
metal
/
assign
'
'
ember
-
metal
/
error
'
'
ember
-
metal
/
observer
'
'
ember
-
views
/
views
/
states
/
has_element
'
]
function
(
exports
_emberMetalDebug
_emberMetalAssign
_emberMetalError
_emberMetalObserver
_emberViewsViewsStatesHas_element
)
{
'
use
strict
'
;
var
inDOM
=
Object
.
create
(
_emberViewsViewsStatesHas_element
.
default
)
;
_emberMetalAssign
.
default
(
inDOM
{
enter
:
function
(
view
)
{
if
(
view
.
tagName
!
=
=
'
'
)
{
view
.
_register
(
)
;
}
_emberMetalDebug
.
runInDebug
(
function
(
)
{
_emberMetalObserver
.
_addBeforeObserver
(
view
'
elementId
'
function
(
)
{
throw
new
_emberMetalError
.
default
(
'
Changing
a
view
\
'
s
elementId
after
creation
is
not
allowed
'
)
;
}
)
;
}
)
;
}
exit
:
function
(
view
)
{
view
.
_unregister
(
)
;
}
}
)
;
exports
.
default
=
inDOM
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
states
/
pre_render
'
[
'
exports
'
'
ember
-
views
/
views
/
states
/
default
'
'
ember
-
metal
/
assign
'
]
function
(
exports
_emberViewsViewsStatesDefault
_emberMetalAssign
)
{
'
use
strict
'
;
var
preRender
=
Object
.
create
(
_emberViewsViewsStatesDefault
.
default
)
;
_emberMetalAssign
.
default
(
preRender
{
legacyPropertyDidChange
:
function
(
view
key
)
{
}
}
)
;
exports
.
default
=
preRender
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
text_area
'
[
'
exports
'
'
ember
-
views
/
components
/
component
'
'
ember
-
views
/
mixins
/
text_support
'
]
function
(
exports
_emberViewsComponentsComponent
_emberViewsMixinsText_support
)
{
'
use
strict
'
;
exports
.
default
=
_emberViewsComponentsComponent
.
default
.
extend
(
_emberViewsMixinsText_support
.
default
{
instrumentDisplay
:
'
{
{
textarea
}
}
'
classNames
:
[
'
ember
-
text
-
area
'
]
tagName
:
'
textarea
'
attributeBindings
:
[
'
rows
'
'
cols
'
'
name
'
'
selectionEnd
'
'
selectionStart
'
'
wrap
'
'
lang
'
'
dir
'
'
value
'
]
rows
:
null
cols
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
text_field
'
[
'
exports
'
'
ember
-
metal
/
computed
'
'
ember
-
metal
/
environment
'
'
ember
-
views
/
components
/
component
'
'
ember
-
views
/
mixins
/
text_support
'
'
ember
-
metal
/
empty_object
'
]
function
(
exports
_emberMetalComputed
_emberMetalEnvironment
_emberViewsComponentsComponent
_emberViewsMixinsText_support
_emberMetalEmpty_object
)
{
'
use
strict
'
;
var
inputTypeTestElement
;
var
inputTypes
=
new
_emberMetalEmpty_object
.
default
(
)
;
function
canSetTypeOfInput
(
type
)
{
if
(
type
in
inputTypes
)
{
return
inputTypes
[
type
]
;
}
if
(
!
_emberMetalEnvironment
.
default
.
hasDOM
)
{
inputTypes
[
type
]
=
type
;
return
type
;
}
if
(
!
inputTypeTestElement
)
{
inputTypeTestElement
=
document
.
createElement
(
'
input
'
)
;
}
try
{
inputTypeTestElement
.
type
=
type
;
}
catch
(
e
)
{
}
return
inputTypes
[
type
]
=
inputTypeTestElement
.
type
=
=
=
type
;
}
exports
.
default
=
_emberViewsComponentsComponent
.
default
.
extend
(
_emberViewsMixinsText_support
.
default
{
instrumentDisplay
:
'
{
{
input
type
=
"
text
"
}
}
'
classNames
:
[
'
ember
-
text
-
field
'
]
tagName
:
'
input
'
attributeBindings
:
[
'
accept
'
'
autocomplete
'
'
autosave
'
'
dir
'
'
formaction
'
'
formenctype
'
'
formmethod
'
'
formnovalidate
'
'
formtarget
'
'
height
'
'
inputmode
'
'
lang
'
'
list
'
'
max
'
'
min
'
'
multiple
'
'
name
'
'
pattern
'
'
size
'
'
step
'
'
type
'
'
value
'
'
width
'
]
defaultLayout
:
null
value
:
'
'
type
:
_emberMetalComputed
.
computed
(
{
get
:
function
(
)
{
return
'
text
'
;
}
set
:
function
(
key
value
)
{
var
type
=
'
text
'
;
if
(
canSetTypeOfInput
(
value
)
)
{
type
=
value
;
}
return
type
;
}
}
)
size
:
null
pattern
:
null
min
:
null
max
:
null
}
)
;
}
)
;
enifed
(
'
ember
-
views
/
views
/
view
'
[
'
exports
'
'
ember
-
views
/
system
/
ext
'
'
ember
-
views
/
views
/
core_view
'
'
ember
-
views
/
mixins
/
view_context_support
'
'
ember
-
views
/
mixins
/
view_child_views_support
'
'
ember
-
views
/
mixins
/
legacy_child_views_support
'
'
ember
-
views
/
mixins
/
view_state_support
'
'
ember
-
views
/
mixins
/
template_rendering_support
'
'
ember
-
views
/
mixins
/
class_names_support
'
'
ember
-
views
/
mixins
/
legacy_view_support
'
'
ember
-
views
/
mixins
/
instrumentation_support
'
'
ember
-
views
/
mixins
/
aria_role_support
'
'
ember
-
views
/
mixins
/
visibility_support
'
'
ember
-
views
/
compat
/
attrs
-
proxy
'
'
ember
-
views
/
mixins
/
view_support
'
]
function
(
exports
_emberViewsSystemExt
_emberViewsViewsCore_view
_emberViewsMixinsView_context_support
_emberViewsMixinsView_child_views_support
_emberViewsMixinsLegacy_child_views_support
_emberViewsMixinsView_state_support
_emberViewsMixinsTemplate_rendering_support
_emberViewsMixinsClass_names_support
_emberViewsMixinsLegacy_view_support
_emberViewsMixinsInstrumentation_support
_emberViewsMixinsAria_role_support
_emberViewsMixinsVisibility_support
_emberViewsCompatAttrsProxy
_emberViewsMixinsView_support
)
{
'
use
strict
'
;
var
View
=
_emberViewsViewsCore_view
.
default
.
extend
(
_emberViewsMixinsView_context_support
.
default
_emberViewsMixinsView_child_views_support
.
default
_emberViewsMixinsLegacy_child_views_support
.
default
_emberViewsMixinsView_state_support
.
default
_emberViewsMixinsTemplate_rendering_support
.
default
_emberViewsMixinsClass_names_support
.
default
_emberViewsMixinsLegacy_view_support
.
default
_emberViewsMixinsInstrumentation_support
.
default
_emberViewsMixinsVisibility_support
.
default
_emberViewsCompatAttrsProxy
.
default
_emberViewsMixinsAria_role_support
.
default
_emberViewsMixinsView_support
.
default
{
init
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
!
this
.
_viewRegistry
)
{
this
.
_viewRegistry
=
View
.
views
;
}
}
_classStringForProperty
:
function
(
parsedPath
)
{
return
View
.
_classStringForValue
(
parsedPath
.
path
parsedPath
.
stream
.
value
(
)
parsedPath
.
className
parsedPath
.
falsyClassName
)
;
}
}
)
;
View
.
reopenClass
(
{
views
:
{
}
}
)
;
exports
.
default
=
View
;
exports
.
ViewContextSupport
=
_emberViewsMixinsView_context_support
.
default
;
exports
.
ViewChildViewsSupport
=
_emberViewsMixinsView_child_views_support
.
default
;
exports
.
ViewStateSupport
=
_emberViewsMixinsView_state_support
.
default
;
exports
.
TemplateRenderingSupport
=
_emberViewsMixinsTemplate_rendering_support
.
default
;
exports
.
ClassNamesSupport
=
_emberViewsMixinsClass_names_support
.
default
;
}
)
;
enifed
(
'
ember
/
index
'
[
'
exports
'
'
ember
-
metal
'
'
ember
-
runtime
'
'
ember
-
views
'
'
ember
-
routing
'
'
ember
-
application
'
'
ember
-
extension
-
support
'
'
ember
-
htmlbars
'
'
ember
-
routing
-
htmlbars
'
'
ember
-
routing
-
views
'
'
require
'
'
ember
-
runtime
/
system
/
lazy_load
'
]
function
(
exports
_emberMetal
_emberRuntime
_emberViews
_emberRouting
_emberApplication
_emberExtensionSupport
_emberHtmlbars
_emberRoutingHtmlbars
_emberRoutingViews
_require
_emberRuntimeSystemLazy_load
)
{
'
use
strict
'
;
if
(
_require
.
has
(
'
ember
-
template
-
compiler
'
)
)
{
_require
.
default
(
'
ember
-
template
-
compiler
'
)
;
}
if
(
_require
.
has
(
'
ember
-
testing
'
)
)
{
_require
.
default
(
'
ember
-
testing
'
)
;
}
_emberRuntimeSystemLazy_load
.
runLoadHooks
(
'
Ember
'
)
;
}
)
;
enifed
(
'
htmlbars
-
runtime
'
[
'
exports
'
'
htmlbars
-
runtime
/
hooks
'
'
htmlbars
-
runtime
/
render
'
'
htmlbars
-
util
/
morph
-
utils
'
'
htmlbars
-
util
/
template
-
utils
'
]
function
(
exports
_htmlbarsRuntimeHooks
_htmlbarsRuntimeRender
_htmlbarsUtilMorphUtils
_htmlbarsUtilTemplateUtils
)
{
'
use
strict
'
;
var
internal
=
{
blockFor
:
_htmlbarsUtilTemplateUtils
.
blockFor
manualElement
:
_htmlbarsRuntimeRender
.
manualElement
hostBlock
:
_htmlbarsRuntimeHooks
.
hostBlock
continueBlock
:
_htmlbarsRuntimeHooks
.
continueBlock
hostYieldWithShadowTemplate
:
_htmlbarsRuntimeHooks
.
hostYieldWithShadowTemplate
visitChildren
:
_htmlbarsUtilMorphUtils
.
visitChildren
validateChildMorphs
:
_htmlbarsUtilMorphUtils
.
validateChildMorphs
clearMorph
:
_htmlbarsUtilTemplateUtils
.
clearMorph
}
;
exports
.
hooks
=
_htmlbarsRuntimeHooks
.
default
;
exports
.
render
=
_htmlbarsRuntimeRender
.
default
;
exports
.
internal
=
internal
;
}
)
;
enifed
(
'
htmlbars
-
runtime
/
expression
-
visitor
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
acceptParams
=
acceptParams
;
exports
.
acceptHash
=
acceptHash
;
function
acceptParams
(
nodes
env
scope
)
{
var
array
=
[
]
;
for
(
var
i
=
0
l
=
nodes
.
length
;
i
<
l
;
i
+
+
)
{
array
.
push
(
acceptExpression
(
nodes
[
i
]
env
scope
)
.
value
)
;
}
return
array
;
}
function
acceptHash
(
pairs
env
scope
)
{
var
object
=
{
}
;
for
(
var
i
=
0
l
=
pairs
.
length
;
i
<
l
;
i
+
=
2
)
{
var
key
=
pairs
[
i
]
;
var
value
=
pairs
[
i
+
1
]
;
object
[
key
]
=
acceptExpression
(
value
env
scope
)
.
value
;
}
return
object
;
}
function
acceptExpression
(
node
env
scope
)
{
var
ret
=
{
value
:
null
}
;
if
(
typeof
node
!
=
=
'
object
'
|
|
node
=
=
=
null
)
{
ret
.
value
=
node
;
}
else
{
ret
.
value
=
evaluateNode
(
node
env
scope
)
;
}
return
ret
;
}
function
evaluateNode
(
node
env
scope
)
{
switch
(
node
[
0
]
)
{
case
'
value
'
:
return
node
[
1
]
;
case
'
get
'
:
return
evaluateGet
(
node
env
scope
)
;
case
'
subexpr
'
:
return
evaluateSubexpr
(
node
env
scope
)
;
case
'
concat
'
:
return
evaluateConcat
(
node
env
scope
)
;
}
}
function
evaluateGet
(
node
env
scope
)
{
var
path
=
node
[
1
]
;
return
env
.
hooks
.
get
(
env
scope
path
)
;
}
function
evaluateSubexpr
(
node
env
scope
)
{
var
path
=
node
[
1
]
;
var
rawParams
=
node
[
2
]
;
var
rawHash
=
node
[
3
]
;
var
params
=
acceptParams
(
rawParams
env
scope
)
;
var
hash
=
acceptHash
(
rawHash
env
scope
)
;
return
env
.
hooks
.
subexpr
(
env
scope
path
params
hash
)
;
}
function
evaluateConcat
(
node
env
scope
)
{
var
rawParts
=
node
[
1
]
;
var
parts
=
acceptParams
(
rawParts
env
scope
)
;
return
env
.
hooks
.
concat
(
env
parts
)
;
}
}
)
;
enifed
(
"
htmlbars
-
runtime
/
hooks
"
[
"
exports
"
"
htmlbars
-
runtime
/
render
"
"
morph
-
range
/
morph
-
list
"
"
htmlbars
-
util
/
object
-
utils
"
"
htmlbars
-
util
/
morph
-
utils
"
"
htmlbars
-
util
/
template
-
utils
"
]
function
(
exports
_htmlbarsRuntimeRender
_morphRangeMorphList
_htmlbarsUtilObjectUtils
_htmlbarsUtilMorphUtils
_htmlbarsUtilTemplateUtils
)
{
"
use
strict
"
;
exports
.
wrap
=
wrap
;
exports
.
wrapForHelper
=
wrapForHelper
;
exports
.
createScope
=
createScope
;
exports
.
createFreshScope
=
createFreshScope
;
exports
.
bindShadowScope
=
bindShadowScope
;
exports
.
createChildScope
=
createChildScope
;
exports
.
bindSelf
=
bindSelf
;
exports
.
updateSelf
=
updateSelf
;
exports
.
bindLocal
=
bindLocal
;
exports
.
updateLocal
=
updateLocal
;
exports
.
bindBlock
=
bindBlock
;
exports
.
block
=
block
;
exports
.
continueBlock
=
continueBlock
;
exports
.
hostBlock
=
hostBlock
;
exports
.
handleRedirect
=
handleRedirect
;
exports
.
handleKeyword
=
handleKeyword
;
exports
.
linkRenderNode
=
linkRenderNode
;
exports
.
inline
=
inline
;
exports
.
keyword
=
keyword
;
exports
.
invokeHelper
=
invokeHelper
;
exports
.
classify
=
classify
;
exports
.
partial
=
partial
;
exports
.
range
=
range
;
exports
.
element
=
element
;
exports
.
attribute
=
attribute
;
exports
.
subexpr
=
subexpr
;
exports
.
get
=
get
;
exports
.
getRoot
=
getRoot
;
exports
.
getBlock
=
getBlock
;
exports
.
getChild
=
getChild
;
exports
.
getValue
=
getValue
;
exports
.
getCellOrValue
=
getCellOrValue
;
exports
.
component
=
component
;
exports
.
concat
=
concat
;
exports
.
hasHelper
=
hasHelper
;
exports
.
lookupHelper
=
lookupHelper
;
exports
.
bindScope
=
bindScope
;
exports
.
updateScope
=
updateScope
;
function
wrap
(
template
)
{
if
(
template
=
=
=
null
)
{
return
null
;
}
return
{
meta
:
template
.
meta
arity
:
template
.
arity
raw
:
template
render
:
function
(
self
env
options
blockArguments
)
{
var
scope
=
env
.
hooks
.
createFreshScope
(
)
;
var
contextualElement
=
options
&
&
options
.
contextualElement
;
var
renderOptions
=
new
_htmlbarsRuntimeRender
.
RenderOptions
(
null
self
blockArguments
contextualElement
)
;
return
_htmlbarsRuntimeRender
.
default
(
template
env
scope
renderOptions
)
;
}
}
;
}
function
wrapForHelper
(
template
env
scope
morph
renderState
visitor
)
{
if
(
!
template
)
{
return
{
}
;
}
var
yieldArgs
=
yieldTemplate
(
template
env
scope
morph
renderState
visitor
)
;
return
{
meta
:
template
.
meta
arity
:
template
.
arity
'
yield
'
:
yieldArgs
yieldItem
:
yieldItem
(
template
env
scope
morph
renderState
visitor
)
raw
:
template
render
:
function
(
self
blockArguments
)
{
yieldArgs
(
blockArguments
self
)
;
}
}
;
}
function
yieldTemplate
(
template
env
parentScope
morph
renderState
visitor
)
{
return
function
(
blockArguments
self
)
{
renderState
.
morphToClear
=
null
;
if
(
morph
.
morphList
)
{
_htmlbarsUtilTemplateUtils
.
clearMorphList
(
morph
.
morphList
morph
env
)
;
renderState
.
morphListToClear
=
null
;
}
var
scope
=
parentScope
;
if
(
morph
.
lastYielded
&
&
isStableTemplate
(
template
morph
.
lastYielded
)
)
{
return
morph
.
lastResult
.
revalidateWith
(
env
undefined
self
blockArguments
visitor
)
;
}
if
(
self
!
=
=
undefined
|
|
parentScope
=
=
=
null
|
|
template
.
arity
)
{
scope
=
env
.
hooks
.
createChildScope
(
parentScope
)
;
}
morph
.
lastYielded
=
{
self
:
self
template
:
template
shadowTemplate
:
null
}
;
var
renderOptions
=
new
_htmlbarsRuntimeRender
.
RenderOptions
(
morph
self
blockArguments
)
;
_htmlbarsRuntimeRender
.
default
(
template
env
scope
renderOptions
)
;
}
;
}
function
yieldItem
(
template
env
parentScope
morph
renderState
visitor
)
{
var
currentMorph
=
null
;
var
candidates
=
{
}
;
var
morphList
=
morph
.
morphList
;
if
(
morphList
)
{
currentMorph
=
morphList
.
firstChildMorph
;
}
function
advanceToKey
(
key
)
{
var
seek
=
currentMorph
;
while
(
seek
.
key
!
=
=
key
)
{
candidates
[
seek
.
key
]
=
seek
;
seek
=
seek
.
nextMorph
;
}
currentMorph
=
seek
.
nextMorph
;
return
seek
;
}
return
function
(
_key
blockArguments
self
)
{
if
(
typeof
_key
!
=
=
'
string
'
)
{
throw
new
Error
(
"
You
must
provide
a
string
key
when
calling
yieldItem
;
you
provided
"
+
_key
)
;
}
renderState
.
morphListToClear
=
null
;
morph
.
lastYielded
=
null
;
var
morphList
morphMap
;
if
(
!
morph
.
morphList
)
{
morph
.
morphList
=
new
_morphRangeMorphList
.
default
(
)
;
morph
.
morphMap
=
{
}
;
morph
.
setMorphList
(
morph
.
morphList
)
;
}
morphList
=
morph
.
morphList
;
morphMap
=
morph
.
morphMap
;
var
handledMorphs
=
renderState
.
handledMorphs
;
var
key
=
undefined
;
if
(
_key
in
handledMorphs
)
{
var
collisions
=
renderState
.
collisions
;
if
(
collisions
=
=
=
undefined
)
{
collisions
=
renderState
.
collisions
=
{
}
;
}
var
count
=
collisions
[
_key
]
|
0
;
collisions
[
_key
]
=
+
+
count
;
key
=
_key
+
'
-
-
z8mS2hvDW0A
-
-
'
+
count
;
}
else
{
key
=
_key
;
}
if
(
currentMorph
&
&
currentMorph
.
key
=
=
=
key
)
{
yieldTemplate
(
template
env
parentScope
currentMorph
renderState
visitor
)
(
blockArguments
self
)
;
currentMorph
=
currentMorph
.
nextMorph
;
handledMorphs
[
key
]
=
currentMorph
;
}
else
if
(
morphMap
[
key
]
!
=
=
undefined
)
{
var
foundMorph
=
morphMap
[
key
]
;
if
(
key
in
candidates
)
{
morphList
.
insertBeforeMorph
(
foundMorph
currentMorph
)
;
}
else
{
advanceToKey
(
key
)
;
}
handledMorphs
[
foundMorph
.
key
]
=
foundMorph
;
yieldTemplate
(
template
env
parentScope
foundMorph
renderState
visitor
)
(
blockArguments
self
)
;
}
else
{
var
childMorph
=
_htmlbarsRuntimeRender
.
createChildMorph
(
env
.
dom
morph
)
;
childMorph
.
key
=
key
;
morphMap
[
key
]
=
handledMorphs
[
key
]
=
childMorph
;
morphList
.
insertBeforeMorph
(
childMorph
currentMorph
)
;
yieldTemplate
(
template
env
parentScope
childMorph
renderState
visitor
)
(
blockArguments
self
)
;
}
renderState
.
morphListToPrune
=
morphList
;
morph
.
childNodes
=
null
;
}
;
}
function
isStableTemplate
(
template
lastYielded
)
{
return
!
lastYielded
.
shadowTemplate
&
&
template
=
=
=
lastYielded
.
template
;
}
function
optionsFor
(
template
inverse
env
scope
morph
visitor
)
{
var
morphToClear
=
morph
.
lastResult
?
morph
:
null
;
var
renderState
=
new
_htmlbarsUtilTemplateUtils
.
RenderState
(
morphToClear
morph
.
morphList
|
|
null
)
;
return
{
templates
:
{
template
:
wrapForHelper
(
template
env
scope
morph
renderState
visitor
)
inverse
:
wrapForHelper
(
inverse
env
scope
morph
renderState
visitor
)
}
renderState
:
renderState
}
;
}
function
thisFor
(
options
)
{
return
{
arity
:
options
.
template
.
arity
'
yield
'
:
options
.
template
.
yield
yieldItem
:
options
.
template
.
yieldItem
yieldIn
:
options
.
template
.
yieldIn
}
;
}
function
createScope
(
env
parentScope
)
{
if
(
parentScope
)
{
return
env
.
hooks
.
createChildScope
(
parentScope
)
;
}
else
{
return
env
.
hooks
.
createFreshScope
(
)
;
}
}
function
createFreshScope
(
)
{
return
{
self
:
null
blocks
:
{
}
locals
:
{
}
localPresent
:
{
}
}
;
}
function
bindShadowScope
(
env
)
{
return
env
.
hooks
.
createFreshScope
(
)
;
}
function
createChildScope
(
parent
)
{
var
scope
=
Object
.
create
(
parent
)
;
scope
.
locals
=
Object
.
create
(
parent
.
locals
)
;
scope
.
localPresent
=
Object
.
create
(
parent
.
localPresent
)
;
scope
.
blocks
=
Object
.
create
(
parent
.
blocks
)
;
return
scope
;
}
function
bindSelf
(
env
scope
self
)
{
scope
.
self
=
self
;
}
function
updateSelf
(
env
scope
self
)
{
env
.
hooks
.
bindSelf
(
env
scope
self
)
;
}
function
bindLocal
(
env
scope
name
value
)
{
scope
.
localPresent
[
name
]
=
true
;
scope
.
locals
[
name
]
=
value
;
}
function
updateLocal
(
env
scope
name
value
)
{
env
.
hooks
.
bindLocal
(
env
scope
name
value
)
;
}
function
bindBlock
(
env
scope
block
)
{
var
name
=
arguments
.
length
<
=
3
|
|
arguments
[
3
]
=
=
=
undefined
?
'
default
'
:
arguments
[
3
]
;
scope
.
blocks
[
name
]
=
block
;
}
function
block
(
morph
env
scope
path
params
hash
template
inverse
visitor
)
{
if
(
handleRedirect
(
morph
env
scope
path
params
hash
template
inverse
visitor
)
)
{
return
;
}
continueBlock
(
morph
env
scope
path
params
hash
template
inverse
visitor
)
;
}
function
continueBlock
(
morph
env
scope
path
params
hash
template
inverse
visitor
)
{
hostBlock
(
morph
env
scope
template
inverse
null
visitor
function
(
options
)
{
var
helper
=
env
.
hooks
.
lookupHelper
(
env
scope
path
)
;
return
env
.
hooks
.
invokeHelper
(
morph
env
scope
visitor
params
hash
helper
options
.
templates
thisFor
(
options
.
templates
)
)
;
}
)
;
}
function
hostBlock
(
morph
env
scope
template
inverse
shadowOptions
visitor
callback
)
{
var
options
=
optionsFor
(
template
inverse
env
scope
morph
visitor
)
;
_htmlbarsUtilTemplateUtils
.
renderAndCleanup
(
morph
env
options
shadowOptions
callback
)
;
}
function
handleRedirect
(
morph
env
scope
path
params
hash
template
inverse
visitor
)
{
if
(
!
path
)
{
return
false
;
}
var
redirect
=
env
.
hooks
.
classify
(
env
scope
path
)
;
if
(
redirect
)
{
switch
(
redirect
)
{
case
'
component
'
:
env
.
hooks
.
component
(
morph
env
scope
path
params
hash
{
default
:
template
inverse
:
inverse
}
visitor
)
;
break
;
case
'
inline
'
:
env
.
hooks
.
inline
(
morph
env
scope
path
params
hash
visitor
)
;
break
;
case
'
block
'
:
env
.
hooks
.
block
(
morph
env
scope
path
params
hash
template
inverse
visitor
)
;
break
;
default
:
throw
new
Error
(
"
Internal
HTMLBars
redirection
to
"
+
redirect
+
"
not
supported
"
)
;
}
return
true
;
}
if
(
handleKeyword
(
path
morph
env
scope
params
hash
template
inverse
visitor
)
)
{
return
true
;
}
return
false
;
}
function
handleKeyword
(
path
morph
env
scope
params
hash
template
inverse
visitor
)
{
var
keyword
=
env
.
hooks
.
keywords
[
path
]
;
if
(
!
keyword
)
{
return
false
;
}
if
(
typeof
keyword
=
=
=
'
function
'
)
{
return
keyword
(
morph
env
scope
params
hash
template
inverse
visitor
)
;
}
if
(
keyword
.
willRender
)
{
keyword
.
willRender
(
morph
env
)
;
}
var
lastState
newState
;
if
(
keyword
.
setupState
)
{
lastState
=
_htmlbarsUtilObjectUtils
.
shallowCopy
(
morph
.
getState
(
)
)
;
newState
=
morph
.
setState
(
keyword
.
setupState
(
lastState
env
scope
params
hash
)
)
;
}
if
(
keyword
.
childEnv
)
{
env
=
keyword
.
childEnv
(
morph
.
getState
(
)
env
)
;
morph
.
buildChildEnv
=
keyword
.
childEnv
;
}
var
firstTime
=
!
morph
.
rendered
;
if
(
keyword
.
isEmpty
)
{
var
isEmpty
=
keyword
.
isEmpty
(
morph
.
getState
(
)
env
scope
params
hash
)
;
if
(
isEmpty
)
{
if
(
!
firstTime
)
{
_htmlbarsUtilTemplateUtils
.
clearMorph
(
morph
env
false
)
;
}
return
true
;
}
}
if
(
firstTime
)
{
if
(
keyword
.
render
)
{
keyword
.
render
(
morph
env
scope
params
hash
template
inverse
visitor
)
;
}
morph
.
rendered
=
true
;
return
true
;
}
var
isStable
;
if
(
keyword
.
isStable
)
{
isStable
=
keyword
.
isStable
(
lastState
newState
)
;
}
else
{
isStable
=
stableState
(
lastState
newState
)
;
}
if
(
isStable
)
{
if
(
keyword
.
rerender
)
{
var
newEnv
=
keyword
.
rerender
(
morph
env
scope
params
hash
template
inverse
visitor
)
;
env
=
newEnv
|
|
env
;
}
_htmlbarsUtilMorphUtils
.
validateChildMorphs
(
env
morph
visitor
)
;
return
true
;
}
else
{
_htmlbarsUtilTemplateUtils
.
clearMorph
(
morph
env
false
)
;
}
if
(
keyword
.
render
)
{
keyword
.
render
(
morph
env
scope
params
hash
template
inverse
visitor
)
;
morph
.
rendered
=
true
;
return
true
;
}
}
function
stableState
(
oldState
newState
)
{
if
(
_htmlbarsUtilObjectUtils
.
keyLength
(
oldState
)
!
=
=
_htmlbarsUtilObjectUtils
.
keyLength
(
newState
)
)
{
return
false
;
}
for
(
var
prop
in
oldState
)
{
if
(
oldState
[
prop
]
!
=
=
newState
[
prop
]
)
{
return
false
;
}
}
return
true
;
}
function
linkRenderNode
(
)
{
return
;
}
function
inline
(
morph
env
scope
path
params
hash
visitor
)
{
if
(
handleRedirect
(
morph
env
scope
path
params
hash
null
null
visitor
)
)
{
return
;
}
var
value
=
undefined
hasValue
=
undefined
;
if
(
morph
.
linkedResult
)
{
value
=
env
.
hooks
.
getValue
(
morph
.
linkedResult
)
;
hasValue
=
true
;
}
else
{
var
options
=
optionsFor
(
null
null
env
scope
morph
)
;
var
helper
=
env
.
hooks
.
lookupHelper
(
env
scope
path
)
;
var
result
=
env
.
hooks
.
invokeHelper
(
morph
env
scope
visitor
params
hash
helper
options
.
templates
thisFor
(
options
.
templates
)
)
;
if
(
result
&
&
result
.
link
)
{
morph
.
linkedResult
=
result
.
value
;
_htmlbarsUtilMorphUtils
.
linkParams
(
env
scope
morph
'
content
-
helper
'
[
morph
.
linkedResult
]
null
)
;
}
if
(
result
&
&
'
value
'
in
result
)
{
value
=
env
.
hooks
.
getValue
(
result
.
value
)
;
hasValue
=
true
;
}
}
if
(
hasValue
)
{
if
(
morph
.
lastValue
!
=
=
value
)
{
morph
.
setContent
(
value
)
;
}
morph
.
lastValue
=
value
;
}
}
function
keyword
(
path
morph
env
scope
params
hash
template
inverse
visitor
)
{
handleKeyword
(
path
morph
env
scope
params
hash
template
inverse
visitor
)
;
}
function
invokeHelper
(
morph
env
scope
visitor
_params
_hash
helper
templates
context
)
{
var
params
=
normalizeArray
(
env
_params
)
;
var
hash
=
normalizeObject
(
env
_hash
)
;
return
{
value
:
helper
.
call
(
context
params
hash
templates
)
}
;
}
function
normalizeArray
(
env
array
)
{
var
out
=
new
Array
(
array
.
length
)
;
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
out
[
i
]
=
env
.
hooks
.
getCellOrValue
(
array
[
i
]
)
;
}
return
out
;
}
function
normalizeObject
(
env
object
)
{
var
out
=
{
}
;
for
(
var
prop
in
object
)
{
out
[
prop
]
=
env
.
hooks
.
getCellOrValue
(
object
[
prop
]
)
;
}
return
out
;
}
function
classify
(
)
{
return
null
;
}
var
keywords
=
{
partial
:
function
(
morph
env
scope
params
)
{
var
value
=
env
.
hooks
.
partial
(
morph
env
scope
params
[
0
]
)
;
morph
.
setContent
(
value
)
;
return
true
;
}
'
yield
'
:
function
(
morph
env
scope
params
hash
template
inverse
visitor
)
{
var
to
=
env
.
hooks
.
getValue
(
hash
.
to
)
|
|
'
default
'
;
var
block
=
env
.
hooks
.
getBlock
(
scope
to
)
;
if
(
block
)
{
block
.
invoke
(
env
params
hash
.
self
morph
scope
visitor
)
;
}
return
true
;
}
hasBlock
:
function
(
morph
env
scope
params
)
{
var
name
=
env
.
hooks
.
getValue
(
params
[
0
]
)
|
|
'
default
'
;
return
!
!
env
.
hooks
.
getBlock
(
scope
name
)
;
}
hasBlockParams
:
function
(
morph
env
scope
params
)
{
var
name
=
env
.
hooks
.
getValue
(
params
[
0
]
)
|
|
'
default
'
;
var
block
=
env
.
hooks
.
getBlock
(
scope
name
)
;
return
!
!
(
block
&
&
block
.
arity
)
;
}
}
;
exports
.
keywords
=
keywords
;
function
partial
(
renderNode
env
scope
path
)
{
var
template
=
env
.
partials
[
path
]
;
return
template
.
render
(
scope
.
self
env
{
}
)
.
fragment
;
}
function
range
(
morph
env
scope
path
value
visitor
)
{
if
(
handleRedirect
(
morph
env
scope
path
[
]
{
}
null
null
visitor
)
)
{
return
;
}
value
=
env
.
hooks
.
getValue
(
value
)
;
if
(
morph
.
lastValue
!
=
=
value
)
{
morph
.
setContent
(
value
)
;
}
morph
.
lastValue
=
value
;
}
function
element
(
morph
env
scope
path
params
hash
visitor
)
{
if
(
handleRedirect
(
morph
env
scope
path
params
hash
null
null
visitor
)
)
{
return
;
}
var
helper
=
env
.
hooks
.
lookupHelper
(
env
scope
path
)
;
if
(
helper
)
{
env
.
hooks
.
invokeHelper
(
null
env
scope
null
params
hash
helper
{
element
:
morph
.
element
}
)
;
}
}
function
attribute
(
morph
env
scope
name
value
)
{
value
=
env
.
hooks
.
getValue
(
value
)
;
if
(
morph
.
lastValue
!
=
=
value
)
{
morph
.
setContent
(
value
)
;
}
morph
.
lastValue
=
value
;
}
function
subexpr
(
env
scope
helperName
params
hash
)
{
var
helper
=
env
.
hooks
.
lookupHelper
(
env
scope
helperName
)
;
var
result
=
env
.
hooks
.
invokeHelper
(
null
env
scope
null
params
hash
helper
{
}
)
;
if
(
result
&
&
'
value
'
in
result
)
{
return
env
.
hooks
.
getValue
(
result
.
value
)
;
}
}
function
get
(
env
scope
path
)
{
if
(
path
=
=
=
'
'
)
{
return
scope
.
self
;
}
var
keys
=
path
.
split
(
'
.
'
)
;
var
value
=
env
.
hooks
.
getRoot
(
scope
keys
[
0
]
)
[
0
]
;
for
(
var
i
=
1
;
i
<
keys
.
length
;
i
+
+
)
{
if
(
value
)
{
value
=
env
.
hooks
.
getChild
(
value
keys
[
i
]
)
;
}
else
{
break
;
}
}
return
value
;
}
function
getRoot
(
scope
key
)
{
if
(
scope
.
localPresent
[
key
]
)
{
return
[
scope
.
locals
[
key
]
]
;
}
else
if
(
scope
.
self
)
{
return
[
scope
.
self
[
key
]
]
;
}
else
{
return
[
undefined
]
;
}
}
function
getBlock
(
scope
key
)
{
return
scope
.
blocks
[
key
]
;
}
function
getChild
(
value
key
)
{
return
value
[
key
]
;
}
function
getValue
(
reference
)
{
return
reference
;
}
function
getCellOrValue
(
reference
)
{
return
reference
;
}
function
component
(
morph
env
scope
tagName
params
attrs
templates
visitor
)
{
if
(
env
.
hooks
.
hasHelper
(
env
scope
tagName
)
)
{
return
env
.
hooks
.
block
(
morph
env
scope
tagName
params
attrs
templates
.
default
templates
.
inverse
visitor
)
;
}
componentFallback
(
morph
env
scope
tagName
attrs
templates
.
default
)
;
}
function
concat
(
env
params
)
{
var
value
=
"
"
;
for
(
var
i
=
0
l
=
params
.
length
;
i
<
l
;
i
+
+
)
{
value
+
=
env
.
hooks
.
getValue
(
params
[
i
]
)
;
}
return
value
;
}
function
componentFallback
(
morph
env
scope
tagName
attrs
template
)
{
var
element
=
env
.
dom
.
createElement
(
tagName
)
;
for
(
var
name
in
attrs
)
{
element
.
setAttribute
(
name
env
.
hooks
.
getValue
(
attrs
[
name
]
)
)
;
}
var
fragment
=
_htmlbarsRuntimeRender
.
default
(
template
env
scope
{
}
)
.
fragment
;
element
.
appendChild
(
fragment
)
;
morph
.
setNode
(
element
)
;
}
function
hasHelper
(
env
scope
helperName
)
{
return
env
.
helpers
[
helperName
]
!
=
=
undefined
;
}
function
lookupHelper
(
env
scope
helperName
)
{
return
env
.
helpers
[
helperName
]
;
}
function
bindScope
(
)
{
}
function
updateScope
(
env
scope
)
{
env
.
hooks
.
bindScope
(
env
scope
)
;
}
exports
.
default
=
{
bindLocal
:
bindLocal
bindSelf
:
bindSelf
bindScope
:
bindScope
classify
:
classify
component
:
component
concat
:
concat
createFreshScope
:
createFreshScope
getChild
:
getChild
getRoot
:
getRoot
getBlock
:
getBlock
getValue
:
getValue
getCellOrValue
:
getCellOrValue
keywords
:
keywords
linkRenderNode
:
linkRenderNode
partial
:
partial
subexpr
:
subexpr
bindBlock
:
bindBlock
bindShadowScope
:
bindShadowScope
updateLocal
:
updateLocal
updateSelf
:
updateSelf
updateScope
:
updateScope
createChildScope
:
createChildScope
hasHelper
:
hasHelper
lookupHelper
:
lookupHelper
invokeHelper
:
invokeHelper
cleanupRenderNode
:
null
destroyRenderNode
:
null
willCleanupTree
:
null
didCleanupTree
:
null
willRenderNode
:
null
didRenderNode
:
null
attribute
:
attribute
block
:
block
createScope
:
createScope
element
:
element
get
:
get
inline
:
inline
range
:
range
keyword
:
keyword
}
;
}
)
;
enifed
(
"
htmlbars
-
runtime
/
morph
"
[
"
exports
"
"
morph
-
range
"
]
function
(
exports
_morphRange
)
{
"
use
strict
"
;
var
guid
=
1
;
function
HTMLBarsMorph
(
domHelper
contextualElement
)
{
this
.
super
constructor
(
domHelper
contextualElement
)
;
this
.
_state
=
undefined
;
this
.
ownerNode
=
null
;
this
.
isDirty
=
false
;
this
.
isSubtreeDirty
=
false
;
this
.
lastYielded
=
null
;
this
.
lastResult
=
null
;
this
.
lastValue
=
null
;
this
.
buildChildEnv
=
null
;
this
.
morphList
=
null
;
this
.
morphMap
=
null
;
this
.
key
=
null
;
this
.
linkedParams
=
null
;
this
.
linkedResult
=
null
;
this
.
childNodes
=
null
;
this
.
rendered
=
false
;
this
.
guid
=
"
range
"
+
guid
+
+
;
this
.
seen
=
false
;
}
HTMLBarsMorph
.
empty
=
function
(
domHelper
contextualElement
)
{
var
morph
=
new
HTMLBarsMorph
(
domHelper
contextualElement
)
;
morph
.
clear
(
)
;
return
morph
;
}
;
HTMLBarsMorph
.
create
=
function
(
domHelper
contextualElement
node
)
{
var
morph
=
new
HTMLBarsMorph
(
domHelper
contextualElement
)
;
morph
.
setNode
(
node
)
;
return
morph
;
}
;
HTMLBarsMorph
.
attach
=
function
(
domHelper
contextualElement
firstNode
lastNode
)
{
var
morph
=
new
HTMLBarsMorph
(
domHelper
contextualElement
)
;
morph
.
setRange
(
firstNode
lastNode
)
;
return
morph
;
}
;
var
prototype
=
HTMLBarsMorph
.
prototype
=
Object
.
create
(
_morphRange
.
default
.
prototype
)
;
prototype
.
constructor
=
HTMLBarsMorph
;
prototype
.
super
constructor
=
_morphRange
.
default
;
prototype
.
getState
=
function
(
)
{
if
(
!
this
.
_state
)
{
this
.
_state
=
{
}
;
}
return
this
.
_state
;
}
;
prototype
.
setState
=
function
(
newState
)
{
return
this
.
_state
=
newState
;
}
;
exports
.
default
=
HTMLBarsMorph
;
}
)
;
enifed
(
"
htmlbars
-
runtime
/
node
-
visitor
"
[
"
exports
"
"
htmlbars
-
util
/
morph
-
utils
"
"
htmlbars
-
runtime
/
expression
-
visitor
"
]
function
(
exports
_htmlbarsUtilMorphUtils
_htmlbarsRuntimeExpressionVisitor
)
{
"
use
strict
"
;
function
linkParamsAndHash
(
env
scope
morph
path
params
hash
)
{
if
(
morph
.
linkedParams
)
{
params
=
morph
.
linkedParams
.
params
;
hash
=
morph
.
linkedParams
.
hash
;
}
else
{
params
=
params
&
&
_htmlbarsRuntimeExpressionVisitor
.
acceptParams
(
params
env
scope
)
;
hash
=
hash
&
&
_htmlbarsRuntimeExpressionVisitor
.
acceptHash
(
hash
env
scope
)
;
}
_htmlbarsUtilMorphUtils
.
linkParams
(
env
scope
morph
path
params
hash
)
;
return
[
params
hash
]
;
}
var
AlwaysDirtyVisitor
=
{
block
:
function
(
node
morph
env
scope
template
visitor
)
{
var
path
=
node
[
1
]
;
var
params
=
node
[
2
]
;
var
hash
=
node
[
3
]
;
var
templateId
=
node
[
4
]
;
var
inverseId
=
node
[
5
]
;
var
paramsAndHash
=
linkParamsAndHash
(
env
scope
morph
path
params
hash
)
;
morph
.
isDirty
=
morph
.
isSubtreeDirty
=
false
;
env
.
hooks
.
block
(
morph
env
scope
path
paramsAndHash
[
0
]
paramsAndHash
[
1
]
templateId
=
=
=
null
?
null
:
template
.
templates
[
templateId
]
inverseId
=
=
=
null
?
null
:
template
.
templates
[
inverseId
]
visitor
)
;
}
inline
:
function
(
node
morph
env
scope
visitor
)
{
var
path
=
node
[
1
]
;
var
params
=
node
[
2
]
;
var
hash
=
node
[
3
]
;
var
paramsAndHash
=
linkParamsAndHash
(
env
scope
morph
path
params
hash
)
;
morph
.
isDirty
=
morph
.
isSubtreeDirty
=
false
;
env
.
hooks
.
inline
(
morph
env
scope
path
paramsAndHash
[
0
]
paramsAndHash
[
1
]
visitor
)
;
}
content
:
function
(
node
morph
env
scope
visitor
)
{
var
path
=
node
[
1
]
;
morph
.
isDirty
=
morph
.
isSubtreeDirty
=
false
;
if
(
isHelper
(
env
scope
path
)
)
{
env
.
hooks
.
inline
(
morph
env
scope
path
[
]
{
}
visitor
)
;
if
(
morph
.
linkedResult
)
{
_htmlbarsUtilMorphUtils
.
linkParams
(
env
scope
morph
'
content
-
helper
'
[
morph
.
linkedResult
]
null
)
;
}
return
;
}
var
params
=
undefined
;
if
(
morph
.
linkedParams
)
{
params
=
morph
.
linkedParams
.
params
;
}
else
{
params
=
[
env
.
hooks
.
get
(
env
scope
path
)
]
;
}
_htmlbarsUtilMorphUtils
.
linkParams
(
env
scope
morph
'
range
'
params
null
)
;
env
.
hooks
.
range
(
morph
env
scope
path
params
[
0
]
visitor
)
;
}
element
:
function
(
node
morph
env
scope
visitor
)
{
var
path
=
node
[
1
]
;
var
params
=
node
[
2
]
;
var
hash
=
node
[
3
]
;
var
paramsAndHash
=
linkParamsAndHash
(
env
scope
morph
path
params
hash
)
;
morph
.
isDirty
=
morph
.
isSubtreeDirty
=
false
;
env
.
hooks
.
element
(
morph
env
scope
path
paramsAndHash
[
0
]
paramsAndHash
[
1
]
visitor
)
;
}
attribute
:
function
(
node
morph
env
scope
)
{
var
name
=
node
[
1
]
;
var
value
=
node
[
2
]
;
var
paramsAndHash
=
linkParamsAndHash
(
env
scope
morph
'
attribute
'
[
value
]
null
)
;
morph
.
isDirty
=
morph
.
isSubtreeDirty
=
false
;
env
.
hooks
.
attribute
(
morph
env
scope
name
paramsAndHash
[
0
]
[
0
]
)
;
}
component
:
function
(
node
morph
env
scope
template
visitor
)
{
var
path
=
node
[
1
]
;
var
attrs
=
node
[
2
]
;
var
templateId
=
node
[
3
]
;
var
inverseId
=
node
[
4
]
;
var
paramsAndHash
=
linkParamsAndHash
(
env
scope
morph
path
[
]
attrs
)
;
var
templates
=
{
default
:
template
.
templates
[
templateId
]
inverse
:
template
.
templates
[
inverseId
]
}
;
morph
.
isDirty
=
morph
.
isSubtreeDirty
=
false
;
env
.
hooks
.
component
(
morph
env
scope
path
paramsAndHash
[
0
]
paramsAndHash
[
1
]
templates
visitor
)
;
}
attributes
:
function
(
node
morph
env
scope
parentMorph
visitor
)
{
var
template
=
node
[
1
]
;
env
.
hooks
.
attributes
(
morph
env
scope
template
parentMorph
visitor
)
;
}
}
;
exports
.
AlwaysDirtyVisitor
=
AlwaysDirtyVisitor
;
exports
.
default
=
{
block
:
function
(
node
morph
env
scope
template
visitor
)
{
dirtyCheck
(
env
morph
visitor
function
(
visitor
)
{
AlwaysDirtyVisitor
.
block
(
node
morph
env
scope
template
visitor
)
;
}
)
;
}
inline
:
function
(
node
morph
env
scope
visitor
)
{
dirtyCheck
(
env
morph
visitor
function
(
visitor
)
{
AlwaysDirtyVisitor
.
inline
(
node
morph
env
scope
visitor
)
;
}
)
;
}
content
:
function
(
node
morph
env
scope
visitor
)
{
dirtyCheck
(
env
morph
visitor
function
(
visitor
)
{
AlwaysDirtyVisitor
.
content
(
node
morph
env
scope
visitor
)
;
}
)
;
}
element
:
function
(
node
morph
env
scope
template
visitor
)
{
dirtyCheck
(
env
morph
visitor
function
(
visitor
)
{
AlwaysDirtyVisitor
.
element
(
node
morph
env
scope
template
visitor
)
;
}
)
;
}
attribute
:
function
(
node
morph
env
scope
template
)
{
dirtyCheck
(
env
morph
null
function
(
)
{
AlwaysDirtyVisitor
.
attribute
(
node
morph
env
scope
template
)
;
}
)
;
}
component
:
function
(
node
morph
env
scope
template
visitor
)
{
dirtyCheck
(
env
morph
visitor
function
(
visitor
)
{
AlwaysDirtyVisitor
.
component
(
node
morph
env
scope
template
visitor
)
;
}
)
;
}
attributes
:
function
(
node
morph
env
scope
parentMorph
visitor
)
{
AlwaysDirtyVisitor
.
attributes
(
node
morph
env
scope
parentMorph
visitor
)
;
}
}
;
function
dirtyCheck
(
_env
morph
visitor
callback
)
{
var
isDirty
=
morph
.
isDirty
;
var
isSubtreeDirty
=
morph
.
isSubtreeDirty
;
var
env
=
_env
;
if
(
isSubtreeDirty
)
{
visitor
=
AlwaysDirtyVisitor
;
}
if
(
isDirty
|
|
isSubtreeDirty
)
{
callback
(
visitor
)
;
}
else
{
if
(
morph
.
buildChildEnv
)
{
env
=
morph
.
buildChildEnv
(
morph
.
getState
(
)
env
)
;
}
_htmlbarsUtilMorphUtils
.
validateChildMorphs
(
env
morph
visitor
)
;
}
}
function
isHelper
(
env
scope
path
)
{
return
env
.
hooks
.
keywords
[
path
]
!
=
=
undefined
|
|
env
.
hooks
.
hasHelper
(
env
scope
path
)
;
}
}
)
;
enifed
(
"
htmlbars
-
runtime
/
render
"
[
"
exports
"
"
htmlbars
-
util
/
morph
-
utils
"
"
htmlbars
-
runtime
/
node
-
visitor
"
"
htmlbars
-
runtime
/
morph
"
"
htmlbars
-
util
/
template
-
utils
"
"
htmlbars
-
util
/
void
-
tag
-
names
"
]
function
(
exports
_htmlbarsUtilMorphUtils
_htmlbarsRuntimeNodeVisitor
_htmlbarsRuntimeMorph
_htmlbarsUtilTemplateUtils
_htmlbarsUtilVoidTagNames
)
{
"
use
strict
"
;
exports
.
default
=
render
;
exports
.
RenderOptions
=
RenderOptions
;
exports
.
manualElement
=
manualElement
;
exports
.
attachAttributes
=
attachAttributes
;
exports
.
createChildMorph
=
createChildMorph
;
exports
.
getCachedFragment
=
getCachedFragment
;
var
svgNamespace
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
function
render
(
template
env
scope
options
)
{
var
dom
=
env
.
dom
;
var
contextualElement
;
if
(
options
)
{
if
(
options
.
renderNode
)
{
contextualElement
=
options
.
renderNode
.
contextualElement
;
}
else
if
(
options
.
contextualElement
)
{
contextualElement
=
options
.
contextualElement
;
}
}
dom
.
detectNamespace
(
contextualElement
)
;
var
renderResult
=
RenderResult
.
build
(
env
scope
template
options
contextualElement
)
;
renderResult
.
render
(
)
;
return
renderResult
;
}
function
RenderOptions
(
renderNode
self
blockArguments
contextualElement
)
{
this
.
renderNode
=
renderNode
|
|
null
;
this
.
self
=
self
;
this
.
blockArguments
=
blockArguments
|
|
null
;
this
.
contextualElement
=
contextualElement
|
|
null
;
}
function
RenderResult
(
env
scope
options
rootNode
ownerNode
nodes
fragment
template
shouldSetContent
)
{
this
.
root
=
rootNode
;
this
.
fragment
=
fragment
;
this
.
nodes
=
nodes
;
this
.
template
=
template
;
this
.
statements
=
template
.
statements
.
slice
(
)
;
this
.
env
=
env
;
this
.
scope
=
scope
;
this
.
shouldSetContent
=
shouldSetContent
;
if
(
options
.
self
!
=
=
undefined
)
{
this
.
bindSelf
(
options
.
self
)
;
}
if
(
options
.
blockArguments
!
=
=
undefined
)
{
this
.
bindLocals
(
options
.
blockArguments
)
;
}
this
.
initializeNodes
(
ownerNode
)
;
}
RenderResult
.
build
=
function
(
env
scope
template
options
contextualElement
)
{
var
dom
=
env
.
dom
;
var
fragment
=
getCachedFragment
(
template
env
)
;
var
nodes
=
template
.
buildRenderNodes
(
dom
fragment
contextualElement
)
;
var
rootNode
ownerNode
shouldSetContent
;
if
(
options
&
&
options
.
renderNode
)
{
rootNode
=
options
.
renderNode
;
ownerNode
=
rootNode
.
ownerNode
;
shouldSetContent
=
true
;
}
else
{
rootNode
=
dom
.
createMorph
(
null
fragment
.
firstChild
fragment
.
lastChild
contextualElement
)
;
ownerNode
=
rootNode
;
rootNode
.
ownerNode
=
ownerNode
;
shouldSetContent
=
false
;
}
if
(
rootNode
.
childNodes
)
{
_htmlbarsUtilMorphUtils
.
visitChildren
(
rootNode
.
childNodes
function
(
node
)
{
_htmlbarsUtilTemplateUtils
.
clearMorph
(
node
env
true
)
;
}
)
;
}
rootNode
.
childNodes
=
nodes
;
return
new
RenderResult
(
env
scope
options
rootNode
ownerNode
nodes
fragment
template
shouldSetContent
)
;
}
;
function
manualElement
(
tagName
attributes
_isEmpty
)
{
var
statements
=
[
]
;
for
(
var
key
in
attributes
)
{
if
(
typeof
attributes
[
key
]
=
=
=
'
string
'
)
{
continue
;
}
statements
.
push
(
[
"
attribute
"
key
attributes
[
key
]
]
)
;
}
var
isEmpty
=
_isEmpty
|
|
_htmlbarsUtilVoidTagNames
.
default
[
tagName
]
;
if
(
!
isEmpty
)
{
statements
.
push
(
[
'
content
'
'
yield
'
]
)
;
}
var
template
=
{
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
if
(
tagName
=
=
=
'
svg
'
)
{
dom
.
setNamespace
(
svgNamespace
)
;
}
var
el1
=
dom
.
createElement
(
tagName
)
;
for
(
var
key
in
attributes
)
{
if
(
typeof
attributes
[
key
]
!
=
=
'
string
'
)
{
continue
;
}
dom
.
setAttribute
(
el1
key
attributes
[
key
]
)
;
}
if
(
!
isEmpty
)
{
var
el2
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el1
el2
)
;
}
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
)
{
var
element
=
dom
.
childAt
(
fragment
[
0
]
)
;
var
morphs
=
[
]
;
for
(
var
key
in
attributes
)
{
if
(
typeof
attributes
[
key
]
=
=
=
'
string
'
)
{
continue
;
}
morphs
.
push
(
dom
.
createAttrMorph
(
element
key
)
)
;
}
if
(
!
isEmpty
)
{
morphs
.
push
(
dom
.
createMorphAt
(
element
0
0
)
)
;
}
return
morphs
;
}
statements
:
statements
locals
:
[
]
templates
:
[
]
}
;
return
template
;
}
function
attachAttributes
(
attributes
)
{
var
statements
=
[
]
;
for
(
var
key
in
attributes
)
{
if
(
typeof
attributes
[
key
]
=
=
=
'
string
'
)
{
continue
;
}
statements
.
push
(
[
"
attribute
"
key
attributes
[
key
]
]
)
;
}
var
template
=
{
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
this
.
element
;
if
(
el0
.
namespaceURI
=
=
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
)
{
dom
.
setNamespace
(
svgNamespace
)
;
}
for
(
var
key
in
attributes
)
{
if
(
typeof
attributes
[
key
]
!
=
=
'
string
'
)
{
continue
;
}
dom
.
setAttribute
(
el0
key
attributes
[
key
]
)
;
}
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
)
{
var
element
=
this
.
element
;
var
morphs
=
[
]
;
for
(
var
key
in
attributes
)
{
if
(
typeof
attributes
[
key
]
=
=
=
'
string
'
)
{
continue
;
}
morphs
.
push
(
dom
.
createAttrMorph
(
element
key
)
)
;
}
return
morphs
;
}
statements
:
statements
locals
:
[
]
templates
:
[
]
element
:
null
}
;
return
template
;
}
RenderResult
.
prototype
.
initializeNodes
=
function
(
ownerNode
)
{
var
childNodes
=
this
.
root
.
childNodes
;
for
(
var
i
=
0
l
=
childNodes
.
length
;
i
<
l
;
i
+
+
)
{
childNodes
[
i
]
.
ownerNode
=
ownerNode
;
}
}
;
RenderResult
.
prototype
.
render
=
function
(
)
{
this
.
root
.
lastResult
=
this
;
this
.
root
.
rendered
=
true
;
this
.
populateNodes
(
_htmlbarsRuntimeNodeVisitor
.
AlwaysDirtyVisitor
)
;
if
(
this
.
shouldSetContent
&
&
this
.
root
.
setContent
)
{
this
.
root
.
setContent
(
this
.
fragment
)
;
}
}
;
RenderResult
.
prototype
.
dirty
=
function
(
)
{
_htmlbarsUtilMorphUtils
.
visitChildren
(
[
this
.
root
]
function
(
node
)
{
node
.
isDirty
=
true
;
}
)
;
}
;
RenderResult
.
prototype
.
revalidate
=
function
(
env
self
blockArguments
scope
)
{
this
.
revalidateWith
(
env
scope
self
blockArguments
_htmlbarsRuntimeNodeVisitor
.
default
)
;
}
;
RenderResult
.
prototype
.
rerender
=
function
(
env
self
blockArguments
scope
)
{
this
.
revalidateWith
(
env
scope
self
blockArguments
_htmlbarsRuntimeNodeVisitor
.
AlwaysDirtyVisitor
)
;
}
;
RenderResult
.
prototype
.
revalidateWith
=
function
(
env
scope
self
blockArguments
visitor
)
{
if
(
env
!
=
=
undefined
)
{
this
.
env
=
env
;
}
if
(
scope
!
=
=
undefined
)
{
this
.
scope
=
scope
;
}
this
.
updateScope
(
)
;
if
(
self
!
=
=
undefined
)
{
this
.
updateSelf
(
self
)
;
}
if
(
blockArguments
!
=
=
undefined
)
{
this
.
updateLocals
(
blockArguments
)
;
}
this
.
populateNodes
(
visitor
)
;
}
;
RenderResult
.
prototype
.
destroy
=
function
(
)
{
var
rootNode
=
this
.
root
;
_htmlbarsUtilTemplateUtils
.
clearMorph
(
rootNode
this
.
env
true
)
;
}
;
RenderResult
.
prototype
.
populateNodes
=
function
(
visitor
)
{
var
env
=
this
.
env
;
var
scope
=
this
.
scope
;
var
template
=
this
.
template
;
var
nodes
=
this
.
nodes
;
var
statements
=
this
.
statements
;
var
i
l
;
for
(
i
=
0
l
=
statements
.
length
;
i
<
l
;
i
+
+
)
{
var
statement
=
statements
[
i
]
;
var
morph
=
nodes
[
i
]
;
if
(
env
.
hooks
.
willRenderNode
)
{
env
.
hooks
.
willRenderNode
(
morph
env
scope
)
;
}
switch
(
statement
[
0
]
)
{
case
'
block
'
:
visitor
.
block
(
statement
morph
env
scope
template
visitor
)
;
break
;
case
'
inline
'
:
visitor
.
inline
(
statement
morph
env
scope
visitor
)
;
break
;
case
'
content
'
:
visitor
.
content
(
statement
morph
env
scope
visitor
)
;
break
;
case
'
element
'
:
visitor
.
element
(
statement
morph
env
scope
template
visitor
)
;
break
;
case
'
attribute
'
:
visitor
.
attribute
(
statement
morph
env
scope
)
;
break
;
case
'
component
'
:
visitor
.
component
(
statement
morph
env
scope
template
visitor
)
;
break
;
}
if
(
env
.
hooks
.
didRenderNode
)
{
env
.
hooks
.
didRenderNode
(
morph
env
scope
)
;
}
}
}
;
RenderResult
.
prototype
.
bindScope
=
function
(
)
{
this
.
env
.
hooks
.
bindScope
(
this
.
env
this
.
scope
)
;
}
;
RenderResult
.
prototype
.
updateScope
=
function
(
)
{
this
.
env
.
hooks
.
updateScope
(
this
.
env
this
.
scope
)
;
}
;
RenderResult
.
prototype
.
bindSelf
=
function
(
self
)
{
this
.
env
.
hooks
.
bindSelf
(
this
.
env
this
.
scope
self
)
;
}
;
RenderResult
.
prototype
.
updateSelf
=
function
(
self
)
{
this
.
env
.
hooks
.
updateSelf
(
this
.
env
this
.
scope
self
)
;
}
;
RenderResult
.
prototype
.
bindLocals
=
function
(
blockArguments
)
{
var
localNames
=
this
.
template
.
locals
;
for
(
var
i
=
0
l
=
localNames
.
length
;
i
<
l
;
i
+
+
)
{
this
.
env
.
hooks
.
bindLocal
(
this
.
env
this
.
scope
localNames
[
i
]
blockArguments
[
i
]
)
;
}
}
;
RenderResult
.
prototype
.
updateLocals
=
function
(
blockArguments
)
{
var
localNames
=
this
.
template
.
locals
;
for
(
var
i
=
0
l
=
localNames
.
length
;
i
<
l
;
i
+
+
)
{
this
.
env
.
hooks
.
updateLocal
(
this
.
env
this
.
scope
localNames
[
i
]
blockArguments
[
i
]
)
;
}
}
;
function
initializeNode
(
node
owner
)
{
node
.
ownerNode
=
owner
;
}
function
createChildMorph
(
dom
parentMorph
contextualElement
)
{
var
morph
=
_htmlbarsRuntimeMorph
.
default
.
empty
(
dom
contextualElement
|
|
parentMorph
.
contextualElement
)
;
initializeNode
(
morph
parentMorph
.
ownerNode
)
;
return
morph
;
}
function
getCachedFragment
(
template
env
)
{
var
dom
=
env
.
dom
fragment
;
if
(
env
.
useFragmentCache
&
&
dom
.
canClone
)
{
if
(
template
.
cachedFragment
=
=
=
null
)
{
fragment
=
template
.
buildFragment
(
dom
)
;
if
(
template
.
hasRendered
)
{
template
.
cachedFragment
=
fragment
;
}
else
{
template
.
hasRendered
=
true
;
}
}
if
(
template
.
cachedFragment
)
{
fragment
=
dom
.
cloneNode
(
template
.
cachedFragment
true
)
;
}
}
else
if
(
!
fragment
)
{
fragment
=
template
.
buildFragment
(
dom
)
;
}
return
fragment
;
}
}
)
;
enifed
(
'
htmlbars
-
util
'
[
'
exports
'
'
htmlbars
-
util
/
safe
-
string
'
'
htmlbars
-
util
/
handlebars
/
utils
'
'
htmlbars
-
util
/
namespaces
'
'
htmlbars
-
util
/
morph
-
utils
'
]
function
(
exports
_htmlbarsUtilSafeString
_htmlbarsUtilHandlebarsUtils
_htmlbarsUtilNamespaces
_htmlbarsUtilMorphUtils
)
{
'
use
strict
'
;
exports
.
SafeString
=
_htmlbarsUtilSafeString
.
default
;
exports
.
escapeExpression
=
_htmlbarsUtilHandlebarsUtils
.
escapeExpression
;
exports
.
getAttrNamespace
=
_htmlbarsUtilNamespaces
.
getAttrNamespace
;
exports
.
validateChildMorphs
=
_htmlbarsUtilMorphUtils
.
validateChildMorphs
;
exports
.
linkParams
=
_htmlbarsUtilMorphUtils
.
linkParams
;
exports
.
dump
=
_htmlbarsUtilMorphUtils
.
dump
;
}
)
;
enifed
(
'
htmlbars
-
util
/
array
-
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
forEach
=
forEach
;
exports
.
map
=
map
;
function
forEach
(
array
callback
binding
)
{
var
i
l
;
if
(
binding
=
=
=
undefined
)
{
for
(
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
callback
(
array
[
i
]
i
array
)
;
}
}
else
{
for
(
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
callback
.
call
(
binding
array
[
i
]
i
array
)
;
}
}
}
function
map
(
array
callback
)
{
var
output
=
[
]
;
var
i
l
;
for
(
i
=
0
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
output
.
push
(
callback
(
array
[
i
]
i
array
)
)
;
}
return
output
;
}
var
getIdx
;
if
(
Array
.
prototype
.
indexOf
)
{
getIdx
=
function
(
array
obj
from
)
{
return
array
.
indexOf
(
obj
from
)
;
}
;
}
else
{
getIdx
=
function
(
array
obj
from
)
{
if
(
from
=
=
=
undefined
|
|
from
=
=
=
null
)
{
from
=
0
;
}
else
if
(
from
<
0
)
{
from
=
Math
.
max
(
0
array
.
length
+
from
)
;
}
for
(
var
i
=
from
l
=
array
.
length
;
i
<
l
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
obj
)
{
return
i
;
}
}
return
-
1
;
}
;
}
var
isArray
=
Array
.
isArray
|
|
function
(
array
)
{
return
Object
.
prototype
.
toString
.
call
(
array
)
=
=
=
'
[
object
Array
]
'
;
}
;
exports
.
isArray
=
isArray
;
var
indexOfArray
=
getIdx
;
exports
.
indexOfArray
=
indexOfArray
;
}
)
;
enifed
(
'
htmlbars
-
util
/
handlebars
/
safe
-
string
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
SafeString
(
string
)
{
this
.
string
=
string
;
}
SafeString
.
prototype
.
toString
=
SafeString
.
prototype
.
toHTML
=
function
(
)
{
return
'
'
+
this
.
string
;
}
;
exports
.
default
=
SafeString
;
}
)
;
enifed
(
'
htmlbars
-
util
/
handlebars
/
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
extend
=
extend
;
exports
.
indexOf
=
indexOf
;
exports
.
escapeExpression
=
escapeExpression
;
exports
.
isEmpty
=
isEmpty
;
exports
.
blockParams
=
blockParams
;
exports
.
appendContextPath
=
appendContextPath
;
var
escape
=
{
'
&
'
:
'
&
amp
;
'
'
<
'
:
'
&
lt
;
'
'
>
'
:
'
&
gt
;
'
'
"
'
:
'
&
quot
;
'
"
'
"
:
'
&
#
x27
;
'
'
'
:
'
&
#
x60
;
'
}
;
var
badChars
=
/
[
&
<
>
"
'
]
/
g
possible
=
/
[
&
<
>
"
'
]
/
;
function
escapeChar
(
chr
)
{
return
escape
[
chr
]
;
}
function
extend
(
obj
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
for
(
var
key
in
arguments
[
i
]
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
arguments
[
i
]
key
)
)
{
obj
[
key
]
=
arguments
[
i
]
[
key
]
;
}
}
}
return
obj
;
}
var
toString
=
Object
.
prototype
.
toString
;
exports
.
toString
=
toString
;
var
isFunction
=
function
(
value
)
{
return
typeof
value
=
=
=
'
function
'
;
}
;
if
(
isFunction
(
/
x
/
)
)
{
exports
.
isFunction
=
isFunction
=
function
(
value
)
{
return
typeof
value
=
=
=
'
function
'
&
&
toString
.
call
(
value
)
=
=
=
'
[
object
Function
]
'
;
}
;
}
var
isFunction
;
exports
.
isFunction
=
isFunction
;
var
isArray
=
Array
.
isArray
|
|
function
(
value
)
{
return
value
&
&
typeof
value
=
=
=
'
object
'
?
toString
.
call
(
value
)
=
=
=
'
[
object
Array
]
'
:
false
;
}
;
exports
.
isArray
=
isArray
;
function
indexOf
(
array
value
)
{
for
(
var
i
=
0
len
=
array
.
length
;
i
<
len
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
{
return
i
;
}
}
return
-
1
;
}
function
escapeExpression
(
string
)
{
if
(
typeof
string
!
=
=
'
string
'
)
{
if
(
string
&
&
string
.
toHTML
)
{
return
string
.
toHTML
(
)
;
}
else
if
(
string
=
=
null
)
{
return
'
'
;
}
else
if
(
!
string
)
{
return
string
+
'
'
;
}
string
=
'
'
+
string
;
}
if
(
!
possible
.
test
(
string
)
)
{
return
string
;
}
return
string
.
replace
(
badChars
escapeChar
)
;
}
function
isEmpty
(
value
)
{
if
(
!
value
&
&
value
!
=
=
0
)
{
return
true
;
}
else
if
(
isArray
(
value
)
&
&
value
.
length
=
=
=
0
)
{
return
true
;
}
else
{
return
false
;
}
}
function
blockParams
(
params
ids
)
{
params
.
path
=
ids
;
return
params
;
}
function
appendContextPath
(
contextPath
id
)
{
return
(
contextPath
?
contextPath
+
'
.
'
:
'
'
)
+
id
;
}
}
)
;
enifed
(
"
htmlbars
-
util
/
morph
-
utils
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
visitChildren
=
visitChildren
;
exports
.
validateChildMorphs
=
validateChildMorphs
;
exports
.
linkParams
=
linkParams
;
exports
.
dump
=
dump
;
function
visitChildren
(
nodes
callback
)
{
if
(
!
nodes
|
|
nodes
.
length
=
=
=
0
)
{
return
;
}
nodes
=
nodes
.
slice
(
)
;
while
(
nodes
.
length
)
{
var
node
=
nodes
.
pop
(
)
;
callback
(
node
)
;
if
(
node
.
childNodes
)
{
nodes
.
push
.
apply
(
nodes
node
.
childNodes
)
;
}
else
if
(
node
.
firstChildMorph
)
{
var
current
=
node
.
firstChildMorph
;
while
(
current
)
{
nodes
.
push
(
current
)
;
current
=
current
.
nextMorph
;
}
}
else
if
(
node
.
morphList
)
{
var
current
=
node
.
morphList
.
firstChildMorph
;
while
(
current
)
{
nodes
.
push
(
current
)
;
current
=
current
.
nextMorph
;
}
}
}
}
function
validateChildMorphs
(
env
morph
visitor
)
{
var
morphList
=
morph
.
morphList
;
if
(
morph
.
morphList
)
{
var
current
=
morphList
.
firstChildMorph
;
while
(
current
)
{
var
next
=
current
.
nextMorph
;
validateChildMorphs
(
env
current
visitor
)
;
current
=
next
;
}
}
else
if
(
morph
.
lastResult
)
{
morph
.
lastResult
.
revalidateWith
(
env
undefined
undefined
undefined
visitor
)
;
}
else
if
(
morph
.
childNodes
)
{
for
(
var
i
=
0
l
=
morph
.
childNodes
.
length
;
i
<
l
;
i
+
+
)
{
validateChildMorphs
(
env
morph
.
childNodes
[
i
]
visitor
)
;
}
}
}
function
linkParams
(
env
scope
morph
path
params
hash
)
{
if
(
morph
.
linkedParams
)
{
return
;
}
if
(
env
.
hooks
.
linkRenderNode
(
morph
env
scope
path
params
hash
)
)
{
morph
.
linkedParams
=
{
params
:
params
hash
:
hash
}
;
}
}
function
dump
(
node
)
{
console
.
group
(
node
node
.
isDirty
)
;
if
(
node
.
childNodes
)
{
map
(
node
.
childNodes
dump
)
;
}
else
if
(
node
.
firstChildMorph
)
{
var
current
=
node
.
firstChildMorph
;
while
(
current
)
{
dump
(
current
)
;
current
=
current
.
nextMorph
;
}
}
else
if
(
node
.
morphList
)
{
dump
(
node
.
morphList
)
;
}
console
.
groupEnd
(
)
;
}
function
map
(
nodes
cb
)
{
for
(
var
i
=
0
l
=
nodes
.
length
;
i
<
l
;
i
+
+
)
{
cb
(
nodes
[
i
]
)
;
}
}
}
)
;
enifed
(
'
htmlbars
-
util
/
namespaces
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
getAttrNamespace
=
getAttrNamespace
;
var
defaultNamespaces
=
{
html
:
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
mathml
:
'
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
'
svg
:
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
xlink
:
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
xml
:
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
}
;
function
getAttrNamespace
(
attrName
detectedNamespace
)
{
if
(
detectedNamespace
)
{
return
detectedNamespace
;
}
var
namespace
;
var
colonIndex
=
attrName
.
indexOf
(
'
:
'
)
;
if
(
colonIndex
!
=
=
-
1
)
{
var
prefix
=
attrName
.
slice
(
0
colonIndex
)
;
namespace
=
defaultNamespaces
[
prefix
]
;
}
return
namespace
|
|
null
;
}
}
)
;
enifed
(
"
htmlbars
-
util
/
object
-
utils
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
merge
=
merge
;
exports
.
shallowCopy
=
shallowCopy
;
exports
.
keySet
=
keySet
;
exports
.
keyLength
=
keyLength
;
function
merge
(
options
defaults
)
{
for
(
var
prop
in
defaults
)
{
if
(
options
.
hasOwnProperty
(
prop
)
)
{
continue
;
}
options
[
prop
]
=
defaults
[
prop
]
;
}
return
options
;
}
function
shallowCopy
(
obj
)
{
return
merge
(
{
}
obj
)
;
}
function
keySet
(
obj
)
{
var
set
=
{
}
;
for
(
var
prop
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
prop
)
)
{
set
[
prop
]
=
true
;
}
}
return
set
;
}
function
keyLength
(
obj
)
{
var
count
=
0
;
for
(
var
prop
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
prop
)
)
{
count
+
+
;
}
}
return
count
;
}
}
)
;
enifed
(
"
htmlbars
-
util
/
quoting
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
hash
=
hash
;
exports
.
repeat
=
repeat
;
function
escapeString
(
str
)
{
str
=
str
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
;
str
=
str
.
replace
(
/
"
/
g
'
\
\
"
'
)
;
str
=
str
.
replace
(
/
\
n
/
g
"
\
\
n
"
)
;
return
str
;
}
exports
.
escapeString
=
escapeString
;
function
string
(
str
)
{
return
'
"
'
+
escapeString
(
str
)
+
'
"
'
;
}
exports
.
string
=
string
;
function
array
(
a
)
{
return
"
[
"
+
a
+
"
]
"
;
}
exports
.
array
=
array
;
function
hash
(
pairs
)
{
return
"
{
"
+
pairs
.
join
(
"
"
)
+
"
}
"
;
}
function
repeat
(
chars
times
)
{
var
str
=
"
"
;
while
(
times
-
-
)
{
str
+
=
chars
;
}
return
str
;
}
}
)
;
enifed
(
'
htmlbars
-
util
/
safe
-
string
'
[
'
exports
'
'
htmlbars
-
util
/
handlebars
/
safe
-
string
'
]
function
(
exports
_htmlbarsUtilHandlebarsSafeString
)
{
'
use
strict
'
;
exports
.
default
=
_htmlbarsUtilHandlebarsSafeString
.
default
;
}
)
;
enifed
(
"
htmlbars
-
util
/
template
-
utils
"
[
"
exports
"
"
htmlbars
-
util
/
morph
-
utils
"
"
htmlbars
-
runtime
/
render
"
]
function
(
exports
_htmlbarsUtilMorphUtils
_htmlbarsRuntimeRender
)
{
"
use
strict
"
;
exports
.
RenderState
=
RenderState
;
exports
.
blockFor
=
blockFor
;
exports
.
renderAndCleanup
=
renderAndCleanup
;
exports
.
clearMorph
=
clearMorph
;
exports
.
clearMorphList
=
clearMorphList
;
function
RenderState
(
renderNode
morphList
)
{
this
.
morphListToClear
=
morphList
;
this
.
morphListToPrune
=
null
;
this
.
handledMorphs
=
{
}
;
this
.
collisions
=
undefined
;
this
.
morphToClear
=
renderNode
;
this
.
shadowOptions
=
null
;
}
function
Block
(
render
template
blockOptions
)
{
this
.
render
=
render
;
this
.
template
=
template
;
this
.
blockOptions
=
blockOptions
;
this
.
arity
=
template
.
arity
;
}
Block
.
prototype
.
invoke
=
function
(
env
blockArguments
_self
renderNode
parentScope
visitor
)
{
if
(
renderNode
.
lastResult
)
{
renderNode
.
lastResult
.
revalidateWith
(
env
undefined
_self
blockArguments
visitor
)
;
}
else
{
this
.
_firstRender
(
env
blockArguments
_self
renderNode
parentScope
)
;
}
}
;
Block
.
prototype
.
_firstRender
=
function
(
env
blockArguments
_self
renderNode
parentScope
)
{
var
options
=
{
renderState
:
new
RenderState
(
renderNode
)
}
;
var
render
=
this
.
render
;
var
template
=
this
.
template
;
var
scope
=
this
.
blockOptions
.
scope
;
var
shadowScope
=
scope
?
env
.
hooks
.
createChildScope
(
scope
)
:
env
.
hooks
.
createFreshScope
(
)
;
env
.
hooks
.
bindShadowScope
(
env
parentScope
shadowScope
this
.
blockOptions
.
options
)
;
if
(
_self
!
=
=
undefined
)
{
env
.
hooks
.
bindSelf
(
env
shadowScope
_self
)
;
}
else
if
(
this
.
blockOptions
.
self
!
=
=
undefined
)
{
env
.
hooks
.
bindSelf
(
env
shadowScope
this
.
blockOptions
.
self
)
;
}
bindBlocks
(
env
shadowScope
this
.
blockOptions
.
yieldTo
)
;
renderAndCleanup
(
renderNode
env
options
null
function
(
)
{
options
.
renderState
.
morphToClear
=
null
;
var
renderOptions
=
new
_htmlbarsRuntimeRender
.
RenderOptions
(
renderNode
undefined
blockArguments
)
;
render
(
template
env
shadowScope
renderOptions
)
;
}
)
;
}
;
function
blockFor
(
render
template
blockOptions
)
{
return
new
Block
(
render
template
blockOptions
)
;
}
function
bindBlocks
(
env
shadowScope
blocks
)
{
if
(
!
blocks
)
{
return
;
}
if
(
blocks
instanceof
Block
)
{
env
.
hooks
.
bindBlock
(
env
shadowScope
blocks
)
;
}
else
{
for
(
var
name
in
blocks
)
{
if
(
blocks
.
hasOwnProperty
(
name
)
)
{
env
.
hooks
.
bindBlock
(
env
shadowScope
blocks
[
name
]
name
)
;
}
}
}
}
function
renderAndCleanup
(
morph
env
options
shadowOptions
callback
)
{
var
renderState
=
options
.
renderState
;
renderState
.
collisions
=
undefined
;
renderState
.
shadowOptions
=
shadowOptions
;
var
result
=
callback
(
options
)
;
if
(
result
&
&
result
.
handled
)
{
return
;
}
var
morphMap
=
morph
.
morphMap
;
var
morphList
=
renderState
.
morphListToPrune
;
if
(
morphList
)
{
var
handledMorphs
=
renderState
.
handledMorphs
;
var
item
=
morphList
.
firstChildMorph
;
while
(
item
)
{
var
next
=
item
.
nextMorph
;
if
(
!
(
item
.
key
in
handledMorphs
)
)
{
morphMap
[
item
.
key
]
=
undefined
;
clearMorph
(
item
env
true
)
;
item
.
destroy
(
)
;
}
item
=
next
;
}
}
morphList
=
renderState
.
morphListToClear
;
if
(
morphList
)
{
clearMorphList
(
morphList
morph
env
)
;
}
var
toClear
=
renderState
.
morphToClear
;
if
(
toClear
)
{
clearMorph
(
toClear
env
)
;
}
}
function
clearMorph
(
morph
env
destroySelf
)
{
var
cleanup
=
env
.
hooks
.
cleanupRenderNode
;
var
destroy
=
env
.
hooks
.
destroyRenderNode
;
var
willCleanup
=
env
.
hooks
.
willCleanupTree
;
var
didCleanup
=
env
.
hooks
.
didCleanupTree
;
function
destroyNode
(
node
)
{
if
(
cleanup
)
{
cleanup
(
node
)
;
}
if
(
destroy
)
{
destroy
(
node
)
;
}
}
if
(
willCleanup
)
{
willCleanup
(
env
morph
destroySelf
)
;
}
if
(
cleanup
)
{
cleanup
(
morph
)
;
}
if
(
destroySelf
&
&
destroy
)
{
destroy
(
morph
)
;
}
_htmlbarsUtilMorphUtils
.
visitChildren
(
morph
.
childNodes
destroyNode
)
;
morph
.
clear
(
)
;
if
(
didCleanup
)
{
didCleanup
(
env
morph
destroySelf
)
;
}
morph
.
lastResult
=
null
;
morph
.
lastYielded
=
null
;
morph
.
childNodes
=
null
;
}
function
clearMorphList
(
morphList
morph
env
)
{
var
item
=
morphList
.
firstChildMorph
;
while
(
item
)
{
var
next
=
item
.
nextMorph
;
morph
.
morphMap
[
item
.
key
]
=
undefined
;
clearMorph
(
item
env
true
)
;
item
.
destroy
(
)
;
item
=
next
;
}
morphList
.
clear
(
)
;
morph
.
morphList
=
null
;
}
}
)
;
enifed
(
"
htmlbars
-
util
/
void
-
tag
-
names
"
[
"
exports
"
"
htmlbars
-
util
/
array
-
utils
"
]
function
(
exports
_htmlbarsUtilArrayUtils
)
{
"
use
strict
"
;
var
voidTagNames
=
"
area
base
br
col
command
embed
hr
img
input
keygen
link
meta
param
source
track
wbr
"
;
var
voidMap
=
{
}
;
_htmlbarsUtilArrayUtils
.
forEach
(
voidTagNames
.
split
(
"
"
)
function
(
tagName
)
{
voidMap
[
tagName
]
=
true
;
}
)
;
exports
.
default
=
voidMap
;
}
)
;
enifed
(
"
morph
-
attr
"
[
"
exports
"
"
morph
-
attr
/
sanitize
-
attribute
-
value
"
"
dom
-
helper
/
prop
"
"
dom
-
helper
/
build
-
html
-
dom
"
"
htmlbars
-
util
"
]
function
(
exports
_morphAttrSanitizeAttributeValue
_domHelperProp
_domHelperBuildHtmlDom
_htmlbarsUtil
)
{
"
use
strict
"
;
function
getProperty
(
)
{
return
this
.
domHelper
.
getPropertyStrict
(
this
.
element
this
.
attrName
)
;
}
function
updateProperty
(
value
)
{
if
(
this
.
_renderedInitially
=
=
=
true
|
|
!
_domHelperProp
.
isAttrRemovalValue
(
value
)
)
{
var
element
=
this
.
element
;
var
attrName
=
this
.
attrName
;
if
(
attrName
=
=
=
'
value
'
&
&
element
.
tagName
=
=
=
'
INPUT
'
&
&
element
.
value
=
=
=
value
)
{
}
else
{
this
.
domHelper
.
setPropertyStrict
(
element
attrName
value
)
;
}
}
this
.
_renderedInitially
=
true
;
}
function
getAttribute
(
)
{
return
this
.
domHelper
.
getAttribute
(
this
.
element
this
.
attrName
)
;
}
function
updateAttribute
(
value
)
{
if
(
_domHelperProp
.
isAttrRemovalValue
(
value
)
)
{
this
.
domHelper
.
removeAttribute
(
this
.
element
this
.
attrName
)
;
}
else
{
this
.
domHelper
.
setAttribute
(
this
.
element
this
.
attrName
value
)
;
}
}
function
getAttributeNS
(
)
{
return
this
.
domHelper
.
getAttributeNS
(
this
.
element
this
.
namespace
this
.
attrName
)
;
}
function
updateAttributeNS
(
value
)
{
if
(
_domHelperProp
.
isAttrRemovalValue
(
value
)
)
{
this
.
domHelper
.
removeAttribute
(
this
.
element
this
.
attrName
)
;
}
else
{
this
.
domHelper
.
setAttributeNS
(
this
.
element
this
.
namespace
this
.
attrName
value
)
;
}
}
var
UNSET
=
{
unset
:
true
}
;
var
guid
=
1
;
AttrMorph
.
create
=
function
(
element
attrName
domHelper
namespace
)
{
var
ns
=
_htmlbarsUtil
.
getAttrNamespace
(
attrName
namespace
)
;
if
(
ns
)
{
return
new
AttributeNSAttrMorph
(
element
attrName
domHelper
ns
)
;
}
else
{
return
createNonNamespacedAttrMorph
(
element
attrName
domHelper
)
;
}
}
;
function
createNonNamespacedAttrMorph
(
element
attrName
domHelper
)
{
var
_normalizeProperty
=
_domHelperProp
.
normalizeProperty
(
element
attrName
)
;
var
normalized
=
_normalizeProperty
.
normalized
;
var
type
=
_normalizeProperty
.
type
;
if
(
element
.
namespaceURI
=
=
=
_domHelperBuildHtmlDom
.
svgNamespace
|
|
attrName
=
=
=
'
style
'
|
|
type
=
=
=
'
attr
'
)
{
return
new
AttributeAttrMorph
(
element
normalized
domHelper
)
;
}
else
{
return
new
PropertyAttrMorph
(
element
normalized
domHelper
)
;
}
}
function
AttrMorph
(
element
attrName
domHelper
)
{
this
.
element
=
element
;
this
.
domHelper
=
domHelper
;
this
.
attrName
=
attrName
;
this
.
_state
=
undefined
;
this
.
isDirty
=
false
;
this
.
isSubtreeDirty
=
false
;
this
.
escaped
=
true
;
this
.
lastValue
=
UNSET
;
this
.
lastResult
=
null
;
this
.
lastYielded
=
null
;
this
.
childNodes
=
null
;
this
.
linkedParams
=
null
;
this
.
linkedResult
=
null
;
this
.
guid
=
"
attr
"
+
guid
+
+
;
this
.
seen
=
false
;
this
.
ownerNode
=
null
;
this
.
rendered
=
false
;
this
.
_renderedInitially
=
false
;
this
.
namespace
=
undefined
;
this
.
didInit
(
)
;
}
AttrMorph
.
prototype
.
getState
=
function
(
)
{
if
(
!
this
.
_state
)
{
this
.
_state
=
{
}
;
}
return
this
.
_state
;
}
;
AttrMorph
.
prototype
.
setState
=
function
(
newState
)
{
return
this
.
_state
=
newState
;
}
;
AttrMorph
.
prototype
.
didInit
=
function
(
)
{
}
;
AttrMorph
.
prototype
.
willSetContent
=
function
(
)
{
}
;
AttrMorph
.
prototype
.
setContent
=
function
(
value
)
{
this
.
willSetContent
(
value
)
;
if
(
this
.
lastValue
=
=
=
value
)
{
return
;
}
this
.
lastValue
=
value
;
if
(
this
.
escaped
)
{
var
sanitized
=
_morphAttrSanitizeAttributeValue
.
sanitizeAttributeValue
(
this
.
domHelper
this
.
element
this
.
attrName
value
)
;
this
.
_update
(
sanitized
this
.
namespace
)
;
}
else
{
this
.
_update
(
value
this
.
namespace
)
;
}
}
;
AttrMorph
.
prototype
.
getContent
=
function
(
)
{
var
value
=
this
.
lastValue
=
this
.
_get
(
)
;
return
value
;
}
;
AttrMorph
.
prototype
.
clear
=
function
(
)
{
}
;
AttrMorph
.
prototype
.
destroy
=
function
(
)
{
this
.
element
=
null
;
this
.
domHelper
=
null
;
}
;
AttrMorph
.
prototype
.
_
superAttrMorph
=
AttrMorph
;
function
PropertyAttrMorph
(
element
attrName
domHelper
)
{
this
.
_
superAttrMorph
(
element
attrName
domHelper
)
;
}
PropertyAttrMorph
.
prototype
=
Object
.
create
(
AttrMorph
.
prototype
)
;
PropertyAttrMorph
.
prototype
.
_update
=
updateProperty
;
PropertyAttrMorph
.
prototype
.
_get
=
getProperty
;
function
AttributeNSAttrMorph
(
element
attrName
domHelper
namespace
)
{
this
.
_
superAttrMorph
(
element
attrName
domHelper
)
;
this
.
namespace
=
namespace
;
}
AttributeNSAttrMorph
.
prototype
=
Object
.
create
(
AttrMorph
.
prototype
)
;
AttributeNSAttrMorph
.
prototype
.
_update
=
updateAttributeNS
;
AttributeNSAttrMorph
.
prototype
.
_get
=
getAttributeNS
;
function
AttributeAttrMorph
(
element
attrName
domHelper
)
{
this
.
_
superAttrMorph
(
element
attrName
domHelper
)
;
}
AttributeAttrMorph
.
prototype
=
Object
.
create
(
AttrMorph
.
prototype
)
;
AttributeAttrMorph
.
prototype
.
_update
=
updateAttribute
;
AttributeAttrMorph
.
prototype
.
_get
=
getAttribute
;
exports
.
default
=
AttrMorph
;
exports
.
sanitizeAttributeValue
=
_morphAttrSanitizeAttributeValue
.
sanitizeAttributeValue
;
}
)
;
enifed
(
'
morph
-
attr
/
sanitize
-
attribute
-
value
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
sanitizeAttributeValue
=
sanitizeAttributeValue
;
var
badProtocols
=
{
'
javascript
:
'
:
true
'
vbscript
:
'
:
true
}
;
var
badTags
=
{
'
A
'
:
true
'
BODY
'
:
true
'
LINK
'
:
true
'
IMG
'
:
true
'
IFRAME
'
:
true
'
BASE
'
:
true
'
FORM
'
:
true
}
;
var
badTagsForDataURI
=
{
'
EMBED
'
:
true
}
;
var
badAttributes
=
{
'
href
'
:
true
'
src
'
:
true
'
background
'
:
true
'
action
'
:
true
}
;
exports
.
badAttributes
=
badAttributes
;
var
badAttributesForDataURI
=
{
'
src
'
:
true
}
;
function
sanitizeAttributeValue
(
dom
element
attribute
value
)
{
var
tagName
;
if
(
!
element
)
{
tagName
=
null
;
}
else
{
tagName
=
element
.
tagName
.
toUpperCase
(
)
;
}
if
(
value
&
&
value
.
toHTML
)
{
return
value
.
toHTML
(
)
;
}
if
(
(
tagName
=
=
=
null
|
|
badTags
[
tagName
]
)
&
&
badAttributes
[
attribute
]
)
{
var
protocol
=
dom
.
protocolForURL
(
value
)
;
if
(
badProtocols
[
protocol
]
=
=
=
true
)
{
return
'
unsafe
:
'
+
value
;
}
}
if
(
badTagsForDataURI
[
tagName
]
&
&
badAttributesForDataURI
[
attribute
]
)
{
return
'
unsafe
:
'
+
value
;
}
return
value
;
}
}
)
;
enifed
(
'
morph
-
range
'
[
'
exports
'
'
morph
-
range
/
utils
'
]
function
(
exports
_morphRangeUtils
)
{
'
use
strict
'
;
function
Morph
(
domHelper
contextualElement
)
{
this
.
domHelper
=
domHelper
;
this
.
contextualElement
=
contextualElement
;
this
.
firstNode
=
null
;
this
.
lastNode
=
null
;
this
.
parseTextAsHTML
=
false
;
this
.
parentMorphList
=
null
;
this
.
previousMorph
=
null
;
this
.
nextMorph
=
null
;
}
Morph
.
empty
=
function
(
domHelper
contextualElement
)
{
var
morph
=
new
Morph
(
domHelper
contextualElement
)
;
morph
.
clear
(
)
;
return
morph
;
}
;
Morph
.
create
=
function
(
domHelper
contextualElement
node
)
{
var
morph
=
new
Morph
(
domHelper
contextualElement
)
;
morph
.
setNode
(
node
)
;
return
morph
;
}
;
Morph
.
attach
=
function
(
domHelper
contextualElement
firstNode
lastNode
)
{
var
morph
=
new
Morph
(
domHelper
contextualElement
)
;
morph
.
setRange
(
firstNode
lastNode
)
;
return
morph
;
}
;
Morph
.
prototype
.
setContent
=
function
Morph
setContent
(
content
)
{
if
(
content
=
=
=
null
|
|
content
=
=
=
undefined
)
{
return
this
.
clear
(
)
;
}
var
type
=
typeof
content
;
switch
(
type
)
{
case
'
string
'
:
if
(
this
.
parseTextAsHTML
)
{
return
this
.
domHelper
.
setMorphHTML
(
this
content
)
;
}
return
this
.
setText
(
content
)
;
case
'
object
'
:
if
(
typeof
content
.
nodeType
=
=
=
'
number
'
)
{
return
this
.
setNode
(
content
)
;
}
if
(
typeof
content
.
toHTML
=
=
=
'
function
'
)
{
return
this
.
setHTML
(
content
.
toHTML
(
)
)
;
}
if
(
this
.
parseTextAsHTML
)
{
return
this
.
setHTML
(
content
.
toString
(
)
)
;
}
case
'
boolean
'
:
case
'
number
'
:
return
this
.
setText
(
content
.
toString
(
)
)
;
case
'
function
'
:
raiseCannotBindToFunction
(
content
)
;
default
:
throw
new
TypeError
(
'
unsupported
content
'
)
;
}
}
;
function
raiseCannotBindToFunction
(
content
)
{
var
functionName
=
content
.
name
;
var
message
;
if
(
functionName
)
{
message
=
'
Unsupported
Content
:
Cannot
bind
to
function
'
+
functionName
+
'
'
;
}
else
{
message
=
'
Unsupported
Content
:
Cannot
bind
to
function
'
;
}
throw
new
TypeError
(
message
)
;
}
Morph
.
prototype
.
clear
=
function
Morph
clear
(
)
{
var
node
=
this
.
setNode
(
this
.
domHelper
.
createComment
(
'
'
)
)
;
return
node
;
}
;
Morph
.
prototype
.
setText
=
function
Morph
setText
(
text
)
{
var
firstNode
=
this
.
firstNode
;
var
lastNode
=
this
.
lastNode
;
if
(
firstNode
&
&
lastNode
=
=
=
firstNode
&
&
firstNode
.
nodeType
=
=
=
3
)
{
firstNode
.
nodeValue
=
text
;
return
firstNode
;
}
return
this
.
setNode
(
text
?
this
.
domHelper
.
createTextNode
(
text
)
:
this
.
domHelper
.
createComment
(
'
'
)
)
;
}
;
Morph
.
prototype
.
setNode
=
function
Morph
setNode
(
newNode
)
{
var
firstNode
lastNode
;
switch
(
newNode
.
nodeType
)
{
case
3
:
firstNode
=
newNode
;
lastNode
=
newNode
;
break
;
case
11
:
firstNode
=
newNode
.
firstChild
;
lastNode
=
newNode
.
lastChild
;
if
(
firstNode
=
=
=
null
)
{
firstNode
=
this
.
domHelper
.
createComment
(
'
'
)
;
newNode
.
appendChild
(
firstNode
)
;
lastNode
=
firstNode
;
}
break
;
default
:
firstNode
=
newNode
;
lastNode
=
newNode
;
break
;
}
this
.
setRange
(
firstNode
lastNode
)
;
return
newNode
;
}
;
Morph
.
prototype
.
setRange
=
function
(
firstNode
lastNode
)
{
var
previousFirstNode
=
this
.
firstNode
;
if
(
previousFirstNode
!
=
=
null
)
{
var
parentNode
=
previousFirstNode
.
parentNode
;
if
(
parentNode
!
=
=
null
)
{
_morphRangeUtils
.
insertBefore
(
parentNode
firstNode
lastNode
previousFirstNode
)
;
_morphRangeUtils
.
clear
(
parentNode
previousFirstNode
this
.
lastNode
)
;
}
}
this
.
firstNode
=
firstNode
;
this
.
lastNode
=
lastNode
;
if
(
this
.
parentMorphList
)
{
this
.
_syncFirstNode
(
)
;
this
.
_syncLastNode
(
)
;
}
}
;
Morph
.
prototype
.
destroy
=
function
Morph
destroy
(
)
{
this
.
unlink
(
)
;
var
firstNode
=
this
.
firstNode
;
var
lastNode
=
this
.
lastNode
;
var
parentNode
=
firstNode
&
&
firstNode
.
parentNode
;
this
.
firstNode
=
null
;
this
.
lastNode
=
null
;
_morphRangeUtils
.
clear
(
parentNode
firstNode
lastNode
)
;
}
;
Morph
.
prototype
.
unlink
=
function
Morph
unlink
(
)
{
var
parentMorphList
=
this
.
parentMorphList
;
var
previousMorph
=
this
.
previousMorph
;
var
nextMorph
=
this
.
nextMorph
;
if
(
previousMorph
)
{
if
(
nextMorph
)
{
previousMorph
.
nextMorph
=
nextMorph
;
nextMorph
.
previousMorph
=
previousMorph
;
}
else
{
previousMorph
.
nextMorph
=
null
;
parentMorphList
.
lastChildMorph
=
previousMorph
;
}
}
else
{
if
(
nextMorph
)
{
nextMorph
.
previousMorph
=
null
;
parentMorphList
.
firstChildMorph
=
nextMorph
;
}
else
if
(
parentMorphList
)
{
parentMorphList
.
lastChildMorph
=
parentMorphList
.
firstChildMorph
=
null
;
}
}
this
.
parentMorphList
=
null
;
this
.
nextMorph
=
null
;
this
.
previousMorph
=
null
;
if
(
parentMorphList
&
&
parentMorphList
.
mountedMorph
)
{
if
(
!
parentMorphList
.
firstChildMorph
)
{
parentMorphList
.
mountedMorph
.
clear
(
)
;
return
;
}
else
{
parentMorphList
.
firstChildMorph
.
_syncFirstNode
(
)
;
parentMorphList
.
lastChildMorph
.
_syncLastNode
(
)
;
}
}
}
;
Morph
.
prototype
.
setHTML
=
function
(
text
)
{
var
fragment
=
this
.
domHelper
.
parseHTML
(
text
this
.
contextualElement
)
;
return
this
.
setNode
(
fragment
)
;
}
;
Morph
.
prototype
.
setMorphList
=
function
Morph
appendMorphList
(
morphList
)
{
morphList
.
mountedMorph
=
this
;
this
.
clear
(
)
;
var
originalFirstNode
=
this
.
firstNode
;
if
(
morphList
.
firstChildMorph
)
{
this
.
firstNode
=
morphList
.
firstChildMorph
.
firstNode
;
this
.
lastNode
=
morphList
.
lastChildMorph
.
lastNode
;
var
current
=
morphList
.
firstChildMorph
;
while
(
current
)
{
var
next
=
current
.
nextMorph
;
current
.
insertBeforeNode
(
originalFirstNode
null
)
;
current
=
next
;
}
originalFirstNode
.
parentNode
.
removeChild
(
originalFirstNode
)
;
}
}
;
Morph
.
prototype
.
_syncFirstNode
=
function
Morph
syncFirstNode
(
)
{
var
morph
=
this
;
var
parentMorphList
;
while
(
parentMorphList
=
morph
.
parentMorphList
)
{
if
(
parentMorphList
.
mountedMorph
=
=
=
null
)
{
break
;
}
if
(
morph
!
=
=
parentMorphList
.
firstChildMorph
)
{
break
;
}
if
(
morph
.
firstNode
=
=
=
parentMorphList
.
mountedMorph
.
firstNode
)
{
break
;
}
parentMorphList
.
mountedMorph
.
firstNode
=
morph
.
firstNode
;
morph
=
parentMorphList
.
mountedMorph
;
}
}
;
Morph
.
prototype
.
_syncLastNode
=
function
Morph
syncLastNode
(
)
{
var
morph
=
this
;
var
parentMorphList
;
while
(
parentMorphList
=
morph
.
parentMorphList
)
{
if
(
parentMorphList
.
mountedMorph
=
=
=
null
)
{
break
;
}
if
(
morph
!
=
=
parentMorphList
.
lastChildMorph
)
{
break
;
}
if
(
morph
.
lastNode
=
=
=
parentMorphList
.
mountedMorph
.
lastNode
)
{
break
;
}
parentMorphList
.
mountedMorph
.
lastNode
=
morph
.
lastNode
;
morph
=
parentMorphList
.
mountedMorph
;
}
}
;
Morph
.
prototype
.
insertBeforeNode
=
function
Morph
insertBeforeNode
(
parentNode
refNode
)
{
_morphRangeUtils
.
insertBefore
(
parentNode
this
.
firstNode
this
.
lastNode
refNode
)
;
}
;
Morph
.
prototype
.
appendToNode
=
function
Morph
appendToNode
(
parentNode
)
{
_morphRangeUtils
.
insertBefore
(
parentNode
this
.
firstNode
this
.
lastNode
null
)
;
}
;
exports
.
default
=
Morph
;
}
)
;
enifed
(
'
morph
-
range
/
morph
-
list
'
[
'
exports
'
'
morph
-
range
/
utils
'
]
function
(
exports
_morphRangeUtils
)
{
'
use
strict
'
;
function
MorphList
(
)
{
this
.
firstChildMorph
=
null
;
this
.
lastChildMorph
=
null
;
this
.
mountedMorph
=
null
;
}
var
prototype
=
MorphList
.
prototype
;
prototype
.
clear
=
function
MorphList
clear
(
)
{
var
current
=
this
.
firstChildMorph
;
while
(
current
)
{
var
next
=
current
.
nextMorph
;
current
.
previousMorph
=
null
;
current
.
nextMorph
=
null
;
current
.
parentMorphList
=
null
;
current
=
next
;
}
this
.
firstChildMorph
=
this
.
lastChildMorph
=
null
;
}
;
prototype
.
destroy
=
function
MorphList
destroy
(
)
{
}
;
prototype
.
appendMorph
=
function
MorphList
appendMorph
(
morph
)
{
this
.
insertBeforeMorph
(
morph
null
)
;
}
;
prototype
.
insertBeforeMorph
=
function
MorphList
insertBeforeMorph
(
morph
referenceMorph
)
{
if
(
morph
.
parentMorphList
!
=
=
null
)
{
morph
.
unlink
(
)
;
}
if
(
referenceMorph
&
&
referenceMorph
.
parentMorphList
!
=
=
this
)
{
throw
new
Error
(
'
The
morph
before
which
the
new
morph
is
to
be
inserted
is
not
a
child
of
this
morph
.
'
)
;
}
var
mountedMorph
=
this
.
mountedMorph
;
if
(
mountedMorph
)
{
var
parentNode
=
mountedMorph
.
firstNode
.
parentNode
;
var
referenceNode
=
referenceMorph
?
referenceMorph
.
firstNode
:
mountedMorph
.
lastNode
.
nextSibling
;
_morphRangeUtils
.
insertBefore
(
parentNode
morph
.
firstNode
morph
.
lastNode
referenceNode
)
;
if
(
!
this
.
firstChildMorph
)
{
_morphRangeUtils
.
clear
(
this
.
mountedMorph
.
firstNode
.
parentNode
this
.
mountedMorph
.
firstNode
this
.
mountedMorph
.
lastNode
)
;
}
}
morph
.
parentMorphList
=
this
;
var
previousMorph
=
referenceMorph
?
referenceMorph
.
previousMorph
:
this
.
lastChildMorph
;
if
(
previousMorph
)
{
previousMorph
.
nextMorph
=
morph
;
morph
.
previousMorph
=
previousMorph
;
}
else
{
this
.
firstChildMorph
=
morph
;
}
if
(
referenceMorph
)
{
referenceMorph
.
previousMorph
=
morph
;
morph
.
nextMorph
=
referenceMorph
;
}
else
{
this
.
lastChildMorph
=
morph
;
}
this
.
firstChildMorph
.
_syncFirstNode
(
)
;
this
.
lastChildMorph
.
_syncLastNode
(
)
;
}
;
prototype
.
removeChildMorph
=
function
MorphList
removeChildMorph
(
morph
)
{
if
(
morph
.
parentMorphList
!
=
=
this
)
{
throw
new
Error
(
"
Cannot
remove
a
morph
from
a
parent
it
is
not
inside
of
"
)
;
}
morph
.
destroy
(
)
;
}
;
exports
.
default
=
MorphList
;
}
)
;
enifed
(
'
morph
-
range
/
morph
-
list
.
umd
'
[
'
exports
'
'
morph
-
range
/
morph
-
list
'
]
function
(
exports
_morphRangeMorphList
)
{
'
use
strict
'
;
(
function
(
root
factory
)
{
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
{
define
(
[
]
factory
)
;
}
else
if
(
typeof
exports
=
=
=
'
object
'
)
{
module
.
exports
=
factory
(
)
;
}
else
{
root
.
MorphList
=
factory
(
)
;
}
}
)
(
undefined
function
(
)
{
return
_morphRangeMorphList
.
default
;
}
)
;
}
)
;
enifed
(
"
morph
-
range
/
utils
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
clear
=
clear
;
exports
.
insertBefore
=
insertBefore
;
function
clear
(
parentNode
firstNode
lastNode
)
{
if
(
!
parentNode
)
{
return
;
}
var
node
=
firstNode
;
var
nextNode
;
do
{
nextNode
=
node
.
nextSibling
;
parentNode
.
removeChild
(
node
)
;
if
(
node
=
=
=
lastNode
)
{
break
;
}
node
=
nextNode
;
}
while
(
node
)
;
}
function
insertBefore
(
parentNode
firstNode
lastNode
refNode
)
{
var
node
=
firstNode
;
var
nextNode
;
do
{
nextNode
=
node
.
nextSibling
;
parentNode
.
insertBefore
(
node
refNode
)
;
if
(
node
=
=
=
lastNode
)
{
break
;
}
node
=
nextNode
;
}
while
(
node
)
;
}
}
)
;
enifed
(
'
route
-
recognizer
'
[
'
exports
'
'
route
-
recognizer
/
dsl
'
]
function
(
exports
_routeRecognizerDsl
)
{
'
use
strict
'
;
var
specials
=
[
'
/
'
'
.
'
'
*
'
'
+
'
'
?
'
'
|
'
'
(
'
'
)
'
'
[
'
'
]
'
'
{
'
'
}
'
'
\
\
'
]
;
var
escapeRegex
=
new
RegExp
(
'
(
\
\
'
+
specials
.
join
(
'
|
\
\
'
)
+
'
)
'
'
g
'
)
;
function
isArray
(
test
)
{
return
Object
.
prototype
.
toString
.
call
(
test
)
=
=
=
"
[
object
Array
]
"
;
}
function
StaticSegment
(
string
)
{
this
.
string
=
string
;
}
StaticSegment
.
prototype
=
{
eachChar
:
function
(
callback
)
{
var
string
=
this
.
string
ch
;
for
(
var
i
=
0
l
=
string
.
length
;
i
<
l
;
i
+
+
)
{
ch
=
string
.
charAt
(
i
)
;
callback
(
{
validChars
:
ch
}
)
;
}
}
regex
:
function
(
)
{
return
this
.
string
.
replace
(
escapeRegex
'
\
\
1
'
)
;
}
generate
:
function
(
)
{
return
this
.
string
;
}
}
;
function
DynamicSegment
(
name
)
{
this
.
name
=
name
;
}
DynamicSegment
.
prototype
=
{
eachChar
:
function
(
callback
)
{
callback
(
{
invalidChars
:
"
/
"
repeat
:
true
}
)
;
}
regex
:
function
(
)
{
return
"
(
[
^
/
]
+
)
"
;
}
generate
:
function
(
params
)
{
return
params
[
this
.
name
]
;
}
}
;
function
StarSegment
(
name
)
{
this
.
name
=
name
;
}
StarSegment
.
prototype
=
{
eachChar
:
function
(
callback
)
{
callback
(
{
invalidChars
:
"
"
repeat
:
true
}
)
;
}
regex
:
function
(
)
{
return
"
(
.
+
)
"
;
}
generate
:
function
(
params
)
{
return
params
[
this
.
name
]
;
}
}
;
function
EpsilonSegment
(
)
{
}
EpsilonSegment
.
prototype
=
{
eachChar
:
function
(
)
{
}
regex
:
function
(
)
{
return
"
"
;
}
generate
:
function
(
)
{
return
"
"
;
}
}
;
function
parse
(
route
names
types
)
{
if
(
route
.
charAt
(
0
)
=
=
=
"
/
"
)
{
route
=
route
.
substr
(
1
)
;
}
var
segments
=
route
.
split
(
"
/
"
)
results
=
[
]
;
for
(
var
i
=
0
l
=
segments
.
length
;
i
<
l
;
i
+
+
)
{
var
segment
=
segments
[
i
]
match
;
if
(
match
=
segment
.
match
(
/
^
:
(
[
^
\
/
]
+
)
/
)
)
{
results
.
push
(
new
DynamicSegment
(
match
[
1
]
)
)
;
names
.
push
(
match
[
1
]
)
;
types
.
dynamics
+
+
;
}
else
if
(
match
=
segment
.
match
(
/
^
\
*
(
[
^
\
/
]
+
)
/
)
)
{
results
.
push
(
new
StarSegment
(
match
[
1
]
)
)
;
names
.
push
(
match
[
1
]
)
;
types
.
stars
+
+
;
}
else
if
(
segment
=
=
=
"
"
)
{
results
.
push
(
new
EpsilonSegment
(
)
)
;
}
else
{
results
.
push
(
new
StaticSegment
(
segment
)
)
;
types
.
statics
+
+
;
}
}
return
results
;
}
function
State
(
charSpec
)
{
this
.
charSpec
=
charSpec
;
this
.
nextStates
=
[
]
;
}
State
.
prototype
=
{
get
:
function
(
charSpec
)
{
var
nextStates
=
this
.
nextStates
;
for
(
var
i
=
0
l
=
nextStates
.
length
;
i
<
l
;
i
+
+
)
{
var
child
=
nextStates
[
i
]
;
var
isEqual
=
child
.
charSpec
.
validChars
=
=
=
charSpec
.
validChars
;
isEqual
=
isEqual
&
&
child
.
charSpec
.
invalidChars
=
=
=
charSpec
.
invalidChars
;
if
(
isEqual
)
{
return
child
;
}
}
}
put
:
function
(
charSpec
)
{
var
state
;
if
(
state
=
this
.
get
(
charSpec
)
)
{
return
state
;
}
state
=
new
State
(
charSpec
)
;
this
.
nextStates
.
push
(
state
)
;
if
(
charSpec
.
repeat
)
{
state
.
nextStates
.
push
(
state
)
;
}
return
state
;
}
match
:
function
(
ch
)
{
var
nextStates
=
this
.
nextStates
child
charSpec
chars
;
var
returned
=
[
]
;
for
(
var
i
=
0
l
=
nextStates
.
length
;
i
<
l
;
i
+
+
)
{
child
=
nextStates
[
i
]
;
charSpec
=
child
.
charSpec
;
if
(
typeof
(
chars
=
charSpec
.
validChars
)
!
=
=
'
undefined
'
)
{
if
(
chars
.
indexOf
(
ch
)
!
=
=
-
1
)
{
returned
.
push
(
child
)
;
}
}
else
if
(
typeof
(
chars
=
charSpec
.
invalidChars
)
!
=
=
'
undefined
'
)
{
if
(
chars
.
indexOf
(
ch
)
=
=
=
-
1
)
{
returned
.
push
(
child
)
;
}
}
}
return
returned
;
}
}
;
function
sortSolutions
(
states
)
{
return
states
.
sort
(
function
(
a
b
)
{
if
(
a
.
types
.
stars
!
=
=
b
.
types
.
stars
)
{
return
a
.
types
.
stars
-
b
.
types
.
stars
;
}
if
(
a
.
types
.
stars
)
{
if
(
a
.
types
.
statics
!
=
=
b
.
types
.
statics
)
{
return
b
.
types
.
statics
-
a
.
types
.
statics
;
}
if
(
a
.
types
.
dynamics
!
=
=
b
.
types
.
dynamics
)
{
return
b
.
types
.
dynamics
-
a
.
types
.
dynamics
;
}
}
if
(
a
.
types
.
dynamics
!
=
=
b
.
types
.
dynamics
)
{
return
a
.
types
.
dynamics
-
b
.
types
.
dynamics
;
}
if
(
a
.
types
.
statics
!
=
=
b
.
types
.
statics
)
{
return
b
.
types
.
statics
-
a
.
types
.
statics
;
}
return
0
;
}
)
;
}
function
recognizeChar
(
states
ch
)
{
var
nextStates
=
[
]
;
for
(
var
i
=
0
l
=
states
.
length
;
i
<
l
;
i
+
+
)
{
var
state
=
states
[
i
]
;
nextStates
=
nextStates
.
concat
(
state
.
match
(
ch
)
)
;
}
return
nextStates
;
}
var
oCreate
=
Object
.
create
|
|
function
(
proto
)
{
function
F
(
)
{
}
F
.
prototype
=
proto
;
return
new
F
(
)
;
}
;
function
RecognizeResults
(
queryParams
)
{
this
.
queryParams
=
queryParams
|
|
{
}
;
}
RecognizeResults
.
prototype
=
oCreate
(
{
splice
:
Array
.
prototype
.
splice
slice
:
Array
.
prototype
.
slice
push
:
Array
.
prototype
.
push
length
:
0
queryParams
:
null
}
)
;
function
findHandler
(
state
path
queryParams
)
{
var
handlers
=
state
.
handlers
regex
=
state
.
regex
;
var
captures
=
path
.
match
(
regex
)
currentCapture
=
1
;
var
result
=
new
RecognizeResults
(
queryParams
)
;
for
(
var
i
=
0
l
=
handlers
.
length
;
i
<
l
;
i
+
+
)
{
var
handler
=
handlers
[
i
]
names
=
handler
.
names
params
=
{
}
;
for
(
var
j
=
0
m
=
names
.
length
;
j
<
m
;
j
+
+
)
{
params
[
names
[
j
]
]
=
captures
[
currentCapture
+
+
]
;
}
result
.
push
(
{
handler
:
handler
.
handler
params
:
params
isDynamic
:
!
!
names
.
length
}
)
;
}
return
result
;
}
function
addSegment
(
currentState
segment
)
{
segment
.
eachChar
(
function
(
ch
)
{
var
state
;
currentState
=
currentState
.
put
(
ch
)
;
}
)
;
return
currentState
;
}
function
decodeQueryParamPart
(
part
)
{
part
=
part
.
replace
(
/
\
+
/
gm
'
%
20
'
)
;
return
decodeURIComponent
(
part
)
;
}
var
RouteRecognizer
=
function
(
)
{
this
.
rootState
=
new
State
(
)
;
this
.
names
=
{
}
;
}
;
RouteRecognizer
.
prototype
=
{
add
:
function
(
routes
options
)
{
var
currentState
=
this
.
rootState
regex
=
"
^
"
types
=
{
statics
:
0
dynamics
:
0
stars
:
0
}
handlers
=
[
]
allSegments
=
[
]
name
;
var
isEmpty
=
true
;
for
(
var
i
=
0
l
=
routes
.
length
;
i
<
l
;
i
+
+
)
{
var
route
=
routes
[
i
]
names
=
[
]
;
var
segments
=
parse
(
route
.
path
names
types
)
;
allSegments
=
allSegments
.
concat
(
segments
)
;
for
(
var
j
=
0
m
=
segments
.
length
;
j
<
m
;
j
+
+
)
{
var
segment
=
segments
[
j
]
;
if
(
segment
instanceof
EpsilonSegment
)
{
continue
;
}
isEmpty
=
false
;
currentState
=
currentState
.
put
(
{
validChars
:
"
/
"
}
)
;
regex
+
=
"
/
"
;
currentState
=
addSegment
(
currentState
segment
)
;
regex
+
=
segment
.
regex
(
)
;
}
var
handler
=
{
handler
:
route
.
handler
names
:
names
}
;
handlers
.
push
(
handler
)
;
}
if
(
isEmpty
)
{
currentState
=
currentState
.
put
(
{
validChars
:
"
/
"
}
)
;
regex
+
=
"
/
"
;
}
currentState
.
handlers
=
handlers
;
currentState
.
regex
=
new
RegExp
(
regex
+
"
"
)
;
currentState
.
types
=
types
;
if
(
name
=
options
&
&
options
.
as
)
{
this
.
names
[
name
]
=
{
segments
:
allSegments
handlers
:
handlers
}
;
}
}
handlersFor
:
function
(
name
)
{
var
route
=
this
.
names
[
name
]
result
=
[
]
;
if
(
!
route
)
{
throw
new
Error
(
"
There
is
no
route
named
"
+
name
)
;
}
for
(
var
i
=
0
l
=
route
.
handlers
.
length
;
i
<
l
;
i
+
+
)
{
result
.
push
(
route
.
handlers
[
i
]
)
;
}
return
result
;
}
hasRoute
:
function
(
name
)
{
return
!
!
this
.
names
[
name
]
;
}
generate
:
function
(
name
params
)
{
var
route
=
this
.
names
[
name
]
output
=
"
"
;
if
(
!
route
)
{
throw
new
Error
(
"
There
is
no
route
named
"
+
name
)
;
}
var
segments
=
route
.
segments
;
for
(
var
i
=
0
l
=
segments
.
length
;
i
<
l
;
i
+
+
)
{
var
segment
=
segments
[
i
]
;
if
(
segment
instanceof
EpsilonSegment
)
{
continue
;
}
output
+
=
"
/
"
;
output
+
=
segment
.
generate
(
params
)
;
}
if
(
output
.
charAt
(
0
)
!
=
=
'
/
'
)
{
output
=
'
/
'
+
output
;
}
if
(
params
&
&
params
.
queryParams
)
{
output
+
=
this
.
generateQueryString
(
params
.
queryParams
route
.
handlers
)
;
}
return
output
;
}
generateQueryString
:
function
(
params
handlers
)
{
var
pairs
=
[
]
;
var
keys
=
[
]
;
for
(
var
key
in
params
)
{
if
(
params
.
hasOwnProperty
(
key
)
)
{
keys
.
push
(
key
)
;
}
}
keys
.
sort
(
)
;
for
(
var
i
=
0
len
=
keys
.
length
;
i
<
len
;
i
+
+
)
{
key
=
keys
[
i
]
;
var
value
=
params
[
key
]
;
if
(
value
=
=
null
)
{
continue
;
}
var
pair
=
encodeURIComponent
(
key
)
;
if
(
isArray
(
value
)
)
{
for
(
var
j
=
0
l
=
value
.
length
;
j
<
l
;
j
+
+
)
{
var
arrayPair
=
key
+
'
[
]
'
+
'
=
'
+
encodeURIComponent
(
value
[
j
]
)
;
pairs
.
push
(
arrayPair
)
;
}
}
else
{
pair
+
=
"
=
"
+
encodeURIComponent
(
value
)
;
pairs
.
push
(
pair
)
;
}
}
if
(
pairs
.
length
=
=
=
0
)
{
return
'
'
;
}
return
"
?
"
+
pairs
.
join
(
"
&
"
)
;
}
parseQueryString
:
function
(
queryString
)
{
var
pairs
=
queryString
.
split
(
"
&
"
)
queryParams
=
{
}
;
for
(
var
i
=
0
;
i
<
pairs
.
length
;
i
+
+
)
{
var
pair
=
pairs
[
i
]
.
split
(
'
=
'
)
key
=
decodeQueryParamPart
(
pair
[
0
]
)
keyLength
=
key
.
length
isArray
=
false
value
;
if
(
pair
.
length
=
=
=
1
)
{
value
=
'
true
'
;
}
else
{
if
(
keyLength
>
2
&
&
key
.
slice
(
keyLength
-
2
)
=
=
=
'
[
]
'
)
{
isArray
=
true
;
key
=
key
.
slice
(
0
keyLength
-
2
)
;
if
(
!
queryParams
[
key
]
)
{
queryParams
[
key
]
=
[
]
;
}
}
value
=
pair
[
1
]
?
decodeQueryParamPart
(
pair
[
1
]
)
:
'
'
;
}
if
(
isArray
)
{
queryParams
[
key
]
.
push
(
value
)
;
}
else
{
queryParams
[
key
]
=
value
;
}
}
return
queryParams
;
}
recognize
:
function
(
path
)
{
var
states
=
[
this
.
rootState
]
pathLen
i
l
queryStart
queryParams
=
{
}
isSlashDropped
=
false
;
queryStart
=
path
.
indexOf
(
'
?
'
)
;
if
(
queryStart
!
=
=
-
1
)
{
var
queryString
=
path
.
substr
(
queryStart
+
1
path
.
length
)
;
path
=
path
.
substr
(
0
queryStart
)
;
queryParams
=
this
.
parseQueryString
(
queryString
)
;
}
path
=
decodeURI
(
path
)
;
if
(
path
.
charAt
(
0
)
!
=
=
"
/
"
)
{
path
=
"
/
"
+
path
;
}
pathLen
=
path
.
length
;
if
(
pathLen
>
1
&
&
path
.
charAt
(
pathLen
-
1
)
=
=
=
"
/
"
)
{
path
=
path
.
substr
(
0
pathLen
-
1
)
;
isSlashDropped
=
true
;
}
for
(
i
=
0
l
=
path
.
length
;
i
<
l
;
i
+
+
)
{
states
=
recognizeChar
(
states
path
.
charAt
(
i
)
)
;
if
(
!
states
.
length
)
{
break
;
}
}
var
solutions
=
[
]
;
for
(
i
=
0
l
=
states
.
length
;
i
<
l
;
i
+
+
)
{
if
(
states
[
i
]
.
handlers
)
{
solutions
.
push
(
states
[
i
]
)
;
}
}
states
=
sortSolutions
(
solutions
)
;
var
state
=
solutions
[
0
]
;
if
(
state
&
&
state
.
handlers
)
{
if
(
isSlashDropped
&
&
state
.
regex
.
source
.
slice
(
-
5
)
=
=
=
"
(
.
+
)
"
)
{
path
=
path
+
"
/
"
;
}
return
findHandler
(
state
path
queryParams
)
;
}
}
}
;
RouteRecognizer
.
prototype
.
map
=
_routeRecognizerDsl
.
default
;
RouteRecognizer
.
VERSION
=
'
0
.
1
.
5
'
;
exports
.
default
=
RouteRecognizer
;
}
)
;
enifed
(
"
route
-
recognizer
/
dsl
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
function
Target
(
path
matcher
delegate
)
{
this
.
path
=
path
;
this
.
matcher
=
matcher
;
this
.
delegate
=
delegate
;
}
Target
.
prototype
=
{
to
:
function
(
target
callback
)
{
var
delegate
=
this
.
delegate
;
if
(
delegate
&
&
delegate
.
willAddRoute
)
{
target
=
delegate
.
willAddRoute
(
this
.
matcher
.
target
target
)
;
}
this
.
matcher
.
add
(
this
.
path
target
)
;
if
(
callback
)
{
if
(
callback
.
length
=
=
=
0
)
{
throw
new
Error
(
"
You
must
have
an
argument
in
the
function
passed
to
to
"
)
;
}
this
.
matcher
.
addChild
(
this
.
path
target
callback
this
.
delegate
)
;
}
return
this
;
}
}
;
function
Matcher
(
target
)
{
this
.
routes
=
{
}
;
this
.
children
=
{
}
;
this
.
target
=
target
;
}
Matcher
.
prototype
=
{
add
:
function
(
path
handler
)
{
this
.
routes
[
path
]
=
handler
;
}
addChild
:
function
(
path
target
callback
delegate
)
{
var
matcher
=
new
Matcher
(
target
)
;
this
.
children
[
path
]
=
matcher
;
var
match
=
generateMatch
(
path
matcher
delegate
)
;
if
(
delegate
&
&
delegate
.
contextEntered
)
{
delegate
.
contextEntered
(
target
match
)
;
}
callback
(
match
)
;
}
}
;
function
generateMatch
(
startingPath
matcher
delegate
)
{
return
function
(
path
nestedCallback
)
{
var
fullPath
=
startingPath
+
path
;
if
(
nestedCallback
)
{
nestedCallback
(
generateMatch
(
fullPath
matcher
delegate
)
)
;
}
else
{
return
new
Target
(
startingPath
+
path
matcher
delegate
)
;
}
}
;
}
function
addRoute
(
routeArray
path
handler
)
{
var
len
=
0
;
for
(
var
i
=
0
l
=
routeArray
.
length
;
i
<
l
;
i
+
+
)
{
len
+
=
routeArray
[
i
]
.
path
.
length
;
}
path
=
path
.
substr
(
len
)
;
var
route
=
{
path
:
path
handler
:
handler
}
;
routeArray
.
push
(
route
)
;
}
function
eachRoute
(
baseRoute
matcher
callback
binding
)
{
var
routes
=
matcher
.
routes
;
for
(
var
path
in
routes
)
{
if
(
routes
.
hasOwnProperty
(
path
)
)
{
var
routeArray
=
baseRoute
.
slice
(
)
;
addRoute
(
routeArray
path
routes
[
path
]
)
;
if
(
matcher
.
children
[
path
]
)
{
eachRoute
(
routeArray
matcher
.
children
[
path
]
callback
binding
)
;
}
else
{
callback
.
call
(
binding
routeArray
)
;
}
}
}
}
exports
.
default
=
function
(
callback
addRouteCallback
)
{
var
matcher
=
new
Matcher
(
)
;
callback
(
generateMatch
(
"
"
matcher
this
.
delegate
)
)
;
eachRoute
(
[
]
matcher
function
(
route
)
{
if
(
addRouteCallback
)
{
addRouteCallback
(
this
route
)
;
}
else
{
this
.
add
(
route
)
;
}
}
this
)
;
}
;
}
)
;
enifed
(
'
router
'
[
'
exports
'
'
router
/
router
'
]
function
(
exports
_routerRouter
)
{
'
use
strict
'
;
exports
.
default
=
_routerRouter
.
default
;
}
)
;
enifed
(
'
router
/
handler
-
info
'
[
'
exports
'
'
router
/
utils
'
'
rsvp
/
promise
'
]
function
(
exports
_routerUtils
_rsvpPromise
)
{
'
use
strict
'
;
function
HandlerInfo
(
_props
)
{
var
props
=
_props
|
|
{
}
;
_routerUtils
.
merge
(
this
props
)
;
this
.
initialize
(
props
)
;
}
HandlerInfo
.
prototype
=
{
name
:
null
handler
:
null
params
:
null
context
:
null
factory
:
null
initialize
:
function
(
)
{
}
log
:
function
(
payload
message
)
{
if
(
payload
.
log
)
{
payload
.
log
(
this
.
name
+
'
:
'
+
message
)
;
}
}
promiseLabel
:
function
(
label
)
{
return
_routerUtils
.
promiseLabel
(
"
'
"
+
this
.
name
+
"
'
"
+
label
)
;
}
getUnresolved
:
function
(
)
{
return
this
;
}
serialize
:
function
(
)
{
return
this
.
params
|
|
{
}
;
}
resolve
:
function
(
shouldContinue
payload
)
{
var
checkForAbort
=
_routerUtils
.
bind
(
this
this
.
checkForAbort
shouldContinue
)
beforeModel
=
_routerUtils
.
bind
(
this
this
.
runBeforeModelHook
payload
)
model
=
_routerUtils
.
bind
(
this
this
.
getModel
payload
)
afterModel
=
_routerUtils
.
bind
(
this
this
.
runAfterModelHook
payload
)
becomeResolved
=
_routerUtils
.
bind
(
this
this
.
becomeResolved
payload
)
;
return
_rsvpPromise
.
default
.
resolve
(
undefined
this
.
promiseLabel
(
"
Start
handler
"
)
)
.
then
(
checkForAbort
null
this
.
promiseLabel
(
"
Check
for
abort
"
)
)
.
then
(
beforeModel
null
this
.
promiseLabel
(
"
Before
model
"
)
)
.
then
(
checkForAbort
null
this
.
promiseLabel
(
"
Check
if
aborted
during
'
beforeModel
'
hook
"
)
)
.
then
(
model
null
this
.
promiseLabel
(
"
Model
"
)
)
.
then
(
checkForAbort
null
this
.
promiseLabel
(
"
Check
if
aborted
in
'
model
'
hook
"
)
)
.
then
(
afterModel
null
this
.
promiseLabel
(
"
After
model
"
)
)
.
then
(
checkForAbort
null
this
.
promiseLabel
(
"
Check
if
aborted
in
'
afterModel
'
hook
"
)
)
.
then
(
becomeResolved
null
this
.
promiseLabel
(
"
Become
resolved
"
)
)
;
}
runBeforeModelHook
:
function
(
payload
)
{
if
(
payload
.
trigger
)
{
payload
.
trigger
(
true
'
willResolveModel
'
payload
this
.
handler
)
;
}
return
this
.
runSharedModelHook
(
payload
'
beforeModel
'
[
]
)
;
}
runAfterModelHook
:
function
(
payload
resolvedModel
)
{
var
name
=
this
.
name
;
this
.
stashResolvedModel
(
payload
resolvedModel
)
;
return
this
.
runSharedModelHook
(
payload
'
afterModel
'
[
resolvedModel
]
)
.
then
(
function
(
)
{
return
payload
.
resolvedModels
[
name
]
;
}
null
this
.
promiseLabel
(
"
Ignore
fulfillment
value
and
return
model
value
"
)
)
;
}
runSharedModelHook
:
function
(
payload
hookName
args
)
{
this
.
log
(
payload
"
calling
"
+
hookName
+
"
hook
"
)
;
if
(
this
.
queryParams
)
{
args
.
push
(
this
.
queryParams
)
;
}
args
.
push
(
payload
)
;
var
result
=
_routerUtils
.
applyHook
(
this
.
handler
hookName
args
)
;
if
(
result
&
&
result
.
isTransition
)
{
result
=
null
;
}
return
_rsvpPromise
.
default
.
resolve
(
result
this
.
promiseLabel
(
"
Resolve
value
returned
from
one
of
the
model
hooks
"
)
)
;
}
getModel
:
null
checkForAbort
:
function
(
shouldContinue
promiseValue
)
{
return
_rsvpPromise
.
default
.
resolve
(
shouldContinue
(
)
this
.
promiseLabel
(
"
Check
for
abort
"
)
)
.
then
(
function
(
)
{
return
promiseValue
;
}
null
this
.
promiseLabel
(
"
Ignore
fulfillment
value
and
continue
"
)
)
;
}
stashResolvedModel
:
function
(
payload
resolvedModel
)
{
payload
.
resolvedModels
=
payload
.
resolvedModels
|
|
{
}
;
payload
.
resolvedModels
[
this
.
name
]
=
resolvedModel
;
}
becomeResolved
:
function
(
payload
resolvedContext
)
{
var
params
=
this
.
serialize
(
resolvedContext
)
;
if
(
payload
)
{
this
.
stashResolvedModel
(
payload
resolvedContext
)
;
payload
.
params
=
payload
.
params
|
|
{
}
;
payload
.
params
[
this
.
name
]
=
params
;
}
return
this
.
factory
(
'
resolved
'
{
context
:
resolvedContext
name
:
this
.
name
handler
:
this
.
handler
params
:
params
}
)
;
}
shouldSupercede
:
function
(
other
)
{
if
(
!
other
)
{
return
true
;
}
var
contextsMatch
=
other
.
context
=
=
=
this
.
context
;
return
other
.
name
!
=
=
this
.
name
|
|
this
.
hasOwnProperty
(
'
context
'
)
&
&
!
contextsMatch
|
|
this
.
hasOwnProperty
(
'
params
'
)
&
&
!
paramsMatch
(
this
.
params
other
.
params
)
;
}
}
;
function
paramsMatch
(
a
b
)
{
if
(
!
a
^
!
b
)
{
return
false
;
}
if
(
!
a
)
{
return
true
;
}
for
(
var
k
in
a
)
{
if
(
a
.
hasOwnProperty
(
k
)
&
&
a
[
k
]
!
=
=
b
[
k
]
)
{
return
false
;
}
}
return
true
;
}
exports
.
default
=
HandlerInfo
;
}
)
;
enifed
(
'
router
/
handler
-
info
/
factory
'
[
'
exports
'
'
router
/
handler
-
info
/
resolved
-
handler
-
info
'
'
router
/
handler
-
info
/
unresolved
-
handler
-
info
-
by
-
object
'
'
router
/
handler
-
info
/
unresolved
-
handler
-
info
-
by
-
param
'
]
function
(
exports
_routerHandlerInfoResolvedHandlerInfo
_routerHandlerInfoUnresolvedHandlerInfoByObject
_routerHandlerInfoUnresolvedHandlerInfoByParam
)
{
'
use
strict
'
;
handlerInfoFactory
.
klasses
=
{
resolved
:
_routerHandlerInfoResolvedHandlerInfo
.
default
param
:
_routerHandlerInfoUnresolvedHandlerInfoByParam
.
default
object
:
_routerHandlerInfoUnresolvedHandlerInfoByObject
.
default
}
;
function
handlerInfoFactory
(
name
props
)
{
var
Ctor
=
handlerInfoFactory
.
klasses
[
name
]
handlerInfo
=
new
Ctor
(
props
|
|
{
}
)
;
handlerInfo
.
factory
=
handlerInfoFactory
;
return
handlerInfo
;
}
exports
.
default
=
handlerInfoFactory
;
}
)
;
enifed
(
'
router
/
handler
-
info
/
resolved
-
handler
-
info
'
[
'
exports
'
'
router
/
handler
-
info
'
'
router
/
utils
'
'
rsvp
/
promise
'
]
function
(
exports
_routerHandlerInfo
_routerUtils
_rsvpPromise
)
{
'
use
strict
'
;
var
ResolvedHandlerInfo
=
_routerUtils
.
subclass
(
_routerHandlerInfo
.
default
{
resolve
:
function
(
shouldContinue
payload
)
{
if
(
payload
&
&
payload
.
resolvedModels
)
{
payload
.
resolvedModels
[
this
.
name
]
=
this
.
context
;
}
return
_rsvpPromise
.
default
.
resolve
(
this
this
.
promiseLabel
(
"
Resolve
"
)
)
;
}
getUnresolved
:
function
(
)
{
return
this
.
factory
(
'
param
'
{
name
:
this
.
name
handler
:
this
.
handler
params
:
this
.
params
}
)
;
}
isResolved
:
true
}
)
;
exports
.
default
=
ResolvedHandlerInfo
;
}
)
;
enifed
(
'
router
/
handler
-
info
/
unresolved
-
handler
-
info
-
by
-
object
'
[
'
exports
'
'
router
/
handler
-
info
'
'
router
/
utils
'
'
rsvp
/
promise
'
]
function
(
exports
_routerHandlerInfo
_routerUtils
_rsvpPromise
)
{
'
use
strict
'
;
var
UnresolvedHandlerInfoByObject
=
_routerUtils
.
subclass
(
_routerHandlerInfo
.
default
{
getModel
:
function
(
payload
)
{
this
.
log
(
payload
this
.
name
+
"
:
resolving
provided
model
"
)
;
return
_rsvpPromise
.
default
.
resolve
(
this
.
context
)
;
}
initialize
:
function
(
props
)
{
this
.
names
=
props
.
names
|
|
[
]
;
this
.
context
=
props
.
context
;
}
serialize
:
function
(
_model
)
{
var
model
=
_model
|
|
this
.
context
names
=
this
.
names
handler
=
this
.
handler
;
var
object
=
{
}
;
if
(
_routerUtils
.
isParam
(
model
)
)
{
object
[
names
[
0
]
]
=
model
;
return
object
;
}
if
(
handler
.
serialize
)
{
return
handler
.
serialize
(
model
names
)
;
}
if
(
names
.
length
!
=
=
1
)
{
return
;
}
var
name
=
names
[
0
]
;
if
(
/
_id
/
.
test
(
name
)
)
{
object
[
name
]
=
model
.
id
;
}
else
{
object
[
name
]
=
model
;
}
return
object
;
}
}
)
;
exports
.
default
=
UnresolvedHandlerInfoByObject
;
}
)
;
enifed
(
'
router
/
handler
-
info
/
unresolved
-
handler
-
info
-
by
-
param
'
[
'
exports
'
'
router
/
handler
-
info
'
'
router
/
utils
'
]
function
(
exports
_routerHandlerInfo
_routerUtils
)
{
'
use
strict
'
;
var
UnresolvedHandlerInfoByParam
=
_routerUtils
.
subclass
(
_routerHandlerInfo
.
default
{
initialize
:
function
(
props
)
{
this
.
params
=
props
.
params
|
|
{
}
;
}
getModel
:
function
(
payload
)
{
var
fullParams
=
this
.
params
;
if
(
payload
&
&
payload
.
queryParams
)
{
fullParams
=
{
}
;
_routerUtils
.
merge
(
fullParams
this
.
params
)
;
fullParams
.
queryParams
=
payload
.
queryParams
;
}
var
handler
=
this
.
handler
;
var
hookName
=
_routerUtils
.
resolveHook
(
handler
'
deserialize
'
)
|
|
_routerUtils
.
resolveHook
(
handler
'
model
'
)
;
return
this
.
runSharedModelHook
(
payload
hookName
[
fullParams
]
)
;
}
}
)
;
exports
.
default
=
UnresolvedHandlerInfoByParam
;
}
)
;
enifed
(
'
router
/
router
'
[
'
exports
'
'
route
-
recognizer
'
'
rsvp
/
promise
'
'
router
/
utils
'
'
router
/
transition
-
state
'
'
router
/
transition
'
'
router
/
transition
-
intent
/
named
-
transition
-
intent
'
'
router
/
transition
-
intent
/
url
-
transition
-
intent
'
'
router
/
handler
-
info
'
]
function
(
exports
_routeRecognizer
_rsvpPromise
_routerUtils
_routerTransitionState
_routerTransition
_routerTransitionIntentNamedTransitionIntent
_routerTransitionIntentUrlTransitionIntent
_routerHandlerInfo
)
{
'
use
strict
'
;
var
pop
=
Array
.
prototype
.
pop
;
function
Router
(
_options
)
{
var
options
=
_options
|
|
{
}
;
this
.
getHandler
=
options
.
getHandler
|
|
this
.
getHandler
;
this
.
updateURL
=
options
.
updateURL
|
|
this
.
updateURL
;
this
.
replaceURL
=
options
.
replaceURL
|
|
this
.
replaceURL
;
this
.
didTransition
=
options
.
didTransition
|
|
this
.
didTransition
;
this
.
willTransition
=
options
.
willTransition
|
|
this
.
willTransition
;
this
.
delegate
=
options
.
delegate
|
|
this
.
delegate
;
this
.
triggerEvent
=
options
.
triggerEvent
|
|
this
.
triggerEvent
;
this
.
log
=
options
.
log
|
|
this
.
log
;
this
.
recognizer
=
new
_routeRecognizer
.
default
(
)
;
this
.
reset
(
)
;
}
function
getTransitionByIntent
(
intent
isIntermediate
)
{
var
wasTransitioning
=
!
!
this
.
activeTransition
;
var
oldState
=
wasTransitioning
?
this
.
activeTransition
.
state
:
this
.
state
;
var
newTransition
;
var
newState
=
intent
.
applyToState
(
oldState
this
.
recognizer
this
.
getHandler
isIntermediate
)
;
var
queryParamChangelist
=
_routerUtils
.
getChangelist
(
oldState
.
queryParams
newState
.
queryParams
)
;
if
(
handlerInfosEqual
(
newState
.
handlerInfos
oldState
.
handlerInfos
)
)
{
if
(
queryParamChangelist
)
{
newTransition
=
this
.
queryParamsTransition
(
queryParamChangelist
wasTransitioning
oldState
newState
)
;
if
(
newTransition
)
{
return
newTransition
;
}
}
return
this
.
activeTransition
|
|
new
_routerTransition
.
Transition
(
this
)
;
}
if
(
isIntermediate
)
{
setupContexts
(
this
newState
)
;
return
;
}
newTransition
=
new
_routerTransition
.
Transition
(
this
intent
newState
)
;
if
(
this
.
activeTransition
)
{
this
.
activeTransition
.
abort
(
)
;
}
this
.
activeTransition
=
newTransition
;
newTransition
.
promise
=
newTransition
.
promise
.
then
(
function
(
result
)
{
return
finalizeTransition
(
newTransition
result
.
state
)
;
}
null
_routerUtils
.
promiseLabel
(
"
Settle
transition
promise
when
transition
is
finalized
"
)
)
;
if
(
!
wasTransitioning
)
{
notifyExistingHandlers
(
this
newState
newTransition
)
;
}
fireQueryParamDidChange
(
this
newState
queryParamChangelist
)
;
return
newTransition
;
}
Router
.
prototype
=
{
map
:
function
(
callback
)
{
this
.
recognizer
.
delegate
=
this
.
delegate
;
this
.
recognizer
.
map
(
callback
function
(
recognizer
routes
)
{
for
(
var
i
=
routes
.
length
-
1
proceed
=
true
;
i
>
=
0
&
&
proceed
;
-
-
i
)
{
var
route
=
routes
[
i
]
;
recognizer
.
add
(
routes
{
as
:
route
.
handler
}
)
;
proceed
=
route
.
path
=
=
=
'
/
'
|
|
route
.
path
=
=
=
'
'
|
|
route
.
handler
.
slice
(
-
6
)
=
=
=
'
.
index
'
;
}
}
)
;
}
hasRoute
:
function
(
route
)
{
return
this
.
recognizer
.
hasRoute
(
route
)
;
}
getHandler
:
function
(
)
{
}
queryParamsTransition
:
function
(
changelist
wasTransitioning
oldState
newState
)
{
var
router
=
this
;
fireQueryParamDidChange
(
this
newState
changelist
)
;
if
(
!
wasTransitioning
&
&
this
.
activeTransition
)
{
return
this
.
activeTransition
;
}
else
{
var
newTransition
=
new
_routerTransition
.
Transition
(
this
)
;
newTransition
.
queryParamsOnly
=
true
;
oldState
.
queryParams
=
finalizeQueryParamChange
(
this
newState
.
handlerInfos
newState
.
queryParams
newTransition
)
;
newTransition
.
promise
=
newTransition
.
promise
.
then
(
function
(
result
)
{
updateURL
(
newTransition
oldState
true
)
;
if
(
router
.
didTransition
)
{
router
.
didTransition
(
router
.
currentHandlerInfos
)
;
}
return
result
;
}
null
_routerUtils
.
promiseLabel
(
"
Transition
complete
"
)
)
;
return
newTransition
;
}
}
transitionByIntent
:
function
(
intent
isIntermediate
)
{
try
{
return
getTransitionByIntent
.
apply
(
this
arguments
)
;
}
catch
(
e
)
{
return
new
_routerTransition
.
Transition
(
this
intent
null
e
)
;
}
}
reset
:
function
(
)
{
if
(
this
.
state
)
{
_routerUtils
.
forEach
(
this
.
state
.
handlerInfos
.
slice
(
)
.
reverse
(
)
function
(
handlerInfo
)
{
var
handler
=
handlerInfo
.
handler
;
_routerUtils
.
callHook
(
handler
'
exit
'
)
;
}
)
;
}
this
.
state
=
new
_routerTransitionState
.
default
(
)
;
this
.
currentHandlerInfos
=
null
;
}
activeTransition
:
null
handleURL
:
function
(
url
)
{
var
args
=
_routerUtils
.
slice
.
call
(
arguments
)
;
if
(
url
.
charAt
(
0
)
!
=
=
'
/
'
)
{
args
[
0
]
=
'
/
'
+
url
;
}
return
doTransition
(
this
args
)
.
method
(
null
)
;
}
updateURL
:
function
(
)
{
throw
new
Error
(
"
updateURL
is
not
implemented
"
)
;
}
replaceURL
:
function
(
url
)
{
this
.
updateURL
(
url
)
;
}
transitionTo
:
function
(
name
)
{
return
doTransition
(
this
arguments
)
;
}
intermediateTransitionTo
:
function
(
name
)
{
return
doTransition
(
this
arguments
true
)
;
}
refresh
:
function
(
pivotHandler
)
{
var
state
=
this
.
activeTransition
?
this
.
activeTransition
.
state
:
this
.
state
;
var
handlerInfos
=
state
.
handlerInfos
;
var
params
=
{
}
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
params
[
handlerInfo
.
name
]
=
handlerInfo
.
params
|
|
{
}
;
}
_routerUtils
.
log
(
this
"
Starting
a
refresh
transition
"
)
;
var
intent
=
new
_routerTransitionIntentNamedTransitionIntent
.
default
(
{
name
:
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
pivotHandler
:
pivotHandler
|
|
handlerInfos
[
0
]
.
handler
contexts
:
[
]
queryParams
:
this
.
_changedQueryParams
|
|
state
.
queryParams
|
|
{
}
}
)
;
return
this
.
transitionByIntent
(
intent
false
)
;
}
replaceWith
:
function
(
name
)
{
return
doTransition
(
this
arguments
)
.
method
(
'
replace
'
)
;
}
generate
:
function
(
handlerName
)
{
var
partitionedArgs
=
_routerUtils
.
extractQueryParams
(
_routerUtils
.
slice
.
call
(
arguments
1
)
)
suppliedParams
=
partitionedArgs
[
0
]
queryParams
=
partitionedArgs
[
1
]
;
var
intent
=
new
_routerTransitionIntentNamedTransitionIntent
.
default
(
{
name
:
handlerName
contexts
:
suppliedParams
}
)
;
var
state
=
intent
.
applyToState
(
this
.
state
this
.
recognizer
this
.
getHandler
)
;
var
params
=
{
}
;
for
(
var
i
=
0
len
=
state
.
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
state
.
handlerInfos
[
i
]
;
var
handlerParams
=
handlerInfo
.
serialize
(
)
;
_routerUtils
.
merge
(
params
handlerParams
)
;
}
params
.
queryParams
=
queryParams
;
return
this
.
recognizer
.
generate
(
handlerName
params
)
;
}
applyIntent
:
function
(
handlerName
contexts
)
{
var
intent
=
new
_routerTransitionIntentNamedTransitionIntent
.
default
(
{
name
:
handlerName
contexts
:
contexts
}
)
;
var
state
=
this
.
activeTransition
&
&
this
.
activeTransition
.
state
|
|
this
.
state
;
return
intent
.
applyToState
(
state
this
.
recognizer
this
.
getHandler
)
;
}
isActiveIntent
:
function
(
handlerName
contexts
queryParams
_state
)
{
var
state
=
_state
|
|
this
.
state
targetHandlerInfos
=
state
.
handlerInfos
found
=
false
names
object
handlerInfo
handlerObj
i
len
;
if
(
!
targetHandlerInfos
.
length
)
{
return
false
;
}
var
targetHandler
=
targetHandlerInfos
[
targetHandlerInfos
.
length
-
1
]
.
name
;
var
recogHandlers
=
this
.
recognizer
.
handlersFor
(
targetHandler
)
;
var
index
=
0
;
for
(
len
=
recogHandlers
.
length
;
index
<
len
;
+
+
index
)
{
handlerInfo
=
targetHandlerInfos
[
index
]
;
if
(
handlerInfo
.
name
=
=
=
handlerName
)
{
break
;
}
}
if
(
index
=
=
=
recogHandlers
.
length
)
{
return
false
;
}
var
testState
=
new
_routerTransitionState
.
default
(
)
;
testState
.
handlerInfos
=
targetHandlerInfos
.
slice
(
0
index
+
1
)
;
recogHandlers
=
recogHandlers
.
slice
(
0
index
+
1
)
;
var
intent
=
new
_routerTransitionIntentNamedTransitionIntent
.
default
(
{
name
:
targetHandler
contexts
:
contexts
}
)
;
var
newState
=
intent
.
applyToHandlers
(
testState
recogHandlers
this
.
getHandler
targetHandler
true
true
)
;
var
handlersEqual
=
handlerInfosEqual
(
newState
.
handlerInfos
testState
.
handlerInfos
)
;
if
(
!
queryParams
|
|
!
handlersEqual
)
{
return
handlersEqual
;
}
var
activeQPsOnNewHandler
=
{
}
;
_routerUtils
.
merge
(
activeQPsOnNewHandler
queryParams
)
;
var
activeQueryParams
=
state
.
queryParams
;
for
(
var
key
in
activeQueryParams
)
{
if
(
activeQueryParams
.
hasOwnProperty
(
key
)
&
&
activeQPsOnNewHandler
.
hasOwnProperty
(
key
)
)
{
activeQPsOnNewHandler
[
key
]
=
activeQueryParams
[
key
]
;
}
}
return
handlersEqual
&
&
!
_routerUtils
.
getChangelist
(
activeQPsOnNewHandler
queryParams
)
;
}
isActive
:
function
(
handlerName
)
{
var
partitionedArgs
=
_routerUtils
.
extractQueryParams
(
_routerUtils
.
slice
.
call
(
arguments
1
)
)
;
return
this
.
isActiveIntent
(
handlerName
partitionedArgs
[
0
]
partitionedArgs
[
1
]
)
;
}
trigger
:
function
(
name
)
{
var
args
=
_routerUtils
.
slice
.
call
(
arguments
)
;
_routerUtils
.
trigger
(
this
this
.
currentHandlerInfos
false
args
)
;
}
log
:
null
}
;
function
fireQueryParamDidChange
(
router
newState
queryParamChangelist
)
{
if
(
queryParamChangelist
)
{
router
.
_changedQueryParams
=
queryParamChangelist
.
all
;
_routerUtils
.
trigger
(
router
newState
.
handlerInfos
true
[
'
queryParamsDidChange
'
queryParamChangelist
.
changed
queryParamChangelist
.
all
queryParamChangelist
.
removed
]
)
;
router
.
_changedQueryParams
=
null
;
}
}
function
setupContexts
(
router
newState
transition
)
{
var
partition
=
partitionHandlers
(
router
.
state
newState
)
;
var
i
l
handler
;
for
(
i
=
0
l
=
partition
.
exited
.
length
;
i
<
l
;
i
+
+
)
{
handler
=
partition
.
exited
[
i
]
.
handler
;
delete
handler
.
context
;
_routerUtils
.
callHook
(
handler
'
reset
'
true
transition
)
;
_routerUtils
.
callHook
(
handler
'
exit
'
transition
)
;
}
var
oldState
=
router
.
oldState
=
router
.
state
;
router
.
state
=
newState
;
var
currentHandlerInfos
=
router
.
currentHandlerInfos
=
partition
.
unchanged
.
slice
(
)
;
try
{
for
(
i
=
0
l
=
partition
.
reset
.
length
;
i
<
l
;
i
+
+
)
{
handler
=
partition
.
reset
[
i
]
.
handler
;
_routerUtils
.
callHook
(
handler
'
reset
'
false
transition
)
;
}
for
(
i
=
0
l
=
partition
.
updatedContext
.
length
;
i
<
l
;
i
+
+
)
{
handlerEnteredOrUpdated
(
currentHandlerInfos
partition
.
updatedContext
[
i
]
false
transition
)
;
}
for
(
i
=
0
l
=
partition
.
entered
.
length
;
i
<
l
;
i
+
+
)
{
handlerEnteredOrUpdated
(
currentHandlerInfos
partition
.
entered
[
i
]
true
transition
)
;
}
}
catch
(
e
)
{
router
.
state
=
oldState
;
router
.
currentHandlerInfos
=
oldState
.
handlerInfos
;
throw
e
;
}
router
.
state
.
queryParams
=
finalizeQueryParamChange
(
router
currentHandlerInfos
newState
.
queryParams
transition
)
;
}
function
handlerEnteredOrUpdated
(
currentHandlerInfos
handlerInfo
enter
transition
)
{
var
handler
=
handlerInfo
.
handler
context
=
handlerInfo
.
context
;
if
(
enter
)
{
_routerUtils
.
callHook
(
handler
'
enter
'
transition
)
;
}
if
(
transition
&
&
transition
.
isAborted
)
{
throw
new
_routerTransition
.
TransitionAborted
(
)
;
}
handler
.
context
=
context
;
_routerUtils
.
callHook
(
handler
'
contextDidChange
'
)
;
_routerUtils
.
callHook
(
handler
'
setup
'
context
transition
)
;
if
(
transition
&
&
transition
.
isAborted
)
{
throw
new
_routerTransition
.
TransitionAborted
(
)
;
}
currentHandlerInfos
.
push
(
handlerInfo
)
;
return
true
;
}
function
partitionHandlers
(
oldState
newState
)
{
var
oldHandlers
=
oldState
.
handlerInfos
;
var
newHandlers
=
newState
.
handlerInfos
;
var
handlers
=
{
updatedContext
:
[
]
exited
:
[
]
entered
:
[
]
unchanged
:
[
]
}
;
var
handlerChanged
contextChanged
=
false
i
l
;
for
(
i
=
0
l
=
newHandlers
.
length
;
i
<
l
;
i
+
+
)
{
var
oldHandler
=
oldHandlers
[
i
]
newHandler
=
newHandlers
[
i
]
;
if
(
!
oldHandler
|
|
oldHandler
.
handler
!
=
=
newHandler
.
handler
)
{
handlerChanged
=
true
;
}
if
(
handlerChanged
)
{
handlers
.
entered
.
push
(
newHandler
)
;
if
(
oldHandler
)
{
handlers
.
exited
.
unshift
(
oldHandler
)
;
}
}
else
if
(
contextChanged
|
|
oldHandler
.
context
!
=
=
newHandler
.
context
)
{
contextChanged
=
true
;
handlers
.
updatedContext
.
push
(
newHandler
)
;
}
else
{
handlers
.
unchanged
.
push
(
oldHandler
)
;
}
}
for
(
i
=
newHandlers
.
length
l
=
oldHandlers
.
length
;
i
<
l
;
i
+
+
)
{
handlers
.
exited
.
unshift
(
oldHandlers
[
i
]
)
;
}
handlers
.
reset
=
handlers
.
updatedContext
.
slice
(
)
;
handlers
.
reset
.
reverse
(
)
;
return
handlers
;
}
function
updateURL
(
transition
state
inputUrl
)
{
var
urlMethod
=
transition
.
urlMethod
;
if
(
!
urlMethod
)
{
return
;
}
var
router
=
transition
.
router
handlerInfos
=
state
.
handlerInfos
handlerName
=
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
params
=
{
}
;
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
_routerUtils
.
merge
(
params
handlerInfo
.
params
)
;
if
(
handlerInfo
.
handler
.
inaccessibleByURL
)
{
urlMethod
=
null
;
}
}
if
(
urlMethod
)
{
params
.
queryParams
=
transition
.
_visibleQueryParams
|
|
state
.
queryParams
;
var
url
=
router
.
recognizer
.
generate
(
handlerName
params
)
;
if
(
urlMethod
=
=
=
'
replace
'
)
{
router
.
replaceURL
(
url
)
;
}
else
{
router
.
updateURL
(
url
)
;
}
}
}
function
finalizeTransition
(
transition
newState
)
{
try
{
_routerUtils
.
log
(
transition
.
router
transition
.
sequence
"
Resolved
all
models
on
destination
route
;
finalizing
transition
.
"
)
;
var
router
=
transition
.
router
handlerInfos
=
newState
.
handlerInfos
seq
=
transition
.
sequence
;
setupContexts
(
router
newState
transition
)
;
if
(
transition
.
isAborted
)
{
router
.
state
.
handlerInfos
=
router
.
currentHandlerInfos
;
return
_rsvpPromise
.
default
.
reject
(
_routerTransition
.
logAbort
(
transition
)
)
;
}
updateURL
(
transition
newState
transition
.
intent
.
url
)
;
transition
.
isActive
=
false
;
router
.
activeTransition
=
null
;
_routerUtils
.
trigger
(
router
router
.
currentHandlerInfos
true
[
'
didTransition
'
]
)
;
if
(
router
.
didTransition
)
{
router
.
didTransition
(
router
.
currentHandlerInfos
)
;
}
_routerUtils
.
log
(
router
transition
.
sequence
"
TRANSITION
COMPLETE
.
"
)
;
return
handlerInfos
[
handlerInfos
.
length
-
1
]
.
handler
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
_routerTransition
.
TransitionAborted
)
)
{
var
infos
=
transition
.
state
.
handlerInfos
;
transition
.
trigger
(
true
'
error
'
e
transition
infos
[
infos
.
length
-
1
]
.
handler
)
;
transition
.
abort
(
)
;
}
throw
e
;
}
}
function
doTransition
(
router
args
isIntermediate
)
{
var
name
=
args
[
0
]
|
|
'
/
'
;
var
lastArg
=
args
[
args
.
length
-
1
]
;
var
queryParams
=
{
}
;
if
(
lastArg
&
&
lastArg
.
hasOwnProperty
(
'
queryParams
'
)
)
{
queryParams
=
pop
.
call
(
args
)
.
queryParams
;
}
var
intent
;
if
(
args
.
length
=
=
=
0
)
{
_routerUtils
.
log
(
router
"
Updating
query
params
"
)
;
var
handlerInfos
=
router
.
state
.
handlerInfos
;
intent
=
new
_routerTransitionIntentNamedTransitionIntent
.
default
(
{
name
:
handlerInfos
[
handlerInfos
.
length
-
1
]
.
name
contexts
:
[
]
queryParams
:
queryParams
}
)
;
}
else
if
(
name
.
charAt
(
0
)
=
=
=
'
/
'
)
{
_routerUtils
.
log
(
router
"
Attempting
URL
transition
to
"
+
name
)
;
intent
=
new
_routerTransitionIntentUrlTransitionIntent
.
default
(
{
url
:
name
}
)
;
}
else
{
_routerUtils
.
log
(
router
"
Attempting
transition
to
"
+
name
)
;
intent
=
new
_routerTransitionIntentNamedTransitionIntent
.
default
(
{
name
:
args
[
0
]
contexts
:
_routerUtils
.
slice
.
call
(
args
1
)
queryParams
:
queryParams
}
)
;
}
return
router
.
transitionByIntent
(
intent
isIntermediate
)
;
}
function
handlerInfosEqual
(
handlerInfos
otherHandlerInfos
)
{
if
(
handlerInfos
.
length
!
=
=
otherHandlerInfos
.
length
)
{
return
false
;
}
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
if
(
handlerInfos
[
i
]
!
=
=
otherHandlerInfos
[
i
]
)
{
return
false
;
}
}
return
true
;
}
function
finalizeQueryParamChange
(
router
resolvedHandlers
newQueryParams
transition
)
{
for
(
var
k
in
newQueryParams
)
{
if
(
newQueryParams
.
hasOwnProperty
(
k
)
&
&
newQueryParams
[
k
]
=
=
=
null
)
{
delete
newQueryParams
[
k
]
;
}
}
var
finalQueryParamsArray
=
[
]
;
_routerUtils
.
trigger
(
router
resolvedHandlers
true
[
'
finalizeQueryParamChange
'
newQueryParams
finalQueryParamsArray
transition
]
)
;
if
(
transition
)
{
transition
.
_visibleQueryParams
=
{
}
;
}
var
finalQueryParams
=
{
}
;
for
(
var
i
=
0
len
=
finalQueryParamsArray
.
length
;
i
<
len
;
+
+
i
)
{
var
qp
=
finalQueryParamsArray
[
i
]
;
finalQueryParams
[
qp
.
key
]
=
qp
.
value
;
if
(
transition
&
&
qp
.
visible
!
=
=
false
)
{
transition
.
_visibleQueryParams
[
qp
.
key
]
=
qp
.
value
;
}
}
return
finalQueryParams
;
}
function
notifyExistingHandlers
(
router
newState
newTransition
)
{
var
oldHandlers
=
router
.
state
.
handlerInfos
changing
=
[
]
leavingIndex
=
null
leaving
leavingChecker
i
oldHandlerLen
oldHandler
newHandler
;
oldHandlerLen
=
oldHandlers
.
length
;
for
(
i
=
0
;
i
<
oldHandlerLen
;
i
+
+
)
{
oldHandler
=
oldHandlers
[
i
]
;
newHandler
=
newState
.
handlerInfos
[
i
]
;
if
(
!
newHandler
|
|
oldHandler
.
name
!
=
=
newHandler
.
name
)
{
leavingIndex
=
i
;
break
;
}
if
(
!
newHandler
.
isResolved
)
{
changing
.
push
(
oldHandler
)
;
}
}
if
(
leavingIndex
!
=
=
null
)
{
leaving
=
oldHandlers
.
slice
(
leavingIndex
oldHandlerLen
)
;
leavingChecker
=
function
(
name
)
{
for
(
var
h
=
0
len
=
leaving
.
length
;
h
<
len
;
h
+
+
)
{
if
(
leaving
[
h
]
.
name
=
=
=
name
)
{
return
true
;
}
}
return
false
;
}
;
}
_routerUtils
.
trigger
(
router
oldHandlers
true
[
'
willTransition
'
newTransition
]
)
;
if
(
router
.
willTransition
)
{
router
.
willTransition
(
oldHandlers
newState
.
handlerInfos
newTransition
)
;
}
}
exports
.
default
=
Router
;
}
)
;
enifed
(
'
router
/
transition
-
intent
'
[
'
exports
'
'
router
/
utils
'
]
function
(
exports
_routerUtils
)
{
'
use
strict
'
;
function
TransitionIntent
(
props
)
{
this
.
initialize
(
props
)
;
this
.
data
=
this
.
data
|
|
{
}
;
}
TransitionIntent
.
prototype
=
{
initialize
:
null
applyToState
:
null
}
;
exports
.
default
=
TransitionIntent
;
}
)
;
enifed
(
'
router
/
transition
-
intent
/
named
-
transition
-
intent
'
[
'
exports
'
'
router
/
transition
-
intent
'
'
router
/
transition
-
state
'
'
router
/
handler
-
info
/
factory
'
'
router
/
utils
'
]
function
(
exports
_routerTransitionIntent
_routerTransitionState
_routerHandlerInfoFactory
_routerUtils
)
{
'
use
strict
'
;
exports
.
default
=
_routerUtils
.
subclass
(
_routerTransitionIntent
.
default
{
name
:
null
pivotHandler
:
null
contexts
:
null
queryParams
:
null
initialize
:
function
(
props
)
{
this
.
name
=
props
.
name
;
this
.
pivotHandler
=
props
.
pivotHandler
;
this
.
contexts
=
props
.
contexts
|
|
[
]
;
this
.
queryParams
=
props
.
queryParams
;
}
applyToState
:
function
(
oldState
recognizer
getHandler
isIntermediate
)
{
var
partitionedArgs
=
_routerUtils
.
extractQueryParams
(
[
this
.
name
]
.
concat
(
this
.
contexts
)
)
pureArgs
=
partitionedArgs
[
0
]
queryParams
=
partitionedArgs
[
1
]
handlers
=
recognizer
.
handlersFor
(
pureArgs
[
0
]
)
;
var
targetRouteName
=
handlers
[
handlers
.
length
-
1
]
.
handler
;
return
this
.
applyToHandlers
(
oldState
handlers
getHandler
targetRouteName
isIntermediate
)
;
}
applyToHandlers
:
function
(
oldState
handlers
getHandler
targetRouteName
isIntermediate
checkingIfActive
)
{
var
i
len
;
var
newState
=
new
_routerTransitionState
.
default
(
)
;
var
objects
=
this
.
contexts
.
slice
(
0
)
;
var
invalidateIndex
=
handlers
.
length
;
if
(
this
.
pivotHandler
)
{
for
(
i
=
0
len
=
handlers
.
length
;
i
<
len
;
+
+
i
)
{
if
(
getHandler
(
handlers
[
i
]
.
handler
)
=
=
=
this
.
pivotHandler
)
{
invalidateIndex
=
i
;
break
;
}
}
}
var
pivotHandlerFound
=
!
this
.
pivotHandler
;
for
(
i
=
handlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
result
=
handlers
[
i
]
;
var
name
=
result
.
handler
;
var
handler
=
getHandler
(
name
)
;
var
oldHandlerInfo
=
oldState
.
handlerInfos
[
i
]
;
var
newHandlerInfo
=
null
;
if
(
result
.
names
.
length
>
0
)
{
if
(
i
>
=
invalidateIndex
)
{
newHandlerInfo
=
this
.
createParamHandlerInfo
(
name
handler
result
.
names
objects
oldHandlerInfo
)
;
}
else
{
newHandlerInfo
=
this
.
getHandlerInfoForDynamicSegment
(
name
handler
result
.
names
objects
oldHandlerInfo
targetRouteName
i
)
;
}
}
else
{
newHandlerInfo
=
this
.
createParamHandlerInfo
(
name
handler
result
.
names
objects
oldHandlerInfo
)
;
}
if
(
checkingIfActive
)
{
newHandlerInfo
=
newHandlerInfo
.
becomeResolved
(
null
newHandlerInfo
.
context
)
;
var
oldContext
=
oldHandlerInfo
&
&
oldHandlerInfo
.
context
;
if
(
result
.
names
.
length
>
0
&
&
newHandlerInfo
.
context
=
=
=
oldContext
)
{
newHandlerInfo
.
params
=
oldHandlerInfo
&
&
oldHandlerInfo
.
params
;
}
newHandlerInfo
.
context
=
oldContext
;
}
var
handlerToUse
=
oldHandlerInfo
;
if
(
i
>
=
invalidateIndex
|
|
newHandlerInfo
.
shouldSupercede
(
oldHandlerInfo
)
)
{
invalidateIndex
=
Math
.
min
(
i
invalidateIndex
)
;
handlerToUse
=
newHandlerInfo
;
}
if
(
isIntermediate
&
&
!
checkingIfActive
)
{
handlerToUse
=
handlerToUse
.
becomeResolved
(
null
handlerToUse
.
context
)
;
}
newState
.
handlerInfos
.
unshift
(
handlerToUse
)
;
}
if
(
objects
.
length
>
0
)
{
throw
new
Error
(
"
More
context
objects
were
passed
than
there
are
dynamic
segments
for
the
route
:
"
+
targetRouteName
)
;
}
if
(
!
isIntermediate
)
{
this
.
invalidateChildren
(
newState
.
handlerInfos
invalidateIndex
)
;
}
_routerUtils
.
merge
(
newState
.
queryParams
this
.
queryParams
|
|
{
}
)
;
return
newState
;
}
invalidateChildren
:
function
(
handlerInfos
invalidateIndex
)
{
for
(
var
i
=
invalidateIndex
l
=
handlerInfos
.
length
;
i
<
l
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
handlerInfos
[
i
]
=
handlerInfos
[
i
]
.
getUnresolved
(
)
;
}
}
getHandlerInfoForDynamicSegment
:
function
(
name
handler
names
objects
oldHandlerInfo
targetRouteName
i
)
{
var
numNames
=
names
.
length
;
var
objectToUse
;
if
(
objects
.
length
>
0
)
{
objectToUse
=
objects
[
objects
.
length
-
1
]
;
if
(
_routerUtils
.
isParam
(
objectToUse
)
)
{
return
this
.
createParamHandlerInfo
(
name
handler
names
objects
oldHandlerInfo
)
;
}
else
{
objects
.
pop
(
)
;
}
}
else
if
(
oldHandlerInfo
&
&
oldHandlerInfo
.
name
=
=
=
name
)
{
return
oldHandlerInfo
;
}
else
{
if
(
this
.
preTransitionState
)
{
var
preTransitionHandlerInfo
=
this
.
preTransitionState
.
handlerInfos
[
i
]
;
objectToUse
=
preTransitionHandlerInfo
&
&
preTransitionHandlerInfo
.
context
;
}
else
{
return
oldHandlerInfo
;
}
}
return
_routerHandlerInfoFactory
.
default
(
'
object
'
{
name
:
name
handler
:
handler
context
:
objectToUse
names
:
names
}
)
;
}
createParamHandlerInfo
:
function
(
name
handler
names
objects
oldHandlerInfo
)
{
var
params
=
{
}
;
var
numNames
=
names
.
length
;
while
(
numNames
-
-
)
{
var
oldParams
=
oldHandlerInfo
&
&
name
=
=
=
oldHandlerInfo
.
name
&
&
oldHandlerInfo
.
params
|
|
{
}
;
var
peek
=
objects
[
objects
.
length
-
1
]
;
var
paramName
=
names
[
numNames
]
;
if
(
_routerUtils
.
isParam
(
peek
)
)
{
params
[
paramName
]
=
"
"
+
objects
.
pop
(
)
;
}
else
{
if
(
oldParams
.
hasOwnProperty
(
paramName
)
)
{
params
[
paramName
]
=
oldParams
[
paramName
]
;
}
else
{
throw
new
Error
(
"
You
didn
'
t
provide
enough
string
/
numeric
parameters
to
satisfy
all
of
the
dynamic
segments
for
route
"
+
name
)
;
}
}
}
return
_routerHandlerInfoFactory
.
default
(
'
param
'
{
name
:
name
handler
:
handler
params
:
params
}
)
;
}
}
)
;
}
)
;
enifed
(
'
router
/
transition
-
intent
/
url
-
transition
-
intent
'
[
'
exports
'
'
router
/
transition
-
intent
'
'
router
/
transition
-
state
'
'
router
/
handler
-
info
/
factory
'
'
router
/
utils
'
'
router
/
unrecognized
-
url
-
error
'
]
function
(
exports
_routerTransitionIntent
_routerTransitionState
_routerHandlerInfoFactory
_routerUtils
_routerUnrecognizedUrlError
)
{
'
use
strict
'
;
exports
.
default
=
_routerUtils
.
subclass
(
_routerTransitionIntent
.
default
{
url
:
null
initialize
:
function
(
props
)
{
this
.
url
=
props
.
url
;
}
applyToState
:
function
(
oldState
recognizer
getHandler
)
{
var
newState
=
new
_routerTransitionState
.
default
(
)
;
var
results
=
recognizer
.
recognize
(
this
.
url
)
queryParams
=
{
}
i
len
;
if
(
!
results
)
{
throw
new
_routerUnrecognizedUrlError
.
default
(
this
.
url
)
;
}
var
statesDiffer
=
false
;
for
(
i
=
0
len
=
results
.
length
;
i
<
len
;
+
+
i
)
{
var
result
=
results
[
i
]
;
var
name
=
result
.
handler
;
var
handler
=
getHandler
(
name
)
;
if
(
handler
.
inaccessibleByURL
)
{
throw
new
_routerUnrecognizedUrlError
.
default
(
this
.
url
)
;
}
var
newHandlerInfo
=
_routerHandlerInfoFactory
.
default
(
'
param
'
{
name
:
name
handler
:
handler
params
:
result
.
params
}
)
;
var
oldHandlerInfo
=
oldState
.
handlerInfos
[
i
]
;
if
(
statesDiffer
|
|
newHandlerInfo
.
shouldSupercede
(
oldHandlerInfo
)
)
{
statesDiffer
=
true
;
newState
.
handlerInfos
[
i
]
=
newHandlerInfo
;
}
else
{
newState
.
handlerInfos
[
i
]
=
oldHandlerInfo
;
}
}
_routerUtils
.
merge
(
newState
.
queryParams
results
.
queryParams
)
;
return
newState
;
}
}
)
;
}
)
;
enifed
(
'
router
/
transition
-
state
'
[
'
exports
'
'
router
/
handler
-
info
'
'
router
/
utils
'
'
rsvp
/
promise
'
]
function
(
exports
_routerHandlerInfo
_routerUtils
_rsvpPromise
)
{
'
use
strict
'
;
function
TransitionState
(
other
)
{
this
.
handlerInfos
=
[
]
;
this
.
queryParams
=
{
}
;
this
.
params
=
{
}
;
}
TransitionState
.
prototype
=
{
handlerInfos
:
null
queryParams
:
null
params
:
null
promiseLabel
:
function
(
label
)
{
var
targetName
=
'
'
;
_routerUtils
.
forEach
(
this
.
handlerInfos
function
(
handlerInfo
)
{
if
(
targetName
!
=
=
'
'
)
{
targetName
+
=
'
.
'
;
}
targetName
+
=
handlerInfo
.
name
;
}
)
;
return
_routerUtils
.
promiseLabel
(
"
'
"
+
targetName
+
"
'
:
"
+
label
)
;
}
resolve
:
function
(
shouldContinue
payload
)
{
var
self
=
this
;
var
params
=
this
.
params
;
_routerUtils
.
forEach
(
this
.
handlerInfos
function
(
handlerInfo
)
{
params
[
handlerInfo
.
name
]
=
handlerInfo
.
params
|
|
{
}
;
}
)
;
payload
=
payload
|
|
{
}
;
payload
.
resolveIndex
=
0
;
var
currentState
=
this
;
var
wasAborted
=
false
;
return
_rsvpPromise
.
default
.
resolve
(
null
this
.
promiseLabel
(
"
Start
transition
"
)
)
.
then
(
resolveOneHandlerInfo
null
this
.
promiseLabel
(
'
Resolve
handler
'
)
)
[
'
catch
'
]
(
handleError
this
.
promiseLabel
(
'
Handle
error
'
)
)
;
function
innerShouldContinue
(
)
{
return
_rsvpPromise
.
default
.
resolve
(
shouldContinue
(
)
currentState
.
promiseLabel
(
"
Check
if
should
continue
"
)
)
[
'
catch
'
]
(
function
(
reason
)
{
wasAborted
=
true
;
return
_rsvpPromise
.
default
.
reject
(
reason
)
;
}
currentState
.
promiseLabel
(
"
Handle
abort
"
)
)
;
}
function
handleError
(
error
)
{
var
handlerInfos
=
currentState
.
handlerInfos
;
var
errorHandlerIndex
=
payload
.
resolveIndex
>
=
handlerInfos
.
length
?
handlerInfos
.
length
-
1
:
payload
.
resolveIndex
;
return
_rsvpPromise
.
default
.
reject
(
{
error
:
error
handlerWithError
:
currentState
.
handlerInfos
[
errorHandlerIndex
]
.
handler
wasAborted
:
wasAborted
state
:
currentState
}
)
;
}
function
proceed
(
resolvedHandlerInfo
)
{
var
wasAlreadyResolved
=
currentState
.
handlerInfos
[
payload
.
resolveIndex
]
.
isResolved
;
currentState
.
handlerInfos
[
payload
.
resolveIndex
+
+
]
=
resolvedHandlerInfo
;
if
(
!
wasAlreadyResolved
)
{
var
handler
=
resolvedHandlerInfo
.
handler
;
_routerUtils
.
callHook
(
handler
'
redirect
'
resolvedHandlerInfo
.
context
payload
)
;
}
return
innerShouldContinue
(
)
.
then
(
resolveOneHandlerInfo
null
currentState
.
promiseLabel
(
'
Resolve
handler
'
)
)
;
}
function
resolveOneHandlerInfo
(
)
{
if
(
payload
.
resolveIndex
=
=
=
currentState
.
handlerInfos
.
length
)
{
return
{
error
:
null
state
:
currentState
}
;
}
var
handlerInfo
=
currentState
.
handlerInfos
[
payload
.
resolveIndex
]
;
return
handlerInfo
.
resolve
(
innerShouldContinue
payload
)
.
then
(
proceed
null
currentState
.
promiseLabel
(
'
Proceed
'
)
)
;
}
}
}
;
exports
.
default
=
TransitionState
;
}
)
;
enifed
(
'
router
/
transition
'
[
'
exports
'
'
rsvp
/
promise
'
'
router
/
handler
-
info
'
'
router
/
utils
'
]
function
(
exports
_rsvpPromise
_routerHandlerInfo
_routerUtils
)
{
'
use
strict
'
;
function
Transition
(
router
intent
state
error
)
{
var
transition
=
this
;
this
.
state
=
state
|
|
router
.
state
;
this
.
intent
=
intent
;
this
.
router
=
router
;
this
.
data
=
this
.
intent
&
&
this
.
intent
.
data
|
|
{
}
;
this
.
resolvedModels
=
{
}
;
this
.
queryParams
=
{
}
;
if
(
error
)
{
this
.
promise
=
_rsvpPromise
.
default
.
reject
(
error
)
;
this
.
error
=
error
;
return
;
}
if
(
state
)
{
this
.
params
=
state
.
params
;
this
.
queryParams
=
state
.
queryParams
;
this
.
handlerInfos
=
state
.
handlerInfos
;
var
len
=
state
.
handlerInfos
.
length
;
if
(
len
)
{
this
.
targetName
=
state
.
handlerInfos
[
len
-
1
]
.
name
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
state
.
handlerInfos
[
i
]
;
if
(
!
handlerInfo
.
isResolved
)
{
break
;
}
this
.
pivotHandler
=
handlerInfo
.
handler
;
}
this
.
sequence
=
Transition
.
currentSequence
+
+
;
this
.
promise
=
state
.
resolve
(
checkForAbort
this
)
[
'
catch
'
]
(
function
(
result
)
{
if
(
result
.
wasAborted
|
|
transition
.
isAborted
)
{
return
_rsvpPromise
.
default
.
reject
(
logAbort
(
transition
)
)
;
}
else
{
transition
.
trigger
(
'
error
'
result
.
error
transition
result
.
handlerWithError
)
;
transition
.
abort
(
)
;
return
_rsvpPromise
.
default
.
reject
(
result
.
error
)
;
}
}
_routerUtils
.
promiseLabel
(
'
Handle
Abort
'
)
)
;
}
else
{
this
.
promise
=
_rsvpPromise
.
default
.
resolve
(
this
.
state
)
;
this
.
params
=
{
}
;
}
function
checkForAbort
(
)
{
if
(
transition
.
isAborted
)
{
return
_rsvpPromise
.
default
.
reject
(
undefined
_routerUtils
.
promiseLabel
(
"
Transition
aborted
-
reject
"
)
)
;
}
}
}
Transition
.
currentSequence
=
0
;
Transition
.
prototype
=
{
targetName
:
null
urlMethod
:
'
update
'
intent
:
null
params
:
null
pivotHandler
:
null
resolveIndex
:
0
handlerInfos
:
null
resolvedModels
:
null
isActive
:
true
state
:
null
queryParamsOnly
:
false
isTransition
:
true
isExiting
:
function
(
handler
)
{
var
handlerInfos
=
this
.
handlerInfos
;
for
(
var
i
=
0
len
=
handlerInfos
.
length
;
i
<
len
;
+
+
i
)
{
var
handlerInfo
=
handlerInfos
[
i
]
;
if
(
handlerInfo
.
name
=
=
=
handler
|
|
handlerInfo
.
handler
=
=
=
handler
)
{
return
false
;
}
}
return
true
;
}
promise
:
null
data
:
null
then
:
function
(
onFulfilled
onRejected
label
)
{
return
this
.
promise
.
then
(
onFulfilled
onRejected
label
)
;
}
catch
:
function
(
onRejection
label
)
{
return
this
.
promise
.
catch
(
onRejection
label
)
;
}
finally
:
function
(
callback
label
)
{
return
this
.
promise
.
finally
(
callback
label
)
;
}
abort
:
function
(
)
{
if
(
this
.
isAborted
)
{
return
this
;
}
_routerUtils
.
log
(
this
.
router
this
.
sequence
this
.
targetName
+
"
:
transition
was
aborted
"
)
;
this
.
intent
.
preTransitionState
=
this
.
router
.
state
;
this
.
isAborted
=
true
;
this
.
isActive
=
false
;
this
.
router
.
activeTransition
=
null
;
return
this
;
}
retry
:
function
(
)
{
this
.
abort
(
)
;
return
this
.
router
.
transitionByIntent
(
this
.
intent
false
)
;
}
method
:
function
(
method
)
{
this
.
urlMethod
=
method
;
return
this
;
}
trigger
:
function
(
ignoreFailure
)
{
var
args
=
_routerUtils
.
slice
.
call
(
arguments
)
;
if
(
typeof
ignoreFailure
=
=
=
'
boolean
'
)
{
args
.
shift
(
)
;
}
else
{
ignoreFailure
=
false
;
}
_routerUtils
.
trigger
(
this
.
router
this
.
state
.
handlerInfos
.
slice
(
0
this
.
resolveIndex
+
1
)
ignoreFailure
args
)
;
}
followRedirects
:
function
(
)
{
var
router
=
this
.
router
;
return
this
.
promise
[
'
catch
'
]
(
function
(
reason
)
{
if
(
router
.
activeTransition
)
{
return
router
.
activeTransition
.
followRedirects
(
)
;
}
return
_rsvpPromise
.
default
.
reject
(
reason
)
;
}
)
;
}
toString
:
function
(
)
{
return
"
Transition
(
sequence
"
+
this
.
sequence
+
"
)
"
;
}
log
:
function
(
message
)
{
_routerUtils
.
log
(
this
.
router
this
.
sequence
message
)
;
}
}
;
Transition
.
prototype
.
send
=
Transition
.
prototype
.
trigger
;
function
logAbort
(
transition
)
{
_routerUtils
.
log
(
transition
.
router
transition
.
sequence
"
detected
abort
.
"
)
;
return
new
TransitionAborted
(
)
;
}
function
TransitionAborted
(
message
)
{
this
.
message
=
message
|
|
"
TransitionAborted
"
;
this
.
name
=
"
TransitionAborted
"
;
}
exports
.
Transition
=
Transition
;
exports
.
logAbort
=
logAbort
;
exports
.
TransitionAborted
=
TransitionAborted
;
}
)
;
enifed
(
"
router
/
unrecognized
-
url
-
error
"
[
"
exports
"
"
router
/
utils
"
]
function
(
exports
_routerUtils
)
{
"
use
strict
"
;
function
UnrecognizedURLError
(
message
)
{
this
.
message
=
message
|
|
"
UnrecognizedURLError
"
;
this
.
name
=
"
UnrecognizedURLError
"
;
Error
.
call
(
this
)
;
}
UnrecognizedURLError
.
prototype
=
_routerUtils
.
oCreate
(
Error
.
prototype
)
;
exports
.
default
=
UnrecognizedURLError
;
}
)
;
enifed
(
'
router
/
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
extractQueryParams
=
extractQueryParams
;
exports
.
log
=
log
;
exports
.
bind
=
bind
;
exports
.
forEach
=
forEach
;
exports
.
trigger
=
trigger
;
exports
.
getChangelist
=
getChangelist
;
exports
.
promiseLabel
=
promiseLabel
;
exports
.
subclass
=
subclass
;
var
slice
=
Array
.
prototype
.
slice
;
var
_isArray
;
if
(
!
Array
.
isArray
)
{
_isArray
=
function
(
x
)
{
return
Object
.
prototype
.
toString
.
call
(
x
)
=
=
=
"
[
object
Array
]
"
;
}
;
}
else
{
_isArray
=
Array
.
isArray
;
}
var
isArray
=
_isArray
;
exports
.
isArray
=
isArray
;
function
merge
(
hash
other
)
{
for
(
var
prop
in
other
)
{
if
(
other
.
hasOwnProperty
(
prop
)
)
{
hash
[
prop
]
=
other
[
prop
]
;
}
}
}
var
oCreate
=
Object
.
create
|
|
function
(
proto
)
{
function
F
(
)
{
}
F
.
prototype
=
proto
;
return
new
F
(
)
;
}
;
exports
.
oCreate
=
oCreate
;
function
extractQueryParams
(
array
)
{
var
len
=
array
&
&
array
.
length
head
queryParams
;
if
(
len
&
&
len
>
0
&
&
array
[
len
-
1
]
&
&
array
[
len
-
1
]
.
hasOwnProperty
(
'
queryParams
'
)
)
{
queryParams
=
array
[
len
-
1
]
.
queryParams
;
head
=
slice
.
call
(
array
0
len
-
1
)
;
return
[
head
queryParams
]
;
}
else
{
return
[
array
null
]
;
}
}
function
coerceQueryParamsToString
(
queryParams
)
{
for
(
var
key
in
queryParams
)
{
if
(
typeof
queryParams
[
key
]
=
=
=
'
number
'
)
{
queryParams
[
key
]
=
'
'
+
queryParams
[
key
]
;
}
else
if
(
isArray
(
queryParams
[
key
]
)
)
{
for
(
var
i
=
0
l
=
queryParams
[
key
]
.
length
;
i
<
l
;
i
+
+
)
{
queryParams
[
key
]
[
i
]
=
'
'
+
queryParams
[
key
]
[
i
]
;
}
}
}
}
function
log
(
router
sequence
msg
)
{
if
(
!
router
.
log
)
{
return
;
}
if
(
arguments
.
length
=
=
=
3
)
{
router
.
log
(
"
Transition
#
"
+
sequence
+
"
:
"
+
msg
)
;
}
else
{
msg
=
sequence
;
router
.
log
(
msg
)
;
}
}
function
bind
(
context
fn
)
{
var
boundArgs
=
arguments
;
return
function
(
value
)
{
var
args
=
slice
.
call
(
boundArgs
2
)
;
args
.
push
(
value
)
;
return
fn
.
apply
(
context
args
)
;
}
;
}
function
isParam
(
object
)
{
return
typeof
object
=
=
=
"
string
"
|
|
object
instanceof
String
|
|
typeof
object
=
=
=
"
number
"
|
|
object
instanceof
Number
;
}
function
forEach
(
array
callback
)
{
for
(
var
i
=
0
l
=
array
.
length
;
i
<
l
&
&
false
!
=
=
callback
(
array
[
i
]
)
;
i
+
+
)
{
}
}
function
trigger
(
router
handlerInfos
ignoreFailure
args
)
{
if
(
router
.
triggerEvent
)
{
router
.
triggerEvent
(
handlerInfos
ignoreFailure
args
)
;
return
;
}
var
name
=
args
.
shift
(
)
;
if
(
!
handlerInfos
)
{
if
(
ignoreFailure
)
{
return
;
}
throw
new
Error
(
"
Could
not
trigger
event
'
"
+
name
+
"
'
.
There
are
no
active
handlers
"
)
;
}
var
eventWasHandled
=
false
;
for
(
var
i
=
handlerInfos
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
handlerInfo
=
handlerInfos
[
i
]
handler
=
handlerInfo
.
handler
;
if
(
handler
.
events
&
&
handler
.
events
[
name
]
)
{
if
(
handler
.
events
[
name
]
.
apply
(
handler
args
)
=
=
=
true
)
{
eventWasHandled
=
true
;
}
else
{
return
;
}
}
}
if
(
!
eventWasHandled
&
&
!
ignoreFailure
)
{
throw
new
Error
(
"
Nothing
handled
the
event
'
"
+
name
+
"
'
.
"
)
;
}
}
function
getChangelist
(
oldObject
newObject
)
{
var
key
;
var
results
=
{
all
:
{
}
changed
:
{
}
removed
:
{
}
}
;
merge
(
results
.
all
newObject
)
;
var
didChange
=
false
;
coerceQueryParamsToString
(
oldObject
)
;
coerceQueryParamsToString
(
newObject
)
;
for
(
key
in
oldObject
)
{
if
(
oldObject
.
hasOwnProperty
(
key
)
)
{
if
(
!
newObject
.
hasOwnProperty
(
key
)
)
{
didChange
=
true
;
results
.
removed
[
key
]
=
oldObject
[
key
]
;
}
}
}
for
(
key
in
newObject
)
{
if
(
newObject
.
hasOwnProperty
(
key
)
)
{
if
(
isArray
(
oldObject
[
key
]
)
&
&
isArray
(
newObject
[
key
]
)
)
{
if
(
oldObject
[
key
]
.
length
!
=
=
newObject
[
key
]
.
length
)
{
results
.
changed
[
key
]
=
newObject
[
key
]
;
didChange
=
true
;
}
else
{
for
(
var
i
=
0
l
=
oldObject
[
key
]
.
length
;
i
<
l
;
i
+
+
)
{
if
(
oldObject
[
key
]
[
i
]
!
=
=
newObject
[
key
]
[
i
]
)
{
results
.
changed
[
key
]
=
newObject
[
key
]
;
didChange
=
true
;
}
}
}
}
else
{
if
(
oldObject
[
key
]
!
=
=
newObject
[
key
]
)
{
results
.
changed
[
key
]
=
newObject
[
key
]
;
didChange
=
true
;
}
}
}
}
return
didChange
&
&
results
;
}
function
promiseLabel
(
label
)
{
return
'
Router
:
'
+
label
;
}
function
subclass
(
parentConstructor
proto
)
{
function
C
(
props
)
{
parentConstructor
.
call
(
this
props
|
|
{
}
)
;
}
C
.
prototype
=
oCreate
(
parentConstructor
.
prototype
)
;
merge
(
C
.
prototype
proto
)
;
return
C
;
}
function
resolveHook
(
obj
hookName
)
{
if
(
!
obj
)
{
return
;
}
var
underscored
=
"
_
"
+
hookName
;
return
obj
[
underscored
]
&
&
underscored
|
|
obj
[
hookName
]
&
&
hookName
;
}
function
callHook
(
obj
_hookName
arg1
arg2
)
{
var
hookName
=
resolveHook
(
obj
_hookName
)
;
return
hookName
&
&
obj
[
hookName
]
.
call
(
obj
arg1
arg2
)
;
}
function
applyHook
(
obj
_hookName
args
)
{
var
hookName
=
resolveHook
(
obj
_hookName
)
;
if
(
hookName
)
{
if
(
args
.
length
=
=
=
0
)
{
return
obj
[
hookName
]
.
call
(
obj
)
;
}
else
if
(
args
.
length
=
=
=
1
)
{
return
obj
[
hookName
]
.
call
(
obj
args
[
0
]
)
;
}
else
if
(
args
.
length
=
=
=
2
)
{
return
obj
[
hookName
]
.
call
(
obj
args
[
0
]
args
[
1
]
)
;
}
else
{
return
obj
[
hookName
]
.
apply
(
obj
args
)
;
}
}
}
exports
.
merge
=
merge
;
exports
.
slice
=
slice
;
exports
.
isParam
=
isParam
;
exports
.
coerceQueryParamsToString
=
coerceQueryParamsToString
;
exports
.
callHook
=
callHook
;
exports
.
resolveHook
=
resolveHook
;
exports
.
applyHook
=
applyHook
;
}
)
;
enifed
(
'
rsvp
'
[
'
exports
'
'
rsvp
/
promise
'
'
rsvp
/
events
'
'
rsvp
/
node
'
'
rsvp
/
all
'
'
rsvp
/
all
-
settled
'
'
rsvp
/
race
'
'
rsvp
/
hash
'
'
rsvp
/
hash
-
settled
'
'
rsvp
/
rethrow
'
'
rsvp
/
defer
'
'
rsvp
/
config
'
'
rsvp
/
map
'
'
rsvp
/
resolve
'
'
rsvp
/
reject
'
'
rsvp
/
filter
'
'
rsvp
/
asap
'
]
function
(
exports
_rsvpPromise
_rsvpEvents
_rsvpNode
_rsvpAll
_rsvpAllSettled
_rsvpRace
_rsvpHash
_rsvpHashSettled
_rsvpRethrow
_rsvpDefer
_rsvpConfig
_rsvpMap
_rsvpResolve
_rsvpReject
_rsvpFilter
_rsvpAsap
)
{
'
use
strict
'
;
_rsvpConfig
.
config
.
async
=
_rsvpAsap
.
default
;
_rsvpConfig
.
config
.
after
=
function
(
cb
)
{
setTimeout
(
cb
0
)
;
}
;
var
cast
=
_rsvpResolve
.
default
;
function
async
(
callback
arg
)
{
_rsvpConfig
.
config
.
async
(
callback
arg
)
;
}
function
on
(
)
{
_rsvpConfig
.
config
[
'
on
'
]
.
apply
(
_rsvpConfig
.
config
arguments
)
;
}
function
off
(
)
{
_rsvpConfig
.
config
[
'
off
'
]
.
apply
(
_rsvpConfig
.
config
arguments
)
;
}
if
(
typeof
window
!
=
=
'
undefined
'
&
&
typeof
window
[
'
__PROMISE_INSTRUMENTATION__
'
]
=
=
=
'
object
'
)
{
var
callbacks
=
window
[
'
__PROMISE_INSTRUMENTATION__
'
]
;
_rsvpConfig
.
configure
(
'
instrument
'
true
)
;
for
(
var
eventName
in
callbacks
)
{
if
(
callbacks
.
hasOwnProperty
(
eventName
)
)
{
on
(
eventName
callbacks
[
eventName
]
)
;
}
}
}
exports
.
cast
=
cast
;
exports
.
Promise
=
_rsvpPromise
.
default
;
exports
.
EventTarget
=
_rsvpEvents
.
default
;
exports
.
all
=
_rsvpAll
.
default
;
exports
.
allSettled
=
_rsvpAllSettled
.
default
;
exports
.
race
=
_rsvpRace
.
default
;
exports
.
hash
=
_rsvpHash
.
default
;
exports
.
hashSettled
=
_rsvpHashSettled
.
default
;
exports
.
rethrow
=
_rsvpRethrow
.
default
;
exports
.
defer
=
_rsvpDefer
.
default
;
exports
.
denodeify
=
_rsvpNode
.
default
;
exports
.
configure
=
_rsvpConfig
.
configure
;
exports
.
on
=
on
;
exports
.
off
=
off
;
exports
.
resolve
=
_rsvpResolve
.
default
;
exports
.
reject
=
_rsvpReject
.
default
;
exports
.
async
=
async
;
exports
.
map
=
_rsvpMap
.
default
;
exports
.
filter
=
_rsvpFilter
.
default
;
}
)
;
enifed
(
'
rsvp
.
umd
'
[
'
exports
'
'
rsvp
/
platform
'
'
rsvp
'
]
function
(
exports
_rsvpPlatform
_rsvp
)
{
'
use
strict
'
;
var
RSVP
=
{
'
race
'
:
_rsvp
.
race
'
Promise
'
:
_rsvp
.
Promise
'
allSettled
'
:
_rsvp
.
allSettled
'
hash
'
:
_rsvp
.
hash
'
hashSettled
'
:
_rsvp
.
hashSettled
'
denodeify
'
:
_rsvp
.
denodeify
'
on
'
:
_rsvp
.
on
'
off
'
:
_rsvp
.
off
'
map
'
:
_rsvp
.
map
'
filter
'
:
_rsvp
.
filter
'
resolve
'
:
_rsvp
.
resolve
'
reject
'
:
_rsvp
.
reject
'
all
'
:
_rsvp
.
all
'
rethrow
'
:
_rsvp
.
rethrow
'
defer
'
:
_rsvp
.
defer
'
EventTarget
'
:
_rsvp
.
EventTarget
'
configure
'
:
_rsvp
.
configure
'
async
'
:
_rsvp
.
async
}
;
if
(
typeof
define
=
=
=
'
function
'
&
&
define
[
'
amd
'
]
)
{
define
(
function
(
)
{
return
RSVP
;
}
)
;
}
else
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
[
'
exports
'
]
)
{
module
[
'
exports
'
]
=
RSVP
;
}
else
if
(
typeof
_rsvpPlatform
.
default
!
=
=
'
undefined
'
)
{
_rsvpPlatform
.
default
[
'
RSVP
'
]
=
RSVP
;
}
}
)
;
enifed
(
'
rsvp
/
-
internal
'
[
'
exports
'
'
rsvp
/
utils
'
'
rsvp
/
instrument
'
'
rsvp
/
config
'
]
function
(
exports
_rsvpUtils
_rsvpInstrument
_rsvpConfig
)
{
'
use
strict
'
;
function
withOwnPromise
(
)
{
return
new
TypeError
(
'
A
promises
callback
cannot
return
that
same
promise
.
'
)
;
}
function
noop
(
)
{
}
var
PENDING
=
void
0
;
var
FULFILLED
=
1
;
var
REJECTED
=
2
;
var
GET_THEN_ERROR
=
new
ErrorObject
(
)
;
function
getThen
(
promise
)
{
try
{
return
promise
.
then
;
}
catch
(
error
)
{
GET_THEN_ERROR
.
error
=
error
;
return
GET_THEN_ERROR
;
}
}
function
tryThen
(
then
value
fulfillmentHandler
rejectionHandler
)
{
try
{
then
.
call
(
value
fulfillmentHandler
rejectionHandler
)
;
}
catch
(
e
)
{
return
e
;
}
}
function
handleForeignThenable
(
promise
thenable
then
)
{
_rsvpConfig
.
config
.
async
(
function
(
promise
)
{
var
sealed
=
false
;
var
error
=
tryThen
(
then
thenable
function
(
value
)
{
if
(
sealed
)
{
return
;
}
sealed
=
true
;
if
(
thenable
!
=
=
value
)
{
resolve
(
promise
value
)
;
}
else
{
fulfill
(
promise
value
)
;
}
}
function
(
reason
)
{
if
(
sealed
)
{
return
;
}
sealed
=
true
;
reject
(
promise
reason
)
;
}
'
Settle
:
'
+
(
promise
.
_label
|
|
'
unknown
promise
'
)
)
;
if
(
!
sealed
&
&
error
)
{
sealed
=
true
;
reject
(
promise
error
)
;
}
}
promise
)
;
}
function
handleOwnThenable
(
promise
thenable
)
{
if
(
thenable
.
_state
=
=
=
FULFILLED
)
{
fulfill
(
promise
thenable
.
_result
)
;
}
else
if
(
thenable
.
_state
=
=
=
REJECTED
)
{
thenable
.
_onError
=
null
;
reject
(
promise
thenable
.
_result
)
;
}
else
{
subscribe
(
thenable
undefined
function
(
value
)
{
if
(
thenable
!
=
=
value
)
{
resolve
(
promise
value
)
;
}
else
{
fulfill
(
promise
value
)
;
}
}
function
(
reason
)
{
reject
(
promise
reason
)
;
}
)
;
}
}
function
handleMaybeThenable
(
promise
maybeThenable
)
{
if
(
maybeThenable
.
constructor
=
=
=
promise
.
constructor
)
{
handleOwnThenable
(
promise
maybeThenable
)
;
}
else
{
var
then
=
getThen
(
maybeThenable
)
;
if
(
then
=
=
=
GET_THEN_ERROR
)
{
reject
(
promise
GET_THEN_ERROR
.
error
)
;
}
else
if
(
then
=
=
=
undefined
)
{
fulfill
(
promise
maybeThenable
)
;
}
else
if
(
_rsvpUtils
.
isFunction
(
then
)
)
{
handleForeignThenable
(
promise
maybeThenable
then
)
;
}
else
{
fulfill
(
promise
maybeThenable
)
;
}
}
}
function
resolve
(
promise
value
)
{
if
(
promise
=
=
=
value
)
{
fulfill
(
promise
value
)
;
}
else
if
(
_rsvpUtils
.
objectOrFunction
(
value
)
)
{
handleMaybeThenable
(
promise
value
)
;
}
else
{
fulfill
(
promise
value
)
;
}
}
function
publishRejection
(
promise
)
{
if
(
promise
.
_onError
)
{
promise
.
_onError
(
promise
.
_result
)
;
}
publish
(
promise
)
;
}
function
fulfill
(
promise
value
)
{
if
(
promise
.
_state
!
=
=
PENDING
)
{
return
;
}
promise
.
_result
=
value
;
promise
.
_state
=
FULFILLED
;
if
(
promise
.
_subscribers
.
length
=
=
=
0
)
{
if
(
_rsvpConfig
.
config
.
instrument
)
{
_rsvpInstrument
.
default
(
'
fulfilled
'
promise
)
;
}
}
else
{
_rsvpConfig
.
config
.
async
(
publish
promise
)
;
}
}
function
reject
(
promise
reason
)
{
if
(
promise
.
_state
!
=
=
PENDING
)
{
return
;
}
promise
.
_state
=
REJECTED
;
promise
.
_result
=
reason
;
_rsvpConfig
.
config
.
async
(
publishRejection
promise
)
;
}
function
subscribe
(
parent
child
onFulfillment
onRejection
)
{
var
subscribers
=
parent
.
_subscribers
;
var
length
=
subscribers
.
length
;
parent
.
_onError
=
null
;
subscribers
[
length
]
=
child
;
subscribers
[
length
+
FULFILLED
]
=
onFulfillment
;
subscribers
[
length
+
REJECTED
]
=
onRejection
;
if
(
length
=
=
=
0
&
&
parent
.
_state
)
{
_rsvpConfig
.
config
.
async
(
publish
parent
)
;
}
}
function
publish
(
promise
)
{
var
subscribers
=
promise
.
_subscribers
;
var
settled
=
promise
.
_state
;
if
(
_rsvpConfig
.
config
.
instrument
)
{
_rsvpInstrument
.
default
(
settled
=
=
=
FULFILLED
?
'
fulfilled
'
:
'
rejected
'
promise
)
;
}
if
(
subscribers
.
length
=
=
=
0
)
{
return
;
}
var
child
callback
detail
=
promise
.
_result
;
for
(
var
i
=
0
;
i
<
subscribers
.
length
;
i
+
=
3
)
{
child
=
subscribers
[
i
]
;
callback
=
subscribers
[
i
+
settled
]
;
if
(
child
)
{
invokeCallback
(
settled
child
callback
detail
)
;
}
else
{
callback
(
detail
)
;
}
}
promise
.
_subscribers
.
length
=
0
;
}
function
ErrorObject
(
)
{
this
.
error
=
null
;
}
var
TRY_CATCH_ERROR
=
new
ErrorObject
(
)
;
function
tryCatch
(
callback
detail
)
{
try
{
return
callback
(
detail
)
;
}
catch
(
e
)
{
TRY_CATCH_ERROR
.
error
=
e
;
return
TRY_CATCH_ERROR
;
}
}
function
invokeCallback
(
settled
promise
callback
detail
)
{
var
hasCallback
=
_rsvpUtils
.
isFunction
(
callback
)
value
error
succeeded
failed
;
if
(
hasCallback
)
{
value
=
tryCatch
(
callback
detail
)
;
if
(
value
=
=
=
TRY_CATCH_ERROR
)
{
failed
=
true
;
error
=
value
.
error
;
value
=
null
;
}
else
{
succeeded
=
true
;
}
if
(
promise
=
=
=
value
)
{
reject
(
promise
withOwnPromise
(
)
)
;
return
;
}
}
else
{
value
=
detail
;
succeeded
=
true
;
}
if
(
promise
.
_state
!
=
=
PENDING
)
{
}
else
if
(
hasCallback
&
&
succeeded
)
{
resolve
(
promise
value
)
;
}
else
if
(
failed
)
{
reject
(
promise
error
)
;
}
else
if
(
settled
=
=
=
FULFILLED
)
{
fulfill
(
promise
value
)
;
}
else
if
(
settled
=
=
=
REJECTED
)
{
reject
(
promise
value
)
;
}
}
function
initializePromise
(
promise
resolver
)
{
var
resolved
=
false
;
try
{
resolver
(
function
resolvePromise
(
value
)
{
if
(
resolved
)
{
return
;
}
resolved
=
true
;
resolve
(
promise
value
)
;
}
function
rejectPromise
(
reason
)
{
if
(
resolved
)
{
return
;
}
resolved
=
true
;
reject
(
promise
reason
)
;
}
)
;
}
catch
(
e
)
{
reject
(
promise
e
)
;
}
}
exports
.
noop
=
noop
;
exports
.
resolve
=
resolve
;
exports
.
reject
=
reject
;
exports
.
fulfill
=
fulfill
;
exports
.
subscribe
=
subscribe
;
exports
.
publish
=
publish
;
exports
.
publishRejection
=
publishRejection
;
exports
.
initializePromise
=
initializePromise
;
exports
.
invokeCallback
=
invokeCallback
;
exports
.
FULFILLED
=
FULFILLED
;
exports
.
REJECTED
=
REJECTED
;
exports
.
PENDING
=
PENDING
;
}
)
;
enifed
(
'
rsvp
/
all
-
settled
'
[
'
exports
'
'
rsvp
/
enumerator
'
'
rsvp
/
promise
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpEnumerator
_rsvpPromise
_rsvpUtils
)
{
'
use
strict
'
;
exports
.
default
=
allSettled
;
function
AllSettled
(
Constructor
entries
label
)
{
this
.
_superConstructor
(
Constructor
entries
false
label
)
;
}
AllSettled
.
prototype
=
_rsvpUtils
.
o_create
(
_rsvpEnumerator
.
default
.
prototype
)
;
AllSettled
.
prototype
.
_superConstructor
=
_rsvpEnumerator
.
default
;
AllSettled
.
prototype
.
_makeResult
=
_rsvpEnumerator
.
makeSettledResult
;
AllSettled
.
prototype
.
_validationError
=
function
(
)
{
return
new
Error
(
'
allSettled
must
be
called
with
an
array
'
)
;
}
;
function
allSettled
(
entries
label
)
{
return
new
AllSettled
(
_rsvpPromise
.
default
entries
label
)
.
promise
;
}
}
)
;
enifed
(
"
rsvp
/
all
"
[
"
exports
"
"
rsvp
/
promise
"
]
function
(
exports
_rsvpPromise
)
{
"
use
strict
"
;
exports
.
default
=
all
;
function
all
(
array
label
)
{
return
_rsvpPromise
.
default
.
all
(
array
label
)
;
}
}
)
;
enifed
(
'
rsvp
/
asap
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
asap
;
var
len
=
0
;
var
toString
=
(
{
}
)
.
toString
;
var
vertxNext
;
function
asap
(
callback
arg
)
{
queue
[
len
]
=
callback
;
queue
[
len
+
1
]
=
arg
;
len
+
=
2
;
if
(
len
=
=
=
2
)
{
scheduleFlush
(
)
;
}
}
var
browserWindow
=
typeof
window
!
=
=
'
undefined
'
?
window
:
undefined
;
var
browserGlobal
=
browserWindow
|
|
{
}
;
var
BrowserMutationObserver
=
browserGlobal
.
MutationObserver
|
|
browserGlobal
.
WebKitMutationObserver
;
var
isNode
=
typeof
window
=
=
=
'
undefined
'
&
&
typeof
process
!
=
=
'
undefined
'
&
&
(
{
}
)
.
toString
.
call
(
process
)
=
=
=
'
[
object
process
]
'
;
var
isWorker
=
typeof
Uint8ClampedArray
!
=
=
'
undefined
'
&
&
typeof
importScripts
!
=
=
'
undefined
'
&
&
typeof
MessageChannel
!
=
=
'
undefined
'
;
function
useNextTick
(
)
{
var
nextTick
=
process
.
nextTick
;
var
version
=
process
.
versions
.
node
.
match
(
/
^
(
?
:
(
\
d
+
)
\
.
)
?
(
?
:
(
\
d
+
)
\
.
)
?
(
\
*
|
\
d
+
)
/
)
;
if
(
Array
.
isArray
(
version
)
&
&
version
[
1
]
=
=
=
'
0
'
&
&
version
[
2
]
=
=
=
'
10
'
)
{
nextTick
=
setImmediate
;
}
return
function
(
)
{
nextTick
(
flush
)
;
}
;
}
function
useVertxTimer
(
)
{
return
function
(
)
{
vertxNext
(
flush
)
;
}
;
}
function
useMutationObserver
(
)
{
var
iterations
=
0
;
var
observer
=
new
BrowserMutationObserver
(
flush
)
;
var
node
=
document
.
createTextNode
(
'
'
)
;
observer
.
observe
(
node
{
characterData
:
true
}
)
;
return
function
(
)
{
node
.
data
=
iterations
=
+
+
iterations
%
2
;
}
;
}
function
useMessageChannel
(
)
{
var
channel
=
new
MessageChannel
(
)
;
channel
.
port1
.
onmessage
=
flush
;
return
function
(
)
{
channel
.
port2
.
postMessage
(
0
)
;
}
;
}
function
useSetTimeout
(
)
{
return
function
(
)
{
setTimeout
(
flush
1
)
;
}
;
}
var
queue
=
new
Array
(
1000
)
;
function
flush
(
)
{
for
(
var
i
=
0
;
i
<
len
;
i
+
=
2
)
{
var
callback
=
queue
[
i
]
;
var
arg
=
queue
[
i
+
1
]
;
callback
(
arg
)
;
queue
[
i
]
=
undefined
;
queue
[
i
+
1
]
=
undefined
;
}
len
=
0
;
}
function
attemptVertex
(
)
{
try
{
var
r
=
require
;
var
vertx
=
r
(
'
vertx
'
)
;
vertxNext
=
vertx
.
runOnLoop
|
|
vertx
.
runOnContext
;
return
useVertxTimer
(
)
;
}
catch
(
e
)
{
return
useSetTimeout
(
)
;
}
}
var
scheduleFlush
;
if
(
isNode
)
{
scheduleFlush
=
useNextTick
(
)
;
}
else
if
(
BrowserMutationObserver
)
{
scheduleFlush
=
useMutationObserver
(
)
;
}
else
if
(
isWorker
)
{
scheduleFlush
=
useMessageChannel
(
)
;
}
else
if
(
browserWindow
=
=
=
undefined
&
&
typeof
require
=
=
=
'
function
'
)
{
scheduleFlush
=
attemptVertex
(
)
;
}
else
{
scheduleFlush
=
useSetTimeout
(
)
;
}
}
)
;
enifed
(
'
rsvp
/
config
'
[
'
exports
'
'
rsvp
/
events
'
]
function
(
exports
_rsvpEvents
)
{
'
use
strict
'
;
var
config
=
{
instrument
:
false
}
;
_rsvpEvents
.
default
[
'
mixin
'
]
(
config
)
;
function
configure
(
name
value
)
{
if
(
name
=
=
=
'
onerror
'
)
{
config
[
'
on
'
]
(
'
error
'
value
)
;
return
;
}
if
(
arguments
.
length
=
=
=
2
)
{
config
[
name
]
=
value
;
}
else
{
return
config
[
name
]
;
}
}
exports
.
config
=
config
;
exports
.
configure
=
configure
;
}
)
;
enifed
(
'
rsvp
/
defer
'
[
'
exports
'
'
rsvp
/
promise
'
]
function
(
exports
_rsvpPromise
)
{
'
use
strict
'
;
exports
.
default
=
defer
;
function
defer
(
label
)
{
var
deferred
=
{
}
;
deferred
[
'
promise
'
]
=
new
_rsvpPromise
.
default
(
function
(
resolve
reject
)
{
deferred
[
'
resolve
'
]
=
resolve
;
deferred
[
'
reject
'
]
=
reject
;
}
label
)
;
return
deferred
;
}
}
)
;
enifed
(
'
rsvp
/
enumerator
'
[
'
exports
'
'
rsvp
/
utils
'
'
rsvp
/
-
internal
'
]
function
(
exports
_rsvpUtils
_rsvpInternal
)
{
'
use
strict
'
;
exports
.
makeSettledResult
=
makeSettledResult
;
function
makeSettledResult
(
state
position
value
)
{
if
(
state
=
=
=
_rsvpInternal
.
FULFILLED
)
{
return
{
state
:
'
fulfilled
'
value
:
value
}
;
}
else
{
return
{
state
:
'
rejected
'
reason
:
value
}
;
}
}
function
Enumerator
(
Constructor
input
abortOnReject
label
)
{
var
enumerator
=
this
;
enumerator
.
_instanceConstructor
=
Constructor
;
enumerator
.
promise
=
new
Constructor
(
_rsvpInternal
.
noop
label
)
;
enumerator
.
_abortOnReject
=
abortOnReject
;
if
(
enumerator
.
_validateInput
(
input
)
)
{
enumerator
.
_input
=
input
;
enumerator
.
length
=
input
.
length
;
enumerator
.
_remaining
=
input
.
length
;
enumerator
.
_init
(
)
;
if
(
enumerator
.
length
=
=
=
0
)
{
_rsvpInternal
.
fulfill
(
enumerator
.
promise
enumerator
.
_result
)
;
}
else
{
enumerator
.
length
=
enumerator
.
length
|
|
0
;
enumerator
.
_enumerate
(
)
;
if
(
enumerator
.
_remaining
=
=
=
0
)
{
_rsvpInternal
.
fulfill
(
enumerator
.
promise
enumerator
.
_result
)
;
}
}
}
else
{
_rsvpInternal
.
reject
(
enumerator
.
promise
enumerator
.
_validationError
(
)
)
;
}
}
exports
.
default
=
Enumerator
;
Enumerator
.
prototype
.
_validateInput
=
function
(
input
)
{
return
_rsvpUtils
.
isArray
(
input
)
;
}
;
Enumerator
.
prototype
.
_validationError
=
function
(
)
{
return
new
Error
(
'
Array
Methods
must
be
provided
an
Array
'
)
;
}
;
Enumerator
.
prototype
.
_init
=
function
(
)
{
this
.
_result
=
new
Array
(
this
.
length
)
;
}
;
Enumerator
.
prototype
.
_enumerate
=
function
(
)
{
var
enumerator
=
this
;
var
length
=
enumerator
.
length
;
var
promise
=
enumerator
.
promise
;
var
input
=
enumerator
.
_input
;
for
(
var
i
=
0
;
promise
.
_state
=
=
=
_rsvpInternal
.
PENDING
&
&
i
<
length
;
i
+
+
)
{
enumerator
.
_eachEntry
(
input
[
i
]
i
)
;
}
}
;
Enumerator
.
prototype
.
_eachEntry
=
function
(
entry
i
)
{
var
enumerator
=
this
;
var
c
=
enumerator
.
_instanceConstructor
;
if
(
_rsvpUtils
.
isMaybeThenable
(
entry
)
)
{
if
(
entry
.
constructor
=
=
=
c
&
&
entry
.
_state
!
=
=
_rsvpInternal
.
PENDING
)
{
entry
.
_onError
=
null
;
enumerator
.
_settledAt
(
entry
.
_state
i
entry
.
_result
)
;
}
else
{
enumerator
.
_willSettleAt
(
c
.
resolve
(
entry
)
i
)
;
}
}
else
{
enumerator
.
_remaining
-
-
;
enumerator
.
_result
[
i
]
=
enumerator
.
_makeResult
(
_rsvpInternal
.
FULFILLED
i
entry
)
;
}
}
;
Enumerator
.
prototype
.
_settledAt
=
function
(
state
i
value
)
{
var
enumerator
=
this
;
var
promise
=
enumerator
.
promise
;
if
(
promise
.
_state
=
=
=
_rsvpInternal
.
PENDING
)
{
enumerator
.
_remaining
-
-
;
if
(
enumerator
.
_abortOnReject
&
&
state
=
=
=
_rsvpInternal
.
REJECTED
)
{
_rsvpInternal
.
reject
(
promise
value
)
;
}
else
{
enumerator
.
_result
[
i
]
=
enumerator
.
_makeResult
(
state
i
value
)
;
}
}
if
(
enumerator
.
_remaining
=
=
=
0
)
{
_rsvpInternal
.
fulfill
(
promise
enumerator
.
_result
)
;
}
}
;
Enumerator
.
prototype
.
_makeResult
=
function
(
state
i
value
)
{
return
value
;
}
;
Enumerator
.
prototype
.
_willSettleAt
=
function
(
promise
i
)
{
var
enumerator
=
this
;
_rsvpInternal
.
subscribe
(
promise
undefined
function
(
value
)
{
enumerator
.
_settledAt
(
_rsvpInternal
.
FULFILLED
i
value
)
;
}
function
(
reason
)
{
enumerator
.
_settledAt
(
_rsvpInternal
.
REJECTED
i
reason
)
;
}
)
;
}
;
}
)
;
enifed
(
'
rsvp
/
events
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
function
indexOf
(
callbacks
callback
)
{
for
(
var
i
=
0
l
=
callbacks
.
length
;
i
<
l
;
i
+
+
)
{
if
(
callbacks
[
i
]
=
=
=
callback
)
{
return
i
;
}
}
return
-
1
;
}
function
callbacksFor
(
object
)
{
var
callbacks
=
object
.
_promiseCallbacks
;
if
(
!
callbacks
)
{
callbacks
=
object
.
_promiseCallbacks
=
{
}
;
}
return
callbacks
;
}
exports
.
default
=
{
'
mixin
'
:
function
(
object
)
{
object
[
'
on
'
]
=
this
[
'
on
'
]
;
object
[
'
off
'
]
=
this
[
'
off
'
]
;
object
[
'
trigger
'
]
=
this
[
'
trigger
'
]
;
object
.
_promiseCallbacks
=
undefined
;
return
object
;
}
'
on
'
:
function
(
eventName
callback
)
{
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
TypeError
(
'
Callback
must
be
a
function
'
)
;
}
var
allCallbacks
=
callbacksFor
(
this
)
callbacks
;
callbacks
=
allCallbacks
[
eventName
]
;
if
(
!
callbacks
)
{
callbacks
=
allCallbacks
[
eventName
]
=
[
]
;
}
if
(
indexOf
(
callbacks
callback
)
=
=
=
-
1
)
{
callbacks
.
push
(
callback
)
;
}
}
'
off
'
:
function
(
eventName
callback
)
{
var
allCallbacks
=
callbacksFor
(
this
)
callbacks
index
;
if
(
!
callback
)
{
allCallbacks
[
eventName
]
=
[
]
;
return
;
}
callbacks
=
allCallbacks
[
eventName
]
;
index
=
indexOf
(
callbacks
callback
)
;
if
(
index
!
=
=
-
1
)
{
callbacks
.
splice
(
index
1
)
;
}
}
'
trigger
'
:
function
(
eventName
options
)
{
var
allCallbacks
=
callbacksFor
(
this
)
callbacks
callback
;
if
(
callbacks
=
allCallbacks
[
eventName
]
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callback
=
callbacks
[
i
]
;
callback
(
options
)
;
}
}
}
}
;
}
)
;
enifed
(
'
rsvp
/
filter
'
[
'
exports
'
'
rsvp
/
promise
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpPromise
_rsvpUtils
)
{
'
use
strict
'
;
exports
.
default
=
filter
;
function
filter
(
promises
filterFn
label
)
{
return
_rsvpPromise
.
default
.
all
(
promises
label
)
.
then
(
function
(
values
)
{
if
(
!
_rsvpUtils
.
isFunction
(
filterFn
)
)
{
throw
new
TypeError
(
"
You
must
pass
a
function
as
filter
'
s
second
argument
.
"
)
;
}
var
length
=
values
.
length
;
var
filtered
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
filtered
[
i
]
=
filterFn
(
values
[
i
]
)
;
}
return
_rsvpPromise
.
default
.
all
(
filtered
label
)
.
then
(
function
(
filtered
)
{
var
results
=
new
Array
(
length
)
;
var
newLength
=
0
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
filtered
[
i
]
)
{
results
[
newLength
]
=
values
[
i
]
;
newLength
+
+
;
}
}
results
.
length
=
newLength
;
return
results
;
}
)
;
}
)
;
}
}
)
;
enifed
(
'
rsvp
/
hash
-
settled
'
[
'
exports
'
'
rsvp
/
promise
'
'
rsvp
/
enumerator
'
'
rsvp
/
promise
-
hash
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpPromise
_rsvpEnumerator
_rsvpPromiseHash
_rsvpUtils
)
{
'
use
strict
'
;
exports
.
default
=
hashSettled
;
function
HashSettled
(
Constructor
object
label
)
{
this
.
_superConstructor
(
Constructor
object
false
label
)
;
}
HashSettled
.
prototype
=
_rsvpUtils
.
o_create
(
_rsvpPromiseHash
.
default
.
prototype
)
;
HashSettled
.
prototype
.
_superConstructor
=
_rsvpEnumerator
.
default
;
HashSettled
.
prototype
.
_makeResult
=
_rsvpEnumerator
.
makeSettledResult
;
HashSettled
.
prototype
.
_validationError
=
function
(
)
{
return
new
Error
(
'
hashSettled
must
be
called
with
an
object
'
)
;
}
;
function
hashSettled
(
object
label
)
{
return
new
HashSettled
(
_rsvpPromise
.
default
object
label
)
.
promise
;
}
}
)
;
enifed
(
'
rsvp
/
hash
'
[
'
exports
'
'
rsvp
/
promise
'
'
rsvp
/
promise
-
hash
'
]
function
(
exports
_rsvpPromise
_rsvpPromiseHash
)
{
'
use
strict
'
;
exports
.
default
=
hash
;
function
hash
(
object
label
)
{
return
new
_rsvpPromiseHash
.
default
(
_rsvpPromise
.
default
object
label
)
.
promise
;
}
}
)
;
enifed
(
'
rsvp
/
instrument
'
[
'
exports
'
'
rsvp
/
config
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpConfig
_rsvpUtils
)
{
'
use
strict
'
;
exports
.
default
=
instrument
;
var
queue
=
[
]
;
function
scheduleFlush
(
)
{
setTimeout
(
function
(
)
{
var
entry
;
for
(
var
i
=
0
;
i
<
queue
.
length
;
i
+
+
)
{
entry
=
queue
[
i
]
;
var
payload
=
entry
.
payload
;
payload
.
guid
=
payload
.
key
+
payload
.
id
;
payload
.
childGuid
=
payload
.
key
+
payload
.
childId
;
if
(
payload
.
error
)
{
payload
.
stack
=
payload
.
error
.
stack
;
}
_rsvpConfig
.
config
[
'
trigger
'
]
(
entry
.
name
entry
.
payload
)
;
}
queue
.
length
=
0
;
}
50
)
;
}
function
instrument
(
eventName
promise
child
)
{
if
(
1
=
=
=
queue
.
push
(
{
name
:
eventName
payload
:
{
key
:
promise
.
_guidKey
id
:
promise
.
_id
eventName
:
eventName
detail
:
promise
.
_result
childId
:
child
&
&
child
.
_id
label
:
promise
.
_label
timeStamp
:
_rsvpUtils
.
now
(
)
error
:
_rsvpConfig
.
config
[
"
instrument
-
with
-
stack
"
]
?
new
Error
(
promise
.
_label
)
:
null
}
}
)
)
{
scheduleFlush
(
)
;
}
}
}
)
;
enifed
(
'
rsvp
/
map
'
[
'
exports
'
'
rsvp
/
promise
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpPromise
_rsvpUtils
)
{
'
use
strict
'
;
exports
.
default
=
map
;
function
map
(
promises
mapFn
label
)
{
return
_rsvpPromise
.
default
.
all
(
promises
label
)
.
then
(
function
(
values
)
{
if
(
!
_rsvpUtils
.
isFunction
(
mapFn
)
)
{
throw
new
TypeError
(
"
You
must
pass
a
function
as
map
'
s
second
argument
.
"
)
;
}
var
length
=
values
.
length
;
var
results
=
new
Array
(
length
)
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
results
[
i
]
=
mapFn
(
values
[
i
]
)
;
}
return
_rsvpPromise
.
default
.
all
(
results
label
)
;
}
)
;
}
}
)
;
enifed
(
'
rsvp
/
node
'
[
'
exports
'
'
rsvp
/
promise
'
'
rsvp
/
-
internal
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpPromise
_rsvpInternal
_rsvpUtils
)
{
'
use
strict
'
;
exports
.
default
=
denodeify
;
function
_defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
function
Result
(
)
{
this
.
value
=
undefined
;
}
var
ERROR
=
new
Result
(
)
;
var
GET_THEN_ERROR
=
new
Result
(
)
;
function
getThen
(
obj
)
{
try
{
return
obj
.
then
;
}
catch
(
error
)
{
ERROR
.
value
=
error
;
return
ERROR
;
}
}
function
tryApply
(
f
s
a
)
{
try
{
f
.
apply
(
s
a
)
;
}
catch
(
error
)
{
ERROR
.
value
=
error
;
return
ERROR
;
}
}
function
makeObject
(
_
argumentNames
)
{
var
obj
=
{
}
;
var
name
;
var
i
;
var
length
=
_
.
length
;
var
args
=
new
Array
(
length
)
;
for
(
var
x
=
0
;
x
<
length
;
x
+
+
)
{
args
[
x
]
=
_
[
x
]
;
}
for
(
i
=
0
;
i
<
argumentNames
.
length
;
i
+
+
)
{
name
=
argumentNames
[
i
]
;
obj
[
name
]
=
args
[
i
+
1
]
;
}
return
obj
;
}
function
arrayResult
(
_
)
{
var
length
=
_
.
length
;
var
args
=
new
Array
(
length
-
1
)
;
for
(
var
i
=
1
;
i
<
length
;
i
+
+
)
{
args
[
i
-
1
]
=
_
[
i
]
;
}
return
args
;
}
function
wrapThenable
(
then
promise
)
{
return
{
then
:
function
(
onFulFillment
onRejection
)
{
return
then
.
call
(
promise
onFulFillment
onRejection
)
;
}
}
;
}
function
denodeify
(
nodeFunc
options
)
{
var
fn
=
function
(
)
{
var
self
=
this
;
var
l
=
arguments
.
length
;
var
args
=
new
Array
(
l
+
1
)
;
var
arg
;
var
promiseInput
=
false
;
for
(
var
i
=
0
;
i
<
l
;
+
+
i
)
{
arg
=
arguments
[
i
]
;
if
(
!
promiseInput
)
{
promiseInput
=
needsPromiseInput
(
arg
)
;
if
(
promiseInput
=
=
=
GET_THEN_ERROR
)
{
var
p
=
new
_rsvpPromise
.
default
(
_rsvpInternal
.
noop
)
;
_rsvpInternal
.
reject
(
p
GET_THEN_ERROR
.
value
)
;
return
p
;
}
else
if
(
promiseInput
&
&
promiseInput
!
=
=
true
)
{
arg
=
wrapThenable
(
promiseInput
arg
)
;
}
}
args
[
i
]
=
arg
;
}
var
promise
=
new
_rsvpPromise
.
default
(
_rsvpInternal
.
noop
)
;
args
[
l
]
=
function
(
err
val
)
{
if
(
err
)
_rsvpInternal
.
reject
(
promise
err
)
;
else
if
(
options
=
=
=
undefined
)
_rsvpInternal
.
resolve
(
promise
val
)
;
else
if
(
options
=
=
=
true
)
_rsvpInternal
.
resolve
(
promise
arrayResult
(
arguments
)
)
;
else
if
(
_rsvpUtils
.
isArray
(
options
)
)
_rsvpInternal
.
resolve
(
promise
makeObject
(
arguments
options
)
)
;
else
_rsvpInternal
.
resolve
(
promise
val
)
;
}
;
if
(
promiseInput
)
{
return
handlePromiseInput
(
promise
args
nodeFunc
self
)
;
}
else
{
return
handleValueInput
(
promise
args
nodeFunc
self
)
;
}
}
;
_defaults
(
fn
nodeFunc
)
;
return
fn
;
}
function
handleValueInput
(
promise
args
nodeFunc
self
)
{
var
result
=
tryApply
(
nodeFunc
self
args
)
;
if
(
result
=
=
=
ERROR
)
{
_rsvpInternal
.
reject
(
promise
result
.
value
)
;
}
return
promise
;
}
function
handlePromiseInput
(
promise
args
nodeFunc
self
)
{
return
_rsvpPromise
.
default
.
all
(
args
)
.
then
(
function
(
args
)
{
var
result
=
tryApply
(
nodeFunc
self
args
)
;
if
(
result
=
=
=
ERROR
)
{
_rsvpInternal
.
reject
(
promise
result
.
value
)
;
}
return
promise
;
}
)
;
}
function
needsPromiseInput
(
arg
)
{
if
(
arg
&
&
typeof
arg
=
=
=
'
object
'
)
{
if
(
arg
.
constructor
=
=
=
_rsvpPromise
.
default
)
{
return
true
;
}
else
{
return
getThen
(
arg
)
;
}
}
else
{
return
false
;
}
}
}
)
;
enifed
(
'
rsvp
/
platform
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
platform
;
if
(
typeof
self
=
=
=
'
object
'
)
{
platform
=
self
;
}
else
if
(
typeof
global
=
=
=
'
object
'
)
{
platform
=
global
;
}
else
{
throw
new
Error
(
'
no
global
:
self
or
global
found
'
)
;
}
exports
.
default
=
platform
;
}
)
;
enifed
(
'
rsvp
/
promise
-
hash
'
[
'
exports
'
'
rsvp
/
enumerator
'
'
rsvp
/
-
internal
'
'
rsvp
/
utils
'
]
function
(
exports
_rsvpEnumerator
_rsvpInternal
_rsvpUtils
)
{
'
use
strict
'
;
function
PromiseHash
(
Constructor
object
label
)
{
this
.
_superConstructor
(
Constructor
object
true
label
)
;
}
exports
.
default
=
PromiseHash
;
PromiseHash
.
prototype
=
_rsvpUtils
.
o_create
(
_rsvpEnumerator
.
default
.
prototype
)
;
PromiseHash
.
prototype
.
_superConstructor
=
_rsvpEnumerator
.
default
;
PromiseHash
.
prototype
.
_init
=
function
(
)
{
this
.
_result
=
{
}
;
}
;
PromiseHash
.
prototype
.
_validateInput
=
function
(
input
)
{
return
input
&
&
typeof
input
=
=
=
'
object
'
;
}
;
PromiseHash
.
prototype
.
_validationError
=
function
(
)
{
return
new
Error
(
'
Promise
.
hash
must
be
called
with
an
object
'
)
;
}
;
PromiseHash
.
prototype
.
_enumerate
=
function
(
)
{
var
enumerator
=
this
;
var
promise
=
enumerator
.
promise
;
var
input
=
enumerator
.
_input
;
var
results
=
[
]
;
for
(
var
key
in
input
)
{
if
(
promise
.
_state
=
=
=
_rsvpInternal
.
PENDING
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
input
key
)
)
{
results
.
push
(
{
position
:
key
entry
:
input
[
key
]
}
)
;
}
}
var
length
=
results
.
length
;
enumerator
.
_remaining
=
length
;
var
result
;
for
(
var
i
=
0
;
promise
.
_state
=
=
=
_rsvpInternal
.
PENDING
&
&
i
<
length
;
i
+
+
)
{
result
=
results
[
i
]
;
enumerator
.
_eachEntry
(
result
.
entry
result
.
position
)
;
}
}
;
}
)
;
enifed
(
'
rsvp
/
promise
'
[
'
exports
'
'
rsvp
/
config
'
'
rsvp
/
instrument
'
'
rsvp
/
utils
'
'
rsvp
/
-
internal
'
'
rsvp
/
promise
/
all
'
'
rsvp
/
promise
/
race
'
'
rsvp
/
promise
/
resolve
'
'
rsvp
/
promise
/
reject
'
]
function
(
exports
_rsvpConfig
_rsvpInstrument
_rsvpUtils
_rsvpInternal
_rsvpPromiseAll
_rsvpPromiseRace
_rsvpPromiseResolve
_rsvpPromiseReject
)
{
'
use
strict
'
;
exports
.
default
=
Promise
;
var
guidKey
=
'
rsvp_
'
+
_rsvpUtils
.
now
(
)
+
'
-
'
;
var
counter
=
0
;
function
needsResolver
(
)
{
throw
new
TypeError
(
'
You
must
pass
a
resolver
function
as
the
first
argument
to
the
promise
constructor
'
)
;
}
function
needsNew
(
)
{
throw
new
TypeError
(
"
Failed
to
construct
'
Promise
'
:
Please
use
the
'
new
'
operator
this
object
constructor
cannot
be
called
as
a
function
.
"
)
;
}
function
Promise
(
resolver
label
)
{
var
promise
=
this
;
promise
.
_id
=
counter
+
+
;
promise
.
_label
=
label
;
promise
.
_state
=
undefined
;
promise
.
_result
=
undefined
;
promise
.
_subscribers
=
[
]
;
if
(
_rsvpConfig
.
config
.
instrument
)
{
_rsvpInstrument
.
default
(
'
created
'
promise
)
;
}
if
(
_rsvpInternal
.
noop
!
=
=
resolver
)
{
if
(
!
_rsvpUtils
.
isFunction
(
resolver
)
)
{
needsResolver
(
)
;
}
if
(
!
(
promise
instanceof
Promise
)
)
{
needsNew
(
)
;
}
_rsvpInternal
.
initializePromise
(
promise
resolver
)
;
}
}
Promise
.
cast
=
_rsvpPromiseResolve
.
default
;
Promise
.
all
=
_rsvpPromiseAll
.
default
;
Promise
.
race
=
_rsvpPromiseRace
.
default
;
Promise
.
resolve
=
_rsvpPromiseResolve
.
default
;
Promise
.
reject
=
_rsvpPromiseReject
.
default
;
Promise
.
prototype
=
{
constructor
:
Promise
_guidKey
:
guidKey
_onError
:
function
(
reason
)
{
var
promise
=
this
;
_rsvpConfig
.
config
.
after
(
function
(
)
{
if
(
promise
.
_onError
)
{
_rsvpConfig
.
config
[
'
trigger
'
]
(
'
error
'
reason
)
;
}
}
)
;
}
then
:
function
(
onFulfillment
onRejection
label
)
{
var
parent
=
this
;
var
state
=
parent
.
_state
;
if
(
state
=
=
=
_rsvpInternal
.
FULFILLED
&
&
!
onFulfillment
|
|
state
=
=
=
_rsvpInternal
.
REJECTED
&
&
!
onRejection
)
{
if
(
_rsvpConfig
.
config
.
instrument
)
{
_rsvpInstrument
.
default
(
'
chained
'
parent
parent
)
;
}
return
parent
;
}
parent
.
_onError
=
null
;
var
child
=
new
parent
.
constructor
(
_rsvpInternal
.
noop
label
)
;
var
result
=
parent
.
_result
;
if
(
_rsvpConfig
.
config
.
instrument
)
{
_rsvpInstrument
.
default
(
'
chained
'
parent
child
)
;
}
if
(
state
)
{
var
callback
=
arguments
[
state
-
1
]
;
_rsvpConfig
.
config
.
async
(
function
(
)
{
_rsvpInternal
.
invokeCallback
(
state
child
callback
result
)
;
}
)
;
}
else
{
_rsvpInternal
.
subscribe
(
parent
child
onFulfillment
onRejection
)
;
}
return
child
;
}
'
catch
'
:
function
(
onRejection
label
)
{
return
this
.
then
(
undefined
onRejection
label
)
;
}
'
finally
'
:
function
(
callback
label
)
{
var
promise
=
this
;
var
constructor
=
promise
.
constructor
;
return
promise
.
then
(
function
(
value
)
{
return
constructor
.
resolve
(
callback
(
)
)
.
then
(
function
(
)
{
return
value
;
}
)
;
}
function
(
reason
)
{
return
constructor
.
resolve
(
callback
(
)
)
.
then
(
function
(
)
{
throw
reason
;
}
)
;
}
label
)
;
}
}
;
}
)
;
enifed
(
'
rsvp
/
promise
/
all
'
[
'
exports
'
'
rsvp
/
enumerator
'
]
function
(
exports
_rsvpEnumerator
)
{
'
use
strict
'
;
exports
.
default
=
all
;
function
all
(
entries
label
)
{
return
new
_rsvpEnumerator
.
default
(
this
entries
true
label
)
.
promise
;
}
}
)
;
enifed
(
'
rsvp
/
promise
/
race
'
[
'
exports
'
'
rsvp
/
utils
'
'
rsvp
/
-
internal
'
]
function
(
exports
_rsvpUtils
_rsvpInternal
)
{
'
use
strict
'
;
exports
.
default
=
race
;
function
race
(
entries
label
)
{
var
Constructor
=
this
;
var
promise
=
new
Constructor
(
_rsvpInternal
.
noop
label
)
;
if
(
!
_rsvpUtils
.
isArray
(
entries
)
)
{
_rsvpInternal
.
reject
(
promise
new
TypeError
(
'
You
must
pass
an
array
to
race
.
'
)
)
;
return
promise
;
}
var
length
=
entries
.
length
;
function
onFulfillment
(
value
)
{
_rsvpInternal
.
resolve
(
promise
value
)
;
}
function
onRejection
(
reason
)
{
_rsvpInternal
.
reject
(
promise
reason
)
;
}
for
(
var
i
=
0
;
promise
.
_state
=
=
=
_rsvpInternal
.
PENDING
&
&
i
<
length
;
i
+
+
)
{
_rsvpInternal
.
subscribe
(
Constructor
.
resolve
(
entries
[
i
]
)
undefined
onFulfillment
onRejection
)
;
}
return
promise
;
}
}
)
;
enifed
(
'
rsvp
/
promise
/
reject
'
[
'
exports
'
'
rsvp
/
-
internal
'
]
function
(
exports
_rsvpInternal
)
{
'
use
strict
'
;
exports
.
default
=
reject
;
function
reject
(
reason
label
)
{
var
Constructor
=
this
;
var
promise
=
new
Constructor
(
_rsvpInternal
.
noop
label
)
;
_rsvpInternal
.
reject
(
promise
reason
)
;
return
promise
;
}
}
)
;
enifed
(
'
rsvp
/
promise
/
resolve
'
[
'
exports
'
'
rsvp
/
-
internal
'
]
function
(
exports
_rsvpInternal
)
{
'
use
strict
'
;
exports
.
default
=
resolve
;
function
resolve
(
object
label
)
{
var
Constructor
=
this
;
if
(
object
&
&
typeof
object
=
=
=
'
object
'
&
&
object
.
constructor
=
=
=
Constructor
)
{
return
object
;
}
var
promise
=
new
Constructor
(
_rsvpInternal
.
noop
label
)
;
_rsvpInternal
.
resolve
(
promise
object
)
;
return
promise
;
}
}
)
;
enifed
(
'
rsvp
/
race
'
[
'
exports
'
'
rsvp
/
promise
'
]
function
(
exports
_rsvpPromise
)
{
'
use
strict
'
;
exports
.
default
=
race
;
function
race
(
array
label
)
{
return
_rsvpPromise
.
default
.
race
(
array
label
)
;
}
}
)
;
enifed
(
'
rsvp
/
reject
'
[
'
exports
'
'
rsvp
/
promise
'
]
function
(
exports
_rsvpPromise
)
{
'
use
strict
'
;
exports
.
default
=
reject
;
function
reject
(
reason
label
)
{
return
_rsvpPromise
.
default
.
reject
(
reason
label
)
;
}
}
)
;
enifed
(
'
rsvp
/
resolve
'
[
'
exports
'
'
rsvp
/
promise
'
]
function
(
exports
_rsvpPromise
)
{
'
use
strict
'
;
exports
.
default
=
resolve
;
function
resolve
(
value
label
)
{
return
_rsvpPromise
.
default
.
resolve
(
value
label
)
;
}
}
)
;
enifed
(
"
rsvp
/
rethrow
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
rethrow
;
function
rethrow
(
reason
)
{
setTimeout
(
function
(
)
{
throw
reason
;
}
)
;
throw
reason
;
}
}
)
;
enifed
(
'
rsvp
/
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
objectOrFunction
=
objectOrFunction
;
exports
.
isFunction
=
isFunction
;
exports
.
isMaybeThenable
=
isMaybeThenable
;
function
objectOrFunction
(
x
)
{
return
typeof
x
=
=
=
'
function
'
|
|
typeof
x
=
=
=
'
object
'
&
&
x
!
=
=
null
;
}
function
isFunction
(
x
)
{
return
typeof
x
=
=
=
'
function
'
;
}
function
isMaybeThenable
(
x
)
{
return
typeof
x
=
=
=
'
object
'
&
&
x
!
=
=
null
;
}
var
_isArray
;
if
(
!
Array
.
isArray
)
{
_isArray
=
function
(
x
)
{
return
Object
.
prototype
.
toString
.
call
(
x
)
=
=
=
'
[
object
Array
]
'
;
}
;
}
else
{
_isArray
=
Array
.
isArray
;
}
var
isArray
=
_isArray
;
exports
.
isArray
=
isArray
;
var
now
=
Date
.
now
|
|
function
(
)
{
return
new
Date
(
)
.
getTime
(
)
;
}
;
exports
.
now
=
now
;
function
F
(
)
{
}
var
o_create
=
Object
.
create
|
|
function
(
o
)
{
if
(
arguments
.
length
>
1
)
{
throw
new
Error
(
'
Second
argument
not
supported
'
)
;
}
if
(
typeof
o
!
=
=
'
object
'
)
{
throw
new
TypeError
(
'
Argument
must
be
an
object
'
)
;
}
F
.
prototype
=
o
;
return
new
F
(
)
;
}
;
exports
.
o_create
=
o_create
;
}
)
;
enifed
(
"
vertex
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
Vertex
;
function
Vertex
(
name
)
{
this
.
name
=
name
;
this
.
incoming
=
{
}
;
this
.
incomingNames
=
[
]
;
this
.
hasOutgoing
=
false
;
this
.
value
=
null
;
}
}
)
;
enifed
(
"
visit
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
visit
;
function
visit
(
vertex
fn
visited
path
)
{
var
name
=
vertex
.
name
;
var
vertices
=
vertex
.
incoming
;
var
names
=
vertex
.
incomingNames
;
var
len
=
names
.
length
;
var
i
;
if
(
!
visited
)
{
visited
=
{
}
;
}
if
(
!
path
)
{
path
=
[
]
;
}
if
(
visited
.
hasOwnProperty
(
name
)
)
{
return
;
}
path
.
push
(
name
)
;
visited
[
name
]
=
true
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
visit
(
vertices
[
names
[
i
]
]
fn
visited
path
)
;
}
fn
(
vertex
path
)
;
path
.
pop
(
)
;
}
}
)
;
requireModule
(
"
ember
"
)
;
}
(
)
)
;
;
(
function
(
)
{
function
processEmberShims
(
)
{
var
shims
=
{
'
ember
'
:
{
'
default
'
:
Ember
}
'
ember
-
application
'
:
{
'
default
'
:
Ember
.
Application
}
'
ember
-
array
'
:
{
'
default
'
:
Ember
.
Array
}
'
ember
-
array
/
mutable
'
:
{
'
default
'
:
Ember
.
MutableArray
}
'
ember
-
array
/
utils
'
:
{
'
A
'
:
Ember
.
A
'
isEmberArray
'
:
Ember
.
isArray
'
wrap
'
:
Ember
.
makeArray
}
'
ember
-
component
'
:
{
'
default
'
:
Ember
.
Component
}
'
ember
-
components
/
checkbox
'
:
{
'
default
'
:
Ember
.
Checkbox
}
'
ember
-
components
/
text
-
area
'
:
{
'
default
'
:
Ember
.
TextArea
}
'
ember
-
components
/
text
-
field
'
:
{
'
default
'
:
Ember
.
TextField
}
'
ember
-
controller
'
:
{
'
default
'
:
Ember
.
Controller
}
'
ember
-
controller
/
inject
'
:
{
'
default
'
:
Ember
.
inject
.
controller
}
'
ember
-
controller
/
proxy
'
:
{
'
default
'
:
Ember
.
ArrayProxy
}
'
ember
-
controllers
/
sortable
'
:
{
'
default
'
:
Ember
.
SortableMixin
}
'
ember
-
debug
'
:
{
'
log
'
:
Ember
.
debug
'
inspect
'
:
Ember
.
inspect
'
run
'
:
Ember
.
runInDebug
'
warn
'
:
Ember
.
warn
}
'
ember
-
debug
/
container
-
debug
-
adapter
'
:
{
'
default
'
:
Ember
.
ContainerDebugAdapter
}
'
ember
-
debug
/
data
-
adapter
'
:
{
'
default
'
:
Ember
.
DataAdapter
}
'
ember
-
deprecations
'
:
{
'
deprecate
'
:
Ember
.
deprecate
'
deprecateFunc
'
:
Ember
.
deprecateFunc
}
'
ember
-
enumerable
'
:
{
'
default
'
:
Ember
.
Enumerable
}
'
ember
-
evented
'
:
{
'
default
'
:
Ember
.
Evented
}
'
ember
-
evented
/
on
'
:
{
'
default
'
:
Ember
.
on
}
'
ember
-
globals
-
resolver
'
:
{
'
default
'
:
Ember
.
DefaultResolver
}
'
ember
-
helper
'
:
{
'
default
'
:
Ember
.
Helper
'
helper
'
:
Ember
.
Helper
&
&
Ember
.
Helper
.
helper
}
'
ember
-
instrumentation
'
:
{
'
instrument
'
:
Ember
.
Instrumentation
.
instrument
'
reset
'
:
Ember
.
Instrumentation
.
reset
'
subscribe
'
:
Ember
.
Instrumentation
.
subscribe
'
unsubscribe
'
:
Ember
.
Instrumentation
.
unsubscribe
}
'
ember
-
locations
/
hash
'
:
{
'
default
'
:
Ember
.
HashLocation
}
'
ember
-
locations
/
history
'
:
{
'
default
'
:
Ember
.
HistoryLocation
}
'
ember
-
locations
/
none
'
:
{
'
default
'
:
Ember
.
NoneLocation
}
'
ember
-
map
'
:
{
'
default
'
:
Ember
.
Map
'
withDefault
'
:
Ember
.
MapWithDefault
}
'
ember
-
metal
/
destroy
'
:
{
'
default
'
:
Ember
.
destroy
}
'
ember
-
metal
/
events
'
:
{
'
addListener
'
:
Ember
.
addListener
'
removeListener
'
:
Ember
.
removeListener
'
send
'
:
Ember
.
sendEvent
}
'
ember
-
metal
/
get
'
:
{
'
default
'
:
Ember
.
get
'
getProperties
'
:
Ember
.
getProperties
}
'
ember
-
metal
/
mixin
'
:
{
'
default
'
:
Ember
.
Mixin
}
'
ember
-
metal
/
observer
'
:
{
'
default
'
:
Ember
.
observer
'
addObserver
'
:
Ember
.
addObserver
'
removeObserver
'
:
Ember
.
removeObserver
}
'
ember
-
metal
/
on
-
load
'
:
{
'
default
'
:
Ember
.
onLoad
'
run
'
:
Ember
.
runLoadHooks
}
'
ember
-
metal
/
set
'
:
{
'
default
'
:
Ember
.
set
'
setProperties
'
:
Ember
.
setProperties
'
trySet
'
:
Ember
.
trySet
}
'
ember
-
metal
/
utils
'
:
{
'
aliasMethod
'
:
Ember
.
aliasMethod
'
assert
'
:
Ember
.
assert
'
cacheFor
'
:
Ember
.
cacheFor
'
copy
'
:
Ember
.
copy
'
guidFor
'
:
Ember
.
guidFor
}
'
ember
-
object
'
:
{
'
default
'
:
Ember
.
Object
}
'
ember
-
platform
'
:
{
'
assign
'
:
Ember
.
merge
'
create
'
:
Ember
.
create
'
defineProperty
'
:
Ember
.
platform
.
defineProperty
'
hasAccessors
'
:
Ember
.
platform
.
hasPropertyAccessors
'
keys
'
:
Ember
.
keys
}
'
ember
-
route
'
:
{
'
default
'
:
Ember
.
Route
}
'
ember
-
router
'
:
{
'
default
'
:
Ember
.
Router
}
'
ember
-
runloop
'
:
{
'
default
'
:
Ember
.
run
'
begin
'
:
Ember
.
run
.
begin
'
bind
'
:
Ember
.
run
.
bind
'
cancel
'
:
Ember
.
run
.
cancel
'
debounce
'
:
Ember
.
run
.
debounce
'
end
'
:
Ember
.
run
.
end
'
join
'
:
Ember
.
run
.
join
'
later
'
:
Ember
.
run
.
later
'
next
'
:
Ember
.
run
.
next
'
once
'
:
Ember
.
run
.
once
'
schedule
'
:
Ember
.
run
.
schedule
'
scheduleOnce
'
:
Ember
.
run
.
scheduleOnce
'
throttle
'
:
Ember
.
run
.
throttle
}
'
ember
-
service
'
:
{
'
default
'
:
Ember
.
Service
}
'
ember
-
service
/
inject
'
:
{
'
default
'
:
Ember
.
inject
.
service
}
'
ember
-
set
/
ordered
'
:
{
'
default
'
:
Ember
.
OrderedSet
}
'
ember
-
string
'
:
{
'
camelize
'
:
Ember
.
String
.
camelize
'
capitalize
'
:
Ember
.
String
.
capitalize
'
classify
'
:
Ember
.
String
.
classify
'
dasherize
'
:
Ember
.
String
.
dasherize
'
decamelize
'
:
Ember
.
String
.
decamelize
'
fmt
'
:
Ember
.
String
.
fmt
'
htmlSafe
'
:
Ember
.
String
.
htmlSafe
'
loc
'
:
Ember
.
String
.
loc
'
underscore
'
:
Ember
.
String
.
underscore
'
w
'
:
Ember
.
String
.
w
}
'
ember
-
utils
'
:
{
'
isBlank
'
:
Ember
.
isBlank
'
isEmpty
'
:
Ember
.
isEmpty
'
isNone
'
:
Ember
.
isNone
'
isPresent
'
:
Ember
.
isPresent
'
tryInvoke
'
:
Ember
.
tryInvoke
'
typeOf
'
:
Ember
.
typeOf
}
}
;
shims
[
'
ember
-
computed
'
]
=
{
'
default
'
:
Ember
.
computed
}
;
var
computedMacros
=
[
"
empty
"
"
notEmpty
"
"
none
"
"
not
"
"
bool
"
"
match
"
"
equal
"
"
gt
"
"
gte
"
"
lt
"
"
lte
"
"
alias
"
"
oneWay
"
"
reads
"
"
readOnly
"
"
deprecatingAlias
"
"
and
"
"
or
"
"
collect
"
"
sum
"
"
min
"
"
max
"
"
map
"
"
sort
"
"
setDiff
"
"
mapBy
"
"
mapProperty
"
"
filter
"
"
filterBy
"
"
filterProperty
"
"
uniq
"
"
union
"
"
intersect
"
]
;
for
(
var
i
=
0
l
=
computedMacros
.
length
;
i
<
l
;
i
+
+
)
{
var
key
=
computedMacros
[
i
]
;
shims
[
'
ember
-
computed
'
]
[
key
]
=
Ember
.
computed
[
key
]
;
}
for
(
var
moduleName
in
shims
)
{
generateModule
(
moduleName
shims
[
moduleName
]
)
;
}
}
function
processTestShims
(
)
{
if
(
Ember
.
Test
)
{
var
testShims
=
{
'
ember
-
test
'
:
{
'
default
'
:
Ember
.
Test
}
'
ember
-
test
/
adapter
'
:
{
'
default
'
:
Ember
.
Test
.
Adapter
}
'
ember
-
test
/
qunit
-
adapter
'
:
{
'
default
'
:
Ember
.
Test
.
QUnitAdapter
}
}
;
for
(
var
moduleName
in
testShims
)
{
generateModule
(
moduleName
testShims
[
moduleName
]
)
;
}
}
}
function
generateModule
(
name
values
)
{
define
(
name
[
]
function
(
)
{
'
use
strict
'
;
return
values
;
}
)
;
}
processEmberShims
(
)
;
processTestShims
(
)
;
generateModule
(
'
jquery
'
{
'
default
'
:
self
.
jQuery
}
)
;
generateModule
(
'
rsvp
'
{
'
default
'
:
Ember
.
RSVP
}
)
;
}
)
(
)
;
;
define
(
'
ember
/
load
-
initializers
'
[
'
exports
'
'
ember
-
load
-
initializers
'
'
ember
'
]
function
(
exports
loadInitializers
Ember
)
{
Ember
[
'
default
'
]
.
deprecate
(
'
Usage
of
'
+
'
ember
/
load
-
initializers
'
+
'
module
is
deprecated
please
update
to
ember
-
load
-
initializers
.
'
false
{
id
:
'
ember
-
load
-
initializers
.
legacy
-
shims
'
until
:
'
3
.
0
.
0
'
}
)
;
exports
[
'
default
'
]
=
loadInitializers
[
'
default
'
]
;
}
)
;
;
function
createDeprecatedModule
(
moduleId
)
{
define
(
moduleId
[
'
exports
'
'
ember
-
resolver
/
resolver
'
'
ember
'
]
function
(
exports
Resolver
Ember
)
{
Ember
[
'
default
'
]
.
deprecate
(
'
Usage
of
'
+
moduleId
+
'
module
is
deprecated
please
update
to
ember
-
resolver
.
'
false
{
id
:
'
ember
-
resolver
.
legacy
-
shims
'
until
:
'
3
.
0
.
0
'
}
)
;
exports
[
'
default
'
]
=
Resolver
[
'
default
'
]
;
}
)
;
}
createDeprecatedModule
(
'
ember
/
resolver
'
)
;
createDeprecatedModule
(
'
resolver
'
)
;
;
define
(
'
ember
-
ajax
/
errors
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
exports
.
AjaxError
=
AjaxError
;
exports
.
InvalidError
=
InvalidError
;
exports
.
UnauthorizedError
=
UnauthorizedError
;
exports
.
ForbiddenError
=
ForbiddenError
;
var
EmberError
=
_ember
[
'
default
'
]
.
Error
;
function
AjaxError
(
errors
)
{
var
message
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
'
Ajax
operation
failed
'
:
arguments
[
1
]
;
EmberError
.
call
(
this
message
)
;
this
.
errors
=
errors
|
|
[
{
title
:
'
Ajax
Error
'
detail
:
message
}
]
;
}
AjaxError
.
prototype
=
Object
.
create
(
EmberError
.
prototype
)
;
function
InvalidError
(
errors
)
{
AjaxError
.
call
(
this
errors
'
Request
was
rejected
because
it
was
invalid
'
)
;
}
InvalidError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
UnauthorizedError
(
errors
)
{
AjaxError
.
call
(
this
errors
'
Ajax
authorization
failed
'
)
;
}
UnauthorizedError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
function
ForbiddenError
(
errors
)
{
AjaxError
.
call
(
this
errors
'
Request
was
rejected
because
user
is
not
permitted
to
perform
this
operation
.
'
)
;
}
ForbiddenError
.
prototype
=
Object
.
create
(
AjaxError
.
prototype
)
;
}
)
;
define
(
'
ember
-
ajax
/
index
'
[
'
exports
'
'
ember
-
ajax
/
request
'
]
function
(
exports
_emberAjaxRequest
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
get
(
)
{
return
_emberAjaxRequest
[
'
default
'
]
;
}
}
)
;
}
)
;
define
(
'
ember
-
ajax
/
make
-
promise
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
makePromise
;
var
run
=
_ember
[
'
default
'
]
.
run
;
var
RSVP
=
_ember
[
'
default
'
]
.
RSVP
;
function
makePromise
(
settings
)
{
var
type
=
settings
.
type
|
|
'
GET
'
;
return
new
RSVP
.
Promise
(
function
(
resolve
reject
)
{
settings
.
success
=
makeSuccess
(
resolve
)
;
settings
.
error
=
makeError
(
reject
)
;
_ember
[
'
default
'
]
.
.
ajax
(
settings
)
;
}
'
ember
-
ajax
:
'
+
type
+
'
to
'
+
settings
.
url
)
;
}
function
makeSuccess
(
resolve
)
{
return
function
success
(
response
textStatus
jqXHR
)
{
run
(
null
resolve
{
response
:
response
textStatus
:
textStatus
jqXHR
:
jqXHR
}
)
;
}
;
}
function
makeError
(
reject
)
{
return
function
error
(
jqXHR
textStatus
errorThrown
)
{
run
(
null
reject
{
jqXHR
:
jqXHR
textStatus
:
textStatus
errorThrown
:
errorThrown
}
)
;
}
;
}
}
)
;
define
(
'
ember
-
ajax
/
raw
'
[
'
exports
'
'
ember
-
ajax
/
make
-
promise
'
'
ember
-
ajax
/
utils
/
parse
-
args
'
'
ember
'
]
function
(
exports
_emberAjaxMakePromise
_emberAjaxUtilsParseArgs
_ember
)
{
'
use
strict
'
;
var
_slicedToArray
=
(
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
'
return
'
]
)
_i
[
'
return
'
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
'
Invalid
attempt
to
destructure
non
-
iterable
instance
'
)
;
}
}
;
}
)
(
)
;
exports
[
'
default
'
]
=
raw
;
var
deprecate
=
_ember
[
'
default
'
]
.
deprecate
;
function
raw
(
)
{
deprecate
(
'
ember
-
ajax
/
raw
is
deprecated
and
will
be
removed
in
ember
-
ajax
2
.
0
.
0
'
false
{
id
:
'
ember
-
ajax
.
raw
'
}
)
;
var
_parseArgs
apply
=
_emberAjaxUtilsParseArgs
[
'
default
'
]
.
apply
(
null
arguments
)
;
var
_parseArgs
apply2
=
_slicedToArray
(
_parseArgs
apply
3
)
;
var
url
=
_parseArgs
apply2
[
0
]
;
var
type
=
_parseArgs
apply2
[
1
]
;
var
settings
=
_parseArgs
apply2
[
2
]
;
if
(
!
settings
)
{
settings
=
{
}
;
}
settings
.
url
=
url
;
settings
.
type
=
type
;
return
(
0
_emberAjaxMakePromise
[
'
default
'
]
)
(
settings
)
;
}
}
)
;
define
(
'
ember
-
ajax
/
request
'
[
'
exports
'
'
ember
-
ajax
/
raw
'
'
ember
'
]
function
(
exports
_emberAjaxRaw
_ember
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
request
;
var
deprecate
=
_ember
[
'
default
'
]
.
deprecate
;
function
request
(
)
{
deprecate
(
'
ember
-
ajax
/
request
is
deprecated
and
will
be
removed
in
ember
-
ajax
2
.
0
.
0
'
false
{
id
:
'
ember
-
ajax
.
raw
'
}
)
;
return
_emberAjaxRaw
[
'
default
'
]
.
apply
(
undefined
arguments
)
.
then
(
function
(
result
)
{
return
result
.
response
;
}
null
'
ember
-
ajax
:
unwrap
raw
ajax
response
'
)
;
}
}
)
;
define
(
'
ember
-
ajax
/
services
/
ajax
'
[
'
exports
'
'
ember
'
'
ember
-
ajax
/
errors
'
'
ember
-
ajax
/
utils
/
parse
-
response
-
headers
'
]
function
(
exports
_ember
_emberAjaxErrors
_emberAjaxUtilsParseResponseHeaders
)
{
'
use
strict
'
;
var
deprecate
=
_ember
[
'
default
'
]
.
deprecate
;
var
get
=
_ember
[
'
default
'
]
.
get
;
var
isBlank
=
_ember
[
'
default
'
]
.
isBlank
;
exports
[
'
default
'
]
=
_ember
[
'
default
'
]
.
Service
.
extend
(
{
request
:
function
request
(
url
options
)
{
var
_this
=
this
;
var
opts
;
if
(
arguments
.
length
>
2
|
|
typeof
options
=
=
=
'
string
'
)
{
deprecate
(
'
ember
-
ajax
/
ajax
#
request
calling
request
with
type
is
deprecated
and
will
be
removed
in
ember
-
ajax
1
.
0
.
0
.
If
you
want
to
specify
a
type
pass
an
object
like
{
type
:
\
'
DELETE
\
'
}
'
false
{
id
:
'
ember
-
ajax
.
service
.
request
'
}
)
;
if
(
arguments
.
length
>
2
)
{
opts
=
arguments
[
2
]
;
opts
.
type
=
options
;
}
else
{
opts
=
{
type
:
options
}
;
}
}
else
{
opts
=
options
;
}
var
hash
=
this
.
options
(
url
opts
)
;
return
new
_ember
[
'
default
'
]
.
RSVP
.
Promise
(
function
(
resolve
reject
)
{
hash
.
success
=
function
(
payload
textStatus
jqXHR
)
{
var
response
=
_this
.
handleResponse
(
jqXHR
.
status
(
0
_emberAjaxUtilsParseResponseHeaders
[
'
default
'
]
)
(
jqXHR
.
getAllResponseHeaders
(
)
)
payload
)
;
if
(
response
instanceof
_emberAjaxErrors
.
AjaxError
)
{
reject
(
response
)
;
}
else
{
resolve
(
response
)
;
}
}
;
hash
.
error
=
function
(
jqXHR
textStatus
errorThrown
)
{
var
error
=
undefined
;
if
(
!
(
error
instanceof
Error
)
)
{
if
(
errorThrown
instanceof
Error
)
{
error
=
errorThrown
;
}
else
{
error
=
_this
.
handleResponse
(
jqXHR
.
status
(
0
_emberAjaxUtilsParseResponseHeaders
[
'
default
'
]
)
(
jqXHR
.
getAllResponseHeaders
(
)
)
_this
.
parseErrorResponse
(
jqXHR
.
responseText
)
|
|
errorThrown
)
;
}
}
reject
(
error
)
;
}
;
_ember
[
'
default
'
]
.
.
ajax
(
hash
)
;
}
'
ember
-
ajax
:
'
+
hash
.
type
+
'
to
'
+
url
)
;
}
post
:
function
post
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
POST
'
)
)
;
}
put
:
function
put
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
PUT
'
)
)
;
}
patch
:
function
patch
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
PATCH
'
)
)
;
}
del
:
function
del
(
url
options
)
{
return
this
.
request
(
url
this
.
_addTypeToOptionsFor
(
options
'
DELETE
'
)
)
;
}
_addTypeToOptionsFor
:
function
_addTypeToOptionsFor
(
options
method
)
{
options
=
options
|
|
{
}
;
options
.
type
=
method
;
return
options
;
}
options
:
function
options
(
url
_options
)
{
var
hash
=
_options
|
|
{
}
;
hash
.
url
=
this
.
_buildURL
(
url
)
;
hash
.
type
=
hash
.
type
|
|
'
GET
'
;
hash
.
dataType
=
hash
.
dataType
|
|
'
json
'
;
hash
.
context
=
this
;
var
headers
=
get
(
this
'
headers
'
)
;
if
(
headers
!
=
=
undefined
)
{
hash
.
beforeSend
=
function
(
xhr
)
{
Object
.
keys
(
headers
)
.
forEach
(
function
(
key
)
{
return
xhr
.
setRequestHeader
(
key
headers
[
key
]
)
;
}
)
;
}
;
}
return
hash
;
}
_buildURL
:
function
_buildURL
(
url
)
{
var
host
=
get
(
this
'
host
'
)
;
if
(
isBlank
(
host
)
)
{
return
url
;
}
var
startsWith
=
String
.
prototype
.
startsWith
|
|
function
(
searchString
position
)
{
position
=
position
|
|
0
;
return
this
.
indexOf
(
searchString
position
)
=
=
=
position
;
}
;
if
(
startsWith
.
call
(
url
'
/
'
)
)
{
return
'
'
+
host
+
url
;
}
else
{
return
host
+
'
/
'
+
url
;
}
}
handleResponse
:
function
handleResponse
(
status
headers
payload
)
{
if
(
this
.
isSuccess
(
status
headers
payload
)
)
{
return
payload
;
}
else
if
(
this
.
isUnauthorized
(
status
headers
payload
)
)
{
return
new
_emberAjaxErrors
.
UnauthorizedError
(
payload
.
errors
)
;
}
else
if
(
this
.
isForbidden
(
status
headers
payload
)
)
{
return
new
_emberAjaxErrors
.
ForbiddenError
(
payload
.
errors
)
;
}
else
if
(
this
.
isInvalid
(
status
headers
payload
)
)
{
return
new
_emberAjaxErrors
.
InvalidError
(
payload
.
errors
)
;
}
var
errors
=
this
.
normalizeErrorResponse
(
status
headers
payload
)
;
return
new
_emberAjaxErrors
.
AjaxError
(
errors
)
;
}
isUnauthorized
:
function
isUnauthorized
(
status
)
{
return
status
=
=
=
401
;
}
isForbidden
:
function
isForbidden
(
status
)
{
return
status
=
=
=
403
;
}
isInvalid
:
function
isInvalid
(
status
)
{
return
status
=
=
=
422
;
}
isSuccess
:
function
isSuccess
(
status
)
{
return
status
>
=
200
&
&
status
<
300
|
|
status
=
=
=
304
;
}
parseErrorResponse
:
function
parseErrorResponse
(
responseText
)
{
var
json
=
responseText
;
try
{
json
=
_ember
[
'
default
'
]
.
.
parseJSON
(
responseText
)
;
}
catch
(
e
)
{
}
return
json
;
}
normalizeErrorResponse
:
function
normalizeErrorResponse
(
status
headers
payload
)
{
if
(
payload
&
&
typeof
payload
=
=
=
'
object
'
&
&
payload
.
errors
)
{
return
payload
.
errors
;
}
else
{
return
[
{
status
:
'
'
+
status
title
:
"
The
backend
responded
with
an
error
"
detail
:
'
'
+
payload
}
]
;
}
}
}
)
;
}
)
;
define
(
"
ember
-
ajax
/
utils
/
parse
-
args
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
var
_slicedToArray
=
(
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
)
(
)
;
exports
[
"
default
"
]
=
parseArgs
;
function
parseArgs
(
)
{
var
args
=
[
]
.
slice
.
apply
(
arguments
)
;
if
(
args
.
length
=
=
=
1
)
{
if
(
typeof
args
[
0
]
=
=
=
"
string
"
)
{
var
_args
=
_slicedToArray
(
args
1
)
;
var
url
=
_args
[
0
]
;
return
[
url
]
;
}
else
{
var
_args2
=
_slicedToArray
(
args
1
)
;
var
options
=
_args2
[
0
]
;
var
url
=
options
.
url
;
delete
options
.
url
;
var
type
=
options
.
type
|
|
options
.
method
;
delete
options
.
type
;
delete
options
.
method
;
return
[
url
type
options
]
;
}
}
if
(
args
.
length
=
=
=
2
)
{
var
_args3
=
_slicedToArray
(
args
1
)
;
var
url
=
_args3
[
0
]
;
if
(
typeof
args
[
1
]
=
=
=
'
object
'
)
{
var
options
=
args
[
1
]
;
var
type
=
options
.
type
|
|
options
.
method
;
delete
options
.
type
;
delete
options
.
method
;
return
[
url
type
options
]
;
}
else
{
var
type
=
args
[
1
]
;
return
[
url
type
]
;
}
}
return
args
;
}
}
)
;
define
(
'
ember
-
ajax
/
utils
/
parse
-
response
-
headers
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
parseResponseHeaders
;
function
parseResponseHeaders
(
headerStr
)
{
var
headers
=
Object
.
create
(
null
)
;
if
(
!
headerStr
)
{
return
headers
;
}
var
headerPairs
=
headerStr
.
split
(
'
\
r
\
n
'
)
;
for
(
var
i
=
0
;
i
<
headerPairs
.
length
;
i
+
+
)
{
var
headerPair
=
headerPairs
[
i
]
;
var
index
=
headerPair
.
indexOf
(
'
:
'
)
;
if
(
index
>
0
)
{
var
key
=
headerPair
.
substring
(
0
index
)
;
var
val
=
headerPair
.
substring
(
index
+
2
)
;
headers
[
key
]
=
val
;
}
}
return
headers
;
}
}
)
;
define
(
'
ember
-
cli
-
app
-
version
/
components
/
app
-
version
'
[
'
exports
'
'
ember
'
'
ember
-
cli
-
app
-
version
/
templates
/
app
-
version
'
]
function
(
exports
_ember
_emberCliAppVersionTemplatesAppVersion
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
_ember
[
'
default
'
]
.
Component
.
extend
(
{
tagName
:
'
span
'
layout
:
_emberCliAppVersionTemplatesAppVersion
[
'
default
'
]
}
)
;
}
)
;
define
(
'
ember
-
cli
-
app
-
version
/
initializer
-
factory
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
initializerFactory
;
var
classify
=
_ember
[
'
default
'
]
.
String
.
classify
;
function
initializerFactory
(
name
version
)
{
var
registered
=
false
;
return
function
(
)
{
if
(
!
registered
&
&
name
&
&
version
)
{
var
appName
=
classify
(
name
)
;
_ember
[
'
default
'
]
.
libraries
.
register
(
appName
version
)
;
registered
=
true
;
}
}
;
}
}
)
;
define
(
"
ember
-
cli
-
app
-
version
/
templates
/
app
-
version
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
[
"
default
"
]
=
Ember
.
HTMLBars
.
template
(
(
function
(
)
{
return
{
meta
:
{
"
fragmentReason
"
:
{
"
name
"
:
"
missing
-
wrapper
"
"
problems
"
:
[
"
wrong
-
type
"
]
}
"
revision
"
:
"
Ember
2
.
6
.
2
"
"
loc
"
:
{
"
source
"
:
null
"
start
"
:
{
"
line
"
:
1
"
column
"
:
0
}
"
end
"
:
{
"
line
"
:
2
"
column
"
:
0
}
}
"
moduleName
"
:
"
modules
/
ember
-
cli
-
app
-
version
/
templates
/
app
-
version
.
hbs
"
}
isEmpty
:
false
arity
:
0
cachedFragment
:
null
hasRendered
:
false
buildFragment
:
function
buildFragment
(
dom
)
{
var
el0
=
dom
.
createDocumentFragment
(
)
;
var
el1
=
dom
.
createComment
(
"
"
)
;
dom
.
appendChild
(
el0
el1
)
;
var
el1
=
dom
.
createTextNode
(
"
\
n
"
)
;
dom
.
appendChild
(
el0
el1
)
;
return
el0
;
}
buildRenderNodes
:
function
buildRenderNodes
(
dom
fragment
contextualElement
)
{
var
morphs
=
new
Array
(
1
)
;
morphs
[
0
]
=
dom
.
createMorphAt
(
fragment
0
0
contextualElement
)
;
dom
.
insertBoundary
(
fragment
0
)
;
return
morphs
;
}
statements
:
[
[
"
content
"
"
version
"
[
"
loc
"
[
null
[
1
0
]
[
1
11
]
]
]
]
]
locals
:
[
]
templates
:
[
]
}
;
}
)
(
)
)
;
}
)
;
define
(
"
ember
-
inflector
/
index
"
[
"
exports
"
"
ember
"
"
ember
-
inflector
/
lib
/
system
"
"
ember
-
inflector
/
lib
/
ext
/
string
"
]
function
(
exports
_ember
_emberInflectorLibSystem
_emberInflectorLibExtString
)
{
"
use
strict
"
;
_emberInflectorLibSystem
.
Inflector
.
defaultRules
=
_emberInflectorLibSystem
.
defaultRules
;
_ember
[
"
default
"
]
.
Inflector
=
_emberInflectorLibSystem
.
Inflector
;
_ember
[
"
default
"
]
.
String
.
pluralize
=
_emberInflectorLibSystem
.
pluralize
;
_ember
[
"
default
"
]
.
String
.
singularize
=
_emberInflectorLibSystem
.
singularize
;
exports
[
"
default
"
]
=
_emberInflectorLibSystem
.
Inflector
;
exports
.
pluralize
=
_emberInflectorLibSystem
.
pluralize
;
exports
.
singularize
=
_emberInflectorLibSystem
.
singularize
;
exports
.
defaultRules
=
_emberInflectorLibSystem
.
defaultRules
;
if
(
typeof
define
!
=
=
'
undefined
'
&
&
define
.
amd
)
{
define
(
'
ember
-
inflector
'
[
'
exports
'
]
function
(
__exports__
)
{
__exports__
[
'
default
'
]
=
_emberInflectorLibSystem
.
Inflector
;
return
_emberInflectorLibSystem
.
Inflector
;
}
)
;
}
else
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
[
'
exports
'
]
)
{
module
[
'
exports
'
]
=
_emberInflectorLibSystem
.
Inflector
;
}
}
)
;
define
(
'
ember
-
inflector
/
lib
/
ext
/
string
'
[
'
exports
'
'
ember
'
'
ember
-
inflector
/
lib
/
system
/
string
'
]
function
(
exports
_ember
_emberInflectorLibSystemString
)
{
'
use
strict
'
;
if
(
_ember
[
'
default
'
]
.
EXTEND_PROTOTYPES
=
=
=
true
|
|
_ember
[
'
default
'
]
.
EXTEND_PROTOTYPES
.
String
)
{
String
.
prototype
.
pluralize
=
function
(
)
{
return
(
0
_emberInflectorLibSystemString
.
pluralize
)
(
this
)
;
}
;
String
.
prototype
.
singularize
=
function
(
)
{
return
(
0
_emberInflectorLibSystemString
.
singularize
)
(
this
)
;
}
;
}
}
)
;
define
(
'
ember
-
inflector
/
lib
/
helpers
/
pluralize
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
inflector
/
lib
/
utils
/
make
-
helper
'
]
function
(
exports
_emberInflector
_emberInflectorLibUtilsMakeHelper
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
(
0
_emberInflectorLibUtilsMakeHelper
[
'
default
'
]
)
(
function
(
params
)
{
var
count
=
undefined
word
=
undefined
;
if
(
params
.
length
=
=
=
1
)
{
word
=
params
[
0
]
;
return
(
0
_emberInflector
.
pluralize
)
(
word
)
;
}
else
{
count
=
params
[
0
]
;
word
=
params
[
1
]
;
if
(
parseFloat
(
count
)
!
=
=
1
)
{
word
=
(
0
_emberInflector
.
pluralize
)
(
word
)
;
}
return
count
+
"
"
+
word
;
}
}
)
;
}
)
;
define
(
'
ember
-
inflector
/
lib
/
helpers
/
singularize
'
[
'
exports
'
'
ember
-
inflector
'
'
ember
-
inflector
/
lib
/
utils
/
make
-
helper
'
]
function
(
exports
_emberInflector
_emberInflectorLibUtilsMakeHelper
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
(
0
_emberInflectorLibUtilsMakeHelper
[
'
default
'
]
)
(
function
(
params
)
{
return
(
0
_emberInflector
.
singularize
)
(
params
[
0
]
)
;
}
)
;
}
)
;
define
(
"
ember
-
inflector
/
lib
/
system
"
[
"
exports
"
"
ember
-
inflector
/
lib
/
system
/
inflector
"
"
ember
-
inflector
/
lib
/
system
/
string
"
"
ember
-
inflector
/
lib
/
system
/
inflections
"
]
function
(
exports
_emberInflectorLibSystemInflector
_emberInflectorLibSystemString
_emberInflectorLibSystemInflections
)
{
"
use
strict
"
;
_emberInflectorLibSystemInflector
[
"
default
"
]
.
inflector
=
new
_emberInflectorLibSystemInflector
[
"
default
"
]
(
_emberInflectorLibSystemInflections
[
"
default
"
]
)
;
exports
.
Inflector
=
_emberInflectorLibSystemInflector
[
"
default
"
]
;
exports
.
singularize
=
_emberInflectorLibSystemString
.
singularize
;
exports
.
pluralize
=
_emberInflectorLibSystemString
.
pluralize
;
exports
.
defaultRules
=
_emberInflectorLibSystemInflections
[
"
default
"
]
;
}
)
;
define
(
'
ember
-
inflector
/
lib
/
system
/
inflections
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
{
plurals
:
[
[
/
/
'
s
'
]
[
/
s
/
i
'
s
'
]
[
/
^
(
ax
|
test
)
is
/
i
'
1es
'
]
[
/
(
octop
|
vir
)
us
/
i
'
1i
'
]
[
/
(
octop
|
vir
)
i
/
i
'
1i
'
]
[
/
(
alias
|
status
)
/
i
'
1es
'
]
[
/
(
bu
)
s
/
i
'
1ses
'
]
[
/
(
buffal
|
tomat
)
o
/
i
'
1oes
'
]
[
/
(
[
ti
]
)
um
/
i
'
1a
'
]
[
/
(
[
ti
]
)
a
/
i
'
1a
'
]
[
/
sis
/
i
'
ses
'
]
[
/
(
?
:
(
[
^
f
]
)
fe
|
(
[
lr
]
)
f
)
/
i
'
1
2ves
'
]
[
/
(
hive
)
/
i
'
1s
'
]
[
/
(
[
^
aeiouy
]
|
qu
)
y
/
i
'
1ies
'
]
[
/
(
x
|
ch
|
ss
|
sh
)
/
i
'
1es
'
]
[
/
(
matr
|
vert
|
ind
)
(
?
:
ix
|
ex
)
/
i
'
1ices
'
]
[
/
^
(
m
|
l
)
ouse
/
i
'
1ice
'
]
[
/
^
(
m
|
l
)
ice
/
i
'
1ice
'
]
[
/
^
(
ox
)
/
i
'
1en
'
]
[
/
^
(
oxen
)
/
i
'
1
'
]
[
/
(
quiz
)
/
i
'
1zes
'
]
]
singular
:
[
[
/
s
/
i
'
'
]
[
/
(
ss
)
/
i
'
1
'
]
[
/
(
n
)
ews
/
i
'
1ews
'
]
[
/
(
[
ti
]
)
a
/
i
'
1um
'
]
[
/
(
(
a
)
naly
|
(
b
)
a
|
(
d
)
iagno
|
(
p
)
arenthe
|
(
p
)
rogno
|
(
s
)
ynop
|
(
t
)
he
)
(
sis
|
ses
)
/
i
'
1sis
'
]
[
/
(
^
analy
)
(
sis
|
ses
)
/
i
'
1sis
'
]
[
/
(
[
^
f
]
)
ves
/
i
'
1fe
'
]
[
/
(
hive
)
s
/
i
'
1
'
]
[
/
(
tive
)
s
/
i
'
1
'
]
[
/
(
[
lr
]
)
ves
/
i
'
1f
'
]
[
/
(
[
^
aeiouy
]
|
qu
)
ies
/
i
'
1y
'
]
[
/
(
s
)
eries
/
i
'
1eries
'
]
[
/
(
m
)
ovies
/
i
'
1ovie
'
]
[
/
(
x
|
ch
|
ss
|
sh
)
es
/
i
'
1
'
]
[
/
^
(
m
|
l
)
ice
/
i
'
1ouse
'
]
[
/
(
bus
)
(
es
)
?
/
i
'
1
'
]
[
/
(
o
)
es
/
i
'
1
'
]
[
/
(
shoe
)
s
/
i
'
1
'
]
[
/
(
cris
|
test
)
(
is
|
es
)
/
i
'
1is
'
]
[
/
^
(
a
)
x
[
ie
]
s
/
i
'
1xis
'
]
[
/
(
octop
|
vir
)
(
us
|
i
)
/
i
'
1us
'
]
[
/
(
alias
|
status
)
(
es
)
?
/
i
'
1
'
]
[
/
^
(
ox
)
en
/
i
'
1
'
]
[
/
(
vert
|
ind
)
ices
/
i
'
1ex
'
]
[
/
(
matr
)
ices
/
i
'
1ix
'
]
[
/
(
quiz
)
zes
/
i
'
1
'
]
[
/
(
database
)
s
/
i
'
1
'
]
]
irregularPairs
:
[
[
'
person
'
'
people
'
]
[
'
man
'
'
men
'
]
[
'
child
'
'
children
'
]
[
'
sex
'
'
sexes
'
]
[
'
move
'
'
moves
'
]
[
'
cow
'
'
kine
'
]
[
'
zombie
'
'
zombies
'
]
]
uncountable
:
[
'
equipment
'
'
information
'
'
rice
'
'
money
'
'
species
'
'
series
'
'
fish
'
'
sheep
'
'
jeans
'
'
police
'
]
}
;
}
)
;
define
(
'
ember
-
inflector
/
lib
/
system
/
inflector
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
var
capitalize
=
_ember
[
'
default
'
]
.
String
.
capitalize
;
var
BLANK_REGEX
=
/
^
\
s
*
/
;
var
LAST_WORD_DASHED_REGEX
=
/
(
[
\
w
/
-
]
+
[
_
/
\
s
-
]
)
(
[
a
-
z
\
d
]
+
)
/
;
var
LAST_WORD_CAMELIZED_REGEX
=
/
(
[
\
w
/
\
s
-
]
+
)
(
[
A
-
Z
]
[
a
-
z
\
d
]
*
)
/
;
var
CAMELIZED_REGEX
=
/
[
A
-
Z
]
[
a
-
z
\
d
]
*
/
;
function
loadUncountable
(
rules
uncountable
)
{
for
(
var
i
=
0
length
=
uncountable
.
length
;
i
<
length
;
i
+
+
)
{
rules
.
uncountable
[
uncountable
[
i
]
.
toLowerCase
(
)
]
=
true
;
}
}
function
loadIrregular
(
rules
irregularPairs
)
{
var
pair
;
for
(
var
i
=
0
length
=
irregularPairs
.
length
;
i
<
length
;
i
+
+
)
{
pair
=
irregularPairs
[
i
]
;
rules
.
irregular
[
pair
[
0
]
.
toLowerCase
(
)
]
=
pair
[
1
]
;
rules
.
irregular
[
pair
[
1
]
.
toLowerCase
(
)
]
=
pair
[
1
]
;
rules
.
irregularInverse
[
pair
[
1
]
.
toLowerCase
(
)
]
=
pair
[
0
]
;
rules
.
irregularInverse
[
pair
[
0
]
.
toLowerCase
(
)
]
=
pair
[
0
]
;
}
}
function
Inflector
(
ruleSet
)
{
ruleSet
=
ruleSet
|
|
{
}
;
ruleSet
.
uncountable
=
ruleSet
.
uncountable
|
|
makeDictionary
(
)
;
ruleSet
.
irregularPairs
=
ruleSet
.
irregularPairs
|
|
makeDictionary
(
)
;
var
rules
=
this
.
rules
=
{
plurals
:
ruleSet
.
plurals
|
|
[
]
singular
:
ruleSet
.
singular
|
|
[
]
irregular
:
makeDictionary
(
)
irregularInverse
:
makeDictionary
(
)
uncountable
:
makeDictionary
(
)
}
;
loadUncountable
(
rules
ruleSet
.
uncountable
)
;
loadIrregular
(
rules
ruleSet
.
irregularPairs
)
;
this
.
enableCache
(
)
;
}
if
(
!
Object
.
create
&
&
!
Object
.
create
(
null
)
.
hasOwnProperty
)
{
throw
new
Error
(
"
This
browser
does
not
support
Object
.
create
(
null
)
please
polyfil
with
es5
-
sham
:
http
:
/
/
git
.
io
/
yBU2rg
"
)
;
}
function
makeDictionary
(
)
{
var
cache
=
Object
.
create
(
null
)
;
cache
[
'
_dict
'
]
=
null
;
delete
cache
[
'
_dict
'
]
;
return
cache
;
}
Inflector
.
prototype
=
{
enableCache
:
function
enableCache
(
)
{
this
.
purgeCache
(
)
;
this
.
singularize
=
function
(
word
)
{
this
.
_cacheUsed
=
true
;
return
this
.
_sCache
[
word
]
|
|
(
this
.
_sCache
[
word
]
=
this
.
_singularize
(
word
)
)
;
}
;
this
.
pluralize
=
function
(
word
)
{
this
.
_cacheUsed
=
true
;
return
this
.
_pCache
[
word
]
|
|
(
this
.
_pCache
[
word
]
=
this
.
_pluralize
(
word
)
)
;
}
;
}
purgeCache
:
function
purgeCache
(
)
{
this
.
_cacheUsed
=
false
;
this
.
_sCache
=
makeDictionary
(
)
;
this
.
_pCache
=
makeDictionary
(
)
;
}
disableCache
:
function
disableCache
(
)
{
this
.
_sCache
=
null
;
this
.
_pCache
=
null
;
this
.
singularize
=
function
(
word
)
{
return
this
.
_singularize
(
word
)
;
}
;
this
.
pluralize
=
function
(
word
)
{
return
this
.
_pluralize
(
word
)
;
}
;
}
plural
:
function
plural
(
regex
string
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
this
.
rules
.
plurals
.
push
(
[
regex
string
.
toLowerCase
(
)
]
)
;
}
singular
:
function
singular
(
regex
string
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
this
.
rules
.
singular
.
push
(
[
regex
string
.
toLowerCase
(
)
]
)
;
}
uncountable
:
function
uncountable
(
string
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
loadUncountable
(
this
.
rules
[
string
.
toLowerCase
(
)
]
)
;
}
irregular
:
function
irregular
(
singular
plural
)
{
if
(
this
.
_cacheUsed
)
{
this
.
purgeCache
(
)
;
}
loadIrregular
(
this
.
rules
[
[
singular
plural
]
]
)
;
}
pluralize
:
function
pluralize
(
word
)
{
return
this
.
_pluralize
(
word
)
;
}
_pluralize
:
function
_pluralize
(
word
)
{
return
this
.
inflect
(
word
this
.
rules
.
plurals
this
.
rules
.
irregular
)
;
}
singularize
:
function
singularize
(
word
)
{
return
this
.
_singularize
(
word
)
;
}
_singularize
:
function
_singularize
(
word
)
{
return
this
.
inflect
(
word
this
.
rules
.
singular
this
.
rules
.
irregularInverse
)
;
}
inflect
:
function
inflect
(
word
typeRules
irregular
)
{
var
inflection
substitution
result
lowercase
wordSplit
firstPhrase
lastWord
isBlank
isCamelized
rule
isUncountable
;
isBlank
=
!
word
|
|
BLANK_REGEX
.
test
(
word
)
;
isCamelized
=
CAMELIZED_REGEX
.
test
(
word
)
;
firstPhrase
=
"
"
;
if
(
isBlank
)
{
return
word
;
}
lowercase
=
word
.
toLowerCase
(
)
;
wordSplit
=
LAST_WORD_DASHED_REGEX
.
exec
(
word
)
|
|
LAST_WORD_CAMELIZED_REGEX
.
exec
(
word
)
;
if
(
wordSplit
)
{
firstPhrase
=
wordSplit
[
1
]
;
lastWord
=
wordSplit
[
2
]
.
toLowerCase
(
)
;
}
isUncountable
=
this
.
rules
.
uncountable
[
lowercase
]
|
|
this
.
rules
.
uncountable
[
lastWord
]
;
if
(
isUncountable
)
{
return
word
;
}
for
(
rule
in
this
.
rules
.
irregular
)
{
if
(
lowercase
.
match
(
rule
+
"
"
)
)
{
substitution
=
irregular
[
rule
]
;
if
(
isCamelized
&
&
irregular
[
lastWord
]
)
{
substitution
=
capitalize
(
substitution
)
;
rule
=
capitalize
(
rule
)
;
}
return
word
.
replace
(
rule
substitution
)
;
}
}
for
(
var
i
=
typeRules
.
length
min
=
0
;
i
>
min
;
i
-
-
)
{
inflection
=
typeRules
[
i
-
1
]
;
rule
=
inflection
[
0
]
;
if
(
rule
.
test
(
word
)
)
{
break
;
}
}
inflection
=
inflection
|
|
[
]
;
rule
=
inflection
[
0
]
;
substitution
=
inflection
[
1
]
;
result
=
word
.
replace
(
rule
substitution
)
;
return
result
;
}
}
;
exports
[
'
default
'
]
=
Inflector
;
}
)
;
define
(
'
ember
-
inflector
/
lib
/
system
/
string
'
[
'
exports
'
'
ember
-
inflector
/
lib
/
system
/
inflector
'
]
function
(
exports
_emberInflectorLibSystemInflector
)
{
'
use
strict
'
;
function
pluralize
(
word
)
{
return
_emberInflectorLibSystemInflector
[
'
default
'
]
.
inflector
.
pluralize
(
word
)
;
}
function
singularize
(
word
)
{
return
_emberInflectorLibSystemInflector
[
'
default
'
]
.
inflector
.
singularize
(
word
)
;
}
exports
.
pluralize
=
pluralize
;
exports
.
singularize
=
singularize
;
}
)
;
define
(
'
ember
-
inflector
/
lib
/
utils
/
make
-
helper
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
makeHelper
;
function
makeHelper
(
helperFunction
)
{
if
(
_ember
[
'
default
'
]
.
Helper
)
{
return
_ember
[
'
default
'
]
.
Helper
.
helper
(
helperFunction
)
;
}
if
(
_ember
[
'
default
'
]
.
HTMLBars
)
{
return
_ember
[
'
default
'
]
.
HTMLBars
.
makeBoundHelper
(
helperFunction
)
;
}
return
_ember
[
'
default
'
]
.
Handlebars
.
makeBoundHelper
(
helperFunction
)
;
}
}
)
;
define
(
'
ember
-
load
-
initializers
/
index
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
function
(
app
prefix
)
{
var
regex
=
new
RegExp
(
'
^
'
+
prefix
+
'
\
/
(
(
?
:
instance
-
)
?
initializers
)
\
/
'
)
;
var
getKeys
=
Object
.
keys
|
|
_ember
[
'
default
'
]
.
keys
;
getKeys
(
requirejs
.
_eak_seen
)
.
map
(
function
(
moduleName
)
{
return
{
moduleName
:
moduleName
matches
:
regex
.
exec
(
moduleName
)
}
;
}
)
.
filter
(
function
(
dep
)
{
return
dep
.
matches
&
&
dep
.
matches
.
length
=
=
=
2
;
}
)
.
forEach
(
function
(
dep
)
{
var
moduleName
=
dep
.
moduleName
;
var
module
=
require
(
moduleName
null
null
true
)
;
if
(
!
module
)
{
throw
new
Error
(
moduleName
+
'
must
export
an
initializer
.
'
)
;
}
var
initializerType
=
_ember
[
'
default
'
]
.
String
.
camelize
(
dep
.
matches
[
1
]
.
substring
(
0
dep
.
matches
[
1
]
.
length
-
1
)
)
;
var
initializer
=
module
[
'
default
'
]
;
if
(
!
initializer
.
name
)
{
var
initializerName
=
moduleName
.
match
(
/
[
^
\
/
]
+
\
/
?
/
)
[
0
]
;
initializer
.
name
=
initializerName
;
}
if
(
app
[
initializerType
]
)
{
app
[
initializerType
]
(
initializer
)
;
}
}
)
;
}
;
}
)
;
define
(
'
ember
-
resolver
/
container
-
debug
-
adapter
'
[
'
exports
'
'
ember
'
'
ember
-
resolver
/
utils
/
module
-
registry
'
]
function
(
exports
_ember
_emberResolverUtilsModuleRegistry
)
{
'
use
strict
'
;
var
ContainerDebugAdapter
=
_ember
[
'
default
'
]
.
ContainerDebugAdapter
;
var
ModulesContainerDebugAdapter
=
null
;
function
getPod
(
type
key
prefix
)
{
var
match
=
key
.
match
(
new
RegExp
(
'
^
/
?
'
+
prefix
+
'
/
(
.
+
)
/
'
+
type
+
'
'
)
)
;
if
(
match
)
{
return
match
[
1
]
;
}
}
if
(
typeof
ContainerDebugAdapter
!
=
=
'
undefined
'
)
{
ModulesContainerDebugAdapter
=
ContainerDebugAdapter
.
extend
(
{
_moduleRegistry
:
null
init
:
function
init
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
if
(
!
this
.
_moduleRegistry
)
{
this
.
_moduleRegistry
=
new
_emberResolverUtilsModuleRegistry
[
'
default
'
]
(
)
;
}
}
canCatalogEntriesByType
:
function
canCatalogEntriesByType
(
)
{
return
true
;
}
catalogEntriesByType
:
function
catalogEntriesByType
(
type
)
{
var
moduleNames
=
this
.
_moduleRegistry
.
moduleNames
(
)
;
var
types
=
_ember
[
'
default
'
]
.
A
(
)
;
var
prefix
=
this
.
namespace
.
modulePrefix
;
for
(
var
i
=
0
l
=
moduleNames
.
length
;
i
<
l
;
i
+
+
)
{
var
key
=
moduleNames
[
i
]
;
if
(
key
.
indexOf
(
type
)
!
=
=
-
1
)
{
var
name
=
getPod
(
type
key
this
.
namespace
.
podModulePrefix
|
|
prefix
)
;
if
(
!
name
)
{
name
=
key
.
split
(
type
+
'
s
/
'
)
.
pop
(
)
;
}
types
.
addObject
(
name
)
;
}
}
return
types
;
}
}
)
;
}
exports
[
'
default
'
]
=
ModulesContainerDebugAdapter
;
}
)
;
define
(
'
ember
-
resolver
/
index
'
[
'
exports
'
'
ember
-
resolver
/
resolver
'
]
function
(
exports
_emberResolverResolver
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
get
(
)
{
return
_emberResolverResolver
[
'
default
'
]
;
}
}
)
;
}
)
;
define
(
'
ember
-
resolver
/
resolver
'
[
'
exports
'
'
ember
'
'
ember
-
resolver
/
utils
/
module
-
registry
'
'
ember
-
resolver
/
utils
/
class
-
factory
'
'
ember
-
resolver
/
utils
/
make
-
dictionary
'
]
function
(
exports
_ember
_emberResolverUtilsModuleRegistry
_emberResolverUtilsClassFactory
_emberResolverUtilsMakeDictionary
)
{
'
use
strict
'
;
var
_Ember
String
=
_ember
[
'
default
'
]
.
String
;
var
underscore
=
_Ember
String
.
underscore
;
var
classify
=
_Ember
String
.
classify
;
var
dasherize
=
_Ember
String
.
dasherize
;
var
get
=
_ember
[
'
default
'
]
.
get
;
var
DefaultResolver
=
_ember
[
'
default
'
]
.
DefaultResolver
;
function
parseName
(
fullName
)
{
if
(
fullName
.
parsedName
=
=
=
true
)
{
return
fullName
;
}
var
prefix
type
name
;
var
fullNameParts
=
fullName
.
split
(
'
'
)
;
if
(
fullName
!
=
=
'
helper
:
content
-
helper
'
&
&
fullNameParts
.
length
=
=
=
2
)
{
var
prefixParts
=
fullNameParts
[
0
]
.
split
(
'
:
'
)
;
if
(
prefixParts
.
length
=
=
=
2
)
{
prefix
=
prefixParts
[
1
]
;
type
=
prefixParts
[
0
]
;
name
=
fullNameParts
[
1
]
;
}
else
{
var
nameParts
=
fullNameParts
[
1
]
.
split
(
'
:
'
)
;
prefix
=
fullNameParts
[
0
]
;
type
=
nameParts
[
0
]
;
name
=
nameParts
[
1
]
;
}
}
else
{
fullNameParts
=
fullName
.
split
(
'
:
'
)
;
type
=
fullNameParts
[
0
]
;
name
=
fullNameParts
[
1
]
;
}
var
fullNameWithoutType
=
name
;
var
namespace
=
get
(
this
'
namespace
'
)
;
var
root
=
namespace
;
return
{
parsedName
:
true
fullName
:
fullName
prefix
:
prefix
|
|
this
.
prefix
(
{
type
:
type
}
)
type
:
type
fullNameWithoutType
:
fullNameWithoutType
name
:
name
root
:
root
resolveMethodName
:
"
resolve
"
+
classify
(
type
)
}
;
}
function
resolveOther
(
parsedName
)
{
_ember
[
'
default
'
]
.
assert
(
'
modulePrefix
must
be
defined
'
this
.
namespace
.
modulePrefix
)
;
var
normalizedModuleName
=
this
.
findModuleName
(
parsedName
)
;
if
(
normalizedModuleName
)
{
var
defaultExport
=
this
.
_extractDefaultExport
(
normalizedModuleName
parsedName
)
;
if
(
defaultExport
=
=
=
undefined
)
{
throw
new
Error
(
"
Expected
to
find
:
'
"
+
parsedName
.
fullName
+
"
'
within
'
"
+
normalizedModuleName
+
"
'
but
got
'
undefined
'
.
Did
you
forget
to
export
default
within
'
"
+
normalizedModuleName
+
"
'
?
"
)
;
}
if
(
this
.
shouldWrapInClassFactory
(
defaultExport
parsedName
)
)
{
defaultExport
=
(
0
_emberResolverUtilsClassFactory
[
'
default
'
]
)
(
defaultExport
)
;
}
return
defaultExport
;
}
else
{
return
this
.
_super
(
parsedName
)
;
}
}
var
Resolver
=
DefaultResolver
.
extend
(
{
resolveOther
:
resolveOther
parseName
:
parseName
resolveTemplate
:
resolveOther
pluralizedTypes
:
null
moduleRegistry
:
null
makeToString
:
function
makeToString
(
factory
fullName
)
{
return
'
'
+
this
.
namespace
.
modulePrefix
+
'
'
+
fullName
+
'
:
'
;
}
shouldWrapInClassFactory
:
function
shouldWrapInClassFactory
(
)
{
return
false
;
}
init
:
function
init
(
)
{
this
.
_super
(
)
;
this
.
moduleBasedResolver
=
true
;
if
(
!
this
.
_moduleRegistry
)
{
this
.
_moduleRegistry
=
new
_emberResolverUtilsModuleRegistry
[
'
default
'
]
(
)
;
}
this
.
_normalizeCache
=
(
0
_emberResolverUtilsMakeDictionary
[
'
default
'
]
)
(
)
;
this
.
pluralizedTypes
=
this
.
pluralizedTypes
|
|
(
0
_emberResolverUtilsMakeDictionary
[
'
default
'
]
)
(
)
;
if
(
!
this
.
pluralizedTypes
.
config
)
{
this
.
pluralizedTypes
.
config
=
'
config
'
;
}
this
.
_deprecatedPodModulePrefix
=
false
;
}
normalize
:
function
normalize
(
fullName
)
{
return
this
.
_normalizeCache
[
fullName
]
|
|
(
this
.
_normalizeCache
[
fullName
]
=
this
.
_normalize
(
fullName
)
)
;
}
_normalize
:
function
_normalize
(
fullName
)
{
var
split
=
fullName
.
split
(
'
:
'
)
;
if
(
split
.
length
>
1
)
{
if
(
split
[
0
]
=
=
=
'
helper
'
)
{
return
split
[
0
]
+
'
:
'
+
split
[
1
]
.
replace
(
/
_
/
g
'
-
'
)
;
}
else
{
return
split
[
0
]
+
'
:
'
+
dasherize
(
split
[
1
]
.
replace
(
/
\
.
/
g
'
/
'
)
)
;
}
}
else
{
return
fullName
;
}
}
pluralize
:
function
pluralize
(
type
)
{
return
this
.
pluralizedTypes
[
type
]
|
|
(
this
.
pluralizedTypes
[
type
]
=
type
+
'
s
'
)
;
}
podBasedLookupWithPrefix
:
function
podBasedLookupWithPrefix
(
podPrefix
parsedName
)
{
var
fullNameWithoutType
=
parsedName
.
fullNameWithoutType
;
if
(
parsedName
.
type
=
=
=
'
template
'
)
{
fullNameWithoutType
=
fullNameWithoutType
.
replace
(
/
^
components
\
/
/
'
'
)
;
}
return
podPrefix
+
'
/
'
+
fullNameWithoutType
+
'
/
'
+
parsedName
.
type
;
}
podBasedModuleName
:
function
podBasedModuleName
(
parsedName
)
{
var
podPrefix
=
this
.
namespace
.
podModulePrefix
|
|
this
.
namespace
.
modulePrefix
;
return
this
.
podBasedLookupWithPrefix
(
podPrefix
parsedName
)
;
}
podBasedComponentsInSubdir
:
function
podBasedComponentsInSubdir
(
parsedName
)
{
var
podPrefix
=
this
.
namespace
.
podModulePrefix
|
|
this
.
namespace
.
modulePrefix
;
podPrefix
=
podPrefix
+
'
/
components
'
;
if
(
parsedName
.
type
=
=
=
'
component
'
|
|
parsedName
.
fullNameWithoutType
.
match
(
/
^
components
/
)
)
{
return
this
.
podBasedLookupWithPrefix
(
podPrefix
parsedName
)
;
}
}
resolveEngine
:
function
resolveEngine
(
parsedName
)
{
var
engineName
=
parsedName
.
fullNameWithoutType
;
var
engineModule
=
engineName
+
'
/
engine
'
;
if
(
this
.
_moduleRegistry
.
has
(
engineModule
)
)
{
return
this
.
_extractDefaultExport
(
engineModule
)
;
}
}
resolveRouteMap
:
function
resolveRouteMap
(
parsedName
)
{
var
engineName
=
parsedName
.
fullNameWithoutType
;
var
engineRoutesModule
=
engineName
+
'
/
routes
'
;
if
(
this
.
_moduleRegistry
.
has
(
engineRoutesModule
)
)
{
var
routeMap
=
this
.
_extractDefaultExport
(
engineRoutesModule
)
;
_ember
[
'
default
'
]
.
assert
(
'
The
route
map
for
'
+
engineName
+
'
should
be
wrapped
by
\
'
buildRoutes
\
'
before
exporting
.
'
routeMap
.
isRouteMap
)
;
return
routeMap
;
}
}
mainModuleName
:
function
mainModuleName
(
parsedName
)
{
var
tmpModuleName
=
parsedName
.
prefix
+
'
/
'
+
parsedName
.
type
;
if
(
parsedName
.
fullNameWithoutType
=
=
=
'
main
'
)
{
return
tmpModuleName
;
}
}
defaultModuleName
:
function
defaultModuleName
(
parsedName
)
{
return
parsedName
.
prefix
+
'
/
'
+
this
.
pluralize
(
parsedName
.
type
)
+
'
/
'
+
parsedName
.
fullNameWithoutType
;
}
prefix
:
function
prefix
(
parsedName
)
{
var
tmpPrefix
=
this
.
namespace
.
modulePrefix
;
if
(
this
.
namespace
[
parsedName
.
type
+
'
Prefix
'
]
)
{
tmpPrefix
=
this
.
namespace
[
parsedName
.
type
+
'
Prefix
'
]
;
}
return
tmpPrefix
;
}
moduleNameLookupPatterns
:
_ember
[
'
default
'
]
.
computed
(
function
(
)
{
return
[
this
.
podBasedModuleName
this
.
podBasedComponentsInSubdir
this
.
mainModuleName
this
.
defaultModuleName
]
;
}
)
findModuleName
:
function
findModuleName
(
parsedName
loggingDisabled
)
{
var
moduleNameLookupPatterns
=
this
.
get
(
'
moduleNameLookupPatterns
'
)
;
var
moduleName
;
for
(
var
index
=
0
_length
=
moduleNameLookupPatterns
.
length
;
index
<
_length
;
index
+
+
)
{
var
item
=
moduleNameLookupPatterns
[
index
]
;
var
tmpModuleName
=
item
.
call
(
this
parsedName
)
;
if
(
tmpModuleName
)
{
tmpModuleName
=
this
.
chooseModuleName
(
tmpModuleName
parsedName
)
;
}
if
(
tmpModuleName
&
&
this
.
_moduleRegistry
.
has
(
tmpModuleName
)
)
{
moduleName
=
tmpModuleName
;
}
if
(
!
loggingDisabled
)
{
this
.
_logLookup
(
moduleName
parsedName
tmpModuleName
)
;
}
if
(
moduleName
)
{
return
moduleName
;
}
}
}
chooseModuleName
:
function
chooseModuleName
(
moduleName
parsedName
)
{
var
_this
=
this
;
var
underscoredModuleName
=
underscore
(
moduleName
)
;
if
(
moduleName
!
=
=
underscoredModuleName
&
&
this
.
_moduleRegistry
.
has
(
moduleName
)
&
&
this
.
_moduleRegistry
.
has
(
underscoredModuleName
)
)
{
throw
new
TypeError
(
"
Ambiguous
module
names
:
"
+
moduleName
+
"
and
"
+
underscoredModuleName
+
"
"
)
;
}
if
(
this
.
_moduleRegistry
.
has
(
moduleName
)
)
{
return
moduleName
;
}
else
if
(
this
.
_moduleRegistry
.
has
(
underscoredModuleName
)
)
{
return
underscoredModuleName
;
}
var
partializedModuleName
=
moduleName
.
replace
(
/
\
/
-
(
[
^
\
/
]
*
)
/
'
/
_
1
'
)
;
if
(
this
.
_moduleRegistry
.
has
(
partializedModuleName
)
)
{
_ember
[
'
default
'
]
.
deprecate
(
'
Modules
should
not
contain
underscores
.
'
+
'
Attempted
to
lookup
"
'
+
moduleName
+
'
"
which
'
+
'
was
not
found
.
Please
rename
"
'
+
partializedModuleName
+
'
"
'
+
'
to
"
'
+
moduleName
+
'
"
instead
.
'
false
{
id
:
'
ember
-
resolver
.
underscored
-
modules
'
until
:
'
3
.
0
.
0
'
}
)
;
return
partializedModuleName
;
}
_ember
[
'
default
'
]
.
runInDebug
(
function
(
)
{
var
isCamelCaseHelper
=
parsedName
.
type
=
=
=
'
helper
'
&
&
!
!
moduleName
.
match
(
/
[
a
-
z
]
+
[
A
-
Z
]
+
/
)
;
if
(
isCamelCaseHelper
)
{
_this
.
_camelCaseHelperWarnedNames
=
_this
.
_camelCaseHelperWarnedNames
|
|
[
]
;
var
alreadyWarned
=
_this
.
_camelCaseHelperWarnedNames
.
indexOf
(
parsedName
.
fullName
)
>
-
1
;
if
(
!
alreadyWarned
&
&
_this
.
_moduleRegistry
.
has
(
dasherize
(
moduleName
)
)
)
{
_this
.
_camelCaseHelperWarnedNames
.
push
(
parsedName
.
fullName
)
;
_ember
[
'
default
'
]
.
warn
(
'
Attempted
to
lookup
"
'
+
parsedName
.
fullName
+
'
"
which
'
+
'
was
not
found
.
In
previous
versions
of
ember
-
resolver
a
bug
would
have
'
+
'
caused
the
module
at
"
'
+
dasherize
(
moduleName
)
+
'
"
to
be
'
+
'
returned
for
this
camel
case
helper
name
.
This
has
been
fixed
.
'
+
'
Use
the
dasherized
name
to
resolve
the
module
that
would
have
been
'
+
'
returned
in
previous
versions
.
'
false
{
id
:
'
ember
-
resolver
.
camelcase
-
helper
-
names
'
until
:
'
3
.
0
.
0
'
}
)
;
}
}
}
)
;
}
lookupDescription
:
function
lookupDescription
(
fullName
)
{
var
parsedName
=
this
.
parseName
(
fullName
)
;
var
moduleName
=
this
.
findModuleName
(
parsedName
true
)
;
return
moduleName
;
}
_logLookup
:
function
_logLookup
(
found
parsedName
description
)
{
if
(
!
_ember
[
'
default
'
]
.
ENV
.
LOG_MODULE_RESOLVER
&
&
!
parsedName
.
root
.
LOG_RESOLVER
)
{
return
;
}
var
symbol
padding
;
if
(
found
)
{
symbol
=
'
[
]
'
;
}
else
{
symbol
=
'
[
]
'
;
}
if
(
parsedName
.
fullName
.
length
>
60
)
{
padding
=
'
.
'
;
}
else
{
padding
=
new
Array
(
60
-
parsedName
.
fullName
.
length
)
.
join
(
'
.
'
)
;
}
if
(
!
description
)
{
description
=
this
.
lookupDescription
(
parsedName
)
;
}
_ember
[
'
default
'
]
.
Logger
.
info
(
symbol
parsedName
.
fullName
padding
description
)
;
}
knownForType
:
function
knownForType
(
type
)
{
var
moduleKeys
=
this
.
_moduleRegistry
.
moduleNames
(
)
;
var
items
=
(
0
_emberResolverUtilsMakeDictionary
[
'
default
'
]
)
(
)
;
for
(
var
index
=
0
length
=
moduleKeys
.
length
;
index
<
length
;
index
+
+
)
{
var
moduleName
=
moduleKeys
[
index
]
;
var
fullname
=
this
.
translateToContainerFullname
(
type
moduleName
)
;
if
(
fullname
)
{
items
[
fullname
]
=
true
;
}
}
return
items
;
}
translateToContainerFullname
:
function
translateToContainerFullname
(
type
moduleName
)
{
var
prefix
=
this
.
prefix
(
{
type
:
type
}
)
;
var
podPrefix
=
prefix
+
'
/
'
;
var
podSuffix
=
'
/
'
+
type
;
var
start
=
moduleName
.
indexOf
(
podPrefix
)
;
var
end
=
moduleName
.
indexOf
(
podSuffix
)
;
if
(
start
=
=
=
0
&
&
end
=
=
=
moduleName
.
length
-
podSuffix
.
length
&
&
moduleName
.
length
>
podPrefix
.
length
+
podSuffix
.
length
)
{
return
type
+
'
:
'
+
moduleName
.
slice
(
start
+
podPrefix
.
length
end
)
;
}
var
pluralizedType
=
this
.
pluralize
(
type
)
;
var
nonPodPrefix
=
prefix
+
'
/
'
+
pluralizedType
+
'
/
'
;
if
(
moduleName
.
indexOf
(
nonPodPrefix
)
=
=
=
0
&
&
moduleName
.
length
>
nonPodPrefix
.
length
)
{
return
type
+
'
:
'
+
moduleName
.
slice
(
nonPodPrefix
.
length
)
;
}
}
_extractDefaultExport
:
function
_extractDefaultExport
(
normalizedModuleName
)
{
var
module
=
require
(
normalizedModuleName
null
null
true
)
;
if
(
module
&
&
module
[
'
default
'
]
)
{
module
=
module
[
'
default
'
]
;
}
return
module
;
}
}
)
;
Resolver
.
reopenClass
(
{
moduleBasedResolver
:
true
}
)
;
exports
[
'
default
'
]
=
Resolver
;
}
)
;
define
(
'
ember
-
resolver
/
utils
/
class
-
factory
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
classFactory
;
function
classFactory
(
klass
)
{
return
{
create
:
function
create
(
injections
)
{
if
(
typeof
klass
.
extend
=
=
=
'
function
'
)
{
return
klass
.
extend
(
injections
)
;
}
else
{
return
klass
;
}
}
}
;
}
}
)
;
define
(
"
ember
-
resolver
/
utils
/
create
"
[
"
exports
"
"
ember
"
]
function
(
exports
_ember
)
{
"
use
strict
"
;
var
create
=
Object
.
create
|
|
_ember
[
"
default
"
]
.
create
;
if
(
!
(
create
&
&
!
create
(
null
)
.
hasOwnProperty
)
)
{
throw
new
Error
(
"
This
browser
does
not
support
Object
.
create
(
null
)
please
polyfil
with
es5
-
sham
:
http
:
/
/
git
.
io
/
yBU2rg
"
)
;
}
exports
[
"
default
"
]
=
create
;
}
)
;
define
(
'
ember
-
resolver
/
utils
/
make
-
dictionary
'
[
'
exports
'
'
ember
-
resolver
/
utils
/
create
'
]
function
(
exports
_emberResolverUtilsCreate
)
{
'
use
strict
'
;
exports
[
'
default
'
]
=
makeDictionary
;
function
makeDictionary
(
)
{
var
cache
=
(
0
_emberResolverUtilsCreate
[
'
default
'
]
)
(
null
)
;
cache
[
'
_dict
'
]
=
null
;
delete
cache
[
'
_dict
'
]
;
return
cache
;
}
}
)
;
define
(
'
ember
-
resolver
/
utils
/
module
-
registry
'
[
'
exports
'
'
ember
'
]
function
(
exports
_ember
)
{
'
use
strict
'
;
if
(
typeof
requirejs
.
entries
=
=
=
'
undefined
'
)
{
requirejs
.
entries
=
requirejs
.
_eak_seen
;
}
function
ModuleRegistry
(
entries
)
{
this
.
_entries
=
entries
|
|
requirejs
.
entries
;
}
ModuleRegistry
.
prototype
.
moduleNames
=
function
ModuleRegistry_moduleNames
(
)
{
return
(
Object
.
keys
|
|
_ember
[
'
default
'
]
.
keys
)
(
this
.
_entries
)
;
}
;
ModuleRegistry
.
prototype
.
has
=
function
ModuleRegistry_has
(
moduleName
)
{
return
moduleName
in
this
.
_entries
;
}
;
ModuleRegistry
.
prototype
.
get
=
function
ModuleRegistry_get
(
moduleName
)
{
var
exportName
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
'
default
'
:
arguments
[
1
]
;
var
module
=
require
(
moduleName
)
;
return
module
&
&
module
[
exportName
]
;
}
;
exports
[
'
default
'
]
=
ModuleRegistry
;
}
)
;
;
