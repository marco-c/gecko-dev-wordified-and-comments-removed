#
ifndef
MSGPACK_V2_UNPACK_DECL_HPP
#
define
MSGPACK_V2_UNPACK_DECL_HPP
#
include
"
msgpack
/
v1
/
unpack_decl
.
hpp
"
namespace
msgpack
{
MSGPACK_API_VERSION_NAMESPACE
(
v2
)
{
using
v1
:
:
unpack_reference_func
;
using
v1
:
:
unpack_error
;
using
v1
:
:
parse_error
;
using
v1
:
:
insufficient_bytes
;
using
v1
:
:
size_overflow
;
using
v1
:
:
array_size_overflow
;
using
v1
:
:
map_size_overflow
;
using
v1
:
:
str_size_overflow
;
using
v1
:
:
bin_size_overflow
;
using
v1
:
:
ext_size_overflow
;
using
v1
:
:
depth_size_overflow
;
using
v1
:
:
unpack_limit
;
namespace
detail
{
using
v1
:
:
detail
:
:
unpack_user
;
using
v1
:
:
detail
:
:
unpack_uint8
;
using
v1
:
:
detail
:
:
unpack_uint16
;
using
v1
:
:
detail
:
:
unpack_uint32
;
using
v1
:
:
detail
:
:
unpack_uint64
;
using
v1
:
:
detail
:
:
unpack_int8
;
using
v1
:
:
detail
:
:
unpack_int16
;
using
v1
:
:
detail
:
:
unpack_int32
;
using
v1
:
:
detail
:
:
unpack_int64
;
using
v1
:
:
detail
:
:
unpack_float
;
using
v1
:
:
detail
:
:
unpack_double
;
using
v1
:
:
detail
:
:
unpack_nil
;
using
v1
:
:
detail
:
:
unpack_true
;
using
v1
:
:
detail
:
:
unpack_false
;
using
v1
:
:
detail
:
:
unpack_array
;
using
v1
:
:
detail
:
:
unpack_array_item
;
using
v1
:
:
detail
:
:
unpack_map
;
using
v1
:
:
detail
:
:
unpack_map_item
;
using
v1
:
:
detail
:
:
unpack_str
;
using
v1
:
:
detail
:
:
unpack_bin
;
using
v1
:
:
detail
:
:
unpack_ext
;
using
v1
:
:
detail
:
:
unpack_stack
;
using
v1
:
:
detail
:
:
init_count
;
using
v1
:
:
detail
:
:
decr_count
;
using
v1
:
:
detail
:
:
incr_count
;
using
v1
:
:
detail
:
:
get_count
;
using
v1
:
:
detail
:
:
fix_tag
;
using
v1
:
:
detail
:
:
value
;
using
v1
:
:
detail
:
:
load
;
}
using
v1
:
:
unpacked
;
class
unpacker
;
template
<
typename
unpack_visitor
typename
referenced_buffer_hook
>
class
basic_unpacker
;
msgpack
:
:
object_handle
unpack
(
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
bool
&
referenced
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object_handle
unpack
(
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object_handle
unpack
(
const
char
*
data
std
:
:
size_t
len
bool
&
referenced
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object_handle
unpack
(
const
char
*
data
std
:
:
size_t
len
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
void
unpack
(
msgpack
:
:
object_handle
&
result
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
bool
&
referenced
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
void
unpack
(
msgpack
:
:
object_handle
&
result
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
void
unpack
(
msgpack
:
:
object_handle
&
result
const
char
*
data
std
:
:
size_t
len
bool
&
referenced
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
void
unpack
(
msgpack
:
:
object_handle
&
result
const
char
*
data
std
:
:
size_t
len
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object
unpack
(
msgpack
:
:
zone
&
z
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
bool
&
referenced
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object
unpack
(
msgpack
:
:
zone
&
z
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object
unpack
(
msgpack
:
:
zone
&
z
const
char
*
data
std
:
:
size_t
len
bool
&
referenced
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
msgpack
:
:
object
unpack
(
msgpack
:
:
zone
&
z
const
char
*
data
std
:
:
size_t
len
unpack_reference_func
f
=
MSGPACK_NULLPTR
void
*
user_data
=
MSGPACK_NULLPTR
unpack_limit
const
&
limit
=
unpack_limit
(
)
)
;
namespace
detail
{
parse_return
unpack_imp
(
const
char
*
data
std
:
:
size_t
len
std
:
:
size_t
&
off
msgpack
:
:
zone
&
result_zone
msgpack
:
:
object
&
result
bool
&
referenced
unpack_reference_func
f
void
*
user_data
unpack_limit
const
&
limit
)
;
}
}
}
#
endif
