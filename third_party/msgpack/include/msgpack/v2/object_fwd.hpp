#
ifndef
MSGPACK_V2_OBJECT_FWD_HPP
#
define
MSGPACK_V2_OBJECT_FWD_HPP
#
include
"
msgpack
/
v2
/
object_fwd_decl
.
hpp
"
#
include
"
msgpack
/
object_fwd
.
hpp
"
namespace
msgpack
{
MSGPACK_API_VERSION_NAMESPACE
(
v2
)
{
struct
object
:
v1
:
:
object
{
object
(
)
{
}
object
(
v1
:
:
object
const
&
o
)
:
v1
:
:
object
(
o
)
{
}
template
<
typename
T
>
explicit
object
(
const
T
&
v
)
{
*
this
<
<
v
;
}
template
<
typename
T
>
object
(
const
T
&
v
msgpack
:
:
zone
&
z
)
:
v1
:
:
object
(
v
z
)
{
}
public
:
template
<
typename
T
>
T
&
convert
(
T
&
v
)
const
{
return
v1
:
:
object
:
:
convert
(
v
)
;
}
using
v1
:
:
object
:
:
with_zone
;
implicit_type
convert
(
)
const
;
}
;
#
if
!
defined
(
MSGPACK_USE_CPP03
)
namespace
adaptor
{
template
<
typename
T
>
struct
as
<
T
typename
std
:
:
enable_if
<
v1
:
:
has_as
<
T
>
:
:
value
>
:
:
type
>
:
v1
:
:
adaptor
:
:
as
<
T
>
{
}
;
}
template
<
typename
T
>
struct
has_as
{
private
:
template
<
typename
U
>
static
auto
check
(
U
*
)
-
>
typename
std
:
:
enable_if
<
std
:
:
is_same
<
decltype
(
adaptor
:
:
as
<
U
>
(
)
(
std
:
:
declval
<
msgpack
:
:
object
>
(
)
)
)
U
>
:
:
value
|
|
v1
:
:
has_as
<
U
>
:
:
value
std
:
:
true_type
>
:
:
type
;
template
<
typename
.
.
.
>
static
std
:
:
false_type
check
(
.
.
.
)
;
public
:
using
type
=
decltype
(
check
<
T
>
(
MSGPACK_NULLPTR
)
)
;
static
constexpr
bool
value
=
type
:
:
value
;
}
;
#
endif
}
}
#
endif
