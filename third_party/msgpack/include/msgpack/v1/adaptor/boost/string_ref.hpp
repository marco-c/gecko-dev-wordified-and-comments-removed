#
ifndef
MSGPACK_V1_TYPE_BOOST_STRING_REF_HPP
#
define
MSGPACK_V1_TYPE_BOOST_STRING_REF_HPP
#
include
<
boost
/
version
.
hpp
>
#
if
(
BOOST_VERSION
/
100000
)
>
=
1
&
&
(
(
BOOST_VERSION
/
100
)
%
1000
)
>
=
53
#
include
"
msgpack
/
versioning
.
hpp
"
#
include
"
msgpack
/
adaptor
/
adaptor_base
.
hpp
"
#
include
"
msgpack
/
adaptor
/
check_container_size
.
hpp
"
#
include
<
boost
/
utility
/
string_ref
.
hpp
>
namespace
msgpack
{
MSGPACK_API_VERSION_NAMESPACE
(
v1
)
{
namespace
adaptor
{
template
<
>
struct
convert
<
boost
:
:
string_ref
>
{
msgpack
:
:
object
const
&
operator
(
)
(
msgpack
:
:
object
const
&
o
boost
:
:
string_ref
&
v
)
const
{
switch
(
o
.
type
)
{
case
msgpack
:
:
type
:
:
BIN
:
v
=
boost
:
:
string_ref
(
o
.
via
.
bin
.
ptr
o
.
via
.
bin
.
size
)
;
break
;
case
msgpack
:
:
type
:
:
STR
:
v
=
boost
:
:
string_ref
(
o
.
via
.
str
.
ptr
o
.
via
.
str
.
size
)
;
break
;
default
:
throw
msgpack
:
:
type_error
(
)
;
break
;
}
return
o
;
}
}
;
template
<
>
struct
pack
<
boost
:
:
string_ref
>
{
template
<
typename
Stream
>
msgpack
:
:
packer
<
Stream
>
&
operator
(
)
(
msgpack
:
:
packer
<
Stream
>
&
o
const
boost
:
:
string_ref
&
v
)
const
{
uint32_t
size
=
checked_get_container_size
(
v
.
size
(
)
)
;
o
.
pack_str
(
size
)
;
o
.
pack_str_body
(
v
.
data
(
)
size
)
;
return
o
;
}
}
;
template
<
>
struct
object
<
boost
:
:
string_ref
>
{
void
operator
(
)
(
msgpack
:
:
object
&
o
const
boost
:
:
string_ref
&
v
)
const
{
uint32_t
size
=
checked_get_container_size
(
v
.
size
(
)
)
;
o
.
type
=
msgpack
:
:
type
:
:
STR
;
o
.
via
.
str
.
ptr
=
v
.
data
(
)
;
o
.
via
.
str
.
size
=
size
;
}
}
;
template
<
>
struct
object_with_zone
<
boost
:
:
string_ref
>
{
void
operator
(
)
(
msgpack
:
:
object
:
:
with_zone
&
o
const
boost
:
:
string_ref
&
v
)
const
{
static_cast
<
msgpack
:
:
object
&
>
(
o
)
<
<
v
;
}
}
;
}
}
}
#
endif
#
endif
