#
ifndef
MSGPACK_V1_OBJECT_FWD_HPP
#
define
MSGPACK_V1_OBJECT_FWD_HPP
#
include
"
msgpack
/
object_fwd_decl
.
hpp
"
namespace
msgpack
{
MSGPACK_API_VERSION_NAMESPACE
(
v1
)
{
struct
object_array
{
uint32_t
size
;
msgpack
:
:
object
*
ptr
;
}
;
struct
object_map
{
uint32_t
size
;
msgpack
:
:
object_kv
*
ptr
;
}
;
struct
object_str
{
uint32_t
size
;
const
char
*
ptr
;
}
;
struct
object_bin
{
uint32_t
size
;
const
char
*
ptr
;
}
;
struct
object_ext
{
int8_t
type
(
)
const
{
return
ptr
[
0
]
;
}
const
char
*
data
(
)
const
{
return
&
ptr
[
1
]
;
}
uint32_t
size
;
const
char
*
ptr
;
}
;
#
if
!
defined
(
MSGPACK_USE_CPP03
)
template
<
typename
T
>
struct
has_as
{
private
:
template
<
typename
U
>
static
auto
check
(
U
*
)
-
>
typename
std
:
:
is_same
<
decltype
(
adaptor
:
:
as
<
U
>
(
)
(
std
:
:
declval
<
msgpack
:
:
object
>
(
)
)
)
T
>
:
:
type
;
template
<
typename
.
.
.
>
static
std
:
:
false_type
check
(
.
.
.
)
;
public
:
using
type
=
decltype
(
check
<
T
>
(
MSGPACK_NULLPTR
)
)
;
static
constexpr
bool
value
=
type
:
:
value
;
}
;
#
endif
struct
object
{
union
union_type
{
bool
boolean
;
uint64_t
u64
;
int64_t
i64
;
#
if
defined
(
MSGPACK_USE_LEGACY_NAME_AS_FLOAT
)
MSGPACK_DEPRECATED
(
"
please
use
f64
instead
"
)
double
dec
;
#
endif
double
f64
;
msgpack
:
:
object_array
array
;
msgpack
:
:
object_map
map
;
msgpack
:
:
object_str
str
;
msgpack
:
:
object_bin
bin
;
msgpack
:
:
object_ext
ext
;
}
;
msgpack
:
:
type
:
:
object_type
type
;
union_type
via
;
bool
is_nil
(
)
const
{
return
type
=
=
msgpack
:
:
type
:
:
NIL
;
}
#
if
defined
(
MSGPACK_USE_CPP03
)
template
<
typename
T
>
T
as
(
)
const
;
#
else
template
<
typename
T
>
typename
std
:
:
enable_if
<
msgpack
:
:
has_as
<
T
>
:
:
value
T
>
:
:
type
as
(
)
const
;
template
<
typename
T
>
typename
std
:
:
enable_if
<
!
msgpack
:
:
has_as
<
T
>
:
:
value
T
>
:
:
type
as
(
)
const
;
#
endif
template
<
typename
T
>
typename
msgpack
:
:
enable_if
<
!
msgpack
:
:
is_array
<
T
>
:
:
value
&
&
!
msgpack
:
:
is_pointer
<
T
>
:
:
value
T
&
>
:
:
type
convert
(
T
&
v
)
const
;
template
<
typename
T
std
:
:
size_t
N
>
T
(
&
convert
(
T
(
&
v
)
[
N
]
)
const
)
[
N
]
;
#
if
!
defined
(
MSGPACK_DISABLE_LEGACY_CONVERT
)
template
<
typename
T
>
MSGPACK_DEPRECATED
(
"
please
use
reference
version
instead
"
)
typename
msgpack
:
:
enable_if
<
msgpack
:
:
is_pointer
<
T
>
:
:
value
T
>
:
:
type
convert
(
T
v
)
const
;
#
endif
template
<
typename
T
>
bool
convert_if_not_nil
(
T
&
v
)
const
;
object
(
)
;
object
(
const
msgpack_object
&
o
)
;
template
<
typename
T
>
explicit
object
(
const
T
&
v
)
;
template
<
typename
T
>
object
(
const
T
&
v
msgpack
:
:
zone
&
z
)
;
template
<
typename
T
>
MSGPACK_DEPRECATED
(
"
please
use
zone
reference
version
instead
of
the
pointer
version
"
)
object
(
const
T
&
v
msgpack
:
:
zone
*
z
)
;
template
<
typename
T
>
object
&
operator
=
(
const
T
&
v
)
;
operator
msgpack_object
(
)
const
;
struct
with_zone
;
protected
:
struct
implicit_type
;
public
:
implicit_type
convert
(
)
const
;
}
;
class
type_error
:
public
std
:
:
bad_cast
{
}
;
struct
object
:
:
implicit_type
{
implicit_type
(
object
const
&
o
)
:
obj
(
o
)
{
}
~
implicit_type
(
)
{
}
template
<
typename
T
>
operator
T
(
)
;
private
:
object
const
&
obj
;
}
;
}
}
#
endif
