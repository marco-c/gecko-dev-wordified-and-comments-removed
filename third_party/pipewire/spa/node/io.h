#
ifndef
SPA_IO_H
#
define
SPA_IO_H
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
include
<
spa
/
utils
/
defs
.
h
>
#
include
<
spa
/
pod
/
pod
.
h
>
enum
spa_io_type
{
SPA_IO_Invalid
SPA_IO_Buffers
SPA_IO_Range
SPA_IO_Clock
SPA_IO_Latency
SPA_IO_Control
SPA_IO_Notify
SPA_IO_Position
SPA_IO_RateMatch
SPA_IO_Memory
}
;
struct
spa_io_buffers
{
#
define
SPA_STATUS_OK
0
#
define
SPA_STATUS_NEED_DATA
(
1
<
<
0
)
#
define
SPA_STATUS_HAVE_DATA
(
1
<
<
1
)
#
define
SPA_STATUS_STOPPED
(
1
<
<
2
)
#
define
SPA_STATUS_DRAINED
(
1
<
<
3
)
int32_t
status
;
uint32_t
buffer_id
;
}
;
#
define
SPA_IO_BUFFERS_INIT
(
struct
spa_io_buffers
)
{
SPA_STATUS_OK
SPA_ID_INVALID
}
struct
spa_io_memory
{
int32_t
status
;
uint32_t
size
;
void
*
data
;
}
;
#
define
SPA_IO_MEMORY_INIT
(
struct
spa_io_memory
)
{
SPA_STATUS_OK
0
NULL
}
struct
spa_io_range
{
uint64_t
offset
;
uint32_t
min_size
;
uint32_t
max_size
;
}
;
struct
spa_io_clock
{
uint32_t
flags
;
uint32_t
id
;
char
name
[
64
]
;
uint64_t
nsec
;
struct
spa_fraction
rate
;
uint64_t
position
;
uint64_t
duration
;
int64_t
delay
;
double
rate_diff
;
uint64_t
next_nsec
;
uint32_t
padding
[
8
]
;
}
;
struct
spa_io_video_size
{
#
define
SPA_IO_VIDEO_SIZE_VALID
(
1
<
<
0
)
uint32_t
flags
;
uint32_t
stride
;
struct
spa_rectangle
size
;
struct
spa_fraction
framerate
;
uint32_t
padding
[
4
]
;
}
;
struct
spa_io_latency
{
struct
spa_fraction
rate
;
uint64_t
min
;
uint64_t
max
;
}
;
struct
spa_io_sequence
{
struct
spa_pod_sequence
sequence
;
}
;
struct
spa_io_segment_bar
{
#
define
SPA_IO_SEGMENT_BAR_FLAG_VALID
(
1
<
<
0
)
uint32_t
flags
;
uint32_t
offset
;
float
signature_num
;
float
signature_denom
;
double
bpm
;
double
beat
;
uint32_t
padding
[
8
]
;
}
;
struct
spa_io_segment_video
{
#
define
SPA_IO_SEGMENT_VIDEO_FLAG_VALID
(
1
<
<
0
)
#
define
SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME
(
1
<
<
1
)
#
define
SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN
(
1
<
<
2
)
#
define
SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED
(
1
<
<
3
)
uint32_t
flags
;
uint32_t
offset
;
struct
spa_fraction
framerate
;
uint32_t
hours
;
uint32_t
minutes
;
uint32_t
seconds
;
uint32_t
frames
;
uint32_t
field_count
;
uint32_t
padding
[
11
]
;
}
;
struct
spa_io_segment
{
uint32_t
version
;
#
define
SPA_IO_SEGMENT_FLAG_LOOPING
(
1
<
<
0
)
/
*
*
<
after
the
duration
the
segment
repeats
*
/
#
define
SPA_IO_SEGMENT_FLAG_NO_POSITION
(
1
<
<
1
)
/
*
*
<
position
is
invalid
.
The
position
can
be
invalid
*
after
a
seek
for
example
when
the
exact
mapping
*
of
the
extra
segment
info
(
bar
video
.
.
.
)
to
*
position
has
not
been
determined
yet
*
/
uint32_t
flags
;
uint64_t
start
;
uint64_t
duration
;
double
rate
;
uint64_t
position
;
struct
spa_io_segment_bar
bar
;
struct
spa_io_segment_video
video
;
}
;
enum
spa_io_position_state
{
SPA_IO_POSITION_STATE_STOPPED
SPA_IO_POSITION_STATE_STARTING
SPA_IO_POSITION_STATE_RUNNING
}
;
#
define
SPA_IO_POSITION_MAX_SEGMENTS
8
struct
spa_io_position
{
struct
spa_io_clock
clock
;
struct
spa_io_video_size
video
;
int64_t
offset
;
uint32_t
state
;
uint32_t
n_segments
;
struct
spa_io_segment
segments
[
SPA_IO_POSITION_MAX_SEGMENTS
]
;
}
;
struct
spa_io_rate_match
{
uint32_t
delay
;
uint32_t
size
;
double
rate
;
#
define
SPA_IO_RATE_MATCH_FLAG_ACTIVE
(
1
<
<
0
)
uint32_t
flags
;
uint32_t
padding
[
7
]
;
}
;
#
ifdef
__cplusplus
}
#
endif
#
endif
