#
if
!
defined
(
SQLITE_CORE
)
|
|
defined
(
SQLITE_ENABLE_FTS5
)
#
if
!
defined
(
NDEBUG
)
&
&
!
defined
(
SQLITE_DEBUG
)
#
define
NDEBUG
1
#
endif
#
if
defined
(
NDEBUG
)
&
&
defined
(
SQLITE_DEBUG
)
#
undef
NDEBUG
#
endif
#
ifdef
HAVE_STDINT_H
#
include
<
stdint
.
h
>
#
endif
#
ifdef
HAVE_INTTYPES_H
#
include
<
inttypes
.
h
>
#
endif
#
line
1
"
fts5
.
h
"
#
ifndef
_FTS5_H
#
define
_FTS5_H
#
include
"
sqlite3
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
typedef
struct
Fts5ExtensionApi
Fts5ExtensionApi
;
typedef
struct
Fts5Context
Fts5Context
;
typedef
struct
Fts5PhraseIter
Fts5PhraseIter
;
typedef
void
(
*
fts5_extension_function
)
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
sqlite3_context
*
pCtx
int
nVal
sqlite3_value
*
*
apVal
)
;
struct
Fts5PhraseIter
{
const
unsigned
char
*
a
;
const
unsigned
char
*
b
;
}
;
struct
Fts5ExtensionApi
{
int
iVersion
;
void
*
(
*
xUserData
)
(
Fts5Context
*
)
;
int
(
*
xColumnCount
)
(
Fts5Context
*
)
;
int
(
*
xRowCount
)
(
Fts5Context
*
sqlite3_int64
*
pnRow
)
;
int
(
*
xColumnTotalSize
)
(
Fts5Context
*
int
iCol
sqlite3_int64
*
pnToken
)
;
int
(
*
xTokenize
)
(
Fts5Context
*
const
char
*
pText
int
nText
void
*
pCtx
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
;
int
(
*
xPhraseCount
)
(
Fts5Context
*
)
;
int
(
*
xPhraseSize
)
(
Fts5Context
*
int
iPhrase
)
;
int
(
*
xInstCount
)
(
Fts5Context
*
int
*
pnInst
)
;
int
(
*
xInst
)
(
Fts5Context
*
int
iIdx
int
*
piPhrase
int
*
piCol
int
*
piOff
)
;
sqlite3_int64
(
*
xRowid
)
(
Fts5Context
*
)
;
int
(
*
xColumnText
)
(
Fts5Context
*
int
iCol
const
char
*
*
pz
int
*
pn
)
;
int
(
*
xColumnSize
)
(
Fts5Context
*
int
iCol
int
*
pnToken
)
;
int
(
*
xQueryPhrase
)
(
Fts5Context
*
int
iPhrase
void
*
pUserData
int
(
*
)
(
const
Fts5ExtensionApi
*
Fts5Context
*
void
*
)
)
;
int
(
*
xSetAuxdata
)
(
Fts5Context
*
void
*
pAux
void
(
*
xDelete
)
(
void
*
)
)
;
void
*
(
*
xGetAuxdata
)
(
Fts5Context
*
int
bClear
)
;
int
(
*
xPhraseFirst
)
(
Fts5Context
*
int
iPhrase
Fts5PhraseIter
*
int
*
int
*
)
;
void
(
*
xPhraseNext
)
(
Fts5Context
*
Fts5PhraseIter
*
int
*
piCol
int
*
piOff
)
;
int
(
*
xPhraseFirstColumn
)
(
Fts5Context
*
int
iPhrase
Fts5PhraseIter
*
int
*
)
;
void
(
*
xPhraseNextColumn
)
(
Fts5Context
*
Fts5PhraseIter
*
int
*
piCol
)
;
int
(
*
xQueryToken
)
(
Fts5Context
*
int
iPhrase
int
iToken
const
char
*
*
ppToken
int
*
pnToken
)
;
int
(
*
xInstToken
)
(
Fts5Context
*
int
iIdx
int
iToken
const
char
*
*
int
*
)
;
int
(
*
xColumnLocale
)
(
Fts5Context
*
int
iCol
const
char
*
*
pz
int
*
pn
)
;
int
(
*
xTokenize_v2
)
(
Fts5Context
*
const
char
*
pText
int
nText
const
char
*
pLocale
int
nLocale
void
*
pCtx
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
;
}
;
typedef
struct
Fts5Tokenizer
Fts5Tokenizer
;
typedef
struct
fts5_tokenizer_v2
fts5_tokenizer_v2
;
struct
fts5_tokenizer_v2
{
int
iVersion
;
int
(
*
xCreate
)
(
void
*
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
;
void
(
*
xDelete
)
(
Fts5Tokenizer
*
)
;
int
(
*
xTokenize
)
(
Fts5Tokenizer
*
void
*
pCtx
int
flags
const
char
*
pText
int
nText
const
char
*
pLocale
int
nLocale
int
(
*
xToken
)
(
void
*
pCtx
int
tflags
const
char
*
pToken
int
nToken
int
iStart
int
iEnd
)
)
;
}
;
typedef
struct
fts5_tokenizer
fts5_tokenizer
;
struct
fts5_tokenizer
{
int
(
*
xCreate
)
(
void
*
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
;
void
(
*
xDelete
)
(
Fts5Tokenizer
*
)
;
int
(
*
xTokenize
)
(
Fts5Tokenizer
*
void
*
pCtx
int
flags
const
char
*
pText
int
nText
int
(
*
xToken
)
(
void
*
pCtx
int
tflags
const
char
*
pToken
int
nToken
int
iStart
int
iEnd
)
)
;
}
;
#
define
FTS5_TOKENIZE_QUERY
0x0001
#
define
FTS5_TOKENIZE_PREFIX
0x0002
#
define
FTS5_TOKENIZE_DOCUMENT
0x0004
#
define
FTS5_TOKENIZE_AUX
0x0008
#
define
FTS5_TOKEN_COLOCATED
0x0001
/
*
Same
position
as
prev
.
token
*
/
typedef
struct
fts5_api
fts5_api
;
struct
fts5_api
{
int
iVersion
;
int
(
*
xCreateTokenizer
)
(
fts5_api
*
pApi
const
char
*
zName
void
*
pUserData
fts5_tokenizer
*
pTokenizer
void
(
*
xDestroy
)
(
void
*
)
)
;
int
(
*
xFindTokenizer
)
(
fts5_api
*
pApi
const
char
*
zName
void
*
*
ppUserData
fts5_tokenizer
*
pTokenizer
)
;
int
(
*
xCreateFunction
)
(
fts5_api
*
pApi
const
char
*
zName
void
*
pUserData
fts5_extension_function
xFunction
void
(
*
xDestroy
)
(
void
*
)
)
;
int
(
*
xCreateTokenizer_v2
)
(
fts5_api
*
pApi
const
char
*
zName
void
*
pUserData
fts5_tokenizer_v2
*
pTokenizer
void
(
*
xDestroy
)
(
void
*
)
)
;
int
(
*
xFindTokenizer_v2
)
(
fts5_api
*
pApi
const
char
*
zName
void
*
*
ppUserData
fts5_tokenizer_v2
*
*
ppTokenizer
)
;
}
;
#
ifdef
__cplusplus
}
#
endif
#
endif
#
line
1
"
fts5Int
.
h
"
#
ifndef
_FTS5INT_H
#
define
_FTS5INT_H
#
include
"
sqlite3ext
.
h
"
SQLITE_EXTENSION_INIT1
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
ifndef
SQLITE_AMALGAMATION
typedef
unsigned
char
u8
;
typedef
unsigned
int
u32
;
typedef
unsigned
short
u16
;
typedef
short
i16
;
typedef
sqlite3_int64
i64
;
typedef
sqlite3_uint64
u64
;
#
ifndef
ArraySize
#
define
ArraySize
(
x
)
(
(
int
)
(
sizeof
(
x
)
/
sizeof
(
x
[
0
]
)
)
)
#
endif
#
define
testcase
(
x
)
#
if
defined
(
SQLITE_COVERAGE_TEST
)
|
|
defined
(
SQLITE_MUTATION_TEST
)
#
define
SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS
1
#
endif
#
if
defined
(
SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS
)
#
define
ALWAYS
(
X
)
(
1
)
#
define
NEVER
(
X
)
(
0
)
#
elif
!
defined
(
NDEBUG
)
#
define
ALWAYS
(
X
)
(
(
X
)
?
1
:
(
assert
(
0
)
0
)
)
#
define
NEVER
(
X
)
(
(
X
)
?
(
assert
(
0
)
1
)
:
0
)
#
else
#
define
ALWAYS
(
X
)
(
X
)
#
define
NEVER
(
X
)
(
X
)
#
endif
#
define
MIN
(
x
y
)
(
(
(
x
)
<
(
y
)
)
?
(
x
)
:
(
y
)
)
#
define
MAX
(
x
y
)
(
(
(
x
)
>
(
y
)
)
?
(
x
)
:
(
y
)
)
#
define
LARGEST_INT64
(
0xffffffff
|
(
(
(
i64
)
0x7fffffff
)
<
<
32
)
)
#
define
SMALLEST_INT64
(
(
(
i64
)
-
1
)
-
LARGEST_INT64
)
#
if
defined
(
HAVE_STDINT_H
)
typedef
uintptr_t
uptr
;
#
elif
SQLITE_PTRSIZE
=
=
4
typedef
u32
uptr
;
#
else
typedef
u64
uptr
;
#
endif
#
ifdef
SQLITE_4_BYTE_ALIGNED_MALLOC
#
define
EIGHT_BYTE_ALIGNMENT
(
X
)
(
(
(
(
uptr
)
(
X
)
-
(
uptr
)
0
)
&
3
)
=
=
0
)
#
else
#
define
EIGHT_BYTE_ALIGNMENT
(
X
)
(
(
(
(
uptr
)
(
X
)
-
(
uptr
)
0
)
&
7
)
=
=
0
)
#
endif
#
endif
#
define
FTS5_MAX_TOKEN_SIZE
32768
#
define
FTS5_MAX_PREFIX_INDEXES
31
#
define
FTS5_MAX_SEGMENT
2000
#
define
FTS5_DEFAULT_NEARDIST
10
#
define
FTS5_DEFAULT_RANK
"
bm25
"
#
define
FTS5_RANK_NAME
"
rank
"
#
define
FTS5_ROWID_NAME
"
rowid
"
#
ifdef
SQLITE_DEBUG
#
define
FTS5_CORRUPT
sqlite3Fts5Corrupt
(
)
static
int
sqlite3Fts5Corrupt
(
void
)
;
#
else
#
define
FTS5_CORRUPT
SQLITE_CORRUPT_VTAB
#
endif
#
ifdef
SQLITE_DEBUG
extern
int
sqlite3_fts5_may_be_corrupt
;
#
define
assert_nc
(
x
)
assert
(
sqlite3_fts5_may_be_corrupt
|
|
(
x
)
)
#
else
#
define
assert_nc
(
x
)
assert
(
x
)
#
endif
#
define
fts5Memcmp
(
s1
s2
n
)
(
(
n
)
<
=
0
?
0
:
memcmp
(
(
s1
)
(
s2
)
(
n
)
)
)
#
ifndef
UNUSED_PARAM
#
define
UNUSED_PARAM
(
X
)
(
void
)
(
X
)
#
endif
#
ifndef
UNUSED_PARAM2
#
define
UNUSED_PARAM2
(
X
Y
)
(
void
)
(
X
)
(
void
)
(
Y
)
#
endif
typedef
struct
Fts5Global
Fts5Global
;
typedef
struct
Fts5Colset
Fts5Colset
;
struct
Fts5Colset
{
int
nCol
;
int
aiCol
[
1
]
;
}
;
typedef
struct
Fts5Config
Fts5Config
;
typedef
struct
Fts5TokenizerConfig
Fts5TokenizerConfig
;
struct
Fts5TokenizerConfig
{
Fts5Tokenizer
*
pTok
;
fts5_tokenizer_v2
*
pApi2
;
fts5_tokenizer
*
pApi1
;
const
char
*
*
azArg
;
int
nArg
;
int
ePattern
;
const
char
*
pLocale
;
int
nLocale
;
}
;
struct
Fts5Config
{
sqlite3
*
db
;
Fts5Global
*
pGlobal
;
char
*
zDb
;
char
*
zName
;
int
nCol
;
char
*
*
azCol
;
u8
*
abUnindexed
;
int
nPrefix
;
int
*
aPrefix
;
int
eContent
;
int
bContentlessDelete
;
int
bContentlessUnindexed
;
char
*
zContent
;
char
*
zContentRowid
;
int
bColumnsize
;
int
bTokendata
;
int
bLocale
;
int
eDetail
;
char
*
zContentExprlist
;
Fts5TokenizerConfig
t
;
int
bLock
;
int
iVersion
;
int
iCookie
;
int
pgsz
;
int
nAutomerge
;
int
nCrisisMerge
;
int
nUsermerge
;
int
nHashSize
;
char
*
zRank
;
char
*
zRankArgs
;
int
bSecureDelete
;
int
nDeleteMerge
;
int
bPrefixInsttoken
;
char
*
*
pzErrmsg
;
#
ifdef
SQLITE_DEBUG
int
bPrefixIndex
;
#
endif
}
;
#
define
FTS5_CURRENT_VERSION
4
#
define
FTS5_CURRENT_VERSION_SECUREDELETE
5
#
define
FTS5_CONTENT_NORMAL
0
#
define
FTS5_CONTENT_NONE
1
#
define
FTS5_CONTENT_EXTERNAL
2
#
define
FTS5_CONTENT_UNINDEXED
3
#
define
FTS5_DETAIL_FULL
0
#
define
FTS5_DETAIL_NONE
1
#
define
FTS5_DETAIL_COLUMNS
2
#
define
FTS5_PATTERN_NONE
0
#
define
FTS5_PATTERN_LIKE
65
/
*
matches
SQLITE_INDEX_CONSTRAINT_LIKE
*
/
#
define
FTS5_PATTERN_GLOB
66
/
*
matches
SQLITE_INDEX_CONSTRAINT_GLOB
*
/
static
int
sqlite3Fts5ConfigParse
(
Fts5Global
*
sqlite3
*
int
const
char
*
*
Fts5Config
*
*
char
*
*
)
;
static
void
sqlite3Fts5ConfigFree
(
Fts5Config
*
)
;
static
int
sqlite3Fts5ConfigDeclareVtab
(
Fts5Config
*
pConfig
)
;
static
int
sqlite3Fts5Tokenize
(
Fts5Config
*
pConfig
int
flags
const
char
*
pText
int
nText
void
*
pCtx
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
;
static
void
sqlite3Fts5Dequote
(
char
*
z
)
;
static
int
sqlite3Fts5ConfigLoad
(
Fts5Config
*
int
)
;
static
int
sqlite3Fts5ConfigSetValue
(
Fts5Config
*
const
char
*
sqlite3_value
*
int
*
)
;
static
int
sqlite3Fts5ConfigParseRank
(
const
char
*
char
*
*
char
*
*
)
;
static
void
sqlite3Fts5ConfigErrmsg
(
Fts5Config
*
pConfig
const
char
*
zFmt
.
.
.
)
;
typedef
struct
Fts5Buffer
Fts5Buffer
;
struct
Fts5Buffer
{
u8
*
p
;
int
n
;
int
nSpace
;
}
;
static
int
sqlite3Fts5BufferSize
(
int
*
Fts5Buffer
*
u32
)
;
static
void
sqlite3Fts5BufferAppendVarint
(
int
*
Fts5Buffer
*
i64
)
;
static
void
sqlite3Fts5BufferAppendBlob
(
int
*
Fts5Buffer
*
u32
const
u8
*
)
;
static
void
sqlite3Fts5BufferAppendString
(
int
*
Fts5Buffer
*
const
char
*
)
;
static
void
sqlite3Fts5BufferFree
(
Fts5Buffer
*
)
;
static
void
sqlite3Fts5BufferZero
(
Fts5Buffer
*
)
;
static
void
sqlite3Fts5BufferSet
(
int
*
Fts5Buffer
*
int
const
u8
*
)
;
static
void
sqlite3Fts5BufferAppendPrintf
(
int
*
Fts5Buffer
*
char
*
zFmt
.
.
.
)
;
static
char
*
sqlite3Fts5Mprintf
(
int
*
pRc
const
char
*
zFmt
.
.
.
)
;
#
define
fts5BufferZero
(
x
)
sqlite3Fts5BufferZero
(
x
)
#
define
fts5BufferAppendVarint
(
a
b
c
)
sqlite3Fts5BufferAppendVarint
(
a
b
(
i64
)
c
)
#
define
fts5BufferFree
(
a
)
sqlite3Fts5BufferFree
(
a
)
#
define
fts5BufferAppendBlob
(
a
b
c
d
)
sqlite3Fts5BufferAppendBlob
(
a
b
c
d
)
#
define
fts5BufferSet
(
a
b
c
d
)
sqlite3Fts5BufferSet
(
a
b
c
d
)
#
define
fts5BufferGrow
(
pRc
pBuf
nn
)
(
\
(
u32
)
(
(
pBuf
)
-
>
n
)
+
(
u32
)
(
nn
)
<
=
(
u32
)
(
(
pBuf
)
-
>
nSpace
)
?
0
:
\
sqlite3Fts5BufferSize
(
(
pRc
)
(
pBuf
)
(
nn
)
+
(
pBuf
)
-
>
n
)
\
)
static
void
sqlite3Fts5Put32
(
u8
*
int
)
;
static
int
sqlite3Fts5Get32
(
const
u8
*
)
;
#
define
FTS5_POS2COLUMN
(
iPos
)
(
int
)
(
(
iPos
>
>
32
)
&
0x7FFFFFFF
)
#
define
FTS5_POS2OFFSET
(
iPos
)
(
int
)
(
iPos
&
0x7FFFFFFF
)
typedef
struct
Fts5PoslistReader
Fts5PoslistReader
;
struct
Fts5PoslistReader
{
const
u8
*
a
;
int
n
;
int
i
;
u8
bFlag
;
u8
bEof
;
i64
iPos
;
}
;
static
int
sqlite3Fts5PoslistReaderInit
(
const
u8
*
a
int
n
Fts5PoslistReader
*
pIter
)
;
static
int
sqlite3Fts5PoslistReaderNext
(
Fts5PoslistReader
*
)
;
typedef
struct
Fts5PoslistWriter
Fts5PoslistWriter
;
struct
Fts5PoslistWriter
{
i64
iPrev
;
}
;
static
int
sqlite3Fts5PoslistWriterAppend
(
Fts5Buffer
*
Fts5PoslistWriter
*
i64
)
;
static
void
sqlite3Fts5PoslistSafeAppend
(
Fts5Buffer
*
i64
*
i64
)
;
static
int
sqlite3Fts5PoslistNext64
(
const
u8
*
a
int
n
int
*
pi
i64
*
piOff
)
;
static
void
*
sqlite3Fts5MallocZero
(
int
*
pRc
sqlite3_int64
nByte
)
;
static
char
*
sqlite3Fts5Strndup
(
int
*
pRc
const
char
*
pIn
int
nIn
)
;
static
int
sqlite3Fts5IsBareword
(
char
t
)
;
typedef
struct
Fts5Termset
Fts5Termset
;
static
int
sqlite3Fts5TermsetNew
(
Fts5Termset
*
*
)
;
static
int
sqlite3Fts5TermsetAdd
(
Fts5Termset
*
int
const
char
*
int
int
*
pbPresent
)
;
static
void
sqlite3Fts5TermsetFree
(
Fts5Termset
*
)
;
typedef
struct
Fts5Index
Fts5Index
;
typedef
struct
Fts5IndexIter
Fts5IndexIter
;
struct
Fts5IndexIter
{
i64
iRowid
;
const
u8
*
pData
;
int
nData
;
u8
bEof
;
}
;
#
define
sqlite3Fts5IterEof
(
x
)
(
(
x
)
-
>
bEof
)
#
define
FTS5INDEX_QUERY_PREFIX
0x0001
/
*
Prefix
query
*
/
#
define
FTS5INDEX_QUERY_DESC
0x0002
/
*
Docs
in
descending
rowid
order
*
/
#
define
FTS5INDEX_QUERY_TEST_NOIDX
0x0004
/
*
Do
not
use
prefix
index
*
/
#
define
FTS5INDEX_QUERY_SCAN
0x0008
/
*
Scan
query
(
fts5vocab
)
*
/
#
define
FTS5INDEX_QUERY_SKIPEMPTY
0x0010
#
define
FTS5INDEX_QUERY_NOOUTPUT
0x0020
#
define
FTS5INDEX_QUERY_SKIPHASH
0x0040
#
define
FTS5INDEX_QUERY_NOTOKENDATA
0x0080
#
define
FTS5INDEX_QUERY_SCANONETERM
0x0100
static
int
sqlite3Fts5IndexOpen
(
Fts5Config
*
pConfig
int
bCreate
Fts5Index
*
*
char
*
*
)
;
static
int
sqlite3Fts5IndexClose
(
Fts5Index
*
p
)
;
static
u64
sqlite3Fts5IndexEntryCksum
(
i64
iRowid
int
iCol
int
iPos
int
iIdx
const
char
*
pTerm
int
nTerm
)
;
static
int
sqlite3Fts5IndexCharlenToBytelen
(
const
char
*
p
int
nByte
int
nChar
)
;
static
int
sqlite3Fts5IndexQuery
(
Fts5Index
*
p
const
char
*
pToken
int
nToken
int
flags
Fts5Colset
*
pColset
Fts5IndexIter
*
*
ppIter
)
;
static
int
sqlite3Fts5IterNext
(
Fts5IndexIter
*
)
;
static
int
sqlite3Fts5IterNextFrom
(
Fts5IndexIter
*
i64
iMatch
)
;
static
void
sqlite3Fts5IterClose
(
Fts5IndexIter
*
)
;
static
void
sqlite3Fts5IndexCloseReader
(
Fts5Index
*
)
;
static
const
char
*
sqlite3Fts5IterTerm
(
Fts5IndexIter
*
int
*
)
;
static
int
sqlite3Fts5IterNextScan
(
Fts5IndexIter
*
)
;
static
void
*
sqlite3Fts5StructureRef
(
Fts5Index
*
)
;
static
void
sqlite3Fts5StructureRelease
(
void
*
)
;
static
int
sqlite3Fts5StructureTest
(
Fts5Index
*
void
*
)
;
static
int
sqlite3Fts5IterToken
(
Fts5IndexIter
*
pIndexIter
const
char
*
pToken
int
nToken
i64
iRowid
int
iCol
int
iOff
const
char
*
*
ppOut
int
*
pnOut
)
;
static
int
sqlite3Fts5IndexWrite
(
Fts5Index
*
p
int
iCol
int
iPos
const
char
*
pToken
int
nToken
)
;
static
int
sqlite3Fts5IndexBeginWrite
(
Fts5Index
*
p
int
bDelete
i64
iDocid
)
;
static
int
sqlite3Fts5IndexSync
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexRollback
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexGetAverages
(
Fts5Index
*
p
i64
*
pnRow
i64
*
anSize
)
;
static
int
sqlite3Fts5IndexSetAverages
(
Fts5Index
*
p
const
u8
*
int
)
;
static
int
sqlite3Fts5IndexIntegrityCheck
(
Fts5Index
*
u64
cksum
int
bUseCksum
)
;
static
int
sqlite3Fts5IndexInit
(
sqlite3
*
)
;
static
int
sqlite3Fts5IndexSetCookie
(
Fts5Index
*
int
)
;
static
int
sqlite3Fts5IndexReads
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexReinit
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexOptimize
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexMerge
(
Fts5Index
*
p
int
nMerge
)
;
static
int
sqlite3Fts5IndexReset
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexLoadConfig
(
Fts5Index
*
p
)
;
static
int
sqlite3Fts5IndexGetOrigin
(
Fts5Index
*
p
i64
*
piOrigin
)
;
static
int
sqlite3Fts5IndexContentlessDelete
(
Fts5Index
*
p
i64
iOrigin
i64
iRowid
)
;
static
void
sqlite3Fts5IndexIterClearTokendata
(
Fts5IndexIter
*
)
;
static
int
sqlite3Fts5IndexIterWriteTokendata
(
Fts5IndexIter
*
const
char
*
int
i64
iRowid
int
iCol
int
iOff
)
;
static
int
sqlite3Fts5GetVarint32
(
const
unsigned
char
*
p
u32
*
v
)
;
static
int
sqlite3Fts5GetVarintLen
(
u32
iVal
)
;
static
u8
sqlite3Fts5GetVarint
(
const
unsigned
char
*
u64
*
)
;
static
int
sqlite3Fts5PutVarint
(
unsigned
char
*
p
u64
v
)
;
#
define
fts5GetVarint32
(
a
b
)
sqlite3Fts5GetVarint32
(
a
(
u32
*
)
&
(
b
)
)
#
define
fts5GetVarint
sqlite3Fts5GetVarint
#
define
fts5FastGetVarint32
(
a
iOff
nVal
)
{
\
nVal
=
(
a
)
[
iOff
+
+
]
;
\
if
(
nVal
&
0x80
)
{
\
iOff
-
-
;
\
iOff
+
=
fts5GetVarint32
(
&
(
a
)
[
iOff
]
nVal
)
;
\
}
\
}
typedef
struct
Fts5Table
Fts5Table
;
struct
Fts5Table
{
sqlite3_vtab
base
;
Fts5Config
*
pConfig
;
Fts5Index
*
pIndex
;
}
;
static
int
sqlite3Fts5LoadTokenizer
(
Fts5Config
*
pConfig
)
;
static
Fts5Table
*
sqlite3Fts5TableFromCsrid
(
Fts5Global
*
i64
)
;
static
int
sqlite3Fts5FlushToDisk
(
Fts5Table
*
)
;
static
void
sqlite3Fts5ClearLocale
(
Fts5Config
*
pConfig
)
;
static
void
sqlite3Fts5SetLocale
(
Fts5Config
*
pConfig
const
char
*
pLoc
int
nLoc
)
;
static
int
sqlite3Fts5IsLocaleValue
(
Fts5Config
*
pConfig
sqlite3_value
*
pVal
)
;
static
int
sqlite3Fts5DecodeLocaleValue
(
sqlite3_value
*
pVal
const
char
*
*
ppText
int
*
pnText
const
char
*
*
ppLoc
int
*
pnLoc
)
;
typedef
struct
Fts5Hash
Fts5Hash
;
static
int
sqlite3Fts5HashNew
(
Fts5Config
*
Fts5Hash
*
*
int
*
pnSize
)
;
static
void
sqlite3Fts5HashFree
(
Fts5Hash
*
)
;
static
int
sqlite3Fts5HashWrite
(
Fts5Hash
*
i64
iRowid
int
iCol
int
iPos
char
bByte
const
char
*
pToken
int
nToken
)
;
static
void
sqlite3Fts5HashClear
(
Fts5Hash
*
)
;
static
int
sqlite3Fts5HashIsEmpty
(
Fts5Hash
*
)
;
static
int
sqlite3Fts5HashQuery
(
Fts5Hash
*
int
nPre
const
char
*
pTerm
int
nTerm
void
*
*
ppObj
int
*
pnDoclist
)
;
static
int
sqlite3Fts5HashScanInit
(
Fts5Hash
*
const
char
*
pTerm
int
nTerm
)
;
static
void
sqlite3Fts5HashScanNext
(
Fts5Hash
*
)
;
static
int
sqlite3Fts5HashScanEof
(
Fts5Hash
*
)
;
static
void
sqlite3Fts5HashScanEntry
(
Fts5Hash
*
const
char
*
*
pzTerm
int
*
pnTerm
const
u8
*
*
ppDoclist
int
*
pnDoclist
)
;
#
define
FTS5_STMT_SCAN_ASC
0
/
*
SELECT
rowid
*
FROM
.
.
.
ORDER
BY
1
ASC
*
/
#
define
FTS5_STMT_SCAN_DESC
1
/
*
SELECT
rowid
*
FROM
.
.
.
ORDER
BY
1
DESC
*
/
#
define
FTS5_STMT_LOOKUP
2
/
*
SELECT
rowid
*
FROM
.
.
.
WHERE
rowid
=
?
*
/
typedef
struct
Fts5Storage
Fts5Storage
;
static
int
sqlite3Fts5StorageOpen
(
Fts5Config
*
Fts5Index
*
int
Fts5Storage
*
*
char
*
*
)
;
static
int
sqlite3Fts5StorageClose
(
Fts5Storage
*
p
)
;
static
int
sqlite3Fts5StorageRename
(
Fts5Storage
*
const
char
*
zName
)
;
static
int
sqlite3Fts5DropAll
(
Fts5Config
*
)
;
static
int
sqlite3Fts5CreateTable
(
Fts5Config
*
const
char
*
const
char
*
int
char
*
*
)
;
static
int
sqlite3Fts5StorageDelete
(
Fts5Storage
*
p
i64
sqlite3_value
*
*
int
)
;
static
int
sqlite3Fts5StorageContentInsert
(
Fts5Storage
*
p
int
sqlite3_value
*
*
i64
*
)
;
static
int
sqlite3Fts5StorageIndexInsert
(
Fts5Storage
*
p
sqlite3_value
*
*
i64
)
;
static
int
sqlite3Fts5StorageIntegrity
(
Fts5Storage
*
p
int
iArg
)
;
static
int
sqlite3Fts5StorageStmt
(
Fts5Storage
*
p
int
eStmt
sqlite3_stmt
*
*
char
*
*
)
;
static
void
sqlite3Fts5StorageStmtRelease
(
Fts5Storage
*
p
int
eStmt
sqlite3_stmt
*
)
;
static
int
sqlite3Fts5StorageDocsize
(
Fts5Storage
*
p
i64
iRowid
int
*
aCol
)
;
static
int
sqlite3Fts5StorageSize
(
Fts5Storage
*
p
int
iCol
i64
*
pnAvg
)
;
static
int
sqlite3Fts5StorageRowCount
(
Fts5Storage
*
p
i64
*
pnRow
)
;
static
int
sqlite3Fts5StorageSync
(
Fts5Storage
*
p
)
;
static
int
sqlite3Fts5StorageRollback
(
Fts5Storage
*
p
)
;
static
int
sqlite3Fts5StorageConfigValue
(
Fts5Storage
*
p
const
char
*
sqlite3_value
*
int
)
;
static
int
sqlite3Fts5StorageDeleteAll
(
Fts5Storage
*
p
)
;
static
int
sqlite3Fts5StorageRebuild
(
Fts5Storage
*
p
)
;
static
int
sqlite3Fts5StorageOptimize
(
Fts5Storage
*
p
)
;
static
int
sqlite3Fts5StorageMerge
(
Fts5Storage
*
p
int
nMerge
)
;
static
int
sqlite3Fts5StorageReset
(
Fts5Storage
*
p
)
;
static
void
sqlite3Fts5StorageReleaseDeleteRow
(
Fts5Storage
*
)
;
static
int
sqlite3Fts5StorageFindDeleteRow
(
Fts5Storage
*
p
i64
iDel
)
;
typedef
struct
Fts5Expr
Fts5Expr
;
typedef
struct
Fts5ExprNode
Fts5ExprNode
;
typedef
struct
Fts5Parse
Fts5Parse
;
typedef
struct
Fts5Token
Fts5Token
;
typedef
struct
Fts5ExprPhrase
Fts5ExprPhrase
;
typedef
struct
Fts5ExprNearset
Fts5ExprNearset
;
struct
Fts5Token
{
const
char
*
p
;
int
n
;
}
;
static
int
sqlite3Fts5ExprNew
(
Fts5Config
*
pConfig
int
bPhraseToAnd
int
iCol
const
char
*
zExpr
Fts5Expr
*
*
ppNew
char
*
*
pzErr
)
;
static
int
sqlite3Fts5ExprPattern
(
Fts5Config
*
pConfig
int
bGlob
int
iCol
const
char
*
zText
Fts5Expr
*
*
pp
)
;
static
int
sqlite3Fts5ExprFirst
(
Fts5Expr
*
Fts5Index
*
pIdx
i64
iMin
int
bDesc
)
;
static
int
sqlite3Fts5ExprNext
(
Fts5Expr
*
i64
iMax
)
;
static
int
sqlite3Fts5ExprEof
(
Fts5Expr
*
)
;
static
i64
sqlite3Fts5ExprRowid
(
Fts5Expr
*
)
;
static
void
sqlite3Fts5ExprFree
(
Fts5Expr
*
)
;
static
int
sqlite3Fts5ExprAnd
(
Fts5Expr
*
*
pp1
Fts5Expr
*
p2
)
;
static
int
sqlite3Fts5ExprInit
(
Fts5Global
*
sqlite3
*
)
;
static
int
sqlite3Fts5ExprPhraseCount
(
Fts5Expr
*
)
;
static
int
sqlite3Fts5ExprPhraseSize
(
Fts5Expr
*
int
iPhrase
)
;
static
int
sqlite3Fts5ExprPoslist
(
Fts5Expr
*
int
const
u8
*
*
)
;
typedef
struct
Fts5PoslistPopulator
Fts5PoslistPopulator
;
static
Fts5PoslistPopulator
*
sqlite3Fts5ExprClearPoslists
(
Fts5Expr
*
int
)
;
static
int
sqlite3Fts5ExprPopulatePoslists
(
Fts5Config
*
Fts5Expr
*
Fts5PoslistPopulator
*
int
const
char
*
int
)
;
static
void
sqlite3Fts5ExprCheckPoslists
(
Fts5Expr
*
i64
)
;
static
int
sqlite3Fts5ExprClonePhrase
(
Fts5Expr
*
int
Fts5Expr
*
*
)
;
static
int
sqlite3Fts5ExprPhraseCollist
(
Fts5Expr
*
int
const
u8
*
*
int
*
)
;
static
int
sqlite3Fts5ExprQueryToken
(
Fts5Expr
*
int
int
const
char
*
*
int
*
)
;
static
int
sqlite3Fts5ExprInstToken
(
Fts5Expr
*
i64
int
int
int
int
const
char
*
*
int
*
)
;
static
void
sqlite3Fts5ExprClearTokens
(
Fts5Expr
*
)
;
static
void
sqlite3Fts5ParseError
(
Fts5Parse
*
pParse
const
char
*
zFmt
.
.
.
)
;
static
Fts5ExprNode
*
sqlite3Fts5ParseNode
(
Fts5Parse
*
pParse
int
eType
Fts5ExprNode
*
pLeft
Fts5ExprNode
*
pRight
Fts5ExprNearset
*
pNear
)
;
static
Fts5ExprNode
*
sqlite3Fts5ParseImplicitAnd
(
Fts5Parse
*
pParse
Fts5ExprNode
*
pLeft
Fts5ExprNode
*
pRight
)
;
static
Fts5ExprPhrase
*
sqlite3Fts5ParseTerm
(
Fts5Parse
*
pParse
Fts5ExprPhrase
*
pPhrase
Fts5Token
*
pToken
int
bPrefix
)
;
static
void
sqlite3Fts5ParseSetCaret
(
Fts5ExprPhrase
*
)
;
static
Fts5ExprNearset
*
sqlite3Fts5ParseNearset
(
Fts5Parse
*
Fts5ExprNearset
*
Fts5ExprPhrase
*
)
;
static
Fts5Colset
*
sqlite3Fts5ParseColset
(
Fts5Parse
*
Fts5Colset
*
Fts5Token
*
)
;
static
void
sqlite3Fts5ParsePhraseFree
(
Fts5ExprPhrase
*
)
;
static
void
sqlite3Fts5ParseNearsetFree
(
Fts5ExprNearset
*
)
;
static
void
sqlite3Fts5ParseNodeFree
(
Fts5ExprNode
*
)
;
static
void
sqlite3Fts5ParseSetDistance
(
Fts5Parse
*
Fts5ExprNearset
*
Fts5Token
*
)
;
static
void
sqlite3Fts5ParseSetColset
(
Fts5Parse
*
Fts5ExprNode
*
Fts5Colset
*
)
;
static
Fts5Colset
*
sqlite3Fts5ParseColsetInvert
(
Fts5Parse
*
Fts5Colset
*
)
;
static
void
sqlite3Fts5ParseFinished
(
Fts5Parse
*
pParse
Fts5ExprNode
*
p
)
;
static
void
sqlite3Fts5ParseNear
(
Fts5Parse
*
pParse
Fts5Token
*
)
;
static
int
sqlite3Fts5AuxInit
(
fts5_api
*
)
;
static
int
sqlite3Fts5TokenizerInit
(
fts5_api
*
)
;
static
int
sqlite3Fts5TokenizerPattern
(
int
(
*
xCreate
)
(
void
*
const
char
*
*
int
Fts5Tokenizer
*
*
)
Fts5Tokenizer
*
pTok
)
;
static
int
sqlite3Fts5TokenizerPreload
(
Fts5TokenizerConfig
*
)
;
static
int
sqlite3Fts5VocabInit
(
Fts5Global
*
sqlite3
*
)
;
static
int
sqlite3Fts5UnicodeIsdiacritic
(
int
c
)
;
static
int
sqlite3Fts5UnicodeFold
(
int
c
int
bRemoveDiacritic
)
;
static
int
sqlite3Fts5UnicodeCatParse
(
const
char
*
u8
*
)
;
static
int
sqlite3Fts5UnicodeCategory
(
u32
iCode
)
;
static
void
sqlite3Fts5UnicodeAscii
(
u8
*
u8
*
)
;
#
endif
#
line
1
"
fts5parse
.
h
"
#
define
FTS5_OR
1
#
define
FTS5_AND
2
#
define
FTS5_NOT
3
#
define
FTS5_TERM
4
#
define
FTS5_COLON
5
#
define
FTS5_MINUS
6
#
define
FTS5_LCP
7
#
define
FTS5_RCP
8
#
define
FTS5_STRING
9
#
define
FTS5_LP
10
#
define
FTS5_RP
11
#
define
FTS5_CARET
12
#
define
FTS5_COMMA
13
#
define
FTS5_PLUS
14
#
define
FTS5_STAR
15
#
line
1
"
fts5parse
.
c
"
#
line
47
"
fts5parse
.
y
"
#
define
fts5YYNOERRORRECOVERY
1
#
define
fts5yytestcase
(
X
)
testcase
(
X
)
#
define
fts5YYPARSEFREENOTNULL
1
#
define
fts5YYMALLOCARGTYPE
u64
#
line
58
"
fts5parse
.
sql
"
#
ifndef
FTS5_OR
#
define
FTS5_OR
1
#
define
FTS5_AND
2
#
define
FTS5_NOT
3
#
define
FTS5_TERM
4
#
define
FTS5_COLON
5
#
define
FTS5_MINUS
6
#
define
FTS5_LCP
7
#
define
FTS5_RCP
8
#
define
FTS5_STRING
9
#
define
FTS5_LP
10
#
define
FTS5_RP
11
#
define
FTS5_CARET
12
#
define
FTS5_COMMA
13
#
define
FTS5_PLUS
14
#
define
FTS5_STAR
15
#
endif
#
ifndef
INTERFACE
#
define
INTERFACE
1
#
endif
#
define
fts5YYCODETYPE
unsigned
char
#
define
fts5YYNOCODE
27
#
define
fts5YYACTIONTYPE
unsigned
char
#
define
sqlite3Fts5ParserFTS5TOKENTYPE
Fts5Token
typedef
union
{
int
fts5yyinit
;
sqlite3Fts5ParserFTS5TOKENTYPE
fts5yy0
;
int
fts5yy4
;
Fts5Colset
*
fts5yy11
;
Fts5ExprNode
*
fts5yy24
;
Fts5ExprNearset
*
fts5yy46
;
Fts5ExprPhrase
*
fts5yy53
;
}
fts5YYMINORTYPE
;
#
ifndef
fts5YYSTACKDEPTH
#
define
fts5YYSTACKDEPTH
100
#
endif
#
define
sqlite3Fts5ParserARG_SDECL
Fts5Parse
*
pParse
;
#
define
sqlite3Fts5ParserARG_PDECL
Fts5Parse
*
pParse
#
define
sqlite3Fts5ParserARG_PARAM
pParse
#
define
sqlite3Fts5ParserARG_FETCH
Fts5Parse
*
pParse
=
fts5yypParser
-
>
pParse
;
#
define
sqlite3Fts5ParserARG_STORE
fts5yypParser
-
>
pParse
=
pParse
;
#
define
fts5YYREALLOC
realloc
#
define
fts5YYFREE
free
#
define
fts5YYDYNSTACK
0
#
define
sqlite3Fts5ParserCTX_SDECL
#
define
sqlite3Fts5ParserCTX_PDECL
#
define
sqlite3Fts5ParserCTX_PARAM
#
define
sqlite3Fts5ParserCTX_FETCH
#
define
sqlite3Fts5ParserCTX_STORE
#
define
fts5YYNSTATE
35
#
define
fts5YYNRULE
28
#
define
fts5YYNRULE_WITH_ACTION
28
#
define
fts5YYNFTS5TOKEN
16
#
define
fts5YY_MAX_SHIFT
34
#
define
fts5YY_MIN_SHIFTREDUCE
52
#
define
fts5YY_MAX_SHIFTREDUCE
79
#
define
fts5YY_ERROR_ACTION
80
#
define
fts5YY_ACCEPT_ACTION
81
#
define
fts5YY_NO_ACTION
82
#
define
fts5YY_MIN_REDUCE
83
#
define
fts5YY_MAX_REDUCE
110
#
define
fts5YY_MIN_DSTRCTR
16
#
define
fts5YY_MAX_DSTRCTR
24
#
define
fts5YY_NLOOKAHEAD
(
(
int
)
(
sizeof
(
fts5yy_lookahead
)
/
sizeof
(
fts5yy_lookahead
[
0
]
)
)
)
#
ifndef
fts5yytestcase
#
define
fts5yytestcase
(
X
)
#
endif
#
if
fts5YYSTACKDEPTH
<
=
0
|
|
fts5YYDYNSTACK
#
define
fts5YYGROWABLESTACK
1
#
else
#
define
fts5YYGROWABLESTACK
0
#
endif
#
if
fts5YYSTACKDEPTH
<
=
0
#
undef
fts5YYSTACKDEPTH
#
define
fts5YYSTACKDEPTH
2
/
*
Need
a
minimum
stack
size
*
/
#
endif
#
define
fts5YY_ACTTAB_COUNT
(
105
)
static
const
fts5YYACTIONTYPE
fts5yy_action
[
]
=
{
81
20
96
6
28
99
98
26
26
18
96
6
28
17
98
56
26
19
96
6
28
14
98
14
26
31
92
96
6
28
108
98
25
26
21
96
6
28
78
98
58
26
29
96
6
28
107
98
22
26
24
16
12
11
1
13
13
24
16
23
11
33
34
13
97
8
27
32
98
7
26
3
4
5
3
4
5
3
83
4
5
3
63
5
3
62
12
2
86
13
9
30
10
10
54
57
75
78
78
53
57
15
82
82
71
}
;
static
const
fts5YYCODETYPE
fts5yy_lookahead
[
]
=
{
16
17
18
19
20
22
22
24
24
17
18
19
20
7
22
9
24
17
18
19
20
9
22
9
24
13
17
18
19
20
26
22
24
24
17
18
19
20
15
22
9
24
17
18
19
20
26
22
21
24
6
7
9
9
10
12
12
6
7
21
9
24
25
12
18
5
20
14
22
5
24
3
1
2
3
1
2
3
0
1
2
3
11
2
3
11
9
10
5
12
23
24
10
10
8
9
9
15
15
8
9
9
27
27
11
27
27
27
27
27
27
27
27
27
27
27
27
27
27
27
27
}
;
#
define
fts5YY_SHIFT_COUNT
(
34
)
#
define
fts5YY_SHIFT_MIN
(
0
)
#
define
fts5YY_SHIFT_MAX
(
93
)
static
const
unsigned
char
fts5yy_shift_ofst
[
]
=
{
44
44
44
44
44
44
51
77
43
12
14
83
82
14
23
23
31
31
71
74
78
81
86
91
6
53
53
60
64
68
53
87
92
53
93
}
;
#
define
fts5YY_REDUCE_COUNT
(
17
)
#
define
fts5YY_REDUCE_MIN
(
-
17
)
#
define
fts5YY_REDUCE_MAX
(
67
)
static
const
signed
char
fts5yy_reduce_ofst
[
]
=
{
-
16
-
8
0
9
17
25
46
-
17
-
17
37
67
4
4
8
4
20
27
38
}
;
static
const
fts5YYACTIONTYPE
fts5yy_default
[
]
=
{
80
80
80
80
80
80
95
80
80
105
80
110
110
80
110
110
80
80
80
80
80
91
80
80
80
101
100
80
80
90
103
80
80
104
80
}
;
#
ifdef
fts5YYFALLBACK
static
const
fts5YYCODETYPE
fts5yyFallback
[
]
=
{
}
;
#
endif
struct
fts5yyStackEntry
{
fts5YYACTIONTYPE
stateno
;
fts5YYCODETYPE
major
;
fts5YYMINORTYPE
minor
;
}
;
typedef
struct
fts5yyStackEntry
fts5yyStackEntry
;
struct
fts5yyParser
{
fts5yyStackEntry
*
fts5yytos
;
#
ifdef
fts5YYTRACKMAXSTACKDEPTH
int
fts5yyhwm
;
#
endif
#
ifndef
fts5YYNOERRORRECOVERY
int
fts5yyerrcnt
;
#
endif
sqlite3Fts5ParserARG_SDECL
sqlite3Fts5ParserCTX_SDECL
fts5yyStackEntry
*
fts5yystackEnd
;
fts5yyStackEntry
*
fts5yystack
;
fts5yyStackEntry
fts5yystk0
[
fts5YYSTACKDEPTH
]
;
}
;
typedef
struct
fts5yyParser
fts5yyParser
;
#
include
<
assert
.
h
>
#
ifndef
NDEBUG
#
include
<
stdio
.
h
>
static
FILE
*
fts5yyTraceFILE
=
0
;
static
char
*
fts5yyTracePrompt
=
0
;
#
endif
#
ifndef
NDEBUG
static
void
sqlite3Fts5ParserTrace
(
FILE
*
TraceFILE
char
*
zTracePrompt
)
{
fts5yyTraceFILE
=
TraceFILE
;
fts5yyTracePrompt
=
zTracePrompt
;
if
(
fts5yyTraceFILE
=
=
0
)
fts5yyTracePrompt
=
0
;
else
if
(
fts5yyTracePrompt
=
=
0
)
fts5yyTraceFILE
=
0
;
}
#
endif
#
if
defined
(
fts5YYCOVERAGE
)
|
|
!
defined
(
NDEBUG
)
static
const
char
*
const
fts5yyTokenName
[
]
=
{
"
"
"
OR
"
"
AND
"
"
NOT
"
"
TERM
"
"
COLON
"
"
MINUS
"
"
LCP
"
"
RCP
"
"
STRING
"
"
LP
"
"
RP
"
"
CARET
"
"
COMMA
"
"
PLUS
"
"
STAR
"
"
input
"
"
expr
"
"
cnearset
"
"
exprlist
"
"
colset
"
"
colsetlist
"
"
nearset
"
"
nearphrases
"
"
phrase
"
"
neardist_opt
"
"
star_opt
"
}
;
#
endif
#
ifndef
NDEBUG
static
const
char
*
const
fts5yyRuleName
[
]
=
{
"
input
:
:
=
expr
"
"
colset
:
:
=
MINUS
LCP
colsetlist
RCP
"
"
colset
:
:
=
LCP
colsetlist
RCP
"
"
colset
:
:
=
STRING
"
"
colset
:
:
=
MINUS
STRING
"
"
colsetlist
:
:
=
colsetlist
STRING
"
"
colsetlist
:
:
=
STRING
"
"
expr
:
:
=
expr
AND
expr
"
"
expr
:
:
=
expr
OR
expr
"
"
expr
:
:
=
expr
NOT
expr
"
"
expr
:
:
=
colset
COLON
LP
expr
RP
"
"
expr
:
:
=
LP
expr
RP
"
"
expr
:
:
=
exprlist
"
"
exprlist
:
:
=
cnearset
"
"
exprlist
:
:
=
exprlist
cnearset
"
"
cnearset
:
:
=
nearset
"
"
cnearset
:
:
=
colset
COLON
nearset
"
"
nearset
:
:
=
phrase
"
"
nearset
:
:
=
CARET
phrase
"
"
nearset
:
:
=
STRING
LP
nearphrases
neardist_opt
RP
"
"
nearphrases
:
:
=
phrase
"
"
nearphrases
:
:
=
nearphrases
phrase
"
"
neardist_opt
:
:
=
"
"
neardist_opt
:
:
=
COMMA
STRING
"
"
phrase
:
:
=
phrase
PLUS
STRING
star_opt
"
"
phrase
:
:
=
STRING
star_opt
"
"
star_opt
:
:
=
STAR
"
"
star_opt
:
:
=
"
}
;
#
endif
#
if
fts5YYGROWABLESTACK
static
int
fts5yyGrowStack
(
fts5yyParser
*
p
)
{
int
oldSize
=
1
+
(
int
)
(
p
-
>
fts5yystackEnd
-
p
-
>
fts5yystack
)
;
int
newSize
;
int
idx
;
fts5yyStackEntry
*
pNew
;
newSize
=
oldSize
*
2
+
100
;
idx
=
(
int
)
(
p
-
>
fts5yytos
-
p
-
>
fts5yystack
)
;
if
(
p
-
>
fts5yystack
=
=
p
-
>
fts5yystk0
)
{
pNew
=
fts5YYREALLOC
(
0
newSize
*
sizeof
(
pNew
[
0
]
)
)
;
if
(
pNew
=
=
0
)
return
1
;
memcpy
(
pNew
p
-
>
fts5yystack
oldSize
*
sizeof
(
pNew
[
0
]
)
)
;
}
else
{
pNew
=
fts5YYREALLOC
(
p
-
>
fts5yystack
newSize
*
sizeof
(
pNew
[
0
]
)
)
;
if
(
pNew
=
=
0
)
return
1
;
}
p
-
>
fts5yystack
=
pNew
;
p
-
>
fts5yytos
=
&
p
-
>
fts5yystack
[
idx
]
;
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sStack
grows
from
%
d
to
%
d
entries
.
\
n
"
fts5yyTracePrompt
oldSize
newSize
)
;
}
#
endif
p
-
>
fts5yystackEnd
=
&
p
-
>
fts5yystack
[
newSize
-
1
]
;
return
0
;
}
#
endif
#
if
!
fts5YYGROWABLESTACK
#
define
fts5yyGrowStack
(
X
)
1
#
endif
#
ifndef
fts5YYMALLOCARGTYPE
#
define
fts5YYMALLOCARGTYPE
size_t
#
endif
static
void
sqlite3Fts5ParserInit
(
void
*
fts5yypRawParser
sqlite3Fts5ParserCTX_PDECL
)
{
fts5yyParser
*
fts5yypParser
=
(
fts5yyParser
*
)
fts5yypRawParser
;
sqlite3Fts5ParserCTX_STORE
#
ifdef
fts5YYTRACKMAXSTACKDEPTH
fts5yypParser
-
>
fts5yyhwm
=
0
;
#
endif
fts5yypParser
-
>
fts5yystack
=
fts5yypParser
-
>
fts5yystk0
;
fts5yypParser
-
>
fts5yystackEnd
=
&
fts5yypParser
-
>
fts5yystack
[
fts5YYSTACKDEPTH
-
1
]
;
#
ifndef
fts5YYNOERRORRECOVERY
fts5yypParser
-
>
fts5yyerrcnt
=
-
1
;
#
endif
fts5yypParser
-
>
fts5yytos
=
fts5yypParser
-
>
fts5yystack
;
fts5yypParser
-
>
fts5yystack
[
0
]
.
stateno
=
0
;
fts5yypParser
-
>
fts5yystack
[
0
]
.
major
=
0
;
}
#
ifndef
sqlite3Fts5Parser_ENGINEALWAYSONSTACK
static
void
*
sqlite3Fts5ParserAlloc
(
void
*
(
*
mallocProc
)
(
fts5YYMALLOCARGTYPE
)
sqlite3Fts5ParserCTX_PDECL
)
{
fts5yyParser
*
fts5yypParser
;
fts5yypParser
=
(
fts5yyParser
*
)
(
*
mallocProc
)
(
(
fts5YYMALLOCARGTYPE
)
sizeof
(
fts5yyParser
)
)
;
if
(
fts5yypParser
)
{
sqlite3Fts5ParserCTX_STORE
sqlite3Fts5ParserInit
(
fts5yypParser
sqlite3Fts5ParserCTX_PARAM
)
;
}
return
(
void
*
)
fts5yypParser
;
}
#
endif
static
void
fts5yy_destructor
(
fts5yyParser
*
fts5yypParser
fts5YYCODETYPE
fts5yymajor
fts5YYMINORTYPE
*
fts5yypminor
)
{
sqlite3Fts5ParserARG_FETCH
sqlite3Fts5ParserCTX_FETCH
switch
(
fts5yymajor
)
{
case
16
:
{
#
line
83
"
fts5parse
.
y
"
(
void
)
pParse
;
#
line
606
"
fts5parse
.
sql
"
}
break
;
case
17
:
case
18
:
case
19
:
{
#
line
89
"
fts5parse
.
y
"
sqlite3Fts5ParseNodeFree
(
(
fts5yypminor
-
>
fts5yy24
)
)
;
#
line
615
"
fts5parse
.
sql
"
}
break
;
case
20
:
case
21
:
{
#
line
93
"
fts5parse
.
y
"
sqlite3_free
(
(
fts5yypminor
-
>
fts5yy11
)
)
;
#
line
623
"
fts5parse
.
sql
"
}
break
;
case
22
:
case
23
:
{
#
line
148
"
fts5parse
.
y
"
sqlite3Fts5ParseNearsetFree
(
(
fts5yypminor
-
>
fts5yy46
)
)
;
#
line
631
"
fts5parse
.
sql
"
}
break
;
case
24
:
{
#
line
183
"
fts5parse
.
y
"
sqlite3Fts5ParsePhraseFree
(
(
fts5yypminor
-
>
fts5yy53
)
)
;
#
line
638
"
fts5parse
.
sql
"
}
break
;
default
:
break
;
}
}
static
void
fts5yy_pop_parser_stack
(
fts5yyParser
*
pParser
)
{
fts5yyStackEntry
*
fts5yytos
;
assert
(
pParser
-
>
fts5yytos
!
=
0
)
;
assert
(
pParser
-
>
fts5yytos
>
pParser
-
>
fts5yystack
)
;
fts5yytos
=
pParser
-
>
fts5yytos
-
-
;
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sPopping
%
s
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
fts5yytos
-
>
major
]
)
;
}
#
endif
fts5yy_destructor
(
pParser
fts5yytos
-
>
major
&
fts5yytos
-
>
minor
)
;
}
static
void
sqlite3Fts5ParserFinalize
(
void
*
p
)
{
fts5yyParser
*
pParser
=
(
fts5yyParser
*
)
p
;
fts5yyStackEntry
*
fts5yytos
=
pParser
-
>
fts5yytos
;
while
(
fts5yytos
>
pParser
-
>
fts5yystack
)
{
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sPopping
%
s
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
fts5yytos
-
>
major
]
)
;
}
#
endif
if
(
fts5yytos
-
>
major
>
=
fts5YY_MIN_DSTRCTR
)
{
fts5yy_destructor
(
pParser
fts5yytos
-
>
major
&
fts5yytos
-
>
minor
)
;
}
fts5yytos
-
-
;
}
#
if
fts5YYGROWABLESTACK
if
(
pParser
-
>
fts5yystack
!
=
pParser
-
>
fts5yystk0
)
fts5YYFREE
(
pParser
-
>
fts5yystack
)
;
#
endif
}
#
ifndef
sqlite3Fts5Parser_ENGINEALWAYSONSTACK
static
void
sqlite3Fts5ParserFree
(
void
*
p
void
(
*
freeProc
)
(
void
*
)
)
{
#
ifndef
fts5YYPARSEFREENEVERNULL
if
(
p
=
=
0
)
return
;
#
endif
sqlite3Fts5ParserFinalize
(
p
)
;
(
*
freeProc
)
(
p
)
;
}
#
endif
#
ifdef
fts5YYTRACKMAXSTACKDEPTH
static
int
sqlite3Fts5ParserStackPeak
(
void
*
p
)
{
fts5yyParser
*
pParser
=
(
fts5yyParser
*
)
p
;
return
pParser
-
>
fts5yyhwm
;
}
#
endif
#
if
defined
(
fts5YYCOVERAGE
)
static
unsigned
char
fts5yycoverage
[
fts5YYNSTATE
]
[
fts5YYNFTS5TOKEN
]
;
#
endif
#
if
defined
(
fts5YYCOVERAGE
)
static
int
sqlite3Fts5ParserCoverage
(
FILE
*
out
)
{
int
stateno
iLookAhead
i
;
int
nMissed
=
0
;
for
(
stateno
=
0
;
stateno
<
fts5YYNSTATE
;
stateno
+
+
)
{
i
=
fts5yy_shift_ofst
[
stateno
]
;
for
(
iLookAhead
=
0
;
iLookAhead
<
fts5YYNFTS5TOKEN
;
iLookAhead
+
+
)
{
if
(
fts5yy_lookahead
[
i
+
iLookAhead
]
!
=
iLookAhead
)
continue
;
if
(
fts5yycoverage
[
stateno
]
[
iLookAhead
]
=
=
0
)
nMissed
+
+
;
if
(
out
)
{
fprintf
(
out
"
State
%
d
lookahead
%
s
%
s
\
n
"
stateno
fts5yyTokenName
[
iLookAhead
]
fts5yycoverage
[
stateno
]
[
iLookAhead
]
?
"
ok
"
:
"
missed
"
)
;
}
}
}
return
nMissed
;
}
#
endif
static
fts5YYACTIONTYPE
fts5yy_find_shift_action
(
fts5YYCODETYPE
iLookAhead
fts5YYACTIONTYPE
stateno
)
{
int
i
;
if
(
stateno
>
fts5YY_MAX_SHIFT
)
return
stateno
;
assert
(
stateno
<
=
fts5YY_SHIFT_COUNT
)
;
#
if
defined
(
fts5YYCOVERAGE
)
fts5yycoverage
[
stateno
]
[
iLookAhead
]
=
1
;
#
endif
do
{
i
=
fts5yy_shift_ofst
[
stateno
]
;
assert
(
i
>
=
0
)
;
assert
(
i
<
=
fts5YY_ACTTAB_COUNT
)
;
assert
(
i
+
fts5YYNFTS5TOKEN
<
=
(
int
)
fts5YY_NLOOKAHEAD
)
;
assert
(
iLookAhead
!
=
fts5YYNOCODE
)
;
assert
(
iLookAhead
<
fts5YYNFTS5TOKEN
)
;
i
+
=
iLookAhead
;
assert
(
i
<
(
int
)
fts5YY_NLOOKAHEAD
)
;
if
(
fts5yy_lookahead
[
i
]
!
=
iLookAhead
)
{
#
ifdef
fts5YYFALLBACK
fts5YYCODETYPE
iFallback
;
assert
(
iLookAhead
<
sizeof
(
fts5yyFallback
)
/
sizeof
(
fts5yyFallback
[
0
]
)
)
;
iFallback
=
fts5yyFallback
[
iLookAhead
]
;
if
(
iFallback
!
=
0
)
{
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sFALLBACK
%
s
=
>
%
s
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
iLookAhead
]
fts5yyTokenName
[
iFallback
]
)
;
}
#
endif
assert
(
fts5yyFallback
[
iFallback
]
=
=
0
)
;
iLookAhead
=
iFallback
;
continue
;
}
#
endif
#
ifdef
fts5YYWILDCARD
{
int
j
=
i
-
iLookAhead
+
fts5YYWILDCARD
;
assert
(
j
<
(
int
)
(
sizeof
(
fts5yy_lookahead
)
/
sizeof
(
fts5yy_lookahead
[
0
]
)
)
)
;
if
(
fts5yy_lookahead
[
j
]
=
=
fts5YYWILDCARD
&
&
iLookAhead
>
0
)
{
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sWILDCARD
%
s
=
>
%
s
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
iLookAhead
]
fts5yyTokenName
[
fts5YYWILDCARD
]
)
;
}
#
endif
return
fts5yy_action
[
j
]
;
}
}
#
endif
return
fts5yy_default
[
stateno
]
;
}
else
{
assert
(
i
>
=
0
&
&
i
<
(
int
)
(
sizeof
(
fts5yy_action
)
/
sizeof
(
fts5yy_action
[
0
]
)
)
)
;
return
fts5yy_action
[
i
]
;
}
}
while
(
1
)
;
}
static
fts5YYACTIONTYPE
fts5yy_find_reduce_action
(
fts5YYACTIONTYPE
stateno
fts5YYCODETYPE
iLookAhead
)
{
int
i
;
#
ifdef
fts5YYERRORSYMBOL
if
(
stateno
>
fts5YY_REDUCE_COUNT
)
{
return
fts5yy_default
[
stateno
]
;
}
#
else
assert
(
stateno
<
=
fts5YY_REDUCE_COUNT
)
;
#
endif
i
=
fts5yy_reduce_ofst
[
stateno
]
;
assert
(
iLookAhead
!
=
fts5YYNOCODE
)
;
i
+
=
iLookAhead
;
#
ifdef
fts5YYERRORSYMBOL
if
(
i
<
0
|
|
i
>
=
fts5YY_ACTTAB_COUNT
|
|
fts5yy_lookahead
[
i
]
!
=
iLookAhead
)
{
return
fts5yy_default
[
stateno
]
;
}
#
else
assert
(
i
>
=
0
&
&
i
<
fts5YY_ACTTAB_COUNT
)
;
assert
(
fts5yy_lookahead
[
i
]
=
=
iLookAhead
)
;
#
endif
return
fts5yy_action
[
i
]
;
}
static
void
fts5yyStackOverflow
(
fts5yyParser
*
fts5yypParser
)
{
sqlite3Fts5ParserARG_FETCH
sqlite3Fts5ParserCTX_FETCH
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sStack
Overflow
!
\
n
"
fts5yyTracePrompt
)
;
}
#
endif
while
(
fts5yypParser
-
>
fts5yytos
>
fts5yypParser
-
>
fts5yystack
)
fts5yy_pop_parser_stack
(
fts5yypParser
)
;
#
line
36
"
fts5parse
.
y
"
sqlite3Fts5ParseError
(
pParse
"
fts5
:
parser
stack
overflow
"
)
;
#
line
876
"
fts5parse
.
sql
"
sqlite3Fts5ParserARG_STORE
sqlite3Fts5ParserCTX_STORE
}
#
ifndef
NDEBUG
static
void
fts5yyTraceShift
(
fts5yyParser
*
fts5yypParser
int
fts5yyNewState
const
char
*
zTag
)
{
if
(
fts5yyTraceFILE
)
{
if
(
fts5yyNewState
<
fts5YYNSTATE
)
{
fprintf
(
fts5yyTraceFILE
"
%
s
%
s
'
%
s
'
go
to
state
%
d
\
n
"
fts5yyTracePrompt
zTag
fts5yyTokenName
[
fts5yypParser
-
>
fts5yytos
-
>
major
]
fts5yyNewState
)
;
}
else
{
fprintf
(
fts5yyTraceFILE
"
%
s
%
s
'
%
s
'
pending
reduce
%
d
\
n
"
fts5yyTracePrompt
zTag
fts5yyTokenName
[
fts5yypParser
-
>
fts5yytos
-
>
major
]
fts5yyNewState
-
fts5YY_MIN_REDUCE
)
;
}
}
}
#
else
#
define
fts5yyTraceShift
(
X
Y
Z
)
#
endif
static
void
fts5yy_shift
(
fts5yyParser
*
fts5yypParser
fts5YYACTIONTYPE
fts5yyNewState
fts5YYCODETYPE
fts5yyMajor
sqlite3Fts5ParserFTS5TOKENTYPE
fts5yyMinor
)
{
fts5yyStackEntry
*
fts5yytos
;
fts5yypParser
-
>
fts5yytos
+
+
;
#
ifdef
fts5YYTRACKMAXSTACKDEPTH
if
(
(
int
)
(
fts5yypParser
-
>
fts5yytos
-
fts5yypParser
-
>
fts5yystack
)
>
fts5yypParser
-
>
fts5yyhwm
)
{
fts5yypParser
-
>
fts5yyhwm
+
+
;
assert
(
fts5yypParser
-
>
fts5yyhwm
=
=
(
int
)
(
fts5yypParser
-
>
fts5yytos
-
fts5yypParser
-
>
fts5yystack
)
)
;
}
#
endif
fts5yytos
=
fts5yypParser
-
>
fts5yytos
;
if
(
fts5yytos
>
fts5yypParser
-
>
fts5yystackEnd
)
{
if
(
fts5yyGrowStack
(
fts5yypParser
)
)
{
fts5yypParser
-
>
fts5yytos
-
-
;
fts5yyStackOverflow
(
fts5yypParser
)
;
return
;
}
fts5yytos
=
fts5yypParser
-
>
fts5yytos
;
assert
(
fts5yytos
<
=
fts5yypParser
-
>
fts5yystackEnd
)
;
}
if
(
fts5yyNewState
>
fts5YY_MAX_SHIFT
)
{
fts5yyNewState
+
=
fts5YY_MIN_REDUCE
-
fts5YY_MIN_SHIFTREDUCE
;
}
fts5yytos
-
>
stateno
=
fts5yyNewState
;
fts5yytos
-
>
major
=
fts5yyMajor
;
fts5yytos
-
>
minor
.
fts5yy0
=
fts5yyMinor
;
fts5yyTraceShift
(
fts5yypParser
fts5yyNewState
"
Shift
"
)
;
}
static
const
fts5YYCODETYPE
fts5yyRuleInfoLhs
[
]
=
{
16
20
20
20
20
21
21
17
17
17
17
17
17
19
19
18
18
22
22
22
23
23
25
25
24
24
26
26
}
;
static
const
signed
char
fts5yyRuleInfoNRhs
[
]
=
{
-
1
-
4
-
3
-
1
-
2
-
2
-
1
-
3
-
3
-
3
-
5
-
3
-
1
-
1
-
2
-
1
-
3
-
1
-
2
-
5
-
1
-
2
0
-
2
-
4
-
2
-
1
0
}
;
static
void
fts5yy_accept
(
fts5yyParser
*
)
;
static
fts5YYACTIONTYPE
fts5yy_reduce
(
fts5yyParser
*
fts5yypParser
unsigned
int
fts5yyruleno
int
fts5yyLookahead
sqlite3Fts5ParserFTS5TOKENTYPE
fts5yyLookaheadToken
sqlite3Fts5ParserCTX_PDECL
)
{
int
fts5yygoto
;
fts5YYACTIONTYPE
fts5yyact
;
fts5yyStackEntry
*
fts5yymsp
;
int
fts5yysize
;
sqlite3Fts5ParserARG_FETCH
(
void
)
fts5yyLookahead
;
(
void
)
fts5yyLookaheadToken
;
fts5yymsp
=
fts5yypParser
-
>
fts5yytos
;
switch
(
fts5yyruleno
)
{
fts5YYMINORTYPE
fts5yylhsminor
;
case
0
:
#
line
82
"
fts5parse
.
y
"
{
sqlite3Fts5ParseFinished
(
pParse
fts5yymsp
[
0
]
.
minor
.
fts5yy24
)
;
}
#
line
1047
"
fts5parse
.
sql
"
break
;
case
1
:
#
line
97
"
fts5parse
.
y
"
{
fts5yymsp
[
-
3
]
.
minor
.
fts5yy11
=
sqlite3Fts5ParseColsetInvert
(
pParse
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
)
;
}
#
line
1054
"
fts5parse
.
sql
"
break
;
case
2
:
#
line
100
"
fts5parse
.
y
"
{
fts5yymsp
[
-
2
]
.
minor
.
fts5yy11
=
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
;
}
#
line
1059
"
fts5parse
.
sql
"
break
;
case
3
:
#
line
101
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy11
=
sqlite3Fts5ParseColset
(
pParse
0
&
fts5yymsp
[
0
]
.
minor
.
fts5yy0
)
;
}
#
line
1066
"
fts5parse
.
sql
"
fts5yymsp
[
0
]
.
minor
.
fts5yy11
=
fts5yylhsminor
.
fts5yy11
;
break
;
case
4
:
#
line
104
"
fts5parse
.
y
"
{
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
=
sqlite3Fts5ParseColset
(
pParse
0
&
fts5yymsp
[
0
]
.
minor
.
fts5yy0
)
;
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
=
sqlite3Fts5ParseColsetInvert
(
pParse
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
)
;
}
#
line
1075
"
fts5parse
.
sql
"
break
;
case
5
:
#
line
109
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy11
=
sqlite3Fts5ParseColset
(
pParse
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
&
fts5yymsp
[
0
]
.
minor
.
fts5yy0
)
;
}
#
line
1081
"
fts5parse
.
sql
"
fts5yymsp
[
-
1
]
.
minor
.
fts5yy11
=
fts5yylhsminor
.
fts5yy11
;
break
;
case
6
:
#
line
111
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy11
=
sqlite3Fts5ParseColset
(
pParse
0
&
fts5yymsp
[
0
]
.
minor
.
fts5yy0
)
;
}
#
line
1089
"
fts5parse
.
sql
"
fts5yymsp
[
0
]
.
minor
.
fts5yy11
=
fts5yylhsminor
.
fts5yy11
;
break
;
case
7
:
#
line
115
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
sqlite3Fts5ParseNode
(
pParse
FTS5_AND
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
fts5yymsp
[
0
]
.
minor
.
fts5yy24
0
)
;
}
#
line
1097
"
fts5parse
.
sql
"
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
8
:
#
line
118
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
sqlite3Fts5ParseNode
(
pParse
FTS5_OR
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
fts5yymsp
[
0
]
.
minor
.
fts5yy24
0
)
;
}
#
line
1105
"
fts5parse
.
sql
"
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
9
:
#
line
121
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
sqlite3Fts5ParseNode
(
pParse
FTS5_NOT
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
fts5yymsp
[
0
]
.
minor
.
fts5yy24
0
)
;
}
#
line
1113
"
fts5parse
.
sql
"
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
10
:
#
line
125
"
fts5parse
.
y
"
{
sqlite3Fts5ParseSetColset
(
pParse
fts5yymsp
[
-
1
]
.
minor
.
fts5yy24
fts5yymsp
[
-
4
]
.
minor
.
fts5yy11
)
;
fts5yylhsminor
.
fts5yy24
=
fts5yymsp
[
-
1
]
.
minor
.
fts5yy24
;
}
#
line
1122
"
fts5parse
.
sql
"
fts5yymsp
[
-
4
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
11
:
#
line
129
"
fts5parse
.
y
"
{
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
=
fts5yymsp
[
-
1
]
.
minor
.
fts5yy24
;
}
#
line
1128
"
fts5parse
.
sql
"
break
;
case
12
:
case
13
:
fts5yytestcase
(
fts5yyruleno
=
=
13
)
;
#
line
130
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
fts5yymsp
[
0
]
.
minor
.
fts5yy24
;
}
#
line
1134
"
fts5parse
.
sql
"
fts5yymsp
[
0
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
14
:
#
line
133
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
sqlite3Fts5ParseImplicitAnd
(
pParse
fts5yymsp
[
-
1
]
.
minor
.
fts5yy24
fts5yymsp
[
0
]
.
minor
.
fts5yy24
)
;
}
#
line
1142
"
fts5parse
.
sql
"
fts5yymsp
[
-
1
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
15
:
#
line
137
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
sqlite3Fts5ParseNode
(
pParse
FTS5_STRING
0
0
fts5yymsp
[
0
]
.
minor
.
fts5yy46
)
;
}
#
line
1150
"
fts5parse
.
sql
"
fts5yymsp
[
0
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
16
:
#
line
140
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy24
=
sqlite3Fts5ParseNode
(
pParse
FTS5_STRING
0
0
fts5yymsp
[
0
]
.
minor
.
fts5yy46
)
;
sqlite3Fts5ParseSetColset
(
pParse
fts5yylhsminor
.
fts5yy24
fts5yymsp
[
-
2
]
.
minor
.
fts5yy11
)
;
}
#
line
1159
"
fts5parse
.
sql
"
fts5yymsp
[
-
2
]
.
minor
.
fts5yy24
=
fts5yylhsminor
.
fts5yy24
;
break
;
case
17
:
#
line
151
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy46
=
sqlite3Fts5ParseNearset
(
pParse
0
fts5yymsp
[
0
]
.
minor
.
fts5yy53
)
;
}
#
line
1165
"
fts5parse
.
sql
"
fts5yymsp
[
0
]
.
minor
.
fts5yy46
=
fts5yylhsminor
.
fts5yy46
;
break
;
case
18
:
#
line
152
"
fts5parse
.
y
"
{
sqlite3Fts5ParseSetCaret
(
fts5yymsp
[
0
]
.
minor
.
fts5yy53
)
;
fts5yymsp
[
-
1
]
.
minor
.
fts5yy46
=
sqlite3Fts5ParseNearset
(
pParse
0
fts5yymsp
[
0
]
.
minor
.
fts5yy53
)
;
}
#
line
1174
"
fts5parse
.
sql
"
break
;
case
19
:
#
line
156
"
fts5parse
.
y
"
{
sqlite3Fts5ParseNear
(
pParse
&
fts5yymsp
[
-
4
]
.
minor
.
fts5yy0
)
;
sqlite3Fts5ParseSetDistance
(
pParse
fts5yymsp
[
-
2
]
.
minor
.
fts5yy46
&
fts5yymsp
[
-
1
]
.
minor
.
fts5yy0
)
;
fts5yylhsminor
.
fts5yy46
=
fts5yymsp
[
-
2
]
.
minor
.
fts5yy46
;
}
#
line
1183
"
fts5parse
.
sql
"
fts5yymsp
[
-
4
]
.
minor
.
fts5yy46
=
fts5yylhsminor
.
fts5yy46
;
break
;
case
20
:
#
line
162
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy46
=
sqlite3Fts5ParseNearset
(
pParse
0
fts5yymsp
[
0
]
.
minor
.
fts5yy53
)
;
}
#
line
1191
"
fts5parse
.
sql
"
fts5yymsp
[
0
]
.
minor
.
fts5yy46
=
fts5yylhsminor
.
fts5yy46
;
break
;
case
21
:
#
line
165
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy46
=
sqlite3Fts5ParseNearset
(
pParse
fts5yymsp
[
-
1
]
.
minor
.
fts5yy46
fts5yymsp
[
0
]
.
minor
.
fts5yy53
)
;
}
#
line
1199
"
fts5parse
.
sql
"
fts5yymsp
[
-
1
]
.
minor
.
fts5yy46
=
fts5yylhsminor
.
fts5yy46
;
break
;
case
22
:
#
line
172
"
fts5parse
.
y
"
{
fts5yymsp
[
1
]
.
minor
.
fts5yy0
.
p
=
0
;
fts5yymsp
[
1
]
.
minor
.
fts5yy0
.
n
=
0
;
}
#
line
1205
"
fts5parse
.
sql
"
break
;
case
23
:
#
line
173
"
fts5parse
.
y
"
{
fts5yymsp
[
-
1
]
.
minor
.
fts5yy0
=
fts5yymsp
[
0
]
.
minor
.
fts5yy0
;
}
#
line
1210
"
fts5parse
.
sql
"
break
;
case
24
:
#
line
185
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy53
=
sqlite3Fts5ParseTerm
(
pParse
fts5yymsp
[
-
3
]
.
minor
.
fts5yy53
&
fts5yymsp
[
-
1
]
.
minor
.
fts5yy0
fts5yymsp
[
0
]
.
minor
.
fts5yy4
)
;
}
#
line
1217
"
fts5parse
.
sql
"
fts5yymsp
[
-
3
]
.
minor
.
fts5yy53
=
fts5yylhsminor
.
fts5yy53
;
break
;
case
25
:
#
line
188
"
fts5parse
.
y
"
{
fts5yylhsminor
.
fts5yy53
=
sqlite3Fts5ParseTerm
(
pParse
0
&
fts5yymsp
[
-
1
]
.
minor
.
fts5yy0
fts5yymsp
[
0
]
.
minor
.
fts5yy4
)
;
}
#
line
1225
"
fts5parse
.
sql
"
fts5yymsp
[
-
1
]
.
minor
.
fts5yy53
=
fts5yylhsminor
.
fts5yy53
;
break
;
case
26
:
#
line
196
"
fts5parse
.
y
"
{
fts5yymsp
[
0
]
.
minor
.
fts5yy4
=
1
;
}
#
line
1231
"
fts5parse
.
sql
"
break
;
case
27
:
#
line
197
"
fts5parse
.
y
"
{
fts5yymsp
[
1
]
.
minor
.
fts5yy4
=
0
;
}
#
line
1236
"
fts5parse
.
sql
"
break
;
default
:
break
;
}
;
assert
(
fts5yyruleno
<
sizeof
(
fts5yyRuleInfoLhs
)
/
sizeof
(
fts5yyRuleInfoLhs
[
0
]
)
)
;
fts5yygoto
=
fts5yyRuleInfoLhs
[
fts5yyruleno
]
;
fts5yysize
=
fts5yyRuleInfoNRhs
[
fts5yyruleno
]
;
fts5yyact
=
fts5yy_find_reduce_action
(
fts5yymsp
[
fts5yysize
]
.
stateno
(
fts5YYCODETYPE
)
fts5yygoto
)
;
assert
(
!
(
fts5yyact
>
fts5YY_MAX_SHIFT
&
&
fts5yyact
<
=
fts5YY_MAX_SHIFTREDUCE
)
)
;
assert
(
fts5yyact
!
=
fts5YY_ERROR_ACTION
)
;
fts5yymsp
+
=
fts5yysize
+
1
;
fts5yypParser
-
>
fts5yytos
=
fts5yymsp
;
fts5yymsp
-
>
stateno
=
(
fts5YYACTIONTYPE
)
fts5yyact
;
fts5yymsp
-
>
major
=
(
fts5YYCODETYPE
)
fts5yygoto
;
fts5yyTraceShift
(
fts5yypParser
fts5yyact
"
.
.
.
then
shift
"
)
;
return
fts5yyact
;
}
#
ifndef
fts5YYNOERRORRECOVERY
static
void
fts5yy_parse_failed
(
fts5yyParser
*
fts5yypParser
)
{
sqlite3Fts5ParserARG_FETCH
sqlite3Fts5ParserCTX_FETCH
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sFail
!
\
n
"
fts5yyTracePrompt
)
;
}
#
endif
while
(
fts5yypParser
-
>
fts5yytos
>
fts5yypParser
-
>
fts5yystack
)
fts5yy_pop_parser_stack
(
fts5yypParser
)
;
sqlite3Fts5ParserARG_STORE
sqlite3Fts5ParserCTX_STORE
}
#
endif
static
void
fts5yy_syntax_error
(
fts5yyParser
*
fts5yypParser
int
fts5yymajor
sqlite3Fts5ParserFTS5TOKENTYPE
fts5yyminor
)
{
sqlite3Fts5ParserARG_FETCH
sqlite3Fts5ParserCTX_FETCH
#
define
FTS5TOKEN
fts5yyminor
#
line
30
"
fts5parse
.
y
"
UNUSED_PARAM
(
fts5yymajor
)
;
sqlite3Fts5ParseError
(
pParse
"
fts5
:
syntax
error
near
\
"
%
.
*
s
\
"
"
FTS5TOKEN
.
n
FTS5TOKEN
.
p
)
;
#
line
1304
"
fts5parse
.
sql
"
sqlite3Fts5ParserARG_STORE
sqlite3Fts5ParserCTX_STORE
}
static
void
fts5yy_accept
(
fts5yyParser
*
fts5yypParser
)
{
sqlite3Fts5ParserARG_FETCH
sqlite3Fts5ParserCTX_FETCH
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sAccept
!
\
n
"
fts5yyTracePrompt
)
;
}
#
endif
#
ifndef
fts5YYNOERRORRECOVERY
fts5yypParser
-
>
fts5yyerrcnt
=
-
1
;
#
endif
assert
(
fts5yypParser
-
>
fts5yytos
=
=
fts5yypParser
-
>
fts5yystack
)
;
sqlite3Fts5ParserARG_STORE
sqlite3Fts5ParserCTX_STORE
}
static
void
sqlite3Fts5Parser
(
void
*
fts5yyp
int
fts5yymajor
sqlite3Fts5ParserFTS5TOKENTYPE
fts5yyminor
sqlite3Fts5ParserARG_PDECL
)
{
fts5YYMINORTYPE
fts5yyminorunion
;
fts5YYACTIONTYPE
fts5yyact
;
#
if
!
defined
(
fts5YYERRORSYMBOL
)
&
&
!
defined
(
fts5YYNOERRORRECOVERY
)
int
fts5yyendofinput
;
#
endif
#
ifdef
fts5YYERRORSYMBOL
int
fts5yyerrorhit
=
0
;
#
endif
fts5yyParser
*
fts5yypParser
=
(
fts5yyParser
*
)
fts5yyp
;
sqlite3Fts5ParserCTX_FETCH
sqlite3Fts5ParserARG_STORE
assert
(
fts5yypParser
-
>
fts5yytos
!
=
0
)
;
#
if
!
defined
(
fts5YYERRORSYMBOL
)
&
&
!
defined
(
fts5YYNOERRORRECOVERY
)
fts5yyendofinput
=
(
fts5yymajor
=
=
0
)
;
#
endif
fts5yyact
=
fts5yypParser
-
>
fts5yytos
-
>
stateno
;
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
if
(
fts5yyact
<
fts5YY_MIN_REDUCE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sInput
'
%
s
'
in
state
%
d
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
fts5yymajor
]
fts5yyact
)
;
}
else
{
fprintf
(
fts5yyTraceFILE
"
%
sInput
'
%
s
'
with
pending
reduce
%
d
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
fts5yymajor
]
fts5yyact
-
fts5YY_MIN_REDUCE
)
;
}
}
#
endif
while
(
1
)
{
assert
(
fts5yypParser
-
>
fts5yytos
>
=
fts5yypParser
-
>
fts5yystack
)
;
assert
(
fts5yyact
=
=
fts5yypParser
-
>
fts5yytos
-
>
stateno
)
;
fts5yyact
=
fts5yy_find_shift_action
(
(
fts5YYCODETYPE
)
fts5yymajor
fts5yyact
)
;
if
(
fts5yyact
>
=
fts5YY_MIN_REDUCE
)
{
unsigned
int
fts5yyruleno
=
fts5yyact
-
fts5YY_MIN_REDUCE
;
#
ifndef
NDEBUG
assert
(
fts5yyruleno
<
(
int
)
(
sizeof
(
fts5yyRuleName
)
/
sizeof
(
fts5yyRuleName
[
0
]
)
)
)
;
if
(
fts5yyTraceFILE
)
{
int
fts5yysize
=
fts5yyRuleInfoNRhs
[
fts5yyruleno
]
;
if
(
fts5yysize
)
{
fprintf
(
fts5yyTraceFILE
"
%
sReduce
%
d
[
%
s
]
%
s
pop
back
to
state
%
d
.
\
n
"
fts5yyTracePrompt
fts5yyruleno
fts5yyRuleName
[
fts5yyruleno
]
fts5yyruleno
<
fts5YYNRULE_WITH_ACTION
?
"
"
:
"
without
external
action
"
fts5yypParser
-
>
fts5yytos
[
fts5yysize
]
.
stateno
)
;
}
else
{
fprintf
(
fts5yyTraceFILE
"
%
sReduce
%
d
[
%
s
]
%
s
.
\
n
"
fts5yyTracePrompt
fts5yyruleno
fts5yyRuleName
[
fts5yyruleno
]
fts5yyruleno
<
fts5YYNRULE_WITH_ACTION
?
"
"
:
"
without
external
action
"
)
;
}
}
#
endif
if
(
fts5yyRuleInfoNRhs
[
fts5yyruleno
]
=
=
0
)
{
#
ifdef
fts5YYTRACKMAXSTACKDEPTH
if
(
(
int
)
(
fts5yypParser
-
>
fts5yytos
-
fts5yypParser
-
>
fts5yystack
)
>
fts5yypParser
-
>
fts5yyhwm
)
{
fts5yypParser
-
>
fts5yyhwm
+
+
;
assert
(
fts5yypParser
-
>
fts5yyhwm
=
=
(
int
)
(
fts5yypParser
-
>
fts5yytos
-
fts5yypParser
-
>
fts5yystack
)
)
;
}
#
endif
if
(
fts5yypParser
-
>
fts5yytos
>
=
fts5yypParser
-
>
fts5yystackEnd
)
{
if
(
fts5yyGrowStack
(
fts5yypParser
)
)
{
fts5yyStackOverflow
(
fts5yypParser
)
;
break
;
}
}
}
fts5yyact
=
fts5yy_reduce
(
fts5yypParser
fts5yyruleno
fts5yymajor
fts5yyminor
sqlite3Fts5ParserCTX_PARAM
)
;
}
else
if
(
fts5yyact
<
=
fts5YY_MAX_SHIFTREDUCE
)
{
fts5yy_shift
(
fts5yypParser
fts5yyact
(
fts5YYCODETYPE
)
fts5yymajor
fts5yyminor
)
;
#
ifndef
fts5YYNOERRORRECOVERY
fts5yypParser
-
>
fts5yyerrcnt
-
-
;
#
endif
break
;
}
else
if
(
fts5yyact
=
=
fts5YY_ACCEPT_ACTION
)
{
fts5yypParser
-
>
fts5yytos
-
-
;
fts5yy_accept
(
fts5yypParser
)
;
return
;
}
else
{
assert
(
fts5yyact
=
=
fts5YY_ERROR_ACTION
)
;
fts5yyminorunion
.
fts5yy0
=
fts5yyminor
;
#
ifdef
fts5YYERRORSYMBOL
int
fts5yymx
;
#
endif
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sSyntax
Error
!
\
n
"
fts5yyTracePrompt
)
;
}
#
endif
#
ifdef
fts5YYERRORSYMBOL
if
(
fts5yypParser
-
>
fts5yyerrcnt
<
0
)
{
fts5yy_syntax_error
(
fts5yypParser
fts5yymajor
fts5yyminor
)
;
}
fts5yymx
=
fts5yypParser
-
>
fts5yytos
-
>
major
;
if
(
fts5yymx
=
=
fts5YYERRORSYMBOL
|
|
fts5yyerrorhit
)
{
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fprintf
(
fts5yyTraceFILE
"
%
sDiscard
input
token
%
s
\
n
"
fts5yyTracePrompt
fts5yyTokenName
[
fts5yymajor
]
)
;
}
#
endif
fts5yy_destructor
(
fts5yypParser
(
fts5YYCODETYPE
)
fts5yymajor
&
fts5yyminorunion
)
;
fts5yymajor
=
fts5YYNOCODE
;
}
else
{
while
(
fts5yypParser
-
>
fts5yytos
>
fts5yypParser
-
>
fts5yystack
)
{
fts5yyact
=
fts5yy_find_reduce_action
(
fts5yypParser
-
>
fts5yytos
-
>
stateno
fts5YYERRORSYMBOL
)
;
if
(
fts5yyact
<
=
fts5YY_MAX_SHIFTREDUCE
)
break
;
fts5yy_pop_parser_stack
(
fts5yypParser
)
;
}
if
(
fts5yypParser
-
>
fts5yytos
<
=
fts5yypParser
-
>
fts5yystack
|
|
fts5yymajor
=
=
0
)
{
fts5yy_destructor
(
fts5yypParser
(
fts5YYCODETYPE
)
fts5yymajor
&
fts5yyminorunion
)
;
fts5yy_parse_failed
(
fts5yypParser
)
;
#
ifndef
fts5YYNOERRORRECOVERY
fts5yypParser
-
>
fts5yyerrcnt
=
-
1
;
#
endif
fts5yymajor
=
fts5YYNOCODE
;
}
else
if
(
fts5yymx
!
=
fts5YYERRORSYMBOL
)
{
fts5yy_shift
(
fts5yypParser
fts5yyact
fts5YYERRORSYMBOL
fts5yyminor
)
;
}
}
fts5yypParser
-
>
fts5yyerrcnt
=
3
;
fts5yyerrorhit
=
1
;
if
(
fts5yymajor
=
=
fts5YYNOCODE
)
break
;
fts5yyact
=
fts5yypParser
-
>
fts5yytos
-
>
stateno
;
#
elif
defined
(
fts5YYNOERRORRECOVERY
)
fts5yy_syntax_error
(
fts5yypParser
fts5yymajor
fts5yyminor
)
;
fts5yy_destructor
(
fts5yypParser
(
fts5YYCODETYPE
)
fts5yymajor
&
fts5yyminorunion
)
;
break
;
#
else
if
(
fts5yypParser
-
>
fts5yyerrcnt
<
=
0
)
{
fts5yy_syntax_error
(
fts5yypParser
fts5yymajor
fts5yyminor
)
;
}
fts5yypParser
-
>
fts5yyerrcnt
=
3
;
fts5yy_destructor
(
fts5yypParser
(
fts5YYCODETYPE
)
fts5yymajor
&
fts5yyminorunion
)
;
if
(
fts5yyendofinput
)
{
fts5yy_parse_failed
(
fts5yypParser
)
;
#
ifndef
fts5YYNOERRORRECOVERY
fts5yypParser
-
>
fts5yyerrcnt
=
-
1
;
#
endif
}
break
;
#
endif
}
}
#
ifndef
NDEBUG
if
(
fts5yyTraceFILE
)
{
fts5yyStackEntry
*
i
;
char
cDiv
=
'
[
'
;
fprintf
(
fts5yyTraceFILE
"
%
sReturn
.
Stack
=
"
fts5yyTracePrompt
)
;
for
(
i
=
&
fts5yypParser
-
>
fts5yystack
[
1
]
;
i
<
=
fts5yypParser
-
>
fts5yytos
;
i
+
+
)
{
fprintf
(
fts5yyTraceFILE
"
%
c
%
s
"
cDiv
fts5yyTokenName
[
i
-
>
major
]
)
;
cDiv
=
'
'
;
}
fprintf
(
fts5yyTraceFILE
"
]
\
n
"
)
;
}
#
endif
return
;
}
static
int
sqlite3Fts5ParserFallback
(
int
iToken
)
{
#
ifdef
fts5YYFALLBACK
assert
(
iToken
<
(
int
)
(
sizeof
(
fts5yyFallback
)
/
sizeof
(
fts5yyFallback
[
0
]
)
)
)
;
return
fts5yyFallback
[
iToken
]
;
#
else
(
void
)
iToken
;
return
0
;
#
endif
}
#
line
1
"
fts5_aux
.
c
"
#
include
<
math
.
h
>
typedef
struct
CInstIter
CInstIter
;
struct
CInstIter
{
const
Fts5ExtensionApi
*
pApi
;
Fts5Context
*
pFts
;
int
iCol
;
int
iInst
;
int
nInst
;
int
iStart
;
int
iEnd
;
}
;
static
int
fts5CInstIterNext
(
CInstIter
*
pIter
)
{
int
rc
=
SQLITE_OK
;
pIter
-
>
iStart
=
-
1
;
pIter
-
>
iEnd
=
-
1
;
while
(
rc
=
=
SQLITE_OK
&
&
pIter
-
>
iInst
<
pIter
-
>
nInst
)
{
int
ip
;
int
ic
;
int
io
;
rc
=
pIter
-
>
pApi
-
>
xInst
(
pIter
-
>
pFts
pIter
-
>
iInst
&
ip
&
ic
&
io
)
;
if
(
rc
=
=
SQLITE_OK
)
{
if
(
ic
=
=
pIter
-
>
iCol
)
{
int
iEnd
=
io
-
1
+
pIter
-
>
pApi
-
>
xPhraseSize
(
pIter
-
>
pFts
ip
)
;
if
(
pIter
-
>
iStart
<
0
)
{
pIter
-
>
iStart
=
io
;
pIter
-
>
iEnd
=
iEnd
;
}
else
if
(
io
<
=
pIter
-
>
iEnd
)
{
if
(
iEnd
>
pIter
-
>
iEnd
)
pIter
-
>
iEnd
=
iEnd
;
}
else
{
break
;
}
}
pIter
-
>
iInst
+
+
;
}
}
return
rc
;
}
static
int
fts5CInstIterInit
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
int
iCol
CInstIter
*
pIter
)
{
int
rc
;
memset
(
pIter
0
sizeof
(
CInstIter
)
)
;
pIter
-
>
pApi
=
pApi
;
pIter
-
>
pFts
=
pFts
;
pIter
-
>
iCol
=
iCol
;
rc
=
pApi
-
>
xInstCount
(
pFts
&
pIter
-
>
nInst
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5CInstIterNext
(
pIter
)
;
}
return
rc
;
}
typedef
struct
HighlightContext
HighlightContext
;
struct
HighlightContext
{
int
iRangeStart
;
int
iRangeEnd
;
const
char
*
zOpen
;
const
char
*
zClose
;
const
char
*
zIn
;
int
nIn
;
CInstIter
iter
;
int
iPos
;
int
iOff
;
int
bOpen
;
char
*
zOut
;
}
;
static
void
fts5HighlightAppend
(
int
*
pRc
HighlightContext
*
p
const
char
*
z
int
n
)
{
if
(
*
pRc
=
=
SQLITE_OK
&
&
z
)
{
if
(
n
<
0
)
n
=
(
int
)
strlen
(
z
)
;
p
-
>
zOut
=
sqlite3_mprintf
(
"
%
z
%
.
*
s
"
p
-
>
zOut
n
z
)
;
if
(
p
-
>
zOut
=
=
0
)
*
pRc
=
SQLITE_NOMEM
;
}
}
static
int
fts5HighlightCb
(
void
*
pContext
int
tflags
const
char
*
pToken
int
nToken
int
iStartOff
int
iEndOff
)
{
HighlightContext
*
p
=
(
HighlightContext
*
)
pContext
;
int
rc
=
SQLITE_OK
;
int
iPos
;
UNUSED_PARAM2
(
pToken
nToken
)
;
if
(
tflags
&
FTS5_TOKEN_COLOCATED
)
return
SQLITE_OK
;
iPos
=
p
-
>
iPos
+
+
;
if
(
p
-
>
iRangeEnd
>
=
0
)
{
if
(
iPos
<
p
-
>
iRangeStart
|
|
iPos
>
p
-
>
iRangeEnd
)
return
SQLITE_OK
;
if
(
p
-
>
iRangeStart
&
&
iPos
=
=
p
-
>
iRangeStart
)
p
-
>
iOff
=
iStartOff
;
}
if
(
p
-
>
bOpen
&
&
(
iPos
<
=
p
-
>
iter
.
iStart
|
|
p
-
>
iter
.
iStart
<
0
)
&
&
iStartOff
>
p
-
>
iOff
)
{
fts5HighlightAppend
(
&
rc
p
p
-
>
zClose
-
1
)
;
p
-
>
bOpen
=
0
;
}
if
(
iPos
=
=
p
-
>
iter
.
iStart
&
&
p
-
>
bOpen
=
=
0
)
{
fts5HighlightAppend
(
&
rc
p
&
p
-
>
zIn
[
p
-
>
iOff
]
iStartOff
-
p
-
>
iOff
)
;
fts5HighlightAppend
(
&
rc
p
p
-
>
zOpen
-
1
)
;
p
-
>
iOff
=
iStartOff
;
p
-
>
bOpen
=
1
;
}
if
(
iPos
=
=
p
-
>
iter
.
iEnd
)
{
if
(
p
-
>
bOpen
=
=
0
)
{
assert
(
p
-
>
iRangeEnd
>
=
0
)
;
fts5HighlightAppend
(
&
rc
p
p
-
>
zOpen
-
1
)
;
p
-
>
bOpen
=
1
;
}
fts5HighlightAppend
(
&
rc
p
&
p
-
>
zIn
[
p
-
>
iOff
]
iEndOff
-
p
-
>
iOff
)
;
p
-
>
iOff
=
iEndOff
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5CInstIterNext
(
&
p
-
>
iter
)
;
}
}
if
(
iPos
=
=
p
-
>
iRangeEnd
)
{
if
(
p
-
>
bOpen
)
{
if
(
p
-
>
iter
.
iStart
>
=
0
&
&
iPos
>
=
p
-
>
iter
.
iStart
)
{
fts5HighlightAppend
(
&
rc
p
&
p
-
>
zIn
[
p
-
>
iOff
]
iEndOff
-
p
-
>
iOff
)
;
p
-
>
iOff
=
iEndOff
;
}
fts5HighlightAppend
(
&
rc
p
p
-
>
zClose
-
1
)
;
p
-
>
bOpen
=
0
;
}
fts5HighlightAppend
(
&
rc
p
&
p
-
>
zIn
[
p
-
>
iOff
]
iEndOff
-
p
-
>
iOff
)
;
p
-
>
iOff
=
iEndOff
;
}
return
rc
;
}
static
void
fts5HighlightFunction
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
sqlite3_context
*
pCtx
int
nVal
sqlite3_value
*
*
apVal
)
{
HighlightContext
ctx
;
int
rc
;
int
iCol
;
if
(
nVal
!
=
3
)
{
const
char
*
zErr
=
"
wrong
number
of
arguments
to
function
highlight
(
)
"
;
sqlite3_result_error
(
pCtx
zErr
-
1
)
;
return
;
}
iCol
=
sqlite3_value_int
(
apVal
[
0
]
)
;
memset
(
&
ctx
0
sizeof
(
HighlightContext
)
)
;
ctx
.
zOpen
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
1
]
)
;
ctx
.
zClose
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
2
]
)
;
ctx
.
iRangeEnd
=
-
1
;
rc
=
pApi
-
>
xColumnText
(
pFts
iCol
&
ctx
.
zIn
&
ctx
.
nIn
)
;
if
(
rc
=
=
SQLITE_RANGE
)
{
sqlite3_result_text
(
pCtx
"
"
-
1
SQLITE_STATIC
)
;
rc
=
SQLITE_OK
;
}
else
if
(
ctx
.
zIn
)
{
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5CInstIterInit
(
pApi
pFts
iCol
&
ctx
.
iter
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
pApi
-
>
xColumnLocale
(
pFts
iCol
&
pLoc
&
nLoc
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
pApi
-
>
xTokenize_v2
(
pFts
ctx
.
zIn
ctx
.
nIn
pLoc
nLoc
(
void
*
)
&
ctx
fts5HighlightCb
)
;
}
if
(
ctx
.
bOpen
)
{
fts5HighlightAppend
(
&
rc
&
ctx
ctx
.
zClose
-
1
)
;
}
fts5HighlightAppend
(
&
rc
&
ctx
&
ctx
.
zIn
[
ctx
.
iOff
]
ctx
.
nIn
-
ctx
.
iOff
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_result_text
(
pCtx
(
const
char
*
)
ctx
.
zOut
-
1
SQLITE_TRANSIENT
)
;
}
sqlite3_free
(
ctx
.
zOut
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_result_error_code
(
pCtx
rc
)
;
}
}
typedef
struct
Fts5SFinder
Fts5SFinder
;
struct
Fts5SFinder
{
int
iPos
;
int
nFirstAlloc
;
int
nFirst
;
int
*
aFirst
;
const
char
*
zDoc
;
}
;
static
int
fts5SentenceFinderAdd
(
Fts5SFinder
*
p
int
iAdd
)
{
if
(
p
-
>
nFirstAlloc
=
=
p
-
>
nFirst
)
{
int
nNew
=
p
-
>
nFirstAlloc
?
p
-
>
nFirstAlloc
*
2
:
64
;
int
*
aNew
;
aNew
=
(
int
*
)
sqlite3_realloc64
(
p
-
>
aFirst
nNew
*
sizeof
(
int
)
)
;
if
(
aNew
=
=
0
)
return
SQLITE_NOMEM
;
p
-
>
aFirst
=
aNew
;
p
-
>
nFirstAlloc
=
nNew
;
}
p
-
>
aFirst
[
p
-
>
nFirst
+
+
]
=
iAdd
;
return
SQLITE_OK
;
}
static
int
fts5SentenceFinderCb
(
void
*
pContext
int
tflags
const
char
*
pToken
int
nToken
int
iStartOff
int
iEndOff
)
{
int
rc
=
SQLITE_OK
;
UNUSED_PARAM2
(
pToken
nToken
)
;
UNUSED_PARAM
(
iEndOff
)
;
if
(
(
tflags
&
FTS5_TOKEN_COLOCATED
)
=
=
0
)
{
Fts5SFinder
*
p
=
(
Fts5SFinder
*
)
pContext
;
if
(
p
-
>
iPos
>
0
)
{
int
i
;
char
c
=
0
;
for
(
i
=
iStartOff
-
1
;
i
>
=
0
;
i
-
-
)
{
c
=
p
-
>
zDoc
[
i
]
;
if
(
c
!
=
'
'
&
&
c
!
=
'
\
t
'
&
&
c
!
=
'
\
n
'
&
&
c
!
=
'
\
r
'
)
break
;
}
if
(
i
!
=
iStartOff
-
1
&
&
(
c
=
=
'
.
'
|
|
c
=
=
'
:
'
)
)
{
rc
=
fts5SentenceFinderAdd
(
p
p
-
>
iPos
)
;
}
}
else
{
rc
=
fts5SentenceFinderAdd
(
p
0
)
;
}
p
-
>
iPos
+
+
;
}
return
rc
;
}
static
int
fts5SnippetScore
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
int
nDocsize
unsigned
char
*
aSeen
int
iCol
int
iPos
int
nToken
int
*
pnScore
int
*
piPos
)
{
int
rc
;
int
i
;
int
ip
=
0
;
int
ic
=
0
;
int
iOff
=
0
;
int
iFirst
=
-
1
;
int
nInst
;
int
nScore
=
0
;
int
iLast
=
0
;
sqlite3_int64
iEnd
=
(
sqlite3_int64
)
iPos
+
nToken
;
rc
=
pApi
-
>
xInstCount
(
pFts
&
nInst
)
;
for
(
i
=
0
;
i
<
nInst
&
&
rc
=
=
SQLITE_OK
;
i
+
+
)
{
rc
=
pApi
-
>
xInst
(
pFts
i
&
ip
&
ic
&
iOff
)
;
if
(
rc
=
=
SQLITE_OK
&
&
ic
=
=
iCol
&
&
iOff
>
=
iPos
&
&
iOff
<
iEnd
)
{
nScore
+
=
(
aSeen
[
ip
]
?
1
:
1000
)
;
aSeen
[
ip
]
=
1
;
if
(
iFirst
<
0
)
iFirst
=
iOff
;
iLast
=
iOff
+
pApi
-
>
xPhraseSize
(
pFts
ip
)
;
}
}
*
pnScore
=
nScore
;
if
(
piPos
)
{
sqlite3_int64
iAdj
=
iFirst
-
(
nToken
-
(
iLast
-
iFirst
)
)
/
2
;
if
(
(
iAdj
+
nToken
)
>
nDocsize
)
iAdj
=
nDocsize
-
nToken
;
if
(
iAdj
<
0
)
iAdj
=
0
;
*
piPos
=
(
int
)
iAdj
;
}
return
rc
;
}
static
const
char
*
fts5ValueToText
(
sqlite3_value
*
pVal
)
{
const
char
*
zRet
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
return
zRet
?
zRet
:
"
"
;
}
static
void
fts5SnippetFunction
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
sqlite3_context
*
pCtx
int
nVal
sqlite3_value
*
*
apVal
)
{
HighlightContext
ctx
;
int
rc
=
SQLITE_OK
;
int
iCol
;
const
char
*
zEllips
;
int
nToken
;
int
nInst
=
0
;
int
i
;
int
nPhrase
;
unsigned
char
*
aSeen
;
int
iBestCol
;
int
iBestStart
=
0
;
int
nBestScore
=
0
;
int
nColSize
=
0
;
Fts5SFinder
sFinder
;
int
nCol
;
if
(
nVal
!
=
5
)
{
const
char
*
zErr
=
"
wrong
number
of
arguments
to
function
snippet
(
)
"
;
sqlite3_result_error
(
pCtx
zErr
-
1
)
;
return
;
}
nCol
=
pApi
-
>
xColumnCount
(
pFts
)
;
memset
(
&
ctx
0
sizeof
(
HighlightContext
)
)
;
iCol
=
sqlite3_value_int
(
apVal
[
0
]
)
;
ctx
.
zOpen
=
fts5ValueToText
(
apVal
[
1
]
)
;
ctx
.
zClose
=
fts5ValueToText
(
apVal
[
2
]
)
;
ctx
.
iRangeEnd
=
-
1
;
zEllips
=
fts5ValueToText
(
apVal
[
3
]
)
;
nToken
=
sqlite3_value_int
(
apVal
[
4
]
)
;
iBestCol
=
(
iCol
>
=
0
?
iCol
:
0
)
;
nPhrase
=
pApi
-
>
xPhraseCount
(
pFts
)
;
aSeen
=
sqlite3_malloc
(
nPhrase
)
;
if
(
aSeen
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
pApi
-
>
xInstCount
(
pFts
&
nInst
)
;
}
memset
(
&
sFinder
0
sizeof
(
Fts5SFinder
)
)
;
for
(
i
=
0
;
i
<
nCol
;
i
+
+
)
{
if
(
iCol
<
0
|
|
iCol
=
=
i
)
{
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
int
nDoc
;
int
nDocsize
;
int
ii
;
sFinder
.
iPos
=
0
;
sFinder
.
nFirst
=
0
;
rc
=
pApi
-
>
xColumnText
(
pFts
i
&
sFinder
.
zDoc
&
nDoc
)
;
if
(
rc
!
=
SQLITE_OK
)
break
;
rc
=
pApi
-
>
xColumnLocale
(
pFts
i
&
pLoc
&
nLoc
)
;
if
(
rc
!
=
SQLITE_OK
)
break
;
rc
=
pApi
-
>
xTokenize_v2
(
pFts
sFinder
.
zDoc
nDoc
pLoc
nLoc
(
void
*
)
&
sFinder
fts5SentenceFinderCb
)
;
if
(
rc
!
=
SQLITE_OK
)
break
;
rc
=
pApi
-
>
xColumnSize
(
pFts
i
&
nDocsize
)
;
if
(
rc
!
=
SQLITE_OK
)
break
;
for
(
ii
=
0
;
rc
=
=
SQLITE_OK
&
&
ii
<
nInst
;
ii
+
+
)
{
int
ip
ic
io
;
int
iAdj
;
int
nScore
;
int
jj
;
rc
=
pApi
-
>
xInst
(
pFts
ii
&
ip
&
ic
&
io
)
;
if
(
ic
!
=
i
)
continue
;
if
(
io
>
nDocsize
)
rc
=
FTS5_CORRUPT
;
if
(
rc
!
=
SQLITE_OK
)
continue
;
memset
(
aSeen
0
nPhrase
)
;
rc
=
fts5SnippetScore
(
pApi
pFts
nDocsize
aSeen
i
io
nToken
&
nScore
&
iAdj
)
;
if
(
rc
=
=
SQLITE_OK
&
&
nScore
>
nBestScore
)
{
nBestScore
=
nScore
;
iBestCol
=
i
;
iBestStart
=
iAdj
;
nColSize
=
nDocsize
;
}
if
(
rc
=
=
SQLITE_OK
&
&
sFinder
.
nFirst
&
&
nDocsize
>
nToken
)
{
for
(
jj
=
0
;
jj
<
(
sFinder
.
nFirst
-
1
)
;
jj
+
+
)
{
if
(
sFinder
.
aFirst
[
jj
+
1
]
>
io
)
break
;
}
if
(
sFinder
.
aFirst
[
jj
]
<
io
)
{
memset
(
aSeen
0
nPhrase
)
;
rc
=
fts5SnippetScore
(
pApi
pFts
nDocsize
aSeen
i
sFinder
.
aFirst
[
jj
]
nToken
&
nScore
0
)
;
nScore
+
=
(
sFinder
.
aFirst
[
jj
]
=
=
0
?
120
:
100
)
;
if
(
rc
=
=
SQLITE_OK
&
&
nScore
>
nBestScore
)
{
nBestScore
=
nScore
;
iBestCol
=
i
;
iBestStart
=
sFinder
.
aFirst
[
jj
]
;
nColSize
=
nDocsize
;
}
}
}
}
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
pApi
-
>
xColumnText
(
pFts
iBestCol
&
ctx
.
zIn
&
ctx
.
nIn
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
nColSize
=
=
0
)
{
rc
=
pApi
-
>
xColumnSize
(
pFts
iBestCol
&
nColSize
)
;
}
if
(
ctx
.
zIn
)
{
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5CInstIterInit
(
pApi
pFts
iBestCol
&
ctx
.
iter
)
;
}
ctx
.
iRangeStart
=
iBestStart
;
ctx
.
iRangeEnd
=
iBestStart
+
nToken
-
1
;
if
(
iBestStart
>
0
)
{
fts5HighlightAppend
(
&
rc
&
ctx
zEllips
-
1
)
;
}
while
(
ctx
.
iter
.
iStart
>
=
0
&
&
ctx
.
iter
.
iStart
<
iBestStart
&
&
rc
=
=
SQLITE_OK
)
{
rc
=
fts5CInstIterNext
(
&
ctx
.
iter
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
pApi
-
>
xColumnLocale
(
pFts
iBestCol
&
pLoc
&
nLoc
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
pApi
-
>
xTokenize_v2
(
pFts
ctx
.
zIn
ctx
.
nIn
pLoc
nLoc
(
void
*
)
&
ctx
fts5HighlightCb
)
;
}
if
(
ctx
.
bOpen
)
{
fts5HighlightAppend
(
&
rc
&
ctx
ctx
.
zClose
-
1
)
;
}
if
(
ctx
.
iRangeEnd
>
=
(
nColSize
-
1
)
)
{
fts5HighlightAppend
(
&
rc
&
ctx
&
ctx
.
zIn
[
ctx
.
iOff
]
ctx
.
nIn
-
ctx
.
iOff
)
;
}
else
{
fts5HighlightAppend
(
&
rc
&
ctx
zEllips
-
1
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_result_text
(
pCtx
(
const
char
*
)
ctx
.
zOut
-
1
SQLITE_TRANSIENT
)
;
}
else
{
sqlite3_result_error_code
(
pCtx
rc
)
;
}
sqlite3_free
(
ctx
.
zOut
)
;
sqlite3_free
(
aSeen
)
;
sqlite3_free
(
sFinder
.
aFirst
)
;
}
typedef
struct
Fts5Bm25Data
Fts5Bm25Data
;
struct
Fts5Bm25Data
{
int
nPhrase
;
double
avgdl
;
double
*
aIDF
;
double
*
aFreq
;
}
;
static
int
fts5CountCb
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
void
*
pUserData
)
{
sqlite3_int64
*
pn
=
(
sqlite3_int64
*
)
pUserData
;
UNUSED_PARAM2
(
pApi
pFts
)
;
(
*
pn
)
+
+
;
return
SQLITE_OK
;
}
static
int
fts5Bm25GetData
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
Fts5Bm25Data
*
*
ppData
)
{
int
rc
=
SQLITE_OK
;
Fts5Bm25Data
*
p
;
p
=
(
Fts5Bm25Data
*
)
pApi
-
>
xGetAuxdata
(
pFts
0
)
;
if
(
p
=
=
0
)
{
int
nPhrase
;
sqlite3_int64
nRow
=
0
;
sqlite3_int64
nToken
=
0
;
sqlite3_int64
nByte
;
int
i
;
nPhrase
=
pApi
-
>
xPhraseCount
(
pFts
)
;
nByte
=
sizeof
(
Fts5Bm25Data
)
+
nPhrase
*
2
*
sizeof
(
double
)
;
p
=
(
Fts5Bm25Data
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
p
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
memset
(
p
0
(
size_t
)
nByte
)
;
p
-
>
nPhrase
=
nPhrase
;
p
-
>
aIDF
=
(
double
*
)
&
p
[
1
]
;
p
-
>
aFreq
=
&
p
-
>
aIDF
[
nPhrase
]
;
}
if
(
rc
=
=
SQLITE_OK
)
rc
=
pApi
-
>
xRowCount
(
pFts
&
nRow
)
;
assert
(
rc
!
=
SQLITE_OK
|
|
nRow
>
0
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
pApi
-
>
xColumnTotalSize
(
pFts
-
1
&
nToken
)
;
if
(
rc
=
=
SQLITE_OK
)
p
-
>
avgdl
=
(
double
)
nToken
/
(
double
)
nRow
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nPhrase
;
i
+
+
)
{
sqlite3_int64
nHit
=
0
;
rc
=
pApi
-
>
xQueryPhrase
(
pFts
i
(
void
*
)
&
nHit
fts5CountCb
)
;
if
(
rc
=
=
SQLITE_OK
)
{
double
idf
=
log
(
(
nRow
-
nHit
+
0
.
5
)
/
(
nHit
+
0
.
5
)
)
;
if
(
idf
<
=
0
.
0
)
idf
=
1e
-
6
;
p
-
>
aIDF
[
i
]
=
idf
;
}
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_free
(
p
)
;
}
else
{
rc
=
pApi
-
>
xSetAuxdata
(
pFts
p
sqlite3_free
)
;
}
if
(
rc
!
=
SQLITE_OK
)
p
=
0
;
}
*
ppData
=
p
;
return
rc
;
}
static
void
fts5Bm25Function
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
sqlite3_context
*
pCtx
int
nVal
sqlite3_value
*
*
apVal
)
{
const
double
k1
=
1
.
2
;
const
double
b
=
0
.
75
;
int
rc
;
double
score
=
0
.
0
;
Fts5Bm25Data
*
pData
;
int
i
;
int
nInst
=
0
;
double
D
=
0
.
0
;
double
*
aFreq
=
0
;
rc
=
fts5Bm25GetData
(
pApi
pFts
&
pData
)
;
if
(
rc
=
=
SQLITE_OK
)
{
aFreq
=
pData
-
>
aFreq
;
memset
(
aFreq
0
sizeof
(
double
)
*
pData
-
>
nPhrase
)
;
rc
=
pApi
-
>
xInstCount
(
pFts
&
nInst
)
;
}
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nInst
;
i
+
+
)
{
int
ip
;
int
ic
;
int
io
;
rc
=
pApi
-
>
xInst
(
pFts
i
&
ip
&
ic
&
io
)
;
if
(
rc
=
=
SQLITE_OK
)
{
double
w
=
(
nVal
>
ic
)
?
sqlite3_value_double
(
apVal
[
ic
]
)
:
1
.
0
;
aFreq
[
ip
]
+
=
w
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
int
nTok
;
rc
=
pApi
-
>
xColumnSize
(
pFts
-
1
&
nTok
)
;
D
=
(
double
)
nTok
;
}
if
(
rc
=
=
SQLITE_OK
)
{
for
(
i
=
0
;
i
<
pData
-
>
nPhrase
;
i
+
+
)
{
score
+
=
pData
-
>
aIDF
[
i
]
*
(
(
aFreq
[
i
]
*
(
k1
+
1
.
0
)
)
/
(
aFreq
[
i
]
+
k1
*
(
1
-
b
+
b
*
D
/
pData
-
>
avgdl
)
)
)
;
}
sqlite3_result_double
(
pCtx
-
1
.
0
*
score
)
;
}
else
{
sqlite3_result_error_code
(
pCtx
rc
)
;
}
}
static
void
fts5GetLocaleFunction
(
const
Fts5ExtensionApi
*
pApi
Fts5Context
*
pFts
sqlite3_context
*
pCtx
int
nVal
sqlite3_value
*
*
apVal
)
{
int
iCol
=
0
;
int
eType
=
0
;
int
rc
=
SQLITE_OK
;
const
char
*
zLocale
=
0
;
int
nLocale
=
0
;
assert
(
pApi
-
>
iVersion
>
=
4
)
;
if
(
nVal
!
=
1
)
{
const
char
*
z
=
"
wrong
number
of
arguments
to
function
fts5_get_locale
(
)
"
;
sqlite3_result_error
(
pCtx
z
-
1
)
;
return
;
}
eType
=
sqlite3_value_numeric_type
(
apVal
[
0
]
)
;
if
(
eType
!
=
SQLITE_INTEGER
)
{
const
char
*
z
=
"
non
-
integer
argument
passed
to
function
fts5_get_locale
(
)
"
;
sqlite3_result_error
(
pCtx
z
-
1
)
;
return
;
}
iCol
=
sqlite3_value_int
(
apVal
[
0
]
)
;
if
(
iCol
<
0
|
|
iCol
>
=
pApi
-
>
xColumnCount
(
pFts
)
)
{
sqlite3_result_error_code
(
pCtx
SQLITE_RANGE
)
;
return
;
}
rc
=
pApi
-
>
xColumnLocale
(
pFts
iCol
&
zLocale
&
nLocale
)
;
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_result_error_code
(
pCtx
rc
)
;
return
;
}
sqlite3_result_text
(
pCtx
zLocale
nLocale
SQLITE_TRANSIENT
)
;
}
static
int
sqlite3Fts5AuxInit
(
fts5_api
*
pApi
)
{
struct
Builtin
{
const
char
*
zFunc
;
void
*
pUserData
;
fts5_extension_function
xFunc
;
void
(
*
xDestroy
)
(
void
*
)
;
}
aBuiltin
[
]
=
{
{
"
snippet
"
0
fts5SnippetFunction
0
}
{
"
highlight
"
0
fts5HighlightFunction
0
}
{
"
bm25
"
0
fts5Bm25Function
0
}
{
"
fts5_get_locale
"
0
fts5GetLocaleFunction
0
}
}
;
int
rc
=
SQLITE_OK
;
int
i
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
ArraySize
(
aBuiltin
)
;
i
+
+
)
{
rc
=
pApi
-
>
xCreateFunction
(
pApi
aBuiltin
[
i
]
.
zFunc
aBuiltin
[
i
]
.
pUserData
aBuiltin
[
i
]
.
xFunc
aBuiltin
[
i
]
.
xDestroy
)
;
}
return
rc
;
}
#
line
1
"
fts5_buffer
.
c
"
static
int
sqlite3Fts5BufferSize
(
int
*
pRc
Fts5Buffer
*
pBuf
u32
nByte
)
{
if
(
(
u32
)
pBuf
-
>
nSpace
<
nByte
)
{
u64
nNew
=
pBuf
-
>
nSpace
?
pBuf
-
>
nSpace
:
64
;
u8
*
pNew
;
while
(
nNew
<
nByte
)
{
nNew
=
nNew
*
2
;
}
pNew
=
sqlite3_realloc64
(
pBuf
-
>
p
nNew
)
;
if
(
pNew
=
=
0
)
{
*
pRc
=
SQLITE_NOMEM
;
return
1
;
}
else
{
pBuf
-
>
nSpace
=
(
int
)
nNew
;
pBuf
-
>
p
=
pNew
;
}
}
return
0
;
}
static
void
sqlite3Fts5BufferAppendVarint
(
int
*
pRc
Fts5Buffer
*
pBuf
i64
iVal
)
{
if
(
fts5BufferGrow
(
pRc
pBuf
9
)
)
return
;
pBuf
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
iVal
)
;
}
static
void
sqlite3Fts5Put32
(
u8
*
aBuf
int
iVal
)
{
aBuf
[
0
]
=
(
iVal
>
>
24
)
&
0x00FF
;
aBuf
[
1
]
=
(
iVal
>
>
16
)
&
0x00FF
;
aBuf
[
2
]
=
(
iVal
>
>
8
)
&
0x00FF
;
aBuf
[
3
]
=
(
iVal
>
>
0
)
&
0x00FF
;
}
static
int
sqlite3Fts5Get32
(
const
u8
*
aBuf
)
{
return
(
int
)
(
(
(
(
u32
)
aBuf
[
0
]
)
<
<
24
)
+
(
aBuf
[
1
]
<
<
16
)
+
(
aBuf
[
2
]
<
<
8
)
+
aBuf
[
3
]
)
;
}
static
void
sqlite3Fts5BufferAppendBlob
(
int
*
pRc
Fts5Buffer
*
pBuf
u32
nData
const
u8
*
pData
)
{
if
(
nData
)
{
if
(
fts5BufferGrow
(
pRc
pBuf
nData
)
)
return
;
assert
(
pBuf
-
>
p
!
=
0
)
;
memcpy
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
pData
nData
)
;
pBuf
-
>
n
+
=
nData
;
}
}
static
void
sqlite3Fts5BufferAppendString
(
int
*
pRc
Fts5Buffer
*
pBuf
const
char
*
zStr
)
{
int
nStr
=
(
int
)
strlen
(
zStr
)
;
sqlite3Fts5BufferAppendBlob
(
pRc
pBuf
nStr
+
1
(
const
u8
*
)
zStr
)
;
pBuf
-
>
n
-
-
;
}
static
void
sqlite3Fts5BufferAppendPrintf
(
int
*
pRc
Fts5Buffer
*
pBuf
char
*
zFmt
.
.
.
)
{
if
(
*
pRc
=
=
SQLITE_OK
)
{
char
*
zTmp
;
va_list
ap
;
va_start
(
ap
zFmt
)
;
zTmp
=
sqlite3_vmprintf
(
zFmt
ap
)
;
va_end
(
ap
)
;
if
(
zTmp
=
=
0
)
{
*
pRc
=
SQLITE_NOMEM
;
}
else
{
sqlite3Fts5BufferAppendString
(
pRc
pBuf
zTmp
)
;
sqlite3_free
(
zTmp
)
;
}
}
}
static
char
*
sqlite3Fts5Mprintf
(
int
*
pRc
const
char
*
zFmt
.
.
.
)
{
char
*
zRet
=
0
;
if
(
*
pRc
=
=
SQLITE_OK
)
{
va_list
ap
;
va_start
(
ap
zFmt
)
;
zRet
=
sqlite3_vmprintf
(
zFmt
ap
)
;
va_end
(
ap
)
;
if
(
zRet
=
=
0
)
{
*
pRc
=
SQLITE_NOMEM
;
}
}
return
zRet
;
}
static
void
sqlite3Fts5BufferFree
(
Fts5Buffer
*
pBuf
)
{
sqlite3_free
(
pBuf
-
>
p
)
;
memset
(
pBuf
0
sizeof
(
Fts5Buffer
)
)
;
}
static
void
sqlite3Fts5BufferZero
(
Fts5Buffer
*
pBuf
)
{
pBuf
-
>
n
=
0
;
}
static
void
sqlite3Fts5BufferSet
(
int
*
pRc
Fts5Buffer
*
pBuf
int
nData
const
u8
*
pData
)
{
pBuf
-
>
n
=
0
;
sqlite3Fts5BufferAppendBlob
(
pRc
pBuf
nData
pData
)
;
}
static
int
sqlite3Fts5PoslistNext64
(
const
u8
*
a
int
n
int
*
pi
i64
*
piOff
)
{
int
i
=
*
pi
;
assert
(
a
!
=
0
|
|
i
=
=
0
)
;
if
(
i
>
=
n
)
{
*
piOff
=
-
1
;
return
1
;
}
else
{
i64
iOff
=
*
piOff
;
u32
iVal
;
assert
(
a
!
=
0
)
;
fts5FastGetVarint32
(
a
i
iVal
)
;
if
(
iVal
<
=
1
)
{
if
(
iVal
=
=
0
)
{
*
pi
=
i
;
return
0
;
}
fts5FastGetVarint32
(
a
i
iVal
)
;
iOff
=
(
(
i64
)
iVal
)
<
<
32
;
assert
(
iOff
>
=
0
)
;
fts5FastGetVarint32
(
a
i
iVal
)
;
if
(
iVal
<
2
)
{
*
piOff
=
-
1
;
return
1
;
}
*
piOff
=
iOff
+
(
(
iVal
-
2
)
&
0x7FFFFFFF
)
;
}
else
{
*
piOff
=
(
iOff
&
(
i64
)
0x7FFFFFFF
<
<
32
)
+
(
(
iOff
+
(
iVal
-
2
)
)
&
0x7FFFFFFF
)
;
}
*
pi
=
i
;
assert_nc
(
*
piOff
>
=
iOff
)
;
return
0
;
}
}
static
int
sqlite3Fts5PoslistReaderNext
(
Fts5PoslistReader
*
pIter
)
{
if
(
sqlite3Fts5PoslistNext64
(
pIter
-
>
a
pIter
-
>
n
&
pIter
-
>
i
&
pIter
-
>
iPos
)
)
{
pIter
-
>
bEof
=
1
;
}
return
pIter
-
>
bEof
;
}
static
int
sqlite3Fts5PoslistReaderInit
(
const
u8
*
a
int
n
Fts5PoslistReader
*
pIter
)
{
memset
(
pIter
0
sizeof
(
*
pIter
)
)
;
pIter
-
>
a
=
a
;
pIter
-
>
n
=
n
;
sqlite3Fts5PoslistReaderNext
(
pIter
)
;
return
pIter
-
>
bEof
;
}
static
void
sqlite3Fts5PoslistSafeAppend
(
Fts5Buffer
*
pBuf
i64
*
piPrev
i64
iPos
)
{
if
(
iPos
>
=
*
piPrev
)
{
static
const
i64
colmask
=
(
(
i64
)
(
0x7FFFFFFF
)
)
<
<
32
;
if
(
(
iPos
&
colmask
)
!
=
(
*
piPrev
&
colmask
)
)
{
pBuf
-
>
p
[
pBuf
-
>
n
+
+
]
=
1
;
pBuf
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
(
iPos
>
>
32
)
)
;
*
piPrev
=
(
iPos
&
colmask
)
;
}
pBuf
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
(
iPos
-
*
piPrev
)
+
2
)
;
*
piPrev
=
iPos
;
}
}
static
int
sqlite3Fts5PoslistWriterAppend
(
Fts5Buffer
*
pBuf
Fts5PoslistWriter
*
pWriter
i64
iPos
)
{
int
rc
=
0
;
if
(
fts5BufferGrow
(
&
rc
pBuf
5
+
5
+
5
)
)
return
rc
;
sqlite3Fts5PoslistSafeAppend
(
pBuf
&
pWriter
-
>
iPrev
iPos
)
;
return
SQLITE_OK
;
}
static
void
*
sqlite3Fts5MallocZero
(
int
*
pRc
sqlite3_int64
nByte
)
{
void
*
pRet
=
0
;
if
(
*
pRc
=
=
SQLITE_OK
)
{
pRet
=
sqlite3_malloc64
(
nByte
)
;
if
(
pRet
=
=
0
)
{
if
(
nByte
>
0
)
*
pRc
=
SQLITE_NOMEM
;
}
else
{
memset
(
pRet
0
(
size_t
)
nByte
)
;
}
}
return
pRet
;
}
static
char
*
sqlite3Fts5Strndup
(
int
*
pRc
const
char
*
pIn
int
nIn
)
{
char
*
zRet
=
0
;
if
(
*
pRc
=
=
SQLITE_OK
)
{
if
(
nIn
<
0
)
{
nIn
=
(
int
)
strlen
(
pIn
)
;
}
zRet
=
(
char
*
)
sqlite3_malloc
(
nIn
+
1
)
;
if
(
zRet
)
{
memcpy
(
zRet
pIn
nIn
)
;
zRet
[
nIn
]
=
'
\
0
'
;
}
else
{
*
pRc
=
SQLITE_NOMEM
;
}
}
return
zRet
;
}
static
int
sqlite3Fts5IsBareword
(
char
t
)
{
u8
aBareword
[
128
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
}
;
return
(
t
&
0x80
)
|
|
aBareword
[
(
int
)
t
]
;
}
typedef
struct
Fts5TermsetEntry
Fts5TermsetEntry
;
struct
Fts5TermsetEntry
{
char
*
pTerm
;
int
nTerm
;
int
iIdx
;
Fts5TermsetEntry
*
pNext
;
}
;
struct
Fts5Termset
{
Fts5TermsetEntry
*
apHash
[
512
]
;
}
;
static
int
sqlite3Fts5TermsetNew
(
Fts5Termset
*
*
pp
)
{
int
rc
=
SQLITE_OK
;
*
pp
=
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5Termset
)
)
;
return
rc
;
}
static
int
sqlite3Fts5TermsetAdd
(
Fts5Termset
*
p
int
iIdx
const
char
*
pTerm
int
nTerm
int
*
pbPresent
)
{
int
rc
=
SQLITE_OK
;
*
pbPresent
=
0
;
if
(
p
)
{
int
i
;
u32
hash
=
13
;
Fts5TermsetEntry
*
pEntry
;
for
(
i
=
nTerm
-
1
;
i
>
=
0
;
i
-
-
)
{
hash
=
(
hash
<
<
3
)
^
hash
^
pTerm
[
i
]
;
}
hash
=
(
hash
<
<
3
)
^
hash
^
iIdx
;
hash
=
hash
%
ArraySize
(
p
-
>
apHash
)
;
for
(
pEntry
=
p
-
>
apHash
[
hash
]
;
pEntry
;
pEntry
=
pEntry
-
>
pNext
)
{
if
(
pEntry
-
>
iIdx
=
=
iIdx
&
&
pEntry
-
>
nTerm
=
=
nTerm
&
&
memcmp
(
pEntry
-
>
pTerm
pTerm
nTerm
)
=
=
0
)
{
*
pbPresent
=
1
;
break
;
}
}
if
(
pEntry
=
=
0
)
{
pEntry
=
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5TermsetEntry
)
+
nTerm
)
;
if
(
pEntry
)
{
pEntry
-
>
pTerm
=
(
char
*
)
&
pEntry
[
1
]
;
pEntry
-
>
nTerm
=
nTerm
;
pEntry
-
>
iIdx
=
iIdx
;
memcpy
(
pEntry
-
>
pTerm
pTerm
nTerm
)
;
pEntry
-
>
pNext
=
p
-
>
apHash
[
hash
]
;
p
-
>
apHash
[
hash
]
=
pEntry
;
}
}
}
return
rc
;
}
static
void
sqlite3Fts5TermsetFree
(
Fts5Termset
*
p
)
{
if
(
p
)
{
u32
i
;
for
(
i
=
0
;
i
<
ArraySize
(
p
-
>
apHash
)
;
i
+
+
)
{
Fts5TermsetEntry
*
pEntry
=
p
-
>
apHash
[
i
]
;
while
(
pEntry
)
{
Fts5TermsetEntry
*
pDel
=
pEntry
;
pEntry
=
pEntry
-
>
pNext
;
sqlite3_free
(
pDel
)
;
}
}
sqlite3_free
(
p
)
;
}
}
#
line
1
"
fts5_config
.
c
"
#
define
FTS5_DEFAULT_PAGE_SIZE
4050
#
define
FTS5_DEFAULT_AUTOMERGE
4
#
define
FTS5_DEFAULT_USERMERGE
4
#
define
FTS5_DEFAULT_CRISISMERGE
16
#
define
FTS5_DEFAULT_HASHSIZE
(
1024
*
1024
)
#
define
FTS5_DEFAULT_DELETE_AUTOMERGE
10
/
*
default
10
%
*
/
#
define
FTS5_MAX_PAGE_SIZE
(
64
*
1024
)
static
int
fts5_iswhitespace
(
char
x
)
{
return
(
x
=
=
'
'
)
;
}
static
int
fts5_isopenquote
(
char
x
)
{
return
(
x
=
=
'
"
'
|
|
x
=
=
'
\
'
'
|
|
x
=
=
'
[
'
|
|
x
=
=
'
'
)
;
}
static
const
char
*
fts5ConfigSkipWhitespace
(
const
char
*
pIn
)
{
const
char
*
p
=
pIn
;
if
(
p
)
{
while
(
fts5_iswhitespace
(
*
p
)
)
{
p
+
+
;
}
}
return
p
;
}
static
const
char
*
fts5ConfigSkipBareword
(
const
char
*
pIn
)
{
const
char
*
p
=
pIn
;
while
(
sqlite3Fts5IsBareword
(
*
p
)
)
p
+
+
;
if
(
p
=
=
pIn
)
p
=
0
;
return
p
;
}
static
int
fts5_isdigit
(
char
a
)
{
return
(
a
>
=
'
0
'
&
&
a
<
=
'
9
'
)
;
}
static
const
char
*
fts5ConfigSkipLiteral
(
const
char
*
pIn
)
{
const
char
*
p
=
pIn
;
switch
(
*
p
)
{
case
'
n
'
:
case
'
N
'
:
if
(
sqlite3_strnicmp
(
"
null
"
p
4
)
=
=
0
)
{
p
=
&
p
[
4
]
;
}
else
{
p
=
0
;
}
break
;
case
'
x
'
:
case
'
X
'
:
p
+
+
;
if
(
*
p
=
=
'
\
'
'
)
{
p
+
+
;
while
(
(
*
p
>
=
'
a
'
&
&
*
p
<
=
'
f
'
)
|
|
(
*
p
>
=
'
A
'
&
&
*
p
<
=
'
F
'
)
|
|
(
*
p
>
=
'
0
'
&
&
*
p
<
=
'
9
'
)
)
{
p
+
+
;
}
if
(
*
p
=
=
'
\
'
'
&
&
0
=
=
(
(
p
-
pIn
)
%
2
)
)
{
p
+
+
;
}
else
{
p
=
0
;
}
}
else
{
p
=
0
;
}
break
;
case
'
\
'
'
:
p
+
+
;
while
(
p
)
{
if
(
*
p
=
=
'
\
'
'
)
{
p
+
+
;
if
(
*
p
!
=
'
\
'
'
)
break
;
}
p
+
+
;
if
(
*
p
=
=
0
)
p
=
0
;
}
break
;
default
:
if
(
*
p
=
=
'
+
'
|
|
*
p
=
=
'
-
'
)
p
+
+
;
while
(
fts5_isdigit
(
*
p
)
)
p
+
+
;
if
(
*
p
=
=
'
.
'
&
&
fts5_isdigit
(
p
[
1
]
)
)
{
p
+
=
2
;
while
(
fts5_isdigit
(
*
p
)
)
p
+
+
;
}
if
(
p
=
=
pIn
)
p
=
0
;
break
;
}
return
p
;
}
static
int
fts5Dequote
(
char
*
z
)
{
char
q
;
int
iIn
=
1
;
int
iOut
=
0
;
q
=
z
[
0
]
;
assert
(
q
=
=
'
[
'
|
|
q
=
=
'
\
'
'
|
|
q
=
=
'
"
'
|
|
q
=
=
'
'
)
;
if
(
q
=
=
'
[
'
)
q
=
'
]
'
;
while
(
z
[
iIn
]
)
{
if
(
z
[
iIn
]
=
=
q
)
{
if
(
z
[
iIn
+
1
]
!
=
q
)
{
iIn
+
+
;
break
;
}
else
{
iIn
+
=
2
;
z
[
iOut
+
+
]
=
q
;
}
}
else
{
z
[
iOut
+
+
]
=
z
[
iIn
+
+
]
;
}
}
z
[
iOut
]
=
'
\
0
'
;
return
iIn
;
}
static
void
sqlite3Fts5Dequote
(
char
*
z
)
{
char
quote
;
assert
(
0
=
=
fts5_iswhitespace
(
z
[
0
]
)
)
;
quote
=
z
[
0
]
;
if
(
quote
=
=
'
[
'
|
|
quote
=
=
'
\
'
'
|
|
quote
=
=
'
"
'
|
|
quote
=
=
'
'
)
{
fts5Dequote
(
z
)
;
}
}
struct
Fts5Enum
{
const
char
*
zName
;
int
eVal
;
}
;
typedef
struct
Fts5Enum
Fts5Enum
;
static
int
fts5ConfigSetEnum
(
const
Fts5Enum
*
aEnum
const
char
*
zEnum
int
*
peVal
)
{
int
nEnum
=
(
int
)
strlen
(
zEnum
)
;
int
i
;
int
iVal
=
-
1
;
for
(
i
=
0
;
aEnum
[
i
]
.
zName
;
i
+
+
)
{
if
(
sqlite3_strnicmp
(
aEnum
[
i
]
.
zName
zEnum
nEnum
)
=
=
0
)
{
if
(
iVal
>
=
0
)
return
SQLITE_ERROR
;
iVal
=
aEnum
[
i
]
.
eVal
;
}
}
*
peVal
=
iVal
;
return
iVal
<
0
?
SQLITE_ERROR
:
SQLITE_OK
;
}
static
int
fts5ConfigParseSpecial
(
Fts5Config
*
pConfig
const
char
*
zCmd
const
char
*
zArg
char
*
*
pzErr
)
{
int
rc
=
SQLITE_OK
;
int
nCmd
=
(
int
)
strlen
(
zCmd
)
;
if
(
sqlite3_strnicmp
(
"
prefix
"
zCmd
nCmd
)
=
=
0
)
{
const
int
nByte
=
sizeof
(
int
)
*
FTS5_MAX_PREFIX_INDEXES
;
const
char
*
p
;
int
bFirst
=
1
;
if
(
pConfig
-
>
aPrefix
=
=
0
)
{
pConfig
-
>
aPrefix
=
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
if
(
rc
)
return
rc
;
}
p
=
zArg
;
while
(
1
)
{
int
nPre
=
0
;
while
(
p
[
0
]
=
=
'
'
)
p
+
+
;
if
(
bFirst
=
=
0
&
&
p
[
0
]
=
=
'
'
)
{
p
+
+
;
while
(
p
[
0
]
=
=
'
'
)
p
+
+
;
}
else
if
(
p
[
0
]
=
=
'
\
0
'
)
{
break
;
}
if
(
p
[
0
]
<
'
0
'
|
|
p
[
0
]
>
'
9
'
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
prefix
=
.
.
.
directive
"
)
;
rc
=
SQLITE_ERROR
;
break
;
}
if
(
pConfig
-
>
nPrefix
=
=
FTS5_MAX_PREFIX_INDEXES
)
{
*
pzErr
=
sqlite3_mprintf
(
"
too
many
prefix
indexes
(
max
%
d
)
"
FTS5_MAX_PREFIX_INDEXES
)
;
rc
=
SQLITE_ERROR
;
break
;
}
while
(
p
[
0
]
>
=
'
0
'
&
&
p
[
0
]
<
=
'
9
'
&
&
nPre
<
1000
)
{
nPre
=
nPre
*
10
+
(
p
[
0
]
-
'
0
'
)
;
p
+
+
;
}
if
(
nPre
<
=
0
|
|
nPre
>
=
1000
)
{
*
pzErr
=
sqlite3_mprintf
(
"
prefix
length
out
of
range
(
max
999
)
"
)
;
rc
=
SQLITE_ERROR
;
break
;
}
pConfig
-
>
aPrefix
[
pConfig
-
>
nPrefix
]
=
nPre
;
pConfig
-
>
nPrefix
+
+
;
bFirst
=
0
;
}
assert
(
pConfig
-
>
nPrefix
<
=
FTS5_MAX_PREFIX_INDEXES
)
;
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
tokenize
"
zCmd
nCmd
)
=
=
0
)
{
const
char
*
p
=
(
const
char
*
)
zArg
;
sqlite3_int64
nArg
=
strlen
(
zArg
)
+
1
;
char
*
*
azArg
=
sqlite3Fts5MallocZero
(
&
rc
(
sizeof
(
char
*
)
+
2
)
*
nArg
)
;
if
(
azArg
)
{
char
*
pSpace
=
(
char
*
)
&
azArg
[
nArg
]
;
if
(
pConfig
-
>
t
.
azArg
)
{
*
pzErr
=
sqlite3_mprintf
(
"
multiple
tokenize
=
.
.
.
directives
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
for
(
nArg
=
0
;
p
&
&
*
p
;
nArg
+
+
)
{
const
char
*
p2
=
fts5ConfigSkipWhitespace
(
p
)
;
if
(
*
p2
=
=
'
\
'
'
)
{
p
=
fts5ConfigSkipLiteral
(
p2
)
;
}
else
{
p
=
fts5ConfigSkipBareword
(
p2
)
;
}
if
(
p
)
{
memcpy
(
pSpace
p2
p
-
p2
)
;
azArg
[
nArg
]
=
pSpace
;
sqlite3Fts5Dequote
(
pSpace
)
;
pSpace
+
=
(
p
-
p2
)
+
1
;
p
=
fts5ConfigSkipWhitespace
(
p
)
;
}
}
if
(
p
=
=
0
)
{
*
pzErr
=
sqlite3_mprintf
(
"
parse
error
in
tokenize
directive
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
t
.
azArg
=
(
const
char
*
*
)
azArg
;
pConfig
-
>
t
.
nArg
=
nArg
;
azArg
=
0
;
}
}
}
sqlite3_free
(
azArg
)
;
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
content
"
zCmd
nCmd
)
=
=
0
)
{
if
(
pConfig
-
>
eContent
!
=
FTS5_CONTENT_NORMAL
)
{
*
pzErr
=
sqlite3_mprintf
(
"
multiple
content
=
.
.
.
directives
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
if
(
zArg
[
0
]
)
{
pConfig
-
>
eContent
=
FTS5_CONTENT_EXTERNAL
;
pConfig
-
>
zContent
=
sqlite3Fts5Mprintf
(
&
rc
"
%
Q
.
%
Q
"
pConfig
-
>
zDb
zArg
)
;
}
else
{
pConfig
-
>
eContent
=
FTS5_CONTENT_NONE
;
}
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
contentless_delete
"
zCmd
nCmd
)
=
=
0
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
)
|
|
zArg
[
1
]
!
=
'
\
0
'
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
contentless_delete
=
.
.
.
directive
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
bContentlessDelete
=
(
zArg
[
0
]
=
=
'
1
'
)
;
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
contentless_unindexed
"
zCmd
nCmd
)
=
=
0
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
)
|
|
zArg
[
1
]
!
=
'
\
0
'
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
contentless_delete
=
.
.
.
directive
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
bContentlessUnindexed
=
(
zArg
[
0
]
=
=
'
1
'
)
;
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
content_rowid
"
zCmd
nCmd
)
=
=
0
)
{
if
(
pConfig
-
>
zContentRowid
)
{
*
pzErr
=
sqlite3_mprintf
(
"
multiple
content_rowid
=
.
.
.
directives
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
zContentRowid
=
sqlite3Fts5Strndup
(
&
rc
zArg
-
1
)
;
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
columnsize
"
zCmd
nCmd
)
=
=
0
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
)
|
|
zArg
[
1
]
!
=
'
\
0
'
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
columnsize
=
.
.
.
directive
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
bColumnsize
=
(
zArg
[
0
]
=
=
'
1
'
)
;
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
locale
"
zCmd
nCmd
)
=
=
0
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
)
|
|
zArg
[
1
]
!
=
'
\
0
'
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
locale
=
.
.
.
directive
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
bLocale
=
(
zArg
[
0
]
=
=
'
1
'
)
;
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
detail
"
zCmd
nCmd
)
=
=
0
)
{
const
Fts5Enum
aDetail
[
]
=
{
{
"
none
"
FTS5_DETAIL_NONE
}
{
"
full
"
FTS5_DETAIL_FULL
}
{
"
columns
"
FTS5_DETAIL_COLUMNS
}
{
0
0
}
}
;
if
(
(
rc
=
fts5ConfigSetEnum
(
aDetail
zArg
&
pConfig
-
>
eDetail
)
)
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
detail
=
.
.
.
directive
"
)
;
}
return
rc
;
}
if
(
sqlite3_strnicmp
(
"
tokendata
"
zCmd
nCmd
)
=
=
0
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
)
|
|
zArg
[
1
]
!
=
'
\
0
'
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
tokendata
=
.
.
.
directive
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pConfig
-
>
bTokendata
=
(
zArg
[
0
]
=
=
'
1
'
)
;
}
return
rc
;
}
*
pzErr
=
sqlite3_mprintf
(
"
unrecognized
option
:
\
"
%
.
*
s
\
"
"
nCmd
zCmd
)
;
return
SQLITE_ERROR
;
}
static
const
char
*
fts5ConfigGobbleWord
(
int
*
pRc
const
char
*
zIn
char
*
*
pzOut
int
*
pbQuoted
)
{
const
char
*
zRet
=
0
;
sqlite3_int64
nIn
=
strlen
(
zIn
)
;
char
*
zOut
=
sqlite3_malloc64
(
nIn
+
1
)
;
assert
(
*
pRc
=
=
SQLITE_OK
)
;
*
pbQuoted
=
0
;
*
pzOut
=
0
;
if
(
zOut
=
=
0
)
{
*
pRc
=
SQLITE_NOMEM
;
}
else
{
memcpy
(
zOut
zIn
(
size_t
)
(
nIn
+
1
)
)
;
if
(
fts5_isopenquote
(
zOut
[
0
]
)
)
{
int
ii
=
fts5Dequote
(
zOut
)
;
zRet
=
&
zIn
[
ii
]
;
*
pbQuoted
=
1
;
}
else
{
zRet
=
fts5ConfigSkipBareword
(
zIn
)
;
if
(
zRet
)
{
zOut
[
zRet
-
zIn
]
=
'
\
0
'
;
}
}
}
if
(
zRet
=
=
0
)
{
sqlite3_free
(
zOut
)
;
}
else
{
*
pzOut
=
zOut
;
}
return
zRet
;
}
static
int
fts5ConfigParseColumn
(
Fts5Config
*
p
char
*
zCol
char
*
zArg
char
*
*
pzErr
int
*
pbUnindexed
)
{
int
rc
=
SQLITE_OK
;
if
(
0
=
=
sqlite3_stricmp
(
zCol
FTS5_RANK_NAME
)
|
|
0
=
=
sqlite3_stricmp
(
zCol
FTS5_ROWID_NAME
)
)
{
*
pzErr
=
sqlite3_mprintf
(
"
reserved
fts5
column
name
:
%
s
"
zCol
)
;
rc
=
SQLITE_ERROR
;
}
else
if
(
zArg
)
{
if
(
0
=
=
sqlite3_stricmp
(
zArg
"
unindexed
"
)
)
{
p
-
>
abUnindexed
[
p
-
>
nCol
]
=
1
;
*
pbUnindexed
=
1
;
}
else
{
*
pzErr
=
sqlite3_mprintf
(
"
unrecognized
column
option
:
%
s
"
zArg
)
;
rc
=
SQLITE_ERROR
;
}
}
p
-
>
azCol
[
p
-
>
nCol
+
+
]
=
zCol
;
return
rc
;
}
static
int
fts5ConfigMakeExprlist
(
Fts5Config
*
p
)
{
int
i
;
int
rc
=
SQLITE_OK
;
Fts5Buffer
buf
=
{
0
0
0
}
;
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
buf
"
T
.
%
Q
"
p
-
>
zContentRowid
)
;
if
(
p
-
>
eContent
!
=
FTS5_CONTENT_NONE
)
{
assert
(
p
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
|
|
p
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
p
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
;
for
(
i
=
0
;
i
<
p
-
>
nCol
;
i
+
+
)
{
if
(
p
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
)
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
buf
"
T
.
%
Q
"
p
-
>
azCol
[
i
]
)
;
}
else
if
(
p
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
p
-
>
abUnindexed
[
i
]
)
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
buf
"
T
.
c
%
d
"
i
)
;
}
else
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
buf
"
NULL
"
)
;
}
}
}
if
(
p
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
&
&
p
-
>
bLocale
)
{
for
(
i
=
0
;
i
<
p
-
>
nCol
;
i
+
+
)
{
if
(
p
-
>
abUnindexed
[
i
]
=
=
0
)
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
buf
"
T
.
l
%
d
"
i
)
;
}
else
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
buf
"
NULL
"
)
;
}
}
}
assert
(
p
-
>
zContentExprlist
=
=
0
)
;
p
-
>
zContentExprlist
=
(
char
*
)
buf
.
p
;
return
rc
;
}
static
int
sqlite3Fts5ConfigParse
(
Fts5Global
*
pGlobal
sqlite3
*
db
int
nArg
const
char
*
*
azArg
Fts5Config
*
*
ppOut
char
*
*
pzErr
)
{
int
rc
=
SQLITE_OK
;
Fts5Config
*
pRet
;
int
i
;
sqlite3_int64
nByte
;
int
bUnindexed
=
0
;
*
ppOut
=
pRet
=
(
Fts5Config
*
)
sqlite3_malloc
(
sizeof
(
Fts5Config
)
)
;
if
(
pRet
=
=
0
)
return
SQLITE_NOMEM
;
memset
(
pRet
0
sizeof
(
Fts5Config
)
)
;
pRet
-
>
pGlobal
=
pGlobal
;
pRet
-
>
db
=
db
;
pRet
-
>
iCookie
=
-
1
;
nByte
=
nArg
*
(
sizeof
(
char
*
)
+
sizeof
(
u8
)
)
;
pRet
-
>
azCol
=
(
char
*
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
pRet
-
>
abUnindexed
=
pRet
-
>
azCol
?
(
u8
*
)
&
pRet
-
>
azCol
[
nArg
]
:
0
;
pRet
-
>
zDb
=
sqlite3Fts5Strndup
(
&
rc
azArg
[
1
]
-
1
)
;
pRet
-
>
zName
=
sqlite3Fts5Strndup
(
&
rc
azArg
[
2
]
-
1
)
;
pRet
-
>
bColumnsize
=
1
;
pRet
-
>
eDetail
=
FTS5_DETAIL_FULL
;
#
ifdef
SQLITE_DEBUG
pRet
-
>
bPrefixIndex
=
1
;
#
endif
if
(
rc
=
=
SQLITE_OK
&
&
sqlite3_stricmp
(
pRet
-
>
zName
FTS5_RANK_NAME
)
=
=
0
)
{
*
pzErr
=
sqlite3_mprintf
(
"
reserved
fts5
table
name
:
%
s
"
pRet
-
>
zName
)
;
rc
=
SQLITE_ERROR
;
}
assert
(
(
pRet
-
>
abUnindexed
&
&
pRet
-
>
azCol
)
|
|
rc
!
=
SQLITE_OK
)
;
for
(
i
=
3
;
rc
=
=
SQLITE_OK
&
&
i
<
nArg
;
i
+
+
)
{
const
char
*
zOrig
=
azArg
[
i
]
;
const
char
*
z
;
char
*
zOne
=
0
;
char
*
zTwo
=
0
;
int
bOption
=
0
;
int
bMustBeCol
=
0
;
z
=
fts5ConfigGobbleWord
(
&
rc
zOrig
&
zOne
&
bMustBeCol
)
;
z
=
fts5ConfigSkipWhitespace
(
z
)
;
if
(
z
&
&
*
z
=
=
'
=
'
)
{
bOption
=
1
;
assert
(
zOne
!
=
0
)
;
z
+
+
;
if
(
bMustBeCol
)
z
=
0
;
}
z
=
fts5ConfigSkipWhitespace
(
z
)
;
if
(
z
&
&
z
[
0
]
)
{
int
bDummy
;
z
=
fts5ConfigGobbleWord
(
&
rc
z
&
zTwo
&
bDummy
)
;
if
(
z
&
&
z
[
0
]
)
z
=
0
;
}
if
(
rc
=
=
SQLITE_OK
)
{
if
(
z
=
=
0
)
{
*
pzErr
=
sqlite3_mprintf
(
"
parse
error
in
\
"
%
s
\
"
"
zOrig
)
;
rc
=
SQLITE_ERROR
;
}
else
{
if
(
bOption
)
{
rc
=
fts5ConfigParseSpecial
(
pRet
ALWAYS
(
zOne
)
?
zOne
:
"
"
zTwo
?
zTwo
:
"
"
pzErr
)
;
}
else
{
rc
=
fts5ConfigParseColumn
(
pRet
zOne
zTwo
pzErr
&
bUnindexed
)
;
zOne
=
0
;
}
}
}
sqlite3_free
(
zOne
)
;
sqlite3_free
(
zTwo
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pRet
-
>
bContentlessDelete
&
&
pRet
-
>
eContent
!
=
FTS5_CONTENT_NONE
)
{
*
pzErr
=
sqlite3_mprintf
(
"
contentless_delete
=
1
requires
a
contentless
table
"
)
;
rc
=
SQLITE_ERROR
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pRet
-
>
bContentlessDelete
&
&
pRet
-
>
bColumnsize
=
=
0
)
{
*
pzErr
=
sqlite3_mprintf
(
"
contentless_delete
=
1
is
incompatible
with
columnsize
=
0
"
)
;
rc
=
SQLITE_ERROR
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pRet
-
>
bContentlessUnindexed
&
&
pRet
-
>
eContent
!
=
FTS5_CONTENT_NONE
)
{
*
pzErr
=
sqlite3_mprintf
(
"
contentless_unindexed
=
1
requires
a
contentless
table
"
)
;
rc
=
SQLITE_ERROR
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pRet
-
>
zContent
=
=
0
)
{
const
char
*
zTail
=
0
;
assert
(
pRet
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pRet
-
>
eContent
=
=
FTS5_CONTENT_NONE
)
;
if
(
pRet
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
zTail
=
"
content
"
;
}
else
if
(
bUnindexed
&
&
pRet
-
>
bContentlessUnindexed
)
{
pRet
-
>
eContent
=
FTS5_CONTENT_UNINDEXED
;
zTail
=
"
content
"
;
}
else
if
(
pRet
-
>
bColumnsize
)
{
zTail
=
"
docsize
"
;
}
if
(
zTail
)
{
pRet
-
>
zContent
=
sqlite3Fts5Mprintf
(
&
rc
"
%
Q
.
'
%
q_
%
s
'
"
pRet
-
>
zDb
pRet
-
>
zName
zTail
)
;
}
}
if
(
rc
=
=
SQLITE_OK
&
&
pRet
-
>
zContentRowid
=
=
0
)
{
pRet
-
>
zContentRowid
=
sqlite3Fts5Strndup
(
&
rc
"
rowid
"
-
1
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5ConfigMakeExprlist
(
pRet
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3Fts5ConfigFree
(
pRet
)
;
*
ppOut
=
0
;
}
return
rc
;
}
static
void
sqlite3Fts5ConfigFree
(
Fts5Config
*
pConfig
)
{
if
(
pConfig
)
{
int
i
;
if
(
pConfig
-
>
t
.
pTok
)
{
if
(
pConfig
-
>
t
.
pApi1
)
{
pConfig
-
>
t
.
pApi1
-
>
xDelete
(
pConfig
-
>
t
.
pTok
)
;
}
else
{
pConfig
-
>
t
.
pApi2
-
>
xDelete
(
pConfig
-
>
t
.
pTok
)
;
}
}
sqlite3_free
(
(
char
*
)
pConfig
-
>
t
.
azArg
)
;
sqlite3_free
(
pConfig
-
>
zDb
)
;
sqlite3_free
(
pConfig
-
>
zName
)
;
for
(
i
=
0
;
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
sqlite3_free
(
pConfig
-
>
azCol
[
i
]
)
;
}
sqlite3_free
(
pConfig
-
>
azCol
)
;
sqlite3_free
(
pConfig
-
>
aPrefix
)
;
sqlite3_free
(
pConfig
-
>
zRank
)
;
sqlite3_free
(
pConfig
-
>
zRankArgs
)
;
sqlite3_free
(
pConfig
-
>
zContent
)
;
sqlite3_free
(
pConfig
-
>
zContentRowid
)
;
sqlite3_free
(
pConfig
-
>
zContentExprlist
)
;
sqlite3_free
(
pConfig
)
;
}
}
static
int
sqlite3Fts5ConfigDeclareVtab
(
Fts5Config
*
pConfig
)
{
int
i
;
int
rc
=
SQLITE_OK
;
char
*
zSql
;
zSql
=
sqlite3Fts5Mprintf
(
&
rc
"
CREATE
TABLE
x
(
"
)
;
for
(
i
=
0
;
zSql
&
&
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
const
char
*
zSep
=
(
i
=
=
0
?
"
"
:
"
"
)
;
zSql
=
sqlite3Fts5Mprintf
(
&
rc
"
%
z
%
s
%
Q
"
zSql
zSep
pConfig
-
>
azCol
[
i
]
)
;
}
zSql
=
sqlite3Fts5Mprintf
(
&
rc
"
%
z
%
Q
HIDDEN
%
s
HIDDEN
)
"
zSql
pConfig
-
>
zName
FTS5_RANK_NAME
)
;
assert
(
zSql
|
|
rc
=
=
SQLITE_NOMEM
)
;
if
(
zSql
)
{
rc
=
sqlite3_declare_vtab
(
pConfig
-
>
db
zSql
)
;
sqlite3_free
(
zSql
)
;
}
return
rc
;
}
static
int
sqlite3Fts5Tokenize
(
Fts5Config
*
pConfig
int
flags
const
char
*
pText
int
nText
void
*
pCtx
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
{
int
rc
=
SQLITE_OK
;
if
(
pText
)
{
if
(
pConfig
-
>
t
.
pTok
=
=
0
)
{
rc
=
sqlite3Fts5LoadTokenizer
(
pConfig
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
if
(
pConfig
-
>
t
.
pApi1
)
{
rc
=
pConfig
-
>
t
.
pApi1
-
>
xTokenize
(
pConfig
-
>
t
.
pTok
pCtx
flags
pText
nText
xToken
)
;
}
else
{
rc
=
pConfig
-
>
t
.
pApi2
-
>
xTokenize
(
pConfig
-
>
t
.
pTok
pCtx
flags
pText
nText
pConfig
-
>
t
.
pLocale
pConfig
-
>
t
.
nLocale
xToken
)
;
}
}
}
return
rc
;
}
static
const
char
*
fts5ConfigSkipArgs
(
const
char
*
pIn
)
{
const
char
*
p
=
pIn
;
while
(
1
)
{
p
=
fts5ConfigSkipWhitespace
(
p
)
;
p
=
fts5ConfigSkipLiteral
(
p
)
;
p
=
fts5ConfigSkipWhitespace
(
p
)
;
if
(
p
=
=
0
|
|
*
p
=
=
'
)
'
)
break
;
if
(
*
p
!
=
'
'
)
{
p
=
0
;
break
;
}
p
+
+
;
}
return
p
;
}
static
int
sqlite3Fts5ConfigParseRank
(
const
char
*
zIn
char
*
*
pzRank
char
*
*
pzRankArgs
)
{
const
char
*
p
=
zIn
;
const
char
*
pRank
;
char
*
zRank
=
0
;
char
*
zRankArgs
=
0
;
int
rc
=
SQLITE_OK
;
*
pzRank
=
0
;
*
pzRankArgs
=
0
;
if
(
p
=
=
0
)
{
rc
=
SQLITE_ERROR
;
}
else
{
p
=
fts5ConfigSkipWhitespace
(
p
)
;
pRank
=
p
;
p
=
fts5ConfigSkipBareword
(
p
)
;
if
(
p
)
{
zRank
=
sqlite3Fts5MallocZero
(
&
rc
1
+
p
-
pRank
)
;
if
(
zRank
)
memcpy
(
zRank
pRank
p
-
pRank
)
;
}
else
{
rc
=
SQLITE_ERROR
;
}
if
(
rc
=
=
SQLITE_OK
)
{
p
=
fts5ConfigSkipWhitespace
(
p
)
;
if
(
*
p
!
=
'
(
'
)
rc
=
SQLITE_ERROR
;
p
+
+
;
}
if
(
rc
=
=
SQLITE_OK
)
{
const
char
*
pArgs
;
p
=
fts5ConfigSkipWhitespace
(
p
)
;
pArgs
=
p
;
if
(
*
p
!
=
'
)
'
)
{
p
=
fts5ConfigSkipArgs
(
p
)
;
if
(
p
=
=
0
)
{
rc
=
SQLITE_ERROR
;
}
else
{
zRankArgs
=
sqlite3Fts5MallocZero
(
&
rc
1
+
p
-
pArgs
)
;
if
(
zRankArgs
)
memcpy
(
zRankArgs
pArgs
p
-
pArgs
)
;
}
}
}
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_free
(
zRank
)
;
assert
(
zRankArgs
=
=
0
)
;
}
else
{
*
pzRank
=
zRank
;
*
pzRankArgs
=
zRankArgs
;
}
return
rc
;
}
static
int
sqlite3Fts5ConfigSetValue
(
Fts5Config
*
pConfig
const
char
*
zKey
sqlite3_value
*
pVal
int
*
pbBadkey
)
{
int
rc
=
SQLITE_OK
;
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
pgsz
"
)
)
{
int
pgsz
=
0
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
pgsz
=
sqlite3_value_int
(
pVal
)
;
}
if
(
pgsz
<
32
|
|
pgsz
>
FTS5_MAX_PAGE_SIZE
)
{
*
pbBadkey
=
1
;
}
else
{
pConfig
-
>
pgsz
=
pgsz
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
hashsize
"
)
)
{
int
nHashSize
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
nHashSize
=
sqlite3_value_int
(
pVal
)
;
}
if
(
nHashSize
<
=
0
)
{
*
pbBadkey
=
1
;
}
else
{
pConfig
-
>
nHashSize
=
nHashSize
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
automerge
"
)
)
{
int
nAutomerge
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
nAutomerge
=
sqlite3_value_int
(
pVal
)
;
}
if
(
nAutomerge
<
0
|
|
nAutomerge
>
64
)
{
*
pbBadkey
=
1
;
}
else
{
if
(
nAutomerge
=
=
1
)
nAutomerge
=
FTS5_DEFAULT_AUTOMERGE
;
pConfig
-
>
nAutomerge
=
nAutomerge
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
usermerge
"
)
)
{
int
nUsermerge
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
nUsermerge
=
sqlite3_value_int
(
pVal
)
;
}
if
(
nUsermerge
<
2
|
|
nUsermerge
>
16
)
{
*
pbBadkey
=
1
;
}
else
{
pConfig
-
>
nUsermerge
=
nUsermerge
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
crisismerge
"
)
)
{
int
nCrisisMerge
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
nCrisisMerge
=
sqlite3_value_int
(
pVal
)
;
}
if
(
nCrisisMerge
<
0
)
{
*
pbBadkey
=
1
;
}
else
{
if
(
nCrisisMerge
<
=
1
)
nCrisisMerge
=
FTS5_DEFAULT_CRISISMERGE
;
if
(
nCrisisMerge
>
=
FTS5_MAX_SEGMENT
)
nCrisisMerge
=
FTS5_MAX_SEGMENT
-
1
;
pConfig
-
>
nCrisisMerge
=
nCrisisMerge
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
deletemerge
"
)
)
{
int
nVal
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
nVal
=
sqlite3_value_int
(
pVal
)
;
}
else
{
*
pbBadkey
=
1
;
}
if
(
nVal
<
0
)
nVal
=
FTS5_DEFAULT_DELETE_AUTOMERGE
;
if
(
nVal
>
100
)
nVal
=
0
;
pConfig
-
>
nDeleteMerge
=
nVal
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
rank
"
)
)
{
const
char
*
zIn
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
char
*
zRank
;
char
*
zRankArgs
;
rc
=
sqlite3Fts5ConfigParseRank
(
zIn
&
zRank
&
zRankArgs
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_free
(
pConfig
-
>
zRank
)
;
sqlite3_free
(
pConfig
-
>
zRankArgs
)
;
pConfig
-
>
zRank
=
zRank
;
pConfig
-
>
zRankArgs
=
zRankArgs
;
}
else
if
(
rc
=
=
SQLITE_ERROR
)
{
rc
=
SQLITE_OK
;
*
pbBadkey
=
1
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
secure
-
delete
"
)
)
{
int
bVal
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
bVal
=
sqlite3_value_int
(
pVal
)
;
}
if
(
bVal
<
0
)
{
*
pbBadkey
=
1
;
}
else
{
pConfig
-
>
bSecureDelete
=
(
bVal
?
1
:
0
)
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
zKey
"
insttoken
"
)
)
{
int
bVal
=
-
1
;
if
(
SQLITE_INTEGER
=
=
sqlite3_value_numeric_type
(
pVal
)
)
{
bVal
=
sqlite3_value_int
(
pVal
)
;
}
if
(
bVal
<
0
)
{
*
pbBadkey
=
1
;
}
else
{
pConfig
-
>
bPrefixInsttoken
=
(
bVal
?
1
:
0
)
;
}
}
else
{
*
pbBadkey
=
1
;
}
return
rc
;
}
static
int
sqlite3Fts5ConfigLoad
(
Fts5Config
*
pConfig
int
iCookie
)
{
const
char
*
zSelect
=
"
SELECT
k
v
FROM
%
Q
.
'
%
q_config
'
"
;
char
*
zSql
;
sqlite3_stmt
*
p
=
0
;
int
rc
=
SQLITE_OK
;
int
iVersion
=
0
;
pConfig
-
>
pgsz
=
FTS5_DEFAULT_PAGE_SIZE
;
pConfig
-
>
nAutomerge
=
FTS5_DEFAULT_AUTOMERGE
;
pConfig
-
>
nUsermerge
=
FTS5_DEFAULT_USERMERGE
;
pConfig
-
>
nCrisisMerge
=
FTS5_DEFAULT_CRISISMERGE
;
pConfig
-
>
nHashSize
=
FTS5_DEFAULT_HASHSIZE
;
pConfig
-
>
nDeleteMerge
=
FTS5_DEFAULT_DELETE_AUTOMERGE
;
zSql
=
sqlite3Fts5Mprintf
(
&
rc
zSelect
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
if
(
zSql
)
{
rc
=
sqlite3_prepare_v2
(
pConfig
-
>
db
zSql
-
1
&
p
0
)
;
sqlite3_free
(
zSql
)
;
}
assert
(
rc
=
=
SQLITE_OK
|
|
p
=
=
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
while
(
SQLITE_ROW
=
=
sqlite3_step
(
p
)
)
{
const
char
*
zK
=
(
const
char
*
)
sqlite3_column_text
(
p
0
)
;
sqlite3_value
*
pVal
=
sqlite3_column_value
(
p
1
)
;
if
(
0
=
=
sqlite3_stricmp
(
zK
"
version
"
)
)
{
iVersion
=
sqlite3_value_int
(
pVal
)
;
}
else
{
int
bDummy
=
0
;
sqlite3Fts5ConfigSetValue
(
pConfig
zK
pVal
&
bDummy
)
;
}
}
rc
=
sqlite3_finalize
(
p
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
iVersion
!
=
FTS5_CURRENT_VERSION
&
&
iVersion
!
=
FTS5_CURRENT_VERSION_SECUREDELETE
)
{
rc
=
SQLITE_ERROR
;
sqlite3Fts5ConfigErrmsg
(
pConfig
"
invalid
fts5
file
format
"
"
(
found
%
d
expected
%
d
or
%
d
)
-
run
'
rebuild
'
"
iVersion
FTS5_CURRENT_VERSION
FTS5_CURRENT_VERSION_SECUREDELETE
)
;
}
else
{
pConfig
-
>
iVersion
=
iVersion
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pConfig
-
>
iCookie
=
iCookie
;
}
return
rc
;
}
static
void
sqlite3Fts5ConfigErrmsg
(
Fts5Config
*
pConfig
const
char
*
zFmt
.
.
.
)
{
va_list
ap
;
char
*
zMsg
=
0
;
va_start
(
ap
zFmt
)
;
zMsg
=
sqlite3_vmprintf
(
zFmt
ap
)
;
if
(
pConfig
-
>
pzErrmsg
)
{
assert
(
*
pConfig
-
>
pzErrmsg
=
=
0
)
;
*
pConfig
-
>
pzErrmsg
=
zMsg
;
}
else
{
sqlite3_free
(
zMsg
)
;
}
va_end
(
ap
)
;
}
#
line
1
"
fts5_expr
.
c
"
#
ifndef
SQLITE_FTS5_MAX_EXPR_DEPTH
#
define
SQLITE_FTS5_MAX_EXPR_DEPTH
256
#
endif
#
define
FTS5_EOF
0
#
define
FTS5_LARGEST_INT64
(
0xffffffff
|
(
(
(
i64
)
0x7fffffff
)
<
<
32
)
)
typedef
struct
Fts5ExprTerm
Fts5ExprTerm
;
static
void
*
sqlite3Fts5ParserAlloc
(
void
*
(
*
mallocProc
)
(
u64
)
)
;
static
void
sqlite3Fts5ParserFree
(
void
*
void
(
*
freeProc
)
(
void
*
)
)
;
static
void
sqlite3Fts5Parser
(
void
*
int
Fts5Token
Fts5Parse
*
)
;
#
ifndef
NDEBUG
#
include
<
stdio
.
h
>
static
void
sqlite3Fts5ParserTrace
(
FILE
*
char
*
)
;
#
endif
static
int
sqlite3Fts5ParserFallback
(
int
)
;
struct
Fts5Expr
{
Fts5Index
*
pIndex
;
Fts5Config
*
pConfig
;
Fts5ExprNode
*
pRoot
;
int
bDesc
;
int
nPhrase
;
Fts5ExprPhrase
*
*
apExprPhrase
;
}
;
struct
Fts5ExprNode
{
int
eType
;
int
bEof
;
int
bNomatch
;
int
iHeight
;
int
(
*
xNext
)
(
Fts5Expr
*
Fts5ExprNode
*
int
i64
)
;
i64
iRowid
;
Fts5ExprNearset
*
pNear
;
int
nChild
;
Fts5ExprNode
*
apChild
[
1
]
;
}
;
#
define
Fts5NodeIsString
(
p
)
(
(
p
)
-
>
eType
=
=
FTS5_TERM
|
|
(
p
)
-
>
eType
=
=
FTS5_STRING
)
#
define
fts5ExprNodeNext
(
a
b
c
d
)
(
b
)
-
>
xNext
(
(
a
)
(
b
)
(
c
)
(
d
)
)
struct
Fts5ExprTerm
{
u8
bPrefix
;
u8
bFirst
;
char
*
pTerm
;
int
nQueryTerm
;
int
nFullTerm
;
Fts5IndexIter
*
pIter
;
Fts5ExprTerm
*
pSynonym
;
}
;
struct
Fts5ExprPhrase
{
Fts5ExprNode
*
pNode
;
Fts5Buffer
poslist
;
int
nTerm
;
Fts5ExprTerm
aTerm
[
1
]
;
}
;
struct
Fts5ExprNearset
{
int
nNear
;
Fts5Colset
*
pColset
;
int
nPhrase
;
Fts5ExprPhrase
*
apPhrase
[
1
]
;
}
;
struct
Fts5Parse
{
Fts5Config
*
pConfig
;
char
*
zErr
;
int
rc
;
int
nPhrase
;
Fts5ExprPhrase
*
*
apPhrase
;
Fts5ExprNode
*
pExpr
;
int
bPhraseToAnd
;
}
;
#
ifndef
NDEBUG
static
void
assert_expr_depth_ok
(
int
rc
Fts5ExprNode
*
p
)
{
if
(
rc
=
=
SQLITE_OK
)
{
if
(
p
-
>
eType
=
=
FTS5_TERM
|
|
p
-
>
eType
=
=
FTS5_STRING
|
|
p
-
>
eType
=
=
0
)
{
assert
(
p
-
>
iHeight
=
=
0
)
;
}
else
{
int
ii
;
int
iMaxChild
=
0
;
for
(
ii
=
0
;
ii
<
p
-
>
nChild
;
ii
+
+
)
{
Fts5ExprNode
*
pChild
=
p
-
>
apChild
[
ii
]
;
iMaxChild
=
MAX
(
iMaxChild
pChild
-
>
iHeight
)
;
assert_expr_depth_ok
(
SQLITE_OK
pChild
)
;
}
assert
(
p
-
>
iHeight
=
=
iMaxChild
+
1
)
;
}
}
}
#
else
#
define
assert_expr_depth_ok
(
rc
p
)
#
endif
static
void
sqlite3Fts5ParseError
(
Fts5Parse
*
pParse
const
char
*
zFmt
.
.
.
)
{
va_list
ap
;
va_start
(
ap
zFmt
)
;
if
(
pParse
-
>
rc
=
=
SQLITE_OK
)
{
assert
(
pParse
-
>
zErr
=
=
0
)
;
pParse
-
>
zErr
=
sqlite3_vmprintf
(
zFmt
ap
)
;
pParse
-
>
rc
=
SQLITE_ERROR
;
}
va_end
(
ap
)
;
}
static
int
fts5ExprIsspace
(
char
t
)
{
return
t
=
=
'
'
|
|
t
=
=
'
\
t
'
|
|
t
=
=
'
\
n
'
|
|
t
=
=
'
\
r
'
;
}
static
int
fts5ExprGetToken
(
Fts5Parse
*
pParse
const
char
*
*
pz
Fts5Token
*
pToken
)
{
const
char
*
z
=
*
pz
;
int
tok
;
while
(
fts5ExprIsspace
(
*
z
)
)
z
+
+
;
pToken
-
>
p
=
z
;
pToken
-
>
n
=
1
;
switch
(
*
z
)
{
case
'
(
'
:
tok
=
FTS5_LP
;
break
;
case
'
)
'
:
tok
=
FTS5_RP
;
break
;
case
'
{
'
:
tok
=
FTS5_LCP
;
break
;
case
'
}
'
:
tok
=
FTS5_RCP
;
break
;
case
'
:
'
:
tok
=
FTS5_COLON
;
break
;
case
'
'
:
tok
=
FTS5_COMMA
;
break
;
case
'
+
'
:
tok
=
FTS5_PLUS
;
break
;
case
'
*
'
:
tok
=
FTS5_STAR
;
break
;
case
'
-
'
:
tok
=
FTS5_MINUS
;
break
;
case
'
^
'
:
tok
=
FTS5_CARET
;
break
;
case
'
\
0
'
:
tok
=
FTS5_EOF
;
break
;
case
'
"
'
:
{
const
char
*
z2
;
tok
=
FTS5_STRING
;
for
(
z2
=
&
z
[
1
]
;
1
;
z2
+
+
)
{
if
(
z2
[
0
]
=
=
'
"
'
)
{
z2
+
+
;
if
(
z2
[
0
]
!
=
'
"
'
)
break
;
}
if
(
z2
[
0
]
=
=
'
\
0
'
)
{
sqlite3Fts5ParseError
(
pParse
"
unterminated
string
"
)
;
return
FTS5_EOF
;
}
}
pToken
-
>
n
=
(
z2
-
z
)
;
break
;
}
default
:
{
const
char
*
z2
;
if
(
sqlite3Fts5IsBareword
(
z
[
0
]
)
=
=
0
)
{
sqlite3Fts5ParseError
(
pParse
"
fts5
:
syntax
error
near
\
"
%
.
1s
\
"
"
z
)
;
return
FTS5_EOF
;
}
tok
=
FTS5_STRING
;
for
(
z2
=
&
z
[
1
]
;
sqlite3Fts5IsBareword
(
*
z2
)
;
z2
+
+
)
;
pToken
-
>
n
=
(
z2
-
z
)
;
if
(
pToken
-
>
n
=
=
2
&
&
memcmp
(
pToken
-
>
p
"
OR
"
2
)
=
=
0
)
tok
=
FTS5_OR
;
if
(
pToken
-
>
n
=
=
3
&
&
memcmp
(
pToken
-
>
p
"
NOT
"
3
)
=
=
0
)
tok
=
FTS5_NOT
;
if
(
pToken
-
>
n
=
=
3
&
&
memcmp
(
pToken
-
>
p
"
AND
"
3
)
=
=
0
)
tok
=
FTS5_AND
;
break
;
}
}
*
pz
=
&
pToken
-
>
p
[
pToken
-
>
n
]
;
return
tok
;
}
static
void
*
fts5ParseAlloc
(
u64
t
)
{
return
sqlite3_malloc64
(
(
sqlite3_int64
)
t
)
;
}
static
void
fts5ParseFree
(
void
*
p
)
{
sqlite3_free
(
p
)
;
}
static
int
sqlite3Fts5ExprNew
(
Fts5Config
*
pConfig
int
bPhraseToAnd
int
iCol
const
char
*
zExpr
Fts5Expr
*
*
ppNew
char
*
*
pzErr
)
{
Fts5Parse
sParse
;
Fts5Token
token
;
const
char
*
z
=
zExpr
;
int
t
;
void
*
pEngine
;
Fts5Expr
*
pNew
;
*
ppNew
=
0
;
*
pzErr
=
0
;
memset
(
&
sParse
0
sizeof
(
sParse
)
)
;
sParse
.
bPhraseToAnd
=
bPhraseToAnd
;
pEngine
=
sqlite3Fts5ParserAlloc
(
fts5ParseAlloc
)
;
if
(
pEngine
=
=
0
)
{
return
SQLITE_NOMEM
;
}
sParse
.
pConfig
=
pConfig
;
do
{
t
=
fts5ExprGetToken
(
&
sParse
&
z
&
token
)
;
sqlite3Fts5Parser
(
pEngine
t
token
&
sParse
)
;
}
while
(
sParse
.
rc
=
=
SQLITE_OK
&
&
t
!
=
FTS5_EOF
)
;
sqlite3Fts5ParserFree
(
pEngine
fts5ParseFree
)
;
assert
(
sParse
.
pExpr
|
|
sParse
.
rc
!
=
SQLITE_OK
)
;
assert_expr_depth_ok
(
sParse
.
rc
sParse
.
pExpr
)
;
if
(
sParse
.
rc
=
=
SQLITE_OK
&
&
iCol
<
pConfig
-
>
nCol
)
{
int
n
=
sizeof
(
Fts5Colset
)
;
Fts5Colset
*
pColset
=
(
Fts5Colset
*
)
sqlite3Fts5MallocZero
(
&
sParse
.
rc
n
)
;
if
(
pColset
)
{
pColset
-
>
nCol
=
1
;
pColset
-
>
aiCol
[
0
]
=
iCol
;
sqlite3Fts5ParseSetColset
(
&
sParse
sParse
.
pExpr
pColset
)
;
}
}
assert
(
sParse
.
rc
!
=
SQLITE_OK
|
|
sParse
.
zErr
=
=
0
)
;
if
(
sParse
.
rc
=
=
SQLITE_OK
)
{
*
ppNew
=
pNew
=
sqlite3_malloc
(
sizeof
(
Fts5Expr
)
)
;
if
(
pNew
=
=
0
)
{
sParse
.
rc
=
SQLITE_NOMEM
;
sqlite3Fts5ParseNodeFree
(
sParse
.
pExpr
)
;
}
else
{
pNew
-
>
pRoot
=
sParse
.
pExpr
;
pNew
-
>
pIndex
=
0
;
pNew
-
>
pConfig
=
pConfig
;
pNew
-
>
apExprPhrase
=
sParse
.
apPhrase
;
pNew
-
>
nPhrase
=
sParse
.
nPhrase
;
pNew
-
>
bDesc
=
0
;
sParse
.
apPhrase
=
0
;
}
}
else
{
sqlite3Fts5ParseNodeFree
(
sParse
.
pExpr
)
;
}
sqlite3_free
(
sParse
.
apPhrase
)
;
if
(
0
=
=
*
pzErr
)
{
*
pzErr
=
sParse
.
zErr
;
}
else
{
sqlite3_free
(
sParse
.
zErr
)
;
}
return
sParse
.
rc
;
}
static
int
fts5ExprCountChar
(
const
char
*
z
int
nByte
)
{
int
nRet
=
0
;
int
ii
;
for
(
ii
=
0
;
ii
<
nByte
;
ii
+
+
)
{
if
(
(
z
[
ii
]
&
0xC0
)
!
=
0x80
)
nRet
+
+
;
}
return
nRet
;
}
static
int
sqlite3Fts5ExprPattern
(
Fts5Config
*
pConfig
int
bGlob
int
iCol
const
char
*
zText
Fts5Expr
*
*
pp
)
{
i64
nText
=
strlen
(
zText
)
;
char
*
zExpr
=
(
char
*
)
sqlite3_malloc64
(
nText
*
4
+
1
)
;
int
rc
=
SQLITE_OK
;
if
(
zExpr
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
char
aSpec
[
3
]
;
int
iOut
=
0
;
int
i
=
0
;
int
iFirst
=
0
;
if
(
bGlob
=
=
0
)
{
aSpec
[
0
]
=
'
_
'
;
aSpec
[
1
]
=
'
%
'
;
aSpec
[
2
]
=
0
;
}
else
{
aSpec
[
0
]
=
'
*
'
;
aSpec
[
1
]
=
'
?
'
;
aSpec
[
2
]
=
'
[
'
;
}
while
(
i
<
=
nText
)
{
if
(
i
=
=
nText
|
|
zText
[
i
]
=
=
aSpec
[
0
]
|
|
zText
[
i
]
=
=
aSpec
[
1
]
|
|
zText
[
i
]
=
=
aSpec
[
2
]
)
{
if
(
fts5ExprCountChar
(
&
zText
[
iFirst
]
i
-
iFirst
)
>
=
3
)
{
int
jj
;
zExpr
[
iOut
+
+
]
=
'
"
'
;
for
(
jj
=
iFirst
;
jj
<
i
;
jj
+
+
)
{
zExpr
[
iOut
+
+
]
=
zText
[
jj
]
;
if
(
zText
[
jj
]
=
=
'
"
'
)
zExpr
[
iOut
+
+
]
=
'
"
'
;
}
zExpr
[
iOut
+
+
]
=
'
"
'
;
zExpr
[
iOut
+
+
]
=
'
'
;
}
if
(
zText
[
i
]
=
=
aSpec
[
2
]
)
{
i
+
=
2
;
if
(
zText
[
i
-
1
]
=
=
'
^
'
)
i
+
+
;
while
(
i
<
nText
&
&
zText
[
i
]
!
=
'
]
'
)
i
+
+
;
}
iFirst
=
i
+
1
;
}
i
+
+
;
}
if
(
iOut
>
0
)
{
int
bAnd
=
0
;
if
(
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
)
{
bAnd
=
1
;
if
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
iCol
=
pConfig
-
>
nCol
;
}
}
zExpr
[
iOut
]
=
'
\
0
'
;
rc
=
sqlite3Fts5ExprNew
(
pConfig
bAnd
iCol
zExpr
pp
pConfig
-
>
pzErrmsg
)
;
}
else
{
*
pp
=
0
;
}
sqlite3_free
(
zExpr
)
;
}
return
rc
;
}
static
void
sqlite3Fts5ParseNodeFree
(
Fts5ExprNode
*
p
)
{
if
(
p
)
{
int
i
;
for
(
i
=
0
;
i
<
p
-
>
nChild
;
i
+
+
)
{
sqlite3Fts5ParseNodeFree
(
p
-
>
apChild
[
i
]
)
;
}
sqlite3Fts5ParseNearsetFree
(
p
-
>
pNear
)
;
sqlite3_free
(
p
)
;
}
}
static
void
sqlite3Fts5ExprFree
(
Fts5Expr
*
p
)
{
if
(
p
)
{
sqlite3Fts5ParseNodeFree
(
p
-
>
pRoot
)
;
sqlite3_free
(
p
-
>
apExprPhrase
)
;
sqlite3_free
(
p
)
;
}
}
static
int
sqlite3Fts5ExprAnd
(
Fts5Expr
*
*
pp1
Fts5Expr
*
p2
)
{
Fts5Parse
sParse
;
memset
(
&
sParse
0
sizeof
(
sParse
)
)
;
if
(
*
pp1
&
&
p2
)
{
Fts5Expr
*
p1
=
*
pp1
;
int
nPhrase
=
p1
-
>
nPhrase
+
p2
-
>
nPhrase
;
p1
-
>
pRoot
=
sqlite3Fts5ParseNode
(
&
sParse
FTS5_AND
p1
-
>
pRoot
p2
-
>
pRoot
0
)
;
p2
-
>
pRoot
=
0
;
if
(
sParse
.
rc
=
=
SQLITE_OK
)
{
Fts5ExprPhrase
*
*
ap
=
(
Fts5ExprPhrase
*
*
)
sqlite3_realloc
(
p1
-
>
apExprPhrase
nPhrase
*
sizeof
(
Fts5ExprPhrase
*
)
)
;
if
(
ap
=
=
0
)
{
sParse
.
rc
=
SQLITE_NOMEM
;
}
else
{
int
i
;
memmove
(
&
ap
[
p2
-
>
nPhrase
]
ap
p1
-
>
nPhrase
*
sizeof
(
Fts5ExprPhrase
*
)
)
;
for
(
i
=
0
;
i
<
p2
-
>
nPhrase
;
i
+
+
)
{
ap
[
i
]
=
p2
-
>
apExprPhrase
[
i
]
;
}
p1
-
>
nPhrase
=
nPhrase
;
p1
-
>
apExprPhrase
=
ap
;
}
}
sqlite3_free
(
p2
-
>
apExprPhrase
)
;
sqlite3_free
(
p2
)
;
}
else
if
(
p2
)
{
*
pp1
=
p2
;
}
return
sParse
.
rc
;
}
static
i64
fts5ExprSynonymRowid
(
Fts5ExprTerm
*
pTerm
int
bDesc
int
*
pbEof
)
{
i64
iRet
=
0
;
int
bRetValid
=
0
;
Fts5ExprTerm
*
p
;
assert
(
pTerm
)
;
assert
(
pTerm
-
>
pSynonym
)
;
assert
(
bDesc
=
=
0
|
|
bDesc
=
=
1
)
;
for
(
p
=
pTerm
;
p
;
p
=
p
-
>
pSynonym
)
{
if
(
0
=
=
sqlite3Fts5IterEof
(
p
-
>
pIter
)
)
{
i64
iRowid
=
p
-
>
pIter
-
>
iRowid
;
if
(
bRetValid
=
=
0
|
|
(
bDesc
!
=
(
iRowid
<
iRet
)
)
)
{
iRet
=
iRowid
;
bRetValid
=
1
;
}
}
}
if
(
pbEof
&
&
bRetValid
=
=
0
)
*
pbEof
=
1
;
return
iRet
;
}
static
int
fts5ExprSynonymList
(
Fts5ExprTerm
*
pTerm
i64
iRowid
Fts5Buffer
*
pBuf
u8
*
*
pa
int
*
pn
)
{
Fts5PoslistReader
aStatic
[
4
]
;
Fts5PoslistReader
*
aIter
=
aStatic
;
int
nIter
=
0
;
int
nAlloc
=
4
;
int
rc
=
SQLITE_OK
;
Fts5ExprTerm
*
p
;
assert
(
pTerm
-
>
pSynonym
)
;
for
(
p
=
pTerm
;
p
;
p
=
p
-
>
pSynonym
)
{
Fts5IndexIter
*
pIter
=
p
-
>
pIter
;
if
(
sqlite3Fts5IterEof
(
pIter
)
=
=
0
&
&
pIter
-
>
iRowid
=
=
iRowid
)
{
if
(
pIter
-
>
nData
=
=
0
)
continue
;
if
(
nIter
=
=
nAlloc
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5PoslistReader
)
*
nAlloc
*
2
;
Fts5PoslistReader
*
aNew
=
(
Fts5PoslistReader
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
aNew
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
goto
synonym_poslist_out
;
}
memcpy
(
aNew
aIter
sizeof
(
Fts5PoslistReader
)
*
nIter
)
;
nAlloc
=
nAlloc
*
2
;
if
(
aIter
!
=
aStatic
)
sqlite3_free
(
aIter
)
;
aIter
=
aNew
;
}
sqlite3Fts5PoslistReaderInit
(
pIter
-
>
pData
pIter
-
>
nData
&
aIter
[
nIter
]
)
;
assert
(
aIter
[
nIter
]
.
bEof
=
=
0
)
;
nIter
+
+
;
}
}
if
(
nIter
=
=
1
)
{
*
pa
=
(
u8
*
)
aIter
[
0
]
.
a
;
*
pn
=
aIter
[
0
]
.
n
;
}
else
{
Fts5PoslistWriter
writer
=
{
0
}
;
i64
iPrev
=
-
1
;
fts5BufferZero
(
pBuf
)
;
while
(
1
)
{
int
i
;
i64
iMin
=
FTS5_LARGEST_INT64
;
for
(
i
=
0
;
i
<
nIter
;
i
+
+
)
{
if
(
aIter
[
i
]
.
bEof
=
=
0
)
{
if
(
aIter
[
i
]
.
iPos
=
=
iPrev
)
{
if
(
sqlite3Fts5PoslistReaderNext
(
&
aIter
[
i
]
)
)
continue
;
}
if
(
aIter
[
i
]
.
iPos
<
iMin
)
{
iMin
=
aIter
[
i
]
.
iPos
;
}
}
}
if
(
iMin
=
=
FTS5_LARGEST_INT64
|
|
rc
!
=
SQLITE_OK
)
break
;
rc
=
sqlite3Fts5PoslistWriterAppend
(
pBuf
&
writer
iMin
)
;
iPrev
=
iMin
;
}
if
(
rc
=
=
SQLITE_OK
)
{
*
pa
=
pBuf
-
>
p
;
*
pn
=
pBuf
-
>
n
;
}
}
synonym_poslist_out
:
if
(
aIter
!
=
aStatic
)
sqlite3_free
(
aIter
)
;
return
rc
;
}
static
int
fts5ExprPhraseIsMatch
(
Fts5ExprNode
*
pNode
Fts5ExprPhrase
*
pPhrase
int
*
pbMatch
)
{
Fts5PoslistWriter
writer
=
{
0
}
;
Fts5PoslistReader
aStatic
[
4
]
;
Fts5PoslistReader
*
aIter
=
aStatic
;
int
i
;
int
rc
=
SQLITE_OK
;
int
bFirst
=
pPhrase
-
>
aTerm
[
0
]
.
bFirst
;
fts5BufferZero
(
&
pPhrase
-
>
poslist
)
;
if
(
pPhrase
-
>
nTerm
>
ArraySize
(
aStatic
)
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5PoslistReader
)
*
pPhrase
-
>
nTerm
;
aIter
=
(
Fts5PoslistReader
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
!
aIter
)
return
SQLITE_NOMEM
;
}
memset
(
aIter
0
sizeof
(
Fts5PoslistReader
)
*
pPhrase
-
>
nTerm
)
;
for
(
i
=
0
;
i
<
pPhrase
-
>
nTerm
;
i
+
+
)
{
Fts5ExprTerm
*
pTerm
=
&
pPhrase
-
>
aTerm
[
i
]
;
int
n
=
0
;
int
bFlag
=
0
;
u8
*
a
=
0
;
if
(
pTerm
-
>
pSynonym
)
{
Fts5Buffer
buf
=
{
0
0
0
}
;
rc
=
fts5ExprSynonymList
(
pTerm
pNode
-
>
iRowid
&
buf
&
a
&
n
)
;
if
(
rc
)
{
sqlite3_free
(
a
)
;
goto
ismatch_out
;
}
if
(
a
=
=
buf
.
p
)
bFlag
=
1
;
}
else
{
a
=
(
u8
*
)
pTerm
-
>
pIter
-
>
pData
;
n
=
pTerm
-
>
pIter
-
>
nData
;
}
sqlite3Fts5PoslistReaderInit
(
a
n
&
aIter
[
i
]
)
;
aIter
[
i
]
.
bFlag
=
(
u8
)
bFlag
;
if
(
aIter
[
i
]
.
bEof
)
goto
ismatch_out
;
}
while
(
1
)
{
int
bMatch
;
i64
iPos
=
aIter
[
0
]
.
iPos
;
do
{
bMatch
=
1
;
for
(
i
=
0
;
i
<
pPhrase
-
>
nTerm
;
i
+
+
)
{
Fts5PoslistReader
*
pPos
=
&
aIter
[
i
]
;
i64
iAdj
=
iPos
+
i
;
if
(
pPos
-
>
iPos
!
=
iAdj
)
{
bMatch
=
0
;
while
(
pPos
-
>
iPos
<
iAdj
)
{
if
(
sqlite3Fts5PoslistReaderNext
(
pPos
)
)
goto
ismatch_out
;
}
if
(
pPos
-
>
iPos
>
iAdj
)
iPos
=
pPos
-
>
iPos
-
i
;
}
}
}
while
(
bMatch
=
=
0
)
;
if
(
bFirst
=
=
0
|
|
FTS5_POS2OFFSET
(
iPos
)
=
=
0
)
{
rc
=
sqlite3Fts5PoslistWriterAppend
(
&
pPhrase
-
>
poslist
&
writer
iPos
)
;
if
(
rc
!
=
SQLITE_OK
)
goto
ismatch_out
;
}
for
(
i
=
0
;
i
<
pPhrase
-
>
nTerm
;
i
+
+
)
{
if
(
sqlite3Fts5PoslistReaderNext
(
&
aIter
[
i
]
)
)
goto
ismatch_out
;
}
}
ismatch_out
:
*
pbMatch
=
(
pPhrase
-
>
poslist
.
n
>
0
)
;
for
(
i
=
0
;
i
<
pPhrase
-
>
nTerm
;
i
+
+
)
{
if
(
aIter
[
i
]
.
bFlag
)
sqlite3_free
(
(
u8
*
)
aIter
[
i
]
.
a
)
;
}
if
(
aIter
!
=
aStatic
)
sqlite3_free
(
aIter
)
;
return
rc
;
}
typedef
struct
Fts5LookaheadReader
Fts5LookaheadReader
;
struct
Fts5LookaheadReader
{
const
u8
*
a
;
int
n
;
int
i
;
i64
iPos
;
i64
iLookahead
;
}
;
#
define
FTS5_LOOKAHEAD_EOF
(
(
(
i64
)
1
)
<
<
62
)
static
int
fts5LookaheadReaderNext
(
Fts5LookaheadReader
*
p
)
{
p
-
>
iPos
=
p
-
>
iLookahead
;
if
(
sqlite3Fts5PoslistNext64
(
p
-
>
a
p
-
>
n
&
p
-
>
i
&
p
-
>
iLookahead
)
)
{
p
-
>
iLookahead
=
FTS5_LOOKAHEAD_EOF
;
}
return
(
p
-
>
iPos
=
=
FTS5_LOOKAHEAD_EOF
)
;
}
static
int
fts5LookaheadReaderInit
(
const
u8
*
a
int
n
Fts5LookaheadReader
*
p
)
{
memset
(
p
0
sizeof
(
Fts5LookaheadReader
)
)
;
p
-
>
a
=
a
;
p
-
>
n
=
n
;
fts5LookaheadReaderNext
(
p
)
;
return
fts5LookaheadReaderNext
(
p
)
;
}
typedef
struct
Fts5NearTrimmer
Fts5NearTrimmer
;
struct
Fts5NearTrimmer
{
Fts5LookaheadReader
reader
;
Fts5PoslistWriter
writer
;
Fts5Buffer
*
pOut
;
}
;
static
int
fts5ExprNearIsMatch
(
int
*
pRc
Fts5ExprNearset
*
pNear
)
{
Fts5NearTrimmer
aStatic
[
4
]
;
Fts5NearTrimmer
*
a
=
aStatic
;
Fts5ExprPhrase
*
*
apPhrase
=
pNear
-
>
apPhrase
;
int
i
;
int
rc
=
*
pRc
;
int
bMatch
;
assert
(
pNear
-
>
nPhrase
>
1
)
;
if
(
pNear
-
>
nPhrase
>
ArraySize
(
aStatic
)
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5NearTrimmer
)
*
pNear
-
>
nPhrase
;
a
=
(
Fts5NearTrimmer
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
}
else
{
memset
(
aStatic
0
sizeof
(
aStatic
)
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
*
pRc
=
rc
;
return
0
;
}
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5Buffer
*
pPoslist
=
&
apPhrase
[
i
]
-
>
poslist
;
fts5LookaheadReaderInit
(
pPoslist
-
>
p
pPoslist
-
>
n
&
a
[
i
]
.
reader
)
;
pPoslist
-
>
n
=
0
;
a
[
i
]
.
pOut
=
pPoslist
;
}
while
(
1
)
{
int
iAdv
;
i64
iMin
;
i64
iMax
;
iMax
=
a
[
0
]
.
reader
.
iPos
;
do
{
bMatch
=
1
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5LookaheadReader
*
pPos
=
&
a
[
i
]
.
reader
;
iMin
=
iMax
-
pNear
-
>
apPhrase
[
i
]
-
>
nTerm
-
pNear
-
>
nNear
;
if
(
pPos
-
>
iPos
<
iMin
|
|
pPos
-
>
iPos
>
iMax
)
{
bMatch
=
0
;
while
(
pPos
-
>
iPos
<
iMin
)
{
if
(
fts5LookaheadReaderNext
(
pPos
)
)
goto
ismatch_out
;
}
if
(
pPos
-
>
iPos
>
iMax
)
iMax
=
pPos
-
>
iPos
;
}
}
}
while
(
bMatch
=
=
0
)
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
i64
iPos
=
a
[
i
]
.
reader
.
iPos
;
Fts5PoslistWriter
*
pWriter
=
&
a
[
i
]
.
writer
;
if
(
a
[
i
]
.
pOut
-
>
n
=
=
0
|
|
iPos
!
=
pWriter
-
>
iPrev
)
{
sqlite3Fts5PoslistWriterAppend
(
a
[
i
]
.
pOut
pWriter
iPos
)
;
}
}
iAdv
=
0
;
iMin
=
a
[
0
]
.
reader
.
iLookahead
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
if
(
a
[
i
]
.
reader
.
iLookahead
<
iMin
)
{
iMin
=
a
[
i
]
.
reader
.
iLookahead
;
iAdv
=
i
;
}
}
if
(
fts5LookaheadReaderNext
(
&
a
[
iAdv
]
.
reader
)
)
goto
ismatch_out
;
}
ismatch_out
:
{
int
bRet
=
a
[
0
]
.
pOut
-
>
n
>
0
;
*
pRc
=
rc
;
if
(
a
!
=
aStatic
)
sqlite3_free
(
a
)
;
return
bRet
;
}
}
static
int
fts5ExprAdvanceto
(
Fts5IndexIter
*
pIter
int
bDesc
i64
*
piLast
int
*
pRc
int
*
pbEof
)
{
i64
iLast
=
*
piLast
;
i64
iRowid
;
iRowid
=
pIter
-
>
iRowid
;
if
(
(
bDesc
=
=
0
&
&
iLast
>
iRowid
)
|
|
(
bDesc
&
&
iLast
<
iRowid
)
)
{
int
rc
=
sqlite3Fts5IterNextFrom
(
pIter
iLast
)
;
if
(
rc
|
|
sqlite3Fts5IterEof
(
pIter
)
)
{
*
pRc
=
rc
;
*
pbEof
=
1
;
return
1
;
}
iRowid
=
pIter
-
>
iRowid
;
assert
(
(
bDesc
=
=
0
&
&
iRowid
>
=
iLast
)
|
|
(
bDesc
=
=
1
&
&
iRowid
<
=
iLast
)
)
;
}
*
piLast
=
iRowid
;
return
0
;
}
static
int
fts5ExprSynonymAdvanceto
(
Fts5ExprTerm
*
pTerm
int
bDesc
i64
*
piLast
int
*
pRc
)
{
int
rc
=
SQLITE_OK
;
i64
iLast
=
*
piLast
;
Fts5ExprTerm
*
p
;
int
bEof
=
0
;
for
(
p
=
pTerm
;
rc
=
=
SQLITE_OK
&
&
p
;
p
=
p
-
>
pSynonym
)
{
if
(
sqlite3Fts5IterEof
(
p
-
>
pIter
)
=
=
0
)
{
i64
iRowid
=
p
-
>
pIter
-
>
iRowid
;
if
(
(
bDesc
=
=
0
&
&
iLast
>
iRowid
)
|
|
(
bDesc
&
&
iLast
<
iRowid
)
)
{
rc
=
sqlite3Fts5IterNextFrom
(
p
-
>
pIter
iLast
)
;
}
}
}
if
(
rc
!
=
SQLITE_OK
)
{
*
pRc
=
rc
;
bEof
=
1
;
}
else
{
*
piLast
=
fts5ExprSynonymRowid
(
pTerm
bDesc
&
bEof
)
;
}
return
bEof
;
}
static
int
fts5ExprNearTest
(
int
*
pRc
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
Fts5ExprNearset
*
pNear
=
pNode
-
>
pNear
;
int
rc
=
*
pRc
;
if
(
pExpr
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
)
{
Fts5ExprTerm
*
pTerm
;
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
0
]
;
pPhrase
-
>
poslist
.
n
=
0
;
for
(
pTerm
=
&
pPhrase
-
>
aTerm
[
0
]
;
pTerm
;
pTerm
=
pTerm
-
>
pSynonym
)
{
Fts5IndexIter
*
pIter
=
pTerm
-
>
pIter
;
if
(
sqlite3Fts5IterEof
(
pIter
)
=
=
0
)
{
if
(
pIter
-
>
iRowid
=
=
pNode
-
>
iRowid
&
&
pIter
-
>
nData
>
0
)
{
pPhrase
-
>
poslist
.
n
=
1
;
}
}
}
return
pPhrase
-
>
poslist
.
n
;
}
else
{
int
i
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
i
]
;
if
(
pPhrase
-
>
nTerm
>
1
|
|
pPhrase
-
>
aTerm
[
0
]
.
pSynonym
|
|
pNear
-
>
pColset
|
|
pPhrase
-
>
aTerm
[
0
]
.
bFirst
)
{
int
bMatch
=
0
;
rc
=
fts5ExprPhraseIsMatch
(
pNode
pPhrase
&
bMatch
)
;
if
(
bMatch
=
=
0
)
break
;
}
else
{
Fts5IndexIter
*
pIter
=
pPhrase
-
>
aTerm
[
0
]
.
pIter
;
fts5BufferSet
(
&
rc
&
pPhrase
-
>
poslist
pIter
-
>
nData
pIter
-
>
pData
)
;
}
}
*
pRc
=
rc
;
if
(
i
=
=
pNear
-
>
nPhrase
&
&
(
i
=
=
1
|
|
fts5ExprNearIsMatch
(
pRc
pNear
)
)
)
{
return
1
;
}
return
0
;
}
}
static
int
fts5ExprNearInitAll
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
Fts5ExprNearset
*
pNear
=
pNode
-
>
pNear
;
int
i
;
assert
(
pNode
-
>
bNomatch
=
=
0
)
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
i
]
;
if
(
pPhrase
-
>
nTerm
=
=
0
)
{
pNode
-
>
bEof
=
1
;
return
SQLITE_OK
;
}
else
{
int
j
;
for
(
j
=
0
;
j
<
pPhrase
-
>
nTerm
;
j
+
+
)
{
Fts5ExprTerm
*
pTerm
=
&
pPhrase
-
>
aTerm
[
j
]
;
Fts5ExprTerm
*
p
;
int
bHit
=
0
;
for
(
p
=
pTerm
;
p
;
p
=
p
-
>
pSynonym
)
{
int
rc
;
if
(
p
-
>
pIter
)
{
sqlite3Fts5IterClose
(
p
-
>
pIter
)
;
p
-
>
pIter
=
0
;
}
rc
=
sqlite3Fts5IndexQuery
(
pExpr
-
>
pIndex
p
-
>
pTerm
p
-
>
nQueryTerm
(
pTerm
-
>
bPrefix
?
FTS5INDEX_QUERY_PREFIX
:
0
)
|
(
pExpr
-
>
bDesc
?
FTS5INDEX_QUERY_DESC
:
0
)
pNear
-
>
pColset
&
p
-
>
pIter
)
;
assert
(
(
rc
=
=
SQLITE_OK
)
=
=
(
p
-
>
pIter
!
=
0
)
)
;
if
(
rc
!
=
SQLITE_OK
)
return
rc
;
if
(
0
=
=
sqlite3Fts5IterEof
(
p
-
>
pIter
)
)
{
bHit
=
1
;
}
}
if
(
bHit
=
=
0
)
{
pNode
-
>
bEof
=
1
;
return
SQLITE_OK
;
}
}
}
}
pNode
-
>
bEof
=
0
;
return
SQLITE_OK
;
}
static
int
fts5RowidCmp
(
Fts5Expr
*
pExpr
i64
iLhs
i64
iRhs
)
{
assert
(
pExpr
-
>
bDesc
=
=
0
|
|
pExpr
-
>
bDesc
=
=
1
)
;
if
(
pExpr
-
>
bDesc
=
=
0
)
{
if
(
iLhs
<
iRhs
)
return
-
1
;
return
(
iLhs
>
iRhs
)
;
}
else
{
if
(
iLhs
>
iRhs
)
return
-
1
;
return
(
iLhs
<
iRhs
)
;
}
}
static
void
fts5ExprSetEof
(
Fts5ExprNode
*
pNode
)
{
int
i
;
pNode
-
>
bEof
=
1
;
pNode
-
>
bNomatch
=
0
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
fts5ExprSetEof
(
pNode
-
>
apChild
[
i
]
)
;
}
}
static
void
fts5ExprNodeZeroPoslist
(
Fts5ExprNode
*
pNode
)
{
if
(
pNode
-
>
eType
=
=
FTS5_STRING
|
|
pNode
-
>
eType
=
=
FTS5_TERM
)
{
Fts5ExprNearset
*
pNear
=
pNode
-
>
pNear
;
int
i
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
i
]
;
pPhrase
-
>
poslist
.
n
=
0
;
}
}
else
{
int
i
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
fts5ExprNodeZeroPoslist
(
pNode
-
>
apChild
[
i
]
)
;
}
}
}
static
int
fts5NodeCompare
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
p1
Fts5ExprNode
*
p2
)
{
if
(
p2
-
>
bEof
)
return
-
1
;
if
(
p1
-
>
bEof
)
return
+
1
;
return
fts5RowidCmp
(
pExpr
p1
-
>
iRowid
p2
-
>
iRowid
)
;
}
static
int
fts5ExprNodeTest_STRING
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
Fts5ExprNearset
*
pNear
=
pNode
-
>
pNear
;
Fts5ExprPhrase
*
pLeft
=
pNear
-
>
apPhrase
[
0
]
;
int
rc
=
SQLITE_OK
;
i64
iLast
;
int
i
j
;
int
bMatch
;
const
int
bDesc
=
pExpr
-
>
bDesc
;
assert
(
pNear
-
>
nPhrase
>
1
|
|
pNear
-
>
apPhrase
[
0
]
-
>
nTerm
>
1
|
|
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
0
]
.
pSynonym
|
|
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
0
]
.
bFirst
)
;
if
(
pLeft
-
>
aTerm
[
0
]
.
pSynonym
)
{
iLast
=
fts5ExprSynonymRowid
(
&
pLeft
-
>
aTerm
[
0
]
bDesc
0
)
;
}
else
{
iLast
=
pLeft
-
>
aTerm
[
0
]
.
pIter
-
>
iRowid
;
}
do
{
bMatch
=
1
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
i
]
;
for
(
j
=
0
;
j
<
pPhrase
-
>
nTerm
;
j
+
+
)
{
Fts5ExprTerm
*
pTerm
=
&
pPhrase
-
>
aTerm
[
j
]
;
if
(
pTerm
-
>
pSynonym
)
{
i64
iRowid
=
fts5ExprSynonymRowid
(
pTerm
bDesc
0
)
;
if
(
iRowid
=
=
iLast
)
continue
;
bMatch
=
0
;
if
(
fts5ExprSynonymAdvanceto
(
pTerm
bDesc
&
iLast
&
rc
)
)
{
pNode
-
>
bNomatch
=
0
;
pNode
-
>
bEof
=
1
;
return
rc
;
}
}
else
{
Fts5IndexIter
*
pIter
=
pPhrase
-
>
aTerm
[
j
]
.
pIter
;
if
(
pIter
-
>
iRowid
=
=
iLast
)
continue
;
bMatch
=
0
;
if
(
fts5ExprAdvanceto
(
pIter
bDesc
&
iLast
&
rc
&
pNode
-
>
bEof
)
)
{
return
rc
;
}
}
}
}
}
while
(
bMatch
=
=
0
)
;
pNode
-
>
iRowid
=
iLast
;
pNode
-
>
bNomatch
=
(
(
0
=
=
fts5ExprNearTest
(
&
rc
pExpr
pNode
)
)
&
&
rc
=
=
SQLITE_OK
)
;
assert
(
pNode
-
>
bEof
=
=
0
|
|
pNode
-
>
bNomatch
=
=
0
)
;
return
rc
;
}
static
int
fts5ExprNodeNext_STRING
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
int
bFromValid
i64
iFrom
)
{
Fts5ExprTerm
*
pTerm
=
&
pNode
-
>
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
0
]
;
int
rc
=
SQLITE_OK
;
pNode
-
>
bNomatch
=
0
;
if
(
pTerm
-
>
pSynonym
)
{
int
bEof
=
1
;
Fts5ExprTerm
*
p
;
i64
iRowid
=
fts5ExprSynonymRowid
(
pTerm
pExpr
-
>
bDesc
0
)
;
for
(
p
=
pTerm
;
p
;
p
=
p
-
>
pSynonym
)
{
if
(
sqlite3Fts5IterEof
(
p
-
>
pIter
)
=
=
0
)
{
i64
ii
=
p
-
>
pIter
-
>
iRowid
;
if
(
ii
=
=
iRowid
|
|
(
bFromValid
&
&
ii
!
=
iFrom
&
&
(
ii
>
iFrom
)
=
=
pExpr
-
>
bDesc
)
)
{
if
(
bFromValid
)
{
rc
=
sqlite3Fts5IterNextFrom
(
p
-
>
pIter
iFrom
)
;
}
else
{
rc
=
sqlite3Fts5IterNext
(
p
-
>
pIter
)
;
}
if
(
rc
!
=
SQLITE_OK
)
break
;
if
(
sqlite3Fts5IterEof
(
p
-
>
pIter
)
=
=
0
)
{
bEof
=
0
;
}
}
else
{
bEof
=
0
;
}
}
}
pNode
-
>
bEof
=
(
rc
|
|
bEof
)
;
}
else
{
Fts5IndexIter
*
pIter
=
pTerm
-
>
pIter
;
assert
(
Fts5NodeIsString
(
pNode
)
)
;
if
(
bFromValid
)
{
rc
=
sqlite3Fts5IterNextFrom
(
pIter
iFrom
)
;
}
else
{
rc
=
sqlite3Fts5IterNext
(
pIter
)
;
}
pNode
-
>
bEof
=
(
rc
|
|
sqlite3Fts5IterEof
(
pIter
)
)
;
}
if
(
pNode
-
>
bEof
=
=
0
)
{
assert
(
rc
=
=
SQLITE_OK
)
;
rc
=
fts5ExprNodeTest_STRING
(
pExpr
pNode
)
;
}
return
rc
;
}
static
int
fts5ExprNodeTest_TERM
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
Fts5ExprPhrase
*
pPhrase
=
pNode
-
>
pNear
-
>
apPhrase
[
0
]
;
Fts5IndexIter
*
pIter
=
pPhrase
-
>
aTerm
[
0
]
.
pIter
;
assert
(
pNode
-
>
eType
=
=
FTS5_TERM
)
;
assert
(
pNode
-
>
pNear
-
>
nPhrase
=
=
1
&
&
pPhrase
-
>
nTerm
=
=
1
)
;
assert
(
pPhrase
-
>
aTerm
[
0
]
.
pSynonym
=
=
0
)
;
pPhrase
-
>
poslist
.
n
=
pIter
-
>
nData
;
if
(
pExpr
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
{
pPhrase
-
>
poslist
.
p
=
(
u8
*
)
pIter
-
>
pData
;
}
pNode
-
>
iRowid
=
pIter
-
>
iRowid
;
pNode
-
>
bNomatch
=
(
pPhrase
-
>
poslist
.
n
=
=
0
)
;
return
SQLITE_OK
;
}
static
int
fts5ExprNodeNext_TERM
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
int
bFromValid
i64
iFrom
)
{
int
rc
;
Fts5IndexIter
*
pIter
=
pNode
-
>
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
0
]
.
pIter
;
assert
(
pNode
-
>
bEof
=
=
0
)
;
if
(
bFromValid
)
{
rc
=
sqlite3Fts5IterNextFrom
(
pIter
iFrom
)
;
}
else
{
rc
=
sqlite3Fts5IterNext
(
pIter
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
sqlite3Fts5IterEof
(
pIter
)
=
=
0
)
{
rc
=
fts5ExprNodeTest_TERM
(
pExpr
pNode
)
;
}
else
{
pNode
-
>
bEof
=
1
;
pNode
-
>
bNomatch
=
0
;
}
return
rc
;
}
static
void
fts5ExprNodeTest_OR
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
Fts5ExprNode
*
pNext
=
pNode
-
>
apChild
[
0
]
;
int
i
;
for
(
i
=
1
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
Fts5ExprNode
*
pChild
=
pNode
-
>
apChild
[
i
]
;
int
cmp
=
fts5NodeCompare
(
pExpr
pNext
pChild
)
;
if
(
cmp
>
0
|
|
(
cmp
=
=
0
&
&
pChild
-
>
bNomatch
=
=
0
)
)
{
pNext
=
pChild
;
}
}
pNode
-
>
iRowid
=
pNext
-
>
iRowid
;
pNode
-
>
bEof
=
pNext
-
>
bEof
;
pNode
-
>
bNomatch
=
pNext
-
>
bNomatch
;
}
static
int
fts5ExprNodeNext_OR
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
int
bFromValid
i64
iFrom
)
{
int
i
;
i64
iLast
=
pNode
-
>
iRowid
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
Fts5ExprNode
*
p1
=
pNode
-
>
apChild
[
i
]
;
assert
(
p1
-
>
bEof
|
|
fts5RowidCmp
(
pExpr
p1
-
>
iRowid
iLast
)
>
=
0
)
;
if
(
p1
-
>
bEof
=
=
0
)
{
if
(
(
p1
-
>
iRowid
=
=
iLast
)
|
|
(
bFromValid
&
&
fts5RowidCmp
(
pExpr
p1
-
>
iRowid
iFrom
)
<
0
)
)
{
int
rc
=
fts5ExprNodeNext
(
pExpr
p1
bFromValid
iFrom
)
;
if
(
rc
!
=
SQLITE_OK
)
{
pNode
-
>
bNomatch
=
0
;
return
rc
;
}
}
}
}
fts5ExprNodeTest_OR
(
pExpr
pNode
)
;
return
SQLITE_OK
;
}
static
int
fts5ExprNodeTest_AND
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pAnd
)
{
int
iChild
;
i64
iLast
=
pAnd
-
>
iRowid
;
int
rc
=
SQLITE_OK
;
int
bMatch
;
assert
(
pAnd
-
>
bEof
=
=
0
)
;
do
{
pAnd
-
>
bNomatch
=
0
;
bMatch
=
1
;
for
(
iChild
=
0
;
iChild
<
pAnd
-
>
nChild
;
iChild
+
+
)
{
Fts5ExprNode
*
pChild
=
pAnd
-
>
apChild
[
iChild
]
;
int
cmp
=
fts5RowidCmp
(
pExpr
iLast
pChild
-
>
iRowid
)
;
if
(
cmp
>
0
)
{
rc
=
fts5ExprNodeNext
(
pExpr
pChild
1
iLast
)
;
if
(
rc
!
=
SQLITE_OK
)
{
pAnd
-
>
bNomatch
=
0
;
return
rc
;
}
}
assert
(
pChild
-
>
bEof
|
|
fts5RowidCmp
(
pExpr
iLast
pChild
-
>
iRowid
)
<
=
0
)
;
if
(
pChild
-
>
bEof
)
{
fts5ExprSetEof
(
pAnd
)
;
bMatch
=
1
;
break
;
}
else
if
(
iLast
!
=
pChild
-
>
iRowid
)
{
bMatch
=
0
;
iLast
=
pChild
-
>
iRowid
;
}
if
(
pChild
-
>
bNomatch
)
{
pAnd
-
>
bNomatch
=
1
;
}
}
}
while
(
bMatch
=
=
0
)
;
if
(
pAnd
-
>
bNomatch
&
&
pAnd
!
=
pExpr
-
>
pRoot
)
{
fts5ExprNodeZeroPoslist
(
pAnd
)
;
}
pAnd
-
>
iRowid
=
iLast
;
return
SQLITE_OK
;
}
static
int
fts5ExprNodeNext_AND
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
int
bFromValid
i64
iFrom
)
{
int
rc
=
fts5ExprNodeNext
(
pExpr
pNode
-
>
apChild
[
0
]
bFromValid
iFrom
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5ExprNodeTest_AND
(
pExpr
pNode
)
;
}
else
{
pNode
-
>
bNomatch
=
0
;
}
return
rc
;
}
static
int
fts5ExprNodeTest_NOT
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
int
rc
=
SQLITE_OK
;
Fts5ExprNode
*
p1
=
pNode
-
>
apChild
[
0
]
;
Fts5ExprNode
*
p2
=
pNode
-
>
apChild
[
1
]
;
assert
(
pNode
-
>
nChild
=
=
2
)
;
while
(
rc
=
=
SQLITE_OK
&
&
p1
-
>
bEof
=
=
0
)
{
int
cmp
=
fts5NodeCompare
(
pExpr
p1
p2
)
;
if
(
cmp
>
0
)
{
rc
=
fts5ExprNodeNext
(
pExpr
p2
1
p1
-
>
iRowid
)
;
cmp
=
fts5NodeCompare
(
pExpr
p1
p2
)
;
}
assert
(
rc
!
=
SQLITE_OK
|
|
cmp
<
=
0
)
;
if
(
cmp
|
|
p2
-
>
bNomatch
)
break
;
rc
=
fts5ExprNodeNext
(
pExpr
p1
0
0
)
;
}
pNode
-
>
bEof
=
p1
-
>
bEof
;
pNode
-
>
bNomatch
=
p1
-
>
bNomatch
;
pNode
-
>
iRowid
=
p1
-
>
iRowid
;
if
(
p1
-
>
bEof
)
{
fts5ExprNodeZeroPoslist
(
p2
)
;
}
return
rc
;
}
static
int
fts5ExprNodeNext_NOT
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
int
bFromValid
i64
iFrom
)
{
int
rc
=
fts5ExprNodeNext
(
pExpr
pNode
-
>
apChild
[
0
]
bFromValid
iFrom
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5ExprNodeTest_NOT
(
pExpr
pNode
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
pNode
-
>
bNomatch
=
0
;
}
return
rc
;
}
static
int
fts5ExprNodeTest
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
int
rc
=
SQLITE_OK
;
if
(
pNode
-
>
bEof
=
=
0
)
{
switch
(
pNode
-
>
eType
)
{
case
FTS5_STRING
:
{
rc
=
fts5ExprNodeTest_STRING
(
pExpr
pNode
)
;
break
;
}
case
FTS5_TERM
:
{
rc
=
fts5ExprNodeTest_TERM
(
pExpr
pNode
)
;
break
;
}
case
FTS5_AND
:
{
rc
=
fts5ExprNodeTest_AND
(
pExpr
pNode
)
;
break
;
}
case
FTS5_OR
:
{
fts5ExprNodeTest_OR
(
pExpr
pNode
)
;
break
;
}
default
:
assert
(
pNode
-
>
eType
=
=
FTS5_NOT
)
;
{
rc
=
fts5ExprNodeTest_NOT
(
pExpr
pNode
)
;
break
;
}
}
}
return
rc
;
}
static
int
fts5ExprNodeFirst
(
Fts5Expr
*
pExpr
Fts5ExprNode
*
pNode
)
{
int
rc
=
SQLITE_OK
;
pNode
-
>
bEof
=
0
;
pNode
-
>
bNomatch
=
0
;
if
(
Fts5NodeIsString
(
pNode
)
)
{
rc
=
fts5ExprNearInitAll
(
pExpr
pNode
)
;
}
else
if
(
pNode
-
>
xNext
=
=
0
)
{
pNode
-
>
bEof
=
1
;
}
else
{
int
i
;
int
nEof
=
0
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
&
&
rc
=
=
SQLITE_OK
;
i
+
+
)
{
Fts5ExprNode
*
pChild
=
pNode
-
>
apChild
[
i
]
;
rc
=
fts5ExprNodeFirst
(
pExpr
pNode
-
>
apChild
[
i
]
)
;
assert
(
pChild
-
>
bEof
=
=
0
|
|
pChild
-
>
bEof
=
=
1
)
;
nEof
+
=
pChild
-
>
bEof
;
}
pNode
-
>
iRowid
=
pNode
-
>
apChild
[
0
]
-
>
iRowid
;
switch
(
pNode
-
>
eType
)
{
case
FTS5_AND
:
if
(
nEof
>
0
)
fts5ExprSetEof
(
pNode
)
;
break
;
case
FTS5_OR
:
if
(
pNode
-
>
nChild
=
=
nEof
)
fts5ExprSetEof
(
pNode
)
;
break
;
default
:
assert
(
pNode
-
>
eType
=
=
FTS5_NOT
)
;
pNode
-
>
bEof
=
pNode
-
>
apChild
[
0
]
-
>
bEof
;
break
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5ExprNodeTest
(
pExpr
pNode
)
;
}
return
rc
;
}
static
int
sqlite3Fts5ExprFirst
(
Fts5Expr
*
p
Fts5Index
*
pIdx
i64
iFirst
int
bDesc
)
{
Fts5ExprNode
*
pRoot
=
p
-
>
pRoot
;
int
rc
;
p
-
>
pIndex
=
pIdx
;
p
-
>
bDesc
=
bDesc
;
rc
=
fts5ExprNodeFirst
(
p
pRoot
)
;
if
(
rc
=
=
SQLITE_OK
&
&
0
=
=
pRoot
-
>
bEof
&
&
fts5RowidCmp
(
p
pRoot
-
>
iRowid
iFirst
)
<
0
)
{
rc
=
fts5ExprNodeNext
(
p
pRoot
1
iFirst
)
;
}
while
(
pRoot
-
>
bNomatch
&
&
rc
=
=
SQLITE_OK
)
{
assert
(
pRoot
-
>
bEof
=
=
0
)
;
rc
=
fts5ExprNodeNext
(
p
pRoot
0
0
)
;
}
return
rc
;
}
static
int
sqlite3Fts5ExprNext
(
Fts5Expr
*
p
i64
iLast
)
{
int
rc
;
Fts5ExprNode
*
pRoot
=
p
-
>
pRoot
;
assert
(
pRoot
-
>
bEof
=
=
0
&
&
pRoot
-
>
bNomatch
=
=
0
)
;
do
{
rc
=
fts5ExprNodeNext
(
p
pRoot
0
0
)
;
assert
(
pRoot
-
>
bNomatch
=
=
0
|
|
(
rc
=
=
SQLITE_OK
&
&
pRoot
-
>
bEof
=
=
0
)
)
;
}
while
(
pRoot
-
>
bNomatch
)
;
if
(
fts5RowidCmp
(
p
pRoot
-
>
iRowid
iLast
)
>
0
)
{
pRoot
-
>
bEof
=
1
;
}
return
rc
;
}
static
int
sqlite3Fts5ExprEof
(
Fts5Expr
*
p
)
{
return
p
-
>
pRoot
-
>
bEof
;
}
static
i64
sqlite3Fts5ExprRowid
(
Fts5Expr
*
p
)
{
return
p
-
>
pRoot
-
>
iRowid
;
}
static
int
fts5ParseStringFromToken
(
Fts5Token
*
pToken
char
*
*
pz
)
{
int
rc
=
SQLITE_OK
;
*
pz
=
sqlite3Fts5Strndup
(
&
rc
pToken
-
>
p
pToken
-
>
n
)
;
return
rc
;
}
static
void
fts5ExprPhraseFree
(
Fts5ExprPhrase
*
pPhrase
)
{
if
(
pPhrase
)
{
int
i
;
for
(
i
=
0
;
i
<
pPhrase
-
>
nTerm
;
i
+
+
)
{
Fts5ExprTerm
*
pSyn
;
Fts5ExprTerm
*
pNext
;
Fts5ExprTerm
*
pTerm
=
&
pPhrase
-
>
aTerm
[
i
]
;
sqlite3_free
(
pTerm
-
>
pTerm
)
;
sqlite3Fts5IterClose
(
pTerm
-
>
pIter
)
;
for
(
pSyn
=
pTerm
-
>
pSynonym
;
pSyn
;
pSyn
=
pNext
)
{
pNext
=
pSyn
-
>
pSynonym
;
sqlite3Fts5IterClose
(
pSyn
-
>
pIter
)
;
fts5BufferFree
(
(
Fts5Buffer
*
)
&
pSyn
[
1
]
)
;
sqlite3_free
(
pSyn
)
;
}
}
if
(
pPhrase
-
>
poslist
.
nSpace
>
0
)
fts5BufferFree
(
&
pPhrase
-
>
poslist
)
;
sqlite3_free
(
pPhrase
)
;
}
}
static
void
sqlite3Fts5ParseSetCaret
(
Fts5ExprPhrase
*
pPhrase
)
{
if
(
pPhrase
&
&
pPhrase
-
>
nTerm
)
{
pPhrase
-
>
aTerm
[
0
]
.
bFirst
=
1
;
}
}
static
Fts5ExprNearset
*
sqlite3Fts5ParseNearset
(
Fts5Parse
*
pParse
Fts5ExprNearset
*
pNear
Fts5ExprPhrase
*
pPhrase
)
{
const
int
SZALLOC
=
8
;
Fts5ExprNearset
*
pRet
=
0
;
if
(
pParse
-
>
rc
=
=
SQLITE_OK
)
{
if
(
pNear
=
=
0
)
{
sqlite3_int64
nByte
;
nByte
=
sizeof
(
Fts5ExprNearset
)
+
SZALLOC
*
sizeof
(
Fts5ExprPhrase
*
)
;
pRet
=
sqlite3_malloc64
(
nByte
)
;
if
(
pRet
=
=
0
)
{
pParse
-
>
rc
=
SQLITE_NOMEM
;
}
else
{
memset
(
pRet
0
(
size_t
)
nByte
)
;
}
}
else
if
(
(
pNear
-
>
nPhrase
%
SZALLOC
)
=
=
0
)
{
int
nNew
=
pNear
-
>
nPhrase
+
SZALLOC
;
sqlite3_int64
nByte
;
nByte
=
sizeof
(
Fts5ExprNearset
)
+
nNew
*
sizeof
(
Fts5ExprPhrase
*
)
;
pRet
=
(
Fts5ExprNearset
*
)
sqlite3_realloc64
(
pNear
nByte
)
;
if
(
pRet
=
=
0
)
{
pParse
-
>
rc
=
SQLITE_NOMEM
;
}
}
else
{
pRet
=
pNear
;
}
}
if
(
pRet
=
=
0
)
{
assert
(
pParse
-
>
rc
!
=
SQLITE_OK
)
;
sqlite3Fts5ParseNearsetFree
(
pNear
)
;
sqlite3Fts5ParsePhraseFree
(
pPhrase
)
;
}
else
{
if
(
pRet
-
>
nPhrase
>
0
)
{
Fts5ExprPhrase
*
pLast
=
pRet
-
>
apPhrase
[
pRet
-
>
nPhrase
-
1
]
;
assert
(
pParse
!
=
0
)
;
assert
(
pParse
-
>
apPhrase
!
=
0
)
;
assert
(
pParse
-
>
nPhrase
>
=
2
)
;
assert
(
pLast
=
=
pParse
-
>
apPhrase
[
pParse
-
>
nPhrase
-
2
]
)
;
if
(
pPhrase
-
>
nTerm
=
=
0
)
{
fts5ExprPhraseFree
(
pPhrase
)
;
pRet
-
>
nPhrase
-
-
;
pParse
-
>
nPhrase
-
-
;
pPhrase
=
pLast
;
}
else
if
(
pLast
-
>
nTerm
=
=
0
)
{
fts5ExprPhraseFree
(
pLast
)
;
pParse
-
>
apPhrase
[
pParse
-
>
nPhrase
-
2
]
=
pPhrase
;
pParse
-
>
nPhrase
-
-
;
pRet
-
>
nPhrase
-
-
;
}
}
pRet
-
>
apPhrase
[
pRet
-
>
nPhrase
+
+
]
=
pPhrase
;
}
return
pRet
;
}
typedef
struct
TokenCtx
TokenCtx
;
struct
TokenCtx
{
Fts5ExprPhrase
*
pPhrase
;
Fts5Config
*
pConfig
;
int
rc
;
}
;
static
int
fts5ParseTokenize
(
void
*
pContext
int
tflags
const
char
*
pToken
int
nToken
int
iUnused1
int
iUnused2
)
{
int
rc
=
SQLITE_OK
;
const
int
SZALLOC
=
8
;
TokenCtx
*
pCtx
=
(
TokenCtx
*
)
pContext
;
Fts5ExprPhrase
*
pPhrase
=
pCtx
-
>
pPhrase
;
UNUSED_PARAM2
(
iUnused1
iUnused2
)
;
if
(
pCtx
-
>
rc
!
=
SQLITE_OK
)
return
pCtx
-
>
rc
;
if
(
nToken
>
FTS5_MAX_TOKEN_SIZE
)
nToken
=
FTS5_MAX_TOKEN_SIZE
;
if
(
pPhrase
&
&
pPhrase
-
>
nTerm
>
0
&
&
(
tflags
&
FTS5_TOKEN_COLOCATED
)
)
{
Fts5ExprTerm
*
pSyn
;
sqlite3_int64
nByte
=
sizeof
(
Fts5ExprTerm
)
+
sizeof
(
Fts5Buffer
)
+
nToken
+
1
;
pSyn
=
(
Fts5ExprTerm
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
pSyn
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
memset
(
pSyn
0
(
size_t
)
nByte
)
;
pSyn
-
>
pTerm
=
(
(
char
*
)
pSyn
)
+
sizeof
(
Fts5ExprTerm
)
+
sizeof
(
Fts5Buffer
)
;
pSyn
-
>
nFullTerm
=
pSyn
-
>
nQueryTerm
=
nToken
;
if
(
pCtx
-
>
pConfig
-
>
bTokendata
)
{
pSyn
-
>
nQueryTerm
=
(
int
)
strlen
(
pSyn
-
>
pTerm
)
;
}
memcpy
(
pSyn
-
>
pTerm
pToken
nToken
)
;
pSyn
-
>
pSynonym
=
pPhrase
-
>
aTerm
[
pPhrase
-
>
nTerm
-
1
]
.
pSynonym
;
pPhrase
-
>
aTerm
[
pPhrase
-
>
nTerm
-
1
]
.
pSynonym
=
pSyn
;
}
}
else
{
Fts5ExprTerm
*
pTerm
;
if
(
pPhrase
=
=
0
|
|
(
pPhrase
-
>
nTerm
%
SZALLOC
)
=
=
0
)
{
Fts5ExprPhrase
*
pNew
;
int
nNew
=
SZALLOC
+
(
pPhrase
?
pPhrase
-
>
nTerm
:
0
)
;
pNew
=
(
Fts5ExprPhrase
*
)
sqlite3_realloc64
(
pPhrase
sizeof
(
Fts5ExprPhrase
)
+
sizeof
(
Fts5ExprTerm
)
*
nNew
)
;
if
(
pNew
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
if
(
pPhrase
=
=
0
)
memset
(
pNew
0
sizeof
(
Fts5ExprPhrase
)
)
;
pCtx
-
>
pPhrase
=
pPhrase
=
pNew
;
pNew
-
>
nTerm
=
nNew
-
SZALLOC
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
pTerm
=
&
pPhrase
-
>
aTerm
[
pPhrase
-
>
nTerm
+
+
]
;
memset
(
pTerm
0
sizeof
(
Fts5ExprTerm
)
)
;
pTerm
-
>
pTerm
=
sqlite3Fts5Strndup
(
&
rc
pToken
nToken
)
;
pTerm
-
>
nFullTerm
=
pTerm
-
>
nQueryTerm
=
nToken
;
if
(
pCtx
-
>
pConfig
-
>
bTokendata
&
&
rc
=
=
SQLITE_OK
)
{
pTerm
-
>
nQueryTerm
=
(
int
)
strlen
(
pTerm
-
>
pTerm
)
;
}
}
}
pCtx
-
>
rc
=
rc
;
return
rc
;
}
static
void
sqlite3Fts5ParsePhraseFree
(
Fts5ExprPhrase
*
pPhrase
)
{
fts5ExprPhraseFree
(
pPhrase
)
;
}
static
void
sqlite3Fts5ParseNearsetFree
(
Fts5ExprNearset
*
pNear
)
{
if
(
pNear
)
{
int
i
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
fts5ExprPhraseFree
(
pNear
-
>
apPhrase
[
i
]
)
;
}
sqlite3_free
(
pNear
-
>
pColset
)
;
sqlite3_free
(
pNear
)
;
}
}
static
void
sqlite3Fts5ParseFinished
(
Fts5Parse
*
pParse
Fts5ExprNode
*
p
)
{
assert
(
pParse
-
>
pExpr
=
=
0
)
;
pParse
-
>
pExpr
=
p
;
}
static
int
parseGrowPhraseArray
(
Fts5Parse
*
pParse
)
{
if
(
(
pParse
-
>
nPhrase
%
8
)
=
=
0
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5ExprPhrase
*
)
*
(
pParse
-
>
nPhrase
+
8
)
;
Fts5ExprPhrase
*
*
apNew
;
apNew
=
(
Fts5ExprPhrase
*
*
)
sqlite3_realloc64
(
pParse
-
>
apPhrase
nByte
)
;
if
(
apNew
=
=
0
)
{
pParse
-
>
rc
=
SQLITE_NOMEM
;
return
SQLITE_NOMEM
;
}
pParse
-
>
apPhrase
=
apNew
;
}
return
SQLITE_OK
;
}
static
Fts5ExprPhrase
*
sqlite3Fts5ParseTerm
(
Fts5Parse
*
pParse
Fts5ExprPhrase
*
pAppend
Fts5Token
*
pToken
int
bPrefix
)
{
Fts5Config
*
pConfig
=
pParse
-
>
pConfig
;
TokenCtx
sCtx
;
int
rc
;
char
*
z
=
0
;
memset
(
&
sCtx
0
sizeof
(
TokenCtx
)
)
;
sCtx
.
pPhrase
=
pAppend
;
sCtx
.
pConfig
=
pConfig
;
rc
=
fts5ParseStringFromToken
(
pToken
&
z
)
;
if
(
rc
=
=
SQLITE_OK
)
{
int
flags
=
FTS5_TOKENIZE_QUERY
|
(
bPrefix
?
FTS5_TOKENIZE_PREFIX
:
0
)
;
int
n
;
sqlite3Fts5Dequote
(
z
)
;
n
=
(
int
)
strlen
(
z
)
;
rc
=
sqlite3Fts5Tokenize
(
pConfig
flags
z
n
&
sCtx
fts5ParseTokenize
)
;
}
sqlite3_free
(
z
)
;
if
(
rc
|
|
(
rc
=
sCtx
.
rc
)
)
{
pParse
-
>
rc
=
rc
;
fts5ExprPhraseFree
(
sCtx
.
pPhrase
)
;
sCtx
.
pPhrase
=
0
;
}
else
{
if
(
pAppend
=
=
0
)
{
if
(
parseGrowPhraseArray
(
pParse
)
)
{
fts5ExprPhraseFree
(
sCtx
.
pPhrase
)
;
return
0
;
}
pParse
-
>
nPhrase
+
+
;
}
if
(
sCtx
.
pPhrase
=
=
0
)
{
sCtx
.
pPhrase
=
sqlite3Fts5MallocZero
(
&
pParse
-
>
rc
sizeof
(
Fts5ExprPhrase
)
)
;
}
else
if
(
sCtx
.
pPhrase
-
>
nTerm
)
{
sCtx
.
pPhrase
-
>
aTerm
[
sCtx
.
pPhrase
-
>
nTerm
-
1
]
.
bPrefix
=
(
u8
)
bPrefix
;
}
assert
(
pParse
-
>
apPhrase
!
=
0
)
;
pParse
-
>
apPhrase
[
pParse
-
>
nPhrase
-
1
]
=
sCtx
.
pPhrase
;
}
return
sCtx
.
pPhrase
;
}
static
int
sqlite3Fts5ExprClonePhrase
(
Fts5Expr
*
pExpr
int
iPhrase
Fts5Expr
*
*
ppNew
)
{
int
rc
=
SQLITE_OK
;
Fts5ExprPhrase
*
pOrig
=
0
;
Fts5Expr
*
pNew
=
0
;
TokenCtx
sCtx
=
{
0
0
0
}
;
if
(
!
pExpr
|
|
iPhrase
<
0
|
|
iPhrase
>
=
pExpr
-
>
nPhrase
)
{
rc
=
SQLITE_RANGE
;
}
else
{
pOrig
=
pExpr
-
>
apExprPhrase
[
iPhrase
]
;
pNew
=
(
Fts5Expr
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5Expr
)
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pNew
-
>
apExprPhrase
=
(
Fts5ExprPhrase
*
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5ExprPhrase
*
)
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pNew
-
>
pRoot
=
(
Fts5ExprNode
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5ExprNode
)
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pNew
-
>
pRoot
-
>
pNear
=
(
Fts5ExprNearset
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5ExprNearset
)
+
sizeof
(
Fts5ExprPhrase
*
)
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
ALWAYS
(
pOrig
!
=
0
)
)
{
Fts5Colset
*
pColsetOrig
=
pOrig
-
>
pNode
-
>
pNear
-
>
pColset
;
if
(
pColsetOrig
)
{
sqlite3_int64
nByte
;
Fts5Colset
*
pColset
;
nByte
=
sizeof
(
Fts5Colset
)
+
(
pColsetOrig
-
>
nCol
-
1
)
*
sizeof
(
int
)
;
pColset
=
(
Fts5Colset
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
if
(
pColset
)
{
memcpy
(
pColset
pColsetOrig
(
size_t
)
nByte
)
;
}
pNew
-
>
pRoot
-
>
pNear
-
>
pColset
=
pColset
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
if
(
pOrig
-
>
nTerm
)
{
int
i
;
sCtx
.
pConfig
=
pExpr
-
>
pConfig
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
pOrig
-
>
nTerm
;
i
+
+
)
{
int
tflags
=
0
;
Fts5ExprTerm
*
p
;
for
(
p
=
&
pOrig
-
>
aTerm
[
i
]
;
p
&
&
rc
=
=
SQLITE_OK
;
p
=
p
-
>
pSynonym
)
{
rc
=
fts5ParseTokenize
(
(
void
*
)
&
sCtx
tflags
p
-
>
pTerm
p
-
>
nFullTerm
0
0
)
;
tflags
=
FTS5_TOKEN_COLOCATED
;
}
if
(
rc
=
=
SQLITE_OK
)
{
sCtx
.
pPhrase
-
>
aTerm
[
i
]
.
bPrefix
=
pOrig
-
>
aTerm
[
i
]
.
bPrefix
;
sCtx
.
pPhrase
-
>
aTerm
[
i
]
.
bFirst
=
pOrig
-
>
aTerm
[
i
]
.
bFirst
;
}
}
}
else
{
sCtx
.
pPhrase
=
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5ExprPhrase
)
)
;
}
}
if
(
rc
=
=
SQLITE_OK
&
&
ALWAYS
(
sCtx
.
pPhrase
)
)
{
pNew
-
>
pIndex
=
pExpr
-
>
pIndex
;
pNew
-
>
pConfig
=
pExpr
-
>
pConfig
;
pNew
-
>
nPhrase
=
1
;
pNew
-
>
apExprPhrase
[
0
]
=
sCtx
.
pPhrase
;
pNew
-
>
pRoot
-
>
pNear
-
>
apPhrase
[
0
]
=
sCtx
.
pPhrase
;
pNew
-
>
pRoot
-
>
pNear
-
>
nPhrase
=
1
;
sCtx
.
pPhrase
-
>
pNode
=
pNew
-
>
pRoot
;
if
(
pOrig
-
>
nTerm
=
=
1
&
&
pOrig
-
>
aTerm
[
0
]
.
pSynonym
=
=
0
&
&
pOrig
-
>
aTerm
[
0
]
.
bFirst
=
=
0
)
{
pNew
-
>
pRoot
-
>
eType
=
FTS5_TERM
;
pNew
-
>
pRoot
-
>
xNext
=
fts5ExprNodeNext_TERM
;
}
else
{
pNew
-
>
pRoot
-
>
eType
=
FTS5_STRING
;
pNew
-
>
pRoot
-
>
xNext
=
fts5ExprNodeNext_STRING
;
}
}
else
{
sqlite3Fts5ExprFree
(
pNew
)
;
fts5ExprPhraseFree
(
sCtx
.
pPhrase
)
;
pNew
=
0
;
}
*
ppNew
=
pNew
;
return
rc
;
}
static
void
sqlite3Fts5ParseNear
(
Fts5Parse
*
pParse
Fts5Token
*
pTok
)
{
if
(
pTok
-
>
n
!
=
4
|
|
memcmp
(
"
NEAR
"
pTok
-
>
p
4
)
)
{
sqlite3Fts5ParseError
(
pParse
"
fts5
:
syntax
error
near
\
"
%
.
*
s
\
"
"
pTok
-
>
n
pTok
-
>
p
)
;
}
}
static
void
sqlite3Fts5ParseSetDistance
(
Fts5Parse
*
pParse
Fts5ExprNearset
*
pNear
Fts5Token
*
p
)
{
if
(
pNear
)
{
int
nNear
=
0
;
int
i
;
if
(
p
-
>
n
)
{
for
(
i
=
0
;
i
<
p
-
>
n
;
i
+
+
)
{
char
c
=
(
char
)
p
-
>
p
[
i
]
;
if
(
c
<
'
0
'
|
|
c
>
'
9
'
)
{
sqlite3Fts5ParseError
(
pParse
"
expected
integer
got
\
"
%
.
*
s
\
"
"
p
-
>
n
p
-
>
p
)
;
return
;
}
nNear
=
nNear
*
10
+
(
p
-
>
p
[
i
]
-
'
0
'
)
;
}
}
else
{
nNear
=
FTS5_DEFAULT_NEARDIST
;
}
pNear
-
>
nNear
=
nNear
;
}
}
static
Fts5Colset
*
fts5ParseColset
(
Fts5Parse
*
pParse
Fts5Colset
*
p
int
iCol
)
{
int
nCol
=
p
?
p
-
>
nCol
:
0
;
Fts5Colset
*
pNew
;
assert
(
pParse
-
>
rc
=
=
SQLITE_OK
)
;
assert
(
iCol
>
=
0
&
&
iCol
<
pParse
-
>
pConfig
-
>
nCol
)
;
pNew
=
sqlite3_realloc64
(
p
sizeof
(
Fts5Colset
)
+
sizeof
(
int
)
*
nCol
)
;
if
(
pNew
=
=
0
)
{
pParse
-
>
rc
=
SQLITE_NOMEM
;
}
else
{
int
*
aiCol
=
pNew
-
>
aiCol
;
int
i
j
;
for
(
i
=
0
;
i
<
nCol
;
i
+
+
)
{
if
(
aiCol
[
i
]
=
=
iCol
)
return
pNew
;
if
(
aiCol
[
i
]
>
iCol
)
break
;
}
for
(
j
=
nCol
;
j
>
i
;
j
-
-
)
{
aiCol
[
j
]
=
aiCol
[
j
-
1
]
;
}
aiCol
[
i
]
=
iCol
;
pNew
-
>
nCol
=
nCol
+
1
;
#
ifndef
NDEBUG
for
(
i
=
1
;
i
<
pNew
-
>
nCol
;
i
+
+
)
assert
(
pNew
-
>
aiCol
[
i
]
>
pNew
-
>
aiCol
[
i
-
1
]
)
;
#
endif
}
return
pNew
;
}
static
Fts5Colset
*
sqlite3Fts5ParseColsetInvert
(
Fts5Parse
*
pParse
Fts5Colset
*
p
)
{
Fts5Colset
*
pRet
;
int
nCol
=
pParse
-
>
pConfig
-
>
nCol
;
pRet
=
(
Fts5Colset
*
)
sqlite3Fts5MallocZero
(
&
pParse
-
>
rc
sizeof
(
Fts5Colset
)
+
sizeof
(
int
)
*
nCol
)
;
if
(
pRet
)
{
int
i
;
int
iOld
=
0
;
for
(
i
=
0
;
i
<
nCol
;
i
+
+
)
{
if
(
iOld
>
=
p
-
>
nCol
|
|
p
-
>
aiCol
[
iOld
]
!
=
i
)
{
pRet
-
>
aiCol
[
pRet
-
>
nCol
+
+
]
=
i
;
}
else
{
iOld
+
+
;
}
}
}
sqlite3_free
(
p
)
;
return
pRet
;
}
static
Fts5Colset
*
sqlite3Fts5ParseColset
(
Fts5Parse
*
pParse
Fts5Colset
*
pColset
Fts5Token
*
p
)
{
Fts5Colset
*
pRet
=
0
;
int
iCol
;
char
*
z
;
z
=
sqlite3Fts5Strndup
(
&
pParse
-
>
rc
p
-
>
p
p
-
>
n
)
;
if
(
pParse
-
>
rc
=
=
SQLITE_OK
)
{
Fts5Config
*
pConfig
=
pParse
-
>
pConfig
;
sqlite3Fts5Dequote
(
z
)
;
for
(
iCol
=
0
;
iCol
<
pConfig
-
>
nCol
;
iCol
+
+
)
{
if
(
0
=
=
sqlite3_stricmp
(
pConfig
-
>
azCol
[
iCol
]
z
)
)
break
;
}
if
(
iCol
=
=
pConfig
-
>
nCol
)
{
sqlite3Fts5ParseError
(
pParse
"
no
such
column
:
%
s
"
z
)
;
}
else
{
pRet
=
fts5ParseColset
(
pParse
pColset
iCol
)
;
}
sqlite3_free
(
z
)
;
}
if
(
pRet
=
=
0
)
{
assert
(
pParse
-
>
rc
!
=
SQLITE_OK
)
;
sqlite3_free
(
pColset
)
;
}
return
pRet
;
}
static
Fts5Colset
*
fts5CloneColset
(
int
*
pRc
Fts5Colset
*
pOrig
)
{
Fts5Colset
*
pRet
;
if
(
pOrig
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5Colset
)
+
(
pOrig
-
>
nCol
-
1
)
*
sizeof
(
int
)
;
pRet
=
(
Fts5Colset
*
)
sqlite3Fts5MallocZero
(
pRc
nByte
)
;
if
(
pRet
)
{
memcpy
(
pRet
pOrig
(
size_t
)
nByte
)
;
}
}
else
{
pRet
=
0
;
}
return
pRet
;
}
static
void
fts5MergeColset
(
Fts5Colset
*
pColset
Fts5Colset
*
pMerge
)
{
int
iIn
=
0
;
int
iMerge
=
0
;
int
iOut
=
0
;
while
(
iIn
<
pColset
-
>
nCol
&
&
iMerge
<
pMerge
-
>
nCol
)
{
int
iDiff
=
pColset
-
>
aiCol
[
iIn
]
-
pMerge
-
>
aiCol
[
iMerge
]
;
if
(
iDiff
=
=
0
)
{
pColset
-
>
aiCol
[
iOut
+
+
]
=
pMerge
-
>
aiCol
[
iMerge
]
;
iMerge
+
+
;
iIn
+
+
;
}
else
if
(
iDiff
>
0
)
{
iMerge
+
+
;
}
else
{
iIn
+
+
;
}
}
pColset
-
>
nCol
=
iOut
;
}
static
void
fts5ParseSetColset
(
Fts5Parse
*
pParse
Fts5ExprNode
*
pNode
Fts5Colset
*
pColset
Fts5Colset
*
*
ppFree
)
{
if
(
pParse
-
>
rc
=
=
SQLITE_OK
)
{
assert
(
pNode
-
>
eType
=
=
FTS5_TERM
|
|
pNode
-
>
eType
=
=
FTS5_STRING
|
|
pNode
-
>
eType
=
=
FTS5_AND
|
|
pNode
-
>
eType
=
=
FTS5_OR
|
|
pNode
-
>
eType
=
=
FTS5_NOT
|
|
pNode
-
>
eType
=
=
FTS5_EOF
)
;
if
(
pNode
-
>
eType
=
=
FTS5_STRING
|
|
pNode
-
>
eType
=
=
FTS5_TERM
)
{
Fts5ExprNearset
*
pNear
=
pNode
-
>
pNear
;
if
(
pNear
-
>
pColset
)
{
fts5MergeColset
(
pNear
-
>
pColset
pColset
)
;
if
(
pNear
-
>
pColset
-
>
nCol
=
=
0
)
{
pNode
-
>
eType
=
FTS5_EOF
;
pNode
-
>
xNext
=
0
;
}
}
else
if
(
*
ppFree
)
{
pNear
-
>
pColset
=
pColset
;
*
ppFree
=
0
;
}
else
{
pNear
-
>
pColset
=
fts5CloneColset
(
&
pParse
-
>
rc
pColset
)
;
}
}
else
{
int
i
;
assert
(
pNode
-
>
eType
!
=
FTS5_EOF
|
|
pNode
-
>
nChild
=
=
0
)
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
fts5ParseSetColset
(
pParse
pNode
-
>
apChild
[
i
]
pColset
ppFree
)
;
}
}
}
}
static
void
sqlite3Fts5ParseSetColset
(
Fts5Parse
*
pParse
Fts5ExprNode
*
pExpr
Fts5Colset
*
pColset
)
{
Fts5Colset
*
pFree
=
pColset
;
if
(
pParse
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
sqlite3Fts5ParseError
(
pParse
"
fts5
:
column
queries
are
not
supported
(
detail
=
none
)
"
)
;
}
else
{
fts5ParseSetColset
(
pParse
pExpr
pColset
&
pFree
)
;
}
sqlite3_free
(
pFree
)
;
}
static
void
fts5ExprAssignXNext
(
Fts5ExprNode
*
pNode
)
{
switch
(
pNode
-
>
eType
)
{
case
FTS5_STRING
:
{
Fts5ExprNearset
*
pNear
=
pNode
-
>
pNear
;
if
(
pNear
-
>
nPhrase
=
=
1
&
&
pNear
-
>
apPhrase
[
0
]
-
>
nTerm
=
=
1
&
&
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
0
]
.
pSynonym
=
=
0
&
&
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
0
]
.
bFirst
=
=
0
)
{
pNode
-
>
eType
=
FTS5_TERM
;
pNode
-
>
xNext
=
fts5ExprNodeNext_TERM
;
}
else
{
pNode
-
>
xNext
=
fts5ExprNodeNext_STRING
;
}
break
;
}
;
case
FTS5_OR
:
{
pNode
-
>
xNext
=
fts5ExprNodeNext_OR
;
break
;
}
;
case
FTS5_AND
:
{
pNode
-
>
xNext
=
fts5ExprNodeNext_AND
;
break
;
}
;
default
:
assert
(
pNode
-
>
eType
=
=
FTS5_NOT
)
;
{
pNode
-
>
xNext
=
fts5ExprNodeNext_NOT
;
break
;
}
;
}
}
static
void
fts5ExprAddChildren
(
Fts5ExprNode
*
p
Fts5ExprNode
*
pSub
)
{
int
ii
=
p
-
>
nChild
;
if
(
p
-
>
eType
!
=
FTS5_NOT
&
&
pSub
-
>
eType
=
=
p
-
>
eType
)
{
int
nByte
=
sizeof
(
Fts5ExprNode
*
)
*
pSub
-
>
nChild
;
memcpy
(
&
p
-
>
apChild
[
p
-
>
nChild
]
pSub
-
>
apChild
nByte
)
;
p
-
>
nChild
+
=
pSub
-
>
nChild
;
sqlite3_free
(
pSub
)
;
}
else
{
p
-
>
apChild
[
p
-
>
nChild
+
+
]
=
pSub
;
}
for
(
;
ii
<
p
-
>
nChild
;
ii
+
+
)
{
p
-
>
iHeight
=
MAX
(
p
-
>
iHeight
p
-
>
apChild
[
ii
]
-
>
iHeight
+
1
)
;
}
}
static
Fts5ExprNode
*
fts5ParsePhraseToAnd
(
Fts5Parse
*
pParse
Fts5ExprNearset
*
pNear
)
{
int
nTerm
=
pNear
-
>
apPhrase
[
0
]
-
>
nTerm
;
int
ii
;
int
nByte
;
Fts5ExprNode
*
pRet
;
assert
(
pNear
-
>
nPhrase
=
=
1
)
;
assert
(
pParse
-
>
bPhraseToAnd
)
;
nByte
=
sizeof
(
Fts5ExprNode
)
+
nTerm
*
sizeof
(
Fts5ExprNode
*
)
;
pRet
=
(
Fts5ExprNode
*
)
sqlite3Fts5MallocZero
(
&
pParse
-
>
rc
nByte
)
;
if
(
pRet
)
{
pRet
-
>
eType
=
FTS5_AND
;
pRet
-
>
nChild
=
nTerm
;
pRet
-
>
iHeight
=
1
;
fts5ExprAssignXNext
(
pRet
)
;
pParse
-
>
nPhrase
-
-
;
for
(
ii
=
0
;
ii
<
nTerm
;
ii
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
(
Fts5ExprPhrase
*
)
sqlite3Fts5MallocZero
(
&
pParse
-
>
rc
sizeof
(
Fts5ExprPhrase
)
)
;
if
(
pPhrase
)
{
if
(
parseGrowPhraseArray
(
pParse
)
)
{
fts5ExprPhraseFree
(
pPhrase
)
;
}
else
{
Fts5ExprTerm
*
p
=
&
pNear
-
>
apPhrase
[
0
]
-
>
aTerm
[
ii
]
;
Fts5ExprTerm
*
pTo
=
&
pPhrase
-
>
aTerm
[
0
]
;
pParse
-
>
apPhrase
[
pParse
-
>
nPhrase
+
+
]
=
pPhrase
;
pPhrase
-
>
nTerm
=
1
;
pTo
-
>
pTerm
=
sqlite3Fts5Strndup
(
&
pParse
-
>
rc
p
-
>
pTerm
p
-
>
nFullTerm
)
;
pTo
-
>
nQueryTerm
=
p
-
>
nQueryTerm
;
pTo
-
>
nFullTerm
=
p
-
>
nFullTerm
;
pRet
-
>
apChild
[
ii
]
=
sqlite3Fts5ParseNode
(
pParse
FTS5_STRING
0
0
sqlite3Fts5ParseNearset
(
pParse
0
pPhrase
)
)
;
}
}
}
if
(
pParse
-
>
rc
)
{
sqlite3Fts5ParseNodeFree
(
pRet
)
;
pRet
=
0
;
}
else
{
sqlite3Fts5ParseNearsetFree
(
pNear
)
;
}
}
return
pRet
;
}
static
Fts5ExprNode
*
sqlite3Fts5ParseNode
(
Fts5Parse
*
pParse
int
eType
Fts5ExprNode
*
pLeft
Fts5ExprNode
*
pRight
Fts5ExprNearset
*
pNear
)
{
Fts5ExprNode
*
pRet
=
0
;
if
(
pParse
-
>
rc
=
=
SQLITE_OK
)
{
int
nChild
=
0
;
sqlite3_int64
nByte
;
assert
(
(
eType
!
=
FTS5_STRING
&
&
!
pNear
)
|
|
(
eType
=
=
FTS5_STRING
&
&
!
pLeft
&
&
!
pRight
)
)
;
if
(
eType
=
=
FTS5_STRING
&
&
pNear
=
=
0
)
return
0
;
if
(
eType
!
=
FTS5_STRING
&
&
pLeft
=
=
0
)
return
pRight
;
if
(
eType
!
=
FTS5_STRING
&
&
pRight
=
=
0
)
return
pLeft
;
if
(
eType
=
=
FTS5_STRING
&
&
pParse
-
>
bPhraseToAnd
&
&
pNear
-
>
apPhrase
[
0
]
-
>
nTerm
>
1
)
{
pRet
=
fts5ParsePhraseToAnd
(
pParse
pNear
)
;
}
else
{
if
(
eType
=
=
FTS5_NOT
)
{
nChild
=
2
;
}
else
if
(
eType
=
=
FTS5_AND
|
|
eType
=
=
FTS5_OR
)
{
nChild
=
2
;
if
(
pLeft
-
>
eType
=
=
eType
)
nChild
+
=
pLeft
-
>
nChild
-
1
;
if
(
pRight
-
>
eType
=
=
eType
)
nChild
+
=
pRight
-
>
nChild
-
1
;
}
nByte
=
sizeof
(
Fts5ExprNode
)
+
sizeof
(
Fts5ExprNode
*
)
*
(
nChild
-
1
)
;
pRet
=
(
Fts5ExprNode
*
)
sqlite3Fts5MallocZero
(
&
pParse
-
>
rc
nByte
)
;
if
(
pRet
)
{
pRet
-
>
eType
=
eType
;
pRet
-
>
pNear
=
pNear
;
fts5ExprAssignXNext
(
pRet
)
;
if
(
eType
=
=
FTS5_STRING
)
{
int
iPhrase
;
for
(
iPhrase
=
0
;
iPhrase
<
pNear
-
>
nPhrase
;
iPhrase
+
+
)
{
pNear
-
>
apPhrase
[
iPhrase
]
-
>
pNode
=
pRet
;
if
(
pNear
-
>
apPhrase
[
iPhrase
]
-
>
nTerm
=
=
0
)
{
pRet
-
>
xNext
=
0
;
pRet
-
>
eType
=
FTS5_EOF
;
}
}
if
(
pParse
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
0
]
;
if
(
pNear
-
>
nPhrase
!
=
1
|
|
pPhrase
-
>
nTerm
>
1
|
|
(
pPhrase
-
>
nTerm
>
0
&
&
pPhrase
-
>
aTerm
[
0
]
.
bFirst
)
)
{
sqlite3Fts5ParseError
(
pParse
"
fts5
:
%
s
queries
are
not
supported
(
detail
!
=
full
)
"
pNear
-
>
nPhrase
=
=
1
?
"
phrase
"
:
"
NEAR
"
)
;
sqlite3Fts5ParseNodeFree
(
pRet
)
;
pRet
=
0
;
pNear
=
0
;
assert
(
pLeft
=
=
0
&
&
pRight
=
=
0
)
;
}
}
}
else
{
assert
(
pNear
=
=
0
)
;
fts5ExprAddChildren
(
pRet
pLeft
)
;
fts5ExprAddChildren
(
pRet
pRight
)
;
pLeft
=
pRight
=
0
;
if
(
pRet
-
>
iHeight
>
SQLITE_FTS5_MAX_EXPR_DEPTH
)
{
sqlite3Fts5ParseError
(
pParse
"
fts5
expression
tree
is
too
large
(
maximum
depth
%
d
)
"
SQLITE_FTS5_MAX_EXPR_DEPTH
)
;
sqlite3Fts5ParseNodeFree
(
pRet
)
;
pRet
=
0
;
}
}
}
}
}
if
(
pRet
=
=
0
)
{
assert
(
pParse
-
>
rc
!
=
SQLITE_OK
)
;
sqlite3Fts5ParseNodeFree
(
pLeft
)
;
sqlite3Fts5ParseNodeFree
(
pRight
)
;
sqlite3Fts5ParseNearsetFree
(
pNear
)
;
}
return
pRet
;
}
static
Fts5ExprNode
*
sqlite3Fts5ParseImplicitAnd
(
Fts5Parse
*
pParse
Fts5ExprNode
*
pLeft
Fts5ExprNode
*
pRight
)
{
Fts5ExprNode
*
pRet
=
0
;
Fts5ExprNode
*
pPrev
;
if
(
pParse
-
>
rc
)
{
sqlite3Fts5ParseNodeFree
(
pLeft
)
;
sqlite3Fts5ParseNodeFree
(
pRight
)
;
}
else
{
assert
(
pLeft
-
>
eType
=
=
FTS5_STRING
|
|
pLeft
-
>
eType
=
=
FTS5_TERM
|
|
pLeft
-
>
eType
=
=
FTS5_EOF
|
|
pLeft
-
>
eType
=
=
FTS5_AND
)
;
assert
(
pRight
-
>
eType
=
=
FTS5_STRING
|
|
pRight
-
>
eType
=
=
FTS5_TERM
|
|
pRight
-
>
eType
=
=
FTS5_EOF
|
|
(
pRight
-
>
eType
=
=
FTS5_AND
&
&
pParse
-
>
bPhraseToAnd
)
)
;
if
(
pLeft
-
>
eType
=
=
FTS5_AND
)
{
pPrev
=
pLeft
-
>
apChild
[
pLeft
-
>
nChild
-
1
]
;
}
else
{
pPrev
=
pLeft
;
}
assert
(
pPrev
-
>
eType
=
=
FTS5_STRING
|
|
pPrev
-
>
eType
=
=
FTS5_TERM
|
|
pPrev
-
>
eType
=
=
FTS5_EOF
)
;
if
(
pRight
-
>
eType
=
=
FTS5_EOF
)
{
assert
(
pParse
-
>
apPhrase
!
=
0
)
;
assert
(
pParse
-
>
nPhrase
>
0
)
;
assert
(
pParse
-
>
apPhrase
[
pParse
-
>
nPhrase
-
1
]
=
=
pRight
-
>
pNear
-
>
apPhrase
[
0
]
)
;
sqlite3Fts5ParseNodeFree
(
pRight
)
;
pRet
=
pLeft
;
pParse
-
>
nPhrase
-
-
;
}
else
if
(
pPrev
-
>
eType
=
=
FTS5_EOF
)
{
Fts5ExprPhrase
*
*
ap
;
if
(
pPrev
=
=
pLeft
)
{
pRet
=
pRight
;
}
else
{
pLeft
-
>
apChild
[
pLeft
-
>
nChild
-
1
]
=
pRight
;
pRet
=
pLeft
;
}
ap
=
&
pParse
-
>
apPhrase
[
pParse
-
>
nPhrase
-
1
-
pRight
-
>
pNear
-
>
nPhrase
]
;
assert
(
ap
[
0
]
=
=
pPrev
-
>
pNear
-
>
apPhrase
[
0
]
)
;
memmove
(
ap
&
ap
[
1
]
sizeof
(
Fts5ExprPhrase
*
)
*
pRight
-
>
pNear
-
>
nPhrase
)
;
pParse
-
>
nPhrase
-
-
;
sqlite3Fts5ParseNodeFree
(
pPrev
)
;
}
else
{
pRet
=
sqlite3Fts5ParseNode
(
pParse
FTS5_AND
pLeft
pRight
0
)
;
}
}
return
pRet
;
}
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
char
*
fts5ExprTermPrint
(
Fts5ExprTerm
*
pTerm
)
{
sqlite3_int64
nByte
=
0
;
Fts5ExprTerm
*
p
;
char
*
zQuoted
;
for
(
p
=
pTerm
;
p
;
p
=
p
-
>
pSynonym
)
{
nByte
+
=
pTerm
-
>
nQueryTerm
*
2
+
3
+
2
;
}
zQuoted
=
sqlite3_malloc64
(
nByte
)
;
if
(
zQuoted
)
{
int
i
=
0
;
for
(
p
=
pTerm
;
p
;
p
=
p
-
>
pSynonym
)
{
char
*
zIn
=
p
-
>
pTerm
;
char
*
zEnd
=
&
zIn
[
p
-
>
nQueryTerm
]
;
zQuoted
[
i
+
+
]
=
'
"
'
;
while
(
zIn
<
zEnd
)
{
if
(
*
zIn
=
=
'
"
'
)
zQuoted
[
i
+
+
]
=
'
"
'
;
zQuoted
[
i
+
+
]
=
*
zIn
+
+
;
}
zQuoted
[
i
+
+
]
=
'
"
'
;
if
(
p
-
>
pSynonym
)
zQuoted
[
i
+
+
]
=
'
|
'
;
}
if
(
pTerm
-
>
bPrefix
)
{
zQuoted
[
i
+
+
]
=
'
'
;
zQuoted
[
i
+
+
]
=
'
*
'
;
}
zQuoted
[
i
+
+
]
=
'
\
0
'
;
}
return
zQuoted
;
}
static
char
*
fts5PrintfAppend
(
char
*
zApp
const
char
*
zFmt
.
.
.
)
{
char
*
zNew
;
va_list
ap
;
va_start
(
ap
zFmt
)
;
zNew
=
sqlite3_vmprintf
(
zFmt
ap
)
;
va_end
(
ap
)
;
if
(
zApp
&
&
zNew
)
{
char
*
zNew2
=
sqlite3_mprintf
(
"
%
s
%
s
"
zApp
zNew
)
;
sqlite3_free
(
zNew
)
;
zNew
=
zNew2
;
}
sqlite3_free
(
zApp
)
;
return
zNew
;
}
static
char
*
fts5ExprPrintTcl
(
Fts5Config
*
pConfig
const
char
*
zNearsetCmd
Fts5ExprNode
*
pExpr
)
{
char
*
zRet
=
0
;
if
(
pExpr
-
>
eType
=
=
FTS5_STRING
|
|
pExpr
-
>
eType
=
=
FTS5_TERM
)
{
Fts5ExprNearset
*
pNear
=
pExpr
-
>
pNear
;
int
i
;
int
iTerm
;
zRet
=
fts5PrintfAppend
(
zRet
"
%
s
"
zNearsetCmd
)
;
if
(
zRet
=
=
0
)
return
0
;
if
(
pNear
-
>
pColset
)
{
int
*
aiCol
=
pNear
-
>
pColset
-
>
aiCol
;
int
nCol
=
pNear
-
>
pColset
-
>
nCol
;
if
(
nCol
=
=
1
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
-
col
%
d
"
aiCol
[
0
]
)
;
}
else
{
zRet
=
fts5PrintfAppend
(
zRet
"
-
col
{
%
d
"
aiCol
[
0
]
)
;
for
(
i
=
1
;
i
<
pNear
-
>
pColset
-
>
nCol
;
i
+
+
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
%
d
"
aiCol
[
i
]
)
;
}
zRet
=
fts5PrintfAppend
(
zRet
"
}
"
)
;
}
if
(
zRet
=
=
0
)
return
0
;
}
if
(
pNear
-
>
nPhrase
>
1
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
-
near
%
d
"
pNear
-
>
nNear
)
;
if
(
zRet
=
=
0
)
return
0
;
}
zRet
=
fts5PrintfAppend
(
zRet
"
-
-
"
)
;
if
(
zRet
=
=
0
)
return
0
;
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
i
]
;
zRet
=
fts5PrintfAppend
(
zRet
"
{
"
)
;
for
(
iTerm
=
0
;
zRet
&
&
iTerm
<
pPhrase
-
>
nTerm
;
iTerm
+
+
)
{
Fts5ExprTerm
*
p
=
&
pPhrase
-
>
aTerm
[
iTerm
]
;
zRet
=
fts5PrintfAppend
(
zRet
"
%
s
%
.
*
s
"
iTerm
=
=
0
?
"
"
:
"
"
p
-
>
nQueryTerm
p
-
>
pTerm
)
;
if
(
pPhrase
-
>
aTerm
[
iTerm
]
.
bPrefix
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
*
"
)
;
}
}
if
(
zRet
)
zRet
=
fts5PrintfAppend
(
zRet
"
}
"
)
;
if
(
zRet
=
=
0
)
return
0
;
}
}
else
if
(
pExpr
-
>
eType
=
=
0
)
{
zRet
=
sqlite3_mprintf
(
"
{
}
"
)
;
}
else
{
char
const
*
zOp
=
0
;
int
i
;
switch
(
pExpr
-
>
eType
)
{
case
FTS5_AND
:
zOp
=
"
AND
"
;
break
;
case
FTS5_NOT
:
zOp
=
"
NOT
"
;
break
;
default
:
assert
(
pExpr
-
>
eType
=
=
FTS5_OR
)
;
zOp
=
"
OR
"
;
break
;
}
zRet
=
sqlite3_mprintf
(
"
%
s
"
zOp
)
;
for
(
i
=
0
;
zRet
&
&
i
<
pExpr
-
>
nChild
;
i
+
+
)
{
char
*
z
=
fts5ExprPrintTcl
(
pConfig
zNearsetCmd
pExpr
-
>
apChild
[
i
]
)
;
if
(
!
z
)
{
sqlite3_free
(
zRet
)
;
zRet
=
0
;
}
else
{
zRet
=
fts5PrintfAppend
(
zRet
"
[
%
z
]
"
z
)
;
}
}
}
return
zRet
;
}
static
char
*
fts5ExprPrint
(
Fts5Config
*
pConfig
Fts5ExprNode
*
pExpr
)
{
char
*
zRet
=
0
;
if
(
pExpr
-
>
eType
=
=
0
)
{
return
sqlite3_mprintf
(
"
\
"
\
"
"
)
;
}
else
if
(
pExpr
-
>
eType
=
=
FTS5_STRING
|
|
pExpr
-
>
eType
=
=
FTS5_TERM
)
{
Fts5ExprNearset
*
pNear
=
pExpr
-
>
pNear
;
int
i
;
int
iTerm
;
if
(
pNear
-
>
pColset
)
{
int
ii
;
Fts5Colset
*
pColset
=
pNear
-
>
pColset
;
if
(
pColset
-
>
nCol
>
1
)
zRet
=
fts5PrintfAppend
(
zRet
"
{
"
)
;
for
(
ii
=
0
;
ii
<
pColset
-
>
nCol
;
ii
+
+
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
%
s
%
s
"
pConfig
-
>
azCol
[
pColset
-
>
aiCol
[
ii
]
]
ii
=
=
pColset
-
>
nCol
-
1
?
"
"
:
"
"
)
;
}
if
(
zRet
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
%
s
:
"
pColset
-
>
nCol
>
1
?
"
}
"
:
"
"
)
;
}
if
(
zRet
=
=
0
)
return
0
;
}
if
(
pNear
-
>
nPhrase
>
1
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
NEAR
(
"
)
;
if
(
zRet
=
=
0
)
return
0
;
}
for
(
i
=
0
;
i
<
pNear
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprPhrase
*
pPhrase
=
pNear
-
>
apPhrase
[
i
]
;
if
(
i
!
=
0
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
"
)
;
if
(
zRet
=
=
0
)
return
0
;
}
for
(
iTerm
=
0
;
iTerm
<
pPhrase
-
>
nTerm
;
iTerm
+
+
)
{
char
*
zTerm
=
fts5ExprTermPrint
(
&
pPhrase
-
>
aTerm
[
iTerm
]
)
;
if
(
zTerm
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
%
s
%
s
"
iTerm
=
=
0
?
"
"
:
"
+
"
zTerm
)
;
sqlite3_free
(
zTerm
)
;
}
if
(
zTerm
=
=
0
|
|
zRet
=
=
0
)
{
sqlite3_free
(
zRet
)
;
return
0
;
}
}
}
if
(
pNear
-
>
nPhrase
>
1
)
{
zRet
=
fts5PrintfAppend
(
zRet
"
%
d
)
"
pNear
-
>
nNear
)
;
if
(
zRet
=
=
0
)
return
0
;
}
}
else
{
char
const
*
zOp
=
0
;
int
i
;
switch
(
pExpr
-
>
eType
)
{
case
FTS5_AND
:
zOp
=
"
AND
"
;
break
;
case
FTS5_NOT
:
zOp
=
"
NOT
"
;
break
;
default
:
assert
(
pExpr
-
>
eType
=
=
FTS5_OR
)
;
zOp
=
"
OR
"
;
break
;
}
for
(
i
=
0
;
i
<
pExpr
-
>
nChild
;
i
+
+
)
{
char
*
z
=
fts5ExprPrint
(
pConfig
pExpr
-
>
apChild
[
i
]
)
;
if
(
z
=
=
0
)
{
sqlite3_free
(
zRet
)
;
zRet
=
0
;
}
else
{
int
e
=
pExpr
-
>
apChild
[
i
]
-
>
eType
;
int
b
=
(
e
!
=
FTS5_STRING
&
&
e
!
=
FTS5_TERM
&
&
e
!
=
FTS5_EOF
)
;
zRet
=
fts5PrintfAppend
(
zRet
"
%
s
%
s
%
z
%
s
"
(
i
=
=
0
?
"
"
:
zOp
)
(
b
?
"
(
"
:
"
"
)
z
(
b
?
"
)
"
:
"
"
)
)
;
}
if
(
zRet
=
=
0
)
break
;
}
}
return
zRet
;
}
static
void
fts5ExprFunction
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
int
bTcl
)
{
Fts5Global
*
pGlobal
=
(
Fts5Global
*
)
sqlite3_user_data
(
pCtx
)
;
sqlite3
*
db
=
sqlite3_context_db_handle
(
pCtx
)
;
const
char
*
zExpr
=
0
;
char
*
zErr
=
0
;
Fts5Expr
*
pExpr
=
0
;
int
rc
;
int
i
;
const
char
*
*
azConfig
;
const
char
*
zNearsetCmd
=
"
nearset
"
;
int
nConfig
;
Fts5Config
*
pConfig
=
0
;
int
iArg
=
1
;
if
(
nArg
<
1
)
{
zErr
=
sqlite3_mprintf
(
"
wrong
number
of
arguments
to
function
%
s
"
bTcl
?
"
fts5_expr_tcl
"
:
"
fts5_expr
"
)
;
sqlite3_result_error
(
pCtx
zErr
-
1
)
;
sqlite3_free
(
zErr
)
;
return
;
}
if
(
bTcl
&
&
nArg
>
1
)
{
zNearsetCmd
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
1
]
)
;
iArg
=
2
;
}
nConfig
=
3
+
(
nArg
-
iArg
)
;
azConfig
=
(
const
char
*
*
)
sqlite3_malloc64
(
sizeof
(
char
*
)
*
nConfig
)
;
if
(
azConfig
=
=
0
)
{
sqlite3_result_error_nomem
(
pCtx
)
;
return
;
}
azConfig
[
0
]
=
0
;
azConfig
[
1
]
=
"
main
"
;
azConfig
[
2
]
=
"
tbl
"
;
for
(
i
=
3
;
iArg
<
nArg
;
iArg
+
+
)
{
const
char
*
z
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
iArg
]
)
;
azConfig
[
i
+
+
]
=
(
z
?
z
:
"
"
)
;
}
zExpr
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
0
]
)
;
if
(
zExpr
=
=
0
)
zExpr
=
"
"
;
rc
=
sqlite3Fts5ConfigParse
(
pGlobal
db
nConfig
azConfig
&
pConfig
&
zErr
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ExprNew
(
pConfig
0
pConfig
-
>
nCol
zExpr
&
pExpr
&
zErr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
char
*
zText
;
if
(
pExpr
-
>
pRoot
-
>
xNext
=
=
0
)
{
zText
=
sqlite3_mprintf
(
"
"
)
;
}
else
if
(
bTcl
)
{
zText
=
fts5ExprPrintTcl
(
pConfig
zNearsetCmd
pExpr
-
>
pRoot
)
;
}
else
{
zText
=
fts5ExprPrint
(
pConfig
pExpr
-
>
pRoot
)
;
}
if
(
zText
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
sqlite3_result_text
(
pCtx
zText
-
1
SQLITE_TRANSIENT
)
;
sqlite3_free
(
zText
)
;
}
}
if
(
rc
!
=
SQLITE_OK
)
{
if
(
zErr
)
{
sqlite3_result_error
(
pCtx
zErr
-
1
)
;
sqlite3_free
(
zErr
)
;
}
else
{
sqlite3_result_error_code
(
pCtx
rc
)
;
}
}
sqlite3_free
(
(
void
*
)
azConfig
)
;
sqlite3Fts5ConfigFree
(
pConfig
)
;
sqlite3Fts5ExprFree
(
pExpr
)
;
}
static
void
fts5ExprFunctionHr
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
)
{
fts5ExprFunction
(
pCtx
nArg
apVal
0
)
;
}
static
void
fts5ExprFunctionTcl
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
)
{
fts5ExprFunction
(
pCtx
nArg
apVal
1
)
;
}
static
void
fts5ExprIsAlnum
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
)
{
int
iCode
;
u8
aArr
[
32
]
;
if
(
nArg
!
=
1
)
{
sqlite3_result_error
(
pCtx
"
wrong
number
of
arguments
to
function
fts5_isalnum
"
-
1
)
;
return
;
}
memset
(
aArr
0
sizeof
(
aArr
)
)
;
sqlite3Fts5UnicodeCatParse
(
"
L
*
"
aArr
)
;
sqlite3Fts5UnicodeCatParse
(
"
N
*
"
aArr
)
;
sqlite3Fts5UnicodeCatParse
(
"
Co
"
aArr
)
;
iCode
=
sqlite3_value_int
(
apVal
[
0
]
)
;
sqlite3_result_int
(
pCtx
aArr
[
sqlite3Fts5UnicodeCategory
(
(
u32
)
iCode
)
]
)
;
}
static
void
fts5ExprFold
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
)
{
if
(
nArg
!
=
1
&
&
nArg
!
=
2
)
{
sqlite3_result_error
(
pCtx
"
wrong
number
of
arguments
to
function
fts5_fold
"
-
1
)
;
}
else
{
int
iCode
;
int
bRemoveDiacritics
=
0
;
iCode
=
sqlite3_value_int
(
apVal
[
0
]
)
;
if
(
nArg
=
=
2
)
bRemoveDiacritics
=
sqlite3_value_int
(
apVal
[
1
]
)
;
sqlite3_result_int
(
pCtx
sqlite3Fts5UnicodeFold
(
iCode
bRemoveDiacritics
)
)
;
}
}
#
endif
static
int
sqlite3Fts5ExprInit
(
Fts5Global
*
pGlobal
sqlite3
*
db
)
{
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
struct
Fts5ExprFunc
{
const
char
*
z
;
void
(
*
x
)
(
sqlite3_context
*
int
sqlite3_value
*
*
)
;
}
aFunc
[
]
=
{
{
"
fts5_expr
"
fts5ExprFunctionHr
}
{
"
fts5_expr_tcl
"
fts5ExprFunctionTcl
}
{
"
fts5_isalnum
"
fts5ExprIsAlnum
}
{
"
fts5_fold
"
fts5ExprFold
}
}
;
int
i
;
int
rc
=
SQLITE_OK
;
void
*
pCtx
=
(
void
*
)
pGlobal
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
ArraySize
(
aFunc
)
;
i
+
+
)
{
struct
Fts5ExprFunc
*
p
=
&
aFunc
[
i
]
;
rc
=
sqlite3_create_function
(
db
p
-
>
z
-
1
SQLITE_UTF8
pCtx
p
-
>
x
0
0
)
;
}
#
else
int
rc
=
SQLITE_OK
;
UNUSED_PARAM2
(
pGlobal
db
)
;
#
endif
#
ifndef
NDEBUG
(
void
)
sqlite3Fts5ParserTrace
;
#
endif
(
void
)
sqlite3Fts5ParserFallback
;
return
rc
;
}
static
int
sqlite3Fts5ExprPhraseCount
(
Fts5Expr
*
pExpr
)
{
return
(
pExpr
?
pExpr
-
>
nPhrase
:
0
)
;
}
static
int
sqlite3Fts5ExprPhraseSize
(
Fts5Expr
*
pExpr
int
iPhrase
)
{
if
(
iPhrase
<
0
|
|
iPhrase
>
=
pExpr
-
>
nPhrase
)
return
0
;
return
pExpr
-
>
apExprPhrase
[
iPhrase
]
-
>
nTerm
;
}
static
int
sqlite3Fts5ExprPoslist
(
Fts5Expr
*
pExpr
int
iPhrase
const
u8
*
*
pa
)
{
int
nRet
;
Fts5ExprPhrase
*
pPhrase
=
pExpr
-
>
apExprPhrase
[
iPhrase
]
;
Fts5ExprNode
*
pNode
=
pPhrase
-
>
pNode
;
if
(
pNode
-
>
bEof
=
=
0
&
&
pNode
-
>
iRowid
=
=
pExpr
-
>
pRoot
-
>
iRowid
)
{
*
pa
=
pPhrase
-
>
poslist
.
p
;
nRet
=
pPhrase
-
>
poslist
.
n
;
}
else
{
*
pa
=
0
;
nRet
=
0
;
}
return
nRet
;
}
struct
Fts5PoslistPopulator
{
Fts5PoslistWriter
writer
;
int
bOk
;
int
bMiss
;
}
;
static
Fts5PoslistPopulator
*
sqlite3Fts5ExprClearPoslists
(
Fts5Expr
*
pExpr
int
bLive
)
{
Fts5PoslistPopulator
*
pRet
;
pRet
=
sqlite3_malloc64
(
sizeof
(
Fts5PoslistPopulator
)
*
pExpr
-
>
nPhrase
)
;
if
(
pRet
)
{
int
i
;
memset
(
pRet
0
sizeof
(
Fts5PoslistPopulator
)
*
pExpr
-
>
nPhrase
)
;
for
(
i
=
0
;
i
<
pExpr
-
>
nPhrase
;
i
+
+
)
{
Fts5Buffer
*
pBuf
=
&
pExpr
-
>
apExprPhrase
[
i
]
-
>
poslist
;
Fts5ExprNode
*
pNode
=
pExpr
-
>
apExprPhrase
[
i
]
-
>
pNode
;
assert
(
pExpr
-
>
apExprPhrase
[
i
]
-
>
nTerm
<
=
1
)
;
if
(
bLive
&
&
(
pBuf
-
>
n
=
=
0
|
|
pNode
-
>
iRowid
!
=
pExpr
-
>
pRoot
-
>
iRowid
|
|
pNode
-
>
bEof
)
)
{
pRet
[
i
]
.
bMiss
=
1
;
}
else
{
pBuf
-
>
n
=
0
;
}
}
}
return
pRet
;
}
struct
Fts5ExprCtx
{
Fts5Expr
*
pExpr
;
Fts5PoslistPopulator
*
aPopulator
;
i64
iOff
;
}
;
typedef
struct
Fts5ExprCtx
Fts5ExprCtx
;
static
int
fts5ExprColsetTest
(
Fts5Colset
*
pColset
int
iCol
)
{
int
i
;
for
(
i
=
0
;
i
<
pColset
-
>
nCol
;
i
+
+
)
{
if
(
pColset
-
>
aiCol
[
i
]
=
=
iCol
)
return
1
;
}
return
0
;
}
static
int
fts5QueryTerm
(
const
char
*
pToken
int
nToken
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
nToken
&
&
pToken
[
ii
]
;
ii
+
+
)
{
}
return
ii
;
}
static
int
fts5ExprPopulatePoslistsCb
(
void
*
pCtx
int
tflags
const
char
*
pToken
int
nToken
int
iUnused1
int
iUnused2
)
{
Fts5ExprCtx
*
p
=
(
Fts5ExprCtx
*
)
pCtx
;
Fts5Expr
*
pExpr
=
p
-
>
pExpr
;
int
i
;
int
nQuery
=
nToken
;
i64
iRowid
=
pExpr
-
>
pRoot
-
>
iRowid
;
UNUSED_PARAM2
(
iUnused1
iUnused2
)
;
if
(
nQuery
>
FTS5_MAX_TOKEN_SIZE
)
nQuery
=
FTS5_MAX_TOKEN_SIZE
;
if
(
pExpr
-
>
pConfig
-
>
bTokendata
)
{
nQuery
=
fts5QueryTerm
(
pToken
nQuery
)
;
}
if
(
(
tflags
&
FTS5_TOKEN_COLOCATED
)
=
=
0
)
p
-
>
iOff
+
+
;
for
(
i
=
0
;
i
<
pExpr
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprTerm
*
pT
;
if
(
p
-
>
aPopulator
[
i
]
.
bOk
=
=
0
)
continue
;
for
(
pT
=
&
pExpr
-
>
apExprPhrase
[
i
]
-
>
aTerm
[
0
]
;
pT
;
pT
=
pT
-
>
pSynonym
)
{
if
(
(
pT
-
>
nQueryTerm
=
=
nQuery
|
|
(
pT
-
>
nQueryTerm
<
nQuery
&
&
pT
-
>
bPrefix
)
)
&
&
memcmp
(
pT
-
>
pTerm
pToken
pT
-
>
nQueryTerm
)
=
=
0
)
{
int
rc
=
sqlite3Fts5PoslistWriterAppend
(
&
pExpr
-
>
apExprPhrase
[
i
]
-
>
poslist
&
p
-
>
aPopulator
[
i
]
.
writer
p
-
>
iOff
)
;
if
(
rc
=
=
SQLITE_OK
&
&
(
pExpr
-
>
pConfig
-
>
bTokendata
|
|
pT
-
>
bPrefix
)
)
{
int
iCol
=
p
-
>
iOff
>
>
32
;
int
iTokOff
=
p
-
>
iOff
&
0x7FFFFFFF
;
rc
=
sqlite3Fts5IndexIterWriteTokendata
(
pT
-
>
pIter
pToken
nToken
iRowid
iCol
iTokOff
)
;
}
if
(
rc
)
return
rc
;
break
;
}
}
}
return
SQLITE_OK
;
}
static
int
sqlite3Fts5ExprPopulatePoslists
(
Fts5Config
*
pConfig
Fts5Expr
*
pExpr
Fts5PoslistPopulator
*
aPopulator
int
iCol
const
char
*
z
int
n
)
{
int
i
;
Fts5ExprCtx
sCtx
;
sCtx
.
pExpr
=
pExpr
;
sCtx
.
aPopulator
=
aPopulator
;
sCtx
.
iOff
=
(
(
(
i64
)
iCol
)
<
<
32
)
-
1
;
for
(
i
=
0
;
i
<
pExpr
-
>
nPhrase
;
i
+
+
)
{
Fts5ExprNode
*
pNode
=
pExpr
-
>
apExprPhrase
[
i
]
-
>
pNode
;
Fts5Colset
*
pColset
=
pNode
-
>
pNear
-
>
pColset
;
if
(
(
pColset
&
&
0
=
=
fts5ExprColsetTest
(
pColset
iCol
)
)
|
|
aPopulator
[
i
]
.
bMiss
)
{
aPopulator
[
i
]
.
bOk
=
0
;
}
else
{
aPopulator
[
i
]
.
bOk
=
1
;
}
}
return
sqlite3Fts5Tokenize
(
pConfig
FTS5_TOKENIZE_DOCUMENT
z
n
(
void
*
)
&
sCtx
fts5ExprPopulatePoslistsCb
)
;
}
static
void
fts5ExprClearPoslists
(
Fts5ExprNode
*
pNode
)
{
if
(
pNode
-
>
eType
=
=
FTS5_TERM
|
|
pNode
-
>
eType
=
=
FTS5_STRING
)
{
pNode
-
>
pNear
-
>
apPhrase
[
0
]
-
>
poslist
.
n
=
0
;
}
else
{
int
i
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
fts5ExprClearPoslists
(
pNode
-
>
apChild
[
i
]
)
;
}
}
}
static
int
fts5ExprCheckPoslists
(
Fts5ExprNode
*
pNode
i64
iRowid
)
{
pNode
-
>
iRowid
=
iRowid
;
pNode
-
>
bEof
=
0
;
switch
(
pNode
-
>
eType
)
{
case
0
:
case
FTS5_TERM
:
case
FTS5_STRING
:
return
(
pNode
-
>
pNear
-
>
apPhrase
[
0
]
-
>
poslist
.
n
>
0
)
;
case
FTS5_AND
:
{
int
i
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
if
(
fts5ExprCheckPoslists
(
pNode
-
>
apChild
[
i
]
iRowid
)
=
=
0
)
{
fts5ExprClearPoslists
(
pNode
)
;
return
0
;
}
}
break
;
}
case
FTS5_OR
:
{
int
i
;
int
bRet
=
0
;
for
(
i
=
0
;
i
<
pNode
-
>
nChild
;
i
+
+
)
{
if
(
fts5ExprCheckPoslists
(
pNode
-
>
apChild
[
i
]
iRowid
)
)
{
bRet
=
1
;
}
}
return
bRet
;
}
default
:
{
assert
(
pNode
-
>
eType
=
=
FTS5_NOT
)
;
if
(
0
=
=
fts5ExprCheckPoslists
(
pNode
-
>
apChild
[
0
]
iRowid
)
|
|
0
!
=
fts5ExprCheckPoslists
(
pNode
-
>
apChild
[
1
]
iRowid
)
)
{
fts5ExprClearPoslists
(
pNode
)
;
return
0
;
}
break
;
}
}
return
1
;
}
static
void
sqlite3Fts5ExprCheckPoslists
(
Fts5Expr
*
pExpr
i64
iRowid
)
{
fts5ExprCheckPoslists
(
pExpr
-
>
pRoot
iRowid
)
;
}
static
int
sqlite3Fts5ExprPhraseCollist
(
Fts5Expr
*
pExpr
int
iPhrase
const
u8
*
*
ppCollist
int
*
pnCollist
)
{
Fts5ExprPhrase
*
pPhrase
=
pExpr
-
>
apExprPhrase
[
iPhrase
]
;
Fts5ExprNode
*
pNode
=
pPhrase
-
>
pNode
;
int
rc
=
SQLITE_OK
;
assert
(
iPhrase
>
=
0
&
&
iPhrase
<
pExpr
-
>
nPhrase
)
;
assert
(
pExpr
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
;
if
(
pNode
-
>
bEof
=
=
0
&
&
pNode
-
>
iRowid
=
=
pExpr
-
>
pRoot
-
>
iRowid
&
&
pPhrase
-
>
poslist
.
n
>
0
)
{
Fts5ExprTerm
*
pTerm
=
&
pPhrase
-
>
aTerm
[
0
]
;
if
(
pTerm
-
>
pSynonym
)
{
Fts5Buffer
*
pBuf
=
(
Fts5Buffer
*
)
&
pTerm
-
>
pSynonym
[
1
]
;
rc
=
fts5ExprSynonymList
(
pTerm
pNode
-
>
iRowid
pBuf
(
u8
*
*
)
ppCollist
pnCollist
)
;
}
else
{
*
ppCollist
=
pPhrase
-
>
aTerm
[
0
]
.
pIter
-
>
pData
;
*
pnCollist
=
pPhrase
-
>
aTerm
[
0
]
.
pIter
-
>
nData
;
}
}
else
{
*
ppCollist
=
0
;
*
pnCollist
=
0
;
}
return
rc
;
}
static
int
sqlite3Fts5ExprQueryToken
(
Fts5Expr
*
pExpr
int
iPhrase
int
iToken
const
char
*
*
ppOut
int
*
pnOut
)
{
Fts5ExprPhrase
*
pPhrase
=
0
;
if
(
iPhrase
<
0
|
|
iPhrase
>
=
pExpr
-
>
nPhrase
)
{
return
SQLITE_RANGE
;
}
pPhrase
=
pExpr
-
>
apExprPhrase
[
iPhrase
]
;
if
(
iToken
<
0
|
|
iToken
>
=
pPhrase
-
>
nTerm
)
{
return
SQLITE_RANGE
;
}
*
ppOut
=
pPhrase
-
>
aTerm
[
iToken
]
.
pTerm
;
*
pnOut
=
pPhrase
-
>
aTerm
[
iToken
]
.
nFullTerm
;
return
SQLITE_OK
;
}
static
int
sqlite3Fts5ExprInstToken
(
Fts5Expr
*
pExpr
i64
iRowid
int
iPhrase
int
iCol
int
iOff
int
iToken
const
char
*
*
ppOut
int
*
pnOut
)
{
Fts5ExprPhrase
*
pPhrase
=
0
;
Fts5ExprTerm
*
pTerm
=
0
;
int
rc
=
SQLITE_OK
;
if
(
iPhrase
<
0
|
|
iPhrase
>
=
pExpr
-
>
nPhrase
)
{
return
SQLITE_RANGE
;
}
pPhrase
=
pExpr
-
>
apExprPhrase
[
iPhrase
]
;
if
(
iToken
<
0
|
|
iToken
>
=
pPhrase
-
>
nTerm
)
{
return
SQLITE_RANGE
;
}
pTerm
=
&
pPhrase
-
>
aTerm
[
iToken
]
;
if
(
pExpr
-
>
pConfig
-
>
bTokendata
|
|
pTerm
-
>
bPrefix
)
{
rc
=
sqlite3Fts5IterToken
(
pTerm
-
>
pIter
pTerm
-
>
pTerm
pTerm
-
>
nQueryTerm
iRowid
iCol
iOff
+
iToken
ppOut
pnOut
)
;
}
else
{
*
ppOut
=
pTerm
-
>
pTerm
;
*
pnOut
=
pTerm
-
>
nFullTerm
;
}
return
rc
;
}
static
void
sqlite3Fts5ExprClearTokens
(
Fts5Expr
*
pExpr
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
pExpr
-
>
nPhrase
;
ii
+
+
)
{
Fts5ExprTerm
*
pT
;
for
(
pT
=
&
pExpr
-
>
apExprPhrase
[
ii
]
-
>
aTerm
[
0
]
;
pT
;
pT
=
pT
-
>
pSynonym
)
{
sqlite3Fts5IndexIterClearTokendata
(
pT
-
>
pIter
)
;
}
}
}
#
line
1
"
fts5_hash
.
c
"
typedef
struct
Fts5HashEntry
Fts5HashEntry
;
struct
Fts5Hash
{
int
eDetail
;
int
*
pnByte
;
int
nEntry
;
int
nSlot
;
Fts5HashEntry
*
pScan
;
Fts5HashEntry
*
*
aSlot
;
}
;
struct
Fts5HashEntry
{
Fts5HashEntry
*
pHashNext
;
Fts5HashEntry
*
pScanNext
;
int
nAlloc
;
int
iSzPoslist
;
int
nData
;
int
nKey
;
u8
bDel
;
u8
bContent
;
i16
iCol
;
int
iPos
;
i64
iRowid
;
}
;
#
define
fts5EntryKey
(
p
)
(
(
(
char
*
)
(
&
(
p
)
[
1
]
)
)
)
static
int
sqlite3Fts5HashNew
(
Fts5Config
*
pConfig
Fts5Hash
*
*
ppNew
int
*
pnByte
)
{
int
rc
=
SQLITE_OK
;
Fts5Hash
*
pNew
;
*
ppNew
=
pNew
=
(
Fts5Hash
*
)
sqlite3_malloc
(
sizeof
(
Fts5Hash
)
)
;
if
(
pNew
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
sqlite3_int64
nByte
;
memset
(
pNew
0
sizeof
(
Fts5Hash
)
)
;
pNew
-
>
pnByte
=
pnByte
;
pNew
-
>
eDetail
=
pConfig
-
>
eDetail
;
pNew
-
>
nSlot
=
1024
;
nByte
=
sizeof
(
Fts5HashEntry
*
)
*
pNew
-
>
nSlot
;
pNew
-
>
aSlot
=
(
Fts5HashEntry
*
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
pNew
-
>
aSlot
=
=
0
)
{
sqlite3_free
(
pNew
)
;
*
ppNew
=
0
;
rc
=
SQLITE_NOMEM
;
}
else
{
memset
(
pNew
-
>
aSlot
0
(
size_t
)
nByte
)
;
}
}
return
rc
;
}
static
void
sqlite3Fts5HashFree
(
Fts5Hash
*
pHash
)
{
if
(
pHash
)
{
sqlite3Fts5HashClear
(
pHash
)
;
sqlite3_free
(
pHash
-
>
aSlot
)
;
sqlite3_free
(
pHash
)
;
}
}
static
void
sqlite3Fts5HashClear
(
Fts5Hash
*
pHash
)
{
int
i
;
for
(
i
=
0
;
i
<
pHash
-
>
nSlot
;
i
+
+
)
{
Fts5HashEntry
*
pNext
;
Fts5HashEntry
*
pSlot
;
for
(
pSlot
=
pHash
-
>
aSlot
[
i
]
;
pSlot
;
pSlot
=
pNext
)
{
pNext
=
pSlot
-
>
pHashNext
;
sqlite3_free
(
pSlot
)
;
}
}
memset
(
pHash
-
>
aSlot
0
pHash
-
>
nSlot
*
sizeof
(
Fts5HashEntry
*
)
)
;
pHash
-
>
nEntry
=
0
;
}
static
unsigned
int
fts5HashKey
(
int
nSlot
const
u8
*
p
int
n
)
{
int
i
;
unsigned
int
h
=
13
;
for
(
i
=
n
-
1
;
i
>
=
0
;
i
-
-
)
{
h
=
(
h
<
<
3
)
^
h
^
p
[
i
]
;
}
return
(
h
%
nSlot
)
;
}
static
unsigned
int
fts5HashKey2
(
int
nSlot
u8
b
const
u8
*
p
int
n
)
{
int
i
;
unsigned
int
h
=
13
;
for
(
i
=
n
-
1
;
i
>
=
0
;
i
-
-
)
{
h
=
(
h
<
<
3
)
^
h
^
p
[
i
]
;
}
h
=
(
h
<
<
3
)
^
h
^
b
;
return
(
h
%
nSlot
)
;
}
static
int
fts5HashResize
(
Fts5Hash
*
pHash
)
{
int
nNew
=
pHash
-
>
nSlot
*
2
;
int
i
;
Fts5HashEntry
*
*
apNew
;
Fts5HashEntry
*
*
apOld
=
pHash
-
>
aSlot
;
apNew
=
(
Fts5HashEntry
*
*
)
sqlite3_malloc64
(
nNew
*
sizeof
(
Fts5HashEntry
*
)
)
;
if
(
!
apNew
)
return
SQLITE_NOMEM
;
memset
(
apNew
0
nNew
*
sizeof
(
Fts5HashEntry
*
)
)
;
for
(
i
=
0
;
i
<
pHash
-
>
nSlot
;
i
+
+
)
{
while
(
apOld
[
i
]
)
{
unsigned
int
iHash
;
Fts5HashEntry
*
p
=
apOld
[
i
]
;
apOld
[
i
]
=
p
-
>
pHashNext
;
iHash
=
fts5HashKey
(
nNew
(
u8
*
)
fts5EntryKey
(
p
)
p
-
>
nKey
)
;
p
-
>
pHashNext
=
apNew
[
iHash
]
;
apNew
[
iHash
]
=
p
;
}
}
sqlite3_free
(
apOld
)
;
pHash
-
>
nSlot
=
nNew
;
pHash
-
>
aSlot
=
apNew
;
return
SQLITE_OK
;
}
static
int
fts5HashAddPoslistSize
(
Fts5Hash
*
pHash
Fts5HashEntry
*
p
Fts5HashEntry
*
p2
)
{
int
nRet
=
0
;
if
(
p
-
>
iSzPoslist
)
{
u8
*
pPtr
=
p2
?
(
u8
*
)
p2
:
(
u8
*
)
p
;
int
nData
=
p
-
>
nData
;
if
(
pHash
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
assert
(
nData
=
=
p
-
>
iSzPoslist
)
;
if
(
p
-
>
bDel
)
{
pPtr
[
nData
+
+
]
=
0x00
;
if
(
p
-
>
bContent
)
{
pPtr
[
nData
+
+
]
=
0x00
;
}
}
}
else
{
int
nSz
=
(
nData
-
p
-
>
iSzPoslist
-
1
)
;
int
nPos
=
nSz
*
2
+
p
-
>
bDel
;
assert
(
p
-
>
bDel
=
=
0
|
|
p
-
>
bDel
=
=
1
)
;
if
(
nPos
<
=
127
)
{
pPtr
[
p
-
>
iSzPoslist
]
=
(
u8
)
nPos
;
}
else
{
int
nByte
=
sqlite3Fts5GetVarintLen
(
(
u32
)
nPos
)
;
memmove
(
&
pPtr
[
p
-
>
iSzPoslist
+
nByte
]
&
pPtr
[
p
-
>
iSzPoslist
+
1
]
nSz
)
;
sqlite3Fts5PutVarint
(
&
pPtr
[
p
-
>
iSzPoslist
]
nPos
)
;
nData
+
=
(
nByte
-
1
)
;
}
}
nRet
=
nData
-
p
-
>
nData
;
if
(
p2
=
=
0
)
{
p
-
>
iSzPoslist
=
0
;
p
-
>
bDel
=
0
;
p
-
>
bContent
=
0
;
p
-
>
nData
=
nData
;
}
}
return
nRet
;
}
static
int
sqlite3Fts5HashWrite
(
Fts5Hash
*
pHash
i64
iRowid
int
iCol
int
iPos
char
bByte
const
char
*
pToken
int
nToken
)
{
unsigned
int
iHash
;
Fts5HashEntry
*
p
;
u8
*
pPtr
;
int
nIncr
=
0
;
int
bNew
;
bNew
=
(
pHash
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
;
iHash
=
fts5HashKey2
(
pHash
-
>
nSlot
(
u8
)
bByte
(
const
u8
*
)
pToken
nToken
)
;
for
(
p
=
pHash
-
>
aSlot
[
iHash
]
;
p
;
p
=
p
-
>
pHashNext
)
{
char
*
zKey
=
fts5EntryKey
(
p
)
;
if
(
zKey
[
0
]
=
=
bByte
&
&
p
-
>
nKey
=
=
nToken
+
1
&
&
memcmp
(
&
zKey
[
1
]
pToken
nToken
)
=
=
0
)
{
break
;
}
}
if
(
p
=
=
0
)
{
char
*
zKey
;
sqlite3_int64
nByte
=
sizeof
(
Fts5HashEntry
)
+
(
nToken
+
1
)
+
1
+
64
;
if
(
nByte
<
128
)
nByte
=
128
;
if
(
(
pHash
-
>
nEntry
*
2
)
>
=
pHash
-
>
nSlot
)
{
int
rc
=
fts5HashResize
(
pHash
)
;
if
(
rc
!
=
SQLITE_OK
)
return
rc
;
iHash
=
fts5HashKey2
(
pHash
-
>
nSlot
(
u8
)
bByte
(
const
u8
*
)
pToken
nToken
)
;
}
p
=
(
Fts5HashEntry
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
!
p
)
return
SQLITE_NOMEM
;
memset
(
p
0
sizeof
(
Fts5HashEntry
)
)
;
p
-
>
nAlloc
=
(
int
)
nByte
;
zKey
=
fts5EntryKey
(
p
)
;
zKey
[
0
]
=
bByte
;
memcpy
(
&
zKey
[
1
]
pToken
nToken
)
;
assert
(
iHash
=
=
fts5HashKey
(
pHash
-
>
nSlot
(
u8
*
)
zKey
nToken
+
1
)
)
;
p
-
>
nKey
=
nToken
+
1
;
zKey
[
nToken
+
1
]
=
'
\
0
'
;
p
-
>
nData
=
nToken
+
1
+
sizeof
(
Fts5HashEntry
)
;
p
-
>
pHashNext
=
pHash
-
>
aSlot
[
iHash
]
;
pHash
-
>
aSlot
[
iHash
]
=
p
;
pHash
-
>
nEntry
+
+
;
p
-
>
nData
+
=
sqlite3Fts5PutVarint
(
&
(
(
u8
*
)
p
)
[
p
-
>
nData
]
iRowid
)
;
p
-
>
iRowid
=
iRowid
;
p
-
>
iSzPoslist
=
p
-
>
nData
;
if
(
pHash
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
{
p
-
>
nData
+
=
1
;
p
-
>
iCol
=
(
pHash
-
>
eDetail
=
=
FTS5_DETAIL_FULL
?
0
:
-
1
)
;
}
}
else
{
if
(
(
p
-
>
nAlloc
-
p
-
>
nData
)
<
(
9
+
4
+
1
+
3
+
5
)
)
{
sqlite3_int64
nNew
=
p
-
>
nAlloc
*
2
;
Fts5HashEntry
*
pNew
;
Fts5HashEntry
*
*
pp
;
pNew
=
(
Fts5HashEntry
*
)
sqlite3_realloc64
(
p
nNew
)
;
if
(
pNew
=
=
0
)
return
SQLITE_NOMEM
;
pNew
-
>
nAlloc
=
(
int
)
nNew
;
for
(
pp
=
&
pHash
-
>
aSlot
[
iHash
]
;
*
pp
!
=
p
;
pp
=
&
(
*
pp
)
-
>
pHashNext
)
;
*
pp
=
pNew
;
p
=
pNew
;
}
nIncr
-
=
p
-
>
nData
;
}
assert
(
(
p
-
>
nAlloc
-
p
-
>
nData
)
>
=
(
9
+
4
+
1
+
3
+
5
)
)
;
pPtr
=
(
u8
*
)
p
;
if
(
iRowid
!
=
p
-
>
iRowid
)
{
u64
iDiff
=
(
u64
)
iRowid
-
(
u64
)
p
-
>
iRowid
;
fts5HashAddPoslistSize
(
pHash
p
0
)
;
p
-
>
nData
+
=
sqlite3Fts5PutVarint
(
&
pPtr
[
p
-
>
nData
]
iDiff
)
;
p
-
>
iRowid
=
iRowid
;
bNew
=
1
;
p
-
>
iSzPoslist
=
p
-
>
nData
;
if
(
pHash
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
{
p
-
>
nData
+
=
1
;
p
-
>
iCol
=
(
pHash
-
>
eDetail
=
=
FTS5_DETAIL_FULL
?
0
:
-
1
)
;
p
-
>
iPos
=
0
;
}
}
if
(
iCol
>
=
0
)
{
if
(
pHash
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
p
-
>
bContent
=
1
;
}
else
{
assert_nc
(
iCol
>
=
p
-
>
iCol
)
;
if
(
iCol
!
=
p
-
>
iCol
)
{
if
(
pHash
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
{
pPtr
[
p
-
>
nData
+
+
]
=
0x01
;
p
-
>
nData
+
=
sqlite3Fts5PutVarint
(
&
pPtr
[
p
-
>
nData
]
iCol
)
;
p
-
>
iCol
=
(
i16
)
iCol
;
p
-
>
iPos
=
0
;
}
else
{
bNew
=
1
;
p
-
>
iCol
=
(
i16
)
(
iPos
=
iCol
)
;
}
}
if
(
bNew
)
{
p
-
>
nData
+
=
sqlite3Fts5PutVarint
(
&
pPtr
[
p
-
>
nData
]
iPos
-
p
-
>
iPos
+
2
)
;
p
-
>
iPos
=
iPos
;
}
}
}
else
{
p
-
>
bDel
=
1
;
}
nIncr
+
=
p
-
>
nData
;
*
pHash
-
>
pnByte
+
=
nIncr
;
return
SQLITE_OK
;
}
static
Fts5HashEntry
*
fts5HashEntryMerge
(
Fts5HashEntry
*
pLeft
Fts5HashEntry
*
pRight
)
{
Fts5HashEntry
*
p1
=
pLeft
;
Fts5HashEntry
*
p2
=
pRight
;
Fts5HashEntry
*
pRet
=
0
;
Fts5HashEntry
*
*
ppOut
=
&
pRet
;
while
(
p1
|
|
p2
)
{
if
(
p1
=
=
0
)
{
*
ppOut
=
p2
;
p2
=
0
;
}
else
if
(
p2
=
=
0
)
{
*
ppOut
=
p1
;
p1
=
0
;
}
else
{
char
*
zKey1
=
fts5EntryKey
(
p1
)
;
char
*
zKey2
=
fts5EntryKey
(
p2
)
;
int
nMin
=
MIN
(
p1
-
>
nKey
p2
-
>
nKey
)
;
int
cmp
=
memcmp
(
zKey1
zKey2
nMin
)
;
if
(
cmp
=
=
0
)
{
cmp
=
p1
-
>
nKey
-
p2
-
>
nKey
;
}
assert
(
cmp
!
=
0
)
;
if
(
cmp
>
0
)
{
*
ppOut
=
p2
;
ppOut
=
&
p2
-
>
pScanNext
;
p2
=
p2
-
>
pScanNext
;
}
else
{
*
ppOut
=
p1
;
ppOut
=
&
p1
-
>
pScanNext
;
p1
=
p1
-
>
pScanNext
;
}
*
ppOut
=
0
;
}
}
return
pRet
;
}
static
int
fts5HashEntrySort
(
Fts5Hash
*
pHash
const
char
*
pTerm
int
nTerm
Fts5HashEntry
*
*
ppSorted
)
{
const
int
nMergeSlot
=
32
;
Fts5HashEntry
*
*
ap
;
Fts5HashEntry
*
pList
;
int
iSlot
;
int
i
;
*
ppSorted
=
0
;
ap
=
sqlite3_malloc64
(
sizeof
(
Fts5HashEntry
*
)
*
nMergeSlot
)
;
if
(
!
ap
)
return
SQLITE_NOMEM
;
memset
(
ap
0
sizeof
(
Fts5HashEntry
*
)
*
nMergeSlot
)
;
for
(
iSlot
=
0
;
iSlot
<
pHash
-
>
nSlot
;
iSlot
+
+
)
{
Fts5HashEntry
*
pIter
;
for
(
pIter
=
pHash
-
>
aSlot
[
iSlot
]
;
pIter
;
pIter
=
pIter
-
>
pHashNext
)
{
if
(
pTerm
=
=
0
|
|
(
pIter
-
>
nKey
>
=
nTerm
&
&
0
=
=
memcmp
(
fts5EntryKey
(
pIter
)
pTerm
nTerm
)
)
)
{
Fts5HashEntry
*
pEntry
=
pIter
;
pEntry
-
>
pScanNext
=
0
;
for
(
i
=
0
;
ap
[
i
]
;
i
+
+
)
{
pEntry
=
fts5HashEntryMerge
(
pEntry
ap
[
i
]
)
;
ap
[
i
]
=
0
;
}
ap
[
i
]
=
pEntry
;
}
}
}
pList
=
0
;
for
(
i
=
0
;
i
<
nMergeSlot
;
i
+
+
)
{
pList
=
fts5HashEntryMerge
(
pList
ap
[
i
]
)
;
}
sqlite3_free
(
ap
)
;
*
ppSorted
=
pList
;
return
SQLITE_OK
;
}
static
int
sqlite3Fts5HashQuery
(
Fts5Hash
*
pHash
int
nPre
const
char
*
pTerm
int
nTerm
void
*
*
ppOut
int
*
pnDoclist
)
{
unsigned
int
iHash
=
fts5HashKey
(
pHash
-
>
nSlot
(
const
u8
*
)
pTerm
nTerm
)
;
char
*
zKey
=
0
;
Fts5HashEntry
*
p
;
for
(
p
=
pHash
-
>
aSlot
[
iHash
]
;
p
;
p
=
p
-
>
pHashNext
)
{
zKey
=
fts5EntryKey
(
p
)
;
if
(
nTerm
=
=
p
-
>
nKey
&
&
memcmp
(
zKey
pTerm
nTerm
)
=
=
0
)
break
;
}
if
(
p
)
{
int
nHashPre
=
sizeof
(
Fts5HashEntry
)
+
nTerm
;
int
nList
=
p
-
>
nData
-
nHashPre
;
u8
*
pRet
=
(
u8
*
)
(
*
ppOut
=
sqlite3_malloc64
(
nPre
+
nList
+
10
)
)
;
if
(
pRet
)
{
Fts5HashEntry
*
pFaux
=
(
Fts5HashEntry
*
)
&
pRet
[
nPre
-
nHashPre
]
;
memcpy
(
&
pRet
[
nPre
]
&
(
(
u8
*
)
p
)
[
nHashPre
]
nList
)
;
nList
+
=
fts5HashAddPoslistSize
(
pHash
p
pFaux
)
;
*
pnDoclist
=
nList
;
}
else
{
*
pnDoclist
=
0
;
return
SQLITE_NOMEM
;
}
}
else
{
*
ppOut
=
0
;
*
pnDoclist
=
0
;
}
return
SQLITE_OK
;
}
static
int
sqlite3Fts5HashScanInit
(
Fts5Hash
*
p
const
char
*
pTerm
int
nTerm
)
{
return
fts5HashEntrySort
(
p
pTerm
nTerm
&
p
-
>
pScan
)
;
}
#
ifdef
SQLITE_DEBUG
static
int
fts5HashCount
(
Fts5Hash
*
pHash
)
{
int
nEntry
=
0
;
int
ii
;
for
(
ii
=
0
;
ii
<
pHash
-
>
nSlot
;
ii
+
+
)
{
Fts5HashEntry
*
p
=
0
;
for
(
p
=
pHash
-
>
aSlot
[
ii
]
;
p
;
p
=
p
-
>
pHashNext
)
{
nEntry
+
+
;
}
}
return
nEntry
;
}
#
endif
static
int
sqlite3Fts5HashIsEmpty
(
Fts5Hash
*
pHash
)
{
assert
(
pHash
-
>
nEntry
=
=
fts5HashCount
(
pHash
)
)
;
return
pHash
-
>
nEntry
=
=
0
;
}
static
void
sqlite3Fts5HashScanNext
(
Fts5Hash
*
p
)
{
assert
(
!
sqlite3Fts5HashScanEof
(
p
)
)
;
p
-
>
pScan
=
p
-
>
pScan
-
>
pScanNext
;
}
static
int
sqlite3Fts5HashScanEof
(
Fts5Hash
*
p
)
{
return
(
p
-
>
pScan
=
=
0
)
;
}
static
void
sqlite3Fts5HashScanEntry
(
Fts5Hash
*
pHash
const
char
*
*
pzTerm
int
*
pnTerm
const
u8
*
*
ppDoclist
int
*
pnDoclist
)
{
Fts5HashEntry
*
p
;
if
(
(
p
=
pHash
-
>
pScan
)
)
{
char
*
zKey
=
fts5EntryKey
(
p
)
;
int
nTerm
=
p
-
>
nKey
;
fts5HashAddPoslistSize
(
pHash
p
0
)
;
*
pzTerm
=
zKey
;
*
pnTerm
=
nTerm
;
*
ppDoclist
=
(
const
u8
*
)
&
zKey
[
nTerm
]
;
*
pnDoclist
=
p
-
>
nData
-
(
sizeof
(
Fts5HashEntry
)
+
nTerm
)
;
}
else
{
*
pzTerm
=
0
;
*
pnTerm
=
0
;
*
ppDoclist
=
0
;
*
pnDoclist
=
0
;
}
}
#
line
1
"
fts5_index
.
c
"
#
define
FTS5_OPT_WORK_UNIT
1000
/
*
Number
of
leaf
pages
per
optimize
step
*
/
#
define
FTS5_WORK_UNIT
64
/
*
Number
of
leaf
pages
in
unit
of
work
*
/
#
define
FTS5_MIN_DLIDX_SIZE
4
/
*
Add
dlidx
if
this
many
empty
pages
*
/
#
define
FTS5_MAIN_PREFIX
'
0
'
#
if
FTS5_MAX_PREFIX_INDEXES
>
31
#
error
"
FTS5_MAX_PREFIX_INDEXES
is
too
large
"
#
endif
#
define
FTS5_MAX_LEVEL
64
#
define
FTS5_STRUCTURE_V2
"
\
xFF
\
x00
\
x00
\
x01
"
#
define
FTS5_AVERAGES_ROWID
1
/
*
Rowid
used
for
the
averages
record
*
/
#
define
FTS5_STRUCTURE_ROWID
10
/
*
The
structure
record
*
/
#
define
FTS5_DATA_ID_B
16
/
*
Max
seg
id
number
65535
*
/
#
define
FTS5_DATA_DLI_B
1
/
*
Doclist
-
index
flag
(
1
bit
)
*
/
#
define
FTS5_DATA_HEIGHT_B
5
/
*
Max
dlidx
tree
height
of
32
*
/
#
define
FTS5_DATA_PAGE_B
31
/
*
Max
page
number
of
2147483648
*
/
#
define
fts5_dri
(
segid
dlidx
height
pgno
)
(
\
(
(
i64
)
(
segid
)
<
<
(
FTS5_DATA_PAGE_B
+
FTS5_DATA_HEIGHT_B
+
FTS5_DATA_DLI_B
)
)
+
\
(
(
i64
)
(
dlidx
)
<
<
(
FTS5_DATA_PAGE_B
+
FTS5_DATA_HEIGHT_B
)
)
+
\
(
(
i64
)
(
height
)
<
<
(
FTS5_DATA_PAGE_B
)
)
+
\
(
(
i64
)
(
pgno
)
)
\
)
#
define
FTS5_SEGMENT_ROWID
(
segid
pgno
)
fts5_dri
(
segid
0
0
pgno
)
#
define
FTS5_DLIDX_ROWID
(
segid
height
pgno
)
fts5_dri
(
segid
1
height
pgno
)
#
define
FTS5_TOMBSTONE_ROWID
(
segid
ipg
)
fts5_dri
(
segid
+
(
1
<
<
16
)
0
0
ipg
)
#
ifdef
SQLITE_DEBUG
static
int
sqlite3Fts5Corrupt
(
)
{
return
SQLITE_CORRUPT_VTAB
;
}
#
endif
#
define
FTS5_DATA_ZERO_PADDING
8
#
define
FTS5_DATA_PADDING
20
typedef
struct
Fts5Data
Fts5Data
;
typedef
struct
Fts5DlidxIter
Fts5DlidxIter
;
typedef
struct
Fts5DlidxLvl
Fts5DlidxLvl
;
typedef
struct
Fts5DlidxWriter
Fts5DlidxWriter
;
typedef
struct
Fts5Iter
Fts5Iter
;
typedef
struct
Fts5PageWriter
Fts5PageWriter
;
typedef
struct
Fts5SegIter
Fts5SegIter
;
typedef
struct
Fts5DoclistIter
Fts5DoclistIter
;
typedef
struct
Fts5SegWriter
Fts5SegWriter
;
typedef
struct
Fts5Structure
Fts5Structure
;
typedef
struct
Fts5StructureLevel
Fts5StructureLevel
;
typedef
struct
Fts5StructureSegment
Fts5StructureSegment
;
typedef
struct
Fts5TokenDataIter
Fts5TokenDataIter
;
typedef
struct
Fts5TokenDataMap
Fts5TokenDataMap
;
typedef
struct
Fts5TombstoneArray
Fts5TombstoneArray
;
struct
Fts5Data
{
u8
*
p
;
int
nn
;
int
szLeaf
;
}
;
struct
Fts5Index
{
Fts5Config
*
pConfig
;
char
*
zDataTbl
;
int
nWorkUnit
;
Fts5Hash
*
pHash
;
int
nPendingData
;
i64
iWriteRowid
;
int
bDelete
;
int
nContentlessDelete
;
int
nPendingRow
;
int
rc
;
int
flushRc
;
sqlite3_blob
*
pReader
;
sqlite3_stmt
*
pWriter
;
sqlite3_stmt
*
pDeleter
;
sqlite3_stmt
*
pIdxWriter
;
sqlite3_stmt
*
pIdxDeleter
;
sqlite3_stmt
*
pIdxSelect
;
sqlite3_stmt
*
pIdxNextSelect
;
int
nRead
;
sqlite3_stmt
*
pDeleteFromIdx
;
sqlite3_stmt
*
pDataVersion
;
i64
iStructVersion
;
Fts5Structure
*
pStruct
;
}
;
struct
Fts5DoclistIter
{
u8
*
aEof
;
i64
iRowid
;
u8
*
aPoslist
;
int
nPoslist
;
int
nSize
;
}
;
struct
Fts5StructureSegment
{
int
iSegid
;
int
pgnoFirst
;
int
pgnoLast
;
u64
iOrigin1
;
u64
iOrigin2
;
int
nPgTombstone
;
u64
nEntryTombstone
;
u64
nEntry
;
}
;
struct
Fts5StructureLevel
{
int
nMerge
;
int
nSeg
;
Fts5StructureSegment
*
aSeg
;
}
;
struct
Fts5Structure
{
int
nRef
;
u64
nWriteCounter
;
u64
nOriginCntr
;
int
nSegment
;
int
nLevel
;
Fts5StructureLevel
aLevel
[
1
]
;
}
;
struct
Fts5PageWriter
{
int
pgno
;
int
iPrevPgidx
;
Fts5Buffer
buf
;
Fts5Buffer
pgidx
;
Fts5Buffer
term
;
}
;
struct
Fts5DlidxWriter
{
int
pgno
;
int
bPrevValid
;
i64
iPrev
;
Fts5Buffer
buf
;
}
;
struct
Fts5SegWriter
{
int
iSegid
;
Fts5PageWriter
writer
;
i64
iPrevRowid
;
u8
bFirstRowidInDoclist
;
u8
bFirstRowidInPage
;
u8
bFirstTermInPage
;
int
nLeafWritten
;
int
nEmpty
;
int
nDlidx
;
Fts5DlidxWriter
*
aDlidx
;
Fts5Buffer
btterm
;
int
iBtPage
;
}
;
typedef
struct
Fts5CResult
Fts5CResult
;
struct
Fts5CResult
{
u16
iFirst
;
u8
bTermEq
;
}
;
struct
Fts5SegIter
{
Fts5StructureSegment
*
pSeg
;
int
flags
;
int
iLeafPgno
;
Fts5Data
*
pLeaf
;
Fts5Data
*
pNextLeaf
;
i64
iLeafOffset
;
Fts5TombstoneArray
*
pTombArray
;
void
(
*
xNext
)
(
Fts5Index
*
Fts5SegIter
*
int
*
)
;
int
iTermLeafPgno
;
int
iTermLeafOffset
;
int
iPgidxOff
;
int
iEndofDoclist
;
int
iRowidOffset
;
int
nRowidOffset
;
int
*
aRowidOffset
;
Fts5DlidxIter
*
pDlidx
;
Fts5Buffer
term
;
i64
iRowid
;
int
nPos
;
u8
bDel
;
}
;
struct
Fts5TombstoneArray
{
int
nRef
;
int
nTombstone
;
Fts5Data
*
apTombstone
[
1
]
;
}
;
#
define
ASSERT_SZLEAF_OK
(
x
)
assert
(
\
(
x
)
-
>
szLeaf
=
=
(
x
)
-
>
nn
|
|
(
x
)
-
>
szLeaf
=
=
fts5GetU16
(
&
(
x
)
-
>
p
[
2
]
)
\
)
#
define
FTS5_SEGITER_ONETERM
0x01
#
define
FTS5_SEGITER_REVERSE
0x02
#
define
fts5LeafIsTermless
(
x
)
(
(
x
)
-
>
szLeaf
>
=
(
x
)
-
>
nn
)
#
define
fts5LeafTermOff
(
x
i
)
(
fts5GetU16
(
&
(
x
)
-
>
p
[
(
x
)
-
>
szLeaf
+
(
i
)
*
2
]
)
)
#
define
fts5LeafFirstRowidOff
(
x
)
(
fts5GetU16
(
(
x
)
-
>
p
)
)
struct
Fts5Iter
{
Fts5IndexIter
base
;
Fts5TokenDataIter
*
pTokenDataIter
;
Fts5Index
*
pIndex
;
Fts5Buffer
poslist
;
Fts5Colset
*
pColset
;
void
(
*
xSetOutputs
)
(
Fts5Iter
*
Fts5SegIter
*
)
;
int
nSeg
;
int
bRev
;
u8
bSkipEmpty
;
i64
iSwitchRowid
;
Fts5CResult
*
aFirst
;
Fts5SegIter
aSeg
[
1
]
;
}
;
struct
Fts5DlidxLvl
{
Fts5Data
*
pData
;
int
iOff
;
int
bEof
;
int
iFirstOff
;
int
iLeafPgno
;
i64
iRowid
;
}
;
struct
Fts5DlidxIter
{
int
nLvl
;
int
iSegid
;
Fts5DlidxLvl
aLvl
[
1
]
;
}
;
static
void
fts5PutU16
(
u8
*
aOut
u16
iVal
)
{
aOut
[
0
]
=
(
iVal
>
>
8
)
;
aOut
[
1
]
=
(
iVal
&
0xFF
)
;
}
static
u16
fts5GetU16
(
const
u8
*
aIn
)
{
return
(
(
u16
)
aIn
[
0
]
<
<
8
)
+
aIn
[
1
]
;
}
static
u64
fts5GetU64
(
u8
*
a
)
{
return
(
(
u64
)
a
[
0
]
<
<
56
)
+
(
(
u64
)
a
[
1
]
<
<
48
)
+
(
(
u64
)
a
[
2
]
<
<
40
)
+
(
(
u64
)
a
[
3
]
<
<
32
)
+
(
(
u64
)
a
[
4
]
<
<
24
)
+
(
(
u64
)
a
[
5
]
<
<
16
)
+
(
(
u64
)
a
[
6
]
<
<
8
)
+
(
(
u64
)
a
[
7
]
<
<
0
)
;
}
static
u32
fts5GetU32
(
const
u8
*
a
)
{
return
(
(
u32
)
a
[
0
]
<
<
24
)
+
(
(
u32
)
a
[
1
]
<
<
16
)
+
(
(
u32
)
a
[
2
]
<
<
8
)
+
(
(
u32
)
a
[
3
]
<
<
0
)
;
}
static
void
fts5PutU64
(
u8
*
a
u64
iVal
)
{
a
[
0
]
=
(
(
iVal
>
>
56
)
&
0xFF
)
;
a
[
1
]
=
(
(
iVal
>
>
48
)
&
0xFF
)
;
a
[
2
]
=
(
(
iVal
>
>
40
)
&
0xFF
)
;
a
[
3
]
=
(
(
iVal
>
>
32
)
&
0xFF
)
;
a
[
4
]
=
(
(
iVal
>
>
24
)
&
0xFF
)
;
a
[
5
]
=
(
(
iVal
>
>
16
)
&
0xFF
)
;
a
[
6
]
=
(
(
iVal
>
>
8
)
&
0xFF
)
;
a
[
7
]
=
(
(
iVal
>
>
0
)
&
0xFF
)
;
}
static
void
fts5PutU32
(
u8
*
a
u32
iVal
)
{
a
[
0
]
=
(
(
iVal
>
>
24
)
&
0xFF
)
;
a
[
1
]
=
(
(
iVal
>
>
16
)
&
0xFF
)
;
a
[
2
]
=
(
(
iVal
>
>
8
)
&
0xFF
)
;
a
[
3
]
=
(
(
iVal
>
>
0
)
&
0xFF
)
;
}
static
void
*
fts5IdxMalloc
(
Fts5Index
*
p
sqlite3_int64
nByte
)
{
return
sqlite3Fts5MallocZero
(
&
p
-
>
rc
nByte
)
;
}
#
ifdef
SQLITE_DEBUG
static
int
fts5BufferCompareBlob
(
Fts5Buffer
*
pLeft
const
u8
*
pRight
int
nRight
)
{
int
nCmp
=
MIN
(
pLeft
-
>
n
nRight
)
;
int
res
=
memcmp
(
pLeft
-
>
p
pRight
nCmp
)
;
return
(
res
=
=
0
?
(
pLeft
-
>
n
-
nRight
)
:
res
)
;
}
#
endif
static
int
fts5BufferCompare
(
Fts5Buffer
*
pLeft
Fts5Buffer
*
pRight
)
{
int
nCmp
res
;
nCmp
=
MIN
(
pLeft
-
>
n
pRight
-
>
n
)
;
assert
(
nCmp
<
=
0
|
|
pLeft
-
>
p
!
=
0
)
;
assert
(
nCmp
<
=
0
|
|
pRight
-
>
p
!
=
0
)
;
res
=
fts5Memcmp
(
pLeft
-
>
p
pRight
-
>
p
nCmp
)
;
return
(
res
=
=
0
?
(
pLeft
-
>
n
-
pRight
-
>
n
)
:
res
)
;
}
static
int
fts5LeafFirstTermOff
(
Fts5Data
*
pLeaf
)
{
int
ret
;
fts5GetVarint32
(
&
pLeaf
-
>
p
[
pLeaf
-
>
szLeaf
]
ret
)
;
return
ret
;
}
static
void
fts5IndexCloseReader
(
Fts5Index
*
p
)
{
if
(
p
-
>
pReader
)
{
int
rc
;
sqlite3_blob
*
pReader
=
p
-
>
pReader
;
p
-
>
pReader
=
0
;
rc
=
sqlite3_blob_close
(
pReader
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
p
-
>
rc
=
rc
;
}
}
static
Fts5Data
*
fts5DataRead
(
Fts5Index
*
p
i64
iRowid
)
{
Fts5Data
*
pRet
=
0
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
rc
=
SQLITE_OK
;
if
(
p
-
>
pReader
)
{
sqlite3_blob
*
pBlob
=
p
-
>
pReader
;
p
-
>
pReader
=
0
;
rc
=
sqlite3_blob_reopen
(
pBlob
iRowid
)
;
assert
(
p
-
>
pReader
=
=
0
)
;
p
-
>
pReader
=
pBlob
;
if
(
rc
!
=
SQLITE_OK
)
{
fts5IndexCloseReader
(
p
)
;
}
if
(
rc
=
=
SQLITE_ABORT
)
rc
=
SQLITE_OK
;
}
if
(
p
-
>
pReader
=
=
0
&
&
rc
=
=
SQLITE_OK
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
rc
=
sqlite3_blob_open
(
pConfig
-
>
db
pConfig
-
>
zDb
p
-
>
zDataTbl
"
block
"
iRowid
0
&
p
-
>
pReader
)
;
}
if
(
rc
=
=
SQLITE_ERROR
)
rc
=
FTS5_CORRUPT
;
if
(
rc
=
=
SQLITE_OK
)
{
u8
*
aOut
=
0
;
int
nByte
=
sqlite3_blob_bytes
(
p
-
>
pReader
)
;
int
szData
=
(
sizeof
(
Fts5Data
)
+
7
)
&
~
7
;
sqlite3_int64
nAlloc
=
szData
+
nByte
+
FTS5_DATA_PADDING
;
pRet
=
(
Fts5Data
*
)
sqlite3_malloc64
(
nAlloc
)
;
if
(
pRet
)
{
pRet
-
>
nn
=
nByte
;
aOut
=
pRet
-
>
p
=
(
u8
*
)
pRet
+
szData
;
}
else
{
rc
=
SQLITE_NOMEM
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_blob_read
(
p
-
>
pReader
aOut
nByte
0
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_free
(
pRet
)
;
pRet
=
0
;
}
else
{
pRet
-
>
p
[
nByte
]
=
0x00
;
pRet
-
>
p
[
nByte
+
1
]
=
0x00
;
pRet
-
>
szLeaf
=
fts5GetU16
(
&
pRet
-
>
p
[
2
]
)
;
}
}
p
-
>
rc
=
rc
;
p
-
>
nRead
+
+
;
}
assert
(
(
pRet
=
=
0
)
=
=
(
p
-
>
rc
!
=
SQLITE_OK
)
)
;
assert
(
pRet
=
=
0
|
|
EIGHT_BYTE_ALIGNMENT
(
pRet
-
>
p
)
)
;
return
pRet
;
}
static
void
fts5DataRelease
(
Fts5Data
*
pData
)
{
sqlite3_free
(
pData
)
;
}
static
Fts5Data
*
fts5LeafRead
(
Fts5Index
*
p
i64
iRowid
)
{
Fts5Data
*
pRet
=
fts5DataRead
(
p
iRowid
)
;
if
(
pRet
)
{
if
(
pRet
-
>
nn
<
4
|
|
pRet
-
>
szLeaf
>
pRet
-
>
nn
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
fts5DataRelease
(
pRet
)
;
pRet
=
0
;
}
}
return
pRet
;
}
static
int
fts5IndexPrepareStmt
(
Fts5Index
*
p
sqlite3_stmt
*
*
ppStmt
char
*
zSql
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
zSql
)
{
int
rc
=
sqlite3_prepare_v3
(
p
-
>
pConfig
-
>
db
zSql
-
1
SQLITE_PREPARE_PERSISTENT
|
SQLITE_PREPARE_NO_VTAB
ppStmt
0
)
;
p
-
>
rc
=
(
rc
=
=
SQLITE_ERROR
?
SQLITE_CORRUPT
:
rc
)
;
}
else
{
p
-
>
rc
=
SQLITE_NOMEM
;
}
}
sqlite3_free
(
zSql
)
;
return
p
-
>
rc
;
}
static
void
fts5DataWrite
(
Fts5Index
*
p
i64
iRowid
const
u8
*
pData
int
nData
)
{
if
(
p
-
>
rc
!
=
SQLITE_OK
)
return
;
if
(
p
-
>
pWriter
=
=
0
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
fts5IndexPrepareStmt
(
p
&
p
-
>
pWriter
sqlite3_mprintf
(
"
REPLACE
INTO
'
%
q
'
.
'
%
q_data
'
(
id
block
)
VALUES
(
?
?
)
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
)
;
if
(
p
-
>
rc
)
return
;
}
sqlite3_bind_int64
(
p
-
>
pWriter
1
iRowid
)
;
sqlite3_bind_blob
(
p
-
>
pWriter
2
pData
nData
SQLITE_STATIC
)
;
sqlite3_step
(
p
-
>
pWriter
)
;
p
-
>
rc
=
sqlite3_reset
(
p
-
>
pWriter
)
;
sqlite3_bind_null
(
p
-
>
pWriter
2
)
;
}
static
void
fts5DataDelete
(
Fts5Index
*
p
i64
iFirst
i64
iLast
)
{
if
(
p
-
>
rc
!
=
SQLITE_OK
)
return
;
if
(
p
-
>
pDeleter
=
=
0
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
char
*
zSql
=
sqlite3_mprintf
(
"
DELETE
FROM
'
%
q
'
.
'
%
q_data
'
WHERE
id
>
=
?
AND
id
<
=
?
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
if
(
fts5IndexPrepareStmt
(
p
&
p
-
>
pDeleter
zSql
)
)
return
;
}
sqlite3_bind_int64
(
p
-
>
pDeleter
1
iFirst
)
;
sqlite3_bind_int64
(
p
-
>
pDeleter
2
iLast
)
;
sqlite3_step
(
p
-
>
pDeleter
)
;
p
-
>
rc
=
sqlite3_reset
(
p
-
>
pDeleter
)
;
}
static
void
fts5DataRemoveSegment
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
)
{
int
iSegid
=
pSeg
-
>
iSegid
;
i64
iFirst
=
FTS5_SEGMENT_ROWID
(
iSegid
0
)
;
i64
iLast
=
FTS5_SEGMENT_ROWID
(
iSegid
+
1
0
)
-
1
;
fts5DataDelete
(
p
iFirst
iLast
)
;
if
(
pSeg
-
>
nPgTombstone
)
{
i64
iTomb1
=
FTS5_TOMBSTONE_ROWID
(
iSegid
0
)
;
i64
iTomb2
=
FTS5_TOMBSTONE_ROWID
(
iSegid
pSeg
-
>
nPgTombstone
-
1
)
;
fts5DataDelete
(
p
iTomb1
iTomb2
)
;
}
if
(
p
-
>
pIdxDeleter
=
=
0
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
fts5IndexPrepareStmt
(
p
&
p
-
>
pIdxDeleter
sqlite3_mprintf
(
"
DELETE
FROM
'
%
q
'
.
'
%
q_idx
'
WHERE
segid
=
?
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int
(
p
-
>
pIdxDeleter
1
iSegid
)
;
sqlite3_step
(
p
-
>
pIdxDeleter
)
;
p
-
>
rc
=
sqlite3_reset
(
p
-
>
pIdxDeleter
)
;
}
}
static
void
fts5StructureRelease
(
Fts5Structure
*
pStruct
)
{
if
(
pStruct
&
&
0
>
=
(
-
-
pStruct
-
>
nRef
)
)
{
int
i
;
assert
(
pStruct
-
>
nRef
=
=
0
)
;
for
(
i
=
0
;
i
<
pStruct
-
>
nLevel
;
i
+
+
)
{
sqlite3_free
(
pStruct
-
>
aLevel
[
i
]
.
aSeg
)
;
}
sqlite3_free
(
pStruct
)
;
}
}
static
void
fts5StructureRef
(
Fts5Structure
*
pStruct
)
{
pStruct
-
>
nRef
+
+
;
}
static
void
*
sqlite3Fts5StructureRef
(
Fts5Index
*
p
)
{
fts5StructureRef
(
p
-
>
pStruct
)
;
return
(
void
*
)
p
-
>
pStruct
;
}
static
void
sqlite3Fts5StructureRelease
(
void
*
p
)
{
if
(
p
)
{
fts5StructureRelease
(
(
Fts5Structure
*
)
p
)
;
}
}
static
int
sqlite3Fts5StructureTest
(
Fts5Index
*
p
void
*
pStruct
)
{
if
(
p
-
>
pStruct
!
=
(
Fts5Structure
*
)
pStruct
)
{
return
SQLITE_ABORT
;
}
return
SQLITE_OK
;
}
static
void
fts5StructureMakeWritable
(
int
*
pRc
Fts5Structure
*
*
pp
)
{
Fts5Structure
*
p
=
*
pp
;
if
(
*
pRc
=
=
SQLITE_OK
&
&
p
-
>
nRef
>
1
)
{
i64
nByte
=
sizeof
(
Fts5Structure
)
+
(
p
-
>
nLevel
-
1
)
*
sizeof
(
Fts5StructureLevel
)
;
Fts5Structure
*
pNew
;
pNew
=
(
Fts5Structure
*
)
sqlite3Fts5MallocZero
(
pRc
nByte
)
;
if
(
pNew
)
{
int
i
;
memcpy
(
pNew
p
nByte
)
;
for
(
i
=
0
;
i
<
p
-
>
nLevel
;
i
+
+
)
pNew
-
>
aLevel
[
i
]
.
aSeg
=
0
;
for
(
i
=
0
;
i
<
p
-
>
nLevel
;
i
+
+
)
{
Fts5StructureLevel
*
pLvl
=
&
pNew
-
>
aLevel
[
i
]
;
nByte
=
sizeof
(
Fts5StructureSegment
)
*
pNew
-
>
aLevel
[
i
]
.
nSeg
;
pLvl
-
>
aSeg
=
(
Fts5StructureSegment
*
)
sqlite3Fts5MallocZero
(
pRc
nByte
)
;
if
(
pLvl
-
>
aSeg
=
=
0
)
{
for
(
i
=
0
;
i
<
p
-
>
nLevel
;
i
+
+
)
{
sqlite3_free
(
pNew
-
>
aLevel
[
i
]
.
aSeg
)
;
}
sqlite3_free
(
pNew
)
;
return
;
}
memcpy
(
pLvl
-
>
aSeg
p
-
>
aLevel
[
i
]
.
aSeg
nByte
)
;
}
p
-
>
nRef
-
-
;
pNew
-
>
nRef
=
1
;
}
*
pp
=
pNew
;
}
}
static
int
fts5StructureDecode
(
const
u8
*
pData
int
nData
int
*
piCookie
Fts5Structure
*
*
ppOut
)
{
int
rc
=
SQLITE_OK
;
int
i
=
0
;
int
iLvl
;
int
nLevel
=
0
;
int
nSegment
=
0
;
sqlite3_int64
nByte
;
Fts5Structure
*
pRet
=
0
;
int
bStructureV2
=
0
;
u64
nOriginCntr
=
0
;
if
(
piCookie
)
*
piCookie
=
sqlite3Fts5Get32
(
pData
)
;
i
=
4
;
if
(
0
=
=
memcmp
(
&
pData
[
i
]
FTS5_STRUCTURE_V2
4
)
)
{
i
+
=
4
;
bStructureV2
=
1
;
}
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
nLevel
)
;
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
nSegment
)
;
if
(
nLevel
>
FTS5_MAX_SEGMENT
|
|
nLevel
<
0
|
|
nSegment
>
FTS5_MAX_SEGMENT
|
|
nSegment
<
0
)
{
return
FTS5_CORRUPT
;
}
nByte
=
(
sizeof
(
Fts5Structure
)
+
sizeof
(
Fts5StructureLevel
)
*
(
nLevel
-
1
)
)
;
pRet
=
(
Fts5Structure
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
if
(
pRet
)
{
pRet
-
>
nRef
=
1
;
pRet
-
>
nLevel
=
nLevel
;
pRet
-
>
nSegment
=
nSegment
;
i
+
=
sqlite3Fts5GetVarint
(
&
pData
[
i
]
&
pRet
-
>
nWriteCounter
)
;
for
(
iLvl
=
0
;
rc
=
=
SQLITE_OK
&
&
iLvl
<
nLevel
;
iLvl
+
+
)
{
Fts5StructureLevel
*
pLvl
=
&
pRet
-
>
aLevel
[
iLvl
]
;
int
nTotal
=
0
;
int
iSeg
;
if
(
i
>
=
nData
)
{
rc
=
FTS5_CORRUPT
;
}
else
{
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
pLvl
-
>
nMerge
)
;
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
nTotal
)
;
if
(
nTotal
<
pLvl
-
>
nMerge
)
rc
=
FTS5_CORRUPT
;
pLvl
-
>
aSeg
=
(
Fts5StructureSegment
*
)
sqlite3Fts5MallocZero
(
&
rc
nTotal
*
sizeof
(
Fts5StructureSegment
)
)
;
nSegment
-
=
nTotal
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pLvl
-
>
nSeg
=
nTotal
;
for
(
iSeg
=
0
;
iSeg
<
nTotal
;
iSeg
+
+
)
{
Fts5StructureSegment
*
pSeg
=
&
pLvl
-
>
aSeg
[
iSeg
]
;
if
(
i
>
=
nData
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
assert
(
pSeg
!
=
0
)
;
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
pSeg
-
>
iSegid
)
;
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
pSeg
-
>
pgnoFirst
)
;
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
pSeg
-
>
pgnoLast
)
;
if
(
bStructureV2
)
{
i
+
=
fts5GetVarint
(
&
pData
[
i
]
&
pSeg
-
>
iOrigin1
)
;
i
+
=
fts5GetVarint
(
&
pData
[
i
]
&
pSeg
-
>
iOrigin2
)
;
i
+
=
fts5GetVarint32
(
&
pData
[
i
]
pSeg
-
>
nPgTombstone
)
;
i
+
=
fts5GetVarint
(
&
pData
[
i
]
&
pSeg
-
>
nEntryTombstone
)
;
i
+
=
fts5GetVarint
(
&
pData
[
i
]
&
pSeg
-
>
nEntry
)
;
nOriginCntr
=
MAX
(
nOriginCntr
pSeg
-
>
iOrigin2
)
;
}
if
(
pSeg
-
>
pgnoLast
<
pSeg
-
>
pgnoFirst
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
}
if
(
iLvl
>
0
&
&
pLvl
[
-
1
]
.
nMerge
&
&
nTotal
=
=
0
)
rc
=
FTS5_CORRUPT
;
if
(
iLvl
=
=
nLevel
-
1
&
&
pLvl
-
>
nMerge
)
rc
=
FTS5_CORRUPT
;
}
}
if
(
nSegment
!
=
0
&
&
rc
=
=
SQLITE_OK
)
rc
=
FTS5_CORRUPT
;
if
(
bStructureV2
)
{
pRet
-
>
nOriginCntr
=
nOriginCntr
+
1
;
}
if
(
rc
!
=
SQLITE_OK
)
{
fts5StructureRelease
(
pRet
)
;
pRet
=
0
;
}
}
*
ppOut
=
pRet
;
return
rc
;
}
static
void
fts5StructureAddLevel
(
int
*
pRc
Fts5Structure
*
*
ppStruct
)
{
fts5StructureMakeWritable
(
pRc
ppStruct
)
;
assert
(
(
ppStruct
!
=
0
&
&
(
*
ppStruct
)
!
=
0
)
|
|
(
*
pRc
)
!
=
SQLITE_OK
)
;
if
(
*
pRc
=
=
SQLITE_OK
)
{
Fts5Structure
*
pStruct
=
*
ppStruct
;
int
nLevel
=
pStruct
-
>
nLevel
;
sqlite3_int64
nByte
=
(
sizeof
(
Fts5Structure
)
+
sizeof
(
Fts5StructureLevel
)
*
(
nLevel
+
1
)
)
;
pStruct
=
sqlite3_realloc64
(
pStruct
nByte
)
;
if
(
pStruct
)
{
memset
(
&
pStruct
-
>
aLevel
[
nLevel
]
0
sizeof
(
Fts5StructureLevel
)
)
;
pStruct
-
>
nLevel
+
+
;
*
ppStruct
=
pStruct
;
}
else
{
*
pRc
=
SQLITE_NOMEM
;
}
}
}
static
void
fts5StructureExtendLevel
(
int
*
pRc
Fts5Structure
*
pStruct
int
iLvl
int
nExtra
int
bInsert
)
{
if
(
*
pRc
=
=
SQLITE_OK
)
{
Fts5StructureLevel
*
pLvl
=
&
pStruct
-
>
aLevel
[
iLvl
]
;
Fts5StructureSegment
*
aNew
;
sqlite3_int64
nByte
;
nByte
=
(
pLvl
-
>
nSeg
+
nExtra
)
*
sizeof
(
Fts5StructureSegment
)
;
aNew
=
sqlite3_realloc64
(
pLvl
-
>
aSeg
nByte
)
;
if
(
aNew
)
{
if
(
bInsert
=
=
0
)
{
memset
(
&
aNew
[
pLvl
-
>
nSeg
]
0
sizeof
(
Fts5StructureSegment
)
*
nExtra
)
;
}
else
{
int
nMove
=
pLvl
-
>
nSeg
*
sizeof
(
Fts5StructureSegment
)
;
memmove
(
&
aNew
[
nExtra
]
aNew
nMove
)
;
memset
(
aNew
0
sizeof
(
Fts5StructureSegment
)
*
nExtra
)
;
}
pLvl
-
>
aSeg
=
aNew
;
}
else
{
*
pRc
=
SQLITE_NOMEM
;
}
}
}
static
Fts5Structure
*
fts5StructureReadUncached
(
Fts5Index
*
p
)
{
Fts5Structure
*
pRet
=
0
;
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
iCookie
;
Fts5Data
*
pData
;
pData
=
fts5DataRead
(
p
FTS5_STRUCTURE_ROWID
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
memset
(
&
pData
-
>
p
[
pData
-
>
nn
]
0
FTS5_DATA_PADDING
)
;
p
-
>
rc
=
fts5StructureDecode
(
pData
-
>
p
pData
-
>
nn
&
iCookie
&
pRet
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
(
pConfig
-
>
pgsz
=
=
0
|
|
pConfig
-
>
iCookie
!
=
iCookie
)
)
{
p
-
>
rc
=
sqlite3Fts5ConfigLoad
(
pConfig
iCookie
)
;
}
fts5DataRelease
(
pData
)
;
if
(
p
-
>
rc
!
=
SQLITE_OK
)
{
fts5StructureRelease
(
pRet
)
;
pRet
=
0
;
}
}
return
pRet
;
}
static
i64
fts5IndexDataVersion
(
Fts5Index
*
p
)
{
i64
iVersion
=
0
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
p
-
>
pDataVersion
=
=
0
)
{
p
-
>
rc
=
fts5IndexPrepareStmt
(
p
&
p
-
>
pDataVersion
sqlite3_mprintf
(
"
PRAGMA
%
Q
.
data_version
"
p
-
>
pConfig
-
>
zDb
)
)
;
if
(
p
-
>
rc
)
return
0
;
}
if
(
SQLITE_ROW
=
=
sqlite3_step
(
p
-
>
pDataVersion
)
)
{
iVersion
=
sqlite3_column_int64
(
p
-
>
pDataVersion
0
)
;
}
p
-
>
rc
=
sqlite3_reset
(
p
-
>
pDataVersion
)
;
}
return
iVersion
;
}
static
Fts5Structure
*
fts5StructureRead
(
Fts5Index
*
p
)
{
if
(
p
-
>
pStruct
=
=
0
)
{
p
-
>
iStructVersion
=
fts5IndexDataVersion
(
p
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
p
-
>
pStruct
=
fts5StructureReadUncached
(
p
)
;
}
}
#
if
0
else
{
Fts5Structure
*
pTest
=
fts5StructureReadUncached
(
p
)
;
if
(
pTest
)
{
int
i
j
;
assert_nc
(
p
-
>
pStruct
-
>
nSegment
=
=
pTest
-
>
nSegment
)
;
assert_nc
(
p
-
>
pStruct
-
>
nLevel
=
=
pTest
-
>
nLevel
)
;
for
(
i
=
0
;
i
<
pTest
-
>
nLevel
;
i
+
+
)
{
assert_nc
(
p
-
>
pStruct
-
>
aLevel
[
i
]
.
nMerge
=
=
pTest
-
>
aLevel
[
i
]
.
nMerge
)
;
assert_nc
(
p
-
>
pStruct
-
>
aLevel
[
i
]
.
nSeg
=
=
pTest
-
>
aLevel
[
i
]
.
nSeg
)
;
for
(
j
=
0
;
j
<
pTest
-
>
aLevel
[
i
]
.
nSeg
;
j
+
+
)
{
Fts5StructureSegment
*
p1
=
&
pTest
-
>
aLevel
[
i
]
.
aSeg
[
j
]
;
Fts5StructureSegment
*
p2
=
&
p
-
>
pStruct
-
>
aLevel
[
i
]
.
aSeg
[
j
]
;
assert_nc
(
p1
-
>
iSegid
=
=
p2
-
>
iSegid
)
;
assert_nc
(
p1
-
>
pgnoFirst
=
=
p2
-
>
pgnoFirst
)
;
assert_nc
(
p1
-
>
pgnoLast
=
=
p2
-
>
pgnoLast
)
;
}
}
fts5StructureRelease
(
pTest
)
;
}
}
#
endif
if
(
p
-
>
rc
!
=
SQLITE_OK
)
return
0
;
assert
(
p
-
>
iStructVersion
!
=
0
)
;
assert
(
p
-
>
pStruct
!
=
0
)
;
fts5StructureRef
(
p
-
>
pStruct
)
;
return
p
-
>
pStruct
;
}
static
void
fts5StructureInvalidate
(
Fts5Index
*
p
)
{
if
(
p
-
>
pStruct
)
{
fts5StructureRelease
(
p
-
>
pStruct
)
;
p
-
>
pStruct
=
0
;
}
}
#
ifdef
SQLITE_DEBUG
static
int
fts5StructureCountSegments
(
Fts5Structure
*
pStruct
)
{
int
nSegment
=
0
;
if
(
pStruct
)
{
int
iLvl
;
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
nSegment
+
=
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
;
}
}
return
nSegment
;
}
#
endif
#
define
fts5BufferSafeAppendBlob
(
pBuf
pBlob
nBlob
)
{
\
assert
(
(
pBuf
)
-
>
nSpace
>
=
(
(
pBuf
)
-
>
n
+
nBlob
)
)
;
\
memcpy
(
&
(
pBuf
)
-
>
p
[
(
pBuf
)
-
>
n
]
pBlob
nBlob
)
;
\
(
pBuf
)
-
>
n
+
=
nBlob
;
\
}
#
define
fts5BufferSafeAppendVarint
(
pBuf
iVal
)
{
\
(
pBuf
)
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
(
pBuf
)
-
>
p
[
(
pBuf
)
-
>
n
]
(
iVal
)
)
;
\
assert
(
(
pBuf
)
-
>
nSpace
>
=
(
pBuf
)
-
>
n
)
;
\
}
static
void
fts5StructureWrite
(
Fts5Index
*
p
Fts5Structure
*
pStruct
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
Fts5Buffer
buf
;
int
iLvl
;
int
iCookie
;
int
nHdr
=
(
pStruct
-
>
nOriginCntr
>
0
?
(
4
+
4
+
9
+
9
+
9
)
:
(
4
+
9
+
9
)
)
;
assert
(
pStruct
-
>
nSegment
=
=
fts5StructureCountSegments
(
pStruct
)
)
;
memset
(
&
buf
0
sizeof
(
Fts5Buffer
)
)
;
iCookie
=
p
-
>
pConfig
-
>
iCookie
;
if
(
iCookie
<
0
)
iCookie
=
0
;
if
(
0
=
=
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
buf
nHdr
)
)
{
sqlite3Fts5Put32
(
buf
.
p
iCookie
)
;
buf
.
n
=
4
;
if
(
pStruct
-
>
nOriginCntr
>
0
)
{
fts5BufferSafeAppendBlob
(
&
buf
FTS5_STRUCTURE_V2
4
)
;
}
fts5BufferSafeAppendVarint
(
&
buf
pStruct
-
>
nLevel
)
;
fts5BufferSafeAppendVarint
(
&
buf
pStruct
-
>
nSegment
)
;
fts5BufferSafeAppendVarint
(
&
buf
(
i64
)
pStruct
-
>
nWriteCounter
)
;
}
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
int
iSeg
;
Fts5StructureLevel
*
pLvl
=
&
pStruct
-
>
aLevel
[
iLvl
]
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pLvl
-
>
nMerge
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pLvl
-
>
nSeg
)
;
assert
(
pLvl
-
>
nMerge
<
=
pLvl
-
>
nSeg
)
;
for
(
iSeg
=
0
;
iSeg
<
pLvl
-
>
nSeg
;
iSeg
+
+
)
{
Fts5StructureSegment
*
pSeg
=
&
pLvl
-
>
aSeg
[
iSeg
]
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
iSegid
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
pgnoFirst
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
pgnoLast
)
;
if
(
pStruct
-
>
nOriginCntr
>
0
)
{
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
iOrigin1
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
iOrigin2
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
nPgTombstone
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
nEntryTombstone
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
nEntry
)
;
}
}
}
fts5DataWrite
(
p
FTS5_STRUCTURE_ROWID
buf
.
p
buf
.
n
)
;
fts5BufferFree
(
&
buf
)
;
}
}
#
if
0
static
void
fts5DebugStructure
(
int
*
Fts5Buffer
*
Fts5Structure
*
)
;
static
void
fts5PrintStructure
(
const
char
*
zCaption
Fts5Structure
*
pStruct
)
{
int
rc
=
SQLITE_OK
;
Fts5Buffer
buf
;
memset
(
&
buf
0
sizeof
(
buf
)
)
;
fts5DebugStructure
(
&
rc
&
buf
pStruct
)
;
fprintf
(
stdout
"
%
s
:
%
s
\
n
"
zCaption
buf
.
p
)
;
fflush
(
stdout
)
;
fts5BufferFree
(
&
buf
)
;
}
#
else
#
define
fts5PrintStructure
(
x
y
)
#
endif
static
int
fts5SegmentSize
(
Fts5StructureSegment
*
pSeg
)
{
return
1
+
pSeg
-
>
pgnoLast
-
pSeg
-
>
pgnoFirst
;
}
static
void
fts5StructurePromoteTo
(
Fts5Index
*
p
int
iPromote
int
szPromote
Fts5Structure
*
pStruct
)
{
int
il
is
;
Fts5StructureLevel
*
pOut
=
&
pStruct
-
>
aLevel
[
iPromote
]
;
if
(
pOut
-
>
nMerge
=
=
0
)
{
for
(
il
=
iPromote
+
1
;
il
<
pStruct
-
>
nLevel
;
il
+
+
)
{
Fts5StructureLevel
*
pLvl
=
&
pStruct
-
>
aLevel
[
il
]
;
if
(
pLvl
-
>
nMerge
)
return
;
for
(
is
=
pLvl
-
>
nSeg
-
1
;
is
>
=
0
;
is
-
-
)
{
int
sz
=
fts5SegmentSize
(
&
pLvl
-
>
aSeg
[
is
]
)
;
if
(
sz
>
szPromote
)
return
;
fts5StructureExtendLevel
(
&
p
-
>
rc
pStruct
iPromote
1
1
)
;
if
(
p
-
>
rc
)
return
;
memcpy
(
pOut
-
>
aSeg
&
pLvl
-
>
aSeg
[
is
]
sizeof
(
Fts5StructureSegment
)
)
;
pOut
-
>
nSeg
+
+
;
pLvl
-
>
nSeg
-
-
;
}
}
}
}
static
void
fts5StructurePromote
(
Fts5Index
*
p
int
iLvl
Fts5Structure
*
pStruct
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
iTst
;
int
iPromote
=
-
1
;
int
szPromote
=
0
;
Fts5StructureSegment
*
pSeg
;
int
szSeg
;
int
nSeg
=
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
;
if
(
nSeg
=
=
0
)
return
;
pSeg
=
&
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
-
1
]
;
szSeg
=
(
1
+
pSeg
-
>
pgnoLast
-
pSeg
-
>
pgnoFirst
)
;
for
(
iTst
=
iLvl
-
1
;
iTst
>
=
0
&
&
pStruct
-
>
aLevel
[
iTst
]
.
nSeg
=
=
0
;
iTst
-
-
)
;
if
(
iTst
>
=
0
)
{
int
i
;
int
szMax
=
0
;
Fts5StructureLevel
*
pTst
=
&
pStruct
-
>
aLevel
[
iTst
]
;
assert
(
pTst
-
>
nMerge
=
=
0
)
;
for
(
i
=
0
;
i
<
pTst
-
>
nSeg
;
i
+
+
)
{
int
sz
=
pTst
-
>
aSeg
[
i
]
.
pgnoLast
-
pTst
-
>
aSeg
[
i
]
.
pgnoFirst
+
1
;
if
(
sz
>
szMax
)
szMax
=
sz
;
}
if
(
szMax
>
=
szSeg
)
{
iPromote
=
iTst
;
szPromote
=
szMax
;
}
}
if
(
iPromote
<
0
)
{
iPromote
=
iLvl
;
szPromote
=
szSeg
;
}
fts5StructurePromoteTo
(
p
iPromote
szPromote
pStruct
)
;
}
}
static
int
fts5DlidxLvlNext
(
Fts5DlidxLvl
*
pLvl
)
{
Fts5Data
*
pData
=
pLvl
-
>
pData
;
if
(
pLvl
-
>
iOff
=
=
0
)
{
assert
(
pLvl
-
>
bEof
=
=
0
)
;
pLvl
-
>
iOff
=
1
;
pLvl
-
>
iOff
+
=
fts5GetVarint32
(
&
pData
-
>
p
[
1
]
pLvl
-
>
iLeafPgno
)
;
pLvl
-
>
iOff
+
=
fts5GetVarint
(
&
pData
-
>
p
[
pLvl
-
>
iOff
]
(
u64
*
)
&
pLvl
-
>
iRowid
)
;
pLvl
-
>
iFirstOff
=
pLvl
-
>
iOff
;
}
else
{
int
iOff
;
for
(
iOff
=
pLvl
-
>
iOff
;
iOff
<
pData
-
>
nn
;
iOff
+
+
)
{
if
(
pData
-
>
p
[
iOff
]
)
break
;
}
if
(
iOff
<
pData
-
>
nn
)
{
u64
iVal
;
pLvl
-
>
iLeafPgno
+
=
(
iOff
-
pLvl
-
>
iOff
)
+
1
;
iOff
+
=
fts5GetVarint
(
&
pData
-
>
p
[
iOff
]
&
iVal
)
;
pLvl
-
>
iRowid
+
=
iVal
;
pLvl
-
>
iOff
=
iOff
;
}
else
{
pLvl
-
>
bEof
=
1
;
}
}
return
pLvl
-
>
bEof
;
}
static
int
fts5DlidxIterNextR
(
Fts5Index
*
p
Fts5DlidxIter
*
pIter
int
iLvl
)
{
Fts5DlidxLvl
*
pLvl
=
&
pIter
-
>
aLvl
[
iLvl
]
;
assert
(
iLvl
<
pIter
-
>
nLvl
)
;
if
(
fts5DlidxLvlNext
(
pLvl
)
)
{
if
(
(
iLvl
+
1
)
<
pIter
-
>
nLvl
)
{
fts5DlidxIterNextR
(
p
pIter
iLvl
+
1
)
;
if
(
pLvl
[
1
]
.
bEof
=
=
0
)
{
fts5DataRelease
(
pLvl
-
>
pData
)
;
memset
(
pLvl
0
sizeof
(
Fts5DlidxLvl
)
)
;
pLvl
-
>
pData
=
fts5DataRead
(
p
FTS5_DLIDX_ROWID
(
pIter
-
>
iSegid
iLvl
pLvl
[
1
]
.
iLeafPgno
)
)
;
if
(
pLvl
-
>
pData
)
fts5DlidxLvlNext
(
pLvl
)
;
}
}
}
return
pIter
-
>
aLvl
[
0
]
.
bEof
;
}
static
int
fts5DlidxIterNext
(
Fts5Index
*
p
Fts5DlidxIter
*
pIter
)
{
return
fts5DlidxIterNextR
(
p
pIter
0
)
;
}
static
int
fts5DlidxIterFirst
(
Fts5DlidxIter
*
pIter
)
{
int
i
;
for
(
i
=
0
;
i
<
pIter
-
>
nLvl
;
i
+
+
)
{
fts5DlidxLvlNext
(
&
pIter
-
>
aLvl
[
i
]
)
;
}
return
pIter
-
>
aLvl
[
0
]
.
bEof
;
}
static
int
fts5DlidxIterEof
(
Fts5Index
*
p
Fts5DlidxIter
*
pIter
)
{
return
p
-
>
rc
!
=
SQLITE_OK
|
|
pIter
-
>
aLvl
[
0
]
.
bEof
;
}
static
void
fts5DlidxIterLast
(
Fts5Index
*
p
Fts5DlidxIter
*
pIter
)
{
int
i
;
for
(
i
=
pIter
-
>
nLvl
-
1
;
p
-
>
rc
=
=
SQLITE_OK
&
&
i
>
=
0
;
i
-
-
)
{
Fts5DlidxLvl
*
pLvl
=
&
pIter
-
>
aLvl
[
i
]
;
while
(
fts5DlidxLvlNext
(
pLvl
)
=
=
0
)
;
pLvl
-
>
bEof
=
0
;
if
(
i
>
0
)
{
Fts5DlidxLvl
*
pChild
=
&
pLvl
[
-
1
]
;
fts5DataRelease
(
pChild
-
>
pData
)
;
memset
(
pChild
0
sizeof
(
Fts5DlidxLvl
)
)
;
pChild
-
>
pData
=
fts5DataRead
(
p
FTS5_DLIDX_ROWID
(
pIter
-
>
iSegid
i
-
1
pLvl
-
>
iLeafPgno
)
)
;
}
}
}
static
int
fts5DlidxLvlPrev
(
Fts5DlidxLvl
*
pLvl
)
{
int
iOff
=
pLvl
-
>
iOff
;
assert
(
pLvl
-
>
bEof
=
=
0
)
;
if
(
iOff
<
=
pLvl
-
>
iFirstOff
)
{
pLvl
-
>
bEof
=
1
;
}
else
{
u8
*
a
=
pLvl
-
>
pData
-
>
p
;
pLvl
-
>
iOff
=
0
;
fts5DlidxLvlNext
(
pLvl
)
;
while
(
1
)
{
int
nZero
=
0
;
int
ii
=
pLvl
-
>
iOff
;
u64
delta
=
0
;
while
(
a
[
ii
]
=
=
0
)
{
nZero
+
+
;
ii
+
+
;
}
ii
+
=
sqlite3Fts5GetVarint
(
&
a
[
ii
]
&
delta
)
;
if
(
ii
>
=
iOff
)
break
;
pLvl
-
>
iLeafPgno
+
=
nZero
+
1
;
pLvl
-
>
iRowid
+
=
delta
;
pLvl
-
>
iOff
=
ii
;
}
}
return
pLvl
-
>
bEof
;
}
static
int
fts5DlidxIterPrevR
(
Fts5Index
*
p
Fts5DlidxIter
*
pIter
int
iLvl
)
{
Fts5DlidxLvl
*
pLvl
=
&
pIter
-
>
aLvl
[
iLvl
]
;
assert
(
iLvl
<
pIter
-
>
nLvl
)
;
if
(
fts5DlidxLvlPrev
(
pLvl
)
)
{
if
(
(
iLvl
+
1
)
<
pIter
-
>
nLvl
)
{
fts5DlidxIterPrevR
(
p
pIter
iLvl
+
1
)
;
if
(
pLvl
[
1
]
.
bEof
=
=
0
)
{
fts5DataRelease
(
pLvl
-
>
pData
)
;
memset
(
pLvl
0
sizeof
(
Fts5DlidxLvl
)
)
;
pLvl
-
>
pData
=
fts5DataRead
(
p
FTS5_DLIDX_ROWID
(
pIter
-
>
iSegid
iLvl
pLvl
[
1
]
.
iLeafPgno
)
)
;
if
(
pLvl
-
>
pData
)
{
while
(
fts5DlidxLvlNext
(
pLvl
)
=
=
0
)
;
pLvl
-
>
bEof
=
0
;
}
}
}
}
return
pIter
-
>
aLvl
[
0
]
.
bEof
;
}
static
int
fts5DlidxIterPrev
(
Fts5Index
*
p
Fts5DlidxIter
*
pIter
)
{
return
fts5DlidxIterPrevR
(
p
pIter
0
)
;
}
static
void
fts5DlidxIterFree
(
Fts5DlidxIter
*
pIter
)
{
if
(
pIter
)
{
int
i
;
for
(
i
=
0
;
i
<
pIter
-
>
nLvl
;
i
+
+
)
{
fts5DataRelease
(
pIter
-
>
aLvl
[
i
]
.
pData
)
;
}
sqlite3_free
(
pIter
)
;
}
}
static
Fts5DlidxIter
*
fts5DlidxIterInit
(
Fts5Index
*
p
int
bRev
int
iSegid
int
iLeafPg
)
{
Fts5DlidxIter
*
pIter
=
0
;
int
i
;
int
bDone
=
0
;
for
(
i
=
0
;
p
-
>
rc
=
=
SQLITE_OK
&
&
bDone
=
=
0
;
i
+
+
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5DlidxIter
)
+
i
*
sizeof
(
Fts5DlidxLvl
)
;
Fts5DlidxIter
*
pNew
;
pNew
=
(
Fts5DlidxIter
*
)
sqlite3_realloc64
(
pIter
nByte
)
;
if
(
pNew
=
=
0
)
{
p
-
>
rc
=
SQLITE_NOMEM
;
}
else
{
i64
iRowid
=
FTS5_DLIDX_ROWID
(
iSegid
i
iLeafPg
)
;
Fts5DlidxLvl
*
pLvl
=
&
pNew
-
>
aLvl
[
i
]
;
pIter
=
pNew
;
memset
(
pLvl
0
sizeof
(
Fts5DlidxLvl
)
)
;
pLvl
-
>
pData
=
fts5DataRead
(
p
iRowid
)
;
if
(
pLvl
-
>
pData
&
&
(
pLvl
-
>
pData
-
>
p
[
0
]
&
0x0001
)
=
=
0
)
{
bDone
=
1
;
}
pIter
-
>
nLvl
=
i
+
1
;
}
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
pIter
-
>
iSegid
=
iSegid
;
if
(
bRev
=
=
0
)
{
fts5DlidxIterFirst
(
pIter
)
;
}
else
{
fts5DlidxIterLast
(
p
pIter
)
;
}
}
if
(
p
-
>
rc
!
=
SQLITE_OK
)
{
fts5DlidxIterFree
(
pIter
)
;
pIter
=
0
;
}
return
pIter
;
}
static
i64
fts5DlidxIterRowid
(
Fts5DlidxIter
*
pIter
)
{
return
pIter
-
>
aLvl
[
0
]
.
iRowid
;
}
static
int
fts5DlidxIterPgno
(
Fts5DlidxIter
*
pIter
)
{
return
pIter
-
>
aLvl
[
0
]
.
iLeafPgno
;
}
static
void
fts5SegIterNextPage
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
Fts5Data
*
pLeaf
;
Fts5StructureSegment
*
pSeg
=
pIter
-
>
pSeg
;
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
iLeafPgno
+
+
;
if
(
pIter
-
>
pNextLeaf
)
{
pIter
-
>
pLeaf
=
pIter
-
>
pNextLeaf
;
pIter
-
>
pNextLeaf
=
0
;
}
else
if
(
pIter
-
>
iLeafPgno
<
=
pSeg
-
>
pgnoLast
)
{
pIter
-
>
pLeaf
=
fts5LeafRead
(
p
FTS5_SEGMENT_ROWID
(
pSeg
-
>
iSegid
pIter
-
>
iLeafPgno
)
)
;
}
else
{
pIter
-
>
pLeaf
=
0
;
}
pLeaf
=
pIter
-
>
pLeaf
;
if
(
pLeaf
)
{
pIter
-
>
iPgidxOff
=
pLeaf
-
>
szLeaf
;
if
(
fts5LeafIsTermless
(
pLeaf
)
)
{
pIter
-
>
iEndofDoclist
=
pLeaf
-
>
nn
+
1
;
}
else
{
pIter
-
>
iPgidxOff
+
=
fts5GetVarint32
(
&
pLeaf
-
>
p
[
pIter
-
>
iPgidxOff
]
pIter
-
>
iEndofDoclist
)
;
}
}
}
static
int
fts5GetPoslistSize
(
const
u8
*
p
int
*
pnSz
int
*
pbDel
)
{
int
nSz
;
int
n
=
0
;
fts5FastGetVarint32
(
p
n
nSz
)
;
assert_nc
(
nSz
>
=
0
)
;
*
pnSz
=
nSz
/
2
;
*
pbDel
=
nSz
&
0x0001
;
return
n
;
}
static
void
fts5SegIterLoadNPos
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
iOff
=
pIter
-
>
iLeafOffset
;
ASSERT_SZLEAF_OK
(
pIter
-
>
pLeaf
)
;
if
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
int
iEod
=
MIN
(
pIter
-
>
iEndofDoclist
pIter
-
>
pLeaf
-
>
szLeaf
)
;
pIter
-
>
bDel
=
0
;
pIter
-
>
nPos
=
1
;
if
(
iOff
<
iEod
&
&
pIter
-
>
pLeaf
-
>
p
[
iOff
]
=
=
0
)
{
pIter
-
>
bDel
=
1
;
iOff
+
+
;
if
(
iOff
<
iEod
&
&
pIter
-
>
pLeaf
-
>
p
[
iOff
]
=
=
0
)
{
pIter
-
>
nPos
=
1
;
iOff
+
+
;
}
else
{
pIter
-
>
nPos
=
0
;
}
}
}
else
{
int
nSz
;
fts5FastGetVarint32
(
pIter
-
>
pLeaf
-
>
p
iOff
nSz
)
;
pIter
-
>
bDel
=
(
nSz
&
0x0001
)
;
pIter
-
>
nPos
=
nSz
>
>
1
;
assert_nc
(
pIter
-
>
nPos
>
=
0
)
;
}
pIter
-
>
iLeafOffset
=
iOff
;
}
}
static
void
fts5SegIterLoadRowid
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
i64
iOff
=
pIter
-
>
iLeafOffset
;
ASSERT_SZLEAF_OK
(
pIter
-
>
pLeaf
)
;
while
(
iOff
>
=
pIter
-
>
pLeaf
-
>
szLeaf
)
{
fts5SegIterNextPage
(
p
pIter
)
;
if
(
pIter
-
>
pLeaf
=
=
0
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
iOff
=
4
;
a
=
pIter
-
>
pLeaf
-
>
p
;
}
iOff
+
=
sqlite3Fts5GetVarint
(
&
a
[
iOff
]
(
u64
*
)
&
pIter
-
>
iRowid
)
;
pIter
-
>
iLeafOffset
=
iOff
;
}
static
void
fts5SegIterLoadTerm
(
Fts5Index
*
p
Fts5SegIter
*
pIter
int
nKeep
)
{
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
i64
iOff
=
pIter
-
>
iLeafOffset
;
int
nNew
;
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nNew
)
;
if
(
iOff
+
nNew
>
pIter
-
>
pLeaf
-
>
szLeaf
|
|
nKeep
>
pIter
-
>
term
.
n
|
|
nNew
=
=
0
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
pIter
-
>
term
.
n
=
nKeep
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pIter
-
>
term
nNew
&
a
[
iOff
]
)
;
assert
(
pIter
-
>
term
.
n
<
=
pIter
-
>
term
.
nSpace
)
;
iOff
+
=
nNew
;
pIter
-
>
iTermLeafOffset
=
iOff
;
pIter
-
>
iTermLeafPgno
=
pIter
-
>
iLeafPgno
;
pIter
-
>
iLeafOffset
=
iOff
;
if
(
pIter
-
>
iPgidxOff
>
=
pIter
-
>
pLeaf
-
>
nn
)
{
pIter
-
>
iEndofDoclist
=
pIter
-
>
pLeaf
-
>
nn
+
1
;
}
else
{
int
nExtra
;
pIter
-
>
iPgidxOff
+
=
fts5GetVarint32
(
&
a
[
pIter
-
>
iPgidxOff
]
nExtra
)
;
pIter
-
>
iEndofDoclist
+
=
nExtra
;
}
fts5SegIterLoadRowid
(
p
pIter
)
;
}
static
void
fts5SegIterNext
(
Fts5Index
*
Fts5SegIter
*
int
*
)
;
static
void
fts5SegIterNext_Reverse
(
Fts5Index
*
Fts5SegIter
*
int
*
)
;
static
void
fts5SegIterNext_None
(
Fts5Index
*
Fts5SegIter
*
int
*
)
;
static
void
fts5SegIterSetNext
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
if
(
pIter
-
>
flags
&
FTS5_SEGITER_REVERSE
)
{
pIter
-
>
xNext
=
fts5SegIterNext_Reverse
;
}
else
if
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
pIter
-
>
xNext
=
fts5SegIterNext_None
;
}
else
{
pIter
-
>
xNext
=
fts5SegIterNext
;
}
}
static
void
fts5SegIterAllocTombstone
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
const
int
nTomb
=
pIter
-
>
pSeg
-
>
nPgTombstone
;
if
(
nTomb
>
0
)
{
int
nByte
=
nTomb
*
sizeof
(
Fts5Data
*
)
+
sizeof
(
Fts5TombstoneArray
)
;
Fts5TombstoneArray
*
pNew
;
pNew
=
(
Fts5TombstoneArray
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
nByte
)
;
if
(
pNew
)
{
pNew
-
>
nTombstone
=
nTomb
;
pNew
-
>
nRef
=
1
;
pIter
-
>
pTombArray
=
pNew
;
}
}
}
static
void
fts5SegIterInit
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
Fts5SegIter
*
pIter
)
{
if
(
pSeg
-
>
pgnoFirst
=
=
0
)
{
assert
(
pIter
-
>
pLeaf
=
=
0
)
;
return
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
memset
(
pIter
0
sizeof
(
*
pIter
)
)
;
fts5SegIterSetNext
(
p
pIter
)
;
pIter
-
>
pSeg
=
pSeg
;
pIter
-
>
iLeafPgno
=
pSeg
-
>
pgnoFirst
-
1
;
do
{
fts5SegIterNextPage
(
p
pIter
)
;
}
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pIter
-
>
pLeaf
&
&
pIter
-
>
pLeaf
-
>
nn
=
=
4
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pIter
-
>
pLeaf
)
{
pIter
-
>
iLeafOffset
=
4
;
assert
(
pIter
-
>
pLeaf
!
=
0
)
;
assert_nc
(
pIter
-
>
pLeaf
-
>
nn
>
4
)
;
assert_nc
(
fts5LeafFirstTermOff
(
pIter
-
>
pLeaf
)
=
=
4
)
;
pIter
-
>
iPgidxOff
=
pIter
-
>
pLeaf
-
>
szLeaf
+
1
;
fts5SegIterLoadTerm
(
p
pIter
0
)
;
fts5SegIterLoadNPos
(
p
pIter
)
;
fts5SegIterAllocTombstone
(
p
pIter
)
;
}
}
static
void
fts5SegIterReverseInitPage
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
int
eDetail
=
p
-
>
pConfig
-
>
eDetail
;
int
n
=
pIter
-
>
pLeaf
-
>
szLeaf
;
int
i
=
pIter
-
>
iLeafOffset
;
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
int
iRowidOffset
=
0
;
if
(
n
>
pIter
-
>
iEndofDoclist
)
{
n
=
pIter
-
>
iEndofDoclist
;
}
ASSERT_SZLEAF_OK
(
pIter
-
>
pLeaf
)
;
while
(
1
)
{
u64
iDelta
=
0
;
if
(
eDetail
=
=
FTS5_DETAIL_NONE
)
{
if
(
i
<
n
&
&
a
[
i
]
=
=
0
)
{
i
+
+
;
if
(
i
<
n
&
&
a
[
i
]
=
=
0
)
i
+
+
;
}
}
else
{
int
nPos
;
int
bDummy
;
i
+
=
fts5GetPoslistSize
(
&
a
[
i
]
&
nPos
&
bDummy
)
;
i
+
=
nPos
;
}
if
(
i
>
=
n
)
break
;
i
+
=
fts5GetVarint
(
&
a
[
i
]
&
iDelta
)
;
pIter
-
>
iRowid
+
=
iDelta
;
if
(
iRowidOffset
>
=
pIter
-
>
nRowidOffset
)
{
int
nNew
=
pIter
-
>
nRowidOffset
+
8
;
int
*
aNew
=
(
int
*
)
sqlite3_realloc64
(
pIter
-
>
aRowidOffset
nNew
*
sizeof
(
int
)
)
;
if
(
aNew
=
=
0
)
{
p
-
>
rc
=
SQLITE_NOMEM
;
break
;
}
pIter
-
>
aRowidOffset
=
aNew
;
pIter
-
>
nRowidOffset
=
nNew
;
}
pIter
-
>
aRowidOffset
[
iRowidOffset
+
+
]
=
pIter
-
>
iLeafOffset
;
pIter
-
>
iLeafOffset
=
i
;
}
pIter
-
>
iRowidOffset
=
iRowidOffset
;
fts5SegIterLoadNPos
(
p
pIter
)
;
}
static
void
fts5SegIterReverseNewPage
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
assert
(
pIter
-
>
flags
&
FTS5_SEGITER_REVERSE
)
;
assert
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
;
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
pLeaf
=
0
;
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pIter
-
>
iLeafPgno
>
pIter
-
>
iTermLeafPgno
)
{
Fts5Data
*
pNew
;
pIter
-
>
iLeafPgno
-
-
;
pNew
=
fts5DataRead
(
p
FTS5_SEGMENT_ROWID
(
pIter
-
>
pSeg
-
>
iSegid
pIter
-
>
iLeafPgno
)
)
;
if
(
pNew
)
{
if
(
pIter
-
>
iLeafPgno
=
=
pIter
-
>
iTermLeafPgno
)
{
assert
(
pIter
-
>
pLeaf
=
=
0
)
;
if
(
pIter
-
>
iTermLeafOffset
<
pNew
-
>
szLeaf
)
{
pIter
-
>
pLeaf
=
pNew
;
pIter
-
>
iLeafOffset
=
pIter
-
>
iTermLeafOffset
;
}
}
else
{
int
iRowidOff
;
iRowidOff
=
fts5LeafFirstRowidOff
(
pNew
)
;
if
(
iRowidOff
)
{
if
(
iRowidOff
>
=
pNew
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
pIter
-
>
pLeaf
=
pNew
;
pIter
-
>
iLeafOffset
=
iRowidOff
;
}
}
}
if
(
pIter
-
>
pLeaf
)
{
u8
*
a
=
&
pIter
-
>
pLeaf
-
>
p
[
pIter
-
>
iLeafOffset
]
;
pIter
-
>
iLeafOffset
+
=
fts5GetVarint
(
a
(
u64
*
)
&
pIter
-
>
iRowid
)
;
break
;
}
else
{
fts5DataRelease
(
pNew
)
;
}
}
}
if
(
pIter
-
>
pLeaf
)
{
pIter
-
>
iEndofDoclist
=
pIter
-
>
pLeaf
-
>
nn
+
1
;
fts5SegIterReverseInitPage
(
p
pIter
)
;
}
}
static
int
fts5MultiIterIsEmpty
(
Fts5Index
*
p
Fts5Iter
*
pIter
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
return
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pSeg
-
>
pLeaf
&
&
pSeg
-
>
nPos
=
=
0
)
;
}
static
void
fts5SegIterNext_Reverse
(
Fts5Index
*
p
Fts5SegIter
*
pIter
int
*
pbUnused
)
{
assert
(
pIter
-
>
flags
&
FTS5_SEGITER_REVERSE
)
;
assert
(
pIter
-
>
pNextLeaf
=
=
0
)
;
UNUSED_PARAM
(
pbUnused
)
;
if
(
pIter
-
>
iRowidOffset
>
0
)
{
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
int
iOff
;
u64
iDelta
;
pIter
-
>
iRowidOffset
-
-
;
pIter
-
>
iLeafOffset
=
pIter
-
>
aRowidOffset
[
pIter
-
>
iRowidOffset
]
;
fts5SegIterLoadNPos
(
p
pIter
)
;
iOff
=
pIter
-
>
iLeafOffset
;
if
(
p
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
{
iOff
+
=
pIter
-
>
nPos
;
}
fts5GetVarint
(
&
a
[
iOff
]
&
iDelta
)
;
pIter
-
>
iRowid
-
=
iDelta
;
}
else
{
fts5SegIterReverseNewPage
(
p
pIter
)
;
}
}
static
void
fts5SegIterNext_None
(
Fts5Index
*
p
Fts5SegIter
*
pIter
int
*
pbNewTerm
)
{
int
iOff
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
assert
(
(
pIter
-
>
flags
&
FTS5_SEGITER_REVERSE
)
=
=
0
)
;
assert
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
;
ASSERT_SZLEAF_OK
(
pIter
-
>
pLeaf
)
;
iOff
=
pIter
-
>
iLeafOffset
;
while
(
pIter
-
>
pSeg
&
&
iOff
>
=
pIter
-
>
pLeaf
-
>
szLeaf
)
{
fts5SegIterNextPage
(
p
pIter
)
;
if
(
p
-
>
rc
|
|
pIter
-
>
pLeaf
=
=
0
)
return
;
pIter
-
>
iRowid
=
0
;
iOff
=
4
;
}
if
(
iOff
<
pIter
-
>
iEndofDoclist
)
{
u64
iDelta
;
iOff
+
=
sqlite3Fts5GetVarint
(
&
pIter
-
>
pLeaf
-
>
p
[
iOff
]
(
u64
*
)
&
iDelta
)
;
pIter
-
>
iLeafOffset
=
iOff
;
pIter
-
>
iRowid
+
=
iDelta
;
}
else
if
(
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
=
=
0
)
{
if
(
pIter
-
>
pSeg
)
{
int
nKeep
=
0
;
if
(
iOff
!
=
fts5LeafFirstTermOff
(
pIter
-
>
pLeaf
)
)
{
iOff
+
=
fts5GetVarint32
(
&
pIter
-
>
pLeaf
-
>
p
[
iOff
]
nKeep
)
;
}
pIter
-
>
iLeafOffset
=
iOff
;
fts5SegIterLoadTerm
(
p
pIter
nKeep
)
;
}
else
{
const
u8
*
pList
=
0
;
const
char
*
zTerm
=
0
;
int
nTerm
=
0
;
int
nList
;
sqlite3Fts5HashScanNext
(
p
-
>
pHash
)
;
sqlite3Fts5HashScanEntry
(
p
-
>
pHash
&
zTerm
&
nTerm
&
pList
&
nList
)
;
if
(
pList
=
=
0
)
goto
next_none_eof
;
pIter
-
>
pLeaf
-
>
p
=
(
u8
*
)
pList
;
pIter
-
>
pLeaf
-
>
nn
=
nList
;
pIter
-
>
pLeaf
-
>
szLeaf
=
nList
;
pIter
-
>
iEndofDoclist
=
nList
;
sqlite3Fts5BufferSet
(
&
p
-
>
rc
&
pIter
-
>
term
nTerm
(
u8
*
)
zTerm
)
;
pIter
-
>
iLeafOffset
=
fts5GetVarint
(
pList
(
u64
*
)
&
pIter
-
>
iRowid
)
;
}
if
(
pbNewTerm
)
*
pbNewTerm
=
1
;
}
else
{
goto
next_none_eof
;
}
fts5SegIterLoadNPos
(
p
pIter
)
;
return
;
next_none_eof
:
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
pLeaf
=
0
;
}
static
void
fts5SegIterNext
(
Fts5Index
*
p
Fts5SegIter
*
pIter
int
*
pbNewTerm
)
{
Fts5Data
*
pLeaf
=
pIter
-
>
pLeaf
;
int
iOff
;
int
bNewTerm
=
0
;
int
nKeep
=
0
;
u8
*
a
;
int
n
;
assert
(
pbNewTerm
=
=
0
|
|
*
pbNewTerm
=
=
0
)
;
assert
(
p
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
;
a
=
pLeaf
-
>
p
;
n
=
pLeaf
-
>
szLeaf
;
ASSERT_SZLEAF_OK
(
pLeaf
)
;
iOff
=
pIter
-
>
iLeafOffset
+
pIter
-
>
nPos
;
if
(
iOff
<
n
)
{
assert_nc
(
iOff
<
=
pIter
-
>
iEndofDoclist
)
;
if
(
iOff
>
=
pIter
-
>
iEndofDoclist
)
{
bNewTerm
=
1
;
if
(
iOff
!
=
fts5LeafFirstTermOff
(
pLeaf
)
)
{
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nKeep
)
;
}
}
else
{
u64
iDelta
;
iOff
+
=
sqlite3Fts5GetVarint
(
&
a
[
iOff
]
&
iDelta
)
;
pIter
-
>
iRowid
+
=
iDelta
;
assert_nc
(
iDelta
>
0
)
;
}
pIter
-
>
iLeafOffset
=
iOff
;
}
else
if
(
pIter
-
>
pSeg
=
=
0
)
{
const
u8
*
pList
=
0
;
const
char
*
zTerm
=
0
;
int
nTerm
=
0
;
int
nList
=
0
;
assert
(
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
|
|
pbNewTerm
)
;
if
(
0
=
=
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
)
{
sqlite3Fts5HashScanNext
(
p
-
>
pHash
)
;
sqlite3Fts5HashScanEntry
(
p
-
>
pHash
&
zTerm
&
nTerm
&
pList
&
nList
)
;
}
if
(
pList
=
=
0
)
{
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
pLeaf
=
0
;
}
else
{
pIter
-
>
pLeaf
-
>
p
=
(
u8
*
)
pList
;
pIter
-
>
pLeaf
-
>
nn
=
nList
;
pIter
-
>
pLeaf
-
>
szLeaf
=
nList
;
pIter
-
>
iEndofDoclist
=
nList
+
1
;
sqlite3Fts5BufferSet
(
&
p
-
>
rc
&
pIter
-
>
term
nTerm
(
u8
*
)
zTerm
)
;
pIter
-
>
iLeafOffset
=
fts5GetVarint
(
pList
(
u64
*
)
&
pIter
-
>
iRowid
)
;
*
pbNewTerm
=
1
;
}
}
else
{
iOff
=
0
;
while
(
iOff
=
=
0
)
{
fts5SegIterNextPage
(
p
pIter
)
;
pLeaf
=
pIter
-
>
pLeaf
;
if
(
pLeaf
=
=
0
)
break
;
ASSERT_SZLEAF_OK
(
pLeaf
)
;
if
(
(
iOff
=
fts5LeafFirstRowidOff
(
pLeaf
)
)
&
&
iOff
<
pLeaf
-
>
szLeaf
)
{
iOff
+
=
sqlite3Fts5GetVarint
(
&
pLeaf
-
>
p
[
iOff
]
(
u64
*
)
&
pIter
-
>
iRowid
)
;
pIter
-
>
iLeafOffset
=
iOff
;
if
(
pLeaf
-
>
nn
>
pLeaf
-
>
szLeaf
)
{
pIter
-
>
iPgidxOff
=
pLeaf
-
>
szLeaf
+
fts5GetVarint32
(
&
pLeaf
-
>
p
[
pLeaf
-
>
szLeaf
]
pIter
-
>
iEndofDoclist
)
;
}
}
else
if
(
pLeaf
-
>
nn
>
pLeaf
-
>
szLeaf
)
{
pIter
-
>
iPgidxOff
=
pLeaf
-
>
szLeaf
+
fts5GetVarint32
(
&
pLeaf
-
>
p
[
pLeaf
-
>
szLeaf
]
iOff
)
;
pIter
-
>
iLeafOffset
=
iOff
;
pIter
-
>
iEndofDoclist
=
iOff
;
bNewTerm
=
1
;
}
assert_nc
(
iOff
<
pLeaf
-
>
szLeaf
)
;
if
(
iOff
>
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
}
}
if
(
pIter
-
>
pLeaf
)
{
if
(
bNewTerm
)
{
if
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
{
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
pLeaf
=
0
;
}
else
{
fts5SegIterLoadTerm
(
p
pIter
nKeep
)
;
fts5SegIterLoadNPos
(
p
pIter
)
;
if
(
pbNewTerm
)
*
pbNewTerm
=
1
;
}
}
else
{
int
nSz
;
assert_nc
(
pIter
-
>
iLeafOffset
<
=
pIter
-
>
pLeaf
-
>
nn
)
;
fts5FastGetVarint32
(
pIter
-
>
pLeaf
-
>
p
pIter
-
>
iLeafOffset
nSz
)
;
pIter
-
>
bDel
=
(
nSz
&
0x0001
)
;
pIter
-
>
nPos
=
nSz
>
>
1
;
assert_nc
(
pIter
-
>
nPos
>
=
0
)
;
}
}
}
#
define
SWAPVAL
(
T
a
b
)
{
T
tmp
;
tmp
=
a
;
a
=
b
;
b
=
tmp
;
}
#
define
fts5IndexSkipVarint
(
a
iOff
)
{
\
int
iEnd
=
iOff
+
9
;
\
while
(
(
a
[
iOff
+
+
]
&
0x80
)
&
&
iOff
<
iEnd
)
;
\
}
static
void
fts5SegIterReverse
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
Fts5DlidxIter
*
pDlidx
=
pIter
-
>
pDlidx
;
Fts5Data
*
pLast
=
0
;
int
pgnoLast
=
0
;
if
(
pDlidx
&
&
p
-
>
pConfig
-
>
iVersion
=
=
FTS5_CURRENT_VERSION
)
{
int
iSegid
=
pIter
-
>
pSeg
-
>
iSegid
;
pgnoLast
=
fts5DlidxIterPgno
(
pDlidx
)
;
pLast
=
fts5LeafRead
(
p
FTS5_SEGMENT_ROWID
(
iSegid
pgnoLast
)
)
;
}
else
{
Fts5Data
*
pLeaf
=
pIter
-
>
pLeaf
;
int
iPoslist
;
if
(
pIter
-
>
iTermLeafPgno
=
=
pIter
-
>
iLeafPgno
)
{
iPoslist
=
pIter
-
>
iTermLeafOffset
;
}
else
{
iPoslist
=
4
;
}
fts5IndexSkipVarint
(
pLeaf
-
>
p
iPoslist
)
;
pIter
-
>
iLeafOffset
=
iPoslist
;
if
(
pIter
-
>
iEndofDoclist
>
=
pLeaf
-
>
szLeaf
)
{
int
pgno
;
Fts5StructureSegment
*
pSeg
=
pIter
-
>
pSeg
;
for
(
pgno
=
pIter
-
>
iLeafPgno
+
1
;
!
p
-
>
rc
&
&
pgno
<
=
pSeg
-
>
pgnoLast
;
pgno
+
+
)
{
i64
iAbs
=
FTS5_SEGMENT_ROWID
(
pSeg
-
>
iSegid
pgno
)
;
Fts5Data
*
pNew
=
fts5LeafRead
(
p
iAbs
)
;
if
(
pNew
)
{
int
iRowid
bTermless
;
iRowid
=
fts5LeafFirstRowidOff
(
pNew
)
;
bTermless
=
fts5LeafIsTermless
(
pNew
)
;
if
(
iRowid
)
{
SWAPVAL
(
Fts5Data
*
pNew
pLast
)
;
pgnoLast
=
pgno
;
}
fts5DataRelease
(
pNew
)
;
if
(
bTermless
=
=
0
)
break
;
}
}
}
}
if
(
pLast
)
{
int
iOff
;
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
pLeaf
=
pLast
;
pIter
-
>
iLeafPgno
=
pgnoLast
;
iOff
=
fts5LeafFirstRowidOff
(
pLast
)
;
if
(
iOff
>
pLast
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
iOff
+
=
fts5GetVarint
(
&
pLast
-
>
p
[
iOff
]
(
u64
*
)
&
pIter
-
>
iRowid
)
;
pIter
-
>
iLeafOffset
=
iOff
;
if
(
fts5LeafIsTermless
(
pLast
)
)
{
pIter
-
>
iEndofDoclist
=
pLast
-
>
nn
+
1
;
}
else
{
pIter
-
>
iEndofDoclist
=
fts5LeafFirstTermOff
(
pLast
)
;
}
}
fts5SegIterReverseInitPage
(
p
pIter
)
;
}
static
void
fts5SegIterLoadDlidx
(
Fts5Index
*
p
Fts5SegIter
*
pIter
)
{
int
iSeg
=
pIter
-
>
pSeg
-
>
iSegid
;
int
bRev
=
(
pIter
-
>
flags
&
FTS5_SEGITER_REVERSE
)
;
Fts5Data
*
pLeaf
=
pIter
-
>
pLeaf
;
assert
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
;
assert
(
pIter
-
>
pDlidx
=
=
0
)
;
if
(
pIter
-
>
iTermLeafPgno
=
=
pIter
-
>
iLeafPgno
&
&
pIter
-
>
iEndofDoclist
<
pLeaf
-
>
szLeaf
)
{
return
;
}
pIter
-
>
pDlidx
=
fts5DlidxIterInit
(
p
bRev
iSeg
pIter
-
>
iTermLeafPgno
)
;
}
static
void
fts5LeafSeek
(
Fts5Index
*
p
int
bGe
Fts5SegIter
*
pIter
const
u8
*
pTerm
int
nTerm
)
{
u32
iOff
;
const
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
u32
n
=
(
u32
)
pIter
-
>
pLeaf
-
>
nn
;
u32
nMatch
=
0
;
u32
nKeep
=
0
;
u32
nNew
=
0
;
u32
iTermOff
;
u32
iPgidx
;
int
bEndOfPage
=
0
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
iPgidx
=
(
u32
)
pIter
-
>
pLeaf
-
>
szLeaf
;
iPgidx
+
=
fts5GetVarint32
(
&
a
[
iPgidx
]
iTermOff
)
;
iOff
=
iTermOff
;
if
(
iOff
>
n
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
while
(
1
)
{
fts5FastGetVarint32
(
a
iOff
nNew
)
;
if
(
nKeep
<
nMatch
)
{
goto
search_failed
;
}
assert
(
nKeep
>
=
nMatch
)
;
if
(
nKeep
=
=
nMatch
)
{
u32
nCmp
;
u32
i
;
nCmp
=
(
u32
)
MIN
(
nNew
nTerm
-
nMatch
)
;
for
(
i
=
0
;
i
<
nCmp
;
i
+
+
)
{
if
(
a
[
iOff
+
i
]
!
=
pTerm
[
nMatch
+
i
]
)
break
;
}
nMatch
+
=
i
;
if
(
(
u32
)
nTerm
=
=
nMatch
)
{
if
(
i
=
=
nNew
)
{
goto
search_success
;
}
else
{
goto
search_failed
;
}
}
else
if
(
i
<
nNew
&
&
a
[
iOff
+
i
]
>
pTerm
[
nMatch
]
)
{
goto
search_failed
;
}
}
if
(
iPgidx
>
=
n
)
{
bEndOfPage
=
1
;
break
;
}
iPgidx
+
=
fts5GetVarint32
(
&
a
[
iPgidx
]
nKeep
)
;
iTermOff
+
=
nKeep
;
iOff
=
iTermOff
;
if
(
iOff
>
=
n
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
fts5FastGetVarint32
(
a
iOff
nKeep
)
;
}
search_failed
:
if
(
bGe
=
=
0
)
{
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
pIter
-
>
pLeaf
=
0
;
return
;
}
else
if
(
bEndOfPage
)
{
do
{
fts5SegIterNextPage
(
p
pIter
)
;
if
(
pIter
-
>
pLeaf
=
=
0
)
return
;
a
=
pIter
-
>
pLeaf
-
>
p
;
if
(
fts5LeafIsTermless
(
pIter
-
>
pLeaf
)
=
=
0
)
{
iPgidx
=
(
u32
)
pIter
-
>
pLeaf
-
>
szLeaf
;
iPgidx
+
=
fts5GetVarint32
(
&
pIter
-
>
pLeaf
-
>
p
[
iPgidx
]
iOff
)
;
if
(
iOff
<
4
|
|
(
i64
)
iOff
>
=
pIter
-
>
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
else
{
nKeep
=
0
;
iTermOff
=
iOff
;
n
=
(
u32
)
pIter
-
>
pLeaf
-
>
nn
;
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nNew
)
;
break
;
}
}
}
while
(
1
)
;
}
search_success
:
if
(
(
i64
)
iOff
+
nNew
>
n
|
|
nNew
<
1
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
pIter
-
>
iLeafOffset
=
iOff
+
nNew
;
pIter
-
>
iTermLeafOffset
=
pIter
-
>
iLeafOffset
;
pIter
-
>
iTermLeafPgno
=
pIter
-
>
iLeafPgno
;
fts5BufferSet
(
&
p
-
>
rc
&
pIter
-
>
term
nKeep
pTerm
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pIter
-
>
term
nNew
&
a
[
iOff
]
)
;
if
(
iPgidx
>
=
n
)
{
pIter
-
>
iEndofDoclist
=
pIter
-
>
pLeaf
-
>
nn
+
1
;
}
else
{
int
nExtra
;
iPgidx
+
=
fts5GetVarint32
(
&
a
[
iPgidx
]
nExtra
)
;
pIter
-
>
iEndofDoclist
=
iTermOff
+
nExtra
;
}
pIter
-
>
iPgidxOff
=
iPgidx
;
fts5SegIterLoadRowid
(
p
pIter
)
;
fts5SegIterLoadNPos
(
p
pIter
)
;
}
static
sqlite3_stmt
*
fts5IdxSelectStmt
(
Fts5Index
*
p
)
{
if
(
p
-
>
pIdxSelect
=
=
0
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
fts5IndexPrepareStmt
(
p
&
p
-
>
pIdxSelect
sqlite3_mprintf
(
"
SELECT
pgno
FROM
'
%
q
'
.
'
%
q_idx
'
WHERE
"
"
segid
=
?
AND
term
<
=
?
ORDER
BY
term
DESC
LIMIT
1
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
)
;
}
return
p
-
>
pIdxSelect
;
}
static
void
fts5SegIterSeekInit
(
Fts5Index
*
p
const
u8
*
pTerm
int
nTerm
int
flags
Fts5StructureSegment
*
pSeg
Fts5SegIter
*
pIter
)
{
int
iPg
=
1
;
int
bGe
=
(
flags
&
FTS5INDEX_QUERY_SCAN
)
;
int
bDlidx
=
0
;
sqlite3_stmt
*
pIdxSelect
=
0
;
assert
(
bGe
=
=
0
|
|
(
flags
&
FTS5INDEX_QUERY_DESC
)
=
=
0
)
;
assert
(
pTerm
&
&
nTerm
)
;
memset
(
pIter
0
sizeof
(
*
pIter
)
)
;
pIter
-
>
pSeg
=
pSeg
;
pIdxSelect
=
fts5IdxSelectStmt
(
p
)
;
if
(
p
-
>
rc
)
return
;
sqlite3_bind_int
(
pIdxSelect
1
pSeg
-
>
iSegid
)
;
sqlite3_bind_blob
(
pIdxSelect
2
pTerm
nTerm
SQLITE_STATIC
)
;
if
(
SQLITE_ROW
=
=
sqlite3_step
(
pIdxSelect
)
)
{
i64
val
=
sqlite3_column_int
(
pIdxSelect
0
)
;
iPg
=
(
int
)
(
val
>
>
1
)
;
bDlidx
=
(
val
&
0x0001
)
;
}
p
-
>
rc
=
sqlite3_reset
(
pIdxSelect
)
;
sqlite3_bind_null
(
pIdxSelect
2
)
;
if
(
iPg
<
pSeg
-
>
pgnoFirst
)
{
iPg
=
pSeg
-
>
pgnoFirst
;
bDlidx
=
0
;
}
pIter
-
>
iLeafPgno
=
iPg
-
1
;
fts5SegIterNextPage
(
p
pIter
)
;
if
(
pIter
-
>
pLeaf
)
{
fts5LeafSeek
(
p
bGe
pIter
pTerm
nTerm
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
(
bGe
=
=
0
|
|
(
flags
&
FTS5INDEX_QUERY_SCANONETERM
)
)
)
{
pIter
-
>
flags
|
=
FTS5_SEGITER_ONETERM
;
if
(
pIter
-
>
pLeaf
)
{
if
(
flags
&
FTS5INDEX_QUERY_DESC
)
{
pIter
-
>
flags
|
=
FTS5_SEGITER_REVERSE
;
}
if
(
bDlidx
)
{
fts5SegIterLoadDlidx
(
p
pIter
)
;
}
if
(
flags
&
FTS5INDEX_QUERY_DESC
)
{
fts5SegIterReverse
(
p
pIter
)
;
}
}
}
fts5SegIterSetNext
(
p
pIter
)
;
if
(
0
=
=
(
flags
&
FTS5INDEX_QUERY_SCANONETERM
)
)
{
fts5SegIterAllocTombstone
(
p
pIter
)
;
}
assert_nc
(
p
-
>
rc
!
=
SQLITE_OK
|
|
pIter
-
>
pLeaf
=
=
0
|
|
fts5BufferCompareBlob
(
&
pIter
-
>
term
pTerm
nTerm
)
=
=
0
|
|
(
bGe
&
&
fts5BufferCompareBlob
(
&
pIter
-
>
term
pTerm
nTerm
)
>
0
)
)
;
}
static
sqlite3_stmt
*
fts5IdxNextStmt
(
Fts5Index
*
p
)
{
if
(
p
-
>
pIdxNextSelect
=
=
0
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
fts5IndexPrepareStmt
(
p
&
p
-
>
pIdxNextSelect
sqlite3_mprintf
(
"
SELECT
pgno
FROM
'
%
q
'
.
'
%
q_idx
'
WHERE
"
"
segid
=
?
AND
term
>
?
ORDER
BY
term
ASC
LIMIT
1
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
)
;
}
return
p
-
>
pIdxNextSelect
;
}
static
void
fts5SegIterNextInit
(
Fts5Index
*
p
const
char
*
pTerm
int
nTerm
Fts5StructureSegment
*
pSeg
Fts5SegIter
*
pIter
)
{
int
iPg
=
-
1
;
int
bDlidx
=
0
;
sqlite3_stmt
*
pSel
=
0
;
pSel
=
fts5IdxNextStmt
(
p
)
;
if
(
pSel
)
{
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
sqlite3_bind_int
(
pSel
1
pSeg
-
>
iSegid
)
;
sqlite3_bind_blob
(
pSel
2
pTerm
nTerm
SQLITE_STATIC
)
;
if
(
sqlite3_step
(
pSel
)
=
=
SQLITE_ROW
)
{
i64
val
=
sqlite3_column_int64
(
pSel
0
)
;
iPg
=
(
int
)
(
val
>
>
1
)
;
bDlidx
=
(
val
&
0x0001
)
;
}
p
-
>
rc
=
sqlite3_reset
(
pSel
)
;
sqlite3_bind_null
(
pSel
2
)
;
if
(
p
-
>
rc
)
return
;
}
memset
(
pIter
0
sizeof
(
*
pIter
)
)
;
pIter
-
>
pSeg
=
pSeg
;
pIter
-
>
flags
|
=
FTS5_SEGITER_ONETERM
;
if
(
iPg
>
=
0
)
{
pIter
-
>
iLeafPgno
=
iPg
-
1
;
fts5SegIterNextPage
(
p
pIter
)
;
fts5SegIterSetNext
(
p
pIter
)
;
}
if
(
pIter
-
>
pLeaf
)
{
const
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
int
iTermOff
=
0
;
pIter
-
>
iPgidxOff
=
pIter
-
>
pLeaf
-
>
szLeaf
;
pIter
-
>
iPgidxOff
+
=
fts5GetVarint32
(
&
a
[
pIter
-
>
iPgidxOff
]
iTermOff
)
;
pIter
-
>
iLeafOffset
=
iTermOff
;
fts5SegIterLoadTerm
(
p
pIter
0
)
;
fts5SegIterLoadNPos
(
p
pIter
)
;
if
(
bDlidx
)
fts5SegIterLoadDlidx
(
p
pIter
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
fts5BufferCompareBlob
(
&
pIter
-
>
term
(
const
u8
*
)
pTerm
nTerm
)
>
0
)
;
}
}
static
void
fts5SegIterHashInit
(
Fts5Index
*
p
const
u8
*
pTerm
int
nTerm
int
flags
Fts5SegIter
*
pIter
)
{
int
nList
=
0
;
const
u8
*
z
=
0
;
int
n
=
0
;
Fts5Data
*
pLeaf
=
0
;
assert
(
p
-
>
pHash
)
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
if
(
pTerm
=
=
0
|
|
(
flags
&
FTS5INDEX_QUERY_SCAN
)
)
{
const
u8
*
pList
=
0
;
p
-
>
rc
=
sqlite3Fts5HashScanInit
(
p
-
>
pHash
(
const
char
*
)
pTerm
nTerm
)
;
sqlite3Fts5HashScanEntry
(
p
-
>
pHash
(
const
char
*
*
)
&
z
&
n
&
pList
&
nList
)
;
if
(
pList
)
{
pLeaf
=
fts5IdxMalloc
(
p
sizeof
(
Fts5Data
)
)
;
if
(
pLeaf
)
{
pLeaf
-
>
p
=
(
u8
*
)
pList
;
}
}
p
-
>
bDelete
=
0
;
}
else
{
p
-
>
rc
=
sqlite3Fts5HashQuery
(
p
-
>
pHash
sizeof
(
Fts5Data
)
(
const
char
*
)
pTerm
nTerm
(
void
*
*
)
&
pLeaf
&
nList
)
;
if
(
pLeaf
)
{
pLeaf
-
>
p
=
(
u8
*
)
&
pLeaf
[
1
]
;
}
z
=
pTerm
;
n
=
nTerm
;
pIter
-
>
flags
|
=
FTS5_SEGITER_ONETERM
;
}
if
(
pLeaf
)
{
sqlite3Fts5BufferSet
(
&
p
-
>
rc
&
pIter
-
>
term
n
z
)
;
pLeaf
-
>
nn
=
pLeaf
-
>
szLeaf
=
nList
;
pIter
-
>
pLeaf
=
pLeaf
;
pIter
-
>
iLeafOffset
=
fts5GetVarint
(
pLeaf
-
>
p
(
u64
*
)
&
pIter
-
>
iRowid
)
;
pIter
-
>
iEndofDoclist
=
pLeaf
-
>
nn
;
if
(
flags
&
FTS5INDEX_QUERY_DESC
)
{
pIter
-
>
flags
|
=
FTS5_SEGITER_REVERSE
;
fts5SegIterReverseInitPage
(
p
pIter
)
;
}
else
{
fts5SegIterLoadNPos
(
p
pIter
)
;
}
}
fts5SegIterSetNext
(
p
pIter
)
;
}
static
void
fts5IndexFreeArray
(
Fts5Data
*
*
ap
int
n
)
{
if
(
ap
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
n
;
ii
+
+
)
{
fts5DataRelease
(
ap
[
ii
]
)
;
}
sqlite3_free
(
ap
)
;
}
}
static
void
fts5TombstoneArrayDelete
(
Fts5TombstoneArray
*
p
)
{
if
(
p
)
{
p
-
>
nRef
-
-
;
if
(
p
-
>
nRef
<
=
0
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
p
-
>
nTombstone
;
ii
+
+
)
{
fts5DataRelease
(
p
-
>
apTombstone
[
ii
]
)
;
}
sqlite3_free
(
p
)
;
}
}
}
static
void
fts5SegIterClear
(
Fts5SegIter
*
pIter
)
{
fts5BufferFree
(
&
pIter
-
>
term
)
;
fts5DataRelease
(
pIter
-
>
pLeaf
)
;
fts5DataRelease
(
pIter
-
>
pNextLeaf
)
;
fts5TombstoneArrayDelete
(
pIter
-
>
pTombArray
)
;
fts5DlidxIterFree
(
pIter
-
>
pDlidx
)
;
sqlite3_free
(
pIter
-
>
aRowidOffset
)
;
memset
(
pIter
0
sizeof
(
Fts5SegIter
)
)
;
}
#
ifdef
SQLITE_DEBUG
static
void
fts5AssertComparisonResult
(
Fts5Iter
*
pIter
Fts5SegIter
*
p1
Fts5SegIter
*
p2
Fts5CResult
*
pRes
)
{
int
i1
=
p1
-
pIter
-
>
aSeg
;
int
i2
=
p2
-
pIter
-
>
aSeg
;
if
(
p1
-
>
pLeaf
|
|
p2
-
>
pLeaf
)
{
if
(
p1
-
>
pLeaf
=
=
0
)
{
assert
(
pRes
-
>
iFirst
=
=
i2
)
;
}
else
if
(
p2
-
>
pLeaf
=
=
0
)
{
assert
(
pRes
-
>
iFirst
=
=
i1
)
;
}
else
{
int
nMin
=
MIN
(
p1
-
>
term
.
n
p2
-
>
term
.
n
)
;
int
res
=
fts5Memcmp
(
p1
-
>
term
.
p
p2
-
>
term
.
p
nMin
)
;
if
(
res
=
=
0
)
res
=
p1
-
>
term
.
n
-
p2
-
>
term
.
n
;
if
(
res
=
=
0
)
{
assert
(
pRes
-
>
bTermEq
=
=
1
)
;
assert
(
p1
-
>
iRowid
!
=
p2
-
>
iRowid
)
;
res
=
(
(
p1
-
>
iRowid
>
p2
-
>
iRowid
)
=
=
pIter
-
>
bRev
)
?
-
1
:
1
;
}
else
{
assert
(
pRes
-
>
bTermEq
=
=
0
)
;
}
if
(
res
<
0
)
{
assert
(
pRes
-
>
iFirst
=
=
i1
)
;
}
else
{
assert
(
pRes
-
>
iFirst
=
=
i2
)
;
}
}
}
}
static
void
fts5AssertMultiIterSetup
(
Fts5Index
*
p
Fts5Iter
*
pIter
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
Fts5SegIter
*
pFirst
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
int
i
;
assert
(
(
pFirst
-
>
pLeaf
=
=
0
)
=
=
pIter
-
>
base
.
bEof
)
;
for
(
i
=
0
;
i
<
pIter
-
>
nSeg
;
i
+
+
)
{
Fts5SegIter
*
p1
=
&
pIter
-
>
aSeg
[
i
]
;
assert
(
p1
=
=
pFirst
|
|
p1
-
>
pLeaf
=
=
0
|
|
fts5BufferCompare
(
&
pFirst
-
>
term
&
p1
-
>
term
)
|
|
p1
-
>
iRowid
=
=
pIter
-
>
iSwitchRowid
|
|
(
p1
-
>
iRowid
<
pIter
-
>
iSwitchRowid
)
=
=
pIter
-
>
bRev
)
;
}
for
(
i
=
0
;
i
<
pIter
-
>
nSeg
;
i
+
=
2
)
{
Fts5SegIter
*
p1
=
&
pIter
-
>
aSeg
[
i
]
;
Fts5SegIter
*
p2
=
&
pIter
-
>
aSeg
[
i
+
1
]
;
Fts5CResult
*
pRes
=
&
pIter
-
>
aFirst
[
(
pIter
-
>
nSeg
+
i
)
/
2
]
;
fts5AssertComparisonResult
(
pIter
p1
p2
pRes
)
;
}
for
(
i
=
1
;
i
<
(
pIter
-
>
nSeg
/
2
)
;
i
+
=
2
)
{
Fts5SegIter
*
p1
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
i
*
2
]
.
iFirst
]
;
Fts5SegIter
*
p2
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
i
*
2
+
1
]
.
iFirst
]
;
Fts5CResult
*
pRes
=
&
pIter
-
>
aFirst
[
i
]
;
fts5AssertComparisonResult
(
pIter
p1
p2
pRes
)
;
}
}
}
#
else
#
define
fts5AssertMultiIterSetup
(
x
y
)
#
endif
static
int
fts5MultiIterDoCompare
(
Fts5Iter
*
pIter
int
iOut
)
{
int
i1
;
int
i2
;
int
iRes
;
Fts5SegIter
*
p1
;
Fts5SegIter
*
p2
;
Fts5CResult
*
pRes
=
&
pIter
-
>
aFirst
[
iOut
]
;
assert
(
iOut
<
pIter
-
>
nSeg
&
&
iOut
>
0
)
;
assert
(
pIter
-
>
bRev
=
=
0
|
|
pIter
-
>
bRev
=
=
1
)
;
if
(
iOut
>
=
(
pIter
-
>
nSeg
/
2
)
)
{
i1
=
(
iOut
-
pIter
-
>
nSeg
/
2
)
*
2
;
i2
=
i1
+
1
;
}
else
{
i1
=
pIter
-
>
aFirst
[
iOut
*
2
]
.
iFirst
;
i2
=
pIter
-
>
aFirst
[
iOut
*
2
+
1
]
.
iFirst
;
}
p1
=
&
pIter
-
>
aSeg
[
i1
]
;
p2
=
&
pIter
-
>
aSeg
[
i2
]
;
pRes
-
>
bTermEq
=
0
;
if
(
p1
-
>
pLeaf
=
=
0
)
{
iRes
=
i2
;
}
else
if
(
p2
-
>
pLeaf
=
=
0
)
{
iRes
=
i1
;
}
else
{
int
res
=
fts5BufferCompare
(
&
p1
-
>
term
&
p2
-
>
term
)
;
if
(
res
=
=
0
)
{
assert_nc
(
i2
>
i1
)
;
assert_nc
(
i2
!
=
0
)
;
pRes
-
>
bTermEq
=
1
;
if
(
p1
-
>
iRowid
=
=
p2
-
>
iRowid
)
{
return
i2
;
}
res
=
(
(
p1
-
>
iRowid
>
p2
-
>
iRowid
)
=
=
pIter
-
>
bRev
)
?
-
1
:
+
1
;
}
assert
(
res
!
=
0
)
;
if
(
res
<
0
)
{
iRes
=
i1
;
}
else
{
iRes
=
i2
;
}
}
pRes
-
>
iFirst
=
(
u16
)
iRes
;
return
0
;
}
static
void
fts5SegIterGotoPage
(
Fts5Index
*
p
Fts5SegIter
*
pIter
int
iLeafPgno
)
{
assert
(
iLeafPgno
>
pIter
-
>
iLeafPgno
)
;
if
(
iLeafPgno
>
pIter
-
>
pSeg
-
>
pgnoLast
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
fts5DataRelease
(
pIter
-
>
pNextLeaf
)
;
pIter
-
>
pNextLeaf
=
0
;
pIter
-
>
iLeafPgno
=
iLeafPgno
-
1
;
while
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
iOff
;
fts5SegIterNextPage
(
p
pIter
)
;
if
(
pIter
-
>
pLeaf
=
=
0
)
break
;
iOff
=
fts5LeafFirstRowidOff
(
pIter
-
>
pLeaf
)
;
if
(
iOff
>
0
)
{
u8
*
a
=
pIter
-
>
pLeaf
-
>
p
;
int
n
=
pIter
-
>
pLeaf
-
>
szLeaf
;
if
(
iOff
<
4
|
|
iOff
>
=
n
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
iOff
+
=
fts5GetVarint
(
&
a
[
iOff
]
(
u64
*
)
&
pIter
-
>
iRowid
)
;
pIter
-
>
iLeafOffset
=
iOff
;
fts5SegIterLoadNPos
(
p
pIter
)
;
}
break
;
}
}
}
}
static
void
fts5SegIterNextFrom
(
Fts5Index
*
p
Fts5SegIter
*
pIter
i64
iMatch
)
{
int
bRev
=
(
pIter
-
>
flags
&
FTS5_SEGITER_REVERSE
)
;
Fts5DlidxIter
*
pDlidx
=
pIter
-
>
pDlidx
;
int
iLeafPgno
=
pIter
-
>
iLeafPgno
;
int
bMove
=
1
;
assert
(
pIter
-
>
flags
&
FTS5_SEGITER_ONETERM
)
;
assert
(
pIter
-
>
pDlidx
)
;
assert
(
pIter
-
>
pLeaf
)
;
if
(
bRev
=
=
0
)
{
while
(
!
fts5DlidxIterEof
(
p
pDlidx
)
&
&
iMatch
>
fts5DlidxIterRowid
(
pDlidx
)
)
{
iLeafPgno
=
fts5DlidxIterPgno
(
pDlidx
)
;
fts5DlidxIterNext
(
p
pDlidx
)
;
}
assert_nc
(
iLeafPgno
>
=
pIter
-
>
iLeafPgno
|
|
p
-
>
rc
)
;
if
(
iLeafPgno
>
pIter
-
>
iLeafPgno
)
{
fts5SegIterGotoPage
(
p
pIter
iLeafPgno
)
;
bMove
=
0
;
}
}
else
{
assert
(
pIter
-
>
pNextLeaf
=
=
0
)
;
assert
(
iMatch
<
pIter
-
>
iRowid
)
;
while
(
!
fts5DlidxIterEof
(
p
pDlidx
)
&
&
iMatch
<
fts5DlidxIterRowid
(
pDlidx
)
)
{
fts5DlidxIterPrev
(
p
pDlidx
)
;
}
iLeafPgno
=
fts5DlidxIterPgno
(
pDlidx
)
;
assert
(
fts5DlidxIterEof
(
p
pDlidx
)
|
|
iLeafPgno
<
=
pIter
-
>
iLeafPgno
)
;
if
(
iLeafPgno
<
pIter
-
>
iLeafPgno
)
{
pIter
-
>
iLeafPgno
=
iLeafPgno
+
1
;
fts5SegIterReverseNewPage
(
p
pIter
)
;
bMove
=
0
;
}
}
do
{
if
(
bMove
&
&
p
-
>
rc
=
=
SQLITE_OK
)
pIter
-
>
xNext
(
p
pIter
0
)
;
if
(
pIter
-
>
pLeaf
=
=
0
)
break
;
if
(
bRev
=
=
0
&
&
pIter
-
>
iRowid
>
=
iMatch
)
break
;
if
(
bRev
!
=
0
&
&
pIter
-
>
iRowid
<
=
iMatch
)
break
;
bMove
=
1
;
}
while
(
p
-
>
rc
=
=
SQLITE_OK
)
;
}
static
void
fts5MultiIterFree
(
Fts5Iter
*
pIter
)
{
if
(
pIter
)
{
int
i
;
for
(
i
=
0
;
i
<
pIter
-
>
nSeg
;
i
+
+
)
{
fts5SegIterClear
(
&
pIter
-
>
aSeg
[
i
]
)
;
}
fts5BufferFree
(
&
pIter
-
>
poslist
)
;
sqlite3_free
(
pIter
)
;
}
}
static
void
fts5MultiIterAdvanced
(
Fts5Index
*
p
Fts5Iter
*
pIter
int
iChanged
int
iMinset
)
{
int
i
;
for
(
i
=
(
pIter
-
>
nSeg
+
iChanged
)
/
2
;
i
>
=
iMinset
&
&
p
-
>
rc
=
=
SQLITE_OK
;
i
=
i
/
2
)
{
int
iEq
;
if
(
(
iEq
=
fts5MultiIterDoCompare
(
pIter
i
)
)
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
iEq
]
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
pSeg
-
>
xNext
(
p
pSeg
0
)
;
i
=
pIter
-
>
nSeg
+
iEq
;
}
}
}
static
int
fts5MultiIterAdvanceRowid
(
Fts5Iter
*
pIter
int
iChanged
Fts5SegIter
*
*
ppFirst
)
{
Fts5SegIter
*
pNew
=
&
pIter
-
>
aSeg
[
iChanged
]
;
if
(
pNew
-
>
iRowid
=
=
pIter
-
>
iSwitchRowid
|
|
(
pNew
-
>
iRowid
<
pIter
-
>
iSwitchRowid
)
=
=
pIter
-
>
bRev
)
{
int
i
;
Fts5SegIter
*
pOther
=
&
pIter
-
>
aSeg
[
iChanged
^
0x0001
]
;
pIter
-
>
iSwitchRowid
=
pIter
-
>
bRev
?
SMALLEST_INT64
:
LARGEST_INT64
;
for
(
i
=
(
pIter
-
>
nSeg
+
iChanged
)
/
2
;
1
;
i
=
i
/
2
)
{
Fts5CResult
*
pRes
=
&
pIter
-
>
aFirst
[
i
]
;
assert
(
pNew
-
>
pLeaf
)
;
assert
(
pRes
-
>
bTermEq
=
=
0
|
|
pOther
-
>
pLeaf
)
;
if
(
pRes
-
>
bTermEq
)
{
if
(
pNew
-
>
iRowid
=
=
pOther
-
>
iRowid
)
{
return
1
;
}
else
if
(
(
pOther
-
>
iRowid
>
pNew
-
>
iRowid
)
=
=
pIter
-
>
bRev
)
{
pIter
-
>
iSwitchRowid
=
pOther
-
>
iRowid
;
pNew
=
pOther
;
}
else
if
(
(
pOther
-
>
iRowid
>
pIter
-
>
iSwitchRowid
)
=
=
pIter
-
>
bRev
)
{
pIter
-
>
iSwitchRowid
=
pOther
-
>
iRowid
;
}
}
pRes
-
>
iFirst
=
(
u16
)
(
pNew
-
pIter
-
>
aSeg
)
;
if
(
i
=
=
1
)
break
;
pOther
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
i
^
0x0001
]
.
iFirst
]
;
}
}
*
ppFirst
=
pNew
;
return
0
;
}
static
void
fts5MultiIterSetEof
(
Fts5Iter
*
pIter
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
pIter
-
>
base
.
bEof
=
pSeg
-
>
pLeaf
=
=
0
;
pIter
-
>
iSwitchRowid
=
pSeg
-
>
iRowid
;
}
#
define
TOMBSTONE_KEYSIZE
(
pPg
)
(
pPg
-
>
p
[
0
]
=
=
4
?
4
:
8
)
#
define
TOMBSTONE_NSLOT
(
pPg
)
\
(
(
pPg
-
>
nn
>
16
)
?
(
(
pPg
-
>
nn
-
8
)
/
TOMBSTONE_KEYSIZE
(
pPg
)
)
:
1
)
static
int
fts5IndexTombstoneQuery
(
Fts5Data
*
pHash
int
nHashTable
u64
iRowid
)
{
const
int
szKey
=
TOMBSTONE_KEYSIZE
(
pHash
)
;
const
int
nSlot
=
TOMBSTONE_NSLOT
(
pHash
)
;
int
iSlot
=
(
iRowid
/
nHashTable
)
%
nSlot
;
int
nCollide
=
nSlot
;
if
(
iRowid
=
=
0
)
{
return
pHash
-
>
p
[
1
]
;
}
else
if
(
szKey
=
=
4
)
{
u32
*
aSlot
=
(
u32
*
)
&
pHash
-
>
p
[
8
]
;
while
(
aSlot
[
iSlot
]
)
{
if
(
fts5GetU32
(
(
u8
*
)
&
aSlot
[
iSlot
]
)
=
=
iRowid
)
return
1
;
if
(
nCollide
-
-
=
=
0
)
break
;
iSlot
=
(
iSlot
+
1
)
%
nSlot
;
}
}
else
{
u64
*
aSlot
=
(
u64
*
)
&
pHash
-
>
p
[
8
]
;
while
(
aSlot
[
iSlot
]
)
{
if
(
fts5GetU64
(
(
u8
*
)
&
aSlot
[
iSlot
]
)
=
=
iRowid
)
return
1
;
if
(
nCollide
-
-
=
=
0
)
break
;
iSlot
=
(
iSlot
+
1
)
%
nSlot
;
}
}
return
0
;
}
static
int
fts5MultiIterIsDeleted
(
Fts5Iter
*
pIter
)
{
int
iFirst
=
pIter
-
>
aFirst
[
1
]
.
iFirst
;
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
iFirst
]
;
Fts5TombstoneArray
*
pArray
=
pSeg
-
>
pTombArray
;
if
(
pSeg
-
>
pLeaf
&
&
pArray
)
{
int
iPg
=
(
(
u64
)
pSeg
-
>
iRowid
)
%
pArray
-
>
nTombstone
;
assert
(
iPg
>
=
0
)
;
if
(
pArray
-
>
apTombstone
[
iPg
]
=
=
0
)
{
pArray
-
>
apTombstone
[
iPg
]
=
fts5DataRead
(
pIter
-
>
pIndex
FTS5_TOMBSTONE_ROWID
(
pSeg
-
>
pSeg
-
>
iSegid
iPg
)
)
;
if
(
pArray
-
>
apTombstone
[
iPg
]
=
=
0
)
return
0
;
}
return
fts5IndexTombstoneQuery
(
pArray
-
>
apTombstone
[
iPg
]
pArray
-
>
nTombstone
pSeg
-
>
iRowid
)
;
}
return
0
;
}
static
void
fts5MultiIterNext
(
Fts5Index
*
p
Fts5Iter
*
pIter
int
bFrom
i64
iFrom
)
{
int
bUseFrom
=
bFrom
;
assert
(
pIter
-
>
base
.
bEof
=
=
0
)
;
while
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
iFirst
=
pIter
-
>
aFirst
[
1
]
.
iFirst
;
int
bNewTerm
=
0
;
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
iFirst
]
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
if
(
bUseFrom
&
&
pSeg
-
>
pDlidx
)
{
fts5SegIterNextFrom
(
p
pSeg
iFrom
)
;
}
else
{
pSeg
-
>
xNext
(
p
pSeg
&
bNewTerm
)
;
}
if
(
pSeg
-
>
pLeaf
=
=
0
|
|
bNewTerm
|
|
fts5MultiIterAdvanceRowid
(
pIter
iFirst
&
pSeg
)
)
{
fts5MultiIterAdvanced
(
p
pIter
iFirst
1
)
;
fts5MultiIterSetEof
(
pIter
)
;
pSeg
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
if
(
pSeg
-
>
pLeaf
=
=
0
)
return
;
}
fts5AssertMultiIterSetup
(
p
pIter
)
;
assert
(
pSeg
=
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
&
&
pSeg
-
>
pLeaf
)
;
if
(
(
pIter
-
>
bSkipEmpty
=
=
0
|
|
pSeg
-
>
nPos
)
&
&
0
=
=
fts5MultiIterIsDeleted
(
pIter
)
)
{
pIter
-
>
xSetOutputs
(
pIter
pSeg
)
;
return
;
}
bUseFrom
=
0
;
}
}
static
void
fts5MultiIterNext2
(
Fts5Index
*
p
Fts5Iter
*
pIter
int
*
pbNewTerm
)
{
assert
(
pIter
-
>
bSkipEmpty
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
*
pbNewTerm
=
0
;
do
{
int
iFirst
=
pIter
-
>
aFirst
[
1
]
.
iFirst
;
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
iFirst
]
;
int
bNewTerm
=
0
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
pSeg
-
>
xNext
(
p
pSeg
&
bNewTerm
)
;
if
(
pSeg
-
>
pLeaf
=
=
0
|
|
bNewTerm
|
|
fts5MultiIterAdvanceRowid
(
pIter
iFirst
&
pSeg
)
)
{
fts5MultiIterAdvanced
(
p
pIter
iFirst
1
)
;
fts5MultiIterSetEof
(
pIter
)
;
*
pbNewTerm
=
1
;
}
fts5AssertMultiIterSetup
(
p
pIter
)
;
}
while
(
(
fts5MultiIterIsEmpty
(
p
pIter
)
|
|
fts5MultiIterIsDeleted
(
pIter
)
)
&
&
(
p
-
>
rc
=
=
SQLITE_OK
)
)
;
}
}
static
void
fts5IterSetOutputs_Noop
(
Fts5Iter
*
pUnused1
Fts5SegIter
*
pUnused2
)
{
UNUSED_PARAM2
(
pUnused1
pUnused2
)
;
}
static
Fts5Iter
*
fts5MultiIterAlloc
(
Fts5Index
*
p
int
nSeg
)
{
Fts5Iter
*
pNew
;
i64
nSlot
;
for
(
nSlot
=
2
;
nSlot
<
nSeg
;
nSlot
=
nSlot
*
2
)
;
pNew
=
fts5IdxMalloc
(
p
sizeof
(
Fts5Iter
)
+
sizeof
(
Fts5SegIter
)
*
(
nSlot
-
1
)
+
sizeof
(
Fts5CResult
)
*
nSlot
)
;
if
(
pNew
)
{
pNew
-
>
nSeg
=
nSlot
;
pNew
-
>
aFirst
=
(
Fts5CResult
*
)
&
pNew
-
>
aSeg
[
nSlot
]
;
pNew
-
>
pIndex
=
p
;
pNew
-
>
xSetOutputs
=
fts5IterSetOutputs_Noop
;
}
return
pNew
;
}
static
void
fts5PoslistCallback
(
Fts5Index
*
pUnused
void
*
pContext
const
u8
*
pChunk
int
nChunk
)
{
UNUSED_PARAM
(
pUnused
)
;
assert_nc
(
nChunk
>
=
0
)
;
if
(
nChunk
>
0
)
{
fts5BufferSafeAppendBlob
(
(
Fts5Buffer
*
)
pContext
pChunk
nChunk
)
;
}
}
typedef
struct
PoslistCallbackCtx
PoslistCallbackCtx
;
struct
PoslistCallbackCtx
{
Fts5Buffer
*
pBuf
;
Fts5Colset
*
pColset
;
int
eState
;
}
;
typedef
struct
PoslistOffsetsCtx
PoslistOffsetsCtx
;
struct
PoslistOffsetsCtx
{
Fts5Buffer
*
pBuf
;
Fts5Colset
*
pColset
;
int
iRead
;
int
iWrite
;
}
;
static
int
fts5IndexColsetTest
(
Fts5Colset
*
pColset
int
iCol
)
{
int
i
;
for
(
i
=
0
;
i
<
pColset
-
>
nCol
;
i
+
+
)
{
if
(
pColset
-
>
aiCol
[
i
]
=
=
iCol
)
return
1
;
}
return
0
;
}
static
void
fts5PoslistOffsetsCallback
(
Fts5Index
*
pUnused
void
*
pContext
const
u8
*
pChunk
int
nChunk
)
{
PoslistOffsetsCtx
*
pCtx
=
(
PoslistOffsetsCtx
*
)
pContext
;
UNUSED_PARAM
(
pUnused
)
;
assert_nc
(
nChunk
>
=
0
)
;
if
(
nChunk
>
0
)
{
int
i
=
0
;
while
(
i
<
nChunk
)
{
int
iVal
;
i
+
=
fts5GetVarint32
(
&
pChunk
[
i
]
iVal
)
;
iVal
+
=
pCtx
-
>
iRead
-
2
;
pCtx
-
>
iRead
=
iVal
;
if
(
fts5IndexColsetTest
(
pCtx
-
>
pColset
iVal
)
)
{
fts5BufferSafeAppendVarint
(
pCtx
-
>
pBuf
iVal
+
2
-
pCtx
-
>
iWrite
)
;
pCtx
-
>
iWrite
=
iVal
;
}
}
}
}
static
void
fts5PoslistFilterCallback
(
Fts5Index
*
pUnused
void
*
pContext
const
u8
*
pChunk
int
nChunk
)
{
PoslistCallbackCtx
*
pCtx
=
(
PoslistCallbackCtx
*
)
pContext
;
UNUSED_PARAM
(
pUnused
)
;
assert_nc
(
nChunk
>
=
0
)
;
if
(
nChunk
>
0
)
{
int
i
=
0
;
int
iStart
=
0
;
if
(
pCtx
-
>
eState
=
=
2
)
{
int
iCol
;
fts5FastGetVarint32
(
pChunk
i
iCol
)
;
if
(
fts5IndexColsetTest
(
pCtx
-
>
pColset
iCol
)
)
{
pCtx
-
>
eState
=
1
;
fts5BufferSafeAppendVarint
(
pCtx
-
>
pBuf
1
)
;
}
else
{
pCtx
-
>
eState
=
0
;
}
}
do
{
while
(
i
<
nChunk
&
&
pChunk
[
i
]
!
=
0x01
)
{
while
(
pChunk
[
i
]
&
0x80
)
i
+
+
;
i
+
+
;
}
if
(
pCtx
-
>
eState
)
{
fts5BufferSafeAppendBlob
(
pCtx
-
>
pBuf
&
pChunk
[
iStart
]
i
-
iStart
)
;
}
if
(
i
<
nChunk
)
{
int
iCol
;
iStart
=
i
;
i
+
+
;
if
(
i
>
=
nChunk
)
{
pCtx
-
>
eState
=
2
;
}
else
{
fts5FastGetVarint32
(
pChunk
i
iCol
)
;
pCtx
-
>
eState
=
fts5IndexColsetTest
(
pCtx
-
>
pColset
iCol
)
;
if
(
pCtx
-
>
eState
)
{
fts5BufferSafeAppendBlob
(
pCtx
-
>
pBuf
&
pChunk
[
iStart
]
i
-
iStart
)
;
iStart
=
i
;
}
}
}
}
while
(
i
<
nChunk
)
;
}
}
static
void
fts5ChunkIterate
(
Fts5Index
*
p
Fts5SegIter
*
pSeg
void
*
pCtx
void
(
*
xChunk
)
(
Fts5Index
*
void
*
const
u8
*
int
)
)
{
int
nRem
=
pSeg
-
>
nPos
;
Fts5Data
*
pData
=
0
;
u8
*
pChunk
=
&
pSeg
-
>
pLeaf
-
>
p
[
pSeg
-
>
iLeafOffset
]
;
int
nChunk
=
MIN
(
nRem
pSeg
-
>
pLeaf
-
>
szLeaf
-
pSeg
-
>
iLeafOffset
)
;
int
pgno
=
pSeg
-
>
iLeafPgno
;
int
pgnoSave
=
0
;
assert
(
p
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
;
if
(
(
pSeg
-
>
flags
&
FTS5_SEGITER_REVERSE
)
=
=
0
)
{
pgnoSave
=
pgno
+
1
;
}
while
(
1
)
{
xChunk
(
p
pCtx
pChunk
nChunk
)
;
nRem
-
=
nChunk
;
fts5DataRelease
(
pData
)
;
if
(
nRem
<
=
0
)
{
break
;
}
else
if
(
pSeg
-
>
pSeg
=
=
0
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
return
;
}
else
{
pgno
+
+
;
pData
=
fts5LeafRead
(
p
FTS5_SEGMENT_ROWID
(
pSeg
-
>
pSeg
-
>
iSegid
pgno
)
)
;
if
(
pData
=
=
0
)
break
;
pChunk
=
&
pData
-
>
p
[
4
]
;
nChunk
=
MIN
(
nRem
pData
-
>
szLeaf
-
4
)
;
if
(
pgno
=
=
pgnoSave
)
{
assert
(
pSeg
-
>
pNextLeaf
=
=
0
)
;
pSeg
-
>
pNextLeaf
=
pData
;
pData
=
0
;
}
}
}
}
static
void
fts5SegiterPoslist
(
Fts5Index
*
p
Fts5SegIter
*
pSeg
Fts5Colset
*
pColset
Fts5Buffer
*
pBuf
)
{
assert
(
pBuf
!
=
0
)
;
assert
(
pSeg
!
=
0
)
;
if
(
0
=
=
fts5BufferGrow
(
&
p
-
>
rc
pBuf
pSeg
-
>
nPos
+
FTS5_DATA_ZERO_PADDING
)
)
{
assert
(
pBuf
-
>
p
!
=
0
)
;
assert
(
pBuf
-
>
nSpace
>
=
pBuf
-
>
n
+
pSeg
-
>
nPos
+
FTS5_DATA_ZERO_PADDING
)
;
memset
(
&
pBuf
-
>
p
[
pBuf
-
>
n
+
pSeg
-
>
nPos
]
0
FTS5_DATA_ZERO_PADDING
)
;
if
(
pColset
=
=
0
)
{
fts5ChunkIterate
(
p
pSeg
(
void
*
)
pBuf
fts5PoslistCallback
)
;
}
else
{
if
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
{
PoslistCallbackCtx
sCtx
;
sCtx
.
pBuf
=
pBuf
;
sCtx
.
pColset
=
pColset
;
sCtx
.
eState
=
fts5IndexColsetTest
(
pColset
0
)
;
assert
(
sCtx
.
eState
=
=
0
|
|
sCtx
.
eState
=
=
1
)
;
fts5ChunkIterate
(
p
pSeg
(
void
*
)
&
sCtx
fts5PoslistFilterCallback
)
;
}
else
{
PoslistOffsetsCtx
sCtx
;
memset
(
&
sCtx
0
sizeof
(
sCtx
)
)
;
sCtx
.
pBuf
=
pBuf
;
sCtx
.
pColset
=
pColset
;
fts5ChunkIterate
(
p
pSeg
(
void
*
)
&
sCtx
fts5PoslistOffsetsCallback
)
;
}
}
}
}
static
void
fts5IndexExtractColset
(
int
*
pRc
Fts5Colset
*
pColset
const
u8
*
pPos
int
nPos
Fts5Iter
*
pIter
)
{
if
(
*
pRc
=
=
SQLITE_OK
)
{
const
u8
*
p
=
pPos
;
const
u8
*
aCopy
=
p
;
const
u8
*
pEnd
=
&
p
[
nPos
]
;
int
i
=
0
;
int
iCurrent
=
0
;
if
(
pColset
-
>
nCol
>
1
&
&
sqlite3Fts5BufferSize
(
pRc
&
pIter
-
>
poslist
nPos
)
)
{
return
;
}
while
(
1
)
{
while
(
pColset
-
>
aiCol
[
i
]
<
iCurrent
)
{
i
+
+
;
if
(
i
=
=
pColset
-
>
nCol
)
{
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
pIter
-
>
base
.
nData
=
pIter
-
>
poslist
.
n
;
return
;
}
}
while
(
p
<
pEnd
&
&
*
p
!
=
0x01
)
{
while
(
*
p
+
+
&
0x80
)
;
}
if
(
pColset
-
>
aiCol
[
i
]
=
=
iCurrent
)
{
if
(
pColset
-
>
nCol
=
=
1
)
{
pIter
-
>
base
.
pData
=
aCopy
;
pIter
-
>
base
.
nData
=
p
-
aCopy
;
return
;
}
fts5BufferSafeAppendBlob
(
&
pIter
-
>
poslist
aCopy
p
-
aCopy
)
;
}
if
(
p
>
=
pEnd
)
{
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
pIter
-
>
base
.
nData
=
pIter
-
>
poslist
.
n
;
return
;
}
aCopy
=
p
+
+
;
iCurrent
=
*
p
+
+
;
if
(
iCurrent
&
0x80
)
{
p
-
-
;
p
+
=
fts5GetVarint32
(
p
iCurrent
)
;
}
}
}
}
static
void
fts5IterSetOutputs_None
(
Fts5Iter
*
pIter
Fts5SegIter
*
pSeg
)
{
assert
(
pIter
-
>
pIndex
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
;
pIter
-
>
base
.
iRowid
=
pSeg
-
>
iRowid
;
pIter
-
>
base
.
nData
=
pSeg
-
>
nPos
;
}
static
void
fts5IterSetOutputs_Nocolset
(
Fts5Iter
*
pIter
Fts5SegIter
*
pSeg
)
{
pIter
-
>
base
.
iRowid
=
pSeg
-
>
iRowid
;
pIter
-
>
base
.
nData
=
pSeg
-
>
nPos
;
assert
(
pIter
-
>
pIndex
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
;
assert
(
pIter
-
>
pColset
=
=
0
)
;
if
(
pSeg
-
>
iLeafOffset
+
pSeg
-
>
nPos
<
=
pSeg
-
>
pLeaf
-
>
szLeaf
)
{
pIter
-
>
base
.
pData
=
&
pSeg
-
>
pLeaf
-
>
p
[
pSeg
-
>
iLeafOffset
]
;
}
else
{
fts5BufferZero
(
&
pIter
-
>
poslist
)
;
fts5SegiterPoslist
(
pIter
-
>
pIndex
pSeg
0
&
pIter
-
>
poslist
)
;
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
}
}
static
void
fts5IterSetOutputs_ZeroColset
(
Fts5Iter
*
pIter
Fts5SegIter
*
pSeg
)
{
UNUSED_PARAM
(
pSeg
)
;
pIter
-
>
base
.
nData
=
0
;
}
static
void
fts5IterSetOutputs_Col
(
Fts5Iter
*
pIter
Fts5SegIter
*
pSeg
)
{
fts5BufferZero
(
&
pIter
-
>
poslist
)
;
fts5SegiterPoslist
(
pIter
-
>
pIndex
pSeg
pIter
-
>
pColset
&
pIter
-
>
poslist
)
;
pIter
-
>
base
.
iRowid
=
pSeg
-
>
iRowid
;
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
pIter
-
>
base
.
nData
=
pIter
-
>
poslist
.
n
;
}
static
void
fts5IterSetOutputs_Col100
(
Fts5Iter
*
pIter
Fts5SegIter
*
pSeg
)
{
assert
(
pIter
-
>
pIndex
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
;
assert
(
pIter
-
>
pColset
)
;
if
(
pSeg
-
>
iLeafOffset
+
pSeg
-
>
nPos
>
pSeg
-
>
pLeaf
-
>
szLeaf
)
{
fts5IterSetOutputs_Col
(
pIter
pSeg
)
;
}
else
{
u8
*
a
=
(
u8
*
)
&
pSeg
-
>
pLeaf
-
>
p
[
pSeg
-
>
iLeafOffset
]
;
u8
*
pEnd
=
(
u8
*
)
&
a
[
pSeg
-
>
nPos
]
;
int
iPrev
=
0
;
int
*
aiCol
=
pIter
-
>
pColset
-
>
aiCol
;
int
*
aiColEnd
=
&
aiCol
[
pIter
-
>
pColset
-
>
nCol
]
;
u8
*
aOut
=
pIter
-
>
poslist
.
p
;
int
iPrevOut
=
0
;
pIter
-
>
base
.
iRowid
=
pSeg
-
>
iRowid
;
while
(
a
<
pEnd
)
{
iPrev
+
=
(
int
)
a
+
+
[
0
]
-
2
;
while
(
*
aiCol
<
iPrev
)
{
aiCol
+
+
;
if
(
aiCol
=
=
aiColEnd
)
goto
setoutputs_col_out
;
}
if
(
*
aiCol
=
=
iPrev
)
{
*
aOut
+
+
=
(
u8
)
(
(
iPrev
-
iPrevOut
)
+
2
)
;
iPrevOut
=
iPrev
;
}
}
setoutputs_col_out
:
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
pIter
-
>
base
.
nData
=
aOut
-
pIter
-
>
poslist
.
p
;
}
}
static
void
fts5IterSetOutputs_Full
(
Fts5Iter
*
pIter
Fts5SegIter
*
pSeg
)
{
Fts5Colset
*
pColset
=
pIter
-
>
pColset
;
pIter
-
>
base
.
iRowid
=
pSeg
-
>
iRowid
;
assert
(
pIter
-
>
pIndex
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
;
assert
(
pColset
)
;
if
(
pSeg
-
>
iLeafOffset
+
pSeg
-
>
nPos
<
=
pSeg
-
>
pLeaf
-
>
szLeaf
)
{
const
u8
*
a
=
&
pSeg
-
>
pLeaf
-
>
p
[
pSeg
-
>
iLeafOffset
]
;
int
*
pRc
=
&
pIter
-
>
pIndex
-
>
rc
;
fts5BufferZero
(
&
pIter
-
>
poslist
)
;
fts5IndexExtractColset
(
pRc
pColset
a
pSeg
-
>
nPos
pIter
)
;
}
else
{
fts5BufferZero
(
&
pIter
-
>
poslist
)
;
fts5SegiterPoslist
(
pIter
-
>
pIndex
pSeg
pColset
&
pIter
-
>
poslist
)
;
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
pIter
-
>
base
.
nData
=
pIter
-
>
poslist
.
n
;
}
}
static
void
fts5IterSetOutputCb
(
int
*
pRc
Fts5Iter
*
pIter
)
{
assert
(
pIter
!
=
0
|
|
(
*
pRc
)
!
=
SQLITE_OK
)
;
if
(
*
pRc
=
=
SQLITE_OK
)
{
Fts5Config
*
pConfig
=
pIter
-
>
pIndex
-
>
pConfig
;
if
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
pIter
-
>
xSetOutputs
=
fts5IterSetOutputs_None
;
}
else
if
(
pIter
-
>
pColset
=
=
0
)
{
pIter
-
>
xSetOutputs
=
fts5IterSetOutputs_Nocolset
;
}
else
if
(
pIter
-
>
pColset
-
>
nCol
=
=
0
)
{
pIter
-
>
xSetOutputs
=
fts5IterSetOutputs_ZeroColset
;
}
else
if
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
{
pIter
-
>
xSetOutputs
=
fts5IterSetOutputs_Full
;
}
else
{
assert
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
;
if
(
pConfig
-
>
nCol
<
=
100
)
{
pIter
-
>
xSetOutputs
=
fts5IterSetOutputs_Col100
;
sqlite3Fts5BufferSize
(
pRc
&
pIter
-
>
poslist
pConfig
-
>
nCol
)
;
}
else
{
pIter
-
>
xSetOutputs
=
fts5IterSetOutputs_Col
;
}
}
}
}
static
void
fts5MultiIterFinishSetup
(
Fts5Index
*
p
Fts5Iter
*
pIter
)
{
int
iIter
;
for
(
iIter
=
pIter
-
>
nSeg
-
1
;
iIter
>
0
;
iIter
-
-
)
{
int
iEq
;
if
(
(
iEq
=
fts5MultiIterDoCompare
(
pIter
iIter
)
)
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
iEq
]
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
pSeg
-
>
xNext
(
p
pSeg
0
)
;
fts5MultiIterAdvanced
(
p
pIter
iEq
iIter
)
;
}
}
fts5MultiIterSetEof
(
pIter
)
;
fts5AssertMultiIterSetup
(
p
pIter
)
;
if
(
(
pIter
-
>
bSkipEmpty
&
&
fts5MultiIterIsEmpty
(
p
pIter
)
)
|
|
fts5MultiIterIsDeleted
(
pIter
)
)
{
fts5MultiIterNext
(
p
pIter
0
0
)
;
}
else
if
(
pIter
-
>
base
.
bEof
=
=
0
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
pIter
-
>
xSetOutputs
(
pIter
pSeg
)
;
}
}
static
void
fts5MultiIterNew
(
Fts5Index
*
p
Fts5Structure
*
pStruct
int
flags
Fts5Colset
*
pColset
const
u8
*
pTerm
int
nTerm
int
iLevel
int
nSegment
Fts5Iter
*
*
ppOut
)
{
int
nSeg
=
0
;
int
iIter
=
0
;
int
iSeg
;
Fts5StructureLevel
*
pLvl
;
Fts5Iter
*
pNew
;
assert
(
(
pTerm
=
=
0
&
&
nTerm
=
=
0
)
|
|
iLevel
<
0
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
iLevel
<
0
)
{
assert
(
pStruct
-
>
nSegment
=
=
fts5StructureCountSegments
(
pStruct
)
)
;
nSeg
=
pStruct
-
>
nSegment
;
nSeg
+
=
(
p
-
>
pHash
&
&
0
=
=
(
flags
&
FTS5INDEX_QUERY_SKIPHASH
)
)
;
}
else
{
nSeg
=
MIN
(
pStruct
-
>
aLevel
[
iLevel
]
.
nSeg
nSegment
)
;
}
}
*
ppOut
=
pNew
=
fts5MultiIterAlloc
(
p
nSeg
)
;
if
(
pNew
=
=
0
)
{
assert
(
p
-
>
rc
!
=
SQLITE_OK
)
;
goto
fts5MultiIterNew_post_check
;
}
pNew
-
>
bRev
=
(
0
!
=
(
flags
&
FTS5INDEX_QUERY_DESC
)
)
;
pNew
-
>
bSkipEmpty
=
(
0
!
=
(
flags
&
FTS5INDEX_QUERY_SKIPEMPTY
)
)
;
pNew
-
>
pColset
=
pColset
;
if
(
(
flags
&
FTS5INDEX_QUERY_NOOUTPUT
)
=
=
0
)
{
fts5IterSetOutputCb
(
&
p
-
>
rc
pNew
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
iLevel
<
0
)
{
Fts5StructureLevel
*
pEnd
=
&
pStruct
-
>
aLevel
[
pStruct
-
>
nLevel
]
;
if
(
p
-
>
pHash
&
&
0
=
=
(
flags
&
FTS5INDEX_QUERY_SKIPHASH
)
)
{
Fts5SegIter
*
pIter
=
&
pNew
-
>
aSeg
[
iIter
+
+
]
;
fts5SegIterHashInit
(
p
pTerm
nTerm
flags
pIter
)
;
}
for
(
pLvl
=
&
pStruct
-
>
aLevel
[
0
]
;
pLvl
<
pEnd
;
pLvl
+
+
)
{
for
(
iSeg
=
pLvl
-
>
nSeg
-
1
;
iSeg
>
=
0
;
iSeg
-
-
)
{
Fts5StructureSegment
*
pSeg
=
&
pLvl
-
>
aSeg
[
iSeg
]
;
Fts5SegIter
*
pIter
=
&
pNew
-
>
aSeg
[
iIter
+
+
]
;
if
(
pTerm
=
=
0
)
{
fts5SegIterInit
(
p
pSeg
pIter
)
;
}
else
{
fts5SegIterSeekInit
(
p
pTerm
nTerm
flags
pSeg
pIter
)
;
}
}
}
}
else
{
pLvl
=
&
pStruct
-
>
aLevel
[
iLevel
]
;
for
(
iSeg
=
nSeg
-
1
;
iSeg
>
=
0
;
iSeg
-
-
)
{
fts5SegIterInit
(
p
&
pLvl
-
>
aSeg
[
iSeg
]
&
pNew
-
>
aSeg
[
iIter
+
+
]
)
;
}
}
assert
(
iIter
=
=
nSeg
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
fts5MultiIterFinishSetup
(
p
pNew
)
;
}
else
{
fts5MultiIterFree
(
pNew
)
;
*
ppOut
=
0
;
}
fts5MultiIterNew_post_check
:
assert
(
(
*
ppOut
)
!
=
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
return
;
}
static
void
fts5MultiIterNew2
(
Fts5Index
*
p
Fts5Data
*
pData
int
bDesc
Fts5Iter
*
*
ppOut
)
{
Fts5Iter
*
pNew
;
pNew
=
fts5MultiIterAlloc
(
p
2
)
;
if
(
pNew
)
{
Fts5SegIter
*
pIter
=
&
pNew
-
>
aSeg
[
1
]
;
pIter
-
>
flags
=
FTS5_SEGITER_ONETERM
;
if
(
pData
-
>
szLeaf
>
0
)
{
pIter
-
>
pLeaf
=
pData
;
pIter
-
>
iLeafOffset
=
fts5GetVarint
(
pData
-
>
p
(
u64
*
)
&
pIter
-
>
iRowid
)
;
pIter
-
>
iEndofDoclist
=
pData
-
>
nn
;
pNew
-
>
aFirst
[
1
]
.
iFirst
=
1
;
if
(
bDesc
)
{
pNew
-
>
bRev
=
1
;
pIter
-
>
flags
|
=
FTS5_SEGITER_REVERSE
;
fts5SegIterReverseInitPage
(
p
pIter
)
;
}
else
{
fts5SegIterLoadNPos
(
p
pIter
)
;
}
pData
=
0
;
}
else
{
pNew
-
>
base
.
bEof
=
1
;
}
fts5SegIterSetNext
(
p
pIter
)
;
*
ppOut
=
pNew
;
}
fts5DataRelease
(
pData
)
;
}
static
int
fts5MultiIterEof
(
Fts5Index
*
p
Fts5Iter
*
pIter
)
{
assert
(
pIter
!
=
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
(
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
.
pLeaf
=
=
0
)
=
=
pIter
-
>
base
.
bEof
)
;
return
(
p
-
>
rc
|
|
pIter
-
>
base
.
bEof
)
;
}
static
i64
fts5MultiIterRowid
(
Fts5Iter
*
pIter
)
{
assert
(
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
.
pLeaf
)
;
return
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
.
iRowid
;
}
static
void
fts5MultiIterNextFrom
(
Fts5Index
*
p
Fts5Iter
*
pIter
i64
iMatch
)
{
while
(
1
)
{
i64
iRowid
;
fts5MultiIterNext
(
p
pIter
1
iMatch
)
;
if
(
fts5MultiIterEof
(
p
pIter
)
)
break
;
iRowid
=
fts5MultiIterRowid
(
pIter
)
;
if
(
pIter
-
>
bRev
=
=
0
&
&
iRowid
>
=
iMatch
)
break
;
if
(
pIter
-
>
bRev
!
=
0
&
&
iRowid
<
=
iMatch
)
break
;
}
}
static
const
u8
*
fts5MultiIterTerm
(
Fts5Iter
*
pIter
int
*
pn
)
{
Fts5SegIter
*
p
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
*
pn
=
p
-
>
term
.
n
;
return
p
-
>
term
.
p
;
}
static
int
fts5AllocateSegid
(
Fts5Index
*
p
Fts5Structure
*
pStruct
)
{
int
iSegid
=
0
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
pStruct
-
>
nSegment
>
=
FTS5_MAX_SEGMENT
)
{
p
-
>
rc
=
SQLITE_FULL
;
}
else
{
u32
aUsed
[
(
FTS5_MAX_SEGMENT
+
31
)
/
32
]
;
int
iLvl
iSeg
;
int
i
;
u32
mask
;
memset
(
aUsed
0
sizeof
(
aUsed
)
)
;
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
for
(
iSeg
=
0
;
iSeg
<
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
;
iSeg
+
+
)
{
int
iId
=
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
iSeg
]
.
iSegid
;
if
(
iId
<
=
FTS5_MAX_SEGMENT
&
&
iId
>
0
)
{
aUsed
[
(
iId
-
1
)
/
32
]
|
=
(
u32
)
1
<
<
(
(
iId
-
1
)
%
32
)
;
}
}
}
for
(
i
=
0
;
aUsed
[
i
]
=
=
0xFFFFFFFF
;
i
+
+
)
;
mask
=
aUsed
[
i
]
;
for
(
iSegid
=
0
;
mask
&
(
(
u32
)
1
<
<
iSegid
)
;
iSegid
+
+
)
;
iSegid
+
=
1
+
i
*
32
;
#
ifdef
SQLITE_DEBUG
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
for
(
iSeg
=
0
;
iSeg
<
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
;
iSeg
+
+
)
{
assert_nc
(
iSegid
!
=
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
iSeg
]
.
iSegid
)
;
}
}
assert_nc
(
iSegid
>
0
&
&
iSegid
<
=
FTS5_MAX_SEGMENT
)
;
{
sqlite3_stmt
*
pIdxSelect
=
fts5IdxSelectStmt
(
p
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
u8
aBlob
[
2
]
=
{
0xff
0xff
}
;
sqlite3_bind_int
(
pIdxSelect
1
iSegid
)
;
sqlite3_bind_blob
(
pIdxSelect
2
aBlob
2
SQLITE_STATIC
)
;
assert_nc
(
sqlite3_step
(
pIdxSelect
)
!
=
SQLITE_ROW
)
;
p
-
>
rc
=
sqlite3_reset
(
pIdxSelect
)
;
sqlite3_bind_null
(
pIdxSelect
2
)
;
}
}
#
endif
}
}
return
iSegid
;
}
static
void
fts5IndexDiscardData
(
Fts5Index
*
p
)
{
assert
(
p
-
>
pHash
|
|
p
-
>
nPendingData
=
=
0
)
;
if
(
p
-
>
pHash
)
{
sqlite3Fts5HashClear
(
p
-
>
pHash
)
;
p
-
>
nPendingData
=
0
;
p
-
>
nPendingRow
=
0
;
p
-
>
flushRc
=
SQLITE_OK
;
}
p
-
>
nContentlessDelete
=
0
;
}
static
int
fts5PrefixCompress
(
int
nOld
const
u8
*
pOld
const
u8
*
pNew
)
{
int
i
;
for
(
i
=
0
;
i
<
nOld
;
i
+
+
)
{
if
(
pOld
[
i
]
!
=
pNew
[
i
]
)
break
;
}
return
i
;
}
static
void
fts5WriteDlidxClear
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
int
bFlush
)
{
int
i
;
assert
(
bFlush
=
=
0
|
|
(
pWriter
-
>
nDlidx
>
0
&
&
pWriter
-
>
aDlidx
[
0
]
.
buf
.
n
>
0
)
)
;
for
(
i
=
0
;
i
<
pWriter
-
>
nDlidx
;
i
+
+
)
{
Fts5DlidxWriter
*
pDlidx
=
&
pWriter
-
>
aDlidx
[
i
]
;
if
(
pDlidx
-
>
buf
.
n
=
=
0
)
break
;
if
(
bFlush
)
{
assert
(
pDlidx
-
>
pgno
!
=
0
)
;
fts5DataWrite
(
p
FTS5_DLIDX_ROWID
(
pWriter
-
>
iSegid
i
pDlidx
-
>
pgno
)
pDlidx
-
>
buf
.
p
pDlidx
-
>
buf
.
n
)
;
}
sqlite3Fts5BufferZero
(
&
pDlidx
-
>
buf
)
;
pDlidx
-
>
bPrevValid
=
0
;
}
}
static
int
fts5WriteDlidxGrow
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
int
nLvl
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
nLvl
>
=
pWriter
-
>
nDlidx
)
{
Fts5DlidxWriter
*
aDlidx
=
(
Fts5DlidxWriter
*
)
sqlite3_realloc64
(
pWriter
-
>
aDlidx
sizeof
(
Fts5DlidxWriter
)
*
nLvl
)
;
if
(
aDlidx
=
=
0
)
{
p
-
>
rc
=
SQLITE_NOMEM
;
}
else
{
size_t
nByte
=
sizeof
(
Fts5DlidxWriter
)
*
(
nLvl
-
pWriter
-
>
nDlidx
)
;
memset
(
&
aDlidx
[
pWriter
-
>
nDlidx
]
0
nByte
)
;
pWriter
-
>
aDlidx
=
aDlidx
;
pWriter
-
>
nDlidx
=
nLvl
;
}
}
return
p
-
>
rc
;
}
static
int
fts5WriteFlushDlidx
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
)
{
int
bFlag
=
0
;
if
(
pWriter
-
>
aDlidx
[
0
]
.
buf
.
n
>
0
&
&
pWriter
-
>
nEmpty
>
=
FTS5_MIN_DLIDX_SIZE
)
{
bFlag
=
1
;
}
fts5WriteDlidxClear
(
p
pWriter
bFlag
)
;
pWriter
-
>
nEmpty
=
0
;
return
bFlag
;
}
static
void
fts5WriteFlushBtree
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
)
{
int
bFlag
;
assert
(
pWriter
-
>
iBtPage
|
|
pWriter
-
>
nEmpty
=
=
0
)
;
if
(
pWriter
-
>
iBtPage
=
=
0
)
return
;
bFlag
=
fts5WriteFlushDlidx
(
p
pWriter
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
const
char
*
z
=
(
pWriter
-
>
btterm
.
n
>
0
?
(
const
char
*
)
pWriter
-
>
btterm
.
p
:
"
"
)
;
sqlite3_bind_blob
(
p
-
>
pIdxWriter
2
z
pWriter
-
>
btterm
.
n
SQLITE_STATIC
)
;
sqlite3_bind_int64
(
p
-
>
pIdxWriter
3
bFlag
+
(
(
i64
)
pWriter
-
>
iBtPage
<
<
1
)
)
;
sqlite3_step
(
p
-
>
pIdxWriter
)
;
p
-
>
rc
=
sqlite3_reset
(
p
-
>
pIdxWriter
)
;
sqlite3_bind_null
(
p
-
>
pIdxWriter
2
)
;
}
pWriter
-
>
iBtPage
=
0
;
}
static
void
fts5WriteBtreeTerm
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
int
nTerm
const
u8
*
pTerm
)
{
fts5WriteFlushBtree
(
p
pWriter
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
fts5BufferSet
(
&
p
-
>
rc
&
pWriter
-
>
btterm
nTerm
pTerm
)
;
pWriter
-
>
iBtPage
=
pWriter
-
>
writer
.
pgno
;
}
}
static
void
fts5WriteBtreeNoTerm
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
)
{
if
(
pWriter
-
>
bFirstRowidInPage
&
&
pWriter
-
>
aDlidx
[
0
]
.
buf
.
n
>
0
)
{
Fts5DlidxWriter
*
pDlidx
=
&
pWriter
-
>
aDlidx
[
0
]
;
assert
(
pDlidx
-
>
bPrevValid
)
;
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
-
>
buf
0
)
;
}
pWriter
-
>
nEmpty
+
+
;
}
static
i64
fts5DlidxExtractFirstRowid
(
Fts5Buffer
*
pBuf
)
{
i64
iRowid
;
int
iOff
;
iOff
=
1
+
fts5GetVarint
(
&
pBuf
-
>
p
[
1
]
(
u64
*
)
&
iRowid
)
;
fts5GetVarint
(
&
pBuf
-
>
p
[
iOff
]
(
u64
*
)
&
iRowid
)
;
return
iRowid
;
}
static
void
fts5WriteDlidxAppend
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
i64
iRowid
)
{
int
i
;
int
bDone
=
0
;
for
(
i
=
0
;
p
-
>
rc
=
=
SQLITE_OK
&
&
bDone
=
=
0
;
i
+
+
)
{
i64
iVal
;
Fts5DlidxWriter
*
pDlidx
=
&
pWriter
-
>
aDlidx
[
i
]
;
if
(
pDlidx
-
>
buf
.
n
>
=
p
-
>
pConfig
-
>
pgsz
)
{
pDlidx
-
>
buf
.
p
[
0
]
=
0x01
;
fts5DataWrite
(
p
FTS5_DLIDX_ROWID
(
pWriter
-
>
iSegid
i
pDlidx
-
>
pgno
)
pDlidx
-
>
buf
.
p
pDlidx
-
>
buf
.
n
)
;
fts5WriteDlidxGrow
(
p
pWriter
i
+
2
)
;
pDlidx
=
&
pWriter
-
>
aDlidx
[
i
]
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pDlidx
[
1
]
.
buf
.
n
=
=
0
)
{
i64
iFirst
=
fts5DlidxExtractFirstRowid
(
&
pDlidx
-
>
buf
)
;
pDlidx
[
1
]
.
pgno
=
pDlidx
-
>
pgno
;
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
[
1
]
.
buf
0
)
;
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
[
1
]
.
buf
pDlidx
-
>
pgno
)
;
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
[
1
]
.
buf
iFirst
)
;
pDlidx
[
1
]
.
bPrevValid
=
1
;
pDlidx
[
1
]
.
iPrev
=
iFirst
;
}
sqlite3Fts5BufferZero
(
&
pDlidx
-
>
buf
)
;
pDlidx
-
>
bPrevValid
=
0
;
pDlidx
-
>
pgno
+
+
;
}
else
{
bDone
=
1
;
}
if
(
pDlidx
-
>
bPrevValid
)
{
iVal
=
(
u64
)
iRowid
-
(
u64
)
pDlidx
-
>
iPrev
;
}
else
{
i64
iPgno
=
(
i
=
=
0
?
pWriter
-
>
writer
.
pgno
:
pDlidx
[
-
1
]
.
pgno
)
;
assert
(
pDlidx
-
>
buf
.
n
=
=
0
)
;
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
-
>
buf
!
bDone
)
;
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
-
>
buf
iPgno
)
;
iVal
=
iRowid
;
}
sqlite3Fts5BufferAppendVarint
(
&
p
-
>
rc
&
pDlidx
-
>
buf
iVal
)
;
pDlidx
-
>
bPrevValid
=
1
;
pDlidx
-
>
iPrev
=
iRowid
;
}
}
static
void
fts5WriteFlushLeaf
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
)
{
static
const
u8
zero
[
]
=
{
0x00
0x00
0x00
0x00
}
;
Fts5PageWriter
*
pPage
=
&
pWriter
-
>
writer
;
i64
iRowid
;
assert
(
(
pPage
-
>
pgidx
.
n
=
=
0
)
=
=
(
pWriter
-
>
bFirstTermInPage
)
)
;
assert
(
0
=
=
fts5GetU16
(
&
pPage
-
>
buf
.
p
[
2
]
)
)
;
fts5PutU16
(
&
pPage
-
>
buf
.
p
[
2
]
(
u16
)
pPage
-
>
buf
.
n
)
;
if
(
pWriter
-
>
bFirstTermInPage
)
{
assert
(
pPage
-
>
pgidx
.
n
=
=
0
)
;
fts5WriteBtreeNoTerm
(
p
pWriter
)
;
}
else
{
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pPage
-
>
buf
pPage
-
>
pgidx
.
n
pPage
-
>
pgidx
.
p
)
;
}
iRowid
=
FTS5_SEGMENT_ROWID
(
pWriter
-
>
iSegid
pPage
-
>
pgno
)
;
fts5DataWrite
(
p
iRowid
pPage
-
>
buf
.
p
pPage
-
>
buf
.
n
)
;
fts5BufferZero
(
&
pPage
-
>
buf
)
;
fts5BufferZero
(
&
pPage
-
>
pgidx
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pPage
-
>
buf
4
zero
)
;
pPage
-
>
iPrevPgidx
=
0
;
pPage
-
>
pgno
+
+
;
pWriter
-
>
nLeafWritten
+
+
;
pWriter
-
>
bFirstTermInPage
=
1
;
pWriter
-
>
bFirstRowidInPage
=
1
;
}
static
void
fts5WriteAppendTerm
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
int
nTerm
const
u8
*
pTerm
)
{
int
nPrefix
;
Fts5PageWriter
*
pPage
=
&
pWriter
-
>
writer
;
Fts5Buffer
*
pPgidx
=
&
pWriter
-
>
writer
.
pgidx
;
int
nMin
=
MIN
(
pPage
-
>
term
.
n
nTerm
)
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
assert
(
pPage
-
>
buf
.
n
>
=
4
)
;
assert
(
pPage
-
>
buf
.
n
>
4
|
|
pWriter
-
>
bFirstTermInPage
)
;
if
(
(
pPage
-
>
buf
.
n
+
pPgidx
-
>
n
+
nTerm
+
2
)
>
=
p
-
>
pConfig
-
>
pgsz
)
{
if
(
pPage
-
>
buf
.
n
>
4
)
{
fts5WriteFlushLeaf
(
p
pWriter
)
;
if
(
p
-
>
rc
!
=
SQLITE_OK
)
return
;
}
fts5BufferGrow
(
&
p
-
>
rc
&
pPage
-
>
buf
nTerm
+
FTS5_DATA_PADDING
)
;
}
pPgidx
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
pPgidx
-
>
p
[
pPgidx
-
>
n
]
pPage
-
>
buf
.
n
-
pPage
-
>
iPrevPgidx
)
;
pPage
-
>
iPrevPgidx
=
pPage
-
>
buf
.
n
;
#
if
0
fts5PutU16
(
&
pPgidx
-
>
p
[
pPgidx
-
>
n
]
pPage
-
>
buf
.
n
)
;
pPgidx
-
>
n
+
=
2
;
#
endif
if
(
pWriter
-
>
bFirstTermInPage
)
{
nPrefix
=
0
;
if
(
pPage
-
>
pgno
!
=
1
)
{
int
n
=
nTerm
;
if
(
pPage
-
>
term
.
n
)
{
n
=
1
+
fts5PrefixCompress
(
nMin
pPage
-
>
term
.
p
pTerm
)
;
}
fts5WriteBtreeTerm
(
p
pWriter
n
pTerm
)
;
if
(
p
-
>
rc
!
=
SQLITE_OK
)
return
;
pPage
=
&
pWriter
-
>
writer
;
}
}
else
{
nPrefix
=
fts5PrefixCompress
(
nMin
pPage
-
>
term
.
p
pTerm
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
pPage
-
>
buf
nPrefix
)
;
}
fts5BufferAppendVarint
(
&
p
-
>
rc
&
pPage
-
>
buf
nTerm
-
nPrefix
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pPage
-
>
buf
nTerm
-
nPrefix
&
pTerm
[
nPrefix
]
)
;
fts5BufferSet
(
&
p
-
>
rc
&
pPage
-
>
term
nTerm
pTerm
)
;
pWriter
-
>
bFirstTermInPage
=
0
;
pWriter
-
>
bFirstRowidInPage
=
0
;
pWriter
-
>
bFirstRowidInDoclist
=
1
;
assert
(
p
-
>
rc
|
|
(
pWriter
-
>
nDlidx
>
0
&
&
pWriter
-
>
aDlidx
[
0
]
.
buf
.
n
=
=
0
)
)
;
pWriter
-
>
aDlidx
[
0
]
.
pgno
=
pPage
-
>
pgno
;
}
static
void
fts5WriteAppendRowid
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
i64
iRowid
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
Fts5PageWriter
*
pPage
=
&
pWriter
-
>
writer
;
if
(
(
pPage
-
>
buf
.
n
+
pPage
-
>
pgidx
.
n
)
>
=
p
-
>
pConfig
-
>
pgsz
)
{
fts5WriteFlushLeaf
(
p
pWriter
)
;
}
if
(
pWriter
-
>
bFirstRowidInPage
)
{
fts5PutU16
(
pPage
-
>
buf
.
p
(
u16
)
pPage
-
>
buf
.
n
)
;
fts5WriteDlidxAppend
(
p
pWriter
iRowid
)
;
}
if
(
pWriter
-
>
bFirstRowidInDoclist
|
|
pWriter
-
>
bFirstRowidInPage
)
{
fts5BufferAppendVarint
(
&
p
-
>
rc
&
pPage
-
>
buf
iRowid
)
;
}
else
{
assert_nc
(
p
-
>
rc
|
|
iRowid
>
pWriter
-
>
iPrevRowid
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
pPage
-
>
buf
(
u64
)
iRowid
-
(
u64
)
pWriter
-
>
iPrevRowid
)
;
}
pWriter
-
>
iPrevRowid
=
iRowid
;
pWriter
-
>
bFirstRowidInDoclist
=
0
;
pWriter
-
>
bFirstRowidInPage
=
0
;
}
}
static
void
fts5WriteAppendPoslistData
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
const
u8
*
aData
int
nData
)
{
Fts5PageWriter
*
pPage
=
&
pWriter
-
>
writer
;
const
u8
*
a
=
aData
;
int
n
=
nData
;
assert
(
p
-
>
pConfig
-
>
pgsz
>
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
(
pPage
-
>
buf
.
n
+
pPage
-
>
pgidx
.
n
+
n
)
>
=
p
-
>
pConfig
-
>
pgsz
)
{
int
nReq
=
p
-
>
pConfig
-
>
pgsz
-
pPage
-
>
buf
.
n
-
pPage
-
>
pgidx
.
n
;
int
nCopy
=
0
;
while
(
nCopy
<
nReq
)
{
i64
dummy
;
nCopy
+
=
fts5GetVarint
(
&
a
[
nCopy
]
(
u64
*
)
&
dummy
)
;
}
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pPage
-
>
buf
nCopy
a
)
;
a
+
=
nCopy
;
n
-
=
nCopy
;
fts5WriteFlushLeaf
(
p
pWriter
)
;
}
if
(
n
>
0
)
{
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pPage
-
>
buf
n
a
)
;
}
}
static
void
fts5WriteFinish
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
int
*
pnLeaf
)
{
int
i
;
Fts5PageWriter
*
pLeaf
=
&
pWriter
-
>
writer
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
assert
(
pLeaf
-
>
pgno
>
=
1
)
;
if
(
pLeaf
-
>
buf
.
n
>
4
)
{
fts5WriteFlushLeaf
(
p
pWriter
)
;
}
*
pnLeaf
=
pLeaf
-
>
pgno
-
1
;
if
(
pLeaf
-
>
pgno
>
1
)
{
fts5WriteFlushBtree
(
p
pWriter
)
;
}
}
fts5BufferFree
(
&
pLeaf
-
>
term
)
;
fts5BufferFree
(
&
pLeaf
-
>
buf
)
;
fts5BufferFree
(
&
pLeaf
-
>
pgidx
)
;
fts5BufferFree
(
&
pWriter
-
>
btterm
)
;
for
(
i
=
0
;
i
<
pWriter
-
>
nDlidx
;
i
+
+
)
{
sqlite3Fts5BufferFree
(
&
pWriter
-
>
aDlidx
[
i
]
.
buf
)
;
}
sqlite3_free
(
pWriter
-
>
aDlidx
)
;
}
static
void
fts5WriteInit
(
Fts5Index
*
p
Fts5SegWriter
*
pWriter
int
iSegid
)
{
const
int
nBuffer
=
p
-
>
pConfig
-
>
pgsz
+
FTS5_DATA_PADDING
;
memset
(
pWriter
0
sizeof
(
Fts5SegWriter
)
)
;
pWriter
-
>
iSegid
=
iSegid
;
fts5WriteDlidxGrow
(
p
pWriter
1
)
;
pWriter
-
>
writer
.
pgno
=
1
;
pWriter
-
>
bFirstTermInPage
=
1
;
pWriter
-
>
iBtPage
=
1
;
assert
(
pWriter
-
>
writer
.
buf
.
n
=
=
0
)
;
assert
(
pWriter
-
>
writer
.
pgidx
.
n
=
=
0
)
;
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
pWriter
-
>
writer
.
pgidx
nBuffer
)
;
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
pWriter
-
>
writer
.
buf
nBuffer
)
;
if
(
p
-
>
pIdxWriter
=
=
0
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
fts5IndexPrepareStmt
(
p
&
p
-
>
pIdxWriter
sqlite3_mprintf
(
"
INSERT
INTO
'
%
q
'
.
'
%
q_idx
'
(
segid
term
pgno
)
VALUES
(
?
?
?
)
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
memset
(
pWriter
-
>
writer
.
buf
.
p
0
4
)
;
pWriter
-
>
writer
.
buf
.
n
=
4
;
sqlite3_bind_int
(
p
-
>
pIdxWriter
1
pWriter
-
>
iSegid
)
;
}
}
static
void
fts5TrimSegments
(
Fts5Index
*
p
Fts5Iter
*
pIter
)
{
int
i
;
Fts5Buffer
buf
;
memset
(
&
buf
0
sizeof
(
Fts5Buffer
)
)
;
for
(
i
=
0
;
i
<
pIter
-
>
nSeg
&
&
p
-
>
rc
=
=
SQLITE_OK
;
i
+
+
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
i
]
;
if
(
pSeg
-
>
pSeg
=
=
0
)
{
}
else
if
(
pSeg
-
>
pLeaf
=
=
0
)
{
pSeg
-
>
pSeg
-
>
pgnoLast
=
0
;
pSeg
-
>
pSeg
-
>
pgnoFirst
=
0
;
}
else
{
int
iOff
=
pSeg
-
>
iTermLeafOffset
;
i64
iLeafRowid
;
Fts5Data
*
pData
;
int
iId
=
pSeg
-
>
pSeg
-
>
iSegid
;
u8
aHdr
[
4
]
=
{
0x00
0x00
0x00
0x00
}
;
iLeafRowid
=
FTS5_SEGMENT_ROWID
(
iId
pSeg
-
>
iTermLeafPgno
)
;
pData
=
fts5LeafRead
(
p
iLeafRowid
)
;
if
(
pData
)
{
if
(
iOff
>
pData
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
fts5BufferZero
(
&
buf
)
;
fts5BufferGrow
(
&
p
-
>
rc
&
buf
pData
-
>
nn
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
buf
sizeof
(
aHdr
)
aHdr
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
pSeg
-
>
term
.
n
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
buf
pSeg
-
>
term
.
n
pSeg
-
>
term
.
p
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
buf
pData
-
>
szLeaf
-
iOff
&
pData
-
>
p
[
iOff
]
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
fts5PutU16
(
&
buf
.
p
[
2
]
(
u16
)
buf
.
n
)
;
}
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
4
)
;
if
(
pSeg
-
>
iLeafPgno
=
=
pSeg
-
>
iTermLeafPgno
&
&
pSeg
-
>
iEndofDoclist
<
pData
-
>
szLeaf
&
&
pSeg
-
>
iPgidxOff
<
=
pData
-
>
nn
)
{
int
nDiff
=
pData
-
>
szLeaf
-
pSeg
-
>
iEndofDoclist
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
buf
buf
.
n
-
1
-
nDiff
-
4
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
buf
pData
-
>
nn
-
pSeg
-
>
iPgidxOff
&
pData
-
>
p
[
pSeg
-
>
iPgidxOff
]
)
;
}
pSeg
-
>
pSeg
-
>
pgnoFirst
=
pSeg
-
>
iTermLeafPgno
;
fts5DataDelete
(
p
FTS5_SEGMENT_ROWID
(
iId
1
)
iLeafRowid
)
;
fts5DataWrite
(
p
iLeafRowid
buf
.
p
buf
.
n
)
;
}
fts5DataRelease
(
pData
)
;
}
}
}
fts5BufferFree
(
&
buf
)
;
}
static
void
fts5MergeChunkCallback
(
Fts5Index
*
p
void
*
pCtx
const
u8
*
pChunk
int
nChunk
)
{
Fts5SegWriter
*
pWriter
=
(
Fts5SegWriter
*
)
pCtx
;
fts5WriteAppendPoslistData
(
p
pWriter
pChunk
nChunk
)
;
}
static
void
fts5IndexMergeLevel
(
Fts5Index
*
p
Fts5Structure
*
*
ppStruct
int
iLvl
int
*
pnRem
)
{
Fts5Structure
*
pStruct
=
*
ppStruct
;
Fts5StructureLevel
*
pLvl
=
&
pStruct
-
>
aLevel
[
iLvl
]
;
Fts5StructureLevel
*
pLvlOut
;
Fts5Iter
*
pIter
=
0
;
int
nRem
=
pnRem
?
*
pnRem
:
0
;
int
nInput
;
Fts5SegWriter
writer
;
Fts5StructureSegment
*
pSeg
;
Fts5Buffer
term
;
int
bOldest
;
int
eDetail
=
p
-
>
pConfig
-
>
eDetail
;
const
int
flags
=
FTS5INDEX_QUERY_NOOUTPUT
;
int
bTermWritten
=
0
;
assert
(
iLvl
<
pStruct
-
>
nLevel
)
;
assert
(
pLvl
-
>
nMerge
<
=
pLvl
-
>
nSeg
)
;
memset
(
&
writer
0
sizeof
(
Fts5SegWriter
)
)
;
memset
(
&
term
0
sizeof
(
Fts5Buffer
)
)
;
if
(
pLvl
-
>
nMerge
)
{
pLvlOut
=
&
pStruct
-
>
aLevel
[
iLvl
+
1
]
;
assert
(
pLvlOut
-
>
nSeg
>
0
)
;
nInput
=
pLvl
-
>
nMerge
;
pSeg
=
&
pLvlOut
-
>
aSeg
[
pLvlOut
-
>
nSeg
-
1
]
;
fts5WriteInit
(
p
&
writer
pSeg
-
>
iSegid
)
;
writer
.
writer
.
pgno
=
pSeg
-
>
pgnoLast
+
1
;
writer
.
iBtPage
=
0
;
}
else
{
int
iSegid
=
fts5AllocateSegid
(
p
pStruct
)
;
if
(
iLvl
=
=
pStruct
-
>
nLevel
-
1
)
{
fts5StructureAddLevel
(
&
p
-
>
rc
ppStruct
)
;
pStruct
=
*
ppStruct
;
}
fts5StructureExtendLevel
(
&
p
-
>
rc
pStruct
iLvl
+
1
1
0
)
;
if
(
p
-
>
rc
)
return
;
pLvl
=
&
pStruct
-
>
aLevel
[
iLvl
]
;
pLvlOut
=
&
pStruct
-
>
aLevel
[
iLvl
+
1
]
;
fts5WriteInit
(
p
&
writer
iSegid
)
;
pSeg
=
&
pLvlOut
-
>
aSeg
[
pLvlOut
-
>
nSeg
]
;
pLvlOut
-
>
nSeg
+
+
;
pSeg
-
>
pgnoFirst
=
1
;
pSeg
-
>
iSegid
=
iSegid
;
pStruct
-
>
nSegment
+
+
;
nInput
=
pLvl
-
>
nSeg
;
if
(
pStruct
-
>
nOriginCntr
>
0
)
{
pSeg
-
>
iOrigin1
=
pLvl
-
>
aSeg
[
0
]
.
iOrigin1
;
pSeg
-
>
iOrigin2
=
pLvl
-
>
aSeg
[
pLvl
-
>
nSeg
-
1
]
.
iOrigin2
;
}
}
bOldest
=
(
pLvlOut
-
>
nSeg
=
=
1
&
&
pStruct
-
>
nLevel
=
=
iLvl
+
2
)
;
assert
(
iLvl
>
=
0
)
;
for
(
fts5MultiIterNew
(
p
pStruct
flags
0
0
0
iLvl
nInput
&
pIter
)
;
fts5MultiIterEof
(
p
pIter
)
=
=
0
;
fts5MultiIterNext
(
p
pIter
0
0
)
)
{
Fts5SegIter
*
pSegIter
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
int
nPos
;
int
nTerm
;
const
u8
*
pTerm
;
pTerm
=
fts5MultiIterTerm
(
pIter
&
nTerm
)
;
if
(
nTerm
!
=
term
.
n
|
|
fts5Memcmp
(
pTerm
term
.
p
nTerm
)
)
{
if
(
pnRem
&
&
writer
.
nLeafWritten
>
nRem
)
{
break
;
}
fts5BufferSet
(
&
p
-
>
rc
&
term
nTerm
pTerm
)
;
bTermWritten
=
0
;
}
if
(
pSegIter
-
>
nPos
=
=
0
&
&
(
bOldest
|
|
pSegIter
-
>
bDel
=
=
0
)
)
continue
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
bTermWritten
=
=
0
)
{
fts5WriteAppendTerm
(
p
&
writer
nTerm
pTerm
)
;
bTermWritten
=
1
;
}
fts5WriteAppendRowid
(
p
&
writer
fts5MultiIterRowid
(
pIter
)
)
;
if
(
eDetail
=
=
FTS5_DETAIL_NONE
)
{
if
(
pSegIter
-
>
bDel
)
{
fts5BufferAppendVarint
(
&
p
-
>
rc
&
writer
.
writer
.
buf
0
)
;
if
(
pSegIter
-
>
nPos
>
0
)
{
fts5BufferAppendVarint
(
&
p
-
>
rc
&
writer
.
writer
.
buf
0
)
;
}
}
}
else
{
nPos
=
pSegIter
-
>
nPos
*
2
+
pSegIter
-
>
bDel
;
fts5BufferAppendVarint
(
&
p
-
>
rc
&
writer
.
writer
.
buf
nPos
)
;
fts5ChunkIterate
(
p
pSegIter
(
void
*
)
&
writer
fts5MergeChunkCallback
)
;
}
}
fts5WriteFinish
(
p
&
writer
&
pSeg
-
>
pgnoLast
)
;
assert
(
pIter
!
=
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
if
(
fts5MultiIterEof
(
p
pIter
)
)
{
int
i
;
assert
(
pSeg
-
>
nEntry
=
=
0
)
;
for
(
i
=
0
;
i
<
nInput
;
i
+
+
)
{
Fts5StructureSegment
*
pOld
=
&
pLvl
-
>
aSeg
[
i
]
;
pSeg
-
>
nEntry
+
=
(
pOld
-
>
nEntry
-
pOld
-
>
nEntryTombstone
)
;
fts5DataRemoveSegment
(
p
pOld
)
;
}
if
(
pLvl
-
>
nSeg
!
=
nInput
)
{
int
nMove
=
(
pLvl
-
>
nSeg
-
nInput
)
*
sizeof
(
Fts5StructureSegment
)
;
memmove
(
pLvl
-
>
aSeg
&
pLvl
-
>
aSeg
[
nInput
]
nMove
)
;
}
pStruct
-
>
nSegment
-
=
nInput
;
pLvl
-
>
nSeg
-
=
nInput
;
pLvl
-
>
nMerge
=
0
;
if
(
pSeg
-
>
pgnoLast
=
=
0
)
{
pLvlOut
-
>
nSeg
-
-
;
pStruct
-
>
nSegment
-
-
;
}
}
else
{
assert
(
pSeg
-
>
pgnoLast
>
0
)
;
fts5TrimSegments
(
p
pIter
)
;
pLvl
-
>
nMerge
=
nInput
;
}
fts5MultiIterFree
(
pIter
)
;
fts5BufferFree
(
&
term
)
;
if
(
pnRem
)
*
pnRem
-
=
writer
.
nLeafWritten
;
}
static
int
fts5IndexFindDeleteMerge
(
Fts5Index
*
p
Fts5Structure
*
pStruct
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
iRet
=
-
1
;
if
(
pConfig
-
>
bContentlessDelete
&
&
pConfig
-
>
nDeleteMerge
>
0
)
{
int
ii
;
int
nBest
=
0
;
for
(
ii
=
0
;
ii
<
pStruct
-
>
nLevel
;
ii
+
+
)
{
Fts5StructureLevel
*
pLvl
=
&
pStruct
-
>
aLevel
[
ii
]
;
i64
nEntry
=
0
;
i64
nTomb
=
0
;
int
iSeg
;
for
(
iSeg
=
0
;
iSeg
<
pLvl
-
>
nSeg
;
iSeg
+
+
)
{
nEntry
+
=
pLvl
-
>
aSeg
[
iSeg
]
.
nEntry
;
nTomb
+
=
pLvl
-
>
aSeg
[
iSeg
]
.
nEntryTombstone
;
}
assert_nc
(
nEntry
>
0
|
|
pLvl
-
>
nSeg
=
=
0
)
;
if
(
nEntry
>
0
)
{
int
nPercent
=
(
nTomb
*
100
)
/
nEntry
;
if
(
nPercent
>
=
pConfig
-
>
nDeleteMerge
&
&
nPercent
>
nBest
)
{
iRet
=
ii
;
nBest
=
nPercent
;
}
}
if
(
pLvl
-
>
nMerge
)
break
;
}
}
return
iRet
;
}
static
int
fts5IndexMerge
(
Fts5Index
*
p
Fts5Structure
*
*
ppStruct
int
nPg
int
nMin
)
{
int
nRem
=
nPg
;
int
bRet
=
0
;
Fts5Structure
*
pStruct
=
*
ppStruct
;
while
(
nRem
>
0
&
&
p
-
>
rc
=
=
SQLITE_OK
)
{
int
iLvl
;
int
iBestLvl
=
0
;
int
nBest
=
0
;
assert
(
pStruct
-
>
nLevel
>
0
)
;
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
Fts5StructureLevel
*
pLvl
=
&
pStruct
-
>
aLevel
[
iLvl
]
;
if
(
pLvl
-
>
nMerge
)
{
if
(
pLvl
-
>
nMerge
>
nBest
)
{
iBestLvl
=
iLvl
;
nBest
=
nMin
;
}
break
;
}
if
(
pLvl
-
>
nSeg
>
nBest
)
{
nBest
=
pLvl
-
>
nSeg
;
iBestLvl
=
iLvl
;
}
}
if
(
nBest
<
nMin
)
{
iBestLvl
=
fts5IndexFindDeleteMerge
(
p
pStruct
)
;
}
if
(
iBestLvl
<
0
)
break
;
bRet
=
1
;
fts5IndexMergeLevel
(
p
&
pStruct
iBestLvl
&
nRem
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pStruct
-
>
aLevel
[
iBestLvl
]
.
nMerge
=
=
0
)
{
fts5StructurePromote
(
p
iBestLvl
+
1
pStruct
)
;
}
if
(
nMin
=
=
1
)
nMin
=
2
;
}
*
ppStruct
=
pStruct
;
return
bRet
;
}
static
void
fts5IndexAutomerge
(
Fts5Index
*
p
Fts5Structure
*
*
ppStruct
int
nLeaf
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
p
-
>
pConfig
-
>
nAutomerge
>
0
&
&
ALWAYS
(
(
*
ppStruct
)
!
=
0
)
)
{
Fts5Structure
*
pStruct
=
*
ppStruct
;
u64
nWrite
;
int
nWork
;
int
nRem
;
nWrite
=
pStruct
-
>
nWriteCounter
;
nWork
=
(
int
)
(
(
(
nWrite
+
nLeaf
)
/
p
-
>
nWorkUnit
)
-
(
nWrite
/
p
-
>
nWorkUnit
)
)
;
pStruct
-
>
nWriteCounter
+
=
nLeaf
;
nRem
=
(
int
)
(
p
-
>
nWorkUnit
*
nWork
*
pStruct
-
>
nLevel
)
;
fts5IndexMerge
(
p
ppStruct
nRem
p
-
>
pConfig
-
>
nAutomerge
)
;
}
}
static
void
fts5IndexCrisismerge
(
Fts5Index
*
p
Fts5Structure
*
*
ppStruct
)
{
const
int
nCrisis
=
p
-
>
pConfig
-
>
nCrisisMerge
;
Fts5Structure
*
pStruct
=
*
ppStruct
;
if
(
pStruct
&
&
pStruct
-
>
nLevel
>
0
)
{
int
iLvl
=
0
;
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
>
=
nCrisis
)
{
fts5IndexMergeLevel
(
p
&
pStruct
iLvl
0
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
pStruct
-
>
nLevel
>
(
iLvl
+
1
)
)
;
fts5StructurePromote
(
p
iLvl
+
1
pStruct
)
;
iLvl
+
+
;
}
*
ppStruct
=
pStruct
;
}
}
static
int
fts5IndexReturn
(
Fts5Index
*
p
)
{
int
rc
=
p
-
>
rc
;
p
-
>
rc
=
SQLITE_OK
;
return
rc
;
}
static
void
sqlite3Fts5IndexCloseReader
(
Fts5Index
*
p
)
{
fts5IndexCloseReader
(
p
)
;
fts5IndexReturn
(
p
)
;
}
typedef
struct
Fts5FlushCtx
Fts5FlushCtx
;
struct
Fts5FlushCtx
{
Fts5Index
*
pIdx
;
Fts5SegWriter
writer
;
}
;
static
int
fts5PoslistPrefix
(
const
u8
*
aBuf
int
nMax
)
{
int
ret
;
u32
dummy
;
ret
=
fts5GetVarint32
(
aBuf
dummy
)
;
if
(
ret
<
nMax
)
{
while
(
1
)
{
int
i
=
fts5GetVarint32
(
&
aBuf
[
ret
]
dummy
)
;
if
(
(
ret
+
i
)
>
nMax
)
break
;
ret
+
=
i
;
}
}
return
ret
;
}
static
void
fts5SecureDeleteIdxEntry
(
Fts5Index
*
p
int
iSegid
int
iPgno
)
{
if
(
iPgno
!
=
1
)
{
assert
(
p
-
>
pConfig
-
>
iVersion
=
=
FTS5_CURRENT_VERSION_SECUREDELETE
)
;
if
(
p
-
>
pDeleteFromIdx
=
=
0
)
{
fts5IndexPrepareStmt
(
p
&
p
-
>
pDeleteFromIdx
sqlite3_mprintf
(
"
DELETE
FROM
'
%
q
'
.
'
%
q_idx
'
WHERE
(
segid
(
pgno
/
2
)
)
=
(
?
1
?
2
)
"
p
-
>
pConfig
-
>
zDb
p
-
>
pConfig
-
>
zName
)
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int
(
p
-
>
pDeleteFromIdx
1
iSegid
)
;
sqlite3_bind_int
(
p
-
>
pDeleteFromIdx
2
iPgno
)
;
sqlite3_step
(
p
-
>
pDeleteFromIdx
)
;
p
-
>
rc
=
sqlite3_reset
(
p
-
>
pDeleteFromIdx
)
;
}
}
}
static
void
fts5SecureDeleteOverflow
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
int
iPgno
int
*
pbLastInDoclist
)
{
const
int
bDetailNone
=
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
;
int
pgno
;
Fts5Data
*
pLeaf
=
0
;
assert
(
iPgno
!
=
1
)
;
*
pbLastInDoclist
=
1
;
for
(
pgno
=
iPgno
;
p
-
>
rc
=
=
SQLITE_OK
&
&
pgno
<
=
pSeg
-
>
pgnoLast
;
pgno
+
+
)
{
i64
iRowid
=
FTS5_SEGMENT_ROWID
(
pSeg
-
>
iSegid
pgno
)
;
int
iNext
=
0
;
u8
*
aPg
=
0
;
pLeaf
=
fts5DataRead
(
p
iRowid
)
;
if
(
pLeaf
=
=
0
)
break
;
aPg
=
pLeaf
-
>
p
;
iNext
=
fts5GetU16
(
&
aPg
[
0
]
)
;
if
(
iNext
!
=
0
)
{
*
pbLastInDoclist
=
0
;
}
if
(
iNext
=
=
0
&
&
pLeaf
-
>
szLeaf
!
=
pLeaf
-
>
nn
)
{
fts5GetVarint32
(
&
aPg
[
pLeaf
-
>
szLeaf
]
iNext
)
;
}
if
(
iNext
=
=
0
)
{
const
u8
aEmpty
[
]
=
{
0x00
0x00
0x00
0x04
}
;
assert_nc
(
bDetailNone
=
=
0
|
|
pLeaf
-
>
nn
=
=
4
)
;
if
(
bDetailNone
=
=
0
)
fts5DataWrite
(
p
iRowid
aEmpty
sizeof
(
aEmpty
)
)
;
fts5DataRelease
(
pLeaf
)
;
pLeaf
=
0
;
}
else
if
(
bDetailNone
)
{
break
;
}
else
if
(
iNext
>
=
pLeaf
-
>
szLeaf
|
|
pLeaf
-
>
nn
<
pLeaf
-
>
szLeaf
|
|
iNext
<
4
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
break
;
}
else
{
int
nShift
=
iNext
-
4
;
int
nPg
;
int
nIdx
=
0
;
u8
*
aIdx
=
0
;
if
(
pLeaf
-
>
nn
>
pLeaf
-
>
szLeaf
)
{
int
iFirst
=
0
;
int
i1
=
pLeaf
-
>
szLeaf
;
int
i2
=
0
;
i1
+
=
fts5GetVarint32
(
&
aPg
[
i1
]
iFirst
)
;
if
(
iFirst
<
iNext
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
break
;
}
aIdx
=
sqlite3Fts5MallocZero
(
&
p
-
>
rc
(
pLeaf
-
>
nn
-
pLeaf
-
>
szLeaf
)
+
2
)
;
if
(
aIdx
=
=
0
)
break
;
i2
=
sqlite3Fts5PutVarint
(
aIdx
iFirst
-
nShift
)
;
if
(
i1
<
pLeaf
-
>
nn
)
{
memcpy
(
&
aIdx
[
i2
]
&
aPg
[
i1
]
pLeaf
-
>
nn
-
i1
)
;
i2
+
=
(
pLeaf
-
>
nn
-
i1
)
;
}
nIdx
=
i2
;
}
nPg
=
pLeaf
-
>
szLeaf
-
nShift
;
memmove
(
&
aPg
[
4
]
&
aPg
[
4
+
nShift
]
nPg
-
4
)
;
fts5PutU16
(
&
aPg
[
2
]
nPg
)
;
if
(
fts5GetU16
(
&
aPg
[
0
]
)
)
fts5PutU16
(
&
aPg
[
0
]
4
)
;
if
(
nIdx
>
0
)
{
memcpy
(
&
aPg
[
nPg
]
aIdx
nIdx
)
;
nPg
+
=
nIdx
;
}
sqlite3_free
(
aIdx
)
;
assert
(
nPg
>
4
|
|
fts5GetU16
(
aPg
)
=
=
0
)
;
fts5DataWrite
(
p
iRowid
aPg
nPg
)
;
break
;
}
}
fts5DataRelease
(
pLeaf
)
;
}
static
void
fts5DoSecureDelete
(
Fts5Index
*
p
Fts5SegIter
*
pSeg
)
{
const
int
bDetailNone
=
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
;
int
iSegid
=
pSeg
-
>
pSeg
-
>
iSegid
;
u8
*
aPg
=
pSeg
-
>
pLeaf
-
>
p
;
int
nPg
=
pSeg
-
>
pLeaf
-
>
nn
;
int
iPgIdx
=
pSeg
-
>
pLeaf
-
>
szLeaf
;
u64
iDelta
=
0
;
int
iNextOff
=
0
;
int
iOff
=
0
;
int
nIdx
=
0
;
u8
*
aIdx
=
0
;
int
bLastInDoclist
=
0
;
int
iIdx
=
0
;
int
iStart
=
0
;
int
iDelKeyOff
=
0
;
nIdx
=
nPg
-
iPgIdx
;
aIdx
=
sqlite3Fts5MallocZero
(
&
p
-
>
rc
nIdx
+
16
)
;
if
(
p
-
>
rc
)
return
;
memcpy
(
aIdx
&
aPg
[
iPgIdx
]
nIdx
)
;
{
int
iSOP
;
if
(
pSeg
-
>
iLeafPgno
=
=
pSeg
-
>
iTermLeafPgno
)
{
iStart
=
pSeg
-
>
iTermLeafOffset
;
}
else
{
iStart
=
fts5GetU16
(
&
aPg
[
0
]
)
;
}
iSOP
=
iStart
+
fts5GetVarint
(
&
aPg
[
iStart
]
&
iDelta
)
;
assert_nc
(
iSOP
<
=
pSeg
-
>
iLeafOffset
)
;
if
(
bDetailNone
)
{
while
(
iSOP
<
pSeg
-
>
iLeafOffset
)
{
if
(
aPg
[
iSOP
]
=
=
0x00
)
iSOP
+
+
;
if
(
aPg
[
iSOP
]
=
=
0x00
)
iSOP
+
+
;
iStart
=
iSOP
;
iSOP
=
iStart
+
fts5GetVarint
(
&
aPg
[
iStart
]
&
iDelta
)
;
}
iNextOff
=
iSOP
;
if
(
iNextOff
<
pSeg
-
>
iEndofDoclist
&
&
aPg
[
iNextOff
]
=
=
0x00
)
iNextOff
+
+
;
if
(
iNextOff
<
pSeg
-
>
iEndofDoclist
&
&
aPg
[
iNextOff
]
=
=
0x00
)
iNextOff
+
+
;
}
else
{
int
nPos
=
0
;
iSOP
+
=
fts5GetVarint32
(
&
aPg
[
iSOP
]
nPos
)
;
while
(
iSOP
<
pSeg
-
>
iLeafOffset
)
{
iStart
=
iSOP
+
(
nPos
/
2
)
;
iSOP
=
iStart
+
fts5GetVarint
(
&
aPg
[
iStart
]
&
iDelta
)
;
iSOP
+
=
fts5GetVarint32
(
&
aPg
[
iSOP
]
nPos
)
;
}
assert_nc
(
iSOP
=
=
pSeg
-
>
iLeafOffset
)
;
iNextOff
=
pSeg
-
>
iLeafOffset
+
pSeg
-
>
nPos
;
}
}
iOff
=
iStart
;
if
(
iNextOff
>
=
iPgIdx
)
{
int
pgno
=
pSeg
-
>
iLeafPgno
+
1
;
fts5SecureDeleteOverflow
(
p
pSeg
-
>
pSeg
pgno
&
bLastInDoclist
)
;
iNextOff
=
iPgIdx
;
}
if
(
pSeg
-
>
bDel
=
=
0
)
{
if
(
iNextOff
!
=
iPgIdx
)
{
int
iKeyOff
=
0
;
for
(
iIdx
=
0
;
iIdx
<
nIdx
;
)
{
u32
iVal
=
0
;
iIdx
+
=
fts5GetVarint32
(
&
aIdx
[
iIdx
]
iVal
)
;
iKeyOff
+
=
iVal
;
if
(
iKeyOff
=
=
iNextOff
)
{
bLastInDoclist
=
1
;
}
}
}
if
(
fts5GetU16
(
&
aPg
[
0
]
)
=
=
iStart
&
&
(
bLastInDoclist
|
|
iNextOff
=
=
iPgIdx
)
)
{
fts5PutU16
(
&
aPg
[
0
]
0
)
;
}
}
if
(
pSeg
-
>
bDel
)
{
iOff
+
=
sqlite3Fts5PutVarint
(
&
aPg
[
iOff
]
iDelta
)
;
aPg
[
iOff
+
+
]
=
0x01
;
}
else
if
(
bLastInDoclist
=
=
0
)
{
if
(
iNextOff
!
=
iPgIdx
)
{
u64
iNextDelta
=
0
;
iNextOff
+
=
fts5GetVarint
(
&
aPg
[
iNextOff
]
&
iNextDelta
)
;
iOff
+
=
sqlite3Fts5PutVarint
(
&
aPg
[
iOff
]
iDelta
+
iNextDelta
)
;
}
}
else
if
(
pSeg
-
>
iLeafPgno
=
=
pSeg
-
>
iTermLeafPgno
&
&
iStart
=
=
pSeg
-
>
iTermLeafOffset
)
{
int
iKey
=
0
;
int
iKeyOff
=
0
;
for
(
iIdx
=
0
;
iIdx
<
nIdx
;
iKey
+
+
)
{
u32
iVal
=
0
;
iIdx
+
=
fts5GetVarint32
(
&
aIdx
[
iIdx
]
iVal
)
;
if
(
(
iKeyOff
+
iVal
)
>
(
u32
)
iStart
)
break
;
iKeyOff
+
=
iVal
;
}
assert_nc
(
iKey
>
=
1
)
;
iDelKeyOff
=
iOff
=
iKeyOff
;
if
(
iNextOff
!
=
iPgIdx
)
{
int
nPrefix
=
0
;
int
nSuffix
=
0
;
int
nPrefix2
=
0
;
int
nSuffix2
=
0
;
iDelKeyOff
=
iNextOff
;
iNextOff
+
=
fts5GetVarint32
(
&
aPg
[
iNextOff
]
nPrefix2
)
;
iNextOff
+
=
fts5GetVarint32
(
&
aPg
[
iNextOff
]
nSuffix2
)
;
if
(
iKey
!
=
1
)
{
iKeyOff
+
=
fts5GetVarint32
(
&
aPg
[
iKeyOff
]
nPrefix
)
;
}
iKeyOff
+
=
fts5GetVarint32
(
&
aPg
[
iKeyOff
]
nSuffix
)
;
nPrefix
=
MIN
(
nPrefix
nPrefix2
)
;
nSuffix
=
(
nPrefix2
+
nSuffix2
)
-
nPrefix
;
if
(
(
iKeyOff
+
nSuffix
)
>
iPgIdx
|
|
(
iNextOff
+
nSuffix2
)
>
iPgIdx
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
if
(
iKey
!
=
1
)
{
iOff
+
=
sqlite3Fts5PutVarint
(
&
aPg
[
iOff
]
nPrefix
)
;
}
iOff
+
=
sqlite3Fts5PutVarint
(
&
aPg
[
iOff
]
nSuffix
)
;
if
(
nPrefix2
>
pSeg
-
>
term
.
n
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
if
(
nPrefix2
>
nPrefix
)
{
memcpy
(
&
aPg
[
iOff
]
&
pSeg
-
>
term
.
p
[
nPrefix
]
nPrefix2
-
nPrefix
)
;
iOff
+
=
(
nPrefix2
-
nPrefix
)
;
}
memmove
(
&
aPg
[
iOff
]
&
aPg
[
iNextOff
]
nSuffix2
)
;
iOff
+
=
nSuffix2
;
iNextOff
+
=
nSuffix2
;
}
}
}
else
if
(
iStart
=
=
4
)
{
int
iPgno
;
assert_nc
(
pSeg
-
>
iLeafPgno
>
pSeg
-
>
iTermLeafPgno
)
;
for
(
iPgno
=
pSeg
-
>
iLeafPgno
-
1
;
iPgno
>
pSeg
-
>
iTermLeafPgno
;
iPgno
-
-
)
{
Fts5Data
*
pPg
=
fts5DataRead
(
p
FTS5_SEGMENT_ROWID
(
iSegid
iPgno
)
)
;
int
bEmpty
=
(
pPg
&
&
pPg
-
>
nn
=
=
4
)
;
fts5DataRelease
(
pPg
)
;
if
(
bEmpty
=
=
0
)
break
;
}
if
(
iPgno
=
=
pSeg
-
>
iTermLeafPgno
)
{
i64
iId
=
FTS5_SEGMENT_ROWID
(
iSegid
pSeg
-
>
iTermLeafPgno
)
;
Fts5Data
*
pTerm
=
fts5DataRead
(
p
iId
)
;
if
(
pTerm
&
&
pTerm
-
>
szLeaf
=
=
pSeg
-
>
iTermLeafOffset
)
{
u8
*
aTermIdx
=
&
pTerm
-
>
p
[
pTerm
-
>
szLeaf
]
;
int
nTermIdx
=
pTerm
-
>
nn
-
pTerm
-
>
szLeaf
;
int
iTermIdx
=
0
;
int
iTermOff
=
0
;
while
(
1
)
{
u32
iVal
=
0
;
int
nByte
=
fts5GetVarint32
(
&
aTermIdx
[
iTermIdx
]
iVal
)
;
iTermOff
+
=
iVal
;
if
(
(
iTermIdx
+
nByte
)
>
=
nTermIdx
)
break
;
iTermIdx
+
=
nByte
;
}
nTermIdx
=
iTermIdx
;
memmove
(
&
pTerm
-
>
p
[
iTermOff
]
&
pTerm
-
>
p
[
pTerm
-
>
szLeaf
]
nTermIdx
)
;
fts5PutU16
(
&
pTerm
-
>
p
[
2
]
iTermOff
)
;
fts5DataWrite
(
p
iId
pTerm
-
>
p
iTermOff
+
nTermIdx
)
;
if
(
nTermIdx
=
=
0
)
{
fts5SecureDeleteIdxEntry
(
p
iSegid
pSeg
-
>
iTermLeafPgno
)
;
}
}
fts5DataRelease
(
pTerm
)
;
}
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
const
int
nMove
=
nPg
-
iNextOff
;
int
nShift
=
iNextOff
-
iOff
;
int
iPrevKeyOut
=
0
;
int
iKeyIn
=
0
;
memmove
(
&
aPg
[
iOff
]
&
aPg
[
iNextOff
]
nMove
)
;
iPgIdx
-
=
nShift
;
nPg
=
iPgIdx
;
fts5PutU16
(
&
aPg
[
2
]
iPgIdx
)
;
for
(
iIdx
=
0
;
iIdx
<
nIdx
;
)
{
u32
iVal
=
0
;
iIdx
+
=
fts5GetVarint32
(
&
aIdx
[
iIdx
]
iVal
)
;
iKeyIn
+
=
iVal
;
if
(
iKeyIn
!
=
iDelKeyOff
)
{
int
iKeyOut
=
(
iKeyIn
-
(
iKeyIn
>
iOff
?
nShift
:
0
)
)
;
nPg
+
=
sqlite3Fts5PutVarint
(
&
aPg
[
nPg
]
iKeyOut
-
iPrevKeyOut
)
;
iPrevKeyOut
=
iKeyOut
;
}
}
if
(
iPgIdx
=
=
nPg
&
&
nIdx
>
0
&
&
pSeg
-
>
iLeafPgno
!
=
1
)
{
fts5SecureDeleteIdxEntry
(
p
iSegid
pSeg
-
>
iLeafPgno
)
;
}
assert_nc
(
nPg
>
4
|
|
fts5GetU16
(
aPg
)
=
=
0
)
;
fts5DataWrite
(
p
FTS5_SEGMENT_ROWID
(
iSegid
pSeg
-
>
iLeafPgno
)
aPg
nPg
)
;
}
sqlite3_free
(
aIdx
)
;
}
static
int
fts5FlushSecureDelete
(
Fts5Index
*
p
Fts5Structure
*
pStruct
const
char
*
zTerm
int
nTerm
i64
iRowid
)
{
const
int
f
=
FTS5INDEX_QUERY_SKIPHASH
;
Fts5Iter
*
pIter
=
0
;
if
(
p
-
>
pConfig
-
>
iVersion
!
=
FTS5_CURRENT_VERSION_SECUREDELETE
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
sqlite3_stmt
*
pStmt
=
0
;
fts5IndexPrepareStmt
(
p
&
pStmt
sqlite3_mprintf
(
"
REPLACE
INTO
%
Q
.
'
%
q_config
'
VALUES
(
'
version
'
%
d
)
"
pConfig
-
>
zDb
pConfig
-
>
zName
FTS5_CURRENT_VERSION_SECUREDELETE
)
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
rc
;
sqlite3_step
(
pStmt
)
;
rc
=
sqlite3_finalize
(
pStmt
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
p
-
>
rc
=
rc
;
pConfig
-
>
iCookie
+
+
;
pConfig
-
>
iVersion
=
FTS5_CURRENT_VERSION_SECUREDELETE
;
}
}
fts5MultiIterNew
(
p
pStruct
f
0
(
const
u8
*
)
zTerm
nTerm
-
1
0
&
pIter
)
;
if
(
fts5MultiIterEof
(
p
pIter
)
=
=
0
)
{
i64
iThis
=
fts5MultiIterRowid
(
pIter
)
;
if
(
iThis
<
iRowid
)
{
fts5MultiIterNextFrom
(
p
pIter
iRowid
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
fts5MultiIterEof
(
p
pIter
)
=
=
0
&
&
iRowid
=
=
fts5MultiIterRowid
(
pIter
)
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
fts5DoSecureDelete
(
p
pSeg
)
;
}
}
fts5MultiIterFree
(
pIter
)
;
return
p
-
>
rc
;
}
static
void
fts5FlushOneHash
(
Fts5Index
*
p
)
{
Fts5Hash
*
pHash
=
p
-
>
pHash
;
Fts5Structure
*
pStruct
;
int
iSegid
;
int
pgnoLast
=
0
;
pStruct
=
fts5StructureRead
(
p
)
;
fts5StructureInvalidate
(
p
)
;
if
(
sqlite3Fts5HashIsEmpty
(
pHash
)
=
=
0
)
{
iSegid
=
fts5AllocateSegid
(
p
pStruct
)
;
if
(
iSegid
)
{
const
int
pgsz
=
p
-
>
pConfig
-
>
pgsz
;
int
eDetail
=
p
-
>
pConfig
-
>
eDetail
;
int
bSecureDelete
=
p
-
>
pConfig
-
>
bSecureDelete
;
Fts5StructureSegment
*
pSeg
;
Fts5Buffer
*
pBuf
;
Fts5Buffer
*
pPgidx
;
Fts5SegWriter
writer
;
fts5WriteInit
(
p
&
writer
iSegid
)
;
pBuf
=
&
writer
.
writer
.
buf
;
pPgidx
=
&
writer
.
writer
.
pgidx
;
assert
(
p
-
>
rc
|
|
pBuf
-
>
nSpace
>
=
(
pgsz
+
FTS5_DATA_PADDING
)
)
;
assert
(
p
-
>
rc
|
|
pPgidx
-
>
nSpace
>
=
(
pgsz
+
FTS5_DATA_PADDING
)
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
p
-
>
rc
=
sqlite3Fts5HashScanInit
(
pHash
0
0
)
;
}
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
0
=
=
sqlite3Fts5HashScanEof
(
pHash
)
)
{
const
char
*
zTerm
;
int
nTerm
;
const
u8
*
pDoclist
;
int
nDoclist
;
sqlite3Fts5HashScanEntry
(
pHash
&
zTerm
&
nTerm
&
pDoclist
&
nDoclist
)
;
if
(
bSecureDelete
=
=
0
)
{
fts5WriteAppendTerm
(
p
&
writer
nTerm
(
const
u8
*
)
zTerm
)
;
if
(
p
-
>
rc
!
=
SQLITE_OK
)
break
;
assert
(
writer
.
bFirstRowidInPage
=
=
0
)
;
}
if
(
!
bSecureDelete
&
&
pgsz
>
=
(
pBuf
-
>
n
+
pPgidx
-
>
n
+
nDoclist
+
1
)
)
{
fts5BufferSafeAppendBlob
(
pBuf
pDoclist
nDoclist
)
;
}
else
{
int
bTermWritten
=
!
bSecureDelete
;
i64
iRowid
=
0
;
i64
iPrev
=
0
;
int
iOff
=
0
;
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
iOff
<
nDoclist
)
{
u64
iDelta
=
0
;
iOff
+
=
fts5GetVarint
(
&
pDoclist
[
iOff
]
&
iDelta
)
;
iRowid
+
=
iDelta
;
if
(
bSecureDelete
)
{
if
(
eDetail
=
=
FTS5_DETAIL_NONE
)
{
if
(
iOff
<
nDoclist
&
&
pDoclist
[
iOff
]
=
=
0x00
&
&
!
fts5FlushSecureDelete
(
p
pStruct
zTerm
nTerm
iRowid
)
)
{
iOff
+
+
;
if
(
iOff
<
nDoclist
&
&
pDoclist
[
iOff
]
=
=
0x00
)
{
iOff
+
+
;
nDoclist
=
0
;
}
else
{
continue
;
}
}
}
else
if
(
(
pDoclist
[
iOff
]
&
0x01
)
&
&
!
fts5FlushSecureDelete
(
p
pStruct
zTerm
nTerm
iRowid
)
)
{
if
(
p
-
>
rc
!
=
SQLITE_OK
|
|
pDoclist
[
iOff
]
=
=
0x01
)
{
iOff
+
+
;
continue
;
}
}
}
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
bTermWritten
=
=
0
)
{
fts5WriteAppendTerm
(
p
&
writer
nTerm
(
const
u8
*
)
zTerm
)
;
bTermWritten
=
1
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
writer
.
bFirstRowidInPage
=
=
0
)
;
}
if
(
writer
.
bFirstRowidInPage
)
{
fts5PutU16
(
&
pBuf
-
>
p
[
0
]
(
u16
)
pBuf
-
>
n
)
;
pBuf
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
iRowid
)
;
writer
.
bFirstRowidInPage
=
0
;
fts5WriteDlidxAppend
(
p
&
writer
iRowid
)
;
}
else
{
u64
iRowidDelta
=
(
u64
)
iRowid
-
(
u64
)
iPrev
;
pBuf
-
>
n
+
=
sqlite3Fts5PutVarint
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
iRowidDelta
)
;
}
if
(
p
-
>
rc
!
=
SQLITE_OK
)
break
;
assert
(
pBuf
-
>
n
<
=
pBuf
-
>
nSpace
)
;
iPrev
=
iRowid
;
if
(
eDetail
=
=
FTS5_DETAIL_NONE
)
{
if
(
iOff
<
nDoclist
&
&
pDoclist
[
iOff
]
=
=
0
)
{
pBuf
-
>
p
[
pBuf
-
>
n
+
+
]
=
0
;
iOff
+
+
;
if
(
iOff
<
nDoclist
&
&
pDoclist
[
iOff
]
=
=
0
)
{
pBuf
-
>
p
[
pBuf
-
>
n
+
+
]
=
0
;
iOff
+
+
;
}
}
if
(
(
pBuf
-
>
n
+
pPgidx
-
>
n
)
>
=
pgsz
)
{
fts5WriteFlushLeaf
(
p
&
writer
)
;
}
}
else
{
int
bDel
=
0
;
int
nPos
=
0
;
int
nCopy
=
fts5GetPoslistSize
(
&
pDoclist
[
iOff
]
&
nPos
&
bDel
)
;
if
(
bDel
&
&
bSecureDelete
)
{
fts5BufferAppendVarint
(
&
p
-
>
rc
pBuf
nPos
*
2
)
;
iOff
+
=
nCopy
;
nCopy
=
nPos
;
}
else
{
nCopy
+
=
nPos
;
}
if
(
(
pBuf
-
>
n
+
pPgidx
-
>
n
+
nCopy
)
<
=
pgsz
)
{
fts5BufferSafeAppendBlob
(
pBuf
&
pDoclist
[
iOff
]
nCopy
)
;
}
else
{
const
u8
*
pPoslist
=
&
pDoclist
[
iOff
]
;
int
iPos
=
0
;
while
(
p
-
>
rc
=
=
SQLITE_OK
)
{
int
nSpace
=
pgsz
-
pBuf
-
>
n
-
pPgidx
-
>
n
;
int
n
=
0
;
if
(
(
nCopy
-
iPos
)
<
=
nSpace
)
{
n
=
nCopy
-
iPos
;
}
else
{
n
=
fts5PoslistPrefix
(
&
pPoslist
[
iPos
]
nSpace
)
;
}
assert
(
n
>
0
)
;
fts5BufferSafeAppendBlob
(
pBuf
&
pPoslist
[
iPos
]
n
)
;
iPos
+
=
n
;
if
(
(
pBuf
-
>
n
+
pPgidx
-
>
n
)
>
=
pgsz
)
{
fts5WriteFlushLeaf
(
p
&
writer
)
;
}
if
(
iPos
>
=
nCopy
)
break
;
}
}
iOff
+
=
nCopy
;
}
}
}
assert
(
pBuf
-
>
n
<
=
pBuf
-
>
nSpace
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
sqlite3Fts5HashScanNext
(
pHash
)
;
}
fts5WriteFinish
(
p
&
writer
&
pgnoLast
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
bSecureDelete
|
|
pgnoLast
>
0
)
;
if
(
pgnoLast
>
0
)
{
if
(
pStruct
-
>
nLevel
=
=
0
)
{
fts5StructureAddLevel
(
&
p
-
>
rc
&
pStruct
)
;
}
fts5StructureExtendLevel
(
&
p
-
>
rc
pStruct
0
1
0
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
pSeg
=
&
pStruct
-
>
aLevel
[
0
]
.
aSeg
[
pStruct
-
>
aLevel
[
0
]
.
nSeg
+
+
]
;
pSeg
-
>
iSegid
=
iSegid
;
pSeg
-
>
pgnoFirst
=
1
;
pSeg
-
>
pgnoLast
=
pgnoLast
;
if
(
pStruct
-
>
nOriginCntr
>
0
)
{
pSeg
-
>
iOrigin1
=
pStruct
-
>
nOriginCntr
;
pSeg
-
>
iOrigin2
=
pStruct
-
>
nOriginCntr
;
pSeg
-
>
nEntry
=
p
-
>
nPendingRow
;
pStruct
-
>
nOriginCntr
+
+
;
}
pStruct
-
>
nSegment
+
+
;
}
fts5StructurePromote
(
p
0
pStruct
)
;
}
}
}
fts5IndexAutomerge
(
p
&
pStruct
pgnoLast
+
p
-
>
nContentlessDelete
)
;
fts5IndexCrisismerge
(
p
&
pStruct
)
;
fts5StructureWrite
(
p
pStruct
)
;
fts5StructureRelease
(
pStruct
)
;
}
static
void
fts5IndexFlush
(
Fts5Index
*
p
)
{
if
(
p
-
>
flushRc
)
{
p
-
>
rc
=
p
-
>
flushRc
;
return
;
}
if
(
p
-
>
nPendingData
|
|
p
-
>
nContentlessDelete
)
{
assert
(
p
-
>
pHash
)
;
fts5FlushOneHash
(
p
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5HashClear
(
p
-
>
pHash
)
;
p
-
>
nPendingData
=
0
;
p
-
>
nPendingRow
=
0
;
p
-
>
nContentlessDelete
=
0
;
}
else
if
(
p
-
>
nPendingData
|
|
p
-
>
nContentlessDelete
)
{
p
-
>
flushRc
=
p
-
>
rc
;
}
}
}
static
Fts5Structure
*
fts5IndexOptimizeStruct
(
Fts5Index
*
p
Fts5Structure
*
pStruct
)
{
Fts5Structure
*
pNew
=
0
;
sqlite3_int64
nByte
=
sizeof
(
Fts5Structure
)
;
int
nSeg
=
pStruct
-
>
nSegment
;
int
i
;
if
(
nSeg
=
=
0
)
return
0
;
for
(
i
=
0
;
i
<
pStruct
-
>
nLevel
;
i
+
+
)
{
int
nThis
=
pStruct
-
>
aLevel
[
i
]
.
nSeg
;
int
nMerge
=
pStruct
-
>
aLevel
[
i
]
.
nMerge
;
if
(
nThis
>
0
&
&
(
nThis
=
=
nSeg
|
|
(
nThis
=
=
nSeg
-
1
&
&
nMerge
=
=
nThis
)
)
)
{
if
(
nSeg
=
=
1
&
&
nThis
=
=
1
&
&
pStruct
-
>
aLevel
[
i
]
.
aSeg
[
0
]
.
nPgTombstone
=
=
0
)
{
return
0
;
}
fts5StructureRef
(
pStruct
)
;
return
pStruct
;
}
assert
(
pStruct
-
>
aLevel
[
i
]
.
nMerge
<
=
nThis
)
;
}
nByte
+
=
(
pStruct
-
>
nLevel
+
1
)
*
sizeof
(
Fts5StructureLevel
)
;
pNew
=
(
Fts5Structure
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
nByte
)
;
if
(
pNew
)
{
Fts5StructureLevel
*
pLvl
;
nByte
=
nSeg
*
sizeof
(
Fts5StructureSegment
)
;
pNew
-
>
nLevel
=
MIN
(
pStruct
-
>
nLevel
+
1
FTS5_MAX_LEVEL
)
;
pNew
-
>
nRef
=
1
;
pNew
-
>
nWriteCounter
=
pStruct
-
>
nWriteCounter
;
pNew
-
>
nOriginCntr
=
pStruct
-
>
nOriginCntr
;
pLvl
=
&
pNew
-
>
aLevel
[
pNew
-
>
nLevel
-
1
]
;
pLvl
-
>
aSeg
=
(
Fts5StructureSegment
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
nByte
)
;
if
(
pLvl
-
>
aSeg
)
{
int
iLvl
iSeg
;
int
iSegOut
=
0
;
for
(
iLvl
=
pStruct
-
>
nLevel
-
1
;
iLvl
>
=
0
;
iLvl
-
-
)
{
for
(
iSeg
=
0
;
iSeg
<
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
;
iSeg
+
+
)
{
pLvl
-
>
aSeg
[
iSegOut
]
=
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
iSeg
]
;
iSegOut
+
+
;
}
}
pNew
-
>
nSegment
=
pLvl
-
>
nSeg
=
nSeg
;
}
else
{
sqlite3_free
(
pNew
)
;
pNew
=
0
;
}
}
return
pNew
;
}
static
int
sqlite3Fts5IndexOptimize
(
Fts5Index
*
p
)
{
Fts5Structure
*
pStruct
;
Fts5Structure
*
pNew
=
0
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
fts5IndexFlush
(
p
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
p
-
>
nContentlessDelete
=
=
0
)
;
pStruct
=
fts5StructureRead
(
p
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
pStruct
!
=
0
)
;
fts5StructureInvalidate
(
p
)
;
if
(
pStruct
)
{
pNew
=
fts5IndexOptimizeStruct
(
p
pStruct
)
;
}
fts5StructureRelease
(
pStruct
)
;
assert
(
pNew
=
=
0
|
|
pNew
-
>
nSegment
>
0
)
;
if
(
pNew
)
{
int
iLvl
;
for
(
iLvl
=
0
;
pNew
-
>
aLevel
[
iLvl
]
.
nSeg
=
=
0
;
iLvl
+
+
)
{
}
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pNew
-
>
aLevel
[
iLvl
]
.
nSeg
>
0
)
{
int
nRem
=
FTS5_OPT_WORK_UNIT
;
fts5IndexMergeLevel
(
p
&
pNew
iLvl
&
nRem
)
;
}
fts5StructureWrite
(
p
pNew
)
;
fts5StructureRelease
(
pNew
)
;
}
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexMerge
(
Fts5Index
*
p
int
nMerge
)
{
Fts5Structure
*
pStruct
=
0
;
fts5IndexFlush
(
p
)
;
pStruct
=
fts5StructureRead
(
p
)
;
if
(
pStruct
)
{
int
nMin
=
p
-
>
pConfig
-
>
nUsermerge
;
fts5StructureInvalidate
(
p
)
;
if
(
nMerge
<
0
)
{
Fts5Structure
*
pNew
=
fts5IndexOptimizeStruct
(
p
pStruct
)
;
fts5StructureRelease
(
pStruct
)
;
pStruct
=
pNew
;
nMin
=
1
;
nMerge
=
nMerge
*
-
1
;
}
if
(
pStruct
&
&
pStruct
-
>
nLevel
)
{
if
(
fts5IndexMerge
(
p
&
pStruct
nMerge
nMin
)
)
{
fts5StructureWrite
(
p
pStruct
)
;
}
}
fts5StructureRelease
(
pStruct
)
;
}
return
fts5IndexReturn
(
p
)
;
}
static
void
fts5AppendRowid
(
Fts5Index
*
p
u64
iDelta
Fts5Iter
*
pUnused
Fts5Buffer
*
pBuf
)
{
UNUSED_PARAM
(
pUnused
)
;
fts5BufferAppendVarint
(
&
p
-
>
rc
pBuf
iDelta
)
;
}
static
void
fts5AppendPoslist
(
Fts5Index
*
p
u64
iDelta
Fts5Iter
*
pMulti
Fts5Buffer
*
pBuf
)
{
int
nData
=
pMulti
-
>
base
.
nData
;
int
nByte
=
nData
+
9
+
9
+
FTS5_DATA_ZERO_PADDING
;
assert
(
nData
>
0
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
0
=
=
fts5BufferGrow
(
&
p
-
>
rc
pBuf
nByte
)
)
{
fts5BufferSafeAppendVarint
(
pBuf
iDelta
)
;
fts5BufferSafeAppendVarint
(
pBuf
nData
*
2
)
;
fts5BufferSafeAppendBlob
(
pBuf
pMulti
-
>
base
.
pData
nData
)
;
memset
(
&
pBuf
-
>
p
[
pBuf
-
>
n
]
0
FTS5_DATA_ZERO_PADDING
)
;
}
}
static
void
fts5DoclistIterNext
(
Fts5DoclistIter
*
pIter
)
{
u8
*
p
=
pIter
-
>
aPoslist
+
pIter
-
>
nSize
+
pIter
-
>
nPoslist
;
assert
(
pIter
-
>
aPoslist
|
|
(
p
=
=
0
&
&
pIter
-
>
aPoslist
=
=
0
)
)
;
if
(
p
>
=
pIter
-
>
aEof
)
{
pIter
-
>
aPoslist
=
0
;
}
else
{
i64
iDelta
;
p
+
=
fts5GetVarint
(
p
(
u64
*
)
&
iDelta
)
;
pIter
-
>
iRowid
+
=
iDelta
;
if
(
p
[
0
]
&
0x80
)
{
int
nPos
;
pIter
-
>
nSize
=
fts5GetVarint32
(
p
nPos
)
;
pIter
-
>
nPoslist
=
(
nPos
>
>
1
)
;
}
else
{
pIter
-
>
nPoslist
=
(
(
int
)
(
p
[
0
]
)
)
>
>
1
;
pIter
-
>
nSize
=
1
;
}
pIter
-
>
aPoslist
=
p
;
if
(
&
pIter
-
>
aPoslist
[
pIter
-
>
nPoslist
]
>
pIter
-
>
aEof
)
{
pIter
-
>
aPoslist
=
0
;
}
}
}
static
void
fts5DoclistIterInit
(
Fts5Buffer
*
pBuf
Fts5DoclistIter
*
pIter
)
{
memset
(
pIter
0
sizeof
(
*
pIter
)
)
;
if
(
pBuf
-
>
n
>
0
)
{
pIter
-
>
aPoslist
=
pBuf
-
>
p
;
pIter
-
>
aEof
=
&
pBuf
-
>
p
[
pBuf
-
>
n
]
;
fts5DoclistIterNext
(
pIter
)
;
}
}
#
if
0
static
void
fts5MergeAppendDocid
(
Fts5Buffer
*
pBuf
i64
*
piLastRowid
i64
iRowid
)
{
assert
(
pBuf
-
>
n
!
=
0
|
|
(
*
piLastRowid
)
=
=
0
)
;
fts5BufferSafeAppendVarint
(
pBuf
iRowid
-
*
piLastRowid
)
;
*
piLastRowid
=
iRowid
;
}
#
endif
#
define
fts5MergeAppendDocid
(
pBuf
iLastRowid
iRowid
)
{
\
assert
(
(
pBuf
)
-
>
n
!
=
0
|
|
(
iLastRowid
)
=
=
0
)
;
\
fts5BufferSafeAppendVarint
(
(
pBuf
)
(
u64
)
(
iRowid
)
-
(
u64
)
(
iLastRowid
)
)
;
\
(
iLastRowid
)
=
(
iRowid
)
;
\
}
static
void
fts5BufferSwap
(
Fts5Buffer
*
p1
Fts5Buffer
*
p2
)
{
Fts5Buffer
tmp
=
*
p1
;
*
p1
=
*
p2
;
*
p2
=
tmp
;
}
static
void
fts5NextRowid
(
Fts5Buffer
*
pBuf
int
*
piOff
i64
*
piRowid
)
{
int
i
=
*
piOff
;
if
(
i
>
=
pBuf
-
>
n
)
{
*
piOff
=
-
1
;
}
else
{
u64
iVal
;
*
piOff
=
i
+
sqlite3Fts5GetVarint
(
&
pBuf
-
>
p
[
i
]
&
iVal
)
;
*
piRowid
+
=
iVal
;
}
}
static
void
fts5MergeRowidLists
(
Fts5Index
*
p
Fts5Buffer
*
p1
int
nBuf
Fts5Buffer
*
aBuf
)
{
int
i1
=
0
;
int
i2
=
0
;
i64
iRowid1
=
0
;
i64
iRowid2
=
0
;
i64
iOut
=
0
;
Fts5Buffer
*
p2
=
&
aBuf
[
0
]
;
Fts5Buffer
out
;
(
void
)
nBuf
;
memset
(
&
out
0
sizeof
(
out
)
)
;
assert
(
nBuf
=
=
1
)
;
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
out
p1
-
>
n
+
p2
-
>
n
)
;
if
(
p
-
>
rc
)
return
;
fts5NextRowid
(
p1
&
i1
&
iRowid1
)
;
fts5NextRowid
(
p2
&
i2
&
iRowid2
)
;
while
(
i1
>
=
0
|
|
i2
>
=
0
)
{
if
(
i1
>
=
0
&
&
(
i2
<
0
|
|
iRowid1
<
iRowid2
)
)
{
assert
(
iOut
=
=
0
|
|
iRowid1
>
iOut
)
;
fts5BufferSafeAppendVarint
(
&
out
iRowid1
-
iOut
)
;
iOut
=
iRowid1
;
fts5NextRowid
(
p1
&
i1
&
iRowid1
)
;
}
else
{
assert
(
iOut
=
=
0
|
|
iRowid2
>
iOut
)
;
fts5BufferSafeAppendVarint
(
&
out
iRowid2
-
iOut
)
;
iOut
=
iRowid2
;
if
(
i1
>
=
0
&
&
iRowid1
=
=
iRowid2
)
{
fts5NextRowid
(
p1
&
i1
&
iRowid1
)
;
}
fts5NextRowid
(
p2
&
i2
&
iRowid2
)
;
}
}
fts5BufferSwap
(
&
out
p1
)
;
fts5BufferFree
(
&
out
)
;
}
typedef
struct
PrefixMerger
PrefixMerger
;
struct
PrefixMerger
{
Fts5DoclistIter
iter
;
i64
iPos
;
int
iOff
;
u8
*
aPos
;
PrefixMerger
*
pNext
;
}
;
static
void
fts5PrefixMergerInsertByRowid
(
PrefixMerger
*
*
ppHead
PrefixMerger
*
p
)
{
if
(
p
-
>
iter
.
aPoslist
)
{
PrefixMerger
*
*
pp
=
ppHead
;
while
(
*
pp
&
&
p
-
>
iter
.
iRowid
>
(
*
pp
)
-
>
iter
.
iRowid
)
{
pp
=
&
(
*
pp
)
-
>
pNext
;
}
p
-
>
pNext
=
*
pp
;
*
pp
=
p
;
}
}
static
void
fts5PrefixMergerInsertByPosition
(
PrefixMerger
*
*
ppHead
PrefixMerger
*
p
)
{
if
(
p
-
>
iPos
>
=
0
)
{
PrefixMerger
*
*
pp
=
ppHead
;
while
(
*
pp
&
&
p
-
>
iPos
>
(
*
pp
)
-
>
iPos
)
{
pp
=
&
(
*
pp
)
-
>
pNext
;
}
p
-
>
pNext
=
*
pp
;
*
pp
=
p
;
}
}
static
void
fts5MergePrefixLists
(
Fts5Index
*
p
Fts5Buffer
*
p1
int
nBuf
Fts5Buffer
*
aBuf
)
{
#
define
fts5PrefixMergerNextPosition
(
p
)
\
sqlite3Fts5PoslistNext64
(
(
p
)
-
>
aPos
(
p
)
-
>
iter
.
nPoslist
&
(
p
)
-
>
iOff
&
(
p
)
-
>
iPos
)
#
define
FTS5_MERGE_NLIST
16
PrefixMerger
aMerger
[
FTS5_MERGE_NLIST
]
;
PrefixMerger
*
pHead
=
0
;
int
i
;
int
nOut
=
0
;
Fts5Buffer
out
=
{
0
0
0
}
;
Fts5Buffer
tmp
=
{
0
0
0
}
;
i64
iLastRowid
=
0
;
assert
(
nBuf
+
1
<
=
(
int
)
(
sizeof
(
aMerger
)
/
sizeof
(
aMerger
[
0
]
)
)
)
;
memset
(
aMerger
0
sizeof
(
PrefixMerger
)
*
(
nBuf
+
1
)
)
;
pHead
=
&
aMerger
[
nBuf
]
;
fts5DoclistIterInit
(
p1
&
pHead
-
>
iter
)
;
for
(
i
=
0
;
i
<
nBuf
;
i
+
+
)
{
fts5DoclistIterInit
(
&
aBuf
[
i
]
&
aMerger
[
i
]
.
iter
)
;
fts5PrefixMergerInsertByRowid
(
&
pHead
&
aMerger
[
i
]
)
;
nOut
+
=
aBuf
[
i
]
.
n
;
}
if
(
nOut
=
=
0
)
return
;
nOut
+
=
p1
-
>
n
+
9
+
10
*
nBuf
;
if
(
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
out
nOut
)
)
return
;
while
(
pHead
)
{
fts5MergeAppendDocid
(
&
out
iLastRowid
pHead
-
>
iter
.
iRowid
)
;
if
(
pHead
-
>
pNext
&
&
iLastRowid
=
=
pHead
-
>
pNext
-
>
iter
.
iRowid
)
{
i64
iPrev
=
0
;
int
nTmp
=
FTS5_DATA_ZERO_PADDING
;
int
nMerge
=
0
;
PrefixMerger
*
pSave
=
pHead
;
PrefixMerger
*
pThis
=
0
;
int
nTail
=
0
;
pHead
=
0
;
while
(
pSave
&
&
pSave
-
>
iter
.
iRowid
=
=
iLastRowid
)
{
PrefixMerger
*
pNext
=
pSave
-
>
pNext
;
pSave
-
>
iOff
=
0
;
pSave
-
>
iPos
=
0
;
pSave
-
>
aPos
=
&
pSave
-
>
iter
.
aPoslist
[
pSave
-
>
iter
.
nSize
]
;
fts5PrefixMergerNextPosition
(
pSave
)
;
nTmp
+
=
pSave
-
>
iter
.
nPoslist
+
10
;
nMerge
+
+
;
fts5PrefixMergerInsertByPosition
(
&
pHead
pSave
)
;
pSave
=
pNext
;
}
if
(
pHead
=
=
0
|
|
pHead
-
>
pNext
=
=
0
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
break
;
}
if
(
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
tmp
nTmp
+
nMerge
*
10
)
)
{
break
;
}
fts5BufferZero
(
&
tmp
)
;
pThis
=
pHead
;
pHead
=
pThis
-
>
pNext
;
sqlite3Fts5PoslistSafeAppend
(
&
tmp
&
iPrev
pThis
-
>
iPos
)
;
fts5PrefixMergerNextPosition
(
pThis
)
;
fts5PrefixMergerInsertByPosition
(
&
pHead
pThis
)
;
while
(
pHead
-
>
pNext
)
{
pThis
=
pHead
;
if
(
pThis
-
>
iPos
!
=
iPrev
)
{
sqlite3Fts5PoslistSafeAppend
(
&
tmp
&
iPrev
pThis
-
>
iPos
)
;
}
fts5PrefixMergerNextPosition
(
pThis
)
;
pHead
=
pThis
-
>
pNext
;
fts5PrefixMergerInsertByPosition
(
&
pHead
pThis
)
;
}
if
(
pHead
-
>
iPos
!
=
iPrev
)
{
sqlite3Fts5PoslistSafeAppend
(
&
tmp
&
iPrev
pHead
-
>
iPos
)
;
}
nTail
=
pHead
-
>
iter
.
nPoslist
-
pHead
-
>
iOff
;
assert_nc
(
tmp
.
n
+
nTail
<
=
nTmp
)
;
assert
(
tmp
.
n
+
nTail
<
=
nTmp
+
nMerge
*
10
)
;
if
(
tmp
.
n
+
nTail
>
nTmp
-
FTS5_DATA_ZERO_PADDING
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
p
-
>
rc
=
FTS5_CORRUPT
;
break
;
}
fts5BufferSafeAppendVarint
(
&
out
(
tmp
.
n
+
nTail
)
*
2
)
;
fts5BufferSafeAppendBlob
(
&
out
tmp
.
p
tmp
.
n
)
;
if
(
nTail
>
0
)
{
fts5BufferSafeAppendBlob
(
&
out
&
pHead
-
>
aPos
[
pHead
-
>
iOff
]
nTail
)
;
}
pHead
=
pSave
;
for
(
i
=
0
;
i
<
nBuf
+
1
;
i
+
+
)
{
PrefixMerger
*
pX
=
&
aMerger
[
i
]
;
if
(
pX
-
>
iter
.
aPoslist
&
&
pX
-
>
iter
.
iRowid
=
=
iLastRowid
)
{
fts5DoclistIterNext
(
&
pX
-
>
iter
)
;
fts5PrefixMergerInsertByRowid
(
&
pHead
pX
)
;
}
}
}
else
{
PrefixMerger
*
pThis
=
pHead
;
Fts5DoclistIter
*
pI
=
&
pThis
-
>
iter
;
fts5BufferSafeAppendBlob
(
&
out
pI
-
>
aPoslist
pI
-
>
nPoslist
+
pI
-
>
nSize
)
;
fts5DoclistIterNext
(
pI
)
;
pHead
=
pThis
-
>
pNext
;
fts5PrefixMergerInsertByRowid
(
&
pHead
pThis
)
;
}
}
fts5BufferFree
(
p1
)
;
fts5BufferFree
(
&
tmp
)
;
memset
(
&
out
.
p
[
out
.
n
]
0
FTS5_DATA_ZERO_PADDING
)
;
*
p1
=
out
;
}
static
int
fts5VisitEntries
(
Fts5Index
*
p
Fts5Colset
*
pColset
u8
*
pToken
int
nToken
int
bPrefix
void
(
*
xVisit
)
(
Fts5Index
*
void
*
pCtx
Fts5Iter
*
pIter
const
u8
*
int
)
void
*
pCtx
)
{
const
int
flags
=
(
bPrefix
?
FTS5INDEX_QUERY_SCAN
:
0
)
|
FTS5INDEX_QUERY_SKIPEMPTY
|
FTS5INDEX_QUERY_NOOUTPUT
;
Fts5Iter
*
p1
=
0
;
int
bNewTerm
=
1
;
Fts5Structure
*
pStruct
=
fts5StructureRead
(
p
)
;
fts5MultiIterNew
(
p
pStruct
flags
pColset
pToken
nToken
-
1
0
&
p1
)
;
fts5IterSetOutputCb
(
&
p
-
>
rc
p1
)
;
for
(
;
fts5MultiIterEof
(
p
p1
)
=
=
0
;
fts5MultiIterNext2
(
p
p1
&
bNewTerm
)
)
{
Fts5SegIter
*
pSeg
=
&
p1
-
>
aSeg
[
p1
-
>
aFirst
[
1
]
.
iFirst
]
;
int
nNew
=
0
;
const
u8
*
pNew
=
0
;
p1
-
>
xSetOutputs
(
p1
pSeg
)
;
if
(
p
-
>
rc
)
break
;
if
(
bNewTerm
)
{
nNew
=
pSeg
-
>
term
.
n
;
pNew
=
pSeg
-
>
term
.
p
;
if
(
nNew
<
nToken
|
|
memcmp
(
pToken
pNew
nToken
)
)
break
;
}
xVisit
(
p
pCtx
p1
pNew
nNew
)
;
}
fts5MultiIterFree
(
p1
)
;
fts5StructureRelease
(
pStruct
)
;
return
p
-
>
rc
;
}
struct
Fts5TokenDataMap
{
i64
iRowid
;
i64
iPos
;
int
iIter
;
int
nByte
;
}
;
struct
Fts5TokenDataIter
{
int
nMapAlloc
;
int
nMap
;
Fts5TokenDataMap
*
aMap
;
Fts5Buffer
terms
;
int
nIter
;
int
nIterAlloc
;
Fts5PoslistReader
*
aPoslistReader
;
int
*
aPoslistToIter
;
Fts5Iter
*
apIter
[
1
]
;
}
;
static
void
fts5TokendataMerge
(
Fts5TokenDataMap
*
a1
int
n1
Fts5TokenDataMap
*
a2
int
n2
Fts5TokenDataMap
*
aOut
)
{
int
i1
=
0
;
int
i2
=
0
;
assert
(
n1
>
=
0
&
&
n2
>
=
0
)
;
while
(
i1
<
n1
|
|
i2
<
n2
)
{
Fts5TokenDataMap
*
pOut
=
&
aOut
[
i1
+
i2
]
;
if
(
i2
>
=
n2
|
|
(
i1
<
n1
&
&
(
a1
[
i1
]
.
iRowid
<
a2
[
i2
]
.
iRowid
|
|
(
a1
[
i1
]
.
iRowid
=
=
a2
[
i2
]
.
iRowid
&
&
a1
[
i1
]
.
iPos
<
=
a2
[
i2
]
.
iPos
)
)
)
)
{
memcpy
(
pOut
&
a1
[
i1
]
sizeof
(
Fts5TokenDataMap
)
)
;
i1
+
+
;
}
else
{
memcpy
(
pOut
&
a2
[
i2
]
sizeof
(
Fts5TokenDataMap
)
)
;
i2
+
+
;
}
}
}
static
void
fts5TokendataIterAppendMap
(
Fts5Index
*
p
Fts5TokenDataIter
*
pT
int
iIter
int
nByte
i64
iRowid
i64
iPos
)
{
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
pT
-
>
nMap
=
=
pT
-
>
nMapAlloc
)
{
int
nNew
=
pT
-
>
nMapAlloc
?
pT
-
>
nMapAlloc
*
2
:
64
;
int
nAlloc
=
nNew
*
sizeof
(
Fts5TokenDataMap
)
;
Fts5TokenDataMap
*
aNew
;
aNew
=
(
Fts5TokenDataMap
*
)
sqlite3_realloc
(
pT
-
>
aMap
nAlloc
)
;
if
(
aNew
=
=
0
)
{
p
-
>
rc
=
SQLITE_NOMEM
;
return
;
}
pT
-
>
aMap
=
aNew
;
pT
-
>
nMapAlloc
=
nNew
;
}
pT
-
>
aMap
[
pT
-
>
nMap
]
.
iRowid
=
iRowid
;
pT
-
>
aMap
[
pT
-
>
nMap
]
.
iPos
=
iPos
;
pT
-
>
aMap
[
pT
-
>
nMap
]
.
iIter
=
iIter
;
pT
-
>
aMap
[
pT
-
>
nMap
]
.
nByte
=
nByte
;
pT
-
>
nMap
+
+
;
}
}
static
void
fts5TokendataIterSortMap
(
Fts5Index
*
p
Fts5TokenDataIter
*
pT
)
{
Fts5TokenDataMap
*
aTmp
=
0
;
int
nByte
=
pT
-
>
nMap
*
sizeof
(
Fts5TokenDataMap
)
;
aTmp
=
(
Fts5TokenDataMap
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
nByte
)
;
if
(
aTmp
)
{
Fts5TokenDataMap
*
a1
=
pT
-
>
aMap
;
Fts5TokenDataMap
*
a2
=
aTmp
;
i64
nHalf
;
for
(
nHalf
=
1
;
nHalf
<
pT
-
>
nMap
;
nHalf
=
nHalf
*
2
)
{
int
i1
;
for
(
i1
=
0
;
i1
<
pT
-
>
nMap
;
i1
+
=
(
nHalf
*
2
)
)
{
int
n1
=
MIN
(
nHalf
pT
-
>
nMap
-
i1
)
;
int
n2
=
MIN
(
nHalf
pT
-
>
nMap
-
i1
-
n1
)
;
fts5TokendataMerge
(
&
a1
[
i1
]
n1
&
a1
[
i1
+
n1
]
n2
&
a2
[
i1
]
)
;
}
SWAPVAL
(
Fts5TokenDataMap
*
a1
a2
)
;
}
if
(
a1
!
=
pT
-
>
aMap
)
{
memcpy
(
pT
-
>
aMap
a1
pT
-
>
nMap
*
sizeof
(
Fts5TokenDataMap
)
)
;
}
sqlite3_free
(
aTmp
)
;
#
ifdef
SQLITE_DEBUG
{
int
ii
;
for
(
ii
=
1
;
ii
<
pT
-
>
nMap
;
ii
+
+
)
{
Fts5TokenDataMap
*
p1
=
&
pT
-
>
aMap
[
ii
-
1
]
;
Fts5TokenDataMap
*
p2
=
&
pT
-
>
aMap
[
ii
]
;
assert
(
p1
-
>
iRowid
<
p2
-
>
iRowid
|
|
(
p1
-
>
iRowid
=
=
p2
-
>
iRowid
&
&
p1
-
>
iPos
<
=
p2
-
>
iPos
)
)
;
}
}
#
endif
}
}
static
void
fts5TokendataIterDelete
(
Fts5TokenDataIter
*
pSet
)
{
if
(
pSet
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
pSet
-
>
nIter
;
ii
+
+
)
{
fts5MultiIterFree
(
pSet
-
>
apIter
[
ii
]
)
;
}
fts5BufferFree
(
&
pSet
-
>
terms
)
;
sqlite3_free
(
pSet
-
>
aPoslistReader
)
;
sqlite3_free
(
pSet
-
>
aMap
)
;
sqlite3_free
(
pSet
)
;
}
}
typedef
struct
TokendataSetupCtx
TokendataSetupCtx
;
struct
TokendataSetupCtx
{
Fts5TokenDataIter
*
pT
;
int
iTermOff
;
int
nTermByte
;
}
;
static
void
prefixIterSetupTokendataCb
(
Fts5Index
*
p
void
*
pCtx
Fts5Iter
*
p1
const
u8
*
pNew
int
nNew
)
{
TokendataSetupCtx
*
pSetup
=
(
TokendataSetupCtx
*
)
pCtx
;
int
iPosOff
=
0
;
i64
iPos
=
0
;
if
(
pNew
)
{
pSetup
-
>
nTermByte
=
nNew
-
1
;
pSetup
-
>
iTermOff
=
pSetup
-
>
pT
-
>
terms
.
n
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pSetup
-
>
pT
-
>
terms
nNew
-
1
pNew
+
1
)
;
}
while
(
0
=
=
sqlite3Fts5PoslistNext64
(
p1
-
>
base
.
pData
p1
-
>
base
.
nData
&
iPosOff
&
iPos
)
)
{
fts5TokendataIterAppendMap
(
p
pSetup
-
>
pT
pSetup
-
>
iTermOff
pSetup
-
>
nTermByte
p1
-
>
base
.
iRowid
iPos
)
;
}
}
typedef
struct
PrefixSetupCtx
PrefixSetupCtx
;
struct
PrefixSetupCtx
{
void
(
*
xMerge
)
(
Fts5Index
*
Fts5Buffer
*
int
Fts5Buffer
*
)
;
void
(
*
xAppend
)
(
Fts5Index
*
u64
Fts5Iter
*
Fts5Buffer
*
)
;
i64
iLastRowid
;
int
nMerge
;
Fts5Buffer
*
aBuf
;
int
nBuf
;
Fts5Buffer
doclist
;
TokendataSetupCtx
*
pTokendata
;
}
;
static
void
prefixIterSetupCb
(
Fts5Index
*
p
void
*
pCtx
Fts5Iter
*
p1
const
u8
*
pNew
int
nNew
)
{
PrefixSetupCtx
*
pSetup
=
(
PrefixSetupCtx
*
)
pCtx
;
const
int
nMerge
=
pSetup
-
>
nMerge
;
if
(
p1
-
>
base
.
nData
>
0
)
{
if
(
p1
-
>
base
.
iRowid
<
=
pSetup
-
>
iLastRowid
&
&
pSetup
-
>
doclist
.
n
>
0
)
{
int
i
;
for
(
i
=
0
;
p
-
>
rc
=
=
SQLITE_OK
&
&
pSetup
-
>
doclist
.
n
;
i
+
+
)
{
int
i1
=
i
*
nMerge
;
int
iStore
;
assert
(
i1
+
nMerge
<
=
pSetup
-
>
nBuf
)
;
for
(
iStore
=
i1
;
iStore
<
i1
+
nMerge
;
iStore
+
+
)
{
if
(
pSetup
-
>
aBuf
[
iStore
]
.
n
=
=
0
)
{
fts5BufferSwap
(
&
pSetup
-
>
doclist
&
pSetup
-
>
aBuf
[
iStore
]
)
;
fts5BufferZero
(
&
pSetup
-
>
doclist
)
;
break
;
}
}
if
(
iStore
=
=
i1
+
nMerge
)
{
pSetup
-
>
xMerge
(
p
&
pSetup
-
>
doclist
nMerge
&
pSetup
-
>
aBuf
[
i1
]
)
;
for
(
iStore
=
i1
;
iStore
<
i1
+
nMerge
;
iStore
+
+
)
{
fts5BufferZero
(
&
pSetup
-
>
aBuf
[
iStore
]
)
;
}
}
}
pSetup
-
>
iLastRowid
=
0
;
}
pSetup
-
>
xAppend
(
p
(
u64
)
p1
-
>
base
.
iRowid
-
(
u64
)
pSetup
-
>
iLastRowid
p1
&
pSetup
-
>
doclist
)
;
pSetup
-
>
iLastRowid
=
p1
-
>
base
.
iRowid
;
}
if
(
pSetup
-
>
pTokendata
)
{
prefixIterSetupTokendataCb
(
p
(
void
*
)
pSetup
-
>
pTokendata
p1
pNew
nNew
)
;
}
}
static
void
fts5SetupPrefixIter
(
Fts5Index
*
p
int
bDesc
int
iIdx
u8
*
pToken
int
nToken
Fts5Colset
*
pColset
Fts5Iter
*
*
ppIter
)
{
Fts5Structure
*
pStruct
;
PrefixSetupCtx
s
;
TokendataSetupCtx
s2
;
memset
(
&
s
0
sizeof
(
s
)
)
;
memset
(
&
s2
0
sizeof
(
s2
)
)
;
s
.
nMerge
=
1
;
s
.
iLastRowid
=
0
;
s
.
nBuf
=
32
;
if
(
iIdx
=
=
0
&
&
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_FULL
&
&
p
-
>
pConfig
-
>
bPrefixInsttoken
)
{
s
.
pTokendata
=
&
s2
;
s2
.
pT
=
(
Fts5TokenDataIter
*
)
fts5IdxMalloc
(
p
sizeof
(
*
s2
.
pT
)
)
;
}
if
(
p
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
s
.
xMerge
=
fts5MergeRowidLists
;
s
.
xAppend
=
fts5AppendRowid
;
}
else
{
s
.
nMerge
=
FTS5_MERGE_NLIST
-
1
;
s
.
nBuf
=
s
.
nMerge
*
8
;
s
.
xMerge
=
fts5MergePrefixLists
;
s
.
xAppend
=
fts5AppendPoslist
;
}
s
.
aBuf
=
(
Fts5Buffer
*
)
fts5IdxMalloc
(
p
sizeof
(
Fts5Buffer
)
*
s
.
nBuf
)
;
pStruct
=
fts5StructureRead
(
p
)
;
assert
(
p
-
>
rc
!
=
SQLITE_OK
|
|
(
s
.
aBuf
&
&
pStruct
)
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
void
*
pCtx
=
(
void
*
)
&
s
;
int
i
;
Fts5Data
*
pData
;
if
(
iIdx
!
=
0
)
{
pToken
[
0
]
=
FTS5_MAIN_PREFIX
;
fts5VisitEntries
(
p
pColset
pToken
nToken
0
prefixIterSetupCb
pCtx
)
;
}
pToken
[
0
]
=
FTS5_MAIN_PREFIX
+
iIdx
;
fts5VisitEntries
(
p
pColset
pToken
nToken
1
prefixIterSetupCb
pCtx
)
;
assert
(
(
s
.
nBuf
%
s
.
nMerge
)
=
=
0
)
;
for
(
i
=
0
;
i
<
s
.
nBuf
;
i
+
=
s
.
nMerge
)
{
int
iFree
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
s
.
xMerge
(
p
&
s
.
doclist
s
.
nMerge
&
s
.
aBuf
[
i
]
)
;
}
for
(
iFree
=
i
;
iFree
<
i
+
s
.
nMerge
;
iFree
+
+
)
{
fts5BufferFree
(
&
s
.
aBuf
[
iFree
]
)
;
}
}
pData
=
fts5IdxMalloc
(
p
sizeof
(
*
pData
)
+
s
.
doclist
.
n
+
FTS5_DATA_ZERO_PADDING
)
;
assert
(
pData
!
=
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
if
(
pData
)
{
pData
-
>
p
=
(
u8
*
)
&
pData
[
1
]
;
pData
-
>
nn
=
pData
-
>
szLeaf
=
s
.
doclist
.
n
;
if
(
s
.
doclist
.
n
)
memcpy
(
pData
-
>
p
s
.
doclist
.
p
s
.
doclist
.
n
)
;
fts5MultiIterNew2
(
p
pData
bDesc
ppIter
)
;
}
assert
(
(
*
ppIter
)
!
=
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
s
.
pTokendata
)
{
fts5TokendataIterSortMap
(
p
s2
.
pT
)
;
(
*
ppIter
)
-
>
pTokenDataIter
=
s2
.
pT
;
s2
.
pT
=
0
;
}
}
fts5TokendataIterDelete
(
s2
.
pT
)
;
fts5BufferFree
(
&
s
.
doclist
)
;
fts5StructureRelease
(
pStruct
)
;
sqlite3_free
(
s
.
aBuf
)
;
}
static
int
sqlite3Fts5IndexBeginWrite
(
Fts5Index
*
p
int
bDelete
i64
iRowid
)
{
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
if
(
p
-
>
pHash
=
=
0
)
{
p
-
>
rc
=
sqlite3Fts5HashNew
(
p
-
>
pConfig
&
p
-
>
pHash
&
p
-
>
nPendingData
)
;
}
if
(
iRowid
<
p
-
>
iWriteRowid
|
|
(
iRowid
=
=
p
-
>
iWriteRowid
&
&
p
-
>
bDelete
=
=
0
)
|
|
(
p
-
>
nPendingData
>
p
-
>
pConfig
-
>
nHashSize
)
)
{
fts5IndexFlush
(
p
)
;
}
p
-
>
iWriteRowid
=
iRowid
;
p
-
>
bDelete
=
bDelete
;
if
(
bDelete
=
=
0
)
{
p
-
>
nPendingRow
+
+
;
}
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexSync
(
Fts5Index
*
p
)
{
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
fts5IndexFlush
(
p
)
;
fts5IndexCloseReader
(
p
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexRollback
(
Fts5Index
*
p
)
{
fts5IndexCloseReader
(
p
)
;
fts5IndexDiscardData
(
p
)
;
fts5StructureInvalidate
(
p
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexReinit
(
Fts5Index
*
p
)
{
Fts5Structure
s
;
fts5StructureInvalidate
(
p
)
;
fts5IndexDiscardData
(
p
)
;
memset
(
&
s
0
sizeof
(
Fts5Structure
)
)
;
if
(
p
-
>
pConfig
-
>
bContentlessDelete
)
{
s
.
nOriginCntr
=
1
;
}
fts5DataWrite
(
p
FTS5_AVERAGES_ROWID
(
const
u8
*
)
"
"
0
)
;
fts5StructureWrite
(
p
&
s
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexOpen
(
Fts5Config
*
pConfig
int
bCreate
Fts5Index
*
*
pp
char
*
*
pzErr
)
{
int
rc
=
SQLITE_OK
;
Fts5Index
*
p
;
*
pp
=
p
=
(
Fts5Index
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5Index
)
)
;
if
(
rc
=
=
SQLITE_OK
)
{
p
-
>
pConfig
=
pConfig
;
p
-
>
nWorkUnit
=
FTS5_WORK_UNIT
;
p
-
>
zDataTbl
=
sqlite3Fts5Mprintf
(
&
rc
"
%
s_data
"
pConfig
-
>
zName
)
;
if
(
p
-
>
zDataTbl
&
&
bCreate
)
{
rc
=
sqlite3Fts5CreateTable
(
pConfig
"
data
"
"
id
INTEGER
PRIMARY
KEY
block
BLOB
"
0
pzErr
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5CreateTable
(
pConfig
"
idx
"
"
segid
term
pgno
PRIMARY
KEY
(
segid
term
)
"
1
pzErr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexReinit
(
p
)
;
}
}
}
assert
(
rc
!
=
SQLITE_OK
|
|
p
-
>
rc
=
=
SQLITE_OK
)
;
if
(
rc
)
{
sqlite3Fts5IndexClose
(
p
)
;
*
pp
=
0
;
}
return
rc
;
}
static
int
sqlite3Fts5IndexClose
(
Fts5Index
*
p
)
{
int
rc
=
SQLITE_OK
;
if
(
p
)
{
assert
(
p
-
>
pReader
=
=
0
)
;
fts5StructureInvalidate
(
p
)
;
sqlite3_finalize
(
p
-
>
pWriter
)
;
sqlite3_finalize
(
p
-
>
pDeleter
)
;
sqlite3_finalize
(
p
-
>
pIdxWriter
)
;
sqlite3_finalize
(
p
-
>
pIdxDeleter
)
;
sqlite3_finalize
(
p
-
>
pIdxSelect
)
;
sqlite3_finalize
(
p
-
>
pIdxNextSelect
)
;
sqlite3_finalize
(
p
-
>
pDataVersion
)
;
sqlite3_finalize
(
p
-
>
pDeleteFromIdx
)
;
sqlite3Fts5HashFree
(
p
-
>
pHash
)
;
sqlite3_free
(
p
-
>
zDataTbl
)
;
sqlite3_free
(
p
)
;
}
return
rc
;
}
static
int
sqlite3Fts5IndexCharlenToBytelen
(
const
char
*
p
int
nByte
int
nChar
)
{
int
n
=
0
;
int
i
;
for
(
i
=
0
;
i
<
nChar
;
i
+
+
)
{
if
(
n
>
=
nByte
)
return
0
;
if
(
(
unsigned
char
)
p
[
n
+
+
]
>
=
0xc0
)
{
if
(
n
>
=
nByte
)
return
0
;
while
(
(
p
[
n
]
&
0xc0
)
=
=
0x80
)
{
n
+
+
;
if
(
n
>
=
nByte
)
{
if
(
i
+
1
=
=
nChar
)
break
;
return
0
;
}
}
}
}
return
n
;
}
static
int
fts5IndexCharlen
(
const
char
*
pIn
int
nIn
)
{
int
nChar
=
0
;
int
i
=
0
;
while
(
i
<
nIn
)
{
if
(
(
unsigned
char
)
pIn
[
i
+
+
]
>
=
0xc0
)
{
while
(
i
<
nIn
&
&
(
pIn
[
i
]
&
0xc0
)
=
=
0x80
)
i
+
+
;
}
nChar
+
+
;
}
return
nChar
;
}
static
int
sqlite3Fts5IndexWrite
(
Fts5Index
*
p
int
iCol
int
iPos
const
char
*
pToken
int
nToken
)
{
int
i
;
int
rc
=
SQLITE_OK
;
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
assert
(
(
iCol
<
0
)
=
=
p
-
>
bDelete
)
;
rc
=
sqlite3Fts5HashWrite
(
p
-
>
pHash
p
-
>
iWriteRowid
iCol
iPos
FTS5_MAIN_PREFIX
pToken
nToken
)
;
for
(
i
=
0
;
i
<
pConfig
-
>
nPrefix
&
&
rc
=
=
SQLITE_OK
;
i
+
+
)
{
const
int
nChar
=
pConfig
-
>
aPrefix
[
i
]
;
int
nByte
=
sqlite3Fts5IndexCharlenToBytelen
(
pToken
nToken
nChar
)
;
if
(
nByte
)
{
rc
=
sqlite3Fts5HashWrite
(
p
-
>
pHash
p
-
>
iWriteRowid
iCol
iPos
(
char
)
(
FTS5_MAIN_PREFIX
+
i
+
1
)
pToken
nByte
)
;
}
}
return
rc
;
}
static
int
fts5IsTokendataPrefix
(
Fts5Buffer
*
pBuf
const
u8
*
pToken
int
nToken
)
{
return
(
pBuf
-
>
n
>
=
nToken
&
&
0
=
=
memcmp
(
pBuf
-
>
p
pToken
nToken
)
&
&
(
pBuf
-
>
n
=
=
nToken
|
|
pBuf
-
>
p
[
nToken
]
=
=
0x00
)
)
;
}
static
void
fts5SegIterSetEOF
(
Fts5SegIter
*
pSeg
)
{
fts5DataRelease
(
pSeg
-
>
pLeaf
)
;
pSeg
-
>
pLeaf
=
0
;
}
static
void
fts5IterClose
(
Fts5IndexIter
*
pIndexIter
)
{
if
(
pIndexIter
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
Fts5Index
*
pIndex
=
pIter
-
>
pIndex
;
fts5TokendataIterDelete
(
pIter
-
>
pTokenDataIter
)
;
fts5MultiIterFree
(
pIter
)
;
fts5IndexCloseReader
(
pIndex
)
;
}
}
static
Fts5TokenDataIter
*
fts5AppendTokendataIter
(
Fts5Index
*
p
Fts5TokenDataIter
*
pIn
Fts5Iter
*
pAppend
)
{
Fts5TokenDataIter
*
pRet
=
pIn
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
if
(
pIn
=
=
0
|
|
pIn
-
>
nIter
=
=
pIn
-
>
nIterAlloc
)
{
int
nAlloc
=
pIn
?
pIn
-
>
nIterAlloc
*
2
:
16
;
int
nByte
=
nAlloc
*
sizeof
(
Fts5Iter
*
)
+
sizeof
(
Fts5TokenDataIter
)
;
Fts5TokenDataIter
*
pNew
=
(
Fts5TokenDataIter
*
)
sqlite3_realloc
(
pIn
nByte
)
;
if
(
pNew
=
=
0
)
{
p
-
>
rc
=
SQLITE_NOMEM
;
}
else
{
if
(
pIn
=
=
0
)
memset
(
pNew
0
nByte
)
;
pRet
=
pNew
;
pNew
-
>
nIterAlloc
=
nAlloc
;
}
}
}
if
(
p
-
>
rc
)
{
fts5IterClose
(
(
Fts5IndexIter
*
)
pAppend
)
;
}
else
{
pRet
-
>
apIter
[
pRet
-
>
nIter
+
+
]
=
pAppend
;
}
assert
(
pRet
=
=
0
|
|
pRet
-
>
nIter
<
=
pRet
-
>
nIterAlloc
)
;
return
pRet
;
}
static
void
fts5IterSetOutputsTokendata
(
Fts5Iter
*
pIter
)
{
int
ii
;
int
nHit
=
0
;
i64
iRowid
=
SMALLEST_INT64
;
int
iMin
=
0
;
Fts5TokenDataIter
*
pT
=
pIter
-
>
pTokenDataIter
;
pIter
-
>
base
.
nData
=
0
;
pIter
-
>
base
.
pData
=
0
;
for
(
ii
=
0
;
ii
<
pT
-
>
nIter
;
ii
+
+
)
{
Fts5Iter
*
p
=
pT
-
>
apIter
[
ii
]
;
if
(
p
-
>
base
.
bEof
=
=
0
)
{
if
(
nHit
=
=
0
|
|
p
-
>
base
.
iRowid
<
iRowid
)
{
iRowid
=
p
-
>
base
.
iRowid
;
nHit
=
1
;
pIter
-
>
base
.
pData
=
p
-
>
base
.
pData
;
pIter
-
>
base
.
nData
=
p
-
>
base
.
nData
;
iMin
=
ii
;
}
else
if
(
p
-
>
base
.
iRowid
=
=
iRowid
)
{
nHit
+
+
;
}
}
}
if
(
nHit
=
=
0
)
{
pIter
-
>
base
.
bEof
=
1
;
}
else
{
int
eDetail
=
pIter
-
>
pIndex
-
>
pConfig
-
>
eDetail
;
pIter
-
>
base
.
bEof
=
0
;
pIter
-
>
base
.
iRowid
=
iRowid
;
if
(
nHit
=
=
1
&
&
eDetail
=
=
FTS5_DETAIL_FULL
)
{
fts5TokendataIterAppendMap
(
pIter
-
>
pIndex
pT
iMin
0
iRowid
-
1
)
;
}
else
if
(
nHit
>
1
&
&
eDetail
!
=
FTS5_DETAIL_NONE
)
{
int
nReader
=
0
;
int
nByte
=
0
;
i64
iPrev
=
0
;
if
(
pT
-
>
aPoslistReader
=
=
0
)
{
pT
-
>
aPoslistReader
=
(
Fts5PoslistReader
*
)
sqlite3Fts5MallocZero
(
&
pIter
-
>
pIndex
-
>
rc
pT
-
>
nIter
*
(
sizeof
(
Fts5PoslistReader
)
+
sizeof
(
int
)
)
)
;
if
(
pT
-
>
aPoslistReader
=
=
0
)
return
;
pT
-
>
aPoslistToIter
=
(
int
*
)
&
pT
-
>
aPoslistReader
[
pT
-
>
nIter
]
;
}
for
(
ii
=
0
;
ii
<
pT
-
>
nIter
;
ii
+
+
)
{
Fts5Iter
*
p
=
pT
-
>
apIter
[
ii
]
;
if
(
iRowid
=
=
p
-
>
base
.
iRowid
)
{
pT
-
>
aPoslistToIter
[
nReader
]
=
ii
;
sqlite3Fts5PoslistReaderInit
(
p
-
>
base
.
pData
p
-
>
base
.
nData
&
pT
-
>
aPoslistReader
[
nReader
+
+
]
)
;
nByte
+
=
p
-
>
base
.
nData
;
}
}
if
(
fts5BufferGrow
(
&
pIter
-
>
pIndex
-
>
rc
&
pIter
-
>
poslist
nByte
+
nHit
*
10
)
)
{
return
;
}
if
(
eDetail
=
=
FTS5_DETAIL_FULL
&
&
pT
-
>
nMapAlloc
<
(
pT
-
>
nMap
+
nByte
)
)
{
int
nNew
=
(
pT
-
>
nMapAlloc
+
nByte
)
*
2
;
Fts5TokenDataMap
*
aNew
=
(
Fts5TokenDataMap
*
)
sqlite3_realloc
(
pT
-
>
aMap
nNew
*
sizeof
(
Fts5TokenDataMap
)
)
;
if
(
aNew
=
=
0
)
{
pIter
-
>
pIndex
-
>
rc
=
SQLITE_NOMEM
;
return
;
}
pT
-
>
aMap
=
aNew
;
pT
-
>
nMapAlloc
=
nNew
;
}
pIter
-
>
poslist
.
n
=
0
;
while
(
1
)
{
i64
iMinPos
=
LARGEST_INT64
;
iMin
=
0
;
for
(
ii
=
0
;
ii
<
nReader
;
ii
+
+
)
{
Fts5PoslistReader
*
pReader
=
&
pT
-
>
aPoslistReader
[
ii
]
;
if
(
pReader
-
>
bEof
=
=
0
)
{
if
(
pReader
-
>
iPos
<
iMinPos
)
{
iMinPos
=
pReader
-
>
iPos
;
iMin
=
ii
;
}
}
}
if
(
iMinPos
=
=
LARGEST_INT64
)
break
;
sqlite3Fts5PoslistSafeAppend
(
&
pIter
-
>
poslist
&
iPrev
iMinPos
)
;
sqlite3Fts5PoslistReaderNext
(
&
pT
-
>
aPoslistReader
[
iMin
]
)
;
if
(
eDetail
=
=
FTS5_DETAIL_FULL
)
{
pT
-
>
aMap
[
pT
-
>
nMap
]
.
iPos
=
iMinPos
;
pT
-
>
aMap
[
pT
-
>
nMap
]
.
iIter
=
pT
-
>
aPoslistToIter
[
iMin
]
;
pT
-
>
aMap
[
pT
-
>
nMap
]
.
iRowid
=
iRowid
;
pT
-
>
nMap
+
+
;
}
}
pIter
-
>
base
.
pData
=
pIter
-
>
poslist
.
p
;
pIter
-
>
base
.
nData
=
pIter
-
>
poslist
.
n
;
}
}
}
static
void
fts5TokendataIterNext
(
Fts5Iter
*
pIter
int
bFrom
i64
iFrom
)
{
int
ii
;
Fts5TokenDataIter
*
pT
=
pIter
-
>
pTokenDataIter
;
Fts5Index
*
pIndex
=
pIter
-
>
pIndex
;
for
(
ii
=
0
;
ii
<
pT
-
>
nIter
;
ii
+
+
)
{
Fts5Iter
*
p
=
pT
-
>
apIter
[
ii
]
;
if
(
p
-
>
base
.
bEof
=
=
0
&
&
(
p
-
>
base
.
iRowid
=
=
pIter
-
>
base
.
iRowid
|
|
(
bFrom
&
&
p
-
>
base
.
iRowid
<
iFrom
)
)
)
{
fts5MultiIterNext
(
pIndex
p
bFrom
iFrom
)
;
while
(
bFrom
&
&
p
-
>
base
.
bEof
=
=
0
&
&
p
-
>
base
.
iRowid
<
iFrom
&
&
pIndex
-
>
rc
=
=
SQLITE_OK
)
{
fts5MultiIterNext
(
pIndex
p
0
0
)
;
}
}
}
if
(
pIndex
-
>
rc
=
=
SQLITE_OK
)
{
fts5IterSetOutputsTokendata
(
pIter
)
;
}
}
static
void
fts5TokendataSetTermIfEof
(
Fts5Iter
*
pIter
Fts5Buffer
*
pTerm
)
{
if
(
pIter
&
&
pIter
-
>
aSeg
[
0
]
.
pLeaf
=
=
0
)
{
fts5BufferSet
(
&
pIter
-
>
pIndex
-
>
rc
&
pIter
-
>
aSeg
[
0
]
.
term
pTerm
-
>
n
pTerm
-
>
p
)
;
}
}
static
Fts5Iter
*
fts5SetupTokendataIter
(
Fts5Index
*
p
const
u8
*
pToken
int
nToken
Fts5Colset
*
pColset
)
{
Fts5Iter
*
pRet
=
0
;
Fts5TokenDataIter
*
pSet
=
0
;
Fts5Structure
*
pStruct
=
0
;
const
int
flags
=
FTS5INDEX_QUERY_SCANONETERM
|
FTS5INDEX_QUERY_SCAN
;
Fts5Buffer
bSeek
=
{
0
0
0
}
;
Fts5Buffer
*
pSmall
=
0
;
fts5IndexFlush
(
p
)
;
pStruct
=
fts5StructureRead
(
p
)
;
while
(
p
-
>
rc
=
=
SQLITE_OK
)
{
Fts5Iter
*
pPrev
=
pSet
?
pSet
-
>
apIter
[
pSet
-
>
nIter
-
1
]
:
0
;
Fts5Iter
*
pNew
=
0
;
Fts5SegIter
*
pNewIter
=
0
;
Fts5SegIter
*
pPrevIter
=
0
;
int
iLvl
iSeg
ii
;
pNew
=
fts5MultiIterAlloc
(
p
pStruct
-
>
nSegment
)
;
if
(
pSmall
)
{
fts5BufferSet
(
&
p
-
>
rc
&
bSeek
pSmall
-
>
n
pSmall
-
>
p
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
bSeek
1
(
const
u8
*
)
"
\
0
"
)
;
}
else
{
fts5BufferSet
(
&
p
-
>
rc
&
bSeek
nToken
pToken
)
;
}
if
(
p
-
>
rc
)
{
fts5IterClose
(
(
Fts5IndexIter
*
)
pNew
)
;
break
;
}
pNewIter
=
&
pNew
-
>
aSeg
[
0
]
;
pPrevIter
=
(
pPrev
?
&
pPrev
-
>
aSeg
[
0
]
:
0
)
;
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
for
(
iSeg
=
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
-
1
;
iSeg
>
=
0
;
iSeg
-
-
)
{
Fts5StructureSegment
*
pSeg
=
&
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
iSeg
]
;
int
bDone
=
0
;
if
(
pPrevIter
)
{
if
(
fts5BufferCompare
(
pSmall
&
pPrevIter
-
>
term
)
)
{
memcpy
(
pNewIter
pPrevIter
sizeof
(
Fts5SegIter
)
)
;
memset
(
pPrevIter
0
sizeof
(
Fts5SegIter
)
)
;
bDone
=
1
;
}
else
if
(
pPrevIter
-
>
iEndofDoclist
>
pPrevIter
-
>
pLeaf
-
>
szLeaf
)
{
fts5SegIterNextInit
(
p
(
const
char
*
)
bSeek
.
p
bSeek
.
n
-
1
pSeg
pNewIter
)
;
bDone
=
1
;
}
}
if
(
bDone
=
=
0
)
{
fts5SegIterSeekInit
(
p
bSeek
.
p
bSeek
.
n
flags
pSeg
pNewIter
)
;
}
if
(
pPrevIter
)
{
if
(
pPrevIter
-
>
pTombArray
)
{
pNewIter
-
>
pTombArray
=
pPrevIter
-
>
pTombArray
;
pNewIter
-
>
pTombArray
-
>
nRef
+
+
;
}
}
else
{
fts5SegIterAllocTombstone
(
p
pNewIter
)
;
}
pNewIter
+
+
;
if
(
pPrevIter
)
pPrevIter
+
+
;
if
(
p
-
>
rc
)
break
;
}
}
fts5TokendataSetTermIfEof
(
pPrev
pSmall
)
;
pNew
-
>
bSkipEmpty
=
1
;
pNew
-
>
pColset
=
pColset
;
fts5IterSetOutputCb
(
&
p
-
>
rc
pNew
)
;
pSmall
=
0
;
for
(
ii
=
0
;
ii
<
pNew
-
>
nSeg
;
ii
+
+
)
{
Fts5SegIter
*
pII
=
&
pNew
-
>
aSeg
[
ii
]
;
if
(
0
=
=
fts5IsTokendataPrefix
(
&
pII
-
>
term
pToken
nToken
)
)
{
fts5SegIterSetEOF
(
pII
)
;
}
if
(
pII
-
>
pLeaf
&
&
(
!
pSmall
|
|
fts5BufferCompare
(
pSmall
&
pII
-
>
term
)
>
0
)
)
{
pSmall
=
&
pII
-
>
term
;
}
}
if
(
pSmall
=
=
0
)
{
fts5IterClose
(
(
Fts5IndexIter
*
)
pNew
)
;
break
;
}
pSet
=
fts5AppendTokendataIter
(
p
pSet
pNew
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pSet
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
pSet
-
>
nIter
;
ii
+
+
)
{
Fts5Iter
*
pIter
=
pSet
-
>
apIter
[
ii
]
;
int
iSeg
;
for
(
iSeg
=
0
;
iSeg
<
pIter
-
>
nSeg
;
iSeg
+
+
)
{
pIter
-
>
aSeg
[
iSeg
]
.
flags
|
=
FTS5_SEGITER_ONETERM
;
}
fts5MultiIterFinishSetup
(
p
pIter
)
;
}
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
pRet
=
fts5MultiIterAlloc
(
p
0
)
;
}
if
(
pRet
)
{
pRet
-
>
nSeg
=
0
;
pRet
-
>
pTokenDataIter
=
pSet
;
if
(
pSet
)
{
fts5IterSetOutputsTokendata
(
pRet
)
;
}
else
{
pRet
-
>
base
.
bEof
=
1
;
}
}
else
{
fts5TokendataIterDelete
(
pSet
)
;
}
fts5StructureRelease
(
pStruct
)
;
fts5BufferFree
(
&
bSeek
)
;
return
pRet
;
}
static
int
sqlite3Fts5IndexQuery
(
Fts5Index
*
p
const
char
*
pToken
int
nToken
int
flags
Fts5Colset
*
pColset
Fts5IndexIter
*
*
ppIter
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
Fts5Iter
*
pRet
=
0
;
Fts5Buffer
buf
=
{
0
0
0
}
;
assert
(
(
flags
&
FTS5INDEX_QUERY_SCAN
)
=
=
0
|
|
flags
=
=
FTS5INDEX_QUERY_SCAN
)
;
if
(
sqlite3Fts5BufferSize
(
&
p
-
>
rc
&
buf
nToken
+
1
)
=
=
0
)
{
int
iIdx
=
0
;
int
iPrefixIdx
=
0
;
int
bTokendata
=
pConfig
-
>
bTokendata
;
assert
(
buf
.
p
!
=
0
)
;
if
(
nToken
>
0
)
memcpy
(
&
buf
.
p
[
1
]
pToken
nToken
)
;
if
(
flags
&
(
FTS5INDEX_QUERY_NOTOKENDATA
|
FTS5INDEX_QUERY_SCAN
)
)
{
bTokendata
=
0
;
}
#
ifdef
SQLITE_DEBUG
if
(
pConfig
-
>
bPrefixIndex
=
=
0
|
|
(
flags
&
FTS5INDEX_QUERY_TEST_NOIDX
)
)
{
assert
(
flags
&
FTS5INDEX_QUERY_PREFIX
)
;
iIdx
=
1
+
pConfig
-
>
nPrefix
;
}
else
#
endif
if
(
flags
&
FTS5INDEX_QUERY_PREFIX
)
{
int
nChar
=
fts5IndexCharlen
(
pToken
nToken
)
;
for
(
iIdx
=
1
;
iIdx
<
=
pConfig
-
>
nPrefix
;
iIdx
+
+
)
{
int
nIdxChar
=
pConfig
-
>
aPrefix
[
iIdx
-
1
]
;
if
(
nIdxChar
=
=
nChar
)
break
;
if
(
nIdxChar
=
=
nChar
+
1
)
iPrefixIdx
=
iIdx
;
}
}
if
(
bTokendata
&
&
iIdx
=
=
0
)
{
buf
.
p
[
0
]
=
FTS5_MAIN_PREFIX
;
pRet
=
fts5SetupTokendataIter
(
p
buf
.
p
nToken
+
1
pColset
)
;
}
else
if
(
iIdx
<
=
pConfig
-
>
nPrefix
)
{
Fts5Structure
*
pStruct
=
fts5StructureRead
(
p
)
;
buf
.
p
[
0
]
=
(
u8
)
(
FTS5_MAIN_PREFIX
+
iIdx
)
;
if
(
pStruct
)
{
fts5MultiIterNew
(
p
pStruct
flags
|
FTS5INDEX_QUERY_SKIPEMPTY
pColset
buf
.
p
nToken
+
1
-
1
0
&
pRet
)
;
fts5StructureRelease
(
pStruct
)
;
}
}
else
{
int
bDesc
=
(
flags
&
FTS5INDEX_QUERY_DESC
)
!
=
0
;
fts5SetupPrefixIter
(
p
bDesc
iPrefixIdx
buf
.
p
nToken
+
1
pColset
&
pRet
)
;
if
(
pRet
=
=
0
)
{
assert
(
p
-
>
rc
!
=
SQLITE_OK
)
;
}
else
{
assert
(
pRet
-
>
pColset
=
=
0
)
;
fts5IterSetOutputCb
(
&
p
-
>
rc
pRet
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
Fts5SegIter
*
pSeg
=
&
pRet
-
>
aSeg
[
pRet
-
>
aFirst
[
1
]
.
iFirst
]
;
if
(
pSeg
-
>
pLeaf
)
pRet
-
>
xSetOutputs
(
pRet
pSeg
)
;
}
}
}
if
(
p
-
>
rc
)
{
fts5IterClose
(
(
Fts5IndexIter
*
)
pRet
)
;
pRet
=
0
;
fts5IndexCloseReader
(
p
)
;
}
*
ppIter
=
(
Fts5IndexIter
*
)
pRet
;
sqlite3Fts5BufferFree
(
&
buf
)
;
}
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IterNext
(
Fts5IndexIter
*
pIndexIter
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
assert
(
pIter
-
>
pIndex
-
>
rc
=
=
SQLITE_OK
)
;
if
(
pIter
-
>
nSeg
=
=
0
)
{
assert
(
pIter
-
>
pTokenDataIter
)
;
fts5TokendataIterNext
(
pIter
0
0
)
;
}
else
{
fts5MultiIterNext
(
pIter
-
>
pIndex
pIter
0
0
)
;
}
return
fts5IndexReturn
(
pIter
-
>
pIndex
)
;
}
static
int
sqlite3Fts5IterNextScan
(
Fts5IndexIter
*
pIndexIter
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
Fts5Index
*
p
=
pIter
-
>
pIndex
;
assert
(
pIter
-
>
pIndex
-
>
rc
=
=
SQLITE_OK
)
;
fts5MultiIterNext
(
p
pIter
0
0
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
Fts5SegIter
*
pSeg
=
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
;
if
(
pSeg
-
>
pLeaf
&
&
pSeg
-
>
term
.
p
[
0
]
!
=
FTS5_MAIN_PREFIX
)
{
fts5DataRelease
(
pSeg
-
>
pLeaf
)
;
pSeg
-
>
pLeaf
=
0
;
pIter
-
>
base
.
bEof
=
1
;
}
}
return
fts5IndexReturn
(
pIter
-
>
pIndex
)
;
}
static
int
sqlite3Fts5IterNextFrom
(
Fts5IndexIter
*
pIndexIter
i64
iMatch
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
if
(
pIter
-
>
nSeg
=
=
0
)
{
assert
(
pIter
-
>
pTokenDataIter
)
;
fts5TokendataIterNext
(
pIter
1
iMatch
)
;
}
else
{
fts5MultiIterNextFrom
(
pIter
-
>
pIndex
pIter
iMatch
)
;
}
return
fts5IndexReturn
(
pIter
-
>
pIndex
)
;
}
static
const
char
*
sqlite3Fts5IterTerm
(
Fts5IndexIter
*
pIndexIter
int
*
pn
)
{
int
n
;
const
char
*
z
=
(
const
char
*
)
fts5MultiIterTerm
(
(
Fts5Iter
*
)
pIndexIter
&
n
)
;
assert_nc
(
z
|
|
n
<
=
1
)
;
*
pn
=
n
-
1
;
return
(
z
?
&
z
[
1
]
:
0
)
;
}
static
int
fts5SetupPrefixIterTokendata
(
Fts5Iter
*
pIter
const
char
*
pToken
int
nToken
)
{
Fts5Index
*
p
=
pIter
-
>
pIndex
;
Fts5Buffer
token
=
{
0
0
0
}
;
TokendataSetupCtx
ctx
;
memset
(
&
ctx
0
sizeof
(
ctx
)
)
;
fts5BufferGrow
(
&
p
-
>
rc
&
token
nToken
+
1
)
;
assert
(
token
.
p
!
=
0
|
|
p
-
>
rc
!
=
SQLITE_OK
)
;
ctx
.
pT
=
(
Fts5TokenDataIter
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
sizeof
(
*
ctx
.
pT
)
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
token
.
p
[
0
]
=
FTS5_MAIN_PREFIX
;
memcpy
(
&
token
.
p
[
1
]
pToken
nToken
)
;
token
.
n
=
nToken
+
1
;
fts5VisitEntries
(
p
0
token
.
p
token
.
n
1
prefixIterSetupTokendataCb
(
void
*
)
&
ctx
)
;
fts5TokendataIterSortMap
(
p
ctx
.
pT
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
pIter
-
>
pTokenDataIter
=
ctx
.
pT
;
}
else
{
fts5TokendataIterDelete
(
ctx
.
pT
)
;
}
fts5BufferFree
(
&
token
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IterToken
(
Fts5IndexIter
*
pIndexIter
const
char
*
pToken
int
nToken
i64
iRowid
int
iCol
int
iOff
const
char
*
*
ppOut
int
*
pnOut
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
Fts5TokenDataIter
*
pT
=
pIter
-
>
pTokenDataIter
;
i64
iPos
=
(
(
(
i64
)
iCol
)
<
<
32
)
+
iOff
;
Fts5TokenDataMap
*
aMap
=
0
;
int
i1
=
0
;
int
i2
=
0
;
int
iTest
=
0
;
assert
(
pT
|
|
(
pToken
&
&
pIter
-
>
nSeg
>
0
)
)
;
if
(
pT
=
=
0
)
{
int
rc
=
fts5SetupPrefixIterTokendata
(
pIter
pToken
nToken
)
;
if
(
rc
!
=
SQLITE_OK
)
return
rc
;
pT
=
pIter
-
>
pTokenDataIter
;
}
i2
=
pT
-
>
nMap
;
aMap
=
pT
-
>
aMap
;
while
(
i2
>
i1
)
{
iTest
=
(
i1
+
i2
)
/
2
;
if
(
aMap
[
iTest
]
.
iRowid
<
iRowid
)
{
i1
=
iTest
+
1
;
}
else
if
(
aMap
[
iTest
]
.
iRowid
>
iRowid
)
{
i2
=
iTest
;
}
else
{
if
(
aMap
[
iTest
]
.
iPos
<
iPos
)
{
if
(
aMap
[
iTest
]
.
iPos
<
0
)
{
break
;
}
i1
=
iTest
+
1
;
}
else
if
(
aMap
[
iTest
]
.
iPos
>
iPos
)
{
i2
=
iTest
;
}
else
{
break
;
}
}
}
if
(
i2
>
i1
)
{
if
(
pIter
-
>
nSeg
=
=
0
)
{
Fts5Iter
*
pMap
=
pT
-
>
apIter
[
aMap
[
iTest
]
.
iIter
]
;
*
ppOut
=
(
const
char
*
)
pMap
-
>
aSeg
[
0
]
.
term
.
p
+
1
;
*
pnOut
=
pMap
-
>
aSeg
[
0
]
.
term
.
n
-
1
;
}
else
{
Fts5TokenDataMap
*
p
=
&
aMap
[
iTest
]
;
*
ppOut
=
(
const
char
*
)
&
pT
-
>
terms
.
p
[
p
-
>
iIter
]
;
*
pnOut
=
aMap
[
iTest
]
.
nByte
;
}
}
return
SQLITE_OK
;
}
static
void
sqlite3Fts5IndexIterClearTokendata
(
Fts5IndexIter
*
pIndexIter
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
if
(
pIter
&
&
pIter
-
>
pTokenDataIter
&
&
(
pIter
-
>
nSeg
=
=
0
|
|
pIter
-
>
pIndex
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
)
)
{
pIter
-
>
pTokenDataIter
-
>
nMap
=
0
;
}
}
static
int
sqlite3Fts5IndexIterWriteTokendata
(
Fts5IndexIter
*
pIndexIter
const
char
*
pToken
int
nToken
i64
iRowid
int
iCol
int
iOff
)
{
Fts5Iter
*
pIter
=
(
Fts5Iter
*
)
pIndexIter
;
Fts5TokenDataIter
*
pT
=
pIter
-
>
pTokenDataIter
;
Fts5Index
*
p
=
pIter
-
>
pIndex
;
i64
iPos
=
(
(
(
i64
)
iCol
)
<
<
32
)
+
iOff
;
assert
(
p
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
)
;
assert
(
pIter
-
>
pTokenDataIter
|
|
pIter
-
>
nSeg
>
0
)
;
if
(
pIter
-
>
nSeg
>
0
)
{
if
(
pT
=
=
0
)
{
pT
=
(
Fts5TokenDataIter
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
sizeof
(
*
pT
)
)
;
pIter
-
>
pTokenDataIter
=
pT
;
}
if
(
pT
)
{
fts5TokendataIterAppendMap
(
p
pT
pT
-
>
terms
.
n
nToken
iRowid
iPos
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
pT
-
>
terms
nToken
(
const
u8
*
)
pToken
)
;
}
}
else
{
int
ii
;
for
(
ii
=
0
;
ii
<
pT
-
>
nIter
;
ii
+
+
)
{
Fts5Buffer
*
pTerm
=
&
pT
-
>
apIter
[
ii
]
-
>
aSeg
[
0
]
.
term
;
if
(
nToken
=
=
pTerm
-
>
n
-
1
&
&
memcmp
(
pToken
pTerm
-
>
p
+
1
nToken
)
=
=
0
)
break
;
}
if
(
ii
<
pT
-
>
nIter
)
{
fts5TokendataIterAppendMap
(
p
pT
ii
0
iRowid
iPos
)
;
}
}
return
fts5IndexReturn
(
p
)
;
}
static
void
sqlite3Fts5IterClose
(
Fts5IndexIter
*
pIndexIter
)
{
if
(
pIndexIter
)
{
Fts5Index
*
pIndex
=
(
(
Fts5Iter
*
)
pIndexIter
)
-
>
pIndex
;
fts5IterClose
(
pIndexIter
)
;
fts5IndexReturn
(
pIndex
)
;
}
}
static
int
sqlite3Fts5IndexGetAverages
(
Fts5Index
*
p
i64
*
pnRow
i64
*
anSize
)
{
int
nCol
=
p
-
>
pConfig
-
>
nCol
;
Fts5Data
*
pData
;
*
pnRow
=
0
;
memset
(
anSize
0
sizeof
(
i64
)
*
nCol
)
;
pData
=
fts5DataRead
(
p
FTS5_AVERAGES_ROWID
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
pData
-
>
nn
)
{
int
i
=
0
;
int
iCol
;
i
+
=
fts5GetVarint
(
&
pData
-
>
p
[
i
]
(
u64
*
)
pnRow
)
;
for
(
iCol
=
0
;
i
<
pData
-
>
nn
&
&
iCol
<
nCol
;
iCol
+
+
)
{
i
+
=
fts5GetVarint
(
&
pData
-
>
p
[
i
]
(
u64
*
)
&
anSize
[
iCol
]
)
;
}
}
fts5DataRelease
(
pData
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexSetAverages
(
Fts5Index
*
p
const
u8
*
pData
int
nData
)
{
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
fts5DataWrite
(
p
FTS5_AVERAGES_ROWID
pData
nData
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexReads
(
Fts5Index
*
p
)
{
return
p
-
>
nRead
;
}
static
int
sqlite3Fts5IndexSetCookie
(
Fts5Index
*
p
int
iNew
)
{
int
rc
;
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
u8
aCookie
[
4
]
;
sqlite3_blob
*
pBlob
=
0
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
sqlite3Fts5Put32
(
aCookie
iNew
)
;
rc
=
sqlite3_blob_open
(
pConfig
-
>
db
pConfig
-
>
zDb
p
-
>
zDataTbl
"
block
"
FTS5_STRUCTURE_ROWID
1
&
pBlob
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_blob_write
(
pBlob
aCookie
4
0
)
;
rc
=
sqlite3_blob_close
(
pBlob
)
;
}
return
rc
;
}
static
int
sqlite3Fts5IndexLoadConfig
(
Fts5Index
*
p
)
{
Fts5Structure
*
pStruct
;
pStruct
=
fts5StructureRead
(
p
)
;
fts5StructureRelease
(
pStruct
)
;
return
fts5IndexReturn
(
p
)
;
}
static
int
sqlite3Fts5IndexGetOrigin
(
Fts5Index
*
p
i64
*
piOrigin
)
{
Fts5Structure
*
pStruct
;
pStruct
=
fts5StructureRead
(
p
)
;
if
(
pStruct
)
{
*
piOrigin
=
pStruct
-
>
nOriginCntr
;
fts5StructureRelease
(
pStruct
)
;
}
return
fts5IndexReturn
(
p
)
;
}
static
int
fts5IndexTombstoneAddToPage
(
Fts5Data
*
pPg
int
bForce
int
nPg
u64
iRowid
)
{
const
int
szKey
=
TOMBSTONE_KEYSIZE
(
pPg
)
;
const
int
nSlot
=
TOMBSTONE_NSLOT
(
pPg
)
;
const
int
nElem
=
fts5GetU32
(
&
pPg
-
>
p
[
4
]
)
;
int
iSlot
=
(
iRowid
/
nPg
)
%
nSlot
;
int
nCollide
=
nSlot
;
if
(
szKey
=
=
4
&
&
iRowid
>
0xFFFFFFFF
)
return
2
;
if
(
iRowid
=
=
0
)
{
pPg
-
>
p
[
1
]
=
0x01
;
return
0
;
}
if
(
bForce
=
=
0
&
&
nElem
>
=
(
nSlot
/
2
)
)
{
return
1
;
}
fts5PutU32
(
&
pPg
-
>
p
[
4
]
nElem
+
1
)
;
if
(
szKey
=
=
4
)
{
u32
*
aSlot
=
(
u32
*
)
&
pPg
-
>
p
[
8
]
;
while
(
aSlot
[
iSlot
]
)
{
iSlot
=
(
iSlot
+
1
)
%
nSlot
;
if
(
nCollide
-
-
=
=
0
)
return
0
;
}
fts5PutU32
(
(
u8
*
)
&
aSlot
[
iSlot
]
(
u32
)
iRowid
)
;
}
else
{
u64
*
aSlot
=
(
u64
*
)
&
pPg
-
>
p
[
8
]
;
while
(
aSlot
[
iSlot
]
)
{
iSlot
=
(
iSlot
+
1
)
%
nSlot
;
if
(
nCollide
-
-
=
=
0
)
return
0
;
}
fts5PutU64
(
(
u8
*
)
&
aSlot
[
iSlot
]
iRowid
)
;
}
return
0
;
}
static
int
fts5IndexTombstoneRehash
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
Fts5Data
*
pData1
int
iPg1
int
szKey
int
nOut
Fts5Data
*
*
apOut
)
{
int
ii
;
int
res
=
0
;
for
(
ii
=
0
;
ii
<
nOut
;
ii
+
+
)
{
apOut
[
ii
]
-
>
p
[
0
]
=
szKey
;
fts5PutU32
(
&
apOut
[
ii
]
-
>
p
[
4
]
0
)
;
}
for
(
ii
=
0
;
res
=
=
0
&
&
ii
<
pSeg
-
>
nPgTombstone
;
ii
+
+
)
{
Fts5Data
*
pData
=
0
;
Fts5Data
*
pFree
=
0
;
if
(
iPg1
=
=
ii
)
{
pData
=
pData1
;
}
else
{
pFree
=
pData
=
fts5DataRead
(
p
FTS5_TOMBSTONE_ROWID
(
pSeg
-
>
iSegid
ii
)
)
;
}
if
(
pData
)
{
int
szKeyIn
=
TOMBSTONE_KEYSIZE
(
pData
)
;
int
nSlotIn
=
(
pData
-
>
nn
-
8
)
/
szKeyIn
;
int
iIn
;
for
(
iIn
=
0
;
iIn
<
nSlotIn
;
iIn
+
+
)
{
u64
iVal
=
0
;
if
(
szKeyIn
=
=
4
)
{
u32
*
aSlot
=
(
u32
*
)
&
pData
-
>
p
[
8
]
;
if
(
aSlot
[
iIn
]
)
iVal
=
fts5GetU32
(
(
u8
*
)
&
aSlot
[
iIn
]
)
;
}
else
{
u64
*
aSlot
=
(
u64
*
)
&
pData
-
>
p
[
8
]
;
if
(
aSlot
[
iIn
]
)
iVal
=
fts5GetU64
(
(
u8
*
)
&
aSlot
[
iIn
]
)
;
}
if
(
iVal
)
{
Fts5Data
*
pPg
=
apOut
[
(
iVal
%
nOut
)
]
;
res
=
fts5IndexTombstoneAddToPage
(
pPg
0
nOut
iVal
)
;
if
(
res
)
break
;
}
}
if
(
ii
=
=
0
)
{
apOut
[
0
]
-
>
p
[
1
]
=
pData
-
>
p
[
1
]
;
}
}
fts5DataRelease
(
pFree
)
;
}
return
res
;
}
static
void
fts5IndexTombstoneRebuild
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
Fts5Data
*
pData1
int
iPg1
int
szKey
int
*
pnOut
Fts5Data
*
*
*
papOut
)
{
const
int
MINSLOT
=
32
;
int
nSlotPerPage
=
MAX
(
MINSLOT
(
p
-
>
pConfig
-
>
pgsz
-
8
)
/
szKey
)
;
int
nSlot
=
0
;
int
nOut
=
0
;
if
(
pSeg
-
>
nPgTombstone
=
=
0
)
{
nOut
=
1
;
nSlot
=
MINSLOT
;
}
else
if
(
pSeg
-
>
nPgTombstone
=
=
1
)
{
int
nElem
=
(
int
)
fts5GetU32
(
&
pData1
-
>
p
[
4
]
)
;
assert
(
pData1
&
&
iPg1
=
=
0
)
;
nOut
=
1
;
nSlot
=
MAX
(
nElem
*
4
MINSLOT
)
;
if
(
nSlot
>
nSlotPerPage
)
nOut
=
0
;
}
if
(
nOut
=
=
0
)
{
nOut
=
(
pSeg
-
>
nPgTombstone
*
2
+
1
)
;
nSlot
=
nSlotPerPage
;
}
while
(
1
)
{
int
res
=
0
;
int
ii
=
0
;
int
szPage
=
0
;
Fts5Data
*
*
apOut
=
0
;
assert
(
nSlot
>
=
MINSLOT
)
;
apOut
=
(
Fts5Data
*
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
sizeof
(
Fts5Data
*
)
*
nOut
)
;
szPage
=
8
+
nSlot
*
szKey
;
for
(
ii
=
0
;
ii
<
nOut
;
ii
+
+
)
{
Fts5Data
*
pNew
=
(
Fts5Data
*
)
sqlite3Fts5MallocZero
(
&
p
-
>
rc
sizeof
(
Fts5Data
)
+
szPage
)
;
if
(
pNew
)
{
pNew
-
>
nn
=
szPage
;
pNew
-
>
p
=
(
u8
*
)
&
pNew
[
1
]
;
apOut
[
ii
]
=
pNew
;
}
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
res
=
fts5IndexTombstoneRehash
(
p
pSeg
pData1
iPg1
szKey
nOut
apOut
)
;
}
if
(
res
=
=
0
)
{
if
(
p
-
>
rc
)
{
fts5IndexFreeArray
(
apOut
nOut
)
;
apOut
=
0
;
nOut
=
0
;
}
*
pnOut
=
nOut
;
*
papOut
=
apOut
;
break
;
}
assert
(
p
-
>
rc
=
=
SQLITE_OK
)
;
fts5IndexFreeArray
(
apOut
nOut
)
;
nSlot
=
nSlotPerPage
;
nOut
=
nOut
*
2
+
1
;
}
}
static
void
fts5IndexTombstoneAdd
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
u64
iRowid
)
{
Fts5Data
*
pPg
=
0
;
int
iPg
=
-
1
;
int
szKey
=
0
;
int
nHash
=
0
;
Fts5Data
*
*
apHash
=
0
;
p
-
>
nContentlessDelete
+
+
;
if
(
pSeg
-
>
nPgTombstone
>
0
)
{
iPg
=
iRowid
%
pSeg
-
>
nPgTombstone
;
pPg
=
fts5DataRead
(
p
FTS5_TOMBSTONE_ROWID
(
pSeg
-
>
iSegid
iPg
)
)
;
if
(
pPg
=
=
0
)
{
assert
(
p
-
>
rc
!
=
SQLITE_OK
)
;
return
;
}
if
(
0
=
=
fts5IndexTombstoneAddToPage
(
pPg
0
pSeg
-
>
nPgTombstone
iRowid
)
)
{
fts5DataWrite
(
p
FTS5_TOMBSTONE_ROWID
(
pSeg
-
>
iSegid
iPg
)
pPg
-
>
p
pPg
-
>
nn
)
;
fts5DataRelease
(
pPg
)
;
return
;
}
}
szKey
=
pPg
?
TOMBSTONE_KEYSIZE
(
pPg
)
:
4
;
if
(
iRowid
>
0xFFFFFFFF
)
szKey
=
8
;
fts5IndexTombstoneRebuild
(
p
pSeg
pPg
iPg
szKey
&
nHash
&
apHash
)
;
assert
(
p
-
>
rc
=
=
SQLITE_OK
|
|
(
nHash
=
=
0
&
&
apHash
=
=
0
)
)
;
if
(
nHash
)
{
int
ii
=
0
;
fts5IndexTombstoneAddToPage
(
apHash
[
iRowid
%
nHash
]
1
nHash
iRowid
)
;
for
(
ii
=
0
;
ii
<
nHash
;
ii
+
+
)
{
i64
iTombstoneRowid
=
FTS5_TOMBSTONE_ROWID
(
pSeg
-
>
iSegid
ii
)
;
fts5DataWrite
(
p
iTombstoneRowid
apHash
[
ii
]
-
>
p
apHash
[
ii
]
-
>
nn
)
;
}
pSeg
-
>
nPgTombstone
=
nHash
;
fts5StructureWrite
(
p
p
-
>
pStruct
)
;
}
fts5DataRelease
(
pPg
)
;
fts5IndexFreeArray
(
apHash
nHash
)
;
}
static
int
sqlite3Fts5IndexContentlessDelete
(
Fts5Index
*
p
i64
iOrigin
i64
iRowid
)
{
Fts5Structure
*
pStruct
;
pStruct
=
fts5StructureRead
(
p
)
;
if
(
pStruct
)
{
int
bFound
=
0
;
int
iLvl
;
for
(
iLvl
=
pStruct
-
>
nLevel
-
1
;
iLvl
>
=
0
;
iLvl
-
-
)
{
int
iSeg
;
for
(
iSeg
=
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
-
1
;
iSeg
>
=
0
;
iSeg
-
-
)
{
Fts5StructureSegment
*
pSeg
=
&
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
iSeg
]
;
if
(
pSeg
-
>
iOrigin1
<
=
(
u64
)
iOrigin
&
&
pSeg
-
>
iOrigin2
>
=
(
u64
)
iOrigin
)
{
if
(
bFound
=
=
0
)
{
pSeg
-
>
nEntryTombstone
+
+
;
bFound
=
1
;
}
fts5IndexTombstoneAdd
(
p
pSeg
iRowid
)
;
}
}
}
fts5StructureRelease
(
pStruct
)
;
}
return
fts5IndexReturn
(
p
)
;
}
static
u64
sqlite3Fts5IndexEntryCksum
(
i64
iRowid
int
iCol
int
iPos
int
iIdx
const
char
*
pTerm
int
nTerm
)
{
int
i
;
u64
ret
=
iRowid
;
ret
+
=
(
ret
<
<
3
)
+
iCol
;
ret
+
=
(
ret
<
<
3
)
+
iPos
;
if
(
iIdx
>
=
0
)
ret
+
=
(
ret
<
<
3
)
+
(
FTS5_MAIN_PREFIX
+
iIdx
)
;
for
(
i
=
0
;
i
<
nTerm
;
i
+
+
)
ret
+
=
(
ret
<
<
3
)
+
pTerm
[
i
]
;
return
ret
;
}
#
ifdef
SQLITE_DEBUG
static
void
fts5TestDlidxReverse
(
Fts5Index
*
p
int
iSegid
int
iLeaf
)
{
Fts5DlidxIter
*
pDlidx
=
0
;
u64
cksum1
=
13
;
u64
cksum2
=
13
;
for
(
pDlidx
=
fts5DlidxIterInit
(
p
0
iSegid
iLeaf
)
;
fts5DlidxIterEof
(
p
pDlidx
)
=
=
0
;
fts5DlidxIterNext
(
p
pDlidx
)
)
{
i64
iRowid
=
fts5DlidxIterRowid
(
pDlidx
)
;
int
pgno
=
fts5DlidxIterPgno
(
pDlidx
)
;
assert
(
pgno
>
iLeaf
)
;
cksum1
+
=
iRowid
+
(
(
i64
)
pgno
<
<
32
)
;
}
fts5DlidxIterFree
(
pDlidx
)
;
pDlidx
=
0
;
for
(
pDlidx
=
fts5DlidxIterInit
(
p
1
iSegid
iLeaf
)
;
fts5DlidxIterEof
(
p
pDlidx
)
=
=
0
;
fts5DlidxIterPrev
(
p
pDlidx
)
)
{
i64
iRowid
=
fts5DlidxIterRowid
(
pDlidx
)
;
int
pgno
=
fts5DlidxIterPgno
(
pDlidx
)
;
assert
(
fts5DlidxIterPgno
(
pDlidx
)
>
iLeaf
)
;
cksum2
+
=
iRowid
+
(
(
i64
)
pgno
<
<
32
)
;
}
fts5DlidxIterFree
(
pDlidx
)
;
pDlidx
=
0
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
cksum1
!
=
cksum2
)
p
-
>
rc
=
FTS5_CORRUPT
;
}
static
int
fts5QueryCksum
(
Fts5Index
*
p
int
iIdx
const
char
*
z
int
n
int
flags
u64
*
pCksum
)
{
int
eDetail
=
p
-
>
pConfig
-
>
eDetail
;
u64
cksum
=
*
pCksum
;
Fts5IndexIter
*
pIter
=
0
;
int
rc
=
sqlite3Fts5IndexQuery
(
p
z
n
(
flags
|
FTS5INDEX_QUERY_NOTOKENDATA
)
0
&
pIter
)
;
while
(
rc
=
=
SQLITE_OK
&
&
ALWAYS
(
pIter
!
=
0
)
&
&
0
=
=
sqlite3Fts5IterEof
(
pIter
)
)
{
i64
rowid
=
pIter
-
>
iRowid
;
if
(
eDetail
=
=
FTS5_DETAIL_NONE
)
{
cksum
^
=
sqlite3Fts5IndexEntryCksum
(
rowid
0
0
iIdx
z
n
)
;
}
else
{
Fts5PoslistReader
sReader
;
for
(
sqlite3Fts5PoslistReaderInit
(
pIter
-
>
pData
pIter
-
>
nData
&
sReader
)
;
sReader
.
bEof
=
=
0
;
sqlite3Fts5PoslistReaderNext
(
&
sReader
)
)
{
int
iCol
=
FTS5_POS2COLUMN
(
sReader
.
iPos
)
;
int
iOff
=
FTS5_POS2OFFSET
(
sReader
.
iPos
)
;
cksum
^
=
sqlite3Fts5IndexEntryCksum
(
rowid
iCol
iOff
iIdx
z
n
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IterNext
(
pIter
)
;
}
}
fts5IterClose
(
pIter
)
;
*
pCksum
=
cksum
;
return
rc
;
}
static
int
fts5TestUtf8
(
const
char
*
z
int
n
)
{
int
i
=
0
;
assert_nc
(
n
>
0
)
;
while
(
i
<
n
)
{
if
(
(
z
[
i
]
&
0x80
)
=
=
0x00
)
{
i
+
+
;
}
else
if
(
(
z
[
i
]
&
0xE0
)
=
=
0xC0
)
{
if
(
i
+
1
>
=
n
|
|
(
z
[
i
+
1
]
&
0xC0
)
!
=
0x80
)
return
1
;
i
+
=
2
;
}
else
if
(
(
z
[
i
]
&
0xF0
)
=
=
0xE0
)
{
if
(
i
+
2
>
=
n
|
|
(
z
[
i
+
1
]
&
0xC0
)
!
=
0x80
|
|
(
z
[
i
+
2
]
&
0xC0
)
!
=
0x80
)
return
1
;
i
+
=
3
;
}
else
if
(
(
z
[
i
]
&
0xF8
)
=
=
0xF0
)
{
if
(
i
+
3
>
=
n
|
|
(
z
[
i
+
1
]
&
0xC0
)
!
=
0x80
|
|
(
z
[
i
+
2
]
&
0xC0
)
!
=
0x80
)
return
1
;
if
(
(
z
[
i
+
2
]
&
0xC0
)
!
=
0x80
)
return
1
;
i
+
=
3
;
}
else
{
return
1
;
}
}
return
0
;
}
static
void
fts5TestTerm
(
Fts5Index
*
p
Fts5Buffer
*
pPrev
const
char
*
z
int
n
u64
expected
u64
*
pCksum
)
{
int
rc
=
p
-
>
rc
;
if
(
pPrev
-
>
n
=
=
0
)
{
fts5BufferSet
(
&
rc
pPrev
n
(
const
u8
*
)
z
)
;
}
else
if
(
rc
=
=
SQLITE_OK
&
&
(
pPrev
-
>
n
!
=
n
|
|
memcmp
(
pPrev
-
>
p
z
n
)
)
)
{
u64
cksum3
=
*
pCksum
;
const
char
*
zTerm
=
(
const
char
*
)
&
pPrev
-
>
p
[
1
]
;
int
nTerm
=
pPrev
-
>
n
-
1
;
int
iIdx
=
(
pPrev
-
>
p
[
0
]
-
FTS5_MAIN_PREFIX
)
;
int
flags
=
(
iIdx
=
=
0
?
0
:
FTS5INDEX_QUERY_PREFIX
)
;
u64
ck1
=
0
;
u64
ck2
=
0
;
rc
=
fts5QueryCksum
(
p
iIdx
zTerm
nTerm
flags
&
ck1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
int
f
=
flags
|
FTS5INDEX_QUERY_DESC
;
rc
=
fts5QueryCksum
(
p
iIdx
zTerm
nTerm
f
&
ck2
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
ck1
!
=
ck2
)
rc
=
FTS5_CORRUPT
;
if
(
p
-
>
nPendingData
=
=
0
&
&
0
=
=
fts5TestUtf8
(
zTerm
nTerm
)
)
{
if
(
iIdx
>
0
&
&
rc
=
=
SQLITE_OK
)
{
int
f
=
flags
|
FTS5INDEX_QUERY_TEST_NOIDX
;
ck2
=
0
;
rc
=
fts5QueryCksum
(
p
iIdx
zTerm
nTerm
f
&
ck2
)
;
if
(
rc
=
=
SQLITE_OK
&
&
ck1
!
=
ck2
)
rc
=
FTS5_CORRUPT
;
}
if
(
iIdx
>
0
&
&
rc
=
=
SQLITE_OK
)
{
int
f
=
flags
|
FTS5INDEX_QUERY_TEST_NOIDX
|
FTS5INDEX_QUERY_DESC
;
ck2
=
0
;
rc
=
fts5QueryCksum
(
p
iIdx
zTerm
nTerm
f
&
ck2
)
;
if
(
rc
=
=
SQLITE_OK
&
&
ck1
!
=
ck2
)
rc
=
FTS5_CORRUPT
;
}
}
cksum3
^
=
ck1
;
fts5BufferSet
(
&
rc
pPrev
n
(
const
u8
*
)
z
)
;
if
(
rc
=
=
SQLITE_OK
&
&
cksum3
!
=
expected
)
{
rc
=
FTS5_CORRUPT
;
}
*
pCksum
=
cksum3
;
}
p
-
>
rc
=
rc
;
}
#
else
#
define
fts5TestDlidxReverse
(
x
y
z
)
#
define
fts5TestTerm
(
u
v
w
x
y
z
)
#
endif
static
void
fts5IndexIntegrityCheckEmpty
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
int
iFirst
int
iNoRowid
int
iLast
)
{
int
i
;
for
(
i
=
iFirst
;
p
-
>
rc
=
=
SQLITE_OK
&
&
i
<
=
iLast
;
i
+
+
)
{
Fts5Data
*
pLeaf
=
fts5DataRead
(
p
FTS5_SEGMENT_ROWID
(
pSeg
-
>
iSegid
i
)
)
;
if
(
pLeaf
)
{
if
(
!
fts5LeafIsTermless
(
pLeaf
)
)
p
-
>
rc
=
FTS5_CORRUPT
;
if
(
i
>
=
iNoRowid
&
&
0
!
=
fts5LeafFirstRowidOff
(
pLeaf
)
)
p
-
>
rc
=
FTS5_CORRUPT
;
}
fts5DataRelease
(
pLeaf
)
;
}
}
static
void
fts5IntegrityCheckPgidx
(
Fts5Index
*
p
Fts5Data
*
pLeaf
)
{
i64
iTermOff
=
0
;
int
ii
;
Fts5Buffer
buf1
=
{
0
0
0
}
;
Fts5Buffer
buf2
=
{
0
0
0
}
;
ii
=
pLeaf
-
>
szLeaf
;
while
(
ii
<
pLeaf
-
>
nn
&
&
p
-
>
rc
=
=
SQLITE_OK
)
{
int
res
;
i64
iOff
;
int
nIncr
;
ii
+
=
fts5GetVarint32
(
&
pLeaf
-
>
p
[
ii
]
nIncr
)
;
iTermOff
+
=
nIncr
;
iOff
=
iTermOff
;
if
(
iOff
>
=
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
if
(
iTermOff
=
=
nIncr
)
{
int
nByte
;
iOff
+
=
fts5GetVarint32
(
&
pLeaf
-
>
p
[
iOff
]
nByte
)
;
if
(
(
iOff
+
nByte
)
>
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
fts5BufferSet
(
&
p
-
>
rc
&
buf1
nByte
&
pLeaf
-
>
p
[
iOff
]
)
;
}
}
else
{
int
nKeep
nByte
;
iOff
+
=
fts5GetVarint32
(
&
pLeaf
-
>
p
[
iOff
]
nKeep
)
;
iOff
+
=
fts5GetVarint32
(
&
pLeaf
-
>
p
[
iOff
]
nByte
)
;
if
(
nKeep
>
buf1
.
n
|
|
(
iOff
+
nByte
)
>
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
buf1
.
n
=
nKeep
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
buf1
nByte
&
pLeaf
-
>
p
[
iOff
]
)
;
}
if
(
p
-
>
rc
=
=
SQLITE_OK
)
{
res
=
fts5BufferCompare
(
&
buf1
&
buf2
)
;
if
(
res
<
=
0
)
p
-
>
rc
=
FTS5_CORRUPT
;
}
}
fts5BufferSet
(
&
p
-
>
rc
&
buf2
buf1
.
n
buf1
.
p
)
;
}
fts5BufferFree
(
&
buf1
)
;
fts5BufferFree
(
&
buf2
)
;
}
static
void
fts5IndexIntegrityCheckSegment
(
Fts5Index
*
p
Fts5StructureSegment
*
pSeg
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
bSecureDelete
=
(
pConfig
-
>
iVersion
=
=
FTS5_CURRENT_VERSION_SECUREDELETE
)
;
sqlite3_stmt
*
pStmt
=
0
;
int
rc2
;
int
iIdxPrevLeaf
=
pSeg
-
>
pgnoFirst
-
1
;
int
iDlidxPrevLeaf
=
pSeg
-
>
pgnoLast
;
if
(
pSeg
-
>
pgnoFirst
=
=
0
)
return
;
fts5IndexPrepareStmt
(
p
&
pStmt
sqlite3_mprintf
(
"
SELECT
segid
term
(
pgno
>
>
1
)
(
pgno
&
1
)
FROM
%
Q
.
'
%
q_idx
'
WHERE
segid
=
%
d
"
"
ORDER
BY
1
2
"
pConfig
-
>
zDb
pConfig
-
>
zName
pSeg
-
>
iSegid
)
)
;
while
(
p
-
>
rc
=
=
SQLITE_OK
&
&
SQLITE_ROW
=
=
sqlite3_step
(
pStmt
)
)
{
i64
iRow
;
Fts5Data
*
pLeaf
;
const
char
*
zIdxTerm
=
(
const
char
*
)
sqlite3_column_blob
(
pStmt
1
)
;
int
nIdxTerm
=
sqlite3_column_bytes
(
pStmt
1
)
;
int
iIdxLeaf
=
sqlite3_column_int
(
pStmt
2
)
;
int
bIdxDlidx
=
sqlite3_column_int
(
pStmt
3
)
;
if
(
iIdxLeaf
<
pSeg
-
>
pgnoFirst
)
continue
;
iRow
=
FTS5_SEGMENT_ROWID
(
pSeg
-
>
iSegid
iIdxLeaf
)
;
pLeaf
=
fts5LeafRead
(
p
iRow
)
;
if
(
pLeaf
=
=
0
)
break
;
if
(
pLeaf
-
>
nn
<
=
pLeaf
-
>
szLeaf
)
{
if
(
nIdxTerm
=
=
0
&
&
pConfig
-
>
iVersion
=
=
FTS5_CURRENT_VERSION_SECUREDELETE
&
&
pLeaf
-
>
nn
=
=
pLeaf
-
>
szLeaf
&
&
pLeaf
-
>
nn
=
=
4
)
{
}
else
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
}
else
{
int
iOff
;
int
iRowidOff
;
int
nTerm
;
int
res
;
iOff
=
fts5LeafFirstTermOff
(
pLeaf
)
;
iRowidOff
=
fts5LeafFirstRowidOff
(
pLeaf
)
;
if
(
iRowidOff
>
=
iOff
|
|
iOff
>
=
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
{
iOff
+
=
fts5GetVarint32
(
&
pLeaf
-
>
p
[
iOff
]
nTerm
)
;
res
=
fts5Memcmp
(
&
pLeaf
-
>
p
[
iOff
]
zIdxTerm
MIN
(
nTerm
nIdxTerm
)
)
;
if
(
res
=
=
0
)
res
=
nTerm
-
nIdxTerm
;
if
(
res
<
0
)
p
-
>
rc
=
FTS5_CORRUPT
;
}
fts5IntegrityCheckPgidx
(
p
pLeaf
)
;
}
fts5DataRelease
(
pLeaf
)
;
if
(
p
-
>
rc
)
break
;
fts5IndexIntegrityCheckEmpty
(
p
pSeg
iIdxPrevLeaf
+
1
iDlidxPrevLeaf
+
1
iIdxLeaf
-
1
)
;
if
(
p
-
>
rc
)
break
;
if
(
bIdxDlidx
)
{
Fts5DlidxIter
*
pDlidx
=
0
;
int
iPrevLeaf
=
iIdxLeaf
;
int
iSegid
=
pSeg
-
>
iSegid
;
int
iPg
=
0
;
i64
iKey
;
for
(
pDlidx
=
fts5DlidxIterInit
(
p
0
iSegid
iIdxLeaf
)
;
fts5DlidxIterEof
(
p
pDlidx
)
=
=
0
;
fts5DlidxIterNext
(
p
pDlidx
)
)
{
for
(
iPg
=
iPrevLeaf
+
1
;
iPg
<
fts5DlidxIterPgno
(
pDlidx
)
;
iPg
+
+
)
{
iKey
=
FTS5_SEGMENT_ROWID
(
iSegid
iPg
)
;
pLeaf
=
fts5DataRead
(
p
iKey
)
;
if
(
pLeaf
)
{
if
(
fts5LeafFirstRowidOff
(
pLeaf
)
!
=
0
)
p
-
>
rc
=
FTS5_CORRUPT
;
fts5DataRelease
(
pLeaf
)
;
}
}
iPrevLeaf
=
fts5DlidxIterPgno
(
pDlidx
)
;
iKey
=
FTS5_SEGMENT_ROWID
(
iSegid
iPrevLeaf
)
;
pLeaf
=
fts5DataRead
(
p
iKey
)
;
if
(
pLeaf
)
{
i64
iRowid
;
int
iRowidOff
=
fts5LeafFirstRowidOff
(
pLeaf
)
;
ASSERT_SZLEAF_OK
(
pLeaf
)
;
if
(
iRowidOff
>
=
pLeaf
-
>
szLeaf
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
else
if
(
bSecureDelete
=
=
0
|
|
iRowidOff
>
0
)
{
i64
iDlRowid
=
fts5DlidxIterRowid
(
pDlidx
)
;
fts5GetVarint
(
&
pLeaf
-
>
p
[
iRowidOff
]
(
u64
*
)
&
iRowid
)
;
if
(
iRowid
<
iDlRowid
|
|
(
bSecureDelete
=
=
0
&
&
iRowid
!
=
iDlRowid
)
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
}
fts5DataRelease
(
pLeaf
)
;
}
}
iDlidxPrevLeaf
=
iPg
;
fts5DlidxIterFree
(
pDlidx
)
;
fts5TestDlidxReverse
(
p
iSegid
iIdxLeaf
)
;
}
else
{
iDlidxPrevLeaf
=
pSeg
-
>
pgnoLast
;
}
iIdxPrevLeaf
=
iIdxLeaf
;
}
rc2
=
sqlite3_finalize
(
pStmt
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
)
p
-
>
rc
=
rc2
;
#
if
0
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
iter
.
iLeaf
!
=
pSeg
-
>
pgnoLast
)
{
p
-
>
rc
=
FTS5_CORRUPT
;
}
#
endif
}
static
int
sqlite3Fts5IndexIntegrityCheck
(
Fts5Index
*
p
u64
cksum
int
bUseCksum
)
{
int
eDetail
=
p
-
>
pConfig
-
>
eDetail
;
u64
cksum2
=
0
;
Fts5Buffer
poslist
=
{
0
0
0
}
;
Fts5Iter
*
pIter
;
Fts5Structure
*
pStruct
;
int
iLvl
iSeg
;
#
ifdef
SQLITE_DEBUG
u64
cksum3
=
0
;
Fts5Buffer
term
=
{
0
0
0
}
;
#
endif
const
int
flags
=
FTS5INDEX_QUERY_NOOUTPUT
;
pStruct
=
fts5StructureRead
(
p
)
;
if
(
pStruct
=
=
0
)
{
assert
(
p
-
>
rc
!
=
SQLITE_OK
)
;
return
fts5IndexReturn
(
p
)
;
}
for
(
iLvl
=
0
;
iLvl
<
pStruct
-
>
nLevel
;
iLvl
+
+
)
{
for
(
iSeg
=
0
;
iSeg
<
pStruct
-
>
aLevel
[
iLvl
]
.
nSeg
;
iSeg
+
+
)
{
Fts5StructureSegment
*
pSeg
=
&
pStruct
-
>
aLevel
[
iLvl
]
.
aSeg
[
iSeg
]
;
fts5IndexIntegrityCheckSegment
(
p
pSeg
)
;
}
}
for
(
fts5MultiIterNew
(
p
pStruct
flags
0
0
0
-
1
0
&
pIter
)
;
fts5MultiIterEof
(
p
pIter
)
=
=
0
;
fts5MultiIterNext
(
p
pIter
0
0
)
)
{
int
n
;
i64
iPos
=
0
;
int
iOff
=
0
;
i64
iRowid
=
fts5MultiIterRowid
(
pIter
)
;
char
*
z
=
(
char
*
)
fts5MultiIterTerm
(
pIter
&
n
)
;
fts5TestTerm
(
p
&
term
z
n
cksum2
&
cksum3
)
;
if
(
p
-
>
rc
)
break
;
if
(
eDetail
=
=
FTS5_DETAIL_NONE
)
{
if
(
0
=
=
fts5MultiIterIsEmpty
(
p
pIter
)
)
{
cksum2
^
=
sqlite3Fts5IndexEntryCksum
(
iRowid
0
0
-
1
z
n
)
;
}
}
else
{
poslist
.
n
=
0
;
fts5SegiterPoslist
(
p
&
pIter
-
>
aSeg
[
pIter
-
>
aFirst
[
1
]
.
iFirst
]
0
&
poslist
)
;
fts5BufferAppendBlob
(
&
p
-
>
rc
&
poslist
4
(
const
u8
*
)
"
\
0
\
0
\
0
\
0
"
)
;
while
(
0
=
=
sqlite3Fts5PoslistNext64
(
poslist
.
p
poslist
.
n
&
iOff
&
iPos
)
)
{
int
iCol
=
FTS5_POS2COLUMN
(
iPos
)
;
int
iTokOff
=
FTS5_POS2OFFSET
(
iPos
)
;
cksum2
^
=
sqlite3Fts5IndexEntryCksum
(
iRowid
iCol
iTokOff
-
1
z
n
)
;
}
}
}
fts5TestTerm
(
p
&
term
0
0
cksum2
&
cksum3
)
;
fts5MultiIterFree
(
pIter
)
;
if
(
p
-
>
rc
=
=
SQLITE_OK
&
&
bUseCksum
&
&
cksum
!
=
cksum2
)
p
-
>
rc
=
FTS5_CORRUPT
;
fts5StructureRelease
(
pStruct
)
;
#
ifdef
SQLITE_DEBUG
fts5BufferFree
(
&
term
)
;
#
endif
fts5BufferFree
(
&
poslist
)
;
return
fts5IndexReturn
(
p
)
;
}
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DecodeRowid
(
i64
iRowid
int
*
pbTombstone
int
*
piSegid
int
*
pbDlidx
int
*
piHeight
int
*
piPgno
)
{
*
piPgno
=
(
int
)
(
iRowid
&
(
(
(
i64
)
1
<
<
FTS5_DATA_PAGE_B
)
-
1
)
)
;
iRowid
>
>
=
FTS5_DATA_PAGE_B
;
*
piHeight
=
(
int
)
(
iRowid
&
(
(
(
i64
)
1
<
<
FTS5_DATA_HEIGHT_B
)
-
1
)
)
;
iRowid
>
>
=
FTS5_DATA_HEIGHT_B
;
*
pbDlidx
=
(
int
)
(
iRowid
&
0x0001
)
;
iRowid
>
>
=
FTS5_DATA_DLI_B
;
*
piSegid
=
(
int
)
(
iRowid
&
(
(
(
i64
)
1
<
<
FTS5_DATA_ID_B
)
-
1
)
)
;
iRowid
>
>
=
FTS5_DATA_ID_B
;
*
pbTombstone
=
(
int
)
(
iRowid
&
0x0001
)
;
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DebugRowid
(
int
*
pRc
Fts5Buffer
*
pBuf
i64
iKey
)
{
int
iSegid
iHeight
iPgno
bDlidx
bTomb
;
fts5DecodeRowid
(
iKey
&
bTomb
&
iSegid
&
bDlidx
&
iHeight
&
iPgno
)
;
if
(
iSegid
=
=
0
)
{
if
(
iKey
=
=
FTS5_AVERAGES_ROWID
)
{
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
{
averages
}
"
)
;
}
else
{
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
{
structure
}
"
)
;
}
}
else
{
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
{
%
s
%
ssegid
=
%
d
h
=
%
d
pgno
=
%
d
}
"
bDlidx
?
"
dlidx
"
:
"
"
bTomb
?
"
tombstone
"
:
"
"
iSegid
iHeight
iPgno
)
;
}
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DebugStructure
(
int
*
pRc
Fts5Buffer
*
pBuf
Fts5Structure
*
p
)
{
int
iLvl
iSeg
;
for
(
iLvl
=
0
;
iLvl
<
p
-
>
nLevel
;
iLvl
+
+
)
{
Fts5StructureLevel
*
pLvl
=
&
p
-
>
aLevel
[
iLvl
]
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
{
lvl
=
%
d
nMerge
=
%
d
nSeg
=
%
d
"
iLvl
pLvl
-
>
nMerge
pLvl
-
>
nSeg
)
;
for
(
iSeg
=
0
;
iSeg
<
pLvl
-
>
nSeg
;
iSeg
+
+
)
{
Fts5StructureSegment
*
pSeg
=
&
pLvl
-
>
aSeg
[
iSeg
]
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
{
id
=
%
d
leaves
=
%
d
.
.
%
d
"
pSeg
-
>
iSegid
pSeg
-
>
pgnoFirst
pSeg
-
>
pgnoLast
)
;
if
(
pSeg
-
>
iOrigin1
>
0
)
{
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
origin
=
%
lld
.
.
%
lld
"
pSeg
-
>
iOrigin1
pSeg
-
>
iOrigin2
)
;
}
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
}
"
)
;
}
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
}
"
)
;
}
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DecodeStructure
(
int
*
pRc
Fts5Buffer
*
pBuf
const
u8
*
pBlob
int
nBlob
)
{
int
rc
;
Fts5Structure
*
p
=
0
;
rc
=
fts5StructureDecode
(
pBlob
nBlob
0
&
p
)
;
if
(
rc
!
=
SQLITE_OK
)
{
*
pRc
=
rc
;
return
;
}
fts5DebugStructure
(
pRc
pBuf
p
)
;
fts5StructureRelease
(
p
)
;
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DecodeAverages
(
int
*
pRc
Fts5Buffer
*
pBuf
const
u8
*
pBlob
int
nBlob
)
{
int
i
=
0
;
const
char
*
zSpace
=
"
"
;
while
(
i
<
nBlob
)
{
u64
iVal
;
i
+
=
sqlite3Fts5GetVarint
(
&
pBlob
[
i
]
&
iVal
)
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
%
s
%
d
"
zSpace
(
int
)
iVal
)
;
zSpace
=
"
"
;
}
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
int
fts5DecodePoslist
(
int
*
pRc
Fts5Buffer
*
pBuf
const
u8
*
a
int
n
)
{
int
iOff
=
0
;
while
(
iOff
<
n
)
{
int
iVal
;
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
iVal
)
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
%
d
"
iVal
)
;
}
return
iOff
;
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
int
fts5DecodeDoclist
(
int
*
pRc
Fts5Buffer
*
pBuf
const
u8
*
a
int
n
)
{
i64
iDocid
=
0
;
int
iOff
=
0
;
if
(
n
>
0
)
{
iOff
=
sqlite3Fts5GetVarint
(
a
(
u64
*
)
&
iDocid
)
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
id
=
%
lld
"
iDocid
)
;
}
while
(
iOff
<
n
)
{
int
nPos
;
int
bDel
;
iOff
+
=
fts5GetPoslistSize
(
&
a
[
iOff
]
&
nPos
&
bDel
)
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
nPos
=
%
d
%
s
"
nPos
bDel
?
"
*
"
:
"
"
)
;
iOff
+
=
fts5DecodePoslist
(
pRc
pBuf
&
a
[
iOff
]
MIN
(
n
-
iOff
nPos
)
)
;
if
(
iOff
<
n
)
{
i64
iDelta
;
iOff
+
=
sqlite3Fts5GetVarint
(
&
a
[
iOff
]
(
u64
*
)
&
iDelta
)
;
iDocid
+
=
iDelta
;
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
id
=
%
lld
"
iDocid
)
;
}
}
return
iOff
;
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DecodeRowidList
(
int
*
pRc
Fts5Buffer
*
pBuf
const
u8
*
pData
int
nData
)
{
int
i
=
0
;
i64
iRowid
=
0
;
while
(
i
<
nData
)
{
const
char
*
zApp
=
"
"
;
u64
iVal
;
i
+
=
sqlite3Fts5GetVarint
(
&
pData
[
i
]
&
iVal
)
;
iRowid
+
=
iVal
;
if
(
i
<
nData
&
&
pData
[
i
]
=
=
0x00
)
{
i
+
+
;
if
(
i
<
nData
&
&
pData
[
i
]
=
=
0x00
)
{
i
+
+
;
zApp
=
"
+
"
;
}
else
{
zApp
=
"
*
"
;
}
}
sqlite3Fts5BufferAppendPrintf
(
pRc
pBuf
"
%
lld
%
s
"
iRowid
zApp
)
;
}
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5BufferAppendTerm
(
int
*
pRc
Fts5Buffer
*
pBuf
Fts5Buffer
*
pTerm
)
{
int
ii
;
fts5BufferGrow
(
pRc
pBuf
pTerm
-
>
n
*
2
+
1
)
;
if
(
*
pRc
=
=
SQLITE_OK
)
{
for
(
ii
=
0
;
ii
<
pTerm
-
>
n
;
ii
+
+
)
{
if
(
pTerm
-
>
p
[
ii
]
=
=
0x00
)
{
pBuf
-
>
p
[
pBuf
-
>
n
+
+
]
=
'
\
\
'
;
pBuf
-
>
p
[
pBuf
-
>
n
+
+
]
=
'
0
'
;
}
else
{
pBuf
-
>
p
[
pBuf
-
>
n
+
+
]
=
pTerm
-
>
p
[
ii
]
;
}
}
pBuf
-
>
p
[
pBuf
-
>
n
]
=
0x00
;
}
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5DecodeFunction
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
)
{
i64
iRowid
;
int
iSegid
iHeight
iPgno
bDlidx
;
int
bTomb
;
const
u8
*
aBlob
;
int
n
;
u8
*
a
=
0
;
Fts5Buffer
s
;
int
rc
=
SQLITE_OK
;
sqlite3_int64
nSpace
=
0
;
int
eDetailNone
=
(
sqlite3_user_data
(
pCtx
)
!
=
0
)
;
assert
(
nArg
=
=
2
)
;
UNUSED_PARAM
(
nArg
)
;
memset
(
&
s
0
sizeof
(
Fts5Buffer
)
)
;
iRowid
=
sqlite3_value_int64
(
apVal
[
0
]
)
;
n
=
sqlite3_value_bytes
(
apVal
[
1
]
)
;
aBlob
=
sqlite3_value_blob
(
apVal
[
1
]
)
;
nSpace
=
n
+
FTS5_DATA_ZERO_PADDING
;
a
=
(
u8
*
)
sqlite3Fts5MallocZero
(
&
rc
nSpace
)
;
if
(
a
=
=
0
)
goto
decode_out
;
if
(
n
>
0
)
memcpy
(
a
aBlob
n
)
;
fts5DecodeRowid
(
iRowid
&
bTomb
&
iSegid
&
bDlidx
&
iHeight
&
iPgno
)
;
fts5DebugRowid
(
&
rc
&
s
iRowid
)
;
if
(
bDlidx
)
{
Fts5Data
dlidx
;
Fts5DlidxLvl
lvl
;
dlidx
.
p
=
a
;
dlidx
.
nn
=
n
;
memset
(
&
lvl
0
sizeof
(
Fts5DlidxLvl
)
)
;
lvl
.
pData
=
&
dlidx
;
lvl
.
iLeafPgno
=
iPgno
;
for
(
fts5DlidxLvlNext
(
&
lvl
)
;
lvl
.
bEof
=
=
0
;
fts5DlidxLvlNext
(
&
lvl
)
)
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
s
"
%
d
(
%
lld
)
"
lvl
.
iLeafPgno
lvl
.
iRowid
)
;
}
}
else
if
(
bTomb
)
{
u32
nElem
=
fts5GetU32
(
&
a
[
4
]
)
;
int
szKey
=
(
aBlob
[
0
]
=
=
4
|
|
aBlob
[
0
]
=
=
8
)
?
aBlob
[
0
]
:
8
;
int
nSlot
=
(
n
-
8
)
/
szKey
;
int
ii
;
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
s
"
nElem
=
%
d
"
(
int
)
nElem
)
;
if
(
aBlob
[
1
]
)
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
s
"
0
"
)
;
}
for
(
ii
=
0
;
ii
<
nSlot
;
ii
+
+
)
{
u64
iVal
=
0
;
if
(
szKey
=
=
4
)
{
u32
*
aSlot
=
(
u32
*
)
&
aBlob
[
8
]
;
if
(
aSlot
[
ii
]
)
iVal
=
fts5GetU32
(
(
u8
*
)
&
aSlot
[
ii
]
)
;
}
else
{
u64
*
aSlot
=
(
u64
*
)
&
aBlob
[
8
]
;
if
(
aSlot
[
ii
]
)
iVal
=
fts5GetU64
(
(
u8
*
)
&
aSlot
[
ii
]
)
;
}
if
(
iVal
!
=
0
)
{
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
s
"
%
lld
"
(
i64
)
iVal
)
;
}
}
}
else
if
(
iSegid
=
=
0
)
{
if
(
iRowid
=
=
FTS5_AVERAGES_ROWID
)
{
fts5DecodeAverages
(
&
rc
&
s
a
n
)
;
}
else
{
fts5DecodeStructure
(
&
rc
&
s
a
n
)
;
}
}
else
if
(
eDetailNone
)
{
Fts5Buffer
term
;
int
szLeaf
;
int
iPgidxOff
=
szLeaf
=
fts5GetU16
(
&
a
[
2
]
)
;
int
iTermOff
;
int
nKeep
=
0
;
int
iOff
;
memset
(
&
term
0
sizeof
(
Fts5Buffer
)
)
;
if
(
szLeaf
<
n
)
{
iPgidxOff
+
=
fts5GetVarint32
(
&
a
[
iPgidxOff
]
iTermOff
)
;
}
else
{
iTermOff
=
szLeaf
;
}
fts5DecodeRowidList
(
&
rc
&
s
&
a
[
4
]
iTermOff
-
4
)
;
iOff
=
iTermOff
;
while
(
iOff
<
szLeaf
&
&
rc
=
=
SQLITE_OK
)
{
int
nAppend
;
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nAppend
)
;
term
.
n
=
nKeep
;
fts5BufferAppendBlob
(
&
rc
&
term
nAppend
&
a
[
iOff
]
)
;
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
s
"
term
=
"
)
;
fts5BufferAppendTerm
(
&
rc
&
s
&
term
)
;
iOff
+
=
nAppend
;
if
(
iPgidxOff
<
n
)
{
int
nIncr
;
iPgidxOff
+
=
fts5GetVarint32
(
&
a
[
iPgidxOff
]
nIncr
)
;
iTermOff
+
=
nIncr
;
}
else
{
iTermOff
=
szLeaf
;
}
if
(
iTermOff
>
szLeaf
)
{
rc
=
FTS5_CORRUPT
;
}
else
{
fts5DecodeRowidList
(
&
rc
&
s
&
a
[
iOff
]
iTermOff
-
iOff
)
;
}
iOff
=
iTermOff
;
if
(
iOff
<
szLeaf
)
{
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nKeep
)
;
}
}
fts5BufferFree
(
&
term
)
;
}
else
{
Fts5Buffer
term
;
int
szLeaf
;
int
iPgidxOff
;
int
iPgidxPrev
=
0
;
int
iTermOff
=
0
;
int
iRowidOff
=
0
;
int
iOff
;
int
nDoclist
;
memset
(
&
term
0
sizeof
(
Fts5Buffer
)
)
;
if
(
n
<
4
)
{
sqlite3Fts5BufferSet
(
&
rc
&
s
7
(
const
u8
*
)
"
corrupt
"
)
;
goto
decode_out
;
}
else
{
iRowidOff
=
fts5GetU16
(
&
a
[
0
]
)
;
iPgidxOff
=
szLeaf
=
fts5GetU16
(
&
a
[
2
]
)
;
if
(
iPgidxOff
<
n
)
{
fts5GetVarint32
(
&
a
[
iPgidxOff
]
iTermOff
)
;
}
else
if
(
iPgidxOff
>
n
)
{
rc
=
FTS5_CORRUPT
;
goto
decode_out
;
}
}
if
(
iRowidOff
!
=
0
)
{
iOff
=
iRowidOff
;
}
else
if
(
iTermOff
!
=
0
)
{
iOff
=
iTermOff
;
}
else
{
iOff
=
szLeaf
;
}
if
(
iOff
>
n
)
{
rc
=
FTS5_CORRUPT
;
goto
decode_out
;
}
fts5DecodePoslist
(
&
rc
&
s
&
a
[
4
]
iOff
-
4
)
;
nDoclist
=
(
iTermOff
?
iTermOff
:
szLeaf
)
-
iOff
;
if
(
nDoclist
+
iOff
>
n
)
{
rc
=
FTS5_CORRUPT
;
goto
decode_out
;
}
fts5DecodeDoclist
(
&
rc
&
s
&
a
[
iOff
]
nDoclist
)
;
while
(
iPgidxOff
<
n
&
&
rc
=
=
SQLITE_OK
)
{
int
bFirst
=
(
iPgidxOff
=
=
szLeaf
)
;
int
nByte
;
int
iEnd
;
iPgidxOff
+
=
fts5GetVarint32
(
&
a
[
iPgidxOff
]
nByte
)
;
iPgidxPrev
+
=
nByte
;
iOff
=
iPgidxPrev
;
if
(
iPgidxOff
<
n
)
{
fts5GetVarint32
(
&
a
[
iPgidxOff
]
nByte
)
;
iEnd
=
iPgidxPrev
+
nByte
;
}
else
{
iEnd
=
szLeaf
;
}
if
(
iEnd
>
szLeaf
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
if
(
bFirst
=
=
0
)
{
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nByte
)
;
if
(
nByte
>
term
.
n
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
term
.
n
=
nByte
;
}
iOff
+
=
fts5GetVarint32
(
&
a
[
iOff
]
nByte
)
;
if
(
iOff
+
nByte
>
n
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
fts5BufferAppendBlob
(
&
rc
&
term
nByte
&
a
[
iOff
]
)
;
iOff
+
=
nByte
;
sqlite3Fts5BufferAppendPrintf
(
&
rc
&
s
"
term
=
"
)
;
fts5BufferAppendTerm
(
&
rc
&
s
&
term
)
;
iOff
+
=
fts5DecodeDoclist
(
&
rc
&
s
&
a
[
iOff
]
iEnd
-
iOff
)
;
}
fts5BufferFree
(
&
term
)
;
}
decode_out
:
sqlite3_free
(
a
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_result_text
(
pCtx
(
const
char
*
)
s
.
p
s
.
n
SQLITE_TRANSIENT
)
;
}
else
{
sqlite3_result_error_code
(
pCtx
rc
)
;
}
fts5BufferFree
(
&
s
)
;
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
static
void
fts5RowidFunction
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apVal
)
{
const
char
*
zArg
;
if
(
nArg
=
=
0
)
{
sqlite3_result_error
(
pCtx
"
should
be
:
fts5_rowid
(
subject
.
.
.
.
)
"
-
1
)
;
}
else
{
zArg
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
0
]
)
;
if
(
0
=
=
sqlite3_stricmp
(
zArg
"
segment
"
)
)
{
i64
iRowid
;
int
segid
pgno
;
if
(
nArg
!
=
3
)
{
sqlite3_result_error
(
pCtx
"
should
be
:
fts5_rowid
(
'
segment
'
segid
pgno
)
)
"
-
1
)
;
}
else
{
segid
=
sqlite3_value_int
(
apVal
[
1
]
)
;
pgno
=
sqlite3_value_int
(
apVal
[
2
]
)
;
iRowid
=
FTS5_SEGMENT_ROWID
(
segid
pgno
)
;
sqlite3_result_int64
(
pCtx
iRowid
)
;
}
}
else
{
sqlite3_result_error
(
pCtx
"
first
arg
to
fts5_rowid
(
)
must
be
'
segment
'
"
-
1
)
;
}
}
}
#
endif
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
typedef
struct
Fts5StructVtab
Fts5StructVtab
;
struct
Fts5StructVtab
{
sqlite3_vtab
base
;
}
;
typedef
struct
Fts5StructVcsr
Fts5StructVcsr
;
struct
Fts5StructVcsr
{
sqlite3_vtab_cursor
base
;
Fts5Structure
*
pStruct
;
int
iLevel
;
int
iSeg
;
int
iRowid
;
}
;
static
int
fts5structConnectMethod
(
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVtab
char
*
*
pzErr
)
{
Fts5StructVtab
*
pNew
=
0
;
int
rc
=
SQLITE_OK
;
rc
=
sqlite3_declare_vtab
(
db
"
CREATE
TABLE
xyz
(
"
"
level
segment
merge
segid
leaf1
leaf2
loc1
loc2
"
"
npgtombstone
nentrytombstone
nentry
struct
HIDDEN
)
;
"
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pNew
=
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
*
pNew
)
)
;
}
*
ppVtab
=
(
sqlite3_vtab
*
)
pNew
;
return
rc
;
}
static
int
fts5structBestIndexMethod
(
sqlite3_vtab
*
tab
sqlite3_index_info
*
pIdxInfo
)
{
int
i
;
int
rc
=
SQLITE_CONSTRAINT
;
struct
sqlite3_index_constraint
*
p
;
pIdxInfo
-
>
estimatedCost
=
(
double
)
100
;
pIdxInfo
-
>
estimatedRows
=
100
;
pIdxInfo
-
>
idxNum
=
0
;
for
(
i
=
0
p
=
pIdxInfo
-
>
aConstraint
;
i
<
pIdxInfo
-
>
nConstraint
;
i
+
+
p
+
+
)
{
if
(
p
-
>
usable
=
=
0
)
continue
;
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_EQ
&
&
p
-
>
iColumn
=
=
11
)
{
rc
=
SQLITE_OK
;
pIdxInfo
-
>
aConstraintUsage
[
i
]
.
omit
=
1
;
pIdxInfo
-
>
aConstraintUsage
[
i
]
.
argvIndex
=
1
;
break
;
}
}
return
rc
;
}
static
int
fts5structDisconnectMethod
(
sqlite3_vtab
*
pVtab
)
{
Fts5StructVtab
*
p
=
(
Fts5StructVtab
*
)
pVtab
;
sqlite3_free
(
p
)
;
return
SQLITE_OK
;
}
static
int
fts5structOpenMethod
(
sqlite3_vtab
*
p
sqlite3_vtab_cursor
*
*
ppCsr
)
{
int
rc
=
SQLITE_OK
;
Fts5StructVcsr
*
pNew
=
0
;
pNew
=
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
*
pNew
)
)
;
*
ppCsr
=
(
sqlite3_vtab_cursor
*
)
pNew
;
return
SQLITE_OK
;
}
static
int
fts5structCloseMethod
(
sqlite3_vtab_cursor
*
cur
)
{
Fts5StructVcsr
*
pCsr
=
(
Fts5StructVcsr
*
)
cur
;
fts5StructureRelease
(
pCsr
-
>
pStruct
)
;
sqlite3_free
(
pCsr
)
;
return
SQLITE_OK
;
}
static
int
fts5structNextMethod
(
sqlite3_vtab_cursor
*
cur
)
{
Fts5StructVcsr
*
pCsr
=
(
Fts5StructVcsr
*
)
cur
;
Fts5Structure
*
p
=
pCsr
-
>
pStruct
;
assert
(
pCsr
-
>
pStruct
)
;
pCsr
-
>
iSeg
+
+
;
pCsr
-
>
iRowid
+
+
;
while
(
pCsr
-
>
iLevel
<
p
-
>
nLevel
&
&
pCsr
-
>
iSeg
>
=
p
-
>
aLevel
[
pCsr
-
>
iLevel
]
.
nSeg
)
{
pCsr
-
>
iLevel
+
+
;
pCsr
-
>
iSeg
=
0
;
}
if
(
pCsr
-
>
iLevel
>
=
p
-
>
nLevel
)
{
fts5StructureRelease
(
pCsr
-
>
pStruct
)
;
pCsr
-
>
pStruct
=
0
;
}
return
SQLITE_OK
;
}
static
int
fts5structEofMethod
(
sqlite3_vtab_cursor
*
cur
)
{
Fts5StructVcsr
*
pCsr
=
(
Fts5StructVcsr
*
)
cur
;
return
pCsr
-
>
pStruct
=
=
0
;
}
static
int
fts5structRowidMethod
(
sqlite3_vtab_cursor
*
cur
sqlite_int64
*
piRowid
)
{
Fts5StructVcsr
*
pCsr
=
(
Fts5StructVcsr
*
)
cur
;
*
piRowid
=
pCsr
-
>
iRowid
;
return
SQLITE_OK
;
}
static
int
fts5structColumnMethod
(
sqlite3_vtab_cursor
*
cur
sqlite3_context
*
ctx
int
i
)
{
Fts5StructVcsr
*
pCsr
=
(
Fts5StructVcsr
*
)
cur
;
Fts5Structure
*
p
=
pCsr
-
>
pStruct
;
Fts5StructureSegment
*
pSeg
=
&
p
-
>
aLevel
[
pCsr
-
>
iLevel
]
.
aSeg
[
pCsr
-
>
iSeg
]
;
switch
(
i
)
{
case
0
:
sqlite3_result_int
(
ctx
pCsr
-
>
iLevel
)
;
break
;
case
1
:
sqlite3_result_int
(
ctx
pCsr
-
>
iSeg
)
;
break
;
case
2
:
sqlite3_result_int
(
ctx
pCsr
-
>
iSeg
<
p
-
>
aLevel
[
pCsr
-
>
iLevel
]
.
nMerge
)
;
break
;
case
3
:
sqlite3_result_int
(
ctx
pSeg
-
>
iSegid
)
;
break
;
case
4
:
sqlite3_result_int
(
ctx
pSeg
-
>
pgnoFirst
)
;
break
;
case
5
:
sqlite3_result_int
(
ctx
pSeg
-
>
pgnoLast
)
;
break
;
case
6
:
sqlite3_result_int64
(
ctx
pSeg
-
>
iOrigin1
)
;
break
;
case
7
:
sqlite3_result_int64
(
ctx
pSeg
-
>
iOrigin2
)
;
break
;
case
8
:
sqlite3_result_int
(
ctx
pSeg
-
>
nPgTombstone
)
;
break
;
case
9
:
sqlite3_result_int64
(
ctx
pSeg
-
>
nEntryTombstone
)
;
break
;
case
10
:
sqlite3_result_int64
(
ctx
pSeg
-
>
nEntry
)
;
break
;
}
return
SQLITE_OK
;
}
static
int
fts5structFilterMethod
(
sqlite3_vtab_cursor
*
pVtabCursor
int
idxNum
const
char
*
idxStr
int
argc
sqlite3_value
*
*
argv
)
{
Fts5StructVcsr
*
pCsr
=
(
Fts5StructVcsr
*
)
pVtabCursor
;
int
rc
=
SQLITE_OK
;
const
u8
*
aBlob
=
0
;
int
nBlob
=
0
;
assert
(
argc
=
=
1
)
;
fts5StructureRelease
(
pCsr
-
>
pStruct
)
;
pCsr
-
>
pStruct
=
0
;
nBlob
=
sqlite3_value_bytes
(
argv
[
0
]
)
;
aBlob
=
(
const
u8
*
)
sqlite3_value_blob
(
argv
[
0
]
)
;
rc
=
fts5StructureDecode
(
aBlob
nBlob
0
&
pCsr
-
>
pStruct
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pCsr
-
>
iLevel
=
0
;
pCsr
-
>
iRowid
=
0
;
pCsr
-
>
iSeg
=
-
1
;
rc
=
fts5structNextMethod
(
pVtabCursor
)
;
}
return
rc
;
}
#
endif
static
int
sqlite3Fts5IndexInit
(
sqlite3
*
db
)
{
#
if
defined
(
SQLITE_TEST
)
|
|
defined
(
SQLITE_FTS5_DEBUG
)
int
rc
=
sqlite3_create_function
(
db
"
fts5_decode
"
2
SQLITE_UTF8
0
fts5DecodeFunction
0
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_create_function
(
db
"
fts5_decode_none
"
2
SQLITE_UTF8
(
void
*
)
db
fts5DecodeFunction
0
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_create_function
(
db
"
fts5_rowid
"
-
1
SQLITE_UTF8
0
fts5RowidFunction
0
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
static
const
sqlite3_module
fts5structure_module
=
{
0
0
fts5structConnectMethod
fts5structBestIndexMethod
fts5structDisconnectMethod
0
fts5structOpenMethod
fts5structCloseMethod
fts5structFilterMethod
fts5structNextMethod
fts5structEofMethod
fts5structColumnMethod
fts5structRowidMethod
0
0
0
0
0
0
0
0
0
0
0
0
}
;
rc
=
sqlite3_create_module
(
db
"
fts5_structure
"
&
fts5structure_module
0
)
;
}
return
rc
;
#
else
return
SQLITE_OK
;
UNUSED_PARAM
(
db
)
;
#
endif
}
static
int
sqlite3Fts5IndexReset
(
Fts5Index
*
p
)
{
assert
(
p
-
>
pStruct
=
=
0
|
|
p
-
>
iStructVersion
!
=
0
)
;
if
(
fts5IndexDataVersion
(
p
)
!
=
p
-
>
iStructVersion
)
{
fts5StructureInvalidate
(
p
)
;
}
return
fts5IndexReturn
(
p
)
;
}
#
line
1
"
fts5_main
.
c
"
#
ifdef
SQLITE_DEBUG
int
sqlite3_fts5_may_be_corrupt
=
1
;
#
endif
typedef
struct
Fts5Auxdata
Fts5Auxdata
;
typedef
struct
Fts5Auxiliary
Fts5Auxiliary
;
typedef
struct
Fts5Cursor
Fts5Cursor
;
typedef
struct
Fts5FullTable
Fts5FullTable
;
typedef
struct
Fts5Sorter
Fts5Sorter
;
typedef
struct
Fts5TokenizerModule
Fts5TokenizerModule
;
struct
Fts5TransactionState
{
int
eState
;
int
iSavepoint
;
}
;
struct
Fts5Global
{
fts5_api
api
;
sqlite3
*
db
;
i64
iNextId
;
Fts5Auxiliary
*
pAux
;
Fts5TokenizerModule
*
pTok
;
Fts5TokenizerModule
*
pDfltTok
;
Fts5Cursor
*
pCsr
;
u32
aLocaleHdr
[
4
]
;
}
;
#
define
FTS5_LOCALE_HDR_SIZE
(
(
int
)
sizeof
(
(
(
Fts5Global
*
)
0
)
-
>
aLocaleHdr
)
)
#
define
FTS5_LOCALE_HDR
(
pConfig
)
(
(
const
u8
*
)
(
pConfig
-
>
pGlobal
-
>
aLocaleHdr
)
)
#
define
FTS5_INSTTOKEN_SUBTYPE
73
struct
Fts5Auxiliary
{
Fts5Global
*
pGlobal
;
char
*
zFunc
;
void
*
pUserData
;
fts5_extension_function
xFunc
;
void
(
*
xDestroy
)
(
void
*
)
;
Fts5Auxiliary
*
pNext
;
}
;
struct
Fts5TokenizerModule
{
char
*
zName
;
void
*
pUserData
;
int
bV2Native
;
fts5_tokenizer
x1
;
fts5_tokenizer_v2
x2
;
void
(
*
xDestroy
)
(
void
*
)
;
Fts5TokenizerModule
*
pNext
;
}
;
struct
Fts5FullTable
{
Fts5Table
p
;
Fts5Storage
*
pStorage
;
Fts5Global
*
pGlobal
;
Fts5Cursor
*
pSortCsr
;
int
iSavepoint
;
#
ifdef
SQLITE_DEBUG
struct
Fts5TransactionState
ts
;
#
endif
}
;
struct
Fts5MatchPhrase
{
Fts5Buffer
*
pPoslist
;
int
nTerm
;
}
;
struct
Fts5Sorter
{
sqlite3_stmt
*
pStmt
;
i64
iRowid
;
const
u8
*
aPoslist
;
int
nIdx
;
int
aIdx
[
1
]
;
}
;
struct
Fts5Cursor
{
sqlite3_vtab_cursor
base
;
Fts5Cursor
*
pNext
;
int
*
aColumnSize
;
i64
iCsrId
;
int
ePlan
;
int
bDesc
;
i64
iFirstRowid
;
i64
iLastRowid
;
sqlite3_stmt
*
pStmt
;
Fts5Expr
*
pExpr
;
Fts5Sorter
*
pSorter
;
int
csrflags
;
i64
iSpecial
;
char
*
zRank
;
char
*
zRankArgs
;
Fts5Auxiliary
*
pRank
;
int
nRankArg
;
sqlite3_value
*
*
apRankArg
;
sqlite3_stmt
*
pRankArgStmt
;
Fts5Auxiliary
*
pAux
;
Fts5Auxdata
*
pAuxdata
;
Fts5PoslistReader
*
aInstIter
;
int
nInstAlloc
;
int
nInstCount
;
int
*
aInst
;
}
;
#
define
FTS5_BI_MATCH
0x0001
/
*
<
tbl
>
MATCH
?
*
/
#
define
FTS5_BI_RANK
0x0002
/
*
rank
MATCH
?
*
/
#
define
FTS5_BI_ROWID_EQ
0x0004
/
*
rowid
=
=
?
*
/
#
define
FTS5_BI_ROWID_LE
0x0008
/
*
rowid
<
=
?
*
/
#
define
FTS5_BI_ROWID_GE
0x0010
/
*
rowid
>
=
?
*
/
#
define
FTS5_BI_ORDER_RANK
0x0020
#
define
FTS5_BI_ORDER_ROWID
0x0040
#
define
FTS5_BI_ORDER_DESC
0x0080
#
define
FTS5CSR_EOF
0x01
#
define
FTS5CSR_REQUIRE_CONTENT
0x02
#
define
FTS5CSR_REQUIRE_DOCSIZE
0x04
#
define
FTS5CSR_REQUIRE_INST
0x08
#
define
FTS5CSR_FREE_ZRANK
0x10
#
define
FTS5CSR_REQUIRE_RESEEK
0x20
#
define
FTS5CSR_REQUIRE_POSLIST
0x40
#
define
BitFlagAllTest
(
x
y
)
(
(
(
x
)
&
(
y
)
)
=
=
(
y
)
)
#
define
BitFlagTest
(
x
y
)
(
(
(
x
)
&
(
y
)
)
!
=
0
)
#
define
CsrFlagSet
(
pCsr
flag
)
(
(
pCsr
)
-
>
csrflags
|
=
(
flag
)
)
#
define
CsrFlagClear
(
pCsr
flag
)
(
(
pCsr
)
-
>
csrflags
&
=
~
(
flag
)
)
#
define
CsrFlagTest
(
pCsr
flag
)
(
(
pCsr
)
-
>
csrflags
&
(
flag
)
)
struct
Fts5Auxdata
{
Fts5Auxiliary
*
pAux
;
void
*
pPtr
;
void
(
*
xDelete
)
(
void
*
)
;
Fts5Auxdata
*
pNext
;
}
;
#
ifdef
SQLITE_DEBUG
#
define
FTS5_BEGIN
1
#
define
FTS5_SYNC
2
#
define
FTS5_COMMIT
3
#
define
FTS5_ROLLBACK
4
#
define
FTS5_SAVEPOINT
5
#
define
FTS5_RELEASE
6
#
define
FTS5_ROLLBACKTO
7
static
void
fts5CheckTransactionState
(
Fts5FullTable
*
p
int
op
int
iSavepoint
)
{
switch
(
op
)
{
case
FTS5_BEGIN
:
assert
(
p
-
>
ts
.
eState
=
=
0
)
;
p
-
>
ts
.
eState
=
1
;
p
-
>
ts
.
iSavepoint
=
-
1
;
break
;
case
FTS5_SYNC
:
assert
(
p
-
>
ts
.
eState
=
=
1
|
|
p
-
>
ts
.
eState
=
=
2
)
;
p
-
>
ts
.
eState
=
2
;
break
;
case
FTS5_COMMIT
:
assert
(
p
-
>
ts
.
eState
=
=
2
)
;
p
-
>
ts
.
eState
=
0
;
break
;
case
FTS5_ROLLBACK
:
assert
(
p
-
>
ts
.
eState
=
=
1
|
|
p
-
>
ts
.
eState
=
=
2
|
|
p
-
>
ts
.
eState
=
=
0
)
;
p
-
>
ts
.
eState
=
0
;
break
;
case
FTS5_SAVEPOINT
:
assert
(
p
-
>
ts
.
eState
>
=
1
)
;
assert
(
iSavepoint
>
=
0
)
;
assert
(
iSavepoint
>
=
p
-
>
ts
.
iSavepoint
)
;
p
-
>
ts
.
iSavepoint
=
iSavepoint
;
break
;
case
FTS5_RELEASE
:
assert
(
p
-
>
ts
.
eState
>
=
1
)
;
assert
(
iSavepoint
>
=
0
)
;
assert
(
iSavepoint
<
=
p
-
>
ts
.
iSavepoint
)
;
p
-
>
ts
.
iSavepoint
=
iSavepoint
-
1
;
break
;
case
FTS5_ROLLBACKTO
:
assert
(
p
-
>
ts
.
eState
>
=
1
)
;
assert
(
iSavepoint
>
=
-
1
)
;
p
-
>
ts
.
iSavepoint
=
iSavepoint
;
break
;
}
}
#
else
#
define
fts5CheckTransactionState
(
x
y
z
)
#
endif
static
int
fts5IsContentless
(
Fts5FullTable
*
pTab
int
bIncludeUnindexed
)
{
int
eContent
=
pTab
-
>
p
.
pConfig
-
>
eContent
;
return
(
eContent
=
=
FTS5_CONTENT_NONE
|
|
(
bIncludeUnindexed
&
&
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
)
;
}
static
void
fts5FreeVtab
(
Fts5FullTable
*
pTab
)
{
if
(
pTab
)
{
sqlite3Fts5IndexClose
(
pTab
-
>
p
.
pIndex
)
;
sqlite3Fts5StorageClose
(
pTab
-
>
pStorage
)
;
sqlite3Fts5ConfigFree
(
pTab
-
>
p
.
pConfig
)
;
sqlite3_free
(
pTab
)
;
}
}
static
int
fts5DisconnectMethod
(
sqlite3_vtab
*
pVtab
)
{
fts5FreeVtab
(
(
Fts5FullTable
*
)
pVtab
)
;
return
SQLITE_OK
;
}
static
int
fts5DestroyMethod
(
sqlite3_vtab
*
pVtab
)
{
Fts5Table
*
pTab
=
(
Fts5Table
*
)
pVtab
;
int
rc
=
sqlite3Fts5DropAll
(
pTab
-
>
pConfig
)
;
if
(
rc
=
=
SQLITE_OK
)
{
fts5FreeVtab
(
(
Fts5FullTable
*
)
pVtab
)
;
}
return
rc
;
}
static
int
fts5InitVtab
(
int
bCreate
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVTab
char
*
*
pzErr
)
{
Fts5Global
*
pGlobal
=
(
Fts5Global
*
)
pAux
;
const
char
*
*
azConfig
=
(
const
char
*
*
)
argv
;
int
rc
=
SQLITE_OK
;
Fts5Config
*
pConfig
=
0
;
Fts5FullTable
*
pTab
=
0
;
pTab
=
(
Fts5FullTable
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5FullTable
)
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ConfigParse
(
pGlobal
db
argc
azConfig
&
pConfig
pzErr
)
;
assert
(
(
rc
=
=
SQLITE_OK
&
&
*
pzErr
=
=
0
)
|
|
pConfig
=
=
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pConfig
-
>
pzErrmsg
=
pzErr
;
pTab
-
>
p
.
pConfig
=
pConfig
;
pTab
-
>
pGlobal
=
pGlobal
;
if
(
bCreate
|
|
sqlite3Fts5TokenizerPreload
(
&
pConfig
-
>
t
)
)
{
rc
=
sqlite3Fts5LoadTokenizer
(
pConfig
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexOpen
(
pConfig
bCreate
&
pTab
-
>
p
.
pIndex
pzErr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageOpen
(
pConfig
pTab
-
>
p
.
pIndex
bCreate
&
pTab
-
>
pStorage
pzErr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ConfigDeclareVtab
(
pConfig
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ConfigLoad
(
pTab
-
>
p
.
pConfig
pTab
-
>
p
.
pConfig
-
>
iCookie
-
1
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
rc
=
sqlite3_vtab_config
(
db
SQLITE_VTAB_CONSTRAINT_SUPPORT
(
int
)
1
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_vtab_config
(
db
SQLITE_VTAB_INNOCUOUS
)
;
}
if
(
pConfig
)
pConfig
-
>
pzErrmsg
=
0
;
if
(
rc
!
=
SQLITE_OK
)
{
fts5FreeVtab
(
pTab
)
;
pTab
=
0
;
}
else
if
(
bCreate
)
{
fts5CheckTransactionState
(
pTab
FTS5_BEGIN
0
)
;
}
*
ppVTab
=
(
sqlite3_vtab
*
)
pTab
;
return
rc
;
}
static
int
fts5ConnectMethod
(
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVtab
char
*
*
pzErr
)
{
return
fts5InitVtab
(
0
db
pAux
argc
argv
ppVtab
pzErr
)
;
}
static
int
fts5CreateMethod
(
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVtab
char
*
*
pzErr
)
{
return
fts5InitVtab
(
1
db
pAux
argc
argv
ppVtab
pzErr
)
;
}
#
define
FTS5_PLAN_MATCH
1
/
*
(
<
tbl
>
MATCH
?
)
*
/
#
define
FTS5_PLAN_SOURCE
2
/
*
A
source
cursor
for
SORTED_MATCH
*
/
#
define
FTS5_PLAN_SPECIAL
3
/
*
An
internal
query
*
/
#
define
FTS5_PLAN_SORTED_MATCH
4
/
*
(
<
tbl
>
MATCH
?
ORDER
BY
rank
)
*
/
#
define
FTS5_PLAN_SCAN
5
/
*
No
usable
constraint
*
/
#
define
FTS5_PLAN_ROWID
6
/
*
(
rowid
=
?
)
*
/
static
void
fts5SetUniqueFlag
(
sqlite3_index_info
*
pIdxInfo
)
{
#
if
SQLITE_VERSION_NUMBER
>
=
3008012
#
ifndef
SQLITE_CORE
if
(
sqlite3_libversion_number
(
)
>
=
3008012
)
#
endif
{
pIdxInfo
-
>
idxFlags
|
=
SQLITE_INDEX_SCAN_UNIQUE
;
}
#
endif
}
static
int
fts5UsePatternMatch
(
Fts5Config
*
pConfig
struct
sqlite3_index_constraint
*
p
)
{
assert
(
FTS5_PATTERN_GLOB
=
=
SQLITE_INDEX_CONSTRAINT_GLOB
)
;
assert
(
FTS5_PATTERN_LIKE
=
=
SQLITE_INDEX_CONSTRAINT_LIKE
)
;
if
(
pConfig
-
>
t
.
ePattern
=
=
FTS5_PATTERN_GLOB
&
&
p
-
>
op
=
=
FTS5_PATTERN_GLOB
)
{
return
1
;
}
if
(
pConfig
-
>
t
.
ePattern
=
=
FTS5_PATTERN_LIKE
&
&
(
p
-
>
op
=
=
FTS5_PATTERN_LIKE
|
|
p
-
>
op
=
=
FTS5_PATTERN_GLOB
)
)
{
return
1
;
}
return
0
;
}
static
int
fts5BestIndexMethod
(
sqlite3_vtab
*
pVTab
sqlite3_index_info
*
pInfo
)
{
Fts5Table
*
pTab
=
(
Fts5Table
*
)
pVTab
;
Fts5Config
*
pConfig
=
pTab
-
>
pConfig
;
const
int
nCol
=
pConfig
-
>
nCol
;
int
idxFlags
=
0
;
int
i
;
char
*
idxStr
;
int
iIdxStr
=
0
;
int
iCons
=
0
;
int
bSeenEq
=
0
;
int
bSeenGt
=
0
;
int
bSeenLt
=
0
;
int
nSeenMatch
=
0
;
int
bSeenRank
=
0
;
assert
(
SQLITE_INDEX_CONSTRAINT_EQ
<
SQLITE_INDEX_CONSTRAINT_MATCH
)
;
assert
(
SQLITE_INDEX_CONSTRAINT_GT
<
SQLITE_INDEX_CONSTRAINT_MATCH
)
;
assert
(
SQLITE_INDEX_CONSTRAINT_LE
<
SQLITE_INDEX_CONSTRAINT_MATCH
)
;
assert
(
SQLITE_INDEX_CONSTRAINT_GE
<
SQLITE_INDEX_CONSTRAINT_MATCH
)
;
assert
(
SQLITE_INDEX_CONSTRAINT_LE
<
SQLITE_INDEX_CONSTRAINT_MATCH
)
;
if
(
pConfig
-
>
bLock
)
{
pTab
-
>
base
.
zErrMsg
=
sqlite3_mprintf
(
"
recursively
defined
fts5
content
table
"
)
;
return
SQLITE_ERROR
;
}
idxStr
=
(
char
*
)
sqlite3_malloc
(
pInfo
-
>
nConstraint
*
8
+
1
)
;
if
(
idxStr
=
=
0
)
return
SQLITE_NOMEM
;
pInfo
-
>
idxStr
=
idxStr
;
pInfo
-
>
needToFreeIdxStr
=
1
;
for
(
i
=
0
;
i
<
pInfo
-
>
nConstraint
;
i
+
+
)
{
struct
sqlite3_index_constraint
*
p
=
&
pInfo
-
>
aConstraint
[
i
]
;
int
iCol
=
p
-
>
iColumn
;
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_MATCH
|
|
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_EQ
&
&
iCol
>
=
nCol
)
)
{
if
(
p
-
>
usable
=
=
0
|
|
iCol
<
0
)
{
idxStr
[
iIdxStr
]
=
0
;
return
SQLITE_CONSTRAINT
;
}
else
{
if
(
iCol
=
=
nCol
+
1
)
{
if
(
bSeenRank
)
continue
;
idxStr
[
iIdxStr
+
+
]
=
'
r
'
;
bSeenRank
=
1
;
}
else
{
nSeenMatch
+
+
;
idxStr
[
iIdxStr
+
+
]
=
'
M
'
;
sqlite3_snprintf
(
6
&
idxStr
[
iIdxStr
]
"
%
d
"
iCol
)
;
idxStr
+
=
strlen
(
&
idxStr
[
iIdxStr
]
)
;
assert
(
idxStr
[
iIdxStr
]
=
=
'
\
0
'
)
;
}
pInfo
-
>
aConstraintUsage
[
i
]
.
argvIndex
=
+
+
iCons
;
pInfo
-
>
aConstraintUsage
[
i
]
.
omit
=
1
;
}
}
else
if
(
p
-
>
usable
)
{
if
(
iCol
>
=
0
&
&
iCol
<
nCol
&
&
fts5UsePatternMatch
(
pConfig
p
)
)
{
assert
(
p
-
>
op
=
=
FTS5_PATTERN_LIKE
|
|
p
-
>
op
=
=
FTS5_PATTERN_GLOB
)
;
idxStr
[
iIdxStr
+
+
]
=
p
-
>
op
=
=
FTS5_PATTERN_LIKE
?
'
L
'
:
'
G
'
;
sqlite3_snprintf
(
6
&
idxStr
[
iIdxStr
]
"
%
d
"
iCol
)
;
idxStr
+
=
strlen
(
&
idxStr
[
iIdxStr
]
)
;
pInfo
-
>
aConstraintUsage
[
i
]
.
argvIndex
=
+
+
iCons
;
assert
(
idxStr
[
iIdxStr
]
=
=
'
\
0
'
)
;
nSeenMatch
+
+
;
}
else
if
(
bSeenEq
=
=
0
&
&
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_EQ
&
&
iCol
<
0
)
{
idxStr
[
iIdxStr
+
+
]
=
'
=
'
;
bSeenEq
=
1
;
pInfo
-
>
aConstraintUsage
[
i
]
.
argvIndex
=
+
+
iCons
;
}
}
}
if
(
bSeenEq
=
=
0
)
{
for
(
i
=
0
;
i
<
pInfo
-
>
nConstraint
;
i
+
+
)
{
struct
sqlite3_index_constraint
*
p
=
&
pInfo
-
>
aConstraint
[
i
]
;
if
(
p
-
>
iColumn
<
0
&
&
p
-
>
usable
)
{
int
op
=
p
-
>
op
;
if
(
op
=
=
SQLITE_INDEX_CONSTRAINT_LT
|
|
op
=
=
SQLITE_INDEX_CONSTRAINT_LE
)
{
if
(
bSeenLt
)
continue
;
idxStr
[
iIdxStr
+
+
]
=
'
<
'
;
pInfo
-
>
aConstraintUsage
[
i
]
.
argvIndex
=
+
+
iCons
;
bSeenLt
=
1
;
}
else
if
(
op
=
=
SQLITE_INDEX_CONSTRAINT_GT
|
|
op
=
=
SQLITE_INDEX_CONSTRAINT_GE
)
{
if
(
bSeenGt
)
continue
;
idxStr
[
iIdxStr
+
+
]
=
'
>
'
;
pInfo
-
>
aConstraintUsage
[
i
]
.
argvIndex
=
+
+
iCons
;
bSeenGt
=
1
;
}
}
}
}
idxStr
[
iIdxStr
]
=
'
\
0
'
;
if
(
pInfo
-
>
nOrderBy
=
=
1
)
{
int
iSort
=
pInfo
-
>
aOrderBy
[
0
]
.
iColumn
;
if
(
iSort
=
=
(
pConfig
-
>
nCol
+
1
)
&
&
nSeenMatch
>
0
)
{
idxFlags
|
=
FTS5_BI_ORDER_RANK
;
}
else
if
(
iSort
=
=
-
1
&
&
(
!
pInfo
-
>
aOrderBy
[
0
]
.
desc
|
|
!
pConfig
-
>
bTokendata
)
)
{
idxFlags
|
=
FTS5_BI_ORDER_ROWID
;
}
if
(
BitFlagTest
(
idxFlags
FTS5_BI_ORDER_RANK
|
FTS5_BI_ORDER_ROWID
)
)
{
pInfo
-
>
orderByConsumed
=
1
;
if
(
pInfo
-
>
aOrderBy
[
0
]
.
desc
)
{
idxFlags
|
=
FTS5_BI_ORDER_DESC
;
}
}
}
if
(
bSeenEq
)
{
pInfo
-
>
estimatedCost
=
nSeenMatch
?
1000
.
0
:
10
.
0
;
if
(
nSeenMatch
=
=
0
)
fts5SetUniqueFlag
(
pInfo
)
;
}
else
if
(
bSeenLt
&
&
bSeenGt
)
{
pInfo
-
>
estimatedCost
=
nSeenMatch
?
5000
.
0
:
250000
.
0
;
}
else
if
(
bSeenLt
|
|
bSeenGt
)
{
pInfo
-
>
estimatedCost
=
nSeenMatch
?
7500
.
0
:
750000
.
0
;
}
else
{
pInfo
-
>
estimatedCost
=
nSeenMatch
?
10000
.
0
:
1000000
.
0
;
}
for
(
i
=
1
;
i
<
nSeenMatch
;
i
+
+
)
{
pInfo
-
>
estimatedCost
*
=
0
.
4
;
}
pInfo
-
>
idxNum
=
idxFlags
;
return
SQLITE_OK
;
}
static
int
fts5NewTransaction
(
Fts5FullTable
*
pTab
)
{
Fts5Cursor
*
pCsr
;
for
(
pCsr
=
pTab
-
>
pGlobal
-
>
pCsr
;
pCsr
;
pCsr
=
pCsr
-
>
pNext
)
{
if
(
pCsr
-
>
base
.
pVtab
=
=
(
sqlite3_vtab
*
)
pTab
)
return
SQLITE_OK
;
}
return
sqlite3Fts5StorageReset
(
pTab
-
>
pStorage
)
;
}
static
int
fts5OpenMethod
(
sqlite3_vtab
*
pVTab
sqlite3_vtab_cursor
*
*
ppCsr
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVTab
;
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
Fts5Cursor
*
pCsr
=
0
;
sqlite3_int64
nByte
;
int
rc
;
rc
=
fts5NewTransaction
(
pTab
)
;
if
(
rc
=
=
SQLITE_OK
)
{
nByte
=
sizeof
(
Fts5Cursor
)
+
pConfig
-
>
nCol
*
sizeof
(
int
)
;
pCsr
=
(
Fts5Cursor
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
pCsr
)
{
Fts5Global
*
pGlobal
=
pTab
-
>
pGlobal
;
memset
(
pCsr
0
(
size_t
)
nByte
)
;
pCsr
-
>
aColumnSize
=
(
int
*
)
&
pCsr
[
1
]
;
pCsr
-
>
pNext
=
pGlobal
-
>
pCsr
;
pGlobal
-
>
pCsr
=
pCsr
;
pCsr
-
>
iCsrId
=
+
+
pGlobal
-
>
iNextId
;
}
else
{
rc
=
SQLITE_NOMEM
;
}
}
*
ppCsr
=
(
sqlite3_vtab_cursor
*
)
pCsr
;
return
rc
;
}
static
int
fts5StmtType
(
Fts5Cursor
*
pCsr
)
{
if
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SCAN
)
{
return
(
pCsr
-
>
bDesc
)
?
FTS5_STMT_SCAN_DESC
:
FTS5_STMT_SCAN_ASC
;
}
return
FTS5_STMT_LOOKUP
;
}
static
void
fts5CsrNewrow
(
Fts5Cursor
*
pCsr
)
{
CsrFlagSet
(
pCsr
FTS5CSR_REQUIRE_CONTENT
|
FTS5CSR_REQUIRE_DOCSIZE
|
FTS5CSR_REQUIRE_INST
|
FTS5CSR_REQUIRE_POSLIST
)
;
}
static
void
fts5FreeCursorComponents
(
Fts5Cursor
*
pCsr
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
Fts5Auxdata
*
pData
;
Fts5Auxdata
*
pNext
;
sqlite3_free
(
pCsr
-
>
aInstIter
)
;
sqlite3_free
(
pCsr
-
>
aInst
)
;
if
(
pCsr
-
>
pStmt
)
{
int
eStmt
=
fts5StmtType
(
pCsr
)
;
sqlite3Fts5StorageStmtRelease
(
pTab
-
>
pStorage
eStmt
pCsr
-
>
pStmt
)
;
}
if
(
pCsr
-
>
pSorter
)
{
Fts5Sorter
*
pSorter
=
pCsr
-
>
pSorter
;
sqlite3_finalize
(
pSorter
-
>
pStmt
)
;
sqlite3_free
(
pSorter
)
;
}
if
(
pCsr
-
>
ePlan
!
=
FTS5_PLAN_SOURCE
)
{
sqlite3Fts5ExprFree
(
pCsr
-
>
pExpr
)
;
}
for
(
pData
=
pCsr
-
>
pAuxdata
;
pData
;
pData
=
pNext
)
{
pNext
=
pData
-
>
pNext
;
if
(
pData
-
>
xDelete
)
pData
-
>
xDelete
(
pData
-
>
pPtr
)
;
sqlite3_free
(
pData
)
;
}
sqlite3_finalize
(
pCsr
-
>
pRankArgStmt
)
;
sqlite3_free
(
pCsr
-
>
apRankArg
)
;
if
(
CsrFlagTest
(
pCsr
FTS5CSR_FREE_ZRANK
)
)
{
sqlite3_free
(
pCsr
-
>
zRank
)
;
sqlite3_free
(
pCsr
-
>
zRankArgs
)
;
}
sqlite3Fts5IndexCloseReader
(
pTab
-
>
p
.
pIndex
)
;
memset
(
&
pCsr
-
>
ePlan
0
sizeof
(
Fts5Cursor
)
-
(
(
u8
*
)
&
pCsr
-
>
ePlan
-
(
u8
*
)
pCsr
)
)
;
}
static
int
fts5CloseMethod
(
sqlite3_vtab_cursor
*
pCursor
)
{
if
(
pCursor
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCursor
-
>
pVtab
)
;
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCursor
;
Fts5Cursor
*
*
pp
;
fts5FreeCursorComponents
(
pCsr
)
;
for
(
pp
=
&
pTab
-
>
pGlobal
-
>
pCsr
;
(
*
pp
)
!
=
pCsr
;
pp
=
&
(
*
pp
)
-
>
pNext
)
;
*
pp
=
pCsr
-
>
pNext
;
sqlite3_free
(
pCsr
)
;
}
return
SQLITE_OK
;
}
static
int
fts5SorterNext
(
Fts5Cursor
*
pCsr
)
{
Fts5Sorter
*
pSorter
=
pCsr
-
>
pSorter
;
int
rc
;
rc
=
sqlite3_step
(
pSorter
-
>
pStmt
)
;
if
(
rc
=
=
SQLITE_DONE
)
{
rc
=
SQLITE_OK
;
CsrFlagSet
(
pCsr
FTS5CSR_EOF
|
FTS5CSR_REQUIRE_CONTENT
)
;
}
else
if
(
rc
=
=
SQLITE_ROW
)
{
const
u8
*
a
;
const
u8
*
aBlob
;
int
nBlob
;
int
i
;
int
iOff
=
0
;
rc
=
SQLITE_OK
;
pSorter
-
>
iRowid
=
sqlite3_column_int64
(
pSorter
-
>
pStmt
0
)
;
nBlob
=
sqlite3_column_bytes
(
pSorter
-
>
pStmt
1
)
;
aBlob
=
a
=
sqlite3_column_blob
(
pSorter
-
>
pStmt
1
)
;
if
(
nBlob
>
0
)
{
for
(
i
=
0
;
i
<
(
pSorter
-
>
nIdx
-
1
)
;
i
+
+
)
{
int
iVal
;
a
+
=
fts5GetVarint32
(
a
iVal
)
;
iOff
+
=
iVal
;
pSorter
-
>
aIdx
[
i
]
=
iOff
;
}
pSorter
-
>
aIdx
[
i
]
=
&
aBlob
[
nBlob
]
-
a
;
pSorter
-
>
aPoslist
=
a
;
}
fts5CsrNewrow
(
pCsr
)
;
}
return
rc
;
}
static
void
fts5TripCursors
(
Fts5FullTable
*
pTab
)
{
Fts5Cursor
*
pCsr
;
for
(
pCsr
=
pTab
-
>
pGlobal
-
>
pCsr
;
pCsr
;
pCsr
=
pCsr
-
>
pNext
)
{
if
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_MATCH
&
&
pCsr
-
>
base
.
pVtab
=
=
(
sqlite3_vtab
*
)
pTab
)
{
CsrFlagSet
(
pCsr
FTS5CSR_REQUIRE_RESEEK
)
;
}
}
}
static
int
fts5CursorReseek
(
Fts5Cursor
*
pCsr
int
*
pbSkip
)
{
int
rc
=
SQLITE_OK
;
assert
(
*
pbSkip
=
=
0
)
;
if
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_RESEEK
)
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
int
bDesc
=
pCsr
-
>
bDesc
;
i64
iRowid
=
sqlite3Fts5ExprRowid
(
pCsr
-
>
pExpr
)
;
rc
=
sqlite3Fts5ExprFirst
(
pCsr
-
>
pExpr
pTab
-
>
p
.
pIndex
iRowid
bDesc
)
;
if
(
rc
=
=
SQLITE_OK
&
&
iRowid
!
=
sqlite3Fts5ExprRowid
(
pCsr
-
>
pExpr
)
)
{
*
pbSkip
=
1
;
}
CsrFlagClear
(
pCsr
FTS5CSR_REQUIRE_RESEEK
)
;
fts5CsrNewrow
(
pCsr
)
;
if
(
sqlite3Fts5ExprEof
(
pCsr
-
>
pExpr
)
)
{
CsrFlagSet
(
pCsr
FTS5CSR_EOF
)
;
*
pbSkip
=
1
;
}
}
return
rc
;
}
static
int
fts5NextMethod
(
sqlite3_vtab_cursor
*
pCursor
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCursor
;
int
rc
;
assert
(
(
pCsr
-
>
ePlan
<
3
)
=
=
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_MATCH
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SOURCE
)
)
;
assert
(
!
CsrFlagTest
(
pCsr
FTS5CSR_EOF
)
)
;
if
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_MATCH
&
&
(
(
Fts5Table
*
)
pCursor
-
>
pVtab
)
-
>
pConfig
-
>
bTokendata
)
{
sqlite3Fts5ExprClearTokens
(
pCsr
-
>
pExpr
)
;
}
if
(
pCsr
-
>
ePlan
<
3
)
{
int
bSkip
=
0
;
if
(
(
rc
=
fts5CursorReseek
(
pCsr
&
bSkip
)
)
|
|
bSkip
)
return
rc
;
rc
=
sqlite3Fts5ExprNext
(
pCsr
-
>
pExpr
pCsr
-
>
iLastRowid
)
;
CsrFlagSet
(
pCsr
sqlite3Fts5ExprEof
(
pCsr
-
>
pExpr
)
)
;
fts5CsrNewrow
(
pCsr
)
;
}
else
{
switch
(
pCsr
-
>
ePlan
)
{
case
FTS5_PLAN_SPECIAL
:
{
CsrFlagSet
(
pCsr
FTS5CSR_EOF
)
;
rc
=
SQLITE_OK
;
break
;
}
case
FTS5_PLAN_SORTED_MATCH
:
{
rc
=
fts5SorterNext
(
pCsr
)
;
break
;
}
default
:
{
Fts5Config
*
pConfig
=
(
(
Fts5Table
*
)
pCursor
-
>
pVtab
)
-
>
pConfig
;
pConfig
-
>
bLock
+
+
;
rc
=
sqlite3_step
(
pCsr
-
>
pStmt
)
;
pConfig
-
>
bLock
-
-
;
if
(
rc
!
=
SQLITE_ROW
)
{
CsrFlagSet
(
pCsr
FTS5CSR_EOF
)
;
rc
=
sqlite3_reset
(
pCsr
-
>
pStmt
)
;
if
(
rc
!
=
SQLITE_OK
)
{
pCursor
-
>
pVtab
-
>
zErrMsg
=
sqlite3_mprintf
(
"
%
s
"
sqlite3_errmsg
(
pConfig
-
>
db
)
)
;
}
}
else
{
rc
=
SQLITE_OK
;
CsrFlagSet
(
pCsr
FTS5CSR_REQUIRE_DOCSIZE
)
;
}
break
;
}
}
}
return
rc
;
}
static
int
fts5PrepareStatement
(
sqlite3_stmt
*
*
ppStmt
Fts5Config
*
pConfig
const
char
*
zFmt
.
.
.
)
{
sqlite3_stmt
*
pRet
=
0
;
int
rc
;
char
*
zSql
;
va_list
ap
;
va_start
(
ap
zFmt
)
;
zSql
=
sqlite3_vmprintf
(
zFmt
ap
)
;
if
(
zSql
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
rc
=
sqlite3_prepare_v3
(
pConfig
-
>
db
zSql
-
1
SQLITE_PREPARE_PERSISTENT
&
pRet
0
)
;
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3Fts5ConfigErrmsg
(
pConfig
"
%
s
"
sqlite3_errmsg
(
pConfig
-
>
db
)
)
;
}
sqlite3_free
(
zSql
)
;
}
va_end
(
ap
)
;
*
ppStmt
=
pRet
;
return
rc
;
}
static
int
fts5CursorFirstSorted
(
Fts5FullTable
*
pTab
Fts5Cursor
*
pCsr
int
bDesc
)
{
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
Fts5Sorter
*
pSorter
;
int
nPhrase
;
sqlite3_int64
nByte
;
int
rc
;
const
char
*
zRank
=
pCsr
-
>
zRank
;
const
char
*
zRankArgs
=
pCsr
-
>
zRankArgs
;
nPhrase
=
sqlite3Fts5ExprPhraseCount
(
pCsr
-
>
pExpr
)
;
nByte
=
sizeof
(
Fts5Sorter
)
+
sizeof
(
int
)
*
(
nPhrase
-
1
)
;
pSorter
=
(
Fts5Sorter
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
pSorter
=
=
0
)
return
SQLITE_NOMEM
;
memset
(
pSorter
0
(
size_t
)
nByte
)
;
pSorter
-
>
nIdx
=
nPhrase
;
rc
=
fts5PrepareStatement
(
&
pSorter
-
>
pStmt
pConfig
"
SELECT
rowid
rank
FROM
%
Q
.
%
Q
ORDER
BY
%
s
(
\
"
%
w
\
"
%
s
%
s
)
%
s
"
pConfig
-
>
zDb
pConfig
-
>
zName
zRank
pConfig
-
>
zName
(
zRankArgs
?
"
"
:
"
"
)
(
zRankArgs
?
zRankArgs
:
"
"
)
bDesc
?
"
DESC
"
:
"
ASC
"
)
;
pCsr
-
>
pSorter
=
pSorter
;
if
(
rc
=
=
SQLITE_OK
)
{
assert
(
pTab
-
>
pSortCsr
=
=
0
)
;
pTab
-
>
pSortCsr
=
pCsr
;
rc
=
fts5SorterNext
(
pCsr
)
;
pTab
-
>
pSortCsr
=
0
;
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_finalize
(
pSorter
-
>
pStmt
)
;
sqlite3_free
(
pSorter
)
;
pCsr
-
>
pSorter
=
0
;
}
return
rc
;
}
static
int
fts5CursorFirst
(
Fts5FullTable
*
pTab
Fts5Cursor
*
pCsr
int
bDesc
)
{
int
rc
;
Fts5Expr
*
pExpr
=
pCsr
-
>
pExpr
;
rc
=
sqlite3Fts5ExprFirst
(
pExpr
pTab
-
>
p
.
pIndex
pCsr
-
>
iFirstRowid
bDesc
)
;
if
(
sqlite3Fts5ExprEof
(
pExpr
)
)
{
CsrFlagSet
(
pCsr
FTS5CSR_EOF
)
;
}
fts5CsrNewrow
(
pCsr
)
;
return
rc
;
}
static
int
fts5SpecialMatch
(
Fts5FullTable
*
pTab
Fts5Cursor
*
pCsr
const
char
*
zQuery
)
{
int
rc
=
SQLITE_OK
;
const
char
*
z
=
zQuery
;
int
n
;
while
(
z
[
0
]
=
=
'
'
)
z
+
+
;
for
(
n
=
0
;
z
[
n
]
&
&
z
[
n
]
!
=
'
'
;
n
+
+
)
;
assert
(
pTab
-
>
p
.
base
.
zErrMsg
=
=
0
)
;
pCsr
-
>
ePlan
=
FTS5_PLAN_SPECIAL
;
if
(
n
=
=
5
&
&
0
=
=
sqlite3_strnicmp
(
"
reads
"
z
n
)
)
{
pCsr
-
>
iSpecial
=
sqlite3Fts5IndexReads
(
pTab
-
>
p
.
pIndex
)
;
}
else
if
(
n
=
=
2
&
&
0
=
=
sqlite3_strnicmp
(
"
id
"
z
n
)
)
{
pCsr
-
>
iSpecial
=
pCsr
-
>
iCsrId
;
}
else
{
pTab
-
>
p
.
base
.
zErrMsg
=
sqlite3_mprintf
(
"
unknown
special
query
:
%
.
*
s
"
n
z
)
;
rc
=
SQLITE_ERROR
;
}
return
rc
;
}
static
Fts5Auxiliary
*
fts5FindAuxiliary
(
Fts5FullTable
*
pTab
const
char
*
zName
)
{
Fts5Auxiliary
*
pAux
;
for
(
pAux
=
pTab
-
>
pGlobal
-
>
pAux
;
pAux
;
pAux
=
pAux
-
>
pNext
)
{
if
(
sqlite3_stricmp
(
zName
pAux
-
>
zFunc
)
=
=
0
)
return
pAux
;
}
return
0
;
}
static
int
fts5FindRankFunction
(
Fts5Cursor
*
pCsr
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
int
rc
=
SQLITE_OK
;
Fts5Auxiliary
*
pAux
=
0
;
const
char
*
zRank
=
pCsr
-
>
zRank
;
const
char
*
zRankArgs
=
pCsr
-
>
zRankArgs
;
if
(
zRankArgs
)
{
char
*
zSql
=
sqlite3Fts5Mprintf
(
&
rc
"
SELECT
%
s
"
zRankArgs
)
;
if
(
zSql
)
{
sqlite3_stmt
*
pStmt
=
0
;
rc
=
sqlite3_prepare_v3
(
pConfig
-
>
db
zSql
-
1
SQLITE_PREPARE_PERSISTENT
&
pStmt
0
)
;
sqlite3_free
(
zSql
)
;
assert
(
rc
=
=
SQLITE_OK
|
|
pCsr
-
>
pRankArgStmt
=
=
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
if
(
SQLITE_ROW
=
=
sqlite3_step
(
pStmt
)
)
{
sqlite3_int64
nByte
;
pCsr
-
>
nRankArg
=
sqlite3_column_count
(
pStmt
)
;
nByte
=
sizeof
(
sqlite3_value
*
)
*
pCsr
-
>
nRankArg
;
pCsr
-
>
apRankArg
=
(
sqlite3_value
*
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
if
(
rc
=
=
SQLITE_OK
)
{
int
i
;
for
(
i
=
0
;
i
<
pCsr
-
>
nRankArg
;
i
+
+
)
{
pCsr
-
>
apRankArg
[
i
]
=
sqlite3_column_value
(
pStmt
i
)
;
}
}
pCsr
-
>
pRankArgStmt
=
pStmt
;
}
else
{
rc
=
sqlite3_finalize
(
pStmt
)
;
assert
(
rc
!
=
SQLITE_OK
)
;
}
}
}
}
if
(
rc
=
=
SQLITE_OK
)
{
pAux
=
fts5FindAuxiliary
(
pTab
zRank
)
;
if
(
pAux
=
=
0
)
{
assert
(
pTab
-
>
p
.
base
.
zErrMsg
=
=
0
)
;
pTab
-
>
p
.
base
.
zErrMsg
=
sqlite3_mprintf
(
"
no
such
function
:
%
s
"
zRank
)
;
rc
=
SQLITE_ERROR
;
}
}
pCsr
-
>
pRank
=
pAux
;
return
rc
;
}
static
int
fts5CursorParseRank
(
Fts5Config
*
pConfig
Fts5Cursor
*
pCsr
sqlite3_value
*
pRank
)
{
int
rc
=
SQLITE_OK
;
if
(
pRank
)
{
const
char
*
z
=
(
const
char
*
)
sqlite3_value_text
(
pRank
)
;
char
*
zRank
=
0
;
char
*
zRankArgs
=
0
;
if
(
z
=
=
0
)
{
if
(
sqlite3_value_type
(
pRank
)
=
=
SQLITE_NULL
)
rc
=
SQLITE_ERROR
;
}
else
{
rc
=
sqlite3Fts5ConfigParseRank
(
z
&
zRank
&
zRankArgs
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
pCsr
-
>
zRank
=
zRank
;
pCsr
-
>
zRankArgs
=
zRankArgs
;
CsrFlagSet
(
pCsr
FTS5CSR_FREE_ZRANK
)
;
}
else
if
(
rc
=
=
SQLITE_ERROR
)
{
pCsr
-
>
base
.
pVtab
-
>
zErrMsg
=
sqlite3_mprintf
(
"
parse
error
in
rank
function
:
%
s
"
z
)
;
}
}
else
{
if
(
pConfig
-
>
zRank
)
{
pCsr
-
>
zRank
=
(
char
*
)
pConfig
-
>
zRank
;
pCsr
-
>
zRankArgs
=
(
char
*
)
pConfig
-
>
zRankArgs
;
}
else
{
pCsr
-
>
zRank
=
(
char
*
)
FTS5_DEFAULT_RANK
;
pCsr
-
>
zRankArgs
=
0
;
}
}
return
rc
;
}
static
i64
fts5GetRowidLimit
(
sqlite3_value
*
pVal
i64
iDefault
)
{
if
(
pVal
)
{
int
eType
=
sqlite3_value_numeric_type
(
pVal
)
;
if
(
eType
=
=
SQLITE_INTEGER
)
{
return
sqlite3_value_int64
(
pVal
)
;
}
}
return
iDefault
;
}
static
void
fts5SetVtabError
(
Fts5FullTable
*
p
const
char
*
zFormat
.
.
.
)
{
va_list
ap
;
va_start
(
ap
zFormat
)
;
sqlite3_free
(
p
-
>
p
.
base
.
zErrMsg
)
;
p
-
>
p
.
base
.
zErrMsg
=
sqlite3_vmprintf
(
zFormat
ap
)
;
va_end
(
ap
)
;
}
static
void
sqlite3Fts5SetLocale
(
Fts5Config
*
pConfig
const
char
*
zLocale
int
nLocale
)
{
Fts5TokenizerConfig
*
pT
=
&
pConfig
-
>
t
;
pT
-
>
pLocale
=
zLocale
;
pT
-
>
nLocale
=
nLocale
;
}
static
void
sqlite3Fts5ClearLocale
(
Fts5Config
*
pConfig
)
{
sqlite3Fts5SetLocale
(
pConfig
0
0
)
;
}
static
int
sqlite3Fts5IsLocaleValue
(
Fts5Config
*
pConfig
sqlite3_value
*
pVal
)
{
int
ret
=
0
;
if
(
sqlite3_value_type
(
pVal
)
=
=
SQLITE_BLOB
)
{
const
u8
*
pBlob
=
sqlite3_value_blob
(
pVal
)
;
int
nBlob
=
sqlite3_value_bytes
(
pVal
)
;
if
(
nBlob
>
FTS5_LOCALE_HDR_SIZE
&
&
0
=
=
memcmp
(
pBlob
FTS5_LOCALE_HDR
(
pConfig
)
FTS5_LOCALE_HDR_SIZE
)
)
{
ret
=
1
;
}
}
return
ret
;
}
static
int
sqlite3Fts5DecodeLocaleValue
(
sqlite3_value
*
pVal
const
char
*
*
ppText
int
*
pnText
const
char
*
*
ppLoc
int
*
pnLoc
)
{
const
char
*
p
=
sqlite3_value_blob
(
pVal
)
;
int
n
=
sqlite3_value_bytes
(
pVal
)
;
int
nLoc
=
0
;
assert
(
sqlite3_value_type
(
pVal
)
=
=
SQLITE_BLOB
)
;
assert
(
n
>
FTS5_LOCALE_HDR_SIZE
)
;
for
(
nLoc
=
FTS5_LOCALE_HDR_SIZE
;
p
[
nLoc
]
;
nLoc
+
+
)
{
if
(
nLoc
=
=
(
n
-
1
)
)
{
return
SQLITE_MISMATCH
;
}
}
*
ppLoc
=
&
p
[
FTS5_LOCALE_HDR_SIZE
]
;
*
pnLoc
=
nLoc
-
FTS5_LOCALE_HDR_SIZE
;
*
ppText
=
&
p
[
nLoc
+
1
]
;
*
pnText
=
n
-
nLoc
-
1
;
return
SQLITE_OK
;
}
static
int
fts5ExtractExprText
(
Fts5Config
*
pConfig
sqlite3_value
*
pVal
char
*
*
pzText
int
*
pbFreeAndReset
)
{
int
rc
=
SQLITE_OK
;
if
(
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
const
char
*
pText
=
0
;
int
nText
=
0
;
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
&
pText
&
nText
&
pLoc
&
nLoc
)
;
*
pzText
=
sqlite3Fts5Mprintf
(
&
rc
"
%
.
*
s
"
nText
pText
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5SetLocale
(
pConfig
pLoc
nLoc
)
;
}
*
pbFreeAndReset
=
1
;
}
else
{
*
pzText
=
(
char
*
)
sqlite3_value_text
(
pVal
)
;
*
pbFreeAndReset
=
0
;
}
return
rc
;
}
static
int
fts5FilterMethod
(
sqlite3_vtab_cursor
*
pCursor
int
idxNum
const
char
*
idxStr
int
nVal
sqlite3_value
*
*
apVal
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCursor
-
>
pVtab
)
;
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCursor
;
int
rc
=
SQLITE_OK
;
int
bDesc
;
int
bOrderByRank
;
sqlite3_value
*
pRank
=
0
;
sqlite3_value
*
pRowidEq
=
0
;
sqlite3_value
*
pRowidLe
=
0
;
sqlite3_value
*
pRowidGe
=
0
;
int
iCol
;
char
*
*
pzErrmsg
=
pConfig
-
>
pzErrmsg
;
int
bPrefixInsttoken
=
pConfig
-
>
bPrefixInsttoken
;
int
i
;
int
iIdxStr
=
0
;
Fts5Expr
*
pExpr
=
0
;
assert
(
pConfig
-
>
bLock
=
=
0
)
;
if
(
pCsr
-
>
ePlan
)
{
fts5FreeCursorComponents
(
pCsr
)
;
memset
(
&
pCsr
-
>
ePlan
0
sizeof
(
Fts5Cursor
)
-
(
(
u8
*
)
&
pCsr
-
>
ePlan
-
(
u8
*
)
pCsr
)
)
;
}
assert
(
pCsr
-
>
pStmt
=
=
0
)
;
assert
(
pCsr
-
>
pExpr
=
=
0
)
;
assert
(
pCsr
-
>
csrflags
=
=
0
)
;
assert
(
pCsr
-
>
pRank
=
=
0
)
;
assert
(
pCsr
-
>
zRank
=
=
0
)
;
assert
(
pCsr
-
>
zRankArgs
=
=
0
)
;
assert
(
pTab
-
>
pSortCsr
=
=
0
|
|
nVal
=
=
0
)
;
assert
(
pzErrmsg
=
=
0
|
|
pzErrmsg
=
=
&
pTab
-
>
p
.
base
.
zErrMsg
)
;
pConfig
-
>
pzErrmsg
=
&
pTab
-
>
p
.
base
.
zErrMsg
;
for
(
i
=
0
;
i
<
nVal
;
i
+
+
)
{
switch
(
idxStr
[
iIdxStr
+
+
]
)
{
case
'
r
'
:
pRank
=
apVal
[
i
]
;
break
;
case
'
M
'
:
{
char
*
zText
=
0
;
int
bFreeAndReset
=
0
;
int
bInternal
=
0
;
rc
=
fts5ExtractExprText
(
pConfig
apVal
[
i
]
&
zText
&
bFreeAndReset
)
;
if
(
rc
!
=
SQLITE_OK
)
goto
filter_out
;
if
(
zText
=
=
0
)
zText
=
"
"
;
if
(
sqlite3_value_subtype
(
apVal
[
i
]
)
=
=
FTS5_INSTTOKEN_SUBTYPE
)
{
pConfig
-
>
bPrefixInsttoken
=
1
;
}
iCol
=
0
;
do
{
iCol
=
iCol
*
10
+
(
idxStr
[
iIdxStr
]
-
'
0
'
)
;
iIdxStr
+
+
;
}
while
(
idxStr
[
iIdxStr
]
>
=
'
0
'
&
&
idxStr
[
iIdxStr
]
<
=
'
9
'
)
;
if
(
zText
[
0
]
=
=
'
*
'
)
{
rc
=
fts5SpecialMatch
(
pTab
pCsr
&
zText
[
1
]
)
;
bInternal
=
1
;
}
else
{
char
*
*
pzErr
=
&
pTab
-
>
p
.
base
.
zErrMsg
;
rc
=
sqlite3Fts5ExprNew
(
pConfig
0
iCol
zText
&
pExpr
pzErr
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ExprAnd
(
&
pCsr
-
>
pExpr
pExpr
)
;
pExpr
=
0
;
}
}
if
(
bFreeAndReset
)
{
sqlite3_free
(
zText
)
;
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
if
(
bInternal
|
|
rc
!
=
SQLITE_OK
)
goto
filter_out
;
break
;
}
case
'
L
'
:
case
'
G
'
:
{
int
bGlob
=
(
idxStr
[
iIdxStr
-
1
]
=
=
'
G
'
)
;
const
char
*
zText
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
i
]
)
;
iCol
=
0
;
do
{
iCol
=
iCol
*
10
+
(
idxStr
[
iIdxStr
]
-
'
0
'
)
;
iIdxStr
+
+
;
}
while
(
idxStr
[
iIdxStr
]
>
=
'
0
'
&
&
idxStr
[
iIdxStr
]
<
=
'
9
'
)
;
if
(
zText
)
{
rc
=
sqlite3Fts5ExprPattern
(
pConfig
bGlob
iCol
zText
&
pExpr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ExprAnd
(
&
pCsr
-
>
pExpr
pExpr
)
;
pExpr
=
0
;
}
if
(
rc
!
=
SQLITE_OK
)
goto
filter_out
;
break
;
}
case
'
=
'
:
pRowidEq
=
apVal
[
i
]
;
break
;
case
'
<
'
:
pRowidLe
=
apVal
[
i
]
;
break
;
default
:
assert
(
idxStr
[
iIdxStr
-
1
]
=
=
'
>
'
)
;
pRowidGe
=
apVal
[
i
]
;
break
;
}
}
bOrderByRank
=
(
(
idxNum
&
FTS5_BI_ORDER_RANK
)
?
1
:
0
)
;
pCsr
-
>
bDesc
=
bDesc
=
(
(
idxNum
&
FTS5_BI_ORDER_DESC
)
?
1
:
0
)
;
if
(
pRowidEq
)
{
pRowidLe
=
pRowidGe
=
pRowidEq
;
}
if
(
bDesc
)
{
pCsr
-
>
iFirstRowid
=
fts5GetRowidLimit
(
pRowidLe
LARGEST_INT64
)
;
pCsr
-
>
iLastRowid
=
fts5GetRowidLimit
(
pRowidGe
SMALLEST_INT64
)
;
}
else
{
pCsr
-
>
iLastRowid
=
fts5GetRowidLimit
(
pRowidLe
LARGEST_INT64
)
;
pCsr
-
>
iFirstRowid
=
fts5GetRowidLimit
(
pRowidGe
SMALLEST_INT64
)
;
}
rc
=
sqlite3Fts5IndexLoadConfig
(
pTab
-
>
p
.
pIndex
)
;
if
(
rc
!
=
SQLITE_OK
)
goto
filter_out
;
if
(
pTab
-
>
pSortCsr
)
{
assert
(
pRowidEq
=
=
0
&
&
pRowidLe
=
=
0
&
&
pRowidGe
=
=
0
&
&
pRank
=
=
0
)
;
assert
(
nVal
=
=
0
&
&
bOrderByRank
=
=
0
&
&
bDesc
=
=
0
)
;
assert
(
pCsr
-
>
iLastRowid
=
=
LARGEST_INT64
)
;
assert
(
pCsr
-
>
iFirstRowid
=
=
SMALLEST_INT64
)
;
if
(
pTab
-
>
pSortCsr
-
>
bDesc
)
{
pCsr
-
>
iLastRowid
=
pTab
-
>
pSortCsr
-
>
iFirstRowid
;
pCsr
-
>
iFirstRowid
=
pTab
-
>
pSortCsr
-
>
iLastRowid
;
}
else
{
pCsr
-
>
iLastRowid
=
pTab
-
>
pSortCsr
-
>
iLastRowid
;
pCsr
-
>
iFirstRowid
=
pTab
-
>
pSortCsr
-
>
iFirstRowid
;
}
pCsr
-
>
ePlan
=
FTS5_PLAN_SOURCE
;
pCsr
-
>
pExpr
=
pTab
-
>
pSortCsr
-
>
pExpr
;
rc
=
fts5CursorFirst
(
pTab
pCsr
bDesc
)
;
}
else
if
(
pCsr
-
>
pExpr
)
{
assert
(
rc
=
=
SQLITE_OK
)
;
rc
=
fts5CursorParseRank
(
pConfig
pCsr
pRank
)
;
if
(
rc
=
=
SQLITE_OK
)
{
if
(
bOrderByRank
)
{
pCsr
-
>
ePlan
=
FTS5_PLAN_SORTED_MATCH
;
rc
=
fts5CursorFirstSorted
(
pTab
pCsr
bDesc
)
;
}
else
{
pCsr
-
>
ePlan
=
FTS5_PLAN_MATCH
;
rc
=
fts5CursorFirst
(
pTab
pCsr
bDesc
)
;
}
}
}
else
if
(
pConfig
-
>
zContent
=
=
0
)
{
fts5SetVtabError
(
pTab
"
%
s
:
table
does
not
support
scanning
"
pConfig
-
>
zName
)
;
rc
=
SQLITE_ERROR
;
}
else
{
pCsr
-
>
ePlan
=
(
pRowidEq
?
FTS5_PLAN_ROWID
:
FTS5_PLAN_SCAN
)
;
rc
=
sqlite3Fts5StorageStmt
(
pTab
-
>
pStorage
fts5StmtType
(
pCsr
)
&
pCsr
-
>
pStmt
&
pTab
-
>
p
.
base
.
zErrMsg
)
;
if
(
rc
=
=
SQLITE_OK
)
{
if
(
pRowidEq
!
=
0
)
{
assert
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_ROWID
)
;
sqlite3_bind_value
(
pCsr
-
>
pStmt
1
pRowidEq
)
;
}
else
{
sqlite3_bind_int64
(
pCsr
-
>
pStmt
1
pCsr
-
>
iFirstRowid
)
;
sqlite3_bind_int64
(
pCsr
-
>
pStmt
2
pCsr
-
>
iLastRowid
)
;
}
rc
=
fts5NextMethod
(
pCursor
)
;
}
}
filter_out
:
sqlite3Fts5ExprFree
(
pExpr
)
;
pConfig
-
>
pzErrmsg
=
pzErrmsg
;
pConfig
-
>
bPrefixInsttoken
=
bPrefixInsttoken
;
return
rc
;
}
static
int
fts5EofMethod
(
sqlite3_vtab_cursor
*
pCursor
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCursor
;
return
(
CsrFlagTest
(
pCsr
FTS5CSR_EOF
)
?
1
:
0
)
;
}
static
i64
fts5CursorRowid
(
Fts5Cursor
*
pCsr
)
{
assert
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_MATCH
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SORTED_MATCH
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SOURCE
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SCAN
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_ROWID
)
;
if
(
pCsr
-
>
pSorter
)
{
return
pCsr
-
>
pSorter
-
>
iRowid
;
}
else
if
(
pCsr
-
>
ePlan
>
=
FTS5_PLAN_SCAN
)
{
return
sqlite3_column_int64
(
pCsr
-
>
pStmt
0
)
;
}
else
{
return
sqlite3Fts5ExprRowid
(
pCsr
-
>
pExpr
)
;
}
}
static
int
fts5RowidMethod
(
sqlite3_vtab_cursor
*
pCursor
sqlite_int64
*
pRowid
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCursor
;
int
ePlan
=
pCsr
-
>
ePlan
;
assert
(
CsrFlagTest
(
pCsr
FTS5CSR_EOF
)
=
=
0
)
;
if
(
ePlan
=
=
FTS5_PLAN_SPECIAL
)
{
*
pRowid
=
0
;
}
else
{
*
pRowid
=
fts5CursorRowid
(
pCsr
)
;
}
return
SQLITE_OK
;
}
static
int
fts5SeekCursor
(
Fts5Cursor
*
pCsr
int
bErrormsg
)
{
int
rc
=
SQLITE_OK
;
if
(
pCsr
-
>
pStmt
=
=
0
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
int
eStmt
=
fts5StmtType
(
pCsr
)
;
rc
=
sqlite3Fts5StorageStmt
(
pTab
-
>
pStorage
eStmt
&
pCsr
-
>
pStmt
(
bErrormsg
?
&
pTab
-
>
p
.
base
.
zErrMsg
:
0
)
)
;
assert
(
rc
!
=
SQLITE_OK
|
|
pTab
-
>
p
.
base
.
zErrMsg
=
=
0
)
;
assert
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_CONTENT
)
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_CONTENT
)
)
{
Fts5Table
*
pTab
=
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
;
assert
(
pCsr
-
>
pExpr
)
;
sqlite3_reset
(
pCsr
-
>
pStmt
)
;
sqlite3_bind_int64
(
pCsr
-
>
pStmt
1
fts5CursorRowid
(
pCsr
)
)
;
pTab
-
>
pConfig
-
>
bLock
+
+
;
rc
=
sqlite3_step
(
pCsr
-
>
pStmt
)
;
pTab
-
>
pConfig
-
>
bLock
-
-
;
if
(
rc
=
=
SQLITE_ROW
)
{
rc
=
SQLITE_OK
;
CsrFlagClear
(
pCsr
FTS5CSR_REQUIRE_CONTENT
)
;
}
else
{
rc
=
sqlite3_reset
(
pCsr
-
>
pStmt
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
FTS5_CORRUPT
;
fts5SetVtabError
(
(
Fts5FullTable
*
)
pTab
"
fts5
:
missing
row
%
lld
from
content
table
%
s
"
fts5CursorRowid
(
pCsr
)
pTab
-
>
pConfig
-
>
zContent
)
;
}
else
if
(
pTab
-
>
pConfig
-
>
pzErrmsg
)
{
fts5SetVtabError
(
(
Fts5FullTable
*
)
pTab
"
%
s
"
sqlite3_errmsg
(
pTab
-
>
pConfig
-
>
db
)
)
;
}
}
}
return
rc
;
}
static
int
fts5SpecialInsert
(
Fts5FullTable
*
pTab
const
char
*
zCmd
sqlite3_value
*
pVal
)
{
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
int
rc
=
SQLITE_OK
;
int
bError
=
0
;
int
bLoadConfig
=
0
;
if
(
0
=
=
sqlite3_stricmp
(
"
delete
-
all
"
zCmd
)
)
{
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
fts5SetVtabError
(
pTab
"
'
delete
-
all
'
may
only
be
used
with
a
"
"
contentless
or
external
content
fts5
table
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
rc
=
sqlite3Fts5StorageDeleteAll
(
pTab
-
>
pStorage
)
;
}
bLoadConfig
=
1
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
"
rebuild
"
zCmd
)
)
{
if
(
fts5IsContentless
(
pTab
1
)
)
{
fts5SetVtabError
(
pTab
"
'
rebuild
'
may
not
be
used
with
a
contentless
fts5
table
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
rc
=
sqlite3Fts5StorageRebuild
(
pTab
-
>
pStorage
)
;
}
bLoadConfig
=
1
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
"
optimize
"
zCmd
)
)
{
rc
=
sqlite3Fts5StorageOptimize
(
pTab
-
>
pStorage
)
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
"
merge
"
zCmd
)
)
{
int
nMerge
=
sqlite3_value_int
(
pVal
)
;
rc
=
sqlite3Fts5StorageMerge
(
pTab
-
>
pStorage
nMerge
)
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
"
integrity
-
check
"
zCmd
)
)
{
int
iArg
=
sqlite3_value_int
(
pVal
)
;
rc
=
sqlite3Fts5StorageIntegrity
(
pTab
-
>
pStorage
iArg
)
;
#
ifdef
SQLITE_DEBUG
}
else
if
(
0
=
=
sqlite3_stricmp
(
"
prefix
-
index
"
zCmd
)
)
{
pConfig
-
>
bPrefixIndex
=
sqlite3_value_int
(
pVal
)
;
#
endif
}
else
if
(
0
=
=
sqlite3_stricmp
(
"
flush
"
zCmd
)
)
{
rc
=
sqlite3Fts5FlushToDisk
(
&
pTab
-
>
p
)
;
}
else
{
rc
=
sqlite3Fts5FlushToDisk
(
&
pTab
-
>
p
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexLoadConfig
(
pTab
-
>
p
.
pIndex
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ConfigSetValue
(
pTab
-
>
p
.
pConfig
zCmd
pVal
&
bError
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
if
(
bError
)
{
rc
=
SQLITE_ERROR
;
}
else
{
rc
=
sqlite3Fts5StorageConfigValue
(
pTab
-
>
pStorage
zCmd
pVal
0
)
;
}
}
}
if
(
rc
=
=
SQLITE_OK
&
&
bLoadConfig
)
{
pTab
-
>
p
.
pConfig
-
>
iCookie
-
-
;
rc
=
sqlite3Fts5IndexLoadConfig
(
pTab
-
>
p
.
pIndex
)
;
}
return
rc
;
}
static
int
fts5SpecialDelete
(
Fts5FullTable
*
pTab
sqlite3_value
*
*
apVal
)
{
int
rc
=
SQLITE_OK
;
int
eType1
=
sqlite3_value_type
(
apVal
[
1
]
)
;
if
(
eType1
=
=
SQLITE_INTEGER
)
{
sqlite3_int64
iDel
=
sqlite3_value_int64
(
apVal
[
1
]
)
;
rc
=
sqlite3Fts5StorageDelete
(
pTab
-
>
pStorage
iDel
&
apVal
[
2
]
0
)
;
}
return
rc
;
}
static
void
fts5StorageInsert
(
int
*
pRc
Fts5FullTable
*
pTab
sqlite3_value
*
*
apVal
i64
*
piRowid
)
{
int
rc
=
*
pRc
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageContentInsert
(
pTab
-
>
pStorage
0
apVal
piRowid
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageIndexInsert
(
pTab
-
>
pStorage
apVal
*
piRowid
)
;
}
*
pRc
=
rc
;
}
static
int
fts5ContentlessUpdate
(
Fts5Config
*
pConfig
sqlite3_value
*
*
apVal
int
bRowidModified
int
*
pbContent
)
{
int
ii
;
int
bSeenIndex
=
0
;
int
bSeenIndexNC
=
0
;
int
rc
=
SQLITE_OK
;
for
(
ii
=
0
;
ii
<
pConfig
-
>
nCol
;
ii
+
+
)
{
if
(
pConfig
-
>
abUnindexed
[
ii
]
=
=
0
)
{
if
(
sqlite3_value_nochange
(
apVal
[
ii
]
)
)
{
bSeenIndexNC
+
+
;
}
else
{
bSeenIndex
+
+
;
}
}
}
if
(
bSeenIndex
=
=
0
&
&
bRowidModified
=
=
0
)
{
*
pbContent
=
1
;
}
else
{
if
(
bSeenIndexNC
|
|
pConfig
-
>
bContentlessDelete
=
=
0
)
{
rc
=
SQLITE_ERROR
;
sqlite3Fts5ConfigErrmsg
(
pConfig
(
pConfig
-
>
bContentlessDelete
?
"
%
s
a
subset
of
columns
on
fts5
contentless
-
delete
table
:
%
s
"
:
"
%
s
contentless
fts5
table
:
%
s
"
)
"
cannot
UPDATE
"
pConfig
-
>
zName
)
;
}
}
return
rc
;
}
static
int
fts5UpdateMethod
(
sqlite3_vtab
*
pVtab
int
nArg
sqlite3_value
*
*
apVal
sqlite_int64
*
pRowid
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
int
eType0
;
int
rc
=
SQLITE_OK
;
assert
(
pTab
-
>
ts
.
eState
=
=
1
|
|
pTab
-
>
ts
.
eState
=
=
2
)
;
assert
(
pVtab
-
>
zErrMsg
=
=
0
)
;
assert
(
nArg
=
=
1
|
|
nArg
=
=
(
2
+
pConfig
-
>
nCol
+
2
)
)
;
assert
(
sqlite3_value_type
(
apVal
[
0
]
)
=
=
SQLITE_INTEGER
|
|
sqlite3_value_type
(
apVal
[
0
]
)
=
=
SQLITE_NULL
)
;
assert
(
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
=
0
)
;
if
(
pConfig
-
>
pgsz
=
=
0
)
{
rc
=
sqlite3Fts5ConfigLoad
(
pTab
-
>
p
.
pConfig
pTab
-
>
p
.
pConfig
-
>
iCookie
)
;
if
(
rc
!
=
SQLITE_OK
)
return
rc
;
}
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
&
pTab
-
>
p
.
base
.
zErrMsg
;
fts5TripCursors
(
pTab
)
;
eType0
=
sqlite3_value_type
(
apVal
[
0
]
)
;
if
(
eType0
=
=
SQLITE_NULL
&
&
sqlite3_value_type
(
apVal
[
2
+
pConfig
-
>
nCol
]
)
!
=
SQLITE_NULL
)
{
const
char
*
z
=
(
const
char
*
)
sqlite3_value_text
(
apVal
[
2
+
pConfig
-
>
nCol
]
)
;
if
(
pConfig
-
>
eContent
!
=
FTS5_CONTENT_NORMAL
&
&
0
=
=
sqlite3_stricmp
(
"
delete
"
z
)
)
{
if
(
pConfig
-
>
bContentlessDelete
)
{
fts5SetVtabError
(
pTab
"
'
delete
'
may
not
be
used
with
a
contentless_delete
=
1
table
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
rc
=
fts5SpecialDelete
(
pTab
apVal
)
;
}
}
else
{
rc
=
fts5SpecialInsert
(
pTab
z
apVal
[
2
+
pConfig
-
>
nCol
+
1
]
)
;
}
}
else
{
int
eConflict
=
SQLITE_ABORT
;
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pConfig
-
>
bContentlessDelete
)
{
eConflict
=
sqlite3_vtab_on_conflict
(
pConfig
-
>
db
)
;
}
assert
(
eType0
=
=
SQLITE_INTEGER
|
|
eType0
=
=
SQLITE_NULL
)
;
assert
(
nArg
!
=
1
|
|
eType0
=
=
SQLITE_INTEGER
)
;
if
(
nArg
=
=
1
)
{
if
(
fts5IsContentless
(
pTab
1
)
&
&
pConfig
-
>
bContentlessDelete
=
=
0
)
{
fts5SetVtabError
(
pTab
"
cannot
DELETE
from
contentless
fts5
table
:
%
s
"
pConfig
-
>
zName
)
;
rc
=
SQLITE_ERROR
;
}
else
{
i64
iDel
=
sqlite3_value_int64
(
apVal
[
0
]
)
;
rc
=
sqlite3Fts5StorageDelete
(
pTab
-
>
pStorage
iDel
0
0
)
;
}
}
else
{
int
eType1
=
sqlite3_value_numeric_type
(
apVal
[
1
]
)
;
if
(
pConfig
-
>
bLocale
=
=
0
)
{
int
ii
;
for
(
ii
=
0
;
ii
<
pConfig
-
>
nCol
;
ii
+
+
)
{
sqlite3_value
*
pVal
=
apVal
[
ii
+
2
]
;
if
(
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
fts5SetVtabError
(
pTab
"
fts5_locale
(
)
requires
locale
=
1
"
)
;
rc
=
SQLITE_MISMATCH
;
goto
update_out
;
}
}
}
if
(
eType0
!
=
SQLITE_INTEGER
)
{
if
(
eConflict
=
=
SQLITE_REPLACE
&
&
eType1
=
=
SQLITE_INTEGER
)
{
i64
iNew
=
sqlite3_value_int64
(
apVal
[
1
]
)
;
rc
=
sqlite3Fts5StorageDelete
(
pTab
-
>
pStorage
iNew
0
0
)
;
}
fts5StorageInsert
(
&
rc
pTab
apVal
pRowid
)
;
}
else
{
Fts5Storage
*
pStorage
=
pTab
-
>
pStorage
;
i64
iOld
=
sqlite3_value_int64
(
apVal
[
0
]
)
;
i64
iNew
=
sqlite3_value_int64
(
apVal
[
1
]
)
;
int
bContent
=
0
;
if
(
fts5IsContentless
(
pTab
1
)
)
{
rc
=
fts5ContentlessUpdate
(
pConfig
&
apVal
[
2
]
iOld
!
=
iNew
&
bContent
)
;
if
(
rc
!
=
SQLITE_OK
)
goto
update_out
;
}
if
(
eType1
!
=
SQLITE_INTEGER
)
{
rc
=
SQLITE_MISMATCH
;
}
else
if
(
iOld
!
=
iNew
)
{
assert
(
bContent
=
=
0
)
;
if
(
eConflict
=
=
SQLITE_REPLACE
)
{
rc
=
sqlite3Fts5StorageDelete
(
pStorage
iOld
0
1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageDelete
(
pStorage
iNew
0
0
)
;
}
fts5StorageInsert
(
&
rc
pTab
apVal
pRowid
)
;
}
else
{
rc
=
sqlite3Fts5StorageFindDeleteRow
(
pStorage
iOld
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageContentInsert
(
pStorage
0
apVal
pRowid
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageDelete
(
pStorage
iOld
0
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageIndexInsert
(
pStorage
apVal
*
pRowid
)
;
}
}
}
else
if
(
bContent
)
{
assert
(
fts5IsContentless
(
pTab
1
)
)
;
rc
=
sqlite3Fts5StorageFindDeleteRow
(
pStorage
iOld
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageContentInsert
(
pStorage
1
apVal
pRowid
)
;
}
}
else
{
rc
=
sqlite3Fts5StorageDelete
(
pStorage
iOld
0
1
)
;
fts5StorageInsert
(
&
rc
pTab
apVal
pRowid
)
;
}
sqlite3Fts5StorageReleaseDeleteRow
(
pStorage
)
;
}
}
}
update_out
:
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
0
;
return
rc
;
}
static
int
fts5SyncMethod
(
sqlite3_vtab
*
pVtab
)
{
int
rc
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
fts5CheckTransactionState
(
pTab
FTS5_SYNC
0
)
;
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
&
pTab
-
>
p
.
base
.
zErrMsg
;
rc
=
sqlite3Fts5FlushToDisk
(
&
pTab
-
>
p
)
;
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
0
;
return
rc
;
}
static
int
fts5BeginMethod
(
sqlite3_vtab
*
pVtab
)
{
int
rc
=
fts5NewTransaction
(
(
Fts5FullTable
*
)
pVtab
)
;
if
(
rc
=
=
SQLITE_OK
)
{
fts5CheckTransactionState
(
(
Fts5FullTable
*
)
pVtab
FTS5_BEGIN
0
)
;
}
return
rc
;
}
static
int
fts5CommitMethod
(
sqlite3_vtab
*
pVtab
)
{
UNUSED_PARAM
(
pVtab
)
;
fts5CheckTransactionState
(
(
Fts5FullTable
*
)
pVtab
FTS5_COMMIT
0
)
;
return
SQLITE_OK
;
}
static
int
fts5RollbackMethod
(
sqlite3_vtab
*
pVtab
)
{
int
rc
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
fts5CheckTransactionState
(
pTab
FTS5_ROLLBACK
0
)
;
rc
=
sqlite3Fts5StorageRollback
(
pTab
-
>
pStorage
)
;
pTab
-
>
p
.
pConfig
-
>
pgsz
=
0
;
return
rc
;
}
static
int
fts5CsrPoslist
(
Fts5Cursor
*
int
const
u8
*
*
int
*
)
;
static
void
*
fts5ApiUserData
(
Fts5Context
*
pCtx
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
return
pCsr
-
>
pAux
-
>
pUserData
;
}
static
int
fts5ApiColumnCount
(
Fts5Context
*
pCtx
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
return
(
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
)
-
>
pConfig
-
>
nCol
;
}
static
int
fts5ApiColumnTotalSize
(
Fts5Context
*
pCtx
int
iCol
sqlite3_int64
*
pnToken
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
return
sqlite3Fts5StorageSize
(
pTab
-
>
pStorage
iCol
pnToken
)
;
}
static
int
fts5ApiRowCount
(
Fts5Context
*
pCtx
i64
*
pnRow
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
return
sqlite3Fts5StorageRowCount
(
pTab
-
>
pStorage
pnRow
)
;
}
static
int
fts5ApiTokenize_v2
(
Fts5Context
*
pCtx
const
char
*
pText
int
nText
const
char
*
pLoc
int
nLoc
void
*
pUserData
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Table
*
pTab
=
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
;
int
rc
=
SQLITE_OK
;
sqlite3Fts5SetLocale
(
pTab
-
>
pConfig
pLoc
nLoc
)
;
rc
=
sqlite3Fts5Tokenize
(
pTab
-
>
pConfig
FTS5_TOKENIZE_AUX
pText
nText
pUserData
xToken
)
;
sqlite3Fts5SetLocale
(
pTab
-
>
pConfig
0
0
)
;
return
rc
;
}
static
int
fts5ApiTokenize
(
Fts5Context
*
pCtx
const
char
*
pText
int
nText
void
*
pUserData
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
{
return
fts5ApiTokenize_v2
(
pCtx
pText
nText
0
0
pUserData
xToken
)
;
}
static
int
fts5ApiPhraseCount
(
Fts5Context
*
pCtx
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
return
sqlite3Fts5ExprPhraseCount
(
pCsr
-
>
pExpr
)
;
}
static
int
fts5ApiPhraseSize
(
Fts5Context
*
pCtx
int
iPhrase
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
return
sqlite3Fts5ExprPhraseSize
(
pCsr
-
>
pExpr
iPhrase
)
;
}
static
int
fts5TextFromStmt
(
Fts5Config
*
pConfig
sqlite3_stmt
*
pStmt
int
iCol
const
char
*
*
ppText
int
*
pnText
)
{
sqlite3_value
*
pVal
=
sqlite3_column_value
(
pStmt
iCol
+
1
)
;
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
int
rc
=
SQLITE_OK
;
if
(
pConfig
-
>
bLocale
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
&
&
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
ppText
pnText
&
pLoc
&
nLoc
)
;
}
else
{
*
ppText
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
*
pnText
=
sqlite3_value_bytes
(
pVal
)
;
if
(
pConfig
-
>
bLocale
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
pLoc
=
(
const
char
*
)
sqlite3_column_text
(
pStmt
iCol
+
1
+
pConfig
-
>
nCol
)
;
nLoc
=
sqlite3_column_bytes
(
pStmt
iCol
+
1
+
pConfig
-
>
nCol
)
;
}
}
sqlite3Fts5SetLocale
(
pConfig
pLoc
nLoc
)
;
return
rc
;
}
static
int
fts5ApiColumnText
(
Fts5Context
*
pCtx
int
iCol
const
char
*
*
pz
int
*
pn
)
{
int
rc
=
SQLITE_OK
;
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Table
*
pTab
=
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
;
assert
(
pCsr
-
>
ePlan
!
=
FTS5_PLAN_SPECIAL
)
;
if
(
iCol
<
0
|
|
iCol
>
=
pTab
-
>
pConfig
-
>
nCol
)
{
rc
=
SQLITE_RANGE
;
}
else
if
(
fts5IsContentless
(
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
0
)
)
{
*
pz
=
0
;
*
pn
=
0
;
}
else
{
rc
=
fts5SeekCursor
(
pCsr
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5TextFromStmt
(
pTab
-
>
pConfig
pCsr
-
>
pStmt
iCol
pz
pn
)
;
sqlite3Fts5ClearLocale
(
pTab
-
>
pConfig
)
;
}
}
return
rc
;
}
static
int
fts5CsrPoslist
(
Fts5Cursor
*
pCsr
int
iPhrase
const
u8
*
*
pa
int
*
pn
)
{
Fts5Config
*
pConfig
=
(
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
)
-
>
pConfig
;
int
rc
=
SQLITE_OK
;
int
bLive
=
(
pCsr
-
>
pSorter
=
=
0
)
;
if
(
iPhrase
<
0
|
|
iPhrase
>
=
sqlite3Fts5ExprPhraseCount
(
pCsr
-
>
pExpr
)
)
{
rc
=
SQLITE_RANGE
;
}
else
if
(
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
&
&
fts5IsContentless
(
(
Fts5FullTable
*
)
pCsr
-
>
base
.
pVtab
1
)
)
{
*
pa
=
0
;
*
pn
=
0
;
return
SQLITE_OK
;
}
else
if
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_POSLIST
)
)
{
if
(
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_FULL
)
{
Fts5PoslistPopulator
*
aPopulator
;
int
i
;
aPopulator
=
sqlite3Fts5ExprClearPoslists
(
pCsr
-
>
pExpr
bLive
)
;
if
(
aPopulator
=
=
0
)
rc
=
SQLITE_NOMEM
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5SeekCursor
(
pCsr
0
)
;
}
for
(
i
=
0
;
i
<
pConfig
-
>
nCol
&
&
rc
=
=
SQLITE_OK
;
i
+
+
)
{
const
char
*
z
=
0
;
int
n
=
0
;
rc
=
fts5TextFromStmt
(
pConfig
pCsr
-
>
pStmt
i
&
z
&
n
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5ExprPopulatePoslists
(
pConfig
pCsr
-
>
pExpr
aPopulator
i
z
n
)
;
}
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
sqlite3_free
(
aPopulator
)
;
if
(
pCsr
-
>
pSorter
)
{
sqlite3Fts5ExprCheckPoslists
(
pCsr
-
>
pExpr
pCsr
-
>
pSorter
-
>
iRowid
)
;
}
}
CsrFlagClear
(
pCsr
FTS5CSR_REQUIRE_POSLIST
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
if
(
pCsr
-
>
pSorter
&
&
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_FULL
)
{
Fts5Sorter
*
pSorter
=
pCsr
-
>
pSorter
;
int
i1
=
(
iPhrase
=
=
0
?
0
:
pSorter
-
>
aIdx
[
iPhrase
-
1
]
)
;
*
pn
=
pSorter
-
>
aIdx
[
iPhrase
]
-
i1
;
*
pa
=
&
pSorter
-
>
aPoslist
[
i1
]
;
}
else
{
*
pn
=
sqlite3Fts5ExprPoslist
(
pCsr
-
>
pExpr
iPhrase
pa
)
;
}
}
else
{
*
pa
=
0
;
*
pn
=
0
;
}
return
rc
;
}
static
int
fts5CacheInstArray
(
Fts5Cursor
*
pCsr
)
{
int
rc
=
SQLITE_OK
;
Fts5PoslistReader
*
aIter
;
int
nIter
;
int
nCol
=
(
(
Fts5Table
*
)
pCsr
-
>
base
.
pVtab
)
-
>
pConfig
-
>
nCol
;
nIter
=
sqlite3Fts5ExprPhraseCount
(
pCsr
-
>
pExpr
)
;
if
(
pCsr
-
>
aInstIter
=
=
0
)
{
sqlite3_int64
nByte
=
sizeof
(
Fts5PoslistReader
)
*
nIter
;
pCsr
-
>
aInstIter
=
(
Fts5PoslistReader
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
}
aIter
=
pCsr
-
>
aInstIter
;
if
(
aIter
)
{
int
nInst
=
0
;
int
i
;
for
(
i
=
0
;
i
<
nIter
&
&
rc
=
=
SQLITE_OK
;
i
+
+
)
{
const
u8
*
a
;
int
n
;
rc
=
fts5CsrPoslist
(
pCsr
i
&
a
&
n
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5PoslistReaderInit
(
a
n
&
aIter
[
i
]
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
while
(
1
)
{
int
*
aInst
;
int
iBest
=
-
1
;
for
(
i
=
0
;
i
<
nIter
;
i
+
+
)
{
if
(
(
aIter
[
i
]
.
bEof
=
=
0
)
&
&
(
iBest
<
0
|
|
aIter
[
i
]
.
iPos
<
aIter
[
iBest
]
.
iPos
)
)
{
iBest
=
i
;
}
}
if
(
iBest
<
0
)
break
;
nInst
+
+
;
if
(
nInst
>
=
pCsr
-
>
nInstAlloc
)
{
int
nNewSize
=
pCsr
-
>
nInstAlloc
?
pCsr
-
>
nInstAlloc
*
2
:
32
;
aInst
=
(
int
*
)
sqlite3_realloc64
(
pCsr
-
>
aInst
nNewSize
*
sizeof
(
int
)
*
3
)
;
if
(
aInst
)
{
pCsr
-
>
aInst
=
aInst
;
pCsr
-
>
nInstAlloc
=
nNewSize
;
}
else
{
nInst
-
-
;
rc
=
SQLITE_NOMEM
;
break
;
}
}
aInst
=
&
pCsr
-
>
aInst
[
3
*
(
nInst
-
1
)
]
;
aInst
[
0
]
=
iBest
;
aInst
[
1
]
=
FTS5_POS2COLUMN
(
aIter
[
iBest
]
.
iPos
)
;
aInst
[
2
]
=
FTS5_POS2OFFSET
(
aIter
[
iBest
]
.
iPos
)
;
assert
(
aInst
[
1
]
>
=
0
)
;
if
(
aInst
[
1
]
>
=
nCol
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
sqlite3Fts5PoslistReaderNext
(
&
aIter
[
iBest
]
)
;
}
}
pCsr
-
>
nInstCount
=
nInst
;
CsrFlagClear
(
pCsr
FTS5CSR_REQUIRE_INST
)
;
}
return
rc
;
}
static
int
fts5ApiInstCount
(
Fts5Context
*
pCtx
int
*
pnInst
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
int
rc
=
SQLITE_OK
;
if
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_INST
)
=
=
0
|
|
SQLITE_OK
=
=
(
rc
=
fts5CacheInstArray
(
pCsr
)
)
)
{
*
pnInst
=
pCsr
-
>
nInstCount
;
}
return
rc
;
}
static
int
fts5ApiInst
(
Fts5Context
*
pCtx
int
iIdx
int
*
piPhrase
int
*
piCol
int
*
piOff
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
int
rc
=
SQLITE_OK
;
if
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_INST
)
=
=
0
|
|
SQLITE_OK
=
=
(
rc
=
fts5CacheInstArray
(
pCsr
)
)
)
{
if
(
iIdx
<
0
|
|
iIdx
>
=
pCsr
-
>
nInstCount
)
{
rc
=
SQLITE_RANGE
;
}
else
{
*
piPhrase
=
pCsr
-
>
aInst
[
iIdx
*
3
]
;
*
piCol
=
pCsr
-
>
aInst
[
iIdx
*
3
+
1
]
;
*
piOff
=
pCsr
-
>
aInst
[
iIdx
*
3
+
2
]
;
}
}
return
rc
;
}
static
sqlite3_int64
fts5ApiRowid
(
Fts5Context
*
pCtx
)
{
return
fts5CursorRowid
(
(
Fts5Cursor
*
)
pCtx
)
;
}
static
int
fts5ColumnSizeCb
(
void
*
pContext
int
tflags
const
char
*
pUnused
int
nUnused
int
iUnused1
int
iUnused2
)
{
int
*
pCnt
=
(
int
*
)
pContext
;
UNUSED_PARAM2
(
pUnused
nUnused
)
;
UNUSED_PARAM2
(
iUnused1
iUnused2
)
;
if
(
(
tflags
&
FTS5_TOKEN_COLOCATED
)
=
=
0
)
{
(
*
pCnt
)
+
+
;
}
return
SQLITE_OK
;
}
static
int
fts5ApiColumnSize
(
Fts5Context
*
pCtx
int
iCol
int
*
pnToken
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
int
rc
=
SQLITE_OK
;
if
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_DOCSIZE
)
)
{
if
(
pConfig
-
>
bColumnsize
)
{
i64
iRowid
=
fts5CursorRowid
(
pCsr
)
;
rc
=
sqlite3Fts5StorageDocsize
(
pTab
-
>
pStorage
iRowid
pCsr
-
>
aColumnSize
)
;
}
else
if
(
!
pConfig
-
>
zContent
|
|
pConfig
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
{
int
i
;
for
(
i
=
0
;
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
if
(
pConfig
-
>
abUnindexed
[
i
]
=
=
0
)
{
pCsr
-
>
aColumnSize
[
i
]
=
-
1
;
}
}
}
else
{
int
i
;
rc
=
fts5SeekCursor
(
pCsr
0
)
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
if
(
pConfig
-
>
abUnindexed
[
i
]
=
=
0
)
{
const
char
*
z
=
0
;
int
n
=
0
;
pCsr
-
>
aColumnSize
[
i
]
=
0
;
rc
=
fts5TextFromStmt
(
pConfig
pCsr
-
>
pStmt
i
&
z
&
n
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5Tokenize
(
pConfig
FTS5_TOKENIZE_AUX
z
n
(
void
*
)
&
pCsr
-
>
aColumnSize
[
i
]
fts5ColumnSizeCb
)
;
}
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
}
}
CsrFlagClear
(
pCsr
FTS5CSR_REQUIRE_DOCSIZE
)
;
}
if
(
iCol
<
0
)
{
int
i
;
*
pnToken
=
0
;
for
(
i
=
0
;
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
*
pnToken
+
=
pCsr
-
>
aColumnSize
[
i
]
;
}
}
else
if
(
iCol
<
pConfig
-
>
nCol
)
{
*
pnToken
=
pCsr
-
>
aColumnSize
[
iCol
]
;
}
else
{
*
pnToken
=
0
;
rc
=
SQLITE_RANGE
;
}
return
rc
;
}
static
int
fts5ApiSetAuxdata
(
Fts5Context
*
pCtx
void
*
pPtr
void
(
*
xDelete
)
(
void
*
)
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Auxdata
*
pData
;
for
(
pData
=
pCsr
-
>
pAuxdata
;
pData
;
pData
=
pData
-
>
pNext
)
{
if
(
pData
-
>
pAux
=
=
pCsr
-
>
pAux
)
break
;
}
if
(
pData
)
{
if
(
pData
-
>
xDelete
)
{
pData
-
>
xDelete
(
pData
-
>
pPtr
)
;
}
}
else
{
int
rc
=
SQLITE_OK
;
pData
=
(
Fts5Auxdata
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
Fts5Auxdata
)
)
;
if
(
pData
=
=
0
)
{
if
(
xDelete
)
xDelete
(
pPtr
)
;
return
rc
;
}
pData
-
>
pAux
=
pCsr
-
>
pAux
;
pData
-
>
pNext
=
pCsr
-
>
pAuxdata
;
pCsr
-
>
pAuxdata
=
pData
;
}
pData
-
>
xDelete
=
xDelete
;
pData
-
>
pPtr
=
pPtr
;
return
SQLITE_OK
;
}
static
void
*
fts5ApiGetAuxdata
(
Fts5Context
*
pCtx
int
bClear
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Auxdata
*
pData
;
void
*
pRet
=
0
;
for
(
pData
=
pCsr
-
>
pAuxdata
;
pData
;
pData
=
pData
-
>
pNext
)
{
if
(
pData
-
>
pAux
=
=
pCsr
-
>
pAux
)
break
;
}
if
(
pData
)
{
pRet
=
pData
-
>
pPtr
;
if
(
bClear
)
{
pData
-
>
pPtr
=
0
;
pData
-
>
xDelete
=
0
;
}
}
return
pRet
;
}
static
void
fts5ApiPhraseNext
(
Fts5Context
*
pCtx
Fts5PhraseIter
*
pIter
int
*
piCol
int
*
piOff
)
{
if
(
pIter
-
>
a
>
=
pIter
-
>
b
)
{
*
piCol
=
-
1
;
*
piOff
=
-
1
;
}
else
{
int
iVal
;
pIter
-
>
a
+
=
fts5GetVarint32
(
pIter
-
>
a
iVal
)
;
if
(
iVal
=
=
1
)
{
int
nCol
=
(
(
Fts5Table
*
)
(
(
(
Fts5Cursor
*
)
pCtx
)
-
>
base
.
pVtab
)
)
-
>
pConfig
-
>
nCol
;
pIter
-
>
a
+
=
fts5GetVarint32
(
pIter
-
>
a
iVal
)
;
*
piCol
=
(
iVal
>
=
nCol
?
nCol
-
1
:
iVal
)
;
*
piOff
=
0
;
pIter
-
>
a
+
=
fts5GetVarint32
(
pIter
-
>
a
iVal
)
;
}
*
piOff
+
=
(
iVal
-
2
)
;
}
}
static
int
fts5ApiPhraseFirst
(
Fts5Context
*
pCtx
int
iPhrase
Fts5PhraseIter
*
pIter
int
*
piCol
int
*
piOff
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
int
n
;
int
rc
=
fts5CsrPoslist
(
pCsr
iPhrase
&
pIter
-
>
a
&
n
)
;
if
(
rc
=
=
SQLITE_OK
)
{
assert
(
pIter
-
>
a
|
|
n
=
=
0
)
;
pIter
-
>
b
=
(
pIter
-
>
a
?
&
pIter
-
>
a
[
n
]
:
0
)
;
*
piCol
=
0
;
*
piOff
=
0
;
fts5ApiPhraseNext
(
pCtx
pIter
piCol
piOff
)
;
}
return
rc
;
}
static
void
fts5ApiPhraseNextColumn
(
Fts5Context
*
pCtx
Fts5PhraseIter
*
pIter
int
*
piCol
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Config
*
pConfig
=
(
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
)
-
>
pConfig
;
if
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
{
if
(
pIter
-
>
a
>
=
pIter
-
>
b
)
{
*
piCol
=
-
1
;
}
else
{
int
iIncr
;
pIter
-
>
a
+
=
fts5GetVarint32
(
&
pIter
-
>
a
[
0
]
iIncr
)
;
*
piCol
+
=
(
iIncr
-
2
)
;
}
}
else
{
while
(
1
)
{
int
dummy
;
if
(
pIter
-
>
a
>
=
pIter
-
>
b
)
{
*
piCol
=
-
1
;
return
;
}
if
(
pIter
-
>
a
[
0
]
=
=
0x01
)
break
;
pIter
-
>
a
+
=
fts5GetVarint32
(
pIter
-
>
a
dummy
)
;
}
pIter
-
>
a
+
=
1
+
fts5GetVarint32
(
&
pIter
-
>
a
[
1
]
*
piCol
)
;
}
}
static
int
fts5ApiPhraseFirstColumn
(
Fts5Context
*
pCtx
int
iPhrase
Fts5PhraseIter
*
pIter
int
*
piCol
)
{
int
rc
=
SQLITE_OK
;
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Config
*
pConfig
=
(
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
)
-
>
pConfig
;
if
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
{
Fts5Sorter
*
pSorter
=
pCsr
-
>
pSorter
;
int
n
;
if
(
pSorter
)
{
int
i1
=
(
iPhrase
=
=
0
?
0
:
pSorter
-
>
aIdx
[
iPhrase
-
1
]
)
;
n
=
pSorter
-
>
aIdx
[
iPhrase
]
-
i1
;
pIter
-
>
a
=
&
pSorter
-
>
aPoslist
[
i1
]
;
}
else
{
rc
=
sqlite3Fts5ExprPhraseCollist
(
pCsr
-
>
pExpr
iPhrase
&
pIter
-
>
a
&
n
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
assert
(
pIter
-
>
a
|
|
n
=
=
0
)
;
pIter
-
>
b
=
(
pIter
-
>
a
?
&
pIter
-
>
a
[
n
]
:
0
)
;
*
piCol
=
0
;
fts5ApiPhraseNextColumn
(
pCtx
pIter
piCol
)
;
}
}
else
{
int
n
;
rc
=
fts5CsrPoslist
(
pCsr
iPhrase
&
pIter
-
>
a
&
n
)
;
if
(
rc
=
=
SQLITE_OK
)
{
assert
(
pIter
-
>
a
|
|
n
=
=
0
)
;
pIter
-
>
b
=
(
pIter
-
>
a
?
&
pIter
-
>
a
[
n
]
:
0
)
;
if
(
n
<
=
0
)
{
*
piCol
=
-
1
;
}
else
if
(
pIter
-
>
a
[
0
]
=
=
0x01
)
{
pIter
-
>
a
+
=
1
+
fts5GetVarint32
(
&
pIter
-
>
a
[
1
]
*
piCol
)
;
}
else
{
*
piCol
=
0
;
}
}
}
return
rc
;
}
static
int
fts5ApiQueryToken
(
Fts5Context
*
pCtx
int
iPhrase
int
iToken
const
char
*
*
ppOut
int
*
pnOut
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
return
sqlite3Fts5ExprQueryToken
(
pCsr
-
>
pExpr
iPhrase
iToken
ppOut
pnOut
)
;
}
static
int
fts5ApiInstToken
(
Fts5Context
*
pCtx
int
iIdx
int
iToken
const
char
*
*
ppOut
int
*
pnOut
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
int
rc
=
SQLITE_OK
;
if
(
CsrFlagTest
(
pCsr
FTS5CSR_REQUIRE_INST
)
=
=
0
|
|
SQLITE_OK
=
=
(
rc
=
fts5CacheInstArray
(
pCsr
)
)
)
{
if
(
iIdx
<
0
|
|
iIdx
>
=
pCsr
-
>
nInstCount
)
{
rc
=
SQLITE_RANGE
;
}
else
{
int
iPhrase
=
pCsr
-
>
aInst
[
iIdx
*
3
]
;
int
iCol
=
pCsr
-
>
aInst
[
iIdx
*
3
+
1
]
;
int
iOff
=
pCsr
-
>
aInst
[
iIdx
*
3
+
2
]
;
i64
iRowid
=
fts5CursorRowid
(
pCsr
)
;
rc
=
sqlite3Fts5ExprInstToken
(
pCsr
-
>
pExpr
iRowid
iPhrase
iCol
iOff
iToken
ppOut
pnOut
)
;
}
}
return
rc
;
}
static
int
fts5ApiQueryPhrase
(
Fts5Context
*
int
void
*
int
(
*
)
(
const
Fts5ExtensionApi
*
Fts5Context
*
void
*
)
)
;
static
int
fts5ApiColumnLocale
(
Fts5Context
*
pCtx
int
iCol
const
char
*
*
pzLocale
int
*
pnLocale
)
{
int
rc
=
SQLITE_OK
;
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5Config
*
pConfig
=
(
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
)
-
>
pConfig
;
*
pzLocale
=
0
;
*
pnLocale
=
0
;
assert
(
pCsr
-
>
ePlan
!
=
FTS5_PLAN_SPECIAL
)
;
if
(
iCol
<
0
|
|
iCol
>
=
pConfig
-
>
nCol
)
{
rc
=
SQLITE_RANGE
;
}
else
if
(
pConfig
-
>
abUnindexed
[
iCol
]
=
=
0
&
&
0
=
=
fts5IsContentless
(
(
Fts5FullTable
*
)
pCsr
-
>
base
.
pVtab
1
)
&
&
pConfig
-
>
bLocale
)
{
rc
=
fts5SeekCursor
(
pCsr
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
const
char
*
zDummy
=
0
;
int
nDummy
=
0
;
rc
=
fts5TextFromStmt
(
pConfig
pCsr
-
>
pStmt
iCol
&
zDummy
&
nDummy
)
;
if
(
rc
=
=
SQLITE_OK
)
{
*
pzLocale
=
pConfig
-
>
t
.
pLocale
;
*
pnLocale
=
pConfig
-
>
t
.
nLocale
;
}
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
}
return
rc
;
}
static
const
Fts5ExtensionApi
sFts5Api
=
{
4
fts5ApiUserData
fts5ApiColumnCount
fts5ApiRowCount
fts5ApiColumnTotalSize
fts5ApiTokenize
fts5ApiPhraseCount
fts5ApiPhraseSize
fts5ApiInstCount
fts5ApiInst
fts5ApiRowid
fts5ApiColumnText
fts5ApiColumnSize
fts5ApiQueryPhrase
fts5ApiSetAuxdata
fts5ApiGetAuxdata
fts5ApiPhraseFirst
fts5ApiPhraseNext
fts5ApiPhraseFirstColumn
fts5ApiPhraseNextColumn
fts5ApiQueryToken
fts5ApiInstToken
fts5ApiColumnLocale
fts5ApiTokenize_v2
}
;
static
int
fts5ApiQueryPhrase
(
Fts5Context
*
pCtx
int
iPhrase
void
*
pUserData
int
(
*
xCallback
)
(
const
Fts5ExtensionApi
*
Fts5Context
*
void
*
)
)
{
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCtx
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCsr
-
>
base
.
pVtab
)
;
int
rc
;
Fts5Cursor
*
pNew
=
0
;
rc
=
fts5OpenMethod
(
pCsr
-
>
base
.
pVtab
(
sqlite3_vtab_cursor
*
*
)
&
pNew
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pNew
-
>
ePlan
=
FTS5_PLAN_MATCH
;
pNew
-
>
iFirstRowid
=
SMALLEST_INT64
;
pNew
-
>
iLastRowid
=
LARGEST_INT64
;
pNew
-
>
base
.
pVtab
=
(
sqlite3_vtab
*
)
pTab
;
rc
=
sqlite3Fts5ExprClonePhrase
(
pCsr
-
>
pExpr
iPhrase
&
pNew
-
>
pExpr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
for
(
rc
=
fts5CursorFirst
(
pTab
pNew
0
)
;
rc
=
=
SQLITE_OK
&
&
CsrFlagTest
(
pNew
FTS5CSR_EOF
)
=
=
0
;
rc
=
fts5NextMethod
(
(
sqlite3_vtab_cursor
*
)
pNew
)
)
{
rc
=
xCallback
(
&
sFts5Api
(
Fts5Context
*
)
pNew
pUserData
)
;
if
(
rc
!
=
SQLITE_OK
)
{
if
(
rc
=
=
SQLITE_DONE
)
rc
=
SQLITE_OK
;
break
;
}
}
}
fts5CloseMethod
(
(
sqlite3_vtab_cursor
*
)
pNew
)
;
return
rc
;
}
static
void
fts5ApiInvoke
(
Fts5Auxiliary
*
pAux
Fts5Cursor
*
pCsr
sqlite3_context
*
context
int
argc
sqlite3_value
*
*
argv
)
{
assert
(
pCsr
-
>
pAux
=
=
0
)
;
assert
(
pCsr
-
>
ePlan
!
=
FTS5_PLAN_SPECIAL
)
;
pCsr
-
>
pAux
=
pAux
;
pAux
-
>
xFunc
(
&
sFts5Api
(
Fts5Context
*
)
pCsr
context
argc
argv
)
;
pCsr
-
>
pAux
=
0
;
}
static
Fts5Cursor
*
fts5CursorFromCsrid
(
Fts5Global
*
pGlobal
i64
iCsrId
)
{
Fts5Cursor
*
pCsr
;
for
(
pCsr
=
pGlobal
-
>
pCsr
;
pCsr
;
pCsr
=
pCsr
-
>
pNext
)
{
if
(
pCsr
-
>
iCsrId
=
=
iCsrId
)
break
;
}
return
pCsr
;
}
static
void
fts5ResultError
(
sqlite3_context
*
pCtx
const
char
*
zFmt
.
.
.
)
{
char
*
zErr
=
0
;
va_list
ap
;
va_start
(
ap
zFmt
)
;
zErr
=
sqlite3_vmprintf
(
zFmt
ap
)
;
sqlite3_result_error
(
pCtx
zErr
-
1
)
;
sqlite3_free
(
zErr
)
;
va_end
(
ap
)
;
}
static
void
fts5ApiCallback
(
sqlite3_context
*
context
int
argc
sqlite3_value
*
*
argv
)
{
Fts5Auxiliary
*
pAux
;
Fts5Cursor
*
pCsr
;
i64
iCsrId
;
assert
(
argc
>
=
1
)
;
pAux
=
(
Fts5Auxiliary
*
)
sqlite3_user_data
(
context
)
;
iCsrId
=
sqlite3_value_int64
(
argv
[
0
]
)
;
pCsr
=
fts5CursorFromCsrid
(
pAux
-
>
pGlobal
iCsrId
)
;
if
(
pCsr
=
=
0
|
|
(
pCsr
-
>
ePlan
=
=
0
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SPECIAL
)
)
{
fts5ResultError
(
context
"
no
such
cursor
:
%
lld
"
iCsrId
)
;
}
else
{
sqlite3_vtab
*
pTab
=
pCsr
-
>
base
.
pVtab
;
fts5ApiInvoke
(
pAux
pCsr
context
argc
-
1
&
argv
[
1
]
)
;
sqlite3_free
(
pTab
-
>
zErrMsg
)
;
pTab
-
>
zErrMsg
=
0
;
}
}
static
Fts5Table
*
sqlite3Fts5TableFromCsrid
(
Fts5Global
*
pGlobal
i64
iCsrId
)
{
Fts5Cursor
*
pCsr
;
pCsr
=
fts5CursorFromCsrid
(
pGlobal
iCsrId
)
;
if
(
pCsr
)
{
return
(
Fts5Table
*
)
pCsr
-
>
base
.
pVtab
;
}
return
0
;
}
static
int
fts5PoslistBlob
(
sqlite3_context
*
pCtx
Fts5Cursor
*
pCsr
)
{
int
i
;
int
rc
=
SQLITE_OK
;
int
nPhrase
=
sqlite3Fts5ExprPhraseCount
(
pCsr
-
>
pExpr
)
;
Fts5Buffer
val
;
memset
(
&
val
0
sizeof
(
Fts5Buffer
)
)
;
switch
(
(
(
Fts5Table
*
)
(
pCsr
-
>
base
.
pVtab
)
)
-
>
pConfig
-
>
eDetail
)
{
case
FTS5_DETAIL_FULL
:
for
(
i
=
0
;
i
<
(
nPhrase
-
1
)
;
i
+
+
)
{
const
u8
*
dummy
;
int
nByte
=
sqlite3Fts5ExprPoslist
(
pCsr
-
>
pExpr
i
&
dummy
)
;
sqlite3Fts5BufferAppendVarint
(
&
rc
&
val
nByte
)
;
}
for
(
i
=
0
;
i
<
nPhrase
;
i
+
+
)
{
const
u8
*
pPoslist
;
int
nPoslist
;
nPoslist
=
sqlite3Fts5ExprPoslist
(
pCsr
-
>
pExpr
i
&
pPoslist
)
;
sqlite3Fts5BufferAppendBlob
(
&
rc
&
val
nPoslist
pPoslist
)
;
}
break
;
case
FTS5_DETAIL_COLUMNS
:
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
(
nPhrase
-
1
)
;
i
+
+
)
{
const
u8
*
dummy
;
int
nByte
;
rc
=
sqlite3Fts5ExprPhraseCollist
(
pCsr
-
>
pExpr
i
&
dummy
&
nByte
)
;
sqlite3Fts5BufferAppendVarint
(
&
rc
&
val
nByte
)
;
}
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nPhrase
;
i
+
+
)
{
const
u8
*
pPoslist
;
int
nPoslist
;
rc
=
sqlite3Fts5ExprPhraseCollist
(
pCsr
-
>
pExpr
i
&
pPoslist
&
nPoslist
)
;
sqlite3Fts5BufferAppendBlob
(
&
rc
&
val
nPoslist
pPoslist
)
;
}
break
;
default
:
break
;
}
sqlite3_result_blob
(
pCtx
val
.
p
val
.
n
sqlite3_free
)
;
return
rc
;
}
static
int
fts5ColumnMethod
(
sqlite3_vtab_cursor
*
pCursor
sqlite3_context
*
pCtx
int
iCol
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
(
pCursor
-
>
pVtab
)
;
Fts5Config
*
pConfig
=
pTab
-
>
p
.
pConfig
;
Fts5Cursor
*
pCsr
=
(
Fts5Cursor
*
)
pCursor
;
int
rc
=
SQLITE_OK
;
assert
(
CsrFlagTest
(
pCsr
FTS5CSR_EOF
)
=
=
0
)
;
if
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SPECIAL
)
{
if
(
iCol
=
=
pConfig
-
>
nCol
)
{
sqlite3_result_int64
(
pCtx
pCsr
-
>
iSpecial
)
;
}
}
else
if
(
iCol
=
=
pConfig
-
>
nCol
)
{
sqlite3_result_int64
(
pCtx
pCsr
-
>
iCsrId
)
;
}
else
if
(
iCol
=
=
pConfig
-
>
nCol
+
1
)
{
if
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SOURCE
)
{
fts5PoslistBlob
(
pCtx
pCsr
)
;
}
else
if
(
pCsr
-
>
ePlan
=
=
FTS5_PLAN_MATCH
|
|
pCsr
-
>
ePlan
=
=
FTS5_PLAN_SORTED_MATCH
)
{
if
(
pCsr
-
>
pRank
|
|
SQLITE_OK
=
=
(
rc
=
fts5FindRankFunction
(
pCsr
)
)
)
{
fts5ApiInvoke
(
pCsr
-
>
pRank
pCsr
pCtx
pCsr
-
>
nRankArg
pCsr
-
>
apRankArg
)
;
}
}
}
else
{
if
(
!
sqlite3_vtab_nochange
(
pCtx
)
&
&
pConfig
-
>
eContent
!
=
FTS5_CONTENT_NONE
)
{
pConfig
-
>
pzErrmsg
=
&
pTab
-
>
p
.
base
.
zErrMsg
;
rc
=
fts5SeekCursor
(
pCsr
1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_value
*
pVal
=
sqlite3_column_value
(
pCsr
-
>
pStmt
iCol
+
1
)
;
if
(
pConfig
-
>
bLocale
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
&
&
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
const
char
*
z
=
0
;
int
n
=
0
;
rc
=
fts5TextFromStmt
(
pConfig
pCsr
-
>
pStmt
iCol
&
z
&
n
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_result_text
(
pCtx
z
n
SQLITE_TRANSIENT
)
;
}
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
else
{
sqlite3_result_value
(
pCtx
pVal
)
;
}
}
pConfig
-
>
pzErrmsg
=
0
;
}
}
return
rc
;
}
static
int
fts5FindFunctionMethod
(
sqlite3_vtab
*
pVtab
int
nUnused
const
char
*
zName
void
(
*
*
pxFunc
)
(
sqlite3_context
*
int
sqlite3_value
*
*
)
void
*
*
ppArg
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
Fts5Auxiliary
*
pAux
;
UNUSED_PARAM
(
nUnused
)
;
pAux
=
fts5FindAuxiliary
(
pTab
zName
)
;
if
(
pAux
)
{
*
pxFunc
=
fts5ApiCallback
;
*
ppArg
=
(
void
*
)
pAux
;
return
1
;
}
return
0
;
}
static
int
fts5RenameMethod
(
sqlite3_vtab
*
pVtab
const
char
*
zName
)
{
int
rc
;
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
rc
=
sqlite3Fts5StorageRename
(
pTab
-
>
pStorage
zName
)
;
return
rc
;
}
static
int
sqlite3Fts5FlushToDisk
(
Fts5Table
*
pTab
)
{
fts5TripCursors
(
(
Fts5FullTable
*
)
pTab
)
;
return
sqlite3Fts5StorageSync
(
(
(
Fts5FullTable
*
)
pTab
)
-
>
pStorage
)
;
}
static
int
fts5SavepointMethod
(
sqlite3_vtab
*
pVtab
int
iSavepoint
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
int
rc
=
SQLITE_OK
;
fts5CheckTransactionState
(
pTab
FTS5_SAVEPOINT
iSavepoint
)
;
rc
=
sqlite3Fts5FlushToDisk
(
(
Fts5Table
*
)
pVtab
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pTab
-
>
iSavepoint
=
iSavepoint
+
1
;
}
return
rc
;
}
static
int
fts5ReleaseMethod
(
sqlite3_vtab
*
pVtab
int
iSavepoint
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
int
rc
=
SQLITE_OK
;
fts5CheckTransactionState
(
pTab
FTS5_RELEASE
iSavepoint
)
;
if
(
(
iSavepoint
+
1
)
<
pTab
-
>
iSavepoint
)
{
rc
=
sqlite3Fts5FlushToDisk
(
&
pTab
-
>
p
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pTab
-
>
iSavepoint
=
iSavepoint
;
}
}
return
rc
;
}
static
int
fts5RollbackToMethod
(
sqlite3_vtab
*
pVtab
int
iSavepoint
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
int
rc
=
SQLITE_OK
;
fts5CheckTransactionState
(
pTab
FTS5_ROLLBACKTO
iSavepoint
)
;
fts5TripCursors
(
pTab
)
;
if
(
(
iSavepoint
+
1
)
<
=
pTab
-
>
iSavepoint
)
{
pTab
-
>
p
.
pConfig
-
>
pgsz
=
0
;
rc
=
sqlite3Fts5StorageRollback
(
pTab
-
>
pStorage
)
;
}
return
rc
;
}
static
int
fts5CreateAux
(
fts5_api
*
pApi
const
char
*
zName
void
*
pUserData
fts5_extension_function
xFunc
void
(
*
xDestroy
)
(
void
*
)
)
{
Fts5Global
*
pGlobal
=
(
Fts5Global
*
)
pApi
;
int
rc
=
sqlite3_overload_function
(
pGlobal
-
>
db
zName
-
1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
Fts5Auxiliary
*
pAux
;
sqlite3_int64
nName
;
sqlite3_int64
nByte
;
nName
=
strlen
(
zName
)
+
1
;
nByte
=
sizeof
(
Fts5Auxiliary
)
+
nName
;
pAux
=
(
Fts5Auxiliary
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
pAux
)
{
memset
(
pAux
0
(
size_t
)
nByte
)
;
pAux
-
>
zFunc
=
(
char
*
)
&
pAux
[
1
]
;
memcpy
(
pAux
-
>
zFunc
zName
nName
)
;
pAux
-
>
pGlobal
=
pGlobal
;
pAux
-
>
pUserData
=
pUserData
;
pAux
-
>
xFunc
=
xFunc
;
pAux
-
>
xDestroy
=
xDestroy
;
pAux
-
>
pNext
=
pGlobal
-
>
pAux
;
pGlobal
-
>
pAux
=
pAux
;
}
else
{
rc
=
SQLITE_NOMEM
;
}
}
return
rc
;
}
static
int
fts5NewTokenizerModule
(
Fts5Global
*
pGlobal
const
char
*
zName
void
*
pUserData
void
(
*
xDestroy
)
(
void
*
)
Fts5TokenizerModule
*
*
ppNew
)
{
int
rc
=
SQLITE_OK
;
Fts5TokenizerModule
*
pNew
;
sqlite3_int64
nName
;
sqlite3_int64
nByte
;
nName
=
strlen
(
zName
)
+
1
;
nByte
=
sizeof
(
Fts5TokenizerModule
)
+
nName
;
*
ppNew
=
pNew
=
(
Fts5TokenizerModule
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
if
(
pNew
)
{
pNew
-
>
zName
=
(
char
*
)
&
pNew
[
1
]
;
memcpy
(
pNew
-
>
zName
zName
nName
)
;
pNew
-
>
pUserData
=
pUserData
;
pNew
-
>
xDestroy
=
xDestroy
;
pNew
-
>
pNext
=
pGlobal
-
>
pTok
;
pGlobal
-
>
pTok
=
pNew
;
if
(
pNew
-
>
pNext
=
=
0
)
{
pGlobal
-
>
pDfltTok
=
pNew
;
}
}
return
rc
;
}
typedef
struct
Fts5VtoVTokenizer
Fts5VtoVTokenizer
;
struct
Fts5VtoVTokenizer
{
int
bV2Native
;
fts5_tokenizer
x1
;
fts5_tokenizer_v2
x2
;
Fts5Tokenizer
*
pReal
;
}
;
static
int
fts5VtoVCreate
(
void
*
pCtx
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
{
Fts5TokenizerModule
*
pMod
=
(
Fts5TokenizerModule
*
)
pCtx
;
Fts5VtoVTokenizer
*
pNew
=
0
;
int
rc
=
SQLITE_OK
;
pNew
=
(
Fts5VtoVTokenizer
*
)
sqlite3Fts5MallocZero
(
&
rc
sizeof
(
*
pNew
)
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pNew
-
>
x1
=
pMod
-
>
x1
;
pNew
-
>
x2
=
pMod
-
>
x2
;
pNew
-
>
bV2Native
=
pMod
-
>
bV2Native
;
if
(
pMod
-
>
bV2Native
)
{
rc
=
pMod
-
>
x2
.
xCreate
(
pMod
-
>
pUserData
azArg
nArg
&
pNew
-
>
pReal
)
;
}
else
{
rc
=
pMod
-
>
x1
.
xCreate
(
pMod
-
>
pUserData
azArg
nArg
&
pNew
-
>
pReal
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
sqlite3_free
(
pNew
)
;
pNew
=
0
;
}
}
*
ppOut
=
(
Fts5Tokenizer
*
)
pNew
;
return
rc
;
}
static
void
fts5VtoVDelete
(
Fts5Tokenizer
*
pTok
)
{
Fts5VtoVTokenizer
*
p
=
(
Fts5VtoVTokenizer
*
)
pTok
;
if
(
p
)
{
if
(
p
-
>
bV2Native
)
{
p
-
>
x2
.
xDelete
(
p
-
>
pReal
)
;
}
else
{
p
-
>
x1
.
xDelete
(
p
-
>
pReal
)
;
}
sqlite3_free
(
p
)
;
}
}
static
int
fts5V1toV2Tokenize
(
Fts5Tokenizer
*
pTok
void
*
pCtx
int
flags
const
char
*
pText
int
nText
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
{
Fts5VtoVTokenizer
*
p
=
(
Fts5VtoVTokenizer
*
)
pTok
;
assert
(
p
-
>
bV2Native
)
;
return
p
-
>
x2
.
xTokenize
(
p
-
>
pReal
pCtx
flags
pText
nText
0
0
xToken
)
;
}
static
int
fts5V2toV1Tokenize
(
Fts5Tokenizer
*
pTok
void
*
pCtx
int
flags
const
char
*
pText
int
nText
const
char
*
pLocale
int
nLocale
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
{
Fts5VtoVTokenizer
*
p
=
(
Fts5VtoVTokenizer
*
)
pTok
;
assert
(
p
-
>
bV2Native
=
=
0
)
;
UNUSED_PARAM2
(
pLocale
nLocale
)
;
return
p
-
>
x1
.
xTokenize
(
p
-
>
pReal
pCtx
flags
pText
nText
xToken
)
;
}
static
int
fts5CreateTokenizer_v2
(
fts5_api
*
pApi
const
char
*
zName
void
*
pUserData
fts5_tokenizer_v2
*
pTokenizer
void
(
*
xDestroy
)
(
void
*
)
)
{
Fts5Global
*
pGlobal
=
(
Fts5Global
*
)
pApi
;
int
rc
=
SQLITE_OK
;
if
(
pTokenizer
-
>
iVersion
>
2
)
{
rc
=
SQLITE_ERROR
;
}
else
{
Fts5TokenizerModule
*
pNew
=
0
;
rc
=
fts5NewTokenizerModule
(
pGlobal
zName
pUserData
xDestroy
&
pNew
)
;
if
(
pNew
)
{
pNew
-
>
x2
=
*
pTokenizer
;
pNew
-
>
bV2Native
=
1
;
pNew
-
>
x1
.
xCreate
=
fts5VtoVCreate
;
pNew
-
>
x1
.
xTokenize
=
fts5V1toV2Tokenize
;
pNew
-
>
x1
.
xDelete
=
fts5VtoVDelete
;
}
}
return
rc
;
}
static
int
fts5CreateTokenizer
(
fts5_api
*
pApi
const
char
*
zName
void
*
pUserData
fts5_tokenizer
*
pTokenizer
void
(
*
xDestroy
)
(
void
*
)
)
{
Fts5TokenizerModule
*
pNew
=
0
;
int
rc
=
SQLITE_OK
;
rc
=
fts5NewTokenizerModule
(
(
Fts5Global
*
)
pApi
zName
pUserData
xDestroy
&
pNew
)
;
if
(
pNew
)
{
pNew
-
>
x1
=
*
pTokenizer
;
pNew
-
>
x2
.
xCreate
=
fts5VtoVCreate
;
pNew
-
>
x2
.
xTokenize
=
fts5V2toV1Tokenize
;
pNew
-
>
x2
.
xDelete
=
fts5VtoVDelete
;
}
return
rc
;
}
static
Fts5TokenizerModule
*
fts5LocateTokenizer
(
Fts5Global
*
pGlobal
const
char
*
zName
)
{
Fts5TokenizerModule
*
pMod
=
0
;
if
(
zName
=
=
0
)
{
pMod
=
pGlobal
-
>
pDfltTok
;
}
else
{
for
(
pMod
=
pGlobal
-
>
pTok
;
pMod
;
pMod
=
pMod
-
>
pNext
)
{
if
(
sqlite3_stricmp
(
zName
pMod
-
>
zName
)
=
=
0
)
break
;
}
}
return
pMod
;
}
static
int
fts5FindTokenizer_v2
(
fts5_api
*
pApi
const
char
*
zName
void
*
*
ppUserData
fts5_tokenizer_v2
*
*
ppTokenizer
)
{
int
rc
=
SQLITE_OK
;
Fts5TokenizerModule
*
pMod
;
pMod
=
fts5LocateTokenizer
(
(
Fts5Global
*
)
pApi
zName
)
;
if
(
pMod
)
{
if
(
pMod
-
>
bV2Native
)
{
*
ppUserData
=
pMod
-
>
pUserData
;
}
else
{
*
ppUserData
=
(
void
*
)
pMod
;
}
*
ppTokenizer
=
&
pMod
-
>
x2
;
}
else
{
*
ppTokenizer
=
0
;
*
ppUserData
=
0
;
rc
=
SQLITE_ERROR
;
}
return
rc
;
}
static
int
fts5FindTokenizer
(
fts5_api
*
pApi
const
char
*
zName
void
*
*
ppUserData
fts5_tokenizer
*
pTokenizer
)
{
int
rc
=
SQLITE_OK
;
Fts5TokenizerModule
*
pMod
;
pMod
=
fts5LocateTokenizer
(
(
Fts5Global
*
)
pApi
zName
)
;
if
(
pMod
)
{
if
(
pMod
-
>
bV2Native
=
=
0
)
{
*
ppUserData
=
pMod
-
>
pUserData
;
}
else
{
*
ppUserData
=
(
void
*
)
pMod
;
}
*
pTokenizer
=
pMod
-
>
x1
;
}
else
{
memset
(
pTokenizer
0
sizeof
(
*
pTokenizer
)
)
;
*
ppUserData
=
0
;
rc
=
SQLITE_ERROR
;
}
return
rc
;
}
static
int
sqlite3Fts5LoadTokenizer
(
Fts5Config
*
pConfig
)
{
const
char
*
*
azArg
=
pConfig
-
>
t
.
azArg
;
const
int
nArg
=
pConfig
-
>
t
.
nArg
;
Fts5TokenizerModule
*
pMod
=
0
;
int
rc
=
SQLITE_OK
;
pMod
=
fts5LocateTokenizer
(
pConfig
-
>
pGlobal
nArg
=
=
0
?
0
:
azArg
[
0
]
)
;
if
(
pMod
=
=
0
)
{
assert
(
nArg
>
0
)
;
rc
=
SQLITE_ERROR
;
sqlite3Fts5ConfigErrmsg
(
pConfig
"
no
such
tokenizer
:
%
s
"
azArg
[
0
]
)
;
}
else
{
int
(
*
xCreate
)
(
void
*
const
char
*
*
int
Fts5Tokenizer
*
*
)
=
0
;
if
(
pMod
-
>
bV2Native
)
{
xCreate
=
pMod
-
>
x2
.
xCreate
;
pConfig
-
>
t
.
pApi2
=
&
pMod
-
>
x2
;
}
else
{
pConfig
-
>
t
.
pApi1
=
&
pMod
-
>
x1
;
xCreate
=
pMod
-
>
x1
.
xCreate
;
}
rc
=
xCreate
(
pMod
-
>
pUserData
(
azArg
?
&
azArg
[
1
]
:
0
)
(
nArg
?
nArg
-
1
:
0
)
&
pConfig
-
>
t
.
pTok
)
;
if
(
rc
!
=
SQLITE_OK
)
{
if
(
rc
!
=
SQLITE_NOMEM
)
{
sqlite3Fts5ConfigErrmsg
(
pConfig
"
error
in
tokenizer
constructor
"
)
;
}
}
else
if
(
pMod
-
>
bV2Native
=
=
0
)
{
pConfig
-
>
t
.
ePattern
=
sqlite3Fts5TokenizerPattern
(
pMod
-
>
x1
.
xCreate
pConfig
-
>
t
.
pTok
)
;
}
}
if
(
rc
!
=
SQLITE_OK
)
{
pConfig
-
>
t
.
pApi1
=
0
;
pConfig
-
>
t
.
pApi2
=
0
;
pConfig
-
>
t
.
pTok
=
0
;
}
return
rc
;
}
static
void
fts5ModuleDestroy
(
void
*
pCtx
)
{
Fts5TokenizerModule
*
pTok
*
pNextTok
;
Fts5Auxiliary
*
pAux
*
pNextAux
;
Fts5Global
*
pGlobal
=
(
Fts5Global
*
)
pCtx
;
for
(
pAux
=
pGlobal
-
>
pAux
;
pAux
;
pAux
=
pNextAux
)
{
pNextAux
=
pAux
-
>
pNext
;
if
(
pAux
-
>
xDestroy
)
pAux
-
>
xDestroy
(
pAux
-
>
pUserData
)
;
sqlite3_free
(
pAux
)
;
}
for
(
pTok
=
pGlobal
-
>
pTok
;
pTok
;
pTok
=
pNextTok
)
{
pNextTok
=
pTok
-
>
pNext
;
if
(
pTok
-
>
xDestroy
)
pTok
-
>
xDestroy
(
pTok
-
>
pUserData
)
;
sqlite3_free
(
pTok
)
;
}
sqlite3_free
(
pGlobal
)
;
}
static
void
fts5Fts5Func
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apArg
)
{
Fts5Global
*
pGlobal
=
(
Fts5Global
*
)
sqlite3_user_data
(
pCtx
)
;
fts5_api
*
*
ppApi
;
UNUSED_PARAM
(
nArg
)
;
assert
(
nArg
=
=
1
)
;
ppApi
=
(
fts5_api
*
*
)
sqlite3_value_pointer
(
apArg
[
0
]
"
fts5_api_ptr
"
)
;
if
(
ppApi
)
*
ppApi
=
&
pGlobal
-
>
api
;
}
static
void
fts5SourceIdFunc
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apUnused
)
{
assert
(
nArg
=
=
0
)
;
UNUSED_PARAM2
(
nArg
apUnused
)
;
sqlite3_result_text
(
pCtx
"
fts5
:
2025
-
02
-
18
13
:
38
:
58
873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70
"
-
1
SQLITE_TRANSIENT
)
;
}
static
void
fts5LocaleFunc
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apArg
)
{
const
char
*
zLocale
=
0
;
int
nLocale
=
0
;
const
char
*
zText
=
0
;
int
nText
=
0
;
assert
(
nArg
=
=
2
)
;
UNUSED_PARAM
(
nArg
)
;
zLocale
=
(
const
char
*
)
sqlite3_value_text
(
apArg
[
0
]
)
;
nLocale
=
sqlite3_value_bytes
(
apArg
[
0
]
)
;
zText
=
(
const
char
*
)
sqlite3_value_text
(
apArg
[
1
]
)
;
nText
=
sqlite3_value_bytes
(
apArg
[
1
]
)
;
if
(
zLocale
=
=
0
|
|
zLocale
[
0
]
=
=
'
\
0
'
)
{
sqlite3_result_text
(
pCtx
zText
nText
SQLITE_TRANSIENT
)
;
}
else
{
Fts5Global
*
p
=
(
Fts5Global
*
)
sqlite3_user_data
(
pCtx
)
;
u8
*
pBlob
=
0
;
u8
*
pCsr
=
0
;
int
nBlob
=
0
;
nBlob
=
FTS5_LOCALE_HDR_SIZE
+
nLocale
+
1
+
nText
;
pBlob
=
(
u8
*
)
sqlite3_malloc
(
nBlob
)
;
if
(
pBlob
=
=
0
)
{
sqlite3_result_error_nomem
(
pCtx
)
;
return
;
}
pCsr
=
pBlob
;
memcpy
(
pCsr
(
const
u8
*
)
p
-
>
aLocaleHdr
FTS5_LOCALE_HDR_SIZE
)
;
pCsr
+
=
FTS5_LOCALE_HDR_SIZE
;
memcpy
(
pCsr
zLocale
nLocale
)
;
pCsr
+
=
nLocale
;
(
*
pCsr
+
+
)
=
0x00
;
if
(
zText
)
memcpy
(
pCsr
zText
nText
)
;
assert
(
&
pCsr
[
nText
]
=
=
&
pBlob
[
nBlob
]
)
;
sqlite3_result_blob
(
pCtx
pBlob
nBlob
sqlite3_free
)
;
}
}
static
void
fts5InsttokenFunc
(
sqlite3_context
*
pCtx
int
nArg
sqlite3_value
*
*
apArg
)
{
assert
(
nArg
=
=
1
)
;
(
void
)
nArg
;
sqlite3_result_value
(
pCtx
apArg
[
0
]
)
;
sqlite3_result_subtype
(
pCtx
FTS5_INSTTOKEN_SUBTYPE
)
;
}
static
int
fts5ShadowName
(
const
char
*
zName
)
{
static
const
char
*
azName
[
]
=
{
"
config
"
"
content
"
"
data
"
"
docsize
"
"
idx
"
}
;
unsigned
int
i
;
for
(
i
=
0
;
i
<
sizeof
(
azName
)
/
sizeof
(
azName
[
0
]
)
;
i
+
+
)
{
if
(
sqlite3_stricmp
(
zName
azName
[
i
]
)
=
=
0
)
return
1
;
}
return
0
;
}
static
int
fts5IntegrityMethod
(
sqlite3_vtab
*
pVtab
const
char
*
zSchema
const
char
*
zTabname
int
isQuick
char
*
*
pzErr
)
{
Fts5FullTable
*
pTab
=
(
Fts5FullTable
*
)
pVtab
;
int
rc
;
assert
(
pzErr
!
=
0
&
&
*
pzErr
=
=
0
)
;
UNUSED_PARAM
(
isQuick
)
;
assert
(
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
=
0
)
;
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
pzErr
;
rc
=
sqlite3Fts5StorageIntegrity
(
pTab
-
>
pStorage
0
)
;
if
(
*
pzErr
=
=
0
&
&
rc
!
=
SQLITE_OK
)
{
if
(
(
rc
&
0xff
)
=
=
SQLITE_CORRUPT
)
{
*
pzErr
=
sqlite3_mprintf
(
"
malformed
inverted
index
for
FTS5
table
%
s
.
%
s
"
zSchema
zTabname
)
;
rc
=
(
*
pzErr
)
?
SQLITE_OK
:
SQLITE_NOMEM
;
}
else
{
*
pzErr
=
sqlite3_mprintf
(
"
unable
to
validate
the
inverted
index
for
"
"
FTS5
table
%
s
.
%
s
:
%
s
"
zSchema
zTabname
sqlite3_errstr
(
rc
)
)
;
}
}
sqlite3Fts5IndexCloseReader
(
pTab
-
>
p
.
pIndex
)
;
pTab
-
>
p
.
pConfig
-
>
pzErrmsg
=
0
;
return
rc
;
}
static
int
fts5Init
(
sqlite3
*
db
)
{
static
const
sqlite3_module
fts5Mod
=
{
4
fts5CreateMethod
fts5ConnectMethod
fts5BestIndexMethod
fts5DisconnectMethod
fts5DestroyMethod
fts5OpenMethod
fts5CloseMethod
fts5FilterMethod
fts5NextMethod
fts5EofMethod
fts5ColumnMethod
fts5RowidMethod
fts5UpdateMethod
fts5BeginMethod
fts5SyncMethod
fts5CommitMethod
fts5RollbackMethod
fts5FindFunctionMethod
fts5RenameMethod
fts5SavepointMethod
fts5ReleaseMethod
fts5RollbackToMethod
fts5ShadowName
fts5IntegrityMethod
}
;
int
rc
;
Fts5Global
*
pGlobal
=
0
;
pGlobal
=
(
Fts5Global
*
)
sqlite3_malloc
(
sizeof
(
Fts5Global
)
)
;
if
(
pGlobal
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
void
*
p
=
(
void
*
)
pGlobal
;
memset
(
pGlobal
0
sizeof
(
Fts5Global
)
)
;
pGlobal
-
>
db
=
db
;
pGlobal
-
>
api
.
iVersion
=
3
;
pGlobal
-
>
api
.
xCreateFunction
=
fts5CreateAux
;
pGlobal
-
>
api
.
xCreateTokenizer
=
fts5CreateTokenizer
;
pGlobal
-
>
api
.
xFindTokenizer
=
fts5FindTokenizer
;
pGlobal
-
>
api
.
xCreateTokenizer_v2
=
fts5CreateTokenizer_v2
;
pGlobal
-
>
api
.
xFindTokenizer_v2
=
fts5FindTokenizer_v2
;
sqlite3_randomness
(
sizeof
(
pGlobal
-
>
aLocaleHdr
)
pGlobal
-
>
aLocaleHdr
)
;
pGlobal
-
>
aLocaleHdr
[
0
]
^
=
0xF924976D
;
pGlobal
-
>
aLocaleHdr
[
1
]
^
=
0x16596E13
;
pGlobal
-
>
aLocaleHdr
[
2
]
^
=
0x7C80BEAA
;
pGlobal
-
>
aLocaleHdr
[
3
]
^
=
0x9B03A67F
;
assert
(
sizeof
(
pGlobal
-
>
aLocaleHdr
)
=
=
16
)
;
rc
=
sqlite3_create_module_v2
(
db
"
fts5
"
&
fts5Mod
p
fts5ModuleDestroy
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
sqlite3Fts5IndexInit
(
db
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
sqlite3Fts5ExprInit
(
pGlobal
db
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
sqlite3Fts5AuxInit
(
&
pGlobal
-
>
api
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
sqlite3Fts5TokenizerInit
(
&
pGlobal
-
>
api
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
sqlite3Fts5VocabInit
(
pGlobal
db
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_create_function
(
db
"
fts5
"
1
SQLITE_UTF8
p
fts5Fts5Func
0
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_create_function
(
db
"
fts5_source_id
"
0
SQLITE_UTF8
|
SQLITE_DETERMINISTIC
|
SQLITE_INNOCUOUS
p
fts5SourceIdFunc
0
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_create_function
(
db
"
fts5_locale
"
2
SQLITE_UTF8
|
SQLITE_INNOCUOUS
|
SQLITE_RESULT_SUBTYPE
|
SQLITE_SUBTYPE
p
fts5LocaleFunc
0
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3_create_function
(
db
"
fts5_insttoken
"
1
SQLITE_UTF8
|
SQLITE_INNOCUOUS
|
SQLITE_RESULT_SUBTYPE
p
fts5InsttokenFunc
0
0
)
;
}
}
#
ifdef
SQLITE_FTS5_ENABLE_TEST_MI
if
(
rc
=
=
SQLITE_OK
)
{
extern
int
sqlite3Fts5TestRegisterMatchinfo
(
sqlite3
*
)
;
rc
=
sqlite3Fts5TestRegisterMatchinfo
(
db
)
;
}
#
endif
return
rc
;
}
#
ifndef
SQLITE_CORE
#
ifdef
_WIN32
__declspec
(
dllexport
)
#
endif
int
sqlite3_fts_init
(
sqlite3
*
db
char
*
*
pzErrMsg
const
sqlite3_api_routines
*
pApi
)
{
SQLITE_EXTENSION_INIT2
(
pApi
)
;
(
void
)
pzErrMsg
;
return
fts5Init
(
db
)
;
}
#
ifdef
_WIN32
__declspec
(
dllexport
)
#
endif
int
sqlite3_fts5_init
(
sqlite3
*
db
char
*
*
pzErrMsg
const
sqlite3_api_routines
*
pApi
)
{
SQLITE_EXTENSION_INIT2
(
pApi
)
;
(
void
)
pzErrMsg
;
return
fts5Init
(
db
)
;
}
#
else
int
sqlite3Fts5Init
(
sqlite3
*
db
)
{
return
fts5Init
(
db
)
;
}
#
endif
#
line
1
"
fts5_storage
.
c
"
struct
Fts5Storage
{
Fts5Config
*
pConfig
;
Fts5Index
*
pIndex
;
int
bTotalsValid
;
i64
nTotalRow
;
i64
*
aTotalSize
;
sqlite3_stmt
*
pSavedRow
;
sqlite3_stmt
*
aStmt
[
12
]
;
}
;
#
if
FTS5_STMT_SCAN_ASC
!
=
0
#
error
"
FTS5_STMT_SCAN_ASC
mismatch
"
#
endif
#
if
FTS5_STMT_SCAN_DESC
!
=
1
#
error
"
FTS5_STMT_SCAN_DESC
mismatch
"
#
endif
#
if
FTS5_STMT_LOOKUP
!
=
2
#
error
"
FTS5_STMT_LOOKUP
mismatch
"
#
endif
#
define
FTS5_STMT_LOOKUP2
3
#
define
FTS5_STMT_INSERT_CONTENT
4
#
define
FTS5_STMT_REPLACE_CONTENT
5
#
define
FTS5_STMT_DELETE_CONTENT
6
#
define
FTS5_STMT_REPLACE_DOCSIZE
7
#
define
FTS5_STMT_DELETE_DOCSIZE
8
#
define
FTS5_STMT_LOOKUP_DOCSIZE
9
#
define
FTS5_STMT_REPLACE_CONFIG
10
#
define
FTS5_STMT_SCAN
11
static
int
fts5StorageGetStmt
(
Fts5Storage
*
p
int
eStmt
sqlite3_stmt
*
*
ppStmt
char
*
*
pzErrMsg
)
{
int
rc
=
SQLITE_OK
;
assert
(
p
-
>
pConfig
-
>
bColumnsize
|
|
(
eStmt
!
=
FTS5_STMT_REPLACE_DOCSIZE
&
&
eStmt
!
=
FTS5_STMT_DELETE_DOCSIZE
&
&
eStmt
!
=
FTS5_STMT_LOOKUP_DOCSIZE
)
)
;
assert
(
eStmt
>
=
0
&
&
eStmt
<
ArraySize
(
p
-
>
aStmt
)
)
;
if
(
p
-
>
aStmt
[
eStmt
]
=
=
0
)
{
const
char
*
azStmt
[
]
=
{
"
SELECT
%
s
FROM
%
s
T
WHERE
T
.
%
Q
>
=
?
AND
T
.
%
Q
<
=
?
ORDER
BY
T
.
%
Q
ASC
"
"
SELECT
%
s
FROM
%
s
T
WHERE
T
.
%
Q
<
=
?
AND
T
.
%
Q
>
=
?
ORDER
BY
T
.
%
Q
DESC
"
"
SELECT
%
s
FROM
%
s
T
WHERE
T
.
%
Q
=
?
"
"
SELECT
%
s
FROM
%
s
T
WHERE
T
.
%
Q
=
?
"
"
INSERT
INTO
%
Q
.
'
%
q_content
'
VALUES
(
%
s
)
"
"
REPLACE
INTO
%
Q
.
'
%
q_content
'
VALUES
(
%
s
)
"
"
DELETE
FROM
%
Q
.
'
%
q_content
'
WHERE
id
=
?
"
"
REPLACE
INTO
%
Q
.
'
%
q_docsize
'
VALUES
(
?
?
%
s
)
"
"
DELETE
FROM
%
Q
.
'
%
q_docsize
'
WHERE
id
=
?
"
"
SELECT
sz
%
s
FROM
%
Q
.
'
%
q_docsize
'
WHERE
id
=
?
"
"
REPLACE
INTO
%
Q
.
'
%
q_config
'
VALUES
(
?
?
)
"
"
SELECT
%
s
FROM
%
s
AS
T
"
}
;
Fts5Config
*
pC
=
p
-
>
pConfig
;
char
*
zSql
=
0
;
assert
(
ArraySize
(
azStmt
)
=
=
ArraySize
(
p
-
>
aStmt
)
)
;
switch
(
eStmt
)
{
case
FTS5_STMT_SCAN
:
zSql
=
sqlite3_mprintf
(
azStmt
[
eStmt
]
pC
-
>
zContentExprlist
pC
-
>
zContent
)
;
break
;
case
FTS5_STMT_SCAN_ASC
:
case
FTS5_STMT_SCAN_DESC
:
zSql
=
sqlite3_mprintf
(
azStmt
[
eStmt
]
pC
-
>
zContentExprlist
pC
-
>
zContent
pC
-
>
zContentRowid
pC
-
>
zContentRowid
pC
-
>
zContentRowid
)
;
break
;
case
FTS5_STMT_LOOKUP
:
case
FTS5_STMT_LOOKUP2
:
zSql
=
sqlite3_mprintf
(
azStmt
[
eStmt
]
pC
-
>
zContentExprlist
pC
-
>
zContent
pC
-
>
zContentRowid
)
;
break
;
case
FTS5_STMT_INSERT_CONTENT
:
case
FTS5_STMT_REPLACE_CONTENT
:
{
char
*
zBind
=
0
;
int
i
;
assert
(
pC
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pC
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
(
pC
-
>
nCol
+
1
)
;
i
+
+
)
{
if
(
!
i
|
|
pC
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pC
-
>
abUnindexed
[
i
-
1
]
)
{
zBind
=
sqlite3Fts5Mprintf
(
&
rc
"
%
z
%
s
?
%
d
"
zBind
zBind
?
"
"
:
"
"
i
+
1
)
;
}
}
if
(
pC
-
>
bLocale
&
&
pC
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
pC
-
>
nCol
;
i
+
+
)
{
if
(
pC
-
>
abUnindexed
[
i
]
=
=
0
)
{
zBind
=
sqlite3Fts5Mprintf
(
&
rc
"
%
z
?
%
d
"
zBind
pC
-
>
nCol
+
i
+
2
)
;
}
}
}
zSql
=
sqlite3Fts5Mprintf
(
&
rc
azStmt
[
eStmt
]
pC
-
>
zDb
pC
-
>
zName
zBind
)
;
sqlite3_free
(
zBind
)
;
break
;
}
case
FTS5_STMT_REPLACE_DOCSIZE
:
zSql
=
sqlite3_mprintf
(
azStmt
[
eStmt
]
pC
-
>
zDb
pC
-
>
zName
(
pC
-
>
bContentlessDelete
?
"
?
"
:
"
"
)
)
;
break
;
case
FTS5_STMT_LOOKUP_DOCSIZE
:
zSql
=
sqlite3_mprintf
(
azStmt
[
eStmt
]
(
pC
-
>
bContentlessDelete
?
"
origin
"
:
"
"
)
pC
-
>
zDb
pC
-
>
zName
)
;
break
;
default
:
zSql
=
sqlite3_mprintf
(
azStmt
[
eStmt
]
pC
-
>
zDb
pC
-
>
zName
)
;
break
;
}
if
(
zSql
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
int
f
=
SQLITE_PREPARE_PERSISTENT
;
if
(
eStmt
>
FTS5_STMT_LOOKUP2
)
f
|
=
SQLITE_PREPARE_NO_VTAB
;
p
-
>
pConfig
-
>
bLock
+
+
;
rc
=
sqlite3_prepare_v3
(
pC
-
>
db
zSql
-
1
f
&
p
-
>
aStmt
[
eStmt
]
0
)
;
p
-
>
pConfig
-
>
bLock
-
-
;
sqlite3_free
(
zSql
)
;
if
(
rc
!
=
SQLITE_OK
&
&
pzErrMsg
)
{
*
pzErrMsg
=
sqlite3_mprintf
(
"
%
s
"
sqlite3_errmsg
(
pC
-
>
db
)
)
;
}
if
(
rc
=
=
SQLITE_ERROR
&
&
eStmt
>
FTS5_STMT_LOOKUP2
&
&
eStmt
<
FTS5_STMT_SCAN
)
{
rc
=
SQLITE_CORRUPT
;
}
}
}
*
ppStmt
=
p
-
>
aStmt
[
eStmt
]
;
sqlite3_reset
(
*
ppStmt
)
;
return
rc
;
}
static
int
fts5ExecPrintf
(
sqlite3
*
db
char
*
*
pzErr
const
char
*
zFormat
.
.
.
)
{
int
rc
;
va_list
ap
;
char
*
zSql
;
va_start
(
ap
zFormat
)
;
zSql
=
sqlite3_vmprintf
(
zFormat
ap
)
;
if
(
zSql
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
rc
=
sqlite3_exec
(
db
zSql
0
0
pzErr
)
;
sqlite3_free
(
zSql
)
;
}
va_end
(
ap
)
;
return
rc
;
}
static
int
sqlite3Fts5DropAll
(
Fts5Config
*
pConfig
)
{
int
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
DROP
TABLE
IF
EXISTS
%
Q
.
'
%
q_data
'
;
"
"
DROP
TABLE
IF
EXISTS
%
Q
.
'
%
q_idx
'
;
"
"
DROP
TABLE
IF
EXISTS
%
Q
.
'
%
q_config
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
pConfig
-
>
zDb
pConfig
-
>
zName
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
bColumnsize
)
{
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
DROP
TABLE
IF
EXISTS
%
Q
.
'
%
q_docsize
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
DROP
TABLE
IF
EXISTS
%
Q
.
'
%
q_content
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
}
return
rc
;
}
static
void
fts5StorageRenameOne
(
Fts5Config
*
pConfig
int
*
pRc
const
char
*
zTail
const
char
*
zName
)
{
if
(
*
pRc
=
=
SQLITE_OK
)
{
*
pRc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
ALTER
TABLE
%
Q
.
'
%
q_
%
s
'
RENAME
TO
'
%
q_
%
s
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
zTail
zName
zTail
)
;
}
}
static
int
sqlite3Fts5StorageRename
(
Fts5Storage
*
pStorage
const
char
*
zName
)
{
Fts5Config
*
pConfig
=
pStorage
-
>
pConfig
;
int
rc
=
sqlite3Fts5StorageSync
(
pStorage
)
;
fts5StorageRenameOne
(
pConfig
&
rc
"
data
"
zName
)
;
fts5StorageRenameOne
(
pConfig
&
rc
"
idx
"
zName
)
;
fts5StorageRenameOne
(
pConfig
&
rc
"
config
"
zName
)
;
if
(
pConfig
-
>
bColumnsize
)
{
fts5StorageRenameOne
(
pConfig
&
rc
"
docsize
"
zName
)
;
}
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
fts5StorageRenameOne
(
pConfig
&
rc
"
content
"
zName
)
;
}
return
rc
;
}
static
int
sqlite3Fts5CreateTable
(
Fts5Config
*
pConfig
const
char
*
zPost
const
char
*
zDefn
int
bWithout
char
*
*
pzErr
)
{
int
rc
;
char
*
zErr
=
0
;
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
&
zErr
"
CREATE
TABLE
%
Q
.
'
%
q_
%
q
'
(
%
s
)
%
s
"
pConfig
-
>
zDb
pConfig
-
>
zName
zPost
zDefn
#
ifndef
SQLITE_FTS5_NO_WITHOUT_ROWID
bWithout
?
"
WITHOUT
ROWID
"
:
#
endif
"
"
)
;
if
(
zErr
)
{
*
pzErr
=
sqlite3_mprintf
(
"
fts5
:
error
creating
shadow
table
%
q_
%
s
:
%
s
"
pConfig
-
>
zName
zPost
zErr
)
;
sqlite3_free
(
zErr
)
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageOpen
(
Fts5Config
*
pConfig
Fts5Index
*
pIndex
int
bCreate
Fts5Storage
*
*
pp
char
*
*
pzErr
)
{
int
rc
=
SQLITE_OK
;
Fts5Storage
*
p
;
sqlite3_int64
nByte
;
nByte
=
sizeof
(
Fts5Storage
)
+
pConfig
-
>
nCol
*
sizeof
(
i64
)
;
*
pp
=
p
=
(
Fts5Storage
*
)
sqlite3_malloc64
(
nByte
)
;
if
(
!
p
)
return
SQLITE_NOMEM
;
memset
(
p
0
(
size_t
)
nByte
)
;
p
-
>
aTotalSize
=
(
i64
*
)
&
p
[
1
]
;
p
-
>
pConfig
=
pConfig
;
p
-
>
pIndex
=
pIndex
;
if
(
bCreate
)
{
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pConfig
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
{
int
nDefn
=
32
+
pConfig
-
>
nCol
*
10
;
char
*
zDefn
=
sqlite3_malloc64
(
32
+
(
sqlite3_int64
)
pConfig
-
>
nCol
*
20
)
;
if
(
zDefn
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
int
i
;
int
iOff
;
sqlite3_snprintf
(
nDefn
zDefn
"
id
INTEGER
PRIMARY
KEY
"
)
;
iOff
=
(
int
)
strlen
(
zDefn
)
;
for
(
i
=
0
;
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pConfig
-
>
abUnindexed
[
i
]
)
{
sqlite3_snprintf
(
nDefn
-
iOff
&
zDefn
[
iOff
]
"
c
%
d
"
i
)
;
iOff
+
=
(
int
)
strlen
(
&
zDefn
[
iOff
]
)
;
}
}
if
(
pConfig
-
>
bLocale
)
{
for
(
i
=
0
;
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
if
(
pConfig
-
>
abUnindexed
[
i
]
=
=
0
)
{
sqlite3_snprintf
(
nDefn
-
iOff
&
zDefn
[
iOff
]
"
l
%
d
"
i
)
;
iOff
+
=
(
int
)
strlen
(
&
zDefn
[
iOff
]
)
;
}
}
}
rc
=
sqlite3Fts5CreateTable
(
pConfig
"
content
"
zDefn
0
pzErr
)
;
}
sqlite3_free
(
zDefn
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
bColumnsize
)
{
const
char
*
zCols
=
"
id
INTEGER
PRIMARY
KEY
sz
BLOB
"
;
if
(
pConfig
-
>
bContentlessDelete
)
{
zCols
=
"
id
INTEGER
PRIMARY
KEY
sz
BLOB
origin
INTEGER
"
;
}
rc
=
sqlite3Fts5CreateTable
(
pConfig
"
docsize
"
zCols
0
pzErr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5CreateTable
(
pConfig
"
config
"
"
k
PRIMARY
KEY
v
"
1
pzErr
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageConfigValue
(
p
"
version
"
0
FTS5_CURRENT_VERSION
)
;
}
}
if
(
rc
)
{
sqlite3Fts5StorageClose
(
p
)
;
*
pp
=
0
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageClose
(
Fts5Storage
*
p
)
{
int
rc
=
SQLITE_OK
;
if
(
p
)
{
int
i
;
for
(
i
=
0
;
i
<
ArraySize
(
p
-
>
aStmt
)
;
i
+
+
)
{
sqlite3_finalize
(
p
-
>
aStmt
[
i
]
)
;
}
sqlite3_free
(
p
)
;
}
return
rc
;
}
typedef
struct
Fts5InsertCtx
Fts5InsertCtx
;
struct
Fts5InsertCtx
{
Fts5Storage
*
pStorage
;
int
iCol
;
int
szCol
;
}
;
static
int
fts5StorageInsertCallback
(
void
*
pContext
int
tflags
const
char
*
pToken
int
nToken
int
iUnused1
int
iUnused2
)
{
Fts5InsertCtx
*
pCtx
=
(
Fts5InsertCtx
*
)
pContext
;
Fts5Index
*
pIdx
=
pCtx
-
>
pStorage
-
>
pIndex
;
UNUSED_PARAM2
(
iUnused1
iUnused2
)
;
if
(
nToken
>
FTS5_MAX_TOKEN_SIZE
)
nToken
=
FTS5_MAX_TOKEN_SIZE
;
if
(
(
tflags
&
FTS5_TOKEN_COLOCATED
)
=
=
0
|
|
pCtx
-
>
szCol
=
=
0
)
{
pCtx
-
>
szCol
+
+
;
}
return
sqlite3Fts5IndexWrite
(
pIdx
pCtx
-
>
iCol
pCtx
-
>
szCol
-
1
pToken
nToken
)
;
}
static
int
sqlite3Fts5StorageFindDeleteRow
(
Fts5Storage
*
p
i64
iDel
)
{
int
rc
=
SQLITE_OK
;
sqlite3_stmt
*
pSeek
=
0
;
assert
(
p
-
>
pSavedRow
=
=
0
)
;
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_LOOKUP
+
1
&
pSeek
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int64
(
pSeek
1
iDel
)
;
if
(
sqlite3_step
(
pSeek
)
!
=
SQLITE_ROW
)
{
rc
=
sqlite3_reset
(
pSeek
)
;
}
else
{
p
-
>
pSavedRow
=
pSeek
;
}
}
return
rc
;
}
static
int
fts5StorageDeleteFromIndex
(
Fts5Storage
*
p
i64
iDel
sqlite3_value
*
*
apVal
int
bSaveRow
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
sqlite3_stmt
*
pSeek
=
0
;
int
rc
=
SQLITE_OK
;
int
rc2
;
int
iCol
;
Fts5InsertCtx
ctx
;
assert
(
bSaveRow
=
=
0
|
|
apVal
=
=
0
)
;
assert
(
bSaveRow
=
=
0
|
|
bSaveRow
=
=
1
)
;
assert
(
FTS5_STMT_LOOKUP2
=
=
FTS5_STMT_LOOKUP
+
1
)
;
if
(
apVal
=
=
0
)
{
if
(
p
-
>
pSavedRow
&
&
bSaveRow
)
{
pSeek
=
p
-
>
pSavedRow
;
p
-
>
pSavedRow
=
0
;
}
else
{
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_LOOKUP
+
bSaveRow
&
pSeek
0
)
;
if
(
rc
!
=
SQLITE_OK
)
return
rc
;
sqlite3_bind_int64
(
pSeek
1
iDel
)
;
if
(
sqlite3_step
(
pSeek
)
!
=
SQLITE_ROW
)
{
return
sqlite3_reset
(
pSeek
)
;
}
}
}
ctx
.
pStorage
=
p
;
ctx
.
iCol
=
-
1
;
for
(
iCol
=
1
;
rc
=
=
SQLITE_OK
&
&
iCol
<
=
pConfig
-
>
nCol
;
iCol
+
+
)
{
if
(
pConfig
-
>
abUnindexed
[
iCol
-
1
]
=
=
0
)
{
sqlite3_value
*
pVal
=
0
;
const
char
*
pText
=
0
;
int
nText
=
0
;
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
assert
(
pSeek
=
=
0
|
|
apVal
=
=
0
)
;
assert
(
pSeek
!
=
0
|
|
apVal
!
=
0
)
;
if
(
pSeek
)
{
pVal
=
sqlite3_column_value
(
pSeek
iCol
)
;
}
else
{
pVal
=
apVal
[
iCol
-
1
]
;
}
if
(
pConfig
-
>
bLocale
&
&
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
&
pText
&
nText
&
pLoc
&
nLoc
)
;
}
else
{
pText
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
nText
=
sqlite3_value_bytes
(
pVal
)
;
if
(
pConfig
-
>
bLocale
&
&
pSeek
)
{
pLoc
=
(
const
char
*
)
sqlite3_column_text
(
pSeek
iCol
+
pConfig
-
>
nCol
)
;
nLoc
=
sqlite3_column_bytes
(
pSeek
iCol
+
pConfig
-
>
nCol
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5SetLocale
(
pConfig
pLoc
nLoc
)
;
ctx
.
szCol
=
0
;
rc
=
sqlite3Fts5Tokenize
(
pConfig
FTS5_TOKENIZE_DOCUMENT
pText
nText
(
void
*
)
&
ctx
fts5StorageInsertCallback
)
;
p
-
>
aTotalSize
[
iCol
-
1
]
-
=
(
i64
)
ctx
.
szCol
;
if
(
rc
=
=
SQLITE_OK
&
&
p
-
>
aTotalSize
[
iCol
-
1
]
<
0
)
{
rc
=
FTS5_CORRUPT
;
}
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
}
}
if
(
rc
=
=
SQLITE_OK
&
&
p
-
>
nTotalRow
<
1
)
{
rc
=
FTS5_CORRUPT
;
}
else
{
p
-
>
nTotalRow
-
-
;
}
if
(
rc
=
=
SQLITE_OK
&
&
bSaveRow
)
{
assert
(
p
-
>
pSavedRow
=
=
0
)
;
p
-
>
pSavedRow
=
pSeek
;
}
else
{
rc2
=
sqlite3_reset
(
pSeek
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
rc2
;
}
return
rc
;
}
static
void
sqlite3Fts5StorageReleaseDeleteRow
(
Fts5Storage
*
pStorage
)
{
assert
(
pStorage
-
>
pSavedRow
=
=
0
|
|
pStorage
-
>
pSavedRow
=
=
pStorage
-
>
aStmt
[
FTS5_STMT_LOOKUP2
]
)
;
sqlite3_reset
(
pStorage
-
>
pSavedRow
)
;
pStorage
-
>
pSavedRow
=
0
;
}
static
int
fts5StorageContentlessDelete
(
Fts5Storage
*
p
i64
iDel
)
{
i64
iOrigin
=
0
;
sqlite3_stmt
*
pLookup
=
0
;
int
rc
=
SQLITE_OK
;
assert
(
p
-
>
pConfig
-
>
bContentlessDelete
)
;
assert
(
p
-
>
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NONE
|
|
p
-
>
pConfig
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
;
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_LOOKUP_DOCSIZE
&
pLookup
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int64
(
pLookup
1
iDel
)
;
if
(
SQLITE_ROW
=
=
sqlite3_step
(
pLookup
)
)
{
iOrigin
=
sqlite3_column_int64
(
pLookup
1
)
;
}
rc
=
sqlite3_reset
(
pLookup
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
iOrigin
!
=
0
)
{
rc
=
sqlite3Fts5IndexContentlessDelete
(
p
-
>
pIndex
iOrigin
iDel
)
;
}
return
rc
;
}
static
int
fts5StorageInsertDocsize
(
Fts5Storage
*
p
i64
iRowid
Fts5Buffer
*
pBuf
)
{
int
rc
=
SQLITE_OK
;
if
(
p
-
>
pConfig
-
>
bColumnsize
)
{
sqlite3_stmt
*
pReplace
=
0
;
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_REPLACE_DOCSIZE
&
pReplace
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int64
(
pReplace
1
iRowid
)
;
if
(
p
-
>
pConfig
-
>
bContentlessDelete
)
{
i64
iOrigin
=
0
;
rc
=
sqlite3Fts5IndexGetOrigin
(
p
-
>
pIndex
&
iOrigin
)
;
sqlite3_bind_int64
(
pReplace
3
iOrigin
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_blob
(
pReplace
2
pBuf
-
>
p
pBuf
-
>
n
SQLITE_STATIC
)
;
sqlite3_step
(
pReplace
)
;
rc
=
sqlite3_reset
(
pReplace
)
;
sqlite3_bind_null
(
pReplace
2
)
;
}
}
return
rc
;
}
static
int
fts5StorageLoadTotals
(
Fts5Storage
*
p
int
bCache
)
{
int
rc
=
SQLITE_OK
;
if
(
p
-
>
bTotalsValid
=
=
0
)
{
rc
=
sqlite3Fts5IndexGetAverages
(
p
-
>
pIndex
&
p
-
>
nTotalRow
p
-
>
aTotalSize
)
;
p
-
>
bTotalsValid
=
bCache
;
}
return
rc
;
}
static
int
fts5StorageSaveTotals
(
Fts5Storage
*
p
)
{
int
nCol
=
p
-
>
pConfig
-
>
nCol
;
int
i
;
Fts5Buffer
buf
;
int
rc
=
SQLITE_OK
;
memset
(
&
buf
0
sizeof
(
buf
)
)
;
sqlite3Fts5BufferAppendVarint
(
&
rc
&
buf
p
-
>
nTotalRow
)
;
for
(
i
=
0
;
i
<
nCol
;
i
+
+
)
{
sqlite3Fts5BufferAppendVarint
(
&
rc
&
buf
p
-
>
aTotalSize
[
i
]
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexSetAverages
(
p
-
>
pIndex
buf
.
p
buf
.
n
)
;
}
sqlite3_free
(
buf
.
p
)
;
return
rc
;
}
static
int
sqlite3Fts5StorageDelete
(
Fts5Storage
*
p
i64
iDel
sqlite3_value
*
*
apVal
int
bSaveRow
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
rc
;
sqlite3_stmt
*
pDel
=
0
;
assert
(
pConfig
-
>
eContent
!
=
FTS5_CONTENT_NORMAL
|
|
apVal
=
=
0
)
;
rc
=
fts5StorageLoadTotals
(
p
1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexBeginWrite
(
p
-
>
pIndex
1
iDel
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
if
(
p
-
>
pConfig
-
>
bContentlessDelete
)
{
rc
=
fts5StorageContentlessDelete
(
p
iDel
)
;
if
(
rc
=
=
SQLITE_OK
&
&
bSaveRow
&
&
p
-
>
pConfig
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
{
rc
=
sqlite3Fts5StorageFindDeleteRow
(
p
iDel
)
;
}
}
else
{
rc
=
fts5StorageDeleteFromIndex
(
p
iDel
apVal
bSaveRow
)
;
}
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
bColumnsize
)
{
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_DELETE_DOCSIZE
&
pDel
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int64
(
pDel
1
iDel
)
;
sqlite3_step
(
pDel
)
;
rc
=
sqlite3_reset
(
pDel
)
;
}
}
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
pConfig
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
{
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_DELETE_CONTENT
&
pDel
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_int64
(
pDel
1
iDel
)
;
sqlite3_step
(
pDel
)
;
rc
=
sqlite3_reset
(
pDel
)
;
}
}
return
rc
;
}
static
int
sqlite3Fts5StorageDeleteAll
(
Fts5Storage
*
p
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
rc
;
p
-
>
bTotalsValid
=
0
;
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
DELETE
FROM
%
Q
.
'
%
q_data
'
;
"
"
DELETE
FROM
%
Q
.
'
%
q_idx
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
bColumnsize
)
{
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
DELETE
FROM
%
Q
.
'
%
q_docsize
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_UNINDEXED
)
{
rc
=
fts5ExecPrintf
(
pConfig
-
>
db
0
"
DELETE
FROM
%
Q
.
'
%
q_content
'
;
"
pConfig
-
>
zDb
pConfig
-
>
zName
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexReinit
(
p
-
>
pIndex
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5StorageConfigValue
(
p
"
version
"
0
FTS5_CURRENT_VERSION
)
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageRebuild
(
Fts5Storage
*
p
)
{
Fts5Buffer
buf
=
{
0
0
0
}
;
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
sqlite3_stmt
*
pScan
=
0
;
Fts5InsertCtx
ctx
;
int
rc
rc2
;
memset
(
&
ctx
0
sizeof
(
Fts5InsertCtx
)
)
;
ctx
.
pStorage
=
p
;
rc
=
sqlite3Fts5StorageDeleteAll
(
p
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5StorageLoadTotals
(
p
1
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_SCAN
&
pScan
pConfig
-
>
pzErrmsg
)
;
}
while
(
rc
=
=
SQLITE_OK
&
&
SQLITE_ROW
=
=
sqlite3_step
(
pScan
)
)
{
i64
iRowid
=
sqlite3_column_int64
(
pScan
0
)
;
sqlite3Fts5BufferZero
(
&
buf
)
;
rc
=
sqlite3Fts5IndexBeginWrite
(
p
-
>
pIndex
0
iRowid
)
;
for
(
ctx
.
iCol
=
0
;
rc
=
=
SQLITE_OK
&
&
ctx
.
iCol
<
pConfig
-
>
nCol
;
ctx
.
iCol
+
+
)
{
ctx
.
szCol
=
0
;
if
(
pConfig
-
>
abUnindexed
[
ctx
.
iCol
]
=
=
0
)
{
int
nText
=
0
;
const
char
*
pText
=
0
;
int
nLoc
=
0
;
const
char
*
pLoc
=
0
;
sqlite3_value
*
pVal
=
sqlite3_column_value
(
pScan
ctx
.
iCol
+
1
)
;
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
&
&
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
&
pText
&
nText
&
pLoc
&
nLoc
)
;
}
else
{
pText
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
nText
=
sqlite3_value_bytes
(
pVal
)
;
if
(
pConfig
-
>
bLocale
)
{
int
iCol
=
ctx
.
iCol
+
1
+
pConfig
-
>
nCol
;
pLoc
=
(
const
char
*
)
sqlite3_column_text
(
pScan
iCol
)
;
nLoc
=
sqlite3_column_bytes
(
pScan
iCol
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5SetLocale
(
pConfig
pLoc
nLoc
)
;
rc
=
sqlite3Fts5Tokenize
(
pConfig
FTS5_TOKENIZE_DOCUMENT
pText
nText
(
void
*
)
&
ctx
fts5StorageInsertCallback
)
;
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
}
sqlite3Fts5BufferAppendVarint
(
&
rc
&
buf
ctx
.
szCol
)
;
p
-
>
aTotalSize
[
ctx
.
iCol
]
+
=
(
i64
)
ctx
.
szCol
;
}
p
-
>
nTotalRow
+
+
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5StorageInsertDocsize
(
p
iRowid
&
buf
)
;
}
}
sqlite3_free
(
buf
.
p
)
;
rc2
=
sqlite3_reset
(
pScan
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
rc2
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5StorageSaveTotals
(
p
)
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageOptimize
(
Fts5Storage
*
p
)
{
return
sqlite3Fts5IndexOptimize
(
p
-
>
pIndex
)
;
}
static
int
sqlite3Fts5StorageMerge
(
Fts5Storage
*
p
int
nMerge
)
{
return
sqlite3Fts5IndexMerge
(
p
-
>
pIndex
nMerge
)
;
}
static
int
sqlite3Fts5StorageReset
(
Fts5Storage
*
p
)
{
return
sqlite3Fts5IndexReset
(
p
-
>
pIndex
)
;
}
static
int
fts5StorageNewRowid
(
Fts5Storage
*
p
i64
*
piRowid
)
{
int
rc
=
SQLITE_MISMATCH
;
if
(
p
-
>
pConfig
-
>
bColumnsize
)
{
sqlite3_stmt
*
pReplace
=
0
;
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_REPLACE_DOCSIZE
&
pReplace
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_null
(
pReplace
1
)
;
sqlite3_bind_null
(
pReplace
2
)
;
sqlite3_step
(
pReplace
)
;
rc
=
sqlite3_reset
(
pReplace
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
*
piRowid
=
sqlite3_last_insert_rowid
(
p
-
>
pConfig
-
>
db
)
;
}
}
return
rc
;
}
static
int
sqlite3Fts5StorageContentInsert
(
Fts5Storage
*
p
int
bReplace
sqlite3_value
*
*
apVal
i64
*
piRowid
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
rc
=
SQLITE_OK
;
if
(
pConfig
-
>
eContent
!
=
FTS5_CONTENT_NORMAL
&
&
pConfig
-
>
eContent
!
=
FTS5_CONTENT_UNINDEXED
)
{
if
(
sqlite3_value_type
(
apVal
[
1
]
)
=
=
SQLITE_INTEGER
)
{
*
piRowid
=
sqlite3_value_int64
(
apVal
[
1
]
)
;
}
else
{
rc
=
fts5StorageNewRowid
(
p
piRowid
)
;
}
}
else
{
sqlite3_stmt
*
pInsert
=
0
;
int
i
;
assert
(
FTS5_STMT_INSERT_CONTENT
+
1
=
=
FTS5_STMT_REPLACE_CONTENT
)
;
assert
(
bReplace
=
=
0
|
|
bReplace
=
=
1
)
;
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_INSERT_CONTENT
+
bReplace
&
pInsert
0
)
;
if
(
pInsert
)
sqlite3_clear_bindings
(
pInsert
)
;
sqlite3_bind_value
(
pInsert
1
apVal
[
1
]
)
;
for
(
i
=
2
;
rc
=
=
SQLITE_OK
&
&
i
<
=
pConfig
-
>
nCol
+
1
;
i
+
+
)
{
int
bUnindexed
=
pConfig
-
>
abUnindexed
[
i
-
2
]
;
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
bUnindexed
)
{
sqlite3_value
*
pVal
=
apVal
[
i
]
;
if
(
sqlite3_value_nochange
(
pVal
)
&
&
p
-
>
pSavedRow
)
{
pVal
=
sqlite3_column_value
(
p
-
>
pSavedRow
i
-
1
)
;
if
(
pConfig
-
>
bLocale
&
&
bUnindexed
=
=
0
)
{
sqlite3_bind_value
(
pInsert
pConfig
-
>
nCol
+
i
sqlite3_column_value
(
p
-
>
pSavedRow
pConfig
-
>
nCol
+
i
-
1
)
)
;
}
}
else
if
(
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
const
char
*
pText
=
0
;
const
char
*
pLoc
=
0
;
int
nText
=
0
;
int
nLoc
=
0
;
assert
(
pConfig
-
>
bLocale
)
;
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
&
pText
&
nText
&
pLoc
&
nLoc
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_text
(
pInsert
i
pText
nText
SQLITE_TRANSIENT
)
;
if
(
bUnindexed
=
=
0
)
{
int
iLoc
=
pConfig
-
>
nCol
+
i
;
sqlite3_bind_text
(
pInsert
iLoc
pLoc
nLoc
SQLITE_TRANSIENT
)
;
}
}
continue
;
}
rc
=
sqlite3_bind_value
(
pInsert
i
pVal
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_step
(
pInsert
)
;
rc
=
sqlite3_reset
(
pInsert
)
;
}
*
piRowid
=
sqlite3_last_insert_rowid
(
pConfig
-
>
db
)
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageIndexInsert
(
Fts5Storage
*
p
sqlite3_value
*
*
apVal
i64
iRowid
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
rc
=
SQLITE_OK
;
Fts5InsertCtx
ctx
;
Fts5Buffer
buf
;
memset
(
&
buf
0
sizeof
(
Fts5Buffer
)
)
;
ctx
.
pStorage
=
p
;
rc
=
fts5StorageLoadTotals
(
p
1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexBeginWrite
(
p
-
>
pIndex
0
iRowid
)
;
}
for
(
ctx
.
iCol
=
0
;
rc
=
=
SQLITE_OK
&
&
ctx
.
iCol
<
pConfig
-
>
nCol
;
ctx
.
iCol
+
+
)
{
ctx
.
szCol
=
0
;
if
(
pConfig
-
>
abUnindexed
[
ctx
.
iCol
]
=
=
0
)
{
int
nText
=
0
;
const
char
*
pText
=
0
;
int
nLoc
=
0
;
const
char
*
pLoc
=
0
;
sqlite3_value
*
pVal
=
apVal
[
ctx
.
iCol
+
2
]
;
if
(
p
-
>
pSavedRow
&
&
sqlite3_value_nochange
(
pVal
)
)
{
pVal
=
sqlite3_column_value
(
p
-
>
pSavedRow
ctx
.
iCol
+
1
)
;
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
&
&
pConfig
-
>
bLocale
)
{
int
iCol
=
ctx
.
iCol
+
1
+
pConfig
-
>
nCol
;
pLoc
=
(
const
char
*
)
sqlite3_column_text
(
p
-
>
pSavedRow
iCol
)
;
nLoc
=
sqlite3_column_bytes
(
p
-
>
pSavedRow
iCol
)
;
}
}
else
{
pVal
=
apVal
[
ctx
.
iCol
+
2
]
;
}
if
(
pConfig
-
>
bLocale
&
&
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
&
pText
&
nText
&
pLoc
&
nLoc
)
;
}
else
{
pText
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
nText
=
sqlite3_value_bytes
(
pVal
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5SetLocale
(
pConfig
pLoc
nLoc
)
;
rc
=
sqlite3Fts5Tokenize
(
pConfig
FTS5_TOKENIZE_DOCUMENT
pText
nText
(
void
*
)
&
ctx
fts5StorageInsertCallback
)
;
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
}
sqlite3Fts5BufferAppendVarint
(
&
rc
&
buf
ctx
.
szCol
)
;
p
-
>
aTotalSize
[
ctx
.
iCol
]
+
=
(
i64
)
ctx
.
szCol
;
}
p
-
>
nTotalRow
+
+
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5StorageInsertDocsize
(
p
iRowid
&
buf
)
;
}
sqlite3_free
(
buf
.
p
)
;
return
rc
;
}
static
int
fts5StorageCount
(
Fts5Storage
*
p
const
char
*
zSuffix
i64
*
pnRow
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
char
*
zSql
;
int
rc
;
zSql
=
sqlite3_mprintf
(
"
SELECT
count
(
*
)
FROM
%
Q
.
'
%
q_
%
s
'
"
pConfig
-
>
zDb
pConfig
-
>
zName
zSuffix
)
;
if
(
zSql
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
sqlite3_stmt
*
pCnt
=
0
;
rc
=
sqlite3_prepare_v2
(
pConfig
-
>
db
zSql
-
1
&
pCnt
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
if
(
SQLITE_ROW
=
=
sqlite3_step
(
pCnt
)
)
{
*
pnRow
=
sqlite3_column_int64
(
pCnt
0
)
;
}
rc
=
sqlite3_finalize
(
pCnt
)
;
}
}
sqlite3_free
(
zSql
)
;
return
rc
;
}
typedef
struct
Fts5IntegrityCtx
Fts5IntegrityCtx
;
struct
Fts5IntegrityCtx
{
i64
iRowid
;
int
iCol
;
int
szCol
;
u64
cksum
;
Fts5Termset
*
pTermset
;
Fts5Config
*
pConfig
;
}
;
static
int
fts5StorageIntegrityCallback
(
void
*
pContext
int
tflags
const
char
*
pToken
int
nToken
int
iUnused1
int
iUnused2
)
{
Fts5IntegrityCtx
*
pCtx
=
(
Fts5IntegrityCtx
*
)
pContext
;
Fts5Termset
*
pTermset
=
pCtx
-
>
pTermset
;
int
bPresent
;
int
ii
;
int
rc
=
SQLITE_OK
;
int
iPos
;
int
iCol
;
UNUSED_PARAM2
(
iUnused1
iUnused2
)
;
if
(
nToken
>
FTS5_MAX_TOKEN_SIZE
)
nToken
=
FTS5_MAX_TOKEN_SIZE
;
if
(
(
tflags
&
FTS5_TOKEN_COLOCATED
)
=
=
0
|
|
pCtx
-
>
szCol
=
=
0
)
{
pCtx
-
>
szCol
+
+
;
}
switch
(
pCtx
-
>
pConfig
-
>
eDetail
)
{
case
FTS5_DETAIL_FULL
:
iPos
=
pCtx
-
>
szCol
-
1
;
iCol
=
pCtx
-
>
iCol
;
break
;
case
FTS5_DETAIL_COLUMNS
:
iPos
=
pCtx
-
>
iCol
;
iCol
=
0
;
break
;
default
:
assert
(
pCtx
-
>
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
;
iPos
=
0
;
iCol
=
0
;
break
;
}
rc
=
sqlite3Fts5TermsetAdd
(
pTermset
0
pToken
nToken
&
bPresent
)
;
if
(
rc
=
=
SQLITE_OK
&
&
bPresent
=
=
0
)
{
pCtx
-
>
cksum
^
=
sqlite3Fts5IndexEntryCksum
(
pCtx
-
>
iRowid
iCol
iPos
0
pToken
nToken
)
;
}
for
(
ii
=
0
;
rc
=
=
SQLITE_OK
&
&
ii
<
pCtx
-
>
pConfig
-
>
nPrefix
;
ii
+
+
)
{
const
int
nChar
=
pCtx
-
>
pConfig
-
>
aPrefix
[
ii
]
;
int
nByte
=
sqlite3Fts5IndexCharlenToBytelen
(
pToken
nToken
nChar
)
;
if
(
nByte
)
{
rc
=
sqlite3Fts5TermsetAdd
(
pTermset
ii
+
1
pToken
nByte
&
bPresent
)
;
if
(
bPresent
=
=
0
)
{
pCtx
-
>
cksum
^
=
sqlite3Fts5IndexEntryCksum
(
pCtx
-
>
iRowid
iCol
iPos
ii
+
1
pToken
nByte
)
;
}
}
}
return
rc
;
}
static
int
sqlite3Fts5StorageIntegrity
(
Fts5Storage
*
p
int
iArg
)
{
Fts5Config
*
pConfig
=
p
-
>
pConfig
;
int
rc
=
SQLITE_OK
;
int
*
aColSize
;
i64
*
aTotalSize
;
Fts5IntegrityCtx
ctx
;
sqlite3_stmt
*
pScan
;
int
bUseCksum
;
memset
(
&
ctx
0
sizeof
(
Fts5IntegrityCtx
)
)
;
ctx
.
pConfig
=
p
-
>
pConfig
;
aTotalSize
=
(
i64
*
)
sqlite3_malloc64
(
pConfig
-
>
nCol
*
(
sizeof
(
int
)
+
sizeof
(
i64
)
)
)
;
if
(
!
aTotalSize
)
return
SQLITE_NOMEM
;
aColSize
=
(
int
*
)
&
aTotalSize
[
pConfig
-
>
nCol
]
;
memset
(
aTotalSize
0
sizeof
(
i64
)
*
pConfig
-
>
nCol
)
;
bUseCksum
=
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
|
|
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
&
&
iArg
)
)
;
if
(
bUseCksum
)
{
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_SCAN
&
pScan
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
int
rc2
;
while
(
SQLITE_ROW
=
=
sqlite3_step
(
pScan
)
)
{
int
i
;
ctx
.
iRowid
=
sqlite3_column_int64
(
pScan
0
)
;
ctx
.
szCol
=
0
;
if
(
pConfig
-
>
bColumnsize
)
{
rc
=
sqlite3Fts5StorageDocsize
(
p
ctx
.
iRowid
aColSize
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_NONE
)
{
rc
=
sqlite3Fts5TermsetNew
(
&
ctx
.
pTermset
)
;
}
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
if
(
pConfig
-
>
abUnindexed
[
i
]
=
=
0
)
{
const
char
*
pText
=
0
;
int
nText
=
0
;
const
char
*
pLoc
=
0
;
int
nLoc
=
0
;
sqlite3_value
*
pVal
=
sqlite3_column_value
(
pScan
i
+
1
)
;
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_EXTERNAL
&
&
sqlite3Fts5IsLocaleValue
(
pConfig
pVal
)
)
{
rc
=
sqlite3Fts5DecodeLocaleValue
(
pVal
&
pText
&
nText
&
pLoc
&
nLoc
)
;
}
else
{
if
(
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
&
&
pConfig
-
>
bLocale
)
{
int
iCol
=
i
+
1
+
pConfig
-
>
nCol
;
pLoc
=
(
const
char
*
)
sqlite3_column_text
(
pScan
iCol
)
;
nLoc
=
sqlite3_column_bytes
(
pScan
iCol
)
;
}
pText
=
(
const
char
*
)
sqlite3_value_text
(
pVal
)
;
nText
=
sqlite3_value_bytes
(
pVal
)
;
}
ctx
.
iCol
=
i
;
ctx
.
szCol
=
0
;
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
{
rc
=
sqlite3Fts5TermsetNew
(
&
ctx
.
pTermset
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5SetLocale
(
pConfig
pLoc
nLoc
)
;
rc
=
sqlite3Fts5Tokenize
(
pConfig
FTS5_TOKENIZE_DOCUMENT
pText
nText
(
void
*
)
&
ctx
fts5StorageIntegrityCallback
)
;
sqlite3Fts5ClearLocale
(
pConfig
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
bColumnsize
&
&
ctx
.
szCol
!
=
aColSize
[
i
]
)
{
rc
=
FTS5_CORRUPT
;
}
aTotalSize
[
i
]
+
=
ctx
.
szCol
;
if
(
pConfig
-
>
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
{
sqlite3Fts5TermsetFree
(
ctx
.
pTermset
)
;
ctx
.
pTermset
=
0
;
}
}
}
sqlite3Fts5TermsetFree
(
ctx
.
pTermset
)
;
ctx
.
pTermset
=
0
;
if
(
rc
!
=
SQLITE_OK
)
break
;
}
rc2
=
sqlite3_reset
(
pScan
)
;
if
(
rc
=
=
SQLITE_OK
)
rc
=
rc2
;
}
if
(
rc
=
=
SQLITE_OK
)
{
int
i
;
rc
=
fts5StorageLoadTotals
(
p
0
)
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
pConfig
-
>
nCol
;
i
+
+
)
{
if
(
p
-
>
aTotalSize
[
i
]
!
=
aTotalSize
[
i
]
)
rc
=
FTS5_CORRUPT
;
}
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
eContent
=
=
FTS5_CONTENT_NORMAL
)
{
i64
nRow
=
0
;
rc
=
fts5StorageCount
(
p
"
content
"
&
nRow
)
;
if
(
rc
=
=
SQLITE_OK
&
&
nRow
!
=
p
-
>
nTotalRow
)
rc
=
FTS5_CORRUPT
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pConfig
-
>
bColumnsize
)
{
i64
nRow
=
0
;
rc
=
fts5StorageCount
(
p
"
docsize
"
&
nRow
)
;
if
(
rc
=
=
SQLITE_OK
&
&
nRow
!
=
p
-
>
nTotalRow
)
rc
=
FTS5_CORRUPT
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexIntegrityCheck
(
p
-
>
pIndex
ctx
.
cksum
bUseCksum
)
;
}
sqlite3_free
(
aTotalSize
)
;
return
rc
;
}
static
int
sqlite3Fts5StorageStmt
(
Fts5Storage
*
p
int
eStmt
sqlite3_stmt
*
*
pp
char
*
*
pzErrMsg
)
{
int
rc
;
assert
(
eStmt
=
=
FTS5_STMT_SCAN_ASC
|
|
eStmt
=
=
FTS5_STMT_SCAN_DESC
|
|
eStmt
=
=
FTS5_STMT_LOOKUP
)
;
rc
=
fts5StorageGetStmt
(
p
eStmt
pp
pzErrMsg
)
;
if
(
rc
=
=
SQLITE_OK
)
{
assert
(
p
-
>
aStmt
[
eStmt
]
=
=
*
pp
)
;
p
-
>
aStmt
[
eStmt
]
=
0
;
}
return
rc
;
}
static
void
sqlite3Fts5StorageStmtRelease
(
Fts5Storage
*
p
int
eStmt
sqlite3_stmt
*
pStmt
)
{
assert
(
eStmt
=
=
FTS5_STMT_SCAN_ASC
|
|
eStmt
=
=
FTS5_STMT_SCAN_DESC
|
|
eStmt
=
=
FTS5_STMT_LOOKUP
)
;
if
(
p
-
>
aStmt
[
eStmt
]
=
=
0
)
{
sqlite3_reset
(
pStmt
)
;
p
-
>
aStmt
[
eStmt
]
=
pStmt
;
}
else
{
sqlite3_finalize
(
pStmt
)
;
}
}
static
int
fts5StorageDecodeSizeArray
(
int
*
aCol
int
nCol
const
u8
*
aBlob
int
nBlob
)
{
int
i
;
int
iOff
=
0
;
for
(
i
=
0
;
i
<
nCol
;
i
+
+
)
{
if
(
iOff
>
=
nBlob
)
return
1
;
iOff
+
=
fts5GetVarint32
(
&
aBlob
[
iOff
]
aCol
[
i
]
)
;
}
return
(
iOff
!
=
nBlob
)
;
}
static
int
sqlite3Fts5StorageDocsize
(
Fts5Storage
*
p
i64
iRowid
int
*
aCol
)
{
int
nCol
=
p
-
>
pConfig
-
>
nCol
;
sqlite3_stmt
*
pLookup
=
0
;
int
rc
;
assert
(
p
-
>
pConfig
-
>
bColumnsize
)
;
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_LOOKUP_DOCSIZE
&
pLookup
0
)
;
if
(
pLookup
)
{
int
bCorrupt
=
1
;
assert
(
rc
=
=
SQLITE_OK
)
;
sqlite3_bind_int64
(
pLookup
1
iRowid
)
;
if
(
SQLITE_ROW
=
=
sqlite3_step
(
pLookup
)
)
{
const
u8
*
aBlob
=
sqlite3_column_blob
(
pLookup
0
)
;
int
nBlob
=
sqlite3_column_bytes
(
pLookup
0
)
;
if
(
0
=
=
fts5StorageDecodeSizeArray
(
aCol
nCol
aBlob
nBlob
)
)
{
bCorrupt
=
0
;
}
}
rc
=
sqlite3_reset
(
pLookup
)
;
if
(
bCorrupt
&
&
rc
=
=
SQLITE_OK
)
{
rc
=
FTS5_CORRUPT
;
}
}
else
{
assert
(
rc
!
=
SQLITE_OK
)
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageSize
(
Fts5Storage
*
p
int
iCol
i64
*
pnToken
)
{
int
rc
=
fts5StorageLoadTotals
(
p
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
*
pnToken
=
0
;
if
(
iCol
<
0
)
{
int
i
;
for
(
i
=
0
;
i
<
p
-
>
pConfig
-
>
nCol
;
i
+
+
)
{
*
pnToken
+
=
p
-
>
aTotalSize
[
i
]
;
}
}
else
if
(
iCol
<
p
-
>
pConfig
-
>
nCol
)
{
*
pnToken
=
p
-
>
aTotalSize
[
iCol
]
;
}
else
{
rc
=
SQLITE_RANGE
;
}
}
return
rc
;
}
static
int
sqlite3Fts5StorageRowCount
(
Fts5Storage
*
p
i64
*
pnRow
)
{
int
rc
=
fts5StorageLoadTotals
(
p
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
*
pnRow
=
p
-
>
nTotalRow
;
if
(
p
-
>
nTotalRow
<
=
0
)
rc
=
FTS5_CORRUPT
;
}
return
rc
;
}
static
int
sqlite3Fts5StorageSync
(
Fts5Storage
*
p
)
{
int
rc
=
SQLITE_OK
;
i64
iLastRowid
=
sqlite3_last_insert_rowid
(
p
-
>
pConfig
-
>
db
)
;
if
(
p
-
>
bTotalsValid
)
{
rc
=
fts5StorageSaveTotals
(
p
)
;
if
(
rc
=
=
SQLITE_OK
)
{
p
-
>
bTotalsValid
=
0
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IndexSync
(
p
-
>
pIndex
)
;
}
sqlite3_set_last_insert_rowid
(
p
-
>
pConfig
-
>
db
iLastRowid
)
;
return
rc
;
}
static
int
sqlite3Fts5StorageRollback
(
Fts5Storage
*
p
)
{
p
-
>
bTotalsValid
=
0
;
return
sqlite3Fts5IndexRollback
(
p
-
>
pIndex
)
;
}
static
int
sqlite3Fts5StorageConfigValue
(
Fts5Storage
*
p
const
char
*
z
sqlite3_value
*
pVal
int
iVal
)
{
sqlite3_stmt
*
pReplace
=
0
;
int
rc
=
fts5StorageGetStmt
(
p
FTS5_STMT_REPLACE_CONFIG
&
pReplace
0
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3_bind_text
(
pReplace
1
z
-
1
SQLITE_STATIC
)
;
if
(
pVal
)
{
sqlite3_bind_value
(
pReplace
2
pVal
)
;
}
else
{
sqlite3_bind_int
(
pReplace
2
iVal
)
;
}
sqlite3_step
(
pReplace
)
;
rc
=
sqlite3_reset
(
pReplace
)
;
sqlite3_bind_null
(
pReplace
1
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
pVal
)
{
int
iNew
=
p
-
>
pConfig
-
>
iCookie
+
1
;
rc
=
sqlite3Fts5IndexSetCookie
(
p
-
>
pIndex
iNew
)
;
if
(
rc
=
=
SQLITE_OK
)
{
p
-
>
pConfig
-
>
iCookie
=
iNew
;
}
}
return
rc
;
}
#
line
1
"
fts5_tokenize
.
c
"
static
unsigned
char
aAsciiTokenChar
[
128
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
}
;
typedef
struct
AsciiTokenizer
AsciiTokenizer
;
struct
AsciiTokenizer
{
unsigned
char
aTokenChar
[
128
]
;
}
;
static
void
fts5AsciiAddExceptions
(
AsciiTokenizer
*
p
const
char
*
zArg
int
bTokenChars
)
{
int
i
;
for
(
i
=
0
;
zArg
[
i
]
;
i
+
+
)
{
if
(
(
zArg
[
i
]
&
0x80
)
=
=
0
)
{
p
-
>
aTokenChar
[
(
int
)
zArg
[
i
]
]
=
(
unsigned
char
)
bTokenChars
;
}
}
}
static
void
fts5AsciiDelete
(
Fts5Tokenizer
*
p
)
{
sqlite3_free
(
p
)
;
}
static
int
fts5AsciiCreate
(
void
*
pUnused
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
{
int
rc
=
SQLITE_OK
;
AsciiTokenizer
*
p
=
0
;
UNUSED_PARAM
(
pUnused
)
;
if
(
nArg
%
2
)
{
rc
=
SQLITE_ERROR
;
}
else
{
p
=
sqlite3_malloc
(
sizeof
(
AsciiTokenizer
)
)
;
if
(
p
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
int
i
;
memset
(
p
0
sizeof
(
AsciiTokenizer
)
)
;
memcpy
(
p
-
>
aTokenChar
aAsciiTokenChar
sizeof
(
aAsciiTokenChar
)
)
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nArg
;
i
+
=
2
)
{
const
char
*
zArg
=
azArg
[
i
+
1
]
;
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
tokenchars
"
)
)
{
fts5AsciiAddExceptions
(
p
zArg
1
)
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
separators
"
)
)
{
fts5AsciiAddExceptions
(
p
zArg
0
)
;
}
else
{
rc
=
SQLITE_ERROR
;
}
}
if
(
rc
!
=
SQLITE_OK
)
{
fts5AsciiDelete
(
(
Fts5Tokenizer
*
)
p
)
;
p
=
0
;
}
}
}
*
ppOut
=
(
Fts5Tokenizer
*
)
p
;
return
rc
;
}
static
void
asciiFold
(
char
*
aOut
const
char
*
aIn
int
nByte
)
{
int
i
;
for
(
i
=
0
;
i
<
nByte
;
i
+
+
)
{
char
c
=
aIn
[
i
]
;
if
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
c
+
=
32
;
aOut
[
i
]
=
c
;
}
}
static
int
fts5AsciiTokenize
(
Fts5Tokenizer
*
pTokenizer
void
*
pCtx
int
iUnused
const
char
*
pText
int
nText
int
(
*
xToken
)
(
void
*
int
const
char
*
int
nToken
int
iStart
int
iEnd
)
)
{
AsciiTokenizer
*
p
=
(
AsciiTokenizer
*
)
pTokenizer
;
int
rc
=
SQLITE_OK
;
int
ie
;
int
is
=
0
;
char
aFold
[
64
]
;
int
nFold
=
sizeof
(
aFold
)
;
char
*
pFold
=
aFold
;
unsigned
char
*
a
=
p
-
>
aTokenChar
;
UNUSED_PARAM
(
iUnused
)
;
while
(
is
<
nText
&
&
rc
=
=
SQLITE_OK
)
{
int
nByte
;
while
(
is
<
nText
&
&
(
(
pText
[
is
]
&
0x80
)
=
=
0
&
&
a
[
(
int
)
pText
[
is
]
]
=
=
0
)
)
{
is
+
+
;
}
if
(
is
=
=
nText
)
break
;
ie
=
is
+
1
;
while
(
ie
<
nText
&
&
(
(
pText
[
ie
]
&
0x80
)
|
|
a
[
(
int
)
pText
[
ie
]
]
)
)
{
ie
+
+
;
}
nByte
=
ie
-
is
;
if
(
nByte
>
nFold
)
{
if
(
pFold
!
=
aFold
)
sqlite3_free
(
pFold
)
;
pFold
=
sqlite3_malloc64
(
(
sqlite3_int64
)
nByte
*
2
)
;
if
(
pFold
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
break
;
}
nFold
=
nByte
*
2
;
}
asciiFold
(
pFold
&
pText
[
is
]
nByte
)
;
rc
=
xToken
(
pCtx
0
pFold
nByte
is
ie
)
;
is
=
ie
+
1
;
}
if
(
pFold
!
=
aFold
)
sqlite3_free
(
pFold
)
;
if
(
rc
=
=
SQLITE_DONE
)
rc
=
SQLITE_OK
;
return
rc
;
}
#
ifndef
SQLITE_AMALGAMATION
static
const
unsigned
char
sqlite3Utf8Trans1
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0a
0x0b
0x0c
0x0d
0x0e
0x0f
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1a
0x1b
0x1c
0x1d
0x1e
0x1f
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0a
0x0b
0x0c
0x0d
0x0e
0x0f
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x00
0x01
0x02
0x03
0x00
0x01
0x00
0x00
}
;
#
define
READ_UTF8
(
zIn
zTerm
c
)
\
c
=
*
(
zIn
+
+
)
;
\
if
(
c
>
=
0xc0
)
{
\
c
=
sqlite3Utf8Trans1
[
c
-
0xc0
]
;
\
while
(
zIn
<
zTerm
&
&
(
*
zIn
&
0xc0
)
=
=
0x80
)
{
\
c
=
(
c
<
<
6
)
+
(
0x3f
&
*
(
zIn
+
+
)
)
;
\
}
\
if
(
c
<
0x80
\
|
|
(
c
&
0xFFFFF800
)
=
=
0xD800
\
|
|
(
c
&
0xFFFFFFFE
)
=
=
0xFFFE
)
{
c
=
0xFFFD
;
}
\
}
#
define
WRITE_UTF8
(
zOut
c
)
{
\
if
(
c
<
0x00080
)
{
\
*
zOut
+
+
=
(
unsigned
char
)
(
c
&
0xFF
)
;
\
}
\
else
if
(
c
<
0x00800
)
{
\
*
zOut
+
+
=
0xC0
+
(
unsigned
char
)
(
(
c
>
>
6
)
&
0x1F
)
;
\
*
zOut
+
+
=
0x80
+
(
unsigned
char
)
(
c
&
0x3F
)
;
\
}
\
else
if
(
c
<
0x10000
)
{
\
*
zOut
+
+
=
0xE0
+
(
unsigned
char
)
(
(
c
>
>
12
)
&
0x0F
)
;
\
*
zOut
+
+
=
0x80
+
(
unsigned
char
)
(
(
c
>
>
6
)
&
0x3F
)
;
\
*
zOut
+
+
=
0x80
+
(
unsigned
char
)
(
c
&
0x3F
)
;
\
}
else
{
\
*
zOut
+
+
=
0xF0
+
(
unsigned
char
)
(
(
c
>
>
18
)
&
0x07
)
;
\
*
zOut
+
+
=
0x80
+
(
unsigned
char
)
(
(
c
>
>
12
)
&
0x3F
)
;
\
*
zOut
+
+
=
0x80
+
(
unsigned
char
)
(
(
c
>
>
6
)
&
0x3F
)
;
\
*
zOut
+
+
=
0x80
+
(
unsigned
char
)
(
c
&
0x3F
)
;
\
}
\
}
#
endif
#
define
FTS5_SKIP_UTF8
(
zIn
)
{
\
if
(
(
(
unsigned
char
)
(
*
(
zIn
+
+
)
)
)
>
=
0xc0
)
{
\
while
(
(
(
(
unsigned
char
)
*
zIn
)
&
0xc0
)
=
=
0x80
)
{
zIn
+
+
;
}
\
}
\
}
typedef
struct
Unicode61Tokenizer
Unicode61Tokenizer
;
struct
Unicode61Tokenizer
{
unsigned
char
aTokenChar
[
128
]
;
char
*
aFold
;
int
nFold
;
int
eRemoveDiacritic
;
int
nException
;
int
*
aiException
;
unsigned
char
aCategory
[
32
]
;
}
;
#
define
FTS5_REMOVE_DIACRITICS_NONE
0
#
define
FTS5_REMOVE_DIACRITICS_SIMPLE
1
#
define
FTS5_REMOVE_DIACRITICS_COMPLEX
2
static
int
fts5UnicodeAddExceptions
(
Unicode61Tokenizer
*
p
const
char
*
z
int
bTokenChars
)
{
int
rc
=
SQLITE_OK
;
int
n
=
(
int
)
strlen
(
z
)
;
int
*
aNew
;
if
(
n
>
0
)
{
aNew
=
(
int
*
)
sqlite3_realloc64
(
p
-
>
aiException
(
n
+
p
-
>
nException
)
*
sizeof
(
int
)
)
;
if
(
aNew
)
{
int
nNew
=
p
-
>
nException
;
const
unsigned
char
*
zCsr
=
(
const
unsigned
char
*
)
z
;
const
unsigned
char
*
zTerm
=
(
const
unsigned
char
*
)
&
z
[
n
]
;
while
(
zCsr
<
zTerm
)
{
u32
iCode
;
int
bToken
;
READ_UTF8
(
zCsr
zTerm
iCode
)
;
if
(
iCode
<
128
)
{
p
-
>
aTokenChar
[
iCode
]
=
(
unsigned
char
)
bTokenChars
;
}
else
{
bToken
=
p
-
>
aCategory
[
sqlite3Fts5UnicodeCategory
(
iCode
)
]
;
assert
(
(
bToken
=
=
0
|
|
bToken
=
=
1
)
)
;
assert
(
(
bTokenChars
=
=
0
|
|
bTokenChars
=
=
1
)
)
;
if
(
bToken
!
=
bTokenChars
&
&
sqlite3Fts5UnicodeIsdiacritic
(
iCode
)
=
=
0
)
{
int
i
;
for
(
i
=
0
;
i
<
nNew
;
i
+
+
)
{
if
(
(
u32
)
aNew
[
i
]
>
iCode
)
break
;
}
memmove
(
&
aNew
[
i
+
1
]
&
aNew
[
i
]
(
nNew
-
i
)
*
sizeof
(
int
)
)
;
aNew
[
i
]
=
iCode
;
nNew
+
+
;
}
}
}
p
-
>
aiException
=
aNew
;
p
-
>
nException
=
nNew
;
}
else
{
rc
=
SQLITE_NOMEM
;
}
}
return
rc
;
}
static
int
fts5UnicodeIsException
(
Unicode61Tokenizer
*
p
int
iCode
)
{
if
(
p
-
>
nException
>
0
)
{
int
*
a
=
p
-
>
aiException
;
int
iLo
=
0
;
int
iHi
=
p
-
>
nException
-
1
;
while
(
iHi
>
=
iLo
)
{
int
iTest
=
(
iHi
+
iLo
)
/
2
;
if
(
iCode
=
=
a
[
iTest
]
)
{
return
1
;
}
else
if
(
iCode
>
a
[
iTest
]
)
{
iLo
=
iTest
+
1
;
}
else
{
iHi
=
iTest
-
1
;
}
}
}
return
0
;
}
static
void
fts5UnicodeDelete
(
Fts5Tokenizer
*
pTok
)
{
if
(
pTok
)
{
Unicode61Tokenizer
*
p
=
(
Unicode61Tokenizer
*
)
pTok
;
sqlite3_free
(
p
-
>
aiException
)
;
sqlite3_free
(
p
-
>
aFold
)
;
sqlite3_free
(
p
)
;
}
return
;
}
static
int
unicodeSetCategories
(
Unicode61Tokenizer
*
p
const
char
*
zCat
)
{
const
char
*
z
=
zCat
;
while
(
*
z
)
{
while
(
*
z
=
=
'
'
|
|
*
z
=
=
'
\
t
'
)
z
+
+
;
if
(
*
z
&
&
sqlite3Fts5UnicodeCatParse
(
z
p
-
>
aCategory
)
)
{
return
SQLITE_ERROR
;
}
while
(
*
z
!
=
'
'
&
&
*
z
!
=
'
\
t
'
&
&
*
z
!
=
'
\
0
'
)
z
+
+
;
}
sqlite3Fts5UnicodeAscii
(
p
-
>
aCategory
p
-
>
aTokenChar
)
;
return
SQLITE_OK
;
}
static
int
fts5UnicodeCreate
(
void
*
pUnused
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
{
int
rc
=
SQLITE_OK
;
Unicode61Tokenizer
*
p
=
0
;
UNUSED_PARAM
(
pUnused
)
;
if
(
nArg
%
2
)
{
rc
=
SQLITE_ERROR
;
}
else
{
p
=
(
Unicode61Tokenizer
*
)
sqlite3_malloc
(
sizeof
(
Unicode61Tokenizer
)
)
;
if
(
p
)
{
const
char
*
zCat
=
"
L
*
N
*
Co
"
;
int
i
;
memset
(
p
0
sizeof
(
Unicode61Tokenizer
)
)
;
p
-
>
eRemoveDiacritic
=
FTS5_REMOVE_DIACRITICS_SIMPLE
;
p
-
>
nFold
=
64
;
p
-
>
aFold
=
sqlite3_malloc64
(
p
-
>
nFold
*
sizeof
(
char
)
)
;
if
(
p
-
>
aFold
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nArg
;
i
+
=
2
)
{
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
categories
"
)
)
{
zCat
=
azArg
[
i
+
1
]
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
unicodeSetCategories
(
p
zCat
)
;
}
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nArg
;
i
+
=
2
)
{
const
char
*
zArg
=
azArg
[
i
+
1
]
;
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
remove_diacritics
"
)
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
&
&
zArg
[
0
]
!
=
'
2
'
)
|
|
zArg
[
1
]
)
{
rc
=
SQLITE_ERROR
;
}
else
{
p
-
>
eRemoveDiacritic
=
(
zArg
[
0
]
-
'
0
'
)
;
assert
(
p
-
>
eRemoveDiacritic
=
=
FTS5_REMOVE_DIACRITICS_NONE
|
|
p
-
>
eRemoveDiacritic
=
=
FTS5_REMOVE_DIACRITICS_SIMPLE
|
|
p
-
>
eRemoveDiacritic
=
=
FTS5_REMOVE_DIACRITICS_COMPLEX
)
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
tokenchars
"
)
)
{
rc
=
fts5UnicodeAddExceptions
(
p
zArg
1
)
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
separators
"
)
)
{
rc
=
fts5UnicodeAddExceptions
(
p
zArg
0
)
;
}
else
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
categories
"
)
)
{
}
else
{
rc
=
SQLITE_ERROR
;
}
}
}
else
{
rc
=
SQLITE_NOMEM
;
}
if
(
rc
!
=
SQLITE_OK
)
{
fts5UnicodeDelete
(
(
Fts5Tokenizer
*
)
p
)
;
p
=
0
;
}
*
ppOut
=
(
Fts5Tokenizer
*
)
p
;
}
return
rc
;
}
static
int
fts5UnicodeIsAlnum
(
Unicode61Tokenizer
*
p
int
iCode
)
{
return
(
p
-
>
aCategory
[
sqlite3Fts5UnicodeCategory
(
(
u32
)
iCode
)
]
^
fts5UnicodeIsException
(
p
iCode
)
)
;
}
static
int
fts5UnicodeTokenize
(
Fts5Tokenizer
*
pTokenizer
void
*
pCtx
int
iUnused
const
char
*
pText
int
nText
int
(
*
xToken
)
(
void
*
int
const
char
*
int
nToken
int
iStart
int
iEnd
)
)
{
Unicode61Tokenizer
*
p
=
(
Unicode61Tokenizer
*
)
pTokenizer
;
int
rc
=
SQLITE_OK
;
unsigned
char
*
a
=
p
-
>
aTokenChar
;
unsigned
char
*
zTerm
=
(
unsigned
char
*
)
&
pText
[
nText
]
;
unsigned
char
*
zCsr
=
(
unsigned
char
*
)
pText
;
char
*
aFold
=
p
-
>
aFold
;
int
nFold
=
p
-
>
nFold
;
const
char
*
pEnd
=
&
aFold
[
nFold
-
6
]
;
UNUSED_PARAM
(
iUnused
)
;
while
(
rc
=
=
SQLITE_OK
)
{
u32
iCode
;
char
*
zOut
=
aFold
;
int
is
;
int
ie
;
while
(
1
)
{
if
(
zCsr
>
=
zTerm
)
goto
tokenize_done
;
if
(
*
zCsr
&
0x80
)
{
is
=
zCsr
-
(
unsigned
char
*
)
pText
;
READ_UTF8
(
zCsr
zTerm
iCode
)
;
if
(
fts5UnicodeIsAlnum
(
p
iCode
)
)
{
goto
non_ascii_tokenchar
;
}
}
else
{
if
(
a
[
*
zCsr
]
)
{
is
=
zCsr
-
(
unsigned
char
*
)
pText
;
goto
ascii_tokenchar
;
}
zCsr
+
+
;
}
}
while
(
zCsr
<
zTerm
)
{
if
(
zOut
>
pEnd
)
{
aFold
=
sqlite3_malloc64
(
(
sqlite3_int64
)
nFold
*
2
)
;
if
(
aFold
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
goto
tokenize_done
;
}
zOut
=
&
aFold
[
zOut
-
p
-
>
aFold
]
;
memcpy
(
aFold
p
-
>
aFold
nFold
)
;
sqlite3_free
(
p
-
>
aFold
)
;
p
-
>
aFold
=
aFold
;
p
-
>
nFold
=
nFold
=
nFold
*
2
;
pEnd
=
&
aFold
[
nFold
-
6
]
;
}
if
(
*
zCsr
&
0x80
)
{
READ_UTF8
(
zCsr
zTerm
iCode
)
;
if
(
fts5UnicodeIsAlnum
(
p
iCode
)
|
|
sqlite3Fts5UnicodeIsdiacritic
(
iCode
)
)
{
non_ascii_tokenchar
:
iCode
=
sqlite3Fts5UnicodeFold
(
iCode
p
-
>
eRemoveDiacritic
)
;
if
(
iCode
)
WRITE_UTF8
(
zOut
iCode
)
;
}
else
{
break
;
}
}
else
if
(
a
[
*
zCsr
]
=
=
0
)
{
break
;
}
else
{
ascii_tokenchar
:
if
(
*
zCsr
>
=
'
A
'
&
&
*
zCsr
<
=
'
Z
'
)
{
*
zOut
+
+
=
*
zCsr
+
32
;
}
else
{
*
zOut
+
+
=
*
zCsr
;
}
zCsr
+
+
;
}
ie
=
zCsr
-
(
unsigned
char
*
)
pText
;
}
rc
=
xToken
(
pCtx
0
aFold
zOut
-
aFold
is
ie
)
;
}
tokenize_done
:
if
(
rc
=
=
SQLITE_DONE
)
rc
=
SQLITE_OK
;
return
rc
;
}
#
define
FTS5_PORTER_MAX_TOKEN
64
typedef
struct
PorterTokenizer
PorterTokenizer
;
struct
PorterTokenizer
{
fts5_tokenizer_v2
tokenizer_v2
;
Fts5Tokenizer
*
pTokenizer
;
char
aBuf
[
FTS5_PORTER_MAX_TOKEN
+
64
]
;
}
;
static
void
fts5PorterDelete
(
Fts5Tokenizer
*
pTok
)
{
if
(
pTok
)
{
PorterTokenizer
*
p
=
(
PorterTokenizer
*
)
pTok
;
if
(
p
-
>
pTokenizer
)
{
p
-
>
tokenizer_v2
.
xDelete
(
p
-
>
pTokenizer
)
;
}
sqlite3_free
(
p
)
;
}
}
static
int
fts5PorterCreate
(
void
*
pCtx
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
{
fts5_api
*
pApi
=
(
fts5_api
*
)
pCtx
;
int
rc
=
SQLITE_OK
;
PorterTokenizer
*
pRet
;
void
*
pUserdata
=
0
;
const
char
*
zBase
=
"
unicode61
"
;
fts5_tokenizer_v2
*
pV2
=
0
;
if
(
nArg
>
0
)
{
zBase
=
azArg
[
0
]
;
}
pRet
=
(
PorterTokenizer
*
)
sqlite3_malloc
(
sizeof
(
PorterTokenizer
)
)
;
if
(
pRet
)
{
memset
(
pRet
0
sizeof
(
PorterTokenizer
)
)
;
rc
=
pApi
-
>
xFindTokenizer_v2
(
pApi
zBase
&
pUserdata
&
pV2
)
;
}
else
{
rc
=
SQLITE_NOMEM
;
}
if
(
rc
=
=
SQLITE_OK
)
{
int
nArg2
=
(
nArg
>
0
?
nArg
-
1
:
0
)
;
const
char
*
*
az2
=
(
nArg2
?
&
azArg
[
1
]
:
0
)
;
memcpy
(
&
pRet
-
>
tokenizer_v2
pV2
sizeof
(
fts5_tokenizer_v2
)
)
;
rc
=
pRet
-
>
tokenizer_v2
.
xCreate
(
pUserdata
az2
nArg2
&
pRet
-
>
pTokenizer
)
;
}
if
(
rc
!
=
SQLITE_OK
)
{
fts5PorterDelete
(
(
Fts5Tokenizer
*
)
pRet
)
;
pRet
=
0
;
}
*
ppOut
=
(
Fts5Tokenizer
*
)
pRet
;
return
rc
;
}
typedef
struct
PorterContext
PorterContext
;
struct
PorterContext
{
void
*
pCtx
;
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
;
char
*
aBuf
;
}
;
typedef
struct
PorterRule
PorterRule
;
struct
PorterRule
{
const
char
*
zSuffix
;
int
nSuffix
;
int
(
*
xCond
)
(
char
*
zStem
int
nStem
)
;
const
char
*
zOutput
;
int
nOutput
;
}
;
#
if
0
static
int
fts5PorterApply
(
char
*
aBuf
int
*
pnBuf
PorterRule
*
aRule
)
{
int
ret
=
-
1
;
int
nBuf
=
*
pnBuf
;
PorterRule
*
p
;
for
(
p
=
aRule
;
p
-
>
zSuffix
;
p
+
+
)
{
assert
(
strlen
(
p
-
>
zSuffix
)
=
=
p
-
>
nSuffix
)
;
assert
(
strlen
(
p
-
>
zOutput
)
=
=
p
-
>
nOutput
)
;
if
(
nBuf
<
p
-
>
nSuffix
)
continue
;
if
(
0
=
=
memcmp
(
&
aBuf
[
nBuf
-
p
-
>
nSuffix
]
p
-
>
zSuffix
p
-
>
nSuffix
)
)
break
;
}
if
(
p
-
>
zSuffix
)
{
int
nStem
=
nBuf
-
p
-
>
nSuffix
;
if
(
p
-
>
xCond
=
=
0
|
|
p
-
>
xCond
(
aBuf
nStem
)
)
{
memcpy
(
&
aBuf
[
nStem
]
p
-
>
zOutput
p
-
>
nOutput
)
;
*
pnBuf
=
nStem
+
p
-
>
nOutput
;
ret
=
p
-
aRule
;
}
}
return
ret
;
}
#
endif
static
int
fts5PorterIsVowel
(
char
c
int
bYIsVowel
)
{
return
(
c
=
=
'
a
'
|
|
c
=
=
'
e
'
|
|
c
=
=
'
i
'
|
|
c
=
=
'
o
'
|
|
c
=
=
'
u
'
|
|
(
bYIsVowel
&
&
c
=
=
'
y
'
)
)
;
}
static
int
fts5PorterGobbleVC
(
char
*
zStem
int
nStem
int
bPrevCons
)
{
int
i
;
int
bCons
=
bPrevCons
;
for
(
i
=
0
;
i
<
nStem
;
i
+
+
)
{
if
(
0
=
=
(
bCons
=
!
fts5PorterIsVowel
(
zStem
[
i
]
bCons
)
)
)
break
;
}
for
(
i
+
+
;
i
<
nStem
;
i
+
+
)
{
if
(
(
bCons
=
!
fts5PorterIsVowel
(
zStem
[
i
]
bCons
)
)
)
return
i
+
1
;
}
return
0
;
}
static
int
fts5Porter_MGt0
(
char
*
zStem
int
nStem
)
{
return
!
!
fts5PorterGobbleVC
(
zStem
nStem
0
)
;
}
static
int
fts5Porter_MGt1
(
char
*
zStem
int
nStem
)
{
int
n
;
n
=
fts5PorterGobbleVC
(
zStem
nStem
0
)
;
if
(
n
&
&
fts5PorterGobbleVC
(
&
zStem
[
n
]
nStem
-
n
1
)
)
{
return
1
;
}
return
0
;
}
static
int
fts5Porter_MEq1
(
char
*
zStem
int
nStem
)
{
int
n
;
n
=
fts5PorterGobbleVC
(
zStem
nStem
0
)
;
if
(
n
&
&
0
=
=
fts5PorterGobbleVC
(
&
zStem
[
n
]
nStem
-
n
1
)
)
{
return
1
;
}
return
0
;
}
static
int
fts5Porter_Ostar
(
char
*
zStem
int
nStem
)
{
if
(
zStem
[
nStem
-
1
]
=
=
'
w
'
|
|
zStem
[
nStem
-
1
]
=
=
'
x
'
|
|
zStem
[
nStem
-
1
]
=
=
'
y
'
)
{
return
0
;
}
else
{
int
i
;
int
mask
=
0
;
int
bCons
=
0
;
for
(
i
=
0
;
i
<
nStem
;
i
+
+
)
{
bCons
=
!
fts5PorterIsVowel
(
zStem
[
i
]
bCons
)
;
assert
(
bCons
=
=
0
|
|
bCons
=
=
1
)
;
mask
=
(
mask
<
<
1
)
+
bCons
;
}
return
(
(
mask
&
0x0007
)
=
=
0x0005
)
;
}
}
static
int
fts5Porter_MGt1_and_S_or_T
(
char
*
zStem
int
nStem
)
{
assert
(
nStem
>
0
)
;
return
(
zStem
[
nStem
-
1
]
=
=
'
s
'
|
|
zStem
[
nStem
-
1
]
=
=
'
t
'
)
&
&
fts5Porter_MGt1
(
zStem
nStem
)
;
}
static
int
fts5Porter_Vowel
(
char
*
zStem
int
nStem
)
{
int
i
;
for
(
i
=
0
;
i
<
nStem
;
i
+
+
)
{
if
(
fts5PorterIsVowel
(
zStem
[
i
]
i
>
0
)
)
{
return
1
;
}
}
return
0
;
}
static
int
fts5PorterStep4
(
char
*
aBuf
int
*
pnBuf
)
{
int
ret
=
0
;
int
nBuf
=
*
pnBuf
;
switch
(
aBuf
[
nBuf
-
2
]
)
{
case
'
a
'
:
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
al
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
2
)
)
{
*
pnBuf
=
nBuf
-
2
;
}
}
break
;
case
'
c
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ance
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
4
)
)
{
*
pnBuf
=
nBuf
-
4
;
}
}
else
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ence
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
4
)
)
{
*
pnBuf
=
nBuf
-
4
;
}
}
break
;
case
'
e
'
:
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
er
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
2
)
)
{
*
pnBuf
=
nBuf
-
2
;
}
}
break
;
case
'
i
'
:
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
ic
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
2
)
)
{
*
pnBuf
=
nBuf
-
2
;
}
}
break
;
case
'
l
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
able
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
4
)
)
{
*
pnBuf
=
nBuf
-
4
;
}
}
else
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ible
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
4
)
)
{
*
pnBuf
=
nBuf
-
4
;
}
}
break
;
case
'
n
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ant
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
else
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
ement
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
5
)
)
{
*
pnBuf
=
nBuf
-
5
;
}
}
else
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ment
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
4
)
)
{
*
pnBuf
=
nBuf
-
4
;
}
}
else
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ent
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
case
'
o
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ion
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1_and_S_or_T
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
else
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
ou
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
2
)
)
{
*
pnBuf
=
nBuf
-
2
;
}
}
break
;
case
'
s
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ism
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
case
'
t
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ate
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
else
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
iti
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
case
'
u
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ous
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
case
'
v
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ive
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
case
'
z
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ize
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
}
return
ret
;
}
static
int
fts5PorterStep1B2
(
char
*
aBuf
int
*
pnBuf
)
{
int
ret
=
0
;
int
nBuf
=
*
pnBuf
;
switch
(
aBuf
[
nBuf
-
2
]
)
{
case
'
a
'
:
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
at
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
2
]
"
ate
"
3
)
;
*
pnBuf
=
nBuf
-
2
+
3
;
ret
=
1
;
}
break
;
case
'
b
'
:
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
bl
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
2
]
"
ble
"
3
)
;
*
pnBuf
=
nBuf
-
2
+
3
;
ret
=
1
;
}
break
;
case
'
i
'
:
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
iz
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
2
]
"
ize
"
3
)
;
*
pnBuf
=
nBuf
-
2
+
3
;
ret
=
1
;
}
break
;
}
return
ret
;
}
static
int
fts5PorterStep2
(
char
*
aBuf
int
*
pnBuf
)
{
int
ret
=
0
;
int
nBuf
=
*
pnBuf
;
switch
(
aBuf
[
nBuf
-
2
]
)
{
case
'
a
'
:
if
(
nBuf
>
7
&
&
0
=
=
memcmp
(
"
ational
"
&
aBuf
[
nBuf
-
7
]
7
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
7
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
7
]
"
ate
"
3
)
;
*
pnBuf
=
nBuf
-
7
+
3
;
}
}
else
if
(
nBuf
>
6
&
&
0
=
=
memcmp
(
"
tional
"
&
aBuf
[
nBuf
-
6
]
6
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
6
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
6
]
"
tion
"
4
)
;
*
pnBuf
=
nBuf
-
6
+
4
;
}
}
break
;
case
'
c
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
enci
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
ence
"
4
)
;
*
pnBuf
=
nBuf
-
4
+
4
;
}
}
else
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
anci
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
ance
"
4
)
;
*
pnBuf
=
nBuf
-
4
+
4
;
}
}
break
;
case
'
e
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
izer
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
ize
"
3
)
;
*
pnBuf
=
nBuf
-
4
+
3
;
}
}
break
;
case
'
g
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
logi
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
log
"
3
)
;
*
pnBuf
=
nBuf
-
4
+
3
;
}
}
break
;
case
'
l
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
bli
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
3
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
3
]
"
ble
"
3
)
;
*
pnBuf
=
nBuf
-
3
+
3
;
}
}
else
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
alli
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
al
"
2
)
;
*
pnBuf
=
nBuf
-
4
+
2
;
}
}
else
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
entli
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
ent
"
3
)
;
*
pnBuf
=
nBuf
-
5
+
3
;
}
}
else
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
eli
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
3
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
3
]
"
e
"
1
)
;
*
pnBuf
=
nBuf
-
3
+
1
;
}
}
else
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
ousli
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
ous
"
3
)
;
*
pnBuf
=
nBuf
-
5
+
3
;
}
}
break
;
case
'
o
'
:
if
(
nBuf
>
7
&
&
0
=
=
memcmp
(
"
ization
"
&
aBuf
[
nBuf
-
7
]
7
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
7
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
7
]
"
ize
"
3
)
;
*
pnBuf
=
nBuf
-
7
+
3
;
}
}
else
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
ation
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
ate
"
3
)
;
*
pnBuf
=
nBuf
-
5
+
3
;
}
}
else
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ator
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
ate
"
3
)
;
*
pnBuf
=
nBuf
-
4
+
3
;
}
}
break
;
case
'
s
'
:
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
alism
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
al
"
2
)
;
*
pnBuf
=
nBuf
-
5
+
2
;
}
}
else
if
(
nBuf
>
7
&
&
0
=
=
memcmp
(
"
iveness
"
&
aBuf
[
nBuf
-
7
]
7
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
7
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
7
]
"
ive
"
3
)
;
*
pnBuf
=
nBuf
-
7
+
3
;
}
}
else
if
(
nBuf
>
7
&
&
0
=
=
memcmp
(
"
fulness
"
&
aBuf
[
nBuf
-
7
]
7
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
7
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
7
]
"
ful
"
3
)
;
*
pnBuf
=
nBuf
-
7
+
3
;
}
}
else
if
(
nBuf
>
7
&
&
0
=
=
memcmp
(
"
ousness
"
&
aBuf
[
nBuf
-
7
]
7
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
7
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
7
]
"
ous
"
3
)
;
*
pnBuf
=
nBuf
-
7
+
3
;
}
}
break
;
case
'
t
'
:
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
aliti
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
al
"
2
)
;
*
pnBuf
=
nBuf
-
5
+
2
;
}
}
else
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
iviti
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
ive
"
3
)
;
*
pnBuf
=
nBuf
-
5
+
3
;
}
}
else
if
(
nBuf
>
6
&
&
0
=
=
memcmp
(
"
biliti
"
&
aBuf
[
nBuf
-
6
]
6
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
6
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
6
]
"
ble
"
3
)
;
*
pnBuf
=
nBuf
-
6
+
3
;
}
}
break
;
}
return
ret
;
}
static
int
fts5PorterStep3
(
char
*
aBuf
int
*
pnBuf
)
{
int
ret
=
0
;
int
nBuf
=
*
pnBuf
;
switch
(
aBuf
[
nBuf
-
2
]
)
{
case
'
a
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ical
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
4
]
"
ic
"
2
)
;
*
pnBuf
=
nBuf
-
4
+
2
;
}
}
break
;
case
'
s
'
:
if
(
nBuf
>
4
&
&
0
=
=
memcmp
(
"
ness
"
&
aBuf
[
nBuf
-
4
]
4
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
4
)
)
{
*
pnBuf
=
nBuf
-
4
;
}
}
break
;
case
'
t
'
:
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
icate
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
ic
"
2
)
;
*
pnBuf
=
nBuf
-
5
+
2
;
}
}
else
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
iciti
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
ic
"
2
)
;
*
pnBuf
=
nBuf
-
5
+
2
;
}
}
break
;
case
'
u
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ful
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
}
}
break
;
case
'
v
'
:
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
ative
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
*
pnBuf
=
nBuf
-
5
;
}
}
break
;
case
'
z
'
:
if
(
nBuf
>
5
&
&
0
=
=
memcmp
(
"
alize
"
&
aBuf
[
nBuf
-
5
]
5
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
5
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
5
]
"
al
"
2
)
;
*
pnBuf
=
nBuf
-
5
+
2
;
}
}
break
;
}
return
ret
;
}
static
int
fts5PorterStep1B
(
char
*
aBuf
int
*
pnBuf
)
{
int
ret
=
0
;
int
nBuf
=
*
pnBuf
;
switch
(
aBuf
[
nBuf
-
2
]
)
{
case
'
e
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
eed
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_MGt0
(
aBuf
nBuf
-
3
)
)
{
memcpy
(
&
aBuf
[
nBuf
-
3
]
"
ee
"
2
)
;
*
pnBuf
=
nBuf
-
3
+
2
;
}
}
else
if
(
nBuf
>
2
&
&
0
=
=
memcmp
(
"
ed
"
&
aBuf
[
nBuf
-
2
]
2
)
)
{
if
(
fts5Porter_Vowel
(
aBuf
nBuf
-
2
)
)
{
*
pnBuf
=
nBuf
-
2
;
ret
=
1
;
}
}
break
;
case
'
n
'
:
if
(
nBuf
>
3
&
&
0
=
=
memcmp
(
"
ing
"
&
aBuf
[
nBuf
-
3
]
3
)
)
{
if
(
fts5Porter_Vowel
(
aBuf
nBuf
-
3
)
)
{
*
pnBuf
=
nBuf
-
3
;
ret
=
1
;
}
}
break
;
}
return
ret
;
}
static
void
fts5PorterStep1A
(
char
*
aBuf
int
*
pnBuf
)
{
int
nBuf
=
*
pnBuf
;
if
(
aBuf
[
nBuf
-
1
]
=
=
'
s
'
)
{
if
(
aBuf
[
nBuf
-
2
]
=
=
'
e
'
)
{
if
(
(
nBuf
>
4
&
&
aBuf
[
nBuf
-
4
]
=
=
'
s
'
&
&
aBuf
[
nBuf
-
3
]
=
=
'
s
'
)
|
|
(
nBuf
>
3
&
&
aBuf
[
nBuf
-
3
]
=
=
'
i
'
)
)
{
*
pnBuf
=
nBuf
-
2
;
}
else
{
*
pnBuf
=
nBuf
-
1
;
}
}
else
if
(
aBuf
[
nBuf
-
2
]
!
=
'
s
'
)
{
*
pnBuf
=
nBuf
-
1
;
}
}
}
static
int
fts5PorterCb
(
void
*
pCtx
int
tflags
const
char
*
pToken
int
nToken
int
iStart
int
iEnd
)
{
PorterContext
*
p
=
(
PorterContext
*
)
pCtx
;
char
*
aBuf
;
int
nBuf
;
if
(
nToken
>
FTS5_PORTER_MAX_TOKEN
|
|
nToken
<
3
)
goto
pass_through
;
aBuf
=
p
-
>
aBuf
;
nBuf
=
nToken
;
memcpy
(
aBuf
pToken
nBuf
)
;
fts5PorterStep1A
(
aBuf
&
nBuf
)
;
if
(
fts5PorterStep1B
(
aBuf
&
nBuf
)
)
{
if
(
fts5PorterStep1B2
(
aBuf
&
nBuf
)
=
=
0
)
{
char
c
=
aBuf
[
nBuf
-
1
]
;
if
(
fts5PorterIsVowel
(
c
0
)
=
=
0
&
&
c
!
=
'
l
'
&
&
c
!
=
'
s
'
&
&
c
!
=
'
z
'
&
&
c
=
=
aBuf
[
nBuf
-
2
]
)
{
nBuf
-
-
;
}
else
if
(
fts5Porter_MEq1
(
aBuf
nBuf
)
&
&
fts5Porter_Ostar
(
aBuf
nBuf
)
)
{
aBuf
[
nBuf
+
+
]
=
'
e
'
;
}
}
}
if
(
aBuf
[
nBuf
-
1
]
=
=
'
y
'
&
&
fts5Porter_Vowel
(
aBuf
nBuf
-
1
)
)
{
aBuf
[
nBuf
-
1
]
=
'
i
'
;
}
fts5PorterStep2
(
aBuf
&
nBuf
)
;
fts5PorterStep3
(
aBuf
&
nBuf
)
;
fts5PorterStep4
(
aBuf
&
nBuf
)
;
assert
(
nBuf
>
0
)
;
if
(
aBuf
[
nBuf
-
1
]
=
=
'
e
'
)
{
if
(
fts5Porter_MGt1
(
aBuf
nBuf
-
1
)
|
|
(
fts5Porter_MEq1
(
aBuf
nBuf
-
1
)
&
&
!
fts5Porter_Ostar
(
aBuf
nBuf
-
1
)
)
)
{
nBuf
-
-
;
}
}
if
(
nBuf
>
1
&
&
aBuf
[
nBuf
-
1
]
=
=
'
l
'
&
&
aBuf
[
nBuf
-
2
]
=
=
'
l
'
&
&
fts5Porter_MGt1
(
aBuf
nBuf
-
1
)
)
{
nBuf
-
-
;
}
return
p
-
>
xToken
(
p
-
>
pCtx
tflags
aBuf
nBuf
iStart
iEnd
)
;
pass_through
:
return
p
-
>
xToken
(
p
-
>
pCtx
tflags
pToken
nToken
iStart
iEnd
)
;
}
static
int
fts5PorterTokenize
(
Fts5Tokenizer
*
pTokenizer
void
*
pCtx
int
flags
const
char
*
pText
int
nText
const
char
*
pLoc
int
nLoc
int
(
*
xToken
)
(
void
*
int
const
char
*
int
nToken
int
iStart
int
iEnd
)
)
{
PorterTokenizer
*
p
=
(
PorterTokenizer
*
)
pTokenizer
;
PorterContext
sCtx
;
sCtx
.
xToken
=
xToken
;
sCtx
.
pCtx
=
pCtx
;
sCtx
.
aBuf
=
p
-
>
aBuf
;
return
p
-
>
tokenizer_v2
.
xTokenize
(
p
-
>
pTokenizer
(
void
*
)
&
sCtx
flags
pText
nText
pLoc
nLoc
fts5PorterCb
)
;
}
typedef
struct
TrigramTokenizer
TrigramTokenizer
;
struct
TrigramTokenizer
{
int
bFold
;
int
iFoldParam
;
}
;
static
void
fts5TriDelete
(
Fts5Tokenizer
*
p
)
{
sqlite3_free
(
p
)
;
}
static
int
fts5TriCreate
(
void
*
pUnused
const
char
*
*
azArg
int
nArg
Fts5Tokenizer
*
*
ppOut
)
{
int
rc
=
SQLITE_OK
;
TrigramTokenizer
*
pNew
=
0
;
UNUSED_PARAM
(
pUnused
)
;
if
(
nArg
%
2
)
{
rc
=
SQLITE_ERROR
;
}
else
{
int
i
;
pNew
=
(
TrigramTokenizer
*
)
sqlite3_malloc
(
sizeof
(
*
pNew
)
)
;
if
(
pNew
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
pNew
-
>
bFold
=
1
;
pNew
-
>
iFoldParam
=
0
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
nArg
;
i
+
=
2
)
{
const
char
*
zArg
=
azArg
[
i
+
1
]
;
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
case_sensitive
"
)
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
)
|
|
zArg
[
1
]
)
{
rc
=
SQLITE_ERROR
;
}
else
{
pNew
-
>
bFold
=
(
zArg
[
0
]
=
=
'
0
'
)
;
}
}
else
if
(
0
=
=
sqlite3_stricmp
(
azArg
[
i
]
"
remove_diacritics
"
)
)
{
if
(
(
zArg
[
0
]
!
=
'
0
'
&
&
zArg
[
0
]
!
=
'
1
'
&
&
zArg
[
0
]
!
=
'
2
'
)
|
|
zArg
[
1
]
)
{
rc
=
SQLITE_ERROR
;
}
else
{
pNew
-
>
iFoldParam
=
(
zArg
[
0
]
!
=
'
0
'
)
?
2
:
0
;
}
}
else
{
rc
=
SQLITE_ERROR
;
}
}
if
(
pNew
-
>
iFoldParam
!
=
0
&
&
pNew
-
>
bFold
=
=
0
)
{
rc
=
SQLITE_ERROR
;
}
if
(
rc
!
=
SQLITE_OK
)
{
fts5TriDelete
(
(
Fts5Tokenizer
*
)
pNew
)
;
pNew
=
0
;
}
}
}
*
ppOut
=
(
Fts5Tokenizer
*
)
pNew
;
return
rc
;
}
static
int
fts5TriTokenize
(
Fts5Tokenizer
*
pTok
void
*
pCtx
int
unusedFlags
const
char
*
pText
int
nText
int
(
*
xToken
)
(
void
*
int
const
char
*
int
int
int
)
)
{
TrigramTokenizer
*
p
=
(
TrigramTokenizer
*
)
pTok
;
int
rc
=
SQLITE_OK
;
char
aBuf
[
32
]
;
char
*
zOut
=
aBuf
;
int
ii
;
const
unsigned
char
*
zIn
=
(
const
unsigned
char
*
)
pText
;
const
unsigned
char
*
zEof
=
(
zIn
?
&
zIn
[
nText
]
:
0
)
;
u32
iCode
=
0
;
int
aStart
[
3
]
;
UNUSED_PARAM
(
unusedFlags
)
;
for
(
ii
=
0
;
ii
<
3
;
ii
+
+
)
{
do
{
aStart
[
ii
]
=
zIn
-
(
const
unsigned
char
*
)
pText
;
if
(
zIn
>
=
zEof
)
return
SQLITE_OK
;
READ_UTF8
(
zIn
zEof
iCode
)
;
if
(
p
-
>
bFold
)
iCode
=
sqlite3Fts5UnicodeFold
(
iCode
p
-
>
iFoldParam
)
;
}
while
(
iCode
=
=
0
)
;
WRITE_UTF8
(
zOut
iCode
)
;
}
assert
(
zIn
<
=
zEof
)
;
while
(
1
)
{
int
iNext
;
const
char
*
z1
;
do
{
iNext
=
zIn
-
(
const
unsigned
char
*
)
pText
;
if
(
zIn
>
=
zEof
)
{
iCode
=
0
;
break
;
}
READ_UTF8
(
zIn
zEof
iCode
)
;
if
(
p
-
>
bFold
)
iCode
=
sqlite3Fts5UnicodeFold
(
iCode
p
-
>
iFoldParam
)
;
}
while
(
iCode
=
=
0
)
;
rc
=
xToken
(
pCtx
0
aBuf
zOut
-
aBuf
aStart
[
0
]
iNext
)
;
if
(
iCode
=
=
0
|
|
rc
!
=
SQLITE_OK
)
break
;
z1
=
aBuf
;
FTS5_SKIP_UTF8
(
z1
)
;
memmove
(
aBuf
z1
zOut
-
z1
)
;
zOut
-
=
(
z1
-
aBuf
)
;
WRITE_UTF8
(
zOut
iCode
)
;
aStart
[
0
]
=
aStart
[
1
]
;
aStart
[
1
]
=
aStart
[
2
]
;
aStart
[
2
]
=
iNext
;
}
return
rc
;
}
static
int
sqlite3Fts5TokenizerPattern
(
int
(
*
xCreate
)
(
void
*
const
char
*
*
int
Fts5Tokenizer
*
*
)
Fts5Tokenizer
*
pTok
)
{
if
(
xCreate
=
=
fts5TriCreate
)
{
TrigramTokenizer
*
p
=
(
TrigramTokenizer
*
)
pTok
;
if
(
p
-
>
iFoldParam
=
=
0
)
{
return
p
-
>
bFold
?
FTS5_PATTERN_LIKE
:
FTS5_PATTERN_GLOB
;
}
}
return
FTS5_PATTERN_NONE
;
}
static
int
sqlite3Fts5TokenizerPreload
(
Fts5TokenizerConfig
*
p
)
{
return
(
p
-
>
nArg
>
=
1
&
&
0
=
=
sqlite3_stricmp
(
p
-
>
azArg
[
0
]
"
trigram
"
)
)
;
}
static
int
sqlite3Fts5TokenizerInit
(
fts5_api
*
pApi
)
{
struct
BuiltinTokenizer
{
const
char
*
zName
;
fts5_tokenizer
x
;
}
aBuiltin
[
]
=
{
{
"
unicode61
"
{
fts5UnicodeCreate
fts5UnicodeDelete
fts5UnicodeTokenize
}
}
{
"
ascii
"
{
fts5AsciiCreate
fts5AsciiDelete
fts5AsciiTokenize
}
}
{
"
trigram
"
{
fts5TriCreate
fts5TriDelete
fts5TriTokenize
}
}
}
;
int
rc
=
SQLITE_OK
;
int
i
;
for
(
i
=
0
;
rc
=
=
SQLITE_OK
&
&
i
<
ArraySize
(
aBuiltin
)
;
i
+
+
)
{
rc
=
pApi
-
>
xCreateTokenizer
(
pApi
aBuiltin
[
i
]
.
zName
(
void
*
)
pApi
&
aBuiltin
[
i
]
.
x
0
)
;
}
if
(
rc
=
=
SQLITE_OK
)
{
fts5_tokenizer_v2
sPorter
=
{
2
fts5PorterCreate
fts5PorterDelete
fts5PorterTokenize
}
;
rc
=
pApi
-
>
xCreateTokenizer_v2
(
pApi
"
porter
"
(
void
*
)
pApi
&
sPorter
0
)
;
}
return
rc
;
}
#
line
1
"
fts5_unicode2
.
c
"
#
include
<
assert
.
h
>
static
int
fts5_remove_diacritic
(
int
c
int
bComplex
)
{
unsigned
short
aDia
[
]
=
{
0
1797
1848
1859
1891
1928
1940
1995
2024
2040
2060
2110
2168
2206
2264
2286
2344
2383
2472
2488
2516
2596
2668
2732
2782
2842
2894
2954
2984
3000
3028
3336
3456
3696
3712
3728
3744
3766
3832
3896
3912
3928
3944
3968
4008
4040
4056
4106
4138
4170
4202
4234
4266
4296
4312
4344
4408
4424
4442
4472
4488
4504
6148
6198
6264
6280
6360
6429
6505
6529
61448
61468
61512
61534
61592
61610
61642
61672
61688
61704
61726
61784
61800
61816
61836
61880
61896
61914
61948
61998
62062
62122
62154
62184
62200
62218
62252
62302
62364
62410
62442
62478
62536
62554
62584
62604
62640
62648
62656
62664
62730
62766
62830
62890
62924
62974
63032
63050
63082
63118
63182
63242
63274
63310
63368
63390
}
;
#
define
HIBIT
(
(
unsigned
char
)
0x80
)
unsigned
char
aChar
[
]
=
{
'
\
0
'
'
a
'
'
c
'
'
e
'
'
i
'
'
n
'
'
o
'
'
u
'
'
y
'
'
y
'
'
a
'
'
c
'
'
d
'
'
e
'
'
e
'
'
g
'
'
h
'
'
i
'
'
j
'
'
k
'
'
l
'
'
n
'
'
o
'
'
r
'
'
s
'
'
t
'
'
u
'
'
u
'
'
w
'
'
y
'
'
z
'
'
o
'
'
u
'
'
a
'
'
i
'
'
o
'
'
u
'
'
u
'
|
HIBIT
'
a
'
|
HIBIT
'
g
'
'
k
'
'
o
'
'
o
'
|
HIBIT
'
j
'
'
g
'
'
n
'
'
a
'
|
HIBIT
'
a
'
'
e
'
'
i
'
'
o
'
'
r
'
'
u
'
'
s
'
'
t
'
'
h
'
'
a
'
'
e
'
'
o
'
|
HIBIT
'
o
'
'
o
'
|
HIBIT
'
y
'
'
\
0
'
'
\
0
'
'
\
0
'
'
\
0
'
'
\
0
'
'
\
0
'
'
\
0
'
'
\
0
'
'
a
'
'
b
'
'
c
'
|
HIBIT
'
d
'
'
d
'
'
e
'
|
HIBIT
'
e
'
'
e
'
|
HIBIT
'
f
'
'
g
'
'
h
'
'
h
'
'
i
'
'
i
'
|
HIBIT
'
k
'
'
l
'
'
l
'
|
HIBIT
'
l
'
'
m
'
'
n
'
'
o
'
|
HIBIT
'
p
'
'
r
'
'
r
'
|
HIBIT
'
r
'
'
s
'
'
s
'
|
HIBIT
'
t
'
'
u
'
'
u
'
|
HIBIT
'
v
'
'
w
'
'
w
'
'
x
'
'
y
'
'
z
'
'
h
'
'
t
'
'
w
'
'
y
'
'
a
'
'
a
'
|
HIBIT
'
a
'
|
HIBIT
'
a
'
|
HIBIT
'
e
'
'
e
'
|
HIBIT
'
e
'
|
HIBIT
'
i
'
'
o
'
'
o
'
|
HIBIT
'
o
'
|
HIBIT
'
o
'
|
HIBIT
'
u
'
'
u
'
|
HIBIT
'
u
'
|
HIBIT
'
y
'
}
;
unsigned
int
key
=
(
(
(
unsigned
int
)
c
)
<
<
3
)
|
0x00000007
;
int
iRes
=
0
;
int
iHi
=
sizeof
(
aDia
)
/
sizeof
(
aDia
[
0
]
)
-
1
;
int
iLo
=
0
;
while
(
iHi
>
=
iLo
)
{
int
iTest
=
(
iHi
+
iLo
)
/
2
;
if
(
key
>
=
aDia
[
iTest
]
)
{
iRes
=
iTest
;
iLo
=
iTest
+
1
;
}
else
{
iHi
=
iTest
-
1
;
}
}
assert
(
key
>
=
aDia
[
iRes
]
)
;
if
(
bComplex
=
=
0
&
&
(
aChar
[
iRes
]
&
0x80
)
)
return
c
;
return
(
c
>
(
aDia
[
iRes
]
>
>
3
)
+
(
aDia
[
iRes
]
&
0x07
)
)
?
c
:
(
(
int
)
aChar
[
iRes
]
&
0x7F
)
;
}
static
int
sqlite3Fts5UnicodeIsdiacritic
(
int
c
)
{
unsigned
int
mask0
=
0x08029FDF
;
unsigned
int
mask1
=
0x000361F8
;
if
(
c
<
768
|
|
c
>
817
)
return
0
;
return
(
c
<
768
+
32
)
?
(
mask0
&
(
(
unsigned
int
)
1
<
<
(
c
-
768
)
)
)
:
(
mask1
&
(
(
unsigned
int
)
1
<
<
(
c
-
768
-
32
)
)
)
;
}
static
int
sqlite3Fts5UnicodeFold
(
int
c
int
eRemoveDiacritic
)
{
static
const
struct
TableEntry
{
unsigned
short
iCode
;
unsigned
char
flags
;
unsigned
char
nRange
;
}
aEntry
[
]
=
{
{
65
14
26
}
{
181
64
1
}
{
192
14
23
}
{
216
14
7
}
{
256
1
48
}
{
306
1
6
}
{
313
1
16
}
{
330
1
46
}
{
376
116
1
}
{
377
1
6
}
{
383
104
1
}
{
385
50
1
}
{
386
1
4
}
{
390
44
1
}
{
391
0
1
}
{
393
42
2
}
{
395
0
1
}
{
398
32
1
}
{
399
38
1
}
{
400
40
1
}
{
401
0
1
}
{
403
42
1
}
{
404
46
1
}
{
406
52
1
}
{
407
48
1
}
{
408
0
1
}
{
412
52
1
}
{
413
54
1
}
{
415
56
1
}
{
416
1
6
}
{
422
60
1
}
{
423
0
1
}
{
425
60
1
}
{
428
0
1
}
{
430
60
1
}
{
431
0
1
}
{
433
58
2
}
{
435
1
4
}
{
439
62
1
}
{
440
0
1
}
{
444
0
1
}
{
452
2
1
}
{
453
0
1
}
{
455
2
1
}
{
456
0
1
}
{
458
2
1
}
{
459
1
18
}
{
478
1
18
}
{
497
2
1
}
{
498
1
4
}
{
502
122
1
}
{
503
134
1
}
{
504
1
40
}
{
544
110
1
}
{
546
1
18
}
{
570
70
1
}
{
571
0
1
}
{
573
108
1
}
{
574
68
1
}
{
577
0
1
}
{
579
106
1
}
{
580
28
1
}
{
581
30
1
}
{
582
1
10
}
{
837
36
1
}
{
880
1
4
}
{
886
0
1
}
{
902
18
1
}
{
904
16
3
}
{
908
26
1
}
{
910
24
2
}
{
913
14
17
}
{
931
14
9
}
{
962
0
1
}
{
975
4
1
}
{
976
140
1
}
{
977
142
1
}
{
981
146
1
}
{
982
144
1
}
{
984
1
24
}
{
1008
136
1
}
{
1009
138
1
}
{
1012
130
1
}
{
1013
128
1
}
{
1015
0
1
}
{
1017
152
1
}
{
1018
0
1
}
{
1021
110
3
}
{
1024
34
16
}
{
1040
14
32
}
{
1120
1
34
}
{
1162
1
54
}
{
1216
6
1
}
{
1217
1
14
}
{
1232
1
88
}
{
1329
22
38
}
{
4256
66
38
}
{
4295
66
1
}
{
4301
66
1
}
{
7680
1
150
}
{
7835
132
1
}
{
7838
96
1
}
{
7840
1
96
}
{
7944
150
8
}
{
7960
150
6
}
{
7976
150
8
}
{
7992
150
8
}
{
8008
150
6
}
{
8025
151
8
}
{
8040
150
8
}
{
8072
150
8
}
{
8088
150
8
}
{
8104
150
8
}
{
8120
150
2
}
{
8122
126
2
}
{
8124
148
1
}
{
8126
100
1
}
{
8136
124
4
}
{
8140
148
1
}
{
8152
150
2
}
{
8154
120
2
}
{
8168
150
2
}
{
8170
118
2
}
{
8172
152
1
}
{
8184
112
2
}
{
8186
114
2
}
{
8188
148
1
}
{
8486
98
1
}
{
8490
92
1
}
{
8491
94
1
}
{
8498
12
1
}
{
8544
8
16
}
{
8579
0
1
}
{
9398
10
26
}
{
11264
22
47
}
{
11360
0
1
}
{
11362
88
1
}
{
11363
102
1
}
{
11364
90
1
}
{
11367
1
6
}
{
11373
84
1
}
{
11374
86
1
}
{
11375
80
1
}
{
11376
82
1
}
{
11378
0
1
}
{
11381
0
1
}
{
11390
78
2
}
{
11392
1
100
}
{
11499
1
4
}
{
11506
0
1
}
{
42560
1
46
}
{
42624
1
24
}
{
42786
1
14
}
{
42802
1
62
}
{
42873
1
4
}
{
42877
76
1
}
{
42878
1
10
}
{
42891
0
1
}
{
42893
74
1
}
{
42896
1
4
}
{
42912
1
10
}
{
42922
72
1
}
{
65313
14
26
}
}
;
static
const
unsigned
short
aiOff
[
]
=
{
1
2
8
15
16
26
28
32
37
38
40
48
63
64
69
71
79
80
116
202
203
205
206
207
209
210
211
213
214
217
218
219
775
7264
10792
10795
23228
23256
30204
54721
54753
54754
54756
54787
54793
54809
57153
57274
57921
58019
58363
61722
65268
65341
65373
65406
65408
65410
65415
65424
65436
65439
65450
65462
65472
65476
65478
65480
65482
65488
65506
65511
65514
65521
65527
65528
65529
}
;
int
ret
=
c
;
assert
(
sizeof
(
unsigned
short
)
=
=
2
&
&
sizeof
(
unsigned
char
)
=
=
1
)
;
if
(
c
<
128
)
{
if
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
ret
=
c
+
(
'
a
'
-
'
A
'
)
;
}
else
if
(
c
<
65536
)
{
const
struct
TableEntry
*
p
;
int
iHi
=
sizeof
(
aEntry
)
/
sizeof
(
aEntry
[
0
]
)
-
1
;
int
iLo
=
0
;
int
iRes
=
-
1
;
assert
(
c
>
aEntry
[
0
]
.
iCode
)
;
while
(
iHi
>
=
iLo
)
{
int
iTest
=
(
iHi
+
iLo
)
/
2
;
int
cmp
=
(
c
-
aEntry
[
iTest
]
.
iCode
)
;
if
(
cmp
>
=
0
)
{
iRes
=
iTest
;
iLo
=
iTest
+
1
;
}
else
{
iHi
=
iTest
-
1
;
}
}
assert
(
iRes
>
=
0
&
&
c
>
=
aEntry
[
iRes
]
.
iCode
)
;
p
=
&
aEntry
[
iRes
]
;
if
(
c
<
(
p
-
>
iCode
+
p
-
>
nRange
)
&
&
0
=
=
(
0x01
&
p
-
>
flags
&
(
p
-
>
iCode
^
c
)
)
)
{
ret
=
(
c
+
(
aiOff
[
p
-
>
flags
>
>
1
]
)
)
&
0x0000FFFF
;
assert
(
ret
>
0
)
;
}
if
(
eRemoveDiacritic
)
{
ret
=
fts5_remove_diacritic
(
ret
eRemoveDiacritic
=
=
2
)
;
}
}
else
if
(
c
>
=
66560
&
&
c
<
66600
)
{
ret
=
c
+
40
;
}
return
ret
;
}
static
int
sqlite3Fts5UnicodeCatParse
(
const
char
*
zCat
u8
*
aArray
)
{
aArray
[
0
]
=
1
;
switch
(
zCat
[
0
]
)
{
case
'
C
'
:
switch
(
zCat
[
1
]
)
{
case
'
c
'
:
aArray
[
1
]
=
1
;
break
;
case
'
f
'
:
aArray
[
2
]
=
1
;
break
;
case
'
n
'
:
aArray
[
3
]
=
1
;
break
;
case
'
s
'
:
aArray
[
4
]
=
1
;
break
;
case
'
o
'
:
aArray
[
31
]
=
1
;
break
;
case
'
*
'
:
aArray
[
1
]
=
1
;
aArray
[
2
]
=
1
;
aArray
[
3
]
=
1
;
aArray
[
4
]
=
1
;
aArray
[
31
]
=
1
;
break
;
default
:
return
1
;
}
break
;
case
'
L
'
:
switch
(
zCat
[
1
]
)
{
case
'
l
'
:
aArray
[
5
]
=
1
;
break
;
case
'
m
'
:
aArray
[
6
]
=
1
;
break
;
case
'
o
'
:
aArray
[
7
]
=
1
;
break
;
case
'
t
'
:
aArray
[
8
]
=
1
;
break
;
case
'
u
'
:
aArray
[
9
]
=
1
;
break
;
case
'
C
'
:
aArray
[
30
]
=
1
;
break
;
case
'
*
'
:
aArray
[
5
]
=
1
;
aArray
[
6
]
=
1
;
aArray
[
7
]
=
1
;
aArray
[
8
]
=
1
;
aArray
[
9
]
=
1
;
aArray
[
30
]
=
1
;
break
;
default
:
return
1
;
}
break
;
case
'
M
'
:
switch
(
zCat
[
1
]
)
{
case
'
c
'
:
aArray
[
10
]
=
1
;
break
;
case
'
e
'
:
aArray
[
11
]
=
1
;
break
;
case
'
n
'
:
aArray
[
12
]
=
1
;
break
;
case
'
*
'
:
aArray
[
10
]
=
1
;
aArray
[
11
]
=
1
;
aArray
[
12
]
=
1
;
break
;
default
:
return
1
;
}
break
;
case
'
N
'
:
switch
(
zCat
[
1
]
)
{
case
'
d
'
:
aArray
[
13
]
=
1
;
break
;
case
'
l
'
:
aArray
[
14
]
=
1
;
break
;
case
'
o
'
:
aArray
[
15
]
=
1
;
break
;
case
'
*
'
:
aArray
[
13
]
=
1
;
aArray
[
14
]
=
1
;
aArray
[
15
]
=
1
;
break
;
default
:
return
1
;
}
break
;
case
'
P
'
:
switch
(
zCat
[
1
]
)
{
case
'
c
'
:
aArray
[
16
]
=
1
;
break
;
case
'
d
'
:
aArray
[
17
]
=
1
;
break
;
case
'
e
'
:
aArray
[
18
]
=
1
;
break
;
case
'
f
'
:
aArray
[
19
]
=
1
;
break
;
case
'
i
'
:
aArray
[
20
]
=
1
;
break
;
case
'
o
'
:
aArray
[
21
]
=
1
;
break
;
case
'
s
'
:
aArray
[
22
]
=
1
;
break
;
case
'
*
'
:
aArray
[
16
]
=
1
;
aArray
[
17
]
=
1
;
aArray
[
18
]
=
1
;
aArray
[
19
]
=
1
;
aArray
[
20
]
=
1
;
aArray
[
21
]
=
1
;
aArray
[
22
]
=
1
;
break
;
default
:
return
1
;
}
break
;
case
'
S
'
:
switch
(
zCat
[
1
]
)
{
case
'
c
'
:
aArray
[
23
]
=
1
;
break
;
case
'
k
'
:
aArray
[
24
]
=
1
;
break
;
case
'
m
'
:
aArray
[
25
]
=
1
;
break
;
case
'
o
'
:
aArray
[
26
]
=
1
;
break
;
case
'
*
'
:
aArray
[
23
]
=
1
;
aArray
[
24
]
=
1
;
aArray
[
25
]
=
1
;
aArray
[
26
]
=
1
;
break
;
default
:
return
1
;
}
break
;
case
'
Z
'
:
switch
(
zCat
[
1
]
)
{
case
'
l
'
:
aArray
[
27
]
=
1
;
break
;
case
'
p
'
:
aArray
[
28
]
=
1
;
break
;
case
'
s
'
:
aArray
[
29
]
=
1
;
break
;
case
'
*
'
:
aArray
[
27
]
=
1
;
aArray
[
28
]
=
1
;
aArray
[
29
]
=
1
;
break
;
default
:
return
1
;
}
break
;
default
:
return
1
;
}
return
0
;
}
static
u16
aFts5UnicodeBlock
[
]
=
{
0
1471
1753
1760
1760
1760
1760
1760
1760
1760
1760
1760
1760
1760
1760
1763
1765
}
;
static
u16
aFts5UnicodeMap
[
]
=
{
0
32
33
36
37
40
41
42
43
44
45
46
48
58
60
63
65
91
92
93
94
95
96
97
123
124
125
126
127
160
161
162
166
167
168
169
170
171
172
173
174
175
176
177
178
180
181
182
184
185
186
187
188
191
192
215
216
223
247
248
256
312
313
329
330
377
383
385
387
388
391
394
396
398
402
403
405
406
409
412
414
415
417
418
423
427
428
431
434
436
437
440
442
443
444
446
448
452
453
454
455
456
457
458
459
460
461
477
478
496
497
498
499
500
503
505
506
564
570
572
573
575
577
580
583
584
592
660
661
688
706
710
722
736
741
748
749
750
751
768
880
884
885
886
890
891
894
900
902
903
904
908
910
912
913
931
940
975
977
978
981
984
1008
1012
1014
1015
1018
1020
1021
1072
1120
1154
1155
1160
1162
1217
1231
1232
1329
1369
1370
1377
1417
1418
1423
1425
1470
1471
1472
1473
1475
1476
1478
1479
1488
1520
1523
1536
1542
1545
1547
1548
1550
1552
1563
1566
1568
1600
1601
1611
1632
1642
1646
1648
1649
1748
1749
1750
1757
1758
1759
1765
1767
1769
1770
1774
1776
1786
1789
1791
1792
1807
1808
1809
1810
1840
1869
1958
1969
1984
1994
2027
2036
2038
2039
2042
2048
2070
2074
2075
2084
2085
2088
2089
2096
2112
2137
2142
2208
2210
2276
2304
2307
2308
2362
2363
2364
2365
2366
2369
2377
2381
2382
2384
2385
2392
2402
2404
2406
2416
2417
2418
2425
2433
2434
2437
2447
2451
2474
2482
2486
2492
2493
2494
2497
2503
2507
2509
2510
2519
2524
2527
2530
2534
2544
2546
2548
2554
2555
2561
2563
2565
2575
2579
2602
2610
2613
2616
2620
2622
2625
2631
2635
2641
2649
2654
2662
2672
2674
2677
2689
2691
2693
2703
2707
2730
2738
2741
2748
2749
2750
2753
2759
2761
2763
2765
2768
2784
2786
2790
2800
2801
2817
2818
2821
2831
2835
2858
2866
2869
2876
2877
2878
2879
2880
2881
2887
2891
2893
2902
2903
2908
2911
2914
2918
2928
2929
2930
2946
2947
2949
2958
2962
2969
2972
2974
2979
2984
2990
3006
3008
3009
3014
3018
3021
3024
3031
3046
3056
3059
3065
3066
3073
3077
3086
3090
3114
3125
3133
3134
3137
3142
3146
3157
3160
3168
3170
3174
3192
3199
3202
3205
3214
3218
3242
3253
3260
3261
3262
3263
3264
3270
3271
3274
3276
3285
3294
3296
3298
3302
3313
3330
3333
3342
3346
3389
3390
3393
3398
3402
3405
3406
3415
3424
3426
3430
3440
3449
3450
3458
3461
3482
3507
3517
3520
3530
3535
3538
3542
3544
3570
3572
3585
3633
3634
3636
3647
3648
3654
3655
3663
3664
3674
3713
3716
3719
3722
3725
3732
3737
3745
3749
3751
3754
3757
3761
3762
3764
3771
3773
3776
3782
3784
3792
3804
3840
3841
3844
3859
3860
3861
3864
3866
3872
3882
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901
3902
3904
3913
3953
3967
3968
3973
3974
3976
3981
3993
4030
4038
4039
4046
4048
4053
4057
4096
4139
4141
4145
4146
4152
4153
4155
4157
4159
4160
4170
4176
4182
4184
4186
4190
4193
4194
4197
4199
4206
4209
4213
4226
4227
4229
4231
4237
4238
4239
4240
4250
4253
4254
4256
4295
4301
4304
4347
4348
4349
4682
4688
4696
4698
4704
4746
4752
4786
4792
4800
4802
4808
4824
4882
4888
4957
4960
4969
4992
5008
5024
5120
5121
5741
5743
5760
5761
5787
5788
5792
5867
5870
5888
5902
5906
5920
5938
5941
5952
5970
5984
5998
6002
6016
6068
6070
6071
6078
6086
6087
6089
6100
6103
6104
6107
6108
6109
6112
6128
6144
6150
6151
6155
6158
6160
6176
6211
6212
6272
6313
6314
6320
6400
6432
6435
6439
6441
6448
6450
6451
6457
6464
6468
6470
6480
6512
6528
6576
6593
6600
6608
6618
6622
6656
6679
6681
6686
6688
6741
6742
6743
6744
6752
6753
6754
6755
6757
6765
6771
6783
6784
6800
6816
6823
6824
6912
6916
6917
6964
6965
6966
6971
6972
6973
6978
6979
6981
6992
7002
7009
7019
7028
7040
7042
7043
7073
7074
7078
7080
7082
7083
7084
7086
7088
7098
7142
7143
7144
7146
7149
7150
7151
7154
7164
7168
7204
7212
7220
7222
7227
7232
7245
7248
7258
7288
7294
7360
7376
7379
7380
7393
7394
7401
7405
7406
7410
7412
7413
7424
7468
7531
7544
7545
7579
7616
7676
7680
7830
7838
7936
7944
7952
7960
7968
7976
7984
7992
8000
8008
8016
8025
8027
8029
8031
8033
8040
8048
8064
8072
8080
8088
8096
8104
8112
8118
8120
8124
8125
8126
8127
8130
8134
8136
8140
8141
8144
8150
8152
8157
8160
8168
8173
8178
8182
8184
8188
8189
8192
8203
8208
8214
8216
8217
8218
8219
8221
8222
8223
8224
8232
8233
8234
8239
8240
8249
8250
8251
8255
8257
8260
8261
8262
8263
8274
8275
8276
8277
8287
8288
8298
8304
8305
8308
8314
8317
8318
8319
8320
8330
8333
8334
8336
8352
8400
8413
8417
8418
8421
8448
8450
8451
8455
8456
8458
8459
8462
8464
8467
8468
8469
8470
8472
8473
8478
8484
8485
8486
8487
8488
8489
8490
8494
8495
8496
8500
8501
8505
8506
8508
8510
8512
8517
8519
8522
8523
8524
8526
8527
8528
8544
8579
8581
8585
8592
8597
8602
8604
8608
8609
8611
8612
8614
8615
8622
8623
8654
8656
8658
8659
8660
8661
8692
8960
8968
8972
8992
8994
9001
9002
9003
9084
9085
9115
9140
9180
9186
9216
9280
9312
9372
9450
9472
9655
9656
9665
9666
9720
9728
9839
9840
9985
10088
10089
10090
10091
10092
10093
10094
10095
10096
10097
10098
10099
10100
10101
10102
10132
10176
10181
10182
10183
10214
10215
10216
10217
10218
10219
10220
10221
10222
10223
10224
10240
10496
10627
10628
10629
10630
10631
10632
10633
10634
10635
10636
10637
10638
10639
10640
10641
10642
10643
10644
10645
10646
10647
10648
10649
10712
10713
10714
10715
10716
10748
10749
10750
11008
11056
11077
11079
11088
11264
11312
11360
11363
11365
11367
11374
11377
11378
11380
11381
11383
11388
11390
11393
11394
11492
11493
11499
11503
11506
11513
11517
11518
11520
11559
11565
11568
11631
11632
11647
11648
11680
11688
11696
11704
11712
11720
11728
11736
11744
11776
11778
11779
11780
11781
11782
11785
11786
11787
11788
11789
11790
11799
11800
11802
11803
11804
11805
11806
11808
11809
11810
11811
11812
11813
11814
11815
11816
11817
11818
11823
11824
11834
11904
11931
12032
12272
12288
12289
12292
12293
12294
12295
12296
12297
12298
12299
12300
12301
12302
12303
12304
12305
12306
12308
12309
12310
12311
12312
12313
12314
12315
12316
12317
12318
12320
12321
12330
12334
12336
12337
12342
12344
12347
12348
12349
12350
12353
12441
12443
12445
12447
12448
12449
12539
12540
12543
12549
12593
12688
12690
12694
12704
12736
12784
12800
12832
12842
12872
12880
12881
12896
12928
12938
12977
12992
13056
13312
19893
19904
19968
40908
40960
40981
40982
42128
42192
42232
42238
42240
42508
42509
42512
42528
42538
42560
42606
42607
42608
42611
42612
42622
42623
42624
42655
42656
42726
42736
42738
42752
42775
42784
42786
42800
42802
42864
42865
42873
42878
42888
42889
42891
42896
42912
43000
43002
43003
43010
43011
43014
43015
43019
43020
43043
43045
43047
43048
43056
43062
43064
43065
43072
43124
43136
43138
43188
43204
43214
43216
43232
43250
43256
43259
43264
43274
43302
43310
43312
43335
43346
43359
43360
43392
43395
43396
43443
43444
43446
43450
43452
43453
43457
43471
43472
43486
43520
43561
43567
43569
43571
43573
43584
43587
43588
43596
43597
43600
43612
43616
43632
43633
43639
43642
43643
43648
43696
43697
43698
43701
43703
43705
43710
43712
43713
43714
43739
43741
43742
43744
43755
43756
43758
43760
43762
43763
43765
43766
43777
43785
43793
43808
43816
43968
44003
44005
44006
44008
44009
44011
44012
44013
44016
44032
55203
55216
55243
55296
56191
56319
57343
57344
63743
63744
64112
64256
64275
64285
64286
64287
64297
64298
64312
64318
64320
64323
64326
64434
64467
64830
64831
64848
64914
65008
65020
65021
65024
65040
65047
65048
65049
65056
65072
65073
65075
65077
65078
65079
65080
65081
65082
65083
65084
65085
65086
65087
65088
65089
65090
65091
65092
65093
65095
65096
65097
65101
65104
65108
65112
65113
65114
65115
65116
65117
65118
65119
65122
65123
65124
65128
65129
65130
65136
65142
65279
65281
65284
65285
65288
65289
65290
65291
65292
65293
65294
65296
65306
65308
65311
65313
65339
65340
65341
65342
65343
65344
65345
65371
65372
65373
65374
65375
65376
65377
65378
65379
65380
65382
65392
65393
65438
65440
65474
65482
65490
65498
65504
65506
65507
65508
65509
65512
65513
65517
65529
65532
0
13
40
60
63
80
128
256
263
311
320
373
377
394
400
464
509
640
672
768
800
816
833
834
842
896
927
928
968
976
977
1024
1064
1104
1184
2048
2056
2058
2103
2108
2111
2135
2136
2304
2326
2335
2336
2367
2432
2494
2560
2561
2565
2572
2576
2581
2585
2616
2623
2624
2640
2656
2685
2687
2816
2873
2880
2904
2912
2936
3072
3680
4096
4097
4098
4099
4152
4167
4178
4198
4224
4226
4227
4272
4275
4279
4281
4283
4285
4286
4304
4336
4352
4355
4391
4396
4397
4406
4416
4480
4482
4483
4531
4534
4543
4545
4549
4560
5760
5803
5804
5805
5806
5808
5814
5815
5824
8192
9216
9328
12288
26624
28416
28496
28497
28559
28563
45056
53248
53504
53545
53605
53607
53610
53613
53619
53627
53635
53637
53644
53674
53678
53760
53826
53829
54016
54112
54272
54298
54324
54350
54358
54376
54402
54428
54430
54434
54437
54441
54446
54454
54459
54461
54469
54480
54506
54532
54535
54541
54550
54558
54584
54587
54592
54598
54602
54610
54636
54662
54688
54714
54740
54766
54792
54818
54844
54870
54896
54922
54952
54977
54978
55003
55004
55010
55035
55036
55061
55062
55068
55093
55094
55119
55120
55126
55151
55152
55177
55178
55184
55209
55210
55235
55236
55242
55246
60928
60933
60961
60964
60967
60969
60980
60985
60987
60994
60999
61001
61003
61005
61009
61012
61015
61017
61019
61021
61023
61025
61028
61031
61036
61044
61049
61054
61056
61067
61089
61093
61099
61168
61440
61488
61600
61617
61633
61649
61696
61712
61744
61808
61926
61968
62016
62032
62208
62256
62263
62336
62368
62406
62432
62464
62528
62530
62713
62720
62784
62800
62971
63045
63104
63232
0
42710
42752
46900
46912
47133
63488
1
32
256
0
65533
}
;
static
u16
aFts5UnicodeData
[
]
=
{
1025
61
117
55
117
54
50
53
57
53
49
85
333
85
121
85
841
54
53
50
56
48
56
837
54
57
50
57
1057
61
53
151
58
53
56
58
39
52
57
34
58
56
58
57
79
56
37
85
56
47
39
51
111
53
745
57
233
773
57
261
1822
37
542
37
1534
222
69
73
37
126
126
73
69
137
37
73
37
105
101
73
37
73
37
190
158
37
126
126
73
37
126
94
37
39
94
69
135
41
40
37
41
40
37
41
40
37
542
37
606
37
41
40
37
126
73
37
1886
197
73
37
73
69
126
105
37
286
2181
39
869
582
152
390
472
166
248
38
56
38
568
3596
158
38
56
94
38
101
53
88
41
53
105
41
73
37
553
297
1125
94
37
105
101
798
133
94
57
126
94
37
1641
1541
1118
58
172
75
1790
478
37
2846
1225
38
213
1253
53
49
55
1452
49
44
53
76
53
76
53
44
871
103
85
162
121
85
55
85
90
364
53
85
1031
38
327
684
333
149
71
44
3175
53
39
236
34
58
204
70
76
58
140
71
333
103
90
39
469
34
39
44
967
876
2855
364
39
333
1063
300
70
58
117
38
711
140
38
300
38
108
38
172
501
807
108
53
39
359
876
108
42
1735
44
42
44
39
106
268
138
44
74
39
236
327
76
85
333
53
38
199
231
44
74
263
71
711
231
39
135
44
39
106
140
74
74
44
39
42
71
103
76
333
71
87
207
58
55
76
42
199
71
711
231
71
71
71
44
106
76
76
108
44
135
39
333
76
103
44
76
42
295
103
711
231
71
167
44
39
106
172
76
42
74
44
39
71
76
333
53
55
44
74
263
71
711
231
71
167
44
39
42
44
42
140
74
74
44
44
42
71
103
76
333
58
39
207
44
39
199
103
135
71
39
71
71
103
391
74
44
74
106
106
44
39
42
333
111
218
55
58
106
263
103
743
327
167
39
108
138
108
140
76
71
71
76
333
239
58
74
263
103
743
327
167
44
39
42
44
170
44
74
74
76
74
39
71
76
333
71
74
263
103
1319
39
106
140
106
106
44
39
42
71
76
333
207
58
199
74
583
775
295
39
231
44
106
108
44
266
74
53
1543
44
71
236
55
199
38
268
53
333
85
71
39
71
39
39
135
231
103
39
39
71
135
44
71
204
76
39
167
38
204
333
135
39
122
501
58
53
122
76
218
333
335
58
44
58
44
58
44
54
50
54
50
74
263
1159
460
42
172
53
76
167
364
1164
282
44
218
90
181
154
85
1383
74
140
42
204
42
76
74
76
39
333
213
199
74
76
135
108
39
106
71
234
103
140
423
44
74
76
202
44
39
42
333
106
44
90
1225
41
41
1383
53
38
10631
135
231
39
135
1319
135
1063
135
231
39
135
487
1831
135
2151
108
309
655
519
346
2727
49
19847
85
551
61
839
54
50
2407
117
110
423
135
108
583
108
85
583
76
423
103
76
1671
76
42
236
266
44
74
364
117
38
117
55
39
44
333
335
213
49
149
108
61
333
1127
38
1671
1319
44
39
2247
935
108
138
76
106
74
44
202
108
58
85
333
967
167
1415
554
231
74
333
47
1114
743
76
106
85
1703
42
44
42
236
44
42
44
74
268
202
332
44
333
333
245
38
213
140
42
1511
44
42
172
42
44
170
44
74
231
333
245
346
300
314
76
42
967
42
140
74
76
42
44
74
71
333
1415
44
42
76
106
44
42
108
74
149
1159
266
268
74
76
181
333
103
333
967
198
85
277
108
53
428
42
236
135
44
135
74
44
71
1413
2022
421
38
1093
1190
1260
140
4830
261
3166
261
265
197
201
261
265
261
265
197
201
261
41
41
41
94
229
265
453
261
264
261
264
261
264
165
69
137
40
56
37
120
101
69
137
40
120
133
69
137
120
261
169
120
101
69
137
40
88
381
162
209
85
52
51
54
84
51
54
52
277
59
60
162
61
309
52
51
149
80
117
57
54
50
373
57
53
48
341
61
162
194
47
38
207
121
54
50
38
335
121
54
50
422
855
428
139
44
107
396
90
41
154
41
90
37
105
69
105
37
58
41
90
57
169
218
41
58
41
58
41
58
137
58
37
137
37
135
37
90
69
73
185
94
101
58
57
90
37
58
527
1134
94
142
47
185
186
89
154
57
90
57
90
57
250
57
1018
89
90
57
58
57
1018
8601
282
153
666
89
250
54
50
2618
57
986
825
1306
217
602
1274
378
1935
2522
719
5882
57
314
57
1754
281
3578
57
4634
3322
54
50
54
50
54
50
54
50
54
50
54
50
54
50
975
1434
185
54
50
1017
54
50
54
50
54
50
54
50
54
50
537
8218
4217
54
50
54
50
54
50
54
50
54
50
54
50
54
50
54
50
54
50
54
50
54
50
2041
54
50
54
50
1049
54
50
8281
1562
697
90
217
346
1513
1509
126
73
69
254
105
37
94
37
94
165
70
105
37
3166
37
218
158
108
94
149
47
85
1221
37
37
1799
38
53
44
743
231
231
231
231
231
231
231
231
1036
85
52
51
52
51
117
52
51
53
52
51
309
49
85
49
53
52
51
85
52
51
54
50
54
50
54
50
54
50
181
38
341
81
858
2874
6874
410
61
117
58
38
39
46
54
50
54
50
54
50
54
50
54
50
90
54
50
54
50
54
50
54
50
49
54
82
58
302
140
74
49
166
90
110
38
39
53
90
2759
76
88
70
39
49
2887
53
102
39
1319
3015
90
143
346
871
1178
519
1018
335
986
271
58
495
1050
335
1274
495
2042
8218
39
39
2074
39
39
679
38
36583
1786
1287
198
85
8583
38
117
519
333
71
1502
39
44
107
53
332
53
38
798
44
2247
334
76
213
760
294
88
478
69
2014
38
261
190
350
38
88
158
158
382
70
37
231
44
103
44
135
44
743
74
76
42
154
207
90
55
58
1671
149
74
1607
522
44
85
333
588
199
117
39
333
903
268
85
743
364
74
53
935
108
42
1511
44
74
140
74
44
138
437
38
333
85
1319
204
74
76
74
76
103
44
263
44
42
333
149
519
38
199
122
39
42
1543
44
39
108
71
76
167
76
39
44
39
71
38
85
359
42
76
74
85
39
70
42
44
199
199
199
231
231
1127
74
44
74
44
74
53
42
44
333
39
39
743
1575
36
68
68
36
63
63
11719
3399
229
165
39
44
327
57
423
167
39
71
71
3463
536
11623
54
50
2055
1735
391
55
58
524
245
54
50
53
236
53
81
80
54
50
54
50
54
50
54
50
54
50
54
50
54
50
54
50
85
54
50
149
112
117
149
49
54
50
54
50
54
50
117
57
49
121
53
55
85
167
4327
34
117
55
117
54
50
53
57
53
49
85
333
85
121
85
841
54
53
50
56
48
56
837
54
57
50
57
54
50
53
54
50
85
327
38
1447
70
999
199
199
199
103
87
57
56
58
87
58
153
90
98
90
391
839
615
71
487
455
3943
117
1455
314
1710
143
570
47
410
1466
44
935
1575
999
143
551
46
263
46
967
53
1159
263
53
174
1289
1285
2503
333
199
39
1415
71
39
743
53
271
711
207
53
839
53
1799
71
39
108
76
140
135
103
871
108
44
271
309
935
79
53
1735
245
711
271
615
271
2343
1007
42
44
42
1703
492
245
655
333
76
42
1447
106
140
74
76
85
34
149
807
333
108
1159
172
42
268
333
149
76
42
1543
106
300
74
135
149
333
1383
44
42
44
74
204
42
44
333
28135
3182
149
34279
18215
2215
39
1482
140
422
71
7898
1274
1946
74
108
122
202
258
268
90
236
986
140
1562
2138
108
58
2810
591
841
837
841
229
581
841
837
41
73
41
73
137
265
133
37
229
357
841
837
73
137
265
233
837
73
137
169
41
233
837
841
837
841
837
841
837
841
837
841
837
841
901
809
57
805
57
197
809
57
805
57
197
809
57
805
57
197
809
57
805
57
197
809
57
805
57
197
94
1613
135
871
71
39
39
327
135
39
39
39
39
39
39
103
71
39
39
39
39
39
39
71
39
135
231
135
135
39
327
551
103
167
551
89
1434
3226
506
474
506
506
367
1018
1946
1402
954
1402
314
90
1082
218
2266
666
1210
186
570
2042
58
5850
154
2010
154
794
2266
378
2266
3738
39
39
39
39
39
39
17351
34
3074
7692
63
63
}
;
static
int
sqlite3Fts5UnicodeCategory
(
u32
iCode
)
{
int
iRes
=
-
1
;
int
iHi
;
int
iLo
;
int
ret
;
u16
iKey
;
if
(
iCode
>
=
(
1
<
<
20
)
)
{
return
0
;
}
iLo
=
aFts5UnicodeBlock
[
(
iCode
>
>
16
)
]
;
iHi
=
aFts5UnicodeBlock
[
1
+
(
iCode
>
>
16
)
]
;
iKey
=
(
iCode
&
0xFFFF
)
;
while
(
iHi
>
iLo
)
{
int
iTest
=
(
iHi
+
iLo
)
/
2
;
assert
(
iTest
>
=
iLo
&
&
iTest
<
iHi
)
;
if
(
iKey
>
=
aFts5UnicodeMap
[
iTest
]
)
{
iRes
=
iTest
;
iLo
=
iTest
+
1
;
}
else
{
iHi
=
iTest
;
}
}
if
(
iRes
<
0
)
return
0
;
if
(
iKey
>
=
(
aFts5UnicodeMap
[
iRes
]
+
(
aFts5UnicodeData
[
iRes
]
>
>
5
)
)
)
return
0
;
ret
=
aFts5UnicodeData
[
iRes
]
&
0x1F
;
if
(
ret
!
=
30
)
return
ret
;
return
(
(
iKey
-
aFts5UnicodeMap
[
iRes
]
)
&
0x01
)
?
5
:
9
;
}
static
void
sqlite3Fts5UnicodeAscii
(
u8
*
aArray
u8
*
aAscii
)
{
int
i
=
0
;
int
iTbl
=
0
;
while
(
i
<
128
)
{
int
bToken
=
aArray
[
aFts5UnicodeData
[
iTbl
]
&
0x1F
]
;
int
n
=
(
aFts5UnicodeData
[
iTbl
]
>
>
5
)
+
i
;
for
(
;
i
<
128
&
&
i
<
n
;
i
+
+
)
{
aAscii
[
i
]
=
(
u8
)
bToken
;
}
iTbl
+
+
;
}
aAscii
[
0
]
=
0
;
}
#
line
1
"
fts5_varint
.
c
"
static
int
sqlite3Fts5GetVarint32
(
const
unsigned
char
*
p
u32
*
v
)
{
u32
a
b
;
a
=
*
p
;
if
(
!
(
a
&
0x80
)
)
{
*
v
=
a
;
return
1
;
}
p
+
+
;
b
=
*
p
;
if
(
!
(
b
&
0x80
)
)
{
a
&
=
0x7f
;
a
=
a
<
<
7
;
*
v
=
a
|
b
;
return
2
;
}
p
+
+
;
a
=
a
<
<
14
;
a
|
=
*
p
;
if
(
!
(
a
&
0x80
)
)
{
a
&
=
(
0x7f
<
<
14
)
|
(
0x7f
)
;
b
&
=
0x7f
;
b
=
b
<
<
7
;
*
v
=
a
|
b
;
return
3
;
}
{
u64
v64
;
u8
n
;
p
-
=
2
;
n
=
sqlite3Fts5GetVarint
(
p
&
v64
)
;
*
v
=
(
(
u32
)
v64
)
&
0x7FFFFFFF
;
assert
(
n
>
3
&
&
n
<
=
9
)
;
return
n
;
}
}
#
define
SLOT_2_0
0x001fc07f
#
define
SLOT_4_2_0
0xf01fc07f
static
u8
sqlite3Fts5GetVarint
(
const
unsigned
char
*
p
u64
*
v
)
{
u32
a
b
s
;
a
=
*
p
;
if
(
!
(
a
&
0x80
)
)
{
*
v
=
a
;
return
1
;
}
p
+
+
;
b
=
*
p
;
if
(
!
(
b
&
0x80
)
)
{
a
&
=
0x7f
;
a
=
a
<
<
7
;
a
|
=
b
;
*
v
=
a
;
return
2
;
}
assert
(
SLOT_2_0
=
=
(
(
0x7f
<
<
14
)
|
(
0x7f
)
)
)
;
assert
(
SLOT_4_2_0
=
=
(
(
0xfU
<
<
28
)
|
(
0x7f
<
<
14
)
|
(
0x7f
)
)
)
;
p
+
+
;
a
=
a
<
<
14
;
a
|
=
*
p
;
if
(
!
(
a
&
0x80
)
)
{
a
&
=
SLOT_2_0
;
b
&
=
0x7f
;
b
=
b
<
<
7
;
a
|
=
b
;
*
v
=
a
;
return
3
;
}
a
&
=
SLOT_2_0
;
p
+
+
;
b
=
b
<
<
14
;
b
|
=
*
p
;
if
(
!
(
b
&
0x80
)
)
{
b
&
=
SLOT_2_0
;
a
=
a
<
<
7
;
a
|
=
b
;
*
v
=
a
;
return
4
;
}
b
&
=
SLOT_2_0
;
s
=
a
;
p
+
+
;
a
=
a
<
<
14
;
a
|
=
*
p
;
if
(
!
(
a
&
0x80
)
)
{
b
=
b
<
<
7
;
a
|
=
b
;
s
=
s
>
>
18
;
*
v
=
(
(
u64
)
s
)
<
<
32
|
a
;
return
5
;
}
s
=
s
<
<
7
;
s
|
=
b
;
p
+
+
;
b
=
b
<
<
14
;
b
|
=
*
p
;
if
(
!
(
b
&
0x80
)
)
{
a
&
=
SLOT_2_0
;
a
=
a
<
<
7
;
a
|
=
b
;
s
=
s
>
>
18
;
*
v
=
(
(
u64
)
s
)
<
<
32
|
a
;
return
6
;
}
p
+
+
;
a
=
a
<
<
14
;
a
|
=
*
p
;
if
(
!
(
a
&
0x80
)
)
{
a
&
=
SLOT_4_2_0
;
b
&
=
SLOT_2_0
;
b
=
b
<
<
7
;
a
|
=
b
;
s
=
s
>
>
11
;
*
v
=
(
(
u64
)
s
)
<
<
32
|
a
;
return
7
;
}
a
&
=
SLOT_2_0
;
p
+
+
;
b
=
b
<
<
14
;
b
|
=
*
p
;
if
(
!
(
b
&
0x80
)
)
{
b
&
=
SLOT_4_2_0
;
a
=
a
<
<
7
;
a
|
=
b
;
s
=
s
>
>
4
;
*
v
=
(
(
u64
)
s
)
<
<
32
|
a
;
return
8
;
}
p
+
+
;
a
=
a
<
<
15
;
a
|
=
*
p
;
b
&
=
SLOT_2_0
;
b
=
b
<
<
8
;
a
|
=
b
;
s
=
s
<
<
4
;
b
=
p
[
-
4
]
;
b
&
=
0x7f
;
b
=
b
>
>
3
;
s
|
=
b
;
*
v
=
(
(
u64
)
s
)
<
<
32
|
a
;
return
9
;
}
#
ifdef
SQLITE_NOINLINE
#
define
FTS5_NOINLINE
SQLITE_NOINLINE
#
else
#
define
FTS5_NOINLINE
#
endif
static
int
FTS5_NOINLINE
fts5PutVarint64
(
unsigned
char
*
p
u64
v
)
{
int
i
j
n
;
u8
buf
[
10
]
;
if
(
v
&
(
(
(
u64
)
0xff000000
)
<
<
32
)
)
{
p
[
8
]
=
(
u8
)
v
;
v
>
>
=
8
;
for
(
i
=
7
;
i
>
=
0
;
i
-
-
)
{
p
[
i
]
=
(
u8
)
(
(
v
&
0x7f
)
|
0x80
)
;
v
>
>
=
7
;
}
return
9
;
}
n
=
0
;
do
{
buf
[
n
+
+
]
=
(
u8
)
(
(
v
&
0x7f
)
|
0x80
)
;
v
>
>
=
7
;
}
while
(
v
!
=
0
)
;
buf
[
0
]
&
=
0x7f
;
assert
(
n
<
=
9
)
;
for
(
i
=
0
j
=
n
-
1
;
j
>
=
0
;
j
-
-
i
+
+
)
{
p
[
i
]
=
buf
[
j
]
;
}
return
n
;
}
static
int
sqlite3Fts5PutVarint
(
unsigned
char
*
p
u64
v
)
{
if
(
v
<
=
0x7f
)
{
p
[
0
]
=
v
&
0x7f
;
return
1
;
}
if
(
v
<
=
0x3fff
)
{
p
[
0
]
=
(
(
v
>
>
7
)
&
0x7f
)
|
0x80
;
p
[
1
]
=
v
&
0x7f
;
return
2
;
}
return
fts5PutVarint64
(
p
v
)
;
}
static
int
sqlite3Fts5GetVarintLen
(
u32
iVal
)
{
#
if
0
if
(
iVal
<
(
1
<
<
7
)
)
return
1
;
#
endif
assert
(
iVal
>
=
(
1
<
<
7
)
)
;
if
(
iVal
<
(
1
<
<
14
)
)
return
2
;
if
(
iVal
<
(
1
<
<
21
)
)
return
3
;
if
(
iVal
<
(
1
<
<
28
)
)
return
4
;
return
5
;
}
#
line
1
"
fts5_vocab
.
c
"
typedef
struct
Fts5VocabTable
Fts5VocabTable
;
typedef
struct
Fts5VocabCursor
Fts5VocabCursor
;
struct
Fts5VocabTable
{
sqlite3_vtab
base
;
char
*
zFts5Tbl
;
char
*
zFts5Db
;
sqlite3
*
db
;
Fts5Global
*
pGlobal
;
int
eType
;
unsigned
bBusy
;
}
;
struct
Fts5VocabCursor
{
sqlite3_vtab_cursor
base
;
sqlite3_stmt
*
pStmt
;
Fts5Table
*
pFts5
;
int
bEof
;
Fts5IndexIter
*
pIter
;
void
*
pStruct
;
int
nLeTerm
;
char
*
zLeTerm
;
int
colUsed
;
int
iCol
;
i64
*
aCnt
;
i64
*
aDoc
;
i64
rowid
;
Fts5Buffer
term
;
i64
iInstPos
;
int
iInstOff
;
}
;
#
define
FTS5_VOCAB_COL
0
#
define
FTS5_VOCAB_ROW
1
#
define
FTS5_VOCAB_INSTANCE
2
#
define
FTS5_VOCAB_COL_SCHEMA
"
term
col
doc
cnt
"
#
define
FTS5_VOCAB_ROW_SCHEMA
"
term
doc
cnt
"
#
define
FTS5_VOCAB_INST_SCHEMA
"
term
doc
col
offset
"
#
define
FTS5_VOCAB_TERM_EQ
0x0100
#
define
FTS5_VOCAB_TERM_GE
0x0200
#
define
FTS5_VOCAB_TERM_LE
0x0400
#
define
FTS5_VOCAB_COLUSED_MASK
0xFF
static
int
fts5VocabTableType
(
const
char
*
zType
char
*
*
pzErr
int
*
peType
)
{
int
rc
=
SQLITE_OK
;
char
*
zCopy
=
sqlite3Fts5Strndup
(
&
rc
zType
-
1
)
;
if
(
rc
=
=
SQLITE_OK
)
{
sqlite3Fts5Dequote
(
zCopy
)
;
if
(
sqlite3_stricmp
(
zCopy
"
col
"
)
=
=
0
)
{
*
peType
=
FTS5_VOCAB_COL
;
}
else
if
(
sqlite3_stricmp
(
zCopy
"
row
"
)
=
=
0
)
{
*
peType
=
FTS5_VOCAB_ROW
;
}
else
if
(
sqlite3_stricmp
(
zCopy
"
instance
"
)
=
=
0
)
{
*
peType
=
FTS5_VOCAB_INSTANCE
;
}
else
{
*
pzErr
=
sqlite3_mprintf
(
"
fts5vocab
:
unknown
table
type
:
%
Q
"
zCopy
)
;
rc
=
SQLITE_ERROR
;
}
sqlite3_free
(
zCopy
)
;
}
return
rc
;
}
static
int
fts5VocabDisconnectMethod
(
sqlite3_vtab
*
pVtab
)
{
Fts5VocabTable
*
pTab
=
(
Fts5VocabTable
*
)
pVtab
;
sqlite3_free
(
pTab
)
;
return
SQLITE_OK
;
}
static
int
fts5VocabDestroyMethod
(
sqlite3_vtab
*
pVtab
)
{
Fts5VocabTable
*
pTab
=
(
Fts5VocabTable
*
)
pVtab
;
sqlite3_free
(
pTab
)
;
return
SQLITE_OK
;
}
static
int
fts5VocabInitVtab
(
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVTab
char
*
*
pzErr
)
{
const
char
*
azSchema
[
]
=
{
"
CREATE
TABlE
vocab
(
"
FTS5_VOCAB_COL_SCHEMA
"
)
"
"
CREATE
TABlE
vocab
(
"
FTS5_VOCAB_ROW_SCHEMA
"
)
"
"
CREATE
TABlE
vocab
(
"
FTS5_VOCAB_INST_SCHEMA
"
)
"
}
;
Fts5VocabTable
*
pRet
=
0
;
int
rc
=
SQLITE_OK
;
int
bDb
;
bDb
=
(
argc
=
=
6
&
&
strlen
(
argv
[
1
]
)
=
=
4
&
&
memcmp
(
"
temp
"
argv
[
1
]
4
)
=
=
0
)
;
if
(
argc
!
=
5
&
&
bDb
=
=
0
)
{
*
pzErr
=
sqlite3_mprintf
(
"
wrong
number
of
vtable
arguments
"
)
;
rc
=
SQLITE_ERROR
;
}
else
{
int
nByte
;
const
char
*
zDb
=
bDb
?
argv
[
3
]
:
argv
[
1
]
;
const
char
*
zTab
=
bDb
?
argv
[
4
]
:
argv
[
3
]
;
const
char
*
zType
=
bDb
?
argv
[
5
]
:
argv
[
4
]
;
int
nDb
=
(
int
)
strlen
(
zDb
)
+
1
;
int
nTab
=
(
int
)
strlen
(
zTab
)
+
1
;
int
eType
=
0
;
rc
=
fts5VocabTableType
(
zType
pzErr
&
eType
)
;
if
(
rc
=
=
SQLITE_OK
)
{
assert
(
eType
>
=
0
&
&
eType
<
ArraySize
(
azSchema
)
)
;
rc
=
sqlite3_declare_vtab
(
db
azSchema
[
eType
]
)
;
}
nByte
=
sizeof
(
Fts5VocabTable
)
+
nDb
+
nTab
;
pRet
=
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
if
(
pRet
)
{
pRet
-
>
pGlobal
=
(
Fts5Global
*
)
pAux
;
pRet
-
>
eType
=
eType
;
pRet
-
>
db
=
db
;
pRet
-
>
zFts5Tbl
=
(
char
*
)
&
pRet
[
1
]
;
pRet
-
>
zFts5Db
=
&
pRet
-
>
zFts5Tbl
[
nTab
]
;
memcpy
(
pRet
-
>
zFts5Tbl
zTab
nTab
)
;
memcpy
(
pRet
-
>
zFts5Db
zDb
nDb
)
;
sqlite3Fts5Dequote
(
pRet
-
>
zFts5Tbl
)
;
sqlite3Fts5Dequote
(
pRet
-
>
zFts5Db
)
;
}
}
*
ppVTab
=
(
sqlite3_vtab
*
)
pRet
;
return
rc
;
}
static
int
fts5VocabConnectMethod
(
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVtab
char
*
*
pzErr
)
{
return
fts5VocabInitVtab
(
db
pAux
argc
argv
ppVtab
pzErr
)
;
}
static
int
fts5VocabCreateMethod
(
sqlite3
*
db
void
*
pAux
int
argc
const
char
*
const
*
argv
sqlite3_vtab
*
*
ppVtab
char
*
*
pzErr
)
{
return
fts5VocabInitVtab
(
db
pAux
argc
argv
ppVtab
pzErr
)
;
}
static
int
fts5VocabBestIndexMethod
(
sqlite3_vtab
*
pUnused
sqlite3_index_info
*
pInfo
)
{
int
i
;
int
iTermEq
=
-
1
;
int
iTermGe
=
-
1
;
int
iTermLe
=
-
1
;
int
idxNum
=
(
int
)
pInfo
-
>
colUsed
;
int
nArg
=
0
;
UNUSED_PARAM
(
pUnused
)
;
assert
(
(
pInfo
-
>
colUsed
&
FTS5_VOCAB_COLUSED_MASK
)
=
=
pInfo
-
>
colUsed
)
;
for
(
i
=
0
;
i
<
pInfo
-
>
nConstraint
;
i
+
+
)
{
struct
sqlite3_index_constraint
*
p
=
&
pInfo
-
>
aConstraint
[
i
]
;
if
(
p
-
>
usable
=
=
0
)
continue
;
if
(
p
-
>
iColumn
=
=
0
)
{
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_EQ
)
iTermEq
=
i
;
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_LE
)
iTermLe
=
i
;
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_LT
)
iTermLe
=
i
;
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_GE
)
iTermGe
=
i
;
if
(
p
-
>
op
=
=
SQLITE_INDEX_CONSTRAINT_GT
)
iTermGe
=
i
;
}
}
if
(
iTermEq
>
=
0
)
{
idxNum
|
=
FTS5_VOCAB_TERM_EQ
;
pInfo
-
>
aConstraintUsage
[
iTermEq
]
.
argvIndex
=
+
+
nArg
;
pInfo
-
>
estimatedCost
=
100
;
}
else
{
pInfo
-
>
estimatedCost
=
1000000
;
if
(
iTermGe
>
=
0
)
{
idxNum
|
=
FTS5_VOCAB_TERM_GE
;
pInfo
-
>
aConstraintUsage
[
iTermGe
]
.
argvIndex
=
+
+
nArg
;
pInfo
-
>
estimatedCost
=
pInfo
-
>
estimatedCost
/
2
;
}
if
(
iTermLe
>
=
0
)
{
idxNum
|
=
FTS5_VOCAB_TERM_LE
;
pInfo
-
>
aConstraintUsage
[
iTermLe
]
.
argvIndex
=
+
+
nArg
;
pInfo
-
>
estimatedCost
=
pInfo
-
>
estimatedCost
/
2
;
}
}
if
(
pInfo
-
>
nOrderBy
=
=
1
&
&
pInfo
-
>
aOrderBy
[
0
]
.
iColumn
=
=
0
&
&
pInfo
-
>
aOrderBy
[
0
]
.
desc
=
=
0
)
{
pInfo
-
>
orderByConsumed
=
1
;
}
pInfo
-
>
idxNum
=
idxNum
;
return
SQLITE_OK
;
}
static
int
fts5VocabOpenMethod
(
sqlite3_vtab
*
pVTab
sqlite3_vtab_cursor
*
*
ppCsr
)
{
Fts5VocabTable
*
pTab
=
(
Fts5VocabTable
*
)
pVTab
;
Fts5Table
*
pFts5
=
0
;
Fts5VocabCursor
*
pCsr
=
0
;
int
rc
=
SQLITE_OK
;
sqlite3_stmt
*
pStmt
=
0
;
char
*
zSql
=
0
;
if
(
pTab
-
>
bBusy
)
{
pVTab
-
>
zErrMsg
=
sqlite3_mprintf
(
"
recursive
definition
for
%
s
.
%
s
"
pTab
-
>
zFts5Db
pTab
-
>
zFts5Tbl
)
;
return
SQLITE_ERROR
;
}
zSql
=
sqlite3Fts5Mprintf
(
&
rc
"
SELECT
t
.
%
Q
FROM
%
Q
.
%
Q
AS
t
WHERE
t
.
%
Q
MATCH
'
*
id
'
"
pTab
-
>
zFts5Tbl
pTab
-
>
zFts5Db
pTab
-
>
zFts5Tbl
pTab
-
>
zFts5Tbl
)
;
if
(
zSql
)
{
rc
=
sqlite3_prepare_v2
(
pTab
-
>
db
zSql
-
1
&
pStmt
0
)
;
}
sqlite3_free
(
zSql
)
;
assert
(
rc
=
=
SQLITE_OK
|
|
pStmt
=
=
0
)
;
if
(
rc
=
=
SQLITE_ERROR
)
rc
=
SQLITE_OK
;
pTab
-
>
bBusy
=
1
;
if
(
pStmt
&
&
sqlite3_step
(
pStmt
)
=
=
SQLITE_ROW
)
{
i64
iId
=
sqlite3_column_int64
(
pStmt
0
)
;
pFts5
=
sqlite3Fts5TableFromCsrid
(
pTab
-
>
pGlobal
iId
)
;
}
pTab
-
>
bBusy
=
0
;
if
(
rc
=
=
SQLITE_OK
)
{
if
(
pFts5
=
=
0
)
{
rc
=
sqlite3_finalize
(
pStmt
)
;
pStmt
=
0
;
if
(
rc
=
=
SQLITE_OK
)
{
pVTab
-
>
zErrMsg
=
sqlite3_mprintf
(
"
no
such
fts5
table
:
%
s
.
%
s
"
pTab
-
>
zFts5Db
pTab
-
>
zFts5Tbl
)
;
rc
=
SQLITE_ERROR
;
}
}
else
{
rc
=
sqlite3Fts5FlushToDisk
(
pFts5
)
;
}
}
if
(
rc
=
=
SQLITE_OK
)
{
i64
nByte
=
pFts5
-
>
pConfig
-
>
nCol
*
sizeof
(
i64
)
*
2
+
sizeof
(
Fts5VocabCursor
)
;
pCsr
=
(
Fts5VocabCursor
*
)
sqlite3Fts5MallocZero
(
&
rc
nByte
)
;
}
if
(
pCsr
)
{
pCsr
-
>
pFts5
=
pFts5
;
pCsr
-
>
pStmt
=
pStmt
;
pCsr
-
>
aCnt
=
(
i64
*
)
&
pCsr
[
1
]
;
pCsr
-
>
aDoc
=
&
pCsr
-
>
aCnt
[
pFts5
-
>
pConfig
-
>
nCol
]
;
}
else
{
sqlite3_finalize
(
pStmt
)
;
}
*
ppCsr
=
(
sqlite3_vtab_cursor
*
)
pCsr
;
return
rc
;
}
static
void
fts5VocabResetCursor
(
Fts5VocabCursor
*
pCsr
)
{
pCsr
-
>
rowid
=
0
;
sqlite3Fts5IterClose
(
pCsr
-
>
pIter
)
;
sqlite3Fts5StructureRelease
(
pCsr
-
>
pStruct
)
;
pCsr
-
>
pStruct
=
0
;
pCsr
-
>
pIter
=
0
;
sqlite3_free
(
pCsr
-
>
zLeTerm
)
;
pCsr
-
>
nLeTerm
=
-
1
;
pCsr
-
>
zLeTerm
=
0
;
pCsr
-
>
bEof
=
0
;
}
static
int
fts5VocabCloseMethod
(
sqlite3_vtab_cursor
*
pCursor
)
{
Fts5VocabCursor
*
pCsr
=
(
Fts5VocabCursor
*
)
pCursor
;
fts5VocabResetCursor
(
pCsr
)
;
sqlite3Fts5BufferFree
(
&
pCsr
-
>
term
)
;
sqlite3_finalize
(
pCsr
-
>
pStmt
)
;
sqlite3_free
(
pCsr
)
;
return
SQLITE_OK
;
}
static
int
fts5VocabInstanceNewTerm
(
Fts5VocabCursor
*
pCsr
)
{
int
rc
=
SQLITE_OK
;
if
(
sqlite3Fts5IterEof
(
pCsr
-
>
pIter
)
)
{
pCsr
-
>
bEof
=
1
;
}
else
{
const
char
*
zTerm
;
int
nTerm
;
zTerm
=
sqlite3Fts5IterTerm
(
pCsr
-
>
pIter
&
nTerm
)
;
if
(
pCsr
-
>
nLeTerm
>
=
0
)
{
int
nCmp
=
MIN
(
nTerm
pCsr
-
>
nLeTerm
)
;
int
bCmp
=
memcmp
(
pCsr
-
>
zLeTerm
zTerm
nCmp
)
;
if
(
bCmp
<
0
|
|
(
bCmp
=
=
0
&
&
pCsr
-
>
nLeTerm
<
nTerm
)
)
{
pCsr
-
>
bEof
=
1
;
}
}
sqlite3Fts5BufferSet
(
&
rc
&
pCsr
-
>
term
nTerm
(
const
u8
*
)
zTerm
)
;
}
return
rc
;
}
static
int
fts5VocabInstanceNext
(
Fts5VocabCursor
*
pCsr
)
{
int
eDetail
=
pCsr
-
>
pFts5
-
>
pConfig
-
>
eDetail
;
int
rc
=
SQLITE_OK
;
Fts5IndexIter
*
pIter
=
pCsr
-
>
pIter
;
i64
*
pp
=
&
pCsr
-
>
iInstPos
;
int
*
po
=
&
pCsr
-
>
iInstOff
;
assert
(
sqlite3Fts5IterEof
(
pIter
)
=
=
0
)
;
assert
(
pCsr
-
>
bEof
=
=
0
)
;
while
(
eDetail
=
=
FTS5_DETAIL_NONE
|
|
sqlite3Fts5PoslistNext64
(
pIter
-
>
pData
pIter
-
>
nData
po
pp
)
)
{
pCsr
-
>
iInstPos
=
0
;
pCsr
-
>
iInstOff
=
0
;
rc
=
sqlite3Fts5IterNextScan
(
pCsr
-
>
pIter
)
;
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
fts5VocabInstanceNewTerm
(
pCsr
)
;
if
(
pCsr
-
>
bEof
|
|
eDetail
=
=
FTS5_DETAIL_NONE
)
break
;
}
if
(
rc
)
{
pCsr
-
>
bEof
=
1
;
break
;
}
}
return
rc
;
}
static
int
fts5VocabNextMethod
(
sqlite3_vtab_cursor
*
pCursor
)
{
Fts5VocabCursor
*
pCsr
=
(
Fts5VocabCursor
*
)
pCursor
;
Fts5VocabTable
*
pTab
=
(
Fts5VocabTable
*
)
pCursor
-
>
pVtab
;
int
nCol
=
pCsr
-
>
pFts5
-
>
pConfig
-
>
nCol
;
int
rc
;
rc
=
sqlite3Fts5StructureTest
(
pCsr
-
>
pFts5
-
>
pIndex
pCsr
-
>
pStruct
)
;
if
(
rc
!
=
SQLITE_OK
)
return
rc
;
pCsr
-
>
rowid
+
+
;
if
(
pTab
-
>
eType
=
=
FTS5_VOCAB_INSTANCE
)
{
return
fts5VocabInstanceNext
(
pCsr
)
;
}
if
(
pTab
-
>
eType
=
=
FTS5_VOCAB_COL
)
{
for
(
pCsr
-
>
iCol
+
+
;
pCsr
-
>
iCol
<
nCol
;
pCsr
-
>
iCol
+
+
)
{
if
(
pCsr
-
>
aDoc
[
pCsr
-
>
iCol
]
)
break
;
}
}
if
(
pTab
-
>
eType
!
=
FTS5_VOCAB_COL
|
|
pCsr
-
>
iCol
>
=
nCol
)
{
if
(
sqlite3Fts5IterEof
(
pCsr
-
>
pIter
)
)
{
pCsr
-
>
bEof
=
1
;
}
else
{
const
char
*
zTerm
;
int
nTerm
;
zTerm
=
sqlite3Fts5IterTerm
(
pCsr
-
>
pIter
&
nTerm
)
;
assert
(
nTerm
>
=
0
)
;
if
(
pCsr
-
>
nLeTerm
>
=
0
)
{
int
nCmp
=
MIN
(
nTerm
pCsr
-
>
nLeTerm
)
;
int
bCmp
=
memcmp
(
pCsr
-
>
zLeTerm
zTerm
nCmp
)
;
if
(
bCmp
<
0
|
|
(
bCmp
=
=
0
&
&
pCsr
-
>
nLeTerm
<
nTerm
)
)
{
pCsr
-
>
bEof
=
1
;
return
SQLITE_OK
;
}
}
sqlite3Fts5BufferSet
(
&
rc
&
pCsr
-
>
term
nTerm
(
const
u8
*
)
zTerm
)
;
memset
(
pCsr
-
>
aCnt
0
nCol
*
sizeof
(
i64
)
)
;
memset
(
pCsr
-
>
aDoc
0
nCol
*
sizeof
(
i64
)
)
;
pCsr
-
>
iCol
=
0
;
assert
(
pTab
-
>
eType
=
=
FTS5_VOCAB_COL
|
|
pTab
-
>
eType
=
=
FTS5_VOCAB_ROW
)
;
while
(
rc
=
=
SQLITE_OK
)
{
int
eDetail
=
pCsr
-
>
pFts5
-
>
pConfig
-
>
eDetail
;
const
u8
*
pPos
;
int
nPos
;
i64
iPos
=
0
;
int
iOff
=
0
;
pPos
=
pCsr
-
>
pIter
-
>
pData
;
nPos
=
pCsr
-
>
pIter
-
>
nData
;
switch
(
pTab
-
>
eType
)
{
case
FTS5_VOCAB_ROW
:
if
(
eDetail
=
=
FTS5_DETAIL_FULL
&
&
(
pCsr
-
>
colUsed
&
0x04
)
)
{
while
(
iPos
<
nPos
)
{
u32
ii
;
fts5FastGetVarint32
(
pPos
iPos
ii
)
;
if
(
ii
=
=
1
)
{
fts5FastGetVarint32
(
pPos
iPos
ii
)
;
}
else
{
pCsr
-
>
aCnt
[
0
]
+
+
;
}
}
}
pCsr
-
>
aDoc
[
0
]
+
+
;
break
;
case
FTS5_VOCAB_COL
:
if
(
eDetail
=
=
FTS5_DETAIL_FULL
)
{
int
iCol
=
-
1
;
while
(
0
=
=
sqlite3Fts5PoslistNext64
(
pPos
nPos
&
iOff
&
iPos
)
)
{
int
ii
=
FTS5_POS2COLUMN
(
iPos
)
;
if
(
iCol
!
=
ii
)
{
if
(
ii
>
=
nCol
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
pCsr
-
>
aDoc
[
ii
]
+
+
;
iCol
=
ii
;
}
pCsr
-
>
aCnt
[
ii
]
+
+
;
}
}
else
if
(
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
{
while
(
0
=
=
sqlite3Fts5PoslistNext64
(
pPos
nPos
&
iOff
&
iPos
)
)
{
assert_nc
(
iPos
>
=
0
&
&
iPos
<
nCol
)
;
if
(
iPos
>
=
nCol
)
{
rc
=
FTS5_CORRUPT
;
break
;
}
pCsr
-
>
aDoc
[
iPos
]
+
+
;
}
}
else
{
assert
(
eDetail
=
=
FTS5_DETAIL_NONE
)
;
pCsr
-
>
aDoc
[
0
]
+
+
;
}
break
;
default
:
assert
(
pTab
-
>
eType
=
=
FTS5_VOCAB_INSTANCE
)
;
break
;
}
if
(
rc
=
=
SQLITE_OK
)
{
rc
=
sqlite3Fts5IterNextScan
(
pCsr
-
>
pIter
)
;
}
if
(
pTab
-
>
eType
=
=
FTS5_VOCAB_INSTANCE
)
break
;
if
(
rc
=
=
SQLITE_OK
)
{
zTerm
=
sqlite3Fts5IterTerm
(
pCsr
-
>
pIter
&
nTerm
)
;
if
(
nTerm
!
=
pCsr
-
>
term
.
n
|
|
(
nTerm
>
0
&
&
memcmp
(
zTerm
pCsr
-
>
term
.
p
nTerm
)
)
)
{
break
;
}
if
(
sqlite3Fts5IterEof
(
pCsr
-
>
pIter
)
)
break
;
}
}
}
}
if
(
rc
=
=
SQLITE_OK
&
&
pCsr
-
>
bEof
=
=
0
&
&
pTab
-
>
eType
=
=
FTS5_VOCAB_COL
)
{
for
(
;
pCsr
-
>
iCol
<
nCol
&
&
pCsr
-
>
aDoc
[
pCsr
-
>
iCol
]
=
=
0
;
pCsr
-
>
iCol
+
+
)
;
if
(
pCsr
-
>
iCol
=
=
nCol
)
{
rc
=
FTS5_CORRUPT
;
}
}
return
rc
;
}
static
int
fts5VocabFilterMethod
(
sqlite3_vtab_cursor
*
pCursor
int
idxNum
const
char
*
zUnused
int
nUnused
sqlite3_value
*
*
apVal
)
{
Fts5VocabTable
*
pTab
=
(
Fts5VocabTable
*
)
pCursor
-
>
pVtab
;
Fts5VocabCursor
*
pCsr
=
(
Fts5VocabCursor
*
)
pCursor
;
int
eType
=
pTab
-
>
eType
;
int
rc
=
SQLITE_OK
;
int
iVal
=
0
;
int
f
=
FTS5INDEX_QUERY_SCAN
;
const
char
*
zTerm
=
0
;
int
nTerm
=
0
;
sqlite3_value
*
pEq
=
0
;
sqlite3_value
*
pGe
=
0
;
sqlite3_value
*
pLe
=
0
;
UNUSED_PARAM2
(
zUnused
nUnused
)
;
fts5VocabResetCursor
(
pCsr
)
;
if
(
idxNum
&
FTS5_VOCAB_TERM_EQ
)
pEq
=
apVal
[
iVal
+
+
]
;
if
(
idxNum
&
FTS5_VOCAB_TERM_GE
)
pGe
=
apVal
[
iVal
+
+
]
;
if
(
idxNum
&
FTS5_VOCAB_TERM_LE
)
pLe
=
apVal
[
iVal
+
+
]
;
pCsr
-
>
colUsed
=
(
idxNum
&
FTS5_VOCAB_COLUSED_MASK
)
;
if
(
pEq
)
{
zTerm
=
(
const
char
*
)
sqlite3_value_text
(
pEq
)
;
nTerm
=
sqlite3_value_bytes
(
pEq
)
;
f
=
FTS5INDEX_QUERY_NOTOKENDATA
;
}
else
{
if
(
pGe
)
{
zTerm
=
(
const
char
*
)
sqlite3_value_text
(
pGe
)
;
nTerm
=
sqlite3_value_bytes
(
pGe
)
;
}
if
(
pLe
)
{
const
char
*
zCopy
=
(
const
char
*
)
sqlite3_value_text
(
pLe
)
;
if
(
zCopy
=
=
0
)
zCopy
=
"
"
;
pCsr
-
>
nLeTerm
=
sqlite3_value_bytes
(
pLe
)
;
pCsr
-
>
zLeTerm
=
sqlite3_malloc
(
pCsr
-
>
nLeTerm
+
1
)
;
if
(
pCsr
-
>
zLeTerm
=
=
0
)
{
rc
=
SQLITE_NOMEM
;
}
else
{
memcpy
(
pCsr
-
>
zLeTerm
zCopy
pCsr
-
>
nLeTerm
+
1
)
;
}
}
}
if
(
rc
=
=
SQLITE_OK
)
{
Fts5Index
*
pIndex
=
pCsr
-
>
pFts5
-
>
pIndex
;
rc
=
sqlite3Fts5IndexQuery
(
pIndex
zTerm
nTerm
f
0
&
pCsr
-
>
pIter
)
;
if
(
rc
=
=
SQLITE_OK
)
{
pCsr
-
>
pStruct
=
sqlite3Fts5StructureRef
(
pIndex
)
;
}
}
if
(
rc
=
=
SQLITE_OK
&
&
eType
=
=
FTS5_VOCAB_INSTANCE
)
{
rc
=
fts5VocabInstanceNewTerm
(
pCsr
)
;
}
if
(
rc
=
=
SQLITE_OK
&
&
!
pCsr
-
>
bEof
&
&
(
eType
!
=
FTS5_VOCAB_INSTANCE
|
|
pCsr
-
>
pFts5
-
>
pConfig
-
>
eDetail
!
=
FTS5_DETAIL_NONE
)
)
{
rc
=
fts5VocabNextMethod
(
pCursor
)
;
}
return
rc
;
}
static
int
fts5VocabEofMethod
(
sqlite3_vtab_cursor
*
pCursor
)
{
Fts5VocabCursor
*
pCsr
=
(
Fts5VocabCursor
*
)
pCursor
;
return
pCsr
-
>
bEof
;
}
static
int
fts5VocabColumnMethod
(
sqlite3_vtab_cursor
*
pCursor
sqlite3_context
*
pCtx
int
iCol
)
{
Fts5VocabCursor
*
pCsr
=
(
Fts5VocabCursor
*
)
pCursor
;
int
eDetail
=
pCsr
-
>
pFts5
-
>
pConfig
-
>
eDetail
;
int
eType
=
(
(
Fts5VocabTable
*
)
(
pCursor
-
>
pVtab
)
)
-
>
eType
;
i64
iVal
=
0
;
if
(
iCol
=
=
0
)
{
sqlite3_result_text
(
pCtx
(
const
char
*
)
pCsr
-
>
term
.
p
pCsr
-
>
term
.
n
SQLITE_TRANSIENT
)
;
}
else
if
(
eType
=
=
FTS5_VOCAB_COL
)
{
assert
(
iCol
=
=
1
|
|
iCol
=
=
2
|
|
iCol
=
=
3
)
;
if
(
iCol
=
=
1
)
{
if
(
eDetail
!
=
FTS5_DETAIL_NONE
)
{
const
char
*
z
=
pCsr
-
>
pFts5
-
>
pConfig
-
>
azCol
[
pCsr
-
>
iCol
]
;
sqlite3_result_text
(
pCtx
z
-
1
SQLITE_STATIC
)
;
}
}
else
if
(
iCol
=
=
2
)
{
iVal
=
pCsr
-
>
aDoc
[
pCsr
-
>
iCol
]
;
}
else
{
iVal
=
pCsr
-
>
aCnt
[
pCsr
-
>
iCol
]
;
}
}
else
if
(
eType
=
=
FTS5_VOCAB_ROW
)
{
assert
(
iCol
=
=
1
|
|
iCol
=
=
2
)
;
if
(
iCol
=
=
1
)
{
iVal
=
pCsr
-
>
aDoc
[
0
]
;
}
else
{
iVal
=
pCsr
-
>
aCnt
[
0
]
;
}
}
else
{
assert
(
eType
=
=
FTS5_VOCAB_INSTANCE
)
;
switch
(
iCol
)
{
case
1
:
sqlite3_result_int64
(
pCtx
pCsr
-
>
pIter
-
>
iRowid
)
;
break
;
case
2
:
{
int
ii
=
-
1
;
if
(
eDetail
=
=
FTS5_DETAIL_FULL
)
{
ii
=
FTS5_POS2COLUMN
(
pCsr
-
>
iInstPos
)
;
}
else
if
(
eDetail
=
=
FTS5_DETAIL_COLUMNS
)
{
ii
=
(
int
)
pCsr
-
>
iInstPos
;
}
if
(
ii
>
=
0
&
&
ii
<
pCsr
-
>
pFts5
-
>
pConfig
-
>
nCol
)
{
const
char
*
z
=
pCsr
-
>
pFts5
-
>
pConfig
-
>
azCol
[
ii
]
;
sqlite3_result_text
(
pCtx
z
-
1
SQLITE_STATIC
)
;
}
break
;
}
default
:
{
assert
(
iCol
=
=
3
)
;
if
(
eDetail
=
=
FTS5_DETAIL_FULL
)
{
int
ii
=
FTS5_POS2OFFSET
(
pCsr
-
>
iInstPos
)
;
sqlite3_result_int
(
pCtx
ii
)
;
}
break
;
}
}
}
if
(
iVal
>
0
)
sqlite3_result_int64
(
pCtx
iVal
)
;
return
SQLITE_OK
;
}
static
int
fts5VocabRowidMethod
(
sqlite3_vtab_cursor
*
pCursor
sqlite_int64
*
pRowid
)
{
Fts5VocabCursor
*
pCsr
=
(
Fts5VocabCursor
*
)
pCursor
;
*
pRowid
=
pCsr
-
>
rowid
;
return
SQLITE_OK
;
}
static
int
sqlite3Fts5VocabInit
(
Fts5Global
*
pGlobal
sqlite3
*
db
)
{
static
const
sqlite3_module
fts5Vocab
=
{
2
fts5VocabCreateMethod
fts5VocabConnectMethod
fts5VocabBestIndexMethod
fts5VocabDisconnectMethod
fts5VocabDestroyMethod
fts5VocabOpenMethod
fts5VocabCloseMethod
fts5VocabFilterMethod
fts5VocabNextMethod
fts5VocabEofMethod
fts5VocabColumnMethod
fts5VocabRowidMethod
0
0
0
0
0
0
0
0
0
0
0
0
}
;
void
*
p
=
(
void
*
)
pGlobal
;
return
sqlite3_create_module_v2
(
db
"
fts5vocab
"
&
fts5Vocab
p
0
)
;
}
#
endif
