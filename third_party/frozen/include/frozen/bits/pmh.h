#
ifndef
FROZEN_LETITGO_PMH_H
#
define
FROZEN_LETITGO_PMH_H
#
include
"
frozen
/
bits
/
algorithms
.
h
"
#
include
"
frozen
/
bits
/
basic_types
.
h
"
#
include
<
array
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
limits
>
namespace
frozen
{
namespace
bits
{
struct
bucket_size_compare
{
template
<
typename
B
>
bool
constexpr
operator
(
)
(
B
const
&
b0
B
const
&
b1
)
const
{
return
b0
.
size
(
)
>
b1
.
size
(
)
;
}
}
;
template
<
std
:
:
size_t
M
>
struct
pmh_buckets
{
static
constexpr
auto
bucket_max
=
2
*
(
1u
<
<
(
log
(
M
)
/
2
)
)
;
using
bucket_t
=
cvector
<
std
:
:
size_t
bucket_max
>
;
carray
<
bucket_t
M
>
buckets
;
std
:
:
uint64_t
seed
;
struct
bucket_ref
{
unsigned
hash
;
const
bucket_t
*
ptr
;
using
value_type
=
typename
bucket_t
:
:
value_type
;
using
const_iterator
=
typename
bucket_t
:
:
const_iterator
;
constexpr
auto
size
(
)
const
{
return
ptr
-
>
size
(
)
;
}
constexpr
const
auto
&
operator
[
]
(
std
:
:
size_t
idx
)
const
{
return
(
*
ptr
)
[
idx
]
;
}
constexpr
auto
begin
(
)
const
{
return
ptr
-
>
begin
(
)
;
}
constexpr
auto
end
(
)
const
{
return
ptr
-
>
end
(
)
;
}
}
;
template
<
std
:
:
size_t
.
.
.
Is
>
carray
<
bucket_ref
M
>
constexpr
make_bucket_refs
(
std
:
:
index_sequence
<
Is
.
.
.
>
)
const
{
return
{
{
bucket_ref
{
Is
&
buckets
[
Is
]
}
.
.
.
}
}
;
}
carray
<
bucket_ref
M
>
constexpr
get_sorted_buckets
(
)
const
{
carray
<
bucket_ref
M
>
result
{
this
-
>
make_bucket_refs
(
std
:
:
make_index_sequence
<
M
>
(
)
)
}
;
bits
:
:
quicksort
(
result
.
begin
(
)
result
.
end
(
)
-
1
bucket_size_compare
{
}
)
;
return
result
;
}
}
;
template
<
std
:
:
size_t
M
class
Item
std
:
:
size_t
N
class
Hash
class
Key
class
PRG
>
pmh_buckets
<
M
>
constexpr
make_pmh_buckets
(
const
carray
<
Item
N
>
&
items
Hash
const
&
hash
Key
const
&
key
PRG
&
prg
)
{
using
result_t
=
pmh_buckets
<
M
>
;
while
(
1
)
{
result_t
result
{
}
;
result
.
seed
=
prg
(
)
;
bool
rejected
=
false
;
for
(
std
:
:
size_t
i
=
0
;
i
<
items
.
size
(
)
;
+
+
i
)
{
auto
&
bucket
=
result
.
buckets
[
hash
(
key
(
items
[
i
]
)
static_cast
<
std
:
:
size_t
>
(
result
.
seed
)
)
%
M
]
;
if
(
bucket
.
size
(
)
>
=
result_t
:
:
bucket_max
)
{
rejected
=
true
;
break
;
}
bucket
.
push_back
(
i
)
;
}
if
(
!
rejected
)
{
return
result
;
}
}
}
template
<
class
T
std
:
:
size_t
N
>
constexpr
bool
all_different_from
(
cvector
<
T
N
>
&
data
T
&
a
)
{
for
(
std
:
:
size_t
i
=
0
;
i
<
data
.
size
(
)
;
+
+
i
)
if
(
data
[
i
]
=
=
a
)
return
false
;
return
true
;
}
struct
seed_or_index
{
using
value_type
=
std
:
:
uint64_t
;
private
:
static
constexpr
value_type
MINUS_ONE
=
std
:
:
numeric_limits
<
value_type
>
:
:
max
(
)
;
static
constexpr
value_type
HIGH_BIT
=
~
(
MINUS_ONE
>
>
1
)
;
value_type
value_
=
0
;
public
:
constexpr
value_type
value
(
)
const
{
return
value_
;
}
constexpr
bool
is_seed
(
)
const
{
return
value_
&
HIGH_BIT
;
}
constexpr
seed_or_index
(
bool
is_seed
value_type
value
)
:
value_
(
is_seed
?
(
value
|
HIGH_BIT
)
:
(
value
&
~
HIGH_BIT
)
)
{
}
constexpr
seed_or_index
(
)
=
default
;
constexpr
seed_or_index
(
const
seed_or_index
&
)
=
default
;
constexpr
seed_or_index
&
operator
=
(
const
seed_or_index
&
)
=
default
;
}
;
template
<
std
:
:
size_t
M
class
Hasher
>
struct
pmh_tables
:
private
Hasher
{
std
:
:
uint64_t
first_seed_
;
carray
<
seed_or_index
M
>
first_table_
;
carray
<
std
:
:
size_t
M
>
second_table_
;
constexpr
pmh_tables
(
std
:
:
uint64_t
first_seed
carray
<
seed_or_index
M
>
first_table
carray
<
std
:
:
size_t
M
>
second_table
Hasher
hash
)
noexcept
:
Hasher
(
hash
)
first_seed_
(
first_seed
)
first_table_
(
first_table
)
second_table_
(
second_table
)
{
}
constexpr
Hasher
const
&
hash_function
(
)
const
noexcept
{
return
static_cast
<
Hasher
const
&
>
(
*
this
)
;
}
template
<
typename
KeyType
>
constexpr
std
:
:
size_t
lookup
(
const
KeyType
&
key
)
const
{
return
lookup
(
key
hash_function
(
)
)
;
}
template
<
typename
KeyType
typename
HasherType
>
constexpr
std
:
:
size_t
lookup
(
const
KeyType
&
key
const
HasherType
&
hasher
)
const
{
auto
const
d
=
first_table_
[
hasher
(
key
static_cast
<
std
:
:
size_t
>
(
first_seed_
)
)
%
M
]
;
if
(
!
d
.
is_seed
(
)
)
{
return
static_cast
<
std
:
:
size_t
>
(
d
.
value
(
)
)
;
}
else
{
return
second_table_
[
hasher
(
key
static_cast
<
std
:
:
size_t
>
(
d
.
value
(
)
)
)
%
M
]
;
}
}
}
;
template
<
std
:
:
size_t
M
class
Item
std
:
:
size_t
N
class
Hash
class
Key
class
PRG
>
pmh_tables
<
M
Hash
>
constexpr
make_pmh_tables
(
const
carray
<
Item
N
>
&
items
Hash
const
&
hash
Key
const
&
key
PRG
prg
)
{
auto
step_one
=
make_pmh_buckets
<
M
>
(
items
hash
key
prg
)
;
auto
buckets
=
step_one
.
get_sorted_buckets
(
)
;
const
auto
UNUSED
=
items
.
size
(
)
;
carray
<
seed_or_index
M
>
G
(
{
false
UNUSED
}
)
;
carray
<
std
:
:
size_t
M
>
H
(
UNUSED
)
;
for
(
const
auto
&
bucket
:
buckets
)
{
auto
const
bsize
=
bucket
.
size
(
)
;
if
(
bsize
=
=
1
)
{
G
[
bucket
.
hash
]
=
{
false
static_cast
<
std
:
:
uint64_t
>
(
bucket
[
0
]
)
}
;
}
else
if
(
bsize
>
1
)
{
seed_or_index
d
{
true
prg
(
)
}
;
cvector
<
std
:
:
size_t
decltype
(
step_one
)
:
:
bucket_max
>
bucket_slots
;
while
(
bucket_slots
.
size
(
)
<
bsize
)
{
auto
slot
=
hash
(
key
(
items
[
bucket
[
bucket_slots
.
size
(
)
]
]
)
static_cast
<
std
:
:
size_t
>
(
d
.
value
(
)
)
)
%
M
;
if
(
H
[
slot
]
!
=
UNUSED
|
|
!
all_different_from
(
bucket_slots
slot
)
)
{
bucket_slots
.
clear
(
)
;
d
=
{
true
prg
(
)
}
;
continue
;
}
bucket_slots
.
push_back
(
slot
)
;
}
G
[
bucket
.
hash
]
=
d
;
for
(
std
:
:
size_t
i
=
0
;
i
<
bsize
;
+
+
i
)
H
[
bucket_slots
[
i
]
]
=
bucket
[
i
]
;
}
}
return
{
step_one
.
seed
G
H
hash
}
;
}
}
}
#
endif
