#
ifndef
XSIMD_API_HPP
#
define
XSIMD_API_HPP
#
include
<
complex
>
#
include
<
cstddef
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
"
.
.
/
arch
/
xsimd_isa
.
hpp
"
#
include
"
.
.
/
types
/
xsimd_batch
.
hpp
"
#
include
"
.
.
/
types
/
xsimd_traits
.
hpp
"
namespace
xsimd
{
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
abs
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
abs
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
abs
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
abs
<
A
>
(
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
add
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
+
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
+
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
acos
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
acos
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
acosh
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
acosh
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
real_batch_type_t
<
batch
<
T
A
>
>
arg
(
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
arg
<
A
>
(
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
asin
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
asin
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
asinh
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
asinh
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
atan
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
atan
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
atan2
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
atan2
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
atanh
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
atanh
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
avg
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
avg
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
avgr
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
avgr
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T_out
class
T_in
class
A
>
XSIMD_INLINE
batch_bool
<
T_out
A
>
batch_bool_cast
(
batch_bool
<
T_in
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T_out
A
>
(
)
;
detail
:
:
static_check_supported_config
<
T_in
A
>
(
)
;
static_assert
(
batch_bool
<
T_out
A
>
:
:
size
=
=
batch_bool
<
T_in
A
>
:
:
size
"
Casting
between
incompatibles
batch_bool
types
.
"
)
;
return
kernel
:
:
batch_bool_cast
<
A
>
(
x
batch_bool
<
T_out
A
>
{
}
A
{
}
)
;
}
template
<
class
T_out
class
T_in
class
A
>
XSIMD_INLINE
batch
<
T_out
A
>
batch_cast
(
batch
<
T_in
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T_out
A
>
(
)
;
detail
:
:
static_check_supported_config
<
T_in
A
>
(
)
;
return
kernel
:
:
batch_cast
<
A
>
(
x
batch
<
T_out
A
>
{
}
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitofsign
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitofsign
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
bitwise_and
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
&
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
&
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
bitwise_and
(
batch_bool
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
&
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
&
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_andnot
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_andnot
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
bitwise_andnot
(
batch_bool
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_andnot
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T_out
class
T_in
class
A
>
XSIMD_INLINE
batch
<
T_out
A
>
bitwise_cast
(
batch
<
T_in
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T_in
A
>
(
)
;
detail
:
:
static_check_supported_config
<
T_out
A
>
(
)
;
return
kernel
:
:
bitwise_cast
<
A
>
(
x
batch
<
T_out
A
>
{
}
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_lshift
(
batch
<
T
A
>
const
&
x
int
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_lshift
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_lshift
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_lshift
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_not
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_not
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
bitwise_not
(
batch_bool
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_not
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
bitwise_or
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
|
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
|
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
bitwise_or
(
batch_bool
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
|
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
|
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_rshift
(
batch
<
T
A
>
const
&
x
int
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_rshift
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_rshift
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
bitwise_rshift
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
bitwise_xor
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
^
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
^
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
bitwise_xor
(
batch_bool
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
^
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
^
y
;
}
template
<
class
T
class
A
=
default_arch
>
XSIMD_INLINE
batch
<
T
A
>
broadcast
(
T
v
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
batch
<
T
A
>
:
:
broadcast
(
v
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
simd_return_type
<
From
To
A
>
broadcast_as
(
From
v
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
using
batch_value_type
=
typename
simd_return_type
<
From
To
A
>
:
:
value_type
;
using
value_type
=
typename
std
:
:
conditional
<
std
:
:
is_same
<
From
bool
>
:
:
value
bool
batch_value_type
>
:
:
type
;
return
simd_return_type
<
From
To
A
>
(
value_type
(
v
)
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
cbrt
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
cbrt
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
ceil
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
ceil
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
clip
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
lo
batch
<
T
A
>
const
&
hi
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
clip
(
x
lo
hi
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
compress
(
batch
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
mask
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
compress
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
A
class
T
>
XSIMD_INLINE
complex_batch_type_t
<
batch
<
T
A
>
>
conj
(
batch
<
T
A
>
const
&
z
)
noexcept
{
return
kernel
:
:
conj
(
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
copysign
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
copysign
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
cos
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
cos
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
cosh
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
cosh
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
decr
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
decr
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
class
Mask
>
XSIMD_INLINE
batch
<
T
A
>
decr_if
(
batch
<
T
A
>
const
&
x
Mask
const
&
mask
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
decr_if
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
div
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
/
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
/
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
eq
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
=
=
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
=
=
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
eq
(
batch_bool
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
=
=
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
=
=
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
exp
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
exp
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
exp10
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
exp10
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
exp2
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
exp2
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
expand
(
batch
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
mask
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
expand
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
expm1
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
expm1
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
erf
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
erf
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
erfc
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
erfc
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
extract_pair
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
std
:
:
size_t
i
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
extract_pair
<
A
>
(
x
y
i
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fabs
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
abs
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fdim
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
fdim
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
floor
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
floor
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fma
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
fma
<
A
>
(
x
y
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fmax
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
max
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fmin
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
min
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fmod
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
fmod
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fms
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
fms
<
A
>
(
x
y
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fnma
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
fnma
<
A
>
(
x
y
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
fnms
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
fnms
<
A
>
(
x
y
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
frexp
(
const
batch
<
T
A
>
&
x
batch
<
as_integer_t
<
T
>
A
>
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
frexp
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
ge
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
>
=
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
gt
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
>
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
haddp
(
batch
<
T
A
>
const
*
row
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
haddp
<
A
>
(
row
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
hypot
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
hypot
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
real_batch_type_t
<
batch
<
T
A
>
>
imag
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
imag
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
incr
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
incr
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
class
Mask
>
XSIMD_INLINE
batch
<
T
A
>
incr_if
(
batch
<
T
A
>
const
&
x
Mask
const
&
mask
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
incr_if
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
B
>
XSIMD_INLINE
B
infinity
(
)
{
using
T
=
typename
B
:
:
value_type
;
using
A
=
typename
B
:
:
arch_type
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
B
(
std
:
:
numeric_limits
<
T
>
:
:
infinity
(
)
)
;
}
template
<
class
T
class
A
size_t
I
>
XSIMD_INLINE
batch
<
T
A
>
insert
(
batch
<
T
A
>
const
&
x
T
val
index
<
I
>
pos
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
insert
<
A
>
(
x
val
pos
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
is_even
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
is_even
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
is_flint
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
is_flint
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
is_odd
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
is_odd
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
typename
batch
<
T
A
>
:
:
batch_bool_type
isinf
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
isinf
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
typename
batch
<
T
A
>
:
:
batch_bool_type
isfinite
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
isfinite
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
typename
batch
<
T
A
>
:
:
batch_bool_type
isnan
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
isnan
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
ldexp
(
const
batch
<
T
A
>
&
x
const
batch
<
as_integer_t
<
T
>
A
>
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
ldexp
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
le
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
<
=
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
lgamma
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
lgamma
<
A
>
(
x
A
{
}
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
simd_return_type
<
From
To
A
>
load_as
(
From
const
*
ptr
aligned_mode
)
noexcept
{
using
batch_value_type
=
typename
simd_return_type
<
From
To
A
>
:
:
value_type
;
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
return
kernel
:
:
load_aligned
<
A
>
(
ptr
kernel
:
:
convert
<
batch_value_type
>
{
}
A
{
}
)
;
}
template
<
class
To
class
A
=
default_arch
>
XSIMD_INLINE
simd_return_type
<
bool
To
A
>
load_as
(
bool
const
*
ptr
aligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
return
simd_return_type
<
bool
To
A
>
:
:
load_aligned
(
ptr
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
simd_return_type
<
std
:
:
complex
<
From
>
To
A
>
load_as
(
std
:
:
complex
<
From
>
const
*
ptr
aligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
using
batch_value_type
=
typename
simd_return_type
<
std
:
:
complex
<
From
>
To
A
>
:
:
value_type
;
return
kernel
:
:
load_complex_aligned
<
A
>
(
ptr
kernel
:
:
convert
<
batch_value_type
>
{
}
A
{
}
)
;
}
#
ifdef
XSIMD_ENABLE_XTL_COMPLEX
template
<
class
To
class
A
=
default_arch
class
From
bool
i3ec
>
XSIMD_INLINE
simd_return_type
<
xtl
:
:
xcomplex
<
From
From
i3ec
>
To
A
>
load_as
(
xtl
:
:
xcomplex
<
From
From
i3ec
>
const
*
ptr
aligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
load_as
<
To
>
(
reinterpret_cast
<
std
:
:
complex
<
From
>
const
*
>
(
ptr
)
aligned_mode
(
)
)
;
}
#
endif
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
simd_return_type
<
From
To
A
>
load_as
(
From
const
*
ptr
unaligned_mode
)
noexcept
{
using
batch_value_type
=
typename
simd_return_type
<
From
To
A
>
:
:
value_type
;
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
kernel
:
:
load_unaligned
<
A
>
(
ptr
kernel
:
:
convert
<
batch_value_type
>
{
}
A
{
}
)
;
}
template
<
class
To
class
A
=
default_arch
>
XSIMD_INLINE
simd_return_type
<
bool
To
A
>
load_as
(
bool
const
*
ptr
unaligned_mode
)
noexcept
{
return
simd_return_type
<
bool
To
A
>
:
:
load_unaligned
(
ptr
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
simd_return_type
<
std
:
:
complex
<
From
>
To
A
>
load_as
(
std
:
:
complex
<
From
>
const
*
ptr
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
using
batch_value_type
=
typename
simd_return_type
<
std
:
:
complex
<
From
>
To
A
>
:
:
value_type
;
return
kernel
:
:
load_complex_unaligned
<
A
>
(
ptr
kernel
:
:
convert
<
batch_value_type
>
{
}
A
{
}
)
;
}
#
ifdef
XSIMD_ENABLE_XTL_COMPLEX
template
<
class
To
class
A
=
default_arch
class
From
bool
i3ec
>
XSIMD_INLINE
simd_return_type
<
xtl
:
:
xcomplex
<
From
From
i3ec
>
To
A
>
load_as
(
xtl
:
:
xcomplex
<
From
From
i3ec
>
const
*
ptr
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
To
A
>
(
)
;
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
load_as
<
To
>
(
reinterpret_cast
<
std
:
:
complex
<
From
>
const
*
>
(
ptr
)
unaligned_mode
(
)
)
;
}
#
endif
template
<
class
A
=
default_arch
class
From
>
XSIMD_INLINE
batch
<
From
A
>
load
(
From
const
*
ptr
aligned_mode
=
{
}
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
load_as
<
From
A
>
(
ptr
aligned_mode
{
}
)
;
}
template
<
class
A
=
default_arch
class
From
>
XSIMD_INLINE
batch
<
From
A
>
load
(
From
const
*
ptr
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
load_as
<
From
A
>
(
ptr
unaligned_mode
{
}
)
;
}
template
<
class
A
=
default_arch
class
From
>
XSIMD_INLINE
batch
<
From
A
>
load_aligned
(
From
const
*
ptr
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
load_as
<
From
A
>
(
ptr
aligned_mode
{
}
)
;
}
template
<
class
A
=
default_arch
class
From
>
XSIMD_INLINE
batch
<
From
A
>
load_unaligned
(
From
const
*
ptr
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
return
load_as
<
From
A
>
(
ptr
unaligned_mode
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
log
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
log
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
log2
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
log2
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
log10
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
log10
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
log1p
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
log1p
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch_bool
<
T
A
>
lt
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
<
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
max
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
max
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
min
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
min
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
B
>
XSIMD_INLINE
B
minusinfinity
(
)
noexcept
{
using
T
=
typename
B
:
:
value_type
;
using
A
=
typename
B
:
:
arch_type
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
B
(
-
std
:
:
numeric_limits
<
T
>
:
:
infinity
(
)
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
mod
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
%
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
%
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
mul
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
*
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
*
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
nearbyint
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
nearbyint
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
as_integer_t
<
T
>
A
>
nearbyint_as_int
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
nearbyint_as_int
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
neq
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
!
=
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
!
=
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
neq
(
batch_bool
<
T
A
>
const
&
x
batch_bool
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
!
=
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
!
=
y
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
neg
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
-
x
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
nextafter
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
nextafter
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
real_batch_type_t
<
batch
<
T
A
>
>
norm
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
norm
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
complex_batch_type_t
<
batch
<
T
A
>
>
polar
(
batch
<
T
A
>
const
&
r
batch
<
T
A
>
const
&
theta
=
batch
<
T
A
>
{
}
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
polar
<
A
>
(
r
theta
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
pos
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
+
x
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
pow
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
pow
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
std
:
:
complex
<
T
>
A
>
pow
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
pow
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
std
:
:
complex
<
T
>
A
>
pow
(
batch
<
T
A
>
const
&
x
batch
<
std
:
:
complex
<
T
>
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
pow
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
ITy
class
A
class
=
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
ITy
>
:
:
value
void
>
:
:
type
>
XSIMD_INLINE
batch
<
T
A
>
pow
(
batch
<
T
A
>
const
&
x
ITy
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
ipow
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
complex_batch_type_t
<
batch
<
T
A
>
>
proj
(
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
proj
(
z
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
real_batch_type_t
<
batch
<
T
A
>
>
real
(
batch
<
T
A
>
const
&
z
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
real
<
A
>
(
z
A
{
}
)
;
}
template
<
class
T
class
A
class
=
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
void
>
:
:
type
>
XSIMD_INLINE
batch
<
T
A
>
reciprocal
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
reciprocal
(
x
A
{
}
)
;
}
template
<
class
T
class
A
class
F
>
XSIMD_INLINE
T
reduce
(
F
&
&
f
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
detail
:
:
reduce
(
std
:
:
forward
<
F
>
(
f
)
x
std
:
:
integral_constant
<
unsigned
batch
<
T
A
>
:
:
size
>
(
)
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
T
reduce_add
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
reduce_add
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
T
reduce_max
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
reduce_max
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
T
reduce_min
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
reduce_min
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
remainder
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
remainder
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rint
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
nearbyint
(
x
)
;
}
template
<
size_t
N
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rotate_left
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rotate_left
<
N
A
>
(
x
A
{
}
)
;
}
template
<
size_t
N
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rotate_right
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rotate_right
<
N
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rotl
(
batch
<
T
A
>
const
&
x
int
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rotl
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rotl
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rotl
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rotr
(
batch
<
T
A
>
const
&
x
int
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rotr
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rotr
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
shift
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rotr
<
A
>
(
x
shift
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
round
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
round
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
rsqrt
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
rsqrt
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
sadd
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
sadd
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
select
(
batch_bool
<
T
A
>
const
&
cond
batch
<
T
A
>
const
&
true_br
batch
<
T
A
>
const
&
false_br
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
select
<
A
>
(
cond
true_br
false_br
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
std
:
:
complex
<
T
>
A
>
select
(
batch_bool
<
T
A
>
const
&
cond
batch
<
std
:
:
complex
<
T
>
A
>
const
&
true_br
batch
<
std
:
:
complex
<
T
>
A
>
const
&
false_br
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
select
<
A
>
(
cond
true_br
false_br
A
{
}
)
;
}
template
<
class
T
class
A
bool
.
.
.
Values
>
XSIMD_INLINE
batch
<
T
A
>
select
(
batch_bool_constant
<
T
A
Values
.
.
.
>
const
&
cond
batch
<
T
A
>
const
&
true_br
batch
<
T
A
>
const
&
false_br
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
select
<
A
>
(
cond
true_br
false_br
A
{
}
)
;
}
template
<
class
T
class
A
class
Vt
Vt
.
.
.
Values
>
XSIMD_INLINE
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
T
>
:
:
value
batch
<
T
A
>
>
:
:
type
shuffle
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch_constant
<
Vt
A
Values
.
.
.
>
mask
)
noexcept
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Vt
)
"
consistent
mask
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
shuffle
<
A
>
(
x
y
mask
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
sign
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
sign
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
signnz
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
signnz
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
sin
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
sin
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
std
:
:
pair
<
batch
<
T
A
>
batch
<
T
A
>
>
sincos
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
sincos
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
sinh
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
sinh
<
A
>
(
x
A
{
}
)
;
}
template
<
size_t
N
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
slide_left
(
batch
<
T
A
>
const
&
x
)
noexcept
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
can
only
slide
batch
of
integers
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
slide_left
<
N
A
>
(
x
A
{
}
)
;
}
template
<
size_t
N
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
slide_right
(
batch
<
T
A
>
const
&
x
)
noexcept
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
can
only
slide
batch
of
integers
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
slide_right
<
N
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
sqrt
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
sqrt
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
ssub
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
ssub
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
void
store_as
(
To
*
dst
batch
<
From
A
>
const
&
src
aligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
kernel
:
:
store_aligned
<
A
>
(
dst
src
A
{
}
)
;
}
template
<
class
A
=
default_arch
class
From
>
XSIMD_INLINE
void
store_as
(
bool
*
dst
batch_bool
<
From
A
>
const
&
src
aligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
kernel
:
:
store
<
A
>
(
src
dst
A
{
}
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
void
store_as
(
std
:
:
complex
<
To
>
*
dst
batch
<
std
:
:
complex
<
From
>
A
>
const
&
src
aligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
std
:
:
complex
<
From
>
A
>
(
)
;
kernel
:
:
store_complex_aligned
<
A
>
(
dst
src
A
{
}
)
;
}
#
ifdef
XSIMD_ENABLE_XTL_COMPLEX
template
<
class
To
class
A
=
default_arch
class
From
bool
i3ec
>
XSIMD_INLINE
void
store_as
(
xtl
:
:
xcomplex
<
To
To
i3ec
>
*
dst
batch
<
std
:
:
complex
<
From
>
A
>
const
&
src
aligned_mode
)
noexcept
{
store_as
(
reinterpret_cast
<
std
:
:
complex
<
To
>
*
>
(
dst
)
src
aligned_mode
(
)
)
;
}
#
endif
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
void
store_as
(
To
*
dst
batch
<
From
A
>
const
&
src
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
kernel
:
:
store_unaligned
<
A
>
(
dst
src
A
{
}
)
;
}
template
<
class
A
=
default_arch
class
From
>
XSIMD_INLINE
void
store_as
(
bool
*
dst
batch_bool
<
From
A
>
const
&
src
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
From
A
>
(
)
;
kernel
:
:
store
<
A
>
(
src
dst
A
{
}
)
;
}
template
<
class
To
class
A
=
default_arch
class
From
>
XSIMD_INLINE
void
store_as
(
std
:
:
complex
<
To
>
*
dst
batch
<
std
:
:
complex
<
From
>
A
>
const
&
src
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
std
:
:
complex
<
From
>
A
>
(
)
;
kernel
:
:
store_complex_unaligned
<
A
>
(
dst
src
A
{
}
)
;
}
#
ifdef
XSIMD_ENABLE_XTL_COMPLEX
template
<
class
To
class
A
=
default_arch
class
From
bool
i3ec
>
XSIMD_INLINE
void
store_as
(
xtl
:
:
xcomplex
<
To
To
i3ec
>
*
dst
batch
<
std
:
:
complex
<
From
>
A
>
const
&
src
unaligned_mode
)
noexcept
{
detail
:
:
static_check_supported_config
<
std
:
:
complex
<
From
>
A
>
(
)
;
store_as
(
reinterpret_cast
<
std
:
:
complex
<
To
>
*
>
(
dst
)
src
unaligned_mode
(
)
)
;
}
#
endif
template
<
class
A
class
T
>
XSIMD_INLINE
void
store
(
T
*
mem
batch
<
T
A
>
const
&
val
aligned_mode
=
{
}
)
noexcept
{
store_as
<
T
A
>
(
mem
val
aligned_mode
{
}
)
;
}
template
<
class
A
class
T
>
XSIMD_INLINE
void
store
(
T
*
mem
batch
<
T
A
>
const
&
val
unaligned_mode
)
noexcept
{
store_as
<
T
A
>
(
mem
val
unaligned_mode
{
}
)
;
}
template
<
class
A
class
T
>
XSIMD_INLINE
void
store_aligned
(
T
*
mem
batch
<
T
A
>
const
&
val
)
noexcept
{
store_as
<
T
A
>
(
mem
val
aligned_mode
{
}
)
;
}
template
<
class
A
class
T
>
XSIMD_INLINE
void
store_unaligned
(
T
*
mem
batch
<
T
A
>
const
&
val
)
noexcept
{
store_as
<
T
A
>
(
mem
val
unaligned_mode
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
auto
sub
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
-
>
decltype
(
x
-
y
)
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
x
-
y
;
}
template
<
class
T
class
A
class
Vt
Vt
.
.
.
Values
>
XSIMD_INLINE
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
T
>
:
:
value
batch
<
T
A
>
>
:
:
type
swizzle
(
batch
<
T
A
>
const
&
x
batch_constant
<
Vt
A
Values
.
.
.
>
mask
)
noexcept
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Vt
)
"
consistent
mask
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
swizzle
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
T
class
A
class
Vt
Vt
.
.
.
Values
>
XSIMD_INLINE
batch
<
std
:
:
complex
<
T
>
A
>
swizzle
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch_constant
<
Vt
A
Values
.
.
.
>
mask
)
noexcept
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Vt
)
"
consistent
mask
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
swizzle
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
T
class
A
class
Vt
>
XSIMD_INLINE
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
T
>
:
:
value
batch
<
T
A
>
>
:
:
type
swizzle
(
batch
<
T
A
>
const
&
x
batch
<
Vt
A
>
mask
)
noexcept
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Vt
)
"
consistent
mask
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
swizzle
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
T
class
A
class
Vt
>
XSIMD_INLINE
batch
<
std
:
:
complex
<
T
>
A
>
swizzle
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch
<
Vt
A
>
mask
)
noexcept
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Vt
)
"
consistent
mask
"
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
swizzle
<
A
>
(
x
mask
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
tan
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
tan
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
tanh
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
tanh
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
tgamma
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
tgamma
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
as_float_t
<
T
>
A
>
to_float
(
batch
<
T
A
>
const
&
i
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
batch_cast
<
as_float_t
<
T
>
>
(
i
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
as_integer_t
<
T
>
A
>
to_int
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
batch_cast
<
as_integer_t
<
T
>
>
(
x
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
trunc
(
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
trunc
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
zip_hi
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
zip_hi
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
batch
<
T
A
>
zip_lo
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
zip_lo
<
A
>
(
x
y
A
{
}
)
;
}
template
<
class
T
class
A
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
int
>
:
:
type
=
3
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_cast
(
batch_bool
<
T
A
>
const
&
self
)
noexcept
{
T
z
(
0
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
select
(
self
batch
<
T
A
>
(
T
(
~
z
)
)
batch
<
T
A
>
(
z
)
)
;
}
template
<
class
T
class
A
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
int
>
:
:
type
=
3
>
XSIMD_INLINE
batch
<
T
A
>
bitwise_cast
(
batch_bool
<
T
A
>
const
&
self
)
noexcept
{
T
z0
(
0
)
z1
(
0
)
;
using
int_type
=
as_unsigned_integer_t
<
T
>
;
int_type
value
(
~
int_type
(
0
)
)
;
std
:
:
memcpy
(
&
z1
&
value
sizeof
(
int_type
)
)
;
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
select
(
self
batch
<
T
A
>
(
z1
)
batch
<
T
A
>
(
z0
)
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
bool
all
(
batch_bool
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
all
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
bool
any
(
batch_bool
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
kernel
:
:
any
<
A
>
(
x
A
{
}
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
bool
none
(
batch_bool
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
return
!
xsimd
:
:
any
(
x
)
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
o
batch
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
constexpr
auto
size
=
batch
<
T
A
>
:
:
size
;
alignas
(
A
:
:
alignment
(
)
)
T
buffer
[
size
]
;
x
.
store_aligned
(
&
buffer
[
0
]
)
;
o
<
<
'
(
'
;
for
(
std
:
:
size_t
i
=
0
;
i
<
size
-
1
;
+
+
i
)
o
<
<
buffer
[
i
]
<
<
"
"
;
return
o
<
<
buffer
[
size
-
1
]
<
<
'
)
'
;
}
template
<
class
T
class
A
>
XSIMD_INLINE
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
o
batch_bool
<
T
A
>
const
&
x
)
noexcept
{
detail
:
:
static_check_supported_config
<
T
A
>
(
)
;
constexpr
auto
size
=
batch_bool
<
T
A
>
:
:
size
;
alignas
(
A
:
:
alignment
(
)
)
bool
buffer
[
size
]
;
x
.
store_aligned
(
&
buffer
[
0
]
)
;
o
<
<
'
(
'
;
for
(
std
:
:
size_t
i
=
0
;
i
<
size
-
1
;
+
+
i
)
o
<
<
buffer
[
i
]
<
<
"
"
;
return
o
<
<
buffer
[
size
-
1
]
<
<
'
)
'
;
}
}
#
endif
