#
ifndef
XSIMD_GENERIC_ARITHMETIC_HPP
#
define
XSIMD_GENERIC_ARITHMETIC_HPP
#
include
<
complex
>
#
include
<
type_traits
>
#
include
"
.
/
xsimd_generic_details
.
hpp
"
namespace
xsimd
{
namespace
kernel
{
using
namespace
types
;
template
<
class
A
class
T
class
>
inline
batch
<
T
A
>
bitwise_lshift
(
batch
<
T
A
>
const
&
self
batch
<
T
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
detail
:
:
apply
(
[
]
(
T
x
T
y
)
noexcept
{
return
x
<
<
y
;
}
self
other
)
;
}
template
<
class
A
class
T
class
>
inline
batch
<
T
A
>
bitwise_rshift
(
batch
<
T
A
>
const
&
self
batch
<
T
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
detail
:
:
apply
(
[
]
(
T
x
T
y
)
noexcept
{
return
x
>
>
y
;
}
self
other
)
;
}
template
<
class
A
class
T
>
inline
batch
<
T
A
>
decr
(
batch
<
T
A
>
const
&
self
requires_arch
<
generic
>
)
noexcept
{
return
self
-
T
(
1
)
;
}
template
<
class
A
class
T
class
Mask
>
inline
batch
<
T
A
>
decr_if
(
batch
<
T
A
>
const
&
self
Mask
const
&
mask
requires_arch
<
generic
>
)
noexcept
{
return
select
(
mask
decr
(
self
)
self
)
;
}
template
<
class
A
class
T
class
=
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
void
>
:
:
type
>
inline
batch
<
T
A
>
div
(
batch
<
T
A
>
const
&
self
batch
<
T
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
detail
:
:
apply
(
[
]
(
T
x
T
y
)
noexcept
-
>
T
{
return
x
/
y
;
}
self
other
)
;
}
template
<
class
A
class
T
>
inline
batch
<
T
A
>
fma
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
return
x
*
y
+
z
;
}
template
<
class
A
class
T
>
inline
batch
<
std
:
:
complex
<
T
>
A
>
fma
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch
<
std
:
:
complex
<
T
>
A
>
const
&
y
batch
<
std
:
:
complex
<
T
>
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
auto
res_r
=
fms
(
x
.
real
(
)
y
.
real
(
)
fms
(
x
.
imag
(
)
y
.
imag
(
)
z
.
real
(
)
)
)
;
auto
res_i
=
fma
(
x
.
real
(
)
y
.
imag
(
)
fma
(
x
.
imag
(
)
y
.
real
(
)
z
.
imag
(
)
)
)
;
return
{
res_r
res_i
}
;
}
template
<
class
A
class
T
>
inline
batch
<
T
A
>
fms
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
return
x
*
y
-
z
;
}
template
<
class
A
class
T
>
inline
batch
<
std
:
:
complex
<
T
>
A
>
fms
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch
<
std
:
:
complex
<
T
>
A
>
const
&
y
batch
<
std
:
:
complex
<
T
>
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
auto
res_r
=
fms
(
x
.
real
(
)
y
.
real
(
)
fma
(
x
.
imag
(
)
y
.
imag
(
)
z
.
real
(
)
)
)
;
auto
res_i
=
fma
(
x
.
real
(
)
y
.
imag
(
)
fms
(
x
.
imag
(
)
y
.
real
(
)
z
.
imag
(
)
)
)
;
return
{
res_r
res_i
}
;
}
template
<
class
A
class
T
>
inline
batch
<
T
A
>
fnma
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
return
-
x
*
y
+
z
;
}
template
<
class
A
class
T
>
inline
batch
<
std
:
:
complex
<
T
>
A
>
fnma
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch
<
std
:
:
complex
<
T
>
A
>
const
&
y
batch
<
std
:
:
complex
<
T
>
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
auto
res_r
=
-
fms
(
x
.
real
(
)
y
.
real
(
)
fma
(
x
.
imag
(
)
y
.
imag
(
)
z
.
real
(
)
)
)
;
auto
res_i
=
-
fma
(
x
.
real
(
)
y
.
imag
(
)
fms
(
x
.
imag
(
)
y
.
real
(
)
z
.
imag
(
)
)
)
;
return
{
res_r
res_i
}
;
}
template
<
class
A
class
T
>
inline
batch
<
T
A
>
fnms
(
batch
<
T
A
>
const
&
x
batch
<
T
A
>
const
&
y
batch
<
T
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
return
-
x
*
y
-
z
;
}
template
<
class
A
class
T
>
inline
batch
<
std
:
:
complex
<
T
>
A
>
fnms
(
batch
<
std
:
:
complex
<
T
>
A
>
const
&
x
batch
<
std
:
:
complex
<
T
>
A
>
const
&
y
batch
<
std
:
:
complex
<
T
>
A
>
const
&
z
requires_arch
<
generic
>
)
noexcept
{
auto
res_r
=
-
fms
(
x
.
real
(
)
y
.
real
(
)
fms
(
x
.
imag
(
)
y
.
imag
(
)
z
.
real
(
)
)
)
;
auto
res_i
=
-
fma
(
x
.
real
(
)
y
.
imag
(
)
fma
(
x
.
imag
(
)
y
.
real
(
)
z
.
imag
(
)
)
)
;
return
{
res_r
res_i
}
;
}
template
<
class
A
class
T
>
inline
batch
<
T
A
>
incr
(
batch
<
T
A
>
const
&
self
requires_arch
<
generic
>
)
noexcept
{
return
self
+
T
(
1
)
;
}
template
<
class
A
class
T
class
Mask
>
inline
batch
<
T
A
>
incr_if
(
batch
<
T
A
>
const
&
self
Mask
const
&
mask
requires_arch
<
generic
>
)
noexcept
{
return
select
(
mask
incr
(
self
)
self
)
;
}
template
<
class
A
class
T
class
>
inline
batch
<
T
A
>
mul
(
batch
<
T
A
>
const
&
self
batch
<
T
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
detail
:
:
apply
(
[
]
(
T
x
T
y
)
noexcept
-
>
T
{
return
x
*
y
;
}
self
other
)
;
}
template
<
class
A
>
inline
batch
<
float
A
>
sadd
(
batch
<
float
A
>
const
&
self
batch
<
float
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
add
(
self
other
)
;
}
template
<
class
A
>
inline
batch
<
double
A
>
sadd
(
batch
<
double
A
>
const
&
self
batch
<
double
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
add
(
self
other
)
;
}
template
<
class
A
>
inline
batch
<
float
A
>
ssub
(
batch
<
float
A
>
const
&
self
batch
<
float
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
sub
(
self
other
)
;
}
template
<
class
A
>
inline
batch
<
double
A
>
ssub
(
batch
<
double
A
>
const
&
self
batch
<
double
A
>
const
&
other
requires_arch
<
generic
>
)
noexcept
{
return
sub
(
self
other
)
;
}
}
}
#
endif
