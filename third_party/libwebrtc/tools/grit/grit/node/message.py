'
'
'
Handling
of
the
<
message
>
element
.
'
'
'
from
__future__
import
print_function
import
re
import
six
from
grit
.
node
import
base
from
grit
import
clique
from
grit
import
exception
from
grit
import
lazy_re
from
grit
import
tclib
from
grit
import
util
_ELLIPSIS_PATTERN
=
lazy_re
.
compile
(
r
'
(
?
<
!
\
.
)
\
.
\
.
\
.
(
?
=
|
\
s
)
'
)
_ELLIPSIS_SYMBOL
=
u
'
\
u2026
'
_WHITESPACE
=
lazy_re
.
compile
(
r
'
(
?
P
<
start
>
\
s
*
)
(
?
P
<
body
>
.
+
?
)
(
?
P
<
end
>
\
s
*
)
\
Z
'
                              
re
.
DOTALL
|
re
.
MULTILINE
)
_ANDROID_FORMAT
=
(
r
'
%
[
1
-
9
]
+
\
'
                   
r
'
(
[
-
#
+
0
(
]
*
)
(
[
0
-
9
]
+
)
?
(
\
.
[
0
-
9
]
+
)
?
'
                   
r
'
(
[
bBhHsScCdoxXeEfgGaAtT
%
n
]
)
'
)
_CHROME_FORMAT
=
r
'
\
+
\
d
'
_OTHER_FORMAT
=
r
'
%
[
0
-
9sd
]
'
_FORMATTERS
=
lazy_re
.
compile
(
    
'
(
%
s
)
|
(
%
s
)
|
(
%
s
)
'
%
(
_ANDROID_FORMAT
_CHROME_FORMAT
_OTHER_FORMAT
)
)
_BAD_PLACEHOLDER_MSG
=
(
'
ERROR
:
Placeholder
formatter
found
outside
of
<
ph
>
'
                        
'
tag
in
message
"
%
s
"
in
%
s
.
'
)
_INVALID_PH_CHAR_MSG
=
(
'
ERROR
:
Invalid
format
characters
found
in
message
'
                        
'
"
%
s
"
<
ph
>
tag
in
%
s
.
'
)
_HTMLTOKEN
=
lazy_re
.
compile
(
r
'
<
[
/
]
?
[
a
-
z
]
[
a
-
z0
-
9
]
*
[
^
>
]
*
>
'
re
.
I
)
_HTMLENTITY
=
lazy_re
.
compile
(
r
'
&
[
^
\
s
]
*
;
'
)
class
MessageNode
(
base
.
ContentNode
)
:
  
'
'
'
A
<
message
>
element
.
'
'
'
  
_SPLIT_RE
=
lazy_re
.
compile
(
r
'
\
s
*
\
s
*
|
\
s
+
'
)
  
def
__init__
(
self
)
:
    
super
(
MessageNode
self
)
.
__init__
(
)
    
self
.
clique
=
None
    
self
.
ws_at_start
=
'
'
    
self
.
ws_at_end
=
'
'
    
self
.
shortcut_groups_
=
[
]
    
self
.
formatter_data
=
{
}
    
self
.
_replace_ellipsis
=
False
  
def
_IsValidChild
(
self
child
)
:
    
return
isinstance
(
child
(
PhNode
)
)
  
def
_IsValidAttribute
(
self
name
value
)
:
    
if
name
not
in
[
        
'
name
'
'
offset
'
'
translateable
'
'
desc
'
'
meaning
'
        
'
internal_comment
'
'
shortcut_groups
'
'
custom_type
'
'
validation_expr
'
        
'
use_name_for_id
'
'
sub_variable
'
'
formatter_data
'
        
'
is_accessibility_with_no_ui
'
    
]
:
      
return
False
    
if
(
name
in
(
'
translateable
'
'
sub_variable
'
)
and
        
value
not
in
[
'
true
'
'
false
'
]
)
:
      
return
False
    
return
True
  
def
SetReplaceEllipsis
(
self
value
)
:
    
r
'
'
'
Sets
whether
to
replace
.
.
.
with
\
u2026
.
    
'
'
'
    
self
.
_replace_ellipsis
=
value
  
def
MandatoryAttributes
(
self
)
:
    
return
[
'
name
|
offset
'
]
  
def
DefaultAttributes
(
self
)
:
    
return
{
        
'
custom_type
'
:
'
'
        
'
desc
'
:
'
'
        
'
formatter_data
'
:
'
'
        
'
internal_comment
'
:
'
'
        
'
is_accessibility_with_no_ui
'
:
'
false
'
        
'
meaning
'
:
'
'
        
'
shortcut_groups
'
:
'
'
        
'
sub_variable
'
:
'
false
'
        
'
translateable
'
:
'
true
'
        
'
use_name_for_id
'
:
'
false
'
        
'
validation_expr
'
:
'
'
    
}
  
def
HandleAttribute
(
self
attrib
value
)
:
    
base
.
ContentNode
.
HandleAttribute
(
self
attrib
value
)
    
if
attrib
!
=
'
formatter_data
'
:
      
return
    
for
item
in
value
.
split
(
)
:
      
name
_
val
=
item
.
partition
(
'
=
'
)
      
self
.
formatter_data
[
name
]
=
val
  
def
GetTextualIds
(
self
)
:
    
'
'
'
    
Returns
the
concatenation
of
the
parent
'
s
node
first_id
and
    
this
node
'
s
offset
if
it
has
one
otherwise
just
call
the
    
superclass
'
implementation
    
'
'
'
    
if
'
offset
'
not
in
self
.
attrs
:
      
return
super
(
MessageNode
self
)
.
GetTextualIds
(
)
    
grouping_parent
=
self
.
parent
    
import
grit
.
node
.
empty
    
while
grouping_parent
and
not
isinstance
(
grouping_parent
                                             
grit
.
node
.
empty
.
GroupingNode
)
:
      
grouping_parent
=
grouping_parent
.
parent
    
assert
'
first_id
'
in
grouping_parent
.
attrs
    
return
[
grouping_parent
.
attrs
[
'
first_id
'
]
+
'
_
'
+
self
.
attrs
[
'
offset
'
]
]
  
def
IsTranslateable
(
self
)
:
    
return
self
.
attrs
[
'
translateable
'
]
=
=
'
true
'
  
def
EndParsing
(
self
)
:
    
super
(
MessageNode
self
)
.
EndParsing
(
)
    
text
=
'
'
    
placeholders
=
[
]
    
for
item
in
self
.
mixed_content
:
      
if
isinstance
(
item
six
.
string_types
)
:
        
if
_FORMATTERS
.
search
(
item
)
:
          
print
(
_BAD_PLACEHOLDER_MSG
%
(
item
self
.
source
)
)
          
raise
exception
.
PlaceholderNotInsidePhNode
        
text
+
=
item
      
else
:
        
presentation
=
item
.
attrs
[
'
name
'
]
.
upper
(
)
        
text
+
=
presentation
        
ex
=
'
'
        
if
len
(
item
.
children
)
:
          
ex
=
item
.
children
[
0
]
.
GetCdata
(
)
        
original
=
item
.
GetCdata
(
)
        
cdata
=
original
        
match
=
_HTMLTOKEN
.
search
(
cdata
)
        
while
match
:
          
cdata
=
cdata
.
replace
(
match
.
group
(
0
)
'
_
'
)
          
match
=
_HTMLTOKEN
.
search
(
cdata
)
        
match
=
_HTMLENTITY
.
search
(
cdata
)
        
while
match
:
          
cdata
=
cdata
.
replace
(
match
.
group
(
0
)
'
_
'
)
          
match
=
_HTMLENTITY
.
search
(
cdata
)
        
match
=
_FORMATTERS
.
search
(
cdata
)
        
if
match
:
          
cdata
=
cdata
.
replace
(
match
.
group
(
0
)
'
'
)
        
if
re
.
search
(
r
'
[
%
\
]
'
cdata
)
:
          
message_id
=
self
.
attrs
[
'
name
'
]
+
'
'
+
original
;
          
print
(
_INVALID_PH_CHAR_MSG
%
(
message_id
self
.
source
)
)
          
raise
exception
.
InvalidCharactersInsidePhNode
        
placeholders
.
append
(
tclib
.
Placeholder
(
presentation
original
ex
)
)
    
m
=
_WHITESPACE
.
match
(
text
)
    
if
m
:
      
self
.
ws_at_start
=
m
.
group
(
'
start
'
)
      
self
.
ws_at_end
=
m
.
group
(
'
end
'
)
      
text
=
m
.
group
(
'
body
'
)
    
self
.
shortcut_groups_
=
self
.
_SPLIT_RE
.
split
(
self
.
attrs
[
'
shortcut_groups
'
]
)
    
self
.
shortcut_groups_
=
[
i
for
i
in
self
.
shortcut_groups_
if
i
!
=
'
'
]
    
description_or_id
=
self
.
attrs
[
'
desc
'
]
    
if
description_or_id
=
=
'
'
and
'
name
'
in
self
.
attrs
:
      
description_or_id
=
'
ID
:
%
s
'
%
self
.
attrs
[
'
name
'
]
    
assigned_id
=
None
    
if
self
.
attrs
[
'
use_name_for_id
'
]
=
=
'
true
'
:
      
assigned_id
=
self
.
attrs
[
'
name
'
]
    
message
=
tclib
.
Message
(
text
=
text
placeholders
=
placeholders
                            
description
=
description_or_id
                            
meaning
=
self
.
attrs
[
'
meaning
'
]
                            
assigned_id
=
assigned_id
)
    
self
.
InstallMessage
(
message
)
  
def
InstallMessage
(
self
message
)
:
    
'
'
'
Sets
this
node
'
s
clique
from
a
tclib
.
Message
instance
.
    
Args
:
      
message
:
A
tclib
.
Message
.
    
'
'
'
    
self
.
clique
=
self
.
UberClique
(
)
.
MakeClique
(
message
self
.
IsTranslateable
(
)
)
    
for
group
in
self
.
shortcut_groups_
:
      
self
.
clique
.
AddToShortcutGroup
(
group
)
    
if
self
.
attrs
[
'
custom_type
'
]
!
=
'
'
:
      
self
.
clique
.
SetCustomType
(
util
.
NewClassInstance
(
self
.
attrs
[
'
custom_type
'
]
                                                      
clique
.
CustomType
)
)
    
elif
self
.
attrs
[
'
validation_expr
'
]
!
=
'
'
:
      
self
.
clique
.
SetCustomType
(
        
clique
.
OneOffCustomType
(
self
.
attrs
[
'
validation_expr
'
]
)
)
  
def
SubstituteMessages
(
self
substituter
)
:
    
'
'
'
Applies
substitution
to
this
message
.
    
Args
:
      
substituter
:
a
grit
.
util
.
Substituter
object
.
    
'
'
'
    
message
=
substituter
.
SubstituteMessage
(
self
.
clique
.
GetMessage
(
)
)
    
if
message
is
not
self
.
clique
.
GetMessage
(
)
:
      
self
.
InstallMessage
(
message
)
  
def
GetCliques
(
self
)
:
    
return
[
self
.
clique
]
if
self
.
clique
else
[
]
  
def
Translate
(
self
lang
)
:
    
'
'
'
Returns
a
translated
version
of
this
message
.
    
'
'
'
    
assert
self
.
clique
    
msg
=
self
.
clique
.
MessageForLanguage
(
lang
                                         
self
.
PseudoIsAllowed
(
)
                                         
self
.
ShouldFallbackToEnglish
(
)
                                         
)
.
GetRealContent
(
)
    
if
self
.
_replace_ellipsis
:
      
msg
=
_ELLIPSIS_PATTERN
.
sub
(
_ELLIPSIS_SYMBOL
msg
)
    
msg
=
msg
.
replace
(
u
'
\
uFEFF
'
'
'
)
    
return
msg
.
replace
(
'
[
GRITLANGCODE
]
'
lang
)
  
def
NameOrOffset
(
self
)
:
    
key
=
'
name
'
if
'
name
'
in
self
.
attrs
else
'
offset
'
    
return
self
.
attrs
[
key
]
  
def
ExpandVariables
(
self
)
:
    
'
'
'
We
always
expand
variables
on
Messages
.
'
'
'
    
return
True
  
def
GetDataPackValue
(
self
lang
encoding
)
:
    
'
'
'
Returns
a
str
represenation
for
a
data_pack
entry
.
'
'
'
    
message
=
self
.
ws_at_start
+
self
.
Translate
(
lang
)
+
self
.
ws_at_end
    
return
util
.
Encode
(
message
encoding
)
  
def
IsResourceMapSource
(
self
)
:
    
return
True
  
staticmethod
  
def
Construct
(
parent
message
name
desc
=
'
'
meaning
=
'
'
translateable
=
True
)
:
    
'
'
'
Constructs
a
new
message
node
that
is
a
child
of
'
parent
'
with
the
    
name
desc
meaning
and
translateable
attributes
set
using
the
same
-
named
    
parameters
and
the
text
of
the
message
and
any
placeholders
taken
from
    
'
message
'
which
must
be
a
tclib
.
Message
(
)
object
.
'
'
'
    
translateable
=
'
true
'
if
translateable
else
'
false
'
    
node
=
MessageNode
(
)
    
node
.
StartParsing
(
'
message
'
parent
)
    
node
.
HandleAttribute
(
'
name
'
name
)
    
node
.
HandleAttribute
(
'
desc
'
desc
)
    
node
.
HandleAttribute
(
'
meaning
'
meaning
)
    
node
.
HandleAttribute
(
'
translateable
'
translateable
)
    
items
=
message
.
GetContent
(
)
    
for
ix
item
in
enumerate
(
items
)
:
      
if
isinstance
(
item
six
.
string_types
)
:
        
if
ix
=
=
0
:
          
item
=
"
'
'
'
"
+
item
        
if
ix
=
=
len
(
items
)
-
1
:
          
item
=
item
+
"
'
'
'
"
        
node
.
AppendContent
(
item
)
      
else
:
        
phnode
=
PhNode
(
)
        
phnode
.
StartParsing
(
'
ph
'
node
)
        
phnode
.
HandleAttribute
(
'
name
'
item
.
GetPresentation
(
)
)
        
phnode
.
AppendContent
(
item
.
GetOriginal
(
)
)
        
if
len
(
item
.
GetExample
(
)
)
and
item
.
GetExample
(
)
!
=
'
'
:
          
exnode
=
ExNode
(
)
          
exnode
.
StartParsing
(
'
ex
'
phnode
)
          
exnode
.
AppendContent
(
item
.
GetExample
(
)
)
          
exnode
.
EndParsing
(
)
          
phnode
.
AddChild
(
exnode
)
        
phnode
.
EndParsing
(
)
        
node
.
AddChild
(
phnode
)
    
node
.
EndParsing
(
)
    
return
node
class
PhNode
(
base
.
ContentNode
)
:
  
'
'
'
A
<
ph
>
element
.
'
'
'
  
def
_IsValidChild
(
self
child
)
:
    
return
isinstance
(
child
ExNode
)
  
def
MandatoryAttributes
(
self
)
:
    
return
[
'
name
'
]
  
def
EndParsing
(
self
)
:
    
super
(
PhNode
self
)
.
EndParsing
(
)
    
if
len
(
self
.
children
)
>
1
:
      
raise
exception
.
TooManyExamples
(
)
  
def
GetTextualIds
(
self
)
:
    
return
[
]
class
ExNode
(
base
.
ContentNode
)
:
  
'
'
'
An
<
ex
>
element
.
'
'
'
  
pass
