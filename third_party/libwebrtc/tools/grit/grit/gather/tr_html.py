'
'
'
A
gatherer
for
the
TotalRecall
brand
of
HTML
templates
with
replaceable
portions
.
We
wanted
to
reuse
extern
.
tclib
.
api
.
handlers
.
html
.
TCHTMLParser
but
this
proved
impossible
due
to
the
fact
that
the
TotalRecall
HTML
templates
are
in
general
quite
far
from
parseable
HTML
and
the
TCHTMLParser
derives
from
HTMLParser
.
HTMLParser
which
requires
relatively
well
-
formed
HTML
.
Some
examples
of
"
HTML
"
from
the
TotalRecall
HTML
templates
that
wouldn
'
t
be
parseable
include
things
like
:
  
<
a
[
PARAMS
]
>
blabla
<
/
a
>
(
not
parseable
because
attributes
are
invalid
)
  
<
table
>
<
tr
>
<
td
>
[
LOTSOFSTUFF
]
<
/
tr
>
<
/
table
>
(
not
parseable
because
closing
                                            
<
/
td
>
is
in
the
HTML
[
LOTSOFSTUFF
]
                                            
is
replaced
by
)
The
other
problem
with
using
general
parsers
(
such
as
TCHTMLParser
)
is
that
we
want
to
make
sure
we
output
the
TotalRecall
template
with
as
little
changes
as
possible
in
terms
of
whitespace
characters
layout
etc
.
With
any
parser
that
generates
a
parse
tree
and
generates
output
by
dumping
the
parse
tree
we
would
always
have
little
inconsistencies
which
could
cause
bugs
(
the
TotalRecall
template
stuff
is
quite
brittle
and
can
break
if
e
.
g
.
a
tab
character
is
replaced
with
spaces
)
.
The
solution
which
may
be
applicable
to
some
other
HTML
-
like
template
languages
floating
around
Google
is
to
create
a
parser
with
a
simple
state
machine
that
keeps
track
of
what
kind
of
tag
it
'
s
inside
and
whether
it
'
s
in
a
translateable
section
or
not
.
Translateable
sections
are
:
a
)
text
(
including
[
BINGO
]
replaceables
)
inside
of
tags
that
   
can
contain
translateable
text
(
which
is
all
tags
except
   
for
a
few
)
b
)
text
inside
of
an
'
alt
'
attribute
in
an
<
image
>
element
or
   
the
'
value
'
attribute
of
a
<
submit
>
<
button
>
or
<
text
>
   
element
.
The
parser
does
not
build
up
a
parse
tree
but
rather
a
"
skeleton
"
which
is
a
list
of
nontranslateable
strings
intermingled
with
grit
.
clique
.
MessageClique
objects
.
This
simplifies
the
parser
considerably
compared
to
a
regular
HTML
parser
.
To
output
a
translated
document
each
item
in
the
skeleton
is
printed
out
with
the
relevant
Translation
from
each
MessageCliques
being
used
for
the
requested
language
.
This
implementation
borrows
some
code
constants
and
ideas
from
extern
.
tclib
.
api
.
handlers
.
html
.
TCHTMLParser
.
'
'
'
from
__future__
import
print_function
import
re
import
six
from
grit
import
clique
from
grit
import
exception
from
grit
import
lazy_re
from
grit
import
util
from
grit
import
tclib
from
grit
.
gather
import
interface
_BLOCK_TAGS
=
[
'
script
'
'
p
'
'
h1
'
'
h2
'
'
h3
'
'
h4
'
'
h5
'
'
h6
'
'
hr
'
'
br
'
              
'
body
'
'
style
'
'
head
'
'
title
'
'
table
'
'
tr
'
'
td
'
'
th
'
              
'
ul
'
'
ol
'
'
dl
'
'
nl
'
'
li
'
'
div
'
'
object
'
'
center
'
              
'
html
'
'
link
'
'
form
'
'
select
'
'
textarea
'
              
'
button
'
'
option
'
'
map
'
'
area
'
'
blockquote
'
'
pre
'
              
'
meta
'
'
xmp
'
'
noscript
'
'
label
'
'
tbody
'
'
thead
'
              
'
script
'
'
style
'
'
pre
'
'
iframe
'
'
img
'
'
input
'
'
nowrap
'
              
'
fieldset
'
'
legend
'
]
_INLINE_TAGS
=
[
'
b
'
'
i
'
'
u
'
'
tt
'
'
code
'
'
font
'
'
a
'
'
span
'
'
small
'
               
'
key
'
'
nobr
'
'
url
'
'
em
'
'
s
'
'
sup
'
'
strike
'
               
'
strong
'
]
_PREFORMATTED_TAGS
=
[
'
textarea
'
'
xmp
'
'
pre
'
]
_HTML_PLACEHOLDER_NAMES
=
{
'
a
'
:
'
link
'
'
br
'
:
'
break
'
'
b
'
:
'
bold
'
  
'
i
'
:
'
italic
'
'
li
'
:
'
item
'
'
ol
'
:
'
ordered_list
'
'
p
'
:
'
paragraph
'
  
'
ul
'
:
'
unordered_list
'
'
img
'
:
'
image
'
'
em
'
:
'
emphasis
'
}
_SUFFIXES
=
'
123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
'
_WHITESPACE
=
lazy_re
.
compile
(
r
'
(
\
s
|
&
nbsp
;
|
\
\
n
|
\
\
r
|
<
!
-
-
\
s
*
desc
\
s
*
=
.
*
?
-
-
>
)
+
'
                              
re
.
DOTALL
)
_FOLD_WHITESPACE
=
lazy_re
.
compile
(
r
'
\
s
+
'
)
_NON_WHITESPACE
=
lazy_re
.
compile
(
r
'
\
S
'
)
_NBSP
=
lazy_re
.
compile
(
r
'
&
nbsp
;
(
&
nbsp
;
)
+
'
)
_NONTRANSLATEABLES
=
lazy_re
.
compile
(
r
'
'
'
  
<
\
s
*
script
.
+
?
<
\
s
*
/
\
s
*
script
\
s
*
>
  
|
  
<
\
s
*
style
.
+
?
<
\
s
*
/
\
s
*
style
\
s
*
>
  
|
  
<
!
-
-
.
+
?
-
-
>
  
|
  
<
\
?
IMPORT
\
s
.
+
?
>
#
import
tag
  
|
  
<
\
s
*
[
a
-
zA
-
Z_
]
+
:
.
+
?
>
#
custom
tag
(
open
)
  
|
  
<
\
s
*
/
\
s
*
[
a
-
zA
-
Z_
]
+
:
.
+
?
>
#
custom
tag
(
close
)
  
|
  
<
!
\
s
*
[
A
-
Z
]
+
\
s
*
(
[
^
>
]
+
|
"
[
^
"
]
+
"
|
'
[
^
'
]
+
'
)
*
?
>
  
'
'
'
re
.
MULTILINE
|
re
.
DOTALL
|
re
.
VERBOSE
|
re
.
IGNORECASE
)
_ELEMENT
=
lazy_re
.
compile
(
r
'
'
'
  
#
Optional
closing
/
element
name
  
<
\
s
*
(
?
P
<
closing
>
/
)
?
\
s
*
(
?
P
<
element
>
[
a
-
zA
-
Z0
-
9
]
+
)
\
s
*
  
#
Attributes
and
/
or
replaceables
inside
the
tag
if
any
  
(
?
P
<
atts
>
(
    
\
s
*
(
[
a
-
zA
-
Z_
]
[
-
:
.
a
-
zA
-
Z_0
-
9
]
*
)
#
Attribute
name
    
(
\
s
*
=
\
s
*
(
\
'
[
^
\
'
]
*
\
'
|
"
[
^
"
]
*
"
|
[
-
a
-
zA
-
Z0
-
9
.
/
:
;
+
*
%
?
!
&
\
(
\
)
_
#
=
~
\
'
"
]
*
)
)
?
    
|
    
\
s
*
\
[
(
\
?
\
~
)
?
(
[
A
-
Z0
-
9
-
_
]
+
?
)
(
\
~
\
?
)
?
\
]
  
)
*
)
  
\
s
*
(
?
P
<
empty
>
/
)
?
\
s
*
>
#
Optional
empty
-
tag
closing
/
and
tag
close
  
'
'
'
  
re
.
MULTILINE
|
re
.
DOTALL
|
re
.
VERBOSE
)
_SPECIAL_ELEMENT
=
lazy_re
.
compile
(
r
'
'
'
  
<
\
s
*
(
    
input
[
^
>
]
+
?
value
\
s
*
=
\
s
*
(
\
'
(
?
P
<
value3
>
[
^
\
'
]
*
)
\
'
|
"
(
?
P
<
value4
>
[
^
"
]
*
)
"
)
    
[
^
>
]
+
type
\
s
*
=
\
s
*
"
?
'
?
(
button
|
reset
|
text
|
submit
)
'
?
"
?
    
|
    
(
      
table
[
^
>
]
+
?
title
\
s
*
=
      
|
      
img
[
^
>
]
+
?
alt
\
s
*
=
      
|
      
input
[
^
>
]
+
?
type
\
s
*
=
\
s
*
"
?
'
?
(
button
|
reset
|
text
|
submit
)
'
?
"
?
[
^
>
]
+
?
value
\
s
*
=
    
)
    
\
s
*
(
\
'
(
?
P
<
value1
>
[
^
\
'
]
*
)
\
'
|
"
(
?
P
<
value2
>
[
^
"
]
*
)
"
)
  
)
[
^
>
]
*
?
>
  
'
'
'
re
.
MULTILINE
|
re
.
DOTALL
|
re
.
VERBOSE
|
re
.
IGNORECASE
)
_CHARACTERS
=
lazy_re
.
compile
(
r
'
'
'
  
(
    
\
w
    
|
    
[
\
!
\
\
#
\
\
%
\
^
\
*
\
(
\
)
\
-
\
=
\
_
\
+
\
[
\
]
\
{
\
}
\
\
\
|
\
;
\
:
\
'
\
"
\
\
.
\
/
\
?
\
\
~
]
    
|
    
&
(
\
#
[
0
-
9
]
+
|
\
#
x
[
0
-
9a
-
fA
-
F
]
+
|
[
A
-
Za
-
z0
-
9
]
+
)
;
  
)
+
  
'
'
'
re
.
MULTILINE
|
re
.
DOTALL
|
re
.
VERBOSE
)
_REPLACEABLE
=
lazy_re
.
compile
(
r
'
\
[
(
\
?
\
~
)
?
(
?
P
<
name
>
[
A
-
Z0
-
9
-
_
]
+
?
)
(
\
~
\
?
)
?
\
]
'
                               
re
.
MULTILINE
)
_SILLY_HEADER
=
lazy_re
.
compile
(
r
'
\
[
!
\
]
\
ntitle
\
t
(
?
P
<
title
>
[
^
\
n
]
+
?
)
\
n
.
+
?
\
n
\
n
'
                                
re
.
MULTILINE
|
re
.
DOTALL
)
_DESCRIPTION_COMMENT
=
lazy_re
.
compile
(
  
r
'
<
!
-
-
\
s
*
desc
\
s
*
=
\
s
*
(
?
P
<
description
>
.
+
?
)
\
s
*
-
-
>
'
re
.
DOTALL
)
_MESSAGE_BREAK_COMMENT
=
lazy_re
.
compile
(
r
'
<
!
-
-
\
s
*
message
-
break
\
s
*
-
-
>
'
                                         
re
.
DOTALL
)
_MESSAGE_NO_BREAK_COMMENT
=
re
.
compile
(
r
'
<
!
-
-
\
s
*
message
-
no
-
break
\
s
*
-
-
>
'
                                       
re
.
DOTALL
)
_DEBUG
=
0
def
_DebugPrint
(
text
)
:
  
if
_DEBUG
:
    
print
(
text
.
encode
(
'
utf
-
8
'
)
)
class
HtmlChunks
(
object
)
:
  
'
'
'
A
parser
that
knows
how
to
break
an
HTML
-
like
document
into
a
list
of
  
chunks
where
each
chunk
is
either
translateable
or
non
-
translateable
.
  
The
chunks
are
unmodified
sections
of
the
original
document
so
concatenating
  
the
text
of
all
chunks
would
result
in
the
original
document
.
'
'
'
  
def
InTranslateable
(
self
)
:
    
return
self
.
last_translateable
!
=
-
1
  
def
Rest
(
self
)
:
    
return
self
.
text_
[
self
.
current
:
]
  
def
StartTranslateable
(
self
)
:
    
assert
not
self
.
InTranslateable
(
)
    
if
self
.
current
!
=
0
:
      
chunk_text
=
self
.
text_
[
self
.
chunk_start
:
self
.
last_nontranslateable
+
1
]
      
if
len
(
chunk_text
)
>
0
:
        
self
.
AddChunk
(
False
chunk_text
)
    
self
.
chunk_start
=
self
.
last_nontranslateable
+
1
    
self
.
last_translateable
=
self
.
current
    
self
.
last_nontranslateable
=
-
1
  
def
EndTranslateable
(
self
)
:
    
assert
self
.
InTranslateable
(
)
    
self
.
AddChunk
(
True
                  
self
.
text_
[
self
.
chunk_start
:
self
.
last_translateable
+
1
]
)
    
self
.
chunk_start
=
self
.
last_translateable
+
1
    
self
.
last_translateable
=
-
1
    
self
.
last_nontranslateable
=
self
.
current
  
def
AdvancePast
(
self
match
)
:
    
self
.
current
+
=
match
.
end
(
)
  
def
AddChunk
(
self
translateable
text
)
:
    
'
'
'
Adds
a
chunk
to
self
removing
linebreaks
and
duplicate
whitespace
    
if
appropriate
.
    
'
'
'
    
m
=
_DESCRIPTION_COMMENT
.
search
(
text
)
    
if
m
:
      
self
.
last_description
=
m
.
group
(
'
description
'
)
      
text
=
_DESCRIPTION_COMMENT
.
sub
(
'
'
text
)
    
m
=
_MESSAGE_BREAK_COMMENT
.
search
(
text
)
    
if
m
:
      
text
=
_MESSAGE_BREAK_COMMENT
.
sub
(
'
'
text
)
    
if
translateable
and
not
self
.
last_element_
in
_PREFORMATTED_TAGS
:
      
if
self
.
fold_whitespace_
:
        
text
=
_FOLD_WHITESPACE
.
sub
(
'
'
text
)
      
else
:
        
text
=
text
.
replace
(
'
\
n
'
'
'
)
        
text
=
text
.
replace
(
'
\
r
'
'
'
)
        
text
=
text
.
replace
(
'
'
'
'
)
        
text
=
text
.
replace
(
'
'
'
'
)
    
if
translateable
:
      
description
=
self
.
last_description
      
self
.
last_description
=
'
'
    
else
:
      
description
=
'
'
    
if
text
!
=
'
'
:
      
self
.
chunks_
.
append
(
(
translateable
text
description
)
)
  
def
Parse
(
self
text
fold_whitespace
)
:
    
'
'
'
Parses
self
.
text_
into
an
intermediate
format
stored
in
self
.
chunks_
    
which
is
translateable
and
nontranslateable
chunks
.
Also
returns
    
self
.
chunks_
    
Args
:
      
text
:
The
HTML
for
parsing
.
      
fold_whitespace
:
Whether
whitespace
sequences
should
be
folded
into
a
        
single
space
.
    
Return
:
      
[
chunk1
chunk2
chunk3
.
.
.
]
(
instances
of
class
Chunk
)
    
'
'
'
    
self
.
text_
=
text
    
self
.
fold_whitespace_
=
fold_whitespace
    
self
.
chunks_
=
[
]
    
self
.
chunk_start
=
0
    
self
.
last_translateable
=
-
1
    
self
.
last_nontranslateable
=
-
1
    
self
.
current
=
0
    
self
.
last_element_
=
'
'
    
self
.
last_description
=
'
'
    
self
.
last_nobreak
=
False
    
while
self
.
current
<
len
(
self
.
text_
)
:
      
_DebugPrint
(
'
REST
:
%
s
'
%
self
.
text_
[
self
.
current
:
self
.
current
+
60
]
)
      
m
=
_MESSAGE_NO_BREAK_COMMENT
.
match
(
self
.
Rest
(
)
)
      
if
m
:
        
self
.
AdvancePast
(
m
)
        
self
.
last_nobreak
=
True
        
continue
      
m
=
_WHITESPACE
.
match
(
self
.
Rest
(
)
)
      
if
m
:
        
if
(
not
self
.
InTranslateable
(
)
and
            
self
.
last_nontranslateable
=
=
self
.
current
-
1
)
:
          
self
.
last_nontranslateable
=
self
.
current
+
m
.
end
(
)
-
1
        
self
.
AdvancePast
(
m
)
        
continue
      
m
=
_NONTRANSLATEABLES
.
match
(
self
.
Rest
(
)
)
      
if
m
:
        
if
self
.
InTranslateable
(
)
:
          
self
.
EndTranslateable
(
)
        
self
.
last_nontranslateable
=
self
.
current
+
m
.
end
(
)
-
1
        
self
.
AdvancePast
(
m
)
        
continue
      
m
=
_ELEMENT
.
match
(
self
.
Rest
(
)
)
      
if
m
:
        
element_name
=
m
.
group
(
'
element
'
)
.
lower
(
)
        
if
element_name
in
_BLOCK_TAGS
:
          
self
.
last_element_
=
element_name
          
if
self
.
InTranslateable
(
)
:
            
if
self
.
last_nobreak
:
              
self
.
last_nobreak
=
False
            
else
:
              
self
.
EndTranslateable
(
)
          
sm
=
_SPECIAL_ELEMENT
.
match
(
self
.
Rest
(
)
)
          
if
sm
:
            
for
group
in
sm
.
groupdict
(
)
:
              
if
sm
.
groupdict
(
)
[
group
]
:
                
break
            
self
.
AddChunk
(
False
self
.
text_
[
              
self
.
chunk_start
:
self
.
current
+
sm
.
start
(
group
)
]
)
            
self
.
AddChunk
(
True
self
.
Rest
(
)
[
sm
.
start
(
group
)
:
sm
.
end
(
group
)
]
)
            
self
.
chunk_start
=
self
.
current
+
sm
.
end
(
group
)
          
self
.
last_nontranslateable
=
self
.
current
+
m
.
end
(
)
-
1
        
elif
self
.
InTranslateable
(
)
:
          
self
.
last_translateable
=
self
.
current
+
m
.
end
(
)
-
1
        
self
.
AdvancePast
(
m
)
        
continue
      
if
not
self
.
InTranslateable
(
)
:
        
self
.
StartTranslateable
(
)
      
else
:
        
self
.
last_translateable
=
self
.
current
      
self
.
current
+
=
1
    
if
self
.
InTranslateable
(
)
:
      
self
.
AddChunk
(
True
self
.
text_
[
self
.
chunk_start
:
]
)
    
else
:
      
self
.
AddChunk
(
False
self
.
text_
[
self
.
chunk_start
:
]
)
    
return
self
.
chunks_
def
HtmlToMessage
(
html
include_block_tags
=
False
description
=
'
'
)
:
  
'
'
'
Takes
a
bit
of
HTML
which
must
contain
only
"
inline
"
HTML
elements
  
and
changes
it
into
a
tclib
.
Message
.
This
involves
escaping
any
entities
and
  
replacing
any
HTML
code
with
placeholders
.
  
If
include_block_tags
is
true
no
error
will
be
given
if
block
tags
(
e
.
g
.
  
<
p
>
or
<
br
>
)
are
included
in
the
HTML
.
  
Args
:
    
html
:
'
Hello
<
b
>
[
USERNAME
]
<
/
b
>
how
&
nbsp
;
<
i
>
are
<
/
i
>
you
?
'
    
include_block_tags
:
False
  
Return
:
    
tclib
.
Message
(
'
Hello
START_BOLD1USERNAMEEND_BOLD
'
                  
'
howNBSPSTART_ITALICareEND_ITALIC
you
?
'
                  
[
Placeholder
(
'
START_BOLD
'
'
<
b
>
'
'
'
)
                    
Placeholder
(
'
USERNAME
'
'
[
USERNAME
]
'
'
'
)
                    
Placeholder
(
'
END_BOLD
'
'
<
/
b
>
'
'
'
)
                    
Placeholder
(
'
START_ITALIC
'
'
<
i
>
'
'
'
)
                    
Placeholder
(
'
END_ITALIC
'
'
<
/
i
>
'
'
'
)
]
)
  
'
'
'
  
parts
=
[
]
  
count_names
=
{
}
  
end_names
=
{
}
  
def
MakeNameClosure
(
base
type
=
'
'
)
:
    
'
'
'
Returns
a
closure
that
can
be
called
once
all
names
have
been
allocated
    
to
return
the
final
name
of
the
placeholder
.
This
allows
us
to
minimally
    
number
placeholders
for
non
-
overlap
.
    
Also
ensures
that
END_XXX_Y
placeholders
have
the
same
Y
as
the
    
corresponding
BEGIN_XXX_Y
placeholder
when
we
have
nested
tags
of
the
same
    
type
.
    
Args
:
      
base
:
'
phname
'
      
type
:
'
'
|
'
begin
'
|
'
end
'
    
Return
:
      
Closure
(
)
    
'
'
'
    
name
=
base
.
upper
(
)
    
if
type
!
=
'
'
:
      
name
=
(
'
%
s_
%
s
'
%
(
type
base
)
)
.
upper
(
)
    
count_names
.
setdefault
(
name
0
)
    
count_names
[
name
]
+
=
1
    
def
MakeFinalName
(
name_
=
name
index
=
count_names
[
name
]
-
1
)
:
      
if
type
.
lower
(
)
=
=
'
end
'
and
end_names
.
get
(
base
)
:
        
return
end_names
[
base
]
.
pop
(
-
1
)
      
if
count_names
[
name_
]
!
=
1
:
        
name_
=
'
%
s_
%
s
'
%
(
name_
_SUFFIXES
[
index
]
)
        
if
type
=
=
'
begin
'
:
          
end_name
=
(
'
END_
%
s_
%
s
'
%
(
base
_SUFFIXES
[
index
]
)
)
.
upper
(
)
          
if
base
in
end_names
:
            
end_names
[
base
]
.
append
(
end_name
)
          
else
:
            
end_names
[
base
]
=
[
end_name
]
      
return
name_
    
return
MakeFinalName
  
current
=
0
  
last_nobreak
=
False
  
while
current
<
len
(
html
)
:
    
m
=
_MESSAGE_NO_BREAK_COMMENT
.
match
(
html
[
current
:
]
)
    
if
m
:
      
last_nobreak
=
True
      
current
+
=
m
.
end
(
)
      
continue
    
m
=
_NBSP
.
match
(
html
[
current
:
]
)
    
if
m
:
      
parts
.
append
(
(
MakeNameClosure
(
'
SPACE
'
)
m
.
group
(
)
)
)
      
current
+
=
m
.
end
(
)
      
continue
    
m
=
_REPLACEABLE
.
match
(
html
[
current
:
]
)
    
if
m
:
      
ph_name
=
MakeNameClosure
(
'
X_
%
s_X
'
%
m
.
group
(
'
name
'
)
.
replace
(
'
-
'
'
_
'
)
)
      
parts
.
append
(
(
ph_name
m
.
group
(
)
)
)
      
current
+
=
m
.
end
(
)
      
continue
    
m
=
_SPECIAL_ELEMENT
.
match
(
html
[
current
:
]
)
    
if
m
:
      
if
not
include_block_tags
:
        
if
last_nobreak
:
          
last_nobreak
=
False
        
else
:
          
raise
exception
.
BlockTagInTranslateableChunk
(
html
)
      
element_name
=
'
block
'
      
for
group
in
m
.
groupdict
(
)
:
        
if
m
.
groupdict
(
)
[
group
]
:
          
break
      
parts
.
append
(
(
MakeNameClosure
(
element_name
'
begin
'
)
                    
html
[
current
:
current
+
m
.
start
(
group
)
]
)
)
      
parts
.
append
(
m
.
group
(
group
)
)
      
parts
.
append
(
(
MakeNameClosure
(
element_name
'
end
'
)
                    
html
[
current
+
m
.
end
(
group
)
:
current
+
m
.
end
(
)
]
)
)
      
current
+
=
m
.
end
(
)
      
continue
    
m
=
_ELEMENT
.
match
(
html
[
current
:
]
)
    
if
m
:
      
element_name
=
m
.
group
(
'
element
'
)
.
lower
(
)
      
if
not
include_block_tags
and
not
element_name
in
_INLINE_TAGS
:
        
if
last_nobreak
:
          
last_nobreak
=
False
        
else
:
          
raise
exception
.
BlockTagInTranslateableChunk
(
html
[
current
:
]
)
      
if
element_name
in
_HTML_PLACEHOLDER_NAMES
:
        
element_name
=
_HTML_PLACEHOLDER_NAMES
[
element_name
]
      
type
=
'
'
      
if
not
m
.
group
(
'
empty
'
)
:
        
if
m
.
group
(
'
closing
'
)
:
          
type
=
'
end
'
        
else
:
          
type
=
'
begin
'
      
parts
.
append
(
(
MakeNameClosure
(
element_name
type
)
m
.
group
(
)
)
)
      
current
+
=
m
.
end
(
)
      
continue
    
if
len
(
parts
)
and
isinstance
(
parts
[
-
1
]
six
.
string_types
)
:
      
parts
[
-
1
]
+
=
html
[
current
]
    
else
:
      
parts
.
append
(
html
[
current
]
)
    
current
+
=
1
  
msg_text
=
'
'
  
placeholders
=
[
]
  
for
part
in
parts
:
    
if
isinstance
(
part
tuple
)
:
      
final_name
=
part
[
0
]
(
)
      
original
=
part
[
1
]
      
msg_text
+
=
final_name
      
placeholders
.
append
(
tclib
.
Placeholder
(
final_name
original
'
(
HTML
code
)
'
)
)
    
else
:
      
msg_text
+
=
part
  
msg
=
tclib
.
Message
(
text
=
msg_text
placeholders
=
placeholders
                      
description
=
description
)
  
content
=
msg
.
GetContent
(
)
  
for
ix
in
range
(
len
(
content
)
)
:
    
if
isinstance
(
content
[
ix
]
six
.
string_types
)
:
      
content
[
ix
]
=
util
.
UnescapeHtml
(
content
[
ix
]
replace_nbsp
=
False
)
  
return
msg
class
TrHtml
(
interface
.
GathererBase
)
:
  
'
'
'
Represents
a
document
or
message
in
the
template
format
used
by
  
Total
Recall
for
HTML
documents
.
'
'
'
  
def
__init__
(
self
*
args
*
*
kwargs
)
:
    
super
(
TrHtml
self
)
.
__init__
(
*
args
*
*
kwargs
)
    
self
.
have_parsed_
=
False
    
self
.
skeleton_
=
[
]
    
self
.
fold_whitespace_
=
False
  
def
SetAttributes
(
self
attrs
)
:
    
'
'
'
Sets
node
attributes
used
by
the
gatherer
.
    
This
checks
the
fold_whitespace
attribute
.
    
Args
:
      
attrs
:
The
mapping
of
node
attributes
.
    
'
'
'
    
self
.
fold_whitespace_
=
(
'
fold_whitespace
'
in
attrs
and
                             
attrs
[
'
fold_whitespace
'
]
=
=
'
true
'
)
  
def
GetText
(
self
)
:
    
'
'
'
Returns
the
original
text
of
the
HTML
document
'
'
'
    
return
self
.
text_
  
def
GetTextualIds
(
self
)
:
    
return
[
self
.
extkey
]
  
def
GetCliques
(
self
)
:
    
'
'
'
Returns
the
message
cliques
for
each
translateable
message
in
the
    
document
.
'
'
'
    
return
[
x
for
x
in
self
.
skeleton_
if
isinstance
(
x
clique
.
MessageClique
)
]
  
def
Translate
(
self
lang
pseudo_if_not_available
=
True
                
skeleton_gatherer
=
None
fallback_to_english
=
False
)
:
    
'
'
'
Returns
this
document
with
translateable
messages
filled
with
    
the
translation
for
language
'
lang
'
.
    
Args
:
      
lang
:
'
en
'
      
pseudo_if_not_available
:
True
    
Return
:
      
'
ID_THIS_SECTION
TYPE
\
n
.
.
.
BEGIN
\
n
"
Translated
message
"
\
n
.
.
.
.
.
.
\
nEND
    
Raises
:
      
grit
.
exception
.
NotReady
(
)
if
used
before
Parse
(
)
has
been
successfully
      
called
.
      
grit
.
exception
.
NoSuchTranslation
(
)
if
'
pseudo_if_not_available
'
is
false
      
and
there
is
no
translation
for
the
requested
language
.
    
'
'
'
    
if
len
(
self
.
skeleton_
)
=
=
0
:
      
raise
exception
.
NotReady
(
)
    
out
=
[
]
    
for
item
in
self
.
skeleton_
:
      
if
isinstance
(
item
six
.
string_types
)
:
        
out
.
append
(
item
)
      
else
:
        
msg
=
item
.
MessageForLanguage
(
lang
                                      
pseudo_if_not_available
                                      
fallback_to_english
)
        
for
content
in
msg
.
GetContent
(
)
:
          
if
isinstance
(
content
tclib
.
Placeholder
)
:
            
out
.
append
(
content
.
GetOriginal
(
)
)
          
else
:
            
out
.
append
(
util
.
EscapeHtml
(
content
True
)
)
    
return
'
'
.
join
(
out
)
  
def
Parse
(
self
)
:
    
if
self
.
have_parsed_
:
      
return
    
self
.
have_parsed_
=
True
    
text
=
self
.
_LoadInputFile
(
)
    
if
text
.
startswith
(
u
'
\
ufeff
'
)
:
      
text
=
text
[
1
:
]
    
self
.
text_
=
text
    
m
=
_SILLY_HEADER
.
match
(
text
)
    
if
m
:
      
self
.
skeleton_
.
append
(
text
[
:
m
.
start
(
'
title
'
)
]
)
      
self
.
skeleton_
.
append
(
self
.
uberclique
.
MakeClique
(
        
tclib
.
Message
(
text
=
text
[
m
.
start
(
'
title
'
)
:
m
.
end
(
'
title
'
)
]
)
)
)
      
self
.
skeleton_
.
append
(
text
[
m
.
end
(
'
title
'
)
:
m
.
end
(
)
]
)
      
text
=
text
[
m
.
end
(
)
:
]
    
chunks
=
HtmlChunks
(
)
.
Parse
(
text
self
.
fold_whitespace_
)
    
for
chunk
in
chunks
:
      
if
chunk
[
0
]
:
        
self
.
skeleton_
.
append
(
self
.
uberclique
.
MakeClique
(
          
HtmlToMessage
(
chunk
[
1
]
description
=
chunk
[
2
]
)
)
)
      
else
:
        
self
.
skeleton_
.
append
(
chunk
[
1
]
)
    
for
ix
in
range
(
len
(
self
.
skeleton_
)
)
:
      
got_text
=
False
      
if
isinstance
(
self
.
skeleton_
[
ix
]
clique
.
MessageClique
)
:
        
msg
=
self
.
skeleton_
[
ix
]
.
GetMessage
(
)
        
for
item
in
msg
.
GetContent
(
)
:
          
if
(
isinstance
(
item
six
.
string_types
)
              
and
_NON_WHITESPACE
.
search
(
item
)
and
item
!
=
'
&
nbsp
;
'
)
:
            
got_text
=
True
            
break
        
if
not
got_text
:
          
self
.
skeleton_
[
ix
]
=
msg
.
GetRealContent
(
)
  
def
SubstituteMessages
(
self
substituter
)
:
    
'
'
'
Applies
substitutions
to
all
messages
in
the
tree
.
    
Goes
through
the
skeleton
and
finds
all
MessageCliques
.
    
Args
:
      
substituter
:
a
grit
.
util
.
Substituter
object
.
    
'
'
'
    
new_skel
=
[
]
    
for
chunk
in
self
.
skeleton_
:
      
if
isinstance
(
chunk
clique
.
MessageClique
)
:
        
old_message
=
chunk
.
GetMessage
(
)
        
new_message
=
substituter
.
SubstituteMessage
(
old_message
)
        
if
new_message
is
not
old_message
:
          
new_skel
.
append
(
self
.
uberclique
.
MakeClique
(
new_message
)
)
          
continue
      
new_skel
.
append
(
chunk
)
    
self
.
skeleton_
=
new_skel
