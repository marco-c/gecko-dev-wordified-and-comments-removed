'
'
'
Support
for
gathering
resources
from
RC
files
.
'
'
'
from
__future__
import
print_function
import
re
from
grit
import
exception
from
grit
import
lazy_re
from
grit
import
tclib
from
grit
.
gather
import
regexp
_NEED_UNESCAPE
=
lazy_re
.
compile
(
r
'
"
"
|
\
\
\
\
|
\
\
n
|
\
\
t
'
)
_NEED_ESCAPE
=
lazy_re
.
compile
(
r
'
"
|
\
n
|
\
t
|
\
\
|
\
&
nbsp
\
;
'
)
_ESCAPE_CHARS
=
{
  
'
"
'
:
'
"
"
'
  
'
\
n
'
:
'
\
\
n
'
  
'
\
t
'
:
'
\
\
t
'
  
'
\
\
'
:
'
\
\
\
\
'
  
'
&
nbsp
;
'
:
'
'
}
_UNESCAPE_CHARS
=
dict
(
[
[
value
key
]
for
key
value
in
_ESCAPE_CHARS
.
items
(
)
]
)
class
Section
(
regexp
.
RegexpGatherer
)
:
  
'
'
'
A
section
from
a
resource
file
.
'
'
'
  
staticmethod
  
def
Escape
(
text
)
:
    
'
'
'
Returns
a
version
of
'
text
'
with
characters
escaped
that
need
to
be
    
for
inclusion
in
a
resource
section
.
'
'
'
    
def
Replace
(
match
)
:
      
return
_ESCAPE_CHARS
[
match
.
group
(
)
]
    
return
_NEED_ESCAPE
.
sub
(
Replace
text
)
  
staticmethod
  
def
UnEscape
(
text
)
:
    
'
'
'
Returns
a
version
of
'
text
'
with
escaped
characters
unescaped
.
'
'
'
    
def
Replace
(
match
)
:
      
return
_UNESCAPE_CHARS
[
match
.
group
(
)
]
    
return
_NEED_UNESCAPE
.
sub
(
Replace
text
)
  
def
_RegExpParse
(
self
rexp
text_to_parse
)
:
    
'
'
'
Overrides
_RegExpParse
to
add
shortcut
group
handling
.
Otherwise
    
the
same
.
    
'
'
'
    
super
(
Section
self
)
.
_RegExpParse
(
rexp
text_to_parse
)
    
if
not
self
.
is_skeleton
and
len
(
self
.
GetTextualIds
(
)
)
>
0
:
      
group_name
=
self
.
GetTextualIds
(
)
[
0
]
      
for
c
in
self
.
GetCliques
(
)
:
        
c
.
AddToShortcutGroup
(
group_name
)
  
def
ReadSection
(
self
)
:
    
rc_text
=
self
.
_LoadInputFile
(
)
    
out
=
'
'
    
begin_count
=
0
    
assert
self
.
extkey
    
first_line_re
=
re
.
compile
(
r
'
\
s
*
'
+
self
.
extkey
+
r
'
\
b
'
)
    
for
line
in
rc_text
.
splitlines
(
True
)
:
      
if
out
or
first_line_re
.
match
(
line
)
:
        
out
+
=
line
      
begin_count_was
=
begin_count
      
if
len
(
out
)
>
0
and
line
.
strip
(
)
=
=
'
BEGIN
'
:
        
begin_count
+
=
1
      
elif
len
(
out
)
>
0
and
line
.
strip
(
)
=
=
'
END
'
:
        
begin_count
-
=
1
      
if
begin_count_was
=
=
1
and
begin_count
=
=
0
:
        
break
    
if
len
(
out
)
=
=
0
:
      
raise
exception
.
SectionNotFound
(
'
%
s
in
file
%
s
'
%
(
self
.
extkey
self
.
rc_file
)
)
    
self
.
text_
=
out
.
strip
(
)
class
Dialog
(
Section
)
:
  
'
'
'
A
resource
section
that
contains
a
dialog
resource
.
'
'
'
  
dialog_re_
=
lazy_re
.
compile
(
r
'
'
'
    
#
The
dialog
'
s
ID
in
the
first
line
    
(
?
P
<
id1
>
[
A
-
Z0
-
9_
]
+
)
\
s
+
DIALOG
(
EX
)
?
    
|
    
#
The
caption
of
the
dialog
    
(
?
P
<
type1
>
CAPTION
)
\
s
+
"
(
?
P
<
text1
>
.
*
?
(
[
^
"
]
|
"
"
)
)
"
\
s
    
|
    
#
Lines
for
controls
that
have
text
and
an
ID
    
\
s
+
(
?
P
<
type2
>
[
A
-
Z
]
+
)
\
s
+
"
(
?
P
<
text2
>
.
*
?
(
[
^
"
]
|
"
"
)
?
)
"
\
s
*
\
s
*
(
?
P
<
id2
>
[
A
-
Z0
-
9_
]
+
)
\
s
*
    
|
    
#
Lines
for
controls
that
have
text
only
    
\
s
+
(
?
P
<
type3
>
[
A
-
Z
]
+
)
\
s
+
"
(
?
P
<
text3
>
.
*
?
(
[
^
"
]
|
"
"
)
?
)
"
\
s
*
    
|
    
#
Lines
for
controls
that
reference
other
resources
    
\
s
+
[
A
-
Z
]
+
\
s
+
[
A
-
Z0
-
9_
]
+
\
s
*
\
s
*
(
?
P
<
id3
>
[
A
-
Z0
-
9_
]
*
[
A
-
Z
]
[
A
-
Z0
-
9_
]
*
)
    
|
    
#
This
matches
"
NOT
SOME_STYLE
"
so
that
it
gets
consumed
and
doesn
'
t
get
    
#
matched
by
the
next
option
(
controls
that
have
only
an
ID
and
then
just
    
#
numbers
)
    
\
s
+
NOT
\
s
+
[
A
-
Z
]
[
A
-
Z0
-
9_
]
+
    
|
    
#
Lines
for
controls
that
have
only
an
ID
and
then
just
numbers
    
\
s
+
[
A
-
Z
]
+
\
s
+
(
?
P
<
id4
>
[
A
-
Z0
-
9_
]
*
[
A
-
Z
]
[
A
-
Z0
-
9_
]
*
)
\
s
*
    
'
'
'
re
.
MULTILINE
|
re
.
VERBOSE
)
  
def
Parse
(
self
)
:
    
'
'
'
Knows
how
to
parse
dialog
resource
sections
.
'
'
'
    
self
.
ReadSection
(
)
    
self
.
_RegExpParse
(
self
.
dialog_re_
self
.
text_
)
class
Menu
(
Section
)
:
  
'
'
'
A
resource
section
that
contains
a
menu
resource
.
'
'
'
  
MENU_MESSAGE_DESCRIPTION
=
(
    
'
This
message
represents
a
menu
.
Each
of
the
items
appears
in
sequence
'
    
'
(
some
possibly
within
sub
-
menus
)
in
the
menu
.
The
XX01XX
placeholders
'
    
'
serve
to
separate
items
.
Each
item
contains
an
&
(
ampersand
)
character
'
    
'
in
front
of
the
keystroke
that
should
be
used
as
a
shortcut
for
that
item
'
    
'
in
the
menu
.
Please
make
sure
that
no
two
items
in
the
same
menu
share
'
    
'
the
same
shortcut
.
'
  
)
  
menu_re_
=
lazy_re
.
compile
(
r
'
'
'
    
#
Match
the
MENU
ID
on
the
first
line
    
^
(
?
P
<
id1
>
[
A
-
Z0
-
9_
]
+
)
\
s
+
MENU
    
|
    
#
Match
the
translateable
caption
for
a
popup
menu
    
POPUP
\
s
+
"
(
?
P
<
text1
>
.
*
?
(
[
^
"
]
|
"
"
)
)
"
\
s
    
|
    
#
Match
the
caption
&
ID
of
a
MENUITEM
    
MENUITEM
\
s
+
"
(
?
P
<
text2
>
.
*
?
(
[
^
"
]
|
"
"
)
)
"
\
s
*
\
s
*
(
?
P
<
id2
>
[
A
-
Z0
-
9_
]
+
)
    
'
'
'
re
.
MULTILINE
|
re
.
VERBOSE
)
  
def
Parse
(
self
)
:
    
'
'
'
Knows
how
to
parse
menu
resource
sections
.
Because
it
is
important
that
    
menu
shortcuts
are
unique
within
the
menu
we
return
each
menu
as
a
single
    
message
with
placeholders
to
break
up
the
different
menu
items
rather
than
    
return
a
single
message
per
menu
item
.
we
also
add
an
automatic
description
    
with
instructions
for
the
translators
.
'
'
'
    
self
.
ReadSection
(
)
    
self
.
single_message_
=
tclib
.
Message
(
description
=
self
.
MENU_MESSAGE_DESCRIPTION
)
    
self
.
_RegExpParse
(
self
.
menu_re_
self
.
text_
)
class
Version
(
Section
)
:
  
'
'
'
A
resource
section
that
contains
a
VERSIONINFO
resource
.
'
'
'
  
version_re_
=
lazy_re
.
compile
(
r
'
'
'
    
#
Match
the
ID
on
the
first
line
    
^
(
?
P
<
id1
>
[
A
-
Z0
-
9_
]
+
)
\
s
+
VERSIONINFO
    
|
    
#
Match
all
potentially
translateable
VALUE
sections
    
\
s
+
VALUE
\
s
+
"
    
(
      
CompanyName
|
FileDescription
|
LegalCopyright
|
      
ProductName
|
Comments
|
LegalTrademarks
    
)
"
\
s
+
"
(
?
P
<
text1
>
.
*
?
(
[
^
"
]
|
"
"
)
)
"
\
s
    
'
'
'
re
.
MULTILINE
|
re
.
VERBOSE
)
  
def
Parse
(
self
)
:
    
'
'
'
Knows
how
to
parse
VERSIONINFO
resource
sections
.
'
'
'
    
self
.
ReadSection
(
)
    
self
.
_RegExpParse
(
self
.
version_re_
self
.
text_
)
class
RCData
(
Section
)
:
  
'
'
'
A
resource
section
that
contains
some
data
.
'
'
'
  
dialog_re_
=
lazy_re
.
compile
(
r
'
'
'
    
^
(
?
P
<
id1
>
[
A
-
Z0
-
9_
]
+
)
\
s
+
RCDATA
\
s
+
(
DISCARDABLE
)
?
\
s
+
\
{
.
*
?
\
}
    
'
'
'
re
.
MULTILINE
|
re
.
VERBOSE
|
re
.
DOTALL
)
  
def
Parse
(
self
)
:
    
'
'
'
Implementation
for
resource
types
w
/
braces
(
not
BEGIN
/
END
)
    
'
'
'
    
rc_text
=
self
.
_LoadInputFile
(
)
    
out
=
'
'
    
begin_count
=
0
    
openbrace_count
=
0
    
assert
self
.
extkey
    
first_line_re
=
re
.
compile
(
r
'
\
s
*
'
+
self
.
extkey
+
r
'
\
b
'
)
    
for
line
in
rc_text
.
splitlines
(
True
)
:
      
if
out
or
first_line_re
.
match
(
line
)
:
        
out
+
=
line
      
begin_count_was
=
begin_count
      
if
len
(
out
)
>
0
:
        
openbrace_count
+
=
line
.
count
(
'
{
'
)
        
begin_count
+
=
line
.
count
(
'
{
'
)
        
begin_count
-
=
line
.
count
(
'
}
'
)
      
if
(
(
begin_count_was
=
=
1
and
begin_count
=
=
0
)
or
         
(
openbrace_count
>
0
and
begin_count
=
=
0
)
)
:
        
break
    
if
len
(
out
)
=
=
0
:
      
raise
exception
.
SectionNotFound
(
'
%
s
in
file
%
s
'
%
(
self
.
extkey
self
.
rc_file
)
)
    
self
.
text_
=
out
    
self
.
_RegExpParse
(
self
.
dialog_re_
out
)
class
Accelerators
(
Section
)
:
  
'
'
'
An
ACCELERATORS
table
.
  
'
'
'
  
accelerators_re_
=
lazy_re
.
compile
(
r
'
'
'
    
#
Match
the
ID
on
the
first
line
    
^
(
?
P
<
id1
>
[
A
-
Z0
-
9_
]
+
)
\
s
+
ACCELERATORS
\
s
+
    
|
    
#
Match
accelerators
specified
as
VK_XXX
    
\
s
+
VK_
[
A
-
Z0
-
9_
]
+
\
s
*
(
?
P
<
id2
>
[
A
-
Z0
-
9_
]
+
)
\
s
*
    
|
    
#
Match
accelerators
specified
as
e
.
g
.
"
^
C
"
    
\
s
+
"
[
^
"
]
*
"
\
s
+
(
?
P
<
id3
>
[
A
-
Z0
-
9_
]
+
)
\
s
*
    
'
'
'
re
.
MULTILINE
|
re
.
VERBOSE
)
  
def
Parse
(
self
)
:
    
'
'
'
Knows
how
to
parse
ACCELERATORS
resource
sections
.
'
'
'
    
self
.
ReadSection
(
)
    
self
.
_RegExpParse
(
self
.
accelerators_re_
self
.
text_
)
