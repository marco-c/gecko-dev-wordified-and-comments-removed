#
include
"
common_video
/
h264
/
h264_common
.
h
"
#
include
<
cstdint
>
namespace
webrtc
{
namespace
H264
{
const
uint8_t
kNaluTypeMask
=
0x1F
;
std
:
:
vector
<
NaluIndex
>
FindNaluIndices
(
rtc
:
:
ArrayView
<
const
uint8_t
>
buffer
)
{
std
:
:
vector
<
NaluIndex
>
sequences
;
if
(
buffer
.
size
(
)
<
kNaluShortStartSequenceSize
)
return
sequences
;
static_assert
(
kNaluShortStartSequenceSize
>
=
2
"
kNaluShortStartSequenceSize
must
be
larger
or
equals
to
2
"
)
;
const
size_t
end
=
buffer
.
size
(
)
-
kNaluShortStartSequenceSize
;
for
(
size_t
i
=
0
;
i
<
end
;
)
{
if
(
buffer
[
i
+
2
]
>
1
)
{
i
+
=
3
;
}
else
if
(
buffer
[
i
+
2
]
=
=
1
)
{
if
(
buffer
[
i
+
1
]
=
=
0
&
&
buffer
[
i
]
=
=
0
)
{
NaluIndex
index
=
{
i
i
+
3
0
}
;
if
(
index
.
start_offset
>
0
&
&
buffer
[
index
.
start_offset
-
1
]
=
=
0
)
-
-
index
.
start_offset
;
auto
it
=
sequences
.
rbegin
(
)
;
if
(
it
!
=
sequences
.
rend
(
)
)
it
-
>
payload_size
=
index
.
start_offset
-
it
-
>
payload_start_offset
;
sequences
.
push_back
(
index
)
;
}
i
+
=
3
;
}
else
{
+
+
i
;
}
}
auto
it
=
sequences
.
rbegin
(
)
;
if
(
it
!
=
sequences
.
rend
(
)
)
it
-
>
payload_size
=
buffer
.
size
(
)
-
it
-
>
payload_start_offset
;
return
sequences
;
}
NaluType
ParseNaluType
(
uint8_t
data
)
{
return
static_cast
<
NaluType
>
(
data
&
kNaluTypeMask
)
;
}
std
:
:
vector
<
uint8_t
>
ParseRbsp
(
rtc
:
:
ArrayView
<
const
uint8_t
>
data
)
{
std
:
:
vector
<
uint8_t
>
out
;
out
.
reserve
(
data
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
data
.
size
(
)
;
)
{
if
(
data
.
size
(
)
-
i
>
=
3
&
&
!
data
[
i
]
&
&
!
data
[
i
+
1
]
&
&
data
[
i
+
2
]
=
=
3
)
{
out
.
push_back
(
data
[
i
+
+
]
)
;
out
.
push_back
(
data
[
i
+
+
]
)
;
i
+
+
;
}
else
{
out
.
push_back
(
data
[
i
+
+
]
)
;
}
}
return
out
;
}
void
WriteRbsp
(
rtc
:
:
ArrayView
<
const
uint8_t
>
bytes
rtc
:
:
Buffer
*
destination
)
{
static
const
uint8_t
kZerosInStartSequence
=
2
;
static
const
uint8_t
kEmulationByte
=
0x03u
;
size_t
num_consecutive_zeros
=
0
;
destination
-
>
EnsureCapacity
(
destination
-
>
size
(
)
+
bytes
.
size
(
)
)
;
for
(
uint8_t
byte
:
bytes
)
{
if
(
byte
<
=
kEmulationByte
&
&
num_consecutive_zeros
>
=
kZerosInStartSequence
)
{
destination
-
>
AppendData
(
kEmulationByte
)
;
num_consecutive_zeros
=
0
;
}
destination
-
>
AppendData
(
byte
)
;
if
(
byte
=
=
0
)
{
+
+
num_consecutive_zeros
;
}
else
{
num_consecutive_zeros
=
0
;
}
}
}
}
}
