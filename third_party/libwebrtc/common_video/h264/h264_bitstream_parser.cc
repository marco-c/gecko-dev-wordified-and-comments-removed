#
include
"
common_video
/
h264
/
h264_bitstream_parser
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
cstdint
>
#
include
<
vector
>
#
include
"
common_video
/
h264
/
h264_common
.
h
"
#
include
"
rtc_base
/
bit_buffer
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
{
const
int
kMaxAbsQpDeltaValue
=
51
;
const
int
kMinQpValue
=
0
;
const
int
kMaxQpValue
=
51
;
}
namespace
webrtc
{
#
define
RETURN_ON_FAIL
(
x
res
)
\
if
(
!
(
x
)
)
{
\
RTC_LOG_F
(
LS_ERROR
)
<
<
"
FAILED
:
"
#
x
;
\
return
res
;
\
}
#
define
RETURN_INV_ON_FAIL
(
x
)
RETURN_ON_FAIL
(
x
kInvalidStream
)
H264BitstreamParser
:
:
H264BitstreamParser
(
)
{
}
H264BitstreamParser
:
:
~
H264BitstreamParser
(
)
{
}
H264BitstreamParser
:
:
Result
H264BitstreamParser
:
:
ParseNonParameterSetNalu
(
const
uint8_t
*
source
size_t
source_length
uint8_t
nalu_type
)
{
if
(
!
sps_
|
|
!
pps_
)
return
kInvalidStream
;
last_slice_qp_delta_
=
absl
:
:
nullopt
;
const
std
:
:
vector
<
uint8_t
>
slice_rbsp
=
H264
:
:
ParseRbsp
(
source
source_length
)
;
if
(
slice_rbsp
.
size
(
)
<
H264
:
:
kNaluTypeSize
)
return
kInvalidStream
;
rtc
:
:
BitBuffer
slice_reader
(
slice_rbsp
.
data
(
)
+
H264
:
:
kNaluTypeSize
slice_rbsp
.
size
(
)
-
H264
:
:
kNaluTypeSize
)
;
bool
is_idr
=
(
source
[
0
]
&
0x0F
)
=
=
H264
:
:
NaluType
:
:
kIdr
;
uint8_t
nal_ref_idc
=
(
source
[
0
]
&
0x60
)
>
>
5
;
uint32_t
golomb_tmp
;
uint32_t
bits_tmp
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
uint32_t
slice_type
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
slice_type
)
)
;
slice_type
%
=
5
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
if
(
sps_
-
>
separate_colour_plane_flag
=
=
1
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
2
)
)
;
}
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
sps_
-
>
log2_max_frame_num
)
)
;
uint32_t
field_pic_flag
=
0
;
if
(
sps_
-
>
frame_mbs_only_flag
=
=
0
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
field_pic_flag
1
)
)
;
if
(
field_pic_flag
!
=
0
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
1
)
)
;
}
}
if
(
is_idr
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
sps_
-
>
pic_order_cnt_type
=
=
0
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
sps_
-
>
log2_max_pic_order_cnt_lsb
)
)
;
if
(
pps_
-
>
bottom_field_pic_order_in_frame_present_flag
&
&
field_pic_flag
=
=
0
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
if
(
sps_
-
>
pic_order_cnt_type
=
=
1
&
&
!
sps_
-
>
delta_pic_order_always_zero_flag
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
if
(
pps_
-
>
bottom_field_pic_order_in_frame_present_flag
&
&
!
field_pic_flag
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
if
(
pps_
-
>
redundant_pic_cnt_present_flag
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
slice_type
=
=
H264
:
:
SliceType
:
:
kB
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
1
)
)
;
}
switch
(
slice_type
)
{
case
H264
:
:
SliceType
:
:
kP
:
case
H264
:
:
SliceType
:
:
kB
:
case
H264
:
:
SliceType
:
:
kSp
:
uint32_t
num_ref_idx_active_override_flag
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
num_ref_idx_active_override_flag
1
)
)
;
if
(
num_ref_idx_active_override_flag
!
=
0
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
if
(
slice_type
=
=
H264
:
:
SliceType
:
:
kB
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
break
;
default
:
break
;
}
if
(
nalu_type
=
=
20
|
|
nalu_type
=
=
21
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unsupported
nal
unit
type
.
"
;
return
kUnsupportedStream
;
}
{
if
(
slice_type
%
5
!
=
2
&
&
slice_type
%
5
!
=
4
)
{
uint32_t
ref_pic_list_modification_flag_l0
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
ref_pic_list_modification_flag_l0
1
)
)
;
if
(
ref_pic_list_modification_flag_l0
)
{
uint32_t
modification_of_pic_nums_idc
;
do
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
modification_of_pic_nums_idc
)
)
;
if
(
modification_of_pic_nums_idc
=
=
0
|
|
modification_of_pic_nums_idc
=
=
1
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
else
if
(
modification_of_pic_nums_idc
=
=
2
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
while
(
modification_of_pic_nums_idc
!
=
3
)
;
}
}
if
(
slice_type
%
5
=
=
1
)
{
uint32_t
ref_pic_list_modification_flag_l1
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
ref_pic_list_modification_flag_l1
1
)
)
;
if
(
ref_pic_list_modification_flag_l1
)
{
uint32_t
modification_of_pic_nums_idc
;
do
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
modification_of_pic_nums_idc
)
)
;
if
(
modification_of_pic_nums_idc
=
=
0
|
|
modification_of_pic_nums_idc
=
=
1
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
else
if
(
modification_of_pic_nums_idc
=
=
2
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
while
(
modification_of_pic_nums_idc
!
=
3
)
;
}
}
}
if
(
(
pps_
-
>
weighted_pred_flag
&
&
(
slice_type
=
=
H264
:
:
SliceType
:
:
kP
|
|
slice_type
=
=
H264
:
:
SliceType
:
:
kSp
)
)
|
|
(
pps_
-
>
weighted_bipred_idc
=
=
1
&
&
slice_type
=
=
H264
:
:
SliceType
:
:
kB
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Streams
with
pred_weight_table
unsupported
.
"
;
return
kUnsupportedStream
;
}
if
(
nal_ref_idc
!
=
0
)
{
if
(
is_idr
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
2
)
)
;
}
else
{
uint32_t
adaptive_ref_pic_marking_mode_flag
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadBits
(
&
adaptive_ref_pic_marking_mode_flag
1
)
)
;
if
(
adaptive_ref_pic_marking_mode_flag
)
{
uint32_t
memory_management_control_operation
;
do
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
memory_management_control_operation
)
)
;
if
(
memory_management_control_operation
=
=
1
|
|
memory_management_control_operation
=
=
3
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
memory_management_control_operation
=
=
2
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
memory_management_control_operation
=
=
3
|
|
memory_management_control_operation
=
=
6
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
memory_management_control_operation
=
=
4
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
while
(
memory_management_control_operation
!
=
0
)
;
}
}
}
if
(
pps_
-
>
entropy_coding_mode_flag
&
&
slice_type
!
=
H264
:
:
SliceType
:
:
kI
&
&
slice_type
!
=
H264
:
:
SliceType
:
:
kSi
)
{
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
int32_t
last_slice_qp_delta
;
RETURN_INV_ON_FAIL
(
slice_reader
.
ReadSignedExponentialGolomb
(
&
last_slice_qp_delta
)
)
;
if
(
abs
(
last_slice_qp_delta
)
>
kMaxAbsQpDeltaValue
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Parsed
QP
value
out
of
range
.
"
;
return
kInvalidStream
;
}
last_slice_qp_delta_
=
last_slice_qp_delta
;
return
kOk
;
}
void
H264BitstreamParser
:
:
ParseSlice
(
const
uint8_t
*
slice
size_t
length
)
{
H264
:
:
NaluType
nalu_type
=
H264
:
:
ParseNaluType
(
slice
[
0
]
)
;
switch
(
nalu_type
)
{
case
H264
:
:
NaluType
:
:
kSps
:
{
sps_
=
SpsParser
:
:
ParseSps
(
slice
+
H264
:
:
kNaluTypeSize
length
-
H264
:
:
kNaluTypeSize
)
;
if
(
!
sps_
)
RTC_DLOG
(
LS_WARNING
)
<
<
"
Unable
to
parse
SPS
from
H264
bitstream
.
"
;
break
;
}
case
H264
:
:
NaluType
:
:
kPps
:
{
pps_
=
PpsParser
:
:
ParsePps
(
slice
+
H264
:
:
kNaluTypeSize
length
-
H264
:
:
kNaluTypeSize
)
;
if
(
!
pps_
)
RTC_DLOG
(
LS_WARNING
)
<
<
"
Unable
to
parse
PPS
from
H264
bitstream
.
"
;
break
;
}
case
H264
:
:
NaluType
:
:
kAud
:
case
H264
:
:
NaluType
:
:
kSei
:
break
;
default
:
Result
res
=
ParseNonParameterSetNalu
(
slice
length
nalu_type
)
;
if
(
res
!
=
kOk
)
RTC_DLOG
(
LS_INFO
)
<
<
"
Failed
to
parse
bitstream
.
Error
:
"
<
<
res
;
break
;
}
}
void
H264BitstreamParser
:
:
ParseBitstream
(
rtc
:
:
ArrayView
<
const
uint8_t
>
bitstream
)
{
std
:
:
vector
<
H264
:
:
NaluIndex
>
nalu_indices
=
H264
:
:
FindNaluIndices
(
bitstream
.
data
(
)
bitstream
.
size
(
)
)
;
for
(
const
H264
:
:
NaluIndex
&
index
:
nalu_indices
)
ParseSlice
(
bitstream
.
data
(
)
+
index
.
payload_start_offset
index
.
payload_size
)
;
}
absl
:
:
optional
<
int
>
H264BitstreamParser
:
:
GetLastSliceQp
(
)
const
{
if
(
!
last_slice_qp_delta_
|
|
!
pps_
)
return
absl
:
:
nullopt
;
const
int
qp
=
26
+
pps_
-
>
pic_init_qp_minus26
+
*
last_slice_qp_delta_
;
if
(
qp
<
kMinQpValue
|
|
qp
>
kMaxQpValue
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Parsed
invalid
QP
from
bitstream
.
"
;
return
absl
:
:
nullopt
;
}
return
qp
;
}
}
