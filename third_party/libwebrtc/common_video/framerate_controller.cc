#
include
"
common_video
/
framerate_controller
.
h
"
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
limits
>
#
include
<
optional
>
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
{
constexpr
double
kMinFramerate
=
0
.
5
;
}
FramerateController
:
:
FramerateController
(
)
:
FramerateController
(
std
:
:
numeric_limits
<
double
>
:
:
max
(
)
)
{
}
FramerateController
:
:
FramerateController
(
double
max_framerate
)
:
max_framerate_
(
max_framerate
)
{
}
FramerateController
:
:
~
FramerateController
(
)
{
}
void
FramerateController
:
:
SetMaxFramerate
(
double
max_framerate
)
{
max_framerate_
=
max_framerate
;
}
double
FramerateController
:
:
GetMaxFramerate
(
)
const
{
return
max_framerate_
;
}
bool
FramerateController
:
:
ShouldDropFrame
(
int64_t
in_timestamp_ns
)
{
if
(
max_framerate_
<
kMinFramerate
)
return
true
;
int64_t
frame_interval_ns
=
kNumNanosecsPerSec
/
max_framerate_
;
if
(
frame_interval_ns
<
=
0
)
{
return
false
;
}
if
(
next_frame_timestamp_ns_
)
{
const
int64_t
time_until_next_frame_ns
=
(
*
next_frame_timestamp_ns_
-
in_timestamp_ns
)
;
if
(
std
:
:
abs
(
time_until_next_frame_ns
)
<
2
*
frame_interval_ns
)
{
if
(
time_until_next_frame_ns
>
0
)
return
true
;
*
next_frame_timestamp_ns_
+
=
frame_interval_ns
;
return
false
;
}
}
next_frame_timestamp_ns_
=
in_timestamp_ns
+
frame_interval_ns
/
2
;
return
false
;
}
void
FramerateController
:
:
Reset
(
)
{
max_framerate_
=
std
:
:
numeric_limits
<
double
>
:
:
max
(
)
;
next_frame_timestamp_ns_
=
std
:
:
nullopt
;
}
void
FramerateController
:
:
KeepFrame
(
int64_t
in_timestamp_ns
)
{
if
(
ShouldDropFrame
(
in_timestamp_ns
)
)
{
if
(
max_framerate_
<
kMinFramerate
)
return
;
int64_t
frame_interval_ns
=
kNumNanosecsPerSec
/
max_framerate_
;
if
(
next_frame_timestamp_ns_
)
*
next_frame_timestamp_ns_
+
=
frame_interval_ns
;
}
}
}
