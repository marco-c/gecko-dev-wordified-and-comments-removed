#
include
"
modules
/
audio_processing
/
aec3
/
matched_filter
.
h
"
#
include
"
typedefs
.
h
"
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
#
include
<
emmintrin
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
sstream
>
#
include
<
string
>
#
include
"
modules
/
audio_processing
/
aec3
/
aec3_common
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
decimator
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
render_delay_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
logging
/
apm_data_dumper
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
echo_canceller_test_tools
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
system_wrappers
/
include
/
cpu_features_wrapper
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
aec3
{
namespace
{
std
:
:
string
ProduceDebugText
(
size_t
delay
size_t
down_sampling_factor
)
{
std
:
:
ostringstream
ss
;
ss
<
<
"
Delay
:
"
<
<
delay
;
ss
<
<
"
Down
sampling
factor
:
"
<
<
down_sampling_factor
;
return
ss
.
str
(
)
;
}
constexpr
size_t
kNumMatchedFilters
=
10
;
constexpr
size_t
kDownSamplingFactors
[
]
=
{
2
4
8
}
;
constexpr
size_t
kWindowSizeSubBlocks
=
32
;
constexpr
size_t
kAlignmentShiftSubBlocks
=
kWindowSizeSubBlocks
*
3
/
4
;
}
#
if
defined
(
WEBRTC_HAS_NEON
)
TEST
(
MatchedFilter
TestNeonOptimizations
)
{
Random
random_generator
(
42U
)
;
for
(
auto
down_sampling_factor
:
kDownSamplingFactors
)
{
const
size_t
sub_block_size
=
kBlockSize
/
down_sampling_factor
;
std
:
:
vector
<
float
>
x
(
2000
)
;
RandomizeSampleVector
(
&
random_generator
x
)
;
std
:
:
vector
<
float
>
y
(
sub_block_size
)
;
std
:
:
vector
<
float
>
h_NEON
(
512
)
;
std
:
:
vector
<
float
>
h
(
512
)
;
int
x_index
=
0
;
for
(
int
k
=
0
;
k
<
1000
;
+
+
k
)
{
RandomizeSampleVector
(
&
random_generator
y
)
;
bool
filters_updated
=
false
;
float
error_sum
=
0
.
f
;
bool
filters_updated_NEON
=
false
;
float
error_sum_NEON
=
0
.
f
;
MatchedFilterCore_NEON
(
x_index
h
.
size
(
)
*
150
.
f
*
150
.
f
x
y
h_NEON
&
filters_updated_NEON
&
error_sum_NEON
)
;
MatchedFilterCore
(
x_index
h
.
size
(
)
*
150
.
f
*
150
.
f
x
y
h
&
filters_updated
&
error_sum
)
;
EXPECT_EQ
(
filters_updated
filters_updated_NEON
)
;
EXPECT_NEAR
(
error_sum
error_sum_NEON
error_sum
/
100000
.
f
)
;
for
(
size_t
j
=
0
;
j
<
h
.
size
(
)
;
+
+
j
)
{
EXPECT_NEAR
(
h
[
j
]
h_NEON
[
j
]
0
.
00001f
)
;
}
x_index
=
(
x_index
+
sub_block_size
)
%
x
.
size
(
)
;
}
}
}
#
endif
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
TEST
(
MatchedFilter
TestSse2Optimizations
)
{
bool
use_sse2
=
(
WebRtc_GetCPUInfo
(
kSSE2
)
!
=
0
)
;
if
(
use_sse2
)
{
Random
random_generator
(
42U
)
;
for
(
auto
down_sampling_factor
:
kDownSamplingFactors
)
{
const
size_t
sub_block_size
=
kBlockSize
/
down_sampling_factor
;
std
:
:
vector
<
float
>
x
(
2000
)
;
RandomizeSampleVector
(
&
random_generator
x
)
;
std
:
:
vector
<
float
>
y
(
sub_block_size
)
;
std
:
:
vector
<
float
>
h_SSE2
(
512
)
;
std
:
:
vector
<
float
>
h
(
512
)
;
int
x_index
=
0
;
for
(
int
k
=
0
;
k
<
1000
;
+
+
k
)
{
RandomizeSampleVector
(
&
random_generator
y
)
;
bool
filters_updated
=
false
;
float
error_sum
=
0
.
f
;
bool
filters_updated_SSE2
=
false
;
float
error_sum_SSE2
=
0
.
f
;
MatchedFilterCore_SSE2
(
x_index
h
.
size
(
)
*
150
.
f
*
150
.
f
x
y
h_SSE2
&
filters_updated_SSE2
&
error_sum_SSE2
)
;
MatchedFilterCore
(
x_index
h
.
size
(
)
*
150
.
f
*
150
.
f
x
y
h
&
filters_updated
&
error_sum
)
;
EXPECT_EQ
(
filters_updated
filters_updated_SSE2
)
;
EXPECT_NEAR
(
error_sum
error_sum_SSE2
error_sum
/
100000
.
f
)
;
for
(
size_t
j
=
0
;
j
<
h
.
size
(
)
;
+
+
j
)
{
EXPECT_NEAR
(
h
[
j
]
h_SSE2
[
j
]
0
.
00001f
)
;
}
x_index
=
(
x_index
+
sub_block_size
)
%
x
.
size
(
)
;
}
}
}
}
#
endif
TEST
(
MatchedFilter
LagEstimation
)
{
Random
random_generator
(
42U
)
;
for
(
auto
down_sampling_factor
:
kDownSamplingFactors
)
{
const
size_t
sub_block_size
=
kBlockSize
/
down_sampling_factor
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
render
(
3
std
:
:
vector
<
float
>
(
kBlockSize
0
.
f
)
)
;
std
:
:
array
<
float
kBlockSize
>
capture
;
capture
.
fill
(
0
.
f
)
;
ApmDataDumper
data_dumper
(
0
)
;
for
(
size_t
delay_samples
:
{
5
64
150
200
800
1000
}
)
{
SCOPED_TRACE
(
ProduceDebugText
(
delay_samples
down_sampling_factor
)
)
;
Decimator
capture_decimator
(
down_sampling_factor
)
;
DelayBuffer
<
float
>
signal_delay_buffer
(
down_sampling_factor
*
delay_samples
)
;
MatchedFilter
filter
(
&
data_dumper
DetectOptimization
(
)
sub_block_size
kWindowSizeSubBlocks
kNumMatchedFilters
kAlignmentShiftSubBlocks
150
)
;
std
:
:
unique_ptr
<
RenderDelayBuffer
>
render_delay_buffer
(
RenderDelayBuffer
:
:
Create
(
3
down_sampling_factor
GetDownSampledBufferSize
(
down_sampling_factor
kNumMatchedFilters
)
GetRenderDelayBufferSize
(
down_sampling_factor
kNumMatchedFilters
)
)
)
;
for
(
size_t
k
=
0
;
k
<
(
300
+
delay_samples
/
sub_block_size
)
;
+
+
k
)
{
RandomizeSampleVector
(
&
random_generator
render
[
0
]
)
;
signal_delay_buffer
.
Delay
(
render
[
0
]
capture
)
;
render_delay_buffer
-
>
Insert
(
render
)
;
render_delay_buffer
-
>
UpdateBuffers
(
)
;
std
:
:
array
<
float
kBlockSize
>
downsampled_capture_data
;
rtc
:
:
ArrayView
<
float
>
downsampled_capture
(
downsampled_capture_data
.
data
(
)
sub_block_size
)
;
capture_decimator
.
Decimate
(
capture
downsampled_capture
)
;
filter
.
Update
(
render_delay_buffer
-
>
GetDownsampledRenderBuffer
(
)
downsampled_capture
)
;
}
auto
lag_estimates
=
filter
.
GetLagEstimates
(
)
;
rtc
:
:
Optional
<
size_t
>
expected_most_accurate_lag_estimate
;
size_t
alignment_shift_sub_blocks
=
0
;
for
(
size_t
k
=
0
;
k
<
kNumMatchedFilters
;
+
+
k
)
{
if
(
(
alignment_shift_sub_blocks
+
3
*
kWindowSizeSubBlocks
/
4
)
*
sub_block_size
>
delay_samples
)
{
expected_most_accurate_lag_estimate
=
k
>
0
?
k
-
1
:
0
;
break
;
}
alignment_shift_sub_blocks
+
=
kAlignmentShiftSubBlocks
;
}
ASSERT_TRUE
(
expected_most_accurate_lag_estimate
)
;
for
(
size_t
k
=
0
;
k
<
kNumMatchedFilters
;
+
+
k
)
{
if
(
k
!
=
*
expected_most_accurate_lag_estimate
&
&
k
!
=
(
*
expected_most_accurate_lag_estimate
+
1
)
)
{
EXPECT_TRUE
(
lag_estimates
[
*
expected_most_accurate_lag_estimate
]
.
accuracy
>
lag_estimates
[
k
]
.
accuracy
|
|
!
lag_estimates
[
k
]
.
reliable
|
|
!
lag_estimates
[
*
expected_most_accurate_lag_estimate
]
.
reliable
)
;
}
}
for
(
auto
&
le
:
lag_estimates
)
{
EXPECT_TRUE
(
le
.
updated
)
;
}
EXPECT_TRUE
(
lag_estimates
[
*
expected_most_accurate_lag_estimate
]
.
reliable
|
|
lag_estimates
[
std
:
:
min
(
*
expected_most_accurate_lag_estimate
+
1
lag_estimates
.
size
(
)
-
1
)
]
.
reliable
)
;
if
(
lag_estimates
[
*
expected_most_accurate_lag_estimate
]
.
reliable
)
{
EXPECT_TRUE
(
delay_samples
=
=
lag_estimates
[
*
expected_most_accurate_lag_estimate
]
.
lag
)
;
}
else
{
EXPECT_TRUE
(
delay_samples
=
=
lag_estimates
[
std
:
:
min
(
*
expected_most_accurate_lag_estimate
+
1
lag_estimates
.
size
(
)
-
1
)
]
.
lag
)
;
}
}
}
}
TEST
(
MatchedFilter
LagNotReliableForUncorrelatedRenderAndCapture
)
{
Random
random_generator
(
42U
)
;
for
(
auto
down_sampling_factor
:
kDownSamplingFactors
)
{
const
size_t
sub_block_size
=
kBlockSize
/
down_sampling_factor
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
render
(
3
std
:
:
vector
<
float
>
(
kBlockSize
0
.
f
)
)
;
std
:
:
array
<
float
kBlockSize
>
capture_data
;
rtc
:
:
ArrayView
<
float
>
capture
(
capture_data
.
data
(
)
sub_block_size
)
;
std
:
:
fill
(
capture
.
begin
(
)
capture
.
end
(
)
0
.
f
)
;
ApmDataDumper
data_dumper
(
0
)
;
std
:
:
unique_ptr
<
RenderDelayBuffer
>
render_delay_buffer
(
RenderDelayBuffer
:
:
Create
(
3
down_sampling_factor
GetDownSampledBufferSize
(
down_sampling_factor
kNumMatchedFilters
)
GetRenderDelayBufferSize
(
down_sampling_factor
kNumMatchedFilters
)
)
)
;
MatchedFilter
filter
(
&
data_dumper
DetectOptimization
(
)
sub_block_size
kWindowSizeSubBlocks
kNumMatchedFilters
kAlignmentShiftSubBlocks
150
)
;
for
(
size_t
k
=
0
;
k
<
100
;
+
+
k
)
{
RandomizeSampleVector
(
&
random_generator
render
[
0
]
)
;
RandomizeSampleVector
(
&
random_generator
capture
)
;
render_delay_buffer
-
>
Insert
(
render
)
;
filter
.
Update
(
render_delay_buffer
-
>
GetDownsampledRenderBuffer
(
)
capture
)
;
}
auto
lag_estimates
=
filter
.
GetLagEstimates
(
)
;
EXPECT_EQ
(
kNumMatchedFilters
lag_estimates
.
size
(
)
)
;
for
(
auto
&
le
:
lag_estimates
)
{
EXPECT_FALSE
(
le
.
reliable
)
;
}
}
}
TEST
(
MatchedFilter
LagNotUpdatedForLowLevelRender
)
{
Random
random_generator
(
42U
)
;
for
(
auto
down_sampling_factor
:
kDownSamplingFactors
)
{
const
size_t
sub_block_size
=
kBlockSize
/
down_sampling_factor
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
render
(
3
std
:
:
vector
<
float
>
(
kBlockSize
0
.
f
)
)
;
std
:
:
array
<
float
kBlockSize
>
capture
;
capture
.
fill
(
0
.
f
)
;
ApmDataDumper
data_dumper
(
0
)
;
MatchedFilter
filter
(
&
data_dumper
DetectOptimization
(
)
sub_block_size
kWindowSizeSubBlocks
kNumMatchedFilters
kAlignmentShiftSubBlocks
150
)
;
std
:
:
unique_ptr
<
RenderDelayBuffer
>
render_delay_buffer
(
RenderDelayBuffer
:
:
Create
(
3
down_sampling_factor
GetDownSampledBufferSize
(
down_sampling_factor
kNumMatchedFilters
)
GetRenderDelayBufferSize
(
down_sampling_factor
kNumMatchedFilters
)
)
)
;
Decimator
capture_decimator
(
down_sampling_factor
)
;
for
(
size_t
k
=
0
;
k
<
100
;
+
+
k
)
{
RandomizeSampleVector
(
&
random_generator
render
[
0
]
)
;
for
(
auto
&
render_k
:
render
[
0
]
)
{
render_k
*
=
149
.
f
/
32767
.
f
;
}
std
:
:
copy
(
render
[
0
]
.
begin
(
)
render
[
0
]
.
end
(
)
capture
.
begin
(
)
)
;
std
:
:
array
<
float
kBlockSize
>
downsampled_capture_data
;
rtc
:
:
ArrayView
<
float
>
downsampled_capture
(
downsampled_capture_data
.
data
(
)
sub_block_size
)
;
capture_decimator
.
Decimate
(
capture
downsampled_capture
)
;
filter
.
Update
(
render_delay_buffer
-
>
GetDownsampledRenderBuffer
(
)
downsampled_capture
)
;
}
auto
lag_estimates
=
filter
.
GetLagEstimates
(
)
;
EXPECT_EQ
(
kNumMatchedFilters
lag_estimates
.
size
(
)
)
;
for
(
auto
&
le
:
lag_estimates
)
{
EXPECT_FALSE
(
le
.
updated
)
;
EXPECT_FALSE
(
le
.
reliable
)
;
}
}
}
TEST
(
MatchedFilter
NumberOfLagEstimates
)
{
ApmDataDumper
data_dumper
(
0
)
;
for
(
auto
down_sampling_factor
:
kDownSamplingFactors
)
{
const
size_t
sub_block_size
=
kBlockSize
/
down_sampling_factor
;
for
(
size_t
num_matched_filters
=
0
;
num_matched_filters
<
10
;
+
+
num_matched_filters
)
{
MatchedFilter
filter
(
&
data_dumper
DetectOptimization
(
)
sub_block_size
32
num_matched_filters
1
150
)
;
EXPECT_EQ
(
num_matched_filters
filter
.
GetLagEstimates
(
)
.
size
(
)
)
;
}
}
}
#
if
RTC_DCHECK_IS_ON
&
&
GTEST_HAS_DEATH_TEST
&
&
!
defined
(
WEBRTC_ANDROID
)
TEST
(
MatchedFilter
ZeroWindowSize
)
{
ApmDataDumper
data_dumper
(
0
)
;
EXPECT_DEATH
(
MatchedFilter
(
&
data_dumper
DetectOptimization
(
)
16
0
1
1
150
)
"
"
)
;
}
TEST
(
MatchedFilter
NullDataDumper
)
{
EXPECT_DEATH
(
MatchedFilter
(
nullptr
DetectOptimization
(
)
16
1
1
1
150
)
"
"
)
;
}
TEST
(
MatchedFilter
DISABLED_BlockSizeMultipleOf4
)
{
ApmDataDumper
data_dumper
(
0
)
;
EXPECT_DEATH
(
MatchedFilter
(
&
data_dumper
DetectOptimization
(
)
15
1
1
1
150
)
"
"
)
;
}
TEST
(
MatchedFilter
DISABLED_SubBlockSizeAddsUpToBlockSize
)
{
ApmDataDumper
data_dumper
(
0
)
;
EXPECT_DEATH
(
MatchedFilter
(
&
data_dumper
DetectOptimization
(
)
12
1
1
1
150
)
"
"
)
;
}
#
endif
}
}
