#
ifndef
MODULES_AUDIO_PROCESSING_AEC3_ADAPTIVE_FIR_FILTER_H_
#
define
MODULES_AUDIO_PROCESSING_AEC3_ADAPTIVE_FIR_FILTER_H_
#
include
<
array
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
aec3_common
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
aec3_fft
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
fft_data
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
render_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
logging
/
apm_data_dumper
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
namespace
webrtc
{
namespace
aec3
{
void
UpdateFrequencyResponse
(
rtc
:
:
ArrayView
<
const
FftData
>
H
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
*
H2
)
;
#
if
defined
(
WEBRTC_HAS_NEON
)
void
UpdateFrequencyResponse_NEON
(
rtc
:
:
ArrayView
<
const
FftData
>
H
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
*
H2
)
;
#
endif
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
void
UpdateFrequencyResponse_SSE2
(
rtc
:
:
ArrayView
<
const
FftData
>
H
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
*
H2
)
;
#
endif
void
UpdateErlEstimator
(
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
H2
std
:
:
array
<
float
kFftLengthBy2Plus1
>
*
erl
)
;
#
if
defined
(
WEBRTC_HAS_NEON
)
void
UpdateErlEstimator_NEON
(
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
H2
std
:
:
array
<
float
kFftLengthBy2Plus1
>
*
erl
)
;
#
endif
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
void
UpdateErlEstimator_SSE2
(
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
H2
std
:
:
array
<
float
kFftLengthBy2Plus1
>
*
erl
)
;
#
endif
void
AdaptPartitions
(
const
RenderBuffer
&
render_buffer
const
FftData
&
G
rtc
:
:
ArrayView
<
FftData
>
H
)
;
#
if
defined
(
WEBRTC_HAS_NEON
)
void
AdaptPartitions_NEON
(
const
RenderBuffer
&
render_buffer
const
FftData
&
G
rtc
:
:
ArrayView
<
FftData
>
H
)
;
#
endif
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
void
AdaptPartitions_SSE2
(
const
RenderBuffer
&
render_buffer
const
FftData
&
G
rtc
:
:
ArrayView
<
FftData
>
H
)
;
#
endif
void
ApplyFilter
(
const
RenderBuffer
&
render_buffer
rtc
:
:
ArrayView
<
const
FftData
>
H
FftData
*
S
)
;
#
if
defined
(
WEBRTC_HAS_NEON
)
void
ApplyFilter_NEON
(
const
RenderBuffer
&
render_buffer
rtc
:
:
ArrayView
<
const
FftData
>
H
FftData
*
S
)
;
#
endif
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
void
ApplyFilter_SSE2
(
const
RenderBuffer
&
render_buffer
rtc
:
:
ArrayView
<
const
FftData
>
H
FftData
*
S
)
;
#
endif
}
class
AdaptiveFirFilter
{
public
:
AdaptiveFirFilter
(
size_t
size_partitions
Aec3Optimization
optimization
ApmDataDumper
*
data_dumper
)
;
~
AdaptiveFirFilter
(
)
;
void
Filter
(
const
RenderBuffer
&
render_buffer
FftData
*
S
)
const
;
void
Adapt
(
const
RenderBuffer
&
render_buffer
const
FftData
&
G
)
;
void
HandleEchoPathChange
(
)
;
size_t
SizePartitions
(
)
const
{
return
H_
.
size
(
)
;
}
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
Erl
(
)
const
{
return
erl_
;
}
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
FilterFrequencyResponse
(
)
const
{
return
H2_
;
}
const
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
&
FilterImpulseResponse
(
)
const
{
return
h_
;
}
void
DumpFilter
(
const
char
*
name
)
{
for
(
auto
&
H
:
H_
)
{
data_dumper_
-
>
DumpRaw
(
name
H
.
re
)
;
data_dumper_
-
>
DumpRaw
(
name
H
.
im
)
;
}
}
private
:
void
Constrain
(
)
;
ApmDataDumper
*
const
data_dumper_
;
const
Aec3Fft
fft_
;
const
Aec3Optimization
optimization_
;
std
:
:
vector
<
FftData
>
H_
;
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
H2_
;
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
h_
;
std
:
:
array
<
float
kFftLengthBy2Plus1
>
erl_
;
size_t
partition_to_constrain_
=
0
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
AdaptiveFirFilter
)
;
}
;
}
#
endif
