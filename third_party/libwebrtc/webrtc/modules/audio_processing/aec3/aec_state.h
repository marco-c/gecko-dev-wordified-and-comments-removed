#
ifndef
MODULES_AUDIO_PROCESSING_AEC3_AEC_STATE_H_
#
define
MODULES_AUDIO_PROCESSING_AEC3_AEC_STATE_H_
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
optional
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
aec3_common
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
echo_path_variability
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
erl_estimator
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
erle_estimator
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
render_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
namespace
webrtc
{
class
ApmDataDumper
;
class
AecState
{
public
:
explicit
AecState
(
const
EchoCanceller3Config
&
config
)
;
~
AecState
(
)
;
bool
UsableLinearEstimate
(
)
const
{
return
usable_linear_estimate_
;
}
bool
EchoLeakageDetected
(
)
const
{
return
echo_leakage_detected_
;
}
bool
ActiveRender
(
)
const
{
return
blocks_with_filter_adaptation_
>
200
;
}
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
Erle
(
)
const
{
return
erle_estimator_
.
Erle
(
)
;
}
float
ErleTimeDomain
(
)
const
{
return
erle_estimator_
.
ErleTimeDomain
(
)
;
}
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
Erl
(
)
const
{
return
erl_estimator_
.
Erl
(
)
;
}
float
ErlTimeDomain
(
)
const
{
return
erl_estimator_
.
ErlTimeDomain
(
)
;
}
rtc
:
:
Optional
<
size_t
>
FilterDelay
(
)
const
{
return
filter_delay_
;
}
rtc
:
:
Optional
<
size_t
>
ExternalDelay
(
)
const
{
return
external_delay_
;
}
bool
SaturatedCapture
(
)
const
{
return
capture_signal_saturation_
;
}
bool
SaturatedEcho
(
)
const
{
return
echo_saturation_
;
}
bool
SaturatingEchoPath
(
)
const
{
return
saturating_echo_path_
;
}
void
UpdateCaptureSaturation
(
bool
capture_signal_saturation
)
{
capture_signal_saturation_
=
capture_signal_saturation
;
}
bool
TransparentMode
(
)
const
{
return
transparent_mode_
;
}
void
HandleEchoPathChange
(
const
EchoPathVariability
&
echo_path_variability
)
;
float
ReverbDecay
(
)
const
{
return
reverb_decay_
;
}
bool
ForcedZeroGain
(
)
const
{
return
force_zero_gain_
;
}
bool
InaudibleEcho
(
)
const
{
return
echo_audibility_
.
InaudibleEcho
(
)
;
}
void
UpdateWithOutput
(
rtc
:
:
ArrayView
<
const
float
>
e
)
{
echo_audibility_
.
UpdateWithOutput
(
e
)
;
}
bool
SufficientFilterUpdates
(
)
const
{
return
sufficient_filter_updates_
;
}
bool
LinearEchoEstimate
(
)
const
{
return
linear_echo_estimate_
;
}
bool
InitialState
(
)
const
{
return
initial_state_
;
}
void
Update
(
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
adaptive_filter_frequency_response
const
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
&
adaptive_filter_impulse_response
bool
converged_filter
const
rtc
:
:
Optional
<
size_t
>
&
external_delay_samples
const
RenderBuffer
&
render_buffer
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
E2_main
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
Y2
rtc
:
:
ArrayView
<
const
float
>
x
const
std
:
:
array
<
float
kBlockSize
>
&
s_main
bool
echo_leakage_detected
)
;
private
:
class
EchoAudibility
{
public
:
void
Update
(
rtc
:
:
ArrayView
<
const
float
>
x
const
std
:
:
array
<
float
kBlockSize
>
&
s
bool
converged_filter
)
;
void
UpdateWithOutput
(
rtc
:
:
ArrayView
<
const
float
>
e
)
;
bool
InaudibleEcho
(
)
const
{
return
inaudible_echo_
;
}
private
:
float
max_nearend_
=
0
.
f
;
size_t
max_nearend_counter_
=
0
;
size_t
low_farend_counter_
=
0
;
bool
inaudible_echo_
=
false
;
}
;
void
UpdateReverb
(
const
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
&
impulse_response
)
;
static
int
instance_count_
;
std
:
:
unique_ptr
<
ApmDataDumper
>
data_dumper_
;
ErlEstimator
erl_estimator_
;
ErleEstimator
erle_estimator_
;
size_t
capture_block_counter_
=
0
;
size_t
blocks_with_filter_adaptation_
=
0
;
size_t
blocks_with_strong_render_
=
0
;
bool
usable_linear_estimate_
=
false
;
bool
echo_leakage_detected_
=
false
;
bool
capture_signal_saturation_
=
false
;
bool
echo_saturation_
=
false
;
bool
transparent_mode_
=
false
;
float
previous_max_sample_
=
0
.
f
;
std
:
:
array
<
float
kAdaptiveFilterLength
>
max_render_
;
bool
force_zero_gain_
=
false
;
bool
render_received_
=
false
;
size_t
force_zero_gain_counter_
=
0
;
rtc
:
:
Optional
<
size_t
>
filter_delay_
;
rtc
:
:
Optional
<
size_t
>
external_delay_
;
size_t
blocks_since_last_saturation_
=
1000
;
float
reverb_decay_to_test_
=
0
.
9f
;
float
reverb_decay_candidate_
=
0
.
f
;
float
reverb_decay_candidate_residual_
=
-
1
.
f
;
EchoAudibility
echo_audibility_
;
const
EchoCanceller3Config
config_
;
float
reverb_decay_
;
bool
saturating_echo_path_
=
false
;
bool
initial_state_
=
true
;
bool
linear_echo_estimate_
=
false
;
bool
sufficient_filter_updates_
=
false
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AecState
)
;
}
;
}
#
endif
