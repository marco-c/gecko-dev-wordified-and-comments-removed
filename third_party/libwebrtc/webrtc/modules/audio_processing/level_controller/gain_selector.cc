#
include
"
modules
/
audio_processing
/
level_controller
/
gain_selector
.
h
"
#
include
<
math
.
h
>
#
include
<
algorithm
>
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
modules
/
audio_processing
/
level_controller
/
level_controller_constants
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
GainSelector
:
:
GainSelector
(
)
{
Initialize
(
AudioProcessing
:
:
kSampleRate48kHz
)
;
}
void
GainSelector
:
:
Initialize
(
int
sample_rate_hz
)
{
gain_
=
1
.
f
;
frame_length_
=
rtc
:
:
CheckedDivExact
(
sample_rate_hz
100
)
;
highly_nonstationary_signal_hold_counter_
=
0
;
}
float
GainSelector
:
:
GetNewGain
(
float
peak_level
float
noise_energy
float
saturating_gain
bool
gain_jumpstart
SignalClassifier
:
:
SignalType
signal_type
)
{
RTC_DCHECK_LT
(
0
.
f
peak_level
)
;
if
(
signal_type
=
=
SignalClassifier
:
:
SignalType
:
:
kHighlyNonStationary
|
|
gain_jumpstart
)
{
highly_nonstationary_signal_hold_counter_
=
100
;
}
else
{
highly_nonstationary_signal_hold_counter_
=
std
:
:
max
(
0
highly_nonstationary_signal_hold_counter_
-
1
)
;
}
float
desired_gain
;
if
(
highly_nonstationary_signal_hold_counter_
>
0
)
{
desired_gain
=
kTargetLcPeakLevel
/
peak_level
;
float
max_noise_energy
=
kMaxLcNoisePower
*
frame_length_
;
if
(
noise_energy
*
desired_gain
*
desired_gain
>
max_noise_energy
)
{
RTC_DCHECK_LE
(
0
.
f
noise_energy
)
;
desired_gain
=
sqrtf
(
max_noise_energy
/
noise_energy
)
;
}
}
else
{
desired_gain
=
1
.
0f
;
}
gain_
+
=
0
.
2f
*
(
desired_gain
-
gain_
)
;
gain_
=
std
:
:
min
(
gain_
saturating_gain
)
;
gain_
=
std
:
:
min
(
gain_
kMaxLcGain
)
;
gain_
=
std
:
:
max
(
gain_
1
.
f
)
;
return
gain_
;
}
}
