#
include
"
modules
/
audio_processing
/
level_controller
/
noise_level_estimator
.
h
"
#
include
<
algorithm
>
#
include
"
modules
/
audio_processing
/
audio_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
logging
/
apm_data_dumper
.
h
"
namespace
webrtc
{
NoiseLevelEstimator
:
:
NoiseLevelEstimator
(
)
{
Initialize
(
AudioProcessing
:
:
kSampleRate48kHz
)
;
}
NoiseLevelEstimator
:
:
~
NoiseLevelEstimator
(
)
{
}
void
NoiseLevelEstimator
:
:
Initialize
(
int
sample_rate_hz
)
{
noise_energy_
=
1
.
f
;
first_update_
=
true
;
min_noise_energy_
=
sample_rate_hz
*
2
.
f
*
2
.
f
/
100
.
f
;
noise_energy_hold_counter_
=
0
;
}
float
NoiseLevelEstimator
:
:
Analyze
(
SignalClassifier
:
:
SignalType
signal_type
float
frame_energy
)
{
if
(
frame_energy
<
=
0
.
f
)
{
return
noise_energy_
;
}
if
(
first_update_
)
{
first_update_
=
false
;
return
noise_energy_
=
std
:
:
max
(
frame_energy
min_noise_energy_
)
;
}
if
(
signal_type
=
=
SignalClassifier
:
:
SignalType
:
:
kStationary
)
{
if
(
frame_energy
>
noise_energy_
)
{
noise_energy_hold_counter_
=
std
:
:
max
(
noise_energy_hold_counter_
-
1
0
)
;
if
(
noise_energy_hold_counter_
=
=
0
)
{
noise_energy_
=
std
:
:
min
(
noise_energy_
*
1
.
01f
frame_energy
)
;
}
}
else
{
noise_energy_
=
std
:
:
max
(
noise_energy_
*
0
.
9f
noise_energy_
+
0
.
05f
*
(
frame_energy
-
noise_energy_
)
)
;
noise_energy_hold_counter_
=
1000
;
}
}
else
{
noise_energy_
=
noise_energy_
*
0
.
99f
;
}
return
noise_energy_
=
std
:
:
max
(
noise_energy_
min_noise_energy_
)
;
}
}
