#
ifndef
MODULES_AUDIO_PROCESSING_AEC_AEC_CORE_H_
#
define
MODULES_AUDIO_PROCESSING_AEC_AEC_CORE_H_
#
include
<
stddef
.
h
>
#
include
<
memory
>
extern
"
C
"
{
#
include
"
common_audio
/
ring_buffer
.
h
"
}
#
include
"
common_audio
/
wav_file
.
h
"
#
include
"
modules
/
audio_processing
/
aec
/
aec_common
.
h
"
#
include
"
modules
/
audio_processing
/
utility
/
block_mean_calculator
.
h
"
#
include
"
modules
/
audio_processing
/
utility
/
ooura_fft
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
#
define
FRAME_LEN
80
#
define
PART_LEN
64
/
/
Length
of
partition
#
define
PART_LEN1
(
PART_LEN
+
1
)
/
/
Unique
fft
coefficients
#
define
PART_LEN2
(
PART_LEN
*
2
)
/
/
Length
of
partition
*
2
#
define
NUM_HIGH_BANDS_MAX
2
/
/
Max
number
of
high
bands
class
ApmDataDumper
;
typedef
float
complex_t
[
2
]
;
enum
{
kOffsetLevel
=
-
100
}
;
typedef
struct
Stats
{
float
instant
;
float
average
;
float
min
;
float
max
;
float
sum
;
float
hisum
;
float
himean
;
size_t
counter
;
size_t
hicounter
;
}
Stats
;
enum
{
kExtendedNumPartitions
=
32
}
;
static
const
int
kNormalNumPartitions
=
12
;
enum
{
kLookaheadBlocks
=
15
}
;
enum
{
kHistorySizeBlocks
=
125
}
;
typedef
struct
PowerLevel
{
PowerLevel
(
)
;
BlockMeanCalculator
framelevel
;
BlockMeanCalculator
averagelevel
;
float
minlevel
;
}
PowerLevel
;
class
BlockBuffer
{
public
:
BlockBuffer
(
)
;
~
BlockBuffer
(
)
;
void
ReInit
(
)
;
void
Insert
(
const
float
block
[
PART_LEN
]
)
;
void
ExtractExtendedBlock
(
float
extended_block
[
PART_LEN
]
)
;
int
AdjustSize
(
int
buffer_size_decrease
)
;
size_t
Size
(
)
;
size_t
AvaliableSpace
(
)
;
private
:
RingBuffer
*
buffer_
;
}
;
class
DivergentFilterFraction
{
public
:
DivergentFilterFraction
(
)
;
void
Reset
(
)
;
void
AddObservation
(
const
PowerLevel
&
nearlevel
const
PowerLevel
&
linoutlevel
const
PowerLevel
&
nlpoutlevel
)
;
float
GetLatestFraction
(
)
const
;
private
:
void
Clear
(
)
;
size_t
count_
;
size_t
occurrence_
;
float
fraction_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
DivergentFilterFraction
)
;
}
;
typedef
struct
CoherenceState
{
complex_t
sde
[
PART_LEN1
]
;
complex_t
sxd
[
PART_LEN1
]
;
float
sx
[
PART_LEN1
]
sd
[
PART_LEN1
]
se
[
PART_LEN1
]
;
}
CoherenceState
;
struct
AecCore
{
explicit
AecCore
(
int
instance_index
)
;
~
AecCore
(
)
;
std
:
:
unique_ptr
<
ApmDataDumper
>
data_dumper
;
const
OouraFft
ooura_fft
;
CoherenceState
coherence_state
;
int
farBufWritePos
farBufReadPos
;
int
knownDelay
;
int
inSamples
outSamples
;
int
delayEstCtr
;
float
nearend_buffer
[
NUM_HIGH_BANDS_MAX
+
1
]
[
PART_LEN
-
(
FRAME_LEN
-
PART_LEN
)
]
;
size_t
nearend_buffer_size
;
float
output_buffer
[
NUM_HIGH_BANDS_MAX
+
1
]
[
2
*
PART_LEN
]
;
size_t
output_buffer_size
;
float
eBuf
[
PART_LEN2
]
;
float
previous_nearend_block
[
NUM_HIGH_BANDS_MAX
+
1
]
[
PART_LEN
]
;
float
xPow
[
PART_LEN1
]
;
float
dPow
[
PART_LEN1
]
;
float
dMinPow
[
PART_LEN1
]
;
float
dInitMinPow
[
PART_LEN1
]
;
float
*
noisePow
;
float
xfBuf
[
2
]
[
kExtendedNumPartitions
*
PART_LEN1
]
;
float
wfBuf
[
2
]
[
kExtendedNumPartitions
*
PART_LEN1
]
;
complex_t
xfwBuf
[
kExtendedNumPartitions
*
PART_LEN1
]
;
float
hNs
[
PART_LEN1
]
;
float
hNlFbMin
hNlFbLocalMin
;
float
hNlXdAvgMin
;
int
hNlNewMin
hNlMinCtr
;
float
overDrive
;
float
overdrive_scaling
;
int
nlp_mode
;
float
outBuf
[
PART_LEN
]
;
int
delayIdx
;
short
stNearState
echoState
;
short
divergeState
;
int
xfBufBlockPos
;
BlockBuffer
farend_block_buffer_
;
int
system_delay
;
int
mult
;
int
sampFreq
=
16000
;
size_t
num_bands
;
uint32_t
seed
;
float
filter_step_size
;
float
error_threshold
;
int
noiseEstCtr
;
PowerLevel
farlevel
;
PowerLevel
nearlevel
;
PowerLevel
linoutlevel
;
PowerLevel
nlpoutlevel
;
int
metricsMode
;
int
stateCounter
;
Stats
erl
;
Stats
erle
;
Stats
aNlp
;
Stats
rerl
;
DivergentFilterFraction
divergent_filter_fraction
;
int
freq_avg_ic
;
int
flag_Hband_cn
;
float
cn_scale_Hband
;
int
delay_metrics_delivered
;
int
delay_histogram
[
kHistorySizeBlocks
]
;
int
num_delay_values
;
int
delay_median
;
int
delay_std
;
float
fraction_poor_delays
;
int
delay_logging_enabled
;
void
*
delay_estimator_farend
;
void
*
delay_estimator
;
int
previous_delay
;
int
delay_correction_count
;
int
shift_offset
;
float
delay_quality_threshold
;
int
frame_count
;
int
delay_agnostic_enabled
;
int
extended_filter_enabled
;
bool
refined_adaptive_filter_enabled
;
int
num_partitions
;
int
extreme_filter_divergence
;
}
;
AecCore
*
WebRtcAec_CreateAec
(
int
instance_count
)
;
void
WebRtcAec_FreeAec
(
AecCore
*
aec
)
;
int
WebRtcAec_InitAec
(
AecCore
*
aec
int
sampFreq
)
;
void
WebRtcAec_InitAec_SSE2
(
void
)
;
#
if
defined
(
MIPS_FPU_LE
)
void
WebRtcAec_InitAec_mips
(
void
)
;
#
endif
#
if
defined
(
WEBRTC_HAS_NEON
)
void
WebRtcAec_InitAec_neon
(
void
)
;
#
endif
void
WebRtcAec_BufferFarendBlock
(
AecCore
*
aec
const
float
*
farend
)
;
void
WebRtcAec_ProcessFrames
(
AecCore
*
aec
const
float
*
const
*
nearend
size_t
num_bands
size_t
num_samples
int
knownDelay
float
*
const
*
out
)
;
int
WebRtcAec_AdjustFarendBufferSizeAndSystemDelay
(
AecCore
*
aec
int
size_decrease
)
;
int
WebRtcAec_GetDelayMetricsCore
(
AecCore
*
self
int
*
median
int
*
std
float
*
fraction_poor_delays
)
;
int
WebRtcAec_echo_state
(
AecCore
*
self
)
;
void
WebRtcAec_GetEchoStats
(
AecCore
*
self
Stats
*
erl
Stats
*
erle
Stats
*
a_nlp
float
*
divergent_filter_fraction
)
;
void
WebRtcAec_SetConfigCore
(
AecCore
*
self
int
nlp_mode
int
metrics_mode
int
delay_logging
)
;
void
WebRtcAec_enable_delay_agnostic
(
AecCore
*
self
int
enable
)
;
int
WebRtcAec_delay_agnostic_enabled
(
AecCore
*
self
)
;
void
WebRtcAec_enable_refined_adaptive_filter
(
AecCore
*
self
bool
enable
)
;
bool
WebRtcAec_refined_adaptive_filter
(
const
AecCore
*
self
)
;
void
WebRtcAec_enable_extended_filter
(
AecCore
*
self
int
enable
)
;
int
WebRtcAec_extended_filter_enabled
(
AecCore
*
self
)
;
int
WebRtcAec_system_delay
(
AecCore
*
self
)
;
void
WebRtcAec_SetSystemDelay
(
AecCore
*
self
int
delay
)
;
}
#
endif
