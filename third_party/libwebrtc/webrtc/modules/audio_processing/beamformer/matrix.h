#
ifndef
MODULES_AUDIO_PROCESSING_BEAMFORMER_MATRIX_H_
#
define
MODULES_AUDIO_PROCESSING_BEAMFORMER_MATRIX_H_
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
namespace
{
template
<
typename
T
>
T
sqrt_wrapper
(
T
x
)
{
return
sqrt
(
static_cast
<
double
>
(
x
)
)
;
}
template
<
typename
S
>
std
:
:
complex
<
S
>
sqrt_wrapper
(
std
:
:
complex
<
S
>
x
)
{
return
sqrt
(
x
)
;
}
}
namespace
webrtc
{
template
<
typename
T
>
class
Matrix
{
public
:
Matrix
(
)
:
num_rows_
(
0
)
num_columns_
(
0
)
{
}
Matrix
(
size_t
num_rows
size_t
num_columns
)
:
num_rows_
(
num_rows
)
num_columns_
(
num_columns
)
{
Resize
(
)
;
scratch_data_
.
resize
(
num_rows_
*
num_columns_
)
;
scratch_elements_
.
resize
(
num_rows_
)
;
}
Matrix
(
const
T
*
data
size_t
num_rows
size_t
num_columns
)
:
num_rows_
(
0
)
num_columns_
(
0
)
{
CopyFrom
(
data
num_rows
num_columns
)
;
scratch_data_
.
resize
(
num_rows_
*
num_columns_
)
;
scratch_elements_
.
resize
(
num_rows_
)
;
}
virtual
~
Matrix
(
)
{
}
void
CopyFrom
(
const
Matrix
&
other
)
{
CopyFrom
(
&
other
.
data_
[
0
]
other
.
num_rows_
other
.
num_columns_
)
;
}
void
CopyFrom
(
const
T
*
const
data
size_t
num_rows
size_t
num_columns
)
{
Resize
(
num_rows
num_columns
)
;
memcpy
(
&
data_
[
0
]
data
num_rows_
*
num_columns_
*
sizeof
(
data_
[
0
]
)
)
;
}
Matrix
&
CopyFromColumn
(
const
T
*
const
*
src
size_t
column_index
size_t
num_rows
)
{
Resize
(
1
num_rows
)
;
for
(
size_t
i
=
0
;
i
<
num_columns_
;
+
+
i
)
{
data_
[
i
]
=
src
[
i
]
[
column_index
]
;
}
return
*
this
;
}
void
Resize
(
size_t
num_rows
size_t
num_columns
)
{
if
(
num_rows
!
=
num_rows_
|
|
num_columns
!
=
num_columns_
)
{
num_rows_
=
num_rows
;
num_columns_
=
num_columns
;
Resize
(
)
;
}
}
size_t
num_rows
(
)
const
{
return
num_rows_
;
}
size_t
num_columns
(
)
const
{
return
num_columns_
;
}
T
*
const
*
elements
(
)
{
return
&
elements_
[
0
]
;
}
const
T
*
const
*
elements
(
)
const
{
return
&
elements_
[
0
]
;
}
T
Trace
(
)
{
RTC_CHECK_EQ
(
num_rows_
num_columns_
)
;
T
trace
=
0
;
for
(
size_t
i
=
0
;
i
<
num_rows_
;
+
+
i
)
{
trace
+
=
elements_
[
i
]
[
i
]
;
}
return
trace
;
}
Matrix
&
Transpose
(
)
{
CopyDataToScratch
(
)
;
Resize
(
num_columns_
num_rows_
)
;
return
Transpose
(
scratch_elements
(
)
)
;
}
Matrix
&
Transpose
(
const
Matrix
&
operand
)
{
RTC_CHECK_EQ
(
operand
.
num_rows_
num_columns_
)
;
RTC_CHECK_EQ
(
operand
.
num_columns_
num_rows_
)
;
return
Transpose
(
operand
.
elements
(
)
)
;
}
template
<
typename
S
>
Matrix
&
Scale
(
const
S
&
scalar
)
{
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
*
=
scalar
;
}
return
*
this
;
}
template
<
typename
S
>
Matrix
&
Scale
(
const
Matrix
&
operand
const
S
&
scalar
)
{
CopyFrom
(
operand
)
;
return
Scale
(
scalar
)
;
}
Matrix
&
Add
(
const
Matrix
&
operand
)
{
RTC_CHECK_EQ
(
num_rows_
operand
.
num_rows_
)
;
RTC_CHECK_EQ
(
num_columns_
operand
.
num_columns_
)
;
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
+
=
operand
.
data_
[
i
]
;
}
return
*
this
;
}
Matrix
&
Add
(
const
Matrix
&
lhs
const
Matrix
&
rhs
)
{
CopyFrom
(
lhs
)
;
return
Add
(
rhs
)
;
}
Matrix
&
Subtract
(
const
Matrix
&
operand
)
{
RTC_CHECK_EQ
(
num_rows_
operand
.
num_rows_
)
;
RTC_CHECK_EQ
(
num_columns_
operand
.
num_columns_
)
;
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
-
=
operand
.
data_
[
i
]
;
}
return
*
this
;
}
Matrix
&
Subtract
(
const
Matrix
&
lhs
const
Matrix
&
rhs
)
{
CopyFrom
(
lhs
)
;
return
Subtract
(
rhs
)
;
}
Matrix
&
PointwiseMultiply
(
const
Matrix
&
operand
)
{
RTC_CHECK_EQ
(
num_rows_
operand
.
num_rows_
)
;
RTC_CHECK_EQ
(
num_columns_
operand
.
num_columns_
)
;
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
*
=
operand
.
data_
[
i
]
;
}
return
*
this
;
}
Matrix
&
PointwiseMultiply
(
const
Matrix
&
lhs
const
Matrix
&
rhs
)
{
CopyFrom
(
lhs
)
;
return
PointwiseMultiply
(
rhs
)
;
}
Matrix
&
PointwiseDivide
(
const
Matrix
&
operand
)
{
RTC_CHECK_EQ
(
num_rows_
operand
.
num_rows_
)
;
RTC_CHECK_EQ
(
num_columns_
operand
.
num_columns_
)
;
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
/
=
operand
.
data_
[
i
]
;
}
return
*
this
;
}
Matrix
&
PointwiseDivide
(
const
Matrix
&
lhs
const
Matrix
&
rhs
)
{
CopyFrom
(
lhs
)
;
return
PointwiseDivide
(
rhs
)
;
}
Matrix
&
PointwiseSquareRoot
(
)
{
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
=
sqrt_wrapper
(
data_
[
i
]
)
;
}
return
*
this
;
}
Matrix
&
PointwiseSquareRoot
(
const
Matrix
&
operand
)
{
CopyFrom
(
operand
)
;
return
PointwiseSquareRoot
(
)
;
}
Matrix
&
PointwiseAbsoluteValue
(
)
{
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
=
abs
(
data_
[
i
]
)
;
}
return
*
this
;
}
Matrix
&
PointwiseAbsoluteValue
(
const
Matrix
&
operand
)
{
CopyFrom
(
operand
)
;
return
PointwiseAbsoluteValue
(
)
;
}
Matrix
&
PointwiseSquare
(
)
{
for
(
size_t
i
=
0
;
i
<
data_
.
size
(
)
;
+
+
i
)
{
data_
[
i
]
*
=
data_
[
i
]
;
}
return
*
this
;
}
Matrix
&
PointwiseSquare
(
const
Matrix
&
operand
)
{
CopyFrom
(
operand
)
;
return
PointwiseSquare
(
)
;
}
Matrix
&
Multiply
(
const
Matrix
&
lhs
const
Matrix
&
rhs
)
{
RTC_CHECK_EQ
(
lhs
.
num_columns_
rhs
.
num_rows_
)
;
RTC_CHECK_EQ
(
num_rows_
lhs
.
num_rows_
)
;
RTC_CHECK_EQ
(
num_columns_
rhs
.
num_columns_
)
;
return
Multiply
(
lhs
.
elements
(
)
rhs
.
num_rows_
rhs
.
elements
(
)
)
;
}
Matrix
&
Multiply
(
const
Matrix
&
rhs
)
{
RTC_CHECK_EQ
(
num_columns_
rhs
.
num_rows_
)
;
CopyDataToScratch
(
)
;
Resize
(
num_rows_
rhs
.
num_columns_
)
;
return
Multiply
(
scratch_elements
(
)
rhs
.
num_rows_
rhs
.
elements
(
)
)
;
}
std
:
:
string
ToString
(
)
const
{
std
:
:
ostringstream
ss
;
ss
<
<
std
:
:
endl
<
<
"
Matrix
"
<
<
std
:
:
endl
;
for
(
size_t
i
=
0
;
i
<
num_rows_
;
+
+
i
)
{
for
(
size_t
j
=
0
;
j
<
num_columns_
;
+
+
j
)
{
ss
<
<
elements_
[
i
]
[
j
]
<
<
"
"
;
}
ss
<
<
std
:
:
endl
;
}
ss
<
<
std
:
:
endl
;
return
ss
.
str
(
)
;
}
protected
:
void
SetNumRows
(
const
size_t
num_rows
)
{
num_rows_
=
num_rows
;
}
void
SetNumColumns
(
const
size_t
num_columns
)
{
num_columns_
=
num_columns
;
}
T
*
data
(
)
{
return
&
data_
[
0
]
;
}
const
T
*
data
(
)
const
{
return
&
data_
[
0
]
;
}
const
T
*
const
*
scratch_elements
(
)
const
{
return
&
scratch_elements_
[
0
]
;
}
void
Resize
(
)
{
size_t
size
=
num_rows_
*
num_columns_
;
data_
.
resize
(
size
)
;
elements_
.
resize
(
num_rows_
)
;
for
(
size_t
i
=
0
;
i
<
num_rows_
;
+
+
i
)
{
elements_
[
i
]
=
&
data_
[
i
*
num_columns_
]
;
}
}
void
CopyDataToScratch
(
)
{
scratch_data_
=
data_
;
scratch_elements_
.
resize
(
num_rows_
)
;
for
(
size_t
i
=
0
;
i
<
num_rows_
;
+
+
i
)
{
scratch_elements_
[
i
]
=
&
scratch_data_
[
i
*
num_columns_
]
;
}
}
private
:
size_t
num_rows_
;
size_t
num_columns_
;
std
:
:
vector
<
T
>
data_
;
std
:
:
vector
<
T
*
>
elements_
;
std
:
:
vector
<
T
>
scratch_data_
;
std
:
:
vector
<
T
*
>
scratch_elements_
;
Matrix
&
Transpose
(
const
T
*
const
*
src
)
{
for
(
size_t
i
=
0
;
i
<
num_rows_
;
+
+
i
)
{
for
(
size_t
j
=
0
;
j
<
num_columns_
;
+
+
j
)
{
elements_
[
i
]
[
j
]
=
src
[
j
]
[
i
]
;
}
}
return
*
this
;
}
Matrix
&
Multiply
(
const
T
*
const
*
lhs
size_t
num_rows_rhs
const
T
*
const
*
rhs
)
{
for
(
size_t
row
=
0
;
row
<
num_rows_
;
+
+
row
)
{
for
(
size_t
col
=
0
;
col
<
num_columns_
;
+
+
col
)
{
T
cur_element
=
0
;
for
(
size_t
i
=
0
;
i
<
num_rows_rhs
;
+
+
i
)
{
cur_element
+
=
lhs
[
row
]
[
i
]
*
rhs
[
i
]
[
col
]
;
}
elements_
[
row
]
[
col
]
=
cur_element
;
}
}
return
*
this
;
}
RTC_DISALLOW_COPY_AND_ASSIGN
(
Matrix
)
;
}
;
}
#
endif
