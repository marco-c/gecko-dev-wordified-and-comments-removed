#
ifndef
MODULES_AUDIO_PROCESSING_BEAMFORMER_NONLINEAR_BEAMFORMER_H_
#
define
MODULES_AUDIO_PROCESSING_BEAMFORMER_NONLINEAR_BEAMFORMER_H_
#
define
_USE_MATH_DEFINES
#
include
<
math
.
h
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
common_audio
/
lapped_transform
.
h
"
#
include
"
common_audio
/
channel_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
beamformer
/
array_util
.
h
"
#
include
"
modules
/
audio_processing
/
beamformer
/
complex_matrix
.
h
"
namespace
webrtc
{
class
PostFilterTransform
:
public
LappedTransform
:
:
Callback
{
public
:
PostFilterTransform
(
size_t
num_channels
size_t
chunk_length
float
*
window
size_t
fft_size
)
;
void
ProcessChunk
(
float
*
const
*
data
float
*
final_mask
)
;
protected
:
void
ProcessAudioBlock
(
const
complex
<
float
>
*
const
*
input
size_t
num_input_channels
size_t
num_freq_bins
size_t
num_output_channels
complex
<
float
>
*
const
*
output
)
override
;
private
:
LappedTransform
transform_
;
const
size_t
num_freq_bins_
;
float
*
final_mask_
;
}
;
class
NonlinearBeamformer
:
public
LappedTransform
:
:
Callback
{
public
:
static
const
float
kHalfBeamWidthRadians
;
explicit
NonlinearBeamformer
(
const
std
:
:
vector
<
Point
>
&
array_geometry
size_t
num_postfilter_channels
=
1u
SphericalPointf
target_direction
=
SphericalPointf
(
static_cast
<
float
>
(
M_PI
)
/
2
.
f
0
.
f
1
.
f
)
)
;
~
NonlinearBeamformer
(
)
override
;
virtual
void
Initialize
(
int
chunk_size_ms
int
sample_rate_hz
)
;
virtual
void
AnalyzeChunk
(
const
ChannelBuffer
<
float
>
&
data
)
;
virtual
void
PostFilter
(
ChannelBuffer
<
float
>
*
data
)
;
virtual
void
AimAt
(
const
SphericalPointf
&
target_direction
)
;
virtual
bool
IsInBeam
(
const
SphericalPointf
&
spherical_point
)
;
virtual
bool
is_target_present
(
)
;
protected
:
void
ProcessAudioBlock
(
const
complex
<
float
>
*
const
*
input
size_t
num_input_channels
size_t
num_freq_bins
size_t
num_output_channels
complex
<
float
>
*
const
*
output
)
override
;
private
:
FRIEND_TEST_ALL_PREFIXES
(
NonlinearBeamformerTest
InterfAnglesTakeAmbiguityIntoAccount
)
;
typedef
Matrix
<
float
>
MatrixF
;
typedef
ComplexMatrix
<
float
>
ComplexMatrixF
;
typedef
complex
<
float
>
complex_f
;
void
InitLowFrequencyCorrectionRanges
(
)
;
void
InitHighFrequencyCorrectionRanges
(
)
;
void
InitInterfAngles
(
)
;
void
InitDelaySumMasks
(
)
;
void
InitTargetCovMats
(
)
;
void
InitDiffuseCovMats
(
)
;
void
InitInterfCovMats
(
)
;
void
NormalizeCovMats
(
)
;
float
CalculatePostfilterMask
(
const
ComplexMatrixF
&
interf_cov_mat
float
rpsiw
float
ratio_rxiw_rxim
float
rmxi_r
)
;
void
ApplyMaskTimeSmoothing
(
)
;
void
ApplyMaskFrequencySmoothing
(
)
;
void
ApplyLowFrequencyCorrection
(
)
;
void
ApplyHighFrequencyCorrection
(
)
;
float
MaskRangeMean
(
size_t
start_bin
size_t
end_bin
)
;
void
ApplyPostFilter
(
const
complex_f
*
input
complex_f
*
output
)
;
void
EstimateTargetPresence
(
)
;
static
const
size_t
kFftSize
=
256
;
static
const
size_t
kNumFreqBins
=
kFftSize
/
2
+
1
;
size_t
chunk_length_
;
std
:
:
unique_ptr
<
LappedTransform
>
process_transform_
;
std
:
:
unique_ptr
<
PostFilterTransform
>
postfilter_transform_
;
float
window_
[
kFftSize
]
;
const
size_t
num_input_channels_
;
const
size_t
num_postfilter_channels_
;
int
sample_rate_hz_
;
const
std
:
:
vector
<
Point
>
array_geometry_
;
const
rtc
:
:
Optional
<
Point
>
array_normal_
;
const
float
min_mic_spacing_
;
size_t
low_mean_start_bin_
;
size_t
low_mean_end_bin_
;
size_t
high_mean_start_bin_
;
size_t
high_mean_end_bin_
;
float
new_mask_
[
kNumFreqBins
]
;
float
time_smooth_mask_
[
kNumFreqBins
]
;
float
final_mask_
[
kNumFreqBins
]
;
float
target_angle_radians_
;
std
:
:
vector
<
float
>
interf_angles_radians_
;
const
float
away_radians_
;
ComplexMatrixF
delay_sum_masks_
[
kNumFreqBins
]
;
ComplexMatrixF
target_cov_mats_
[
kNumFreqBins
]
;
ComplexMatrixF
uniform_cov_mat_
[
kNumFreqBins
]
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ComplexMatrixF
>
>
interf_cov_mats_
[
kNumFreqBins
]
;
float
wave_numbers_
[
kNumFreqBins
]
;
float
rxiws_
[
kNumFreqBins
]
;
std
:
:
vector
<
float
>
rpsiws_
[
kNumFreqBins
]
;
ComplexMatrixF
eig_m_
;
float
high_pass_postfilter_mask_
;
float
old_high_pass_mask_
;
bool
is_target_present_
;
size_t
hold_target_blocks_
;
size_t
interference_blocks_count_
;
}
;
}
#
endif
