#
include
"
modules
/
audio_processing
/
test
/
fake_recording_device
.
h
"
#
include
<
algorithm
>
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
ptr_util
.
h
"
namespace
webrtc
{
namespace
test
{
namespace
{
constexpr
int16_t
kInt16SampleMin
=
-
32768
;
constexpr
int16_t
kInt16SampleMax
=
32767
;
constexpr
float
kFloatSampleMin
=
-
32768
.
f
;
constexpr
float
kFloatSampleMax
=
32767
.
0f
;
}
class
FakeRecordingDeviceWorker
{
public
:
explicit
FakeRecordingDeviceWorker
(
const
int
initial_mic_level
)
:
mic_level_
(
initial_mic_level
)
{
}
int
mic_level
(
)
const
{
return
mic_level_
;
}
void
set_mic_level
(
const
int
level
)
{
mic_level_
=
level
;
}
void
set_undo_mic_level
(
const
int
level
)
{
undo_mic_level_
=
level
;
}
virtual
~
FakeRecordingDeviceWorker
(
)
=
default
;
virtual
void
ModifyBufferInt16
(
AudioFrame
*
buffer
)
=
0
;
virtual
void
ModifyBufferFloat
(
ChannelBuffer
<
float
>
*
buffer
)
=
0
;
protected
:
int
mic_level_
;
rtc
:
:
Optional
<
int
>
undo_mic_level_
;
}
;
namespace
{
class
FakeRecordingDeviceIdentity
final
:
public
FakeRecordingDeviceWorker
{
public
:
explicit
FakeRecordingDeviceIdentity
(
const
int
initial_mic_level
)
:
FakeRecordingDeviceWorker
(
initial_mic_level
)
{
}
~
FakeRecordingDeviceIdentity
(
)
override
=
default
;
void
ModifyBufferInt16
(
AudioFrame
*
buffer
)
override
{
}
void
ModifyBufferFloat
(
ChannelBuffer
<
float
>
*
buffer
)
override
{
}
}
;
class
FakeRecordingDeviceLinear
final
:
public
FakeRecordingDeviceWorker
{
public
:
explicit
FakeRecordingDeviceLinear
(
const
int
initial_mic_level
)
:
FakeRecordingDeviceWorker
(
initial_mic_level
)
{
}
~
FakeRecordingDeviceLinear
(
)
override
=
default
;
void
ModifyBufferInt16
(
AudioFrame
*
buffer
)
override
{
const
size_t
number_of_samples
=
buffer
-
>
samples_per_channel_
*
buffer
-
>
num_channels_
;
int16_t
*
data
=
buffer
-
>
mutable_data
(
)
;
const
float
divisor
=
(
undo_mic_level_
&
&
*
undo_mic_level_
>
0
)
?
*
undo_mic_level_
:
255
.
f
;
for
(
size_t
i
=
0
;
i
<
number_of_samples
;
+
+
i
)
{
data
[
i
]
=
std
:
:
max
(
kInt16SampleMin
std
:
:
min
(
kInt16SampleMax
static_cast
<
int16_t
>
(
static_cast
<
float
>
(
data
[
i
]
)
*
mic_level_
/
divisor
)
)
)
;
}
}
void
ModifyBufferFloat
(
ChannelBuffer
<
float
>
*
buffer
)
override
{
const
float
divisor
=
(
undo_mic_level_
&
&
*
undo_mic_level_
>
0
)
?
*
undo_mic_level_
:
255
.
f
;
for
(
size_t
c
=
0
;
c
<
buffer
-
>
num_channels
(
)
;
+
+
c
)
{
for
(
size_t
i
=
0
;
i
<
buffer
-
>
num_frames
(
)
;
+
+
i
)
{
buffer
-
>
channels
(
)
[
c
]
[
i
]
=
std
:
:
max
(
kFloatSampleMin
std
:
:
min
(
kFloatSampleMax
buffer
-
>
channels
(
)
[
c
]
[
i
]
*
mic_level_
/
divisor
)
)
;
}
}
}
}
;
}
FakeRecordingDevice
:
:
FakeRecordingDevice
(
int
initial_mic_level
int
device_kind
)
{
switch
(
device_kind
)
{
case
0
:
worker_
=
rtc
:
:
MakeUnique
<
FakeRecordingDeviceIdentity
>
(
initial_mic_level
)
;
break
;
case
1
:
worker_
=
rtc
:
:
MakeUnique
<
FakeRecordingDeviceLinear
>
(
initial_mic_level
)
;
break
;
default
:
RTC_NOTREACHED
(
)
;
break
;
}
}
FakeRecordingDevice
:
:
~
FakeRecordingDevice
(
)
=
default
;
int
FakeRecordingDevice
:
:
MicLevel
(
)
const
{
RTC_CHECK
(
worker_
)
;
return
worker_
-
>
mic_level
(
)
;
}
void
FakeRecordingDevice
:
:
SetMicLevel
(
const
int
level
)
{
RTC_CHECK
(
worker_
)
;
if
(
level
!
=
worker_
-
>
mic_level
(
)
)
RTC_LOG
(
LS_INFO
)
<
<
"
Simulate
mic
level
update
:
"
<
<
level
;
worker_
-
>
set_mic_level
(
level
)
;
}
void
FakeRecordingDevice
:
:
SetUndoMicLevel
(
const
int
level
)
{
RTC_DCHECK
(
worker_
)
;
RTC_CHECK
(
level
>
0
)
<
<
"
Zero
undo
mic
level
is
unsupported
"
;
worker_
-
>
set_undo_mic_level
(
level
)
;
}
void
FakeRecordingDevice
:
:
SimulateAnalogGain
(
AudioFrame
*
buffer
)
{
RTC_DCHECK
(
worker_
)
;
worker_
-
>
ModifyBufferInt16
(
buffer
)
;
}
void
FakeRecordingDevice
:
:
SimulateAnalogGain
(
ChannelBuffer
<
float
>
*
buffer
)
{
RTC_DCHECK
(
worker_
)
;
worker_
-
>
ModifyBufferFloat
(
buffer
)
;
}
}
}
