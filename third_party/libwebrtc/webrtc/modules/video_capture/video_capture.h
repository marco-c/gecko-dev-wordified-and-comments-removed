#
ifndef
MODULES_VIDEO_CAPTURE_VIDEO_CAPTURE_H_
#
define
MODULES_VIDEO_CAPTURE_VIDEO_CAPTURE_H_
#
include
"
modules
/
audio_processing
/
include
/
config
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
media
/
base
/
videosinkinterface
.
h
"
#
include
"
modules
/
include
/
module
.
h
"
#
include
"
modules
/
video_capture
/
video_capture_defines
.
h
"
#
include
<
set
>
#
if
defined
(
ANDROID
)
#
include
<
jni
.
h
>
#
endif
namespace
webrtc
{
enum
class
CaptureDeviceType
{
Camera
Screen
Window
Browser
}
;
struct
CaptureDeviceInfo
{
CaptureDeviceType
type
;
CaptureDeviceInfo
(
)
:
type
(
CaptureDeviceType
:
:
Camera
)
{
}
CaptureDeviceInfo
(
CaptureDeviceType
t
)
:
type
(
t
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kCaptureDeviceInfo
;
const
char
*
TypeName
(
)
const
{
switch
(
type
)
{
case
CaptureDeviceType
:
:
Camera
:
{
return
"
Camera
"
;
}
case
CaptureDeviceType
:
:
Screen
:
{
return
"
Screen
"
;
}
case
CaptureDeviceType
:
:
Window
:
{
return
"
Window
"
;
}
case
CaptureDeviceType
:
:
Browser
:
{
return
"
Browser
"
;
}
}
assert
(
false
)
;
return
"
UNKOWN
-
CaptureDeviceType
!
"
;
}
}
;
class
VideoInputFeedBack
{
public
:
virtual
void
OnDeviceChange
(
)
=
0
;
protected
:
virtual
~
VideoInputFeedBack
(
)
{
}
}
;
#
if
defined
(
ANDROID
)
&
&
!
defined
(
WEBRTC_CHROMIUM_BUILD
)
int32_t
SetCaptureAndroidVM
(
JavaVM
*
javaVM
)
;
#
endif
class
VideoCaptureModule
:
public
rtc
:
:
RefCountInterface
{
public
:
class
DeviceInfo
{
public
:
virtual
uint32_t
NumberOfDevices
(
)
=
0
;
virtual
int32_t
Refresh
(
)
=
0
;
virtual
void
DeviceChange
(
)
{
for
(
auto
inputCallBack
:
_inputCallBacks
)
{
inputCallBack
-
>
OnDeviceChange
(
)
;
}
}
virtual
void
RegisterVideoInputFeedBack
(
VideoInputFeedBack
*
callBack
)
{
_inputCallBacks
.
insert
(
callBack
)
;
}
virtual
void
DeRegisterVideoInputFeedBack
(
VideoInputFeedBack
*
callBack
)
{
auto
it
=
_inputCallBacks
.
find
(
callBack
)
;
if
(
it
!
=
_inputCallBacks
.
end
(
)
)
{
_inputCallBacks
.
erase
(
it
)
;
}
}
virtual
int32_t
GetDeviceName
(
uint32_t
deviceNumber
char
*
deviceNameUTF8
uint32_t
deviceNameSize
char
*
deviceUniqueIdUTF8
uint32_t
deviceUniqueIdUTF8Size
char
*
productUniqueIdUTF8
=
0
uint32_t
productUniqueIdUTF8Size
=
0
pid_t
*
pid
=
0
)
=
0
;
virtual
int32_t
NumberOfCapabilities
(
const
char
*
deviceUniqueIdUTF8
)
=
0
;
virtual
int32_t
GetCapability
(
const
char
*
deviceUniqueIdUTF8
const
uint32_t
deviceCapabilityNumber
VideoCaptureCapability
&
capability
)
=
0
;
virtual
int32_t
GetOrientation
(
const
char
*
deviceUniqueIdUTF8
VideoRotation
&
orientation
)
=
0
;
virtual
int32_t
GetBestMatchedCapability
(
const
char
*
deviceUniqueIdUTF8
const
VideoCaptureCapability
&
requested
VideoCaptureCapability
&
resulting
)
=
0
;
virtual
int32_t
DisplayCaptureSettingsDialogBox
(
const
char
*
deviceUniqueIdUTF8
const
char
*
dialogTitleUTF8
void
*
parentWindow
uint32_t
positionX
uint32_t
positionY
)
=
0
;
virtual
~
DeviceInfo
(
)
{
}
private
:
std
:
:
set
<
VideoInputFeedBack
*
>
_inputCallBacks
;
}
;
virtual
void
RegisterCaptureDataCallback
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
dataCallback
)
=
0
;
virtual
void
DeRegisterCaptureDataCallback
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
dataCallback
)
=
0
;
virtual
int32_t
StartCapture
(
const
VideoCaptureCapability
&
capability
)
=
0
;
virtual
int32_t
StopCaptureIfAllClientsClose
(
)
=
0
;
virtual
bool
FocusOnSelectedSource
(
)
{
return
false
;
}
;
virtual
int32_t
StopCapture
(
)
=
0
;
virtual
const
char
*
CurrentDeviceName
(
)
const
=
0
;
virtual
bool
CaptureStarted
(
)
=
0
;
virtual
int32_t
CaptureSettings
(
VideoCaptureCapability
&
settings
)
=
0
;
virtual
int32_t
SetCaptureRotation
(
VideoRotation
rotation
)
=
0
;
virtual
bool
SetApplyRotation
(
bool
enable
)
=
0
;
virtual
bool
GetApplyRotation
(
)
=
0
;
protected
:
virtual
~
VideoCaptureModule
(
)
{
}
;
}
;
}
#
endif
