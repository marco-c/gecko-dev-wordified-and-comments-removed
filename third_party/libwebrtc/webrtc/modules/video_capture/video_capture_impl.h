#
ifndef
MODULES_VIDEO_CAPTURE_MAIN_SOURCE_VIDEO_CAPTURE_IMPL_H_
#
define
MODULES_VIDEO_CAPTURE_MAIN_SOURCE_VIDEO_CAPTURE_IMPL_H_
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
modules
/
video_capture
/
video_capture
.
h
"
#
include
"
modules
/
video_capture
/
video_capture_config
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
namespace
webrtc
{
namespace
videocapturemodule
{
class
VideoCaptureImpl
:
public
VideoCaptureModule
public
VideoCaptureExternal
{
public
:
static
rtc
:
:
scoped_refptr
<
VideoCaptureModule
>
Create
(
const
char
*
deviceUniqueIdUTF8
)
;
static
rtc
:
:
scoped_refptr
<
VideoCaptureModule
>
Create
(
VideoCaptureExternal
*
&
externalCapture
)
;
static
DeviceInfo
*
CreateDeviceInfo
(
)
;
static
int32_t
RotationFromDegrees
(
int
degrees
VideoRotation
*
rotation
)
;
static
int32_t
RotationInDegrees
(
VideoRotation
rotation
int
*
degrees
)
;
void
RegisterCaptureDataCallback
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
dataCallback
)
override
;
void
DeRegisterCaptureDataCallback
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
dataCallback
)
override
;
int32_t
StopCaptureIfAllClientsClose
(
)
override
;
int32_t
SetCaptureRotation
(
VideoRotation
rotation
)
override
;
bool
SetApplyRotation
(
bool
enable
)
override
;
bool
GetApplyRotation
(
)
override
{
return
apply_rotation_
;
}
const
char
*
CurrentDeviceName
(
)
const
override
;
int32_t
IncomingFrame
(
uint8_t
*
videoFrame
size_t
videoFrameLength
const
VideoCaptureCapability
&
frameInfo
int64_t
captureTime
=
0
)
override
;
int32_t
StartCapture
(
const
VideoCaptureCapability
&
capability
)
override
{
_requestedCapability
=
capability
;
return
-
1
;
}
int32_t
StopCapture
(
)
override
{
return
-
1
;
}
bool
CaptureStarted
(
)
override
{
return
false
;
}
int32_t
CaptureSettings
(
VideoCaptureCapability
&
)
override
{
return
-
1
;
}
protected
:
VideoCaptureImpl
(
)
;
virtual
~
VideoCaptureImpl
(
)
;
int32_t
DeliverCapturedFrame
(
VideoFrame
&
captureFrame
)
;
char
*
_deviceUniqueId
;
rtc
:
:
CriticalSection
_apiCs
;
VideoCaptureCapability
_requestedCapability
;
private
:
void
UpdateFrameCount
(
)
;
uint32_t
CalculateFrameRate
(
int64_t
now_ns
)
;
int64_t
_lastProcessTimeNanos
;
int64_t
_lastFrameRateCallbackTimeNanos
;
std
:
:
set
<
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
>
_dataCallBacks
;
int64_t
_lastProcessFrameTimeNanos
;
int64_t
_incomingFrameTimesNanos
[
kFrameRateCountHistorySize
]
;
VideoRotation
_rotateFrame
;
bool
apply_rotation_
;
}
;
}
}
#
endif
