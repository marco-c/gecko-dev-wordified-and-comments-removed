#
ifndef
MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_INTERNAL_H_
#
define
MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_INTERNAL_H_
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
constexpr
size_t
kUlpfecMaxMediaPackets
=
48
;
constexpr
size_t
kUlpfecPacketMaskSizeLBitClear
=
2
;
constexpr
size_t
kUlpfecPacketMaskSizeLBitSet
=
6
;
constexpr
size_t
kUlpfecMinPacketMaskSize
=
kUlpfecPacketMaskSizeLBitClear
;
constexpr
size_t
kUlpfecMaxPacketMaskSize
=
kUlpfecPacketMaskSizeLBitSet
;
namespace
internal
{
class
PacketMaskTable
{
public
:
PacketMaskTable
(
FecMaskType
fec_mask_type
int
num_media_packets
)
;
~
PacketMaskTable
(
)
{
}
FecMaskType
fec_mask_type
(
)
const
{
return
fec_mask_type_
;
}
const
uint8_t
*
const
*
const
*
fec_packet_mask_table
(
)
const
{
return
fec_packet_mask_table_
;
}
private
:
FecMaskType
InitMaskType
(
FecMaskType
fec_mask_type
int
num_media_packets
)
;
const
uint8_t
*
const
*
const
*
InitMaskTable
(
FecMaskType
fec_mask_type_
)
;
const
FecMaskType
fec_mask_type_
;
const
uint8_t
*
const
*
const
*
fec_packet_mask_table_
;
}
;
void
GeneratePacketMasks
(
int
num_media_packets
int
num_fec_packets
int
num_imp_packets
bool
use_unequal_protection
const
PacketMaskTable
&
mask_table
uint8_t
*
packet_mask
)
;
size_t
PacketMaskSize
(
size_t
num_sequence_numbers
)
;
void
InsertZeroColumns
(
int
num_zeros
uint8_t
*
new_mask
int
new_mask_bytes
int
num_fec_packets
int
new_bit_index
)
;
void
CopyColumn
(
uint8_t
*
new_mask
int
new_mask_bytes
uint8_t
*
old_mask
int
old_mask_bytes
int
num_fec_packets
int
new_bit_index
int
old_bit_index
)
;
}
}
#
endif
