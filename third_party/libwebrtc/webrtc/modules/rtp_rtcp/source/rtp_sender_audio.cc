#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_sender_audio
.
h
"
#
include
<
string
.
h
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_header_extensions
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
namespace
webrtc
{
RTPSenderAudio
:
:
RTPSenderAudio
(
Clock
*
clock
RTPSender
*
rtp_sender
)
:
clock_
(
clock
)
rtp_sender_
(
rtp_sender
)
{
}
RTPSenderAudio
:
:
~
RTPSenderAudio
(
)
{
}
int32_t
RTPSenderAudio
:
:
RegisterAudioPayload
(
const
char
payloadName
[
RTP_PAYLOAD_NAME_SIZE
]
const
int8_t
payload_type
const
uint32_t
frequency
const
size_t
channels
const
uint32_t
rate
RtpUtility
:
:
Payload
*
*
payload
)
{
if
(
RtpUtility
:
:
StringCompare
(
payloadName
"
cn
"
2
)
)
{
rtc
:
:
CritScope
cs
(
&
send_audio_critsect_
)
;
switch
(
frequency
)
{
case
8000
:
cngnb_payload_type_
=
payload_type
;
break
;
case
16000
:
cngwb_payload_type_
=
payload_type
;
break
;
case
32000
:
cngswb_payload_type_
=
payload_type
;
break
;
case
48000
:
cngfb_payload_type_
=
payload_type
;
break
;
default
:
return
-
1
;
}
}
else
if
(
RtpUtility
:
:
StringCompare
(
payloadName
"
telephone
-
event
"
15
)
)
{
rtc
:
:
CritScope
cs
(
&
send_audio_critsect_
)
;
dtmf_payload_type_
=
payload_type
;
dtmf_payload_freq_
=
frequency
;
return
0
;
}
*
payload
=
new
RtpUtility
:
:
Payload
(
payloadName
PayloadUnion
(
AudioPayload
{
SdpAudioFormat
(
payloadName
frequency
channels
)
rate
}
)
)
;
return
0
;
}
bool
RTPSenderAudio
:
:
MarkerBit
(
FrameType
frame_type
int8_t
payload_type
)
{
rtc
:
:
CritScope
cs
(
&
send_audio_critsect_
)
;
bool
marker_bit
=
false
;
if
(
last_payload_type_
!
=
payload_type
)
{
if
(
payload_type
!
=
-
1
&
&
(
cngnb_payload_type_
=
=
payload_type
|
|
cngwb_payload_type_
=
=
payload_type
|
|
cngswb_payload_type_
=
=
payload_type
|
|
cngfb_payload_type_
=
=
payload_type
)
)
{
return
false
;
}
if
(
last_payload_type_
=
=
-
1
)
{
if
(
frame_type
!
=
kAudioFrameCN
)
{
return
true
;
}
else
{
inband_vad_active_
=
true
;
return
false
;
}
}
marker_bit
=
true
;
}
if
(
frame_type
=
=
kAudioFrameCN
)
{
inband_vad_active_
=
true
;
}
else
if
(
inband_vad_active_
)
{
inband_vad_active_
=
false
;
marker_bit
=
true
;
}
return
marker_bit
;
}
bool
RTPSenderAudio
:
:
SendAudio
(
FrameType
frame_type
int8_t
payload_type
uint32_t
rtp_timestamp
const
uint8_t
*
payload_data
size_t
payload_size
const
StreamId
*
mId
)
{
constexpr
int
kDtmfIntervalTimeMs
=
50
;
uint8_t
audio_level_dbov
=
0
;
uint32_t
dtmf_payload_freq
=
0
;
{
rtc
:
:
CritScope
cs
(
&
send_audio_critsect_
)
;
audio_level_dbov
=
audio_level_dbov_
;
dtmf_payload_freq
=
dtmf_payload_freq_
;
}
if
(
!
dtmf_event_is_on_
&
&
dtmf_queue_
.
PendingDtmf
(
)
)
{
if
(
(
clock_
-
>
TimeInMilliseconds
(
)
-
dtmf_time_last_sent_
)
>
kDtmfIntervalTimeMs
)
{
dtmf_timestamp_
=
rtp_timestamp
;
if
(
dtmf_queue_
.
NextDtmf
(
&
dtmf_current_event_
)
)
{
dtmf_event_first_packet_sent_
=
false
;
dtmf_length_samples_
=
dtmf_current_event_
.
duration_ms
*
(
dtmf_payload_freq
/
1000
)
;
dtmf_event_is_on_
=
true
;
}
}
}
if
(
dtmf_event_is_on_
)
{
if
(
frame_type
=
=
kEmptyFrame
)
{
const
unsigned
int
dtmf_interval_time_rtp
=
dtmf_payload_freq
*
kDtmfIntervalTimeMs
/
1000
;
if
(
(
rtp_timestamp
-
dtmf_timestamp_last_sent_
)
<
dtmf_interval_time_rtp
)
{
return
true
;
}
}
dtmf_timestamp_last_sent_
=
rtp_timestamp
;
uint32_t
dtmf_duration_samples
=
rtp_timestamp
-
dtmf_timestamp_
;
bool
ended
=
false
;
bool
send
=
true
;
if
(
dtmf_length_samples_
>
dtmf_duration_samples
)
{
if
(
dtmf_duration_samples
<
=
0
)
{
send
=
false
;
}
}
else
{
ended
=
true
;
dtmf_event_is_on_
=
false
;
dtmf_time_last_sent_
=
clock_
-
>
TimeInMilliseconds
(
)
;
}
if
(
send
)
{
if
(
dtmf_duration_samples
>
0xffff
)
{
SendTelephoneEventPacket
(
ended
dtmf_timestamp_
static_cast
<
uint16_t
>
(
0xffff
)
false
)
;
dtmf_timestamp_
=
rtp_timestamp
;
dtmf_duration_samples
-
=
0xffff
;
dtmf_length_samples_
-
=
0xffff
;
return
SendTelephoneEventPacket
(
ended
dtmf_timestamp_
static_cast
<
uint16_t
>
(
dtmf_duration_samples
)
false
)
;
}
else
{
if
(
!
SendTelephoneEventPacket
(
ended
dtmf_timestamp_
dtmf_duration_samples
!
dtmf_event_first_packet_sent_
)
)
{
return
false
;
}
dtmf_event_first_packet_sent_
=
true
;
return
true
;
}
}
return
true
;
}
if
(
payload_size
=
=
0
|
|
payload_data
=
=
NULL
)
{
if
(
frame_type
=
=
kEmptyFrame
)
{
return
true
;
}
return
false
;
}
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
=
rtp_sender_
-
>
AllocatePacket
(
)
;
packet
-
>
SetMarker
(
MarkerBit
(
frame_type
payload_type
)
)
;
packet
-
>
SetPayloadType
(
payload_type
)
;
packet
-
>
SetTimestamp
(
rtp_timestamp
)
;
packet
-
>
set_capture_time_ms
(
clock_
-
>
TimeInMilliseconds
(
)
)
;
packet
-
>
SetExtension
<
AudioLevel
>
(
frame_type
=
=
kAudioFrameSpeech
audio_level_dbov
)
;
if
(
mId
&
&
!
mId
-
>
empty
(
)
)
{
packet
-
>
SetExtension
<
RtpMid
>
(
*
mId
)
;
}
uint8_t
*
payload
=
packet
-
>
AllocatePayload
(
payload_size
)
;
if
(
!
payload
)
return
false
;
memcpy
(
payload
payload_data
payload_size
)
;
if
(
!
rtp_sender_
-
>
AssignSequenceNumber
(
packet
.
get
(
)
)
)
return
false
;
{
rtc
:
:
CritScope
cs
(
&
send_audio_critsect_
)
;
last_payload_type_
=
payload_type
;
}
TRACE_EVENT_ASYNC_END2
(
"
webrtc
"
"
Audio
"
rtp_timestamp
"
timestamp
"
packet
-
>
Timestamp
(
)
"
seqnum
"
packet
-
>
SequenceNumber
(
)
)
;
bool
send_result
=
rtp_sender_
-
>
SendToNetwork
(
std
:
:
move
(
packet
)
kAllowRetransmission
RtpPacketSender
:
:
kHighPriority
)
;
if
(
first_packet_sent_
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
First
audio
RTP
packet
sent
to
pacer
"
;
}
return
send_result
;
}
int32_t
RTPSenderAudio
:
:
SetAudioLevel
(
uint8_t
level_dbov
)
{
if
(
level_dbov
>
127
)
{
return
-
1
;
}
rtc
:
:
CritScope
cs
(
&
send_audio_critsect_
)
;
audio_level_dbov_
=
level_dbov
;
return
0
;
}
int32_t
RTPSenderAudio
:
:
SendTelephoneEvent
(
uint8_t
key
uint16_t
time_ms
uint8_t
level
)
{
DtmfQueue
:
:
Event
event
;
{
rtc
:
:
CritScope
lock
(
&
send_audio_critsect_
)
;
if
(
dtmf_payload_type_
<
0
)
{
return
-
1
;
}
event
.
payload_type
=
dtmf_payload_type_
;
}
event
.
key
=
key
;
event
.
duration_ms
=
time_ms
;
event
.
level
=
level
;
return
dtmf_queue_
.
AddDtmf
(
event
)
?
0
:
-
1
;
}
bool
RTPSenderAudio
:
:
SendTelephoneEventPacket
(
bool
ended
uint32_t
dtmf_timestamp
uint16_t
duration
bool
marker_bit
)
{
uint8_t
send_count
=
1
;
bool
result
=
true
;
if
(
ended
)
{
send_count
=
3
;
}
do
{
constexpr
RtpPacketToSend
:
:
ExtensionManager
*
kNoExtensions
=
nullptr
;
constexpr
size_t
kDtmfSize
=
4
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
(
new
RtpPacketToSend
(
kNoExtensions
kRtpHeaderSize
+
kDtmfSize
)
)
;
packet
-
>
SetPayloadType
(
dtmf_current_event_
.
payload_type
)
;
packet
-
>
SetMarker
(
marker_bit
)
;
packet
-
>
SetSsrc
(
rtp_sender_
-
>
SSRC
(
)
)
;
packet
-
>
SetTimestamp
(
dtmf_timestamp
)
;
packet
-
>
set_capture_time_ms
(
clock_
-
>
TimeInMilliseconds
(
)
)
;
if
(
!
rtp_sender_
-
>
AssignSequenceNumber
(
packet
.
get
(
)
)
)
return
false
;
uint8_t
*
dtmfbuffer
=
packet
-
>
AllocatePayload
(
kDtmfSize
)
;
RTC_DCHECK
(
dtmfbuffer
)
;
uint8_t
R
=
0x00
;
uint8_t
volume
=
dtmf_current_event_
.
level
;
uint8_t
E
=
ended
?
0x80
:
0x00
;
dtmfbuffer
[
0
]
=
dtmf_current_event_
.
key
;
dtmfbuffer
[
1
]
=
E
|
R
|
volume
;
ByteWriter
<
uint16_t
>
:
:
WriteBigEndian
(
dtmfbuffer
+
2
duration
)
;
TRACE_EVENT_INSTANT2
(
TRACE_DISABLED_BY_DEFAULT
(
"
webrtc_rtp
"
)
"
Audio
:
:
SendTelephoneEvent
"
"
timestamp
"
packet
-
>
Timestamp
(
)
"
seqnum
"
packet
-
>
SequenceNumber
(
)
)
;
result
=
rtp_sender_
-
>
SendToNetwork
(
std
:
:
move
(
packet
)
kAllowRetransmission
RtpPacketSender
:
:
kHighPriority
)
;
send_count
-
-
;
}
while
(
send_count
>
0
&
&
result
)
;
return
result
;
}
}
