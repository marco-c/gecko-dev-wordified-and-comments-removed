#
ifndef
MODULES_MEDIA_FILE_MEDIA_FILE_UTILITY_H_
#
define
MODULES_MEDIA_FILE_MEDIA_FILE_UTILITY_H_
#
include
<
stdio
.
h
>
#
include
"
common_types
.
h
"
#
include
"
modules
/
media_file
/
media_file_defines
.
h
"
namespace
webrtc
{
class
InStream
;
class
OutStream
;
class
ModuleFileUtility
{
public
:
ModuleFileUtility
(
)
;
~
ModuleFileUtility
(
)
;
int32_t
InitWavReading
(
InStream
&
stream
const
uint32_t
startPointMs
=
0
const
uint32_t
stopPointMs
=
0
)
;
int32_t
ReadWavDataAsMono
(
InStream
&
stream
int8_t
*
audioBuffer
const
size_t
dataLengthInBytes
)
;
int32_t
ReadWavDataAsStereo
(
InStream
&
wav
int8_t
*
audioBufferLeft
int8_t
*
audioBufferRight
const
size_t
bufferLength
)
;
int32_t
InitWavWriting
(
OutStream
&
stream
const
CodecInst
&
codecInst
)
;
int32_t
WriteWavData
(
OutStream
&
stream
const
int8_t
*
audioBuffer
const
size_t
bufferLength
)
;
int32_t
UpdateWavHeader
(
OutStream
&
stream
)
;
int32_t
InitPCMReading
(
InStream
&
stream
const
uint32_t
startPointMs
=
0
const
uint32_t
stopPointMs
=
0
const
uint32_t
freqInHz
=
16000
)
;
int32_t
ReadPCMData
(
InStream
&
stream
int8_t
*
audioBuffer
const
size_t
dataLengthInBytes
)
;
int32_t
InitPCMWriting
(
OutStream
&
stream
const
uint32_t
freqInHz
=
16000
)
;
int32_t
WritePCMData
(
OutStream
&
stream
const
int8_t
*
audioBuffer
size_t
bufferLength
)
;
int32_t
InitCompressedReading
(
InStream
&
stream
const
uint32_t
startPointMs
=
0
const
uint32_t
stopPointMs
=
0
)
;
int32_t
ReadCompressedData
(
InStream
&
stream
int8_t
*
audioBuffer
const
size_t
dataLengthInBytes
)
;
int32_t
InitCompressedWriting
(
OutStream
&
stream
const
CodecInst
&
codecInst
)
;
int32_t
WriteCompressedData
(
OutStream
&
stream
const
int8_t
*
audioBuffer
const
size_t
bufferLength
)
;
int32_t
InitPreEncodedReading
(
InStream
&
stream
const
CodecInst
&
codecInst
)
;
int32_t
ReadPreEncodedData
(
InStream
&
stream
int8_t
*
audioBuffer
const
size_t
dataLengthInBytes
)
;
int32_t
InitPreEncodedWriting
(
OutStream
&
stream
const
CodecInst
&
codecInst
)
;
int32_t
WritePreEncodedData
(
OutStream
&
stream
const
int8_t
*
inData
const
size_t
dataLengthInBytes
)
;
int32_t
FileDurationMs
(
const
char
*
fileName
const
FileFormats
fileFormat
const
uint32_t
freqInHz
=
16000
)
;
uint32_t
PlayoutPositionMs
(
)
;
int32_t
codec_info
(
CodecInst
&
codecInst
)
;
private
:
static
const
size_t
WAV_MAX_BUFFER_SIZE
=
480
*
2
*
2
;
int32_t
InitWavCodec
(
uint32_t
samplesPerSec
size_t
channels
uint32_t
bitsPerSample
uint32_t
formatTag
)
;
int32_t
ReadWavHeader
(
InStream
&
stream
)
;
int32_t
WriteWavHeader
(
OutStream
&
stream
uint32_t
freqInHz
size_t
bytesPerSample
size_t
channels
uint32_t
format
size_t
lengthInBytes
)
;
int32_t
ReadWavData
(
InStream
&
stream
uint8_t
*
audioBuffer
size_t
dataLengthInBytes
)
;
int32_t
set_codec_info
(
const
CodecInst
&
codecInst
)
;
struct
WAVE_FMTINFO_header
{
int16_t
formatTag
;
int16_t
nChannels
;
int32_t
nSamplesPerSec
;
int32_t
nAvgBytesPerSec
;
int16_t
nBlockAlign
;
int16_t
nBitsPerSample
;
}
;
enum
MediaFileUtility_CodecType
{
kCodecNoCodec
=
0
kCodecIsac
kCodecIsacSwb
kCodecIsacLc
kCodecL16_8Khz
kCodecL16_16kHz
kCodecL16_32Khz
kCodecL16_48Khz
kCodecPcmu
kCodecPcma
kCodecIlbc20Ms
kCodecIlbc30Ms
kCodecG722
kCodecG722_1_32Kbps
kCodecG722_1_24Kbps
kCodecG722_1_16Kbps
kCodecG722_1c_48
kCodecG722_1c_32
kCodecG722_1c_24
kCodecAmr
kCodecAmrWb
kCodecG729
kCodecG729_1
kCodecG726_40
kCodecG726_32
kCodecG726_24
kCodecG726_16
}
;
WAVE_FMTINFO_header
_wavFormatObj
;
size_t
_dataSize
;
size_t
_readSizeBytes
;
uint32_t
_stopPointInMs
;
uint32_t
_startPointInMs
;
uint32_t
_playoutPositionMs
;
size_t
_bytesWritten
;
CodecInst
codec_info_
;
MediaFileUtility_CodecType
_codecId
;
size_t
_bytesPerSample
;
size_t
_readPos
;
bool
_reading
;
bool
_writing
;
uint8_t
_tempData
[
WAV_MAX_BUFFER_SIZE
]
;
}
;
}
#
endif
