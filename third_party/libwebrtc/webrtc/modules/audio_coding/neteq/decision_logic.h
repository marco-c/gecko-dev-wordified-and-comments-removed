#
ifndef
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_
#
define
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_
#
include
"
modules
/
audio_coding
/
neteq
/
defines
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
include
/
neteq
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tick_timer
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
class
BufferLevelFilter
;
class
DecoderDatabase
;
class
DelayManager
;
class
Expand
;
class
PacketBuffer
;
class
SyncBuffer
;
struct
Packet
;
class
DecisionLogic
{
public
:
static
DecisionLogic
*
Create
(
int
fs_hz
size_t
output_size_samples
NetEqPlayoutMode
playout_mode
DecoderDatabase
*
decoder_database
const
PacketBuffer
&
packet_buffer
DelayManager
*
delay_manager
BufferLevelFilter
*
buffer_level_filter
const
TickTimer
*
tick_timer
)
;
DecisionLogic
(
int
fs_hz
size_t
output_size_samples
NetEqPlayoutMode
playout_mode
DecoderDatabase
*
decoder_database
const
PacketBuffer
&
packet_buffer
DelayManager
*
delay_manager
BufferLevelFilter
*
buffer_level_filter
const
TickTimer
*
tick_timer
)
;
virtual
~
DecisionLogic
(
)
;
void
Reset
(
)
;
void
SoftReset
(
)
;
void
SetSampleRate
(
int
fs_hz
size_t
output_size_samples
)
;
Operations
GetDecision
(
const
SyncBuffer
&
sync_buffer
const
Expand
&
expand
size_t
decoder_frame_length
const
Packet
*
next_packet
Modes
prev_mode
bool
play_dtmf
size_t
generated_noise_samples
bool
*
reset_decoder
)
;
bool
CngRfc3389On
(
)
const
{
return
cng_state_
=
=
kCngRfc3389On
;
}
bool
CngOff
(
)
const
{
return
cng_state_
=
=
kCngOff
;
}
void
SetCngOff
(
)
{
cng_state_
=
kCngOff
;
}
virtual
void
ExpandDecision
(
Operations
operation
)
;
void
AddSampleMemory
(
int32_t
value
)
{
sample_memory_
+
=
value
;
}
void
set_sample_memory
(
int32_t
value
)
{
sample_memory_
=
value
;
}
size_t
noise_fast_forward
(
)
const
{
return
noise_fast_forward_
;
}
size_t
packet_length_samples
(
)
const
{
return
packet_length_samples_
;
}
void
set_packet_length_samples
(
size_t
value
)
{
packet_length_samples_
=
value
;
}
void
set_prev_time_scale
(
bool
value
)
{
prev_time_scale_
=
value
;
}
NetEqPlayoutMode
playout_mode
(
)
const
{
return
playout_mode_
;
}
protected
:
static
const
int
kMinTimescaleInterval
=
5
;
enum
CngState
{
kCngOff
kCngRfc3389On
kCngInternalOn
}
;
virtual
Operations
GetDecisionSpecialized
(
const
SyncBuffer
&
sync_buffer
const
Expand
&
expand
size_t
decoder_frame_length
const
Packet
*
next_packet
Modes
prev_mode
bool
play_dtmf
bool
*
reset_decoder
size_t
generated_noise_samples
)
=
0
;
void
FilterBufferLevel
(
size_t
buffer_size_packets
Modes
prev_mode
)
;
DecoderDatabase
*
decoder_database_
;
const
PacketBuffer
&
packet_buffer_
;
DelayManager
*
delay_manager_
;
BufferLevelFilter
*
buffer_level_filter_
;
const
TickTimer
*
tick_timer_
;
int
fs_mult_
;
size_t
output_size_samples_
;
CngState
cng_state_
;
size_t
noise_fast_forward_
=
0
;
size_t
packet_length_samples_
;
int
sample_memory_
;
bool
prev_time_scale_
;
std
:
:
unique_ptr
<
TickTimer
:
:
Countdown
>
timescale_countdown_
;
int
num_consecutive_expands_
;
const
NetEqPlayoutMode
playout_mode_
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
DecisionLogic
)
;
}
;
}
#
endif
