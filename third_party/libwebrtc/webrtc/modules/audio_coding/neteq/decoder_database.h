#
ifndef
MODULES_AUDIO_CODING_NETEQ_DECODER_DATABASE_H_
#
define
MODULES_AUDIO_CODING_NETEQ_DECODER_DATABASE_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
api
/
audio_codecs
/
audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
cng
/
webrtc_cng
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
neteq_decoder_enum
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
packet
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
class
DecoderDatabase
{
public
:
enum
DatabaseReturnCodes
{
kOK
=
0
kInvalidRtpPayloadType
=
-
1
kCodecNotSupported
=
-
2
kInvalidSampleRate
=
-
3
kDecoderExists
=
-
4
kDecoderNotFound
=
-
5
kInvalidPointer
=
-
6
}
;
class
DecoderInfo
{
public
:
DecoderInfo
(
const
SdpAudioFormat
&
audio_format
AudioDecoderFactory
*
factory
const
std
:
:
string
&
codec_name
)
;
explicit
DecoderInfo
(
const
SdpAudioFormat
&
audio_format
AudioDecoderFactory
*
factory
=
nullptr
)
;
explicit
DecoderInfo
(
NetEqDecoder
ct
AudioDecoderFactory
*
factory
=
nullptr
)
;
DecoderInfo
(
const
SdpAudioFormat
&
audio_format
AudioDecoder
*
ext_dec
const
std
:
:
string
&
codec_name
)
;
DecoderInfo
(
DecoderInfo
&
&
)
;
~
DecoderInfo
(
)
;
bool
CanGetDecoder
(
)
const
;
AudioDecoder
*
GetDecoder
(
)
const
;
void
DropDecoder
(
)
const
{
decoder_
.
reset
(
)
;
}
int
SampleRateHz
(
)
const
{
if
(
IsDtmf
(
)
)
{
return
audio_format_
.
clockrate_hz
;
}
const
AudioDecoder
*
decoder
=
GetDecoder
(
)
;
RTC_DCHECK_EQ
(
1
!
!
decoder
+
!
!
cng_decoder_
)
;
return
decoder
?
decoder
-
>
SampleRateHz
(
)
:
cng_decoder_
-
>
sample_rate_hz
;
}
const
SdpAudioFormat
&
GetFormat
(
)
const
{
return
audio_format_
;
}
bool
IsComfortNoise
(
)
const
{
RTC_DCHECK_EQ
(
!
!
cng_decoder_
subtype_
=
=
Subtype
:
:
kComfortNoise
)
;
return
subtype_
=
=
Subtype
:
:
kComfortNoise
;
}
bool
IsDtmf
(
)
const
{
return
subtype_
=
=
Subtype
:
:
kDtmf
;
}
bool
IsRed
(
)
const
{
return
subtype_
=
=
Subtype
:
:
kRed
;
}
bool
IsType
(
const
char
*
name
)
const
;
bool
IsType
(
const
std
:
:
string
&
name
)
const
;
const
std
:
:
string
&
get_name
(
)
const
{
return
name_
;
}
private
:
const
std
:
:
string
name_
;
const
SdpAudioFormat
audio_format_
;
AudioDecoderFactory
*
const
factory_
;
mutable
std
:
:
unique_ptr
<
AudioDecoder
>
decoder_
;
AudioDecoder
*
const
external_decoder_
;
struct
CngDecoder
{
static
rtc
:
:
Optional
<
CngDecoder
>
Create
(
const
SdpAudioFormat
&
format
)
;
int
sample_rate_hz
;
}
;
const
rtc
:
:
Optional
<
CngDecoder
>
cng_decoder_
;
enum
class
Subtype
:
int8_t
{
kNormal
kComfortNoise
kDtmf
kRed
}
;
static
Subtype
SubtypeFromFormat
(
const
SdpAudioFormat
&
format
)
;
const
Subtype
subtype_
;
}
;
static
const
uint8_t
kRtpPayloadTypeError
=
0xFF
;
DecoderDatabase
(
const
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
&
decoder_factory
)
;
virtual
~
DecoderDatabase
(
)
;
virtual
bool
Empty
(
)
const
;
virtual
int
Size
(
)
const
;
virtual
void
Reset
(
)
;
virtual
std
:
:
vector
<
int
>
SetCodecs
(
const
std
:
:
map
<
int
SdpAudioFormat
>
&
codecs
)
;
virtual
int
RegisterPayload
(
uint8_t
rtp_payload_type
NetEqDecoder
codec_type
const
std
:
:
string
&
name
)
;
virtual
int
RegisterPayload
(
int
rtp_payload_type
const
SdpAudioFormat
&
audio_format
)
;
virtual
int
InsertExternal
(
uint8_t
rtp_payload_type
NetEqDecoder
codec_type
const
std
:
:
string
&
codec_name
AudioDecoder
*
decoder
)
;
virtual
int
Remove
(
uint8_t
rtp_payload_type
)
;
virtual
void
RemoveAll
(
)
;
virtual
const
DecoderInfo
*
GetDecoderInfo
(
uint8_t
rtp_payload_type
)
const
;
virtual
int
SetActiveDecoder
(
uint8_t
rtp_payload_type
bool
*
new_decoder
)
;
virtual
AudioDecoder
*
GetActiveDecoder
(
)
const
;
virtual
int
SetActiveCngDecoder
(
uint8_t
rtp_payload_type
)
;
virtual
ComfortNoiseDecoder
*
GetActiveCngDecoder
(
)
const
;
AudioDecoder
*
GetDecoder
(
uint8_t
rtp_payload_type
)
const
;
bool
IsType
(
uint8_t
rtp_payload_type
const
char
*
name
)
const
;
bool
IsType
(
uint8_t
rtp_payload_type
const
std
:
:
string
&
name
)
const
;
bool
IsComfortNoise
(
uint8_t
rtp_payload_type
)
const
;
bool
IsDtmf
(
uint8_t
rtp_payload_type
)
const
;
bool
IsRed
(
uint8_t
rtp_payload_type
)
const
;
int
CheckPayloadTypes
(
const
PacketList
&
packet_list
)
const
;
private
:
typedef
std
:
:
map
<
uint8_t
DecoderInfo
>
DecoderMap
;
DecoderMap
decoders_
;
int
active_decoder_type_
;
int
active_cng_decoder_type_
;
mutable
std
:
:
unique_ptr
<
ComfortNoiseDecoder
>
active_cng_decoder_
;
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
DecoderDatabase
)
;
}
;
}
#
endif
