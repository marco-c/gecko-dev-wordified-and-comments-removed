#
include
"
modules
/
audio_coding
/
neteq
/
include
/
neteq
.
h
"
#
include
<
math
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
pcm16b
/
pcm16b
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
audio_loop
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
rtp_file_source
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
rtc_base
/
flags
.
h
"
#
include
"
rtc_base
/
ignore_wundef
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
protobuf_utils
.
h
"
#
include
"
rtc_base
/
sha1digest
.
h
"
#
include
"
rtc_base
/
stringencode
.
h
"
#
include
"
test
/
field_trial
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
testsupport
/
fileutils
.
h
"
#
include
"
typedefs
.
h
"
#
ifdef
WEBRTC_NETEQ_UNITTEST_BITEXACT
RTC_PUSH_IGNORING_WUNDEF
(
)
#
ifdef
WEBRTC_ANDROID_PLATFORM_BUILD
#
include
"
external
/
webrtc
/
webrtc
/
modules
/
audio_coding
/
neteq
/
neteq_unittest
.
pb
.
h
"
#
else
#
include
"
modules
/
audio_coding
/
neteq
/
neteq_unittest
.
pb
.
h
"
#
endif
RTC_POP_IGNORING_WUNDEF
(
)
#
endif
DEFINE_bool
(
gen_ref
false
"
Generate
reference
files
.
"
)
;
namespace
webrtc
{
namespace
{
const
std
:
:
string
&
PlatformChecksum
(
const
std
:
:
string
&
checksum_general
const
std
:
:
string
&
checksum_android_32
const
std
:
:
string
&
checksum_android_64
const
std
:
:
string
&
checksum_win_32
const
std
:
:
string
&
checksum_win_64
)
{
#
if
defined
(
WEBRTC_ANDROID
)
#
ifdef
WEBRTC_ARCH_64_BITS
return
checksum_android_64
;
#
else
return
checksum_android_32
;
#
endif
#
elif
defined
(
WEBRTC_WIN
)
#
ifdef
WEBRTC_ARCH_64_BITS
return
checksum_win_64
;
#
else
return
checksum_win_32
;
#
endif
#
else
return
checksum_general
;
#
endif
}
#
ifdef
WEBRTC_NETEQ_UNITTEST_BITEXACT
void
Convert
(
const
webrtc
:
:
NetEqNetworkStatistics
&
stats_raw
webrtc
:
:
neteq_unittest
:
:
NetEqNetworkStatistics
*
stats
)
{
stats
-
>
set_current_buffer_size_ms
(
stats_raw
.
current_buffer_size_ms
)
;
stats
-
>
set_preferred_buffer_size_ms
(
stats_raw
.
preferred_buffer_size_ms
)
;
stats
-
>
set_jitter_peaks_found
(
stats_raw
.
jitter_peaks_found
)
;
stats
-
>
set_packet_loss_rate
(
stats_raw
.
packet_loss_rate
)
;
stats
-
>
set_expand_rate
(
stats_raw
.
expand_rate
)
;
stats
-
>
set_speech_expand_rate
(
stats_raw
.
speech_expand_rate
)
;
stats
-
>
set_preemptive_rate
(
stats_raw
.
preemptive_rate
)
;
stats
-
>
set_accelerate_rate
(
stats_raw
.
accelerate_rate
)
;
stats
-
>
set_secondary_decoded_rate
(
stats_raw
.
secondary_decoded_rate
)
;
stats
-
>
set_secondary_discarded_rate
(
stats_raw
.
secondary_discarded_rate
)
;
stats
-
>
set_clockdrift_ppm
(
stats_raw
.
clockdrift_ppm
)
;
stats
-
>
set_added_zero_samples
(
stats_raw
.
added_zero_samples
)
;
stats
-
>
set_mean_waiting_time_ms
(
stats_raw
.
mean_waiting_time_ms
)
;
stats
-
>
set_median_waiting_time_ms
(
stats_raw
.
median_waiting_time_ms
)
;
stats
-
>
set_min_waiting_time_ms
(
stats_raw
.
min_waiting_time_ms
)
;
stats
-
>
set_max_waiting_time_ms
(
stats_raw
.
max_waiting_time_ms
)
;
}
void
Convert
(
const
webrtc
:
:
RtcpStatistics
&
stats_raw
webrtc
:
:
neteq_unittest
:
:
RtcpStatistics
*
stats
)
{
stats
-
>
set_fraction_lost
(
stats_raw
.
fraction_lost
)
;
stats
-
>
set_cumulative_lost
(
stats_raw
.
packets_lost
)
;
stats
-
>
set_extended_max_sequence_number
(
stats_raw
.
extended_highest_sequence_number
)
;
stats
-
>
set_jitter
(
stats_raw
.
jitter
)
;
}
void
AddMessage
(
FILE
*
file
rtc
:
:
MessageDigest
*
digest
const
std
:
:
string
&
message
)
{
int32_t
size
=
message
.
length
(
)
;
if
(
file
)
ASSERT_EQ
(
1u
fwrite
(
&
size
sizeof
(
size
)
1
file
)
)
;
digest
-
>
Update
(
&
size
sizeof
(
size
)
)
;
if
(
file
)
ASSERT_EQ
(
static_cast
<
size_t
>
(
size
)
fwrite
(
message
.
data
(
)
sizeof
(
char
)
size
file
)
)
;
digest
-
>
Update
(
message
.
data
(
)
sizeof
(
char
)
*
size
)
;
}
#
endif
void
LoadDecoders
(
webrtc
:
:
NetEq
*
neteq
)
{
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
0
SdpAudioFormat
(
"
pcmu
"
8000
1
)
)
)
;
ASSERT_EQ
(
0
neteq
-
>
RegisterPayloadType
(
webrtc
:
:
NetEqDecoder
:
:
kDecoderPCMa
"
pcma
"
8
)
)
;
#
ifdef
WEBRTC_CODEC_ILBC
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
102
SdpAudioFormat
(
"
ilbc
"
8000
1
)
)
)
;
#
endif
#
if
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
103
SdpAudioFormat
(
"
isac
"
16000
1
)
)
)
;
#
endif
#
ifdef
WEBRTC_CODEC_ISAC
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
104
SdpAudioFormat
(
"
isac
"
32000
1
)
)
)
;
#
endif
#
ifdef
WEBRTC_CODEC_OPUS
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
111
SdpAudioFormat
(
"
opus
"
48000
2
{
{
"
stereo
"
"
0
"
}
}
)
)
)
;
#
endif
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
93
SdpAudioFormat
(
"
L16
"
8000
1
)
)
)
;
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
94
SdpAudioFormat
(
"
L16
"
16000
1
)
)
)
;
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
95
SdpAudioFormat
(
"
L16
"
32000
1
)
)
)
;
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
13
SdpAudioFormat
(
"
cn
"
8000
1
)
)
)
;
ASSERT_EQ
(
true
neteq
-
>
RegisterPayloadType
(
98
SdpAudioFormat
(
"
cn
"
16000
1
)
)
)
;
}
}
class
ResultSink
{
public
:
explicit
ResultSink
(
const
std
:
:
string
&
output_file
)
;
~
ResultSink
(
)
;
template
<
typename
T
>
void
AddResult
(
const
T
*
test_results
size_t
length
)
;
void
AddResult
(
const
NetEqNetworkStatistics
&
stats
)
;
void
AddResult
(
const
RtcpStatistics
&
stats
)
;
void
VerifyChecksum
(
const
std
:
:
string
&
ref_check_sum
)
;
private
:
FILE
*
output_fp_
;
std
:
:
unique_ptr
<
rtc
:
:
MessageDigest
>
digest_
;
}
;
ResultSink
:
:
ResultSink
(
const
std
:
:
string
&
output_file
)
:
output_fp_
(
nullptr
)
digest_
(
new
rtc
:
:
Sha1Digest
(
)
)
{
if
(
!
output_file
.
empty
(
)
)
{
output_fp_
=
fopen
(
output_file
.
c_str
(
)
"
wb
"
)
;
EXPECT_TRUE
(
output_fp_
!
=
NULL
)
;
}
}
ResultSink
:
:
~
ResultSink
(
)
{
if
(
output_fp_
)
fclose
(
output_fp_
)
;
}
template
<
typename
T
>
void
ResultSink
:
:
AddResult
(
const
T
*
test_results
size_t
length
)
{
if
(
output_fp_
)
{
ASSERT_EQ
(
length
fwrite
(
test_results
sizeof
(
T
)
length
output_fp_
)
)
;
}
digest_
-
>
Update
(
test_results
sizeof
(
T
)
*
length
)
;
}
void
ResultSink
:
:
AddResult
(
const
NetEqNetworkStatistics
&
stats_raw
)
{
#
ifdef
WEBRTC_NETEQ_UNITTEST_BITEXACT
neteq_unittest
:
:
NetEqNetworkStatistics
stats
;
Convert
(
stats_raw
&
stats
)
;
ProtoString
stats_string
;
ASSERT_TRUE
(
stats
.
SerializeToString
(
&
stats_string
)
)
;
AddMessage
(
output_fp_
digest_
.
get
(
)
stats_string
)
;
#
else
FAIL
(
)
<
<
"
Writing
to
reference
file
requires
Proto
Buffer
.
"
;
#
endif
}
void
ResultSink
:
:
AddResult
(
const
RtcpStatistics
&
stats_raw
)
{
#
ifdef
WEBRTC_NETEQ_UNITTEST_BITEXACT
neteq_unittest
:
:
RtcpStatistics
stats
;
Convert
(
stats_raw
&
stats
)
;
ProtoString
stats_string
;
ASSERT_TRUE
(
stats
.
SerializeToString
(
&
stats_string
)
)
;
AddMessage
(
output_fp_
digest_
.
get
(
)
stats_string
)
;
#
else
FAIL
(
)
<
<
"
Writing
to
reference
file
requires
Proto
Buffer
.
"
;
#
endif
}
void
ResultSink
:
:
VerifyChecksum
(
const
std
:
:
string
&
checksum
)
{
std
:
:
vector
<
char
>
buffer
;
buffer
.
resize
(
digest_
-
>
Size
(
)
)
;
digest_
-
>
Finish
(
&
buffer
[
0
]
buffer
.
size
(
)
)
;
const
std
:
:
string
result
=
rtc
:
:
hex_encode
(
&
buffer
[
0
]
digest_
-
>
Size
(
)
)
;
EXPECT_EQ
(
checksum
result
)
;
}
class
NetEqDecodingTest
:
public
:
:
testing
:
:
Test
{
protected
:
static
const
int
kTimeStepMs
=
10
;
static
const
size_t
kBlockSize8kHz
=
kTimeStepMs
*
8
;
static
const
size_t
kBlockSize16kHz
=
kTimeStepMs
*
16
;
static
const
size_t
kBlockSize32kHz
=
kTimeStepMs
*
32
;
static
const
size_t
kBlockSize48kHz
=
kTimeStepMs
*
48
;
static
const
int
kInitSampleRateHz
=
8000
;
NetEqDecodingTest
(
)
;
virtual
void
SetUp
(
)
;
virtual
void
TearDown
(
)
;
void
SelectDecoders
(
NetEqDecoder
*
used_codec
)
;
void
OpenInputFile
(
const
std
:
:
string
&
rtp_file
)
;
void
Process
(
)
;
void
DecodeAndCompare
(
const
std
:
:
string
&
rtp_file
const
std
:
:
string
&
output_checksum
const
std
:
:
string
&
network_stats_checksum
const
std
:
:
string
&
rtcp_stats_checksum
bool
gen_ref
)
;
static
void
PopulateRtpInfo
(
int
frame_index
int
timestamp
RTPHeader
*
rtp_info
)
;
static
void
PopulateCng
(
int
frame_index
int
timestamp
RTPHeader
*
rtp_info
uint8_t
*
payload
size_t
*
payload_len
)
;
void
WrapTest
(
uint16_t
start_seq_no
uint32_t
start_timestamp
const
std
:
:
set
<
uint16_t
>
&
drop_seq_numbers
bool
expect_seq_no_wrap
bool
expect_timestamp_wrap
)
;
void
LongCngWithClockDrift
(
double
drift_factor
double
network_freeze_ms
bool
pull_audio_during_freeze
int
delay_tolerance_ms
int
max_time_to_speech_ms
)
;
void
DuplicateCng
(
)
;
NetEq
*
neteq_
;
NetEq
:
:
Config
config_
;
std
:
:
unique_ptr
<
test
:
:
RtpFileSource
>
rtp_source_
;
std
:
:
unique_ptr
<
test
:
:
Packet
>
packet_
;
unsigned
int
sim_clock_
;
AudioFrame
out_frame_
;
int
output_sample_rate_
;
int
algorithmic_delay_ms_
;
}
;
const
int
NetEqDecodingTest
:
:
kTimeStepMs
;
const
size_t
NetEqDecodingTest
:
:
kBlockSize8kHz
;
const
size_t
NetEqDecodingTest
:
:
kBlockSize16kHz
;
const
size_t
NetEqDecodingTest
:
:
kBlockSize32kHz
;
const
int
NetEqDecodingTest
:
:
kInitSampleRateHz
;
NetEqDecodingTest
:
:
NetEqDecodingTest
(
)
:
neteq_
(
NULL
)
config_
(
)
sim_clock_
(
0
)
output_sample_rate_
(
kInitSampleRateHz
)
algorithmic_delay_ms_
(
0
)
{
config_
.
sample_rate_hz
=
kInitSampleRateHz
;
}
void
NetEqDecodingTest
:
:
SetUp
(
)
{
neteq_
=
NetEq
:
:
Create
(
config_
CreateBuiltinAudioDecoderFactory
(
)
)
;
NetEqNetworkStatistics
stat
;
ASSERT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
stat
)
)
;
algorithmic_delay_ms_
=
stat
.
current_buffer_size_ms
;
ASSERT_TRUE
(
neteq_
)
;
LoadDecoders
(
neteq_
)
;
}
void
NetEqDecodingTest
:
:
TearDown
(
)
{
delete
neteq_
;
}
void
NetEqDecodingTest
:
:
OpenInputFile
(
const
std
:
:
string
&
rtp_file
)
{
rtp_source_
.
reset
(
test
:
:
RtpFileSource
:
:
Create
(
rtp_file
)
)
;
}
void
NetEqDecodingTest
:
:
Process
(
)
{
while
(
packet_
&
&
sim_clock_
>
=
packet_
-
>
time_ms
(
)
)
{
if
(
packet_
-
>
payload_length_bytes
(
)
>
0
)
{
#
ifndef
WEBRTC_CODEC_ISAC
if
(
packet_
-
>
header
(
)
.
payloadType
!
=
104
)
#
endif
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
packet_
-
>
header
(
)
rtc
:
:
ArrayView
<
const
uint8_t
>
(
packet_
-
>
payload
(
)
packet_
-
>
payload_length_bytes
(
)
)
static_cast
<
uint32_t
>
(
packet_
-
>
time_ms
(
)
*
(
output_sample_rate_
/
1000
)
)
)
)
;
}
packet_
=
rtp_source_
-
>
NextPacket
(
)
;
}
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
ASSERT_TRUE
(
(
out_frame_
.
samples_per_channel_
=
=
kBlockSize8kHz
)
|
|
(
out_frame_
.
samples_per_channel_
=
=
kBlockSize16kHz
)
|
|
(
out_frame_
.
samples_per_channel_
=
=
kBlockSize32kHz
)
|
|
(
out_frame_
.
samples_per_channel_
=
=
kBlockSize48kHz
)
)
;
output_sample_rate_
=
out_frame_
.
sample_rate_hz_
;
EXPECT_EQ
(
output_sample_rate_
neteq_
-
>
last_output_sample_rate_hz
(
)
)
;
sim_clock_
+
=
kTimeStepMs
;
}
void
NetEqDecodingTest
:
:
DecodeAndCompare
(
const
std
:
:
string
&
rtp_file
const
std
:
:
string
&
output_checksum
const
std
:
:
string
&
network_stats_checksum
const
std
:
:
string
&
rtcp_stats_checksum
bool
gen_ref
)
{
OpenInputFile
(
rtp_file
)
;
std
:
:
string
ref_out_file
=
gen_ref
?
webrtc
:
:
test
:
:
OutputPath
(
)
+
"
neteq_universal_ref
.
pcm
"
:
"
"
;
ResultSink
output
(
ref_out_file
)
;
std
:
:
string
stat_out_file
=
gen_ref
?
webrtc
:
:
test
:
:
OutputPath
(
)
+
"
neteq_network_stats
.
dat
"
:
"
"
;
ResultSink
network_stats
(
stat_out_file
)
;
std
:
:
string
rtcp_out_file
=
gen_ref
?
webrtc
:
:
test
:
:
OutputPath
(
)
+
"
neteq_rtcp_stats
.
dat
"
:
"
"
;
ResultSink
rtcp_stats
(
rtcp_out_file
)
;
packet_
=
rtp_source_
-
>
NextPacket
(
)
;
int
i
=
0
;
uint64_t
last_concealed_samples
=
0
;
uint64_t
last_total_samples_received
=
0
;
while
(
packet_
)
{
std
:
:
ostringstream
ss
;
ss
<
<
"
Lap
number
"
<
<
i
+
+
<
<
"
in
DecodeAndCompare
while
loop
"
;
SCOPED_TRACE
(
ss
.
str
(
)
)
;
ASSERT_NO_FATAL_FAILURE
(
Process
(
)
)
;
ASSERT_NO_FATAL_FAILURE
(
output
.
AddResult
(
out_frame_
.
data
(
)
out_frame_
.
samples_per_channel_
)
)
;
if
(
sim_clock_
%
1000
=
=
0
)
{
NetEqNetworkStatistics
current_network_stats
;
ASSERT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
current_network_stats
)
)
;
ASSERT_NO_FATAL_FAILURE
(
network_stats
.
AddResult
(
current_network_stats
)
)
;
EXPECT_EQ
(
current_network_stats
.
current_buffer_size_ms
neteq_
-
>
CurrentDelayMs
(
)
)
;
auto
lifetime_stats
=
neteq_
-
>
GetLifetimeStatistics
(
)
;
const
uint64_t
delta_concealed_samples
=
lifetime_stats
.
concealed_samples
-
last_concealed_samples
;
last_concealed_samples
=
lifetime_stats
.
concealed_samples
;
const
uint64_t
delta_total_samples_received
=
lifetime_stats
.
total_samples_received
-
last_total_samples_received
;
last_total_samples_received
=
lifetime_stats
.
total_samples_received
;
EXPECT_NEAR
(
(
delta_concealed_samples
<
<
14
)
/
delta_total_samples_received
current_network_stats
.
expand_rate
(
2
<
<
14
)
/
100
.
0
)
;
RtcpStatistics
current_rtcp_stats
;
neteq_
-
>
GetRtcpStatistics
(
&
current_rtcp_stats
)
;
ASSERT_NO_FATAL_FAILURE
(
rtcp_stats
.
AddResult
(
current_rtcp_stats
)
)
;
}
}
SCOPED_TRACE
(
"
Check
output
audio
.
"
)
;
output
.
VerifyChecksum
(
output_checksum
)
;
SCOPED_TRACE
(
"
Check
network
stats
.
"
)
;
network_stats
.
VerifyChecksum
(
network_stats_checksum
)
;
SCOPED_TRACE
(
"
Check
rtcp
stats
.
"
)
;
rtcp_stats
.
VerifyChecksum
(
rtcp_stats_checksum
)
;
}
void
NetEqDecodingTest
:
:
PopulateRtpInfo
(
int
frame_index
int
timestamp
RTPHeader
*
rtp_info
)
{
rtp_info
-
>
sequenceNumber
=
frame_index
;
rtp_info
-
>
timestamp
=
timestamp
;
rtp_info
-
>
ssrc
=
0x1234
;
rtp_info
-
>
payloadType
=
94
;
rtp_info
-
>
markerBit
=
0
;
}
void
NetEqDecodingTest
:
:
PopulateCng
(
int
frame_index
int
timestamp
RTPHeader
*
rtp_info
uint8_t
*
payload
size_t
*
payload_len
)
{
rtp_info
-
>
sequenceNumber
=
frame_index
;
rtp_info
-
>
timestamp
=
timestamp
;
rtp_info
-
>
ssrc
=
0x1234
;
rtp_info
-
>
payloadType
=
98
;
rtp_info
-
>
markerBit
=
0
;
payload
[
0
]
=
64
;
*
payload_len
=
1
;
}
#
if
!
defined
(
WEBRTC_IOS
)
&
&
defined
(
WEBRTC_NETEQ_UNITTEST_BITEXACT
)
&
&
\
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
&
&
\
defined
(
WEBRTC_CODEC_ILBC
)
&
&
!
defined
(
WEBRTC_ARCH_ARM64
)
#
define
MAYBE_TestBitExactness
TestBitExactness
#
else
#
define
MAYBE_TestBitExactness
DISABLED_TestBitExactness
#
endif
TEST_F
(
NetEqDecodingTest
MAYBE_TestBitExactness
)
{
const
std
:
:
string
input_rtp_file
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
neteq_universal_new
"
"
rtp
"
)
;
const
std
:
:
string
output_checksum
=
PlatformChecksum
(
"
09fa7646e2ad032a0b156177b95f09012430f81f
"
"
1c64eb8b55ce8878676c6a1e6ddd78f48de0668b
"
"
not
used
"
"
09fa7646e2ad032a0b156177b95f09012430f81f
"
"
759fef89a5de52bd17e733dc255c671ce86be909
"
)
;
const
std
:
:
string
network_stats_checksum
=
PlatformChecksum
(
"
5b4262ca328e5f066af5d34f3380521583dd20de
"
"
80235b6d727281203acb63b98f9a9e85d95f7ec0
"
"
not
used
"
"
5b4262ca328e5f066af5d34f3380521583dd20de
"
"
5b4262ca328e5f066af5d34f3380521583dd20de
"
)
;
const
std
:
:
string
rtcp_stats_checksum
=
PlatformChecksum
(
"
b8880bf9fed2487efbddcb8d94b9937a29ae521d
"
"
f3f7b3d3e71d7e635240b5373b57df6a7e4ce9d4
"
"
not
used
"
"
b8880bf9fed2487efbddcb8d94b9937a29ae521d
"
"
b8880bf9fed2487efbddcb8d94b9937a29ae521d
"
)
;
DecodeAndCompare
(
input_rtp_file
output_checksum
network_stats_checksum
rtcp_stats_checksum
FLAG_gen_ref
)
;
}
#
if
!
defined
(
WEBRTC_IOS
)
&
&
\
defined
(
WEBRTC_NETEQ_UNITTEST_BITEXACT
)
&
&
\
defined
(
WEBRTC_CODEC_OPUS
)
#
define
MAYBE_TestOpusBitExactness
TestOpusBitExactness
#
else
#
define
MAYBE_TestOpusBitExactness
DISABLED_TestOpusBitExactness
#
endif
TEST_F
(
NetEqDecodingTest
MAYBE_TestOpusBitExactness
)
{
const
std
:
:
string
input_rtp_file
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
neteq_opus
"
"
rtp
"
)
;
const
std
:
:
string
output_checksum
=
PlatformChecksum
(
"
7ea28d7edf9395f4ac8e8d8dd3a9e5c620b1bf48
"
"
5b1e691ab1c4465c742d6d944bc71e3b1c0e4c0e
"
"
b096114dd8c233eaf2b0ce9802ac95af13933772
"
"
7ea28d7edf9395f4ac8e8d8dd3a9e5c620b1bf48
"
"
7ea28d7edf9395f4ac8e8d8dd3a9e5c620b1bf48
"
)
;
const
std
:
:
string
network_stats_checksum
=
PlatformChecksum
(
"
9e72233c78baf685e500dd6c94212b30a4c5f27d
"
"
9a37270e4242fbd31e80bb47dc5e7ab82cf2d557
"
"
4f1e9734bc80a290faaf9d611efcb8d7802dbc4f
"
"
9e72233c78baf685e500dd6c94212b30a4c5f27d
"
"
9e72233c78baf685e500dd6c94212b30a4c5f27d
"
)
;
const
std
:
:
string
rtcp_stats_checksum
=
PlatformChecksum
(
"
e37c797e3de6a64dda88c9ade7a013d022a2e1e0
"
"
e37c797e3de6a64dda88c9ade7a013d022a2e1e0
"
"
e37c797e3de6a64dda88c9ade7a013d022a2e1e0
"
"
e37c797e3de6a64dda88c9ade7a013d022a2e1e0
"
"
e37c797e3de6a64dda88c9ade7a013d022a2e1e0
"
)
;
DecodeAndCompare
(
input_rtp_file
output_checksum
network_stats_checksum
rtcp_stats_checksum
FLAG_gen_ref
)
;
}
class
NetEqDecodingTestWithOpusDtxFieldTrial
:
public
NetEqDecodingTest
{
public
:
NetEqDecodingTestWithOpusDtxFieldTrial
(
)
:
override_field_trials_
(
"
WebRTC
-
NetEqOpusDtxDelayFix
/
Enabled
/
"
)
{
}
private
:
test
:
:
ScopedFieldTrials
override_field_trials_
;
}
;
#
if
!
defined
(
WEBRTC_IOS
)
&
&
\
defined
(
WEBRTC_NETEQ_UNITTEST_BITEXACT
)
&
&
\
defined
(
WEBRTC_CODEC_OPUS
)
#
define
MAYBE_TestOpusDtxBitExactness
TestOpusDtxBitExactness
#
else
#
define
MAYBE_TestOpusDtxBitExactness
DISABLED_TestOpusDtxBitExactness
#
endif
TEST_F
(
NetEqDecodingTestWithOpusDtxFieldTrial
MAYBE_TestOpusDtxBitExactness
)
{
const
std
:
:
string
input_rtp_file
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
neteq_opus_dtx
"
"
rtp
"
)
;
const
std
:
:
string
output_checksum
=
PlatformChecksum
(
"
713af6c92881f5aab1285765ee6680da9d1c06ce
"
"
3ec991b96872123f1554c03c543ca5d518431e46
"
"
da9f9a2d94e0c2d67342fad4965d7b91cda50b25
"
"
713af6c92881f5aab1285765ee6680da9d1c06ce
"
"
713af6c92881f5aab1285765ee6680da9d1c06ce
"
)
;
const
std
:
:
string
network_stats_checksum
=
"
bab58dc587d956f326056d7340c96eb9d2d3cc21
"
;
const
std
:
:
string
rtcp_stats_checksum
=
"
ac27a7f305efb58b39bf123dccee25dee5758e63
"
;
DecodeAndCompare
(
input_rtp_file
output_checksum
network_stats_checksum
rtcp_stats_checksum
FLAG_gen_ref
)
;
}
class
NetEqDecodingTestFaxMode
:
public
NetEqDecodingTest
{
protected
:
NetEqDecodingTestFaxMode
(
)
:
NetEqDecodingTest
(
)
{
config_
.
playout_mode
=
kPlayoutFax
;
}
void
TestJitterBufferDelay
(
bool
apply_packet_loss
)
;
}
;
TEST_F
(
NetEqDecodingTestFaxMode
TestFrameWaitingTimeStatistics
)
{
size_t
num_frames
=
30
;
const
size_t
kSamples
=
10
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
const
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
rtp_info
.
sequenceNumber
=
rtc
:
:
checked_cast
<
uint16_t
>
(
i
)
;
rtp_info
.
timestamp
=
rtc
:
:
checked_cast
<
uint32_t
>
(
i
*
kSamples
)
;
rtp_info
.
ssrc
=
0x1234
;
rtp_info
.
payloadType
=
94
;
rtp_info
.
markerBit
=
0
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
}
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
NetEqNetworkStatistics
stats
;
EXPECT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
stats
)
)
;
EXPECT_EQ
(
155
stats
.
mean_waiting_time_ms
)
;
EXPECT_EQ
(
155
stats
.
median_waiting_time_ms
)
;
EXPECT_EQ
(
10
stats
.
min_waiting_time_ms
)
;
EXPECT_EQ
(
300
stats
.
max_waiting_time_ms
)
;
EXPECT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
stats
)
)
;
EXPECT_EQ
(
-
1
stats
.
mean_waiting_time_ms
)
;
EXPECT_EQ
(
-
1
stats
.
median_waiting_time_ms
)
;
EXPECT_EQ
(
-
1
stats
.
min_waiting_time_ms
)
;
EXPECT_EQ
(
-
1
stats
.
max_waiting_time_ms
)
;
}
TEST_F
(
NetEqDecodingTest
TestAverageInterArrivalTimeNegative
)
{
const
int
kNumFrames
=
3000
;
int
frame_index
=
0
;
const
size_t
kSamples
=
10
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
while
(
frame_index
<
kNumFrames
)
{
int
num_packets
=
(
frame_index
%
10
=
=
0
?
2
:
1
)
;
for
(
int
n
=
0
;
n
<
num_packets
;
+
+
n
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
frame_index
frame_index
*
kSamples
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
+
+
frame_index
;
}
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
NetEqNetworkStatistics
network_stats
;
ASSERT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
network_stats
)
)
;
EXPECT_EQ
(
-
103192
network_stats
.
clockdrift_ppm
)
;
}
TEST_F
(
NetEqDecodingTest
TestAverageInterArrivalTimePositive
)
{
const
int
kNumFrames
=
5000
;
int
frame_index
=
0
;
const
size_t
kSamples
=
10
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
for
(
int
i
=
0
;
i
<
kNumFrames
;
+
+
i
)
{
int
num_packets
=
(
i
%
10
=
=
9
?
0
:
1
)
;
for
(
int
n
=
0
;
n
<
num_packets
;
+
+
n
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
frame_index
frame_index
*
kSamples
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
+
+
frame_index
;
}
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
NetEqNetworkStatistics
network_stats
;
ASSERT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
network_stats
)
)
;
EXPECT_EQ
(
110953
network_stats
.
clockdrift_ppm
)
;
}
void
NetEqDecodingTest
:
:
LongCngWithClockDrift
(
double
drift_factor
double
network_freeze_ms
bool
pull_audio_during_freeze
int
delay_tolerance_ms
int
max_time_to_speech_ms
)
{
uint16_t
seq_no
=
0
;
uint32_t
timestamp
=
0
;
const
int
kFrameSizeMs
=
30
;
const
size_t
kSamples
=
kFrameSizeMs
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
double
next_input_time_ms
=
0
.
0
;
double
t_ms
;
bool
muted
;
const
int
kSpeechDurationMs
=
5000
;
for
(
t_ms
=
0
;
t_ms
<
kSpeechDurationMs
;
t_ms
+
=
10
)
{
while
(
next_input_time_ms
<
=
t_ms
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
seq_no
timestamp
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kSamples
;
next_input_time_ms
+
=
static_cast
<
double
>
(
kFrameSizeMs
)
*
drift_factor
;
}
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
EXPECT_EQ
(
AudioFrame
:
:
kNormalSpeech
out_frame_
.
speech_type_
)
;
rtc
:
:
Optional
<
uint32_t
>
playout_timestamp
=
neteq_
-
>
GetPlayoutTimestamp
(
)
;
ASSERT_TRUE
(
playout_timestamp
)
;
int32_t
delay_before
=
timestamp
-
*
playout_timestamp
;
const
int
kCngPeriodMs
=
100
;
const
int
kCngPeriodSamples
=
kCngPeriodMs
*
16
;
const
int
kCngDurationMs
=
60000
;
for
(
;
t_ms
<
kSpeechDurationMs
+
kCngDurationMs
;
t_ms
+
=
10
)
{
while
(
next_input_time_ms
<
=
t_ms
)
{
uint8_t
payload
[
kPayloadBytes
]
;
size_t
payload_len
;
RTPHeader
rtp_info
;
PopulateCng
(
seq_no
timestamp
&
rtp_info
payload
&
payload_len
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
payload_len
)
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kCngPeriodSamples
;
next_input_time_ms
+
=
static_cast
<
double
>
(
kCngPeriodMs
)
*
drift_factor
;
}
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
if
(
network_freeze_ms
>
0
)
{
const
double
loop_end_time
=
t_ms
+
network_freeze_ms
;
for
(
;
t_ms
<
loop_end_time
;
t_ms
+
=
10
)
{
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
}
bool
pull_once
=
pull_audio_during_freeze
;
double
pull_time_ms
=
(
t_ms
+
next_input_time_ms
)
/
2
;
while
(
next_input_time_ms
<
=
t_ms
)
{
if
(
pull_once
&
&
next_input_time_ms
>
=
pull_time_ms
)
{
pull_once
=
false
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
t_ms
+
=
10
;
}
uint8_t
payload
[
kPayloadBytes
]
;
size_t
payload_len
;
RTPHeader
rtp_info
;
PopulateCng
(
seq_no
timestamp
&
rtp_info
payload
&
payload_len
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
payload_len
)
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kCngPeriodSamples
;
next_input_time_ms
+
=
kCngPeriodMs
*
drift_factor
;
}
}
double
speech_restart_time_ms
=
t_ms
;
while
(
out_frame_
.
speech_type_
!
=
AudioFrame
:
:
kNormalSpeech
)
{
while
(
next_input_time_ms
<
=
t_ms
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
seq_no
timestamp
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kSamples
;
next_input_time_ms
+
=
kFrameSizeMs
*
drift_factor
;
}
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
t_ms
+
=
10
;
}
double
time_until_speech_returns_ms
=
t_ms
-
speech_restart_time_ms
;
EXPECT_LT
(
time_until_speech_returns_ms
max_time_to_speech_ms
)
;
playout_timestamp
=
neteq_
-
>
GetPlayoutTimestamp
(
)
;
ASSERT_TRUE
(
playout_timestamp
)
;
int32_t
delay_after
=
timestamp
-
*
playout_timestamp
;
EXPECT_LE
(
delay_after
delay_before
+
delay_tolerance_ms
*
16
)
;
EXPECT_GE
(
delay_after
delay_before
-
delay_tolerance_ms
*
16
)
;
}
TEST_F
(
NetEqDecodingTest
LongCngWithNegativeClockDrift
)
{
const
double
kDriftFactor
=
1000
.
0
/
(
1000
.
0
+
25
.
0
)
;
const
double
kNetworkFreezeTimeMs
=
0
.
0
;
const
bool
kGetAudioDuringFreezeRecovery
=
false
;
const
int
kDelayToleranceMs
=
20
;
const
int
kMaxTimeToSpeechMs
=
100
;
LongCngWithClockDrift
(
kDriftFactor
kNetworkFreezeTimeMs
kGetAudioDuringFreezeRecovery
kDelayToleranceMs
kMaxTimeToSpeechMs
)
;
}
TEST_F
(
NetEqDecodingTest
LongCngWithPositiveClockDrift
)
{
const
double
kDriftFactor
=
1000
.
0
/
(
1000
.
0
-
25
.
0
)
;
const
double
kNetworkFreezeTimeMs
=
0
.
0
;
const
bool
kGetAudioDuringFreezeRecovery
=
false
;
const
int
kDelayToleranceMs
=
20
;
const
int
kMaxTimeToSpeechMs
=
100
;
LongCngWithClockDrift
(
kDriftFactor
kNetworkFreezeTimeMs
kGetAudioDuringFreezeRecovery
kDelayToleranceMs
kMaxTimeToSpeechMs
)
;
}
TEST_F
(
NetEqDecodingTest
LongCngWithNegativeClockDriftNetworkFreeze
)
{
const
double
kDriftFactor
=
1000
.
0
/
(
1000
.
0
+
25
.
0
)
;
const
double
kNetworkFreezeTimeMs
=
5000
.
0
;
const
bool
kGetAudioDuringFreezeRecovery
=
false
;
const
int
kDelayToleranceMs
=
50
;
const
int
kMaxTimeToSpeechMs
=
200
;
LongCngWithClockDrift
(
kDriftFactor
kNetworkFreezeTimeMs
kGetAudioDuringFreezeRecovery
kDelayToleranceMs
kMaxTimeToSpeechMs
)
;
}
TEST_F
(
NetEqDecodingTest
LongCngWithPositiveClockDriftNetworkFreeze
)
{
const
double
kDriftFactor
=
1000
.
0
/
(
1000
.
0
-
25
.
0
)
;
const
double
kNetworkFreezeTimeMs
=
5000
.
0
;
const
bool
kGetAudioDuringFreezeRecovery
=
false
;
const
int
kDelayToleranceMs
=
20
;
const
int
kMaxTimeToSpeechMs
=
100
;
LongCngWithClockDrift
(
kDriftFactor
kNetworkFreezeTimeMs
kGetAudioDuringFreezeRecovery
kDelayToleranceMs
kMaxTimeToSpeechMs
)
;
}
TEST_F
(
NetEqDecodingTest
LongCngWithPositiveClockDriftNetworkFreezeExtraPull
)
{
const
double
kDriftFactor
=
1000
.
0
/
(
1000
.
0
-
25
.
0
)
;
const
double
kNetworkFreezeTimeMs
=
5000
.
0
;
const
bool
kGetAudioDuringFreezeRecovery
=
true
;
const
int
kDelayToleranceMs
=
20
;
const
int
kMaxTimeToSpeechMs
=
100
;
LongCngWithClockDrift
(
kDriftFactor
kNetworkFreezeTimeMs
kGetAudioDuringFreezeRecovery
kDelayToleranceMs
kMaxTimeToSpeechMs
)
;
}
TEST_F
(
NetEqDecodingTest
LongCngWithoutClockDrift
)
{
const
double
kDriftFactor
=
1
.
0
;
const
double
kNetworkFreezeTimeMs
=
0
.
0
;
const
bool
kGetAudioDuringFreezeRecovery
=
false
;
const
int
kDelayToleranceMs
=
10
;
const
int
kMaxTimeToSpeechMs
=
50
;
LongCngWithClockDrift
(
kDriftFactor
kNetworkFreezeTimeMs
kGetAudioDuringFreezeRecovery
kDelayToleranceMs
kMaxTimeToSpeechMs
)
;
}
TEST_F
(
NetEqDecodingTest
UnknownPayloadType
)
{
const
size_t
kPayloadBytes
=
100
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
0
0
&
rtp_info
)
;
rtp_info
.
payloadType
=
1
;
EXPECT_EQ
(
NetEq
:
:
kFail
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
}
#
if
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
#
define
MAYBE_DecoderError
DecoderError
#
else
#
define
MAYBE_DecoderError
DISABLED_DecoderError
#
endif
TEST_F
(
NetEqDecodingTest
MAYBE_DecoderError
)
{
const
size_t
kPayloadBytes
=
100
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
0
0
&
rtp_info
)
;
rtp_info
.
payloadType
=
103
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
int16_t
*
out_frame_data
=
out_frame_
.
mutable_data
(
)
;
for
(
size_t
i
=
0
;
i
<
AudioFrame
:
:
kMaxDataSizeSamples
;
+
+
i
)
{
out_frame_data
[
i
]
=
1
;
}
bool
muted
;
EXPECT_EQ
(
NetEq
:
:
kFail
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
static
const
int
kExpectedOutputLength
=
160
;
const
int16_t
*
const_out_frame_data
=
out_frame_
.
data
(
)
;
for
(
int
i
=
0
;
i
<
kExpectedOutputLength
;
+
+
i
)
{
std
:
:
ostringstream
ss
;
ss
<
<
"
i
=
"
<
<
i
;
SCOPED_TRACE
(
ss
.
str
(
)
)
;
EXPECT_EQ
(
0
const_out_frame_data
[
i
]
)
;
}
}
TEST_F
(
NetEqDecodingTest
GetAudioBeforeInsertPacket
)
{
int16_t
*
out_frame_data
=
out_frame_
.
mutable_data
(
)
;
for
(
size_t
i
=
0
;
i
<
AudioFrame
:
:
kMaxDataSizeSamples
;
+
+
i
)
{
out_frame_data
[
i
]
=
1
;
}
bool
muted
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
static
const
int
kExpectedOutputLength
=
kInitSampleRateHz
/
100
;
const
int16_t
*
const_out_frame_data
=
out_frame_
.
data
(
)
;
for
(
int
i
=
0
;
i
<
kExpectedOutputLength
;
+
+
i
)
{
std
:
:
ostringstream
ss
;
ss
<
<
"
i
=
"
<
<
i
;
SCOPED_TRACE
(
ss
.
str
(
)
)
;
EXPECT_EQ
(
0
const_out_frame_data
[
i
]
)
;
}
EXPECT_EQ
(
config_
.
sample_rate_hz
neteq_
-
>
last_output_sample_rate_hz
(
)
)
;
}
class
NetEqBgnTest
:
public
NetEqDecodingTest
{
protected
:
virtual
void
TestCondition
(
double
sum_squared_noise
bool
should_be_faded
)
=
0
;
void
CheckBgn
(
int
sampling_rate_hz
)
{
size_t
expected_samples_per_channel
=
0
;
uint8_t
payload_type
=
0xFF
;
if
(
sampling_rate_hz
=
=
8000
)
{
expected_samples_per_channel
=
kBlockSize8kHz
;
payload_type
=
93
;
}
else
if
(
sampling_rate_hz
=
=
16000
)
{
expected_samples_per_channel
=
kBlockSize16kHz
;
payload_type
=
94
;
}
else
if
(
sampling_rate_hz
=
=
32000
)
{
expected_samples_per_channel
=
kBlockSize32kHz
;
payload_type
=
95
;
}
else
{
ASSERT_TRUE
(
false
)
;
}
AudioFrame
output
;
test
:
:
AudioLoop
input
;
ASSERT_TRUE
(
input
.
Init
(
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
testfile32kHz
"
"
pcm
"
)
10
*
sampling_rate_hz
expected_samples_per_channel
)
)
;
uint8_t
payload
[
kBlockSize32kHz
*
sizeof
(
int16_t
)
]
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
0
0
&
rtp_info
)
;
rtp_info
.
payloadType
=
payload_type
;
uint32_t
receive_timestamp
=
0
;
bool
muted
;
for
(
int
n
=
0
;
n
<
10
;
+
+
n
)
{
auto
block
=
input
.
GetNextBlock
(
)
;
ASSERT_EQ
(
expected_samples_per_channel
block
.
size
(
)
)
;
size_t
enc_len_bytes
=
WebRtcPcm16b_Encode
(
block
.
data
(
)
block
.
size
(
)
payload
)
;
ASSERT_EQ
(
enc_len_bytes
expected_samples_per_channel
*
2
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
enc_len_bytes
)
receive_timestamp
)
)
;
output
.
Reset
(
)
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
ASSERT_EQ
(
1u
output
.
num_channels_
)
;
ASSERT_EQ
(
expected_samples_per_channel
output
.
samples_per_channel_
)
;
ASSERT_EQ
(
AudioFrame
:
:
kNormalSpeech
output
.
speech_type_
)
;
rtp_info
.
timestamp
+
=
rtc
:
:
checked_cast
<
uint32_t
>
(
expected_samples_per_channel
)
;
rtp_info
.
sequenceNumber
+
+
;
receive_timestamp
+
=
rtc
:
:
checked_cast
<
uint32_t
>
(
expected_samples_per_channel
)
;
}
output
.
Reset
(
)
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
ASSERT_EQ
(
1u
output
.
num_channels_
)
;
ASSERT_EQ
(
expected_samples_per_channel
output
.
samples_per_channel_
)
;
const
int
kFadingThreshold
=
611
;
const
int
kNumPlcToCngTestFrames
=
20
;
bool
plc_to_cng
=
false
;
for
(
int
n
=
0
;
n
<
kFadingThreshold
+
kNumPlcToCngTestFrames
;
+
+
n
)
{
output
.
Reset
(
)
;
memset
(
output
.
mutable_data
(
)
1
AudioFrame
:
:
kMaxDataSizeBytes
)
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
ASSERT_EQ
(
1u
output
.
num_channels_
)
;
ASSERT_EQ
(
expected_samples_per_channel
output
.
samples_per_channel_
)
;
if
(
output
.
speech_type_
=
=
AudioFrame
:
:
kPLCCNG
)
{
plc_to_cng
=
true
;
double
sum_squared
=
0
;
const
int16_t
*
output_data
=
output
.
data
(
)
;
for
(
size_t
k
=
0
;
k
<
output
.
num_channels_
*
output
.
samples_per_channel_
;
+
+
k
)
sum_squared
+
=
output_data
[
k
]
*
output_data
[
k
]
;
TestCondition
(
sum_squared
n
>
kFadingThreshold
)
;
}
else
{
EXPECT_EQ
(
AudioFrame
:
:
kPLC
output
.
speech_type_
)
;
}
}
EXPECT_TRUE
(
plc_to_cng
)
;
}
}
;
class
NetEqBgnTestOn
:
public
NetEqBgnTest
{
protected
:
NetEqBgnTestOn
(
)
:
NetEqBgnTest
(
)
{
config_
.
background_noise_mode
=
NetEq
:
:
kBgnOn
;
}
void
TestCondition
(
double
sum_squared_noise
bool
)
{
EXPECT_NE
(
0
sum_squared_noise
)
;
}
}
;
class
NetEqBgnTestOff
:
public
NetEqBgnTest
{
protected
:
NetEqBgnTestOff
(
)
:
NetEqBgnTest
(
)
{
config_
.
background_noise_mode
=
NetEq
:
:
kBgnOff
;
}
void
TestCondition
(
double
sum_squared_noise
bool
)
{
EXPECT_EQ
(
0
sum_squared_noise
)
;
}
}
;
class
NetEqBgnTestFade
:
public
NetEqBgnTest
{
protected
:
NetEqBgnTestFade
(
)
:
NetEqBgnTest
(
)
{
config_
.
background_noise_mode
=
NetEq
:
:
kBgnFade
;
}
void
TestCondition
(
double
sum_squared_noise
bool
should_be_faded
)
{
if
(
should_be_faded
)
EXPECT_EQ
(
0
sum_squared_noise
)
;
}
}
;
TEST_F
(
NetEqBgnTestOn
RunTest
)
{
CheckBgn
(
8000
)
;
CheckBgn
(
16000
)
;
CheckBgn
(
32000
)
;
}
TEST_F
(
NetEqBgnTestOff
RunTest
)
{
CheckBgn
(
8000
)
;
CheckBgn
(
16000
)
;
CheckBgn
(
32000
)
;
}
TEST_F
(
NetEqBgnTestFade
RunTest
)
{
CheckBgn
(
8000
)
;
CheckBgn
(
16000
)
;
CheckBgn
(
32000
)
;
}
void
NetEqDecodingTest
:
:
WrapTest
(
uint16_t
start_seq_no
uint32_t
start_timestamp
const
std
:
:
set
<
uint16_t
>
&
drop_seq_numbers
bool
expect_seq_no_wrap
bool
expect_timestamp_wrap
)
{
uint16_t
seq_no
=
start_seq_no
;
uint32_t
timestamp
=
start_timestamp
;
const
int
kBlocksPerFrame
=
3
;
const
int
kFrameSizeMs
=
kBlocksPerFrame
*
kTimeStepMs
;
const
int
kSamples
=
kBlockSize16kHz
*
kBlocksPerFrame
;
const
size_t
kPayloadBytes
=
kSamples
*
sizeof
(
int16_t
)
;
double
next_input_time_ms
=
0
.
0
;
uint32_t
receive_timestamp
=
0
;
const
int
kSpeechDurationMs
=
2000
;
int
packets_inserted
=
0
;
uint16_t
last_seq_no
;
uint32_t
last_timestamp
;
bool
timestamp_wrapped
=
false
;
bool
seq_no_wrapped
=
false
;
for
(
double
t_ms
=
0
;
t_ms
<
kSpeechDurationMs
;
t_ms
+
=
10
)
{
while
(
next_input_time_ms
<
=
t_ms
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
seq_no
timestamp
&
rtp_info
)
;
if
(
drop_seq_numbers
.
find
(
seq_no
)
=
=
drop_seq_numbers
.
end
(
)
)
{
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
receive_timestamp
)
)
;
+
+
packets_inserted
;
}
NetEqNetworkStatistics
network_stats
;
ASSERT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
network_stats
)
)
;
if
(
packets_inserted
>
4
)
{
EXPECT_LE
(
network_stats
.
preferred_buffer_size_ms
kFrameSizeMs
*
2
)
;
EXPECT_LE
(
network_stats
.
current_buffer_size_ms
kFrameSizeMs
*
2
+
algorithmic_delay_ms_
)
;
}
last_seq_no
=
seq_no
;
last_timestamp
=
timestamp
;
+
+
seq_no
;
timestamp
+
=
kSamples
;
receive_timestamp
+
=
kSamples
;
next_input_time_ms
+
=
static_cast
<
double
>
(
kFrameSizeMs
)
;
seq_no_wrapped
|
=
seq_no
<
last_seq_no
;
timestamp_wrapped
|
=
timestamp
<
last_timestamp
;
}
AudioFrame
output
;
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
output
.
samples_per_channel_
)
;
ASSERT_EQ
(
1u
output
.
num_channels_
)
;
rtc
:
:
Optional
<
uint32_t
>
playout_timestamp
=
neteq_
-
>
GetPlayoutTimestamp
(
)
;
ASSERT_TRUE
(
playout_timestamp
)
;
EXPECT_LE
(
timestamp
-
*
playout_timestamp
static_cast
<
uint32_t
>
(
kSamples
*
2
)
)
;
}
ASSERT_EQ
(
expect_seq_no_wrap
seq_no_wrapped
)
;
ASSERT_EQ
(
expect_timestamp_wrap
timestamp_wrapped
)
;
}
TEST_F
(
NetEqDecodingTest
SequenceNumberWrap
)
{
std
:
:
set
<
uint16_t
>
drop_seq_numbers
;
WrapTest
(
0xFFFF
-
10
0
drop_seq_numbers
true
false
)
;
}
TEST_F
(
NetEqDecodingTest
SequenceNumberWrapAndDrop
)
{
std
:
:
set
<
uint16_t
>
drop_seq_numbers
;
drop_seq_numbers
.
insert
(
0xFFFF
)
;
drop_seq_numbers
.
insert
(
0x0
)
;
WrapTest
(
0xFFFF
-
10
0
drop_seq_numbers
true
false
)
;
}
TEST_F
(
NetEqDecodingTest
TimestampWrap
)
{
std
:
:
set
<
uint16_t
>
drop_seq_numbers
;
WrapTest
(
0
0xFFFFFFFF
-
3000
drop_seq_numbers
false
true
)
;
}
TEST_F
(
NetEqDecodingTest
TimestampAndSequenceNumberWrap
)
{
std
:
:
set
<
uint16_t
>
drop_seq_numbers
;
WrapTest
(
0xFFFF
-
10
0xFFFFFFFF
-
5000
drop_seq_numbers
true
true
)
;
}
void
NetEqDecodingTest
:
:
DuplicateCng
(
)
{
uint16_t
seq_no
=
0
;
uint32_t
timestamp
=
0
;
const
int
kFrameSizeMs
=
10
;
const
int
kSampleRateKhz
=
16
;
const
int
kSamples
=
kFrameSizeMs
*
kSampleRateKhz
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
const
int
algorithmic_delay_samples
=
std
:
:
max
(
algorithmic_delay_ms_
*
kSampleRateKhz
5
*
kSampleRateKhz
/
8
)
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
bool
muted
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
PopulateRtpInfo
(
seq_no
timestamp
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kSamples
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
EXPECT_EQ
(
AudioFrame
:
:
kNormalSpeech
out_frame_
.
speech_type_
)
;
const
int
kCngPeriodMs
=
100
;
const
int
kCngPeriodSamples
=
kCngPeriodMs
*
kSampleRateKhz
;
size_t
payload_len
;
PopulateCng
(
seq_no
timestamp
&
rtp_info
payload
&
payload_len
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
payload_len
)
0
)
)
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
EXPECT_FALSE
(
neteq_
-
>
GetPlayoutTimestamp
(
)
)
;
EXPECT_EQ
(
timestamp
-
algorithmic_delay_samples
out_frame_
.
timestamp_
+
out_frame_
.
samples_per_channel_
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
payload_len
)
0
)
)
;
for
(
int
cng_time_ms
=
10
;
cng_time_ms
<
kCngPeriodMs
;
cng_time_ms
+
=
10
)
{
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
EXPECT_FALSE
(
neteq_
-
>
GetPlayoutTimestamp
(
)
)
;
EXPECT_EQ
(
timestamp
-
algorithmic_delay_samples
out_frame_
.
timestamp_
+
out_frame_
.
samples_per_channel_
)
;
}
+
+
seq_no
;
timestamp
+
=
kCngPeriodSamples
;
PopulateRtpInfo
(
seq_no
timestamp
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
EXPECT_EQ
(
AudioFrame
:
:
kNormalSpeech
out_frame_
.
speech_type_
)
;
rtc
:
:
Optional
<
uint32_t
>
playout_timestamp
=
neteq_
-
>
GetPlayoutTimestamp
(
)
;
ASSERT_TRUE
(
playout_timestamp
)
;
EXPECT_EQ
(
timestamp
+
kSamples
-
algorithmic_delay_samples
*
playout_timestamp
)
;
}
TEST_F
(
NetEqDecodingTest
DiscardDuplicateCng
)
{
DuplicateCng
(
)
;
}
TEST_F
(
NetEqDecodingTest
CngFirst
)
{
uint16_t
seq_no
=
0
;
uint32_t
timestamp
=
0
;
const
int
kFrameSizeMs
=
10
;
const
int
kSampleRateKhz
=
16
;
const
int
kSamples
=
kFrameSizeMs
*
kSampleRateKhz
;
const
int
kPayloadBytes
=
kSamples
*
2
;
const
int
kCngPeriodMs
=
100
;
const
int
kCngPeriodSamples
=
kCngPeriodMs
*
kSampleRateKhz
;
size_t
payload_len
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateCng
(
seq_no
timestamp
&
rtp_info
payload
&
payload_len
)
;
ASSERT_EQ
(
NetEq
:
:
kOK
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
payload_len
)
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kCngPeriodSamples
;
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
const
uint32_t
first_speech_timestamp
=
timestamp
;
int
timeout_counter
=
0
;
do
{
ASSERT_LT
(
timeout_counter
+
+
20
)
<
<
"
Test
timed
out
"
;
PopulateRtpInfo
(
seq_no
timestamp
&
rtp_info
)
;
ASSERT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
+
+
seq_no
;
timestamp
+
=
kSamples
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_EQ
(
kBlockSize16kHz
out_frame_
.
samples_per_channel_
)
;
}
while
(
!
IsNewerTimestamp
(
out_frame_
.
timestamp_
first_speech_timestamp
)
)
;
EXPECT_EQ
(
AudioFrame
:
:
kNormalSpeech
out_frame_
.
speech_type_
)
;
}
class
NetEqDecodingTestWithMutedState
:
public
NetEqDecodingTest
{
public
:
NetEqDecodingTestWithMutedState
(
)
:
NetEqDecodingTest
(
)
{
config_
.
enable_muted_state
=
true
;
}
protected
:
static
constexpr
size_t
kSamples
=
10
*
16
;
static
constexpr
size_t
kPayloadBytes
=
kSamples
*
2
;
void
InsertPacket
(
uint32_t
rtp_timestamp
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
0
rtp_timestamp
&
rtp_info
)
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
}
void
InsertCngPacket
(
uint32_t
rtp_timestamp
)
{
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
size_t
payload_len
;
PopulateCng
(
0
rtp_timestamp
&
rtp_info
payload
&
payload_len
)
;
EXPECT_EQ
(
NetEq
:
:
kOK
neteq_
-
>
InsertPacket
(
rtp_info
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload
payload_len
)
0
)
)
;
}
bool
GetAudioReturnMuted
(
)
{
bool
muted
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
return
muted
;
}
void
GetAudioUntilMuted
(
)
{
while
(
!
GetAudioReturnMuted
(
)
)
{
ASSERT_LT
(
counter_
+
+
1000
)
<
<
"
Test
timed
out
"
;
}
}
void
GetAudioUntilNormal
(
)
{
bool
muted
=
false
;
while
(
out_frame_
.
speech_type_
!
=
AudioFrame
:
:
kNormalSpeech
)
{
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_LT
(
counter_
+
+
1000
)
<
<
"
Test
timed
out
"
;
}
EXPECT_FALSE
(
muted
)
;
}
int
counter_
=
0
;
}
;
TEST_F
(
NetEqDecodingTestWithMutedState
MutedState
)
{
InsertPacket
(
0
)
;
EXPECT_FALSE
(
GetAudioReturnMuted
(
)
)
;
GetAudioUntilMuted
(
)
;
EXPECT_TRUE
(
out_frame_
.
muted
(
)
)
;
AudioFrame
new_frame
;
int16_t
*
frame_data
=
new_frame
.
mutable_data
(
)
;
for
(
size_t
i
=
0
;
i
<
AudioFrame
:
:
kMaxDataSizeSamples
;
i
+
+
)
{
frame_data
[
i
]
=
17
;
}
bool
muted
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
new_frame
&
muted
)
)
;
EXPECT_TRUE
(
muted
)
;
EXPECT_TRUE
(
out_frame_
.
muted
(
)
)
;
for
(
size_t
i
=
0
;
i
<
AudioFrame
:
:
kMaxDataSizeSamples
;
i
+
+
)
{
EXPECT_EQ
(
17
frame_data
[
i
]
)
;
}
EXPECT_EQ
(
out_frame_
.
timestamp_
+
out_frame_
.
samples_per_channel_
new_frame
.
timestamp_
)
;
EXPECT_EQ
(
out_frame_
.
samples_per_channel_
new_frame
.
samples_per_channel_
)
;
EXPECT_EQ
(
out_frame_
.
sample_rate_hz_
new_frame
.
sample_rate_hz_
)
;
EXPECT_EQ
(
out_frame_
.
num_channels_
new_frame
.
num_channels_
)
;
EXPECT_EQ
(
out_frame_
.
speech_type_
new_frame
.
speech_type_
)
;
EXPECT_EQ
(
out_frame_
.
vad_activity_
new_frame
.
vad_activity_
)
;
InsertPacket
(
kSamples
*
counter_
)
;
GetAudioUntilNormal
(
)
;
EXPECT_FALSE
(
out_frame_
.
muted
(
)
)
;
NetEqNetworkStatistics
stats
;
EXPECT_EQ
(
0
neteq_
-
>
NetworkStatistics
(
&
stats
)
)
;
EXPECT_GT
(
stats
.
expand_rate
14000
)
;
EXPECT_GT
(
stats
.
expand_rate
stats
.
speech_expand_rate
)
;
}
TEST_F
(
NetEqDecodingTestWithMutedState
MutedStateDelayedPacket
)
{
InsertPacket
(
0
)
;
EXPECT_FALSE
(
GetAudioReturnMuted
(
)
)
;
GetAudioUntilMuted
(
)
;
InsertPacket
(
kSamples
*
counter_
/
2
)
;
GetAudioUntilNormal
(
)
;
}
TEST_F
(
NetEqDecodingTestWithMutedState
MutedStateFuturePacket
)
{
InsertPacket
(
0
)
;
EXPECT_FALSE
(
GetAudioReturnMuted
(
)
)
;
GetAudioUntilMuted
(
)
;
InsertPacket
(
kSamples
*
counter_
*
2
)
;
GetAudioUntilNormal
(
)
;
}
TEST_F
(
NetEqDecodingTestWithMutedState
MutedStateOldPacket
)
{
InsertPacket
(
0
)
;
EXPECT_FALSE
(
GetAudioReturnMuted
(
)
)
;
GetAudioUntilMuted
(
)
;
EXPECT_NE
(
AudioFrame
:
:
kNormalSpeech
out_frame_
.
speech_type_
)
;
InsertPacket
(
kSamples
*
(
counter_
-
1000
)
)
;
EXPECT_FALSE
(
GetAudioReturnMuted
(
)
)
;
EXPECT_EQ
(
AudioFrame
:
:
kNormalSpeech
out_frame_
.
speech_type_
)
;
}
TEST_F
(
NetEqDecodingTestWithMutedState
DoNotMuteExtendedCngWithoutPackets
)
{
InsertCngPacket
(
0
)
;
for
(
int
i
=
0
;
i
<
1000
;
+
+
i
)
{
bool
muted
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
}
EXPECT_EQ
(
AudioFrame
:
:
kCNG
out_frame_
.
speech_type_
)
;
}
TEST_F
(
NetEqDecodingTestWithMutedState
RecoverAfterExtendedCngWithoutPackets
)
{
InsertCngPacket
(
0
)
;
for
(
int
i
=
0
;
i
<
1000
;
+
+
i
)
{
bool
muted
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
)
;
}
InsertPacket
(
kSamples
*
counter_
)
;
GetAudioUntilNormal
(
)
;
}
class
NetEqDecodingTestTwoInstances
:
public
NetEqDecodingTest
{
public
:
NetEqDecodingTestTwoInstances
(
)
:
NetEqDecodingTest
(
)
{
}
void
SetUp
(
)
override
{
NetEqDecodingTest
:
:
SetUp
(
)
;
config2_
=
config_
;
}
void
CreateSecondInstance
(
)
{
neteq2_
.
reset
(
NetEq
:
:
Create
(
config2_
CreateBuiltinAudioDecoderFactory
(
)
)
)
;
ASSERT_TRUE
(
neteq2_
)
;
LoadDecoders
(
neteq2_
.
get
(
)
)
;
}
protected
:
std
:
:
unique_ptr
<
NetEq
>
neteq2_
;
NetEq
:
:
Config
config2_
;
}
;
namespace
{
:
:
testing
:
:
AssertionResult
AudioFramesEqualExceptData
(
const
AudioFrame
&
a
const
AudioFrame
&
b
)
{
if
(
a
.
timestamp_
!
=
b
.
timestamp_
)
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
timestamp_
diff
(
"
<
<
a
.
timestamp_
<
<
"
!
=
"
<
<
b
.
timestamp_
<
<
"
)
"
;
if
(
a
.
sample_rate_hz_
!
=
b
.
sample_rate_hz_
)
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
sample_rate_hz_
diff
(
"
<
<
a
.
sample_rate_hz_
<
<
"
!
=
"
<
<
b
.
sample_rate_hz_
<
<
"
)
"
;
if
(
a
.
samples_per_channel_
!
=
b
.
samples_per_channel_
)
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
samples_per_channel_
diff
(
"
<
<
a
.
samples_per_channel_
<
<
"
!
=
"
<
<
b
.
samples_per_channel_
<
<
"
)
"
;
if
(
a
.
num_channels_
!
=
b
.
num_channels_
)
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
num_channels_
diff
(
"
<
<
a
.
num_channels_
<
<
"
!
=
"
<
<
b
.
num_channels_
<
<
"
)
"
;
if
(
a
.
speech_type_
!
=
b
.
speech_type_
)
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
speech_type_
diff
(
"
<
<
a
.
speech_type_
<
<
"
!
=
"
<
<
b
.
speech_type_
<
<
"
)
"
;
if
(
a
.
vad_activity_
!
=
b
.
vad_activity_
)
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
vad_activity_
diff
(
"
<
<
a
.
vad_activity_
<
<
"
!
=
"
<
<
b
.
vad_activity_
<
<
"
)
"
;
return
:
:
testing
:
:
AssertionSuccess
(
)
;
}
:
:
testing
:
:
AssertionResult
AudioFramesEqual
(
const
AudioFrame
&
a
const
AudioFrame
&
b
)
{
:
:
testing
:
:
AssertionResult
res
=
AudioFramesEqualExceptData
(
a
b
)
;
if
(
!
res
)
return
res
;
if
(
memcmp
(
a
.
data
(
)
b
.
data
(
)
a
.
samples_per_channel_
*
a
.
num_channels_
*
sizeof
(
*
a
.
data
(
)
)
)
!
=
0
)
{
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
data_
diff
"
;
}
return
:
:
testing
:
:
AssertionSuccess
(
)
;
}
}
TEST_F
(
NetEqDecodingTestTwoInstances
CompareMutedStateOnOff
)
{
ASSERT_FALSE
(
config_
.
enable_muted_state
)
;
config2_
.
enable_muted_state
=
true
;
CreateSecondInstance
(
)
;
const
size_t
kSamples
=
10
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
PopulateRtpInfo
(
0
0
&
rtp_info
)
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
EXPECT_EQ
(
0
neteq2_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
AudioFrame
out_frame1
out_frame2
;
bool
muted
;
for
(
int
i
=
0
;
i
<
1000
;
+
+
i
)
{
std
:
:
ostringstream
ss
;
ss
<
<
"
i
=
"
<
<
i
;
SCOPED_TRACE
(
ss
.
str
(
)
)
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame1
&
muted
)
)
;
EXPECT_FALSE
(
muted
)
;
EXPECT_EQ
(
0
neteq2_
-
>
GetAudio
(
&
out_frame2
&
muted
)
)
;
if
(
muted
)
{
EXPECT_TRUE
(
AudioFramesEqualExceptData
(
out_frame1
out_frame2
)
)
;
}
else
{
EXPECT_TRUE
(
AudioFramesEqual
(
out_frame1
out_frame2
)
)
;
}
}
EXPECT_TRUE
(
muted
)
;
PopulateRtpInfo
(
0
kSamples
*
1000
&
rtp_info
)
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
EXPECT_EQ
(
0
neteq2_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
int
counter
=
0
;
while
(
out_frame1
.
speech_type_
!
=
AudioFrame
:
:
kNormalSpeech
)
{
ASSERT_LT
(
counter
+
+
1000
)
<
<
"
Test
timed
out
"
;
std
:
:
ostringstream
ss
;
ss
<
<
"
counter
=
"
<
<
counter
;
SCOPED_TRACE
(
ss
.
str
(
)
)
;
EXPECT_EQ
(
0
neteq_
-
>
GetAudio
(
&
out_frame1
&
muted
)
)
;
EXPECT_FALSE
(
muted
)
;
EXPECT_EQ
(
0
neteq2_
-
>
GetAudio
(
&
out_frame2
&
muted
)
)
;
if
(
muted
)
{
EXPECT_TRUE
(
AudioFramesEqualExceptData
(
out_frame1
out_frame2
)
)
;
}
else
{
EXPECT_TRUE
(
AudioFramesEqual
(
out_frame1
out_frame2
)
)
;
}
}
EXPECT_FALSE
(
muted
)
;
}
TEST_F
(
NetEqDecodingTest
LastDecodedTimestampsEmpty
)
{
EXPECT_TRUE
(
neteq_
-
>
LastDecodedTimestamps
(
)
.
empty
(
)
)
;
AudioFrame
output
;
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
EXPECT_TRUE
(
neteq_
-
>
LastDecodedTimestamps
(
)
.
empty
(
)
)
;
}
TEST_F
(
NetEqDecodingTest
LastDecodedTimestampsOneDecoded
)
{
constexpr
size_t
kPayloadSamples
=
16
*
10
;
constexpr
size_t
kPayloadBytes
=
2
*
kPayloadSamples
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
constexpr
uint32_t
kRtpTimestamp
=
0x1234
;
PopulateRtpInfo
(
0
kRtpTimestamp
&
rtp_info
)
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
AudioFrame
output
;
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
EXPECT_EQ
(
std
:
:
vector
<
uint32_t
>
(
{
kRtpTimestamp
}
)
neteq_
-
>
LastDecodedTimestamps
(
)
)
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
EXPECT_TRUE
(
neteq_
-
>
LastDecodedTimestamps
(
)
.
empty
(
)
)
;
}
TEST_F
(
NetEqDecodingTest
LastDecodedTimestampsTwoDecoded
)
{
constexpr
size_t
kPayloadSamples
=
16
*
5
;
constexpr
size_t
kPayloadBytes
=
2
*
kPayloadSamples
;
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
RTPHeader
rtp_info
;
constexpr
uint32_t
kRtpTimestamp1
=
0x1234
;
PopulateRtpInfo
(
0
kRtpTimestamp1
&
rtp_info
)
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
constexpr
uint32_t
kRtpTimestamp2
=
kRtpTimestamp1
+
kPayloadSamples
;
PopulateRtpInfo
(
1
kRtpTimestamp2
&
rtp_info
)
;
EXPECT_EQ
(
0
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
)
;
AudioFrame
output
;
bool
muted
;
ASSERT_EQ
(
0
neteq_
-
>
GetAudio
(
&
output
&
muted
)
)
;
EXPECT_EQ
(
std
:
:
vector
<
uint32_t
>
(
{
kRtpTimestamp1
kRtpTimestamp2
}
)
neteq_
-
>
LastDecodedTimestamps
(
)
)
;
}
TEST_F
(
NetEqDecodingTest
TestConcealmentEvents
)
{
const
int
kNumConcealmentEvents
=
19
;
const
size_t
kSamples
=
10
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
int
seq_no
=
0
;
RTPHeader
rtp_info
;
rtp_info
.
ssrc
=
0x1234
;
rtp_info
.
payloadType
=
94
;
rtp_info
.
markerBit
=
0
;
const
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
bool
muted
;
for
(
int
i
=
0
;
i
<
kNumConcealmentEvents
;
i
+
+
)
{
for
(
int
j
=
0
;
j
<
10
;
j
+
+
)
{
rtp_info
.
sequenceNumber
=
seq_no
+
+
;
rtp_info
.
timestamp
=
rtp_info
.
sequenceNumber
*
kSamples
;
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
;
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
;
}
int
num_lost
=
1
+
i
;
for
(
int
j
=
0
;
j
<
num_lost
;
j
+
+
)
{
seq_no
+
+
;
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
;
}
}
NetEqLifetimeStatistics
stats
=
neteq_
-
>
GetLifetimeStatistics
(
)
;
EXPECT_EQ
(
kNumConcealmentEvents
static_cast
<
int
>
(
stats
.
concealment_events
)
)
;
}
void
NetEqDecodingTestFaxMode
:
:
TestJitterBufferDelay
(
bool
apply_packet_loss
)
{
const
int
kNumPackets
=
10
;
const
int
kDelayInNumPackets
=
2
;
const
int
kPacketLenMs
=
10
;
const
size_t
kSamples
=
kPacketLenMs
*
16
;
const
size_t
kPayloadBytes
=
kSamples
*
2
;
RTPHeader
rtp_info
;
rtp_info
.
ssrc
=
0x1234
;
rtp_info
.
payloadType
=
94
;
rtp_info
.
markerBit
=
0
;
const
uint8_t
payload
[
kPayloadBytes
]
=
{
0
}
;
bool
muted
;
int
packets_sent
=
0
;
int
packets_received
=
0
;
int
expected_delay
=
0
;
while
(
packets_received
<
kNumPackets
)
{
if
(
packets_sent
<
kNumPackets
)
{
rtp_info
.
sequenceNumber
=
packets_sent
+
+
;
rtp_info
.
timestamp
=
rtp_info
.
sequenceNumber
*
kSamples
;
neteq_
-
>
InsertPacket
(
rtp_info
payload
0
)
;
}
if
(
packets_sent
>
kDelayInNumPackets
)
{
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
;
packets_received
+
+
;
int
packets_delay
=
std
:
:
min
(
packets_received
kDelayInNumPackets
+
1
)
;
int
current_delay_ms
=
packets_delay
*
kPacketLenMs
;
expected_delay
+
=
current_delay_ms
*
kSamples
;
}
}
if
(
apply_packet_loss
)
{
neteq_
-
>
GetAudio
(
&
out_frame_
&
muted
)
;
}
NetEqLifetimeStatistics
stats
=
neteq_
-
>
GetLifetimeStatistics
(
)
;
EXPECT_EQ
(
expected_delay
static_cast
<
int
>
(
stats
.
jitter_buffer_delay_ms
)
)
;
}
TEST_F
(
NetEqDecodingTestFaxMode
TestJitterBufferDelayWithoutLoss
)
{
TestJitterBufferDelay
(
false
)
;
}
TEST_F
(
NetEqDecodingTestFaxMode
TestJitterBufferDelayWithLoss
)
{
TestJitterBufferDelay
(
true
)
;
}
}
