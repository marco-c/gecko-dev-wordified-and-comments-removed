#
include
"
modules
/
audio_coding
/
neteq
/
delay_peak_detector
.
h
"
#
include
<
algorithm
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
namespace
webrtc
{
DelayPeakDetector
:
:
~
DelayPeakDetector
(
)
=
default
;
DelayPeakDetector
:
:
DelayPeakDetector
(
const
TickTimer
*
tick_timer
)
:
peak_found_
(
false
)
peak_detection_threshold_
(
0
)
tick_timer_
(
tick_timer
)
frame_length_change_experiment_
(
field_trial
:
:
IsEnabled
(
"
WebRTC
-
Audio
-
NetEqFramelengthExperiment
"
)
)
{
RTC_DCHECK
(
!
peak_period_stopwatch_
)
;
}
void
DelayPeakDetector
:
:
Reset
(
)
{
peak_period_stopwatch_
.
reset
(
)
;
peak_found_
=
false
;
peak_history_
.
clear
(
)
;
}
void
DelayPeakDetector
:
:
SetPacketAudioLength
(
int
length_ms
)
{
if
(
length_ms
>
0
)
{
if
(
frame_length_change_experiment_
)
{
peak_detection_threshold_
=
std
:
:
max
(
2
kPeakHeightMs
/
length_ms
)
;
}
else
{
peak_detection_threshold_
=
kPeakHeightMs
/
length_ms
;
}
}
if
(
frame_length_change_experiment_
)
{
peak_history_
.
clear
(
)
;
}
}
bool
DelayPeakDetector
:
:
peak_found
(
)
{
return
peak_found_
;
}
int
DelayPeakDetector
:
:
MaxPeakHeight
(
)
const
{
int
max_height
=
-
1
;
std
:
:
list
<
Peak
>
:
:
const_iterator
it
;
for
(
it
=
peak_history_
.
begin
(
)
;
it
!
=
peak_history_
.
end
(
)
;
+
+
it
)
{
max_height
=
std
:
:
max
(
max_height
it
-
>
peak_height_packets
)
;
}
return
max_height
;
}
uint64_t
DelayPeakDetector
:
:
MaxPeakPeriod
(
)
const
{
auto
max_period_element
=
std
:
:
max_element
(
peak_history_
.
begin
(
)
peak_history_
.
end
(
)
[
]
(
Peak
a
Peak
b
)
{
return
a
.
period_ms
<
b
.
period_ms
;
}
)
;
if
(
max_period_element
=
=
peak_history_
.
end
(
)
)
{
return
0
;
}
RTC_DCHECK_GT
(
max_period_element
-
>
period_ms
0
)
;
return
max_period_element
-
>
period_ms
;
}
bool
DelayPeakDetector
:
:
Update
(
int
inter_arrival_time
int
target_level
)
{
if
(
inter_arrival_time
>
target_level
+
peak_detection_threshold_
|
|
inter_arrival_time
>
2
*
target_level
)
{
if
(
!
peak_period_stopwatch_
)
{
peak_period_stopwatch_
=
tick_timer_
-
>
GetNewStopwatch
(
)
;
}
else
if
(
peak_period_stopwatch_
-
>
ElapsedMs
(
)
>
0
)
{
if
(
peak_period_stopwatch_
-
>
ElapsedMs
(
)
<
=
kMaxPeakPeriodMs
)
{
Peak
peak_data
;
peak_data
.
period_ms
=
peak_period_stopwatch_
-
>
ElapsedMs
(
)
;
peak_data
.
peak_height_packets
=
inter_arrival_time
;
peak_history_
.
push_back
(
peak_data
)
;
while
(
peak_history_
.
size
(
)
>
kMaxNumPeaks
)
{
peak_history_
.
pop_front
(
)
;
}
peak_period_stopwatch_
=
tick_timer_
-
>
GetNewStopwatch
(
)
;
}
else
if
(
peak_period_stopwatch_
-
>
ElapsedMs
(
)
<
=
2
*
kMaxPeakPeriodMs
)
{
peak_period_stopwatch_
=
tick_timer_
-
>
GetNewStopwatch
(
)
;
}
else
{
Reset
(
)
;
}
}
}
return
CheckPeakConditions
(
)
;
}
bool
DelayPeakDetector
:
:
CheckPeakConditions
(
)
{
size_t
s
=
peak_history_
.
size
(
)
;
if
(
s
>
=
kMinPeaksToTrigger
&
&
peak_period_stopwatch_
-
>
ElapsedMs
(
)
<
=
2
*
MaxPeakPeriod
(
)
)
{
peak_found_
=
true
;
}
else
{
peak_found_
=
false
;
}
return
peak_found_
;
}
}
