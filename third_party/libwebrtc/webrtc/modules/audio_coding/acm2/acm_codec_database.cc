#
include
"
modules
/
audio_coding
/
acm2
/
acm_codec_database
.
h
"
#
include
<
assert
.
h
>
#
include
"
rtc_base
/
checks
.
h
"
#
if
(
(
defined
WEBRTC_CODEC_ISAC
)
&
&
(
defined
WEBRTC_CODEC_ISACFX
)
)
#
error
iSAC
and
iSACFX
codecs
cannot
be
enabled
at
the
same
time
#
endif
namespace
webrtc
{
namespace
acm2
{
namespace
{
bool
IsISACRateValid
(
int
rate
)
{
return
(
rate
=
=
-
1
)
|
|
(
(
rate
<
=
56000
)
&
&
(
rate
>
=
10000
)
)
;
}
bool
IsILBCRateValid
(
int
rate
int
frame_size_samples
)
{
if
(
(
(
frame_size_samples
=
=
240
)
|
|
(
frame_size_samples
=
=
480
)
)
&
&
(
rate
=
=
13300
)
)
{
return
true
;
}
else
if
(
(
(
frame_size_samples
=
=
160
)
|
|
(
frame_size_samples
=
=
320
)
)
&
&
(
rate
=
=
15200
)
)
{
return
true
;
}
else
{
return
false
;
}
}
bool
IsOpusRateValid
(
int
rate
)
{
return
(
rate
>
=
6000
)
&
&
(
rate
<
=
510000
)
;
}
}
const
CodecInst
ACMCodecDB
:
:
database_
[
]
=
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
{
103
"
ISAC
"
16000
480
1
32000
}
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
)
{
104
"
ISAC
"
32000
960
1
56000
}
#
endif
#
endif
{
107
"
L16
"
8000
80
1
128000
}
{
108
"
L16
"
16000
160
1
256000
}
{
109
"
L16
"
32000
320
1
512000
}
{
111
"
L16
"
8000
80
2
128000
}
{
112
"
L16
"
16000
160
2
256000
}
{
113
"
L16
"
32000
320
2
512000
}
{
0
"
PCMU
"
8000
160
1
64000
}
{
8
"
PCMA
"
8000
160
1
64000
}
{
110
"
PCMU
"
8000
160
2
64000
}
{
118
"
PCMA
"
8000
160
2
64000
}
#
ifdef
WEBRTC_CODEC_ILBC
{
102
"
ILBC
"
8000
240
1
13300
}
#
endif
{
9
"
G722
"
16000
320
1
64000
}
{
119
"
G722
"
16000
320
2
64000
}
#
ifdef
WEBRTC_CODEC_OPUS
{
120
"
opus
"
48000
960
2
64000
}
#
endif
{
13
"
CN
"
8000
240
1
0
}
{
98
"
CN
"
16000
480
1
0
}
{
99
"
CN
"
32000
960
1
0
}
#
ifdef
ENABLE_48000_HZ
{
100
"
CN
"
48000
1440
1
0
}
#
endif
{
106
"
telephone
-
event
"
8000
240
1
0
}
{
114
"
telephone
-
event
"
16000
240
1
0
}
{
115
"
telephone
-
event
"
32000
240
1
0
}
{
116
"
telephone
-
event
"
48000
240
1
0
}
#
ifdef
WEBRTC_CODEC_RED
{
127
"
red
"
8000
0
1
0
}
#
endif
{
-
1
"
Null
"
-
1
-
1
0
-
1
}
}
;
const
ACMCodecDB
:
:
CodecSettings
ACMCodecDB
:
:
codec_settings_
[
]
=
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
{
2
{
480
960
}
0
1
}
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
)
{
1
{
960
}
0
1
}
#
endif
#
endif
{
4
{
80
160
240
320
}
0
2
}
{
4
{
160
320
480
640
}
0
2
}
{
2
{
320
640
}
0
2
}
{
4
{
80
160
240
320
}
0
2
}
{
4
{
160
320
480
640
}
0
2
}
{
2
{
320
640
}
0
2
}
{
6
{
80
160
240
320
400
480
}
0
2
}
{
6
{
80
160
240
320
400
480
}
0
2
}
{
6
{
80
160
240
320
400
480
}
0
2
}
{
6
{
80
160
240
320
400
480
}
0
2
}
#
ifdef
WEBRTC_CODEC_ILBC
{
4
{
160
240
320
480
}
0
1
}
#
endif
{
6
{
160
320
480
640
800
960
}
0
2
}
{
6
{
160
320
480
640
800
960
}
0
2
}
#
ifdef
WEBRTC_CODEC_OPUS
#
if
WEBRTC_OPUS_SUPPORT_120MS_PTIME
{
5
{
480
960
1920
2880
5760
}
0
2
}
#
else
{
4
{
480
960
1920
2880
}
0
2
}
#
endif
#
endif
{
1
{
240
}
240
1
}
{
1
{
480
}
480
1
}
{
1
{
960
}
960
1
}
#
ifdef
ENABLE_48000_HZ
{
1
{
1440
}
1440
1
}
#
endif
{
1
{
240
}
240
1
}
{
1
{
240
}
240
1
}
{
1
{
240
}
240
1
}
{
1
{
240
}
240
1
}
#
ifdef
WEBRTC_CODEC_RED
{
1
{
0
}
0
1
}
#
endif
{
-
1
{
-
1
}
-
1
0
}
}
;
const
NetEqDecoder
ACMCodecDB
:
:
neteq_decoders_
[
]
=
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
NetEqDecoder
:
:
kDecoderISAC
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
)
NetEqDecoder
:
:
kDecoderISACswb
#
endif
#
endif
NetEqDecoder
:
:
kDecoderPCM16B
NetEqDecoder
:
:
kDecoderPCM16Bwb
NetEqDecoder
:
:
kDecoderPCM16Bswb32kHz
NetEqDecoder
:
:
kDecoderPCM16B_2ch
NetEqDecoder
:
:
kDecoderPCM16Bwb_2ch
NetEqDecoder
:
:
kDecoderPCM16Bswb32kHz_2ch
NetEqDecoder
:
:
kDecoderPCMu
NetEqDecoder
:
:
kDecoderPCMa
NetEqDecoder
:
:
kDecoderPCMu_2ch
NetEqDecoder
:
:
kDecoderPCMa_2ch
#
ifdef
WEBRTC_CODEC_ILBC
NetEqDecoder
:
:
kDecoderILBC
#
endif
NetEqDecoder
:
:
kDecoderG722
NetEqDecoder
:
:
kDecoderG722_2ch
#
ifdef
WEBRTC_CODEC_OPUS
NetEqDecoder
:
:
kDecoderOpus
#
endif
NetEqDecoder
:
:
kDecoderCNGnb
NetEqDecoder
:
:
kDecoderCNGwb
NetEqDecoder
:
:
kDecoderCNGswb32kHz
#
ifdef
ENABLE_48000_HZ
NetEqDecoder
:
:
kDecoderCNGswb48kHz
#
endif
NetEqDecoder
:
:
kDecoderAVT
NetEqDecoder
:
:
kDecoderAVT16kHz
NetEqDecoder
:
:
kDecoderAVT32kHz
NetEqDecoder
:
:
kDecoderAVT48kHz
#
ifdef
WEBRTC_CODEC_RED
NetEqDecoder
:
:
kDecoderRED
#
endif
}
;
enum
{
kInvalidCodec
=
-
10
kInvalidPayloadtype
=
-
30
kInvalidPacketSize
=
-
40
kInvalidRate
=
-
50
}
;
int
ACMCodecDB
:
:
CodecNumber
(
const
CodecInst
&
codec_inst
)
{
int
codec_id
=
CodecId
(
codec_inst
)
;
if
(
codec_id
=
=
-
1
)
{
return
kInvalidCodec
;
}
if
(
!
RentACodec
:
:
IsPayloadTypeValid
(
codec_inst
.
pltype
)
)
{
return
kInvalidPayloadtype
;
}
if
(
STR_CASE_CMP
(
database_
[
codec_id
]
.
plname
"
CN
"
)
=
=
0
)
{
return
codec_id
;
}
if
(
STR_CASE_CMP
(
database_
[
codec_id
]
.
plname
"
red
"
)
=
=
0
)
{
return
codec_id
;
}
if
(
codec_settings_
[
codec_id
]
.
num_packet_sizes
>
0
)
{
bool
packet_size_ok
=
false
;
int
i
;
int
packet_size_samples
;
for
(
i
=
0
;
i
<
codec_settings_
[
codec_id
]
.
num_packet_sizes
;
i
+
+
)
{
packet_size_samples
=
codec_settings_
[
codec_id
]
.
packet_sizes_samples
[
i
]
;
if
(
codec_inst
.
pacsize
=
=
packet_size_samples
)
{
packet_size_ok
=
true
;
break
;
}
}
if
(
!
packet_size_ok
)
{
return
kInvalidPacketSize
;
}
}
if
(
codec_inst
.
pacsize
<
1
)
{
return
kInvalidPacketSize
;
}
if
(
STR_CASE_CMP
(
"
isac
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsISACRateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
ilbc
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsILBCRateValid
(
codec_inst
.
rate
codec_inst
.
pacsize
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
opus
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsOpusRateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
return
database_
[
codec_id
]
.
rate
=
=
codec_inst
.
rate
?
codec_id
:
kInvalidRate
;
}
int
ACMCodecDB
:
:
CodecId
(
const
CodecInst
&
codec_inst
)
{
return
(
CodecId
(
codec_inst
.
plname
codec_inst
.
plfreq
codec_inst
.
channels
)
)
;
}
int
ACMCodecDB
:
:
CodecId
(
const
char
*
payload_name
int
frequency
size_t
channels
)
{
for
(
const
CodecInst
&
ci
:
RentACodec
:
:
Database
(
)
)
{
bool
name_match
=
false
;
bool
frequency_match
=
false
;
bool
channels_match
=
false
;
name_match
=
(
STR_CASE_CMP
(
ci
.
plname
payload_name
)
=
=
0
)
;
frequency_match
=
(
frequency
=
=
ci
.
plfreq
)
|
|
(
frequency
=
=
-
1
)
;
if
(
STR_CASE_CMP
(
payload_name
"
opus
"
)
!
=
0
)
{
channels_match
=
(
channels
=
=
ci
.
channels
)
;
}
else
{
channels_match
=
(
channels
=
=
1
|
|
channels
=
=
2
)
;
}
if
(
name_match
&
&
frequency_match
&
&
channels_match
)
{
return
&
ci
-
RentACodec
:
:
Database
(
)
.
data
(
)
;
}
}
return
-
1
;
}
int
ACMCodecDB
:
:
ReceiverCodecNumber
(
const
CodecInst
&
codec_inst
)
{
return
CodecId
(
codec_inst
)
;
}
}
}
