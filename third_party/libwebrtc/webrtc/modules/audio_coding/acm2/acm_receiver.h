#
ifndef
MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
#
define
MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
atomic
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
optional
.
h
"
#
include
"
common_audio
/
vad
/
include
/
webrtc_vad
.
h
"
#
include
"
modules
/
audio_coding
/
acm2
/
acm_resampler
.
h
"
#
include
"
modules
/
audio_coding
/
acm2
/
call_statistics
.
h
"
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
include
/
neteq
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
struct
CodecInst
;
class
NetEq
;
namespace
acm2
{
class
AcmReceiver
{
public
:
explicit
AcmReceiver
(
const
AudioCodingModule
:
:
Config
&
config
)
;
~
AcmReceiver
(
)
;
int
InsertPacket
(
const
WebRtcRTPHeader
&
rtp_header
rtc
:
:
ArrayView
<
const
uint8_t
>
incoming_payload
)
;
int
GetAudio
(
int
desired_freq_hz
AudioFrame
*
audio_frame
bool
*
muted
)
;
void
SetCodecs
(
const
std
:
:
map
<
int
SdpAudioFormat
>
&
codecs
)
;
int
AddCodec
(
int
acm_codec_id
uint8_t
payload_type
size_t
channels
int
sample_rate_hz
AudioDecoder
*
audio_decoder
const
std
:
:
string
&
name
)
;
bool
AddCodec
(
int
rtp_payload_type
const
SdpAudioFormat
&
audio_format
)
;
int
SetMinimumDelay
(
int
delay_ms
)
;
int
SetMaximumDelay
(
int
delay_ms
)
;
int
LeastRequiredDelayMs
(
)
const
;
void
ResetInitialDelay
(
)
;
rtc
:
:
Optional
<
int
>
last_packet_sample_rate_hz
(
)
const
;
int
last_output_sample_rate_hz
(
)
const
;
void
GetNetworkStatistics
(
NetworkStatistics
*
statistics
)
;
void
FlushBuffers
(
)
;
int
RemoveCodec
(
uint8_t
payload_type
)
;
void
RemoveAllCodecs
(
)
;
rtc
:
:
Optional
<
uint32_t
>
GetPlayoutTimestamp
(
)
;
int
FilteredCurrentDelayMs
(
)
const
;
int
TargetDelayMs
(
)
const
;
int
LastAudioCodec
(
CodecInst
*
codec
)
const
;
rtc
:
:
Optional
<
SdpAudioFormat
>
LastAudioFormat
(
)
const
;
int
LastAudioSampleRate
(
)
const
;
int
DecoderByPayloadType
(
uint8_t
payload_type
CodecInst
*
codec
)
const
;
int
EnableNack
(
size_t
max_nack_list_size
)
;
void
DisableNack
(
)
;
std
:
:
vector
<
uint16_t
>
GetNackList
(
int64_t
round_trip_time_ms
)
const
;
void
GetDecodingCallStatistics
(
AudioDecodingCallStats
*
stats
)
const
;
private
:
struct
Decoder
{
int
acm_codec_id
;
uint8_t
payload_type
;
size_t
channels
;
int
sample_rate_hz
;
}
;
const
rtc
:
:
Optional
<
CodecInst
>
RtpHeaderToDecoder
(
const
RTPHeader
&
rtp_header
uint8_t
first_payload_byte
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
uint32_t
NowInTimestamp
(
int
decoder_sampling_rate
)
const
;
rtc
:
:
CriticalSection
crit_sect_
;
rtc
:
:
Optional
<
CodecInst
>
last_audio_decoder_
RTC_GUARDED_BY
(
crit_sect_
)
;
rtc
:
:
Optional
<
SdpAudioFormat
>
last_audio_format_
RTC_GUARDED_BY
(
crit_sect_
)
;
ACMResampler
resampler_
RTC_GUARDED_BY
(
crit_sect_
)
;
std
:
:
unique_ptr
<
int16_t
[
]
>
last_audio_buffer_
;
CallStatistics
call_stats_
RTC_GUARDED_BY
(
crit_sect_
)
;
const
std
:
:
unique_ptr
<
NetEq
>
neteq_
;
const
Clock
*
const
clock_
;
std
:
:
atomic
<
bool
>
resampled_last_output_frame_
;
rtc
:
:
Optional
<
int
>
last_packet_sample_rate_hz_
RTC_GUARDED_BY
(
crit_sect_
)
;
std
:
:
atomic
<
int
>
last_audio_format_clockrate_hz_
;
}
;
}
}
#
endif
