#
include
<
random
>
#
include
<
utility
>
#
include
"
modules
/
audio_coding
/
audio_network_adaptor
/
fec_controller_rplr_based
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
constexpr
int
kDisablingBandwidthLow
=
15000
;
constexpr
float
kDisablingRecoverablePacketLossAtLowBw
=
0
.
08f
;
constexpr
int
kDisablingBandwidthHigh
=
64000
;
constexpr
float
kDisablingRecoverablePacketLossAtHighBw
=
0
.
01f
;
constexpr
int
kEnablingBandwidthLow
=
17000
;
constexpr
float
kEnablingRecoverablePacketLossAtLowBw
=
0
.
1f
;
constexpr
int
kEnablingBandwidthHigh
=
64000
;
constexpr
float
kEnablingRecoverablePacketLossAtHighBw
=
0
.
05f
;
constexpr
float
kEpsilon
=
1e
-
5f
;
rtc
:
:
Optional
<
float
>
GetRandomProbabilityOrUnknown
(
)
{
std
:
:
random_device
rd
;
std
:
:
mt19937
generator
(
rd
(
)
)
;
std
:
:
uniform_real_distribution
<
>
distribution
(
0
1
)
;
return
(
distribution
(
generator
)
<
0
.
2
)
?
rtc
:
:
nullopt
:
rtc
:
:
Optional
<
float
>
(
distribution
(
generator
)
)
;
}
std
:
:
unique_ptr
<
FecControllerRplrBased
>
CreateFecControllerRplrBased
(
bool
initial_fec_enabled
)
{
return
std
:
:
unique_ptr
<
FecControllerRplrBased
>
(
new
FecControllerRplrBased
(
FecControllerRplrBased
:
:
Config
(
initial_fec_enabled
ThresholdCurve
(
kEnablingBandwidthLow
kEnablingRecoverablePacketLossAtLowBw
kEnablingBandwidthHigh
kEnablingRecoverablePacketLossAtHighBw
)
ThresholdCurve
(
kDisablingBandwidthLow
kDisablingRecoverablePacketLossAtLowBw
kDisablingBandwidthHigh
kDisablingRecoverablePacketLossAtHighBw
)
)
)
)
;
}
void
UpdateNetworkMetrics
(
FecControllerRplrBased
*
controller
const
rtc
:
:
Optional
<
int
>
&
uplink_bandwidth_bps
const
rtc
:
:
Optional
<
float
>
&
uplink_packet_loss
const
rtc
:
:
Optional
<
float
>
&
uplink_recoveralbe_packet_loss
)
{
if
(
uplink_bandwidth_bps
)
{
Controller
:
:
NetworkMetrics
network_metrics
;
network_metrics
.
uplink_bandwidth_bps
=
uplink_bandwidth_bps
;
controller
-
>
UpdateNetworkMetrics
(
network_metrics
)
;
}
if
(
uplink_packet_loss
)
{
Controller
:
:
NetworkMetrics
network_metrics
;
network_metrics
.
uplink_packet_loss_fraction
=
uplink_packet_loss
;
controller
-
>
UpdateNetworkMetrics
(
network_metrics
)
;
}
if
(
uplink_recoveralbe_packet_loss
)
{
Controller
:
:
NetworkMetrics
network_metrics
;
network_metrics
.
uplink_recoverable_packet_loss_fraction
=
uplink_recoveralbe_packet_loss
;
controller
-
>
UpdateNetworkMetrics
(
network_metrics
)
;
}
}
void
UpdateNetworkMetrics
(
FecControllerRplrBased
*
controller
const
rtc
:
:
Optional
<
int
>
&
uplink_bandwidth_bps
const
rtc
:
:
Optional
<
float
>
&
uplink_recoveralbe_packet_loss
)
{
UpdateNetworkMetrics
(
controller
uplink_bandwidth_bps
GetRandomProbabilityOrUnknown
(
)
uplink_recoveralbe_packet_loss
)
;
}
void
CheckDecision
(
FecControllerRplrBased
*
controller
bool
expected_enable_fec
float
expected_uplink_packet_loss_fraction
)
{
AudioEncoderRuntimeConfig
config
;
controller
-
>
MakeDecision
(
&
config
)
;
EXPECT_TRUE
(
config
.
enable_fec
)
;
if
(
config
.
enable_fec
)
{
EXPECT_EQ
(
expected_enable_fec
*
config
.
enable_fec
)
;
}
EXPECT_TRUE
(
config
.
uplink_packet_loss_fraction
)
;
if
(
config
.
uplink_packet_loss_fraction
)
{
EXPECT_EQ
(
expected_uplink_packet_loss_fraction
*
config
.
uplink_packet_loss_fraction
)
;
}
}
}
TEST
(
FecControllerRplrBasedTest
OutputInitValueBeforeAnyInputsAreReceived
)
{
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
auto
controller
=
CreateFecControllerRplrBased
(
initial_fec_enabled
)
;
CheckDecision
(
controller
.
get
(
)
initial_fec_enabled
0
)
;
}
}
TEST
(
FecControllerRplrBasedTest
OutputInitValueWhenUplinkBandwidthUnknown
)
{
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
for
(
float
recoverable_packet_loss
:
{
kDisablingRecoverablePacketLossAtHighBw
-
kEpsilon
kDisablingRecoverablePacketLossAtHighBw
kDisablingRecoverablePacketLossAtHighBw
+
kEpsilon
kEnablingRecoverablePacketLossAtHighBw
-
kEpsilon
kEnablingRecoverablePacketLossAtHighBw
kEnablingRecoverablePacketLossAtHighBw
+
kEpsilon
}
)
{
auto
controller
=
CreateFecControllerRplrBased
(
initial_fec_enabled
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
rtc
:
:
nullopt
recoverable_packet_loss
)
;
CheckDecision
(
controller
.
get
(
)
initial_fec_enabled
recoverable_packet_loss
)
;
}
}
}
TEST
(
FecControllerRplrBasedTest
OutputInitValueWhenUplinkRecoverablePacketLossFractionUnknown
)
{
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
for
(
int
bandwidth
:
{
kDisablingBandwidthLow
-
1
kDisablingBandwidthLow
kDisablingBandwidthLow
+
1
kEnablingBandwidthLow
-
1
kEnablingBandwidthLow
kEnablingBandwidthLow
+
1
}
)
{
auto
controller
=
CreateFecControllerRplrBased
(
initial_fec_enabled
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
bandwidth
rtc
:
:
nullopt
)
;
CheckDecision
(
controller
.
get
(
)
initial_fec_enabled
0
.
0
)
;
}
}
}
TEST
(
FecControllerRplrBasedTest
EnableFecForHighBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthHigh
kEnablingRecoverablePacketLossAtHighBw
)
;
CheckDecision
(
controller
.
get
(
)
true
kEnablingRecoverablePacketLossAtHighBw
)
;
}
TEST
(
FecControllerRplrBasedTest
UpdateMultipleNetworkMetricsAtOnce
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
Controller
:
:
NetworkMetrics
network_metrics
;
network_metrics
.
uplink_bandwidth_bps
=
kEnablingBandwidthHigh
;
network_metrics
.
uplink_packet_loss_fraction
=
GetRandomProbabilityOrUnknown
(
)
;
network_metrics
.
uplink_recoverable_packet_loss_fraction
=
kEnablingRecoverablePacketLossAtHighBw
;
controller
-
>
UpdateNetworkMetrics
(
network_metrics
)
;
CheckDecision
(
controller
.
get
(
)
true
kEnablingRecoverablePacketLossAtHighBw
)
;
}
TEST
(
FecControllerRplrBasedTest
MaintainFecOffForHighBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
constexpr
float
kRecoverablePacketLoss
=
kEnablingRecoverablePacketLossAtHighBw
*
0
.
99f
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthHigh
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
false
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
EnableFecForMediumBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
constexpr
float
kRecoverablePacketLoss
=
(
kEnablingRecoverablePacketLossAtLowBw
+
kEnablingRecoverablePacketLossAtHighBw
)
/
2
.
0
;
UpdateNetworkMetrics
(
controller
.
get
(
)
(
kEnablingBandwidthHigh
+
kEnablingBandwidthLow
)
/
2
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
true
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
MaintainFecOffForMediumBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
constexpr
float
kRecoverablePacketLoss
=
kEnablingRecoverablePacketLossAtLowBw
*
0
.
49f
+
kEnablingRecoverablePacketLossAtHighBw
*
0
.
51f
;
UpdateNetworkMetrics
(
controller
.
get
(
)
(
kEnablingBandwidthHigh
+
kEnablingBandwidthLow
)
/
2
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
false
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
EnableFecForLowBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthLow
kEnablingRecoverablePacketLossAtLowBw
)
;
CheckDecision
(
controller
.
get
(
)
true
kEnablingRecoverablePacketLossAtLowBw
)
;
}
TEST
(
FecControllerRplrBasedTest
MaintainFecOffForLowBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
constexpr
float
kRecoverablePacketLoss
=
kEnablingRecoverablePacketLossAtLowBw
*
0
.
99f
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthLow
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
false
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
MaintainFecOffForVeryLowBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
false
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthLow
-
1
1
.
0
)
;
CheckDecision
(
controller
.
get
(
)
false
1
.
0
)
;
}
TEST
(
FecControllerRplrBasedTest
DisableFecForHighBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
constexpr
float
kRecoverablePacketLoss
=
kDisablingRecoverablePacketLossAtHighBw
-
kEpsilon
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthHigh
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
false
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
MaintainFecOnForHighBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthHigh
kDisablingRecoverablePacketLossAtHighBw
)
;
CheckDecision
(
controller
.
get
(
)
true
kDisablingRecoverablePacketLossAtHighBw
)
;
}
TEST
(
FecControllerRplrBasedTest
DisableFecOnMediumBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
constexpr
float
kRecoverablePacketLoss
=
(
(
kDisablingRecoverablePacketLossAtLowBw
+
kDisablingRecoverablePacketLossAtHighBw
)
/
2
.
0f
)
-
kEpsilon
;
UpdateNetworkMetrics
(
controller
.
get
(
)
(
kDisablingBandwidthHigh
+
kDisablingBandwidthLow
)
/
2
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
false
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
MaintainFecOnForMediumBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
constexpr
float
kRecoverablePacketLoss
=
kDisablingRecoverablePacketLossAtLowBw
*
0
.
51f
+
kDisablingRecoverablePacketLossAtHighBw
*
0
.
49f
-
kEpsilon
;
UpdateNetworkMetrics
(
controller
.
get
(
)
(
kEnablingBandwidthHigh
+
kDisablingBandwidthLow
)
/
2
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
true
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
DisableFecForLowBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
constexpr
float
kRecoverablePacketLoss
=
kDisablingRecoverablePacketLossAtLowBw
-
kEpsilon
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthLow
kRecoverablePacketLoss
)
;
CheckDecision
(
controller
.
get
(
)
false
kRecoverablePacketLoss
)
;
}
TEST
(
FecControllerRplrBasedTest
DisableFecForVeryLowBandwidth
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthLow
-
1
1
.
0
)
;
CheckDecision
(
controller
.
get
(
)
false
1
.
0
)
;
}
TEST
(
FecControllerRplrBasedTest
CheckBehaviorOnChangingNetworkMetrics
)
{
auto
controller
=
CreateFecControllerRplrBased
(
true
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthLow
-
1
1
.
0
)
;
CheckDecision
(
controller
.
get
(
)
false
1
.
0
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthLow
kEnablingRecoverablePacketLossAtLowBw
*
0
.
99f
)
;
CheckDecision
(
controller
.
get
(
)
false
kEnablingRecoverablePacketLossAtLowBw
*
0
.
99f
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kEnablingBandwidthHigh
kEnablingRecoverablePacketLossAtHighBw
)
;
CheckDecision
(
controller
.
get
(
)
true
kEnablingRecoverablePacketLossAtHighBw
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthHigh
kDisablingRecoverablePacketLossAtHighBw
)
;
CheckDecision
(
controller
.
get
(
)
true
kDisablingRecoverablePacketLossAtHighBw
)
;
UpdateNetworkMetrics
(
controller
.
get
(
)
kDisablingBandwidthHigh
+
1
0
.
0
)
;
CheckDecision
(
controller
.
get
(
)
false
0
.
0
)
;
}
TEST
(
FecControllerRplrBasedTest
CheckBehaviorOnSpecialCurves
)
{
constexpr
int
kEnablingBandwidthHigh
=
kEnablingBandwidthLow
;
constexpr
float
kDisablingRecoverablePacketLossAtLowBw
=
kDisablingRecoverablePacketLossAtHighBw
;
FecControllerRplrBased
controller
(
FecControllerRplrBased
:
:
Config
(
true
ThresholdCurve
(
kEnablingBandwidthLow
kEnablingRecoverablePacketLossAtLowBw
kEnablingBandwidthHigh
kEnablingRecoverablePacketLossAtHighBw
)
ThresholdCurve
(
kDisablingBandwidthLow
kDisablingRecoverablePacketLossAtLowBw
kDisablingBandwidthHigh
kDisablingRecoverablePacketLossAtHighBw
)
)
)
;
UpdateNetworkMetrics
(
&
controller
kDisablingBandwidthLow
-
1
1
.
0
)
;
CheckDecision
(
&
controller
false
1
.
0
)
;
UpdateNetworkMetrics
(
&
controller
kEnablingBandwidthLow
kEnablingRecoverablePacketLossAtHighBw
*
0
.
99f
)
;
CheckDecision
(
&
controller
false
kEnablingRecoverablePacketLossAtHighBw
*
0
.
99f
)
;
UpdateNetworkMetrics
(
&
controller
kEnablingBandwidthHigh
kEnablingRecoverablePacketLossAtHighBw
)
;
CheckDecision
(
&
controller
true
kEnablingRecoverablePacketLossAtHighBw
)
;
UpdateNetworkMetrics
(
&
controller
kDisablingBandwidthHigh
kDisablingRecoverablePacketLossAtHighBw
)
;
CheckDecision
(
&
controller
true
kDisablingRecoverablePacketLossAtHighBw
)
;
UpdateNetworkMetrics
(
&
controller
kDisablingBandwidthHigh
+
1
0
.
0
)
;
CheckDecision
(
&
controller
false
0
.
0
)
;
}
TEST
(
FecControllerRplrBasedTest
SingleThresholdCurveForEnablingAndDisabling
)
{
constexpr
int
kBandwidthLow
=
10000
;
constexpr
float
kRecoverablePacketLossAtLowBw
=
0
.
25f
;
constexpr
int
kBandwidthHigh
=
20000
;
constexpr
float
kRecoverablePacketLossAtHighBw
=
0
.
125f
;
auto
curve
=
ThresholdCurve
(
kBandwidthLow
kRecoverablePacketLossAtLowBw
kBandwidthHigh
kRecoverablePacketLossAtHighBw
)
;
struct
NetworkState
{
int
bandwidth
;
float
recoverable_packet_loss
;
}
;
std
:
:
vector
<
NetworkState
>
below
{
{
kBandwidthLow
-
1
kRecoverablePacketLossAtLowBw
+
0
.
1f
}
{
(
kBandwidthLow
+
kBandwidthHigh
)
/
2
(
kRecoverablePacketLossAtLowBw
+
kRecoverablePacketLossAtHighBw
)
/
2
-
kEpsilon
}
{
kBandwidthHigh
+
1
kRecoverablePacketLossAtHighBw
-
kEpsilon
}
}
;
std
:
:
vector
<
NetworkState
>
on
{
{
kBandwidthLow
kRecoverablePacketLossAtLowBw
+
0
.
1f
}
{
kBandwidthLow
kRecoverablePacketLossAtLowBw
}
{
(
kBandwidthLow
+
kBandwidthHigh
)
/
2
(
kRecoverablePacketLossAtLowBw
+
kRecoverablePacketLossAtHighBw
)
/
2
}
{
kBandwidthHigh
kRecoverablePacketLossAtHighBw
}
{
kBandwidthHigh
+
1
kRecoverablePacketLossAtHighBw
}
}
;
std
:
:
vector
<
NetworkState
>
above
{
{
(
kBandwidthLow
+
kBandwidthHigh
)
/
2
(
kRecoverablePacketLossAtLowBw
+
kRecoverablePacketLossAtHighBw
)
/
2
+
kEpsilon
}
{
kBandwidthHigh
+
1
kRecoverablePacketLossAtHighBw
+
kEpsilon
}
}
;
for
(
NetworkState
net_state
:
below
)
{
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
FecControllerRplrBased
controller
(
FecControllerRplrBased
:
:
Config
(
initial_fec_enabled
curve
curve
)
)
;
UpdateNetworkMetrics
(
&
controller
net_state
.
bandwidth
net_state
.
recoverable_packet_loss
)
;
CheckDecision
(
&
controller
false
net_state
.
recoverable_packet_loss
)
;
}
}
for
(
std
:
:
vector
<
NetworkState
>
states_list
:
{
on
above
}
)
{
for
(
NetworkState
net_state
:
states_list
)
{
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
FecControllerRplrBased
controller
(
FecControllerRplrBased
:
:
Config
(
initial_fec_enabled
curve
curve
)
)
;
UpdateNetworkMetrics
(
&
controller
net_state
.
bandwidth
net_state
.
recoverable_packet_loss
)
;
CheckDecision
(
&
controller
true
net_state
.
recoverable_packet_loss
)
;
}
}
}
}
TEST
(
FecControllerRplrBasedTest
FecAlwaysOff
)
{
ThresholdCurve
always_off_curve
(
0
1
.
0f
+
kEpsilon
0
1
.
0f
+
kEpsilon
)
;
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
for
(
int
bandwidth
:
{
0
10000
}
)
{
for
(
float
recoverable_packet_loss
:
{
0
.
0f
0
.
5f
1
.
0f
}
)
{
FecControllerRplrBased
controller
(
FecControllerRplrBased
:
:
Config
(
initial_fec_enabled
always_off_curve
always_off_curve
)
)
;
UpdateNetworkMetrics
(
&
controller
bandwidth
recoverable_packet_loss
)
;
CheckDecision
(
&
controller
false
recoverable_packet_loss
)
;
}
}
}
}
TEST
(
FecControllerRplrBasedTest
FecAlwaysOn
)
{
ThresholdCurve
always_on_curve
(
0
0
.
0f
0
0
.
0f
)
;
for
(
bool
initial_fec_enabled
:
{
false
true
}
)
{
for
(
int
bandwidth
:
{
0
10000
}
)
{
for
(
float
recoverable_packet_loss
:
{
0
.
0f
0
.
5f
1
.
0f
}
)
{
FecControllerRplrBased
controller
(
FecControllerRplrBased
:
:
Config
(
initial_fec_enabled
always_on_curve
always_on_curve
)
)
;
UpdateNetworkMetrics
(
&
controller
bandwidth
recoverable_packet_loss
)
;
CheckDecision
(
&
controller
true
recoverable_packet_loss
)
;
}
}
}
}
#
if
RTC_DCHECK_IS_ON
&
&
GTEST_HAS_DEATH_TEST
&
&
!
defined
(
WEBRTC_ANDROID
)
TEST
(
FecControllerRplrBasedDeathTest
InvalidConfig
)
{
EXPECT_DEATH
(
FecControllerRplrBased
controller
(
FecControllerRplrBased
:
:
Config
(
true
ThresholdCurve
(
kDisablingBandwidthLow
-
1
kEnablingRecoverablePacketLossAtLowBw
kEnablingBandwidthHigh
kEnablingRecoverablePacketLossAtHighBw
)
ThresholdCurve
(
kDisablingBandwidthLow
kDisablingRecoverablePacketLossAtLowBw
kDisablingBandwidthHigh
kDisablingRecoverablePacketLossAtHighBw
)
)
)
"
Check
failed
"
)
;
}
#
endif
}
