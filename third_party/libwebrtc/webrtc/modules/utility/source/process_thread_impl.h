#
ifndef
MODULES_UTILITY_SOURCE_PROCESS_THREAD_IMPL_H_
#
define
MODULES_UTILITY_SOURCE_PROCESS_THREAD_IMPL_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
queue
>
#
include
"
modules
/
utility
/
include
/
process_thread
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
#
include
"
system_wrappers
/
include
/
event_wrapper
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
class
ProcessThreadImpl
:
public
ProcessThread
{
public
:
explicit
ProcessThreadImpl
(
const
char
*
thread_name
)
;
~
ProcessThreadImpl
(
)
override
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
WakeUp
(
Module
*
module
)
override
;
void
PostTask
(
std
:
:
unique_ptr
<
rtc
:
:
QueuedTask
>
task
)
override
;
void
RegisterModule
(
Module
*
module
const
rtc
:
:
Location
&
from
)
override
;
void
DeRegisterModule
(
Module
*
module
)
override
;
protected
:
static
bool
Run
(
void
*
obj
)
;
bool
Process
(
)
;
private
:
struct
ModuleCallback
{
ModuleCallback
(
)
=
delete
;
ModuleCallback
(
ModuleCallback
&
&
cb
)
=
default
;
ModuleCallback
(
const
ModuleCallback
&
cb
)
=
default
;
ModuleCallback
(
Module
*
module
const
rtc
:
:
Location
&
location
)
:
module
(
module
)
location
(
location
)
{
}
bool
operator
=
=
(
const
ModuleCallback
&
cb
)
const
{
return
cb
.
module
=
=
module
;
}
Module
*
const
module
;
int64_t
next_callback
=
0
;
const
rtc
:
:
Location
location
;
private
:
ModuleCallback
&
operator
=
(
ModuleCallback
&
)
;
}
;
typedef
std
:
:
list
<
ModuleCallback
>
ModuleList
;
rtc
:
:
CriticalSection
lock_
;
rtc
:
:
ThreadChecker
thread_checker_
;
const
std
:
:
unique_ptr
<
EventWrapper
>
wake_up_
;
std
:
:
unique_ptr
<
rtc
:
:
PlatformThread
>
thread_
;
ModuleList
modules_
;
std
:
:
queue
<
rtc
:
:
QueuedTask
*
>
queue_
;
bool
stop_
;
const
char
*
thread_name_
;
}
;
}
#
endif
