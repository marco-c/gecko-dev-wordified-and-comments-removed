#
ifndef
MODULES_VIDEO_CODING_CODECS_TEST_VIDEOPROCESSOR_H_
#
define
MODULES_VIDEO_CODING_CODECS_TEST_VIDEOPROCESSOR_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
h264
/
include
/
h264_globals
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
test
/
packet_manipulator
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
test
/
stats
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
test
/
test_config
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_codec_interface
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
ivf_file_writer
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
vp8_header_parser
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
vp9_uncompressed_header_parser
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
sequenced_task_checker
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
test
/
testsupport
/
frame_reader
.
h
"
#
include
"
test
/
testsupport
/
frame_writer
.
h
"
namespace
webrtc
{
class
VideoBitrateAllocator
;
namespace
test
{
class
VideoProcessor
{
public
:
VideoProcessor
(
webrtc
:
:
VideoEncoder
*
encoder
webrtc
:
:
VideoDecoder
*
decoder
FrameReader
*
analysis_frame_reader
PacketManipulator
*
packet_manipulator
const
TestConfig
&
config
Stats
*
stats
IvfFileWriter
*
encoded_frame_writer
FrameWriter
*
decoded_frame_writer
)
;
~
VideoProcessor
(
)
;
void
ProcessFrame
(
)
;
void
SetRates
(
int
bitrate_kbps
int
framerate_fps
)
;
std
:
:
vector
<
int
>
NumberDroppedFramesPerRateUpdate
(
)
const
;
std
:
:
vector
<
int
>
NumberSpatialResizesPerRateUpdate
(
)
const
;
private
:
class
VideoProcessorEncodeCompleteCallback
:
public
webrtc
:
:
EncodedImageCallback
{
public
:
explicit
VideoProcessorEncodeCompleteCallback
(
VideoProcessor
*
video_processor
)
:
video_processor_
(
video_processor
)
task_queue_
(
rtc
:
:
TaskQueue
:
:
Current
(
)
)
{
}
Result
OnEncodedImage
(
const
webrtc
:
:
EncodedImage
&
encoded_image
const
webrtc
:
:
CodecSpecificInfo
*
codec_specific_info
const
webrtc
:
:
RTPFragmentationHeader
*
fragmentation
)
override
{
RTC_CHECK
(
codec_specific_info
)
;
if
(
task_queue_
&
&
!
task_queue_
-
>
IsCurrent
(
)
)
{
task_queue_
-
>
PostTask
(
std
:
:
unique_ptr
<
rtc
:
:
QueuedTask
>
(
new
EncodeCallbackTask
(
video_processor_
encoded_image
codec_specific_info
)
)
)
;
return
Result
(
Result
:
:
OK
0
)
;
}
video_processor_
-
>
FrameEncoded
(
codec_specific_info
-
>
codecType
encoded_image
)
;
return
Result
(
Result
:
:
OK
0
)
;
}
private
:
class
EncodeCallbackTask
:
public
rtc
:
:
QueuedTask
{
public
:
EncodeCallbackTask
(
VideoProcessor
*
video_processor
const
webrtc
:
:
EncodedImage
&
encoded_image
const
webrtc
:
:
CodecSpecificInfo
*
codec_specific_info
)
:
video_processor_
(
video_processor
)
buffer_
(
encoded_image
.
_buffer
encoded_image
.
_length
)
encoded_image_
(
encoded_image
)
codec_specific_info_
(
*
codec_specific_info
)
{
encoded_image_
.
_buffer
=
buffer_
.
data
(
)
;
}
bool
Run
(
)
override
{
video_processor_
-
>
FrameEncoded
(
codec_specific_info_
.
codecType
encoded_image_
)
;
return
true
;
}
private
:
VideoProcessor
*
const
video_processor_
;
rtc
:
:
Buffer
buffer_
;
webrtc
:
:
EncodedImage
encoded_image_
;
const
webrtc
:
:
CodecSpecificInfo
codec_specific_info_
;
}
;
VideoProcessor
*
const
video_processor_
;
rtc
:
:
TaskQueue
*
const
task_queue_
;
}
;
class
VideoProcessorDecodeCompleteCallback
:
public
webrtc
:
:
DecodedImageCallback
{
public
:
explicit
VideoProcessorDecodeCompleteCallback
(
VideoProcessor
*
video_processor
)
:
video_processor_
(
video_processor
)
task_queue_
(
rtc
:
:
TaskQueue
:
:
Current
(
)
)
{
}
int32_t
Decoded
(
webrtc
:
:
VideoFrame
&
image
)
override
{
if
(
task_queue_
&
&
!
task_queue_
-
>
IsCurrent
(
)
)
{
task_queue_
-
>
PostTask
(
[
this
image
]
(
)
{
video_processor_
-
>
FrameDecoded
(
image
)
;
}
)
;
return
0
;
}
video_processor_
-
>
FrameDecoded
(
image
)
;
return
0
;
}
int32_t
Decoded
(
webrtc
:
:
VideoFrame
&
image
int64_t
decode_time_ms
)
override
{
return
Decoded
(
image
)
;
}
void
Decoded
(
webrtc
:
:
VideoFrame
&
image
rtc
:
:
Optional
<
int32_t
>
decode_time_ms
rtc
:
:
Optional
<
uint8_t
>
qp
)
override
{
Decoded
(
image
)
;
}
private
:
VideoProcessor
*
const
video_processor_
;
rtc
:
:
TaskQueue
*
const
task_queue_
;
}
;
void
FrameEncoded
(
webrtc
:
:
VideoCodecType
codec
const
webrtc
:
:
EncodedImage
&
encodedImage
)
;
void
FrameDecoded
(
const
webrtc
:
:
VideoFrame
&
image
)
;
void
WriteDecodedFrameToFile
(
rtc
:
:
Buffer
*
buffer
)
;
bool
ExcludeFrame
(
const
EncodedImage
&
encoded_image
)
;
TestConfig
config_
RTC_GUARDED_BY
(
sequence_checker_
)
;
webrtc
:
:
VideoEncoder
*
const
encoder_
;
webrtc
:
:
VideoDecoder
*
const
decoder_
;
const
std
:
:
unique_ptr
<
VideoBitrateAllocator
>
bitrate_allocator_
;
VideoProcessorEncodeCompleteCallback
encode_callback_
;
VideoProcessorDecodeCompleteCallback
decode_callback_
;
PacketManipulator
*
const
packet_manipulator_
;
std
:
:
map
<
int
std
:
:
unique_ptr
<
VideoFrame
>
>
input_frames_
RTC_GUARDED_BY
(
sequence_checker_
)
;
FrameReader
*
const
analysis_frame_reader_
;
IvfFileWriter
*
const
encoded_frame_writer_
;
FrameWriter
*
const
decoded_frame_writer_
;
int
last_inputed_frame_num_
RTC_GUARDED_BY
(
sequence_checker_
)
;
int
last_encoded_frame_num_
RTC_GUARDED_BY
(
sequence_checker_
)
;
int
last_decoded_frame_num_
RTC_GUARDED_BY
(
sequence_checker_
)
;
std
:
:
map
<
uint32_t
int
>
rtp_timestamp_to_frame_num_
RTC_GUARDED_BY
(
sequence_checker_
)
;
bool
first_key_frame_has_been_excluded_
RTC_GUARDED_BY
(
sequence_checker_
)
;
rtc
:
:
Buffer
last_decoded_frame_buffer_
RTC_GUARDED_BY
(
sequence_checker_
)
;
Stats
*
stats_
;
std
:
:
vector
<
int
>
num_dropped_frames_
RTC_GUARDED_BY
(
sequence_checker_
)
;
std
:
:
vector
<
int
>
num_spatial_resizes_
RTC_GUARDED_BY
(
sequence_checker_
)
;
int
rate_update_index_
RTC_GUARDED_BY
(
sequence_checker_
)
;
rtc
:
:
SequencedTaskChecker
sequence_checker_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
VideoProcessor
)
;
}
;
}
}
#
endif
