#
ifndef
MODULES_AUDIO_DEVICE_INCLUDE_AUDIO_DEVICE_DEFINES_H_
#
define
MODULES_AUDIO_DEVICE_INCLUDE_AUDIO_DEVICE_DEFINES_H_
#
include
<
stddef
.
h
>
#
include
"
typedefs
.
h
"
namespace
webrtc
{
static
const
int
kAdmMaxDeviceNameSize
=
128
;
static
const
int
kAdmMaxFileNameSize
=
512
;
static
const
int
kAdmMaxGuidSize
=
128
;
static
const
int
kAdmMinPlayoutBufferSizeMs
=
10
;
static
const
int
kAdmMaxPlayoutBufferSizeMs
=
250
;
class
AudioTransport
{
public
:
virtual
int32_t
RecordedDataIsAvailable
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
=
0
;
virtual
int32_t
NeedMorePlayData
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
=
0
;
virtual
void
PushCaptureData
(
int
voe_channel
const
void
*
audio_data
int
bits_per_sample
int
sample_rate
size_t
number_of_channels
size_t
number_of_frames
)
=
0
;
virtual
void
PullRenderData
(
int
bits_per_sample
int
sample_rate
size_t
number_of_channels
size_t
number_of_frames
void
*
audio_data
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
=
0
;
protected
:
virtual
~
AudioTransport
(
)
{
}
}
;
class
AudioParameters
{
public
:
static
const
size_t
kBitsPerSample
=
16
;
AudioParameters
(
)
:
sample_rate_
(
0
)
channels_
(
0
)
frames_per_buffer_
(
0
)
frames_per_10ms_buffer_
(
0
)
{
}
AudioParameters
(
int
sample_rate
size_t
channels
size_t
frames_per_buffer
)
:
sample_rate_
(
sample_rate
)
channels_
(
channels
)
frames_per_buffer_
(
frames_per_buffer
)
frames_per_10ms_buffer_
(
static_cast
<
size_t
>
(
sample_rate
/
100
)
)
{
}
void
reset
(
int
sample_rate
size_t
channels
size_t
frames_per_buffer
)
{
sample_rate_
=
sample_rate
;
channels_
=
channels
;
frames_per_buffer_
=
frames_per_buffer
;
frames_per_10ms_buffer_
=
static_cast
<
size_t
>
(
sample_rate
/
100
)
;
}
size_t
bits_per_sample
(
)
const
{
return
kBitsPerSample
;
}
void
reset
(
int
sample_rate
size_t
channels
double
ms_per_buffer
)
{
reset
(
sample_rate
channels
static_cast
<
size_t
>
(
sample_rate
*
ms_per_buffer
+
0
.
5
)
)
;
}
void
reset
(
int
sample_rate
size_t
channels
)
{
reset
(
sample_rate
channels
static_cast
<
size_t
>
(
0
)
)
;
}
int
sample_rate
(
)
const
{
return
sample_rate_
;
}
size_t
channels
(
)
const
{
return
channels_
;
}
size_t
frames_per_buffer
(
)
const
{
return
frames_per_buffer_
;
}
size_t
frames_per_10ms_buffer
(
)
const
{
return
frames_per_10ms_buffer_
;
}
size_t
GetBytesPerFrame
(
)
const
{
return
channels_
*
kBitsPerSample
/
8
;
}
size_t
GetBytesPerBuffer
(
)
const
{
return
frames_per_buffer_
*
GetBytesPerFrame
(
)
;
}
bool
is_valid
(
)
const
{
return
(
(
sample_rate_
>
0
)
&
&
(
channels_
>
0
)
)
;
}
bool
is_complete
(
)
const
{
return
(
is_valid
(
)
&
&
(
frames_per_buffer_
>
0
)
)
;
}
size_t
GetBytesPer10msBuffer
(
)
const
{
return
frames_per_10ms_buffer_
*
GetBytesPerFrame
(
)
;
}
double
GetBufferSizeInMilliseconds
(
)
const
{
if
(
sample_rate_
=
=
0
)
return
0
.
0
;
return
frames_per_buffer_
/
(
sample_rate_
/
1000
.
0
)
;
}
double
GetBufferSizeInSeconds
(
)
const
{
if
(
sample_rate_
=
=
0
)
return
0
.
0
;
return
static_cast
<
double
>
(
frames_per_buffer_
)
/
(
sample_rate_
)
;
}
private
:
int
sample_rate_
;
size_t
channels_
;
size_t
frames_per_buffer_
;
size_t
frames_per_10ms_buffer_
;
}
;
}
#
endif
