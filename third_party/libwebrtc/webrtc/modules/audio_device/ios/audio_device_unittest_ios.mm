#
include
<
algorithm
>
#
include
<
limits
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
numeric
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
modules
/
audio_device
/
audio_device_impl
.
h
"
#
include
"
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
modules
/
audio_device
/
include
/
mock_audio_transport
.
h
"
#
include
"
modules
/
audio_device
/
ios
/
audio_device_ios
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
format_macros
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
#
include
"
system_wrappers
/
include
/
event_wrapper
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
testsupport
/
fileutils
.
h
"
#
import
"
sdk
/
objc
/
Framework
/
Classes
/
Audio
/
RTCAudioSession
+
Private
.
h
"
#
import
"
sdk
/
objc
/
Framework
/
Headers
/
WebRTC
/
RTCAudioSession
.
h
"
using
std
:
:
cout
;
using
std
:
:
endl
;
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AtLeast
;
using
:
:
testing
:
:
Gt
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
NotNull
;
using
:
:
testing
:
:
Return
;
#
ifdef
ENABLE_DEBUG_PRINTF
#
define
PRINTD
(
.
.
.
)
fprintf
(
stderr
__VA_ARGS__
)
;
#
else
#
define
PRINTD
(
.
.
.
)
(
(
void
)
0
)
#
endif
#
define
PRINT
(
.
.
.
)
fprintf
(
stderr
__VA_ARGS__
)
;
namespace
webrtc
{
static
const
size_t
kNumCallbacks
=
10
;
static
const
int
kTestTimeOutInMilliseconds
=
10
*
1000
;
static
const
size_t
kBitsPerSample
=
16
;
static
const
size_t
kBytesPerSample
=
kBitsPerSample
/
8
;
static
const
size_t
kNumCallbacksPerSecond
=
100
;
static
const
int
kFilePlayTimeInSec
=
15
;
static
const
int
kFullDuplexTimeInSec
=
10
;
static
const
size_t
kNumIgnoreFirstCallbacks
=
50
;
static
const
int
kImpulseFrequencyInHz
=
1
;
static
const
int
kMeasureLatencyTimeInSec
=
5
;
static
const
int
kImpulseThreshold
=
50
;
static
const
char
kTag
[
]
=
"
[
.
.
.
.
.
.
.
.
.
.
]
"
;
enum
TransportType
{
kPlayout
=
0x1
kRecording
=
0x2
}
;
class
AudioStreamInterface
{
public
:
virtual
void
Write
(
const
void
*
source
size_t
num_frames
)
=
0
;
virtual
void
Read
(
void
*
destination
size_t
num_frames
)
=
0
;
protected
:
virtual
~
AudioStreamInterface
(
)
{
}
}
;
class
FileAudioStream
:
public
AudioStreamInterface
{
public
:
FileAudioStream
(
size_t
num_callbacks
const
std
:
:
string
&
file_name
int
sample_rate
)
:
file_size_in_bytes_
(
0
)
sample_rate_
(
sample_rate
)
file_pos_
(
0
)
{
file_size_in_bytes_
=
test
:
:
GetFileSize
(
file_name
)
;
sample_rate_
=
sample_rate
;
EXPECT_GE
(
file_size_in_callbacks
(
)
num_callbacks
)
<
<
"
Size
of
test
file
is
not
large
enough
to
last
during
the
test
.
"
;
const
size_t
num_16bit_samples
=
test
:
:
GetFileSize
(
file_name
)
/
kBytesPerSample
;
file_
.
reset
(
new
int16_t
[
num_16bit_samples
]
)
;
FILE
*
audio_file
=
fopen
(
file_name
.
c_str
(
)
"
rb
"
)
;
EXPECT_NE
(
audio_file
nullptr
)
;
size_t
num_samples_read
=
fread
(
file_
.
get
(
)
sizeof
(
int16_t
)
num_16bit_samples
audio_file
)
;
EXPECT_EQ
(
num_samples_read
num_16bit_samples
)
;
fclose
(
audio_file
)
;
}
void
Write
(
const
void
*
source
size_t
num_frames
)
override
{
}
void
Read
(
void
*
destination
size_t
num_frames
)
override
{
memcpy
(
destination
static_cast
<
int16_t
*
>
(
&
file_
[
file_pos_
]
)
num_frames
*
sizeof
(
int16_t
)
)
;
file_pos_
+
=
num_frames
;
}
int
file_size_in_seconds
(
)
const
{
return
static_cast
<
int
>
(
file_size_in_bytes_
/
(
kBytesPerSample
*
sample_rate_
)
)
;
}
size_t
file_size_in_callbacks
(
)
const
{
return
file_size_in_seconds
(
)
*
kNumCallbacksPerSecond
;
}
private
:
size_t
file_size_in_bytes_
;
int
sample_rate_
;
std
:
:
unique_ptr
<
int16_t
[
]
>
file_
;
size_t
file_pos_
;
}
;
class
FifoAudioStream
:
public
AudioStreamInterface
{
public
:
explicit
FifoAudioStream
(
size_t
frames_per_buffer
)
:
frames_per_buffer_
(
frames_per_buffer
)
bytes_per_buffer_
(
frames_per_buffer_
*
sizeof
(
int16_t
)
)
fifo_
(
new
AudioBufferList
)
largest_size_
(
0
)
total_written_elements_
(
0
)
write_count_
(
0
)
{
EXPECT_NE
(
fifo_
.
get
(
)
nullptr
)
;
}
~
FifoAudioStream
(
)
{
Flush
(
)
;
}
void
Write
(
const
void
*
source
size_t
num_frames
)
override
{
ASSERT_EQ
(
num_frames
frames_per_buffer_
)
;
PRINTD
(
"
+
"
)
;
if
(
write_count_
+
+
<
kNumIgnoreFirstCallbacks
)
{
return
;
}
int16_t
*
memory
=
new
int16_t
[
frames_per_buffer_
]
;
memcpy
(
static_cast
<
int16_t
*
>
(
&
memory
[
0
]
)
source
bytes_per_buffer_
)
;
rtc
:
:
CritScope
lock
(
&
lock_
)
;
fifo_
-
>
push_back
(
memory
)
;
const
size_t
size
=
fifo_
-
>
size
(
)
;
if
(
size
>
largest_size_
)
{
largest_size_
=
size
;
PRINTD
(
"
(
%
"
PRIuS
"
)
"
largest_size_
)
;
}
total_written_elements_
+
=
size
;
}
void
Read
(
void
*
destination
size_t
num_frames
)
override
{
ASSERT_EQ
(
num_frames
frames_per_buffer_
)
;
PRINTD
(
"
-
"
)
;
rtc
:
:
CritScope
lock
(
&
lock_
)
;
if
(
fifo_
-
>
empty
(
)
)
{
memset
(
destination
0
bytes_per_buffer_
)
;
}
else
{
int16_t
*
memory
=
fifo_
-
>
front
(
)
;
fifo_
-
>
pop_front
(
)
;
memcpy
(
destination
static_cast
<
int16_t
*
>
(
&
memory
[
0
]
)
bytes_per_buffer_
)
;
delete
memory
;
}
}
size_t
size
(
)
const
{
return
fifo_
-
>
size
(
)
;
}
size_t
largest_size
(
)
const
{
return
largest_size_
;
}
size_t
average_size
(
)
const
{
return
(
total_written_elements_
=
=
0
)
?
0
.
0
:
0
.
5
+
static_cast
<
float
>
(
total_written_elements_
)
/
(
write_count_
-
kNumIgnoreFirstCallbacks
)
;
}
private
:
void
Flush
(
)
{
for
(
auto
it
=
fifo_
-
>
begin
(
)
;
it
!
=
fifo_
-
>
end
(
)
;
+
+
it
)
{
delete
*
it
;
}
fifo_
-
>
clear
(
)
;
}
using
AudioBufferList
=
std
:
:
list
<
int16_t
*
>
;
rtc
:
:
CriticalSection
lock_
;
const
size_t
frames_per_buffer_
;
const
size_t
bytes_per_buffer_
;
std
:
:
unique_ptr
<
AudioBufferList
>
fifo_
;
size_t
largest_size_
;
size_t
total_written_elements_
;
size_t
write_count_
;
}
;
class
LatencyMeasuringAudioStream
:
public
AudioStreamInterface
{
public
:
explicit
LatencyMeasuringAudioStream
(
size_t
frames_per_buffer
)
:
frames_per_buffer_
(
frames_per_buffer
)
bytes_per_buffer_
(
frames_per_buffer_
*
sizeof
(
int16_t
)
)
play_count_
(
0
)
rec_count_
(
0
)
pulse_time_
(
0
)
{
}
void
Read
(
void
*
destination
size_t
num_frames
)
override
{
ASSERT_EQ
(
num_frames
frames_per_buffer_
)
;
if
(
play_count_
=
=
0
)
{
PRINT
(
"
[
"
)
;
}
play_count_
+
+
;
memset
(
destination
0
bytes_per_buffer_
)
;
if
(
play_count_
%
(
kNumCallbacksPerSecond
/
kImpulseFrequencyInHz
)
=
=
0
)
{
if
(
pulse_time_
=
=
0
)
{
pulse_time_
=
rtc
:
:
TimeMillis
(
)
;
}
PRINT
(
"
.
"
)
;
const
int16_t
impulse
=
std
:
:
numeric_limits
<
int16_t
>
:
:
max
(
)
;
int16_t
*
ptr16
=
static_cast
<
int16_t
*
>
(
destination
)
;
for
(
size_t
i
=
0
;
i
<
2
;
+
+
i
)
{
ptr16
[
i
]
=
impulse
;
}
}
}
void
Write
(
const
void
*
source
size_t
num_frames
)
override
{
ASSERT_EQ
(
num_frames
frames_per_buffer_
)
;
rec_count_
+
+
;
if
(
pulse_time_
=
=
0
)
{
return
;
}
const
int16_t
*
ptr16
=
static_cast
<
const
int16_t
*
>
(
source
)
;
std
:
:
vector
<
int16_t
>
vec
(
ptr16
ptr16
+
num_frames
)
;
int
max
=
*
std
:
:
max_element
(
vec
.
begin
(
)
vec
.
end
(
)
)
;
int
index_of_max
=
std
:
:
distance
(
vec
.
begin
(
)
std
:
:
find
(
vec
.
begin
(
)
vec
.
end
(
)
max
)
)
;
if
(
max
>
kImpulseThreshold
)
{
PRINTD
(
"
(
%
d
%
d
)
"
max
index_of_max
)
;
int64_t
now_time
=
rtc
:
:
TimeMillis
(
)
;
int
extra_delay
=
IndexToMilliseconds
(
static_cast
<
double
>
(
index_of_max
)
)
;
PRINTD
(
"
[
%
d
]
"
static_cast
<
int
>
(
now_time
-
pulse_time_
)
)
;
PRINTD
(
"
[
%
d
]
"
extra_delay
)
;
latencies_
.
push_back
(
now_time
-
pulse_time_
+
extra_delay
)
;
pulse_time_
=
0
;
}
else
{
PRINTD
(
"
-
"
)
;
}
}
size_t
num_latency_values
(
)
const
{
return
latencies_
.
size
(
)
;
}
int
min_latency
(
)
const
{
if
(
latencies_
.
empty
(
)
)
return
0
;
return
*
std
:
:
min_element
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
)
;
}
int
max_latency
(
)
const
{
if
(
latencies_
.
empty
(
)
)
return
0
;
return
*
std
:
:
max_element
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
)
;
}
int
average_latency
(
)
const
{
if
(
latencies_
.
empty
(
)
)
return
0
;
return
0
.
5
+
static_cast
<
double
>
(
std
:
:
accumulate
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
0
)
)
/
latencies_
.
size
(
)
;
}
void
PrintResults
(
)
const
{
PRINT
(
"
]
"
)
;
for
(
auto
it
=
latencies_
.
begin
(
)
;
it
!
=
latencies_
.
end
(
)
;
+
+
it
)
{
PRINT
(
"
%
d
"
*
it
)
;
}
PRINT
(
"
\
n
"
)
;
PRINT
(
"
%
s
[
min
max
avg
]
=
[
%
d
%
d
%
d
]
ms
\
n
"
kTag
min_latency
(
)
max_latency
(
)
average_latency
(
)
)
;
}
int
IndexToMilliseconds
(
double
index
)
const
{
return
10
.
0
*
(
index
/
frames_per_buffer_
)
+
0
.
5
;
}
private
:
const
size_t
frames_per_buffer_
;
const
size_t
bytes_per_buffer_
;
size_t
play_count_
;
size_t
rec_count_
;
int64_t
pulse_time_
;
std
:
:
vector
<
int
>
latencies_
;
}
;
class
MockAudioTransportIOS
:
public
test
:
:
MockAudioTransport
{
public
:
explicit
MockAudioTransportIOS
(
int
type
)
:
num_callbacks_
(
0
)
type_
(
type
)
play_count_
(
0
)
rec_count_
(
0
)
audio_stream_
(
nullptr
)
{
}
virtual
~
MockAudioTransportIOS
(
)
{
}
void
HandleCallbacks
(
EventWrapper
*
test_is_done
AudioStreamInterface
*
audio_stream
size_t
num_callbacks
)
{
test_is_done_
=
test_is_done
;
audio_stream_
=
audio_stream
;
num_callbacks_
=
num_callbacks
;
if
(
play_mode
(
)
)
{
ON_CALL
(
*
this
NeedMorePlayData
(
_
_
_
_
_
_
_
_
)
)
.
WillByDefault
(
Invoke
(
this
&
MockAudioTransportIOS
:
:
RealNeedMorePlayData
)
)
;
}
if
(
rec_mode
(
)
)
{
ON_CALL
(
*
this
RecordedDataIsAvailable
(
_
_
_
_
_
_
_
_
_
_
)
)
.
WillByDefault
(
Invoke
(
this
&
MockAudioTransportIOS
:
:
RealRecordedDataIsAvailable
)
)
;
}
}
int32_t
RealRecordedDataIsAvailable
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
{
EXPECT_TRUE
(
rec_mode
(
)
)
<
<
"
No
test
is
expecting
these
callbacks
.
"
;
rec_count_
+
+
;
if
(
audio_stream_
)
{
audio_stream_
-
>
Write
(
audioSamples
nSamples
)
;
}
if
(
ReceivedEnoughCallbacks
(
)
)
{
if
(
test_is_done_
)
{
test_is_done_
-
>
Set
(
)
;
}
}
return
0
;
}
int32_t
RealNeedMorePlayData
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
EXPECT_TRUE
(
play_mode
(
)
)
<
<
"
No
test
is
expecting
these
callbacks
.
"
;
play_count_
+
+
;
nSamplesOut
=
nSamples
;
if
(
audio_stream_
)
{
audio_stream_
-
>
Read
(
audioSamples
nSamples
)
;
}
else
{
memset
(
audioSamples
0
nSamples
*
nBytesPerSample
)
;
}
if
(
ReceivedEnoughCallbacks
(
)
)
{
if
(
test_is_done_
)
{
test_is_done_
-
>
Set
(
)
;
}
}
return
0
;
}
bool
ReceivedEnoughCallbacks
(
)
{
bool
recording_done
=
false
;
if
(
rec_mode
(
)
)
recording_done
=
rec_count_
>
=
num_callbacks_
;
else
recording_done
=
true
;
bool
playout_done
=
false
;
if
(
play_mode
(
)
)
playout_done
=
play_count_
>
=
num_callbacks_
;
else
playout_done
=
true
;
return
recording_done
&
&
playout_done
;
}
bool
play_mode
(
)
const
{
return
type_
&
kPlayout
;
}
bool
rec_mode
(
)
const
{
return
type_
&
kRecording
;
}
private
:
EventWrapper
*
test_is_done_
;
size_t
num_callbacks_
;
int
type_
;
size_t
play_count_
;
size_t
rec_count_
;
AudioStreamInterface
*
audio_stream_
;
}
;
class
AudioDeviceTest
:
public
:
:
testing
:
:
Test
{
protected
:
AudioDeviceTest
(
)
:
test_is_done_
(
EventWrapper
:
:
Create
(
)
)
{
old_sev_
=
rtc
:
:
LogMessage
:
:
GetLogToDebug
(
)
;
rtc
:
:
LogMessage
:
:
LogToDebug
(
rtc
:
:
LS_INFO
)
;
rtc
:
:
LogMessage
:
:
LogThreads
(
)
;
audio_device_
=
CreateAudioDevice
(
AudioDeviceModule
:
:
kPlatformDefaultAudio
)
;
EXPECT_NE
(
audio_device_
.
get
(
)
nullptr
)
;
EXPECT_EQ
(
0
audio_device_
-
>
Init
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
GetPlayoutAudioParameters
(
&
playout_parameters_
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
GetRecordAudioParameters
(
&
record_parameters_
)
)
;
}
virtual
~
AudioDeviceTest
(
)
{
EXPECT_EQ
(
0
audio_device_
-
>
Terminate
(
)
)
;
rtc
:
:
LogMessage
:
:
LogToDebug
(
old_sev_
)
;
}
int
playout_sample_rate
(
)
const
{
return
playout_parameters_
.
sample_rate
(
)
;
}
int
record_sample_rate
(
)
const
{
return
record_parameters_
.
sample_rate
(
)
;
}
int
playout_channels
(
)
const
{
return
playout_parameters_
.
channels
(
)
;
}
int
record_channels
(
)
const
{
return
record_parameters_
.
channels
(
)
;
}
size_t
playout_frames_per_10ms_buffer
(
)
const
{
return
playout_parameters_
.
frames_per_10ms_buffer
(
)
;
}
size_t
record_frames_per_10ms_buffer
(
)
const
{
return
record_parameters_
.
frames_per_10ms_buffer
(
)
;
}
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
audio_device
(
)
const
{
return
audio_device_
;
}
AudioDeviceModuleImpl
*
audio_device_impl
(
)
const
{
return
static_cast
<
AudioDeviceModuleImpl
*
>
(
audio_device_
.
get
(
)
)
;
}
AudioDeviceBuffer
*
audio_device_buffer
(
)
const
{
return
audio_device_impl
(
)
-
>
GetAudioDeviceBuffer
(
)
;
}
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
CreateAudioDevice
(
AudioDeviceModule
:
:
AudioLayer
audio_layer
)
{
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
module
(
AudioDeviceModule
:
:
Create
(
0
audio_layer
)
)
;
return
module
;
}
std
:
:
string
GetFileName
(
int
sample_rate
)
{
EXPECT_TRUE
(
sample_rate
=
=
48000
|
|
sample_rate
=
=
44100
|
|
sample_rate
=
=
16000
)
;
char
fname
[
64
]
;
snprintf
(
fname
sizeof
(
fname
)
"
audio_device
/
audio_short
%
d
"
sample_rate
/
1000
)
;
std
:
:
string
file_name
(
webrtc
:
:
test
:
:
ResourcePath
(
fname
"
pcm
"
)
)
;
EXPECT_TRUE
(
test
:
:
FileExists
(
file_name
)
)
;
#
ifdef
ENABLE_DEBUG_PRINTF
PRINTD
(
"
file
name
:
%
s
\
n
"
file_name
.
c_str
(
)
)
;
const
size_t
bytes
=
test
:
:
GetFileSize
(
file_name
)
;
PRINTD
(
"
file
size
:
%
"
PRIuS
"
[
bytes
]
\
n
"
bytes
)
;
PRINTD
(
"
file
size
:
%
"
PRIuS
"
[
samples
]
\
n
"
bytes
/
kBytesPerSample
)
;
const
int
seconds
=
static_cast
<
int
>
(
bytes
/
(
sample_rate
*
kBytesPerSample
)
)
;
PRINTD
(
"
file
size
:
%
d
[
secs
]
\
n
"
seconds
)
;
PRINTD
(
"
file
size
:
%
"
PRIuS
"
[
callbacks
]
\
n
"
seconds
*
kNumCallbacksPerSecond
)
;
#
endif
return
file_name
;
}
void
StartPlayout
(
)
{
EXPECT_FALSE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Playing
(
)
)
;
}
void
StopPlayout
(
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopPlayout
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Playing
(
)
)
;
}
void
StartRecording
(
)
{
EXPECT_FALSE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Recording
(
)
)
;
}
void
StopRecording
(
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopRecording
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Recording
(
)
)
;
}
std
:
:
unique_ptr
<
EventWrapper
>
test_is_done_
;
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
audio_device_
;
AudioParameters
playout_parameters_
;
AudioParameters
record_parameters_
;
rtc
:
:
LoggingSeverity
old_sev_
;
}
;
TEST_F
(
AudioDeviceTest
ConstructDestruct
)
{
}
TEST_F
(
AudioDeviceTest
InitTerminate
)
{
EXPECT_TRUE
(
audio_device
(
)
-
>
Initialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
Terminate
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Initialized
(
)
)
;
}
TEST_F
(
AudioDeviceTest
DISABLED_StartStopPlayout
)
{
StartPlayout
(
)
;
StopPlayout
(
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
DISABLED_StartStopRecording
)
{
StartRecording
(
)
;
StopRecording
(
)
;
StartRecording
(
)
;
StopRecording
(
)
;
}
TEST_F
(
AudioDeviceTest
StopPlayoutRequiresInitToRestart
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartPlayout
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopPlayout
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
}
TEST_F
(
AudioDeviceTest
DISABLED_StartPlayoutOnTwoInstances
)
{
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
second_audio_device
=
CreateAudioDevice
(
AudioDeviceModule
:
:
kPlatformDefaultAudio
)
;
EXPECT_NE
(
second_audio_device
.
get
(
)
nullptr
)
;
EXPECT_EQ
(
0
second_audio_device
-
>
Init
(
)
)
;
NiceMock
<
MockAudioTransportIOS
>
mock
(
kPlayout
)
;
mock
.
HandleCallbacks
(
nullptr
nullptr
0
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
playout_frames_per_10ms_buffer
(
)
kBytesPerSample
playout_channels
(
)
playout_sample_rate
(
)
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
EXPECT_EQ
(
0
second_audio_device
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
second_audio_device
-
>
PlayoutIsInitialized
(
)
)
;
MockAudioTransportIOS
mock2
(
kPlayout
)
;
mock2
.
HandleCallbacks
(
test_is_done_
.
get
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock2
NeedMorePlayData
(
playout_frames_per_10ms_buffer
(
)
kBytesPerSample
playout_channels
(
)
playout_sample_rate
(
)
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
second_audio_device
-
>
RegisterAudioCallback
(
&
mock2
)
)
;
EXPECT_EQ
(
0
second_audio_device
-
>
StartPlayout
(
)
)
;
EXPECT_TRUE
(
second_audio_device
-
>
Playing
(
)
)
;
test_is_done_
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
EXPECT_EQ
(
0
second_audio_device
-
>
StopPlayout
(
)
)
;
EXPECT_FALSE
(
second_audio_device
-
>
Playing
(
)
)
;
EXPECT_FALSE
(
second_audio_device
-
>
PlayoutIsInitialized
(
)
)
;
EXPECT_EQ
(
0
second_audio_device
-
>
Terminate
(
)
)
;
}
TEST_F
(
AudioDeviceTest
StartPlayoutVerifyCallbacks
)
{
MockAudioTransportIOS
mock
(
kPlayout
)
;
mock
.
HandleCallbacks
(
test_is_done_
.
get
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
playout_frames_per_10ms_buffer
(
)
kBytesPerSample
playout_channels
(
)
playout_sample_rate
(
)
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
test_is_done_
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
StartRecordingVerifyCallbacks
)
{
MockAudioTransportIOS
mock
(
kRecording
)
;
mock
.
HandleCallbacks
(
test_is_done_
.
get
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
record_frames_per_10ms_buffer
(
)
kBytesPerSample
record_channels
(
)
record_sample_rate
(
)
_
0
0
false
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartRecording
(
)
;
test_is_done_
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopRecording
(
)
;
}
TEST_F
(
AudioDeviceTest
StartPlayoutAndRecordingVerifyCallbacks
)
{
MockAudioTransportIOS
mock
(
kPlayout
|
kRecording
)
;
mock
.
HandleCallbacks
(
test_is_done_
.
get
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
playout_frames_per_10ms_buffer
(
)
kBytesPerSample
playout_channels
(
)
playout_sample_rate
(
)
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
record_frames_per_10ms_buffer
(
)
kBytesPerSample
record_channels
(
)
record_sample_rate
(
)
_
0
0
false
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
test_is_done_
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
RunPlayoutWithFileAsSource
)
{
EXPECT_EQ
(
1
playout_channels
(
)
)
;
NiceMock
<
MockAudioTransportIOS
>
mock
(
kPlayout
)
;
const
int
num_callbacks
=
kFilePlayTimeInSec
*
kNumCallbacksPerSecond
;
std
:
:
string
file_name
=
GetFileName
(
playout_sample_rate
(
)
)
;
std
:
:
unique_ptr
<
FileAudioStream
>
file_audio_stream
(
new
FileAudioStream
(
num_callbacks
file_name
playout_sample_rate
(
)
)
)
;
mock
.
HandleCallbacks
(
test_is_done_
.
get
(
)
file_audio_stream
.
get
(
)
num_callbacks
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
test_is_done_
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
Devices
)
{
EXPECT_EQ
(
1
audio_device
(
)
-
>
PlayoutDevices
(
)
)
;
EXPECT_EQ
(
1
audio_device
(
)
-
>
RecordingDevices
(
)
)
;
}
TEST_F
(
AudioDeviceTest
RunPlayoutAndRecordingInFullDuplex
)
{
EXPECT_EQ
(
record_channels
(
)
playout_channels
(
)
)
;
EXPECT_EQ
(
record_sample_rate
(
)
playout_sample_rate
(
)
)
;
NiceMock
<
MockAudioTransportIOS
>
mock
(
kPlayout
|
kRecording
)
;
std
:
:
unique_ptr
<
FifoAudioStream
>
fifo_audio_stream
(
new
FifoAudioStream
(
playout_frames_per_10ms_buffer
(
)
)
)
;
mock
.
HandleCallbacks
(
test_is_done_
.
get
(
)
fifo_audio_stream
.
get
(
)
kFullDuplexTimeInSec
*
kNumCallbacksPerSecond
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartRecording
(
)
;
StartPlayout
(
)
;
test_is_done_
-
>
Wait
(
std
:
:
max
(
kTestTimeOutInMilliseconds
1000
*
kFullDuplexTimeInSec
)
)
;
StopPlayout
(
)
;
StopRecording
(
)
;
EXPECT_LE
(
fifo_audio_stream
-
>
average_size
(
)
10u
)
;
EXPECT_LE
(
fifo_audio_stream
-
>
largest_size
(
)
20u
)
;
}
TEST_F
(
AudioDeviceTest
DISABLED_MeasureLoopbackLatency
)
{
EXPECT_EQ
(
record_channels
(
)
playout_channels
(
)
)
;
EXPECT_EQ
(
record_sample_rate
(
)
playout_sample_rate
(
)
)
;
NiceMock
<
MockAudioTransportIOS
>
mock
(
kPlayout
|
kRecording
)
;
std
:
:
unique_ptr
<
LatencyMeasuringAudioStream
>
latency_audio_stream
(
new
LatencyMeasuringAudioStream
(
playout_frames_per_10ms_buffer
(
)
)
)
;
mock
.
HandleCallbacks
(
test_is_done_
.
get
(
)
latency_audio_stream
.
get
(
)
kMeasureLatencyTimeInSec
*
kNumCallbacksPerSecond
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartRecording
(
)
;
StartPlayout
(
)
;
test_is_done_
-
>
Wait
(
std
:
:
max
(
kTestTimeOutInMilliseconds
1000
*
kMeasureLatencyTimeInSec
)
)
;
StopPlayout
(
)
;
StopRecording
(
)
;
EXPECT_EQ
(
latency_audio_stream
-
>
num_latency_values
(
)
static_cast
<
size_t
>
(
kImpulseFrequencyInHz
*
kMeasureLatencyTimeInSec
-
1
)
)
;
latency_audio_stream
-
>
PrintResults
(
)
;
}
TEST_F
(
AudioDeviceTest
testInterruptedAudioSession
)
{
RTCAudioSession
*
session
=
[
RTCAudioSession
sharedInstance
]
;
std
:
:
unique_ptr
<
webrtc
:
:
AudioDeviceIOS
>
audio_device
;
audio_device
.
reset
(
new
webrtc
:
:
AudioDeviceIOS
(
)
)
;
std
:
:
unique_ptr
<
webrtc
:
:
AudioDeviceBuffer
>
audio_buffer
;
audio_buffer
.
reset
(
new
webrtc
:
:
AudioDeviceBuffer
(
)
)
;
audio_device
-
>
AttachAudioBuffer
(
audio_buffer
.
get
(
)
)
;
audio_device
-
>
Init
(
)
;
audio_device
-
>
InitPlayout
(
)
;
[
session
notifyDidBeginInterruption
]
;
rtc
:
:
MessageQueueManager
:
:
ProcessAllMessageQueues
(
)
;
EXPECT_TRUE
(
audio_device
-
>
is_interrupted_
)
;
audio_device
-
>
playing_
=
false
;
audio_device
-
>
ShutdownPlayOrRecord
(
)
;
audio_device
-
>
audio_is_initialized_
=
false
;
[
session
notifyDidEndInterruptionWithShouldResumeSession
:
YES
]
;
rtc
:
:
MessageQueueManager
:
:
ProcessAllMessageQueues
(
)
;
EXPECT_TRUE
(
audio_device
-
>
is_interrupted_
)
;
audio_device
-
>
Init
(
)
;
audio_device
-
>
InitPlayout
(
)
;
EXPECT_FALSE
(
audio_device
-
>
is_interrupted_
)
;
}
}
