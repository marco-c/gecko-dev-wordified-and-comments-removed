#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
numeric
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
optional
.
h
"
#
include
"
modules
/
audio_device
/
audio_device_impl
.
h
"
#
include
"
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
modules
/
audio_device
/
include
/
mock_audio_transport
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
race_checker
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AtLeast
;
using
:
:
testing
:
:
Ge
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
NotNull
;
namespace
webrtc
{
namespace
{
#
ifdef
ENABLE_DEBUG_PRINTF
#
define
PRINTD
(
.
.
.
)
fprintf
(
stderr
__VA_ARGS__
)
;
#
else
#
define
PRINTD
(
.
.
.
)
(
(
void
)
0
)
#
endif
#
define
PRINT
(
.
.
.
)
fprintf
(
stderr
__VA_ARGS__
)
;
#
if
!
defined
(
ADDRESS_SANITIZER
)
&
&
!
defined
(
MEMORY_SANITIZER
)
#
define
SKIP_TEST_IF_NOT
(
requirements_satisfied
)
\
do
{
\
if
(
!
requirements_satisfied
)
{
\
return
;
\
}
\
}
while
(
false
)
#
else
#
define
SKIP_TEST_IF_NOT
(
requirements_satisfied
)
\
do
{
\
return
;
\
}
while
(
false
)
#
endif
static
constexpr
size_t
kNumCallbacks
=
10
;
static
constexpr
size_t
kTestTimeOutInMilliseconds
=
10
*
1000
;
static
constexpr
size_t
kNumCallbacksPerSecond
=
100
;
static
constexpr
size_t
kFullDuplexTimeInSec
=
5
;
static
constexpr
size_t
kMeasureLatencyTimeInSec
=
10
;
static
constexpr
size_t
kImpulseFrequencyInHz
=
1
;
static
constexpr
int
kImpulseThreshold
=
1000
;
enum
class
TransportType
{
kInvalid
kPlay
kRecord
kPlayAndRecord
}
;
class
AudioStream
{
public
:
virtual
void
Write
(
rtc
:
:
ArrayView
<
const
int16_t
>
source
size_t
channels
)
=
0
;
virtual
void
Read
(
rtc
:
:
ArrayView
<
int16_t
>
destination
size_t
channels
)
=
0
;
virtual
~
AudioStream
(
)
=
default
;
}
;
int
IndexToMilliseconds
(
size_t
index
size_t
frames_per_10ms_buffer
)
{
return
rtc
:
:
checked_cast
<
int
>
(
10
.
0
*
(
static_cast
<
double
>
(
index
)
/
frames_per_10ms_buffer
)
+
0
.
5
)
;
}
}
class
FifoAudioStream
:
public
AudioStream
{
public
:
void
Write
(
rtc
:
:
ArrayView
<
const
int16_t
>
source
size_t
channels
)
override
{
EXPECT_EQ
(
channels
1u
)
;
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
const
size_t
size
=
[
&
]
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
fifo_
.
push_back
(
Buffer16
(
source
.
data
(
)
source
.
size
(
)
)
)
;
return
fifo_
.
size
(
)
;
}
(
)
;
if
(
size
>
max_size_
)
{
max_size_
=
size
;
}
if
(
write_count_
+
+
%
100
=
=
0
)
{
PRINT
(
"
.
"
)
;
}
written_elements_
+
=
size
;
}
void
Read
(
rtc
:
:
ArrayView
<
int16_t
>
destination
size_t
channels
)
override
{
EXPECT_EQ
(
channels
1u
)
;
rtc
:
:
CritScope
lock
(
&
lock_
)
;
if
(
fifo_
.
empty
(
)
)
{
std
:
:
fill
(
destination
.
begin
(
)
destination
.
end
(
)
0
)
;
}
else
{
const
Buffer16
&
buffer
=
fifo_
.
front
(
)
;
RTC_CHECK_EQ
(
buffer
.
size
(
)
destination
.
size
(
)
)
;
std
:
:
copy
(
buffer
.
begin
(
)
buffer
.
end
(
)
destination
.
begin
(
)
)
;
fifo_
.
pop_front
(
)
;
}
}
size_t
size
(
)
const
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
return
fifo_
.
size
(
)
;
}
size_t
max_size
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
return
max_size_
;
}
size_t
average_size
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
return
0
.
5
+
static_cast
<
float
>
(
written_elements_
/
write_count_
)
;
}
using
Buffer16
=
rtc
:
:
BufferT
<
int16_t
>
;
rtc
:
:
CriticalSection
lock_
;
rtc
:
:
RaceChecker
race_checker_
;
std
:
:
list
<
Buffer16
>
fifo_
RTC_GUARDED_BY
(
lock_
)
;
size_t
write_count_
RTC_GUARDED_BY
(
race_checker_
)
=
0
;
size_t
max_size_
RTC_GUARDED_BY
(
race_checker_
)
=
0
;
size_t
written_elements_
RTC_GUARDED_BY
(
race_checker_
)
=
0
;
}
;
class
LatencyAudioStream
:
public
AudioStream
{
public
:
LatencyAudioStream
(
)
{
read_thread_checker_
.
DetachFromThread
(
)
;
write_thread_checker_
.
DetachFromThread
(
)
;
}
void
Read
(
rtc
:
:
ArrayView
<
int16_t
>
destination
size_t
channels
)
override
{
RTC_DCHECK_RUN_ON
(
&
read_thread_checker_
)
;
EXPECT_EQ
(
channels
1u
)
;
if
(
read_count_
=
=
0
)
{
PRINT
(
"
[
"
)
;
}
read_count_
+
+
;
std
:
:
fill
(
destination
.
begin
(
)
destination
.
end
(
)
0
)
;
if
(
read_count_
%
(
kNumCallbacksPerSecond
/
kImpulseFrequencyInHz
)
=
=
0
)
{
PRINT
(
"
.
"
)
;
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
if
(
!
pulse_time_
)
{
pulse_time_
=
rtc
:
:
Optional
<
int64_t
>
(
rtc
:
:
TimeMillis
(
)
)
;
}
}
constexpr
int16_t
impulse
=
std
:
:
numeric_limits
<
int16_t
>
:
:
max
(
)
;
std
:
:
fill_n
(
destination
.
begin
(
)
2
impulse
)
;
}
}
void
Write
(
rtc
:
:
ArrayView
<
const
int16_t
>
source
size_t
channels
)
override
{
EXPECT_EQ
(
channels
1u
)
;
RTC_DCHECK_RUN_ON
(
&
write_thread_checker_
)
;
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
rtc
:
:
CritScope
lock
(
&
lock_
)
;
write_count_
+
+
;
if
(
!
pulse_time_
)
{
return
;
}
const
size_t
index_of_max
=
std
:
:
max_element
(
source
.
begin
(
)
source
.
end
(
)
)
-
source
.
begin
(
)
;
const
size_t
max
=
source
[
index_of_max
]
;
if
(
max
>
kImpulseThreshold
)
{
PRINTD
(
"
(
%
zu
%
zu
)
"
max
index_of_max
)
;
int64_t
now_time
=
rtc
:
:
TimeMillis
(
)
;
int
extra_delay
=
IndexToMilliseconds
(
index_of_max
source
.
size
(
)
)
;
PRINTD
(
"
[
%
d
]
"
rtc
:
:
checked_cast
<
int
>
(
now_time
-
pulse_time_
)
)
;
PRINTD
(
"
[
%
d
]
"
extra_delay
)
;
latencies_
.
push_back
(
now_time
-
*
pulse_time_
+
extra_delay
)
;
pulse_time_
.
reset
(
)
;
}
else
{
PRINTD
(
"
-
"
)
;
}
}
size_t
num_latency_values
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
return
latencies_
.
size
(
)
;
}
int
min_latency
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
if
(
latencies_
.
empty
(
)
)
return
0
;
return
*
std
:
:
min_element
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
)
;
}
int
max_latency
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
if
(
latencies_
.
empty
(
)
)
return
0
;
return
*
std
:
:
max_element
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
)
;
}
int
average_latency
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
if
(
latencies_
.
empty
(
)
)
return
0
;
return
0
.
5
+
static_cast
<
double
>
(
std
:
:
accumulate
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
0
)
)
/
latencies_
.
size
(
)
;
}
void
PrintResults
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
PRINT
(
"
]
"
)
;
for
(
auto
it
=
latencies_
.
begin
(
)
;
it
!
=
latencies_
.
end
(
)
;
+
+
it
)
{
PRINTD
(
"
%
d
"
*
it
)
;
}
PRINT
(
"
\
n
"
)
;
PRINT
(
"
[
.
.
.
.
.
.
.
.
.
.
]
[
min
max
avg
]
=
[
%
d
%
d
%
d
]
ms
\
n
"
min_latency
(
)
max_latency
(
)
average_latency
(
)
)
;
}
rtc
:
:
CriticalSection
lock_
;
rtc
:
:
RaceChecker
race_checker_
;
rtc
:
:
ThreadChecker
read_thread_checker_
;
rtc
:
:
ThreadChecker
write_thread_checker_
;
rtc
:
:
Optional
<
int64_t
>
pulse_time_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
vector
<
int
>
latencies_
RTC_GUARDED_BY
(
race_checker_
)
;
size_t
read_count_
RTC_ACCESS_ON
(
read_thread_checker_
)
=
0
;
size_t
write_count_
RTC_ACCESS_ON
(
write_thread_checker_
)
=
0
;
}
;
class
MockAudioTransport
:
public
test
:
:
MockAudioTransport
{
public
:
explicit
MockAudioTransport
(
TransportType
type
)
:
type_
(
type
)
{
}
~
MockAudioTransport
(
)
{
}
void
HandleCallbacks
(
rtc
:
:
Event
*
event
AudioStream
*
audio_stream
int
num_callbacks
)
{
event_
=
event
;
audio_stream_
=
audio_stream
;
num_callbacks_
=
num_callbacks
;
if
(
play_mode
(
)
)
{
ON_CALL
(
*
this
NeedMorePlayData
(
_
_
_
_
_
_
_
_
)
)
.
WillByDefault
(
Invoke
(
this
&
MockAudioTransport
:
:
RealNeedMorePlayData
)
)
;
}
if
(
rec_mode
(
)
)
{
ON_CALL
(
*
this
RecordedDataIsAvailable
(
_
_
_
_
_
_
_
_
_
_
)
)
.
WillByDefault
(
Invoke
(
this
&
MockAudioTransport
:
:
RealRecordedDataIsAvailable
)
)
;
}
}
int32_t
RealRecordedDataIsAvailable
(
const
void
*
audio_buffer
const
size_t
samples_per_channel
const
size_t
bytes_per_frame
const
size_t
channels
const
uint32_t
sample_rate
const
uint32_t
total_delay_ms
const
int32_t
clock_drift
const
uint32_t
current_mic_level
const
bool
typing_status
uint32_t
&
new_mic_level
)
{
EXPECT_TRUE
(
rec_mode
(
)
)
<
<
"
No
test
is
expecting
these
callbacks
.
"
;
RTC_LOG
(
INFO
)
<
<
"
+
"
;
if
(
!
record_parameters_
.
is_complete
(
)
)
{
record_parameters_
.
reset
(
sample_rate
channels
samples_per_channel
)
;
}
else
{
EXPECT_EQ
(
samples_per_channel
record_parameters_
.
frames_per_buffer
(
)
)
;
EXPECT_EQ
(
bytes_per_frame
record_parameters_
.
GetBytesPerFrame
(
)
)
;
EXPECT_EQ
(
channels
record_parameters_
.
channels
(
)
)
;
EXPECT_EQ
(
static_cast
<
int
>
(
sample_rate
)
record_parameters_
.
sample_rate
(
)
)
;
EXPECT_EQ
(
samples_per_channel
record_parameters_
.
frames_per_10ms_buffer
(
)
)
;
}
rec_count_
+
+
;
if
(
audio_stream_
)
{
audio_stream_
-
>
Write
(
rtc
:
:
MakeArrayView
(
static_cast
<
const
int16_t
*
>
(
audio_buffer
)
samples_per_channel
*
channels
)
channels
)
;
}
if
(
ReceivedEnoughCallbacks
(
)
)
{
event_
-
>
Set
(
)
;
}
return
0
;
}
int32_t
RealNeedMorePlayData
(
const
size_t
samples_per_channel
const
size_t
bytes_per_frame
const
size_t
channels
const
uint32_t
sample_rate
void
*
audio_buffer
size_t
&
samples_per_channel_out
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
EXPECT_TRUE
(
play_mode
(
)
)
<
<
"
No
test
is
expecting
these
callbacks
.
"
;
RTC_LOG
(
INFO
)
<
<
"
-
"
;
if
(
!
playout_parameters_
.
is_complete
(
)
)
{
playout_parameters_
.
reset
(
sample_rate
channels
samples_per_channel
)
;
}
else
{
EXPECT_EQ
(
samples_per_channel
playout_parameters_
.
frames_per_buffer
(
)
)
;
EXPECT_EQ
(
bytes_per_frame
playout_parameters_
.
GetBytesPerFrame
(
)
)
;
EXPECT_EQ
(
channels
playout_parameters_
.
channels
(
)
)
;
EXPECT_EQ
(
static_cast
<
int
>
(
sample_rate
)
playout_parameters_
.
sample_rate
(
)
)
;
EXPECT_EQ
(
samples_per_channel
playout_parameters_
.
frames_per_10ms_buffer
(
)
)
;
}
play_count_
+
+
;
samples_per_channel_out
=
samples_per_channel
;
if
(
audio_stream_
)
{
audio_stream_
-
>
Read
(
rtc
:
:
MakeArrayView
(
static_cast
<
int16_t
*
>
(
audio_buffer
)
samples_per_channel
*
channels
)
channels
)
;
}
else
{
const
size_t
num_bytes
=
samples_per_channel
*
bytes_per_frame
;
std
:
:
memset
(
audio_buffer
0
num_bytes
)
;
}
if
(
ReceivedEnoughCallbacks
(
)
)
{
event_
-
>
Set
(
)
;
}
return
0
;
}
bool
ReceivedEnoughCallbacks
(
)
{
bool
recording_done
=
false
;
if
(
rec_mode
(
)
)
{
recording_done
=
rec_count_
>
=
num_callbacks_
;
}
else
{
recording_done
=
true
;
}
bool
playout_done
=
false
;
if
(
play_mode
(
)
)
{
playout_done
=
play_count_
>
=
num_callbacks_
;
}
else
{
playout_done
=
true
;
}
return
recording_done
&
&
playout_done
;
}
bool
play_mode
(
)
const
{
return
type_
=
=
TransportType
:
:
kPlay
|
|
type_
=
=
TransportType
:
:
kPlayAndRecord
;
}
bool
rec_mode
(
)
const
{
return
type_
=
=
TransportType
:
:
kRecord
|
|
type_
=
=
TransportType
:
:
kPlayAndRecord
;
}
private
:
TransportType
type_
=
TransportType
:
:
kInvalid
;
rtc
:
:
Event
*
event_
=
nullptr
;
AudioStream
*
audio_stream_
=
nullptr
;
size_t
num_callbacks_
=
0
;
size_t
play_count_
=
0
;
size_t
rec_count_
=
0
;
AudioParameters
playout_parameters_
;
AudioParameters
record_parameters_
;
}
;
class
AudioDeviceTest
:
public
:
:
testing
:
:
Test
{
protected
:
AudioDeviceTest
(
)
:
event_
(
false
false
)
{
#
if
!
defined
(
ADDRESS_SANITIZER
)
&
&
!
defined
(
MEMORY_SANITIZER
)
rtc
:
:
LogMessage
:
:
LogToDebug
(
rtc
:
:
LS_INFO
)
;
audio_device_
=
AudioDeviceModule
:
:
Create
(
AudioDeviceModule
:
:
kPlatformDefaultAudio
)
;
EXPECT_NE
(
audio_device_
.
get
(
)
nullptr
)
;
AudioDeviceModule
:
:
AudioLayer
audio_layer
;
int
got_platform_audio_layer
=
audio_device_
-
>
ActiveAudioLayer
(
&
audio_layer
)
;
if
(
got_platform_audio_layer
!
=
0
)
{
requirements_satisfied_
=
false
;
}
if
(
requirements_satisfied_
)
{
requirements_satisfied_
=
(
audio_device_
-
>
Init
(
)
=
=
0
)
;
}
if
(
requirements_satisfied_
)
{
const
int16_t
num_playout_devices
=
audio_device_
-
>
PlayoutDevices
(
)
;
const
int16_t
num_record_devices
=
audio_device_
-
>
RecordingDevices
(
)
;
requirements_satisfied_
=
num_playout_devices
>
0
&
&
num_record_devices
>
0
;
}
#
else
requirements_satisfied_
=
false
;
#
endif
if
(
requirements_satisfied_
)
{
EXPECT_EQ
(
0
audio_device_
-
>
SetPlayoutDevice
(
0
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
InitSpeaker
(
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetRecordingDevice
(
0
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
InitMicrophone
(
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
StereoPlayoutIsAvailable
(
&
stereo_playout_
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetStereoPlayout
(
stereo_playout_
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetStereoRecording
(
false
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetAGC
(
false
)
)
;
EXPECT_FALSE
(
audio_device_
-
>
AGC
(
)
)
;
}
}
virtual
~
AudioDeviceTest
(
)
{
if
(
audio_device_
)
{
EXPECT_EQ
(
0
audio_device_
-
>
Terminate
(
)
)
;
}
}
bool
requirements_satisfied
(
)
const
{
return
requirements_satisfied_
;
}
rtc
:
:
Event
*
event
(
)
{
return
&
event_
;
}
const
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
&
audio_device
(
)
const
{
return
audio_device_
;
}
void
StartPlayout
(
)
{
EXPECT_FALSE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Playing
(
)
)
;
}
void
StopPlayout
(
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopPlayout
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
}
void
StartRecording
(
)
{
EXPECT_FALSE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Recording
(
)
)
;
}
void
StopRecording
(
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopRecording
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
}
private
:
bool
requirements_satisfied_
=
true
;
rtc
:
:
Event
event_
;
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
audio_device_
;
bool
stereo_playout_
=
false
;
}
;
TEST_F
(
AudioDeviceTest
ConstructDestruct
)
{
}
TEST_F
(
AudioDeviceTest
InitTerminate
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Initialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
Terminate
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Initialized
(
)
)
;
}
TEST_F
(
AudioDeviceTest
StartStopPlayout
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
StartStopRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartRecording
(
)
;
StopRecording
(
)
;
StartRecording
(
)
;
StopRecording
(
)
;
}
TEST_F
(
AudioDeviceTest
InitStopInitRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
StopRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
StopRecording
(
)
;
}
TEST_F
(
AudioDeviceTest
InitStopInitRecordingWhilePlaying
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
StopRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
InitStopInitPlayout
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
StopPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
InitStopInitPlayoutWhileRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
StopPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
StopPlayout
(
)
;
StopRecording
(
)
;
}
TEST_F
(
AudioDeviceTest
StartPlayoutVerifyCallbacks
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
MockAudioTransport
mock
(
TransportType
:
:
kPlay
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
_
_
_
_
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
StartRecordingVerifyCallbacks
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
MockAudioTransport
mock
(
TransportType
:
:
kRecord
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
_
_
_
_
Ge
(
0u
)
0
_
false
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopRecording
(
)
;
}
TEST_F
(
AudioDeviceTest
StartPlayoutAndRecordingVerifyCallbacks
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
MockAudioTransport
mock
(
TransportType
:
:
kPlayAndRecord
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
_
_
_
_
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
_
_
_
_
Ge
(
0u
)
0
_
false
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOutInMilliseconds
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
}
TEST_F
(
AudioDeviceTest
RunPlayoutAndRecordingInFullDuplex
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
NiceMock
<
MockAudioTransport
>
mock
(
TransportType
:
:
kPlayAndRecord
)
;
FifoAudioStream
audio_stream
;
mock
.
HandleCallbacks
(
event
(
)
&
audio_stream
kFullDuplexTimeInSec
*
kNumCallbacksPerSecond
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoPlayout
(
false
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoRecording
(
false
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
static_cast
<
int
>
(
std
:
:
max
(
kTestTimeOutInMilliseconds
1000
*
kFullDuplexTimeInSec
)
)
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
EXPECT_LE
(
audio_stream
.
average_size
(
)
25u
)
;
PRINT
(
"
\
n
"
)
;
}
TEST_F
(
AudioDeviceTest
DISABLED_MeasureLoopbackLatency
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
NiceMock
<
MockAudioTransport
>
mock
(
TransportType
:
:
kPlayAndRecord
)
;
LatencyAudioStream
audio_stream
;
mock
.
HandleCallbacks
(
event
(
)
&
audio_stream
kMeasureLatencyTimeInSec
*
kNumCallbacksPerSecond
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoPlayout
(
false
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoRecording
(
false
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
static_cast
<
int
>
(
std
:
:
max
(
kTestTimeOutInMilliseconds
1000
*
kMeasureLatencyTimeInSec
)
)
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
EXPECT_EQ
(
audio_stream
.
num_latency_values
(
)
static_cast
<
size_t
>
(
kImpulseFrequencyInHz
*
kMeasureLatencyTimeInSec
-
1
)
)
;
audio_stream
.
PrintResults
(
)
;
}
}
