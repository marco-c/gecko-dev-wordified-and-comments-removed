#
include
<
stddef
.
h
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
utility
>
#
include
<
ApplicationServices
/
ApplicationServices
.
h
>
#
include
<
Cocoa
/
Cocoa
.
h
>
#
include
<
CoreGraphics
/
CoreGraphics
.
h
>
#
include
"
modules
/
desktop_capture
/
desktop_capture_options
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_frame
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_geometry
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_region
.
h
"
#
include
"
modules
/
desktop_capture
/
mac
/
desktop_configuration
.
h
"
#
include
"
modules
/
desktop_capture
/
mac
/
desktop_configuration_monitor
.
h
"
#
include
"
modules
/
desktop_capture
/
mac
/
scoped_pixel_buffer_object
.
h
"
#
include
"
modules
/
desktop_capture
/
screen_capture_frame_queue
.
h
"
#
include
"
modules
/
desktop_capture
/
screen_capturer_helper
.
h
"
#
include
"
modules
/
desktop_capture
/
shared_desktop_frame
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
macutils
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
namespace
webrtc
{
namespace
{
class
DisplayStreamManager
{
public
:
int
GetUniqueId
(
)
{
return
+
+
unique_id_generator_
;
}
void
DestroyStream
(
int
unique_id
)
{
auto
it
=
display_stream_wrappers_
.
find
(
unique_id
)
;
RTC_CHECK
(
it
!
=
display_stream_wrappers_
.
end
(
)
)
;
RTC_CHECK
(
!
it
-
>
second
.
active
)
;
CFRelease
(
it
-
>
second
.
stream
)
;
display_stream_wrappers_
.
erase
(
it
)
;
if
(
ready_for_self_destruction_
&
&
display_stream_wrappers_
.
empty
(
)
)
delete
this
;
}
void
SaveStream
(
int
unique_id
CGDisplayStreamRef
stream
)
{
RTC_CHECK
(
unique_id
<
=
unique_id_generator_
)
;
DisplayStreamWrapper
wrapper
;
wrapper
.
stream
=
stream
;
display_stream_wrappers_
[
unique_id
]
=
wrapper
;
}
void
UnregisterActiveStreams
(
)
{
for
(
auto
&
pair
:
display_stream_wrappers_
)
{
DisplayStreamWrapper
&
wrapper
=
pair
.
second
;
if
(
wrapper
.
active
)
{
wrapper
.
active
=
false
;
CFRunLoopSourceRef
source
=
CGDisplayStreamGetRunLoopSource
(
wrapper
.
stream
)
;
CFRunLoopRemoveSource
(
CFRunLoopGetCurrent
(
)
source
kCFRunLoopCommonModes
)
;
CGDisplayStreamStop
(
wrapper
.
stream
)
;
}
}
}
void
PrepareForSelfDestruction
(
)
{
ready_for_self_destruction_
=
true
;
if
(
display_stream_wrappers_
.
empty
(
)
)
delete
this
;
}
bool
ShouldIgnoreUpdates
(
)
{
return
ready_for_self_destruction_
;
}
private
:
struct
DisplayStreamWrapper
{
CGDisplayStreamRef
stream
=
nullptr
;
bool
active
=
true
;
}
;
std
:
:
map
<
int
DisplayStreamWrapper
>
display_stream_wrappers_
;
int
unique_id_generator_
=
0
;
bool
ready_for_self_destruction_
=
false
;
}
;
const
int
kStandardDPI
=
96
;
DesktopRect
ScaleAndRoundCGRect
(
const
CGRect
&
rect
float
scale
)
{
return
DesktopRect
:
:
MakeLTRB
(
static_cast
<
int
>
(
floor
(
rect
.
origin
.
x
*
scale
)
)
static_cast
<
int
>
(
floor
(
rect
.
origin
.
y
*
scale
)
)
static_cast
<
int
>
(
ceil
(
(
rect
.
origin
.
x
+
rect
.
size
.
width
)
*
scale
)
)
static_cast
<
int
>
(
ceil
(
(
rect
.
origin
.
y
+
rect
.
size
.
height
)
*
scale
)
)
)
;
}
void
CopyRect
(
const
uint8_t
*
src_plane
int
src_plane_stride
uint8_t
*
dest_plane
int
dest_plane_stride
int
bytes_per_pixel
const
DesktopRect
&
rect
)
{
const
int
src_y_offset
=
src_plane_stride
*
rect
.
top
(
)
;
const
int
dest_y_offset
=
dest_plane_stride
*
rect
.
top
(
)
;
const
int
x_offset
=
bytes_per_pixel
*
rect
.
left
(
)
;
src_plane
+
=
src_y_offset
+
x_offset
;
dest_plane
+
=
dest_y_offset
+
x_offset
;
const
int
bytes_per_line
=
bytes_per_pixel
*
rect
.
width
(
)
;
const
int
height
=
rect
.
height
(
)
;
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
memcpy
(
dest_plane
src_plane
bytes_per_line
)
;
src_plane
+
=
src_plane_stride
;
dest_plane
+
=
dest_plane_stride
;
}
}
CFArrayRef
CreateWindowListWithExclusion
(
CGWindowID
window_to_exclude
)
{
if
(
!
window_to_exclude
)
return
nullptr
;
CFArrayRef
all_windows
=
CGWindowListCopyWindowInfo
(
kCGWindowListOptionOnScreenOnly
kCGNullWindowID
)
;
if
(
!
all_windows
)
return
nullptr
;
CFMutableArrayRef
returned_array
=
CFArrayCreateMutable
(
nullptr
CFArrayGetCount
(
all_windows
)
nullptr
)
;
bool
found
=
false
;
for
(
CFIndex
i
=
0
;
i
<
CFArrayGetCount
(
all_windows
)
;
+
+
i
)
{
CFDictionaryRef
window
=
reinterpret_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
all_windows
i
)
)
;
CFNumberRef
id_ref
=
reinterpret_cast
<
CFNumberRef
>
(
CFDictionaryGetValue
(
window
kCGWindowNumber
)
)
;
CGWindowID
id
;
CFNumberGetValue
(
id_ref
kCFNumberIntType
&
id
)
;
if
(
id
=
=
window_to_exclude
)
{
found
=
true
;
continue
;
}
CFArrayAppendValue
(
returned_array
reinterpret_cast
<
void
*
>
(
id
)
)
;
}
CFRelease
(
all_windows
)
;
if
(
!
found
)
{
CFRelease
(
returned_array
)
;
returned_array
=
nullptr
;
}
return
returned_array
;
}
DesktopRect
GetExcludedWindowPixelBounds
(
CGWindowID
window
float
dip_to_pixel_scale
)
{
static
const
int
kBorderEffectSize
=
20
;
CGRect
rect
;
CGWindowID
ids
[
1
]
;
ids
[
0
]
=
window
;
CFArrayRef
window_id_array
=
CFArrayCreate
(
nullptr
reinterpret_cast
<
const
void
*
*
>
(
&
ids
)
1
nullptr
)
;
CFArrayRef
window_array
=
CGWindowListCreateDescriptionFromArray
(
window_id_array
)
;
if
(
CFArrayGetCount
(
window_array
)
>
0
)
{
CFDictionaryRef
window
=
reinterpret_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
window_array
0
)
)
;
CFDictionaryRef
bounds_ref
=
reinterpret_cast
<
CFDictionaryRef
>
(
CFDictionaryGetValue
(
window
kCGWindowBounds
)
)
;
CGRectMakeWithDictionaryRepresentation
(
bounds_ref
&
rect
)
;
}
CFRelease
(
window_id_array
)
;
CFRelease
(
window_array
)
;
rect
.
origin
.
x
-
=
kBorderEffectSize
;
rect
.
origin
.
y
-
=
kBorderEffectSize
;
rect
.
size
.
width
+
=
kBorderEffectSize
*
2
;
rect
.
size
.
height
+
=
kBorderEffectSize
*
2
;
return
ScaleAndRoundCGRect
(
rect
dip_to_pixel_scale
)
;
}
CGImageRef
CreateExcludedWindowRegionImage
(
const
DesktopRect
&
pixel_bounds
float
dip_to_pixel_scale
CFArrayRef
window_list
)
{
CGRect
window_bounds
;
window_bounds
.
origin
.
x
=
pixel_bounds
.
left
(
)
/
dip_to_pixel_scale
;
window_bounds
.
origin
.
y
=
pixel_bounds
.
top
(
)
/
dip_to_pixel_scale
;
window_bounds
.
size
.
width
=
pixel_bounds
.
width
(
)
;
window_bounds
.
size
.
height
=
pixel_bounds
.
height
(
)
;
return
CGWindowListCreateImageFromArray
(
window_bounds
window_list
kCGWindowImageDefault
)
;
}
class
ScreenCapturerMac
:
public
DesktopCapturer
{
public
:
explicit
ScreenCapturerMac
(
rtc
:
:
scoped_refptr
<
DesktopConfigurationMonitor
>
desktop_config_monitor
bool
detect_updated_region
)
;
~
ScreenCapturerMac
(
)
override
;
bool
Init
(
)
;
void
Start
(
Callback
*
callback
)
override
;
void
CaptureFrame
(
)
override
;
void
SetExcludedWindow
(
WindowId
window
)
override
;
bool
GetSourceList
(
SourceList
*
screens
)
override
;
bool
SelectSource
(
SourceId
id
)
override
;
private
:
bool
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
region
)
;
void
ScreenConfigurationChanged
(
)
;
bool
RegisterRefreshAndMoveHandlers
(
)
;
void
UnregisterRefreshAndMoveHandlers
(
)
;
void
ScreenRefresh
(
CGRectCount
count
const
CGRect
*
rect_array
DesktopVector
display_origin
)
;
void
ReleaseBuffers
(
)
;
std
:
:
unique_ptr
<
DesktopFrame
>
CreateFrame
(
)
;
const
bool
detect_updated_region_
;
Callback
*
callback_
=
nullptr
;
ScopedPixelBufferObject
pixel_buffer_object_
;
ScreenCaptureFrameQueue
<
SharedDesktopFrame
>
queue_
;
MacDesktopConfiguration
desktop_config_
;
CGDirectDisplayID
current_display_
=
0
;
DesktopRect
screen_pixel_bounds_
;
float
dip_to_pixel_scale_
=
1
.
0f
;
ScreenCapturerHelper
helper_
;
DesktopRegion
last_invalid_region_
;
rtc
:
:
scoped_refptr
<
DesktopConfigurationMonitor
>
desktop_config_monitor_
;
CGWindowID
excluded_window_
=
0
;
DisplayStreamManager
*
display_stream_manager_
;
bool
update_screen_configuration_
=
false
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
ScreenCapturerMac
)
;
}
;
class
InvertedDesktopFrame
:
public
DesktopFrame
{
public
:
InvertedDesktopFrame
(
std
:
:
unique_ptr
<
DesktopFrame
>
frame
)
:
DesktopFrame
(
frame
-
>
size
(
)
-
frame
-
>
stride
(
)
frame
-
>
data
(
)
+
(
frame
-
>
size
(
)
.
height
(
)
-
1
)
*
frame
-
>
stride
(
)
frame
-
>
shared_memory
(
)
)
{
original_frame_
=
std
:
:
move
(
frame
)
;
MoveFrameInfoFrom
(
original_frame_
.
get
(
)
)
;
}
~
InvertedDesktopFrame
(
)
override
{
}
private
:
std
:
:
unique_ptr
<
DesktopFrame
>
original_frame_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
InvertedDesktopFrame
)
;
}
;
ScreenCapturerMac
:
:
ScreenCapturerMac
(
rtc
:
:
scoped_refptr
<
DesktopConfigurationMonitor
>
desktop_config_monitor
bool
detect_updated_region
)
:
detect_updated_region_
(
detect_updated_region
)
desktop_config_monitor_
(
desktop_config_monitor
)
{
display_stream_manager_
=
new
DisplayStreamManager
;
}
ScreenCapturerMac
:
:
~
ScreenCapturerMac
(
)
{
ReleaseBuffers
(
)
;
UnregisterRefreshAndMoveHandlers
(
)
;
display_stream_manager_
-
>
PrepareForSelfDestruction
(
)
;
}
bool
ScreenCapturerMac
:
:
Init
(
)
{
desktop_config_monitor_
-
>
Lock
(
)
;
desktop_config_
=
desktop_config_monitor_
-
>
desktop_configuration
(
)
;
desktop_config_monitor_
-
>
Unlock
(
)
;
if
(
!
RegisterRefreshAndMoveHandlers
(
)
)
{
return
false
;
}
ScreenConfigurationChanged
(
)
;
return
true
;
}
void
ScreenCapturerMac
:
:
ReleaseBuffers
(
)
{
queue_
.
Reset
(
)
;
}
void
ScreenCapturerMac
:
:
Start
(
Callback
*
callback
)
{
assert
(
!
callback_
)
;
assert
(
callback
)
;
callback_
=
callback
;
desktop_config_monitor_
-
>
Lock
(
)
;
update_screen_configuration_
=
true
;
desktop_config_monitor_
-
>
Unlock
(
)
;
}
void
ScreenCapturerMac
:
:
CaptureFrame
(
)
{
int64_t
capture_start_time_nanos
=
rtc
:
:
TimeNanos
(
)
;
CFRunLoopRunInMode
(
kCFRunLoopDefaultMode
0
.
01
true
)
;
queue_
.
MoveToNextFrame
(
)
;
RTC_DCHECK
(
!
queue_
.
current_frame
(
)
|
|
!
queue_
.
current_frame
(
)
-
>
IsShared
(
)
)
;
desktop_config_monitor_
-
>
Lock
(
)
;
MacDesktopConfiguration
new_config
=
desktop_config_monitor_
-
>
desktop_configuration
(
)
;
if
(
update_screen_configuration_
|
|
!
desktop_config_
.
Equals
(
new_config
)
)
{
update_screen_configuration_
=
false
;
desktop_config_
=
new_config
;
UnregisterRefreshAndMoveHandlers
(
)
;
RegisterRefreshAndMoveHandlers
(
)
;
ScreenConfigurationChanged
(
)
;
}
DesktopRegion
region
;
helper_
.
TakeInvalidRegion
(
&
region
)
;
if
(
!
queue_
.
current_frame
(
)
)
queue_
.
ReplaceCurrentFrame
(
SharedDesktopFrame
:
:
Wrap
(
CreateFrame
(
)
)
)
;
DesktopFrame
*
current_frame
=
queue_
.
current_frame
(
)
;
if
(
!
CgBlit
(
*
current_frame
region
)
)
{
desktop_config_monitor_
-
>
Unlock
(
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_PERMANENT
nullptr
)
;
return
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
new_frame
=
queue_
.
current_frame
(
)
-
>
Share
(
)
;
if
(
detect_updated_region_
)
{
*
new_frame
-
>
mutable_updated_region
(
)
=
region
;
}
else
{
new_frame
-
>
mutable_updated_region
(
)
-
>
AddRect
(
DesktopRect
:
:
MakeSize
(
new_frame
-
>
size
(
)
)
)
;
}
if
(
current_display_
)
{
const
MacDisplayConfiguration
*
config
=
desktop_config_
.
FindDisplayConfigurationById
(
current_display_
)
;
if
(
config
)
{
new_frame
-
>
set_top_left
(
config
-
>
bounds
.
top_left
(
)
.
subtract
(
desktop_config_
.
bounds
.
top_left
(
)
)
)
;
}
}
helper_
.
set_size_most_recent
(
new_frame
-
>
size
(
)
)
;
desktop_config_monitor_
-
>
Unlock
(
)
;
new_frame
-
>
set_capture_time_ms
(
(
rtc
:
:
TimeNanos
(
)
-
capture_start_time_nanos
)
/
rtc
:
:
kNumNanosecsPerMillisec
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
new_frame
)
)
;
}
void
ScreenCapturerMac
:
:
SetExcludedWindow
(
WindowId
window
)
{
excluded_window_
=
window
;
}
bool
ScreenCapturerMac
:
:
GetSourceList
(
SourceList
*
screens
)
{
assert
(
screens
-
>
size
(
)
=
=
0
)
;
for
(
MacDisplayConfigurations
:
:
iterator
it
=
desktop_config_
.
displays
.
begin
(
)
;
it
!
=
desktop_config_
.
displays
.
end
(
)
;
+
+
it
)
{
screens
-
>
push_back
(
{
it
-
>
id
}
)
;
}
return
true
;
}
bool
ScreenCapturerMac
:
:
SelectSource
(
SourceId
id
)
{
if
(
id
=
=
kFullDesktopScreenId
)
{
current_display_
=
0
;
}
else
{
const
MacDisplayConfiguration
*
config
=
desktop_config_
.
FindDisplayConfigurationById
(
static_cast
<
CGDirectDisplayID
>
(
id
)
)
;
if
(
!
config
)
return
false
;
current_display_
=
config
-
>
id
;
}
ScreenConfigurationChanged
(
)
;
return
true
;
}
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
region
)
{
if
(
queue_
.
previous_frame
(
)
)
{
memcpy
(
frame
.
data
(
)
queue_
.
previous_frame
(
)
-
>
data
(
)
frame
.
stride
(
)
*
frame
.
size
(
)
.
height
(
)
)
;
}
MacDisplayConfigurations
displays_to_capture
;
if
(
current_display_
)
{
const
MacDisplayConfiguration
*
config
=
desktop_config_
.
FindDisplayConfigurationById
(
current_display_
)
;
if
(
config
)
{
displays_to_capture
.
push_back
(
*
config
)
;
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
"
The
selected
screen
cannot
be
found
for
capturing
.
"
;
return
false
;
}
}
else
{
displays_to_capture
=
desktop_config_
.
displays
;
}
CFArrayRef
window_list
=
CreateWindowListWithExclusion
(
excluded_window_
)
;
for
(
size_t
i
=
0
;
i
<
displays_to_capture
.
size
(
)
;
+
+
i
)
{
const
MacDisplayConfiguration
&
display_config
=
displays_to_capture
[
i
]
;
if
(
i
>
0
&
&
display_config
.
dip_to_pixel_scale
!
=
displays_to_capture
[
0
]
.
dip_to_pixel_scale
)
{
continue
;
}
DesktopRect
display_bounds
=
display_config
.
pixel_bounds
;
display_bounds
.
Translate
(
-
screen_pixel_bounds_
.
left
(
)
-
screen_pixel_bounds_
.
top
(
)
)
;
DesktopRegion
copy_region
=
region
;
copy_region
.
IntersectWith
(
display_bounds
)
;
if
(
copy_region
.
is_empty
(
)
)
continue
;
copy_region
.
Translate
(
-
display_bounds
.
left
(
)
-
display_bounds
.
top
(
)
)
;
DesktopRect
excluded_window_bounds
;
CGImageRef
excluded_image
=
nullptr
;
if
(
excluded_window_
&
&
window_list
)
{
excluded_window_bounds
=
GetExcludedWindowPixelBounds
(
excluded_window_
display_config
.
dip_to_pixel_scale
)
;
excluded_window_bounds
.
IntersectWith
(
display_config
.
pixel_bounds
)
;
if
(
!
excluded_window_bounds
.
is_empty
(
)
)
{
excluded_image
=
CreateExcludedWindowRegionImage
(
excluded_window_bounds
display_config
.
dip_to_pixel_scale
window_list
)
;
}
}
CGImageRef
image
=
CGDisplayCreateImage
(
display_config
.
id
)
;
if
(
!
image
)
{
if
(
excluded_image
)
CFRelease
(
excluded_image
)
;
continue
;
}
int
bits_per_pixel
=
CGImageGetBitsPerPixel
(
image
)
;
if
(
bits_per_pixel
/
8
!
=
DesktopFrame
:
:
kBytesPerPixel
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
CGDisplayCreateImage
(
)
returned
imaged
with
"
<
<
bits_per_pixel
<
<
"
bits
per
pixel
.
Only
32
-
bit
depth
is
supported
.
"
;
CFRelease
(
image
)
;
if
(
excluded_image
)
CFRelease
(
excluded_image
)
;
return
false
;
}
CGDataProviderRef
provider
=
CGImageGetDataProvider
(
image
)
;
CFDataRef
data
=
CGDataProviderCopyData
(
provider
)
;
assert
(
data
)
;
const
uint8_t
*
display_base_address
=
CFDataGetBytePtr
(
data
)
;
int
src_bytes_per_row
=
CGImageGetBytesPerRow
(
image
)
;
copy_region
.
IntersectWith
(
DesktopRect
:
:
MakeWH
(
CGImageGetWidth
(
image
)
CGImageGetHeight
(
image
)
)
)
;
uint8_t
*
out_ptr
=
frame
.
GetFrameDataAtPos
(
display_bounds
.
top_left
(
)
)
;
for
(
DesktopRegion
:
:
Iterator
i
(
copy_region
)
;
!
i
.
IsAtEnd
(
)
;
i
.
Advance
(
)
)
{
CopyRect
(
display_base_address
src_bytes_per_row
out_ptr
frame
.
stride
(
)
DesktopFrame
:
:
kBytesPerPixel
i
.
rect
(
)
)
;
}
CFRelease
(
data
)
;
CFRelease
(
image
)
;
if
(
excluded_image
)
{
CGDataProviderRef
provider
=
CGImageGetDataProvider
(
excluded_image
)
;
CFDataRef
excluded_image_data
=
CGDataProviderCopyData
(
provider
)
;
assert
(
excluded_image_data
)
;
display_base_address
=
CFDataGetBytePtr
(
excluded_image_data
)
;
src_bytes_per_row
=
CGImageGetBytesPerRow
(
excluded_image
)
;
DesktopRect
window_bounds_relative_to_desktop
(
excluded_window_bounds
)
;
window_bounds_relative_to_desktop
.
Translate
(
-
screen_pixel_bounds_
.
left
(
)
-
screen_pixel_bounds_
.
top
(
)
)
;
DesktopRect
rect_to_copy
=
DesktopRect
:
:
MakeSize
(
excluded_window_bounds
.
size
(
)
)
;
rect_to_copy
.
IntersectWith
(
DesktopRect
:
:
MakeWH
(
CGImageGetWidth
(
excluded_image
)
CGImageGetHeight
(
excluded_image
)
)
)
;
if
(
CGImageGetBitsPerPixel
(
excluded_image
)
/
8
=
=
DesktopFrame
:
:
kBytesPerPixel
)
{
CopyRect
(
display_base_address
src_bytes_per_row
frame
.
GetFrameDataAtPos
(
window_bounds_relative_to_desktop
.
top_left
(
)
)
frame
.
stride
(
)
DesktopFrame
:
:
kBytesPerPixel
rect_to_copy
)
;
}
CFRelease
(
excluded_image_data
)
;
CFRelease
(
excluded_image
)
;
}
}
if
(
window_list
)
CFRelease
(
window_list
)
;
return
true
;
}
void
ScreenCapturerMac
:
:
ScreenConfigurationChanged
(
)
{
if
(
current_display_
)
{
const
MacDisplayConfiguration
*
config
=
desktop_config_
.
FindDisplayConfigurationById
(
current_display_
)
;
screen_pixel_bounds_
=
config
?
config
-
>
pixel_bounds
:
DesktopRect
(
)
;
dip_to_pixel_scale_
=
config
?
config
-
>
dip_to_pixel_scale
:
1
.
0f
;
}
else
{
screen_pixel_bounds_
=
desktop_config_
.
pixel_bounds
;
dip_to_pixel_scale_
=
desktop_config_
.
dip_to_pixel_scale
;
}
ReleaseBuffers
(
)
;
helper_
.
ClearInvalidRegion
(
)
;
helper_
.
InvalidateScreen
(
screen_pixel_bounds_
.
size
(
)
)
;
queue_
.
Reset
(
)
;
}
bool
ScreenCapturerMac
:
:
RegisterRefreshAndMoveHandlers
(
)
{
desktop_config_
=
desktop_config_monitor_
-
>
desktop_configuration
(
)
;
for
(
const
auto
&
config
:
desktop_config_
.
displays
)
{
size_t
pixel_width
=
config
.
pixel_bounds
.
width
(
)
;
size_t
pixel_height
=
config
.
pixel_bounds
.
height
(
)
;
if
(
pixel_width
=
=
0
|
|
pixel_height
=
=
0
)
continue
;
DisplayStreamManager
*
manager
=
display_stream_manager_
;
int
unique_id
=
manager
-
>
GetUniqueId
(
)
;
CGDirectDisplayID
display_id
=
config
.
id
;
DesktopVector
display_origin
=
config
.
pixel_bounds
.
top_left
(
)
;
CGDisplayStreamFrameAvailableHandler
handler
=
^
(
CGDisplayStreamFrameStatus
status
uint64_t
display_time
IOSurfaceRef
frame_surface
CGDisplayStreamUpdateRef
updateRef
)
{
if
(
status
=
=
kCGDisplayStreamFrameStatusStopped
)
{
manager
-
>
DestroyStream
(
unique_id
)
;
return
;
}
if
(
manager
-
>
ShouldIgnoreUpdates
(
)
)
return
;
if
(
status
!
=
kCGDisplayStreamFrameStatusFrameComplete
)
return
;
size_t
count
=
0
;
const
CGRect
*
rects
=
CGDisplayStreamUpdateGetRects
(
updateRef
kCGDisplayStreamUpdateDirtyRects
&
count
)
;
if
(
count
!
=
0
)
{
ScreenRefresh
(
count
rects
display_origin
)
;
}
}
;
CGDisplayStreamRef
display_stream
=
CGDisplayStreamCreate
(
display_id
pixel_width
pixel_height
'
BGRA
'
nullptr
handler
)
;
if
(
display_stream
)
{
CGError
error
=
CGDisplayStreamStart
(
display_stream
)
;
if
(
error
!
=
kCGErrorSuccess
)
return
false
;
CFRunLoopSourceRef
source
=
CGDisplayStreamGetRunLoopSource
(
display_stream
)
;
CFRunLoopAddSource
(
CFRunLoopGetCurrent
(
)
source
kCFRunLoopCommonModes
)
;
display_stream_manager_
-
>
SaveStream
(
unique_id
display_stream
)
;
}
}
return
true
;
}
void
ScreenCapturerMac
:
:
UnregisterRefreshAndMoveHandlers
(
)
{
display_stream_manager_
-
>
UnregisterActiveStreams
(
)
;
}
void
ScreenCapturerMac
:
:
ScreenRefresh
(
CGRectCount
count
const
CGRect
*
rect_array
DesktopVector
display_origin
)
{
if
(
screen_pixel_bounds_
.
is_empty
(
)
)
ScreenConfigurationChanged
(
)
;
DesktopVector
translate_vector
;
if
(
!
current_display_
)
translate_vector
=
display_origin
;
DesktopRegion
region
;
for
(
CGRectCount
i
=
0
;
i
<
count
;
+
+
i
)
{
DesktopRect
rect
=
DesktopRect
:
:
MakeXYWH
(
rect_array
[
i
]
.
origin
.
x
rect_array
[
i
]
.
origin
.
y
rect_array
[
i
]
.
size
.
width
rect_array
[
i
]
.
size
.
height
)
;
rect
.
Translate
(
translate_vector
)
;
region
.
AddRect
(
rect
)
;
}
helper_
.
InvalidateRegion
(
region
)
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
ScreenCapturerMac
:
:
CreateFrame
(
)
{
std
:
:
unique_ptr
<
DesktopFrame
>
frame
(
new
BasicDesktopFrame
(
screen_pixel_bounds_
.
size
(
)
)
)
;
frame
-
>
set_dpi
(
DesktopVector
(
kStandardDPI
*
dip_to_pixel_scale_
kStandardDPI
*
dip_to_pixel_scale_
)
)
;
return
frame
;
}
}
std
:
:
unique_ptr
<
DesktopCapturer
>
DesktopCapturer
:
:
CreateRawScreenCapturer
(
const
DesktopCaptureOptions
&
options
)
{
if
(
!
options
.
configuration_monitor
(
)
)
return
nullptr
;
std
:
:
unique_ptr
<
ScreenCapturerMac
>
capturer
(
new
ScreenCapturerMac
(
options
.
configuration_monitor
(
)
options
.
detect_updated_region
(
)
)
)
;
if
(
!
capturer
.
get
(
)
-
>
Init
(
)
)
{
return
nullptr
;
}
return
capturer
;
}
}
