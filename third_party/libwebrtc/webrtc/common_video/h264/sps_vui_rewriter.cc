#
include
"
common_video
/
h264
/
sps_vui_rewriter
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
rtc_base
/
bitbuffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
#
include
"
common_video
/
h264
/
h264_common
.
h
"
#
include
"
common_video
/
h264
/
sps_parser
.
h
"
namespace
webrtc
{
const
size_t
kMaxVuiSpsIncrease
=
64
;
#
define
RETURN_FALSE_ON_FAIL
(
x
)
\
if
(
!
(
x
)
)
{
\
RTC_LOG_F
(
LS_ERROR
)
<
<
"
(
line
:
"
<
<
__LINE__
<
<
"
)
FAILED
:
"
#
x
;
\
return
false
;
\
}
#
define
COPY_UINT8
(
src
dest
tmp
)
\
do
{
\
RETURN_FALSE_ON_FAIL
(
(
src
)
-
>
ReadUInt8
(
&
tmp
)
)
;
\
if
(
dest
)
\
RETURN_FALSE_ON_FAIL
(
(
dest
)
-
>
WriteUInt8
(
tmp
)
)
;
\
}
while
(
0
)
#
define
COPY_EXP_GOLOMB
(
src
dest
tmp
)
\
do
{
\
RETURN_FALSE_ON_FAIL
(
(
src
)
-
>
ReadExponentialGolomb
(
&
tmp
)
)
;
\
if
(
dest
)
\
RETURN_FALSE_ON_FAIL
(
(
dest
)
-
>
WriteExponentialGolomb
(
tmp
)
)
;
\
}
while
(
0
)
#
define
COPY_BITS
(
src
dest
tmp
bits
)
\
do
{
\
RETURN_FALSE_ON_FAIL
(
(
src
)
-
>
ReadBits
(
&
tmp
bits
)
)
;
\
if
(
dest
)
\
RETURN_FALSE_ON_FAIL
(
(
dest
)
-
>
WriteBits
(
tmp
bits
)
)
;
\
}
while
(
0
)
typedef
const
SpsParser
:
:
SpsState
&
Sps
;
bool
CopyAndRewriteVui
(
Sps
sps
rtc
:
:
BitBuffer
*
source
rtc
:
:
BitBufferWriter
*
destination
SpsVuiRewriter
:
:
ParseResult
*
out_vui_rewritten
)
;
bool
CopyHrdParameters
(
rtc
:
:
BitBuffer
*
source
rtc
:
:
BitBufferWriter
*
destination
)
;
bool
AddBitstreamRestriction
(
rtc
:
:
BitBufferWriter
*
destination
uint32_t
max_num_ref_frames
)
;
bool
CopyRemainingBits
(
rtc
:
:
BitBuffer
*
source
rtc
:
:
BitBufferWriter
*
destination
)
;
SpsVuiRewriter
:
:
ParseResult
SpsVuiRewriter
:
:
ParseAndRewriteSps
(
const
uint8_t
*
buffer
size_t
length
rtc
:
:
Optional
<
SpsParser
:
:
SpsState
>
*
sps
rtc
:
:
Buffer
*
destination
)
{
std
:
:
vector
<
uint8_t
>
rbsp_buffer
=
H264
:
:
ParseRbsp
(
buffer
length
)
;
rtc
:
:
BitBuffer
source_buffer
(
rbsp_buffer
.
data
(
)
rbsp_buffer
.
size
(
)
)
;
rtc
:
:
Optional
<
SpsParser
:
:
SpsState
>
sps_state
=
SpsParser
:
:
ParseSpsUpToVui
(
&
source_buffer
)
;
if
(
!
sps_state
)
return
ParseResult
:
:
kFailure
;
*
sps
=
sps_state
;
if
(
sps_state
-
>
pic_order_cnt_type
>
=
2
)
{
return
ParseResult
:
:
kPocOk
;
}
rtc
:
:
Buffer
out_buffer
(
length
+
kMaxVuiSpsIncrease
)
;
rtc
:
:
BitBufferWriter
sps_writer
(
out_buffer
.
data
(
)
out_buffer
.
size
(
)
)
;
size_t
byte_offset
;
size_t
bit_offset
;
source_buffer
.
GetCurrentOffset
(
&
byte_offset
&
bit_offset
)
;
memcpy
(
out_buffer
.
data
(
)
rbsp_buffer
.
data
(
)
byte_offset
+
(
bit_offset
>
0
?
1
:
0
)
)
;
if
(
bit_offset
=
=
0
)
{
-
-
byte_offset
;
bit_offset
=
7
;
}
else
{
-
-
bit_offset
;
}
sps_writer
.
Seek
(
byte_offset
bit_offset
)
;
ParseResult
vui_updated
;
if
(
!
CopyAndRewriteVui
(
*
sps_state
&
source_buffer
&
sps_writer
&
vui_updated
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
parse
/
copy
SPS
VUI
.
"
;
return
ParseResult
:
:
kFailure
;
}
if
(
vui_updated
=
=
ParseResult
:
:
kVuiOk
)
{
return
vui_updated
;
}
if
(
!
CopyRemainingBits
(
&
source_buffer
&
sps_writer
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
parse
/
copy
SPS
VUI
.
"
;
return
ParseResult
:
:
kFailure
;
}
sps_writer
.
GetCurrentOffset
(
&
byte_offset
&
bit_offset
)
;
if
(
bit_offset
>
0
)
{
sps_writer
.
WriteBits
(
0
8
-
bit_offset
)
;
+
+
byte_offset
;
bit_offset
=
0
;
}
RTC_DCHECK
(
byte_offset
<
=
length
+
kMaxVuiSpsIncrease
)
;
RTC_CHECK
(
destination
!
=
nullptr
)
;
out_buffer
.
SetSize
(
byte_offset
)
;
H264
:
:
WriteRbsp
(
out_buffer
.
data
(
)
out_buffer
.
size
(
)
destination
)
;
return
ParseResult
:
:
kVuiRewritten
;
}
bool
CopyAndRewriteVui
(
Sps
sps
rtc
:
:
BitBuffer
*
source
rtc
:
:
BitBufferWriter
*
destination
SpsVuiRewriter
:
:
ParseResult
*
out_vui_rewritten
)
{
uint32_t
golomb_tmp
;
uint32_t
bits_tmp
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteBits
(
1
1
)
)
;
if
(
!
sps
.
vui_params_present
)
{
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteBits
(
0
8
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteBits
(
1
1
)
)
;
RETURN_FALSE_ON_FAIL
(
AddBitstreamRestriction
(
destination
sps
.
max_num_ref_frames
)
)
;
}
else
{
COPY_BITS
(
source
destination
bits_tmp
1
)
;
if
(
bits_tmp
=
=
1
)
{
COPY_BITS
(
source
destination
bits_tmp
8
)
;
if
(
bits_tmp
=
=
255u
)
{
COPY_BITS
(
source
destination
bits_tmp
32
)
;
}
}
COPY_BITS
(
source
destination
bits_tmp
1
)
;
if
(
bits_tmp
=
=
1
)
{
COPY_BITS
(
source
destination
bits_tmp
1
)
;
}
COPY_BITS
(
source
destination
bits_tmp
1
)
;
if
(
bits_tmp
=
=
1
)
{
COPY_BITS
(
source
destination
bits_tmp
4
)
;
COPY_BITS
(
source
destination
bits_tmp
1
)
;
if
(
bits_tmp
=
=
1
)
{
COPY_BITS
(
source
destination
bits_tmp
24
)
;
}
}
COPY_BITS
(
source
destination
bits_tmp
1
)
;
if
(
bits_tmp
=
=
1
)
{
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
}
COPY_BITS
(
source
destination
bits_tmp
1
)
;
if
(
bits_tmp
=
=
1
)
{
COPY_BITS
(
source
destination
bits_tmp
32
)
;
COPY_BITS
(
source
destination
bits_tmp
32
)
;
COPY_BITS
(
source
destination
bits_tmp
1
)
;
}
uint32_t
nal_hrd_parameters_present_flag
;
COPY_BITS
(
source
destination
nal_hrd_parameters_present_flag
1
)
;
if
(
nal_hrd_parameters_present_flag
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
CopyHrdParameters
(
source
destination
)
)
;
}
uint32_t
vcl_hrd_parameters_present_flag
;
COPY_BITS
(
source
destination
vcl_hrd_parameters_present_flag
1
)
;
if
(
vcl_hrd_parameters_present_flag
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
CopyHrdParameters
(
source
destination
)
)
;
}
if
(
nal_hrd_parameters_present_flag
=
=
1
|
|
vcl_hrd_parameters_present_flag
=
=
1
)
{
COPY_BITS
(
source
destination
bits_tmp
1
)
;
}
COPY_BITS
(
source
destination
bits_tmp
1
)
;
uint32_t
bitstream_restriction_flag
;
RETURN_FALSE_ON_FAIL
(
source
-
>
ReadBits
(
&
bitstream_restriction_flag
1
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteBits
(
1
1
)
)
;
if
(
bitstream_restriction_flag
=
=
0
)
{
RETURN_FALSE_ON_FAIL
(
AddBitstreamRestriction
(
destination
sps
.
max_num_ref_frames
)
)
;
}
else
{
COPY_BITS
(
source
destination
bits_tmp
1
)
;
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
uint32_t
max_num_reorder_frames
max_dec_frame_buffering
;
RETURN_FALSE_ON_FAIL
(
source
-
>
ReadExponentialGolomb
(
&
max_num_reorder_frames
)
)
;
RETURN_FALSE_ON_FAIL
(
source
-
>
ReadExponentialGolomb
(
&
max_dec_frame_buffering
)
)
;
if
(
max_num_reorder_frames
=
=
0
&
&
max_dec_frame_buffering
<
=
sps
.
max_num_ref_frames
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
VUI
bitstream
already
contains
an
optimal
VUI
.
"
;
*
out_vui_rewritten
=
SpsVuiRewriter
:
:
ParseResult
:
:
kVuiOk
;
return
true
;
}
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
0
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
sps
.
max_num_ref_frames
)
)
;
}
}
*
out_vui_rewritten
=
SpsVuiRewriter
:
:
ParseResult
:
:
kVuiRewritten
;
return
true
;
}
bool
CopyHrdParameters
(
rtc
:
:
BitBuffer
*
source
rtc
:
:
BitBufferWriter
*
destination
)
{
uint32_t
golomb_tmp
;
uint32_t
bits_tmp
;
uint32_t
cbp_cnt_minus1
;
COPY_EXP_GOLOMB
(
source
destination
cbp_cnt_minus1
)
;
COPY_BITS
(
source
destination
bits_tmp
8
)
;
for
(
size_t
i
=
0
;
i
<
=
cbp_cnt_minus1
;
+
+
i
)
{
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
COPY_EXP_GOLOMB
(
source
destination
golomb_tmp
)
;
COPY_BITS
(
source
destination
bits_tmp
1
)
;
}
COPY_BITS
(
source
destination
bits_tmp
5
)
;
COPY_BITS
(
source
destination
bits_tmp
5
)
;
COPY_BITS
(
source
destination
bits_tmp
5
)
;
COPY_BITS
(
source
destination
bits_tmp
5
)
;
return
true
;
}
bool
AddBitstreamRestriction
(
rtc
:
:
BitBufferWriter
*
destination
uint32_t
max_num_ref_frames
)
{
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteBits
(
1
1
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
2
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
1
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
16
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
16
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
0
)
)
;
RETURN_FALSE_ON_FAIL
(
destination
-
>
WriteExponentialGolomb
(
max_num_ref_frames
)
)
;
return
true
;
}
bool
CopyRemainingBits
(
rtc
:
:
BitBuffer
*
source
rtc
:
:
BitBufferWriter
*
destination
)
{
uint32_t
bits_tmp
;
if
(
source
-
>
RemainingBitCount
(
)
>
0
&
&
source
-
>
RemainingBitCount
(
)
%
8
!
=
0
)
{
size_t
misaligned_bits
=
source
-
>
RemainingBitCount
(
)
%
8
;
COPY_BITS
(
source
destination
bits_tmp
misaligned_bits
)
;
}
while
(
source
-
>
RemainingBitCount
(
)
>
0
)
{
auto
count
=
rtc
:
:
SafeMin
<
size_t
>
(
32u
source
-
>
RemainingBitCount
(
)
)
;
COPY_BITS
(
source
destination
bits_tmp
count
)
;
}
return
true
;
}
}
