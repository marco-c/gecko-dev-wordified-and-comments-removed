#
include
"
common_video
/
h264
/
pps_parser
.
h
"
#
include
<
limits
>
#
include
<
memory
>
#
include
"
common_video
/
h264
/
h264_common
.
h
"
#
include
"
rtc_base
/
bitbuffer
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
const
uint8_t
kH264BitstreamChunk
[
]
=
{
0x00
0x00
0x00
0x01
0x67
0x42
0x80
0x20
0xda
0x01
0x40
0x16
0xe8
0x06
0xd0
0xa1
0x35
0x00
0x00
0x00
0x01
0x68
0xce
0x06
0xe2
0x00
0x00
0x00
0x01
0x65
0xb8
0x40
0xf0
0x8c
0x03
0xf2
0x75
0x67
0xad
0x41
0x64
0x24
0x0e
0xa0
0xb2
0x12
0x1e
0xf8
}
;
const
size_t
kPpsBufferMaxSize
=
256
;
const
uint32_t
kIgnored
=
0
;
}
void
WritePps
(
const
PpsParser
:
:
PpsState
&
pps
int
slice_group_map_type
int
num_slice_groups
int
pic_size_in_map_units
rtc
:
:
Buffer
*
out_buffer
)
{
uint8_t
data
[
kPpsBufferMaxSize
]
=
{
0
}
;
rtc
:
:
BitBufferWriter
bit_buffer
(
data
kPpsBufferMaxSize
)
;
bit_buffer
.
WriteExponentialGolomb
(
pps
.
id
)
;
bit_buffer
.
WriteExponentialGolomb
(
pps
.
sps_id
)
;
bit_buffer
.
WriteBits
(
pps
.
entropy_coding_mode_flag
1
)
;
bit_buffer
.
WriteBits
(
pps
.
bottom_field_pic_order_in_frame_present_flag
?
1
:
0
1
)
;
RTC_CHECK_GT
(
num_slice_groups
0
)
;
bit_buffer
.
WriteExponentialGolomb
(
num_slice_groups
-
1
)
;
if
(
num_slice_groups
>
1
)
{
bit_buffer
.
WriteExponentialGolomb
(
slice_group_map_type
)
;
switch
(
slice_group_map_type
)
{
case
0
:
for
(
int
i
=
0
;
i
<
num_slice_groups
;
+
+
i
)
{
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
}
break
;
case
2
:
for
(
int
i
=
0
;
i
<
num_slice_groups
;
+
+
i
)
{
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
}
break
;
case
3
:
case
4
:
case
5
:
bit_buffer
.
WriteBits
(
kIgnored
1
)
;
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
break
;
case
6
:
{
bit_buffer
.
WriteExponentialGolomb
(
pic_size_in_map_units
-
1
)
;
uint32_t
slice_group_id_bits
=
0
;
if
(
(
num_slice_groups
&
(
num_slice_groups
-
1
)
)
!
=
0
)
+
+
slice_group_id_bits
;
while
(
num_slice_groups
>
0
)
{
num_slice_groups
>
>
=
1
;
+
+
slice_group_id_bits
;
}
for
(
int
i
=
0
;
i
<
pic_size_in_map_units
;
+
+
i
)
{
bit_buffer
.
WriteBits
(
kIgnored
slice_group_id_bits
)
;
}
break
;
}
default
:
RTC_NOTREACHED
(
)
;
}
}
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
bit_buffer
.
WriteBits
(
pps
.
weighted_pred_flag
?
1
:
0
1
)
;
bit_buffer
.
WriteBits
(
pps
.
weighted_bipred_idc
2
)
;
bit_buffer
.
WriteSignedExponentialGolomb
(
pps
.
pic_init_qp_minus26
)
;
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
bit_buffer
.
WriteExponentialGolomb
(
kIgnored
)
;
bit_buffer
.
WriteBits
(
kIgnored
2
)
;
bit_buffer
.
WriteBits
(
pps
.
redundant_pic_cnt_present_flag
1
)
;
size_t
byte_offset
;
size_t
bit_offset
;
bit_buffer
.
GetCurrentOffset
(
&
byte_offset
&
bit_offset
)
;
if
(
bit_offset
>
0
)
{
bit_buffer
.
WriteBits
(
0
8
-
bit_offset
)
;
bit_buffer
.
GetCurrentOffset
(
&
byte_offset
&
bit_offset
)
;
}
H264
:
:
WriteRbsp
(
data
byte_offset
out_buffer
)
;
}
class
PpsParserTest
:
public
:
:
testing
:
:
Test
{
public
:
PpsParserTest
(
)
{
}
virtual
~
PpsParserTest
(
)
{
}
void
RunTest
(
)
{
VerifyParsing
(
generated_pps_
0
1
0
)
;
const
int
kMaxSliceGroups
=
17
;
const
int
kMaxMapType
=
6
;
int
slice_group_bits
=
0
;
for
(
int
slice_group
=
2
;
slice_group
<
kMaxSliceGroups
;
+
+
slice_group
)
{
if
(
(
slice_group
&
(
slice_group
-
1
)
)
=
=
0
)
{
+
+
slice_group_bits
;
}
for
(
int
map_type
=
0
;
map_type
<
=
kMaxMapType
;
+
+
map_type
)
{
if
(
map_type
=
=
1
)
{
continue
;
}
else
if
(
map_type
=
=
6
)
{
int
max_pic_size
=
1
<
<
slice_group_bits
;
for
(
int
pic_size
=
1
;
pic_size
<
max_pic_size
;
+
+
pic_size
)
VerifyParsing
(
generated_pps_
map_type
slice_group
pic_size
)
;
}
else
{
VerifyParsing
(
generated_pps_
map_type
slice_group
0
)
;
}
}
}
}
void
VerifyParsing
(
const
PpsParser
:
:
PpsState
&
pps
int
slice_group_map_type
int
num_slice_groups
int
pic_size_in_map_units
)
{
buffer_
.
Clear
(
)
;
WritePps
(
pps
slice_group_map_type
num_slice_groups
pic_size_in_map_units
&
buffer_
)
;
parsed_pps_
=
PpsParser
:
:
ParsePps
(
buffer_
.
data
(
)
buffer_
.
size
(
)
)
;
EXPECT_TRUE
(
static_cast
<
bool
>
(
parsed_pps_
)
)
;
EXPECT_EQ
(
pps
.
bottom_field_pic_order_in_frame_present_flag
parsed_pps_
-
>
bottom_field_pic_order_in_frame_present_flag
)
;
EXPECT_EQ
(
pps
.
weighted_pred_flag
parsed_pps_
-
>
weighted_pred_flag
)
;
EXPECT_EQ
(
pps
.
weighted_bipred_idc
parsed_pps_
-
>
weighted_bipred_idc
)
;
EXPECT_EQ
(
pps
.
entropy_coding_mode_flag
parsed_pps_
-
>
entropy_coding_mode_flag
)
;
EXPECT_EQ
(
pps
.
redundant_pic_cnt_present_flag
parsed_pps_
-
>
redundant_pic_cnt_present_flag
)
;
EXPECT_EQ
(
pps
.
pic_init_qp_minus26
parsed_pps_
-
>
pic_init_qp_minus26
)
;
EXPECT_EQ
(
pps
.
id
parsed_pps_
-
>
id
)
;
EXPECT_EQ
(
pps
.
sps_id
parsed_pps_
-
>
sps_id
)
;
}
PpsParser
:
:
PpsState
generated_pps_
;
rtc
:
:
Buffer
buffer_
;
rtc
:
:
Optional
<
PpsParser
:
:
PpsState
>
parsed_pps_
;
}
;
TEST_F
(
PpsParserTest
ZeroPps
)
{
RunTest
(
)
;
}
TEST_F
(
PpsParserTest
MaxPps
)
{
generated_pps_
.
bottom_field_pic_order_in_frame_present_flag
=
true
;
generated_pps_
.
pic_init_qp_minus26
=
25
;
generated_pps_
.
redundant_pic_cnt_present_flag
=
1
;
generated_pps_
.
weighted_bipred_idc
=
(
1
<
<
2
)
-
1
;
generated_pps_
.
weighted_pred_flag
=
true
;
generated_pps_
.
entropy_coding_mode_flag
=
true
;
generated_pps_
.
id
=
2
;
generated_pps_
.
sps_id
=
1
;
RunTest
(
)
;
generated_pps_
.
pic_init_qp_minus26
=
-
25
;
RunTest
(
)
;
}
TEST_F
(
PpsParserTest
PpsIdFromSlice
)
{
rtc
:
:
Optional
<
uint32_t
>
pps_id
=
PpsParser
:
:
ParsePpsIdFromSlice
(
kH264BitstreamChunk
sizeof
(
kH264BitstreamChunk
)
)
;
ASSERT_TRUE
(
pps_id
)
;
EXPECT_EQ
(
2u
*
pps_id
)
;
}
}
