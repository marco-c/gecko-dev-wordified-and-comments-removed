#
ifndef
COMMON_TYPES_H_
#
define
COMMON_TYPES_H_
#
include
<
atomic
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
optional
.
h
"
#
include
"
api
/
video
/
video_content_type
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
api
/
video
/
video_timing
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
deprecation
.
h
"
#
include
"
typedefs
.
h
"
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
disable
:
4351
)
#
endif
#
if
defined
(
WEBRTC_EXPORT
)
#
define
WEBRTC_DLLEXPORT
_declspec
(
dllexport
)
#
elif
defined
(
WEBRTC_DLL
)
#
define
WEBRTC_DLLEXPORT
_declspec
(
dllimport
)
#
else
#
define
WEBRTC_DLLEXPORT
#
endif
#
ifndef
NULL
#
define
NULL
0
#
endif
#
define
RTP_PAYLOAD_NAME_SIZE
32u
#
if
defined
(
WEBRTC_WIN
)
|
|
defined
(
WIN32
)
#
define
STR_CASE_CMP
(
s1
s2
)
:
:
_stricmp
(
s1
s2
)
#
define
STR_NCASE_CMP
(
s1
s2
n
)
:
:
_strnicmp
(
s1
s2
n
)
#
else
#
define
STR_CASE_CMP
(
s1
s2
)
:
:
strcasecmp
(
s1
s2
)
#
define
STR_NCASE_CMP
(
s1
s2
n
)
:
:
strncasecmp
(
s1
s2
n
)
#
endif
namespace
webrtc
{
class
RewindableStream
{
public
:
virtual
~
RewindableStream
(
)
{
}
virtual
int
Rewind
(
)
=
0
;
}
;
class
InStream
:
public
RewindableStream
{
public
:
virtual
int
Read
(
void
*
buf
size_t
len
)
=
0
;
}
;
class
OutStream
:
public
RewindableStream
{
public
:
virtual
bool
Write
(
const
void
*
buf
size_t
len
)
=
0
;
}
;
enum
FileFormats
{
kFileFormatWavFile
=
1
kFileFormatCompressedFile
=
2
kFileFormatPreencodedFile
=
4
kFileFormatPcm16kHzFile
=
7
kFileFormatPcm8kHzFile
=
8
kFileFormatPcm32kHzFile
=
9
kFileFormatPcm48kHzFile
=
10
}
;
enum
FrameType
{
kEmptyFrame
=
0
kAudioFrameSpeech
=
1
kAudioFrameCN
=
2
kVideoFrameKey
=
3
kVideoFrameDelta
=
4
}
;
struct
RtcpStatistics
{
RtcpStatistics
(
)
:
fraction_lost
(
0
)
packets_lost
(
0
)
extended_highest_sequence_number
(
0
)
jitter
(
0
)
{
}
uint8_t
fraction_lost
;
union
{
uint32_t
packets_lost
;
RTC_DEPRECATED
uint32_t
cumulative_lost
;
}
;
union
{
uint32_t
extended_highest_sequence_number
;
RTC_DEPRECATED
uint32_t
extended_max_sequence_number
;
}
;
uint32_t
jitter
;
}
;
class
RtcpStatisticsCallback
{
public
:
virtual
~
RtcpStatisticsCallback
(
)
{
}
virtual
void
StatisticsUpdated
(
const
RtcpStatistics
&
statistics
uint32_t
ssrc
)
=
0
;
virtual
void
CNameChanged
(
const
char
*
cname
uint32_t
ssrc
)
=
0
;
}
;
struct
RtcpPacketTypeCounter
{
RtcpPacketTypeCounter
(
)
:
first_packet_time_ms
(
-
1
)
nack_packets
(
0
)
fir_packets
(
0
)
pli_packets
(
0
)
nack_requests
(
0
)
unique_nack_requests
(
0
)
{
}
void
Add
(
const
RtcpPacketTypeCounter
&
other
)
{
nack_packets
+
=
other
.
nack_packets
;
fir_packets
+
=
other
.
fir_packets
;
pli_packets
+
=
other
.
pli_packets
;
nack_requests
+
=
other
.
nack_requests
;
unique_nack_requests
+
=
other
.
unique_nack_requests
;
if
(
other
.
first_packet_time_ms
!
=
-
1
&
&
(
other
.
first_packet_time_ms
<
first_packet_time_ms
|
|
first_packet_time_ms
=
=
-
1
)
)
{
first_packet_time_ms
=
other
.
first_packet_time_ms
;
}
}
void
Subtract
(
const
RtcpPacketTypeCounter
&
other
)
{
nack_packets
-
=
other
.
nack_packets
;
fir_packets
-
=
other
.
fir_packets
;
pli_packets
-
=
other
.
pli_packets
;
nack_requests
-
=
other
.
nack_requests
;
unique_nack_requests
-
=
other
.
unique_nack_requests
;
if
(
other
.
first_packet_time_ms
!
=
-
1
&
&
(
other
.
first_packet_time_ms
>
first_packet_time_ms
|
|
first_packet_time_ms
=
=
-
1
)
)
{
first_packet_time_ms
=
other
.
first_packet_time_ms
;
}
}
int64_t
TimeSinceFirstPacketInMs
(
int64_t
now_ms
)
const
{
return
(
first_packet_time_ms
=
=
-
1
)
?
-
1
:
(
now_ms
-
first_packet_time_ms
)
;
}
int
UniqueNackRequestsInPercent
(
)
const
{
if
(
nack_requests
=
=
0
)
{
return
0
;
}
return
static_cast
<
int
>
(
(
unique_nack_requests
*
100
.
0f
/
nack_requests
)
+
0
.
5f
)
;
}
int64_t
first_packet_time_ms
;
uint32_t
nack_packets
;
uint32_t
fir_packets
;
uint32_t
pli_packets
;
uint32_t
nack_requests
;
uint32_t
unique_nack_requests
;
}
;
class
RtcpPacketTypeCounterObserver
{
public
:
virtual
~
RtcpPacketTypeCounterObserver
(
)
{
}
virtual
void
RtcpPacketTypesCounterUpdated
(
uint32_t
ssrc
const
RtcpPacketTypeCounter
&
packet_counter
)
=
0
;
}
;
struct
BitrateStatistics
{
BitrateStatistics
(
)
:
bitrate_bps
(
0
)
packet_rate
(
0
)
{
}
uint32_t
bitrate_bps
;
uint32_t
packet_rate
;
}
;
class
BitrateStatisticsObserver
{
public
:
virtual
~
BitrateStatisticsObserver
(
)
{
}
virtual
void
Notify
(
uint32_t
total_bitrate_bps
uint32_t
retransmit_bitrate_bps
uint32_t
ssrc
)
=
0
;
}
;
struct
FrameCounts
{
FrameCounts
(
)
:
key_frames
(
0
)
delta_frames
(
0
)
{
}
int
key_frames
;
int
delta_frames
;
}
;
class
FrameCountObserver
{
public
:
virtual
~
FrameCountObserver
(
)
{
}
virtual
void
FrameCountUpdated
(
const
FrameCounts
&
frame_counts
uint32_t
ssrc
)
=
0
;
}
;
class
SendSideDelayObserver
{
public
:
virtual
~
SendSideDelayObserver
(
)
{
}
virtual
void
SendSideDelayUpdated
(
int
avg_delay_ms
int
max_delay_ms
uint32_t
ssrc
)
=
0
;
}
;
class
SendPacketObserver
{
public
:
virtual
~
SendPacketObserver
(
)
{
}
virtual
void
OnSendPacket
(
uint16_t
packet_id
int64_t
capture_time_ms
uint32_t
ssrc
)
=
0
;
}
;
class
OverheadObserver
{
public
:
virtual
~
OverheadObserver
(
)
=
default
;
virtual
void
OnOverheadChanged
(
size_t
overhead_bytes_per_packet
)
=
0
;
}
;
struct
CodecInst
{
int
pltype
;
char
plname
[
RTP_PAYLOAD_NAME_SIZE
]
;
int
plfreq
;
int
pacsize
;
size_t
channels
;
int
rate
;
bool
operator
=
=
(
const
CodecInst
&
other
)
const
{
return
pltype
=
=
other
.
pltype
&
&
(
STR_CASE_CMP
(
plname
other
.
plname
)
=
=
0
)
&
&
plfreq
=
=
other
.
plfreq
&
&
pacsize
=
=
other
.
pacsize
&
&
channels
=
=
other
.
channels
&
&
rate
=
=
other
.
rate
;
}
bool
operator
!
=
(
const
CodecInst
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
CodecInst
&
ci
)
{
os
<
<
"
{
pltype
:
"
<
<
ci
.
pltype
;
os
<
<
"
plname
:
"
<
<
ci
.
plname
;
os
<
<
"
plfreq
:
"
<
<
ci
.
plfreq
;
os
<
<
"
pacsize
:
"
<
<
ci
.
pacsize
;
os
<
<
"
channels
:
"
<
<
ci
.
channels
;
os
<
<
"
rate
:
"
<
<
ci
.
rate
<
<
"
}
"
;
return
os
;
}
}
;
enum
{
kRtpCsrcSize
=
15
}
;
enum
PayloadFrequencies
{
kFreq8000Hz
=
8000
kFreq16000Hz
=
16000
kFreq32000Hz
=
32000
}
;
enum
VadModes
{
kVadConventional
=
0
kVadAggressiveLow
kVadAggressiveMid
kVadAggressiveHigh
}
;
struct
NetworkStatistics
{
uint16_t
currentBufferSize
;
uint16_t
preferredBufferSize
;
bool
jitterPeaksFound
;
uint64_t
totalSamplesReceived
;
uint64_t
concealedSamples
;
uint64_t
concealmentEvents
;
uint64_t
jitterBufferDelayMs
;
uint16_t
currentPacketLossRate
;
union
{
RTC_DEPRECATED
uint16_t
currentDiscardRate
;
}
;
uint16_t
currentExpandRate
;
uint16_t
currentSpeechExpandRate
;
uint16_t
currentPreemptiveRate
;
uint16_t
currentAccelerateRate
;
uint16_t
currentSecondaryDecodedRate
;
uint16_t
currentSecondaryDiscardedRate
;
int32_t
clockDriftPPM
;
int
meanWaitingTimeMs
;
int
medianWaitingTimeMs
;
int
minWaitingTimeMs
;
int
maxWaitingTimeMs
;
size_t
addedSamples
;
}
;
struct
AudioDecodingCallStats
{
AudioDecodingCallStats
(
)
:
calls_to_silence_generator
(
0
)
calls_to_neteq
(
0
)
decoded_normal
(
0
)
decoded_plc
(
0
)
decoded_cng
(
0
)
decoded_plc_cng
(
0
)
decoded_muted_output
(
0
)
{
}
AudioDecodingCallStats
(
const
AudioDecodingCallStats
&
other
)
{
calls_to_silence_generator
=
other
.
calls_to_silence_generator
.
load
(
)
;
calls_to_neteq
=
other
.
calls_to_neteq
.
load
(
)
;
decoded_normal
=
other
.
decoded_normal
.
load
(
)
;
decoded_plc
=
other
.
decoded_plc
.
load
(
)
;
decoded_cng
=
other
.
decoded_cng
.
load
(
)
;
decoded_plc_cng
=
other
.
decoded_plc_cng
.
load
(
)
;
decoded_muted_output
=
other
.
decoded_muted_output
.
load
(
)
;
}
AudioDecodingCallStats
&
operator
=
(
const
AudioDecodingCallStats
&
other
)
{
calls_to_silence_generator
=
other
.
calls_to_silence_generator
.
load
(
)
;
calls_to_neteq
=
other
.
calls_to_neteq
.
load
(
)
;
decoded_normal
=
other
.
decoded_normal
.
load
(
)
;
decoded_plc
=
other
.
decoded_plc
.
load
(
)
;
decoded_cng
=
other
.
decoded_cng
.
load
(
)
;
decoded_plc_cng
=
other
.
decoded_plc_cng
.
load
(
)
;
decoded_muted_output
=
other
.
decoded_muted_output
.
load
(
)
;
return
*
this
;
}
std
:
:
atomic
<
int
>
calls_to_silence_generator
;
std
:
:
atomic
<
int
>
calls_to_neteq
;
std
:
:
atomic
<
int
>
decoded_normal
;
std
:
:
atomic
<
int
>
decoded_plc
;
std
:
:
atomic
<
int
>
decoded_cng
;
std
:
:
atomic
<
int
>
decoded_plc_cng
;
std
:
:
atomic
<
int
>
decoded_muted_output
;
}
;
enum
class
VideoType
{
kUnknown
kI420
kIYUV
kRGB24
kABGR
kARGB
kARGB4444
kRGB565
kARGB1555
kYUY2
kYV12
kUYVY
kMJPEG
kNV21
kNV12
kBGRA
}
;
enum
{
kPayloadNameSize
=
32
}
;
enum
{
kMaxSimulcastStreams
=
4
}
;
enum
{
kMaxSpatialLayers
=
5
}
;
enum
{
kMaxTemporalStreams
=
4
}
;
enum
{
kRIDSize
=
32
}
;
enum
VideoCodecComplexity
{
kComplexityNormal
=
0
kComplexityHigh
=
1
kComplexityHigher
=
2
kComplexityMax
=
3
}
;
enum
VP8ResilienceMode
{
kResilienceOff
kResilientStream
kResilientFrames
}
;
class
TemporalLayersFactory
;
struct
VideoCodecVP8
{
bool
pictureLossIndicationOn
;
VideoCodecComplexity
complexity
;
VP8ResilienceMode
resilience
;
unsigned
char
numberOfTemporalLayers
;
bool
denoisingOn
;
bool
errorConcealmentOn
;
bool
automaticResizeOn
;
bool
frameDroppingOn
;
int
keyFrameInterval
;
TemporalLayersFactory
*
tl_factory
;
}
;
struct
VideoCodecVP9
{
VideoCodecComplexity
complexity
;
bool
resilienceOn
;
unsigned
char
numberOfTemporalLayers
;
bool
denoisingOn
;
bool
frameDroppingOn
;
int
keyFrameInterval
;
bool
adaptiveQpMode
;
bool
automaticResizeOn
;
unsigned
char
numberOfSpatialLayers
;
bool
flexibleMode
;
}
;
namespace
H264
{
enum
Profile
{
kProfileConstrainedBaseline
kProfileBaseline
kProfileMain
kProfileConstrainedHigh
kProfileHigh
}
;
}
struct
VideoCodecH264
{
bool
frameDroppingOn
;
int
keyFrameInterval
;
double
scaleDownBy
;
const
uint8_t
*
spsData
;
size_t
spsLen
;
const
uint8_t
*
ppsData
;
size_t
ppsLen
;
H264
:
:
Profile
profile
;
uint8_t
packetizationMode
;
}
;
enum
VideoCodecType
{
kVideoCodecVP8
kVideoCodecVP9
kVideoCodecH264
kVideoCodecI420
kVideoCodecRED
kVideoCodecULPFEC
kVideoCodecFlexfec
kVideoCodecGeneric
kVideoCodecUnknown
}
;
const
char
*
CodecTypeToPayloadString
(
VideoCodecType
type
)
;
VideoCodecType
PayloadStringToCodecType
(
const
std
:
:
string
&
name
)
;
union
VideoCodecUnion
{
VideoCodecVP8
VP8
;
VideoCodecVP9
VP9
;
VideoCodecH264
H264
;
}
;
struct
SimulcastStream
{
unsigned
short
width
;
unsigned
short
height
;
unsigned
char
numberOfTemporalLayers
;
unsigned
int
maxBitrate
;
unsigned
int
targetBitrate
;
unsigned
int
minBitrate
;
unsigned
int
qpMax
;
char
rid
[
kRIDSize
]
;
}
;
struct
SpatialLayer
{
int
scaling_factor_num
;
int
scaling_factor_den
;
int
target_bitrate_bps
;
}
;
enum
VideoCodecMode
{
kRealtimeVideo
kScreensharing
}
;
class
VideoCodec
{
public
:
VideoCodec
(
)
;
VideoCodecType
codecType
;
char
plName
[
kPayloadNameSize
]
;
unsigned
char
plType
;
unsigned
short
width
;
unsigned
short
height
;
unsigned
int
startBitrate
;
unsigned
int
maxBitrate
;
unsigned
int
minBitrate
;
unsigned
int
targetBitrate
;
uint32_t
maxFramerate
;
unsigned
int
qpMax
;
unsigned
char
numberOfSimulcastStreams
;
SimulcastStream
simulcastStream
[
kMaxSimulcastStreams
]
;
SpatialLayer
spatialLayers
[
kMaxSpatialLayers
]
;
VideoCodecMode
mode
;
bool
expect_encode_from_texture
;
struct
TimingFrameTriggerThresholds
{
int64_t
delay_ms
;
uint16_t
outlier_ratio_percent
;
}
timing_frame_thresholds
;
bool
operator
=
=
(
const
VideoCodec
&
other
)
const
=
delete
;
bool
operator
!
=
(
const
VideoCodec
&
other
)
const
=
delete
;
VideoCodecVP8
*
VP8
(
)
;
const
VideoCodecVP8
&
VP8
(
)
const
;
VideoCodecVP9
*
VP9
(
)
;
const
VideoCodecVP9
&
VP9
(
)
const
;
VideoCodecH264
*
H264
(
)
;
const
VideoCodecH264
&
H264
(
)
const
;
private
:
VideoCodecUnion
codec_specific_
;
}
;
class
BitrateAllocation
{
public
:
static
const
uint32_t
kMaxBitrateBps
;
BitrateAllocation
(
)
;
bool
SetBitrate
(
size_t
spatial_index
size_t
temporal_index
uint32_t
bitrate_bps
)
;
bool
HasBitrate
(
size_t
spatial_index
size_t
temporal_index
)
const
;
uint32_t
GetBitrate
(
size_t
spatial_index
size_t
temporal_index
)
const
;
bool
IsSpatialLayerUsed
(
size_t
spatial_index
)
const
;
uint32_t
GetSpatialLayerSum
(
size_t
spatial_index
)
const
;
uint32_t
get_sum_bps
(
)
const
{
return
sum_
;
}
uint32_t
get_sum_kbps
(
)
const
{
return
(
sum_
+
500
)
/
1000
;
}
inline
bool
operator
=
=
(
const
BitrateAllocation
&
other
)
const
{
return
memcmp
(
bitrates_
other
.
bitrates_
sizeof
(
bitrates_
)
)
=
=
0
;
}
inline
bool
operator
!
=
(
const
BitrateAllocation
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
std
:
:
string
ToString
(
)
const
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
)
const
;
private
:
uint32_t
sum_
;
uint32_t
bitrates_
[
kMaxSpatialLayers
]
[
kMaxTemporalStreams
]
;
bool
has_bitrate_
[
kMaxSpatialLayers
]
[
kMaxTemporalStreams
]
;
}
;
struct
OverUseDetectorOptions
{
OverUseDetectorOptions
(
)
:
initial_slope
(
8
.
0
/
512
.
0
)
initial_offset
(
0
)
initial_e
(
)
initial_process_noise
(
)
initial_avg_noise
(
0
.
0
)
initial_var_noise
(
50
)
{
initial_e
[
0
]
[
0
]
=
100
;
initial_e
[
1
]
[
1
]
=
1e
-
1
;
initial_e
[
0
]
[
1
]
=
initial_e
[
1
]
[
0
]
=
0
;
initial_process_noise
[
0
]
=
1e
-
13
;
initial_process_noise
[
1
]
=
1e
-
3
;
}
double
initial_slope
;
double
initial_offset
;
double
initial_e
[
2
]
[
2
]
;
double
initial_process_noise
[
2
]
;
double
initial_avg_noise
;
double
initial_var_noise
;
}
;
enum
CPULoadState
{
kLoadRelaxed
=
0
kLoadNormal
kLoadStressed
kLoadLast
}
;
class
CPULoadStateObserver
{
public
:
virtual
void
onLoadStateChanged
(
CPULoadState
aNewState
)
=
0
;
virtual
~
CPULoadStateObserver
(
)
{
}
;
}
;
class
CPULoadStateCallbackInvoker
{
public
:
virtual
void
AddObserver
(
CPULoadStateObserver
*
aObserver
)
=
0
;
virtual
void
RemoveObserver
(
CPULoadStateObserver
*
aObserver
)
=
0
;
virtual
~
CPULoadStateCallbackInvoker
(
)
{
}
;
}
;
struct
PacketTime
{
PacketTime
(
)
:
timestamp
(
-
1
)
not_before
(
-
1
)
{
}
PacketTime
(
int64_t
timestamp
int64_t
not_before
)
:
timestamp
(
timestamp
)
not_before
(
not_before
)
{
}
int64_t
timestamp
;
int64_t
not_before
;
}
;
struct
PlayoutDelay
{
int
min_ms
;
int
max_ms
;
}
;
class
StringRtpHeaderExtension
{
public
:
static
constexpr
size_t
kMaxSize
=
16
;
static
bool
IsLegalName
(
rtc
:
:
ArrayView
<
const
char
>
name
)
;
StringRtpHeaderExtension
(
)
{
value_
[
0
]
=
0
;
}
explicit
StringRtpHeaderExtension
(
rtc
:
:
ArrayView
<
const
char
>
value
)
{
Set
(
value
.
data
(
)
value
.
size
(
)
)
;
}
StringRtpHeaderExtension
(
const
StringRtpHeaderExtension
&
)
=
default
;
StringRtpHeaderExtension
&
operator
=
(
const
StringRtpHeaderExtension
&
)
=
default
;
bool
empty
(
)
const
{
return
value_
[
0
]
=
=
0
;
}
const
char
*
data
(
)
const
{
return
value_
;
}
size_t
size
(
)
const
{
return
strnlen
(
value_
kMaxSize
)
;
}
void
Set
(
rtc
:
:
ArrayView
<
const
uint8_t
>
value
)
{
Set
(
reinterpret_cast
<
const
char
*
>
(
value
.
data
(
)
)
value
.
size
(
)
)
;
}
void
Set
(
const
char
*
data
size_t
size
)
;
friend
bool
operator
=
=
(
const
StringRtpHeaderExtension
&
lhs
const
StringRtpHeaderExtension
&
rhs
)
{
return
strncmp
(
lhs
.
value_
rhs
.
value_
kMaxSize
)
=
=
0
;
}
friend
bool
operator
!
=
(
const
StringRtpHeaderExtension
&
lhs
const
StringRtpHeaderExtension
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
private
:
char
value_
[
kMaxSize
]
;
}
;
typedef
StringRtpHeaderExtension
StreamId
;
typedef
StringRtpHeaderExtension
Mid
;
struct
CsrcAudioLevelList
{
CsrcAudioLevelList
(
)
:
numAudioLevels
(
0
)
{
}
CsrcAudioLevelList
(
const
CsrcAudioLevelList
&
)
=
default
;
CsrcAudioLevelList
&
operator
=
(
const
CsrcAudioLevelList
&
)
=
default
;
uint8_t
numAudioLevels
;
uint8_t
arrOfAudioLevels
[
kRtpCsrcSize
]
;
}
;
struct
RTPHeaderExtension
{
RTPHeaderExtension
(
)
;
RTPHeaderExtension
(
const
RTPHeaderExtension
&
other
)
;
RTPHeaderExtension
&
operator
=
(
const
RTPHeaderExtension
&
other
)
;
bool
hasTransmissionTimeOffset
;
int32_t
transmissionTimeOffset
;
bool
hasAbsoluteSendTime
;
uint32_t
absoluteSendTime
;
bool
hasTransportSequenceNumber
;
uint16_t
transportSequenceNumber
;
bool
hasAudioLevel
;
bool
voiceActivity
;
uint8_t
audioLevel
;
bool
hasVideoRotation
;
VideoRotation
videoRotation
;
bool
hasVideoContentType
;
VideoContentType
videoContentType
;
bool
has_video_timing
;
VideoSendTiming
video_timing
;
PlayoutDelay
playout_delay
=
{
-
1
-
1
}
;
StreamId
stream_id
;
StreamId
repaired_stream_id
;
Mid
mid
;
CsrcAudioLevelList
csrcAudioLevels
;
}
;
struct
RTPHeader
{
RTPHeader
(
)
;
RTPHeader
(
const
RTPHeader
&
other
)
;
RTPHeader
&
operator
=
(
const
RTPHeader
&
other
)
;
bool
markerBit
;
uint8_t
payloadType
;
uint16_t
sequenceNumber
;
uint32_t
timestamp
;
uint32_t
ssrc
;
uint8_t
numCSRCs
;
uint32_t
arrOfCSRCs
[
kRtpCsrcSize
]
;
size_t
paddingLength
;
size_t
headerLength
;
int
payload_type_frequency
;
RTPHeaderExtension
extension
;
}
;
struct
RtpPacketCounter
{
RtpPacketCounter
(
)
:
header_bytes
(
0
)
payload_bytes
(
0
)
padding_bytes
(
0
)
packets
(
0
)
{
}
void
Add
(
const
RtpPacketCounter
&
other
)
{
header_bytes
+
=
other
.
header_bytes
;
payload_bytes
+
=
other
.
payload_bytes
;
padding_bytes
+
=
other
.
padding_bytes
;
packets
+
=
other
.
packets
;
}
void
Subtract
(
const
RtpPacketCounter
&
other
)
{
RTC_DCHECK_GE
(
header_bytes
other
.
header_bytes
)
;
header_bytes
-
=
other
.
header_bytes
;
RTC_DCHECK_GE
(
payload_bytes
other
.
payload_bytes
)
;
payload_bytes
-
=
other
.
payload_bytes
;
RTC_DCHECK_GE
(
padding_bytes
other
.
padding_bytes
)
;
padding_bytes
-
=
other
.
padding_bytes
;
RTC_DCHECK_GE
(
packets
other
.
packets
)
;
packets
-
=
other
.
packets
;
}
void
AddPacket
(
size_t
packet_length
const
RTPHeader
&
header
)
{
+
+
packets
;
header_bytes
+
=
header
.
headerLength
;
padding_bytes
+
=
header
.
paddingLength
;
payload_bytes
+
=
packet_length
-
(
header
.
headerLength
+
header
.
paddingLength
)
;
}
size_t
TotalBytes
(
)
const
{
return
header_bytes
+
payload_bytes
+
padding_bytes
;
}
size_t
header_bytes
;
size_t
payload_bytes
;
size_t
padding_bytes
;
uint32_t
packets
;
}
;
struct
StreamDataCounters
{
StreamDataCounters
(
)
;
void
Add
(
const
StreamDataCounters
&
other
)
{
transmitted
.
Add
(
other
.
transmitted
)
;
retransmitted
.
Add
(
other
.
retransmitted
)
;
fec
.
Add
(
other
.
fec
)
;
if
(
other
.
first_packet_time_ms
!
=
-
1
&
&
(
other
.
first_packet_time_ms
<
first_packet_time_ms
|
|
first_packet_time_ms
=
=
-
1
)
)
{
first_packet_time_ms
=
other
.
first_packet_time_ms
;
}
}
void
Subtract
(
const
StreamDataCounters
&
other
)
{
transmitted
.
Subtract
(
other
.
transmitted
)
;
retransmitted
.
Subtract
(
other
.
retransmitted
)
;
fec
.
Subtract
(
other
.
fec
)
;
if
(
other
.
first_packet_time_ms
!
=
-
1
&
&
(
other
.
first_packet_time_ms
>
first_packet_time_ms
|
|
first_packet_time_ms
=
=
-
1
)
)
{
first_packet_time_ms
=
other
.
first_packet_time_ms
;
}
}
int64_t
TimeSinceFirstPacketInMs
(
int64_t
now_ms
)
const
{
return
(
first_packet_time_ms
=
=
-
1
)
?
-
1
:
(
now_ms
-
first_packet_time_ms
)
;
}
size_t
MediaPayloadBytes
(
)
const
{
return
transmitted
.
payload_bytes
-
retransmitted
.
payload_bytes
-
fec
.
payload_bytes
;
}
int64_t
first_packet_time_ms
;
RtpPacketCounter
transmitted
;
RtpPacketCounter
retransmitted
;
RtpPacketCounter
fec
;
}
;
class
StreamDataCountersCallback
{
public
:
virtual
~
StreamDataCountersCallback
(
)
{
}
virtual
void
DataCountersUpdated
(
const
StreamDataCounters
&
counters
uint32_t
ssrc
)
=
0
;
}
;
enum
class
RtcpMode
{
kOff
kCompound
kReducedSize
}
;
enum
NetworkState
{
kNetworkUp
kNetworkDown
}
;
struct
RtpKeepAliveConfig
final
{
int64_t
timeout_interval_ms
=
-
1
;
uint8_t
payload_type
=
20
;
bool
operator
=
=
(
const
RtpKeepAliveConfig
&
o
)
const
{
return
timeout_interval_ms
=
=
o
.
timeout_interval_ms
&
&
payload_type
=
=
o
.
payload_type
;
}
bool
operator
!
=
(
const
RtpKeepAliveConfig
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
struct
RtpPayloadState
{
int16_t
picture_id
=
-
1
;
}
;
}
#
endif
