#
ifndef
VIDEO_PAYLOAD_ROUTER_H_
#
define
VIDEO_PAYLOAD_ROUTER_H_
#
include
<
map
>
#
include
<
vector
>
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
common_types
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
RTPFragmentationHeader
;
class
RtpRtcp
;
struct
RTPVideoHeader
;
class
PayloadRouter
:
public
EncodedImageCallback
{
public
:
PayloadRouter
(
const
std
:
:
vector
<
RtpRtcp
*
>
&
rtp_modules
const
std
:
:
vector
<
uint32_t
>
&
ssrcs
int
payload_type
const
std
:
:
map
<
uint32_t
RtpPayloadState
>
&
states
)
;
~
PayloadRouter
(
)
;
void
SetActive
(
bool
active
)
;
bool
IsActive
(
)
;
std
:
:
map
<
uint32_t
RtpPayloadState
>
GetRtpPayloadStates
(
)
const
;
EncodedImageCallback
:
:
Result
OnEncodedImage
(
const
EncodedImage
&
encoded_image
const
CodecSpecificInfo
*
codec_specific_info
const
RTPFragmentationHeader
*
fragmentation
)
override
;
void
OnBitrateAllocationUpdated
(
const
BitrateAllocation
&
bitrate
)
;
private
:
class
RtpPayloadParams
;
void
UpdateModuleSendingState
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
rtc
:
:
CriticalSection
crit_
;
bool
active_
RTC_GUARDED_BY
(
crit_
)
;
const
std
:
:
vector
<
RtpRtcp
*
>
rtp_modules_
;
const
int
payload_type_
;
const
bool
forced_fallback_enabled_
;
std
:
:
vector
<
RtpPayloadParams
>
params_
RTC_GUARDED_BY
(
crit_
)
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
PayloadRouter
)
;
}
;
}
#
endif
