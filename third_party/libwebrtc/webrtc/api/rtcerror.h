#
ifndef
API_RTCERROR_H_
#
define
API_RTCERROR_H_
#
include
<
ostream
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
enum
class
RTCErrorType
{
NONE
UNSUPPORTED_OPERATION
UNSUPPORTED_PARAMETER
INVALID_PARAMETER
INVALID_RANGE
SYNTAX_ERROR
INVALID_STATE
INVALID_MODIFICATION
NETWORK_ERROR
RESOURCE_EXHAUSTED
INTERNAL_ERROR
}
;
class
RTCError
{
public
:
RTCError
(
)
{
}
explicit
RTCError
(
RTCErrorType
type
)
:
type_
(
type
)
{
}
RTCError
(
RTCErrorType
type
const
char
*
message
)
:
type_
(
type
)
static_message_
(
message
)
have_string_message_
(
false
)
{
}
RTCError
(
RTCErrorType
type
std
:
:
string
&
&
message
)
:
type_
(
type
)
string_message_
(
message
)
have_string_message_
(
true
)
{
}
RTCError
(
const
RTCError
&
other
)
=
delete
;
RTCError
&
operator
=
(
const
RTCError
&
other
)
=
delete
;
RTCError
(
RTCError
&
&
other
)
;
RTCError
&
operator
=
(
RTCError
&
&
other
)
;
~
RTCError
(
)
;
static
RTCError
OK
(
)
;
RTCErrorType
type
(
)
const
{
return
type_
;
}
void
set_type
(
RTCErrorType
type
)
{
type_
=
type
;
}
const
char
*
message
(
)
const
;
void
set_message
(
const
char
*
message
)
;
void
set_message
(
std
:
:
string
&
&
message
)
;
bool
ok
(
)
const
{
return
type_
=
=
RTCErrorType
:
:
NONE
;
}
private
:
RTCErrorType
type_
=
RTCErrorType
:
:
NONE
;
union
{
const
char
*
static_message_
=
"
"
;
std
:
:
string
string_message_
;
}
;
bool
have_string_message_
=
false
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
RTCErrorType
error
)
;
#
define
LOG_AND_RETURN_ERROR_EX
(
type
message
severity
)
\
{
\
RTC_DCHECK
(
type
!
=
RTCErrorType
:
:
NONE
)
;
\
RTC_LOG
(
severity
)
<
<
message
<
<
"
(
"
<
<
type
<
<
"
)
"
;
\
return
webrtc
:
:
RTCError
(
type
message
)
;
\
}
#
define
LOG_AND_RETURN_ERROR
(
type
message
)
\
LOG_AND_RETURN_ERROR_EX
(
type
message
LS_ERROR
)
template
<
typename
T
>
class
RTCErrorOr
{
template
<
typename
U
>
friend
class
RTCErrorOr
;
public
:
typedef
T
element_type
;
RTCErrorOr
(
)
:
error_
(
RTCErrorType
:
:
INTERNAL_ERROR
)
{
}
RTCErrorOr
(
RTCError
&
&
error
)
:
error_
(
std
:
:
move
(
error
)
)
{
RTC_DCHECK
(
!
error
.
ok
(
)
)
;
}
RTCErrorOr
(
T
&
&
value
)
:
value_
(
std
:
:
move
(
value
)
)
{
}
RTCErrorOr
(
const
RTCErrorOr
&
other
)
=
delete
;
RTCErrorOr
&
operator
=
(
const
RTCErrorOr
&
other
)
=
delete
;
RTCErrorOr
(
RTCErrorOr
&
&
other
)
:
error_
(
std
:
:
move
(
other
.
error_
)
)
value_
(
std
:
:
move
(
other
.
value_
)
)
{
}
RTCErrorOr
&
operator
=
(
RTCErrorOr
&
&
other
)
{
error_
=
std
:
:
move
(
other
.
error_
)
;
value_
=
std
:
:
move
(
other
.
value_
)
;
return
*
this
;
}
template
<
typename
U
>
RTCErrorOr
(
RTCErrorOr
<
U
>
other
)
:
error_
(
std
:
:
move
(
other
.
error_
)
)
value_
(
std
:
:
move
(
other
.
value_
)
)
{
}
template
<
typename
U
>
RTCErrorOr
&
operator
=
(
RTCErrorOr
<
U
>
other
)
{
error_
=
std
:
:
move
(
other
.
error_
)
;
value_
=
std
:
:
move
(
other
.
value_
)
;
return
*
this
;
}
const
RTCError
&
error
(
)
const
{
return
error_
;
}
RTCError
MoveError
(
)
{
return
std
:
:
move
(
error_
)
;
}
bool
ok
(
)
const
{
return
error_
.
ok
(
)
;
}
const
T
&
value
(
)
const
{
RTC_DCHECK
(
ok
(
)
)
;
return
value_
;
}
T
&
value
(
)
{
RTC_DCHECK
(
ok
(
)
)
;
return
value_
;
}
T
MoveValue
(
)
{
RTC_DCHECK
(
ok
(
)
)
;
return
std
:
:
move
(
value_
)
;
}
private
:
RTCError
error_
;
T
value_
;
}
;
}
#
endif
