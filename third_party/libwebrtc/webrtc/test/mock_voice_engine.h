#
ifndef
AUDIO_MOCK_VOICE_ENGINE_H_
#
define
AUDIO_MOCK_VOICE_ENGINE_H_
#
include
<
memory
>
#
include
"
modules
/
audio_device
/
include
/
mock_audio_transport
.
h
"
#
include
"
modules
/
rtp_rtcp
/
mocks
/
mock_rtp_rtcp
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
mock_voe_channel_proxy
.
h
"
#
include
"
voice_engine
/
voice_engine_impl
.
h
"
namespace
webrtc
{
namespace
voe
{
class
TransmitMixer
;
}
namespace
test
{
class
MockVoiceEngine
:
public
VoiceEngineImpl
{
public
:
MockVoiceEngine
(
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
=
nullptr
)
:
decoder_factory_
(
decoder_factory
)
{
+
+
_ref_count
;
ON_CALL
(
*
this
ChannelProxyFactory
(
testing
:
:
_
)
)
.
WillByDefault
(
testing
:
:
Invoke
(
[
this
]
(
int
channel_id
)
{
auto
*
proxy
=
new
testing
:
:
NiceMock
<
webrtc
:
:
test
:
:
MockVoEChannelProxy
>
(
)
;
EXPECT_CALL
(
*
proxy
GetAudioDecoderFactory
(
)
)
.
WillRepeatedly
(
testing
:
:
ReturnRef
(
decoder_factory_
)
)
;
EXPECT_CALL
(
*
proxy
SetReceiveCodecs
(
testing
:
:
_
)
)
.
WillRepeatedly
(
testing
:
:
Invoke
(
[
]
(
const
std
:
:
map
<
int
SdpAudioFormat
>
&
codecs
)
{
EXPECT_THAT
(
codecs
testing
:
:
IsEmpty
(
)
)
;
}
)
)
;
EXPECT_CALL
(
*
proxy
GetRtpRtcp
(
testing
:
:
_
testing
:
:
_
)
)
.
WillRepeatedly
(
testing
:
:
SetArgPointee
<
0
>
(
GetMockRtpRtcp
(
channel_id
)
)
)
;
return
proxy
;
}
)
)
;
ON_CALL
(
*
this
audio_transport
(
)
)
.
WillByDefault
(
testing
:
:
Return
(
&
mock_audio_transport_
)
)
;
}
virtual
~
MockVoiceEngine
(
)
{
-
-
_ref_count
;
}
MockRtpRtcp
*
GetMockRtpRtcp
(
int
channel_id
)
{
if
(
mock_rtp_rtcps_
.
find
(
channel_id
)
=
=
mock_rtp_rtcps_
.
end
(
)
)
{
mock_rtp_rtcps_
[
channel_id
]
.
reset
(
new
:
:
testing
:
:
NiceMock
<
MockRtpRtcp
>
)
;
}
return
mock_rtp_rtcps_
[
channel_id
]
.
get
(
)
;
}
MOCK_METHOD1
(
ChannelProxyFactory
voe
:
:
ChannelProxy
*
(
int
channel_id
)
)
;
virtual
std
:
:
unique_ptr
<
voe
:
:
ChannelProxy
>
GetChannelProxy
(
int
channel_id
)
{
return
std
:
:
unique_ptr
<
voe
:
:
ChannelProxy
>
(
ChannelProxyFactory
(
channel_id
)
)
;
}
MOCK_METHOD3
(
Init
int
(
AudioDeviceModule
*
external_adm
AudioProcessing
*
external_apm
const
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
&
decoder_factory
)
)
;
MOCK_METHOD0
(
transmit_mixer
voe
:
:
TransmitMixer
*
(
)
)
;
MOCK_METHOD0
(
Terminate
void
(
)
)
;
MOCK_METHOD0
(
CreateChannel
int
(
)
)
;
MOCK_METHOD1
(
CreateChannel
int
(
const
ChannelConfig
&
config
)
)
;
MOCK_METHOD1
(
DeleteChannel
int
(
int
channel
)
)
;
MOCK_METHOD1
(
StartPlayout
int
(
int
channel
)
)
;
MOCK_METHOD1
(
StopPlayout
int
(
int
channel
)
)
;
MOCK_METHOD1
(
StartSend
int
(
int
channel
)
)
;
MOCK_METHOD1
(
StopSend
int
(
int
channel
)
)
;
MOCK_METHOD0
(
audio_transport
AudioTransport
*
(
)
)
;
private
:
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory_
;
std
:
:
map
<
int
std
:
:
unique_ptr
<
MockRtpRtcp
>
>
mock_rtp_rtcps_
;
MockAudioTransport
mock_audio_transport_
;
}
;
}
}
#
endif
