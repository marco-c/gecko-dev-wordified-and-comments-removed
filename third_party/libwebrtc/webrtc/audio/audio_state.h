#
ifndef
AUDIO_AUDIO_STATE_H_
#
define
AUDIO_AUDIO_STATE_H_
#
include
<
memory
>
#
include
"
audio
/
audio_transport_proxy
.
h
"
#
include
"
audio
/
null_audio_poller
.
h
"
#
include
"
audio
/
scoped_voe_interface
.
h
"
#
include
"
call
/
audio_state
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
refcount
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
#
include
"
voice_engine
/
include
/
voe_base
.
h
"
namespace
webrtc
{
namespace
internal
{
class
AudioState
final
:
public
webrtc
:
:
AudioState
{
public
:
explicit
AudioState
(
const
AudioState
:
:
Config
&
config
)
;
~
AudioState
(
)
override
;
AudioProcessing
*
audio_processing
(
)
override
{
RTC_DCHECK
(
config_
.
audio_processing
)
;
return
config_
.
audio_processing
.
get
(
)
;
}
AudioTransport
*
audio_transport
(
)
override
{
return
&
audio_transport_proxy_
;
}
void
SetPlayout
(
bool
enabled
)
override
;
void
SetRecording
(
bool
enabled
)
override
;
VoiceEngine
*
voice_engine
(
)
;
rtc
:
:
scoped_refptr
<
AudioMixer
>
mixer
(
)
;
bool
typing_noise_detected
(
)
const
;
private
:
void
AddRef
(
)
const
override
;
rtc
:
:
RefCountReleaseStatus
Release
(
)
const
override
;
rtc
:
:
ThreadChecker
thread_checker_
;
rtc
:
:
ThreadChecker
process_thread_checker_
;
const
webrtc
:
:
AudioState
:
:
Config
config_
;
ScopedVoEInterface
<
VoEBase
>
voe_base_
;
mutable
volatile
int
ref_count_
=
0
;
AudioTransportProxy
audio_transport_proxy_
;
std
:
:
unique_ptr
<
NullAudioPoller
>
null_audio_poller_
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
AudioState
)
;
}
;
}
}
#
endif
