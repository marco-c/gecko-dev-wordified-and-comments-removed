#
ifndef
RTC_BASE_PTR_UTIL_H_
#
define
RTC_BASE_PTR_UTIL_H_
#
include
<
memory
>
#
include
<
utility
>
namespace
rtc
{
template
<
typename
T
>
std
:
:
unique_ptr
<
T
>
WrapUnique
(
T
*
ptr
)
{
return
std
:
:
unique_ptr
<
T
>
(
ptr
)
;
}
namespace
internal
{
template
<
typename
T
>
struct
MakeUniqueResult
{
using
Scalar
=
std
:
:
unique_ptr
<
T
>
;
}
;
template
<
typename
T
>
struct
MakeUniqueResult
<
T
[
]
>
{
using
Array
=
std
:
:
unique_ptr
<
T
[
]
>
;
}
;
template
<
typename
T
size_t
N
>
struct
MakeUniqueResult
<
T
[
N
]
>
{
using
Invalid
=
void
;
}
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
internal
:
:
MakeUniqueResult
<
T
>
:
:
Scalar
MakeUnique
(
Args
&
&
.
.
.
args
)
{
return
std
:
:
unique_ptr
<
T
>
(
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
T
>
typename
internal
:
:
MakeUniqueResult
<
T
>
:
:
Array
MakeUnique
(
size_t
size
)
{
return
std
:
:
unique_ptr
<
T
>
(
new
typename
std
:
:
remove_extent
<
T
>
:
:
type
[
size
]
(
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
internal
:
:
MakeUniqueResult
<
T
>
:
:
Invalid
MakeUnique
(
Args
&
&
.
.
.
args
)
=
delete
;
}
#
endif
