#
include
"
rtc_base
/
asyncinvoker
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
rtc
{
AsyncInvoker
:
:
AsyncInvoker
(
)
:
pending_invocations_
(
0
)
invocation_complete_
(
new
RefCountedObject
<
Event
>
(
false
false
)
)
destroying_
(
false
)
{
}
AsyncInvoker
:
:
~
AsyncInvoker
(
)
{
destroying_
.
store
(
true
std
:
:
memory_order_relaxed
)
;
MessageQueueManager
:
:
Clear
(
this
)
;
while
(
pending_invocations_
.
load
(
std
:
:
memory_order_acquire
)
>
0
)
{
Thread
:
:
Current
(
)
-
>
Clear
(
this
)
;
invocation_complete_
-
>
Wait
(
Event
:
:
kForever
)
;
}
}
void
AsyncInvoker
:
:
OnMessage
(
Message
*
msg
)
{
ScopedMessageData
<
AsyncClosure
>
*
data
=
static_cast
<
ScopedMessageData
<
AsyncClosure
>
*
>
(
msg
-
>
pdata
)
;
data
-
>
inner_data
(
)
.
Execute
(
)
;
delete
data
;
}
void
AsyncInvoker
:
:
Flush
(
Thread
*
thread
uint32_t
id
)
{
if
(
destroying_
.
load
(
std
:
:
memory_order_relaxed
)
)
return
;
if
(
Thread
:
:
Current
(
)
!
=
thread
)
{
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
AsyncInvoker
:
:
Flush
this
thread
id
)
)
;
return
;
}
MessageList
removed
;
thread
-
>
Clear
(
this
id
&
removed
)
;
for
(
MessageList
:
:
iterator
it
=
removed
.
begin
(
)
;
it
!
=
removed
.
end
(
)
;
+
+
it
)
{
thread
-
>
Send
(
it
-
>
posted_from
it
-
>
phandler
it
-
>
message_id
it
-
>
pdata
)
;
}
}
void
AsyncInvoker
:
:
DoInvoke
(
const
Location
&
posted_from
Thread
*
thread
std
:
:
unique_ptr
<
AsyncClosure
>
closure
uint32_t
id
)
{
if
(
destroying_
.
load
(
std
:
:
memory_order_relaxed
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Tried
to
invoke
while
destroying
the
invoker
.
"
;
return
;
}
thread
-
>
Post
(
posted_from
this
id
new
ScopedMessageData
<
AsyncClosure
>
(
std
:
:
move
(
closure
)
)
)
;
}
void
AsyncInvoker
:
:
DoInvokeDelayed
(
const
Location
&
posted_from
Thread
*
thread
std
:
:
unique_ptr
<
AsyncClosure
>
closure
uint32_t
delay_ms
uint32_t
id
)
{
if
(
destroying_
.
load
(
std
:
:
memory_order_relaxed
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Tried
to
invoke
while
destroying
the
invoker
.
"
;
return
;
}
thread
-
>
PostDelayed
(
posted_from
delay_ms
this
id
new
ScopedMessageData
<
AsyncClosure
>
(
std
:
:
move
(
closure
)
)
)
;
}
GuardedAsyncInvoker
:
:
GuardedAsyncInvoker
(
)
:
thread_
(
Thread
:
:
Current
(
)
)
{
thread_
-
>
SignalQueueDestroyed
.
connect
(
this
&
GuardedAsyncInvoker
:
:
ThreadDestroyed
)
;
}
GuardedAsyncInvoker
:
:
~
GuardedAsyncInvoker
(
)
{
}
bool
GuardedAsyncInvoker
:
:
Flush
(
uint32_t
id
)
{
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
Flush
(
thread_
id
)
;
return
true
;
}
void
GuardedAsyncInvoker
:
:
ThreadDestroyed
(
)
{
CritScope
cs
(
&
crit_
)
;
RTC_DCHECK
(
thread_
!
=
nullptr
)
;
thread_
=
nullptr
;
}
AsyncClosure
:
:
AsyncClosure
(
AsyncInvoker
*
invoker
)
:
invoker_
(
invoker
)
invocation_complete_
(
invoker_
-
>
invocation_complete_
)
{
invoker_
-
>
pending_invocations_
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
}
AsyncClosure
:
:
~
AsyncClosure
(
)
{
invoker_
-
>
pending_invocations_
.
fetch_sub
(
1
std
:
:
memory_order_release
)
;
invocation_complete_
-
>
Set
(
)
;
}
}
