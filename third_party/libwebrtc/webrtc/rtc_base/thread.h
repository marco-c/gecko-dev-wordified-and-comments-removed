#
ifndef
RTC_BASE_THREAD_H_
#
define
RTC_BASE_THREAD_H_
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
if
defined
(
WEBRTC_POSIX
)
#
include
<
pthread
.
h
>
#
endif
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
messagequeue
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
if
defined
(
WEBRTC_WIN
)
#
include
"
rtc_base
/
win32
.
h
"
#
endif
namespace
rtc
{
class
Thread
;
class
ThreadManager
{
public
:
static
const
int
kForever
=
-
1
;
static
ThreadManager
*
Instance
(
)
;
Thread
*
CurrentThread
(
)
;
void
SetCurrentThread
(
Thread
*
thread
)
;
Thread
*
WrapCurrentThread
(
)
;
void
UnwrapCurrentThread
(
)
;
bool
IsMainThread
(
)
;
private
:
ThreadManager
(
)
;
~
ThreadManager
(
)
;
#
if
defined
(
WEBRTC_POSIX
)
pthread_key_t
key_
;
#
endif
#
if
defined
(
WEBRTC_WIN
)
DWORD
key_
;
#
endif
PlatformThreadRef
main_thread_ref_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
ThreadManager
)
;
}
;
struct
_SendMessage
{
_SendMessage
(
)
{
}
Thread
*
thread
;
Message
msg
;
bool
*
ready
;
}
;
class
Runnable
{
public
:
virtual
~
Runnable
(
)
{
}
virtual
void
Run
(
Thread
*
thread
)
=
0
;
protected
:
Runnable
(
)
{
}
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
Runnable
)
;
}
;
class
RTC_LOCKABLE
Thread
:
public
MessageQueue
{
public
:
Thread
(
)
;
explicit
Thread
(
SocketServer
*
ss
)
;
explicit
Thread
(
std
:
:
unique_ptr
<
SocketServer
>
ss
)
;
~
Thread
(
)
override
;
static
std
:
:
unique_ptr
<
Thread
>
CreateWithSocketServer
(
)
;
static
std
:
:
unique_ptr
<
Thread
>
Create
(
)
;
static
Thread
*
Current
(
)
;
class
ScopedDisallowBlockingCalls
{
public
:
ScopedDisallowBlockingCalls
(
)
;
~
ScopedDisallowBlockingCalls
(
)
;
private
:
Thread
*
const
thread_
;
const
bool
previous_state_
;
}
;
bool
IsCurrent
(
)
const
;
static
bool
SleepMs
(
int
millis
)
;
const
std
:
:
string
&
name
(
)
const
{
return
name_
;
}
bool
SetName
(
const
std
:
:
string
&
name
const
void
*
obj
)
;
bool
Start
(
Runnable
*
runnable
=
nullptr
)
;
virtual
void
Stop
(
)
;
virtual
void
Run
(
)
;
virtual
void
Send
(
const
Location
&
posted_from
MessageHandler
*
phandler
uint32_t
id
=
0
MessageData
*
pdata
=
nullptr
)
;
template
<
class
ReturnT
class
FunctorT
>
ReturnT
Invoke
(
const
Location
&
posted_from
FunctorT
&
&
functor
)
{
FunctorMessageHandler
<
ReturnT
FunctorT
>
handler
(
std
:
:
forward
<
FunctorT
>
(
functor
)
)
;
InvokeInternal
(
posted_from
&
handler
)
;
return
handler
.
MoveResult
(
)
;
}
void
Clear
(
MessageHandler
*
phandler
uint32_t
id
=
MQID_ANY
MessageList
*
removed
=
nullptr
)
override
;
void
ReceiveSends
(
)
override
;
bool
ProcessMessages
(
int
cms
)
;
bool
IsOwned
(
)
;
#
if
defined
(
WEBRTC_WIN
)
HANDLE
GetHandle
(
)
const
{
return
thread_
;
}
DWORD
GetId
(
)
const
{
return
thread_id_
;
}
#
elif
defined
(
WEBRTC_POSIX
)
pthread_t
GetPThread
(
)
{
return
thread_
;
}
#
endif
bool
RunningForTest
(
)
{
return
running
(
)
;
}
bool
SetAllowBlockingCalls
(
bool
allow
)
;
bool
WrapCurrent
(
)
;
void
UnwrapCurrent
(
)
;
protected
:
void
SafeWrapCurrent
(
)
;
void
Join
(
)
;
static
void
AssertBlockingIsAllowedOnCurrentThread
(
)
;
friend
class
ScopedDisallowBlockingCalls
;
private
:
struct
ThreadInit
{
Thread
*
thread
;
Runnable
*
runnable
;
}
;
#
if
defined
(
WEBRTC_WIN
)
static
DWORD
WINAPI
PreRun
(
LPVOID
context
)
;
#
else
static
void
*
PreRun
(
void
*
pv
)
;
#
endif
bool
WrapCurrentWithThreadManager
(
ThreadManager
*
thread_manager
bool
need_synchronize_access
)
;
bool
running
(
)
{
return
running_
.
Wait
(
0
)
;
}
void
ReceiveSendsFromThread
(
const
Thread
*
source
)
;
bool
PopSendMessageFromThread
(
const
Thread
*
source
_SendMessage
*
msg
)
;
void
InvokeInternal
(
const
Location
&
posted_from
MessageHandler
*
handler
)
;
std
:
:
list
<
_SendMessage
>
sendlist_
;
std
:
:
string
name_
;
Event
running_
;
#
if
defined
(
WEBRTC_POSIX
)
pthread_t
thread_
;
#
endif
#
if
defined
(
WEBRTC_WIN
)
HANDLE
thread_
;
DWORD
thread_id_
;
#
endif
bool
owned_
;
bool
blocking_calls_allowed_
;
friend
class
ThreadManager
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
Thread
)
;
}
;
class
AutoThread
:
public
Thread
{
public
:
AutoThread
(
)
;
~
AutoThread
(
)
override
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
AutoThread
)
;
}
;
class
AutoSocketServerThread
:
public
Thread
{
public
:
explicit
AutoSocketServerThread
(
SocketServer
*
ss
)
;
~
AutoSocketServerThread
(
)
override
;
private
:
rtc
:
:
Thread
*
old_thread_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AutoSocketServerThread
)
;
}
;
}
#
endif
