#
if
defined
(
WEBRTC_WIN
)
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
endif
#
include
<
memory
>
#
include
<
vector
>
#
include
"
rtc_base
/
bind
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
namespace
rtc
{
namespace
{
class
EnableHighResTimers
{
public
:
#
if
!
defined
(
WEBRTC_WIN
)
EnableHighResTimers
(
)
{
}
#
else
EnableHighResTimers
(
)
:
enabled_
(
timeBeginPeriod
(
1
)
=
=
TIMERR_NOERROR
)
{
}
~
EnableHighResTimers
(
)
{
if
(
enabled_
)
timeEndPeriod
(
1
)
;
}
private
:
const
bool
enabled_
;
#
endif
}
;
}
namespace
{
void
CheckCurrent
(
Event
*
signal
TaskQueue
*
queue
)
{
EXPECT_TRUE
(
queue
-
>
IsCurrent
(
)
)
;
if
(
signal
)
signal
-
>
Set
(
)
;
}
}
TEST
(
TaskQueueTest
Construct
)
{
static
const
char
kQueueName
[
]
=
"
Construct
"
;
TaskQueue
queue
(
kQueueName
)
;
EXPECT_FALSE
(
queue
.
IsCurrent
(
)
)
;
}
TEST
(
TaskQueueTest
PostAndCheckCurrent
)
{
static
const
char
kQueueName
[
]
=
"
PostAndCheckCurrent
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
)
;
EXPECT_FALSE
(
queue
.
IsCurrent
(
)
)
;
EXPECT_FALSE
(
TaskQueue
:
:
Current
(
)
)
;
queue
.
PostTask
(
Bind
(
&
CheckCurrent
&
event
&
queue
)
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostCustomTask
)
{
static
const
char
kQueueName
[
]
=
"
PostCustomImplementation
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
)
;
class
CustomTask
:
public
QueuedTask
{
public
:
explicit
CustomTask
(
Event
*
event
)
:
event_
(
event
)
{
}
private
:
bool
Run
(
)
override
{
event_
-
>
Set
(
)
;
return
false
;
}
Event
*
const
event_
;
}
my_task
(
&
event
)
;
queue
.
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
(
&
my_task
)
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostLambda
)
{
static
const
char
kQueueName
[
]
=
"
PostLambda
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
)
;
queue
.
PostTask
(
[
&
event
]
(
)
{
event
.
Set
(
)
;
}
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostDelayedZero
)
{
static
const
char
kQueueName
[
]
=
"
PostDelayedZero
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
)
;
queue
.
PostDelayedTask
(
[
&
event
]
(
)
{
event
.
Set
(
)
;
}
0
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostFromQueue
)
{
static
const
char
kQueueName
[
]
=
"
PostFromQueue
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
)
;
queue
.
PostTask
(
[
&
event
&
queue
]
(
)
{
queue
.
PostTask
(
[
&
event
]
(
)
{
event
.
Set
(
)
;
}
)
;
}
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostDelayed
)
{
static
const
char
kQueueName
[
]
=
"
PostDelayed
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
TaskQueue
:
:
Priority
:
:
HIGH
)
;
uint32_t
start
=
Time
(
)
;
queue
.
PostDelayedTask
(
Bind
(
&
CheckCurrent
&
event
&
queue
)
100
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
uint32_t
end
=
Time
(
)
;
EXPECT_GE
(
end
-
start
90u
)
;
EXPECT_NEAR
(
end
-
start
190u
100u
)
;
}
TEST
(
TaskQueueTest
DISABLED_PostDelayedHighRes
)
{
EnableHighResTimers
high_res_scope
;
static
const
char
kQueueName
[
]
=
"
PostDelayedHighRes
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
TaskQueue
:
:
Priority
:
:
HIGH
)
;
uint32_t
start
=
Time
(
)
;
queue
.
PostDelayedTask
(
Bind
(
&
CheckCurrent
&
event
&
queue
)
3
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
uint32_t
end
=
TimeMillis
(
)
;
EXPECT_GE
(
end
-
start
3u
)
;
EXPECT_NEAR
(
end
-
start
3
3u
)
;
}
TEST
(
TaskQueueTest
PostMultipleDelayed
)
{
static
const
char
kQueueName
[
]
=
"
PostMultipleDelayed
"
;
TaskQueue
queue
(
kQueueName
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Event
>
>
events
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
events
.
push_back
(
std
:
:
unique_ptr
<
Event
>
(
new
Event
(
false
false
)
)
)
;
queue
.
PostDelayedTask
(
Bind
(
&
CheckCurrent
events
.
back
(
)
.
get
(
)
&
queue
)
i
)
;
}
for
(
const
auto
&
e
:
events
)
EXPECT_TRUE
(
e
-
>
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostDelayedAfterDestruct
)
{
static
const
char
kQueueName
[
]
=
"
PostDelayedAfterDestruct
"
;
Event
event
(
false
false
)
;
{
TaskQueue
queue
(
kQueueName
)
;
queue
.
PostDelayedTask
(
Bind
(
&
CheckCurrent
&
event
&
queue
)
100
)
;
}
EXPECT_FALSE
(
event
.
Wait
(
200
)
)
;
}
TEST
(
TaskQueueTest
PostAndReply
)
{
static
const
char
kPostQueue
[
]
=
"
PostQueue
"
;
static
const
char
kReplyQueue
[
]
=
"
ReplyQueue
"
;
Event
event
(
false
false
)
;
TaskQueue
post_queue
(
kPostQueue
)
;
TaskQueue
reply_queue
(
kReplyQueue
)
;
post_queue
.
PostTaskAndReply
(
Bind
(
&
CheckCurrent
nullptr
&
post_queue
)
Bind
(
&
CheckCurrent
&
event
&
reply_queue
)
&
reply_queue
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostAndReuse
)
{
static
const
char
kPostQueue
[
]
=
"
PostQueue
"
;
static
const
char
kReplyQueue
[
]
=
"
ReplyQueue
"
;
Event
event
(
false
false
)
;
TaskQueue
post_queue
(
kPostQueue
)
;
TaskQueue
reply_queue
(
kReplyQueue
)
;
int
call_count
=
0
;
class
ReusedTask
:
public
QueuedTask
{
public
:
ReusedTask
(
int
*
counter
TaskQueue
*
reply_queue
Event
*
event
)
:
counter_
(
counter
)
reply_queue_
(
reply_queue
)
event_
(
event
)
{
EXPECT_EQ
(
0
*
counter_
)
;
}
private
:
bool
Run
(
)
override
{
if
(
+
+
(
*
counter_
)
=
=
1
)
{
std
:
:
unique_ptr
<
QueuedTask
>
myself
(
this
)
;
reply_queue_
-
>
PostTask
(
std
:
:
move
(
myself
)
)
;
return
false
;
}
else
{
EXPECT_EQ
(
2
*
counter_
)
;
EXPECT_TRUE
(
reply_queue_
-
>
IsCurrent
(
)
)
;
event_
-
>
Set
(
)
;
return
true
;
}
}
int
*
const
counter_
;
TaskQueue
*
const
reply_queue_
;
Event
*
const
event_
;
}
;
std
:
:
unique_ptr
<
ReusedTask
>
task
(
new
ReusedTask
(
&
call_count
&
reply_queue
&
event
)
)
;
post_queue
.
PostTask
(
std
:
:
move
(
task
)
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostAndReplyLambda
)
{
static
const
char
kPostQueue
[
]
=
"
PostQueue
"
;
static
const
char
kReplyQueue
[
]
=
"
ReplyQueue
"
;
Event
event
(
false
false
)
;
TaskQueue
post_queue
(
kPostQueue
)
;
TaskQueue
reply_queue
(
kReplyQueue
)
;
bool
my_flag
=
false
;
post_queue
.
PostTaskAndReply
(
[
&
my_flag
]
(
)
{
my_flag
=
true
;
}
[
&
event
]
(
)
{
event
.
Set
(
)
;
}
&
reply_queue
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
EXPECT_TRUE
(
my_flag
)
;
}
TEST
(
TaskQueueTest
PostCopyableClosure
)
{
struct
CopyableClosure
{
CopyableClosure
(
int
*
num_copies
int
*
num_moves
Event
*
event
)
:
num_copies
(
num_copies
)
num_moves
(
num_moves
)
event
(
event
)
{
}
CopyableClosure
(
const
CopyableClosure
&
other
)
:
num_copies
(
other
.
num_copies
)
num_moves
(
other
.
num_moves
)
event
(
other
.
event
)
{
+
+
*
num_copies
;
}
CopyableClosure
(
CopyableClosure
&
&
other
)
:
num_copies
(
other
.
num_copies
)
num_moves
(
other
.
num_moves
)
event
(
other
.
event
)
{
+
+
*
num_moves
;
}
void
operator
(
)
(
)
{
event
-
>
Set
(
)
;
}
int
*
num_copies
;
int
*
num_moves
;
Event
*
event
;
}
;
int
num_copies
=
0
;
int
num_moves
=
0
;
Event
event
(
false
false
)
;
static
const
char
kPostQueue
[
]
=
"
PostCopyableClosure
"
;
TaskQueue
post_queue
(
kPostQueue
)
;
{
CopyableClosure
closure
(
&
num_copies
&
num_moves
&
event
)
;
post_queue
.
PostTask
(
closure
)
;
}
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
EXPECT_EQ
(
num_copies
1
)
;
EXPECT_EQ
(
num_moves
0
)
;
}
TEST
(
TaskQueueTest
PostMoveOnlyClosure
)
{
struct
SomeState
{
explicit
SomeState
(
Event
*
event
)
:
event
(
event
)
{
}
~
SomeState
(
)
{
event
-
>
Set
(
)
;
}
Event
*
event
;
}
;
struct
MoveOnlyClosure
{
MoveOnlyClosure
(
int
*
num_moves
std
:
:
unique_ptr
<
SomeState
>
state
)
:
num_moves
(
num_moves
)
state
(
std
:
:
move
(
state
)
)
{
}
MoveOnlyClosure
(
const
MoveOnlyClosure
&
)
=
delete
;
MoveOnlyClosure
(
MoveOnlyClosure
&
&
other
)
:
num_moves
(
other
.
num_moves
)
state
(
std
:
:
move
(
other
.
state
)
)
{
+
+
*
num_moves
;
}
void
operator
(
)
(
)
{
state
.
reset
(
)
;
}
int
*
num_moves
;
std
:
:
unique_ptr
<
SomeState
>
state
;
}
;
int
num_moves
=
0
;
Event
event
(
false
false
)
;
std
:
:
unique_ptr
<
SomeState
>
state
(
new
SomeState
(
&
event
)
)
;
static
const
char
kPostQueue
[
]
=
"
PostMoveOnlyClosure
"
;
TaskQueue
post_queue
(
kPostQueue
)
;
post_queue
.
PostTask
(
MoveOnlyClosure
(
&
num_moves
std
:
:
move
(
state
)
)
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
EXPECT_EQ
(
num_moves
1
)
;
}
TEST
(
TaskQueueTest
PostMoveOnlyCleanup
)
{
struct
SomeState
{
explicit
SomeState
(
Event
*
event
)
:
event
(
event
)
{
}
~
SomeState
(
)
{
event
-
>
Set
(
)
;
}
Event
*
event
;
}
;
struct
MoveOnlyClosure
{
void
operator
(
)
(
)
{
state
.
reset
(
)
;
}
std
:
:
unique_ptr
<
SomeState
>
state
;
}
;
Event
event_run
(
false
false
)
;
Event
event_cleanup
(
false
false
)
;
std
:
:
unique_ptr
<
SomeState
>
state_run
(
new
SomeState
(
&
event_run
)
)
;
std
:
:
unique_ptr
<
SomeState
>
state_cleanup
(
new
SomeState
(
&
event_cleanup
)
)
;
static
const
char
kPostQueue
[
]
=
"
PostMoveOnlyCleanup
"
;
TaskQueue
post_queue
(
kPostQueue
)
;
post_queue
.
PostTask
(
NewClosure
(
MoveOnlyClosure
{
std
:
:
move
(
state_run
)
}
MoveOnlyClosure
{
std
:
:
move
(
state_cleanup
)
}
)
)
;
EXPECT_TRUE
(
event_cleanup
.
Wait
(
1000
)
)
;
EXPECT_TRUE
(
event_run
.
Wait
(
0
)
)
;
}
TEST
(
TaskQueueTest
PostAndReplyDeadlock
)
{
Event
event
(
false
false
)
;
TaskQueue
post_queue
(
"
PostQueue
"
)
;
TaskQueue
reply_queue
(
"
ReplyQueue
"
)
;
post_queue
.
PostTaskAndReply
(
[
&
event
]
(
)
{
event
.
Set
(
)
;
}
[
]
(
)
{
}
&
reply_queue
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
void
TestPostTaskAndReply
(
TaskQueue
*
work_queue
Event
*
event
)
{
ASSERT_FALSE
(
work_queue
-
>
IsCurrent
(
)
)
;
work_queue
-
>
PostTaskAndReply
(
Bind
(
&
CheckCurrent
nullptr
work_queue
)
NewClosure
(
[
event
]
(
)
{
event
-
>
Set
(
)
;
}
)
)
;
}
TEST
(
TaskQueueTest
PostAndReply2
)
{
static
const
char
kQueueName
[
]
=
"
PostAndReply2
"
;
static
const
char
kWorkQueueName
[
]
=
"
PostAndReply2_Worker
"
;
Event
event
(
false
false
)
;
TaskQueue
queue
(
kQueueName
)
;
TaskQueue
work_queue
(
kWorkQueueName
)
;
queue
.
PostTask
(
Bind
(
&
TestPostTaskAndReply
&
work_queue
&
event
)
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
}
TEST
(
TaskQueueTest
PostALot
)
{
Event
event
(
false
false
)
;
int
tasks_executed
=
0
;
int
tasks_cleaned_up
=
0
;
static
const
int
kTaskCount
=
0xffff
;
{
static
const
char
kQueueName
[
]
=
"
PostALot
"
;
TaskQueue
queue
(
kQueueName
)
;
queue
.
PostTask
(
[
&
event
]
(
)
{
event
.
Wait
(
Event
:
:
kForever
)
;
}
)
;
for
(
int
i
=
0
;
i
<
kTaskCount
;
+
+
i
)
queue
.
PostTask
(
NewClosure
(
[
&
tasks_executed
]
(
)
{
+
+
tasks_executed
;
}
[
&
tasks_cleaned_up
]
(
)
{
+
+
tasks_cleaned_up
;
}
)
)
;
event
.
Set
(
)
;
}
EXPECT_GE
(
tasks_cleaned_up
tasks_executed
)
;
EXPECT_EQ
(
kTaskCount
tasks_cleaned_up
)
;
}
}
