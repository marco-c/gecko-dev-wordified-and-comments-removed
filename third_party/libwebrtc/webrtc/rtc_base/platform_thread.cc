#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
atomicops
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
#
if
defined
(
WEBRTC_LINUX
)
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
endif
#
if
defined
(
__DragonFly__
)
|
|
defined
(
__FreeBSD__
)
|
|
defined
(
__OpenBSD__
)
#
include
<
pthread_np
.
h
>
#
elif
defined
(
__NetBSD__
)
#
include
<
lwp
.
h
>
#
endif
namespace
rtc
{
PlatformThreadId
CurrentThreadId
(
)
{
PlatformThreadId
ret
;
#
if
defined
(
WEBRTC_WIN
)
ret
=
GetCurrentThreadId
(
)
;
#
elif
defined
(
WEBRTC_POSIX
)
#
if
defined
(
WEBRTC_MAC
)
|
|
defined
(
WEBRTC_IOS
)
ret
=
pthread_mach_thread_np
(
pthread_self
(
)
)
;
#
elif
defined
(
WEBRTC_ANDROID
)
ret
=
gettid
(
)
;
#
elif
defined
(
WEBRTC_LINUX
)
ret
=
syscall
(
__NR_gettid
)
;
#
elif
defined
(
__DragonFly__
)
ret
=
lwp_gettid
(
)
;
#
elif
defined
(
__FreeBSD__
)
ret
=
pthread_getthreadid_np
(
)
;
#
elif
defined
(
__NetBSD__
)
ret
=
_lwp_self
(
)
;
#
else
ret
=
reinterpret_cast
<
uintptr_t
>
(
pthread_self
(
)
)
;
#
endif
#
endif
RTC_DCHECK
(
ret
)
;
return
ret
;
}
PlatformThreadRef
CurrentThreadRef
(
)
{
#
if
defined
(
WEBRTC_WIN
)
return
GetCurrentThreadId
(
)
;
#
elif
defined
(
WEBRTC_POSIX
)
return
pthread_self
(
)
;
#
endif
}
bool
IsThreadRefEqual
(
const
PlatformThreadRef
&
a
const
PlatformThreadRef
&
b
)
{
#
if
defined
(
WEBRTC_WIN
)
return
a
=
=
b
;
#
elif
defined
(
WEBRTC_POSIX
)
return
pthread_equal
(
a
b
)
;
#
endif
}
void
SetCurrentThreadName
(
const
char
*
name
)
{
#
if
defined
(
WEBRTC_WIN
)
#
pragma
pack
(
push
8
)
struct
{
DWORD
dwType
;
LPCSTR
szName
;
DWORD
dwThreadID
;
DWORD
dwFlags
;
}
threadname_info
=
{
0x1000
name
static_cast
<
DWORD
>
(
-
1
)
0
}
;
#
pragma
pack
(
pop
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
6320
6322
)
__try
{
:
:
RaiseException
(
0x406D1388
0
sizeof
(
threadname_info
)
/
sizeof
(
ULONG_PTR
)
reinterpret_cast
<
ULONG_PTR
*
>
(
&
threadname_info
)
)
;
}
__except
(
EXCEPTION_EXECUTE_HANDLER
)
{
}
#
pragma
warning
(
pop
)
#
elif
defined
(
WEBRTC_LINUX
)
|
|
defined
(
WEBRTC_ANDROID
)
prctl
(
PR_SET_NAME
reinterpret_cast
<
unsigned
long
>
(
name
)
)
;
#
elif
defined
(
WEBRTC_MAC
)
|
|
defined
(
WEBRTC_IOS
)
pthread_setname_np
(
name
)
;
#
elif
defined
(
__DragonFly__
)
|
|
defined
(
__FreeBSD__
)
|
|
defined
(
__OpenBSD__
)
pthread_set_name_np
(
pthread_self
(
)
name
)
;
#
elif
defined
(
__NetBSD__
)
pthread_setname_np
(
pthread_self
(
)
"
%
s
"
(
void
*
)
name
)
;
#
endif
}
namespace
{
#
if
defined
(
WEBRTC_WIN
)
void
CALLBACK
RaiseFlag
(
ULONG_PTR
param
)
{
*
reinterpret_cast
<
bool
*
>
(
param
)
=
true
;
}
#
else
struct
ThreadAttributes
{
ThreadAttributes
(
)
{
pthread_attr_init
(
&
attr
)
;
}
~
ThreadAttributes
(
)
{
pthread_attr_destroy
(
&
attr
)
;
}
pthread_attr_t
*
operator
&
(
)
{
return
&
attr
;
}
pthread_attr_t
attr
;
}
;
#
endif
}
PlatformThread
:
:
PlatformThread
(
ThreadRunFunctionDeprecated
func
void
*
obj
const
char
*
thread_name
)
:
run_function_deprecated_
(
func
)
obj_
(
obj
)
name_
(
thread_name
?
thread_name
:
"
webrtc
"
)
{
RTC_DCHECK
(
func
)
;
RTC_DCHECK
(
name_
.
length
(
)
<
64
)
;
spawned_thread_checker_
.
DetachFromThread
(
)
;
}
PlatformThread
:
:
PlatformThread
(
ThreadRunFunction
func
void
*
obj
const
char
*
thread_name
ThreadPriority
priority
)
:
run_function_
(
func
)
priority_
(
priority
)
obj_
(
obj
)
name_
(
thread_name
)
{
RTC_DCHECK
(
func
)
;
RTC_DCHECK
(
!
name_
.
empty
(
)
)
;
RTC_DCHECK
(
name_
.
length
(
)
<
64
)
;
spawned_thread_checker_
.
DetachFromThread
(
)
;
}
PlatformThread
:
:
~
PlatformThread
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
#
if
defined
(
WEBRTC_WIN
)
RTC_DCHECK
(
!
thread_
)
;
RTC_DCHECK
(
!
thread_id_
)
;
#
endif
}
#
if
defined
(
WEBRTC_WIN
)
DWORD
WINAPI
PlatformThread
:
:
StartThread
(
void
*
param
)
{
:
:
SetLastError
(
ERROR_SUCCESS
)
;
static_cast
<
PlatformThread
*
>
(
param
)
-
>
Run
(
)
;
return
0
;
}
#
else
void
*
PlatformThread
:
:
StartThread
(
void
*
param
)
{
static_cast
<
PlatformThread
*
>
(
param
)
-
>
Run
(
)
;
return
0
;
}
#
endif
void
PlatformThread
:
:
Start
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
!
thread_
)
<
<
"
Thread
already
started
?
"
;
#
if
defined
(
WEBRTC_WIN
)
stop_
=
false
;
thread_
=
:
:
CreateThread
(
nullptr
256
*
1024
&
StartThread
this
STACK_SIZE_PARAM_IS_A_RESERVATION
&
thread_id_
)
;
RTC_CHECK
(
thread_
)
<
<
"
CreateThread
failed
"
;
RTC_DCHECK
(
thread_id_
)
;
#
else
ThreadAttributes
attr
;
pthread_attr_setstacksize
(
&
attr
256
*
1024
)
;
RTC_CHECK_EQ
(
0
pthread_create
(
&
thread_
&
attr
&
StartThread
this
)
)
;
#
endif
}
bool
PlatformThread
:
:
IsRunning
(
)
const
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
#
if
defined
(
WEBRTC_WIN
)
return
thread_
!
=
nullptr
;
#
else
return
thread_
!
=
0
;
#
endif
}
PlatformThreadRef
PlatformThread
:
:
GetThreadRef
(
)
const
{
#
if
defined
(
WEBRTC_WIN
)
return
thread_id_
;
#
else
return
thread_
;
#
endif
}
void
PlatformThread
:
:
Stop
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
!
IsRunning
(
)
)
return
;
#
if
defined
(
WEBRTC_WIN
)
bool
queued
=
QueueAPC
(
&
RaiseFlag
reinterpret_cast
<
ULONG_PTR
>
(
&
stop_
)
)
;
RTC_CHECK
(
queued
|
|
GetLastError
(
)
=
=
ERROR_GEN_FAILURE
)
;
WaitForSingleObject
(
thread_
INFINITE
)
;
CloseHandle
(
thread_
)
;
thread_
=
nullptr
;
thread_id_
=
0
;
#
else
if
(
!
run_function_
)
RTC_CHECK_EQ
(
1
AtomicOps
:
:
Increment
(
&
stop_flag_
)
)
;
RTC_CHECK_EQ
(
0
pthread_join
(
thread_
nullptr
)
)
;
if
(
!
run_function_
)
AtomicOps
:
:
ReleaseStore
(
&
stop_flag_
0
)
;
thread_
=
0
;
#
endif
spawned_thread_checker_
.
DetachFromThread
(
)
;
}
void
PlatformThread
:
:
Run
(
)
{
RTC_DCHECK
(
spawned_thread_checker_
.
CalledOnValidThread
(
)
)
;
rtc
:
:
SetCurrentThreadName
(
name_
.
c_str
(
)
)
;
if
(
run_function_
)
{
SetPriority
(
priority_
)
;
run_function_
(
obj_
)
;
return
;
}
#
if
RTC_DCHECK_IS_ON
static
const
int
kMaxLoopCount
=
1000
;
static
const
int
kPeriodToMeasureMs
=
100
;
int64_t
loop_stamps
[
kMaxLoopCount
]
=
{
}
;
int64_t
sequence_nr
=
0
;
#
endif
do
{
TRACE_EVENT1
(
"
webrtc
"
"
PlatformThread
:
:
Run
"
"
name
"
name_
.
c_str
(
)
)
;
if
(
!
run_function_deprecated_
(
obj_
)
)
break
;
#
if
RTC_DCHECK_IS_ON
auto
id
=
sequence_nr
%
kMaxLoopCount
;
loop_stamps
[
id
]
=
rtc
:
:
TimeMillis
(
)
;
if
(
sequence_nr
>
kMaxLoopCount
)
{
auto
compare_id
=
(
id
+
1
)
%
kMaxLoopCount
;
auto
diff
=
loop_stamps
[
id
]
-
loop_stamps
[
compare_id
]
;
RTC_DCHECK_GE
(
diff
0
)
;
if
(
diff
<
kPeriodToMeasureMs
)
{
RTC_NOTREACHED
(
)
<
<
"
This
thread
is
too
busy
:
"
<
<
name_
<
<
"
"
<
<
diff
<
<
"
ms
sequence
=
"
<
<
sequence_nr
<
<
"
"
<
<
loop_stamps
[
id
]
<
<
"
vs
"
<
<
loop_stamps
[
compare_id
]
<
<
"
"
<
<
id
<
<
"
vs
"
<
<
compare_id
;
}
}
+
+
sequence_nr
;
#
endif
#
if
defined
(
WEBRTC_WIN
)
SleepEx
(
0
true
)
;
}
while
(
!
stop_
)
;
#
else
#
if
defined
(
WEBRTC_MAC
)
sched_yield
(
)
;
#
else
static
const
struct
timespec
ts_null
=
{
0
}
;
nanosleep
(
&
ts_null
nullptr
)
;
#
endif
}
while
(
!
AtomicOps
:
:
AcquireLoad
(
&
stop_flag_
)
)
;
#
endif
}
bool
PlatformThread
:
:
SetPriority
(
ThreadPriority
priority
)
{
#
if
RTC_DCHECK_IS_ON
if
(
run_function_
)
{
RTC_DCHECK
(
!
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
spawned_thread_checker_
.
CalledOnValidThread
(
)
)
;
}
else
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
IsRunning
(
)
)
;
}
#
endif
#
if
defined
(
WEBRTC_WIN
)
return
SetThreadPriority
(
thread_
priority
)
!
=
FALSE
;
#
elif
defined
(
__native_client__
)
return
true
;
#
elif
defined
(
WEBRTC_CHROMIUM_BUILD
)
&
&
defined
(
WEBRTC_LINUX
)
return
true
;
#
else
#
ifdef
WEBRTC_THREAD_RR
const
int
policy
=
SCHED_RR
;
#
else
const
int
policy
=
SCHED_FIFO
;
#
endif
const
int
min_prio
=
sched_get_priority_min
(
policy
)
;
const
int
max_prio
=
sched_get_priority_max
(
policy
)
;
if
(
min_prio
=
=
-
1
|
|
max_prio
=
=
-
1
)
{
return
false
;
}
if
(
max_prio
-
min_prio
<
=
2
)
return
false
;
sched_param
param
;
const
int
top_prio
=
max_prio
-
1
;
const
int
low_prio
=
min_prio
+
1
;
switch
(
priority
)
{
case
kLowPriority
:
param
.
sched_priority
=
low_prio
;
break
;
case
kNormalPriority
:
param
.
sched_priority
=
(
low_prio
+
top_prio
-
1
)
/
2
;
break
;
case
kHighPriority
:
param
.
sched_priority
=
std
:
:
max
(
top_prio
-
2
low_prio
)
;
break
;
case
kHighestPriority
:
param
.
sched_priority
=
std
:
:
max
(
top_prio
-
1
low_prio
)
;
break
;
case
kRealtimePriority
:
param
.
sched_priority
=
top_prio
;
break
;
}
return
pthread_setschedparam
(
thread_
policy
&
param
)
=
=
0
;
#
endif
}
#
if
defined
(
WEBRTC_WIN
)
bool
PlatformThread
:
:
QueueAPC
(
PAPCFUNC
function
ULONG_PTR
data
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
IsRunning
(
)
)
;
return
QueueUserAPC
(
function
thread_
data
)
!
=
FALSE
;
}
#
endif
}
