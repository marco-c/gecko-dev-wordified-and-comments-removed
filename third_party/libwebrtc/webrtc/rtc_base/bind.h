#
ifndef
RTC_BASE_BIND_H_
#
define
RTC_BASE_BIND_H_
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
rtc_base
/
template_util
.
h
"
#
define
NONAME
namespace
rtc
{
namespace
detail
{
template
<
class
T
>
struct
identity
{
typedef
T
type
;
}
;
template
<
typename
T
>
class
IsRefCounted
{
struct
Yes
{
char
dummy
[
1
]
;
}
;
struct
No
{
char
dummy
[
2
]
;
}
;
template
<
typename
R
>
static
Yes
test
(
R
*
r
decltype
(
r
-
>
AddRef
(
)
r
-
>
Release
(
)
42
)
)
;
template
<
typename
C
>
static
No
test
(
.
.
.
)
;
public
:
static
const
bool
value
=
sizeof
(
test
<
T
>
(
(
T
*
)
nullptr
42
)
)
=
=
sizeof
(
Yes
)
;
}
;
template
<
bool
condition
typename
IfTrueT
typename
IfFalseT
>
struct
TernaryTypeOperator
{
}
;
template
<
typename
IfTrueT
typename
IfFalseT
>
struct
TernaryTypeOperator
<
true
IfTrueT
IfFalseT
>
{
typedef
IfTrueT
type
;
}
;
template
<
typename
IfTrueT
typename
IfFalseT
>
struct
TernaryTypeOperator
<
false
IfTrueT
IfFalseT
>
{
typedef
IfFalseT
type
;
}
;
template
<
class
T
>
struct
PointerType
{
typedef
typename
TernaryTypeOperator
<
IsRefCounted
<
T
>
:
:
value
scoped_refptr
<
T
>
T
*
>
:
:
type
type
;
}
;
template
<
typename
T
>
class
UnretainedWrapper
{
public
:
explicit
UnretainedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
T
*
get
(
)
const
{
return
ptr_
;
}
private
:
T
*
ptr_
;
}
;
}
template
<
typename
T
>
static
inline
detail
:
:
UnretainedWrapper
<
T
>
Unretained
(
T
*
o
)
{
return
detail
:
:
UnretainedWrapper
<
T
>
(
o
)
;
}
template
<
class
ObjectT
class
MethodT
class
R
typename
.
.
.
Args
>
class
MethodFunctor
{
public
:
MethodFunctor
(
MethodT
method
ObjectT
*
object
Args
.
.
.
args
)
:
method_
(
method
)
object_
(
object
)
args_
(
args
.
.
.
)
{
}
R
operator
(
)
(
)
const
{
return
CallMethod
(
typename
sequence_generator
<
sizeof
.
.
.
(
Args
)
>
:
:
type
(
)
)
;
}
private
:
template
<
int
.
.
.
S
>
R
CallMethod
(
sequence
<
S
.
.
.
>
)
const
{
return
(
object_
-
>
*
method_
)
(
std
:
:
get
<
S
>
(
args_
)
.
.
.
)
;
}
MethodT
method_
;
typename
detail
:
:
PointerType
<
ObjectT
>
:
:
type
object_
;
typename
std
:
:
tuple
<
typename
std
:
:
remove_reference
<
Args
>
:
:
type
.
.
.
>
args_
;
}
;
template
<
class
ObjectT
class
MethodT
class
R
typename
.
.
.
Args
>
class
UnretainedMethodFunctor
{
public
:
UnretainedMethodFunctor
(
MethodT
method
detail
:
:
UnretainedWrapper
<
ObjectT
>
object
Args
.
.
.
args
)
:
method_
(
method
)
object_
(
object
.
get
(
)
)
args_
(
args
.
.
.
)
{
}
R
operator
(
)
(
)
const
{
return
CallMethod
(
typename
sequence_generator
<
sizeof
.
.
.
(
Args
)
>
:
:
type
(
)
)
;
}
private
:
template
<
int
.
.
.
S
>
R
CallMethod
(
sequence
<
S
.
.
.
>
)
const
{
return
(
object_
-
>
*
method_
)
(
std
:
:
get
<
S
>
(
args_
)
.
.
.
)
;
}
MethodT
method_
;
ObjectT
*
object_
;
typename
std
:
:
tuple
<
typename
std
:
:
remove_reference
<
Args
>
:
:
type
.
.
.
>
args_
;
}
;
template
<
class
FunctorT
class
R
typename
.
.
.
Args
>
class
Functor
{
public
:
Functor
(
const
FunctorT
&
functor
Args
.
.
.
args
)
:
functor_
(
functor
)
args_
(
args
.
.
.
)
{
}
R
operator
(
)
(
)
const
{
return
CallFunction
(
typename
sequence_generator
<
sizeof
.
.
.
(
Args
)
>
:
:
type
(
)
)
;
}
private
:
template
<
int
.
.
.
S
>
R
CallFunction
(
sequence
<
S
.
.
.
>
)
const
{
return
functor_
(
std
:
:
get
<
S
>
(
args_
)
.
.
.
)
;
}
FunctorT
functor_
;
typename
std
:
:
tuple
<
typename
std
:
:
remove_reference
<
Args
>
:
:
type
.
.
.
>
args_
;
}
;
#
define
FP_T
(
x
)
R
(
ObjectT
:
:
*
x
)
(
Args
.
.
.
)
template
<
class
ObjectT
class
R
typename
.
.
.
Args
>
MethodFunctor
<
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
Bind
(
FP_T
(
method
)
ObjectT
*
object
typename
detail
:
:
identity
<
Args
>
:
:
type
.
.
.
args
)
{
return
MethodFunctor
<
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
(
method
object
args
.
.
.
)
;
}
template
<
class
ObjectT
class
R
typename
.
.
.
Args
>
MethodFunctor
<
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
Bind
(
FP_T
(
method
)
const
scoped_refptr
<
ObjectT
>
&
object
typename
detail
:
:
identity
<
Args
>
:
:
type
.
.
.
args
)
{
return
MethodFunctor
<
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
(
method
object
.
get
(
)
args
.
.
.
)
;
}
template
<
class
ObjectT
class
R
typename
.
.
.
Args
>
UnretainedMethodFunctor
<
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
Bind
(
FP_T
(
method
)
detail
:
:
UnretainedWrapper
<
ObjectT
>
object
typename
detail
:
:
identity
<
Args
>
:
:
type
.
.
.
args
)
{
return
UnretainedMethodFunctor
<
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
(
method
object
args
.
.
.
)
;
}
#
undef
FP_T
#
define
FP_T
(
x
)
R
(
ObjectT
:
:
*
x
)
(
Args
.
.
.
)
const
template
<
class
ObjectT
class
R
typename
.
.
.
Args
>
MethodFunctor
<
const
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
Bind
(
FP_T
(
method
)
const
ObjectT
*
object
typename
detail
:
:
identity
<
Args
>
:
:
type
.
.
.
args
)
{
return
MethodFunctor
<
const
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
(
method
object
args
.
.
.
)
;
}
template
<
class
ObjectT
class
R
typename
.
.
.
Args
>
UnretainedMethodFunctor
<
const
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
Bind
(
FP_T
(
method
)
detail
:
:
UnretainedWrapper
<
const
ObjectT
>
object
typename
detail
:
:
identity
<
Args
>
:
:
type
.
.
.
args
)
{
return
UnretainedMethodFunctor
<
const
ObjectT
FP_T
(
NONAME
)
R
Args
.
.
.
>
(
method
object
args
.
.
.
)
;
}
#
undef
FP_T
#
define
FP_T
(
x
)
R
(
*
x
)
(
Args
.
.
.
)
template
<
class
R
typename
.
.
.
Args
>
Functor
<
FP_T
(
NONAME
)
R
Args
.
.
.
>
Bind
(
FP_T
(
function
)
typename
detail
:
:
identity
<
Args
>
:
:
type
.
.
.
args
)
{
return
Functor
<
FP_T
(
NONAME
)
R
Args
.
.
.
>
(
function
args
.
.
.
)
;
}
#
undef
FP_T
}
#
undef
NONAME
#
endif
