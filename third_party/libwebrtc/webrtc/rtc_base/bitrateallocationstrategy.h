#
ifndef
RTC_BASE_BITRATEALLOCATIONSTRATEGY_H_
#
define
RTC_BASE_BITRATEALLOCATIONSTRATEGY_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
rtc
{
class
BitrateAllocationStrategy
{
public
:
struct
TrackConfig
{
TrackConfig
(
uint32_t
min_bitrate_bps
uint32_t
max_bitrate_bps
bool
enforce_min_bitrate
std
:
:
string
track_id
)
:
min_bitrate_bps
(
min_bitrate_bps
)
max_bitrate_bps
(
max_bitrate_bps
)
enforce_min_bitrate
(
enforce_min_bitrate
)
track_id
(
track_id
)
{
}
TrackConfig
(
const
TrackConfig
&
track_config
)
=
default
;
virtual
~
TrackConfig
(
)
=
default
;
TrackConfig
(
)
{
}
uint32_t
min_bitrate_bps
;
uint32_t
max_bitrate_bps
;
bool
enforce_min_bitrate
;
std
:
:
string
track_id
;
}
;
static
std
:
:
vector
<
uint32_t
>
SetAllBitratesToMinimum
(
const
ArrayView
<
const
TrackConfig
*
>
track_configs
)
;
static
std
:
:
vector
<
uint32_t
>
DistributeBitratesEvenly
(
const
ArrayView
<
const
TrackConfig
*
>
track_configs
uint32_t
available_bitrate
)
;
virtual
std
:
:
vector
<
uint32_t
>
AllocateBitrates
(
uint32_t
available_bitrate
const
ArrayView
<
const
TrackConfig
*
>
track_configs
)
=
0
;
virtual
~
BitrateAllocationStrategy
(
)
=
default
;
}
;
class
AudioPriorityBitrateAllocationStrategy
:
public
BitrateAllocationStrategy
{
public
:
AudioPriorityBitrateAllocationStrategy
(
std
:
:
string
audio_track_id
uint32_t
sufficient_audio_bitrate
)
;
std
:
:
vector
<
uint32_t
>
AllocateBitrates
(
uint32_t
available_bitrate
const
ArrayView
<
const
TrackConfig
*
>
track_configs
)
override
;
private
:
std
:
:
string
audio_track_id_
;
uint32_t
sufficient_audio_bitrate_
;
}
;
}
#
endif
