#
ifndef
RTC_BASE_LOGGING_H_
#
define
RTC_BASE_LOGGING_H_
#
include
<
errno
.
h
>
#
include
<
list
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
utility
>
#
if
defined
(
WEBRTC_MAC
)
&
&
!
defined
(
WEBRTC_IOS
)
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
endif
#
include
"
rtc_base
/
basictypes
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
if
!
defined
(
NDEBUG
)
|
|
defined
(
DLOG_ALWAYS_ON
)
#
define
RTC_DLOG_IS_ON
1
#
else
#
define
RTC_DLOG_IS_ON
0
#
endif
namespace
rtc
{
struct
ConstantLabel
{
int
value
;
const
char
*
label
;
}
;
#
define
KLABEL
(
x
)
{
x
#
x
}
#
define
TLABEL
(
x
y
)
{
x
y
}
#
define
LASTLABEL
{
0
0
}
const
char
*
FindLabel
(
int
value
const
ConstantLabel
entries
[
]
)
;
std
:
:
string
ErrorName
(
int
err
const
ConstantLabel
*
err_table
)
;
#
if
defined
(
WEBRTC_MAC
)
&
&
!
defined
(
WEBRTC_IOS
)
std
:
:
string
DescriptionFromOSStatus
(
OSStatus
err
)
;
#
endif
enum
LoggingSeverity
{
LS_SENSITIVE
LS_VERBOSE
LS_INFO
LS_WARNING
LS_ERROR
LS_NONE
INFO
=
LS_INFO
WARNING
=
LS_WARNING
LERROR
=
LS_ERROR
}
;
enum
LogErrorContext
{
ERRCTX_NONE
ERRCTX_ERRNO
ERRCTX_HRESULT
ERRCTX_OSSTATUS
ERRCTX_EN
=
ERRCTX_ERRNO
ERRCTX_HR
=
ERRCTX_HRESULT
ERRCTX_OS
=
ERRCTX_OSSTATUS
}
;
class
LogSink
{
public
:
LogSink
(
)
{
}
virtual
~
LogSink
(
)
{
}
virtual
void
OnLogMessage
(
const
std
:
:
string
&
message
)
=
0
;
}
;
class
LogMessage
{
public
:
LogMessage
(
const
char
*
file
int
line
LoggingSeverity
sev
LogErrorContext
err_ctx
=
ERRCTX_NONE
int
err
=
0
const
char
*
module
=
nullptr
)
;
LogMessage
(
const
char
*
file
int
line
LoggingSeverity
sev
const
std
:
:
string
&
tag
)
;
~
LogMessage
(
)
;
static
inline
bool
Loggable
(
LoggingSeverity
sev
)
{
return
(
sev
>
=
min_sev_
)
;
}
std
:
:
ostream
&
stream
(
)
{
return
print_stream_
;
}
static
int64_t
LogStartTime
(
)
;
static
uint32_t
WallClockStartTime
(
)
;
static
void
LogThreads
(
bool
on
=
true
)
;
static
void
LogTimestamps
(
bool
on
=
true
)
;
static
void
LogToDebug
(
LoggingSeverity
min_sev
)
;
static
LoggingSeverity
GetLogToDebug
(
)
{
return
dbg_sev_
;
}
static
void
SetLogToStderr
(
bool
log_to_stderr
)
;
static
int
GetLogToStream
(
LogSink
*
stream
=
nullptr
)
;
static
void
AddLogToStream
(
LogSink
*
stream
LoggingSeverity
min_sev
)
;
static
void
RemoveLogToStream
(
LogSink
*
stream
)
;
static
int
GetMinLogSeverity
(
)
{
return
min_sev_
;
}
static
void
ConfigureLogging
(
const
char
*
params
)
;
static
void
set_aec_debug
(
bool
enable
)
{
aec_debug_
=
enable
;
}
static
void
set_aec_debug_size
(
uint32_t
size
)
{
aec_debug_size_
=
size
;
}
static
bool
aec_debug
(
)
{
return
aec_debug_
;
}
static
uint32_t
aec_debug_size
(
)
{
return
aec_debug_size_
;
}
static
std
:
:
string
aec_debug_filename
(
)
;
static
void
set_aec_debug_filename
(
const
char
*
filename
)
{
aec_filename_base_
=
filename
;
}
private
:
typedef
std
:
:
pair
<
LogSink
*
LoggingSeverity
>
StreamAndSeverity
;
typedef
std
:
:
list
<
StreamAndSeverity
>
StreamList
;
static
void
UpdateMinLogSeverity
(
)
;
static
void
OutputToDebug
(
const
std
:
:
string
&
msg
LoggingSeverity
severity
const
std
:
:
string
&
tag
)
;
std
:
:
ostringstream
print_stream_
;
LoggingSeverity
severity_
;
std
:
:
string
tag_
;
std
:
:
string
extra_
;
static
LoggingSeverity
min_sev_
dbg_sev_
ctx_sev_
;
static
StreamList
streams_
;
static
bool
thread_
timestamp_
;
static
bool
log_to_stderr_
;
static
bool
aec_debug_
;
static
uint32_t
aec_debug_size_
;
static
std
:
:
string
aec_filename_base_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
LogMessage
)
;
}
;
class
LogMultilineState
{
public
:
size_t
unprintable_count_
[
2
]
;
LogMultilineState
(
)
{
unprintable_count_
[
0
]
=
unprintable_count_
[
1
]
=
0
;
}
}
;
void
LogMultiline
(
LoggingSeverity
level
const
char
*
label
bool
input
const
void
*
data
size_t
len
bool
hex_mode
LogMultilineState
*
state
)
;
class
LogMessageVoidify
{
public
:
LogMessageVoidify
(
)
{
}
void
operator
&
(
std
:
:
ostream
&
)
{
}
}
;
#
define
RTC_LOG_SEVERITY_PRECONDITION
(
sev
)
\
!
(
rtc
:
:
LogMessage
:
:
Loggable
(
sev
)
)
\
?
(
void
)
0
\
:
rtc
:
:
LogMessageVoidify
(
)
&
#
define
RTC_LOG
(
sev
)
\
RTC_LOG_SEVERITY_PRECONDITION
(
rtc
:
:
sev
)
\
rtc
:
:
LogMessage
(
__FILE__
__LINE__
rtc
:
:
sev
)
.
stream
(
)
#
define
RTC_LOG_V
(
sev
)
\
RTC_LOG_SEVERITY_PRECONDITION
(
sev
)
\
rtc
:
:
LogMessage
(
__FILE__
__LINE__
sev
)
.
stream
(
)
#
if
(
defined
(
__GNUC__
)
&
&
!
defined
(
NDEBUG
)
)
|
|
defined
(
WANT_PRETTY_LOG_F
)
#
define
RTC_LOG_F
(
sev
)
RTC_LOG
(
sev
)
<
<
__PRETTY_FUNCTION__
<
<
"
:
"
#
define
RTC_LOG_T_F
(
sev
)
RTC_LOG
(
sev
)
<
<
this
<
<
"
:
"
\
<
<
__PRETTY_FUNCTION__
<
<
"
:
"
#
else
#
define
RTC_LOG_F
(
sev
)
RTC_LOG
(
sev
)
<
<
__FUNCTION__
<
<
"
:
"
#
define
RTC_LOG_T_F
(
sev
)
RTC_LOG
(
sev
)
<
<
this
<
<
"
:
"
<
<
__FUNCTION__
<
<
"
:
"
#
endif
#
define
RTC_LOG_CHECK_LEVEL
(
sev
)
\
rtc
:
:
LogCheckLevel
(
rtc
:
:
sev
)
#
define
RTC_LOG_CHECK_LEVEL_V
(
sev
)
\
rtc
:
:
LogCheckLevel
(
sev
)
inline
bool
LogCheckLevel
(
LoggingSeverity
sev
)
{
return
(
LogMessage
:
:
GetMinLogSeverity
(
)
<
=
sev
)
;
}
#
define
RTC_LOG_E
(
sev
ctx
err
.
.
.
)
\
RTC_LOG_SEVERITY_PRECONDITION
(
rtc
:
:
sev
)
\
rtc
:
:
LogMessage
(
__FILE__
__LINE__
rtc
:
:
sev
\
rtc
:
:
ERRCTX_
#
#
ctx
err
#
#
__VA_ARGS__
)
\
.
stream
(
)
#
define
RTC_LOG_T
(
sev
)
RTC_LOG
(
sev
)
<
<
this
<
<
"
:
"
#
define
RTC_LOG_ERRNO_EX
(
sev
err
)
\
RTC_LOG_E
(
sev
ERRNO
err
)
#
define
RTC_LOG_ERRNO
(
sev
)
\
RTC_LOG_ERRNO_EX
(
sev
errno
)
#
if
defined
(
WEBRTC_WIN
)
#
define
RTC_LOG_GLE_EX
(
sev
err
)
\
RTC_LOG_E
(
sev
HRESULT
err
)
#
define
RTC_LOG_GLE
(
sev
)
\
RTC_LOG_GLE_EX
(
sev
GetLastError
(
)
)
#
define
RTC_LOG_GLEM
(
sev
mod
)
\
RTC_LOG_E
(
sev
HRESULT
GetLastError
(
)
mod
)
#
define
RTC_LOG_ERR_EX
(
sev
err
)
\
RTC_LOG_GLE_EX
(
sev
err
)
#
define
RTC_LOG_ERR
(
sev
)
\
RTC_LOG_GLE
(
sev
)
#
define
RTC_LAST_SYSTEM_ERROR
\
(
:
:
GetLastError
(
)
)
#
elif
defined
(
__native_client__
)
&
&
__native_client__
#
define
RTC_LOG_ERR_EX
(
sev
err
)
\
RTC_LOG
(
sev
)
#
define
RTC_LOG_ERR
(
sev
)
\
RTC_LOG
(
sev
)
#
define
RTC_LAST_SYSTEM_ERROR
\
(
0
)
#
elif
defined
(
WEBRTC_POSIX
)
#
define
RTC_LOG_ERR_EX
(
sev
err
)
\
RTC_LOG_ERRNO_EX
(
sev
err
)
#
define
RTC_LOG_ERR
(
sev
)
\
RTC_LOG_ERRNO
(
sev
)
#
define
RTC_LAST_SYSTEM_ERROR
\
(
errno
)
#
endif
#
define
RTC_LOG_TAG
(
sev
tag
)
\
RTC_LOG_SEVERITY_PRECONDITION
(
sev
)
\
rtc
:
:
LogMessage
(
nullptr
0
sev
tag
)
.
stream
(
)
#
define
RTC_PLOG
(
sev
err
)
\
RTC_LOG_ERR_EX
(
sev
err
)
#
if
RTC_DLOG_IS_ON
#
define
RTC_DLOG
(
sev
)
RTC_LOG
(
sev
)
#
define
RTC_DLOG_V
(
sev
)
RTC_LOG_V
(
sev
)
#
define
RTC_DLOG_F
(
sev
)
RTC_LOG_F
(
sev
)
#
else
#
define
RTC_DLOG_EAT_STREAM_PARAMS
(
sev
)
\
(
true
?
true
:
(
(
void
)
(
rtc
:
:
sev
)
true
)
)
\
?
static_cast
<
void
>
(
0
)
\
:
rtc
:
:
LogMessageVoidify
(
)
&
\
rtc
:
:
LogMessage
(
__FILE__
__LINE__
rtc
:
:
sev
)
.
stream
(
)
#
define
RTC_DLOG
(
sev
)
RTC_DLOG_EAT_STREAM_PARAMS
(
sev
)
#
define
RTC_DLOG_V
(
sev
)
RTC_DLOG_EAT_STREAM_PARAMS
(
sev
)
#
define
RTC_DLOG_F
(
sev
)
RTC_DLOG_EAT_STREAM_PARAMS
(
sev
)
#
endif
}
#
endif
