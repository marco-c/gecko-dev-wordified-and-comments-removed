#
ifndef
RTC_BASE_ASYNCINVOKER_H_
#
define
RTC_BASE_ASYNCINVOKER_H_
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
rtc_base
/
asyncinvoker
-
inl
.
h
"
#
include
"
rtc_base
/
bind
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
refcountedobject
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
rtc
{
class
AsyncInvoker
:
public
MessageHandler
{
public
:
AsyncInvoker
(
)
;
~
AsyncInvoker
(
)
override
;
template
<
class
ReturnT
class
FunctorT
>
void
AsyncInvoke
(
const
Location
&
posted_from
Thread
*
thread
const
FunctorT
&
functor
uint32_t
id
=
0
)
{
std
:
:
unique_ptr
<
AsyncClosure
>
closure
(
new
FireAndForgetAsyncClosure
<
FunctorT
>
(
this
functor
)
)
;
DoInvoke
(
posted_from
thread
std
:
:
move
(
closure
)
id
)
;
}
template
<
class
ReturnT
class
FunctorT
>
void
AsyncInvokeDelayed
(
const
Location
&
posted_from
Thread
*
thread
const
FunctorT
&
functor
uint32_t
delay_ms
uint32_t
id
=
0
)
{
std
:
:
unique_ptr
<
AsyncClosure
>
closure
(
new
FireAndForgetAsyncClosure
<
FunctorT
>
(
this
functor
)
)
;
DoInvokeDelayed
(
posted_from
thread
std
:
:
move
(
closure
)
delay_ms
id
)
;
}
void
Flush
(
Thread
*
thread
uint32_t
id
=
MQID_ANY
)
;
private
:
void
OnMessage
(
Message
*
msg
)
override
;
void
DoInvoke
(
const
Location
&
posted_from
Thread
*
thread
std
:
:
unique_ptr
<
AsyncClosure
>
closure
uint32_t
id
)
;
void
DoInvokeDelayed
(
const
Location
&
posted_from
Thread
*
thread
std
:
:
unique_ptr
<
AsyncClosure
>
closure
uint32_t
delay_ms
uint32_t
id
)
;
std
:
:
atomic
<
int
>
pending_invocations_
;
scoped_refptr
<
RefCountedObject
<
Event
>
>
invocation_complete_
;
std
:
:
atomic
<
bool
>
destroying_
;
friend
class
AsyncClosure
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AsyncInvoker
)
;
}
;
class
GuardedAsyncInvoker
:
public
sigslot
:
:
has_slots
<
>
{
public
:
GuardedAsyncInvoker
(
)
;
~
GuardedAsyncInvoker
(
)
override
;
bool
Flush
(
uint32_t
id
=
MQID_ANY
)
;
template
<
class
ReturnT
class
FunctorT
>
bool
AsyncInvoke
(
const
Location
&
posted_from
const
FunctorT
&
functor
uint32_t
id
=
0
)
{
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvoke
<
ReturnT
FunctorT
>
(
posted_from
thread_
functor
id
)
;
return
true
;
}
template
<
class
ReturnT
class
FunctorT
>
bool
AsyncInvokeDelayed
(
const
Location
&
posted_from
const
FunctorT
&
functor
uint32_t
delay_ms
uint32_t
id
=
0
)
{
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvokeDelayed
<
ReturnT
FunctorT
>
(
posted_from
thread_
functor
delay_ms
id
)
;
return
true
;
}
template
<
class
ReturnT
class
FunctorT
class
HostT
>
bool
AsyncInvoke
(
const
Location
&
posted_from
const
Location
&
callback_posted_from
const
FunctorT
&
functor
void
(
HostT
:
:
*
callback
)
(
ReturnT
)
HostT
*
callback_host
uint32_t
id
=
0
)
{
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvoke
<
ReturnT
FunctorT
HostT
>
(
posted_from
callback_posted_from
thread_
functor
callback
callback_host
id
)
;
return
true
;
}
template
<
class
ReturnT
class
FunctorT
class
HostT
>
bool
AsyncInvoke
(
const
Location
&
posted_from
const
Location
&
callback_posted_from
const
FunctorT
&
functor
void
(
HostT
:
:
*
callback
)
(
)
HostT
*
callback_host
uint32_t
id
=
0
)
{
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvoke
<
ReturnT
FunctorT
HostT
>
(
posted_from
callback_posted_from
thread_
functor
callback
callback_host
id
)
;
return
true
;
}
private
:
void
ThreadDestroyed
(
)
;
CriticalSection
crit_
;
Thread
*
thread_
RTC_GUARDED_BY
(
crit_
)
;
AsyncInvoker
invoker_
RTC_GUARDED_BY
(
crit_
)
;
}
;
}
#
endif
