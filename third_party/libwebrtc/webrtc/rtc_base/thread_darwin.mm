#
include
"
rtc_base
/
thread
.
h
"
#
import
<
Foundation
/
Foundation
.
h
>
#
include
"
rtc_base
/
platform_thread
.
h
"
namespace
{
void
InitCocoaMultiThreading
(
)
{
if
(
[
NSThread
isMultiThreaded
]
=
=
NO
)
{
autoreleasepool
{
[
NSThread
detachNewThreadSelector
:
selector
(
class
)
toTarget
:
[
NSObject
class
]
withObject
:
nil
]
;
}
}
RTC_DCHECK
(
[
NSThread
isMultiThreaded
]
)
;
}
}
namespace
rtc
{
ThreadManager
:
:
ThreadManager
(
)
{
main_thread_ref_
=
CurrentThreadRef
(
)
;
pthread_key_create
(
&
key_
nullptr
)
;
InitCocoaMultiThreading
(
)
;
}
void
*
Thread
:
:
PreRun
(
void
*
pv
)
{
ThreadInit
*
init
=
static_cast
<
ThreadInit
*
>
(
pv
)
;
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
init
-
>
thread
)
;
rtc
:
:
SetCurrentThreadName
(
init
-
>
thread
-
>
name_
.
c_str
(
)
)
;
autoreleasepool
{
if
(
init
-
>
runnable
)
{
init
-
>
runnable
-
>
Run
(
init
-
>
thread
)
;
}
else
{
init
-
>
thread
-
>
Run
(
)
;
}
}
delete
init
;
return
nullptr
;
}
bool
Thread
:
:
ProcessMessages
(
int
cmsLoop
)
{
int64_t
msEnd
=
(
kForever
=
=
cmsLoop
)
?
0
:
TimeAfter
(
cmsLoop
)
;
int
cmsNext
=
cmsLoop
;
while
(
true
)
{
autoreleasepool
{
Message
msg
;
if
(
!
Get
(
&
msg
cmsNext
)
)
return
!
IsQuitting
(
)
;
Dispatch
(
&
msg
)
;
if
(
cmsLoop
!
=
kForever
)
{
cmsNext
=
static_cast
<
int
>
(
TimeUntil
(
msEnd
)
)
;
if
(
cmsNext
<
0
)
return
true
;
}
}
}
}
}
