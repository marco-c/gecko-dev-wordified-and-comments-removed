#
ifndef
RTC_BASE_CRITICALSECTION_H_
#
define
RTC_BASE_CRITICALSECTION_H_
#
include
"
rtc_base
/
atomicops
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
typedefs
.
h
"
#
if
defined
(
WEBRTC_WIN
)
#
include
<
winsock2
.
h
>
#
include
<
windows
.
h
>
#
include
<
sal
.
h
>
#
endif
#
if
defined
(
WEBRTC_POSIX
)
#
include
<
pthread
.
h
>
#
endif
#
define
USE_NATIVE_MUTEX_ON_MAC
0
#
if
defined
(
WEBRTC_MAC
)
&
&
!
USE_NATIVE_MUTEX_ON_MAC
#
include
<
dispatch
/
dispatch
.
h
>
#
endif
#
define
CS_DEBUG_CHECKS
RTC_DCHECK_IS_ON
#
if
CS_DEBUG_CHECKS
#
define
CS_DEBUG_CODE
(
x
)
x
#
else
#
define
CS_DEBUG_CODE
(
x
)
#
endif
namespace
rtc
{
class
RTC_LOCKABLE
CriticalSection
{
public
:
CriticalSection
(
)
;
~
CriticalSection
(
)
;
void
Enter
(
)
const
RTC_EXCLUSIVE_LOCK_FUNCTION
(
)
;
bool
TryEnter
(
)
const
RTC_EXCLUSIVE_TRYLOCK_FUNCTION
(
true
)
;
void
Leave
(
)
const
RTC_UNLOCK_FUNCTION
(
)
;
private
:
bool
CurrentThreadIsOwner
(
)
const
;
#
if
defined
(
WEBRTC_WIN
)
mutable
CRITICAL_SECTION
crit_
;
#
elif
defined
(
WEBRTC_POSIX
)
#
if
defined
(
WEBRTC_MAC
)
&
&
!
USE_NATIVE_MUTEX_ON_MAC
mutable
volatile
int
lock_queue_
;
mutable
int
recursion_
;
mutable
dispatch_semaphore_t
semaphore_
;
mutable
PlatformThreadRef
owning_thread_
;
#
else
mutable
pthread_mutex_t
mutex_
;
#
endif
mutable
PlatformThreadRef
thread_
;
mutable
int
recursion_count_
;
#
else
#
error
Unsupported
platform
.
#
endif
}
;
class
RTC_SCOPED_LOCKABLE
CritScope
{
public
:
explicit
CritScope
(
const
CriticalSection
*
cs
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
cs
)
;
~
CritScope
(
)
RTC_UNLOCK_FUNCTION
(
)
;
private
:
const
CriticalSection
*
const
cs_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
CritScope
)
;
}
;
class
TryCritScope
{
public
:
explicit
TryCritScope
(
const
CriticalSection
*
cs
)
;
~
TryCritScope
(
)
;
#
if
defined
(
WEBRTC_WIN
)
_Check_return_
bool
locked
(
)
const
;
#
elif
defined
(
WEBRTC_POSIX
)
bool
locked
(
)
const
__attribute__
(
(
__warn_unused_result__
)
)
;
#
else
#
error
Unsupported
platform
.
#
endif
private
:
const
CriticalSection
*
const
cs_
;
const
bool
locked_
;
mutable
bool
lock_was_called_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
TryCritScope
)
;
}
;
class
RTC_LOCKABLE
GlobalLockPod
{
public
:
void
Lock
(
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
)
;
void
Unlock
(
)
RTC_UNLOCK_FUNCTION
(
)
;
volatile
int
lock_acquired
;
}
;
class
GlobalLock
:
public
GlobalLockPod
{
public
:
GlobalLock
(
)
;
}
;
class
RTC_SCOPED_LOCKABLE
GlobalLockScope
{
public
:
explicit
GlobalLockScope
(
GlobalLockPod
*
lock
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
lock
)
;
~
GlobalLockScope
(
)
RTC_UNLOCK_FUNCTION
(
)
;
private
:
GlobalLockPod
*
const
lock_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
GlobalLockScope
)
;
}
;
}
#
endif
