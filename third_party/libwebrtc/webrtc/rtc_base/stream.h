#
ifndef
RTC_BASE_STREAM_H_
#
define
RTC_BASE_STREAM_H_
#
include
<
stdio
.
h
>
#
include
<
memory
>
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
messagehandler
.
h
"
#
include
"
rtc_base
/
messagequeue
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
namespace
rtc
{
enum
StreamState
{
SS_CLOSED
SS_OPENING
SS_OPEN
}
;
enum
StreamResult
{
SR_ERROR
SR_SUCCESS
SR_BLOCK
SR_EOS
}
;
enum
StreamEvent
{
SE_OPEN
=
1
SE_READ
=
2
SE_WRITE
=
4
SE_CLOSE
=
8
}
;
class
Thread
;
struct
StreamEventData
:
public
MessageData
{
int
events
error
;
StreamEventData
(
int
ev
int
er
)
:
events
(
ev
)
error
(
er
)
{
}
}
;
class
StreamInterface
:
public
MessageHandler
{
public
:
enum
{
MSG_POST_EVENT
=
0xF1F1
MSG_MAX
=
MSG_POST_EVENT
}
;
~
StreamInterface
(
)
override
;
virtual
StreamState
GetState
(
)
const
=
0
;
virtual
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
=
0
;
virtual
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
=
0
;
virtual
void
Close
(
)
=
0
;
sigslot
:
:
signal3
<
StreamInterface
*
int
int
>
SignalEvent
;
void
PostEvent
(
Thread
*
t
int
events
int
err
)
;
void
PostEvent
(
int
events
int
err
)
;
virtual
const
void
*
GetReadData
(
size_t
*
data_len
)
;
virtual
void
ConsumeReadData
(
size_t
used
)
{
}
virtual
void
*
GetWriteBuffer
(
size_t
*
buf_len
)
;
virtual
void
ConsumeWriteBuffer
(
size_t
used
)
{
}
virtual
bool
SetPosition
(
size_t
position
)
;
virtual
bool
GetPosition
(
size_t
*
position
)
const
;
virtual
bool
GetSize
(
size_t
*
size
)
const
;
virtual
bool
GetAvailable
(
size_t
*
size
)
const
;
virtual
bool
GetWriteRemaining
(
size_t
*
size
)
const
;
virtual
bool
Flush
(
)
;
virtual
bool
ReserveSize
(
size_t
size
)
;
inline
bool
Rewind
(
)
{
return
SetPosition
(
0
)
;
}
StreamResult
WriteAll
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
;
StreamResult
ReadAll
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
;
StreamResult
ReadLine
(
std
:
:
string
*
line
)
;
protected
:
StreamInterface
(
)
;
void
OnMessage
(
Message
*
msg
)
override
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
StreamInterface
)
;
}
;
class
StreamAdapterInterface
:
public
StreamInterface
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
StreamAdapterInterface
(
StreamInterface
*
stream
bool
owned
=
true
)
;
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
void
Close
(
)
override
;
bool
SetPosition
(
size_t
position
)
override
;
bool
GetPosition
(
size_t
*
position
)
const
override
;
bool
GetSize
(
size_t
*
size
)
const
override
;
bool
GetAvailable
(
size_t
*
size
)
const
override
;
bool
GetWriteRemaining
(
size_t
*
size
)
const
override
;
bool
ReserveSize
(
size_t
size
)
override
;
bool
Flush
(
)
override
;
void
Attach
(
StreamInterface
*
stream
bool
owned
=
true
)
;
StreamInterface
*
Detach
(
)
;
protected
:
~
StreamAdapterInterface
(
)
override
;
virtual
void
OnEvent
(
StreamInterface
*
stream
int
events
int
err
)
;
StreamInterface
*
stream
(
)
{
return
stream_
;
}
private
:
StreamInterface
*
stream_
;
bool
owned_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
StreamAdapterInterface
)
;
}
;
class
StreamTap
:
public
StreamAdapterInterface
{
public
:
explicit
StreamTap
(
StreamInterface
*
stream
StreamInterface
*
tap
)
;
~
StreamTap
(
)
override
;
void
AttachTap
(
StreamInterface
*
tap
)
;
StreamInterface
*
DetachTap
(
)
;
StreamResult
GetTapResult
(
int
*
error
)
;
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
private
:
std
:
:
unique_ptr
<
StreamInterface
>
tap_
;
StreamResult
tap_result_
;
int
tap_error_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
StreamTap
)
;
}
;
class
NullStream
:
public
StreamInterface
{
public
:
NullStream
(
)
;
~
NullStream
(
)
override
;
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
void
Close
(
)
override
;
}
;
class
FileStream
:
public
StreamInterface
{
public
:
FileStream
(
)
;
~
FileStream
(
)
override
;
virtual
bool
Open
(
const
std
:
:
string
&
filename
const
char
*
mode
int
*
error
)
;
virtual
bool
OpenShare
(
const
std
:
:
string
&
filename
const
char
*
mode
int
shflag
int
*
error
)
;
virtual
bool
DisableBuffering
(
)
;
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
void
Close
(
)
override
;
bool
SetPosition
(
size_t
position
)
override
;
bool
GetPosition
(
size_t
*
position
)
const
override
;
bool
GetSize
(
size_t
*
size
)
const
override
;
bool
GetAvailable
(
size_t
*
size
)
const
override
;
bool
ReserveSize
(
size_t
size
)
override
;
bool
Flush
(
)
override
;
#
if
defined
(
WEBRTC_POSIX
)
&
&
!
defined
(
__native_client__
)
bool
TryLock
(
)
;
bool
Unlock
(
)
;
#
endif
protected
:
virtual
void
DoClose
(
)
;
FILE
*
file_
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
FileStream
)
;
}
;
class
MemoryStreamBase
:
public
StreamInterface
{
public
:
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
bytes
size_t
*
bytes_read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
buffer
size_t
bytes
size_t
*
bytes_written
int
*
error
)
override
;
void
Close
(
)
override
;
bool
SetPosition
(
size_t
position
)
override
;
bool
GetPosition
(
size_t
*
position
)
const
override
;
bool
GetSize
(
size_t
*
size
)
const
override
;
bool
GetAvailable
(
size_t
*
size
)
const
override
;
bool
ReserveSize
(
size_t
size
)
override
;
char
*
GetBuffer
(
)
{
return
buffer_
;
}
const
char
*
GetBuffer
(
)
const
{
return
buffer_
;
}
protected
:
MemoryStreamBase
(
)
;
virtual
StreamResult
DoReserve
(
size_t
size
int
*
error
)
;
char
*
buffer_
;
size_t
buffer_length_
;
size_t
data_length_
;
size_t
seek_position_
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
MemoryStreamBase
)
;
}
;
class
MemoryStream
:
public
MemoryStreamBase
{
public
:
MemoryStream
(
)
;
explicit
MemoryStream
(
const
char
*
data
)
;
MemoryStream
(
const
void
*
data
size_t
length
)
;
~
MemoryStream
(
)
override
;
void
SetData
(
const
void
*
data
size_t
length
)
;
protected
:
StreamResult
DoReserve
(
size_t
size
int
*
error
)
override
;
static
const
int
kAlignment
=
16
;
char
*
buffer_alloc_
;
}
;
class
ExternalMemoryStream
:
public
MemoryStreamBase
{
public
:
ExternalMemoryStream
(
)
;
ExternalMemoryStream
(
void
*
data
size_t
length
)
;
~
ExternalMemoryStream
(
)
override
;
void
SetData
(
void
*
data
size_t
length
)
;
}
;
class
FifoBuffer
:
public
StreamInterface
{
public
:
explicit
FifoBuffer
(
size_t
length
)
;
FifoBuffer
(
size_t
length
Thread
*
owner
)
;
~
FifoBuffer
(
)
override
;
bool
GetBuffered
(
size_t
*
data_len
)
const
;
bool
SetCapacity
(
size_t
length
)
;
StreamResult
ReadOffset
(
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_read
)
;
StreamResult
WriteOffset
(
const
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_written
)
;
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
bytes
size_t
*
bytes_read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
buffer
size_t
bytes
size_t
*
bytes_written
int
*
error
)
override
;
void
Close
(
)
override
;
const
void
*
GetReadData
(
size_t
*
data_len
)
override
;
void
ConsumeReadData
(
size_t
used
)
override
;
void
*
GetWriteBuffer
(
size_t
*
buf_len
)
override
;
void
ConsumeWriteBuffer
(
size_t
used
)
override
;
bool
GetWriteRemaining
(
size_t
*
size
)
const
override
;
private
:
StreamResult
ReadOffsetLocked
(
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_read
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
StreamResult
WriteOffsetLocked
(
const
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_written
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
StreamState
state_
RTC_GUARDED_BY
(
crit_
)
;
std
:
:
unique_ptr
<
char
[
]
>
buffer_
RTC_GUARDED_BY
(
crit_
)
;
size_t
buffer_length_
RTC_GUARDED_BY
(
crit_
)
;
size_t
data_length_
RTC_GUARDED_BY
(
crit_
)
;
size_t
read_position_
RTC_GUARDED_BY
(
crit_
)
;
Thread
*
owner_
;
CriticalSection
crit_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
FifoBuffer
)
;
}
;
class
LoggingAdapter
:
public
StreamAdapterInterface
{
public
:
LoggingAdapter
(
StreamInterface
*
stream
LoggingSeverity
level
const
std
:
:
string
&
label
bool
hex_mode
=
false
)
;
void
set_label
(
const
std
:
:
string
&
label
)
;
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
void
Close
(
)
override
;
protected
:
void
OnEvent
(
StreamInterface
*
stream
int
events
int
err
)
override
;
private
:
LoggingSeverity
level_
;
std
:
:
string
label_
;
bool
hex_mode_
;
LogMultilineState
lms_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
LoggingAdapter
)
;
}
;
class
StringStream
:
public
StreamInterface
{
public
:
explicit
StringStream
(
std
:
:
string
*
str
)
;
explicit
StringStream
(
const
std
:
:
string
&
str
)
;
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
void
Close
(
)
override
;
bool
SetPosition
(
size_t
position
)
override
;
bool
GetPosition
(
size_t
*
position
)
const
override
;
bool
GetSize
(
size_t
*
size
)
const
override
;
bool
GetAvailable
(
size_t
*
size
)
const
override
;
bool
ReserveSize
(
size_t
size
)
override
;
private
:
std
:
:
string
&
str_
;
size_t
read_pos_
;
bool
read_only_
;
}
;
class
StreamReference
:
public
StreamAdapterInterface
{
class
StreamRefCount
;
public
:
explicit
StreamReference
(
StreamInterface
*
stream
)
;
StreamInterface
*
GetStream
(
)
{
return
stream
(
)
;
}
StreamInterface
*
NewReference
(
)
;
~
StreamReference
(
)
override
;
private
:
class
StreamRefCount
{
public
:
explicit
StreamRefCount
(
StreamInterface
*
stream
)
:
stream_
(
stream
)
ref_count_
(
1
)
{
}
void
AddReference
(
)
{
CritScope
lock
(
&
cs_
)
;
+
+
ref_count_
;
}
void
Release
(
)
{
int
ref_count
;
{
CritScope
lock
(
&
cs_
)
;
ref_count
=
-
-
ref_count_
;
}
if
(
ref_count
=
=
0
)
{
delete
stream_
;
delete
this
;
}
}
private
:
StreamInterface
*
stream_
;
int
ref_count_
;
CriticalSection
cs_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
StreamRefCount
)
;
}
;
explicit
StreamReference
(
StreamRefCount
*
stream_ref_count
StreamInterface
*
stream
)
;
StreamRefCount
*
stream_ref_count_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
StreamReference
)
;
}
;
StreamResult
Flow
(
StreamInterface
*
source
char
*
buffer
size_t
buffer_len
StreamInterface
*
sink
size_t
*
data_len
=
nullptr
)
;
}
#
endif
