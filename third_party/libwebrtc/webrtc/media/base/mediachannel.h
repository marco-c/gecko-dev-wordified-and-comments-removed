#
ifndef
MEDIA_BASE_MEDIACHANNEL_H_
#
define
MEDIA_BASE_MEDIACHANNEL_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
audio_codecs
/
audio_encoder
.
h
"
#
include
"
api
/
optional
.
h
"
#
include
"
api
/
rtpparameters
.
h
"
#
include
"
api
/
rtpreceiverinterface
.
h
"
#
include
"
api
/
video
/
video_timing
.
h
"
#
include
"
call
/
video_config
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
mediaconstants
.
h
"
#
include
"
media
/
base
/
streamparams
.
h
"
#
include
"
media
/
base
/
videosinkinterface
.
h
"
#
include
"
media
/
base
/
videosourceinterface
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing_statistics
.
h
"
#
include
"
rtc_base
/
asyncpacketsocket
.
h
"
#
include
"
rtc_base
/
basictypes
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
copyonwritebuffer
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
networkroute
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
window
.
h
"
namespace
rtc
{
class
RateLimiter
;
class
Timing
;
}
namespace
webrtc
{
class
AudioSinkInterface
;
class
VideoFrame
;
}
namespace
cricket
{
class
AudioSource
;
class
VideoCapturer
;
struct
RtpHeader
;
struct
VideoFormat
;
const
int
kScreencastDefaultFps
=
5
;
template
<
class
T
>
static
std
:
:
string
ToStringIfSet
(
const
char
*
key
const
rtc
:
:
Optional
<
T
>
&
val
)
{
std
:
:
string
str
;
if
(
val
)
{
str
=
key
;
str
+
=
"
:
"
;
str
+
=
val
?
rtc
:
:
ToString
(
*
val
)
:
"
"
;
str
+
=
"
"
;
}
return
str
;
}
template
<
class
T
>
static
std
:
:
string
VectorToString
(
const
std
:
:
vector
<
T
>
&
vals
)
{
std
:
:
ostringstream
ost
;
ost
<
<
"
[
"
;
for
(
size_t
i
=
0
;
i
<
vals
.
size
(
)
;
+
+
i
)
{
if
(
i
>
0
)
{
ost
<
<
"
"
;
}
ost
<
<
vals
[
i
]
.
ToString
(
)
;
}
ost
<
<
"
]
"
;
return
ost
.
str
(
)
;
}
struct
MediaConfig
{
bool
enable_dscp
=
false
;
struct
Video
{
bool
enable_cpu_overuse_detection
=
true
;
bool
suspend_below_min_bitrate
=
false
;
bool
disable_prerenderer_smoothing
=
false
;
bool
periodic_alr_bandwidth_probing
=
false
;
}
video
;
bool
operator
=
=
(
const
MediaConfig
&
o
)
const
{
return
enable_dscp
=
=
o
.
enable_dscp
&
&
video
.
enable_cpu_overuse_detection
=
=
o
.
video
.
enable_cpu_overuse_detection
&
&
video
.
suspend_below_min_bitrate
=
=
o
.
video
.
suspend_below_min_bitrate
&
&
video
.
disable_prerenderer_smoothing
=
=
o
.
video
.
disable_prerenderer_smoothing
&
&
video
.
periodic_alr_bandwidth_probing
=
=
o
.
video
.
periodic_alr_bandwidth_probing
;
}
bool
operator
!
=
(
const
MediaConfig
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
struct
AudioOptions
{
void
SetAll
(
const
AudioOptions
&
change
)
{
SetFrom
(
&
echo_cancellation
change
.
echo_cancellation
)
;
SetFrom
(
&
auto_gain_control
change
.
auto_gain_control
)
;
SetFrom
(
&
noise_suppression
change
.
noise_suppression
)
;
SetFrom
(
&
highpass_filter
change
.
highpass_filter
)
;
SetFrom
(
&
stereo_swapping
change
.
stereo_swapping
)
;
SetFrom
(
&
audio_jitter_buffer_max_packets
change
.
audio_jitter_buffer_max_packets
)
;
SetFrom
(
&
audio_jitter_buffer_fast_accelerate
change
.
audio_jitter_buffer_fast_accelerate
)
;
SetFrom
(
&
typing_detection
change
.
typing_detection
)
;
SetFrom
(
&
aecm_generate_comfort_noise
change
.
aecm_generate_comfort_noise
)
;
SetFrom
(
&
adjust_agc_delta
change
.
adjust_agc_delta
)
;
SetFrom
(
&
experimental_agc
change
.
experimental_agc
)
;
SetFrom
(
&
extended_filter_aec
change
.
extended_filter_aec
)
;
SetFrom
(
&
delay_agnostic_aec
change
.
delay_agnostic_aec
)
;
SetFrom
(
&
experimental_ns
change
.
experimental_ns
)
;
SetFrom
(
&
intelligibility_enhancer
change
.
intelligibility_enhancer
)
;
SetFrom
(
&
level_control
change
.
level_control
)
;
SetFrom
(
&
residual_echo_detector
change
.
residual_echo_detector
)
;
SetFrom
(
&
tx_agc_target_dbov
change
.
tx_agc_target_dbov
)
;
SetFrom
(
&
tx_agc_digital_compression_gain
change
.
tx_agc_digital_compression_gain
)
;
SetFrom
(
&
tx_agc_limiter
change
.
tx_agc_limiter
)
;
SetFrom
(
&
combined_audio_video_bwe
change
.
combined_audio_video_bwe
)
;
SetFrom
(
&
audio_network_adaptor
change
.
audio_network_adaptor
)
;
SetFrom
(
&
audio_network_adaptor_config
change
.
audio_network_adaptor_config
)
;
SetFrom
(
&
level_control_initial_peak_level_dbfs
change
.
level_control_initial_peak_level_dbfs
)
;
}
bool
operator
=
=
(
const
AudioOptions
&
o
)
const
{
return
echo_cancellation
=
=
o
.
echo_cancellation
&
&
auto_gain_control
=
=
o
.
auto_gain_control
&
&
noise_suppression
=
=
o
.
noise_suppression
&
&
highpass_filter
=
=
o
.
highpass_filter
&
&
stereo_swapping
=
=
o
.
stereo_swapping
&
&
audio_jitter_buffer_max_packets
=
=
o
.
audio_jitter_buffer_max_packets
&
&
audio_jitter_buffer_fast_accelerate
=
=
o
.
audio_jitter_buffer_fast_accelerate
&
&
typing_detection
=
=
o
.
typing_detection
&
&
aecm_generate_comfort_noise
=
=
o
.
aecm_generate_comfort_noise
&
&
experimental_agc
=
=
o
.
experimental_agc
&
&
extended_filter_aec
=
=
o
.
extended_filter_aec
&
&
delay_agnostic_aec
=
=
o
.
delay_agnostic_aec
&
&
experimental_ns
=
=
o
.
experimental_ns
&
&
intelligibility_enhancer
=
=
o
.
intelligibility_enhancer
&
&
level_control
=
=
o
.
level_control
&
&
residual_echo_detector
=
=
o
.
residual_echo_detector
&
&
adjust_agc_delta
=
=
o
.
adjust_agc_delta
&
&
tx_agc_target_dbov
=
=
o
.
tx_agc_target_dbov
&
&
tx_agc_digital_compression_gain
=
=
o
.
tx_agc_digital_compression_gain
&
&
tx_agc_limiter
=
=
o
.
tx_agc_limiter
&
&
combined_audio_video_bwe
=
=
o
.
combined_audio_video_bwe
&
&
audio_network_adaptor
=
=
o
.
audio_network_adaptor
&
&
audio_network_adaptor_config
=
=
o
.
audio_network_adaptor_config
&
&
level_control_initial_peak_level_dbfs
=
=
o
.
level_control_initial_peak_level_dbfs
;
}
bool
operator
!
=
(
const
AudioOptions
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
std
:
:
string
ToString
(
)
const
{
std
:
:
ostringstream
ost
;
ost
<
<
"
AudioOptions
{
"
;
ost
<
<
ToStringIfSet
(
"
aec
"
echo_cancellation
)
;
ost
<
<
ToStringIfSet
(
"
agc
"
auto_gain_control
)
;
ost
<
<
ToStringIfSet
(
"
ns
"
noise_suppression
)
;
ost
<
<
ToStringIfSet
(
"
hf
"
highpass_filter
)
;
ost
<
<
ToStringIfSet
(
"
swap
"
stereo_swapping
)
;
ost
<
<
ToStringIfSet
(
"
audio_jitter_buffer_max_packets
"
audio_jitter_buffer_max_packets
)
;
ost
<
<
ToStringIfSet
(
"
audio_jitter_buffer_fast_accelerate
"
audio_jitter_buffer_fast_accelerate
)
;
ost
<
<
ToStringIfSet
(
"
typing
"
typing_detection
)
;
ost
<
<
ToStringIfSet
(
"
comfort_noise
"
aecm_generate_comfort_noise
)
;
ost
<
<
ToStringIfSet
(
"
agc_delta
"
adjust_agc_delta
)
;
ost
<
<
ToStringIfSet
(
"
experimental_agc
"
experimental_agc
)
;
ost
<
<
ToStringIfSet
(
"
extended_filter_aec
"
extended_filter_aec
)
;
ost
<
<
ToStringIfSet
(
"
delay_agnostic_aec
"
delay_agnostic_aec
)
;
ost
<
<
ToStringIfSet
(
"
experimental_ns
"
experimental_ns
)
;
ost
<
<
ToStringIfSet
(
"
intelligibility_enhancer
"
intelligibility_enhancer
)
;
ost
<
<
ToStringIfSet
(
"
level_control
"
level_control
)
;
ost
<
<
ToStringIfSet
(
"
level_control_initial_peak_level_dbfs
"
level_control_initial_peak_level_dbfs
)
;
ost
<
<
ToStringIfSet
(
"
residual_echo_detector
"
residual_echo_detector
)
;
ost
<
<
ToStringIfSet
(
"
tx_agc_target_dbov
"
tx_agc_target_dbov
)
;
ost
<
<
ToStringIfSet
(
"
tx_agc_digital_compression_gain
"
tx_agc_digital_compression_gain
)
;
ost
<
<
ToStringIfSet
(
"
tx_agc_limiter
"
tx_agc_limiter
)
;
ost
<
<
ToStringIfSet
(
"
combined_audio_video_bwe
"
combined_audio_video_bwe
)
;
ost
<
<
ToStringIfSet
(
"
audio_network_adaptor
"
audio_network_adaptor
)
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
rtc
:
:
Optional
<
bool
>
echo_cancellation
;
rtc
:
:
Optional
<
bool
>
auto_gain_control
;
rtc
:
:
Optional
<
bool
>
noise_suppression
;
rtc
:
:
Optional
<
bool
>
highpass_filter
;
rtc
:
:
Optional
<
bool
>
stereo_swapping
;
rtc
:
:
Optional
<
int
>
audio_jitter_buffer_max_packets
;
rtc
:
:
Optional
<
bool
>
audio_jitter_buffer_fast_accelerate
;
rtc
:
:
Optional
<
bool
>
typing_detection
;
rtc
:
:
Optional
<
bool
>
aecm_generate_comfort_noise
;
rtc
:
:
Optional
<
int
>
adjust_agc_delta
;
rtc
:
:
Optional
<
bool
>
experimental_agc
;
rtc
:
:
Optional
<
bool
>
extended_filter_aec
;
rtc
:
:
Optional
<
bool
>
delay_agnostic_aec
;
rtc
:
:
Optional
<
bool
>
experimental_ns
;
rtc
:
:
Optional
<
bool
>
intelligibility_enhancer
;
rtc
:
:
Optional
<
bool
>
level_control
;
rtc
:
:
Optional
<
float
>
level_control_initial_peak_level_dbfs
;
rtc
:
:
Optional
<
bool
>
residual_echo_detector
;
rtc
:
:
Optional
<
uint16_t
>
tx_agc_target_dbov
;
rtc
:
:
Optional
<
uint16_t
>
tx_agc_digital_compression_gain
;
rtc
:
:
Optional
<
bool
>
tx_agc_limiter
;
rtc
:
:
Optional
<
bool
>
combined_audio_video_bwe
;
rtc
:
:
Optional
<
bool
>
audio_network_adaptor
;
rtc
:
:
Optional
<
std
:
:
string
>
audio_network_adaptor_config
;
private
:
template
<
typename
T
>
static
void
SetFrom
(
rtc
:
:
Optional
<
T
>
*
s
const
rtc
:
:
Optional
<
T
>
&
o
)
{
if
(
o
)
{
*
s
=
o
;
}
}
}
;
struct
VideoOptions
{
void
SetAll
(
const
VideoOptions
&
change
)
{
SetFrom
(
&
video_noise_reduction
change
.
video_noise_reduction
)
;
SetFrom
(
&
screencast_min_bitrate_kbps
change
.
screencast_min_bitrate_kbps
)
;
SetFrom
(
&
is_screencast
change
.
is_screencast
)
;
}
bool
operator
=
=
(
const
VideoOptions
&
o
)
const
{
return
video_noise_reduction
=
=
o
.
video_noise_reduction
&
&
screencast_min_bitrate_kbps
=
=
o
.
screencast_min_bitrate_kbps
&
&
is_screencast
=
=
o
.
is_screencast
;
}
bool
operator
!
=
(
const
VideoOptions
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
std
:
:
string
ToString
(
)
const
{
std
:
:
ostringstream
ost
;
ost
<
<
"
VideoOptions
{
"
;
ost
<
<
ToStringIfSet
(
"
noise
reduction
"
video_noise_reduction
)
;
ost
<
<
ToStringIfSet
(
"
screencast
min
bitrate
kbps
"
screencast_min_bitrate_kbps
)
;
ost
<
<
ToStringIfSet
(
"
is_screencast
"
is_screencast
)
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
rtc
:
:
Optional
<
bool
>
video_noise_reduction
;
rtc
:
:
Optional
<
int
>
screencast_min_bitrate_kbps
;
rtc
:
:
Optional
<
bool
>
is_screencast
;
private
:
template
<
typename
T
>
static
void
SetFrom
(
rtc
:
:
Optional
<
T
>
*
s
const
rtc
:
:
Optional
<
T
>
&
o
)
{
if
(
o
)
{
*
s
=
o
;
}
}
}
;
struct
RtpHeaderExtension
{
RtpHeaderExtension
(
)
:
id
(
0
)
{
}
RtpHeaderExtension
(
const
std
:
:
string
&
uri
int
id
)
:
uri
(
uri
)
id
(
id
)
{
}
std
:
:
string
ToString
(
)
const
{
std
:
:
ostringstream
ost
;
ost
<
<
"
{
"
;
ost
<
<
"
uri
:
"
<
<
uri
;
ost
<
<
"
id
:
"
<
<
id
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
std
:
:
string
uri
;
int
id
;
}
;
class
MediaChannel
:
public
sigslot
:
:
has_slots
<
>
{
public
:
class
NetworkInterface
{
public
:
enum
SocketType
{
ST_RTP
ST_RTCP
}
;
virtual
bool
SendPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
=
0
;
virtual
bool
SendRtcp
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
=
0
;
virtual
int
SetOption
(
SocketType
type
rtc
:
:
Socket
:
:
Option
opt
int
option
)
=
0
;
virtual
~
NetworkInterface
(
)
{
}
}
;
explicit
MediaChannel
(
const
MediaConfig
&
config
)
:
enable_dscp_
(
config
.
enable_dscp
)
network_interface_
(
NULL
)
{
}
MediaChannel
(
)
:
enable_dscp_
(
false
)
network_interface_
(
NULL
)
{
}
virtual
~
MediaChannel
(
)
{
}
virtual
void
SetInterface
(
NetworkInterface
*
iface
)
{
rtc
:
:
CritScope
cs
(
&
network_interface_crit_
)
;
network_interface_
=
iface
;
SetDscp
(
enable_dscp_
?
PreferredDscp
(
)
:
rtc
:
:
DSCP_DEFAULT
)
;
}
virtual
rtc
:
:
DiffServCodePoint
PreferredDscp
(
)
const
{
return
rtc
:
:
DSCP_DEFAULT
;
}
virtual
void
OnPacketReceived
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketTime
&
packet_time
)
=
0
;
virtual
void
OnRtcpReceived
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketTime
&
packet_time
)
=
0
;
virtual
void
OnReadyToSend
(
bool
ready
)
=
0
;
virtual
void
OnNetworkRouteChanged
(
const
std
:
:
string
&
transport_name
const
rtc
:
:
NetworkRoute
&
network_route
)
=
0
;
virtual
bool
AddSendStream
(
const
StreamParams
&
sp
)
=
0
;
virtual
bool
RemoveSendStream
(
uint32_t
ssrc
)
=
0
;
virtual
bool
AddRecvStream
(
const
StreamParams
&
sp
)
=
0
;
virtual
bool
RemoveRecvStream
(
uint32_t
ssrc
)
=
0
;
virtual
int
GetRtpSendTimeExtnId
(
)
const
{
return
-
1
;
}
bool
SendPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
{
return
DoSendPacket
(
packet
false
options
)
;
}
bool
SendRtcp
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
{
return
DoSendPacket
(
packet
true
options
)
;
}
int
SetOption
(
NetworkInterface
:
:
SocketType
type
rtc
:
:
Socket
:
:
Option
opt
int
option
)
{
rtc
:
:
CritScope
cs
(
&
network_interface_crit_
)
;
if
(
!
network_interface_
)
return
-
1
;
return
network_interface_
-
>
SetOption
(
type
opt
option
)
;
}
private
:
int
SetDscp
(
rtc
:
:
DiffServCodePoint
value
)
{
int
ret
;
ret
=
SetOption
(
NetworkInterface
:
:
ST_RTP
rtc
:
:
Socket
:
:
OPT_DSCP
value
)
;
if
(
ret
=
=
0
)
{
ret
=
SetOption
(
NetworkInterface
:
:
ST_RTCP
rtc
:
:
Socket
:
:
OPT_DSCP
value
)
;
}
return
ret
;
}
bool
DoSendPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
bool
rtcp
const
rtc
:
:
PacketOptions
&
options
)
{
rtc
:
:
CritScope
cs
(
&
network_interface_crit_
)
;
if
(
!
network_interface_
)
return
false
;
return
(
!
rtcp
)
?
network_interface_
-
>
SendPacket
(
packet
options
)
:
network_interface_
-
>
SendRtcp
(
packet
options
)
;
}
const
bool
enable_dscp_
;
rtc
:
:
CriticalSection
network_interface_crit_
;
NetworkInterface
*
network_interface_
;
}
;
struct
SsrcSenderInfo
{
SsrcSenderInfo
(
)
:
ssrc
(
0
)
timestamp
(
0
)
{
}
uint32_t
ssrc
;
double
timestamp
;
}
;
struct
SsrcReceiverInfo
{
SsrcReceiverInfo
(
)
:
ssrc
(
0
)
timestamp
(
0
)
{
}
uint32_t
ssrc
;
double
timestamp
;
}
;
struct
MediaSenderInfo
{
MediaSenderInfo
(
)
:
bytes_sent
(
0
)
packets_sent
(
0
)
packets_lost
(
0
)
fraction_lost
(
0
.
0
)
rtt_ms
(
0
)
{
}
void
add_ssrc
(
const
SsrcSenderInfo
&
stat
)
{
local_stats
.
push_back
(
stat
)
;
}
void
add_ssrc
(
uint32_t
ssrc
)
{
SsrcSenderInfo
stat
;
stat
.
ssrc
=
ssrc
;
add_ssrc
(
stat
)
;
}
std
:
:
vector
<
uint32_t
>
ssrcs
(
)
const
{
std
:
:
vector
<
uint32_t
>
retval
;
for
(
std
:
:
vector
<
SsrcSenderInfo
>
:
:
const_iterator
it
=
local_stats
.
begin
(
)
;
it
!
=
local_stats
.
end
(
)
;
+
+
it
)
{
retval
.
push_back
(
it
-
>
ssrc
)
;
}
return
retval
;
}
uint32_t
ssrc
(
)
const
{
if
(
local_stats
.
size
(
)
>
0
)
{
return
local_stats
[
0
]
.
ssrc
;
}
else
{
return
0
;
}
}
int64_t
bytes_sent
;
int
packets_sent
;
int
packets_lost
;
float
fraction_lost
;
int64_t
rtt_ms
;
std
:
:
string
codec_name
;
rtc
:
:
Optional
<
int
>
codec_payload_type
;
std
:
:
vector
<
SsrcSenderInfo
>
local_stats
;
std
:
:
vector
<
SsrcReceiverInfo
>
remote_stats
;
}
;
struct
MediaReceiverInfo
{
MediaReceiverInfo
(
)
:
bytes_rcvd
(
0
)
packets_rcvd
(
0
)
packets_lost
(
0
)
fraction_lost
(
0
.
0
)
{
}
void
add_ssrc
(
const
SsrcReceiverInfo
&
stat
)
{
local_stats
.
push_back
(
stat
)
;
}
void
add_ssrc
(
uint32_t
ssrc
)
{
SsrcReceiverInfo
stat
;
stat
.
ssrc
=
ssrc
;
add_ssrc
(
stat
)
;
}
std
:
:
vector
<
uint32_t
>
ssrcs
(
)
const
{
std
:
:
vector
<
uint32_t
>
retval
;
for
(
std
:
:
vector
<
SsrcReceiverInfo
>
:
:
const_iterator
it
=
local_stats
.
begin
(
)
;
it
!
=
local_stats
.
end
(
)
;
+
+
it
)
{
retval
.
push_back
(
it
-
>
ssrc
)
;
}
return
retval
;
}
uint32_t
ssrc
(
)
const
{
if
(
local_stats
.
size
(
)
>
0
)
{
return
local_stats
[
0
]
.
ssrc
;
}
else
{
return
0
;
}
}
int64_t
bytes_rcvd
;
int
packets_rcvd
;
int
packets_lost
;
float
fraction_lost
;
std
:
:
string
codec_name
;
rtc
:
:
Optional
<
int
>
codec_payload_type
;
std
:
:
vector
<
SsrcReceiverInfo
>
local_stats
;
std
:
:
vector
<
SsrcSenderInfo
>
remote_stats
;
}
;
struct
VoiceSenderInfo
:
public
MediaSenderInfo
{
VoiceSenderInfo
(
)
:
ext_seqnum
(
0
)
jitter_ms
(
0
)
audio_level
(
0
)
total_input_energy
(
0
.
0
)
total_input_duration
(
0
.
0
)
aec_quality_min
(
0
.
0
)
echo_delay_median_ms
(
0
)
echo_delay_std_ms
(
0
)
echo_return_loss
(
0
)
echo_return_loss_enhancement
(
0
)
residual_echo_likelihood
(
0
.
0f
)
residual_echo_likelihood_recent_max
(
0
.
0f
)
typing_noise_detected
(
false
)
{
}
int
ext_seqnum
;
int
jitter_ms
;
int
audio_level
;
double
total_input_energy
;
double
total_input_duration
;
float
aec_quality_min
;
int
echo_delay_median_ms
;
int
echo_delay_std_ms
;
int
echo_return_loss
;
int
echo_return_loss_enhancement
;
float
residual_echo_likelihood
;
float
residual_echo_likelihood_recent_max
;
bool
typing_noise_detected
;
webrtc
:
:
ANAStats
ana_statistics
;
webrtc
:
:
AudioProcessingStats
apm_statistics
;
}
;
struct
VoiceReceiverInfo
:
public
MediaReceiverInfo
{
VoiceReceiverInfo
(
)
:
ext_seqnum
(
0
)
jitter_ms
(
0
)
jitter_buffer_ms
(
0
)
jitter_buffer_preferred_ms
(
0
)
delay_estimate_ms
(
0
)
audio_level
(
0
)
total_output_energy
(
0
.
0
)
total_samples_received
(
0
)
total_output_duration
(
0
.
0
)
concealed_samples
(
0
)
concealment_events
(
0
)
jitter_buffer_delay_seconds
(
0
)
expand_rate
(
0
)
speech_expand_rate
(
0
)
secondary_decoded_rate
(
0
)
secondary_discarded_rate
(
0
)
accelerate_rate
(
0
)
preemptive_expand_rate
(
0
)
decoding_calls_to_silence_generator
(
0
)
decoding_calls_to_neteq
(
0
)
decoding_normal
(
0
)
decoding_plc
(
0
)
decoding_cng
(
0
)
decoding_plc_cng
(
0
)
decoding_muted_output
(
0
)
capture_start_ntp_time_ms
(
-
1
)
{
}
int
ext_seqnum
;
int
jitter_ms
;
int
jitter_buffer_ms
;
int
jitter_buffer_preferred_ms
;
int
delay_estimate_ms
;
int
audio_level
;
double
total_output_energy
;
uint64_t
total_samples_received
;
double
total_output_duration
;
uint64_t
concealed_samples
;
uint64_t
concealment_events
;
double
jitter_buffer_delay_seconds
;
float
expand_rate
;
float
speech_expand_rate
;
float
secondary_decoded_rate
;
float
secondary_discarded_rate
;
float
accelerate_rate
;
float
preemptive_expand_rate
;
int
decoding_calls_to_silence_generator
;
int
decoding_calls_to_neteq
;
int
decoding_normal
;
int
decoding_plc
;
int
decoding_cng
;
int
decoding_plc_cng
;
int
decoding_muted_output
;
int64_t
capture_start_ntp_time_ms
;
}
;
struct
VideoSenderInfo
:
public
MediaSenderInfo
{
VideoSenderInfo
(
)
:
packets_cached
(
0
)
firs_rcvd
(
0
)
plis_rcvd
(
0
)
nacks_rcvd
(
0
)
send_frame_width
(
0
)
send_frame_height
(
0
)
framerate_input
(
0
)
framerate_sent
(
0
)
nominal_bitrate
(
0
)
preferred_bitrate
(
0
)
adapt_reason
(
0
)
adapt_changes
(
0
)
avg_encode_ms
(
0
)
encode_usage_percent
(
0
)
frames_encoded
(
0
)
has_entered_low_resolution
(
false
)
content_type
(
webrtc
:
:
VideoContentType
:
:
UNSPECIFIED
)
{
}
std
:
:
vector
<
SsrcGroup
>
ssrc_groups
;
std
:
:
string
encoder_implementation_name
;
int
packets_cached
;
int
firs_rcvd
;
int
plis_rcvd
;
int
nacks_rcvd
;
int
send_frame_width
;
int
send_frame_height
;
int
framerate_input
;
int
framerate_sent
;
int
nominal_bitrate
;
int
preferred_bitrate
;
int
adapt_reason
;
int
adapt_changes
;
int
avg_encode_ms
;
int
encode_usage_percent
;
uint32_t
frames_encoded
;
bool
has_entered_low_resolution
;
rtc
:
:
Optional
<
uint64_t
>
qp_sum
;
webrtc
:
:
VideoContentType
content_type
;
}
;
struct
VideoReceiverInfo
:
public
MediaReceiverInfo
{
VideoReceiverInfo
(
)
:
packets_concealed
(
0
)
firs_sent
(
0
)
plis_sent
(
0
)
nacks_sent
(
0
)
frame_width
(
0
)
frame_height
(
0
)
framerate_rcvd
(
0
)
framerate_decoded
(
0
)
framerate_output
(
0
)
framerate_render_input
(
0
)
framerate_render_output
(
0
)
frames_received
(
0
)
frames_decoded
(
0
)
frames_rendered
(
0
)
interframe_delay_max_ms
(
-
1
)
content_type
(
webrtc
:
:
VideoContentType
:
:
UNSPECIFIED
)
decode_ms
(
0
)
max_decode_ms
(
0
)
jitter_buffer_ms
(
0
)
min_playout_delay_ms
(
0
)
render_delay_ms
(
0
)
target_delay_ms
(
0
)
current_delay_ms
(
0
)
capture_start_ntp_time_ms
(
-
1
)
{
}
std
:
:
vector
<
SsrcGroup
>
ssrc_groups
;
std
:
:
string
decoder_implementation_name
;
int
packets_concealed
;
int
firs_sent
;
int
plis_sent
;
int
nacks_sent
;
int
frame_width
;
int
frame_height
;
int
framerate_rcvd
;
int
framerate_decoded
;
int
framerate_output
;
int
framerate_render_input
;
int
framerate_render_output
;
uint32_t
frames_received
;
uint32_t
frames_decoded
;
uint32_t
frames_rendered
;
rtc
:
:
Optional
<
uint64_t
>
qp_sum
;
int64_t
interframe_delay_max_ms
;
webrtc
:
:
VideoContentType
content_type
;
int
decode_ms
;
int
max_decode_ms
;
int
jitter_buffer_ms
;
int
min_playout_delay_ms
;
int
render_delay_ms
;
int
target_delay_ms
;
int
current_delay_ms
;
int64_t
capture_start_ntp_time_ms
;
rtc
:
:
Optional
<
webrtc
:
:
TimingFrameInfo
>
timing_frame_info
;
}
;
struct
DataSenderInfo
:
public
MediaSenderInfo
{
DataSenderInfo
(
)
:
ssrc
(
0
)
{
}
uint32_t
ssrc
;
}
;
struct
DataReceiverInfo
:
public
MediaReceiverInfo
{
DataReceiverInfo
(
)
:
ssrc
(
0
)
{
}
uint32_t
ssrc
;
}
;
struct
BandwidthEstimationInfo
{
BandwidthEstimationInfo
(
)
:
available_send_bandwidth
(
0
)
available_recv_bandwidth
(
0
)
target_enc_bitrate
(
0
)
actual_enc_bitrate
(
0
)
retransmit_bitrate
(
0
)
transmit_bitrate
(
0
)
bucket_delay
(
0
)
{
}
int
available_send_bandwidth
;
int
available_recv_bandwidth
;
int
target_enc_bitrate
;
int
actual_enc_bitrate
;
int
retransmit_bitrate
;
int
transmit_bitrate
;
int64_t
bucket_delay
;
}
;
typedef
std
:
:
map
<
int
webrtc
:
:
RtpCodecParameters
>
RtpCodecParametersMap
;
struct
VoiceMediaInfo
{
void
Clear
(
)
{
senders
.
clear
(
)
;
receivers
.
clear
(
)
;
send_codecs
.
clear
(
)
;
receive_codecs
.
clear
(
)
;
}
std
:
:
vector
<
VoiceSenderInfo
>
senders
;
std
:
:
vector
<
VoiceReceiverInfo
>
receivers
;
RtpCodecParametersMap
send_codecs
;
RtpCodecParametersMap
receive_codecs
;
}
;
struct
VideoMediaInfo
{
void
Clear
(
)
{
senders
.
clear
(
)
;
receivers
.
clear
(
)
;
bw_estimations
.
clear
(
)
;
send_codecs
.
clear
(
)
;
receive_codecs
.
clear
(
)
;
}
std
:
:
vector
<
VideoSenderInfo
>
senders
;
std
:
:
vector
<
VideoReceiverInfo
>
receivers
;
std
:
:
vector
<
BandwidthEstimationInfo
>
bw_estimations
;
RtpCodecParametersMap
send_codecs
;
RtpCodecParametersMap
receive_codecs
;
}
;
struct
DataMediaInfo
{
void
Clear
(
)
{
senders
.
clear
(
)
;
receivers
.
clear
(
)
;
}
std
:
:
vector
<
DataSenderInfo
>
senders
;
std
:
:
vector
<
DataReceiverInfo
>
receivers
;
}
;
struct
RtcpParameters
{
bool
reduced_size
=
false
;
}
;
template
<
class
Codec
>
struct
RtpParameters
{
virtual
std
:
:
string
ToString
(
)
const
{
std
:
:
ostringstream
ost
;
ost
<
<
"
{
"
;
ost
<
<
"
codecs
:
"
<
<
VectorToString
(
codecs
)
<
<
"
"
;
ost
<
<
"
extensions
:
"
<
<
VectorToString
(
extensions
)
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
std
:
:
vector
<
Codec
>
codecs
;
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extensions
;
RtcpParameters
rtcp
;
virtual
~
RtpParameters
(
)
=
default
;
}
;
template
<
class
Codec
>
struct
RtpSendParameters
:
RtpParameters
<
Codec
>
{
std
:
:
string
ToString
(
)
const
override
{
std
:
:
ostringstream
ost
;
ost
<
<
"
{
"
;
ost
<
<
"
codecs
:
"
<
<
VectorToString
(
this
-
>
codecs
)
<
<
"
"
;
ost
<
<
"
extensions
:
"
<
<
VectorToString
(
this
-
>
extensions
)
<
<
"
"
;
ost
<
<
"
max_bandwidth_bps
:
"
<
<
max_bandwidth_bps
<
<
"
"
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
int
max_bandwidth_bps
=
-
1
;
}
;
struct
AudioSendParameters
:
RtpSendParameters
<
AudioCodec
>
{
std
:
:
string
ToString
(
)
const
override
{
std
:
:
ostringstream
ost
;
ost
<
<
"
{
"
;
ost
<
<
"
codecs
:
"
<
<
VectorToString
(
this
-
>
codecs
)
<
<
"
"
;
ost
<
<
"
extensions
:
"
<
<
VectorToString
(
this
-
>
extensions
)
<
<
"
"
;
ost
<
<
"
max_bandwidth_bps
:
"
<
<
max_bandwidth_bps
<
<
"
"
;
ost
<
<
"
options
:
"
<
<
options
.
ToString
(
)
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
AudioOptions
options
;
}
;
struct
AudioRecvParameters
:
RtpParameters
<
AudioCodec
>
{
}
;
class
VoiceMediaChannel
:
public
MediaChannel
{
public
:
enum
Error
{
ERROR_NONE
=
0
ERROR_OTHER
ERROR_REC_DEVICE_OPEN_FAILED
=
100
ERROR_REC_DEVICE_MUTED
ERROR_REC_DEVICE_SILENT
ERROR_REC_DEVICE_SATURATION
ERROR_REC_DEVICE_REMOVED
ERROR_REC_RUNTIME_ERROR
ERROR_REC_SRTP_ERROR
ERROR_REC_SRTP_AUTH_FAILED
ERROR_REC_TYPING_NOISE_DETECTED
ERROR_PLAY_DEVICE_OPEN_FAILED
=
200
ERROR_PLAY_DEVICE_MUTED
ERROR_PLAY_DEVICE_REMOVED
ERROR_PLAY_RUNTIME_ERROR
ERROR_PLAY_SRTP_ERROR
ERROR_PLAY_SRTP_AUTH_FAILED
ERROR_PLAY_SRTP_REPLAY
}
;
VoiceMediaChannel
(
)
{
}
explicit
VoiceMediaChannel
(
const
MediaConfig
&
config
)
:
MediaChannel
(
config
)
{
}
virtual
~
VoiceMediaChannel
(
)
{
}
virtual
bool
SetSendParameters
(
const
AudioSendParameters
&
params
)
=
0
;
virtual
bool
SetRecvParameters
(
const
AudioRecvParameters
&
params
)
=
0
;
virtual
webrtc
:
:
RtpParameters
GetRtpSendParameters
(
uint32_t
ssrc
)
const
=
0
;
virtual
bool
SetRtpSendParameters
(
uint32_t
ssrc
const
webrtc
:
:
RtpParameters
&
parameters
)
=
0
;
virtual
webrtc
:
:
RtpParameters
GetRtpReceiveParameters
(
uint32_t
ssrc
)
const
=
0
;
virtual
bool
SetRtpReceiveParameters
(
uint32_t
ssrc
const
webrtc
:
:
RtpParameters
&
parameters
)
=
0
;
virtual
void
SetPlayout
(
bool
playout
)
=
0
;
virtual
void
SetSend
(
bool
send
)
=
0
;
virtual
bool
SetAudioSend
(
uint32_t
ssrc
bool
enable
const
AudioOptions
*
options
AudioSource
*
source
)
=
0
;
typedef
std
:
:
vector
<
std
:
:
pair
<
uint32_t
int
>
>
StreamList
;
virtual
bool
GetActiveStreams
(
StreamList
*
actives
)
=
0
;
virtual
int
GetOutputLevel
(
)
=
0
;
virtual
bool
SetOutputVolume
(
uint32_t
ssrc
double
volume
)
=
0
;
virtual
bool
CanInsertDtmf
(
)
=
0
;
virtual
bool
InsertDtmf
(
uint32_t
ssrc
int
event
int
duration
)
=
0
;
virtual
bool
GetStats
(
VoiceMediaInfo
*
info
)
=
0
;
virtual
void
SetRawAudioSink
(
uint32_t
ssrc
std
:
:
unique_ptr
<
webrtc
:
:
AudioSinkInterface
>
sink
)
=
0
;
virtual
std
:
:
vector
<
webrtc
:
:
RtpSource
>
GetSources
(
uint32_t
ssrc
)
const
=
0
;
}
;
struct
VideoSendParameters
:
RtpSendParameters
<
VideoCodec
>
{
bool
conference_mode
=
false
;
}
;
struct
VideoRecvParameters
:
RtpParameters
<
VideoCodec
>
{
}
;
class
VideoMediaChannel
:
public
MediaChannel
{
public
:
enum
Error
{
ERROR_NONE
=
0
ERROR_OTHER
ERROR_REC_DEVICE_OPEN_FAILED
=
100
ERROR_REC_DEVICE_NO_DEVICE
ERROR_REC_DEVICE_IN_USE
ERROR_REC_DEVICE_REMOVED
ERROR_REC_SRTP_ERROR
ERROR_REC_SRTP_AUTH_FAILED
ERROR_REC_CPU_MAX_CANT_DOWNGRADE
ERROR_PLAY_SRTP_ERROR
=
200
ERROR_PLAY_SRTP_AUTH_FAILED
ERROR_PLAY_SRTP_REPLAY
}
;
VideoMediaChannel
(
)
{
}
explicit
VideoMediaChannel
(
const
MediaConfig
&
config
)
:
MediaChannel
(
config
)
{
}
virtual
~
VideoMediaChannel
(
)
{
}
virtual
bool
SetSendParameters
(
const
VideoSendParameters
&
params
)
=
0
;
virtual
bool
SetRecvParameters
(
const
VideoRecvParameters
&
params
)
=
0
;
virtual
webrtc
:
:
RtpParameters
GetRtpSendParameters
(
uint32_t
ssrc
)
const
=
0
;
virtual
bool
SetRtpSendParameters
(
uint32_t
ssrc
const
webrtc
:
:
RtpParameters
&
parameters
)
=
0
;
virtual
webrtc
:
:
RtpParameters
GetRtpReceiveParameters
(
uint32_t
ssrc
)
const
=
0
;
virtual
bool
SetRtpReceiveParameters
(
uint32_t
ssrc
const
webrtc
:
:
RtpParameters
&
parameters
)
=
0
;
virtual
bool
GetSendCodec
(
VideoCodec
*
send_codec
)
=
0
;
virtual
bool
SetSend
(
bool
send
)
=
0
;
virtual
bool
SetVideoSend
(
uint32_t
ssrc
bool
enable
const
VideoOptions
*
options
rtc
:
:
VideoSourceInterface
<
webrtc
:
:
VideoFrame
>
*
source
)
=
0
;
virtual
bool
SetSink
(
uint32_t
ssrc
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
)
=
0
;
virtual
void
FillBitrateInfo
(
BandwidthEstimationInfo
*
bwe_info
)
=
0
;
virtual
bool
GetStats
(
VideoMediaInfo
*
info
)
=
0
;
}
;
enum
DataMessageType
{
DMT_NONE
=
0
DMT_CONTROL
=
1
DMT_BINARY
=
2
DMT_TEXT
=
3
}
;
struct
ReceiveDataParams
{
union
{
uint32_t
ssrc
;
int
sid
;
}
;
DataMessageType
type
;
int
seq_num
;
int
timestamp
;
ReceiveDataParams
(
)
:
sid
(
0
)
type
(
DMT_TEXT
)
seq_num
(
0
)
timestamp
(
0
)
{
}
}
;
struct
SendDataParams
{
union
{
uint32_t
ssrc
;
int
sid
;
}
;
DataMessageType
type
;
bool
ordered
;
bool
reliable
;
int
max_rtx_count
;
int
max_rtx_ms
;
SendDataParams
(
)
:
sid
(
0
)
type
(
DMT_TEXT
)
ordered
(
false
)
reliable
(
false
)
max_rtx_count
(
0
)
max_rtx_ms
(
0
)
{
}
}
;
enum
SendDataResult
{
SDR_SUCCESS
SDR_ERROR
SDR_BLOCK
}
;
struct
DataSendParameters
:
RtpSendParameters
<
DataCodec
>
{
std
:
:
string
ToString
(
)
const
{
std
:
:
ostringstream
ost
;
ost
<
<
"
{
"
;
ost
<
<
"
codecs
:
"
<
<
VectorToString
(
codecs
)
<
<
"
"
;
ost
<
<
"
max_bandwidth_bps
:
"
<
<
max_bandwidth_bps
;
ost
<
<
"
}
"
;
return
ost
.
str
(
)
;
}
}
;
struct
DataRecvParameters
:
RtpParameters
<
DataCodec
>
{
}
;
class
DataMediaChannel
:
public
MediaChannel
{
public
:
enum
Error
{
ERROR_NONE
=
0
ERROR_OTHER
ERROR_SEND_SRTP_ERROR
=
200
ERROR_SEND_SRTP_AUTH_FAILED
ERROR_RECV_SRTP_ERROR
ERROR_RECV_SRTP_AUTH_FAILED
ERROR_RECV_SRTP_REPLAY
}
;
DataMediaChannel
(
)
{
}
explicit
DataMediaChannel
(
const
MediaConfig
&
config
)
:
MediaChannel
(
config
)
{
}
virtual
~
DataMediaChannel
(
)
{
}
virtual
bool
SetSendParameters
(
const
DataSendParameters
&
params
)
=
0
;
virtual
bool
SetRecvParameters
(
const
DataRecvParameters
&
params
)
=
0
;
virtual
bool
GetStats
(
DataMediaInfo
*
info
)
{
return
true
;
}
virtual
bool
SetSend
(
bool
send
)
=
0
;
virtual
bool
SetReceive
(
bool
receive
)
=
0
;
virtual
void
OnNetworkRouteChanged
(
const
std
:
:
string
&
transport_name
const
rtc
:
:
NetworkRoute
&
network_route
)
{
}
virtual
bool
SendData
(
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
SendDataResult
*
result
=
NULL
)
=
0
;
sigslot
:
:
signal3
<
const
ReceiveDataParams
&
const
char
*
size_t
>
SignalDataReceived
;
sigslot
:
:
signal1
<
bool
>
SignalReadyToSend
;
}
;
}
#
endif
