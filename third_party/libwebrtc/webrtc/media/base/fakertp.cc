#
include
<
algorithm
>
#
include
"
media
/
base
/
fakertp
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
void
CompareHeaderExtensions
(
const
char
*
packet1
size_t
packet1_size
const
char
*
packet2
size_t
packet2_size
const
std
:
:
vector
<
int
>
encrypted_headers
bool
expect_equal
)
{
RTC_CHECK_GE
(
packet1_size
12
+
4
)
;
RTC_CHECK_GE
(
packet2_size
12
+
4
)
;
EXPECT_EQ
(
0
memcmp
(
packet1
+
12
packet2
+
12
4
)
)
;
EXPECT_EQ
(
'
\
xBE
'
packet1
[
12
]
)
;
EXPECT_EQ
(
'
\
xDE
'
packet1
[
13
]
)
;
size_t
extension_words
=
packet1
[
14
]
<
<
8
|
packet1
[
15
]
;
const
char
*
extension_data1
=
packet1
+
12
+
4
;
const
char
*
extension_end1
=
extension_data1
+
extension_words
*
4
;
const
char
*
extension_data2
=
packet2
+
12
+
4
;
RTC_CHECK_GE
(
packet1_size
12
+
4
+
extension_words
*
4
)
;
RTC_CHECK_GE
(
packet2_size
12
+
4
+
extension_words
*
4
)
;
while
(
extension_data1
<
extension_end1
)
{
uint8_t
id
=
(
*
extension_data1
&
0xf0
)
>
>
4
;
uint8_t
len
=
(
*
extension_data1
&
0x0f
)
+
1
;
extension_data1
+
+
;
extension_data2
+
+
;
EXPECT_LE
(
extension_data1
extension_end1
)
;
if
(
id
=
=
15
)
{
break
;
}
if
(
expect_equal
|
|
std
:
:
find
(
encrypted_headers
.
begin
(
)
encrypted_headers
.
end
(
)
id
)
=
=
encrypted_headers
.
end
(
)
)
{
EXPECT_EQ
(
0
memcmp
(
extension_data1
extension_data2
len
)
)
;
}
else
{
EXPECT_NE
(
0
memcmp
(
extension_data1
extension_data2
len
)
)
;
}
extension_data1
+
=
len
;
extension_data2
+
=
len
;
while
(
extension_data1
<
extension_end1
&
&
*
extension_data1
=
=
0
)
{
extension_data1
+
+
;
extension_data2
+
+
;
}
}
}
