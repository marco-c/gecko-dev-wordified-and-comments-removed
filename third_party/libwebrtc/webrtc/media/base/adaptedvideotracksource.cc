#
include
"
media
/
base
/
adaptedvideotracksource
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
namespace
rtc
{
AdaptedVideoTrackSource
:
:
AdaptedVideoTrackSource
(
)
{
thread_checker_
.
DetachFromThread
(
)
;
}
AdaptedVideoTrackSource
:
:
AdaptedVideoTrackSource
(
int
required_alignment
)
:
video_adapter_
(
required_alignment
)
{
thread_checker_
.
DetachFromThread
(
)
;
}
bool
AdaptedVideoTrackSource
:
:
GetStats
(
Stats
*
stats
)
{
rtc
:
:
CritScope
lock
(
&
stats_crit_
)
;
if
(
!
stats_
)
{
return
false
;
}
*
stats
=
*
stats_
;
return
true
;
}
void
AdaptedVideoTrackSource
:
:
OnFrame
(
const
webrtc
:
:
VideoFrame
&
frame
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
buffer
(
frame
.
video_frame_buffer
(
)
)
;
if
(
apply_rotation
(
)
&
&
frame
.
rotation
(
)
!
=
webrtc
:
:
kVideoRotation_0
&
&
buffer
-
>
type
(
)
=
=
webrtc
:
:
VideoFrameBuffer
:
:
Type
:
:
kI420
)
{
broadcaster_
.
OnFrame
(
webrtc
:
:
VideoFrame
(
webrtc
:
:
I420Buffer
:
:
Rotate
(
*
buffer
-
>
GetI420
(
)
frame
.
rotation
(
)
)
webrtc
:
:
kVideoRotation_0
frame
.
timestamp_us
(
)
)
)
;
}
else
{
broadcaster_
.
OnFrame
(
frame
)
;
}
}
void
AdaptedVideoTrackSource
:
:
AddOrUpdateSink
(
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
const
rtc
:
:
VideoSinkWants
&
wants
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
broadcaster_
.
AddOrUpdateSink
(
sink
wants
)
;
OnSinkWantsChanged
(
broadcaster_
.
wants
(
)
)
;
}
void
AdaptedVideoTrackSource
:
:
RemoveSink
(
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
broadcaster_
.
RemoveSink
(
sink
)
;
OnSinkWantsChanged
(
broadcaster_
.
wants
(
)
)
;
}
bool
AdaptedVideoTrackSource
:
:
apply_rotation
(
)
{
return
broadcaster_
.
wants
(
)
.
rotation_applied
;
}
void
AdaptedVideoTrackSource
:
:
OnSinkWantsChanged
(
const
rtc
:
:
VideoSinkWants
&
wants
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
video_adapter_
.
OnResolutionFramerateRequest
(
wants
.
target_pixel_count
wants
.
max_pixel_count
wants
.
max_framerate_fps
)
;
}
bool
AdaptedVideoTrackSource
:
:
AdaptFrame
(
int
width
int
height
int64_t
time_us
int
*
out_width
int
*
out_height
int
*
crop_width
int
*
crop_height
int
*
crop_x
int
*
crop_y
)
{
{
rtc
:
:
CritScope
lock
(
&
stats_crit_
)
;
stats_
=
Stats
{
width
height
}
;
}
if
(
!
broadcaster_
.
frame_wanted
(
)
)
{
return
false
;
}
if
(
!
video_adapter_
.
AdaptFrameResolution
(
width
height
time_us
*
rtc
:
:
kNumNanosecsPerMicrosec
crop_width
crop_height
out_width
out_height
)
)
{
broadcaster_
.
OnDiscardedFrame
(
)
;
return
false
;
}
*
crop_x
=
(
width
-
*
crop_width
)
/
2
;
*
crop_y
=
(
height
-
*
crop_height
)
/
2
;
return
true
;
}
}
