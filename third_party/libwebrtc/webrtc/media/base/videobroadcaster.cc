#
include
"
media
/
base
/
videobroadcaster
.
h
"
#
include
<
limits
>
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
rtc
{
VideoBroadcaster
:
:
VideoBroadcaster
(
)
{
thread_checker_
.
DetachFromThread
(
)
;
}
void
VideoBroadcaster
:
:
AddOrUpdateSink
(
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
const
VideoSinkWants
&
wants
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
sink
!
=
nullptr
)
;
rtc
:
:
CritScope
cs
(
&
sinks_and_wants_lock_
)
;
VideoSourceBase
:
:
AddOrUpdateSink
(
sink
wants
)
;
UpdateWants
(
)
;
}
void
VideoBroadcaster
:
:
RemoveSink
(
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
sink
!
=
nullptr
)
;
rtc
:
:
CritScope
cs
(
&
sinks_and_wants_lock_
)
;
VideoSourceBase
:
:
RemoveSink
(
sink
)
;
UpdateWants
(
)
;
}
bool
VideoBroadcaster
:
:
frame_wanted
(
)
const
{
rtc
:
:
CritScope
cs
(
&
sinks_and_wants_lock_
)
;
return
!
sink_pairs
(
)
.
empty
(
)
;
}
VideoSinkWants
VideoBroadcaster
:
:
wants
(
)
const
{
rtc
:
:
CritScope
cs
(
&
sinks_and_wants_lock_
)
;
return
current_wants_
;
}
void
VideoBroadcaster
:
:
OnFrame
(
const
webrtc
:
:
VideoFrame
&
frame
)
{
rtc
:
:
CritScope
cs
(
&
sinks_and_wants_lock_
)
;
for
(
auto
&
sink_pair
:
sink_pairs
(
)
)
{
if
(
sink_pair
.
wants
.
rotation_applied
&
&
frame
.
rotation
(
)
!
=
webrtc
:
:
kVideoRotation_0
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Discarding
frame
with
unexpected
rotation
.
"
;
continue
;
}
if
(
sink_pair
.
wants
.
black_frames
)
{
sink_pair
.
sink
-
>
OnFrame
(
webrtc
:
:
VideoFrame
(
GetBlackFrameBuffer
(
frame
.
width
(
)
frame
.
height
(
)
)
frame
.
rotation
(
)
frame
.
timestamp_us
(
)
)
)
;
}
else
{
sink_pair
.
sink
-
>
OnFrame
(
frame
)
;
}
}
}
void
VideoBroadcaster
:
:
OnDiscardedFrame
(
)
{
for
(
auto
&
sink_pair
:
sink_pairs
(
)
)
{
sink_pair
.
sink
-
>
OnDiscardedFrame
(
)
;
}
}
void
VideoBroadcaster
:
:
UpdateWants
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
VideoSinkWants
wants
;
wants
.
rotation_applied
=
false
;
for
(
auto
&
sink
:
sink_pairs
(
)
)
{
if
(
sink
.
wants
.
rotation_applied
)
{
wants
.
rotation_applied
=
true
;
}
if
(
sink
.
wants
.
max_pixel_count
<
wants
.
max_pixel_count
)
{
wants
.
max_pixel_count
=
sink
.
wants
.
max_pixel_count
;
}
if
(
sink
.
wants
.
target_pixel_count
&
&
(
!
wants
.
target_pixel_count
|
|
(
*
sink
.
wants
.
target_pixel_count
<
*
wants
.
target_pixel_count
)
)
)
{
wants
.
target_pixel_count
=
sink
.
wants
.
target_pixel_count
;
}
if
(
sink
.
wants
.
max_framerate_fps
<
wants
.
max_framerate_fps
)
{
wants
.
max_framerate_fps
=
sink
.
wants
.
max_framerate_fps
;
}
}
if
(
wants
.
target_pixel_count
&
&
*
wants
.
target_pixel_count
>
=
wants
.
max_pixel_count
)
{
wants
.
target_pixel_count
.
emplace
(
wants
.
max_pixel_count
)
;
}
current_wants_
=
wants
;
}
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
&
VideoBroadcaster
:
:
GetBlackFrameBuffer
(
int
width
int
height
)
{
if
(
!
black_frame_buffer_
|
|
black_frame_buffer_
-
>
width
(
)
!
=
width
|
|
black_frame_buffer_
-
>
height
(
)
!
=
height
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420Buffer
>
buffer
=
webrtc
:
:
I420Buffer
:
:
Create
(
width
height
)
;
webrtc
:
:
I420Buffer
:
:
SetBlack
(
buffer
.
get
(
)
)
;
black_frame_buffer_
=
buffer
;
}
return
black_frame_buffer_
;
}
}
