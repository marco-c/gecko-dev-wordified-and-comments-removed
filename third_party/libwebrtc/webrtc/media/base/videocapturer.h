#
ifndef
MEDIA_BASE_VIDEOCAPTURER_H_
#
define
MEDIA_BASE_VIDEOCAPTURER_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
media
/
base
/
videoadapter
.
h
"
#
include
"
media
/
base
/
videobroadcaster
.
h
"
#
include
"
media
/
base
/
videocommon
.
h
"
#
include
"
media
/
base
/
videosourceinterface
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
#
include
"
rtc_base
/
timestampaligner
.
h
"
namespace
webrtc
{
class
VideoFrame
;
}
namespace
cricket
{
enum
CaptureState
{
CS_STOPPED
CS_STARTING
CS_RUNNING
CS_FAILED
}
;
class
VideoCapturer
:
public
sigslot
:
:
has_slots
<
>
public
rtc
:
:
VideoSourceInterface
<
webrtc
:
:
VideoFrame
>
{
public
:
VideoCapturer
(
)
;
virtual
~
VideoCapturer
(
)
{
}
const
std
:
:
string
&
GetId
(
)
const
{
return
id_
;
}
const
std
:
:
vector
<
VideoFormat
>
*
GetSupportedFormats
(
)
const
;
virtual
bool
GetBestCaptureFormat
(
const
VideoFormat
&
desired
VideoFormat
*
best_format
)
;
bool
StartCapturing
(
const
VideoFormat
&
capture_format
)
;
virtual
CaptureState
Start
(
const
VideoFormat
&
capture_format
)
=
0
;
const
VideoFormat
*
GetCaptureFormat
(
)
const
{
return
capture_format_
.
get
(
)
;
}
virtual
void
Stop
(
)
=
0
;
virtual
bool
IsRunning
(
)
=
0
;
CaptureState
capture_state
(
)
const
{
return
capture_state_
;
}
virtual
bool
apply_rotation
(
)
{
return
apply_rotation_
;
}
virtual
bool
IsScreencast
(
)
const
=
0
;
void
ConstrainSupportedFormats
(
const
VideoFormat
&
max_format
)
;
void
set_enable_camera_list
(
bool
enable_camera_list
)
{
enable_camera_list_
=
enable_camera_list
;
}
bool
enable_camera_list
(
)
{
return
enable_camera_list_
;
}
sigslot
:
:
signal2
<
VideoCapturer
*
CaptureState
>
SignalStateChange
;
bool
enable_video_adapter
(
)
const
{
return
enable_video_adapter_
;
}
void
set_enable_video_adapter
(
bool
enable_video_adapter
)
{
enable_video_adapter_
=
enable_video_adapter
;
}
bool
GetInputSize
(
int
*
width
int
*
height
)
;
void
AddOrUpdateSink
(
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
const
rtc
:
:
VideoSinkWants
&
wants
)
override
;
void
RemoveSink
(
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
)
override
;
protected
:
virtual
void
OnSinkWantsChanged
(
const
rtc
:
:
VideoSinkWants
&
wants
)
;
bool
AdaptFrame
(
int
width
int
height
int64_t
camera_time_us
int64_t
system_time_us
int
*
out_width
int
*
out_height
int
*
crop_width
int
*
crop_height
int
*
crop_x
int
*
crop_y
int64_t
*
translated_camera_time_us
)
;
void
OnFrame
(
const
webrtc
:
:
VideoFrame
&
frame
int
orig_width
int
orig_height
)
;
VideoAdapter
*
video_adapter
(
)
{
return
&
video_adapter_
;
}
void
SetCaptureState
(
CaptureState
state
)
;
virtual
bool
GetPreferredFourccs
(
std
:
:
vector
<
uint32_t
>
*
fourccs
)
=
0
;
void
SetId
(
const
std
:
:
string
&
id
)
{
id_
=
id
;
}
void
SetCaptureFormat
(
const
VideoFormat
*
format
)
{
capture_format_
.
reset
(
format
?
new
VideoFormat
(
*
format
)
:
NULL
)
;
}
void
SetSupportedFormats
(
const
std
:
:
vector
<
VideoFormat
>
&
formats
)
;
private
:
void
Construct
(
)
;
int64_t
GetFormatDistance
(
const
VideoFormat
&
desired
const
VideoFormat
&
supported
)
;
void
UpdateFilteredSupportedFormats
(
)
;
bool
ShouldFilterFormat
(
const
VideoFormat
&
format
)
const
;
void
UpdateInputSize
(
int
width
int
height
)
;
rtc
:
:
ThreadChecker
thread_checker_
;
std
:
:
string
id_
;
CaptureState
capture_state_
;
std
:
:
unique_ptr
<
VideoFormat
>
capture_format_
;
std
:
:
vector
<
VideoFormat
>
supported_formats_
;
std
:
:
unique_ptr
<
VideoFormat
>
max_format_
;
std
:
:
vector
<
VideoFormat
>
filtered_supported_formats_
;
bool
enable_camera_list_
;
int
scaled_width_
;
int
scaled_height_
;
rtc
:
:
VideoBroadcaster
broadcaster_
;
bool
enable_video_adapter_
;
VideoAdapter
video_adapter_
;
rtc
:
:
CriticalSection
frame_stats_crit_
;
bool
input_size_valid_
RTC_GUARDED_BY
(
frame_stats_crit_
)
=
false
;
int
input_width_
RTC_GUARDED_BY
(
frame_stats_crit_
)
;
int
input_height_
RTC_GUARDED_BY
(
frame_stats_crit_
)
;
bool
apply_rotation_
;
rtc
:
:
TimestampAligner
timestamp_aligner_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
VideoCapturer
)
;
}
;
}
#
endif
