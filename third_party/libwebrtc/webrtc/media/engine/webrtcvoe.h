#
ifndef
MEDIA_ENGINE_WEBRTCVOE_H_
#
define
MEDIA_ENGINE_WEBRTCVOE_H_
#
include
<
memory
>
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
voice_engine
/
include
/
voe_base
.
h
"
#
include
"
voice_engine
/
include
/
voe_errors
.
h
"
namespace
cricket
{
class
scoped_voe_engine
{
public
:
explicit
scoped_voe_engine
(
webrtc
:
:
VoiceEngine
*
e
)
:
ptr
(
e
)
{
}
~
scoped_voe_engine
(
)
{
if
(
ptr
)
{
const
bool
success
=
webrtc
:
:
VoiceEngine
:
:
Delete
(
ptr
)
;
RTC_DCHECK
(
success
)
;
}
}
void
reset
(
)
{
if
(
ptr
)
{
const
bool
success
=
webrtc
:
:
VoiceEngine
:
:
Delete
(
ptr
)
;
RTC_DCHECK
(
success
)
;
ptr
=
NULL
;
}
}
webrtc
:
:
VoiceEngine
*
get
(
)
const
{
return
ptr
;
}
private
:
webrtc
:
:
VoiceEngine
*
ptr
;
}
;
template
<
class
T
>
class
scoped_voe_ptr
{
public
:
explicit
scoped_voe_ptr
(
const
scoped_voe_engine
&
e
)
:
ptr
(
T
:
:
GetInterface
(
e
.
get
(
)
)
)
{
}
explicit
scoped_voe_ptr
(
T
*
p
)
:
ptr
(
p
)
{
}
~
scoped_voe_ptr
(
)
{
if
(
ptr
)
ptr
-
>
Release
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
ptr
;
}
T
*
get
(
)
const
{
return
ptr
;
}
void
reset
(
)
{
if
(
ptr
)
{
ptr
-
>
Release
(
)
;
ptr
=
NULL
;
}
}
private
:
T
*
ptr
;
}
;
class
VoEWrapper
{
public
:
VoEWrapper
(
)
:
engine_
(
webrtc
:
:
VoiceEngine
:
:
Create
(
)
)
base_
(
engine_
)
{
}
explicit
VoEWrapper
(
webrtc
:
:
VoEBase
*
base
)
:
engine_
(
NULL
)
base_
(
base
)
{
}
~
VoEWrapper
(
)
{
}
webrtc
:
:
VoiceEngine
*
engine
(
)
const
{
return
engine_
.
get
(
)
;
}
webrtc
:
:
VoEBase
*
base
(
)
const
{
return
base_
.
get
(
)
;
}
private
:
scoped_voe_engine
engine_
;
scoped_voe_ptr
<
webrtc
:
:
VoEBase
>
base_
;
}
;
}
#
endif
