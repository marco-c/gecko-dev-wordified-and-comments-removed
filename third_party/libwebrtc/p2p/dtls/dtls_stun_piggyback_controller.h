#
ifndef
P2P_DTLS_DTLS_STUN_PIGGYBACK_CONTROLLER_H_
#
define
P2P_DTLS_DTLS_STUN_PIGGYBACK_CONTROLLER_H_
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
DtlsStunPiggybackController
{
public
:
static
constexpr
unsigned
kMaxAckSize
=
16
;
DtlsStunPiggybackController
(
absl
:
:
AnyInvocable
<
void
(
rtc
:
:
ArrayView
<
const
uint8_t
>
)
>
dtls_data_callback
)
;
~
DtlsStunPiggybackController
(
)
;
enum
class
State
{
TENTATIVE
=
0
CONFIRMED
=
1
PENDING
=
2
COMPLETE
=
3
OFF
=
4
}
;
State
state
(
)
const
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
return
state_
;
}
void
SetDtlsHandshakeComplete
(
bool
is_dtls_client
bool
is_dtls13
)
;
void
CapturePacket
(
rtc
:
:
ArrayView
<
const
uint8_t
>
data
)
;
void
ClearCachedPacketForTesting
(
)
;
void
Flush
(
)
;
std
:
:
optional
<
absl
:
:
string_view
>
GetDataToPiggyback
(
StunMessageType
stun_message_type
)
;
std
:
:
optional
<
absl
:
:
string_view
>
GetAckToPiggyback
(
StunMessageType
stun_message_type
)
;
void
ReportDataPiggybacked
(
const
StunByteStringAttribute
*
data
const
StunByteStringAttribute
*
ack
)
;
int
GetCountOfReceivedData
(
)
const
{
return
data_recv_count_
;
}
private
:
State
state_
RTC_GUARDED_BY
(
sequence_checker_
)
=
State
:
:
TENTATIVE
;
bool
writing_packets_
RTC_GUARDED_BY
(
sequence_checker_
)
=
false
;
uint32_t
pending_packet_pos_
RTC_GUARDED_BY
(
sequence_checker_
)
=
0
;
std
:
:
vector
<
std
:
:
pair
<
uint32_t
std
:
:
unique_ptr
<
rtc
:
:
Buffer
>
>
>
pending_packets_
RTC_GUARDED_BY
(
sequence_checker_
)
;
absl
:
:
AnyInvocable
<
void
(
rtc
:
:
ArrayView
<
const
uint8_t
>
)
>
dtls_data_callback_
;
absl
:
:
AnyInvocable
<
void
(
)
>
disable_piggybacking_callback_
;
std
:
:
vector
<
uint32_t
>
handshake_messages_received_
RTC_GUARDED_BY
(
sequence_checker_
)
;
ByteBufferWriter
handshake_ack_writer_
RTC_GUARDED_BY
(
sequence_checker_
)
;
int
data_recv_count_
=
0
;
RTC_NO_UNIQUE_ADDRESS
SequenceChecker
sequence_checker_
;
}
;
}
namespace
cricket
{
using
:
:
webrtc
:
:
DtlsStunPiggybackController
;
}
#
endif
