#
include
"
p2p
/
dtls
/
dtls_transport
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
crypto
/
crypto_options
.
h
"
#
include
"
api
/
dtls_transport_interface
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
rtc_event_log
/
rtc_event_log
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
api
/
transport
/
ecn_marking
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
logging
/
rtc_event_log
/
events
/
rtc_event_dtls_transport_state
.
h
"
#
include
"
logging
/
rtc_event_log
/
events
/
rtc_event_dtls_writable_state
.
h
"
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
p2p
/
dtls
/
dtls_stun_piggyback_callbacks
.
h
"
#
include
"
p2p
/
dtls
/
dtls_stun_piggyback_controller
.
h
"
#
include
"
p2p
/
dtls
/
dtls_transport_internal
.
h
"
#
include
"
p2p
/
dtls
/
dtls_utils
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
rtc_certificate
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
ssl_certificate
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
stream
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
template
<
typename
Sink
>
void
AbslStringify
(
Sink
&
sink
webrtc
:
:
DtlsTransportState
state
)
{
switch
(
state
)
{
case
webrtc
:
:
DtlsTransportState
:
:
kNew
:
sink
.
Append
(
"
kNew
"
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnecting
:
sink
.
Append
(
"
kConnecting
"
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnected
:
sink
.
Append
(
"
kConnected
"
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kClosed
:
sink
.
Append
(
"
kClosed
"
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kFailed
:
sink
.
Append
(
"
kFailed
"
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kNumValues
:
sink
.
Append
(
"
kNumValues
"
)
;
break
;
}
}
constexpr
size_t
kMinRtpPacketLen
=
12
;
constexpr
size_t
kMaxPendingPackets
=
2
;
constexpr
int
kMinDtlsHandshakeTimeoutMs
=
50
;
constexpr
int
kMaxDtlsHandshakeTimeoutMs
=
3000
;
constexpr
int
kDisabledHandshakeTimeoutMs
=
3600
*
1000
*
24
;
constexpr
uint32_t
kMaxCachedClientHello
=
4
;
static
bool
IsRtpPacket
(
ArrayView
<
const
uint8_t
>
payload
)
{
const
uint8_t
*
u
=
payload
.
data
(
)
;
return
(
payload
.
size
(
)
>
=
kMinRtpPacketLen
&
&
(
u
[
0
]
&
0xC0
)
=
=
0x80
)
;
}
StreamInterfaceChannel
:
:
StreamInterfaceChannel
(
webrtc
:
:
IceTransportInternal
*
ice_transport
)
:
ice_transport_
(
ice_transport
)
state_
(
webrtc
:
:
SS_OPEN
)
packets_
(
kMaxPendingPackets
webrtc
:
:
kMaxDtlsPacketLen
)
{
}
void
StreamInterfaceChannel
:
:
SetDtlsStunPiggybackController
(
webrtc
:
:
DtlsStunPiggybackController
*
dtls_stun_piggyback_controller
)
{
dtls_stun_piggyback_controller_
=
dtls_stun_piggyback_controller
;
}
StreamResult
StreamInterfaceChannel
:
:
Read
(
ArrayView
<
uint8_t
>
buffer
size_t
&
read
int
&
)
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
if
(
state_
=
=
webrtc
:
:
SS_CLOSED
)
return
webrtc
:
:
SR_EOS
;
if
(
state_
=
=
webrtc
:
:
SS_OPENING
)
return
webrtc
:
:
SR_BLOCK
;
if
(
!
packets_
.
ReadFront
(
buffer
.
data
(
)
buffer
.
size
(
)
&
read
)
)
{
return
webrtc
:
:
SR_BLOCK
;
}
return
webrtc
:
:
SR_SUCCESS
;
}
StreamResult
StreamInterfaceChannel
:
:
Write
(
ArrayView
<
const
uint8_t
>
data
size_t
&
written
int
&
)
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
if
(
dtls_stun_piggyback_controller_
)
{
dtls_stun_piggyback_controller_
-
>
CapturePacket
(
data
)
;
}
AsyncSocketPacketOptions
packet_options
;
ice_transport_
-
>
SendPacket
(
reinterpret_cast
<
const
char
*
>
(
data
.
data
(
)
)
data
.
size
(
)
packet_options
)
;
written
=
data
.
size
(
)
;
return
webrtc
:
:
SR_SUCCESS
;
}
bool
StreamInterfaceChannel
:
:
Flush
(
)
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
if
(
dtls_stun_piggyback_controller_
)
{
dtls_stun_piggyback_controller_
-
>
Flush
(
)
;
}
return
false
;
}
bool
StreamInterfaceChannel
:
:
OnPacketReceived
(
const
char
*
data
size_t
size
)
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
if
(
packets_
.
size
(
)
>
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Packet
already
in
queue
.
"
;
}
bool
ret
=
packets_
.
WriteBack
(
data
size
NULL
)
;
if
(
!
ret
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
write
packet
to
queue
.
"
;
}
FireEvent
(
webrtc
:
:
SE_READ
0
)
;
return
ret
;
}
StreamState
StreamInterfaceChannel
:
:
GetState
(
)
const
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
return
state_
;
}
void
StreamInterfaceChannel
:
:
Close
(
)
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
packets_
.
Clear
(
)
;
state_
=
webrtc
:
:
SS_CLOSED
;
}
DtlsTransportInternalImpl
:
:
DtlsTransportInternalImpl
(
webrtc
:
:
IceTransportInternal
*
ice_transport
const
webrtc
:
:
CryptoOptions
&
crypto_options
webrtc
:
:
RtcEventLog
*
event_log
webrtc
:
:
SSLProtocolVersion
max_version
)
:
component_
(
ice_transport
-
>
component
(
)
)
ice_transport_
(
ice_transport
)
downward_
(
nullptr
)
srtp_ciphers_
(
crypto_options
.
GetSupportedDtlsSrtpCryptoSuites
(
)
)
ssl_max_version_
(
max_version
)
event_log_
(
event_log
)
dtls_stun_piggyback_controller_
(
[
this
]
(
ArrayView
<
const
uint8_t
>
piggybacked_dtls_packet
)
{
if
(
piggybacked_dtls_callback_
=
=
nullptr
)
{
return
;
}
piggybacked_dtls_callback_
(
this
ReceivedIpPacket
(
piggybacked_dtls_packet
webrtc
:
:
SocketAddress
(
)
)
)
;
}
)
{
RTC_DCHECK
(
ice_transport_
)
;
ConnectToIceTransport
(
)
;
if
(
auto
field_trials
=
ice_transport_
-
>
field_trials
(
)
)
{
dtls_in_stun_
=
field_trials
-
>
IsEnabled
(
"
WebRTC
-
IceHandshakeDtls
"
)
;
}
else
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
ice_transport_
>
field_trials
(
)
is
NULL
"
;
dtls_in_stun_
=
false
;
}
}
DtlsTransportInternalImpl
:
:
~
DtlsTransportInternalImpl
(
)
{
if
(
ice_transport_
)
{
ice_transport_
-
>
ResetDtlsStunPiggybackCallbacks
(
)
;
ice_transport_
-
>
DeregisterReceivedPacketCallback
(
this
)
;
}
}
webrtc
:
:
DtlsTransportState
DtlsTransportInternalImpl
:
:
dtls_state
(
)
const
{
return
dtls_state_
;
}
const
std
:
:
string
&
DtlsTransportInternalImpl
:
:
transport_name
(
)
const
{
return
ice_transport_
-
>
transport_name
(
)
;
}
int
DtlsTransportInternalImpl
:
:
component
(
)
const
{
return
component_
;
}
bool
DtlsTransportInternalImpl
:
:
IsDtlsActive
(
)
const
{
return
dtls_active_
;
}
bool
DtlsTransportInternalImpl
:
:
SetLocalCertificate
(
const
scoped_refptr
<
webrtc
:
:
RTCCertificate
>
&
certificate
)
{
if
(
dtls_active_
)
{
if
(
certificate
=
=
local_certificate_
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Ignoring
identical
DTLS
identity
"
;
return
true
;
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Can
'
t
change
DTLS
local
identity
in
this
state
"
;
return
false
;
}
}
if
(
certificate
)
{
local_certificate_
=
certificate
;
dtls_active_
=
true
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
NULL
DTLS
identity
supplied
.
Not
doing
DTLS
"
;
}
return
true
;
}
scoped_refptr
<
webrtc
:
:
RTCCertificate
>
DtlsTransportInternalImpl
:
:
GetLocalCertificate
(
)
const
{
return
local_certificate_
;
}
bool
DtlsTransportInternalImpl
:
:
SetDtlsRole
(
webrtc
:
:
SSLRole
role
)
{
if
(
dtls_
)
{
RTC_DCHECK
(
dtls_role_
)
;
if
(
*
dtls_role_
!
=
role
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SSL
Role
can
'
t
be
reversed
after
the
session
is
setup
.
"
;
return
false
;
}
return
true
;
}
dtls_role_
=
role
;
return
true
;
}
bool
DtlsTransportInternalImpl
:
:
GetDtlsRole
(
webrtc
:
:
SSLRole
*
role
)
const
{
if
(
!
dtls_role_
)
{
return
false
;
}
*
role
=
*
dtls_role_
;
return
true
;
}
bool
DtlsTransportInternalImpl
:
:
GetSslCipherSuite
(
int
*
cipher
)
const
{
if
(
dtls_state
(
)
!
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
return
false
;
}
return
dtls_
-
>
GetSslCipherSuite
(
cipher
)
;
}
std
:
:
optional
<
absl
:
:
string_view
>
DtlsTransportInternalImpl
:
:
GetTlsCipherSuiteName
(
)
const
{
if
(
dtls_state
(
)
!
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
return
std
:
:
nullopt
;
}
return
dtls_
-
>
GetTlsCipherSuiteName
(
)
;
}
webrtc
:
:
RTCError
DtlsTransportInternalImpl
:
:
SetRemoteParameters
(
absl
:
:
string_view
digest_alg
const
uint8_t
*
digest
size_t
digest_len
std
:
:
optional
<
webrtc
:
:
SSLRole
>
role
)
{
Buffer
remote_fingerprint_value
(
digest
digest_len
)
;
bool
is_dtls_restart
=
dtls_active_
&
&
remote_fingerprint_value_
!
=
remote_fingerprint_value
;
if
(
role
)
{
if
(
is_dtls_restart
)
{
dtls_role_
=
*
role
;
}
else
{
if
(
!
SetDtlsRole
(
*
role
)
)
{
return
webrtc
:
:
RTCError
(
webrtc
:
:
RTCErrorType
:
:
INVALID_PARAMETER
"
Failed
to
set
SSL
role
for
the
transport
.
"
)
;
}
}
}
if
(
!
SetRemoteFingerprint
(
digest_alg
digest
digest_len
)
)
{
return
webrtc
:
:
RTCError
(
webrtc
:
:
RTCErrorType
:
:
INVALID_PARAMETER
"
Failed
to
apply
remote
fingerprint
.
"
)
;
}
return
webrtc
:
:
RTCError
:
:
OK
(
)
;
}
bool
DtlsTransportInternalImpl
:
:
SetRemoteFingerprint
(
absl
:
:
string_view
digest_alg
const
uint8_t
*
digest
size_t
digest_len
)
{
Buffer
remote_fingerprint_value
(
digest
digest_len
)
;
if
(
dtls_active_
&
&
remote_fingerprint_value_
=
=
remote_fingerprint_value
&
&
!
digest_alg
.
empty
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Ignoring
identical
remote
DTLS
fingerprint
"
;
return
true
;
}
if
(
digest_alg
.
empty
(
)
)
{
RTC_DCHECK
(
!
digest_len
)
;
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Other
side
didn
'
t
support
DTLS
.
"
;
dtls_active_
=
false
;
return
true
;
}
if
(
!
dtls_active_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Can
'
t
set
DTLS
remote
settings
in
this
state
.
"
;
return
false
;
}
bool
fingerprint_changing
=
remote_fingerprint_value_
.
size
(
)
>
0u
;
remote_fingerprint_value_
=
std
:
:
move
(
remote_fingerprint_value
)
;
remote_fingerprint_algorithm_
=
std
:
:
string
(
digest_alg
)
;
if
(
dtls_
&
&
!
fingerprint_changing
)
{
webrtc
:
:
SSLPeerCertificateDigestError
err
=
dtls_
-
>
SetPeerCertificateDigest
(
remote_fingerprint_algorithm_
remote_fingerprint_value_
)
;
if
(
err
!
=
webrtc
:
:
SSLPeerCertificateDigestError
:
:
NONE
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Couldn
'
t
set
DTLS
certificate
digest
.
"
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
;
return
err
=
=
webrtc
:
:
SSLPeerCertificateDigestError
:
:
VERIFICATION_FAILED
;
}
return
true
;
}
if
(
dtls_
&
&
fingerprint_changing
)
{
dtls_
.
reset
(
nullptr
)
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kNew
)
;
set_writable
(
false
)
;
}
if
(
!
SetupDtls
(
)
)
{
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
;
return
false
;
}
return
true
;
}
std
:
:
unique_ptr
<
webrtc
:
:
SSLCertChain
>
DtlsTransportInternalImpl
:
:
GetRemoteSSLCertChain
(
)
const
{
if
(
!
dtls_
)
{
return
nullptr
;
}
return
dtls_
-
>
GetPeerSSLCertChain
(
)
;
}
bool
DtlsTransportInternalImpl
:
:
ExportSrtpKeyingMaterial
(
ZeroOnFreeBuffer
<
uint8_t
>
&
keying_material
)
{
return
dtls_
?
dtls_
-
>
ExportSrtpKeyingMaterial
(
keying_material
)
:
false
;
}
bool
DtlsTransportInternalImpl
:
:
SetupDtls
(
)
{
RTC_DCHECK
(
dtls_role_
)
;
dtls_in_stun_
=
ice_transport_
-
>
config
(
)
.
dtls_handshake_in_stun
;
{
auto
downward
=
std
:
:
make_unique
<
StreamInterfaceChannel
>
(
ice_transport_
)
;
StreamInterfaceChannel
*
downward_ptr
=
downward
.
get
(
)
;
if
(
dtls_in_stun_
)
{
downward_ptr
-
>
SetDtlsStunPiggybackController
(
&
dtls_stun_piggyback_controller_
)
;
}
dtls_
=
webrtc
:
:
SSLStreamAdapter
:
:
Create
(
std
:
:
move
(
downward
)
[
this
]
(
SSLHandshakeError
error
)
{
OnDtlsHandshakeError
(
error
)
;
}
ice_transport_
-
>
field_trials
(
)
)
;
if
(
!
dtls_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Failed
to
create
DTLS
adapter
.
"
;
return
false
;
}
downward_
=
downward_ptr
;
}
if
(
dtls_in_stun_
)
{
const
int
kDtlsMtu
=
800
;
dtls_
-
>
SetMTU
(
kDtlsMtu
)
;
}
dtls_
-
>
SetIdentity
(
local_certificate_
-
>
identity
(
)
-
>
Clone
(
)
)
;
dtls_
-
>
SetMaxProtocolVersion
(
ssl_max_version_
)
;
dtls_
-
>
SetServerRole
(
*
dtls_role_
)
;
dtls_
-
>
SetEventCallback
(
[
this
]
(
int
events
int
err
)
{
OnDtlsEvent
(
events
err
)
;
}
)
;
if
(
remote_fingerprint_value_
.
size
(
)
&
&
dtls_
-
>
SetPeerCertificateDigest
(
remote_fingerprint_algorithm_
remote_fingerprint_value_
)
!
=
webrtc
:
:
SSLPeerCertificateDigestError
:
:
NONE
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Couldn
'
t
set
DTLS
certificate
digest
.
"
;
return
false
;
}
if
(
!
srtp_ciphers_
.
empty
(
)
)
{
if
(
!
dtls_
-
>
SetDtlsSrtpCryptoSuites
(
srtp_ciphers_
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Couldn
'
t
set
DTLS
-
SRTP
ciphers
.
"
;
return
false
;
}
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Not
using
DTLS
-
SRTP
.
"
;
}
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
DTLS
setup
complete
dtls_in_stun
:
"
<
<
dtls_in_stun_
;
MaybeStartDtls
(
)
;
return
true
;
}
bool
DtlsTransportInternalImpl
:
:
GetSrtpCryptoSuite
(
int
*
cipher
)
const
{
if
(
dtls_state
(
)
!
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
return
false
;
}
return
dtls_
-
>
GetDtlsSrtpCryptoSuite
(
cipher
)
;
}
bool
DtlsTransportInternalImpl
:
:
GetSslVersionBytes
(
int
*
version
)
const
{
if
(
dtls_state
(
)
!
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
return
false
;
}
return
dtls_
-
>
GetSslVersionBytes
(
version
)
;
}
uint16_t
DtlsTransportInternalImpl
:
:
GetSslPeerSignatureAlgorithm
(
)
const
{
if
(
dtls_state
(
)
!
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
return
webrtc
:
:
kSslSignatureAlgorithmUnknown
;
}
return
dtls_
-
>
GetPeerSignatureAlgorithm
(
)
;
}
int
DtlsTransportInternalImpl
:
:
SendPacket
(
const
char
*
data
size_t
size
const
AsyncSocketPacketOptions
&
options
int
flags
)
{
if
(
!
dtls_active_
)
{
return
ice_transport_
-
>
SendPacket
(
data
size
options
)
;
}
switch
(
dtls_state
(
)
)
{
case
webrtc
:
:
DtlsTransportState
:
:
kNew
:
return
-
1
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnecting
:
return
-
1
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnected
:
if
(
flags
&
webrtc
:
:
PF_SRTP_BYPASS
)
{
RTC_DCHECK
(
!
srtp_ciphers_
.
empty
(
)
)
;
if
(
!
IsRtpPacket
(
MakeArrayView
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
size
)
)
)
{
return
-
1
;
}
return
ice_transport_
-
>
SendPacket
(
data
size
options
)
;
}
else
{
size_t
written
;
int
error
;
return
(
dtls_
-
>
WriteAll
(
MakeArrayView
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
size
)
written
error
)
=
=
webrtc
:
:
SR_SUCCESS
)
?
static_cast
<
int
>
(
size
)
:
-
1
;
}
case
webrtc
:
:
DtlsTransportState
:
:
kFailed
:
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Couldn
'
t
send
packet
due
to
"
"
webrtc
:
:
DtlsTransportState
:
:
kFailed
.
"
;
return
-
1
;
case
webrtc
:
:
DtlsTransportState
:
:
kClosed
:
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Couldn
'
t
send
packet
due
to
"
"
webrtc
:
:
DtlsTransportState
:
:
kClosed
.
"
;
return
-
1
;
default
:
RTC_DCHECK_NOTREACHED
(
)
;
return
-
1
;
}
}
webrtc
:
:
IceTransportInternal
*
DtlsTransportInternalImpl
:
:
ice_transport
(
)
{
return
ice_transport_
;
}
bool
DtlsTransportInternalImpl
:
:
IsDtlsConnected
(
)
{
return
dtls_
&
&
dtls_
-
>
IsTlsConnected
(
)
;
}
bool
DtlsTransportInternalImpl
:
:
receiving
(
)
const
{
return
receiving_
;
}
bool
DtlsTransportInternalImpl
:
:
writable
(
)
const
{
return
writable_
;
}
int
DtlsTransportInternalImpl
:
:
GetError
(
)
{
return
ice_transport_
-
>
GetError
(
)
;
}
std
:
:
optional
<
webrtc
:
:
NetworkRoute
>
DtlsTransportInternalImpl
:
:
network_route
(
)
const
{
return
ice_transport_
-
>
network_route
(
)
;
}
bool
DtlsTransportInternalImpl
:
:
GetOption
(
webrtc
:
:
Socket
:
:
Option
opt
int
*
value
)
{
return
ice_transport_
-
>
GetOption
(
opt
value
)
;
}
int
DtlsTransportInternalImpl
:
:
SetOption
(
webrtc
:
:
Socket
:
:
Option
opt
int
value
)
{
return
ice_transport_
-
>
SetOption
(
opt
value
)
;
}
void
DtlsTransportInternalImpl
:
:
ConnectToIceTransport
(
)
{
RTC_DCHECK
(
ice_transport_
)
;
ice_transport_
-
>
SignalWritableState
.
connect
(
this
&
DtlsTransportInternalImpl
:
:
OnWritableState
)
;
ice_transport_
-
>
RegisterReceivedPacketCallback
(
this
[
&
]
(
PacketTransportInternal
*
transport
const
ReceivedIpPacket
&
packet
)
{
OnReadPacket
(
transport
packet
false
)
;
}
)
;
ice_transport_
-
>
SignalSentPacket
.
connect
(
this
&
DtlsTransportInternalImpl
:
:
OnSentPacket
)
;
ice_transport_
-
>
SignalReadyToSend
.
connect
(
this
&
DtlsTransportInternalImpl
:
:
OnReadyToSend
)
;
ice_transport_
-
>
SignalReceivingState
.
connect
(
this
&
DtlsTransportInternalImpl
:
:
OnReceivingState
)
;
ice_transport_
-
>
SignalNetworkRouteChanged
.
connect
(
this
&
DtlsTransportInternalImpl
:
:
OnNetworkRouteChanged
)
;
ice_transport_
-
>
SetDtlsStunPiggybackCallbacks
(
webrtc
:
:
DtlsStunPiggybackCallbacks
(
[
&
]
(
auto
stun_message_type
)
{
std
:
:
optional
<
absl
:
:
string_view
>
data
;
std
:
:
optional
<
absl
:
:
string_view
>
ack
;
if
(
dtls_in_stun_
)
{
data
=
dtls_stun_piggyback_controller_
.
GetDataToPiggyback
(
stun_message_type
)
;
ack
=
dtls_stun_piggyback_controller_
.
GetAckToPiggyback
(
stun_message_type
)
;
}
return
std
:
:
make_pair
(
data
ack
)
;
}
[
&
]
(
auto
data
auto
ack
)
{
if
(
!
dtls_in_stun_
)
{
return
;
}
dtls_stun_piggyback_controller_
.
ReportDataPiggybacked
(
data
ack
)
;
}
)
)
;
SetPiggybackDtlsDataCallback
(
[
this
]
(
PacketTransportInternal
*
transport
const
ReceivedIpPacket
&
packet
)
{
RTC_DCHECK
(
dtls_active_
)
;
RTC_DCHECK
(
webrtc
:
:
IsDtlsPacket
(
packet
.
payload
(
)
)
)
;
if
(
!
dtls_active_
)
{
return
;
}
if
(
!
webrtc
:
:
IsDtlsPacket
(
packet
.
payload
(
)
)
)
{
return
;
}
OnReadPacket
(
ice_transport_
packet
true
)
;
}
)
;
}
void
DtlsTransportInternalImpl
:
:
OnWritableState
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
transport
=
=
ice_transport_
)
;
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
ice_transport
writable
state
changed
to
"
<
<
ice_transport_
-
>
writable
(
)
<
<
"
dtls_state
:
"
<
<
dtls_state
(
)
;
if
(
!
ice_has_been_writable_
)
{
RTC_DCHECK
(
ice_transport_
-
>
writable
(
)
)
;
}
bool
first_ice_writable
=
!
ice_has_been_writable_
;
ice_has_been_writable_
=
true
;
if
(
!
dtls_active_
)
{
set_writable
(
ice_transport_
-
>
writable
(
)
)
;
return
;
}
switch
(
dtls_state
(
)
)
{
case
webrtc
:
:
DtlsTransportState
:
:
kNew
:
MaybeStartDtls
(
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnected
:
if
(
dtls_in_stun_
&
&
dtls_
&
&
first_ice_writable
)
{
ConfigureHandshakeTimeout
(
)
;
PeriodicRetransmitDtlsPacketUntilDtlsConnected
(
)
;
}
set_writable
(
ice_transport_
-
>
writable
(
)
)
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnecting
:
if
(
dtls_in_stun_
&
&
dtls_
)
{
ConfigureHandshakeTimeout
(
)
;
PeriodicRetransmitDtlsPacketUntilDtlsConnected
(
)
;
}
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kFailed
:
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
OnWritableState
(
)
called
in
state
"
"
webrtc
:
:
DtlsTransportState
:
:
kFailed
.
"
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kClosed
:
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
OnWritableState
(
)
called
in
state
"
"
webrtc
:
:
DtlsTransportState
:
:
kClosed
.
"
;
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kNumValues
:
RTC_DCHECK_NOTREACHED
(
)
;
break
;
}
}
void
DtlsTransportInternalImpl
:
:
OnReceivingState
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
transport
=
=
ice_transport_
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
ToString
(
)
<
<
"
:
ice_transport
"
"
receiving
state
changed
to
"
<
<
ice_transport_
-
>
receiving
(
)
;
if
(
!
dtls_active_
|
|
dtls_state
(
)
=
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
set_receiving
(
ice_transport_
-
>
receiving
(
)
)
;
}
}
void
DtlsTransportInternalImpl
:
:
OnReadPacket
(
webrtc
:
:
PacketTransportInternal
*
transport
const
ReceivedIpPacket
&
packet
bool
piggybacked
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
transport
=
=
ice_transport_
)
;
if
(
!
dtls_active_
)
{
NotifyPacketReceived
(
packet
)
;
return
;
}
switch
(
dtls_state
(
)
)
{
case
webrtc
:
:
DtlsTransportState
:
:
kNew
:
if
(
dtls_
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Packet
received
before
DTLS
started
.
"
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
ToString
(
)
<
<
"
:
Packet
received
before
we
know
if
we
are
"
"
doing
DTLS
or
not
.
"
;
}
if
(
webrtc
:
:
IsDtlsClientHelloPacket
(
packet
.
payload
(
)
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Caching
DTLS
ClientHello
packet
until
DTLS
is
"
"
started
.
"
;
cached_client_hello_
.
AddIfUnique
(
packet
.
payload
(
)
)
;
cached_client_hello_
.
Prune
(
kMaxCachedClientHello
)
;
if
(
!
dtls_
&
&
local_certificate_
)
{
SetDtlsRole
(
webrtc
:
:
SSL_SERVER
)
;
SetupDtls
(
)
;
}
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Not
a
DTLS
ClientHello
packet
;
dropping
.
"
;
}
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kConnecting
:
case
webrtc
:
:
DtlsTransportState
:
:
kConnected
:
if
(
webrtc
:
:
IsDtlsPacket
(
packet
.
payload
(
)
)
)
{
if
(
!
HandleDtlsPacket
(
packet
.
payload
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Failed
to
handle
DTLS
packet
.
"
;
return
;
}
}
else
{
if
(
dtls_state
(
)
!
=
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Received
non
-
DTLS
packet
before
DTLS
"
"
complete
.
"
;
return
;
}
if
(
!
IsRtpPacket
(
packet
.
payload
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Received
unexpected
non
-
DTLS
packet
.
"
;
return
;
}
RTC_DCHECK
(
!
srtp_ciphers_
.
empty
(
)
)
;
NotifyPacketReceived
(
packet
.
CopyAndSet
(
ReceivedIpPacket
:
:
kSrtpEncrypted
)
)
;
}
break
;
case
webrtc
:
:
DtlsTransportState
:
:
kFailed
:
case
webrtc
:
:
DtlsTransportState
:
:
kClosed
:
case
webrtc
:
:
DtlsTransportState
:
:
kNumValues
:
break
;
}
}
void
DtlsTransportInternalImpl
:
:
OnSentPacket
(
webrtc
:
:
PacketTransportInternal
*
const
SentPacketInfo
&
sent_packet
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
SignalSentPacket
(
this
sent_packet
)
;
}
void
DtlsTransportInternalImpl
:
:
OnReadyToSend
(
webrtc
:
:
PacketTransportInternal
*
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
if
(
writable
(
)
)
{
SignalReadyToSend
(
this
)
;
}
}
void
DtlsTransportInternalImpl
:
:
OnDtlsEvent
(
int
sig
int
err
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
dtls_
)
;
if
(
sig
&
webrtc
:
:
SE_OPEN
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
DTLS
handshake
complete
.
"
;
if
(
dtls_
-
>
GetState
(
)
=
=
webrtc
:
:
SS_OPEN
)
{
int
ssl_version_bytes
;
bool
ret
=
dtls_
-
>
GetSslVersionBytes
(
&
ssl_version_bytes
)
;
RTC_DCHECK
(
ret
)
;
dtls_stun_piggyback_controller_
.
SetDtlsHandshakeComplete
(
dtls_role_
=
=
webrtc
:
:
SSL_CLIENT
ssl_version_bytes
=
=
webrtc
:
:
kDtls13VersionBytes
)
;
downward_
-
>
SetDtlsStunPiggybackController
(
nullptr
)
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
;
set_writable
(
true
)
;
}
}
if
(
sig
&
webrtc
:
:
SE_READ
)
{
uint8_t
buf
[
webrtc
:
:
kMaxDtlsPacketLen
]
;
size_t
read
;
int
read_error
;
StreamResult
ret
;
do
{
ret
=
dtls_
-
>
Read
(
buf
read
read_error
)
;
if
(
ret
=
=
webrtc
:
:
SR_SUCCESS
)
{
NotifyPacketReceived
(
ReceivedIpPacket
(
MakeArrayView
(
buf
read
)
webrtc
:
:
SocketAddress
(
)
webrtc
:
:
Timestamp
:
:
Micros
(
webrtc
:
:
TimeMicros
(
)
)
EcnMarking
:
:
kNotEct
ReceivedIpPacket
:
:
kDtlsDecrypted
)
)
;
}
else
if
(
ret
=
=
webrtc
:
:
SR_EOS
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
DTLS
transport
closed
by
remote
"
;
set_writable
(
false
)
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kClosed
)
;
NotifyOnClose
(
)
;
}
else
if
(
ret
=
=
webrtc
:
:
SR_ERROR
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Closed
by
remote
with
DTLS
transport
error
code
=
"
<
<
read_error
;
set_writable
(
false
)
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
;
NotifyOnClose
(
)
;
}
}
while
(
ret
=
=
webrtc
:
:
SR_SUCCESS
)
;
}
if
(
sig
&
webrtc
:
:
SE_CLOSE
)
{
RTC_DCHECK
(
sig
=
=
webrtc
:
:
SE_CLOSE
)
;
set_writable
(
false
)
;
if
(
!
err
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
DTLS
transport
closed
"
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kClosed
)
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
DTLS
transport
error
code
=
"
<
<
err
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
;
}
}
}
void
DtlsTransportInternalImpl
:
:
OnNetworkRouteChanged
(
std
:
:
optional
<
webrtc
:
:
NetworkRoute
>
network_route
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
SignalNetworkRouteChanged
(
network_route
)
;
}
void
DtlsTransportInternalImpl
:
:
MaybeStartDtls
(
)
{
RTC_DCHECK
(
ice_transport_
)
;
if
(
dtls_
&
&
(
ice_transport_
-
>
writable
(
)
|
|
dtls_in_stun_
)
)
{
ConfigureHandshakeTimeout
(
)
;
if
(
dtls_
-
>
StartSSL
(
)
)
{
RTC_DCHECK_NOTREACHED
(
)
<
<
"
StartSSL
failed
.
"
;
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Couldn
'
t
start
DTLS
handshake
"
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
;
return
;
}
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
DtlsTransportInternalImpl
:
Started
DTLS
handshake
active
=
"
<
<
IsDtlsActive
(
)
<
<
"
role
=
"
<
<
(
*
dtls_role_
=
=
SSL_SERVER
?
"
server
"
:
"
client
"
)
;
set_dtls_state
(
webrtc
:
:
DtlsTransportState
:
:
kConnecting
)
;
if
(
!
cached_client_hello_
.
empty
(
)
)
{
if
(
*
dtls_role_
=
=
webrtc
:
:
SSL_SERVER
)
{
int
size
=
cached_client_hello_
.
size
(
)
;
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Handling
#
"
<
<
size
<
<
"
cached
DTLS
ClientHello
packet
(
s
)
.
"
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
!
HandleDtlsPacket
(
cached_client_hello_
.
GetNext
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
ToString
(
)
<
<
"
:
Failed
to
handle
DTLS
packet
.
"
;
break
;
}
}
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
ToString
(
)
<
<
"
:
Discarding
cached
DTLS
ClientHello
packet
"
"
because
we
don
'
t
have
the
server
role
.
"
;
}
cached_client_hello_
.
clear
(
)
;
}
}
}
bool
DtlsTransportInternalImpl
:
:
HandleDtlsPacket
(
ArrayView
<
const
uint8_t
>
payload
)
{
return
downward_
-
>
OnPacketReceived
(
reinterpret_cast
<
const
char
*
>
(
payload
.
data
(
)
)
payload
.
size
(
)
)
;
}
void
DtlsTransportInternalImpl
:
:
set_receiving
(
bool
receiving
)
{
if
(
receiving_
=
=
receiving
)
{
return
;
}
receiving_
=
receiving
;
SignalReceivingState
(
this
)
;
}
void
DtlsTransportInternalImpl
:
:
set_writable
(
bool
writable
)
{
if
(
writable_
=
=
writable
)
{
return
;
}
if
(
writable
&
&
!
ice_has_been_writable_
)
{
RTC_DCHECK
(
dtls_in_stun_
)
;
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
defer
set_writable
(
true
)
until
ICE
has
become
writable
once
"
;
return
;
}
if
(
event_log_
)
{
event_log_
-
>
Log
(
std
:
:
make_unique
<
webrtc
:
:
RtcEventDtlsWritableState
>
(
writable
)
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
ToString
(
)
<
<
"
:
set_writable
to
:
"
<
<
writable
;
writable_
=
writable
;
if
(
writable_
)
{
SignalReadyToSend
(
this
)
;
}
SignalWritableState
(
this
)
;
}
void
DtlsTransportInternalImpl
:
:
set_dtls_state
(
webrtc
:
:
DtlsTransportState
state
)
{
if
(
dtls_state_
=
=
state
)
{
return
;
}
if
(
event_log_
)
{
event_log_
-
>
Log
(
std
:
:
make_unique
<
webrtc
:
:
RtcEventDtlsTransportState
>
(
state
)
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
ToString
(
)
<
<
"
:
set_dtls_state
from
:
"
<
<
static_cast
<
int
>
(
dtls_state_
)
<
<
"
to
"
<
<
static_cast
<
int
>
(
state
)
;
dtls_state_
=
state
;
SendDtlsState
(
this
state
)
;
}
void
DtlsTransportInternalImpl
:
:
OnDtlsHandshakeError
(
webrtc
:
:
SSLHandshakeError
error
)
{
SendDtlsHandshakeError
(
error
)
;
}
int
ComputeRetransmissionTimeout
(
int
rtt_ms
)
{
return
std
:
:
max
(
kMinDtlsHandshakeTimeoutMs
std
:
:
min
(
kMaxDtlsHandshakeTimeoutMs
2
*
(
rtt_ms
)
)
)
;
}
void
DtlsTransportInternalImpl
:
:
ConfigureHandshakeTimeout
(
)
{
RTC_DCHECK
(
dtls_
)
;
std
:
:
optional
<
int
>
rtt_ms
=
ice_transport_
-
>
GetRttEstimate
(
)
;
if
(
rtt_ms
)
{
int
initial_timeout_ms
=
ComputeRetransmissionTimeout
(
*
rtt_ms
)
;
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
configuring
DTLS
handshake
timeout
"
<
<
initial_timeout_ms
<
<
"
ms
based
on
ICE
RTT
"
<
<
*
rtt_ms
;
dtls_
-
>
SetInitialRetransmissionTimeout
(
initial_timeout_ms
)
;
}
else
if
(
dtls_in_stun_
)
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
configuring
DTLS
handshake
timeout
"
<
<
kDisabledHandshakeTimeoutMs
<
<
"
ms
for
DTLS
-
in
-
STUN
"
;
dtls_
-
>
SetInitialRetransmissionTimeout
(
kDisabledHandshakeTimeoutMs
)
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
no
RTT
estimate
-
using
default
DTLS
handshake
timeout
"
;
}
}
void
DtlsTransportInternalImpl
:
:
SetPiggybackDtlsDataCallback
(
absl
:
:
AnyInvocable
<
void
(
webrtc
:
:
PacketTransportInternal
*
transport
const
webrtc
:
:
ReceivedIpPacket
&
packet
)
>
callback
)
{
RTC_DCHECK
(
callback
=
=
nullptr
|
|
!
piggybacked_dtls_callback_
)
;
piggybacked_dtls_callback_
=
std
:
:
move
(
callback
)
;
}
bool
DtlsTransportInternalImpl
:
:
IsDtlsPiggybackSupportedByPeer
(
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
ice_transport_
)
;
return
dtls_in_stun_
&
&
(
dtls_stun_piggyback_controller_
.
state
(
)
!
=
webrtc
:
:
DtlsStunPiggybackController
:
:
State
:
:
OFF
)
;
}
bool
DtlsTransportInternalImpl
:
:
WasDtlsCompletedByPiggybacking
(
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
ice_transport_
)
;
return
dtls_in_stun_
&
&
(
dtls_stun_piggyback_controller_
.
state
(
)
=
=
webrtc
:
:
DtlsStunPiggybackController
:
:
State
:
:
COMPLETE
|
|
dtls_stun_piggyback_controller_
.
state
(
)
=
=
webrtc
:
:
DtlsStunPiggybackController
:
:
State
:
:
PENDING
)
;
}
void
DtlsTransportInternalImpl
:
:
PeriodicRetransmitDtlsPacketUntilDtlsConnected
(
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
if
(
pending_periodic_retransmit_dtls_packet_
=
=
true
)
{
return
;
}
if
(
ice_transport_
-
>
writable
(
)
&
&
dtls_in_stun_
)
{
auto
data_to_send
=
dtls_stun_piggyback_controller_
.
GetDataToPiggyback
(
webrtc
:
:
STUN_BINDING_INDICATION
)
;
if
(
!
data_to_send
)
{
return
;
}
AsyncSocketPacketOptions
packet_options
;
ice_transport_
-
>
SendPacket
(
data_to_send
-
>
data
(
)
data_to_send
-
>
size
(
)
packet_options
0
)
;
}
const
auto
rtt_ms
=
ice_transport_
-
>
GetRttEstimate
(
)
.
value_or
(
100
)
;
const
int
delay_ms
=
ComputeRetransmissionTimeout
(
rtt_ms
)
;
pending_periodic_retransmit_dtls_packet_
=
true
;
webrtc
:
:
Thread
:
:
Current
(
)
-
>
PostDelayedHighPrecisionTask
(
webrtc
:
:
SafeTask
(
safety_flag_
.
flag
(
)
[
this
]
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
pending_periodic_retransmit_dtls_packet_
=
false
;
PeriodicRetransmitDtlsPacketUntilDtlsConnected
(
)
;
}
)
webrtc
:
:
TimeDelta
:
:
Millis
(
delay_ms
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
ToString
(
)
<
<
"
:
Scheduled
retransmit
of
DTLS
packet
delay_ms
:
"
<
<
delay_ms
;
}
int
DtlsTransportInternalImpl
:
:
GetRetransmissionCount
(
)
const
{
if
(
!
dtls_
)
{
return
0
;
}
return
dtls_
-
>
GetRetransmissionCount
(
)
;
}
int
DtlsTransportInternalImpl
:
:
GetStunDataCount
(
)
const
{
if
(
!
dtls_in_stun_
)
{
return
0
;
}
return
dtls_stun_piggyback_controller_
.
GetCountOfReceivedData
(
)
;
}
}
