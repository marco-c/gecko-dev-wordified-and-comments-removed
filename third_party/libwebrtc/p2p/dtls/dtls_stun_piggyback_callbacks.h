#
ifndef
P2P_DTLS_DTLS_STUN_PIGGYBACK_CALLBACKS_H_
#
define
P2P_DTLS_DTLS_STUN_PIGGYBACK_CALLBACKS_H_
#
include
<
cstdint
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
class
DtlsStunPiggybackCallbacks
{
public
:
DtlsStunPiggybackCallbacks
(
)
:
send_data_
(
nullptr
)
recv_data_
(
nullptr
)
{
}
DtlsStunPiggybackCallbacks
(
absl
:
:
AnyInvocable
<
std
:
:
pair
<
std
:
:
optional
<
absl
:
:
string_view
>
std
:
:
optional
<
absl
:
:
string_view
>
>
(
StunMessageType
)
>
&
&
send_data
absl
:
:
AnyInvocable
<
void
(
std
:
:
optional
<
ArrayView
<
uint8_t
>
>
std
:
:
optional
<
std
:
:
vector
<
uint32_t
>
>
)
>
&
&
recv_data
)
:
send_data_
(
std
:
:
move
(
send_data
)
)
recv_data_
(
std
:
:
move
(
recv_data
)
)
{
RTC_DCHECK
(
(
send_data_
!
=
nullptr
&
&
recv_data_
!
=
nullptr
)
|
|
(
send_data_
=
=
nullptr
&
&
recv_data_
=
=
nullptr
)
)
;
}
std
:
:
pair
<
std
:
:
optional
<
absl
:
:
string_view
>
std
:
:
optional
<
absl
:
:
string_view
>
>
send_data
(
StunMessageType
request_type
)
{
RTC_DCHECK
(
send_data_
)
;
return
send_data_
(
request_type
)
;
}
void
recv_data
(
std
:
:
optional
<
ArrayView
<
uint8_t
>
>
data
std
:
:
optional
<
std
:
:
vector
<
uint32_t
>
>
acks
)
{
RTC_DCHECK
(
recv_data_
)
;
return
recv_data_
(
data
acks
)
;
}
bool
empty
(
)
const
{
return
send_data_
=
=
nullptr
;
}
void
reset
(
)
{
send_data_
=
nullptr
;
recv_data_
=
nullptr
;
}
private
:
absl
:
:
AnyInvocable
<
std
:
:
pair
<
std
:
:
optional
<
absl
:
:
string_view
>
std
:
:
optional
<
absl
:
:
string_view
>
>
(
StunMessageType
)
>
send_data_
;
absl
:
:
AnyInvocable
<
void
(
std
:
:
optional
<
ArrayView
<
uint8_t
>
>
std
:
:
optional
<
std
:
:
vector
<
uint32_t
>
>
)
>
recv_data_
;
}
;
}
#
endif
