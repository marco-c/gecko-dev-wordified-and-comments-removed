#
ifndef
P2P_DTLS_DTLS_UTILS_H_
#
define
P2P_DTLS_DTLS_UTILS_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
vector
>
#
include
"
absl
/
container
/
flat_hash_set
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
namespace
webrtc
{
const
size_t
kDtlsRecordHeaderLen
=
13
;
const
size_t
kMaxDtlsPacketLen
=
2048
;
bool
IsDtlsPacket
(
ArrayView
<
const
uint8_t
>
payload
)
;
bool
IsDtlsClientHelloPacket
(
ArrayView
<
const
uint8_t
>
payload
)
;
bool
IsDtlsHandshakePacket
(
ArrayView
<
const
uint8_t
>
payload
)
;
std
:
:
optional
<
std
:
:
vector
<
uint16_t
>
>
GetDtlsHandshakeAcks
(
ArrayView
<
const
uint8_t
>
dtls_packet
)
;
uint32_t
ComputeDtlsPacketHash
(
ArrayView
<
const
uint8_t
>
dtls_packet
)
;
class
PacketStash
{
public
:
PacketStash
(
)
{
}
void
Add
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
;
bool
AddIfUnique
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
;
void
Prune
(
const
absl
:
:
flat_hash_set
<
uint32_t
>
&
packet_hashes
)
;
void
Prune
(
uint32_t
max_size
)
;
rtc
:
:
ArrayView
<
const
uint8_t
>
GetNext
(
)
;
void
clear
(
)
{
packets_
.
clear
(
)
;
pos_
=
0
;
}
bool
empty
(
)
const
{
return
packets_
.
empty
(
)
;
}
int
size
(
)
const
{
return
packets_
.
size
(
)
;
}
static
uint32_t
Hash
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
{
return
ComputeDtlsPacketHash
(
packet
)
;
}
private
:
struct
StashedPacket
{
uint32_t
hash
;
std
:
:
unique_ptr
<
rtc
:
:
Buffer
>
buffer
;
}
;
uint32_t
pos_
=
0
;
std
:
:
vector
<
StashedPacket
>
packets_
;
}
;
}
#
ifdef
WEBRTC_ALLOW_DEPRECATED_NAMESPACES
namespace
cricket
{
using
:
:
webrtc
:
:
GetDtlsHandshakeAcks
;
using
:
:
webrtc
:
:
IsDtlsClientHelloPacket
;
using
:
:
webrtc
:
:
IsDtlsHandshakePacket
;
using
:
:
webrtc
:
:
IsDtlsPacket
;
using
:
:
webrtc
:
:
kDtlsRecordHeaderLen
;
using
:
:
webrtc
:
:
kMaxDtlsPacketLen
;
}
#
endif
#
endif
