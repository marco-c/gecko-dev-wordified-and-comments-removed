#
include
"
p2p
/
dtls
/
dtls_stun_piggyback_controller
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
container
/
flat_hash_set
.
h
"
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
p2p
/
dtls
/
dtls_utils
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
strings
/
str_join
.
h
"
namespace
webrtc
{
DtlsStunPiggybackController
:
:
DtlsStunPiggybackController
(
absl
:
:
AnyInvocable
<
void
(
ArrayView
<
const
uint8_t
>
)
>
dtls_data_callback
)
:
dtls_data_callback_
(
std
:
:
move
(
dtls_data_callback
)
)
{
}
DtlsStunPiggybackController
:
:
~
DtlsStunPiggybackController
(
)
{
}
void
DtlsStunPiggybackController
:
:
SetDtlsHandshakeComplete
(
bool
is_dtls_client
bool
is_dtls13
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
(
is_dtls_client
&
&
!
is_dtls13
)
|
|
(
!
is_dtls_client
&
&
is_dtls13
)
)
{
pending_packets_
.
clear
(
)
;
}
if
(
state_
=
=
State
:
:
OFF
)
{
return
;
}
state_
=
State
:
:
PENDING
;
}
void
DtlsStunPiggybackController
:
:
SetDtlsFailed
(
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
state_
=
=
State
:
:
TENTATIVE
|
|
state_
=
=
State
:
:
CONFIRMED
|
|
state_
=
=
State
:
:
PENDING
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
DTLS
failed
during
negotiation
.
"
;
}
state_
=
State
:
:
OFF
;
}
void
DtlsStunPiggybackController
:
:
CapturePacket
(
ArrayView
<
const
uint8_t
>
data
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
!
IsDtlsPacket
(
data
)
)
{
return
;
}
if
(
!
writing_packets_
)
{
pending_packets_
.
clear
(
)
;
writing_packets_
=
true
;
}
pending_packets_
.
Add
(
data
)
;
}
void
DtlsStunPiggybackController
:
:
ClearCachedPacketForTesting
(
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
pending_packets_
.
clear
(
)
;
}
void
DtlsStunPiggybackController
:
:
Flush
(
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
writing_packets_
=
false
;
}
std
:
:
optional
<
absl
:
:
string_view
>
DtlsStunPiggybackController
:
:
GetDataToPiggyback
(
StunMessageType
stun_message_type
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
RTC_DCHECK
(
stun_message_type
=
=
STUN_BINDING_REQUEST
|
|
stun_message_type
=
=
STUN_BINDING_RESPONSE
|
|
stun_message_type
=
=
STUN_BINDING_INDICATION
)
;
RTC_DCHECK
(
!
writing_packets_
)
;
if
(
state_
=
=
State
:
:
COMPLETE
)
{
return
std
:
:
nullopt
;
}
if
(
stun_message_type
=
=
STUN_BINDING_INDICATION
)
{
}
else
if
(
state_
=
=
State
:
:
OFF
)
{
return
std
:
:
nullopt
;
}
if
(
pending_packets_
.
empty
(
)
)
{
return
std
:
:
nullopt
;
}
const
auto
packet
=
pending_packets_
.
GetNext
(
)
;
return
absl
:
:
string_view
(
reinterpret_cast
<
const
char
*
>
(
packet
.
data
(
)
)
packet
.
size
(
)
)
;
}
std
:
:
optional
<
const
std
:
:
vector
<
uint32_t
>
>
DtlsStunPiggybackController
:
:
GetAckToPiggyback
(
StunMessageType
stun_message_type
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
state_
=
=
State
:
:
OFF
|
|
state_
=
=
State
:
:
COMPLETE
)
{
return
std
:
:
nullopt
;
}
return
handshake_messages_received_
;
}
void
DtlsStunPiggybackController
:
:
ReportDataPiggybacked
(
std
:
:
optional
<
ArrayView
<
uint8_t
>
>
data
std
:
:
optional
<
std
:
:
vector
<
uint32_t
>
>
acks
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
state_
=
=
State
:
:
OFF
|
|
state_
=
=
State
:
:
COMPLETE
)
{
return
;
}
if
(
state_
=
=
State
:
:
TENTATIVE
&
&
!
data
.
has_value
(
)
&
&
!
acks
.
has_value
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
not
supported
by
peer
.
"
;
state_
=
State
:
:
OFF
;
return
;
}
if
(
state_
=
=
State
:
:
PENDING
&
&
!
data
.
has_value
(
)
&
&
!
acks
.
has_value
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
complete
.
"
;
state_
=
State
:
:
COMPLETE
;
pending_packets_
.
clear
(
)
;
handshake_messages_received_
.
clear
(
)
;
return
;
}
if
(
state_
=
=
State
:
:
TENTATIVE
)
{
state_
=
State
:
:
CONFIRMED
;
}
if
(
acks
.
has_value
(
)
)
{
if
(
!
pending_packets_
.
empty
(
)
)
{
absl
:
:
flat_hash_set
<
uint32_t
>
acked_packets
;
for
(
const
auto
&
ack
:
*
acks
)
{
acked_packets
.
insert
(
ack
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
DTLS
-
STUN
piggybacking
ACK
:
"
<
<
StrJoin
(
acked_packets
"
"
)
;
pending_packets_
.
Prune
(
acked_packets
)
;
}
}
if
(
!
data
.
has_value
(
)
&
&
acks
.
has_value
(
)
&
&
state_
=
=
State
:
:
PENDING
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
complete
.
"
;
state_
=
State
:
:
COMPLETE
;
pending_packets_
.
clear
(
)
;
handshake_messages_received_
.
clear
(
)
;
return
;
}
if
(
!
data
.
has_value
(
)
|
|
data
-
>
size
(
)
=
=
0
)
{
return
;
}
if
(
!
IsDtlsPacket
(
*
data
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Dropping
non
-
DTLS
data
.
"
;
return
;
}
data_recv_count_
+
+
;
uint32_t
hash
=
ComputeDtlsPacketHash
(
*
data
)
;
if
(
std
:
:
find
(
handshake_messages_received_
.
begin
(
)
handshake_messages_received_
.
end
(
)
hash
)
=
=
handshake_messages_received_
.
end
(
)
)
{
while
(
handshake_messages_received_
.
size
(
)
>
=
kMaxAckSize
)
{
handshake_messages_received_
.
erase
(
handshake_messages_received_
.
begin
(
)
)
;
}
handshake_messages_received_
.
push_back
(
hash
)
;
}
dtls_data_callback_
(
*
data
)
;
}
}
