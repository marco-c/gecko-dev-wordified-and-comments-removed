#
include
"
p2p
/
dtls
/
dtls_stun_piggyback_controller
.
h
"
#
include
<
cstdint
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
p2p
/
dtls
/
dtls_utils
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
string_encode
.
h
"
namespace
cricket
{
DtlsStunPiggybackController
:
:
DtlsStunPiggybackController
(
absl
:
:
AnyInvocable
<
void
(
rtc
:
:
ArrayView
<
const
uint8_t
>
)
>
dtls_data_callback
)
:
dtls_data_callback_
(
std
:
:
move
(
dtls_data_callback
)
)
{
}
DtlsStunPiggybackController
:
:
~
DtlsStunPiggybackController
(
)
{
}
void
DtlsStunPiggybackController
:
:
SetDtlsHandshakeComplete
(
bool
is_dtls_client
bool
is_dtls13
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
(
is_dtls_client
&
&
!
is_dtls13
)
|
|
(
!
is_dtls_client
&
&
is_dtls13
)
)
{
pending_packet_
.
Clear
(
)
;
}
if
(
state_
=
=
State
:
:
OFF
)
{
return
;
}
state_
=
State
:
:
PENDING
;
}
void
DtlsStunPiggybackController
:
:
CapturePacket
(
rtc
:
:
ArrayView
<
const
uint8_t
>
data
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
!
IsDtlsPacket
(
data
)
)
{
return
;
}
if
(
!
writing_packets_
)
{
pending_packet_
.
Clear
(
)
;
writing_packets_
=
true
;
}
pending_packet_
.
SetData
(
data
)
;
}
void
DtlsStunPiggybackController
:
:
ClearCachedPacketForTesting
(
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
pending_packet_
.
Clear
(
)
;
}
void
DtlsStunPiggybackController
:
:
Flush
(
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
writing_packets_
=
false
;
}
std
:
:
optional
<
absl
:
:
string_view
>
DtlsStunPiggybackController
:
:
GetDataToPiggyback
(
StunMessageType
stun_message_type
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
RTC_DCHECK
(
stun_message_type
=
=
STUN_BINDING_REQUEST
|
|
stun_message_type
=
=
STUN_BINDING_RESPONSE
|
|
stun_message_type
=
=
STUN_BINDING_INDICATION
)
;
RTC_DCHECK
(
!
writing_packets_
)
;
if
(
state_
=
=
State
:
:
COMPLETE
)
{
return
std
:
:
nullopt
;
}
if
(
stun_message_type
=
=
STUN_BINDING_INDICATION
)
{
}
else
if
(
state_
=
=
State
:
:
OFF
)
{
return
std
:
:
nullopt
;
}
if
(
pending_packet_
.
size
(
)
=
=
0
)
{
return
std
:
:
nullopt
;
}
return
absl
:
:
string_view
(
pending_packet_
)
;
}
std
:
:
optional
<
absl
:
:
string_view
>
DtlsStunPiggybackController
:
:
GetAckToPiggyback
(
StunMessageType
stun_message_type
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
state_
=
=
State
:
:
OFF
|
|
state_
=
=
State
:
:
COMPLETE
)
{
return
std
:
:
nullopt
;
}
return
handshake_ack_writer_
.
DataAsStringView
(
)
;
}
void
DtlsStunPiggybackController
:
:
ReportDataPiggybacked
(
const
StunByteStringAttribute
*
data
const
StunByteStringAttribute
*
ack
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
data_recv_count_
+
=
(
data
!
=
nullptr
)
;
if
(
state_
=
=
State
:
:
OFF
|
|
state_
=
=
State
:
:
COMPLETE
)
{
return
;
}
if
(
state_
=
=
State
:
:
TENTATIVE
&
&
data
=
=
nullptr
&
&
ack
=
=
nullptr
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
not
supported
by
peer
.
"
;
state_
=
State
:
:
OFF
;
return
;
}
if
(
state_
=
=
State
:
:
PENDING
&
&
data
=
=
nullptr
&
&
ack
=
=
nullptr
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
complete
.
"
;
state_
=
State
:
:
COMPLETE
;
pending_packet_
.
Clear
(
)
;
handshake_ack_writer_
.
Clear
(
)
;
handshake_messages_received_
.
clear
(
)
;
return
;
}
if
(
state_
=
=
State
:
:
TENTATIVE
)
{
state_
=
State
:
:
CONFIRMED
;
}
if
(
ack
!
=
nullptr
&
&
!
ack
-
>
string_view
(
)
.
empty
(
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
DTLS
-
STUN
piggybacking
ACK
:
"
<
<
webrtc
:
:
hex_encode
(
ack
-
>
string_view
(
)
)
;
}
if
(
data
=
=
nullptr
&
&
ack
!
=
nullptr
&
&
state_
=
=
State
:
:
PENDING
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
DTLS
-
STUN
piggybacking
complete
.
"
;
state_
=
State
:
:
COMPLETE
;
pending_packet_
.
Clear
(
)
;
handshake_ack_writer_
.
Clear
(
)
;
handshake_messages_received_
.
clear
(
)
;
return
;
}
if
(
!
data
|
|
data
-
>
length
(
)
=
=
0
)
{
return
;
}
std
:
:
optional
<
std
:
:
vector
<
uint16_t
>
>
new_message_sequences
=
GetDtlsHandshakeAcks
(
data
-
>
array_view
(
)
)
;
if
(
!
new_message_sequences
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
DTLS
-
STUN
piggybacking
failed
to
parse
DTLS
packet
.
"
;
return
;
}
if
(
!
new_message_sequences
-
>
empty
(
)
)
{
for
(
const
auto
&
message_seq
:
*
new_message_sequences
)
{
handshake_messages_received_
.
insert
(
message_seq
)
;
}
handshake_ack_writer_
.
Clear
(
)
;
for
(
const
auto
&
message_seq
:
handshake_messages_received_
)
{
handshake_ack_writer_
.
WriteUInt16
(
message_seq
)
;
}
}
dtls_data_callback_
(
data
-
>
array_view
(
)
)
;
}
}
