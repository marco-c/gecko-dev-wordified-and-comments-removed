#
include
"
p2p
/
base
/
regathering_controller
.
h
"
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
p2p
/
base
/
fake_port_allocator
.
h
"
#
include
"
p2p
/
base
/
mock_ice_transport
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
port
.
h
"
#
include
"
p2p
/
base
/
stun_server
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
ref_counted_object
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
namespace
{
const
int
kOnlyLocalPorts
=
cricket
:
:
PORTALLOCATOR_DISABLE_STUN
|
cricket
:
:
PORTALLOCATOR_DISABLE_RELAY
|
cricket
:
:
PORTALLOCATOR_DISABLE_TCP
;
const
rtc
:
:
SocketAddress
kStunAddr
(
"
99
.
99
.
99
.
1
"
cricket
:
:
STUN_SERVER_PORT
)
;
const
rtc
:
:
SocketAddress
kTurnUdpIntAddr
(
"
99
.
99
.
99
.
3
"
cricket
:
:
STUN_SERVER_PORT
)
;
const
cricket
:
:
RelayCredentials
kRelayCredentials
(
"
test
"
"
test
"
)
;
const
char
kIceUfrag
[
]
=
"
UF00
"
;
const
char
kIcePwd
[
]
=
"
TESTICEPWD00000000000000
"
;
}
namespace
webrtc
{
class
RegatheringControllerTest
:
public
:
:
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
RegatheringControllerTest
(
)
:
vss_
(
new
rtc
:
:
VirtualSocketServer
(
)
)
thread_
(
vss_
.
get
(
)
)
ice_transport_
(
new
cricket
:
:
MockIceTransport
(
)
)
allocator_
(
new
cricket
:
:
FakePortAllocator
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
)
{
BasicRegatheringController
:
:
Config
regathering_config
;
regathering_config
.
regather_on_failed_networks_interval
=
0
;
regathering_controller_
.
reset
(
new
BasicRegatheringController
(
regathering_config
ice_transport_
.
get
(
)
rtc
:
:
Thread
:
:
Current
(
)
)
)
;
}
void
InitializeAndGatherOnce
(
)
{
cricket
:
:
ServerAddresses
stun_servers
;
stun_servers
.
insert
(
kStunAddr
)
;
cricket
:
:
RelayServerConfig
turn_server
;
turn_server
.
credentials
=
kRelayCredentials
;
turn_server
.
ports
.
push_back
(
cricket
:
:
ProtocolAddress
(
kTurnUdpIntAddr
cricket
:
:
PROTO_UDP
)
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
(
1
turn_server
)
;
allocator_
-
>
set_flags
(
kOnlyLocalPorts
)
;
allocator_
-
>
SetConfiguration
(
stun_servers
turn_servers
0
webrtc
:
:
NO_PRUNE
)
;
allocator_session_
=
allocator_
-
>
CreateSession
(
"
test
"
cricket
:
:
ICE_CANDIDATE_COMPONENT_RTP
kIceUfrag
kIcePwd
)
;
allocator_session_
-
>
StartGettingPorts
(
)
;
allocator_session_
-
>
SignalIceRegathering
.
connect
(
this
&
RegatheringControllerTest
:
:
OnIceRegathering
)
;
regathering_controller_
-
>
set_allocator_session
(
allocator_session_
.
get
(
)
)
;
}
void
InitializeAndGatherOnceWithSessionCleared
(
)
{
InitializeAndGatherOnce
(
)
;
allocator_session_
-
>
ClearGettingPorts
(
)
;
}
void
OnIceRegathering
(
cricket
:
:
PortAllocatorSession
*
allocator_session
cricket
:
:
IceRegatheringReason
reason
)
{
+
+
count_
[
reason
]
;
}
int
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
reason
)
{
return
count_
[
reason
]
;
}
BasicRegatheringController
*
regathering_controller
(
)
{
return
regathering_controller_
.
get
(
)
;
}
private
:
std
:
:
unique_ptr
<
rtc
:
:
VirtualSocketServer
>
vss_
;
rtc
:
:
AutoSocketServerThread
thread_
;
std
:
:
unique_ptr
<
cricket
:
:
IceTransportInternal
>
ice_transport_
;
std
:
:
unique_ptr
<
BasicRegatheringController
>
regathering_controller_
;
std
:
:
unique_ptr
<
cricket
:
:
PortAllocator
>
allocator_
;
std
:
:
unique_ptr
<
cricket
:
:
PortAllocatorSession
>
allocator_session_
;
std
:
:
map
<
cricket
:
:
IceRegatheringReason
int
>
count_
;
}
;
TEST_F
(
RegatheringControllerTest
IceRegatheringDoesNotOccurIfSessionNotCleared
)
{
rtc
:
:
ScopedFakeClock
clock
;
InitializeAndGatherOnce
(
)
;
BasicRegatheringController
:
:
Config
config
;
config
.
regather_on_failed_networks_interval
=
2000
;
regathering_controller
(
)
-
>
SetConfig
(
config
)
;
regathering_controller
(
)
-
>
Start
(
)
;
SIMULATED_WAIT
(
false
10000
clock
)
;
EXPECT_EQ
(
0
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
}
TEST_F
(
RegatheringControllerTest
IceRegatheringRepeatsAsScheduled
)
{
rtc
:
:
ScopedFakeClock
clock
;
InitializeAndGatherOnceWithSessionCleared
(
)
;
BasicRegatheringController
:
:
Config
config
;
config
.
regather_on_failed_networks_interval
=
2000
;
regathering_controller
(
)
-
>
SetConfig
(
config
)
;
regathering_controller
(
)
-
>
Start
(
)
;
SIMULATED_WAIT
(
false
2000
-
1
clock
)
;
EXPECT_EQ
(
0
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
SIMULATED_WAIT
(
false
2
clock
)
;
EXPECT_EQ
(
1
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
SIMULATED_WAIT
(
false
11000
clock
)
;
EXPECT_EQ
(
6
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
}
TEST_F
(
RegatheringControllerTest
ScheduleOfIceRegatheringOnFailedNetworksCanBeReplaced
)
{
rtc
:
:
ScopedFakeClock
clock
;
InitializeAndGatherOnceWithSessionCleared
(
)
;
BasicRegatheringController
:
:
Config
config
;
config
.
regather_on_failed_networks_interval
=
2000
;
regathering_controller
(
)
-
>
SetConfig
(
config
)
;
regathering_controller
(
)
-
>
Start
(
)
;
config
.
regather_on_failed_networks_interval
=
5000
;
regathering_controller
(
)
-
>
SetConfig
(
config
)
;
SIMULATED_WAIT
(
false
3000
clock
)
;
EXPECT_EQ
(
0
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
SIMULATED_WAIT
(
false
11000
-
3000
clock
)
;
EXPECT_EQ
(
2
GetRegatheringReasonCount
(
cricket
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
}
}
