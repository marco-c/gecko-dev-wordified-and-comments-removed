#
include
"
p2p
/
base
/
tcp_port
.
h
"
#
include
<
list
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
helpers
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
#
include
"
test
/
gtest
.
h
"
using
cricket
:
:
Connection
;
using
cricket
:
:
ICE_PWD_LENGTH
;
using
cricket
:
:
ICE_UFRAG_LENGTH
;
using
cricket
:
:
Port
;
using
cricket
:
:
TCPPort
;
using
rtc
:
:
SocketAddress
;
static
int
kTimeout
=
1000
;
static
const
SocketAddress
kLocalAddr
(
"
11
.
11
.
11
.
11
"
0
)
;
static
const
SocketAddress
kLocalIPv6Addr
(
"
2401
:
fa00
:
4
:
1000
:
be30
:
5bff
:
fee5
:
c3
"
0
)
;
static
const
SocketAddress
kAlternateLocalAddr
(
"
1
.
2
.
3
.
4
"
0
)
;
static
const
SocketAddress
kRemoteAddr
(
"
22
.
22
.
22
.
22
"
0
)
;
static
const
SocketAddress
kRemoteIPv6Addr
(
"
2401
:
fa00
:
4
:
1000
:
be30
:
5bff
:
fee5
:
c4
"
0
)
;
class
ConnectionObserver
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
ConnectionObserver
(
Connection
*
conn
)
{
conn
-
>
SignalDestroyed
.
connect
(
this
&
ConnectionObserver
:
:
OnDestroyed
)
;
}
bool
connection_destroyed
(
)
{
return
connection_destroyed_
;
}
private
:
void
OnDestroyed
(
Connection
*
)
{
connection_destroyed_
=
true
;
}
bool
connection_destroyed_
=
false
;
}
;
class
TCPPortTest
:
public
:
:
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
TCPPortTest
(
)
:
ss_
(
new
rtc
:
:
VirtualSocketServer
(
)
)
main_
(
ss_
.
get
(
)
)
socket_factory_
(
rtc
:
:
Thread
:
:
Current
(
)
)
username_
(
rtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
)
password_
(
rtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
)
{
}
rtc
:
:
Network
*
MakeNetwork
(
const
SocketAddress
&
addr
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
addr
.
ipaddr
(
)
)
;
return
&
networks_
.
back
(
)
;
}
std
:
:
unique_ptr
<
TCPPort
>
CreateTCPPort
(
const
SocketAddress
&
addr
)
{
return
std
:
:
unique_ptr
<
TCPPort
>
(
TCPPort
:
:
Create
(
&
main_
&
socket_factory_
MakeNetwork
(
addr
)
0
0
username_
password_
true
)
)
;
}
std
:
:
unique_ptr
<
TCPPort
>
CreateTCPPort
(
rtc
:
:
Network
*
network
)
{
return
std
:
:
unique_ptr
<
TCPPort
>
(
TCPPort
:
:
Create
(
&
main_
&
socket_factory_
network
0
0
username_
password_
true
)
)
;
}
protected
:
std
:
:
list
<
rtc
:
:
Network
>
networks_
;
std
:
:
unique_ptr
<
rtc
:
:
VirtualSocketServer
>
ss_
;
rtc
:
:
AutoSocketServerThread
main_
;
rtc
:
:
BasicPacketSocketFactory
socket_factory_
;
std
:
:
string
username_
;
std
:
:
string
password_
;
}
;
TEST_F
(
TCPPortTest
TestTCPPortWithLocalhostAddress
)
{
SocketAddress
local_address
(
"
127
.
0
.
0
.
1
"
0
)
;
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr
.
ipaddr
(
)
local_address
.
ipaddr
(
)
)
;
auto
local_port
=
CreateTCPPort
(
kLocalAddr
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteAddr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_TRUE_WAIT
(
conn
-
>
connected
(
)
kTimeout
)
;
ASSERT_EQ
(
local_address
.
ipaddr
(
)
local_port
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
TCPPortTest
TCPPortDiscardedIfBoundAddressDoesNotMatchNetwork
)
{
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr
.
ipaddr
(
)
kAlternateLocalAddr
.
ipaddr
(
)
)
;
auto
local_port
=
CreateTCPPort
(
kLocalAddr
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteAddr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ConnectionObserver
observer
(
conn
)
;
EXPECT_TRUE_WAIT
(
observer
.
connection_destroyed
(
)
kTimeout
)
;
}
TEST_F
(
TCPPortTest
TCPPortNotDiscardedIfNotBoundToBestIP
)
{
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr
.
ipaddr
(
)
kAlternateLocalAddr
.
ipaddr
(
)
)
;
rtc
:
:
Network
*
network
=
MakeNetwork
(
kLocalAddr
)
;
network
-
>
AddIP
(
kAlternateLocalAddr
.
ipaddr
(
)
)
;
ASSERT_EQ
(
kLocalAddr
.
ipaddr
(
)
network
-
>
GetBestIP
(
)
)
;
auto
local_port
=
CreateTCPPort
(
network
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteAddr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_TRUE_WAIT
(
conn
-
>
connected
(
)
kTimeout
)
;
ASSERT_EQ
(
kAlternateLocalAddr
.
ipaddr
(
)
local_port
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
TCPPortTest
TCPPortNotDiscardedIfBoundToTemporaryIP
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
kLocalIPv6Addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
rtc
:
:
InterfaceAddress
(
kLocalIPv6Addr
.
ipaddr
(
)
rtc
:
:
IPV6_ADDRESS_FLAG_TEMPORARY
)
)
;
auto
local_port
=
CreateTCPPort
(
&
networks_
.
back
(
)
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteIPv6Addr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_NE
(
nullptr
conn
)
;
EXPECT_TRUE_WAIT
(
conn
-
>
connected
(
)
kTimeout
)
;
}
class
SentPacketCounter
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
SentPacketCounter
(
TCPPort
*
p
)
{
p
-
>
SignalSentPacket
.
connect
(
this
&
SentPacketCounter
:
:
OnSentPacket
)
;
}
int
sent_packets
(
)
const
{
return
sent_packets_
;
}
private
:
void
OnSentPacket
(
const
rtc
:
:
SentPacket
&
)
{
+
+
sent_packets_
;
}
int
sent_packets_
=
0
;
}
;
TEST_F
(
TCPPortTest
SignalSentPacket
)
{
std
:
:
unique_ptr
<
TCPPort
>
client
(
CreateTCPPort
(
kLocalAddr
)
)
;
std
:
:
unique_ptr
<
TCPPort
>
server
(
CreateTCPPort
(
kRemoteAddr
)
)
;
client
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
server
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
client
-
>
PrepareAddress
(
)
;
server
-
>
PrepareAddress
(
)
;
Connection
*
client_conn
=
client
-
>
CreateConnection
(
server
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_NE
(
nullptr
client_conn
)
;
ASSERT_TRUE_WAIT
(
client_conn
-
>
connected
(
)
kTimeout
)
;
cricket
:
:
Candidate
client_candidate
=
client
-
>
Candidates
(
)
[
0
]
;
client_candidate
.
set_address
(
static_cast
<
cricket
:
:
TCPConnection
*
>
(
client_conn
)
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
Connection
*
server_conn
=
server
-
>
CreateConnection
(
client_candidate
Port
:
:
ORIGIN_THIS_PORT
)
;
ASSERT_NE
(
nullptr
server_conn
)
;
ASSERT_TRUE_WAIT
(
server_conn
-
>
connected
(
)
kTimeout
)
;
client_conn
-
>
Ping
(
rtc
:
:
TimeMillis
(
)
)
;
server_conn
-
>
Ping
(
rtc
:
:
TimeMillis
(
)
)
;
ASSERT_TRUE_WAIT
(
client_conn
-
>
writable
(
)
kTimeout
)
;
ASSERT_TRUE_WAIT
(
server_conn
-
>
writable
(
)
kTimeout
)
;
SentPacketCounter
client_counter
(
client
.
get
(
)
)
;
SentPacketCounter
server_counter
(
server
.
get
(
)
)
;
static
const
char
kData
[
]
=
"
hello
"
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
client_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
;
server_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
;
}
EXPECT_EQ_WAIT
(
10
client_counter
.
sent_packets
(
)
kTimeout
)
;
EXPECT_EQ_WAIT
(
10
server_counter
.
sent_packets
(
)
kTimeout
)
;
}
