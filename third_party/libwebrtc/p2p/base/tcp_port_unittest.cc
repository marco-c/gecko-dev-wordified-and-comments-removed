#
include
"
p2p
/
base
/
tcp_port
.
h
"
#
include
<
cstdint
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
test
/
rtc_error_matchers
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
port
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
scoped_key_value_config
.
h
"
#
include
"
test
/
wait_until
.
h
"
using
cricket
:
:
Connection
;
using
cricket
:
:
ICE_PWD_LENGTH
;
using
cricket
:
:
ICE_UFRAG_LENGTH
;
using
cricket
:
:
Port
;
using
cricket
:
:
TCPPort
;
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
IsTrue
;
using
:
:
webrtc
:
:
SocketAddress
;
static
int
kTimeout
=
1000
;
static
const
SocketAddress
kLocalAddr
(
"
11
.
11
.
11
.
11
"
0
)
;
static
const
SocketAddress
kLocalIPv6Addr
(
"
2401
:
fa00
:
4
:
1000
:
be30
:
5bff
:
fee5
:
c3
"
0
)
;
static
const
SocketAddress
kAlternateLocalAddr
(
"
1
.
2
.
3
.
4
"
0
)
;
static
const
SocketAddress
kRemoteAddr
(
"
22
.
22
.
22
.
22
"
0
)
;
static
const
SocketAddress
kRemoteIPv6Addr
(
"
2401
:
fa00
:
4
:
1000
:
be30
:
5bff
:
fee5
:
c4
"
0
)
;
constexpr
uint64_t
kTiebreakerDefault
=
44444
;
class
ConnectionObserver
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
ConnectionObserver
(
Connection
*
conn
)
:
conn_
(
conn
)
{
conn
-
>
SignalDestroyed
.
connect
(
this
&
ConnectionObserver
:
:
OnDestroyed
)
;
}
~
ConnectionObserver
(
)
{
if
(
!
connection_destroyed_
)
{
RTC_DCHECK
(
conn_
)
;
conn_
-
>
SignalDestroyed
.
disconnect
(
this
)
;
}
}
bool
connection_destroyed
(
)
{
return
connection_destroyed_
;
}
private
:
void
OnDestroyed
(
Connection
*
)
{
connection_destroyed_
=
true
;
}
Connection
*
const
conn_
;
bool
connection_destroyed_
=
false
;
}
;
class
TCPPortTest
:
public
:
:
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
TCPPortTest
(
)
:
ss_
(
new
webrtc
:
:
VirtualSocketServer
(
)
)
main_
(
ss_
.
get
(
)
)
socket_factory_
(
ss_
.
get
(
)
)
username_
(
webrtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
)
password_
(
webrtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
)
{
}
webrtc
:
:
Network
*
MakeNetwork
(
const
SocketAddress
&
addr
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
addr
.
ipaddr
(
)
)
;
return
&
networks_
.
back
(
)
;
}
std
:
:
unique_ptr
<
TCPPort
>
CreateTCPPort
(
const
SocketAddress
&
addr
bool
allow_listen
=
true
int
port_number
=
0
)
{
auto
port
=
std
:
:
unique_ptr
<
TCPPort
>
(
TCPPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
&
socket_factory_
.
network
=
MakeNetwork
(
addr
)
.
ice_username_fragment
=
username_
.
ice_password
=
password_
.
field_trials
=
&
field_trials_
}
port_number
port_number
allow_listen
)
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
std
:
:
unique_ptr
<
TCPPort
>
CreateTCPPort
(
const
webrtc
:
:
Network
*
network
)
{
auto
port
=
std
:
:
unique_ptr
<
TCPPort
>
(
TCPPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
&
socket_factory_
.
network
=
network
.
ice_username_fragment
=
username_
.
ice_password
=
password_
.
field_trials
=
&
field_trials_
}
0
0
true
)
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
protected
:
std
:
:
list
<
webrtc
:
:
Network
>
networks_
;
std
:
:
unique_ptr
<
webrtc
:
:
VirtualSocketServer
>
ss_
;
webrtc
:
:
AutoSocketServerThread
main_
;
webrtc
:
:
BasicPacketSocketFactory
socket_factory_
;
std
:
:
string
username_
;
std
:
:
string
password_
;
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials_
;
}
;
TEST_F
(
TCPPortTest
TestTCPPortWithLocalhostAddress
)
{
SocketAddress
local_address
(
"
127
.
0
.
0
.
1
"
0
)
;
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr
.
ipaddr
(
)
local_address
.
ipaddr
(
)
)
;
auto
local_port
=
CreateTCPPort
(
kLocalAddr
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteAddr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
local_address
.
ipaddr
(
)
local_port
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
TCPPortTest
TCPPortDiscardedIfBoundAddressDoesNotMatchNetwork
)
{
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr
.
ipaddr
(
)
kAlternateLocalAddr
.
ipaddr
(
)
)
;
auto
local_port
=
CreateTCPPort
(
kLocalAddr
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteAddr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ConnectionObserver
observer
(
conn
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
observer
.
connection_destroyed
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
TCPPortTest
TCPPortNotDiscardedIfNotBoundToBestIP
)
{
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr
.
ipaddr
(
)
kAlternateLocalAddr
.
ipaddr
(
)
)
;
webrtc
:
:
Network
*
network
=
MakeNetwork
(
kLocalAddr
)
;
network
-
>
AddIP
(
kAlternateLocalAddr
.
ipaddr
(
)
)
;
ASSERT_EQ
(
kLocalAddr
.
ipaddr
(
)
network
-
>
GetBestIP
(
)
)
;
auto
local_port
=
CreateTCPPort
(
network
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteAddr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
kAlternateLocalAddr
.
ipaddr
(
)
local_port
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
TCPPortTest
TCPPortNotDiscardedIfBoundToTemporaryIP
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
kLocalIPv6Addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
webrtc
:
:
InterfaceAddress
(
kLocalIPv6Addr
.
ipaddr
(
)
webrtc
:
:
IPV6_ADDRESS_FLAG_TEMPORARY
)
)
;
auto
local_port
=
CreateTCPPort
(
&
networks_
.
back
(
)
)
;
auto
remote_port
=
CreateTCPPort
(
kRemoteIPv6Addr
)
;
local_port
-
>
PrepareAddress
(
)
;
remote_port
-
>
PrepareAddress
(
)
;
Connection
*
conn
=
local_port
-
>
CreateConnection
(
remote_port
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_NE
(
nullptr
conn
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
class
SentPacketCounter
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
SentPacketCounter
(
TCPPort
*
p
)
{
p
-
>
SignalSentPacket
.
connect
(
this
&
SentPacketCounter
:
:
OnSentPacket
)
;
}
int
sent_packets
(
)
const
{
return
sent_packets_
;
}
private
:
void
OnSentPacket
(
const
rtc
:
:
SentPacket
&
)
{
+
+
sent_packets_
;
}
int
sent_packets_
=
0
;
}
;
TEST_F
(
TCPPortTest
SignalSentPacket
)
{
std
:
:
unique_ptr
<
TCPPort
>
client
(
CreateTCPPort
(
kLocalAddr
)
)
;
std
:
:
unique_ptr
<
TCPPort
>
server
(
CreateTCPPort
(
kRemoteAddr
)
)
;
client
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
server
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
client
-
>
PrepareAddress
(
)
;
server
-
>
PrepareAddress
(
)
;
Connection
*
client_conn
=
client
-
>
CreateConnection
(
server
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_NE
(
nullptr
client_conn
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
Candidate
client_candidate
=
client
-
>
Candidates
(
)
[
0
]
;
client_candidate
.
set_address
(
static_cast
<
cricket
:
:
TCPConnection
*
>
(
client_conn
)
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
Connection
*
server_conn
=
server
-
>
CreateConnection
(
client_candidate
Port
:
:
ORIGIN_THIS_PORT
)
;
ASSERT_NE
(
nullptr
server_conn
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
server_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
client_conn
-
>
Ping
(
webrtc
:
:
TimeMillis
(
)
)
;
server_conn
-
>
Ping
(
webrtc
:
:
TimeMillis
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_conn
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
server_conn
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SentPacketCounter
client_counter
(
client
.
get
(
)
)
;
SentPacketCounter
server_counter
(
server
.
get
(
)
)
;
static
const
char
kData
[
]
=
"
hello
"
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
client_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
;
server_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_counter
.
sent_packets
(
)
;
}
Eq
(
10
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
server_counter
.
sent_packets
(
)
;
}
Eq
(
10
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
TCPPortTest
SignalSentPacketAfterReconnect
)
{
std
:
:
unique_ptr
<
TCPPort
>
client
(
CreateTCPPort
(
kLocalAddr
false
)
)
;
constexpr
int
kServerPort
=
123
;
std
:
:
unique_ptr
<
TCPPort
>
server
(
CreateTCPPort
(
kRemoteAddr
true
kServerPort
)
)
;
client
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
server
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
client
-
>
PrepareAddress
(
)
;
server
-
>
PrepareAddress
(
)
;
Connection
*
client_conn
=
client
-
>
CreateConnection
(
server
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_NE
(
nullptr
client_conn
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
Candidate
client_candidate
=
client
-
>
Candidates
(
)
[
0
]
;
client_candidate
.
set_address
(
static_cast
<
cricket
:
:
TCPConnection
*
>
(
client_conn
)
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
client_candidate
.
set_tcptype
(
"
"
)
;
Connection
*
server_conn
=
server
-
>
CreateConnection
(
client_candidate
Port
:
:
ORIGIN_THIS_PORT
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
server_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
client_conn
-
>
writable
(
)
)
;
client_conn
-
>
Ping
(
webrtc
:
:
TimeMillis
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_conn
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SentPacketCounter
client_counter
(
client
.
get
(
)
)
;
static
const
char
kData
[
]
=
"
hello
"
;
int
result
=
client_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
;
EXPECT_EQ
(
result
6
)
;
server
=
nullptr
;
server_conn
=
nullptr
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
client_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
server
=
CreateTCPPort
(
kRemoteAddr
true
kServerPort
)
;
server
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
server
-
>
PrepareAddress
(
)
;
result
=
client_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
;
EXPECT_EQ
(
result
SOCKET_ERROR
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
client_conn
-
>
writable
(
)
)
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
EXPECT_EQ
(
client_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
SOCKET_ERROR
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_counter
.
sent_packets
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
client_candidate
=
client
-
>
Candidates
(
)
[
0
]
;
client_candidate
.
set_address
(
static_cast
<
cricket
:
:
TCPConnection
*
>
(
client_conn
)
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
client_candidate
.
set_tcptype
(
"
"
)
;
server_conn
=
server
-
>
CreateConnection
(
client_candidate
Port
:
:
ORIGIN_THIS_PORT
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
server_conn
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_counter
.
sent_packets
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
client_conn
-
>
Ping
(
webrtc
:
:
TimeMillis
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_counter
.
sent_packets
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
100
)
;
for
(
int
i
=
0
;
i
<
5
;
+
+
i
)
{
EXPECT_EQ
(
client_conn
-
>
Send
(
&
kData
sizeof
(
kData
)
rtc
:
:
PacketOptions
(
)
)
6
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
client_counter
.
sent_packets
(
)
;
}
Eq
(
2
+
5
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
