#
ifndef
P2P_BASE_PORT_H_
#
define
P2P_BASE_PORT_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
local_network_access_permission
.
h
"
#
include
"
api
/
packet_socket_factory
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
p2p
/
base
/
candidate_pair_interface
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
callback_list
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
weak_ptr
.
h
"
namespace
webrtc
{
extern
const
int
DISCARD_PORT
;
extern
const
char
TCPTYPE_ACTIVE_STR
[
]
;
extern
const
char
TCPTYPE_PASSIVE_STR
[
]
;
extern
const
char
TCPTYPE_SIMOPEN_STR
[
]
;
enum
class
MdnsNameRegistrationStatus
{
kNotStarted
kInProgress
kCompleted
}
;
class
StunStats
{
public
:
StunStats
(
)
=
default
;
StunStats
(
const
StunStats
&
)
=
default
;
~
StunStats
(
)
=
default
;
StunStats
&
operator
=
(
const
StunStats
&
other
)
=
default
;
int
stun_binding_requests_sent
=
0
;
int
stun_binding_responses_received
=
0
;
double
stun_binding_rtt_ms_total
=
0
;
double
stun_binding_rtt_ms_squared_total
=
0
;
}
;
class
CandidateStats
{
public
:
CandidateStats
(
)
=
default
;
CandidateStats
(
const
CandidateStats
&
)
=
default
;
CandidateStats
(
CandidateStats
&
&
)
=
default
;
CandidateStats
(
Candidate
candidate
std
:
:
optional
<
StunStats
>
stats
=
std
:
:
nullopt
)
:
candidate_
(
std
:
:
move
(
candidate
)
)
stun_stats_
(
std
:
:
move
(
stats
)
)
{
}
~
CandidateStats
(
)
=
default
;
CandidateStats
&
operator
=
(
const
CandidateStats
&
other
)
=
default
;
const
Candidate
&
candidate
(
)
const
{
return
candidate_
;
}
const
std
:
:
optional
<
StunStats
>
&
stun_stats
(
)
const
{
return
stun_stats_
;
}
private
:
Candidate
candidate_
;
std
:
:
optional
<
StunStats
>
stun_stats_
;
}
;
typedef
std
:
:
vector
<
CandidateStats
>
CandidateStatsList
;
const
char
*
ProtoToString
(
ProtocolType
proto
)
;
std
:
:
optional
<
ProtocolType
>
StringToProto
(
absl
:
:
string_view
proto_name
)
;
struct
ProtocolAddress
{
SocketAddress
address
;
ProtocolType
proto
;
ProtocolAddress
(
const
SocketAddress
&
a
ProtocolType
p
)
:
address
(
a
)
proto
(
p
)
{
}
bool
operator
=
=
(
const
ProtocolAddress
&
o
)
const
{
return
address
=
=
o
.
address
&
&
proto
=
=
o
.
proto
;
}
bool
operator
!
=
(
const
ProtocolAddress
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
struct
IceCandidateErrorEvent
{
IceCandidateErrorEvent
(
)
=
default
;
IceCandidateErrorEvent
(
absl
:
:
string_view
address
int
port
absl
:
:
string_view
url
int
error_code
absl
:
:
string_view
error_text
)
:
address
(
std
:
:
move
(
address
)
)
port
(
port
)
url
(
std
:
:
move
(
url
)
)
error_code
(
error_code
)
error_text
(
std
:
:
move
(
error_text
)
)
{
}
std
:
:
string
address
;
int
port
=
0
;
std
:
:
string
url
;
int
error_code
=
0
;
std
:
:
string
error_text
;
}
;
struct
CandidatePairChangeEvent
{
std
:
:
string
transport_name
;
CandidatePair
selected_candidate_pair
;
int64_t
last_data_received_ms
;
std
:
:
string
reason
;
int64_t
estimated_disconnected_time_ms
;
}
;
typedef
std
:
:
set
<
SocketAddress
>
ServerAddresses
;
class
RTC_EXPORT
Port
:
public
PortInterface
public
sigslot
:
:
has_slots
<
>
{
public
:
struct
PortParametersRef
{
Environment
env
;
TaskQueueBase
*
network_thread
;
PacketSocketFactory
*
socket_factory
;
const
:
:
webrtc
:
:
Network
*
network
;
absl
:
:
string_view
ice_username_fragment
;
absl
:
:
string_view
ice_password
;
LocalNetworkAccessPermissionFactoryInterface
*
lna_permission_factory
=
nullptr
;
}
;
protected
:
Port
(
const
PortParametersRef
&
args
IceCandidateType
type
)
;
Port
(
const
PortParametersRef
&
args
IceCandidateType
type
uint16_t
min_port
uint16_t
max_port
bool
shared_socket
=
false
)
;
public
:
~
Port
(
)
override
;
IceCandidateType
Type
(
)
const
override
;
const
:
:
webrtc
:
:
Network
*
Network
(
)
const
override
;
IceRole
GetIceRole
(
)
const
override
;
void
SetIceRole
(
IceRole
role
)
override
;
void
SetIceTiebreaker
(
uint64_t
tiebreaker
)
override
;
uint64_t
IceTiebreaker
(
)
const
override
;
bool
SharedSocket
(
)
const
override
;
void
ResetSharedSocket
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
shared_socket_
=
false
;
}
void
KeepAliveUntilPruned
(
)
;
void
Prune
(
)
;
void
CancelPendingTasks
(
)
;
TaskQueueBase
*
thread
(
)
override
{
return
thread_
;
}
PacketSocketFactory
*
socket_factory
(
)
const
override
{
return
factory_
;
}
const
std
:
:
string
&
content_name
(
)
const
override
{
return
content_name_
;
}
void
set_content_name
(
absl
:
:
string_view
content_name
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
content_name_
=
std
:
:
string
(
content_name
)
;
}
int
component
(
)
const
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
component_
;
}
void
set_component
(
int
component
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
component_
=
component
;
}
bool
send_retransmit_count_attribute
(
)
const
override
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
send_retransmit_count_attribute_
;
}
void
set_send_retransmit_count_attribute
(
bool
enable
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
send_retransmit_count_attribute_
=
enable
;
}
uint32_t
generation
(
)
const
override
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
generation_
;
}
void
set_generation
(
uint32_t
generation
)
override
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
generation_
=
generation
;
}
const
std
:
:
string
&
username_fragment
(
)
const
;
const
std
:
:
string
&
password
(
)
const
{
return
password_
;
}
void
SetIceParameters
(
int
component
absl
:
:
string_view
username_fragment
absl
:
:
string_view
password
)
;
void
SubscribeCandidateReadyCallback
(
absl
:
:
AnyInvocable
<
void
(
Port
*
const
Candidate
&
)
>
callback
)
;
sigslot
:
:
signal2
<
Port
*
const
Candidate
&
>
SignalCandidateReady
;
const
std
:
:
vector
<
Candidate
>
&
Candidates
(
)
const
override
;
void
SubscribeCandidateError
(
std
:
:
function
<
void
(
Port
*
const
IceCandidateErrorEvent
&
)
>
callback
)
;
void
SendCandidateError
(
const
IceCandidateErrorEvent
&
candidate_error_event
)
;
void
SubscribePortComplete
(
absl
:
:
AnyInvocable
<
void
(
Port
*
)
>
callback
)
;
sigslot
:
:
signal1
<
Port
*
>
SignalPortComplete
;
void
SubscribePortError
(
absl
:
:
AnyInvocable
<
void
(
Port
*
)
>
callback
)
;
sigslot
:
:
signal1
<
Port
*
>
SignalPortError
;
void
SubscribePortDestroyed
(
std
:
:
function
<
void
(
PortInterface
*
)
>
callback
)
override
;
void
SendPortDestroyed
(
Port
*
port
)
;
typedef
std
:
:
map
<
SocketAddress
Connection
*
>
AddressMap
;
const
AddressMap
&
connections
(
)
{
return
connections_
;
}
Connection
*
GetConnection
(
const
SocketAddress
&
remote_addr
)
override
;
void
DestroyConnection
(
Connection
*
conn
)
override
{
DestroyConnectionInternal
(
conn
false
)
;
}
void
DestroyConnectionAsync
(
Connection
*
conn
)
override
{
DestroyConnectionInternal
(
conn
true
)
;
}
virtual
bool
HandleIncomingPacket
(
AsyncPacketSocket
*
socket
const
ReceivedIpPacket
&
packet
)
;
virtual
bool
CanHandleIncomingPacketsFrom
(
const
SocketAddress
&
remote_addr
)
const
;
void
SendBindingErrorResponse
(
StunMessage
*
message
const
SocketAddress
&
addr
int
error_code
absl
:
:
string_view
reason
)
override
;
void
SendUnknownAttributesErrorResponse
(
StunMessage
*
message
const
SocketAddress
&
addr
const
std
:
:
vector
<
uint16_t
>
&
unknown_types
)
;
void
EnablePortPackets
(
)
override
;
void
Destroy
(
)
;
std
:
:
string
ToString
(
)
const
override
;
uint16_t
min_port
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
min_port_
;
}
uint16_t
max_port
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
max_port_
;
}
void
set_timeout_delay
(
int
delay
)
;
bool
ParseStunUsername
(
const
StunMessage
*
stun_msg
std
:
:
string
*
local_username
std
:
:
string
*
remote_username
)
const
override
;
std
:
:
string
CreateStunUsername
(
absl
:
:
string_view
remote_username
)
const
override
;
bool
MaybeIceRoleConflict
(
const
SocketAddress
&
addr
IceMessage
*
stun_msg
absl
:
:
string_view
remote_ufrag
)
override
;
virtual
void
OnSentPacket
(
AsyncPacketSocket
*
socket
const
SentPacketInfo
&
sent_packet
)
=
0
;
void
OnReadyToSend
(
)
;
void
AddPrflxCandidate
(
const
Candidate
&
local
)
override
;
int16_t
network_cost
(
)
const
override
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
network_cost_
;
}
void
GetStunStats
(
std
:
:
optional
<
StunStats
>
*
)
override
{
}
void
SubscribeRoleConflict
(
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
override
;
void
NotifyRoleConflict
(
)
override
;
protected
:
void
UpdateNetworkCost
(
)
override
;
WeakPtr
<
Port
>
NewWeakPtr
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
weak_factory_
.
GetWeakPtr
(
)
;
}
void
AddAddress
(
const
SocketAddress
&
address
const
SocketAddress
&
base_address
const
SocketAddress
&
related_address
absl
:
:
string_view
protocol
absl
:
:
string_view
relay_protocol
absl
:
:
string_view
tcptype
IceCandidateType
type
uint32_t
type_preference
uint32_t
relay_preference
absl
:
:
string_view
url
bool
is_final
)
;
void
FinishAddingAddress
(
const
Candidate
&
c
bool
is_final
)
RTC_RUN_ON
(
thread_
)
;
virtual
void
PostAddAddress
(
bool
is_final
)
;
void
AddOrReplaceConnection
(
Connection
*
conn
)
;
void
OnReadPacket
(
const
ReceivedIpPacket
&
packet
ProtocolType
proto
)
;
[
[
deprecated
(
"
Use
OnReadPacket
(
const
ReceivedIpPacket
&
packet
ProtocolType
"
"
proto
)
"
)
]
]
void
OnReadPacket
(
const
char
*
data
size_t
size
const
SocketAddress
&
addr
ProtocolType
proto
)
{
OnReadPacket
(
ReceivedIpPacket
:
:
CreateFromLegacy
(
data
size
-
1
addr
)
proto
)
;
}
bool
GetStunMessage
(
const
char
*
data
size_t
size
const
SocketAddress
&
addr
std
:
:
unique_ptr
<
IceMessage
>
*
out_msg
std
:
:
string
*
out_username
)
override
;
bool
IsCompatibleAddress
(
const
SocketAddress
&
addr
)
;
DiffServCodePoint
StunDscpValue
(
)
const
override
;
virtual
void
HandleConnectionDestroyed
(
Connection
*
)
{
}
void
DestroyAllConnections
(
)
;
void
CopyPortInformationToPacketInfo
(
PacketInfo
*
info
)
const
;
MdnsNameRegistrationStatus
mdns_name_registration_status
(
)
const
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
mdns_name_registration_status_
;
}
void
set_mdns_name_registration_status
(
MdnsNameRegistrationStatus
status
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
mdns_name_registration_status_
=
status
;
}
const
Environment
&
env
(
)
const
{
return
env_
;
}
IceCandidateType
type
(
)
const
{
return
type_
;
}
void
MaybeRequestLocalNetworkAccessPermission
(
const
SocketAddress
&
address
absl
:
:
AnyInvocable
<
void
(
LocalNetworkAccessPermissionStatus
)
>
callback
)
;
private
:
bool
MaybeObfuscateAddress
(
const
Candidate
&
c
bool
is_final
)
RTC_RUN_ON
(
thread_
)
;
void
PostDestroyIfDead
(
bool
delayed
)
;
void
DestroyIfDead
(
)
;
bool
OnConnectionDestroyed
(
Connection
*
conn
)
;
void
DestroyConnectionInternal
(
Connection
*
conn
bool
async
)
;
void
OnNetworkTypeChanged
(
const
:
:
webrtc
:
:
Network
*
network
)
;
void
OnRequestLocalNetworkAccessPermission
(
LocalNetworkAccessPermissionInterface
*
permission_query
absl
:
:
AnyInvocable
<
void
(
LocalNetworkAccessPermissionStatus
)
>
callback
LocalNetworkAccessPermissionStatus
status
)
;
void
SendCandidateReadyCallbackList
(
Port
*
const
Candidate
&
)
;
void
SendPortCompleteCallbackList
(
Port
*
)
;
void
SendPortErrorCallbackList
(
Port
*
)
;
const
Environment
env_
;
TaskQueueBase
*
const
thread_
;
PacketSocketFactory
*
const
factory_
;
LocalNetworkAccessPermissionFactoryInterface
*
const
lna_permission_factory_
;
const
IceCandidateType
type_
;
bool
send_retransmit_count_attribute_
RTC_GUARDED_BY
(
thread_
)
;
const
:
:
webrtc
:
:
Network
*
network_
;
uint16_t
min_port_
RTC_GUARDED_BY
(
thread_
)
;
uint16_t
max_port_
RTC_GUARDED_BY
(
thread_
)
;
std
:
:
string
content_name_
RTC_GUARDED_BY
(
thread_
)
;
int
component_
RTC_GUARDED_BY
(
thread_
)
;
uint32_t
generation_
RTC_GUARDED_BY
(
thread_
)
;
std
:
:
string
ice_username_fragment_
RTC_GUARDED_BY
(
thread_
)
;
std
:
:
string
password_
RTC_GUARDED_BY
(
thread_
)
;
std
:
:
vector
<
Candidate
>
candidates_
RTC_GUARDED_BY
(
thread_
)
;
AddressMap
connections_
RTC_GUARDED_BY
(
thread_
)
;
int
timeout_delay_
RTC_GUARDED_BY
(
thread_
)
;
bool
enable_port_packets_
RTC_GUARDED_BY
(
thread_
)
;
IceRole
ice_role_
RTC_GUARDED_BY
(
thread_
)
;
uint64_t
tiebreaker_
RTC_GUARDED_BY
(
thread_
)
;
bool
shared_socket_
RTC_GUARDED_BY
(
thread_
)
;
int16_t
network_cost_
RTC_GUARDED_BY
(
thread_
)
;
enum
class
State
{
INIT
KEEP_ALIVE_UNTIL_PRUNED
PRUNED
}
;
State
state_
RTC_GUARDED_BY
(
thread_
)
=
State
:
:
INIT
;
int64_t
last_time_all_connections_removed_
RTC_GUARDED_BY
(
thread_
)
=
0
;
MdnsNameRegistrationStatus
mdns_name_registration_status_
RTC_GUARDED_BY
(
thread_
)
=
MdnsNameRegistrationStatus
:
:
kNotStarted
;
std
:
:
vector
<
std
:
:
unique_ptr
<
LocalNetworkAccessPermissionInterface
>
>
permission_queries_
RTC_GUARDED_BY
(
thread_
)
;
CallbackList
<
PortInterface
*
>
port_destroyed_callback_list_
RTC_GUARDED_BY
(
thread_
)
;
CallbackList
<
Port
*
const
IceCandidateErrorEvent
&
>
candidate_error_callback_list_
RTC_GUARDED_BY
(
thread_
)
;
CallbackList
<
Port
*
const
Candidate
&
>
candidate_ready_callback_list_
RTC_GUARDED_BY
(
thread_
)
;
CallbackList
<
Port
*
>
port_complete_callback_list_
RTC_GUARDED_BY
(
thread_
)
;
CallbackList
<
Port
*
>
port_error_callback_list_
RTC_GUARDED_BY
(
thread_
)
;
absl
:
:
AnyInvocable
<
void
(
)
>
role_conflict_callback_
RTC_GUARDED_BY
(
thread_
)
;
WeakPtrFactory
<
Port
>
weak_factory_
RTC_GUARDED_BY
(
thread_
)
;
}
;
}
#
endif
