#
ifndef
P2P_BASE_DTLS_TRANSPORT_INTERNAL_H_
#
define
P2P_BASE_DTLS_TRANSPORT_INTERNAL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
api
/
crypto
/
crypto_options
.
h
"
#
include
"
api
/
dtls_transport_interface
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
rtc_base
/
callback_list
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
ssl_certificate
.
h
"
#
include
"
rtc_base
/
ssl_fingerprint
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
namespace
cricket
{
enum
DtlsTransportState
{
DTLS_TRANSPORT_NEW
=
static_cast
<
int
>
(
webrtc
:
:
DtlsTransportState
:
:
kNew
)
DTLS_TRANSPORT_CONNECTING
=
static_cast
<
int
>
(
webrtc
:
:
DtlsTransportState
:
:
kConnecting
)
DTLS_TRANSPORT_CONNECTED
=
static_cast
<
int
>
(
webrtc
:
:
DtlsTransportState
:
:
kConnected
)
DTLS_TRANSPORT_CLOSED
=
static_cast
<
int
>
(
webrtc
:
:
DtlsTransportState
:
:
kClosed
)
DTLS_TRANSPORT_FAILED
=
static_cast
<
int
>
(
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
}
;
webrtc
:
:
DtlsTransportState
ConvertDtlsTransportState
(
cricket
:
:
DtlsTransportState
cricket_state
)
;
enum
PacketFlags
{
PF_NORMAL
=
0x00
PF_SRTP_BYPASS
=
0x01
}
;
class
DtlsTransportInternal
:
public
rtc
:
:
PacketTransportInternal
{
public
:
~
DtlsTransportInternal
(
)
override
;
virtual
DtlsTransportState
dtls_state
(
)
const
=
0
;
virtual
int
component
(
)
const
=
0
;
virtual
bool
IsDtlsActive
(
)
const
=
0
;
virtual
bool
GetDtlsRole
(
rtc
:
:
SSLRole
*
role
)
const
=
0
;
virtual
bool
SetDtlsRole
(
rtc
:
:
SSLRole
role
)
=
0
;
virtual
bool
GetSslVersionBytes
(
int
*
version
)
const
=
0
;
virtual
bool
GetSrtpCryptoSuite
(
int
*
cipher
)
=
0
;
virtual
bool
GetSslCipherSuite
(
int
*
cipher
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
GetLocalCertificate
(
)
const
=
0
;
virtual
bool
SetLocalCertificate
(
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
)
=
0
;
virtual
std
:
:
unique_ptr
<
rtc
:
:
SSLCertChain
>
GetRemoteSSLCertChain
(
)
const
=
0
;
virtual
bool
ExportKeyingMaterial
(
const
std
:
:
string
&
label
const
uint8_t
*
context
size_t
context_len
bool
use_context
uint8_t
*
result
size_t
result_len
)
=
0
;
virtual
bool
SetRemoteFingerprint
(
const
std
:
:
string
&
digest_alg
const
uint8_t
*
digest
size_t
digest_len
)
=
0
;
ABSL_DEPRECATED
(
"
Set
the
max
version
via
construction
.
"
)
bool
SetSslMaxProtocolVersion
(
rtc
:
:
SSLProtocolVersion
version
)
{
return
true
;
}
virtual
IceTransportInternal
*
ice_transport
(
)
=
0
;
template
<
typename
F
>
void
SubscribeDtlsState
(
F
&
&
callback
)
{
dtls_state_callback_list_
.
AddReceiver
(
std
:
:
forward
<
F
>
(
callback
)
)
;
}
template
<
typename
F
>
void
SubscribeDtlsState
(
const
void
*
id
F
&
&
callback
)
{
dtls_state_callback_list_
.
AddReceiver
(
id
std
:
:
forward
<
F
>
(
callback
)
)
;
}
void
UnsubscribeDtlsState
(
const
void
*
id
)
{
dtls_state_callback_list_
.
RemoveReceivers
(
id
)
;
}
void
SendDtlsState
(
DtlsTransportInternal
*
transport
DtlsTransportState
state
)
{
dtls_state_callback_list_
.
Send
(
transport
state
)
;
}
template
<
typename
F
>
void
SubscribeDtlsHandshakeError
(
F
&
&
callback
)
{
dtls_handshake_error_callback_list_
.
AddReceiver
(
std
:
:
forward
<
F
>
(
callback
)
)
;
}
void
SendDtlsHandshakeError
(
rtc
:
:
SSLHandshakeError
error
)
{
dtls_handshake_error_callback_list_
.
Send
(
error
)
;
}
protected
:
DtlsTransportInternal
(
)
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
DtlsTransportInternal
)
;
webrtc
:
:
CallbackList
<
const
rtc
:
:
SSLHandshakeError
>
dtls_handshake_error_callback_list_
;
webrtc
:
:
CallbackList
<
DtlsTransportInternal
*
const
DtlsTransportState
>
dtls_state_callback_list_
;
}
;
}
#
endif
