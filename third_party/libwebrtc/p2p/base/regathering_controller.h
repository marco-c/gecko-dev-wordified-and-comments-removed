#
ifndef
P2P_BASE_REGATHERING_CONTROLLER_H_
#
define
P2P_BASE_REGATHERING_CONTROLLER_H_
#
include
<
memory
>
#
include
<
optional
>
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
class
BasicRegatheringController
:
public
sigslot
:
:
has_slots
<
>
{
public
:
struct
Config
{
int
regather_on_failed_networks_interval
=
cricket
:
:
REGATHER_ON_FAILED_NETWORKS_INTERVAL
;
}
;
BasicRegatheringController
(
)
=
delete
;
BasicRegatheringController
(
const
Config
&
config
IceTransportInternal
*
ice_transport
Thread
*
thread
)
;
~
BasicRegatheringController
(
)
override
;
void
Start
(
)
;
void
set_allocator_session
(
PortAllocatorSession
*
allocator_session
)
{
allocator_session_
=
allocator_session
;
}
void
SetConfig
(
const
Config
&
config
)
;
private
:
void
OnIceTransportStateChanged
(
IceTransportInternal
*
)
{
}
void
OnIceTransportWritableState
(
PacketTransportInternal
*
)
{
}
void
OnIceTransportReceivingState
(
PacketTransportInternal
*
)
{
}
void
OnIceTransportNetworkRouteChanged
(
std
:
:
optional
<
NetworkRoute
>
)
{
}
void
ScheduleRecurringRegatheringOnFailedNetworks
(
)
;
void
CancelScheduledRecurringRegatheringOnAllNetworks
(
)
;
std
:
:
unique_ptr
<
ScopedTaskSafety
>
pending_regathering_
;
Config
config_
;
IceTransportInternal
*
ice_transport_
;
PortAllocatorSession
*
allocator_session_
=
nullptr
;
Thread
*
const
thread_
;
}
;
}
#
endif
