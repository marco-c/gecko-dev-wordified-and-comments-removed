#
ifndef
P2P_BASE_REGATHERING_CONTROLLER_H_
#
define
P2P_BASE_REGATHERING_CONTROLLER_H_
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
rtc_base
/
async_invoker
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
class
BasicRegatheringController
:
public
sigslot
:
:
has_slots
<
>
{
public
:
struct
Config
{
int
regather_on_failed_networks_interval
=
cricket
:
:
REGATHER_ON_FAILED_NETWORKS_INTERVAL
;
}
;
BasicRegatheringController
(
)
=
delete
;
BasicRegatheringController
(
const
Config
&
config
cricket
:
:
IceTransportInternal
*
ice_transport
rtc
:
:
Thread
*
thread
)
;
~
BasicRegatheringController
(
)
override
;
void
Start
(
)
;
void
set_allocator_session
(
cricket
:
:
PortAllocatorSession
*
allocator_session
)
{
allocator_session_
=
allocator_session
;
}
void
SetConfig
(
const
Config
&
config
)
;
private
:
void
OnIceTransportStateChanged
(
cricket
:
:
IceTransportInternal
*
)
{
}
void
OnIceTransportWritableState
(
rtc
:
:
PacketTransportInternal
*
)
{
}
void
OnIceTransportReceivingState
(
rtc
:
:
PacketTransportInternal
*
)
{
}
void
OnIceTransportNetworkRouteChanged
(
absl
:
:
optional
<
rtc
:
:
NetworkRoute
>
)
{
}
void
ScheduleRecurringRegatheringOnFailedNetworks
(
)
;
void
CancelScheduledRecurringRegatheringOnAllNetworks
(
)
;
void
CancelScheduledRecurringRegatheringOnFailedNetworks
(
)
;
void
RegatherOnFailedNetworksIfDoneGathering
(
)
;
Config
config_
;
cricket
:
:
IceTransportInternal
*
ice_transport_
;
cricket
:
:
PortAllocatorSession
*
allocator_session_
=
nullptr
;
bool
has_recurring_schedule_on_failed_networks_
=
false
;
rtc
:
:
Thread
*
thread_
;
rtc
:
:
AsyncInvoker
invoker_for_failed_networks_
;
}
;
}
#
endif
