#
ifndef
P2P_BASE_ICE_TRANSPORT_INTERNAL_H_
#
define
P2P_BASE_ICE_TRANSPORT_INTERNAL_H_
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
transport
/
enums
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
p2p
/
base
/
port
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
rtc_base
/
network_constants
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
cricket
{
struct
IceTransportStats
{
CandidateStatsList
candidate_stats_list
;
ConnectionInfos
connection_infos
;
uint32_t
selected_candidate_pair_changes
=
0
;
}
;
typedef
std
:
:
vector
<
Candidate
>
Candidates
;
enum
IceConnectionState
{
kIceConnectionConnecting
=
0
kIceConnectionFailed
kIceConnectionConnected
kIceConnectionCompleted
}
;
enum
IceGatheringState
{
kIceGatheringNew
=
0
kIceGatheringGathering
kIceGatheringComplete
}
;
enum
ContinualGatheringPolicy
{
GATHER_ONCE
=
0
GATHER_CONTINUALLY
}
;
enum
class
NominationMode
{
REGULAR
AGGRESSIVE
SEMI_AGGRESSIVE
}
;
webrtc
:
:
RTCError
VerifyCandidate
(
const
Candidate
&
cand
)
;
webrtc
:
:
RTCError
VerifyCandidates
(
const
Candidates
&
candidates
)
;
struct
IceConfig
{
absl
:
:
optional
<
int
>
receiving_timeout
;
absl
:
:
optional
<
int
>
backup_connection_ping_interval
;
ContinualGatheringPolicy
continual_gathering_policy
=
GATHER_ONCE
;
bool
gather_continually
(
)
const
{
return
continual_gathering_policy
=
=
GATHER_CONTINUALLY
;
}
bool
prioritize_most_likely_candidate_pairs
=
false
;
absl
:
:
optional
<
int
>
stable_writable_connection_ping_interval
;
bool
presume_writable_when_fully_relayed
=
false
;
bool
surface_ice_candidates_on_ice_transport_type_changed
=
false
;
absl
:
:
optional
<
int
>
regather_on_failed_networks_interval
;
absl
:
:
optional
<
int
>
receiving_switching_delay
;
NominationMode
default_nomination_mode
=
NominationMode
:
:
SEMI_AGGRESSIVE
;
absl
:
:
optional
<
int
>
ice_check_interval_strong_connectivity
;
absl
:
:
optional
<
int
>
ice_check_interval_weak_connectivity
;
absl
:
:
optional
<
int
>
ice_check_min_interval
;
absl
:
:
optional
<
int
>
ice_unwritable_timeout
;
absl
:
:
optional
<
int
>
ice_unwritable_min_checks
;
absl
:
:
optional
<
int
>
ice_inactive_timeout
;
absl
:
:
optional
<
int
>
stun_keepalive_interval
;
absl
:
:
optional
<
rtc
:
:
AdapterType
>
network_preference
;
IceConfig
(
)
;
IceConfig
(
int
receiving_timeout_ms
int
backup_connection_ping_interval
ContinualGatheringPolicy
gathering_policy
bool
prioritize_most_likely_candidate_pairs
int
stable_writable_connection_ping_interval_ms
bool
presume_writable_when_fully_relayed
int
regather_on_failed_networks_interval_ms
int
receiving_switching_delay_ms
)
;
~
IceConfig
(
)
;
int
receiving_timeout_or_default
(
)
const
;
int
backup_connection_ping_interval_or_default
(
)
const
;
int
stable_writable_connection_ping_interval_or_default
(
)
const
;
int
regather_on_failed_networks_interval_or_default
(
)
const
;
int
receiving_switching_delay_or_default
(
)
const
;
int
ice_check_interval_strong_connectivity_or_default
(
)
const
;
int
ice_check_interval_weak_connectivity_or_default
(
)
const
;
int
ice_check_min_interval_or_default
(
)
const
;
int
ice_unwritable_timeout_or_default
(
)
const
;
int
ice_unwritable_min_checks_or_default
(
)
const
;
int
ice_inactive_timeout_or_default
(
)
const
;
int
stun_keepalive_interval_or_default
(
)
const
;
}
;
enum
class
IceTransportState
{
STATE_INIT
STATE_CONNECTING
STATE_COMPLETED
STATE_FAILED
}
;
enum
IceProtocolType
{
ICEPROTO_RFC5245
}
;
class
RTC_EXPORT
IceTransportInternal
:
public
rtc
:
:
PacketTransportInternal
{
public
:
IceTransportInternal
(
)
;
~
IceTransportInternal
(
)
override
;
virtual
IceTransportState
GetState
(
)
const
=
0
;
virtual
webrtc
:
:
IceTransportState
GetIceTransportState
(
)
const
=
0
;
virtual
int
component
(
)
const
=
0
;
virtual
IceRole
GetIceRole
(
)
const
=
0
;
virtual
void
SetIceRole
(
IceRole
role
)
=
0
;
virtual
void
SetIceTiebreaker
(
uint64_t
tiebreaker
)
=
0
;
virtual
void
SetIceProtocolType
(
IceProtocolType
type
)
{
}
virtual
void
SetIceCredentials
(
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
;
virtual
void
SetRemoteIceCredentials
(
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
;
virtual
void
SetIceParameters
(
const
IceParameters
&
ice_params
)
=
0
;
virtual
void
SetRemoteIceParameters
(
const
IceParameters
&
ice_params
)
=
0
;
virtual
void
SetRemoteIceMode
(
IceMode
mode
)
=
0
;
virtual
void
SetIceConfig
(
const
IceConfig
&
config
)
=
0
;
virtual
void
MaybeStartGathering
(
)
=
0
;
virtual
void
AddRemoteCandidate
(
const
Candidate
&
candidate
)
=
0
;
virtual
void
RemoveRemoteCandidate
(
const
Candidate
&
candidate
)
=
0
;
virtual
void
RemoveAllRemoteCandidates
(
)
=
0
;
virtual
IceGatheringState
gathering_state
(
)
const
=
0
;
virtual
bool
GetStats
(
IceTransportStats
*
ice_transport_stats
)
=
0
;
virtual
absl
:
:
optional
<
int
>
GetRttEstimate
(
)
=
0
;
virtual
const
Connection
*
selected_connection
(
)
const
=
0
;
virtual
absl
:
:
optional
<
const
CandidatePair
>
GetSelectedCandidatePair
(
)
const
=
0
;
sigslot
:
:
signal1
<
IceTransportInternal
*
>
SignalGatheringState
;
sigslot
:
:
signal2
<
IceTransportInternal
*
const
Candidate
&
>
SignalCandidateGathered
;
sigslot
:
:
signal2
<
IceTransportInternal
*
const
IceCandidateErrorEvent
&
>
SignalCandidateError
;
sigslot
:
:
signal2
<
IceTransportInternal
*
const
Candidates
&
>
SignalCandidatesRemoved
;
sigslot
:
:
signal2
<
IceTransportInternal
*
const
Candidate
&
>
SignalRouteChange
;
sigslot
:
:
signal1
<
const
cricket
:
:
CandidatePairChangeEvent
&
>
SignalCandidatePairChanged
;
sigslot
:
:
signal1
<
IceTransportInternal
*
>
SignalRoleConflict
;
sigslot
:
:
signal1
<
IceTransportInternal
*
>
SignalStateChanged
;
sigslot
:
:
signal1
<
IceTransportInternal
*
>
SignalIceTransportStateChanged
;
sigslot
:
:
signal1
<
IceTransportInternal
*
>
SignalDestroyed
;
}
;
}
#
endif
