#
ifndef
P2P_BASE_PACKET_TRANSPORT_INTERNAL_H_
#
define
P2P_BASE_PACKET_TRANSPORT_INTERNAL_H_
#
include
<
cstddef
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
callback_list
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
sigslot_trampoline
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
RTC_EXPORT
PacketTransportInternal
:
public
sigslot
:
:
has_slots
<
>
{
public
:
virtual
const
std
:
:
string
&
transport_name
(
)
const
=
0
;
virtual
bool
writable
(
)
const
=
0
;
virtual
bool
receiving
(
)
const
=
0
;
virtual
int
SendPacket
(
const
char
*
data
size_t
len
const
AsyncSocketPacketOptions
&
options
int
flags
=
0
)
=
0
;
virtual
int
SetOption
(
Socket
:
:
Option
opt
int
value
)
=
0
;
virtual
bool
GetOption
(
Socket
:
:
Option
opt
int
*
value
)
;
virtual
int
GetError
(
)
=
0
;
virtual
std
:
:
optional
<
NetworkRoute
>
network_route
(
)
const
;
sigslot
:
:
signal1
<
PacketTransportInternal
*
>
SignalWritableState
;
void
SubscribeWritableState
(
void
*
tag
absl
:
:
AnyInvocable
<
void
(
PacketTransportInternal
*
)
>
callback
)
;
void
UnsubscribeWritableState
(
void
*
tag
)
;
void
NotifyWritableState
(
PacketTransportInternal
*
packet_transport
)
;
sigslot
:
:
signal1
<
PacketTransportInternal
*
>
SignalReadyToSend
;
void
SubscribeReadyToSend
(
void
*
tag
absl
:
:
AnyInvocable
<
void
(
PacketTransportInternal
*
)
>
callback
)
;
void
UnsubscribeReadyToSend
(
void
*
tag
)
;
void
NotifyReadyToSend
(
PacketTransportInternal
*
packet_transport
)
;
sigslot
:
:
signal1
<
PacketTransportInternal
*
>
SignalReceivingState
;
void
SubscribeReceivingState
(
absl
:
:
AnyInvocable
<
void
(
PacketTransportInternal
*
)
>
callback
)
;
void
NotifyReceivingState
(
PacketTransportInternal
*
packet_transport
)
;
void
RegisterReceivedPacketCallback
(
void
*
id
absl
:
:
AnyInvocable
<
void
(
PacketTransportInternal
*
const
ReceivedIpPacket
&
)
>
callback
)
;
void
DeregisterReceivedPacketCallback
(
void
*
id
)
;
sigslot
:
:
signal2
<
PacketTransportInternal
*
const
SentPacketInfo
&
>
SignalSentPacket
;
sigslot
:
:
signal1
<
std
:
:
optional
<
NetworkRoute
>
>
SignalNetworkRouteChanged
;
void
SubscribeNetworkRouteChanged
(
void
*
tag
absl
:
:
AnyInvocable
<
void
(
std
:
:
optional
<
NetworkRoute
>
)
>
callback
)
;
void
UnsubscribeNetworkRouteChanged
(
void
*
tag
)
;
void
NotifyNetworkRouteChanged
(
std
:
:
optional
<
webrtc
:
:
NetworkRoute
>
network_route
)
;
void
SetOnCloseCallback
(
absl
:
:
AnyInvocable
<
void
(
)
&
&
>
callback
)
;
protected
:
PacketTransportInternal
(
)
;
~
PacketTransportInternal
(
)
override
;
void
NotifyPacketReceived
(
const
ReceivedIpPacket
&
packet
)
;
void
NotifyOnClose
(
)
;
SequenceChecker
network_checker_
{
SequenceChecker
:
:
kDetached
}
;
private
:
CallbackList
<
PacketTransportInternal
*
const
ReceivedIpPacket
&
>
received_packet_callback_list_
RTC_GUARDED_BY
(
&
network_checker_
)
;
absl
:
:
AnyInvocable
<
void
(
)
&
&
>
on_close_
;
SignalTrampoline
<
PacketTransportInternal
&
PacketTransportInternal
:
:
SignalWritableState
>
writable_state_trampoline_
;
SignalTrampoline
<
PacketTransportInternal
&
PacketTransportInternal
:
:
SignalReadyToSend
>
ready_to_send_trampoline_
;
SignalTrampoline
<
PacketTransportInternal
&
PacketTransportInternal
:
:
SignalReceivingState
>
receiving_state_trampoline_
;
SignalTrampoline
<
PacketTransportInternal
&
PacketTransportInternal
:
:
SignalNetworkRouteChanged
>
network_route_changed_trampoline_
;
}
;
}
#
endif
