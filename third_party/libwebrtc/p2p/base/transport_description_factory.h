#
ifndef
P2P_BASE_TRANSPORT_DESCRIPTION_FACTORY_H_
#
define
P2P_BASE_TRANSPORT_DESCRIPTION_FACTORY_H_
#
include
<
memory
>
#
include
<
utility
>
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
p2p
/
base
/
ice_credentials_iterator
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
rtc_base
/
rtc_certificate
.
h
"
#
include
"
rtc_base
/
ssl_identity
.
h
"
namespace
webrtc
{
struct
TransportOptions
{
bool
ice_restart
=
false
;
bool
prefer_passive_role
=
false
;
bool
enable_ice_renomination
=
false
;
}
;
class
TransportDescriptionFactory
{
public
:
explicit
TransportDescriptionFactory
(
const
FieldTrialsView
&
field_trials
)
;
~
TransportDescriptionFactory
(
)
;
const
scoped_refptr
<
RTCCertificate
>
&
certificate
(
)
const
{
return
certificate_
;
}
void
set_certificate
(
scoped_refptr
<
RTCCertificate
>
certificate
)
{
certificate_
=
std
:
:
move
(
certificate
)
;
}
std
:
:
unique_ptr
<
TransportDescription
>
CreateOffer
(
const
TransportOptions
&
options
const
TransportDescription
*
current_description
IceCredentialsIterator
*
ice_credentials
)
const
;
std
:
:
unique_ptr
<
TransportDescription
>
CreateAnswer
(
const
TransportDescription
*
offer
const
TransportOptions
&
options
bool
require_transport_attributes
const
TransportDescription
*
current_description
IceCredentialsIterator
*
ice_credentials
)
const
;
const
FieldTrialsView
&
trials
(
)
const
{
return
field_trials_
;
}
bool
insecure
(
)
const
{
return
insecure_
;
}
void
SetInsecureForTesting
(
)
{
insecure_
=
true
;
}
private
:
bool
SetSecurityInfo
(
TransportDescription
*
description
ConnectionRole
role
)
const
;
bool
insecure_
=
false
;
scoped_refptr
<
RTCCertificate
>
certificate_
;
const
FieldTrialsView
&
field_trials_
;
}
;
}
namespace
cricket
{
using
:
:
webrtc
:
:
TransportDescriptionFactory
;
using
:
:
webrtc
:
:
TransportOptions
;
}
#
endif
