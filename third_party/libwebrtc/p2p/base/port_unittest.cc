#
include
"
p2p
/
base
/
port
.
h
"
#
include
<
string
.
h
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
async_dns_resolver
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
packet_socket_factory
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
test
/
rtc_error_matchers
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
p2p_transport_channel_ice_field_trials
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
p2p
/
base
/
stun_port
.
h
"
#
include
"
p2p
/
base
/
tcp_port
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
base
/
turn_port
.
h
"
#
include
"
p2p
/
client
/
relay_port_factory_interface
.
h
"
#
include
"
p2p
/
test
/
nat_server
.
h
"
#
include
"
p2p
/
test
/
nat_socket_factory
.
h
"
#
include
"
p2p
/
test
/
nat_types
.
h
"
#
include
"
p2p
/
test
/
stun_server
.
h
"
#
include
"
p2p
/
test
/
test_stun_server
.
h
"
#
include
"
p2p
/
test
/
test_turn_server
.
h
"
#
include
"
p2p
/
test
/
turn_server
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
net_helper
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
network_constants
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_adapters
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
scoped_key_value_config
.
h
"
#
include
"
test
/
wait_until
.
h
"
using
rtc
:
:
AsyncPacketSocket
;
using
rtc
:
:
ByteBufferReader
;
using
rtc
:
:
ByteBufferWriter
;
using
rtc
:
:
PacketSocketFactory
;
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
IsNull
;
using
:
:
testing
:
:
IsTrue
;
using
:
:
testing
:
:
NotNull
;
using
:
:
webrtc
:
:
AsyncListenSocket
;
using
webrtc
:
:
IceCandidateType
;
using
:
:
webrtc
:
:
NAT_ADDR_RESTRICTED
;
using
:
:
webrtc
:
:
NAT_OPEN_CONE
;
using
:
:
webrtc
:
:
NAT_PORT_RESTRICTED
;
using
:
:
webrtc
:
:
NAT_SYMMETRIC
;
using
:
:
webrtc
:
:
NATType
;
using
:
:
webrtc
:
:
Socket
;
using
:
:
webrtc
:
:
SocketAddress
;
namespace
cricket
{
namespace
{
constexpr
int
kDefaultTimeout
=
3000
;
constexpr
int
kShortTimeout
=
1000
;
constexpr
int
kMaxExpectedSimulatedRtt
=
200
;
const
SocketAddress
kLocalAddr1
(
"
192
.
168
.
1
.
2
"
0
)
;
const
SocketAddress
kLocalAddr2
(
"
192
.
168
.
1
.
3
"
0
)
;
const
SocketAddress
kLinkLocalIPv6Addr
(
"
fe80
:
:
aabb
:
ccff
:
fedd
:
eeff
"
0
)
;
const
SocketAddress
kNatAddr1
(
"
77
.
77
.
77
.
77
"
webrtc
:
:
NAT_SERVER_UDP_PORT
)
;
const
SocketAddress
kNatAddr2
(
"
88
.
88
.
88
.
88
"
webrtc
:
:
NAT_SERVER_UDP_PORT
)
;
const
SocketAddress
kStunAddr
(
"
99
.
99
.
99
.
1
"
webrtc
:
:
STUN_SERVER_PORT
)
;
const
SocketAddress
kTurnUdpIntAddr
(
"
99
.
99
.
99
.
4
"
webrtc
:
:
STUN_SERVER_PORT
)
;
const
SocketAddress
kTurnTcpIntAddr
(
"
99
.
99
.
99
.
4
"
5010
)
;
const
SocketAddress
kTurnUdpExtAddr
(
"
99
.
99
.
99
.
5
"
0
)
;
const
webrtc
:
:
RelayCredentials
kRelayCredentials
(
"
test
"
"
test
"
)
;
const
uint32_t
kDefaultPrflxPriority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
|
30
<
<
8
|
(
256
-
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
constexpr
int
kTiebreaker1
=
11111
;
constexpr
int
kTiebreaker2
=
22222
;
constexpr
int
kTiebreakerDefault
=
44444
;
const
char
*
kTestData
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890
"
;
webrtc
:
:
Candidate
GetCandidate
(
Port
*
port
)
{
RTC_DCHECK_GE
(
port
-
>
Candidates
(
)
.
size
(
)
1
)
;
return
port
-
>
Candidates
(
)
[
0
]
;
}
SocketAddress
GetAddress
(
Port
*
port
)
{
return
GetCandidate
(
port
)
.
address
(
)
;
}
std
:
:
unique_ptr
<
IceMessage
>
CopyStunMessage
(
const
IceMessage
&
src
)
{
auto
dst
=
std
:
:
make_unique
<
IceMessage
>
(
)
;
ByteBufferWriter
buf
;
src
.
Write
(
&
buf
)
;
ByteBufferReader
read_buf
(
buf
)
;
dst
-
>
Read
(
&
read_buf
)
;
return
dst
;
}
bool
WriteStunMessage
(
const
StunMessage
&
msg
ByteBufferWriter
*
buf
)
{
buf
-
>
Resize
(
0
)
;
return
msg
.
Write
(
buf
)
;
}
}
class
TestPort
:
public
Port
{
public
:
TestPort
(
const
PortParametersRef
&
args
uint16_t
min_port
uint16_t
max_port
)
:
Port
(
args
IceCandidateType
:
:
kHost
min_port
max_port
)
{
}
~
TestPort
(
)
{
}
using
cricket
:
:
Port
:
:
GetStunMessage
;
rtc
:
:
ArrayView
<
const
uint8_t
>
last_stun_buf
(
)
{
if
(
!
last_stun_buf_
)
return
rtc
:
:
ArrayView
<
const
uint8_t
>
(
)
;
return
*
last_stun_buf_
;
}
IceMessage
*
last_stun_msg
(
)
{
return
last_stun_msg_
.
get
(
)
;
}
int
last_stun_error_code
(
)
{
int
code
=
0
;
if
(
last_stun_msg_
)
{
const
StunErrorCodeAttribute
*
error_attr
=
last_stun_msg_
-
>
GetErrorCode
(
)
;
if
(
error_attr
)
{
code
=
error_attr
-
>
code
(
)
;
}
}
return
code
;
}
virtual
void
PrepareAddress
(
)
{
webrtc
:
:
SocketAddress
addr
(
Network
(
)
-
>
GetBestIP
(
)
min_port
(
)
)
;
AddAddress
(
addr
addr
webrtc
:
:
SocketAddress
(
)
"
udp
"
"
"
"
"
type
(
)
ICE_TYPE_PREFERENCE_HOST
0
"
"
true
)
;
}
virtual
bool
SupportsProtocol
(
absl
:
:
string_view
)
const
{
return
true
;
}
virtual
webrtc
:
:
ProtocolType
GetProtocol
(
)
const
{
return
webrtc
:
:
PROTO_UDP
;
}
void
AddCandidateAddress
(
const
webrtc
:
:
SocketAddress
&
addr
)
{
AddAddress
(
addr
addr
webrtc
:
:
SocketAddress
(
)
"
udp
"
"
"
"
"
type
(
)
type_preference_
0
"
"
false
)
;
}
void
AddCandidateAddress
(
const
webrtc
:
:
SocketAddress
&
addr
const
webrtc
:
:
SocketAddress
&
base_address
IceCandidateType
type
int
type_preference
bool
final
)
{
AddAddress
(
addr
base_address
webrtc
:
:
SocketAddress
(
)
"
udp
"
"
"
"
"
type
type_preference
0
"
"
final
)
;
}
virtual
Connection
*
CreateConnection
(
const
webrtc
:
:
Candidate
&
remote_candidate
CandidateOrigin
)
{
Connection
*
conn
=
new
ProxyConnection
(
NewWeakPtr
(
)
0
remote_candidate
)
;
AddOrReplaceConnection
(
conn
)
;
conn
-
>
set_use_candidate_attr
(
true
)
;
return
conn
;
}
virtual
int
SendTo
(
const
void
*
data
size_t
size
const
webrtc
:
:
SocketAddress
&
const
rtc
:
:
PacketOptions
&
bool
payload
)
{
if
(
!
payload
)
{
auto
msg
=
std
:
:
make_unique
<
IceMessage
>
(
)
;
auto
buf
=
std
:
:
make_unique
<
rtc
:
:
BufferT
<
uint8_t
>
>
(
static_cast
<
const
char
*
>
(
data
)
size
)
;
ByteBufferReader
read_buf
(
*
buf
)
;
if
(
!
msg
-
>
Read
(
&
read_buf
)
)
{
return
-
1
;
}
last_stun_buf_
=
std
:
:
move
(
buf
)
;
last_stun_msg_
=
std
:
:
move
(
msg
)
;
}
return
static_cast
<
int
>
(
size
)
;
}
virtual
int
SetOption
(
webrtc
:
:
Socket
:
:
Option
int
)
{
return
0
;
}
virtual
int
GetOption
(
webrtc
:
:
Socket
:
:
Option
opt
int
*
value
)
{
return
-
1
;
}
virtual
int
GetError
(
)
{
return
0
;
}
void
Reset
(
)
{
last_stun_buf_
.
reset
(
)
;
last_stun_msg_
.
reset
(
)
;
}
void
set_type_preference
(
int
type_preference
)
{
type_preference_
=
type_preference
;
}
private
:
void
OnSentPacket
(
webrtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SentPacket
&
sent_packet
)
{
webrtc
:
:
PortInterface
:
:
SignalSentPacket
(
sent_packet
)
;
}
std
:
:
unique_ptr
<
rtc
:
:
BufferT
<
uint8_t
>
>
last_stun_buf_
;
std
:
:
unique_ptr
<
IceMessage
>
last_stun_msg_
;
int
type_preference_
=
0
;
}
;
bool
GetStunMessageFromBufferWriter
(
TestPort
*
port
ByteBufferWriter
*
buf
const
webrtc
:
:
SocketAddress
&
addr
std
:
:
unique_ptr
<
IceMessage
>
*
out_msg
std
:
:
string
*
out_username
)
{
return
port
-
>
GetStunMessage
(
reinterpret_cast
<
const
char
*
>
(
buf
-
>
Data
(
)
)
buf
-
>
Length
(
)
addr
out_msg
out_username
)
;
}
static
void
SendPingAndReceiveResponse
(
Connection
*
lconn
TestPort
*
lport
Connection
*
rconn
TestPort
*
rport
webrtc
:
:
ScopedFakeClock
*
clock
int64_t
ms
)
{
lconn
-
>
Ping
(
rtc
:
:
TimeMillis
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
lport
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
clock
-
>
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
ms
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
rport
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
}
class
TestChannel
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
TestChannel
(
std
:
:
unique_ptr
<
Port
>
p1
)
:
port_
(
std
:
:
move
(
p1
)
)
{
port_
-
>
SignalPortComplete
.
connect
(
this
&
TestChannel
:
:
OnPortComplete
)
;
port_
-
>
SignalUnknownAddress
.
connect
(
this
&
TestChannel
:
:
OnUnknownAddress
)
;
port_
-
>
SubscribePortDestroyed
(
[
this
]
(
PortInterface
*
port
)
{
OnSrcPortDestroyed
(
port
)
;
}
)
;
}
~
TestChannel
(
)
{
Stop
(
)
;
}
int
complete_count
(
)
{
return
complete_count_
;
}
Connection
*
conn
(
)
{
return
conn_
;
}
const
SocketAddress
&
remote_address
(
)
{
return
remote_address_
;
}
std
:
:
string
remote_fragment
(
)
{
return
remote_frag_
;
}
void
Start
(
)
{
port_
-
>
PrepareAddress
(
)
;
}
void
CreateConnection
(
const
webrtc
:
:
Candidate
&
remote_candidate
)
{
RTC_DCHECK
(
!
conn_
)
;
conn_
=
port_
-
>
CreateConnection
(
remote_candidate
Port
:
:
ORIGIN_MESSAGE
)
;
IceMode
remote_ice_mode
=
(
ice_mode_
=
=
ICEMODE_FULL
)
?
ICEMODE_LITE
:
ICEMODE_FULL
;
conn_
-
>
set_use_candidate_attr
(
remote_ice_mode
=
=
ICEMODE_FULL
)
;
conn_
-
>
SignalStateChange
.
connect
(
this
&
TestChannel
:
:
OnConnectionStateChange
)
;
conn_
-
>
SignalDestroyed
.
connect
(
this
&
TestChannel
:
:
OnDestroyed
)
;
conn_
-
>
SignalReadyToSend
.
connect
(
this
&
TestChannel
:
:
OnConnectionReadyToSend
)
;
connection_ready_to_send_
=
false
;
}
void
OnConnectionStateChange
(
Connection
*
conn
)
{
if
(
conn
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
{
conn
-
>
set_use_candidate_attr
(
true
)
;
nominated_
=
true
;
}
}
void
AcceptConnection
(
const
webrtc
:
:
Candidate
&
remote_candidate
)
{
if
(
conn_
)
{
conn_
-
>
SignalDestroyed
.
disconnect
(
this
)
;
conn_
=
nullptr
;
}
ASSERT_TRUE
(
remote_request_
.
get
(
)
!
=
NULL
)
;
webrtc
:
:
Candidate
c
=
remote_candidate
;
c
.
set_address
(
remote_address_
)
;
conn_
=
port_
-
>
CreateConnection
(
c
Port
:
:
ORIGIN_MESSAGE
)
;
conn_
-
>
SignalDestroyed
.
connect
(
this
&
TestChannel
:
:
OnDestroyed
)
;
conn_
-
>
SendStunBindingResponse
(
remote_request_
.
get
(
)
)
;
remote_request_
.
reset
(
)
;
}
void
Ping
(
)
{
Ping
(
0
)
;
}
void
Ping
(
int64_t
now
)
{
conn_
-
>
Ping
(
now
)
;
}
void
Stop
(
)
{
if
(
conn_
)
{
port_
-
>
DestroyConnection
(
conn_
)
;
conn_
=
nullptr
;
}
}
void
OnPortComplete
(
Port
*
port
)
{
complete_count_
+
+
;
}
void
SetIceMode
(
IceMode
ice_mode
)
{
ice_mode_
=
ice_mode
;
}
int
SendData
(
const
char
*
data
size_t
len
)
{
rtc
:
:
PacketOptions
options
;
return
conn_
-
>
Send
(
data
len
options
)
;
}
void
OnUnknownAddress
(
webrtc
:
:
PortInterface
*
port
const
SocketAddress
&
addr
webrtc
:
:
ProtocolType
proto
IceMessage
*
msg
const
std
:
:
string
&
rf
bool
)
{
ASSERT_EQ
(
port_
.
get
(
)
port
)
;
if
(
!
remote_address_
.
IsNil
(
)
)
{
ASSERT_EQ
(
remote_address_
addr
)
;
}
const
cricket
:
:
StunUInt32Attribute
*
priority_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_PRIORITY
)
;
const
cricket
:
:
StunByteStringAttribute
*
mi_attr
=
msg
-
>
GetByteString
(
STUN_ATTR_MESSAGE_INTEGRITY
)
;
const
cricket
:
:
StunUInt32Attribute
*
fingerprint_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_FINGERPRINT
)
;
EXPECT_TRUE
(
priority_attr
!
=
NULL
)
;
EXPECT_TRUE
(
mi_attr
!
=
NULL
)
;
EXPECT_TRUE
(
fingerprint_attr
!
=
NULL
)
;
remote_address_
=
addr
;
remote_request_
=
CopyStunMessage
(
*
msg
)
;
remote_frag_
=
rf
;
}
void
OnDestroyed
(
Connection
*
conn
)
{
ASSERT_EQ
(
conn_
conn
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
OnDestroy
connection
"
<
<
conn
<
<
"
deleted
"
;
conn_
=
nullptr
;
remote_request_
.
reset
(
)
;
remote_address_
.
Clear
(
)
;
}
void
OnSrcPortDestroyed
(
webrtc
:
:
PortInterface
*
port
)
{
Port
*
destroyed_src
=
port_
.
release
(
)
;
ASSERT_EQ
(
destroyed_src
port
)
;
}
Port
*
port
(
)
{
return
port_
.
get
(
)
;
}
bool
nominated
(
)
const
{
return
nominated_
;
}
void
set_connection_ready_to_send
(
bool
ready
)
{
connection_ready_to_send_
=
ready
;
}
bool
connection_ready_to_send
(
)
const
{
return
connection_ready_to_send_
;
}
private
:
void
OnConnectionReadyToSend
(
Connection
*
conn
)
{
ASSERT_EQ
(
conn
conn_
)
;
connection_ready_to_send_
=
true
;
}
IceMode
ice_mode_
=
ICEMODE_FULL
;
std
:
:
unique_ptr
<
Port
>
port_
;
int
complete_count_
=
0
;
Connection
*
conn_
=
nullptr
;
SocketAddress
remote_address_
;
std
:
:
unique_ptr
<
StunMessage
>
remote_request_
;
std
:
:
string
remote_frag_
;
bool
nominated_
=
false
;
bool
connection_ready_to_send_
=
false
;
}
;
class
PortTest
:
public
:
:
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
PortTest
(
)
:
ss_
(
new
webrtc
:
:
VirtualSocketServer
(
)
)
main_
(
ss_
.
get
(
)
)
socket_factory_
(
ss_
.
get
(
)
)
nat_factory1_
(
ss_
.
get
(
)
kNatAddr1
SocketAddress
(
)
)
nat_factory2_
(
ss_
.
get
(
)
kNatAddr2
SocketAddress
(
)
)
nat_socket_factory1_
(
&
nat_factory1_
)
nat_socket_factory2_
(
&
nat_factory2_
)
stun_server_
(
webrtc
:
:
TestStunServer
:
:
Create
(
ss_
.
get
(
)
kStunAddr
main_
)
)
turn_server_
(
&
main_
ss_
.
get
(
)
kTurnUdpIntAddr
kTurnUdpExtAddr
)
username_
(
rtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
)
password_
(
rtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
)
role_conflict_
(
false
)
ports_destroyed_
(
0
)
{
}
~
PortTest
(
)
{
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
0
)
;
}
protected
:
std
:
:
string
password
(
)
{
return
password_
;
}
void
TestLocalToLocal
(
)
{
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
"
udp
"
std
:
:
move
(
port1
)
"
udp
"
std
:
:
move
(
port2
)
true
true
true
true
)
;
}
void
TestLocalToStun
(
NATType
ntype
)
{
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
nat_server2_
=
CreateNatServer
(
kNatAddr2
ntype
)
;
auto
port2
=
CreateStunPort
(
kLocalAddr2
&
nat_socket_factory2_
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
"
udp
"
std
:
:
move
(
port1
)
StunName
(
ntype
)
std
:
:
move
(
port2
)
ntype
=
=
webrtc
:
:
NAT_OPEN_CONE
true
ntype
!
=
webrtc
:
:
NAT_SYMMETRIC
true
)
;
}
void
TestLocalToRelay
(
webrtc
:
:
ProtocolType
proto
)
{
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateRelayPort
(
kLocalAddr2
proto
webrtc
:
:
PROTO_UDP
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
"
udp
"
std
:
:
move
(
port1
)
RelayName
(
proto
)
std
:
:
move
(
port2
)
false
true
true
true
)
;
}
void
TestStunToLocal
(
NATType
ntype
)
{
nat_server1_
=
CreateNatServer
(
kNatAddr1
ntype
)
;
auto
port1
=
CreateStunPort
(
kLocalAddr1
&
nat_socket_factory1_
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
StunName
(
ntype
)
std
:
:
move
(
port1
)
"
udp
"
std
:
:
move
(
port2
)
true
ntype
!
=
webrtc
:
:
NAT_SYMMETRIC
true
true
)
;
}
void
TestStunToStun
(
NATType
ntype1
NATType
ntype2
)
{
nat_server1_
=
CreateNatServer
(
kNatAddr1
ntype1
)
;
auto
port1
=
CreateStunPort
(
kLocalAddr1
&
nat_socket_factory1_
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
nat_server2_
=
CreateNatServer
(
kNatAddr2
ntype2
)
;
auto
port2
=
CreateStunPort
(
kLocalAddr2
&
nat_socket_factory2_
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
StunName
(
ntype1
)
std
:
:
move
(
port1
)
StunName
(
ntype2
)
std
:
:
move
(
port2
)
ntype2
=
=
webrtc
:
:
NAT_OPEN_CONE
ntype1
!
=
webrtc
:
:
NAT_SYMMETRIC
ntype2
!
=
webrtc
:
:
NAT_SYMMETRIC
ntype1
+
ntype2
<
(
webrtc
:
:
NAT_PORT_RESTRICTED
+
webrtc
:
:
NAT_SYMMETRIC
)
)
;
}
void
TestStunToRelay
(
NATType
ntype
webrtc
:
:
ProtocolType
proto
)
{
nat_server1_
=
CreateNatServer
(
kNatAddr1
ntype
)
;
auto
port1
=
CreateStunPort
(
kLocalAddr1
&
nat_socket_factory1_
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateRelayPort
(
kLocalAddr2
proto
webrtc
:
:
PROTO_UDP
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
StunName
(
ntype
)
std
:
:
move
(
port1
)
RelayName
(
proto
)
std
:
:
move
(
port2
)
false
ntype
!
=
webrtc
:
:
NAT_SYMMETRIC
true
true
)
;
}
void
TestTcpToTcp
(
)
{
auto
port1
=
CreateTcpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateTcpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
"
tcp
"
std
:
:
move
(
port1
)
"
tcp
"
std
:
:
move
(
port2
)
true
false
true
true
)
;
}
void
TestTcpToRelay
(
webrtc
:
:
ProtocolType
proto
)
{
auto
port1
=
CreateTcpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateRelayPort
(
kLocalAddr2
proto
webrtc
:
:
PROTO_TCP
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
"
tcp
"
std
:
:
move
(
port1
)
RelayName
(
proto
)
std
:
:
move
(
port2
)
false
false
true
true
)
;
}
void
TestSslTcpToRelay
(
webrtc
:
:
ProtocolType
proto
)
{
auto
port1
=
CreateTcpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateRelayPort
(
kLocalAddr2
proto
webrtc
:
:
PROTO_SSLTCP
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestConnectivity
(
"
ssltcp
"
std
:
:
move
(
port1
)
RelayName
(
proto
)
std
:
:
move
(
port2
)
false
false
true
true
)
;
}
rtc
:
:
Network
*
MakeNetwork
(
const
SocketAddress
&
addr
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
addr
.
ipaddr
(
)
)
;
return
&
networks_
.
back
(
)
;
}
rtc
:
:
Network
*
MakeNetworkMultipleAddrs
(
const
SocketAddress
&
global_addr
const
SocketAddress
&
link_local_addr
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
global_addr
.
ipaddr
(
)
32
webrtc
:
:
ADAPTER_TYPE_UNKNOWN
)
;
networks_
.
back
(
)
.
AddIP
(
link_local_addr
.
ipaddr
(
)
)
;
networks_
.
back
(
)
.
AddIP
(
global_addr
.
ipaddr
(
)
)
;
networks_
.
back
(
)
.
AddIP
(
link_local_addr
.
ipaddr
(
)
)
;
return
&
networks_
.
back
(
)
;
}
std
:
:
unique_ptr
<
UDPPort
>
CreateUdpPort
(
const
SocketAddress
&
addr
)
{
return
CreateUdpPort
(
addr
&
socket_factory_
)
;
}
std
:
:
unique_ptr
<
UDPPort
>
CreateUdpPort
(
const
SocketAddress
&
addr
PacketSocketFactory
*
socket_factory
)
{
auto
port
=
UDPPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
socket_factory
.
network
=
MakeNetwork
(
addr
)
.
ice_username_fragment
=
username_
.
ice_password
=
password_
.
field_trials
=
&
field_trials_
}
0
0
true
std
:
:
nullopt
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
std
:
:
unique_ptr
<
UDPPort
>
CreateUdpPortMultipleAddrs
(
const
SocketAddress
&
global_addr
const
SocketAddress
&
link_local_addr
PacketSocketFactory
*
socket_factory
)
{
auto
port
=
UDPPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
socket_factory
.
network
=
MakeNetworkMultipleAddrs
(
global_addr
link_local_addr
)
.
ice_username_fragment
=
username_
.
ice_password
=
password_
.
field_trials
=
&
field_trials_
}
0
0
true
std
:
:
nullopt
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
std
:
:
unique_ptr
<
TCPPort
>
CreateTcpPort
(
const
SocketAddress
&
addr
)
{
return
CreateTcpPort
(
addr
&
socket_factory_
)
;
}
std
:
:
unique_ptr
<
TCPPort
>
CreateTcpPort
(
const
SocketAddress
&
addr
PacketSocketFactory
*
socket_factory
)
{
auto
port
=
TCPPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
socket_factory
.
network
=
MakeNetwork
(
addr
)
.
ice_username_fragment
=
username_
.
ice_password
=
password_
.
field_trials
=
&
field_trials_
}
0
0
true
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
std
:
:
unique_ptr
<
StunPort
>
CreateStunPort
(
const
SocketAddress
&
addr
webrtc
:
:
PacketSocketFactory
*
socket_factory
)
{
ServerAddresses
stun_servers
;
stun_servers
.
insert
(
kStunAddr
)
;
auto
port
=
StunPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
socket_factory
.
network
=
MakeNetwork
(
addr
)
.
ice_username_fragment
=
username_
.
ice_password
=
password_
.
field_trials
=
&
field_trials_
}
0
0
stun_servers
std
:
:
nullopt
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
std
:
:
unique_ptr
<
Port
>
CreateRelayPort
(
const
SocketAddress
&
addr
webrtc
:
:
ProtocolType
int_proto
webrtc
:
:
ProtocolType
ext_proto
)
{
return
CreateTurnPort
(
addr
&
socket_factory_
int_proto
ext_proto
)
;
}
std
:
:
unique_ptr
<
TurnPort
>
CreateTurnPort
(
const
SocketAddress
&
addr
PacketSocketFactory
*
socket_factory
webrtc
:
:
ProtocolType
int_proto
webrtc
:
:
ProtocolType
ext_proto
)
{
SocketAddress
server_addr
=
int_proto
=
=
webrtc
:
:
PROTO_TCP
?
kTurnTcpIntAddr
:
kTurnUdpIntAddr
;
return
CreateTurnPort
(
addr
socket_factory
int_proto
ext_proto
server_addr
)
;
}
std
:
:
unique_ptr
<
TurnPort
>
CreateTurnPort
(
const
SocketAddress
&
addr
PacketSocketFactory
*
socket_factory
webrtc
:
:
ProtocolType
int_proto
webrtc
:
:
ProtocolType
ext_proto
const
webrtc
:
:
SocketAddress
&
server_addr
)
{
webrtc
:
:
RelayServerConfig
config
;
config
.
credentials
=
kRelayCredentials
;
ProtocolAddress
server_address
(
server_addr
int_proto
)
;
CreateRelayPortArgs
args
;
args
.
network_thread
=
&
main_
;
args
.
socket_factory
=
socket_factory
;
args
.
network
=
MakeNetwork
(
addr
)
;
args
.
username
=
username_
;
args
.
password
=
password_
;
args
.
server_address
=
&
server_address
;
args
.
config
=
&
config
;
args
.
field_trials
=
&
field_trials_
;
auto
port
=
TurnPort
:
:
Create
(
args
0
0
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
return
port
;
}
std
:
:
unique_ptr
<
webrtc
:
:
NATServer
>
CreateNatServer
(
const
SocketAddress
&
addr
webrtc
:
:
NATType
type
)
{
return
std
:
:
make_unique
<
webrtc
:
:
NATServer
>
(
type
main_
ss_
.
get
(
)
addr
addr
main_
ss_
.
get
(
)
addr
)
;
}
static
const
char
*
StunName
(
NATType
type
)
{
switch
(
type
)
{
case
webrtc
:
:
NAT_OPEN_CONE
:
return
"
stun
(
open
cone
)
"
;
case
webrtc
:
:
NAT_ADDR_RESTRICTED
:
return
"
stun
(
addr
restricted
)
"
;
case
webrtc
:
:
NAT_PORT_RESTRICTED
:
return
"
stun
(
port
restricted
)
"
;
case
webrtc
:
:
NAT_SYMMETRIC
:
return
"
stun
(
symmetric
)
"
;
default
:
return
"
stun
(
?
)
"
;
}
}
static
const
char
*
RelayName
(
webrtc
:
:
ProtocolType
proto
)
{
switch
(
proto
)
{
case
webrtc
:
:
PROTO_UDP
:
return
"
turn
(
udp
)
"
;
case
webrtc
:
:
PROTO_TCP
:
return
"
turn
(
tcp
)
"
;
case
webrtc
:
:
PROTO_SSLTCP
:
return
"
turn
(
ssltcp
)
"
;
case
webrtc
:
:
PROTO_TLS
:
return
"
turn
(
tls
)
"
;
default
:
return
"
turn
(
?
)
"
;
}
}
void
TestCrossFamilyPorts
(
int
type
)
;
void
ExpectPortsCanConnect
(
bool
can_connect
Port
*
p1
Port
*
p2
)
;
void
TestConnectivity
(
absl
:
:
string_view
name1
std
:
:
unique_ptr
<
Port
>
port1
absl
:
:
string_view
name2
std
:
:
unique_ptr
<
Port
>
port2
bool
accept
bool
same_addr1
bool
same_addr2
bool
possible
)
;
void
ConnectStartedChannels
(
TestChannel
*
ch1
TestChannel
*
ch2
)
{
ASSERT_TRUE
(
ch1
-
>
conn
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
-
>
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
-
>
Ping
(
)
;
WAIT
(
!
ch2
-
>
remote_address
(
)
.
IsNil
(
)
kShortTimeout
)
;
ch2
-
>
AcceptConnection
(
GetCandidate
(
ch1
-
>
port
(
)
)
)
;
ch2
-
>
Ping
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
-
>
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
void
StartConnectAndStopChannels
(
TestChannel
*
ch1
TestChannel
*
ch2
)
{
ch1
-
>
Start
(
)
;
ch2
-
>
Start
(
)
;
ch1
-
>
CreateConnection
(
GetCandidate
(
ch2
-
>
port
(
)
)
)
;
ConnectStartedChannels
(
ch1
ch2
)
;
ch1
-
>
Stop
(
)
;
ch2
-
>
Stop
(
)
;
}
void
DisconnectTcpTestChannels
(
TestChannel
*
ch1
TestChannel
*
ch2
)
{
TCPConnection
*
tcp_conn1
=
static_cast
<
TCPConnection
*
>
(
ch1
-
>
conn
(
)
)
;
TCPConnection
*
tcp_conn2
=
static_cast
<
TCPConnection
*
>
(
ch2
-
>
conn
(
)
)
;
ASSERT_TRUE
(
ss_
-
>
CloseTcpConnections
(
tcp_conn1
-
>
socket
(
)
-
>
GetLocalAddress
(
)
tcp_conn2
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ch1
-
>
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ch2
-
>
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
tcp_conn1
-
>
socket
(
)
-
>
NotifyClosedForTest
(
0
)
;
tcp_conn2
-
>
socket
(
)
-
>
NotifyClosedForTest
(
0
)
;
ch2
-
>
Stop
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
-
>
conn
(
)
;
}
IsNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
void
TestTcpReconnect
(
bool
ping_after_disconnected
bool
send_after_disconnected
)
{
auto
port1
=
CreateTcpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateTcpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
port1
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
port2
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
EXPECT_EQ
(
0
ch1
.
complete_count
(
)
)
;
EXPECT_EQ
(
0
ch2
.
complete_count
(
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ConnectStartedChannels
(
&
ch1
&
ch2
)
;
const
int
kTcpReconnectTimeout
=
kDefaultTimeout
;
static_cast
<
TCPConnection
*
>
(
ch1
.
conn
(
)
)
-
>
set_reconnection_timeout
(
kTcpReconnectTimeout
)
;
static_cast
<
TCPConnection
*
>
(
ch2
.
conn
(
)
)
-
>
set_reconnection_timeout
(
kTcpReconnectTimeout
)
;
EXPECT_FALSE
(
ch1
.
connection_ready_to_send
(
)
)
;
EXPECT_FALSE
(
ch2
.
connection_ready_to_send
(
)
)
;
DisconnectTcpTestChannels
(
&
ch1
&
ch2
)
;
if
(
send_after_disconnected
|
|
ping_after_disconnected
)
{
if
(
send_after_disconnected
)
{
EXPECT_EQ
(
-
1
ch1
.
SendData
(
kTestData
static_cast
<
int
>
(
strlen
(
kTestData
)
)
)
)
;
}
if
(
ping_after_disconnected
)
{
ch1
.
Ping
(
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ConnectStartedChannels
(
&
ch1
&
ch2
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
connection_ready_to_send
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTcpReconnectTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
ch2
.
connection_ready_to_send
(
)
)
;
}
else
{
EXPECT_EQ
(
ch1
.
conn
(
)
-
>
write_state
(
)
Connection
:
:
STATE_WRITABLE
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ch1
.
conn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTcpReconnectTimeout
+
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
!
ch2
.
conn
(
)
)
;
}
ch1
.
Stop
(
)
;
ch2
.
Stop
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
;
}
IsNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
conn
(
)
;
}
IsNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
std
:
:
unique_ptr
<
IceMessage
>
CreateStunMessage
(
StunMessageType
type
)
{
auto
msg
=
std
:
:
make_unique
<
IceMessage
>
(
type
"
TESTTESTTEST
"
)
;
return
msg
;
}
std
:
:
unique_ptr
<
IceMessage
>
CreateStunMessageWithUsername
(
StunMessageType
type
absl
:
:
string_view
username
)
{
std
:
:
unique_ptr
<
IceMessage
>
msg
=
CreateStunMessage
(
type
)
;
msg
-
>
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
std
:
:
string
(
username
)
)
)
;
return
msg
;
}
std
:
:
unique_ptr
<
TestPort
>
CreateTestPort
(
const
webrtc
:
:
SocketAddress
&
addr
absl
:
:
string_view
username
absl
:
:
string_view
password
const
webrtc
:
:
FieldTrialsView
*
field_trials
=
nullptr
)
{
Port
:
:
PortParametersRef
args
=
{
.
network_thread
=
&
main_
.
socket_factory
=
&
socket_factory_
.
network
=
MakeNetwork
(
addr
)
.
ice_username_fragment
=
username
.
ice_password
=
password
.
field_trials
=
field_trials
}
;
auto
port
=
std
:
:
make_unique
<
TestPort
>
(
args
0
0
)
;
port
-
>
SignalRoleConflict
.
connect
(
this
&
PortTest
:
:
OnRoleConflict
)
;
return
port
;
}
std
:
:
unique_ptr
<
TestPort
>
CreateTestPort
(
const
webrtc
:
:
SocketAddress
&
addr
absl
:
:
string_view
username
absl
:
:
string_view
password
cricket
:
:
IceRole
role
int
tiebreaker
)
{
auto
port
=
CreateTestPort
(
addr
username
password
)
;
port
-
>
SetIceRole
(
role
)
;
port
-
>
SetIceTiebreaker
(
tiebreaker
)
;
return
port
;
}
std
:
:
unique_ptr
<
TestPort
>
CreateTestPort
(
const
rtc
:
:
Network
*
network
absl
:
:
string_view
username
absl
:
:
string_view
password
)
{
Port
:
:
PortParametersRef
args
=
{
.
network_thread
=
&
main_
.
socket_factory
=
&
socket_factory_
.
network
=
network
.
ice_username_fragment
=
username
.
ice_password
=
password
.
field_trials
=
nullptr
}
;
auto
port
=
std
:
:
make_unique
<
TestPort
>
(
args
0
0
)
;
port
-
>
SignalRoleConflict
.
connect
(
this
&
PortTest
:
:
OnRoleConflict
)
;
return
port
;
}
void
OnRoleConflict
(
webrtc
:
:
PortInterface
*
port
)
{
role_conflict_
=
true
;
}
bool
role_conflict
(
)
const
{
return
role_conflict_
;
}
void
ConnectToSignalDestroyed
(
webrtc
:
:
PortInterface
*
port
)
{
port
-
>
SubscribePortDestroyed
(
[
this
]
(
PortInterface
*
port
)
{
OnDestroyed
(
port
)
;
}
)
;
}
void
OnDestroyed
(
webrtc
:
:
PortInterface
*
port
)
{
+
+
ports_destroyed_
;
}
int
ports_destroyed
(
)
const
{
return
ports_destroyed_
;
}
webrtc
:
:
BasicPacketSocketFactory
*
nat_socket_factory1
(
)
{
return
&
nat_socket_factory1_
;
}
webrtc
:
:
VirtualSocketServer
*
vss
(
)
{
return
ss_
.
get
(
)
;
}
private
:
std
:
:
list
<
rtc
:
:
Network
>
networks_
;
std
:
:
unique_ptr
<
webrtc
:
:
VirtualSocketServer
>
ss_
;
rtc
:
:
AutoSocketServerThread
main_
;
webrtc
:
:
BasicPacketSocketFactory
socket_factory_
;
std
:
:
unique_ptr
<
webrtc
:
:
NATServer
>
nat_server1_
;
std
:
:
unique_ptr
<
webrtc
:
:
NATServer
>
nat_server2_
;
webrtc
:
:
NATSocketFactory
nat_factory1_
;
webrtc
:
:
NATSocketFactory
nat_factory2_
;
webrtc
:
:
BasicPacketSocketFactory
nat_socket_factory1_
;
webrtc
:
:
BasicPacketSocketFactory
nat_socket_factory2_
;
webrtc
:
:
TestStunServer
:
:
StunServerPtr
stun_server_
;
webrtc
:
:
TestTurnServer
turn_server_
;
std
:
:
string
username_
;
std
:
:
string
password_
;
bool
role_conflict_
;
int
ports_destroyed_
;
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials_
;
}
;
void
PortTest
:
:
TestConnectivity
(
absl
:
:
string_view
name1
std
:
:
unique_ptr
<
Port
>
port1
absl
:
:
string_view
name2
std
:
:
unique_ptr
<
Port
>
port2
bool
accept
bool
same_addr1
bool
same_addr2
bool
possible
)
{
webrtc
:
:
ScopedFakeClock
clock
;
RTC_LOG
(
LS_INFO
)
<
<
"
Test
:
"
<
<
name1
<
<
"
to
"
<
<
name2
<
<
"
:
"
;
port1
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
port2
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
EXPECT_EQ
(
0
ch1
.
complete_count
(
)
)
;
EXPECT_EQ
(
0
ch2
.
complete_count
(
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
Ping
(
)
;
SIMULATED_WAIT
(
!
ch2
.
remote_address
(
)
.
IsNil
(
)
kShortTimeout
clock
)
;
if
(
accept
)
{
EXPECT_TRUE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
EXPECT_EQ
(
ch2
.
remote_fragment
(
)
ch1
.
port
(
)
-
>
username_fragment
(
)
)
;
if
(
same_addr1
)
EXPECT_EQ
(
ch2
.
remote_address
(
)
GetAddress
(
ch1
.
port
(
)
)
)
;
EXPECT_TRUE
(
same_addr2
)
;
ch2
.
AcceptConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch2
.
conn
(
)
!
=
NULL
)
;
ch2
.
Ping
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
else
{
EXPECT_TRUE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
EXPECT_TRUE
(
ch2
.
remote_address
(
)
.
IsNil
(
)
)
;
ch2
.
CreateConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch2
.
conn
(
)
!
=
NULL
)
;
ch2
.
Ping
(
)
;
SIMULATED_WAIT
(
ch2
.
conn
(
)
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
kShortTimeout
clock
)
;
if
(
same_addr1
&
&
same_addr2
)
{
EXPECT_TRUE
(
ch1
.
conn
(
)
-
>
receiving
(
)
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITABLE
ch2
.
conn
(
)
-
>
write_state
(
)
)
;
if
(
ch1
.
conn
(
)
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITE_INIT
)
{
ch1
.
Ping
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
}
else
if
(
!
same_addr1
&
&
possible
)
{
EXPECT_TRUE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
EXPECT_TRUE
(
ch2
.
remote_address
(
)
.
IsNil
(
)
)
;
ch1
.
Ping
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ch2
.
remote_address
(
)
.
IsNil
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
ch2
.
conn
(
)
-
>
receiving
(
)
)
;
EXPECT_TRUE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
ch2
.
AcceptConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch2
.
conn
(
)
!
=
NULL
)
;
ch2
.
Ping
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
else
if
(
!
same_addr2
&
&
possible
)
{
EXPECT_FALSE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
EXPECT_FALSE
(
ch1
.
conn
(
)
-
>
receiving
(
)
)
;
ch1
.
AcceptConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ch1
.
Ping
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
else
{
EXPECT_TRUE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
EXPECT_TRUE
(
ch2
.
remote_address
(
)
.
IsNil
(
)
)
;
ch1
.
Ping
(
)
;
SIMULATED_WAIT
(
!
ch2
.
remote_address
(
)
.
IsNil
(
)
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ch1
.
remote_address
(
)
.
IsNil
(
)
)
;
EXPECT_TRUE
(
ch2
.
remote_address
(
)
.
IsNil
(
)
)
;
}
}
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
ASSERT_TRUE
(
ch2
.
conn
(
)
!
=
NULL
)
;
if
(
possible
)
{
EXPECT_TRUE
(
ch1
.
conn
(
)
-
>
receiving
(
)
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
EXPECT_TRUE
(
ch2
.
conn
(
)
-
>
receiving
(
)
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITABLE
ch2
.
conn
(
)
-
>
write_state
(
)
)
;
}
else
{
EXPECT_FALSE
(
ch1
.
conn
(
)
-
>
receiving
(
)
)
;
EXPECT_NE
(
Connection
:
:
STATE_WRITABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
EXPECT_FALSE
(
ch2
.
conn
(
)
-
>
receiving
(
)
)
;
EXPECT_NE
(
Connection
:
:
STATE_WRITABLE
ch2
.
conn
(
)
-
>
write_state
(
)
)
;
}
ch1
.
Stop
(
)
;
ch2
.
Stop
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
;
}
IsNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
conn
(
)
;
}
IsNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
class
FakePacketSocketFactory
:
public
webrtc
:
:
PacketSocketFactory
{
public
:
FakePacketSocketFactory
(
)
:
next_udp_socket_
(
NULL
)
next_server_tcp_socket_
(
NULL
)
{
}
~
FakePacketSocketFactory
(
)
override
{
}
AsyncPacketSocket
*
CreateUdpSocket
(
const
SocketAddress
&
address
uint16_t
min_port
uint16_t
max_port
)
override
{
EXPECT_TRUE
(
next_udp_socket_
!
=
NULL
)
;
AsyncPacketSocket
*
result
=
next_udp_socket_
;
next_udp_socket_
=
NULL
;
return
result
;
}
AsyncListenSocket
*
CreateServerTcpSocket
(
const
SocketAddress
&
local_address
uint16_t
min_port
uint16_t
max_port
int
opts
)
override
{
EXPECT_TRUE
(
next_server_tcp_socket_
!
=
NULL
)
;
AsyncListenSocket
*
result
=
next_server_tcp_socket_
;
next_server_tcp_socket_
=
NULL
;
return
result
;
}
AsyncPacketSocket
*
CreateClientTcpSocket
(
const
SocketAddress
&
local_address
const
SocketAddress
&
remote_address
const
webrtc
:
:
PacketSocketTcpOptions
&
opts
)
override
{
EXPECT_TRUE
(
next_client_tcp_socket_
.
has_value
(
)
)
;
AsyncPacketSocket
*
result
=
*
next_client_tcp_socket_
;
next_client_tcp_socket_
=
nullptr
;
return
result
;
}
void
set_next_udp_socket
(
AsyncPacketSocket
*
next_udp_socket
)
{
next_udp_socket_
=
next_udp_socket
;
}
void
set_next_server_tcp_socket
(
AsyncListenSocket
*
next_server_tcp_socket
)
{
next_server_tcp_socket_
=
next_server_tcp_socket
;
}
void
set_next_client_tcp_socket
(
AsyncPacketSocket
*
next_client_tcp_socket
)
{
next_client_tcp_socket_
=
next_client_tcp_socket
;
}
std
:
:
unique_ptr
<
webrtc
:
:
AsyncDnsResolverInterface
>
CreateAsyncDnsResolver
(
)
override
{
return
nullptr
;
}
private
:
AsyncPacketSocket
*
next_udp_socket_
;
AsyncListenSocket
*
next_server_tcp_socket_
;
std
:
:
optional
<
AsyncPacketSocket
*
>
next_client_tcp_socket_
;
}
;
class
FakeAsyncPacketSocket
:
public
AsyncPacketSocket
{
public
:
virtual
SocketAddress
GetLocalAddress
(
)
const
{
return
local_address_
;
}
virtual
SocketAddress
GetRemoteAddress
(
)
const
{
return
remote_address_
;
}
virtual
int
Send
(
const
void
*
pv
size_t
cb
const
rtc
:
:
PacketOptions
&
options
)
{
if
(
error_
=
=
0
)
{
return
static_cast
<
int
>
(
cb
)
;
}
else
{
return
-
1
;
}
}
virtual
int
SendTo
(
const
void
*
pv
size_t
cb
const
SocketAddress
&
addr
const
rtc
:
:
PacketOptions
&
options
)
{
if
(
error_
=
=
0
)
{
return
static_cast
<
int
>
(
cb
)
;
}
else
{
return
-
1
;
}
}
virtual
int
Close
(
)
{
return
0
;
}
virtual
State
GetState
(
)
const
{
return
state_
;
}
virtual
int
GetOption
(
Socket
:
:
Option
opt
int
*
value
)
{
return
0
;
}
virtual
int
SetOption
(
Socket
:
:
Option
opt
int
value
)
{
return
0
;
}
virtual
int
GetError
(
)
const
{
return
0
;
}
virtual
void
SetError
(
int
error
)
{
error_
=
error
;
}
void
set_state
(
State
state
)
{
state_
=
state
;
}
SocketAddress
local_address_
;
SocketAddress
remote_address_
;
private
:
int
error_
=
0
;
State
state_
;
}
;
class
FakeAsyncListenSocket
:
public
AsyncListenSocket
{
public
:
virtual
SocketAddress
GetLocalAddress
(
)
const
{
return
local_address_
;
}
void
Bind
(
const
SocketAddress
&
address
)
{
local_address_
=
address
;
state_
=
State
:
:
kBound
;
}
virtual
int
GetOption
(
Socket
:
:
Option
opt
int
*
value
)
{
return
0
;
}
virtual
int
SetOption
(
Socket
:
:
Option
opt
int
value
)
{
return
0
;
}
virtual
State
GetState
(
)
const
{
return
state_
;
}
private
:
SocketAddress
local_address_
;
State
state_
=
State
:
:
kClosed
;
}
;
TEST_F
(
PortTest
TestLocalToLocal
)
{
TestLocalToLocal
(
)
;
}
TEST_F
(
PortTest
TestLocalToConeNat
)
{
TestLocalToStun
(
webrtc
:
:
NAT_OPEN_CONE
)
;
}
TEST_F
(
PortTest
TestLocalToARNat
)
{
TestLocalToStun
(
webrtc
:
:
NAT_ADDR_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestLocalToPRNat
)
{
TestLocalToStun
(
webrtc
:
:
NAT_PORT_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestLocalToSymNat
)
{
TestLocalToStun
(
webrtc
:
:
NAT_SYMMETRIC
)
;
}
TEST_F
(
PortTest
DISABLED_TestLocalToTurn
)
{
TestLocalToRelay
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
PortTest
TestConeNatToLocal
)
{
TestStunToLocal
(
webrtc
:
:
NAT_OPEN_CONE
)
;
}
TEST_F
(
PortTest
TestConeNatToConeNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_OPEN_CONE
webrtc
:
:
NAT_OPEN_CONE
)
;
}
TEST_F
(
PortTest
TestConeNatToARNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_OPEN_CONE
webrtc
:
:
NAT_ADDR_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestConeNatToPRNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_OPEN_CONE
webrtc
:
:
NAT_PORT_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestConeNatToSymNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_OPEN_CONE
webrtc
:
:
NAT_SYMMETRIC
)
;
}
TEST_F
(
PortTest
TestConeNatToTurn
)
{
TestStunToRelay
(
webrtc
:
:
NAT_OPEN_CONE
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
PortTest
TestARNatToLocal
)
{
TestStunToLocal
(
webrtc
:
:
NAT_ADDR_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestARNatToConeNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_ADDR_RESTRICTED
webrtc
:
:
NAT_OPEN_CONE
)
;
}
TEST_F
(
PortTest
TestARNatToARNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_ADDR_RESTRICTED
webrtc
:
:
NAT_ADDR_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestARNatToPRNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_ADDR_RESTRICTED
webrtc
:
:
NAT_PORT_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestARNatToSymNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_ADDR_RESTRICTED
webrtc
:
:
NAT_SYMMETRIC
)
;
}
TEST_F
(
PortTest
TestARNatToTurn
)
{
TestStunToRelay
(
webrtc
:
:
NAT_ADDR_RESTRICTED
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
PortTest
TestPRNatToLocal
)
{
TestStunToLocal
(
webrtc
:
:
NAT_PORT_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestPRNatToConeNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_PORT_RESTRICTED
webrtc
:
:
NAT_OPEN_CONE
)
;
}
TEST_F
(
PortTest
TestPRNatToARNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_PORT_RESTRICTED
webrtc
:
:
NAT_ADDR_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestPRNatToPRNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_PORT_RESTRICTED
webrtc
:
:
NAT_PORT_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestPRNatToSymNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_PORT_RESTRICTED
webrtc
:
:
NAT_SYMMETRIC
)
;
}
TEST_F
(
PortTest
TestPRNatToTurn
)
{
TestStunToRelay
(
webrtc
:
:
NAT_PORT_RESTRICTED
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
PortTest
TestSymNatToLocal
)
{
TestStunToLocal
(
webrtc
:
:
NAT_SYMMETRIC
)
;
}
TEST_F
(
PortTest
TestSymNatToConeNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_SYMMETRIC
webrtc
:
:
NAT_OPEN_CONE
)
;
}
TEST_F
(
PortTest
TestSymNatToARNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_SYMMETRIC
webrtc
:
:
NAT_ADDR_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestSymNatToPRNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_SYMMETRIC
webrtc
:
:
NAT_PORT_RESTRICTED
)
;
}
TEST_F
(
PortTest
TestSymNatToSymNat
)
{
TestStunToStun
(
webrtc
:
:
NAT_SYMMETRIC
webrtc
:
:
NAT_SYMMETRIC
)
;
}
TEST_F
(
PortTest
TestSymNatToTurn
)
{
TestStunToRelay
(
webrtc
:
:
NAT_SYMMETRIC
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
PortTest
TestTcpToTcp
)
{
TestTcpToTcp
(
)
;
}
TEST_F
(
PortTest
TestTcpReconnectOnSendPacket
)
{
TestTcpReconnect
(
false
true
)
;
}
TEST_F
(
PortTest
TestTcpReconnectOnPing
)
{
TestTcpReconnect
(
true
false
)
;
}
TEST_F
(
PortTest
TestTcpReconnectTimeout
)
{
TestTcpReconnect
(
false
false
)
;
}
TEST_F
(
PortTest
TestTcpNeverConnect
)
{
auto
port1
=
CreateTcpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
port1
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
EXPECT_EQ
(
0
ch1
.
complete_count
(
)
)
;
ch1
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
std
:
:
unique_ptr
<
webrtc
:
:
Socket
>
server
(
vss
(
)
-
>
CreateSocket
(
kLocalAddr2
.
family
(
)
SOCK_STREAM
)
)
;
EXPECT_EQ
(
0
server
-
>
Bind
(
kLocalAddr2
)
)
;
webrtc
:
:
Candidate
c
=
GetCandidate
(
ch1
.
port
(
)
)
;
c
.
set_address
(
server
-
>
GetLocalAddress
(
)
)
;
ch1
.
CreateConnection
(
c
)
;
EXPECT_TRUE
(
ch1
.
conn
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ch1
.
conn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestConnectionDead
)
{
TestChannel
ch1
(
CreateUdpPort
(
kLocalAddr1
)
)
;
TestChannel
ch2
(
CreateUdpPort
(
kLocalAddr2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
int64_t
before_created
=
rtc
:
:
TimeMillis
(
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
int64_t
after_created
=
rtc
:
:
TimeMillis
(
)
;
Connection
*
conn
=
ch1
.
conn
(
)
;
ASSERT_NE
(
conn
nullptr
)
;
conn
-
>
UpdateState
(
after_created
+
MIN_CONNECTION_LIFETIME
+
1
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
0
)
;
EXPECT_TRUE
(
ch1
.
conn
(
)
!
=
nullptr
)
;
conn
-
>
UpdateState
(
before_created
+
MIN_CONNECTION_LIFETIME
-
1
)
;
conn
-
>
Prune
(
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
0
)
;
EXPECT_TRUE
(
ch1
.
conn
(
)
!
=
nullptr
)
;
conn
-
>
UpdateState
(
after_created
+
MIN_CONNECTION_LIFETIME
+
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
conn
=
ch1
.
conn
(
)
;
ASSERT_NE
(
conn
nullptr
)
;
int64_t
before_last_receiving
=
rtc
:
:
TimeMillis
(
)
;
conn
-
>
ReceivedPing
(
)
;
int64_t
after_last_receiving
=
rtc
:
:
TimeMillis
(
)
;
conn
-
>
UpdateState
(
before_last_receiving
+
DEAD_CONNECTION_RECEIVE_TIMEOUT
-
1
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
100
)
;
EXPECT_TRUE
(
ch1
.
conn
(
)
!
=
nullptr
)
;
conn
-
>
UpdateState
(
after_last_receiving
+
DEAD_CONNECTION_RECEIVE_TIMEOUT
+
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestConnectionDeadWithDeadConnectionTimeout
)
{
TestChannel
ch1
(
CreateUdpPort
(
kLocalAddr1
)
)
;
TestChannel
ch2
(
CreateUdpPort
(
kLocalAddr2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceFieldTrials
field_trials
;
field_trials
.
dead_connection_timeout_ms
=
90000
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
auto
conn
=
ch1
.
conn
(
)
;
conn
-
>
SetIceFieldTrials
(
&
field_trials
)
;
ASSERT_NE
(
conn
nullptr
)
;
int64_t
before_last_receiving
=
rtc
:
:
TimeMillis
(
)
;
conn
-
>
ReceivedPing
(
)
;
int64_t
after_last_receiving
=
rtc
:
:
TimeMillis
(
)
;
conn
-
>
UpdateState
(
before_last_receiving
+
90000
-
1
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
100
)
;
EXPECT_TRUE
(
ch1
.
conn
(
)
!
=
nullptr
)
;
conn
-
>
UpdateState
(
after_last_receiving
+
90000
+
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestConnectionDeadOutstandingPing
)
{
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
port1
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
port2
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceFieldTrials
field_trials
;
field_trials
.
dead_connection_timeout_ms
=
360000
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
auto
conn
=
ch1
.
conn
(
)
;
conn
-
>
SetIceFieldTrials
(
&
field_trials
)
;
ASSERT_NE
(
conn
nullptr
)
;
conn
-
>
ReceivedPing
(
)
;
int64_t
send_ping_timestamp
=
rtc
:
:
TimeMillis
(
)
;
conn
-
>
Ping
(
send_ping_timestamp
)
;
conn
-
>
UpdateState
(
send_ping_timestamp
+
DEAD_CONNECTION_RECEIVE_TIMEOUT
-
1
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
100
)
;
EXPECT_TRUE
(
ch1
.
conn
(
)
!
=
nullptr
)
;
conn
-
>
UpdateState
(
send_ping_timestamp
+
DEAD_CONNECTION_RECEIVE_TIMEOUT
+
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestLocalToLocalStandard
)
{
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
port1
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
port2
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
TestConnectivity
(
"
udp
"
std
:
:
move
(
port1
)
"
udp
"
std
:
:
move
(
port2
)
true
true
true
true
)
;
}
TEST_F
(
PortTest
TestLoopbackCall
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
lport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
conn
=
lport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
conn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
lport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
conn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
msg
=
lport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_RESPONSE
msg
-
>
type
(
)
)
;
lport
-
>
Reset
(
)
;
lport
-
>
AddCandidateAddress
(
kLocalAddr2
)
;
Connection
*
conn1
=
lport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
1
]
Port
:
:
ORIGIN_MESSAGE
)
;
conn1
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
msg
=
lport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
std
:
:
unique_ptr
<
IceMessage
>
modified_req
(
CreateStunMessage
(
STUN_BINDING_REQUEST
)
)
;
const
StunByteStringAttribute
*
username_attr
=
msg
-
>
GetByteString
(
STUN_ATTR_USERNAME
)
;
modified_req
-
>
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
username_attr
-
>
string_view
(
)
)
)
;
modified_req
-
>
AddAttribute
(
std
:
:
make_unique
<
StunUInt64Attribute
>
(
STUN_ATTR_ICE_CONTROLLING
kTiebreaker1
-
1
)
)
;
modified_req
-
>
AddMessageIntegrity
(
"
lpass
"
)
;
modified_req
-
>
AddFingerprint
(
)
;
lport
-
>
Reset
(
)
;
auto
buf
=
std
:
:
make_unique
<
ByteBufferWriter
>
(
)
;
WriteStunMessage
(
*
modified_req
buf
.
get
(
)
)
;
conn1
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
reinterpret_cast
<
const
char
*
>
(
buf
-
>
Data
(
)
)
buf
-
>
Length
(
)
-
1
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
msg
=
lport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_ERROR_RESPONSE
msg
-
>
type
(
)
)
;
}
TEST_F
(
PortTest
TestIceRoleConflict
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
rconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
rport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
STUN_BINDING_RESPONSE
lport
-
>
last_stun_msg
(
)
-
>
type
(
)
)
;
EXPECT_TRUE
(
role_conflict
(
)
)
;
}
TEST_F
(
PortTest
TestTcpNoDelay
)
{
webrtc
:
:
ScopedFakeClock
clock
;
auto
port1
=
CreateTcpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
int
option_value
=
-
1
;
int
success
=
port1
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_NODELAY
&
option_value
)
;
ASSERT_EQ
(
0
success
)
;
EXPECT_EQ
(
1
option_value
)
;
auto
port2
=
CreateTcpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
Ping
(
)
;
SIMULATED_WAIT
(
!
ch2
.
remote_address
(
)
.
IsNil
(
)
kShortTimeout
clock
)
;
ch2
.
AcceptConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch2
.
conn
(
)
!
=
NULL
)
;
option_value
=
-
1
;
success
=
static_cast
<
TCPConnection
*
>
(
ch1
.
conn
(
)
)
-
>
socket
(
)
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_NODELAY
&
option_value
)
;
ASSERT_EQ
(
0
success
)
;
EXPECT_EQ
(
1
option_value
)
;
option_value
=
-
1
;
success
=
static_cast
<
TCPConnection
*
>
(
ch2
.
conn
(
)
)
-
>
socket
(
)
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_NODELAY
&
option_value
)
;
ASSERT_EQ
(
0
success
)
;
EXPECT_EQ
(
1
option_value
)
;
}
TEST_F
(
PortTest
TestDelayedBindingUdp
)
{
FakeAsyncPacketSocket
*
socket
=
new
FakeAsyncPacketSocket
(
)
;
FakePacketSocketFactory
socket_factory
;
socket_factory
.
set_next_udp_socket
(
socket
)
;
auto
port
=
CreateUdpPort
(
kLocalAddr1
&
socket_factory
)
;
socket
-
>
set_state
(
AsyncPacketSocket
:
:
STATE_BINDING
)
;
port
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
0U
port
-
>
Candidates
(
)
.
size
(
)
)
;
socket
-
>
SignalAddressReady
(
socket
kLocalAddr2
)
;
EXPECT_EQ
(
1U
port
-
>
Candidates
(
)
.
size
(
)
)
;
}
TEST_F
(
PortTest
TestDisableInterfaceOfTcpPort
)
{
FakeAsyncListenSocket
*
lsocket
=
new
FakeAsyncListenSocket
(
)
;
FakeAsyncListenSocket
*
rsocket
=
new
FakeAsyncListenSocket
(
)
;
FakePacketSocketFactory
socket_factory
;
socket_factory
.
set_next_server_tcp_socket
(
lsocket
)
;
auto
lport
=
CreateTcpPort
(
kLocalAddr1
&
socket_factory
)
;
socket_factory
.
set_next_server_tcp_socket
(
rsocket
)
;
auto
rport
=
CreateTcpPort
(
kLocalAddr2
&
socket_factory
)
;
lsocket
-
>
Bind
(
kLocalAddr1
)
;
rsocket
-
>
Bind
(
kLocalAddr2
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
FakeAsyncPacketSocket
*
socket
=
new
FakeAsyncPacketSocket
(
)
;
socket
-
>
local_address_
=
kLocalAddr1
;
socket
-
>
remote_address_
=
kLocalAddr2
;
socket_factory
.
set_next_client_tcp_socket
(
socket
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_NE
(
lconn
nullptr
)
;
socket
-
>
SignalConnect
(
socket
)
;
lconn
-
>
Ping
(
0
)
;
socket
-
>
NotifyClosedForTest
(
1
)
;
socket_factory
.
set_next_client_tcp_socket
(
nullptr
)
;
lconn
-
>
Ping
(
0
)
;
}
void
PortTest
:
:
TestCrossFamilyPorts
(
int
type
)
{
FakePacketSocketFactory
factory
;
std
:
:
unique_ptr
<
Port
>
ports
[
4
]
;
SocketAddress
addresses
[
4
]
=
{
SocketAddress
(
"
192
.
168
.
1
.
3
"
0
)
SocketAddress
(
"
192
.
168
.
1
.
4
"
0
)
SocketAddress
(
"
2001
:
db8
:
:
1
"
0
)
SocketAddress
(
"
2001
:
db8
:
:
2
"
0
)
}
;
for
(
int
i
=
0
;
i
<
4
;
i
+
+
)
{
if
(
type
=
=
SOCK_DGRAM
)
{
FakeAsyncPacketSocket
*
socket
=
new
FakeAsyncPacketSocket
(
)
;
factory
.
set_next_udp_socket
(
socket
)
;
ports
[
i
]
=
CreateUdpPort
(
addresses
[
i
]
&
factory
)
;
socket
-
>
set_state
(
AsyncPacketSocket
:
:
STATE_BINDING
)
;
socket
-
>
SignalAddressReady
(
socket
addresses
[
i
]
)
;
}
else
if
(
type
=
=
SOCK_STREAM
)
{
FakeAsyncListenSocket
*
socket
=
new
FakeAsyncListenSocket
(
)
;
factory
.
set_next_server_tcp_socket
(
socket
)
;
ports
[
i
]
=
CreateTcpPort
(
addresses
[
i
]
&
factory
)
;
socket
-
>
Bind
(
addresses
[
i
]
)
;
}
ports
[
i
]
-
>
PrepareAddress
(
)
;
}
if
(
type
=
=
SOCK_STREAM
)
{
FakeAsyncPacketSocket
*
clientsocket
=
new
FakeAsyncPacketSocket
(
)
;
factory
.
set_next_client_tcp_socket
(
clientsocket
)
;
}
Connection
*
c
=
ports
[
0
]
-
>
CreateConnection
(
GetCandidate
(
ports
[
2
]
.
get
(
)
)
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_TRUE
(
NULL
=
=
c
)
;
EXPECT_EQ
(
0U
ports
[
0
]
-
>
connections
(
)
.
size
(
)
)
;
c
=
ports
[
0
]
-
>
CreateConnection
(
GetCandidate
(
ports
[
1
]
.
get
(
)
)
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_FALSE
(
NULL
=
=
c
)
;
EXPECT_EQ
(
1U
ports
[
0
]
-
>
connections
(
)
.
size
(
)
)
;
if
(
type
=
=
SOCK_STREAM
)
{
FakeAsyncPacketSocket
*
clientsocket
=
new
FakeAsyncPacketSocket
(
)
;
factory
.
set_next_client_tcp_socket
(
clientsocket
)
;
}
c
=
ports
[
2
]
-
>
CreateConnection
(
GetCandidate
(
ports
[
0
]
.
get
(
)
)
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_TRUE
(
NULL
=
=
c
)
;
EXPECT_EQ
(
0U
ports
[
2
]
-
>
connections
(
)
.
size
(
)
)
;
c
=
ports
[
2
]
-
>
CreateConnection
(
GetCandidate
(
ports
[
3
]
.
get
(
)
)
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_FALSE
(
NULL
=
=
c
)
;
EXPECT_EQ
(
1U
ports
[
2
]
-
>
connections
(
)
.
size
(
)
)
;
}
TEST_F
(
PortTest
TestSkipCrossFamilyTcp
)
{
TestCrossFamilyPorts
(
SOCK_STREAM
)
;
}
TEST_F
(
PortTest
TestSkipCrossFamilyUdp
)
{
TestCrossFamilyPorts
(
SOCK_DGRAM
)
;
}
void
PortTest
:
:
ExpectPortsCanConnect
(
bool
can_connect
Port
*
p1
Port
*
p2
)
{
Connection
*
c
=
p1
-
>
CreateConnection
(
GetCandidate
(
p2
)
Port
:
:
ORIGIN_MESSAGE
)
;
if
(
can_connect
)
{
EXPECT_FALSE
(
NULL
=
=
c
)
;
EXPECT_EQ
(
1U
p1
-
>
connections
(
)
.
size
(
)
)
;
}
else
{
EXPECT_TRUE
(
NULL
=
=
c
)
;
EXPECT_EQ
(
0U
p1
-
>
connections
(
)
.
size
(
)
)
;
}
}
TEST_F
(
PortTest
TestUdpSingleAddressV6CrossTypePorts
)
{
FakePacketSocketFactory
factory
;
std
:
:
unique_ptr
<
Port
>
ports
[
4
]
;
SocketAddress
addresses
[
4
]
=
{
SocketAddress
(
"
2001
:
db8
:
:
1
"
0
)
SocketAddress
(
"
fe80
:
:
1
"
0
)
SocketAddress
(
"
fe80
:
:
2
"
0
)
SocketAddress
(
"
:
:
1
"
0
)
}
;
for
(
int
i
=
0
;
i
<
4
;
i
+
+
)
{
FakeAsyncPacketSocket
*
socket
=
new
FakeAsyncPacketSocket
(
)
;
factory
.
set_next_udp_socket
(
socket
)
;
ports
[
i
]
=
CreateUdpPort
(
addresses
[
i
]
&
factory
)
;
socket
-
>
set_state
(
AsyncPacketSocket
:
:
STATE_BINDING
)
;
socket
-
>
SignalAddressReady
(
socket
addresses
[
i
]
)
;
ports
[
i
]
-
>
PrepareAddress
(
)
;
}
Port
*
standard
=
ports
[
0
]
.
get
(
)
;
Port
*
link_local1
=
ports
[
1
]
.
get
(
)
;
Port
*
link_local2
=
ports
[
2
]
.
get
(
)
;
Port
*
localhost
=
ports
[
3
]
.
get
(
)
;
ExpectPortsCanConnect
(
false
link_local1
standard
)
;
ExpectPortsCanConnect
(
false
standard
link_local1
)
;
ExpectPortsCanConnect
(
false
link_local1
localhost
)
;
ExpectPortsCanConnect
(
false
localhost
link_local1
)
;
ExpectPortsCanConnect
(
true
link_local1
link_local2
)
;
ExpectPortsCanConnect
(
true
localhost
standard
)
;
ExpectPortsCanConnect
(
true
standard
localhost
)
;
}
TEST_F
(
PortTest
TestUdpMultipleAddressesV6CrossTypePorts
)
{
FakePacketSocketFactory
factory
;
std
:
:
unique_ptr
<
Port
>
ports
[
5
]
;
SocketAddress
addresses
[
5
]
=
{
SocketAddress
(
"
2001
:
db8
:
:
1
"
0
)
SocketAddress
(
"
2001
:
db8
:
:
2
"
0
)
SocketAddress
(
"
fe80
:
:
1
"
0
)
SocketAddress
(
"
fe80
:
:
2
"
0
)
SocketAddress
(
"
:
:
1
"
0
)
}
;
for
(
int
i
=
0
;
i
<
5
;
i
+
+
)
{
FakeAsyncPacketSocket
*
socket
=
new
FakeAsyncPacketSocket
(
)
;
factory
.
set_next_udp_socket
(
socket
)
;
ports
[
i
]
=
CreateUdpPortMultipleAddrs
(
addresses
[
i
]
kLinkLocalIPv6Addr
&
factory
)
;
ports
[
i
]
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
socket
-
>
set_state
(
AsyncPacketSocket
:
:
STATE_BINDING
)
;
socket
-
>
SignalAddressReady
(
socket
addresses
[
i
]
)
;
ports
[
i
]
-
>
PrepareAddress
(
)
;
}
Port
*
standard1
=
ports
[
0
]
.
get
(
)
;
Port
*
standard2
=
ports
[
1
]
.
get
(
)
;
Port
*
link_local1
=
ports
[
2
]
.
get
(
)
;
Port
*
link_local2
=
ports
[
3
]
.
get
(
)
;
Port
*
localhost
=
ports
[
4
]
.
get
(
)
;
ExpectPortsCanConnect
(
false
link_local1
standard1
)
;
ExpectPortsCanConnect
(
false
standard1
link_local1
)
;
ExpectPortsCanConnect
(
false
link_local1
localhost
)
;
ExpectPortsCanConnect
(
false
localhost
link_local1
)
;
ExpectPortsCanConnect
(
true
link_local1
link_local2
)
;
ExpectPortsCanConnect
(
true
localhost
standard1
)
;
ExpectPortsCanConnect
(
true
standard1
localhost
)
;
ExpectPortsCanConnect
(
true
standard2
standard1
)
;
}
TEST_F
(
PortTest
TestDefaultDscpValue
)
{
int
dscp
;
auto
udpport
=
CreateUdpPort
(
kLocalAddr1
)
;
EXPECT_EQ
(
0
udpport
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS6
)
)
;
EXPECT_EQ
(
0
udpport
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
&
dscp
)
)
;
auto
tcpport
=
CreateTcpPort
(
kLocalAddr1
)
;
EXPECT_EQ
(
0
tcpport
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_AF31
)
)
;
EXPECT_EQ
(
0
tcpport
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
&
dscp
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_AF31
dscp
)
;
auto
stunport
=
CreateStunPort
(
kLocalAddr1
nat_socket_factory1
(
)
)
;
EXPECT_EQ
(
0
stunport
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_AF41
)
)
;
EXPECT_EQ
(
0
stunport
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
&
dscp
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_AF41
dscp
)
;
auto
turnport1
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
)
;
turnport1
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
0
turnport1
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS7
)
)
;
EXPECT_EQ
(
0
turnport1
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
&
dscp
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_CS7
dscp
)
;
auto
turnport2
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
)
;
EXPECT_EQ
(
0
turnport2
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS6
)
)
;
EXPECT_EQ
(
0
turnport2
-
>
GetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
&
dscp
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_CS6
dscp
)
;
}
TEST_F
(
PortTest
TestSendStunMessage
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
lconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
lport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
EXPECT_FALSE
(
msg
-
>
IsLegacy
(
)
)
;
const
StunByteStringAttribute
*
username_attr
=
msg
-
>
GetByteString
(
STUN_ATTR_USERNAME
)
;
ASSERT_TRUE
(
username_attr
!
=
NULL
)
;
const
StunUInt32Attribute
*
priority_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_PRIORITY
)
;
ASSERT_TRUE
(
priority_attr
!
=
NULL
)
;
EXPECT_EQ
(
kDefaultPrflxPriority
priority_attr
-
>
value
(
)
)
;
EXPECT_EQ
(
"
rfrag
:
lfrag
"
username_attr
-
>
string_view
(
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_MESSAGE_INTEGRITY
)
!
=
NULL
)
;
EXPECT_EQ
(
StunMessage
:
:
IntegrityStatus
:
:
kIntegrityOk
msg
-
>
ValidateMessageIntegrity
(
"
rpass
"
)
)
;
const
StunUInt64Attribute
*
ice_controlling_attr
=
msg
-
>
GetUInt64
(
STUN_ATTR_ICE_CONTROLLING
)
;
ASSERT_TRUE
(
ice_controlling_attr
!
=
NULL
)
;
EXPECT_EQ
(
lport
-
>
IceTiebreaker
(
)
ice_controlling_attr
-
>
value
(
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_ICE_CONTROLLED
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USE_CANDIDATE
)
!
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetUInt32
(
STUN_ATTR_FINGERPRINT
)
!
=
NULL
)
;
EXPECT_TRUE
(
StunMessage
:
:
ValidateFingerprint
(
reinterpret_cast
<
const
char
*
>
(
lport
-
>
last_stun_buf
(
)
.
data
(
)
)
lport
-
>
last_stun_buf
(
)
.
size
(
)
)
)
;
ASSERT_TRUE
(
msg
-
>
GetUInt32
(
STUN_ATTR_RETRANSMIT_COUNT
)
=
=
NULL
)
;
std
:
:
unique_ptr
<
IceMessage
>
request
=
CopyStunMessage
(
*
msg
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
msg
=
rport
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
msg
!
=
NULL
)
;
EXPECT_EQ
(
STUN_BINDING_RESPONSE
msg
-
>
type
(
)
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_EQ
(
1U
lconn
-
>
stats
(
)
.
sent_ping_requests_total
)
;
EXPECT_EQ
(
1U
lconn
-
>
stats
(
)
.
sent_ping_requests_before_first_response
)
;
EXPECT_EQ
(
1U
lconn
-
>
stats
(
)
.
recv_ping_responses
)
;
EXPECT_EQ
(
1U
rconn
-
>
stats
(
)
.
recv_ping_requests
)
;
EXPECT_EQ
(
1U
rconn
-
>
stats
(
)
.
sent_ping_responses
)
;
EXPECT_FALSE
(
msg
-
>
IsLegacy
(
)
)
;
const
StunAddressAttribute
*
addr_attr
=
msg
-
>
GetAddress
(
STUN_ATTR_XOR_MAPPED_ADDRESS
)
;
ASSERT_TRUE
(
addr_attr
!
=
NULL
)
;
EXPECT_EQ
(
lport
-
>
Candidates
(
)
[
0
]
.
address
(
)
addr_attr
-
>
GetAddress
(
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_MESSAGE_INTEGRITY
)
!
=
NULL
)
;
EXPECT_EQ
(
StunMessage
:
:
IntegrityStatus
:
:
kIntegrityOk
msg
-
>
ValidateMessageIntegrity
(
"
rpass
"
)
)
;
EXPECT_TRUE
(
msg
-
>
GetUInt32
(
STUN_ATTR_FINGERPRINT
)
!
=
NULL
)
;
EXPECT_TRUE
(
StunMessage
:
:
ValidateFingerprint
(
reinterpret_cast
<
const
char
*
>
(
lport
-
>
last_stun_buf
(
)
.
data
(
)
)
lport
-
>
last_stun_buf
(
)
.
size
(
)
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USERNAME
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_PRIORITY
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_MAPPED_ADDRESS
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_ICE_CONTROLLING
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_ICE_CONTROLLED
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USE_CANDIDATE
)
=
=
NULL
)
;
ASSERT_TRUE
(
msg
-
>
GetUInt32
(
STUN_ATTR_RETRANSMIT_COUNT
)
=
=
NULL
)
;
rport
-
>
SendBindingErrorResponse
(
request
.
get
(
)
lport
-
>
Candidates
(
)
[
0
]
.
address
(
)
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
;
msg
=
rport
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
msg
!
=
NULL
)
;
EXPECT_EQ
(
STUN_BINDING_ERROR_RESPONSE
msg
-
>
type
(
)
)
;
EXPECT_FALSE
(
msg
-
>
IsLegacy
(
)
)
;
const
StunErrorCodeAttribute
*
error_attr
=
msg
-
>
GetErrorCode
(
)
;
ASSERT_TRUE
(
error_attr
!
=
NULL
)
;
EXPECT_EQ
(
STUN_ERROR_SERVER_ERROR
error_attr
-
>
code
(
)
)
;
EXPECT_EQ
(
std
:
:
string
(
STUN_ERROR_REASON_SERVER_ERROR
)
error_attr
-
>
reason
(
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_MESSAGE_INTEGRITY
)
!
=
NULL
)
;
EXPECT_EQ
(
StunMessage
:
:
IntegrityStatus
:
:
kIntegrityOk
msg
-
>
ValidateMessageIntegrity
(
"
rpass
"
)
)
;
EXPECT_TRUE
(
msg
-
>
GetUInt32
(
STUN_ATTR_FINGERPRINT
)
!
=
NULL
)
;
EXPECT_TRUE
(
StunMessage
:
:
ValidateFingerprint
(
reinterpret_cast
<
const
char
*
>
(
lport
-
>
last_stun_buf
(
)
.
data
(
)
)
lport
-
>
last_stun_buf
(
)
.
size
(
)
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USERNAME
)
=
=
NULL
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_PRIORITY
)
=
=
NULL
)
;
rport
-
>
Reset
(
)
;
rport
-
>
set_send_retransmit_count_attribute
(
true
)
;
rconn
-
>
Ping
(
0
)
;
rconn
-
>
Ping
(
0
)
;
rconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
msg
=
rport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
const
StunUInt64Attribute
*
ice_controlled_attr
=
msg
-
>
GetUInt64
(
STUN_ATTR_ICE_CONTROLLED
)
;
ASSERT_TRUE
(
ice_controlled_attr
!
=
NULL
)
;
EXPECT_EQ
(
rport
-
>
IceTiebreaker
(
)
ice_controlled_attr
-
>
value
(
)
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USE_CANDIDATE
)
=
=
NULL
)
;
const
StunUInt32Attribute
*
retransmit_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_RETRANSMIT_COUNT
)
;
ASSERT_TRUE
(
retransmit_attr
!
=
NULL
)
;
EXPECT_EQ
(
2U
retransmit_attr
-
>
value
(
)
)
;
request
=
CopyStunMessage
(
*
msg
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
msg
=
lport
-
>
last_stun_msg
(
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_EQ
(
3U
rconn
-
>
stats
(
)
.
sent_ping_requests_total
)
;
EXPECT_EQ
(
3U
rconn
-
>
stats
(
)
.
sent_ping_requests_before_first_response
)
;
EXPECT_EQ
(
1U
rconn
-
>
stats
(
)
.
recv_ping_responses
)
;
EXPECT_EQ
(
1U
lconn
-
>
stats
(
)
.
sent_ping_responses
)
;
EXPECT_EQ
(
1U
lconn
-
>
stats
(
)
.
recv_ping_requests
)
;
rconn
-
>
Ping
(
0
)
;
rconn
-
>
Ping
(
0
)
;
EXPECT_EQ
(
5U
rconn
-
>
stats
(
)
.
sent_ping_requests_total
)
;
EXPECT_EQ
(
3U
rconn
-
>
stats
(
)
.
sent_ping_requests_before_first_response
)
;
retransmit_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_RETRANSMIT_COUNT
)
;
ASSERT_TRUE
(
retransmit_attr
!
=
NULL
)
;
EXPECT_EQ
(
2U
retransmit_attr
-
>
value
(
)
)
;
}
TEST_F
(
PortTest
TestNomination
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
uint32_t
nomination
=
1234
;
lconn
-
>
set_nomination
(
nomination
)
;
EXPECT_FALSE
(
lconn
-
>
nominated
(
)
)
;
EXPECT_FALSE
(
rconn
-
>
nominated
(
)
)
;
EXPECT_EQ
(
lconn
-
>
nominated
(
)
lconn
-
>
stats
(
)
.
nominated
)
;
EXPECT_EQ
(
rconn
-
>
nominated
(
)
rconn
-
>
stats
(
)
.
nominated
)
;
lconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
lport
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_EQ
(
nomination
rconn
-
>
remote_nomination
(
)
)
;
EXPECT_FALSE
(
lconn
-
>
nominated
(
)
)
;
EXPECT_TRUE
(
rconn
-
>
nominated
(
)
)
;
EXPECT_EQ
(
lconn
-
>
nominated
(
)
lconn
-
>
stats
(
)
.
nominated
)
;
EXPECT_EQ
(
rconn
-
>
nominated
(
)
rconn
-
>
stats
(
)
.
nominated
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
rport
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_EQ
(
nomination
lconn
-
>
acked_nomination
(
)
)
;
EXPECT_TRUE
(
lconn
-
>
nominated
(
)
)
;
EXPECT_TRUE
(
rconn
-
>
nominated
(
)
)
;
EXPECT_EQ
(
lconn
-
>
nominated
(
)
lconn
-
>
stats
(
)
.
nominated
)
;
EXPECT_EQ
(
rconn
-
>
nominated
(
)
rconn
-
>
stats
(
)
.
nominated
)
;
}
TEST_F
(
PortTest
TestRoundTripTime
)
{
webrtc
:
:
ScopedFakeClock
clock
;
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_EQ
(
0u
lconn
-
>
stats
(
)
.
total_round_trip_time_ms
)
;
EXPECT_FALSE
(
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
SendPingAndReceiveResponse
(
lconn
lport
.
get
(
)
rconn
rport
.
get
(
)
&
clock
10
)
;
EXPECT_EQ
(
10u
lconn
-
>
stats
(
)
.
total_round_trip_time_ms
)
;
ASSERT_TRUE
(
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
EXPECT_EQ
(
10u
*
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
SendPingAndReceiveResponse
(
lconn
lport
.
get
(
)
rconn
rport
.
get
(
)
&
clock
20
)
;
EXPECT_EQ
(
30u
lconn
-
>
stats
(
)
.
total_round_trip_time_ms
)
;
ASSERT_TRUE
(
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
EXPECT_EQ
(
20u
*
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
SendPingAndReceiveResponse
(
lconn
lport
.
get
(
)
rconn
rport
.
get
(
)
&
clock
30
)
;
EXPECT_EQ
(
60u
lconn
-
>
stats
(
)
.
total_round_trip_time_ms
)
;
ASSERT_TRUE
(
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
EXPECT_EQ
(
30u
*
lconn
-
>
stats
(
)
.
current_round_trip_time_ms
)
;
}
TEST_F
(
PortTest
TestUseCandidateAttribute
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
lconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
lport
-
>
last_stun_msg
(
)
;
const
StunUInt64Attribute
*
ice_controlling_attr
=
msg
-
>
GetUInt64
(
STUN_ATTR_ICE_CONTROLLING
)
;
ASSERT_TRUE
(
ice_controlling_attr
!
=
NULL
)
;
const
StunByteStringAttribute
*
use_candidate_attr
=
msg
-
>
GetByteString
(
STUN_ATTR_USE_CANDIDATE
)
;
ASSERT_TRUE
(
use_candidate_attr
!
=
NULL
)
;
}
TEST_F
(
PortTest
TestNetworkCostChange
)
{
rtc
:
:
Network
*
test_network
=
MakeNetwork
(
kLocalAddr1
)
;
auto
lport
=
CreateTestPort
(
test_network
"
lfrag
"
"
lpass
"
)
;
auto
rport
=
CreateTestPort
(
test_network
"
rfrag
"
"
rpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostUnknown
lport
-
>
network_cost
(
)
)
;
ASSERT_TRUE
(
!
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
for
(
const
cricket
:
:
Candidate
&
candidate
:
lport
-
>
Candidates
(
)
)
{
EXPECT_EQ
(
webrtc
:
:
kNetworkCostUnknown
candidate
.
network_cost
(
)
)
;
}
test_network
-
>
set_type
(
webrtc
:
:
ADAPTER_TYPE_WIFI
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostLow
lport
-
>
network_cost
(
)
)
;
for
(
const
cricket
:
:
Candidate
&
candidate
:
lport
-
>
Candidates
(
)
)
{
EXPECT_EQ
(
webrtc
:
:
kNetworkCostLow
candidate
.
network_cost
(
)
)
;
}
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
test_network
-
>
set_type
(
webrtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostHigh
lport
-
>
network_cost
(
)
)
;
for
(
const
cricket
:
:
Candidate
&
candidate
:
lport
-
>
Candidates
(
)
)
{
EXPECT_EQ
(
webrtc
:
:
kNetworkCostHigh
candidate
.
network_cost
(
)
)
;
}
test_network
-
>
set_type
(
webrtc
:
:
ADAPTER_TYPE_WIFI
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
test_network
-
>
set_type
(
webrtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
lconn
-
>
Ping
(
0
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostLow
rconn
-
>
remote_candidate
(
)
.
network_cost
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
lport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostHigh
rconn
-
>
remote_candidate
(
)
.
network_cost
(
)
)
;
}
TEST_F
(
PortTest
TestNetworkInfoAttribute
)
{
rtc
:
:
Network
*
test_network
=
MakeNetwork
(
kLocalAddr1
)
;
auto
lport
=
CreateTestPort
(
test_network
"
lfrag
"
"
lpass
"
)
;
auto
rport
=
CreateTestPort
(
test_network
"
rfrag
"
"
rpass
"
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
uint16_t
lnetwork_id
=
9
;
test_network
-
>
set_id
(
lnetwork_id
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
lconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
lport
-
>
last_stun_msg
(
)
;
const
StunUInt32Attribute
*
network_info_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_GOOG_NETWORK_INFO
)
;
ASSERT_TRUE
(
network_info_attr
!
=
NULL
)
;
uint32_t
network_info
=
network_info_attr
-
>
value
(
)
;
EXPECT_EQ
(
lnetwork_id
network_info
>
>
16
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostUnknown
network_info
&
0xFFFF
)
;
test_network
-
>
set_type
(
webrtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
uint16_t
rnetwork_id
=
8
;
test_network
-
>
set_id
(
rnetwork_id
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
rconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
msg
=
rport
-
>
last_stun_msg
(
)
;
network_info_attr
=
msg
-
>
GetUInt32
(
STUN_ATTR_GOOG_NETWORK_INFO
)
;
ASSERT_TRUE
(
network_info_attr
!
=
NULL
)
;
network_info
=
network_info_attr
-
>
value
(
)
;
EXPECT_EQ
(
rnetwork_id
network_info
>
>
16
)
;
EXPECT_EQ
(
webrtc
:
:
kNetworkCostHigh
network_info
&
0xFFFF
)
;
}
TEST_F
(
PortTest
TestHandleStunMessage
)
{
auto
port
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
std
:
:
unique_ptr
<
IceMessage
>
in_msg
out_msg
;
auto
buf
=
std
:
:
make_unique
<
ByteBufferWriter
>
(
)
;
webrtc
:
:
SocketAddress
addr
(
kLocalAddr1
)
;
std
:
:
string
username
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
rfrag
:
lfrag
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
!
=
NULL
)
;
EXPECT_EQ
(
"
lfrag
"
username
)
;
in_msg
=
CreateStunMessage
(
STUN_BINDING_RESPONSE
)
;
in_msg
-
>
AddAttribute
(
std
:
:
make_unique
<
StunXorAddressAttribute
>
(
STUN_ATTR_XOR_MAPPED_ADDRESS
kLocalAddr2
)
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
!
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
in_msg
=
CreateStunMessage
(
STUN_BINDING_ERROR_RESPONSE
)
;
in_msg
-
>
AddAttribute
(
std
:
:
make_unique
<
StunErrorCodeAttribute
>
(
STUN_ATTR_ERROR_CODE
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
!
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
ASSERT_TRUE
(
out_msg
-
>
GetErrorCode
(
)
!
=
NULL
)
;
EXPECT_EQ
(
STUN_ERROR_SERVER_ERROR
out_msg
-
>
GetErrorCode
(
)
-
>
code
(
)
)
;
EXPECT_EQ
(
std
:
:
string
(
STUN_ERROR_REASON_SERVER_ERROR
)
out_msg
-
>
GetErrorCode
(
)
-
>
reason
(
)
)
;
}
TEST_F
(
PortTest
TestHandleStunMessageBadUsername
)
{
auto
port
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
std
:
:
unique_ptr
<
IceMessage
>
in_msg
out_msg
;
auto
buf
=
std
:
:
make_unique
<
ByteBufferWriter
>
(
)
;
webrtc
:
:
SocketAddress
addr
(
kLocalAddr1
)
;
std
:
:
string
username
;
in_msg
=
CreateStunMessage
(
STUN_BINDING_REQUEST
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_BAD_REQUEST
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_UNAUTHORIZED
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
rfra
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_UNAUTHORIZED
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
lfrag
:
rfrag
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_UNAUTHORIZED
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
abcd
:
efgh
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_UNAUTHORIZED
port
-
>
last_stun_error_code
(
)
)
;
}
TEST_F
(
PortTest
TestHandleStunMessageBadMessageIntegrity
)
{
auto
port
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
std
:
:
unique_ptr
<
IceMessage
>
in_msg
out_msg
;
auto
buf
=
std
:
:
make_unique
<
ByteBufferWriter
>
(
)
;
webrtc
:
:
SocketAddress
addr
(
kLocalAddr1
)
;
std
:
:
string
username
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
rfrag
:
lfrag
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_BAD_REQUEST
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
rfrag
:
lfrag
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
invalid
"
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
=
=
NULL
)
;
EXPECT_EQ
(
"
"
username
)
;
EXPECT_EQ
(
STUN_ERROR_UNAUTHORIZED
port
-
>
last_stun_error_code
(
)
)
;
}
TEST_F
(
PortTest
TestHandleStunMessageBadFingerprint
)
{
auto
port
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
std
:
:
unique_ptr
<
IceMessage
>
in_msg
out_msg
;
auto
buf
=
std
:
:
make_unique
<
ByteBufferWriter
>
(
)
;
webrtc
:
:
SocketAddress
addr
(
kLocalAddr1
)
;
std
:
:
string
username
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
rfrag
:
lfrag
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_FALSE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_EQ
(
0
port
-
>
last_stun_error_code
(
)
)
;
in_msg
-
>
AddFingerprint
(
)
;
in_msg
-
>
SetTransactionIdForTesting
(
"
TESTTESTBADD
"
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_FALSE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_EQ
(
0
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessage
(
STUN_BINDING_RESPONSE
)
;
in_msg
-
>
AddAttribute
(
std
:
:
make_unique
<
StunXorAddressAttribute
>
(
STUN_ATTR_XOR_MAPPED_ADDRESS
kLocalAddr2
)
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_FALSE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_EQ
(
0
port
-
>
last_stun_error_code
(
)
)
;
in_msg
-
>
AddFingerprint
(
)
;
in_msg
-
>
SetTransactionIdForTesting
(
"
TESTTESTBADD
"
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_FALSE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_EQ
(
0
port
-
>
last_stun_error_code
(
)
)
;
in_msg
=
CreateStunMessage
(
STUN_BINDING_ERROR_RESPONSE
)
;
in_msg
-
>
AddAttribute
(
std
:
:
make_unique
<
StunErrorCodeAttribute
>
(
STUN_ATTR_ERROR_CODE
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_FALSE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_EQ
(
0
port
-
>
last_stun_error_code
(
)
)
;
in_msg
-
>
AddFingerprint
(
)
;
in_msg
-
>
SetTransactionIdForTesting
(
"
TESTTESTBADD
"
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_FALSE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_EQ
(
0
port
-
>
last_stun_error_code
(
)
)
;
}
TEST_F
(
PortTest
TestHandleStunRequestWithUnknownComprehensionRequiredAttribute
)
{
std
:
:
unique_ptr
<
TestPort
>
port
(
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
)
;
std
:
:
unique_ptr
<
IceMessage
>
in_msg
out_msg
;
auto
buf
=
std
:
:
make_unique
<
ByteBufferWriter
>
(
)
;
webrtc
:
:
SocketAddress
addr
(
kLocalAddr1
)
;
std
:
:
string
username
;
in_msg
=
CreateStunMessageWithUsername
(
STUN_BINDING_REQUEST
"
rfrag
:
lfrag
"
)
;
in_msg
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
in_msg
-
>
AddAttribute
(
StunAttribute
:
:
CreateUInt32
(
0x7777
)
)
;
in_msg
-
>
AddAttribute
(
StunAttribute
:
:
CreateUInt32
(
0x4567
)
)
;
in_msg
-
>
AddAttribute
(
StunAttribute
:
:
CreateUInt32
(
0xdead
)
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
ASSERT_TRUE
(
GetStunMessageFromBufferWriter
(
port
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
IceMessage
*
error_response
=
port
-
>
last_stun_msg
(
)
;
ASSERT_NE
(
nullptr
error_response
)
;
EXPECT_EQ
(
STUN_ERROR_UNKNOWN_ATTRIBUTE
error_response
-
>
GetErrorCodeValue
(
)
)
;
const
StunUInt16ListAttribute
*
unknown_attributes
=
error_response
-
>
GetUnknownAttributes
(
)
;
ASSERT_NE
(
nullptr
unknown_attributes
)
;
ASSERT_EQ
(
2u
unknown_attributes
-
>
Size
(
)
)
;
EXPECT_EQ
(
0x7777
unknown_attributes
-
>
GetType
(
0
)
)
;
EXPECT_EQ
(
0x4567
unknown_attributes
-
>
GetType
(
1
)
)
;
}
TEST_F
(
PortTest
TestHandleStunResponseWithUnknownComprehensionRequiredAttribute
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreakerDefault
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreakerDefault
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
lconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
auto
modified_response
=
rport
-
>
last_stun_msg
(
)
-
>
Clone
(
)
;
modified_response
-
>
AddAttribute
(
StunAttribute
:
:
CreateUInt32
(
0x7777
)
)
;
modified_response
-
>
RemoveAttribute
(
STUN_ATTR_FINGERPRINT
)
;
modified_response
-
>
AddFingerprint
(
)
;
ByteBufferWriter
buf
;
WriteStunMessage
(
*
modified_response
&
buf
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
reinterpret_cast
<
const
char
*
>
(
buf
.
Data
(
)
)
buf
.
Length
(
)
-
1
)
)
;
EXPECT_FALSE
(
lconn
-
>
writable
(
)
)
;
}
TEST_F
(
PortTest
TestHandleStunIndicationWithUnknownComprehensionRequiredAttribute
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr2
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreakerDefault
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreakerDefault
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
auto
in_msg
=
CreateStunMessage
(
STUN_BINDING_INDICATION
)
;
in_msg
-
>
AddAttribute
(
StunAttribute
:
:
CreateUInt32
(
0x7777
)
)
;
in_msg
-
>
AddFingerprint
(
)
;
ByteBufferWriter
buf
;
WriteStunMessage
(
*
in_msg
&
buf
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
buf
.
Data
(
)
buf
.
Length
(
)
-
1
)
)
;
EXPECT_EQ
(
0u
lconn
-
>
last_ping_received
(
)
)
;
}
TEST_F
(
PortTest
TestHandleStunBindingIndication
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr2
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
std
:
:
unique_ptr
<
IceMessage
>
in_msg
out_msg
;
std
:
:
unique_ptr
<
ByteBufferWriter
>
buf
(
new
ByteBufferWriter
(
)
)
;
webrtc
:
:
SocketAddress
addr
(
kLocalAddr1
)
;
std
:
:
string
username
;
in_msg
=
CreateStunMessage
(
STUN_BINDING_INDICATION
)
;
in_msg
-
>
AddFingerprint
(
)
;
WriteStunMessage
(
*
in_msg
buf
.
get
(
)
)
;
EXPECT_TRUE
(
GetStunMessageFromBufferWriter
(
lport
.
get
(
)
buf
.
get
(
)
addr
&
out_msg
&
username
)
)
;
EXPECT_TRUE
(
out_msg
.
get
(
)
!
=
NULL
)
;
EXPECT_EQ
(
out_msg
-
>
type
(
)
STUN_BINDING_INDICATION
)
;
EXPECT_EQ
(
"
"
username
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport
-
>
PrepareAddress
(
)
;
rport
-
>
PrepareAddress
(
)
;
ASSERT_FALSE
(
lport
-
>
Candidates
(
)
.
empty
(
)
)
;
ASSERT_FALSE
(
rport
-
>
Candidates
(
)
.
empty
(
)
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
rconn
-
>
Ping
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
rport
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
STUN_BINDING_REQUEST
msg
-
>
type
(
)
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
STUN_BINDING_RESPONSE
lport
-
>
last_stun_msg
(
)
-
>
type
(
)
)
;
int64_t
last_ping_received1
=
lconn
-
>
last_ping_received
(
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
100
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
buf
-
>
Data
(
)
buf
-
>
Length
(
)
-
1
)
)
;
int64_t
last_ping_received2
=
lconn
-
>
last_ping_received
(
)
;
EXPECT_GT
(
last_ping_received2
last_ping_received1
)
;
}
TEST_F
(
PortTest
TestComputeCandidatePriority
)
{
auto
port
=
CreateTestPort
(
kLocalAddr1
"
name
"
"
pass
"
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
port
-
>
set_type_preference
(
90
)
;
port
-
>
set_component
(
177
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
192
.
168
.
1
.
4
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
2001
:
db8
:
:
1234
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
fc12
:
3456
:
:
1234
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
:
:
ffff
:
192
.
168
.
1
.
4
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
:
:
192
.
168
.
1
.
4
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
2002
:
:
1234
:
5678
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
2001
:
:
1234
:
5678
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
fecf
:
:
1234
:
5678
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
3ffe
:
:
1234
:
5678
"
1234
)
)
;
uint32_t
expected_priority_v4
=
1509957199U
;
uint32_t
expected_priority_v6
=
1509959759U
;
uint32_t
expected_priority_ula
=
1509962319U
;
uint32_t
expected_priority_v4mapped
=
expected_priority_v4
;
uint32_t
expected_priority_v4compat
=
1509949775U
;
uint32_t
expected_priority_6to4
=
1509954639U
;
uint32_t
expected_priority_teredo
=
1509952079U
;
uint32_t
expected_priority_sitelocal
=
1509949775U
;
uint32_t
expected_priority_6bone
=
1509949775U
;
ASSERT_EQ
(
expected_priority_v4
port
-
>
Candidates
(
)
[
0
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_v6
port
-
>
Candidates
(
)
[
1
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_ula
port
-
>
Candidates
(
)
[
2
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_v4mapped
port
-
>
Candidates
(
)
[
3
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_v4compat
port
-
>
Candidates
(
)
[
4
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_6to4
port
-
>
Candidates
(
)
[
5
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_teredo
port
-
>
Candidates
(
)
[
6
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_sitelocal
port
-
>
Candidates
(
)
[
7
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_6bone
port
-
>
Candidates
(
)
[
8
]
.
priority
(
)
)
;
}
TEST_F
(
PortTest
TestComputeCandidatePriorityWithPriorityAdjustment
)
{
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials
(
"
WebRTC
-
IncreaseIceCandidatePriorityHostSrflx
/
Enabled
/
"
)
;
auto
port
=
CreateTestPort
(
kLocalAddr1
"
name
"
"
pass
"
&
field_trials
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
port
-
>
set_type_preference
(
90
)
;
port
-
>
set_component
(
177
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
192
.
168
.
1
.
4
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
2001
:
db8
:
:
1234
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
fc12
:
3456
:
:
1234
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
:
:
ffff
:
192
.
168
.
1
.
4
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
:
:
192
.
168
.
1
.
4
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
2002
:
:
1234
:
5678
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
2001
:
:
1234
:
5678
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
fecf
:
:
1234
:
5678
"
1234
)
)
;
port
-
>
AddCandidateAddress
(
SocketAddress
(
"
3ffe
:
:
1234
:
5678
"
1234
)
)
;
uint32_t
expected_priority_v4
=
1509957199U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_v6
=
1509959759U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_ula
=
1509962319U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_v4mapped
=
expected_priority_v4
;
uint32_t
expected_priority_v4compat
=
1509949775U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_6to4
=
1509954639U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_teredo
=
1509952079U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_sitelocal
=
1509949775U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
uint32_t
expected_priority_6bone
=
1509949775U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
;
ASSERT_EQ
(
expected_priority_v4
port
-
>
Candidates
(
)
[
0
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_v6
port
-
>
Candidates
(
)
[
1
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_ula
port
-
>
Candidates
(
)
[
2
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_v4mapped
port
-
>
Candidates
(
)
[
3
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_v4compat
port
-
>
Candidates
(
)
[
4
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_6to4
port
-
>
Candidates
(
)
[
5
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_teredo
port
-
>
Candidates
(
)
[
6
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_sitelocal
port
-
>
Candidates
(
)
[
7
]
.
priority
(
)
)
;
ASSERT_EQ
(
expected_priority_6bone
port
-
>
Candidates
(
)
[
8
]
.
priority
(
)
)
;
}
TEST_F
(
PortTest
TestFoundation
)
{
auto
testport
=
CreateTestPort
(
kLocalAddr1
"
name
"
"
pass
"
)
;
testport
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
testport
-
>
AddCandidateAddress
(
kLocalAddr1
kLocalAddr1
IceCandidateType
:
:
kHost
cricket
:
:
ICE_TYPE_PREFERENCE_HOST
false
)
;
testport
-
>
AddCandidateAddress
(
kLocalAddr2
kLocalAddr1
IceCandidateType
:
:
kSrflx
cricket
:
:
ICE_TYPE_PREFERENCE_SRFLX
true
)
;
EXPECT_NE
(
testport
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
testport
-
>
Candidates
(
)
[
1
]
.
foundation
(
)
)
;
}
TEST_F
(
PortTest
TestCandidateFoundation
)
{
std
:
:
unique_ptr
<
webrtc
:
:
NATServer
>
nat_server
(
CreateNatServer
(
kNatAddr1
webrtc
:
:
NAT_OPEN_CONE
)
)
;
auto
udpport1
=
CreateUdpPort
(
kLocalAddr1
)
;
udpport1
-
>
PrepareAddress
(
)
;
auto
udpport2
=
CreateUdpPort
(
kLocalAddr1
)
;
udpport2
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
udpport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
udpport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
auto
tcpport1
=
CreateTcpPort
(
kLocalAddr1
)
;
tcpport1
-
>
PrepareAddress
(
)
;
auto
tcpport2
=
CreateTcpPort
(
kLocalAddr1
)
;
tcpport2
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
tcpport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
tcpport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
auto
stunport
=
CreateStunPort
(
kLocalAddr1
nat_socket_factory1
(
)
)
;
stunport
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
stunport
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
tcpport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
stunport
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
EXPECT_NE
(
tcpport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
stunport
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
EXPECT_NE
(
udpport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
stunport
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
EXPECT_NE
(
udpport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
stunport
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
auto
turnport1
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
)
;
turnport1
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turnport1
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
udpport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
turnport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
EXPECT_NE
(
udpport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
turnport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
EXPECT_NE
(
stunport
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
turnport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
auto
turnport2
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
)
;
turnport2
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turnport2
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
turnport1
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
turnport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
SocketAddress
kTurnUdpIntAddr2
(
"
99
.
99
.
98
.
4
"
webrtc
:
:
STUN_SERVER_PORT
)
;
SocketAddress
kTurnUdpExtAddr2
(
"
99
.
99
.
98
.
5
"
0
)
;
webrtc
:
:
TestTurnServer
turn_server2
(
rtc
:
:
Thread
:
:
Current
(
)
vss
(
)
kTurnUdpIntAddr2
kTurnUdpExtAddr2
)
;
auto
turnport3
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
kTurnUdpIntAddr2
)
;
turnport3
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turnport3
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
turnport3
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
turnport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
webrtc
:
:
TestTurnServer
turn_server3
(
rtc
:
:
Thread
:
:
Current
(
)
vss
(
)
kTurnTcpIntAddr
kTurnUdpExtAddr
webrtc
:
:
PROTO_TCP
)
;
auto
turnport4
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_TCP
webrtc
:
:
PROTO_UDP
)
;
turnport4
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turnport4
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
turnport2
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
turnport4
-
>
Candidates
(
)
[
0
]
.
foundation
(
)
)
;
}
TEST_F
(
PortTest
TestCandidateRelatedAddress
)
{
auto
nat_server
=
CreateNatServer
(
kNatAddr1
webrtc
:
:
NAT_OPEN_CONE
)
;
auto
udpport
=
CreateUdpPort
(
kLocalAddr1
)
;
udpport
-
>
PrepareAddress
(
)
;
EXPECT_TRUE
(
udpport
-
>
Candidates
(
)
[
0
]
.
related_address
(
)
.
IsNil
(
)
)
;
auto
stunport
=
CreateStunPort
(
kLocalAddr1
nat_socket_factory1
(
)
)
;
stunport
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
stunport
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
stunport
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
kNatAddr1
.
ipaddr
(
)
)
;
EXPECT_EQ
(
stunport
-
>
Candidates
(
)
[
0
]
.
related_address
(
)
stunport
-
>
GetLocalAddress
(
)
)
;
auto
turnport
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
)
;
turnport
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turnport
-
>
Candidates
(
)
.
size
(
)
;
}
Eq
(
1U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
kTurnUdpExtAddr
.
ipaddr
(
)
turnport
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
EXPECT_EQ
(
kNatAddr1
.
ipaddr
(
)
turnport
-
>
Candidates
(
)
[
0
]
.
related_address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
PortTest
TestCandidatePriority
)
{
webrtc
:
:
Candidate
cand1
;
cand1
.
set_priority
(
3
)
;
webrtc
:
:
Candidate
cand2
;
cand2
.
set_priority
(
1
)
;
EXPECT_TRUE
(
cand1
.
priority
(
)
>
cand2
.
priority
(
)
)
;
}
TEST_F
(
PortTest
TestConnectionPriority
)
{
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
lport
-
>
set_type_preference
(
cricket
:
:
ICE_TYPE_PREFERENCE_HOST
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
rport
-
>
set_type_preference
(
cricket
:
:
ICE_TYPE_PREFERENCE_RELAY_UDP
)
;
lport
-
>
set_component
(
123
)
;
lport
-
>
AddCandidateAddress
(
SocketAddress
(
"
192
.
168
.
1
.
4
"
1234
)
)
;
rport
-
>
set_component
(
23
)
;
rport
-
>
AddCandidateAddress
(
SocketAddress
(
"
10
.
1
.
1
.
100
"
1234
)
)
;
EXPECT_EQ
(
0x7E001E85U
lport
-
>
Candidates
(
)
[
0
]
.
priority
(
)
)
;
EXPECT_EQ
(
0x2001EE9U
rport
-
>
Candidates
(
)
[
0
]
.
priority
(
)
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
#
if
defined
(
WEBRTC_WIN
)
EXPECT_EQ
(
0x2001EE9FC003D0BU
lconn
-
>
priority
(
)
)
;
#
else
EXPECT_EQ
(
0x2001EE9FC003D0BLLU
lconn
-
>
priority
(
)
)
;
#
endif
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
#
if
defined
(
WEBRTC_WIN
)
EXPECT_EQ
(
0x2001EE9FC003D0AU
rconn
-
>
priority
(
)
)
;
#
else
EXPECT_EQ
(
0x2001EE9FC003D0ALLU
rconn
-
>
priority
(
)
)
;
#
endif
}
TEST_F
(
PortTest
TestConnectionPriorityWithPriorityAdjustment
)
{
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials
(
"
WebRTC
-
IncreaseIceCandidatePriorityHostSrflx
/
Enabled
/
"
)
;
auto
lport
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
&
field_trials
)
;
lport
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
lport
-
>
set_type_preference
(
cricket
:
:
ICE_TYPE_PREFERENCE_HOST
)
;
auto
rport
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
&
field_trials
)
;
rport
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
rport
-
>
set_type_preference
(
cricket
:
:
ICE_TYPE_PREFERENCE_RELAY_UDP
)
;
lport
-
>
set_component
(
123
)
;
lport
-
>
AddCandidateAddress
(
SocketAddress
(
"
192
.
168
.
1
.
4
"
1234
)
)
;
rport
-
>
set_component
(
23
)
;
rport
-
>
AddCandidateAddress
(
SocketAddress
(
"
10
.
1
.
1
.
100
"
1234
)
)
;
EXPECT_EQ
(
0x7E001E85U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
lport
-
>
Candidates
(
)
[
0
]
.
priority
(
)
)
;
EXPECT_EQ
(
0x2001EE9U
+
(
webrtc
:
:
kMaxTurnServers
<
<
8
)
rport
-
>
Candidates
(
)
[
0
]
.
priority
(
)
)
;
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
Connection
*
lconn
=
lport
-
>
CreateConnection
(
rport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
#
if
defined
(
WEBRTC_WIN
)
EXPECT_EQ
(
0x2003EE9FC007D0BU
lconn
-
>
priority
(
)
)
;
#
else
EXPECT_EQ
(
0x2003EE9FC007D0BLLU
lconn
-
>
priority
(
)
)
;
#
endif
lport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
rport
-
>
CreateConnection
(
lport
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
RCONN
"
<
<
rconn
-
>
priority
(
)
;
#
if
defined
(
WEBRTC_WIN
)
EXPECT_EQ
(
0x2003EE9FC007D0AU
rconn
-
>
priority
(
)
)
;
#
else
EXPECT_EQ
(
0x2003EE9FC007D0ALLU
rconn
-
>
priority
(
)
)
;
#
endif
}
TEST_F
(
PortTest
TestWritableState
)
{
webrtc
:
:
ScopedFakeClock
clock
;
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
connected
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
Ping
(
)
;
SIMULATED_WAIT
(
!
ch2
.
remote_address
(
)
.
IsNil
(
)
kShortTimeout
clock
)
;
char
data
[
]
=
"
abcd
"
;
int
data_size
=
arraysize
(
data
)
;
rtc
:
:
PacketOptions
options
;
EXPECT_EQ
(
data_size
ch1
.
conn
(
)
-
>
Send
(
data
data_size
options
)
)
;
ch2
.
AcceptConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
data_size
ch1
.
conn
(
)
-
>
Send
(
data
data_size
options
)
)
;
for
(
uint32_t
i
=
1
;
i
<
=
CONNECTION_WRITE_CONNECT_FAILURES
;
+
+
i
)
{
ch1
.
Ping
(
i
)
;
}
int
unreliable_timeout_delay
=
CONNECTION_WRITE_CONNECT_TIMEOUT
+
kMaxExpectedSimulatedRtt
;
ch1
.
conn
(
)
-
>
UpdateState
(
unreliable_timeout_delay
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_UNRELIABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
EXPECT_EQ
(
data_size
ch1
.
conn
(
)
-
>
Send
(
data
data_size
options
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
=
CONNECTION_WRITE_CONNECT_FAILURES
;
+
+
i
)
{
ch1
.
Ping
(
unreliable_timeout_delay
+
i
)
;
}
ch1
.
conn
(
)
-
>
UpdateState
(
unreliable_timeout_delay
+
CONNECTION_WRITE_TIMEOUT
+
kMaxExpectedSimulatedRtt
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_TIMEOUT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
EXPECT_EQ
(
data_size
ch1
.
conn
(
)
-
>
Send
(
data
data_size
options
)
)
;
ch1
.
Stop
(
)
;
ch2
.
Stop
(
)
;
}
TEST_F
(
PortTest
TestWritableStateWithConfiguredThreshold
)
{
webrtc
:
:
ScopedFakeClock
clock
;
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch2
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
ch1
.
Ping
(
)
;
SIMULATED_WAIT
(
!
ch2
.
remote_address
(
)
.
IsNil
(
)
kShortTimeout
clock
)
;
ch2
.
AcceptConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch1
.
conn
(
)
-
>
set_unwritable_timeout
(
1000
)
;
ch1
.
conn
(
)
-
>
set_unwritable_min_checks
(
3
)
;
ch1
.
Ping
(
1
)
;
ch1
.
Ping
(
2
)
;
ch1
.
conn
(
)
-
>
UpdateState
(
999
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
UpdateState
(
1000
+
kMaxExpectedSimulatedRtt
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
Ping
(
3
)
;
ch1
.
conn
(
)
-
>
UpdateState
(
999
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
UpdateState
(
1000
+
kMaxExpectedSimulatedRtt
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_UNRELIABLE
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
Stop
(
)
;
ch2
.
Stop
(
)
;
}
TEST_F
(
PortTest
TestTimeoutForNeverWritable
)
{
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
ch1
.
Start
(
)
;
ch2
.
Start
(
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
=
CONNECTION_WRITE_CONNECT_FAILURES
;
+
+
i
)
{
ch1
.
Ping
(
i
)
;
}
ch1
.
conn
(
)
-
>
UpdateState
(
CONNECTION_WRITE_TIMEOUT
+
kMaxExpectedSimulatedRtt
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_TIMEOUT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
}
TEST_F
(
PortTest
TestIceLiteConnectivity
)
{
auto
ice_full_port
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
auto
*
ice_full_port_ptr
=
ice_full_port
.
get
(
)
;
auto
ice_lite_port
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
ice_full_port
)
)
;
ch1
.
SetIceMode
(
ICEMODE_FULL
)
;
ch1
.
Start
(
)
;
ice_lite_port
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_FALSE
(
ice_lite_port
-
>
Candidates
(
)
.
empty
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ice_lite_port
.
get
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ice_full_port_ptr
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
*
msg
=
ice_full_port_ptr
-
>
last_stun_msg
(
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USE_CANDIDATE
)
=
=
NULL
)
;
auto
*
con
=
ice_lite_port
-
>
CreateConnection
(
ice_full_port_ptr
-
>
Candidates
(
)
[
0
]
cricket
:
:
Port
:
:
ORIGIN_MESSAGE
)
;
std
:
:
unique_ptr
<
IceMessage
>
request
=
CopyStunMessage
(
*
msg
)
;
con
-
>
SendStunBindingResponse
(
request
.
get
(
)
)
;
ch1
.
conn
(
)
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
ice_lite_port
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
conn
(
)
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
nominated
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ice_full_port_ptr
-
>
Reset
(
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ice_full_port_ptr
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
msg
=
ice_full_port_ptr
-
>
last_stun_msg
(
)
;
EXPECT_TRUE
(
msg
-
>
GetByteString
(
STUN_ATTR_USE_CANDIDATE
)
!
=
NULL
)
;
ch1
.
Stop
(
)
;
}
namespace
{
std
:
:
optional
<
int
>
GetSupportedGoogPingVersion
(
const
StunMessage
*
msg
)
{
auto
goog_misc
=
msg
-
>
GetUInt16List
(
STUN_ATTR_GOOG_MISC_INFO
)
;
if
(
goog_misc
=
=
nullptr
)
{
return
std
:
:
nullopt
;
}
if
(
msg
-
>
type
(
)
=
=
STUN_BINDING_REQUEST
)
{
if
(
goog_misc
-
>
Size
(
)
<
static_cast
<
int
>
(
cricket
:
:
IceGoogMiscInfoBindingRequestAttributeIndex
:
:
SUPPORT_GOOG_PING_VERSION
)
)
{
return
std
:
:
nullopt
;
}
return
goog_misc
-
>
GetType
(
static_cast
<
int
>
(
cricket
:
:
IceGoogMiscInfoBindingRequestAttributeIndex
:
:
SUPPORT_GOOG_PING_VERSION
)
)
;
}
if
(
msg
-
>
type
(
)
=
=
STUN_BINDING_RESPONSE
)
{
if
(
goog_misc
-
>
Size
(
)
<
static_cast
<
int
>
(
cricket
:
:
IceGoogMiscInfoBindingResponseAttributeIndex
:
:
SUPPORT_GOOG_PING_VERSION
)
)
{
return
std
:
:
nullopt
;
}
return
goog_misc
-
>
GetType
(
static_cast
<
int
>
(
cricket
:
:
IceGoogMiscInfoBindingResponseAttributeIndex
:
:
SUPPORT_GOOG_PING_VERSION
)
)
;
}
return
std
:
:
nullopt
;
}
}
class
GoogPingTest
:
public
PortTest
public
:
:
testing
:
:
WithParamInterface
<
std
:
:
pair
<
bool
bool
>
>
{
}
;
TEST_P
(
GoogPingTest
TestGoogPingAnnounceEnable
)
{
IceFieldTrials
trials
;
trials
.
announce_goog_ping
=
GetParam
(
)
.
first
;
trials
.
enable_goog_ping
=
GetParam
(
)
.
second
;
RTC_LOG
(
LS_INFO
)
<
<
"
Testing
combination
:
"
"
announce
:
"
<
<
trials
.
announce_goog_ping
<
<
"
enable
:
"
<
<
trials
.
enable_goog_ping
;
auto
port1_unique
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
auto
*
port1
=
port1_unique
.
get
(
)
;
auto
port2
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1_unique
)
)
;
ch1
.
SetIceMode
(
ICEMODE_LITE
)
;
ch1
.
Start
(
)
;
port2
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_FALSE
(
port2
-
>
Candidates
(
)
.
empty
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
port2
.
get
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
SetIceFieldTrials
(
&
trials
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
request1
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
trials
.
enable_goog_ping
GetSupportedGoogPingVersion
(
request1
)
&
&
GetSupportedGoogPingVersion
(
request1
)
>
=
kGoogPingVersion
)
;
auto
*
con
=
port2
-
>
CreateConnection
(
port1
-
>
Candidates
(
)
[
0
]
cricket
:
:
Port
:
:
ORIGIN_MESSAGE
)
;
con
-
>
SetIceFieldTrials
(
&
trials
)
;
con
-
>
SendStunBindingResponse
(
request1
)
;
const
auto
*
response
=
port2
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
response
-
>
type
(
)
STUN_BINDING_RESPONSE
)
;
EXPECT_EQ
(
trials
.
enable_goog_ping
&
&
trials
.
announce_goog_ping
GetSupportedGoogPingVersion
(
response
)
&
&
GetSupportedGoogPingVersion
(
response
)
>
=
kGoogPingVersion
)
;
ch1
.
conn
(
)
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
port2
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
port1
-
>
Reset
(
)
;
port2
-
>
Reset
(
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
request2
=
port1
-
>
last_stun_msg
(
)
;
if
(
trials
.
announce_goog_ping
&
&
trials
.
enable_goog_ping
)
{
ASSERT_EQ
(
request2
-
>
type
(
)
GOOG_PING_REQUEST
)
;
con
-
>
SendGoogPingResponse
(
request2
)
;
}
else
{
ASSERT_EQ
(
request2
-
>
type
(
)
STUN_BINDING_REQUEST
)
;
ASSERT_FALSE
(
GetSupportedGoogPingVersion
(
request2
)
.
has_value
(
)
)
;
con
-
>
SendStunBindingResponse
(
request2
)
;
}
const
auto
*
response2
=
port2
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
response2
!
=
nullptr
)
;
if
(
trials
.
announce_goog_ping
&
&
trials
.
enable_goog_ping
)
{
ASSERT_EQ
(
response2
-
>
type
(
)
GOOG_PING_RESPONSE
)
;
}
else
{
ASSERT_EQ
(
response2
-
>
type
(
)
STUN_BINDING_RESPONSE
)
;
}
ch1
.
Stop
(
)
;
}
TEST_F
(
PortTest
TestGoogPingUnsupportedVersionInStunBinding
)
{
IceFieldTrials
trials
;
trials
.
announce_goog_ping
=
true
;
trials
.
enable_goog_ping
=
true
;
auto
port1_unique
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
auto
*
port1
=
port1_unique
.
get
(
)
;
auto
port2
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1_unique
)
)
;
ch1
.
SetIceMode
(
ICEMODE_LITE
)
;
ch1
.
Start
(
)
;
port2
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_FALSE
(
port2
-
>
Candidates
(
)
.
empty
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
port2
.
get
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
SetIceFieldTrials
(
&
trials
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
request1
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
GetSupportedGoogPingVersion
(
request1
)
&
&
GetSupportedGoogPingVersion
(
request1
)
>
=
kGoogPingVersion
)
;
auto
modified_request1
=
request1
-
>
Clone
(
)
;
ASSERT_TRUE
(
modified_request1
-
>
RemoveAttribute
(
STUN_ATTR_GOOG_MISC_INFO
)
!
=
nullptr
)
;
ASSERT_TRUE
(
modified_request1
-
>
RemoveAttribute
(
STUN_ATTR_MESSAGE_INTEGRITY
)
!
=
nullptr
)
;
{
auto
list
=
StunAttribute
:
:
CreateUInt16ListAttribute
(
STUN_ATTR_GOOG_MISC_INFO
)
;
list
-
>
AddTypeAtIndex
(
static_cast
<
uint16_t
>
(
cricket
:
:
IceGoogMiscInfoBindingRequestAttributeIndex
:
:
SUPPORT_GOOG_PING_VERSION
)
0
)
;
modified_request1
-
>
AddAttribute
(
std
:
:
move
(
list
)
)
;
modified_request1
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
}
auto
*
con
=
port2
-
>
CreateConnection
(
port1
-
>
Candidates
(
)
[
0
]
cricket
:
:
Port
:
:
ORIGIN_MESSAGE
)
;
con
-
>
SetIceFieldTrials
(
&
trials
)
;
con
-
>
SendStunBindingResponse
(
modified_request1
.
get
(
)
)
;
const
auto
*
response
=
port2
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
response
-
>
type
(
)
STUN_BINDING_RESPONSE
)
;
EXPECT_FALSE
(
GetSupportedGoogPingVersion
(
response
)
)
;
ch1
.
Stop
(
)
;
}
TEST_F
(
PortTest
TestGoogPingUnsupportedVersionInStunBindingResponse
)
{
IceFieldTrials
trials
;
trials
.
announce_goog_ping
=
true
;
trials
.
enable_goog_ping
=
true
;
auto
port1_unique
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
auto
*
port1
=
port1_unique
.
get
(
)
;
auto
port2
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1_unique
)
)
;
ch1
.
SetIceMode
(
ICEMODE_LITE
)
;
ch1
.
Start
(
)
;
port2
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_FALSE
(
port2
-
>
Candidates
(
)
.
empty
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
port2
.
get
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
SetIceFieldTrials
(
&
trials
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
request1
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
GetSupportedGoogPingVersion
(
request1
)
&
&
GetSupportedGoogPingVersion
(
request1
)
>
=
kGoogPingVersion
)
;
auto
*
con
=
port2
-
>
CreateConnection
(
port1
-
>
Candidates
(
)
[
0
]
cricket
:
:
Port
:
:
ORIGIN_MESSAGE
)
;
con
-
>
SetIceFieldTrials
(
&
trials
)
;
con
-
>
SendStunBindingResponse
(
request1
)
;
const
auto
*
response
=
port2
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
response
-
>
type
(
)
STUN_BINDING_RESPONSE
)
;
EXPECT_TRUE
(
GetSupportedGoogPingVersion
(
response
)
)
;
auto
modified_response
=
response
-
>
Clone
(
)
;
ASSERT_TRUE
(
modified_response
-
>
RemoveAttribute
(
STUN_ATTR_GOOG_MISC_INFO
)
!
=
nullptr
)
;
ASSERT_TRUE
(
modified_response
-
>
RemoveAttribute
(
STUN_ATTR_MESSAGE_INTEGRITY
)
!
=
nullptr
)
;
ASSERT_TRUE
(
modified_response
-
>
RemoveAttribute
(
STUN_ATTR_FINGERPRINT
)
!
=
nullptr
)
;
{
auto
list
=
StunAttribute
:
:
CreateUInt16ListAttribute
(
STUN_ATTR_GOOG_MISC_INFO
)
;
list
-
>
AddTypeAtIndex
(
static_cast
<
uint16_t
>
(
cricket
:
:
IceGoogMiscInfoBindingResponseAttributeIndex
:
:
SUPPORT_GOOG_PING_VERSION
)
0
)
;
modified_response
-
>
AddAttribute
(
std
:
:
move
(
list
)
)
;
modified_response
-
>
AddMessageIntegrity
(
"
rpass
"
)
;
modified_response
-
>
AddFingerprint
(
)
;
}
rtc
:
:
ByteBufferWriter
buf
;
modified_response
-
>
Write
(
&
buf
)
;
ch1
.
conn
(
)
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
buf
.
Data
(
)
buf
.
Length
(
)
-
1
)
)
;
port1
-
>
Reset
(
)
;
port2
-
>
Reset
(
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
request2
=
port1
-
>
last_stun_msg
(
)
;
EXPECT_EQ
(
request2
-
>
type
(
)
STUN_BINDING_REQUEST
)
;
EXPECT_FALSE
(
GetSupportedGoogPingVersion
(
request2
)
)
;
ch1
.
Stop
(
)
;
}
INSTANTIATE_TEST_SUITE_P
(
GoogPingTest
GoogPingTest
:
:
testing
:
:
Values
(
std
:
:
make_pair
(
false
false
)
std
:
:
make_pair
(
true
false
)
std
:
:
make_pair
(
false
true
)
std
:
:
make_pair
(
true
true
)
)
)
;
TEST_F
(
PortTest
TestChangeInAttributeMakesGoogPingFallsbackToStunBinding
)
{
IceFieldTrials
trials
;
trials
.
announce_goog_ping
=
true
;
trials
.
enable_goog_ping
=
true
;
auto
port1_unique
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
auto
*
port1
=
port1_unique
.
get
(
)
;
auto
port2
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1_unique
)
)
;
ch1
.
SetIceMode
(
ICEMODE_LITE
)
;
ch1
.
Start
(
)
;
port2
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_FALSE
(
port2
-
>
Candidates
(
)
.
empty
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
port2
.
get
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
nullptr
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
SetIceFieldTrials
(
&
trials
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
msg
=
port1
-
>
last_stun_msg
(
)
;
auto
*
con
=
port2
-
>
CreateConnection
(
port1
-
>
Candidates
(
)
[
0
]
cricket
:
:
Port
:
:
ORIGIN_MESSAGE
)
;
con
-
>
SetIceFieldTrials
(
&
trials
)
;
con
-
>
SendStunBindingResponse
(
msg
)
;
const
auto
*
response
=
port2
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
response
-
>
type
(
)
STUN_BINDING_RESPONSE
)
;
ASSERT_TRUE
(
GetSupportedGoogPingVersion
(
response
)
>
=
kGoogPingVersion
)
;
ch1
.
conn
(
)
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
port2
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
port1
-
>
Reset
(
)
;
port2
-
>
Reset
(
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
msg2
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
msg2
-
>
type
(
)
GOOG_PING_REQUEST
)
;
con
-
>
SendGoogPingResponse
(
msg2
)
;
const
auto
*
response2
=
port2
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
response2
!
=
nullptr
)
;
ASSERT_EQ
(
response2
-
>
type
(
)
GOOG_PING_RESPONSE
)
;
port1
-
>
Reset
(
)
;
port2
-
>
Reset
(
)
;
ch1
.
conn
(
)
-
>
set_use_candidate_attr
(
!
ch1
.
conn
(
)
-
>
use_candidate_attr
(
)
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
msg3
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
msg3
-
>
type
(
)
STUN_BINDING_REQUEST
)
;
ch1
.
Stop
(
)
;
}
TEST_F
(
PortTest
TestErrorResponseMakesGoogPingFallBackToStunBinding
)
{
IceFieldTrials
trials
;
trials
.
announce_goog_ping
=
true
;
trials
.
enable_goog_ping
=
true
;
auto
port1_unique
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
cricket
:
:
ICEROLE_CONTROLLING
kTiebreaker1
)
;
auto
*
port1
=
port1_unique
.
get
(
)
;
auto
port2
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
cricket
:
:
ICEROLE_CONTROLLED
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1_unique
)
)
;
ch1
.
SetIceMode
(
ICEMODE_LITE
)
;
ch1
.
Start
(
)
;
port2
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch1
.
complete_count
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_FALSE
(
port2
-
>
Candidates
(
)
.
empty
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
port2
.
get
(
)
)
)
;
ASSERT_TRUE
(
ch1
.
conn
(
)
!
=
NULL
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
ch1
.
conn
(
)
-
>
write_state
(
)
)
;
ch1
.
conn
(
)
-
>
SetIceFieldTrials
(
&
trials
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
msg
=
port1
-
>
last_stun_msg
(
)
;
auto
*
con
=
port2
-
>
CreateConnection
(
port1
-
>
Candidates
(
)
[
0
]
cricket
:
:
Port
:
:
ORIGIN_MESSAGE
)
;
con
-
>
SetIceFieldTrials
(
&
trials
)
;
con
-
>
SendStunBindingResponse
(
msg
)
;
const
auto
*
response
=
port2
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
response
-
>
type
(
)
STUN_BINDING_RESPONSE
)
;
ASSERT_TRUE
(
GetSupportedGoogPingVersion
(
response
)
>
=
kGoogPingVersion
)
;
ch1
.
conn
(
)
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
port2
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
port1
-
>
Reset
(
)
;
port2
-
>
Reset
(
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
msg2
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
msg2
-
>
type
(
)
GOOG_PING_REQUEST
)
;
con
-
>
SendGoogPingResponse
(
msg2
)
;
const
auto
*
response2
=
port2
-
>
last_stun_msg
(
)
;
ASSERT_TRUE
(
response2
!
=
nullptr
)
;
ASSERT_EQ
(
response2
-
>
type
(
)
GOOG_PING_RESPONSE
)
;
StunMessage
error_response
(
GOOG_PING_ERROR_RESPONSE
)
;
error_response
.
SetTransactionIdForTesting
(
response2
-
>
transaction_id
(
)
)
;
error_response
.
AddMessageIntegrity32
(
"
rpass
"
)
;
rtc
:
:
ByteBufferWriter
buf
;
error_response
.
Write
(
&
buf
)
;
ch1
.
conn
(
)
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
buf
.
Data
(
)
buf
.
Length
(
)
-
1
)
)
;
port1
-
>
Reset
(
)
;
port2
-
>
Reset
(
)
;
ch1
.
Ping
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
port1
-
>
last_stun_msg
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
IceMessage
*
msg3
=
port1
-
>
last_stun_msg
(
)
;
ASSERT_EQ
(
msg3
-
>
type
(
)
STUN_BINDING_REQUEST
)
;
ch1
.
Stop
(
)
;
}
TEST_F
(
PortTest
TestPortTimeoutIfNotKeptAlive
)
{
webrtc
:
:
ScopedFakeClock
clock
;
int
timeout_delay
=
100
;
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
ConnectToSignalDestroyed
(
port1
.
get
(
)
)
;
port1
-
>
set_timeout_delay
(
timeout_delay
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
port1
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
ConnectToSignalDestroyed
(
port2
.
get
(
)
)
;
port2
-
>
set_timeout_delay
(
timeout_delay
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
port2
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
StartConnectAndStopChannels
(
&
ch1
&
ch2
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ports_destroyed
(
)
;
}
Eq
(
2
)
{
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestPortTimeoutAfterNewConnectionCreatedAndDestroyed
)
{
webrtc
:
:
ScopedFakeClock
clock
;
int
timeout_delay
=
100
;
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
ConnectToSignalDestroyed
(
port1
.
get
(
)
)
;
port1
-
>
set_timeout_delay
(
timeout_delay
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
port1
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
ConnectToSignalDestroyed
(
port2
.
get
(
)
)
;
port2
-
>
set_timeout_delay
(
timeout_delay
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
port2
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
StartConnectAndStopChannels
(
&
ch1
&
ch2
)
;
SIMULATED_WAIT
(
ports_destroyed
(
)
>
0
80
clock
)
;
EXPECT_EQ
(
0
ports_destroyed
(
)
)
;
ch1
.
CreateConnection
(
GetCandidate
(
ch2
.
port
(
)
)
)
;
ch2
.
CreateConnection
(
GetCandidate
(
ch1
.
port
(
)
)
)
;
ch1
.
Stop
(
)
;
ch2
.
Stop
(
)
;
SIMULATED_WAIT
(
ports_destroyed
(
)
>
0
80
clock
)
;
EXPECT_EQ
(
0
ports_destroyed
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ports_destroyed
(
)
;
}
Eq
(
2
)
{
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestPortNotTimeoutUntilPruned
)
{
webrtc
:
:
ScopedFakeClock
clock
;
int
timeout_delay
=
100
;
auto
port1
=
CreateUdpPort
(
kLocalAddr1
)
;
ConnectToSignalDestroyed
(
port1
.
get
(
)
)
;
port1
-
>
set_timeout_delay
(
timeout_delay
)
;
port1
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
port1
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
auto
port2
=
CreateUdpPort
(
kLocalAddr2
)
;
ConnectToSignalDestroyed
(
port2
.
get
(
)
)
;
port2
-
>
set_timeout_delay
(
timeout_delay
)
;
port2
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
port2
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
EXPECT_EQ
(
0
ports_destroyed
(
)
)
;
port1
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
port2
-
>
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
TestChannel
ch1
(
std
:
:
move
(
port1
)
)
;
TestChannel
ch2
(
std
:
:
move
(
port2
)
)
;
StartConnectAndStopChannels
(
&
ch1
&
ch2
)
;
ch1
.
port
(
)
-
>
KeepAliveUntilPruned
(
)
;
ch2
.
port
(
)
-
>
KeepAliveUntilPruned
(
)
;
SIMULATED_WAIT
(
ports_destroyed
(
)
>
0
150
clock
)
;
EXPECT_EQ
(
0
ports_destroyed
(
)
)
;
ch1
.
port
(
)
-
>
Prune
(
)
;
ch2
.
port
(
)
-
>
Prune
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ports_destroyed
(
)
;
}
Eq
(
2
)
{
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
PortTest
TestSupportsProtocol
)
{
auto
udp_port
=
CreateUdpPort
(
kLocalAddr1
)
;
EXPECT_TRUE
(
udp_port
-
>
SupportsProtocol
(
UDP_PROTOCOL_NAME
)
)
;
EXPECT_FALSE
(
udp_port
-
>
SupportsProtocol
(
TCP_PROTOCOL_NAME
)
)
;
auto
stun_port
=
CreateStunPort
(
kLocalAddr1
nat_socket_factory1
(
)
)
;
EXPECT_TRUE
(
stun_port
-
>
SupportsProtocol
(
UDP_PROTOCOL_NAME
)
)
;
EXPECT_FALSE
(
stun_port
-
>
SupportsProtocol
(
TCP_PROTOCOL_NAME
)
)
;
auto
tcp_port
=
CreateTcpPort
(
kLocalAddr1
)
;
EXPECT_TRUE
(
tcp_port
-
>
SupportsProtocol
(
TCP_PROTOCOL_NAME
)
)
;
EXPECT_TRUE
(
tcp_port
-
>
SupportsProtocol
(
SSLTCP_PROTOCOL_NAME
)
)
;
EXPECT_FALSE
(
tcp_port
-
>
SupportsProtocol
(
UDP_PROTOCOL_NAME
)
)
;
auto
turn_port
=
CreateTurnPort
(
kLocalAddr1
nat_socket_factory1
(
)
webrtc
:
:
PROTO_UDP
webrtc
:
:
PROTO_UDP
)
;
EXPECT_TRUE
(
turn_port
-
>
SupportsProtocol
(
UDP_PROTOCOL_NAME
)
)
;
EXPECT_FALSE
(
turn_port
-
>
SupportsProtocol
(
TCP_PROTOCOL_NAME
)
)
;
}
TEST_F
(
PortTest
TestSetIceParameters
)
{
auto
port
=
CreateTestPort
(
kLocalAddr1
"
ufrag1
"
"
password1
"
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
port
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
1UL
port
-
>
Candidates
(
)
.
size
(
)
)
;
port
-
>
SetIceParameters
(
1
"
ufrag2
"
"
password2
"
)
;
EXPECT_EQ
(
1
port
-
>
component
(
)
)
;
EXPECT_EQ
(
"
ufrag2
"
port
-
>
username_fragment
(
)
)
;
EXPECT_EQ
(
"
password2
"
port
-
>
password
(
)
)
;
const
webrtc
:
:
Candidate
&
candidate
=
port
-
>
Candidates
(
)
[
0
]
;
EXPECT_EQ
(
1
candidate
.
component
(
)
)
;
EXPECT_EQ
(
"
ufrag2
"
candidate
.
username
(
)
)
;
EXPECT_EQ
(
"
password2
"
candidate
.
password
(
)
)
;
}
TEST_F
(
PortTest
TestAddConnectionWithSameAddress
)
{
auto
port
=
CreateTestPort
(
kLocalAddr1
"
ufrag1
"
"
password1
"
)
;
port
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
port
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
1u
port
-
>
Candidates
(
)
.
size
(
)
)
;
webrtc
:
:
SocketAddress
address
(
"
1
.
1
.
1
.
1
"
5000
)
;
webrtc
:
:
Candidate
candidate
(
1
"
udp
"
address
0
"
"
"
"
IceCandidateType
:
:
kRelay
0
"
"
)
;
cricket
:
:
Connection
*
conn1
=
port
-
>
CreateConnection
(
candidate
Port
:
:
ORIGIN_MESSAGE
)
;
cricket
:
:
Connection
*
conn_in_use
=
port
-
>
GetConnection
(
address
)
;
EXPECT_EQ
(
conn1
conn_in_use
)
;
EXPECT_EQ
(
0u
conn_in_use
-
>
remote_candidate
(
)
.
generation
(
)
)
;
candidate
.
set_generation
(
2
)
;
cricket
:
:
Connection
*
conn2
=
port
-
>
CreateConnection
(
candidate
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_NE
(
conn1
conn2
)
;
conn_in_use
=
port
-
>
GetConnection
(
address
)
;
EXPECT_EQ
(
conn2
conn_in_use
)
;
EXPECT_EQ
(
2u
conn_in_use
-
>
remote_candidate
(
)
.
generation
(
)
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
300
)
;
EXPECT_TRUE
(
port
-
>
GetConnection
(
address
)
!
=
nullptr
)
;
}
class
ConnectionTest
:
public
PortTest
{
public
:
ConnectionTest
(
)
{
lport_
=
CreateTestPort
(
kLocalAddr1
"
lfrag
"
"
lpass
"
)
;
rport_
=
CreateTestPort
(
kLocalAddr2
"
rfrag
"
"
rpass
"
)
;
lport_
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLING
)
;
lport_
-
>
SetIceTiebreaker
(
kTiebreaker1
)
;
rport_
-
>
SetIceRole
(
cricket
:
:
ICEROLE_CONTROLLED
)
;
rport_
-
>
SetIceTiebreaker
(
kTiebreaker2
)
;
lport_
-
>
PrepareAddress
(
)
;
rport_
-
>
PrepareAddress
(
)
;
}
webrtc
:
:
ScopedFakeClock
clock_
;
int
num_state_changes_
=
0
;
Connection
*
CreateConnection
(
IceRole
role
)
{
Connection
*
conn
;
if
(
role
=
=
cricket
:
:
ICEROLE_CONTROLLING
)
{
conn
=
lport_
-
>
CreateConnection
(
rport_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
}
else
{
conn
=
rport_
-
>
CreateConnection
(
lport_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
}
conn
-
>
SignalStateChange
.
connect
(
this
&
ConnectionTest
:
:
OnConnectionStateChange
)
;
return
conn
;
}
void
SendPingAndCaptureReply
(
Connection
*
lconn
Connection
*
rconn
int64_t
ms
rtc
:
:
BufferT
<
uint8_t
>
*
reply
)
{
TestPort
*
lport
=
lconn
-
>
PortForTest
(
)
=
=
lport_
.
get
(
)
?
lport_
.
get
(
)
:
rport_
.
get
(
)
;
TestPort
*
rport
=
rconn
-
>
PortForTest
(
)
=
=
rport_
.
get
(
)
?
rport_
.
get
(
)
:
lport_
.
get
(
)
;
lconn
-
>
Ping
(
rtc
:
:
TimeMillis
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
lport
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
ms
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
rport
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
reply
-
>
SetData
(
rport
-
>
last_stun_buf
(
)
)
;
}
void
SendPingAndReceiveResponse
(
Connection
*
lconn
Connection
*
rconn
int64_t
ms
)
{
rtc
:
:
BufferT
<
uint8_t
>
reply
;
SendPingAndCaptureReply
(
lconn
rconn
ms
&
reply
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
reply
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
}
void
OnConnectionStateChange
(
Connection
*
connection
)
{
num_state_changes_
+
+
;
}
std
:
:
unique_ptr
<
TestPort
>
lport_
;
std
:
:
unique_ptr
<
TestPort
>
rport_
;
}
;
TEST_F
(
ConnectionTest
ConnectionForgetLearnedState
)
{
Connection
*
lconn
=
CreateConnection
(
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
CreateConnection
(
ICEROLE_CONTROLLED
)
;
EXPECT_FALSE
(
lconn
-
>
writable
(
)
)
;
EXPECT_FALSE
(
lconn
-
>
receiving
(
)
)
;
EXPECT_TRUE
(
std
:
:
isnan
(
lconn
-
>
GetRttEstimate
(
)
.
GetAverage
(
)
)
)
;
EXPECT_EQ
(
lconn
-
>
GetRttEstimate
(
)
.
GetVariance
(
)
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
;
SendPingAndReceiveResponse
(
lconn
rconn
10
)
;
EXPECT_TRUE
(
lconn
-
>
writable
(
)
)
;
EXPECT_TRUE
(
lconn
-
>
receiving
(
)
)
;
EXPECT_EQ
(
lconn
-
>
GetRttEstimate
(
)
.
GetAverage
(
)
10
)
;
EXPECT_EQ
(
lconn
-
>
GetRttEstimate
(
)
.
GetVariance
(
)
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
;
SendPingAndReceiveResponse
(
lconn
rconn
11
)
;
EXPECT_TRUE
(
lconn
-
>
writable
(
)
)
;
EXPECT_TRUE
(
lconn
-
>
receiving
(
)
)
;
EXPECT_NEAR
(
lconn
-
>
GetRttEstimate
(
)
.
GetAverage
(
)
10
0
.
5
)
;
EXPECT_LT
(
lconn
-
>
GetRttEstimate
(
)
.
GetVariance
(
)
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
;
lconn
-
>
ForgetLearnedState
(
)
;
EXPECT_FALSE
(
lconn
-
>
writable
(
)
)
;
EXPECT_FALSE
(
lconn
-
>
receiving
(
)
)
;
EXPECT_TRUE
(
std
:
:
isnan
(
lconn
-
>
GetRttEstimate
(
)
.
GetAverage
(
)
)
)
;
EXPECT_EQ
(
lconn
-
>
GetRttEstimate
(
)
.
GetVariance
(
)
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
;
}
TEST_F
(
ConnectionTest
ConnectionForgetLearnedStateDiscardsPendingPings
)
{
Connection
*
lconn
=
CreateConnection
(
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
CreateConnection
(
ICEROLE_CONTROLLED
)
;
SendPingAndReceiveResponse
(
lconn
rconn
10
)
;
EXPECT_TRUE
(
lconn
-
>
writable
(
)
)
;
EXPECT_TRUE
(
lconn
-
>
receiving
(
)
)
;
rtc
:
:
BufferT
<
uint8_t
>
reply
;
SendPingAndCaptureReply
(
lconn
rconn
10
&
reply
)
;
lconn
-
>
ForgetLearnedState
(
)
;
EXPECT_FALSE
(
lconn
-
>
writable
(
)
)
;
EXPECT_FALSE
(
lconn
-
>
receiving
(
)
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
reply
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_FALSE
(
lconn
-
>
writable
(
)
)
;
EXPECT_FALSE
(
lconn
-
>
receiving
(
)
)
;
SendPingAndReceiveResponse
(
lconn
rconn
11
)
;
EXPECT_TRUE
(
lconn
-
>
writable
(
)
)
;
EXPECT_TRUE
(
lconn
-
>
receiving
(
)
)
;
}
TEST_F
(
ConnectionTest
ConnectionForgetLearnedStateDoesNotTriggerStateChange
)
{
Connection
*
lconn
=
CreateConnection
(
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
CreateConnection
(
ICEROLE_CONTROLLED
)
;
EXPECT_EQ
(
num_state_changes_
0
)
;
SendPingAndReceiveResponse
(
lconn
rconn
10
)
;
EXPECT_TRUE
(
lconn
-
>
writable
(
)
)
;
EXPECT_TRUE
(
lconn
-
>
receiving
(
)
)
;
EXPECT_EQ
(
num_state_changes_
2
)
;
lconn
-
>
ForgetLearnedState
(
)
;
EXPECT_FALSE
(
lconn
-
>
writable
(
)
)
;
EXPECT_FALSE
(
lconn
-
>
receiving
(
)
)
;
EXPECT_EQ
(
num_state_changes_
2
)
;
}
TEST_F
(
ConnectionTest
SendReceiveGoogDelta
)
{
constexpr
int64_t
ms
=
10
;
Connection
*
lconn
=
CreateConnection
(
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
CreateConnection
(
ICEROLE_CONTROLLED
)
;
std
:
:
unique_ptr
<
StunByteStringAttribute
>
delta
=
absl
:
:
WrapUnique
(
new
StunByteStringAttribute
(
STUN_ATTR_GOOG_DELTA
)
)
;
delta
-
>
CopyBytes
(
"
DELTA
"
)
;
std
:
:
unique_ptr
<
StunAttribute
>
delta_ack
=
absl
:
:
WrapUnique
(
new
StunUInt64Attribute
(
STUN_ATTR_GOOG_DELTA_ACK
133
)
)
;
bool
received_goog_delta
=
false
;
bool
received_goog_delta_ack
=
false
;
lconn
-
>
SetStunDictConsumer
(
[
]
(
const
StunByteStringAttribute
*
delta
)
-
>
std
:
:
unique_ptr
<
StunAttribute
>
{
return
nullptr
;
}
[
&
]
(
webrtc
:
:
RTCErrorOr
<
const
StunUInt64Attribute
*
>
error_or_ack
)
{
received_goog_delta_ack
=
true
;
EXPECT_TRUE
(
error_or_ack
.
ok
(
)
)
;
EXPECT_EQ
(
error_or_ack
.
value
(
)
-
>
value
(
)
133ull
)
;
}
)
;
rconn
-
>
SetStunDictConsumer
(
[
&
]
(
const
StunByteStringAttribute
*
delta
)
-
>
std
:
:
unique_ptr
<
StunAttribute
>
{
received_goog_delta
=
true
;
EXPECT_EQ
(
delta
-
>
string_view
(
)
"
DELTA
"
)
;
return
std
:
:
move
(
delta_ack
)
;
}
[
]
(
webrtc
:
:
RTCErrorOr
<
const
StunUInt64Attribute
*
>
error_or__ack
)
{
}
)
;
lconn
-
>
Ping
(
rtc
:
:
TimeMillis
(
)
std
:
:
move
(
delta
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport_
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
lport_
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport_
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_TRUE
(
received_goog_delta
)
;
clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
ms
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport_
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
rport_
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport_
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_TRUE
(
received_goog_delta_ack
)
;
}
TEST_F
(
ConnectionTest
SendGoogDeltaNoReply
)
{
constexpr
int64_t
ms
=
10
;
Connection
*
lconn
=
CreateConnection
(
ICEROLE_CONTROLLING
)
;
Connection
*
rconn
=
CreateConnection
(
ICEROLE_CONTROLLED
)
;
std
:
:
unique_ptr
<
StunByteStringAttribute
>
delta
=
absl
:
:
WrapUnique
(
new
StunByteStringAttribute
(
STUN_ATTR_GOOG_DELTA
)
)
;
delta
-
>
CopyBytes
(
"
DELTA
"
)
;
bool
received_goog_delta_ack_error
=
false
;
lconn
-
>
SetStunDictConsumer
(
[
]
(
const
StunByteStringAttribute
*
delta
)
-
>
std
:
:
unique_ptr
<
StunAttribute
>
{
return
nullptr
;
}
[
&
]
(
webrtc
:
:
RTCErrorOr
<
const
StunUInt64Attribute
*
>
error_or_ack
)
{
received_goog_delta_ack_error
=
true
;
EXPECT_FALSE
(
error_or_ack
.
ok
(
)
)
;
}
)
;
lconn
-
>
Ping
(
rtc
:
:
TimeMillis
(
)
std
:
:
move
(
delta
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
lport_
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
lport_
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
rconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
lport_
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
ms
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
rport_
-
>
last_stun_msg
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
rport_
-
>
last_stun_buf
(
)
.
size
(
)
0u
)
;
lconn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
(
rport_
-
>
last_stun_buf
(
)
webrtc
:
:
SocketAddress
(
)
std
:
:
nullopt
)
)
;
EXPECT_TRUE
(
received_goog_delta_ack_error
)
;
}
}
