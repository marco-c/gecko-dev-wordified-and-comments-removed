#
include
"
p2p
/
base
/
p2p_transport_channel
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
async_dns_resolver
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
field_trials
.
h
"
#
include
"
api
/
ice_transport_interface
.
h
"
#
include
"
api
/
packet_socket_factory
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
api
/
test
/
mock_async_dns_resolver
.
h
"
#
include
"
api
/
test
/
rtc_error_matchers
.
h
"
#
include
"
api
/
transport
/
enums
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
p2p
/
base
/
basic_ice_controller
.
h
"
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
#
include
"
p2p
/
base
/
candidate_pair_interface
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
connection_info
.
h
"
#
include
"
p2p
/
base
/
ice_controller_factory_interface
.
h
"
#
include
"
p2p
/
base
/
ice_controller_interface
.
h
"
#
include
"
p2p
/
base
/
ice_switch_reason
.
h
"
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
p2p
/
base
/
port
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
p2p
/
base
/
stun_dictionary
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
client
/
basic_port_allocator
.
h
"
#
include
"
p2p
/
dtls
/
dtls_stun_piggyback_callbacks
.
h
"
#
include
"
p2p
/
test
/
fake_port_allocator
.
h
"
#
include
"
p2p
/
test
/
mock_active_ice_controller
.
h
"
#
include
"
p2p
/
test
/
mock_ice_controller
.
h
"
#
include
"
p2p
/
test
/
nat_socket_factory
.
h
"
#
include
"
p2p
/
test
/
nat_types
.
h
"
#
include
"
p2p
/
test
/
stun_server
.
h
"
#
include
"
p2p
/
test
/
test_stun_server
.
h
"
#
include
"
p2p
/
test
/
test_turn_server
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
fake_mdns_responder
.
h
"
#
include
"
rtc_base
/
fake_network
.
h
"
#
include
"
rtc_base
/
firewall_socket_server
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
internal
/
default_socket_server
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
mdns_responder_interface
.
h
"
#
include
"
rtc_base
/
net_helper
.
h
"
#
include
"
rtc_base
/
net_helpers
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
network_constants
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
socket_server
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
wait_until
.
h
"
namespace
{
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
Assign
;
using
:
:
testing
:
:
Contains
;
using
:
:
testing
:
:
DoAll
;
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
Gt
;
using
:
:
testing
:
:
IsFalse
;
using
:
:
testing
:
:
IsTrue
;
using
:
:
testing
:
:
MockFunction
;
using
:
:
testing
:
:
Ne
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
ReturnRef
;
using
:
:
testing
:
:
SetArgPointee
;
using
:
:
testing
:
:
SizeIs
;
using
:
:
testing
:
:
Values
;
using
:
:
testing
:
:
WithParamInterface
;
using
:
:
webrtc
:
:
CreateEnvironment
;
using
:
:
webrtc
:
:
Environment
;
using
:
:
webrtc
:
:
FieldTrials
;
using
:
:
webrtc
:
:
IceCandidateType
;
using
:
:
webrtc
:
:
PendingTaskSafetyFlag
;
using
:
:
webrtc
:
:
SafeTask
;
using
:
:
webrtc
:
:
SocketAddress
;
static
const
int
kDefaultTimeout
=
10000
;
static
const
int
kMediumTimeout
=
3000
;
static
const
int
kShortTimeout
=
1000
;
static
const
int
kOnlyLocalPorts
=
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_RELAY
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
;
static
const
int
LOW_RTT
=
20
;
static
const
SocketAddress
kPublicAddrs
[
2
]
=
{
SocketAddress
(
"
11
.
11
.
11
.
11
"
0
)
SocketAddress
(
"
22
.
22
.
22
.
22
"
0
)
}
;
static
const
SocketAddress
kIPv6PublicAddrs
[
2
]
=
{
SocketAddress
(
"
2400
:
4030
:
1
:
2c00
:
be30
:
abcd
:
efab
:
cdef
"
0
)
SocketAddress
(
"
2600
:
0
:
1000
:
1b03
:
2e41
:
38ff
:
fea6
:
f2a4
"
0
)
}
;
static
const
SocketAddress
kAlternateAddrs
[
2
]
=
{
SocketAddress
(
"
101
.
101
.
101
.
101
"
0
)
SocketAddress
(
"
202
.
202
.
202
.
202
"
0
)
}
;
static
const
SocketAddress
kIPv6AlternateAddrs
[
2
]
=
{
SocketAddress
(
"
2401
:
4030
:
1
:
2c00
:
be30
:
abcd
:
efab
:
cdef
"
0
)
SocketAddress
(
"
2601
:
0
:
1000
:
1b03
:
2e41
:
38ff
:
fea6
:
f2a4
"
0
)
}
;
static
const
SocketAddress
kNatAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
1
.
1
"
0
)
SocketAddress
(
"
192
.
168
.
2
.
1
"
0
)
}
;
static
const
SocketAddress
kPrivateAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
1
.
11
"
0
)
SocketAddress
(
"
192
.
168
.
2
.
22
"
0
)
}
;
static
const
SocketAddress
kCascadedNatAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
10
.
1
"
0
)
SocketAddress
(
"
192
.
168
.
20
.
1
"
0
)
}
;
static
const
SocketAddress
kCascadedPrivateAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
10
.
11
"
0
)
SocketAddress
(
"
192
.
168
.
20
.
22
"
0
)
}
;
static
const
SocketAddress
kStunAddr
(
"
99
.
99
.
99
.
1
"
webrtc
:
:
STUN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnUdpIntAddr
(
"
99
.
99
.
99
.
3
"
webrtc
:
:
STUN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnTcpIntAddr
(
"
99
.
99
.
99
.
4
"
webrtc
:
:
STUN_SERVER_PORT
+
1
)
;
static
const
SocketAddress
kTurnUdpExtAddr
(
"
99
.
99
.
99
.
5
"
0
)
;
static
const
webrtc
:
:
RelayCredentials
kRelayCredentials
(
"
test
"
"
test
"
)
;
const
char
*
kIceUfrag
[
4
]
=
{
"
UF00
"
"
UF01
"
"
UF02
"
"
UF03
"
}
;
const
char
*
kIcePwd
[
4
]
=
{
"
TESTICEPWD00000000000000
"
"
TESTICEPWD00000000000001
"
"
TESTICEPWD00000000000002
"
"
TESTICEPWD00000000000003
"
}
;
const
cricket
:
:
IceParameters
kIceParams
[
4
]
=
{
{
kIceUfrag
[
0
]
kIcePwd
[
0
]
false
}
{
kIceUfrag
[
1
]
kIcePwd
[
1
]
false
}
{
kIceUfrag
[
2
]
kIcePwd
[
2
]
false
}
{
kIceUfrag
[
3
]
kIcePwd
[
3
]
false
}
}
;
webrtc
:
:
IceConfig
CreateIceConfig
(
int
receiving_timeout
webrtc
:
:
ContinualGatheringPolicy
continual_gathering_policy
std
:
:
optional
<
int
>
backup_ping_interval
=
std
:
:
nullopt
)
{
webrtc
:
:
IceConfig
config
;
config
.
receiving_timeout
=
receiving_timeout
;
config
.
continual_gathering_policy
=
continual_gathering_policy
;
config
.
backup_connection_ping_interval
=
backup_ping_interval
;
return
config
;
}
webrtc
:
:
Candidate
CreateUdpCandidate
(
IceCandidateType
type
absl
:
:
string_view
ip
int
port
int
priority
absl
:
:
string_view
ufrag
=
"
"
)
{
webrtc
:
:
Candidate
c
;
c
.
set_address
(
webrtc
:
:
SocketAddress
(
ip
port
)
)
;
c
.
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
c
.
set_protocol
(
webrtc
:
:
UDP_PROTOCOL_NAME
)
;
c
.
set_priority
(
priority
)
;
c
.
set_username
(
ufrag
)
;
c
.
set_type
(
type
)
;
return
c
;
}
std
:
:
unique_ptr
<
cricket
:
:
BasicPortAllocator
>
CreateBasicPortAllocator
(
const
Environment
&
env
webrtc
:
:
NetworkManager
*
network_manager
webrtc
:
:
PacketSocketFactory
*
socket_factory
const
cricket
:
:
ServerAddresses
&
stun_servers
const
webrtc
:
:
SocketAddress
&
turn_server_udp
const
webrtc
:
:
SocketAddress
&
turn_server_tcp
)
{
webrtc
:
:
RelayServerConfig
turn_server
;
turn_server
.
credentials
=
kRelayCredentials
;
if
(
!
turn_server_udp
.
IsNil
(
)
)
{
turn_server
.
ports
.
push_back
(
cricket
:
:
ProtocolAddress
(
turn_server_udp
webrtc
:
:
PROTO_UDP
)
)
;
}
if
(
!
turn_server_tcp
.
IsNil
(
)
)
{
turn_server
.
ports
.
push_back
(
cricket
:
:
ProtocolAddress
(
turn_server_tcp
webrtc
:
:
PROTO_TCP
)
)
;
}
std
:
:
vector
<
webrtc
:
:
RelayServerConfig
>
turn_servers
(
1
turn_server
)
;
auto
allocator
=
std
:
:
make_unique
<
cricket
:
:
BasicPortAllocator
>
(
env
network_manager
socket_factory
)
;
allocator
-
>
Initialize
(
)
;
allocator
-
>
SetConfiguration
(
stun_servers
turn_servers
0
webrtc
:
:
NO_PRUNE
)
;
return
allocator
;
}
class
ResolverFactoryFixture
:
public
webrtc
:
:
MockAsyncDnsResolverFactory
{
public
:
ResolverFactoryFixture
(
)
{
mock_async_dns_resolver_
=
std
:
:
make_unique
<
webrtc
:
:
MockAsyncDnsResolver
>
(
)
;
EXPECT_CALL
(
*
mock_async_dns_resolver_
Start
(
_
_
)
)
.
WillRepeatedly
(
[
]
(
const
webrtc
:
:
SocketAddress
&
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
{
callback
(
)
;
}
)
;
EXPECT_CALL
(
*
mock_async_dns_resolver_
result
(
)
)
.
WillOnce
(
ReturnRef
(
mock_async_dns_resolver_result_
)
)
;
EXPECT_CALL
(
mock_async_dns_resolver_result_
GetResolvedAddress
(
_
_
)
)
.
WillRepeatedly
(
Return
(
true
)
)
;
EXPECT_CALL
(
mock_async_dns_resolver_result_
GetError
(
)
)
.
WillOnce
(
Return
(
0
)
)
;
EXPECT_CALL
(
*
this
Create
(
)
)
.
WillOnce
(
[
this
]
(
)
{
return
std
:
:
move
(
mock_async_dns_resolver_
)
;
}
)
;
}
void
SetAddressToReturn
(
webrtc
:
:
SocketAddress
address_to_return
)
{
EXPECT_CALL
(
mock_async_dns_resolver_result_
GetResolvedAddress
(
_
_
)
)
.
WillOnce
(
DoAll
(
SetArgPointee
<
1
>
(
address_to_return
)
Return
(
true
)
)
)
;
}
void
DelayResolution
(
)
{
ASSERT_TRUE
(
!
!
mock_async_dns_resolver_
)
;
EXPECT_CALL
(
*
mock_async_dns_resolver_
Start
(
_
_
)
)
.
WillOnce
(
[
this
]
(
const
rtc
:
:
SocketAddress
&
addr
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
{
saved_callback_
=
std
:
:
move
(
callback
)
;
}
)
;
}
void
FireDelayedResolution
(
)
{
ASSERT_TRUE
(
saved_callback_
)
;
saved_callback_
(
)
;
}
private
:
std
:
:
unique_ptr
<
webrtc
:
:
MockAsyncDnsResolver
>
mock_async_dns_resolver_
;
webrtc
:
:
MockAsyncDnsResolverResult
mock_async_dns_resolver_result_
;
absl
:
:
AnyInvocable
<
void
(
)
>
saved_callback_
;
}
;
bool
HasLocalAddress
(
const
cricket
:
:
CandidatePairInterface
*
pair
const
SocketAddress
&
address
)
{
return
pair
-
>
local_candidate
(
)
.
address
(
)
.
EqualIPs
(
address
)
;
}
bool
HasRemoteAddress
(
const
cricket
:
:
CandidatePairInterface
*
pair
const
SocketAddress
&
address
)
{
return
pair
-
>
remote_candidate
(
)
.
address
(
)
.
EqualIPs
(
address
)
;
}
}
namespace
cricket
{
using
:
:
testing
:
:
NotNull
;
class
P2PTransportChannelTestBase
:
public
:
:
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
P2PTransportChannelTestBase
(
)
:
vss_
(
new
webrtc
:
:
VirtualSocketServer
(
)
)
nss_
(
new
webrtc
:
:
NATSocketServer
(
vss_
.
get
(
)
)
)
ss_
(
new
webrtc
:
:
FirewallSocketServer
(
nss_
.
get
(
)
)
)
socket_factory_
(
new
webrtc
:
:
BasicPacketSocketFactory
(
ss_
.
get
(
)
)
)
main_
(
ss_
.
get
(
)
)
stun_server_
(
webrtc
:
:
TestStunServer
:
:
Create
(
ss_
.
get
(
)
kStunAddr
main_
)
)
turn_server_
(
&
main_
ss_
.
get
(
)
kTurnUdpIntAddr
kTurnUdpExtAddr
)
force_relay_
(
false
)
{
ep1_
.
role_
=
ICEROLE_CONTROLLING
;
ep2_
.
role_
=
ICEROLE_CONTROLLED
;
webrtc
:
:
metrics
:
:
Reset
(
)
;
}
void
CreatePortAllocators
(
const
Environment
&
env
)
{
ServerAddresses
stun_servers
=
{
kStunAddr
}
;
ep1_
.
allocator_
=
CreateBasicPortAllocator
(
env
&
ep1_
.
network_manager_
socket_factory_
.
get
(
)
stun_servers
kTurnUdpIntAddr
webrtc
:
:
SocketAddress
(
)
)
;
ep2_
.
allocator_
=
CreateBasicPortAllocator
(
env
&
ep2_
.
network_manager_
socket_factory_
.
get
(
)
stun_servers
kTurnUdpIntAddr
webrtc
:
:
SocketAddress
(
)
)
;
}
protected
:
enum
Config
{
OPEN
NAT_FULL_CONE
NAT_ADDR_RESTRICTED
NAT_PORT_RESTRICTED
NAT_SYMMETRIC
NAT_DOUBLE_CONE
NAT_SYMMETRIC_THEN_CONE
BLOCK_UDP
BLOCK_UDP_AND_INCOMING_TCP
BLOCK_ALL_BUT_OUTGOING_HTTP
NUM_CONFIGS
}
;
struct
Result
{
Result
(
IceCandidateType
controlling_type
absl
:
:
string_view
controlling_protocol
IceCandidateType
controlled_type
absl
:
:
string_view
controlled_protocol
int
wait
)
:
controlling_type
(
controlling_type
)
controlling_protocol
(
controlling_protocol
)
controlled_type
(
controlled_type
)
controlled_protocol
(
controlled_protocol
)
connect_wait
(
wait
)
{
}
IceCandidateType
controlling_type
;
std
:
:
string
controlling_protocol
;
IceCandidateType
controlled_type
;
std
:
:
string
controlled_protocol
;
int
connect_wait
;
}
;
struct
ChannelData
{
bool
CheckData
(
const
char
*
data
int
len
)
{
bool
ret
=
false
;
if
(
!
ch_packets_
.
empty
(
)
)
{
std
:
:
string
packet
=
ch_packets_
.
front
(
)
;
ret
=
(
packet
=
=
std
:
:
string
(
data
len
)
)
;
ch_packets_
.
pop_front
(
)
;
}
return
ret
;
}
std
:
:
string
name_
;
std
:
:
list
<
std
:
:
string
>
ch_packets_
;
std
:
:
unique_ptr
<
P2PTransportChannel
>
ch_
;
}
;
struct
CandidateData
{
webrtc
:
:
IceTransportInternal
*
channel
;
webrtc
:
:
Candidate
candidate
;
}
;
struct
Endpoint
:
public
sigslot
:
:
has_slots
<
>
{
Endpoint
(
)
:
role_
(
ICEROLE_UNKNOWN
)
tiebreaker_
(
0
)
role_conflict_
(
false
)
save_candidates_
(
false
)
{
}
bool
HasTransport
(
const
webrtc
:
:
PacketTransportInternal
*
transport
)
{
return
(
transport
=
=
cd1_
.
ch_
.
get
(
)
|
|
transport
=
=
cd2_
.
ch_
.
get
(
)
)
;
}
ChannelData
*
GetChannelData
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
if
(
!
HasTransport
(
transport
)
)
return
NULL
;
if
(
cd1_
.
ch_
.
get
(
)
=
=
transport
)
return
&
cd1_
;
else
return
&
cd2_
;
}
void
SetIceRole
(
IceRole
role
)
{
role_
=
role
;
}
IceRole
ice_role
(
)
{
return
role_
;
}
void
OnRoleConflict
(
bool
role_conflict
)
{
role_conflict_
=
role_conflict
;
}
bool
role_conflict
(
)
{
return
role_conflict_
;
}
void
SetAllocationStepDelay
(
uint32_t
delay
)
{
allocator_
-
>
set_step_delay
(
delay
)
;
}
void
SetAllowTcpListen
(
bool
allow_tcp_listen
)
{
allocator_
-
>
set_allow_tcp_listen
(
allow_tcp_listen
)
;
}
void
OnIceRegathering
(
webrtc
:
:
PortAllocatorSession
*
webrtc
:
:
IceRegatheringReason
reason
)
{
+
+
ice_regathering_counter_
[
reason
]
;
}
int
GetIceRegatheringCountForReason
(
webrtc
:
:
IceRegatheringReason
reason
)
{
return
ice_regathering_counter_
[
reason
]
;
}
webrtc
:
:
FakeNetworkManager
network_manager_
;
std
:
:
unique_ptr
<
BasicPortAllocator
>
allocator_
;
webrtc
:
:
AsyncDnsResolverFactoryInterface
*
async_dns_resolver_factory_
=
nullptr
;
ChannelData
cd1_
;
ChannelData
cd2_
;
IceRole
role_
;
uint64_t
tiebreaker_
;
bool
role_conflict_
;
bool
save_candidates_
;
std
:
:
vector
<
CandidateData
>
saved_candidates_
;
bool
ready_to_send_
=
false
;
std
:
:
map
<
webrtc
:
:
IceRegatheringReason
int
>
ice_regathering_counter_
;
}
;
ChannelData
*
GetChannelData
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
if
(
ep1_
.
HasTransport
(
transport
)
)
return
ep1_
.
GetChannelData
(
transport
)
;
else
return
ep2_
.
GetChannelData
(
transport
)
;
}
IceParameters
IceParamsWithRenomination
(
const
IceParameters
&
ice
bool
renomination
)
{
IceParameters
new_ice
=
ice
;
new_ice
.
renomination
=
renomination
;
return
new_ice
;
}
void
CreateChannels
(
const
Environment
&
env
const
webrtc
:
:
IceConfig
&
ep1_config
const
webrtc
:
:
IceConfig
&
ep2_config
bool
renomination
=
false
)
{
IceParameters
ice_ep1_cd1_ch
=
IceParamsWithRenomination
(
kIceParams
[
0
]
renomination
)
;
IceParameters
ice_ep2_cd1_ch
=
IceParamsWithRenomination
(
kIceParams
[
1
]
renomination
)
;
ep1_
.
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
ice_ep1_cd1_ch
ice_ep2_cd1_ch
)
;
ep2_
.
cd1_
.
ch_
=
CreateChannel
(
env
1
ICE_CANDIDATE_COMPONENT_DEFAULT
ice_ep2_cd1_ch
ice_ep1_cd1_ch
)
;
ep1_
.
cd1_
.
ch_
-
>
SetIceConfig
(
ep1_config
)
;
ep2_
.
cd1_
.
ch_
-
>
SetIceConfig
(
ep2_config
)
;
ep1_
.
cd1_
.
ch_
-
>
MaybeStartGathering
(
)
;
ep2_
.
cd1_
.
ch_
-
>
MaybeStartGathering
(
)
;
ep1_
.
cd1_
.
ch_
-
>
allocator_session
(
)
-
>
SignalIceRegathering
.
connect
(
&
ep1_
&
Endpoint
:
:
OnIceRegathering
)
;
ep2_
.
cd1_
.
ch_
-
>
allocator_session
(
)
-
>
SignalIceRegathering
.
connect
(
&
ep2_
&
Endpoint
:
:
OnIceRegathering
)
;
}
void
CreateChannels
(
const
Environment
&
env
)
{
webrtc
:
:
IceConfig
default_config
;
CreateChannels
(
env
default_config
default_config
false
)
;
}
std
:
:
unique_ptr
<
P2PTransportChannel
>
CreateChannel
(
const
Environment
&
env
int
endpoint
int
component
const
IceParameters
&
local_ice
const
IceParameters
&
remote_ice
)
{
webrtc
:
:
IceTransportInit
init
;
init
.
set_port_allocator
(
GetAllocator
(
endpoint
)
)
;
init
.
set_async_dns_resolver_factory
(
GetEndpoint
(
endpoint
)
-
>
async_dns_resolver_factory_
)
;
init
.
set_field_trials
(
&
env
.
field_trials
(
)
)
;
auto
channel
=
P2PTransportChannel
:
:
Create
(
"
test
content
name
"
component
std
:
:
move
(
init
)
)
;
channel
-
>
SignalReadyToSend
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnReadyToSend
)
;
channel
-
>
SignalCandidateGathered
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnCandidateGathered
)
;
channel
-
>
SetCandidatesRemovedCallback
(
[
this
]
(
IceTransportInternal
*
transport
const
Candidates
&
candidates
)
{
OnCandidatesRemoved
(
transport
candidates
)
;
}
)
;
channel
-
>
RegisterReceivedPacketCallback
(
this
[
&
]
(
rtc
:
:
PacketTransportInternal
*
transport
const
rtc
:
:
ReceivedPacket
&
packet
)
{
OnReadPacket
(
transport
packet
)
;
}
)
;
channel
-
>
SignalRoleConflict
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnRoleConflict
)
;
channel
-
>
SignalNetworkRouteChanged
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnNetworkRouteChanged
)
;
channel
-
>
SignalSentPacket
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnSentPacket
)
;
channel
-
>
SetIceParameters
(
local_ice
)
;
if
(
remote_ice_parameter_source_
=
=
FROM_SETICEPARAMETERS
)
{
channel
-
>
SetRemoteIceParameters
(
remote_ice
)
;
}
channel
-
>
SetIceRole
(
GetEndpoint
(
endpoint
)
-
>
ice_role
(
)
)
;
return
channel
;
}
void
DestroyChannels
(
)
{
safety_
-
>
SetNotAlive
(
)
;
ep1_
.
cd1_
.
ch_
.
reset
(
)
;
ep2_
.
cd1_
.
ch_
.
reset
(
)
;
ep1_
.
cd2_
.
ch_
.
reset
(
)
;
ep2_
.
cd2_
.
ch_
.
reset
(
)
;
webrtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
0
)
;
}
P2PTransportChannel
*
ep1_ch1
(
)
{
return
ep1_
.
cd1_
.
ch_
.
get
(
)
;
}
P2PTransportChannel
*
ep1_ch2
(
)
{
return
ep1_
.
cd2_
.
ch_
.
get
(
)
;
}
P2PTransportChannel
*
ep2_ch1
(
)
{
return
ep2_
.
cd1_
.
ch_
.
get
(
)
;
}
P2PTransportChannel
*
ep2_ch2
(
)
{
return
ep2_
.
cd2_
.
ch_
.
get
(
)
;
}
webrtc
:
:
TestTurnServer
*
test_turn_server
(
)
{
return
&
turn_server_
;
}
webrtc
:
:
VirtualSocketServer
*
virtual_socket_server
(
)
{
return
vss_
.
get
(
)
;
}
static
const
Result
kLocalUdpToLocalUdp
;
static
const
Result
kLocalUdpToStunUdp
;
static
const
Result
kLocalUdpToPrflxUdp
;
static
const
Result
kPrflxUdpToLocalUdp
;
static
const
Result
kStunUdpToLocalUdp
;
static
const
Result
kStunUdpToStunUdp
;
static
const
Result
kStunUdpToPrflxUdp
;
static
const
Result
kPrflxUdpToStunUdp
;
static
const
Result
kLocalUdpToRelayUdp
;
static
const
Result
kPrflxUdpToRelayUdp
;
static
const
Result
kRelayUdpToPrflxUdp
;
static
const
Result
kLocalTcpToLocalTcp
;
static
const
Result
kLocalTcpToPrflxTcp
;
static
const
Result
kPrflxTcpToLocalTcp
;
webrtc
:
:
NATSocketServer
*
nat
(
)
{
return
nss_
.
get
(
)
;
}
webrtc
:
:
FirewallSocketServer
*
fw
(
)
{
return
ss_
.
get
(
)
;
}
Endpoint
*
GetEndpoint
(
int
endpoint
)
{
if
(
endpoint
=
=
0
)
{
return
&
ep1_
;
}
else
if
(
endpoint
=
=
1
)
{
return
&
ep2_
;
}
else
{
return
NULL
;
}
}
BasicPortAllocator
*
GetAllocator
(
int
endpoint
)
{
return
GetEndpoint
(
endpoint
)
-
>
allocator_
.
get
(
)
;
}
void
AddAddress
(
int
endpoint
const
SocketAddress
&
addr
)
{
GetEndpoint
(
endpoint
)
-
>
network_manager_
.
AddInterface
(
addr
)
;
}
void
AddAddress
(
int
endpoint
const
SocketAddress
&
addr
absl
:
:
string_view
ifname
rtc
:
:
AdapterType
adapter_type
std
:
:
optional
<
rtc
:
:
AdapterType
>
underlying_vpn_adapter_type
=
std
:
:
nullopt
)
{
GetEndpoint
(
endpoint
)
-
>
network_manager_
.
AddInterface
(
addr
ifname
adapter_type
underlying_vpn_adapter_type
)
;
}
void
RemoveAddress
(
int
endpoint
const
SocketAddress
&
addr
)
{
GetEndpoint
(
endpoint
)
-
>
network_manager_
.
RemoveInterface
(
addr
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
addr
)
;
}
void
SetAllocatorFlags
(
int
endpoint
int
flags
)
{
GetAllocator
(
endpoint
)
-
>
set_flags
(
flags
)
;
}
void
SetIceRole
(
int
endpoint
IceRole
role
)
{
GetEndpoint
(
endpoint
)
-
>
SetIceRole
(
role
)
;
}
bool
GetRoleConflict
(
int
endpoint
)
{
return
GetEndpoint
(
endpoint
)
-
>
role_conflict
(
)
;
}
void
SetAllocationStepDelay
(
int
endpoint
uint32_t
delay
)
{
return
GetEndpoint
(
endpoint
)
-
>
SetAllocationStepDelay
(
delay
)
;
}
void
SetAllowTcpListen
(
int
endpoint
bool
allow_tcp_listen
)
{
return
GetEndpoint
(
endpoint
)
-
>
SetAllowTcpListen
(
allow_tcp_listen
)
;
}
bool
CheckCandidate1
(
const
Result
&
expected
)
{
auto
local_type
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
auto
remote_type
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
return
(
local_protocol
=
=
expected
.
controlling_protocol
&
&
remote_protocol
=
=
expected
.
controlled_protocol
&
&
local_type
=
=
expected
.
controlling_type
&
&
remote_type
=
=
expected
.
controlled_type
)
;
}
void
ExpectCandidate1
(
const
Result
&
expected
)
{
if
(
CheckCandidate1
(
expected
)
)
{
return
;
}
auto
local_type
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
auto
remote_type
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
EXPECT_EQ
(
expected
.
controlling_type
local_type
)
;
EXPECT_EQ
(
expected
.
controlled_type
remote_type
)
;
EXPECT_EQ
(
expected
.
controlling_protocol
local_protocol
)
;
EXPECT_EQ
(
expected
.
controlled_protocol
remote_protocol
)
;
}
bool
CheckCandidate2
(
const
Result
&
expected
)
{
auto
local_type
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
auto
remote_type
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
return
(
local_protocol
=
=
expected
.
controlled_protocol
&
&
remote_protocol
=
=
expected
.
controlling_protocol
&
&
local_type
=
=
expected
.
controlled_type
&
&
remote_type
=
=
expected
.
controlling_type
)
;
}
void
ExpectCandidate2
(
const
Result
&
expected
)
{
if
(
CheckCandidate2
(
expected
)
)
{
return
;
}
auto
local_type
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
auto
remote_type
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
EXPECT_EQ
(
expected
.
controlled_type
local_type
)
;
EXPECT_EQ
(
expected
.
controlling_type
remote_type
)
;
EXPECT_EQ
(
expected
.
controlled_protocol
local_protocol
)
;
EXPECT_EQ
(
expected
.
controlling_protocol
remote_protocol
)
;
}
static
bool
CheckCandidate
(
P2PTransportChannel
*
channel
SocketAddress
from
SocketAddress
to
)
{
auto
local_candidate
=
LocalCandidate
(
channel
)
;
auto
remote_candidate
=
RemoteCandidate
(
channel
)
;
return
local_candidate
!
=
nullptr
&
&
local_candidate
-
>
address
(
)
.
EqualIPs
(
from
)
&
&
remote_candidate
!
=
nullptr
&
&
remote_candidate
-
>
address
(
)
.
EqualIPs
(
to
)
;
}
static
bool
CheckCandidatePair
(
P2PTransportChannel
*
ch1
P2PTransportChannel
*
ch2
SocketAddress
from
SocketAddress
to
)
{
return
CheckCandidate
(
ch1
from
to
)
&
&
CheckCandidate
(
ch2
to
from
)
;
}
static
bool
CheckConnected
(
P2PTransportChannel
*
ch1
P2PTransportChannel
*
ch2
)
{
return
ch1
!
=
nullptr
&
&
ch1
-
>
receiving
(
)
&
&
ch1
-
>
writable
(
)
&
&
ch2
!
=
nullptr
&
&
ch2
-
>
receiving
(
)
&
&
ch2
-
>
writable
(
)
;
}
static
bool
CheckCandidatePairAndConnected
(
P2PTransportChannel
*
ch1
P2PTransportChannel
*
ch2
SocketAddress
from
SocketAddress
to
)
{
return
CheckConnected
(
ch1
ch2
)
&
&
CheckCandidatePair
(
ch1
ch2
from
to
)
;
}
void
Test
(
const
Environment
&
env
const
Result
&
expected
)
{
webrtc
:
:
ScopedFakeClock
clock
;
int64_t
connect_start
=
webrtc
:
:
TimeMillis
(
)
;
int64_t
connect_time
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
expected
.
connect_wait
+
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
connect_time
=
webrtc
:
:
TimeMillis
(
)
-
connect_start
;
if
(
connect_time
<
expected
.
connect_wait
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Connect
time
:
"
<
<
connect_time
<
<
"
ms
"
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
Connect
time
:
TIMEOUT
(
"
<
<
expected
.
connect_wait
<
<
"
ms
)
"
;
}
if
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
{
int64_t
converge_start
=
webrtc
:
:
TimeMillis
(
)
;
int64_t
converge_time
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidate1
(
expected
)
&
&
CheckCandidate2
(
expected
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ExpectCandidate1
(
expected
)
;
ExpectCandidate2
(
expected
)
;
converge_time
=
webrtc
:
:
TimeMillis
(
)
-
converge_start
;
int64_t
converge_wait
=
2000
;
if
(
converge_time
<
converge_wait
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Converge
time
:
"
<
<
converge_time
<
<
"
ms
"
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
Converge
time
:
TIMEOUT
(
"
<
<
converge_time
<
<
"
ms
)
"
;
}
}
TestSendRecv
(
&
clock
)
;
DestroyChannels
(
)
;
}
void
TestSendRecv
(
webrtc
:
:
ThreadProcessingFakeClock
*
clock
)
{
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
const
char
*
data
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
SendData
(
ep1_ch1
(
)
data
len
)
;
}
Eq
(
len
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
*
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckDataOnChannel
(
ep2_ch1
(
)
data
len
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
*
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
SendData
(
ep2_ch1
(
)
data
len
)
;
}
Eq
(
len
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
*
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckDataOnChannel
(
ep1_ch1
(
)
data
len
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
*
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
}
void
TestHandleIceUfragPasswordChanged
(
)
{
webrtc
:
:
ScopedFakeClock
clock
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
webrtc
:
:
Candidate
*
old_local_candidate1
=
LocalCandidate
(
ep1_ch1
(
)
)
;
const
webrtc
:
:
Candidate
*
old_local_candidate2
=
LocalCandidate
(
ep2_ch1
(
)
)
;
const
webrtc
:
:
Candidate
*
old_remote_candidate1
=
RemoteCandidate
(
ep1_ch1
(
)
)
;
const
webrtc
:
:
Candidate
*
old_remote_candidate2
=
RemoteCandidate
(
ep2_ch1
(
)
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
LocalCandidate
(
ep1_ch1
(
)
)
-
>
generation
(
)
;
}
Ne
(
old_local_candidate1
-
>
generation
(
)
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
LocalCandidate
(
ep2_ch1
(
)
)
-
>
generation
(
)
;
}
Ne
(
old_local_candidate2
-
>
generation
(
)
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
generation
(
)
;
}
Ne
(
old_remote_candidate1
-
>
generation
(
)
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
generation
(
)
;
}
Ne
(
old_remote_candidate2
-
>
generation
(
)
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
1u
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
generation
(
)
)
;
EXPECT_EQ
(
1u
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
generation
(
)
)
;
}
void
TestPacketInfoIsSet
(
webrtc
:
:
PacketInfo
info
)
{
EXPECT_NE
(
info
.
packet_type
webrtc
:
:
PacketType
:
:
kUnknown
)
;
EXPECT_NE
(
info
.
protocol
webrtc
:
:
PacketInfoProtocolType
:
:
kUnknown
)
;
EXPECT_TRUE
(
info
.
network_id
.
has_value
(
)
)
;
}
void
OnReadyToSend
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
GetEndpoint
(
transport
)
-
>
ready_to_send_
=
true
;
}
void
OnCandidateGathered
(
webrtc
:
:
IceTransportInternal
*
ch
const
webrtc
:
:
Candidate
&
c
)
{
if
(
force_relay_
&
&
!
c
.
is_relay
(
)
)
return
;
if
(
GetEndpoint
(
ch
)
-
>
save_candidates_
)
{
GetEndpoint
(
ch
)
-
>
saved_candidates_
.
push_back
(
{
.
channel
=
ch
.
candidate
=
c
}
)
;
}
else
{
main_
.
PostTask
(
SafeTask
(
safety_
[
this
ch
c
=
c
]
(
)
mutable
{
AddCandidate
(
ch
c
)
;
}
)
)
;
}
}
void
OnNetworkRouteChanged
(
std
:
:
optional
<
rtc
:
:
NetworkRoute
>
network_route
)
{
if
(
network_route
)
{
+
+
selected_candidate_pair_switches_
;
}
}
int
reset_selected_candidate_pair_switches
(
)
{
int
switches
=
selected_candidate_pair_switches_
;
selected_candidate_pair_switches_
=
0
;
return
switches
;
}
void
PauseCandidates
(
int
endpoint
)
{
GetEndpoint
(
endpoint
)
-
>
save_candidates_
=
true
;
}
void
OnCandidatesRemoved
(
webrtc
:
:
IceTransportInternal
*
ch
const
std
:
:
vector
<
webrtc
:
:
Candidate
>
&
candidates
)
{
main_
.
PostTask
(
SafeTask
(
safety_
[
this
ch
candidates
]
(
)
mutable
{
P2PTransportChannel
*
rch
=
GetRemoteChannel
(
ch
)
;
if
(
rch
=
=
nullptr
)
{
return
;
}
for
(
const
Candidate
&
c
:
candidates
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Removed
remote
candidate
"
<
<
c
.
ToString
(
)
;
rch
-
>
RemoveRemoteCandidate
(
c
)
;
}
}
)
)
;
}
void
VerifySavedTcpCandidates
(
int
endpoint
absl
:
:
string_view
tcptype
)
{
for
(
auto
&
data
:
GetEndpoint
(
endpoint
)
-
>
saved_candidates_
)
{
EXPECT_EQ
(
data
.
candidate
.
protocol
(
)
webrtc
:
:
TCP_PROTOCOL_NAME
)
;
EXPECT_EQ
(
data
.
candidate
.
tcptype
(
)
tcptype
)
;
if
(
data
.
candidate
.
tcptype
(
)
=
=
TCPTYPE_ACTIVE_STR
)
{
EXPECT_EQ
(
data
.
candidate
.
address
(
)
.
port
(
)
DISCARD_PORT
)
;
}
else
if
(
data
.
candidate
.
tcptype
(
)
=
=
TCPTYPE_PASSIVE_STR
)
{
EXPECT_NE
(
data
.
candidate
.
address
(
)
.
port
(
)
DISCARD_PORT
)
;
}
else
{
FAIL
(
)
<
<
"
Unknown
tcptype
:
"
<
<
data
.
candidate
.
tcptype
(
)
;
}
}
}
void
ResumeCandidates
(
int
endpoint
)
{
Endpoint
*
ed
=
GetEndpoint
(
endpoint
)
;
std
:
:
vector
<
CandidateData
>
candidates
=
std
:
:
move
(
ed
-
>
saved_candidates_
)
;
if
(
!
candidates
.
empty
(
)
)
{
main_
.
PostTask
(
SafeTask
(
safety_
[
this
candidates
=
std
:
:
move
(
candidates
)
]
(
)
mutable
{
for
(
CandidateData
&
data
:
candidates
)
{
AddCandidate
(
data
.
channel
data
.
candidate
)
;
}
}
)
)
;
}
ed
-
>
saved_candidates_
.
clear
(
)
;
ed
-
>
save_candidates_
=
false
;
}
void
AddCandidate
(
webrtc
:
:
IceTransportInternal
*
channel
webrtc
:
:
Candidate
&
candidate
)
{
P2PTransportChannel
*
rch
=
GetRemoteChannel
(
channel
)
;
if
(
rch
=
=
nullptr
)
{
return
;
}
if
(
remote_ice_parameter_source_
!
=
FROM_CANDIDATE
)
{
candidate
.
set_username
(
"
"
)
;
candidate
.
set_password
(
"
"
)
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
Candidate
(
"
<
<
channel
-
>
component
(
)
<
<
"
-
>
"
<
<
rch
-
>
component
(
)
<
<
"
)
:
"
<
<
candidate
.
ToString
(
)
;
rch
-
>
AddRemoteCandidate
(
candidate
)
;
}
void
OnReadPacket
(
webrtc
:
:
PacketTransportInternal
*
transport
const
rtc
:
:
ReceivedPacket
&
packet
)
{
std
:
:
list
<
std
:
:
string
>
&
packets
=
GetPacketList
(
transport
)
;
packets
.
push_front
(
std
:
:
string
(
reinterpret_cast
<
const
char
*
>
(
packet
.
payload
(
)
.
data
(
)
)
packet
.
payload
(
)
.
size
(
)
)
)
;
}
void
OnRoleConflict
(
webrtc
:
:
IceTransportInternal
*
channel
)
{
GetEndpoint
(
channel
)
-
>
OnRoleConflict
(
true
)
;
IceRole
new_role
=
GetEndpoint
(
channel
)
-
>
ice_role
(
)
=
=
ICEROLE_CONTROLLING
?
ICEROLE_CONTROLLED
:
ICEROLE_CONTROLLING
;
channel
-
>
SetIceRole
(
new_role
)
;
}
void
OnSentPacket
(
webrtc
:
:
PacketTransportInternal
*
transport
const
rtc
:
:
SentPacket
&
packet
)
{
TestPacketInfoIsSet
(
packet
.
info
)
;
}
int
SendData
(
webrtc
:
:
IceTransportInternal
*
channel
const
char
*
data
size_t
len
)
{
rtc
:
:
PacketOptions
options
;
return
channel
-
>
SendPacket
(
data
len
options
0
)
;
}
bool
CheckDataOnChannel
(
webrtc
:
:
IceTransportInternal
*
channel
const
char
*
data
int
len
)
{
return
GetChannelData
(
channel
)
-
>
CheckData
(
data
len
)
;
}
static
const
webrtc
:
:
Candidate
*
LocalCandidate
(
P2PTransportChannel
*
ch
)
{
return
(
ch
&
&
ch
-
>
selected_connection
(
)
)
?
&
ch
-
>
selected_connection
(
)
-
>
local_candidate
(
)
:
NULL
;
}
static
const
webrtc
:
:
Candidate
*
RemoteCandidate
(
P2PTransportChannel
*
ch
)
{
return
(
ch
&
&
ch
-
>
selected_connection
(
)
)
?
&
ch
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
:
NULL
;
}
Endpoint
*
GetEndpoint
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
if
(
ep1_
.
HasTransport
(
transport
)
)
{
return
&
ep1_
;
}
else
if
(
ep2_
.
HasTransport
(
transport
)
)
{
return
&
ep2_
;
}
else
{
return
NULL
;
}
}
P2PTransportChannel
*
GetRemoteChannel
(
webrtc
:
:
IceTransportInternal
*
ch
)
{
if
(
ch
=
=
ep1_ch1
(
)
)
return
ep2_ch1
(
)
;
else
if
(
ch
=
=
ep1_ch2
(
)
)
return
ep2_ch2
(
)
;
else
if
(
ch
=
=
ep2_ch1
(
)
)
return
ep1_ch1
(
)
;
else
if
(
ch
=
=
ep2_ch2
(
)
)
return
ep1_ch2
(
)
;
else
return
NULL
;
}
std
:
:
list
<
std
:
:
string
>
&
GetPacketList
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
return
GetChannelData
(
transport
)
-
>
ch_packets_
;
}
enum
RemoteIceParameterSource
{
FROM_CANDIDATE
FROM_SETICEPARAMETERS
}
;
void
set_remote_ice_parameter_source
(
RemoteIceParameterSource
source
)
{
remote_ice_parameter_source_
=
source
;
}
void
set_force_relay
(
bool
relay
)
{
force_relay_
=
relay
;
}
void
ConnectSignalNominated
(
Connection
*
conn
)
{
conn
-
>
SignalNominated
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnNominated
)
;
}
void
OnNominated
(
Connection
*
conn
)
{
nominated_
=
true
;
}
bool
nominated
(
)
{
return
nominated_
;
}
private
:
std
:
:
unique_ptr
<
webrtc
:
:
VirtualSocketServer
>
vss_
;
std
:
:
unique_ptr
<
webrtc
:
:
NATSocketServer
>
nss_
;
std
:
:
unique_ptr
<
webrtc
:
:
FirewallSocketServer
>
ss_
;
std
:
:
unique_ptr
<
webrtc
:
:
BasicPacketSocketFactory
>
socket_factory_
;
webrtc
:
:
AutoSocketServerThread
main_
;
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
safety_
=
PendingTaskSafetyFlag
:
:
Create
(
)
;
webrtc
:
:
TestStunServer
:
:
StunServerPtr
stun_server_
;
webrtc
:
:
TestTurnServer
turn_server_
;
Endpoint
ep1_
;
Endpoint
ep2_
;
RemoteIceParameterSource
remote_ice_parameter_source_
=
FROM_CANDIDATE
;
bool
force_relay_
;
int
selected_candidate_pair_switches_
=
0
;
bool
nominated_
=
false
;
}
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToLocalUdp
(
IceCandidateType
:
:
kHost
"
udp
"
IceCandidateType
:
:
kHost
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToStunUdp
(
IceCandidateType
:
:
kHost
"
udp
"
IceCandidateType
:
:
kSrflx
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToPrflxUdp
(
IceCandidateType
:
:
kHost
"
udp
"
IceCandidateType
:
:
kPrflx
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxUdpToLocalUdp
(
IceCandidateType
:
:
kPrflx
"
udp
"
IceCandidateType
:
:
kHost
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kStunUdpToLocalUdp
(
IceCandidateType
:
:
kSrflx
"
udp
"
IceCandidateType
:
:
kHost
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kStunUdpToStunUdp
(
IceCandidateType
:
:
kSrflx
"
udp
"
IceCandidateType
:
:
kSrflx
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kStunUdpToPrflxUdp
(
IceCandidateType
:
:
kSrflx
"
udp
"
IceCandidateType
:
:
kPrflx
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxUdpToStunUdp
(
IceCandidateType
:
:
kPrflx
"
udp
"
IceCandidateType
:
:
kSrflx
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToRelayUdp
(
IceCandidateType
:
:
kHost
"
udp
"
IceCandidateType
:
:
kRelay
"
udp
"
2000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxUdpToRelayUdp
(
IceCandidateType
:
:
kPrflx
"
udp
"
IceCandidateType
:
:
kRelay
"
udp
"
2000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kRelayUdpToPrflxUdp
(
IceCandidateType
:
:
kRelay
"
udp
"
IceCandidateType
:
:
kPrflx
"
udp
"
2000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalTcpToLocalTcp
(
IceCandidateType
:
:
kHost
"
tcp
"
IceCandidateType
:
:
kHost
"
tcp
"
3000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalTcpToPrflxTcp
(
IceCandidateType
:
:
kHost
"
tcp
"
IceCandidateType
:
:
kPrflx
"
tcp
"
3000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxTcpToLocalTcp
(
IceCandidateType
:
:
kPrflx
"
tcp
"
IceCandidateType
:
:
kHost
"
tcp
"
3000
)
;
class
P2PTransportChannelTest
:
public
P2PTransportChannelTestBase
{
protected
:
void
ConfigureEndpoints
(
const
Environment
&
env
Config
config1
Config
config2
int
allocator_flags1
int
allocator_flags2
)
{
CreatePortAllocators
(
env
)
;
ConfigureEndpoint
(
0
config1
)
;
SetAllocatorFlags
(
0
allocator_flags1
)
;
SetAllocationStepDelay
(
0
webrtc
:
:
kMinimumStepDelay
)
;
ConfigureEndpoint
(
1
config2
)
;
SetAllocatorFlags
(
1
allocator_flags2
)
;
SetAllocationStepDelay
(
1
webrtc
:
:
kMinimumStepDelay
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
}
void
ConfigureEndpoint
(
int
endpoint
Config
config
)
{
switch
(
config
)
{
case
OPEN
:
AddAddress
(
endpoint
kPublicAddrs
[
endpoint
]
)
;
break
;
case
NAT_FULL_CONE
:
case
NAT_ADDR_RESTRICTED
:
case
NAT_PORT_RESTRICTED
:
case
NAT_SYMMETRIC
:
AddAddress
(
endpoint
kPrivateAddrs
[
endpoint
]
)
;
nat
(
)
-
>
AddTranslator
(
kPublicAddrs
[
endpoint
]
kNatAddrs
[
endpoint
]
static_cast
<
webrtc
:
:
NATType
>
(
config
-
NAT_FULL_CONE
)
)
-
>
AddClient
(
kPrivateAddrs
[
endpoint
]
)
;
break
;
case
NAT_DOUBLE_CONE
:
case
NAT_SYMMETRIC_THEN_CONE
:
AddAddress
(
endpoint
kCascadedPrivateAddrs
[
endpoint
]
)
;
nat
(
)
-
>
AddTranslator
(
kPublicAddrs
[
endpoint
]
kNatAddrs
[
endpoint
]
(
config
=
=
NAT_DOUBLE_CONE
)
?
webrtc
:
:
NAT_OPEN_CONE
:
webrtc
:
:
NAT_SYMMETRIC
)
-
>
AddTranslator
(
kPrivateAddrs
[
endpoint
]
kCascadedNatAddrs
[
endpoint
]
webrtc
:
:
NAT_OPEN_CONE
)
-
>
AddClient
(
kCascadedPrivateAddrs
[
endpoint
]
)
;
break
;
case
BLOCK_UDP
:
case
BLOCK_UDP_AND_INCOMING_TCP
:
case
BLOCK_ALL_BUT_OUTGOING_HTTP
:
AddAddress
(
endpoint
kPublicAddrs
[
endpoint
]
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_UDP
webrtc
:
:
FD_ANY
kPublicAddrs
[
endpoint
]
)
;
if
(
config
=
=
BLOCK_UDP_AND_INCOMING_TCP
)
{
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_TCP
SocketAddress
(
)
kPublicAddrs
[
endpoint
]
)
;
}
else
if
(
config
=
=
BLOCK_ALL_BUT_OUTGOING_HTTP
)
{
fw
(
)
-
>
AddRule
(
true
webrtc
:
:
FP_TCP
kPublicAddrs
[
endpoint
]
SocketAddress
(
webrtc
:
:
IPAddress
(
INADDR_ANY
)
80
)
)
;
fw
(
)
-
>
AddRule
(
true
webrtc
:
:
FP_TCP
kPublicAddrs
[
endpoint
]
SocketAddress
(
webrtc
:
:
IPAddress
(
INADDR_ANY
)
443
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_TCP
webrtc
:
:
FD_ANY
kPublicAddrs
[
endpoint
]
)
;
}
break
;
default
:
RTC_DCHECK_NOTREACHED
(
)
;
break
;
}
}
}
;
class
P2PTransportChannelMatrixTest
:
public
P2PTransportChannelTest
public
WithParamInterface
<
std
:
:
string
>
{
protected
:
static
const
Result
*
kMatrix
[
NUM_CONFIGS
]
[
NUM_CONFIGS
]
;
}
;
#
define
LULU
&
kLocalUdpToLocalUdp
#
define
LUSU
&
kLocalUdpToStunUdp
#
define
LUPU
&
kLocalUdpToPrflxUdp
#
define
PULU
&
kPrflxUdpToLocalUdp
#
define
SULU
&
kStunUdpToLocalUdp
#
define
SUSU
&
kStunUdpToStunUdp
#
define
SUPU
&
kStunUdpToPrflxUdp
#
define
PUSU
&
kPrflxUdpToStunUdp
#
define
LURU
&
kLocalUdpToRelayUdp
#
define
PURU
&
kPrflxUdpToRelayUdp
#
define
RUPU
&
kRelayUdpToPrflxUdp
#
define
LTLT
&
kLocalTcpToLocalTcp
#
define
LTPT
&
kLocalTcpToPrflxTcp
#
define
PTLT
&
kPrflxTcpToLocalTcp
#
define
LTRT
NULL
#
define
LSRS
NULL
const
P2PTransportChannelMatrixTest
:
:
Result
*
P2PTransportChannelMatrixTest
:
:
kMatrix
[
NUM_CONFIGS
]
[
NUM_CONFIGS
]
=
{
{
LULU
LUSU
LUSU
LUSU
LUPU
LUSU
LUPU
LTPT
LTPT
LSRS
}
{
SULU
SUSU
SUSU
SUSU
SUPU
SUSU
SUPU
NULL
NULL
LSRS
}
{
SULU
SUSU
SUSU
SUSU
SUPU
SUSU
SUPU
NULL
NULL
LSRS
}
{
SULU
SUSU
SUSU
SUSU
RUPU
SUSU
RUPU
NULL
NULL
LSRS
}
{
PULU
PUSU
PUSU
PURU
PURU
PUSU
PURU
NULL
NULL
LSRS
}
{
SULU
SUSU
SUSU
SUSU
SUPU
SUSU
SUPU
NULL
NULL
LSRS
}
{
PULU
PUSU
PUSU
PURU
PURU
PUSU
PURU
NULL
NULL
LSRS
}
{
LTPT
NULL
NULL
NULL
NULL
NULL
NULL
LTPT
LTPT
LSRS
}
{
PTLT
NULL
NULL
NULL
NULL
NULL
NULL
PTLT
LTRT
LSRS
}
{
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
}
}
;
#
define
P2P_TEST_DECLARATION
(
x
y
z
)
\
TEST_P
(
P2PTransportChannelMatrixTest
z
#
#
Test
#
#
x
#
#
To
#
#
y
)
{
\
const
Environment
env
=
\
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
GetParam
(
)
)
)
;
\
ConfigureEndpoints
(
env
x
y
PORTALLOCATOR_ENABLE_SHARED_SOCKET
\
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
\
if
(
kMatrix
[
x
]
[
y
]
!
=
NULL
)
\
Test
(
env
*
kMatrix
[
x
]
[
y
]
)
;
\
else
\
RTC_LOG
(
LS_WARNING
)
<
<
"
Not
yet
implemented
"
;
\
}
#
define
P2P_TEST
(
x
y
)
P2P_TEST_DECLARATION
(
x
y
/
*
empty
argument
*
/
)
#
define
P2P_TEST_SET
(
x
)
\
P2P_TEST
(
x
OPEN
)
\
P2P_TEST
(
x
NAT_FULL_CONE
)
\
P2P_TEST
(
x
NAT_ADDR_RESTRICTED
)
\
P2P_TEST
(
x
NAT_PORT_RESTRICTED
)
\
P2P_TEST
(
x
NAT_SYMMETRIC
)
\
P2P_TEST
(
x
NAT_DOUBLE_CONE
)
\
P2P_TEST
(
x
NAT_SYMMETRIC_THEN_CONE
)
\
P2P_TEST
(
x
BLOCK_UDP
)
\
P2P_TEST
(
x
BLOCK_UDP_AND_INCOMING_TCP
)
\
P2P_TEST
(
x
BLOCK_ALL_BUT_OUTGOING_HTTP
)
P2P_TEST_SET
(
OPEN
)
P2P_TEST_SET
(
NAT_FULL_CONE
)
P2P_TEST_SET
(
NAT_ADDR_RESTRICTED
)
P2P_TEST_SET
(
NAT_PORT_RESTRICTED
)
P2P_TEST_SET
(
NAT_SYMMETRIC
)
P2P_TEST_SET
(
NAT_DOUBLE_CONE
)
P2P_TEST_SET
(
NAT_SYMMETRIC_THEN_CONE
)
P2P_TEST_SET
(
BLOCK_UDP
)
P2P_TEST_SET
(
BLOCK_UDP_AND_INCOMING_TCP
)
P2P_TEST_SET
(
BLOCK_ALL_BUT_OUTGOING_HTTP
)
INSTANTIATE_TEST_SUITE_P
(
All
P2PTransportChannelMatrixTest
Values
(
"
"
"
WebRTC
-
IceFieldTrials
/
enable_goog_ping
:
true
/
"
)
)
;
TEST_F
(
P2PTransportChannelTest
HandleUfragPwdChange
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
TestHandleIceUfragPasswordChanged
(
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
HandleUfragPwdChangeSymmetricNat
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_SYMMETRIC
NAT_SYMMETRIC
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
TestHandleIceUfragPasswordChanged
(
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
GetStats
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
virtual_socket_server
(
)
-
>
SetSendingBlocked
(
true
)
;
const
char
*
data
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
-
1
SendData
(
ep1_ch1
(
)
data
len
)
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
ASSERT_GE
(
ice_transport_stats
.
connection_infos
.
size
(
)
1u
)
;
ASSERT_GE
(
ice_transport_stats
.
candidate_stats_list
.
size
(
)
1u
)
;
EXPECT_EQ
(
ice_transport_stats
.
selected_candidate_pair_changes
1u
)
;
ConnectionInfo
*
best_conn_info
=
nullptr
;
for
(
ConnectionInfo
&
info
:
ice_transport_stats
.
connection_infos
)
{
if
(
info
.
best_connection
)
{
best_conn_info
=
&
info
;
break
;
}
}
ASSERT_TRUE
(
best_conn_info
!
=
nullptr
)
;
EXPECT_TRUE
(
best_conn_info
-
>
receiving
)
;
EXPECT_TRUE
(
best_conn_info
-
>
writable
)
;
EXPECT_FALSE
(
best_conn_info
-
>
timeout
)
;
EXPECT_EQ
(
11U
best_conn_info
-
>
sent_total_packets
)
;
EXPECT_EQ
(
1U
best_conn_info
-
>
sent_discarded_packets
)
;
EXPECT_EQ
(
10
*
36U
best_conn_info
-
>
sent_total_bytes
)
;
EXPECT_EQ
(
36U
best_conn_info
-
>
sent_discarded_bytes
)
;
EXPECT_EQ
(
10
*
36U
best_conn_info
-
>
recv_total_bytes
)
;
EXPECT_EQ
(
10U
best_conn_info
-
>
packets_received
)
;
EXPECT_EQ
(
10
*
36U
ice_transport_stats
.
bytes_sent
)
;
EXPECT_EQ
(
10
*
36U
ice_transport_stats
.
bytes_received
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
GetStatsSwitchConnection
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
webrtc
:
:
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
AddAddress
(
0
kAlternateAddrs
[
1
]
"
rmnet0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
CreateChannels
(
env
continual_gathering_config
continual_gathering_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
ASSERT_GE
(
ice_transport_stats
.
connection_infos
.
size
(
)
2u
)
;
ASSERT_GE
(
ice_transport_stats
.
candidate_stats_list
.
size
(
)
2u
)
;
EXPECT_EQ
(
ice_transport_stats
.
selected_candidate_pair_changes
1u
)
;
ConnectionInfo
*
best_conn_info
=
nullptr
;
for
(
ConnectionInfo
&
info
:
ice_transport_stats
.
connection_infos
)
{
if
(
info
.
best_connection
)
{
best_conn_info
=
&
info
;
break
;
}
}
ASSERT_TRUE
(
best_conn_info
!
=
nullptr
)
;
EXPECT_TRUE
(
best_conn_info
-
>
receiving
)
;
EXPECT_TRUE
(
best_conn_info
-
>
writable
)
;
EXPECT_FALSE
(
best_conn_info
-
>
timeout
)
;
EXPECT_EQ
(
10
*
36U
best_conn_info
-
>
sent_total_bytes
)
;
EXPECT_EQ
(
10
*
36U
best_conn_info
-
>
recv_total_bytes
)
;
EXPECT_EQ
(
10
*
36U
ice_transport_stats
.
bytes_sent
)
;
EXPECT_EQ
(
10
*
36U
ice_transport_stats
.
bytes_received
)
;
auto
old_selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
ep1_ch1
(
)
-
>
RemoveConnectionForTest
(
const_cast
<
Connection
*
>
(
old_selected_connection
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats2
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats2
)
)
;
int64_t
sum_bytes_sent
=
0
;
int64_t
sum_bytes_received
=
0
;
for
(
ConnectionInfo
&
info
:
ice_transport_stats
.
connection_infos
)
{
sum_bytes_sent
+
=
info
.
sent_total_bytes
;
sum_bytes_received
+
=
info
.
recv_total_bytes
;
}
EXPECT_EQ
(
10
*
36U
sum_bytes_sent
)
;
EXPECT_EQ
(
10
*
36U
sum_bytes_received
)
;
EXPECT_EQ
(
20
*
36U
ice_transport_stats2
.
bytes_sent
)
;
EXPECT_EQ
(
20
*
36U
ice_transport_stats2
.
bytes_received
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceRegatheringReasonContinualGatheringByNetworkChange
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
webrtc
:
:
IceConfig
default_config
;
CreateChannels
(
env
continual_gathering_config
default_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
GetIceRegatheringCountForReason
(
webrtc
:
:
IceRegatheringReason
:
:
NETWORK_CHANGE
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
EXPECT_EQ
(
0
GetEndpoint
(
1
)
-
>
GetIceRegatheringCountForReason
(
webrtc
:
:
IceRegatheringReason
:
:
NETWORK_CHANGE
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceRegatheringReasonContinualGatheringByNetworkFailure
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
config1
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
config1
.
regather_on_failed_networks_interval
=
2000
;
webrtc
:
:
IceConfig
config2
;
config2
.
regather_on_failed_networks_interval
=
2000
;
CreateChannels
(
env
config1
config2
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
const
int
kNetworkFailureTimeout
=
35000
;
SIMULATED_WAIT
(
false
kNetworkFailureTimeout
clock
)
;
EXPECT_LE
(
1
GetEndpoint
(
0
)
-
>
GetIceRegatheringCountForReason
(
webrtc
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
EXPECT_EQ
(
0
GetEndpoint
(
1
)
-
>
GetIceRegatheringCountForReason
(
webrtc
:
:
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignaling
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
env
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
const
Connection
*
selected_connection
=
nullptr
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
selected_connection
-
>
remote_candidate
(
)
.
is_prflx
(
)
)
;
EXPECT_EQ
(
kIceUfrag
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
password
(
)
)
;
EXPECT_EQ
(
1u
selected_connection
-
>
remote_candidate
(
)
.
generation
(
)
)
;
ResumeCandidates
(
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveRemoteCandidateIsSanitized
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
env
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
auto
pair_ep1
=
ep1_ch1
(
)
-
>
GetSelectedCandidatePair
(
)
;
ASSERT_TRUE
(
pair_ep1
.
has_value
(
)
)
;
EXPECT_TRUE
(
pair_ep1
-
>
remote_candidate
(
)
.
is_prflx
(
)
)
;
EXPECT_TRUE
(
pair_ep1
-
>
remote_candidate
(
)
.
address
(
)
.
ipaddr
(
)
.
IsNil
(
)
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats
;
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
;
ASSERT_EQ
(
1u
ice_transport_stats
.
connection_infos
.
size
(
)
)
;
EXPECT_TRUE
(
ice_transport_stats
.
connection_infos
[
0
]
.
remote_candidate
.
is_prflx
(
)
)
;
EXPECT_TRUE
(
ice_transport_stats
.
connection_infos
[
0
]
.
remote_candidate
.
address
(
)
.
ipaddr
(
)
.
IsNil
(
)
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
auto
updated_pair_ep1
=
ep1_ch1
(
)
-
>
GetSelectedCandidatePair
(
)
;
ASSERT_TRUE
(
updated_pair_ep1
.
has_value
(
)
)
;
EXPECT_TRUE
(
updated_pair_ep1
-
>
remote_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
HasRemoteAddress
(
&
updated_pair_ep1
.
value
(
)
kPublicAddrs
[
1
]
)
)
;
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
;
ASSERT_EQ
(
1u
ice_transport_stats
.
connection_infos
.
size
(
)
)
;
EXPECT_TRUE
(
ice_transport_stats
.
connection_infos
[
0
]
.
remote_candidate
.
is_local
(
)
)
;
EXPECT_TRUE
(
ice_transport_stats
.
connection_infos
[
0
]
.
remote_candidate
.
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignalingWithNAT
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
NAT_SYMMETRIC
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
env
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
const
Connection
*
selected_connection
=
nullptr
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
selected_connection
-
>
remote_candidate
(
)
.
is_prflx
(
)
)
;
EXPECT_EQ
(
kIceUfrag
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
password
(
)
)
;
EXPECT_EQ
(
1u
selected_connection
-
>
remote_candidate
(
)
.
generation
(
)
)
;
ResumeCandidates
(
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_prflx
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignalingWithIceRestart
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
GetEndpoint
(
1
)
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
env
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
PauseCandidates
(
1
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_prflx
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
Connection
*
prflx_selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ResumeCandidates
(
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
prflx_selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
RemoteCandidatesWithoutUfragPwd
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
const
Connection
*
selected_connection
=
NULL
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
selected_connection
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
NotNull
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
selected_connection
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
=
=
selected_connection
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
IncomingOnlyBlocked
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_FULL_CONE
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
ep1_ch1
(
)
-
>
set_incoming_only
(
true
)
;
SIMULATED_WAIT
(
false
kShortTimeout
clock
)
;
EXPECT_FALSE
(
ep1_ch1
(
)
-
>
receiving
(
)
)
;
EXPECT_FALSE
(
ep1_ch1
(
)
-
>
writable
(
)
)
;
EXPECT_FALSE
(
ep2_ch1
(
)
-
>
receiving
(
)
)
;
EXPECT_FALSE
(
ep2_ch1
(
)
-
>
writable
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
IncomingOnlyOpen
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
NAT_FULL_CONE
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
ep1_ch1
(
)
-
>
set_incoming_only
(
true
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
CanOnlyMakeOutgoingTcpConnections
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_ANY_ADDRESS_PORTS
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
fw
(
)
-
>
SetUnbindableIps
(
{
webrtc
:
:
GetAnyIP
(
AF_INET
)
webrtc
:
:
GetAnyIP
(
AF_INET6
)
kPublicAddrs
[
0
]
.
ipaddr
(
)
}
)
;
CreateChannels
(
env
)
;
Test
(
env
kPrflxTcpToLocalTcp
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestTcpConnectionsFromActiveToPassive
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocationStepDelay
(
0
webrtc
:
:
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
webrtc
:
:
kMinimumStepDelay
)
;
int
kOnlyLocalTcpPorts
=
webrtc
:
:
PORTALLOCATOR_DISABLE_UDP
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_RELAY
;
SetAllocatorFlags
(
0
kOnlyLocalTcpPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalTcpPorts
)
;
SetAllowTcpListen
(
0
true
)
;
SetAllowTcpListen
(
1
false
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
CreateChannels
(
env
)
;
VerifySavedTcpCandidates
(
0
TCPTYPE_PASSIVE_STR
)
;
VerifySavedTcpCandidates
(
1
TCPTYPE_ACTIVE_STR
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestTcpConnectionTcptypeSet
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
BLOCK_UDP_AND_INCOMING_TCP
OPEN
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
SetAllowTcpListen
(
0
false
)
;
SetAllowTcpListen
(
1
true
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
EXPECT_EQ
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
tcptype
(
)
"
passive
"
)
;
EXPECT_EQ
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
tcptype
(
)
"
active
"
)
;
EXPECT_EQ
(
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
tcptype
(
)
"
active
"
)
;
EXPECT_EQ
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
tcptype
(
)
"
passive
"
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceRoleConflict
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetIceRole
(
0
ICEROLE_CONTROLLING
)
;
SetIceRole
(
1
ICEROLE_CONTROLLING
)
;
CreateChannels
(
env
)
;
bool
first_endpoint_has_lower_tiebreaker
=
GetEndpoint
(
0
)
-
>
allocator_
-
>
ice_tiebreaker
(
)
<
GetEndpoint
(
1
)
-
>
allocator_
-
>
ice_tiebreaker
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetRoleConflict
(
first_endpoint_has_lower_tiebreaker
?
0
:
1
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
GetRoleConflict
(
first_endpoint_has_lower_tiebreaker
?
1
:
0
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
TestSendRecv
(
&
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceConfigWillPassDownToPort
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetIceRole
(
0
ICEROLE_CONTROLLING
)
;
SetIceRole
(
1
ICEROLE_CONTROLLING
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
ports
(
)
.
size
(
)
;
}
Eq
(
2u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
std
:
:
vector
<
webrtc
:
:
PortInterface
*
>
ports_before
=
ep1_ch1
(
)
-
>
ports
(
)
;
for
(
size_t
i
=
0
;
i
<
ports_before
.
size
(
)
;
+
+
i
)
{
EXPECT_EQ
(
ICEROLE_CONTROLLING
ports_before
[
i
]
-
>
GetIceRole
(
)
)
;
}
ep1_ch1
(
)
-
>
SetIceRole
(
ICEROLE_CONTROLLED
)
;
const
std
:
:
vector
<
webrtc
:
:
PortInterface
*
>
ports_after
=
ep1_ch1
(
)
-
>
ports
(
)
;
for
(
size_t
i
=
0
;
i
<
ports_after
.
size
(
)
;
+
+
i
)
{
EXPECT_EQ
(
ICEROLE_CONTROLLED
ports_before
[
i
]
-
>
GetIceRole
(
)
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
TestSendRecv
(
&
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestDefaultDscpValue
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
CreateChannels
(
env
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_NO_CHANGE
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_NO_CHANGE
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS6
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS6
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_CS6
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_CS6
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_AF41
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_AF41
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_AF41
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_AF41
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIPv6Connections
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kIPv6PublicAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kIPv6PublicAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocationStepDelay
(
0
webrtc
:
:
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
webrtc
:
:
kMinimumStepDelay
)
;
SetAllocatorFlags
(
0
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6
|
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6_ON_WIFI
)
;
SetAllocatorFlags
(
1
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6
|
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6_ON_WIFI
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kIPv6PublicAddrs
[
0
]
kIPv6PublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestForceTurn
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_PORT_RESTRICTED
NAT_SYMMETRIC
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
set_force_relay
(
true
)
;
SetAllocationStepDelay
(
0
webrtc
:
:
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
webrtc
:
:
kMinimumStepDelay
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
is_relay
(
)
)
;
TestSendRecv
(
&
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestContinualGathering
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
SetAllocationStepDelay
(
0
webrtc
:
:
kDefaultStepDelay
)
;
SetAllocationStepDelay
(
1
webrtc
:
:
kDefaultStepDelay
)
;
webrtc
:
:
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
webrtc
:
:
IceConfig
default_config
;
CreateChannels
(
env
continual_gathering_config
default_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringComplete
=
=
ep1_ch1
(
)
-
>
gathering_state
(
)
kShortTimeout
clock
)
;
EXPECT_EQ
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringGathering
ep1_ch1
(
)
-
>
gathering_state
(
)
)
;
EXPECT_EQ
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringComplete
ep2_ch1
(
)
-
>
gathering_state
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUsingPooledSessionBeforeDoneGathering
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
auto
&
allocator_1
=
GetEndpoint
(
0
)
-
>
allocator_
;
auto
&
allocator_2
=
GetEndpoint
(
1
)
-
>
allocator_
;
int
pool_size
=
1
;
allocator_1
-
>
SetConfiguration
(
allocator_1
-
>
stun_servers
(
)
allocator_1
-
>
turn_servers
(
)
pool_size
webrtc
:
:
NO_PRUNE
)
;
allocator_2
-
>
SetConfiguration
(
allocator_2
-
>
stun_servers
(
)
allocator_2
-
>
turn_servers
(
)
pool_size
webrtc
:
:
NO_PRUNE
)
;
const
webrtc
:
:
PortAllocatorSession
*
pooled_session_1
=
allocator_1
-
>
GetPooledSession
(
)
;
const
webrtc
:
:
PortAllocatorSession
*
pooled_session_2
=
allocator_2
-
>
GetPooledSession
(
)
;
ASSERT_NE
(
nullptr
pooled_session_1
)
;
ASSERT_NE
(
nullptr
pooled_session_2
)
;
EXPECT_TRUE
(
pooled_session_1
-
>
ReadyPorts
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
pooled_session_1
-
>
ReadyCandidates
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
pooled_session_2
-
>
ReadyPorts
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
pooled_session_2
-
>
ReadyCandidates
(
)
.
empty
(
)
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
auto
pooled_ports_1
=
pooled_session_1
-
>
ReadyPorts
(
)
;
auto
pooled_ports_2
=
pooled_session_2
-
>
ReadyPorts
(
)
;
EXPECT_THAT
(
pooled_ports_1
Contains
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
PortForTest
(
)
)
)
;
EXPECT_THAT
(
pooled_ports_2
Contains
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
PortForTest
(
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUsingPooledSessionAfterDoneGathering
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
auto
&
allocator_1
=
GetEndpoint
(
0
)
-
>
allocator_
;
auto
&
allocator_2
=
GetEndpoint
(
1
)
-
>
allocator_
;
int
pool_size
=
1
;
allocator_1
-
>
SetConfiguration
(
allocator_1
-
>
stun_servers
(
)
allocator_1
-
>
turn_servers
(
)
pool_size
webrtc
:
:
NO_PRUNE
)
;
allocator_2
-
>
SetConfiguration
(
allocator_2
-
>
stun_servers
(
)
allocator_2
-
>
turn_servers
(
)
pool_size
webrtc
:
:
NO_PRUNE
)
;
const
webrtc
:
:
PortAllocatorSession
*
pooled_session_1
=
allocator_1
-
>
GetPooledSession
(
)
;
const
webrtc
:
:
PortAllocatorSession
*
pooled_session_2
=
allocator_2
-
>
GetPooledSession
(
)
;
ASSERT_NE
(
nullptr
pooled_session_1
)
;
ASSERT_NE
(
nullptr
pooled_session_2
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
pooled_session_1
-
>
CandidatesAllocationDone
(
)
&
&
pooled_session_2
-
>
CandidatesAllocationDone
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestSendRecv
(
&
clock
)
;
auto
pooled_ports_1
=
pooled_session_1
-
>
ReadyPorts
(
)
;
auto
pooled_ports_2
=
pooled_session_2
-
>
ReadyPorts
(
)
;
EXPECT_THAT
(
pooled_ports_1
Contains
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
PortForTest
(
)
)
)
;
EXPECT_THAT
(
pooled_ports_2
Contains
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
PortForTest
(
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TurnToTurnPresumedWritable
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
gathering_state
(
)
;
}
Eq
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringComplete
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
2
.
2
.
2
.
2
"
2
0
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
writable
(
)
)
;
EXPECT_TRUE
(
GetEndpoint
(
0
)
-
>
ready_to_send_
)
;
const
char
*
data
=
"
test
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
len
SendData
(
ep1_ch1
(
)
data
len
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TurnToPrflxPresumedWritable
)
{
webrtc
:
:
ScopedFakeClock
fake_clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
virtual_socket_server
(
)
-
>
set_delay_mean
(
50
)
;
virtual_socket_server
(
)
-
>
UpdateDelayDistribution
(
)
;
ConfigureEndpoints
(
env
NAT_SYMMETRIC
NAT_SYMMETRIC
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
test_turn_server
(
)
-
>
set_enable_permission_checks
(
false
)
;
webrtc
:
:
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
1
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
1
]
kIceParams
[
0
]
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
PauseCandidates
(
1
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
fake_clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
is_prflx
(
)
)
;
EXPECT_FALSE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
writable
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
fake_clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PresumedWritablePreferredOverUnreliable
)
{
webrtc
:
:
ScopedFakeClock
fake_clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_SYMMETRIC
NAT_SYMMETRIC
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
webrtc
:
:
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
1
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
1
]
kIceParams
[
0
]
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
fake_clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
Connection
*
old_selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
.
reset
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ep1_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
fake_clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
nullptr
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
2
.
2
.
2
.
2
"
2
0
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
writable
(
)
)
;
EXPECT_TRUE
(
GetEndpoint
(
0
)
-
>
ready_to_send_
)
;
EXPECT_NE
(
old_selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
SignalReadyToSendWithPresumedWritable
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
gathering_state
(
)
;
}
Eq
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringComplete
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
1
.
1
.
1
.
1
"
1
0
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
virtual_socket_server
(
)
-
>
SetSendingBlocked
(
true
)
;
const
char
*
data
=
"
test
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
-
1
SendData
(
ep1_ch1
(
)
data
len
)
)
;
GetEndpoint
(
0
)
-
>
ready_to_send_
=
false
;
virtual_socket_server
(
)
-
>
SetSendingBlocked
(
false
)
;
EXPECT_TRUE
(
GetEndpoint
(
0
)
-
>
ready_to_send_
)
;
EXPECT_EQ
(
len
SendData
(
ep1_ch1
(
)
data
len
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TurnToPrflxSelectedAfterResolvingIceControllingRoleConflict
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_SYMMETRIC
NAT_SYMMETRIC
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_DISABLE_UDP
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_DISABLE_UDP
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
)
;
SetIceRole
(
0
ICEROLE_CONTROLLING
)
;
SetIceRole
(
1
ICEROLE_CONTROLLING
)
;
test_turn_server
(
)
-
>
set_enable_permission_checks
(
false
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
1
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
1
]
kIceParams
[
0
]
)
;
PauseCandidates
(
1
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
is_relay
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
is_prflx
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
CanConnectWithPiggybackCheckAcknowledgementWhenCheckResponseBlocked
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
PiggybackIceCheckAcknowledgement
/
Enabled
/
"
)
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
ep1_config
;
webrtc
:
:
IceConfig
ep2_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ep2_config
.
receiving_timeout
=
30
*
1000
;
ep2_config
.
ice_unwritable_timeout
=
30
*
1000
;
ep2_config
.
ice_unwritable_min_checks
=
30
;
ep2_config
.
ice_inactive_timeout
=
60
*
1000
;
CreateChannels
(
env
ep1_config
ep2_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
LocalCandidate
(
ep1_ch1
(
)
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_IN
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
!
=
nullptr
&
&
!
ep1_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
!
=
nullptr
&
&
ep2_ch1
(
)
-
>
writable
(
)
)
;
fw
(
)
-
>
ClearRules
(
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_OUT
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
class
P2PTransportChannelSameNatTest
:
public
P2PTransportChannelTestBase
{
protected
:
void
ConfigureEndpoints
(
const
Environment
&
env
Config
nat_type
Config
config1
Config
config2
)
{
RTC_CHECK_GE
(
nat_type
NAT_FULL_CONE
)
;
RTC_CHECK_LE
(
nat_type
NAT_SYMMETRIC
)
;
CreatePortAllocators
(
env
)
;
webrtc
:
:
NATSocketServer
:
:
Translator
*
outer_nat
=
nat
(
)
-
>
AddTranslator
(
kPublicAddrs
[
0
]
kNatAddrs
[
0
]
static_cast
<
webrtc
:
:
NATType
>
(
nat_type
-
NAT_FULL_CONE
)
)
;
ConfigureEndpoint
(
outer_nat
0
config1
)
;
ConfigureEndpoint
(
outer_nat
1
config2
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
}
void
ConfigureEndpoint
(
webrtc
:
:
NATSocketServer
:
:
Translator
*
nat
int
endpoint
Config
config
)
{
RTC_CHECK
(
config
<
=
NAT_SYMMETRIC
)
;
if
(
config
=
=
OPEN
)
{
AddAddress
(
endpoint
kPrivateAddrs
[
endpoint
]
)
;
nat
-
>
AddClient
(
kPrivateAddrs
[
endpoint
]
)
;
}
else
{
AddAddress
(
endpoint
kCascadedPrivateAddrs
[
endpoint
]
)
;
nat
-
>
AddTranslator
(
kPrivateAddrs
[
endpoint
]
kCascadedNatAddrs
[
endpoint
]
static_cast
<
webrtc
:
:
NATType
>
(
config
-
NAT_FULL_CONE
)
)
-
>
AddClient
(
kCascadedPrivateAddrs
[
endpoint
]
)
;
}
}
}
;
TEST_F
(
P2PTransportChannelSameNatTest
TestConesBehindSameCone
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_FULL_CONE
NAT_FULL_CONE
NAT_FULL_CONE
)
;
Test
(
env
P2PTransportChannelTestBase
:
:
Result
(
IceCandidateType
:
:
kPrflx
"
udp
"
IceCandidateType
:
:
kSrflx
"
udp
"
1000
)
)
;
}
class
P2PTransportChannelMultihomedTest
:
public
P2PTransportChannelTest
{
public
:
const
Connection
*
GetConnectionWithRemoteAddress
(
P2PTransportChannel
*
channel
const
SocketAddress
&
address
)
{
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
HasRemoteAddress
(
conn
address
)
)
{
return
conn
;
}
}
return
nullptr
;
}
Connection
*
GetConnectionWithLocalAddress
(
P2PTransportChannel
*
channel
const
SocketAddress
&
address
)
{
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
HasLocalAddress
(
conn
address
)
)
{
return
conn
;
}
}
return
nullptr
;
}
Connection
*
GetConnection
(
P2PTransportChannel
*
channel
const
SocketAddress
&
local
const
SocketAddress
&
remote
)
{
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
HasLocalAddress
(
conn
local
)
&
&
HasRemoteAddress
(
conn
remote
)
)
{
return
conn
;
}
}
return
nullptr
;
}
Connection
*
GetBestConnection
(
P2PTransportChannel
*
channel
)
{
rtc
:
:
ArrayView
<
Connection
*
const
>
connections
=
channel
-
>
connections
(
)
;
auto
it
=
absl
:
:
c_find
(
connections
channel
-
>
selected_connection
(
)
)
;
if
(
it
=
=
connections
.
end
(
)
)
{
return
nullptr
;
}
return
*
it
;
}
Connection
*
GetBackupConnection
(
P2PTransportChannel
*
channel
)
{
rtc
:
:
ArrayView
<
Connection
*
const
>
connections
=
channel
-
>
connections
(
)
;
auto
it
=
absl
:
:
c_find_if_not
(
connections
[
channel
]
(
Connection
*
conn
)
{
return
conn
=
=
channel
-
>
selected_connection
(
)
;
}
)
;
if
(
it
=
=
connections
.
end
(
)
)
{
return
nullptr
;
}
return
*
it
;
}
void
DestroyAllButBestConnection
(
P2PTransportChannel
*
channel
)
{
const
Connection
*
selected_connection
=
channel
-
>
selected_connection
(
)
;
rtc
:
:
ArrayView
<
Connection
*
const
>
view
=
channel
-
>
connections
(
)
;
std
:
:
vector
<
Connection
*
>
connections
(
view
.
begin
(
)
view
.
end
(
)
)
;
for
(
Connection
*
conn
:
connections
)
{
if
(
conn
!
=
selected_connection
)
channel
-
>
RemoveConnectionForTest
(
conn
)
;
}
}
}
;
TEST_F
(
P2PTransportChannelMultihomedTest
TestBasic
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
Test
(
env
kLocalUdpToLocalUdp
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestFailoverControlledSide
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
"
wlan0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
CreateChannels
(
env
config
config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
1
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
selected_connection1
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
1
]
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
1
]
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestFailoverControllingSide
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
wlan0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
CreateChannels
(
env
config
config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kAlternateAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestFailoverWithManyConnections
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
test_turn_server
(
)
-
>
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
webrtc
:
:
RelayServerConfig
turn_server
;
turn_server
.
credentials
=
kRelayCredentials
;
turn_server
.
ports
.
push_back
(
ProtocolAddress
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
)
;
GetAllocator
(
0
)
-
>
AddTurnServerForTesting
(
turn_server
)
;
GetAllocator
(
1
)
-
>
AddTurnServerForTesting
(
turn_server
)
;
SetAllocatorFlags
(
0
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6
|
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6_ON_WIFI
)
;
SetAllocatorFlags
(
1
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6
|
webrtc
:
:
PORTALLOCATOR_ENABLE_IPV6_ON_WIFI
)
;
SetAllocationStepDelay
(
0
webrtc
:
:
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
webrtc
:
:
kMinimumStepDelay
)
;
auto
&
wifi
=
kPublicAddrs
;
auto
&
cellular
=
kAlternateAddrs
;
auto
&
wifiIpv6
=
kIPv6PublicAddrs
;
auto
&
cellularIpv6
=
kIPv6AlternateAddrs
;
AddAddress
(
0
wifi
[
0
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
wifiIpv6
[
0
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
0
cellularIpv6
[
0
]
"
cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
wifiIpv6
[
1
]
"
wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
cellular1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
cellularIpv6
[
1
]
"
cellular1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
virtual_socket_server
(
)
-
>
SetDelayOnAddress
(
kTurnTcpIntAddr
1
)
;
virtual_socket_server
(
)
-
>
SetDelayOnAddress
(
kTurnUdpExtAddr
1
)
;
virtual_socket_server
(
)
-
>
set_delay_mean
(
500
)
;
virtual_socket_server
(
)
-
>
UpdateDelayDistribution
(
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
CreateChannels
(
env
config
config
true
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
wifiIpv6
[
0
]
wifiIpv6
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
wifi
[
0
]
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
wifiIpv6
[
0
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
const
Connection
*
selected_connection2
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
selected_connection1
-
>
receiving
(
)
&
&
!
selected_connection2
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
Connection
*
per_network_best_connection1
=
GetConnection
(
ep1_ch1
(
)
cellularIpv6
[
0
]
wifiIpv6
[
1
]
)
;
ASSERT_NE
(
nullptr
per_network_best_connection1
)
;
int64_t
last_ping_sent1
=
per_network_best_connection1
-
>
last_ping_sent
(
)
;
int
num_pings_sent1
=
per_network_best_connection1
-
>
num_pings_sent
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
per_network_best_connection1
-
>
num_pings_sent
(
)
;
}
Gt
(
num_pings_sent1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_GT
(
per_network_best_connection1
-
>
num_pings_sent
(
)
-
num_pings_sent1
0
)
;
int64_t
ping_interval1
=
(
per_network_best_connection1
-
>
last_ping_sent
(
)
-
last_ping_sent1
)
/
(
per_network_best_connection1
-
>
num_pings_sent
(
)
-
num_pings_sent1
)
;
constexpr
int
SCHEDULING_DELAY
=
200
;
EXPECT_LT
(
ping_interval1
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_DELAY
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
cellularIpv6
[
0
]
wifiIpv6
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestIceRenomination
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
wlan0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
CreateChannels
(
env
config
config
true
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_nomination
(
)
>
0
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
acked_nomination
(
)
>
0
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
Connection
*
selected_connection2
=
const_cast
<
Connection
*
>
(
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
uint32_t
remote_nomination2
=
selected_connection2
-
>
remote_nomination
(
)
;
ConnectSignalNominated
(
selected_connection2
)
;
SIMULATED_WAIT
(
nominated
(
)
kMediumTimeout
clock
)
;
EXPECT_FALSE
(
nominated
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
selected_connection1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_nomination
(
)
;
}
Gt
(
remote_nomination2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestConnectionSwitchDampeningControlledSide
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
"
wlan0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
reset_selected_candidate_pair_switches
(
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
1
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
selected_connection1
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
fw
(
)
-
>
ClearRules
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestConnectionSwitchDampeningControllingSide
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
wlan0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
reset_selected_candidate_pair_switches
(
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
selected_connection1
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
fw
(
)
-
>
ClearRules
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestRemoteFailover
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
auto
&
wifi
=
kPublicAddrs
;
auto
&
cellular
=
kAlternateAddrs
;
AddAddress
(
0
wifi
[
0
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
25000
)
;
config
.
stable_writable_connection_ping_interval
=
900
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
wifi
[
0
]
wifi
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
Connection
*
backup_conn
=
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
;
ASSERT_NE
(
nullptr
backup_conn
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
backup_conn
-
>
writable
(
)
&
&
!
backup_conn
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
reset_selected_candidate_pair_switches
(
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
wifi
[
1
]
)
;
int
num_switches
=
0
;
SIMULATED_WAIT
(
(
num_switches
=
reset_selected_candidate_pair_switches
(
)
)
>
0
20000
clock
)
;
EXPECT_EQ
(
0
num_switches
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestPreferWifiToWifiConnection
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
wifi
[
0
]
"
test0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
test0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
(
)
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
wifi
[
0
]
wifi
[
1
]
)
;
}
IsTrue
(
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestPreferWifiOverCellularNetwork
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
cellular
[
0
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
test0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
(
)
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
cellular
[
0
]
wifi
[
1
]
)
;
}
IsTrue
(
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestPingBackupConnectionRate
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
int
backup_ping_interval
=
2000
;
ep2_ch1
(
)
-
>
SetIceConfig
(
CreateIceConfig
(
2000
webrtc
:
:
GATHER_ONCE
backup_ping_interval
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
GetState
(
)
;
}
Eq
(
IceTransportState
:
:
STATE_COMPLETED
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
auto
connections
=
ep2_ch1
(
)
-
>
connections
(
)
;
ASSERT_EQ
(
2U
connections
.
size
(
)
)
;
Connection
*
backup_conn
=
GetBackupConnection
(
ep2_ch1
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
backup_conn
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
int64_t
last_ping_response_ms
=
backup_conn
-
>
last_ping_response_received
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
backup_conn
-
>
last_ping_response_received
(
)
;
}
Gt
(
last_ping_response_ms
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
int
time_elapsed
=
backup_conn
-
>
last_ping_response_received
(
)
-
last_ping_response_ms
;
RTC_LOG
(
LS_INFO
)
<
<
"
Time
elapsed
:
"
<
<
time_elapsed
;
EXPECT_GE
(
time_elapsed
backup_ping_interval
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestStableWritableRate
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
int
ping_interval_ms
=
3456
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
2
*
ping_interval_ms
webrtc
:
:
GATHER_ONCE
)
;
config
.
stable_writable_connection_ping_interval
=
ping_interval_ms
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
GetState
(
)
;
}
Eq
(
IceTransportState
:
:
STATE_COMPLETED
)
)
webrtc
:
:
IsRtcOk
(
)
)
;
auto
connections
=
ep2_ch1
(
)
-
>
connections
(
)
;
ASSERT_EQ
(
2U
connections
.
size
(
)
)
;
Connection
*
conn
=
GetBestConnection
(
ep2_ch1
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
int64_t
last_ping_response_ms
;
for
(
int
i
=
0
;
i
<
5
;
i
+
+
)
{
last_ping_response_ms
=
conn
-
>
last_ping_response_received
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn
-
>
last_ping_response_received
(
)
;
}
Gt
(
last_ping_response_ms
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
EXPECT_TRUE
(
conn
-
>
stable
(
last_ping_response_ms
)
)
<
<
"
Connection
not
stable
"
;
int
time_elapsed
=
conn
-
>
last_ping_response_received
(
)
-
last_ping_response_ms
;
RTC_LOG
(
LS_INFO
)
<
<
"
Time
elapsed
:
"
<
<
time_elapsed
;
EXPECT_GE
(
time_elapsed
ping_interval_ms
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestGetState
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
CreateChannels
(
env
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
GetState
(
)
;
}
Eq
(
IceTransportState
:
:
STATE_COMPLETED
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
GetState
(
)
;
}
Eq
(
IceTransportState
:
:
STATE_COMPLETED
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestNetworkBecomesInactive
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
webrtc
:
:
IceConfig
ep1_config
=
CreateIceConfig
(
2000
webrtc
:
:
GATHER_CONTINUALLY
)
;
webrtc
:
:
IceConfig
ep2_config
=
CreateIceConfig
(
2000
webrtc
:
:
GATHER_ONCE
)
;
CreateChannels
(
env
ep1_config
ep2_config
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_LE
(
1U
ep1_ch1
(
)
-
>
ports
(
)
.
size
(
)
)
;
RemoveAddress
(
0
kPublicAddrs
[
0
]
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
ports
(
)
.
empty
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
remote_candidates
(
)
.
empty
(
)
;
}
IsTrue
(
)
{
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
size_t
num_ports
=
ep2_ch1
(
)
-
>
ports
(
)
.
size
(
)
;
EXPECT_LE
(
1U
num_ports
)
;
size_t
num_remote_candidates
=
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
;
RemoveAddress
(
1
kPublicAddrs
[
1
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
ports
(
)
.
size
(
)
;
}
Eq
(
0U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
empty
(
)
500
clock
)
;
EXPECT_EQ
(
num_remote_candidates
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestContinualGatheringOnNewInterface
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
wifi
[
0
]
"
test_wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test_cell1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
webrtc
:
:
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
CreateChannels
(
env
continual_gathering_config
continual_gathering_config
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
AddAddress
(
1
wifi
[
1
]
"
test_wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
const
Connection
*
conn
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
(
conn
=
ep1_ch1
(
)
-
>
selected_connection
(
)
)
!
=
nullptr
&
&
HasRemoteAddress
(
conn
wifi
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
(
conn
=
ep2_ch1
(
)
-
>
selected_connection
(
)
)
!
=
nullptr
&
&
HasLocalAddress
(
conn
wifi
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
AddAddress
(
0
cellular
[
0
]
"
test_cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
GetState
(
)
=
=
IceTransportState
:
:
STATE_COMPLETED
&
&
absl
:
:
c_any_of
(
ep1_ch1
(
)
-
>
connections
(
)
[
channel
=
ep1_ch1
(
)
address
=
cellular
[
0
]
]
(
const
Connection
*
conn
)
{
return
HasLocalAddress
(
conn
address
)
&
&
conn
!
=
channel
-
>
selected_connection
(
)
&
&
conn
-
>
writable
(
)
;
}
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
GetState
(
)
=
=
IceTransportState
:
:
STATE_COMPLETED
&
&
absl
:
:
c_any_of
(
ep2_ch1
(
)
-
>
connections
(
)
[
channel
=
ep2_ch1
(
)
address
=
cellular
[
0
]
]
(
const
Connection
*
conn
)
{
return
HasRemoteAddress
(
conn
address
)
&
&
conn
!
=
channel
-
>
selected_connection
(
)
&
&
conn
-
>
receiving
(
)
;
}
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestSwitchLinksViaContinualGathering
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
CreateChannels
(
env
continual_gathering_config
continual_gathering_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Draining
.
.
.
"
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
RemoveAddress
(
1
kPublicAddrs
[
1
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kAlternateAddrs
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Draining
again
.
.
.
"
;
RemoveAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kAlternateAddrs
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
kPublicAddrs
[
0
]
kAlternateAddrs
[
0
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestRestoreBackupConnection
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
wifi
[
0
]
"
test_wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
test_cell0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
test_wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test_cell1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
config
.
regather_on_failed_networks_interval
=
2000
;
CreateChannels
(
env
config
config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckCandidatePairAndConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
wifi
[
0
]
wifi
[
1
]
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyAllButBestConnection
(
ep1_ch1
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
Connection
*
conn
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
(
conn
=
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
)
!
=
nullptr
&
&
conn
!
=
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
conn
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestVpnDefault
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_ETHERNET
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
vpn0
"
rtc
:
:
ADAPTER_TYPE_VPN
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
CreateChannels
(
env
config
config
false
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
!
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestVpnPreferVpn
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_ETHERNET
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
vpn0
"
rtc
:
:
ADAPTER_TYPE_VPN
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
config
.
vpn_preference
=
webrtc
:
:
VpnPreference
:
:
kPreferVpn
;
RTC_LOG
(
LS_INFO
)
<
<
"
KESO
:
config
.
vpn_preference
:
"
<
<
config
.
vpn_preference
;
CreateChannels
(
env
config
config
false
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kAlternateAddrs
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
!
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestVpnAvoidVpn
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
vpn0
"
rtc
:
:
ADAPTER_TYPE_VPN
rtc
:
:
ADAPTER_TYPE_ETHERNET
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
config
.
vpn_preference
=
webrtc
:
:
VpnPreference
:
:
kAvoidVpn
;
CreateChannels
(
env
config
config
false
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
!
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestVpnNeverVpn
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
vpn0
"
rtc
:
:
ADAPTER_TYPE_VPN
rtc
:
:
ADAPTER_TYPE_ETHERNET
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
config
.
vpn_preference
=
webrtc
:
:
VpnPreference
:
:
kNeverUseVpn
;
CreateChannels
(
env
config
config
false
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
!
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestVpnOnlyVpn
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
vpn0
"
rtc
:
:
ADAPTER_TYPE_VPN
rtc
:
:
ADAPTER_TYPE_ETHERNET
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
config
.
vpn_preference
=
webrtc
:
:
VpnPreference
:
:
kOnlyUseVpn
;
CreateChannels
(
env
config
config
false
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
network
(
)
-
>
IsVpn
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
webrtc
:
:
FD_ANY
kAlternateAddrs
[
0
]
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
StunDictionaryPerformsSync
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
"
eth0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
"
vpn0
"
rtc
:
:
ADAPTER_TYPE_VPN
rtc
:
:
ADAPTER_TYPE_ETHERNET
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
CreateChannels
(
env
)
;
MockFunction
<
void
(
webrtc
:
:
IceTransportInternal
*
const
StunDictionaryView
&
rtc
:
:
ArrayView
<
uint16_t
>
)
>
view_updated_func
;
ep2_ch1
(
)
-
>
AddDictionaryViewUpdatedCallback
(
"
tag
"
view_updated_func
.
AsStdFunction
(
)
)
;
MockFunction
<
void
(
webrtc
:
:
IceTransportInternal
*
const
StunDictionaryWriter
&
)
>
writer_synced_func
;
ep1_ch1
(
)
-
>
AddDictionaryWriterSyncedCallback
(
"
tag
"
writer_synced_func
.
AsStdFunction
(
)
)
;
auto
&
dict_writer
=
ep1_ch1
(
)
-
>
GetDictionaryWriter
(
)
-
>
get
(
)
;
dict_writer
.
SetByteString
(
12
)
-
>
CopyBytes
(
"
keso
"
)
;
EXPECT_CALL
(
view_updated_func
Call
)
.
WillOnce
(
[
&
]
(
auto
*
channel
auto
&
view
auto
keys
)
{
EXPECT_EQ
(
keys
.
size
(
)
1u
)
;
EXPECT_EQ
(
keys
[
0
]
12
)
;
EXPECT_EQ
(
view
.
GetByteString
(
12
)
-
>
string_view
(
)
"
keso
"
)
;
}
)
;
EXPECT_CALL
(
writer_synced_func
Call
)
.
Times
(
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
class
P2PTransportChannelPingTest
:
public
:
:
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
P2PTransportChannelPingTest
(
)
:
vss_
(
std
:
:
make_unique
<
webrtc
:
:
VirtualSocketServer
>
(
)
)
packet_socket_factory_
(
std
:
:
make_unique
<
webrtc
:
:
BasicPacketSocketFactory
>
(
vss_
.
get
(
)
)
)
thread_
(
vss_
.
get
(
)
)
{
}
protected
:
void
PrepareChannel
(
P2PTransportChannel
*
ch
)
{
ch
-
>
SetIceRole
(
ICEROLE_CONTROLLING
)
;
ch
-
>
SetIceParameters
(
kIceParams
[
0
]
)
;
ch
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ch
-
>
SignalNetworkRouteChanged
.
connect
(
this
&
P2PTransportChannelPingTest
:
:
OnNetworkRouteChanged
)
;
ch
-
>
SignalReadyToSend
.
connect
(
this
&
P2PTransportChannelPingTest
:
:
OnReadyToSend
)
;
ch
-
>
SignalStateChanged
.
connect
(
this
&
P2PTransportChannelPingTest
:
:
OnChannelStateChanged
)
;
ch
-
>
SetCandidatePairChangeCallback
(
[
this
]
(
const
cricket
:
:
CandidatePairChangeEvent
&
event
)
{
OnCandidatePairChanged
(
event
)
;
}
)
;
}
Connection
*
WaitForConnectionTo
(
P2PTransportChannel
*
ch
absl
:
:
string_view
ip
int
port_num
webrtc
:
:
ThreadProcessingFakeClock
*
clock
=
nullptr
)
{
if
(
clock
=
=
nullptr
)
{
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetConnectionTo
(
ch
ip
port_num
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
else
{
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetConnectionTo
(
ch
ip
port_num
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
*
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
return
GetConnectionTo
(
ch
ip
port_num
)
;
}
Port
*
GetPort
(
P2PTransportChannel
*
ch
)
{
if
(
ch
-
>
ports
(
)
.
empty
(
)
)
{
return
nullptr
;
}
return
static_cast
<
Port
*
>
(
ch
-
>
ports
(
)
[
0
]
)
;
}
Port
*
GetPrunedPort
(
P2PTransportChannel
*
ch
)
{
if
(
ch
-
>
pruned_ports
(
)
.
empty
(
)
)
{
return
nullptr
;
}
return
static_cast
<
Port
*
>
(
ch
-
>
pruned_ports
(
)
[
0
]
)
;
}
Connection
*
GetConnectionTo
(
P2PTransportChannel
*
ch
absl
:
:
string_view
ip
int
port_num
)
{
Port
*
port
=
GetPort
(
ch
)
;
if
(
!
port
)
{
return
nullptr
;
}
return
port
-
>
GetConnection
(
webrtc
:
:
SocketAddress
(
ip
port_num
)
)
;
}
Connection
*
FindNextPingableConnectionAndPingIt
(
P2PTransportChannel
*
ch
)
{
Connection
*
conn
=
ch
-
>
FindNextPingableConnection
(
)
;
if
(
conn
)
{
ch
-
>
MarkConnectionPinged
(
conn
)
;
}
return
conn
;
}
int
SendData
(
webrtc
:
:
IceTransportInternal
*
channel
const
char
*
data
size_t
len
int
packet_id
)
{
rtc
:
:
PacketOptions
options
;
options
.
packet_id
=
packet_id
;
return
channel
-
>
SendPacket
(
data
len
options
0
)
;
}
Connection
*
CreateConnectionWithCandidate
(
P2PTransportChannel
*
channel
webrtc
:
:
ScopedFakeClock
*
clock
absl
:
:
string_view
ip_addr
int
port
int
priority
bool
writable
)
{
channel
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
ip_addr
port
priority
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetConnectionTo
(
channel
ip_addr
port
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
*
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
Connection
*
conn
=
GetConnectionTo
(
channel
ip_addr
port
)
;
if
(
conn
&
&
writable
)
{
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
}
return
conn
;
}
void
NominateConnection
(
Connection
*
conn
uint32_t
remote_nomination
=
1U
)
{
conn
-
>
set_remote_nomination
(
remote_nomination
)
;
conn
-
>
SignalNominated
(
conn
)
;
}
void
OnNetworkRouteChanged
(
std
:
:
optional
<
rtc
:
:
NetworkRoute
>
network_route
)
{
last_network_route_
=
network_route
;
if
(
last_network_route_
)
{
last_sent_packet_id_
=
last_network_route_
-
>
last_sent_packet_id
;
}
+
+
selected_candidate_pair_switches_
;
}
void
ReceivePingOnConnection
(
Connection
*
conn
absl
:
:
string_view
remote_ufrag
int
priority
uint32_t
nomination
const
std
:
:
optional
<
std
:
:
string
>
&
piggyback_ping_id
)
{
IceMessage
msg
(
STUN_BINDING_REQUEST
)
;
msg
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
conn
-
>
local_candidate
(
)
.
username
(
)
+
"
:
"
+
std
:
:
string
(
remote_ufrag
)
)
)
;
msg
.
AddAttribute
(
std
:
:
make_unique
<
StunUInt32Attribute
>
(
STUN_ATTR_PRIORITY
priority
)
)
;
if
(
nomination
!
=
0
)
{
msg
.
AddAttribute
(
std
:
:
make_unique
<
StunUInt32Attribute
>
(
STUN_ATTR_NOMINATION
nomination
)
)
;
}
if
(
piggyback_ping_id
)
{
msg
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_GOOG_LAST_ICE_CHECK_RECEIVED
piggyback_ping_id
.
value
(
)
)
)
;
}
msg
.
AddMessageIntegrity
(
conn
-
>
local_candidate
(
)
.
password
(
)
)
;
msg
.
AddFingerprint
(
)
;
webrtc
:
:
ByteBufferWriter
buf
;
msg
.
Write
(
&
buf
)
;
conn
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
reinterpret_cast
<
const
char
*
>
(
buf
.
Data
(
)
)
buf
.
Length
(
)
webrtc
:
:
TimeMicros
(
)
)
)
;
}
void
ReceivePingOnConnection
(
Connection
*
conn
absl
:
:
string_view
remote_ufrag
int
priority
uint32_t
nomination
=
0
)
{
ReceivePingOnConnection
(
conn
remote_ufrag
priority
nomination
std
:
:
nullopt
)
;
}
void
OnReadyToSend
(
webrtc
:
:
PacketTransportInternal
*
transport
)
{
channel_ready_to_send_
=
true
;
}
void
OnChannelStateChanged
(
webrtc
:
:
IceTransportInternal
*
channel
)
{
channel_state_
=
channel
-
>
GetState
(
)
;
}
void
OnCandidatePairChanged
(
const
CandidatePairChangeEvent
&
event
)
{
last_candidate_change_event_
=
event
;
}
int
last_sent_packet_id
(
)
{
return
last_sent_packet_id_
;
}
bool
channel_ready_to_send
(
)
{
return
channel_ready_to_send_
;
}
void
reset_channel_ready_to_send
(
)
{
channel_ready_to_send_
=
false
;
}
IceTransportState
channel_state
(
)
{
return
channel_state_
;
}
int
reset_selected_candidate_pair_switches
(
)
{
int
switches
=
selected_candidate_pair_switches_
;
selected_candidate_pair_switches_
=
0
;
return
switches
;
}
bool
CandidatePairMatchesNetworkRoute
(
CandidatePairInterface
*
pair
)
{
if
(
!
pair
)
{
return
!
last_network_route_
.
has_value
(
)
;
}
else
{
return
pair
-
>
local_candidate
(
)
.
network_id
(
)
=
=
last_network_route_
-
>
local
.
network_id
(
)
&
&
pair
-
>
remote_candidate
(
)
.
network_id
(
)
=
=
last_network_route_
-
>
remote
.
network_id
(
)
;
}
}
bool
ConnectionMatchesChangeEvent
(
Connection
*
conn
absl
:
:
string_view
reason
)
{
if
(
!
conn
)
{
return
!
last_candidate_change_event_
.
has_value
(
)
;
}
else
{
const
auto
&
last_selected_pair
=
last_candidate_change_event_
-
>
selected_candidate_pair
;
return
last_selected_pair
.
local_candidate
(
)
.
IsEquivalent
(
conn
-
>
local_candidate
(
)
)
&
&
last_selected_pair
.
remote_candidate
(
)
.
IsEquivalent
(
conn
-
>
remote_candidate
(
)
)
&
&
last_candidate_change_event_
-
>
last_data_received_ms
=
=
conn
-
>
last_data_received
(
)
&
&
last_candidate_change_event_
-
>
reason
=
=
reason
;
}
}
int64_t
LastEstimatedDisconnectedTimeMs
(
)
const
{
if
(
!
last_candidate_change_event_
.
has_value
(
)
)
{
return
0
;
}
else
{
return
last_candidate_change_event_
-
>
estimated_disconnected_time_ms
;
}
}
webrtc
:
:
SocketServer
*
ss
(
)
const
{
return
vss_
.
get
(
)
;
}
webrtc
:
:
PacketSocketFactory
*
packet_socket_factory
(
)
const
{
return
packet_socket_factory_
.
get
(
)
;
}
private
:
std
:
:
unique_ptr
<
webrtc
:
:
VirtualSocketServer
>
vss_
;
std
:
:
unique_ptr
<
webrtc
:
:
PacketSocketFactory
>
packet_socket_factory_
;
webrtc
:
:
AutoSocketServerThread
thread_
;
int
selected_candidate_pair_switches_
=
0
;
int
last_sent_packet_id_
=
-
1
;
bool
channel_ready_to_send_
=
false
;
std
:
:
optional
<
CandidatePairChangeEvent
>
last_candidate_change_event_
;
IceTransportState
channel_state_
=
IceTransportState
:
:
STATE_INIT
;
std
:
:
optional
<
rtc
:
:
NetworkRoute
>
last_network_route_
;
}
;
TEST_F
(
P2PTransportChannelPingTest
TestTriggeredChecks
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
trigger
checks
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
conn1
-
>
ReceivedPing
(
)
;
EXPECT_EQ
(
conn1
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestAllConnectionsPingedSufficiently
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
ping
sufficiently
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
num_pings_sent
(
)
>
=
MIN_PINGS_AT_WEAK_PING_INTERVAL
&
&
conn2
-
>
num_pings_sent
(
)
>
=
MIN_PINGS_AT_WEAK_PING_INTERVAL
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestStunPingIntervals
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
int
RTT_RATIO
=
4
;
int
SCHEDULING_RANGE
=
200
;
int
RTT_RANGE
=
10
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
TestChannel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
1
kDefaultTimeout
clock
)
;
int64_t
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
>
=
MIN_PINGS_AT_WEAK_PING_INTERVAL
kDefaultTimeout
clock
)
;
int64_t
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
webrtc
:
:
kNumNanosecsPerMillisec
/
(
MIN_PINGS_AT_WEAK_PING_INTERVAL
-
1
)
;
EXPECT_EQ
(
ping_interval_ms
WEAK_PING_INTERVAL
)
;
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
int
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
webrtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
)
;
EXPECT_LE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_RANGE
)
;
for
(
int
i
=
0
;
i
<
RTT_RATIO
;
i
+
+
)
{
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
}
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
webrtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
ping_interval_ms
STRONG_AND_STABLE_WRITABLE_CONNECTION_PING_INTERVAL
)
;
EXPECT_LE
(
ping_interval_ms
STRONG_AND_STABLE_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_RANGE
)
;
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn
-
>
Ping
(
clock
.
TimeNanos
(
)
/
webrtc
:
:
kNumNanosecsPerMillisec
)
;
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
!
conn
-
>
stable
(
clock
.
TimeNanos
(
)
/
webrtc
:
:
kNumNanosecsPerMillisec
)
kMediumTimeout
clock
)
;
int64_t
duration_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
webrtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
duration_ms
2
*
conn
-
>
rtt
(
)
-
RTT_RANGE
)
;
EXPECT_LE
(
duration_ms
2
*
conn
-
>
rtt
(
)
+
RTT_RANGE
)
;
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
start
=
clock
.
TimeNanos
(
)
;
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
webrtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
)
;
EXPECT_LE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_RANGE
)
;
}
TEST_F
(
P2PTransportChannelPingTest
PingingStartedAsSoonAsPossible
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
TestChannel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLING
)
;
ch
.
SetIceParameters
(
kIceParams
[
0
]
)
;
ch
.
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
gathering_state
(
)
;
}
Eq
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringComplete
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
request
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunUInt32Attribute
>
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
Port
*
port
=
GetPort
(
&
ch
)
;
ASSERT_NE
(
nullptr
port
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
1
.
1
.
1
.
1
"
1
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn
=
GetConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_NE
(
nullptr
conn
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
>
0
1025
clock
)
;
EXPECT_EQ
(
0
conn
-
>
num_pings_sent
(
)
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn
-
>
num_pings_sent
(
)
;
}
Gt
(
0
)
{
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestNoTriggeredChecksWhenWritable
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
trigger
checks
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
EXPECT_EQ
(
conn1
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
ASSERT_TRUE
(
conn1
-
>
writable
(
)
)
;
conn1
-
>
ReceivedPing
(
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestFailedConnectionNotPingable
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
Do
not
ping
failed
connections
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
ch
.
FindNextPingableConnection
(
)
)
;
conn1
-
>
Prune
(
)
;
EXPECT_EQ
(
conn1
ch
.
FindNextPingableConnection
(
)
)
;
conn1
-
>
FailAndPrune
(
)
;
EXPECT_TRUE
(
nullptr
=
=
ch
.
FindNextPingableConnection
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSignalStateChanged
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
Prune
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
channel_state
(
)
;
}
Eq
(
IceTransportState
:
:
STATE_FAILED
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestAddRemoteCandidateWithVariousUfrags
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
add
candidate
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
kIceUfrag
[
2
]
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
const
webrtc
:
:
Candidate
&
candidate
=
conn1
-
>
remote_candidate
(
)
;
EXPECT_EQ
(
kIceUfrag
[
2
]
candidate
.
username
(
)
)
;
EXPECT_TRUE
(
candidate
.
password
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
FindNextPingableConnectionAndPingIt
(
&
ch
)
=
=
nullptr
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
EXPECT_EQ
(
kIceUfrag
[
2
]
candidate
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
2
]
candidate
.
password
(
)
)
;
EXPECT_EQ
(
conn1
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
kIceUfrag
[
1
]
)
)
;
webrtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
500
)
;
EXPECT_TRUE
(
GetConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
=
=
nullptr
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
3
.
3
.
3
.
3
"
3
0
kIceUfrag
[
2
]
)
)
;
Connection
*
conn3
=
nullptr
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn3
=
GetConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
webrtc
:
:
Candidate
&
new_candidate
=
conn3
-
>
remote_candidate
(
)
;
EXPECT_EQ
(
kIcePwd
[
2
]
new_candidate
.
password
(
)
)
;
EXPECT_EQ
(
1U
new_candidate
.
generation
(
)
)
;
for
(
const
RemoteCandidate
&
remote_candidate
:
ch
.
remote_candidates
(
)
)
{
EXPECT_TRUE
(
remote_candidate
.
username
(
)
=
=
kIceUfrag
[
1
]
|
|
remote_candidate
.
username
(
)
=
=
kIceUfrag
[
2
]
)
;
if
(
remote_candidate
.
username
(
)
=
=
kIceUfrag
[
1
]
)
{
EXPECT_EQ
(
kIcePwd
[
1
]
remote_candidate
.
password
(
)
)
;
}
else
if
(
remote_candidate
.
username
(
)
=
=
kIceUfrag
[
2
]
)
{
EXPECT_EQ
(
kIcePwd
[
2
]
remote_candidate
.
password
(
)
)
;
}
}
}
TEST_F
(
P2PTransportChannelPingTest
ConnectionResurrection
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
connection
resurrection
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
uint32_t
remote_priority
=
conn1
-
>
remote_candidate
(
)
.
priority
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPing
(
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
RemoveConnectionForTest
(
conn1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
IceMessage
request
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunUInt32Attribute
>
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
EXPECT_NE
(
prflx_priority
remote_priority
)
;
Port
*
port
=
GetPort
(
&
ch
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
1
.
1
.
1
.
1
"
1
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
-
>
remote_candidate
(
)
.
priority
(
)
remote_priority
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
3
.
3
.
3
.
3
"
1
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
1
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_EQ
(
conn3
-
>
remote_candidate
(
)
.
priority
(
)
prflx_priority
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestReceivingStateChange
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
EXPECT_LE
(
1000
ch
.
config
(
)
.
receiving_timeout_or_default
(
)
)
;
EXPECT_LE
(
200
ch
.
check_receiving_interval
(
)
)
;
ch
.
SetIceConfig
(
CreateIceConfig
(
500
webrtc
:
:
GATHER_ONCE
)
)
;
EXPECT_EQ
(
500
ch
.
config
(
)
.
receiving_timeout_or_default
(
)
)
;
EXPECT_EQ
(
50
ch
.
check_receiving_interval
(
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
conn1
-
>
ReceivedPing
(
)
;
conn1
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
ABC
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
ch
.
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSelectConnectionBeforeNomination
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_FALSE
(
channel_ready_to_send
(
)
)
;
int
last_packet_id
=
0
;
const
char
*
data
=
"
ABCDEFGH
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
-
1
SendData
(
&
ch
data
len
+
+
last_packet_id
)
)
;
EXPECT_EQ
(
-
1
last_sent_packet_id
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
EXPECT_TRUE
(
ConnectionMatchesChangeEvent
(
conn1
"
remote
candidate
generation
maybe
changed
"
)
)
;
EXPECT_EQ
(
len
SendData
(
&
ch
data
len
+
+
last_packet_id
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
10
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
EXPECT_TRUE
(
ConnectionMatchesChangeEvent
(
conn2
"
candidate
pair
state
changed
"
)
)
;
EXPECT_TRUE
(
channel_ready_to_send
(
)
)
;
EXPECT_EQ
(
last_packet_id
last_sent_packet_id
(
)
)
;
EXPECT_EQ
(
len
SendData
(
&
ch
data
len
+
+
last_packet_id
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
3
.
3
.
3
.
3
"
3
1
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
NominateConnection
(
conn3
)
;
ASSERT_EQ
(
conn3
ch
.
selected_connection
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn3
)
)
;
EXPECT_TRUE
(
ConnectionMatchesChangeEvent
(
conn3
"
nomination
on
the
controlled
side
"
)
)
;
EXPECT_EQ
(
last_packet_id
last_sent_packet_id
(
)
)
;
EXPECT_TRUE
(
channel_ready_to_send
(
)
)
;
EXPECT_EQ
(
len
SendData
(
&
ch
data
len
+
+
last_packet_id
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
4
.
4
.
4
.
4
"
4
100
)
)
;
Connection
*
conn4
=
WaitForConnectionTo
(
&
ch
"
4
.
4
.
4
.
4
"
4
)
;
ASSERT_TRUE
(
conn4
!
=
nullptr
)
;
EXPECT_EQ
(
conn3
ch
.
selected_connection
(
)
)
;
NominateConnection
(
conn4
)
;
EXPECT_EQ
(
conn3
ch
.
selected_connection
(
)
)
;
reset_channel_ready_to_send
(
)
;
conn4
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn4
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn4
)
)
;
EXPECT_TRUE
(
ConnectionMatchesChangeEvent
(
conn4
"
candidate
pair
state
changed
"
)
)
;
EXPECT_EQ
(
last_packet_id
last_sent_packet_id
(
)
)
;
EXPECT_TRUE
(
channel_ready_to_send
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestPingOnNomination
)
{
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
send_ping_on_nomination_ice_controlled
:
true
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
10
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
const
int
before
=
conn1
-
>
num_pings_sent
(
)
;
NominateConnection
(
conn1
)
;
ASSERT_EQ
(
conn1
ch
.
selected_connection
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
EXPECT_EQ
(
conn1
-
>
num_pings_sent
(
)
before
+
1
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestPingOnSwitch
)
{
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
send_ping_on_switch_ice_controlling
:
true
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLING
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
10
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
const
int
before
=
conn2
-
>
num_pings_sent
(
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
EXPECT_EQ
(
conn2
-
>
num_pings_sent
(
)
before
+
1
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestPingOnSelected
)
{
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
send_ping_on_selected_ice_controlling
:
true
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLING
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
const
int
before
=
conn1
-
>
num_pings_sent
(
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
EXPECT_EQ
(
conn1
-
>
num_pings_sent
(
)
before
+
1
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSelectConnectionFromUnknownAddress
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
IceMessage
request
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunUInt32Attribute
>
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
TestUDPPort
*
port
=
static_cast
<
TestUDPPort
*
>
(
GetPort
(
&
ch
)
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
1
.
1
.
1
.
1
"
1
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
-
>
stats
(
)
.
sent_ping_responses
1u
)
;
EXPECT_NE
(
conn1
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
ch
.
selected_connection
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
NominateConnection
(
conn2
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
3
.
3
.
3
.
3
"
3
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_EQ
(
conn3
-
>
stats
(
)
.
sent_ping_responses
1u
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USE_CANDIDATE
)
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
4
.
4
.
4
.
4
"
4
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn4
=
WaitForConnectionTo
(
&
ch
"
4
.
4
.
4
.
4
"
4
)
;
ASSERT_TRUE
(
conn4
!
=
nullptr
)
;
EXPECT_EQ
(
conn4
-
>
stats
(
)
.
sent_ping_responses
1u
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn4
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn4
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
5
.
5
.
5
.
5
"
5
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
2
]
false
)
;
Connection
*
conn5
=
WaitForConnectionTo
(
&
ch
"
5
.
5
.
5
.
5
"
5
)
;
ASSERT_TRUE
(
conn5
!
=
nullptr
)
;
EXPECT_EQ
(
conn5
-
>
stats
(
)
.
sent_ping_responses
1u
)
;
EXPECT_EQ
(
kIcePwd
[
2
]
conn5
-
>
remote_candidate
(
)
.
password
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSelectConnectionBasedOnMediaReceived
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
10
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn2
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
ABC
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
IceMessage
request
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunUInt32Attribute
>
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
request
.
AddAttribute
(
std
:
:
make_unique
<
StunByteStringAttribute
>
(
STUN_ATTR_USE_CANDIDATE
)
)
;
Port
*
port
=
GetPort
(
&
ch
)
;
port
-
>
SignalUnknownAddress
(
port
webrtc
:
:
SocketAddress
(
"
3
.
3
.
3
.
3
"
3
)
webrtc
:
:
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_NE
(
conn3
ch
.
selected_connection
(
)
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn3
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
ReceivedPing
(
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn2
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
XYZ
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn3
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentDataReceivingTakesHigherPrecedenceThanPriority
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
SwitchSelectedConnection
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn2
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
XYZ
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
conn1
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
ABC
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn2
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
ABC
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentNominationTakesHigherPrecedenceThanDataReceiving
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
SwitchSelectedConnection
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn1
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
XYZ
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
NominateConnection
(
conn2
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
NominateConnection
(
conn1
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentSelectsConnectionWithHigherNomination
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
reset_selected_candidate_pair_switches
(
)
;
NominateConnection
(
conn2
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
NominateConnection
(
conn1
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn1
ch
.
selected_connection
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
NominateConnection
(
conn2
2U
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
SIMULATED_WAIT
(
false
100
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestEstimatedDisconnectedTime
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
EXPECT_EQ
(
LastEstimatedDisconnectedTimeMs
(
)
0
)
;
int
nomination
=
1
;
{
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
conn1
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
XYZ
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
2
)
)
;
NominateConnection
(
conn2
nomination
+
+
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
EXPECT_EQ
(
LastEstimatedDisconnectedTimeMs
(
)
2000
)
;
}
{
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
conn2
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
XYZ
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
2
)
)
;
ReceivePingOnConnection
(
conn2
kIceUfrag
[
1
]
1
nomination
+
+
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
500
)
)
;
ReceivePingOnConnection
(
conn1
kIceUfrag
[
1
]
1
nomination
+
+
)
;
EXPECT_EQ
(
conn1
ch
.
selected_connection
(
)
)
;
EXPECT_EQ
(
LastEstimatedDisconnectedTimeMs
(
)
500
)
;
}
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentIgnoresSmallerNomination
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
10
false
)
;
ReceivePingOnConnection
(
conn
kIceUfrag
[
1
]
1
2U
)
;
EXPECT_EQ
(
2U
conn
-
>
remote_nomination
(
)
)
;
ReceivePingOnConnection
(
conn
kIceUfrag
[
1
]
1
1U
)
;
EXPECT_EQ
(
2U
conn
-
>
remote_nomination
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentWriteStateTakesHigherPrecedenceThanNomination
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
SwitchSelectedConnection
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
10
false
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
2
.
2
.
2
.
2
"
2
9
false
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
NominateConnection
(
conn1
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
reset_selected_candidate_pair_switches
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn2
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
reset_selected_candidate_pair_switches
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CandidatePairMatchesNetworkRoute
(
conn1
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestAddRemoteCandidateWithAddressReuse
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
candidate
reuse
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
const
std
:
:
string
host_address
=
"
1
.
1
.
1
.
1
"
;
const
int
port_num
=
1
;
webrtc
:
:
Candidate
candidate
=
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
host_address
port_num
1
kIceUfrag
[
1
]
)
;
ch
.
AddRemoteCandidate
(
candidate
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
host_address
port_num
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
0u
conn1
-
>
remote_candidate
(
)
.
generation
(
)
)
;
ch
.
AddRemoteCandidate
(
candidate
)
;
Connection
*
conn2
=
GetConnectionTo
(
&
ch
host_address
port_num
)
;
EXPECT_EQ
(
conn1
conn2
)
;
candidate
.
set_username
(
kIceUfrag
[
2
]
)
;
ch
.
AddRemoteCandidate
(
candidate
)
;
conn2
=
GetConnectionTo
(
&
ch
host_address
port_num
)
;
EXPECT_NE
(
conn1
conn2
)
;
EXPECT_EQ
(
kIceUfrag
[
2
]
conn2
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
1u
conn2
-
>
remote_candidate
(
)
.
generation
(
)
)
;
EXPECT_EQ
(
0
conn2
-
>
last_ping_received
(
)
)
;
ReceivePingOnConnection
(
conn2
kIceUfrag
[
2
]
1
)
;
EXPECT_GT
(
conn2
-
>
last_ping_received
(
)
0
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestDontPruneWhenWeak
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
10
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
NominateConnection
(
conn2
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
pruned
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
SetIceConfig
(
CreateIceConfig
(
500
webrtc
:
:
GATHER_ONCE
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
conn2
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
3
.
3
.
3
.
3
"
3
1
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
&
clock
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
SIMULATED_WAIT
(
conn3
-
>
pruned
(
)
kShortTimeout
clock
)
;
EXPECT_FALSE
(
conn3
-
>
pruned
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestDontPruneHighPriorityConnections
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
1
.
1
.
1
.
1
"
1
100
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
&
ch
&
clock
"
2
.
2
.
2
.
2
"
2
200
false
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
NominateConnection
(
conn1
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn1
-
>
OnReadPacket
(
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
"
XYZ
"
3
webrtc
:
:
TimeMicros
(
)
)
)
;
SIMULATED_WAIT
(
conn2
-
>
pruned
(
)
100
clock
)
;
EXPECT_FALSE
(
conn2
-
>
pruned
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestGetState
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
EXPECT_EQ
(
webrtc
:
:
IceTransportState
:
:
kNew
ch
.
GetIceTransportState
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
EXPECT_EQ
(
webrtc
:
:
IceTransportState
:
:
kNew
ch
.
GetIceTransportState
(
)
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_INIT
ch
.
GetState
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
1
)
)
;
ASSERT_GT
(
ch
.
connections
(
)
.
size
(
)
0u
)
;
EXPECT_EQ
(
webrtc
:
:
IceTransportState
:
:
kChecking
ch
.
GetIceTransportState
(
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_CONNECTING
ch
.
GetState
(
)
)
;
EXPECT_EQ
(
webrtc
:
:
IceTransportState
:
:
kChecking
ch
.
GetIceTransportState
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
pruned
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_COMPLETED
ch
.
GetState
(
)
)
;
EXPECT_EQ
(
webrtc
:
:
IceTransportState
:
:
kConnected
ch
.
GetIceTransportState
(
)
)
;
conn1
-
>
Prune
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
GetState
(
)
;
}
Eq
(
IceTransportState
:
:
STATE_FAILED
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
webrtc
:
:
IceTransportState
:
:
kFailed
ch
.
GetIceTransportState
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestConnectionPrunedAgain
)
{
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
config
.
receiving_switching_delay
=
800
;
ch
.
SetIceConfig
(
config
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
conn2
-
>
active
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
IceCandidatePairState
:
:
WAITING
conn2
-
>
state
(
)
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_COMPLETED
ch
.
GetState
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
conn1
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
state
(
)
;
}
Eq
(
IceCandidatePairState
:
:
IN_PROGRESS
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_CONNECTING
ch
.
GetState
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
conn2
-
>
active
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_COMPLETED
ch
.
GetState
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestDeleteConnectionsIfAllWriteTimedout
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPing
(
)
;
conn1
-
>
Prune
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
empty
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPing
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
3
.
3
.
3
.
3
"
3
2
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
&
clock
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
conn3
-
>
ReceivedPing
(
)
;
conn2
-
>
Prune
(
)
;
conn3
-
>
Prune
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
empty
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kShortTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestStopPortAllocatorSessions
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
CreateIceConfig
(
2000
webrtc
:
:
GATHER_ONCE
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
!
ch
.
allocator_session
(
)
-
>
IsGettingPorts
(
)
)
;
ch
.
SetIceParameters
(
kIceParams
[
1
]
)
;
ch
.
MaybeStartGathering
(
)
;
conn1
-
>
Prune
(
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
ch
.
allocator_session
(
)
-
>
IsGettingPorts
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
100
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
!
ch
.
allocator_session
(
)
-
>
IsGettingPorts
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestIceRoleUpdatedOnRemovedPort
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
ICE_CANDIDATE_COMPONENT_DEFAULT
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ch
.
SetIceConfig
(
config
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
std
:
:
vector
<
webrtc
:
:
PortInterface
*
>
ports
(
1
conn
-
>
PortForTest
(
)
)
;
ch
.
allocator_session
(
)
-
>
SignalPortsPruned
(
ch
.
allocator_session
(
)
ports
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
EXPECT_EQ
(
ICEROLE_CONTROLLED
conn
-
>
PortForTest
(
)
-
>
GetIceRole
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestIceRoleUpdatedOnPortAfterIceRestart
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
ICE_CANDIDATE_COMPONENT_DEFAULT
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
ch
.
SetIceParameters
(
kIceParams
[
1
]
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
EXPECT_EQ
(
ICEROLE_CONTROLLED
conn
-
>
PortForTest
(
)
-
>
GetIceRole
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestPortDestroyedAfterTimeoutAndPruned
)
{
webrtc
:
:
ScopedFakeClock
fake_clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
ICE_CANDIDATE_COMPONENT_DEFAULT
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
for
(
int
second
=
0
;
second
<
120
;
+
+
second
)
{
fake_clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
}
EXPECT_EQ
(
nullptr
GetConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
)
;
webrtc
:
:
PortInterface
*
port
=
GetPort
(
&
ch
)
;
ASSERT_NE
(
nullptr
port
)
;
ch
.
allocator_session
(
)
-
>
PruneAllPorts
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetPort
(
&
ch
)
;
}
Eq
(
nullptr
)
{
.
clock
=
&
fake_clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetPrunedPort
(
&
ch
)
;
}
Eq
(
nullptr
)
{
.
clock
=
&
fake_clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestMaxOutstandingPingsFieldTrial
)
{
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
max_outstanding_pings
:
3
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
max
"
1
&
pa
&
env
.
field_trials
(
)
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
num_pings_sent
(
)
=
=
3
&
&
conn2
-
>
num_pings_sent
(
)
=
=
3
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
nullptr
ch
.
FindNextPingableConnection
(
)
)
;
}
class
P2PTransportChannelMostLikelyToWorkFirstTest
:
public
P2PTransportChannelPingTest
{
public
:
P2PTransportChannelMostLikelyToWorkFirstTest
(
)
:
turn_server_
(
webrtc
:
:
Thread
:
:
Current
(
)
ss
(
)
kTurnUdpIntAddr
kTurnUdpExtAddr
)
{
network_manager_
.
AddInterface
(
kPublicAddrs
[
0
]
)
;
}
BasicPortAllocator
&
CreatePortAllocator
(
const
Environment
&
env
)
{
port_allocator_
=
CreateBasicPortAllocator
(
env
&
network_manager_
packet_socket_factory
(
)
ServerAddresses
(
)
kTurnUdpIntAddr
webrtc
:
:
SocketAddress
(
)
)
;
port_allocator_
-
>
set_flags
(
port_allocator_
-
>
flags
(
)
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
)
;
port_allocator_
-
>
set_step_delay
(
webrtc
:
:
kMinimumStepDelay
)
;
return
*
port_allocator_
;
}
P2PTransportChannel
&
StartTransportChannel
(
const
Environment
&
env
bool
prioritize_most_likely_to_work
int
stable_writable_connection_ping_interval
)
{
channel_
=
std
:
:
make_unique
<
P2PTransportChannel
>
(
"
checks
"
1
port_allocator_
.
get
(
)
&
env
.
field_trials
(
)
)
;
webrtc
:
:
IceConfig
config
=
channel_
-
>
config
(
)
;
config
.
prioritize_most_likely_candidate_pairs
=
prioritize_most_likely_to_work
;
config
.
stable_writable_connection_ping_interval
=
stable_writable_connection_ping_interval
;
channel_
-
>
SetIceConfig
(
config
)
;
PrepareChannel
(
channel_
.
get
(
)
)
;
channel_
-
>
MaybeStartGathering
(
)
;
return
*
channel_
;
}
webrtc
:
:
TestTurnServer
*
turn_server
(
)
{
return
&
turn_server_
;
}
void
VerifyNextPingableConnection
(
IceCandidateType
local_candidate_type
IceCandidateType
remote_candidate_type
absl
:
:
string_view
relay_protocol_type
=
webrtc
:
:
UDP_PROTOCOL_NAME
)
{
Connection
*
conn
=
FindNextPingableConnectionAndPingIt
(
channel_
.
get
(
)
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
EXPECT_EQ
(
conn
-
>
local_candidate
(
)
.
type
(
)
local_candidate_type
)
;
if
(
conn
-
>
local_candidate
(
)
.
is_relay
(
)
)
{
EXPECT_EQ
(
conn
-
>
local_candidate
(
)
.
relay_protocol
(
)
relay_protocol_type
)
;
}
EXPECT_EQ
(
conn
-
>
remote_candidate
(
)
.
type
(
)
remote_candidate_type
)
;
}
private
:
std
:
:
unique_ptr
<
BasicPortAllocator
>
port_allocator_
;
webrtc
:
:
FakeNetworkManager
network_manager_
;
webrtc
:
:
TestTurnServer
turn_server_
;
std
:
:
unique_ptr
<
P2PTransportChannel
>
channel_
;
}
;
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestRelayRelayFirstWhenNothingPingedYet
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
const
int
max_strong_interval
=
500
;
CreatePortAllocator
(
env
)
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
env
true
max_strong_interval
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
ports
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
IceCandidateType
:
:
kHost
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
IceCandidateType
:
:
kRelay
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
4
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
Connection
*
conn
=
FindNextPingableConnectionAndPingIt
(
&
ch
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
EXPECT_TRUE
(
conn
-
>
local_candidate
(
)
.
is_relay
(
)
)
;
EXPECT_TRUE
(
conn
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_TRUE
(
conn2
-
>
local_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
conn2
-
>
remote_candidate
(
)
.
is_local
(
)
)
;
conn2
-
>
ReceivedPing
(
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_TRUE
(
conn3
-
>
local_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
conn3
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
ASSERT_TRUE
(
conn3
-
>
writable
(
)
)
;
conn3
-
>
ReceivedPing
(
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestRelayRelayFirstWhenEverythingPinged
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocator
(
env
)
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
env
true
500
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
ports
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
IceCandidateType
:
:
kHost
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
IceCandidateType
:
:
kRelay
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kHost
IceCandidateType
:
:
kHost
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kHost
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
4
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kRelay
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kHost
IceCandidateType
:
:
kRelay
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kRelay
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestNoStarvationOnNonRelayConnection
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocator
(
env
)
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
env
true
500
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
ports
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
IceCandidateType
:
:
kHost
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
IceCandidateType
:
:
kRelay
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kRelay
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kHost
IceCandidateType
:
:
kRelay
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
4
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kHost
IceCandidateType
:
:
kHost
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kHost
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kRelay
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestSkipRelayToNonRelayConnectionsFieldTrial
)
{
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
skip_relay_to_non_relay_connections
:
true
/
"
)
)
;
CreatePortAllocator
(
env
)
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
env
true
500
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
ports
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
IceCandidateType
:
:
kHost
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
IceCandidateType
:
:
kRelay
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
2
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestTcpTurn
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
turn_server
(
)
-
>
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
webrtc
:
:
RelayServerConfig
config
;
config
.
credentials
=
kRelayCredentials
;
config
.
ports
.
push_back
(
ProtocolAddress
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
)
;
CreatePortAllocator
(
env
)
.
AddTurnServerForTesting
(
config
)
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
env
true
500
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
ports
(
)
.
size
(
)
;
}
Eq
(
3
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
IceCandidateType
:
:
kHost
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
IceCandidateType
:
:
kRelay
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
2
]
-
>
Type
(
)
IceCandidateType
:
:
kRelay
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
connections
(
)
.
size
(
)
;
}
Eq
(
3
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kRelay
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kRelay
IceCandidateType
:
:
kRelay
webrtc
:
:
TCP_PROTOCOL_NAME
)
;
VerifyNextPingableConnection
(
IceCandidateType
:
:
kHost
IceCandidateType
:
:
kRelay
)
;
}
TEST
(
P2PTransportChannelResolverTest
HostnameCandidateIsResolved
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ResolverFactoryFixture
resolver_fixture
;
std
:
:
unique_ptr
<
webrtc
:
:
SocketServer
>
socket_server
=
webrtc
:
:
CreateDefaultSocketServer
(
)
;
webrtc
:
:
AutoSocketServerThread
main_thread
(
socket_server
.
get
(
)
)
;
FakePortAllocator
allocator
(
env
socket_server
.
get
(
)
)
;
webrtc
:
:
IceTransportInit
init
;
init
.
set_port_allocator
(
&
allocator
)
;
init
.
set_async_dns_resolver_factory
(
&
resolver_fixture
)
;
init
.
set_field_trials
(
&
env
.
field_trials
(
)
)
;
auto
channel
=
P2PTransportChannel
:
:
Create
(
"
tn
"
0
std
:
:
move
(
init
)
)
;
webrtc
:
:
Candidate
hostname_candidate
;
SocketAddress
hostname_address
(
"
fake
.
test
"
1000
)
;
hostname_candidate
.
set_address
(
hostname_address
)
;
channel
-
>
AddRemoteCandidate
(
hostname_candidate
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
channel
-
>
remote_candidates
(
)
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
RemoteCandidate
&
candidate
=
channel
-
>
remote_candidates
(
)
[
0
]
;
EXPECT_FALSE
(
candidate
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignalingWithMdnsName
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
GetEndpoint
(
0
)
-
>
network_manager_
.
set_mdns_responder
(
std
:
:
make_unique
<
webrtc
:
:
FakeMdnsResponder
>
(
webrtc
:
:
Thread
:
:
Current
(
)
)
)
;
ResolverFactoryFixture
resolver_fixture
;
GetEndpoint
(
1
)
-
>
async_dns_resolver_factory_
=
&
resolver_fixture
;
CreateChannels
(
env
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
auto
&
local_candidate
=
GetEndpoint
(
0
)
-
>
saved_candidates_
[
0
]
.
candidate
;
EXPECT_TRUE
(
local_candidate
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
const
auto
local_address
=
webrtc
:
:
SocketAddress
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
local_candidate
.
address
(
)
.
port
(
)
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
Connection
*
selected_connection
=
nullptr
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
selected_connection
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
selected_connection
-
>
remote_candidate
(
)
.
is_prflx
(
)
)
;
EXPECT_EQ
(
kIceUfrag
[
0
]
selected_connection
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
0
]
selected_connection
-
>
remote_candidate
(
)
.
password
(
)
)
;
resolver_fixture
.
SetAddressToReturn
(
local_address
)
;
ResumeCandidates
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
selected_connection
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateDuringResolvingHostCandidateWithMdnsName
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ResolverFactoryFixture
resolver_fixture
;
resolver_fixture
.
DelayResolution
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
GetEndpoint
(
0
)
-
>
network_manager_
.
set_mdns_responder
(
std
:
:
make_unique
<
webrtc
:
:
FakeMdnsResponder
>
(
webrtc
:
:
Thread
:
:
Current
(
)
)
)
;
GetEndpoint
(
1
)
-
>
async_dns_resolver_factory_
=
&
resolver_fixture
;
CreateChannels
(
env
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
auto
&
local_candidate
=
GetEndpoint
(
0
)
-
>
saved_candidates_
[
0
]
.
candidate
;
ASSERT_TRUE
(
local_candidate
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
const
auto
local_address
=
webrtc
:
:
SocketAddress
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
local_candidate
.
address
(
)
.
port
(
)
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
resolver_fixture
.
SetAddressToReturn
(
local_address
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_prflx
(
)
)
;
resolver_fixture
.
FireDelayedResolution
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
1u
ep2_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
CanConnectWithHostCandidateWithMdnsName
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ResolverFactoryFixture
resolver_fixture
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
GetEndpoint
(
0
)
-
>
network_manager_
.
set_mdns_responder
(
std
:
:
make_unique
<
webrtc
:
:
FakeMdnsResponder
>
(
webrtc
:
:
Thread
:
:
Current
(
)
)
)
;
GetEndpoint
(
1
)
-
>
async_dns_resolver_factory_
=
&
resolver_fixture
;
CreateChannels
(
env
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
auto
&
local_candidate_ep1
=
GetEndpoint
(
0
)
-
>
saved_candidates_
[
0
]
.
candidate
;
EXPECT_TRUE
(
local_candidate_ep1
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
webrtc
:
:
SocketAddress
resolved_address_ep1
(
local_candidate_ep1
.
address
(
)
)
;
resolved_address_ep1
.
SetResolvedIP
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
)
;
resolver_fixture
.
SetAddressToReturn
(
resolved_address_ep1
)
;
ResumeCandidates
(
0
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_prflx
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
CandidatesSanitizedInStatsWhenMdnsObfuscationEnabled
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ResolverFactoryFixture
resolver_fixture
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
GetEndpoint
(
0
)
-
>
network_manager_
.
set_mdns_responder
(
std
:
:
make_unique
<
webrtc
:
:
FakeMdnsResponder
>
(
webrtc
:
:
Thread
:
:
Current
(
)
)
)
;
GetEndpoint
(
1
)
-
>
async_dns_resolver_factory_
=
&
resolver_fixture
;
CreateChannels
(
env
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
3u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
1
)
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
for
(
const
auto
&
candidates_data
:
GetEndpoint
(
0
)
-
>
saved_candidates_
)
{
const
auto
&
local_candidate_ep1
=
candidates_data
.
candidate
;
if
(
local_candidate_ep1
.
is_local
(
)
)
{
webrtc
:
:
SocketAddress
resolved_address_ep1
(
local_candidate_ep1
.
address
(
)
)
;
resolved_address_ep1
.
SetResolvedIP
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
)
;
resolver_fixture
.
SetAddressToReturn
(
resolved_address_ep1
)
;
break
;
}
}
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
gathering_state
(
)
;
}
Eq
(
webrtc
:
:
kIceGatheringComplete
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
connections
(
)
.
size
(
)
;
}
Eq
(
3u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
connections
(
)
.
size
(
)
;
}
Eq
(
3u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats1
;
webrtc
:
:
IceTransportStats
ice_transport_stats2
;
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats1
)
;
ep2_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats2
)
;
EXPECT_EQ
(
3u
ice_transport_stats1
.
connection_infos
.
size
(
)
)
;
EXPECT_EQ
(
3u
ice_transport_stats1
.
candidate_stats_list
.
size
(
)
)
;
EXPECT_EQ
(
3u
ice_transport_stats2
.
connection_infos
.
size
(
)
)
;
for
(
const
auto
&
connection_info
:
ice_transport_stats1
.
connection_infos
)
{
const
auto
&
local_candidate
=
connection_info
.
local_candidate
;
if
(
local_candidate
.
is_local
(
)
)
{
EXPECT_TRUE
(
local_candidate
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
}
else
if
(
local_candidate
.
is_stun
(
)
)
{
EXPECT_TRUE
(
local_candidate
.
related_address
(
)
.
IsAnyIP
(
)
)
;
}
else
if
(
local_candidate
.
is_relay
(
)
)
{
EXPECT_EQ
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
local_candidate
.
related_address
(
)
.
ipaddr
(
)
)
;
}
else
{
FAIL
(
)
;
}
}
for
(
const
auto
&
connection_info
:
ice_transport_stats2
.
connection_infos
)
{
const
auto
&
remote_candidate
=
connection_info
.
remote_candidate
;
if
(
remote_candidate
.
is_local
(
)
)
{
EXPECT_TRUE
(
remote_candidate
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
}
else
if
(
remote_candidate
.
is_stun
(
)
)
{
EXPECT_TRUE
(
remote_candidate
.
related_address
(
)
.
IsAnyIP
(
)
)
;
}
else
if
(
remote_candidate
.
is_relay
(
)
)
{
EXPECT_EQ
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
remote_candidate
.
related_address
(
)
.
ipaddr
(
)
)
;
}
else
{
FAIL
(
)
;
}
}
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
ConnectingIncreasesSelectedCandidatePairChanges
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
0u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
1u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
DisconnectedIncreasesSelectedCandidatePairChanges
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
0u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
1u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
for
(
Connection
*
con
:
ep1_ch1
(
)
-
>
connections
(
)
)
{
con
-
>
Prune
(
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Eq
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
2u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
NewSelectionIncreasesSelectedCandidatePairChanges
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
env
)
;
webrtc
:
:
IceTransportStats
ice_transport_stats
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
0u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_EQ
(
1u
ice_transport_stats
.
selected_candidate_pair_changes
)
;
const
Connection
*
selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
for
(
Connection
*
con
:
ep1_ch1
(
)
-
>
connections
(
)
)
{
if
(
con
=
=
selected_connection
)
{
con
-
>
Prune
(
)
;
}
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
ice_transport_stats
.
selected_candidate_pair_changes
>
=
2u
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
ice_transport_stats
)
)
;
EXPECT_GE
(
ice_transport_stats
.
selected_candidate_pair_changes
2u
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
SelectedCandidatePairSanitizedWhenMdnsObfuscationEnabled
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ResolverFactoryFixture
resolver_fixture
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
GetEndpoint
(
0
)
-
>
network_manager_
.
set_mdns_responder
(
std
:
:
make_unique
<
webrtc
:
:
FakeMdnsResponder
>
(
webrtc
:
:
Thread
:
:
Current
(
)
)
)
;
GetEndpoint
(
1
)
-
>
async_dns_resolver_factory_
=
&
resolver_fixture
;
CreateChannels
(
env
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
auto
&
candidates_data
=
GetEndpoint
(
0
)
-
>
saved_candidates_
[
0
]
;
const
auto
&
local_candidate_ep1
=
candidates_data
.
candidate
;
ASSERT_TRUE
(
local_candidate_ep1
.
is_local
(
)
)
;
webrtc
:
:
SocketAddress
resolved_address_ep1
(
local_candidate_ep1
.
address
(
)
)
;
resolved_address_ep1
.
SetResolvedIP
(
kPublicAddrs
[
0
]
.
ipaddr
(
)
)
;
resolver_fixture
.
SetAddressToReturn
(
resolved_address_ep1
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
auto
pair_ep1
=
ep1_ch1
(
)
-
>
GetSelectedCandidatePair
(
)
;
ASSERT_TRUE
(
pair_ep1
.
has_value
(
)
)
;
EXPECT_TRUE
(
pair_ep1
-
>
local_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
pair_ep1
-
>
local_candidate
(
)
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
const
auto
pair_ep2
=
ep2_ch1
(
)
-
>
GetSelectedCandidatePair
(
)
;
ASSERT_TRUE
(
pair_ep2
.
has_value
(
)
)
;
EXPECT_TRUE
(
pair_ep2
-
>
remote_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
pair_ep2
-
>
remote_candidate
(
)
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
NoPairOfLocalRelayCandidateWithRemoteMdnsCandidate
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
const
int
kOnlyRelayPorts
=
webrtc
:
:
PORTALLOCATOR_DISABLE_UDP
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
;
ConfigureEndpoints
(
env
OPEN
OPEN
kOnlyRelayPorts
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
=
CreateChannel
(
env
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
;
webrtc
:
:
IceConfig
config
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
gathering_state
(
)
;
}
Eq
(
webrtc
:
:
IceGatheringState
:
:
kIceGatheringComplete
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
1u
ep1_ch1
(
)
-
>
ports
(
)
.
size
(
)
)
;
webrtc
:
:
Candidate
host_candidate
=
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
0
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
host_candidate
)
;
std
:
:
vector
<
webrtc
:
:
Candidate
>
mdns_candidates
;
mdns_candidates
.
push_back
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
example
.
local
"
2
0
)
)
;
mdns_candidates
.
push_back
(
CreateUdpCandidate
(
IceCandidateType
:
:
kSrflx
"
example
.
local
"
3
0
)
)
;
mdns_candidates
.
push_back
(
CreateUdpCandidate
(
IceCandidateType
:
:
kRelay
"
example
.
local
"
4
0
)
)
;
for
(
auto
&
mdns_candidate
:
mdns_candidates
)
{
webrtc
:
:
SocketAddress
resolved_address
(
mdns_candidate
.
address
(
)
)
;
resolved_address
.
SetResolvedIP
(
0x1111
)
;
mdns_candidate
.
set_address
(
resolved_address
)
;
EXPECT_FALSE
(
mdns_candidate
.
address
(
)
.
IsUnresolvedIP
(
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
mdns_candidate
)
;
}
EXPECT_EQ
(
4u
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
)
;
ASSERT_EQ
(
1u
ep1_ch1
(
)
-
>
connections
(
)
.
size
(
)
)
;
ASSERT_NE
(
nullptr
ep1_ch1
(
)
-
>
connections
(
)
[
0
]
)
;
EXPECT_EQ
(
"
1
.
1
.
1
.
1
:
1
"
ep1_ch1
(
)
-
>
connections
(
)
[
0
]
-
>
remote_candidate
(
)
.
address
(
)
.
ToString
(
)
)
;
DestroyChannels
(
)
;
}
class
MockMdnsResponder
:
public
webrtc
:
:
MdnsResponderInterface
{
public
:
MOCK_METHOD
(
void
CreateNameForAddress
(
const
webrtc
:
:
IPAddress
&
NameCreatedCallback
)
(
override
)
)
;
MOCK_METHOD
(
void
RemoveNameForAddress
(
const
webrtc
:
:
IPAddress
&
NameRemovedCallback
)
(
override
)
)
;
}
;
TEST_F
(
P2PTransportChannelTest
SrflxCandidateCanBeGatheredBeforeMdnsCandidateToCreateConnection
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
const
auto
kOnlyLocalAndStunPorts
=
webrtc
:
:
PORTALLOCATOR_DISABLE_RELAY
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
;
ConfigureEndpoints
(
env
NAT_FULL_CONE
OPEN
kOnlyLocalAndStunPorts
kOnlyLocalAndStunPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
auto
mock_mdns_responder
=
std
:
:
make_unique
<
MockMdnsResponder
>
(
)
;
EXPECT_CALL
(
*
mock_mdns_responder
CreateNameForAddress
(
_
_
)
)
.
Times
(
1
)
.
WillOnce
(
Return
(
)
)
;
GetEndpoint
(
0
)
-
>
network_manager_
.
set_mdns_responder
(
std
:
:
move
(
mock_mdns_responder
)
)
;
CreateChannels
(
env
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_stun
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
SurfaceHostCandidateOnCandidateFilterChangeFromRelayToAll
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ice_config
.
surface_ice_candidates_on_ice_transport_type_changed
=
true
;
CreateChannels
(
env
ice_config
ice_config
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPublicAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPublicAddrs
[
1
]
kPublicAddrs
[
0
]
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPublicAddrs
[
0
]
kTurnUdpExtAddr
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPublicAddrs
[
1
]
kTurnUdpExtAddr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
SurfaceSrflxCandidateOnCandidateFilterChangeFromRelayToNoHost
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
NAT_FULL_CONE
NAT_FULL_CONE
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ice_config
.
surface_ice_candidates_on_ice_transport_type_changed
=
true
;
CreateChannels
(
env
ice_config
ice_config
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
uint32_t
kCandidateFilterNoHost
=
webrtc
:
:
CF_ALL
&
~
webrtc
:
:
CF_HOST
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
kCandidateFilterNoHost
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_stun
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
kCandidateFilterNoHost
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_stun
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_stun
(
)
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPrivateAddrs
[
0
]
kPublicAddrs
[
1
]
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPrivateAddrs
[
1
]
kPublicAddrs
[
0
]
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPrivateAddrs
[
0
]
kTurnUdpExtAddr
)
;
fw
(
)
-
>
AddRule
(
false
webrtc
:
:
FP_ANY
kPrivateAddrs
[
1
]
kTurnUdpExtAddr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
CannotSurfaceTheNewlyAllowedOnFilterChangeIfNotGatheringContinually
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_ONCE
)
;
ice_config
.
surface_ice_candidates_on_ice_transport_type_changed
=
true
;
CreateChannels
(
env
ice_config
ice_config
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
RestrictingCandidateFilterDoesNotRemoveRegatheredCandidates
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ice_config
.
surface_ice_candidates_on_ice_transport_type_changed
=
true
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
CreateChannels
(
env
ice_config
ice_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
3u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_local
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
auto
test_invariants
=
[
this
]
(
)
{
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_local
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_local
(
)
)
;
EXPECT_THAT
(
ep2_ch1
(
)
-
>
remote_candidates
(
)
SizeIs
(
3
)
)
;
}
;
test_invariants
(
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_HOST
|
webrtc
:
:
CF_REFLEXIVE
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
test_invariants
(
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_HOST
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
test_invariants
(
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_NONE
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
test_invariants
(
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
SurfaceRequiresCoordination
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
skip_relay_to_non_relay_connections
:
true
/
"
)
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
ice_config
.
surface_ice_candidates_on_ice_transport_type_changed
=
true
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
CreateChannels
(
env
ice_config
ice_config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
1u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2
-
>
saved_candidates_
.
size
(
)
;
}
Eq
(
3u
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
Ne
(
nullptr
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
false
300000
clock
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
local_candidate
(
)
.
is_relay
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
is_relay
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestInitialSelectDampening0
)
{
constexpr
int
kMargin
=
10
;
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
initial_select_dampening
:
0
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMargin
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestInitialSelectDampening
)
{
constexpr
int
kMargin
=
10
;
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
initial_select_dampening
:
100
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
SIMULATED_WAIT
(
conn1
=
=
ch
.
selected_connection
(
)
100
-
kMargin
clock
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
2
*
kMargin
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestInitialSelectDampeningPingReceived
)
{
constexpr
int
kMargin
=
10
;
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
initial_select_dampening_ping_received
:
100
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn1
-
>
ReceivedPing
(
"
id1
"
)
;
SIMULATED_WAIT
(
conn1
=
=
ch
.
selected_connection
(
)
100
-
kMargin
clock
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
2
*
kMargin
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestInitialSelectDampeningBoth
)
{
constexpr
int
kMargin
=
10
;
webrtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
"
WebRTC
-
IceFieldTrials
/
"
"
initial_select_dampening
:
100
initial_select_dampening_ping_received
:
"
"
50
/
"
)
)
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
&
env
.
field_trials
(
)
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
ch
.
config
(
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
SIMULATED_WAIT
(
conn1
=
=
ch
.
selected_connection
(
)
50
-
kMargin
clock
)
;
conn1
-
>
ReceivedPing
(
"
id1
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
.
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
2
*
kMargin
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST
(
P2PTransportChannelIceControllerTest
InjectIceController
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
std
:
:
unique_ptr
<
webrtc
:
:
SocketServer
>
socket_server
=
webrtc
:
:
CreateDefaultSocketServer
(
)
;
webrtc
:
:
AutoSocketServerThread
main_thread
(
socket_server
.
get
(
)
)
;
webrtc
:
:
MockIceControllerFactory
factory
;
FakePortAllocator
pa
(
env
socket_server
.
get
(
)
)
;
EXPECT_CALL
(
factory
RecordIceControllerCreated
(
)
)
.
Times
(
1
)
;
webrtc
:
:
IceTransportInit
init
;
init
.
set_port_allocator
(
&
pa
)
;
init
.
set_ice_controller_factory
(
&
factory
)
;
init
.
set_field_trials
(
&
env
.
field_trials
(
)
)
;
auto
dummy
=
P2PTransportChannel
:
:
Create
(
"
transport_name
"
77
std
:
:
move
(
init
)
)
;
}
TEST
(
P2PTransportChannel
InjectActiveIceController
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
std
:
:
unique_ptr
<
webrtc
:
:
SocketServer
>
socket_server
=
webrtc
:
:
CreateDefaultSocketServer
(
)
;
webrtc
:
:
AutoSocketServerThread
main_thread
(
socket_server
.
get
(
)
)
;
webrtc
:
:
MockActiveIceControllerFactory
factory
;
FakePortAllocator
pa
(
env
socket_server
.
get
(
)
)
;
EXPECT_CALL
(
factory
RecordActiveIceControllerCreated
(
)
)
.
Times
(
1
)
;
webrtc
:
:
IceTransportInit
init
;
init
.
set_port_allocator
(
&
pa
)
;
init
.
set_active_ice_controller_factory
(
&
factory
)
;
init
.
set_field_trials
(
&
env
.
field_trials
(
)
)
;
auto
dummy
=
P2PTransportChannel
:
:
Create
(
"
transport_name
"
77
std
:
:
move
(
init
)
)
;
}
class
ForgetLearnedStateController
:
public
cricket
:
:
BasicIceController
{
public
:
explicit
ForgetLearnedStateController
(
const
webrtc
:
:
IceControllerFactoryArgs
&
args
)
:
cricket
:
:
BasicIceController
(
args
)
{
}
SwitchResult
SortAndSwitchConnection
(
IceSwitchReason
reason
)
override
{
auto
result
=
cricket
:
:
BasicIceController
:
:
SortAndSwitchConnection
(
reason
)
;
if
(
forget_connnection_
)
{
result
.
connections_to_forget_state_on
.
push_back
(
forget_connnection_
)
;
forget_connnection_
=
nullptr
;
}
result
.
recheck_event
.
emplace
(
IceSwitchReason
:
:
ICE_CONTROLLER_RECHECK
100
)
;
return
result
;
}
void
ForgetThisConnectionNextTimeSortAndSwitchConnectionIsCalled
(
Connection
*
con
)
{
forget_connnection_
=
con
;
}
private
:
Connection
*
forget_connnection_
=
nullptr
;
}
;
class
ForgetLearnedStateControllerFactory
:
public
webrtc
:
:
IceControllerFactoryInterface
{
public
:
std
:
:
unique_ptr
<
cricket
:
:
IceControllerInterface
>
Create
(
const
webrtc
:
:
IceControllerFactoryArgs
&
args
)
override
{
auto
controller
=
std
:
:
make_unique
<
ForgetLearnedStateController
>
(
args
)
;
controller_
=
controller
.
get
(
)
;
return
controller
;
}
virtual
~
ForgetLearnedStateControllerFactory
(
)
=
default
;
ForgetLearnedStateController
*
controller_
;
}
;
TEST_F
(
P2PTransportChannelPingTest
TestForgetLearnedState
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ForgetLearnedStateControllerFactory
factory
;
FakePortAllocator
pa
(
env
ss
(
)
)
;
webrtc
:
:
IceTransportInit
init
;
init
.
set_port_allocator
(
&
pa
)
;
init
.
set_ice_controller_factory
(
&
factory
)
;
init
.
set_field_trials
(
&
env
.
field_trials
(
)
)
;
auto
ch
=
P2PTransportChannel
:
:
Create
(
"
ping
sufficiently
"
1
std
:
:
move
(
init
)
)
;
PrepareChannel
(
ch
.
get
(
)
)
;
ch
-
>
MaybeStartGathering
(
)
;
ch
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
ch
.
get
(
)
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
ch
.
get
(
)
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ch
-
>
selected_connection
(
)
;
}
Eq
(
conn1
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
conn2
-
>
writable
(
)
)
;
factory
.
controller_
-
>
ForgetThisConnectionNextTimeSortAndSwitchConnectionIsCalled
(
conn2
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
writable
(
)
;
}
IsFalse
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kMediumTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
P2PTransportChannelTest
DisableDnsLookupsWithTransportPolicyRelay
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_RELAY
)
;
std
:
:
unique_ptr
<
webrtc
:
:
MockAsyncDnsResolver
>
mock_async_resolver
=
std
:
:
make_unique
<
webrtc
:
:
MockAsyncDnsResolver
>
(
)
;
EXPECT_CALL
(
*
mock_async_resolver
Start
(
_
_
)
)
.
Times
(
0
)
;
webrtc
:
:
MockAsyncDnsResolverFactory
mock_async_resolver_factory
;
ON_CALL
(
mock_async_resolver_factory
Create
(
)
)
.
WillByDefault
(
[
&
mock_async_resolver
]
(
)
{
return
std
:
:
move
(
mock_async_resolver
)
;
}
)
;
ep1
-
>
async_dns_resolver_factory_
=
&
mock_async_resolver_factory
;
CreateChannels
(
env
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
hostname
.
test
"
1
100
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
DisableDnsLookupsWithTransportPolicyNone
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_NONE
)
;
std
:
:
unique_ptr
<
webrtc
:
:
MockAsyncDnsResolver
>
mock_async_resolver
=
std
:
:
make_unique
<
webrtc
:
:
MockAsyncDnsResolver
>
(
)
;
EXPECT_CALL
(
*
mock_async_resolver
Start
(
_
_
)
)
.
Times
(
0
)
;
webrtc
:
:
MockAsyncDnsResolverFactory
mock_async_resolver_factory
;
ON_CALL
(
mock_async_resolver_factory
Create
(
)
)
.
WillByDefault
(
[
&
mock_async_resolver
]
(
)
{
return
std
:
:
move
(
mock_async_resolver
)
;
}
)
;
ep1
-
>
async_dns_resolver_factory_
=
&
mock_async_resolver_factory
;
CreateChannels
(
env
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
hostname
.
test
"
1
100
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
EnableDnsLookupsWithTransportPolicyNoHost
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
&
~
webrtc
:
:
CF_HOST
)
;
std
:
:
unique_ptr
<
webrtc
:
:
MockAsyncDnsResolver
>
mock_async_resolver
=
std
:
:
make_unique
<
webrtc
:
:
MockAsyncDnsResolver
>
(
)
;
bool
lookup_started
=
false
;
EXPECT_CALL
(
*
mock_async_resolver
Start
(
_
_
)
)
.
WillOnce
(
Assign
(
&
lookup_started
true
)
)
;
webrtc
:
:
MockAsyncDnsResolverFactory
mock_async_resolver_factory
;
EXPECT_CALL
(
mock_async_resolver_factory
Create
(
)
)
.
WillOnce
(
[
&
mock_async_resolver
]
(
)
{
return
std
:
:
move
(
mock_async_resolver
)
;
}
)
;
ep1
-
>
async_dns_resolver_factory_
=
&
mock_async_resolver_factory
;
CreateChannels
(
env
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
IceCandidateType
:
:
kHost
"
hostname
.
test
"
1
100
)
)
;
EXPECT_TRUE
(
lookup_started
)
;
DestroyChannels
(
)
;
}
class
GatherAfterConnectedTest
:
public
P2PTransportChannelTest
public
WithParamInterface
<
bool
>
{
}
;
INSTANTIATE_TEST_SUITE_P
(
All
GatherAfterConnectedTest
Values
(
true
false
)
)
;
TEST_P
(
GatherAfterConnectedTest
GatherAfterConnected
)
{
const
bool
stop_gather_on_strongly_connected
=
GetParam
(
)
;
const
std
:
:
string
field_trial
=
std
:
:
string
(
"
WebRTC
-
IceFieldTrials
/
stop_gather_on_strongly_connected
:
"
)
+
(
stop_gather_on_strongly_connected
?
"
true
/
"
:
"
false
/
"
)
;
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
field_trial
)
)
;
constexpr
uint32_t
flags
=
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
;
ConfigureEndpoints
(
env
OPEN
OPEN
flags
flags
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
int
delay
=
3000
;
SetAllocationStepDelay
(
0
delay
)
;
SetAllocationStepDelay
(
1
delay
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
CreateChannels
(
env
ice_config
ice_config
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1
-
>
saved_candidates_
.
size
(
)
=
=
1u
&
&
ep2
-
>
saved_candidates_
.
size
(
)
=
=
1u
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
=
=
1
&
&
ep2_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
=
=
1
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
10
*
delay
)
)
;
if
(
stop_gather_on_strongly_connected
)
{
EXPECT_EQ
(
ep1
-
>
saved_candidates_
.
size
(
)
0u
)
;
EXPECT_EQ
(
ep2
-
>
saved_candidates_
.
size
(
)
0u
)
;
}
else
{
EXPECT_EQ
(
ep1
-
>
saved_candidates_
.
size
(
)
1u
)
;
EXPECT_EQ
(
ep2
-
>
saved_candidates_
.
size
(
)
1u
)
;
}
}
TEST_P
(
GatherAfterConnectedTest
GatherAfterConnectedMultiHomed
)
{
const
bool
stop_gather_on_strongly_connected
=
GetParam
(
)
;
const
std
:
:
string
field_trial
=
std
:
:
string
(
"
WebRTC
-
IceFieldTrials
/
stop_gather_on_strongly_connected
:
"
)
+
(
stop_gather_on_strongly_connected
?
"
true
/
"
:
"
false
/
"
)
;
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
FieldTrials
:
:
CreateNoGlobal
(
field_trial
)
)
;
constexpr
uint32_t
flags
=
webrtc
:
:
kDefaultPortAllocatorFlags
|
webrtc
:
:
PORTALLOCATOR_ENABLE_SHARED_SOCKET
|
webrtc
:
:
PORTALLOCATOR_DISABLE_STUN
|
webrtc
:
:
PORTALLOCATOR_DISABLE_TCP
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
flags
flags
)
;
auto
*
ep1
=
GetEndpoint
(
0
)
;
auto
*
ep2
=
GetEndpoint
(
1
)
;
ep1
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
ep2
-
>
allocator_
-
>
SetCandidateFilter
(
webrtc
:
:
CF_ALL
)
;
int
delay
=
3000
;
SetAllocationStepDelay
(
0
delay
)
;
SetAllocationStepDelay
(
1
delay
)
;
webrtc
:
:
IceConfig
ice_config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
CreateChannels
(
env
ice_config
ice_config
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1
-
>
saved_candidates_
.
size
(
)
=
=
2u
&
&
ep2
-
>
saved_candidates_
.
size
(
)
=
=
1u
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
=
=
1
&
&
ep2_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
=
=
2
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
10
*
delay
)
)
;
if
(
stop_gather_on_strongly_connected
)
{
EXPECT_EQ
(
ep1
-
>
saved_candidates_
.
size
(
)
0u
)
;
EXPECT_EQ
(
ep2
-
>
saved_candidates_
.
size
(
)
0u
)
;
}
else
{
EXPECT_EQ
(
ep1
-
>
saved_candidates_
.
size
(
)
2u
)
;
EXPECT_EQ
(
ep2
-
>
saved_candidates_
.
size
(
)
1u
)
;
}
}
TEST_F
(
P2PTransportChannelTest
TestIceNoOldCandidatesAfterIceRestart
)
{
webrtc
:
:
ScopedFakeClock
clock
;
const
Environment
env
=
CreateEnvironment
(
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
ConfigureEndpoints
(
env
OPEN
OPEN
webrtc
:
:
kDefaultPortAllocatorFlags
webrtc
:
:
kDefaultPortAllocatorFlags
)
;
webrtc
:
:
IceConfig
config
=
CreateIceConfig
(
1000
webrtc
:
:
GATHER_CONTINUALLY
)
;
CreateChannels
(
env
config
config
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
PauseCandidates
(
0
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
GetEndpoint
(
0
)
-
>
saved_candidates_
.
size
(
)
;
}
Gt
(
0
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
for
(
const
auto
&
cd
:
GetEndpoint
(
0
)
-
>
saved_candidates_
)
{
EXPECT_EQ
(
cd
.
candidate
.
username
(
)
kIceUfrag
[
3
]
)
;
}
DestroyChannels
(
)
;
}
class
P2PTransportChannelTestDtlsInStun
:
public
P2PTransportChannelTestBase
{
public
:
P2PTransportChannelTestDtlsInStun
(
)
:
P2PTransportChannelTestBase
(
)
{
std
:
:
vector
<
uint8_t
>
dtls_server_hello
=
{
0x16
0xfe
0xff
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x0c
0x0e
0x00
0x00
0x00
0x00
0x04
0x00
0x00
0x00
0x00
0x00
0x00
}
;
pending_packet_
.
SetData
(
dtls_server_hello
)
;
}
protected
:
void
Run
(
bool
ep1_support
bool
ep2_support
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
CreatePortAllocators
(
env
)
;
webrtc
:
:
IceConfig
ep1_config
;
ep1_config
.
dtls_handshake_in_stun
=
ep1_support
;
webrtc
:
:
IceConfig
ep2_config
;
ep2_config
.
dtls_handshake_in_stun
=
ep2_support
;
CreateChannels
(
env
ep1_config
ep2_config
)
;
if
(
ep1_support
)
{
ep1_ch1
(
)
-
>
SetDtlsStunPiggybackCallbacks
(
DtlsStunPiggybackCallbacks
(
[
&
]
(
auto
type
)
{
return
data_to_piggyback_func
(
type
)
;
}
[
&
]
(
auto
data
auto
ack
)
{
piggyback_data_received
(
data
ack
)
;
}
)
)
;
}
if
(
ep2_support
)
{
ep2_ch1
(
)
-
>
SetDtlsStunPiggybackCallbacks
(
DtlsStunPiggybackCallbacks
(
[
&
]
(
auto
type
)
{
return
data_to_piggyback_func
(
type
)
;
}
[
&
]
(
auto
data
auto
ack
)
{
piggyback_data_received
(
data
ack
)
;
}
)
)
;
}
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnected
(
ep1_ch1
(
)
ep2_ch1
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kDefaultTimeout
)
.
clock
=
&
clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
DestroyChannels
(
)
;
}
std
:
:
pair
<
std
:
:
optional
<
absl
:
:
string_view
>
std
:
:
optional
<
absl
:
:
string_view
>
>
data_to_piggyback_func
(
StunMessageType
type
)
{
return
make_pair
(
absl
:
:
string_view
(
pending_packet_
)
std
:
:
nullopt
)
;
}
void
piggyback_data_received
(
const
StunByteStringAttribute
*
data
const
StunByteStringAttribute
*
ack
)
{
}
webrtc
:
:
ScopedFakeClock
clock_
;
rtc
:
:
Buffer
pending_packet_
;
}
;
TEST_F
(
P2PTransportChannelTestDtlsInStun
NotSupportedByEither
)
{
Run
(
false
false
)
;
}
TEST_F
(
P2PTransportChannelTestDtlsInStun
SupportedByClient
)
{
Run
(
true
false
)
;
}
TEST_F
(
P2PTransportChannelTestDtlsInStun
SupportedByServer
)
{
Run
(
false
true
)
;
}
TEST_F
(
P2PTransportChannelTestDtlsInStun
SupportedByBoth
)
{
Run
(
true
true
)
;
}
}
