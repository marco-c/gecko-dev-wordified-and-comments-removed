#
ifndef
P2P_BASE_TRANSPORT_DESCRIPTION_H_
#
define
P2P_BASE_TRANSPORT_DESCRIPTION_H_
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
rtc_base
/
ssl_fingerprint
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
webrtc
{
enum
IceRole
{
ICEROLE_CONTROLLING
=
0
ICEROLE_CONTROLLED
ICEROLE_UNKNOWN
}
;
enum
IceMode
{
ICEMODE_FULL
ICEMODE_LITE
}
;
enum
ConnectionRole
{
CONNECTIONROLE_NONE
=
0
CONNECTIONROLE_ACTIVE
CONNECTIONROLE_PASSIVE
CONNECTIONROLE_ACTPASS
CONNECTIONROLE_HOLDCONN
}
;
struct
IceParameters
{
static
RTC_EXPORT
RTCErrorOr
<
IceParameters
>
Parse
(
absl
:
:
string_view
raw_ufrag
absl
:
:
string_view
raw_pwd
)
;
std
:
:
string
ufrag
;
std
:
:
string
pwd
;
bool
renomination
=
false
;
IceParameters
(
)
=
default
;
IceParameters
(
absl
:
:
string_view
ice_ufrag
absl
:
:
string_view
ice_pwd
bool
ice_renomination
)
:
ufrag
(
ice_ufrag
)
pwd
(
ice_pwd
)
renomination
(
ice_renomination
)
{
}
bool
operator
=
=
(
const
IceParameters
&
other
)
const
{
return
ufrag
=
=
other
.
ufrag
&
&
pwd
=
=
other
.
pwd
&
&
renomination
=
=
other
.
renomination
;
}
bool
operator
!
=
(
const
IceParameters
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
RTCError
Validate
(
)
const
;
}
;
constexpr
auto
*
ICE_OPTION_TRICKLE
=
"
trickle
"
;
constexpr
auto
*
ICE_OPTION_RENOMINATION
=
"
renomination
"
;
std
:
:
optional
<
ConnectionRole
>
StringToConnectionRole
(
absl
:
:
string_view
role_str
)
;
bool
ConnectionRoleToString
(
const
ConnectionRole
&
role
std
:
:
string
*
role_str
)
;
struct
TransportDescription
{
TransportDescription
(
)
;
TransportDescription
(
const
std
:
:
vector
<
std
:
:
string
>
&
transport_options
absl
:
:
string_view
ice_ufrag
absl
:
:
string_view
ice_pwd
IceMode
ice_mode
ConnectionRole
role
const
SSLFingerprint
*
identity_fingerprint
)
;
TransportDescription
(
absl
:
:
string_view
ice_ufrag
absl
:
:
string_view
ice_pwd
)
;
TransportDescription
(
const
TransportDescription
&
from
)
;
~
TransportDescription
(
)
;
TransportDescription
&
operator
=
(
const
TransportDescription
&
from
)
;
bool
HasOption
(
absl
:
:
string_view
option
)
const
{
return
absl
:
:
c_linear_search
(
transport_options
option
)
;
}
void
AddOption
(
absl
:
:
string_view
option
)
{
transport_options
.
emplace_back
(
option
)
;
}
bool
secure
(
)
const
{
return
identity_fingerprint
!
=
nullptr
;
}
IceParameters
GetIceParameters
(
)
const
{
return
IceParameters
(
ice_ufrag
ice_pwd
HasOption
(
ICE_OPTION_RENOMINATION
)
)
;
}
static
SSLFingerprint
*
CopyFingerprint
(
const
SSLFingerprint
*
from
)
{
if
(
!
from
)
return
NULL
;
return
new
SSLFingerprint
(
*
from
)
;
}
std
:
:
vector
<
std
:
:
string
>
transport_options
;
std
:
:
string
ice_ufrag
;
std
:
:
string
ice_pwd
;
IceMode
ice_mode
;
ConnectionRole
connection_role
;
std
:
:
unique_ptr
<
SSLFingerprint
>
identity_fingerprint
;
}
;
}
namespace
cricket
{
using
:
:
webrtc
:
:
ConnectionRole
;
using
:
:
webrtc
:
:
CONNECTIONROLE_ACTIVE
;
using
:
:
webrtc
:
:
CONNECTIONROLE_ACTPASS
;
using
:
:
webrtc
:
:
CONNECTIONROLE_HOLDCONN
;
using
:
:
webrtc
:
:
CONNECTIONROLE_NONE
;
using
:
:
webrtc
:
:
CONNECTIONROLE_PASSIVE
;
using
:
:
webrtc
:
:
ConnectionRoleToString
;
using
:
:
webrtc
:
:
ICE_OPTION_RENOMINATION
;
using
:
:
webrtc
:
:
ICE_OPTION_TRICKLE
;
using
:
:
webrtc
:
:
IceMode
;
using
:
:
webrtc
:
:
ICEMODE_FULL
;
using
:
:
webrtc
:
:
ICEMODE_LITE
;
using
:
:
webrtc
:
:
IceParameters
;
using
:
:
webrtc
:
:
IceRole
;
using
:
:
webrtc
:
:
ICEROLE_CONTROLLED
;
using
:
:
webrtc
:
:
ICEROLE_CONTROLLING
;
using
:
:
webrtc
:
:
ICEROLE_UNKNOWN
;
using
:
:
webrtc
:
:
StringToConnectionRole
;
using
:
:
webrtc
:
:
TransportDescription
;
}
#
endif
