#
include
"
p2p
/
base
/
pseudo_tcp
.
h
"
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
test
/
rtc_error_matchers
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
memory_stream
.
h
"
#
include
"
rtc_base
/
stream
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
wait_until
.
h
"
using
:
:
testing
:
:
IsTrue
;
using
:
:
webrtc
:
:
PseudoTcp
;
using
:
:
webrtc
:
:
ScopedTaskSafety
;
using
:
:
webrtc
:
:
TaskQueueBase
;
using
:
:
webrtc
:
:
TimeDelta
;
static
const
int
kConnectTimeoutMs
=
10000
;
static
const
int
kTransferTimeoutMs
=
15000
;
static
const
int
kBlockSize
=
4096
;
class
PseudoTcpForTest
:
public
webrtc
:
:
PseudoTcp
{
public
:
PseudoTcpForTest
(
webrtc
:
:
IPseudoTcpNotify
*
notify
uint32_t
conv
)
:
webrtc
:
:
PseudoTcp
(
notify
conv
)
{
}
bool
isReceiveBufferFull
(
)
const
{
return
webrtc
:
:
PseudoTcp
:
:
isReceiveBufferFull
(
)
;
}
void
disableWindowScale
(
)
{
webrtc
:
:
PseudoTcp
:
:
disableWindowScale
(
)
;
}
}
;
class
PseudoTcpTestBase
:
public
:
:
testing
:
:
Test
public
webrtc
:
:
IPseudoTcpNotify
{
public
:
PseudoTcpTestBase
(
)
:
local_
(
this
1
)
remote_
(
this
1
)
have_connected_
(
false
)
have_disconnected_
(
false
)
local_mtu_
(
65535
)
remote_mtu_
(
65535
)
delay_
(
0
)
loss_
(
0
)
{
webrtc
:
:
SetRandomTestMode
(
true
)
;
}
~
PseudoTcpTestBase
(
)
{
webrtc
:
:
SetRandomTestMode
(
false
)
;
}
void
SetSimultaneousOpen
(
bool
enabled
)
{
simultaneous_open_
=
enabled
;
}
void
SetLocalMtu
(
int
mtu
)
{
local_
.
NotifyMTU
(
mtu
)
;
local_mtu_
=
mtu
;
}
void
SetRemoteMtu
(
int
mtu
)
{
remote_
.
NotifyMTU
(
mtu
)
;
remote_mtu_
=
mtu
;
}
void
SetDelay
(
int
delay
)
{
delay_
=
delay
;
}
void
SetLoss
(
int
percent
)
{
loss_
=
percent
;
}
void
DropNextPacket
(
)
{
drop_next_packet_
=
true
;
}
void
SetOptNagling
(
bool
enable_nagles
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_NODELAY
!
enable_nagles
)
;
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_NODELAY
!
enable_nagles
)
;
}
void
SetOptAckDelay
(
int
ack_delay
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_ACKDELAY
ack_delay
)
;
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_ACKDELAY
ack_delay
)
;
}
void
SetOptSndBuf
(
int
size
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_SNDBUF
size
)
;
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_SNDBUF
size
)
;
}
void
SetRemoteOptRcvBuf
(
int
size
)
{
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_RCVBUF
size
)
;
}
void
SetLocalOptRcvBuf
(
int
size
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_RCVBUF
size
)
;
}
void
DisableRemoteWindowScale
(
)
{
remote_
.
disableWindowScale
(
)
;
}
void
DisableLocalWindowScale
(
)
{
local_
.
disableWindowScale
(
)
;
}
protected
:
int
Connect
(
)
{
int
ret
=
local_
.
Connect
(
)
;
if
(
ret
=
=
0
)
{
UpdateLocalClock
(
)
;
}
if
(
simultaneous_open_
)
{
ret
=
remote_
.
Connect
(
)
;
if
(
ret
=
=
0
)
{
UpdateRemoteClock
(
)
;
}
}
return
ret
;
}
void
Close
(
)
{
local_
.
Close
(
false
)
;
UpdateLocalClock
(
)
;
}
virtual
void
OnTcpOpen
(
PseudoTcp
*
tcp
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Opened
"
;
if
(
tcp
=
=
&
local_
)
{
have_connected_
=
true
;
OnTcpWriteable
(
tcp
)
;
}
}
virtual
void
OnTcpClosed
(
PseudoTcp
*
tcp
uint32_t
error
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Closed
"
;
EXPECT_EQ
(
0U
error
)
;
if
(
tcp
=
=
&
remote_
)
{
have_disconnected_
=
true
;
}
}
virtual
WriteResult
TcpWritePacket
(
PseudoTcp
*
tcp
const
char
*
buffer
size_t
len
)
{
if
(
drop_next_packet_
)
{
drop_next_packet_
=
false
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Dropping
packet
due
to
DropNextPacket
size
=
"
<
<
len
;
return
WR_SUCCESS
;
}
if
(
webrtc
:
:
CreateRandomId
(
)
%
100
<
static_cast
<
uint32_t
>
(
loss_
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Randomly
dropping
packet
size
=
"
<
<
len
;
return
WR_SUCCESS
;
}
if
(
len
>
static_cast
<
size_t
>
(
std
:
:
min
(
local_mtu_
remote_mtu_
)
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Dropping
packet
that
exceeds
path
MTU
size
=
"
<
<
len
;
return
WR_SUCCESS
;
}
PseudoTcp
*
other
;
ScopedTaskSafety
*
timer
;
if
(
tcp
=
=
&
local_
)
{
other
=
&
remote_
;
timer
=
&
remote_timer_
;
}
else
{
other
=
&
local_
;
timer
=
&
local_timer_
;
}
std
:
:
string
packet
(
buffer
len
)
;
+
+
packets_in_flight_
;
TaskQueueBase
:
:
Current
(
)
-
>
PostDelayedTask
(
[
other
timer
packet
=
std
:
:
move
(
packet
)
this
]
{
-
-
packets_in_flight_
;
other
-
>
NotifyPacket
(
packet
.
c_str
(
)
packet
.
size
(
)
)
;
UpdateClock
(
*
other
*
timer
)
;
}
TimeDelta
:
:
Millis
(
delay_
)
)
;
return
WR_SUCCESS
;
}
void
UpdateLocalClock
(
)
{
UpdateClock
(
local_
local_timer_
)
;
}
void
UpdateRemoteClock
(
)
{
UpdateClock
(
remote_
remote_timer_
)
;
}
static
void
UpdateClock
(
PseudoTcp
&
tcp
ScopedTaskSafety
&
timer
)
{
long
interval
=
0
;
tcp
.
GetNextClock
(
PseudoTcp
:
:
Now
(
)
interval
)
;
interval
=
std
:
:
max
<
int
>
(
interval
0L
)
;
timer
.
reset
(
)
;
TaskQueueBase
:
:
Current
(
)
-
>
PostDelayedTask
(
SafeTask
(
timer
.
flag
(
)
[
&
tcp
&
timer
]
{
tcp
.
NotifyClock
(
PseudoTcp
:
:
Now
(
)
)
;
UpdateClock
(
tcp
timer
)
;
}
)
TimeDelta
:
:
Millis
(
interval
)
)
;
}
webrtc
:
:
AutoThread
main_thread_
;
PseudoTcpForTest
local_
;
PseudoTcpForTest
remote_
;
ScopedTaskSafety
local_timer_
;
ScopedTaskSafety
remote_timer_
;
webrtc
:
:
MemoryStream
send_stream_
;
webrtc
:
:
MemoryStream
recv_stream_
;
bool
have_connected_
;
bool
have_disconnected_
;
int
local_mtu_
;
int
remote_mtu_
;
int
delay_
;
int
loss_
;
bool
drop_next_packet_
=
false
;
bool
simultaneous_open_
=
false
;
int
packets_in_flight_
=
0
;
}
;
class
PseudoTcpTest
:
public
PseudoTcpTestBase
{
public
:
void
TestTransfer
(
int
size
)
{
uint32_t
start
;
int32_t
elapsed
;
size_t
received
;
send_stream_
.
ReserveSize
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
uint8_t
ch
=
static_cast
<
uint8_t
>
(
i
)
;
size_t
written
;
int
error
;
send_stream_
.
Write
(
rtc
:
:
MakeArrayView
(
&
ch
1
)
written
error
)
;
}
send_stream_
.
Rewind
(
)
;
recv_stream_
.
ReserveSize
(
size
)
;
start
=
webrtc
:
:
Time32
(
)
;
EXPECT_EQ
(
0
Connect
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
have_connected_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kConnectTimeoutMs
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
have_disconnected_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTransferTimeoutMs
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
elapsed
=
webrtc
:
:
Time32
(
)
-
start
;
recv_stream_
.
GetSize
(
&
received
)
;
EXPECT_EQ
(
static_cast
<
size_t
>
(
size
)
received
)
;
EXPECT_EQ
(
0
memcmp
(
send_stream_
.
GetBuffer
(
)
recv_stream_
.
GetBuffer
(
)
size
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Transferred
"
<
<
received
<
<
"
bytes
in
"
<
<
elapsed
<
<
"
ms
(
"
<
<
size
*
8
/
elapsed
<
<
"
Kbps
)
"
;
}
private
:
virtual
void
OnTcpReadable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
=
=
&
remote_
)
{
ReadData
(
)
;
size_t
received
required
;
recv_stream_
.
GetPosition
(
&
received
)
;
send_stream_
.
GetSize
(
&
required
)
;
if
(
received
=
=
required
)
OnTcpClosed
(
&
remote_
0
)
;
}
}
virtual
void
OnTcpWriteable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
=
=
&
local_
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Control
Lifted
"
;
bool
done
;
WriteData
(
&
done
)
;
if
(
done
)
{
Close
(
)
;
}
}
}
void
ReadData
(
)
{
char
block
[
kBlockSize
]
;
size_t
position
;
int
received
;
do
{
received
=
remote_
.
Recv
(
block
sizeof
(
block
)
)
;
if
(
received
!
=
-
1
)
{
size_t
written
;
int
error
;
recv_stream_
.
Write
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
uint8_t
*
>
(
block
)
received
)
written
error
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Received
:
"
<
<
position
;
}
}
while
(
received
>
0
)
;
}
void
WriteData
(
bool
*
done
)
{
size_t
position
tosend
;
int
sent
;
char
block
[
kBlockSize
]
;
do
{
send_stream_
.
GetPosition
(
&
position
)
;
int
error
;
if
(
send_stream_
.
Read
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
uint8_t
*
>
(
block
)
kBlockSize
)
tosend
error
)
!
=
rtc
:
:
SR_EOS
)
{
sent
=
local_
.
Send
(
block
tosend
)
;
UpdateLocalClock
(
)
;
if
(
sent
!
=
-
1
)
{
send_stream_
.
SetPosition
(
position
+
sent
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Sent
:
"
<
<
position
+
sent
;
}
else
{
send_stream_
.
SetPosition
(
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Controlled
"
;
}
}
else
{
sent
=
static_cast
<
int
>
(
tosend
=
0
)
;
}
}
while
(
sent
>
0
)
;
*
done
=
(
tosend
=
=
0
)
;
}
private
:
webrtc
:
:
MemoryStream
send_stream_
;
webrtc
:
:
MemoryStream
recv_stream_
;
}
;
class
PseudoTcpTestPingPong
:
public
PseudoTcpTestBase
{
public
:
PseudoTcpTestPingPong
(
)
:
iterations_remaining_
(
0
)
sender_
(
NULL
)
receiver_
(
NULL
)
bytes_per_send_
(
0
)
{
}
void
SetBytesPerSend
(
int
bytes
)
{
bytes_per_send_
=
bytes
;
}
void
TestPingPong
(
int
size
int
iterations
)
{
uint32_t
start
elapsed
;
iterations_remaining_
=
iterations
;
receiver_
=
&
remote_
;
sender_
=
&
local_
;
send_stream_
.
ReserveSize
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
uint8_t
ch
=
static_cast
<
uint8_t
>
(
i
)
;
size_t
written
;
int
error
;
send_stream_
.
Write
(
rtc
:
:
MakeArrayView
(
&
ch
1
)
written
error
)
;
}
send_stream_
.
Rewind
(
)
;
recv_stream_
.
ReserveSize
(
size
)
;
start
=
webrtc
:
:
Time32
(
)
;
EXPECT_EQ
(
0
Connect
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
have_connected_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kConnectTimeoutMs
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
have_disconnected_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTransferTimeoutMs
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
elapsed
=
webrtc
:
:
TimeSince
(
start
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Performed
"
<
<
iterations
<
<
"
pings
in
"
<
<
elapsed
<
<
"
ms
"
;
}
private
:
virtual
void
OnTcpReadable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
!
=
receiver_
)
{
RTC_LOG_F
(
LS_ERROR
)
<
<
"
unexpected
OnTcpReadable
"
;
return
;
}
ReadData
(
)
;
size_t
position
desired
;
recv_stream_
.
GetPosition
(
&
position
)
;
send_stream_
.
GetSize
(
&
desired
)
;
if
(
position
=
=
desired
)
{
if
(
receiver_
=
=
&
local_
&
&
-
-
iterations_remaining_
=
=
0
)
{
Close
(
)
;
OnTcpClosed
(
&
remote_
0
)
;
return
;
}
PseudoTcp
*
tmp
=
receiver_
;
receiver_
=
sender_
;
sender_
=
tmp
;
recv_stream_
.
Rewind
(
)
;
send_stream_
.
Rewind
(
)
;
OnTcpWriteable
(
sender_
)
;
}
}
virtual
void
OnTcpWriteable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
!
=
sender_
)
return
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Control
Lifted
"
;
WriteData
(
)
;
}
void
ReadData
(
)
{
char
block
[
kBlockSize
]
;
size_t
position
;
int
received
;
do
{
received
=
receiver_
-
>
Recv
(
block
sizeof
(
block
)
)
;
if
(
received
!
=
-
1
)
{
size_t
written
;
int
error
;
recv_stream_
.
Write
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
const
uint8_t
*
>
(
block
)
received
)
written
error
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Received
:
"
<
<
position
;
}
}
while
(
received
>
0
)
;
}
void
WriteData
(
)
{
size_t
position
tosend
;
int
sent
;
char
block
[
kBlockSize
]
;
do
{
send_stream_
.
GetPosition
(
&
position
)
;
tosend
=
bytes_per_send_
?
bytes_per_send_
:
sizeof
(
block
)
;
int
error
;
if
(
send_stream_
.
Read
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
uint8_t
*
>
(
block
)
tosend
)
tosend
error
)
!
=
rtc
:
:
SR_EOS
)
{
sent
=
sender_
-
>
Send
(
block
tosend
)
;
UpdateLocalClock
(
)
;
if
(
sent
!
=
-
1
)
{
send_stream_
.
SetPosition
(
position
+
sent
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Sent
:
"
<
<
position
+
sent
;
}
else
{
send_stream_
.
SetPosition
(
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Controlled
"
;
}
}
else
{
sent
=
static_cast
<
int
>
(
tosend
=
0
)
;
}
}
while
(
sent
>
0
)
;
}
private
:
int
iterations_remaining_
;
PseudoTcp
*
sender_
;
PseudoTcp
*
receiver_
;
int
bytes_per_send_
;
}
;
class
PseudoTcpTestReceiveWindow
:
public
PseudoTcpTestBase
{
public
:
void
TestTransfer
(
int
size
)
{
send_stream_
.
ReserveSize
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
uint8_t
ch
=
static_cast
<
uint8_t
>
(
i
)
;
size_t
written
;
int
error
;
send_stream_
.
Write
(
rtc
:
:
MakeArrayView
(
&
ch
1
)
written
error
)
;
}
send_stream_
.
Rewind
(
)
;
recv_stream_
.
ReserveSize
(
size
)
;
EXPECT_EQ
(
0
Connect
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
have_connected_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kConnectTimeoutMs
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TaskQueueBase
:
:
Current
(
)
-
>
PostTask
(
[
this
]
{
WriteData
(
)
;
}
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
have_disconnected_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kTransferTimeoutMs
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
2u
send_position_
.
size
(
)
)
;
ASSERT_EQ
(
2u
recv_position_
.
size
(
)
)
;
const
size_t
estimated_recv_window
=
EstimateReceiveWindowSize
(
)
;
const
size_t
send_position_diff
=
send_position_
[
1
]
-
send_position_
[
0
]
;
EXPECT_GE
(
1024u
estimated_recv_window
-
send_position_diff
)
;
EXPECT_EQ
(
2
*
estimated_recv_window
recv_position_
[
1
]
)
;
}
uint32_t
EstimateReceiveWindowSize
(
)
const
{
return
static_cast
<
uint32_t
>
(
recv_position_
[
0
]
)
;
}
uint32_t
EstimateSendWindowSize
(
)
const
{
return
static_cast
<
uint32_t
>
(
send_position_
[
0
]
-
recv_position_
[
0
]
)
;
}
private
:
virtual
void
OnTcpReadable
(
PseudoTcp
*
)
{
}
virtual
void
OnTcpWriteable
(
PseudoTcp
*
)
{
}
void
ReadUntilIOPending
(
)
{
char
block
[
kBlockSize
]
;
size_t
position
;
int
received
;
do
{
received
=
remote_
.
Recv
(
block
sizeof
(
block
)
)
;
if
(
received
!
=
-
1
)
{
size_t
written
;
int
error
;
recv_stream_
.
Write
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
uint8_t
*
>
(
block
)
received
)
written
error
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Received
:
"
<
<
position
;
}
}
while
(
received
>
0
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
recv_position_
.
push_back
(
position
)
;
if
(
recv_position_
.
size
(
)
=
=
2u
)
{
Close
(
)
;
OnTcpClosed
(
&
remote_
0
)
;
}
else
{
WriteData
(
)
;
}
}
void
WriteData
(
)
{
size_t
position
tosend
;
int
sent
;
char
block
[
kBlockSize
]
;
do
{
send_stream_
.
GetPosition
(
&
position
)
;
int
error
;
if
(
send_stream_
.
Read
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
uint8_t
*
>
(
block
)
sizeof
(
block
)
)
tosend
error
)
!
=
rtc
:
:
SR_EOS
)
{
sent
=
local_
.
Send
(
block
tosend
)
;
UpdateLocalClock
(
)
;
if
(
sent
!
=
-
1
)
{
send_stream_
.
SetPosition
(
position
+
sent
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Sent
:
"
<
<
position
+
sent
;
}
else
{
send_stream_
.
SetPosition
(
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Controlled
"
;
}
}
else
{
sent
=
static_cast
<
int
>
(
tosend
=
0
)
;
}
}
while
(
sent
>
0
)
;
if
(
packets_in_flight_
>
0
)
{
webrtc
:
:
Thread
:
:
Current
(
)
-
>
PostDelayedTask
(
[
this
]
{
WriteData
(
)
;
}
TimeDelta
:
:
Millis
(
10
)
)
;
}
else
{
if
(
!
remote_
.
isReceiveBufferFull
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
This
shouldn
'
t
happen
-
the
send
buffer
is
full
"
"
the
receive
buffer
is
not
and
there
are
no
"
"
remaining
messages
to
process
.
"
;
}
send_stream_
.
GetPosition
(
&
position
)
;
send_position_
.
push_back
(
position
)
;
ReadUntilIOPending
(
)
;
}
}
private
:
webrtc
:
:
MemoryStream
send_stream_
;
webrtc
:
:
MemoryStream
recv_stream_
;
std
:
:
vector
<
size_t
>
send_position_
;
std
:
:
vector
<
size_t
>
recv_position_
;
}
;
TEST_F
(
PseudoTcpTest
TestSend
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelay
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithLoss
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLoss
(
10
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelayAndLoss
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
SetLoss
(
10
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithLossAndOptNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLoss
(
10
)
;
SetOptNagling
(
false
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWhenFirstPacketLostWithOptNaglingOffAndSimultaneousOpen
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
DropNextPacket
(
)
;
SetOptNagling
(
false
)
;
SetSimultaneousOpen
(
true
)
;
TestTransfer
(
10000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithLossAndOptAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLoss
(
10
)
;
SetOptAckDelay
(
0
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelayAndOptNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
SetOptNagling
(
false
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelayAndOptAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
SetOptAckDelay
(
0
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendRemoteNoWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLocalOptRcvBuf
(
100000
)
;
DisableRemoteWindowScale
(
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendLocalNoWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100000
)
;
DisableLocalWindowScale
(
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendBothUseWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100000
)
;
SetLocalOptRcvBuf
(
100000
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendLargeInFlight
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100000
)
;
SetLocalOptRcvBuf
(
100000
)
;
SetOptSndBuf
(
150000
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendBothUseLargeWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
1000000
)
;
SetLocalOptRcvBuf
(
1000000
)
;
TestTransfer
(
10000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendSmallReceiveBuffer
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
10000
)
;
SetLocalOptRcvBuf
(
10000
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendVerySmallReceiveBuffer
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100
)
;
SetLocalOptRcvBuf
(
100
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong1xMtu
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestPingPong
(
100
100
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong3xMtu
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestPingPong
(
400
100
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong2xMtu
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestPingPong
(
2000
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong2xMtuWithAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptAckDelay
(
0
)
;
TestPingPong
(
2000
100
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong2xMtuWithNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
TestPingPong
(
2000
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPongShortSegments
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptAckDelay
(
5000
)
;
SetBytesPerSend
(
50
)
;
TestPingPong
(
100
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPongShortSegmentsWithNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetBytesPerSend
(
50
)
;
TestPingPong
(
100
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPongShortSegmentsWithAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetBytesPerSend
(
50
)
;
SetOptAckDelay
(
0
)
;
TestPingPong
(
100
5
)
;
}
TEST_F
(
PseudoTcpTestReceiveWindow
TestReceiveWindow
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetOptAckDelay
(
0
)
;
TestTransfer
(
1024
*
1000
)
;
}
TEST_F
(
PseudoTcpTestReceiveWindow
TestSetVerySmallSendWindowSize
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetOptAckDelay
(
0
)
;
SetOptSndBuf
(
900
)
;
TestTransfer
(
1024
*
1000
)
;
EXPECT_EQ
(
900u
EstimateSendWindowSize
(
)
)
;
}
TEST_F
(
PseudoTcpTestReceiveWindow
TestSetReceiveWindowSize
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetOptAckDelay
(
0
)
;
SetRemoteOptRcvBuf
(
100000
)
;
SetLocalOptRcvBuf
(
100000
)
;
TestTransfer
(
1024
*
1000
)
;
EXPECT_EQ
(
100000u
EstimateReceiveWindowSize
(
)
)
;
}
