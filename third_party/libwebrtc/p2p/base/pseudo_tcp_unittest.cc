#
include
"
p2p
/
base
/
pseudo_tcp
.
h
"
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
helpers
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
memory_stream
.
h
"
#
include
"
rtc_base
/
message_handler
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
test
/
gtest
.
h
"
using
cricket
:
:
PseudoTcp
;
static
const
int
kConnectTimeoutMs
=
10000
;
static
const
int
kTransferTimeoutMs
=
15000
;
static
const
int
kBlockSize
=
4096
;
class
PseudoTcpForTest
:
public
cricket
:
:
PseudoTcp
{
public
:
PseudoTcpForTest
(
cricket
:
:
IPseudoTcpNotify
*
notify
uint32_t
conv
)
:
PseudoTcp
(
notify
conv
)
{
}
bool
isReceiveBufferFull
(
)
const
{
return
PseudoTcp
:
:
isReceiveBufferFull
(
)
;
}
void
disableWindowScale
(
)
{
PseudoTcp
:
:
disableWindowScale
(
)
;
}
}
;
class
PseudoTcpTestBase
:
public
:
:
testing
:
:
Test
public
rtc
:
:
MessageHandlerAutoCleanup
public
cricket
:
:
IPseudoTcpNotify
{
public
:
PseudoTcpTestBase
(
)
:
local_
(
this
1
)
remote_
(
this
1
)
have_connected_
(
false
)
have_disconnected_
(
false
)
local_mtu_
(
65535
)
remote_mtu_
(
65535
)
delay_
(
0
)
loss_
(
0
)
{
rtc
:
:
SetRandomTestMode
(
true
)
;
}
~
PseudoTcpTestBase
(
)
{
rtc
:
:
SetRandomTestMode
(
false
)
;
}
void
SetSimultaneousOpen
(
bool
enabled
)
{
simultaneous_open_
=
enabled
;
}
void
SetLocalMtu
(
int
mtu
)
{
local_
.
NotifyMTU
(
mtu
)
;
local_mtu_
=
mtu
;
}
void
SetRemoteMtu
(
int
mtu
)
{
remote_
.
NotifyMTU
(
mtu
)
;
remote_mtu_
=
mtu
;
}
void
SetDelay
(
int
delay
)
{
delay_
=
delay
;
}
void
SetLoss
(
int
percent
)
{
loss_
=
percent
;
}
void
DropNextPacket
(
)
{
drop_next_packet_
=
true
;
}
void
SetOptNagling
(
bool
enable_nagles
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_NODELAY
!
enable_nagles
)
;
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_NODELAY
!
enable_nagles
)
;
}
void
SetOptAckDelay
(
int
ack_delay
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_ACKDELAY
ack_delay
)
;
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_ACKDELAY
ack_delay
)
;
}
void
SetOptSndBuf
(
int
size
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_SNDBUF
size
)
;
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_SNDBUF
size
)
;
}
void
SetRemoteOptRcvBuf
(
int
size
)
{
remote_
.
SetOption
(
PseudoTcp
:
:
OPT_RCVBUF
size
)
;
}
void
SetLocalOptRcvBuf
(
int
size
)
{
local_
.
SetOption
(
PseudoTcp
:
:
OPT_RCVBUF
size
)
;
}
void
DisableRemoteWindowScale
(
)
{
remote_
.
disableWindowScale
(
)
;
}
void
DisableLocalWindowScale
(
)
{
local_
.
disableWindowScale
(
)
;
}
protected
:
int
Connect
(
)
{
int
ret
=
local_
.
Connect
(
)
;
if
(
ret
=
=
0
)
{
UpdateLocalClock
(
)
;
}
if
(
simultaneous_open_
)
{
ret
=
remote_
.
Connect
(
)
;
if
(
ret
=
=
0
)
{
UpdateRemoteClock
(
)
;
}
}
return
ret
;
}
void
Close
(
)
{
local_
.
Close
(
false
)
;
UpdateLocalClock
(
)
;
}
enum
{
MSG_LPACKET
MSG_RPACKET
MSG_LCLOCK
MSG_RCLOCK
MSG_IOCOMPLETE
MSG_WRITE
}
;
virtual
void
OnTcpOpen
(
PseudoTcp
*
tcp
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Opened
"
;
if
(
tcp
=
=
&
local_
)
{
have_connected_
=
true
;
OnTcpWriteable
(
tcp
)
;
}
}
virtual
void
OnTcpClosed
(
PseudoTcp
*
tcp
uint32_t
error
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Closed
"
;
EXPECT_EQ
(
0U
error
)
;
if
(
tcp
=
=
&
remote_
)
{
have_disconnected_
=
true
;
}
}
virtual
WriteResult
TcpWritePacket
(
PseudoTcp
*
tcp
const
char
*
buffer
size_t
len
)
{
if
(
drop_next_packet_
)
{
drop_next_packet_
=
false
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Dropping
packet
due
to
DropNextPacket
size
=
"
<
<
len
;
return
WR_SUCCESS
;
}
if
(
rtc
:
:
CreateRandomId
(
)
%
100
<
static_cast
<
uint32_t
>
(
loss_
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Randomly
dropping
packet
size
=
"
<
<
len
;
return
WR_SUCCESS
;
}
if
(
len
>
static_cast
<
size_t
>
(
std
:
:
min
(
local_mtu_
remote_mtu_
)
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Dropping
packet
that
exceeds
path
MTU
size
=
"
<
<
len
;
return
WR_SUCCESS
;
}
int
id
=
(
tcp
=
=
&
local_
)
?
MSG_RPACKET
:
MSG_LPACKET
;
std
:
:
string
packet
(
buffer
len
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
PostDelayed
(
RTC_FROM_HERE
delay_
this
id
rtc
:
:
WrapMessageData
(
packet
)
)
;
return
WR_SUCCESS
;
}
void
UpdateLocalClock
(
)
{
UpdateClock
(
&
local_
MSG_LCLOCK
)
;
}
void
UpdateRemoteClock
(
)
{
UpdateClock
(
&
remote_
MSG_RCLOCK
)
;
}
void
UpdateClock
(
PseudoTcp
*
tcp
uint32_t
message
)
{
long
interval
=
0
;
tcp
-
>
GetNextClock
(
PseudoTcp
:
:
Now
(
)
interval
)
;
interval
=
std
:
:
max
<
int
>
(
interval
0L
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
Clear
(
this
message
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
PostDelayed
(
RTC_FROM_HERE
interval
this
message
)
;
}
virtual
void
OnMessage
(
rtc
:
:
Message
*
message
)
{
switch
(
message
-
>
message_id
)
{
case
MSG_LPACKET
:
{
const
std
:
:
string
&
s
(
rtc
:
:
UseMessageData
<
std
:
:
string
>
(
message
-
>
pdata
)
)
;
local_
.
NotifyPacket
(
s
.
c_str
(
)
s
.
size
(
)
)
;
UpdateLocalClock
(
)
;
break
;
}
case
MSG_RPACKET
:
{
const
std
:
:
string
&
s
(
rtc
:
:
UseMessageData
<
std
:
:
string
>
(
message
-
>
pdata
)
)
;
remote_
.
NotifyPacket
(
s
.
c_str
(
)
s
.
size
(
)
)
;
UpdateRemoteClock
(
)
;
break
;
}
case
MSG_LCLOCK
:
local_
.
NotifyClock
(
PseudoTcp
:
:
Now
(
)
)
;
UpdateLocalClock
(
)
;
break
;
case
MSG_RCLOCK
:
remote_
.
NotifyClock
(
PseudoTcp
:
:
Now
(
)
)
;
UpdateRemoteClock
(
)
;
break
;
default
:
break
;
}
delete
message
-
>
pdata
;
}
PseudoTcpForTest
local_
;
PseudoTcpForTest
remote_
;
rtc
:
:
MemoryStream
send_stream_
;
rtc
:
:
MemoryStream
recv_stream_
;
bool
have_connected_
;
bool
have_disconnected_
;
int
local_mtu_
;
int
remote_mtu_
;
int
delay_
;
int
loss_
;
bool
drop_next_packet_
=
false
;
bool
simultaneous_open_
=
false
;
}
;
class
PseudoTcpTest
:
public
PseudoTcpTestBase
{
public
:
void
TestTransfer
(
int
size
)
{
uint32_t
start
;
int32_t
elapsed
;
size_t
received
;
send_stream_
.
ReserveSize
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
char
ch
=
static_cast
<
char
>
(
i
)
;
send_stream_
.
Write
(
&
ch
1
NULL
NULL
)
;
}
send_stream_
.
Rewind
(
)
;
recv_stream_
.
ReserveSize
(
size
)
;
start
=
rtc
:
:
Time32
(
)
;
EXPECT_EQ
(
0
Connect
(
)
)
;
EXPECT_TRUE_WAIT
(
have_connected_
kConnectTimeoutMs
)
;
EXPECT_TRUE_WAIT
(
have_disconnected_
kTransferTimeoutMs
)
;
elapsed
=
rtc
:
:
Time32
(
)
-
start
;
recv_stream_
.
GetSize
(
&
received
)
;
EXPECT_EQ
(
static_cast
<
size_t
>
(
size
)
received
)
;
EXPECT_EQ
(
0
memcmp
(
send_stream_
.
GetBuffer
(
)
recv_stream_
.
GetBuffer
(
)
size
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Transferred
"
<
<
received
<
<
"
bytes
in
"
<
<
elapsed
<
<
"
ms
(
"
<
<
size
*
8
/
elapsed
<
<
"
Kbps
)
"
;
}
private
:
virtual
void
OnTcpReadable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
=
=
&
remote_
)
{
ReadData
(
)
;
size_t
received
required
;
recv_stream_
.
GetPosition
(
&
received
)
;
send_stream_
.
GetSize
(
&
required
)
;
if
(
received
=
=
required
)
OnTcpClosed
(
&
remote_
0
)
;
}
}
virtual
void
OnTcpWriteable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
=
=
&
local_
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Control
Lifted
"
;
bool
done
;
WriteData
(
&
done
)
;
if
(
done
)
{
Close
(
)
;
}
}
}
void
ReadData
(
)
{
char
block
[
kBlockSize
]
;
size_t
position
;
int
rcvd
;
do
{
rcvd
=
remote_
.
Recv
(
block
sizeof
(
block
)
)
;
if
(
rcvd
!
=
-
1
)
{
recv_stream_
.
Write
(
block
rcvd
NULL
NULL
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Received
:
"
<
<
position
;
}
}
while
(
rcvd
>
0
)
;
}
void
WriteData
(
bool
*
done
)
{
size_t
position
tosend
;
int
sent
;
char
block
[
kBlockSize
]
;
do
{
send_stream_
.
GetPosition
(
&
position
)
;
if
(
send_stream_
.
Read
(
block
sizeof
(
block
)
&
tosend
NULL
)
!
=
rtc
:
:
SR_EOS
)
{
sent
=
local_
.
Send
(
block
tosend
)
;
UpdateLocalClock
(
)
;
if
(
sent
!
=
-
1
)
{
send_stream_
.
SetPosition
(
position
+
sent
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Sent
:
"
<
<
position
+
sent
;
}
else
{
send_stream_
.
SetPosition
(
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Controlled
"
;
}
}
else
{
sent
=
static_cast
<
int
>
(
tosend
=
0
)
;
}
}
while
(
sent
>
0
)
;
*
done
=
(
tosend
=
=
0
)
;
}
private
:
rtc
:
:
MemoryStream
send_stream_
;
rtc
:
:
MemoryStream
recv_stream_
;
}
;
class
PseudoTcpTestPingPong
:
public
PseudoTcpTestBase
{
public
:
PseudoTcpTestPingPong
(
)
:
iterations_remaining_
(
0
)
sender_
(
NULL
)
receiver_
(
NULL
)
bytes_per_send_
(
0
)
{
}
void
SetBytesPerSend
(
int
bytes
)
{
bytes_per_send_
=
bytes
;
}
void
TestPingPong
(
int
size
int
iterations
)
{
uint32_t
start
elapsed
;
iterations_remaining_
=
iterations
;
receiver_
=
&
remote_
;
sender_
=
&
local_
;
send_stream_
.
ReserveSize
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
char
ch
=
static_cast
<
char
>
(
i
)
;
send_stream_
.
Write
(
&
ch
1
NULL
NULL
)
;
}
send_stream_
.
Rewind
(
)
;
recv_stream_
.
ReserveSize
(
size
)
;
start
=
rtc
:
:
Time32
(
)
;
EXPECT_EQ
(
0
Connect
(
)
)
;
EXPECT_TRUE_WAIT
(
have_connected_
kConnectTimeoutMs
)
;
EXPECT_TRUE_WAIT
(
have_disconnected_
kTransferTimeoutMs
)
;
elapsed
=
rtc
:
:
TimeSince
(
start
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Performed
"
<
<
iterations
<
<
"
pings
in
"
<
<
elapsed
<
<
"
ms
"
;
}
private
:
virtual
void
OnTcpReadable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
!
=
receiver_
)
{
RTC_LOG_F
(
LS_ERROR
)
<
<
"
unexpected
OnTcpReadable
"
;
return
;
}
ReadData
(
)
;
size_t
position
desired
;
recv_stream_
.
GetPosition
(
&
position
)
;
send_stream_
.
GetSize
(
&
desired
)
;
if
(
position
=
=
desired
)
{
if
(
receiver_
=
=
&
local_
&
&
-
-
iterations_remaining_
=
=
0
)
{
Close
(
)
;
OnTcpClosed
(
&
remote_
0
)
;
return
;
}
PseudoTcp
*
tmp
=
receiver_
;
receiver_
=
sender_
;
sender_
=
tmp
;
recv_stream_
.
Rewind
(
)
;
send_stream_
.
Rewind
(
)
;
OnTcpWriteable
(
sender_
)
;
}
}
virtual
void
OnTcpWriteable
(
PseudoTcp
*
tcp
)
{
if
(
tcp
!
=
sender_
)
return
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Control
Lifted
"
;
WriteData
(
)
;
}
void
ReadData
(
)
{
char
block
[
kBlockSize
]
;
size_t
position
;
int
rcvd
;
do
{
rcvd
=
receiver_
-
>
Recv
(
block
sizeof
(
block
)
)
;
if
(
rcvd
!
=
-
1
)
{
recv_stream_
.
Write
(
block
rcvd
NULL
NULL
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Received
:
"
<
<
position
;
}
}
while
(
rcvd
>
0
)
;
}
void
WriteData
(
)
{
size_t
position
tosend
;
int
sent
;
char
block
[
kBlockSize
]
;
do
{
send_stream_
.
GetPosition
(
&
position
)
;
tosend
=
bytes_per_send_
?
bytes_per_send_
:
sizeof
(
block
)
;
if
(
send_stream_
.
Read
(
block
tosend
&
tosend
NULL
)
!
=
rtc
:
:
SR_EOS
)
{
sent
=
sender_
-
>
Send
(
block
tosend
)
;
UpdateLocalClock
(
)
;
if
(
sent
!
=
-
1
)
{
send_stream_
.
SetPosition
(
position
+
sent
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Sent
:
"
<
<
position
+
sent
;
}
else
{
send_stream_
.
SetPosition
(
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Controlled
"
;
}
}
else
{
sent
=
static_cast
<
int
>
(
tosend
=
0
)
;
}
}
while
(
sent
>
0
)
;
}
private
:
int
iterations_remaining_
;
PseudoTcp
*
sender_
;
PseudoTcp
*
receiver_
;
int
bytes_per_send_
;
}
;
class
PseudoTcpTestReceiveWindow
:
public
PseudoTcpTestBase
{
public
:
void
TestTransfer
(
int
size
)
{
send_stream_
.
ReserveSize
(
size
)
;
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
char
ch
=
static_cast
<
char
>
(
i
)
;
send_stream_
.
Write
(
&
ch
1
NULL
NULL
)
;
}
send_stream_
.
Rewind
(
)
;
recv_stream_
.
ReserveSize
(
size
)
;
EXPECT_EQ
(
0
Connect
(
)
)
;
EXPECT_TRUE_WAIT
(
have_connected_
kConnectTimeoutMs
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
Post
(
RTC_FROM_HERE
this
MSG_WRITE
)
;
EXPECT_TRUE_WAIT
(
have_disconnected_
kTransferTimeoutMs
)
;
ASSERT_EQ
(
2u
send_position_
.
size
(
)
)
;
ASSERT_EQ
(
2u
recv_position_
.
size
(
)
)
;
const
size_t
estimated_recv_window
=
EstimateReceiveWindowSize
(
)
;
const
size_t
send_position_diff
=
send_position_
[
1
]
-
send_position_
[
0
]
;
EXPECT_GE
(
1024u
estimated_recv_window
-
send_position_diff
)
;
EXPECT_EQ
(
2
*
estimated_recv_window
recv_position_
[
1
]
)
;
}
virtual
void
OnMessage
(
rtc
:
:
Message
*
message
)
{
int
message_id
=
message
-
>
message_id
;
PseudoTcpTestBase
:
:
OnMessage
(
message
)
;
switch
(
message_id
)
{
case
MSG_WRITE
:
{
WriteData
(
)
;
break
;
}
default
:
break
;
}
}
uint32_t
EstimateReceiveWindowSize
(
)
const
{
return
static_cast
<
uint32_t
>
(
recv_position_
[
0
]
)
;
}
uint32_t
EstimateSendWindowSize
(
)
const
{
return
static_cast
<
uint32_t
>
(
send_position_
[
0
]
-
recv_position_
[
0
]
)
;
}
private
:
virtual
void
OnTcpReadable
(
PseudoTcp
*
tcp
)
{
}
virtual
void
OnTcpWriteable
(
PseudoTcp
*
tcp
)
{
}
void
ReadUntilIOPending
(
)
{
char
block
[
kBlockSize
]
;
size_t
position
;
int
rcvd
;
do
{
rcvd
=
remote_
.
Recv
(
block
sizeof
(
block
)
)
;
if
(
rcvd
!
=
-
1
)
{
recv_stream_
.
Write
(
block
rcvd
NULL
NULL
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Received
:
"
<
<
position
;
}
}
while
(
rcvd
>
0
)
;
recv_stream_
.
GetPosition
(
&
position
)
;
recv_position_
.
push_back
(
position
)
;
if
(
recv_position_
.
size
(
)
=
=
2u
)
{
Close
(
)
;
OnTcpClosed
(
&
remote_
0
)
;
}
else
{
WriteData
(
)
;
}
}
void
WriteData
(
)
{
size_t
position
tosend
;
int
sent
;
char
block
[
kBlockSize
]
;
do
{
send_stream_
.
GetPosition
(
&
position
)
;
if
(
send_stream_
.
Read
(
block
sizeof
(
block
)
&
tosend
NULL
)
!
=
rtc
:
:
SR_EOS
)
{
sent
=
local_
.
Send
(
block
tosend
)
;
UpdateLocalClock
(
)
;
if
(
sent
!
=
-
1
)
{
send_stream_
.
SetPosition
(
position
+
sent
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Sent
:
"
<
<
position
+
sent
;
}
else
{
send_stream_
.
SetPosition
(
position
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Flow
Controlled
"
;
}
}
else
{
sent
=
static_cast
<
int
>
(
tosend
=
0
)
;
}
}
while
(
sent
>
0
)
;
int
message_queue_size
=
static_cast
<
int
>
(
rtc
:
:
Thread
:
:
Current
(
)
-
>
size
(
)
)
;
if
(
message_queue_size
>
2
)
{
rtc
:
:
Thread
:
:
Current
(
)
-
>
PostDelayed
(
RTC_FROM_HERE
10
this
MSG_WRITE
)
;
}
else
{
if
(
!
remote_
.
isReceiveBufferFull
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
This
shouldn
'
t
happen
-
the
send
buffer
is
full
"
"
the
receive
buffer
is
not
and
there
are
no
"
"
remaining
messages
to
process
.
"
;
}
send_stream_
.
GetPosition
(
&
position
)
;
send_position_
.
push_back
(
position
)
;
ReadUntilIOPending
(
)
;
}
}
private
:
rtc
:
:
MemoryStream
send_stream_
;
rtc
:
:
MemoryStream
recv_stream_
;
std
:
:
vector
<
size_t
>
send_position_
;
std
:
:
vector
<
size_t
>
recv_position_
;
}
;
TEST_F
(
PseudoTcpTest
TestSend
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelay
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithLoss
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLoss
(
10
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelayAndLoss
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
SetLoss
(
10
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithLossAndOptNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLoss
(
10
)
;
SetOptNagling
(
false
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWhenFirstPacketLostWithOptNaglingOffAndSimultaneousOpen
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
DropNextPacket
(
)
;
SetOptNagling
(
false
)
;
SetSimultaneousOpen
(
true
)
;
TestTransfer
(
10000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithLossAndOptAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLoss
(
10
)
;
SetOptAckDelay
(
0
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelayAndOptNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
SetOptNagling
(
false
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendWithDelayAndOptAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetDelay
(
50
)
;
SetOptAckDelay
(
0
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendRemoteNoWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetLocalOptRcvBuf
(
100000
)
;
DisableRemoteWindowScale
(
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendLocalNoWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100000
)
;
DisableLocalWindowScale
(
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendBothUseWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100000
)
;
SetLocalOptRcvBuf
(
100000
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendLargeInFlight
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100000
)
;
SetLocalOptRcvBuf
(
100000
)
;
SetOptSndBuf
(
150000
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendBothUseLargeWindowScale
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
1000000
)
;
SetLocalOptRcvBuf
(
1000000
)
;
TestTransfer
(
10000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendSmallReceiveBuffer
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
10000
)
;
SetLocalOptRcvBuf
(
10000
)
;
TestTransfer
(
1000000
)
;
}
TEST_F
(
PseudoTcpTest
TestSendVerySmallReceiveBuffer
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetRemoteOptRcvBuf
(
100
)
;
SetLocalOptRcvBuf
(
100
)
;
TestTransfer
(
100000
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong1xMtu
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestPingPong
(
100
100
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong3xMtu
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestPingPong
(
400
100
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong2xMtu
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
TestPingPong
(
2000
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong2xMtuWithAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptAckDelay
(
0
)
;
TestPingPong
(
2000
100
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPong2xMtuWithNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
TestPingPong
(
2000
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPongShortSegments
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptAckDelay
(
5000
)
;
SetBytesPerSend
(
50
)
;
TestPingPong
(
100
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPongShortSegmentsWithNaglingOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetBytesPerSend
(
50
)
;
TestPingPong
(
100
5
)
;
}
TEST_F
(
PseudoTcpTestPingPong
TestPingPongShortSegmentsWithAckDelayOff
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetBytesPerSend
(
50
)
;
SetOptAckDelay
(
0
)
;
TestPingPong
(
100
5
)
;
}
TEST_F
(
PseudoTcpTestReceiveWindow
TestReceiveWindow
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetOptAckDelay
(
0
)
;
TestTransfer
(
1024
*
1000
)
;
}
TEST_F
(
PseudoTcpTestReceiveWindow
TestSetVerySmallSendWindowSize
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetOptAckDelay
(
0
)
;
SetOptSndBuf
(
900
)
;
TestTransfer
(
1024
*
1000
)
;
EXPECT_EQ
(
900u
EstimateSendWindowSize
(
)
)
;
}
TEST_F
(
PseudoTcpTestReceiveWindow
TestSetReceiveWindowSize
)
{
SetLocalMtu
(
1500
)
;
SetRemoteMtu
(
1500
)
;
SetOptNagling
(
false
)
;
SetOptAckDelay
(
0
)
;
SetRemoteOptRcvBuf
(
100000
)
;
SetLocalOptRcvBuf
(
100000
)
;
TestTransfer
(
1024
*
1000
)
;
EXPECT_EQ
(
100000u
EstimateReceiveWindowSize
(
)
)
;
}
