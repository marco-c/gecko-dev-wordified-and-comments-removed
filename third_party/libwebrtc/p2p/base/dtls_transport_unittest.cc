#
include
"
p2p
/
base
/
dtls_transport
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
utility
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
dtls_transport_interface
.
h
"
#
include
"
p2p
/
base
/
fake_ice_transport
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
rtc_certificate
.
h
"
#
include
"
rtc_base
/
ssl_adapter
.
h
"
#
include
"
rtc_base
/
ssl_identity
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
define
MAYBE_SKIP_TEST
(
feature
)
\
if
(
!
(
rtc
:
:
SSLStreamAdapter
:
:
feature
(
)
)
)
{
\
RTC_LOG
(
LS_INFO
)
<
<
#
feature
"
feature
disabled
.
.
.
skipping
"
;
\
return
;
\
}
namespace
cricket
{
static
const
size_t
kPacketNumOffset
=
8
;
static
const
size_t
kPacketHeaderLen
=
12
;
static
const
int
kFakePacketId
=
0x1234
;
static
const
int
kTimeout
=
10000
;
static
bool
IsRtpLeadByte
(
uint8_t
b
)
{
return
(
(
b
&
0xC0
)
=
=
0x80
)
;
}
void
SetRemoteFingerprintFromCert
(
DtlsTransport
*
transport
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
cert
bool
modify_digest
=
false
)
{
std
:
:
unique_ptr
<
rtc
:
:
SSLFingerprint
>
fingerprint
=
rtc
:
:
SSLFingerprint
:
:
CreateFromCertificate
(
*
cert
)
;
if
(
modify_digest
)
{
+
+
fingerprint
-
>
digest
.
MutableData
(
)
[
0
]
;
}
EXPECT_TRUE
(
transport
-
>
SetRemoteParameters
(
fingerprint
-
>
algorithm
reinterpret_cast
<
const
uint8_t
*
>
(
fingerprint
-
>
digest
.
data
(
)
)
fingerprint
-
>
digest
.
size
(
)
std
:
:
nullopt
)
.
ok
(
)
)
;
}
class
DtlsTestClient
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
DtlsTestClient
(
absl
:
:
string_view
name
)
:
name_
(
name
)
{
}
void
CreateCertificate
(
rtc
:
:
KeyType
key_type
)
{
certificate_
=
rtc
:
:
RTCCertificate
:
:
Create
(
rtc
:
:
SSLIdentity
:
:
Create
(
name_
key_type
)
)
;
}
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
(
)
{
return
certificate_
;
}
void
SetupMaxProtocolVersion
(
rtc
:
:
SSLProtocolVersion
version
)
{
ssl_max_version_
=
version
;
}
void
SetupTransports
(
IceRole
role
int
async_delay_ms
=
0
)
{
dtls_transport_
=
nullptr
;
fake_ice_transport_
=
nullptr
;
fake_ice_transport_
.
reset
(
new
FakeIceTransport
(
"
fake
"
0
)
)
;
fake_ice_transport_
-
>
SetAsync
(
true
)
;
fake_ice_transport_
-
>
SetAsyncDelay
(
async_delay_ms
)
;
fake_ice_transport_
-
>
SetIceRole
(
role
)
;
fake_ice_transport_
-
>
RegisterReceivedPacketCallback
(
this
[
&
]
(
rtc
:
:
PacketTransportInternal
*
transport
const
rtc
:
:
ReceivedPacket
&
packet
)
{
OnFakeIceTransportReadPacket
(
transport
packet
)
;
}
)
;
dtls_transport_
=
std
:
:
make_unique
<
DtlsTransport
>
(
fake_ice_transport_
.
get
(
)
webrtc
:
:
CryptoOptions
(
)
nullptr
ssl_max_version_
)
;
dtls_transport_
-
>
SetLocalCertificate
(
certificate_
)
;
dtls_transport_
-
>
SignalWritableState
.
connect
(
this
&
DtlsTestClient
:
:
OnTransportWritableState
)
;
dtls_transport_
-
>
RegisterReceivedPacketCallback
(
this
[
&
]
(
rtc
:
:
PacketTransportInternal
*
transport
const
rtc
:
:
ReceivedPacket
&
packet
)
{
OnTransportReadPacket
(
transport
packet
)
;
}
)
;
dtls_transport_
-
>
SignalSentPacket
.
connect
(
this
&
DtlsTestClient
:
:
OnTransportSentPacket
)
;
}
FakeIceTransport
*
fake_ice_transport
(
)
{
return
static_cast
<
FakeIceTransport
*
>
(
dtls_transport_
-
>
ice_transport
(
)
)
;
}
DtlsTransport
*
dtls_transport
(
)
{
return
dtls_transport_
.
get
(
)
;
}
bool
Connect
(
DtlsTestClient
*
peer
bool
asymmetric
)
{
fake_ice_transport
(
)
-
>
SetDestination
(
peer
-
>
fake_ice_transport
(
)
asymmetric
)
;
return
true
;
}
int
received_dtls_client_hellos
(
)
const
{
return
received_dtls_client_hellos_
;
}
int
received_dtls_server_hellos
(
)
const
{
return
received_dtls_server_hellos_
;
}
void
CheckRole
(
rtc
:
:
SSLRole
role
)
{
if
(
role
=
=
rtc
:
:
SSL_CLIENT
)
{
ASSERT_EQ
(
0
received_dtls_client_hellos_
)
;
ASSERT_GT
(
received_dtls_server_hellos_
0
)
;
}
else
{
ASSERT_GT
(
received_dtls_client_hellos_
0
)
;
ASSERT_EQ
(
0
received_dtls_server_hellos_
)
;
}
}
void
CheckSrtp
(
int
expected_crypto_suite
)
{
int
crypto_suite
;
bool
rv
=
dtls_transport_
-
>
GetSrtpCryptoSuite
(
&
crypto_suite
)
;
if
(
dtls_transport_
-
>
IsDtlsActive
(
)
&
&
expected_crypto_suite
)
{
ASSERT_TRUE
(
rv
)
;
ASSERT_EQ
(
crypto_suite
expected_crypto_suite
)
;
}
else
{
ASSERT_FALSE
(
rv
)
;
}
}
void
CheckSsl
(
)
{
int
cipher
;
bool
rv
=
dtls_transport_
-
>
GetSslCipherSuite
(
&
cipher
)
;
if
(
dtls_transport_
-
>
IsDtlsActive
(
)
)
{
ASSERT_TRUE
(
rv
)
;
EXPECT_TRUE
(
rtc
:
:
SSLStreamAdapter
:
:
IsAcceptableCipher
(
cipher
rtc
:
:
KT_DEFAULT
)
)
;
}
else
{
ASSERT_FALSE
(
rv
)
;
}
}
void
SendPackets
(
size_t
size
size_t
count
bool
srtp
)
{
std
:
:
unique_ptr
<
char
[
]
>
packet
(
new
char
[
size
]
)
;
size_t
sent
=
0
;
do
{
memset
(
packet
.
get
(
)
sent
&
0xff
size
)
;
packet
[
0
]
=
(
srtp
)
?
0x80
:
0x00
;
rtc
:
:
SetBE32
(
packet
.
get
(
)
+
kPacketNumOffset
static_cast
<
uint32_t
>
(
sent
)
)
;
int
flags
=
(
certificate_
&
&
srtp
)
?
PF_SRTP_BYPASS
:
0
;
rtc
:
:
PacketOptions
packet_options
;
packet_options
.
packet_id
=
kFakePacketId
;
int
rv
=
dtls_transport_
-
>
SendPacket
(
packet
.
get
(
)
size
packet_options
flags
)
;
ASSERT_GT
(
rv
0
)
;
ASSERT_EQ
(
size
static_cast
<
size_t
>
(
rv
)
)
;
+
+
sent
;
}
while
(
sent
<
count
)
;
}
int
SendInvalidSrtpPacket
(
size_t
size
)
{
std
:
:
unique_ptr
<
char
[
]
>
packet
(
new
char
[
size
]
)
;
memset
(
packet
.
get
(
)
0
size
)
;
rtc
:
:
PacketOptions
packet_options
;
return
dtls_transport_
-
>
SendPacket
(
packet
.
get
(
)
size
packet_options
PF_SRTP_BYPASS
)
;
}
void
ExpectPackets
(
size_t
size
)
{
packet_size_
=
size
;
received_
.
clear
(
)
;
}
size_t
NumPacketsReceived
(
)
{
return
received_
.
size
(
)
;
}
bool
VerifyPacket
(
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
uint32_t
*
out_num
)
{
const
uint8_t
*
data
=
payload
.
data
(
)
;
size_t
size
=
payload
.
size
(
)
;
if
(
size
!
=
packet_size_
|
|
(
data
[
0
]
!
=
0
&
&
(
data
[
0
]
)
!
=
0x80
)
)
{
return
false
;
}
uint32_t
packet_num
=
rtc
:
:
GetBE32
(
data
+
kPacketNumOffset
)
;
for
(
size_t
i
=
kPacketHeaderLen
;
i
<
size
;
+
+
i
)
{
if
(
data
[
i
]
!
=
(
packet_num
&
0xff
)
)
{
return
false
;
}
}
if
(
out_num
)
{
*
out_num
=
packet_num
;
}
return
true
;
}
bool
VerifyEncryptedPacket
(
const
uint8_t
*
data
size_t
size
)
{
if
(
size
<
=
packet_size_
)
{
return
false
;
}
uint32_t
packet_num
=
rtc
:
:
GetBE32
(
data
+
kPacketNumOffset
)
;
int
num_matches
=
0
;
for
(
size_t
i
=
kPacketNumOffset
;
i
<
size
;
+
+
i
)
{
if
(
data
[
i
]
=
=
(
packet_num
&
0xff
)
)
{
+
+
num_matches
;
}
}
return
(
num_matches
<
(
(
static_cast
<
int
>
(
size
)
-
5
)
/
10
)
)
;
}
void
OnTransportWritableState
(
rtc
:
:
PacketTransportInternal
*
transport
)
{
RTC_LOG
(
LS_INFO
)
<
<
name_
<
<
"
:
Transport
'
"
<
<
transport
-
>
transport_name
(
)
<
<
"
'
is
writable
"
;
}
void
OnTransportReadPacket
(
rtc
:
:
PacketTransportInternal
*
const
rtc
:
:
ReceivedPacket
&
packet
)
{
uint32_t
packet_num
=
0
;
ASSERT_TRUE
(
VerifyPacket
(
packet
.
payload
(
)
&
packet_num
)
)
;
received_
.
insert
(
packet_num
)
;
switch
(
packet
.
decryption_info
(
)
)
{
case
rtc
:
:
ReceivedPacket
:
:
kSrtpEncrypted
:
ASSERT_TRUE
(
certificate_
&
&
IsRtpLeadByte
(
packet
.
payload
(
)
[
0
]
)
)
;
break
;
case
rtc
:
:
ReceivedPacket
:
:
kDtlsDecrypted
:
ASSERT_TRUE
(
certificate_
&
&
!
IsRtpLeadByte
(
packet
.
payload
(
)
[
0
]
)
)
;
break
;
case
rtc
:
:
ReceivedPacket
:
:
kNotDecrypted
:
ASSERT_FALSE
(
certificate_
)
;
break
;
}
}
void
OnTransportSentPacket
(
rtc
:
:
PacketTransportInternal
*
const
rtc
:
:
SentPacket
&
sent_packet
)
{
sent_packet_
=
sent_packet
;
}
rtc
:
:
SentPacket
sent_packet
(
)
const
{
return
sent_packet_
;
}
void
OnFakeIceTransportReadPacket
(
rtc
:
:
PacketTransportInternal
*
const
rtc
:
:
ReceivedPacket
&
packet
)
{
ASSERT_EQ
(
packet
.
decryption_info
(
)
rtc
:
:
ReceivedPacket
:
:
kNotDecrypted
)
;
const
uint8_t
*
data
=
packet
.
payload
(
)
.
data
(
)
;
size_t
size
=
packet
.
payload
(
)
.
size
(
)
;
if
(
data
[
0
]
=
=
22
&
&
size
>
17
)
{
if
(
data
[
13
]
=
=
1
)
{
+
+
received_dtls_client_hellos_
;
}
else
if
(
data
[
13
]
=
=
2
)
{
+
+
received_dtls_server_hellos_
;
}
}
else
if
(
dtls_transport_
-
>
IsDtlsActive
(
)
&
&
!
(
data
[
0
]
>
=
20
&
&
data
[
0
]
<
=
22
)
)
{
ASSERT_TRUE
(
data
[
0
]
=
=
23
|
|
IsRtpLeadByte
(
data
[
0
]
)
)
;
if
(
data
[
0
]
=
=
23
)
{
ASSERT_TRUE
(
VerifyEncryptedPacket
(
data
size
)
)
;
}
else
if
(
IsRtpLeadByte
(
data
[
0
]
)
)
{
ASSERT_TRUE
(
VerifyPacket
(
packet
.
payload
(
)
NULL
)
)
;
}
}
}
private
:
std
:
:
string
name_
;
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
certificate_
;
std
:
:
unique_ptr
<
FakeIceTransport
>
fake_ice_transport_
;
std
:
:
unique_ptr
<
DtlsTransport
>
dtls_transport_
;
size_t
packet_size_
=
0u
;
std
:
:
set
<
int
>
received_
;
rtc
:
:
SSLProtocolVersion
ssl_max_version_
=
rtc
:
:
SSL_PROTOCOL_DTLS_12
;
int
received_dtls_client_hellos_
=
0
;
int
received_dtls_server_hellos_
=
0
;
rtc
:
:
SentPacket
sent_packet_
;
}
;
class
DtlsTransportTestBase
{
public
:
DtlsTransportTestBase
(
)
:
client1_
(
"
P1
"
)
client2_
(
"
P2
"
)
use_dtls_
(
false
)
{
}
void
SetMaxProtocolVersions
(
rtc
:
:
SSLProtocolVersion
c1
rtc
:
:
SSLProtocolVersion
c2
)
{
client1_
.
SetupMaxProtocolVersion
(
c1
)
;
client2_
.
SetupMaxProtocolVersion
(
c2
)
;
}
void
PrepareDtls
(
rtc
:
:
KeyType
key_type
)
{
client1_
.
CreateCertificate
(
key_type
)
;
client2_
.
CreateCertificate
(
key_type
)
;
use_dtls_
=
true
;
}
bool
Connect
(
bool
client1_server
=
true
)
{
Negotiate
(
client1_server
)
;
EXPECT_TRUE
(
client1_
.
Connect
(
&
client2_
false
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
client1_
.
dtls_transport
(
)
-
>
writable
(
)
&
&
client2_
.
dtls_transport
(
)
-
>
writable
(
)
kTimeout
fake_clock_
)
;
if
(
!
client1_
.
dtls_transport
(
)
-
>
writable
(
)
|
|
!
client2_
.
dtls_transport
(
)
-
>
writable
(
)
)
return
false
;
if
(
use_dtls_
)
{
client1_
.
CheckRole
(
client1_server
?
rtc
:
:
SSL_SERVER
:
rtc
:
:
SSL_CLIENT
)
;
client2_
.
CheckRole
(
client1_server
?
rtc
:
:
SSL_CLIENT
:
rtc
:
:
SSL_SERVER
)
;
}
if
(
use_dtls_
)
{
client1_
.
CheckSrtp
(
rtc
:
:
kSrtpAes128CmSha1_80
)
;
client2_
.
CheckSrtp
(
rtc
:
:
kSrtpAes128CmSha1_80
)
;
}
else
{
client1_
.
CheckSrtp
(
rtc
:
:
kSrtpInvalidCryptoSuite
)
;
client2_
.
CheckSrtp
(
rtc
:
:
kSrtpInvalidCryptoSuite
)
;
}
client1_
.
CheckSsl
(
)
;
client2_
.
CheckSsl
(
)
;
return
true
;
}
void
Negotiate
(
bool
client1_server
=
true
)
{
client1_
.
SetupTransports
(
ICEROLE_CONTROLLING
)
;
client2_
.
SetupTransports
(
ICEROLE_CONTROLLED
)
;
client1_
.
dtls_transport
(
)
-
>
SetDtlsRole
(
client1_server
?
rtc
:
:
SSL_SERVER
:
rtc
:
:
SSL_CLIENT
)
;
client2_
.
dtls_transport
(
)
-
>
SetDtlsRole
(
client1_server
?
rtc
:
:
SSL_CLIENT
:
rtc
:
:
SSL_SERVER
)
;
if
(
client2_
.
certificate
(
)
)
{
SetRemoteFingerprintFromCert
(
client1_
.
dtls_transport
(
)
client2_
.
certificate
(
)
)
;
}
if
(
client1_
.
certificate
(
)
)
{
SetRemoteFingerprintFromCert
(
client2_
.
dtls_transport
(
)
client1_
.
certificate
(
)
)
;
}
}
void
TestTransfer
(
size_t
size
size_t
count
bool
srtp
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Expect
packets
size
=
"
<
<
size
;
client2_
.
ExpectPackets
(
size
)
;
client1_
.
SendPackets
(
size
count
srtp
)
;
EXPECT_EQ_SIMULATED_WAIT
(
count
client2_
.
NumPacketsReceived
(
)
kTimeout
fake_clock_
)
;
}
protected
:
rtc
:
:
AutoThread
main_thread_
;
rtc
:
:
ScopedFakeClock
fake_clock_
;
DtlsTestClient
client1_
;
DtlsTestClient
client2_
;
bool
use_dtls_
;
rtc
:
:
SSLProtocolVersion
ssl_expected_version_
;
}
;
class
DtlsTransportTest
:
public
DtlsTransportTestBase
public
:
:
testing
:
:
Test
{
}
;
TEST_F
(
DtlsTransportTest
TestTransferRtp
)
{
ASSERT_TRUE
(
Connect
(
)
)
;
TestTransfer
(
1000
100
false
)
;
}
TEST_F
(
DtlsTransportTest
TestSignalSentPacket
)
{
ASSERT_TRUE
(
Connect
(
)
)
;
ASSERT_EQ
(
client1_
.
sent_packet
(
)
.
send_time_ms
-
1
)
;
TestTransfer
(
1000
100
false
)
;
EXPECT_EQ
(
kFakePacketId
client1_
.
sent_packet
(
)
.
packet_id
)
;
EXPECT_GE
(
client1_
.
sent_packet
(
)
.
send_time_ms
0
)
;
}
TEST_F
(
DtlsTransportTest
TestTransferSrtp
)
{
ASSERT_TRUE
(
Connect
(
)
)
;
TestTransfer
(
1000
100
true
)
;
}
TEST_F
(
DtlsTransportTest
TestTransferDtls
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
TestTransfer
(
1000
100
false
)
;
}
TEST_F
(
DtlsTransportTest
TestTransferDtlsCombineRecords
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
FakeIceTransport
*
transport
=
client1_
.
fake_ice_transport
(
)
;
transport
-
>
combine_outgoing_packets
(
true
)
;
TestTransfer
(
500
100
false
)
;
}
TEST_F
(
DtlsTransportTest
KeyingMaterialExporter
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
int
crypto_suite
;
EXPECT_TRUE
(
client1_
.
dtls_transport
(
)
-
>
GetSrtpCryptoSuite
(
&
crypto_suite
)
)
;
int
key_len
;
int
salt_len
;
EXPECT_TRUE
(
rtc
:
:
GetSrtpKeyAndSaltLengths
(
crypto_suite
&
key_len
&
salt_len
)
)
;
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
client1_out
(
2
*
(
key_len
+
salt_len
)
)
;
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
client2_out
(
2
*
(
key_len
+
salt_len
)
)
;
EXPECT_TRUE
(
client1_
.
dtls_transport
(
)
-
>
ExportSrtpKeyingMaterial
(
client1_out
)
)
;
EXPECT_TRUE
(
client2_
.
dtls_transport
(
)
-
>
ExportSrtpKeyingMaterial
(
client2_out
)
)
;
EXPECT_EQ
(
client1_out
client2_out
)
;
}
class
DtlsTransportVersionTest
:
public
DtlsTransportTestBase
public
:
:
testing
:
:
TestWithParam
<
:
:
testing
:
:
tuple
<
rtc
:
:
SSLProtocolVersion
rtc
:
:
SSLProtocolVersion
>
>
{
}
;
TEST_P
(
DtlsTransportVersionTest
TestCipherSuiteNegotiation
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
SetMaxProtocolVersions
(
:
:
testing
:
:
get
<
0
>
(
GetParam
(
)
)
:
:
testing
:
:
get
<
1
>
(
GetParam
(
)
)
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
TestCipherSuiteNegotiation
DtlsTransportVersionTest
:
:
testing
:
:
Combine
(
:
:
testing
:
:
Values
(
rtc
:
:
SSL_PROTOCOL_DTLS_10
rtc
:
:
SSL_PROTOCOL_DTLS_12
)
:
:
testing
:
:
Values
(
rtc
:
:
SSL_PROTOCOL_DTLS_10
rtc
:
:
SSL_PROTOCOL_DTLS_12
)
)
)
;
TEST_F
(
DtlsTransportTest
TestTransferDtlsSrtp
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
TestTransfer
(
1000
100
true
)
;
}
TEST_F
(
DtlsTransportTest
TestTransferDtlsInvalidSrtpPacket
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
EXPECT_EQ
(
-
1
client1_
.
SendInvalidSrtpPacket
(
100
)
)
;
}
TEST_F
(
DtlsTransportTest
TestTransferDtlsSrtpDemux
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
TestTransfer
(
1000
100
false
)
;
TestTransfer
(
1000
100
true
)
;
}
TEST_F
(
DtlsTransportTest
TestTransferDtlsSrtpAnswererIsPassive
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
false
)
)
;
TestTransfer
(
1000
100
true
)
;
}
TEST_F
(
DtlsTransportTest
TestRenegotiateBeforeConnect
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
Negotiate
(
)
;
Negotiate
(
)
;
EXPECT_TRUE
(
client1_
.
Connect
(
&
client2_
false
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
client1_
.
dtls_transport
(
)
-
>
writable
(
)
&
&
client2_
.
dtls_transport
(
)
-
>
writable
(
)
kTimeout
fake_clock_
)
;
TestTransfer
(
1000
100
true
)
;
}
TEST_F
(
DtlsTransportTest
TestCertificatesBeforeConnect
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
Negotiate
(
)
;
auto
certificate1
=
client1_
.
dtls_transport
(
)
-
>
GetLocalCertificate
(
)
;
auto
certificate2
=
client2_
.
dtls_transport
(
)
-
>
GetLocalCertificate
(
)
;
ASSERT_NE
(
certificate1
-
>
GetSSLCertificate
(
)
.
ToPEMString
(
)
certificate2
-
>
GetSSLCertificate
(
)
.
ToPEMString
(
)
)
;
ASSERT_FALSE
(
client1_
.
dtls_transport
(
)
-
>
GetRemoteSSLCertChain
(
)
)
;
ASSERT_FALSE
(
client2_
.
dtls_transport
(
)
-
>
GetRemoteSSLCertChain
(
)
)
;
}
TEST_F
(
DtlsTransportTest
TestCertificatesAfterConnect
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
ASSERT_TRUE
(
Connect
(
)
)
;
auto
certificate1
=
client1_
.
dtls_transport
(
)
-
>
GetLocalCertificate
(
)
;
auto
certificate2
=
client2_
.
dtls_transport
(
)
-
>
GetLocalCertificate
(
)
;
ASSERT_NE
(
certificate1
-
>
GetSSLCertificate
(
)
.
ToPEMString
(
)
certificate2
-
>
GetSSLCertificate
(
)
.
ToPEMString
(
)
)
;
std
:
:
unique_ptr
<
rtc
:
:
SSLCertChain
>
remote_cert1
=
client1_
.
dtls_transport
(
)
-
>
GetRemoteSSLCertChain
(
)
;
ASSERT_TRUE
(
remote_cert1
)
;
ASSERT_EQ
(
1u
remote_cert1
-
>
GetSize
(
)
)
;
ASSERT_EQ
(
remote_cert1
-
>
Get
(
0
)
.
ToPEMString
(
)
certificate2
-
>
GetSSLCertificate
(
)
.
ToPEMString
(
)
)
;
std
:
:
unique_ptr
<
rtc
:
:
SSLCertChain
>
remote_cert2
=
client2_
.
dtls_transport
(
)
-
>
GetRemoteSSLCertChain
(
)
;
ASSERT_TRUE
(
remote_cert2
)
;
ASSERT_EQ
(
1u
remote_cert2
-
>
GetSize
(
)
)
;
ASSERT_EQ
(
remote_cert2
-
>
Get
(
0
)
.
ToPEMString
(
)
certificate1
-
>
GetSSLCertificate
(
)
.
ToPEMString
(
)
)
;
}
TEST_F
(
DtlsTransportTest
TestRetransmissionSchedule
)
{
MAYBE_SKIP_TEST
(
IsBoringSsl
)
;
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
Negotiate
(
)
;
EXPECT_TRUE
(
client2_
.
Connect
(
&
client1_
true
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
client2_
.
fake_ice_transport
(
)
-
>
writable
(
)
kTimeout
fake_clock_
)
;
EXPECT_EQ_WAIT
(
1
client1_
.
received_dtls_client_hellos
(
)
kTimeout
)
;
EXPECT_FALSE
(
client1_
.
fake_ice_transport
(
)
-
>
writable
(
)
)
;
static
int
timeout_schedule_ms
[
]
=
{
50
100
200
400
800
1600
3200
6400
12800
25600
51200
60000
}
;
int
expected_hellos
=
1
;
for
(
size_t
i
=
0
;
i
<
(
sizeof
(
timeout_schedule_ms
)
/
sizeof
(
timeout_schedule_ms
[
0
]
)
)
;
+
+
i
)
{
fake_clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
timeout_schedule_ms
[
i
]
-
1
)
)
;
EXPECT_EQ
(
expected_hellos
client1_
.
received_dtls_client_hellos
(
)
)
;
fake_clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
1
)
)
;
EXPECT_EQ
(
+
+
expected_hellos
client1_
.
received_dtls_client_hellos
(
)
)
;
}
}
enum
DtlsTransportEvent
{
CALLER_RECEIVES_FINGERPRINT
CALLER_WRITABLE
CALLER_RECEIVES_CLIENTHELLO
HANDSHAKE_FINISHES
}
;
class
DtlsEventOrderingTest
:
public
DtlsTransportTestBase
public
:
:
testing
:
:
TestWithParam
<
:
:
testing
:
:
tuple
<
std
:
:
vector
<
DtlsTransportEvent
>
bool
>
>
{
protected
:
void
TestEventOrdering
(
const
std
:
:
vector
<
DtlsTransportEvent
>
&
events
bool
valid_fingerprint
)
{
PrepareDtls
(
rtc
:
:
KT_DEFAULT
)
;
int
simulated_delay_ms
=
10
;
client1_
.
SetupTransports
(
ICEROLE_CONTROLLING
simulated_delay_ms
)
;
client2_
.
SetupTransports
(
ICEROLE_CONTROLLED
simulated_delay_ms
)
;
client1_
.
dtls_transport
(
)
-
>
SetDtlsRole
(
rtc
:
:
SSL_SERVER
)
;
client2_
.
dtls_transport
(
)
-
>
SetDtlsRole
(
rtc
:
:
SSL_CLIENT
)
;
SetRemoteFingerprintFromCert
(
client2_
.
dtls_transport
(
)
client1_
.
certificate
(
)
)
;
for
(
DtlsTransportEvent
e
:
events
)
{
switch
(
e
)
{
case
CALLER_RECEIVES_FINGERPRINT
:
if
(
valid_fingerprint
)
{
SetRemoteFingerprintFromCert
(
client1_
.
dtls_transport
(
)
client2_
.
certificate
(
)
)
;
}
else
{
SetRemoteFingerprintFromCert
(
client1_
.
dtls_transport
(
)
client2_
.
certificate
(
)
true
)
;
}
break
;
case
CALLER_WRITABLE
:
EXPECT_TRUE
(
client1_
.
Connect
(
&
client2_
true
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
client1_
.
fake_ice_transport
(
)
-
>
writable
(
)
kTimeout
fake_clock_
)
;
break
;
case
CALLER_RECEIVES_CLIENTHELLO
:
EXPECT_EQ
(
0
client1_
.
received_dtls_client_hellos
(
)
)
;
EXPECT_TRUE
(
client2_
.
Connect
(
&
client1_
true
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
client2_
.
fake_ice_transport
(
)
-
>
writable
(
)
kTimeout
fake_clock_
)
;
EXPECT_EQ_SIMULATED_WAIT
(
1
client1_
.
received_dtls_client_hellos
(
)
kTimeout
fake_clock_
)
;
break
;
case
HANDSHAKE_FINISHES
:
EXPECT_FALSE
(
client1_
.
dtls_transport
(
)
-
>
IsDtlsConnected
(
)
|
|
client1_
.
dtls_transport
(
)
-
>
dtls_state
(
)
=
=
webrtc
:
:
DtlsTransportState
:
:
kFailed
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
client1_
.
dtls_transport
(
)
-
>
IsDtlsConnected
(
)
|
|
client1_
.
dtls_transport
(
)
-
>
dtls_state
(
)
=
=
webrtc
:
:
DtlsTransportState
:
:
kFailed
kTimeout
fake_clock_
)
;
break
;
}
}
webrtc
:
:
DtlsTransportState
expected_final_state
=
valid_fingerprint
?
webrtc
:
:
DtlsTransportState
:
:
kConnected
:
webrtc
:
:
DtlsTransportState
:
:
kFailed
;
EXPECT_EQ_SIMULATED_WAIT
(
expected_final_state
client1_
.
dtls_transport
(
)
-
>
dtls_state
(
)
kTimeout
fake_clock_
)
;
EXPECT_EQ_SIMULATED_WAIT
(
expected_final_state
client2_
.
dtls_transport
(
)
-
>
dtls_state
(
)
kTimeout
fake_clock_
)
;
EXPECT_EQ
(
valid_fingerprint
client1_
.
dtls_transport
(
)
-
>
writable
(
)
)
;
EXPECT_EQ
(
valid_fingerprint
client2_
.
dtls_transport
(
)
-
>
writable
(
)
)
;
EXPECT_EQ
(
1
client1_
.
received_dtls_client_hellos
(
)
)
;
EXPECT_EQ
(
1
client2_
.
received_dtls_server_hellos
(
)
)
;
if
(
valid_fingerprint
)
{
TestTransfer
(
1000
100
false
)
;
}
}
}
;
TEST_P
(
DtlsEventOrderingTest
TestEventOrdering
)
{
TestEventOrdering
(
:
:
testing
:
:
get
<
0
>
(
GetParam
(
)
)
:
:
testing
:
:
get
<
1
>
(
GetParam
(
)
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
TestEventOrdering
DtlsEventOrderingTest
:
:
testing
:
:
Combine
(
:
:
testing
:
:
Values
(
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_RECEIVES_FINGERPRINT
CALLER_WRITABLE
CALLER_RECEIVES_CLIENTHELLO
HANDSHAKE_FINISHES
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_WRITABLE
CALLER_RECEIVES_FINGERPRINT
CALLER_RECEIVES_CLIENTHELLO
HANDSHAKE_FINISHES
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_WRITABLE
CALLER_RECEIVES_CLIENTHELLO
CALLER_RECEIVES_FINGERPRINT
HANDSHAKE_FINISHES
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_WRITABLE
CALLER_RECEIVES_CLIENTHELLO
HANDSHAKE_FINISHES
CALLER_RECEIVES_FINGERPRINT
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_RECEIVES_FINGERPRINT
CALLER_RECEIVES_CLIENTHELLO
CALLER_WRITABLE
HANDSHAKE_FINISHES
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_RECEIVES_CLIENTHELLO
CALLER_RECEIVES_FINGERPRINT
CALLER_WRITABLE
HANDSHAKE_FINISHES
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_RECEIVES_CLIENTHELLO
CALLER_WRITABLE
CALLER_RECEIVES_FINGERPRINT
HANDSHAKE_FINISHES
}
std
:
:
vector
<
DtlsTransportEvent
>
{
CALLER_RECEIVES_CLIENTHELLO
CALLER_WRITABLE
HANDSHAKE_FINISHES
CALLER_RECEIVES_FINGERPRINT
}
)
:
:
testing
:
:
Bool
(
)
)
)
;
}
