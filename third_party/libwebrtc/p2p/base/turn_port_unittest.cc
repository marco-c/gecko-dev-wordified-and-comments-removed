#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
packet_socket_factory
.
h
"
#
include
"
api
/
test
/
mock_async_dns_resolver
.
h
"
#
include
"
api
/
test
/
rtc_error_matchers
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
p2p
/
base
/
connection_info
.
h
"
#
include
"
p2p
/
base
/
port
.
h
"
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
p2p
/
base
/
stun_request
.
h
"
#
include
"
p2p
/
client
/
relay_port_factory_interface
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
net_helpers
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
wait_until
.
h
"
#
if
defined
(
WEBRTC_POSIX
)
#
include
<
dirent
.
h
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
endif
#
include
<
list
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
p2p
/
base
/
stun_port
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
base
/
turn_port
.
h
"
#
include
"
p2p
/
test
/
mock_dns_resolving_packet_socket_factory
.
h
"
#
include
"
p2p
/
test
/
test_turn_customizer
.
h
"
#
include
"
p2p
/
test
/
test_turn_server
.
h
"
#
include
"
p2p
/
test
/
turn_server
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
net_helper
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
scoped_key_value_config
.
h
"
namespace
{
using
:
:
webrtc
:
:
SocketAddress
;
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
DoAll
;
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
IsTrue
;
using
:
:
testing
:
:
Ne
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
ReturnPointee
;
using
:
:
testing
:
:
SetArgPointee
;
using
:
:
webrtc
:
:
IceCandidateType
;
static
const
SocketAddress
kLocalAddr1
(
"
11
.
11
.
11
.
11
"
0
)
;
static
const
SocketAddress
kLocalAddr2
(
"
22
.
22
.
22
.
22
"
0
)
;
static
const
SocketAddress
kLocalIPv6Addr
(
"
2401
:
fa00
:
4
:
1000
:
be30
:
5bff
:
fee5
:
c3
"
0
)
;
static
const
SocketAddress
kLocalIPv6Addr2
(
"
2401
:
fa00
:
4
:
2000
:
be30
:
5bff
:
fee5
:
d4
"
0
)
;
static
const
SocketAddress
kTurnUdpIntAddr
(
"
99
.
99
.
99
.
3
"
webrtc
:
:
TURN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnTcpIntAddr
(
"
99
.
99
.
99
.
4
"
webrtc
:
:
TURN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnUdpExtAddr
(
"
99
.
99
.
99
.
5
"
0
)
;
static
const
SocketAddress
kTurnAlternateIntAddr
(
"
99
.
99
.
99
.
6
"
webrtc
:
:
TURN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnDangerousAddr
(
"
99
.
99
.
99
.
7
"
81
)
;
static
const
SocketAddress
kTurnPort53Addr
(
"
99
.
99
.
99
.
7
"
53
)
;
static
const
SocketAddress
kTurnPort80Addr
(
"
99
.
99
.
99
.
7
"
80
)
;
static
const
SocketAddress
kTurnPort443Addr
(
"
99
.
99
.
99
.
7
"
443
)
;
static
const
SocketAddress
kTurnIntAddr
(
"
99
.
99
.
99
.
7
"
webrtc
:
:
TURN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnIPv6IntAddr
(
"
2400
:
4030
:
2
:
2c00
:
be30
:
abcd
:
efab
:
cdef
"
webrtc
:
:
TURN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnUdpIPv6IntAddr
(
"
2400
:
4030
:
1
:
2c00
:
be30
:
abcd
:
efab
:
cdef
"
webrtc
:
:
TURN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnInvalidAddr
(
"
www
.
google
.
invalid
.
"
3478
)
;
static
const
SocketAddress
kTurnValidAddr
(
"
www
.
google
.
valid
.
"
3478
)
;
static
const
char
kCandidateFoundation
[
]
=
"
foundation
"
;
static
const
char
kIceUfrag1
[
]
=
"
TESTICEUFRAG0001
"
;
static
const
char
kIceUfrag2
[
]
=
"
TESTICEUFRAG0002
"
;
static
const
char
kIcePwd1
[
]
=
"
TESTICEPWD00000000000001
"
;
static
const
char
kIcePwd2
[
]
=
"
TESTICEPWD00000000000002
"
;
static
const
char
kTurnUsername
[
]
=
"
test
"
;
static
const
char
kTurnPassword
[
]
=
"
test
"
;
static
constexpr
unsigned
int
kSimulatedRtt
=
50
;
static
constexpr
unsigned
int
kConnectionDestructionDelay
=
1
;
static
constexpr
unsigned
int
kResolverTimeout
=
10000
;
constexpr
uint64_t
kTiebreakerDefault
=
44444
;
static
const
cricket
:
:
ProtocolAddress
kTurnUdpProtoAddr
(
kTurnUdpIntAddr
webrtc
:
:
PROTO_UDP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnTcpProtoAddr
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnTlsProtoAddr
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnUdpIPv6ProtoAddr
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnDangerousProtoAddr
(
kTurnDangerousAddr
webrtc
:
:
PROTO_TCP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnPort53ProtoAddr
(
kTurnPort53Addr
webrtc
:
:
PROTO_TCP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnPort80ProtoAddr
(
kTurnPort80Addr
webrtc
:
:
PROTO_TCP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnPort443ProtoAddr
(
kTurnPort443Addr
webrtc
:
:
PROTO_TCP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnPortInvalidHostnameProtoAddr
(
kTurnInvalidAddr
webrtc
:
:
PROTO_UDP
)
;
static
const
cricket
:
:
ProtocolAddress
kTurnPortValidHostnameProtoAddr
(
kTurnValidAddr
webrtc
:
:
PROTO_UDP
)
;
#
if
defined
(
WEBRTC_LINUX
)
&
&
!
defined
(
WEBRTC_ANDROID
)
static
int
GetFDCount
(
)
{
struct
dirent
*
dp
;
int
fd_count
=
0
;
DIR
*
dir
=
opendir
(
"
/
proc
/
self
/
fd
/
"
)
;
while
(
(
dp
=
readdir
(
dir
)
)
!
=
NULL
)
{
if
(
dp
-
>
d_name
[
0
]
=
=
'
.
'
)
continue
;
+
+
fd_count
;
}
closedir
(
dir
)
;
return
fd_count
;
}
#
endif
}
namespace
cricket
{
class
TurnPortTestVirtualSocketServer
:
public
webrtc
:
:
VirtualSocketServer
{
public
:
TurnPortTestVirtualSocketServer
(
)
{
set_delay_mean
(
kSimulatedRtt
/
2
)
;
UpdateDelayDistribution
(
)
;
}
using
webrtc
:
:
VirtualSocketServer
:
:
LookupBinding
;
}
;
class
TestConnectionWrapper
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
TestConnectionWrapper
(
Connection
*
conn
)
:
connection_
(
conn
)
{
conn
-
>
SignalDestroyed
.
connect
(
this
&
TestConnectionWrapper
:
:
OnConnectionDestroyed
)
;
}
~
TestConnectionWrapper
(
)
{
if
(
connection_
)
{
connection_
-
>
SignalDestroyed
.
disconnect
(
this
)
;
}
}
Connection
*
connection
(
)
{
return
connection_
;
}
private
:
void
OnConnectionDestroyed
(
Connection
*
conn
)
{
ASSERT_TRUE
(
conn
=
=
connection_
)
;
connection_
=
nullptr
;
}
Connection
*
connection_
;
}
;
class
TurnPortTest
:
public
:
:
testing
:
:
Test
public
TurnPort
:
:
CallbacksForTest
public
sigslot
:
:
has_slots
<
>
{
public
:
TurnPortTest
(
)
:
ss_
(
new
TurnPortTestVirtualSocketServer
(
)
)
main_
(
ss_
.
get
(
)
)
turn_server_
(
&
main_
ss_
.
get
(
)
kTurnUdpIntAddr
kTurnUdpExtAddr
)
socket_factory_
(
ss_
.
get
(
)
)
{
fake_clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
1
)
)
;
}
void
OnTurnPortComplete
(
Port
*
port
)
{
turn_ready_
=
true
;
}
void
OnTurnPortError
(
Port
*
port
)
{
turn_error_
=
true
;
}
void
OnCandidateError
(
Port
*
port
const
cricket
:
:
IceCandidateErrorEvent
&
event
)
{
error_event_
=
event
;
}
void
OnTurnUnknownAddress
(
webrtc
:
:
PortInterface
*
port
const
SocketAddress
&
addr
webrtc
:
:
ProtocolType
proto
IceMessage
*
msg
const
std
:
:
string
&
rf
bool
)
{
turn_unknown_address_
=
true
;
}
void
OnUdpPortComplete
(
Port
*
port
)
{
udp_ready_
=
true
;
}
void
OnSocketReadPacket
(
webrtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
ReceivedPacket
&
packet
)
{
turn_port_
-
>
HandleIncomingPacket
(
socket
packet
)
;
}
void
OnTurnPortDestroyed
(
webrtc
:
:
PortInterface
*
port
)
{
turn_port_destroyed_
=
true
;
}
void
OnTurnCreatePermissionResult
(
int
code
)
override
{
turn_create_permission_success_
=
(
code
=
=
0
)
;
}
void
OnTurnRefreshResult
(
int
code
)
override
{
turn_refresh_success_
=
(
code
=
=
0
)
;
}
void
OnTurnPortClosed
(
)
override
{
turn_port_closed_
=
true
;
}
void
OnConnectionSignalDestroyed
(
Connection
*
connection
)
{
connection
-
>
DeregisterReceivedPacketCallback
(
)
;
}
webrtc
:
:
Socket
*
CreateServerSocket
(
const
SocketAddress
addr
)
{
webrtc
:
:
Socket
*
socket
=
ss_
-
>
CreateSocket
(
AF_INET
SOCK_STREAM
)
;
EXPECT_GE
(
socket
-
>
Bind
(
addr
)
0
)
;
EXPECT_GE
(
socket
-
>
Listen
(
5
)
0
)
;
return
socket
;
}
webrtc
:
:
Network
*
MakeNetwork
(
const
SocketAddress
&
addr
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
addr
.
ipaddr
(
)
)
;
return
&
networks_
.
back
(
)
;
}
bool
CreateTurnPort
(
absl
:
:
string_view
username
absl
:
:
string_view
password
const
ProtocolAddress
&
server_address
)
{
return
CreateTurnPortWithAllParams
(
MakeNetwork
(
kLocalAddr1
)
username
password
server_address
)
;
}
bool
CreateTurnPort
(
const
webrtc
:
:
SocketAddress
&
local_address
absl
:
:
string_view
username
absl
:
:
string_view
password
const
ProtocolAddress
&
server_address
)
{
return
CreateTurnPortWithAllParams
(
MakeNetwork
(
local_address
)
username
password
server_address
)
;
}
bool
CreateTurnPortWithNetwork
(
const
webrtc
:
:
Network
*
network
absl
:
:
string_view
username
absl
:
:
string_view
password
const
ProtocolAddress
&
server_address
)
{
return
CreateTurnPortWithAllParams
(
network
username
password
server_address
)
;
}
bool
CreateTurnPortWithAllParams
(
const
webrtc
:
:
Network
*
network
absl
:
:
string_view
username
absl
:
:
string_view
password
const
ProtocolAddress
&
server_address
)
{
webrtc
:
:
RelayServerConfig
config
;
config
.
credentials
=
webrtc
:
:
RelayCredentials
(
username
password
)
;
CreateRelayPortArgs
args
;
args
.
network_thread
=
&
main_
;
args
.
socket_factory
=
socket_factory
(
)
;
args
.
network
=
network
;
args
.
username
=
kIceUfrag1
;
args
.
password
=
kIcePwd1
;
args
.
server_address
=
&
server_address
;
args
.
config
=
&
config
;
args
.
turn_customizer
=
turn_customizer_
.
get
(
)
;
args
.
field_trials
=
&
field_trials_
;
turn_port_
=
TurnPort
:
:
Create
(
args
0
0
)
;
if
(
!
turn_port_
)
{
return
false
;
}
turn_port_
-
>
SetIceRole
(
ICEROLE_CONTROLLING
)
;
turn_port_
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
ConnectSignals
(
)
;
if
(
server_address
.
proto
=
=
webrtc
:
:
PROTO_TLS
)
{
turn_port_
-
>
SetTlsCertPolicy
(
webrtc
:
:
TlsCertPolicy
:
:
TLS_CERT_POLICY_INSECURE_NO_CHECK
)
;
}
return
true
;
}
void
CreateSharedTurnPort
(
absl
:
:
string_view
username
absl
:
:
string_view
password
const
ProtocolAddress
&
server_address
)
{
RTC_CHECK
(
server_address
.
proto
=
=
webrtc
:
:
PROTO_UDP
)
;
if
(
!
socket_
)
{
socket_
.
reset
(
socket_factory
(
)
-
>
CreateUdpSocket
(
webrtc
:
:
SocketAddress
(
kLocalAddr1
.
ipaddr
(
)
0
)
0
0
)
)
;
ASSERT_TRUE
(
socket_
!
=
NULL
)
;
socket_
-
>
RegisterReceivedPacketCallback
(
[
&
]
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
ReceivedPacket
&
packet
)
{
OnSocketReadPacket
(
socket
packet
)
;
}
)
;
}
webrtc
:
:
RelayServerConfig
config
;
config
.
credentials
=
webrtc
:
:
RelayCredentials
(
username
password
)
;
CreateRelayPortArgs
args
;
args
.
network_thread
=
&
main_
;
args
.
socket_factory
=
socket_factory
(
)
;
args
.
network
=
MakeNetwork
(
kLocalAddr1
)
;
args
.
username
=
kIceUfrag1
;
args
.
password
=
kIcePwd1
;
args
.
server_address
=
&
server_address
;
args
.
config
=
&
config
;
args
.
turn_customizer
=
turn_customizer_
.
get
(
)
;
args
.
field_trials
=
&
field_trials_
;
turn_port_
=
TurnPort
:
:
Create
(
args
socket_
.
get
(
)
)
;
turn_port_
-
>
SetIceRole
(
ICEROLE_CONTROLLING
)
;
turn_port_
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
ConnectSignals
(
)
;
}
void
ConnectSignals
(
)
{
turn_port_
-
>
SignalPortComplete
.
connect
(
this
&
TurnPortTest
:
:
OnTurnPortComplete
)
;
turn_port_
-
>
SignalPortError
.
connect
(
this
&
TurnPortTest
:
:
OnTurnPortError
)
;
turn_port_
-
>
SignalCandidateError
.
connect
(
this
&
TurnPortTest
:
:
OnCandidateError
)
;
turn_port_
-
>
SignalUnknownAddress
.
connect
(
this
&
TurnPortTest
:
:
OnTurnUnknownAddress
)
;
turn_port_
-
>
SubscribePortDestroyed
(
[
this
]
(
PortInterface
*
port
)
{
OnTurnPortDestroyed
(
port
)
;
}
)
;
turn_port_
-
>
SetCallbacksForTest
(
this
)
;
}
void
CreateUdpPort
(
)
{
CreateUdpPort
(
kLocalAddr2
)
;
}
void
CreateUdpPort
(
const
SocketAddress
&
address
)
{
udp_port_
=
UDPPort
:
:
Create
(
{
.
network_thread
=
&
main_
.
socket_factory
=
socket_factory
(
)
.
network
=
MakeNetwork
(
address
)
.
ice_username_fragment
=
kIceUfrag2
.
ice_password
=
kIcePwd2
.
field_trials
=
&
field_trials_
}
0
0
false
std
:
:
nullopt
)
;
udp_port_
-
>
SetIceRole
(
ICEROLE_CONTROLLED
)
;
udp_port_
-
>
SetIceTiebreaker
(
kTiebreakerDefault
)
;
udp_port_
-
>
SignalPortComplete
.
connect
(
this
&
TurnPortTest
:
:
OnUdpPortComplete
)
;
}
void
PrepareTurnAndUdpPorts
(
webrtc
:
:
ProtocolType
protocol_type
)
{
ASSERT_TRUE
(
turn_port_
!
=
nullptr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
CreateUdpPort
(
)
;
udp_port_
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
udp_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
int
TimeToConnect
(
webrtc
:
:
ProtocolType
protocol_type
)
{
switch
(
protocol_type
)
{
case
webrtc
:
:
PROTO_TCP
:
return
kSimulatedRtt
/
2
;
case
webrtc
:
:
PROTO_TLS
:
return
2
*
kSimulatedRtt
+
TimeToConnect
(
webrtc
:
:
PROTO_TCP
)
;
case
webrtc
:
:
PROTO_UDP
:
default
:
return
0
;
}
}
int
TimeToGetTurnCandidate
(
webrtc
:
:
ProtocolType
protocol_type
)
{
return
2
*
kSimulatedRtt
+
TimeToConnect
(
protocol_type
)
;
}
int
TimeToGetAlternateTurnCandidate
(
webrtc
:
:
ProtocolType
protocol_type
)
{
return
3
*
kSimulatedRtt
+
2
*
TimeToConnect
(
protocol_type
)
;
}
bool
CheckConnectionFailedAndPruned
(
Connection
*
conn
)
{
return
conn
&
&
!
conn
-
>
active
(
)
&
&
conn
-
>
state
(
)
=
=
IceCandidatePairState
:
:
FAILED
;
}
bool
CheckAllConnectionsFailedAndPruned
(
)
{
auto
&
connections
=
turn_port_
-
>
connections
(
)
;
if
(
connections
.
empty
(
)
)
{
return
false
;
}
for
(
const
auto
&
kv
:
connections
)
{
if
(
!
CheckConnectionFailedAndPruned
(
kv
.
second
)
)
{
return
false
;
}
}
return
true
;
}
void
TestTurnAllocateSucceeds
(
unsigned
int
timeout
)
{
ASSERT_TRUE
(
turn_port_
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
timeout
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
1U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
EXPECT_EQ
(
kTurnUdpExtAddr
.
ipaddr
(
)
turn_port_
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
EXPECT_NE
(
0
turn_port_
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
port
(
)
)
;
}
void
TestReconstructedServerUrl
(
webrtc
:
:
ProtocolType
protocol_type
absl
:
:
string_view
expected_url
)
{
ASSERT_TRUE
(
turn_port_
)
;
turn_port_
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
1U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
EXPECT_EQ
(
turn_port_
-
>
Candidates
(
)
[
0
]
.
url
(
)
expected_url
)
;
}
void
TestTurnAlternateServer
(
webrtc
:
:
ProtocolType
protocol_type
)
{
std
:
:
vector
<
webrtc
:
:
SocketAddress
>
redirect_addresses
;
redirect_addresses
.
push_back
(
kTurnAlternateIntAddr
)
;
webrtc
:
:
TestTurnRedirector
redirector
(
redirect_addresses
)
;
turn_server_
.
AddInternalSocket
(
kTurnIntAddr
protocol_type
)
;
turn_server_
.
AddInternalSocket
(
kTurnAlternateIntAddr
protocol_type
)
;
turn_server_
.
set_redirect_hook
(
&
redirector
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnIntAddr
protocol_type
)
)
;
const
SocketAddress
old_addr
=
turn_port_
-
>
server_address
(
)
.
address
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetAlternateTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
const
SocketAddress
new_addr
=
turn_port_
-
>
server_address
(
)
.
address
;
EXPECT_NE
(
old_addr
new_addr
)
;
ASSERT_EQ
(
1U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
EXPECT_EQ
(
kTurnUdpExtAddr
.
ipaddr
(
)
turn_port_
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
ipaddr
(
)
)
;
EXPECT_NE
(
0
turn_port_
-
>
Candidates
(
)
[
0
]
.
address
(
)
.
port
(
)
)
;
}
void
TestTurnAlternateServerV4toV6
(
webrtc
:
:
ProtocolType
protocol_type
)
{
std
:
:
vector
<
webrtc
:
:
SocketAddress
>
redirect_addresses
;
redirect_addresses
.
push_back
(
kTurnIPv6IntAddr
)
;
webrtc
:
:
TestTurnRedirector
redirector
(
redirect_addresses
)
;
turn_server_
.
AddInternalSocket
(
kTurnIntAddr
protocol_type
)
;
turn_server_
.
set_redirect_hook
(
&
redirector
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnIntAddr
protocol_type
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
+
TimeToConnect
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
void
TestTurnAlternateServerPingPong
(
webrtc
:
:
ProtocolType
protocol_type
)
{
std
:
:
vector
<
webrtc
:
:
SocketAddress
>
redirect_addresses
;
redirect_addresses
.
push_back
(
kTurnAlternateIntAddr
)
;
redirect_addresses
.
push_back
(
kTurnIntAddr
)
;
webrtc
:
:
TestTurnRedirector
redirector
(
redirect_addresses
)
;
turn_server_
.
AddInternalSocket
(
kTurnIntAddr
protocol_type
)
;
turn_server_
.
AddInternalSocket
(
kTurnAlternateIntAddr
protocol_type
)
;
turn_server_
.
set_redirect_hook
(
&
redirector
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnIntAddr
protocol_type
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetAlternateTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
webrtc
:
:
SocketAddress
address
;
EXPECT_FALSE
(
redirector
.
ShouldRedirect
(
address
&
address
)
)
;
}
void
TestTurnAlternateServerDetectRepetition
(
webrtc
:
:
ProtocolType
protocol_type
)
{
std
:
:
vector
<
webrtc
:
:
SocketAddress
>
redirect_addresses
;
redirect_addresses
.
push_back
(
kTurnAlternateIntAddr
)
;
redirect_addresses
.
push_back
(
kTurnAlternateIntAddr
)
;
webrtc
:
:
TestTurnRedirector
redirector
(
redirect_addresses
)
;
turn_server_
.
AddInternalSocket
(
kTurnIntAddr
protocol_type
)
;
turn_server_
.
AddInternalSocket
(
kTurnAlternateIntAddr
protocol_type
)
;
turn_server_
.
set_redirect_hook
(
&
redirector
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnIntAddr
protocol_type
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetAlternateTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
}
void
TestTurnAlternateServerLoopback
(
webrtc
:
:
ProtocolType
protocol_type
bool
ipv6
)
{
const
SocketAddress
&
local_address
=
ipv6
?
kLocalIPv6Addr
:
kLocalAddr1
;
const
SocketAddress
&
server_address
=
ipv6
?
kTurnIPv6IntAddr
:
kTurnIntAddr
;
std
:
:
vector
<
webrtc
:
:
SocketAddress
>
redirect_addresses
;
SocketAddress
loopback_address
(
ipv6
?
"
:
:
1
"
:
"
127
.
1
.
2
.
3
"
webrtc
:
:
TURN_SERVER_PORT
)
;
redirect_addresses
.
push_back
(
loopback_address
)
;
std
:
:
unique_ptr
<
webrtc
:
:
Socket
>
loopback_socket
(
ss_
-
>
CreateSocket
(
AF_INET
protocol_type
=
=
webrtc
:
:
PROTO_UDP
?
SOCK_DGRAM
:
SOCK_STREAM
)
)
;
ASSERT_NE
(
nullptr
loopback_socket
.
get
(
)
)
;
ASSERT_EQ
(
0
loopback_socket
-
>
Bind
(
loopback_address
)
)
;
if
(
protocol_type
=
=
webrtc
:
:
PROTO_TCP
)
{
ASSERT_EQ
(
0
loopback_socket
-
>
Listen
(
1
)
)
;
}
webrtc
:
:
TestTurnRedirector
redirector
(
redirect_addresses
)
;
turn_server_
.
AddInternalSocket
(
server_address
protocol_type
)
;
turn_server_
.
set_redirect_hook
(
&
redirector
)
;
CreateTurnPort
(
local_address
kTurnUsername
kTurnPassword
ProtocolAddress
(
server_address
protocol_type
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
false
kSimulatedRtt
fake_clock_
)
;
if
(
protocol_type
=
=
webrtc
:
:
PROTO_UDP
)
{
char
buf
[
1
]
;
EXPECT_EQ
(
-
1
loopback_socket
-
>
Recv
(
&
buf
1
nullptr
)
)
;
}
else
{
std
:
:
unique_ptr
<
webrtc
:
:
Socket
>
accepted_socket
(
loopback_socket
-
>
Accept
(
nullptr
)
)
;
EXPECT_EQ
(
nullptr
accepted_socket
.
get
(
)
)
;
}
}
void
TestTurnConnection
(
webrtc
:
:
ProtocolType
protocol_type
)
{
PrepareTurnAndUdpPorts
(
protocol_type
)
;
ASSERT_GE
(
turn_port_
-
>
Candidates
(
)
.
size
(
)
1U
)
;
Connection
*
conn1
=
udp_port_
-
>
CreateConnection
(
turn_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
!
=
NULL
)
;
conn1
-
>
Ping
(
0
)
;
SIMULATED_WAIT
(
!
turn_unknown_address_
kSimulatedRtt
*
2
fake_clock_
)
;
EXPECT_FALSE
(
turn_unknown_address_
)
;
EXPECT_FALSE
(
conn1
-
>
receiving
(
)
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
conn1
-
>
write_state
(
)
)
;
Connection
*
conn2
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn2
!
=
NULL
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_create_permission_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
conn1
-
>
receiving
(
)
)
;
EXPECT_TRUE
(
conn2
-
>
receiving
(
)
)
;
EXPECT_EQ
(
Connection
:
:
STATE_WRITE_INIT
conn1
-
>
write_state
(
)
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
conn2
-
>
receiving
(
)
)
;
}
void
TestDestroyTurnConnection
(
)
{
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_UDP
)
;
Connection
*
conn1
=
udp_port_
-
>
CreateConnection
(
turn_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
conn2
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
turn_port_
-
>
set_timeout_delay
(
10
*
60
*
1000
)
;
ASSERT_TRUE
(
conn2
!
=
NULL
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_create_permission_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
turn_unknown_address_
)
;
turn_port_
-
>
DestroyConnection
(
conn2
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_unknown_address_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
turn_unknown_address_
=
false
;
fake_clock_
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
5
*
60
)
)
;
std
:
:
string
pwd
=
conn1
-
>
remote_password_for_test
(
)
;
conn1
-
>
set_remote_password_for_test
(
"
bad
"
)
;
auto
msg
=
conn1
-
>
BuildPingRequestForTest
(
)
;
webrtc
:
:
ByteBufferWriter
buf
;
msg
-
>
Write
(
&
buf
)
;
conn1
-
>
Send
(
buf
.
Data
(
)
buf
.
Length
(
)
options
)
;
conn1
-
>
set_remote_password_for_test
(
pwd
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_unknown_address_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
receiving
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
void
TestTurnSendData
(
webrtc
:
:
ProtocolType
protocol_type
)
{
PrepareTurnAndUdpPorts
(
protocol_type
)
;
Connection
*
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
conn2
=
udp_port_
-
>
CreateConnection
(
turn_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
!
=
NULL
)
;
ASSERT_TRUE
(
conn2
!
=
NULL
)
;
conn1
-
>
RegisterReceivedPacketCallback
(
[
&
]
(
Connection
*
connection
const
rtc
:
:
ReceivedPacket
&
packet
)
{
turn_packets_
.
push_back
(
rtc
:
:
Buffer
(
packet
.
payload
(
)
.
data
(
)
packet
.
payload
(
)
.
size
(
)
)
)
;
}
)
;
conn1
-
>
SignalDestroyed
.
connect
(
this
&
TurnPortTest
:
:
OnConnectionSignalDestroyed
)
;
conn2
-
>
RegisterReceivedPacketCallback
(
[
&
]
(
Connection
*
connection
const
rtc
:
:
ReceivedPacket
&
packet
)
{
udp_packets_
.
push_back
(
rtc
:
:
Buffer
(
packet
.
payload
(
)
.
data
(
)
packet
.
payload
(
)
.
size
(
)
)
)
;
}
)
;
conn2
-
>
SignalDestroyed
.
connect
(
this
&
TurnPortTest
:
:
OnConnectionSignalDestroyed
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
size_t
num_packets
=
256
;
for
(
size_t
i
=
0
;
i
<
num_packets
;
+
+
i
)
{
unsigned
char
buf
[
256
]
=
{
0
}
;
for
(
size_t
j
=
0
;
j
<
i
+
1
;
+
+
j
)
{
buf
[
j
]
=
0xFF
-
static_cast
<
unsigned
char
>
(
j
)
;
}
conn1
-
>
Send
(
buf
i
+
1
options
)
;
conn2
-
>
Send
(
buf
i
+
1
options
)
;
SIMULATED_WAIT
(
false
kSimulatedRtt
fake_clock_
)
;
}
ASSERT_EQ
(
num_packets
turn_packets_
.
size
(
)
)
;
ASSERT_EQ
(
num_packets
udp_packets_
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
num_packets
;
+
+
i
)
{
EXPECT_EQ
(
i
+
1
turn_packets_
[
i
]
.
size
(
)
)
;
EXPECT_EQ
(
i
+
1
udp_packets_
[
i
]
.
size
(
)
)
;
EXPECT_EQ
(
turn_packets_
[
i
]
udp_packets_
[
i
]
)
;
}
}
void
TestTurnReleaseAllocation
(
webrtc
:
:
ProtocolType
protocol_type
)
{
PrepareTurnAndUdpPorts
(
protocol_type
)
;
turn_port_
.
reset
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_server_
.
server
(
)
-
>
allocations
(
)
.
size
(
)
;
}
Eq
(
0U
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
void
TestTurnGracefulReleaseAllocation
(
webrtc
:
:
ProtocolType
protocol_type
)
{
PrepareTurnAndUdpPorts
(
protocol_type
)
;
Connection
*
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
conn2
=
udp_port_
-
>
CreateConnection
(
turn_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
!
=
NULL
)
;
ASSERT_TRUE
(
conn2
!
=
NULL
)
;
conn1
-
>
RegisterReceivedPacketCallback
(
[
&
]
(
Connection
*
connection
const
rtc
:
:
ReceivedPacket
&
packet
)
{
turn_packets_
.
push_back
(
rtc
:
:
Buffer
(
packet
.
payload
(
)
.
data
(
)
packet
.
payload
(
)
.
size
(
)
)
)
;
}
)
;
conn1
-
>
SignalDestroyed
.
connect
(
this
&
TurnPortTest
:
:
OnConnectionSignalDestroyed
)
;
conn2
-
>
RegisterReceivedPacketCallback
(
[
&
]
(
Connection
*
connection
const
rtc
:
:
ReceivedPacket
&
packet
)
{
udp_packets_
.
push_back
(
rtc
:
:
Buffer
(
packet
.
payload
(
)
.
data
(
)
packet
.
payload
(
)
.
size
(
)
)
)
;
}
)
;
conn2
-
>
SignalDestroyed
.
connect
(
this
&
TurnPortTest
:
:
OnConnectionSignalDestroyed
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
unsigned
char
buf
[
256
]
=
{
0
}
;
conn2
-
>
Send
(
buf
sizeof
(
buf
)
options
)
;
turn_port_
-
>
Release
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_port_closed_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
1ul
turn_packets_
.
size
(
)
)
;
EXPECT_EQ
(
sizeof
(
buf
)
turn_packets_
[
0
]
.
size
(
)
)
;
EXPECT_EQ
(
0U
turn_server_
.
server
(
)
-
>
allocations
(
)
.
size
(
)
)
;
}
protected
:
virtual
webrtc
:
:
PacketSocketFactory
*
socket_factory
(
)
{
return
&
socket_factory_
;
}
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials_
;
webrtc
:
:
ScopedFakeClock
fake_clock_
;
std
:
:
list
<
webrtc
:
:
Network
>
networks_
;
std
:
:
unique_ptr
<
TurnPortTestVirtualSocketServer
>
ss_
;
webrtc
:
:
AutoSocketServerThread
main_
;
std
:
:
unique_ptr
<
webrtc
:
:
AsyncPacketSocket
>
socket_
;
webrtc
:
:
TestTurnServer
turn_server_
;
std
:
:
unique_ptr
<
TurnPort
>
turn_port_
;
std
:
:
unique_ptr
<
UDPPort
>
udp_port_
;
bool
turn_ready_
=
false
;
bool
turn_error_
=
false
;
bool
turn_unknown_address_
=
false
;
bool
turn_create_permission_success_
=
false
;
bool
turn_port_closed_
=
false
;
bool
turn_port_destroyed_
=
false
;
bool
udp_ready_
=
false
;
bool
test_finish_
=
false
;
bool
turn_refresh_success_
=
false
;
std
:
:
vector
<
rtc
:
:
Buffer
>
turn_packets_
;
std
:
:
vector
<
rtc
:
:
Buffer
>
udp_packets_
;
rtc
:
:
PacketOptions
options
;
std
:
:
unique_ptr
<
webrtc
:
:
TurnCustomizer
>
turn_customizer_
;
cricket
:
:
IceCandidateErrorEvent
error_event_
;
private
:
webrtc
:
:
BasicPacketSocketFactory
socket_factory_
;
}
;
TEST_F
(
TurnPortTest
TestTurnPortType
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
EXPECT_EQ
(
IceCandidateType
:
:
kRelay
turn_port_
-
>
Type
(
)
)
;
}
TEST_F
(
TurnPortTest
TestReconstructedServerUrlForUdpIPv4
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestReconstructedServerUrl
(
webrtc
:
:
PROTO_UDP
"
turn
:
99
.
99
.
99
.
3
:
3478
?
transport
=
udp
"
)
;
}
TEST_F
(
TurnPortTest
TestReconstructedServerUrlForUdpIPv6
)
{
turn_server_
.
AddInternalSocket
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
kTurnUdpIPv6ProtoAddr
)
;
TestReconstructedServerUrl
(
webrtc
:
:
PROTO_UDP
"
turn
:
[
2400
:
4030
:
1
:
2c00
:
be30
:
abcd
:
efab
:
cdef
]
:
3478
?
transport
=
udp
"
)
;
}
TEST_F
(
TurnPortTest
TestReconstructedServerUrlForTcp
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
TestReconstructedServerUrl
(
webrtc
:
:
PROTO_TCP
"
turn
:
99
.
99
.
99
.
4
:
3478
?
transport
=
tcp
"
)
;
}
TEST_F
(
TurnPortTest
TestReconstructedServerUrlForTls
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestReconstructedServerUrl
(
webrtc
:
:
PROTO_TLS
"
turns
:
99
.
99
.
99
.
4
:
3478
?
transport
=
tcp
"
)
;
}
TEST_F
(
TurnPortTest
TestReconstructedServerUrlForHostname
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnPortInvalidHostnameProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kResolverTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
std
:
:
string
server_url
=
"
turn
:
"
+
kTurnInvalidAddr
.
ToString
(
)
+
"
?
transport
=
udp
"
;
ASSERT_EQ
(
error_event_
.
url
server_url
)
;
}
TEST_F
(
TurnPortTest
TestTurnAllocate
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
EXPECT_EQ
(
0
turn_port_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_SNDBUF
10
*
1024
)
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
2
)
;
}
class
TurnLoggingIdValidator
:
public
webrtc
:
:
StunMessageObserver
{
public
:
explicit
TurnLoggingIdValidator
(
const
char
*
expect_val
)
:
expect_val_
(
expect_val
)
{
}
~
TurnLoggingIdValidator
(
)
{
}
void
ReceivedMessage
(
const
TurnMessage
*
msg
)
override
{
if
(
msg
-
>
type
(
)
=
=
cricket
:
:
STUN_ALLOCATE_REQUEST
)
{
const
StunByteStringAttribute
*
attr
=
msg
-
>
GetByteString
(
cricket
:
:
STUN_ATTR_TURN_LOGGING_ID
)
;
if
(
expect_val_
)
{
ASSERT_NE
(
nullptr
attr
)
;
ASSERT_EQ
(
expect_val_
attr
-
>
string_view
(
)
)
;
}
else
{
EXPECT_EQ
(
nullptr
attr
)
;
}
}
}
void
ReceivedChannelData
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
override
{
}
private
:
const
char
*
expect_val_
;
}
;
TEST_F
(
TurnPortTest
TestTurnAllocateWithLoggingId
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
SetTurnLoggingId
(
"
KESO
"
)
;
turn_server_
.
server
(
)
-
>
SetStunMessageObserver
(
std
:
:
make_unique
<
TurnLoggingIdValidator
>
(
"
KESO
"
)
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
2
)
;
}
TEST_F
(
TurnPortTest
TestTurnAllocateWithoutLoggingId
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_server_
.
server
(
)
-
>
SetStunMessageObserver
(
std
:
:
make_unique
<
TurnLoggingIdValidator
>
(
nullptr
)
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
2
)
;
}
TEST_F
(
TurnPortTest
TestTurnBadCredentials
)
{
CreateTurnPort
(
kTurnUsername
"
bad
"
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
error_event_
.
error_code
;
}
Eq
(
STUN_ERROR_UNAUTHORIZED
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
error_event_
.
error_text
"
Unauthorized
"
)
;
}
TEST_F
(
TurnPortTest
TestServerAddressFamilyMismatch
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpIPv6ProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
EXPECT_EQ
(
0
error_event_
.
error_code
)
;
}
TEST_F
(
TurnPortTest
TestServerAddressFamilyMismatch6
)
{
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
EXPECT_EQ
(
0
error_event_
.
error_code
)
;
}
TEST_F
(
TurnPortTest
TestTurnTcpAllocate
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
EXPECT_EQ
(
0
turn_port_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_SNDBUF
10
*
1024
)
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
3
)
;
}
TEST_F
(
TurnPortTest
TestTurnTcpAllocationWhenProxyChangesAddressToLocalHost
)
{
SocketAddress
local_address
(
"
127
.
0
.
0
.
1
"
0
)
;
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr1
.
ipaddr
(
)
local_address
.
ipaddr
(
)
)
;
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kLocalAddr1
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
EXPECT_EQ
(
0
turn_port_
-
>
SetOption
(
webrtc
:
:
Socket
:
:
OPT_SNDBUF
10
*
1024
)
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
3
)
;
ASSERT_EQ
(
local_address
.
ipaddr
(
)
turn_port_
-
>
Candidates
(
)
[
0
]
.
related_address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
TurnPortTest
TurnTcpAllocationDiscardedIfBoundAddressDoesNotMatchNetwork
)
{
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr1
.
ipaddr
(
)
kLocalAddr2
.
ipaddr
(
)
)
;
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kLocalAddr1
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
error_event_
.
error_code
;
}
Eq
(
STUN_ERROR_SERVER_NOT_REACHABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
error_event_
.
error_text
.
find
(
'
.
'
)
std
:
:
string
:
:
npos
)
;
EXPECT_NE
(
error_event_
.
address
.
find
(
kLocalAddr2
.
HostAsSensitiveURIString
(
)
)
std
:
:
string
:
:
npos
)
;
EXPECT_NE
(
error_event_
.
port
0
)
;
std
:
:
string
server_url
=
"
turn
:
"
+
kTurnTcpIntAddr
.
ToString
(
)
+
"
?
transport
=
tcp
"
;
EXPECT_EQ
(
error_event_
.
url
server_url
)
;
}
TEST_F
(
TurnPortTest
TurnTcpAllocationNotDiscardedIfNotBoundToBestIP
)
{
ss_
-
>
SetAlternativeLocalAddress
(
kLocalAddr1
.
ipaddr
(
)
kLocalAddr2
.
ipaddr
(
)
)
;
webrtc
:
:
Network
*
network
=
MakeNetwork
(
kLocalAddr1
)
;
network
-
>
AddIP
(
kLocalAddr2
.
ipaddr
(
)
)
;
ASSERT_EQ
(
kLocalAddr1
.
ipaddr
(
)
network
-
>
GetBestIP
(
)
)
;
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPortWithNetwork
(
network
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
1U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
ASSERT_EQ
(
kLocalAddr2
.
ipaddr
(
)
turn_port_
-
>
Candidates
(
)
[
0
]
.
related_address
(
)
.
ipaddr
(
)
)
;
}
TEST_F
(
TurnPortTest
TCPPortNotDiscardedIfBoundToTemporaryIP
)
{
networks_
.
emplace_back
(
"
unittest
"
"
unittest
"
kLocalIPv6Addr
.
ipaddr
(
)
32
)
;
networks_
.
back
(
)
.
AddIP
(
webrtc
:
:
InterfaceAddress
(
kLocalIPv6Addr
.
ipaddr
(
)
webrtc
:
:
IPV6_ADDRESS_FLAG_TEMPORARY
)
)
;
turn_server_
.
AddInternalSocket
(
kTurnIPv6IntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPortWithNetwork
(
&
networks_
.
back
(
)
kTurnUsername
kTurnPassword
cricket
:
:
ProtocolAddress
(
kTurnIPv6IntAddr
webrtc
:
:
PROTO_TCP
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
1U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnTcpOnAddressResolveFailure
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnInvalidAddr
webrtc
:
:
PROTO_TCP
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kResolverTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
SOCKET_ERROR
turn_port_
-
>
error
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
error_event_
.
error_code
;
}
Eq
(
STUN_ERROR_SERVER_NOT_REACHABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
std
:
:
string
server_url
=
"
turn
:
"
+
kTurnInvalidAddr
.
ToString
(
)
+
"
?
transport
=
tcp
"
;
ASSERT_EQ
(
error_event_
.
url
server_url
)
;
}
TEST_F
(
TurnPortTest
TestTurnTlsOnAddressResolveFailure
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnInvalidAddr
webrtc
:
:
PROTO_TLS
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kResolverTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
SOCKET_ERROR
turn_port_
-
>
error
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnUdpOnAddressResolveFailure
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnInvalidAddr
webrtc
:
:
PROTO_UDP
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kResolverTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
SOCKET_ERROR
turn_port_
-
>
error
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnAllocateBadPassword
)
{
CreateTurnPort
(
kTurnUsername
"
bad
"
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnAllocateNonceResetAfterAllocateMismatch
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
SocketAddress
first_addr
(
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
ss_
-
>
set_drop_probability
(
1
.
0
)
;
turn_port_
.
reset
(
)
;
SIMULATED_WAIT
(
false
kSimulatedRtt
fake_clock_
)
;
ss_
-
>
set_drop_probability
(
0
.
0
)
;
ss_
-
>
SetNextPortForTesting
(
first_addr
.
port
(
)
)
;
turn_ready_
=
false
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
int64_t
ts_before
=
webrtc
:
:
TimeMillis
(
)
-
1
;
std
:
:
string
first_nonce
=
turn_server_
.
server
(
)
-
>
SetTimestampForNextNonce
(
ts_before
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
4
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
first_nonce
turn_port_
-
>
nonce
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnAllocateMismatch
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
SocketAddress
first_addr
(
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
turn_port_
-
>
OnSocketClose
(
turn_port_
-
>
socket
(
)
0
)
;
ss_
-
>
SetNextPortForTesting
(
first_addr
.
port
(
)
)
;
turn_ready_
=
false
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
first_addr
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
4
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
first_addr
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
std
:
:
string
test_packet
=
"
Test
packet
"
;
EXPECT_FALSE
(
turn_port_
-
>
HandleIncomingPacket
(
socket_
.
get
(
)
rtc
:
:
ReceivedPacket
:
:
CreateFromLegacy
(
test_packet
.
data
(
)
test_packet
.
size
(
)
webrtc
:
:
TimeMicros
(
)
webrtc
:
:
SocketAddress
(
kTurnUdpExtAddr
.
ipaddr
(
)
0
)
)
)
)
;
}
TEST_F
(
TurnPortTest
TestSharedSocketAllocateMismatch
)
{
CreateSharedTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
SocketAddress
first_addr
(
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
turn_port_
-
>
OnSocketClose
(
turn_port_
-
>
socket
(
)
0
)
;
turn_ready_
=
false
;
CreateSharedTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
EXPECT_EQ
(
first_addr
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
EXPECT_TRUE
(
turn_port_
-
>
SharedSocket
(
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
4
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
first_addr
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
EXPECT_FALSE
(
turn_port_
-
>
SharedSocket
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnTcpAllocateMismatch
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
webrtc
:
:
SocketAddress
first_addr
(
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
turn_port_
-
>
OnSocketClose
(
turn_port_
-
>
socket
(
)
0
)
;
ss_
-
>
SetNextPortForTesting
(
first_addr
.
port
(
)
)
;
turn_ready_
=
false
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_EQ
(
first_addr
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
5
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_NE
(
first_addr
turn_port_
-
>
socket
(
)
-
>
GetLocalAddress
(
)
)
;
}
TEST_F
(
TurnPortTest
TestRefreshRequestGetsErrorResponse
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_UDP
)
;
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
webrtc
:
:
RelayCredentials
bad_credentials
(
"
bad_user
"
"
bad_pwd
"
)
;
turn_port_
-
>
set_credentials
(
bad_credentials
)
;
turn_refresh_success_
=
false
;
turn_port_
-
>
request_manager
(
)
.
FlushForTest
(
TURN_REFRESH_REQUEST
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_refresh_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
turn_port_
-
>
request_manager
(
)
.
FlushForTest
(
TURN_REFRESH_REQUEST
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
turn_refresh_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
turn_port_
-
>
connected
(
)
)
;
EXPECT_TRUE
(
CheckAllConnectionsFailedAndPruned
(
)
)
;
EXPECT_FALSE
(
turn_port_
-
>
HasRequests
(
)
)
;
}
TEST_F
(
TurnPortTest
TestStopProcessingPacketsAfterClosed
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_UDP
)
;
Connection
*
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
conn2
=
udp_port_
-
>
CreateConnection
(
turn_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
!
=
NULL
)
;
ASSERT_TRUE
(
conn2
!
=
NULL
)
;
conn2
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn2
-
>
write_state
(
)
;
}
Eq
(
Connection
:
:
STATE_WRITABLE
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
turn_port_
-
>
CloseForTest
(
)
;
SIMULATED_WAIT
(
false
kSimulatedRtt
fake_clock_
)
;
turn_unknown_address_
=
false
;
conn2
-
>
Ping
(
0
)
;
SIMULATED_WAIT
(
false
kSimulatedRtt
fake_clock_
)
;
EXPECT_FALSE
(
turn_unknown_address_
)
;
}
TEST_F
(
TurnPortTest
TestCreateConnectionWhenSocketClosed
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_TCP
)
;
Connection
*
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
!
=
NULL
)
;
turn_port_
-
>
OnSocketClose
(
turn_port_
-
>
socket
(
)
1
)
;
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
=
=
NULL
)
;
}
TEST_F
(
TurnPortTest
TestSocketCloseWillDestroyConnection
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_TCP
)
;
Connection
*
conn
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_NE
(
nullptr
conn
)
;
EXPECT_TRUE
(
!
turn_port_
-
>
connections
(
)
.
empty
(
)
)
;
turn_port_
-
>
socket
(
)
-
>
NotifyClosedForTest
(
1
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_port_
-
>
connections
(
)
.
empty
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kConnectionDestructionDelay
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerUDP
)
{
TestTurnAlternateServer
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerTCP
)
{
TestTurnAlternateServer
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerTLS
)
{
TestTurnAlternateServer
(
webrtc
:
:
PROTO_TLS
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerV4toV6UDP
)
{
TestTurnAlternateServerV4toV6
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerV4toV6TCP
)
{
TestTurnAlternateServerV4toV6
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerV4toV6TLS
)
{
TestTurnAlternateServerV4toV6
(
webrtc
:
:
PROTO_TLS
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerPingPongUDP
)
{
TestTurnAlternateServerPingPong
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerPingPongTCP
)
{
TestTurnAlternateServerPingPong
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerPingPongTLS
)
{
TestTurnAlternateServerPingPong
(
webrtc
:
:
PROTO_TLS
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerDetectRepetitionUDP
)
{
TestTurnAlternateServerDetectRepetition
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerDetectRepetitionTCP
)
{
TestTurnAlternateServerDetectRepetition
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerDetectRepetitionTLS
)
{
TestTurnAlternateServerDetectRepetition
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerLoopbackUdpIpv4
)
{
TestTurnAlternateServerLoopback
(
webrtc
:
:
PROTO_UDP
false
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerLoopbackUdpIpv6
)
{
TestTurnAlternateServerLoopback
(
webrtc
:
:
PROTO_UDP
true
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerLoopbackTcpIpv4
)
{
TestTurnAlternateServerLoopback
(
webrtc
:
:
PROTO_TCP
false
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerLoopbackTcpIpv6
)
{
TestTurnAlternateServerLoopback
(
webrtc
:
:
PROTO_TCP
true
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerLoopbackTlsIpv4
)
{
TestTurnAlternateServerLoopback
(
webrtc
:
:
PROTO_TLS
false
)
;
}
TEST_F
(
TurnPortTest
TestTurnAlternateServerLoopbackTlsIpv6
)
{
TestTurnAlternateServerLoopback
(
webrtc
:
:
PROTO_TLS
true
)
;
}
TEST_F
(
TurnPortTest
TestTurnConnection
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestTurnConnection
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnConnectionUsingSharedSocket
)
{
CreateSharedTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestTurnConnection
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnTcpConnection
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
TestTurnConnection
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnTlsConnection
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnConnection
(
webrtc
:
:
PROTO_TLS
)
;
}
TEST_F
(
TurnPortTest
TestDestroyTurnConnection
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestDestroyTurnConnection
(
)
;
}
TEST_F
(
TurnPortTest
TestDestroyTurnConnectionUsingSharedSocket
)
{
CreateSharedTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestDestroyTurnConnection
(
)
;
}
TEST_F
(
TurnPortTest
TestTurnConnectionUsingOTUNonce
)
{
turn_server_
.
set_enable_otu_nonce
(
true
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestTurnConnection
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestRefreshCreatePermissionRequest
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_UDP
)
;
Connection
*
conn
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn
!
=
NULL
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_create_permission_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
turn_create_permission_success_
=
false
;
webrtc
:
:
RelayCredentials
bad_credentials
(
"
bad_user
"
"
bad_pwd
"
)
;
turn_port_
-
>
set_credentials
(
bad_credentials
)
;
turn_port_
-
>
request_manager
(
)
.
FlushForTest
(
kAllRequestsForTest
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_create_permission_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
turn_port_
-
>
request_manager
(
)
.
FlushForTest
(
kAllRequestsForTest
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
turn_create_permission_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
CheckConnectionFailedAndPruned
(
conn
)
)
;
}
TEST_F
(
TurnPortTest
TestChannelBindGetErrorResponse
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_UDP
)
;
Connection
*
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
udp_port_
-
>
CreateConnection
(
turn_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn1
-
>
Ping
(
0
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
conn1
-
>
writable
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
turn_server_
.
server
(
)
-
>
set_reject_bind_requests
(
true
)
;
std
:
:
string
data
=
"
ABC
"
;
conn1
-
>
Send
(
data
.
data
(
)
data
.
length
(
)
options
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnectionFailedAndPruned
(
conn1
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
RegisterReceivedPacketCallback
(
[
&
]
(
Connection
*
connection
const
rtc
:
:
ReceivedPacket
&
packet
)
{
udp_packets_
.
push_back
(
rtc
:
:
Buffer
(
packet
.
payload
(
)
.
data
(
)
packet
.
payload
(
)
.
size
(
)
)
)
;
}
)
;
conn1
-
>
Send
(
data
.
data
(
)
data
.
length
(
)
options
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
udp_packets_
.
empty
(
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
conn2
-
>
DeregisterReceivedPacketCallback
(
)
;
}
TEST_F
(
TurnPortTest
TestTurnSendDataTurnUdpToUdp
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestTurnSendData
(
webrtc
:
:
PROTO_UDP
)
;
EXPECT_EQ
(
webrtc
:
:
UDP_PROTOCOL_NAME
turn_port_
-
>
Candidates
(
)
[
0
]
.
relay_protocol
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnSendDataTurnTcpToUdp
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
TestTurnSendData
(
webrtc
:
:
PROTO_TCP
)
;
EXPECT_EQ
(
webrtc
:
:
TCP_PROTOCOL_NAME
turn_port_
-
>
Candidates
(
)
[
0
]
.
relay_protocol
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnSendDataTurnTlsToUdp
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnSendData
(
webrtc
:
:
PROTO_TLS
)
;
EXPECT_EQ
(
webrtc
:
:
TLS_PROTOCOL_NAME
turn_port_
-
>
Candidates
(
)
[
0
]
.
relay_protocol
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnLocalIPv6AddressServerIPv4
)
{
turn_server_
.
AddInternalSocket
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
turn_port_
-
>
Candidates
(
)
.
empty
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnLocalIPv6AddressServerIPv6ExtenalIPv4
)
{
turn_server_
.
AddInternalSocket
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
kTurnUdpIPv6ProtoAddr
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
2
)
;
}
TEST_F
(
TurnPortTest
TestCandidateAddressFamilyMatch
)
{
turn_server_
.
AddInternalSocket
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
kTurnUdpIPv6ProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
2
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
ASSERT_EQ
(
1U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
webrtc
:
:
Candidate
remote_candidate
(
ICE_CANDIDATE_COMPONENT_RTP
"
udp
"
kLocalAddr2
0
"
"
"
"
IceCandidateType
:
:
kHost
0
kCandidateFoundation
)
;
remote_candidate
.
set_address
(
kLocalAddr2
)
;
Connection
*
conn
=
turn_port_
-
>
CreateConnection
(
remote_candidate
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_NE
(
nullptr
conn
)
;
remote_candidate
.
set_address
(
kLocalIPv6Addr2
)
;
conn
=
turn_port_
-
>
CreateConnection
(
remote_candidate
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_EQ
(
nullptr
conn
)
;
}
TEST_F
(
TurnPortTest
TestConnectionFailedAndPrunedOnCreatePermissionFailure
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
turn_server_
.
server
(
)
-
>
set_reject_private_addresses
(
true
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
*
3
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
CreateUdpPort
(
SocketAddress
(
"
10
.
0
.
0
.
10
"
0
)
)
;
udp_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
udp_ready_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
TestConnectionWrapper
conn
(
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
)
;
EXPECT_TRUE
(
conn
.
connection
(
)
!
=
nullptr
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
CheckConnectionFailedAndPruned
(
conn
.
connection
(
)
)
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
!
turn_create_permission_success_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kSimulatedRtt
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
SIMULATED_WAIT
(
conn
.
connection
(
)
=
=
nullptr
kConnectionDestructionDelay
fake_clock_
)
;
EXPECT_NE
(
nullptr
conn
.
connection
(
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnReleaseAllocation
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestTurnReleaseAllocation
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnTCPReleaseAllocation
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
TestTurnReleaseAllocation
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnTLSReleaseAllocation
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnReleaseAllocation
(
webrtc
:
:
PROTO_TLS
)
;
}
TEST_F
(
TurnPortTest
TestTurnUDPGracefulReleaseAllocation
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_UDP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
TestTurnGracefulReleaseAllocation
(
webrtc
:
:
PROTO_UDP
)
;
}
TEST_F
(
TurnPortTest
TestTurnTCPGracefulReleaseAllocation
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TCP
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTcpProtoAddr
)
;
TestTurnGracefulReleaseAllocation
(
webrtc
:
:
PROTO_TCP
)
;
}
TEST_F
(
TurnPortTest
TestTurnTLSGracefulReleaseAllocation
)
{
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnGracefulReleaseAllocation
(
webrtc
:
:
PROTO_TLS
)
;
}
TEST_F
(
TurnPortTest
CanCreateTwoConnectionsToSameAddress
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnUdpProtoAddr
)
;
PrepareTurnAndUdpPorts
(
webrtc
:
:
PROTO_UDP
)
;
Connection
*
conn1
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
Connection
*
conn2
=
turn_port_
-
>
CreateConnection
(
udp_port_
-
>
Candidates
(
)
[
0
]
Port
:
:
ORIGIN_MESSAGE
)
;
EXPECT_NE
(
conn1
conn2
)
;
}
#
if
defined
(
WEBRTC_LINUX
)
&
&
!
defined
(
WEBRTC_ANDROID
)
TEST_F
(
TurnPortTest
TestResolverShutdown
)
{
turn_server_
.
AddInternalSocket
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
int
last_fd_count
=
GetFDCount
(
)
;
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnInvalidAddr
webrtc
:
:
PROTO_UDP
)
)
;
turn_port_
-
>
PrepareAddress
(
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
turn_error_
;
}
IsTrue
(
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
kResolverTimeout
)
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
turn_port_
-
>
Candidates
(
)
.
empty
(
)
)
;
turn_port_
.
reset
(
)
;
webrtc
:
:
Thread
:
:
Current
(
)
-
>
PostTask
(
[
this
]
{
test_finish_
=
true
;
}
)
;
ASSERT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
test_finish_
;
}
IsTrue
(
)
{
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_EQ
(
last_fd_count
GetFDCount
(
)
)
;
}
#
endif
class
MessageObserver
:
public
webrtc
:
:
StunMessageObserver
{
public
:
MessageObserver
(
unsigned
int
*
message_counter
unsigned
int
*
channel_data_counter
unsigned
int
*
attr_counter
)
:
message_counter_
(
message_counter
)
channel_data_counter_
(
channel_data_counter
)
attr_counter_
(
attr_counter
)
{
}
virtual
~
MessageObserver
(
)
{
}
void
ReceivedMessage
(
const
TurnMessage
*
msg
)
override
{
if
(
message_counter_
!
=
nullptr
)
{
(
*
message_counter_
)
+
+
;
}
const
StunByteStringAttribute
*
attr
=
msg
-
>
GetByteString
(
webrtc
:
:
TestTurnCustomizer
:
:
STUN_ATTR_COUNTER
)
;
if
(
attr
!
=
nullptr
&
&
attr_counter_
!
=
nullptr
)
{
webrtc
:
:
ByteBufferReader
buf
(
attr
-
>
array_view
(
)
)
;
unsigned
int
val
=
~
0u
;
buf
.
ReadUInt32
(
&
val
)
;
(
*
attr_counter_
)
+
+
;
}
}
void
ReceivedChannelData
(
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
)
override
{
if
(
channel_data_counter_
!
=
nullptr
)
{
(
*
channel_data_counter_
)
+
+
;
}
}
unsigned
int
*
message_counter_
=
nullptr
;
unsigned
int
*
channel_data_counter_
=
nullptr
;
unsigned
int
*
attr_counter_
=
nullptr
;
}
;
TEST_F
(
TurnPortTest
TestTurnCustomizerCount
)
{
unsigned
int
observer_message_counter
=
0
;
unsigned
int
observer_channel_data_counter
=
0
;
unsigned
int
observer_attr_counter
=
0
;
webrtc
:
:
TestTurnCustomizer
*
customizer
=
new
webrtc
:
:
TestTurnCustomizer
(
)
;
std
:
:
unique_ptr
<
MessageObserver
>
validator
(
new
MessageObserver
(
&
observer_message_counter
&
observer_channel_data_counter
&
observer_attr_counter
)
)
;
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
turn_customizer_
.
reset
(
customizer
)
;
turn_server_
.
server
(
)
-
>
SetStunMessageObserver
(
std
:
:
move
(
validator
)
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnSendData
(
webrtc
:
:
PROTO_TLS
)
;
EXPECT_EQ
(
webrtc
:
:
TLS_PROTOCOL_NAME
turn_port_
-
>
Candidates
(
)
[
0
]
.
relay_protocol
(
)
)
;
EXPECT_GE
(
customizer
-
>
modify_cnt_
+
customizer
-
>
allow_channel_data_cnt_
turn_packets_
.
size
(
)
)
;
EXPECT_GE
(
observer_channel_data_counter
0u
)
;
turn_port_
.
reset
(
nullptr
)
;
}
TEST_F
(
TurnPortTest
TestTurnCustomizerDisallowChannelData
)
{
unsigned
int
observer_message_counter
=
0
;
unsigned
int
observer_channel_data_counter
=
0
;
unsigned
int
observer_attr_counter
=
0
;
webrtc
:
:
TestTurnCustomizer
*
customizer
=
new
webrtc
:
:
TestTurnCustomizer
(
)
;
std
:
:
unique_ptr
<
MessageObserver
>
validator
(
new
MessageObserver
(
&
observer_message_counter
&
observer_channel_data_counter
&
observer_attr_counter
)
)
;
customizer
-
>
allow_channel_data_
=
false
;
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
turn_customizer_
.
reset
(
customizer
)
;
turn_server_
.
server
(
)
-
>
SetStunMessageObserver
(
std
:
:
move
(
validator
)
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnSendData
(
webrtc
:
:
PROTO_TLS
)
;
EXPECT_EQ
(
webrtc
:
:
TLS_PROTOCOL_NAME
turn_port_
-
>
Candidates
(
)
[
0
]
.
relay_protocol
(
)
)
;
EXPECT_GE
(
customizer
-
>
modify_cnt_
turn_packets_
.
size
(
)
)
;
EXPECT_EQ
(
observer_channel_data_counter
0u
)
;
turn_port_
.
reset
(
nullptr
)
;
}
TEST_F
(
TurnPortTest
TestTurnCustomizerAddAttribute
)
{
unsigned
int
observer_message_counter
=
0
;
unsigned
int
observer_channel_data_counter
=
0
;
unsigned
int
observer_attr_counter
=
0
;
webrtc
:
:
TestTurnCustomizer
*
customizer
=
new
webrtc
:
:
TestTurnCustomizer
(
)
;
std
:
:
unique_ptr
<
MessageObserver
>
validator
(
new
MessageObserver
(
&
observer_message_counter
&
observer_channel_data_counter
&
observer_attr_counter
)
)
;
customizer
-
>
allow_channel_data_
=
false
;
customizer
-
>
add_counter_
=
true
;
turn_server_
.
AddInternalSocket
(
kTurnTcpIntAddr
webrtc
:
:
PROTO_TLS
)
;
turn_customizer_
.
reset
(
customizer
)
;
turn_server_
.
server
(
)
-
>
SetStunMessageObserver
(
std
:
:
move
(
validator
)
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnTlsProtoAddr
)
;
TestTurnSendData
(
webrtc
:
:
PROTO_TLS
)
;
EXPECT_EQ
(
webrtc
:
:
TLS_PROTOCOL_NAME
turn_port_
-
>
Candidates
(
)
[
0
]
.
relay_protocol
(
)
)
;
EXPECT_GE
(
customizer
-
>
modify_cnt_
turn_packets_
.
size
(
)
)
;
EXPECT_GE
(
customizer
-
>
modify_cnt_
observer_message_counter
)
;
EXPECT_EQ
(
observer_message_counter
observer_attr_counter
)
;
EXPECT_GE
(
customizer
-
>
modify_cnt_
customizer
-
>
allow_channel_data_cnt_
)
;
EXPECT_GE
(
customizer
-
>
allow_channel_data_cnt_
0u
)
;
EXPECT_EQ
(
observer_channel_data_counter
0u
)
;
turn_port_
.
reset
(
nullptr
)
;
}
TEST_F
(
TurnPortTest
TestOverlongUsername
)
{
std
:
:
string
overlong_username
(
513
'
x
'
)
;
webrtc
:
:
RelayCredentials
credentials
(
overlong_username
kTurnPassword
)
;
EXPECT_FALSE
(
CreateTurnPort
(
overlong_username
kTurnPassword
kTurnTlsProtoAddr
)
)
;
}
TEST_F
(
TurnPortTest
TestTurnDangerousServer
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnDangerousProtoAddr
)
;
ASSERT_FALSE
(
turn_port_
)
;
}
TEST_F
(
TurnPortTest
TestTurnDangerousServerPermits53
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnPort53ProtoAddr
)
;
ASSERT_TRUE
(
turn_port_
)
;
}
TEST_F
(
TurnPortTest
TestTurnDangerousServerPermits80
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnPort80ProtoAddr
)
;
ASSERT_TRUE
(
turn_port_
)
;
}
TEST_F
(
TurnPortTest
TestTurnDangerousServerPermits443
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnPort443ProtoAddr
)
;
ASSERT_TRUE
(
turn_port_
)
;
}
TEST_F
(
TurnPortTest
TestTurnDangerousAlternateServer
)
{
const
webrtc
:
:
ProtocolType
protocol_type
=
webrtc
:
:
PROTO_TCP
;
std
:
:
vector
<
webrtc
:
:
SocketAddress
>
redirect_addresses
;
redirect_addresses
.
push_back
(
kTurnDangerousAddr
)
;
webrtc
:
:
TestTurnRedirector
redirector
(
redirect_addresses
)
;
turn_server_
.
AddInternalSocket
(
kTurnIntAddr
protocol_type
)
;
turn_server_
.
AddInternalSocket
(
kTurnDangerousAddr
protocol_type
)
;
turn_server_
.
set_redirect_hook
(
&
redirector
)
;
CreateTurnPort
(
kTurnUsername
kTurnPassword
ProtocolAddress
(
kTurnIntAddr
protocol_type
)
)
;
const
SocketAddress
old_addr
=
turn_port_
-
>
server_address
(
)
.
address
;
turn_port_
-
>
PrepareAddress
(
)
;
EXPECT_THAT
(
webrtc
:
:
WaitUntil
(
[
&
]
{
return
error_event_
.
error_code
;
}
Ne
(
0
)
{
.
timeout
=
webrtc
:
:
TimeDelta
:
:
Millis
(
TimeToGetAlternateTurnCandidate
(
protocol_type
)
)
.
clock
=
&
fake_clock_
}
)
webrtc
:
:
IsRtcOk
(
)
)
;
EXPECT_FALSE
(
turn_ready_
)
;
ASSERT_EQ
(
0U
turn_port_
-
>
Candidates
(
)
.
size
(
)
)
;
}
class
TurnPortWithMockDnsResolverTest
:
public
TurnPortTest
{
public
:
TurnPortWithMockDnsResolverTest
(
)
:
TurnPortTest
(
)
socket_factory_
(
ss_
.
get
(
)
)
{
}
webrtc
:
:
PacketSocketFactory
*
socket_factory
(
)
override
{
return
&
socket_factory_
;
}
void
SetDnsResolverExpectations
(
webrtc
:
:
MockDnsResolvingPacketSocketFactory
:
:
Expectations
expectations
)
{
socket_factory_
.
SetExpectations
(
expectations
)
;
}
private
:
webrtc
:
:
MockDnsResolvingPacketSocketFactory
socket_factory_
;
}
;
TEST_F
(
TurnPortWithMockDnsResolverTest
TestHostnameResolved
)
{
CreateTurnPort
(
kTurnUsername
kTurnPassword
kTurnPortValidHostnameProtoAddr
)
;
SetDnsResolverExpectations
(
[
]
(
webrtc
:
:
MockAsyncDnsResolver
*
resolver
webrtc
:
:
MockAsyncDnsResolverResult
*
resolver_result
)
{
EXPECT_CALL
(
*
resolver
Start
(
kTurnValidAddr
AF_INET
_
)
)
.
WillOnce
(
[
]
(
const
webrtc
:
:
SocketAddress
&
addr
int
family
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
{
callback
(
)
;
}
)
;
EXPECT_CALL
(
*
resolver
result
)
.
WillRepeatedly
(
ReturnPointee
(
resolver_result
)
)
;
EXPECT_CALL
(
*
resolver_result
GetError
)
.
WillRepeatedly
(
Return
(
0
)
)
;
EXPECT_CALL
(
*
resolver_result
GetResolvedAddress
(
AF_INET
_
)
)
.
WillOnce
(
DoAll
(
SetArgPointee
<
1
>
(
kTurnUdpIntAddr
)
Return
(
true
)
)
)
;
}
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
2
)
;
}
TEST_F
(
TurnPortWithMockDnsResolverTest
TestHostnameResolvedIPv6Network
)
{
turn_server_
.
AddInternalSocket
(
kTurnUdpIPv6IntAddr
webrtc
:
:
PROTO_UDP
)
;
CreateTurnPort
(
kLocalIPv6Addr
kTurnUsername
kTurnPassword
kTurnPortValidHostnameProtoAddr
)
;
SetDnsResolverExpectations
(
[
]
(
webrtc
:
:
MockAsyncDnsResolver
*
resolver
webrtc
:
:
MockAsyncDnsResolverResult
*
resolver_result
)
{
EXPECT_CALL
(
*
resolver
Start
(
kTurnValidAddr
AF_INET6
_
)
)
.
WillOnce
(
[
]
(
const
webrtc
:
:
SocketAddress
&
addr
int
family
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
{
callback
(
)
;
}
)
;
EXPECT_CALL
(
*
resolver
result
)
.
WillRepeatedly
(
ReturnPointee
(
resolver_result
)
)
;
EXPECT_CALL
(
*
resolver_result
GetError
)
.
WillRepeatedly
(
Return
(
0
)
)
;
EXPECT_CALL
(
*
resolver_result
GetResolvedAddress
(
AF_INET6
_
)
)
.
WillOnce
(
DoAll
(
SetArgPointee
<
1
>
(
kTurnUdpIPv6IntAddr
)
Return
(
true
)
)
)
;
}
)
;
TestTurnAllocateSucceeds
(
kSimulatedRtt
*
2
)
;
}
}
