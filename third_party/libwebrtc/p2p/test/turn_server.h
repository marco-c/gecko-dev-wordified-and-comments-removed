#
ifndef
P2P_TEST_TURN_SERVER_H_
#
define
P2P_TEST_TURN_SERVER_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
packet_socket_factory
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
ssl_adapter
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
cricket
{
class
StunMessage
;
class
TurnMessage
;
}
namespace
webrtc
{
constexpr
int
kMinTurnChannelNumber
=
0x4000
;
constexpr
int
kMaxTurnChannelNumber
=
0x7FFF
;
class
TurnServer
;
const
int
TURN_SERVER_PORT
=
3478
;
class
TurnServerConnection
{
public
:
TurnServerConnection
(
)
:
proto_
(
webrtc
:
:
PROTO_UDP
)
socket_
(
NULL
)
{
}
TurnServerConnection
(
const
SocketAddress
&
src
ProtocolType
proto
AsyncPacketSocket
*
socket
)
;
const
SocketAddress
&
src
(
)
const
{
return
src_
;
}
AsyncPacketSocket
*
socket
(
)
{
return
socket_
;
}
bool
operator
=
=
(
const
TurnServerConnection
&
t
)
const
;
bool
operator
<
(
const
TurnServerConnection
&
t
)
const
;
std
:
:
string
ToString
(
)
const
;
private
:
SocketAddress
src_
;
SocketAddress
dst_
;
ProtocolType
proto_
;
AsyncPacketSocket
*
socket_
;
}
;
class
TurnServerAllocation
final
{
public
:
TurnServerAllocation
(
TurnServer
*
server_
TaskQueueBase
*
thread
const
TurnServerConnection
&
conn
AsyncPacketSocket
*
server_socket
absl
:
:
string_view
key
)
;
~
TurnServerAllocation
(
)
;
TurnServerConnection
*
conn
(
)
{
return
&
conn_
;
}
const
std
:
:
string
&
key
(
)
const
{
return
key_
;
}
const
std
:
:
string
&
transaction_id
(
)
const
{
return
transaction_id_
;
}
const
std
:
:
string
&
username
(
)
const
{
return
username_
;
}
const
std
:
:
string
&
last_nonce
(
)
const
{
return
last_nonce_
;
}
void
set_last_nonce
(
absl
:
:
string_view
nonce
)
{
last_nonce_
=
std
:
:
string
(
nonce
)
;
}
std
:
:
string
ToString
(
)
const
;
void
HandleTurnMessage
(
const
cricket
:
:
TurnMessage
*
msg
)
;
void
HandleChannelData
(
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
)
;
private
:
struct
Channel
{
ScopedTaskSafety
pending_delete
;
const
uint16_t
id
;
const
SocketAddress
peer
;
}
;
struct
Permission
{
ScopedTaskSafety
pending_delete
;
IPAddress
peer
;
}
;
using
PermissionList
=
std
:
:
list
<
Permission
>
;
using
ChannelList
=
std
:
:
list
<
Channel
>
;
void
PostDeleteSelf
(
TimeDelta
delay
)
;
void
HandleAllocateRequest
(
const
cricket
:
:
TurnMessage
*
msg
)
;
void
HandleRefreshRequest
(
const
cricket
:
:
TurnMessage
*
msg
)
;
void
HandleSendIndication
(
const
cricket
:
:
TurnMessage
*
msg
)
;
void
HandleCreatePermissionRequest
(
const
cricket
:
:
TurnMessage
*
msg
)
;
void
HandleChannelBindRequest
(
const
cricket
:
:
TurnMessage
*
msg
)
;
void
OnExternalPacket
(
AsyncPacketSocket
*
socket
const
rtc
:
:
ReceivedPacket
&
packet
)
;
static
TimeDelta
ComputeLifetime
(
const
cricket
:
:
TurnMessage
&
msg
)
;
bool
HasPermission
(
const
IPAddress
&
addr
)
;
void
AddPermission
(
const
IPAddress
&
addr
)
;
PermissionList
:
:
iterator
FindPermission
(
const
IPAddress
&
addr
)
;
ChannelList
:
:
iterator
FindChannel
(
int
channel_id
)
;
ChannelList
:
:
iterator
FindChannel
(
const
SocketAddress
&
addr
)
;
void
SendResponse
(
cricket
:
:
TurnMessage
*
msg
)
;
void
SendBadRequestResponse
(
const
cricket
:
:
TurnMessage
*
req
)
;
void
SendErrorResponse
(
const
cricket
:
:
TurnMessage
*
req
int
code
absl
:
:
string_view
reason
)
;
void
SendExternal
(
const
void
*
data
size_t
size
const
SocketAddress
&
peer
)
;
TurnServer
*
const
server_
;
TaskQueueBase
*
const
thread_
;
TurnServerConnection
conn_
;
std
:
:
unique_ptr
<
AsyncPacketSocket
>
external_socket_
;
std
:
:
string
key_
;
std
:
:
string
transaction_id_
;
std
:
:
string
username_
;
std
:
:
string
last_nonce_
;
PermissionList
perms_
;
ChannelList
channels_
;
ScopedTaskSafety
safety_
;
}
;
class
TurnAuthInterface
{
public
:
virtual
bool
GetKey
(
absl
:
:
string_view
username
absl
:
:
string_view
realm
std
:
:
string
*
key
)
=
0
;
virtual
~
TurnAuthInterface
(
)
=
default
;
}
;
class
TurnRedirectInterface
{
public
:
virtual
bool
ShouldRedirect
(
const
SocketAddress
&
address
SocketAddress
*
out
)
=
0
;
virtual
~
TurnRedirectInterface
(
)
{
}
}
;
class
StunMessageObserver
{
public
:
virtual
void
ReceivedMessage
(
const
cricket
:
:
TurnMessage
*
msg
)
=
0
;
virtual
void
ReceivedChannelData
(
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
)
=
0
;
virtual
~
StunMessageObserver
(
)
{
}
}
;
class
TurnServer
:
public
sigslot
:
:
has_slots
<
>
{
public
:
typedef
std
:
:
map
<
TurnServerConnection
std
:
:
unique_ptr
<
TurnServerAllocation
>
>
AllocationMap
;
explicit
TurnServer
(
TaskQueueBase
*
thread
)
;
~
TurnServer
(
)
override
;
const
std
:
:
string
&
realm
(
)
const
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
realm_
;
}
void
set_realm
(
absl
:
:
string_view
realm
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
realm_
=
std
:
:
string
(
realm
)
;
}
const
std
:
:
string
&
software
(
)
const
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
software_
;
}
void
set_software
(
absl
:
:
string_view
software
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
software_
=
std
:
:
string
(
software
)
;
}
const
AllocationMap
&
allocations
(
)
const
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
allocations_
;
}
void
set_auth_hook
(
TurnAuthInterface
*
auth_hook
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
auth_hook_
=
auth_hook
;
}
void
set_redirect_hook
(
TurnRedirectInterface
*
redirect_hook
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
redirect_hook_
=
redirect_hook
;
}
void
set_enable_otu_nonce
(
bool
enable
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
enable_otu_nonce_
=
enable
;
}
void
set_reject_private_addresses
(
bool
filter
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
reject_private_addresses_
=
filter
;
}
void
set_reject_bind_requests
(
bool
filter
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
reject_bind_requests_
=
filter
;
}
void
set_enable_permission_checks
(
bool
enable
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
enable_permission_checks_
=
enable
;
}
void
AddInternalSocket
(
AsyncPacketSocket
*
socket
ProtocolType
proto
)
;
void
AddInternalServerSocket
(
Socket
*
socket
ProtocolType
proto
std
:
:
unique_ptr
<
SSLAdapterFactory
>
ssl_adapter_factory
=
nullptr
)
;
void
SetExternalSocketFactory
(
PacketSocketFactory
*
factory
const
SocketAddress
&
address
)
;
std
:
:
string
SetTimestampForNextNonce
(
int64_t
timestamp
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
ts_for_next_nonce_
=
timestamp
;
return
GenerateNonce
(
timestamp
)
;
}
void
SetStunMessageObserver
(
std
:
:
unique_ptr
<
StunMessageObserver
>
observer
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
stun_message_observer_
=
std
:
:
move
(
observer
)
;
}
private
:
std
:
:
string
GenerateNonce
(
int64_t
now
)
const
RTC_RUN_ON
(
thread_
)
;
void
OnInternalPacket
(
AsyncPacketSocket
*
socket
const
rtc
:
:
ReceivedPacket
&
packet
)
RTC_RUN_ON
(
thread_
)
;
void
OnNewInternalConnection
(
Socket
*
socket
)
;
void
AcceptConnection
(
Socket
*
server_socket
)
RTC_RUN_ON
(
thread_
)
;
void
OnInternalSocketClose
(
AsyncPacketSocket
*
socket
int
err
)
;
void
HandleStunMessage
(
TurnServerConnection
*
conn
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
)
RTC_RUN_ON
(
thread_
)
;
void
HandleBindingRequest
(
TurnServerConnection
*
conn
const
cricket
:
:
StunMessage
*
msg
)
RTC_RUN_ON
(
thread_
)
;
void
HandleAllocateRequest
(
TurnServerConnection
*
conn
const
cricket
:
:
TurnMessage
*
msg
absl
:
:
string_view
key
)
RTC_RUN_ON
(
thread_
)
;
bool
GetKey
(
const
cricket
:
:
StunMessage
*
msg
std
:
:
string
*
key
)
RTC_RUN_ON
(
thread_
)
;
bool
CheckAuthorization
(
TurnServerConnection
*
conn
cricket
:
:
StunMessage
*
msg
absl
:
:
string_view
key
)
RTC_RUN_ON
(
thread_
)
;
bool
ValidateNonce
(
absl
:
:
string_view
nonce
)
const
RTC_RUN_ON
(
thread_
)
;
TurnServerAllocation
*
FindAllocation
(
TurnServerConnection
*
conn
)
RTC_RUN_ON
(
thread_
)
;
TurnServerAllocation
*
CreateAllocation
(
TurnServerConnection
*
conn
int
proto
absl
:
:
string_view
key
)
RTC_RUN_ON
(
thread_
)
;
void
SendErrorResponse
(
TurnServerConnection
*
conn
const
cricket
:
:
StunMessage
*
req
int
code
absl
:
:
string_view
reason
)
;
void
SendErrorResponseWithRealmAndNonce
(
TurnServerConnection
*
conn
const
cricket
:
:
StunMessage
*
req
int
code
absl
:
:
string_view
reason
)
RTC_RUN_ON
(
thread_
)
;
void
SendErrorResponseWithAlternateServer
(
TurnServerConnection
*
conn
const
cricket
:
:
StunMessage
*
req
const
SocketAddress
&
addr
)
RTC_RUN_ON
(
thread_
)
;
void
SendStun
(
TurnServerConnection
*
conn
cricket
:
:
StunMessage
*
msg
)
;
void
Send
(
TurnServerConnection
*
conn
const
ByteBufferWriter
&
buf
)
;
void
DestroyAllocation
(
TurnServerAllocation
*
allocation
)
RTC_RUN_ON
(
thread_
)
;
void
DestroyInternalSocket
(
AsyncPacketSocket
*
socket
)
RTC_RUN_ON
(
thread_
)
;
typedef
std
:
:
map
<
AsyncPacketSocket
*
ProtocolType
>
InternalSocketMap
;
struct
ServerSocketInfo
{
ProtocolType
proto
;
std
:
:
unique_ptr
<
SSLAdapterFactory
>
ssl_adapter_factory
;
}
;
typedef
std
:
:
map
<
Socket
*
ServerSocketInfo
>
ServerSocketMap
;
TaskQueueBase
*
const
thread_
;
const
std
:
:
string
nonce_key_
;
std
:
:
string
realm_
RTC_GUARDED_BY
(
thread_
)
;
std
:
:
string
software_
RTC_GUARDED_BY
(
thread_
)
;
TurnAuthInterface
*
auth_hook_
RTC_GUARDED_BY
(
thread_
)
;
TurnRedirectInterface
*
redirect_hook_
RTC_GUARDED_BY
(
thread_
)
;
bool
enable_otu_nonce_
RTC_GUARDED_BY
(
thread_
)
;
bool
reject_private_addresses_
RTC_GUARDED_BY
(
thread_
)
=
false
;
bool
reject_bind_requests_
RTC_GUARDED_BY
(
thread_
)
=
false
;
bool
enable_permission_checks_
=
true
;
InternalSocketMap
server_sockets_
RTC_GUARDED_BY
(
thread_
)
;
ServerSocketMap
server_listen_sockets_
RTC_GUARDED_BY
(
thread_
)
;
std
:
:
unique_ptr
<
PacketSocketFactory
>
external_socket_factory_
RTC_GUARDED_BY
(
thread_
)
;
SocketAddress
external_addr_
RTC_GUARDED_BY
(
thread_
)
;
AllocationMap
allocations_
RTC_GUARDED_BY
(
thread_
)
;
int64_t
ts_for_next_nonce_
RTC_GUARDED_BY
(
thread_
)
=
0
;
std
:
:
unique_ptr
<
StunMessageObserver
>
stun_message_observer_
RTC_GUARDED_BY
(
thread_
)
;
friend
class
TurnServerAllocation
;
}
;
}
namespace
cricket
{
using
:
:
webrtc
:
:
kMaxTurnChannelNumber
;
using
:
:
webrtc
:
:
kMinTurnChannelNumber
;
using
:
:
webrtc
:
:
StunMessageObserver
;
using
:
:
webrtc
:
:
TURN_SERVER_PORT
;
using
:
:
webrtc
:
:
TurnAuthInterface
;
using
:
:
webrtc
:
:
TurnRedirectInterface
;
using
:
:
webrtc
:
:
TurnServer
;
using
:
:
webrtc
:
:
TurnServerAllocation
;
using
:
:
webrtc
:
:
TurnServerConnection
;
}
#
endif
