#
ifndef
P2P_TEST_FAKE_PACKET_TRANSPORT_H_
#
define
P2P_TEST_FAKE_PACKET_TRANSPORT_H_
#
include
<
cstddef
>
#
include
<
map
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
transport
/
ecn_marking
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
class
FakePacketTransport
:
public
rtc
:
:
PacketTransportInternal
{
public
:
explicit
FakePacketTransport
(
const
std
:
:
string
&
transport_name
)
:
transport_name_
(
transport_name
)
{
}
~
FakePacketTransport
(
)
override
{
if
(
dest_
&
&
dest_
-
>
dest_
=
=
this
)
{
dest_
-
>
dest_
=
nullptr
;
}
}
void
SetWritable
(
bool
writable
)
{
set_writable
(
writable
)
;
}
void
SetReceiving
(
bool
receiving
)
{
set_receiving
(
receiving
)
;
}
void
SetDestination
(
FakePacketTransport
*
dest
bool
asymmetric
)
{
if
(
dest
)
{
dest_
=
dest
;
set_writable
(
true
)
;
if
(
!
asymmetric
)
{
dest
-
>
SetDestination
(
this
true
)
;
}
}
else
{
dest_
=
nullptr
;
set_writable
(
false
)
;
}
}
const
std
:
:
string
&
transport_name
(
)
const
override
{
return
transport_name_
;
}
bool
writable
(
)
const
override
{
return
writable_
;
}
bool
receiving
(
)
const
override
{
return
receiving_
;
}
int
SendPacket
(
const
char
*
data
size_t
len
const
rtc
:
:
PacketOptions
&
options
int
)
override
{
if
(
!
dest_
|
|
error_
!
=
0
)
{
return
-
1
;
}
CopyOnWriteBuffer
packet
(
data
len
)
;
SendPacketInternal
(
packet
options
)
;
rtc
:
:
SentPacket
sent_packet
(
options
.
packet_id
rtc
:
:
TimeMillis
(
)
)
;
SignalSentPacket
(
this
sent_packet
)
;
return
static_cast
<
int
>
(
len
)
;
}
int
SetOption
(
Socket
:
:
Option
opt
int
value
)
override
{
options_
[
opt
]
=
value
;
return
0
;
}
bool
GetOption
(
Socket
:
:
Option
opt
int
*
value
)
override
{
auto
it
=
options_
.
find
(
opt
)
;
if
(
it
=
=
options_
.
end
(
)
)
{
return
false
;
}
*
value
=
it
-
>
second
;
return
true
;
}
int
GetError
(
)
override
{
return
error_
;
}
void
SetError
(
int
error
)
{
error_
=
error
;
}
const
CopyOnWriteBuffer
*
last_sent_packet
(
)
{
return
&
last_sent_packet_
;
}
std
:
:
optional
<
NetworkRoute
>
network_route
(
)
const
override
{
return
network_route_
;
}
void
SetNetworkRoute
(
std
:
:
optional
<
NetworkRoute
>
network_route
)
{
network_route_
=
network_route
;
SignalNetworkRouteChanged
(
network_route
)
;
}
using
rtc
:
:
PacketTransportInternal
:
:
NotifyOnClose
;
using
rtc
:
:
PacketTransportInternal
:
:
NotifyPacketReceived
;
private
:
void
set_writable
(
bool
writable
)
{
if
(
writable_
=
=
writable
)
{
return
;
}
writable_
=
writable
;
if
(
writable_
)
{
SignalReadyToSend
(
this
)
;
}
SignalWritableState
(
this
)
;
}
void
set_receiving
(
bool
receiving
)
{
if
(
receiving_
=
=
receiving
)
{
return
;
}
receiving_
=
receiving
;
SignalReceivingState
(
this
)
;
}
void
SendPacketInternal
(
const
CopyOnWriteBuffer
&
packet
const
rtc
:
:
PacketOptions
&
options
)
{
last_sent_packet_
=
packet
;
if
(
dest_
)
{
dest_
-
>
NotifyPacketReceived
(
rtc
:
:
ReceivedPacket
(
packet
SocketAddress
(
)
Timestamp
:
:
Micros
(
rtc
:
:
TimeMicros
(
)
)
options
.
ecn_1
?
EcnMarking
:
:
kEct1
:
EcnMarking
:
:
kNotEct
)
)
;
}
}
CopyOnWriteBuffer
last_sent_packet_
;
std
:
:
string
transport_name_
;
FakePacketTransport
*
dest_
=
nullptr
;
bool
writable_
=
false
;
bool
receiving_
=
false
;
std
:
:
map
<
Socket
:
:
Option
int
>
options_
;
int
error_
=
0
;
std
:
:
optional
<
NetworkRoute
>
network_route_
;
}
;
}
namespace
rtc
{
using
:
:
webrtc
:
:
FakePacketTransport
;
}
#
endif
