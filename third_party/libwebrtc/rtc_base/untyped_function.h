#
ifndef
RTC_BASE_UNTYPED_FUNCTION_H_
#
define
RTC_BASE_UNTYPED_FUNCTION_H_
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
rtc_base
/
system
/
assume
.
h
"
namespace
webrtc
{
namespace
webrtc_function_impl
{
using
FunVoid
=
void
(
)
;
union
VoidUnion
{
void
*
void_ptr
;
FunVoid
*
fun_ptr
;
typename
std
:
:
aligned_storage
<
16
>
:
:
type
inline_storage
;
}
;
template
<
typename
T
>
struct
CallHelpers
;
template
<
typename
RetT
typename
.
.
.
ArgT
>
struct
CallHelpers
<
RetT
(
ArgT
.
.
.
)
>
{
using
return_type
=
RetT
;
using
function_type
=
RetT
(
VoidUnion
*
ArgT
.
.
.
)
;
template
<
typename
F
>
static
RetT
CallVoidPtr
(
VoidUnion
*
vu
ArgT
.
.
.
args
)
{
return
(
*
static_cast
<
F
*
>
(
vu
-
>
void_ptr
)
)
(
std
:
:
forward
<
ArgT
>
(
args
)
.
.
.
)
;
}
static
RetT
CallFunPtr
(
VoidUnion
*
vu
ArgT
.
.
.
args
)
{
return
(
reinterpret_cast
<
RetT
(
*
)
(
ArgT
.
.
.
)
>
(
vu
-
>
fun_ptr
)
)
(
std
:
:
forward
<
ArgT
>
(
args
)
.
.
.
)
;
}
template
<
typename
F
>
static
RetT
CallInlineStorage
(
VoidUnion
*
vu
ArgT
.
.
.
args
)
{
return
(
*
reinterpret_cast
<
F
*
>
(
&
vu
-
>
inline_storage
)
)
(
std
:
:
forward
<
ArgT
>
(
args
)
.
.
.
)
;
}
}
;
}
class
UntypedFunction
final
{
public
:
template
<
typename
Signature
typename
F
typename
std
:
:
enable_if
<
!
std
:
:
is_function
<
typename
std
:
:
remove_pointer
<
typename
std
:
:
remove_reference
<
F
>
:
:
type
>
:
:
type
>
:
:
value
&
&
!
std
:
:
is_same
<
std
:
:
nullptr_t
typename
std
:
:
remove_cv
<
F
>
:
:
type
>
:
:
value
&
&
!
std
:
:
is_same
<
UntypedFunction
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
F
>
:
:
type
>
:
:
type
>
:
:
value
>
:
:
type
*
=
nullptr
>
static
UntypedFunction
Create
(
F
&
&
f
)
{
using
F_deref
=
typename
std
:
:
remove_reference
<
F
>
:
:
type
;
if
(
std
:
:
is_trivially_move_constructible
<
F_deref
>
:
:
value
&
&
std
:
:
is_trivially_destructible
<
F_deref
>
:
:
value
&
&
sizeof
(
F_deref
)
<
=
sizeof
(
webrtc_function_impl
:
:
VoidUnion
:
:
inline_storage
)
)
{
webrtc_function_impl
:
:
VoidUnion
vu
;
new
(
&
vu
.
inline_storage
)
F_deref
(
std
:
:
forward
<
F
>
(
f
)
)
;
return
UntypedFunction
(
vu
reinterpret_cast
<
webrtc_function_impl
:
:
FunVoid
*
>
(
webrtc_function_impl
:
:
CallHelpers
<
Signature
>
:
:
template
CallInlineStorage
<
F_deref
>
)
nullptr
)
;
}
else
{
webrtc_function_impl
:
:
VoidUnion
vu
;
vu
.
void_ptr
=
new
F_deref
(
std
:
:
forward
<
F
>
(
f
)
)
;
return
UntypedFunction
(
vu
reinterpret_cast
<
webrtc_function_impl
:
:
FunVoid
*
>
(
webrtc_function_impl
:
:
CallHelpers
<
Signature
>
:
:
template
CallVoidPtr
<
F_deref
>
)
static_cast
<
void
(
*
)
(
webrtc_function_impl
:
:
VoidUnion
*
)
>
(
[
]
(
webrtc_function_impl
:
:
VoidUnion
*
vu
)
{
RTC_ASSUME
(
vu
-
>
void_ptr
!
=
nullptr
)
;
delete
reinterpret_cast
<
F_deref
*
>
(
vu
-
>
void_ptr
)
;
}
)
)
;
}
}
template
<
typename
Signature
>
static
UntypedFunction
Create
(
Signature
*
f
)
{
webrtc_function_impl
:
:
VoidUnion
vu
;
vu
.
fun_ptr
=
reinterpret_cast
<
webrtc_function_impl
:
:
FunVoid
*
>
(
f
)
;
return
UntypedFunction
(
vu
f
?
reinterpret_cast
<
webrtc_function_impl
:
:
FunVoid
*
>
(
webrtc_function_impl
:
:
CallHelpers
<
Signature
>
:
:
CallFunPtr
)
:
nullptr
nullptr
)
;
}
UntypedFunction
(
)
:
call_
(
nullptr
)
delete_
(
nullptr
)
{
}
UntypedFunction
(
std
:
:
nullptr_t
)
:
call_
(
nullptr
)
delete_
(
nullptr
)
{
}
UntypedFunction
&
operator
=
(
std
:
:
nullptr_t
)
{
call_
=
nullptr
;
if
(
delete_
)
{
delete_
(
&
f_
)
;
delete_
=
nullptr
;
}
return
*
this
;
}
UntypedFunction
(
const
UntypedFunction
&
)
=
delete
;
UntypedFunction
&
operator
=
(
const
UntypedFunction
&
)
=
delete
;
UntypedFunction
(
UntypedFunction
&
&
other
)
:
f_
(
other
.
f_
)
call_
(
other
.
call_
)
delete_
(
other
.
delete_
)
{
other
.
delete_
=
nullptr
;
}
UntypedFunction
&
operator
=
(
UntypedFunction
&
&
other
)
{
if
(
delete_
)
{
delete_
(
&
f_
)
;
}
f_
=
other
.
f_
;
call_
=
other
.
call_
;
delete_
=
other
.
delete_
;
other
.
delete_
=
nullptr
;
return
*
this
;
}
~
UntypedFunction
(
)
{
if
(
delete_
)
{
delete_
(
&
f_
)
;
}
}
friend
void
swap
(
UntypedFunction
&
a
UntypedFunction
&
b
)
{
using
std
:
:
swap
;
swap
(
a
.
f_
b
.
f_
)
;
swap
(
a
.
call_
b
.
call_
)
;
swap
(
a
.
delete_
b
.
delete_
)
;
}
explicit
operator
bool
(
)
const
{
return
call_
!
=
nullptr
;
}
template
<
typename
Signature
typename
.
.
.
ArgT
>
typename
webrtc_function_impl
:
:
CallHelpers
<
Signature
>
:
:
return_type
Call
(
ArgT
&
&
.
.
.
args
)
{
return
reinterpret_cast
<
typename
webrtc_function_impl
:
:
CallHelpers
<
Signature
>
:
:
function_type
*
>
(
call_
)
(
&
f_
std
:
:
forward
<
ArgT
>
(
args
)
.
.
.
)
;
}
bool
IsTriviallyDestructible
(
)
{
return
delete_
=
=
nullptr
;
}
private
:
UntypedFunction
(
webrtc_function_impl
:
:
VoidUnion
f
webrtc_function_impl
:
:
FunVoid
*
call
void
(
*
del
)
(
webrtc_function_impl
:
:
VoidUnion
*
)
)
:
f_
(
f
)
call_
(
call
)
delete_
(
del
)
{
}
webrtc_function_impl
:
:
VoidUnion
f_
;
webrtc_function_impl
:
:
FunVoid
*
call_
;
void
(
*
delete_
)
(
webrtc_function_impl
:
:
VoidUnion
*
)
;
}
;
}
#
endif
