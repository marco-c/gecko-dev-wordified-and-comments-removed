#
ifndef
RTC_BASE_SERVER_SOCKET_ADAPTERS_H_
#
define
RTC_BASE_SERVER_SOCKET_ADAPTERS_H_
#
include
"
rtc_base
/
socket_adapters
.
h
"
namespace
rtc
{
class
AsyncProxyServerSocket
:
public
BufferedReadAdapter
{
public
:
AsyncProxyServerSocket
(
AsyncSocket
*
socket
size_t
buffer_size
)
;
~
AsyncProxyServerSocket
(
)
override
;
sigslot
:
:
signal2
<
AsyncProxyServerSocket
*
const
SocketAddress
&
>
SignalConnectRequest
;
virtual
void
SendConnectResult
(
int
err
const
SocketAddress
&
addr
)
=
0
;
}
;
class
AsyncSSLServerSocket
:
public
BufferedReadAdapter
{
public
:
explicit
AsyncSSLServerSocket
(
AsyncSocket
*
socket
)
;
protected
:
void
ProcessInput
(
char
*
data
size_t
*
len
)
override
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AsyncSSLServerSocket
)
;
}
;
class
AsyncSocksProxyServerSocket
:
public
AsyncProxyServerSocket
{
public
:
explicit
AsyncSocksProxyServerSocket
(
AsyncSocket
*
socket
)
;
private
:
void
ProcessInput
(
char
*
data
size_t
*
len
)
override
;
void
DirectSend
(
const
ByteBufferWriter
&
buf
)
;
void
HandleHello
(
ByteBufferReader
*
request
)
;
void
SendHelloReply
(
uint8_t
method
)
;
void
HandleAuth
(
ByteBufferReader
*
request
)
;
void
SendAuthReply
(
uint8_t
result
)
;
void
HandleConnect
(
ByteBufferReader
*
request
)
;
void
SendConnectResult
(
int
result
const
SocketAddress
&
addr
)
override
;
void
Error
(
int
error
)
;
static
const
int
kBufferSize
=
1024
;
enum
State
{
SS_HELLO
SS_AUTH
SS_CONNECT
SS_CONNECT_PENDING
SS_TUNNEL
SS_ERROR
}
;
State
state_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AsyncSocksProxyServerSocket
)
;
}
;
}
#
endif
