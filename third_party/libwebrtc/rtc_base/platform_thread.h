#
ifndef
RTC_BASE_PLATFORM_THREAD_H_
#
define
RTC_BASE_PLATFORM_THREAD_H_
#
include
<
functional
>
#
include
<
string
>
#
if
!
defined
(
WEBRTC_WIN
)
#
include
<
pthread
.
h
>
#
endif
#
include
<
optional
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
namespace
webrtc
{
enum
class
ThreadPriority
{
kLow
=
1
kNormal
kHigh
kRealtime
}
;
struct
ThreadAttributes
{
ThreadPriority
priority
=
ThreadPriority
:
:
kNormal
;
ThreadAttributes
&
SetPriority
(
ThreadPriority
priority_param
)
{
priority
=
priority_param
;
return
*
this
;
}
}
;
class
PlatformThread
final
{
public
:
#
if
defined
(
WEBRTC_WIN
)
using
Handle
=
HANDLE
;
#
else
using
Handle
=
pthread_t
;
#
endif
PlatformThread
(
)
=
default
;
PlatformThread
(
PlatformThread
&
&
rhs
)
;
PlatformThread
(
const
PlatformThread
&
)
=
delete
;
PlatformThread
&
operator
=
(
const
PlatformThread
&
)
=
delete
;
PlatformThread
&
operator
=
(
PlatformThread
&
&
rhs
)
;
~
PlatformThread
(
)
;
void
Finalize
(
)
;
bool
empty
(
)
const
{
return
!
handle_
.
has_value
(
)
;
}
static
PlatformThread
SpawnJoinable
(
std
:
:
function
<
void
(
)
>
thread_function
absl
:
:
string_view
name
ThreadAttributes
attributes
=
ThreadAttributes
(
)
)
;
static
PlatformThread
SpawnDetached
(
std
:
:
function
<
void
(
)
>
thread_function
absl
:
:
string_view
name
ThreadAttributes
attributes
=
ThreadAttributes
(
)
)
;
std
:
:
optional
<
Handle
>
GetHandle
(
)
const
;
#
if
defined
(
WEBRTC_WIN
)
bool
QueueAPC
(
PAPCFUNC
apc_function
ULONG_PTR
data
)
;
#
endif
private
:
PlatformThread
(
Handle
handle
bool
joinable
)
;
static
PlatformThread
SpawnThread
(
std
:
:
function
<
void
(
)
>
thread_function
absl
:
:
string_view
name
ThreadAttributes
attributes
bool
joinable
)
;
std
:
:
optional
<
Handle
>
handle_
;
bool
joinable_
=
false
;
}
;
}
#
ifdef
WEBRTC_ALLOW_DEPRECATED_NAMESPACES
namespace
rtc
{
using
:
:
webrtc
:
:
PlatformThread
;
using
:
:
webrtc
:
:
ThreadAttributes
;
using
:
:
webrtc
:
:
ThreadPriority
;
}
#
endif
#
endif
