#
ifndef
RTC_BASE_TEST_UTILS_H_
#
define
RTC_BASE_TEST_UTILS_H_
#
include
<
map
>
#
include
<
utility
>
#
include
"
rtc_base
/
async_socket
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
namespace
webrtc
{
namespace
testing
{
enum
StreamSinkEvent
{
SSE_OPEN
=
1
SSE_READ
=
2
SSE_WRITE
=
4
SSE_CLOSE
=
8
SSE_ERROR
=
16
}
;
class
StreamSink
:
public
sigslot
:
:
has_slots
<
>
{
public
:
StreamSink
(
)
;
~
StreamSink
(
)
override
;
void
Monitor
(
rtc
:
:
AsyncSocket
*
socket
)
{
socket
-
>
SignalConnectEvent
.
connect
(
this
&
StreamSink
:
:
OnConnectEvent
)
;
socket
-
>
SignalReadEvent
.
connect
(
this
&
StreamSink
:
:
OnReadEvent
)
;
socket
-
>
SignalWriteEvent
.
connect
(
this
&
StreamSink
:
:
OnWriteEvent
)
;
socket
-
>
SignalCloseEvent
.
connect
(
this
&
StreamSink
:
:
OnCloseEvent
)
;
events_
.
erase
(
socket
)
;
}
void
Unmonitor
(
rtc
:
:
AsyncSocket
*
socket
)
{
socket
-
>
SignalConnectEvent
.
disconnect
(
this
)
;
socket
-
>
SignalReadEvent
.
disconnect
(
this
)
;
socket
-
>
SignalWriteEvent
.
disconnect
(
this
)
;
socket
-
>
SignalCloseEvent
.
disconnect
(
this
)
;
events_
.
erase
(
socket
)
;
}
bool
Check
(
rtc
:
:
AsyncSocket
*
socket
StreamSinkEvent
event
bool
reset
=
true
)
{
return
DoCheck
(
socket
event
reset
)
;
}
private
:
typedef
std
:
:
map
<
rtc
:
:
AsyncSocket
*
int
>
EventMap
;
void
OnConnectEvent
(
rtc
:
:
AsyncSocket
*
socket
)
{
AddEvents
(
socket
SSE_OPEN
)
;
}
void
OnReadEvent
(
rtc
:
:
AsyncSocket
*
socket
)
{
AddEvents
(
socket
SSE_READ
)
;
}
void
OnWriteEvent
(
rtc
:
:
AsyncSocket
*
socket
)
{
AddEvents
(
socket
SSE_WRITE
)
;
}
void
OnCloseEvent
(
rtc
:
:
AsyncSocket
*
socket
int
error
)
{
AddEvents
(
socket
(
0
=
=
error
)
?
SSE_CLOSE
:
SSE_ERROR
)
;
}
void
AddEvents
(
rtc
:
:
AsyncSocket
*
obj
int
events
)
{
EventMap
:
:
iterator
it
=
events_
.
find
(
obj
)
;
if
(
events_
.
end
(
)
=
=
it
)
{
events_
.
insert
(
EventMap
:
:
value_type
(
obj
events
)
)
;
}
else
{
it
-
>
second
|
=
events
;
}
}
bool
DoCheck
(
rtc
:
:
AsyncSocket
*
obj
StreamSinkEvent
event
bool
reset
)
{
EventMap
:
:
iterator
it
=
events_
.
find
(
obj
)
;
if
(
(
events_
.
end
(
)
=
=
it
)
|
|
(
0
=
=
(
it
-
>
second
&
event
)
)
)
{
return
false
;
}
if
(
reset
)
{
it
-
>
second
&
=
~
event
;
}
return
true
;
}
EventMap
events_
;
}
;
}
}
#
endif
