#
ifndef
RTC_BASE_NUMERICS_SAFE_MINMAX_H_
#
define
RTC_BASE_NUMERICS_SAFE_MINMAX_H_
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_compare
.
h
"
#
include
"
rtc_base
/
type_traits
.
h
"
namespace
rtc
{
namespace
safe_minmax_impl
{
template
<
typename
T
>
struct
Limits
{
static
constexpr
T
lowest
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
;
static
constexpr
T
max
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
}
;
template
<
typename
T
bool
is_enum
=
std
:
:
is_enum
<
T
>
:
:
value
>
struct
UnderlyingType
;
template
<
typename
T
>
struct
UnderlyingType
<
T
false
>
{
using
type
=
T
;
}
;
template
<
typename
T
>
struct
UnderlyingType
<
T
true
>
{
using
type
=
typename
std
:
:
underlying_type
<
T
>
:
:
type
;
}
;
template
<
typename
T1
typename
T2
bool
int1
=
IsIntlike
<
T1
>
:
:
value
bool
int2
=
IsIntlike
<
T2
>
:
:
value
>
struct
MType
{
static_assert
(
int1
=
=
int2
"
You
may
not
mix
integral
and
floating
-
point
arguments
"
)
;
}
;
template
<
typename
T1
typename
T2
>
struct
MType
<
T1
T2
false
false
>
{
using
min_t
=
typename
std
:
:
common_type
<
T1
T2
>
:
:
type
;
static_assert
(
std
:
:
is_same
<
min_t
T1
>
:
:
value
|
|
std
:
:
is_same
<
min_t
T2
>
:
:
value
"
"
)
;
using
max_t
=
typename
std
:
:
common_type
<
T1
T2
>
:
:
type
;
static_assert
(
std
:
:
is_same
<
max_t
T1
>
:
:
value
|
|
std
:
:
is_same
<
max_t
T2
>
:
:
value
"
"
)
;
}
;
template
<
typename
T1
typename
T2
>
struct
MType
<
T1
T2
true
true
>
{
using
min_t
=
typename
std
:
:
conditional
<
SafeLt
(
Limits
<
T1
>
:
:
lowest
Limits
<
T2
>
:
:
lowest
)
T1
typename
std
:
:
conditional
<
SafeGt
(
Limits
<
T1
>
:
:
lowest
Limits
<
T2
>
:
:
lowest
)
T2
typename
std
:
:
conditional
<
SafeLe
(
Limits
<
T1
>
:
:
max
Limits
<
T2
>
:
:
max
)
T1
T2
>
:
:
type
>
:
:
type
>
:
:
type
;
static_assert
(
std
:
:
is_same
<
min_t
T1
>
:
:
value
|
|
std
:
:
is_same
<
min_t
T2
>
:
:
value
"
"
)
;
static_assert
(
SafeNe
(
Limits
<
T1
>
:
:
max
Limits
<
T2
>
:
:
max
)
|
|
SafeEq
(
Limits
<
T1
>
:
:
lowest
Limits
<
T2
>
:
:
lowest
)
"
integer
types
with
the
same
max
should
have
the
same
min
"
)
;
using
max_t
=
typename
std
:
:
conditional
<
SafeGe
(
Limits
<
T1
>
:
:
max
Limits
<
T2
>
:
:
max
)
T1
T2
>
:
:
type
;
static_assert
(
std
:
:
is_same
<
max_t
T1
>
:
:
value
|
|
std
:
:
is_same
<
max_t
T2
>
:
:
value
"
"
)
;
}
;
struct
DefaultType
;
template
<
typename
A
typename
B
>
struct
TypeOr
{
using
type
=
typename
std
:
:
conditional
<
std
:
:
is_same
<
A
DefaultType
>
:
:
value
B
A
>
:
:
type
;
static_assert
(
SafeLe
(
Limits
<
type
>
:
:
lowest
Limits
<
B
>
:
:
lowest
)
&
&
SafeGe
(
Limits
<
type
>
:
:
max
Limits
<
B
>
:
:
max
)
"
The
specified
type
isn
'
t
large
enough
"
)
;
static_assert
(
IsIntlike
<
type
>
:
:
value
=
=
IsIntlike
<
B
>
:
:
value
&
&
std
:
:
is_floating_point
<
type
>
:
:
value
=
=
std
:
:
is_floating_point
<
type
>
:
:
value
"
float
<
-
>
int
conversions
not
allowed
"
)
;
}
;
}
template
<
typename
R
=
safe_minmax_impl
:
:
DefaultType
typename
T1
=
safe_minmax_impl
:
:
DefaultType
typename
T2
=
safe_minmax_impl
:
:
DefaultType
typename
R2
=
typename
safe_minmax_impl
:
:
TypeOr
<
R
typename
safe_minmax_impl
:
:
MType
<
typename
safe_minmax_impl
:
:
UnderlyingType
<
T1
>
:
:
type
typename
safe_minmax_impl
:
:
UnderlyingType
<
T2
>
:
:
type
>
:
:
min_t
>
:
:
type
>
constexpr
R2
SafeMin
(
T1
a
T2
b
)
{
static_assert
(
IsIntlike
<
T1
>
:
:
value
|
|
std
:
:
is_floating_point
<
T1
>
:
:
value
"
The
first
argument
must
be
integral
or
floating
-
point
"
)
;
static_assert
(
IsIntlike
<
T2
>
:
:
value
|
|
std
:
:
is_floating_point
<
T2
>
:
:
value
"
The
second
argument
must
be
integral
or
floating
-
point
"
)
;
return
SafeLt
(
a
b
)
?
static_cast
<
R2
>
(
a
)
:
static_cast
<
R2
>
(
b
)
;
}
template
<
typename
R
=
safe_minmax_impl
:
:
DefaultType
typename
T1
=
safe_minmax_impl
:
:
DefaultType
typename
T2
=
safe_minmax_impl
:
:
DefaultType
typename
R2
=
typename
safe_minmax_impl
:
:
TypeOr
<
R
typename
safe_minmax_impl
:
:
MType
<
typename
safe_minmax_impl
:
:
UnderlyingType
<
T1
>
:
:
type
typename
safe_minmax_impl
:
:
UnderlyingType
<
T2
>
:
:
type
>
:
:
max_t
>
:
:
type
>
constexpr
R2
SafeMax
(
T1
a
T2
b
)
{
static_assert
(
IsIntlike
<
T1
>
:
:
value
|
|
std
:
:
is_floating_point
<
T1
>
:
:
value
"
The
first
argument
must
be
integral
or
floating
-
point
"
)
;
static_assert
(
IsIntlike
<
T2
>
:
:
value
|
|
std
:
:
is_floating_point
<
T2
>
:
:
value
"
The
second
argument
must
be
integral
or
floating
-
point
"
)
;
return
SafeGt
(
a
b
)
?
static_cast
<
R2
>
(
a
)
:
static_cast
<
R2
>
(
b
)
;
}
namespace
safe_minmax_impl
{
template
<
typename
T
typename
L
typename
H
bool
int1
=
IsIntlike
<
T
>
:
:
value
bool
int2
=
IsIntlike
<
L
>
:
:
value
bool
int3
=
IsIntlike
<
H
>
:
:
value
>
struct
ClampType
{
static_assert
(
int1
=
=
int2
&
&
int1
=
=
int3
"
You
may
not
mix
integral
and
floating
-
point
arguments
"
)
;
}
;
template
<
typename
T
typename
L
typename
H
>
struct
ClampType
<
T
L
H
false
false
false
>
{
using
type
=
typename
std
:
:
common_type
<
T
L
H
>
:
:
type
;
}
;
template
<
typename
T
typename
L
typename
H
>
struct
ClampType
<
T
L
H
true
true
true
>
{
private
:
static
constexpr
auto
r_min
=
SafeMax
(
Limits
<
L
>
:
:
lowest
SafeMin
(
Limits
<
H
>
:
:
lowest
Limits
<
T
>
:
:
lowest
)
)
;
static
constexpr
auto
r_max
=
SafeMin
(
Limits
<
H
>
:
:
max
SafeMax
(
Limits
<
L
>
:
:
max
Limits
<
T
>
:
:
max
)
)
;
template
<
typename
A
>
struct
AcceptableType
{
private
:
static
constexpr
bool
not_too_large
=
sizeof
(
A
)
<
=
sizeof
(
L
)
|
|
sizeof
(
A
)
<
=
sizeof
(
H
)
|
|
sizeof
(
A
)
<
=
sizeof
(
T
)
;
static
constexpr
bool
range_contained
=
SafeLe
(
Limits
<
A
>
:
:
lowest
r_min
)
&
&
SafeLe
(
r_max
Limits
<
A
>
:
:
max
)
;
public
:
static
constexpr
bool
value
=
not_too_large
&
&
range_contained
;
}
;
using
best_signed_type
=
typename
std
:
:
conditional
<
AcceptableType
<
int8_t
>
:
:
value
int8_t
typename
std
:
:
conditional
<
AcceptableType
<
int16_t
>
:
:
value
int16_t
typename
std
:
:
conditional
<
AcceptableType
<
int32_t
>
:
:
value
int32_t
int64_t
>
:
:
type
>
:
:
type
>
:
:
type
;
using
best_unsigned_type
=
typename
std
:
:
conditional
<
AcceptableType
<
uint8_t
>
:
:
value
uint8_t
typename
std
:
:
conditional
<
AcceptableType
<
uint16_t
>
:
:
value
uint16_t
typename
std
:
:
conditional
<
AcceptableType
<
uint32_t
>
:
:
value
uint32_t
uint64_t
>
:
:
type
>
:
:
type
>
:
:
type
;
public
:
using
type
=
typename
std
:
:
conditional
<
std
:
:
is_signed
<
T
>
:
:
value
typename
std
:
:
conditional
<
AcceptableType
<
best_signed_type
>
:
:
value
best_signed_type
best_unsigned_type
>
:
:
type
typename
std
:
:
conditional
<
AcceptableType
<
best_unsigned_type
>
:
:
value
best_unsigned_type
best_signed_type
>
:
:
type
>
:
:
type
;
static_assert
(
AcceptableType
<
type
>
:
:
value
"
"
)
;
}
;
}
template
<
typename
R
=
safe_minmax_impl
:
:
DefaultType
typename
T
=
safe_minmax_impl
:
:
DefaultType
typename
L
=
safe_minmax_impl
:
:
DefaultType
typename
H
=
safe_minmax_impl
:
:
DefaultType
typename
R2
=
typename
safe_minmax_impl
:
:
TypeOr
<
R
typename
safe_minmax_impl
:
:
ClampType
<
typename
safe_minmax_impl
:
:
UnderlyingType
<
T
>
:
:
type
typename
safe_minmax_impl
:
:
UnderlyingType
<
L
>
:
:
type
typename
safe_minmax_impl
:
:
UnderlyingType
<
H
>
:
:
type
>
:
:
type
>
:
:
type
>
R2
SafeClamp
(
T
x
L
min
H
max
)
{
static_assert
(
IsIntlike
<
H
>
:
:
value
|
|
std
:
:
is_floating_point
<
H
>
:
:
value
"
The
first
argument
must
be
integral
or
floating
-
point
"
)
;
static_assert
(
IsIntlike
<
T
>
:
:
value
|
|
std
:
:
is_floating_point
<
T
>
:
:
value
"
The
second
argument
must
be
integral
or
floating
-
point
"
)
;
static_assert
(
IsIntlike
<
L
>
:
:
value
|
|
std
:
:
is_floating_point
<
L
>
:
:
value
"
The
third
argument
must
be
integral
or
floating
-
point
"
)
;
RTC_DCHECK_LE
(
min
max
)
;
return
SafeLe
(
x
min
)
?
static_cast
<
R2
>
(
min
)
:
SafeGe
(
x
max
)
?
static_cast
<
R2
>
(
max
)
:
static_cast
<
R2
>
(
x
)
;
}
}
#
endif
