#
ifndef
RTC_BASE_NUMERICS_MOVING_MAX_COUNTER_H_
#
define
RTC_BASE_NUMERICS_MOVING_MAX_COUNTER_H_
#
include
<
stdint
.
h
>
#
include
<
deque
>
#
include
<
limits
>
#
include
<
optional
>
#
include
<
utility
>
#
include
"
rtc_base
/
checks
.
h
"
namespace
rtc
{
template
<
class
T
>
class
MovingMaxCounter
{
public
:
explicit
MovingMaxCounter
(
int64_t
window_length_ms
)
;
MovingMaxCounter
(
const
MovingMaxCounter
&
)
=
delete
;
MovingMaxCounter
&
operator
=
(
const
MovingMaxCounter
&
)
=
delete
;
void
Add
(
const
T
&
sample
int64_t
current_time_ms
)
;
std
:
:
optional
<
T
>
Max
(
int64_t
current_time_ms
)
;
void
Reset
(
)
;
private
:
void
RollWindow
(
int64_t
new_time_ms
)
;
const
int64_t
window_length_ms_
;
std
:
:
deque
<
std
:
:
pair
<
int64_t
T
>
>
samples_
;
#
if
RTC_DCHECK_IS_ON
int64_t
last_call_time_ms_
=
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
;
#
endif
}
;
template
<
class
T
>
MovingMaxCounter
<
T
>
:
:
MovingMaxCounter
(
int64_t
window_length_ms
)
:
window_length_ms_
(
window_length_ms
)
{
}
template
<
class
T
>
void
MovingMaxCounter
<
T
>
:
:
Add
(
const
T
&
sample
int64_t
current_time_ms
)
{
RollWindow
(
current_time_ms
)
;
while
(
!
samples_
.
empty
(
)
&
&
samples_
.
back
(
)
.
second
<
=
sample
)
{
samples_
.
pop_back
(
)
;
}
if
(
samples_
.
empty
(
)
|
|
samples_
.
back
(
)
.
first
<
current_time_ms
)
{
samples_
.
emplace_back
(
std
:
:
make_pair
(
current_time_ms
sample
)
)
;
}
}
template
<
class
T
>
std
:
:
optional
<
T
>
MovingMaxCounter
<
T
>
:
:
Max
(
int64_t
current_time_ms
)
{
RollWindow
(
current_time_ms
)
;
std
:
:
optional
<
T
>
res
;
if
(
!
samples_
.
empty
(
)
)
{
res
.
emplace
(
samples_
.
front
(
)
.
second
)
;
}
return
res
;
}
template
<
class
T
>
void
MovingMaxCounter
<
T
>
:
:
Reset
(
)
{
samples_
.
clear
(
)
;
}
template
<
class
T
>
void
MovingMaxCounter
<
T
>
:
:
RollWindow
(
int64_t
new_time_ms
)
{
#
if
RTC_DCHECK_IS_ON
RTC_DCHECK_GE
(
new_time_ms
last_call_time_ms_
)
;
last_call_time_ms_
=
new_time_ms
;
#
endif
const
int64_t
window_begin_ms
=
new_time_ms
-
window_length_ms_
;
auto
it
=
samples_
.
begin
(
)
;
while
(
it
!
=
samples_
.
end
(
)
&
&
it
-
>
first
<
window_begin_ms
)
{
+
+
it
;
}
samples_
.
erase
(
samples_
.
begin
(
)
it
)
;
}
}
#
endif
