#
ifndef
RTC_BASE_EXPERIMENTS_FIELD_TRIAL_PARSER_H_
#
define
RTC_BASE_EXPERIMENTS_FIELD_TRIAL_PARSER_H_
#
include
<
stdint
.
h
>
#
include
<
initializer_list
>
#
include
<
map
>
#
include
<
optional
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
webrtc
{
class
FieldTrialParameterInterface
{
public
:
virtual
~
FieldTrialParameterInterface
(
)
;
std
:
:
string
key
(
)
const
{
return
key_
;
}
protected
:
FieldTrialParameterInterface
(
const
FieldTrialParameterInterface
&
)
=
default
;
FieldTrialParameterInterface
&
operator
=
(
const
FieldTrialParameterInterface
&
)
=
default
;
explicit
FieldTrialParameterInterface
(
absl
:
:
string_view
key
)
;
friend
void
ParseFieldTrial
(
std
:
:
initializer_list
<
FieldTrialParameterInterface
*
>
fields
absl
:
:
string_view
trial_string
)
;
void
MarkAsUsed
(
)
{
used_
=
true
;
}
virtual
bool
Parse
(
std
:
:
optional
<
std
:
:
string
>
str_value
)
=
0
;
virtual
void
ParseDone
(
)
{
}
std
:
:
vector
<
FieldTrialParameterInterface
*
>
sub_parameters_
;
private
:
std
:
:
string
key_
;
bool
used_
=
false
;
}
;
void
ParseFieldTrial
(
std
:
:
initializer_list
<
FieldTrialParameterInterface
*
>
fields
absl
:
:
string_view
trial_string
)
;
template
<
typename
T
>
std
:
:
optional
<
T
>
ParseTypedParameter
(
absl
:
:
string_view
)
;
template
<
typename
T
>
class
FieldTrialParameter
:
public
FieldTrialParameterInterface
{
public
:
FieldTrialParameter
(
absl
:
:
string_view
key
T
default_value
)
:
FieldTrialParameterInterface
(
key
)
value_
(
default_value
)
{
}
T
Get
(
)
const
{
return
value_
;
}
operator
T
(
)
const
{
return
Get
(
)
;
}
const
T
*
operator
-
>
(
)
const
{
return
&
value_
;
}
void
SetForTest
(
T
value
)
{
value_
=
value
;
}
protected
:
bool
Parse
(
std
:
:
optional
<
std
:
:
string
>
str_value
)
override
{
if
(
str_value
)
{
std
:
:
optional
<
T
>
value
=
ParseTypedParameter
<
T
>
(
*
str_value
)
;
if
(
value
.
has_value
(
)
)
{
value_
=
value
.
value
(
)
;
return
true
;
}
}
return
false
;
}
private
:
T
value_
;
}
;
template
<
typename
T
>
class
FieldTrialConstrained
:
public
FieldTrialParameterInterface
{
public
:
FieldTrialConstrained
(
absl
:
:
string_view
key
T
default_value
std
:
:
optional
<
T
>
lower_limit
std
:
:
optional
<
T
>
upper_limit
)
:
FieldTrialParameterInterface
(
key
)
value_
(
default_value
)
lower_limit_
(
lower_limit
)
upper_limit_
(
upper_limit
)
{
}
T
Get
(
)
const
{
return
value_
;
}
operator
T
(
)
const
{
return
Get
(
)
;
}
const
T
*
operator
-
>
(
)
const
{
return
&
value_
;
}
protected
:
bool
Parse
(
std
:
:
optional
<
std
:
:
string
>
str_value
)
override
{
if
(
str_value
)
{
std
:
:
optional
<
T
>
value
=
ParseTypedParameter
<
T
>
(
*
str_value
)
;
if
(
value
&
&
(
!
lower_limit_
|
|
*
value
>
=
*
lower_limit_
)
&
&
(
!
upper_limit_
|
|
*
value
<
=
*
upper_limit_
)
)
{
value_
=
*
value
;
return
true
;
}
}
return
false
;
}
private
:
T
value_
;
std
:
:
optional
<
T
>
lower_limit_
;
std
:
:
optional
<
T
>
upper_limit_
;
}
;
class
AbstractFieldTrialEnum
:
public
FieldTrialParameterInterface
{
public
:
AbstractFieldTrialEnum
(
absl
:
:
string_view
key
int
default_value
std
:
:
map
<
std
:
:
string
int
>
mapping
)
;
~
AbstractFieldTrialEnum
(
)
override
;
AbstractFieldTrialEnum
(
const
AbstractFieldTrialEnum
&
)
;
protected
:
bool
Parse
(
std
:
:
optional
<
std
:
:
string
>
str_value
)
override
;
protected
:
int
value_
;
std
:
:
map
<
std
:
:
string
int
>
enum_mapping_
;
std
:
:
set
<
int
>
valid_values_
;
}
;
template
<
typename
T
>
class
FieldTrialEnum
:
public
AbstractFieldTrialEnum
{
public
:
FieldTrialEnum
(
absl
:
:
string_view
key
T
default_value
std
:
:
map
<
std
:
:
string
T
>
mapping
)
:
AbstractFieldTrialEnum
(
key
static_cast
<
int
>
(
default_value
)
ToIntMap
(
mapping
)
)
{
}
T
Get
(
)
const
{
return
static_cast
<
T
>
(
value_
)
;
}
operator
T
(
)
const
{
return
Get
(
)
;
}
private
:
static
std
:
:
map
<
std
:
:
string
int
>
ToIntMap
(
std
:
:
map
<
std
:
:
string
T
>
mapping
)
{
std
:
:
map
<
std
:
:
string
int
>
res
;
for
(
const
auto
&
it
:
mapping
)
res
[
it
.
first
]
=
static_cast
<
int
>
(
it
.
second
)
;
return
res
;
}
}
;
template
<
typename
T
>
class
FieldTrialOptional
:
public
FieldTrialParameterInterface
{
public
:
explicit
FieldTrialOptional
(
absl
:
:
string_view
key
)
:
FieldTrialParameterInterface
(
key
)
{
}
FieldTrialOptional
(
absl
:
:
string_view
key
std
:
:
optional
<
T
>
default_value
)
:
FieldTrialParameterInterface
(
key
)
value_
(
default_value
)
{
}
std
:
:
optional
<
T
>
GetOptional
(
)
const
{
return
value_
;
}
const
T
&
Value
(
)
const
{
return
value_
.
value
(
)
;
}
const
T
&
operator
*
(
)
const
{
return
value_
.
value
(
)
;
}
const
T
*
operator
-
>
(
)
const
{
return
&
value_
.
value
(
)
;
}
explicit
operator
bool
(
)
const
{
return
value_
.
has_value
(
)
;
}
protected
:
bool
Parse
(
std
:
:
optional
<
std
:
:
string
>
str_value
)
override
{
if
(
str_value
)
{
std
:
:
optional
<
T
>
value
=
ParseTypedParameter
<
T
>
(
*
str_value
)
;
if
(
!
value
.
has_value
(
)
)
return
false
;
value_
=
value
.
value
(
)
;
}
else
{
value_
=
std
:
:
nullopt
;
}
return
true
;
}
private
:
std
:
:
optional
<
T
>
value_
;
}
;
class
FieldTrialFlag
:
public
FieldTrialParameterInterface
{
public
:
explicit
FieldTrialFlag
(
absl
:
:
string_view
key
)
;
FieldTrialFlag
(
absl
:
:
string_view
key
bool
default_value
)
;
bool
Get
(
)
const
;
explicit
operator
bool
(
)
const
;
protected
:
bool
Parse
(
std
:
:
optional
<
std
:
:
string
>
str_value
)
override
;
private
:
bool
value_
;
}
;
template
<
typename
T
>
std
:
:
optional
<
std
:
:
optional
<
T
>
>
ParseOptionalParameter
(
absl
:
:
string_view
str
)
{
if
(
str
.
empty
(
)
)
return
std
:
:
optional
<
T
>
(
)
;
auto
parsed
=
ParseTypedParameter
<
T
>
(
str
)
;
if
(
parsed
.
has_value
(
)
)
return
parsed
;
return
std
:
:
nullopt
;
}
template
<
>
std
:
:
optional
<
bool
>
ParseTypedParameter
<
bool
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
double
>
ParseTypedParameter
<
double
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
int
>
ParseTypedParameter
<
int
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
unsigned
>
ParseTypedParameter
<
unsigned
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
std
:
:
string
>
ParseTypedParameter
<
std
:
:
string
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
std
:
:
optional
<
bool
>
>
ParseTypedParameter
<
std
:
:
optional
<
bool
>
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
std
:
:
optional
<
int
>
>
ParseTypedParameter
<
std
:
:
optional
<
int
>
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
std
:
:
optional
<
unsigned
>
>
ParseTypedParameter
<
std
:
:
optional
<
unsigned
>
>
(
absl
:
:
string_view
str
)
;
template
<
>
std
:
:
optional
<
std
:
:
optional
<
double
>
>
ParseTypedParameter
<
std
:
:
optional
<
double
>
>
(
absl
:
:
string_view
str
)
;
extern
template
class
FieldTrialParameter
<
bool
>
;
extern
template
class
FieldTrialParameter
<
double
>
;
extern
template
class
FieldTrialParameter
<
int
>
;
extern
template
class
FieldTrialParameter
<
unsigned
>
;
extern
template
class
FieldTrialParameter
<
std
:
:
string
>
;
extern
template
class
FieldTrialConstrained
<
double
>
;
extern
template
class
FieldTrialConstrained
<
int
>
;
extern
template
class
FieldTrialConstrained
<
unsigned
>
;
extern
template
class
FieldTrialOptional
<
double
>
;
extern
template
class
FieldTrialOptional
<
int
>
;
extern
template
class
FieldTrialOptional
<
unsigned
>
;
extern
template
class
FieldTrialOptional
<
bool
>
;
extern
template
class
FieldTrialOptional
<
std
:
:
string
>
;
}
#
endif
