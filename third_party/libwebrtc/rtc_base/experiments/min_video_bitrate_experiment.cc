#
include
"
rtc_base
/
experiments
/
min_video_bitrate_experiment
.
h
"
#
include
<
cstdio
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
video
/
video_codec_type
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
const
int
kDefaultMinVideoBitrateBps
=
30000
;
namespace
{
const
char
kForcedFallbackFieldTrial
[
]
=
"
WebRTC
-
VP8
-
Forced
-
Fallback
-
Encoder
-
v2
"
;
const
char
kMinVideoBitrateExperiment
[
]
=
"
WebRTC
-
Video
-
MinVideoBitrate
"
;
std
:
:
optional
<
int
>
GetFallbackMinBpsFromFieldTrial
(
const
FieldTrialsView
&
field_trials
VideoCodecType
type
)
{
if
(
type
!
=
kVideoCodecVP8
)
{
return
std
:
:
nullopt
;
}
if
(
!
field_trials
.
IsEnabled
(
kForcedFallbackFieldTrial
)
)
{
return
std
:
:
nullopt
;
}
const
std
:
:
string
group
=
field_trials
.
Lookup
(
kForcedFallbackFieldTrial
)
;
if
(
group
.
empty
(
)
)
{
return
std
:
:
nullopt
;
}
int
min_pixels
;
int
max_pixels
;
int
min_bps
;
if
(
sscanf
(
group
.
c_str
(
)
"
Enabled
-
%
d
%
d
%
d
"
&
min_pixels
&
max_pixels
&
min_bps
)
!
=
3
)
{
return
std
:
:
nullopt
;
}
if
(
min_bps
<
=
0
)
{
return
std
:
:
nullopt
;
}
return
min_bps
;
}
}
std
:
:
optional
<
DataRate
>
GetExperimentalMinVideoBitrate
(
const
FieldTrialsView
&
field_trials
VideoCodecType
type
)
{
const
std
:
:
optional
<
int
>
fallback_min_bitrate_bps
=
GetFallbackMinBpsFromFieldTrial
(
field_trials
type
)
;
if
(
fallback_min_bitrate_bps
)
{
return
DataRate
:
:
BitsPerSec
(
*
fallback_min_bitrate_bps
)
;
}
if
(
field_trials
.
IsEnabled
(
kMinVideoBitrateExperiment
)
)
{
FieldTrialFlag
enabled
(
"
Enabled
"
)
;
FieldTrialOptional
<
DataRate
>
min_video_bitrate
(
"
br
"
)
;
FieldTrialOptional
<
DataRate
>
min_bitrate_vp8
(
"
vp8_br
"
)
;
FieldTrialOptional
<
DataRate
>
min_bitrate_vp9
(
"
vp9_br
"
)
;
FieldTrialOptional
<
DataRate
>
min_bitrate_av1
(
"
av1_br
"
)
;
FieldTrialOptional
<
DataRate
>
min_bitrate_h264
(
"
h264_br
"
)
;
ParseFieldTrial
(
{
&
enabled
&
min_video_bitrate
&
min_bitrate_vp8
&
min_bitrate_vp9
&
min_bitrate_av1
&
min_bitrate_h264
}
field_trials
.
Lookup
(
kMinVideoBitrateExperiment
)
)
;
if
(
min_video_bitrate
)
{
if
(
min_bitrate_vp8
|
|
min_bitrate_vp9
|
|
min_bitrate_av1
|
|
min_bitrate_h264
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Self
-
contradictory
experiment
config
.
"
;
}
return
*
min_video_bitrate
;
}
switch
(
type
)
{
case
kVideoCodecVP8
:
return
min_bitrate_vp8
.
GetOptional
(
)
;
case
kVideoCodecH265
:
case
kVideoCodecVP9
:
return
min_bitrate_vp9
.
GetOptional
(
)
;
case
kVideoCodecAV1
:
return
min_bitrate_av1
.
GetOptional
(
)
;
case
kVideoCodecH264
:
return
min_bitrate_h264
.
GetOptional
(
)
;
case
kVideoCodecGeneric
:
return
std
:
:
nullopt
;
}
RTC_DCHECK_NOTREACHED
(
)
;
}
return
std
:
:
nullopt
;
}
}
