#
ifndef
RTC_BASE_NETWORK_MONITOR_H_
#
define
RTC_BASE_NETWORK_MONITOR_H_
#
include
<
functional
>
#
include
<
utility
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
network_constants
.
h
"
namespace
rtc
{
class
IPAddress
;
enum
class
NetworkBindingResult
{
SUCCESS
=
0
FAILURE
=
-
1
NOT_IMPLEMENTED
=
-
2
ADDRESS_NOT_FOUND
=
-
3
NETWORK_CHANGED
=
-
4
}
;
enum
class
NetworkPreference
{
NEUTRAL
=
0
NOT_PREFERRED
=
-
1
}
;
const
char
*
NetworkPreferenceToString
(
NetworkPreference
preference
)
;
class
NetworkBinderInterface
{
public
:
virtual
NetworkBindingResult
BindSocketToNetwork
(
int
socket_fd
const
IPAddress
&
address
)
=
0
;
virtual
~
NetworkBinderInterface
(
)
{
}
}
;
class
NetworkMonitorInterface
{
public
:
NetworkMonitorInterface
(
)
;
virtual
~
NetworkMonitorInterface
(
)
;
virtual
void
Start
(
)
=
0
;
virtual
void
Stop
(
)
=
0
;
virtual
AdapterType
GetAdapterType
(
absl
:
:
string_view
interface_name
)
=
0
;
virtual
AdapterType
GetVpnUnderlyingAdapterType
(
absl
:
:
string_view
interface_name
)
=
0
;
virtual
NetworkPreference
GetNetworkPreference
(
absl
:
:
string_view
interface_name
)
=
0
;
virtual
bool
SupportsBindSocketToNetwork
(
)
const
{
return
false
;
}
virtual
NetworkBindingResult
BindSocketToNetwork
(
int
socket_fd
const
IPAddress
&
address
absl
:
:
string_view
interface_name
)
{
return
NetworkBindingResult
:
:
NOT_IMPLEMENTED
;
}
virtual
bool
IsAdapterAvailable
(
absl
:
:
string_view
interface_name
)
{
return
true
;
}
void
SetNetworksChangedCallback
(
std
:
:
function
<
void
(
)
>
callback
)
{
networks_changed_callback_
=
std
:
:
move
(
callback
)
;
}
protected
:
void
InvokeNetworksChangedCallback
(
)
{
if
(
networks_changed_callback_
)
{
networks_changed_callback_
(
)
;
}
}
private
:
std
:
:
function
<
void
(
)
>
networks_changed_callback_
;
}
;
}
#
endif
