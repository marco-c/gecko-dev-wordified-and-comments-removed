#
ifndef
RTC_BASE_MEMORY_FIFO_BUFFER_H_
#
define
RTC_BASE_MEMORY_FIFO_BUFFER_H_
#
include
<
memory
>
#
include
"
rtc_base
/
stream
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
rtc
{
class
FifoBuffer
final
:
public
StreamInterface
{
public
:
explicit
FifoBuffer
(
size_t
length
)
;
FifoBuffer
(
size_t
length
Thread
*
owner
)
;
~
FifoBuffer
(
)
override
;
bool
GetBuffered
(
size_t
*
data_len
)
const
;
bool
SetCapacity
(
size_t
length
)
;
StreamResult
ReadOffset
(
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_read
)
;
StreamResult
WriteOffset
(
const
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_written
)
;
StreamState
GetState
(
)
const
override
;
StreamResult
Read
(
void
*
buffer
size_t
bytes
size_t
*
bytes_read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
buffer
size_t
bytes
size_t
*
bytes_written
int
*
error
)
override
;
void
Close
(
)
override
;
bool
SetPosition
(
size_t
position
)
;
bool
GetPosition
(
size_t
*
position
)
const
;
bool
Rewind
(
)
{
return
SetPosition
(
0
)
;
}
const
void
*
GetReadData
(
size_t
*
data_len
)
;
void
ConsumeReadData
(
size_t
used
)
;
void
*
GetWriteBuffer
(
size_t
*
buf_len
)
;
void
ConsumeWriteBuffer
(
size_t
used
)
;
bool
GetWriteRemaining
(
size_t
*
size
)
const
;
private
:
StreamResult
ReadOffsetLocked
(
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_read
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
StreamResult
WriteOffsetLocked
(
const
void
*
buffer
size_t
bytes
size_t
offset
size_t
*
bytes_written
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
StreamState
state_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
unique_ptr
<
char
[
]
>
buffer_
RTC_GUARDED_BY
(
mutex_
)
;
size_t
buffer_length_
RTC_GUARDED_BY
(
mutex_
)
;
size_t
data_length_
RTC_GUARDED_BY
(
mutex_
)
;
size_t
read_position_
RTC_GUARDED_BY
(
mutex_
)
;
Thread
*
owner_
;
mutable
webrtc
:
:
Mutex
mutex_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
FifoBuffer
)
;
}
;
}
#
endif
