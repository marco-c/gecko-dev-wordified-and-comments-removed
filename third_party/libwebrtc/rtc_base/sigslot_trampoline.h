#
ifndef
RTC_BASE_SIGSLOT_TRAMPOLINE_H_
#
define
RTC_BASE_SIGSLOT_TRAMPOLINE_H_
#
include
<
utility
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
rtc_base
/
callback_list
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
namespace
webrtc
{
namespace
internal
{
template
<
typename
MemberPtrT
>
struct
member_pointer_traits
;
template
<
typename
ClassT
typename
MemberT
>
struct
member_pointer_traits
<
MemberT
ClassT
:
:
*
>
{
using
member_type
=
MemberT
;
}
;
template
<
typename
SignalT
>
class
SignalTrampolineBase
;
template
<
typename
.
.
.
Args
>
class
SignalTrampolineBase
<
sigslot
:
:
signal
<
Args
.
.
.
>
>
:
public
sigslot
:
:
has_slots
<
>
{
public
:
void
Subscribe
(
absl
:
:
AnyInvocable
<
void
(
Args
.
.
.
)
>
callback
)
{
callbacks_
.
AddReceiver
(
std
:
:
move
(
callback
)
)
;
}
void
Subscribe
(
const
void
*
tag
absl
:
:
AnyInvocable
<
void
(
Args
.
.
.
)
>
callback
)
{
callbacks_
.
AddReceiver
(
tag
std
:
:
move
(
callback
)
)
;
}
void
Unsubscribe
(
const
void
*
tag
)
{
callbacks_
.
RemoveReceivers
(
tag
)
;
}
void
Notify
(
Args
.
.
.
args
)
{
callbacks_
.
Send
(
args
.
.
.
)
;
}
private
:
CallbackList
<
Args
.
.
.
>
callbacks_
;
}
;
template
<
typename
T
auto
member_signal
>
using
SignalTrampolineMemberBase
=
SignalTrampolineBase
<
typename
internal
:
:
member_pointer_traits
<
decltype
(
member_signal
)
>
:
:
member_type
>
;
}
template
<
class
T
auto
member_signal
>
class
SignalTrampoline
:
public
internal
:
:
SignalTrampolineMemberBase
<
T
member_signal
>
{
private
:
using
Base
=
internal
:
:
SignalTrampolineMemberBase
<
T
member_signal
>
;
public
:
explicit
SignalTrampoline
(
T
*
that
)
{
(
that
-
>
*
member_signal
)
.
connect
(
static_cast
<
Base
*
>
(
this
)
&
Base
:
:
Notify
)
;
}
}
;
}
#
endif
