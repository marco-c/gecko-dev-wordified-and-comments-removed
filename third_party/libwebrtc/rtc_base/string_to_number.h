#
ifndef
RTC_BASE_STRING_TO_NUMBER_H_
#
define
RTC_BASE_STRING_TO_NUMBER_H_
#
include
<
limits
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
webrtc
{
namespace
string_to_number_internal
{
using
unsigned_type
=
unsigned
long
long
;
using
signed_type
=
long
long
;
std
:
:
optional
<
signed_type
>
ParseSigned
(
absl
:
:
string_view
str
int
base
)
;
std
:
:
optional
<
unsigned_type
>
ParseUnsigned
(
absl
:
:
string_view
str
int
base
)
;
template
<
typename
T
>
std
:
:
optional
<
T
>
ParseFloatingPoint
(
absl
:
:
string_view
str
)
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_signed
<
T
>
:
:
value
std
:
:
optional
<
T
>
>
:
:
type
StringToNumber
(
absl
:
:
string_view
str
int
base
=
10
)
{
using
string_to_number_internal
:
:
signed_type
;
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
<
=
std
:
:
numeric_limits
<
signed_type
>
:
:
max
(
)
&
&
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
>
=
std
:
:
numeric_limits
<
signed_type
>
:
:
lowest
(
)
"
StringToNumber
only
supports
signed
integers
as
large
as
long
long
int
"
)
;
std
:
:
optional
<
signed_type
>
value
=
string_to_number_internal
:
:
ParseSigned
(
str
base
)
;
if
(
value
&
&
*
value
>
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
&
&
*
value
<
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
{
return
static_cast
<
T
>
(
*
value
)
;
}
return
std
:
:
nullopt
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_unsigned
<
T
>
:
:
value
std
:
:
optional
<
T
>
>
:
:
type
StringToNumber
(
absl
:
:
string_view
str
int
base
=
10
)
{
using
string_to_number_internal
:
:
unsigned_type
;
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
<
=
std
:
:
numeric_limits
<
unsigned_type
>
:
:
max
(
)
"
StringToNumber
only
supports
unsigned
integers
as
large
as
"
"
unsigned
long
long
int
"
)
;
std
:
:
optional
<
unsigned_type
>
value
=
string_to_number_internal
:
:
ParseUnsigned
(
str
base
)
;
if
(
value
&
&
*
value
<
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
{
return
static_cast
<
T
>
(
*
value
)
;
}
return
std
:
:
nullopt
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
std
:
:
optional
<
T
>
>
:
:
type
StringToNumber
(
absl
:
:
string_view
str
int
=
10
)
{
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
<
=
std
:
:
numeric_limits
<
long
double
>
:
:
max
(
)
"
StringToNumber
only
supports
floating
-
point
numbers
as
large
"
"
as
long
double
"
)
;
return
string_to_number_internal
:
:
ParseFloatingPoint
<
T
>
(
str
)
;
}
}
namespace
rtc
{
using
:
:
webrtc
:
:
StringToNumber
;
}
#
endif
