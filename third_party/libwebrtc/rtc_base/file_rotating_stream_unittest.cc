#
include
"
rtc_base
/
file_rotating_stream
.
h
"
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
system
/
file_wrapper
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
testsupport
/
file_utils
.
h
"
namespace
webrtc
{
namespace
{
void
CleanupLogDirectory
(
const
FileRotatingStream
&
stream
)
{
for
(
size_t
i
=
0
;
i
<
stream
.
GetNumFiles
(
)
;
+
+
i
)
{
webrtc
:
:
test
:
:
RemoveFile
(
stream
.
GetFilePath
(
i
)
)
;
}
}
}
#
if
defined
(
WEBRTC_ANDROID
)
#
define
MAYBE_FileRotatingStreamTest
DISABLED_FileRotatingStreamTest
#
else
#
define
MAYBE_FileRotatingStreamTest
FileRotatingStreamTest
#
endif
class
MAYBE_FileRotatingStreamTest
:
public
:
:
testing
:
:
Test
{
protected
:
static
const
char
*
kFilePrefix
;
static
const
size_t
kMaxFileSize
;
void
Init
(
absl
:
:
string_view
dir_name
absl
:
:
string_view
file_prefix
size_t
max_file_size
size_t
num_log_files
bool
ensure_trailing_delimiter
=
true
)
{
dir_path_
=
webrtc
:
:
test
:
:
OutputPath
(
)
;
dir_path_
.
append
(
dir_name
.
begin
(
)
dir_name
.
end
(
)
)
;
if
(
ensure_trailing_delimiter
)
{
dir_path_
.
append
(
std
:
:
string
(
webrtc
:
:
test
:
:
kPathDelimiter
)
)
;
}
ASSERT_TRUE
(
webrtc
:
:
test
:
:
CreateDir
(
dir_path_
)
)
;
stream_
.
reset
(
new
FileRotatingStream
(
dir_path_
file_prefix
max_file_size
num_log_files
)
)
;
}
void
TearDown
(
)
override
{
stream_
-
>
Close
(
)
;
CleanupLogDirectory
(
*
stream_
)
;
EXPECT_TRUE
(
webrtc
:
:
test
:
:
RemoveDir
(
dir_path_
)
)
;
stream_
.
reset
(
)
;
}
void
WriteAndFlush
(
const
void
*
data
const
size_t
data_len
)
{
EXPECT_TRUE
(
stream_
-
>
Write
(
data
data_len
)
)
;
EXPECT_TRUE
(
stream_
-
>
Flush
(
)
)
;
}
void
VerifyStreamRead
(
absl
:
:
string_view
expected_contents
absl
:
:
string_view
dir_path
absl
:
:
string_view
file_prefix
)
{
size_t
expected_length
=
expected_contents
.
size
(
)
;
FileRotatingStreamReader
reader
(
dir_path
file_prefix
)
;
EXPECT_EQ
(
reader
.
GetSize
(
)
expected_length
)
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
buffer
(
new
uint8_t
[
expected_length
]
)
;
memset
(
buffer
.
get
(
)
0
expected_length
)
;
EXPECT_EQ
(
expected_length
reader
.
ReadAll
(
buffer
.
get
(
)
expected_length
)
)
;
EXPECT_EQ
(
0
memcmp
(
expected_contents
.
data
(
)
buffer
.
get
(
)
expected_length
)
)
;
}
void
VerifyFileContents
(
absl
:
:
string_view
expected_contents
absl
:
:
string_view
file_path
)
{
size_t
expected_length
=
expected_contents
.
size
(
)
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
buffer
(
new
uint8_t
[
expected_length
+
1
]
)
;
FileWrapper
f
=
FileWrapper
:
:
OpenReadOnly
(
file_path
)
;
ASSERT_TRUE
(
f
.
is_open
(
)
)
;
size_t
size_read
=
f
.
Read
(
buffer
.
get
(
)
expected_length
+
1
)
;
EXPECT_EQ
(
size_read
expected_length
)
;
EXPECT_EQ
(
0
memcmp
(
expected_contents
.
data
(
)
buffer
.
get
(
)
std
:
:
min
(
expected_length
size_read
)
)
)
;
}
std
:
:
unique_ptr
<
FileRotatingStream
>
stream_
;
std
:
:
string
dir_path_
;
}
;
const
char
*
MAYBE_FileRotatingStreamTest
:
:
kFilePrefix
=
"
FileRotatingStreamTest
"
;
const
size_t
MAYBE_FileRotatingStreamTest
:
:
kMaxFileSize
=
2
;
TEST_F
(
MAYBE_FileRotatingStreamTest
State
)
{
Init
(
"
FileRotatingStreamTestState
"
kFilePrefix
kMaxFileSize
3
)
;
EXPECT_FALSE
(
stream_
-
>
IsOpen
(
)
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
EXPECT_TRUE
(
stream_
-
>
IsOpen
(
)
)
;
stream_
-
>
Close
(
)
;
EXPECT_FALSE
(
stream_
-
>
IsOpen
(
)
)
;
}
TEST_F
(
MAYBE_FileRotatingStreamTest
EmptyWrite
)
{
Init
(
"
FileRotatingStreamTestEmptyWrite
"
kFilePrefix
kMaxFileSize
3
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
WriteAndFlush
(
"
a
"
0
)
;
std
:
:
string
logfile_path
=
stream_
-
>
GetFilePath
(
0
)
;
FileWrapper
f
=
FileWrapper
:
:
OpenReadOnly
(
logfile_path
)
;
ASSERT_TRUE
(
f
.
is_open
(
)
)
;
char
buf
[
1
]
;
EXPECT_EQ
(
0u
f
.
Read
(
buf
sizeof
(
buf
)
)
)
;
}
TEST_F
(
MAYBE_FileRotatingStreamTest
WriteAndRead
)
{
Init
(
"
FileRotatingStreamTestWriteAndRead
"
kFilePrefix
kMaxFileSize
3
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
std
:
:
string
messages
[
3
]
=
{
"
aa
"
"
bb
"
"
cc
"
}
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
messages
)
;
+
+
i
)
{
const
std
:
:
string
&
message
=
messages
[
i
]
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
VerifyFileContents
(
message
stream_
-
>
GetFilePath
(
1
)
)
;
}
for
(
size_t
i
=
0
;
i
<
arraysize
(
messages
)
;
+
+
i
)
{
EXPECT_TRUE
(
webrtc
:
:
test
:
:
FileExists
(
stream_
-
>
GetFilePath
(
i
)
)
)
;
}
std
:
:
string
message
(
"
d
"
)
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
messages
)
;
+
+
i
)
{
EXPECT_TRUE
(
webrtc
:
:
test
:
:
FileExists
(
stream_
-
>
GetFilePath
(
i
)
)
)
;
}
std
:
:
string
expected_contents
(
"
bbccd
"
)
;
VerifyStreamRead
(
expected_contents
dir_path_
kFilePrefix
)
;
}
TEST_F
(
MAYBE_FileRotatingStreamTest
WriteWithoutDelimiterAndRead
)
{
Init
(
"
FileRotatingStreamTestWriteWithoutDelimiterAndRead
"
kFilePrefix
kMaxFileSize
3
false
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
std
:
:
string
messages
[
3
]
=
{
"
aa
"
"
bb
"
"
cc
"
}
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
messages
)
;
+
+
i
)
{
const
std
:
:
string
&
message
=
messages
[
i
]
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
}
std
:
:
string
message
(
"
d
"
)
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
std
:
:
string
expected_contents
(
"
bbccd
"
)
;
VerifyStreamRead
(
expected_contents
dir_path_
+
std
:
:
string
(
webrtc
:
:
test
:
:
kPathDelimiter
)
kFilePrefix
)
;
}
TEST_F
(
MAYBE_FileRotatingStreamTest
WriteAndReadWithoutDelimiter
)
{
Init
(
"
FileRotatingStreamTestWriteAndReadWithoutDelimiter
"
kFilePrefix
kMaxFileSize
3
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
std
:
:
string
messages
[
3
]
=
{
"
aa
"
"
bb
"
"
cc
"
}
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
messages
)
;
+
+
i
)
{
const
std
:
:
string
&
message
=
messages
[
i
]
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
}
std
:
:
string
message
(
"
d
"
)
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
std
:
:
string
expected_contents
(
"
bbccd
"
)
;
VerifyStreamRead
(
expected_contents
dir_path_
.
substr
(
0
dir_path_
.
size
(
)
-
1
)
kFilePrefix
)
;
}
TEST_F
(
MAYBE_FileRotatingStreamTest
WriteOverflowAndRead
)
{
Init
(
"
FileRotatingStreamTestWriteOverflowAndRead
"
kFilePrefix
kMaxFileSize
3
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
std
:
:
string
message
(
"
foobarbaz
"
)
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
std
:
:
string
expected_file_contents
(
"
z
"
)
;
VerifyFileContents
(
expected_file_contents
stream_
-
>
GetFilePath
(
0
)
)
;
std
:
:
string
expected_stream_contents
(
"
arbaz
"
)
;
VerifyStreamRead
(
expected_stream_contents
dir_path_
kFilePrefix
)
;
}
TEST_F
(
MAYBE_FileRotatingStreamTest
GetFilePath
)
{
Init
(
"
FileRotatingStreamTestGetFilePath
"
kFilePrefix
kMaxFileSize
20
)
;
const
std
:
:
string
prefix
=
dir_path_
+
kFilePrefix
;
for
(
auto
i
=
0
;
i
<
20
;
+
+
i
)
{
EXPECT_EQ
(
0
stream_
-
>
GetFilePath
(
i
)
.
compare
(
0
prefix
.
size
(
)
prefix
)
)
;
}
}
#
if
defined
(
WEBRTC_ANDROID
)
#
define
MAYBE_CallSessionFileRotatingStreamTest
\
DISABLED_CallSessionFileRotatingStreamTest
#
else
#
define
MAYBE_CallSessionFileRotatingStreamTest
\
CallSessionFileRotatingStreamTest
#
endif
class
MAYBE_CallSessionFileRotatingStreamTest
:
public
:
:
testing
:
:
Test
{
protected
:
void
Init
(
absl
:
:
string_view
dir_name
size_t
max_total_log_size
)
{
dir_path_
=
webrtc
:
:
test
:
:
OutputPath
(
)
;
dir_path_
.
append
(
dir_name
.
begin
(
)
dir_name
.
end
(
)
)
;
dir_path_
.
append
(
std
:
:
string
(
webrtc
:
:
test
:
:
kPathDelimiter
)
)
;
ASSERT_TRUE
(
webrtc
:
:
test
:
:
CreateDir
(
dir_path_
)
)
;
stream_
.
reset
(
new
CallSessionFileRotatingStream
(
dir_path_
max_total_log_size
)
)
;
}
void
TearDown
(
)
override
{
stream_
-
>
Close
(
)
;
CleanupLogDirectory
(
*
stream_
)
;
EXPECT_TRUE
(
webrtc
:
:
test
:
:
RemoveDir
(
dir_path_
)
)
;
stream_
.
reset
(
)
;
}
void
WriteAndFlush
(
const
void
*
data
const
size_t
data_len
)
{
EXPECT_TRUE
(
stream_
-
>
Write
(
data
data_len
)
)
;
EXPECT_TRUE
(
stream_
-
>
Flush
(
)
)
;
}
void
VerifyStreamRead
(
absl
:
:
string_view
expected_contents
absl
:
:
string_view
dir_path
)
{
size_t
expected_length
=
expected_contents
.
size
(
)
;
CallSessionFileRotatingStreamReader
reader
(
dir_path
)
;
EXPECT_EQ
(
reader
.
GetSize
(
)
expected_length
)
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
buffer
(
new
uint8_t
[
expected_length
]
)
;
memset
(
buffer
.
get
(
)
0
expected_length
)
;
EXPECT_EQ
(
expected_length
reader
.
ReadAll
(
buffer
.
get
(
)
expected_length
)
)
;
EXPECT_EQ
(
0
memcmp
(
expected_contents
.
data
(
)
buffer
.
get
(
)
expected_length
)
)
;
}
std
:
:
unique_ptr
<
CallSessionFileRotatingStream
>
stream_
;
std
:
:
string
dir_path_
;
}
;
TEST_F
(
MAYBE_CallSessionFileRotatingStreamTest
WriteAndReadSmallest
)
{
Init
(
"
CallSessionFileRotatingStreamTestWriteAndReadSmallest
"
4
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
std
:
:
string
message
(
"
abcde
"
)
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
std
:
:
string
expected_contents
(
"
abe
"
)
;
VerifyStreamRead
(
expected_contents
dir_path_
)
;
}
TEST_F
(
MAYBE_CallSessionFileRotatingStreamTest
WriteAndReadSmall
)
{
Init
(
"
CallSessionFileRotatingStreamTestWriteAndReadSmall
"
8
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
std
:
:
string
message
(
"
123456789
"
)
;
WriteAndFlush
(
message
.
c_str
(
)
message
.
size
(
)
)
;
std
:
:
string
expected_contents
(
"
1234789
"
)
;
VerifyStreamRead
(
expected_contents
dir_path_
)
;
}
TEST_F
(
MAYBE_CallSessionFileRotatingStreamTest
WriteAndReadLarge
)
{
Init
(
"
CallSessionFileRotatingStreamTestWriteAndReadLarge
"
6
*
1024
*
1024
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
const
size_t
buffer_size
=
1024
*
1024
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
buffer
(
new
uint8_t
[
buffer_size
]
)
;
for
(
int
i
=
0
;
i
<
8
;
i
+
+
)
{
memset
(
buffer
.
get
(
)
i
buffer_size
)
;
EXPECT_TRUE
(
stream_
-
>
Write
(
buffer
.
get
(
)
buffer_size
)
)
;
}
const
int
expected_vals
[
]
=
{
0
1
2
6
7
}
;
const
size_t
expected_size
=
buffer_size
*
arraysize
(
expected_vals
)
;
CallSessionFileRotatingStreamReader
reader
(
dir_path_
)
;
EXPECT_EQ
(
reader
.
GetSize
(
)
expected_size
)
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
contents
(
new
uint8_t
[
expected_size
+
1
]
)
;
EXPECT_EQ
(
reader
.
ReadAll
(
contents
.
get
(
)
expected_size
+
1
)
expected_size
)
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
expected_vals
)
;
+
+
i
)
{
const
uint8_t
*
block
=
contents
.
get
(
)
+
i
*
buffer_size
;
bool
match
=
true
;
for
(
size_t
j
=
0
;
j
<
buffer_size
;
j
+
+
)
{
if
(
block
[
j
]
!
=
expected_vals
[
i
]
)
{
match
=
false
;
break
;
}
}
EXPECT_TRUE
(
match
)
;
}
}
TEST_F
(
MAYBE_CallSessionFileRotatingStreamTest
WriteAndReadFirstHalf
)
{
Init
(
"
CallSessionFileRotatingStreamTestWriteAndReadFirstHalf
"
6
*
1024
*
1024
)
;
ASSERT_TRUE
(
stream_
-
>
Open
(
)
)
;
const
size_t
buffer_size
=
1024
*
1024
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
buffer
(
new
uint8_t
[
buffer_size
]
)
;
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
{
memset
(
buffer
.
get
(
)
i
buffer_size
)
;
EXPECT_TRUE
(
stream_
-
>
Write
(
buffer
.
get
(
)
buffer_size
)
)
;
}
const
int
expected_vals
[
]
=
{
0
1
}
;
const
size_t
expected_size
=
buffer_size
*
arraysize
(
expected_vals
)
;
CallSessionFileRotatingStreamReader
reader
(
dir_path_
)
;
EXPECT_EQ
(
reader
.
GetSize
(
)
expected_size
)
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
contents
(
new
uint8_t
[
expected_size
+
1
]
)
;
EXPECT_EQ
(
reader
.
ReadAll
(
contents
.
get
(
)
expected_size
+
1
)
expected_size
)
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
expected_vals
)
;
+
+
i
)
{
const
uint8_t
*
block
=
contents
.
get
(
)
+
i
*
buffer_size
;
bool
match
=
true
;
for
(
size_t
j
=
0
;
j
<
buffer_size
;
j
+
+
)
{
if
(
block
[
j
]
!
=
expected_vals
[
i
]
)
{
match
=
false
;
break
;
}
}
EXPECT_TRUE
(
match
)
;
}
}
}
