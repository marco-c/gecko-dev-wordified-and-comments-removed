#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1300
#
pragma
warning
(
disable
:
4786
)
#
endif
#
include
"
rtc_base
/
socket_adapters
.
h
"
#
include
<
algorithm
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
rtc_base
/
zero_memory
.
h
"
namespace
webrtc
{
BufferedReadAdapter
:
:
BufferedReadAdapter
(
Socket
*
socket
size_t
size
)
:
AsyncSocketAdapter
(
socket
)
buffer_size_
(
size
)
data_len_
(
0
)
buffering_
(
false
)
{
buffer_
=
new
char
[
buffer_size_
]
;
}
BufferedReadAdapter
:
:
~
BufferedReadAdapter
(
)
{
delete
[
]
buffer_
;
}
int
BufferedReadAdapter
:
:
Send
(
const
void
*
pv
size_t
cb
)
{
if
(
buffering_
)
{
SetError
(
EWOULDBLOCK
)
;
return
-
1
;
}
return
AsyncSocketAdapter
:
:
Send
(
pv
cb
)
;
}
int
BufferedReadAdapter
:
:
Recv
(
void
*
pv
size_t
cb
int64_t
*
timestamp
)
{
if
(
buffering_
)
{
SetError
(
EWOULDBLOCK
)
;
return
-
1
;
}
size_t
read
=
0
;
if
(
data_len_
)
{
read
=
std
:
:
min
(
cb
data_len_
)
;
memcpy
(
pv
buffer_
read
)
;
data_len_
-
=
read
;
if
(
data_len_
>
0
)
{
memmove
(
buffer_
buffer_
+
read
data_len_
)
;
}
pv
=
static_cast
<
char
*
>
(
pv
)
+
read
;
cb
-
=
read
;
}
int
res
=
AsyncSocketAdapter
:
:
Recv
(
pv
cb
timestamp
)
;
if
(
res
>
=
0
)
{
return
res
+
static_cast
<
int
>
(
read
)
;
}
if
(
read
>
0
)
{
return
static_cast
<
int
>
(
read
)
;
}
return
res
;
}
void
BufferedReadAdapter
:
:
BufferInput
(
bool
on
)
{
buffering_
=
on
;
}
void
BufferedReadAdapter
:
:
OnReadEvent
(
Socket
*
socket
)
{
RTC_DCHECK
(
socket
=
=
GetSocket
(
)
)
;
if
(
!
buffering_
)
{
AsyncSocketAdapter
:
:
OnReadEvent
(
socket
)
;
return
;
}
if
(
data_len_
>
=
buffer_size_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Input
buffer
overflow
"
;
RTC_DCHECK_NOTREACHED
(
)
;
data_len_
=
0
;
}
int
len
=
AsyncSocketAdapter
:
:
Recv
(
buffer_
+
data_len_
buffer_size_
-
data_len_
nullptr
)
;
if
(
len
<
0
)
{
RTC_LOG_ERR
(
LS_INFO
)
<
<
"
Recv
"
;
return
;
}
data_len_
+
=
len
;
ProcessInput
(
buffer_
&
data_len_
)
;
}
static
const
uint8_t
kSslClientHello
[
]
=
{
0x80
0x46
0x01
0x03
0x01
0x00
0x2d
0x00
0x00
0x00
0x10
0x01
0x00
0x80
0x03
0x00
0x80
0x07
0x00
0xc0
0x06
0x00
0x40
0x02
0x00
0x80
0x04
0x00
0x80
0x00
0x00
0x04
0x00
0xfe
0xff
0x00
0x00
0x0a
0x00
0xfe
0xfe
0x00
0x00
0x09
0x00
0x00
0x64
0x00
0x00
0x62
0x00
0x00
0x03
0x00
0x00
0x06
0x1f
0x17
0x0c
0xa6
0x2f
0x00
0x78
0xfc
0x46
0x55
0x2e
0xb1
0x83
0x39
0xf1
0xea
}
;
ArrayView
<
const
uint8_t
>
AsyncSSLSocket
:
:
SslClientHello
(
)
{
return
{
kSslClientHello
sizeof
(
kSslClientHello
)
}
;
}
static
const
uint8_t
kSslServerHello
[
]
=
{
0x16
0x03
0x01
0x00
0x4a
0x02
0x00
0x00
0x46
0x03
0x01
0x42
0x85
0x45
0xa7
0x27
0xa9
0x5d
0xa0
0xb3
0xc5
0xe7
0x53
0xda
0x48
0x2b
0x3f
0xc6
0x5a
0xca
0x89
0xc1
0x58
0x52
0xa1
0x78
0x3c
0x5b
0x17
0x46
0x00
0x85
0x3f
0x20
0x0e
0xd3
0x06
0x72
0x5b
0x5b
0x1b
0x5f
0x15
0xac
0x13
0xf9
0x88
0x53
0x9d
0x9b
0xe8
0x3d
0x7b
0x0c
0x30
0x32
0x6e
0x38
0x4d
0xa2
0x75
0x57
0x41
0x6c
0x34
0x5c
0x00
0x04
0x00
}
;
ArrayView
<
const
uint8_t
>
AsyncSSLSocket
:
:
SslServerHello
(
)
{
return
{
kSslServerHello
sizeof
(
kSslServerHello
)
}
;
}
AsyncSSLSocket
:
:
AsyncSSLSocket
(
Socket
*
socket
)
:
BufferedReadAdapter
(
socket
1024
)
{
}
int
AsyncSSLSocket
:
:
Connect
(
const
SocketAddress
&
addr
)
{
BufferInput
(
true
)
;
return
BufferedReadAdapter
:
:
Connect
(
addr
)
;
}
void
AsyncSSLSocket
:
:
OnConnectEvent
(
Socket
*
socket
)
{
RTC_DCHECK
(
socket
=
=
GetSocket
(
)
)
;
const
int
res
=
DirectSend
(
kSslClientHello
sizeof
(
kSslClientHello
)
)
;
if
(
res
!
=
sizeof
(
kSslClientHello
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Sending
fake
SSL
ClientHello
message
failed
.
"
;
Close
(
)
;
SignalCloseEvent
(
this
0
)
;
}
}
void
AsyncSSLSocket
:
:
ProcessInput
(
char
*
data
size_t
*
len
)
{
if
(
*
len
<
sizeof
(
kSslServerHello
)
)
return
;
if
(
memcmp
(
kSslServerHello
data
sizeof
(
kSslServerHello
)
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Received
non
-
matching
fake
SSL
ServerHello
message
.
"
;
Close
(
)
;
SignalCloseEvent
(
this
0
)
;
return
;
}
*
len
-
=
sizeof
(
kSslServerHello
)
;
if
(
*
len
>
0
)
{
memmove
(
data
data
+
sizeof
(
kSslServerHello
)
*
len
)
;
}
bool
remainder
=
(
*
len
>
0
)
;
BufferInput
(
false
)
;
SignalConnectEvent
(
this
)
;
if
(
remainder
)
SignalReadEvent
(
this
)
;
}
}
