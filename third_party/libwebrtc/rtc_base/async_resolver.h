#
ifndef
RTC_BASE_ASYNC_RESOLVER_H_
#
define
RTC_BASE_ASYNC_RESOLVER_H_
#
if
defined
(
WEBRTC_POSIX
)
#
include
<
sys
/
socket
.
h
>
#
elif
WEBRTC_WIN
#
include
<
winsock2
.
h
>
#
endif
#
include
<
vector
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
rtc_base
/
async_resolver_interface
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
rtc
{
class
RTC_EXPORT
AsyncResolver
:
public
AsyncResolverInterface
{
public
:
AsyncResolver
(
)
;
~
AsyncResolver
(
)
override
;
void
Start
(
const
SocketAddress
&
addr
)
override
;
bool
GetResolvedAddress
(
int
family
SocketAddress
*
addr
)
const
override
;
int
GetError
(
)
const
override
;
void
Destroy
(
bool
wait
)
override
;
const
std
:
:
vector
<
IPAddress
>
&
addresses
(
)
const
;
private
:
struct
State
;
void
ResolveDone
(
std
:
:
vector
<
IPAddress
>
addresses
int
error
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
sequence_checker_
)
;
void
MaybeSelfDestruct
(
)
;
SocketAddress
addr_
RTC_GUARDED_BY
(
sequence_checker_
)
;
std
:
:
vector
<
IPAddress
>
addresses_
RTC_GUARDED_BY
(
sequence_checker_
)
;
int
error_
RTC_GUARDED_BY
(
sequence_checker_
)
;
bool
recursion_check_
=
false
;
bool
destroy_called_
=
false
;
scoped_refptr
<
State
>
state_
;
RTC_NO_UNIQUE_ADDRESS
webrtc
:
:
SequenceChecker
sequence_checker_
;
}
;
}
#
endif
