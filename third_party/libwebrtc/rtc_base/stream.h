#
ifndef
RTC_BASE_STREAM_H_
#
define
RTC_BASE_STREAM_H_
#
include
<
memory
>
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
message_handler
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
rtc
{
enum
StreamState
{
SS_CLOSED
SS_OPENING
SS_OPEN
}
;
enum
StreamResult
{
SR_ERROR
SR_SUCCESS
SR_BLOCK
SR_EOS
}
;
enum
StreamEvent
{
SE_OPEN
=
1
SE_READ
=
2
SE_WRITE
=
4
SE_CLOSE
=
8
}
;
class
RTC_EXPORT
StreamInterface
{
public
:
virtual
~
StreamInterface
(
)
{
}
virtual
StreamState
GetState
(
)
const
=
0
;
virtual
StreamResult
Read
(
void
*
buffer
size_t
buffer_len
size_t
*
read
int
*
error
)
=
0
;
virtual
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
=
0
;
virtual
void
Close
(
)
=
0
;
sigslot
:
:
signal3
<
StreamInterface
*
int
int
>
SignalEvent
;
virtual
bool
Flush
(
)
;
StreamResult
WriteAll
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
;
protected
:
StreamInterface
(
)
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
StreamInterface
)
;
}
;
}
#
endif
