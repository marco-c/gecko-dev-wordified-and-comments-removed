#
ifndef
RTC_BASE_STREAM_H_
#
define
RTC_BASE_STREAM_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
enum
StreamState
{
SS_CLOSED
SS_OPENING
SS_OPEN
}
;
enum
StreamResult
{
SR_ERROR
SR_SUCCESS
SR_BLOCK
SR_EOS
}
;
enum
StreamEvent
{
SE_OPEN
=
1
SE_READ
=
2
SE_WRITE
=
4
SE_CLOSE
=
8
}
;
class
RTC_EXPORT
StreamInterface
{
public
:
virtual
~
StreamInterface
(
)
{
}
StreamInterface
(
const
StreamInterface
&
)
=
delete
;
StreamInterface
&
operator
=
(
const
StreamInterface
&
)
=
delete
;
virtual
StreamState
GetState
(
)
const
=
0
;
virtual
StreamResult
Read
(
ArrayView
<
uint8_t
>
buffer
size_t
&
read
int
&
error
)
=
0
;
virtual
StreamResult
Write
(
ArrayView
<
const
uint8_t
>
data
size_t
&
written
int
&
error
)
=
0
;
virtual
void
Close
(
)
=
0
;
void
SetEventCallback
(
absl
:
:
AnyInvocable
<
void
(
int
int
)
>
callback
)
{
RTC_DCHECK_RUN_ON
(
&
callback_sequence_
)
;
RTC_DCHECK
(
!
callback_
|
|
!
callback
)
;
callback_
=
std
:
:
move
(
callback
)
;
}
virtual
bool
Flush
(
)
;
StreamResult
WriteAll
(
ArrayView
<
const
uint8_t
>
data
size_t
&
written
int
&
error
)
;
protected
:
StreamInterface
(
)
;
void
FireEvent
(
int
stream_events
int
err
)
RTC_RUN_ON
(
&
callback_sequence_
)
{
if
(
callback_
)
{
callback_
(
stream_events
err
)
;
}
}
RTC_NO_UNIQUE_ADDRESS
SequenceChecker
callback_sequence_
{
SequenceChecker
:
:
kDetached
}
;
private
:
absl
:
:
AnyInvocable
<
void
(
int
int
)
>
callback_
RTC_GUARDED_BY
(
&
callback_sequence_
)
=
nullptr
;
}
;
}
#
endif
