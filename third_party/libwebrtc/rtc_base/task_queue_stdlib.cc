#
include
"
rtc_base
/
task_queue_stdlib
.
h
"
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
utility
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
task_queue
/
queued_task
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
{
rtc
:
:
ThreadPriority
TaskQueuePriorityToThreadPriority
(
TaskQueueFactory
:
:
Priority
priority
)
{
switch
(
priority
)
{
case
TaskQueueFactory
:
:
Priority
:
:
HIGH
:
return
rtc
:
:
ThreadPriority
:
:
kRealtime
;
case
TaskQueueFactory
:
:
Priority
:
:
LOW
:
return
rtc
:
:
ThreadPriority
:
:
kLow
;
case
TaskQueueFactory
:
:
Priority
:
:
NORMAL
:
return
rtc
:
:
ThreadPriority
:
:
kNormal
;
}
}
class
TaskQueueStdlib
final
:
public
TaskQueueBase
{
public
:
TaskQueueStdlib
(
absl
:
:
string_view
queue_name
rtc
:
:
ThreadPriority
priority
)
;
~
TaskQueueStdlib
(
)
override
=
default
;
void
Delete
(
)
override
;
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
override
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
override
;
private
:
using
OrderId
=
uint64_t
;
struct
DelayedEntryTimeout
{
int64_t
next_fire_at_ms_
{
}
;
OrderId
order_
{
}
;
bool
operator
<
(
const
DelayedEntryTimeout
&
o
)
const
{
return
std
:
:
tie
(
next_fire_at_ms_
order_
)
<
std
:
:
tie
(
o
.
next_fire_at_ms_
o
.
order_
)
;
}
}
;
struct
NextTask
{
bool
final_task_
=
false
;
std
:
:
unique_ptr
<
QueuedTask
>
run_task_
;
int64_t
sleep_time_ms_
=
0
;
}
;
static
rtc
:
:
PlatformThread
InitializeThread
(
TaskQueueStdlib
*
me
absl
:
:
string_view
queue_name
rtc
:
:
ThreadPriority
priority
)
;
NextTask
GetNextTask
(
)
;
void
ProcessTasks
(
)
;
void
NotifyWake
(
)
;
rtc
:
:
Event
flag_notify_
;
Mutex
pending_lock_
;
bool
thread_should_quit_
RTC_GUARDED_BY
(
pending_lock_
)
=
false
;
OrderId
thread_posting_order_
RTC_GUARDED_BY
(
pending_lock_
)
=
0
;
std
:
:
queue
<
std
:
:
pair
<
OrderId
std
:
:
unique_ptr
<
QueuedTask
>
>
>
pending_queue_
RTC_GUARDED_BY
(
pending_lock_
)
;
std
:
:
map
<
DelayedEntryTimeout
std
:
:
unique_ptr
<
QueuedTask
>
>
delayed_queue_
RTC_GUARDED_BY
(
pending_lock_
)
;
rtc
:
:
PlatformThread
thread_
;
}
;
TaskQueueStdlib
:
:
TaskQueueStdlib
(
absl
:
:
string_view
queue_name
rtc
:
:
ThreadPriority
priority
)
:
flag_notify_
(
false
false
)
thread_
(
InitializeThread
(
this
queue_name
priority
)
)
{
}
rtc
:
:
PlatformThread
TaskQueueStdlib
:
:
InitializeThread
(
TaskQueueStdlib
*
me
absl
:
:
string_view
queue_name
rtc
:
:
ThreadPriority
priority
)
{
rtc
:
:
Event
started
;
auto
thread
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
&
started
me
]
{
CurrentTaskQueueSetter
set_current
(
me
)
;
started
.
Set
(
)
;
me
-
>
ProcessTasks
(
)
;
}
queue_name
rtc
:
:
ThreadAttributes
(
)
.
SetPriority
(
priority
)
)
;
started
.
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
return
thread
;
}
void
TaskQueueStdlib
:
:
Delete
(
)
{
RTC_DCHECK
(
!
IsCurrent
(
)
)
;
{
MutexLock
lock
(
&
pending_lock_
)
;
thread_should_quit_
=
true
;
}
NotifyWake
(
)
;
delete
this
;
}
void
TaskQueueStdlib
:
:
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
{
{
MutexLock
lock
(
&
pending_lock_
)
;
OrderId
order
=
thread_posting_order_
+
+
;
pending_queue_
.
push
(
std
:
:
pair
<
OrderId
std
:
:
unique_ptr
<
QueuedTask
>
>
(
order
std
:
:
move
(
task
)
)
)
;
}
NotifyWake
(
)
;
}
void
TaskQueueStdlib
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
{
const
auto
fire_at
=
rtc
:
:
TimeMillis
(
)
+
milliseconds
;
DelayedEntryTimeout
delay
;
delay
.
next_fire_at_ms_
=
fire_at
;
{
MutexLock
lock
(
&
pending_lock_
)
;
delay
.
order_
=
+
+
thread_posting_order_
;
delayed_queue_
[
delay
]
=
std
:
:
move
(
task
)
;
}
NotifyWake
(
)
;
}
TaskQueueStdlib
:
:
NextTask
TaskQueueStdlib
:
:
GetNextTask
(
)
{
NextTask
result
;
const
auto
tick
=
rtc
:
:
TimeMillis
(
)
;
MutexLock
lock
(
&
pending_lock_
)
;
if
(
thread_should_quit_
)
{
result
.
final_task_
=
true
;
return
result
;
}
if
(
delayed_queue_
.
size
(
)
>
0
)
{
auto
delayed_entry
=
delayed_queue_
.
begin
(
)
;
const
auto
&
delay_info
=
delayed_entry
-
>
first
;
auto
&
delay_run
=
delayed_entry
-
>
second
;
if
(
tick
>
=
delay_info
.
next_fire_at_ms_
)
{
if
(
pending_queue_
.
size
(
)
>
0
)
{
auto
&
entry
=
pending_queue_
.
front
(
)
;
auto
&
entry_order
=
entry
.
first
;
auto
&
entry_run
=
entry
.
second
;
if
(
entry_order
<
delay_info
.
order_
)
{
result
.
run_task_
=
std
:
:
move
(
entry_run
)
;
pending_queue_
.
pop
(
)
;
return
result
;
}
}
result
.
run_task_
=
std
:
:
move
(
delay_run
)
;
delayed_queue_
.
erase
(
delayed_entry
)
;
return
result
;
}
result
.
sleep_time_ms_
=
delay_info
.
next_fire_at_ms_
-
tick
;
}
if
(
pending_queue_
.
size
(
)
>
0
)
{
auto
&
entry
=
pending_queue_
.
front
(
)
;
result
.
run_task_
=
std
:
:
move
(
entry
.
second
)
;
pending_queue_
.
pop
(
)
;
}
return
result
;
}
void
TaskQueueStdlib
:
:
ProcessTasks
(
)
{
while
(
true
)
{
auto
task
=
GetNextTask
(
)
;
if
(
task
.
final_task_
)
break
;
if
(
task
.
run_task_
)
{
QueuedTask
*
release_ptr
=
task
.
run_task_
.
release
(
)
;
if
(
release_ptr
-
>
Run
(
)
)
delete
release_ptr
;
continue
;
}
flag_notify_
.
Wait
(
0
=
=
task
.
sleep_time_ms_
?
rtc
:
:
Event
:
:
kForever
:
task
.
sleep_time_ms_
)
;
}
}
void
TaskQueueStdlib
:
:
NotifyWake
(
)
{
flag_notify_
.
Set
(
)
;
}
class
TaskQueueStdlibFactory
final
:
public
TaskQueueFactory
{
public
:
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
CreateTaskQueue
(
absl
:
:
string_view
name
Priority
priority
)
const
override
{
return
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
(
new
TaskQueueStdlib
(
name
TaskQueuePriorityToThreadPriority
(
priority
)
)
)
;
}
}
;
}
std
:
:
unique_ptr
<
TaskQueueFactory
>
CreateTaskQueueStdlibFactory
(
)
{
return
std
:
:
make_unique
<
TaskQueueStdlibFactory
>
(
)
;
}
}
