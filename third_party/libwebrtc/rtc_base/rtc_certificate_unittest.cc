#
include
"
rtc_base
/
rtc_certificate
.
h
"
#
include
<
time
.
h
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
ssl_identity
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
rtc
{
namespace
{
static
const
char
*
kTestCertCommonName
=
"
RTCCertificateTest
'
s
certificate
"
;
}
class
RTCCertificateTest
:
public
:
:
testing
:
:
Test
{
protected
:
scoped_refptr
<
RTCCertificate
>
GenerateECDSA
(
)
{
std
:
:
unique_ptr
<
SSLIdentity
>
identity
(
SSLIdentity
:
:
Create
(
kTestCertCommonName
KeyParams
:
:
ECDSA
(
)
)
)
;
RTC_CHECK
(
identity
)
;
return
RTCCertificate
:
:
Create
(
std
:
:
move
(
identity
)
)
;
}
uint64_t
NowSeconds
(
)
const
{
return
TimeNanos
(
)
/
kNumNanosecsPerSec
;
}
uint64_t
ExpiresSeconds
(
const
scoped_refptr
<
RTCCertificate
>
&
cert
)
const
{
uint64_t
exp_ms
=
cert
-
>
Expires
(
)
;
uint64_t
exp_s
=
exp_ms
/
kNumMillisecsPerSec
;
RTC_CHECK_EQ
(
exp_s
*
kNumMillisecsPerSec
exp_ms
)
;
return
exp_s
;
}
bool
HasExpiredSeconds
(
const
scoped_refptr
<
RTCCertificate
>
&
cert
uint64_t
now_s
)
const
{
return
cert
-
>
HasExpired
(
now_s
*
kNumMillisecsPerSec
)
;
}
scoped_refptr
<
RTCCertificate
>
GenerateCertificateWithExpires
(
uint64_t
expires_s
)
const
{
RTC_CHECK
(
IsValueInRangeForNumericType
<
time_t
>
(
expires_s
)
)
;
SSLIdentityParams
params
;
params
.
common_name
=
kTestCertCommonName
;
params
.
not_before
=
0
;
params
.
not_after
=
static_cast
<
time_t
>
(
expires_s
)
;
params
.
key_params
=
KeyParams
:
:
ECDSA
(
)
;
std
:
:
unique_ptr
<
SSLIdentity
>
identity
(
SSLIdentity
:
:
CreateForTest
(
params
)
)
;
return
RTCCertificate
:
:
Create
(
std
:
:
move
(
identity
)
)
;
}
}
;
TEST_F
(
RTCCertificateTest
NewCertificateNotExpired
)
{
scoped_refptr
<
RTCCertificate
>
certificate
=
GenerateECDSA
(
)
;
uint64_t
now
=
NowSeconds
(
)
;
EXPECT_FALSE
(
HasExpiredSeconds
(
certificate
now
)
)
;
EXPECT_FALSE
(
HasExpiredSeconds
(
certificate
now
+
30
*
60
)
)
;
}
TEST_F
(
RTCCertificateTest
UsesExpiresAskedFor
)
{
uint64_t
now
=
NowSeconds
(
)
;
scoped_refptr
<
RTCCertificate
>
certificate
=
GenerateCertificateWithExpires
(
now
)
;
EXPECT_EQ
(
now
ExpiresSeconds
(
certificate
)
)
;
}
TEST_F
(
RTCCertificateTest
ExpiresInOneSecond
)
{
uint64_t
now
=
NowSeconds
(
)
;
scoped_refptr
<
RTCCertificate
>
certificate
=
GenerateCertificateWithExpires
(
now
+
1
)
;
EXPECT_FALSE
(
HasExpiredSeconds
(
certificate
now
)
)
;
EXPECT_TRUE
(
HasExpiredSeconds
(
certificate
now
+
2
)
)
;
}
TEST_F
(
RTCCertificateTest
DifferentCertificatesNotEqual
)
{
scoped_refptr
<
RTCCertificate
>
a
=
GenerateECDSA
(
)
;
scoped_refptr
<
RTCCertificate
>
b
=
GenerateECDSA
(
)
;
EXPECT_TRUE
(
*
a
!
=
*
b
)
;
}
TEST_F
(
RTCCertificateTest
CloneWithPEMSerialization
)
{
scoped_refptr
<
RTCCertificate
>
orig
=
GenerateECDSA
(
)
;
RTCCertificatePEM
orig_pem
=
orig
-
>
ToPEM
(
)
;
scoped_refptr
<
RTCCertificate
>
clone
=
RTCCertificate
:
:
FromPEM
(
orig_pem
)
;
EXPECT_TRUE
(
clone
)
;
EXPECT_TRUE
(
*
orig
=
=
*
clone
)
;
EXPECT_EQ
(
orig
-
>
Expires
(
)
clone
-
>
Expires
(
)
)
;
}
TEST_F
(
RTCCertificateTest
FromPEMWithInvalidPEM
)
{
RTCCertificatePEM
pem
(
"
not
a
valid
PEM
"
"
not
a
valid
PEM
"
)
;
scoped_refptr
<
RTCCertificate
>
certificate
=
RTCCertificate
:
:
FromPEM
(
pem
)
;
EXPECT_FALSE
(
certificate
)
;
}
}
