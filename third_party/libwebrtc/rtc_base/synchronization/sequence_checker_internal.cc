#
include
"
rtc_base
/
synchronization
/
sequence_checker_internal
.
h
"
#
include
<
string
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
namespace
webrtc
{
namespace
webrtc_sequence_checker_internal
{
SequenceCheckerImpl
:
:
SequenceCheckerImpl
(
bool
attach_to_current_thread
)
:
attached_
(
attach_to_current_thread
)
valid_thread_
(
rtc
:
:
CurrentThreadRef
(
)
)
valid_queue_
(
TaskQueueBase
:
:
Current
(
)
)
{
}
bool
SequenceCheckerImpl
:
:
IsCurrent
(
)
const
{
const
TaskQueueBase
*
const
current_queue
=
TaskQueueBase
:
:
Current
(
)
;
const
rtc
:
:
PlatformThreadRef
current_thread
=
rtc
:
:
CurrentThreadRef
(
)
;
MutexLock
scoped_lock
(
&
lock_
)
;
if
(
!
attached_
)
{
attached_
=
true
;
valid_thread_
=
current_thread
;
valid_queue_
=
current_queue
;
return
true
;
}
if
(
valid_queue_
)
{
return
valid_queue_
=
=
current_queue
;
}
return
rtc
:
:
IsThreadRefEqual
(
valid_thread_
current_thread
)
;
}
void
SequenceCheckerImpl
:
:
Detach
(
)
{
MutexLock
scoped_lock
(
&
lock_
)
;
attached_
=
false
;
}
#
if
RTC_DCHECK_IS_ON
std
:
:
string
SequenceCheckerImpl
:
:
ExpectationToString
(
)
const
{
const
TaskQueueBase
*
const
current_queue
=
TaskQueueBase
:
:
Current
(
)
;
const
rtc
:
:
PlatformThreadRef
current_thread
=
rtc
:
:
CurrentThreadRef
(
)
;
MutexLock
scoped_lock
(
&
lock_
)
;
if
(
!
attached_
)
return
"
Checker
currently
not
attached
.
"
;
rtc
:
:
StringBuilder
message
;
message
.
AppendFormat
(
"
#
Expected
:
TQ
:
%
p
Thread
:
%
p
\
n
"
"
#
Actual
:
TQ
:
%
p
Thread
:
%
p
\
n
"
valid_queue_
reinterpret_cast
<
const
void
*
>
(
valid_thread_
)
current_queue
reinterpret_cast
<
const
void
*
>
(
current_thread
)
)
;
if
(
(
valid_queue_
|
|
current_queue
)
&
&
valid_queue_
!
=
current_queue
)
{
message
<
<
"
TaskQueue
doesn
'
t
match
\
n
"
;
}
else
if
(
!
rtc
:
:
IsThreadRefEqual
(
valid_thread_
current_thread
)
)
{
message
<
<
"
Threads
don
'
t
match
\
n
"
;
}
return
message
.
Release
(
)
;
}
#
endif
}
}
