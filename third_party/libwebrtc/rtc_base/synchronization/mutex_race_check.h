#
ifndef
RTC_BASE_SYNCHRONIZATION_MUTEX_RACE_CHECK_H_
#
define
RTC_BASE_SYNCHRONIZATION_MUTEX_RACE_CHECK_H_
#
include
<
atomic
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
system
/
unused
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
RTC_LOCKABLE
MutexImpl
final
{
public
:
MutexImpl
(
)
=
default
;
MutexImpl
(
const
MutexImpl
&
)
=
delete
;
MutexImpl
&
operator
=
(
const
MutexImpl
&
)
=
delete
;
void
Lock
(
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
)
{
bool
was_free
=
free_
.
exchange
(
false
std
:
:
memory_order_acquire
)
;
RTC_CHECK
(
was_free
)
<
<
"
WEBRTC_RACE_CHECK_MUTEX
:
mutex
locked
concurrently
.
"
;
}
RTC_WARN_UNUSED_RESULT
bool
TryLock
(
)
RTC_EXCLUSIVE_TRYLOCK_FUNCTION
(
true
)
{
bool
was_free
=
free_
.
exchange
(
false
std
:
:
memory_order_acquire
)
;
return
was_free
;
}
void
Unlock
(
)
RTC_UNLOCK_FUNCTION
(
)
{
free_
.
store
(
true
std
:
:
memory_order_release
)
;
}
private
:
std
:
:
atomic
<
bool
>
free_
{
true
}
;
}
;
}
#
endif
