#
ifndef
RTC_BASE_SYNCHRONIZATION_SEQUENCE_CHECKER_INTERNAL_H_
#
define
RTC_BASE_SYNCHRONIZATION_SEQUENCE_CHECKER_INTERNAL_H_
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
namespace
webrtc_sequence_checker_internal
{
class
RTC_EXPORT
SequenceCheckerImpl
{
public
:
explicit
SequenceCheckerImpl
(
bool
attach_to_current_thread
)
;
explicit
SequenceCheckerImpl
(
TaskQueueBase
*
attached_queue
)
;
~
SequenceCheckerImpl
(
)
=
default
;
bool
IsCurrent
(
)
const
;
void
Detach
(
)
;
std
:
:
string
ExpectationToString
(
)
const
;
private
:
mutable
Mutex
lock_
;
mutable
bool
attached_
RTC_GUARDED_BY
(
lock_
)
;
mutable
rtc
:
:
PlatformThreadRef
valid_thread_
RTC_GUARDED_BY
(
lock_
)
;
mutable
const
TaskQueueBase
*
valid_queue_
RTC_GUARDED_BY
(
lock_
)
;
}
;
class
SequenceCheckerDoNothing
{
public
:
explicit
SequenceCheckerDoNothing
(
bool
)
{
}
explicit
SequenceCheckerDoNothing
(
TaskQueueBase
*
)
{
}
bool
IsCurrent
(
)
const
{
return
true
;
}
void
Detach
(
)
{
}
}
;
template
<
typename
ThreadLikeObject
>
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
SequenceCheckerImpl
ThreadLikeObject
>
std
:
:
string
>
ExpectationToString
(
[
[
maybe_unused
]
]
const
ThreadLikeObject
*
checker
)
{
#
if
RTC_DCHECK_IS_ON
return
checker
-
>
ExpectationToString
(
)
;
#
else
return
std
:
:
string
(
)
;
#
endif
}
template
<
typename
ThreadLikeObject
>
std
:
:
enable_if_t
<
!
std
:
:
is_base_of_v
<
SequenceCheckerImpl
ThreadLikeObject
>
std
:
:
string
>
ExpectationToString
(
const
ThreadLikeObject
*
)
{
return
std
:
:
string
(
)
;
}
}
}
#
endif
