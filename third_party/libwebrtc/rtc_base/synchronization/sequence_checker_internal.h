#
ifndef
RTC_BASE_SYNCHRONIZATION_SEQUENCE_CHECKER_INTERNAL_H_
#
define
RTC_BASE_SYNCHRONIZATION_SEQUENCE_CHECKER_INTERNAL_H_
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
namespace
webrtc_sequence_checker_internal
{
class
RTC_EXPORT
SequenceCheckerImpl
{
public
:
SequenceCheckerImpl
(
)
;
~
SequenceCheckerImpl
(
)
=
default
;
bool
IsCurrent
(
)
const
;
void
Detach
(
)
;
std
:
:
string
ExpectationToString
(
)
const
;
private
:
mutable
Mutex
lock_
;
mutable
bool
attached_
RTC_GUARDED_BY
(
lock_
)
;
mutable
rtc
:
:
PlatformThreadRef
valid_thread_
RTC_GUARDED_BY
(
lock_
)
;
mutable
const
TaskQueueBase
*
valid_queue_
RTC_GUARDED_BY
(
lock_
)
;
mutable
const
void
*
valid_system_queue_
RTC_GUARDED_BY
(
lock_
)
;
}
;
class
SequenceCheckerDoNothing
{
public
:
bool
IsCurrent
(
)
const
{
return
true
;
}
void
Detach
(
)
{
}
}
;
class
RTC_SCOPED_LOCKABLE
SequenceCheckerScope
{
public
:
template
<
typename
ThreadLikeObject
>
explicit
SequenceCheckerScope
(
const
ThreadLikeObject
*
thread_like_object
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
thread_like_object
)
{
}
SequenceCheckerScope
(
const
SequenceCheckerScope
&
)
=
delete
;
SequenceCheckerScope
&
operator
=
(
const
SequenceCheckerScope
&
)
=
delete
;
~
SequenceCheckerScope
(
)
RTC_UNLOCK_FUNCTION
(
)
{
}
template
<
typename
ThreadLikeObject
>
static
bool
IsCurrent
(
const
ThreadLikeObject
*
thread_like_object
)
{
return
thread_like_object
-
>
IsCurrent
(
)
;
}
}
;
std
:
:
string
ExpectationToString
(
const
SequenceCheckerImpl
*
checker
)
;
template
<
typename
ThreadLikeObject
>
std
:
:
string
ExpectationToString
(
const
ThreadLikeObject
*
)
{
return
std
:
:
string
(
)
;
}
}
}
#
endif
