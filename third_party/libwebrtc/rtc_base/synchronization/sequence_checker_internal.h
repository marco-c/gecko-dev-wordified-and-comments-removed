#
ifndef
RTC_BASE_SYNCHRONIZATION_SEQUENCE_CHECKER_INTERNAL_H_
#
define
RTC_BASE_SYNCHRONIZATION_SEQUENCE_CHECKER_INTERNAL_H_
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
rtc
{
class
TaskQueue
;
}
namespace
webrtc
{
class
SequenceChecker
;
namespace
webrtc_sequence_checker_internal
{
inline
void
AssertHeld
(
const
SequenceChecker
*
checker
)
RTC_ASSERT_EXCLUSIVE_LOCK
(
checker
)
{
}
inline
void
AssertHeld
(
const
TaskQueueBase
*
task_queue
)
RTC_ASSERT_EXCLUSIVE_LOCK
(
task_queue
)
{
}
inline
void
AssertHeld
(
const
rtc
:
:
TaskQueue
*
task_queue
)
RTC_ASSERT_EXCLUSIVE_LOCK
(
task_queue
)
{
}
class
RTC_EXPORT
SequenceCheckerImpl
{
public
:
SequenceCheckerImpl
(
)
;
~
SequenceCheckerImpl
(
)
=
default
;
bool
IsCurrent
(
)
const
;
void
Detach
(
)
;
std
:
:
string
ExpectationToString
(
)
const
;
private
:
mutable
Mutex
lock_
;
mutable
bool
attached_
RTC_GUARDED_BY
(
lock_
)
;
mutable
rtc
:
:
PlatformThreadRef
valid_thread_
RTC_GUARDED_BY
(
lock_
)
;
mutable
const
TaskQueueBase
*
valid_queue_
RTC_GUARDED_BY
(
lock_
)
;
mutable
const
void
*
valid_system_queue_
RTC_GUARDED_BY
(
lock_
)
;
}
;
class
SequenceCheckerDoNothing
{
public
:
bool
IsCurrent
(
)
const
{
return
true
;
}
void
Detach
(
)
{
}
}
;
std
:
:
string
ExpectationToString
(
const
SequenceCheckerImpl
*
checker
)
;
template
<
typename
ThreadLikeObject
>
std
:
:
string
ExpectationToString
(
const
ThreadLikeObject
*
)
{
return
std
:
:
string
(
)
;
}
}
}
#
endif
