#
ifndef
RTC_BASE_DEPRECATED_RECURSIVE_CRITICAL_SECTION_H_
#
define
RTC_BASE_DEPRECATED_RECURSIVE_CRITICAL_SECTION_H_
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
if
defined
(
WEBRTC_WIN
)
#
include
<
winsock2
.
h
>
#
include
<
windows
.
h
>
#
include
<
sal
.
h
>
#
endif
#
if
defined
(
WEBRTC_POSIX
)
#
include
<
pthread
.
h
>
#
endif
#
define
RTC_USE_NATIVE_MUTEX_ON_MAC
1
#
if
defined
(
WEBRTC_MAC
)
&
&
!
RTC_USE_NATIVE_MUTEX_ON_MAC
#
include
<
dispatch
/
dispatch
.
h
>
#
endif
namespace
webrtc
{
class
RTC_LOCKABLE
RecursiveCriticalSection
{
public
:
RecursiveCriticalSection
(
)
;
~
RecursiveCriticalSection
(
)
;
void
Enter
(
)
const
RTC_EXCLUSIVE_LOCK_FUNCTION
(
)
;
bool
TryEnter
(
)
const
RTC_EXCLUSIVE_TRYLOCK_FUNCTION
(
true
)
;
void
Leave
(
)
const
RTC_UNLOCK_FUNCTION
(
)
;
private
:
bool
CurrentThreadIsOwner
(
)
const
;
#
if
defined
(
WEBRTC_WIN
)
mutable
CRITICAL_SECTION
crit_
;
#
elif
defined
(
WEBRTC_POSIX
)
#
if
defined
(
WEBRTC_MAC
)
&
&
!
RTC_USE_NATIVE_MUTEX_ON_MAC
mutable
std
:
:
atomic
<
int
>
lock_queue_
;
mutable
int
recursion_
;
mutable
dispatch_semaphore_t
semaphore_
;
mutable
PlatformThreadRef
owning_thread_
;
#
else
mutable
pthread_mutex_t
mutex_
;
#
endif
mutable
rtc
:
:
PlatformThreadRef
thread_
;
mutable
int
recursion_count_
;
#
else
#
error
Unsupported
platform
.
#
endif
}
;
class
RTC_SCOPED_LOCKABLE
CritScope
{
public
:
explicit
CritScope
(
const
RecursiveCriticalSection
*
cs
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
cs
)
;
~
CritScope
(
)
RTC_UNLOCK_FUNCTION
(
)
;
CritScope
(
const
CritScope
&
)
=
delete
;
CritScope
&
operator
=
(
const
CritScope
&
)
=
delete
;
private
:
const
RecursiveCriticalSection
*
const
cs_
;
}
;
}
namespace
rtc
{
using
:
:
webrtc
:
:
CritScope
;
using
:
:
webrtc
:
:
RecursiveCriticalSection
;
}
#
endif
