#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
namespace
webrtc
{
SimpleStringBuilder
:
:
SimpleStringBuilder
(
rtc
:
:
ArrayView
<
char
>
buffer
)
:
buffer_
(
buffer
)
{
buffer_
[
0
]
=
'
\
0
'
;
RTC_DCHECK
(
IsConsistent
(
)
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
char
ch
)
{
return
operator
<
<
(
absl
:
:
string_view
(
&
ch
1
)
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
absl
:
:
string_view
str
)
{
RTC_DCHECK_LT
(
size_
+
str
.
length
(
)
buffer_
.
size
(
)
)
<
<
"
Buffer
size
was
insufficient
"
;
const
size_t
chars_added
=
SafeMin
(
str
.
length
(
)
buffer_
.
size
(
)
-
size_
-
1
)
;
memcpy
(
&
buffer_
[
size_
]
str
.
data
(
)
chars_added
)
;
size_
+
=
chars_added
;
buffer_
[
size_
]
=
'
\
0
'
;
RTC_DCHECK
(
IsConsistent
(
)
)
;
return
*
this
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
int
i
)
{
return
AppendFormat
(
"
%
d
"
i
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
unsigned
i
)
{
return
AppendFormat
(
"
%
u
"
i
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
long
i
)
{
return
AppendFormat
(
"
%
ld
"
i
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
long
long
i
)
{
return
AppendFormat
(
"
%
lld
"
i
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
unsigned
long
i
)
{
return
AppendFormat
(
"
%
lu
"
i
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
unsigned
long
long
i
)
{
return
AppendFormat
(
"
%
llu
"
i
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
float
f
)
{
return
AppendFormat
(
"
%
g
"
f
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
double
f
)
{
return
AppendFormat
(
"
%
g
"
f
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
operator
<
<
(
long
double
f
)
{
return
AppendFormat
(
"
%
Lg
"
f
)
;
}
SimpleStringBuilder
&
SimpleStringBuilder
:
:
AppendFormat
(
const
char
*
fmt
.
.
.
)
{
va_list
args
;
va_start
(
args
fmt
)
;
const
int
len
=
std
:
:
vsnprintf
(
&
buffer_
[
size_
]
buffer_
.
size
(
)
-
size_
fmt
args
)
;
if
(
len
>
=
0
)
{
const
size_t
chars_added
=
SafeMin
(
len
buffer_
.
size
(
)
-
1
-
size_
)
;
size_
+
=
chars_added
;
RTC_DCHECK_EQ
(
len
chars_added
)
<
<
"
Buffer
size
was
insufficient
"
;
}
else
{
RTC_DCHECK_NOTREACHED
(
)
;
buffer_
[
size_
]
=
'
\
0
'
;
}
va_end
(
args
)
;
RTC_DCHECK
(
IsConsistent
(
)
)
;
return
*
this
;
}
StringBuilder
&
StringBuilder
:
:
AppendFormat
(
const
char
*
fmt
.
.
.
)
{
va_list
args
copy
;
va_start
(
args
fmt
)
;
va_copy
(
copy
args
)
;
const
int
predicted_length
=
std
:
:
vsnprintf
(
nullptr
0
fmt
copy
)
;
va_end
(
copy
)
;
RTC_DCHECK_GE
(
predicted_length
0
)
;
if
(
predicted_length
>
0
)
{
const
size_t
size
=
str_
.
size
(
)
;
str_
.
resize
(
size
+
predicted_length
)
;
const
int
actual_length
=
std
:
:
vsnprintf
(
&
str_
[
size
]
predicted_length
+
1
fmt
args
)
;
RTC_DCHECK_GE
(
actual_length
0
)
;
}
va_end
(
args
)
;
return
*
this
;
}
}
