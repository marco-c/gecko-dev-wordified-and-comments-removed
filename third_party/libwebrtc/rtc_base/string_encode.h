#
ifndef
RTC_BASE_STRING_ENCODE_H_
#
define
RTC_BASE_STRING_ENCODE_H_
#
include
<
stddef
.
h
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
string_to_number
.
h
"
namespace
rtc
{
template
<
typename
T
typename
std
:
:
enable_if
<
!
std
:
:
is_pointer
<
T
>
:
:
value
|
|
std
:
:
is_convertible
<
T
const
char
*
>
:
:
value
>
:
:
type
*
=
nullptr
>
std
:
:
string
ToString
(
T
value
)
{
return
{
absl
:
:
StrCat
(
value
)
}
;
}
template
<
>
std
:
:
string
ToString
(
bool
b
)
;
template
<
>
std
:
:
string
ToString
(
long
double
t
)
;
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_pointer
<
T
>
:
:
value
&
&
!
std
:
:
is_convertible
<
T
const
char
*
>
:
:
value
>
:
:
type
*
=
nullptr
>
std
:
:
string
ToString
(
T
p
)
{
char
buf
[
32
]
;
const
int
len
=
std
:
:
snprintf
(
&
buf
[
0
]
std
:
:
size
(
buf
)
"
%
p
"
p
)
;
RTC_DCHECK_LE
(
len
std
:
:
size
(
buf
)
)
;
return
std
:
:
string
(
&
buf
[
0
]
len
)
;
}
}
namespace
webrtc
{
std
:
:
string
hex_encode
(
absl
:
:
string_view
str
)
;
std
:
:
string
hex_encode_with_delimiter
(
absl
:
:
string_view
source
char
delimiter
)
;
size_t
hex_decode
(
rtc
:
:
ArrayView
<
char
>
buffer
absl
:
:
string_view
source
)
;
size_t
hex_decode_with_delimiter
(
rtc
:
:
ArrayView
<
char
>
buffer
absl
:
:
string_view
source
char
delimiter
)
;
std
:
:
vector
<
absl
:
:
string_view
>
split
(
absl
:
:
string_view
source
char
delimiter
)
;
size_t
tokenize
(
absl
:
:
string_view
source
char
delimiter
std
:
:
vector
<
std
:
:
string
>
*
fields
)
;
bool
tokenize_first
(
absl
:
:
string_view
source
char
delimiter
std
:
:
string
*
token
std
:
:
string
*
rest
)
;
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
T
>
:
:
value
&
&
!
std
:
:
is_same
<
T
bool
>
:
:
value
int
>
:
:
type
=
0
>
static
bool
FromString
(
absl
:
:
string_view
s
T
*
t
)
{
RTC_DCHECK
(
t
)
;
std
:
:
optional
<
T
>
result
=
webrtc
:
:
StringToNumber
<
T
>
(
s
)
;
if
(
result
)
*
t
=
*
result
;
return
result
.
has_value
(
)
;
}
bool
FromString
(
absl
:
:
string_view
s
bool
*
b
)
;
template
<
typename
T
>
static
inline
T
FromString
(
absl
:
:
string_view
str
)
{
T
val
;
FromString
(
str
&
val
)
;
return
val
;
}
}
namespace
rtc
{
using
:
:
webrtc
:
:
FromString
;
using
:
:
webrtc
:
:
hex_decode
;
using
:
:
webrtc
:
:
hex_decode_with_delimiter
;
using
:
:
webrtc
:
:
hex_encode
;
using
:
:
webrtc
:
:
hex_encode_with_delimiter
;
using
:
:
webrtc
:
:
split
;
using
:
:
webrtc
:
:
tokenize
;
using
:
:
webrtc
:
:
tokenize_first
;
}
#
endif
