#
include
"
rtc_base
/
task_utils
/
repeating_task
.
h
"
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
task_utils
/
pending_task_safety_flag
.
h
"
#
include
"
rtc_base
/
task_utils
/
to_queued_task
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
webrtc_repeating_task_impl
{
RepeatingTaskBase
:
:
RepeatingTaskBase
(
TaskQueueBase
*
task_queue
TaskQueueBase
:
:
DelayPrecision
precision
TimeDelta
first_delay
Clock
*
clock
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
alive_flag
)
:
task_queue_
(
task_queue
)
precision_
(
precision
)
clock_
(
clock
)
next_run_time_
(
clock_
-
>
CurrentTime
(
)
+
first_delay
)
alive_flag_
(
std
:
:
move
(
alive_flag
)
)
{
}
RepeatingTaskBase
:
:
~
RepeatingTaskBase
(
)
=
default
;
bool
RepeatingTaskBase
:
:
Run
(
)
{
RTC_DCHECK_RUN_ON
(
task_queue_
)
;
if
(
!
alive_flag_
-
>
alive
(
)
)
return
true
;
TimeDelta
delay
=
RunClosure
(
)
;
RTC_DCHECK_GE
(
delay
TimeDelta
:
:
Zero
(
)
)
;
if
(
delay
.
IsPlusInfinity
(
)
|
|
!
alive_flag_
-
>
alive
(
)
)
return
true
;
TimeDelta
lost_time
=
clock_
-
>
CurrentTime
(
)
-
next_run_time_
;
next_run_time_
+
=
delay
;
delay
-
=
lost_time
;
delay
=
std
:
:
max
(
delay
TimeDelta
:
:
Zero
(
)
)
;
task_queue_
-
>
PostDelayedTaskWithPrecision
(
precision_
absl
:
:
WrapUnique
(
this
)
delay
.
ms
(
)
)
;
return
false
;
}
}
void
RepeatingTaskHandle
:
:
Stop
(
)
{
if
(
repeating_task_
)
{
repeating_task_
-
>
SetNotAlive
(
)
;
repeating_task_
=
nullptr
;
}
}
bool
RepeatingTaskHandle
:
:
Running
(
)
const
{
return
repeating_task_
!
=
nullptr
;
}
namespace
webrtc_repeating_task_impl
{
void
RepeatingTaskHandleDTraceProbeStart
(
)
{
}
void
RepeatingTaskHandleDTraceProbeDelayedStart
(
)
{
}
void
RepeatingTaskImplDTraceProbeRun
(
)
{
}
}
}
