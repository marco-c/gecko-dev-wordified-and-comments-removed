#
ifndef
RTC_BASE_TASK_UTILS_REPEATING_TASK_H_
#
define
RTC_BASE_TASK_UTILS_REPEATING_TASK_H_
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
api
/
task_queue
/
queued_task
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
class
RepeatingTaskHandle
;
namespace
webrtc_repeating_task_impl
{
class
RepeatingTaskBase
:
public
QueuedTask
{
public
:
RepeatingTaskBase
(
TaskQueueBase
*
task_queue
TimeDelta
first_delay
Clock
*
clock
)
;
~
RepeatingTaskBase
(
)
override
;
void
Stop
(
)
;
private
:
virtual
TimeDelta
RunClosure
(
)
=
0
;
bool
Run
(
)
final
;
TaskQueueBase
*
const
task_queue_
;
Clock
*
const
clock_
;
Timestamp
next_run_time_
RTC_GUARDED_BY
(
task_queue_
)
;
}
;
template
<
class
Closure
>
class
RepeatingTaskImpl
final
:
public
RepeatingTaskBase
{
public
:
RepeatingTaskImpl
(
TaskQueueBase
*
task_queue
TimeDelta
first_delay
Closure
&
&
closure
Clock
*
clock
)
:
RepeatingTaskBase
(
task_queue
first_delay
clock
)
closure_
(
std
:
:
forward
<
Closure
>
(
closure
)
)
{
static_assert
(
std
:
:
is_same
<
TimeDelta
typename
std
:
:
result_of
<
decltype
(
&
Closure
:
:
operator
(
)
)
(
Closure
)
>
:
:
type
>
:
:
value
"
"
)
;
}
private
:
TimeDelta
RunClosure
(
)
override
{
return
closure_
(
)
;
}
typename
std
:
:
remove_const
<
typename
std
:
:
remove_reference
<
Closure
>
:
:
type
>
:
:
type
closure_
;
}
;
}
class
RepeatingTaskHandle
{
public
:
RepeatingTaskHandle
(
)
=
default
;
~
RepeatingTaskHandle
(
)
=
default
;
RepeatingTaskHandle
(
RepeatingTaskHandle
&
&
other
)
;
RepeatingTaskHandle
&
operator
=
(
RepeatingTaskHandle
&
&
other
)
;
RepeatingTaskHandle
(
const
RepeatingTaskHandle
&
)
=
delete
;
RepeatingTaskHandle
&
operator
=
(
const
RepeatingTaskHandle
&
)
=
delete
;
template
<
class
Closure
>
static
RepeatingTaskHandle
Start
(
TaskQueueBase
*
task_queue
Closure
&
&
closure
Clock
*
clock
=
Clock
:
:
GetRealTimeClockRaw
(
)
)
{
auto
repeating_task
=
std
:
:
make_unique
<
webrtc_repeating_task_impl
:
:
RepeatingTaskImpl
<
Closure
>
>
(
task_queue
TimeDelta
:
:
Zero
(
)
std
:
:
forward
<
Closure
>
(
closure
)
clock
)
;
auto
*
repeating_task_ptr
=
repeating_task
.
get
(
)
;
task_queue
-
>
PostTask
(
std
:
:
move
(
repeating_task
)
)
;
return
RepeatingTaskHandle
(
repeating_task_ptr
)
;
}
template
<
class
Closure
>
static
RepeatingTaskHandle
DelayedStart
(
TaskQueueBase
*
task_queue
TimeDelta
first_delay
Closure
&
&
closure
Clock
*
clock
=
Clock
:
:
GetRealTimeClockRaw
(
)
)
{
auto
repeating_task
=
std
:
:
make_unique
<
webrtc_repeating_task_impl
:
:
RepeatingTaskImpl
<
Closure
>
>
(
task_queue
first_delay
std
:
:
forward
<
Closure
>
(
closure
)
clock
)
;
auto
*
repeating_task_ptr
=
repeating_task
.
get
(
)
;
task_queue
-
>
PostDelayedTask
(
std
:
:
move
(
repeating_task
)
first_delay
.
ms
(
)
)
;
return
RepeatingTaskHandle
(
repeating_task_ptr
)
;
}
void
Stop
(
)
;
bool
Running
(
)
const
;
private
:
explicit
RepeatingTaskHandle
(
webrtc_repeating_task_impl
:
:
RepeatingTaskBase
*
repeating_task
)
;
webrtc_repeating_task_impl
:
:
RepeatingTaskBase
*
repeating_task_
=
nullptr
;
}
;
}
#
endif
