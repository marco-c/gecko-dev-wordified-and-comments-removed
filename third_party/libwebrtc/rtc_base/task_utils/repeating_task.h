#
ifndef
RTC_BASE_TASK_UTILS_REPEATING_TASK_H_
#
define
RTC_BASE_TASK_UTILS_REPEATING_TASK_H_
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
api
/
task_queue
/
queued_task
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
rtc_base
/
task_utils
/
pending_task_safety_flag
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
webrtc_repeating_task_impl
{
class
RepeatingTaskBase
:
public
QueuedTask
{
public
:
RepeatingTaskBase
(
TaskQueueBase
*
task_queue
TimeDelta
first_delay
Clock
*
clock
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
alive_flag
)
;
~
RepeatingTaskBase
(
)
override
;
private
:
virtual
TimeDelta
RunClosure
(
)
=
0
;
bool
Run
(
)
final
;
TaskQueueBase
*
const
task_queue_
;
Clock
*
const
clock_
;
Timestamp
next_run_time_
RTC_GUARDED_BY
(
task_queue_
)
;
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
alive_flag_
RTC_GUARDED_BY
(
task_queue_
)
;
}
;
template
<
class
Closure
>
class
RepeatingTaskImpl
final
:
public
RepeatingTaskBase
{
public
:
RepeatingTaskImpl
(
TaskQueueBase
*
task_queue
TimeDelta
first_delay
Closure
&
&
closure
Clock
*
clock
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
alive_flag
)
:
RepeatingTaskBase
(
task_queue
first_delay
clock
std
:
:
move
(
alive_flag
)
)
closure_
(
std
:
:
forward
<
Closure
>
(
closure
)
)
{
static_assert
(
std
:
:
is_same
<
TimeDelta
typename
std
:
:
result_of
<
decltype
(
&
Closure
:
:
operator
(
)
)
(
Closure
)
>
:
:
type
>
:
:
value
"
"
)
;
}
private
:
TimeDelta
RunClosure
(
)
override
{
return
closure_
(
)
;
}
typename
std
:
:
remove_const
<
typename
std
:
:
remove_reference
<
Closure
>
:
:
type
>
:
:
type
closure_
;
}
;
}
class
RepeatingTaskHandle
{
public
:
RepeatingTaskHandle
(
)
=
default
;
~
RepeatingTaskHandle
(
)
=
default
;
RepeatingTaskHandle
(
RepeatingTaskHandle
&
&
other
)
=
default
;
RepeatingTaskHandle
&
operator
=
(
RepeatingTaskHandle
&
&
other
)
=
default
;
RepeatingTaskHandle
(
const
RepeatingTaskHandle
&
)
=
delete
;
RepeatingTaskHandle
&
operator
=
(
const
RepeatingTaskHandle
&
)
=
delete
;
template
<
class
Closure
>
static
RepeatingTaskHandle
Start
(
TaskQueueBase
*
task_queue
Closure
&
&
closure
Clock
*
clock
=
Clock
:
:
GetRealTimeClockRaw
(
)
)
{
auto
alive_flag
=
PendingTaskSafetyFlag
:
:
CreateDetached
(
)
;
task_queue
-
>
PostTask
(
std
:
:
make_unique
<
webrtc_repeating_task_impl
:
:
RepeatingTaskImpl
<
Closure
>
>
(
task_queue
TimeDelta
:
:
Zero
(
)
std
:
:
forward
<
Closure
>
(
closure
)
clock
alive_flag
)
)
;
return
RepeatingTaskHandle
(
std
:
:
move
(
alive_flag
)
)
;
}
template
<
class
Closure
>
static
RepeatingTaskHandle
DelayedStart
(
TaskQueueBase
*
task_queue
TimeDelta
first_delay
Closure
&
&
closure
Clock
*
clock
=
Clock
:
:
GetRealTimeClockRaw
(
)
)
{
auto
alive_flag
=
PendingTaskSafetyFlag
:
:
CreateDetached
(
)
;
task_queue
-
>
PostDelayedTask
(
std
:
:
make_unique
<
webrtc_repeating_task_impl
:
:
RepeatingTaskImpl
<
Closure
>
>
(
task_queue
first_delay
std
:
:
forward
<
Closure
>
(
closure
)
clock
alive_flag
)
first_delay
.
ms
(
)
)
;
return
RepeatingTaskHandle
(
std
:
:
move
(
alive_flag
)
)
;
}
void
Stop
(
)
;
bool
Running
(
)
const
;
private
:
explicit
RepeatingTaskHandle
(
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
alive_flag
)
:
repeating_task_
(
std
:
:
move
(
alive_flag
)
)
{
}
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
repeating_task_
;
}
;
}
#
endif
