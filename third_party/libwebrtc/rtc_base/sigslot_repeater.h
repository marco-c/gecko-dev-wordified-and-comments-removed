#
ifndef
RTC_BASE_SIGSLOT_REPEATER_H__
#
define
RTC_BASE_SIGSLOT_REPEATER_H__
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
namespace
sigslot
{
template
<
class
mt_policy
typename
.
.
.
Args
>
class
repeater_with_thread_policy
:
public
signal_with_thread_policy
<
mt_policy
Args
.
.
.
>
public
has_slots
<
mt_policy
>
{
private
:
typedef
signal_with_thread_policy
<
mt_policy
Args
.
.
.
>
base_type
;
typedef
repeater_with_thread_policy
<
mt_policy
Args
.
.
.
>
this_type
;
public
:
repeater_with_thread_policy
(
)
{
}
repeater_with_thread_policy
(
const
this_type
&
s
)
:
base_type
(
s
)
{
}
void
reemit
(
Args
.
.
.
args
)
{
base_type
:
:
emit
(
args
.
.
.
)
;
}
void
repeat
(
base_type
&
s
)
{
s
.
connect
(
this
&
this_type
:
:
reemit
)
;
}
void
stop
(
base_type
&
s
)
{
s
.
disconnect
(
this
)
;
}
}
;
template
<
typename
.
.
.
Args
>
using
repeater
=
repeater_with_thread_policy
<
SIGSLOT_DEFAULT_MT_POLICY
Args
.
.
.
>
;
}
#
endif
