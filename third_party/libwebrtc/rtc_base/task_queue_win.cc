#
include
"
rtc_base
/
task_queue
.
h
"
#
include
<
mmsystem
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
queue
>
#
include
<
utility
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
refcount
.
h
"
#
include
"
rtc_base
/
refcountedobject
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
namespace
rtc
{
namespace
{
using
Priority
=
TaskQueue
:
:
Priority
;
DWORD
g_queue_ptr_tls
=
0
;
BOOL
CALLBACK
InitializeTls
(
PINIT_ONCE
init_once
void
*
param
void
*
*
context
)
{
g_queue_ptr_tls
=
TlsAlloc
(
)
;
return
TRUE
;
}
DWORD
GetQueuePtrTls
(
)
{
static
INIT_ONCE
init_once
=
INIT_ONCE_STATIC_INIT
;
:
:
InitOnceExecuteOnce
(
&
init_once
InitializeTls
nullptr
nullptr
)
;
return
g_queue_ptr_tls
;
}
struct
ThreadStartupData
{
Event
*
started
;
void
*
thread_context
;
}
;
void
CALLBACK
InitializeQueueThread
(
ULONG_PTR
param
)
{
ThreadStartupData
*
data
=
reinterpret_cast
<
ThreadStartupData
*
>
(
param
)
;
:
:
TlsSetValue
(
GetQueuePtrTls
(
)
data
-
>
thread_context
)
;
data
-
>
started
-
>
Set
(
)
;
}
ThreadPriority
TaskQueuePriorityToThreadPriority
(
Priority
priority
)
{
switch
(
priority
)
{
case
Priority
:
:
HIGH
:
return
rtc
:
:
ThreadPriority
:
:
kRealtime
;
case
Priority
:
:
LOW
:
return
rtc
:
:
ThreadPriority
:
:
kLow
;
case
Priority
:
:
NORMAL
:
return
rtc
:
:
ThreadPriority
:
:
kNormal
;
}
}
int64_t
GetTick
(
)
{
static
const
UINT
kPeriod
=
1
;
bool
high_res
=
(
timeBeginPeriod
(
kPeriod
)
=
=
TIMERR_NOERROR
)
;
int64_t
ret
=
TimeMillis
(
)
;
if
(
high_res
)
{
timeEndPeriod
(
kPeriod
)
;
}
return
ret
;
}
class
DelayedTaskInfo
{
public
:
DelayedTaskInfo
(
)
{
}
DelayedTaskInfo
(
uint32_t
milliseconds
std
:
:
unique_ptr
<
QueuedTask
>
task
)
:
due_time_
(
GetTick
(
)
+
milliseconds
)
task_
(
std
:
:
move
(
task
)
)
{
}
DelayedTaskInfo
(
DelayedTaskInfo
&
&
)
=
default
;
bool
operator
>
(
const
DelayedTaskInfo
&
other
)
const
{
return
due_time_
>
other
.
due_time_
;
}
DelayedTaskInfo
&
operator
=
(
DelayedTaskInfo
&
&
other
)
=
default
;
std
:
:
unique_ptr
<
QueuedTask
>
take
(
)
const
{
return
std
:
:
move
(
task_
)
;
}
int64_t
due_time
(
)
const
{
return
due_time_
;
}
private
:
int64_t
due_time_
=
0
;
mutable
std
:
:
unique_ptr
<
QueuedTask
>
task_
;
}
;
}
class
TaskQueue
:
:
Impl
:
public
RefCountInterface
{
public
:
class
ReplyHandler
{
public
:
ReplyHandler
(
)
:
impl_
(
nullptr
)
{
}
void
SetImpl
(
Impl
*
impl
)
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
impl_
=
impl
;
}
void
PostReplyTask
(
QueuedTask
*
reply_task
)
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
if
(
!
impl_
)
{
delete
reply_task
;
return
;
}
impl_
-
>
PostTask
(
[
reply_task
]
{
if
(
reply_task
-
>
Run
(
)
)
{
delete
reply_task
;
}
}
)
;
}
ReplyHandler
(
const
ReplyHandler
&
)
=
delete
;
ReplyHandler
&
operator
=
(
const
ReplyHandler
&
)
=
delete
;
private
:
Impl
*
impl_
;
rtc
:
:
CriticalSection
lock_
;
}
;
Impl
(
const
char
*
queue_name
TaskQueue
*
queue
Priority
priority
)
;
~
Impl
(
)
override
;
static
TaskQueue
:
:
Impl
*
Current
(
)
;
static
TaskQueue
*
CurrentQueue
(
)
;
bool
IsCurrent
(
)
const
;
template
<
class
Closure
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
Closure
std
:
:
unique_ptr
<
QueuedTask
>
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
PostTask
(
Closure
&
&
closure
)
{
PostTask
(
NewClosure
(
std
:
:
forward
<
Closure
>
(
closure
)
)
)
;
}
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
;
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
:
:
Impl
*
reply_queue
)
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
;
void
RunPendingTasks
(
)
;
private
:
void
RunThreadMain
(
)
;
void
RunDueTasks
(
)
;
void
ScheduleNextTimer
(
)
;
template
<
typename
T
>
struct
greater
{
bool
operator
(
)
(
const
T
&
l
const
T
&
r
)
{
return
l
>
r
;
}
}
;
rtc
:
:
CriticalSection
timer_lock_
;
std
:
:
priority_queue
<
DelayedTaskInfo
std
:
:
vector
<
DelayedTaskInfo
>
greater
<
DelayedTaskInfo
>
>
timer_tasks_
RTC_GUARDED_BY
(
timer_lock_
)
;
TaskQueue
*
const
queue_
;
rtc
:
:
PlatformThread
thread_
;
rtc
:
:
CriticalSection
pending_lock_
;
std
:
:
queue
<
std
:
:
unique_ptr
<
QueuedTask
>
>
pending_
RTC_GUARDED_BY
(
pending_lock_
)
;
HANDLE
in_queue_
;
HANDLE
stop_queue_
;
HANDLE
task_timer_
;
std
:
:
shared_ptr
<
ReplyHandler
>
reply_handler_
;
}
;
TaskQueue
:
:
Impl
:
:
Impl
(
const
char
*
queue_name
TaskQueue
*
queue
Priority
priority
)
:
queue_
(
queue
)
in_queue_
(
:
:
CreateEvent
(
nullptr
true
false
nullptr
)
)
stop_queue_
(
:
:
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
)
task_timer_
(
:
:
CreateWaitableTimer
(
nullptr
FALSE
nullptr
)
)
reply_handler_
(
std
:
:
make_shared
<
ReplyHandler
>
(
)
)
{
RTC_DCHECK
(
queue_name
)
;
RTC_DCHECK
(
in_queue_
)
;
RTC_DCHECK
(
stop_queue_
)
;
RTC_DCHECK
(
task_timer_
)
;
thread_
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
RunThreadMain
(
)
;
}
queue_name
rtc
:
:
ThreadAttributes
(
)
.
SetPriority
(
priority
)
)
;
Event
event
(
false
false
)
;
ThreadStartupData
startup
=
{
&
event
this
}
;
RTC_CHECK
(
thread_
.
QueueAPC
(
&
InitializeQueueThread
reinterpret_cast
<
ULONG_PTR
>
(
&
startup
)
)
)
;
event
.
Wait
(
Event
:
:
kForever
)
;
reply_handler_
-
>
SetImpl
(
this
)
;
}
TaskQueue
:
:
Impl
:
:
~
Impl
(
)
{
RTC_DCHECK
(
!
IsCurrent
(
)
)
;
reply_handler_
-
>
SetImpl
(
nullptr
)
;
:
:
SetEvent
(
stop_queue_
)
;
thread_
.
Stop
(
)
;
:
:
CloseHandle
(
stop_queue_
)
;
:
:
CloseHandle
(
task_timer_
)
;
:
:
CloseHandle
(
in_queue_
)
;
}
TaskQueue
:
:
Impl
*
TaskQueue
:
:
Impl
:
:
Current
(
)
{
return
static_cast
<
TaskQueue
:
:
Impl
*
>
(
:
:
TlsGetValue
(
GetQueuePtrTls
(
)
)
)
;
}
TaskQueue
*
TaskQueue
:
:
Impl
:
:
CurrentQueue
(
)
{
TaskQueue
:
:
Impl
*
current
=
Current
(
)
;
return
current
?
current
-
>
queue_
:
nullptr
;
}
bool
TaskQueue
:
:
Impl
:
:
IsCurrent
(
)
const
{
return
IsThreadRefEqual
(
thread_
.
GetThreadRef
(
)
CurrentThreadRef
(
)
)
;
}
void
TaskQueue
:
:
Impl
:
:
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
{
rtc
:
:
CritScope
lock
(
&
pending_lock_
)
;
pending_
.
push
(
std
:
:
move
(
task
)
)
;
:
:
SetEvent
(
in_queue_
)
;
}
void
TaskQueue
:
:
Impl
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
{
if
(
!
milliseconds
)
{
PostTask
(
std
:
:
move
(
task
)
)
;
return
;
}
{
rtc
:
:
CritScope
lock
(
&
timer_lock_
)
;
bool
need_to_schedule_timer
=
timer_tasks_
.
empty
(
)
|
|
timer_tasks_
.
top
(
)
.
due_time
(
)
>
GetTick
(
)
+
milliseconds
;
timer_tasks_
.
emplace
(
milliseconds
std
:
:
move
(
task
)
)
;
if
(
need_to_schedule_timer
)
{
ScheduleNextTimer
(
)
;
}
}
}
void
TaskQueue
:
:
Impl
:
:
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
:
:
Impl
*
reply_queue
)
{
QueuedTask
*
task_ptr
=
task
.
release
(
)
;
QueuedTask
*
reply_task_ptr
=
reply
.
release
(
)
;
std
:
:
shared_ptr
<
ReplyHandler
>
reply_handler
=
reply_queue
-
>
reply_handler_
;
PostTask
(
[
task_ptr
reply_task_ptr
reply_handler
]
{
if
(
task_ptr
-
>
Run
(
)
)
{
delete
task_ptr
;
}
reply_handler
-
>
PostReplyTask
(
reply_task_ptr
)
;
}
)
;
}
void
TaskQueue
:
:
Impl
:
:
RunPendingTasks
(
)
{
while
(
true
)
{
std
:
:
unique_ptr
<
QueuedTask
>
task
;
{
rtc
:
:
CritScope
lock
(
&
pending_lock_
)
;
if
(
pending_
.
empty
(
)
)
{
break
;
}
task
=
std
:
:
move
(
pending_
.
front
(
)
)
;
pending_
.
pop
(
)
;
}
if
(
!
task
-
>
Run
(
)
)
{
task
.
release
(
)
;
}
}
}
void
TaskQueue
:
:
Impl
:
:
ThreadMain
(
void
*
context
)
{
static_cast
<
TaskQueue
:
:
Impl
*
>
(
context
)
-
>
RunThreadMain
(
)
;
}
void
TaskQueue
:
:
Impl
:
:
RunThreadMain
(
)
{
HANDLE
handles
[
3
]
=
{
stop_queue_
task_timer_
in_queue_
}
;
while
(
true
)
{
DWORD
result
=
:
:
WaitForMultipleObjectsEx
(
arraysize
(
handles
)
handles
FALSE
INFINITE
TRUE
)
;
RTC_CHECK_NE
(
WAIT_FAILED
result
)
;
{
rtc
:
:
CritScope
lock
(
&
timer_lock_
)
;
if
(
result
=
=
WAIT_OBJECT_0
+
1
|
|
(
!
timer_tasks_
.
empty
(
)
&
&
:
:
WaitForSingleObject
(
task_timer_
0
)
=
=
WAIT_OBJECT_0
)
)
{
RunDueTasks
(
)
;
ScheduleNextTimer
(
)
;
}
}
if
(
result
=
=
(
WAIT_OBJECT_0
+
2
)
)
{
:
:
ResetEvent
(
in_queue_
)
;
TaskQueue
:
:
Impl
:
:
Current
(
)
-
>
RunPendingTasks
(
)
;
}
if
(
result
=
=
(
WAIT_OBJECT_0
)
)
{
break
;
}
}
}
void
TaskQueue
:
:
Impl
:
:
RunDueTasks
(
)
{
RTC_DCHECK
(
!
timer_tasks_
.
empty
(
)
)
;
auto
now
=
GetTick
(
)
;
do
{
if
(
timer_tasks_
.
top
(
)
.
due_time
(
)
>
now
)
{
break
;
}
std
:
:
unique_ptr
<
QueuedTask
>
task
=
timer_tasks_
.
top
(
)
.
take
(
)
;
timer_tasks_
.
pop
(
)
;
if
(
!
task
-
>
Run
(
)
)
{
task
.
release
(
)
;
}
}
while
(
!
timer_tasks_
.
empty
(
)
)
;
}
void
TaskQueue
:
:
Impl
:
:
ScheduleNextTimer
(
)
{
RTC_DCHECK_NE
(
task_timer_
INVALID_HANDLE_VALUE
)
;
if
(
timer_tasks_
.
empty
(
)
)
{
return
;
}
LARGE_INTEGER
due_time
;
due_time
.
QuadPart
=
-
10000
*
std
:
:
max
(
0ll
timer_tasks_
.
top
(
)
.
due_time
(
)
-
GetTick
(
)
)
;
:
:
SetWaitableTimer
(
task_timer_
&
due_time
0
nullptr
nullptr
FALSE
)
;
}
TaskQueue
:
:
TaskQueue
(
const
char
*
queue_name
Priority
priority
)
:
impl_
(
new
RefCountedObject
<
TaskQueue
:
:
Impl
>
(
queue_name
this
priority
)
)
{
}
TaskQueue
:
:
~
TaskQueue
(
)
{
}
TaskQueue
*
TaskQueue
:
:
Current
(
)
{
return
TaskQueue
:
:
Impl
:
:
CurrentQueue
(
)
;
}
bool
TaskQueue
:
:
IsCurrent
(
)
const
{
return
impl_
-
>
IsCurrent
(
)
;
}
void
TaskQueue
:
:
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
{
return
TaskQueue
:
:
impl_
-
>
PostTask
(
std
:
:
move
(
task
)
)
;
}
void
TaskQueue
:
:
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
*
reply_queue
)
{
return
TaskQueue
:
:
impl_
-
>
PostTaskAndReply
(
std
:
:
move
(
task
)
std
:
:
move
(
reply
)
reply_queue
-
>
impl_
.
get
(
)
)
;
}
void
TaskQueue
:
:
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
{
return
TaskQueue
:
:
impl_
-
>
PostTaskAndReply
(
std
:
:
move
(
task
)
std
:
:
move
(
reply
)
impl_
.
get
(
)
)
;
}
void
TaskQueue
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
{
return
TaskQueue
:
:
impl_
-
>
PostDelayedTask
(
std
:
:
move
(
task
)
milliseconds
)
;
}
}
