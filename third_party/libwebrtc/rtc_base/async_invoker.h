#
ifndef
RTC_BASE_ASYNC_INVOKER_H_
#
define
RTC_BASE_ASYNC_INVOKER_H_
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
rtc_base
/
async_invoker_inl
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
ref_counted_object
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
rtc
{
class
AsyncInvoker
:
public
MessageHandlerAutoCleanup
{
public
:
AsyncInvoker
(
)
;
~
AsyncInvoker
(
)
override
;
template
<
class
ReturnT
class
FunctorT
>
void
AsyncInvoke
(
const
Location
&
posted_from
Thread
*
thread
FunctorT
&
&
functor
uint32_t
id
=
0
)
{
std
:
:
unique_ptr
<
AsyncClosure
>
closure
(
new
FireAndForgetAsyncClosure
<
FunctorT
>
(
this
std
:
:
forward
<
FunctorT
>
(
functor
)
)
)
;
DoInvoke
(
posted_from
thread
std
:
:
move
(
closure
)
id
)
;
}
template
<
class
ReturnT
class
FunctorT
>
void
AsyncInvokeDelayed
(
const
Location
&
posted_from
Thread
*
thread
FunctorT
&
&
functor
uint32_t
delay_ms
uint32_t
id
=
0
)
{
std
:
:
unique_ptr
<
AsyncClosure
>
closure
(
new
FireAndForgetAsyncClosure
<
FunctorT
>
(
this
std
:
:
forward
<
FunctorT
>
(
functor
)
)
)
;
DoInvokeDelayed
(
posted_from
thread
std
:
:
move
(
closure
)
delay_ms
id
)
;
}
void
Flush
(
Thread
*
thread
uint32_t
id
=
MQID_ANY
)
;
void
Clear
(
)
;
private
:
void
OnMessage
(
Message
*
msg
)
override
;
void
DoInvoke
(
const
Location
&
posted_from
Thread
*
thread
std
:
:
unique_ptr
<
AsyncClosure
>
closure
uint32_t
id
)
;
void
DoInvokeDelayed
(
const
Location
&
posted_from
Thread
*
thread
std
:
:
unique_ptr
<
AsyncClosure
>
closure
uint32_t
delay_ms
uint32_t
id
)
;
std
:
:
atomic
<
int
>
pending_invocations_
;
scoped_refptr
<
RefCountedObject
<
Event
>
>
invocation_complete_
;
std
:
:
atomic
<
bool
>
destroying_
;
friend
class
AsyncClosure
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AsyncInvoker
)
;
}
;
}
#
endif
