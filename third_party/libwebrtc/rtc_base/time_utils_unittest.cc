#
include
"
rtc_base
/
time_utils
.
h
"
#
include
<
memory
>
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
helpers
.
h
"
#
include
"
rtc_base
/
message_handler
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
rtc
{
using
:
:
webrtc
:
:
TimeDelta
;
TEST
(
TimeTest
TimeInMs
)
{
int64_t
ts_earlier
=
TimeMillis
(
)
;
Thread
:
:
SleepMs
(
100
)
;
int64_t
ts_now
=
TimeMillis
(
)
;
EXPECT_GE
(
ts_now
ts_earlier
+
80
)
;
EXPECT_LT
(
ts_now
ts_earlier
+
1000
)
;
}
TEST
(
TimeTest
Intervals
)
{
int64_t
ts_earlier
=
TimeMillis
(
)
;
int64_t
ts_later
=
TimeAfter
(
500
)
;
EXPECT_LE
(
500
TimeDiff
(
ts_later
ts_earlier
)
)
;
EXPECT_GE
(
-
500
TimeDiff
(
ts_earlier
ts_later
)
)
;
EXPECT_GE
(
TimeSince
(
ts_earlier
)
0
)
;
EXPECT_LE
(
TimeUntil
(
ts_earlier
)
0
)
;
EXPECT_GE
(
TimeSince
(
ts_later
)
-
500
)
;
EXPECT_LE
(
TimeUntil
(
ts_later
)
500
)
;
}
TEST
(
TimeTest
TestTimeDiff64
)
{
int64_t
ts_diff
=
100
;
int64_t
ts_earlier
=
rtc
:
:
TimeMillis
(
)
;
int64_t
ts_later
=
ts_earlier
+
ts_diff
;
EXPECT_EQ
(
ts_diff
rtc
:
:
TimeDiff
(
ts_later
ts_earlier
)
)
;
EXPECT_EQ
(
-
ts_diff
rtc
:
:
TimeDiff
(
ts_earlier
ts_later
)
)
;
}
class
TimestampWrapAroundHandlerTest
:
public
:
:
testing
:
:
Test
{
public
:
TimestampWrapAroundHandlerTest
(
)
{
}
protected
:
TimestampWrapAroundHandler
wraparound_handler_
;
}
;
TEST_F
(
TimestampWrapAroundHandlerTest
Unwrap
)
{
int64_t
ts
=
2
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
ts
=
-
2
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
ts
=
2
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
=
0xf
;
+
+
i
)
{
ts
=
(
i
<
<
28
)
+
0x0fffffff
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
}
ts
+
=
2
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
ts
-
=
0x0fffffff
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
ts
+
=
0x0fffffff
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
}
TEST_F
(
TimestampWrapAroundHandlerTest
NoNegativeStart
)
{
int64_t
ts
=
0xfffffff0
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
static_cast
<
uint32_t
>
(
ts
&
0xffffffff
)
)
)
;
}
class
TmToSeconds
:
public
:
:
testing
:
:
Test
{
public
:
TmToSeconds
(
)
{
rtc
:
:
SetRandomTestMode
(
true
)
;
}
~
TmToSeconds
(
)
override
{
rtc
:
:
SetRandomTestMode
(
false
)
;
}
void
TestTmToSeconds
(
int
times
)
{
static
char
mdays
[
12
]
=
{
31
28
31
30
31
30
31
31
30
31
30
31
}
;
for
(
int
i
=
0
;
i
<
times
;
i
+
+
)
{
int
year
=
rtc
:
:
CreateRandomId
(
)
%
400
+
1970
;
bool
leap_year
=
false
;
if
(
year
%
4
=
=
0
)
leap_year
=
true
;
if
(
year
%
100
=
=
0
)
leap_year
=
false
;
if
(
year
%
400
=
=
0
)
leap_year
=
true
;
std
:
:
tm
tm
;
tm
.
tm_year
=
year
-
1900
;
tm
.
tm_mon
=
rtc
:
:
CreateRandomId
(
)
%
12
;
tm
.
tm_mday
=
rtc
:
:
CreateRandomId
(
)
%
mdays
[
tm
.
tm_mon
]
+
1
;
tm
.
tm_hour
=
rtc
:
:
CreateRandomId
(
)
%
24
;
tm
.
tm_min
=
rtc
:
:
CreateRandomId
(
)
%
60
;
tm
.
tm_sec
=
rtc
:
:
CreateRandomId
(
)
%
60
;
int64_t
t
=
rtc
:
:
TmToSeconds
(
tm
)
;
EXPECT_TRUE
(
t
>
=
0
)
;
switch
(
rtc
:
:
CreateRandomId
(
)
%
11
)
{
case
0
:
tm
.
tm_year
=
1969
-
1900
;
break
;
case
1
:
tm
.
tm_mon
=
-
1
;
break
;
case
2
:
tm
.
tm_mon
=
12
;
break
;
case
3
:
tm
.
tm_mday
=
0
;
break
;
case
4
:
tm
.
tm_mday
=
mdays
[
tm
.
tm_mon
]
+
(
leap_year
&
&
tm
.
tm_mon
=
=
1
)
+
1
;
break
;
case
5
:
tm
.
tm_hour
=
-
1
;
break
;
case
6
:
tm
.
tm_hour
=
24
;
break
;
case
7
:
tm
.
tm_min
=
-
1
;
break
;
case
8
:
tm
.
tm_min
=
60
;
break
;
case
9
:
tm
.
tm_sec
=
-
1
;
break
;
case
10
:
tm
.
tm_sec
=
60
;
break
;
}
EXPECT_EQ
(
rtc
:
:
TmToSeconds
(
tm
)
-
1
)
;
}
for
(
int
i
=
0
;
i
<
times
;
i
+
+
)
{
time_t
t
=
rtc
:
:
CreateRandomId
(
)
%
0x80000000
;
#
if
defined
(
WEBRTC_WIN
)
std
:
:
tm
*
tm
=
std
:
:
gmtime
(
&
t
)
;
EXPECT_TRUE
(
tm
)
;
EXPECT_TRUE
(
rtc
:
:
TmToSeconds
(
*
tm
)
=
=
t
)
;
#
else
std
:
:
tm
tm
;
EXPECT_TRUE
(
gmtime_r
(
&
t
&
tm
)
)
;
EXPECT_TRUE
(
rtc
:
:
TmToSeconds
(
tm
)
=
=
t
)
;
#
endif
}
}
}
;
TEST_F
(
TmToSeconds
TestTmToSeconds
)
{
TestTmToSeconds
(
100000
)
;
}
TEST
(
FakeClock
TimeFunctionsUseFakeClock
)
{
FakeClock
clock
;
SetClockForTesting
(
&
clock
)
;
clock
.
SetTime
(
webrtc
:
:
Timestamp
:
:
Micros
(
987654
)
)
;
EXPECT_EQ
(
987u
Time32
(
)
)
;
EXPECT_EQ
(
987
TimeMillis
(
)
)
;
EXPECT_EQ
(
987654
TimeMicros
(
)
)
;
EXPECT_EQ
(
987654000
TimeNanos
(
)
)
;
EXPECT_EQ
(
1000u
TimeAfter
(
13
)
)
;
SetClockForTesting
(
nullptr
)
;
EXPECT_NE
(
987
TimeMillis
(
)
)
;
}
TEST
(
FakeClock
InitialTime
)
{
FakeClock
clock
;
EXPECT_EQ
(
0
clock
.
TimeNanos
(
)
)
;
}
TEST
(
FakeClock
SetTime
)
{
FakeClock
clock
;
clock
.
SetTime
(
webrtc
:
:
Timestamp
:
:
Micros
(
123
)
)
;
EXPECT_EQ
(
123000
clock
.
TimeNanos
(
)
)
;
clock
.
SetTime
(
webrtc
:
:
Timestamp
:
:
Micros
(
456
)
)
;
EXPECT_EQ
(
456000
clock
.
TimeNanos
(
)
)
;
}
TEST
(
FakeClock
AdvanceTime
)
{
FakeClock
clock
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Micros
(
1u
)
)
;
EXPECT_EQ
(
1000
clock
.
TimeNanos
(
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Micros
(
2222u
)
)
;
EXPECT_EQ
(
2223000
clock
.
TimeNanos
(
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Millis
(
3333u
)
)
;
EXPECT_EQ
(
3335223000
clock
.
TimeNanos
(
)
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
4444u
)
)
;
EXPECT_EQ
(
4447335223000
clock
.
TimeNanos
(
)
)
;
}
TEST
(
FakeClock
SettingTimeWakesThreads
)
{
int64_t
real_start_time_ms
=
TimeMillis
(
)
;
ThreadProcessingFakeClock
clock
;
SetClockForTesting
(
&
clock
)
;
std
:
:
unique_ptr
<
Thread
>
worker
(
Thread
:
:
CreateWithSocketServer
(
)
)
;
worker
-
>
Start
(
)
;
Event
message_handler_dispatched
;
worker
-
>
PostDelayedTask
(
[
&
message_handler_dispatched
]
{
message_handler_dispatched
.
Set
(
)
;
}
TimeDelta
:
:
Seconds
(
60
)
)
;
Thread
:
:
Current
(
)
-
>
SleepMs
(
1000
)
;
clock
.
AdvanceTime
(
webrtc
:
:
TimeDelta
:
:
Seconds
(
60u
)
)
;
EXPECT_TRUE
(
message_handler_dispatched
.
Wait
(
webrtc
:
:
TimeDelta
:
:
Zero
(
)
)
)
;
worker
-
>
Stop
(
)
;
SetClockForTesting
(
nullptr
)
;
int64_t
real_end_time_ms
=
TimeMillis
(
)
;
EXPECT_LT
(
real_end_time_ms
-
real_start_time_ms
10000
)
;
}
}
