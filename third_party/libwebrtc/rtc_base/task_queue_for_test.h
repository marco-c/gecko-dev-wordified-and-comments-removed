#
ifndef
RTC_BASE_TASK_QUEUE_FOR_TEST_H_
#
define
RTC_BASE_TASK_QUEUE_FOR_TEST_H_
#
include
<
utility
>
#
include
"
absl
/
cleanup
/
cleanup
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
function_view
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
inline
void
SendTask
(
TaskQueueBase
*
task_queue
rtc
:
:
FunctionView
<
void
(
)
>
task
)
{
if
(
task_queue
-
>
IsCurrent
(
)
)
{
task
(
)
;
return
;
}
rtc
:
:
Event
event
;
absl
:
:
Cleanup
cleanup
=
[
&
event
]
{
event
.
Set
(
)
;
}
;
task_queue
-
>
PostTask
(
[
task
cleanup
=
std
:
:
move
(
cleanup
)
]
{
task
(
)
;
}
)
;
RTC_CHECK
(
event
.
Wait
(
rtc
:
:
Event
:
:
kForever
TimeDelta
:
:
Seconds
(
10
)
)
)
;
}
class
RTC_LOCKABLE
TaskQueueForTest
:
public
rtc
:
:
TaskQueue
{
public
:
using
rtc
:
:
TaskQueue
:
:
TaskQueue
;
explicit
TaskQueueForTest
(
absl
:
:
string_view
name
=
"
TestQueue
"
Priority
priority
=
Priority
:
:
NORMAL
)
;
TaskQueueForTest
(
const
TaskQueueForTest
&
)
=
delete
;
TaskQueueForTest
&
operator
=
(
const
TaskQueueForTest
&
)
=
delete
;
~
TaskQueueForTest
(
)
=
default
;
void
SendTask
(
rtc
:
:
FunctionView
<
void
(
)
>
task
)
{
:
:
webrtc
:
:
SendTask
(
Get
(
)
task
)
;
}
void
WaitForPreviouslyPostedTasks
(
)
{
RTC_DCHECK
(
!
Get
(
)
-
>
IsCurrent
(
)
)
;
SendTask
(
[
]
(
)
{
}
)
;
}
}
;
}
#
endif
