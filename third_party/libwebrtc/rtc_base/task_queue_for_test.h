#
ifndef
RTC_BASE_TASK_QUEUE_FOR_TEST_H_
#
define
RTC_BASE_TASK_QUEUE_FOR_TEST_H_
#
include
<
utility
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
task_queue
/
to_queued_task
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
template
<
typename
Closure
>
void
SendTask
(
rtc
:
:
Location
loc
TaskQueueBase
*
task_queue
Closure
&
&
task
)
{
RTC_CHECK
(
!
task_queue
-
>
IsCurrent
(
)
)
<
<
"
Called
SendTask
to
a
queue
from
the
same
queue
at
"
<
<
loc
.
ToString
(
)
;
rtc
:
:
Event
event
;
task_queue
-
>
PostTask
(
ToQueuedTask
(
std
:
:
forward
<
Closure
>
(
task
)
[
&
event
]
{
event
.
Set
(
)
;
}
)
)
;
RTC_CHECK
(
event
.
Wait
(
rtc
:
:
Event
:
:
kForever
10
'
000
)
)
<
<
"
Waited
too
long
at
"
<
<
loc
.
ToString
(
)
;
}
class
RTC_LOCKABLE
TaskQueueForTest
:
public
rtc
:
:
TaskQueue
{
public
:
using
rtc
:
:
TaskQueue
:
:
TaskQueue
;
explicit
TaskQueueForTest
(
absl
:
:
string_view
name
=
"
TestQueue
"
Priority
priority
=
Priority
:
:
NORMAL
)
;
TaskQueueForTest
(
const
TaskQueueForTest
&
)
=
delete
;
TaskQueueForTest
&
operator
=
(
const
TaskQueueForTest
&
)
=
delete
;
~
TaskQueueForTest
(
)
=
default
;
template
<
class
Closure
>
void
SendTask
(
Closure
*
task
)
{
RTC_CHECK
(
!
IsCurrent
(
)
)
;
rtc
:
:
Event
event
;
PostTask
(
ToQueuedTask
(
[
&
task
]
{
RTC_CHECK_EQ
(
false
static_cast
<
QueuedTask
*
>
(
task
)
-
>
Run
(
)
)
;
}
[
&
event
]
{
event
.
Set
(
)
;
}
)
)
;
event
.
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
}
template
<
class
Closure
>
void
SendTask
(
Closure
&
&
task
rtc
:
:
Location
loc
)
{
:
:
webrtc
:
:
SendTask
(
loc
Get
(
)
std
:
:
forward
<
Closure
>
(
task
)
)
;
}
void
WaitForPreviouslyPostedTasks
(
)
{
SendTask
(
[
]
(
)
{
}
RTC_FROM_HERE
)
;
}
}
;
}
#
endif
