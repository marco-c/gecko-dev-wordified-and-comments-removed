#
ifndef
RTC_BASE_OPERATIONS_CHAIN_H_
#
define
RTC_BASE_OPERATIONS_CHAIN_H_
#
include
<
functional
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
queue
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
api
/
ref_counted_base
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
namespace
rtc_operations_chain_internal
{
class
Operation
{
public
:
virtual
~
Operation
(
)
{
}
virtual
void
Run
(
)
=
0
;
}
;
template
<
typename
FunctorT
>
class
OperationWithFunctor
final
:
public
Operation
{
public
:
OperationWithFunctor
(
FunctorT
&
&
functor
std
:
:
function
<
void
(
)
>
callback
)
:
functor_
(
std
:
:
forward
<
FunctorT
>
(
functor
)
)
callback_
(
std
:
:
move
(
callback
)
)
{
}
~
OperationWithFunctor
(
)
override
{
#
if
RTC_DCHECK_IS_ON
RTC_DCHECK
(
has_run_
)
;
#
endif
}
void
Run
(
)
override
{
#
if
RTC_DCHECK_IS_ON
RTC_DCHECK
(
!
has_run_
)
;
has_run_
=
true
;
#
endif
auto
functor
=
std
:
:
move
(
functor_
)
;
functor
(
std
:
:
move
(
callback_
)
)
;
}
private
:
typename
std
:
:
remove_reference
<
FunctorT
>
:
:
type
functor_
;
std
:
:
function
<
void
(
)
>
callback_
;
#
if
RTC_DCHECK_IS_ON
bool
has_run_
=
false
;
#
endif
}
;
}
class
OperationsChain
final
:
public
RefCountedNonVirtual
<
OperationsChain
>
{
public
:
static
scoped_refptr
<
OperationsChain
>
Create
(
)
;
~
OperationsChain
(
)
;
OperationsChain
(
const
OperationsChain
&
)
=
delete
;
OperationsChain
&
operator
=
(
const
OperationsChain
&
)
=
delete
;
void
SetOnChainEmptyCallback
(
std
:
:
function
<
void
(
)
>
on_chain_empty_callback
)
;
bool
IsEmpty
(
)
const
;
template
<
typename
FunctorT
>
void
ChainOperation
(
FunctorT
&
&
functor
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
chained_operations_
.
push
(
std
:
:
make_unique
<
rtc_operations_chain_internal
:
:
OperationWithFunctor
<
FunctorT
>
>
(
std
:
:
forward
<
FunctorT
>
(
functor
)
CreateOperationsChainCallback
(
)
)
)
;
if
(
chained_operations_
.
size
(
)
=
=
1
)
{
chained_operations_
.
front
(
)
-
>
Run
(
)
;
}
}
private
:
friend
class
CallbackHandle
;
class
CallbackHandle
final
:
public
RefCountedNonVirtual
<
CallbackHandle
>
{
public
:
explicit
CallbackHandle
(
scoped_refptr
<
OperationsChain
>
operations_chain
)
;
~
CallbackHandle
(
)
;
CallbackHandle
(
const
CallbackHandle
&
)
=
delete
;
CallbackHandle
&
operator
=
(
const
CallbackHandle
&
)
=
delete
;
void
OnOperationComplete
(
)
;
private
:
scoped_refptr
<
OperationsChain
>
operations_chain_
;
#
if
RTC_DCHECK_IS_ON
bool
has_run_
=
false
;
#
endif
}
;
OperationsChain
(
)
;
std
:
:
function
<
void
(
)
>
CreateOperationsChainCallback
(
)
;
void
OnOperationComplete
(
)
;
RTC_NO_UNIQUE_ADDRESS
SequenceChecker
sequence_checker_
;
std
:
:
queue
<
std
:
:
unique_ptr
<
rtc_operations_chain_internal
:
:
Operation
>
>
chained_operations_
RTC_GUARDED_BY
(
sequence_checker_
)
;
std
:
:
optional
<
std
:
:
function
<
void
(
)
>
>
on_chain_empty_callback_
RTC_GUARDED_BY
(
sequence_checker_
)
;
}
;
}
namespace
rtc
{
using
:
:
webrtc
:
:
OperationsChain
;
}
#
endif
