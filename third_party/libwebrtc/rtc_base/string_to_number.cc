#
include
"
rtc_base
/
string_to_number
.
h
"
#
include
<
ctype
.
h
>
#
include
<
cerrno
>
#
include
<
cstdlib
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
webrtc
{
namespace
string_to_number_internal
{
std
:
:
optional
<
signed_type
>
ParseSigned
(
absl
:
:
string_view
str
int
base
)
{
if
(
str
.
empty
(
)
)
return
std
:
:
nullopt
;
if
(
isdigit
(
static_cast
<
unsigned
char
>
(
str
[
0
]
)
)
|
|
str
[
0
]
=
=
'
-
'
)
{
std
:
:
string
str_str
(
str
)
;
char
*
end
=
nullptr
;
errno
=
0
;
const
signed_type
value
=
std
:
:
strtoll
(
str_str
.
c_str
(
)
&
end
base
)
;
if
(
end
=
=
str_str
.
c_str
(
)
+
str_str
.
size
(
)
&
&
errno
=
=
0
)
{
return
value
;
}
}
return
std
:
:
nullopt
;
}
std
:
:
optional
<
unsigned_type
>
ParseUnsigned
(
absl
:
:
string_view
str
int
base
)
{
if
(
str
.
empty
(
)
)
return
std
:
:
nullopt
;
if
(
isdigit
(
static_cast
<
unsigned
char
>
(
str
[
0
]
)
)
|
|
str
[
0
]
=
=
'
-
'
)
{
std
:
:
string
str_str
(
str
)
;
const
bool
is_negative
=
str
[
0
]
=
=
'
-
'
;
char
*
end
=
nullptr
;
errno
=
0
;
const
unsigned_type
value
=
std
:
:
strtoull
(
str_str
.
c_str
(
)
&
end
base
)
;
if
(
end
=
=
str_str
.
c_str
(
)
+
str_str
.
size
(
)
&
&
errno
=
=
0
&
&
(
value
=
=
0
|
|
!
is_negative
)
)
{
return
value
;
}
}
return
std
:
:
nullopt
;
}
template
<
typename
T
>
T
StrToT
(
const
char
*
str
char
*
*
str_end
)
;
template
<
>
inline
float
StrToT
(
const
char
*
str
char
*
*
str_end
)
{
return
std
:
:
strtof
(
str
str_end
)
;
}
template
<
>
inline
double
StrToT
(
const
char
*
str
char
*
*
str_end
)
{
return
std
:
:
strtod
(
str
str_end
)
;
}
template
<
>
inline
long
double
StrToT
(
const
char
*
str
char
*
*
str_end
)
{
return
std
:
:
strtold
(
str
str_end
)
;
}
template
<
typename
T
>
std
:
:
optional
<
T
>
ParseFloatingPoint
(
absl
:
:
string_view
str
)
{
if
(
str
.
empty
(
)
)
return
std
:
:
nullopt
;
if
(
str
[
0
]
=
=
'
\
0
'
)
return
std
:
:
nullopt
;
std
:
:
string
str_str
(
str
)
;
char
*
end
=
nullptr
;
errno
=
0
;
const
T
value
=
StrToT
<
T
>
(
str_str
.
c_str
(
)
&
end
)
;
if
(
end
=
=
str_str
.
c_str
(
)
+
str_str
.
size
(
)
&
&
errno
=
=
0
)
{
return
value
;
}
return
std
:
:
nullopt
;
}
template
std
:
:
optional
<
float
>
ParseFloatingPoint
(
absl
:
:
string_view
str
)
;
template
std
:
:
optional
<
double
>
ParseFloatingPoint
(
absl
:
:
string_view
str
)
;
template
std
:
:
optional
<
long
double
>
ParseFloatingPoint
(
absl
:
:
string_view
str
)
;
}
}
