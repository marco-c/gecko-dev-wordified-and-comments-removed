#
ifndef
RTC_BASE_SANITIZER_H_
#
define
RTC_BASE_SANITIZER_H_
#
include
<
stddef
.
h
>
#
ifdef
__cplusplus
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
endif
#
if
defined
(
__has_feature
)
#
if
__has_feature
(
address_sanitizer
)
#
define
RTC_HAS_ASAN
1
#
endif
#
if
__has_feature
(
memory_sanitizer
)
#
define
RTC_HAS_MSAN
1
#
endif
#
endif
#
ifndef
RTC_HAS_ASAN
#
define
RTC_HAS_ASAN
0
#
endif
#
ifndef
RTC_HAS_MSAN
#
define
RTC_HAS_MSAN
0
#
endif
#
if
RTC_HAS_ASAN
#
include
<
sanitizer
/
asan_interface
.
h
>
#
endif
#
if
RTC_HAS_MSAN
#
include
<
sanitizer
/
msan_interface
.
h
>
#
endif
#
ifdef
__has_attribute
#
if
__has_attribute
(
no_sanitize
)
#
define
RTC_NO_SANITIZE
(
what
)
__attribute__
(
(
no_sanitize
(
what
)
)
)
#
endif
#
endif
#
ifndef
RTC_NO_SANITIZE
#
define
RTC_NO_SANITIZE
(
what
)
#
endif
static
inline
void
rtc_AsanPoison
(
const
volatile
void
*
ptr
size_t
element_size
size_t
num_elements
)
{
#
if
RTC_HAS_ASAN
ASAN_POISON_MEMORY_REGION
(
ptr
element_size
*
num_elements
)
;
#
else
(
void
)
ptr
;
(
void
)
element_size
;
(
void
)
num_elements
;
#
endif
}
static
inline
void
rtc_AsanUnpoison
(
const
volatile
void
*
ptr
size_t
element_size
size_t
num_elements
)
{
#
if
RTC_HAS_ASAN
ASAN_UNPOISON_MEMORY_REGION
(
ptr
element_size
*
num_elements
)
;
#
else
(
void
)
ptr
;
(
void
)
element_size
;
(
void
)
num_elements
;
#
endif
}
static
inline
void
rtc_MsanMarkUninitialized
(
const
volatile
void
*
ptr
size_t
element_size
size_t
num_elements
)
{
#
if
RTC_HAS_MSAN
__msan_poison
(
ptr
element_size
*
num_elements
)
;
#
else
(
void
)
ptr
;
(
void
)
element_size
;
(
void
)
num_elements
;
#
endif
}
static
inline
void
rtc_MsanCheckInitialized
(
const
volatile
void
*
ptr
size_t
element_size
size_t
num_elements
)
{
#
if
RTC_HAS_MSAN
__msan_check_mem_is_initialized
(
ptr
element_size
*
num_elements
)
;
#
else
(
void
)
ptr
;
(
void
)
element_size
;
(
void
)
num_elements
;
#
endif
}
#
ifdef
__cplusplus
namespace
rtc
{
namespace
sanitizer_impl
{
template
<
typename
T
>
constexpr
bool
IsTriviallyCopyable
(
)
{
return
static_cast
<
bool
>
(
absl
:
:
is_trivially_copy_constructible
<
T
>
:
:
value
&
&
(
absl
:
:
is_trivially_copy_assignable
<
T
>
:
:
value
|
|
!
std
:
:
is_copy_assignable
<
T
>
:
:
value
)
&
&
absl
:
:
is_trivially_destructible
<
T
>
:
:
value
)
;
}
}
template
<
typename
T
>
inline
void
AsanPoison
(
const
T
&
mem
)
{
rtc_AsanPoison
(
mem
.
data
(
)
sizeof
(
mem
.
data
(
)
[
0
]
)
mem
.
size
(
)
)
;
}
template
<
typename
T
>
inline
void
AsanUnpoison
(
const
T
&
mem
)
{
rtc_AsanUnpoison
(
mem
.
data
(
)
sizeof
(
mem
.
data
(
)
[
0
]
)
mem
.
size
(
)
)
;
}
template
<
typename
T
>
inline
void
MsanMarkUninitialized
(
const
T
&
mem
)
{
rtc_MsanMarkUninitialized
(
mem
.
data
(
)
sizeof
(
mem
.
data
(
)
[
0
]
)
mem
.
size
(
)
)
;
}
template
<
typename
T
>
inline
T
MsanUninitialized
(
T
t
)
{
#
if
RTC_HAS_MSAN
static_assert
(
sanitizer_impl
:
:
IsTriviallyCopyable
<
T
>
(
)
"
"
)
;
#
endif
rtc_MsanMarkUninitialized
(
&
t
sizeof
(
T
)
1
)
;
return
t
;
}
template
<
typename
T
>
inline
void
MsanCheckInitialized
(
const
T
&
mem
)
{
rtc_MsanCheckInitialized
(
mem
.
data
(
)
sizeof
(
mem
.
data
(
)
[
0
]
)
mem
.
size
(
)
)
;
}
}
#
endif
#
endif
