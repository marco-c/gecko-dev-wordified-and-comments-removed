#
include
"
rtc_base
/
unique_id_generator
.
h
"
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
string_to_number
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
webrtc
{
UniqueRandomIdGenerator
:
:
UniqueRandomIdGenerator
(
)
:
known_ids_
(
)
{
}
UniqueRandomIdGenerator
:
:
UniqueRandomIdGenerator
(
ArrayView
<
uint32_t
>
known_ids
)
:
known_ids_
(
known_ids
.
begin
(
)
known_ids
.
end
(
)
)
{
}
UniqueRandomIdGenerator
:
:
~
UniqueRandomIdGenerator
(
)
=
default
;
uint32_t
UniqueRandomIdGenerator
:
:
GenerateId
(
)
{
MutexLock
lock
(
&
mutex_
)
;
RTC_CHECK_LT
(
known_ids_
.
size
(
)
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
1
)
;
while
(
true
)
{
auto
pair
=
known_ids_
.
insert
(
CreateRandomNonZeroId
(
)
)
;
if
(
pair
.
second
)
{
return
*
pair
.
first
;
}
}
}
bool
UniqueRandomIdGenerator
:
:
AddKnownId
(
uint32_t
value
)
{
MutexLock
lock
(
&
mutex_
)
;
return
known_ids_
.
insert
(
value
)
.
second
;
}
UniqueStringGenerator
:
:
UniqueStringGenerator
(
)
:
unique_number_generator_
(
)
{
}
UniqueStringGenerator
:
:
UniqueStringGenerator
(
ArrayView
<
std
:
:
string
>
known_ids
)
{
for
(
const
std
:
:
string
&
str
:
known_ids
)
{
AddKnownId
(
str
)
;
}
}
UniqueStringGenerator
:
:
~
UniqueStringGenerator
(
)
=
default
;
std
:
:
string
UniqueStringGenerator
:
:
GenerateString
(
)
{
return
absl
:
:
StrCat
(
unique_number_generator_
.
GenerateNumber
(
)
)
;
}
bool
UniqueStringGenerator
:
:
AddKnownId
(
absl
:
:
string_view
value
)
{
std
:
:
optional
<
uint32_t
>
int_value
=
StringToNumber
<
uint32_t
>
(
std
:
:
string
(
value
)
)
;
if
(
int_value
.
has_value
(
)
)
{
return
unique_number_generator_
.
AddKnownId
(
int_value
.
value
(
)
)
;
}
return
false
;
}
}
