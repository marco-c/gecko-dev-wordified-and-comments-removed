#
ifndef
RTC_BASE_RTC_CERTIFICATE_GENERATOR_H_
#
define
RTC_BASE_RTC_CERTIFICATE_GENERATOR_H_
#
include
<
stdint
.
h
>
#
include
<
optional
>
#
include
"
absl
/
functional
/
any_invocable
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
rtc_base
/
rtc_certificate
.
h
"
#
include
"
rtc_base
/
ssl_identity
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
class
RTCCertificateGeneratorInterface
{
public
:
using
Callback
=
absl
:
:
AnyInvocable
<
void
(
scoped_refptr
<
webrtc
:
:
RTCCertificate
>
)
&
&
>
;
virtual
~
RTCCertificateGeneratorInterface
(
)
=
default
;
virtual
void
GenerateCertificateAsync
(
const
rtc
:
:
KeyParams
&
key_params
const
std
:
:
optional
<
uint64_t
>
&
expires_ms
Callback
callback
)
=
0
;
}
;
class
RTC_EXPORT
RTCCertificateGenerator
:
public
RTCCertificateGeneratorInterface
{
public
:
static
scoped_refptr
<
RTCCertificate
>
GenerateCertificate
(
const
rtc
:
:
KeyParams
&
key_params
const
std
:
:
optional
<
uint64_t
>
&
expires_ms
)
;
RTCCertificateGenerator
(
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
Thread
*
worker_thread
)
;
~
RTCCertificateGenerator
(
)
override
{
}
void
GenerateCertificateAsync
(
const
rtc
:
:
KeyParams
&
key_params
const
std
:
:
optional
<
uint64_t
>
&
expires_ms
Callback
callback
)
override
;
private
:
rtc
:
:
Thread
*
const
signaling_thread_
;
rtc
:
:
Thread
*
const
worker_thread_
;
}
;
}
namespace
rtc
{
using
:
:
webrtc
:
:
RTCCertificateGenerator
;
using
:
:
webrtc
:
:
RTCCertificateGeneratorInterface
;
}
#
endif
