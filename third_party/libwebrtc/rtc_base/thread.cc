#
include
"
rtc_base
/
thread
.
h
"
#
if
defined
(
WEBRTC_WIN
)
#
include
<
comdef
.
h
>
#
elif
defined
(
WEBRTC_POSIX
)
#
include
<
time
.
h
>
#
else
#
error
"
Either
WEBRTC_WIN
or
WEBRTC_POSIX
needs
to
be
defined
.
"
#
endif
#
if
defined
(
WEBRTC_WIN
)
#
pragma
warning
(
disable
:
4722
)
#
endif
#
include
<
stdio
.
h
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
rtc_base
/
atomic_ops
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
deprecated
/
recursive_critical_section
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
internal
/
default_socket_server
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
null_socket_server
.
h
"
#
include
"
rtc_base
/
synchronization
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
task_utils
/
to_queued_task
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
#
if
defined
(
WEBRTC_MAC
)
#
include
"
rtc_base
/
system
/
cocoa_threading
.
h
"
extern
"
C
"
{
void
*
objc_autoreleasePoolPush
(
void
)
;
void
objc_autoreleasePoolPop
(
void
*
pool
)
;
}
namespace
{
class
ScopedAutoReleasePool
{
public
:
ScopedAutoReleasePool
(
)
:
pool_
(
objc_autoreleasePoolPush
(
)
)
{
}
~
ScopedAutoReleasePool
(
)
{
objc_autoreleasePoolPop
(
pool_
)
;
}
private
:
void
*
const
pool_
;
}
;
}
#
endif
namespace
rtc
{
namespace
{
class
MessageHandlerWithTask
final
:
public
MessageHandler
{
public
:
MessageHandlerWithTask
(
)
{
}
void
OnMessage
(
Message
*
msg
)
override
{
static_cast
<
rtc_thread_internal
:
:
MessageLikeTask
*
>
(
msg
-
>
pdata
)
-
>
Run
(
)
;
delete
msg
-
>
pdata
;
}
private
:
~
MessageHandlerWithTask
(
)
override
{
}
RTC_DISALLOW_COPY_AND_ASSIGN
(
MessageHandlerWithTask
)
;
}
;
class
RTC_SCOPED_LOCKABLE
MarkProcessingCritScope
{
public
:
MarkProcessingCritScope
(
const
RecursiveCriticalSection
*
cs
size_t
*
processing
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
cs
)
:
cs_
(
cs
)
processing_
(
processing
)
{
cs_
-
>
Enter
(
)
;
*
processing_
+
=
1
;
}
~
MarkProcessingCritScope
(
)
RTC_UNLOCK_FUNCTION
(
)
{
*
processing_
-
=
1
;
cs_
-
>
Leave
(
)
;
}
private
:
const
RecursiveCriticalSection
*
const
cs_
;
size_t
*
processing_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
MarkProcessingCritScope
)
;
}
;
}
ThreadManager
*
ThreadManager
:
:
Instance
(
)
{
static
ThreadManager
*
const
thread_manager
=
new
ThreadManager
(
)
;
return
thread_manager
;
}
ThreadManager
:
:
~
ThreadManager
(
)
{
RTC_NOTREACHED
(
)
<
<
"
ThreadManager
should
never
be
destructed
.
"
;
}
void
ThreadManager
:
:
Add
(
Thread
*
message_queue
)
{
return
Instance
(
)
-
>
AddInternal
(
message_queue
)
;
}
void
ThreadManager
:
:
AddInternal
(
Thread
*
message_queue
)
{
CritScope
cs
(
&
crit_
)
;
RTC_DCHECK_EQ
(
processing_
0
)
;
message_queues_
.
push_back
(
message_queue
)
;
}
void
ThreadManager
:
:
Remove
(
Thread
*
message_queue
)
{
return
Instance
(
)
-
>
RemoveInternal
(
message_queue
)
;
}
void
ThreadManager
:
:
RemoveInternal
(
Thread
*
message_queue
)
{
{
CritScope
cs
(
&
crit_
)
;
RTC_DCHECK_EQ
(
processing_
0
)
;
std
:
:
vector
<
Thread
*
>
:
:
iterator
iter
;
iter
=
absl
:
:
c_find
(
message_queues_
message_queue
)
;
if
(
iter
!
=
message_queues_
.
end
(
)
)
{
message_queues_
.
erase
(
iter
)
;
}
#
if
RTC_DCHECK_IS_ON
RemoveFromSendGraph
(
message_queue
)
;
#
endif
}
}
#
if
RTC_DCHECK_IS_ON
void
ThreadManager
:
:
RemoveFromSendGraph
(
Thread
*
thread
)
{
for
(
auto
it
=
send_graph_
.
begin
(
)
;
it
!
=
send_graph_
.
end
(
)
;
)
{
if
(
it
-
>
first
=
=
thread
)
{
it
=
send_graph_
.
erase
(
it
)
;
}
else
{
it
-
>
second
.
erase
(
thread
)
;
+
+
it
;
}
}
}
void
ThreadManager
:
:
RegisterSendAndCheckForCycles
(
Thread
*
source
Thread
*
target
)
{
RTC_DCHECK
(
source
)
;
RTC_DCHECK
(
target
)
;
CritScope
cs
(
&
crit_
)
;
std
:
:
deque
<
Thread
*
>
all_targets
(
{
target
}
)
;
for
(
size_t
i
=
0
;
i
<
all_targets
.
size
(
)
;
i
+
+
)
{
const
auto
&
targets
=
send_graph_
[
all_targets
[
i
]
]
;
all_targets
.
insert
(
all_targets
.
end
(
)
targets
.
begin
(
)
targets
.
end
(
)
)
;
}
RTC_CHECK_EQ
(
absl
:
:
c_count
(
all_targets
source
)
0
)
<
<
"
send
loop
between
"
<
<
source
-
>
name
(
)
<
<
"
and
"
<
<
target
-
>
name
(
)
;
send_graph_
[
source
]
.
insert
(
target
)
;
}
#
endif
void
ThreadManager
:
:
Clear
(
MessageHandler
*
handler
)
{
return
Instance
(
)
-
>
ClearInternal
(
handler
)
;
}
void
ThreadManager
:
:
ClearInternal
(
MessageHandler
*
handler
)
{
MarkProcessingCritScope
cs
(
&
crit_
&
processing_
)
;
for
(
Thread
*
queue
:
message_queues_
)
{
queue
-
>
Clear
(
handler
)
;
}
}
void
ThreadManager
:
:
ProcessAllMessageQueuesForTesting
(
)
{
return
Instance
(
)
-
>
ProcessAllMessageQueuesInternal
(
)
;
}
void
ThreadManager
:
:
ProcessAllMessageQueuesInternal
(
)
{
volatile
int
queues_not_done
=
0
;
class
ScopedIncrement
:
public
MessageData
{
public
:
ScopedIncrement
(
volatile
int
*
value
)
:
value_
(
value
)
{
AtomicOps
:
:
Increment
(
value_
)
;
}
~
ScopedIncrement
(
)
override
{
AtomicOps
:
:
Decrement
(
value_
)
;
}
private
:
volatile
int
*
value_
;
}
;
{
MarkProcessingCritScope
cs
(
&
crit_
&
processing_
)
;
for
(
Thread
*
queue
:
message_queues_
)
{
if
(
!
queue
-
>
IsProcessingMessagesForTesting
(
)
)
{
continue
;
}
queue
-
>
PostDelayed
(
RTC_FROM_HERE
0
nullptr
MQID_DISPOSE
new
ScopedIncrement
(
&
queues_not_done
)
)
;
}
}
rtc
:
:
Thread
*
current
=
rtc
:
:
Thread
:
:
Current
(
)
;
while
(
AtomicOps
:
:
AcquireLoad
(
&
queues_not_done
)
>
0
)
{
if
(
current
)
{
current
-
>
ProcessMessages
(
0
)
;
}
}
}
Thread
*
Thread
:
:
Current
(
)
{
ThreadManager
*
manager
=
ThreadManager
:
:
Instance
(
)
;
Thread
*
thread
=
manager
-
>
CurrentThread
(
)
;
#
ifndef
NO_MAIN_THREAD_WRAPPING
if
(
!
thread
&
&
manager
-
>
IsMainThread
(
)
)
{
thread
=
new
Thread
(
CreateDefaultSocketServer
(
)
)
;
thread
-
>
WrapCurrentWithThreadManager
(
manager
true
)
;
}
#
endif
return
thread
;
}
#
if
defined
(
WEBRTC_POSIX
)
ThreadManager
:
:
ThreadManager
(
)
:
main_thread_ref_
(
CurrentThreadRef
(
)
)
{
#
if
defined
(
WEBRTC_MAC
)
InitCocoaMultiThreading
(
)
;
#
endif
pthread_key_create
(
&
key_
nullptr
)
;
}
Thread
*
ThreadManager
:
:
CurrentThread
(
)
{
return
static_cast
<
Thread
*
>
(
pthread_getspecific
(
key_
)
)
;
}
void
ThreadManager
:
:
SetCurrentThreadInternal
(
Thread
*
thread
)
{
pthread_setspecific
(
key_
thread
)
;
}
#
endif
#
if
defined
(
WEBRTC_WIN
)
ThreadManager
:
:
ThreadManager
(
)
:
key_
(
TlsAlloc
(
)
)
main_thread_ref_
(
CurrentThreadRef
(
)
)
{
}
Thread
*
ThreadManager
:
:
CurrentThread
(
)
{
return
static_cast
<
Thread
*
>
(
TlsGetValue
(
key_
)
)
;
}
void
ThreadManager
:
:
SetCurrentThreadInternal
(
Thread
*
thread
)
{
TlsSetValue
(
key_
thread
)
;
}
#
endif
void
ThreadManager
:
:
SetCurrentThread
(
Thread
*
thread
)
{
#
if
RTC_DLOG_IS_ON
if
(
CurrentThread
(
)
&
&
thread
)
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
SetCurrentThread
:
Overwriting
an
existing
value
?
"
;
}
#
endif
if
(
thread
)
{
thread
-
>
EnsureIsCurrentTaskQueue
(
)
;
}
else
{
Thread
*
current
=
CurrentThread
(
)
;
if
(
current
)
{
current
-
>
ClearCurrentTaskQueue
(
)
;
}
}
SetCurrentThreadInternal
(
thread
)
;
}
void
rtc
:
:
ThreadManager
:
:
ChangeCurrentThreadForTest
(
rtc
:
:
Thread
*
thread
)
{
SetCurrentThreadInternal
(
thread
)
;
}
Thread
*
ThreadManager
:
:
WrapCurrentThread
(
)
{
Thread
*
result
=
CurrentThread
(
)
;
if
(
nullptr
=
=
result
)
{
result
=
new
Thread
(
CreateDefaultSocketServer
(
)
)
;
result
-
>
WrapCurrentWithThreadManager
(
this
true
)
;
}
return
result
;
}
void
ThreadManager
:
:
UnwrapCurrentThread
(
)
{
Thread
*
t
=
CurrentThread
(
)
;
if
(
t
&
&
!
(
t
-
>
IsOwned
(
)
)
)
{
t
-
>
UnwrapCurrent
(
)
;
delete
t
;
}
}
bool
ThreadManager
:
:
IsMainThread
(
)
{
return
IsThreadRefEqual
(
CurrentThreadRef
(
)
main_thread_ref_
)
;
}
Thread
:
:
ScopedDisallowBlockingCalls
:
:
ScopedDisallowBlockingCalls
(
)
:
thread_
(
Thread
:
:
Current
(
)
)
previous_state_
(
thread_
-
>
SetAllowBlockingCalls
(
false
)
)
{
}
Thread
:
:
ScopedDisallowBlockingCalls
:
:
~
ScopedDisallowBlockingCalls
(
)
{
RTC_DCHECK
(
thread_
-
>
IsCurrent
(
)
)
;
thread_
-
>
SetAllowBlockingCalls
(
previous_state_
)
;
}
Thread
:
:
Thread
(
SocketServer
*
ss
)
:
Thread
(
ss
true
)
{
}
Thread
:
:
Thread
(
std
:
:
unique_ptr
<
SocketServer
>
ss
)
:
Thread
(
std
:
:
move
(
ss
)
true
)
{
}
Thread
:
:
Thread
(
SocketServer
*
ss
bool
do_init
)
:
fPeekKeep_
(
false
)
delayed_next_num_
(
0
)
fInitialized_
(
false
)
fDestroyed_
(
false
)
stop_
(
0
)
ss_
(
ss
)
{
RTC_DCHECK
(
ss
)
;
ss_
-
>
SetMessageQueue
(
this
)
;
SetName
(
"
Thread
"
this
)
;
if
(
do_init
)
{
DoInit
(
)
;
}
}
Thread
:
:
Thread
(
std
:
:
unique_ptr
<
SocketServer
>
ss
bool
do_init
)
:
Thread
(
ss
.
get
(
)
do_init
)
{
own_ss_
=
std
:
:
move
(
ss
)
;
}
Thread
:
:
~
Thread
(
)
{
Stop
(
)
;
DoDestroy
(
)
;
}
void
Thread
:
:
DoInit
(
)
{
if
(
fInitialized_
)
{
return
;
}
fInitialized_
=
true
;
ThreadManager
:
:
Add
(
this
)
;
}
void
Thread
:
:
DoDestroy
(
)
{
if
(
fDestroyed_
)
{
return
;
}
fDestroyed_
=
true
;
SignalQueueDestroyed
(
)
;
ThreadManager
:
:
Remove
(
this
)
;
ClearInternal
(
nullptr
MQID_ANY
nullptr
)
;
if
(
ss_
)
{
ss_
-
>
SetMessageQueue
(
nullptr
)
;
}
}
SocketServer
*
Thread
:
:
socketserver
(
)
{
return
ss_
;
}
void
Thread
:
:
WakeUpSocketServer
(
)
{
ss_
-
>
WakeUp
(
)
;
}
void
Thread
:
:
Quit
(
)
{
AtomicOps
:
:
ReleaseStore
(
&
stop_
1
)
;
WakeUpSocketServer
(
)
;
}
bool
Thread
:
:
IsQuitting
(
)
{
return
AtomicOps
:
:
AcquireLoad
(
&
stop_
)
!
=
0
;
}
void
Thread
:
:
Restart
(
)
{
AtomicOps
:
:
ReleaseStore
(
&
stop_
0
)
;
}
bool
Thread
:
:
Peek
(
Message
*
pmsg
int
cmsWait
)
{
if
(
fPeekKeep_
)
{
*
pmsg
=
msgPeek_
;
return
true
;
}
if
(
!
Get
(
pmsg
cmsWait
)
)
return
false
;
msgPeek_
=
*
pmsg
;
fPeekKeep_
=
true
;
return
true
;
}
bool
Thread
:
:
Get
(
Message
*
pmsg
int
cmsWait
bool
process_io
)
{
if
(
fPeekKeep_
)
{
*
pmsg
=
msgPeek_
;
fPeekKeep_
=
false
;
return
true
;
}
int64_t
cmsTotal
=
cmsWait
;
int64_t
cmsElapsed
=
0
;
int64_t
msStart
=
TimeMillis
(
)
;
int64_t
msCurrent
=
msStart
;
while
(
true
)
{
int64_t
cmsDelayNext
=
kForever
;
bool
first_pass
=
true
;
while
(
true
)
{
{
CritScope
cs
(
&
crit_
)
;
if
(
first_pass
)
{
first_pass
=
false
;
while
(
!
delayed_messages_
.
empty
(
)
)
{
if
(
msCurrent
<
delayed_messages_
.
top
(
)
.
run_time_ms_
)
{
cmsDelayNext
=
TimeDiff
(
delayed_messages_
.
top
(
)
.
run_time_ms_
msCurrent
)
;
break
;
}
messages_
.
push_back
(
delayed_messages_
.
top
(
)
.
msg_
)
;
delayed_messages_
.
pop
(
)
;
}
}
if
(
messages_
.
empty
(
)
)
{
break
;
}
else
{
*
pmsg
=
messages_
.
front
(
)
;
messages_
.
pop_front
(
)
;
}
}
if
(
MQID_DISPOSE
=
=
pmsg
-
>
message_id
)
{
RTC_DCHECK
(
nullptr
=
=
pmsg
-
>
phandler
)
;
delete
pmsg
-
>
pdata
;
*
pmsg
=
Message
(
)
;
continue
;
}
return
true
;
}
if
(
IsQuitting
(
)
)
break
;
int64_t
cmsNext
;
if
(
cmsWait
=
=
kForever
)
{
cmsNext
=
cmsDelayNext
;
}
else
{
cmsNext
=
std
:
:
max
<
int64_t
>
(
0
cmsTotal
-
cmsElapsed
)
;
if
(
(
cmsDelayNext
!
=
kForever
)
&
&
(
cmsDelayNext
<
cmsNext
)
)
cmsNext
=
cmsDelayNext
;
}
{
if
(
!
ss_
-
>
Wait
(
static_cast
<
int
>
(
cmsNext
)
process_io
)
)
return
false
;
}
msCurrent
=
TimeMillis
(
)
;
cmsElapsed
=
TimeDiff
(
msCurrent
msStart
)
;
if
(
cmsWait
!
=
kForever
)
{
if
(
cmsElapsed
>
=
cmsWait
)
return
false
;
}
}
return
false
;
}
void
Thread
:
:
Post
(
const
Location
&
posted_from
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
bool
time_sensitive
)
{
RTC_DCHECK
(
!
time_sensitive
)
;
if
(
IsQuitting
(
)
)
{
delete
pdata
;
return
;
}
{
CritScope
cs
(
&
crit_
)
;
Message
msg
;
msg
.
posted_from
=
posted_from
;
msg
.
phandler
=
phandler
;
msg
.
message_id
=
id
;
msg
.
pdata
=
pdata
;
messages_
.
push_back
(
msg
)
;
}
WakeUpSocketServer
(
)
;
}
void
Thread
:
:
PostDelayed
(
const
Location
&
posted_from
int
delay_ms
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
return
DoDelayPost
(
posted_from
delay_ms
TimeAfter
(
delay_ms
)
phandler
id
pdata
)
;
}
void
Thread
:
:
PostAt
(
const
Location
&
posted_from
int64_t
run_at_ms
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
return
DoDelayPost
(
posted_from
TimeUntil
(
run_at_ms
)
run_at_ms
phandler
id
pdata
)
;
}
void
Thread
:
:
DoDelayPost
(
const
Location
&
posted_from
int64_t
delay_ms
int64_t
run_at_ms
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
if
(
IsQuitting
(
)
)
{
delete
pdata
;
return
;
}
{
CritScope
cs
(
&
crit_
)
;
Message
msg
;
msg
.
posted_from
=
posted_from
;
msg
.
phandler
=
phandler
;
msg
.
message_id
=
id
;
msg
.
pdata
=
pdata
;
DelayedMessage
delayed
(
delay_ms
run_at_ms
delayed_next_num_
msg
)
;
delayed_messages_
.
push
(
delayed
)
;
+
+
delayed_next_num_
;
RTC_DCHECK_NE
(
0
delayed_next_num_
)
;
}
WakeUpSocketServer
(
)
;
}
int
Thread
:
:
GetDelay
(
)
{
CritScope
cs
(
&
crit_
)
;
if
(
!
messages_
.
empty
(
)
)
return
0
;
if
(
!
delayed_messages_
.
empty
(
)
)
{
int
delay
=
TimeUntil
(
delayed_messages_
.
top
(
)
.
run_time_ms_
)
;
if
(
delay
<
0
)
delay
=
0
;
return
delay
;
}
return
kForever
;
}
void
Thread
:
:
ClearInternal
(
MessageHandler
*
phandler
uint32_t
id
MessageList
*
removed
)
{
if
(
fPeekKeep_
&
&
msgPeek_
.
Match
(
phandler
id
)
)
{
if
(
removed
)
{
removed
-
>
push_back
(
msgPeek_
)
;
}
else
{
delete
msgPeek_
.
pdata
;
}
fPeekKeep_
=
false
;
}
for
(
auto
it
=
messages_
.
begin
(
)
;
it
!
=
messages_
.
end
(
)
;
)
{
if
(
it
-
>
Match
(
phandler
id
)
)
{
if
(
removed
)
{
removed
-
>
push_back
(
*
it
)
;
}
else
{
delete
it
-
>
pdata
;
}
it
=
messages_
.
erase
(
it
)
;
}
else
{
+
+
it
;
}
}
auto
new_end
=
delayed_messages_
.
container
(
)
.
begin
(
)
;
for
(
auto
it
=
new_end
;
it
!
=
delayed_messages_
.
container
(
)
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
msg_
.
Match
(
phandler
id
)
)
{
if
(
removed
)
{
removed
-
>
push_back
(
it
-
>
msg_
)
;
}
else
{
delete
it
-
>
msg_
.
pdata
;
}
}
else
{
*
new_end
+
+
=
*
it
;
}
}
delayed_messages_
.
container
(
)
.
erase
(
new_end
delayed_messages_
.
container
(
)
.
end
(
)
)
;
delayed_messages_
.
reheap
(
)
;
}
void
Thread
:
:
Dispatch
(
Message
*
pmsg
)
{
TRACE_EVENT2
(
"
webrtc
"
"
Thread
:
:
Dispatch
"
"
src_file
"
pmsg
-
>
posted_from
.
file_name
(
)
"
src_func
"
pmsg
-
>
posted_from
.
function_name
(
)
)
;
RTC_DCHECK_RUN_ON
(
this
)
;
int64_t
start_time
=
TimeMillis
(
)
;
pmsg
-
>
phandler
-
>
OnMessage
(
pmsg
)
;
int64_t
end_time
=
TimeMillis
(
)
;
int64_t
diff
=
TimeDiff
(
end_time
start_time
)
;
if
(
diff
>
=
dispatch_warning_ms_
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Message
to
"
<
<
name
(
)
<
<
"
took
"
<
<
diff
<
<
"
ms
to
dispatch
.
Posted
from
:
"
<
<
pmsg
-
>
posted_from
.
ToString
(
)
;
dispatch_warning_ms_
=
diff
+
1
;
}
}
bool
Thread
:
:
IsCurrent
(
)
const
{
return
ThreadManager
:
:
Instance
(
)
-
>
CurrentThread
(
)
=
=
this
;
}
std
:
:
unique_ptr
<
Thread
>
Thread
:
:
CreateWithSocketServer
(
)
{
return
std
:
:
unique_ptr
<
Thread
>
(
new
Thread
(
CreateDefaultSocketServer
(
)
)
)
;
}
std
:
:
unique_ptr
<
Thread
>
Thread
:
:
Create
(
)
{
return
std
:
:
unique_ptr
<
Thread
>
(
new
Thread
(
std
:
:
unique_ptr
<
SocketServer
>
(
new
NullSocketServer
(
)
)
)
)
;
}
bool
Thread
:
:
SleepMs
(
int
milliseconds
)
{
AssertBlockingIsAllowedOnCurrentThread
(
)
;
#
if
defined
(
WEBRTC_WIN
)
:
:
Sleep
(
milliseconds
)
;
return
true
;
#
else
struct
timespec
ts
;
ts
.
tv_sec
=
milliseconds
/
1000
;
ts
.
tv_nsec
=
(
milliseconds
%
1000
)
*
1000000
;
int
ret
=
nanosleep
(
&
ts
nullptr
)
;
if
(
ret
!
=
0
)
{
RTC_LOG_ERR
(
LS_WARNING
)
<
<
"
nanosleep
(
)
returning
early
"
;
return
false
;
}
return
true
;
#
endif
}
bool
Thread
:
:
SetName
(
const
std
:
:
string
&
name
const
void
*
obj
)
{
RTC_DCHECK
(
!
IsRunning
(
)
)
;
name_
=
name
;
if
(
obj
)
{
char
buf
[
30
]
;
snprintf
(
buf
sizeof
(
buf
)
"
0x
%
p
"
obj
)
;
name_
+
=
buf
;
}
return
true
;
}
void
Thread
:
:
SetDispatchWarningMs
(
int
deadline
)
{
if
(
!
IsCurrent
(
)
)
{
PostTask
(
webrtc
:
:
ToQueuedTask
(
[
this
deadline
]
(
)
{
SetDispatchWarningMs
(
deadline
)
;
}
)
)
;
return
;
}
RTC_DCHECK_RUN_ON
(
this
)
;
dispatch_warning_ms_
=
deadline
;
}
bool
Thread
:
:
Start
(
)
{
RTC_DCHECK
(
!
IsRunning
(
)
)
;
if
(
IsRunning
(
)
)
return
false
;
Restart
(
)
;
ThreadManager
:
:
Instance
(
)
;
owned_
=
true
;
#
if
defined
(
WEBRTC_WIN
)
thread_
=
CreateThread
(
nullptr
0
PreRun
this
0
&
thread_id_
)
;
if
(
!
thread_
)
{
return
false
;
}
#
elif
defined
(
WEBRTC_POSIX
)
pthread_attr_t
attr
;
pthread_attr_init
(
&
attr
)
;
int
error_code
=
pthread_create
(
&
thread_
&
attr
PreRun
this
)
;
if
(
0
!
=
error_code
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unable
to
create
pthread
error
"
<
<
error_code
;
thread_
=
0
;
return
false
;
}
RTC_DCHECK
(
thread_
)
;
#
endif
return
true
;
}
bool
Thread
:
:
WrapCurrent
(
)
{
return
WrapCurrentWithThreadManager
(
ThreadManager
:
:
Instance
(
)
true
)
;
}
void
Thread
:
:
UnwrapCurrent
(
)
{
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
nullptr
)
;
#
if
defined
(
WEBRTC_WIN
)
if
(
thread_
!
=
nullptr
)
{
if
(
!
CloseHandle
(
thread_
)
)
{
RTC_LOG_GLE
(
LS_ERROR
)
<
<
"
When
unwrapping
thread
failed
to
close
handle
.
"
;
}
thread_
=
nullptr
;
thread_id_
=
0
;
}
#
elif
defined
(
WEBRTC_POSIX
)
thread_
=
0
;
#
endif
}
void
Thread
:
:
SafeWrapCurrent
(
)
{
WrapCurrentWithThreadManager
(
ThreadManager
:
:
Instance
(
)
false
)
;
}
void
Thread
:
:
Join
(
)
{
if
(
!
IsRunning
(
)
)
return
;
RTC_DCHECK
(
!
IsCurrent
(
)
)
;
if
(
Current
(
)
&
&
!
Current
(
)
-
>
blocking_calls_allowed_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Waiting
for
the
thread
to
join
"
"
but
blocking
calls
have
been
disallowed
"
;
}
#
if
defined
(
WEBRTC_WIN
)
RTC_DCHECK
(
thread_
!
=
nullptr
)
;
WaitForSingleObject
(
thread_
INFINITE
)
;
CloseHandle
(
thread_
)
;
thread_
=
nullptr
;
thread_id_
=
0
;
#
elif
defined
(
WEBRTC_POSIX
)
pthread_join
(
thread_
nullptr
)
;
thread_
=
0
;
#
endif
}
bool
Thread
:
:
SetAllowBlockingCalls
(
bool
allow
)
{
RTC_DCHECK
(
IsCurrent
(
)
)
;
bool
previous
=
blocking_calls_allowed_
;
blocking_calls_allowed_
=
allow
;
return
previous
;
}
void
Thread
:
:
AssertBlockingIsAllowedOnCurrentThread
(
)
{
#
if
!
defined
(
NDEBUG
)
Thread
*
current
=
Thread
:
:
Current
(
)
;
RTC_DCHECK
(
!
current
|
|
current
-
>
blocking_calls_allowed_
)
;
#
endif
}
#
if
defined
(
WEBRTC_WIN
)
DWORD
WINAPI
Thread
:
:
PreRun
(
LPVOID
pv
)
{
#
else
void
*
Thread
:
:
PreRun
(
void
*
pv
)
{
#
endif
Thread
*
thread
=
static_cast
<
Thread
*
>
(
pv
)
;
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
thread
)
;
rtc
:
:
SetCurrentThreadName
(
thread
-
>
name_
.
c_str
(
)
)
;
#
if
defined
(
WEBRTC_MAC
)
ScopedAutoReleasePool
pool
;
#
endif
thread
-
>
Run
(
)
;
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
nullptr
)
;
#
ifdef
WEBRTC_WIN
return
0
;
#
else
return
nullptr
;
#
endif
}
void
Thread
:
:
Run
(
)
{
ProcessMessages
(
kForever
)
;
}
bool
Thread
:
:
IsOwned
(
)
{
RTC_DCHECK
(
IsRunning
(
)
)
;
return
owned_
;
}
void
Thread
:
:
Stop
(
)
{
Thread
:
:
Quit
(
)
;
Join
(
)
;
}
void
Thread
:
:
Send
(
const
Location
&
posted_from
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
RTC_DCHECK
(
!
IsQuitting
(
)
)
;
if
(
IsQuitting
(
)
)
return
;
Message
msg
;
msg
.
posted_from
=
posted_from
;
msg
.
phandler
=
phandler
;
msg
.
message_id
=
id
;
msg
.
pdata
=
pdata
;
if
(
IsCurrent
(
)
)
{
msg
.
phandler
-
>
OnMessage
(
&
msg
)
;
return
;
}
AssertBlockingIsAllowedOnCurrentThread
(
)
;
Thread
*
current_thread
=
Thread
:
:
Current
(
)
;
#
if
RTC_DCHECK_IS_ON
if
(
current_thread
)
{
RTC_DCHECK
(
current_thread
-
>
IsInvokeToThreadAllowed
(
this
)
)
;
ThreadManager
:
:
Instance
(
)
-
>
RegisterSendAndCheckForCycles
(
current_thread
this
)
;
}
#
endif
std
:
:
unique_ptr
<
rtc
:
:
Event
>
done_event
;
if
(
!
current_thread
)
done_event
.
reset
(
new
rtc
:
:
Event
(
)
)
;
bool
ready
=
false
;
PostTask
(
webrtc
:
:
ToQueuedTask
(
[
&
msg
]
(
)
mutable
{
msg
.
phandler
-
>
OnMessage
(
&
msg
)
;
}
[
this
&
ready
current_thread
done
=
done_event
.
get
(
)
]
{
if
(
current_thread
)
{
CritScope
cs
(
&
crit_
)
;
ready
=
true
;
current_thread
-
>
socketserver
(
)
-
>
WakeUp
(
)
;
}
else
{
done
-
>
Set
(
)
;
}
}
)
)
;
if
(
current_thread
)
{
bool
waited
=
false
;
crit_
.
Enter
(
)
;
while
(
!
ready
)
{
crit_
.
Leave
(
)
;
current_thread
-
>
socketserver
(
)
-
>
Wait
(
kForever
false
)
;
waited
=
true
;
crit_
.
Enter
(
)
;
}
crit_
.
Leave
(
)
;
if
(
waited
)
{
current_thread
-
>
socketserver
(
)
-
>
WakeUp
(
)
;
}
}
else
{
done_event
-
>
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
}
}
void
Thread
:
:
InvokeInternal
(
const
Location
&
posted_from
rtc
:
:
FunctionView
<
void
(
)
>
functor
)
{
TRACE_EVENT2
(
"
webrtc
"
"
Thread
:
:
Invoke
"
"
src_file
"
posted_from
.
file_name
(
)
"
src_func
"
posted_from
.
function_name
(
)
)
;
class
FunctorMessageHandler
:
public
MessageHandler
{
public
:
explicit
FunctorMessageHandler
(
rtc
:
:
FunctionView
<
void
(
)
>
functor
)
:
functor_
(
functor
)
{
}
void
OnMessage
(
Message
*
msg
)
override
{
functor_
(
)
;
}
private
:
rtc
:
:
FunctionView
<
void
(
)
>
functor_
;
}
handler
(
functor
)
;
Send
(
posted_from
&
handler
)
;
}
void
Thread
:
:
EnsureIsCurrentTaskQueue
(
)
{
task_queue_registration_
=
std
:
:
make_unique
<
TaskQueueBase
:
:
CurrentTaskQueueSetter
>
(
this
)
;
}
void
Thread
:
:
ClearCurrentTaskQueue
(
)
{
task_queue_registration_
.
reset
(
)
;
}
void
Thread
:
:
QueuedTaskHandler
:
:
OnMessage
(
Message
*
msg
)
{
RTC_DCHECK
(
msg
)
;
auto
*
data
=
static_cast
<
ScopedMessageData
<
webrtc
:
:
QueuedTask
>
*
>
(
msg
-
>
pdata
)
;
std
:
:
unique_ptr
<
webrtc
:
:
QueuedTask
>
task
=
std
:
:
move
(
data
-
>
data
(
)
)
;
delete
data
;
if
(
!
task
-
>
Run
(
)
)
task
.
release
(
)
;
}
void
Thread
:
:
AllowInvokesToThread
(
Thread
*
thread
)
{
#
if
(
!
defined
(
NDEBUG
)
|
|
defined
(
DCHECK_ALWAYS_ON
)
)
if
(
!
IsCurrent
(
)
)
{
PostTask
(
webrtc
:
:
ToQueuedTask
(
[
thread
this
]
(
)
{
AllowInvokesToThread
(
thread
)
;
}
)
)
;
return
;
}
RTC_DCHECK_RUN_ON
(
this
)
;
allowed_threads_
.
push_back
(
thread
)
;
invoke_policy_enabled_
=
true
;
#
endif
}
void
Thread
:
:
DisallowAllInvokes
(
)
{
#
if
(
!
defined
(
NDEBUG
)
|
|
defined
(
DCHECK_ALWAYS_ON
)
)
if
(
!
IsCurrent
(
)
)
{
PostTask
(
webrtc
:
:
ToQueuedTask
(
[
this
]
(
)
{
DisallowAllInvokes
(
)
;
}
)
)
;
return
;
}
RTC_DCHECK_RUN_ON
(
this
)
;
allowed_threads_
.
clear
(
)
;
invoke_policy_enabled_
=
true
;
#
endif
}
bool
Thread
:
:
IsInvokeToThreadAllowed
(
rtc
:
:
Thread
*
target
)
{
#
if
(
!
defined
(
NDEBUG
)
|
|
defined
(
DCHECK_ALWAYS_ON
)
)
RTC_DCHECK_RUN_ON
(
this
)
;
if
(
!
invoke_policy_enabled_
)
{
return
true
;
}
for
(
const
auto
*
thread
:
allowed_threads_
)
{
if
(
thread
=
=
target
)
{
return
true
;
}
}
return
false
;
#
else
return
true
;
#
endif
}
void
Thread
:
:
PostTask
(
std
:
:
unique_ptr
<
webrtc
:
:
QueuedTask
>
task
)
{
Post
(
RTC_FROM_HERE
&
queued_task_handler_
0
new
ScopedMessageData
<
webrtc
:
:
QueuedTask
>
(
std
:
:
move
(
task
)
)
)
;
}
void
Thread
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
webrtc
:
:
QueuedTask
>
task
uint32_t
milliseconds
)
{
PostDelayed
(
RTC_FROM_HERE
milliseconds
&
queued_task_handler_
0
new
ScopedMessageData
<
webrtc
:
:
QueuedTask
>
(
std
:
:
move
(
task
)
)
)
;
}
void
Thread
:
:
Delete
(
)
{
Stop
(
)
;
delete
this
;
}
bool
Thread
:
:
IsProcessingMessagesForTesting
(
)
{
return
(
owned_
|
|
IsCurrent
(
)
)
&
&
!
IsQuitting
(
)
;
}
void
Thread
:
:
Clear
(
MessageHandler
*
phandler
uint32_t
id
MessageList
*
removed
)
{
CritScope
cs
(
&
crit_
)
;
ClearInternal
(
phandler
id
removed
)
;
}
bool
Thread
:
:
ProcessMessages
(
int
cmsLoop
)
{
RTC_DCHECK
(
GetClockForTesting
(
)
=
=
nullptr
|
|
cmsLoop
=
=
0
|
|
cmsLoop
=
=
kForever
)
;
int64_t
msEnd
=
(
kForever
=
=
cmsLoop
)
?
0
:
TimeAfter
(
cmsLoop
)
;
int
cmsNext
=
cmsLoop
;
while
(
true
)
{
#
if
defined
(
WEBRTC_MAC
)
ScopedAutoReleasePool
pool
;
#
endif
Message
msg
;
if
(
!
Get
(
&
msg
cmsNext
)
)
return
!
IsQuitting
(
)
;
Dispatch
(
&
msg
)
;
if
(
cmsLoop
!
=
kForever
)
{
cmsNext
=
static_cast
<
int
>
(
TimeUntil
(
msEnd
)
)
;
if
(
cmsNext
<
0
)
return
true
;
}
}
}
bool
Thread
:
:
WrapCurrentWithThreadManager
(
ThreadManager
*
thread_manager
bool
need_synchronize_access
)
{
RTC_DCHECK
(
!
IsRunning
(
)
)
;
#
if
defined
(
WEBRTC_WIN
)
if
(
need_synchronize_access
)
{
thread_
=
OpenThread
(
SYNCHRONIZE
FALSE
GetCurrentThreadId
(
)
)
;
if
(
!
thread_
)
{
RTC_LOG_GLE
(
LS_ERROR
)
<
<
"
Unable
to
get
handle
to
thread
.
"
;
return
false
;
}
thread_id_
=
GetCurrentThreadId
(
)
;
}
#
elif
defined
(
WEBRTC_POSIX
)
thread_
=
pthread_self
(
)
;
#
endif
owned_
=
false
;
thread_manager
-
>
SetCurrentThread
(
this
)
;
return
true
;
}
bool
Thread
:
:
IsRunning
(
)
{
#
if
defined
(
WEBRTC_WIN
)
return
thread_
!
=
nullptr
;
#
elif
defined
(
WEBRTC_POSIX
)
return
thread_
!
=
0
;
#
endif
}
MessageHandler
*
Thread
:
:
GetPostTaskMessageHandler
(
)
{
static
MessageHandler
*
handler
=
new
MessageHandlerWithTask
;
return
handler
;
}
AutoThread
:
:
AutoThread
(
)
:
Thread
(
CreateDefaultSocketServer
(
)
false
)
{
if
(
!
ThreadManager
:
:
Instance
(
)
-
>
CurrentThread
(
)
)
{
DoInit
(
)
;
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
this
)
;
}
}
AutoThread
:
:
~
AutoThread
(
)
{
Stop
(
)
;
DoDestroy
(
)
;
if
(
ThreadManager
:
:
Instance
(
)
-
>
CurrentThread
(
)
=
=
this
)
{
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
nullptr
)
;
}
}
AutoSocketServerThread
:
:
AutoSocketServerThread
(
SocketServer
*
ss
)
:
Thread
(
ss
false
)
{
DoInit
(
)
;
old_thread_
=
ThreadManager
:
:
Instance
(
)
-
>
CurrentThread
(
)
;
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
nullptr
)
;
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
this
)
;
if
(
old_thread_
)
{
ThreadManager
:
:
Remove
(
old_thread_
)
;
}
}
AutoSocketServerThread
:
:
~
AutoSocketServerThread
(
)
{
RTC_DCHECK
(
ThreadManager
:
:
Instance
(
)
-
>
CurrentThread
(
)
=
=
this
)
;
ProcessMessages
(
0
)
;
Stop
(
)
;
DoDestroy
(
)
;
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
nullptr
)
;
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
old_thread_
)
;
if
(
old_thread_
)
{
ThreadManager
:
:
Add
(
old_thread_
)
;
}
}
}
