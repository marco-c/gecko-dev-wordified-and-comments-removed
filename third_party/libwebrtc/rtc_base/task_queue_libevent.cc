#
include
"
rtc_base
/
task_queue_libevent
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
pthread
.
h
>
#
include
<
signal
.
h
>
#
include
<
stdint
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
container
/
inlined_vector
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
task_queue
/
queued_task
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
event2
/
event
.
h
"
#
include
"
event2
/
event_compat
.
h
"
#
include
"
event2
/
event_struct
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
{
constexpr
char
kQuit
=
1
;
constexpr
char
kRunTasks
=
2
;
using
Priority
=
TaskQueueFactory
:
:
Priority
;
void
IgnoreSigPipeSignalOnCurrentThread
(
)
{
sigset_t
sigpipe_mask
;
sigemptyset
(
&
sigpipe_mask
)
;
sigaddset
(
&
sigpipe_mask
SIGPIPE
)
;
pthread_sigmask
(
SIG_BLOCK
&
sigpipe_mask
nullptr
)
;
}
bool
SetNonBlocking
(
int
fd
)
{
const
int
flags
=
fcntl
(
fd
F_GETFL
)
;
RTC_CHECK
(
flags
!
=
-
1
)
;
return
(
flags
&
O_NONBLOCK
)
|
|
fcntl
(
fd
F_SETFL
flags
|
O_NONBLOCK
)
!
=
-
1
;
}
void
EventAssign
(
struct
event
*
ev
struct
event_base
*
base
int
fd
short
events
void
(
*
callback
)
(
int
short
void
*
)
void
*
arg
)
{
#
if
defined
(
_EVENT2_EVENT_H_
)
RTC_CHECK_EQ
(
0
event_assign
(
ev
base
fd
events
callback
arg
)
)
;
#
else
event_set
(
ev
fd
events
callback
arg
)
;
RTC_CHECK_EQ
(
0
event_base_set
(
base
ev
)
)
;
#
endif
}
rtc
:
:
ThreadPriority
TaskQueuePriorityToThreadPriority
(
Priority
priority
)
{
switch
(
priority
)
{
case
Priority
:
:
HIGH
:
return
rtc
:
:
kRealtimePriority
;
case
Priority
:
:
LOW
:
return
rtc
:
:
kLowPriority
;
case
Priority
:
:
NORMAL
:
return
rtc
:
:
kNormalPriority
;
default
:
RTC_NOTREACHED
(
)
;
break
;
}
return
rtc
:
:
kNormalPriority
;
}
class
TaskQueueLibevent
final
:
public
TaskQueueBase
{
public
:
TaskQueueLibevent
(
absl
:
:
string_view
queue_name
rtc
:
:
ThreadPriority
priority
)
;
void
Delete
(
)
override
;
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
override
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
override
;
private
:
class
SetTimerTask
;
struct
TimerEvent
;
~
TaskQueueLibevent
(
)
override
=
default
;
static
void
ThreadMain
(
void
*
context
)
;
static
void
OnWakeup
(
int
socket
short
flags
void
*
context
)
;
static
void
RunTimer
(
int
fd
short
flags
void
*
context
)
;
bool
is_active_
=
true
;
int
wakeup_pipe_in_
=
-
1
;
int
wakeup_pipe_out_
=
-
1
;
event_base
*
event_base_
;
event
wakeup_event_
;
rtc
:
:
PlatformThread
thread_
;
Mutex
pending_lock_
;
absl
:
:
InlinedVector
<
std
:
:
unique_ptr
<
QueuedTask
>
4
>
pending_
RTC_GUARDED_BY
(
pending_lock_
)
;
std
:
:
list
<
TimerEvent
*
>
pending_timers_
;
}
;
struct
TaskQueueLibevent
:
:
TimerEvent
{
TimerEvent
(
TaskQueueLibevent
*
task_queue
std
:
:
unique_ptr
<
QueuedTask
>
task
)
:
task_queue
(
task_queue
)
task
(
std
:
:
move
(
task
)
)
{
}
~
TimerEvent
(
)
{
event_del
(
&
ev
)
;
}
event
ev
;
TaskQueueLibevent
*
task_queue
;
std
:
:
unique_ptr
<
QueuedTask
>
task
;
}
;
class
TaskQueueLibevent
:
:
SetTimerTask
:
public
QueuedTask
{
public
:
SetTimerTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
:
task_
(
std
:
:
move
(
task
)
)
milliseconds_
(
milliseconds
)
posted_
(
rtc
:
:
Time32
(
)
)
{
}
private
:
bool
Run
(
)
override
{
uint32_t
post_time
=
rtc
:
:
Time32
(
)
-
posted_
;
TaskQueueLibevent
:
:
Current
(
)
-
>
PostDelayedTask
(
std
:
:
move
(
task_
)
post_time
>
milliseconds_
?
0
:
milliseconds_
-
post_time
)
;
return
true
;
}
std
:
:
unique_ptr
<
QueuedTask
>
task_
;
const
uint32_t
milliseconds_
;
const
uint32_t
posted_
;
}
;
TaskQueueLibevent
:
:
TaskQueueLibevent
(
absl
:
:
string_view
queue_name
rtc
:
:
ThreadPriority
priority
)
:
event_base_
(
event_base_new
(
)
)
thread_
(
&
TaskQueueLibevent
:
:
ThreadMain
this
queue_name
priority
)
{
int
fds
[
2
]
;
RTC_CHECK
(
pipe
(
fds
)
=
=
0
)
;
SetNonBlocking
(
fds
[
0
]
)
;
SetNonBlocking
(
fds
[
1
]
)
;
wakeup_pipe_out_
=
fds
[
0
]
;
wakeup_pipe_in_
=
fds
[
1
]
;
EventAssign
(
&
wakeup_event_
event_base_
wakeup_pipe_out_
EV_READ
|
EV_PERSIST
OnWakeup
this
)
;
event_add
(
&
wakeup_event_
0
)
;
thread_
.
Start
(
)
;
}
void
TaskQueueLibevent
:
:
Delete
(
)
{
RTC_DCHECK
(
!
IsCurrent
(
)
)
;
struct
timespec
ts
;
char
message
=
kQuit
;
while
(
write
(
wakeup_pipe_in_
&
message
sizeof
(
message
)
)
!
=
sizeof
(
message
)
)
{
RTC_CHECK_EQ
(
EAGAIN
errno
)
;
ts
.
tv_sec
=
0
;
ts
.
tv_nsec
=
1000000
;
nanosleep
(
&
ts
nullptr
)
;
}
thread_
.
Stop
(
)
;
event_del
(
&
wakeup_event_
)
;
IgnoreSigPipeSignalOnCurrentThread
(
)
;
close
(
wakeup_pipe_in_
)
;
close
(
wakeup_pipe_out_
)
;
wakeup_pipe_in_
=
-
1
;
wakeup_pipe_out_
=
-
1
;
event_base_free
(
event_base_
)
;
delete
this
;
}
void
TaskQueueLibevent
:
:
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
{
{
MutexLock
lock
(
&
pending_lock_
)
;
bool
had_pending_tasks
=
!
pending_
.
empty
(
)
;
pending_
.
push_back
(
std
:
:
move
(
task
)
)
;
if
(
had_pending_tasks
)
{
return
;
}
}
char
message
=
kRunTasks
;
RTC_CHECK_EQ
(
write
(
wakeup_pipe_in_
&
message
sizeof
(
message
)
)
sizeof
(
message
)
)
;
}
void
TaskQueueLibevent
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
{
if
(
IsCurrent
(
)
)
{
TimerEvent
*
timer
=
new
TimerEvent
(
this
std
:
:
move
(
task
)
)
;
EventAssign
(
&
timer
-
>
ev
event_base_
-
1
0
&
TaskQueueLibevent
:
:
RunTimer
timer
)
;
pending_timers_
.
push_back
(
timer
)
;
timeval
tv
=
{
rtc
:
:
dchecked_cast
<
int
>
(
milliseconds
/
1000
)
rtc
:
:
dchecked_cast
<
int
>
(
milliseconds
%
1000
)
*
1000
}
;
event_add
(
&
timer
-
>
ev
&
tv
)
;
}
else
{
PostTask
(
std
:
:
make_unique
<
SetTimerTask
>
(
std
:
:
move
(
task
)
milliseconds
)
)
;
}
}
void
TaskQueueLibevent
:
:
ThreadMain
(
void
*
context
)
{
TaskQueueLibevent
*
me
=
static_cast
<
TaskQueueLibevent
*
>
(
context
)
;
{
CurrentTaskQueueSetter
set_current
(
me
)
;
while
(
me
-
>
is_active_
)
event_base_loop
(
me
-
>
event_base_
0
)
;
}
for
(
TimerEvent
*
timer
:
me
-
>
pending_timers_
)
delete
timer
;
}
void
TaskQueueLibevent
:
:
OnWakeup
(
int
socket
short
flags
void
*
context
)
{
TaskQueueLibevent
*
me
=
static_cast
<
TaskQueueLibevent
*
>
(
context
)
;
RTC_DCHECK
(
me
-
>
wakeup_pipe_out_
=
=
socket
)
;
char
buf
;
RTC_CHECK
(
sizeof
(
buf
)
=
=
read
(
socket
&
buf
sizeof
(
buf
)
)
)
;
switch
(
buf
)
{
case
kQuit
:
me
-
>
is_active_
=
false
;
event_base_loopbreak
(
me
-
>
event_base_
)
;
break
;
case
kRunTasks
:
{
absl
:
:
InlinedVector
<
std
:
:
unique_ptr
<
QueuedTask
>
4
>
tasks
;
{
MutexLock
lock
(
&
me
-
>
pending_lock_
)
;
tasks
.
swap
(
me
-
>
pending_
)
;
}
RTC_DCHECK
(
!
tasks
.
empty
(
)
)
;
for
(
auto
&
task
:
tasks
)
{
if
(
task
-
>
Run
(
)
)
{
task
.
reset
(
)
;
}
else
{
task
.
release
(
)
;
}
}
break
;
}
default
:
RTC_NOTREACHED
(
)
;
break
;
}
}
void
TaskQueueLibevent
:
:
RunTimer
(
int
fd
short
flags
void
*
context
)
{
TimerEvent
*
timer
=
static_cast
<
TimerEvent
*
>
(
context
)
;
if
(
!
timer
-
>
task
-
>
Run
(
)
)
timer
-
>
task
.
release
(
)
;
timer
-
>
task_queue
-
>
pending_timers_
.
remove
(
timer
)
;
delete
timer
;
}
class
TaskQueueLibeventFactory
final
:
public
TaskQueueFactory
{
public
:
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
CreateTaskQueue
(
absl
:
:
string_view
name
Priority
priority
)
const
override
{
return
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
(
new
TaskQueueLibevent
(
name
TaskQueuePriorityToThreadPriority
(
priority
)
)
)
;
}
}
;
}
std
:
:
unique_ptr
<
TaskQueueFactory
>
CreateTaskQueueLibeventFactory
(
)
{
return
std
:
:
make_unique
<
TaskQueueLibeventFactory
>
(
)
;
}
}
