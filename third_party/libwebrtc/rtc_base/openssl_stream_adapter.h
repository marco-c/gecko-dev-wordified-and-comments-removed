#
ifndef
RTC_BASE_OPENSSL_STREAM_ADAPTER_H_
#
define
RTC_BASE_OPENSSL_STREAM_ADAPTER_H_
#
include
<
openssl
/
ossl_typ
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
openssl_identity
.
h
"
#
include
"
rtc_base
/
ssl_identity
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
stream
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
rtc
{
class
SSLCertChain
;
RTC_EXPORT
void
SetAllowLegacyTLSProtocols
(
const
absl
:
:
optional
<
bool
>
&
allow
)
;
class
OpenSSLStreamAdapter
final
:
public
SSLStreamAdapter
{
public
:
explicit
OpenSSLStreamAdapter
(
std
:
:
unique_ptr
<
StreamInterface
>
stream
)
;
~
OpenSSLStreamAdapter
(
)
override
;
void
SetIdentity
(
std
:
:
unique_ptr
<
SSLIdentity
>
identity
)
override
;
OpenSSLIdentity
*
GetIdentityForTesting
(
)
const
override
;
void
SetServerRole
(
SSLRole
role
=
SSL_SERVER
)
override
;
bool
SetPeerCertificateDigest
(
const
std
:
:
string
&
digest_alg
const
unsigned
char
*
digest_val
size_t
digest_len
SSLPeerCertificateDigestError
*
error
=
nullptr
)
override
;
std
:
:
unique_ptr
<
SSLCertChain
>
GetPeerSSLCertChain
(
)
const
override
;
int
StartSSL
(
)
override
;
void
SetMode
(
SSLMode
mode
)
override
;
void
SetMaxProtocolVersion
(
SSLProtocolVersion
version
)
override
;
void
SetInitialRetransmissionTimeout
(
int
timeout_ms
)
override
;
StreamResult
Read
(
void
*
data
size_t
data_len
size_t
*
read
int
*
error
)
override
;
StreamResult
Write
(
const
void
*
data
size_t
data_len
size_t
*
written
int
*
error
)
override
;
void
Close
(
)
override
;
StreamState
GetState
(
)
const
override
;
static
std
:
:
string
SslCipherSuiteToName
(
int
crypto_suite
)
;
bool
GetSslCipherSuite
(
int
*
cipher
)
override
;
SSLProtocolVersion
GetSslVersion
(
)
const
override
;
bool
GetSslVersionBytes
(
int
*
version
)
const
override
;
bool
ExportKeyingMaterial
(
const
std
:
:
string
&
label
const
uint8_t
*
context
size_t
context_len
bool
use_context
uint8_t
*
result
size_t
result_len
)
override
;
bool
SetDtlsSrtpCryptoSuites
(
const
std
:
:
vector
<
int
>
&
crypto_suites
)
override
;
bool
GetDtlsSrtpCryptoSuite
(
int
*
crypto_suite
)
override
;
bool
IsTlsConnected
(
)
override
;
static
bool
IsBoringSsl
(
)
;
static
bool
IsAcceptableCipher
(
int
cipher
KeyType
key_type
)
;
static
bool
IsAcceptableCipher
(
const
std
:
:
string
&
cipher
KeyType
key_type
)
;
static
void
EnableTimeCallbackForTesting
(
)
;
protected
:
void
OnEvent
(
StreamInterface
*
stream
int
events
int
err
)
override
;
private
:
enum
SSLState
{
SSL_NONE
SSL_WAIT
SSL_CONNECTING
SSL_CONNECTED
SSL_ERROR
SSL_CLOSED
}
;
enum
{
MSG_TIMEOUT
=
MSG_MAX
+
1
}
;
int
BeginSSL
(
)
;
int
ContinueSSL
(
)
;
void
Error
(
const
char
*
context
int
err
uint8_t
alert
bool
signal
)
;
void
Cleanup
(
uint8_t
alert
)
;
void
OnMessage
(
Message
*
msg
)
override
;
void
FlushInput
(
unsigned
int
left
)
;
SSL_CTX
*
SetupSSLContext
(
)
;
bool
VerifyPeerCertificate
(
)
;
static
int
SSLVerifyCallback
(
X509_STORE_CTX
*
store
void
*
arg
)
;
bool
WaitingToVerifyPeerCertificate
(
)
const
{
return
GetClientAuthEnabled
(
)
&
&
!
peer_certificate_verified_
;
}
bool
HasPeerCertificateDigest
(
)
const
{
return
!
peer_certificate_digest_algorithm_
.
empty
(
)
&
&
!
peer_certificate_digest_value_
.
empty
(
)
;
}
SSLState
state_
;
SSLRole
role_
;
int
ssl_error_code_
;
bool
ssl_read_needs_write_
;
bool
ssl_write_needs_read_
;
SSL
*
ssl_
;
SSL_CTX
*
ssl_ctx_
;
std
:
:
unique_ptr
<
OpenSSLIdentity
>
identity_
;
std
:
:
unique_ptr
<
SSLCertChain
>
peer_cert_chain_
;
bool
peer_certificate_verified_
=
false
;
Buffer
peer_certificate_digest_value_
;
std
:
:
string
peer_certificate_digest_algorithm_
;
std
:
:
string
srtp_ciphers_
;
SSLMode
ssl_mode_
;
SSLProtocolVersion
ssl_max_version_
;
int
dtls_handshake_timeout_ms_
=
50
;
const
bool
support_legacy_tls_protocols_flag_
;
}
;
}
#
endif
