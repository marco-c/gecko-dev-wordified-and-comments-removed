#
include
"
rtc_base
/
sanitizer
.
h
"
#
include
<
cstdint
>
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
test
/
gtest
.
h
"
#
if
RTC_HAS_MSAN
#
include
<
sanitizer
/
msan_interface
.
h
>
#
endif
namespace
webrtc
{
namespace
{
struct
TrTrTr
{
TrTrTr
(
const
TrTrTr
&
)
=
default
;
TrTrTr
&
operator
=
(
const
TrTrTr
&
)
=
default
;
~
TrTrTr
(
)
=
default
;
}
;
static_assert
(
sanitizer_impl
:
:
IsTriviallyCopyable
<
TrTrTr
>
(
)
"
"
)
;
struct
TrDeTr
{
TrDeTr
(
const
TrDeTr
&
)
=
default
;
TrDeTr
&
operator
=
(
const
TrDeTr
&
)
=
delete
;
~
TrDeTr
(
)
=
default
;
}
;
static_assert
(
sanitizer_impl
:
:
IsTriviallyCopyable
<
TrDeTr
>
(
)
"
"
)
;
struct
TrTrNt
{
TrTrNt
(
const
TrTrNt
&
)
=
default
;
TrTrNt
&
operator
=
(
const
TrTrNt
&
)
=
default
;
~
TrTrNt
(
)
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
TrTrNt
>
(
)
"
"
)
;
struct
TrNtTr
{
TrNtTr
(
const
TrNtTr
&
)
=
default
;
TrNtTr
&
operator
=
(
const
TrNtTr
&
)
;
~
TrNtTr
(
)
=
default
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
TrNtTr
>
(
)
"
"
)
;
struct
TrNtNt
{
TrNtNt
(
const
TrNtNt
&
)
=
default
;
TrNtNt
&
operator
=
(
const
TrNtNt
&
)
;
~
TrNtNt
(
)
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
TrNtNt
>
(
)
"
"
)
;
struct
TrDeNt
{
TrDeNt
(
const
TrDeNt
&
)
=
default
;
TrDeNt
&
operator
=
(
const
TrDeNt
&
)
=
delete
;
~
TrDeNt
(
)
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
TrDeNt
>
(
)
"
"
)
;
struct
NtTrTr
{
NtTrTr
(
const
NtTrTr
&
)
;
NtTrTr
&
operator
=
(
const
NtTrTr
&
)
=
default
;
~
NtTrTr
(
)
=
default
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
NtTrTr
>
(
)
"
"
)
;
struct
NtTrNt
{
NtTrNt
(
const
NtTrNt
&
)
;
NtTrNt
&
operator
=
(
const
NtTrNt
&
)
=
default
;
~
NtTrNt
(
)
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
NtTrNt
>
(
)
"
"
)
;
struct
NtNtTr
{
NtNtTr
(
const
NtNtTr
&
)
;
NtNtTr
&
operator
=
(
const
NtNtTr
&
)
;
~
NtNtTr
(
)
=
default
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
NtNtTr
>
(
)
"
"
)
;
struct
NtNtNt
{
NtNtNt
(
const
NtNtNt
&
)
;
NtNtNt
&
operator
=
(
const
NtNtNt
&
)
;
~
NtNtNt
(
)
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
NtNtNt
>
(
)
"
"
)
;
struct
NtDeTr
{
NtDeTr
(
const
NtDeTr
&
)
;
NtDeTr
&
operator
=
(
const
NtDeTr
&
)
=
delete
;
~
NtDeTr
(
)
=
default
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
NtDeTr
>
(
)
"
"
)
;
struct
NtDeNt
{
NtDeNt
(
const
NtDeNt
&
)
;
NtDeNt
&
operator
=
(
const
NtDeNt
&
)
=
delete
;
~
NtDeNt
(
)
;
}
;
static_assert
(
!
sanitizer_impl
:
:
IsTriviallyCopyable
<
NtDeNt
>
(
)
"
"
)
;
struct
Foo
{
uint32_t
field1
;
uint16_t
field2
;
}
;
struct
Bar
{
uint32_t
ID
;
Foo
foo
;
}
;
template
<
typename
F
>
void
MsanExpectUninitializedRead
(
F
&
&
f
)
{
#
if
RTC_HAS_MSAN
EXPECT_DEATH
(
f
(
)
"
"
)
;
#
else
f
(
)
;
#
endif
}
}
TEST
(
SanitizerTest
MsanUninitialized
)
{
Bar
bar
=
MsanUninitialized
<
Bar
>
(
{
}
)
;
bar
.
ID
=
1
;
EXPECT_EQ
(
1u
bar
.
ID
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
read
after
init
passed
"
;
MsanExpectUninitializedRead
(
[
&
]
{
EXPECT_EQ
(
0u
bar
.
foo
.
field1
)
;
}
)
;
MsanExpectUninitializedRead
(
[
&
]
{
EXPECT_EQ
(
0u
bar
.
foo
.
field2
)
;
}
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
read
with
no
init
passed
"
;
}
}
