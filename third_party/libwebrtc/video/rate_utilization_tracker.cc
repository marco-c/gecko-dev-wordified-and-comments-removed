#
include
"
video
/
rate_utilization_tracker
.
h
"
#
include
<
algorithm
>
namespace
webrtc
{
RateUtilizationTracker
:
:
RateUtilizationTracker
(
size_t
max_num_encoded_data_points
TimeDelta
max_duration
)
:
max_data_points_
(
max_num_encoded_data_points
)
max_duration_
(
max_duration
)
current_rate_
(
DataRate
:
:
Zero
(
)
)
{
RTC_CHECK_GE
(
max_num_encoded_data_points
0
)
;
RTC_CHECK_GT
(
max_duration
TimeDelta
:
:
Zero
(
)
)
;
}
void
RateUtilizationTracker
:
:
OnDataRateChanged
(
DataRate
rate
Timestamp
time
)
{
current_rate_
=
rate
;
if
(
data_points_
.
empty
(
)
)
{
return
;
}
else
{
RateUsageUpdate
&
last_data_point
=
data_points_
.
back
(
)
;
RTC_CHECK_GE
(
time
last_data_point
.
time
)
;
if
(
last_data_point
.
time
=
=
time
)
{
last_data_point
.
target_rate
=
rate
;
}
else
{
data_points_
.
push_back
(
{
.
time
=
time
.
target_rate
=
rate
.
produced_data
=
DataSize
:
:
Zero
(
)
}
)
;
}
}
CullOldData
(
time
)
;
}
void
RateUtilizationTracker
:
:
OnDataProduced
(
DataSize
size
Timestamp
time
)
{
if
(
data_points_
.
empty
(
)
)
{
data_points_
.
push_back
(
{
.
time
=
time
.
target_rate
=
current_rate_
.
produced_data
=
size
}
)
;
}
else
{
RateUsageUpdate
&
last_data_point
=
data_points_
.
back
(
)
;
RTC_CHECK_GE
(
time
last_data_point
.
time
)
;
if
(
last_data_point
.
time
=
=
time
)
{
last_data_point
.
produced_data
+
=
size
;
}
else
{
data_points_
.
push_back
(
{
.
time
=
time
.
target_rate
=
current_rate_
.
produced_data
=
size
}
)
;
}
}
CullOldData
(
time
)
;
}
absl
:
:
optional
<
double
>
RateUtilizationTracker
:
:
GetRateUtilizationFactor
(
Timestamp
time
)
const
{
if
(
data_points_
.
empty
(
)
)
{
return
absl
:
:
nullopt
;
}
RTC_CHECK_GE
(
time
data_points_
.
back
(
)
.
time
)
;
DataSize
allocated_send_data_size
=
DataSize
:
:
Zero
(
)
;
DataSize
total_produced_data
=
DataSize
:
:
Zero
(
)
;
DataSize
data_allocated_for_last_data
=
DataSize
:
:
Zero
(
)
;
DataSize
size_of_last_data
=
DataSize
:
:
Zero
(
)
;
RTC_DCHECK
(
!
data_points_
.
front
(
)
.
produced_data
.
IsZero
(
)
)
;
for
(
size_t
i
=
0
;
i
<
data_points_
.
size
(
)
;
+
+
i
)
{
const
RateUsageUpdate
&
update
=
data_points_
[
i
]
;
total_produced_data
+
=
update
.
produced_data
;
DataSize
allocated_since_previous_data_point
=
i
=
=
0
?
DataSize
:
:
Zero
(
)
:
(
update
.
time
-
data_points_
[
i
-
1
]
.
time
)
*
data_points_
[
i
-
1
]
.
target_rate
;
allocated_send_data_size
+
=
allocated_since_previous_data_point
;
if
(
update
.
produced_data
.
IsZero
(
)
)
{
data_allocated_for_last_data
+
=
allocated_since_previous_data_point
;
}
else
{
size_of_last_data
=
update
.
produced_data
;
data_allocated_for_last_data
=
DataSize
:
:
Zero
(
)
;
}
}
if
(
allocated_send_data_size
.
IsZero
(
)
&
&
current_rate_
.
IsZero
(
)
)
{
return
absl
:
:
nullopt
;
}
const
RateUsageUpdate
&
last_update
=
data_points_
.
back
(
)
;
DataSize
allocated_since_last_data_point
=
(
time
-
last_update
.
time
)
*
last_update
.
target_rate
;
allocated_send_data_size
+
=
std
:
:
max
(
allocated_since_last_data_point
size_of_last_data
-
data_allocated_for_last_data
)
;
return
total_produced_data
.
bytes
<
double
>
(
)
/
allocated_send_data_size
.
bytes
(
)
;
}
void
RateUtilizationTracker
:
:
CullOldData
(
Timestamp
time
)
{
const
Timestamp
oldest_included_time
=
time
.
ms
(
)
>
max_duration_
.
ms
(
)
?
time
-
max_duration_
:
Timestamp
:
:
Zero
(
)
;
while
(
!
data_points_
.
empty
(
)
&
&
(
data_points_
.
front
(
)
.
time
<
oldest_included_time
|
|
data_points_
.
size
(
)
>
max_data_points_
|
|
data_points_
.
front
(
)
.
produced_data
.
IsZero
(
)
)
)
{
data_points_
.
pop_front
(
)
;
}
}
}
