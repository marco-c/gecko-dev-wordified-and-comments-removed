#
include
"
video
/
adaptation
/
pixel_limit_resource
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
call
/
adaptation
/
video_stream_adapter
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
ref_counted_object
.
h
"
namespace
webrtc
{
namespace
{
constexpr
TimeDelta
kResourceUsageCheckIntervalMs
=
TimeDelta
:
:
Seconds
(
5
)
;
}
rtc
:
:
scoped_refptr
<
PixelLimitResource
>
PixelLimitResource
:
:
Create
(
TaskQueueBase
*
task_queue
VideoStreamInputStateProvider
*
input_state_provider
)
{
return
new
rtc
:
:
RefCountedObject
<
PixelLimitResource
>
(
task_queue
input_state_provider
)
;
}
PixelLimitResource
:
:
PixelLimitResource
(
TaskQueueBase
*
task_queue
VideoStreamInputStateProvider
*
input_state_provider
)
:
task_queue_
(
task_queue
)
input_state_provider_
(
input_state_provider
)
max_pixels_
(
absl
:
:
nullopt
)
{
RTC_DCHECK
(
task_queue_
)
;
RTC_DCHECK
(
input_state_provider_
)
;
}
PixelLimitResource
:
:
~
PixelLimitResource
(
)
{
RTC_DCHECK
(
!
listener_
)
;
RTC_DCHECK
(
!
repeating_task_
.
Running
(
)
)
;
}
void
PixelLimitResource
:
:
SetMaxPixels
(
int
max_pixels
)
{
RTC_DCHECK_RUN_ON
(
task_queue_
)
;
max_pixels_
=
max_pixels
;
}
void
PixelLimitResource
:
:
SetResourceListener
(
ResourceListener
*
listener
)
{
RTC_DCHECK_RUN_ON
(
task_queue_
)
;
listener_
=
listener
;
if
(
listener_
)
{
repeating_task_
.
Stop
(
)
;
repeating_task_
=
RepeatingTaskHandle
:
:
Start
(
task_queue_
[
&
]
{
RTC_DCHECK_RUN_ON
(
task_queue_
)
;
if
(
!
listener_
)
{
return
kResourceUsageCheckIntervalMs
;
}
if
(
!
max_pixels_
.
has_value
(
)
)
{
return
kResourceUsageCheckIntervalMs
;
}
absl
:
:
optional
<
int
>
frame_size_pixels
=
input_state_provider_
-
>
InputState
(
)
.
frame_size_pixels
(
)
;
if
(
!
frame_size_pixels
.
has_value
(
)
)
{
return
kResourceUsageCheckIntervalMs
;
}
int
current_pixels
=
frame_size_pixels
.
value
(
)
;
int
target_pixel_upper_bounds
=
max_pixels_
.
value
(
)
;
int
target_pixels_lower_bounds
=
GetLowerResolutionThan
(
target_pixel_upper_bounds
)
;
if
(
current_pixels
>
target_pixel_upper_bounds
)
{
listener_
-
>
OnResourceUsageStateMeasured
(
this
ResourceUsageState
:
:
kOveruse
)
;
}
else
if
(
current_pixels
<
target_pixels_lower_bounds
)
{
listener_
-
>
OnResourceUsageStateMeasured
(
this
ResourceUsageState
:
:
kUnderuse
)
;
}
return
kResourceUsageCheckIntervalMs
;
}
)
;
}
else
{
repeating_task_
.
Stop
(
)
;
}
RTC_DCHECK
(
repeating_task_
.
Running
(
)
|
|
!
listener_
)
;
}
}
