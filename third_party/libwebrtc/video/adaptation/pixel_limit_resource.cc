#
include
"
video
/
adaptation
/
pixel_limit_resource
.
h
"
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
adaptation
/
resource
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
make_ref_counted
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
call
/
adaptation
/
video_stream_adapter
.
h
"
#
include
"
call
/
adaptation
/
video_stream_input_state_provider
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
task_utils
/
repeating_task
.
h
"
namespace
webrtc
{
namespace
{
struct
PixelLimitResourceParams
{
static
std
:
:
optional
<
PixelLimitResourceParams
>
Parse
(
const
FieldTrialsView
&
field_trials
)
{
std
:
:
string
params_str
=
field_trials
.
Lookup
(
"
WebRTC
-
PixelLimitResource
"
)
;
if
(
params_str
.
empty
(
)
)
{
return
std
:
:
nullopt
;
}
PixelLimitResourceParams
params
;
ParseFieldTrial
(
{
&
params
.
target_pixels
&
params
.
interval
&
params
.
toggle
}
params_str
)
;
return
params
;
}
PixelLimitResourceParams
(
)
:
target_pixels
(
"
target_pixels
"
0
)
interval
(
"
interval
"
TimeDelta
:
:
Seconds
(
5
)
)
toggle
(
"
toggle
"
)
{
}
FieldTrialParameter
<
int
>
target_pixels
;
FieldTrialParameter
<
TimeDelta
>
interval
;
FieldTrialOptional
<
TimeDelta
>
toggle
;
}
;
}
scoped_refptr
<
PixelLimitResource
>
PixelLimitResource
:
:
CreateIfFieldTrialEnabled
(
const
FieldTrialsView
&
field_trials
TaskQueueBase
*
task_queue
VideoStreamInputStateProvider
*
input_state_provider
)
{
std
:
:
optional
<
PixelLimitResourceParams
>
params
=
PixelLimitResourceParams
:
:
Parse
(
field_trials
)
;
if
(
!
params
.
has_value
(
)
)
{
return
nullptr
;
}
auto
pixel_limit_resource
=
make_ref_counted
<
PixelLimitResource
>
(
task_queue
input_state_provider
params
-
>
target_pixels
.
Get
(
)
params
-
>
interval
.
Get
(
)
params
-
>
toggle
.
GetOptional
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Running
with
PixelLimitResource
{
target_pixels
:
"
<
<
params
-
>
target_pixels
.
Get
(
)
<
<
"
interval
:
"
<
<
params
-
>
interval
.
Get
(
)
<
<
"
toggle
:
"
<
<
(
params
-
>
toggle
?
ToString
(
*
params
-
>
toggle
)
:
std
:
:
string
(
"
N
/
A
"
)
)
<
<
"
}
"
;
return
pixel_limit_resource
;
}
PixelLimitResource
:
:
PixelLimitResource
(
TaskQueueBase
*
task_queue
VideoStreamInputStateProvider
*
input_state_provider
int
target_pixels
TimeDelta
interval
std
:
:
optional
<
TimeDelta
>
toggle_interval
)
:
task_queue_
(
task_queue
)
input_state_provider_
(
input_state_provider
)
target_pixels_
(
target_pixels
)
interval_
(
interval
)
toggle_interval_
(
toggle_interval
)
is_enabled_
(
true
)
time_since_last_toggle_
(
TimeDelta
:
:
Zero
(
)
)
{
RTC_DCHECK
(
task_queue_
)
;
RTC_DCHECK
(
input_state_provider_
)
;
}
PixelLimitResource
:
:
~
PixelLimitResource
(
)
{
RTC_DCHECK
(
!
listener_
)
;
RTC_DCHECK
(
!
repeating_task_
.
Running
(
)
)
;
}
void
PixelLimitResource
:
:
SetResourceListener
(
ResourceListener
*
listener
)
{
RTC_DCHECK_RUN_ON
(
task_queue_
)
;
listener_
=
listener
;
if
(
listener_
)
{
repeating_task_
.
Stop
(
)
;
repeating_task_
=
RepeatingTaskHandle
:
:
DelayedStart
(
task_queue_
interval_
[
&
]
{
RTC_DCHECK_RUN_ON
(
task_queue_
)
;
if
(
!
listener_
)
{
return
interval_
;
}
if
(
is_enabled_
)
{
std
:
:
optional
<
int
>
current_pixels
=
input_state_provider_
-
>
InputState
(
)
.
frame_size_pixels
(
)
;
if
(
current_pixels
.
has_value
(
)
)
{
int
target_pixels_lower_bounds
=
GetLowerResolutionThan
(
target_pixels_
)
;
if
(
*
current_pixels
>
target_pixels_
)
{
listener_
-
>
OnResourceUsageStateMeasured
(
scoped_refptr
<
Resource
>
(
this
)
ResourceUsageState
:
:
kOveruse
)
;
}
else
if
(
*
current_pixels
<
target_pixels_lower_bounds
)
{
listener_
-
>
OnResourceUsageStateMeasured
(
scoped_refptr
<
Resource
>
(
this
)
ResourceUsageState
:
:
kUnderuse
)
;
}
}
}
else
{
listener_
-
>
OnResourceUsageStateMeasured
(
scoped_refptr
<
Resource
>
(
this
)
ResourceUsageState
:
:
kUnderuse
)
;
}
if
(
toggle_interval_
.
has_value
(
)
)
{
time_since_last_toggle_
+
=
interval_
;
if
(
time_since_last_toggle_
>
=
toggle_interval_
.
value
(
)
)
{
is_enabled_
=
!
is_enabled_
;
RTC_LOG
(
LS_INFO
)
<
<
"
PixelLimitResource
toggled
"
<
<
(
is_enabled_
?
"
on
"
:
"
off
"
)
;
time_since_last_toggle_
=
TimeDelta
:
:
Zero
(
)
;
}
}
return
interval_
;
}
)
;
}
else
{
repeating_task_
.
Stop
(
)
;
}
RTC_DCHECK
(
repeating_task_
.
Running
(
)
|
|
!
listener_
)
;
}
}
