#
include
"
video
/
adaptation
/
bitrate_constraint
.
h
"
#
include
<
cstdint
>
#
include
<
optional
>
#
include
<
utility
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
call
/
adaptation
/
encoder_settings
.
h
"
#
include
"
call
/
adaptation
/
video_source_restrictions
.
h
"
#
include
"
call
/
adaptation
/
video_stream_adapter
.
h
"
#
include
"
call
/
adaptation
/
video_stream_input_state
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
video
/
adaptation
/
video_stream_encoder_resource_manager
.
h
"
namespace
webrtc
{
BitrateConstraint
:
:
BitrateConstraint
(
)
:
encoder_settings_
(
std
:
:
nullopt
)
encoder_target_bitrate_bps_
(
std
:
:
nullopt
)
{
sequence_checker_
.
Detach
(
)
;
}
void
BitrateConstraint
:
:
OnEncoderSettingsUpdated
(
std
:
:
optional
<
EncoderSettings
>
encoder_settings
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
encoder_settings_
=
std
:
:
move
(
encoder_settings
)
;
}
void
BitrateConstraint
:
:
OnEncoderTargetBitrateUpdated
(
std
:
:
optional
<
uint32_t
>
encoder_target_bitrate_bps
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
encoder_target_bitrate_bps_
=
std
:
:
move
(
encoder_target_bitrate_bps
)
;
}
bool
BitrateConstraint
:
:
IsAdaptationUpAllowed
(
const
VideoStreamInputState
&
input_state
const
VideoSourceRestrictions
&
restrictions_before
const
VideoSourceRestrictions
&
restrictions_after
)
const
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
if
(
DidIncreaseResolution
(
restrictions_before
restrictions_after
)
)
{
if
(
!
encoder_settings_
.
has_value
(
)
)
{
return
true
;
}
uint32_t
bitrate_bps
=
encoder_target_bitrate_bps_
.
value_or
(
0
)
;
if
(
bitrate_bps
=
=
0
)
{
return
true
;
}
if
(
VideoStreamEncoderResourceManager
:
:
IsSimulcastOrMultipleSpatialLayers
(
encoder_settings_
-
>
encoder_config
(
)
encoder_settings_
-
>
video_codec
(
)
)
)
{
return
true
;
}
std
:
:
optional
<
int
>
current_frame_size_px
=
input_state
.
single_active_stream_pixels
(
)
;
if
(
!
current_frame_size_px
.
has_value
(
)
)
{
return
true
;
}
std
:
:
optional
<
VideoEncoder
:
:
ResolutionBitrateLimits
>
bitrate_limits
=
encoder_settings_
-
>
encoder_info
(
)
.
GetEncoderBitrateLimitsForResolution
(
GetHigherResolutionThan
(
*
current_frame_size_px
)
)
;
if
(
bitrate_limits
.
has_value
(
)
)
{
RTC_DCHECK_GE
(
bitrate_limits
-
>
frame_size_pixels
*
current_frame_size_px
)
;
return
bitrate_bps
>
=
static_cast
<
uint32_t
>
(
bitrate_limits
-
>
min_start_bitrate_bps
)
;
}
}
return
true
;
}
}
