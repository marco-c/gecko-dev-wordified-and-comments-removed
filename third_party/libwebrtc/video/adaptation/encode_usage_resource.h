#
ifndef
VIDEO_ADAPTATION_ENCODE_USAGE_RESOURCE_H_
#
define
VIDEO_ADAPTATION_ENCODE_USAGE_RESOURCE_H_
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
video_adaptation_reason
.
h
"
#
include
"
video
/
adaptation
/
overuse_frame_detector
.
h
"
#
include
"
video
/
adaptation
/
video_stream_encoder_resource
.
h
"
namespace
webrtc
{
class
EncodeUsageResource
:
public
VideoStreamEncoderResource
public
OveruseFrameDetectorObserverInterface
{
public
:
static
scoped_refptr
<
EncodeUsageResource
>
Create
(
std
:
:
unique_ptr
<
OveruseFrameDetector
>
overuse_detector
)
;
explicit
EncodeUsageResource
(
std
:
:
unique_ptr
<
OveruseFrameDetector
>
overuse_detector
)
;
~
EncodeUsageResource
(
)
override
;
bool
is_started
(
)
const
;
void
StartCheckForOveruse
(
CpuOveruseOptions
options
)
;
void
StopCheckForOveruse
(
)
;
void
SetTargetFrameRate
(
std
:
:
optional
<
double
>
target_frame_rate
)
;
void
OnEncodeStarted
(
const
VideoFrame
&
cropped_frame
int64_t
time_when_first_seen_us
)
;
void
OnEncodeCompleted
(
uint32_t
timestamp
int64_t
time_sent_in_us
int64_t
capture_time_us
std
:
:
optional
<
int
>
encode_duration_us
)
;
void
AdaptUp
(
)
override
;
void
AdaptDown
(
)
override
;
private
:
int
TargetFrameRateAsInt
(
)
;
const
std
:
:
unique_ptr
<
OveruseFrameDetector
>
overuse_detector_
RTC_GUARDED_BY
(
encoder_queue
(
)
)
;
bool
is_started_
RTC_GUARDED_BY
(
encoder_queue
(
)
)
;
std
:
:
optional
<
double
>
target_frame_rate_
RTC_GUARDED_BY
(
encoder_queue
(
)
)
;
}
;
}
#
endif
