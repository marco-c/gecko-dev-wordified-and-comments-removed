#
include
"
video
/
frame_decode_timing
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
namespace
{
constexpr
TimeDelta
kMaxAllowedFrameDelay
=
TimeDelta
:
:
Millis
(
5
)
;
}
FrameDecodeTiming
:
:
FrameDecodeTiming
(
Clock
*
clock
webrtc
:
:
VCMTiming
const
*
timing
)
:
clock_
(
clock
)
timing_
(
timing
)
{
RTC_DCHECK
(
clock_
)
;
RTC_DCHECK
(
timing_
)
;
}
absl
:
:
optional
<
FrameDecodeTiming
:
:
FrameSchedule
>
FrameDecodeTiming
:
:
OnFrameBufferUpdated
(
uint32_t
next_temporal_unit_rtp
uint32_t
last_temporal_unit_rtp
bool
too_many_frames_queued
)
{
const
Timestamp
now
=
clock_
-
>
CurrentTime
(
)
;
Timestamp
render_time
=
Timestamp
:
:
Millis
(
timing_
-
>
RenderTimeMs
(
next_temporal_unit_rtp
now
.
ms
(
)
)
)
;
TimeDelta
max_wait
=
TimeDelta
:
:
Millis
(
timing_
-
>
MaxWaitingTime
(
render_time
.
ms
(
)
now
.
ms
(
)
too_many_frames_queued
)
)
;
if
(
max_wait
<
=
-
kMaxAllowedFrameDelay
&
&
next_temporal_unit_rtp
!
=
last_temporal_unit_rtp
)
{
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
Fast
-
forwarded
frame
"
<
<
next_temporal_unit_rtp
<
<
"
render
time
"
<
<
render_time
.
ms
(
)
<
<
"
with
delay
"
<
<
max_wait
.
ms
(
)
<
<
"
ms
"
;
return
absl
:
:
nullopt
;
}
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
Selected
frame
with
rtp
"
<
<
next_temporal_unit_rtp
<
<
"
render
time
"
<
<
render_time
.
ms
(
)
<
<
"
with
a
max
wait
of
"
<
<
max_wait
.
ms
(
)
<
<
"
ms
"
;
return
FrameSchedule
{
.
max_decode_time
=
now
+
max_wait
.
render_time
=
render_time
}
;
}
}
