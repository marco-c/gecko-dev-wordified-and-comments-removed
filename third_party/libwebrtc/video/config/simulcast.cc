#
include
"
video
/
config
/
simulcast
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
video
/
resolution
.
h
"
#
include
"
api
/
video
/
video_codec_type
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
simulcast_rate_allocator
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
experiments
/
min_video_bitrate_experiment
.
h
"
#
include
"
rtc_base
/
experiments
/
rate_control_settings
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
video
/
config
/
video_encoder_config
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
webrtc
:
:
FieldTrialsView
;
constexpr
char
kUseLegacySimulcastLayerLimitFieldTrial
[
]
=
"
WebRTC
-
LegacySimulcastLayerLimit
"
;
constexpr
double
kDefaultMaxRoundupRate
=
0
.
1
;
constexpr
DataRate
kScreenshareDefaultTl0Bitrate
=
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
200
)
;
constexpr
DataRate
kScreenshareDefaultTl1Bitrate
=
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1000
)
;
constexpr
DataRate
kScreenshareHighStreamMinBitrate
=
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
600
)
;
constexpr
DataRate
kScreenshareHighStreamMaxBitrate
=
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1250
)
;
constexpr
int
kDefaultNumTemporalLayers
=
3
;
constexpr
int
kScreenshareMaxSimulcastLayers
=
2
;
constexpr
int
kScreenshareTemporalLayers
=
2
;
struct
SimulcastFormat
{
int
width
;
int
height
;
size_t
max_layers
;
DataRate
max_bitrate
;
DataRate
target_bitrate
;
DataRate
min_bitrate
;
}
;
constexpr
const
SimulcastFormat
kSimulcastFormatsVP8
[
]
=
{
{
1920
1080
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
5000
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
4000
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
800
)
}
{
1280
720
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
2500
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
2500
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
600
)
}
{
960
540
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1200
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1200
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
350
)
}
{
640
360
2
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
700
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
500
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
150
)
}
{
480
270
2
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
450
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
350
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
150
)
}
{
320
180
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
200
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
150
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
{
0
0
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
0
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
0
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
}
;
constexpr
const
SimulcastFormat
kSimulcastFormatsVP9
[
]
=
{
{
1920
1080
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
3367
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
3367
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
769
)
}
{
1280
720
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1524
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1524
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
481
)
}
{
960
540
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
879
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
879
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
337
)
}
{
640
360
2
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
420
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
420
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
193
)
}
{
480
270
2
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
257
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
257
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
121
)
}
{
320
180
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
142
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
142
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
{
240
135
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
101
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
101
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
{
0
0
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
0
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
0
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
}
;
constexpr
const
SimulcastFormat
kSimulcastFormatsH265
[
]
=
{
{
1920
1080
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
3367
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
3367
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
769
)
}
{
1280
720
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1524
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
1524
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
481
)
}
{
960
540
3
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
879
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
879
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
337
)
}
{
640
360
2
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
420
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
420
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
193
)
}
{
480
270
2
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
257
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
257
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
121
)
}
{
320
180
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
142
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
142
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
{
240
135
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
101
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
101
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
{
0
0
1
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
0
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
0
)
webrtc
:
:
DataRate
:
:
KilobitsPerSec
(
30
)
}
}
;
constexpr
DataRate
Interpolate
(
const
DataRate
&
a
const
DataRate
&
b
float
rate
)
{
return
a
*
(
1
.
0
-
rate
)
+
b
*
rate
;
}
bool
EnableLowresBitrateInterpolation
(
const
FieldTrialsView
&
trials
)
{
return
absl
:
:
StartsWith
(
trials
.
Lookup
(
"
WebRTC
-
LowresSimulcastBitrateInterpolation
"
)
"
Enabled
"
)
;
}
int
GetDefaultSimulcastTemporalLayers
(
VideoCodecType
codec
)
{
switch
(
codec
)
{
case
webrtc
:
:
kVideoCodecVP8
:
case
webrtc
:
:
kVideoCodecVP9
:
case
webrtc
:
:
kVideoCodecAV1
:
case
webrtc
:
:
kVideoCodecH264
:
case
webrtc
:
:
kVideoCodecGeneric
:
return
kDefaultNumTemporalLayers
;
case
webrtc
:
:
kVideoCodecH265
:
return
1
;
}
RTC_DCHECK_NOTREACHED
(
)
<
<
"
Unsupported
codec
.
"
;
return
1
;
}
std
:
:
vector
<
SimulcastFormat
>
GetSimulcastFormats
(
bool
enable_lowres_bitrate_interpolation
VideoCodecType
codec
)
{
std
:
:
vector
<
SimulcastFormat
>
formats
;
switch
(
codec
)
{
case
webrtc
:
:
kVideoCodecVP8
:
formats
.
insert
(
formats
.
begin
(
)
std
:
:
begin
(
kSimulcastFormatsVP8
)
std
:
:
end
(
kSimulcastFormatsVP8
)
)
;
break
;
case
webrtc
:
:
kVideoCodecVP9
:
formats
.
insert
(
formats
.
begin
(
)
std
:
:
begin
(
kSimulcastFormatsVP9
)
std
:
:
end
(
kSimulcastFormatsVP9
)
)
;
break
;
case
webrtc
:
:
kVideoCodecH265
:
formats
.
insert
(
formats
.
begin
(
)
std
:
:
begin
(
kSimulcastFormatsH265
)
std
:
:
end
(
kSimulcastFormatsH265
)
)
;
break
;
default
:
formats
.
insert
(
formats
.
begin
(
)
std
:
:
begin
(
kSimulcastFormatsVP8
)
std
:
:
end
(
kSimulcastFormatsVP8
)
)
;
break
;
}
if
(
!
enable_lowres_bitrate_interpolation
)
{
RTC_CHECK_GE
(
formats
.
size
(
)
2u
)
;
SimulcastFormat
&
format0x0
=
formats
[
formats
.
size
(
)
-
1
]
;
const
SimulcastFormat
&
format_prev
=
formats
[
formats
.
size
(
)
-
2
]
;
format0x0
.
max_bitrate
=
format_prev
.
max_bitrate
;
format0x0
.
target_bitrate
=
format_prev
.
target_bitrate
;
format0x0
.
min_bitrate
=
format_prev
.
min_bitrate
;
}
return
formats
;
}
int
FindSimulcastFormatIndex
(
int
width
int
height
bool
enable_lowres_bitrate_interpolation
VideoCodecType
codec
)
{
RTC_DCHECK_GE
(
width
0
)
;
RTC_DCHECK_GE
(
height
0
)
;
const
auto
formats
=
GetSimulcastFormats
(
enable_lowres_bitrate_interpolation
codec
)
;
for
(
uint32_t
i
=
0
;
i
<
formats
.
size
(
)
;
+
+
i
)
{
if
(
width
*
height
>
=
formats
[
i
]
.
width
*
formats
[
i
]
.
height
)
{
return
i
;
}
}
RTC_DCHECK_NOTREACHED
(
)
;
return
-
1
;
}
SimulcastFormat
InterpolateSimulcastFormat
(
int
width
int
height
std
:
:
optional
<
double
>
max_roundup_rate
bool
enable_lowres_bitrate_interpolation
VideoCodecType
codec
)
{
const
auto
formats
=
GetSimulcastFormats
(
enable_lowres_bitrate_interpolation
codec
)
;
const
int
index
=
FindSimulcastFormatIndex
(
width
height
enable_lowres_bitrate_interpolation
codec
)
;
if
(
index
=
=
0
)
return
formats
[
index
]
;
const
int
total_pixels_up
=
formats
[
index
-
1
]
.
width
*
formats
[
index
-
1
]
.
height
;
const
int
total_pixels_down
=
formats
[
index
]
.
width
*
formats
[
index
]
.
height
;
const
int
total_pixels
=
width
*
height
;
const
float
rate
=
(
total_pixels_up
-
total_pixels
)
/
static_cast
<
float
>
(
total_pixels_up
-
total_pixels_down
)
;
size_t
max_layers
=
(
rate
<
max_roundup_rate
.
value_or
(
kDefaultMaxRoundupRate
)
)
?
formats
[
index
-
1
]
.
max_layers
:
formats
[
index
]
.
max_layers
;
DataRate
max_bitrate
=
Interpolate
(
formats
[
index
-
1
]
.
max_bitrate
formats
[
index
]
.
max_bitrate
rate
)
;
DataRate
target_bitrate
=
Interpolate
(
formats
[
index
-
1
]
.
target_bitrate
formats
[
index
]
.
target_bitrate
rate
)
;
DataRate
min_bitrate
=
Interpolate
(
formats
[
index
-
1
]
.
min_bitrate
formats
[
index
]
.
min_bitrate
rate
)
;
return
{
width
height
max_layers
max_bitrate
target_bitrate
min_bitrate
}
;
}
std
:
:
vector
<
VideoStream
>
GetNormalSimulcastLayers
(
rtc
:
:
ArrayView
<
const
Resolution
>
resolutions
bool
temporal_layers_supported
bool
base_heavy_tl3_rate_alloc
const
FieldTrialsView
&
trials
VideoCodecType
codec
)
{
const
bool
enable_lowres_bitrate_interpolation
=
EnableLowresBitrateInterpolation
(
trials
)
;
const
int
num_temporal_layers
=
temporal_layers_supported
?
GetDefaultSimulcastTemporalLayers
(
codec
)
:
1
;
std
:
:
vector
<
VideoStream
>
layers
(
resolutions
.
size
(
)
)
;
for
(
size_t
s
=
0
;
s
<
resolutions
.
size
(
)
;
+
+
s
)
{
layers
[
s
]
.
width
=
resolutions
[
s
]
.
width
;
layers
[
s
]
.
height
=
resolutions
[
s
]
.
height
;
layers
[
s
]
.
num_temporal_layers
=
num_temporal_layers
;
SimulcastFormat
interpolated_format
=
InterpolateSimulcastFormat
(
layers
[
s
]
.
width
layers
[
s
]
.
height
std
:
:
nullopt
enable_lowres_bitrate_interpolation
codec
)
;
layers
[
s
]
.
max_bitrate_bps
=
interpolated_format
.
max_bitrate
.
bps
(
)
;
layers
[
s
]
.
target_bitrate_bps
=
interpolated_format
.
target_bitrate
.
bps
(
)
;
layers
[
s
]
.
min_bitrate_bps
=
interpolated_format
.
min_bitrate
.
bps
(
)
;
if
(
s
=
=
0
)
{
float
rate_factor
=
1
.
0
;
if
(
num_temporal_layers
=
=
3
)
{
if
(
base_heavy_tl3_rate_alloc
)
{
rate_factor
=
0
.
4
/
0
.
6
;
}
}
layers
[
s
]
.
max_bitrate_bps
=
static_cast
<
int
>
(
layers
[
s
]
.
max_bitrate_bps
*
rate_factor
)
;
layers
[
s
]
.
target_bitrate_bps
=
static_cast
<
int
>
(
layers
[
s
]
.
target_bitrate_bps
*
rate_factor
)
;
}
layers
[
s
]
.
max_bitrate_bps
=
std
:
:
max
(
layers
[
s
]
.
min_bitrate_bps
layers
[
s
]
.
max_bitrate_bps
)
;
layers
[
s
]
.
target_bitrate_bps
=
std
:
:
max
(
layers
[
s
]
.
min_bitrate_bps
layers
[
s
]
.
target_bitrate_bps
)
;
layers
[
s
]
.
max_framerate
=
cricket
:
:
kDefaultVideoMaxFramerate
;
}
return
layers
;
}
std
:
:
vector
<
VideoStream
>
GetScreenshareLayers
(
size_t
max_layers
int
width
int
height
bool
temporal_layers_supported
bool
base_heavy_tl3_rate_alloc
const
FieldTrialsView
&
trials
)
{
size_t
num_simulcast_layers
=
std
:
:
min
<
int
>
(
max_layers
kScreenshareMaxSimulcastLayers
)
;
std
:
:
vector
<
VideoStream
>
layers
(
num_simulcast_layers
)
;
layers
[
0
]
.
width
=
width
;
layers
[
0
]
.
height
=
height
;
layers
[
0
]
.
max_framerate
=
5
;
layers
[
0
]
.
min_bitrate_bps
=
webrtc
:
:
kDefaultMinVideoBitrateBps
;
layers
[
0
]
.
target_bitrate_bps
=
kScreenshareDefaultTl0Bitrate
.
bps
(
)
;
layers
[
0
]
.
max_bitrate_bps
=
kScreenshareDefaultTl1Bitrate
.
bps
(
)
;
layers
[
0
]
.
num_temporal_layers
=
temporal_layers_supported
?
2
:
1
;
if
(
num_simulcast_layers
=
=
kScreenshareMaxSimulcastLayers
)
{
int
max_bitrate_bps
;
bool
using_boosted_bitrate
=
false
;
if
(
!
temporal_layers_supported
)
{
max_bitrate_bps
=
static_cast
<
int
>
(
kScreenshareHighStreamMaxBitrate
.
bps
(
)
*
webrtc
:
:
SimulcastRateAllocator
:
:
GetTemporalRateAllocation
(
kScreenshareTemporalLayers
0
base_heavy_tl3_rate_alloc
)
)
;
}
else
{
max_bitrate_bps
=
kScreenshareHighStreamMaxBitrate
.
bps
(
)
;
using_boosted_bitrate
=
true
;
}
layers
[
1
]
.
width
=
width
;
layers
[
1
]
.
height
=
height
;
layers
[
1
]
.
max_framerate
=
cricket
:
:
kDefaultVideoMaxFramerate
;
layers
[
1
]
.
num_temporal_layers
=
temporal_layers_supported
?
kScreenshareTemporalLayers
:
1
;
layers
[
1
]
.
min_bitrate_bps
=
using_boosted_bitrate
?
kScreenshareHighStreamMinBitrate
.
bps
(
)
:
layers
[
0
]
.
target_bitrate_bps
*
2
;
layers
[
1
]
.
target_bitrate_bps
=
max_bitrate_bps
;
layers
[
1
]
.
max_bitrate_bps
=
max_bitrate_bps
;
}
return
layers
;
}
}
size_t
LimitSimulcastLayerCount
(
size_t
min_num_layers
size_t
max_num_layers
int
width
int
height
const
FieldTrialsView
&
trials
VideoCodecType
codec
)
{
if
(
!
absl
:
:
StartsWith
(
trials
.
Lookup
(
kUseLegacySimulcastLayerLimitFieldTrial
)
"
Disabled
"
)
)
{
FieldTrialOptional
<
double
>
max_ratio
(
"
max_ratio
"
)
;
webrtc
:
:
ParseFieldTrial
(
{
&
max_ratio
}
trials
.
Lookup
(
"
WebRTC
-
SimulcastLayerLimitRoundUp
"
)
)
;
size_t
reduced_num_layers
=
std
:
:
max
(
min_num_layers
InterpolateSimulcastFormat
(
width
height
max_ratio
.
GetOptional
(
)
false
codec
)
.
max_layers
)
;
if
(
max_num_layers
>
reduced_num_layers
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Reducing
simulcast
layer
count
from
"
<
<
max_num_layers
<
<
"
to
"
<
<
reduced_num_layers
;
return
reduced_num_layers
;
}
}
return
max_num_layers
;
}
void
BoostMaxSimulcastLayer
(
DataRate
max_bitrate
std
:
:
vector
<
VideoStream
>
*
layers
)
{
if
(
layers
-
>
empty
(
)
)
return
;
const
DataRate
total_bitrate
=
GetTotalMaxBitrate
(
*
layers
)
;
if
(
total_bitrate
<
max_bitrate
)
{
const
DataRate
bitrate_left
=
max_bitrate
-
total_bitrate
;
layers
-
>
back
(
)
.
max_bitrate_bps
+
=
bitrate_left
.
bps
(
)
;
}
}
DataRate
GetTotalMaxBitrate
(
const
std
:
:
vector
<
VideoStream
>
&
layers
)
{
if
(
layers
.
empty
(
)
)
return
webrtc
:
:
DataRate
:
:
Zero
(
)
;
int
total_max_bitrate_bps
=
0
;
for
(
size_t
s
=
0
;
s
<
layers
.
size
(
)
-
1
;
+
+
s
)
{
total_max_bitrate_bps
+
=
layers
[
s
]
.
target_bitrate_bps
;
}
total_max_bitrate_bps
+
=
layers
.
back
(
)
.
max_bitrate_bps
;
return
webrtc
:
:
DataRate
:
:
BitsPerSec
(
total_max_bitrate_bps
)
;
}
std
:
:
vector
<
VideoStream
>
GetSimulcastConfig
(
rtc
:
:
ArrayView
<
const
Resolution
>
resolutions
bool
is_screenshare_with_conference_mode
bool
temporal_layers_supported
const
FieldTrialsView
&
trials
VideoCodecType
codec
)
{
RTC_DCHECK
(
!
resolutions
.
empty
(
)
)
;
const
bool
base_heavy_tl3_rate_alloc
=
RateControlSettings
(
trials
)
.
Vp8BaseHeavyTl3RateAllocation
(
)
;
if
(
is_screenshare_with_conference_mode
)
{
return
GetScreenshareLayers
(
resolutions
.
size
(
)
resolutions
[
0
]
.
width
resolutions
[
0
]
.
height
temporal_layers_supported
base_heavy_tl3_rate_alloc
trials
)
;
}
else
{
return
GetNormalSimulcastLayers
(
resolutions
temporal_layers_supported
base_heavy_tl3_rate_alloc
trials
codec
)
;
}
}
}
