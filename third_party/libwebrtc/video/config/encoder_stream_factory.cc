#
include
"
video
/
config
/
encoder_stream_factory
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
video
/
video_codec_constants
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
media
/
base
/
video_adapter
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp9
/
svc_config
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
simulcast_utility
.
h
"
#
include
"
rtc_base
/
experiments
/
min_video_bitrate_experiment
.
h
"
#
include
"
rtc_base
/
experiments
/
normalize_simulcast_size_experiment
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
video
/
config
/
simulcast
.
h
"
namespace
cricket
{
namespace
{
using
:
:
webrtc
:
:
FieldTrialsView
;
const
int
kMinLayerSize
=
16
;
int
ScaleDownResolution
(
int
resolution
double
scale_down_by
int
min_resolution
)
{
if
(
resolution
<
=
min_resolution
)
return
resolution
;
return
std
:
:
max
(
static_cast
<
int
>
(
resolution
/
scale_down_by
+
0
.
5
)
min_resolution
)
;
}
bool
PowerOfTwo
(
int
value
)
{
return
(
value
>
0
)
&
&
(
(
value
&
(
value
-
1
)
)
=
=
0
)
;
}
bool
IsScaleFactorsPowerOfTwo
(
const
webrtc
:
:
VideoEncoderConfig
&
config
)
{
for
(
const
auto
&
layer
:
config
.
simulcast_layers
)
{
double
scale
=
std
:
:
max
(
layer
.
scale_resolution_down_by
1
.
0
)
;
if
(
std
:
:
round
(
scale
)
!
=
scale
|
|
!
PowerOfTwo
(
scale
)
)
{
return
false
;
}
}
return
true
;
}
bool
IsTemporalLayersSupported
(
webrtc
:
:
VideoCodecType
codec_type
)
{
return
codec_type
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecVP8
|
|
codec_type
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecVP9
|
|
codec_type
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecAV1
;
}
size_t
FindRequiredActiveLayers
(
const
webrtc
:
:
VideoEncoderConfig
&
encoder_config
)
{
for
(
size_t
i
=
0
;
i
<
encoder_config
.
number_of_streams
;
+
+
i
)
{
if
(
encoder_config
.
simulcast_layers
[
i
]
.
active
)
{
return
i
+
1
;
}
}
return
0
;
}
static
int
GetMaxDefaultVideoBitrateKbps
(
int
width
int
height
bool
is_screenshare
)
{
int
max_bitrate
;
if
(
width
*
height
<
=
320
*
240
)
{
max_bitrate
=
600
;
}
else
if
(
width
*
height
<
=
640
*
480
)
{
max_bitrate
=
1700
;
}
else
if
(
width
*
height
<
=
960
*
540
)
{
max_bitrate
=
2000
;
}
else
{
max_bitrate
=
2500
;
}
if
(
is_screenshare
)
max_bitrate
=
std
:
:
max
(
max_bitrate
1200
)
;
return
max_bitrate
;
}
int
GetDefaultMaxQp
(
webrtc
:
:
VideoCodecType
codec_type
)
{
switch
(
codec_type
)
{
case
webrtc
:
:
kVideoCodecH264
:
case
webrtc
:
:
kVideoCodecH265
:
return
kDefaultVideoMaxQpH26x
;
case
webrtc
:
:
kVideoCodecVP8
:
case
webrtc
:
:
kVideoCodecVP9
:
case
webrtc
:
:
kVideoCodecAV1
:
case
webrtc
:
:
kVideoCodecGeneric
:
return
kDefaultVideoMaxQpVpx
;
}
}
}
EncoderStreamFactory
:
:
EncoderStreamFactory
(
const
webrtc
:
:
VideoEncoder
:
:
EncoderInfo
&
encoder_info
absl
:
:
optional
<
webrtc
:
:
VideoSourceRestrictions
>
restrictions
)
:
encoder_info_requested_resolution_alignment_
(
encoder_info
.
requested_resolution_alignment
)
restrictions_
(
restrictions
)
{
}
std
:
:
vector
<
webrtc
:
:
VideoStream
>
EncoderStreamFactory
:
:
CreateEncoderStreams
(
const
FieldTrialsView
&
trials
int
frame_width
int
frame_height
const
webrtc
:
:
VideoEncoderConfig
&
encoder_config
)
{
RTC_DCHECK_GT
(
encoder_config
.
number_of_streams
0
)
;
RTC_DCHECK_GE
(
encoder_config
.
simulcast_layers
.
size
(
)
encoder_config
.
number_of_streams
)
;
const
absl
:
:
optional
<
webrtc
:
:
DataRate
>
experimental_min_bitrate
=
GetExperimentalMinVideoBitrate
(
trials
encoder_config
.
codec_type
)
;
bool
is_simulcast
=
(
encoder_config
.
number_of_streams
>
1
)
;
if
(
is_simulcast
&
&
encoder_config
.
simulcast_layers
[
0
]
.
scalability_mode
.
has_value
(
)
)
{
is_simulcast
=
false
;
for
(
size_t
i
=
1
;
i
<
encoder_config
.
simulcast_layers
.
size
(
)
;
+
+
i
)
{
if
(
encoder_config
.
simulcast_layers
[
i
]
.
active
)
{
is_simulcast
=
true
;
break
;
}
}
}
if
(
is_simulcast
|
|
webrtc
:
:
SimulcastUtility
:
:
IsConferenceModeScreenshare
(
encoder_config
)
)
{
return
CreateSimulcastOrConferenceModeScreenshareStreams
(
trials
frame_width
frame_height
encoder_config
experimental_min_bitrate
)
;
}
return
CreateDefaultVideoStreams
(
frame_width
frame_height
encoder_config
experimental_min_bitrate
)
;
}
std
:
:
vector
<
webrtc
:
:
VideoStream
>
EncoderStreamFactory
:
:
CreateDefaultVideoStreams
(
int
width
int
height
const
webrtc
:
:
VideoEncoderConfig
&
encoder_config
const
absl
:
:
optional
<
webrtc
:
:
DataRate
>
&
experimental_min_bitrate
)
const
{
bool
is_screencast
=
encoder_config
.
content_type
=
=
webrtc
:
:
VideoEncoderConfig
:
:
ContentType
:
:
kScreen
;
absl
:
:
optional
<
int
>
api_max_bitrate_bps
;
if
(
encoder_config
.
simulcast_layers
[
0
]
.
max_bitrate_bps
>
0
)
{
api_max_bitrate_bps
=
encoder_config
.
simulcast_layers
[
0
]
.
max_bitrate_bps
;
}
if
(
encoder_config
.
max_bitrate_bps
>
0
)
{
api_max_bitrate_bps
=
api_max_bitrate_bps
.
has_value
(
)
?
std
:
:
min
(
encoder_config
.
max_bitrate_bps
*
api_max_bitrate_bps
)
:
encoder_config
.
max_bitrate_bps
;
}
int
max_bitrate_bps
=
api_max_bitrate_bps
.
has_value
(
)
?
*
api_max_bitrate_bps
:
GetMaxDefaultVideoBitrateKbps
(
width
height
is_screencast
)
*
1000
;
int
min_bitrate_bps
=
experimental_min_bitrate
?
rtc
:
:
saturated_cast
<
int
>
(
experimental_min_bitrate
-
>
bps
(
)
)
:
webrtc
:
:
kDefaultMinVideoBitrateBps
;
if
(
encoder_config
.
simulcast_layers
[
0
]
.
min_bitrate_bps
>
0
)
{
min_bitrate_bps
=
encoder_config
.
simulcast_layers
[
0
]
.
min_bitrate_bps
;
if
(
!
api_max_bitrate_bps
.
has_value
(
)
)
max_bitrate_bps
=
std
:
:
max
(
min_bitrate_bps
max_bitrate_bps
)
;
}
int
max_framerate
=
(
encoder_config
.
simulcast_layers
[
0
]
.
max_framerate
>
0
)
?
encoder_config
.
simulcast_layers
[
0
]
.
max_framerate
:
kDefaultVideoMaxFramerate
;
webrtc
:
:
VideoStream
layer
;
layer
.
width
=
width
;
layer
.
height
=
height
;
layer
.
max_framerate
=
max_framerate
;
layer
.
requested_resolution
=
encoder_config
.
simulcast_layers
[
0
]
.
requested_resolution
;
layer
.
active
=
absl
:
:
c_any_of
(
encoder_config
.
simulcast_layers
[
]
(
const
auto
&
layer
)
{
return
layer
.
active
;
}
)
;
if
(
encoder_config
.
simulcast_layers
[
0
]
.
requested_resolution
)
{
auto
res
=
GetLayerResolutionFromRequestedResolution
(
width
height
*
encoder_config
.
simulcast_layers
[
0
]
.
requested_resolution
)
;
layer
.
width
=
res
.
width
;
layer
.
height
=
res
.
height
;
}
else
if
(
encoder_config
.
simulcast_layers
[
0
]
.
scale_resolution_down_by
>
1
.
)
{
layer
.
width
=
ScaleDownResolution
(
layer
.
width
encoder_config
.
simulcast_layers
[
0
]
.
scale_resolution_down_by
kMinLayerSize
)
;
layer
.
height
=
ScaleDownResolution
(
layer
.
height
encoder_config
.
simulcast_layers
[
0
]
.
scale_resolution_down_by
kMinLayerSize
)
;
}
if
(
encoder_config
.
codec_type
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecVP9
)
{
RTC_DCHECK
(
encoder_config
.
encoder_specific_settings
)
;
webrtc
:
:
VideoCodecVP9
vp9_settings
;
encoder_config
.
encoder_specific_settings
-
>
FillVideoCodecVp9
(
&
vp9_settings
)
;
layer
.
num_temporal_layers
=
vp9_settings
.
numberOfTemporalLayers
;
int
num_spatial_layers
=
std
:
:
max
(
{
encoder_config
.
simulcast_layers
.
size
(
)
encoder_config
.
spatial_layers
.
size
(
)
size_t
{
vp9_settings
.
numberOfSpatialLayers
}
}
)
;
if
(
width
*
height
>
0
&
&
(
layer
.
num_temporal_layers
>
1u
|
|
num_spatial_layers
>
1
)
)
{
std
:
:
vector
<
webrtc
:
:
SpatialLayer
>
svc_layers
=
webrtc
:
:
GetSvcConfig
(
width
height
max_framerate
0
num_spatial_layers
*
layer
.
num_temporal_layers
is_screencast
)
;
int
sum_max_bitrates_kbps
=
0
;
for
(
const
webrtc
:
:
SpatialLayer
&
spatial_layer
:
svc_layers
)
{
sum_max_bitrates_kbps
+
=
spatial_layer
.
maxBitrate
;
}
RTC_DCHECK_GE
(
sum_max_bitrates_kbps
0
)
;
if
(
!
api_max_bitrate_bps
.
has_value
(
)
)
{
max_bitrate_bps
=
sum_max_bitrates_kbps
*
1000
;
}
else
{
max_bitrate_bps
=
std
:
:
min
(
max_bitrate_bps
sum_max_bitrates_kbps
*
1000
)
;
}
max_bitrate_bps
=
std
:
:
max
(
min_bitrate_bps
max_bitrate_bps
)
;
}
}
layer
.
min_bitrate_bps
=
std
:
:
min
(
min_bitrate_bps
max_bitrate_bps
)
;
if
(
encoder_config
.
simulcast_layers
[
0
]
.
target_bitrate_bps
<
=
0
)
{
layer
.
target_bitrate_bps
=
max_bitrate_bps
;
}
else
{
layer
.
target_bitrate_bps
=
std
:
:
min
(
encoder_config
.
simulcast_layers
[
0
]
.
target_bitrate_bps
max_bitrate_bps
)
;
}
layer
.
max_bitrate_bps
=
max_bitrate_bps
;
layer
.
bitrate_priority
=
encoder_config
.
bitrate_priority
;
if
(
encoder_config
.
max_qp
>
0
)
{
layer
.
max_qp
=
encoder_config
.
max_qp
;
}
else
{
layer
.
max_qp
=
GetDefaultMaxQp
(
encoder_config
.
codec_type
)
;
}
if
(
IsTemporalLayersSupported
(
encoder_config
.
codec_type
)
)
{
if
(
encoder_config
.
simulcast_layers
[
0
]
.
num_temporal_layers
)
{
layer
.
num_temporal_layers
=
*
encoder_config
.
simulcast_layers
[
0
]
.
num_temporal_layers
;
}
}
layer
.
scalability_mode
=
encoder_config
.
simulcast_layers
[
0
]
.
scalability_mode
;
return
{
layer
}
;
}
std
:
:
vector
<
webrtc
:
:
VideoStream
>
EncoderStreamFactory
:
:
CreateSimulcastOrConferenceModeScreenshareStreams
(
const
FieldTrialsView
&
trials
int
width
int
height
const
webrtc
:
:
VideoEncoderConfig
&
encoder_config
const
absl
:
:
optional
<
webrtc
:
:
DataRate
>
&
experimental_min_bitrate
)
const
{
bool
is_screencast
=
encoder_config
.
content_type
=
=
webrtc
:
:
VideoEncoderConfig
:
:
ContentType
:
:
kScreen
;
std
:
:
vector
<
webrtc
:
:
VideoStream
>
layers
;
const
bool
temporal_layers_supported
=
IsTemporalLayersSupported
(
encoder_config
.
codec_type
)
;
layers
=
GetSimulcastConfig
(
FindRequiredActiveLayers
(
encoder_config
)
encoder_config
.
number_of_streams
width
height
encoder_config
.
bitrate_priority
encoder_config
.
max_qp
webrtc
:
:
SimulcastUtility
:
:
IsConferenceModeScreenshare
(
encoder_config
)
temporal_layers_supported
trials
encoder_config
.
codec_type
)
;
if
(
experimental_min_bitrate
)
{
layers
[
0
]
.
min_bitrate_bps
=
rtc
:
:
saturated_cast
<
int
>
(
experimental_min_bitrate
-
>
bps
(
)
)
;
}
bool
is_highest_layer_max_bitrate_configured
=
false
;
const
bool
has_scale_resolution_down_by
=
absl
:
:
c_any_of
(
encoder_config
.
simulcast_layers
[
]
(
const
webrtc
:
:
VideoStream
&
layer
)
{
return
layer
.
scale_resolution_down_by
!
=
-
1
.
;
}
)
;
bool
default_scale_factors_used
=
true
;
if
(
has_scale_resolution_down_by
)
{
default_scale_factors_used
=
IsScaleFactorsPowerOfTwo
(
encoder_config
)
;
}
const
bool
norm_size_configured
=
webrtc
:
:
NormalizeSimulcastSizeExperiment
:
:
GetBase2Exponent
(
trials
)
.
has_value
(
)
;
const
int
normalized_width
=
(
default_scale_factors_used
|
|
norm_size_configured
)
&
&
(
width
>
=
kMinLayerSize
)
?
NormalizeSimulcastSize
(
trials
width
encoder_config
.
number_of_streams
)
:
width
;
const
int
normalized_height
=
(
default_scale_factors_used
|
|
norm_size_configured
)
&
&
(
height
>
=
kMinLayerSize
)
?
NormalizeSimulcastSize
(
trials
height
encoder_config
.
number_of_streams
)
:
height
;
for
(
size_t
i
=
0
;
i
<
layers
.
size
(
)
;
+
+
i
)
{
layers
[
i
]
.
active
=
encoder_config
.
simulcast_layers
[
i
]
.
active
;
layers
[
i
]
.
scalability_mode
=
encoder_config
.
simulcast_layers
[
i
]
.
scalability_mode
;
layers
[
i
]
.
requested_resolution
=
encoder_config
.
simulcast_layers
[
i
]
.
requested_resolution
;
if
(
encoder_config
.
simulcast_layers
[
i
]
.
num_temporal_layers
&
&
temporal_layers_supported
)
{
layers
[
i
]
.
num_temporal_layers
=
*
encoder_config
.
simulcast_layers
[
i
]
.
num_temporal_layers
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
max_framerate
>
0
)
{
layers
[
i
]
.
max_framerate
=
encoder_config
.
simulcast_layers
[
i
]
.
max_framerate
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
requested_resolution
.
has_value
(
)
)
{
auto
res
=
GetLayerResolutionFromRequestedResolution
(
normalized_width
normalized_height
*
encoder_config
.
simulcast_layers
[
i
]
.
requested_resolution
)
;
layers
[
i
]
.
width
=
res
.
width
;
layers
[
i
]
.
height
=
res
.
height
;
}
else
if
(
has_scale_resolution_down_by
)
{
const
double
scale_resolution_down_by
=
std
:
:
max
(
encoder_config
.
simulcast_layers
[
i
]
.
scale_resolution_down_by
1
.
0
)
;
layers
[
i
]
.
width
=
ScaleDownResolution
(
normalized_width
scale_resolution_down_by
kMinLayerSize
)
;
layers
[
i
]
.
height
=
ScaleDownResolution
(
normalized_height
scale_resolution_down_by
kMinLayerSize
)
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
min_bitrate_bps
>
0
)
{
layers
[
i
]
.
min_bitrate_bps
=
encoder_config
.
simulcast_layers
[
i
]
.
min_bitrate_bps
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
max_bitrate_bps
>
0
)
{
layers
[
i
]
.
max_bitrate_bps
=
encoder_config
.
simulcast_layers
[
i
]
.
max_bitrate_bps
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
target_bitrate_bps
>
0
)
{
layers
[
i
]
.
target_bitrate_bps
=
encoder_config
.
simulcast_layers
[
i
]
.
target_bitrate_bps
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
min_bitrate_bps
>
0
&
&
encoder_config
.
simulcast_layers
[
i
]
.
max_bitrate_bps
>
0
)
{
if
(
encoder_config
.
simulcast_layers
[
i
]
.
target_bitrate_bps
<
=
0
)
layers
[
i
]
.
target_bitrate_bps
=
layers
[
i
]
.
max_bitrate_bps
*
3
/
4
;
if
(
layers
[
i
]
.
target_bitrate_bps
<
layers
[
i
]
.
min_bitrate_bps
)
layers
[
i
]
.
target_bitrate_bps
=
layers
[
i
]
.
max_bitrate_bps
;
}
else
if
(
encoder_config
.
simulcast_layers
[
i
]
.
min_bitrate_bps
>
0
)
{
layers
[
i
]
.
target_bitrate_bps
=
std
:
:
max
(
layers
[
i
]
.
target_bitrate_bps
layers
[
i
]
.
min_bitrate_bps
)
;
layers
[
i
]
.
max_bitrate_bps
=
std
:
:
max
(
layers
[
i
]
.
max_bitrate_bps
layers
[
i
]
.
min_bitrate_bps
)
;
}
else
if
(
encoder_config
.
simulcast_layers
[
i
]
.
max_bitrate_bps
>
0
)
{
layers
[
i
]
.
min_bitrate_bps
=
std
:
:
min
(
layers
[
i
]
.
min_bitrate_bps
layers
[
i
]
.
max_bitrate_bps
)
;
if
(
encoder_config
.
simulcast_layers
[
i
]
.
target_bitrate_bps
<
=
0
)
{
layers
[
i
]
.
target_bitrate_bps
=
std
:
:
max
(
layers
[
i
]
.
target_bitrate_bps
layers
[
i
]
.
max_bitrate_bps
*
3
/
4
)
;
}
layers
[
i
]
.
target_bitrate_bps
=
std
:
:
max
(
std
:
:
min
(
layers
[
i
]
.
target_bitrate_bps
layers
[
i
]
.
max_bitrate_bps
)
layers
[
i
]
.
min_bitrate_bps
)
;
}
if
(
encoder_config
.
simulcast_layers
[
i
]
.
max_qp
>
0
)
{
layers
[
i
]
.
max_qp
=
encoder_config
.
simulcast_layers
[
i
]
.
max_qp
;
}
else
if
(
encoder_config
.
max_qp
>
0
)
{
layers
[
i
]
.
max_qp
=
encoder_config
.
max_qp
;
}
else
{
layers
[
i
]
.
max_qp
=
GetDefaultMaxQp
(
encoder_config
.
codec_type
)
;
}
if
(
i
=
=
layers
.
size
(
)
-
1
)
{
is_highest_layer_max_bitrate_configured
=
encoder_config
.
simulcast_layers
[
i
]
.
max_bitrate_bps
>
0
;
}
}
if
(
!
is_screencast
&
&
!
is_highest_layer_max_bitrate_configured
&
&
encoder_config
.
max_bitrate_bps
>
0
)
{
BoostMaxSimulcastLayer
(
webrtc
:
:
DataRate
:
:
BitsPerSec
(
encoder_config
.
max_bitrate_bps
)
&
layers
)
;
}
std
:
:
vector
<
size_t
>
index
(
layers
.
size
(
)
)
;
std
:
:
iota
(
index
.
begin
(
)
index
.
end
(
)
0
)
;
std
:
:
stable_sort
(
index
.
begin
(
)
index
.
end
(
)
[
&
layers
]
(
size_t
a
size_t
b
)
{
return
layers
[
a
]
.
max_bitrate_bps
<
layers
[
b
]
.
max_bitrate_bps
;
}
)
;
if
(
!
layers
[
index
[
0
]
]
.
active
)
{
const
int
min_configured_bitrate
=
layers
[
index
[
0
]
]
.
min_bitrate_bps
;
for
(
size_t
i
=
0
;
i
<
layers
.
size
(
)
;
+
+
i
)
{
if
(
layers
[
index
[
i
]
]
.
active
)
{
layers
[
index
[
i
]
]
.
min_bitrate_bps
=
min_configured_bitrate
;
break
;
}
}
}
return
layers
;
}
webrtc
:
:
Resolution
EncoderStreamFactory
:
:
GetLayerResolutionFromRequestedResolution
(
int
frame_width
int
frame_height
webrtc
:
:
Resolution
requested_resolution
)
const
{
VideoAdapter
adapter
(
encoder_info_requested_resolution_alignment_
)
;
adapter
.
OnOutputFormatRequest
(
requested_resolution
.
ToPair
(
)
requested_resolution
.
PixelCount
(
)
absl
:
:
nullopt
)
;
if
(
restrictions_
)
{
rtc
:
:
VideoSinkWants
wants
;
wants
.
is_active
=
true
;
wants
.
target_pixel_count
=
restrictions_
-
>
target_pixels_per_frame
(
)
;
wants
.
max_pixel_count
=
rtc
:
:
dchecked_cast
<
int
>
(
restrictions_
-
>
max_pixels_per_frame
(
)
.
value_or
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
)
;
wants
.
aggregates
.
emplace
(
rtc
:
:
VideoSinkWants
:
:
Aggregates
(
)
)
;
wants
.
resolution_alignment
=
encoder_info_requested_resolution_alignment_
;
adapter
.
OnSinkWants
(
wants
)
;
}
int
cropped_width
cropped_height
;
int
out_width
=
0
out_height
=
0
;
if
(
!
adapter
.
AdaptFrameResolution
(
frame_width
frame_height
0
&
cropped_width
&
cropped_height
&
out_width
&
out_height
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
AdaptFrameResolution
returned
false
!
"
;
}
return
{
.
width
=
out_width
.
height
=
out_height
}
;
}
}
