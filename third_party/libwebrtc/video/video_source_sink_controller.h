#
ifndef
VIDEO_VIDEO_SOURCE_SINK_CONTROLLER_H_
#
define
VIDEO_VIDEO_SOURCE_SINK_CONTROLLER_H_
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
api
/
video
/
video_source_interface
.
h
"
#
include
"
call
/
adaptation
/
video_source_restrictions
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
namespace
webrtc
{
class
VideoSourceSinkController
{
public
:
VideoSourceSinkController
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
sink
rtc
:
:
VideoSourceInterface
<
VideoFrame
>
*
source
)
;
~
VideoSourceSinkController
(
)
;
void
SetSource
(
rtc
:
:
VideoSourceInterface
<
VideoFrame
>
*
source
)
;
bool
HasSource
(
)
const
;
void
RequestRefreshFrame
(
)
;
void
PushSourceSinkSettings
(
)
;
VideoSourceRestrictions
restrictions
(
)
const
;
std
:
:
optional
<
size_t
>
pixels_per_frame_upper_limit
(
)
const
;
std
:
:
optional
<
double
>
frame_rate_upper_limit
(
)
const
;
bool
rotation_applied
(
)
const
;
int
resolution_alignment
(
)
const
;
const
std
:
:
vector
<
rtc
:
:
VideoSinkWants
:
:
FrameSize
>
&
resolutions
(
)
const
;
bool
active
(
)
const
;
std
:
:
optional
<
rtc
:
:
VideoSinkWants
:
:
FrameSize
>
scale_resolution_down_to
(
)
const
;
void
SetRestrictions
(
VideoSourceRestrictions
restrictions
)
;
void
SetPixelsPerFrameUpperLimit
(
std
:
:
optional
<
size_t
>
pixels_per_frame_upper_limit
)
;
void
SetFrameRateUpperLimit
(
std
:
:
optional
<
double
>
frame_rate_upper_limit
)
;
void
SetRotationApplied
(
bool
rotation_applied
)
;
void
SetResolutionAlignment
(
int
resolution_alignment
)
;
void
SetResolutions
(
std
:
:
vector
<
rtc
:
:
VideoSinkWants
:
:
FrameSize
>
resolutions
)
;
void
SetActive
(
bool
active
)
;
void
SetScaleResolutionDownTo
(
std
:
:
optional
<
rtc
:
:
VideoSinkWants
:
:
FrameSize
>
scale_resolution_down_to
)
;
private
:
rtc
:
:
VideoSinkWants
CurrentSettingsToSinkWants
(
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
sequence_checker_
)
;
RTC_NO_UNIQUE_ADDRESS
SequenceChecker
sequence_checker_
;
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
const
sink_
;
rtc
:
:
VideoSourceInterface
<
VideoFrame
>
*
source_
RTC_GUARDED_BY
(
&
sequence_checker_
)
;
VideoSourceRestrictions
restrictions_
RTC_GUARDED_BY
(
&
sequence_checker_
)
;
std
:
:
optional
<
size_t
>
pixels_per_frame_upper_limit_
RTC_GUARDED_BY
(
&
sequence_checker_
)
;
std
:
:
optional
<
double
>
frame_rate_upper_limit_
RTC_GUARDED_BY
(
&
sequence_checker_
)
;
bool
rotation_applied_
RTC_GUARDED_BY
(
&
sequence_checker_
)
=
false
;
int
resolution_alignment_
RTC_GUARDED_BY
(
&
sequence_checker_
)
=
1
;
std
:
:
vector
<
rtc
:
:
VideoSinkWants
:
:
FrameSize
>
resolutions_
RTC_GUARDED_BY
(
&
sequence_checker_
)
;
bool
active_
RTC_GUARDED_BY
(
&
sequence_checker_
)
=
true
;
std
:
:
optional
<
rtc
:
:
VideoSinkWants
:
:
FrameSize
>
scale_resolution_down_to_
RTC_GUARDED_BY
(
&
sequence_checker_
)
;
}
;
}
#
endif
