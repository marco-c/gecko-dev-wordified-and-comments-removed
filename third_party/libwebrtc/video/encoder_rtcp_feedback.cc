#
include
"
video
/
encoder_rtcp_feedback
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
iterator
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_sequence_number_map
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
keyframe_interval_settings
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
{
constexpr
int
kMinKeyframeSendIntervalMs
=
300
;
}
EncoderRtcpFeedback
:
:
EncoderRtcpFeedback
(
const
Environment
&
env
bool
per_layer_keyframes
const
std
:
:
vector
<
uint32_t
>
&
ssrcs
VideoStreamEncoderInterface
*
encoder
std
:
:
function
<
std
:
:
vector
<
RtpSequenceNumberMap
:
:
Info
>
(
uint32_t
ssrc
const
std
:
:
vector
<
uint16_t
>
&
seq_nums
)
>
get_packet_infos
)
:
env_
(
env
)
ssrcs_
(
ssrcs
)
per_layer_keyframes_
(
per_layer_keyframes
)
get_packet_infos_
(
std
:
:
move
(
get_packet_infos
)
)
video_stream_encoder_
(
encoder
)
time_last_packet_delivery_queue_
(
per_layer_keyframes
?
ssrcs
.
size
(
)
:
1
Timestamp
:
:
Zero
(
)
)
min_keyframe_send_interval_
(
TimeDelta
:
:
Millis
(
KeyframeIntervalSettings
(
env_
.
field_trials
(
)
)
.
MinKeyframeSendIntervalMs
(
)
.
value_or
(
kMinKeyframeSendIntervalMs
)
)
)
{
RTC_DCHECK
(
!
ssrcs
.
empty
(
)
)
;
packet_delivery_queue_
.
Detach
(
)
;
}
void
EncoderRtcpFeedback
:
:
OnReceivedIntraFrameRequest
(
uint32_t
ssrc
)
{
RTC_DCHECK_RUN_ON
(
&
packet_delivery_queue_
)
;
RTC_DCHECK
(
std
:
:
find
(
ssrcs_
.
begin
(
)
ssrcs_
.
end
(
)
ssrc
)
!
=
ssrcs_
.
end
(
)
)
;
auto
it
=
std
:
:
find
(
ssrcs_
.
begin
(
)
ssrcs_
.
end
(
)
ssrc
)
;
if
(
it
=
=
ssrcs_
.
end
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
SSRC
"
<
<
ssrc
<
<
"
not
found
.
"
;
return
;
}
size_t
ssrc_index
=
per_layer_keyframes_
?
std
:
:
distance
(
ssrcs_
.
begin
(
)
it
)
:
0
;
RTC_CHECK_LE
(
ssrc_index
time_last_packet_delivery_queue_
.
size
(
)
)
;
const
Timestamp
now
=
env_
.
clock
(
)
.
CurrentTime
(
)
;
if
(
time_last_packet_delivery_queue_
[
ssrc_index
]
+
min_keyframe_send_interval_
>
now
)
return
;
time_last_packet_delivery_queue_
[
ssrc_index
]
=
now
;
std
:
:
vector
<
VideoFrameType
>
layers
(
ssrcs_
.
size
(
)
VideoFrameType
:
:
kVideoFrameDelta
)
;
if
(
!
per_layer_keyframes_
)
{
video_stream_encoder_
-
>
SendKeyFrame
(
)
;
}
else
{
layers
[
ssrc_index
]
=
VideoFrameType
:
:
kVideoFrameKey
;
video_stream_encoder_
-
>
SendKeyFrame
(
layers
)
;
}
}
void
EncoderRtcpFeedback
:
:
OnReceivedLossNotification
(
uint32_t
ssrc
uint16_t
seq_num_of_last_decodable
uint16_t
seq_num_of_last_received
bool
decodability_flag
)
{
RTC_DCHECK
(
get_packet_infos_
)
<
<
"
Object
initialization
incomplete
.
"
;
const
std
:
:
vector
<
uint16_t
>
seq_nums
=
{
seq_num_of_last_decodable
seq_num_of_last_received
}
;
const
std
:
:
vector
<
RtpSequenceNumberMap
:
:
Info
>
infos
=
get_packet_infos_
(
ssrc
seq_nums
)
;
if
(
infos
.
empty
(
)
)
{
return
;
}
RTC_DCHECK_EQ
(
infos
.
size
(
)
2u
)
;
const
RtpSequenceNumberMap
:
:
Info
&
last_decodable
=
infos
[
0
]
;
const
RtpSequenceNumberMap
:
:
Info
&
last_received
=
infos
[
1
]
;
VideoEncoder
:
:
LossNotification
loss_notification
;
loss_notification
.
timestamp_of_last_decodable
=
last_decodable
.
timestamp
;
loss_notification
.
timestamp_of_last_received
=
last_received
.
timestamp
;
if
(
last_received
.
is_first
&
&
last_received
.
is_last
)
{
loss_notification
.
dependencies_of_last_received_decodable
=
decodability_flag
;
loss_notification
.
last_received_decodable
=
decodability_flag
;
}
else
if
(
last_received
.
is_first
&
&
!
last_received
.
is_last
)
{
loss_notification
.
dependencies_of_last_received_decodable
=
decodability_flag
;
loss_notification
.
last_received_decodable
=
!
decodability_flag
?
std
:
:
make_optional
(
false
)
:
std
:
:
nullopt
;
}
else
if
(
!
last_received
.
is_first
&
&
last_received
.
is_last
)
{
if
(
decodability_flag
)
{
loss_notification
.
dependencies_of_last_received_decodable
=
true
;
loss_notification
.
last_received_decodable
=
true
;
}
else
{
loss_notification
.
dependencies_of_last_received_decodable
=
std
:
:
nullopt
;
loss_notification
.
last_received_decodable
=
false
;
}
}
else
{
if
(
decodability_flag
)
{
loss_notification
.
dependencies_of_last_received_decodable
=
true
;
loss_notification
.
last_received_decodable
=
std
:
:
nullopt
;
}
else
{
loss_notification
.
dependencies_of_last_received_decodable
=
std
:
:
nullopt
;
loss_notification
.
last_received_decodable
=
false
;
}
}
video_stream_encoder_
-
>
OnLossNotification
(
loss_notification
)
;
}
}
