#
include
"
video
/
quality_convergence_monitor
.
h
"
#
include
<
numeric
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
struct_parameters_parser
.
h
"
namespace
webrtc
{
namespace
{
constexpr
size_t
kDefaultRecentWindowLength
=
6
;
constexpr
size_t
kDefaultPastWindowLength
=
6
;
constexpr
float
kDefaultAlpha
=
0
.
06
;
struct
DynamicDetectionConfig
{
bool
enabled
=
false
;
double
alpha
=
kDefaultAlpha
;
int
recent_length
=
kDefaultRecentWindowLength
;
int
past_length
=
kDefaultPastWindowLength
;
std
:
:
unique_ptr
<
StructParametersParser
>
Parser
(
)
;
}
;
std
:
:
unique_ptr
<
StructParametersParser
>
DynamicDetectionConfig
:
:
Parser
(
)
{
return
StructParametersParser
:
:
Create
(
"
enabled
"
&
enabled
"
alpha
"
&
alpha
"
recent_length
"
&
recent_length
"
past_length
"
&
past_length
)
;
}
QualityConvergenceMonitor
:
:
Parameters
GetParameters
(
int
static_qp_threshold
VideoCodecType
codec
const
FieldTrialsView
&
trials
)
{
QualityConvergenceMonitor
:
:
Parameters
params
;
params
.
static_qp_threshold
=
static_qp_threshold
;
DynamicDetectionConfig
dynamic_config
;
int
max_qp
=
0
;
switch
(
codec
)
{
case
kVideoCodecVP8
:
dynamic_config
.
Parser
(
)
-
>
Parse
(
trials
.
Lookup
(
"
WebRTC
-
QCM
-
Dynamic
-
VP8
"
)
)
;
max_qp
=
127
;
break
;
case
kVideoCodecVP9
:
dynamic_config
.
enabled
=
true
;
dynamic_config
.
Parser
(
)
-
>
Parse
(
trials
.
Lookup
(
"
WebRTC
-
QCM
-
Dynamic
-
VP9
"
)
)
;
max_qp
=
255
;
break
;
case
kVideoCodecAV1
:
dynamic_config
.
enabled
=
true
;
dynamic_config
.
Parser
(
)
-
>
Parse
(
trials
.
Lookup
(
"
WebRTC
-
QCM
-
Dynamic
-
AV1
"
)
)
;
max_qp
=
255
;
break
;
case
kVideoCodecGeneric
:
case
kVideoCodecH264
:
case
kVideoCodecH265
:
break
;
}
if
(
dynamic_config
.
enabled
)
{
params
.
dynamic_detection_enabled
=
dynamic_config
.
enabled
;
params
.
dynamic_qp_threshold
=
params
.
static_qp_threshold
+
max_qp
*
dynamic_config
.
alpha
;
params
.
recent_window_length
=
dynamic_config
.
recent_length
;
params
.
past_window_length
=
dynamic_config
.
past_length
;
}
return
params
;
}
}
QualityConvergenceMonitor
:
:
QualityConvergenceMonitor
(
const
Parameters
&
params
)
:
params_
(
params
)
{
RTC_CHECK
(
!
params_
.
dynamic_detection_enabled
|
|
(
params_
.
past_window_length
>
0
&
&
params_
.
recent_window_length
>
0
)
)
;
}
void
QualityConvergenceMonitor
:
:
AddSample
(
int
qp
bool
is_refresh_frame
)
{
if
(
qp
<
0
)
{
qp_window_
.
clear
(
)
;
at_target_quality_
=
false
;
return
;
}
if
(
qp
<
=
params_
.
static_qp_threshold
)
{
at_target_quality_
=
true
;
return
;
}
if
(
!
is_refresh_frame
|
|
!
params_
.
dynamic_detection_enabled
)
{
qp_window_
.
clear
(
)
;
at_target_quality_
=
false
;
return
;
}
RTC_CHECK
(
is_refresh_frame
)
;
if
(
at_target_quality_
)
{
return
;
}
qp_window_
.
push_back
(
qp
)
;
if
(
qp_window_
.
size
(
)
>
params_
.
recent_window_length
+
params_
.
past_window_length
)
{
qp_window_
.
pop_front
(
)
;
}
if
(
qp_window_
.
size
(
)
<
=
params_
.
recent_window_length
)
{
RTC_CHECK
(
at_target_quality_
=
=
false
)
;
return
;
}
float
qp_past_average
=
std
:
:
accumulate
(
qp_window_
.
begin
(
)
qp_window_
.
end
(
)
-
params_
.
recent_window_length
0
.
0
)
/
(
qp_window_
.
size
(
)
-
params_
.
recent_window_length
)
;
float
qp_recent_average
=
std
:
:
accumulate
(
qp_window_
.
end
(
)
-
params_
.
recent_window_length
qp_window_
.
end
(
)
0
.
0
)
/
params_
.
recent_window_length
;
if
(
qp_past_average
<
=
params_
.
dynamic_qp_threshold
&
&
qp_past_average
<
=
qp_recent_average
)
{
at_target_quality_
=
true
;
}
}
bool
QualityConvergenceMonitor
:
:
AtTargetQuality
(
)
const
{
return
at_target_quality_
;
}
std
:
:
unique_ptr
<
QualityConvergenceMonitor
>
QualityConvergenceMonitor
:
:
Create
(
int
static_qp_threshold
VideoCodecType
codec
const
FieldTrialsView
&
trials
)
{
Parameters
params
=
GetParameters
(
static_qp_threshold
codec
trials
)
;
return
std
:
:
unique_ptr
<
QualityConvergenceMonitor
>
(
new
QualityConvergenceMonitor
(
params
)
)
;
}
}
