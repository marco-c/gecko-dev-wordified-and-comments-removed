#
include
"
video
/
quality_convergence_monitor
.
h
"
#
include
<
numeric
>
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
QualityConvergenceMonitor
:
:
QualityConvergenceMonitor
(
const
Parameters
&
params
)
:
params_
(
params
)
{
RTC_CHECK
(
!
params_
.
dynamic_detection_enabled
|
|
(
params_
.
past_window_length
>
0
&
&
params_
.
recent_window_length
>
0
)
)
;
}
void
QualityConvergenceMonitor
:
:
AddSample
(
int
qp
bool
is_refresh_frame
)
{
if
(
qp
<
0
)
{
qp_window_
.
clear
(
)
;
at_target_quality_
=
false
;
return
;
}
if
(
qp
<
=
params_
.
static_qp_threshold
)
{
at_target_quality_
=
true
;
return
;
}
if
(
!
is_refresh_frame
|
|
!
params_
.
dynamic_detection_enabled
)
{
qp_window_
.
clear
(
)
;
at_target_quality_
=
false
;
return
;
}
RTC_CHECK
(
is_refresh_frame
)
;
if
(
at_target_quality_
)
{
return
;
}
qp_window_
.
push_back
(
qp
)
;
if
(
qp_window_
.
size
(
)
>
params_
.
recent_window_length
+
params_
.
past_window_length
)
{
qp_window_
.
pop_front
(
)
;
}
if
(
qp_window_
.
size
(
)
<
=
params_
.
recent_window_length
)
{
RTC_CHECK
(
at_target_quality_
=
=
false
)
;
return
;
}
float
qp_past_average
=
std
:
:
accumulate
(
qp_window_
.
begin
(
)
qp_window_
.
end
(
)
-
params_
.
recent_window_length
0
.
0
)
/
(
qp_window_
.
size
(
)
-
params_
.
recent_window_length
)
;
float
qp_recent_average
=
std
:
:
accumulate
(
qp_window_
.
end
(
)
-
params_
.
recent_window_length
qp_window_
.
end
(
)
0
.
0
)
/
params_
.
recent_window_length
;
if
(
qp_past_average
<
=
params_
.
dynamic_qp_threshold
&
&
qp_past_average
<
=
qp_recent_average
)
{
at_target_quality_
=
true
;
}
}
bool
QualityConvergenceMonitor
:
:
AtTargetQuality
(
)
const
{
return
at_target_quality_
;
}
}
