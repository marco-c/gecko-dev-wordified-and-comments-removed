#
ifndef
VIDEO_RTP_STREAMS_SYNCHRONIZER2_H_
#
define
VIDEO_RTP_STREAMS_SYNCHRONIZER2_H_
#
include
<
memory
>
#
include
"
rtc_base
/
synchronization
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
task_utils
/
repeating_task
.
h
"
#
include
"
video
/
stream_synchronization
.
h
"
namespace
webrtc
{
class
Syncable
;
namespace
internal
{
class
RtpStreamsSynchronizer
{
public
:
RtpStreamsSynchronizer
(
TaskQueueBase
*
main_queue
Syncable
*
syncable_video
)
;
~
RtpStreamsSynchronizer
(
)
;
void
ConfigureSync
(
Syncable
*
syncable_audio
)
;
bool
GetStreamSyncOffsetInMs
(
uint32_t
rtp_timestamp
int64_t
render_time_ms
int64_t
*
video_playout_ntp_ms
int64_t
*
stream_offset_ms
double
*
estimated_freq_khz
)
const
;
private
:
void
UpdateDelay
(
)
;
TaskQueueBase
*
const
task_queue_
;
RTC_NO_UNIQUE_ADDRESS
SequenceChecker
main_checker_
;
Syncable
*
const
syncable_video_
;
Syncable
*
syncable_audio_
RTC_GUARDED_BY
(
main_checker_
)
=
nullptr
;
std
:
:
unique_ptr
<
StreamSynchronization
>
sync_
RTC_GUARDED_BY
(
main_checker_
)
;
StreamSynchronization
:
:
Measurements
audio_measurement_
RTC_GUARDED_BY
(
main_checker_
)
;
StreamSynchronization
:
:
Measurements
video_measurement_
RTC_GUARDED_BY
(
main_checker_
)
;
RepeatingTaskHandle
repeating_task_
RTC_GUARDED_BY
(
main_checker_
)
;
int64_t
last_stats_log_ms_
RTC_GUARDED_BY
(
&
main_checker_
)
;
}
;
}
}
#
endif
