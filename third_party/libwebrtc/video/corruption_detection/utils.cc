#
include
"
video
/
corruption_detection
/
utils
.
h
"
#
include
<
algorithm
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_codec_type
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
{
constexpr
char
kPayloadNameVp8
[
]
=
"
VP8
"
;
constexpr
char
kPayloadNameVp9
[
]
=
"
VP9
"
;
constexpr
char
kPayloadNameAv1
[
]
=
"
AV1
"
;
constexpr
char
kPayloadNameH264
[
]
=
"
H264
"
;
constexpr
char
kPayloadNameH265
[
]
=
"
H265
"
;
constexpr
char
kPayloadNameGeneric
[
]
=
"
Generic
"
;
}
VideoCodecType
GetVideoCodecType
(
absl
:
:
string_view
codec_name
)
{
if
(
absl
:
:
StrContainsIgnoreCase
(
codec_name
kPayloadNameVp8
)
)
return
kVideoCodecVP8
;
if
(
absl
:
:
StrContainsIgnoreCase
(
codec_name
kPayloadNameVp9
)
)
return
kVideoCodecVP9
;
if
(
absl
:
:
StrContainsIgnoreCase
(
codec_name
kPayloadNameAv1
)
)
return
kVideoCodecAV1
;
if
(
absl
:
:
StrContainsIgnoreCase
(
codec_name
kPayloadNameH264
)
)
return
kVideoCodecH264
;
if
(
absl
:
:
StrContainsIgnoreCase
(
codec_name
kPayloadNameH265
)
)
return
kVideoCodecH265
;
if
(
absl
:
:
StrContainsIgnoreCase
(
codec_name
kPayloadNameGeneric
)
)
return
kVideoCodecGeneric
;
RTC_FATAL
(
)
<
<
"
Codec
name
"
<
<
codec_name
<
<
"
is
not
supported
.
"
;
}
scoped_refptr
<
I420Buffer
>
GetAsI420Buffer
(
const
scoped_refptr
<
I420BufferInterface
>
i420_buffer_interface
)
{
scoped_refptr
<
I420Buffer
>
frame_as_i420_buffer
=
I420Buffer
:
:
Copy
(
*
i420_buffer_interface
)
;
RTC_DCHECK_EQ
(
frame_as_i420_buffer
-
>
StrideY
(
)
frame_as_i420_buffer
-
>
width
(
)
)
;
return
frame_as_i420_buffer
;
}
int
GetSpatialLayerId
(
const
EncodedImage
&
encoded_image
)
{
return
std
:
:
max
(
encoded_image
.
SpatialIndex
(
)
.
value_or
(
0
)
encoded_image
.
SimulcastIndex
(
)
.
value_or
(
0
)
)
;
}
}
