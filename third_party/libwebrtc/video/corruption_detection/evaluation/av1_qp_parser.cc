#
include
"
video
/
corruption_detection
/
evaluation
/
av1_qp_parser
.
h
"
#
include
<
cstdint
>
#
include
<
optional
>
#
include
"
api
/
array_view
.
h
"
#
include
"
third_party
/
libgav1
/
src
/
src
/
buffer_pool
.
h
"
#
include
"
third_party
/
libgav1
/
src
/
src
/
gav1
/
status_code
.
h
"
#
include
"
third_party
/
libgav1
/
src
/
src
/
obu_parser
.
h
"
namespace
webrtc
{
std
:
:
optional
<
uint32_t
>
Av1QpParser
:
:
Parse
(
ArrayView
<
const
uint8_t
>
frame_data
int
operating_point
)
{
libgav1
:
:
RefCountedBufferPtr
curr_frame
;
libgav1
:
:
ObuParser
parser
(
frame_data
.
data
(
)
frame_data
.
size
(
)
operating_point
&
buffer_pool_
&
decoder_state_
)
;
uint8_t
highest_acceptable_spatial_layers_qp
;
while
(
parser
.
HasData
(
)
)
{
if
(
sequence_header_
)
{
parser
.
set_sequence_header
(
*
sequence_header_
)
;
}
if
(
parser
.
ParseOneFrame
(
&
curr_frame
)
!
=
libgav1
:
:
kStatusOk
)
{
return
std
:
:
nullopt
;
}
const
auto
&
frame_header
=
parser
.
frame_header
(
)
;
if
(
frame_header
.
quantizer
.
base_index
!
=
0
)
{
highest_acceptable_spatial_layers_qp
=
frame_header
.
quantizer
.
base_index
;
}
if
(
parser
.
sequence_header_changed
(
)
)
{
sequence_header_
=
parser
.
sequence_header
(
)
;
}
decoder_state_
.
UpdateReferenceFrames
(
curr_frame
frame_header
.
refresh_frame_flags
)
;
}
return
highest_acceptable_spatial_layers_qp
;
}
}
