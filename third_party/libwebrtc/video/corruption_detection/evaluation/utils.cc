#
include
"
video
/
corruption_detection
/
evaluation
/
utils
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstdio
>
#
include
<
string
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
test
/
testsupport
/
file_utils
.
h
"
namespace
webrtc
{
namespace
{
constexpr
char
kFrameHeader
[
]
=
"
FRAME
\
n
"
;
constexpr
int
kHeaderBytesToRead
=
30
;
}
TempY4mFileCreator
:
:
TempY4mFileCreator
(
int
width
int
height
int
framerate
)
:
width_
(
width
)
height_
(
height
)
framerate_
(
framerate
)
frame_size_
(
width
*
height
*
3
/
2
)
y4m_filepath_
(
test
:
:
TempFilename
(
test
:
:
OutputPath
(
)
"
temp_video
.
y4m
"
)
)
{
RTC_CHECK_EQ
(
test
:
:
GetFileSize
(
y4m_filepath_
)
0
)
;
}
TempY4mFileCreator
:
:
~
TempY4mFileCreator
(
)
{
RTC_CHECK
(
test
:
:
RemoveFile
(
y4m_filepath_
.
c_str
(
)
)
)
;
}
void
TempY4mFileCreator
:
:
CreateTempY4mFile
(
ArrayView
<
const
uint8_t
>
file_content
)
{
RTC_CHECK_EQ
(
file_content
.
size
(
)
%
frame_size_
0
)
<
<
"
Content
size
is
not
a
multiple
of
frame
size
.
Probably
some
data
is
"
"
missing
.
"
;
FILE
*
video_file
=
fopen
(
y4m_filepath_
.
c_str
(
)
"
wb
"
)
;
RTC_CHECK
(
video_file
)
;
WriteFileHeader
(
video_file
)
;
int
frame_number
=
file_content
.
size
(
)
/
frame_size_
;
for
(
int
frame_index
=
0
;
frame_index
<
frame_number
;
+
+
frame_index
)
{
size_t
written_bytes_header
=
fwrite
(
kFrameHeader
1
sizeof
(
kFrameHeader
)
-
1
video_file
)
;
RTC_CHECK_LT
(
frame_size_
*
frame_index
file_content
.
size
(
)
)
;
size_t
written_bytes_content
=
fwrite
(
file_content
.
data
(
)
+
frame_size_
*
frame_index
1
frame_size_
video_file
)
;
RTC_CHECK_EQ
(
written_bytes_header
+
written_bytes_content
sizeof
(
kFrameHeader
)
-
1
+
frame_size_
)
;
}
RTC_CHECK_EQ
(
fclose
(
video_file
)
0
)
;
}
void
TempY4mFileCreator
:
:
WriteFileHeader
(
FILE
*
video_file
)
const
{
StringBuilder
frame_header
;
frame_header
<
<
"
YUV4MPEG2
W
"
<
<
width_
<
<
"
H
"
<
<
height_
<
<
"
F
"
<
<
framerate_
<
<
"
:
1
C420
\
n
"
;
fwrite
(
frame_header
.
str
(
)
.
data
(
)
1
frame_header
.
size
(
)
video_file
)
;
}
Y4mMetadata
ReadMetadataFromY4mHeader
(
absl
:
:
string_view
clip_path
)
{
FILE
*
file
=
fopen
(
std
:
:
string
(
clip_path
)
.
c_str
(
)
"
r
"
)
;
RTC_CHECK
(
file
)
<
<
"
Could
not
open
"
<
<
clip_path
;
char
header
[
kHeaderBytesToRead
]
;
RTC_CHECK
(
fgets
(
header
sizeof
(
header
)
file
)
!
=
nullptr
)
<
<
"
File
"
<
<
clip_path
<
<
"
is
too
small
"
;
fclose
(
file
)
;
int
fps_numerator
;
int
fps_denominator
;
int
width
;
int
height
;
RTC_CHECK_EQ
(
sscanf
(
header
"
YUV4MPEG2
W
%
u
H
%
u
F
%
i
:
%
i
"
&
width
&
height
&
fps_numerator
&
fps_denominator
)
4
)
;
RTC_CHECK_NE
(
fps_denominator
0
)
;
return
{
.
width
=
width
.
height
=
height
.
framerate
=
fps_numerator
/
fps_denominator
}
;
}
}
