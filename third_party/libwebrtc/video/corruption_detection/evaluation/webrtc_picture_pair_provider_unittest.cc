#
include
"
video
/
corruption_detection
/
evaluation
/
webrtc_picture_pair_provider
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
iostream
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
test
/
mock_video_decoder
.
h
"
#
include
"
api
/
test
/
mock_video_decoder_factory
.
h
"
#
include
"
api
/
test
/
mock_video_encoder
.
h
"
#
include
"
api
/
test
/
mock_video_encoder_factory
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_codec_type
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
api
/
video_codecs
/
builtin_video_decoder_factory
.
h
"
#
include
"
api
/
video_codecs
/
builtin_video_encoder_factory
.
h
"
#
include
"
api
/
video_codecs
/
scalability_mode
.
h
"
#
include
"
api
/
video_codecs
/
video_codec
.
h
"
#
include
"
api
/
video_codecs
/
video_decoder
.
h
"
#
include
"
api
/
video_codecs
/
video_decoder_factory_template
.
h
"
#
include
"
api
/
video_codecs
/
video_decoder_factory_template_dav1d_adapter
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_factory_template
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_factory_template_libaom_av1_adapter
.
h
"
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_codec_interface
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_error_codes
.
h
"
#
include
"
modules
/
video_coding
/
svc
/
svc_rate_allocator
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
simulcast_rate_allocator
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
video
/
corruption_detection
/
evaluation
/
picture_pair_provider
.
h
"
#
include
"
video
/
corruption_detection
/
evaluation
/
test_clip
.
h
"
#
include
"
video
/
corruption_detection
/
evaluation
/
utils
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AllOf
;
using
:
:
testing
:
:
ElementsAre
;
using
:
:
testing
:
:
Field
;
using
:
:
testing
:
:
HasSubstr
;
using
:
:
testing
:
:
InSequence
;
using
:
:
testing
:
:
Pointee
;
using
:
:
testing
:
:
Property
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
Values
;
using
:
:
testing
:
:
WithoutArgs
;
constexpr
uint8_t
kEncodedFrame
[
]
=
{
0x12
0x0
0xa
0xa
0x0
0x0
0x0
0x2
0x27
0xfe
0xff
0xfc
0xc0
0x20
0x32
0x93
0x2
0x10
0x0
0xa8
0x80
0x0
0x3
0x0
0x10
0x10
0x30
}
;
constexpr
size_t
kEncodedFrameSize
=
sizeof
(
kEncodedFrame
)
/
sizeof
(
kEncodedFrame
[
0
]
)
;
constexpr
int
kQp
=
31
;
constexpr
uint8_t
kDecodedChannelYContent
[
4
]
=
{
0x16
0x21
0x59
0x11
}
;
constexpr
uint8_t
kDecodedChannelUContent
[
1
]
=
{
0x65
}
;
constexpr
uint8_t
kDecodedChannelVContent
[
1
]
=
{
0x89
}
;
constexpr
int
kDecodedWidth
=
2
;
constexpr
int
kDecodedHeight
=
2
;
constexpr
int
kDecodedStrideY
=
2
;
constexpr
int
kDecodedStrideU
=
1
;
constexpr
int
kDecodedStrideV
=
1
;
constexpr
int
kDummyVideoWidth
=
2
;
constexpr
int
kDummyVideoHeight
=
2
;
constexpr
int
kNumFrames
=
2
;
constexpr
uint8_t
kDummyFileContent
[
kDummyVideoWidth
*
kDummyVideoHeight
*
3
]
=
{
0
1
2
3
4
5
6
7
8
9
10
11
}
;
constexpr
absl
:
:
string_view
kFilename
=
"
ConferenceMotion_1280_720_50
"
;
constexpr
int
kWidth
=
1280
;
constexpr
int
kHeight
=
720
;
constexpr
int
kFramerate
=
50
;
constexpr
uint32_t
kRtpTimestampInterval
=
90
'
000
/
kFramerate
;
constexpr
VideoCodecMode
kCodecMode
=
VideoCodecMode
:
:
kRealtimeVideo
;
constexpr
float
kBitsPerPixel
=
0
.
1
;
constexpr
DataRate
kDefaultBitrate
=
DataRate
:
:
BitsPerSec
(
kWidth
*
kHeight
*
kFramerate
*
kBitsPerPixel
)
;
constexpr
int
kFramesToLoop
=
5
;
constexpr
double
kWatchablePsnrDb
=
30
.
0
;
constexpr
double
kGoodPsnrDb
=
40
.
0
;
TestClip
GetTestClip
(
)
{
return
TestClip
:
:
CreateYuvClip
(
kFilename
kWidth
kHeight
kFramerate
kCodecMode
)
;
}
class
EmptyFieldTrials
:
public
FieldTrialsView
{
public
:
std
:
:
string
Lookup
(
absl
:
:
string_view
key
)
const
override
{
return
"
"
;
}
}
;
class
WebRtcPicturePairProviderTest
:
public
TestWithParam
<
VideoCodecType
>
{
protected
:
WebRtcPicturePairProviderTest
(
)
:
encoder_factory_
(
std
:
:
make_unique
<
MockVideoEncoderFactory
>
(
)
)
decoder_factory_
(
std
:
:
make_unique
<
MockVideoDecoderFactory
>
(
)
)
codec_type_
(
GetParam
(
)
)
{
}
~
WebRtcPicturePairProviderTest
(
)
override
=
default
;
void
ExpectedCallsInConstructor
(
)
{
RTC_CHECK
(
encoder_factory_
)
;
RTC_CHECK
(
decoder_factory_
)
;
EXPECT_CALL
(
*
encoder_factory_
Create
)
.
WillOnce
(
WithoutArgs
(
[
&
]
{
std
:
:
unique_ptr
<
VideoEncoder
>
encoder
=
std
:
:
make_unique
<
MockVideoEncoder
>
(
)
;
encoder_
=
static_cast
<
MockVideoEncoder
*
>
(
encoder
.
get
(
)
)
;
EXPECT_CALL
(
*
encoder_
RegisterEncodeCompleteCallback
)
.
WillOnce
(
[
&
]
(
EncodedImageCallback
*
callback
)
{
encode_callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
)
;
return
encoder
;
}
)
)
;
EXPECT_CALL
(
*
decoder_factory_
Create
)
.
WillOnce
(
WithoutArgs
(
[
&
]
{
std
:
:
unique_ptr
<
VideoDecoder
>
decoder
=
std
:
:
make_unique
<
MockVideoDecoder
>
(
)
;
decoder_
=
static_cast
<
MockVideoDecoder
*
>
(
decoder
.
get
(
)
)
;
EXPECT_CALL
(
*
decoder_
RegisterDecodeCompleteCallback
)
.
WillOnce
(
[
&
]
(
DecodedImageCallback
*
callback
)
{
decode_callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
)
;
return
decoder
;
}
)
)
;
}
void
CreatePicturePairProvider
(
VideoCodecType
codec_type
)
{
picture_pair_provider_
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type
std
:
:
move
(
encoder_factory_
)
std
:
:
move
(
decoder_factory_
)
)
;
}
void
TearDown
(
)
override
{
if
(
!
skipped_test_
)
{
RTC_DCHECK
(
picture_pair_provider_
!
=
nullptr
)
;
EXPECT_CALL
(
*
encoder_
Release
)
;
EXPECT_CALL
(
*
decoder_
Release
)
;
EXPECT_CALL
(
*
encoder_
RegisterEncodeCompleteCallback
(
nullptr
)
)
;
EXPECT_CALL
(
*
decoder_
RegisterDecodeCompleteCallback
(
nullptr
)
)
;
}
}
std
:
:
unique_ptr
<
WebRtcEncoderDecoderPicturePairProvider
>
picture_pair_provider_
=
nullptr
;
std
:
:
unique_ptr
<
MockVideoEncoderFactory
>
encoder_factory_
;
std
:
:
unique_ptr
<
MockVideoDecoderFactory
>
decoder_factory_
;
MockVideoEncoder
*
encoder_
=
nullptr
;
MockVideoDecoder
*
decoder_
=
nullptr
;
EncodedImageCallback
*
encode_callback_
=
nullptr
;
DecodedImageCallback
*
decode_callback_
=
nullptr
;
const
VideoCodecType
codec_type_
;
bool
skipped_test_
=
false
;
}
;
INSTANTIATE_TEST_SUITE_P
(
DifferentCodecTypes
WebRtcPicturePairProviderTest
Values
(
VideoCodecType
:
:
kVideoCodecVP8
VideoCodecType
:
:
kVideoCodecVP9
VideoCodecType
:
:
kVideoCodecAV1
VideoCodecType
:
:
kVideoCodecH264
)
)
;
#
if
GTEST_HAS_DEATH_TEST
TEST_P
(
WebRtcPicturePairProviderTest
RaiseErrorIfConfigureHasNotBeenCalled
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
EXPECT_DEATH
(
picture_pair_provider_
-
>
GetNextPicturePair
(
)
HasSubstr
(
"
Encoder
and
decoder
have
not
been
initialized
.
Try
"
"
calling
Configure
first
"
)
)
;
}
#
endif
TEST_P
(
WebRtcPicturePairProviderTest
ConfigurationIsSuccesfull
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
EXPECT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
ConfigureWhenInitialized
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
VideoCodecType
:
:
kVideoCodecAV1
)
;
ASSERT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
EXPECT_CALL
(
*
encoder_
Release
)
;
EXPECT_CALL
(
*
decoder_
Release
)
;
EXPECT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
#
if
GTEST_HAS_DEATH_TEST
TEST_P
(
WebRtcPicturePairProviderTest
NonExistentFileShouldRaiseError
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
EXPECT_DEATH
(
TestClip
:
:
CreateY4mClip
(
"
does_not_exist
"
kCodecMode
)
_
)
;
}
#
endif
TEST_P
(
WebRtcPicturePairProviderTest
InitializeEncoder
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
if
(
codec_type_
=
=
kVideoCodecVP9
|
|
codec_type_
=
=
kVideoCodecAV1
)
{
EXPECT_CALL
(
*
encoder_
InitEncode
(
AllOf
(
Field
(
&
VideoCodec
:
:
width
kWidth
)
Field
(
&
VideoCodec
:
:
height
kHeight
)
Field
(
&
VideoCodec
:
:
maxFramerate
kFramerate
)
Field
(
&
VideoCodec
:
:
codecType
codec_type_
)
Field
(
&
VideoCodec
:
:
minBitrate
kDefaultBitrate
.
kbps
(
)
)
Field
(
&
VideoCodec
:
:
startBitrate
kDefaultBitrate
.
kbps
(
)
)
Field
(
&
VideoCodec
:
:
maxBitrate
kDefaultBitrate
.
kbps
(
)
)
Field
(
&
VideoCodec
:
:
mode
kCodecMode
)
Property
(
&
VideoCodec
:
:
GetScalabilityMode
ScalabilityMode
:
:
kL1T3
)
Field
(
&
VideoCodec
:
:
qpMax
63
)
)
AllOf
(
Field
(
&
VideoEncoder
:
:
Settings
:
:
number_of_cores
1
)
Field
(
&
VideoEncoder
:
:
Settings
:
:
max_payload_size
1500
)
)
)
)
;
}
else
{
EXPECT_CALL
(
*
encoder_
InitEncode
(
AllOf
(
Field
(
&
VideoCodec
:
:
width
kWidth
)
Field
(
&
VideoCodec
:
:
height
kHeight
)
Field
(
&
VideoCodec
:
:
maxFramerate
kFramerate
)
Field
(
&
VideoCodec
:
:
codecType
codec_type_
)
Field
(
&
VideoCodec
:
:
minBitrate
kDefaultBitrate
.
kbps
(
)
)
Field
(
&
VideoCodec
:
:
startBitrate
kDefaultBitrate
.
kbps
(
)
)
Field
(
&
VideoCodec
:
:
maxBitrate
kDefaultBitrate
.
kbps
(
)
)
Field
(
&
VideoCodec
:
:
mode
kCodecMode
)
Field
(
&
VideoCodec
:
:
qpMax
codec_type_
=
=
kVideoCodecH264
?
51
:
63
)
)
AllOf
(
Field
(
&
VideoEncoder
:
:
Settings
:
:
number_of_cores
1
)
Field
(
&
VideoEncoder
:
:
Settings
:
:
max_payload_size
1500
)
)
)
)
;
}
EXPECT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
FailEncoderInitialization
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
EXPECT_CALL
(
*
encoder_
InitEncode
(
_
_
)
)
.
WillOnce
(
Return
(
WEBRTC_VIDEO_CODEC_ERROR
)
)
;
EXPECT_FALSE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
SetRatesWithSimulcastRateAllocator
)
{
if
(
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecVP8
&
&
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecH264
)
{
skipped_test_
=
true
;
GTEST_SKIP
(
)
<
<
"
SimulcastRateAllocator
is
only
used
for
VP8
and
H264
.
"
;
}
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
VideoCodec
codec_config
;
codec_config
.
width
=
kWidth
;
codec_config
.
height
=
kHeight
;
codec_config
.
maxFramerate
=
kFramerate
;
codec_config
.
codecType
=
codec_type_
;
codec_config
.
minBitrate
=
kDefaultBitrate
.
kbps
(
)
;
codec_config
.
startBitrate
=
kDefaultBitrate
.
kbps
(
)
;
codec_config
.
maxBitrate
=
kDefaultBitrate
.
kbps
(
)
;
codec_config
.
mode
=
kCodecMode
;
if
(
codec_type_
=
=
VideoCodecType
:
:
kVideoCodecH264
)
{
codec_config
.
H264
(
)
-
>
numberOfTemporalLayers
=
3
;
codec_config
.
qpMax
=
51
;
codec_config
.
simulcastStream
[
0
]
.
numberOfTemporalLayers
=
3
;
}
else
{
codec_config
.
VP8
(
)
-
>
numberOfTemporalLayers
=
3
;
codec_config
.
qpMax
=
63
;
}
SimulcastRateAllocator
simulcast_rate_allocator
(
CreateEnvironment
(
)
codec_config
)
;
VideoEncoder
:
:
RateControlParameters
rate_params
(
simulcast_rate_allocator
.
GetAllocation
(
kDefaultBitrate
.
bps
(
)
kFramerate
)
kFramerate
kDefaultBitrate
)
;
EXPECT_CALL
(
*
encoder_
SetRates
(
rate_params
)
)
;
EXPECT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
SetRatesWithSvcRateAllocator
)
{
if
(
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecVP9
&
&
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecAV1
)
{
skipped_test_
=
true
;
GTEST_SKIP
(
)
<
<
"
SvcRateAllocator
is
only
used
for
VP9
and
AV1
.
"
;
}
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
VideoCodec
codec_config
;
codec_config
.
width
=
kWidth
;
codec_config
.
height
=
kHeight
;
codec_config
.
maxFramerate
=
kFramerate
;
codec_config
.
codecType
=
codec_type_
;
codec_config
.
minBitrate
=
kDefaultBitrate
.
kbps
(
)
;
codec_config
.
startBitrate
=
kDefaultBitrate
.
kbps
(
)
;
codec_config
.
maxBitrate
=
kDefaultBitrate
.
kbps
(
)
;
codec_config
.
mode
=
kCodecMode
;
codec_config
.
SetScalabilityMode
(
ScalabilityMode
:
:
kL1T3
)
;
codec_config
.
qpMax
=
63
;
unsigned
int
bitrate_kbps
=
static_cast
<
unsigned
int
>
(
kDefaultBitrate
.
kbps
(
)
)
;
codec_config
.
spatialLayers
[
0
]
.
targetBitrate
=
bitrate_kbps
;
codec_config
.
spatialLayers
[
0
]
.
maxBitrate
=
bitrate_kbps
;
codec_config
.
spatialLayers
[
0
]
.
active
=
true
;
SvcRateAllocator
svc_rate_allocator
(
codec_config
EmptyFieldTrials
(
)
)
;
VideoEncoder
:
:
RateControlParameters
rate_params
=
VideoEncoder
:
:
RateControlParameters
(
svc_rate_allocator
.
GetAllocation
(
kDefaultBitrate
.
bps
(
)
kFramerate
)
kFramerate
kDefaultBitrate
)
;
EXPECT_CALL
(
*
encoder_
SetRates
(
rate_params
)
)
;
EXPECT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
ConfigureDecoderTest
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
EXPECT_CALL
(
*
decoder_
Configure
(
AllOf
(
Property
(
&
VideoDecoder
:
:
Settings
:
:
codec_type
codec_type_
)
)
)
)
;
EXPECT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
ConfigureDecoderFailure
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
EXPECT_CALL
(
*
decoder_
Configure
)
.
WillOnce
(
Return
(
false
)
)
;
EXPECT_FALSE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
EncodeTest
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
ASSERT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
constexpr
int
call_picture_pair_provider
=
3
;
{
InSequence
s
;
EXPECT_CALL
(
*
encoder_
Encode
(
AllOf
(
Property
(
&
VideoFrame
:
:
width
kWidth
)
Property
(
&
VideoFrame
:
:
height
kHeight
)
Property
(
&
VideoFrame
:
:
rtp_timestamp
0
)
)
Pointee
(
ElementsAre
(
VideoFrameType
:
:
kVideoFrameKey
)
)
)
)
;
EXPECT_CALL
(
*
encoder_
Encode
(
AllOf
(
Property
(
&
VideoFrame
:
:
width
kWidth
)
Property
(
&
VideoFrame
:
:
height
kHeight
)
Property
(
&
VideoFrame
:
:
rtp_timestamp
kRtpTimestampInterval
)
)
Pointee
(
ElementsAre
(
VideoFrameType
:
:
kVideoFrameDelta
)
)
)
)
;
EXPECT_CALL
(
*
encoder_
Encode
(
AllOf
(
Property
(
&
VideoFrame
:
:
width
kWidth
)
Property
(
&
VideoFrame
:
:
height
kHeight
)
Property
(
&
VideoFrame
:
:
rtp_timestamp
kRtpTimestampInterval
*
2
)
)
Pointee
(
ElementsAre
(
VideoFrameType
:
:
kVideoFrameDelta
)
)
)
)
;
}
for
(
int
i
=
0
;
i
<
call_picture_pair_provider
;
+
+
i
)
{
EXPECT_EQ
(
picture_pair_provider_
-
>
GetNextPicturePair
(
)
std
:
:
nullopt
)
;
}
}
TEST_P
(
WebRtcPicturePairProviderTest
EncodeFailure
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
ASSERT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
EXPECT_CALL
(
*
encoder_
Encode
(
_
_
)
)
.
WillOnce
(
Return
(
WEBRTC_VIDEO_CODEC_ERROR
)
)
;
EXPECT_EQ
(
picture_pair_provider_
-
>
GetNextPicturePair
(
)
std
:
:
nullopt
)
;
}
void
PopulateEncodedImage
(
EncodedImage
*
encoded_image
VideoCodecType
codec_type
)
{
scoped_refptr
<
EncodedImageBuffer
>
encoded_image_buffer
=
EncodedImageBuffer
:
:
Create
(
kEncodedFrame
kEncodedFrameSize
)
;
encoded_image
-
>
SetEncodedData
(
encoded_image_buffer
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
DecodeFailureTest
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
ASSERT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
EncodedImage
encoded_image
;
PopulateEncodedImage
(
&
encoded_image
codec_type_
)
;
CodecSpecificInfo
codec_specific_info
;
EXPECT_CALL
(
*
encoder_
Encode
(
_
_
)
)
.
WillOnce
(
[
&
]
(
const
VideoFrame
&
frame
const
std
:
:
vector
<
VideoFrameType
>
*
frame_types
)
{
encode_callback_
-
>
OnEncodedImage
(
encoded_image
&
codec_specific_info
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
)
;
EXPECT_CALL
(
*
decoder_
Decode
(
_
_
)
)
.
WillOnce
(
Return
(
WEBRTC_VIDEO_CODEC_ERROR
)
)
;
EXPECT_EQ
(
picture_pair_provider_
-
>
GetNextPicturePair
(
)
std
:
:
nullopt
)
;
}
TEST_P
(
WebRtcPicturePairProviderTest
ProperDecodeTest
)
{
ExpectedCallsInConstructor
(
)
;
CreatePicturePairProvider
(
codec_type_
)
;
ASSERT_TRUE
(
picture_pair_provider_
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
EncodedImage
encoded_image
;
PopulateEncodedImage
(
&
encoded_image
codec_type_
)
;
CodecSpecificInfo
codec_specific_info
;
EXPECT_CALL
(
*
encoder_
Encode
(
_
_
)
)
.
WillOnce
(
[
&
]
(
const
VideoFrame
&
frame
const
std
:
:
vector
<
VideoFrameType
>
*
frame_types
)
{
encoded_image
.
qp_
=
kQp
;
encode_callback_
-
>
OnEncodedImage
(
encoded_image
&
codec_specific_info
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
)
;
scoped_refptr
<
I420Buffer
>
decoded_frame
=
I420Buffer
:
:
Copy
(
kDecodedWidth
kDecodedHeight
kDecodedChannelYContent
kDecodedStrideY
kDecodedChannelUContent
kDecodedStrideU
kDecodedChannelVContent
kDecodedStrideV
)
;
VideoFrame
decoded_image
=
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
decoded_frame
)
.
set_rtp_timestamp
(
0
)
.
build
(
)
;
EXPECT_CALL
(
*
decoder_
Decode
(
_
_
)
)
.
WillOnce
(
[
&
]
(
const
EncodedImage
&
input_image
int64_t
render_time_ms
)
{
decode_callback_
-
>
Decoded
(
decoded_image
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
)
;
std
:
:
optional
<
OriginalCompressedPicturePair
>
picture_pair
=
picture_pair_provider_
-
>
GetNextPicturePair
(
)
;
ASSERT_NE
(
picture_pair
std
:
:
nullopt
)
;
for
(
int
i
=
0
;
i
<
kDecodedWidth
*
kDecodedHeight
;
+
+
i
)
{
EXPECT_EQ
(
picture_pair
-
>
compressed_image
.
video_frame_buffer
(
)
-
>
ToI420
(
)
-
>
DataY
(
)
[
i
]
kDecodedChannelYContent
[
i
]
)
;
}
EXPECT_EQ
(
picture_pair
-
>
compressed_image
.
video_frame_buffer
(
)
-
>
ToI420
(
)
-
>
DataU
(
)
[
0
]
kDecodedChannelUContent
[
0
]
)
;
EXPECT_EQ
(
picture_pair
-
>
compressed_image
.
video_frame_buffer
(
)
-
>
ToI420
(
)
-
>
DataV
(
)
[
0
]
kDecodedChannelVContent
[
0
]
)
;
EXPECT_EQ
(
picture_pair
-
>
frame_average_qp
kQp
)
;
}
class
WebRtcPicturePairProviderEnd2EndTest
:
public
TestWithParam
<
VideoCodecType
>
{
protected
:
WebRtcPicturePairProviderEnd2EndTest
(
)
:
codec_type_
(
GetParam
(
)
)
{
}
~
WebRtcPicturePairProviderEnd2EndTest
(
)
override
=
default
;
int
GetMapQP
(
)
{
switch
(
codec_type_
)
{
case
VideoCodecType
:
:
kVideoCodecVP8
:
return
127
;
case
VideoCodecType
:
:
kVideoCodecAV1
:
case
VideoCodecType
:
:
kVideoCodecVP9
:
return
255
;
case
VideoCodecType
:
:
kVideoCodecH264
:
return
51
;
default
:
RTC_DCHECK_NOTREACHED
(
)
;
return
0
;
}
}
VideoCodecType
codec_type_
;
}
;
INSTANTIATE_TEST_SUITE_P
(
DifferentCodecTypes
WebRtcPicturePairProviderEnd2EndTest
Values
(
VideoCodecType
:
:
kVideoCodecVP8
VideoCodecType
:
:
kVideoCodecVP9
VideoCodecType
:
:
kVideoCodecAV1
)
)
;
TEST_P
(
WebRtcPicturePairProviderEnd2EndTest
PsnrIsInExpectedRange
)
{
std
:
:
unique_ptr
<
WebRtcEncoderDecoderPicturePairProvider
>
webrtc_provider
;
if
(
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecAV1
)
{
webrtc_provider
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type_
CreateBuiltinVideoEncoderFactory
(
)
CreateBuiltinVideoDecoderFactory
(
)
)
;
}
else
{
webrtc_provider
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type_
std
:
:
make_unique
<
VideoEncoderFactoryTemplate
<
LibaomAv1EncoderTemplateAdapter
>
>
(
)
std
:
:
make_unique
<
VideoDecoderFactoryTemplate
<
Dav1dDecoderTemplateAdapter
>
>
(
)
)
;
}
ASSERT_TRUE
(
webrtc_provider
-
>
Configure
(
GetTestClip
(
)
kDefaultBitrate
)
)
;
for
(
int
i
=
0
;
i
<
kFramesToLoop
;
+
+
i
)
{
std
:
:
optional
<
OriginalCompressedPicturePair
>
picture_pair
=
webrtc_provider
-
>
GetNextPicturePair
(
)
;
EXPECT_NE
(
picture_pair
std
:
:
nullopt
)
;
EXPECT_GE
(
picture_pair
-
>
frame_average_qp
0
)
;
EXPECT_LE
(
picture_pair
-
>
frame_average_qp
GetMapQP
(
)
)
;
double
psnr
=
I420PSNR
(
*
picture_pair
-
>
original_image
.
video_frame_buffer
(
)
-
>
GetI420
(
)
*
picture_pair
-
>
compressed_image
.
video_frame_buffer
(
)
-
>
GetI420
(
)
)
;
EXPECT_GE
(
psnr
kWatchablePsnrDb
)
;
EXPECT_EQ
(
picture_pair
-
>
original_image
.
rtp_timestamp
(
)
kRtpTimestampInterval
*
i
)
;
EXPECT_EQ
(
picture_pair
-
>
compressed_image
.
rtp_timestamp
(
)
kRtpTimestampInterval
*
i
)
;
}
}
TEST_P
(
WebRtcPicturePairProviderEnd2EndTest
PsnrIsGoodWhenBitrateIsHigh
)
{
std
:
:
unique_ptr
<
WebRtcEncoderDecoderPicturePairProvider
>
webrtc_provider
;
if
(
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecAV1
)
{
webrtc_provider
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type_
CreateBuiltinVideoEncoderFactory
(
)
CreateBuiltinVideoDecoderFactory
(
)
)
;
}
else
{
webrtc_provider
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type_
std
:
:
make_unique
<
VideoEncoderFactoryTemplate
<
LibaomAv1EncoderTemplateAdapter
>
>
(
)
std
:
:
make_unique
<
VideoDecoderFactoryTemplate
<
Dav1dDecoderTemplateAdapter
>
>
(
)
)
;
}
const
DataRate
high_bitrate
=
DataRate
:
:
BitsPerSec
(
kWidth
*
kHeight
*
kFramerate
*
10
)
;
ASSERT_TRUE
(
webrtc_provider
-
>
Configure
(
GetTestClip
(
)
high_bitrate
)
)
;
for
(
int
i
=
0
;
i
<
kFramesToLoop
;
+
+
i
)
{
std
:
:
optional
<
OriginalCompressedPicturePair
>
picture_pair
=
webrtc_provider
-
>
GetNextPicturePair
(
)
;
EXPECT_NE
(
picture_pair
std
:
:
nullopt
)
;
EXPECT_GE
(
picture_pair
-
>
frame_average_qp
0
)
;
EXPECT_LE
(
picture_pair
-
>
frame_average_qp
GetMapQP
(
)
)
;
double
psnr
=
I420PSNR
(
*
picture_pair
-
>
original_image
.
video_frame_buffer
(
)
-
>
GetI420
(
)
*
picture_pair
-
>
compressed_image
.
video_frame_buffer
(
)
-
>
GetI420
(
)
)
;
EXPECT_GE
(
psnr
kGoodPsnrDb
)
;
}
}
TEST_P
(
WebRtcPicturePairProviderEnd2EndTest
Y4mVideoTest
)
{
std
:
:
unique_ptr
<
WebRtcEncoderDecoderPicturePairProvider
>
webrtc_provider
;
if
(
codec_type_
!
=
VideoCodecType
:
:
kVideoCodecAV1
)
{
webrtc_provider
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type_
CreateBuiltinVideoEncoderFactory
(
)
CreateBuiltinVideoDecoderFactory
(
)
)
;
}
else
{
webrtc_provider
=
std
:
:
make_unique
<
WebRtcEncoderDecoderPicturePairProvider
>
(
codec_type_
std
:
:
make_unique
<
VideoEncoderFactoryTemplate
<
LibaomAv1EncoderTemplateAdapter
>
>
(
)
std
:
:
make_unique
<
VideoDecoderFactoryTemplate
<
Dav1dDecoderTemplateAdapter
>
>
(
)
)
;
}
TempY4mFileCreator
temp_y4m_file_creator
(
kDummyVideoWidth
kDummyVideoHeight
kFramerate
)
;
temp_y4m_file_creator
.
CreateTempY4mFile
(
kDummyFileContent
)
;
const
absl
:
:
string_view
y4m_filepath
=
temp_y4m_file_creator
.
y4m_filepath
(
)
;
const
TestClip
y4m_test_clip
=
TestClip
:
:
CreateY4mClip
(
y4m_filepath
kCodecMode
)
;
ASSERT_TRUE
(
webrtc_provider
-
>
Configure
(
y4m_test_clip
kDefaultBitrate
)
)
;
for
(
int
i
=
0
;
i
<
kNumFrames
;
+
+
i
)
{
std
:
:
optional
<
OriginalCompressedPicturePair
>
picture_pair
=
webrtc_provider
-
>
GetNextPicturePair
(
)
;
EXPECT_NE
(
picture_pair
std
:
:
nullopt
)
;
EXPECT_GE
(
picture_pair
-
>
frame_average_qp
0
)
;
std
:
:
cout
<
<
"
Avg
QP
:
"
<
<
picture_pair
-
>
frame_average_qp
<
<
std
:
:
endl
;
EXPECT_LE
(
picture_pair
-
>
frame_average_qp
GetMapQP
(
)
)
;
double
psnr
=
I420PSNR
(
*
picture_pair
-
>
original_image
.
video_frame_buffer
(
)
-
>
GetI420
(
)
*
picture_pair
-
>
compressed_image
.
video_frame_buffer
(
)
-
>
GetI420
(
)
)
;
EXPECT_GE
(
psnr
kWatchablePsnrDb
)
;
std
:
:
cout
<
<
"
PSNR
:
"
<
<
psnr
<
<
std
:
:
endl
;
EXPECT_EQ
(
picture_pair
-
>
original_image
.
rtp_timestamp
(
)
kRtpTimestampInterval
*
i
)
;
EXPECT_EQ
(
picture_pair
-
>
compressed_image
.
rtp_timestamp
(
)
kRtpTimestampInterval
*
i
)
;
}
webrtc_provider
.
reset
(
)
;
}
}
}
