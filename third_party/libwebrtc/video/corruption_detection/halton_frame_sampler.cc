#
include
"
video
/
corruption_detection
/
halton_frame_sampler
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
nv12_buffer
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
#
include
"
video
/
corruption_detection
/
halton_sequence
.
h
"
#
include
"
video
/
corruption_detection
/
video_frame_sampler
.
h
"
namespace
webrtc
{
namespace
{
const
double
kCutoff
=
0
.
2
;
const
int
kLowerBoundKernelSize
=
3
;
constexpr
int
kMaxFramesBetweenSamples
=
33
;
constexpr
uint32_t
kMaxDurationBetweenSamples
=
90
'
000
;
uint32_t
EnoughTimeHasPassed
(
uint32_t
from
uint32_t
to
)
{
return
(
to
-
from
)
>
=
kMaxDurationBetweenSamples
;
}
}
HaltonFrameSampler
:
:
HaltonFrameSampler
(
)
:
coordinate_sampler_prng_
(
HaltonSequence
(
2
)
)
{
}
std
:
:
vector
<
HaltonFrameSampler
:
:
Coordinates
>
HaltonFrameSampler
:
:
GetSampleCoordinatesForFrameIfFrameShouldBeSampled
(
bool
is_key_frame
uint32_t
rtp_timestamp
int
num_samples
)
{
if
(
num_samples
<
1
)
{
return
{
}
;
}
if
(
rtp_timestamp_last_frame_sampled_
.
has_value
(
)
)
{
RTC_CHECK_NE
(
*
rtp_timestamp_last_frame_sampled_
rtp_timestamp
)
;
}
if
(
is_key_frame
|
|
frames_until_next_sample_
<
=
0
|
|
!
rtp_timestamp_last_frame_sampled_
.
has_value
(
)
|
|
EnoughTimeHasPassed
(
*
rtp_timestamp_last_frame_sampled_
rtp_timestamp
)
)
{
frames_until_next_sample_
=
(
kMaxFramesBetweenSamples
-
1
)
-
(
frames_sampled_
%
8
)
;
+
+
frames_sampled_
;
rtp_timestamp_last_frame_sampled_
=
rtp_timestamp
;
return
GetSampleCoordinatesForFrame
(
num_samples
)
;
}
-
-
frames_until_next_sample_
;
return
{
}
;
}
std
:
:
vector
<
HaltonFrameSampler
:
:
Coordinates
>
HaltonFrameSampler
:
:
GetSampleCoordinatesForFrame
(
int
num_samples
)
{
RTC_CHECK_GE
(
num_samples
1
)
;
std
:
:
vector
<
Coordinates
>
coordinates
;
coordinates
.
reserve
(
num_samples
)
;
for
(
int
i
=
0
;
i
<
num_samples
;
+
+
i
)
{
coordinates
.
push_back
(
GetNextSampleCoordinates
(
)
)
;
}
return
coordinates
;
}
HaltonFrameSampler
:
:
Coordinates
HaltonFrameSampler
:
:
GetNextSampleCoordinates
(
)
{
std
:
:
vector
<
double
>
point
=
coordinate_sampler_prng_
.
GetNext
(
)
;
return
{
.
row
=
point
[
0
]
.
column
=
point
[
1
]
}
;
}
void
HaltonFrameSampler
:
:
Restart
(
)
{
coordinate_sampler_prng_
.
Reset
(
)
;
}
int
HaltonFrameSampler
:
:
GetCurrentIndex
(
)
const
{
return
coordinate_sampler_prng_
.
GetCurrentIndex
(
)
;
}
void
HaltonFrameSampler
:
:
SetCurrentIndex
(
int
index
)
{
coordinate_sampler_prng_
.
SetCurrentIndex
(
index
)
;
}
double
GetFilteredElement
(
const
VideoFrameSampler
&
frame_sampler
VideoFrameSampler
:
:
ChannelType
channel
int
row
int
column
double
std_dev
)
{
RTC_CHECK_GE
(
row
0
)
;
RTC_CHECK_LT
(
row
frame_sampler
.
height
(
channel
)
)
;
RTC_CHECK_GE
(
column
0
)
;
RTC_CHECK_LT
(
column
frame_sampler
.
width
(
channel
)
)
;
RTC_CHECK_GE
(
std_dev
0
.
0
)
;
if
(
std_dev
=
=
0
.
0
)
{
return
frame_sampler
.
GetSampleValue
(
channel
column
row
)
;
}
int
max_distance
=
std
:
:
ceil
(
std
:
:
sqrt
(
-
2
.
0
*
std
:
:
log
(
kCutoff
)
*
std
:
:
pow
(
std_dev
2
.
0
)
)
)
-
1
;
max_distance
=
std
:
:
max
(
kLowerBoundKernelSize
max_distance
)
;
double
element_sum
=
0
.
0
;
double
total_weight
=
0
.
0
;
for
(
int
r
=
std
:
:
max
(
row
-
max_distance
0
)
;
r
<
std
:
:
min
(
row
+
max_distance
+
1
frame_sampler
.
height
(
channel
)
)
;
+
+
r
)
{
for
(
int
c
=
std
:
:
max
(
column
-
max_distance
0
)
;
c
<
std
:
:
min
(
column
+
max_distance
+
1
frame_sampler
.
width
(
channel
)
)
;
+
+
c
)
{
double
weight
=
std
:
:
exp
(
-
1
.
0
*
(
std
:
:
pow
(
row
-
r
2
)
+
std
:
:
pow
(
column
-
c
2
)
)
/
(
2
.
0
*
std
:
:
pow
(
std_dev
2
)
)
)
;
element_sum
+
=
frame_sampler
.
GetSampleValue
(
channel
c
r
)
*
weight
;
total_weight
+
=
weight
;
}
}
return
SafeClamp
(
element_sum
/
total_weight
0
.
0
255
.
0
)
;
}
std
:
:
vector
<
FilteredSample
>
GetSampleValuesForFrame
(
const
VideoFrame
&
frame
std
:
:
vector
<
HaltonFrameSampler
:
:
Coordinates
>
sample_coordinates
int
scaled_width
int
scaled_height
double
std_dev_gaussian_blur
)
{
if
(
frame
.
video_frame_buffer
(
)
=
=
nullptr
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
The
framebuffer
must
not
be
nullptr
"
;
return
{
}
;
}
if
(
sample_coordinates
.
empty
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
There
must
be
at
least
one
coordinate
provided
"
;
return
{
}
;
}
for
(
HaltonFrameSampler
:
:
Coordinates
coordinate
:
sample_coordinates
)
{
if
(
coordinate
.
column
<
0
.
0
|
|
coordinate
.
column
>
=
1
.
0
|
|
coordinate
.
row
<
0
.
0
|
|
coordinate
.
row
>
=
1
.
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
The
coordinates
must
be
in
[
0
1
)
:
column
=
"
<
<
coordinate
.
column
<
<
"
row
=
"
<
<
coordinate
.
row
<
<
"
.
\
n
"
;
return
{
}
;
}
}
if
(
scaled_width
<
=
0
|
|
scaled_height
<
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
The
width
and
height
to
scale
to
must
be
positive
:
width
=
"
<
<
scaled_width
<
<
"
height
=
"
<
<
scaled_height
<
<
"
.
\
n
"
;
return
{
}
;
}
if
(
std_dev_gaussian_blur
<
0
.
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
The
standard
deviation
for
the
Gaussian
blur
must
not
be
negative
:
"
<
<
std_dev_gaussian_blur
<
<
"
.
\
n
"
;
return
{
}
;
}
if
(
scaled_width
>
frame
.
width
(
)
|
|
scaled_height
>
frame
.
height
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Upscaling
causes
corruption
.
Therefore
only
down
-
scaling
is
"
"
permissible
.
"
;
return
{
}
;
}
VideoFrame
scaled_frame
=
frame
;
std
:
:
unique_ptr
<
VideoFrameSampler
>
frame_sampler
;
if
(
scaled_width
=
=
frame
.
width
(
)
&
&
scaled_height
=
=
frame
.
height
(
)
)
{
frame_sampler
=
VideoFrameSampler
:
:
Create
(
frame
)
;
}
else
{
if
(
frame
.
video_frame_buffer
(
)
-
>
type
(
)
=
=
VideoFrameBuffer
:
:
Type
:
:
kNV12
)
{
scoped_refptr
<
NV12Buffer
>
scaled_buffer
=
NV12Buffer
:
:
Create
(
scaled_width
scaled_height
)
;
scaled_buffer
-
>
CropAndScaleFrom
(
*
frame
.
video_frame_buffer
(
)
-
>
GetNV12
(
)
0
0
frame
.
width
(
)
frame
.
height
(
)
)
;
scaled_frame
.
set_video_frame_buffer
(
scaled_buffer
)
;
}
else
{
scoped_refptr
<
I420Buffer
>
scaled_buffer
=
I420Buffer
:
:
Create
(
scaled_width
scaled_height
)
;
scoped_refptr
<
I420BufferInterface
>
buffer
=
frame
.
video_frame_buffer
(
)
-
>
ToI420
(
)
;
if
(
buffer
=
=
nullptr
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
convert
frame
to
I420
format
.
"
;
return
{
}
;
}
scaled_buffer
-
>
ScaleFrom
(
*
buffer
)
;
scaled_frame
.
set_video_frame_buffer
(
scaled_buffer
)
;
}
frame_sampler
=
VideoFrameSampler
:
:
Create
(
scaled_frame
)
;
}
if
(
frame_sampler
=
=
nullptr
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
create
frame
sampler
for
buffer
type
"
<
<
VideoFrameBufferTypeToString
(
frame
.
video_frame_buffer
(
)
-
>
type
(
)
)
;
return
{
}
;
}
RTC_DCHECK_EQ
(
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
U
)
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
V
)
)
<
<
"
Chroma
channels
are
expected
to
be
equal
in
resolution
.
"
;
int
width_merged_planes
=
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
Y
)
+
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
U
)
;
int
height_merged_planes
=
frame_sampler
-
>
height
(
VideoFrameSampler
:
:
ChannelType
:
:
Y
)
;
std
:
:
vector
<
FilteredSample
>
filtered_samples
;
filtered_samples
.
reserve
(
sample_coordinates
.
size
(
)
)
;
for
(
HaltonFrameSampler
:
:
Coordinates
coordinate
:
sample_coordinates
)
{
int
column
=
coordinate
.
column
*
width_merged_planes
;
int
row
=
coordinate
.
row
*
height_merged_planes
;
double
value_for_coordinate
;
if
(
column
<
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
Y
)
)
{
value_for_coordinate
=
GetFilteredElement
(
*
frame_sampler
VideoFrameSampler
:
:
ChannelType
:
:
Y
row
column
std_dev_gaussian_blur
)
;
filtered_samples
.
push_back
(
{
.
value
=
value_for_coordinate
.
plane
=
ImagePlane
:
:
kLuma
}
)
;
}
else
if
(
row
<
frame_sampler
-
>
height
(
VideoFrameSampler
:
:
ChannelType
:
:
U
)
)
{
column
-
=
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
Y
)
;
value_for_coordinate
=
GetFilteredElement
(
*
frame_sampler
VideoFrameSampler
:
:
ChannelType
:
:
U
row
column
std_dev_gaussian_blur
)
;
filtered_samples
.
push_back
(
{
.
value
=
value_for_coordinate
.
plane
=
ImagePlane
:
:
kChroma
}
)
;
}
else
{
column
-
=
frame_sampler
-
>
width
(
VideoFrameSampler
:
:
ChannelType
:
:
Y
)
;
row
-
=
frame_sampler
-
>
height
(
VideoFrameSampler
:
:
ChannelType
:
:
U
)
;
value_for_coordinate
=
GetFilteredElement
(
*
frame_sampler
VideoFrameSampler
:
:
ChannelType
:
:
V
row
column
std_dev_gaussian_blur
)
;
filtered_samples
.
push_back
(
{
.
value
=
value_for_coordinate
.
plane
=
ImagePlane
:
:
kChroma
}
)
;
}
}
return
filtered_samples
;
}
[
[
deprecated
]
]
std
:
:
vector
<
FilteredSample
>
GetSampleValuesForFrame
(
scoped_refptr
<
I420BufferInterface
>
i420_frame_buffer
std
:
:
vector
<
HaltonFrameSampler
:
:
Coordinates
>
sample_coordinates
int
scaled_width
int
scaled_height
double
std_dev_gaussian_blur
)
{
return
GetSampleValuesForFrame
(
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
i420_frame_buffer
)
.
build
(
)
sample_coordinates
scaled_width
scaled_height
std_dev_gaussian_blur
)
;
}
}
