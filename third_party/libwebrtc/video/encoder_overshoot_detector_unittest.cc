#
include
"
video
/
encoder_overshoot_detector
.
h
"
#
include
<
cstdint
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
frequency
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
video
/
video_codec_type
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
ValuesIn
;
std
:
:
string
CodecTypeToHistogramSuffix
(
VideoCodecType
codec
)
{
switch
(
codec
)
{
case
kVideoCodecVP8
:
return
"
Vp8
"
;
case
kVideoCodecVP9
:
return
"
Vp9
"
;
case
kVideoCodecAV1
:
return
"
Av1
"
;
case
kVideoCodecH264
:
return
"
H264
"
;
case
kVideoCodecH265
:
return
"
H265
"
;
case
kVideoCodecGeneric
:
return
"
Generic
"
;
}
}
struct
TestParams
{
VideoCodecType
codec_type
;
bool
is_screenshare
;
}
;
}
class
EncoderOvershootDetectorTest
:
public
TestWithParam
<
TestParams
>
{
public
:
static
constexpr
int
kDefaultBitrateBps
=
300000
;
static
constexpr
double
kDefaultFrameRateFps
=
15
;
EncoderOvershootDetectorTest
(
)
:
detector_
(
kWindowSizeMs
GetParam
(
)
.
codec_type
GetParam
(
)
.
is_screenshare
)
target_bitrate_
(
DataRate
:
:
BitsPerSec
(
kDefaultBitrateBps
)
)
target_framerate_fps_
(
kDefaultFrameRateFps
)
{
}
protected
:
void
SetUp
(
)
override
{
metrics
:
:
Reset
(
)
;
}
void
RunConstantUtilizationTest
(
double
actual_utilization_factor
double
expected_utilization_factor
double
allowed_error
int64_t
test_duration_ms
)
{
const
int
frame_size_bytes
=
static_cast
<
int
>
(
actual_utilization_factor
*
(
target_bitrate_
.
bps
(
)
/
target_framerate_fps_
)
/
8
)
;
detector_
.
SetTargetRate
(
target_bitrate_
target_framerate_fps_
TimeMillis
(
)
)
;
if
(
TimeMillis
(
)
=
=
0
)
{
detector_
.
OnEncodedFrame
(
frame_size_bytes
TimeMillis
(
)
)
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
1
)
/
target_framerate_fps_
)
;
}
int64_t
runtime_us
=
0
;
while
(
runtime_us
<
test_duration_ms
*
1000
)
{
detector_
.
OnEncodedFrame
(
frame_size_bytes
TimeMillis
(
)
)
;
runtime_us
+
=
kNumMicrosecsPerSec
/
target_framerate_fps_
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
1
)
/
target_framerate_fps_
)
;
}
const
std
:
:
optional
<
double
>
network_utilization_factor
=
detector_
.
GetNetworkRateUtilizationFactor
(
TimeMillis
(
)
)
;
EXPECT_NEAR
(
network_utilization_factor
.
value_or
(
-
1
)
expected_utilization_factor
allowed_error
)
;
const
std
:
:
optional
<
double
>
media_utilization_factor
=
detector_
.
GetMediaRateUtilizationFactor
(
TimeMillis
(
)
)
;
EXPECT_NEAR
(
media_utilization_factor
.
value_or
(
-
1
)
expected_utilization_factor
allowed_error
)
;
}
static
constexpr
int64_t
kWindowSizeMs
=
3000
;
EncoderOvershootDetector
detector_
;
ScopedFakeClock
clock_
;
DataRate
target_bitrate_
;
double
target_framerate_fps_
;
}
;
TEST_P
(
EncoderOvershootDetectorTest
NoUtilizationIfNoRate
)
{
const
int
frame_size_bytes
=
1000
;
const
int64_t
time_interval_ms
=
33
;
detector_
.
SetTargetRate
(
target_bitrate_
target_framerate_fps_
TimeMillis
(
)
)
;
EXPECT_FALSE
(
detector_
.
GetNetworkRateUtilizationFactor
(
TimeMillis
(
)
)
.
has_value
(
)
)
;
detector_
.
OnEncodedFrame
(
frame_size_bytes
TimeMillis
(
)
)
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
time_interval_ms
)
)
;
EXPECT_TRUE
(
detector_
.
GetNetworkRateUtilizationFactor
(
TimeMillis
(
)
)
.
has_value
(
)
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
OptimalSize
)
{
RunConstantUtilizationTest
(
1
.
0
1
.
0
0
.
01
kWindowSizeMs
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
Undershoot
)
{
RunConstantUtilizationTest
(
0
.
5
1
.
0
0
.
00
kWindowSizeMs
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
Overshoot
)
{
RunConstantUtilizationTest
(
1
.
2
1
.
2
0
.
01
kWindowSizeMs
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
ConstantOvershootVaryingRates
)
{
RunConstantUtilizationTest
(
1
.
2
1
.
2
0
.
01
kWindowSizeMs
)
;
target_framerate_fps_
/
=
2
;
RunConstantUtilizationTest
(
1
.
2
1
.
2
0
.
01
kWindowSizeMs
/
2
)
;
target_bitrate_
=
DataRate
:
:
BitsPerSec
(
target_bitrate_
.
bps
(
)
/
2
)
;
RunConstantUtilizationTest
(
1
.
2
1
.
2
0
.
01
kWindowSizeMs
/
2
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
ConstantRateVaryingOvershoot
)
{
RunConstantUtilizationTest
(
1
.
1
1
.
1
0
.
01
kWindowSizeMs
)
;
RunConstantUtilizationTest
(
1
.
2
1
.
15
0
.
01
kWindowSizeMs
/
2
)
;
RunConstantUtilizationTest
(
1
.
2
1
.
2
0
.
01
kWindowSizeMs
/
2
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
PartialOvershoot
)
{
const
int
ideal_frame_size_bytes
=
(
target_bitrate_
.
bps
(
)
/
target_framerate_fps_
)
/
8
;
detector_
.
SetTargetRate
(
target_bitrate_
target_framerate_fps_
TimeMillis
(
)
)
;
int64_t
runtime_us
=
0
;
int
i
=
0
;
while
(
runtime_us
<
kWindowSizeMs
*
kNumMicrosecsPerMillisec
)
{
runtime_us
+
=
kNumMicrosecsPerSec
/
target_framerate_fps_
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
1
)
/
target_framerate_fps_
)
;
int
frame_size_bytes
=
(
i
+
+
%
4
<
2
)
?
(
ideal_frame_size_bytes
*
120
)
/
100
:
(
ideal_frame_size_bytes
*
80
)
/
100
;
detector_
.
OnEncodedFrame
(
frame_size_bytes
TimeMillis
(
)
)
;
}
const
std
:
:
optional
<
double
>
network_utilization_factor
=
detector_
.
GetNetworkRateUtilizationFactor
(
TimeMillis
(
)
)
;
EXPECT_NEAR
(
network_utilization_factor
.
value_or
(
-
1
)
1
.
05
0
.
01
)
;
const
std
:
:
optional
<
double
>
media_utilization_factor
=
detector_
.
GetMediaRateUtilizationFactor
(
TimeMillis
(
)
)
;
EXPECT_NEAR
(
media_utilization_factor
.
value_or
(
-
1
)
1
.
00
0
.
01
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
RecordsZeroErrorMetricWithNoOvershoot
)
{
DataSize
ideal_frame_size
=
target_bitrate_
/
Frequency
:
:
Hertz
(
target_framerate_fps_
)
;
detector_
.
SetTargetRate
(
target_bitrate_
target_framerate_fps_
TimeMillis
(
)
)
;
detector_
.
OnEncodedFrame
(
ideal_frame_size
.
bytes
(
)
TimeMillis
(
)
)
;
detector_
.
Reset
(
)
;
const
VideoCodecType
codec
=
GetParam
(
)
.
codec_type
;
const
bool
is_screenshare
=
GetParam
(
)
.
is_screenshare
;
const
std
:
:
string
rmse_histogram_prefix
=
is_screenshare
?
"
WebRTC
.
Video
.
Screenshare
.
RMSEOfEncodingBitrateInKbps
.
"
:
"
WebRTC
.
Video
.
RMSEOfEncodingBitrateInKbps
.
"
;
const
std
:
:
string
overshoot_histogram_prefix
=
is_screenshare
?
"
WebRTC
.
Video
.
Screenshare
.
EncodingBitrateOvershoot
.
"
:
"
WebRTC
.
Video
.
EncodingBitrateOvershoot
.
"
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumSamples
(
rmse_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
)
)
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumEvents
(
rmse_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
0
)
)
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumSamples
(
overshoot_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
)
)
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumEvents
(
overshoot_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
0
)
)
;
}
TEST_P
(
EncoderOvershootDetectorTest
RecordScreenshareZeroMetricWithNoOvershoot
)
{
DataSize
ideal_frame_size
=
target_bitrate_
/
Frequency
:
:
Hertz
(
target_framerate_fps_
)
;
DataSize
target_frame_size
=
ideal_frame_size
*
3
/
2
;
detector_
.
SetTargetRate
(
target_bitrate_
target_framerate_fps_
TimeMillis
(
)
)
;
detector_
.
OnEncodedFrame
(
target_frame_size
.
bytes
(
)
TimeMillis
(
)
)
;
detector_
.
Reset
(
)
;
const
VideoCodecType
codec
=
GetParam
(
)
.
codec_type
;
const
bool
is_screenshare
=
GetParam
(
)
.
is_screenshare
;
const
std
:
:
string
rmse_histogram_prefix
=
is_screenshare
?
"
WebRTC
.
Video
.
Screenshare
.
RMSEOfEncodingBitrateInKbps
.
"
:
"
WebRTC
.
Video
.
RMSEOfEncodingBitrateInKbps
.
"
;
const
std
:
:
string
overshoot_histogram_prefix
=
is_screenshare
?
"
WebRTC
.
Video
.
Screenshare
.
EncodingBitrateOvershoot
.
"
:
"
WebRTC
.
Video
.
EncodingBitrateOvershoot
.
"
;
int64_t
rmse_in_kbps
=
ideal_frame_size
.
bytes
(
)
*
8
/
1000
/
2
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumSamples
(
rmse_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
)
)
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumEvents
(
rmse_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
rmse_in_kbps
)
)
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumSamples
(
overshoot_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
)
)
;
EXPECT_METRIC_EQ
(
1
metrics
:
:
NumEvents
(
overshoot_histogram_prefix
+
CodecTypeToHistogramSuffix
(
codec
)
50
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
PerCodecType
EncoderOvershootDetectorTest
ValuesIn
<
TestParams
>
(
{
{
VideoCodecType
:
:
kVideoCodecVP8
false
}
{
VideoCodecType
:
:
kVideoCodecVP8
true
}
{
VideoCodecType
:
:
kVideoCodecVP9
false
}
{
VideoCodecType
:
:
kVideoCodecVP9
true
}
{
VideoCodecType
:
:
kVideoCodecAV1
false
}
{
VideoCodecType
:
:
kVideoCodecAV1
true
}
{
VideoCodecType
:
:
kVideoCodecH264
false
}
{
VideoCodecType
:
:
kVideoCodecH264
true
}
{
VideoCodecType
:
:
kVideoCodecH265
false
}
{
VideoCodecType
:
:
kVideoCodecH265
true
}
}
)
)
;
}
