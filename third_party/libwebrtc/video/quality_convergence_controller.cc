#
include
"
video
/
quality_convergence_controller
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
{
constexpr
int
kVp8DefaultStaticQpThreshold
=
15
;
constexpr
int
kVp9DefaultStaticQpThreshold
=
32
;
constexpr
int
kAv1DefaultStaticQpThreshold
=
40
;
int
GetDefaultStaticQpThreshold
(
VideoCodecType
codec
)
{
switch
(
codec
)
{
case
kVideoCodecVP8
:
return
kVp8DefaultStaticQpThreshold
;
case
kVideoCodecVP9
:
return
kVp9DefaultStaticQpThreshold
;
case
kVideoCodecAV1
:
return
kAv1DefaultStaticQpThreshold
;
case
kVideoCodecGeneric
:
case
kVideoCodecH264
:
case
kVideoCodecH265
:
return
-
1
;
}
}
}
void
QualityConvergenceController
:
:
Initialize
(
int
number_of_layers
absl
:
:
optional
<
int
>
static_qp_threshold
VideoCodecType
codec
const
FieldTrialsView
&
trials
)
{
RTC_DCHECK
(
sequence_checker_
.
IsCurrent
(
)
)
;
RTC_CHECK
(
number_of_layers
>
0
)
;
number_of_layers_
=
number_of_layers
;
convergence_monitors_
.
clear
(
)
;
int
qp_threshold
=
static_qp_threshold
.
value_or
(
GetDefaultStaticQpThreshold
(
codec
)
)
;
for
(
int
i
=
0
;
i
<
number_of_layers_
;
+
+
i
)
{
convergence_monitors_
.
push_back
(
QualityConvergenceMonitor
:
:
Create
(
qp_threshold
codec
trials
)
)
;
}
initialized_
=
true
;
}
bool
QualityConvergenceController
:
:
AddSampleAndCheckTargetQuality
(
int
layer_index
int
qp
bool
is_refresh_frame
)
{
RTC_DCHECK
(
sequence_checker_
.
IsCurrent
(
)
)
;
RTC_CHECK
(
initialized_
)
;
if
(
layer_index
<
0
|
|
layer_index
>
=
number_of_layers_
)
{
return
false
;
}
RTC_DCHECK
(
number_of_layers_
=
=
static_cast
<
int
>
(
convergence_monitors_
.
size
(
)
)
)
;
if
(
number_of_layers_
!
=
static_cast
<
int
>
(
convergence_monitors_
.
size
(
)
)
)
{
return
false
;
}
convergence_monitors_
[
layer_index
]
-
>
AddSample
(
qp
is_refresh_frame
)
;
return
convergence_monitors_
[
layer_index
]
-
>
AtTargetQuality
(
)
;
}
}
