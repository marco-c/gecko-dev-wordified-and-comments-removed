#
ifndef
CRC32C_CRC32C_ARM_CHECK_H_
#
define
CRC32C_CRC32C_ARM_CHECK_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
"
crc32c
/
crc32c_config
.
h
"
#
if
HAVE_ARM64_CRC32C
#
ifdef
__linux__
#
if
HAVE_STRONG_GETAUXVAL
#
include
<
sys
/
auxv
.
h
>
#
elif
HAVE_WEAK_GETAUXVAL
extern
"
C
"
unsigned
long
getauxval
(
unsigned
long
type
)
__attribute__
(
(
weak
)
)
;
#
define
AT_HWCAP
16
#
endif
#
endif
#
ifdef
__APPLE__
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
endif
namespace
crc32c
{
inline
bool
CanUseArm64Crc32
(
)
{
#
if
defined
(
__linux__
)
&
&
(
HAVE_STRONG_GETAUXVAL
|
|
HAVE_WEAK_GETAUXVAL
)
constexpr
unsigned
long
kHWCAP_PMULL
=
1
<
<
4
;
constexpr
unsigned
long
kHWCAP_CRC32
=
1
<
<
7
;
unsigned
long
hwcap
=
#
if
HAVE_STRONG_GETAUXVAL
getauxval
(
AT_HWCAP
)
;
#
elif
HAVE_WEAK_GETAUXVAL
(
&
getauxval
!
=
nullptr
)
?
getauxval
(
AT_HWCAP
)
:
0
;
#
else
#
error
This
is
supposed
to
be
nested
inside
a
check
for
HAVE_
*
_GETAUXVAL
.
#
endif
return
(
hwcap
&
(
kHWCAP_PMULL
|
kHWCAP_CRC32
)
)
=
=
(
kHWCAP_PMULL
|
kHWCAP_CRC32
)
;
#
elif
defined
(
__APPLE__
)
int
val
=
0
;
size_t
len
=
sizeof
(
val
)
;
return
sysctlbyname
(
"
hw
.
optional
.
armv8_crc32
"
&
val
&
len
nullptr
0
)
=
=
0
&
&
val
!
=
0
;
#
else
return
false
;
#
endif
}
}
#
endif
#
endif
