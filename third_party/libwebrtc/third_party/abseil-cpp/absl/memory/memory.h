#
ifndef
ABSL_MEMORY_MEMORY_H_
#
define
ABSL_MEMORY_MEMORY_H_
#
include
<
cstddef
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
T
>
std
:
:
unique_ptr
<
T
>
WrapUnique
(
T
*
ptr
)
{
static_assert
(
!
std
:
:
is_array
<
T
>
:
:
value
"
array
types
are
unsupported
"
)
;
static_assert
(
std
:
:
is_object
<
T
>
:
:
value
"
non
-
object
types
are
unsupported
"
)
;
return
std
:
:
unique_ptr
<
T
>
(
ptr
)
;
}
namespace
memory_internal
{
template
<
typename
T
>
struct
MakeUniqueResult
{
using
scalar
=
std
:
:
unique_ptr
<
T
>
;
}
;
template
<
typename
T
>
struct
MakeUniqueResult
<
T
[
]
>
{
using
array
=
std
:
:
unique_ptr
<
T
[
]
>
;
}
;
template
<
typename
T
size_t
N
>
struct
MakeUniqueResult
<
T
[
N
]
>
{
using
invalid
=
void
;
}
;
}
#
if
(
__cplusplus
>
201103L
|
|
defined
(
_MSC_VER
)
)
&
&
\
!
(
defined
(
__GLIBCXX__
)
&
&
!
defined
(
__cpp_lib_make_unique
)
)
using
std
:
:
make_unique
;
#
else
template
<
typename
T
typename
.
.
.
Args
>
typename
memory_internal
:
:
MakeUniqueResult
<
T
>
:
:
scalar
make_unique
(
Args
&
&
.
.
.
args
)
{
return
std
:
:
unique_ptr
<
T
>
(
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
T
>
typename
memory_internal
:
:
MakeUniqueResult
<
T
>
:
:
array
make_unique
(
size_t
n
)
{
return
std
:
:
unique_ptr
<
T
>
(
new
typename
absl
:
:
remove_extent_t
<
T
>
[
n
]
(
)
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
memory_internal
:
:
MakeUniqueResult
<
T
>
:
:
invalid
make_unique
(
Args
&
&
.
.
.
)
=
delete
;
#
endif
template
<
typename
T
>
auto
RawPtr
(
T
&
&
ptr
)
-
>
decltype
(
std
:
:
addressof
(
*
ptr
)
)
{
return
(
ptr
!
=
nullptr
)
?
std
:
:
addressof
(
*
ptr
)
:
nullptr
;
}
inline
std
:
:
nullptr_t
RawPtr
(
std
:
:
nullptr_t
)
{
return
nullptr
;
}
template
<
typename
T
typename
D
>
std
:
:
shared_ptr
<
T
>
ShareUniquePtr
(
std
:
:
unique_ptr
<
T
D
>
&
&
ptr
)
{
return
ptr
?
std
:
:
shared_ptr
<
T
>
(
std
:
:
move
(
ptr
)
)
:
std
:
:
shared_ptr
<
T
>
(
)
;
}
template
<
typename
T
>
std
:
:
weak_ptr
<
T
>
WeakenPtr
(
const
std
:
:
shared_ptr
<
T
>
&
ptr
)
{
return
std
:
:
weak_ptr
<
T
>
(
ptr
)
;
}
namespace
memory_internal
{
template
<
template
<
typename
>
class
Extract
typename
Obj
typename
Default
typename
>
struct
ExtractOr
{
using
type
=
Default
;
}
;
template
<
template
<
typename
>
class
Extract
typename
Obj
typename
Default
>
struct
ExtractOr
<
Extract
Obj
Default
void_t
<
Extract
<
Obj
>
>
>
{
using
type
=
Extract
<
Obj
>
;
}
;
template
<
template
<
typename
>
class
Extract
typename
Obj
typename
Default
>
using
ExtractOrT
=
typename
ExtractOr
<
Extract
Obj
Default
void
>
:
:
type
;
template
<
typename
T
>
using
GetPointer
=
typename
T
:
:
pointer
;
template
<
typename
T
>
using
GetConstPointer
=
typename
T
:
:
const_pointer
;
template
<
typename
T
>
using
GetVoidPointer
=
typename
T
:
:
void_pointer
;
template
<
typename
T
>
using
GetConstVoidPointer
=
typename
T
:
:
const_void_pointer
;
template
<
typename
T
>
using
GetDifferenceType
=
typename
T
:
:
difference_type
;
template
<
typename
T
>
using
GetSizeType
=
typename
T
:
:
size_type
;
template
<
typename
T
>
using
GetPropagateOnContainerCopyAssignment
=
typename
T
:
:
propagate_on_container_copy_assignment
;
template
<
typename
T
>
using
GetPropagateOnContainerMoveAssignment
=
typename
T
:
:
propagate_on_container_move_assignment
;
template
<
typename
T
>
using
GetPropagateOnContainerSwap
=
typename
T
:
:
propagate_on_container_swap
;
template
<
typename
T
>
using
GetIsAlwaysEqual
=
typename
T
:
:
is_always_equal
;
template
<
typename
T
>
struct
GetFirstArg
;
template
<
template
<
typename
.
.
.
>
class
Class
typename
T
typename
.
.
.
Args
>
struct
GetFirstArg
<
Class
<
T
Args
.
.
.
>
>
{
using
type
=
T
;
}
;
template
<
typename
Ptr
typename
=
void
>
struct
ElementType
{
using
type
=
typename
GetFirstArg
<
Ptr
>
:
:
type
;
}
;
template
<
typename
T
>
struct
ElementType
<
T
void_t
<
typename
T
:
:
element_type
>
>
{
using
type
=
typename
T
:
:
element_type
;
}
;
template
<
typename
T
typename
U
>
struct
RebindFirstArg
;
template
<
template
<
typename
.
.
.
>
class
Class
typename
T
typename
.
.
.
Args
typename
U
>
struct
RebindFirstArg
<
Class
<
T
Args
.
.
.
>
U
>
{
using
type
=
Class
<
U
Args
.
.
.
>
;
}
;
template
<
typename
T
typename
U
typename
=
void
>
struct
RebindPtr
{
using
type
=
typename
RebindFirstArg
<
T
U
>
:
:
type
;
}
;
template
<
typename
T
typename
U
>
struct
RebindPtr
<
T
U
void_t
<
typename
T
:
:
template
rebind
<
U
>
>
>
{
using
type
=
typename
T
:
:
template
rebind
<
U
>
;
}
;
template
<
typename
T
typename
U
>
constexpr
bool
HasRebindAlloc
(
.
.
.
)
{
return
false
;
}
template
<
typename
T
typename
U
>
constexpr
bool
HasRebindAlloc
(
typename
T
:
:
template
rebind
<
U
>
:
:
other
*
)
{
return
true
;
}
template
<
typename
T
typename
U
bool
=
HasRebindAlloc
<
T
U
>
(
nullptr
)
>
struct
RebindAlloc
{
using
type
=
typename
RebindFirstArg
<
T
U
>
:
:
type
;
}
;
template
<
typename
T
typename
U
>
struct
RebindAlloc
<
T
U
true
>
{
using
type
=
typename
T
:
:
template
rebind
<
U
>
:
:
other
;
}
;
}
template
<
typename
Ptr
>
struct
pointer_traits
{
using
pointer
=
Ptr
;
using
element_type
=
typename
memory_internal
:
:
ElementType
<
Ptr
>
:
:
type
;
using
difference_type
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetDifferenceType
Ptr
std
:
:
ptrdiff_t
>
;
template
<
typename
U
>
using
rebind
=
typename
memory_internal
:
:
RebindPtr
<
Ptr
U
>
:
:
type
;
static
pointer
pointer_to
(
element_type
&
r
)
{
return
Ptr
:
:
pointer_to
(
r
)
;
}
}
;
template
<
typename
T
>
struct
pointer_traits
<
T
*
>
{
using
pointer
=
T
*
;
using
element_type
=
T
;
using
difference_type
=
std
:
:
ptrdiff_t
;
template
<
typename
U
>
using
rebind
=
U
*
;
static
pointer
pointer_to
(
element_type
&
r
)
noexcept
{
return
std
:
:
addressof
(
r
)
;
}
}
;
#
if
__cplusplus
>
=
201703L
|
|
(
defined
(
_MSVC_LANG
)
&
&
_MSVC_LANG
>
=
201703L
)
using
std
:
:
allocator_traits
;
#
else
template
<
typename
Alloc
>
struct
allocator_traits
{
using
allocator_type
=
Alloc
;
using
value_type
=
typename
Alloc
:
:
value_type
;
using
pointer
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetPointer
Alloc
value_type
*
>
;
using
const_pointer
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetConstPointer
Alloc
typename
absl
:
:
pointer_traits
<
pointer
>
:
:
template
rebind
<
const
value_type
>
>
;
using
void_pointer
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetVoidPointer
Alloc
typename
absl
:
:
pointer_traits
<
pointer
>
:
:
template
rebind
<
void
>
>
;
using
const_void_pointer
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetConstVoidPointer
Alloc
typename
absl
:
:
pointer_traits
<
pointer
>
:
:
template
rebind
<
const
void
>
>
;
using
difference_type
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetDifferenceType
Alloc
typename
absl
:
:
pointer_traits
<
pointer
>
:
:
difference_type
>
;
using
size_type
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetSizeType
Alloc
typename
std
:
:
make_unsigned
<
difference_type
>
:
:
type
>
;
using
propagate_on_container_copy_assignment
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetPropagateOnContainerCopyAssignment
Alloc
std
:
:
false_type
>
;
using
propagate_on_container_move_assignment
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetPropagateOnContainerMoveAssignment
Alloc
std
:
:
false_type
>
;
using
propagate_on_container_swap
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetPropagateOnContainerSwap
Alloc
std
:
:
false_type
>
;
using
is_always_equal
=
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetIsAlwaysEqual
Alloc
typename
std
:
:
is_empty
<
Alloc
>
:
:
type
>
;
template
<
typename
T
>
using
rebind_alloc
=
typename
memory_internal
:
:
RebindAlloc
<
Alloc
T
>
:
:
type
;
template
<
typename
T
>
using
rebind_traits
=
absl
:
:
allocator_traits
<
rebind_alloc
<
T
>
>
;
static
pointer
allocate
(
Alloc
&
a
size_type
n
)
{
return
a
.
allocate
(
n
)
;
}
static
pointer
allocate
(
Alloc
&
a
size_type
n
const_void_pointer
hint
)
{
return
allocate_impl
(
0
a
n
hint
)
;
}
static
void
deallocate
(
Alloc
&
a
pointer
p
size_type
n
)
{
a
.
deallocate
(
p
n
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
static
void
construct
(
Alloc
&
a
T
*
p
Args
&
&
.
.
.
args
)
{
construct_impl
(
0
a
p
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
>
static
void
destroy
(
Alloc
&
a
T
*
p
)
{
destroy_impl
(
0
a
p
)
;
}
static
size_type
max_size
(
const
Alloc
&
a
)
{
return
max_size_impl
(
0
a
)
;
}
static
Alloc
select_on_container_copy_construction
(
const
Alloc
&
a
)
{
return
select_on_container_copy_construction_impl
(
0
a
)
;
}
private
:
template
<
typename
A
>
static
auto
allocate_impl
(
int
A
&
a
size_type
n
const_void_pointer
hint
)
-
>
decltype
(
a
.
allocate
(
n
hint
)
)
{
return
a
.
allocate
(
n
hint
)
;
}
static
pointer
allocate_impl
(
char
Alloc
&
a
size_type
n
const_void_pointer
)
{
return
a
.
allocate
(
n
)
;
}
template
<
typename
A
typename
.
.
.
Args
>
static
auto
construct_impl
(
int
A
&
a
Args
&
&
.
.
.
args
)
-
>
decltype
(
a
.
construct
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
{
a
.
construct
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
static
void
construct_impl
(
char
Alloc
&
T
*
p
Args
&
&
.
.
.
args
)
{
:
:
new
(
static_cast
<
void
*
>
(
p
)
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
A
typename
T
>
static
auto
destroy_impl
(
int
A
&
a
T
*
p
)
-
>
decltype
(
a
.
destroy
(
p
)
)
{
a
.
destroy
(
p
)
;
}
template
<
typename
T
>
static
void
destroy_impl
(
char
Alloc
&
T
*
p
)
{
p
-
>
~
T
(
)
;
}
template
<
typename
A
>
static
auto
max_size_impl
(
int
const
A
&
a
)
-
>
decltype
(
a
.
max_size
(
)
)
{
return
a
.
max_size
(
)
;
}
static
size_type
max_size_impl
(
char
const
Alloc
&
)
{
return
(
std
:
:
numeric_limits
<
size_type
>
:
:
max
)
(
)
/
sizeof
(
value_type
)
;
}
template
<
typename
A
>
static
auto
select_on_container_copy_construction_impl
(
int
const
A
&
a
)
-
>
decltype
(
a
.
select_on_container_copy_construction
(
)
)
{
return
a
.
select_on_container_copy_construction
(
)
;
}
static
Alloc
select_on_container_copy_construction_impl
(
char
const
Alloc
&
a
)
{
return
a
;
}
}
;
#
endif
namespace
memory_internal
{
template
<
typename
Alloc
>
using
GetIsNothrow
=
typename
Alloc
:
:
is_nothrow
;
}
template
<
typename
Alloc
>
struct
allocator_is_nothrow
:
memory_internal
:
:
ExtractOrT
<
memory_internal
:
:
GetIsNothrow
Alloc
std
:
:
false_type
>
{
}
;
#
if
defined
(
ABSL_ALLOCATOR_NOTHROW
)
&
&
ABSL_ALLOCATOR_NOTHROW
template
<
typename
T
>
struct
allocator_is_nothrow
<
std
:
:
allocator
<
T
>
>
:
std
:
:
true_type
{
}
;
struct
default_allocator_is_nothrow
:
std
:
:
true_type
{
}
;
#
else
struct
default_allocator_is_nothrow
:
std
:
:
false_type
{
}
;
#
endif
namespace
memory_internal
{
template
<
typename
Allocator
typename
Iterator
typename
.
.
.
Args
>
void
ConstructRange
(
Allocator
&
alloc
Iterator
first
Iterator
last
const
Args
&
.
.
.
args
)
{
for
(
Iterator
cur
=
first
;
cur
!
=
last
;
+
+
cur
)
{
ABSL_INTERNAL_TRY
{
std
:
:
allocator_traits
<
Allocator
>
:
:
construct
(
alloc
std
:
:
addressof
(
*
cur
)
args
.
.
.
)
;
}
ABSL_INTERNAL_CATCH_ANY
{
while
(
cur
!
=
first
)
{
-
-
cur
;
std
:
:
allocator_traits
<
Allocator
>
:
:
destroy
(
alloc
std
:
:
addressof
(
*
cur
)
)
;
}
ABSL_INTERNAL_RETHROW
;
}
}
}
template
<
typename
Allocator
typename
Iterator
typename
InputIterator
>
void
CopyRange
(
Allocator
&
alloc
Iterator
destination
InputIterator
first
InputIterator
last
)
{
for
(
Iterator
cur
=
destination
;
first
!
=
last
;
static_cast
<
void
>
(
+
+
cur
)
static_cast
<
void
>
(
+
+
first
)
)
{
ABSL_INTERNAL_TRY
{
std
:
:
allocator_traits
<
Allocator
>
:
:
construct
(
alloc
std
:
:
addressof
(
*
cur
)
*
first
)
;
}
ABSL_INTERNAL_CATCH_ANY
{
while
(
cur
!
=
destination
)
{
-
-
cur
;
std
:
:
allocator_traits
<
Allocator
>
:
:
destroy
(
alloc
std
:
:
addressof
(
*
cur
)
)
;
}
ABSL_INTERNAL_RETHROW
;
}
}
}
}
ABSL_NAMESPACE_END
}
#
endif
