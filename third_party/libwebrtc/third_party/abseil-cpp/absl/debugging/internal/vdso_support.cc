#
include
"
absl
/
debugging
/
internal
/
vdso_support
.
h
"
#
ifdef
ABSL_HAVE_VDSO_SUPPORT
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
unistd
.
h
>
#
if
__GLIBC_PREREQ
(
2
16
)
#
include
<
sys
/
auxv
.
h
>
#
endif
#
include
"
absl
/
base
/
dynamic_annotations
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
ifndef
AT_SYSINFO_EHDR
#
define
AT_SYSINFO_EHDR
33
/
/
for
crosstoolv10
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
ABSL_CONST_INIT
std
:
:
atomic
<
const
void
*
>
VDSOSupport
:
:
vdso_base_
(
debugging_internal
:
:
ElfMemImage
:
:
kInvalidBase
)
;
std
:
:
atomic
<
VDSOSupport
:
:
GetCpuFn
>
VDSOSupport
:
:
getcpu_fn_
(
&
InitAndGetCPU
)
;
VDSOSupport
:
:
VDSOSupport
(
)
:
image_
(
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
=
=
debugging_internal
:
:
ElfMemImage
:
:
kInvalidBase
?
Init
(
)
:
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
)
{
}
const
void
*
VDSOSupport
:
:
Init
(
)
{
const
auto
kInvalidBase
=
debugging_internal
:
:
ElfMemImage
:
:
kInvalidBase
;
#
if
__GLIBC_PREREQ
(
2
16
)
if
(
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
=
=
kInvalidBase
)
{
errno
=
0
;
const
void
*
const
sysinfo_ehdr
=
reinterpret_cast
<
const
void
*
>
(
getauxval
(
AT_SYSINFO_EHDR
)
)
;
if
(
errno
=
=
0
)
{
vdso_base_
.
store
(
sysinfo_ehdr
std
:
:
memory_order_relaxed
)
;
}
}
#
endif
if
(
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
=
=
kInvalidBase
)
{
int
fd
=
open
(
"
/
proc
/
self
/
auxv
"
O_RDONLY
)
;
if
(
fd
=
=
-
1
)
{
vdso_base_
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
getcpu_fn_
.
store
(
&
GetCPUViaSyscall
std
:
:
memory_order_relaxed
)
;
return
nullptr
;
}
ElfW
(
auxv_t
)
aux
;
while
(
read
(
fd
&
aux
sizeof
(
aux
)
)
=
=
sizeof
(
aux
)
)
{
if
(
aux
.
a_type
=
=
AT_SYSINFO_EHDR
)
{
vdso_base_
.
store
(
reinterpret_cast
<
void
*
>
(
aux
.
a_un
.
a_val
)
std
:
:
memory_order_relaxed
)
;
break
;
}
}
close
(
fd
)
;
if
(
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
=
=
kInvalidBase
)
{
vdso_base_
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
}
}
GetCpuFn
fn
=
&
GetCPUViaSyscall
;
if
(
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
)
{
VDSOSupport
vdso
;
SymbolInfo
info
;
if
(
vdso
.
LookupSymbol
(
"
__vdso_getcpu
"
"
LINUX_2
.
6
"
STT_FUNC
&
info
)
)
{
fn
=
reinterpret_cast
<
GetCpuFn
>
(
const_cast
<
void
*
>
(
info
.
address
)
)
;
}
}
getcpu_fn_
.
store
(
fn
std
:
:
memory_order_relaxed
)
;
return
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
;
}
const
void
*
VDSOSupport
:
:
SetBase
(
const
void
*
base
)
{
ABSL_RAW_CHECK
(
base
!
=
debugging_internal
:
:
ElfMemImage
:
:
kInvalidBase
"
internal
error
"
)
;
const
void
*
old_base
=
vdso_base_
.
load
(
std
:
:
memory_order_relaxed
)
;
vdso_base_
.
store
(
base
std
:
:
memory_order_relaxed
)
;
image_
.
Init
(
base
)
;
getcpu_fn_
.
store
(
&
InitAndGetCPU
std
:
:
memory_order_relaxed
)
;
return
old_base
;
}
bool
VDSOSupport
:
:
LookupSymbol
(
const
char
*
name
const
char
*
version
int
type
SymbolInfo
*
info
)
const
{
return
image_
.
LookupSymbol
(
name
version
type
info
)
;
}
bool
VDSOSupport
:
:
LookupSymbolByAddress
(
const
void
*
address
SymbolInfo
*
info_out
)
const
{
return
image_
.
LookupSymbolByAddress
(
address
info_out
)
;
}
long
VDSOSupport
:
:
GetCPUViaSyscall
(
unsigned
*
cpu
void
*
void
*
)
{
#
ifdef
SYS_getcpu
return
syscall
(
SYS_getcpu
cpu
nullptr
nullptr
)
;
#
else
static_cast
<
void
>
(
cpu
)
;
errno
=
ENOSYS
;
return
-
1
;
#
endif
}
long
VDSOSupport
:
:
InitAndGetCPU
(
unsigned
*
cpu
void
*
x
void
*
y
)
{
Init
(
)
;
GetCpuFn
fn
=
getcpu_fn_
.
load
(
std
:
:
memory_order_relaxed
)
;
ABSL_RAW_CHECK
(
fn
!
=
&
InitAndGetCPU
"
Init
(
)
did
not
set
getcpu_fn_
"
)
;
return
(
*
fn
)
(
cpu
x
y
)
;
}
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
int
GetCPU
(
)
{
unsigned
cpu
;
int
ret_code
=
(
*
VDSOSupport
:
:
getcpu_fn_
)
(
&
cpu
nullptr
nullptr
)
;
return
ret_code
=
=
0
?
cpu
:
ret_code
;
}
}
ABSL_NAMESPACE_END
}
#
endif
