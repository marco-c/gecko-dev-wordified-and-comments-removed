#
ifndef
ABSL_DEBUGGING_INTERNAL_STACKTRACE_EMSCRIPTEN_INL_H_
#
define
ABSL_DEBUGGING_INTERNAL_STACKTRACE_EMSCRIPTEN_INL_H_
#
include
<
emscripten
.
h
>
#
include
<
atomic
>
#
include
<
cstring
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
debugging
/
stacktrace
.
h
"
extern
"
C
"
{
uintptr_t
emscripten_stack_snapshot
(
)
;
uint32_t
emscripten_stack_unwind_buffer
(
uintptr_t
pc
void
*
buffer
uint32_t
depth
)
;
}
static
__thread
int
recursive
=
0
;
static
std
:
:
atomic
<
bool
>
disable_stacktraces
(
true
)
;
ABSL_ATTRIBUTE_UNUSED
static
int
stacktraces_enabler
=
[
]
(
)
{
if
(
!
EM_ASM_INT
(
{
return
(
typeof
wasmOffsetConverter
!
=
=
'
undefined
'
)
;
}
)
)
{
return
0
;
}
disable_stacktraces
.
store
(
false
std
:
:
memory_order_relaxed
)
;
return
0
;
}
(
)
;
template
<
bool
IS_STACK_FRAMES
bool
IS_WITH_CONTEXT
>
static
int
UnwindImpl
(
void
*
*
result
int
*
sizes
int
max_depth
int
skip_count
const
void
*
ucp
int
*
min_dropped_frames
)
{
if
(
recursive
|
|
disable_stacktraces
.
load
(
std
:
:
memory_order_relaxed
)
)
{
return
0
;
}
+
+
recursive
;
static_cast
<
void
>
(
ucp
)
;
constexpr
int
kStackLength
=
64
;
void
*
stack
[
kStackLength
]
;
int
size
;
uintptr_t
pc
=
emscripten_stack_snapshot
(
)
;
size
=
emscripten_stack_unwind_buffer
(
pc
stack
kStackLength
)
;
int
result_count
=
size
-
skip_count
;
if
(
result_count
<
0
)
result_count
=
0
;
if
(
result_count
>
max_depth
)
result_count
=
max_depth
;
for
(
int
i
=
0
;
i
<
result_count
;
i
+
+
)
result
[
i
]
=
stack
[
i
+
skip_count
]
;
if
(
IS_STACK_FRAMES
)
{
memset
(
sizes
0
sizeof
(
*
sizes
)
*
result_count
)
;
}
if
(
min_dropped_frames
!
=
nullptr
)
{
if
(
size
-
skip_count
-
max_depth
>
0
)
{
*
min_dropped_frames
=
size
-
skip_count
-
max_depth
;
}
else
{
*
min_dropped_frames
=
0
;
}
}
-
-
recursive
;
return
result_count
;
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
bool
StackTraceWorksForTest
(
)
{
return
true
;
}
}
ABSL_NAMESPACE_END
}
#
endif
