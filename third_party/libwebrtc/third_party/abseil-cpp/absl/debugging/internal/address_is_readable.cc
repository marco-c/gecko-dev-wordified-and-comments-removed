#
include
"
absl
/
debugging
/
internal
/
address_is_readable
.
h
"
#
if
!
defined
(
__linux__
)
|
|
defined
(
__ANDROID__
)
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
bool
AddressIsReadable
(
const
void
*
)
{
return
true
;
}
}
ABSL_NAMESPACE_END
}
#
else
#
include
<
fcntl
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
unistd
.
h
>
#
include
<
atomic
>
#
include
<
cerrno
>
#
include
<
cstdint
>
#
include
"
absl
/
base
/
internal
/
errno_saver
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
static
uint64_t
Pack
(
uint64_t
pid
uint64_t
read_fd
uint64_t
write_fd
)
{
ABSL_RAW_CHECK
(
(
read_fd
>
>
24
)
=
=
0
&
&
(
write_fd
>
>
24
)
=
=
0
"
fd
out
of
range
"
)
;
return
(
pid
<
<
48
)
|
(
(
read_fd
&
0xffffff
)
<
<
24
)
|
(
write_fd
&
0xffffff
)
;
}
static
void
Unpack
(
uint64_t
x
int
*
pid
int
*
read_fd
int
*
write_fd
)
{
*
pid
=
x
>
>
48
;
*
read_fd
=
(
x
>
>
24
)
&
0xffffff
;
*
write_fd
=
x
&
0xffffff
;
}
static
std
:
:
atomic
<
uint64_t
>
pid_and_fds
;
bool
AddressIsReadable
(
const
void
*
addr
)
{
absl
:
:
base_internal
:
:
ErrnoSaver
errno_saver
;
int
bytes_written
;
int
current_pid
=
getpid
(
)
&
0xffff
;
do
{
int
pid
;
int
read_fd
;
int
write_fd
;
uint64_t
local_pid_and_fds
=
pid_and_fds
.
load
(
std
:
:
memory_order_acquire
)
;
Unpack
(
local_pid_and_fds
&
pid
&
read_fd
&
write_fd
)
;
while
(
current_pid
!
=
pid
)
{
int
p
[
2
]
;
if
(
pipe
(
p
)
!
=
0
)
{
ABSL_RAW_LOG
(
FATAL
"
Failed
to
create
pipe
errno
=
%
d
"
errno
)
;
}
fcntl
(
p
[
0
]
F_SETFD
FD_CLOEXEC
)
;
fcntl
(
p
[
1
]
F_SETFD
FD_CLOEXEC
)
;
uint64_t
new_pid_and_fds
=
Pack
(
current_pid
p
[
0
]
p
[
1
]
)
;
if
(
pid_and_fds
.
compare_exchange_strong
(
local_pid_and_fds
new_pid_and_fds
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
)
{
local_pid_and_fds
=
new_pid_and_fds
;
}
else
{
close
(
p
[
0
]
)
;
close
(
p
[
1
]
)
;
local_pid_and_fds
=
pid_and_fds
.
load
(
std
:
:
memory_order_acquire
)
;
}
Unpack
(
local_pid_and_fds
&
pid
&
read_fd
&
write_fd
)
;
}
errno
=
0
;
do
{
bytes_written
=
syscall
(
SYS_write
write_fd
addr
1
)
;
}
while
(
bytes_written
=
=
-
1
&
&
errno
=
=
EINTR
)
;
if
(
bytes_written
=
=
1
)
{
char
c
;
while
(
read
(
read_fd
&
c
1
)
=
=
-
1
&
&
errno
=
=
EINTR
)
{
}
}
if
(
errno
=
=
EBADF
)
{
pid_and_fds
.
compare_exchange_strong
(
local_pid_and_fds
0
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
;
}
}
while
(
errno
=
=
EBADF
)
;
return
bytes_written
=
=
1
;
}
}
ABSL_NAMESPACE_END
}
#
endif
