#
include
"
absl
/
debugging
/
internal
/
stack_consumption
.
h
"
#
ifdef
ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
#
include
<
signal
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
unistd
.
h
>
#
include
<
string
.
h
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
debugging_internal
{
namespace
{
#
if
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
|
|
defined
(
__ppc__
)
|
|
\
defined
(
__aarch64__
)
|
|
defined
(
__riscv
)
constexpr
bool
kStackGrowsDown
=
true
;
#
else
#
error
Need
to
define
kStackGrowsDown
#
endif
void
EmptySignalHandler
(
int
)
{
}
constexpr
int
kAlternateStackSize
=
64
<
<
10
;
constexpr
int
kSafetyMargin
=
32
;
constexpr
char
kAlternateStackFillValue
=
0x55
;
int
GetStackConsumption
(
const
void
*
const
altstack
)
{
const
char
*
begin
;
int
increment
;
if
(
kStackGrowsDown
)
{
begin
=
reinterpret_cast
<
const
char
*
>
(
altstack
)
;
increment
=
1
;
}
else
{
begin
=
reinterpret_cast
<
const
char
*
>
(
altstack
)
+
kAlternateStackSize
-
1
;
increment
=
-
1
;
}
for
(
int
usage_count
=
kAlternateStackSize
;
usage_count
>
0
;
-
-
usage_count
)
{
if
(
*
begin
!
=
kAlternateStackFillValue
)
{
ABSL_RAW_CHECK
(
usage_count
<
=
kAlternateStackSize
-
kSafetyMargin
"
Buffer
has
overflowed
or
is
about
to
overflow
"
)
;
return
usage_count
;
}
begin
+
=
increment
;
}
ABSL_RAW_LOG
(
FATAL
"
Unreachable
code
"
)
;
return
-
1
;
}
}
int
GetSignalHandlerStackConsumption
(
void
(
*
signal_handler
)
(
int
)
)
{
void
*
altstack
=
mmap
(
nullptr
kAlternateStackSize
PROT_READ
|
PROT_WRITE
MAP_PRIVATE
|
MAP_ANONYMOUS
-
1
0
)
;
ABSL_RAW_CHECK
(
altstack
!
=
MAP_FAILED
"
mmap
(
)
failed
"
)
;
stack_t
sigstk
;
memset
(
&
sigstk
0
sizeof
(
sigstk
)
)
;
sigstk
.
ss_sp
=
altstack
;
sigstk
.
ss_size
=
kAlternateStackSize
;
sigstk
.
ss_flags
=
0
;
stack_t
old_sigstk
;
memset
(
&
old_sigstk
0
sizeof
(
old_sigstk
)
)
;
ABSL_RAW_CHECK
(
sigaltstack
(
&
sigstk
&
old_sigstk
)
=
=
0
"
sigaltstack
(
)
failed
"
)
;
struct
sigaction
sa
;
memset
(
&
sa
0
sizeof
(
sa
)
)
;
struct
sigaction
old_sa1
old_sa2
;
sigemptyset
(
&
sa
.
sa_mask
)
;
sa
.
sa_flags
=
SA_ONSTACK
;
sa
.
sa_handler
=
EmptySignalHandler
;
ABSL_RAW_CHECK
(
sigaction
(
SIGUSR1
&
sa
&
old_sa1
)
=
=
0
"
sigaction
(
)
failed
"
)
;
sa
.
sa_handler
=
signal_handler
;
ABSL_RAW_CHECK
(
sigaction
(
SIGUSR2
&
sa
&
old_sa2
)
=
=
0
"
sigaction
(
)
failed
"
)
;
ABSL_RAW_CHECK
(
kill
(
getpid
(
)
SIGUSR1
)
=
=
0
"
kill
(
)
failed
"
)
;
memset
(
altstack
kAlternateStackFillValue
kAlternateStackSize
)
;
ABSL_RAW_CHECK
(
kill
(
getpid
(
)
SIGUSR1
)
=
=
0
"
kill
(
)
failed
"
)
;
int
base_stack_consumption
=
GetStackConsumption
(
altstack
)
;
ABSL_RAW_CHECK
(
kill
(
getpid
(
)
SIGUSR2
)
=
=
0
"
kill
(
)
failed
"
)
;
int
signal_handler_stack_consumption
=
GetStackConsumption
(
altstack
)
;
if
(
old_sigstk
.
ss_sp
=
=
nullptr
&
&
old_sigstk
.
ss_size
=
=
0
&
&
(
old_sigstk
.
ss_flags
&
SS_DISABLE
)
)
{
old_sigstk
.
ss_size
=
MINSIGSTKSZ
;
}
ABSL_RAW_CHECK
(
sigaltstack
(
&
old_sigstk
nullptr
)
=
=
0
"
sigaltstack
(
)
failed
"
)
;
ABSL_RAW_CHECK
(
sigaction
(
SIGUSR1
&
old_sa1
nullptr
)
=
=
0
"
sigaction
(
)
failed
"
)
;
ABSL_RAW_CHECK
(
sigaction
(
SIGUSR2
&
old_sa2
nullptr
)
=
=
0
"
sigaction
(
)
failed
"
)
;
ABSL_RAW_CHECK
(
munmap
(
altstack
kAlternateStackSize
)
=
=
0
"
munmap
(
)
failed
"
)
;
if
(
signal_handler_stack_consumption
!
=
-
1
&
&
base_stack_consumption
!
=
-
1
)
{
return
signal_handler_stack_consumption
-
base_stack_consumption
;
}
return
-
1
;
}
}
ABSL_NAMESPACE_END
}
#
endif
