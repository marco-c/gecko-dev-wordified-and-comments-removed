#
include
<
windows
.
h
>
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4091
)
#
include
<
dbghelp
.
h
>
#
pragma
warning
(
pop
)
#
pragma
comment
(
lib
"
dbghelp
.
lib
"
)
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
static
HANDLE
process
=
NULL
;
void
InitializeSymbolizer
(
const
char
*
)
{
if
(
process
!
=
nullptr
)
{
return
;
}
process
=
GetCurrentProcess
(
)
;
SymSetOptions
(
SYMOPT_DEFERRED_LOADS
|
SYMOPT_UNDNAME
)
;
if
(
!
SymInitialize
(
process
nullptr
true
)
)
{
const
unsigned
long
long
error
{
GetLastError
(
)
}
;
ABSL_RAW_LOG
(
FATAL
"
SymInitialize
(
)
failed
:
%
llu
"
error
)
;
}
}
bool
Symbolize
(
const
void
*
pc
char
*
out
int
out_size
)
{
if
(
out_size
<
=
0
)
{
return
false
;
}
alignas
(
SYMBOL_INFO
)
char
buf
[
sizeof
(
SYMBOL_INFO
)
+
MAX_SYM_NAME
]
;
SYMBOL_INFO
*
symbol
=
reinterpret_cast
<
SYMBOL_INFO
*
>
(
buf
)
;
symbol
-
>
SizeOfStruct
=
sizeof
(
SYMBOL_INFO
)
;
symbol
-
>
MaxNameLen
=
MAX_SYM_NAME
;
if
(
!
SymFromAddr
(
process
reinterpret_cast
<
DWORD64
>
(
pc
)
nullptr
symbol
)
)
{
return
false
;
}
const
size_t
out_size_t
=
static_cast
<
size_t
>
(
out_size
)
;
strncpy
(
out
symbol
-
>
Name
out_size_t
)
;
if
(
out
[
out_size_t
-
1
]
!
=
'
\
0
'
)
{
static
constexpr
char
kEllipsis
[
]
=
"
.
.
.
"
;
size_t
ellipsis_size
=
std
:
:
min
(
sizeof
(
kEllipsis
)
-
1
out_size_t
-
1
)
;
memcpy
(
out
+
out_size_t
-
ellipsis_size
-
1
kEllipsis
ellipsis_size
)
;
out
[
out_size_t
-
1
]
=
'
\
0
'
;
}
return
true
;
}
ABSL_NAMESPACE_END
}
