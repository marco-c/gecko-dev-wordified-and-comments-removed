#
include
"
absl
/
debugging
/
symbolize
.
h
"
#
ifndef
_WIN32
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
endif
#
include
<
cstring
>
#
include
<
iostream
>
#
include
<
memory
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
casts
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
per_thread_tls
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
debugging
/
internal
/
stack_consumption
.
h
"
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
using
testing
:
:
Contains
;
#
ifdef
_WIN32
#
define
ABSL_SYMBOLIZE_TEST_NOINLINE
__declspec
(
noinline
)
#
else
#
define
ABSL_SYMBOLIZE_TEST_NOINLINE
ABSL_ATTRIBUTE_NOINLINE
#
endif
extern
"
C
"
{
ABSL_SYMBOLIZE_TEST_NOINLINE
void
nonstatic_func
(
)
{
volatile
int
x
=
__LINE__
;
static_cast
<
void
>
(
x
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
}
ABSL_SYMBOLIZE_TEST_NOINLINE
static
void
static_func
(
)
{
volatile
int
x
=
__LINE__
;
static_cast
<
void
>
(
x
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
}
}
struct
Foo
{
static
void
func
(
int
x
)
;
}
;
ABSL_SYMBOLIZE_TEST_NOINLINE
void
Foo
:
:
func
(
int
)
{
volatile
int
x
=
__LINE__
;
static_cast
<
void
>
(
x
)
;
ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
(
)
;
}
int
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
.
unlikely
)
unlikely_func
(
)
{
return
0
;
}
int
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
.
hot
)
hot_func
(
)
{
return
0
;
}
int
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
.
startup
)
startup_func
(
)
{
return
0
;
}
int
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
.
exit
)
exit_func
(
)
{
return
0
;
}
int
regular_func
(
)
{
return
0
;
}
#
if
ABSL_PER_THREAD_TLS
static
ABSL_PER_THREAD_TLS_KEYWORD
char
symbolize_test_thread_small
[
1
]
;
static
ABSL_PER_THREAD_TLS_KEYWORD
char
symbolize_test_thread_big
[
2
*
1024
*
1024
]
;
#
endif
#
if
!
defined
(
__EMSCRIPTEN__
)
static
volatile
bool
volatile_bool
=
false
;
static
constexpr
size_t
kHpageSize
=
1
<
<
21
;
const
char
kHpageTextPadding
[
kHpageSize
*
4
]
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
)
=
"
"
;
#
endif
static
char
try_symbolize_buffer
[
4096
]
;
static
const
char
*
TrySymbolizeWithLimit
(
void
*
pc
int
limit
)
{
ABSL_RAW_CHECK
(
limit
<
=
sizeof
(
try_symbolize_buffer
)
"
try_symbolize_buffer
is
too
small
"
)
;
auto
heap_buffer
=
absl
:
:
make_unique
<
char
[
]
>
(
sizeof
(
try_symbolize_buffer
)
)
;
bool
found
=
absl
:
:
Symbolize
(
pc
heap_buffer
.
get
(
)
limit
)
;
if
(
found
)
{
ABSL_RAW_CHECK
(
strnlen
(
heap_buffer
.
get
(
)
limit
)
<
limit
"
absl
:
:
Symbolize
(
)
did
not
properly
terminate
the
string
"
)
;
strncpy
(
try_symbolize_buffer
heap_buffer
.
get
(
)
sizeof
(
try_symbolize_buffer
)
-
1
)
;
try_symbolize_buffer
[
sizeof
(
try_symbolize_buffer
)
-
1
]
=
'
\
0
'
;
}
return
found
?
try_symbolize_buffer
:
nullptr
;
}
static
const
char
*
TrySymbolize
(
void
*
pc
)
{
return
TrySymbolizeWithLimit
(
pc
sizeof
(
try_symbolize_buffer
)
)
;
}
#
if
defined
(
ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE
)
|
|
\
defined
(
ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
)
|
|
\
defined
(
ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE
)
void
ABSL_ATTRIBUTE_NOINLINE
TestWithReturnAddress
(
)
{
#
if
defined
(
ABSL_HAVE_ATTRIBUTE_NOINLINE
)
void
*
return_address
=
__builtin_return_address
(
0
)
;
const
char
*
symbol
=
TrySymbolize
(
return_address
)
;
ABSL_RAW_CHECK
(
symbol
!
=
nullptr
"
TestWithReturnAddress
failed
"
)
;
ABSL_RAW_CHECK
(
strcmp
(
symbol
"
main
"
)
=
=
0
"
TestWithReturnAddress
failed
"
)
;
std
:
:
cout
<
<
"
TestWithReturnAddress
passed
"
<
<
std
:
:
endl
;
#
endif
}
#
ifndef
ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE
TEST
(
Symbolize
Cached
)
{
EXPECT_STREQ
(
"
nonstatic_func
"
TrySymbolize
(
(
void
*
)
(
&
nonstatic_func
)
)
)
;
const
char
*
static_func_symbol
=
TrySymbolize
(
(
void
*
)
(
&
static_func
)
)
;
EXPECT_TRUE
(
strcmp
(
"
static_func
"
static_func_symbol
)
=
=
0
|
|
strcmp
(
"
static_func
(
)
"
static_func_symbol
)
=
=
0
)
;
EXPECT_TRUE
(
nullptr
=
=
TrySymbolize
(
nullptr
)
)
;
}
TEST
(
Symbolize
Truncation
)
{
constexpr
char
kNonStaticFunc
[
]
=
"
nonstatic_func
"
;
EXPECT_STREQ
(
"
nonstatic_func
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
strlen
(
kNonStaticFunc
)
+
1
)
)
;
EXPECT_STREQ
(
"
nonstatic_
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
strlen
(
kNonStaticFunc
)
+
0
)
)
;
EXPECT_STREQ
(
"
nonstatic
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
strlen
(
kNonStaticFunc
)
-
1
)
)
;
EXPECT_STREQ
(
"
n
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
5
)
)
;
EXPECT_STREQ
(
"
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
4
)
)
;
EXPECT_STREQ
(
"
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
3
)
)
;
EXPECT_STREQ
(
"
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
2
)
)
;
EXPECT_STREQ
(
"
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
1
)
)
;
EXPECT_EQ
(
nullptr
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
0
)
)
;
}
TEST
(
Symbolize
SymbolizeWithDemangling
)
{
Foo
:
:
func
(
100
)
;
EXPECT_STREQ
(
"
Foo
:
:
func
(
)
"
TrySymbolize
(
(
void
*
)
(
&
Foo
:
:
func
)
)
)
;
}
TEST
(
Symbolize
SymbolizeSplitTextSections
)
{
EXPECT_STREQ
(
"
unlikely_func
(
)
"
TrySymbolize
(
(
void
*
)
(
&
unlikely_func
)
)
)
;
EXPECT_STREQ
(
"
hot_func
(
)
"
TrySymbolize
(
(
void
*
)
(
&
hot_func
)
)
)
;
EXPECT_STREQ
(
"
startup_func
(
)
"
TrySymbolize
(
(
void
*
)
(
&
startup_func
)
)
)
;
EXPECT_STREQ
(
"
exit_func
(
)
"
TrySymbolize
(
(
void
*
)
(
&
exit_func
)
)
)
;
EXPECT_STREQ
(
"
regular_func
(
)
"
TrySymbolize
(
(
void
*
)
(
&
regular_func
)
)
)
;
}
#
ifdef
ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
static
void
*
g_pc_to_symbolize
;
static
char
g_symbolize_buffer
[
4096
]
;
static
char
*
g_symbolize_result
;
static
void
SymbolizeSignalHandler
(
int
signo
)
{
if
(
absl
:
:
Symbolize
(
g_pc_to_symbolize
g_symbolize_buffer
sizeof
(
g_symbolize_buffer
)
)
)
{
g_symbolize_result
=
g_symbolize_buffer
;
}
else
{
g_symbolize_result
=
nullptr
;
}
}
static
const
char
*
SymbolizeStackConsumption
(
void
*
pc
int
*
stack_consumed
)
{
g_pc_to_symbolize
=
pc
;
*
stack_consumed
=
absl
:
:
debugging_internal
:
:
GetSignalHandlerStackConsumption
(
SymbolizeSignalHandler
)
;
return
g_symbolize_result
;
}
static
int
GetStackConsumptionUpperLimit
(
)
{
int
stack_consumption_upper_limit
=
2048
;
#
if
defined
(
ABSL_HAVE_ADDRESS_SANITIZER
)
|
|
\
defined
(
ABSL_HAVE_MEMORY_SANITIZER
)
|
|
defined
(
ABSL_HAVE_THREAD_SANITIZER
)
stack_consumption_upper_limit
*
=
5
;
#
endif
return
stack_consumption_upper_limit
;
}
TEST
(
Symbolize
SymbolizeStackConsumption
)
{
int
stack_consumed
=
0
;
const
char
*
symbol
=
SymbolizeStackConsumption
(
(
void
*
)
(
&
nonstatic_func
)
&
stack_consumed
)
;
EXPECT_STREQ
(
"
nonstatic_func
"
symbol
)
;
EXPECT_GT
(
stack_consumed
0
)
;
EXPECT_LT
(
stack_consumed
GetStackConsumptionUpperLimit
(
)
)
;
symbol
=
SymbolizeStackConsumption
(
(
void
*
)
(
&
static_func
)
&
stack_consumed
)
;
EXPECT_TRUE
(
strcmp
(
"
static_func
"
symbol
)
=
=
0
|
|
strcmp
(
"
static_func
(
)
"
symbol
)
=
=
0
)
;
EXPECT_GT
(
stack_consumed
0
)
;
EXPECT_LT
(
stack_consumed
GetStackConsumptionUpperLimit
(
)
)
;
}
TEST
(
Symbolize
SymbolizeWithDemanglingStackConsumption
)
{
Foo
:
:
func
(
100
)
;
int
stack_consumed
=
0
;
const
char
*
symbol
=
SymbolizeStackConsumption
(
(
void
*
)
(
&
Foo
:
:
func
)
&
stack_consumed
)
;
EXPECT_STREQ
(
"
Foo
:
:
func
(
)
"
symbol
)
;
EXPECT_GT
(
stack_consumed
0
)
;
EXPECT_LT
(
stack_consumed
GetStackConsumptionUpperLimit
(
)
)
;
}
#
endif
#
ifndef
ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
const
size_t
kPageSize
=
64
<
<
10
;
const
char
kPadding0
[
kPageSize
*
4
]
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
)
=
"
"
;
const
char
kPadding1
[
kPageSize
*
4
]
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
.
text
)
=
"
"
;
static
int
FilterElfHeader
(
struct
dl_phdr_info
*
info
size_t
size
void
*
data
)
{
for
(
int
i
=
0
;
i
<
info
-
>
dlpi_phnum
;
i
+
+
)
{
if
(
info
-
>
dlpi_phdr
[
i
]
.
p_type
=
=
PT_LOAD
&
&
info
-
>
dlpi_phdr
[
i
]
.
p_flags
=
=
(
PF_R
|
PF_X
)
)
{
const
void
*
const
vaddr
=
absl
:
:
bit_cast
<
void
*
>
(
info
-
>
dlpi_addr
+
info
-
>
dlpi_phdr
[
i
]
.
p_vaddr
)
;
const
auto
segsize
=
info
-
>
dlpi_phdr
[
i
]
.
p_memsz
;
const
char
*
self_exe
;
if
(
info
-
>
dlpi_name
!
=
nullptr
&
&
info
-
>
dlpi_name
[
0
]
!
=
'
\
0
'
)
{
self_exe
=
info
-
>
dlpi_name
;
}
else
{
self_exe
=
"
/
proc
/
self
/
exe
"
;
}
absl
:
:
debugging_internal
:
:
RegisterFileMappingHint
(
vaddr
reinterpret_cast
<
const
char
*
>
(
vaddr
)
+
segsize
info
-
>
dlpi_phdr
[
i
]
.
p_offset
self_exe
)
;
return
1
;
}
}
return
1
;
}
TEST
(
Symbolize
SymbolizeWithMultipleMaps
)
{
if
(
volatile_bool
)
{
ABSL_RAW_LOG
(
INFO
"
%
s
"
kPadding0
)
;
ABSL_RAW_LOG
(
INFO
"
%
s
"
kPadding1
)
;
}
char
buf
[
512
]
;
memset
(
buf
0
sizeof
(
buf
)
)
;
absl
:
:
Symbolize
(
kPadding0
buf
sizeof
(
buf
)
)
;
EXPECT_STREQ
(
"
kPadding0
"
buf
)
;
memset
(
buf
0
sizeof
(
buf
)
)
;
absl
:
:
Symbolize
(
kPadding1
buf
sizeof
(
buf
)
)
;
EXPECT_STREQ
(
"
kPadding1
"
buf
)
;
dl_iterate_phdr
(
FilterElfHeader
nullptr
)
;
const
char
*
ptrs
[
]
=
{
kPadding0
kPadding1
}
;
for
(
const
char
*
ptr
:
ptrs
)
{
const
int
kMapFlags
=
MAP_ANONYMOUS
|
MAP_PRIVATE
;
void
*
addr
=
mmap
(
nullptr
kPageSize
PROT_READ
kMapFlags
0
0
)
;
ASSERT_NE
(
addr
MAP_FAILED
)
;
void
*
remapped
=
reinterpret_cast
<
void
*
>
(
reinterpret_cast
<
uintptr_t
>
(
ptr
+
kPageSize
)
&
~
(
kPageSize
-
1ULL
)
)
;
const
int
kMremapFlags
=
(
MREMAP_MAYMOVE
|
MREMAP_FIXED
)
;
void
*
ret
=
mremap
(
addr
kPageSize
kPageSize
kMremapFlags
remapped
)
;
ASSERT_NE
(
ret
MAP_FAILED
)
;
}
absl
:
:
Symbolize
(
nullptr
buf
sizeof
(
buf
)
)
;
const
char
*
expected
[
]
=
{
"
kPadding0
"
"
kPadding1
"
}
;
const
size_t
offsets
[
]
=
{
0
kPageSize
2
*
kPageSize
3
*
kPageSize
}
;
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
{
for
(
size_t
offset
:
offsets
)
{
memset
(
buf
0
sizeof
(
buf
)
)
;
absl
:
:
Symbolize
(
ptrs
[
i
]
+
offset
buf
sizeof
(
buf
)
)
;
EXPECT_STREQ
(
expected
[
i
]
buf
)
;
}
}
}
static
void
DummySymbolDecorator
(
const
absl
:
:
debugging_internal
:
:
SymbolDecoratorArgs
*
args
)
{
std
:
:
string
*
message
=
static_cast
<
std
:
:
string
*
>
(
args
-
>
arg
)
;
strncat
(
args
-
>
symbol_buf
message
-
>
c_str
(
)
args
-
>
symbol_buf_size
-
strlen
(
args
-
>
symbol_buf
)
-
1
)
;
}
TEST
(
Symbolize
InstallAndRemoveSymbolDecorators
)
{
int
ticket_a
;
std
:
:
string
a_message
(
"
a
"
)
;
EXPECT_GE
(
ticket_a
=
absl
:
:
debugging_internal
:
:
InstallSymbolDecorator
(
DummySymbolDecorator
&
a_message
)
0
)
;
int
ticket_b
;
std
:
:
string
b_message
(
"
b
"
)
;
EXPECT_GE
(
ticket_b
=
absl
:
:
debugging_internal
:
:
InstallSymbolDecorator
(
DummySymbolDecorator
&
b_message
)
0
)
;
int
ticket_c
;
std
:
:
string
c_message
(
"
c
"
)
;
EXPECT_GE
(
ticket_c
=
absl
:
:
debugging_internal
:
:
InstallSymbolDecorator
(
DummySymbolDecorator
&
c_message
)
0
)
;
char
*
address
=
reinterpret_cast
<
char
*
>
(
1
)
;
EXPECT_STREQ
(
"
abc
"
TrySymbolize
(
address
+
+
)
)
;
EXPECT_TRUE
(
absl
:
:
debugging_internal
:
:
RemoveSymbolDecorator
(
ticket_b
)
)
;
EXPECT_STREQ
(
"
ac
"
TrySymbolize
(
address
+
+
)
)
;
EXPECT_TRUE
(
absl
:
:
debugging_internal
:
:
RemoveSymbolDecorator
(
ticket_a
)
)
;
EXPECT_TRUE
(
absl
:
:
debugging_internal
:
:
RemoveSymbolDecorator
(
ticket_c
)
)
;
}
static
int
in_data_section
=
1
;
TEST
(
Symbolize
ForEachSection
)
{
int
fd
=
TEMP_FAILURE_RETRY
(
open
(
"
/
proc
/
self
/
exe
"
O_RDONLY
)
)
;
ASSERT_NE
(
fd
-
1
)
;
std
:
:
vector
<
std
:
:
string
>
sections
;
ASSERT_TRUE
(
absl
:
:
debugging_internal
:
:
ForEachSection
(
fd
[
&
sections
]
(
const
absl
:
:
string_view
name
const
ElfW
(
Shdr
)
&
)
{
sections
.
emplace_back
(
name
)
;
return
true
;
}
)
)
;
EXPECT_THAT
(
sections
Contains
(
"
.
text
"
)
)
;
EXPECT_THAT
(
sections
Contains
(
"
.
rodata
"
)
)
;
EXPECT_THAT
(
sections
Contains
(
"
.
bss
"
)
)
;
+
+
in_data_section
;
EXPECT_THAT
(
sections
Contains
(
"
.
data
"
)
)
;
close
(
fd
)
;
}
#
endif
#
endif
extern
"
C
"
{
inline
void
*
ABSL_ATTRIBUTE_ALWAYS_INLINE
inline_func
(
)
{
void
*
pc
=
nullptr
;
#
if
defined
(
__i386__
)
__asm__
__volatile__
(
"
call
1f
;
\
n
1
:
pop
%
[
PC
]
"
:
[
PC
]
"
=
r
"
(
pc
)
)
;
#
elif
defined
(
__x86_64__
)
__asm__
__volatile__
(
"
leaq
0
(
%
%
rip
)
%
[
PC
]
;
\
n
"
:
[
PC
]
"
=
r
"
(
pc
)
)
;
#
endif
return
pc
;
}
void
*
ABSL_ATTRIBUTE_NOINLINE
non_inline_func
(
)
{
void
*
pc
=
nullptr
;
#
if
defined
(
__i386__
)
__asm__
__volatile__
(
"
call
1f
;
\
n
1
:
pop
%
[
PC
]
"
:
[
PC
]
"
=
r
"
(
pc
)
)
;
#
elif
defined
(
__x86_64__
)
__asm__
__volatile__
(
"
leaq
0
(
%
%
rip
)
%
[
PC
]
;
\
n
"
:
[
PC
]
"
=
r
"
(
pc
)
)
;
#
endif
return
pc
;
}
void
ABSL_ATTRIBUTE_NOINLINE
TestWithPCInsideNonInlineFunction
(
)
{
#
if
defined
(
ABSL_HAVE_ATTRIBUTE_NOINLINE
)
&
&
\
(
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
)
void
*
pc
=
non_inline_func
(
)
;
const
char
*
symbol
=
TrySymbolize
(
pc
)
;
ABSL_RAW_CHECK
(
symbol
!
=
nullptr
"
TestWithPCInsideNonInlineFunction
failed
"
)
;
ABSL_RAW_CHECK
(
strcmp
(
symbol
"
non_inline_func
"
)
=
=
0
"
TestWithPCInsideNonInlineFunction
failed
"
)
;
std
:
:
cout
<
<
"
TestWithPCInsideNonInlineFunction
passed
"
<
<
std
:
:
endl
;
#
endif
}
void
ABSL_ATTRIBUTE_NOINLINE
TestWithPCInsideInlineFunction
(
)
{
#
if
defined
(
ABSL_HAVE_ATTRIBUTE_ALWAYS_INLINE
)
&
&
\
(
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
)
void
*
pc
=
inline_func
(
)
;
const
char
*
symbol
=
TrySymbolize
(
pc
)
;
ABSL_RAW_CHECK
(
symbol
!
=
nullptr
"
TestWithPCInsideInlineFunction
failed
"
)
;
ABSL_RAW_CHECK
(
strcmp
(
symbol
__FUNCTION__
)
=
=
0
"
TestWithPCInsideInlineFunction
failed
"
)
;
std
:
:
cout
<
<
"
TestWithPCInsideInlineFunction
passed
"
<
<
std
:
:
endl
;
#
endif
}
}
#
if
defined
(
__arm__
)
&
&
ABSL_HAVE_ATTRIBUTE
(
target
)
__attribute__
(
(
target
(
"
thumb
"
)
)
)
int
ArmThumbOverlapThumb
(
int
x
)
{
return
x
*
x
*
x
;
}
__attribute__
(
(
target
(
"
arm
"
)
)
)
int
ArmThumbOverlapArm
(
int
x
)
{
return
x
*
x
*
x
;
}
void
ABSL_ATTRIBUTE_NOINLINE
TestArmThumbOverlap
(
)
{
#
if
defined
(
ABSL_HAVE_ATTRIBUTE_NOINLINE
)
const
char
*
symbol
=
TrySymbolize
(
(
void
*
)
&
ArmThumbOverlapArm
)
;
ABSL_RAW_CHECK
(
symbol
!
=
nullptr
"
TestArmThumbOverlap
failed
"
)
;
ABSL_RAW_CHECK
(
strcmp
(
"
ArmThumbOverlapArm
(
)
"
symbol
)
=
=
0
"
TestArmThumbOverlap
failed
"
)
;
std
:
:
cout
<
<
"
TestArmThumbOverlap
passed
"
<
<
std
:
:
endl
;
#
endif
}
#
endif
#
elif
defined
(
_WIN32
)
#
if
!
defined
(
ABSL_CONSUME_DLL
)
TEST
(
Symbolize
Basics
)
{
EXPECT_STREQ
(
"
nonstatic_func
"
TrySymbolize
(
(
void
*
)
(
&
nonstatic_func
)
)
)
;
const
char
*
static_func_symbol
=
TrySymbolize
(
(
void
*
)
(
&
static_func
)
)
;
ASSERT_TRUE
(
static_func_symbol
!
=
nullptr
)
;
EXPECT_TRUE
(
strstr
(
static_func_symbol
"
static_func
"
)
!
=
nullptr
)
;
EXPECT_TRUE
(
nullptr
=
=
TrySymbolize
(
nullptr
)
)
;
}
TEST
(
Symbolize
Truncation
)
{
constexpr
char
kNonStaticFunc
[
]
=
"
nonstatic_func
"
;
EXPECT_STREQ
(
"
nonstatic_func
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
strlen
(
kNonStaticFunc
)
+
1
)
)
;
EXPECT_STREQ
(
"
nonstatic_
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
strlen
(
kNonStaticFunc
)
+
0
)
)
;
EXPECT_STREQ
(
"
nonstatic
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
strlen
(
kNonStaticFunc
)
-
1
)
)
;
EXPECT_STREQ
(
"
n
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
5
)
)
;
EXPECT_STREQ
(
"
.
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
4
)
)
;
EXPECT_STREQ
(
"
.
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
3
)
)
;
EXPECT_STREQ
(
"
.
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
2
)
)
;
EXPECT_STREQ
(
"
"
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
1
)
)
;
EXPECT_EQ
(
nullptr
TrySymbolizeWithLimit
(
(
void
*
)
(
&
nonstatic_func
)
0
)
)
;
}
TEST
(
Symbolize
SymbolizeWithDemangling
)
{
const
char
*
result
=
TrySymbolize
(
(
void
*
)
(
&
Foo
:
:
func
)
)
;
ASSERT_TRUE
(
result
!
=
nullptr
)
;
EXPECT_TRUE
(
strstr
(
result
"
Foo
:
:
func
"
)
!
=
nullptr
)
<
<
result
;
}
#
endif
#
else
TEST
(
Symbolize
Unimplemented
)
{
char
buf
[
64
]
;
EXPECT_FALSE
(
absl
:
:
Symbolize
(
(
void
*
)
(
&
nonstatic_func
)
buf
sizeof
(
buf
)
)
)
;
EXPECT_FALSE
(
absl
:
:
Symbolize
(
(
void
*
)
(
&
static_func
)
buf
sizeof
(
buf
)
)
)
;
EXPECT_FALSE
(
absl
:
:
Symbolize
(
(
void
*
)
(
&
Foo
:
:
func
)
buf
sizeof
(
buf
)
)
)
;
}
#
endif
int
main
(
int
argc
char
*
*
argv
)
{
#
if
!
defined
(
__EMSCRIPTEN__
)
if
(
volatile_bool
)
{
ABSL_RAW_LOG
(
INFO
"
%
s
"
kHpageTextPadding
)
;
}
#
endif
#
if
ABSL_PER_THREAD_TLS
symbolize_test_thread_small
[
0
]
=
0
;
symbolize_test_thread_big
[
0
]
=
0
;
#
endif
absl
:
:
InitializeSymbolizer
(
argv
[
0
]
)
;
testing
:
:
InitGoogleTest
(
&
argc
argv
)
;
#
if
defined
(
ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE
)
|
|
\
defined
(
ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
)
TestWithPCInsideInlineFunction
(
)
;
TestWithPCInsideNonInlineFunction
(
)
;
TestWithReturnAddress
(
)
;
#
if
defined
(
__arm__
)
&
&
ABSL_HAVE_ATTRIBUTE
(
target
)
TestArmThumbOverlap
(
)
;
#
endif
#
endif
return
RUN_ALL_TESTS
(
)
;
}
