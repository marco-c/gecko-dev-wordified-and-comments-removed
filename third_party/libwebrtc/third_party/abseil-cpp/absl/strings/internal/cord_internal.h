#
ifndef
ABSL_STRINGS_INTERNAL_CORD_INTERNAL_H_
#
define
ABSL_STRINGS_INTERNAL_CORD_INTERNAL_H_
#
include
<
atomic
>
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
internal
/
invoke
.
h
"
#
include
"
absl
/
container
/
internal
/
compressed_tuple
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
cord_internal
{
class
Refcount
{
public
:
Refcount
(
)
:
count_
{
1
}
{
}
~
Refcount
(
)
{
}
inline
void
Increment
(
)
{
count_
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
}
inline
bool
Decrement
(
)
{
int32_t
refcount
=
count_
.
load
(
std
:
:
memory_order_acquire
)
;
assert
(
refcount
>
0
)
;
return
refcount
!
=
1
&
&
count_
.
fetch_sub
(
1
std
:
:
memory_order_acq_rel
)
!
=
1
;
}
inline
bool
DecrementExpectHighRefcount
(
)
{
int32_t
refcount
=
count_
.
fetch_sub
(
1
std
:
:
memory_order_acq_rel
)
;
assert
(
refcount
>
0
)
;
return
refcount
!
=
1
;
}
inline
int32_t
Get
(
)
const
{
return
count_
.
load
(
std
:
:
memory_order_acquire
)
;
}
inline
bool
IsOne
(
)
{
return
count_
.
load
(
std
:
:
memory_order_acquire
)
=
=
1
;
}
private
:
std
:
:
atomic
<
int32_t
>
count_
;
}
;
struct
CordRepConcat
;
struct
CordRepSubstring
;
struct
CordRepExternal
;
struct
CordRep
{
size_t
length
;
Refcount
refcount
;
uint8_t
tag
;
char
data
[
1
]
;
inline
CordRepConcat
*
concat
(
)
;
inline
const
CordRepConcat
*
concat
(
)
const
;
inline
CordRepSubstring
*
substring
(
)
;
inline
const
CordRepSubstring
*
substring
(
)
const
;
inline
CordRepExternal
*
external
(
)
;
inline
const
CordRepExternal
*
external
(
)
const
;
}
;
struct
CordRepConcat
:
public
CordRep
{
CordRep
*
left
;
CordRep
*
right
;
uint8_t
depth
(
)
const
{
return
static_cast
<
uint8_t
>
(
data
[
0
]
)
;
}
void
set_depth
(
uint8_t
depth
)
{
data
[
0
]
=
static_cast
<
char
>
(
depth
)
;
}
}
;
struct
CordRepSubstring
:
public
CordRep
{
size_t
start
;
CordRep
*
child
;
}
;
using
ExternalReleaserInvoker
=
void
(
*
)
(
CordRepExternal
*
)
;
struct
CordRepExternal
:
public
CordRep
{
const
char
*
base
;
ExternalReleaserInvoker
releaser_invoker
;
}
;
struct
Rank1
{
}
;
struct
Rank0
:
Rank1
{
}
;
template
<
typename
Releaser
typename
=
:
:
absl
:
:
base_internal
:
:
invoke_result_t
<
Releaser
absl
:
:
string_view
>
>
void
InvokeReleaser
(
Rank0
Releaser
&
&
releaser
absl
:
:
string_view
data
)
{
:
:
absl
:
:
base_internal
:
:
invoke
(
std
:
:
forward
<
Releaser
>
(
releaser
)
data
)
;
}
template
<
typename
Releaser
typename
=
:
:
absl
:
:
base_internal
:
:
invoke_result_t
<
Releaser
>
>
void
InvokeReleaser
(
Rank1
Releaser
&
&
releaser
absl
:
:
string_view
)
{
:
:
absl
:
:
base_internal
:
:
invoke
(
std
:
:
forward
<
Releaser
>
(
releaser
)
)
;
}
template
<
typename
Releaser
>
struct
CordRepExternalImpl
:
public
CordRepExternal
public
:
:
absl
:
:
container_internal
:
:
CompressedTuple
<
Releaser
>
{
template
<
typename
T
>
CordRepExternalImpl
(
T
&
&
releaser
int
)
:
CordRepExternalImpl
:
:
CompressedTuple
(
std
:
:
forward
<
T
>
(
releaser
)
)
{
this
-
>
releaser_invoker
=
&
Release
;
}
~
CordRepExternalImpl
(
)
{
InvokeReleaser
(
Rank0
{
}
std
:
:
move
(
this
-
>
template
get
<
0
>
(
)
)
absl
:
:
string_view
(
base
length
)
)
;
}
static
void
Release
(
CordRepExternal
*
rep
)
{
delete
static_cast
<
CordRepExternalImpl
*
>
(
rep
)
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
