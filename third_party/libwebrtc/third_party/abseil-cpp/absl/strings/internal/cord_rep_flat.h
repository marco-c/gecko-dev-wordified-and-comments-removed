#
ifndef
ABSL_STRINGS_INTERNAL_CORD_REP_FLAT_H_
#
define
ABSL_STRINGS_INTERNAL_CORD_REP_FLAT_H_
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
strings
/
internal
/
cord_internal
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
cord_internal
{
static
constexpr
size_t
kFlatOverhead
=
offsetof
(
CordRep
storage
)
;
static
constexpr
size_t
kMinFlatSize
=
32
;
static
constexpr
size_t
kMaxFlatSize
=
4096
;
static
constexpr
size_t
kMaxFlatLength
=
kMaxFlatSize
-
kFlatOverhead
;
static
constexpr
size_t
kMinFlatLength
=
kMinFlatSize
-
kFlatOverhead
;
static
constexpr
size_t
kMaxLargeFlatSize
=
256
*
1024
;
static
constexpr
size_t
kMaxLargeFlatLength
=
kMaxLargeFlatSize
-
kFlatOverhead
;
static
constexpr
uint8_t
kTagBase
=
FLAT
-
4
;
constexpr
uint8_t
AllocatedSizeToTagUnchecked
(
size_t
size
)
{
return
static_cast
<
uint8_t
>
(
size
<
=
512
?
kTagBase
+
size
/
8
:
size
<
=
8192
?
kTagBase
+
512
/
8
+
size
/
64
-
512
/
64
:
kTagBase
+
512
/
8
+
(
(
8192
-
512
)
/
64
)
+
size
/
4096
-
8192
/
4096
)
;
}
constexpr
size_t
TagToAllocatedSize
(
uint8_t
tag
)
{
return
(
tag
<
=
kTagBase
+
512
/
8
)
?
tag
*
8
-
kTagBase
*
8
:
(
tag
<
=
kTagBase
+
(
512
/
8
)
+
(
(
8192
-
512
)
/
64
)
)
?
512
+
tag
*
64
-
kTagBase
*
64
-
512
/
8
*
64
:
8192
+
tag
*
4096
-
kTagBase
*
4096
-
(
(
512
/
8
)
+
(
(
8192
-
512
)
/
64
)
)
*
4096
;
}
static_assert
(
AllocatedSizeToTagUnchecked
(
kMinFlatSize
)
=
=
FLAT
"
"
)
;
static_assert
(
AllocatedSizeToTagUnchecked
(
kMaxLargeFlatSize
)
=
=
MAX_FLAT_TAG
"
"
)
;
constexpr
size_t
RoundUp
(
size_t
n
size_t
m
)
{
return
(
n
+
m
-
1
)
&
(
0
-
m
)
;
}
inline
size_t
RoundUpForTag
(
size_t
size
)
{
return
RoundUp
(
size
(
size
<
=
512
)
?
8
:
(
size
<
=
8192
?
64
:
4096
)
)
;
}
inline
uint8_t
AllocatedSizeToTag
(
size_t
size
)
{
const
uint8_t
tag
=
AllocatedSizeToTagUnchecked
(
size
)
;
assert
(
tag
<
=
MAX_FLAT_TAG
)
;
return
tag
;
}
constexpr
size_t
TagToLength
(
uint8_t
tag
)
{
return
TagToAllocatedSize
(
tag
)
-
kFlatOverhead
;
}
static_assert
(
TagToAllocatedSize
(
MAX_FLAT_TAG
)
=
=
kMaxLargeFlatSize
"
Bad
tag
logic
"
)
;
struct
CordRepFlat
:
public
CordRep
{
struct
Large
{
}
;
template
<
size_t
max_flat_size
typename
.
.
.
Args
>
static
CordRepFlat
*
NewImpl
(
size_t
len
Args
.
.
.
args
ABSL_ATTRIBUTE_UNUSED
)
{
if
(
len
<
=
kMinFlatLength
)
{
len
=
kMinFlatLength
;
}
else
if
(
len
>
max_flat_size
-
kFlatOverhead
)
{
len
=
max_flat_size
-
kFlatOverhead
;
}
const
size_t
size
=
RoundUpForTag
(
len
+
kFlatOverhead
)
;
void
*
const
raw_rep
=
:
:
operator
new
(
size
)
;
#
if
ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION
(
13
0
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wstringop
-
overflow
"
#
endif
CordRepFlat
*
rep
=
new
(
raw_rep
)
CordRepFlat
(
)
;
rep
-
>
tag
=
AllocatedSizeToTag
(
size
)
;
#
if
ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION
(
13
0
)
#
pragma
GCC
diagnostic
pop
#
endif
return
rep
;
}
static
CordRepFlat
*
New
(
size_t
len
)
{
return
NewImpl
<
kMaxFlatSize
>
(
len
)
;
}
static
CordRepFlat
*
New
(
Large
size_t
len
)
{
return
NewImpl
<
kMaxLargeFlatSize
>
(
len
)
;
}
static
void
Delete
(
CordRep
*
rep
)
{
assert
(
rep
-
>
tag
>
=
FLAT
&
&
rep
-
>
tag
<
=
MAX_FLAT_TAG
)
;
#
if
defined
(
__cpp_sized_deallocation
)
size_t
size
=
TagToAllocatedSize
(
rep
-
>
tag
)
;
rep
-
>
~
CordRep
(
)
;
:
:
operator
delete
(
rep
size
)
;
#
else
rep
-
>
~
CordRep
(
)
;
:
:
operator
delete
(
rep
)
;
#
endif
}
static
CordRepFlat
*
Create
(
absl
:
:
string_view
data
size_t
extra
=
0
)
{
assert
(
data
.
size
(
)
<
=
kMaxFlatLength
)
;
CordRepFlat
*
flat
=
New
(
data
.
size
(
)
+
(
std
:
:
min
)
(
extra
kMaxFlatLength
)
)
;
memcpy
(
flat
-
>
Data
(
)
data
.
data
(
)
data
.
size
(
)
)
;
flat
-
>
length
=
data
.
size
(
)
;
return
flat
;
}
char
*
Data
(
)
{
return
reinterpret_cast
<
char
*
>
(
storage
)
;
}
const
char
*
Data
(
)
const
{
return
reinterpret_cast
<
const
char
*
>
(
storage
)
;
}
size_t
Capacity
(
)
const
{
return
TagToLength
(
tag
)
;
}
size_t
AllocatedSize
(
)
const
{
return
TagToAllocatedSize
(
tag
)
;
}
}
;
inline
CordRepFlat
*
CordRep
:
:
flat
(
)
{
assert
(
tag
>
=
FLAT
&
&
tag
<
=
MAX_FLAT_TAG
)
;
return
reinterpret_cast
<
CordRepFlat
*
>
(
this
)
;
}
inline
const
CordRepFlat
*
CordRep
:
:
flat
(
)
const
{
assert
(
tag
>
=
FLAT
&
&
tag
<
=
MAX_FLAT_TAG
)
;
return
reinterpret_cast
<
const
CordRepFlat
*
>
(
this
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
