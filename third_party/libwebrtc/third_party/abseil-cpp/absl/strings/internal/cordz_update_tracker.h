#
ifndef
ABSL_STRINGS_INTERNAL_CORDZ_UPDATE_TRACKER_H_
#
define
ABSL_STRINGS_INTERNAL_CORDZ_UPDATE_TRACKER_H_
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
"
absl
/
base
/
config
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
cord_internal
{
class
CordzUpdateTracker
{
public
:
enum
MethodIdentifier
{
kUnknown
kAppendCord
kAppendExternalMemory
kAppendString
kAssignCord
kAssignString
kClear
kConstructorCord
kConstructorString
kCordReader
kFlatten
kGetAppendRegion
kMakeCordFromExternal
kMoveAppendCord
kMoveAssignCord
kMovePrependCord
kPrependCord
kPrependString
kRemovePrefix
kRemoveSuffix
kSubCord
kNumMethods
}
;
constexpr
CordzUpdateTracker
(
)
noexcept
:
values_
{
}
{
}
CordzUpdateTracker
(
const
CordzUpdateTracker
&
rhs
)
noexcept
{
*
this
=
rhs
;
}
CordzUpdateTracker
&
operator
=
(
const
CordzUpdateTracker
&
rhs
)
noexcept
{
for
(
int
i
=
0
;
i
<
kNumMethods
;
+
+
i
)
{
values_
[
i
]
.
store
(
rhs
.
values_
[
i
]
.
load
(
std
:
:
memory_order_relaxed
)
std
:
:
memory_order_relaxed
)
;
}
return
*
this
;
}
int64_t
Value
(
MethodIdentifier
method
)
const
{
return
values_
[
method
]
.
load
(
std
:
:
memory_order_relaxed
)
;
}
void
LossyAdd
(
MethodIdentifier
method
int64_t
n
=
1
)
{
auto
&
value
=
values_
[
method
]
;
value
.
store
(
value
.
load
(
std
:
:
memory_order_relaxed
)
+
n
std
:
:
memory_order_relaxed
)
;
}
void
LossyAdd
(
const
CordzUpdateTracker
&
src
)
{
for
(
int
i
=
0
;
i
<
kNumMethods
;
+
+
i
)
{
MethodIdentifier
method
=
static_cast
<
MethodIdentifier
>
(
i
)
;
if
(
int64_t
value
=
src
.
Value
(
method
)
)
{
LossyAdd
(
method
value
)
;
}
}
}
private
:
class
Counter
:
public
std
:
:
atomic
<
int64_t
>
{
public
:
constexpr
Counter
(
)
noexcept
:
std
:
:
atomic
<
int64_t
>
(
0
)
{
}
}
;
Counter
values_
[
kNumMethods
]
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
