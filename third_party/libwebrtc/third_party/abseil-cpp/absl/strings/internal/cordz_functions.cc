#
include
"
absl
/
strings
/
internal
/
cordz_functions
.
h
"
#
include
<
atomic
>
#
include
<
cmath
>
#
include
<
limits
>
#
include
<
random
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
profiling
/
internal
/
exponential_biased
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
cord_internal
{
namespace
{
std
:
:
atomic
<
int
>
g_cordz_mean_interval
(
50000
)
;
}
#
ifdef
ABSL_INTERNAL_CORDZ_ENABLED
static
constexpr
int64_t
kInitCordzNextSample
=
-
1
;
ABSL_CONST_INIT
thread_local
int64_t
cordz_next_sample
=
kInitCordzNextSample
;
constexpr
int64_t
kIntervalIfDisabled
=
1
<
<
16
;
ABSL_ATTRIBUTE_NOINLINE
bool
cordz_should_profile_slow
(
)
{
thread_local
absl
:
:
profiling_internal
:
:
ExponentialBiased
exponential_biased_generator
;
int32_t
mean_interval
=
get_cordz_mean_interval
(
)
;
if
(
mean_interval
<
=
0
)
{
cordz_next_sample
=
kIntervalIfDisabled
;
return
false
;
}
if
(
mean_interval
=
=
1
)
{
cordz_next_sample
=
1
;
return
true
;
}
if
(
cordz_next_sample
<
=
0
)
{
const
bool
initialized
=
cordz_next_sample
!
=
kInitCordzNextSample
;
cordz_next_sample
=
exponential_biased_generator
.
GetStride
(
mean_interval
)
;
return
initialized
|
|
cordz_should_profile
(
)
;
}
-
-
cordz_next_sample
;
return
false
;
}
void
cordz_set_next_sample_for_testing
(
int64_t
next_sample
)
{
cordz_next_sample
=
next_sample
;
}
#
endif
int32_t
get_cordz_mean_interval
(
)
{
return
g_cordz_mean_interval
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
set_cordz_mean_interval
(
int32_t
mean_interval
)
{
g_cordz_mean_interval
.
store
(
mean_interval
std
:
:
memory_order_release
)
;
}
}
ABSL_NAMESPACE_END
}
