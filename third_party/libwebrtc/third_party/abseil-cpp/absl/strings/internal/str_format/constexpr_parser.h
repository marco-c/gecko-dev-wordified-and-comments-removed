#
ifndef
ABSL_STRINGS_INTERNAL_STR_FORMAT_CONSTEXPR_PARSER_H_
#
define
ABSL_STRINGS_INTERNAL_STR_FORMAT_CONSTEXPR_PARSER_H_
#
include
<
cassert
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
"
absl
/
base
/
const_init
.
h
"
#
include
"
absl
/
strings
/
internal
/
str_format
/
extension
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
str_format_internal
{
enum
class
LengthMod
:
std
:
:
uint8_t
{
h
hh
l
ll
L
j
z
t
q
none
}
;
struct
UnboundConversion
{
UnboundConversion
(
)
{
}
explicit
constexpr
UnboundConversion
(
absl
:
:
ConstInitType
)
:
arg_position
{
}
width
{
}
precision
{
}
{
}
class
InputValue
{
public
:
constexpr
void
set_value
(
int
value
)
{
assert
(
value
>
=
0
)
;
value_
=
value
;
}
constexpr
int
value
(
)
const
{
return
value_
;
}
constexpr
void
set_from_arg
(
int
value
)
{
assert
(
value
>
0
)
;
value_
=
-
value
-
1
;
}
constexpr
bool
is_from_arg
(
)
const
{
return
value_
<
-
1
;
}
constexpr
int
get_from_arg
(
)
const
{
assert
(
is_from_arg
(
)
)
;
return
-
value_
-
1
;
}
private
:
int
value_
=
-
1
;
}
;
int
arg_position
;
InputValue
width
;
InputValue
precision
;
Flags
flags
=
Flags
:
:
kBasic
;
LengthMod
length_mod
=
LengthMod
:
:
none
;
FormatConversionChar
conv
=
FormatConversionCharInternal
:
:
kNone
;
}
;
class
ConvTag
{
public
:
constexpr
ConvTag
(
FormatConversionChar
conversion_char
)
:
tag_
(
static_cast
<
uint8_t
>
(
conversion_char
)
)
{
}
constexpr
ConvTag
(
LengthMod
length_mod
)
:
tag_
(
0x80
|
static_cast
<
uint8_t
>
(
length_mod
)
)
{
}
constexpr
ConvTag
(
Flags
flags
)
:
tag_
(
0xc0
|
static_cast
<
uint8_t
>
(
flags
)
)
{
}
constexpr
ConvTag
(
)
:
tag_
(
0xFF
)
{
}
constexpr
bool
is_conv
(
)
const
{
return
(
tag_
&
0x80
)
=
=
0
;
}
constexpr
bool
is_length
(
)
const
{
return
(
tag_
&
0xC0
)
=
=
0x80
;
}
constexpr
bool
is_flags
(
)
const
{
return
(
tag_
&
0xE0
)
=
=
0xC0
;
}
constexpr
FormatConversionChar
as_conv
(
)
const
{
assert
(
is_conv
(
)
)
;
assert
(
!
is_length
(
)
)
;
assert
(
!
is_flags
(
)
)
;
return
static_cast
<
FormatConversionChar
>
(
tag_
)
;
}
constexpr
LengthMod
as_length
(
)
const
{
assert
(
!
is_conv
(
)
)
;
assert
(
is_length
(
)
)
;
assert
(
!
is_flags
(
)
)
;
return
static_cast
<
LengthMod
>
(
tag_
&
0x3F
)
;
}
constexpr
Flags
as_flags
(
)
const
{
assert
(
!
is_conv
(
)
)
;
assert
(
!
is_length
(
)
)
;
assert
(
is_flags
(
)
)
;
return
static_cast
<
Flags
>
(
tag_
&
0x1F
)
;
}
private
:
uint8_t
tag_
;
}
;
struct
ConvTagHolder
{
using
CC
=
FormatConversionCharInternal
;
using
LM
=
LengthMod
;
static
constexpr
auto
kFSign
=
Flags
:
:
kSignCol
;
static
constexpr
auto
kFAlt
=
Flags
:
:
kAlt
;
static
constexpr
auto
kFPos
=
Flags
:
:
kShowPos
;
static
constexpr
auto
kFLeft
=
Flags
:
:
kLeft
;
static
constexpr
auto
kFZero
=
Flags
:
:
kZero
;
static
constexpr
ConvTag
value
[
256
]
=
{
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
kFSign
{
}
{
}
kFAlt
{
}
{
}
{
}
{
}
{
}
{
}
{
}
kFPos
{
}
kFLeft
{
}
{
}
kFZero
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
CC
:
:
A
{
}
{
}
{
}
CC
:
:
E
CC
:
:
F
CC
:
:
G
{
}
{
}
{
}
{
}
LM
:
:
L
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
CC
:
:
X
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
CC
:
:
a
{
}
CC
:
:
c
CC
:
:
d
CC
:
:
e
CC
:
:
f
CC
:
:
g
LM
:
:
h
CC
:
:
i
LM
:
:
j
{
}
LM
:
:
l
{
}
CC
:
:
n
CC
:
:
o
CC
:
:
p
LM
:
:
q
{
}
CC
:
:
s
LM
:
:
t
CC
:
:
u
CC
:
:
v
{
}
CC
:
:
x
{
}
LM
:
:
z
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
}
;
}
;
constexpr
ConvTag
GetTagForChar
(
char
c
)
{
return
ConvTagHolder
:
:
value
[
static_cast
<
unsigned
char
>
(
c
)
]
;
}
constexpr
bool
CheckFastPathSetting
(
const
UnboundConversion
&
conv
)
{
bool
width_precision_needed
=
conv
.
width
.
value
(
)
>
=
0
|
|
conv
.
precision
.
value
(
)
>
=
0
;
if
(
width_precision_needed
&
&
conv
.
flags
=
=
Flags
:
:
kBasic
)
{
#
if
defined
(
__clang__
)
fprintf
(
stderr
"
basic
=
%
d
left
=
%
d
show_pos
=
%
d
sign_col
=
%
d
alt
=
%
d
zero
=
%
d
"
"
width
=
%
d
precision
=
%
d
\
n
"
conv
.
flags
=
=
Flags
:
:
kBasic
?
1
:
0
FlagsContains
(
conv
.
flags
Flags
:
:
kLeft
)
?
1
:
0
FlagsContains
(
conv
.
flags
Flags
:
:
kShowPos
)
?
1
:
0
FlagsContains
(
conv
.
flags
Flags
:
:
kSignCol
)
?
1
:
0
FlagsContains
(
conv
.
flags
Flags
:
:
kAlt
)
?
1
:
0
FlagsContains
(
conv
.
flags
Flags
:
:
kZero
)
?
1
:
0
conv
.
width
.
value
(
)
conv
.
precision
.
value
(
)
)
;
#
endif
return
false
;
}
return
true
;
}
constexpr
int
ParseDigits
(
char
&
c
const
char
*
&
pos
const
char
*
const
end
)
{
int
digits
=
c
-
'
0
'
;
int
num_digits
=
std
:
:
numeric_limits
<
int
>
:
:
digits10
;
for
(
;
;
)
{
if
(
ABSL_PREDICT_FALSE
(
pos
=
=
end
)
)
break
;
c
=
*
pos
+
+
;
if
(
'
0
'
>
c
|
|
c
>
'
9
'
)
break
;
-
-
num_digits
;
if
(
ABSL_PREDICT_FALSE
(
!
num_digits
)
)
break
;
digits
=
10
*
digits
+
c
-
'
0
'
;
}
return
digits
;
}
template
<
bool
is_positional
>
constexpr
const
char
*
ConsumeConversion
(
const
char
*
pos
const
char
*
const
end
UnboundConversion
*
conv
int
*
next_arg
)
{
const
char
*
const
original_pos
=
pos
;
char
c
=
0
;
#
define
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
\
do
{
\
if
(
ABSL_PREDICT_FALSE
(
pos
=
=
end
)
)
return
nullptr
;
\
c
=
*
pos
+
+
;
\
}
while
(
0
)
if
(
is_positional
)
{
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
if
(
ABSL_PREDICT_FALSE
(
c
<
'
1
'
|
|
c
>
'
9
'
)
)
return
nullptr
;
conv
-
>
arg_position
=
ParseDigits
(
c
pos
end
)
;
assert
(
conv
-
>
arg_position
>
0
)
;
if
(
ABSL_PREDICT_FALSE
(
c
!
=
'
'
)
)
return
nullptr
;
}
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
assert
(
conv
-
>
flags
=
=
Flags
:
:
kBasic
)
;
if
(
c
<
'
A
'
)
{
while
(
c
<
=
'
0
'
)
{
auto
tag
=
GetTagForChar
(
c
)
;
if
(
tag
.
is_flags
(
)
)
{
conv
-
>
flags
=
conv
-
>
flags
|
tag
.
as_flags
(
)
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
}
else
{
break
;
}
}
if
(
c
<
=
'
9
'
)
{
if
(
c
>
=
'
0
'
)
{
int
maybe_width
=
ParseDigits
(
c
pos
end
)
;
if
(
!
is_positional
&
&
c
=
=
'
'
)
{
if
(
ABSL_PREDICT_FALSE
(
*
next_arg
!
=
0
)
)
return
nullptr
;
*
next_arg
=
-
1
;
return
ConsumeConversion
<
true
>
(
original_pos
end
conv
next_arg
)
;
}
conv
-
>
flags
=
conv
-
>
flags
|
Flags
:
:
kNonBasic
;
conv
-
>
width
.
set_value
(
maybe_width
)
;
}
else
if
(
c
=
=
'
*
'
)
{
conv
-
>
flags
=
conv
-
>
flags
|
Flags
:
:
kNonBasic
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
if
(
is_positional
)
{
if
(
ABSL_PREDICT_FALSE
(
c
<
'
1
'
|
|
c
>
'
9
'
)
)
return
nullptr
;
conv
-
>
width
.
set_from_arg
(
ParseDigits
(
c
pos
end
)
)
;
if
(
ABSL_PREDICT_FALSE
(
c
!
=
'
'
)
)
return
nullptr
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
}
else
{
conv
-
>
width
.
set_from_arg
(
+
+
*
next_arg
)
;
}
}
}
if
(
c
=
=
'
.
'
)
{
conv
-
>
flags
=
conv
-
>
flags
|
Flags
:
:
kNonBasic
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
if
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
{
conv
-
>
precision
.
set_value
(
ParseDigits
(
c
pos
end
)
)
;
}
else
if
(
c
=
=
'
*
'
)
{
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
if
(
is_positional
)
{
if
(
ABSL_PREDICT_FALSE
(
c
<
'
1
'
|
|
c
>
'
9
'
)
)
return
nullptr
;
conv
-
>
precision
.
set_from_arg
(
ParseDigits
(
c
pos
end
)
)
;
if
(
c
!
=
'
'
)
return
nullptr
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
}
else
{
conv
-
>
precision
.
set_from_arg
(
+
+
*
next_arg
)
;
}
}
else
{
conv
-
>
precision
.
set_value
(
0
)
;
}
}
}
auto
tag
=
GetTagForChar
(
c
)
;
if
(
ABSL_PREDICT_FALSE
(
c
=
=
'
v
'
&
&
conv
-
>
flags
!
=
Flags
:
:
kBasic
)
)
{
return
nullptr
;
}
if
(
ABSL_PREDICT_FALSE
(
!
tag
.
is_conv
(
)
)
)
{
if
(
ABSL_PREDICT_FALSE
(
!
tag
.
is_length
(
)
)
)
return
nullptr
;
using
str_format_internal
:
:
LengthMod
;
LengthMod
length_mod
=
tag
.
as_length
(
)
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
if
(
c
=
=
'
h
'
&
&
length_mod
=
=
LengthMod
:
:
h
)
{
conv
-
>
length_mod
=
LengthMod
:
:
hh
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
}
else
if
(
c
=
=
'
l
'
&
&
length_mod
=
=
LengthMod
:
:
l
)
{
conv
-
>
length_mod
=
LengthMod
:
:
ll
;
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
(
)
;
}
else
{
conv
-
>
length_mod
=
length_mod
;
}
tag
=
GetTagForChar
(
c
)
;
if
(
ABSL_PREDICT_FALSE
(
c
=
=
'
v
'
)
)
return
nullptr
;
if
(
ABSL_PREDICT_FALSE
(
!
tag
.
is_conv
(
)
)
)
return
nullptr
;
}
#
undef
ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR
assert
(
CheckFastPathSetting
(
*
conv
)
)
;
(
void
)
(
&
CheckFastPathSetting
)
;
conv
-
>
conv
=
tag
.
as_conv
(
)
;
if
(
!
is_positional
)
conv
-
>
arg_position
=
+
+
*
next_arg
;
return
pos
;
}
constexpr
const
char
*
ConsumeUnboundConversion
(
const
char
*
p
const
char
*
end
UnboundConversion
*
conv
int
*
next_arg
)
{
if
(
*
next_arg
<
0
)
return
ConsumeConversion
<
true
>
(
p
end
conv
next_arg
)
;
return
ConsumeConversion
<
false
>
(
p
end
conv
next_arg
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
