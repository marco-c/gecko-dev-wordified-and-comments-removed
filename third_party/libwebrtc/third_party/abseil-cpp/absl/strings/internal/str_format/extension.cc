#
include
"
absl
/
strings
/
internal
/
str_format
/
extension
.
h
"
#
include
<
errno
.
h
>
#
include
<
algorithm
>
#
include
<
string
>
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
str_format_internal
{
std
:
:
string
Flags
:
:
ToString
(
)
const
{
std
:
:
string
s
;
s
.
append
(
left
?
"
-
"
:
"
"
)
;
s
.
append
(
show_pos
?
"
+
"
:
"
"
)
;
s
.
append
(
sign_col
?
"
"
:
"
"
)
;
s
.
append
(
alt
?
"
#
"
:
"
"
)
;
s
.
append
(
zero
?
"
0
"
:
"
"
)
;
return
s
;
}
#
define
ABSL_INTERNAL_X_VAL
(
id
)
\
constexpr
absl
:
:
FormatConversionChar
FormatConversionCharInternal
:
:
id
;
ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_
(
ABSL_INTERNAL_X_VAL
)
#
undef
ABSL_INTERNAL_X_VAL
constexpr
absl
:
:
FormatConversionChar
FormatConversionCharInternal
:
:
kNone
;
#
define
ABSL_INTERNAL_CHAR_SET_CASE
(
c
)
\
constexpr
FormatConversionCharSet
FormatConversionCharSetInternal
:
:
c
;
ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_
(
ABSL_INTERNAL_CHAR_SET_CASE
)
#
undef
ABSL_INTERNAL_CHAR_SET_CASE
constexpr
FormatConversionCharSet
FormatConversionCharSetInternal
:
:
kStar
;
constexpr
FormatConversionCharSet
FormatConversionCharSetInternal
:
:
kIntegral
;
constexpr
FormatConversionCharSet
FormatConversionCharSetInternal
:
:
kFloating
;
constexpr
FormatConversionCharSet
FormatConversionCharSetInternal
:
:
kNumeric
;
constexpr
FormatConversionCharSet
FormatConversionCharSetInternal
:
:
kPointer
;
bool
FormatSinkImpl
:
:
PutPaddedString
(
string_view
value
int
width
int
precision
bool
left
)
{
size_t
space_remaining
=
0
;
if
(
width
>
=
0
)
space_remaining
=
width
;
size_t
n
=
value
.
size
(
)
;
if
(
precision
>
=
0
)
n
=
std
:
:
min
(
n
static_cast
<
size_t
>
(
precision
)
)
;
string_view
shown
(
value
.
data
(
)
n
)
;
space_remaining
=
Excess
(
shown
.
size
(
)
space_remaining
)
;
if
(
!
left
)
Append
(
space_remaining
'
'
)
;
Append
(
shown
)
;
if
(
left
)
Append
(
space_remaining
'
'
)
;
return
true
;
}
}
ABSL_NAMESPACE_END
}
