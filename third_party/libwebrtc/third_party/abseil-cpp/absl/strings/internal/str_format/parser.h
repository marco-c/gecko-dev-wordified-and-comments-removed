#
ifndef
ABSL_STRINGS_INTERNAL_STR_FORMAT_PARSER_H_
#
define
ABSL_STRINGS_INTERNAL_STR_FORMAT_PARSER_H_
#
include
<
limits
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
cassert
>
#
include
<
cstdint
>
#
include
<
initializer_list
>
#
include
<
iosfwd
>
#
include
<
iterator
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
internal
/
str_format
/
checker
.
h
"
#
include
"
absl
/
strings
/
internal
/
str_format
/
extension
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
str_format_internal
{
enum
class
LengthMod
:
std
:
:
uint8_t
{
h
hh
l
ll
L
j
z
t
q
none
}
;
std
:
:
string
LengthModToString
(
LengthMod
v
)
;
struct
UnboundConversion
{
UnboundConversion
(
)
:
flags
(
)
{
flags
.
basic
=
true
;
}
class
InputValue
{
public
:
void
set_value
(
int
value
)
{
assert
(
value
>
=
0
)
;
value_
=
value
;
}
int
value
(
)
const
{
return
value_
;
}
void
set_from_arg
(
int
value
)
{
assert
(
value
>
0
)
;
value_
=
-
value
-
1
;
}
bool
is_from_arg
(
)
const
{
return
value_
<
-
1
;
}
int
get_from_arg
(
)
const
{
assert
(
is_from_arg
(
)
)
;
return
-
value_
-
1
;
}
private
:
int
value_
=
-
1
;
}
;
int
arg_position
;
InputValue
width
;
InputValue
precision
;
Flags
flags
;
LengthMod
length_mod
=
LengthMod
:
:
none
;
FormatConversionChar
conv
=
FormatConversionCharInternal
:
:
kNone
;
}
;
const
char
*
ConsumeUnboundConversion
(
const
char
*
p
const
char
*
end
UnboundConversion
*
conv
int
*
next_arg
)
;
class
ConvTag
{
public
:
constexpr
ConvTag
(
FormatConversionChar
conversion_char
)
:
tag_
(
static_cast
<
int8_t
>
(
conversion_char
)
)
{
}
constexpr
ConvTag
(
LengthMod
length_mod
)
:
tag_
(
~
static_cast
<
std
:
:
int8_t
>
(
length_mod
)
)
{
}
constexpr
ConvTag
(
)
:
tag_
(
-
128
)
{
}
bool
is_conv
(
)
const
{
return
tag_
>
=
0
;
}
bool
is_length
(
)
const
{
return
tag_
<
0
&
&
tag_
!
=
-
128
;
}
FormatConversionChar
as_conv
(
)
const
{
assert
(
is_conv
(
)
)
;
return
static_cast
<
FormatConversionChar
>
(
tag_
)
;
}
LengthMod
as_length
(
)
const
{
assert
(
is_length
(
)
)
;
return
static_cast
<
LengthMod
>
(
~
tag_
)
;
}
private
:
std
:
:
int8_t
tag_
;
}
;
extern
const
ConvTag
kTags
[
256
]
;
inline
ConvTag
GetTagForChar
(
char
c
)
{
return
kTags
[
static_cast
<
unsigned
char
>
(
c
)
]
;
}
template
<
typename
Consumer
>
bool
ParseFormatString
(
string_view
src
Consumer
consumer
)
{
int
next_arg
=
0
;
const
char
*
p
=
src
.
data
(
)
;
const
char
*
const
end
=
p
+
src
.
size
(
)
;
while
(
p
!
=
end
)
{
const
char
*
percent
=
static_cast
<
const
char
*
>
(
memchr
(
p
'
%
'
end
-
p
)
)
;
if
(
!
percent
)
{
return
consumer
.
Append
(
string_view
(
p
end
-
p
)
)
;
}
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
Append
(
string_view
(
p
percent
-
p
)
)
)
)
{
return
false
;
}
if
(
ABSL_PREDICT_FALSE
(
percent
+
1
>
=
end
)
)
return
false
;
auto
tag
=
GetTagForChar
(
percent
[
1
]
)
;
if
(
tag
.
is_conv
(
)
)
{
if
(
ABSL_PREDICT_FALSE
(
next_arg
<
0
)
)
{
return
false
;
}
p
=
percent
+
2
;
UnboundConversion
conv
;
conv
.
conv
=
tag
.
as_conv
(
)
;
conv
.
arg_position
=
+
+
next_arg
;
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
ConvertOne
(
conv
string_view
(
percent
+
1
1
)
)
)
)
{
return
false
;
}
}
else
if
(
percent
[
1
]
!
=
'
%
'
)
{
UnboundConversion
conv
;
p
=
ConsumeUnboundConversion
(
percent
+
1
end
&
conv
&
next_arg
)
;
if
(
ABSL_PREDICT_FALSE
(
p
=
=
nullptr
)
)
return
false
;
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
ConvertOne
(
conv
string_view
(
percent
+
1
p
-
(
percent
+
1
)
)
)
)
)
{
return
false
;
}
}
else
{
if
(
ABSL_PREDICT_FALSE
(
!
consumer
.
Append
(
"
%
"
)
)
)
return
false
;
p
=
percent
+
2
;
continue
;
}
}
return
true
;
}
constexpr
bool
EnsureConstexpr
(
string_view
s
)
{
return
s
.
empty
(
)
|
|
s
[
0
]
=
=
s
[
0
]
;
}
class
ParsedFormatBase
{
public
:
explicit
ParsedFormatBase
(
string_view
format
bool
allow_ignored
std
:
:
initializer_list
<
FormatConversionCharSet
>
convs
)
;
ParsedFormatBase
(
const
ParsedFormatBase
&
other
)
{
*
this
=
other
;
}
ParsedFormatBase
(
ParsedFormatBase
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
ParsedFormatBase
&
operator
=
(
const
ParsedFormatBase
&
other
)
{
if
(
this
=
=
&
other
)
return
*
this
;
has_error_
=
other
.
has_error_
;
items_
=
other
.
items_
;
size_t
text_size
=
items_
.
empty
(
)
?
0
:
items_
.
back
(
)
.
text_end
;
data_
.
reset
(
new
char
[
text_size
]
)
;
memcpy
(
data_
.
get
(
)
other
.
data_
.
get
(
)
text_size
)
;
return
*
this
;
}
ParsedFormatBase
&
operator
=
(
ParsedFormatBase
&
&
other
)
{
if
(
this
=
=
&
other
)
return
*
this
;
has_error_
=
other
.
has_error_
;
data_
=
std
:
:
move
(
other
.
data_
)
;
items_
=
std
:
:
move
(
other
.
items_
)
;
other
.
items_
.
clear
(
)
;
return
*
this
;
}
template
<
typename
Consumer
>
bool
ProcessFormat
(
Consumer
consumer
)
const
{
const
char
*
const
base
=
data_
.
get
(
)
;
string_view
text
(
base
0
)
;
for
(
const
auto
&
item
:
items_
)
{
const
char
*
const
end
=
text
.
data
(
)
+
text
.
size
(
)
;
text
=
string_view
(
end
(
base
+
item
.
text_end
)
-
end
)
;
if
(
item
.
is_conversion
)
{
if
(
!
consumer
.
ConvertOne
(
item
.
conv
text
)
)
return
false
;
}
else
{
if
(
!
consumer
.
Append
(
text
)
)
return
false
;
}
}
return
!
has_error_
;
}
bool
has_error
(
)
const
{
return
has_error_
;
}
private
:
bool
MatchesConversions
(
bool
allow_ignored
std
:
:
initializer_list
<
FormatConversionCharSet
>
convs
)
const
;
struct
ParsedFormatConsumer
;
struct
ConversionItem
{
bool
is_conversion
;
size_t
text_end
;
UnboundConversion
conv
;
}
;
bool
has_error_
;
std
:
:
unique_ptr
<
char
[
]
>
data_
;
std
:
:
vector
<
ConversionItem
>
items_
;
}
;
template
<
FormatConversionCharSet
.
.
.
C
>
class
ExtendedParsedFormat
:
public
str_format_internal
:
:
ParsedFormatBase
{
public
:
explicit
ExtendedParsedFormat
(
string_view
format
)
#
ifdef
ABSL_INTERNAL_ENABLE_FORMAT_CHECKER
__attribute__
(
(
enable_if
(
str_format_internal
:
:
EnsureConstexpr
(
format
)
"
Format
string
is
not
constexpr
.
"
)
enable_if
(
str_format_internal
:
:
ValidFormatImpl
<
C
.
.
.
>
(
format
)
"
Format
specified
does
not
match
the
template
arguments
.
"
)
)
)
#
endif
:
ExtendedParsedFormat
(
format
false
)
{
}
static
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
New
(
string_view
format
)
{
return
New
(
format
false
)
;
}
static
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
NewAllowIgnored
(
string_view
format
)
{
return
New
(
format
true
)
;
}
private
:
static
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
New
(
string_view
format
bool
allow_ignored
)
{
std
:
:
unique_ptr
<
ExtendedParsedFormat
>
conv
(
new
ExtendedParsedFormat
(
format
allow_ignored
)
)
;
if
(
conv
-
>
has_error
(
)
)
return
nullptr
;
return
conv
;
}
ExtendedParsedFormat
(
string_view
s
bool
allow_ignored
)
:
ParsedFormatBase
(
s
allow_ignored
{
C
.
.
.
}
)
{
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
