#
ifndef
ABSL_STRINGS_NUMBERS_H_
#
define
ABSL_STRINGS_NUMBERS_H_
#
ifdef
__SSE4_2__
#
include
<
x86intrin
.
h
>
#
endif
#
include
<
cstddef
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
ctime
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
ifdef
__SSE4_2__
#
include
"
absl
/
base
/
internal
/
endian
.
h
"
#
endif
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
numeric
/
bits
.
h
"
#
include
"
absl
/
numeric
/
int128
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
int_type
>
ABSL_MUST_USE_RESULT
bool
SimpleAtoi
(
absl
:
:
string_view
str
int_type
*
out
)
;
ABSL_MUST_USE_RESULT
bool
SimpleAtof
(
absl
:
:
string_view
str
float
*
out
)
;
ABSL_MUST_USE_RESULT
bool
SimpleAtod
(
absl
:
:
string_view
str
double
*
out
)
;
ABSL_MUST_USE_RESULT
bool
SimpleAtob
(
absl
:
:
string_view
str
bool
*
out
)
;
ABSL_NAMESPACE_END
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
numbers_internal
{
ABSL_DLL
extern
const
char
kHexChar
[
17
]
;
ABSL_DLL
extern
const
char
kHexTable
[
513
]
;
ABSL_DLL
extern
const
char
two_ASCII_digits
[
100
]
[
2
]
;
inline
void
PutTwoDigits
(
size_t
i
char
*
buf
)
{
assert
(
i
<
100
)
;
memcpy
(
buf
two_ASCII_digits
[
i
]
2
)
;
}
bool
safe_strto32_base
(
absl
:
:
string_view
text
int32_t
*
value
int
base
)
;
bool
safe_strto64_base
(
absl
:
:
string_view
text
int64_t
*
value
int
base
)
;
bool
safe_strto128_base
(
absl
:
:
string_view
text
absl
:
:
int128
*
value
int
base
)
;
bool
safe_strtou32_base
(
absl
:
:
string_view
text
uint32_t
*
value
int
base
)
;
bool
safe_strtou64_base
(
absl
:
:
string_view
text
uint64_t
*
value
int
base
)
;
bool
safe_strtou128_base
(
absl
:
:
string_view
text
absl
:
:
uint128
*
value
int
base
)
;
static
const
int
kFastToBufferSize
=
32
;
static
const
int
kSixDigitsToBufferSize
=
16
;
size_t
SixDigitsToBuffer
(
double
d
char
*
buffer
)
;
char
*
FastIntToBuffer
(
int32_t
char
*
)
;
char
*
FastIntToBuffer
(
uint32_t
char
*
)
;
char
*
FastIntToBuffer
(
int64_t
char
*
)
;
char
*
FastIntToBuffer
(
uint64_t
char
*
)
;
template
<
typename
int_type
>
char
*
FastIntToBuffer
(
int_type
i
char
*
buffer
)
{
static_assert
(
sizeof
(
i
)
<
=
64
/
8
"
FastIntToBuffer
works
only
with
64
-
bit
-
or
-
less
integers
.
"
)
;
if
(
static_cast
<
int_type
>
(
1
)
-
2
<
0
)
{
if
(
sizeof
(
i
)
>
32
/
8
)
{
return
FastIntToBuffer
(
static_cast
<
int64_t
>
(
i
)
buffer
)
;
}
else
{
return
FastIntToBuffer
(
static_cast
<
int32_t
>
(
i
)
buffer
)
;
}
}
else
{
if
(
sizeof
(
i
)
>
32
/
8
)
{
return
FastIntToBuffer
(
static_cast
<
uint64_t
>
(
i
)
buffer
)
;
}
else
{
return
FastIntToBuffer
(
static_cast
<
uint32_t
>
(
i
)
buffer
)
;
}
}
}
template
<
typename
int_type
>
ABSL_MUST_USE_RESULT
bool
safe_strtoi_base
(
absl
:
:
string_view
s
int_type
*
out
int
base
)
{
static_assert
(
sizeof
(
*
out
)
=
=
4
|
|
sizeof
(
*
out
)
=
=
8
"
SimpleAtoi
works
only
with
32
-
bit
or
64
-
bit
integers
.
"
)
;
static_assert
(
!
std
:
:
is_floating_point
<
int_type
>
:
:
value
"
Use
SimpleAtof
or
SimpleAtod
instead
.
"
)
;
bool
parsed
;
if
(
static_cast
<
int_type
>
(
1
)
-
2
<
0
)
{
if
(
sizeof
(
*
out
)
=
=
64
/
8
)
{
int64_t
val
;
parsed
=
numbers_internal
:
:
safe_strto64_base
(
s
&
val
base
)
;
*
out
=
static_cast
<
int_type
>
(
val
)
;
}
else
{
int32_t
val
;
parsed
=
numbers_internal
:
:
safe_strto32_base
(
s
&
val
base
)
;
*
out
=
static_cast
<
int_type
>
(
val
)
;
}
}
else
{
if
(
sizeof
(
*
out
)
=
=
64
/
8
)
{
uint64_t
val
;
parsed
=
numbers_internal
:
:
safe_strtou64_base
(
s
&
val
base
)
;
*
out
=
static_cast
<
int_type
>
(
val
)
;
}
else
{
uint32_t
val
;
parsed
=
numbers_internal
:
:
safe_strtou32_base
(
s
&
val
base
)
;
*
out
=
static_cast
<
int_type
>
(
val
)
;
}
}
return
parsed
;
}
inline
size_t
FastHexToBufferZeroPad16
(
uint64_t
val
char
*
out
)
{
#
ifdef
__SSE4_2__
uint64_t
be
=
absl
:
:
big_endian
:
:
FromHost64
(
val
)
;
const
auto
kNibbleMask
=
_mm_set1_epi8
(
0xf
)
;
const
auto
kHexDigits
=
_mm_setr_epi8
(
'
0
'
'
1
'
'
2
'
'
3
'
'
4
'
'
5
'
'
6
'
'
7
'
'
8
'
'
9
'
'
a
'
'
b
'
'
c
'
'
d
'
'
e
'
'
f
'
)
;
auto
v
=
_mm_loadl_epi64
(
reinterpret_cast
<
__m128i
*
>
(
&
be
)
)
;
auto
v4
=
_mm_srli_epi64
(
v
4
)
;
auto
il
=
_mm_unpacklo_epi8
(
v4
v
)
;
auto
m
=
_mm_and_si128
(
il
kNibbleMask
)
;
auto
hexchars
=
_mm_shuffle_epi8
(
kHexDigits
m
)
;
_mm_storeu_si128
(
reinterpret_cast
<
__m128i
*
>
(
out
)
hexchars
)
;
#
else
for
(
int
i
=
0
;
i
<
8
;
+
+
i
)
{
auto
byte
=
(
val
>
>
(
56
-
8
*
i
)
)
&
0xFF
;
auto
*
hex
=
&
absl
:
:
numbers_internal
:
:
kHexTable
[
byte
*
2
]
;
std
:
:
memcpy
(
out
+
2
*
i
hex
2
)
;
}
#
endif
return
16
-
countl_zero
(
val
|
0x1
)
/
4
;
}
}
template
<
typename
int_type
>
ABSL_MUST_USE_RESULT
bool
SimpleAtoi
(
absl
:
:
string_view
str
int_type
*
out
)
{
return
numbers_internal
:
:
safe_strtoi_base
(
str
out
10
)
;
}
ABSL_MUST_USE_RESULT
inline
bool
SimpleAtoi
(
absl
:
:
string_view
str
absl
:
:
int128
*
out
)
{
return
numbers_internal
:
:
safe_strto128_base
(
str
out
10
)
;
}
ABSL_MUST_USE_RESULT
inline
bool
SimpleAtoi
(
absl
:
:
string_view
str
absl
:
:
uint128
*
out
)
{
return
numbers_internal
:
:
safe_strtou128_base
(
str
out
10
)
;
}
ABSL_NAMESPACE_END
}
#
endif
