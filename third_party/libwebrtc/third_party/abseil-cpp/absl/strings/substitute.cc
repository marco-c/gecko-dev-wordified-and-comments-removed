#
include
"
absl
/
strings
/
substitute
.
h
"
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
strings
/
ascii
.
h
"
#
include
"
absl
/
strings
/
escaping
.
h
"
#
include
"
absl
/
strings
/
internal
/
resize_uninitialized
.
h
"
#
include
"
absl
/
strings
/
numbers
.
h
"
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
substitute_internal
{
void
SubstituteAndAppendArray
(
std
:
:
string
*
output
absl
:
:
string_view
format
const
absl
:
:
string_view
*
args_array
size_t
num_args
)
{
size_t
size
=
0
;
for
(
size_t
i
=
0
;
i
<
format
.
size
(
)
;
i
+
+
)
{
if
(
format
[
i
]
=
=
'
'
)
{
if
(
i
+
1
>
=
format
.
size
(
)
)
{
#
ifndef
NDEBUG
ABSL_RAW_LOG
(
FATAL
"
Invalid
absl
:
:
Substitute
(
)
format
string
:
\
"
%
s
\
"
.
"
absl
:
:
CEscape
(
format
)
.
c_str
(
)
)
;
#
endif
return
;
}
else
if
(
absl
:
:
ascii_isdigit
(
static_cast
<
unsigned
char
>
(
format
[
i
+
1
]
)
)
)
{
int
index
=
format
[
i
+
1
]
-
'
0
'
;
if
(
static_cast
<
size_t
>
(
index
)
>
=
num_args
)
{
#
ifndef
NDEBUG
ABSL_RAW_LOG
(
FATAL
"
Invalid
absl
:
:
Substitute
(
)
format
string
:
asked
for
\
"
"
"
%
d
\
"
but
only
%
d
args
were
given
.
Full
format
string
was
:
"
"
\
"
%
s
\
"
.
"
index
static_cast
<
int
>
(
num_args
)
absl
:
:
CEscape
(
format
)
.
c_str
(
)
)
;
#
endif
return
;
}
size
+
=
args_array
[
index
]
.
size
(
)
;
+
+
i
;
}
else
if
(
format
[
i
+
1
]
=
=
'
'
)
{
+
+
size
;
+
+
i
;
}
else
{
#
ifndef
NDEBUG
ABSL_RAW_LOG
(
FATAL
"
Invalid
absl
:
:
Substitute
(
)
format
string
:
\
"
%
s
\
"
.
"
absl
:
:
CEscape
(
format
)
.
c_str
(
)
)
;
#
endif
return
;
}
}
else
{
+
+
size
;
}
}
if
(
size
=
=
0
)
return
;
size_t
original_size
=
output
-
>
size
(
)
;
strings_internal
:
:
STLStringResizeUninitializedAmortized
(
output
original_size
+
size
)
;
char
*
target
=
&
(
*
output
)
[
original_size
]
;
for
(
size_t
i
=
0
;
i
<
format
.
size
(
)
;
i
+
+
)
{
if
(
format
[
i
]
=
=
'
'
)
{
if
(
absl
:
:
ascii_isdigit
(
static_cast
<
unsigned
char
>
(
format
[
i
+
1
]
)
)
)
{
const
absl
:
:
string_view
src
=
args_array
[
format
[
i
+
1
]
-
'
0
'
]
;
target
=
std
:
:
copy
(
src
.
begin
(
)
src
.
end
(
)
target
)
;
+
+
i
;
}
else
if
(
format
[
i
+
1
]
=
=
'
'
)
{
*
target
+
+
=
'
'
;
+
+
i
;
}
}
else
{
*
target
+
+
=
format
[
i
]
;
}
}
assert
(
target
=
=
output
-
>
data
(
)
+
output
-
>
size
(
)
)
;
}
Arg
:
:
Arg
(
const
void
*
value
)
{
static_assert
(
sizeof
(
scratch_
)
>
=
sizeof
(
value
)
*
2
+
2
"
fix
sizeof
(
scratch_
)
"
)
;
if
(
value
=
=
nullptr
)
{
piece_
=
"
NULL
"
;
}
else
{
char
*
ptr
=
scratch_
+
sizeof
(
scratch_
)
;
uintptr_t
num
=
reinterpret_cast
<
uintptr_t
>
(
value
)
;
do
{
*
-
-
ptr
=
absl
:
:
numbers_internal
:
:
kHexChar
[
num
&
0xf
]
;
num
>
>
=
4
;
}
while
(
num
!
=
0
)
;
*
-
-
ptr
=
'
x
'
;
*
-
-
ptr
=
'
0
'
;
piece_
=
absl
:
:
string_view
(
ptr
static_cast
<
size_t
>
(
scratch_
+
sizeof
(
scratch_
)
-
ptr
)
)
;
}
}
Arg
:
:
Arg
(
Hex
hex
)
{
char
*
const
end
=
&
scratch_
[
numbers_internal
:
:
kFastToBufferSize
]
;
char
*
writer
=
end
;
uint64_t
value
=
hex
.
value
;
do
{
*
-
-
writer
=
absl
:
:
numbers_internal
:
:
kHexChar
[
value
&
0xF
]
;
value
>
>
=
4
;
}
while
(
value
!
=
0
)
;
char
*
beg
;
if
(
end
-
writer
<
hex
.
width
)
{
beg
=
end
-
hex
.
width
;
std
:
:
fill_n
(
beg
writer
-
beg
hex
.
fill
)
;
}
else
{
beg
=
writer
;
}
piece_
=
absl
:
:
string_view
(
beg
static_cast
<
size_t
>
(
end
-
beg
)
)
;
}
Arg
:
:
Arg
(
Dec
dec
)
{
assert
(
dec
.
width
<
=
numbers_internal
:
:
kFastToBufferSize
)
;
char
*
const
end
=
&
scratch_
[
numbers_internal
:
:
kFastToBufferSize
]
;
char
*
const
minfill
=
end
-
dec
.
width
;
char
*
writer
=
end
;
uint64_t
value
=
dec
.
value
;
bool
neg
=
dec
.
neg
;
while
(
value
>
9
)
{
*
-
-
writer
=
'
0
'
+
(
value
%
10
)
;
value
/
=
10
;
}
*
-
-
writer
=
'
0
'
+
static_cast
<
char
>
(
value
)
;
if
(
neg
)
*
-
-
writer
=
'
-
'
;
ptrdiff_t
fillers
=
writer
-
minfill
;
if
(
fillers
>
0
)
{
bool
add_sign_again
=
false
;
if
(
neg
&
&
dec
.
fill
=
=
'
0
'
)
{
+
+
writer
;
add_sign_again
=
true
;
}
writer
-
=
fillers
;
std
:
:
fill_n
(
writer
fillers
dec
.
fill
)
;
if
(
add_sign_again
)
*
-
-
writer
=
'
-
'
;
}
piece_
=
absl
:
:
string_view
(
writer
static_cast
<
size_t
>
(
end
-
writer
)
)
;
}
}
ABSL_NAMESPACE_END
}
