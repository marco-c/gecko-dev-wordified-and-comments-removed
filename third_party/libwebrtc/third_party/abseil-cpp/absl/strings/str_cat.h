#
ifndef
ABSL_STRINGS_STR_CAT_H_
#
define
ABSL_STRINGS_STR_CAT_H_
#
include
<
array
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
strings
/
numbers
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
strings_internal
{
template
<
size_t
max_size
>
struct
AlphaNumBuffer
{
std
:
:
array
<
char
max_size
>
data
;
size_t
size
;
}
;
}
enum
PadSpec
:
uint8_t
{
kNoPad
=
1
kZeroPad2
kZeroPad3
kZeroPad4
kZeroPad5
kZeroPad6
kZeroPad7
kZeroPad8
kZeroPad9
kZeroPad10
kZeroPad11
kZeroPad12
kZeroPad13
kZeroPad14
kZeroPad15
kZeroPad16
kZeroPad17
kZeroPad18
kZeroPad19
kZeroPad20
kSpacePad2
=
kZeroPad2
+
64
kSpacePad3
kSpacePad4
kSpacePad5
kSpacePad6
kSpacePad7
kSpacePad8
kSpacePad9
kSpacePad10
kSpacePad11
kSpacePad12
kSpacePad13
kSpacePad14
kSpacePad15
kSpacePad16
kSpacePad17
kSpacePad18
kSpacePad19
kSpacePad20
}
;
struct
Hex
{
uint64_t
value
;
uint8_t
width
;
char
fill
;
template
<
typename
Int
>
explicit
Hex
(
Int
v
PadSpec
spec
=
absl
:
:
kNoPad
typename
std
:
:
enable_if
<
sizeof
(
Int
)
=
=
1
&
&
!
std
:
:
is_pointer
<
Int
>
:
:
value
>
:
:
type
*
=
nullptr
)
:
Hex
(
spec
static_cast
<
uint8_t
>
(
v
)
)
{
}
template
<
typename
Int
>
explicit
Hex
(
Int
v
PadSpec
spec
=
absl
:
:
kNoPad
typename
std
:
:
enable_if
<
sizeof
(
Int
)
=
=
2
&
&
!
std
:
:
is_pointer
<
Int
>
:
:
value
>
:
:
type
*
=
nullptr
)
:
Hex
(
spec
static_cast
<
uint16_t
>
(
v
)
)
{
}
template
<
typename
Int
>
explicit
Hex
(
Int
v
PadSpec
spec
=
absl
:
:
kNoPad
typename
std
:
:
enable_if
<
sizeof
(
Int
)
=
=
4
&
&
!
std
:
:
is_pointer
<
Int
>
:
:
value
>
:
:
type
*
=
nullptr
)
:
Hex
(
spec
static_cast
<
uint32_t
>
(
v
)
)
{
}
template
<
typename
Int
>
explicit
Hex
(
Int
v
PadSpec
spec
=
absl
:
:
kNoPad
typename
std
:
:
enable_if
<
sizeof
(
Int
)
=
=
8
&
&
!
std
:
:
is_pointer
<
Int
>
:
:
value
>
:
:
type
*
=
nullptr
)
:
Hex
(
spec
static_cast
<
uint64_t
>
(
v
)
)
{
}
template
<
typename
Pointee
>
explicit
Hex
(
Pointee
*
v
PadSpec
spec
=
absl
:
:
kNoPad
)
:
Hex
(
spec
reinterpret_cast
<
uintptr_t
>
(
v
)
)
{
}
private
:
Hex
(
PadSpec
spec
uint64_t
v
)
:
value
(
v
)
width
(
spec
=
=
absl
:
:
kNoPad
?
1
:
spec
>
=
absl
:
:
kSpacePad2
?
spec
-
absl
:
:
kSpacePad2
+
2
:
spec
-
absl
:
:
kZeroPad2
+
2
)
fill
(
spec
>
=
absl
:
:
kSpacePad2
?
'
'
:
'
0
'
)
{
}
}
;
struct
Dec
{
uint64_t
value
;
uint8_t
width
;
char
fill
;
bool
neg
;
template
<
typename
Int
>
explicit
Dec
(
Int
v
PadSpec
spec
=
absl
:
:
kNoPad
typename
std
:
:
enable_if
<
(
sizeof
(
Int
)
<
=
8
)
>
:
:
type
*
=
nullptr
)
:
value
(
v
>
=
0
?
static_cast
<
uint64_t
>
(
v
)
:
uint64_t
{
0
}
-
static_cast
<
uint64_t
>
(
v
)
)
width
(
spec
=
=
absl
:
:
kNoPad
?
1
:
spec
>
=
absl
:
:
kSpacePad2
?
spec
-
absl
:
:
kSpacePad2
+
2
:
spec
-
absl
:
:
kZeroPad2
+
2
)
fill
(
spec
>
=
absl
:
:
kSpacePad2
?
'
'
:
'
0
'
)
neg
(
v
<
0
)
{
}
}
;
class
AlphaNum
{
public
:
AlphaNum
(
int
x
)
:
piece_
(
digits_
static_cast
<
size_t
>
(
numbers_internal
:
:
FastIntToBuffer
(
x
digits_
)
-
&
digits_
[
0
]
)
)
{
}
AlphaNum
(
unsigned
int
x
)
:
piece_
(
digits_
static_cast
<
size_t
>
(
numbers_internal
:
:
FastIntToBuffer
(
x
digits_
)
-
&
digits_
[
0
]
)
)
{
}
AlphaNum
(
long
x
)
:
piece_
(
digits_
static_cast
<
size_t
>
(
numbers_internal
:
:
FastIntToBuffer
(
x
digits_
)
-
&
digits_
[
0
]
)
)
{
}
AlphaNum
(
unsigned
long
x
)
:
piece_
(
digits_
static_cast
<
size_t
>
(
numbers_internal
:
:
FastIntToBuffer
(
x
digits_
)
-
&
digits_
[
0
]
)
)
{
}
AlphaNum
(
long
long
x
)
:
piece_
(
digits_
static_cast
<
size_t
>
(
numbers_internal
:
:
FastIntToBuffer
(
x
digits_
)
-
&
digits_
[
0
]
)
)
{
}
AlphaNum
(
unsigned
long
long
x
)
:
piece_
(
digits_
static_cast
<
size_t
>
(
numbers_internal
:
:
FastIntToBuffer
(
x
digits_
)
-
&
digits_
[
0
]
)
)
{
}
AlphaNum
(
float
f
)
:
piece_
(
digits_
numbers_internal
:
:
SixDigitsToBuffer
(
f
digits_
)
)
{
}
AlphaNum
(
double
f
)
:
piece_
(
digits_
numbers_internal
:
:
SixDigitsToBuffer
(
f
digits_
)
)
{
}
AlphaNum
(
Hex
hex
)
;
AlphaNum
(
Dec
dec
)
;
template
<
size_t
size
>
AlphaNum
(
const
strings_internal
:
:
AlphaNumBuffer
<
size
>
&
buf
)
:
piece_
(
&
buf
.
data
[
0
]
buf
.
size
)
{
}
AlphaNum
(
const
char
*
c_str
)
:
piece_
(
NullSafeStringView
(
c_str
)
)
{
}
AlphaNum
(
absl
:
:
string_view
pc
)
:
piece_
(
pc
)
{
}
template
<
typename
Allocator
>
AlphaNum
(
const
std
:
:
basic_string
<
char
std
:
:
char_traits
<
char
>
Allocator
>
&
str
)
:
piece_
(
str
)
{
}
AlphaNum
(
char
c
)
=
delete
;
AlphaNum
(
const
AlphaNum
&
)
=
delete
;
AlphaNum
&
operator
=
(
const
AlphaNum
&
)
=
delete
;
absl
:
:
string_view
:
:
size_type
size
(
)
const
{
return
piece_
.
size
(
)
;
}
const
char
*
data
(
)
const
{
return
piece_
.
data
(
)
;
}
absl
:
:
string_view
Piece
(
)
const
{
return
piece_
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
T
>
{
}
&
&
!
std
:
:
is_convertible
<
T
int
>
{
}
>
:
:
type
>
AlphaNum
(
T
e
)
:
AlphaNum
(
static_cast
<
typename
std
:
:
underlying_type
<
T
>
:
:
type
>
(
e
)
)
{
}
template
<
typename
T
typename
std
:
:
enable_if
<
std
:
:
is_class
<
T
>
:
:
value
&
&
(
std
:
:
is_same
<
T
std
:
:
vector
<
bool
>
:
:
reference
>
:
:
value
|
|
std
:
:
is_same
<
T
std
:
:
vector
<
bool
>
:
:
const_reference
>
:
:
value
)
>
:
:
type
*
=
nullptr
>
AlphaNum
(
T
e
)
:
AlphaNum
(
static_cast
<
bool
>
(
e
)
)
{
}
private
:
absl
:
:
string_view
piece_
;
char
digits_
[
numbers_internal
:
:
kFastToBufferSize
]
;
}
;
namespace
strings_internal
{
std
:
:
string
CatPieces
(
std
:
:
initializer_list
<
absl
:
:
string_view
>
pieces
)
;
void
AppendPieces
(
std
:
:
string
*
dest
std
:
:
initializer_list
<
absl
:
:
string_view
>
pieces
)
;
}
ABSL_MUST_USE_RESULT
inline
std
:
:
string
StrCat
(
)
{
return
std
:
:
string
(
)
;
}
ABSL_MUST_USE_RESULT
inline
std
:
:
string
StrCat
(
const
AlphaNum
&
a
)
{
return
std
:
:
string
(
a
.
data
(
)
a
.
size
(
)
)
;
}
ABSL_MUST_USE_RESULT
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
)
;
ABSL_MUST_USE_RESULT
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
;
ABSL_MUST_USE_RESULT
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
;
template
<
typename
.
.
.
AV
>
ABSL_MUST_USE_RESULT
inline
std
:
:
string
StrCat
(
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
const
AV
&
.
.
.
args
)
{
return
strings_internal
:
:
CatPieces
(
{
a
.
Piece
(
)
b
.
Piece
(
)
c
.
Piece
(
)
d
.
Piece
(
)
e
.
Piece
(
)
static_cast
<
const
AlphaNum
&
>
(
args
)
.
Piece
(
)
.
.
.
}
)
;
}
inline
void
StrAppend
(
std
:
:
string
*
)
{
}
void
StrAppend
(
std
:
:
string
*
dest
const
AlphaNum
&
a
)
;
void
StrAppend
(
std
:
:
string
*
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
)
;
void
StrAppend
(
std
:
:
string
*
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
)
;
void
StrAppend
(
std
:
:
string
*
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
)
;
template
<
typename
.
.
.
AV
>
inline
void
StrAppend
(
std
:
:
string
*
dest
const
AlphaNum
&
a
const
AlphaNum
&
b
const
AlphaNum
&
c
const
AlphaNum
&
d
const
AlphaNum
&
e
const
AV
&
.
.
.
args
)
{
strings_internal
:
:
AppendPieces
(
dest
{
a
.
Piece
(
)
b
.
Piece
(
)
c
.
Piece
(
)
d
.
Piece
(
)
e
.
Piece
(
)
static_cast
<
const
AlphaNum
&
>
(
args
)
.
Piece
(
)
.
.
.
}
)
;
}
inline
strings_internal
:
:
AlphaNumBuffer
<
numbers_internal
:
:
kSixDigitsToBufferSize
>
SixDigits
(
double
d
)
{
strings_internal
:
:
AlphaNumBuffer
<
numbers_internal
:
:
kSixDigitsToBufferSize
>
result
;
result
.
size
=
numbers_internal
:
:
SixDigitsToBuffer
(
d
&
result
.
data
[
0
]
)
;
return
result
;
}
ABSL_NAMESPACE_END
}
#
endif
