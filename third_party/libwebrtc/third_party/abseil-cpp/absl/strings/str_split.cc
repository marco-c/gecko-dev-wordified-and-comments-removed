#
include
"
absl
/
strings
/
str_split
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
{
template
<
typename
FindPolicy
>
absl
:
:
string_view
GenericFind
(
absl
:
:
string_view
text
absl
:
:
string_view
delimiter
size_t
pos
FindPolicy
find_policy
)
{
if
(
delimiter
.
empty
(
)
&
&
text
.
length
(
)
>
0
)
{
return
absl
:
:
string_view
(
text
.
data
(
)
+
pos
+
1
0
)
;
}
size_t
found_pos
=
absl
:
:
string_view
:
:
npos
;
absl
:
:
string_view
found
(
text
.
data
(
)
+
text
.
size
(
)
0
)
;
found_pos
=
find_policy
.
Find
(
text
delimiter
pos
)
;
if
(
found_pos
!
=
absl
:
:
string_view
:
:
npos
)
{
found
=
absl
:
:
string_view
(
text
.
data
(
)
+
found_pos
find_policy
.
Length
(
delimiter
)
)
;
}
return
found
;
}
struct
LiteralPolicy
{
static
size_t
Find
(
absl
:
:
string_view
text
absl
:
:
string_view
delimiter
size_t
pos
)
{
return
text
.
find
(
delimiter
pos
)
;
}
static
size_t
Length
(
absl
:
:
string_view
delimiter
)
{
return
delimiter
.
length
(
)
;
}
}
;
struct
AnyOfPolicy
{
static
size_t
Find
(
absl
:
:
string_view
text
absl
:
:
string_view
delimiter
size_t
pos
)
{
return
text
.
find_first_of
(
delimiter
pos
)
;
}
static
size_t
Length
(
absl
:
:
string_view
)
{
return
1
;
}
}
;
}
ByString
:
:
ByString
(
absl
:
:
string_view
sp
)
:
delimiter_
(
sp
)
{
}
absl
:
:
string_view
ByString
:
:
Find
(
absl
:
:
string_view
text
size_t
pos
)
const
{
if
(
delimiter_
.
length
(
)
=
=
1
)
{
size_t
found_pos
=
text
.
find
(
delimiter_
[
0
]
pos
)
;
if
(
found_pos
=
=
absl
:
:
string_view
:
:
npos
)
return
absl
:
:
string_view
(
text
.
data
(
)
+
text
.
size
(
)
0
)
;
return
text
.
substr
(
found_pos
1
)
;
}
return
GenericFind
(
text
delimiter_
pos
LiteralPolicy
(
)
)
;
}
absl
:
:
string_view
ByChar
:
:
Find
(
absl
:
:
string_view
text
size_t
pos
)
const
{
size_t
found_pos
=
text
.
find
(
c_
pos
)
;
if
(
found_pos
=
=
absl
:
:
string_view
:
:
npos
)
return
absl
:
:
string_view
(
text
.
data
(
)
+
text
.
size
(
)
0
)
;
return
text
.
substr
(
found_pos
1
)
;
}
ByAnyChar
:
:
ByAnyChar
(
absl
:
:
string_view
sp
)
:
delimiters_
(
sp
)
{
}
absl
:
:
string_view
ByAnyChar
:
:
Find
(
absl
:
:
string_view
text
size_t
pos
)
const
{
return
GenericFind
(
text
delimiters_
pos
AnyOfPolicy
(
)
)
;
}
ByLength
:
:
ByLength
(
ptrdiff_t
length
)
:
length_
(
length
)
{
ABSL_RAW_CHECK
(
length
>
0
"
"
)
;
}
absl
:
:
string_view
ByLength
:
:
Find
(
absl
:
:
string_view
text
size_t
pos
)
const
{
pos
=
std
:
:
min
(
pos
text
.
size
(
)
)
;
absl
:
:
string_view
substr
=
text
.
substr
(
pos
)
;
if
(
substr
.
length
(
)
<
=
static_cast
<
size_t
>
(
length_
)
)
return
absl
:
:
string_view
(
text
.
data
(
)
+
text
.
size
(
)
0
)
;
return
absl
:
:
string_view
(
substr
.
data
(
)
+
length_
0
)
;
}
ABSL_NAMESPACE_END
}
