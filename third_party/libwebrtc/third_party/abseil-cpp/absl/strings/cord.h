#
ifndef
ABSL_STRINGS_CORD_H_
#
define
ABSL_STRINGS_CORD_H_
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
iosfwd
>
#
include
<
iterator
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
internal
/
endian
.
h
"
#
include
"
absl
/
base
/
internal
/
per_thread_tls
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
container
/
inlined_vector
.
h
"
#
include
"
absl
/
functional
/
function_ref
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
strings
/
internal
/
cord_internal
.
h
"
#
include
"
absl
/
strings
/
internal
/
resize_uninitialized
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
Cord
;
class
CordTestPeer
;
template
<
typename
Releaser
>
Cord
MakeCordFromExternal
(
absl
:
:
string_view
Releaser
&
&
)
;
void
CopyCordToString
(
const
Cord
&
src
std
:
:
string
*
dst
)
;
class
Cord
{
private
:
template
<
typename
T
>
using
EnableIfString
=
absl
:
:
enable_if_t
<
std
:
:
is_same
<
T
std
:
:
string
>
:
:
value
int
>
;
public
:
constexpr
Cord
(
)
noexcept
;
Cord
(
const
Cord
&
src
)
;
Cord
(
Cord
&
&
src
)
noexcept
;
Cord
&
operator
=
(
const
Cord
&
x
)
;
Cord
&
operator
=
(
Cord
&
&
x
)
noexcept
;
explicit
Cord
(
absl
:
:
string_view
src
)
;
Cord
&
operator
=
(
absl
:
:
string_view
src
)
;
template
<
typename
T
EnableIfString
<
T
>
=
0
>
explicit
Cord
(
T
&
&
src
)
;
template
<
typename
T
EnableIfString
<
T
>
=
0
>
Cord
&
operator
=
(
T
&
&
src
)
;
~
Cord
(
)
{
if
(
contents_
.
is_tree
(
)
)
DestroyCordSlow
(
)
;
}
template
<
typename
Releaser
>
friend
Cord
MakeCordFromExternal
(
absl
:
:
string_view
data
Releaser
&
&
releaser
)
;
void
Clear
(
)
;
void
Append
(
const
Cord
&
src
)
;
void
Append
(
Cord
&
&
src
)
;
void
Append
(
absl
:
:
string_view
src
)
;
template
<
typename
T
EnableIfString
<
T
>
=
0
>
void
Append
(
T
&
&
src
)
;
void
Prepend
(
const
Cord
&
src
)
;
void
Prepend
(
absl
:
:
string_view
src
)
;
template
<
typename
T
EnableIfString
<
T
>
=
0
>
void
Prepend
(
T
&
&
src
)
;
void
RemovePrefix
(
size_t
n
)
;
void
RemoveSuffix
(
size_t
n
)
;
Cord
Subcord
(
size_t
pos
size_t
new_size
)
const
;
void
swap
(
Cord
&
other
)
noexcept
;
friend
void
swap
(
Cord
&
x
Cord
&
y
)
noexcept
{
x
.
swap
(
y
)
;
}
size_t
size
(
)
const
;
bool
empty
(
)
const
;
size_t
EstimatedMemoryUsage
(
)
const
;
int
Compare
(
absl
:
:
string_view
rhs
)
const
;
int
Compare
(
const
Cord
&
rhs
)
const
;
bool
StartsWith
(
const
Cord
&
rhs
)
const
;
bool
StartsWith
(
absl
:
:
string_view
rhs
)
const
;
bool
EndsWith
(
absl
:
:
string_view
rhs
)
const
;
bool
EndsWith
(
const
Cord
&
rhs
)
const
;
explicit
operator
std
:
:
string
(
)
const
;
friend
void
CopyCordToString
(
const
Cord
&
src
std
:
:
string
*
dst
)
;
class
CharIterator
;
class
ChunkIterator
{
public
:
using
iterator_category
=
std
:
:
input_iterator_tag
;
using
value_type
=
absl
:
:
string_view
;
using
difference_type
=
ptrdiff_t
;
using
pointer
=
const
value_type
*
;
using
reference
=
value_type
;
ChunkIterator
(
)
=
default
;
ChunkIterator
&
operator
+
+
(
)
;
ChunkIterator
operator
+
+
(
int
)
;
bool
operator
=
=
(
const
ChunkIterator
&
other
)
const
;
bool
operator
!
=
(
const
ChunkIterator
&
other
)
const
;
reference
operator
*
(
)
const
;
pointer
operator
-
>
(
)
const
;
friend
class
Cord
;
friend
class
CharIterator
;
private
:
explicit
ChunkIterator
(
const
Cord
*
cord
)
;
void
RemoveChunkPrefix
(
size_t
n
)
;
Cord
AdvanceAndReadBytes
(
size_t
n
)
;
void
AdvanceBytes
(
size_t
n
)
;
void
AdvanceBytesSlowPath
(
size_t
n
)
;
absl
:
:
string_view
current_chunk_
;
absl
:
:
cord_internal
:
:
CordRep
*
current_leaf_
=
nullptr
;
size_t
bytes_remaining_
=
0
;
absl
:
:
InlinedVector
<
absl
:
:
cord_internal
:
:
CordRep
*
4
>
stack_of_right_children_
;
}
;
ChunkIterator
chunk_begin
(
)
const
;
ChunkIterator
chunk_end
(
)
const
;
class
ChunkRange
{
public
:
explicit
ChunkRange
(
const
Cord
*
cord
)
:
cord_
(
cord
)
{
}
ChunkIterator
begin
(
)
const
;
ChunkIterator
end
(
)
const
;
private
:
const
Cord
*
cord_
;
}
;
ChunkRange
Chunks
(
)
const
;
class
CharIterator
{
public
:
using
iterator_category
=
std
:
:
input_iterator_tag
;
using
value_type
=
char
;
using
difference_type
=
ptrdiff_t
;
using
pointer
=
const
char
*
;
using
reference
=
const
char
&
;
CharIterator
(
)
=
default
;
CharIterator
&
operator
+
+
(
)
;
CharIterator
operator
+
+
(
int
)
;
bool
operator
=
=
(
const
CharIterator
&
other
)
const
;
bool
operator
!
=
(
const
CharIterator
&
other
)
const
;
reference
operator
*
(
)
const
;
pointer
operator
-
>
(
)
const
;
friend
Cord
;
private
:
explicit
CharIterator
(
const
Cord
*
cord
)
:
chunk_iterator_
(
cord
)
{
}
ChunkIterator
chunk_iterator_
;
}
;
static
Cord
AdvanceAndRead
(
CharIterator
*
it
size_t
n_bytes
)
;
static
void
Advance
(
CharIterator
*
it
size_t
n_bytes
)
;
static
absl
:
:
string_view
ChunkRemaining
(
const
CharIterator
&
it
)
;
CharIterator
char_begin
(
)
const
;
CharIterator
char_end
(
)
const
;
class
CharRange
{
public
:
explicit
CharRange
(
const
Cord
*
cord
)
:
cord_
(
cord
)
{
}
CharIterator
begin
(
)
const
;
CharIterator
end
(
)
const
;
private
:
const
Cord
*
cord_
;
}
;
CharRange
Chars
(
)
const
;
char
operator
[
]
(
size_t
i
)
const
;
absl
:
:
optional
<
absl
:
:
string_view
>
TryFlat
(
)
const
;
absl
:
:
string_view
Flatten
(
)
;
friend
void
AbslFormatFlush
(
absl
:
:
Cord
*
cord
absl
:
:
string_view
part
)
{
cord
-
>
Append
(
part
)
;
}
template
<
typename
H
>
friend
H
AbslHashValue
(
H
hash_state
const
absl
:
:
Cord
&
c
)
{
absl
:
:
optional
<
absl
:
:
string_view
>
maybe_flat
=
c
.
TryFlat
(
)
;
if
(
maybe_flat
.
has_value
(
)
)
{
return
H
:
:
combine
(
std
:
:
move
(
hash_state
)
*
maybe_flat
)
;
}
return
c
.
HashFragmented
(
std
:
:
move
(
hash_state
)
)
;
}
private
:
friend
class
CordTestPeer
;
friend
bool
operator
=
=
(
const
Cord
&
lhs
const
Cord
&
rhs
)
;
friend
bool
operator
=
=
(
const
Cord
&
lhs
absl
:
:
string_view
rhs
)
;
void
ForEachChunk
(
absl
:
:
FunctionRef
<
void
(
absl
:
:
string_view
)
>
)
const
;
absl
:
:
string_view
FlattenSlowPath
(
)
;
class
InlineRep
{
public
:
static
constexpr
unsigned
char
kMaxInline
=
15
;
static_assert
(
kMaxInline
>
=
sizeof
(
absl
:
:
cord_internal
:
:
CordRep
*
)
"
"
)
;
static
constexpr
unsigned
char
kTreeFlag
=
1
<
<
4
;
static
constexpr
unsigned
char
kProfiledFlag
=
1
<
<
5
;
constexpr
InlineRep
(
)
:
data_
{
}
{
}
InlineRep
(
const
InlineRep
&
src
)
;
InlineRep
(
InlineRep
&
&
src
)
;
InlineRep
&
operator
=
(
const
InlineRep
&
src
)
;
InlineRep
&
operator
=
(
InlineRep
&
&
src
)
noexcept
;
void
Swap
(
InlineRep
*
rhs
)
;
bool
empty
(
)
const
;
size_t
size
(
)
const
;
const
char
*
data
(
)
const
;
void
set_data
(
const
char
*
data
size_t
n
bool
nullify_tail
)
;
char
*
set_data
(
size_t
n
)
;
absl
:
:
cord_internal
:
:
CordRep
*
tree
(
)
const
;
void
set_tree
(
absl
:
:
cord_internal
:
:
CordRep
*
rep
)
;
void
replace_tree
(
absl
:
:
cord_internal
:
:
CordRep
*
rep
)
;
absl
:
:
cord_internal
:
:
CordRep
*
clear
(
)
;
absl
:
:
cord_internal
:
:
CordRep
*
force_tree
(
size_t
extra_hint
)
;
void
reduce_size
(
size_t
n
)
;
void
remove_prefix
(
size_t
n
)
;
void
AppendArray
(
const
char
*
src_data
size_t
src_size
)
;
absl
:
:
string_view
FindFlatStartPiece
(
)
const
;
void
AppendTree
(
absl
:
:
cord_internal
:
:
CordRep
*
tree
)
;
void
PrependTree
(
absl
:
:
cord_internal
:
:
CordRep
*
tree
)
;
void
GetAppendRegion
(
char
*
*
region
size_t
*
size
size_t
max_length
)
;
void
GetAppendRegion
(
char
*
*
region
size_t
*
size
)
;
bool
IsSame
(
const
InlineRep
&
other
)
const
{
return
memcmp
(
data_
other
.
data_
sizeof
(
data_
)
)
=
=
0
;
}
int
BitwiseCompare
(
const
InlineRep
&
other
)
const
{
uint64_t
x
y
;
memcpy
(
&
x
data_
sizeof
(
x
)
)
;
memcpy
(
&
y
other
.
data_
sizeof
(
y
)
)
;
if
(
x
=
=
y
)
{
memcpy
(
&
x
data_
+
8
sizeof
(
x
)
)
;
memcpy
(
&
y
other
.
data_
+
8
sizeof
(
y
)
)
;
if
(
x
=
=
y
)
return
0
;
}
return
absl
:
:
big_endian
:
:
FromHost64
(
x
)
<
absl
:
:
big_endian
:
:
FromHost64
(
y
)
?
-
1
:
1
;
}
void
CopyTo
(
std
:
:
string
*
dst
)
const
{
absl
:
:
strings_internal
:
:
STLStringResizeUninitialized
(
dst
sizeof
(
data_
)
-
1
)
;
memcpy
(
&
(
*
dst
)
[
0
]
data_
sizeof
(
data_
)
-
1
)
;
dst
-
>
erase
(
data_
[
kMaxInline
]
)
;
}
void
CopyToArray
(
char
*
dst
)
const
;
bool
is_tree
(
)
const
{
return
data_
[
kMaxInline
]
>
kMaxInline
;
}
private
:
friend
class
Cord
;
void
AssignSlow
(
const
InlineRep
&
src
)
;
void
ClearSlow
(
)
;
alignas
(
absl
:
:
cord_internal
:
:
CordRep
*
)
char
data_
[
kMaxInline
+
1
]
;
}
;
InlineRep
contents_
;
static
size_t
MemoryUsageAux
(
const
absl
:
:
cord_internal
:
:
CordRep
*
rep
)
;
static
bool
GetFlatAux
(
absl
:
:
cord_internal
:
:
CordRep
*
rep
absl
:
:
string_view
*
fragment
)
;
static
void
ForEachChunkAux
(
absl
:
:
cord_internal
:
:
CordRep
*
rep
absl
:
:
FunctionRef
<
void
(
absl
:
:
string_view
)
>
callback
)
;
void
DestroyCordSlow
(
)
;
void
CopyToArraySlowPath
(
char
*
dst
)
const
;
int
CompareSlowPath
(
absl
:
:
string_view
rhs
size_t
compared_size
size_t
size_to_compare
)
const
;
int
CompareSlowPath
(
const
Cord
&
rhs
size_t
compared_size
size_t
size_to_compare
)
const
;
bool
EqualsImpl
(
absl
:
:
string_view
rhs
size_t
size_to_compare
)
const
;
bool
EqualsImpl
(
const
Cord
&
rhs
size_t
size_to_compare
)
const
;
int
CompareImpl
(
const
Cord
&
rhs
)
const
;
template
<
typename
ResultType
typename
RHS
>
friend
ResultType
GenericCompare
(
const
Cord
&
lhs
const
RHS
&
rhs
size_t
size_to_compare
)
;
static
absl
:
:
string_view
GetFirstChunk
(
const
Cord
&
c
)
;
static
absl
:
:
string_view
GetFirstChunk
(
absl
:
:
string_view
sv
)
;
absl
:
:
cord_internal
:
:
CordRep
*
TakeRep
(
)
const
&
;
absl
:
:
cord_internal
:
:
CordRep
*
TakeRep
(
)
&
&
;
template
<
typename
C
>
void
AppendImpl
(
C
&
&
src
)
;
template
<
typename
H
>
H
HashFragmented
(
H
hash_state
)
const
{
typename
H
:
:
AbslInternalPiecewiseCombiner
combiner
;
ForEachChunk
(
[
&
combiner
&
hash_state
]
(
absl
:
:
string_view
chunk
)
{
hash_state
=
combiner
.
add_buffer
(
std
:
:
move
(
hash_state
)
chunk
.
data
(
)
chunk
.
size
(
)
)
;
}
)
;
return
H
:
:
combine
(
combiner
.
finalize
(
std
:
:
move
(
hash_state
)
)
size
(
)
)
;
}
}
;
ABSL_NAMESPACE_END
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
extern
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
Cord
&
cord
)
;
namespace
cord_internal
{
inline
void
SmallMemmove
(
char
*
dst
const
char
*
src
size_t
n
bool
nullify_tail
=
false
)
{
if
(
n
>
=
8
)
{
assert
(
n
<
=
16
)
;
uint64_t
buf1
;
uint64_t
buf2
;
memcpy
(
&
buf1
src
8
)
;
memcpy
(
&
buf2
src
+
n
-
8
8
)
;
if
(
nullify_tail
)
{
memset
(
dst
+
8
0
8
)
;
}
memcpy
(
dst
&
buf1
8
)
;
memcpy
(
dst
+
n
-
8
&
buf2
8
)
;
}
else
if
(
n
>
=
4
)
{
uint32_t
buf1
;
uint32_t
buf2
;
memcpy
(
&
buf1
src
4
)
;
memcpy
(
&
buf2
src
+
n
-
4
4
)
;
if
(
nullify_tail
)
{
memset
(
dst
+
4
0
4
)
;
memset
(
dst
+
8
0
8
)
;
}
memcpy
(
dst
&
buf1
4
)
;
memcpy
(
dst
+
n
-
4
&
buf2
4
)
;
}
else
{
if
(
n
!
=
0
)
{
dst
[
0
]
=
src
[
0
]
;
dst
[
n
/
2
]
=
src
[
n
/
2
]
;
dst
[
n
-
1
]
=
src
[
n
-
1
]
;
}
if
(
nullify_tail
)
{
memset
(
dst
+
8
0
8
)
;
memset
(
dst
+
n
0
8
)
;
}
}
}
void
InitializeCordRepExternal
(
absl
:
:
string_view
data
CordRepExternal
*
rep
)
;
template
<
typename
Releaser
>
CordRep
*
NewExternalRep
(
absl
:
:
string_view
data
Releaser
&
&
releaser
)
{
using
ReleaserType
=
absl
:
:
decay_t
<
Releaser
>
;
if
(
data
.
empty
(
)
)
{
InvokeReleaser
(
Rank0
{
}
ReleaserType
(
std
:
:
forward
<
Releaser
>
(
releaser
)
)
data
)
;
return
nullptr
;
}
CordRepExternal
*
rep
=
new
CordRepExternalImpl
<
ReleaserType
>
(
std
:
:
forward
<
Releaser
>
(
releaser
)
0
)
;
InitializeCordRepExternal
(
data
rep
)
;
return
rep
;
}
inline
CordRep
*
NewExternalRep
(
absl
:
:
string_view
data
void
(
&
releaser
)
(
absl
:
:
string_view
)
)
{
return
NewExternalRep
(
data
&
releaser
)
;
}
}
template
<
typename
Releaser
>
Cord
MakeCordFromExternal
(
absl
:
:
string_view
data
Releaser
&
&
releaser
)
{
Cord
cord
;
cord
.
contents_
.
set_tree
(
:
:
absl
:
:
cord_internal
:
:
NewExternalRep
(
data
std
:
:
forward
<
Releaser
>
(
releaser
)
)
)
;
return
cord
;
}
inline
Cord
:
:
InlineRep
:
:
InlineRep
(
const
Cord
:
:
InlineRep
&
src
)
{
cord_internal
:
:
SmallMemmove
(
data_
src
.
data_
sizeof
(
data_
)
)
;
}
inline
Cord
:
:
InlineRep
:
:
InlineRep
(
Cord
:
:
InlineRep
&
&
src
)
{
memcpy
(
data_
src
.
data_
sizeof
(
data_
)
)
;
memset
(
src
.
data_
0
sizeof
(
data_
)
)
;
}
inline
Cord
:
:
InlineRep
&
Cord
:
:
InlineRep
:
:
operator
=
(
const
Cord
:
:
InlineRep
&
src
)
{
if
(
this
=
=
&
src
)
{
return
*
this
;
}
if
(
!
is_tree
(
)
&
&
!
src
.
is_tree
(
)
)
{
cord_internal
:
:
SmallMemmove
(
data_
src
.
data_
sizeof
(
data_
)
)
;
return
*
this
;
}
AssignSlow
(
src
)
;
return
*
this
;
}
inline
Cord
:
:
InlineRep
&
Cord
:
:
InlineRep
:
:
operator
=
(
Cord
:
:
InlineRep
&
&
src
)
noexcept
{
if
(
is_tree
(
)
)
{
ClearSlow
(
)
;
}
memcpy
(
data_
src
.
data_
sizeof
(
data_
)
)
;
memset
(
src
.
data_
0
sizeof
(
data_
)
)
;
return
*
this
;
}
inline
void
Cord
:
:
InlineRep
:
:
Swap
(
Cord
:
:
InlineRep
*
rhs
)
{
if
(
rhs
=
=
this
)
{
return
;
}
Cord
:
:
InlineRep
tmp
;
cord_internal
:
:
SmallMemmove
(
tmp
.
data_
data_
sizeof
(
data_
)
)
;
cord_internal
:
:
SmallMemmove
(
data_
rhs
-
>
data_
sizeof
(
data_
)
)
;
cord_internal
:
:
SmallMemmove
(
rhs
-
>
data_
tmp
.
data_
sizeof
(
data_
)
)
;
}
inline
const
char
*
Cord
:
:
InlineRep
:
:
data
(
)
const
{
return
is_tree
(
)
?
nullptr
:
data_
;
}
inline
absl
:
:
cord_internal
:
:
CordRep
*
Cord
:
:
InlineRep
:
:
tree
(
)
const
{
if
(
is_tree
(
)
)
{
absl
:
:
cord_internal
:
:
CordRep
*
rep
;
memcpy
(
&
rep
data_
sizeof
(
rep
)
)
;
return
rep
;
}
else
{
return
nullptr
;
}
}
inline
bool
Cord
:
:
InlineRep
:
:
empty
(
)
const
{
return
data_
[
kMaxInline
]
=
=
0
;
}
inline
size_t
Cord
:
:
InlineRep
:
:
size
(
)
const
{
const
char
tag
=
data_
[
kMaxInline
]
;
if
(
tag
<
=
kMaxInline
)
return
tag
;
return
static_cast
<
size_t
>
(
tree
(
)
-
>
length
)
;
}
inline
void
Cord
:
:
InlineRep
:
:
set_tree
(
absl
:
:
cord_internal
:
:
CordRep
*
rep
)
{
if
(
rep
=
=
nullptr
)
{
memset
(
data_
0
sizeof
(
data_
)
)
;
}
else
{
bool
was_tree
=
is_tree
(
)
;
memcpy
(
data_
&
rep
sizeof
(
rep
)
)
;
memset
(
data_
+
sizeof
(
rep
)
0
sizeof
(
data_
)
-
sizeof
(
rep
)
-
1
)
;
if
(
!
was_tree
)
{
data_
[
kMaxInline
]
=
kTreeFlag
;
}
}
}
inline
void
Cord
:
:
InlineRep
:
:
replace_tree
(
absl
:
:
cord_internal
:
:
CordRep
*
rep
)
{
ABSL_ASSERT
(
is_tree
(
)
)
;
if
(
ABSL_PREDICT_FALSE
(
rep
=
=
nullptr
)
)
{
set_tree
(
rep
)
;
return
;
}
memcpy
(
data_
&
rep
sizeof
(
rep
)
)
;
memset
(
data_
+
sizeof
(
rep
)
0
sizeof
(
data_
)
-
sizeof
(
rep
)
-
1
)
;
}
inline
absl
:
:
cord_internal
:
:
CordRep
*
Cord
:
:
InlineRep
:
:
clear
(
)
{
const
char
tag
=
data_
[
kMaxInline
]
;
absl
:
:
cord_internal
:
:
CordRep
*
result
=
nullptr
;
if
(
tag
>
kMaxInline
)
{
memcpy
(
&
result
data_
sizeof
(
result
)
)
;
}
memset
(
data_
0
sizeof
(
data_
)
)
;
return
result
;
}
inline
void
Cord
:
:
InlineRep
:
:
CopyToArray
(
char
*
dst
)
const
{
assert
(
!
is_tree
(
)
)
;
size_t
n
=
data_
[
kMaxInline
]
;
assert
(
n
!
=
0
)
;
cord_internal
:
:
SmallMemmove
(
dst
data_
n
)
;
}
constexpr
inline
Cord
:
:
Cord
(
)
noexcept
{
}
inline
Cord
&
Cord
:
:
operator
=
(
const
Cord
&
x
)
{
contents_
=
x
.
contents_
;
return
*
this
;
}
inline
Cord
:
:
Cord
(
Cord
&
&
src
)
noexcept
:
contents_
(
std
:
:
move
(
src
.
contents_
)
)
{
}
inline
void
Cord
:
:
swap
(
Cord
&
other
)
noexcept
{
contents_
.
Swap
(
&
other
.
contents_
)
;
}
inline
Cord
&
Cord
:
:
operator
=
(
Cord
&
&
x
)
noexcept
{
contents_
=
std
:
:
move
(
x
.
contents_
)
;
return
*
this
;
}
extern
template
Cord
:
:
Cord
(
std
:
:
string
&
&
src
)
;
extern
template
Cord
&
Cord
:
:
operator
=
(
std
:
:
string
&
&
src
)
;
inline
size_t
Cord
:
:
size
(
)
const
{
return
contents_
.
size
(
)
;
}
inline
bool
Cord
:
:
empty
(
)
const
{
return
contents_
.
empty
(
)
;
}
inline
size_t
Cord
:
:
EstimatedMemoryUsage
(
)
const
{
size_t
result
=
sizeof
(
Cord
)
;
if
(
const
absl
:
:
cord_internal
:
:
CordRep
*
rep
=
contents_
.
tree
(
)
)
{
result
+
=
MemoryUsageAux
(
rep
)
;
}
return
result
;
}
inline
absl
:
:
optional
<
absl
:
:
string_view
>
Cord
:
:
TryFlat
(
)
const
{
absl
:
:
cord_internal
:
:
CordRep
*
rep
=
contents_
.
tree
(
)
;
if
(
rep
=
=
nullptr
)
{
return
absl
:
:
string_view
(
contents_
.
data
(
)
contents_
.
size
(
)
)
;
}
absl
:
:
string_view
fragment
;
if
(
GetFlatAux
(
rep
&
fragment
)
)
{
return
fragment
;
}
return
absl
:
:
nullopt
;
}
inline
absl
:
:
string_view
Cord
:
:
Flatten
(
)
{
absl
:
:
cord_internal
:
:
CordRep
*
rep
=
contents_
.
tree
(
)
;
if
(
rep
=
=
nullptr
)
{
return
absl
:
:
string_view
(
contents_
.
data
(
)
contents_
.
size
(
)
)
;
}
else
{
absl
:
:
string_view
already_flat_contents
;
if
(
GetFlatAux
(
rep
&
already_flat_contents
)
)
{
return
already_flat_contents
;
}
}
return
FlattenSlowPath
(
)
;
}
inline
void
Cord
:
:
Append
(
absl
:
:
string_view
src
)
{
contents_
.
AppendArray
(
src
.
data
(
)
src
.
size
(
)
)
;
}
extern
template
void
Cord
:
:
Append
(
std
:
:
string
&
&
src
)
;
extern
template
void
Cord
:
:
Prepend
(
std
:
:
string
&
&
src
)
;
inline
int
Cord
:
:
Compare
(
const
Cord
&
rhs
)
const
{
if
(
!
contents_
.
is_tree
(
)
&
&
!
rhs
.
contents_
.
is_tree
(
)
)
{
return
contents_
.
BitwiseCompare
(
rhs
.
contents_
)
;
}
return
CompareImpl
(
rhs
)
;
}
inline
bool
Cord
:
:
StartsWith
(
const
Cord
&
rhs
)
const
{
if
(
contents_
.
IsSame
(
rhs
.
contents_
)
)
return
true
;
size_t
rhs_size
=
rhs
.
size
(
)
;
if
(
size
(
)
<
rhs_size
)
return
false
;
return
EqualsImpl
(
rhs
rhs_size
)
;
}
inline
bool
Cord
:
:
StartsWith
(
absl
:
:
string_view
rhs
)
const
{
size_t
rhs_size
=
rhs
.
size
(
)
;
if
(
size
(
)
<
rhs_size
)
return
false
;
return
EqualsImpl
(
rhs
rhs_size
)
;
}
inline
Cord
:
:
ChunkIterator
:
:
ChunkIterator
(
const
Cord
*
cord
)
:
bytes_remaining_
(
cord
-
>
size
(
)
)
{
if
(
cord
-
>
empty
(
)
)
return
;
if
(
cord
-
>
contents_
.
is_tree
(
)
)
{
stack_of_right_children_
.
push_back
(
cord
-
>
contents_
.
tree
(
)
)
;
operator
+
+
(
)
;
}
else
{
current_chunk_
=
absl
:
:
string_view
(
cord
-
>
contents_
.
data
(
)
cord
-
>
size
(
)
)
;
}
}
inline
Cord
:
:
ChunkIterator
Cord
:
:
ChunkIterator
:
:
operator
+
+
(
int
)
{
ChunkIterator
tmp
(
*
this
)
;
operator
+
+
(
)
;
return
tmp
;
}
inline
bool
Cord
:
:
ChunkIterator
:
:
operator
=
=
(
const
ChunkIterator
&
other
)
const
{
return
bytes_remaining_
=
=
other
.
bytes_remaining_
;
}
inline
bool
Cord
:
:
ChunkIterator
:
:
operator
!
=
(
const
ChunkIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
inline
Cord
:
:
ChunkIterator
:
:
reference
Cord
:
:
ChunkIterator
:
:
operator
*
(
)
const
{
ABSL_HARDENING_ASSERT
(
bytes_remaining_
!
=
0
)
;
return
current_chunk_
;
}
inline
Cord
:
:
ChunkIterator
:
:
pointer
Cord
:
:
ChunkIterator
:
:
operator
-
>
(
)
const
{
ABSL_HARDENING_ASSERT
(
bytes_remaining_
!
=
0
)
;
return
&
current_chunk_
;
}
inline
void
Cord
:
:
ChunkIterator
:
:
RemoveChunkPrefix
(
size_t
n
)
{
assert
(
n
<
current_chunk_
.
size
(
)
)
;
current_chunk_
.
remove_prefix
(
n
)
;
bytes_remaining_
-
=
n
;
}
inline
void
Cord
:
:
ChunkIterator
:
:
AdvanceBytes
(
size_t
n
)
{
if
(
ABSL_PREDICT_TRUE
(
n
<
current_chunk_
.
size
(
)
)
)
{
RemoveChunkPrefix
(
n
)
;
}
else
if
(
n
!
=
0
)
{
AdvanceBytesSlowPath
(
n
)
;
}
}
inline
Cord
:
:
ChunkIterator
Cord
:
:
chunk_begin
(
)
const
{
return
ChunkIterator
(
this
)
;
}
inline
Cord
:
:
ChunkIterator
Cord
:
:
chunk_end
(
)
const
{
return
ChunkIterator
(
)
;
}
inline
Cord
:
:
ChunkIterator
Cord
:
:
ChunkRange
:
:
begin
(
)
const
{
return
cord_
-
>
chunk_begin
(
)
;
}
inline
Cord
:
:
ChunkIterator
Cord
:
:
ChunkRange
:
:
end
(
)
const
{
return
cord_
-
>
chunk_end
(
)
;
}
inline
Cord
:
:
ChunkRange
Cord
:
:
Chunks
(
)
const
{
return
ChunkRange
(
this
)
;
}
inline
Cord
:
:
CharIterator
&
Cord
:
:
CharIterator
:
:
operator
+
+
(
)
{
if
(
ABSL_PREDICT_TRUE
(
chunk_iterator_
-
>
size
(
)
>
1
)
)
{
chunk_iterator_
.
RemoveChunkPrefix
(
1
)
;
}
else
{
+
+
chunk_iterator_
;
}
return
*
this
;
}
inline
Cord
:
:
CharIterator
Cord
:
:
CharIterator
:
:
operator
+
+
(
int
)
{
CharIterator
tmp
(
*
this
)
;
operator
+
+
(
)
;
return
tmp
;
}
inline
bool
Cord
:
:
CharIterator
:
:
operator
=
=
(
const
CharIterator
&
other
)
const
{
return
chunk_iterator_
=
=
other
.
chunk_iterator_
;
}
inline
bool
Cord
:
:
CharIterator
:
:
operator
!
=
(
const
CharIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
inline
Cord
:
:
CharIterator
:
:
reference
Cord
:
:
CharIterator
:
:
operator
*
(
)
const
{
return
*
chunk_iterator_
-
>
data
(
)
;
}
inline
Cord
:
:
CharIterator
:
:
pointer
Cord
:
:
CharIterator
:
:
operator
-
>
(
)
const
{
return
chunk_iterator_
-
>
data
(
)
;
}
inline
Cord
Cord
:
:
AdvanceAndRead
(
CharIterator
*
it
size_t
n_bytes
)
{
assert
(
it
!
=
nullptr
)
;
return
it
-
>
chunk_iterator_
.
AdvanceAndReadBytes
(
n_bytes
)
;
}
inline
void
Cord
:
:
Advance
(
CharIterator
*
it
size_t
n_bytes
)
{
assert
(
it
!
=
nullptr
)
;
it
-
>
chunk_iterator_
.
AdvanceBytes
(
n_bytes
)
;
}
inline
absl
:
:
string_view
Cord
:
:
ChunkRemaining
(
const
CharIterator
&
it
)
{
return
*
it
.
chunk_iterator_
;
}
inline
Cord
:
:
CharIterator
Cord
:
:
char_begin
(
)
const
{
return
CharIterator
(
this
)
;
}
inline
Cord
:
:
CharIterator
Cord
:
:
char_end
(
)
const
{
return
CharIterator
(
)
;
}
inline
Cord
:
:
CharIterator
Cord
:
:
CharRange
:
:
begin
(
)
const
{
return
cord_
-
>
char_begin
(
)
;
}
inline
Cord
:
:
CharIterator
Cord
:
:
CharRange
:
:
end
(
)
const
{
return
cord_
-
>
char_end
(
)
;
}
inline
Cord
:
:
CharRange
Cord
:
:
Chars
(
)
const
{
return
CharRange
(
this
)
;
}
inline
void
Cord
:
:
ForEachChunk
(
absl
:
:
FunctionRef
<
void
(
absl
:
:
string_view
)
>
callback
)
const
{
absl
:
:
cord_internal
:
:
CordRep
*
rep
=
contents_
.
tree
(
)
;
if
(
rep
=
=
nullptr
)
{
callback
(
absl
:
:
string_view
(
contents_
.
data
(
)
contents_
.
size
(
)
)
)
;
}
else
{
return
ForEachChunkAux
(
rep
callback
)
;
}
}
inline
bool
operator
=
=
(
const
Cord
&
lhs
const
Cord
&
rhs
)
{
if
(
lhs
.
contents_
.
IsSame
(
rhs
.
contents_
)
)
return
true
;
size_t
rhs_size
=
rhs
.
size
(
)
;
if
(
lhs
.
size
(
)
!
=
rhs_size
)
return
false
;
return
lhs
.
EqualsImpl
(
rhs
rhs_size
)
;
}
inline
bool
operator
!
=
(
const
Cord
&
x
const
Cord
&
y
)
{
return
!
(
x
=
=
y
)
;
}
inline
bool
operator
<
(
const
Cord
&
x
const
Cord
&
y
)
{
return
x
.
Compare
(
y
)
<
0
;
}
inline
bool
operator
>
(
const
Cord
&
x
const
Cord
&
y
)
{
return
x
.
Compare
(
y
)
>
0
;
}
inline
bool
operator
<
=
(
const
Cord
&
x
const
Cord
&
y
)
{
return
x
.
Compare
(
y
)
<
=
0
;
}
inline
bool
operator
>
=
(
const
Cord
&
x
const
Cord
&
y
)
{
return
x
.
Compare
(
y
)
>
=
0
;
}
inline
bool
operator
=
=
(
const
Cord
&
lhs
absl
:
:
string_view
rhs
)
{
size_t
lhs_size
=
lhs
.
size
(
)
;
size_t
rhs_size
=
rhs
.
size
(
)
;
if
(
lhs_size
!
=
rhs_size
)
return
false
;
return
lhs
.
EqualsImpl
(
rhs
rhs_size
)
;
}
inline
bool
operator
=
=
(
absl
:
:
string_view
x
const
Cord
&
y
)
{
return
y
=
=
x
;
}
inline
bool
operator
!
=
(
const
Cord
&
x
absl
:
:
string_view
y
)
{
return
!
(
x
=
=
y
)
;
}
inline
bool
operator
!
=
(
absl
:
:
string_view
x
const
Cord
&
y
)
{
return
!
(
x
=
=
y
)
;
}
inline
bool
operator
<
(
const
Cord
&
x
absl
:
:
string_view
y
)
{
return
x
.
Compare
(
y
)
<
0
;
}
inline
bool
operator
<
(
absl
:
:
string_view
x
const
Cord
&
y
)
{
return
y
.
Compare
(
x
)
>
0
;
}
inline
bool
operator
>
(
const
Cord
&
x
absl
:
:
string_view
y
)
{
return
y
<
x
;
}
inline
bool
operator
>
(
absl
:
:
string_view
x
const
Cord
&
y
)
{
return
y
<
x
;
}
inline
bool
operator
<
=
(
const
Cord
&
x
absl
:
:
string_view
y
)
{
return
!
(
y
<
x
)
;
}
inline
bool
operator
<
=
(
absl
:
:
string_view
x
const
Cord
&
y
)
{
return
!
(
y
<
x
)
;
}
inline
bool
operator
>
=
(
const
Cord
&
x
absl
:
:
string_view
y
)
{
return
!
(
x
<
y
)
;
}
inline
bool
operator
>
=
(
absl
:
:
string_view
x
const
Cord
&
y
)
{
return
!
(
x
<
y
)
;
}
namespace
strings_internal
{
class
CordTestAccess
{
public
:
static
size_t
FlatOverhead
(
)
;
static
size_t
MaxFlatLength
(
)
;
static
size_t
SizeofCordRepConcat
(
)
;
static
size_t
SizeofCordRepExternal
(
)
;
static
size_t
SizeofCordRepSubstring
(
)
;
static
size_t
FlatTagToLength
(
uint8_t
tag
)
;
static
uint8_t
LengthToTag
(
size_t
s
)
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
