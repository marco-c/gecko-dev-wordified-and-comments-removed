#
ifndef
ABSL_NUMERIC_BITS_H_
#
define
ABSL_NUMERIC_BITS_H_
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
if
ABSL_INTERNAL_CPLUSPLUS_LANG
>
=
202002L
#
include
<
bit
>
#
endif
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
numeric
/
internal
/
bits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
#
if
(
defined
(
__cpp_lib_bitops
)
&
&
__cpp_lib_bitops
>
=
201907L
)
&
&
\
(
!
defined
(
_LIBCPP_VERSION
)
|
|
_LIBCPP_VERSION
>
=
180000
)
using
std
:
:
rotl
;
using
std
:
:
rotr
;
#
else
template
<
class
T
>
ABSL_MUST_USE_RESULT
constexpr
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
T
>
:
:
type
rotl
(
T
x
int
s
)
noexcept
{
return
numeric_internal
:
:
RotateLeft
(
x
s
)
;
}
template
<
class
T
>
ABSL_MUST_USE_RESULT
constexpr
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
T
>
:
:
type
rotr
(
T
x
int
s
)
noexcept
{
return
numeric_internal
:
:
RotateRight
(
x
s
)
;
}
#
endif
#
if
(
defined
(
__cpp_lib_bitops
)
&
&
__cpp_lib_bitops
>
=
201907L
)
using
std
:
:
countl_one
;
using
std
:
:
countl_zero
;
using
std
:
:
countr_one
;
using
std
:
:
countr_zero
;
using
std
:
:
popcount
;
#
else
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CLZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
int
>
:
:
type
countl_zero
(
T
x
)
noexcept
{
return
numeric_internal
:
:
CountLeadingZeroes
(
x
)
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CLZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
int
>
:
:
type
countl_one
(
T
x
)
noexcept
{
return
countl_zero
(
static_cast
<
T
>
(
~
x
)
)
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CTZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
int
>
:
:
type
countr_zero
(
T
x
)
noexcept
{
return
numeric_internal
:
:
CountTrailingZeroes
(
x
)
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CTZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
int
>
:
:
type
countr_one
(
T
x
)
noexcept
{
return
countr_zero
(
static_cast
<
T
>
(
~
x
)
)
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_POPCOUNT
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
int
>
:
:
type
popcount
(
T
x
)
noexcept
{
return
numeric_internal
:
:
Popcount
(
x
)
;
}
#
endif
#
if
(
defined
(
__cpp_lib_int_pow2
)
&
&
__cpp_lib_int_pow2
>
=
202002L
)
using
std
:
:
bit_ceil
;
using
std
:
:
bit_floor
;
using
std
:
:
bit_width
;
using
std
:
:
has_single_bit
;
#
else
template
<
class
T
>
constexpr
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
bool
>
:
:
type
has_single_bit
(
T
x
)
noexcept
{
return
x
!
=
0
&
&
(
x
&
(
x
-
1
)
)
=
=
0
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CLZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
int
>
:
:
type
bit_width
(
T
x
)
noexcept
{
return
std
:
:
numeric_limits
<
T
>
:
:
digits
-
countl_zero
(
x
)
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CLZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
T
>
:
:
type
bit_floor
(
T
x
)
noexcept
{
return
x
=
=
0
?
0
:
T
{
1
}
<
<
(
bit_width
(
x
)
-
1
)
;
}
template
<
class
T
>
ABSL_INTERNAL_CONSTEXPR_CLZ
inline
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T
>
:
:
value
T
>
:
:
type
bit_ceil
(
T
x
)
{
return
has_single_bit
(
x
)
?
T
{
1
}
<
<
(
bit_width
(
x
)
-
1
)
:
numeric_internal
:
:
BitCeilNonPowerOf2
(
x
)
;
}
#
endif
ABSL_NAMESPACE_END
}
#
endif
