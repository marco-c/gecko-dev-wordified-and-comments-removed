#
ifndef
ABSL_TYPES_INTERNAL_SPAN_H_
#
define
ABSL_TYPES_INTERNAL_SPAN_H_
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
algorithm
/
algorithm
.
h
"
#
include
"
absl
/
base
/
internal
/
throw_delegate
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
span_internal
{
constexpr
size_t
Min
(
size_t
a
size_t
b
)
noexcept
{
return
a
<
b
?
a
:
b
;
}
template
<
typename
C
>
constexpr
auto
GetDataImpl
(
C
&
c
char
)
noexcept
-
>
decltype
(
c
.
data
(
)
)
{
return
c
.
data
(
)
;
}
inline
char
*
GetDataImpl
(
std
:
:
string
&
s
int
)
noexcept
{
return
&
s
[
0
]
;
}
template
<
typename
C
>
constexpr
auto
GetData
(
C
&
c
)
noexcept
-
>
decltype
(
GetDataImpl
(
c
0
)
)
{
return
GetDataImpl
(
c
0
)
;
}
template
<
typename
C
>
using
HasSize
=
std
:
:
is_integral
<
absl
:
:
decay_t
<
decltype
(
std
:
:
declval
<
C
&
>
(
)
.
size
(
)
)
>
>
;
template
<
typename
T
typename
C
>
using
HasData
=
std
:
:
is_convertible
<
absl
:
:
decay_t
<
decltype
(
GetData
(
std
:
:
declval
<
C
&
>
(
)
)
)
>
*
T
*
const
*
>
;
template
<
typename
C
>
struct
ElementType
{
using
type
=
typename
absl
:
:
remove_reference_t
<
C
>
:
:
value_type
;
}
;
template
<
typename
T
size_t
N
>
struct
ElementType
<
T
(
&
)
[
N
]
>
{
using
type
=
T
;
}
;
template
<
typename
C
>
using
ElementT
=
typename
ElementType
<
C
>
:
:
type
;
template
<
typename
T
>
using
EnableIfMutable
=
typename
std
:
:
enable_if
<
!
std
:
:
is_const
<
T
>
:
:
value
int
>
:
:
type
;
template
<
template
<
typename
>
class
SpanT
typename
T
>
bool
EqualImpl
(
SpanT
<
T
>
a
SpanT
<
T
>
b
)
{
static_assert
(
std
:
:
is_const
<
T
>
:
:
value
"
"
)
;
return
absl
:
:
equal
(
a
.
begin
(
)
a
.
end
(
)
b
.
begin
(
)
b
.
end
(
)
)
;
}
template
<
template
<
typename
>
class
SpanT
typename
T
>
bool
LessThanImpl
(
SpanT
<
T
>
a
SpanT
<
T
>
b
)
{
static_assert
(
std
:
:
is_const
<
T
>
:
:
value
"
"
)
;
return
std
:
:
lexicographical_compare
(
a
.
begin
(
)
a
.
end
(
)
b
.
begin
(
)
b
.
end
(
)
)
;
}
template
<
typename
From
typename
To
>
struct
IsConvertibleHelper
{
private
:
static
std
:
:
true_type
testval
(
To
)
;
static
std
:
:
false_type
testval
(
.
.
.
)
;
public
:
using
type
=
decltype
(
testval
(
std
:
:
declval
<
From
>
(
)
)
)
;
}
;
template
<
typename
From
typename
To
>
struct
IsConvertible
:
IsConvertibleHelper
<
From
To
>
:
:
type
{
}
;
template
<
typename
From
typename
To
>
using
EnableIfConvertibleTo
=
typename
std
:
:
enable_if
<
IsConvertible
<
From
To
>
:
:
value
>
:
:
type
;
}
ABSL_NAMESPACE_END
}
#
endif
