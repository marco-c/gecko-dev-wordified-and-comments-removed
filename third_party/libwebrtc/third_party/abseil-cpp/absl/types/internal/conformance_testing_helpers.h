#
ifndef
ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_HELPERS_H_
#
define
ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_HELPERS_H_
#
if
(
defined
(
__ANDROID__
)
|
|
defined
(
ANDROID
)
)
&
&
!
defined
(
OS_ANDROID
)
#
define
ABSL_INTERNAL_OS_ANDROID
#
endif
#
if
defined
(
OS_ANDROID
)
&
&
(
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
)
#
define
ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
0
#
elif
(
__GNUC__
>
=
4
|
|
(
__GNUC__
>
=
3
&
&
__GNUC_MINOR__
>
=
4
)
)
&
&
\
!
defined
(
__mips__
)
#
define
ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
1
#
elif
defined
(
__clang__
)
&
&
!
defined
(
_MSC_VER
)
#
define
ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
1
#
else
#
define
ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
0
#
endif
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
#
if
ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
#
include
<
cxxabi
.
h
>
#
include
<
cstdlib
>
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
types_internal
{
template
<
class
T
>
absl
:
:
string_view
NameOfImpl
(
)
{
#
if
ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
int
status
=
0
;
char
*
demangled_name
=
nullptr
;
demangled_name
=
abi
:
:
__cxa_demangle
(
typeid
(
T
)
.
name
(
)
nullptr
nullptr
&
status
)
;
if
(
status
=
=
0
&
&
demangled_name
!
=
nullptr
)
{
return
demangled_name
;
}
else
{
return
typeid
(
T
)
.
name
(
)
;
}
#
else
return
typeid
(
T
)
.
name
(
)
;
#
endif
}
template
<
class
T
>
std
:
:
string
NameOf
(
)
{
static
const
absl
:
:
string_view
result
=
NameOfImpl
<
T
>
(
)
;
return
std
:
:
string
(
result
)
;
}
template
<
class
Fun
class
=
void
>
struct
IsNullaryCallableImpl
:
std
:
:
false_type
{
}
;
template
<
class
Fun
>
struct
IsNullaryCallableImpl
<
Fun
absl
:
:
void_t
<
decltype
(
std
:
:
declval
<
const
Fun
&
>
(
)
(
)
)
>
>
:
std
:
:
true_type
{
using
result_type
=
decltype
(
std
:
:
declval
<
const
Fun
&
>
(
)
(
)
)
;
template
<
class
ValueType
>
using
for_type
=
std
:
:
is_same
<
ValueType
result_type
>
;
using
void_if_true
=
void
;
}
;
template
<
class
Fun
>
struct
IsNullaryCallable
:
IsNullaryCallableImpl
<
Fun
>
{
}
;
template
<
class
Fun
>
struct
GeneratorType
;
template
<
class
.
.
.
Funs
>
struct
EquivalenceClassType
;
template
<
class
T
>
struct
IsEquivalenceClass
:
std
:
:
false_type
{
}
;
template
<
>
struct
IsEquivalenceClass
<
EquivalenceClassType
<
>
>
:
std
:
:
true_type
{
using
self
=
IsEquivalenceClass
;
template
<
class
ValueType
>
using
for_type
=
std
:
:
true_type
;
}
;
template
<
class
Head
class
.
.
.
Tail
>
struct
IsEquivalenceClass
<
EquivalenceClassType
<
Head
Tail
.
.
.
>
>
:
std
:
:
true_type
{
using
self
=
IsEquivalenceClass
;
using
result_type
=
typename
IsNullaryCallable
<
Head
>
:
:
result_type
;
template
<
class
ValueType
>
using
for_type
=
std
:
:
is_same
<
ValueType
result_type
>
;
}
;
template
<
class
.
.
.
EqClasses
>
struct
OrderedEquivalenceClasses
;
template
<
class
T
>
struct
ResultOfGenerator
{
}
;
template
<
class
Fun
>
struct
ResultOfGenerator
<
GeneratorType
<
Fun
>
>
{
using
type
=
decltype
(
std
:
:
declval
<
const
Fun
&
>
(
)
(
)
)
;
}
;
template
<
class
Fun
>
using
ResultOfGeneratorT
=
typename
ResultOfGenerator
<
GeneratorType
<
Fun
>
>
:
:
type
;
template
<
class
class
.
.
.
Funs
>
struct
AreGeneratorsWithTheSameReturnTypeImpl
:
std
:
:
false_type
{
}
;
template
<
>
struct
AreGeneratorsWithTheSameReturnTypeImpl
<
void
>
:
std
:
:
true_type
{
}
;
template
<
class
Head
class
.
.
.
Tail
>
struct
AreGeneratorsWithTheSameReturnTypeImpl
<
typename
std
:
:
enable_if
<
absl
:
:
conjunction
<
std
:
:
is_same
<
ResultOfGeneratorT
<
Head
>
ResultOfGeneratorT
<
Tail
>
>
.
.
.
>
:
:
value
>
:
:
type
Head
Tail
.
.
.
>
:
std
:
:
true_type
{
}
;
template
<
class
.
.
.
Funs
>
struct
AreGeneratorsWithTheSameReturnType
:
AreGeneratorsWithTheSameReturnTypeImpl
<
void
Funs
.
.
.
>
:
:
type
{
}
;
template
<
class
.
.
.
EqClasses
>
struct
AreEquivalenceClassesOfTheSameType
{
static_assert
(
sizeof
.
.
.
(
EqClasses
)
!
=
sizeof
.
.
.
(
EqClasses
)
"
"
)
;
}
;
template
<
>
struct
AreEquivalenceClassesOfTheSameType
<
>
:
std
:
:
true_type
{
using
self
=
AreEquivalenceClassesOfTheSameType
;
template
<
class
>
using
for_type
=
std
:
:
true_type
;
}
;
template
<
class
.
.
.
Funs
>
struct
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
Funs
.
.
.
>
>
:
std
:
:
true_type
{
using
self
=
AreEquivalenceClassesOfTheSameType
;
template
<
class
ValueType
>
using
for_type
=
typename
IsEquivalenceClass
<
EquivalenceClassType
<
Funs
.
.
.
>
>
:
:
template
for_type
<
ValueType
>
;
}
;
template
<
class
.
.
.
TailEqClasses
>
struct
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
>
EquivalenceClassType
<
>
TailEqClasses
.
.
.
>
:
AreEquivalenceClassesOfTheSameType
<
TailEqClasses
.
.
.
>
:
:
self
{
}
;
template
<
class
HeadNextFun
class
.
.
.
TailNextFuns
class
.
.
.
TailEqClasses
>
struct
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
>
EquivalenceClassType
<
HeadNextFun
TailNextFuns
.
.
.
>
TailEqClasses
.
.
.
>
:
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
HeadNextFun
TailNextFuns
.
.
.
>
TailEqClasses
.
.
.
>
:
:
self
{
}
;
template
<
class
HeadHeadFun
class
.
.
.
TailHeadFuns
class
.
.
.
TailEqClasses
>
struct
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
HeadHeadFun
TailHeadFuns
.
.
.
>
EquivalenceClassType
<
>
TailEqClasses
.
.
.
>
:
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
HeadHeadFun
TailHeadFuns
.
.
.
>
TailEqClasses
.
.
.
>
:
:
self
{
}
;
template
<
class
HeadHeadFun
class
.
.
.
TailHeadFuns
class
HeadNextFun
class
.
.
.
TailNextFuns
class
.
.
.
TailEqClasses
>
struct
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
HeadHeadFun
TailHeadFuns
.
.
.
>
EquivalenceClassType
<
HeadNextFun
TailNextFuns
.
.
.
>
TailEqClasses
.
.
.
>
:
absl
:
:
conditional_t
<
IsNullaryCallable
<
HeadNextFun
>
:
:
template
for_type
<
typename
IsNullaryCallable
<
HeadHeadFun
>
:
:
result_type
>
:
:
value
AreEquivalenceClassesOfTheSameType
<
EquivalenceClassType
<
HeadHeadFun
TailHeadFuns
.
.
.
>
TailEqClasses
.
.
.
>
std
:
:
false_type
>
{
}
;
template
<
class
Fun
class
.
.
.
Cases
>
void
ForEachParameter
(
const
Fun
&
fun
const
Cases
&
.
.
.
cases
)
{
const
std
:
:
initializer_list
<
bool
>
results
=
{
(
static_cast
<
void
>
(
fun
(
cases
)
)
true
)
.
.
.
}
;
(
void
)
results
;
}
template
<
class
Fun
>
struct
ForEachParameterFun
{
template
<
class
.
.
.
T
>
void
operator
(
)
(
const
T
&
.
.
.
cases
)
const
{
(
ForEachParameter
)
(
fun
cases
.
.
.
)
;
}
Fun
fun
;
}
;
template
<
class
Fun
class
Tup
>
void
ForEachTupleElement
(
const
Fun
&
fun
const
Tup
&
tup
)
{
absl
:
:
apply
(
ForEachParameterFun
<
Fun
>
{
fun
}
tup
)
;
}
template
<
class
Fun
class
.
.
.
T
>
struct
ForEveryTwoImpl
{
template
<
class
Lhs
>
struct
WithBoundLhs
{
template
<
class
Rhs
>
void
operator
(
)
(
const
Rhs
&
rhs
)
const
{
fun
(
lhs
rhs
)
;
}
Fun
fun
;
Lhs
lhs
;
}
;
template
<
class
Lhs
>
void
operator
(
)
(
const
Lhs
&
lhs
)
const
{
(
ForEachTupleElement
)
(
WithBoundLhs
<
Lhs
>
{
fun
lhs
}
args
)
;
}
Fun
fun
;
std
:
:
tuple
<
T
.
.
.
>
args
;
}
;
template
<
class
Fun
class
.
.
.
T
>
void
ForEveryTwo
(
const
Fun
&
fun
std
:
:
tuple
<
T
.
.
.
>
args
)
{
(
ForEachTupleElement
)
(
ForEveryTwoImpl
<
Fun
T
.
.
.
>
{
fun
args
}
args
)
;
}
template
<
class
Container
>
void
InsertEach
(
Container
*
cont
)
{
}
template
<
class
Container
class
H
class
.
.
.
T
>
void
InsertEach
(
Container
*
cont
H
&
&
head
T
&
&
.
.
.
tail
)
{
cont
-
>
insert
(
head
)
;
(
InsertEach
)
(
cont
tail
.
.
.
)
;
}
template
<
bool
Condition
>
struct
If
;
template
<
>
struct
If
<
false
>
{
template
<
class
Fun
class
.
.
.
P
>
static
void
Invoke
(
const
Fun
&
P
&
&
.
.
.
)
{
}
}
;
template
<
>
struct
If
<
true
>
{
template
<
class
Fun
class
.
.
.
P
>
static
void
Invoke
(
const
Fun
&
fun
P
&
&
.
.
.
args
)
{
fun
(
absl
:
:
forward
<
P
>
(
args
)
.
.
.
)
;
}
}
;
#
define
ABSL_INTERNAL_STRINGIZE
(
.
.
.
)
ABSL_INTERNAL_STRINGIZE_IMPL
(
(
__VA_ARGS__
)
)
#
define
ABSL_INTERNAL_STRINGIZE_IMPL
(
arg
)
ABSL_INTERNAL_STRINGIZE_IMPL2
arg
#
define
ABSL_INTERNAL_STRINGIZE_IMPL2
(
.
.
.
)
#
__VA_ARGS__
}
ABSL_NAMESPACE_END
}
#
endif
