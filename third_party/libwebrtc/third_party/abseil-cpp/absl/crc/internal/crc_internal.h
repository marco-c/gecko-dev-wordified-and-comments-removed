#
ifndef
ABSL_CRC_INTERNAL_CRC_INTERNAL_H_
#
define
ABSL_CRC_INTERNAL_CRC_INTERNAL_H_
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
crc
/
internal
/
crc
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
crc_internal
{
constexpr
int
kPrefetchHorizon
=
ABSL_CACHELINE_SIZE
*
4
;
constexpr
int
kPrefetchHorizonMedium
=
ABSL_CACHELINE_SIZE
*
1
;
static_assert
(
kPrefetchHorizon
>
=
64
"
CRCPrefetchHorizon
less
than
loop
len
"
)
;
constexpr
uint64_t
kScrambleHi
=
(
static_cast
<
uint64_t
>
(
0x4f1bbcdcU
)
<
<
32
)
|
static_cast
<
uint64_t
>
(
0xbfa53e0aU
)
;
constexpr
uint64_t
kScrambleLo
=
(
static_cast
<
uint64_t
>
(
0xf9ce6030U
)
<
<
32
)
|
static_cast
<
uint64_t
>
(
0x2e76e41bU
)
;
class
CRCImpl
:
public
CRC
{
public
:
using
Uint32By256
=
uint32_t
[
256
]
;
CRCImpl
(
)
=
default
;
~
CRCImpl
(
)
override
=
default
;
static
CRCImpl
*
NewInternal
(
)
;
static
void
FillWordTable
(
uint32_t
poly
uint32_t
last
int
word_size
Uint32By256
*
t
)
;
static
int
FillZeroesTable
(
uint32_t
poly
Uint32By256
*
t
)
;
virtual
void
InitTables
(
)
=
0
;
private
:
CRCImpl
(
const
CRCImpl
&
)
=
delete
;
CRCImpl
&
operator
=
(
const
CRCImpl
&
)
=
delete
;
}
;
class
CRC32
:
public
CRCImpl
{
public
:
CRC32
(
)
=
default
;
~
CRC32
(
)
override
=
default
;
void
Extend
(
uint32_t
*
crc
const
void
*
bytes
size_t
length
)
const
override
;
void
ExtendByZeroes
(
uint32_t
*
crc
size_t
length
)
const
override
;
void
Scramble
(
uint32_t
*
crc
)
const
override
;
void
Unscramble
(
uint32_t
*
crc
)
const
override
;
void
UnextendByZeroes
(
uint32_t
*
crc
size_t
length
)
const
override
;
void
InitTables
(
)
override
;
private
:
static
void
ExtendByZeroesImpl
(
uint32_t
*
crc
size_t
length
const
uint32_t
zeroes_table
[
256
]
const
uint32_t
poly_table
[
256
]
)
;
uint32_t
table0_
[
256
]
;
uint32_t
zeroes_
[
256
]
;
uint32_t
table_
[
4
]
[
256
]
;
uint32_t
reverse_table0_
[
256
]
;
uint32_t
reverse_zeroes_
[
256
]
;
CRC32
(
const
CRC32
&
)
=
delete
;
CRC32
&
operator
=
(
const
CRC32
&
)
=
delete
;
}
;
template
<
typename
T
>
T
MaskOfLength
(
int
len
)
{
return
(
T
(
2
)
<
<
(
len
-
1
)
)
-
1
;
}
template
<
typename
T
>
T
RotateRight
(
T
in
int
width
int
r
)
{
return
(
in
<
<
(
width
-
r
)
)
|
(
(
in
>
>
r
)
&
MaskOfLength
<
T
>
(
width
-
r
)
)
;
}
template
<
int
alignment
>
const
uint8_t
*
RoundUp
(
const
uint8_t
*
p
)
{
static_assert
(
(
alignment
&
(
alignment
-
1
)
)
=
=
0
"
alignment
is
not
2
^
n
"
)
;
constexpr
uintptr_t
mask
=
alignment
-
1
;
const
uintptr_t
as_uintptr
=
reinterpret_cast
<
uintptr_t
>
(
p
)
;
return
reinterpret_cast
<
const
uint8_t
*
>
(
(
as_uintptr
+
mask
)
&
~
mask
)
;
}
CRCImpl
*
TryNewCRC32AcceleratedX86ARMCombined
(
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
CRCImpl
>
>
NewCRC32AcceleratedX86ARMCombinedAll
(
)
;
}
ABSL_NAMESPACE_END
}
#
endif
