#
include
<
type_traits
>
#
if
defined
(
_WIN32
)
#
include
<
condition_variable
>
#
include
<
mutex
>
#
else
#
include
<
pthread
.
h
>
#
endif
#
include
"
absl
/
base
/
call_once
.
h
"
#
include
"
absl
/
time
/
time
.
h
"
#
ifdef
ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE
#
error
ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE
cannot
be
directly
set
#
else
#
define
ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE
1
#
endif
#
ifdef
ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED
#
error
ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED
cannot
be
directly
set
#
else
#
define
ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED
1
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
Condition
;
namespace
synchronization_internal
{
class
MutexImpl
;
class
CondVarImpl
{
public
:
CondVarImpl
(
)
;
CondVarImpl
(
const
CondVarImpl
&
)
=
delete
;
CondVarImpl
&
operator
=
(
const
CondVarImpl
&
)
=
delete
;
~
CondVarImpl
(
)
;
void
Signal
(
)
;
void
SignalAll
(
)
;
void
Wait
(
MutexImpl
*
mutex
)
;
bool
WaitWithDeadline
(
MutexImpl
*
mutex
absl
:
:
Time
deadline
)
;
private
:
#
if
defined
(
_WIN32
)
std
:
:
condition_variable_any
std_cv_
;
#
else
pthread_cond_t
pthread_cv_
;
#
endif
}
;
class
MutexImpl
{
public
:
MutexImpl
(
)
;
MutexImpl
(
const
MutexImpl
&
)
=
delete
;
MutexImpl
&
operator
=
(
const
MutexImpl
&
)
=
delete
;
~
MutexImpl
(
)
;
void
Lock
(
)
;
bool
TryLock
(
)
;
void
Unlock
(
)
;
void
Await
(
const
Condition
&
cond
)
;
bool
AwaitWithDeadline
(
const
Condition
&
cond
absl
:
:
Time
deadline
)
;
private
:
friend
class
CondVarImpl
;
#
if
defined
(
_WIN32
)
std
:
:
mutex
std_mutex_
;
#
else
pthread_mutex_t
pthread_mutex_
;
#
endif
bool
locked_
=
false
;
CondVarImpl
released_
;
}
;
template
<
typename
T
>
class
SynchronizationStorage
{
public
:
SynchronizationStorage
(
)
:
destruct_
(
true
)
once_
(
)
{
}
constexpr
explicit
SynchronizationStorage
(
absl
:
:
ConstInitType
)
:
destruct_
(
false
)
once_
(
)
space_
{
{
0
}
}
{
}
SynchronizationStorage
(
SynchronizationStorage
&
)
=
delete
;
SynchronizationStorage
&
operator
=
(
SynchronizationStorage
&
)
=
delete
;
~
SynchronizationStorage
(
)
{
if
(
destruct_
)
{
get
(
)
-
>
~
T
(
)
;
}
}
T
*
get
(
)
{
absl
:
:
call_once
(
once_
SynchronizationStorage
:
:
Construct
this
)
;
return
reinterpret_cast
<
T
*
>
(
&
space_
)
;
}
private
:
static
void
Construct
(
SynchronizationStorage
<
T
>
*
self
)
{
new
(
&
self
-
>
space_
)
T
(
)
;
}
const
bool
destruct_
;
absl
:
:
once_flag
once_
;
alignas
(
T
)
unsigned
char
space_
[
sizeof
(
T
)
]
;
}
;
}
ABSL_NAMESPACE_END
}
