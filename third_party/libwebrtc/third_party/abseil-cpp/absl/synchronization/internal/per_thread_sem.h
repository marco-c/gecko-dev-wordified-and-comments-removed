#
ifndef
ABSL_SYNCHRONIZATION_INTERNAL_PER_THREAD_SEM_H_
#
define
ABSL_SYNCHRONIZATION_INTERNAL_PER_THREAD_SEM_H_
#
include
<
atomic
>
#
include
"
absl
/
base
/
internal
/
thread_identity
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
create_thread_identity
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
kernel_timeout
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
Mutex
;
namespace
synchronization_internal
{
class
PerThreadSem
{
public
:
PerThreadSem
(
)
=
delete
;
PerThreadSem
(
const
PerThreadSem
&
)
=
delete
;
PerThreadSem
&
operator
=
(
const
PerThreadSem
&
)
=
delete
;
static
void
Tick
(
base_internal
:
:
ThreadIdentity
*
identity
)
;
static
void
SetThreadBlockedCounter
(
std
:
:
atomic
<
int
>
*
counter
)
;
static
std
:
:
atomic
<
int
>
*
GetThreadBlockedCounter
(
)
;
private
:
static
void
Init
(
base_internal
:
:
ThreadIdentity
*
identity
)
;
static
void
Destroy
(
base_internal
:
:
ThreadIdentity
*
identity
)
;
static
inline
void
Post
(
base_internal
:
:
ThreadIdentity
*
identity
)
;
static
inline
bool
Wait
(
KernelTimeout
t
)
;
friend
class
PerThreadSemTest
;
friend
class
absl
:
:
Mutex
;
friend
absl
:
:
base_internal
:
:
ThreadIdentity
*
CreateThreadIdentity
(
)
;
friend
void
ReclaimThreadIdentity
(
void
*
v
)
;
}
;
}
ABSL_NAMESPACE_END
}
extern
"
C
"
{
void
ABSL_INTERNAL_C_SYMBOL
(
AbslInternalPerThreadSemPost
)
(
absl
:
:
base_internal
:
:
ThreadIdentity
*
identity
)
;
bool
ABSL_INTERNAL_C_SYMBOL
(
AbslInternalPerThreadSemWait
)
(
absl
:
:
synchronization_internal
:
:
KernelTimeout
t
)
;
}
void
absl
:
:
synchronization_internal
:
:
PerThreadSem
:
:
Post
(
absl
:
:
base_internal
:
:
ThreadIdentity
*
identity
)
{
ABSL_INTERNAL_C_SYMBOL
(
AbslInternalPerThreadSemPost
)
(
identity
)
;
}
bool
absl
:
:
synchronization_internal
:
:
PerThreadSem
:
:
Wait
(
absl
:
:
synchronization_internal
:
:
KernelTimeout
t
)
{
return
ABSL_INTERNAL_C_SYMBOL
(
AbslInternalPerThreadSemWait
)
(
t
)
;
}
#
endif
