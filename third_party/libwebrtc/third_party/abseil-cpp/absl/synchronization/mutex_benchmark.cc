#
include
<
cstdint
>
#
include
<
mutex
>
#
include
<
vector
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
cycleclock
.
h
"
#
include
"
absl
/
base
/
internal
/
spinlock
.
h
"
#
include
"
absl
/
synchronization
/
blocking_counter
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
thread_pool
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
#
include
"
benchmark
/
benchmark
.
h
"
namespace
{
void
BM_Mutex
(
benchmark
:
:
State
&
state
)
{
static
absl
:
:
Mutex
*
mu
=
new
absl
:
:
Mutex
;
for
(
auto
_
:
state
)
{
absl
:
:
MutexLock
lock
(
mu
)
;
}
}
BENCHMARK
(
BM_Mutex
)
-
>
UseRealTime
(
)
-
>
Threads
(
1
)
-
>
ThreadPerCpu
(
)
;
static
void
DelayNs
(
int64_t
ns
int
*
data
)
{
int64_t
end
=
absl
:
:
base_internal
:
:
CycleClock
:
:
Now
(
)
+
ns
*
absl
:
:
base_internal
:
:
CycleClock
:
:
Frequency
(
)
/
1e9
;
while
(
absl
:
:
base_internal
:
:
CycleClock
:
:
Now
(
)
<
end
)
{
+
+
(
*
data
)
;
benchmark
:
:
DoNotOptimize
(
*
data
)
;
}
}
template
<
typename
MutexType
>
class
RaiiLocker
{
public
:
explicit
RaiiLocker
(
MutexType
*
mu
)
:
mu_
(
mu
)
{
mu_
-
>
Lock
(
)
;
}
~
RaiiLocker
(
)
{
mu_
-
>
Unlock
(
)
;
}
private
:
MutexType
*
mu_
;
}
;
template
<
>
class
RaiiLocker
<
std
:
:
mutex
>
{
public
:
explicit
RaiiLocker
(
std
:
:
mutex
*
mu
)
:
mu_
(
mu
)
{
mu_
-
>
lock
(
)
;
}
~
RaiiLocker
(
)
{
mu_
-
>
unlock
(
)
;
}
private
:
std
:
:
mutex
*
mu_
;
}
;
template
<
typename
MutexType
>
void
BM_Contended
(
benchmark
:
:
State
&
state
)
{
struct
Shared
{
MutexType
mu
;
int
data
=
0
;
}
;
static
auto
*
shared
=
new
Shared
;
int
local
=
0
;
for
(
auto
_
:
state
)
{
DelayNs
(
100
*
state
.
threads
&
local
)
;
RaiiLocker
<
MutexType
>
locker
(
&
shared
-
>
mu
)
;
DelayNs
(
state
.
range
(
0
)
&
shared
-
>
data
)
;
}
}
BENCHMARK_TEMPLATE
(
BM_Contended
absl
:
:
Mutex
)
-
>
UseRealTime
(
)
-
>
Threads
(
1
)
-
>
Threads
(
2
)
-
>
Threads
(
4
)
-
>
Threads
(
6
)
-
>
Threads
(
8
)
-
>
Threads
(
12
)
-
>
Threads
(
16
)
-
>
Threads
(
24
)
-
>
Threads
(
32
)
-
>
Threads
(
48
)
-
>
Threads
(
64
)
-
>
Threads
(
96
)
-
>
Threads
(
128
)
-
>
Threads
(
192
)
-
>
Threads
(
256
)
-
>
Arg
(
1
)
-
>
Arg
(
20
)
-
>
Arg
(
50
)
-
>
Arg
(
200
)
;
BENCHMARK_TEMPLATE
(
BM_Contended
absl
:
:
base_internal
:
:
SpinLock
)
-
>
UseRealTime
(
)
-
>
Threads
(
1
)
-
>
Threads
(
2
)
-
>
Threads
(
4
)
-
>
Threads
(
6
)
-
>
Threads
(
8
)
-
>
Threads
(
12
)
-
>
Threads
(
16
)
-
>
Threads
(
24
)
-
>
Threads
(
32
)
-
>
Threads
(
48
)
-
>
Threads
(
64
)
-
>
Threads
(
96
)
-
>
Threads
(
128
)
-
>
Threads
(
192
)
-
>
Threads
(
256
)
-
>
Arg
(
1
)
-
>
Arg
(
20
)
-
>
Arg
(
50
)
-
>
Arg
(
200
)
;
BENCHMARK_TEMPLATE
(
BM_Contended
std
:
:
mutex
)
-
>
UseRealTime
(
)
-
>
Threads
(
1
)
-
>
Threads
(
2
)
-
>
Threads
(
4
)
-
>
Threads
(
6
)
-
>
Threads
(
8
)
-
>
Threads
(
12
)
-
>
Threads
(
16
)
-
>
Threads
(
24
)
-
>
Threads
(
32
)
-
>
Threads
(
48
)
-
>
Threads
(
64
)
-
>
Threads
(
96
)
-
>
Threads
(
128
)
-
>
Threads
(
192
)
-
>
Threads
(
256
)
-
>
Arg
(
1
)
-
>
Arg
(
20
)
-
>
Arg
(
50
)
-
>
Arg
(
200
)
;
void
BM_ConditionWaiters
(
benchmark
:
:
State
&
state
)
{
int
num_classes
=
state
.
range
(
0
)
;
int
num_waiters
=
state
.
range
(
1
)
;
struct
Helper
{
static
void
Waiter
(
absl
:
:
BlockingCounter
*
init
absl
:
:
Mutex
*
m
int
*
p
)
{
init
-
>
DecrementCount
(
)
;
m
-
>
LockWhen
(
absl
:
:
Condition
(
static_cast
<
bool
(
*
)
(
int
*
)
>
(
[
]
(
int
*
v
)
{
return
*
v
=
=
0
;
}
)
p
)
)
;
m
-
>
Unlock
(
)
;
}
}
;
if
(
num_classes
=
=
0
)
{
num_classes
=
num_waiters
;
}
absl
:
:
BlockingCounter
init
(
num_waiters
)
;
absl
:
:
Mutex
mu
;
std
:
:
vector
<
int
>
equivalence_classes
(
num_classes
1
)
;
absl
:
:
synchronization_internal
:
:
ThreadPool
pool
(
num_waiters
)
;
for
(
int
i
=
0
;
i
<
num_waiters
;
i
+
+
)
{
pool
.
Schedule
(
[
&
i
]
{
Helper
:
:
Waiter
(
&
init
&
mu
&
equivalence_classes
[
i
%
num_classes
]
)
;
}
)
;
}
init
.
Wait
(
)
;
for
(
auto
_
:
state
)
{
mu
.
Lock
(
)
;
mu
.
Unlock
(
)
;
}
mu
.
Lock
(
)
;
for
(
int
i
=
0
;
i
<
num_classes
;
i
+
+
)
{
equivalence_classes
[
i
]
=
0
;
}
mu
.
Unlock
(
)
;
}
#
if
defined
(
__linux__
)
&
&
!
defined
(
ABSL_HAVE_THREAD_SANITIZER
)
constexpr
int
kMaxConditionWaiters
=
8192
;
#
else
constexpr
int
kMaxConditionWaiters
=
1024
;
#
endif
BENCHMARK
(
BM_ConditionWaiters
)
-
>
RangePair
(
0
2
1
kMaxConditionWaiters
)
;
}
