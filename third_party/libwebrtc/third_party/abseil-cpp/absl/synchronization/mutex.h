#
ifndef
ABSL_SYNCHRONIZATION_MUTEX_H_
#
define
ABSL_SYNCHRONIZATION_MUTEX_H_
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
"
absl
/
base
/
const_init
.
h
"
#
include
"
absl
/
base
/
internal
/
identity
.
h
"
#
include
"
absl
/
base
/
internal
/
low_level_alloc
.
h
"
#
include
"
absl
/
base
/
internal
/
thread_identity
.
h
"
#
include
"
absl
/
base
/
internal
/
tsan_mutex_interface
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
base
/
thread_annotations
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
kernel_timeout
.
h
"
#
include
"
absl
/
synchronization
/
internal
/
per_thread_sem
.
h
"
#
include
"
absl
/
time
/
time
.
h
"
#
ifdef
ABSL_INTERNAL_USE_NONPROD_MUTEX
#
error
ABSL_INTERNAL_USE_NONPROD_MUTEX
cannot
be
directly
set
#
elif
defined
(
ABSL_LOW_LEVEL_ALLOC_MISSING
)
#
define
ABSL_INTERNAL_USE_NONPROD_MUTEX
1
#
include
"
absl
/
synchronization
/
internal
/
mutex_nonprod
.
inc
"
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
Condition
;
struct
SynchWaitParams
;
class
ABSL_LOCKABLE
Mutex
{
public
:
Mutex
(
)
;
explicit
constexpr
Mutex
(
absl
:
:
ConstInitType
)
;
~
Mutex
(
)
;
void
Lock
(
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
;
void
Unlock
(
)
ABSL_UNLOCK_FUNCTION
(
)
;
bool
TryLock
(
)
ABSL_EXCLUSIVE_TRYLOCK_FUNCTION
(
true
)
;
void
AssertHeld
(
)
const
ABSL_ASSERT_EXCLUSIVE_LOCK
(
)
;
void
ReaderLock
(
)
ABSL_SHARED_LOCK_FUNCTION
(
)
;
void
ReaderUnlock
(
)
ABSL_UNLOCK_FUNCTION
(
)
;
bool
ReaderTryLock
(
)
ABSL_SHARED_TRYLOCK_FUNCTION
(
true
)
;
void
AssertReaderHeld
(
)
const
ABSL_ASSERT_SHARED_LOCK
(
)
;
void
WriterLock
(
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
{
this
-
>
Lock
(
)
;
}
void
WriterUnlock
(
)
ABSL_UNLOCK_FUNCTION
(
)
{
this
-
>
Unlock
(
)
;
}
bool
WriterTryLock
(
)
ABSL_EXCLUSIVE_TRYLOCK_FUNCTION
(
true
)
{
return
this
-
>
TryLock
(
)
;
}
void
Await
(
const
Condition
&
cond
)
;
void
LockWhen
(
const
Condition
&
cond
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
;
void
ReaderLockWhen
(
const
Condition
&
cond
)
ABSL_SHARED_LOCK_FUNCTION
(
)
;
void
WriterLockWhen
(
const
Condition
&
cond
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
{
this
-
>
LockWhen
(
cond
)
;
}
bool
AwaitWithTimeout
(
const
Condition
&
cond
absl
:
:
Duration
timeout
)
;
bool
AwaitWithDeadline
(
const
Condition
&
cond
absl
:
:
Time
deadline
)
;
bool
LockWhenWithTimeout
(
const
Condition
&
cond
absl
:
:
Duration
timeout
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
;
bool
ReaderLockWhenWithTimeout
(
const
Condition
&
cond
absl
:
:
Duration
timeout
)
ABSL_SHARED_LOCK_FUNCTION
(
)
;
bool
WriterLockWhenWithTimeout
(
const
Condition
&
cond
absl
:
:
Duration
timeout
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
{
return
this
-
>
LockWhenWithTimeout
(
cond
timeout
)
;
}
bool
LockWhenWithDeadline
(
const
Condition
&
cond
absl
:
:
Time
deadline
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
;
bool
ReaderLockWhenWithDeadline
(
const
Condition
&
cond
absl
:
:
Time
deadline
)
ABSL_SHARED_LOCK_FUNCTION
(
)
;
bool
WriterLockWhenWithDeadline
(
const
Condition
&
cond
absl
:
:
Time
deadline
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
)
{
return
this
-
>
LockWhenWithDeadline
(
cond
deadline
)
;
}
void
EnableInvariantDebugging
(
void
(
*
invariant
)
(
void
*
)
void
*
arg
)
;
void
EnableDebugLog
(
const
char
*
name
)
;
void
ForgetDeadlockInfo
(
)
;
void
AssertNotHeld
(
)
const
;
typedef
const
struct
MuHowS
*
MuHow
;
static
void
InternalAttemptToUseMutexInFatalSignalHandler
(
)
;
private
:
#
ifdef
ABSL_INTERNAL_USE_NONPROD_MUTEX
friend
class
CondVar
;
synchronization_internal
:
:
MutexImpl
*
impl
(
)
{
return
impl_
.
get
(
)
;
}
synchronization_internal
:
:
SynchronizationStorage
<
synchronization_internal
:
:
MutexImpl
>
impl_
;
#
else
std
:
:
atomic
<
intptr_t
>
mu_
;
static
inline
void
IncrementSynchSem
(
Mutex
*
mu
base_internal
:
:
PerThreadSynch
*
w
)
;
static
inline
bool
DecrementSynchSem
(
Mutex
*
mu
base_internal
:
:
PerThreadSynch
*
w
synchronization_internal
:
:
KernelTimeout
t
)
;
void
LockSlowLoop
(
SynchWaitParams
*
waitp
int
flags
)
;
bool
LockSlowWithDeadline
(
MuHow
how
const
Condition
*
cond
synchronization_internal
:
:
KernelTimeout
t
int
flags
)
;
void
LockSlow
(
MuHow
how
const
Condition
*
cond
int
flags
)
ABSL_ATTRIBUTE_COLD
;
void
UnlockSlow
(
SynchWaitParams
*
waitp
)
ABSL_ATTRIBUTE_COLD
;
bool
AwaitCommon
(
const
Condition
&
cond
synchronization_internal
:
:
KernelTimeout
t
)
;
void
TryRemove
(
base_internal
:
:
PerThreadSynch
*
s
)
;
void
Block
(
base_internal
:
:
PerThreadSynch
*
s
)
;
base_internal
:
:
PerThreadSynch
*
Wakeup
(
base_internal
:
:
PerThreadSynch
*
w
)
;
friend
class
CondVar
;
void
Trans
(
MuHow
how
)
;
void
Fer
(
base_internal
:
:
PerThreadSynch
*
w
)
;
#
endif
Mutex
(
const
volatile
Mutex
*
)
{
}
Mutex
(
const
Mutex
&
)
=
delete
;
Mutex
&
operator
=
(
const
Mutex
&
)
=
delete
;
}
;
class
ABSL_SCOPED_LOCKABLE
MutexLock
{
public
:
explicit
MutexLock
(
Mutex
*
mu
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
mu
)
:
mu_
(
mu
)
{
this
-
>
mu_
-
>
Lock
(
)
;
}
MutexLock
(
const
MutexLock
&
)
=
delete
;
MutexLock
(
MutexLock
&
&
)
=
delete
;
MutexLock
&
operator
=
(
const
MutexLock
&
)
=
delete
;
MutexLock
&
operator
=
(
MutexLock
&
&
)
=
delete
;
~
MutexLock
(
)
ABSL_UNLOCK_FUNCTION
(
)
{
this
-
>
mu_
-
>
Unlock
(
)
;
}
private
:
Mutex
*
const
mu_
;
}
;
class
ABSL_SCOPED_LOCKABLE
ReaderMutexLock
{
public
:
explicit
ReaderMutexLock
(
Mutex
*
mu
)
ABSL_SHARED_LOCK_FUNCTION
(
mu
)
:
mu_
(
mu
)
{
mu
-
>
ReaderLock
(
)
;
}
ReaderMutexLock
(
const
ReaderMutexLock
&
)
=
delete
;
ReaderMutexLock
(
ReaderMutexLock
&
&
)
=
delete
;
ReaderMutexLock
&
operator
=
(
const
ReaderMutexLock
&
)
=
delete
;
ReaderMutexLock
&
operator
=
(
ReaderMutexLock
&
&
)
=
delete
;
~
ReaderMutexLock
(
)
ABSL_UNLOCK_FUNCTION
(
)
{
this
-
>
mu_
-
>
ReaderUnlock
(
)
;
}
private
:
Mutex
*
const
mu_
;
}
;
class
ABSL_SCOPED_LOCKABLE
WriterMutexLock
{
public
:
explicit
WriterMutexLock
(
Mutex
*
mu
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
mu
)
:
mu_
(
mu
)
{
mu
-
>
WriterLock
(
)
;
}
WriterMutexLock
(
const
WriterMutexLock
&
)
=
delete
;
WriterMutexLock
(
WriterMutexLock
&
&
)
=
delete
;
WriterMutexLock
&
operator
=
(
const
WriterMutexLock
&
)
=
delete
;
WriterMutexLock
&
operator
=
(
WriterMutexLock
&
&
)
=
delete
;
~
WriterMutexLock
(
)
ABSL_UNLOCK_FUNCTION
(
)
{
this
-
>
mu_
-
>
WriterUnlock
(
)
;
}
private
:
Mutex
*
const
mu_
;
}
;
class
Condition
{
public
:
Condition
(
bool
(
*
func
)
(
void
*
)
void
*
arg
)
;
template
<
typename
T
>
Condition
(
bool
(
*
func
)
(
T
*
)
T
*
arg
)
;
template
<
typename
T
>
Condition
(
T
*
object
bool
(
absl
:
:
internal
:
:
identity
<
T
>
:
:
type
:
:
*
method
)
(
)
)
;
template
<
typename
T
>
Condition
(
const
T
*
object
bool
(
absl
:
:
internal
:
:
identity
<
T
>
:
:
type
:
:
*
method
)
(
)
const
)
;
explicit
Condition
(
const
bool
*
cond
)
;
template
<
typename
T
typename
E
=
decltype
(
static_cast
<
bool
(
T
:
:
*
)
(
)
const
>
(
&
T
:
:
operator
(
)
)
)
>
explicit
Condition
(
const
T
*
obj
)
:
Condition
(
obj
static_cast
<
bool
(
T
:
:
*
)
(
)
const
>
(
&
T
:
:
operator
(
)
)
)
{
}
static
const
Condition
kTrue
;
bool
Eval
(
)
const
;
static
bool
GuaranteedEqual
(
const
Condition
*
a
const
Condition
*
b
)
;
private
:
typedef
bool
(
*
InternalFunctionType
)
(
void
*
arg
)
;
typedef
bool
(
Condition
:
:
*
InternalMethodType
)
(
)
;
typedef
bool
(
*
InternalMethodCallerType
)
(
void
*
arg
InternalMethodType
internal_method
)
;
bool
(
*
eval_
)
(
const
Condition
*
)
;
InternalFunctionType
function_
;
InternalMethodType
method_
;
void
*
arg_
;
Condition
(
)
;
static
bool
CallVoidPtrFunction
(
const
Condition
*
)
;
template
<
typename
T
>
static
bool
CastAndCallFunction
(
const
Condition
*
c
)
;
template
<
typename
T
>
static
bool
CastAndCallMethod
(
const
Condition
*
c
)
;
}
;
class
CondVar
{
public
:
CondVar
(
)
;
~
CondVar
(
)
;
void
Wait
(
Mutex
*
mu
)
;
bool
WaitWithTimeout
(
Mutex
*
mu
absl
:
:
Duration
timeout
)
;
bool
WaitWithDeadline
(
Mutex
*
mu
absl
:
:
Time
deadline
)
;
void
Signal
(
)
;
void
SignalAll
(
)
;
void
EnableDebugLog
(
const
char
*
name
)
;
private
:
#
ifdef
ABSL_INTERNAL_USE_NONPROD_MUTEX
synchronization_internal
:
:
CondVarImpl
*
impl
(
)
{
return
impl_
.
get
(
)
;
}
synchronization_internal
:
:
SynchronizationStorage
<
synchronization_internal
:
:
CondVarImpl
>
impl_
;
#
else
bool
WaitCommon
(
Mutex
*
mutex
synchronization_internal
:
:
KernelTimeout
t
)
;
void
Remove
(
base_internal
:
:
PerThreadSynch
*
s
)
;
void
Wakeup
(
base_internal
:
:
PerThreadSynch
*
w
)
;
std
:
:
atomic
<
intptr_t
>
cv_
;
#
endif
CondVar
(
const
CondVar
&
)
=
delete
;
CondVar
&
operator
=
(
const
CondVar
&
)
=
delete
;
}
;
class
ABSL_SCOPED_LOCKABLE
MutexLockMaybe
{
public
:
explicit
MutexLockMaybe
(
Mutex
*
mu
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
mu
)
:
mu_
(
mu
)
{
if
(
this
-
>
mu_
!
=
nullptr
)
{
this
-
>
mu_
-
>
Lock
(
)
;
}
}
~
MutexLockMaybe
(
)
ABSL_UNLOCK_FUNCTION
(
)
{
if
(
this
-
>
mu_
!
=
nullptr
)
{
this
-
>
mu_
-
>
Unlock
(
)
;
}
}
private
:
Mutex
*
const
mu_
;
MutexLockMaybe
(
const
MutexLockMaybe
&
)
=
delete
;
MutexLockMaybe
(
MutexLockMaybe
&
&
)
=
delete
;
MutexLockMaybe
&
operator
=
(
const
MutexLockMaybe
&
)
=
delete
;
MutexLockMaybe
&
operator
=
(
MutexLockMaybe
&
&
)
=
delete
;
}
;
class
ABSL_SCOPED_LOCKABLE
ReleasableMutexLock
{
public
:
explicit
ReleasableMutexLock
(
Mutex
*
mu
)
ABSL_EXCLUSIVE_LOCK_FUNCTION
(
mu
)
:
mu_
(
mu
)
{
this
-
>
mu_
-
>
Lock
(
)
;
}
~
ReleasableMutexLock
(
)
ABSL_UNLOCK_FUNCTION
(
)
{
if
(
this
-
>
mu_
!
=
nullptr
)
{
this
-
>
mu_
-
>
Unlock
(
)
;
}
}
void
Release
(
)
ABSL_UNLOCK_FUNCTION
(
)
;
private
:
Mutex
*
mu_
;
ReleasableMutexLock
(
const
ReleasableMutexLock
&
)
=
delete
;
ReleasableMutexLock
(
ReleasableMutexLock
&
&
)
=
delete
;
ReleasableMutexLock
&
operator
=
(
const
ReleasableMutexLock
&
)
=
delete
;
ReleasableMutexLock
&
operator
=
(
ReleasableMutexLock
&
&
)
=
delete
;
}
;
#
ifdef
ABSL_INTERNAL_USE_NONPROD_MUTEX
inline
constexpr
Mutex
:
:
Mutex
(
absl
:
:
ConstInitType
)
:
impl_
(
absl
:
:
kConstInit
)
{
}
#
else
inline
Mutex
:
:
Mutex
(
)
:
mu_
(
0
)
{
ABSL_TSAN_MUTEX_CREATE
(
this
__tsan_mutex_not_static
)
;
}
inline
constexpr
Mutex
:
:
Mutex
(
absl
:
:
ConstInitType
)
:
mu_
(
0
)
{
}
inline
CondVar
:
:
CondVar
(
)
:
cv_
(
0
)
{
}
#
endif
template
<
typename
T
>
bool
Condition
:
:
CastAndCallMethod
(
const
Condition
*
c
)
{
typedef
bool
(
T
:
:
*
MemberType
)
(
)
;
MemberType
rm
=
reinterpret_cast
<
MemberType
>
(
c
-
>
method_
)
;
T
*
x
=
static_cast
<
T
*
>
(
c
-
>
arg_
)
;
return
(
x
-
>
*
rm
)
(
)
;
}
template
<
typename
T
>
bool
Condition
:
:
CastAndCallFunction
(
const
Condition
*
c
)
{
typedef
bool
(
*
FuncType
)
(
T
*
)
;
FuncType
fn
=
reinterpret_cast
<
FuncType
>
(
c
-
>
function_
)
;
T
*
x
=
static_cast
<
T
*
>
(
c
-
>
arg_
)
;
return
(
*
fn
)
(
x
)
;
}
template
<
typename
T
>
inline
Condition
:
:
Condition
(
bool
(
*
func
)
(
T
*
)
T
*
arg
)
:
eval_
(
&
CastAndCallFunction
<
T
>
)
function_
(
reinterpret_cast
<
InternalFunctionType
>
(
func
)
)
method_
(
nullptr
)
arg_
(
const_cast
<
void
*
>
(
static_cast
<
const
void
*
>
(
arg
)
)
)
{
}
template
<
typename
T
>
inline
Condition
:
:
Condition
(
T
*
object
bool
(
absl
:
:
internal
:
:
identity
<
T
>
:
:
type
:
:
*
method
)
(
)
)
:
eval_
(
&
CastAndCallMethod
<
T
>
)
function_
(
nullptr
)
method_
(
reinterpret_cast
<
InternalMethodType
>
(
method
)
)
arg_
(
object
)
{
}
template
<
typename
T
>
inline
Condition
:
:
Condition
(
const
T
*
object
bool
(
absl
:
:
internal
:
:
identity
<
T
>
:
:
type
:
:
*
method
)
(
)
const
)
:
eval_
(
&
CastAndCallMethod
<
T
>
)
function_
(
nullptr
)
method_
(
reinterpret_cast
<
InternalMethodType
>
(
method
)
)
arg_
(
reinterpret_cast
<
void
*
>
(
const_cast
<
T
*
>
(
object
)
)
)
{
}
void
RegisterMutexProfiler
(
void
(
*
fn
)
(
int64_t
wait_timestamp
)
)
;
void
RegisterMutexTracer
(
void
(
*
fn
)
(
const
char
*
msg
const
void
*
obj
int64_t
wait_cycles
)
)
;
void
RegisterCondVarTracer
(
void
(
*
fn
)
(
const
char
*
msg
const
void
*
cv
)
)
;
ABSL_DEPRECATED
(
"
absl
:
:
RegisterSymbolizer
(
)
is
deprecated
and
will
be
removed
"
"
on
or
after
2023
-
05
-
01
"
)
void
RegisterSymbolizer
(
bool
(
*
fn
)
(
const
void
*
pc
char
*
out
int
out_size
)
)
;
void
EnableMutexInvariantDebugging
(
bool
enabled
)
;
enum
class
OnDeadlockCycle
{
kIgnore
kReport
kAbort
}
;
void
SetMutexDeadlockDetectionMode
(
OnDeadlockCycle
mode
)
;
ABSL_NAMESPACE_END
}
extern
"
C
"
{
void
AbslInternalMutexYield
(
)
;
}
#
endif
