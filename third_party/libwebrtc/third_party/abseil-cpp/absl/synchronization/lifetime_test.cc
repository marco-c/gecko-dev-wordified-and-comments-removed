#
include
<
cstdlib
>
#
include
<
thread
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
const_init
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
thread_annotations
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
#
include
"
absl
/
synchronization
/
notification
.
h
"
namespace
{
void
ThreadOne
(
absl
:
:
Mutex
*
mutex
absl
:
:
CondVar
*
condvar
absl
:
:
Notification
*
notification
bool
*
state
)
{
ABSL_RAW_CHECK
(
!
notification
-
>
HasBeenNotified
(
)
"
invalid
Notification
"
)
;
ABSL_RAW_CHECK
(
*
state
=
=
false
"
*
state
not
initialized
"
)
;
{
absl
:
:
MutexLock
lock
(
mutex
)
;
notification
-
>
Notify
(
)
;
ABSL_RAW_CHECK
(
notification
-
>
HasBeenNotified
(
)
"
invalid
Notification
"
)
;
while
(
*
state
=
=
false
)
{
condvar
-
>
Wait
(
mutex
)
;
}
}
}
void
ThreadTwo
(
absl
:
:
Mutex
*
mutex
absl
:
:
CondVar
*
condvar
absl
:
:
Notification
*
notification
bool
*
state
)
{
ABSL_RAW_CHECK
(
*
state
=
=
false
"
*
state
not
initialized
"
)
;
notification
-
>
WaitForNotification
(
)
;
ABSL_RAW_CHECK
(
notification
-
>
HasBeenNotified
(
)
"
invalid
Notification
"
)
;
{
absl
:
:
MutexLock
lock
(
mutex
)
;
*
state
=
true
;
condvar
-
>
Signal
(
)
;
}
}
void
RunTests
(
absl
:
:
Mutex
*
mutex
absl
:
:
CondVar
*
condvar
)
{
absl
:
:
Mutex
default_mutex
;
absl
:
:
CondVar
default_condvar
;
absl
:
:
Notification
notification
;
if
(
!
mutex
)
{
mutex
=
&
default_mutex
;
}
if
(
!
condvar
)
{
condvar
=
&
default_condvar
;
}
bool
state
=
false
;
std
:
:
thread
thread_one
(
ThreadOne
mutex
condvar
&
notification
&
state
)
;
std
:
:
thread
thread_two
(
ThreadTwo
mutex
condvar
&
notification
&
state
)
;
thread_one
.
join
(
)
;
thread_two
.
join
(
)
;
}
void
TestLocals
(
)
{
absl
:
:
Mutex
mutex
;
absl
:
:
CondVar
condvar
;
RunTests
(
&
mutex
&
condvar
)
;
}
ABSL_CONST_INIT
absl
:
:
Mutex
const_init_mutex
(
absl
:
:
kConstInit
)
;
void
TestConstInitGlobal
(
)
{
RunTests
(
&
const_init_mutex
nullptr
)
;
}
using
Function
=
void
(
*
)
(
)
;
class
OnConstruction
{
public
:
explicit
OnConstruction
(
Function
fn
)
{
fn
(
)
;
}
}
;
class
OnDestruction
{
public
:
explicit
OnDestruction
(
Function
fn
)
:
fn_
(
fn
)
{
}
~
OnDestruction
(
)
{
fn_
(
)
;
}
private
:
Function
fn_
;
}
;
#
if
defined
(
__clang__
)
|
|
!
(
defined
(
_MSC_VER
)
&
&
_MSC_VER
>
1900
)
extern
absl
:
:
Mutex
early_const_init_mutex
;
OnConstruction
test_early_const_init
(
[
]
{
RunTests
(
&
early_const_init_mutex
nullptr
)
;
}
)
;
ABSL_CONST_INIT
absl
:
:
Mutex
early_const_init_mutex
(
absl
:
:
kConstInit
)
;
extern
absl
:
:
Mutex
const_init_sanity_mutex
;
OnConstruction
grab_lock
(
[
]
(
)
ABSL_NO_THREAD_SAFETY_ANALYSIS
{
const_init_sanity_mutex
.
Lock
(
)
;
}
)
;
ABSL_CONST_INIT
absl
:
:
Mutex
const_init_sanity_mutex
(
absl
:
:
kConstInit
)
;
OnConstruction
check_still_locked
(
[
]
(
)
ABSL_NO_THREAD_SAFETY_ANALYSIS
{
const_init_sanity_mutex
.
AssertHeld
(
)
;
const_init_sanity_mutex
.
Unlock
(
)
;
}
)
;
#
endif
extern
absl
:
:
Mutex
late_const_init_mutex
;
OnDestruction
test_late_const_init
(
[
]
{
RunTests
(
&
late_const_init_mutex
nullptr
)
;
}
)
;
ABSL_CONST_INIT
absl
:
:
Mutex
late_const_init_mutex
(
absl
:
:
kConstInit
)
;
}
int
main
(
)
{
TestLocals
(
)
;
TestConstInitGlobal
(
)
;
std
:
:
exit
(
0
)
;
}
