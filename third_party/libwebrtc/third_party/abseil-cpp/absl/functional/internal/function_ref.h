#
ifndef
ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
#
define
ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
#
include
<
cassert
>
#
include
<
functional
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
internal
/
invoke
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
functional_internal
{
union
VoidPtr
{
const
void
*
obj
;
void
(
*
fun
)
(
)
;
}
;
template
<
typename
T
>
constexpr
bool
PassByValue
(
)
{
return
!
std
:
:
is_lvalue_reference
<
T
>
:
:
value
&
&
absl
:
:
is_trivially_copy_constructible
<
T
>
:
:
value
&
&
absl
:
:
is_trivially_copy_assignable
<
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
:
:
value
&
&
std
:
:
is_trivially_destructible
<
T
>
:
:
value
&
&
sizeof
(
T
)
<
=
2
*
sizeof
(
void
*
)
;
}
template
<
typename
T
>
struct
ForwardT
:
std
:
:
conditional
<
PassByValue
<
T
>
(
)
T
T
&
&
>
{
}
;
template
<
typename
R
typename
.
.
.
Args
>
using
Invoker
=
R
(
*
)
(
VoidPtr
typename
ForwardT
<
Args
>
:
:
type
.
.
.
)
;
template
<
typename
Obj
typename
R
typename
.
.
.
Args
>
R
InvokeObject
(
VoidPtr
ptr
typename
ForwardT
<
Args
>
:
:
type
.
.
.
args
)
{
auto
o
=
static_cast
<
const
Obj
*
>
(
ptr
.
obj
)
;
return
static_cast
<
R
>
(
absl
:
:
base_internal
:
:
invoke
(
*
o
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
Fun
typename
R
typename
.
.
.
Args
>
R
InvokeFunction
(
VoidPtr
ptr
typename
ForwardT
<
Args
>
:
:
type
.
.
.
args
)
{
auto
f
=
reinterpret_cast
<
Fun
>
(
ptr
.
fun
)
;
return
static_cast
<
R
>
(
absl
:
:
base_internal
:
:
invoke
(
f
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
Sig
>
void
AssertNonNull
(
const
std
:
:
function
<
Sig
>
&
f
)
{
assert
(
f
!
=
nullptr
)
;
(
void
)
f
;
}
template
<
typename
F
>
void
AssertNonNull
(
const
F
&
)
{
}
template
<
typename
F
typename
C
>
void
AssertNonNull
(
F
C
:
:
*
f
)
{
assert
(
f
!
=
nullptr
)
;
(
void
)
f
;
}
template
<
bool
C
>
using
EnableIf
=
typename
:
:
std
:
:
enable_if
<
C
int
>
:
:
type
;
}
ABSL_NAMESPACE_END
}
#
endif
