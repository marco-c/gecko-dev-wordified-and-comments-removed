#
ifndef
ABSL_META_TYPE_TRAITS_H_
#
define
ABSL_META_TYPE_TRAITS_H_
#
include
<
cstddef
>
#
include
<
functional
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
!
defined
(
__GNUC__
)
#
define
ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION
1
#
endif
#
if
defined
(
__STDCPP_DEFAULT_NEW_ALIGNMENT__
)
#
define
ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT
__STDCPP_DEFAULT_NEW_ALIGNMENT__
#
else
#
define
ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT
alignof
(
std
:
:
max_align_t
)
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
T
>
struct
is_trivially_destructible
;
template
<
typename
T
>
struct
is_trivially_move_assignable
;
namespace
type_traits_internal
{
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__GNUC__
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4624
)
#
endif
template
<
class
T
>
union
SingleMemberUnion
{
T
t
;
}
;
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__GNUC__
)
#
pragma
warning
(
pop
)
#
endif
template
<
class
T
>
struct
IsTriviallyMoveConstructibleObject
:
std
:
:
integral_constant
<
bool
std
:
:
is_move_constructible
<
type_traits_internal
:
:
SingleMemberUnion
<
T
>
>
:
:
value
&
&
absl
:
:
is_trivially_destructible
<
T
>
:
:
value
>
{
}
;
template
<
class
T
>
struct
IsTriviallyCopyConstructibleObject
:
std
:
:
integral_constant
<
bool
std
:
:
is_copy_constructible
<
type_traits_internal
:
:
SingleMemberUnion
<
T
>
>
:
:
value
&
&
absl
:
:
is_trivially_destructible
<
T
>
:
:
value
>
{
}
;
template
<
class
T
>
struct
IsTriviallyMoveAssignableReference
:
std
:
:
false_type
{
}
;
template
<
class
T
>
struct
IsTriviallyMoveAssignableReference
<
T
&
>
:
absl
:
:
is_trivially_move_assignable
<
T
>
:
:
type
{
}
;
template
<
class
T
>
struct
IsTriviallyMoveAssignableReference
<
T
&
&
>
:
absl
:
:
is_trivially_move_assignable
<
T
>
:
:
type
{
}
;
template
<
typename
.
.
.
Ts
>
struct
VoidTImpl
{
using
type
=
void
;
}
;
template
<
size_t
Len
typename
T
=
std
:
:
aligned_storage
<
Len
>
>
struct
default_alignment_of_aligned_storage
;
template
<
size_t
Len
size_t
Align
>
struct
default_alignment_of_aligned_storage
<
Len
std
:
:
aligned_storage
<
Len
Align
>
>
{
static
constexpr
size_t
value
=
Align
;
}
;
template
<
class
Enabler
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_impl
{
using
type
=
std
:
:
false_type
;
}
;
template
<
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_impl
<
typename
VoidTImpl
<
Op
<
Args
.
.
.
>
>
:
:
type
Op
Args
.
.
.
>
{
using
type
=
std
:
:
true_type
;
}
;
template
<
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected
:
is_detected_impl
<
void
Op
Args
.
.
.
>
:
:
type
{
}
;
template
<
class
Enabler
class
To
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_convertible_impl
{
using
type
=
std
:
:
false_type
;
}
;
template
<
class
To
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_convertible_impl
<
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
Op
<
Args
.
.
.
>
To
>
:
:
value
>
:
:
type
To
Op
Args
.
.
.
>
{
using
type
=
std
:
:
true_type
;
}
;
template
<
class
To
template
<
class
.
.
.
>
class
Op
class
.
.
.
Args
>
struct
is_detected_convertible
:
is_detected_convertible_impl
<
void
To
Op
Args
.
.
.
>
:
:
type
{
}
;
template
<
typename
T
>
using
IsCopyAssignableImpl
=
decltype
(
std
:
:
declval
<
T
&
>
(
)
=
std
:
:
declval
<
const
T
&
>
(
)
)
;
template
<
typename
T
>
using
IsMoveAssignableImpl
=
decltype
(
std
:
:
declval
<
T
&
>
(
)
=
std
:
:
declval
<
T
&
&
>
(
)
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
(
_MSC_VER
>
=
1920
)
template
<
typename
T
>
using
is_copy_assignable
=
std
:
:
is_copy_assignable
<
T
>
;
template
<
typename
T
>
using
is_move_assignable
=
std
:
:
is_move_assignable
<
T
>
;
#
else
template
<
typename
T
>
struct
is_copy_assignable
:
type_traits_internal
:
:
is_detected
<
type_traits_internal
:
:
IsCopyAssignableImpl
T
>
{
}
;
template
<
typename
T
>
struct
is_move_assignable
:
type_traits_internal
:
:
is_detected
<
type_traits_internal
:
:
IsMoveAssignableImpl
T
>
{
}
;
#
endif
template
<
typename
.
.
.
Ts
>
using
void_t
=
typename
type_traits_internal
:
:
VoidTImpl
<
Ts
.
.
.
>
:
:
type
;
template
<
typename
.
.
.
Ts
>
struct
conjunction
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
.
.
.
Ts
>
struct
conjunction
<
T
Ts
.
.
.
>
:
std
:
:
conditional
<
T
:
:
value
conjunction
<
Ts
.
.
.
>
T
>
:
:
type
{
}
;
template
<
typename
T
>
struct
conjunction
<
T
>
:
T
{
}
;
template
<
typename
.
.
.
Ts
>
struct
disjunction
:
std
:
:
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Ts
>
struct
disjunction
<
T
Ts
.
.
.
>
:
std
:
:
conditional
<
T
:
:
value
T
disjunction
<
Ts
.
.
.
>
>
:
:
type
{
}
;
template
<
typename
T
>
struct
disjunction
<
T
>
:
T
{
}
;
template
<
typename
T
>
struct
negation
:
std
:
:
integral_constant
<
bool
!
T
:
:
value
>
{
}
;
template
<
typename
T
>
struct
is_function
:
std
:
:
integral_constant
<
bool
!
(
std
:
:
is_reference
<
T
>
:
:
value
|
|
std
:
:
is_const
<
typename
std
:
:
add_const
<
T
>
:
:
type
>
:
:
value
)
>
{
}
;
template
<
typename
T
>
struct
is_trivially_destructible
#
ifdef
ABSL_HAVE_STD_IS_TRIVIALLY_DESTRUCTIBLE
:
std
:
:
is_trivially_destructible
<
T
>
{
#
else
:
std
:
:
integral_constant
<
bool
__has_trivial_destructor
(
T
)
&
&
std
:
:
is_destructible
<
T
>
:
:
value
>
{
#
endif
#
ifdef
ABSL_HAVE_STD_IS_TRIVIALLY_DESTRUCTIBLE
private
:
static
constexpr
bool
compliant
=
std
:
:
is_trivially_destructible
<
T
>
:
:
value
=
=
is_trivially_destructible
:
:
value
;
static_assert
(
compliant
|
|
std
:
:
is_trivially_destructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_destructible
;
"
"
Standard
:
false
Implementation
:
true
"
)
;
static_assert
(
compliant
|
|
!
std
:
:
is_trivially_destructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_destructible
;
"
"
Standard
:
true
Implementation
:
false
"
)
;
#
endif
}
;
template
<
typename
T
>
struct
is_trivially_default_constructible
#
if
defined
(
ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
)
:
std
:
:
is_trivially_default_constructible
<
T
>
{
#
else
:
std
:
:
integral_constant
<
bool
__has_trivial_constructor
(
T
)
&
&
std
:
:
is_default_constructible
<
T
>
:
:
value
&
&
is_trivially_destructible
<
T
>
:
:
value
>
{
#
endif
#
if
defined
(
ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
)
&
&
\
!
defined
(
\
ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION
)
private
:
static
constexpr
bool
compliant
=
std
:
:
is_trivially_default_constructible
<
T
>
:
:
value
=
=
is_trivially_default_constructible
:
:
value
;
static_assert
(
compliant
|
|
std
:
:
is_trivially_default_constructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_default_constructible
;
"
"
Standard
:
false
Implementation
:
true
"
)
;
static_assert
(
compliant
|
|
!
std
:
:
is_trivially_default_constructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_default_constructible
;
"
"
Standard
:
true
Implementation
:
false
"
)
;
#
endif
}
;
template
<
typename
T
>
struct
is_trivially_move_constructible
#
if
defined
(
ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
)
:
std
:
:
is_trivially_move_constructible
<
T
>
{
#
else
:
std
:
:
conditional
<
std
:
:
is_object
<
T
>
:
:
value
&
&
!
std
:
:
is_array
<
T
>
:
:
value
type_traits_internal
:
:
IsTriviallyMoveConstructibleObject
<
T
>
std
:
:
is_reference
<
T
>
>
:
:
type
:
:
type
{
#
endif
#
if
defined
(
ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
)
&
&
\
!
defined
(
\
ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION
)
private
:
static
constexpr
bool
compliant
=
std
:
:
is_trivially_move_constructible
<
T
>
:
:
value
=
=
is_trivially_move_constructible
:
:
value
;
static_assert
(
compliant
|
|
std
:
:
is_trivially_move_constructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_move_constructible
;
"
"
Standard
:
false
Implementation
:
true
"
)
;
static_assert
(
compliant
|
|
!
std
:
:
is_trivially_move_constructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_move_constructible
;
"
"
Standard
:
true
Implementation
:
false
"
)
;
#
endif
}
;
template
<
typename
T
>
struct
is_trivially_copy_constructible
:
std
:
:
conditional
<
std
:
:
is_object
<
T
>
:
:
value
&
&
!
std
:
:
is_array
<
T
>
:
:
value
type_traits_internal
:
:
IsTriviallyCopyConstructibleObject
<
T
>
std
:
:
is_lvalue_reference
<
T
>
>
:
:
type
:
:
type
{
#
if
defined
(
ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
)
&
&
\
!
defined
(
\
ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION
)
private
:
static
constexpr
bool
compliant
=
std
:
:
is_trivially_copy_constructible
<
T
>
:
:
value
=
=
is_trivially_copy_constructible
:
:
value
;
static_assert
(
compliant
|
|
std
:
:
is_trivially_copy_constructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_copy_constructible
;
"
"
Standard
:
false
Implementation
:
true
"
)
;
static_assert
(
compliant
|
|
!
std
:
:
is_trivially_copy_constructible
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_copy_constructible
;
"
"
Standard
:
true
Implementation
:
false
"
)
;
#
endif
}
;
template
<
typename
T
>
struct
is_trivially_move_assignable
:
std
:
:
conditional
<
std
:
:
is_object
<
T
>
:
:
value
&
&
!
std
:
:
is_array
<
T
>
:
:
value
&
&
std
:
:
is_move_assignable
<
T
>
:
:
value
std
:
:
is_move_assignable
<
type_traits_internal
:
:
SingleMemberUnion
<
T
>
>
type_traits_internal
:
:
IsTriviallyMoveAssignableReference
<
T
>
>
:
:
type
:
:
type
{
#
ifdef
ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
private
:
static
constexpr
bool
compliant
=
std
:
:
is_trivially_move_assignable
<
T
>
:
:
value
=
=
is_trivially_move_assignable
:
:
value
;
static_assert
(
compliant
|
|
std
:
:
is_trivially_move_assignable
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_move_assignable
;
"
"
Standard
:
false
Implementation
:
true
"
)
;
static_assert
(
compliant
|
|
!
std
:
:
is_trivially_move_assignable
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_move_assignable
;
"
"
Standard
:
true
Implementation
:
false
"
)
;
#
endif
}
;
template
<
typename
T
>
struct
is_trivially_copy_assignable
#
ifdef
ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
:
std
:
:
is_trivially_copy_assignable
<
T
>
{
#
else
:
std
:
:
integral_constant
<
bool
__has_trivial_assign
(
typename
std
:
:
remove_reference
<
T
>
:
:
type
)
&
&
absl
:
:
is_copy_assignable
<
T
>
:
:
value
>
{
#
endif
#
ifdef
ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
private
:
static
constexpr
bool
compliant
=
std
:
:
is_trivially_copy_assignable
<
T
>
:
:
value
=
=
is_trivially_copy_assignable
:
:
value
;
static_assert
(
compliant
|
|
std
:
:
is_trivially_copy_assignable
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_copy_assignable
;
"
"
Standard
:
false
Implementation
:
true
"
)
;
static_assert
(
compliant
|
|
!
std
:
:
is_trivially_copy_assignable
<
T
>
:
:
value
"
Not
compliant
with
std
:
:
is_trivially_copy_assignable
;
"
"
Standard
:
true
Implementation
:
false
"
)
;
#
endif
}
;
#
if
defined
(
__cpp_lib_remove_cvref
)
&
&
__cpp_lib_remove_cvref
>
=
201711L
template
<
typename
T
>
using
remove_cvref
=
std
:
:
remove_cvref
<
T
>
;
template
<
typename
T
>
using
remove_cvref_t
=
typename
std
:
:
remove_cvref
<
T
>
:
:
type
;
#
else
template
<
typename
T
>
struct
remove_cvref
{
using
type
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
;
}
;
template
<
typename
T
>
using
remove_cvref_t
=
typename
remove_cvref
<
T
>
:
:
type
;
#
endif
namespace
type_traits_internal
{
#
if
defined
(
ABSL_HAVE_STD_IS_TRIVIALLY_COPYABLE
)
template
<
typename
T
>
struct
is_trivially_copyable
:
std
:
:
is_trivially_copyable
<
T
>
{
}
;
#
else
template
<
typename
T
>
class
is_trivially_copyable_impl
{
using
ExtentsRemoved
=
typename
std
:
:
remove_all_extents
<
T
>
:
:
type
;
static
constexpr
bool
kIsCopyOrMoveConstructible
=
std
:
:
is_copy_constructible
<
ExtentsRemoved
>
:
:
value
|
|
std
:
:
is_move_constructible
<
ExtentsRemoved
>
:
:
value
;
static
constexpr
bool
kIsCopyOrMoveAssignable
=
absl
:
:
is_copy_assignable
<
ExtentsRemoved
>
:
:
value
|
|
absl
:
:
is_move_assignable
<
ExtentsRemoved
>
:
:
value
;
public
:
static
constexpr
bool
kValue
=
(
__has_trivial_copy
(
ExtentsRemoved
)
|
|
!
kIsCopyOrMoveConstructible
)
&
&
(
__has_trivial_assign
(
ExtentsRemoved
)
|
|
!
kIsCopyOrMoveAssignable
)
&
&
(
kIsCopyOrMoveConstructible
|
|
kIsCopyOrMoveAssignable
)
&
&
is_trivially_destructible
<
ExtentsRemoved
>
:
:
value
&
&
!
std
:
:
is_reference
<
ExtentsRemoved
>
:
:
value
;
}
;
template
<
typename
T
>
struct
is_trivially_copyable
:
std
:
:
integral_constant
<
bool
type_traits_internal
:
:
is_trivially_copyable_impl
<
T
>
:
:
kValue
>
{
}
;
#
endif
}
template
<
typename
T
>
using
remove_cv_t
=
typename
std
:
:
remove_cv
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_const_t
=
typename
std
:
:
remove_const
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_volatile_t
=
typename
std
:
:
remove_volatile
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_cv_t
=
typename
std
:
:
add_cv
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_const_t
=
typename
std
:
:
add_const
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_volatile_t
=
typename
std
:
:
add_volatile
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_reference_t
=
typename
std
:
:
remove_reference
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_lvalue_reference_t
=
typename
std
:
:
add_lvalue_reference
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_rvalue_reference_t
=
typename
std
:
:
add_rvalue_reference
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_pointer_t
=
typename
std
:
:
remove_pointer
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_pointer_t
=
typename
std
:
:
add_pointer
<
T
>
:
:
type
;
template
<
typename
T
>
using
make_signed_t
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
template
<
typename
T
>
using
make_unsigned_t
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_extent_t
=
typename
std
:
:
remove_extent
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_all_extents_t
=
typename
std
:
:
remove_all_extents
<
T
>
:
:
type
;
template
<
size_t
Len
size_t
Align
=
type_traits_internal
:
:
default_alignment_of_aligned_storage
<
Len
>
:
:
value
>
using
aligned_storage_t
=
typename
std
:
:
aligned_storage
<
Len
Align
>
:
:
type
;
template
<
typename
T
>
using
decay_t
=
typename
std
:
:
decay
<
T
>
:
:
type
;
template
<
bool
B
typename
T
=
void
>
using
enable_if_t
=
typename
std
:
:
enable_if
<
B
T
>
:
:
type
;
template
<
bool
B
typename
T
typename
F
>
using
conditional_t
=
typename
std
:
:
conditional
<
B
T
F
>
:
:
type
;
template
<
typename
.
.
.
T
>
using
common_type_t
=
typename
std
:
:
common_type
<
T
.
.
.
>
:
:
type
;
template
<
typename
T
>
using
underlying_type_t
=
typename
std
:
:
underlying_type
<
T
>
:
:
type
;
namespace
type_traits_internal
{
#
if
(
defined
(
__cpp_lib_is_invocable
)
&
&
__cpp_lib_is_invocable
>
=
201703L
)
|
|
\
(
defined
(
_MSVC_LANG
)
&
&
_MSVC_LANG
>
=
201703L
)
template
<
typename
>
struct
result_of
;
template
<
typename
F
typename
.
.
.
Args
>
struct
result_of
<
F
(
Args
.
.
.
)
>
:
std
:
:
invoke_result
<
F
Args
.
.
.
>
{
}
;
#
else
template
<
typename
F
>
using
result_of
=
std
:
:
result_of
<
F
>
;
#
endif
}
template
<
typename
F
>
using
result_of_t
=
typename
type_traits_internal
:
:
result_of
<
F
>
:
:
type
;
namespace
type_traits_internal
{
#
if
defined
(
_MSC_VER
)
|
|
(
defined
(
_LIBCPP_VERSION
)
&
&
\
_LIBCPP_VERSION
<
4000
&
&
_LIBCPP_STD_VER
>
11
)
#
define
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
0
#
else
#
define
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
1
#
endif
#
if
!
ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
template
<
typename
Key
typename
=
size_t
>
struct
IsHashable
:
std
:
:
true_type
{
}
;
#
else
template
<
typename
Key
typename
=
void
>
struct
IsHashable
:
std
:
:
false_type
{
}
;
template
<
typename
Key
>
struct
IsHashable
<
Key
absl
:
:
enable_if_t
<
std
:
:
is_convertible
<
decltype
(
std
:
:
declval
<
std
:
:
hash
<
Key
>
&
>
(
)
(
std
:
:
declval
<
Key
const
&
>
(
)
)
)
std
:
:
size_t
>
:
:
value
>
>
:
std
:
:
true_type
{
}
;
#
endif
struct
AssertHashEnabledHelper
{
private
:
static
void
Sink
(
.
.
.
)
{
}
struct
NAT
{
}
;
template
<
class
Key
>
static
auto
GetReturnType
(
int
)
-
>
decltype
(
std
:
:
declval
<
std
:
:
hash
<
Key
>
>
(
)
(
std
:
:
declval
<
Key
const
&
>
(
)
)
)
;
template
<
class
Key
>
static
NAT
GetReturnType
(
.
.
.
)
;
template
<
class
Key
>
static
std
:
:
nullptr_t
DoIt
(
)
{
static_assert
(
IsHashable
<
Key
>
:
:
value
"
std
:
:
hash
<
Key
>
does
not
provide
a
call
operator
"
)
;
static_assert
(
std
:
:
is_default_constructible
<
std
:
:
hash
<
Key
>
>
:
:
value
"
std
:
:
hash
<
Key
>
must
be
default
constructible
when
it
is
enabled
"
)
;
static_assert
(
std
:
:
is_copy_constructible
<
std
:
:
hash
<
Key
>
>
:
:
value
"
std
:
:
hash
<
Key
>
must
be
copy
constructible
when
it
is
enabled
"
)
;
static_assert
(
absl
:
:
is_copy_assignable
<
std
:
:
hash
<
Key
>
>
:
:
value
"
std
:
:
hash
<
Key
>
must
be
copy
assignable
when
it
is
enabled
"
)
;
using
ReturnType
=
decltype
(
GetReturnType
<
Key
>
(
0
)
)
;
static_assert
(
std
:
:
is_same
<
ReturnType
NAT
>
:
:
value
|
|
std
:
:
is_same
<
ReturnType
size_t
>
:
:
value
"
std
:
:
hash
<
Key
>
must
return
size_t
"
)
;
return
nullptr
;
}
template
<
class
.
.
.
Ts
>
friend
void
AssertHashEnabled
(
)
;
}
;
template
<
class
.
.
.
Ts
>
inline
void
AssertHashEnabled
(
)
{
using
Helper
=
AssertHashEnabledHelper
;
Helper
:
:
Sink
(
Helper
:
:
DoIt
<
Ts
>
(
)
.
.
.
)
;
}
}
namespace
swap_internal
{
using
std
:
:
swap
;
void
swap
(
)
;
template
<
class
T
>
using
IsSwappableImpl
=
decltype
(
swap
(
std
:
:
declval
<
T
&
>
(
)
std
:
:
declval
<
T
&
>
(
)
)
)
;
template
<
class
T
class
IsNoexcept
=
std
:
:
integral_constant
<
bool
noexcept
(
swap
(
std
:
:
declval
<
T
&
>
(
)
std
:
:
declval
<
T
&
>
(
)
)
)
>
>
using
IsNothrowSwappableImpl
=
typename
std
:
:
enable_if
<
IsNoexcept
:
:
value
>
:
:
type
;
template
<
class
T
>
struct
IsSwappable
:
absl
:
:
type_traits_internal
:
:
is_detected
<
IsSwappableImpl
T
>
{
}
;
template
<
class
T
>
struct
IsNothrowSwappable
:
absl
:
:
type_traits_internal
:
:
is_detected
<
IsNothrowSwappableImpl
T
>
{
}
;
template
<
class
T
absl
:
:
enable_if_t
<
IsSwappable
<
T
>
:
:
value
int
>
=
0
>
void
Swap
(
T
&
lhs
T
&
rhs
)
noexcept
(
IsNothrowSwappable
<
T
>
:
:
value
)
{
swap
(
lhs
rhs
)
;
}
using
StdSwapIsUnconstrained
=
IsSwappable
<
void
(
)
>
;
}
namespace
type_traits_internal
{
using
swap_internal
:
:
IsNothrowSwappable
;
using
swap_internal
:
:
IsSwappable
;
using
swap_internal
:
:
Swap
;
using
swap_internal
:
:
StdSwapIsUnconstrained
;
}
ABSL_NAMESPACE_END
}
#
endif
