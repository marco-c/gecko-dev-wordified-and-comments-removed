#
ifndef
ABSL_CONTAINER_INLINED_VECTOR_H_
#
define
ABSL_CONTAINER_INLINED_VECTOR_H_
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
algorithm
.
h
"
#
include
"
absl
/
base
/
internal
/
throw_delegate
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
container
/
internal
/
inlined_vector
.
h
"
#
include
"
absl
/
memory
/
memory
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
T
size_t
N
typename
A
=
std
:
:
allocator
<
T
>
>
class
InlinedVector
{
static_assert
(
N
>
0
"
absl
:
:
InlinedVector
requires
an
inlined
capacity
.
"
)
;
using
Storage
=
inlined_vector_internal
:
:
Storage
<
T
N
A
>
;
using
AllocatorTraits
=
typename
Storage
:
:
AllocatorTraits
;
using
RValueReference
=
typename
Storage
:
:
RValueReference
;
using
MoveIterator
=
typename
Storage
:
:
MoveIterator
;
using
IsMemcpyOk
=
typename
Storage
:
:
IsMemcpyOk
;
template
<
typename
Iterator
>
using
IteratorValueAdapter
=
typename
Storage
:
:
template
IteratorValueAdapter
<
Iterator
>
;
using
CopyValueAdapter
=
typename
Storage
:
:
CopyValueAdapter
;
using
DefaultValueAdapter
=
typename
Storage
:
:
DefaultValueAdapter
;
template
<
typename
Iterator
>
using
EnableIfAtLeastForwardIterator
=
absl
:
:
enable_if_t
<
inlined_vector_internal
:
:
IsAtLeastForwardIterator
<
Iterator
>
:
:
value
>
;
template
<
typename
Iterator
>
using
DisableIfAtLeastForwardIterator
=
absl
:
:
enable_if_t
<
!
inlined_vector_internal
:
:
IsAtLeastForwardIterator
<
Iterator
>
:
:
value
>
;
public
:
using
allocator_type
=
typename
Storage
:
:
allocator_type
;
using
value_type
=
typename
Storage
:
:
value_type
;
using
pointer
=
typename
Storage
:
:
pointer
;
using
const_pointer
=
typename
Storage
:
:
const_pointer
;
using
size_type
=
typename
Storage
:
:
size_type
;
using
difference_type
=
typename
Storage
:
:
difference_type
;
using
reference
=
typename
Storage
:
:
reference
;
using
const_reference
=
typename
Storage
:
:
const_reference
;
using
iterator
=
typename
Storage
:
:
iterator
;
using
const_iterator
=
typename
Storage
:
:
const_iterator
;
using
reverse_iterator
=
typename
Storage
:
:
reverse_iterator
;
using
const_reverse_iterator
=
typename
Storage
:
:
const_reverse_iterator
;
InlinedVector
(
)
noexcept
(
noexcept
(
allocator_type
(
)
)
)
:
storage_
(
)
{
}
explicit
InlinedVector
(
const
allocator_type
&
alloc
)
noexcept
:
storage_
(
alloc
)
{
}
explicit
InlinedVector
(
size_type
n
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
storage_
(
alloc
)
{
storage_
.
Initialize
(
DefaultValueAdapter
(
)
n
)
;
}
InlinedVector
(
size_type
n
const_reference
v
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
storage_
(
alloc
)
{
storage_
.
Initialize
(
CopyValueAdapter
(
v
)
n
)
;
}
InlinedVector
(
std
:
:
initializer_list
<
value_type
>
list
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
InlinedVector
(
list
.
begin
(
)
list
.
end
(
)
alloc
)
{
}
template
<
typename
ForwardIterator
EnableIfAtLeastForwardIterator
<
ForwardIterator
>
*
=
nullptr
>
InlinedVector
(
ForwardIterator
first
ForwardIterator
last
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
storage_
(
alloc
)
{
storage_
.
Initialize
(
IteratorValueAdapter
<
ForwardIterator
>
(
first
)
std
:
:
distance
(
first
last
)
)
;
}
template
<
typename
InputIterator
DisableIfAtLeastForwardIterator
<
InputIterator
>
*
=
nullptr
>
InlinedVector
(
InputIterator
first
InputIterator
last
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
storage_
(
alloc
)
{
std
:
:
copy
(
first
last
std
:
:
back_inserter
(
*
this
)
)
;
}
InlinedVector
(
const
InlinedVector
&
other
)
:
InlinedVector
(
other
*
other
.
storage_
.
GetAllocPtr
(
)
)
{
}
InlinedVector
(
const
InlinedVector
&
other
const
allocator_type
&
alloc
)
:
storage_
(
alloc
)
{
if
(
IsMemcpyOk
:
:
value
&
&
!
other
.
storage_
.
GetIsAllocated
(
)
)
{
storage_
.
MemcpyFrom
(
other
.
storage_
)
;
}
else
{
storage_
.
Initialize
(
IteratorValueAdapter
<
const_pointer
>
(
other
.
data
(
)
)
other
.
size
(
)
)
;
}
}
InlinedVector
(
InlinedVector
&
&
other
)
noexcept
(
absl
:
:
allocator_is_nothrow
<
allocator_type
>
:
:
value
|
|
std
:
:
is_nothrow_move_constructible
<
value_type
>
:
:
value
)
:
storage_
(
*
other
.
storage_
.
GetAllocPtr
(
)
)
{
if
(
IsMemcpyOk
:
:
value
)
{
storage_
.
MemcpyFrom
(
other
.
storage_
)
;
other
.
storage_
.
SetInlinedSize
(
0
)
;
}
else
if
(
other
.
storage_
.
GetIsAllocated
(
)
)
{
storage_
.
SetAllocatedData
(
other
.
storage_
.
GetAllocatedData
(
)
other
.
storage_
.
GetAllocatedCapacity
(
)
)
;
storage_
.
SetAllocatedSize
(
other
.
storage_
.
GetSize
(
)
)
;
other
.
storage_
.
SetInlinedSize
(
0
)
;
}
else
{
IteratorValueAdapter
<
MoveIterator
>
other_values
(
MoveIterator
(
other
.
storage_
.
GetInlinedData
(
)
)
)
;
inlined_vector_internal
:
:
ConstructElements
(
storage_
.
GetAllocPtr
(
)
storage_
.
GetInlinedData
(
)
&
other_values
other
.
storage_
.
GetSize
(
)
)
;
storage_
.
SetInlinedSize
(
other
.
storage_
.
GetSize
(
)
)
;
}
}
InlinedVector
(
InlinedVector
&
&
other
const
allocator_type
&
alloc
)
noexcept
(
absl
:
:
allocator_is_nothrow
<
allocator_type
>
:
:
value
)
:
storage_
(
alloc
)
{
if
(
IsMemcpyOk
:
:
value
)
{
storage_
.
MemcpyFrom
(
other
.
storage_
)
;
other
.
storage_
.
SetInlinedSize
(
0
)
;
}
else
if
(
(
*
storage_
.
GetAllocPtr
(
)
=
=
*
other
.
storage_
.
GetAllocPtr
(
)
)
&
&
other
.
storage_
.
GetIsAllocated
(
)
)
{
storage_
.
SetAllocatedData
(
other
.
storage_
.
GetAllocatedData
(
)
other
.
storage_
.
GetAllocatedCapacity
(
)
)
;
storage_
.
SetAllocatedSize
(
other
.
storage_
.
GetSize
(
)
)
;
other
.
storage_
.
SetInlinedSize
(
0
)
;
}
else
{
storage_
.
Initialize
(
IteratorValueAdapter
<
MoveIterator
>
(
MoveIterator
(
other
.
data
(
)
)
)
other
.
size
(
)
)
;
}
}
~
InlinedVector
(
)
{
}
bool
empty
(
)
const
noexcept
{
return
!
size
(
)
;
}
size_type
size
(
)
const
noexcept
{
return
storage_
.
GetSize
(
)
;
}
size_type
max_size
(
)
const
noexcept
{
return
(
std
:
:
numeric_limits
<
size_type
>
:
:
max
)
(
)
/
2
;
}
size_type
capacity
(
)
const
noexcept
{
return
storage_
.
GetIsAllocated
(
)
?
storage_
.
GetAllocatedCapacity
(
)
:
storage_
.
GetInlinedCapacity
(
)
;
}
pointer
data
(
)
noexcept
{
return
storage_
.
GetIsAllocated
(
)
?
storage_
.
GetAllocatedData
(
)
:
storage_
.
GetInlinedData
(
)
;
}
const_pointer
data
(
)
const
noexcept
{
return
storage_
.
GetIsAllocated
(
)
?
storage_
.
GetAllocatedData
(
)
:
storage_
.
GetInlinedData
(
)
;
}
reference
operator
[
]
(
size_type
i
)
{
ABSL_HARDENING_ASSERT
(
i
<
size
(
)
)
;
return
data
(
)
[
i
]
;
}
const_reference
operator
[
]
(
size_type
i
)
const
{
ABSL_HARDENING_ASSERT
(
i
<
size
(
)
)
;
return
data
(
)
[
i
]
;
}
reference
at
(
size_type
i
)
{
if
(
ABSL_PREDICT_FALSE
(
i
>
=
size
(
)
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
InlinedVector
:
:
at
(
size_type
)
failed
bounds
check
"
)
;
}
return
data
(
)
[
i
]
;
}
const_reference
at
(
size_type
i
)
const
{
if
(
ABSL_PREDICT_FALSE
(
i
>
=
size
(
)
)
)
{
base_internal
:
:
ThrowStdOutOfRange
(
"
InlinedVector
:
:
at
(
size_type
)
const
failed
bounds
check
"
)
;
}
return
data
(
)
[
i
]
;
}
reference
front
(
)
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
return
data
(
)
[
0
]
;
}
const_reference
front
(
)
const
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
return
data
(
)
[
0
]
;
}
reference
back
(
)
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
return
data
(
)
[
size
(
)
-
1
]
;
}
const_reference
back
(
)
const
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
return
data
(
)
[
size
(
)
-
1
]
;
}
iterator
begin
(
)
noexcept
{
return
data
(
)
;
}
const_iterator
begin
(
)
const
noexcept
{
return
data
(
)
;
}
iterator
end
(
)
noexcept
{
return
data
(
)
+
size
(
)
;
}
const_iterator
end
(
)
const
noexcept
{
return
data
(
)
+
size
(
)
;
}
const_iterator
cbegin
(
)
const
noexcept
{
return
begin
(
)
;
}
const_iterator
cend
(
)
const
noexcept
{
return
end
(
)
;
}
reverse_iterator
rbegin
(
)
noexcept
{
return
reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
rbegin
(
)
const
noexcept
{
return
const_reverse_iterator
(
end
(
)
)
;
}
reverse_iterator
rend
(
)
noexcept
{
return
reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
rend
(
)
const
noexcept
{
return
const_reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
crbegin
(
)
const
noexcept
{
return
rbegin
(
)
;
}
const_reverse_iterator
crend
(
)
const
noexcept
{
return
rend
(
)
;
}
allocator_type
get_allocator
(
)
const
{
return
*
storage_
.
GetAllocPtr
(
)
;
}
InlinedVector
&
operator
=
(
std
:
:
initializer_list
<
value_type
>
list
)
{
assign
(
list
.
begin
(
)
list
.
end
(
)
)
;
return
*
this
;
}
InlinedVector
&
operator
=
(
const
InlinedVector
&
other
)
{
if
(
ABSL_PREDICT_TRUE
(
this
!
=
std
:
:
addressof
(
other
)
)
)
{
const_pointer
other_data
=
other
.
data
(
)
;
assign
(
other_data
other_data
+
other
.
size
(
)
)
;
}
return
*
this
;
}
InlinedVector
&
operator
=
(
InlinedVector
&
&
other
)
{
if
(
ABSL_PREDICT_TRUE
(
this
!
=
std
:
:
addressof
(
other
)
)
)
{
if
(
IsMemcpyOk
:
:
value
|
|
other
.
storage_
.
GetIsAllocated
(
)
)
{
inlined_vector_internal
:
:
DestroyElements
(
storage_
.
GetAllocPtr
(
)
data
(
)
size
(
)
)
;
storage_
.
DeallocateIfAllocated
(
)
;
storage_
.
MemcpyFrom
(
other
.
storage_
)
;
other
.
storage_
.
SetInlinedSize
(
0
)
;
}
else
{
storage_
.
Assign
(
IteratorValueAdapter
<
MoveIterator
>
(
MoveIterator
(
other
.
storage_
.
GetInlinedData
(
)
)
)
other
.
size
(
)
)
;
}
}
return
*
this
;
}
void
assign
(
size_type
n
const_reference
v
)
{
storage_
.
Assign
(
CopyValueAdapter
(
v
)
n
)
;
}
void
assign
(
std
:
:
initializer_list
<
value_type
>
list
)
{
assign
(
list
.
begin
(
)
list
.
end
(
)
)
;
}
template
<
typename
ForwardIterator
EnableIfAtLeastForwardIterator
<
ForwardIterator
>
*
=
nullptr
>
void
assign
(
ForwardIterator
first
ForwardIterator
last
)
{
storage_
.
Assign
(
IteratorValueAdapter
<
ForwardIterator
>
(
first
)
std
:
:
distance
(
first
last
)
)
;
}
template
<
typename
InputIterator
DisableIfAtLeastForwardIterator
<
InputIterator
>
*
=
nullptr
>
void
assign
(
InputIterator
first
InputIterator
last
)
{
size_type
i
=
0
;
for
(
;
i
<
size
(
)
&
&
first
!
=
last
;
+
+
i
static_cast
<
void
>
(
+
+
first
)
)
{
data
(
)
[
i
]
=
*
first
;
}
erase
(
data
(
)
+
i
data
(
)
+
size
(
)
)
;
std
:
:
copy
(
first
last
std
:
:
back_inserter
(
*
this
)
)
;
}
void
resize
(
size_type
n
)
{
ABSL_HARDENING_ASSERT
(
n
<
=
max_size
(
)
)
;
storage_
.
Resize
(
DefaultValueAdapter
(
)
n
)
;
}
void
resize
(
size_type
n
const_reference
v
)
{
ABSL_HARDENING_ASSERT
(
n
<
=
max_size
(
)
)
;
storage_
.
Resize
(
CopyValueAdapter
(
v
)
n
)
;
}
iterator
insert
(
const_iterator
pos
const_reference
v
)
{
return
emplace
(
pos
v
)
;
}
iterator
insert
(
const_iterator
pos
RValueReference
v
)
{
return
emplace
(
pos
std
:
:
move
(
v
)
)
;
}
iterator
insert
(
const_iterator
pos
size_type
n
const_reference
v
)
{
ABSL_HARDENING_ASSERT
(
pos
>
=
begin
(
)
)
;
ABSL_HARDENING_ASSERT
(
pos
<
=
end
(
)
)
;
if
(
ABSL_PREDICT_TRUE
(
n
!
=
0
)
)
{
value_type
dealias
=
v
;
return
storage_
.
Insert
(
pos
CopyValueAdapter
(
dealias
)
n
)
;
}
else
{
return
const_cast
<
iterator
>
(
pos
)
;
}
}
iterator
insert
(
const_iterator
pos
std
:
:
initializer_list
<
value_type
>
list
)
{
return
insert
(
pos
list
.
begin
(
)
list
.
end
(
)
)
;
}
template
<
typename
ForwardIterator
EnableIfAtLeastForwardIterator
<
ForwardIterator
>
*
=
nullptr
>
iterator
insert
(
const_iterator
pos
ForwardIterator
first
ForwardIterator
last
)
{
ABSL_HARDENING_ASSERT
(
pos
>
=
begin
(
)
)
;
ABSL_HARDENING_ASSERT
(
pos
<
=
end
(
)
)
;
if
(
ABSL_PREDICT_TRUE
(
first
!
=
last
)
)
{
return
storage_
.
Insert
(
pos
IteratorValueAdapter
<
ForwardIterator
>
(
first
)
std
:
:
distance
(
first
last
)
)
;
}
else
{
return
const_cast
<
iterator
>
(
pos
)
;
}
}
template
<
typename
InputIterator
DisableIfAtLeastForwardIterator
<
InputIterator
>
*
=
nullptr
>
iterator
insert
(
const_iterator
pos
InputIterator
first
InputIterator
last
)
{
ABSL_HARDENING_ASSERT
(
pos
>
=
begin
(
)
)
;
ABSL_HARDENING_ASSERT
(
pos
<
=
end
(
)
)
;
size_type
index
=
std
:
:
distance
(
cbegin
(
)
pos
)
;
for
(
size_type
i
=
index
;
first
!
=
last
;
+
+
i
static_cast
<
void
>
(
+
+
first
)
)
{
insert
(
data
(
)
+
i
*
first
)
;
}
return
iterator
(
data
(
)
+
index
)
;
}
template
<
typename
.
.
.
Args
>
iterator
emplace
(
const_iterator
pos
Args
&
&
.
.
.
args
)
{
ABSL_HARDENING_ASSERT
(
pos
>
=
begin
(
)
)
;
ABSL_HARDENING_ASSERT
(
pos
<
=
end
(
)
)
;
value_type
dealias
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
storage_
.
Insert
(
pos
IteratorValueAdapter
<
MoveIterator
>
(
MoveIterator
(
std
:
:
addressof
(
dealias
)
)
)
1
)
;
}
template
<
typename
.
.
.
Args
>
reference
emplace_back
(
Args
&
&
.
.
.
args
)
{
return
storage_
.
EmplaceBack
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
void
push_back
(
const_reference
v
)
{
static_cast
<
void
>
(
emplace_back
(
v
)
)
;
}
void
push_back
(
RValueReference
v
)
{
static_cast
<
void
>
(
emplace_back
(
std
:
:
move
(
v
)
)
)
;
}
void
pop_back
(
)
noexcept
{
ABSL_HARDENING_ASSERT
(
!
empty
(
)
)
;
AllocatorTraits
:
:
destroy
(
*
storage_
.
GetAllocPtr
(
)
data
(
)
+
(
size
(
)
-
1
)
)
;
storage_
.
SubtractSize
(
1
)
;
}
iterator
erase
(
const_iterator
pos
)
{
ABSL_HARDENING_ASSERT
(
pos
>
=
begin
(
)
)
;
ABSL_HARDENING_ASSERT
(
pos
<
end
(
)
)
;
return
storage_
.
Erase
(
pos
pos
+
1
)
;
}
iterator
erase
(
const_iterator
from
const_iterator
to
)
{
ABSL_HARDENING_ASSERT
(
from
>
=
begin
(
)
)
;
ABSL_HARDENING_ASSERT
(
from
<
=
to
)
;
ABSL_HARDENING_ASSERT
(
to
<
=
end
(
)
)
;
if
(
ABSL_PREDICT_TRUE
(
from
!
=
to
)
)
{
return
storage_
.
Erase
(
from
to
)
;
}
else
{
return
const_cast
<
iterator
>
(
from
)
;
}
}
void
clear
(
)
noexcept
{
inlined_vector_internal
:
:
DestroyElements
(
storage_
.
GetAllocPtr
(
)
data
(
)
size
(
)
)
;
storage_
.
DeallocateIfAllocated
(
)
;
storage_
.
SetInlinedSize
(
0
)
;
}
void
reserve
(
size_type
n
)
{
storage_
.
Reserve
(
n
)
;
}
void
shrink_to_fit
(
)
{
if
(
storage_
.
GetIsAllocated
(
)
)
{
storage_
.
ShrinkToFit
(
)
;
}
}
void
swap
(
InlinedVector
&
other
)
{
if
(
ABSL_PREDICT_TRUE
(
this
!
=
std
:
:
addressof
(
other
)
)
)
{
storage_
.
Swap
(
std
:
:
addressof
(
other
.
storage_
)
)
;
}
}
private
:
template
<
typename
H
typename
TheT
size_t
TheN
typename
TheA
>
friend
H
AbslHashValue
(
H
h
const
absl
:
:
InlinedVector
<
TheT
TheN
TheA
>
&
a
)
;
Storage
storage_
;
}
;
template
<
typename
T
size_t
N
typename
A
>
void
swap
(
absl
:
:
InlinedVector
<
T
N
A
>
&
a
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
noexcept
(
noexcept
(
a
.
swap
(
b
)
)
)
{
a
.
swap
(
b
)
;
}
template
<
typename
T
size_t
N
typename
A
>
bool
operator
=
=
(
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
const
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
{
auto
a_data
=
a
.
data
(
)
;
auto
b_data
=
b
.
data
(
)
;
return
absl
:
:
equal
(
a_data
a_data
+
a
.
size
(
)
b_data
b_data
+
b
.
size
(
)
)
;
}
template
<
typename
T
size_t
N
typename
A
>
bool
operator
!
=
(
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
const
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
{
return
!
(
a
=
=
b
)
;
}
template
<
typename
T
size_t
N
typename
A
>
bool
operator
<
(
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
const
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
{
auto
a_data
=
a
.
data
(
)
;
auto
b_data
=
b
.
data
(
)
;
return
std
:
:
lexicographical_compare
(
a_data
a_data
+
a
.
size
(
)
b_data
b_data
+
b
.
size
(
)
)
;
}
template
<
typename
T
size_t
N
typename
A
>
bool
operator
>
(
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
const
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
{
return
b
<
a
;
}
template
<
typename
T
size_t
N
typename
A
>
bool
operator
<
=
(
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
const
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
{
return
!
(
b
<
a
)
;
}
template
<
typename
T
size_t
N
typename
A
>
bool
operator
>
=
(
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
const
absl
:
:
InlinedVector
<
T
N
A
>
&
b
)
{
return
!
(
a
<
b
)
;
}
template
<
typename
H
typename
T
size_t
N
typename
A
>
H
AbslHashValue
(
H
h
const
absl
:
:
InlinedVector
<
T
N
A
>
&
a
)
{
auto
size
=
a
.
size
(
)
;
return
H
:
:
combine
(
H
:
:
combine_contiguous
(
std
:
:
move
(
h
)
a
.
data
(
)
size
)
size
)
;
}
ABSL_NAMESPACE_END
}
#
endif
