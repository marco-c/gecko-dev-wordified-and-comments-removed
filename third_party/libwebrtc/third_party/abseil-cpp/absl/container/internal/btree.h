#
ifndef
ABSL_CONTAINER_INTERNAL_BTREE_H_
#
define
ABSL_CONTAINER_INTERNAL_BTREE_H_
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
functional
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
new
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
container
/
internal
/
common
.
h
"
#
include
"
absl
/
container
/
internal
/
compressed_tuple
.
h
"
#
include
"
absl
/
container
/
internal
/
container_memory
.
h
"
#
include
"
absl
/
container
/
internal
/
layout
.
h
"
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
strings
/
cord
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
compare
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
typename
Compare
typename
T
>
using
btree_is_key_compare_to
=
std
:
:
is_convertible
<
absl
:
:
result_of_t
<
Compare
(
const
T
&
const
T
&
)
>
absl
:
:
weak_ordering
>
;
struct
StringBtreeDefaultLess
{
using
is_transparent
=
void
;
StringBtreeDefaultLess
(
)
=
default
;
StringBtreeDefaultLess
(
std
:
:
less
<
std
:
:
string
>
)
{
}
StringBtreeDefaultLess
(
std
:
:
less
<
absl
:
:
string_view
>
)
{
}
explicit
operator
std
:
:
less
<
std
:
:
string
>
(
)
const
{
return
{
}
;
}
explicit
operator
std
:
:
less
<
absl
:
:
string_view
>
(
)
const
{
return
{
}
;
}
explicit
operator
std
:
:
less
<
absl
:
:
Cord
>
(
)
const
{
return
{
}
;
}
absl
:
:
weak_ordering
operator
(
)
(
absl
:
:
string_view
lhs
absl
:
:
string_view
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
lhs
.
compare
(
rhs
)
)
;
}
StringBtreeDefaultLess
(
std
:
:
less
<
absl
:
:
Cord
>
)
{
}
absl
:
:
weak_ordering
operator
(
)
(
const
absl
:
:
Cord
&
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
lhs
.
Compare
(
rhs
)
)
;
}
absl
:
:
weak_ordering
operator
(
)
(
const
absl
:
:
Cord
&
lhs
absl
:
:
string_view
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
lhs
.
Compare
(
rhs
)
)
;
}
absl
:
:
weak_ordering
operator
(
)
(
absl
:
:
string_view
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
-
rhs
.
Compare
(
lhs
)
)
;
}
}
;
struct
StringBtreeDefaultGreater
{
using
is_transparent
=
void
;
StringBtreeDefaultGreater
(
)
=
default
;
StringBtreeDefaultGreater
(
std
:
:
greater
<
std
:
:
string
>
)
{
}
StringBtreeDefaultGreater
(
std
:
:
greater
<
absl
:
:
string_view
>
)
{
}
explicit
operator
std
:
:
greater
<
std
:
:
string
>
(
)
const
{
return
{
}
;
}
explicit
operator
std
:
:
greater
<
absl
:
:
string_view
>
(
)
const
{
return
{
}
;
}
explicit
operator
std
:
:
greater
<
absl
:
:
Cord
>
(
)
const
{
return
{
}
;
}
absl
:
:
weak_ordering
operator
(
)
(
absl
:
:
string_view
lhs
absl
:
:
string_view
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
rhs
.
compare
(
lhs
)
)
;
}
StringBtreeDefaultGreater
(
std
:
:
greater
<
absl
:
:
Cord
>
)
{
}
absl
:
:
weak_ordering
operator
(
)
(
const
absl
:
:
Cord
&
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
rhs
.
Compare
(
lhs
)
)
;
}
absl
:
:
weak_ordering
operator
(
)
(
const
absl
:
:
Cord
&
lhs
absl
:
:
string_view
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
-
lhs
.
Compare
(
rhs
)
)
;
}
absl
:
:
weak_ordering
operator
(
)
(
absl
:
:
string_view
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
compare_internal
:
:
compare_result_as_ordering
(
rhs
.
Compare
(
lhs
)
)
;
}
}
;
template
<
typename
Compare
>
struct
key_compare_to_adapter
{
using
type
=
Compare
;
}
;
template
<
>
struct
key_compare_to_adapter
<
std
:
:
less
<
std
:
:
string
>
>
{
using
type
=
StringBtreeDefaultLess
;
}
;
template
<
>
struct
key_compare_to_adapter
<
std
:
:
greater
<
std
:
:
string
>
>
{
using
type
=
StringBtreeDefaultGreater
;
}
;
template
<
>
struct
key_compare_to_adapter
<
std
:
:
less
<
absl
:
:
string_view
>
>
{
using
type
=
StringBtreeDefaultLess
;
}
;
template
<
>
struct
key_compare_to_adapter
<
std
:
:
greater
<
absl
:
:
string_view
>
>
{
using
type
=
StringBtreeDefaultGreater
;
}
;
template
<
>
struct
key_compare_to_adapter
<
std
:
:
less
<
absl
:
:
Cord
>
>
{
using
type
=
StringBtreeDefaultLess
;
}
;
template
<
>
struct
key_compare_to_adapter
<
std
:
:
greater
<
absl
:
:
Cord
>
>
{
using
type
=
StringBtreeDefaultGreater
;
}
;
template
<
typename
T
typename
=
void
>
struct
has_linear_node_search_preference
:
std
:
:
false_type
{
}
;
template
<
typename
T
typename
=
void
>
struct
prefers_linear_node_search
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
has_linear_node_search_preference
<
T
absl
:
:
void_t
<
typename
T
:
:
absl_btree_prefer_linear_node_search
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
prefers_linear_node_search
<
T
absl
:
:
void_t
<
typename
T
:
:
absl_btree_prefer_linear_node_search
>
>
:
T
:
:
absl_btree_prefer_linear_node_search
{
}
;
template
<
typename
Key
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
Multi
typename
SlotPolicy
>
struct
common_params
{
using
original_key_compare
=
Compare
;
using
key_compare
=
typename
key_compare_to_adapter
<
Compare
>
:
:
type
;
using
is_key_compare_to
=
btree_is_key_compare_to
<
key_compare
Key
>
;
using
allocator_type
=
Alloc
;
using
key_type
=
Key
;
using
size_type
=
std
:
:
make_signed
<
size_t
>
:
:
type
;
using
difference_type
=
ptrdiff_t
;
using
slot_policy
=
SlotPolicy
;
using
slot_type
=
typename
slot_policy
:
:
slot_type
;
using
value_type
=
typename
slot_policy
:
:
value_type
;
using
init_type
=
typename
slot_policy
:
:
mutable_value_type
;
using
pointer
=
value_type
*
;
using
const_pointer
=
const
value_type
*
;
using
reference
=
value_type
&
;
using
const_reference
=
const
value_type
&
;
template
<
typename
LookupKey
>
constexpr
static
bool
can_have_multiple_equivalent_keys
(
)
{
return
Multi
|
|
(
IsTransparent
<
key_compare
>
:
:
value
&
&
!
std
:
:
is_same
<
LookupKey
Key
>
:
:
value
&
&
!
std
:
:
is_same
<
key_compare
StringBtreeDefaultLess
>
:
:
value
&
&
!
std
:
:
is_same
<
key_compare
StringBtreeDefaultGreater
>
:
:
value
)
;
}
enum
{
kTargetNodeSize
=
TargetNodeSize
kNodeValueSpace
=
TargetNodeSize
-
(
sizeof
(
void
*
)
+
4
)
}
;
using
node_count_type
=
absl
:
:
conditional_t
<
(
kNodeValueSpace
/
sizeof
(
value_type
)
>
(
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
)
(
)
)
uint16_t
uint8_t
>
;
static
value_type
&
element
(
slot_type
*
slot
)
{
return
slot_policy
:
:
element
(
slot
)
;
}
static
const
value_type
&
element
(
const
slot_type
*
slot
)
{
return
slot_policy
:
:
element
(
slot
)
;
}
template
<
class
.
.
.
Args
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
Args
&
&
.
.
.
args
)
{
slot_policy
:
:
construct
(
alloc
slot
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
slot_type
*
other
)
{
slot_policy
:
:
construct
(
alloc
slot
other
)
;
}
static
void
destroy
(
Alloc
*
alloc
slot_type
*
slot
)
{
slot_policy
:
:
destroy
(
alloc
slot
)
;
}
static
void
transfer
(
Alloc
*
alloc
slot_type
*
new_slot
slot_type
*
old_slot
)
{
construct
(
alloc
new_slot
old_slot
)
;
destroy
(
alloc
old_slot
)
;
}
static
void
swap
(
Alloc
*
alloc
slot_type
*
a
slot_type
*
b
)
{
slot_policy
:
:
swap
(
alloc
a
b
)
;
}
static
void
move
(
Alloc
*
alloc
slot_type
*
src
slot_type
*
dest
)
{
slot_policy
:
:
move
(
alloc
src
dest
)
;
}
}
;
template
<
typename
Key
typename
Data
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
Multi
>
struct
map_params
:
common_params
<
Key
Compare
Alloc
TargetNodeSize
Multi
map_slot_policy
<
Key
Data
>
>
{
using
super_type
=
typename
map_params
:
:
common_params
;
using
mapped_type
=
Data
;
using
slot_policy
=
typename
super_type
:
:
slot_policy
;
using
slot_type
=
typename
super_type
:
:
slot_type
;
using
value_type
=
typename
super_type
:
:
value_type
;
using
init_type
=
typename
super_type
:
:
init_type
;
using
original_key_compare
=
typename
super_type
:
:
original_key_compare
;
class
value_compare
{
template
<
typename
Params
>
friend
class
btree
;
protected
:
explicit
value_compare
(
original_key_compare
c
)
:
comp
(
std
:
:
move
(
c
)
)
{
}
original_key_compare
comp
;
public
:
auto
operator
(
)
(
const
value_type
&
lhs
const
value_type
&
rhs
)
const
-
>
decltype
(
comp
(
lhs
.
first
rhs
.
first
)
)
{
return
comp
(
lhs
.
first
rhs
.
first
)
;
}
}
;
using
is_map_container
=
std
:
:
true_type
;
template
<
typename
V
>
static
auto
key
(
const
V
&
value
)
-
>
decltype
(
value
.
first
)
{
return
value
.
first
;
}
static
const
Key
&
key
(
const
slot_type
*
s
)
{
return
slot_policy
:
:
key
(
s
)
;
}
static
const
Key
&
key
(
slot_type
*
s
)
{
return
slot_policy
:
:
key
(
s
)
;
}
static
auto
mutable_key
(
slot_type
*
s
)
-
>
decltype
(
slot_policy
:
:
mutable_key
(
s
)
)
{
return
slot_policy
:
:
mutable_key
(
s
)
;
}
static
mapped_type
&
value
(
value_type
*
value
)
{
return
value
-
>
second
;
}
}
;
template
<
typename
Key
>
struct
set_slot_policy
{
using
slot_type
=
Key
;
using
value_type
=
Key
;
using
mutable_value_type
=
Key
;
static
value_type
&
element
(
slot_type
*
slot
)
{
return
*
slot
;
}
static
const
value_type
&
element
(
const
slot_type
*
slot
)
{
return
*
slot
;
}
template
<
typename
Alloc
class
.
.
.
Args
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
Args
&
&
.
.
.
args
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
construct
(
*
alloc
slot
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
Alloc
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
slot_type
*
other
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
construct
(
*
alloc
slot
std
:
:
move
(
*
other
)
)
;
}
template
<
typename
Alloc
>
static
void
destroy
(
Alloc
*
alloc
slot_type
*
slot
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
destroy
(
*
alloc
slot
)
;
}
template
<
typename
Alloc
>
static
void
swap
(
Alloc
*
slot_type
*
a
slot_type
*
b
)
{
using
std
:
:
swap
;
swap
(
*
a
*
b
)
;
}
template
<
typename
Alloc
>
static
void
move
(
Alloc
*
slot_type
*
src
slot_type
*
dest
)
{
*
dest
=
std
:
:
move
(
*
src
)
;
}
}
;
template
<
typename
Key
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
Multi
>
struct
set_params
:
common_params
<
Key
Compare
Alloc
TargetNodeSize
Multi
set_slot_policy
<
Key
>
>
{
using
value_type
=
Key
;
using
slot_type
=
typename
set_params
:
:
common_params
:
:
slot_type
;
using
value_compare
=
typename
set_params
:
:
common_params
:
:
original_key_compare
;
using
is_map_container
=
std
:
:
false_type
;
template
<
typename
V
>
static
const
V
&
key
(
const
V
&
value
)
{
return
value
;
}
static
const
Key
&
key
(
const
slot_type
*
slot
)
{
return
*
slot
;
}
static
const
Key
&
key
(
slot_type
*
slot
)
{
return
*
slot
;
}
}
;
template
<
typename
Compare
>
struct
upper_bound_adapter
{
explicit
upper_bound_adapter
(
const
Compare
&
c
)
:
comp
(
c
)
{
}
template
<
typename
K1
typename
K2
>
bool
operator
(
)
(
const
K1
&
a
const
K2
&
b
)
const
{
return
!
compare_internal
:
:
compare_result_as_less_than
(
comp
(
b
a
)
)
;
}
private
:
Compare
comp
;
}
;
enum
class
MatchKind
:
uint8_t
{
kEq
kNe
}
;
template
<
typename
V
bool
IsCompareTo
>
struct
SearchResult
{
V
value
;
MatchKind
match
;
static
constexpr
bool
HasMatch
(
)
{
return
true
;
}
bool
IsEq
(
)
const
{
return
match
=
=
MatchKind
:
:
kEq
;
}
}
;
template
<
typename
V
>
struct
SearchResult
<
V
false
>
{
SearchResult
(
)
{
}
explicit
SearchResult
(
V
value
)
:
value
(
value
)
{
}
SearchResult
(
V
value
MatchKind
)
:
value
(
value
)
{
}
V
value
;
static
constexpr
bool
HasMatch
(
)
{
return
false
;
}
static
constexpr
bool
IsEq
(
)
{
return
false
;
}
}
;
template
<
typename
Params
>
class
btree_node
{
using
is_key_compare_to
=
typename
Params
:
:
is_key_compare_to
;
using
field_type
=
typename
Params
:
:
node_count_type
;
using
allocator_type
=
typename
Params
:
:
allocator_type
;
using
slot_type
=
typename
Params
:
:
slot_type
;
public
:
using
params_type
=
Params
;
using
key_type
=
typename
Params
:
:
key_type
;
using
value_type
=
typename
Params
:
:
value_type
;
using
pointer
=
typename
Params
:
:
pointer
;
using
const_pointer
=
typename
Params
:
:
const_pointer
;
using
reference
=
typename
Params
:
:
reference
;
using
const_reference
=
typename
Params
:
:
const_reference
;
using
key_compare
=
typename
Params
:
:
key_compare
;
using
size_type
=
typename
Params
:
:
size_type
;
using
difference_type
=
typename
Params
:
:
difference_type
;
using
use_linear_search
=
std
:
:
integral_constant
<
bool
has_linear_node_search_preference
<
key_compare
>
:
:
value
?
prefers_linear_node_search
<
key_compare
>
:
:
value
:
has_linear_node_search_preference
<
key_type
>
:
:
value
?
prefers_linear_node_search
<
key_type
>
:
:
value
:
std
:
:
is_arithmetic
<
key_type
>
:
:
value
&
&
(
std
:
:
is_same
<
std
:
:
less
<
key_type
>
key_compare
>
:
:
value
|
|
std
:
:
is_same
<
std
:
:
greater
<
key_type
>
key_compare
>
:
:
value
)
>
;
~
btree_node
(
)
=
default
;
btree_node
(
btree_node
const
&
)
=
delete
;
btree_node
&
operator
=
(
btree_node
const
&
)
=
delete
;
constexpr
static
size_type
Alignment
(
)
{
static_assert
(
LeafLayout
(
1
)
.
Alignment
(
)
=
=
InternalLayout
(
)
.
Alignment
(
)
"
Alignment
of
all
nodes
must
be
equal
.
"
)
;
return
InternalLayout
(
)
.
Alignment
(
)
;
}
protected
:
btree_node
(
)
=
default
;
private
:
using
layout_type
=
absl
:
:
container_internal
:
:
Layout
<
btree_node
*
field_type
slot_type
btree_node
*
>
;
constexpr
static
size_type
SizeWithNSlots
(
size_type
n
)
{
return
layout_type
(
1
4
n
0
)
.
AllocSize
(
)
;
}
constexpr
static
size_type
MinimumOverhead
(
)
{
return
SizeWithNSlots
(
1
)
-
sizeof
(
value_type
)
;
}
constexpr
static
size_type
NodeTargetSlots
(
const
int
begin
const
int
end
)
{
return
begin
=
=
end
?
begin
:
SizeWithNSlots
(
(
begin
+
end
)
/
2
+
1
)
>
params_type
:
:
kTargetNodeSize
?
NodeTargetSlots
(
begin
(
begin
+
end
)
/
2
)
:
NodeTargetSlots
(
(
begin
+
end
)
/
2
+
1
end
)
;
}
enum
{
kTargetNodeSize
=
params_type
:
:
kTargetNodeSize
kNodeTargetSlots
=
NodeTargetSlots
(
0
params_type
:
:
kTargetNodeSize
)
kMinNodeSlots
=
4
kNodeSlots
=
kNodeTargetSlots
>
=
kMinNodeSlots
?
kNodeTargetSlots
:
kMinNodeSlots
kInternalNodeMaxCount
=
0
}
;
constexpr
static
layout_type
LeafLayout
(
const
int
slot_count
=
kNodeSlots
)
{
return
layout_type
(
1
4
slot_count
0
)
;
}
constexpr
static
layout_type
InternalLayout
(
)
{
return
layout_type
(
1
4
kNodeSlots
kNodeSlots
+
1
)
;
}
constexpr
static
size_type
LeafSize
(
const
int
slot_count
=
kNodeSlots
)
{
return
LeafLayout
(
slot_count
)
.
AllocSize
(
)
;
}
constexpr
static
size_type
InternalSize
(
)
{
return
InternalLayout
(
)
.
AllocSize
(
)
;
}
template
<
size_type
N
>
inline
typename
layout_type
:
:
template
ElementType
<
N
>
*
GetField
(
)
{
assert
(
N
<
3
|
|
!
leaf
(
)
)
;
return
InternalLayout
(
)
.
template
Pointer
<
N
>
(
reinterpret_cast
<
char
*
>
(
this
)
)
;
}
template
<
size_type
N
>
inline
const
typename
layout_type
:
:
template
ElementType
<
N
>
*
GetField
(
)
const
{
assert
(
N
<
3
|
|
!
leaf
(
)
)
;
return
InternalLayout
(
)
.
template
Pointer
<
N
>
(
reinterpret_cast
<
const
char
*
>
(
this
)
)
;
}
void
set_parent
(
btree_node
*
p
)
{
*
GetField
<
0
>
(
)
=
p
;
}
field_type
&
mutable_finish
(
)
{
return
GetField
<
1
>
(
)
[
2
]
;
}
slot_type
*
slot
(
int
i
)
{
return
&
GetField
<
2
>
(
)
[
i
]
;
}
slot_type
*
start_slot
(
)
{
return
slot
(
start
(
)
)
;
}
slot_type
*
finish_slot
(
)
{
return
slot
(
finish
(
)
)
;
}
const
slot_type
*
slot
(
int
i
)
const
{
return
&
GetField
<
2
>
(
)
[
i
]
;
}
void
set_position
(
field_type
v
)
{
GetField
<
1
>
(
)
[
0
]
=
v
;
}
void
set_start
(
field_type
v
)
{
GetField
<
1
>
(
)
[
1
]
=
v
;
}
void
set_finish
(
field_type
v
)
{
GetField
<
1
>
(
)
[
2
]
=
v
;
}
void
set_max_count
(
field_type
v
)
{
GetField
<
1
>
(
)
[
3
]
=
v
;
}
public
:
bool
leaf
(
)
const
{
return
GetField
<
1
>
(
)
[
3
]
!
=
kInternalNodeMaxCount
;
}
field_type
position
(
)
const
{
return
GetField
<
1
>
(
)
[
0
]
;
}
field_type
start
(
)
const
{
assert
(
GetField
<
1
>
(
)
[
1
]
=
=
0
)
;
return
0
;
}
field_type
finish
(
)
const
{
return
GetField
<
1
>
(
)
[
2
]
;
}
field_type
count
(
)
const
{
assert
(
finish
(
)
>
=
start
(
)
)
;
return
finish
(
)
-
start
(
)
;
}
field_type
max_count
(
)
const
{
const
field_type
max_count
=
GetField
<
1
>
(
)
[
3
]
;
return
max_count
=
=
field_type
{
kInternalNodeMaxCount
}
?
field_type
{
kNodeSlots
}
:
max_count
;
}
btree_node
*
parent
(
)
const
{
return
*
GetField
<
0
>
(
)
;
}
bool
is_root
(
)
const
{
return
parent
(
)
-
>
leaf
(
)
;
}
void
make_root
(
)
{
assert
(
parent
(
)
-
>
is_root
(
)
)
;
set_parent
(
parent
(
)
-
>
parent
(
)
)
;
}
const
key_type
&
key
(
int
i
)
const
{
return
params_type
:
:
key
(
slot
(
i
)
)
;
}
reference
value
(
int
i
)
{
return
params_type
:
:
element
(
slot
(
i
)
)
;
}
const_reference
value
(
int
i
)
const
{
return
params_type
:
:
element
(
slot
(
i
)
)
;
}
btree_node
*
child
(
int
i
)
const
{
return
GetField
<
3
>
(
)
[
i
]
;
}
btree_node
*
start_child
(
)
const
{
return
child
(
start
(
)
)
;
}
btree_node
*
&
mutable_child
(
int
i
)
{
return
GetField
<
3
>
(
)
[
i
]
;
}
void
clear_child
(
int
i
)
{
absl
:
:
container_internal
:
:
SanitizerPoisonObject
(
&
mutable_child
(
i
)
)
;
}
void
set_child
(
int
i
btree_node
*
c
)
{
absl
:
:
container_internal
:
:
SanitizerUnpoisonObject
(
&
mutable_child
(
i
)
)
;
mutable_child
(
i
)
=
c
;
c
-
>
set_position
(
i
)
;
}
void
init_child
(
int
i
btree_node
*
c
)
{
set_child
(
i
c
)
;
c
-
>
set_parent
(
this
)
;
}
template
<
typename
K
>
SearchResult
<
int
is_key_compare_to
:
:
value
>
lower_bound
(
const
K
&
k
const
key_compare
&
comp
)
const
{
return
use_linear_search
:
:
value
?
linear_search
(
k
comp
)
:
binary_search
(
k
comp
)
;
}
template
<
typename
K
>
int
upper_bound
(
const
K
&
k
const
key_compare
&
comp
)
const
{
auto
upper_compare
=
upper_bound_adapter
<
key_compare
>
(
comp
)
;
return
use_linear_search
:
:
value
?
linear_search
(
k
upper_compare
)
.
value
:
binary_search
(
k
upper_compare
)
.
value
;
}
template
<
typename
K
typename
Compare
>
SearchResult
<
int
btree_is_key_compare_to
<
Compare
key_type
>
:
:
value
>
linear_search
(
const
K
&
k
const
Compare
&
comp
)
const
{
return
linear_search_impl
(
k
start
(
)
finish
(
)
comp
btree_is_key_compare_to
<
Compare
key_type
>
(
)
)
;
}
template
<
typename
K
typename
Compare
>
SearchResult
<
int
btree_is_key_compare_to
<
Compare
key_type
>
:
:
value
>
binary_search
(
const
K
&
k
const
Compare
&
comp
)
const
{
return
binary_search_impl
(
k
start
(
)
finish
(
)
comp
btree_is_key_compare_to
<
Compare
key_type
>
(
)
)
;
}
template
<
typename
K
typename
Compare
>
SearchResult
<
int
false
>
linear_search_impl
(
const
K
&
k
int
s
const
int
e
const
Compare
&
comp
std
:
:
false_type
)
const
{
while
(
s
<
e
)
{
if
(
!
comp
(
key
(
s
)
k
)
)
{
break
;
}
+
+
s
;
}
return
SearchResult
<
int
false
>
{
s
}
;
}
template
<
typename
K
typename
Compare
>
SearchResult
<
int
true
>
linear_search_impl
(
const
K
&
k
int
s
const
int
e
const
Compare
&
comp
std
:
:
true_type
)
const
{
while
(
s
<
e
)
{
const
absl
:
:
weak_ordering
c
=
comp
(
key
(
s
)
k
)
;
if
(
c
=
=
0
)
{
return
{
s
MatchKind
:
:
kEq
}
;
}
else
if
(
c
>
0
)
{
break
;
}
+
+
s
;
}
return
{
s
MatchKind
:
:
kNe
}
;
}
template
<
typename
K
typename
Compare
>
SearchResult
<
int
false
>
binary_search_impl
(
const
K
&
k
int
s
int
e
const
Compare
&
comp
std
:
:
false_type
)
const
{
while
(
s
!
=
e
)
{
const
int
mid
=
(
s
+
e
)
>
>
1
;
if
(
comp
(
key
(
mid
)
k
)
)
{
s
=
mid
+
1
;
}
else
{
e
=
mid
;
}
}
return
SearchResult
<
int
false
>
{
s
}
;
}
template
<
typename
K
typename
CompareTo
>
SearchResult
<
int
true
>
binary_search_impl
(
const
K
&
k
int
s
int
e
const
CompareTo
&
comp
std
:
:
true_type
)
const
{
if
(
params_type
:
:
template
can_have_multiple_equivalent_keys
<
K
>
(
)
)
{
MatchKind
exact_match
=
MatchKind
:
:
kNe
;
while
(
s
!
=
e
)
{
const
int
mid
=
(
s
+
e
)
>
>
1
;
const
absl
:
:
weak_ordering
c
=
comp
(
key
(
mid
)
k
)
;
if
(
c
<
0
)
{
s
=
mid
+
1
;
}
else
{
e
=
mid
;
if
(
c
=
=
0
)
{
exact_match
=
MatchKind
:
:
kEq
;
}
}
}
return
{
s
exact_match
}
;
}
else
{
while
(
s
!
=
e
)
{
const
int
mid
=
(
s
+
e
)
>
>
1
;
const
absl
:
:
weak_ordering
c
=
comp
(
key
(
mid
)
k
)
;
if
(
c
<
0
)
{
s
=
mid
+
1
;
}
else
if
(
c
>
0
)
{
e
=
mid
;
}
else
{
return
{
mid
MatchKind
:
:
kEq
}
;
}
}
return
{
s
MatchKind
:
:
kNe
}
;
}
}
template
<
typename
.
.
.
Args
>
void
emplace_value
(
size_type
i
allocator_type
*
alloc
Args
&
&
.
.
.
args
)
;
void
remove_values
(
field_type
i
field_type
to_erase
allocator_type
*
alloc
)
;
void
rebalance_right_to_left
(
int
to_move
btree_node
*
right
allocator_type
*
alloc
)
;
void
rebalance_left_to_right
(
int
to_move
btree_node
*
right
allocator_type
*
alloc
)
;
void
split
(
int
insert_position
btree_node
*
dest
allocator_type
*
alloc
)
;
void
merge
(
btree_node
*
src
allocator_type
*
alloc
)
;
void
init_leaf
(
btree_node
*
parent
int
max_count
)
{
set_parent
(
parent
)
;
set_position
(
0
)
;
set_start
(
0
)
;
set_finish
(
0
)
;
set_max_count
(
max_count
)
;
absl
:
:
container_internal
:
:
SanitizerPoisonMemoryRegion
(
start_slot
(
)
max_count
*
sizeof
(
slot_type
)
)
;
}
void
init_internal
(
btree_node
*
parent
)
{
init_leaf
(
parent
kNodeSlots
)
;
set_max_count
(
kInternalNodeMaxCount
)
;
absl
:
:
container_internal
:
:
SanitizerPoisonMemoryRegion
(
&
mutable_child
(
start
(
)
)
(
kNodeSlots
+
1
)
*
sizeof
(
btree_node
*
)
)
;
}
static
void
deallocate
(
const
size_type
size
btree_node
*
node
allocator_type
*
alloc
)
{
absl
:
:
container_internal
:
:
Deallocate
<
Alignment
(
)
>
(
alloc
node
size
)
;
}
static
void
clear_and_delete
(
btree_node
*
node
allocator_type
*
alloc
)
;
private
:
template
<
typename
.
.
.
Args
>
void
value_init
(
const
field_type
i
allocator_type
*
alloc
Args
&
&
.
.
.
args
)
{
absl
:
:
container_internal
:
:
SanitizerUnpoisonObject
(
slot
(
i
)
)
;
params_type
:
:
construct
(
alloc
slot
(
i
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
void
value_destroy
(
const
field_type
i
allocator_type
*
alloc
)
{
params_type
:
:
destroy
(
alloc
slot
(
i
)
)
;
absl
:
:
container_internal
:
:
SanitizerPoisonObject
(
slot
(
i
)
)
;
}
void
value_destroy_n
(
const
field_type
i
const
field_type
n
allocator_type
*
alloc
)
{
for
(
slot_type
*
s
=
slot
(
i
)
*
end
=
slot
(
i
+
n
)
;
s
!
=
end
;
+
+
s
)
{
params_type
:
:
destroy
(
alloc
s
)
;
absl
:
:
container_internal
:
:
SanitizerPoisonObject
(
s
)
;
}
}
static
void
transfer
(
slot_type
*
dest
slot_type
*
src
allocator_type
*
alloc
)
{
absl
:
:
container_internal
:
:
SanitizerUnpoisonObject
(
dest
)
;
params_type
:
:
transfer
(
alloc
dest
src
)
;
absl
:
:
container_internal
:
:
SanitizerPoisonObject
(
src
)
;
}
void
transfer
(
const
size_type
dest_i
const
size_type
src_i
btree_node
*
src_node
allocator_type
*
alloc
)
{
transfer
(
slot
(
dest_i
)
src_node
-
>
slot
(
src_i
)
alloc
)
;
}
void
transfer_n
(
const
size_type
n
const
size_type
dest_i
const
size_type
src_i
btree_node
*
src_node
allocator_type
*
alloc
)
{
for
(
slot_type
*
src
=
src_node
-
>
slot
(
src_i
)
*
end
=
src
+
n
*
dest
=
slot
(
dest_i
)
;
src
!
=
end
;
+
+
src
+
+
dest
)
{
transfer
(
dest
src
alloc
)
;
}
}
void
transfer_n_backward
(
const
size_type
n
const
size_type
dest_i
const
size_type
src_i
btree_node
*
src_node
allocator_type
*
alloc
)
{
for
(
slot_type
*
src
=
src_node
-
>
slot
(
src_i
+
n
-
1
)
*
end
=
src
-
n
*
dest
=
slot
(
dest_i
+
n
-
1
)
;
src
!
=
end
;
-
-
src
-
-
dest
)
{
transfer
(
dest
src
alloc
)
;
}
}
template
<
typename
P
>
friend
class
btree
;
template
<
typename
N
typename
R
typename
P
>
friend
struct
btree_iterator
;
friend
class
BtreeNodePeer
;
}
;
template
<
typename
Node
typename
Reference
typename
Pointer
>
struct
btree_iterator
{
private
:
using
key_type
=
typename
Node
:
:
key_type
;
using
size_type
=
typename
Node
:
:
size_type
;
using
params_type
=
typename
Node
:
:
params_type
;
using
is_map_container
=
typename
params_type
:
:
is_map_container
;
using
node_type
=
Node
;
using
normal_node
=
typename
std
:
:
remove_const
<
Node
>
:
:
type
;
using
const_node
=
const
Node
;
using
normal_pointer
=
typename
params_type
:
:
pointer
;
using
normal_reference
=
typename
params_type
:
:
reference
;
using
const_pointer
=
typename
params_type
:
:
const_pointer
;
using
const_reference
=
typename
params_type
:
:
const_reference
;
using
slot_type
=
typename
params_type
:
:
slot_type
;
using
iterator
=
btree_iterator
<
normal_node
normal_reference
normal_pointer
>
;
using
const_iterator
=
btree_iterator
<
const_node
const_reference
const_pointer
>
;
public
:
using
difference_type
=
typename
Node
:
:
difference_type
;
using
value_type
=
typename
params_type
:
:
value_type
;
using
pointer
=
Pointer
;
using
reference
=
Reference
;
using
iterator_category
=
std
:
:
bidirectional_iterator_tag
;
btree_iterator
(
)
:
node
(
nullptr
)
position
(
-
1
)
{
}
explicit
btree_iterator
(
Node
*
n
)
:
node
(
n
)
position
(
n
-
>
start
(
)
)
{
}
btree_iterator
(
Node
*
n
int
p
)
:
node
(
n
)
position
(
p
)
{
}
template
<
typename
N
typename
R
typename
P
absl
:
:
enable_if_t
<
std
:
:
is_same
<
btree_iterator
<
N
R
P
>
iterator
>
:
:
value
&
&
std
:
:
is_same
<
btree_iterator
const_iterator
>
:
:
value
int
>
=
0
>
btree_iterator
(
const
btree_iterator
<
N
R
P
>
other
)
:
node
(
other
.
node
)
position
(
other
.
position
)
{
}
private
:
template
<
typename
N
typename
R
typename
P
absl
:
:
enable_if_t
<
std
:
:
is_same
<
btree_iterator
<
N
R
P
>
const_iterator
>
:
:
value
&
&
std
:
:
is_same
<
btree_iterator
iterator
>
:
:
value
int
>
=
0
>
explicit
btree_iterator
(
const
btree_iterator
<
N
R
P
>
other
)
:
node
(
const_cast
<
node_type
*
>
(
other
.
node
)
)
position
(
other
.
position
)
{
}
void
increment
(
)
{
if
(
node
-
>
leaf
(
)
&
&
+
+
position
<
node
-
>
finish
(
)
)
{
return
;
}
increment_slow
(
)
;
}
void
increment_slow
(
)
;
void
decrement
(
)
{
if
(
node
-
>
leaf
(
)
&
&
-
-
position
>
=
node
-
>
start
(
)
)
{
return
;
}
decrement_slow
(
)
;
}
void
decrement_slow
(
)
;
public
:
bool
operator
=
=
(
const
iterator
&
other
)
const
{
return
node
=
=
other
.
node
&
&
position
=
=
other
.
position
;
}
bool
operator
=
=
(
const
const_iterator
&
other
)
const
{
return
node
=
=
other
.
node
&
&
position
=
=
other
.
position
;
}
bool
operator
!
=
(
const
iterator
&
other
)
const
{
return
node
!
=
other
.
node
|
|
position
!
=
other
.
position
;
}
bool
operator
!
=
(
const
const_iterator
&
other
)
const
{
return
node
!
=
other
.
node
|
|
position
!
=
other
.
position
;
}
reference
operator
*
(
)
const
{
ABSL_HARDENING_ASSERT
(
node
!
=
nullptr
)
;
ABSL_HARDENING_ASSERT
(
node
-
>
start
(
)
<
=
position
)
;
ABSL_HARDENING_ASSERT
(
node
-
>
finish
(
)
>
position
)
;
return
node
-
>
value
(
position
)
;
}
pointer
operator
-
>
(
)
const
{
return
&
operator
*
(
)
;
}
btree_iterator
&
operator
+
+
(
)
{
increment
(
)
;
return
*
this
;
}
btree_iterator
&
operator
-
-
(
)
{
decrement
(
)
;
return
*
this
;
}
btree_iterator
operator
+
+
(
int
)
{
btree_iterator
tmp
=
*
this
;
+
+
*
this
;
return
tmp
;
}
btree_iterator
operator
-
-
(
int
)
{
btree_iterator
tmp
=
*
this
;
-
-
*
this
;
return
tmp
;
}
private
:
friend
iterator
;
friend
const_iterator
;
template
<
typename
Params
>
friend
class
btree
;
template
<
typename
Tree
>
friend
class
btree_container
;
template
<
typename
Tree
>
friend
class
btree_set_container
;
template
<
typename
Tree
>
friend
class
btree_map_container
;
template
<
typename
Tree
>
friend
class
btree_multiset_container
;
template
<
typename
TreeType
typename
CheckerType
>
friend
class
base_checker
;
const
key_type
&
key
(
)
const
{
return
node
-
>
key
(
position
)
;
}
slot_type
*
slot
(
)
{
return
node
-
>
slot
(
position
)
;
}
Node
*
node
;
int
position
;
}
;
template
<
typename
Params
>
class
btree
{
using
node_type
=
btree_node
<
Params
>
;
using
is_key_compare_to
=
typename
Params
:
:
is_key_compare_to
;
using
init_type
=
typename
Params
:
:
init_type
;
using
field_type
=
typename
node_type
:
:
field_type
;
struct
alignas
(
node_type
:
:
Alignment
(
)
)
EmptyNodeType
:
node_type
{
using
field_type
=
typename
node_type
:
:
field_type
;
node_type
*
parent
;
field_type
position
=
0
;
field_type
start
=
0
;
field_type
finish
=
0
;
field_type
max_count
=
node_type
:
:
kInternalNodeMaxCount
+
1
;
#
ifdef
_MSC_VER
EmptyNodeType
(
)
:
parent
(
this
)
{
}
#
else
constexpr
EmptyNodeType
(
node_type
*
p
)
:
parent
(
p
)
{
}
#
endif
}
;
static
node_type
*
EmptyNode
(
)
{
#
ifdef
_MSC_VER
static
EmptyNodeType
*
empty_node
=
new
EmptyNodeType
;
assert
(
empty_node
-
>
parent
=
=
empty_node
)
;
return
empty_node
;
#
else
static
constexpr
EmptyNodeType
empty_node
(
const_cast
<
EmptyNodeType
*
>
(
&
empty_node
)
)
;
return
const_cast
<
EmptyNodeType
*
>
(
&
empty_node
)
;
#
endif
}
enum
:
uint32_t
{
kNodeSlots
=
node_type
:
:
kNodeSlots
kMinNodeValues
=
kNodeSlots
/
2
}
;
struct
node_stats
{
using
size_type
=
typename
Params
:
:
size_type
;
node_stats
(
size_type
l
size_type
i
)
:
leaf_nodes
(
l
)
internal_nodes
(
i
)
{
}
node_stats
&
operator
+
=
(
const
node_stats
&
other
)
{
leaf_nodes
+
=
other
.
leaf_nodes
;
internal_nodes
+
=
other
.
internal_nodes
;
return
*
this
;
}
size_type
leaf_nodes
;
size_type
internal_nodes
;
}
;
public
:
using
key_type
=
typename
Params
:
:
key_type
;
using
value_type
=
typename
Params
:
:
value_type
;
using
size_type
=
typename
Params
:
:
size_type
;
using
difference_type
=
typename
Params
:
:
difference_type
;
using
key_compare
=
typename
Params
:
:
key_compare
;
using
original_key_compare
=
typename
Params
:
:
original_key_compare
;
using
value_compare
=
typename
Params
:
:
value_compare
;
using
allocator_type
=
typename
Params
:
:
allocator_type
;
using
reference
=
typename
Params
:
:
reference
;
using
const_reference
=
typename
Params
:
:
const_reference
;
using
pointer
=
typename
Params
:
:
pointer
;
using
const_pointer
=
typename
Params
:
:
const_pointer
;
using
iterator
=
typename
btree_iterator
<
node_type
reference
pointer
>
:
:
iterator
;
using
const_iterator
=
typename
iterator
:
:
const_iterator
;
using
reverse_iterator
=
std
:
:
reverse_iterator
<
iterator
>
;
using
const_reverse_iterator
=
std
:
:
reverse_iterator
<
const_iterator
>
;
using
node_handle_type
=
node_handle
<
Params
Params
allocator_type
>
;
using
params_type
=
Params
;
using
slot_type
=
typename
Params
:
:
slot_type
;
private
:
const
value_type
&
maybe_move_from_iterator
(
const_iterator
it
)
{
return
*
it
;
}
value_type
&
&
maybe_move_from_iterator
(
iterator
it
)
{
return
std
:
:
move
(
const_cast
<
value_type
&
>
(
*
it
)
)
;
}
template
<
typename
Btree
>
void
copy_or_move_values_in_order
(
Btree
&
other
)
;
constexpr
static
bool
static_assert_validation
(
)
;
public
:
btree
(
const
key_compare
&
comp
const
allocator_type
&
alloc
)
:
root_
(
comp
alloc
EmptyNode
(
)
)
rightmost_
(
EmptyNode
(
)
)
size_
(
0
)
{
}
btree
(
const
btree
&
other
)
:
btree
(
other
other
.
allocator
(
)
)
{
}
btree
(
const
btree
&
other
const
allocator_type
&
alloc
)
:
btree
(
other
.
key_comp
(
)
alloc
)
{
copy_or_move_values_in_order
(
other
)
;
}
btree
(
btree
&
&
other
)
noexcept
:
root_
(
std
:
:
move
(
other
.
root_
)
)
rightmost_
(
absl
:
:
exchange
(
other
.
rightmost_
EmptyNode
(
)
)
)
size_
(
absl
:
:
exchange
(
other
.
size_
0
)
)
{
other
.
mutable_root
(
)
=
EmptyNode
(
)
;
}
btree
(
btree
&
&
other
const
allocator_type
&
alloc
)
:
btree
(
other
.
key_comp
(
)
alloc
)
{
if
(
alloc
=
=
other
.
allocator
(
)
)
{
swap
(
other
)
;
}
else
{
copy_or_move_values_in_order
(
other
)
;
}
}
~
btree
(
)
{
static_assert
(
static_assert_validation
(
)
"
This
call
must
be
elided
.
"
)
;
clear
(
)
;
}
btree
&
operator
=
(
const
btree
&
other
)
;
btree
&
operator
=
(
btree
&
&
other
)
noexcept
;
iterator
begin
(
)
{
return
iterator
(
leftmost
(
)
)
;
}
const_iterator
begin
(
)
const
{
return
const_iterator
(
leftmost
(
)
)
;
}
iterator
end
(
)
{
return
iterator
(
rightmost_
rightmost_
-
>
finish
(
)
)
;
}
const_iterator
end
(
)
const
{
return
const_iterator
(
rightmost_
rightmost_
-
>
finish
(
)
)
;
}
reverse_iterator
rbegin
(
)
{
return
reverse_iterator
(
end
(
)
)
;
}
const_reverse_iterator
rbegin
(
)
const
{
return
const_reverse_iterator
(
end
(
)
)
;
}
reverse_iterator
rend
(
)
{
return
reverse_iterator
(
begin
(
)
)
;
}
const_reverse_iterator
rend
(
)
const
{
return
const_reverse_iterator
(
begin
(
)
)
;
}
template
<
typename
K
>
iterator
lower_bound
(
const
K
&
key
)
{
return
internal_end
(
internal_lower_bound
(
key
)
.
value
)
;
}
template
<
typename
K
>
const_iterator
lower_bound
(
const
K
&
key
)
const
{
return
internal_end
(
internal_lower_bound
(
key
)
.
value
)
;
}
template
<
typename
K
>
std
:
:
pair
<
iterator
bool
>
lower_bound_equal
(
const
K
&
key
)
const
;
template
<
typename
K
>
iterator
upper_bound
(
const
K
&
key
)
{
return
internal_end
(
internal_upper_bound
(
key
)
)
;
}
template
<
typename
K
>
const_iterator
upper_bound
(
const
K
&
key
)
const
{
return
internal_end
(
internal_upper_bound
(
key
)
)
;
}
template
<
typename
K
>
std
:
:
pair
<
iterator
iterator
>
equal_range
(
const
K
&
key
)
;
template
<
typename
K
>
std
:
:
pair
<
const_iterator
const_iterator
>
equal_range
(
const
K
&
key
)
const
{
return
const_cast
<
btree
*
>
(
this
)
-
>
equal_range
(
key
)
;
}
template
<
typename
K
typename
.
.
.
Args
>
std
:
:
pair
<
iterator
bool
>
insert_unique
(
const
K
&
key
Args
&
&
.
.
.
args
)
;
template
<
typename
K
typename
.
.
.
Args
>
std
:
:
pair
<
iterator
bool
>
insert_hint_unique
(
iterator
position
const
K
&
key
Args
&
&
.
.
.
args
)
;
template
<
typename
InputIterator
typename
=
decltype
(
std
:
:
declval
<
const
key_compare
&
>
(
)
(
params_type
:
:
key
(
*
std
:
:
declval
<
InputIterator
>
(
)
)
std
:
:
declval
<
const
key_type
&
>
(
)
)
)
>
void
insert_iterator_unique
(
InputIterator
b
InputIterator
e
int
)
;
template
<
typename
InputIterator
>
void
insert_iterator_unique
(
InputIterator
b
InputIterator
e
char
)
;
template
<
typename
ValueType
>
iterator
insert_multi
(
const
key_type
&
key
ValueType
&
&
v
)
;
template
<
typename
ValueType
>
iterator
insert_multi
(
ValueType
&
&
v
)
{
return
insert_multi
(
params_type
:
:
key
(
v
)
std
:
:
forward
<
ValueType
>
(
v
)
)
;
}
template
<
typename
ValueType
>
iterator
insert_hint_multi
(
iterator
position
ValueType
&
&
v
)
;
template
<
typename
InputIterator
>
void
insert_iterator_multi
(
InputIterator
b
InputIterator
e
)
;
iterator
erase
(
iterator
iter
)
;
std
:
:
pair
<
size_type
iterator
>
erase_range
(
iterator
begin
iterator
end
)
;
template
<
typename
K
>
iterator
find
(
const
K
&
key
)
{
return
internal_end
(
internal_find
(
key
)
)
;
}
template
<
typename
K
>
const_iterator
find
(
const
K
&
key
)
const
{
return
internal_end
(
internal_find
(
key
)
)
;
}
void
clear
(
)
;
void
swap
(
btree
&
other
)
;
const
key_compare
&
key_comp
(
)
const
noexcept
{
return
root_
.
template
get
<
0
>
(
)
;
}
template
<
typename
K1
typename
K2
>
bool
compare_keys
(
const
K1
&
a
const
K2
&
b
)
const
{
return
compare_internal
:
:
compare_result_as_less_than
(
key_comp
(
)
(
a
b
)
)
;
}
value_compare
value_comp
(
)
const
{
return
value_compare
(
original_key_compare
(
key_comp
(
)
)
)
;
}
void
verify
(
)
const
;
size_type
size
(
)
const
{
return
size_
;
}
size_type
max_size
(
)
const
{
return
(
std
:
:
numeric_limits
<
size_type
>
:
:
max
)
(
)
;
}
bool
empty
(
)
const
{
return
size_
=
=
0
;
}
size_type
height
(
)
const
{
size_type
h
=
0
;
if
(
!
empty
(
)
)
{
const
node_type
*
n
=
root
(
)
;
do
{
+
+
h
;
n
=
n
-
>
parent
(
)
;
}
while
(
n
!
=
root
(
)
)
;
}
return
h
;
}
size_type
leaf_nodes
(
)
const
{
return
internal_stats
(
root
(
)
)
.
leaf_nodes
;
}
size_type
internal_nodes
(
)
const
{
return
internal_stats
(
root
(
)
)
.
internal_nodes
;
}
size_type
nodes
(
)
const
{
node_stats
stats
=
internal_stats
(
root
(
)
)
;
return
stats
.
leaf_nodes
+
stats
.
internal_nodes
;
}
size_type
bytes_used
(
)
const
{
node_stats
stats
=
internal_stats
(
root
(
)
)
;
if
(
stats
.
leaf_nodes
=
=
1
&
&
stats
.
internal_nodes
=
=
0
)
{
return
sizeof
(
*
this
)
+
node_type
:
:
LeafSize
(
root
(
)
-
>
max_count
(
)
)
;
}
else
{
return
sizeof
(
*
this
)
+
stats
.
leaf_nodes
*
node_type
:
:
LeafSize
(
)
+
stats
.
internal_nodes
*
node_type
:
:
InternalSize
(
)
;
}
}
static
double
average_bytes_per_value
(
)
{
const
double
expected_values_per_node
=
(
kNodeSlots
+
kMinNodeValues
)
/
2
.
0
;
return
node_type
:
:
LeafSize
(
)
/
expected_values_per_node
;
}
double
fullness
(
)
const
{
if
(
empty
(
)
)
return
0
.
0
;
return
static_cast
<
double
>
(
size
(
)
)
/
(
nodes
(
)
*
kNodeSlots
)
;
}
double
overhead
(
)
const
{
if
(
empty
(
)
)
return
0
.
0
;
return
(
bytes_used
(
)
-
size
(
)
*
sizeof
(
value_type
)
)
/
static_cast
<
double
>
(
size
(
)
)
;
}
allocator_type
get_allocator
(
)
const
{
return
allocator
(
)
;
}
private
:
node_type
*
root
(
)
{
return
root_
.
template
get
<
2
>
(
)
;
}
const
node_type
*
root
(
)
const
{
return
root_
.
template
get
<
2
>
(
)
;
}
node_type
*
&
mutable_root
(
)
noexcept
{
return
root_
.
template
get
<
2
>
(
)
;
}
key_compare
*
mutable_key_comp
(
)
noexcept
{
return
&
root_
.
template
get
<
0
>
(
)
;
}
node_type
*
leftmost
(
)
{
return
root
(
)
-
>
parent
(
)
;
}
const
node_type
*
leftmost
(
)
const
{
return
root
(
)
-
>
parent
(
)
;
}
allocator_type
*
mutable_allocator
(
)
noexcept
{
return
&
root_
.
template
get
<
1
>
(
)
;
}
const
allocator_type
&
allocator
(
)
const
noexcept
{
return
root_
.
template
get
<
1
>
(
)
;
}
node_type
*
allocate
(
const
size_type
size
)
{
return
reinterpret_cast
<
node_type
*
>
(
absl
:
:
container_internal
:
:
Allocate
<
node_type
:
:
Alignment
(
)
>
(
mutable_allocator
(
)
size
)
)
;
}
node_type
*
new_internal_node
(
node_type
*
parent
)
{
node_type
*
n
=
allocate
(
node_type
:
:
InternalSize
(
)
)
;
n
-
>
init_internal
(
parent
)
;
return
n
;
}
node_type
*
new_leaf_node
(
node_type
*
parent
)
{
node_type
*
n
=
allocate
(
node_type
:
:
LeafSize
(
)
)
;
n
-
>
init_leaf
(
parent
kNodeSlots
)
;
return
n
;
}
node_type
*
new_leaf_root_node
(
const
int
max_count
)
{
node_type
*
n
=
allocate
(
node_type
:
:
LeafSize
(
max_count
)
)
;
n
-
>
init_leaf
(
n
max_count
)
;
return
n
;
}
iterator
rebalance_after_delete
(
iterator
iter
)
;
void
rebalance_or_split
(
iterator
*
iter
)
;
void
merge_nodes
(
node_type
*
left
node_type
*
right
)
;
bool
try_merge_or_rebalance
(
iterator
*
iter
)
;
void
try_shrink
(
)
;
iterator
internal_end
(
iterator
iter
)
{
return
iter
.
node
!
=
nullptr
?
iter
:
end
(
)
;
}
const_iterator
internal_end
(
const_iterator
iter
)
const
{
return
iter
.
node
!
=
nullptr
?
iter
:
end
(
)
;
}
template
<
typename
.
.
.
Args
>
iterator
internal_emplace
(
iterator
iter
Args
&
&
.
.
.
args
)
;
template
<
typename
IterType
>
static
IterType
internal_last
(
IterType
iter
)
;
template
<
typename
K
>
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
internal_locate
(
const
K
&
key
)
const
;
template
<
typename
K
>
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
internal_lower_bound
(
const
K
&
key
)
const
;
template
<
typename
K
>
iterator
internal_upper_bound
(
const
K
&
key
)
const
;
template
<
typename
K
>
iterator
internal_find
(
const
K
&
key
)
const
;
int
internal_verify
(
const
node_type
*
node
const
key_type
*
lo
const
key_type
*
hi
)
const
;
node_stats
internal_stats
(
const
node_type
*
node
)
const
{
if
(
node
=
=
nullptr
|
|
(
node
=
=
root
(
)
&
&
empty
(
)
)
)
{
return
node_stats
(
0
0
)
;
}
if
(
node
-
>
leaf
(
)
)
{
return
node_stats
(
1
0
)
;
}
node_stats
res
(
0
1
)
;
for
(
int
i
=
node
-
>
start
(
)
;
i
<
=
node
-
>
finish
(
)
;
+
+
i
)
{
res
+
=
internal_stats
(
node
-
>
child
(
i
)
)
;
}
return
res
;
}
absl
:
:
container_internal
:
:
CompressedTuple
<
key_compare
allocator_type
node_type
*
>
root_
;
node_type
*
rightmost_
;
size_type
size_
;
}
;
template
<
typename
P
>
template
<
typename
.
.
.
Args
>
inline
void
btree_node
<
P
>
:
:
emplace_value
(
const
size_type
i
allocator_type
*
alloc
Args
&
&
.
.
.
args
)
{
assert
(
i
>
=
start
(
)
)
;
assert
(
i
<
=
finish
(
)
)
;
if
(
i
<
finish
(
)
)
{
transfer_n_backward
(
finish
(
)
-
i
i
+
1
i
this
alloc
)
;
}
value_init
(
i
alloc
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
set_finish
(
finish
(
)
+
1
)
;
if
(
!
leaf
(
)
&
&
finish
(
)
>
i
+
1
)
{
for
(
int
j
=
finish
(
)
;
j
>
i
+
1
;
-
-
j
)
{
set_child
(
j
child
(
j
-
1
)
)
;
}
clear_child
(
i
+
1
)
;
}
}
template
<
typename
P
>
inline
void
btree_node
<
P
>
:
:
remove_values
(
const
field_type
i
const
field_type
to_erase
allocator_type
*
alloc
)
{
value_destroy_n
(
i
to_erase
alloc
)
;
const
field_type
orig_finish
=
finish
(
)
;
const
field_type
src_i
=
i
+
to_erase
;
transfer_n
(
orig_finish
-
src_i
i
src_i
this
alloc
)
;
if
(
!
leaf
(
)
)
{
for
(
int
j
=
0
;
j
<
to_erase
;
+
+
j
)
{
clear_and_delete
(
child
(
i
+
j
+
1
)
alloc
)
;
}
for
(
int
j
=
i
+
to_erase
+
1
;
j
<
=
orig_finish
;
+
+
j
)
{
set_child
(
j
-
to_erase
child
(
j
)
)
;
clear_child
(
j
)
;
}
}
set_finish
(
orig_finish
-
to_erase
)
;
}
template
<
typename
P
>
void
btree_node
<
P
>
:
:
rebalance_right_to_left
(
const
int
to_move
btree_node
*
right
allocator_type
*
alloc
)
{
assert
(
parent
(
)
=
=
right
-
>
parent
(
)
)
;
assert
(
position
(
)
+
1
=
=
right
-
>
position
(
)
)
;
assert
(
right
-
>
count
(
)
>
=
count
(
)
)
;
assert
(
to_move
>
=
1
)
;
assert
(
to_move
<
=
right
-
>
count
(
)
)
;
transfer
(
finish
(
)
position
(
)
parent
(
)
alloc
)
;
transfer_n
(
to_move
-
1
finish
(
)
+
1
right
-
>
start
(
)
right
alloc
)
;
parent
(
)
-
>
transfer
(
position
(
)
right
-
>
start
(
)
+
to_move
-
1
right
alloc
)
;
right
-
>
transfer_n
(
right
-
>
count
(
)
-
to_move
right
-
>
start
(
)
right
-
>
start
(
)
+
to_move
right
alloc
)
;
if
(
!
leaf
(
)
)
{
for
(
int
i
=
0
;
i
<
to_move
;
+
+
i
)
{
init_child
(
finish
(
)
+
i
+
1
right
-
>
child
(
i
)
)
;
}
for
(
int
i
=
right
-
>
start
(
)
;
i
<
=
right
-
>
finish
(
)
-
to_move
;
+
+
i
)
{
assert
(
i
+
to_move
<
=
right
-
>
max_count
(
)
)
;
right
-
>
init_child
(
i
right
-
>
child
(
i
+
to_move
)
)
;
right
-
>
clear_child
(
i
+
to_move
)
;
}
}
set_finish
(
finish
(
)
+
to_move
)
;
right
-
>
set_finish
(
right
-
>
finish
(
)
-
to_move
)
;
}
template
<
typename
P
>
void
btree_node
<
P
>
:
:
rebalance_left_to_right
(
const
int
to_move
btree_node
*
right
allocator_type
*
alloc
)
{
assert
(
parent
(
)
=
=
right
-
>
parent
(
)
)
;
assert
(
position
(
)
+
1
=
=
right
-
>
position
(
)
)
;
assert
(
count
(
)
>
=
right
-
>
count
(
)
)
;
assert
(
to_move
>
=
1
)
;
assert
(
to_move
<
=
count
(
)
)
;
right
-
>
transfer_n_backward
(
right
-
>
count
(
)
right
-
>
start
(
)
+
to_move
right
-
>
start
(
)
right
alloc
)
;
right
-
>
transfer
(
right
-
>
start
(
)
+
to_move
-
1
position
(
)
parent
(
)
alloc
)
;
right
-
>
transfer_n
(
to_move
-
1
right
-
>
start
(
)
finish
(
)
-
(
to_move
-
1
)
this
alloc
)
;
parent
(
)
-
>
transfer
(
position
(
)
finish
(
)
-
to_move
this
alloc
)
;
if
(
!
leaf
(
)
)
{
for
(
int
i
=
right
-
>
finish
(
)
;
i
>
=
right
-
>
start
(
)
;
-
-
i
)
{
right
-
>
init_child
(
i
+
to_move
right
-
>
child
(
i
)
)
;
right
-
>
clear_child
(
i
)
;
}
for
(
int
i
=
1
;
i
<
=
to_move
;
+
+
i
)
{
right
-
>
init_child
(
i
-
1
child
(
finish
(
)
-
to_move
+
i
)
)
;
clear_child
(
finish
(
)
-
to_move
+
i
)
;
}
}
set_finish
(
finish
(
)
-
to_move
)
;
right
-
>
set_finish
(
right
-
>
finish
(
)
+
to_move
)
;
}
template
<
typename
P
>
void
btree_node
<
P
>
:
:
split
(
const
int
insert_position
btree_node
*
dest
allocator_type
*
alloc
)
{
assert
(
dest
-
>
count
(
)
=
=
0
)
;
assert
(
max_count
(
)
=
=
kNodeSlots
)
;
if
(
insert_position
=
=
start
(
)
)
{
dest
-
>
set_finish
(
dest
-
>
start
(
)
+
finish
(
)
-
1
)
;
}
else
if
(
insert_position
=
=
kNodeSlots
)
{
dest
-
>
set_finish
(
dest
-
>
start
(
)
)
;
}
else
{
dest
-
>
set_finish
(
dest
-
>
start
(
)
+
count
(
)
/
2
)
;
}
set_finish
(
finish
(
)
-
dest
-
>
count
(
)
)
;
assert
(
count
(
)
>
=
1
)
;
dest
-
>
transfer_n
(
dest
-
>
count
(
)
dest
-
>
start
(
)
finish
(
)
this
alloc
)
;
-
-
mutable_finish
(
)
;
parent
(
)
-
>
emplace_value
(
position
(
)
alloc
finish_slot
(
)
)
;
value_destroy
(
finish
(
)
alloc
)
;
parent
(
)
-
>
init_child
(
position
(
)
+
1
dest
)
;
if
(
!
leaf
(
)
)
{
for
(
int
i
=
dest
-
>
start
(
)
j
=
finish
(
)
+
1
;
i
<
=
dest
-
>
finish
(
)
;
+
+
i
+
+
j
)
{
assert
(
child
(
j
)
!
=
nullptr
)
;
dest
-
>
init_child
(
i
child
(
j
)
)
;
clear_child
(
j
)
;
}
}
}
template
<
typename
P
>
void
btree_node
<
P
>
:
:
merge
(
btree_node
*
src
allocator_type
*
alloc
)
{
assert
(
parent
(
)
=
=
src
-
>
parent
(
)
)
;
assert
(
position
(
)
+
1
=
=
src
-
>
position
(
)
)
;
value_init
(
finish
(
)
alloc
parent
(
)
-
>
slot
(
position
(
)
)
)
;
transfer_n
(
src
-
>
count
(
)
finish
(
)
+
1
src
-
>
start
(
)
src
alloc
)
;
if
(
!
leaf
(
)
)
{
for
(
int
i
=
src
-
>
start
(
)
j
=
finish
(
)
+
1
;
i
<
=
src
-
>
finish
(
)
;
+
+
i
+
+
j
)
{
init_child
(
j
src
-
>
child
(
i
)
)
;
src
-
>
clear_child
(
i
)
;
}
}
set_finish
(
start
(
)
+
1
+
count
(
)
+
src
-
>
count
(
)
)
;
src
-
>
set_finish
(
src
-
>
start
(
)
)
;
parent
(
)
-
>
remove_values
(
position
(
)
1
alloc
)
;
}
template
<
typename
P
>
void
btree_node
<
P
>
:
:
clear_and_delete
(
btree_node
*
node
allocator_type
*
alloc
)
{
if
(
node
-
>
leaf
(
)
)
{
node
-
>
value_destroy_n
(
node
-
>
start
(
)
node
-
>
count
(
)
alloc
)
;
deallocate
(
LeafSize
(
node
-
>
max_count
(
)
)
node
alloc
)
;
return
;
}
if
(
node
-
>
count
(
)
=
=
0
)
{
deallocate
(
InternalSize
(
)
node
alloc
)
;
return
;
}
btree_node
*
delete_root_parent
=
node
-
>
parent
(
)
;
while
(
!
node
-
>
leaf
(
)
)
node
=
node
-
>
start_child
(
)
;
int
pos
=
node
-
>
position
(
)
;
btree_node
*
parent
=
node
-
>
parent
(
)
;
for
(
;
;
)
{
assert
(
pos
<
=
parent
-
>
finish
(
)
)
;
do
{
node
=
parent
-
>
child
(
pos
)
;
if
(
!
node
-
>
leaf
(
)
)
{
while
(
!
node
-
>
leaf
(
)
)
node
=
node
-
>
start_child
(
)
;
pos
=
node
-
>
position
(
)
;
parent
=
node
-
>
parent
(
)
;
}
node
-
>
value_destroy_n
(
node
-
>
start
(
)
node
-
>
count
(
)
alloc
)
;
deallocate
(
LeafSize
(
node
-
>
max_count
(
)
)
node
alloc
)
;
+
+
pos
;
}
while
(
pos
<
=
parent
-
>
finish
(
)
)
;
assert
(
pos
>
parent
-
>
finish
(
)
)
;
do
{
node
=
parent
;
pos
=
node
-
>
position
(
)
;
parent
=
node
-
>
parent
(
)
;
node
-
>
value_destroy_n
(
node
-
>
start
(
)
node
-
>
count
(
)
alloc
)
;
deallocate
(
InternalSize
(
)
node
alloc
)
;
if
(
parent
=
=
delete_root_parent
)
return
;
+
+
pos
;
}
while
(
pos
>
parent
-
>
finish
(
)
)
;
}
}
template
<
typename
N
typename
R
typename
P
>
void
btree_iterator
<
N
R
P
>
:
:
increment_slow
(
)
{
if
(
node
-
>
leaf
(
)
)
{
assert
(
position
>
=
node
-
>
finish
(
)
)
;
btree_iterator
save
(
*
this
)
;
while
(
position
=
=
node
-
>
finish
(
)
&
&
!
node
-
>
is_root
(
)
)
{
assert
(
node
-
>
parent
(
)
-
>
child
(
node
-
>
position
(
)
)
=
=
node
)
;
position
=
node
-
>
position
(
)
;
node
=
node
-
>
parent
(
)
;
}
if
(
position
=
=
node
-
>
finish
(
)
)
{
*
this
=
save
;
}
}
else
{
assert
(
position
<
node
-
>
finish
(
)
)
;
node
=
node
-
>
child
(
position
+
1
)
;
while
(
!
node
-
>
leaf
(
)
)
{
node
=
node
-
>
start_child
(
)
;
}
position
=
node
-
>
start
(
)
;
}
}
template
<
typename
N
typename
R
typename
P
>
void
btree_iterator
<
N
R
P
>
:
:
decrement_slow
(
)
{
if
(
node
-
>
leaf
(
)
)
{
assert
(
position
<
=
-
1
)
;
btree_iterator
save
(
*
this
)
;
while
(
position
<
node
-
>
start
(
)
&
&
!
node
-
>
is_root
(
)
)
{
assert
(
node
-
>
parent
(
)
-
>
child
(
node
-
>
position
(
)
)
=
=
node
)
;
position
=
node
-
>
position
(
)
-
1
;
node
=
node
-
>
parent
(
)
;
}
if
(
position
<
node
-
>
start
(
)
)
{
*
this
=
save
;
}
}
else
{
assert
(
position
>
=
node
-
>
start
(
)
)
;
node
=
node
-
>
child
(
position
)
;
while
(
!
node
-
>
leaf
(
)
)
{
node
=
node
-
>
child
(
node
-
>
finish
(
)
)
;
}
position
=
node
-
>
finish
(
)
-
1
;
}
}
template
<
typename
P
>
template
<
typename
Btree
>
void
btree
<
P
>
:
:
copy_or_move_values_in_order
(
Btree
&
other
)
{
static_assert
(
std
:
:
is_same
<
btree
Btree
>
:
:
value
|
|
std
:
:
is_same
<
const
btree
Btree
>
:
:
value
"
Btree
type
must
be
same
or
const
.
"
)
;
assert
(
empty
(
)
)
;
auto
iter
=
other
.
begin
(
)
;
if
(
iter
=
=
other
.
end
(
)
)
return
;
insert_multi
(
maybe_move_from_iterator
(
iter
)
)
;
+
+
iter
;
for
(
;
iter
!
=
other
.
end
(
)
;
+
+
iter
)
{
internal_emplace
(
end
(
)
maybe_move_from_iterator
(
iter
)
)
;
}
}
template
<
typename
P
>
constexpr
bool
btree
<
P
>
:
:
static_assert_validation
(
)
{
static_assert
(
std
:
:
is_nothrow_copy_constructible
<
key_compare
>
:
:
value
"
Key
comparison
must
be
nothrow
copy
constructible
"
)
;
static_assert
(
std
:
:
is_nothrow_copy_constructible
<
allocator_type
>
:
:
value
"
Allocator
must
be
nothrow
copy
constructible
"
)
;
static_assert
(
type_traits_internal
:
:
is_trivially_copyable
<
iterator
>
:
:
value
"
iterator
not
trivially
copyable
.
"
)
;
static_assert
(
kNodeSlots
<
(
1
<
<
(
8
*
sizeof
(
typename
node_type
:
:
field_type
)
)
)
"
target
node
size
too
large
"
)
;
using
compare_result_type
=
absl
:
:
result_of_t
<
key_compare
(
key_type
key_type
)
>
;
static_assert
(
std
:
:
is_same
<
compare_result_type
bool
>
:
:
value
|
|
std
:
:
is_convertible
<
compare_result_type
absl
:
:
weak_ordering
>
:
:
value
"
key
comparison
function
must
return
absl
:
:
{
weak
strong
}
_ordering
or
"
"
bool
.
"
)
;
static_assert
(
node_type
:
:
MinimumOverhead
(
)
>
=
sizeof
(
void
*
)
+
4
"
node
space
assumption
incorrect
"
)
;
return
true
;
}
template
<
typename
P
>
template
<
typename
K
>
auto
btree
<
P
>
:
:
lower_bound_equal
(
const
K
&
key
)
const
-
>
std
:
:
pair
<
iterator
bool
>
{
const
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
res
=
internal_lower_bound
(
key
)
;
const
iterator
lower
=
iterator
(
internal_end
(
res
.
value
)
)
;
const
bool
equal
=
res
.
HasMatch
(
)
?
res
.
IsEq
(
)
:
lower
!
=
end
(
)
&
&
!
compare_keys
(
key
lower
.
key
(
)
)
;
return
{
lower
equal
}
;
}
template
<
typename
P
>
template
<
typename
K
>
auto
btree
<
P
>
:
:
equal_range
(
const
K
&
key
)
-
>
std
:
:
pair
<
iterator
iterator
>
{
const
std
:
:
pair
<
iterator
bool
>
lower_and_equal
=
lower_bound_equal
(
key
)
;
const
iterator
lower
=
lower_and_equal
.
first
;
if
(
!
lower_and_equal
.
second
)
{
return
{
lower
lower
}
;
}
const
iterator
next
=
std
:
:
next
(
lower
)
;
if
(
!
params_type
:
:
template
can_have_multiple_equivalent_keys
<
K
>
(
)
)
{
assert
(
next
=
=
end
(
)
|
|
compare_keys
(
key
next
.
key
(
)
)
)
;
return
{
lower
next
}
;
}
if
(
next
=
=
end
(
)
|
|
compare_keys
(
key
next
.
key
(
)
)
)
return
{
lower
next
}
;
return
{
lower
upper_bound
(
key
)
}
;
}
template
<
typename
P
>
template
<
typename
K
typename
.
.
.
Args
>
auto
btree
<
P
>
:
:
insert_unique
(
const
K
&
key
Args
&
&
.
.
.
args
)
-
>
std
:
:
pair
<
iterator
bool
>
{
if
(
empty
(
)
)
{
mutable_root
(
)
=
rightmost_
=
new_leaf_root_node
(
1
)
;
}
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
res
=
internal_locate
(
key
)
;
iterator
iter
=
res
.
value
;
if
(
res
.
HasMatch
(
)
)
{
if
(
res
.
IsEq
(
)
)
{
return
{
iter
false
}
;
}
}
else
{
iterator
last
=
internal_last
(
iter
)
;
if
(
last
.
node
&
&
!
compare_keys
(
key
last
.
key
(
)
)
)
{
return
{
last
false
}
;
}
}
return
{
internal_emplace
(
iter
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
true
}
;
}
template
<
typename
P
>
template
<
typename
K
typename
.
.
.
Args
>
inline
auto
btree
<
P
>
:
:
insert_hint_unique
(
iterator
position
const
K
&
key
Args
&
&
.
.
.
args
)
-
>
std
:
:
pair
<
iterator
bool
>
{
if
(
!
empty
(
)
)
{
if
(
position
=
=
end
(
)
|
|
compare_keys
(
key
position
.
key
(
)
)
)
{
if
(
position
=
=
begin
(
)
|
|
compare_keys
(
std
:
:
prev
(
position
)
.
key
(
)
key
)
)
{
return
{
internal_emplace
(
position
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
true
}
;
}
}
else
if
(
compare_keys
(
position
.
key
(
)
key
)
)
{
+
+
position
;
if
(
position
=
=
end
(
)
|
|
compare_keys
(
key
position
.
key
(
)
)
)
{
return
{
internal_emplace
(
position
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
true
}
;
}
}
else
{
return
{
position
false
}
;
}
}
return
insert_unique
(
key
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
P
>
template
<
typename
InputIterator
typename
>
void
btree
<
P
>
:
:
insert_iterator_unique
(
InputIterator
b
InputIterator
e
int
)
{
for
(
;
b
!
=
e
;
+
+
b
)
{
insert_hint_unique
(
end
(
)
params_type
:
:
key
(
*
b
)
*
b
)
;
}
}
template
<
typename
P
>
template
<
typename
InputIterator
>
void
btree
<
P
>
:
:
insert_iterator_unique
(
InputIterator
b
InputIterator
e
char
)
{
for
(
;
b
!
=
e
;
+
+
b
)
{
init_type
value
(
*
b
)
;
insert_hint_unique
(
end
(
)
params_type
:
:
key
(
value
)
std
:
:
move
(
value
)
)
;
}
}
template
<
typename
P
>
template
<
typename
ValueType
>
auto
btree
<
P
>
:
:
insert_multi
(
const
key_type
&
key
ValueType
&
&
v
)
-
>
iterator
{
if
(
empty
(
)
)
{
mutable_root
(
)
=
rightmost_
=
new_leaf_root_node
(
1
)
;
}
iterator
iter
=
internal_upper_bound
(
key
)
;
if
(
iter
.
node
=
=
nullptr
)
{
iter
=
end
(
)
;
}
return
internal_emplace
(
iter
std
:
:
forward
<
ValueType
>
(
v
)
)
;
}
template
<
typename
P
>
template
<
typename
ValueType
>
auto
btree
<
P
>
:
:
insert_hint_multi
(
iterator
position
ValueType
&
&
v
)
-
>
iterator
{
if
(
!
empty
(
)
)
{
const
key_type
&
key
=
params_type
:
:
key
(
v
)
;
if
(
position
=
=
end
(
)
|
|
!
compare_keys
(
position
.
key
(
)
key
)
)
{
if
(
position
=
=
begin
(
)
|
|
!
compare_keys
(
key
std
:
:
prev
(
position
)
.
key
(
)
)
)
{
return
internal_emplace
(
position
std
:
:
forward
<
ValueType
>
(
v
)
)
;
}
}
else
{
+
+
position
;
if
(
position
=
=
end
(
)
|
|
!
compare_keys
(
position
.
key
(
)
key
)
)
{
return
internal_emplace
(
position
std
:
:
forward
<
ValueType
>
(
v
)
)
;
}
}
}
return
insert_multi
(
std
:
:
forward
<
ValueType
>
(
v
)
)
;
}
template
<
typename
P
>
template
<
typename
InputIterator
>
void
btree
<
P
>
:
:
insert_iterator_multi
(
InputIterator
b
InputIterator
e
)
{
for
(
;
b
!
=
e
;
+
+
b
)
{
insert_hint_multi
(
end
(
)
*
b
)
;
}
}
template
<
typename
P
>
auto
btree
<
P
>
:
:
operator
=
(
const
btree
&
other
)
-
>
btree
&
{
if
(
this
!
=
&
other
)
{
clear
(
)
;
*
mutable_key_comp
(
)
=
other
.
key_comp
(
)
;
if
(
absl
:
:
allocator_traits
<
allocator_type
>
:
:
propagate_on_container_copy_assignment
:
:
value
)
{
*
mutable_allocator
(
)
=
other
.
allocator
(
)
;
}
copy_or_move_values_in_order
(
other
)
;
}
return
*
this
;
}
template
<
typename
P
>
auto
btree
<
P
>
:
:
operator
=
(
btree
&
&
other
)
noexcept
-
>
btree
&
{
if
(
this
!
=
&
other
)
{
clear
(
)
;
using
std
:
:
swap
;
if
(
absl
:
:
allocator_traits
<
allocator_type
>
:
:
propagate_on_container_copy_assignment
:
:
value
)
{
swap
(
root_
other
.
root_
)
;
swap
(
rightmost_
other
.
rightmost_
)
;
swap
(
size_
other
.
size_
)
;
}
else
{
if
(
allocator
(
)
=
=
other
.
allocator
(
)
)
{
swap
(
mutable_root
(
)
other
.
mutable_root
(
)
)
;
swap
(
*
mutable_key_comp
(
)
*
other
.
mutable_key_comp
(
)
)
;
swap
(
rightmost_
other
.
rightmost_
)
;
swap
(
size_
other
.
size_
)
;
}
else
{
*
mutable_key_comp
(
)
=
other
.
key_comp
(
)
;
copy_or_move_values_in_order
(
other
)
;
}
}
}
return
*
this
;
}
template
<
typename
P
>
auto
btree
<
P
>
:
:
erase
(
iterator
iter
)
-
>
iterator
{
bool
internal_delete
=
false
;
if
(
!
iter
.
node
-
>
leaf
(
)
)
{
iterator
internal_iter
(
iter
)
;
-
-
iter
;
assert
(
iter
.
node
-
>
leaf
(
)
)
;
params_type
:
:
move
(
mutable_allocator
(
)
iter
.
node
-
>
slot
(
iter
.
position
)
internal_iter
.
node
-
>
slot
(
internal_iter
.
position
)
)
;
internal_delete
=
true
;
}
iter
.
node
-
>
remove_values
(
iter
.
position
1
mutable_allocator
(
)
)
;
-
-
size_
;
iterator
res
=
rebalance_after_delete
(
iter
)
;
if
(
internal_delete
)
{
+
+
res
;
}
return
res
;
}
template
<
typename
P
>
auto
btree
<
P
>
:
:
rebalance_after_delete
(
iterator
iter
)
-
>
iterator
{
iterator
res
(
iter
)
;
bool
first_iteration
=
true
;
for
(
;
;
)
{
if
(
iter
.
node
=
=
root
(
)
)
{
try_shrink
(
)
;
if
(
empty
(
)
)
{
return
end
(
)
;
}
break
;
}
if
(
iter
.
node
-
>
count
(
)
>
=
kMinNodeValues
)
{
break
;
}
bool
merged
=
try_merge_or_rebalance
(
&
iter
)
;
if
(
first_iteration
)
{
res
=
iter
;
first_iteration
=
false
;
}
if
(
!
merged
)
{
break
;
}
iter
.
position
=
iter
.
node
-
>
position
(
)
;
iter
.
node
=
iter
.
node
-
>
parent
(
)
;
}
if
(
res
.
position
=
=
res
.
node
-
>
finish
(
)
)
{
res
.
position
=
res
.
node
-
>
finish
(
)
-
1
;
+
+
res
;
}
return
res
;
}
template
<
typename
P
>
auto
btree
<
P
>
:
:
erase_range
(
iterator
begin
iterator
end
)
-
>
std
:
:
pair
<
size_type
iterator
>
{
difference_type
count
=
std
:
:
distance
(
begin
end
)
;
assert
(
count
>
=
0
)
;
if
(
count
=
=
0
)
{
return
{
0
begin
}
;
}
if
(
count
=
=
size_
)
{
clear
(
)
;
return
{
count
this
-
>
end
(
)
}
;
}
if
(
begin
.
node
=
=
end
.
node
)
{
assert
(
end
.
position
>
begin
.
position
)
;
begin
.
node
-
>
remove_values
(
begin
.
position
end
.
position
-
begin
.
position
mutable_allocator
(
)
)
;
size_
-
=
count
;
return
{
count
rebalance_after_delete
(
begin
)
}
;
}
const
size_type
target_size
=
size_
-
count
;
while
(
size_
>
target_size
)
{
if
(
begin
.
node
-
>
leaf
(
)
)
{
const
size_type
remaining_to_erase
=
size_
-
target_size
;
const
size_type
remaining_in_node
=
begin
.
node
-
>
finish
(
)
-
begin
.
position
;
const
size_type
to_erase
=
(
std
:
:
min
)
(
remaining_to_erase
remaining_in_node
)
;
begin
.
node
-
>
remove_values
(
begin
.
position
to_erase
mutable_allocator
(
)
)
;
size_
-
=
to_erase
;
begin
=
rebalance_after_delete
(
begin
)
;
}
else
{
begin
=
erase
(
begin
)
;
}
}
return
{
count
begin
}
;
}
template
<
typename
P
>
void
btree
<
P
>
:
:
clear
(
)
{
if
(
!
empty
(
)
)
{
node_type
:
:
clear_and_delete
(
root
(
)
mutable_allocator
(
)
)
;
}
mutable_root
(
)
=
EmptyNode
(
)
;
rightmost_
=
EmptyNode
(
)
;
size_
=
0
;
}
template
<
typename
P
>
void
btree
<
P
>
:
:
swap
(
btree
&
other
)
{
using
std
:
:
swap
;
if
(
absl
:
:
allocator_traits
<
allocator_type
>
:
:
propagate_on_container_swap
:
:
value
)
{
swap
(
root_
other
.
root_
)
;
}
else
{
assert
(
allocator
(
)
=
=
other
.
allocator
(
)
)
;
swap
(
mutable_root
(
)
other
.
mutable_root
(
)
)
;
swap
(
*
mutable_key_comp
(
)
*
other
.
mutable_key_comp
(
)
)
;
}
swap
(
rightmost_
other
.
rightmost_
)
;
swap
(
size_
other
.
size_
)
;
}
template
<
typename
P
>
void
btree
<
P
>
:
:
verify
(
)
const
{
assert
(
root
(
)
!
=
nullptr
)
;
assert
(
leftmost
(
)
!
=
nullptr
)
;
assert
(
rightmost_
!
=
nullptr
)
;
assert
(
empty
(
)
|
|
size
(
)
=
=
internal_verify
(
root
(
)
nullptr
nullptr
)
)
;
assert
(
leftmost
(
)
=
=
(
+
+
const_iterator
(
root
(
)
-
1
)
)
.
node
)
;
assert
(
rightmost_
=
=
(
-
-
const_iterator
(
root
(
)
root
(
)
-
>
finish
(
)
)
)
.
node
)
;
assert
(
leftmost
(
)
-
>
leaf
(
)
)
;
assert
(
rightmost_
-
>
leaf
(
)
)
;
}
template
<
typename
P
>
void
btree
<
P
>
:
:
rebalance_or_split
(
iterator
*
iter
)
{
node_type
*
&
node
=
iter
-
>
node
;
int
&
insert_position
=
iter
-
>
position
;
assert
(
node
-
>
count
(
)
=
=
node
-
>
max_count
(
)
)
;
assert
(
kNodeSlots
=
=
node
-
>
max_count
(
)
)
;
node_type
*
parent
=
node
-
>
parent
(
)
;
if
(
node
!
=
root
(
)
)
{
if
(
node
-
>
position
(
)
>
parent
-
>
start
(
)
)
{
node_type
*
left
=
parent
-
>
child
(
node
-
>
position
(
)
-
1
)
;
assert
(
left
-
>
max_count
(
)
=
=
kNodeSlots
)
;
if
(
left
-
>
count
(
)
<
kNodeSlots
)
{
int
to_move
=
(
kNodeSlots
-
left
-
>
count
(
)
)
/
(
1
+
(
insert_position
<
static_cast
<
int
>
(
kNodeSlots
)
)
)
;
to_move
=
(
std
:
:
max
)
(
1
to_move
)
;
if
(
insert_position
-
to_move
>
=
node
-
>
start
(
)
|
|
left
-
>
count
(
)
+
to_move
<
static_cast
<
int
>
(
kNodeSlots
)
)
{
left
-
>
rebalance_right_to_left
(
to_move
node
mutable_allocator
(
)
)
;
assert
(
node
-
>
max_count
(
)
-
node
-
>
count
(
)
=
=
to_move
)
;
insert_position
=
insert_position
-
to_move
;
if
(
insert_position
<
node
-
>
start
(
)
)
{
insert_position
=
insert_position
+
left
-
>
count
(
)
+
1
;
node
=
left
;
}
assert
(
node
-
>
count
(
)
<
node
-
>
max_count
(
)
)
;
return
;
}
}
}
if
(
node
-
>
position
(
)
<
parent
-
>
finish
(
)
)
{
node_type
*
right
=
parent
-
>
child
(
node
-
>
position
(
)
+
1
)
;
assert
(
right
-
>
max_count
(
)
=
=
kNodeSlots
)
;
if
(
right
-
>
count
(
)
<
kNodeSlots
)
{
int
to_move
=
(
static_cast
<
int
>
(
kNodeSlots
)
-
right
-
>
count
(
)
)
/
(
1
+
(
insert_position
>
node
-
>
start
(
)
)
)
;
to_move
=
(
std
:
:
max
)
(
1
to_move
)
;
if
(
insert_position
<
=
node
-
>
finish
(
)
-
to_move
|
|
right
-
>
count
(
)
+
to_move
<
static_cast
<
int
>
(
kNodeSlots
)
)
{
node
-
>
rebalance_left_to_right
(
to_move
right
mutable_allocator
(
)
)
;
if
(
insert_position
>
node
-
>
finish
(
)
)
{
insert_position
=
insert_position
-
node
-
>
count
(
)
-
1
;
node
=
right
;
}
assert
(
node
-
>
count
(
)
<
node
-
>
max_count
(
)
)
;
return
;
}
}
}
assert
(
parent
-
>
max_count
(
)
=
=
kNodeSlots
)
;
if
(
parent
-
>
count
(
)
=
=
kNodeSlots
)
{
iterator
parent_iter
(
node
-
>
parent
(
)
node
-
>
position
(
)
)
;
rebalance_or_split
(
&
parent_iter
)
;
}
}
else
{
parent
=
new_internal_node
(
parent
)
;
parent
-
>
init_child
(
parent
-
>
start
(
)
root
(
)
)
;
mutable_root
(
)
=
parent
;
assert
(
!
parent
-
>
start_child
(
)
-
>
leaf
(
)
|
|
parent
-
>
start_child
(
)
=
=
rightmost_
)
;
}
node_type
*
split_node
;
if
(
node
-
>
leaf
(
)
)
{
split_node
=
new_leaf_node
(
parent
)
;
node
-
>
split
(
insert_position
split_node
mutable_allocator
(
)
)
;
if
(
rightmost_
=
=
node
)
rightmost_
=
split_node
;
}
else
{
split_node
=
new_internal_node
(
parent
)
;
node
-
>
split
(
insert_position
split_node
mutable_allocator
(
)
)
;
}
if
(
insert_position
>
node
-
>
finish
(
)
)
{
insert_position
=
insert_position
-
node
-
>
count
(
)
-
1
;
node
=
split_node
;
}
}
template
<
typename
P
>
void
btree
<
P
>
:
:
merge_nodes
(
node_type
*
left
node_type
*
right
)
{
left
-
>
merge
(
right
mutable_allocator
(
)
)
;
if
(
rightmost_
=
=
right
)
rightmost_
=
left
;
}
template
<
typename
P
>
bool
btree
<
P
>
:
:
try_merge_or_rebalance
(
iterator
*
iter
)
{
node_type
*
parent
=
iter
-
>
node
-
>
parent
(
)
;
if
(
iter
-
>
node
-
>
position
(
)
>
parent
-
>
start
(
)
)
{
node_type
*
left
=
parent
-
>
child
(
iter
-
>
node
-
>
position
(
)
-
1
)
;
assert
(
left
-
>
max_count
(
)
=
=
kNodeSlots
)
;
if
(
1U
+
left
-
>
count
(
)
+
iter
-
>
node
-
>
count
(
)
<
=
kNodeSlots
)
{
iter
-
>
position
+
=
1
+
left
-
>
count
(
)
;
merge_nodes
(
left
iter
-
>
node
)
;
iter
-
>
node
=
left
;
return
true
;
}
}
if
(
iter
-
>
node
-
>
position
(
)
<
parent
-
>
finish
(
)
)
{
node_type
*
right
=
parent
-
>
child
(
iter
-
>
node
-
>
position
(
)
+
1
)
;
assert
(
right
-
>
max_count
(
)
=
=
kNodeSlots
)
;
if
(
1U
+
iter
-
>
node
-
>
count
(
)
+
right
-
>
count
(
)
<
=
kNodeSlots
)
{
merge_nodes
(
iter
-
>
node
right
)
;
return
true
;
}
if
(
right
-
>
count
(
)
>
kMinNodeValues
&
&
(
iter
-
>
node
-
>
count
(
)
=
=
0
|
|
iter
-
>
position
>
iter
-
>
node
-
>
start
(
)
)
)
{
int
to_move
=
(
right
-
>
count
(
)
-
iter
-
>
node
-
>
count
(
)
)
/
2
;
to_move
=
(
std
:
:
min
)
(
to_move
right
-
>
count
(
)
-
1
)
;
iter
-
>
node
-
>
rebalance_right_to_left
(
to_move
right
mutable_allocator
(
)
)
;
return
false
;
}
}
if
(
iter
-
>
node
-
>
position
(
)
>
parent
-
>
start
(
)
)
{
node_type
*
left
=
parent
-
>
child
(
iter
-
>
node
-
>
position
(
)
-
1
)
;
if
(
left
-
>
count
(
)
>
kMinNodeValues
&
&
(
iter
-
>
node
-
>
count
(
)
=
=
0
|
|
iter
-
>
position
<
iter
-
>
node
-
>
finish
(
)
)
)
{
int
to_move
=
(
left
-
>
count
(
)
-
iter
-
>
node
-
>
count
(
)
)
/
2
;
to_move
=
(
std
:
:
min
)
(
to_move
left
-
>
count
(
)
-
1
)
;
left
-
>
rebalance_left_to_right
(
to_move
iter
-
>
node
mutable_allocator
(
)
)
;
iter
-
>
position
+
=
to_move
;
return
false
;
}
}
return
false
;
}
template
<
typename
P
>
void
btree
<
P
>
:
:
try_shrink
(
)
{
node_type
*
orig_root
=
root
(
)
;
if
(
orig_root
-
>
count
(
)
>
0
)
{
return
;
}
if
(
orig_root
-
>
leaf
(
)
)
{
assert
(
size
(
)
=
=
0
)
;
mutable_root
(
)
=
rightmost_
=
EmptyNode
(
)
;
}
else
{
node_type
*
child
=
orig_root
-
>
start_child
(
)
;
child
-
>
make_root
(
)
;
mutable_root
(
)
=
child
;
}
node_type
:
:
clear_and_delete
(
orig_root
mutable_allocator
(
)
)
;
}
template
<
typename
P
>
template
<
typename
IterType
>
inline
IterType
btree
<
P
>
:
:
internal_last
(
IterType
iter
)
{
assert
(
iter
.
node
!
=
nullptr
)
;
while
(
iter
.
position
=
=
iter
.
node
-
>
finish
(
)
)
{
iter
.
position
=
iter
.
node
-
>
position
(
)
;
iter
.
node
=
iter
.
node
-
>
parent
(
)
;
if
(
iter
.
node
-
>
leaf
(
)
)
{
iter
.
node
=
nullptr
;
break
;
}
}
return
iter
;
}
template
<
typename
P
>
template
<
typename
.
.
.
Args
>
inline
auto
btree
<
P
>
:
:
internal_emplace
(
iterator
iter
Args
&
&
.
.
.
args
)
-
>
iterator
{
if
(
!
iter
.
node
-
>
leaf
(
)
)
{
-
-
iter
;
+
+
iter
.
position
;
}
const
field_type
max_count
=
iter
.
node
-
>
max_count
(
)
;
allocator_type
*
alloc
=
mutable_allocator
(
)
;
if
(
iter
.
node
-
>
count
(
)
=
=
max_count
)
{
if
(
max_count
<
kNodeSlots
)
{
assert
(
iter
.
node
=
=
root
(
)
)
;
iter
.
node
=
new_leaf_root_node
(
(
std
:
:
min
<
int
>
)
(
kNodeSlots
2
*
max_count
)
)
;
node_type
*
old_root
=
root
(
)
;
node_type
*
new_root
=
iter
.
node
;
new_root
-
>
transfer_n
(
old_root
-
>
count
(
)
new_root
-
>
start
(
)
old_root
-
>
start
(
)
old_root
alloc
)
;
new_root
-
>
set_finish
(
old_root
-
>
finish
(
)
)
;
old_root
-
>
set_finish
(
old_root
-
>
start
(
)
)
;
node_type
:
:
clear_and_delete
(
old_root
alloc
)
;
mutable_root
(
)
=
rightmost_
=
new_root
;
}
else
{
rebalance_or_split
(
&
iter
)
;
}
}
iter
.
node
-
>
emplace_value
(
iter
.
position
alloc
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
+
+
size_
;
return
iter
;
}
template
<
typename
P
>
template
<
typename
K
>
inline
auto
btree
<
P
>
:
:
internal_locate
(
const
K
&
key
)
const
-
>
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
{
iterator
iter
(
const_cast
<
node_type
*
>
(
root
(
)
)
)
;
for
(
;
;
)
{
SearchResult
<
int
is_key_compare_to
:
:
value
>
res
=
iter
.
node
-
>
lower_bound
(
key
key_comp
(
)
)
;
iter
.
position
=
res
.
value
;
if
(
res
.
IsEq
(
)
)
{
return
{
iter
MatchKind
:
:
kEq
}
;
}
if
(
iter
.
node
-
>
leaf
(
)
)
{
break
;
}
iter
.
node
=
iter
.
node
-
>
child
(
iter
.
position
)
;
}
return
{
iter
MatchKind
:
:
kNe
}
;
}
template
<
typename
P
>
template
<
typename
K
>
auto
btree
<
P
>
:
:
internal_lower_bound
(
const
K
&
key
)
const
-
>
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
{
if
(
!
params_type
:
:
template
can_have_multiple_equivalent_keys
<
K
>
(
)
)
{
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
ret
=
internal_locate
(
key
)
;
ret
.
value
=
internal_last
(
ret
.
value
)
;
return
ret
;
}
iterator
iter
(
const_cast
<
node_type
*
>
(
root
(
)
)
)
;
SearchResult
<
int
is_key_compare_to
:
:
value
>
res
;
bool
seen_eq
=
false
;
for
(
;
;
)
{
res
=
iter
.
node
-
>
lower_bound
(
key
key_comp
(
)
)
;
iter
.
position
=
res
.
value
;
if
(
iter
.
node
-
>
leaf
(
)
)
{
break
;
}
seen_eq
=
seen_eq
|
|
res
.
IsEq
(
)
;
iter
.
node
=
iter
.
node
-
>
child
(
iter
.
position
)
;
}
if
(
res
.
IsEq
(
)
)
return
{
iter
MatchKind
:
:
kEq
}
;
return
{
internal_last
(
iter
)
seen_eq
?
MatchKind
:
:
kEq
:
MatchKind
:
:
kNe
}
;
}
template
<
typename
P
>
template
<
typename
K
>
auto
btree
<
P
>
:
:
internal_upper_bound
(
const
K
&
key
)
const
-
>
iterator
{
iterator
iter
(
const_cast
<
node_type
*
>
(
root
(
)
)
)
;
for
(
;
;
)
{
iter
.
position
=
iter
.
node
-
>
upper_bound
(
key
key_comp
(
)
)
;
if
(
iter
.
node
-
>
leaf
(
)
)
{
break
;
}
iter
.
node
=
iter
.
node
-
>
child
(
iter
.
position
)
;
}
return
internal_last
(
iter
)
;
}
template
<
typename
P
>
template
<
typename
K
>
auto
btree
<
P
>
:
:
internal_find
(
const
K
&
key
)
const
-
>
iterator
{
SearchResult
<
iterator
is_key_compare_to
:
:
value
>
res
=
internal_locate
(
key
)
;
if
(
res
.
HasMatch
(
)
)
{
if
(
res
.
IsEq
(
)
)
{
return
res
.
value
;
}
}
else
{
const
iterator
iter
=
internal_last
(
res
.
value
)
;
if
(
iter
.
node
!
=
nullptr
&
&
!
compare_keys
(
key
iter
.
key
(
)
)
)
{
return
iter
;
}
}
return
{
nullptr
0
}
;
}
template
<
typename
P
>
int
btree
<
P
>
:
:
internal_verify
(
const
node_type
*
node
const
key_type
*
lo
const
key_type
*
hi
)
const
{
assert
(
node
-
>
count
(
)
>
0
)
;
assert
(
node
-
>
count
(
)
<
=
node
-
>
max_count
(
)
)
;
if
(
lo
)
{
assert
(
!
compare_keys
(
node
-
>
key
(
node
-
>
start
(
)
)
*
lo
)
)
;
}
if
(
hi
)
{
assert
(
!
compare_keys
(
*
hi
node
-
>
key
(
node
-
>
finish
(
)
-
1
)
)
)
;
}
for
(
int
i
=
node
-
>
start
(
)
+
1
;
i
<
node
-
>
finish
(
)
;
+
+
i
)
{
assert
(
!
compare_keys
(
node
-
>
key
(
i
)
node
-
>
key
(
i
-
1
)
)
)
;
}
int
count
=
node
-
>
count
(
)
;
if
(
!
node
-
>
leaf
(
)
)
{
for
(
int
i
=
node
-
>
start
(
)
;
i
<
=
node
-
>
finish
(
)
;
+
+
i
)
{
assert
(
node
-
>
child
(
i
)
!
=
nullptr
)
;
assert
(
node
-
>
child
(
i
)
-
>
parent
(
)
=
=
node
)
;
assert
(
node
-
>
child
(
i
)
-
>
position
(
)
=
=
i
)
;
count
+
=
internal_verify
(
node
-
>
child
(
i
)
i
=
=
node
-
>
start
(
)
?
lo
:
&
node
-
>
key
(
i
-
1
)
i
=
=
node
-
>
finish
(
)
?
hi
:
&
node
-
>
key
(
i
)
)
;
}
}
return
count
;
}
}
ABSL_NAMESPACE_END
}
#
endif
