#
ifndef
ABSL_CONTAINER_INTERNAL_HASH_FUNCTION_DEFAULTS_H_
#
define
ABSL_CONTAINER_INTERNAL_HASH_FUNCTION_DEFAULTS_H_
#
include
<
stdint
.
h
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
hash
/
hash
.
h
"
#
include
"
absl
/
strings
/
cord
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
#
include
<
string_view
>
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
class
T
class
E
=
void
>
struct
HashEq
{
using
Hash
=
absl
:
:
Hash
<
T
>
;
using
Eq
=
std
:
:
equal_to
<
T
>
;
}
;
struct
StringHash
{
using
is_transparent
=
void
;
size_t
operator
(
)
(
absl
:
:
string_view
v
)
const
{
return
absl
:
:
Hash
<
absl
:
:
string_view
>
{
}
(
v
)
;
}
size_t
operator
(
)
(
const
absl
:
:
Cord
&
v
)
const
{
return
absl
:
:
Hash
<
absl
:
:
Cord
>
{
}
(
v
)
;
}
}
;
struct
StringEq
{
using
is_transparent
=
void
;
bool
operator
(
)
(
absl
:
:
string_view
lhs
absl
:
:
string_view
rhs
)
const
{
return
lhs
=
=
rhs
;
}
bool
operator
(
)
(
const
absl
:
:
Cord
&
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
lhs
=
=
rhs
;
}
bool
operator
(
)
(
const
absl
:
:
Cord
&
lhs
absl
:
:
string_view
rhs
)
const
{
return
lhs
=
=
rhs
;
}
bool
operator
(
)
(
absl
:
:
string_view
lhs
const
absl
:
:
Cord
&
rhs
)
const
{
return
lhs
=
=
rhs
;
}
}
;
struct
StringHashEq
{
using
Hash
=
StringHash
;
using
Eq
=
StringEq
;
}
;
template
<
>
struct
HashEq
<
std
:
:
string
>
:
StringHashEq
{
}
;
template
<
>
struct
HashEq
<
absl
:
:
string_view
>
:
StringHashEq
{
}
;
template
<
>
struct
HashEq
<
absl
:
:
Cord
>
:
StringHashEq
{
}
;
#
ifdef
ABSL_HAVE_STD_STRING_VIEW
template
<
typename
TChar
>
struct
BasicStringHash
{
using
is_transparent
=
void
;
size_t
operator
(
)
(
std
:
:
basic_string_view
<
TChar
>
v
)
const
{
return
absl
:
:
Hash
<
std
:
:
basic_string_view
<
TChar
>
>
{
}
(
v
)
;
}
}
;
template
<
typename
TChar
>
struct
BasicStringEq
{
using
is_transparent
=
void
;
bool
operator
(
)
(
std
:
:
basic_string_view
<
TChar
>
lhs
std
:
:
basic_string_view
<
TChar
>
rhs
)
const
{
return
lhs
=
=
rhs
;
}
}
;
template
<
typename
TChar
>
struct
BasicStringHashEq
{
using
Hash
=
BasicStringHash
<
TChar
>
;
using
Eq
=
BasicStringEq
<
TChar
>
;
}
;
template
<
>
struct
HashEq
<
std
:
:
wstring
>
:
BasicStringHashEq
<
wchar_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
wstring_view
>
:
BasicStringHashEq
<
wchar_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u16string
>
:
BasicStringHashEq
<
char16_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u16string_view
>
:
BasicStringHashEq
<
char16_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u32string
>
:
BasicStringHashEq
<
char32_t
>
{
}
;
template
<
>
struct
HashEq
<
std
:
:
u32string_view
>
:
BasicStringHashEq
<
char32_t
>
{
}
;
#
endif
template
<
class
T
>
struct
HashEq
<
T
*
>
{
struct
Hash
{
using
is_transparent
=
void
;
template
<
class
U
>
size_t
operator
(
)
(
const
U
&
ptr
)
const
{
return
absl
:
:
Hash
<
const
T
*
>
{
}
(
HashEq
:
:
ToPtr
(
ptr
)
)
;
}
}
;
struct
Eq
{
using
is_transparent
=
void
;
template
<
class
A
class
B
>
bool
operator
(
)
(
const
A
&
a
const
B
&
b
)
const
{
return
HashEq
:
:
ToPtr
(
a
)
=
=
HashEq
:
:
ToPtr
(
b
)
;
}
}
;
private
:
static
const
T
*
ToPtr
(
const
T
*
ptr
)
{
return
ptr
;
}
template
<
class
U
class
D
>
static
const
T
*
ToPtr
(
const
std
:
:
unique_ptr
<
U
D
>
&
ptr
)
{
return
ptr
.
get
(
)
;
}
template
<
class
U
>
static
const
T
*
ToPtr
(
const
std
:
:
shared_ptr
<
U
>
&
ptr
)
{
return
ptr
.
get
(
)
;
}
}
;
template
<
class
T
class
D
>
struct
HashEq
<
std
:
:
unique_ptr
<
T
D
>
>
:
HashEq
<
T
*
>
{
}
;
template
<
class
T
>
struct
HashEq
<
std
:
:
shared_ptr
<
T
>
>
:
HashEq
<
T
*
>
{
}
;
template
<
class
T
>
using
hash_default_hash
=
typename
container_internal
:
:
HashEq
<
T
>
:
:
Hash
;
template
<
class
T
>
using
hash_default_eq
=
typename
container_internal
:
:
HashEq
<
T
>
:
:
Eq
;
}
ABSL_NAMESPACE_END
}
#
endif
