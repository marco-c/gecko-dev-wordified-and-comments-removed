#
include
"
absl
/
container
/
internal
/
raw_hash_set
.
h
"
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
"
absl
/
base
/
config
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
alignas
(
16
)
ABSL_CONST_INIT
ABSL_DLL
const
ctrl_t
kEmptyGroup
[
16
]
=
{
ctrl_t
:
:
kSentinel
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
ctrl_t
:
:
kEmpty
}
;
constexpr
size_t
Group
:
:
kWidth
;
inline
size_t
RandomSeed
(
)
{
#
ifdef
ABSL_HAVE_THREAD_LOCAL
static
thread_local
size_t
counter
=
0
;
size_t
value
=
+
+
counter
;
#
else
static
std
:
:
atomic
<
size_t
>
counter
(
0
)
;
size_t
value
=
counter
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
#
endif
return
value
^
static_cast
<
size_t
>
(
reinterpret_cast
<
uintptr_t
>
(
&
counter
)
)
;
}
bool
ShouldInsertBackwards
(
size_t
hash
const
ctrl_t
*
ctrl
)
{
return
(
H1
(
hash
ctrl
)
^
RandomSeed
(
)
)
%
13
>
6
;
}
void
ConvertDeletedToEmptyAndFullToDeleted
(
ctrl_t
*
ctrl
size_t
capacity
)
{
assert
(
ctrl
[
capacity
]
=
=
ctrl_t
:
:
kSentinel
)
;
assert
(
IsValidCapacity
(
capacity
)
)
;
for
(
ctrl_t
*
pos
=
ctrl
;
pos
<
ctrl
+
capacity
;
pos
+
=
Group
:
:
kWidth
)
{
Group
{
pos
}
.
ConvertSpecialToEmptyAndFullToDeleted
(
pos
)
;
}
std
:
:
memcpy
(
ctrl
+
capacity
+
1
ctrl
NumClonedBytes
(
)
)
;
ctrl
[
capacity
]
=
ctrl_t
:
:
kSentinel
;
}
}
ABSL_NAMESPACE_END
}
