#
ifndef
ABSL_CONTAINER_INTERNAL_HASHTABLEZ_SAMPLER_H_
#
define
ABSL_CONTAINER_INTERNAL_HASHTABLEZ_SAMPLER_H_
#
include
<
atomic
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
absl
/
base
/
internal
/
per_thread_tls
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
container
/
internal
/
have_sse
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
struct
HashtablezInfo
{
HashtablezInfo
(
)
;
~
HashtablezInfo
(
)
;
HashtablezInfo
(
const
HashtablezInfo
&
)
=
delete
;
HashtablezInfo
&
operator
=
(
const
HashtablezInfo
&
)
=
delete
;
void
PrepareForSampling
(
)
ABSL_EXCLUSIVE_LOCKS_REQUIRED
(
init_mu
)
;
std
:
:
atomic
<
size_t
>
capacity
;
std
:
:
atomic
<
size_t
>
size
;
std
:
:
atomic
<
size_t
>
num_erases
;
std
:
:
atomic
<
size_t
>
num_rehashes
;
std
:
:
atomic
<
size_t
>
max_probe_length
;
std
:
:
atomic
<
size_t
>
total_probe_length
;
std
:
:
atomic
<
size_t
>
hashes_bitwise_or
;
std
:
:
atomic
<
size_t
>
hashes_bitwise_and
;
absl
:
:
Mutex
init_mu
;
HashtablezInfo
*
next
;
HashtablezInfo
*
dead
ABSL_GUARDED_BY
(
init_mu
)
;
static
constexpr
int
kMaxStackDepth
=
64
;
absl
:
:
Time
create_time
;
int32_t
depth
;
void
*
stack
[
kMaxStackDepth
]
;
}
;
inline
void
RecordRehashSlow
(
HashtablezInfo
*
info
size_t
total_probe_length
)
{
#
if
ABSL_INTERNAL_RAW_HASH_SET_HAVE_SSE2
total_probe_length
/
=
16
;
#
else
total_probe_length
/
=
8
;
#
endif
info
-
>
total_probe_length
.
store
(
total_probe_length
std
:
:
memory_order_relaxed
)
;
info
-
>
num_erases
.
store
(
0
std
:
:
memory_order_relaxed
)
;
info
-
>
num_rehashes
.
store
(
1
+
info
-
>
num_rehashes
.
load
(
std
:
:
memory_order_relaxed
)
std
:
:
memory_order_relaxed
)
;
}
inline
void
RecordStorageChangedSlow
(
HashtablezInfo
*
info
size_t
size
size_t
capacity
)
{
info
-
>
size
.
store
(
size
std
:
:
memory_order_relaxed
)
;
info
-
>
capacity
.
store
(
capacity
std
:
:
memory_order_relaxed
)
;
if
(
size
=
=
0
)
{
info
-
>
total_probe_length
.
store
(
0
std
:
:
memory_order_relaxed
)
;
info
-
>
num_erases
.
store
(
0
std
:
:
memory_order_relaxed
)
;
}
}
void
RecordInsertSlow
(
HashtablezInfo
*
info
size_t
hash
size_t
distance_from_desired
)
;
inline
void
RecordEraseSlow
(
HashtablezInfo
*
info
)
{
info
-
>
size
.
fetch_sub
(
1
std
:
:
memory_order_relaxed
)
;
info
-
>
num_erases
.
store
(
1
+
info
-
>
num_erases
.
load
(
std
:
:
memory_order_relaxed
)
std
:
:
memory_order_relaxed
)
;
}
HashtablezInfo
*
SampleSlow
(
int64_t
*
next_sample
)
;
void
UnsampleSlow
(
HashtablezInfo
*
info
)
;
#
if
defined
(
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
)
#
error
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
cannot
be
directly
set
#
endif
#
if
defined
(
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
)
class
HashtablezInfoHandle
{
public
:
explicit
HashtablezInfoHandle
(
)
:
info_
(
nullptr
)
{
}
explicit
HashtablezInfoHandle
(
HashtablezInfo
*
info
)
:
info_
(
info
)
{
}
~
HashtablezInfoHandle
(
)
{
if
(
ABSL_PREDICT_TRUE
(
info_
=
=
nullptr
)
)
return
;
UnsampleSlow
(
info_
)
;
}
HashtablezInfoHandle
(
const
HashtablezInfoHandle
&
)
=
delete
;
HashtablezInfoHandle
&
operator
=
(
const
HashtablezInfoHandle
&
)
=
delete
;
HashtablezInfoHandle
(
HashtablezInfoHandle
&
&
o
)
noexcept
:
info_
(
absl
:
:
exchange
(
o
.
info_
nullptr
)
)
{
}
HashtablezInfoHandle
&
operator
=
(
HashtablezInfoHandle
&
&
o
)
noexcept
{
if
(
ABSL_PREDICT_FALSE
(
info_
!
=
nullptr
)
)
{
UnsampleSlow
(
info_
)
;
}
info_
=
absl
:
:
exchange
(
o
.
info_
nullptr
)
;
return
*
this
;
}
inline
void
RecordStorageChanged
(
size_t
size
size_t
capacity
)
{
if
(
ABSL_PREDICT_TRUE
(
info_
=
=
nullptr
)
)
return
;
RecordStorageChangedSlow
(
info_
size
capacity
)
;
}
inline
void
RecordRehash
(
size_t
total_probe_length
)
{
if
(
ABSL_PREDICT_TRUE
(
info_
=
=
nullptr
)
)
return
;
RecordRehashSlow
(
info_
total_probe_length
)
;
}
inline
void
RecordInsert
(
size_t
hash
size_t
distance_from_desired
)
{
if
(
ABSL_PREDICT_TRUE
(
info_
=
=
nullptr
)
)
return
;
RecordInsertSlow
(
info_
hash
distance_from_desired
)
;
}
inline
void
RecordErase
(
)
{
if
(
ABSL_PREDICT_TRUE
(
info_
=
=
nullptr
)
)
return
;
RecordEraseSlow
(
info_
)
;
}
friend
inline
void
swap
(
HashtablezInfoHandle
&
lhs
HashtablezInfoHandle
&
rhs
)
{
std
:
:
swap
(
lhs
.
info_
rhs
.
info_
)
;
}
private
:
friend
class
HashtablezInfoHandlePeer
;
HashtablezInfo
*
info_
;
}
;
#
else
class
HashtablezInfoHandle
{
public
:
explicit
HashtablezInfoHandle
(
)
=
default
;
explicit
HashtablezInfoHandle
(
std
:
:
nullptr_t
)
{
}
inline
void
RecordStorageChanged
(
size_t
size_t
)
{
}
inline
void
RecordRehash
(
size_t
)
{
}
inline
void
RecordInsert
(
size_t
size_t
)
{
}
inline
void
RecordErase
(
)
{
}
friend
inline
void
swap
(
HashtablezInfoHandle
&
HashtablezInfoHandle
&
)
{
}
}
;
#
endif
#
if
defined
(
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
)
extern
ABSL_PER_THREAD_TLS_KEYWORD
int64_t
global_next_sample
;
#
endif
inline
HashtablezInfoHandle
Sample
(
)
{
#
if
defined
(
ABSL_INTERNAL_HASHTABLEZ_SAMPLE
)
if
(
ABSL_PREDICT_TRUE
(
-
-
global_next_sample
>
0
)
)
{
return
HashtablezInfoHandle
(
nullptr
)
;
}
return
HashtablezInfoHandle
(
SampleSlow
(
&
global_next_sample
)
)
;
#
else
return
HashtablezInfoHandle
(
nullptr
)
;
#
endif
}
class
HashtablezSampler
{
public
:
static
HashtablezSampler
&
Global
(
)
;
HashtablezSampler
(
)
;
~
HashtablezSampler
(
)
;
HashtablezInfo
*
Register
(
)
;
void
Unregister
(
HashtablezInfo
*
sample
)
;
using
DisposeCallback
=
void
(
*
)
(
const
HashtablezInfo
&
)
;
DisposeCallback
SetDisposeCallback
(
DisposeCallback
f
)
;
int64_t
Iterate
(
const
std
:
:
function
<
void
(
const
HashtablezInfo
&
stack
)
>
&
f
)
;
private
:
void
PushNew
(
HashtablezInfo
*
sample
)
;
void
PushDead
(
HashtablezInfo
*
sample
)
;
HashtablezInfo
*
PopDead
(
)
;
std
:
:
atomic
<
size_t
>
dropped_samples_
;
std
:
:
atomic
<
size_t
>
size_estimate_
;
std
:
:
atomic
<
HashtablezInfo
*
>
all_
;
HashtablezInfo
graveyard_
;
std
:
:
atomic
<
DisposeCallback
>
dispose_
;
}
;
void
SetHashtablezEnabled
(
bool
enabled
)
;
void
SetHashtablezSampleParameter
(
int32_t
rate
)
;
void
SetHashtablezMaxSamples
(
int32_t
max
)
;
extern
"
C
"
bool
AbslContainerInternalSampleEverything
(
)
;
}
ABSL_NAMESPACE_END
}
#
endif
