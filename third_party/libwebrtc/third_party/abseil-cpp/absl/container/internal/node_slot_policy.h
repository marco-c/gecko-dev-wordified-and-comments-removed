#
ifndef
ABSL_CONTAINER_INTERNAL_NODE_SLOT_POLICY_H_
#
define
ABSL_CONTAINER_INTERNAL_NODE_SLOT_POLICY_H_
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
config
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
class
Reference
class
Policy
>
struct
node_slot_policy
{
static_assert
(
std
:
:
is_lvalue_reference
<
Reference
>
:
:
value
"
"
)
;
using
slot_type
=
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
Reference
>
:
:
type
>
:
:
type
*
;
template
<
class
Alloc
class
.
.
.
Args
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
Args
&
&
.
.
.
args
)
{
*
slot
=
Policy
:
:
new_element
(
alloc
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
Alloc
>
static
void
destroy
(
Alloc
*
alloc
slot_type
*
slot
)
{
Policy
:
:
delete_element
(
alloc
*
slot
)
;
}
template
<
class
Alloc
>
static
void
transfer
(
Alloc
*
slot_type
*
new_slot
slot_type
*
old_slot
)
{
*
new_slot
=
*
old_slot
;
}
static
size_t
space_used
(
const
slot_type
*
slot
)
{
if
(
slot
=
=
nullptr
)
return
Policy
:
:
element_space_used
(
nullptr
)
;
return
Policy
:
:
element_space_used
(
*
slot
)
;
}
static
Reference
element
(
slot_type
*
slot
)
{
return
*
*
slot
;
}
template
<
class
T
class
P
=
Policy
>
static
auto
value
(
T
*
elem
)
-
>
decltype
(
P
:
:
value
(
elem
)
)
{
return
P
:
:
value
(
elem
)
;
}
template
<
class
.
.
.
Ts
class
P
=
Policy
>
static
auto
apply
(
Ts
&
&
.
.
.
ts
)
-
>
decltype
(
P
:
:
apply
(
std
:
:
forward
<
Ts
>
(
ts
)
.
.
.
)
)
{
return
P
:
:
apply
(
std
:
:
forward
<
Ts
>
(
ts
)
.
.
.
)
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
