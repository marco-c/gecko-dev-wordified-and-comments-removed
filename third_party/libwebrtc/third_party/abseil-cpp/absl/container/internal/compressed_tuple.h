#
ifndef
ABSL_CONTAINER_INTERNAL_COMPRESSED_TUPLE_H_
#
define
ABSL_CONTAINER_INTERNAL_COMPRESSED_TUPLE_H_
#
include
<
initializer_list
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
utility
/
utility
.
h
"
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__NVCC__
)
#
define
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
__declspec
(
empty_bases
)
#
else
#
define
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
typename
.
.
.
Ts
>
class
CompressedTuple
;
namespace
internal_compressed_tuple
{
template
<
typename
D
size_t
I
>
struct
Elem
;
template
<
typename
.
.
.
B
size_t
I
>
struct
Elem
<
CompressedTuple
<
B
.
.
.
>
I
>
:
std
:
:
tuple_element
<
I
std
:
:
tuple
<
B
.
.
.
>
>
{
}
;
template
<
typename
D
size_t
I
>
using
ElemT
=
typename
Elem
<
D
I
>
:
:
type
;
template
<
typename
T
>
constexpr
bool
IsFinal
(
)
{
#
if
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
return
__is_final
(
T
)
;
#
else
return
false
;
#
endif
}
struct
uses_inheritance
{
}
;
template
<
typename
T
>
constexpr
bool
ShouldUseBase
(
)
{
return
std
:
:
is_class
<
T
>
:
:
value
&
&
std
:
:
is_empty
<
T
>
:
:
value
&
&
!
IsFinal
<
T
>
(
)
&
&
!
std
:
:
is_base_of
<
uses_inheritance
T
>
:
:
value
;
}
template
<
typename
T
size_t
I
#
if
defined
(
_MSC_VER
)
bool
UseBase
=
ShouldUseBase
<
typename
std
:
:
enable_if
<
true
T
>
:
:
type
>
(
)
>
#
else
bool
UseBase
=
ShouldUseBase
<
T
>
(
)
>
#
endif
struct
Storage
{
T
value
;
constexpr
Storage
(
)
=
default
;
template
<
typename
V
>
explicit
constexpr
Storage
(
absl
:
:
in_place_t
V
&
&
v
)
:
value
(
absl
:
:
forward
<
V
>
(
v
)
)
{
}
constexpr
const
T
&
get
(
)
const
&
{
return
value
;
}
T
&
get
(
)
&
{
return
value
;
}
constexpr
const
T
&
&
get
(
)
const
&
&
{
return
absl
:
:
move
(
*
this
)
.
value
;
}
T
&
&
get
(
)
&
&
{
return
std
:
:
move
(
*
this
)
.
value
;
}
}
;
template
<
typename
T
size_t
I
>
struct
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
Storage
<
T
I
true
>
:
T
{
constexpr
Storage
(
)
=
default
;
template
<
typename
V
>
explicit
constexpr
Storage
(
absl
:
:
in_place_t
V
&
&
v
)
:
T
(
absl
:
:
forward
<
V
>
(
v
)
)
{
}
constexpr
const
T
&
get
(
)
const
&
{
return
*
this
;
}
T
&
get
(
)
&
{
return
*
this
;
}
constexpr
const
T
&
&
get
(
)
const
&
&
{
return
absl
:
:
move
(
*
this
)
;
}
T
&
&
get
(
)
&
&
{
return
std
:
:
move
(
*
this
)
;
}
}
;
template
<
typename
D
typename
I
bool
ShouldAnyUseBase
>
struct
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
CompressedTupleImpl
;
template
<
typename
.
.
.
Ts
size_t
.
.
.
I
bool
ShouldAnyUseBase
>
struct
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
CompressedTupleImpl
<
CompressedTuple
<
Ts
.
.
.
>
absl
:
:
index_sequence
<
I
.
.
.
>
ShouldAnyUseBase
>
:
uses_inheritance
Storage
<
Ts
std
:
:
integral_constant
<
size_t
I
>
:
:
value
>
.
.
.
{
constexpr
CompressedTupleImpl
(
)
=
default
;
template
<
typename
.
.
.
Vs
>
explicit
constexpr
CompressedTupleImpl
(
absl
:
:
in_place_t
Vs
&
&
.
.
.
args
)
:
Storage
<
Ts
I
>
(
absl
:
:
in_place
absl
:
:
forward
<
Vs
>
(
args
)
)
.
.
.
{
}
friend
CompressedTuple
<
Ts
.
.
.
>
;
}
;
template
<
typename
.
.
.
Ts
size_t
.
.
.
I
>
struct
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
CompressedTupleImpl
<
CompressedTuple
<
Ts
.
.
.
>
absl
:
:
index_sequence
<
I
.
.
.
>
false
>
:
Storage
<
Ts
std
:
:
integral_constant
<
size_t
I
>
:
:
value
false
>
.
.
.
{
constexpr
CompressedTupleImpl
(
)
=
default
;
template
<
typename
.
.
.
Vs
>
explicit
constexpr
CompressedTupleImpl
(
absl
:
:
in_place_t
Vs
&
&
.
.
.
args
)
:
Storage
<
Ts
I
false
>
(
absl
:
:
in_place
absl
:
:
forward
<
Vs
>
(
args
)
)
.
.
.
{
}
friend
CompressedTuple
<
Ts
.
.
.
>
;
}
;
std
:
:
false_type
Or
(
std
:
:
initializer_list
<
std
:
:
false_type
>
)
;
std
:
:
true_type
Or
(
std
:
:
initializer_list
<
bool
>
)
;
template
<
typename
.
.
.
Ts
>
constexpr
bool
ShouldAnyUseBase
(
)
{
return
decltype
(
Or
(
{
std
:
:
integral_constant
<
bool
ShouldUseBase
<
Ts
>
(
)
>
(
)
.
.
.
}
)
)
{
}
;
}
template
<
typename
T
typename
V
>
using
TupleElementMoveConstructible
=
typename
std
:
:
conditional
<
std
:
:
is_reference
<
T
>
:
:
value
std
:
:
is_convertible
<
V
T
>
std
:
:
is_constructible
<
T
V
&
&
>
>
:
:
type
;
template
<
bool
SizeMatches
class
T
class
.
.
.
Vs
>
struct
TupleMoveConstructible
:
std
:
:
false_type
{
}
;
template
<
class
.
.
.
Ts
class
.
.
.
Vs
>
struct
TupleMoveConstructible
<
true
CompressedTuple
<
Ts
.
.
.
>
Vs
.
.
.
>
:
std
:
:
integral_constant
<
bool
absl
:
:
conjunction
<
TupleElementMoveConstructible
<
Ts
Vs
&
&
>
.
.
.
>
:
:
value
>
{
}
;
template
<
typename
T
>
struct
compressed_tuple_size
;
template
<
typename
.
.
.
Es
>
struct
compressed_tuple_size
<
CompressedTuple
<
Es
.
.
.
>
>
:
public
std
:
:
integral_constant
<
std
:
:
size_t
sizeof
.
.
.
(
Es
)
>
{
}
;
template
<
class
T
class
.
.
.
Vs
>
struct
TupleItemsMoveConstructible
:
std
:
:
integral_constant
<
bool
TupleMoveConstructible
<
compressed_tuple_size
<
T
>
:
:
value
=
=
sizeof
.
.
.
(
Vs
)
T
Vs
.
.
.
>
:
:
value
>
{
}
;
}
template
<
typename
.
.
.
Ts
>
class
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
CompressedTuple
:
private
internal_compressed_tuple
:
:
CompressedTupleImpl
<
CompressedTuple
<
Ts
.
.
.
>
absl
:
:
index_sequence_for
<
Ts
.
.
.
>
internal_compressed_tuple
:
:
ShouldAnyUseBase
<
Ts
.
.
.
>
(
)
>
{
private
:
template
<
int
I
>
using
ElemT
=
internal_compressed_tuple
:
:
ElemT
<
CompressedTuple
I
>
;
template
<
int
I
>
using
StorageT
=
internal_compressed_tuple
:
:
Storage
<
ElemT
<
I
>
I
>
;
public
:
#
if
defined
(
_MSC_VER
)
constexpr
CompressedTuple
(
)
:
CompressedTuple
:
:
CompressedTupleImpl
(
)
{
}
#
else
constexpr
CompressedTuple
(
)
=
default
;
#
endif
explicit
constexpr
CompressedTuple
(
const
Ts
&
.
.
.
base
)
:
CompressedTuple
:
:
CompressedTupleImpl
(
absl
:
:
in_place
base
.
.
.
)
{
}
template
<
typename
First
typename
.
.
.
Vs
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
absl
:
:
negation
<
std
:
:
is_same
<
void
(
CompressedTuple
)
void
(
absl
:
:
decay_t
<
First
>
)
>
>
internal_compressed_tuple
:
:
TupleItemsMoveConstructible
<
CompressedTuple
<
Ts
.
.
.
>
First
Vs
.
.
.
>
>
:
:
value
bool
>
=
true
>
explicit
constexpr
CompressedTuple
(
First
&
&
first
Vs
&
&
.
.
.
base
)
:
CompressedTuple
:
:
CompressedTupleImpl
(
absl
:
:
in_place
absl
:
:
forward
<
First
>
(
first
)
absl
:
:
forward
<
Vs
>
(
base
)
.
.
.
)
{
}
template
<
int
I
>
ElemT
<
I
>
&
get
(
)
&
{
return
StorageT
<
I
>
:
:
get
(
)
;
}
template
<
int
I
>
constexpr
const
ElemT
<
I
>
&
get
(
)
const
&
{
return
StorageT
<
I
>
:
:
get
(
)
;
}
template
<
int
I
>
ElemT
<
I
>
&
&
get
(
)
&
&
{
return
std
:
:
move
(
*
this
)
.
StorageT
<
I
>
:
:
get
(
)
;
}
template
<
int
I
>
constexpr
const
ElemT
<
I
>
&
&
get
(
)
const
&
&
{
return
absl
:
:
move
(
*
this
)
.
StorageT
<
I
>
:
:
get
(
)
;
}
}
;
template
<
>
class
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
CompressedTuple
<
>
{
}
;
}
ABSL_NAMESPACE_END
}
#
undef
ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC
#
endif
