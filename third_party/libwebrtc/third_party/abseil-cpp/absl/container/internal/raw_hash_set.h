#
ifndef
ABSL_CONTAINER_INTERNAL_RAW_HASH_SET_H_
#
define
ABSL_CONTAINER_INTERNAL_RAW_HASH_SET_H_
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
endian
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
base
/
options
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
include
"
absl
/
base
/
prefetch
.
h
"
#
include
"
absl
/
container
/
internal
/
common
.
h
"
#
include
"
absl
/
container
/
internal
/
compressed_tuple
.
h
"
#
include
"
absl
/
container
/
internal
/
container_memory
.
h
"
#
include
"
absl
/
container
/
internal
/
hash_policy_traits
.
h
"
#
include
"
absl
/
container
/
internal
/
hashtable_debug_hooks
.
h
"
#
include
"
absl
/
container
/
internal
/
hashtablez_sampler
.
h
"
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
numeric
/
bits
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
#
ifdef
ABSL_INTERNAL_HAVE_SSE2
#
include
<
emmintrin
.
h
>
#
endif
#
ifdef
ABSL_INTERNAL_HAVE_SSSE3
#
include
<
tmmintrin
.
h
>
#
endif
#
ifdef
_MSC_VER
#
include
<
intrin
.
h
>
#
endif
#
ifdef
ABSL_INTERNAL_HAVE_ARM_NEON
#
include
<
arm_neon
.
h
>
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
#
ifdef
ABSL_SWISSTABLE_ENABLE_GENERATIONS
#
error
ABSL_SWISSTABLE_ENABLE_GENERATIONS
cannot
be
directly
set
#
elif
defined
(
ABSL_HAVE_ADDRESS_SANITIZER
)
|
|
\
defined
(
ABSL_HAVE_MEMORY_SANITIZER
)
#
define
ABSL_SWISSTABLE_ENABLE_GENERATIONS
#
endif
using
GenerationType
=
uint8_t
;
constexpr
GenerationType
SentinelEmptyGeneration
(
)
{
return
0
;
}
constexpr
GenerationType
NextGeneration
(
GenerationType
generation
)
{
return
+
+
generation
=
=
SentinelEmptyGeneration
(
)
?
+
+
generation
:
generation
;
}
#
ifdef
ABSL_SWISSTABLE_ENABLE_GENERATIONS
constexpr
bool
SwisstableGenerationsEnabled
(
)
{
return
true
;
}
constexpr
size_t
NumGenerationBytes
(
)
{
return
sizeof
(
GenerationType
)
;
}
#
else
constexpr
bool
SwisstableGenerationsEnabled
(
)
{
return
false
;
}
constexpr
size_t
NumGenerationBytes
(
)
{
return
0
;
}
#
endif
template
<
typename
AllocType
>
void
SwapAlloc
(
AllocType
&
lhs
AllocType
&
rhs
std
:
:
true_type
)
{
using
std
:
:
swap
;
swap
(
lhs
rhs
)
;
}
template
<
typename
AllocType
>
void
SwapAlloc
(
AllocType
&
AllocType
&
std
:
:
false_type
)
{
}
template
<
size_t
Width
>
class
probe_seq
{
public
:
probe_seq
(
size_t
hash
size_t
mask
)
{
assert
(
(
(
mask
+
1
)
&
mask
)
=
=
0
&
&
"
not
a
mask
"
)
;
mask_
=
mask
;
offset_
=
hash
&
mask_
;
}
size_t
offset
(
)
const
{
return
offset_
;
}
size_t
offset
(
size_t
i
)
const
{
return
(
offset_
+
i
)
&
mask_
;
}
void
next
(
)
{
index_
+
=
Width
;
offset_
+
=
index_
;
offset_
&
=
mask_
;
}
size_t
index
(
)
const
{
return
index_
;
}
private
:
size_t
mask_
;
size_t
offset_
;
size_t
index_
=
0
;
}
;
template
<
class
ContainerKey
class
Hash
class
Eq
>
struct
RequireUsableKey
{
template
<
class
PassedKey
class
.
.
.
Args
>
std
:
:
pair
<
decltype
(
std
:
:
declval
<
const
Hash
&
>
(
)
(
std
:
:
declval
<
const
PassedKey
&
>
(
)
)
)
decltype
(
std
:
:
declval
<
const
Eq
&
>
(
)
(
std
:
:
declval
<
const
ContainerKey
&
>
(
)
std
:
:
declval
<
const
PassedKey
&
>
(
)
)
)
>
*
operator
(
)
(
const
PassedKey
&
const
Args
&
.
.
.
)
const
;
}
;
template
<
class
E
class
Policy
class
Hash
class
Eq
class
.
.
.
Ts
>
struct
IsDecomposable
:
std
:
:
false_type
{
}
;
template
<
class
Policy
class
Hash
class
Eq
class
.
.
.
Ts
>
struct
IsDecomposable
<
absl
:
:
void_t
<
decltype
(
Policy
:
:
apply
(
RequireUsableKey
<
typename
Policy
:
:
key_type
Hash
Eq
>
(
)
std
:
:
declval
<
Ts
>
(
)
.
.
.
)
)
>
Policy
Hash
Eq
Ts
.
.
.
>
:
std
:
:
true_type
{
}
;
template
<
class
T
>
constexpr
bool
IsNoThrowSwappable
(
std
:
:
true_type
=
{
}
)
{
using
std
:
:
swap
;
return
noexcept
(
swap
(
std
:
:
declval
<
T
&
>
(
)
std
:
:
declval
<
T
&
>
(
)
)
)
;
}
template
<
class
T
>
constexpr
bool
IsNoThrowSwappable
(
std
:
:
false_type
)
{
return
false
;
}
template
<
typename
T
>
uint32_t
TrailingZeros
(
T
x
)
{
ABSL_ASSUME
(
x
!
=
0
)
;
return
static_cast
<
uint32_t
>
(
countr_zero
(
x
)
)
;
}
template
<
class
T
int
SignificantBits
int
Shift
=
0
>
class
NonIterableBitMask
{
public
:
explicit
NonIterableBitMask
(
T
mask
)
:
mask_
(
mask
)
{
}
explicit
operator
bool
(
)
const
{
return
this
-
>
mask_
!
=
0
;
}
uint32_t
LowestBitSet
(
)
const
{
return
container_internal
:
:
TrailingZeros
(
mask_
)
>
>
Shift
;
}
uint32_t
HighestBitSet
(
)
const
{
return
static_cast
<
uint32_t
>
(
(
bit_width
(
mask_
)
-
1
)
>
>
Shift
)
;
}
uint32_t
TrailingZeros
(
)
const
{
return
container_internal
:
:
TrailingZeros
(
mask_
)
>
>
Shift
;
}
uint32_t
LeadingZeros
(
)
const
{
constexpr
int
total_significant_bits
=
SignificantBits
<
<
Shift
;
constexpr
int
extra_bits
=
sizeof
(
T
)
*
8
-
total_significant_bits
;
return
static_cast
<
uint32_t
>
(
countl_zero
(
mask_
<
<
extra_bits
)
)
>
>
Shift
;
}
T
mask_
;
}
;
template
<
class
T
int
SignificantBits
int
Shift
=
0
>
class
BitMask
:
public
NonIterableBitMask
<
T
SignificantBits
Shift
>
{
using
Base
=
NonIterableBitMask
<
T
SignificantBits
Shift
>
;
static_assert
(
std
:
:
is_unsigned
<
T
>
:
:
value
"
"
)
;
static_assert
(
Shift
=
=
0
|
|
Shift
=
=
3
"
"
)
;
public
:
explicit
BitMask
(
T
mask
)
:
Base
(
mask
)
{
}
using
value_type
=
int
;
using
iterator
=
BitMask
;
using
const_iterator
=
BitMask
;
BitMask
&
operator
+
+
(
)
{
if
(
Shift
=
=
3
)
{
constexpr
uint64_t
msbs
=
0x8080808080808080ULL
;
this
-
>
mask_
&
=
msbs
;
}
this
-
>
mask_
&
=
(
this
-
>
mask_
-
1
)
;
return
*
this
;
}
uint32_t
operator
*
(
)
const
{
return
Base
:
:
LowestBitSet
(
)
;
}
BitMask
begin
(
)
const
{
return
*
this
;
}
BitMask
end
(
)
const
{
return
BitMask
(
0
)
;
}
private
:
friend
bool
operator
=
=
(
const
BitMask
&
a
const
BitMask
&
b
)
{
return
a
.
mask_
=
=
b
.
mask_
;
}
friend
bool
operator
!
=
(
const
BitMask
&
a
const
BitMask
&
b
)
{
return
a
.
mask_
!
=
b
.
mask_
;
}
}
;
using
h2_t
=
uint8_t
;
enum
class
ctrl_t
:
int8_t
{
kEmpty
=
-
128
kDeleted
=
-
2
kSentinel
=
-
1
}
;
static_assert
(
(
static_cast
<
int8_t
>
(
ctrl_t
:
:
kEmpty
)
&
static_cast
<
int8_t
>
(
ctrl_t
:
:
kDeleted
)
&
static_cast
<
int8_t
>
(
ctrl_t
:
:
kSentinel
)
&
0x80
)
!
=
0
"
Special
markers
need
to
have
the
MSB
to
make
checking
for
them
efficient
"
)
;
static_assert
(
ctrl_t
:
:
kEmpty
<
ctrl_t
:
:
kSentinel
&
&
ctrl_t
:
:
kDeleted
<
ctrl_t
:
:
kSentinel
"
ctrl_t
:
:
kEmpty
and
ctrl_t
:
:
kDeleted
must
be
smaller
than
"
"
ctrl_t
:
:
kSentinel
to
make
the
SIMD
test
of
IsEmptyOrDeleted
(
)
efficient
"
)
;
static_assert
(
ctrl_t
:
:
kSentinel
=
=
static_cast
<
ctrl_t
>
(
-
1
)
"
ctrl_t
:
:
kSentinel
must
be
-
1
to
elide
loading
it
from
memory
into
SIMD
"
"
registers
(
pcmpeqd
xmm
xmm
)
"
)
;
static_assert
(
ctrl_t
:
:
kEmpty
=
=
static_cast
<
ctrl_t
>
(
-
128
)
"
ctrl_t
:
:
kEmpty
must
be
-
128
to
make
the
SIMD
check
for
its
"
"
existence
efficient
(
psignb
xmm
xmm
)
"
)
;
static_assert
(
(
~
static_cast
<
int8_t
>
(
ctrl_t
:
:
kEmpty
)
&
~
static_cast
<
int8_t
>
(
ctrl_t
:
:
kDeleted
)
&
static_cast
<
int8_t
>
(
ctrl_t
:
:
kSentinel
)
&
0x7F
)
!
=
0
"
ctrl_t
:
:
kEmpty
and
ctrl_t
:
:
kDeleted
must
share
an
unset
bit
that
is
not
"
"
shared
by
ctrl_t
:
:
kSentinel
to
make
the
scalar
test
for
"
"
MaskEmptyOrDeleted
(
)
efficient
"
)
;
static_assert
(
ctrl_t
:
:
kDeleted
=
=
static_cast
<
ctrl_t
>
(
-
2
)
"
ctrl_t
:
:
kDeleted
must
be
-
2
to
make
the
implementation
of
"
"
ConvertSpecialToEmptyAndFullToDeleted
efficient
"
)
;
ABSL_DLL
extern
const
ctrl_t
kEmptyGroup
[
32
]
;
inline
ctrl_t
*
EmptyGroup
(
)
{
return
const_cast
<
ctrl_t
*
>
(
kEmptyGroup
+
16
)
;
}
GenerationType
*
EmptyGeneration
(
)
;
inline
bool
IsEmptyGeneration
(
const
GenerationType
*
generation
)
{
return
*
generation
=
=
SentinelEmptyGeneration
(
)
;
}
bool
ShouldInsertBackwards
(
size_t
hash
const
ctrl_t
*
ctrl
)
;
inline
size_t
PerTableSalt
(
const
ctrl_t
*
ctrl
)
{
return
reinterpret_cast
<
uintptr_t
>
(
ctrl
)
>
>
12
;
}
inline
size_t
H1
(
size_t
hash
const
ctrl_t
*
ctrl
)
{
return
(
hash
>
>
7
)
^
PerTableSalt
(
ctrl
)
;
}
inline
h2_t
H2
(
size_t
hash
)
{
return
hash
&
0x7F
;
}
inline
bool
IsEmpty
(
ctrl_t
c
)
{
return
c
=
=
ctrl_t
:
:
kEmpty
;
}
inline
bool
IsFull
(
ctrl_t
c
)
{
return
c
>
=
static_cast
<
ctrl_t
>
(
0
)
;
}
inline
bool
IsDeleted
(
ctrl_t
c
)
{
return
c
=
=
ctrl_t
:
:
kDeleted
;
}
inline
bool
IsEmptyOrDeleted
(
ctrl_t
c
)
{
return
c
<
ctrl_t
:
:
kSentinel
;
}
#
ifdef
ABSL_INTERNAL_HAVE_SSE2
inline
__m128i
_mm_cmpgt_epi8_fixed
(
__m128i
a
__m128i
b
)
{
#
if
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
if
(
std
:
:
is_unsigned
<
char
>
:
:
value
)
{
const
__m128i
mask
=
_mm_set1_epi8
(
0x80
)
;
const
__m128i
diff
=
_mm_subs_epi8
(
b
a
)
;
return
_mm_cmpeq_epi8
(
_mm_and_si128
(
diff
mask
)
mask
)
;
}
#
endif
return
_mm_cmpgt_epi8
(
a
b
)
;
}
struct
GroupSse2Impl
{
static
constexpr
size_t
kWidth
=
16
;
explicit
GroupSse2Impl
(
const
ctrl_t
*
pos
)
{
ctrl
=
_mm_loadu_si128
(
reinterpret_cast
<
const
__m128i
*
>
(
pos
)
)
;
}
BitMask
<
uint32_t
kWidth
>
Match
(
h2_t
hash
)
const
{
auto
match
=
_mm_set1_epi8
(
static_cast
<
char
>
(
hash
)
)
;
return
BitMask
<
uint32_t
kWidth
>
(
static_cast
<
uint32_t
>
(
_mm_movemask_epi8
(
_mm_cmpeq_epi8
(
match
ctrl
)
)
)
)
;
}
NonIterableBitMask
<
uint32_t
kWidth
>
MaskEmpty
(
)
const
{
#
ifdef
ABSL_INTERNAL_HAVE_SSSE3
return
NonIterableBitMask
<
uint32_t
kWidth
>
(
static_cast
<
uint32_t
>
(
_mm_movemask_epi8
(
_mm_sign_epi8
(
ctrl
ctrl
)
)
)
)
;
#
else
auto
match
=
_mm_set1_epi8
(
static_cast
<
char
>
(
ctrl_t
:
:
kEmpty
)
)
;
return
NonIterableBitMask
<
uint32_t
kWidth
>
(
static_cast
<
uint32_t
>
(
_mm_movemask_epi8
(
_mm_cmpeq_epi8
(
match
ctrl
)
)
)
)
;
#
endif
}
NonIterableBitMask
<
uint32_t
kWidth
>
MaskEmptyOrDeleted
(
)
const
{
auto
special
=
_mm_set1_epi8
(
static_cast
<
char
>
(
ctrl_t
:
:
kSentinel
)
)
;
return
NonIterableBitMask
<
uint32_t
kWidth
>
(
static_cast
<
uint32_t
>
(
_mm_movemask_epi8
(
_mm_cmpgt_epi8_fixed
(
special
ctrl
)
)
)
)
;
}
uint32_t
CountLeadingEmptyOrDeleted
(
)
const
{
auto
special
=
_mm_set1_epi8
(
static_cast
<
char
>
(
ctrl_t
:
:
kSentinel
)
)
;
return
TrailingZeros
(
static_cast
<
uint32_t
>
(
_mm_movemask_epi8
(
_mm_cmpgt_epi8_fixed
(
special
ctrl
)
)
+
1
)
)
;
}
void
ConvertSpecialToEmptyAndFullToDeleted
(
ctrl_t
*
dst
)
const
{
auto
msbs
=
_mm_set1_epi8
(
static_cast
<
char
>
(
-
128
)
)
;
auto
x126
=
_mm_set1_epi8
(
126
)
;
#
ifdef
ABSL_INTERNAL_HAVE_SSSE3
auto
res
=
_mm_or_si128
(
_mm_shuffle_epi8
(
x126
ctrl
)
msbs
)
;
#
else
auto
zero
=
_mm_setzero_si128
(
)
;
auto
special_mask
=
_mm_cmpgt_epi8_fixed
(
zero
ctrl
)
;
auto
res
=
_mm_or_si128
(
msbs
_mm_andnot_si128
(
special_mask
x126
)
)
;
#
endif
_mm_storeu_si128
(
reinterpret_cast
<
__m128i
*
>
(
dst
)
res
)
;
}
__m128i
ctrl
;
}
;
#
endif
#
if
defined
(
ABSL_INTERNAL_HAVE_ARM_NEON
)
&
&
defined
(
ABSL_IS_LITTLE_ENDIAN
)
struct
GroupAArch64Impl
{
static
constexpr
size_t
kWidth
=
8
;
explicit
GroupAArch64Impl
(
const
ctrl_t
*
pos
)
{
ctrl
=
vld1_u8
(
reinterpret_cast
<
const
uint8_t
*
>
(
pos
)
)
;
}
BitMask
<
uint64_t
kWidth
3
>
Match
(
h2_t
hash
)
const
{
uint8x8_t
dup
=
vdup_n_u8
(
hash
)
;
auto
mask
=
vceq_u8
(
ctrl
dup
)
;
return
BitMask
<
uint64_t
kWidth
3
>
(
vget_lane_u64
(
vreinterpret_u64_u8
(
mask
)
0
)
)
;
}
NonIterableBitMask
<
uint64_t
kWidth
3
>
MaskEmpty
(
)
const
{
uint64_t
mask
=
vget_lane_u64
(
vreinterpret_u64_u8
(
vceq_s8
(
vdup_n_s8
(
static_cast
<
int8_t
>
(
ctrl_t
:
:
kEmpty
)
)
vreinterpret_s8_u8
(
ctrl
)
)
)
0
)
;
return
NonIterableBitMask
<
uint64_t
kWidth
3
>
(
mask
)
;
}
NonIterableBitMask
<
uint64_t
kWidth
3
>
MaskEmptyOrDeleted
(
)
const
{
uint64_t
mask
=
vget_lane_u64
(
vreinterpret_u64_u8
(
vcgt_s8
(
vdup_n_s8
(
static_cast
<
int8_t
>
(
ctrl_t
:
:
kSentinel
)
)
vreinterpret_s8_u8
(
ctrl
)
)
)
0
)
;
return
NonIterableBitMask
<
uint64_t
kWidth
3
>
(
mask
)
;
}
uint32_t
CountLeadingEmptyOrDeleted
(
)
const
{
uint64_t
mask
=
vget_lane_u64
(
vreinterpret_u64_u8
(
vcle_s8
(
vdup_n_s8
(
static_cast
<
int8_t
>
(
ctrl_t
:
:
kSentinel
)
)
vreinterpret_s8_u8
(
ctrl
)
)
)
0
)
;
return
static_cast
<
uint32_t
>
(
countr_zero
(
mask
)
)
>
>
3
;
}
void
ConvertSpecialToEmptyAndFullToDeleted
(
ctrl_t
*
dst
)
const
{
uint64_t
mask
=
vget_lane_u64
(
vreinterpret_u64_u8
(
ctrl
)
0
)
;
constexpr
uint64_t
msbs
=
0x8080808080808080ULL
;
constexpr
uint64_t
slsbs
=
0x0202020202020202ULL
;
constexpr
uint64_t
midbs
=
0x7e7e7e7e7e7e7e7eULL
;
auto
x
=
slsbs
&
(
mask
>
>
6
)
;
auto
res
=
(
x
+
midbs
)
|
msbs
;
little_endian
:
:
Store64
(
dst
res
)
;
}
uint8x8_t
ctrl
;
}
;
#
endif
struct
GroupPortableImpl
{
static
constexpr
size_t
kWidth
=
8
;
explicit
GroupPortableImpl
(
const
ctrl_t
*
pos
)
:
ctrl
(
little_endian
:
:
Load64
(
pos
)
)
{
}
BitMask
<
uint64_t
kWidth
3
>
Match
(
h2_t
hash
)
const
{
constexpr
uint64_t
msbs
=
0x8080808080808080ULL
;
constexpr
uint64_t
lsbs
=
0x0101010101010101ULL
;
auto
x
=
ctrl
^
(
lsbs
*
hash
)
;
return
BitMask
<
uint64_t
kWidth
3
>
(
(
x
-
lsbs
)
&
~
x
&
msbs
)
;
}
NonIterableBitMask
<
uint64_t
kWidth
3
>
MaskEmpty
(
)
const
{
constexpr
uint64_t
msbs
=
0x8080808080808080ULL
;
return
NonIterableBitMask
<
uint64_t
kWidth
3
>
(
(
ctrl
&
~
(
ctrl
<
<
6
)
)
&
msbs
)
;
}
NonIterableBitMask
<
uint64_t
kWidth
3
>
MaskEmptyOrDeleted
(
)
const
{
constexpr
uint64_t
msbs
=
0x8080808080808080ULL
;
return
NonIterableBitMask
<
uint64_t
kWidth
3
>
(
(
ctrl
&
~
(
ctrl
<
<
7
)
)
&
msbs
)
;
}
uint32_t
CountLeadingEmptyOrDeleted
(
)
const
{
constexpr
uint64_t
bits
=
0x0101010101010101ULL
;
return
static_cast
<
uint32_t
>
(
countr_zero
(
(
ctrl
|
~
(
ctrl
>
>
7
)
)
&
bits
)
>
>
3
)
;
}
void
ConvertSpecialToEmptyAndFullToDeleted
(
ctrl_t
*
dst
)
const
{
constexpr
uint64_t
msbs
=
0x8080808080808080ULL
;
constexpr
uint64_t
lsbs
=
0x0101010101010101ULL
;
auto
x
=
ctrl
&
msbs
;
auto
res
=
(
~
x
+
(
x
>
>
7
)
)
&
~
lsbs
;
little_endian
:
:
Store64
(
dst
res
)
;
}
uint64_t
ctrl
;
}
;
#
ifdef
ABSL_INTERNAL_HAVE_SSE2
using
Group
=
GroupSse2Impl
;
using
GroupEmptyOrDeleted
=
GroupSse2Impl
;
#
elif
defined
(
ABSL_INTERNAL_HAVE_ARM_NEON
)
&
&
defined
(
ABSL_IS_LITTLE_ENDIAN
)
using
Group
=
GroupAArch64Impl
;
using
GroupEmptyOrDeleted
=
GroupPortableImpl
;
#
else
using
Group
=
GroupPortableImpl
;
using
GroupEmptyOrDeleted
=
GroupPortableImpl
;
#
endif
inline
size_t
RehashProbabilityConstant
(
)
{
return
16
;
}
class
CommonFieldsGenerationInfoEnabled
{
static
constexpr
size_t
kReservedGrowthJustRanOut
=
(
std
:
:
numeric_limits
<
size_t
>
:
:
max
)
(
)
;
public
:
CommonFieldsGenerationInfoEnabled
(
)
=
default
;
CommonFieldsGenerationInfoEnabled
(
CommonFieldsGenerationInfoEnabled
&
&
that
)
:
reserved_growth_
(
that
.
reserved_growth_
)
reservation_size_
(
that
.
reservation_size_
)
generation_
(
that
.
generation_
)
{
that
.
reserved_growth_
=
0
;
that
.
reservation_size_
=
0
;
that
.
generation_
=
EmptyGeneration
(
)
;
}
CommonFieldsGenerationInfoEnabled
&
operator
=
(
CommonFieldsGenerationInfoEnabled
&
&
)
=
default
;
bool
should_rehash_for_bug_detection_on_insert
(
const
ctrl_t
*
ctrl
size_t
capacity
)
const
;
void
maybe_increment_generation_on_insert
(
)
{
if
(
reserved_growth_
=
=
kReservedGrowthJustRanOut
)
reserved_growth_
=
0
;
if
(
reserved_growth_
>
0
)
{
if
(
-
-
reserved_growth_
=
=
0
)
reserved_growth_
=
kReservedGrowthJustRanOut
;
}
else
{
*
generation_
=
NextGeneration
(
*
generation_
)
;
}
}
void
reset_reserved_growth
(
size_t
reservation
size_t
size
)
{
reserved_growth_
=
reservation
-
size
;
}
size_t
reserved_growth
(
)
const
{
return
reserved_growth_
;
}
void
set_reserved_growth
(
size_t
r
)
{
reserved_growth_
=
r
;
}
size_t
reservation_size
(
)
const
{
return
reservation_size_
;
}
void
set_reservation_size
(
size_t
r
)
{
reservation_size_
=
r
;
}
GenerationType
generation
(
)
const
{
return
*
generation_
;
}
void
set_generation
(
GenerationType
g
)
{
*
generation_
=
g
;
}
GenerationType
*
generation_ptr
(
)
const
{
return
generation_
;
}
void
set_generation_ptr
(
GenerationType
*
g
)
{
generation_
=
g
;
}
private
:
size_t
reserved_growth_
=
0
;
size_t
reservation_size_
=
0
;
GenerationType
*
generation_
=
EmptyGeneration
(
)
;
}
;
class
CommonFieldsGenerationInfoDisabled
{
public
:
CommonFieldsGenerationInfoDisabled
(
)
=
default
;
CommonFieldsGenerationInfoDisabled
(
CommonFieldsGenerationInfoDisabled
&
&
)
=
default
;
CommonFieldsGenerationInfoDisabled
&
operator
=
(
CommonFieldsGenerationInfoDisabled
&
&
)
=
default
;
bool
should_rehash_for_bug_detection_on_insert
(
const
ctrl_t
*
size_t
)
const
{
return
false
;
}
void
maybe_increment_generation_on_insert
(
)
{
}
void
reset_reserved_growth
(
size_t
size_t
)
{
}
size_t
reserved_growth
(
)
const
{
return
0
;
}
void
set_reserved_growth
(
size_t
)
{
}
size_t
reservation_size
(
)
const
{
return
0
;
}
void
set_reservation_size
(
size_t
)
{
}
GenerationType
generation
(
)
const
{
return
0
;
}
void
set_generation
(
GenerationType
)
{
}
GenerationType
*
generation_ptr
(
)
const
{
return
nullptr
;
}
void
set_generation_ptr
(
GenerationType
*
)
{
}
}
;
class
HashSetIteratorGenerationInfoEnabled
{
public
:
HashSetIteratorGenerationInfoEnabled
(
)
=
default
;
explicit
HashSetIteratorGenerationInfoEnabled
(
const
GenerationType
*
generation_ptr
)
:
generation_ptr_
(
generation_ptr
)
generation_
(
*
generation_ptr
)
{
}
GenerationType
generation
(
)
const
{
return
generation_
;
}
void
reset_generation
(
)
{
generation_
=
*
generation_ptr_
;
}
const
GenerationType
*
generation_ptr
(
)
const
{
return
generation_ptr_
;
}
void
set_generation_ptr
(
const
GenerationType
*
ptr
)
{
generation_ptr_
=
ptr
;
}
private
:
const
GenerationType
*
generation_ptr_
=
EmptyGeneration
(
)
;
GenerationType
generation_
=
*
generation_ptr_
;
}
;
class
HashSetIteratorGenerationInfoDisabled
{
public
:
HashSetIteratorGenerationInfoDisabled
(
)
=
default
;
explicit
HashSetIteratorGenerationInfoDisabled
(
const
GenerationType
*
)
{
}
GenerationType
generation
(
)
const
{
return
0
;
}
void
reset_generation
(
)
{
}
const
GenerationType
*
generation_ptr
(
)
const
{
return
nullptr
;
}
void
set_generation_ptr
(
const
GenerationType
*
)
{
}
}
;
#
ifdef
ABSL_SWISSTABLE_ENABLE_GENERATIONS
using
CommonFieldsGenerationInfo
=
CommonFieldsGenerationInfoEnabled
;
using
HashSetIteratorGenerationInfo
=
HashSetIteratorGenerationInfoEnabled
;
#
else
using
CommonFieldsGenerationInfo
=
CommonFieldsGenerationInfoDisabled
;
using
HashSetIteratorGenerationInfo
=
HashSetIteratorGenerationInfoDisabled
;
#
endif
inline
bool
IsValidCapacity
(
size_t
n
)
{
return
(
(
n
+
1
)
&
n
)
=
=
0
&
&
n
>
0
;
}
inline
size_t
ControlOffset
(
bool
has_infoz
)
{
return
(
has_infoz
?
sizeof
(
HashtablezInfoHandle
)
:
0
)
+
sizeof
(
size_t
)
;
}
constexpr
size_t
NumClonedBytes
(
)
{
return
Group
:
:
kWidth
-
1
;
}
inline
size_t
GenerationOffset
(
size_t
capacity
bool
has_infoz
)
{
assert
(
IsValidCapacity
(
capacity
)
)
;
const
size_t
num_control_bytes
=
capacity
+
1
+
NumClonedBytes
(
)
;
return
ControlOffset
(
has_infoz
)
+
num_control_bytes
;
}
inline
size_t
SlotOffset
(
size_t
capacity
size_t
slot_align
bool
has_infoz
)
{
assert
(
IsValidCapacity
(
capacity
)
)
;
return
(
GenerationOffset
(
capacity
has_infoz
)
+
NumGenerationBytes
(
)
+
slot_align
-
1
)
&
(
~
slot_align
+
1
)
;
}
inline
size_t
AllocSize
(
size_t
capacity
size_t
slot_size
size_t
slot_align
bool
has_infoz
)
{
return
SlotOffset
(
capacity
slot_align
has_infoz
)
+
capacity
*
slot_size
;
}
class
CommonFields
:
public
CommonFieldsGenerationInfo
{
public
:
CommonFields
(
)
=
default
;
CommonFields
(
const
CommonFields
&
)
=
delete
;
CommonFields
&
operator
=
(
const
CommonFields
&
)
=
delete
;
CommonFields
(
CommonFields
&
&
that
)
:
CommonFieldsGenerationInfo
(
std
:
:
move
(
static_cast
<
CommonFieldsGenerationInfo
&
&
>
(
that
)
)
)
control_
(
that
.
control
(
)
)
slots_
(
that
.
slot_array
(
)
)
capacity_
(
that
.
capacity
(
)
)
size_
(
that
.
size_
)
{
that
.
set_control
(
EmptyGroup
(
)
)
;
that
.
set_slots
(
nullptr
)
;
that
.
set_capacity
(
0
)
;
that
.
size_
=
0
;
}
CommonFields
&
operator
=
(
CommonFields
&
&
)
=
default
;
ctrl_t
*
control
(
)
const
{
return
control_
;
}
void
set_control
(
ctrl_t
*
c
)
{
control_
=
c
;
}
void
*
backing_array_start
(
)
const
{
assert
(
reinterpret_cast
<
uintptr_t
>
(
control
(
)
)
%
alignof
(
size_t
)
=
=
0
)
;
return
control
(
)
-
ControlOffset
(
has_infoz
(
)
)
;
}
void
*
slot_array
(
)
const
{
return
slots_
;
}
void
set_slots
(
void
*
s
)
{
slots_
=
s
;
}
size_t
size
(
)
const
{
return
size_
>
>
HasInfozShift
(
)
;
}
void
set_size
(
size_t
s
)
{
size_
=
(
s
<
<
HasInfozShift
(
)
)
|
(
size_
&
HasInfozMask
(
)
)
;
}
void
increment_size
(
)
{
assert
(
size
(
)
<
capacity
(
)
)
;
size_
+
=
size_t
{
1
}
<
<
HasInfozShift
(
)
;
}
void
decrement_size
(
)
{
assert
(
size
(
)
>
0
)
;
size_
-
=
size_t
{
1
}
<
<
HasInfozShift
(
)
;
}
size_t
capacity
(
)
const
{
return
capacity_
;
}
void
set_capacity
(
size_t
c
)
{
assert
(
c
=
=
0
|
|
IsValidCapacity
(
c
)
)
;
capacity_
=
c
;
}
size_t
growth_left
(
)
const
{
const
size_t
*
gl_ptr
=
reinterpret_cast
<
size_t
*
>
(
control
(
)
)
-
1
;
assert
(
reinterpret_cast
<
uintptr_t
>
(
gl_ptr
)
%
alignof
(
size_t
)
=
=
0
)
;
return
*
gl_ptr
;
}
void
set_growth_left
(
size_t
gl
)
{
size_t
*
gl_ptr
=
reinterpret_cast
<
size_t
*
>
(
control
(
)
)
-
1
;
assert
(
reinterpret_cast
<
uintptr_t
>
(
gl_ptr
)
%
alignof
(
size_t
)
=
=
0
)
;
*
gl_ptr
=
gl
;
}
bool
has_infoz
(
)
const
{
return
ABSL_PREDICT_FALSE
(
(
size_
&
HasInfozMask
(
)
)
!
=
0
)
;
}
void
set_has_infoz
(
bool
has_infoz
)
{
size_
=
(
size
(
)
<
<
HasInfozShift
(
)
)
|
static_cast
<
size_t
>
(
has_infoz
)
;
}
HashtablezInfoHandle
infoz
(
)
{
return
has_infoz
(
)
?
*
reinterpret_cast
<
HashtablezInfoHandle
*
>
(
backing_array_start
(
)
)
:
HashtablezInfoHandle
(
)
;
}
void
set_infoz
(
HashtablezInfoHandle
infoz
)
{
assert
(
has_infoz
(
)
)
;
*
reinterpret_cast
<
HashtablezInfoHandle
*
>
(
backing_array_start
(
)
)
=
infoz
;
}
bool
should_rehash_for_bug_detection_on_insert
(
)
const
{
return
CommonFieldsGenerationInfo
:
:
should_rehash_for_bug_detection_on_insert
(
control
(
)
capacity
(
)
)
;
}
void
reset_reserved_growth
(
size_t
reservation
)
{
CommonFieldsGenerationInfo
:
:
reset_reserved_growth
(
reservation
size
(
)
)
;
}
size_t
alloc_size
(
size_t
slot_size
size_t
slot_align
)
const
{
return
AllocSize
(
capacity
(
)
slot_size
slot_align
has_infoz
(
)
)
;
}
size_t
TombstonesCount
(
)
const
{
return
static_cast
<
size_t
>
(
std
:
:
count
(
control
(
)
control
(
)
+
capacity
(
)
ctrl_t
:
:
kDeleted
)
)
;
}
private
:
static
constexpr
size_t
HasInfozShift
(
)
{
return
1
;
}
static
constexpr
size_t
HasInfozMask
(
)
{
return
(
size_t
{
1
}
<
<
HasInfozShift
(
)
)
-
1
;
}
ctrl_t
*
control_
=
EmptyGroup
(
)
;
void
*
slots_
=
nullptr
;
size_t
capacity_
=
0
;
size_t
size_
=
0
;
}
;
template
<
class
Policy
class
Hash
class
Eq
class
Alloc
>
class
raw_hash_set
;
inline
size_t
NextCapacity
(
size_t
n
)
{
assert
(
IsValidCapacity
(
n
)
|
|
n
=
=
0
)
;
return
n
*
2
+
1
;
}
void
ConvertDeletedToEmptyAndFullToDeleted
(
ctrl_t
*
ctrl
size_t
capacity
)
;
inline
size_t
NormalizeCapacity
(
size_t
n
)
{
return
n
?
~
size_t
{
}
>
>
countl_zero
(
n
)
:
1
;
}
inline
size_t
CapacityToGrowth
(
size_t
capacity
)
{
assert
(
IsValidCapacity
(
capacity
)
)
;
if
(
Group
:
:
kWidth
=
=
8
&
&
capacity
=
=
7
)
{
return
6
;
}
return
capacity
-
capacity
/
8
;
}
inline
size_t
GrowthToLowerboundCapacity
(
size_t
growth
)
{
if
(
Group
:
:
kWidth
=
=
8
&
&
growth
=
=
7
)
{
return
8
;
}
return
growth
+
static_cast
<
size_t
>
(
(
static_cast
<
int64_t
>
(
growth
)
-
1
)
/
7
)
;
}
template
<
class
InputIter
>
size_t
SelectBucketCountForIterRange
(
InputIter
first
InputIter
last
size_t
bucket_count
)
{
if
(
bucket_count
!
=
0
)
{
return
bucket_count
;
}
using
InputIterCategory
=
typename
std
:
:
iterator_traits
<
InputIter
>
:
:
iterator_category
;
if
(
std
:
:
is_base_of
<
std
:
:
random_access_iterator_tag
InputIterCategory
>
:
:
value
)
{
return
GrowthToLowerboundCapacity
(
static_cast
<
size_t
>
(
std
:
:
distance
(
first
last
)
)
)
;
}
return
0
;
}
constexpr
bool
SwisstableDebugEnabled
(
)
{
#
if
defined
(
ABSL_SWISSTABLE_ENABLE_GENERATIONS
)
|
|
\
ABSL_OPTION_HARDENED
=
=
1
|
|
!
defined
(
NDEBUG
)
return
true
;
#
else
return
false
;
#
endif
}
inline
void
AssertIsFull
(
const
ctrl_t
*
ctrl
GenerationType
generation
const
GenerationType
*
generation_ptr
const
char
*
operation
)
{
if
(
!
SwisstableDebugEnabled
(
)
)
return
;
if
(
ABSL_PREDICT_FALSE
(
ctrl
=
=
nullptr
)
)
{
ABSL_RAW_LOG
(
FATAL
"
%
s
called
on
end
(
)
iterator
.
"
operation
)
;
}
if
(
ABSL_PREDICT_FALSE
(
ctrl
=
=
EmptyGroup
(
)
)
)
{
ABSL_RAW_LOG
(
FATAL
"
%
s
called
on
default
-
constructed
iterator
.
"
operation
)
;
}
if
(
SwisstableGenerationsEnabled
(
)
)
{
if
(
generation
!
=
*
generation_ptr
)
{
ABSL_INTERNAL_LOG
(
FATAL
std
:
:
string
(
operation
)
+
"
called
on
invalid
iterator
.
The
table
could
have
"
"
rehashed
since
this
iterator
was
initialized
.
"
)
;
}
if
(
!
IsFull
(
*
ctrl
)
)
{
ABSL_INTERNAL_LOG
(
FATAL
std
:
:
string
(
operation
)
+
"
called
on
invalid
iterator
.
The
element
was
likely
erased
.
"
)
;
}
}
else
{
if
(
ABSL_PREDICT_FALSE
(
!
IsFull
(
*
ctrl
)
)
)
{
ABSL_RAW_LOG
(
FATAL
"
%
s
called
on
invalid
iterator
.
The
element
might
have
been
erased
"
"
or
the
table
might
have
rehashed
.
Consider
running
with
"
"
-
-
config
=
asan
to
diagnose
rehashing
issues
.
"
operation
)
;
}
}
}
inline
void
AssertIsValidForComparison
(
const
ctrl_t
*
ctrl
GenerationType
generation
const
GenerationType
*
generation_ptr
)
{
if
(
!
SwisstableDebugEnabled
(
)
)
return
;
const
bool
ctrl_is_valid_for_comparison
=
ctrl
=
=
nullptr
|
|
ctrl
=
=
EmptyGroup
(
)
|
|
IsFull
(
*
ctrl
)
;
if
(
SwisstableGenerationsEnabled
(
)
)
{
if
(
generation
!
=
*
generation_ptr
)
{
ABSL_INTERNAL_LOG
(
FATAL
"
Invalid
iterator
comparison
.
The
table
could
have
"
"
rehashed
since
this
iterator
was
initialized
.
"
)
;
}
if
(
!
ctrl_is_valid_for_comparison
)
{
ABSL_INTERNAL_LOG
(
FATAL
"
Invalid
iterator
comparison
.
The
element
was
likely
erased
.
"
)
;
}
}
else
{
ABSL_HARDENING_ASSERT
(
ctrl_is_valid_for_comparison
&
&
"
Invalid
iterator
comparison
.
The
element
might
have
been
erased
or
"
"
the
table
might
have
rehashed
.
Consider
running
with
-
-
config
=
asan
to
"
"
diagnose
rehashing
issues
.
"
)
;
}
}
inline
bool
AreItersFromSameContainer
(
const
ctrl_t
*
ctrl_a
const
ctrl_t
*
ctrl_b
const
void
*
const
&
slot_a
const
void
*
const
&
slot_b
)
{
if
(
ctrl_a
=
=
nullptr
|
|
ctrl_b
=
=
nullptr
)
return
true
;
const
void
*
low_slot
=
slot_a
;
const
void
*
hi_slot
=
slot_b
;
if
(
ctrl_a
>
ctrl_b
)
{
std
:
:
swap
(
ctrl_a
ctrl_b
)
;
std
:
:
swap
(
low_slot
hi_slot
)
;
}
return
ctrl_b
<
low_slot
&
&
low_slot
<
=
hi_slot
;
}
inline
void
AssertSameContainer
(
const
ctrl_t
*
ctrl_a
const
ctrl_t
*
ctrl_b
const
void
*
const
&
slot_a
const
void
*
const
&
slot_b
const
GenerationType
*
generation_ptr_a
const
GenerationType
*
generation_ptr_b
)
{
if
(
!
SwisstableDebugEnabled
(
)
)
return
;
const
bool
a_is_default
=
ctrl_a
=
=
EmptyGroup
(
)
;
const
bool
b_is_default
=
ctrl_b
=
=
EmptyGroup
(
)
;
if
(
ABSL_PREDICT_FALSE
(
a_is_default
!
=
b_is_default
)
)
{
ABSL_RAW_LOG
(
FATAL
"
Invalid
iterator
comparison
.
Comparing
default
-
constructed
iterator
"
"
with
non
-
default
-
constructed
iterator
.
"
)
;
}
if
(
a_is_default
&
&
b_is_default
)
return
;
if
(
SwisstableGenerationsEnabled
(
)
)
{
if
(
generation_ptr_a
=
=
generation_ptr_b
)
return
;
const
bool
a_is_empty
=
IsEmptyGeneration
(
generation_ptr_a
)
;
const
bool
b_is_empty
=
IsEmptyGeneration
(
generation_ptr_b
)
;
if
(
a_is_empty
!
=
b_is_empty
)
{
ABSL_INTERNAL_LOG
(
FATAL
"
Invalid
iterator
comparison
.
Comparing
iterator
from
"
"
a
non
-
empty
hashtable
with
an
iterator
from
an
empty
"
"
hashtable
.
"
)
;
}
if
(
a_is_empty
&
&
b_is_empty
)
{
ABSL_INTERNAL_LOG
(
FATAL
"
Invalid
iterator
comparison
.
Comparing
iterators
from
"
"
different
empty
hashtables
.
"
)
;
}
const
bool
a_is_end
=
ctrl_a
=
=
nullptr
;
const
bool
b_is_end
=
ctrl_b
=
=
nullptr
;
if
(
a_is_end
|
|
b_is_end
)
{
ABSL_INTERNAL_LOG
(
FATAL
"
Invalid
iterator
comparison
.
Comparing
iterator
with
"
"
an
end
(
)
iterator
from
a
different
hashtable
.
"
)
;
}
ABSL_INTERNAL_LOG
(
FATAL
"
Invalid
iterator
comparison
.
Comparing
non
-
end
(
)
"
"
iterators
from
different
hashtables
.
"
)
;
}
else
{
ABSL_HARDENING_ASSERT
(
AreItersFromSameContainer
(
ctrl_a
ctrl_b
slot_a
slot_b
)
&
&
"
Invalid
iterator
comparison
.
The
iterators
may
be
from
different
"
"
containers
or
the
container
might
have
rehashed
.
Consider
running
"
"
with
-
-
config
=
asan
to
diagnose
rehashing
issues
.
"
)
;
}
}
struct
FindInfo
{
size_t
offset
;
size_t
probe_length
;
}
;
inline
bool
is_small
(
size_t
capacity
)
{
return
capacity
<
Group
:
:
kWidth
-
1
;
}
inline
probe_seq
<
Group
:
:
kWidth
>
probe
(
const
ctrl_t
*
ctrl
const
size_t
capacity
size_t
hash
)
{
return
probe_seq
<
Group
:
:
kWidth
>
(
H1
(
hash
ctrl
)
capacity
)
;
}
inline
probe_seq
<
Group
:
:
kWidth
>
probe
(
const
CommonFields
&
common
size_t
hash
)
{
return
probe
(
common
.
control
(
)
common
.
capacity
(
)
hash
)
;
}
template
<
typename
=
void
>
inline
FindInfo
find_first_non_full
(
const
CommonFields
&
common
size_t
hash
)
{
auto
seq
=
probe
(
common
hash
)
;
const
ctrl_t
*
ctrl
=
common
.
control
(
)
;
while
(
true
)
{
GroupEmptyOrDeleted
g
{
ctrl
+
seq
.
offset
(
)
}
;
auto
mask
=
g
.
MaskEmptyOrDeleted
(
)
;
if
(
mask
)
{
#
if
!
defined
(
NDEBUG
)
if
(
!
is_small
(
common
.
capacity
(
)
)
&
&
ShouldInsertBackwards
(
hash
ctrl
)
)
{
return
{
seq
.
offset
(
mask
.
HighestBitSet
(
)
)
seq
.
index
(
)
}
;
}
#
endif
return
{
seq
.
offset
(
mask
.
LowestBitSet
(
)
)
seq
.
index
(
)
}
;
}
seq
.
next
(
)
;
assert
(
seq
.
index
(
)
<
=
common
.
capacity
(
)
&
&
"
full
table
!
"
)
;
}
}
extern
template
FindInfo
find_first_non_full
(
const
CommonFields
&
size_t
)
;
FindInfo
find_first_non_full_outofline
(
const
CommonFields
&
size_t
)
;
inline
void
ResetGrowthLeft
(
CommonFields
&
common
)
{
common
.
set_growth_left
(
CapacityToGrowth
(
common
.
capacity
(
)
)
-
common
.
size
(
)
)
;
}
inline
void
ResetCtrl
(
CommonFields
&
common
size_t
slot_size
)
{
const
size_t
capacity
=
common
.
capacity
(
)
;
ctrl_t
*
ctrl
=
common
.
control
(
)
;
std
:
:
memset
(
ctrl
static_cast
<
int8_t
>
(
ctrl_t
:
:
kEmpty
)
capacity
+
1
+
NumClonedBytes
(
)
)
;
ctrl
[
capacity
]
=
ctrl_t
:
:
kSentinel
;
SanitizerPoisonMemoryRegion
(
common
.
slot_array
(
)
slot_size
*
capacity
)
;
ResetGrowthLeft
(
common
)
;
}
inline
void
SetCtrl
(
const
CommonFields
&
common
size_t
i
ctrl_t
h
size_t
slot_size
)
{
const
size_t
capacity
=
common
.
capacity
(
)
;
assert
(
i
<
capacity
)
;
auto
*
slot_i
=
static_cast
<
const
char
*
>
(
common
.
slot_array
(
)
)
+
i
*
slot_size
;
if
(
IsFull
(
h
)
)
{
SanitizerUnpoisonMemoryRegion
(
slot_i
slot_size
)
;
}
else
{
SanitizerPoisonMemoryRegion
(
slot_i
slot_size
)
;
}
ctrl_t
*
ctrl
=
common
.
control
(
)
;
ctrl
[
i
]
=
h
;
ctrl
[
(
(
i
-
NumClonedBytes
(
)
)
&
capacity
)
+
(
NumClonedBytes
(
)
&
capacity
)
]
=
h
;
}
inline
void
SetCtrl
(
const
CommonFields
&
common
size_t
i
h2_t
h
size_t
slot_size
)
{
SetCtrl
(
common
i
static_cast
<
ctrl_t
>
(
h
)
slot_size
)
;
}
constexpr
size_t
BackingArrayAlignment
(
size_t
align_of_slot
)
{
return
(
std
:
:
max
)
(
align_of_slot
alignof
(
size_t
)
)
;
}
template
<
typename
Alloc
size_t
SizeOfSlot
size_t
AlignOfSlot
>
ABSL_ATTRIBUTE_NOINLINE
void
InitializeSlots
(
CommonFields
&
c
Alloc
alloc
)
{
assert
(
c
.
capacity
(
)
)
;
const
size_t
sample_size
=
(
std
:
:
is_same
<
Alloc
std
:
:
allocator
<
char
>
>
:
:
value
&
&
c
.
slot_array
(
)
=
=
nullptr
)
?
SizeOfSlot
:
0
;
HashtablezInfoHandle
infoz
=
sample_size
>
0
?
Sample
(
sample_size
)
:
c
.
infoz
(
)
;
const
bool
has_infoz
=
infoz
.
IsSampled
(
)
;
const
size_t
cap
=
c
.
capacity
(
)
;
const
size_t
alloc_size
=
AllocSize
(
cap
SizeOfSlot
AlignOfSlot
has_infoz
)
;
char
*
mem
=
static_cast
<
char
*
>
(
Allocate
<
BackingArrayAlignment
(
AlignOfSlot
)
>
(
&
alloc
alloc_size
)
)
;
const
GenerationType
old_generation
=
c
.
generation
(
)
;
c
.
set_generation_ptr
(
reinterpret_cast
<
GenerationType
*
>
(
mem
+
GenerationOffset
(
cap
has_infoz
)
)
)
;
c
.
set_generation
(
NextGeneration
(
old_generation
)
)
;
c
.
set_control
(
reinterpret_cast
<
ctrl_t
*
>
(
mem
+
ControlOffset
(
has_infoz
)
)
)
;
c
.
set_slots
(
mem
+
SlotOffset
(
cap
AlignOfSlot
has_infoz
)
)
;
ResetCtrl
(
c
SizeOfSlot
)
;
c
.
set_has_infoz
(
has_infoz
)
;
if
(
has_infoz
)
{
infoz
.
RecordStorageChanged
(
c
.
size
(
)
cap
)
;
c
.
set_infoz
(
infoz
)
;
}
}
struct
PolicyFunctions
{
size_t
slot_size
;
size_t
(
*
hash_slot
)
(
void
*
set
void
*
slot
)
;
void
(
*
transfer
)
(
void
*
set
void
*
dst_slot
void
*
src_slot
)
;
void
(
*
dealloc
)
(
CommonFields
&
common
const
PolicyFunctions
&
policy
)
;
}
;
void
ClearBackingArray
(
CommonFields
&
c
const
PolicyFunctions
&
policy
bool
reuse
)
;
void
EraseMetaOnly
(
CommonFields
&
c
ctrl_t
*
it
size_t
slot_size
)
;
template
<
size_t
AlignOfSlot
>
ABSL_ATTRIBUTE_NOINLINE
void
DeallocateStandard
(
CommonFields
&
common
const
PolicyFunctions
&
policy
)
{
SanitizerUnpoisonMemoryRegion
(
common
.
slot_array
(
)
policy
.
slot_size
*
common
.
capacity
(
)
)
;
std
:
:
allocator
<
char
>
alloc
;
common
.
infoz
(
)
.
Unregister
(
)
;
Deallocate
<
BackingArrayAlignment
(
AlignOfSlot
)
>
(
&
alloc
common
.
backing_array_start
(
)
common
.
alloc_size
(
policy
.
slot_size
AlignOfSlot
)
)
;
}
template
<
size_t
SizeOfSlot
>
ABSL_ATTRIBUTE_NOINLINE
void
TransferRelocatable
(
void
*
void
*
dst
void
*
src
)
{
memcpy
(
dst
src
SizeOfSlot
)
;
}
void
DropDeletesWithoutResize
(
CommonFields
&
common
const
PolicyFunctions
&
policy
void
*
tmp_space
)
;
template
<
class
Policy
class
Hash
class
Eq
class
Alloc
>
class
raw_hash_set
{
using
PolicyTraits
=
hash_policy_traits
<
Policy
>
;
using
KeyArgImpl
=
KeyArg
<
IsTransparent
<
Eq
>
:
:
value
&
&
IsTransparent
<
Hash
>
:
:
value
>
;
public
:
using
init_type
=
typename
PolicyTraits
:
:
init_type
;
using
key_type
=
typename
PolicyTraits
:
:
key_type
;
using
slot_type
=
typename
PolicyTraits
:
:
slot_type
;
using
allocator_type
=
Alloc
;
using
size_type
=
size_t
;
using
difference_type
=
ptrdiff_t
;
using
hasher
=
Hash
;
using
key_equal
=
Eq
;
using
policy_type
=
Policy
;
using
value_type
=
typename
PolicyTraits
:
:
value_type
;
using
reference
=
value_type
&
;
using
const_reference
=
const
value_type
&
;
using
pointer
=
typename
absl
:
:
allocator_traits
<
allocator_type
>
:
:
template
rebind_traits
<
value_type
>
:
:
pointer
;
using
const_pointer
=
typename
absl
:
:
allocator_traits
<
allocator_type
>
:
:
template
rebind_traits
<
value_type
>
:
:
const_pointer
;
template
<
class
K
>
using
key_arg
=
typename
KeyArgImpl
:
:
template
type
<
K
key_type
>
;
private
:
auto
KeyTypeCanBeHashed
(
const
Hash
&
h
const
key_type
&
k
)
-
>
decltype
(
h
(
k
)
)
;
auto
KeyTypeCanBeEq
(
const
Eq
&
eq
const
key_type
&
k
)
-
>
decltype
(
eq
(
k
k
)
)
;
using
AllocTraits
=
absl
:
:
allocator_traits
<
allocator_type
>
;
using
SlotAlloc
=
typename
absl
:
:
allocator_traits
<
allocator_type
>
:
:
template
rebind_alloc
<
slot_type
>
;
using
SlotAllocTraits
=
typename
absl
:
:
allocator_traits
<
allocator_type
>
:
:
template
rebind_traits
<
slot_type
>
;
static_assert
(
std
:
:
is_lvalue_reference
<
reference
>
:
:
value
"
Policy
:
:
element
(
)
must
return
a
reference
"
)
;
template
<
typename
T
>
struct
SameAsElementReference
:
std
:
:
is_same
<
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
reference
>
:
:
type
>
:
:
type
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
:
:
type
>
{
}
;
template
<
class
T
>
using
RequiresInsertable
=
typename
std
:
:
enable_if
<
absl
:
:
disjunction
<
std
:
:
is_convertible
<
T
init_type
>
SameAsElementReference
<
T
>
>
:
:
value
int
>
:
:
type
;
template
<
class
T
>
using
RequiresNotInit
=
typename
std
:
:
enable_if
<
!
std
:
:
is_same
<
T
init_type
>
:
:
value
int
>
:
:
type
;
template
<
class
.
.
.
Ts
>
using
IsDecomposable
=
IsDecomposable
<
void
PolicyTraits
Hash
Eq
Ts
.
.
.
>
;
public
:
static_assert
(
std
:
:
is_same
<
pointer
value_type
*
>
:
:
value
"
Allocators
with
custom
pointer
types
are
not
supported
"
)
;
static_assert
(
std
:
:
is_same
<
const_pointer
const
value_type
*
>
:
:
value
"
Allocators
with
custom
pointer
types
are
not
supported
"
)
;
class
iterator
:
private
HashSetIteratorGenerationInfo
{
friend
class
raw_hash_set
;
public
:
using
iterator_category
=
std
:
:
forward_iterator_tag
;
using
value_type
=
typename
raw_hash_set
:
:
value_type
;
using
reference
=
absl
:
:
conditional_t
<
PolicyTraits
:
:
constant_iterators
:
:
value
const
value_type
&
value_type
&
>
;
using
pointer
=
absl
:
:
remove_reference_t
<
reference
>
*
;
using
difference_type
=
typename
raw_hash_set
:
:
difference_type
;
iterator
(
)
{
}
reference
operator
*
(
)
const
{
AssertIsFull
(
ctrl_
generation
(
)
generation_ptr
(
)
"
operator
*
(
)
"
)
;
return
PolicyTraits
:
:
element
(
slot_
)
;
}
pointer
operator
-
>
(
)
const
{
AssertIsFull
(
ctrl_
generation
(
)
generation_ptr
(
)
"
operator
-
>
"
)
;
return
&
operator
*
(
)
;
}
iterator
&
operator
+
+
(
)
{
AssertIsFull
(
ctrl_
generation
(
)
generation_ptr
(
)
"
operator
+
+
"
)
;
+
+
ctrl_
;
+
+
slot_
;
skip_empty_or_deleted
(
)
;
return
*
this
;
}
iterator
operator
+
+
(
int
)
{
auto
tmp
=
*
this
;
+
+
*
this
;
return
tmp
;
}
friend
bool
operator
=
=
(
const
iterator
&
a
const
iterator
&
b
)
{
AssertIsValidForComparison
(
a
.
ctrl_
a
.
generation
(
)
a
.
generation_ptr
(
)
)
;
AssertIsValidForComparison
(
b
.
ctrl_
b
.
generation
(
)
b
.
generation_ptr
(
)
)
;
AssertSameContainer
(
a
.
ctrl_
b
.
ctrl_
a
.
slot_
b
.
slot_
a
.
generation_ptr
(
)
b
.
generation_ptr
(
)
)
;
return
a
.
ctrl_
=
=
b
.
ctrl_
;
}
friend
bool
operator
!
=
(
const
iterator
&
a
const
iterator
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
iterator
(
ctrl_t
*
ctrl
slot_type
*
slot
const
GenerationType
*
generation_ptr
)
:
HashSetIteratorGenerationInfo
(
generation_ptr
)
ctrl_
(
ctrl
)
slot_
(
slot
)
{
ABSL_ASSUME
(
ctrl
!
=
nullptr
)
;
}
explicit
iterator
(
const
GenerationType
*
generation_ptr
)
:
HashSetIteratorGenerationInfo
(
generation_ptr
)
ctrl_
(
nullptr
)
{
}
void
skip_empty_or_deleted
(
)
{
while
(
IsEmptyOrDeleted
(
*
ctrl_
)
)
{
uint32_t
shift
=
GroupEmptyOrDeleted
{
ctrl_
}
.
CountLeadingEmptyOrDeleted
(
)
;
ctrl_
+
=
shift
;
slot_
+
=
shift
;
}
if
(
ABSL_PREDICT_FALSE
(
*
ctrl_
=
=
ctrl_t
:
:
kSentinel
)
)
ctrl_
=
nullptr
;
}
ctrl_t
*
ctrl_
=
EmptyGroup
(
)
;
union
{
slot_type
*
slot_
;
}
;
}
;
class
const_iterator
{
friend
class
raw_hash_set
;
public
:
using
iterator_category
=
typename
iterator
:
:
iterator_category
;
using
value_type
=
typename
raw_hash_set
:
:
value_type
;
using
reference
=
typename
raw_hash_set
:
:
const_reference
;
using
pointer
=
typename
raw_hash_set
:
:
const_pointer
;
using
difference_type
=
typename
raw_hash_set
:
:
difference_type
;
const_iterator
(
)
=
default
;
const_iterator
(
iterator
i
)
:
inner_
(
std
:
:
move
(
i
)
)
{
}
reference
operator
*
(
)
const
{
return
*
inner_
;
}
pointer
operator
-
>
(
)
const
{
return
inner_
.
operator
-
>
(
)
;
}
const_iterator
&
operator
+
+
(
)
{
+
+
inner_
;
return
*
this
;
}
const_iterator
operator
+
+
(
int
)
{
return
inner_
+
+
;
}
friend
bool
operator
=
=
(
const
const_iterator
&
a
const
const_iterator
&
b
)
{
return
a
.
inner_
=
=
b
.
inner_
;
}
friend
bool
operator
!
=
(
const
const_iterator
&
a
const
const_iterator
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
const_iterator
(
const
ctrl_t
*
ctrl
const
slot_type
*
slot
const
GenerationType
*
gen
)
:
inner_
(
const_cast
<
ctrl_t
*
>
(
ctrl
)
const_cast
<
slot_type
*
>
(
slot
)
gen
)
{
}
iterator
inner_
;
}
;
using
node_type
=
node_handle
<
Policy
hash_policy_traits
<
Policy
>
Alloc
>
;
using
insert_return_type
=
InsertReturnType
<
iterator
node_type
>
;
raw_hash_set
(
)
noexcept
(
std
:
:
is_nothrow_default_constructible
<
hasher
>
:
:
value
&
&
std
:
:
is_nothrow_default_constructible
<
key_equal
>
:
:
value
&
&
std
:
:
is_nothrow_default_constructible
<
allocator_type
>
:
:
value
)
{
}
ABSL_ATTRIBUTE_NOINLINE
explicit
raw_hash_set
(
size_t
bucket_count
const
hasher
&
hash
=
hasher
(
)
const
key_equal
&
eq
=
key_equal
(
)
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
settings_
(
CommonFields
{
}
hash
eq
alloc
)
{
if
(
bucket_count
)
{
common
(
)
.
set_capacity
(
NormalizeCapacity
(
bucket_count
)
)
;
initialize_slots
(
)
;
}
}
raw_hash_set
(
size_t
bucket_count
const
hasher
&
hash
const
allocator_type
&
alloc
)
:
raw_hash_set
(
bucket_count
hash
key_equal
(
)
alloc
)
{
}
raw_hash_set
(
size_t
bucket_count
const
allocator_type
&
alloc
)
:
raw_hash_set
(
bucket_count
hasher
(
)
key_equal
(
)
alloc
)
{
}
explicit
raw_hash_set
(
const
allocator_type
&
alloc
)
:
raw_hash_set
(
0
hasher
(
)
key_equal
(
)
alloc
)
{
}
template
<
class
InputIter
>
raw_hash_set
(
InputIter
first
InputIter
last
size_t
bucket_count
=
0
const
hasher
&
hash
=
hasher
(
)
const
key_equal
&
eq
=
key_equal
(
)
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
raw_hash_set
(
SelectBucketCountForIterRange
(
first
last
bucket_count
)
hash
eq
alloc
)
{
insert
(
first
last
)
;
}
template
<
class
InputIter
>
raw_hash_set
(
InputIter
first
InputIter
last
size_t
bucket_count
const
hasher
&
hash
const
allocator_type
&
alloc
)
:
raw_hash_set
(
first
last
bucket_count
hash
key_equal
(
)
alloc
)
{
}
template
<
class
InputIter
>
raw_hash_set
(
InputIter
first
InputIter
last
size_t
bucket_count
const
allocator_type
&
alloc
)
:
raw_hash_set
(
first
last
bucket_count
hasher
(
)
key_equal
(
)
alloc
)
{
}
template
<
class
InputIter
>
raw_hash_set
(
InputIter
first
InputIter
last
const
allocator_type
&
alloc
)
:
raw_hash_set
(
first
last
0
hasher
(
)
key_equal
(
)
alloc
)
{
}
template
<
class
T
RequiresNotInit
<
T
>
=
0
RequiresInsertable
<
T
>
=
0
>
raw_hash_set
(
std
:
:
initializer_list
<
T
>
init
size_t
bucket_count
=
0
const
hasher
&
hash
=
hasher
(
)
const
key_equal
&
eq
=
key_equal
(
)
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
raw_hash_set
(
init
.
begin
(
)
init
.
end
(
)
bucket_count
hash
eq
alloc
)
{
}
raw_hash_set
(
std
:
:
initializer_list
<
init_type
>
init
size_t
bucket_count
=
0
const
hasher
&
hash
=
hasher
(
)
const
key_equal
&
eq
=
key_equal
(
)
const
allocator_type
&
alloc
=
allocator_type
(
)
)
:
raw_hash_set
(
init
.
begin
(
)
init
.
end
(
)
bucket_count
hash
eq
alloc
)
{
}
template
<
class
T
RequiresNotInit
<
T
>
=
0
RequiresInsertable
<
T
>
=
0
>
raw_hash_set
(
std
:
:
initializer_list
<
T
>
init
size_t
bucket_count
const
hasher
&
hash
const
allocator_type
&
alloc
)
:
raw_hash_set
(
init
bucket_count
hash
key_equal
(
)
alloc
)
{
}
raw_hash_set
(
std
:
:
initializer_list
<
init_type
>
init
size_t
bucket_count
const
hasher
&
hash
const
allocator_type
&
alloc
)
:
raw_hash_set
(
init
bucket_count
hash
key_equal
(
)
alloc
)
{
}
template
<
class
T
RequiresNotInit
<
T
>
=
0
RequiresInsertable
<
T
>
=
0
>
raw_hash_set
(
std
:
:
initializer_list
<
T
>
init
size_t
bucket_count
const
allocator_type
&
alloc
)
:
raw_hash_set
(
init
bucket_count
hasher
(
)
key_equal
(
)
alloc
)
{
}
raw_hash_set
(
std
:
:
initializer_list
<
init_type
>
init
size_t
bucket_count
const
allocator_type
&
alloc
)
:
raw_hash_set
(
init
bucket_count
hasher
(
)
key_equal
(
)
alloc
)
{
}
template
<
class
T
RequiresNotInit
<
T
>
=
0
RequiresInsertable
<
T
>
=
0
>
raw_hash_set
(
std
:
:
initializer_list
<
T
>
init
const
allocator_type
&
alloc
)
:
raw_hash_set
(
init
0
hasher
(
)
key_equal
(
)
alloc
)
{
}
raw_hash_set
(
std
:
:
initializer_list
<
init_type
>
init
const
allocator_type
&
alloc
)
:
raw_hash_set
(
init
0
hasher
(
)
key_equal
(
)
alloc
)
{
}
raw_hash_set
(
const
raw_hash_set
&
that
)
:
raw_hash_set
(
that
AllocTraits
:
:
select_on_container_copy_construction
(
that
.
alloc_ref
(
)
)
)
{
}
raw_hash_set
(
const
raw_hash_set
&
that
const
allocator_type
&
a
)
:
raw_hash_set
(
0
that
.
hash_ref
(
)
that
.
eq_ref
(
)
a
)
{
const
size_t
size
=
that
.
size
(
)
;
if
(
size
=
=
0
)
return
;
reserve
(
size
)
;
for
(
const
auto
&
v
:
that
)
{
const
size_t
hash
=
PolicyTraits
:
:
apply
(
HashElement
{
hash_ref
(
)
}
v
)
;
auto
target
=
find_first_non_full_outofline
(
common
(
)
hash
)
;
SetCtrl
(
common
(
)
target
.
offset
H2
(
hash
)
sizeof
(
slot_type
)
)
;
emplace_at
(
target
.
offset
v
)
;
common
(
)
.
maybe_increment_generation_on_insert
(
)
;
infoz
(
)
.
RecordInsert
(
hash
target
.
probe_length
)
;
}
common
(
)
.
set_size
(
size
)
;
set_growth_left
(
growth_left
(
)
-
size
)
;
}
ABSL_ATTRIBUTE_NOINLINE
raw_hash_set
(
raw_hash_set
&
&
that
)
noexcept
(
std
:
:
is_nothrow_copy_constructible
<
hasher
>
:
:
value
&
&
std
:
:
is_nothrow_copy_constructible
<
key_equal
>
:
:
value
&
&
std
:
:
is_nothrow_copy_constructible
<
allocator_type
>
:
:
value
)
:
settings_
(
absl
:
:
exchange
(
that
.
common
(
)
CommonFields
{
}
)
that
.
hash_ref
(
)
that
.
eq_ref
(
)
that
.
alloc_ref
(
)
)
{
}
raw_hash_set
(
raw_hash_set
&
&
that
const
allocator_type
&
a
)
:
settings_
(
CommonFields
{
}
that
.
hash_ref
(
)
that
.
eq_ref
(
)
a
)
{
if
(
a
=
=
that
.
alloc_ref
(
)
)
{
std
:
:
swap
(
common
(
)
that
.
common
(
)
)
;
}
else
{
reserve
(
that
.
size
(
)
)
;
for
(
auto
&
elem
:
that
)
insert
(
std
:
:
move
(
elem
)
)
;
}
}
raw_hash_set
&
operator
=
(
const
raw_hash_set
&
that
)
{
raw_hash_set
tmp
(
that
AllocTraits
:
:
propagate_on_container_copy_assignment
:
:
value
?
that
.
alloc_ref
(
)
:
alloc_ref
(
)
)
;
swap
(
tmp
)
;
return
*
this
;
}
raw_hash_set
&
operator
=
(
raw_hash_set
&
&
that
)
noexcept
(
absl
:
:
allocator_traits
<
allocator_type
>
:
:
is_always_equal
:
:
value
&
&
std
:
:
is_nothrow_move_assignable
<
hasher
>
:
:
value
&
&
std
:
:
is_nothrow_move_assignable
<
key_equal
>
:
:
value
)
{
return
move_assign
(
std
:
:
move
(
that
)
typename
AllocTraits
:
:
propagate_on_container_move_assignment
(
)
)
;
}
~
raw_hash_set
(
)
{
const
size_t
cap
=
capacity
(
)
;
if
(
!
cap
)
return
;
destroy_slots
(
)
;
SanitizerUnpoisonMemoryRegion
(
slot_array
(
)
sizeof
(
slot_type
)
*
cap
)
;
infoz
(
)
.
Unregister
(
)
;
Deallocate
<
BackingArrayAlignment
(
alignof
(
slot_type
)
)
>
(
&
alloc_ref
(
)
common
(
)
.
backing_array_start
(
)
common
(
)
.
alloc_size
(
sizeof
(
slot_type
)
alignof
(
slot_type
)
)
)
;
}
iterator
begin
(
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
it
=
iterator_at
(
0
)
;
it
.
skip_empty_or_deleted
(
)
;
return
it
;
}
iterator
end
(
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
iterator
(
common
(
)
.
generation_ptr
(
)
)
;
}
const_iterator
begin
(
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
const_cast
<
raw_hash_set
*
>
(
this
)
-
>
begin
(
)
;
}
const_iterator
end
(
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
iterator
(
common
(
)
.
generation_ptr
(
)
)
;
}
const_iterator
cbegin
(
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
begin
(
)
;
}
const_iterator
cend
(
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
end
(
)
;
}
bool
empty
(
)
const
{
return
!
size
(
)
;
}
size_t
size
(
)
const
{
return
common
(
)
.
size
(
)
;
}
size_t
capacity
(
)
const
{
return
common
(
)
.
capacity
(
)
;
}
size_t
max_size
(
)
const
{
return
(
std
:
:
numeric_limits
<
size_t
>
:
:
max
)
(
)
;
}
ABSL_ATTRIBUTE_REINITIALIZES
void
clear
(
)
{
const
size_t
cap
=
capacity
(
)
;
if
(
cap
=
=
0
)
{
}
else
{
destroy_slots
(
)
;
ClearBackingArray
(
common
(
)
GetPolicyFunctions
(
)
cap
<
128
)
;
}
common
(
)
.
set_reserved_growth
(
0
)
;
common
(
)
.
set_reservation_size
(
0
)
;
}
template
<
class
T
RequiresInsertable
<
T
>
=
0
class
T2
=
T
typename
std
:
:
enable_if
<
IsDecomposable
<
T2
>
:
:
value
int
>
:
:
type
=
0
T
*
=
nullptr
>
std
:
:
pair
<
iterator
bool
>
insert
(
T
&
&
value
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
emplace
(
std
:
:
forward
<
T
>
(
value
)
)
;
}
template
<
class
T
RequiresInsertable
<
const
T
&
>
=
0
typename
std
:
:
enable_if
<
IsDecomposable
<
const
T
&
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
insert
(
const
T
&
value
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
emplace
(
value
)
;
}
std
:
:
pair
<
iterator
bool
>
insert
(
init_type
&
&
value
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
emplace
(
std
:
:
move
(
value
)
)
;
}
template
<
class
T
RequiresInsertable
<
T
>
=
0
class
T2
=
T
typename
std
:
:
enable_if
<
IsDecomposable
<
T2
>
:
:
value
int
>
:
:
type
=
0
T
*
=
nullptr
>
iterator
insert
(
const_iterator
T
&
&
value
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
insert
(
std
:
:
forward
<
T
>
(
value
)
)
.
first
;
}
template
<
class
T
RequiresInsertable
<
const
T
&
>
=
0
typename
std
:
:
enable_if
<
IsDecomposable
<
const
T
&
>
:
:
value
int
>
:
:
type
=
0
>
iterator
insert
(
const_iterator
const
T
&
value
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
insert
(
value
)
.
first
;
}
iterator
insert
(
const_iterator
init_type
&
&
value
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
insert
(
std
:
:
move
(
value
)
)
.
first
;
}
template
<
class
InputIt
>
void
insert
(
InputIt
first
InputIt
last
)
{
for
(
;
first
!
=
last
;
+
+
first
)
emplace
(
*
first
)
;
}
template
<
class
T
RequiresNotInit
<
T
>
=
0
RequiresInsertable
<
const
T
&
>
=
0
>
void
insert
(
std
:
:
initializer_list
<
T
>
ilist
)
{
insert
(
ilist
.
begin
(
)
ilist
.
end
(
)
)
;
}
void
insert
(
std
:
:
initializer_list
<
init_type
>
ilist
)
{
insert
(
ilist
.
begin
(
)
ilist
.
end
(
)
)
;
}
insert_return_type
insert
(
node_type
&
&
node
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
if
(
!
node
)
return
{
end
(
)
false
node_type
(
)
}
;
const
auto
&
elem
=
PolicyTraits
:
:
element
(
CommonAccess
:
:
GetSlot
(
node
)
)
;
auto
res
=
PolicyTraits
:
:
apply
(
InsertSlot
<
false
>
{
*
this
std
:
:
move
(
*
CommonAccess
:
:
GetSlot
(
node
)
)
}
elem
)
;
if
(
res
.
second
)
{
CommonAccess
:
:
Reset
(
&
node
)
;
return
{
res
.
first
true
node_type
(
)
}
;
}
else
{
return
{
res
.
first
false
std
:
:
move
(
node
)
}
;
}
}
iterator
insert
(
const_iterator
node_type
&
&
node
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
res
=
insert
(
std
:
:
move
(
node
)
)
;
node
=
std
:
:
move
(
res
.
node
)
;
return
res
.
position
;
}
template
<
class
.
.
.
Args
typename
std
:
:
enable_if
<
IsDecomposable
<
Args
.
.
.
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
emplace
(
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
PolicyTraits
:
:
apply
(
EmplaceDecomposable
{
*
this
}
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
class
.
.
.
Args
typename
std
:
:
enable_if
<
!
IsDecomposable
<
Args
.
.
.
>
:
:
value
int
>
:
:
type
=
0
>
std
:
:
pair
<
iterator
bool
>
emplace
(
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
alignas
(
slot_type
)
unsigned
char
raw
[
sizeof
(
slot_type
)
]
;
slot_type
*
slot
=
reinterpret_cast
<
slot_type
*
>
(
&
raw
)
;
PolicyTraits
:
:
construct
(
&
alloc_ref
(
)
slot
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
const
auto
&
elem
=
PolicyTraits
:
:
element
(
slot
)
;
return
PolicyTraits
:
:
apply
(
InsertSlot
<
true
>
{
*
this
std
:
:
move
(
*
slot
)
}
elem
)
;
}
template
<
class
.
.
.
Args
>
iterator
emplace_hint
(
const_iterator
Args
&
&
.
.
.
args
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
emplace
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
.
first
;
}
class
constructor
{
friend
class
raw_hash_set
;
public
:
template
<
class
.
.
.
Args
>
void
operator
(
)
(
Args
&
&
.
.
.
args
)
const
{
assert
(
*
slot_
)
;
PolicyTraits
:
:
construct
(
alloc_
*
slot_
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
*
slot_
=
nullptr
;
}
private
:
constructor
(
allocator_type
*
a
slot_type
*
*
slot
)
:
alloc_
(
a
)
slot_
(
slot
)
{
}
allocator_type
*
alloc_
;
slot_type
*
*
slot_
;
}
;
template
<
class
K
=
key_type
class
F
>
iterator
lazy_emplace
(
const
key_arg
<
K
>
&
key
F
&
&
f
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
res
=
find_or_prepare_insert
(
key
)
;
if
(
res
.
second
)
{
slot_type
*
slot
=
slot_array
(
)
+
res
.
first
;
std
:
:
forward
<
F
>
(
f
)
(
constructor
(
&
alloc_ref
(
)
&
slot
)
)
;
assert
(
!
slot
)
;
}
return
iterator_at
(
res
.
first
)
;
}
template
<
class
K
=
key_type
>
size_type
erase
(
const
key_arg
<
K
>
&
key
)
{
auto
it
=
find
(
key
)
;
if
(
it
=
=
end
(
)
)
return
0
;
erase
(
it
)
;
return
1
;
}
void
erase
(
const_iterator
cit
)
{
erase
(
cit
.
inner_
)
;
}
void
erase
(
iterator
it
)
{
AssertIsFull
(
it
.
ctrl_
it
.
generation
(
)
it
.
generation_ptr
(
)
"
erase
(
)
"
)
;
PolicyTraits
:
:
destroy
(
&
alloc_ref
(
)
it
.
slot_
)
;
erase_meta_only
(
it
)
;
}
iterator
erase
(
const_iterator
first
const_iterator
last
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
if
(
empty
(
)
)
return
end
(
)
;
if
(
first
=
=
begin
(
)
&
&
last
=
=
end
(
)
)
{
destroy_slots
(
)
;
ClearBackingArray
(
common
(
)
GetPolicyFunctions
(
)
true
)
;
common
(
)
.
set_reserved_growth
(
common
(
)
.
reservation_size
(
)
)
;
return
end
(
)
;
}
while
(
first
!
=
last
)
{
erase
(
first
+
+
)
;
}
return
last
.
inner_
;
}
template
<
typename
H
typename
E
>
void
merge
(
raw_hash_set
<
Policy
H
E
Alloc
>
&
src
)
{
assert
(
this
!
=
&
src
)
;
for
(
auto
it
=
src
.
begin
(
)
e
=
src
.
end
(
)
;
it
!
=
e
;
)
{
auto
next
=
std
:
:
next
(
it
)
;
if
(
PolicyTraits
:
:
apply
(
InsertSlot
<
false
>
{
*
this
std
:
:
move
(
*
it
.
slot_
)
}
PolicyTraits
:
:
element
(
it
.
slot_
)
)
.
second
)
{
src
.
erase_meta_only
(
it
)
;
}
it
=
next
;
}
}
template
<
typename
H
typename
E
>
void
merge
(
raw_hash_set
<
Policy
H
E
Alloc
>
&
&
src
)
{
merge
(
src
)
;
}
node_type
extract
(
const_iterator
position
)
{
AssertIsFull
(
position
.
inner_
.
ctrl_
position
.
inner_
.
generation
(
)
position
.
inner_
.
generation_ptr
(
)
"
extract
(
)
"
)
;
auto
node
=
CommonAccess
:
:
Transfer
<
node_type
>
(
alloc_ref
(
)
position
.
inner_
.
slot_
)
;
erase_meta_only
(
position
)
;
return
node
;
}
template
<
class
K
=
key_type
typename
std
:
:
enable_if
<
!
std
:
:
is_same
<
K
iterator
>
:
:
value
int
>
:
:
type
=
0
>
node_type
extract
(
const
key_arg
<
K
>
&
key
)
{
auto
it
=
find
(
key
)
;
return
it
=
=
end
(
)
?
node_type
(
)
:
extract
(
const_iterator
{
it
}
)
;
}
void
swap
(
raw_hash_set
&
that
)
noexcept
(
IsNoThrowSwappable
<
hasher
>
(
)
&
&
IsNoThrowSwappable
<
key_equal
>
(
)
&
&
IsNoThrowSwappable
<
allocator_type
>
(
typename
AllocTraits
:
:
propagate_on_container_swap
{
}
)
)
{
using
std
:
:
swap
;
swap
(
common
(
)
that
.
common
(
)
)
;
swap
(
hash_ref
(
)
that
.
hash_ref
(
)
)
;
swap
(
eq_ref
(
)
that
.
eq_ref
(
)
)
;
SwapAlloc
(
alloc_ref
(
)
that
.
alloc_ref
(
)
typename
AllocTraits
:
:
propagate_on_container_swap
{
}
)
;
}
void
rehash
(
size_t
n
)
{
if
(
n
=
=
0
&
&
capacity
(
)
=
=
0
)
return
;
if
(
n
=
=
0
&
&
size
(
)
=
=
0
)
{
ClearBackingArray
(
common
(
)
GetPolicyFunctions
(
)
false
)
;
return
;
}
auto
m
=
NormalizeCapacity
(
n
|
GrowthToLowerboundCapacity
(
size
(
)
)
)
;
if
(
n
=
=
0
|
|
m
>
capacity
(
)
)
{
resize
(
m
)
;
infoz
(
)
.
RecordReservation
(
n
)
;
}
}
void
reserve
(
size_t
n
)
{
if
(
n
>
size
(
)
+
growth_left
(
)
)
{
size_t
m
=
GrowthToLowerboundCapacity
(
n
)
;
resize
(
NormalizeCapacity
(
m
)
)
;
infoz
(
)
.
RecordReservation
(
n
)
;
}
common
(
)
.
reset_reserved_growth
(
n
)
;
common
(
)
.
set_reservation_size
(
n
)
;
}
template
<
class
K
=
key_type
>
size_t
count
(
const
key_arg
<
K
>
&
key
)
const
{
return
find
(
key
)
=
=
end
(
)
?
0
:
1
;
}
template
<
class
K
=
key_type
>
void
prefetch
(
const
key_arg
<
K
>
&
key
)
const
{
(
void
)
key
;
#
ifdef
ABSL_HAVE_PREFETCH
prefetch_heap_block
(
)
;
auto
seq
=
probe
(
common
(
)
hash_ref
(
)
(
key
)
)
;
PrefetchToLocalCache
(
control
(
)
+
seq
.
offset
(
)
)
;
PrefetchToLocalCache
(
slot_array
(
)
+
seq
.
offset
(
)
)
;
#
endif
}
template
<
class
K
=
key_type
>
iterator
find
(
const
key_arg
<
K
>
&
key
size_t
hash
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
seq
=
probe
(
common
(
)
hash
)
;
slot_type
*
slot_ptr
=
slot_array
(
)
;
const
ctrl_t
*
ctrl
=
control
(
)
;
while
(
true
)
{
Group
g
{
ctrl
+
seq
.
offset
(
)
}
;
for
(
uint32_t
i
:
g
.
Match
(
H2
(
hash
)
)
)
{
if
(
ABSL_PREDICT_TRUE
(
PolicyTraits
:
:
apply
(
EqualElement
<
K
>
{
key
eq_ref
(
)
}
PolicyTraits
:
:
element
(
slot_ptr
+
seq
.
offset
(
i
)
)
)
)
)
return
iterator_at
(
seq
.
offset
(
i
)
)
;
}
if
(
ABSL_PREDICT_TRUE
(
g
.
MaskEmpty
(
)
)
)
return
end
(
)
;
seq
.
next
(
)
;
assert
(
seq
.
index
(
)
<
=
capacity
(
)
&
&
"
full
table
!
"
)
;
}
}
template
<
class
K
=
key_type
>
iterator
find
(
const
key_arg
<
K
>
&
key
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
prefetch_heap_block
(
)
;
return
find
(
key
hash_ref
(
)
(
key
)
)
;
}
template
<
class
K
=
key_type
>
const_iterator
find
(
const
key_arg
<
K
>
&
key
size_t
hash
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
const_cast
<
raw_hash_set
*
>
(
this
)
-
>
find
(
key
hash
)
;
}
template
<
class
K
=
key_type
>
const_iterator
find
(
const
key_arg
<
K
>
&
key
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
prefetch_heap_block
(
)
;
return
find
(
key
hash_ref
(
)
(
key
)
)
;
}
template
<
class
K
=
key_type
>
bool
contains
(
const
key_arg
<
K
>
&
key
)
const
{
return
find
(
key
)
!
=
end
(
)
;
}
template
<
class
K
=
key_type
>
std
:
:
pair
<
iterator
iterator
>
equal_range
(
const
key_arg
<
K
>
&
key
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
it
=
find
(
key
)
;
if
(
it
!
=
end
(
)
)
return
{
it
std
:
:
next
(
it
)
}
;
return
{
it
it
}
;
}
template
<
class
K
=
key_type
>
std
:
:
pair
<
const_iterator
const_iterator
>
equal_range
(
const
key_arg
<
K
>
&
key
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
auto
it
=
find
(
key
)
;
if
(
it
!
=
end
(
)
)
return
{
it
std
:
:
next
(
it
)
}
;
return
{
it
it
}
;
}
size_t
bucket_count
(
)
const
{
return
capacity
(
)
;
}
float
load_factor
(
)
const
{
return
capacity
(
)
?
static_cast
<
double
>
(
size
(
)
)
/
capacity
(
)
:
0
.
0
;
}
float
max_load_factor
(
)
const
{
return
1
.
0f
;
}
void
max_load_factor
(
float
)
{
}
hasher
hash_function
(
)
const
{
return
hash_ref
(
)
;
}
key_equal
key_eq
(
)
const
{
return
eq_ref
(
)
;
}
allocator_type
get_allocator
(
)
const
{
return
alloc_ref
(
)
;
}
friend
bool
operator
=
=
(
const
raw_hash_set
&
a
const
raw_hash_set
&
b
)
{
if
(
a
.
size
(
)
!
=
b
.
size
(
)
)
return
false
;
const
raw_hash_set
*
outer
=
&
a
;
const
raw_hash_set
*
inner
=
&
b
;
if
(
outer
-
>
capacity
(
)
>
inner
-
>
capacity
(
)
)
std
:
:
swap
(
outer
inner
)
;
for
(
const
value_type
&
elem
:
*
outer
)
{
auto
it
=
PolicyTraits
:
:
apply
(
FindElement
{
*
inner
}
elem
)
;
if
(
it
=
=
inner
-
>
end
(
)
|
|
!
(
*
it
=
=
elem
)
)
return
false
;
}
return
true
;
}
friend
bool
operator
!
=
(
const
raw_hash_set
&
a
const
raw_hash_set
&
b
)
{
return
!
(
a
=
=
b
)
;
}
template
<
typename
H
>
friend
typename
std
:
:
enable_if
<
H
:
:
template
is_hashable
<
value_type
>
:
:
value
H
>
:
:
type
AbslHashValue
(
H
h
const
raw_hash_set
&
s
)
{
return
H
:
:
combine
(
H
:
:
combine_unordered
(
std
:
:
move
(
h
)
s
.
begin
(
)
s
.
end
(
)
)
s
.
size
(
)
)
;
}
friend
void
swap
(
raw_hash_set
&
a
raw_hash_set
&
b
)
noexcept
(
noexcept
(
a
.
swap
(
b
)
)
)
{
a
.
swap
(
b
)
;
}
private
:
template
<
class
Container
typename
Enabler
>
friend
struct
absl
:
:
container_internal
:
:
hashtable_debug_internal
:
:
HashtableDebugAccess
;
struct
FindElement
{
template
<
class
K
class
.
.
.
Args
>
const_iterator
operator
(
)
(
const
K
&
key
Args
&
&
.
.
.
)
const
{
return
s
.
find
(
key
)
;
}
const
raw_hash_set
&
s
;
}
;
struct
HashElement
{
template
<
class
K
class
.
.
.
Args
>
size_t
operator
(
)
(
const
K
&
key
Args
&
&
.
.
.
)
const
{
return
h
(
key
)
;
}
const
hasher
&
h
;
}
;
template
<
class
K1
>
struct
EqualElement
{
template
<
class
K2
class
.
.
.
Args
>
bool
operator
(
)
(
const
K2
&
lhs
Args
&
&
.
.
.
)
const
{
return
eq
(
lhs
rhs
)
;
}
const
K1
&
rhs
;
const
key_equal
&
eq
;
}
;
struct
EmplaceDecomposable
{
template
<
class
K
class
.
.
.
Args
>
std
:
:
pair
<
iterator
bool
>
operator
(
)
(
const
K
&
key
Args
&
&
.
.
.
args
)
const
{
auto
res
=
s
.
find_or_prepare_insert
(
key
)
;
if
(
res
.
second
)
{
s
.
emplace_at
(
res
.
first
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
return
{
s
.
iterator_at
(
res
.
first
)
res
.
second
}
;
}
raw_hash_set
&
s
;
}
;
template
<
bool
do_destroy
>
struct
InsertSlot
{
template
<
class
K
class
.
.
.
Args
>
std
:
:
pair
<
iterator
bool
>
operator
(
)
(
const
K
&
key
Args
&
&
.
.
.
)
&
&
{
auto
res
=
s
.
find_or_prepare_insert
(
key
)
;
if
(
res
.
second
)
{
PolicyTraits
:
:
transfer
(
&
s
.
alloc_ref
(
)
s
.
slot_array
(
)
+
res
.
first
&
slot
)
;
}
else
if
(
do_destroy
)
{
PolicyTraits
:
:
destroy
(
&
s
.
alloc_ref
(
)
&
slot
)
;
}
return
{
s
.
iterator_at
(
res
.
first
)
res
.
second
}
;
}
raw_hash_set
&
s
;
slot_type
&
&
slot
;
}
;
inline
void
destroy_slots
(
)
{
const
size_t
cap
=
capacity
(
)
;
const
ctrl_t
*
ctrl
=
control
(
)
;
slot_type
*
slot
=
slot_array
(
)
;
for
(
size_t
i
=
0
;
i
!
=
cap
;
+
+
i
)
{
if
(
IsFull
(
ctrl
[
i
]
)
)
{
PolicyTraits
:
:
destroy
(
&
alloc_ref
(
)
slot
+
i
)
;
}
}
}
void
erase_meta_only
(
const_iterator
it
)
{
EraseMetaOnly
(
common
(
)
it
.
inner_
.
ctrl_
sizeof
(
slot_type
)
)
;
}
inline
void
initialize_slots
(
)
{
using
CharAlloc
=
typename
absl
:
:
allocator_traits
<
Alloc
>
:
:
template
rebind_alloc
<
char
>
;
InitializeSlots
<
CharAlloc
sizeof
(
slot_type
)
alignof
(
slot_type
)
>
(
common
(
)
CharAlloc
(
alloc_ref
(
)
)
)
;
}
ABSL_ATTRIBUTE_NOINLINE
void
resize
(
size_t
new_capacity
)
{
assert
(
IsValidCapacity
(
new_capacity
)
)
;
auto
*
old_ctrl
=
control
(
)
;
auto
*
old_slots
=
slot_array
(
)
;
const
bool
had_infoz
=
common
(
)
.
has_infoz
(
)
;
const
size_t
old_capacity
=
common
(
)
.
capacity
(
)
;
common
(
)
.
set_capacity
(
new_capacity
)
;
initialize_slots
(
)
;
auto
*
new_slots
=
slot_array
(
)
;
size_t
total_probe_length
=
0
;
for
(
size_t
i
=
0
;
i
!
=
old_capacity
;
+
+
i
)
{
if
(
IsFull
(
old_ctrl
[
i
]
)
)
{
size_t
hash
=
PolicyTraits
:
:
apply
(
HashElement
{
hash_ref
(
)
}
PolicyTraits
:
:
element
(
old_slots
+
i
)
)
;
auto
target
=
find_first_non_full
(
common
(
)
hash
)
;
size_t
new_i
=
target
.
offset
;
total_probe_length
+
=
target
.
probe_length
;
SetCtrl
(
common
(
)
new_i
H2
(
hash
)
sizeof
(
slot_type
)
)
;
PolicyTraits
:
:
transfer
(
&
alloc_ref
(
)
new_slots
+
new_i
old_slots
+
i
)
;
}
}
if
(
old_capacity
)
{
SanitizerUnpoisonMemoryRegion
(
old_slots
sizeof
(
slot_type
)
*
old_capacity
)
;
Deallocate
<
BackingArrayAlignment
(
alignof
(
slot_type
)
)
>
(
&
alloc_ref
(
)
old_ctrl
-
ControlOffset
(
had_infoz
)
AllocSize
(
old_capacity
sizeof
(
slot_type
)
alignof
(
slot_type
)
had_infoz
)
)
;
}
infoz
(
)
.
RecordRehash
(
total_probe_length
)
;
}
inline
void
drop_deletes_without_resize
(
)
{
alignas
(
slot_type
)
unsigned
char
tmp
[
sizeof
(
slot_type
)
]
;
DropDeletesWithoutResize
(
common
(
)
GetPolicyFunctions
(
)
tmp
)
;
}
void
rehash_and_grow_if_necessary
(
)
{
const
size_t
cap
=
capacity
(
)
;
if
(
cap
>
Group
:
:
kWidth
&
&
size
(
)
*
uint64_t
{
32
}
<
=
cap
*
uint64_t
{
25
}
)
{
drop_deletes_without_resize
(
)
;
}
else
{
resize
(
NextCapacity
(
cap
)
)
;
}
}
raw_hash_set
&
move_assign
(
raw_hash_set
&
&
that
std
:
:
true_type
)
{
raw_hash_set
tmp
(
std
:
:
move
(
that
)
)
;
swap
(
tmp
)
;
return
*
this
;
}
raw_hash_set
&
move_assign
(
raw_hash_set
&
&
that
std
:
:
false_type
)
{
raw_hash_set
tmp
(
std
:
:
move
(
that
)
alloc_ref
(
)
)
;
swap
(
tmp
)
;
return
*
this
;
}
protected
:
template
<
class
K
>
std
:
:
pair
<
size_t
bool
>
find_or_prepare_insert
(
const
K
&
key
)
{
prefetch_heap_block
(
)
;
auto
hash
=
hash_ref
(
)
(
key
)
;
auto
seq
=
probe
(
common
(
)
hash
)
;
const
ctrl_t
*
ctrl
=
control
(
)
;
while
(
true
)
{
Group
g
{
ctrl
+
seq
.
offset
(
)
}
;
for
(
uint32_t
i
:
g
.
Match
(
H2
(
hash
)
)
)
{
if
(
ABSL_PREDICT_TRUE
(
PolicyTraits
:
:
apply
(
EqualElement
<
K
>
{
key
eq_ref
(
)
}
PolicyTraits
:
:
element
(
slot_array
(
)
+
seq
.
offset
(
i
)
)
)
)
)
return
{
seq
.
offset
(
i
)
false
}
;
}
if
(
ABSL_PREDICT_TRUE
(
g
.
MaskEmpty
(
)
)
)
break
;
seq
.
next
(
)
;
assert
(
seq
.
index
(
)
<
=
capacity
(
)
&
&
"
full
table
!
"
)
;
}
return
{
prepare_insert
(
hash
)
true
}
;
}
size_t
prepare_insert
(
size_t
hash
)
ABSL_ATTRIBUTE_NOINLINE
{
const
bool
rehash_for_bug_detection
=
common
(
)
.
should_rehash_for_bug_detection_on_insert
(
)
;
if
(
rehash_for_bug_detection
)
{
const
size_t
cap
=
capacity
(
)
;
resize
(
growth_left
(
)
>
0
?
cap
:
NextCapacity
(
cap
)
)
;
}
auto
target
=
find_first_non_full
(
common
(
)
hash
)
;
if
(
!
rehash_for_bug_detection
&
&
ABSL_PREDICT_FALSE
(
growth_left
(
)
=
=
0
&
&
!
IsDeleted
(
control
(
)
[
target
.
offset
]
)
)
)
{
rehash_and_grow_if_necessary
(
)
;
target
=
find_first_non_full
(
common
(
)
hash
)
;
}
common
(
)
.
increment_size
(
)
;
set_growth_left
(
growth_left
(
)
-
IsEmpty
(
control
(
)
[
target
.
offset
]
)
)
;
SetCtrl
(
common
(
)
target
.
offset
H2
(
hash
)
sizeof
(
slot_type
)
)
;
common
(
)
.
maybe_increment_generation_on_insert
(
)
;
infoz
(
)
.
RecordInsert
(
hash
target
.
probe_length
)
;
return
target
.
offset
;
}
template
<
class
.
.
.
Args
>
void
emplace_at
(
size_t
i
Args
&
&
.
.
.
args
)
{
PolicyTraits
:
:
construct
(
&
alloc_ref
(
)
slot_array
(
)
+
i
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
assert
(
PolicyTraits
:
:
apply
(
FindElement
{
*
this
}
*
iterator_at
(
i
)
)
=
=
iterator_at
(
i
)
&
&
"
constructed
value
does
not
match
the
lookup
key
"
)
;
}
iterator
iterator_at
(
size_t
i
)
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
{
control
(
)
+
i
slot_array
(
)
+
i
common
(
)
.
generation_ptr
(
)
}
;
}
const_iterator
iterator_at
(
size_t
i
)
const
ABSL_ATTRIBUTE_LIFETIME_BOUND
{
return
{
control
(
)
+
i
slot_array
(
)
+
i
common
(
)
.
generation_ptr
(
)
}
;
}
private
:
friend
struct
RawHashSetTestOnlyAccess
;
size_t
growth_left
(
)
const
{
return
common
(
)
.
growth_left
(
)
;
}
void
set_growth_left
(
size_t
gl
)
{
return
common
(
)
.
set_growth_left
(
gl
)
;
}
void
prefetch_heap_block
(
)
const
{
#
if
ABSL_HAVE_BUILTIN
(
__builtin_prefetch
)
|
|
defined
(
__GNUC__
)
__builtin_prefetch
(
control
(
)
0
1
)
;
#
endif
}
CommonFields
&
common
(
)
{
return
settings_
.
template
get
<
0
>
(
)
;
}
const
CommonFields
&
common
(
)
const
{
return
settings_
.
template
get
<
0
>
(
)
;
}
ctrl_t
*
control
(
)
const
{
return
common
(
)
.
control
(
)
;
}
slot_type
*
slot_array
(
)
const
{
return
static_cast
<
slot_type
*
>
(
common
(
)
.
slot_array
(
)
)
;
}
HashtablezInfoHandle
infoz
(
)
{
return
common
(
)
.
infoz
(
)
;
}
hasher
&
hash_ref
(
)
{
return
settings_
.
template
get
<
1
>
(
)
;
}
const
hasher
&
hash_ref
(
)
const
{
return
settings_
.
template
get
<
1
>
(
)
;
}
key_equal
&
eq_ref
(
)
{
return
settings_
.
template
get
<
2
>
(
)
;
}
const
key_equal
&
eq_ref
(
)
const
{
return
settings_
.
template
get
<
2
>
(
)
;
}
allocator_type
&
alloc_ref
(
)
{
return
settings_
.
template
get
<
3
>
(
)
;
}
const
allocator_type
&
alloc_ref
(
)
const
{
return
settings_
.
template
get
<
3
>
(
)
;
}
static
size_t
hash_slot_fn
(
void
*
set
void
*
slot
)
{
auto
*
h
=
static_cast
<
raw_hash_set
*
>
(
set
)
;
return
PolicyTraits
:
:
apply
(
HashElement
{
h
-
>
hash_ref
(
)
}
PolicyTraits
:
:
element
(
static_cast
<
slot_type
*
>
(
slot
)
)
)
;
}
static
void
transfer_slot_fn
(
void
*
set
void
*
dst
void
*
src
)
{
auto
*
h
=
static_cast
<
raw_hash_set
*
>
(
set
)
;
PolicyTraits
:
:
transfer
(
&
h
-
>
alloc_ref
(
)
static_cast
<
slot_type
*
>
(
dst
)
static_cast
<
slot_type
*
>
(
src
)
)
;
}
static
void
dealloc_fn
(
CommonFields
&
common
const
PolicyFunctions
&
)
{
auto
*
set
=
reinterpret_cast
<
raw_hash_set
*
>
(
&
common
)
;
SanitizerUnpoisonMemoryRegion
(
common
.
slot_array
(
)
sizeof
(
slot_type
)
*
common
.
capacity
(
)
)
;
common
.
infoz
(
)
.
Unregister
(
)
;
Deallocate
<
BackingArrayAlignment
(
alignof
(
slot_type
)
)
>
(
&
set
-
>
alloc_ref
(
)
common
.
backing_array_start
(
)
common
.
alloc_size
(
sizeof
(
slot_type
)
alignof
(
slot_type
)
)
)
;
}
static
const
PolicyFunctions
&
GetPolicyFunctions
(
)
{
static
constexpr
PolicyFunctions
value
=
{
sizeof
(
slot_type
)
&
raw_hash_set
:
:
hash_slot_fn
PolicyTraits
:
:
transfer_uses_memcpy
(
)
?
TransferRelocatable
<
sizeof
(
slot_type
)
>
:
&
raw_hash_set
:
:
transfer_slot_fn
(
std
:
:
is_same
<
SlotAlloc
std
:
:
allocator
<
slot_type
>
>
:
:
value
?
&
DeallocateStandard
<
alignof
(
slot_type
)
>
:
&
raw_hash_set
:
:
dealloc_fn
)
}
;
return
value
;
}
absl
:
:
container_internal
:
:
CompressedTuple
<
CommonFields
hasher
key_equal
allocator_type
>
settings_
{
CommonFields
{
}
hasher
{
}
key_equal
{
}
allocator_type
{
}
}
;
}
;
template
<
typename
P
typename
H
typename
E
typename
A
typename
Predicate
>
typename
raw_hash_set
<
P
H
E
A
>
:
:
size_type
EraseIf
(
Predicate
&
pred
raw_hash_set
<
P
H
E
A
>
*
c
)
{
const
auto
initial_size
=
c
-
>
size
(
)
;
for
(
auto
it
=
c
-
>
begin
(
)
last
=
c
-
>
end
(
)
;
it
!
=
last
;
)
{
if
(
pred
(
*
it
)
)
{
c
-
>
erase
(
it
+
+
)
;
}
else
{
+
+
it
;
}
}
return
initial_size
-
c
-
>
size
(
)
;
}
namespace
hashtable_debug_internal
{
template
<
typename
Set
>
struct
HashtableDebugAccess
<
Set
absl
:
:
void_t
<
typename
Set
:
:
raw_hash_set
>
>
{
using
Traits
=
typename
Set
:
:
PolicyTraits
;
using
Slot
=
typename
Traits
:
:
slot_type
;
static
size_t
GetNumProbes
(
const
Set
&
set
const
typename
Set
:
:
key_type
&
key
)
{
size_t
num_probes
=
0
;
size_t
hash
=
set
.
hash_ref
(
)
(
key
)
;
auto
seq
=
probe
(
set
.
common
(
)
hash
)
;
const
ctrl_t
*
ctrl
=
set
.
control
(
)
;
while
(
true
)
{
container_internal
:
:
Group
g
{
ctrl
+
seq
.
offset
(
)
}
;
for
(
uint32_t
i
:
g
.
Match
(
container_internal
:
:
H2
(
hash
)
)
)
{
if
(
Traits
:
:
apply
(
typename
Set
:
:
template
EqualElement
<
typename
Set
:
:
key_type
>
{
key
set
.
eq_ref
(
)
}
Traits
:
:
element
(
set
.
slot_array
(
)
+
seq
.
offset
(
i
)
)
)
)
return
num_probes
;
+
+
num_probes
;
}
if
(
g
.
MaskEmpty
(
)
)
return
num_probes
;
seq
.
next
(
)
;
+
+
num_probes
;
}
}
static
size_t
AllocatedByteSize
(
const
Set
&
c
)
{
size_t
capacity
=
c
.
capacity
(
)
;
if
(
capacity
=
=
0
)
return
0
;
size_t
m
=
c
.
common
(
)
.
alloc_size
(
sizeof
(
Slot
)
alignof
(
Slot
)
)
;
size_t
per_slot
=
Traits
:
:
space_used
(
static_cast
<
const
Slot
*
>
(
nullptr
)
)
;
if
(
per_slot
!
=
~
size_t
{
}
)
{
m
+
=
per_slot
*
c
.
size
(
)
;
}
else
{
const
ctrl_t
*
ctrl
=
c
.
control
(
)
;
for
(
size_t
i
=
0
;
i
!
=
capacity
;
+
+
i
)
{
if
(
container_internal
:
:
IsFull
(
ctrl
[
i
]
)
)
{
m
+
=
Traits
:
:
space_used
(
c
.
slot_array
(
)
+
i
)
;
}
}
}
return
m
;
}
}
;
}
}
ABSL_NAMESPACE_END
}
#
undef
ABSL_SWISSTABLE_ENABLE_GENERATIONS
#
endif
