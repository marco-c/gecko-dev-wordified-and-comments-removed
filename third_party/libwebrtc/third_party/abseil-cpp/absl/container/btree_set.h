#
ifndef
ABSL_CONTAINER_BTREE_SET_H_
#
define
ABSL_CONTAINER_BTREE_SET_H_
#
include
"
absl
/
container
/
internal
/
btree
.
h
"
#
include
"
absl
/
container
/
internal
/
btree_container
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
container_internal
{
template
<
typename
Key
>
struct
set_slot_policy
;
template
<
typename
Key
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
IsMulti
>
struct
set_params
;
}
template
<
typename
Key
typename
Compare
=
std
:
:
less
<
Key
>
typename
Alloc
=
std
:
:
allocator
<
Key
>
>
class
btree_set
:
public
container_internal
:
:
btree_set_container
<
container_internal
:
:
btree
<
container_internal
:
:
set_params
<
Key
Compare
Alloc
256
false
>
>
>
{
using
Base
=
typename
btree_set
:
:
btree_set_container
;
public
:
btree_set
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
end
;
using
Base
:
:
cend
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
extract
;
using
Base
:
:
extract_and_get_next
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
lower_bound
;
using
Base
:
:
upper_bound
;
using
Base
:
:
get_allocator
;
using
Base
:
:
key_comp
;
using
Base
:
:
value_comp
;
}
;
template
<
typename
K
typename
C
typename
A
>
void
swap
(
btree_set
<
K
C
A
>
&
x
btree_set
<
K
C
A
>
&
y
)
{
return
x
.
swap
(
y
)
;
}
template
<
typename
K
typename
C
typename
A
typename
Pred
>
typename
btree_set
<
K
C
A
>
:
:
size_type
erase_if
(
btree_set
<
K
C
A
>
&
set
Pred
pred
)
{
return
container_internal
:
:
btree_access
:
:
erase_if
(
set
std
:
:
move
(
pred
)
)
;
}
template
<
typename
Key
typename
Compare
=
std
:
:
less
<
Key
>
typename
Alloc
=
std
:
:
allocator
<
Key
>
>
class
btree_multiset
:
public
container_internal
:
:
btree_multiset_container
<
container_internal
:
:
btree
<
container_internal
:
:
set_params
<
Key
Compare
Alloc
256
true
>
>
>
{
using
Base
=
typename
btree_multiset
:
:
btree_multiset_container
;
public
:
btree_multiset
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
end
;
using
Base
:
:
cend
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
extract
;
using
Base
:
:
extract_and_get_next
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
lower_bound
;
using
Base
:
:
upper_bound
;
using
Base
:
:
get_allocator
;
using
Base
:
:
key_comp
;
using
Base
:
:
value_comp
;
}
;
template
<
typename
K
typename
C
typename
A
>
void
swap
(
btree_multiset
<
K
C
A
>
&
x
btree_multiset
<
K
C
A
>
&
y
)
{
return
x
.
swap
(
y
)
;
}
template
<
typename
K
typename
C
typename
A
typename
Pred
>
typename
btree_multiset
<
K
C
A
>
:
:
size_type
erase_if
(
btree_multiset
<
K
C
A
>
&
set
Pred
pred
)
{
return
container_internal
:
:
btree_access
:
:
erase_if
(
set
std
:
:
move
(
pred
)
)
;
}
namespace
container_internal
{
template
<
typename
Key
>
struct
set_slot_policy
{
using
slot_type
=
Key
;
using
value_type
=
Key
;
using
mutable_value_type
=
Key
;
static
value_type
&
element
(
slot_type
*
slot
)
{
return
*
slot
;
}
static
const
value_type
&
element
(
const
slot_type
*
slot
)
{
return
*
slot
;
}
template
<
typename
Alloc
class
.
.
.
Args
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
Args
&
&
.
.
.
args
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
construct
(
*
alloc
slot
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
Alloc
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
slot_type
*
other
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
construct
(
*
alloc
slot
std
:
:
move
(
*
other
)
)
;
}
template
<
typename
Alloc
>
static
void
construct
(
Alloc
*
alloc
slot_type
*
slot
const
slot_type
*
other
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
construct
(
*
alloc
slot
*
other
)
;
}
template
<
typename
Alloc
>
static
void
destroy
(
Alloc
*
alloc
slot_type
*
slot
)
{
absl
:
:
allocator_traits
<
Alloc
>
:
:
destroy
(
*
alloc
slot
)
;
}
}
;
template
<
typename
Key
typename
Compare
typename
Alloc
int
TargetNodeSize
bool
IsMulti
>
struct
set_params
:
common_params
<
Key
Compare
Alloc
TargetNodeSize
IsMulti
false
set_slot_policy
<
Key
>
>
{
using
value_type
=
Key
;
using
slot_type
=
typename
set_params
:
:
common_params
:
:
slot_type
;
template
<
typename
V
>
static
const
V
&
key
(
const
V
&
value
)
{
return
value
;
}
static
const
Key
&
key
(
const
slot_type
*
slot
)
{
return
*
slot
;
}
static
const
Key
&
key
(
slot_type
*
slot
)
{
return
*
slot
;
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
