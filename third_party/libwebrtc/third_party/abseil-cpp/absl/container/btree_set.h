#
ifndef
ABSL_CONTAINER_BTREE_SET_H_
#
define
ABSL_CONTAINER_BTREE_SET_H_
#
include
"
absl
/
container
/
internal
/
btree
.
h
"
#
include
"
absl
/
container
/
internal
/
btree_container
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
Key
typename
Compare
=
std
:
:
less
<
Key
>
typename
Alloc
=
std
:
:
allocator
<
Key
>
>
class
btree_set
:
public
container_internal
:
:
btree_set_container
<
container_internal
:
:
btree
<
container_internal
:
:
set_params
<
Key
Compare
Alloc
256
false
>
>
>
{
using
Base
=
typename
btree_set
:
:
btree_set_container
;
public
:
btree_set
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
end
;
using
Base
:
:
cend
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
extract
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
get_allocator
;
using
Base
:
:
key_comp
;
using
Base
:
:
value_comp
;
}
;
template
<
typename
K
typename
C
typename
A
>
void
swap
(
btree_set
<
K
C
A
>
&
x
btree_set
<
K
C
A
>
&
y
)
{
return
x
.
swap
(
y
)
;
}
template
<
typename
K
typename
C
typename
A
typename
Pred
>
void
erase_if
(
btree_set
<
K
C
A
>
&
set
Pred
pred
)
{
for
(
auto
it
=
set
.
begin
(
)
;
it
!
=
set
.
end
(
)
;
)
{
if
(
pred
(
*
it
)
)
{
it
=
set
.
erase
(
it
)
;
}
else
{
+
+
it
;
}
}
}
template
<
typename
Key
typename
Compare
=
std
:
:
less
<
Key
>
typename
Alloc
=
std
:
:
allocator
<
Key
>
>
class
btree_multiset
:
public
container_internal
:
:
btree_multiset_container
<
container_internal
:
:
btree
<
container_internal
:
:
set_params
<
Key
Compare
Alloc
256
true
>
>
>
{
using
Base
=
typename
btree_multiset
:
:
btree_multiset_container
;
public
:
btree_multiset
(
)
{
}
using
Base
:
:
Base
;
using
Base
:
:
begin
;
using
Base
:
:
cbegin
;
using
Base
:
:
end
;
using
Base
:
:
cend
;
using
Base
:
:
empty
;
using
Base
:
:
max_size
;
using
Base
:
:
size
;
using
Base
:
:
clear
;
using
Base
:
:
erase
;
using
Base
:
:
insert
;
using
Base
:
:
emplace
;
using
Base
:
:
emplace_hint
;
using
Base
:
:
extract
;
using
Base
:
:
merge
;
using
Base
:
:
swap
;
using
Base
:
:
contains
;
using
Base
:
:
count
;
using
Base
:
:
equal_range
;
using
Base
:
:
find
;
using
Base
:
:
get_allocator
;
using
Base
:
:
key_comp
;
using
Base
:
:
value_comp
;
}
;
template
<
typename
K
typename
C
typename
A
>
void
swap
(
btree_multiset
<
K
C
A
>
&
x
btree_multiset
<
K
C
A
>
&
y
)
{
return
x
.
swap
(
y
)
;
}
template
<
typename
K
typename
C
typename
A
typename
Pred
>
void
erase_if
(
btree_multiset
<
K
C
A
>
&
set
Pred
pred
)
{
for
(
auto
it
=
set
.
begin
(
)
;
it
!
=
set
.
end
(
)
;
)
{
if
(
pred
(
*
it
)
)
{
it
=
set
.
erase
(
it
)
;
}
else
{
+
+
it
;
}
}
}
ABSL_NAMESPACE_END
}
#
endif
