#
ifndef
ABSL_RANDOM_INTERNAL_UNIFORM_HELPER_H_
#
define
ABSL_RANDOM_INTERNAL_UNIFORM_HELPER_H_
#
include
<
cmath
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
internal
/
traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
IntType
>
class
uniform_int_distribution
;
template
<
typename
RealType
>
class
uniform_real_distribution
;
namespace
random_internal
{
template
<
typename
T
>
struct
TagTypeCompare
{
}
;
template
<
typename
T
>
constexpr
bool
operator
=
=
(
TagTypeCompare
<
T
>
TagTypeCompare
<
T
>
)
{
return
true
;
}
template
<
typename
T
>
constexpr
bool
operator
!
=
(
TagTypeCompare
<
T
>
TagTypeCompare
<
T
>
)
{
return
false
;
}
}
struct
IntervalClosedClosedTag
:
public
random_internal
:
:
TagTypeCompare
<
IntervalClosedClosedTag
>
{
}
;
struct
IntervalClosedOpenTag
:
public
random_internal
:
:
TagTypeCompare
<
IntervalClosedOpenTag
>
{
}
;
struct
IntervalOpenClosedTag
:
public
random_internal
:
:
TagTypeCompare
<
IntervalOpenClosedTag
>
{
}
;
struct
IntervalOpenOpenTag
:
public
random_internal
:
:
TagTypeCompare
<
IntervalOpenOpenTag
>
{
}
;
namespace
random_internal
{
template
<
typename
A
typename
B
>
using
uniform_inferred_return_t
=
absl
:
:
enable_if_t
<
absl
:
:
disjunction
<
is_widening_convertible
<
A
B
>
is_widening_convertible
<
B
A
>
>
:
:
value
typename
std
:
:
conditional
<
is_widening_convertible
<
A
B
>
:
:
value
B
A
>
:
:
type
>
;
template
<
typename
IntType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
IsIntegral
<
IntType
>
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalOpenClosedTag
>
std
:
:
is_same
<
Tag
IntervalOpenOpenTag
>
>
>
:
:
value
IntType
>
uniform_lower_bound
(
Tag
IntType
a
IntType
)
{
return
a
<
(
std
:
:
numeric_limits
<
IntType
>
:
:
max
)
(
)
?
(
a
+
1
)
:
a
;
}
template
<
typename
FloatType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_floating_point
<
FloatType
>
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalOpenClosedTag
>
std
:
:
is_same
<
Tag
IntervalOpenOpenTag
>
>
>
:
:
value
FloatType
>
uniform_lower_bound
(
Tag
FloatType
a
FloatType
b
)
{
return
std
:
:
nextafter
(
a
b
)
;
}
template
<
typename
NumType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalClosedClosedTag
>
std
:
:
is_same
<
Tag
IntervalClosedOpenTag
>
>
:
:
value
NumType
>
uniform_lower_bound
(
Tag
NumType
a
NumType
)
{
return
a
;
}
template
<
typename
IntType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
IsIntegral
<
IntType
>
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalClosedOpenTag
>
std
:
:
is_same
<
Tag
IntervalOpenOpenTag
>
>
>
:
:
value
IntType
>
uniform_upper_bound
(
Tag
IntType
IntType
b
)
{
return
b
>
(
std
:
:
numeric_limits
<
IntType
>
:
:
min
)
(
)
?
(
b
-
1
)
:
b
;
}
template
<
typename
FloatType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_floating_point
<
FloatType
>
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalClosedOpenTag
>
std
:
:
is_same
<
Tag
IntervalOpenOpenTag
>
>
>
:
:
value
FloatType
>
uniform_upper_bound
(
Tag
FloatType
FloatType
b
)
{
return
b
;
}
template
<
typename
IntType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
IsIntegral
<
IntType
>
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalClosedClosedTag
>
std
:
:
is_same
<
Tag
IntervalOpenClosedTag
>
>
>
:
:
value
IntType
>
uniform_upper_bound
(
Tag
IntType
IntType
b
)
{
return
b
;
}
template
<
typename
FloatType
typename
Tag
>
typename
absl
:
:
enable_if_t
<
absl
:
:
conjunction
<
std
:
:
is_floating_point
<
FloatType
>
absl
:
:
disjunction
<
std
:
:
is_same
<
Tag
IntervalClosedClosedTag
>
std
:
:
is_same
<
Tag
IntervalOpenClosedTag
>
>
>
:
:
value
FloatType
>
uniform_upper_bound
(
Tag
FloatType
FloatType
b
)
{
return
std
:
:
nextafter
(
b
(
std
:
:
numeric_limits
<
FloatType
>
:
:
max
)
(
)
)
;
}
template
<
typename
FloatType
>
absl
:
:
enable_if_t
<
std
:
:
is_floating_point
<
FloatType
>
:
:
value
bool
>
is_uniform_range_valid
(
FloatType
a
FloatType
b
)
{
return
a
<
=
b
&
&
std
:
:
isfinite
(
b
-
a
)
;
}
template
<
typename
IntType
>
absl
:
:
enable_if_t
<
IsIntegral
<
IntType
>
:
:
value
bool
>
is_uniform_range_valid
(
IntType
a
IntType
b
)
{
return
a
<
=
b
;
}
template
<
typename
NumType
>
using
UniformDistribution
=
typename
std
:
:
conditional
<
IsIntegral
<
NumType
>
:
:
value
absl
:
:
uniform_int_distribution
<
NumType
>
absl
:
:
uniform_real_distribution
<
NumType
>
>
:
:
type
;
template
<
typename
NumType
>
struct
UniformDistributionWrapper
:
public
UniformDistribution
<
NumType
>
{
template
<
typename
TagType
>
explicit
UniformDistributionWrapper
(
TagType
NumType
lo
NumType
hi
)
:
UniformDistribution
<
NumType
>
(
uniform_lower_bound
<
NumType
>
(
TagType
{
}
lo
hi
)
uniform_upper_bound
<
NumType
>
(
TagType
{
}
lo
hi
)
)
{
}
explicit
UniformDistributionWrapper
(
NumType
lo
NumType
hi
)
:
UniformDistribution
<
NumType
>
(
uniform_lower_bound
<
NumType
>
(
IntervalClosedOpenTag
(
)
lo
hi
)
uniform_upper_bound
<
NumType
>
(
IntervalClosedOpenTag
(
)
lo
hi
)
)
{
}
explicit
UniformDistributionWrapper
(
)
:
UniformDistribution
<
NumType
>
(
std
:
:
numeric_limits
<
NumType
>
:
:
lowest
(
)
(
std
:
:
numeric_limits
<
NumType
>
:
:
max
)
(
)
)
{
}
}
;
}
ABSL_NAMESPACE_END
}
#
endif
