#
ifndef
ABSL_RANDOM_INTERNAL_SALTED_SEED_SEQ_H_
#
define
ABSL_RANDOM_INTERNAL_SALTED_SEED_SEQ_H_
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
container
/
inlined_vector
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
internal
/
seed_material
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
absl
/
types
/
span
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
template
<
typename
SSeq
>
class
SaltedSeedSeq
{
public
:
using
inner_sequence_type
=
SSeq
;
using
result_type
=
typename
SSeq
:
:
result_type
;
SaltedSeedSeq
(
)
:
seq_
(
absl
:
:
make_unique
<
SSeq
>
(
)
)
{
}
template
<
typename
Iterator
>
SaltedSeedSeq
(
Iterator
begin
Iterator
end
)
:
seq_
(
absl
:
:
make_unique
<
SSeq
>
(
begin
end
)
)
{
}
template
<
typename
T
>
SaltedSeedSeq
(
std
:
:
initializer_list
<
T
>
il
)
:
SaltedSeedSeq
(
il
.
begin
(
)
il
.
end
(
)
)
{
}
SaltedSeedSeq
(
const
SaltedSeedSeq
&
)
=
delete
;
SaltedSeedSeq
&
operator
=
(
const
SaltedSeedSeq
&
)
=
delete
;
SaltedSeedSeq
(
SaltedSeedSeq
&
&
)
=
default
;
SaltedSeedSeq
&
operator
=
(
SaltedSeedSeq
&
&
)
=
default
;
template
<
typename
RandomAccessIterator
>
void
generate
(
RandomAccessIterator
begin
RandomAccessIterator
end
)
{
using
tag
=
absl
:
:
conditional_t
<
(
std
:
:
is_pointer
<
RandomAccessIterator
>
:
:
value
&
&
std
:
:
is_same
<
absl
:
:
decay_t
<
decltype
(
*
begin
)
>
uint32_t
>
:
:
value
)
ContiguousAndUint32Tag
DefaultTag
>
;
if
(
begin
!
=
end
)
{
generate_impl
(
begin
end
tag
{
}
)
;
}
}
template
<
typename
OutIterator
>
void
param
(
OutIterator
out
)
const
{
seq_
-
>
param
(
out
)
;
}
size_t
size
(
)
const
{
return
seq_
-
>
size
(
)
;
}
private
:
struct
ContiguousAndUint32Tag
{
}
;
struct
DefaultTag
{
}
;
void
generate_impl
(
uint32_t
*
begin
uint32_t
*
end
ContiguousAndUint32Tag
)
{
generate_contiguous
(
absl
:
:
MakeSpan
(
begin
end
)
)
;
}
template
<
typename
RandomAccessIterator
>
void
generate_impl
(
RandomAccessIterator
begin
RandomAccessIterator
end
DefaultTag
)
{
return
generate_and_copy
(
std
:
:
distance
(
begin
end
)
begin
)
;
}
void
generate_contiguous
(
absl
:
:
Span
<
uint32_t
>
buffer
)
{
seq_
-
>
generate
(
buffer
.
begin
(
)
buffer
.
end
(
)
)
;
const
uint32_t
salt
=
absl
:
:
random_internal
:
:
GetSaltMaterial
(
)
.
value_or
(
0
)
;
MixIntoSeedMaterial
(
absl
:
:
MakeConstSpan
(
&
salt
1
)
buffer
)
;
}
template
<
typename
Iterator
>
void
generate_and_copy
(
size_t
n
Iterator
out
)
{
absl
:
:
InlinedVector
<
uint32_t
8
>
data
(
n
0
)
;
generate_contiguous
(
absl
:
:
MakeSpan
(
data
.
data
(
)
data
.
size
(
)
)
)
;
std
:
:
copy
(
data
.
begin
(
)
data
.
end
(
)
out
)
;
}
std
:
:
unique_ptr
<
SSeq
>
seq_
;
}
;
template
<
typename
T
typename
=
void
>
struct
is_salted_seed_seq
:
public
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
is_salted_seed_seq
<
T
typename
std
:
:
enable_if
<
std
:
:
is_same
<
T
SaltedSeedSeq
<
typename
T
:
:
inner_sequence_type
>
>
:
:
value
>
:
:
type
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
SSeq
typename
EnableIf
=
absl
:
:
enable_if_t
<
is_salted_seed_seq
<
SSeq
>
:
:
value
>
>
SSeq
MakeSaltedSeedSeq
(
SSeq
&
&
seq
)
{
return
SSeq
(
std
:
:
forward
<
SSeq
>
(
seq
)
)
;
}
template
<
typename
SSeq
typename
EnableIf
=
absl
:
:
enable_if_t
<
!
is_salted_seed_seq
<
SSeq
>
:
:
value
>
>
SaltedSeedSeq
<
typename
std
:
:
decay
<
SSeq
>
:
:
type
>
MakeSaltedSeedSeq
(
SSeq
&
&
seq
)
{
using
sseq_type
=
typename
std
:
:
decay
<
SSeq
>
:
:
type
;
using
result_type
=
typename
sseq_type
:
:
result_type
;
absl
:
:
InlinedVector
<
result_type
8
>
data
;
seq
.
param
(
std
:
:
back_inserter
(
data
)
)
;
return
SaltedSeedSeq
<
sseq_type
>
(
data
.
begin
(
)
data
.
end
(
)
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
