#
ifndef
ABSL_RANDOM_INTERNAL_RANDEN_H_
#
define
ABSL_RANDOM_INTERNAL_RANDEN_H_
#
include
<
cstddef
>
#
include
"
absl
/
random
/
internal
/
platform
.
h
"
#
include
"
absl
/
random
/
internal
/
randen_hwaes
.
h
"
#
include
"
absl
/
random
/
internal
/
randen_slow
.
h
"
#
include
"
absl
/
random
/
internal
/
randen_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
class
Randen
{
public
:
static
constexpr
size_t
kStateBytes
=
RandenTraits
:
:
kStateBytes
;
static
constexpr
size_t
kCapacityBytes
=
RandenTraits
:
:
kCapacityBytes
;
static
constexpr
size_t
kSeedBytes
=
RandenTraits
:
:
kSeedBytes
;
~
Randen
(
)
=
default
;
Randen
(
)
;
template
<
typename
T
size_t
N
>
void
Generate
(
T
(
&
state
)
[
N
]
)
const
{
static_assert
(
N
*
sizeof
(
T
)
=
=
kStateBytes
"
Randen
:
:
Generate
(
)
requires
kStateBytes
of
state
"
)
;
#
if
ABSL_RANDOM_INTERNAL_AES_DISPATCH
if
(
has_crypto_
)
{
RandenHwAes
:
:
Generate
(
keys_
state
)
;
}
else
{
RandenSlow
:
:
Generate
(
keys_
state
)
;
}
#
elif
ABSL_HAVE_ACCELERATED_AES
RandenHwAes
:
:
Generate
(
keys_
state
)
;
#
else
RandenSlow
:
:
Generate
(
keys_
state
)
;
#
endif
}
template
<
typename
S
size_t
M
typename
T
size_t
N
>
void
Absorb
(
const
S
(
&
seed
)
[
M
]
T
(
&
state
)
[
N
]
)
const
{
static_assert
(
M
*
sizeof
(
S
)
=
=
RandenTraits
:
:
kSeedBytes
"
Randen
:
:
Absorb
(
)
requires
kSeedBytes
of
seed
"
)
;
static_assert
(
N
*
sizeof
(
T
)
=
=
RandenTraits
:
:
kStateBytes
"
Randen
:
:
Absorb
(
)
requires
kStateBytes
of
state
"
)
;
#
if
ABSL_RANDOM_INTERNAL_AES_DISPATCH
if
(
has_crypto_
)
{
RandenHwAes
:
:
Absorb
(
seed
state
)
;
}
else
{
RandenSlow
:
:
Absorb
(
seed
state
)
;
}
#
elif
ABSL_HAVE_ACCELERATED_AES
RandenHwAes
:
:
Absorb
(
seed
state
)
;
#
else
RandenSlow
:
:
Absorb
(
seed
state
)
;
#
endif
}
private
:
const
void
*
keys_
;
#
if
ABSL_RANDOM_INTERNAL_AES_DISPATCH
bool
has_crypto_
;
#
endif
}
;
}
ABSL_NAMESPACE_END
}
#
endif
