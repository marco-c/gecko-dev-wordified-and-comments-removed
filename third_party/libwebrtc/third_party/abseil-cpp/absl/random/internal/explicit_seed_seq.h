#
ifndef
ABSL_RANDOM_INTERNAL_EXPLICIT_SEED_SEQ_H_
#
define
ABSL_RANDOM_INTERNAL_EXPLICIT_SEED_SEQ_H_
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
vector
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
endian
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
class
ExplicitSeedSeq
{
public
:
using
result_type
=
uint32_t
;
ExplicitSeedSeq
(
)
:
state_
(
)
{
}
ExplicitSeedSeq
(
const
ExplicitSeedSeq
&
other
)
=
default
;
ExplicitSeedSeq
&
operator
=
(
const
ExplicitSeedSeq
&
other
)
=
default
;
ExplicitSeedSeq
(
ExplicitSeedSeq
&
&
other
)
=
default
;
ExplicitSeedSeq
&
operator
=
(
ExplicitSeedSeq
&
&
other
)
=
default
;
template
<
typename
Iterator
>
ExplicitSeedSeq
(
Iterator
begin
Iterator
end
)
{
for
(
auto
it
=
begin
;
it
!
=
end
;
it
+
+
)
{
state_
.
push_back
(
*
it
&
0xffffffff
)
;
}
}
template
<
typename
T
>
ExplicitSeedSeq
(
std
:
:
initializer_list
<
T
>
il
)
:
ExplicitSeedSeq
(
il
.
begin
(
)
il
.
end
(
)
)
{
}
size_t
size
(
)
const
{
return
state_
.
size
(
)
;
}
template
<
typename
OutIterator
>
void
param
(
OutIterator
out
)
const
{
std
:
:
copy
(
std
:
:
begin
(
state_
)
std
:
:
end
(
state_
)
out
)
;
}
template
<
typename
OutIterator
>
void
generate
(
OutIterator
begin
OutIterator
end
)
{
for
(
size_t
index
=
0
;
begin
!
=
end
;
begin
+
+
)
{
*
begin
=
state_
.
empty
(
)
?
0
:
little_endian
:
:
FromHost32
(
state_
[
index
+
+
]
)
;
if
(
index
>
=
state_
.
size
(
)
)
{
index
=
0
;
}
}
}
protected
:
std
:
:
vector
<
uint32_t
>
state_
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
