#
include
"
absl
/
random
/
internal
/
nanobenchmark
.
h
"
#
include
"
absl
/
log
/
check
.
h
"
#
include
"
absl
/
log
/
log
.
h
"
#
include
"
absl
/
strings
/
numbers
.
h
"
#
include
"
absl
/
strings
/
str_format
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal_nanobenchmark
{
namespace
{
uint64_t
Div
(
const
void
*
FuncInput
in
)
{
const
int64_t
d1
=
0xFFFFFFFFFFll
/
int64_t
(
in
)
;
return
d1
;
}
template
<
size_t
N
>
void
MeasureDiv
(
const
FuncInput
(
&
inputs
)
[
N
]
)
{
Result
results
[
N
]
;
Params
params
;
params
.
max_evals
=
6
;
const
size_t
num_results
=
Measure
(
&
Div
nullptr
inputs
N
results
params
)
;
if
(
num_results
=
=
0
)
{
LOG
(
WARNING
)
<
<
"
WARNING
:
Measurement
failed
should
not
happen
when
using
"
"
PinThreadToCPU
unless
the
region
to
measure
takes
>
1
second
.
"
;
return
;
}
for
(
size_t
i
=
0
;
i
<
num_results
;
+
+
i
)
{
LOG
(
INFO
)
<
<
absl
:
:
StreamFormat
(
"
%
5u
:
%
6
.
2f
ticks
;
MAD
=
%
4
.
2f
%
%
\
n
"
results
[
i
]
.
input
results
[
i
]
.
ticks
results
[
i
]
.
variability
*
100
.
0
)
;
CHECK_NE
(
results
[
i
]
.
ticks
0
.
0f
)
<
<
"
Zero
duration
"
;
}
}
void
RunAll
(
const
int
argc
char
*
argv
[
]
)
{
int
cpu
=
-
1
;
if
(
argc
=
=
2
)
{
if
(
!
absl
:
:
SimpleAtoi
(
argv
[
1
]
&
cpu
)
)
{
LOG
(
FATAL
)
<
<
"
The
optional
argument
must
be
a
CPU
number
>
=
0
.
"
;
}
}
PinThreadToCPU
(
cpu
)
;
const
FuncInput
unpredictable
=
argc
!
=
999
;
static
const
FuncInput
inputs
[
]
=
{
unpredictable
*
10
unpredictable
*
100
}
;
MeasureDiv
(
inputs
)
;
}
}
}
ABSL_NAMESPACE_END
}
int
main
(
int
argc
char
*
argv
[
]
)
{
absl
:
:
random_internal_nanobenchmark
:
:
RunAll
(
argc
argv
)
;
return
0
;
}
