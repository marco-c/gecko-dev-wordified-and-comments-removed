#
include
"
absl
/
random
/
internal
/
explicit_seed_seq
.
h
"
#
include
<
iterator
>
#
include
<
random
>
#
include
<
utility
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
random
/
seed_sequences
.
h
"
namespace
{
using
:
:
absl
:
:
random_internal
:
:
ExplicitSeedSeq
;
template
<
typename
Sseq
>
bool
ConformsToInterface
(
)
{
{
Sseq
default_constructed_seq
;
}
{
uint32_t
init_array
[
]
=
{
1
3
5
7
9
}
;
Sseq
iterator_constructed_seq
(
init_array
&
init_array
[
5
]
)
;
}
{
Sseq
list_constructed_seq
=
{
1
3
5
7
9
11
13
}
;
}
{
uint32_t
init_array
[
]
=
{
1
2
3
4
5
}
;
Sseq
seq
(
init_array
&
init_array
[
ABSL_ARRAYSIZE
(
init_array
)
]
)
;
EXPECT_EQ
(
seq
.
size
(
)
ABSL_ARRAYSIZE
(
init_array
)
)
;
uint32_t
state_array
[
ABSL_ARRAYSIZE
(
init_array
)
]
;
seq
.
param
(
state_array
)
;
for
(
int
i
=
0
;
i
<
ABSL_ARRAYSIZE
(
state_array
)
;
i
+
+
)
{
EXPECT_EQ
(
state_array
[
i
]
i
+
1
)
;
}
}
{
Sseq
seq
;
uint32_t
seeds
[
5
]
;
seq
.
generate
(
seeds
&
seeds
[
ABSL_ARRAYSIZE
(
seeds
)
]
)
;
}
return
true
;
}
}
TEST
(
SeedSequences
CheckInterfaces
)
{
EXPECT_TRUE
(
ConformsToInterface
<
std
:
:
seed_seq
>
(
)
)
;
EXPECT_TRUE
(
ConformsToInterface
<
ExplicitSeedSeq
>
(
)
)
;
}
TEST
(
ExplicitSeedSeq
DefaultConstructorGeneratesZeros
)
{
const
size_t
kNumBlocks
=
128
;
uint32_t
outputs
[
kNumBlocks
]
;
ExplicitSeedSeq
seq
;
seq
.
generate
(
outputs
&
outputs
[
kNumBlocks
]
)
;
for
(
uint32_t
&
seed
:
outputs
)
{
EXPECT_EQ
(
seed
0
)
;
}
}
TEST
(
ExplicitSeeqSeq
SeedMaterialIsForwardedIdentically
)
{
const
size_t
kNumBlocks
=
128
;
uint32_t
seed_material
[
kNumBlocks
]
;
std
:
:
random_device
urandom
{
"
/
dev
/
urandom
"
}
;
for
(
uint32_t
&
seed
:
seed_material
)
{
seed
=
urandom
(
)
;
}
ExplicitSeedSeq
seq
(
seed_material
&
seed_material
[
kNumBlocks
]
)
;
{
const
size_t
kNumGenerated
=
kNumBlocks
/
2
;
uint32_t
outputs
[
kNumGenerated
]
;
seq
.
generate
(
outputs
&
outputs
[
kNumGenerated
]
)
;
for
(
size_t
i
=
0
;
i
<
kNumGenerated
;
i
+
+
)
{
EXPECT_EQ
(
outputs
[
i
]
seed_material
[
i
]
)
;
}
}
{
const
size_t
kNumGenerated
=
kNumBlocks
;
uint32_t
outputs
[
kNumGenerated
]
;
seq
.
generate
(
outputs
&
outputs
[
kNumGenerated
]
)
;
for
(
size_t
i
=
0
;
i
<
kNumGenerated
;
i
+
+
)
{
EXPECT_EQ
(
outputs
[
i
]
seed_material
[
i
]
)
;
}
}
{
const
size_t
kNumGenerated
=
kNumBlocks
*
2
;
uint32_t
outputs
[
kNumGenerated
]
;
seq
.
generate
(
outputs
&
outputs
[
kNumGenerated
]
)
;
for
(
size_t
i
=
0
;
i
<
kNumGenerated
;
i
+
+
)
{
EXPECT_EQ
(
outputs
[
i
]
seed_material
[
i
%
kNumBlocks
]
)
;
}
}
}
TEST
(
ExplicitSeedSeq
CopyAndMoveConstructors
)
{
using
testing
:
:
Each
;
using
testing
:
:
Eq
;
using
testing
:
:
Not
;
using
testing
:
:
Pointwise
;
uint32_t
entropy
[
4
]
;
std
:
:
random_device
urandom
(
"
/
dev
/
urandom
"
)
;
for
(
uint32_t
&
entry
:
entropy
)
{
entry
=
urandom
(
)
;
}
ExplicitSeedSeq
seq_from_entropy
(
std
:
:
begin
(
entropy
)
std
:
:
end
(
entropy
)
)
;
{
ExplicitSeedSeq
seq_copy
(
seq_from_entropy
)
;
EXPECT_EQ
(
seq_copy
.
size
(
)
seq_from_entropy
.
size
(
)
)
;
std
:
:
vector
<
uint32_t
>
seeds_1
(
1000
0
)
;
std
:
:
vector
<
uint32_t
>
seeds_2
(
1000
1
)
;
seq_from_entropy
.
generate
(
seeds_1
.
begin
(
)
seeds_1
.
end
(
)
)
;
seq_copy
.
generate
(
seeds_2
.
begin
(
)
seeds_2
.
end
(
)
)
;
EXPECT_THAT
(
seeds_1
Pointwise
(
Eq
(
)
seeds_2
)
)
;
}
{
for
(
uint32_t
&
entry
:
entropy
)
{
entry
=
urandom
(
)
;
}
ExplicitSeedSeq
another_seq
(
std
:
:
begin
(
entropy
)
std
:
:
end
(
entropy
)
)
;
std
:
:
vector
<
uint32_t
>
seeds_1
(
1000
0
)
;
std
:
:
vector
<
uint32_t
>
seeds_2
(
1000
0
)
;
seq_from_entropy
.
generate
(
seeds_1
.
begin
(
)
seeds_1
.
end
(
)
)
;
another_seq
.
generate
(
seeds_2
.
begin
(
)
seeds_2
.
end
(
)
)
;
EXPECT_THAT
(
seeds_1
Not
(
Pointwise
(
Eq
(
)
seeds_2
)
)
)
;
#
if
ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION
(
12
0
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wstringop
-
overflow
"
#
endif
another_seq
=
seq_from_entropy
;
#
if
ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION
(
12
0
)
#
pragma
GCC
diagnostic
pop
#
endif
seq_from_entropy
.
generate
(
seeds_1
.
begin
(
)
seeds_1
.
end
(
)
)
;
another_seq
.
generate
(
seeds_2
.
begin
(
)
seeds_2
.
end
(
)
)
;
EXPECT_THAT
(
seeds_1
Pointwise
(
Eq
(
)
seeds_2
)
)
;
}
{
std
:
:
vector
<
uint32_t
>
seeds_1
(
1000
0
)
;
seq_from_entropy
.
generate
(
seeds_1
.
begin
(
)
seeds_1
.
end
(
)
)
;
absl
:
:
random_internal
:
:
ExplicitSeedSeq
moved_seq
(
std
:
:
move
(
seq_from_entropy
)
)
;
std
:
:
vector
<
uint32_t
>
seeds_2
(
1000
1
)
;
moved_seq
.
generate
(
seeds_2
.
begin
(
)
seeds_2
.
end
(
)
)
;
EXPECT_THAT
(
seeds_1
Pointwise
(
Eq
(
)
seeds_2
)
)
;
EXPECT_EQ
(
seq_from_entropy
.
size
(
)
0
)
;
seq_from_entropy
.
generate
(
seeds_1
.
begin
(
)
seeds_1
.
end
(
)
)
;
EXPECT_THAT
(
seeds_1
Each
(
Eq
(
0
)
)
)
;
}
}
TEST
(
ExplicitSeedSeq
StdURBGGoldenTests
)
{
{
ExplicitSeedSeq
seed_sequence
{
12
34
56
}
;
std
:
:
minstd_rand
rng
(
seed_sequence
)
;
std
:
:
minstd_rand
:
:
result_type
values
[
4
]
=
{
rng
(
)
rng
(
)
rng
(
)
rng
(
)
}
;
EXPECT_THAT
(
values
testing
:
:
ElementsAre
(
579252
43785881
464353103
1501811174
)
)
;
}
{
ExplicitSeedSeq
seed_sequence
{
12
34
56
}
;
std
:
:
mt19937
rng
(
seed_sequence
)
;
std
:
:
mt19937
:
:
result_type
values
[
4
]
=
{
rng
(
)
rng
(
)
rng
(
)
rng
(
)
}
;
EXPECT_THAT
(
values
testing
:
:
ElementsAre
(
138416803
151130212
33817739
138416803
)
)
;
}
{
ExplicitSeedSeq
seed_sequence
{
12
34
56
}
;
std
:
:
mt19937_64
rng
(
seed_sequence
)
;
std
:
:
mt19937_64
:
:
result_type
values
[
4
]
=
{
rng
(
)
rng
(
)
rng
(
)
rng
(
)
}
;
EXPECT_THAT
(
values
testing
:
:
ElementsAre
(
19738651785169348
1464811352364190456
18054685302720800
19738651785169348
)
)
;
}
}
