#
ifndef
ABSL_RANDOM_INTERNAL_FAST_UNIFORM_BITS_H_
#
define
ABSL_RANDOM_INTERNAL_FAST_UNIFORM_BITS_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
internal
/
traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
template
<
typename
UIntType
>
constexpr
bool
IsPowerOfTwoOrZero
(
UIntType
n
)
{
return
(
n
=
=
0
)
|
|
(
(
n
&
(
n
-
1
)
)
=
=
0
)
;
}
template
<
typename
URBG
>
constexpr
typename
URBG
:
:
result_type
RangeSize
(
)
{
using
result_type
=
typename
URBG
:
:
result_type
;
static_assert
(
(
URBG
:
:
max
)
(
)
!
=
(
URBG
:
:
min
)
(
)
"
URBG
range
cannot
be
0
.
"
)
;
return
(
(
URBG
:
:
max
)
(
)
=
=
(
std
:
:
numeric_limits
<
result_type
>
:
:
max
)
(
)
&
&
(
URBG
:
:
min
)
(
)
=
=
std
:
:
numeric_limits
<
result_type
>
:
:
lowest
(
)
)
?
result_type
{
0
}
:
(
(
URBG
:
:
max
)
(
)
-
(
URBG
:
:
min
)
(
)
+
result_type
{
1
}
)
;
}
template
<
typename
UIntType
>
constexpr
UIntType
IntegerLog2
(
UIntType
n
)
{
return
(
n
<
=
1
)
?
0
:
1
+
IntegerLog2
(
n
>
>
1
)
;
}
template
<
typename
URBG
>
constexpr
size_t
NumBits
(
)
{
return
static_cast
<
size_t
>
(
RangeSize
<
URBG
>
(
)
=
=
0
?
std
:
:
numeric_limits
<
typename
URBG
:
:
result_type
>
:
:
digits
:
IntegerLog2
(
RangeSize
<
URBG
>
(
)
)
)
;
}
template
<
typename
UIntType
>
constexpr
UIntType
MaskFromShift
(
size_t
n
)
{
return
(
(
n
%
std
:
:
numeric_limits
<
UIntType
>
:
:
digits
)
=
=
0
)
?
~
UIntType
{
0
}
:
(
UIntType
{
1
}
<
<
n
)
-
UIntType
{
1
}
;
}
struct
SimplifiedLoopTag
{
}
;
struct
RejectionLoopTag
{
}
;
template
<
typename
UIntType
=
uint64_t
>
class
FastUniformBits
{
public
:
using
result_type
=
UIntType
;
static
constexpr
result_type
(
min
)
(
)
{
return
0
;
}
static
constexpr
result_type
(
max
)
(
)
{
return
(
std
:
:
numeric_limits
<
result_type
>
:
:
max
)
(
)
;
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
)
;
private
:
static_assert
(
IsUnsigned
<
UIntType
>
:
:
value
"
Class
-
template
FastUniformBits
<
>
must
be
parameterized
using
"
"
an
unsigned
type
.
"
)
;
template
<
typename
URBG
>
result_type
Generate
(
URBG
&
g
SimplifiedLoopTag
)
;
template
<
typename
URBG
>
result_type
Generate
(
URBG
&
g
RejectionLoopTag
)
;
}
;
template
<
typename
UIntType
>
template
<
typename
URBG
>
typename
FastUniformBits
<
UIntType
>
:
:
result_type
FastUniformBits
<
UIntType
>
:
:
operator
(
)
(
URBG
&
g
)
{
static_assert
(
(
URBG
:
:
max
)
(
)
>
(
URBG
:
:
min
)
(
)
"
URBG
:
:
max
and
URBG
:
:
min
may
not
be
equal
.
"
)
;
using
tag
=
absl
:
:
conditional_t
<
IsPowerOfTwoOrZero
(
RangeSize
<
URBG
>
(
)
)
SimplifiedLoopTag
RejectionLoopTag
>
;
return
Generate
(
g
tag
{
}
)
;
}
template
<
typename
UIntType
>
template
<
typename
URBG
>
typename
FastUniformBits
<
UIntType
>
:
:
result_type
FastUniformBits
<
UIntType
>
:
:
Generate
(
URBG
&
g
SimplifiedLoopTag
)
{
static_assert
(
IsPowerOfTwoOrZero
(
RangeSize
<
URBG
>
(
)
)
"
incorrect
Generate
tag
for
URBG
instance
"
)
;
static
constexpr
size_t
kResultBits
=
std
:
:
numeric_limits
<
result_type
>
:
:
digits
;
static
constexpr
size_t
kUrbgBits
=
NumBits
<
URBG
>
(
)
;
static
constexpr
size_t
kIters
=
(
kResultBits
/
kUrbgBits
)
+
(
kResultBits
%
kUrbgBits
!
=
0
)
;
static
constexpr
size_t
kShift
=
(
kIters
=
=
1
)
?
0
:
kUrbgBits
;
static
constexpr
auto
kMin
=
(
URBG
:
:
min
)
(
)
;
result_type
r
=
static_cast
<
result_type
>
(
g
(
)
-
kMin
)
;
for
(
size_t
n
=
1
;
n
<
kIters
;
+
+
n
)
{
r
=
static_cast
<
result_type
>
(
r
<
<
kShift
)
+
static_cast
<
result_type
>
(
g
(
)
-
kMin
)
;
}
return
r
;
}
template
<
typename
UIntType
>
template
<
typename
URBG
>
typename
FastUniformBits
<
UIntType
>
:
:
result_type
FastUniformBits
<
UIntType
>
:
:
Generate
(
URBG
&
g
RejectionLoopTag
)
{
static_assert
(
!
IsPowerOfTwoOrZero
(
RangeSize
<
URBG
>
(
)
)
"
incorrect
Generate
tag
for
URBG
instance
"
)
;
using
urbg_result_type
=
typename
URBG
:
:
result_type
;
static
constexpr
size_t
kResultBits
=
std
:
:
numeric_limits
<
result_type
>
:
:
digits
;
static
constexpr
urbg_result_type
kUrbgRange
=
RangeSize
<
URBG
>
(
)
;
static
constexpr
size_t
kUrbgBits
=
NumBits
<
URBG
>
(
)
;
static
constexpr
size_t
kA
=
(
kResultBits
/
kUrbgBits
)
+
(
(
kResultBits
%
kUrbgBits
)
!
=
0
)
;
static
constexpr
size_t
kABits
=
kResultBits
/
kA
;
static
constexpr
urbg_result_type
kARejection
=
(
(
kUrbgRange
>
>
kABits
)
<
<
kABits
)
;
static
constexpr
size_t
kTotalIters
=
(
(
kUrbgRange
-
kARejection
)
<
=
(
kARejection
/
kA
)
)
?
kA
:
(
kA
+
1
)
;
static
constexpr
size_t
kSmallIters
=
kTotalIters
-
(
kResultBits
%
kTotalIters
)
;
static
constexpr
size_t
kSmallBits
=
kResultBits
/
kTotalIters
;
static
constexpr
urbg_result_type
kSmallRejection
=
(
(
kUrbgRange
>
>
kSmallBits
)
<
<
kSmallBits
)
;
static
constexpr
size_t
kLargeBits
=
kSmallBits
+
1
;
static
constexpr
urbg_result_type
kLargeRejection
=
(
(
kUrbgRange
>
>
kLargeBits
)
<
<
kLargeBits
)
;
static_assert
(
kResultBits
=
=
kSmallIters
*
kSmallBits
+
(
kTotalIters
-
kSmallIters
)
*
kLargeBits
"
Error
in
looping
constant
calculations
.
"
)
;
static
constexpr
size_t
kSmallShift
=
kSmallBits
%
kResultBits
;
static
constexpr
auto
kSmallMask
=
MaskFromShift
<
urbg_result_type
>
(
kSmallShift
)
;
static
constexpr
size_t
kLargeShift
=
kLargeBits
%
kResultBits
;
static
constexpr
auto
kLargeMask
=
MaskFromShift
<
urbg_result_type
>
(
kLargeShift
)
;
static
constexpr
auto
kMin
=
(
URBG
:
:
min
)
(
)
;
result_type
s
=
0
;
for
(
size_t
n
=
0
;
n
<
kSmallIters
;
+
+
n
)
{
urbg_result_type
v
;
do
{
v
=
g
(
)
-
kMin
;
}
while
(
v
>
=
kSmallRejection
)
;
s
=
(
s
<
<
kSmallShift
)
+
static_cast
<
result_type
>
(
v
&
kSmallMask
)
;
}
for
(
size_t
n
=
kSmallIters
;
n
<
kTotalIters
;
+
+
n
)
{
urbg_result_type
v
;
do
{
v
=
g
(
)
-
kMin
;
}
while
(
v
>
=
kLargeRejection
)
;
s
=
(
s
<
<
kLargeShift
)
+
static_cast
<
result_type
>
(
v
&
kLargeMask
)
;
}
return
s
;
}
}
ABSL_NAMESPACE_END
}
#
endif
