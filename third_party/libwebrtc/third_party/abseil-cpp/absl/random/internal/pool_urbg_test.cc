#
include
"
absl
/
random
/
internal
/
pool_urbg
.
h
"
#
include
<
algorithm
>
#
include
<
bitset
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
iterator
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
types
/
span
.
h
"
using
absl
:
:
random_internal
:
:
PoolURBG
;
using
absl
:
:
random_internal
:
:
RandenPool
;
namespace
{
template
<
typename
T
>
using
is_randen_pool
=
typename
absl
:
:
disjunction
<
std
:
:
is_same
<
T
RandenPool
<
uint8_t
>
>
std
:
:
is_same
<
T
RandenPool
<
uint16_t
>
>
std
:
:
is_same
<
T
RandenPool
<
uint32_t
>
>
std
:
:
is_same
<
T
RandenPool
<
uint64_t
>
>
>
;
template
<
typename
T
typename
V
>
typename
absl
:
:
enable_if_t
<
absl
:
:
negation
<
is_randen_pool
<
T
>
>
:
:
value
void
>
MyFill
(
T
&
rng
absl
:
:
Span
<
V
>
data
)
{
std
:
:
generate
(
std
:
:
begin
(
data
)
std
:
:
end
(
data
)
rng
)
;
}
template
<
typename
T
typename
V
>
typename
absl
:
:
enable_if_t
<
is_randen_pool
<
T
>
:
:
value
void
>
MyFill
(
T
&
rng
absl
:
:
Span
<
V
>
data
)
{
rng
.
Fill
(
data
)
;
}
template
<
typename
EngineType
>
class
PoolURBGTypedTest
:
public
:
:
testing
:
:
Test
{
}
;
using
EngineTypes
=
:
:
testing
:
:
Types
<
RandenPool
<
uint8_t
>
RandenPool
<
uint16_t
>
RandenPool
<
uint32_t
>
RandenPool
<
uint64_t
>
PoolURBG
<
uint8_t
2
>
PoolURBG
<
uint16_t
2
>
PoolURBG
<
uint32_t
2
>
PoolURBG
<
uint64_t
2
>
PoolURBG
<
unsigned
int
8
>
PoolURBG
<
unsigned
long
8
>
PoolURBG
<
unsigned
long
int
4
>
PoolURBG
<
unsigned
long
long
4
>
>
;
TYPED_TEST_SUITE
(
PoolURBGTypedTest
EngineTypes
)
;
TYPED_TEST
(
PoolURBGTypedTest
URBGInterface
)
{
using
E
=
TypeParam
;
using
T
=
typename
E
:
:
result_type
;
static_assert
(
std
:
:
is_copy_constructible
<
E
>
:
:
value
"
engine
must
be
copy
constructible
"
)
;
static_assert
(
absl
:
:
is_copy_assignable
<
E
>
:
:
value
"
engine
must
be
copy
assignable
"
)
;
E
e
;
const
E
x
;
e
(
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
e
(
)
)
T
>
:
:
value
"
return
type
of
operator
(
)
must
be
result_type
"
)
;
E
u0
(
x
)
;
u0
(
)
;
E
u1
=
e
;
u1
(
)
;
}
TYPED_TEST
(
PoolURBGTypedTest
VerifySequences
)
{
using
E
=
TypeParam
;
using
result_type
=
typename
E
:
:
result_type
;
E
rng
;
(
void
)
rng
(
)
;
constexpr
int
kNumOutputs
=
64
;
result_type
a
[
kNumOutputs
]
;
result_type
b
[
kNumOutputs
]
;
std
:
:
fill
(
std
:
:
begin
(
b
)
std
:
:
end
(
b
)
0
)
;
{
E
x
=
rng
;
MyFill
(
x
absl
:
:
MakeSpan
(
a
)
)
;
}
{
E
x
=
rng
;
std
:
:
generate
(
std
:
:
begin
(
b
)
std
:
:
end
(
b
)
x
)
;
}
size_t
changed_bits
=
0
;
size_t
unchanged_bits
=
0
;
size_t
total_set
=
0
;
size_t
total_bits
=
0
;
size_t
equal_count
=
0
;
for
(
size_t
i
=
0
;
i
<
kNumOutputs
;
+
+
i
)
{
equal_count
+
=
(
a
[
i
]
=
=
b
[
i
]
)
?
1
:
0
;
std
:
:
bitset
<
sizeof
(
result_type
)
*
8
>
bitset
(
a
[
i
]
^
b
[
i
]
)
;
changed_bits
+
=
bitset
.
count
(
)
;
unchanged_bits
+
=
bitset
.
size
(
)
-
bitset
.
count
(
)
;
std
:
:
bitset
<
sizeof
(
result_type
)
*
8
>
a_set
(
a
[
i
]
)
;
std
:
:
bitset
<
sizeof
(
result_type
)
*
8
>
b_set
(
b
[
i
]
)
;
total_set
+
=
a_set
.
count
(
)
+
b_set
.
count
(
)
;
total_bits
+
=
2
*
8
*
sizeof
(
result_type
)
;
}
EXPECT_LE
(
changed_bits
0
.
60
*
(
changed_bits
+
unchanged_bits
)
)
;
EXPECT_GE
(
changed_bits
0
.
40
*
(
changed_bits
+
unchanged_bits
)
)
;
EXPECT_NEAR
(
total_set
total_bits
*
0
.
5
4
*
std
:
:
sqrt
(
total_bits
)
)
<
<
"
"
<
<
total_set
/
static_cast
<
double
>
(
total_bits
)
;
const
double
kExpected
=
kNumOutputs
/
(
1
.
0
*
sizeof
(
result_type
)
*
8
)
;
EXPECT_LE
(
equal_count
1
.
0
+
kExpected
)
;
}
}
