#
ifndef
ABSL_RANDOM_INTERNAL_RANDEN_ENGINE_H_
#
define
ABSL_RANDOM_INTERNAL_RANDEN_ENGINE_H_
#
include
<
algorithm
>
#
include
<
cinttypes
>
#
include
<
cstdlib
>
#
include
<
iostream
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
internal
/
endian
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
internal
/
iostream_state_saver
.
h
"
#
include
"
absl
/
random
/
internal
/
randen
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
template
<
typename
T
>
class
alignas
(
16
)
randen_engine
{
public
:
using
result_type
=
T
;
static_assert
(
std
:
:
is_unsigned
<
result_type
>
:
:
value
"
randen_engine
template
argument
must
be
a
built
-
in
unsigned
"
"
integer
type
"
)
;
static
constexpr
result_type
(
min
)
(
)
{
return
(
std
:
:
numeric_limits
<
result_type
>
:
:
min
)
(
)
;
}
static
constexpr
result_type
(
max
)
(
)
{
return
(
std
:
:
numeric_limits
<
result_type
>
:
:
max
)
(
)
;
}
explicit
randen_engine
(
result_type
seed_value
=
0
)
{
seed
(
seed_value
)
;
}
template
<
class
SeedSequence
typename
=
typename
absl
:
:
enable_if_t
<
!
std
:
:
is_same
<
SeedSequence
randen_engine
>
:
:
value
>
>
explicit
randen_engine
(
SeedSequence
&
&
seq
)
{
seed
(
seq
)
;
}
randen_engine
(
const
randen_engine
&
)
=
default
;
result_type
operator
(
)
(
)
{
if
(
next_
>
=
kStateSizeT
)
{
next_
=
kCapacityT
;
impl_
.
Generate
(
state_
)
;
}
return
little_endian
:
:
ToHost
(
state_
[
next_
+
+
]
)
;
}
template
<
class
SeedSequence
>
typename
absl
:
:
enable_if_t
<
!
std
:
:
is_convertible
<
SeedSequence
result_type
>
:
:
value
>
seed
(
SeedSequence
&
&
seq
)
{
seed
(
)
;
reseed
(
seq
)
;
}
void
seed
(
result_type
seed_value
=
0
)
{
next_
=
kStateSizeT
;
std
:
:
fill
(
std
:
:
begin
(
state_
)
std
:
:
begin
(
state_
)
+
kCapacityT
0
)
;
std
:
:
fill
(
std
:
:
begin
(
state_
)
+
kCapacityT
std
:
:
end
(
state_
)
seed_value
)
;
}
template
<
class
SeedSequence
>
void
reseed
(
SeedSequence
&
seq
)
{
using
sequence_result_type
=
typename
SeedSequence
:
:
result_type
;
static_assert
(
sizeof
(
sequence_result_type
)
=
=
4
"
SeedSequence
:
:
result_type
must
be
32
-
bit
"
)
;
constexpr
size_t
kBufferSize
=
Randen
:
:
kSeedBytes
/
sizeof
(
sequence_result_type
)
;
alignas
(
16
)
sequence_result_type
buffer
[
kBufferSize
]
;
const
size_t
entropy_size
=
seq
.
size
(
)
;
if
(
entropy_size
<
kBufferSize
)
{
const
size_t
requested_entropy
=
(
entropy_size
=
=
0
)
?
8u
:
entropy_size
;
std
:
:
fill
(
std
:
:
begin
(
buffer
)
+
requested_entropy
std
:
:
end
(
buffer
)
0
)
;
seq
.
generate
(
std
:
:
begin
(
buffer
)
std
:
:
begin
(
buffer
)
+
requested_entropy
)
;
size_t
dst
=
kBufferSize
;
while
(
dst
>
7
)
{
dst
-
=
4
;
size_t
src
=
dst
>
>
1
;
std
:
:
swap
(
buffer
[
-
-
dst
]
buffer
[
-
-
src
]
)
;
std
:
:
swap
(
buffer
[
-
-
dst
]
buffer
[
-
-
src
]
)
;
std
:
:
swap
(
buffer
[
-
-
dst
]
buffer
[
-
-
src
]
)
;
std
:
:
swap
(
buffer
[
-
-
dst
]
buffer
[
-
-
src
]
)
;
}
}
else
{
seq
.
generate
(
std
:
:
begin
(
buffer
)
std
:
:
end
(
buffer
)
)
;
}
impl_
.
Absorb
(
buffer
state_
)
;
next_
=
kStateSizeT
;
}
void
discard
(
uint64_t
count
)
{
uint64_t
step
=
std
:
:
min
<
uint64_t
>
(
kStateSizeT
-
next_
count
)
;
count
-
=
step
;
constexpr
uint64_t
kRateT
=
kStateSizeT
-
kCapacityT
;
while
(
count
>
0
)
{
next_
=
kCapacityT
;
impl_
.
Generate
(
state_
)
;
step
=
std
:
:
min
<
uint64_t
>
(
kRateT
count
)
;
count
-
=
step
;
}
next_
+
=
step
;
}
bool
operator
=
=
(
const
randen_engine
&
other
)
const
{
return
next_
=
=
other
.
next_
&
&
std
:
:
equal
(
std
:
:
begin
(
state_
)
std
:
:
end
(
state_
)
std
:
:
begin
(
other
.
state_
)
)
;
}
bool
operator
!
=
(
const
randen_engine
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
template
<
class
CharT
class
Traits
>
friend
std
:
:
basic_ostream
<
CharT
Traits
>
&
operator
<
<
(
std
:
:
basic_ostream
<
CharT
Traits
>
&
os
const
randen_engine
<
T
>
&
engine
)
{
using
numeric_type
=
typename
random_internal
:
:
stream_format_type
<
result_type
>
:
:
type
;
auto
saver
=
random_internal
:
:
make_ostream_state_saver
(
os
)
;
for
(
const
auto
&
elem
:
engine
.
state_
)
{
os
<
<
static_cast
<
numeric_type
>
(
little_endian
:
:
FromHost
(
elem
)
)
<
<
os
.
fill
(
)
;
}
os
<
<
engine
.
next_
;
return
os
;
}
template
<
class
CharT
class
Traits
>
friend
std
:
:
basic_istream
<
CharT
Traits
>
&
operator
>
>
(
std
:
:
basic_istream
<
CharT
Traits
>
&
is
randen_engine
<
T
>
&
engine
)
{
using
numeric_type
=
typename
random_internal
:
:
stream_format_type
<
result_type
>
:
:
type
;
result_type
state
[
kStateSizeT
]
;
size_t
next
;
for
(
auto
&
elem
:
state
)
{
numeric_type
value
;
is
>
>
value
;
elem
=
little_endian
:
:
ToHost
(
static_cast
<
result_type
>
(
value
)
)
;
}
is
>
>
next
;
if
(
is
.
fail
(
)
)
{
return
is
;
}
std
:
:
memcpy
(
engine
.
state_
state
sizeof
(
engine
.
state_
)
)
;
engine
.
next_
=
next
;
return
is
;
}
private
:
static
constexpr
size_t
kStateSizeT
=
Randen
:
:
kStateBytes
/
sizeof
(
result_type
)
;
static
constexpr
size_t
kCapacityT
=
Randen
:
:
kCapacityBytes
/
sizeof
(
result_type
)
;
alignas
(
16
)
result_type
state_
[
kStateSizeT
]
;
size_t
next_
;
Randen
impl_
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
