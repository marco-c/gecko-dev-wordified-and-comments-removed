#
ifndef
ABSL_RANDOM_MOCKING_BIT_GEN_H_
#
define
ABSL_RANDOM_MOCKING_BIT_GEN_H_
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
internal
/
fast_type_id
.
h
"
#
include
"
absl
/
container
/
flat_hash_map
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
distributions
.
h
"
#
include
"
absl
/
random
/
internal
/
distribution_caller
.
h
"
#
include
"
absl
/
random
/
random
.
h
"
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
str_join
.
h
"
#
include
"
absl
/
types
/
span
.
h
"
#
include
"
absl
/
types
/
variant
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
template
<
typename
>
struct
DistributionCaller
;
class
MockHelpers
;
}
class
BitGenRef
;
class
MockingBitGen
{
public
:
MockingBitGen
(
)
=
default
;
~
MockingBitGen
(
)
=
default
;
using
result_type
=
absl
:
:
BitGen
:
:
result_type
;
static
constexpr
result_type
(
min
)
(
)
{
return
(
absl
:
:
BitGen
:
:
min
)
(
)
;
}
static
constexpr
result_type
(
max
)
(
)
{
return
(
absl
:
:
BitGen
:
:
max
)
(
)
;
}
result_type
operator
(
)
(
)
{
return
gen_
(
)
;
}
private
:
template
<
typename
ResultT
typename
.
.
.
Args
>
static
auto
GetMockFnType
(
ResultT
std
:
:
tuple
<
Args
.
.
.
>
)
-
>
:
:
testing
:
:
MockFunction
<
ResultT
(
Args
.
.
.
)
>
;
template
<
typename
MockFnType
typename
ResultT
typename
Tuple
>
struct
MockFnCaller
;
template
<
typename
MockFnType
typename
ResultT
typename
.
.
.
Args
>
struct
MockFnCaller
<
MockFnType
ResultT
std
:
:
tuple
<
Args
.
.
.
>
>
{
MockFnType
*
fn
;
inline
ResultT
operator
(
)
(
Args
.
.
.
args
)
{
return
fn
-
>
Call
(
std
:
:
move
(
args
)
.
.
.
)
;
}
}
;
class
FunctionHolder
{
public
:
virtual
~
FunctionHolder
(
)
=
default
;
virtual
void
Apply
(
void
*
args_tuple
void
*
result
)
=
0
;
}
;
template
<
typename
MockFnType
typename
ResultT
typename
ArgTupleT
>
class
FunctionHolderImpl
final
:
public
FunctionHolder
{
public
:
void
Apply
(
void
*
args_tuple
void
*
result
)
override
{
*
static_cast
<
ResultT
*
>
(
result
)
=
absl
:
:
apply
(
MockFnCaller
<
MockFnType
ResultT
ArgTupleT
>
{
&
mock_fn_
}
*
static_cast
<
ArgTupleT
*
>
(
args_tuple
)
)
;
}
MockFnType
mock_fn_
;
}
;
template
<
typename
ResultT
typename
ArgTupleT
typename
SelfT
>
auto
RegisterMock
(
SelfT
&
base_internal
:
:
FastTypeIdType
type
)
-
>
decltype
(
GetMockFnType
(
std
:
:
declval
<
ResultT
>
(
)
std
:
:
declval
<
ArgTupleT
>
(
)
)
)
&
{
using
MockFnType
=
decltype
(
GetMockFnType
(
std
:
:
declval
<
ResultT
>
(
)
std
:
:
declval
<
ArgTupleT
>
(
)
)
)
;
using
WrappedFnType
=
absl
:
:
conditional_t
<
std
:
:
is_same
<
SelfT
:
:
testing
:
:
NiceMock
<
absl
:
:
MockingBitGen
>
>
:
:
value
:
:
testing
:
:
NiceMock
<
MockFnType
>
absl
:
:
conditional_t
<
std
:
:
is_same
<
SelfT
:
:
testing
:
:
NaggyMock
<
absl
:
:
MockingBitGen
>
>
:
:
value
:
:
testing
:
:
NaggyMock
<
MockFnType
>
absl
:
:
conditional_t
<
std
:
:
is_same
<
SelfT
:
:
testing
:
:
StrictMock
<
absl
:
:
MockingBitGen
>
>
:
:
value
:
:
testing
:
:
StrictMock
<
MockFnType
>
MockFnType
>
>
>
;
using
ImplT
=
FunctionHolderImpl
<
WrappedFnType
ResultT
ArgTupleT
>
;
auto
&
mock
=
mocks_
[
type
]
;
if
(
!
mock
)
{
mock
=
absl
:
:
make_unique
<
ImplT
>
(
)
;
}
return
static_cast
<
ImplT
*
>
(
mock
.
get
(
)
)
-
>
mock_fn_
;
}
inline
bool
InvokeMock
(
base_internal
:
:
FastTypeIdType
type
void
*
args_tuple
void
*
result
)
{
auto
it
=
mocks_
.
find
(
type
)
;
if
(
it
=
=
mocks_
.
end
(
)
)
return
false
;
it
-
>
second
-
>
Apply
(
args_tuple
result
)
;
return
true
;
}
absl
:
:
flat_hash_map
<
base_internal
:
:
FastTypeIdType
std
:
:
unique_ptr
<
FunctionHolder
>
>
mocks_
;
absl
:
:
BitGen
gen_
;
template
<
typename
>
friend
struct
:
:
absl
:
:
random_internal
:
:
DistributionCaller
;
friend
class
:
:
absl
:
:
BitGenRef
;
friend
class
:
:
absl
:
:
random_internal
:
:
MockHelpers
;
}
;
ABSL_NAMESPACE_END
}
#
endif
