#
ifndef
ABSL_RANDOM_MOCKING_BIT_GEN_H_
#
define
ABSL_RANDOM_MOCKING_BIT_GEN_H_
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
internal
/
fast_type_id
.
h
"
#
include
"
absl
/
container
/
flat_hash_map
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
distributions
.
h
"
#
include
"
absl
/
random
/
internal
/
distribution_caller
.
h
"
#
include
"
absl
/
random
/
random
.
h
"
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
str_join
.
h
"
#
include
"
absl
/
types
/
span
.
h
"
#
include
"
absl
/
types
/
variant
.
h
"
#
include
"
absl
/
utility
/
utility
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
random_internal
{
template
<
typename
>
struct
DistributionCaller
;
class
MockHelpers
;
}
class
BitGenRef
;
class
MockingBitGen
{
public
:
MockingBitGen
(
)
=
default
;
~
MockingBitGen
(
)
{
for
(
const
auto
&
del
:
deleters_
)
del
(
)
;
}
using
result_type
=
absl
:
:
BitGen
:
:
result_type
;
static
constexpr
result_type
(
min
)
(
)
{
return
(
absl
:
:
BitGen
:
:
min
)
(
)
;
}
static
constexpr
result_type
(
max
)
(
)
{
return
(
absl
:
:
BitGen
:
:
max
)
(
)
;
}
result_type
operator
(
)
(
)
{
return
gen_
(
)
;
}
private
:
using
match_impl_fn
=
void
(
*
)
(
void
*
mock_fn
void
*
t_erased_arg_tuple
void
*
t_erased_result
)
;
struct
MockData
{
void
*
mock_fn
=
nullptr
;
match_impl_fn
match_impl
=
nullptr
;
}
;
template
<
typename
ResultT
typename
.
.
.
Args
>
static
auto
GetMockFnType
(
ResultT
std
:
:
tuple
<
Args
.
.
.
>
)
-
>
:
:
testing
:
:
MockFunction
<
ResultT
(
Args
.
.
.
)
>
;
template
<
typename
ResultT
typename
MockFnType
typename
Tuple
>
struct
MockFnCaller
;
template
<
typename
ResultT
typename
MockFnType
typename
.
.
.
Args
>
struct
MockFnCaller
<
ResultT
MockFnType
std
:
:
tuple
<
Args
.
.
.
>
>
{
MockFnType
*
fn
;
inline
ResultT
operator
(
)
(
Args
.
.
.
args
)
{
return
fn
-
>
Call
(
std
:
:
move
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
ResultT
typename
ArgTupleT
>
auto
RegisterMock
(
base_internal
:
:
FastTypeIdType
type
)
-
>
decltype
(
GetMockFnType
(
std
:
:
declval
<
ResultT
>
(
)
std
:
:
declval
<
ArgTupleT
>
(
)
)
)
&
{
using
MockFnType
=
decltype
(
GetMockFnType
(
std
:
:
declval
<
ResultT
>
(
)
std
:
:
declval
<
ArgTupleT
>
(
)
)
)
;
auto
&
mock
=
mocks_
[
type
]
;
if
(
!
mock
.
mock_fn
)
{
auto
*
mock_fn
=
new
MockFnType
;
mock
.
mock_fn
=
mock_fn
;
mock
.
match_impl
=
&
MatchImpl
<
ResultT
ArgTupleT
>
;
deleters_
.
emplace_back
(
[
mock_fn
]
{
delete
mock_fn
;
}
)
;
}
return
*
static_cast
<
MockFnType
*
>
(
mock
.
mock_fn
)
;
}
template
<
typename
ResultT
typename
ArgTupleT
>
static
void
MatchImpl
(
void
*
mock_fn
void
*
args_tuple
void
*
result
)
{
using
MockFnType
=
decltype
(
GetMockFnType
(
std
:
:
declval
<
ResultT
>
(
)
std
:
:
declval
<
ArgTupleT
>
(
)
)
)
;
*
static_cast
<
ResultT
*
>
(
result
)
=
absl
:
:
apply
(
MockFnCaller
<
ResultT
MockFnType
ArgTupleT
>
{
static_cast
<
MockFnType
*
>
(
mock_fn
)
}
*
static_cast
<
ArgTupleT
*
>
(
args_tuple
)
)
;
}
inline
bool
InvokeMock
(
base_internal
:
:
FastTypeIdType
type
void
*
args_tuple
void
*
result
)
{
auto
it
=
mocks_
.
find
(
type
)
;
if
(
it
=
=
mocks_
.
end
(
)
)
return
false
;
auto
*
mock_data
=
static_cast
<
MockData
*
>
(
&
it
-
>
second
)
;
mock_data
-
>
match_impl
(
mock_data
-
>
mock_fn
args_tuple
result
)
;
return
true
;
}
absl
:
:
flat_hash_map
<
base_internal
:
:
FastTypeIdType
MockData
>
mocks_
;
std
:
:
vector
<
std
:
:
function
<
void
(
)
>
>
deleters_
;
absl
:
:
BitGen
gen_
;
template
<
typename
>
friend
struct
:
:
absl
:
:
random_internal
:
:
DistributionCaller
;
friend
class
:
:
absl
:
:
BitGenRef
;
friend
class
:
:
absl
:
:
random_internal
:
:
MockHelpers
;
}
;
ABSL_NAMESPACE_END
}
#
endif
