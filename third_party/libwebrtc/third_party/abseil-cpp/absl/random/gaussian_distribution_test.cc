#
include
"
absl
/
random
/
gaussian_distribution
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
ios
>
#
include
<
iterator
>
#
include
<
random
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
numeric
/
internal
/
representation
.
h
"
#
include
"
absl
/
random
/
internal
/
chi_square
.
h
"
#
include
"
absl
/
random
/
internal
/
distribution_test_util
.
h
"
#
include
"
absl
/
random
/
internal
/
sequence_urbg
.
h
"
#
include
"
absl
/
random
/
random
.
h
"
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
str_format
.
h
"
#
include
"
absl
/
strings
/
str_replace
.
h
"
#
include
"
absl
/
strings
/
strip
.
h
"
namespace
{
using
absl
:
:
random_internal
:
:
kChiSquared
;
template
<
typename
RealType
>
class
GaussianDistributionInterfaceTest
:
public
:
:
testing
:
:
Test
{
}
;
using
RealTypes
=
std
:
:
conditional
<
absl
:
:
numeric_internal
:
:
IsDoubleDouble
(
)
:
:
testing
:
:
Types
<
float
double
>
:
:
testing
:
:
Types
<
float
double
long
double
>
>
:
:
type
;
TYPED_TEST_CASE
(
GaussianDistributionInterfaceTest
RealTypes
)
;
TYPED_TEST
(
GaussianDistributionInterfaceTest
SerializeTest
)
{
using
param_type
=
typename
absl
:
:
gaussian_distribution
<
TypeParam
>
:
:
param_type
;
const
TypeParam
kParams
[
]
=
{
1
std
:
:
nextafter
(
TypeParam
(
1
)
TypeParam
(
0
)
)
std
:
:
nextafter
(
TypeParam
(
1
)
TypeParam
(
2
)
)
TypeParam
(
1e
-
8
)
TypeParam
(
1e
-
4
)
TypeParam
(
2
)
TypeParam
(
1e4
)
TypeParam
(
1e8
)
TypeParam
(
1e20
)
TypeParam
(
2
.
5
)
std
:
:
numeric_limits
<
TypeParam
>
:
:
infinity
(
)
std
:
:
numeric_limits
<
TypeParam
>
:
:
max
(
)
std
:
:
numeric_limits
<
TypeParam
>
:
:
epsilon
(
)
std
:
:
nextafter
(
std
:
:
numeric_limits
<
TypeParam
>
:
:
min
(
)
TypeParam
(
1
)
)
std
:
:
numeric_limits
<
TypeParam
>
:
:
min
(
)
std
:
:
numeric_limits
<
TypeParam
>
:
:
denorm_min
(
)
std
:
:
numeric_limits
<
TypeParam
>
:
:
min
(
)
/
2
std
:
:
nextafter
(
std
:
:
numeric_limits
<
TypeParam
>
:
:
min
(
)
TypeParam
(
0
)
)
}
;
constexpr
int
kCount
=
1000
;
absl
:
:
InsecureBitGen
gen
;
for
(
const
auto
mod
:
{
0
1
2
3
}
)
{
for
(
const
auto
x
:
kParams
)
{
if
(
!
std
:
:
isfinite
(
x
)
)
continue
;
for
(
const
auto
y
:
kParams
)
{
const
TypeParam
mean
=
(
mod
&
0x1
)
?
-
x
:
x
;
const
TypeParam
stddev
=
(
mod
&
0x2
)
?
-
y
:
y
;
const
param_type
param
(
mean
stddev
)
;
absl
:
:
gaussian_distribution
<
TypeParam
>
before
(
mean
stddev
)
;
EXPECT_EQ
(
before
.
mean
(
)
param
.
mean
(
)
)
;
EXPECT_EQ
(
before
.
stddev
(
)
param
.
stddev
(
)
)
;
{
absl
:
:
gaussian_distribution
<
TypeParam
>
via_param
(
param
)
;
EXPECT_EQ
(
via_param
before
)
;
EXPECT_EQ
(
via_param
.
param
(
)
before
.
param
(
)
)
;
}
auto
sample_min
=
before
.
max
(
)
;
auto
sample_max
=
before
.
min
(
)
;
for
(
int
i
=
0
;
i
<
kCount
;
i
+
+
)
{
auto
sample
=
before
(
gen
)
;
if
(
sample
>
sample_max
)
sample_max
=
sample
;
if
(
sample
<
sample_min
)
sample_min
=
sample
;
EXPECT_GE
(
sample
before
.
min
(
)
)
<
<
before
;
EXPECT_LE
(
sample
before
.
max
(
)
)
<
<
before
;
}
if
(
!
std
:
:
is_same
<
TypeParam
long
double
>
:
:
value
)
{
ABSL_INTERNAL_LOG
(
INFO
absl
:
:
StrFormat
(
"
Range
{
%
f
%
f
}
:
%
f
%
f
"
mean
stddev
sample_min
sample_max
)
)
;
}
std
:
:
stringstream
ss
;
ss
<
<
before
;
if
(
!
std
:
:
isfinite
(
mean
)
|
|
!
std
:
:
isfinite
(
stddev
)
)
{
continue
;
}
absl
:
:
gaussian_distribution
<
TypeParam
>
after
(
-
0
.
53f
2
.
3456f
)
;
EXPECT_NE
(
before
.
mean
(
)
after
.
mean
(
)
)
;
EXPECT_NE
(
before
.
stddev
(
)
after
.
stddev
(
)
)
;
EXPECT_NE
(
before
.
param
(
)
after
.
param
(
)
)
;
EXPECT_NE
(
before
after
)
;
ss
>
>
after
;
EXPECT_EQ
(
before
.
mean
(
)
after
.
mean
(
)
)
;
EXPECT_EQ
(
before
.
stddev
(
)
after
.
stddev
(
)
)
<
<
ss
.
str
(
)
<
<
"
"
<
<
(
ss
.
good
(
)
?
"
good
"
:
"
"
)
<
<
(
ss
.
bad
(
)
?
"
bad
"
:
"
"
)
<
<
(
ss
.
eof
(
)
?
"
eof
"
:
"
"
)
<
<
(
ss
.
fail
(
)
?
"
fail
"
:
"
"
)
;
}
}
}
}
class
GaussianModel
{
public
:
GaussianModel
(
double
mean
double
stddev
)
:
mean_
(
mean
)
stddev_
(
stddev
)
{
}
double
mean
(
)
const
{
return
mean_
;
}
double
variance
(
)
const
{
return
stddev
(
)
*
stddev
(
)
;
}
double
stddev
(
)
const
{
return
stddev_
;
}
double
skew
(
)
const
{
return
0
;
}
double
kurtosis
(
)
const
{
return
3
.
0
;
}
double
InverseCDF
(
double
p
)
{
ABSL_ASSERT
(
p
>
=
0
.
0
)
;
ABSL_ASSERT
(
p
<
1
.
0
)
;
return
mean
(
)
+
stddev
(
)
*
-
absl
:
:
random_internal
:
:
InverseNormalSurvival
(
p
)
;
}
private
:
const
double
mean_
;
const
double
stddev_
;
}
;
struct
Param
{
double
mean
;
double
stddev
;
double
p_fail
;
int
trials
;
}
;
class
GaussianDistributionTests
:
public
testing
:
:
TestWithParam
<
Param
>
public
GaussianModel
{
public
:
GaussianDistributionTests
(
)
:
GaussianModel
(
GetParam
(
)
.
mean
GetParam
(
)
.
stddev
)
{
}
template
<
typename
D
>
bool
SingleZTest
(
const
double
p
const
size_t
samples
)
;
template
<
typename
D
>
double
SingleChiSquaredTest
(
)
;
absl
:
:
random_internal
:
:
pcg64_2018_engine
rng_
{
0x2B7E151628AED2A6
}
;
}
;
template
<
typename
D
>
bool
GaussianDistributionTests
:
:
SingleZTest
(
const
double
p
const
size_t
samples
)
{
D
dis
(
mean
(
)
stddev
(
)
)
;
std
:
:
vector
<
double
>
data
;
data
.
reserve
(
samples
)
;
for
(
size_t
i
=
0
;
i
<
samples
;
i
+
+
)
{
const
double
x
=
dis
(
rng_
)
;
data
.
push_back
(
x
)
;
}
const
double
max_err
=
absl
:
:
random_internal
:
:
MaxErrorTolerance
(
p
)
;
const
auto
m
=
absl
:
:
random_internal
:
:
ComputeDistributionMoments
(
data
)
;
const
double
z
=
absl
:
:
random_internal
:
:
ZScore
(
mean
(
)
m
)
;
const
bool
pass
=
absl
:
:
random_internal
:
:
Near
(
"
z
"
z
0
.
0
max_err
)
;
const
double
jb
=
static_cast
<
double
>
(
m
.
n
)
/
6
.
0
*
(
std
:
:
pow
(
m
.
skewness
2
.
0
)
+
std
:
:
pow
(
m
.
kurtosis
-
3
.
0
2
.
0
)
/
4
.
0
)
;
if
(
!
pass
|
|
jb
>
9
.
21
)
{
ABSL_INTERNAL_LOG
(
INFO
absl
:
:
StrFormat
(
"
p
=
%
f
max_err
=
%
f
\
n
"
"
mean
=
%
f
vs
.
%
f
\
n
"
"
stddev
=
%
f
vs
.
%
f
\
n
"
"
skewness
=
%
f
vs
.
%
f
\
n
"
"
kurtosis
=
%
f
vs
.
%
f
\
n
"
"
z
=
%
f
vs
.
0
\
n
"
"
jb
=
%
f
vs
.
9
.
21
"
p
max_err
m
.
mean
mean
(
)
std
:
:
sqrt
(
m
.
variance
)
stddev
(
)
m
.
skewness
skew
(
)
m
.
kurtosis
kurtosis
(
)
z
jb
)
)
;
}
return
pass
;
}
template
<
typename
D
>
double
GaussianDistributionTests
:
:
SingleChiSquaredTest
(
)
{
const
size_t
kSamples
=
10000
;
const
int
kBuckets
=
50
;
std
:
:
vector
<
double
>
cutoffs
;
const
double
kInc
=
1
.
0
/
static_cast
<
double
>
(
kBuckets
)
;
for
(
double
p
=
kInc
;
p
<
1
.
0
;
p
+
=
kInc
)
{
cutoffs
.
push_back
(
InverseCDF
(
p
)
)
;
}
if
(
cutoffs
.
back
(
)
!
=
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
{
cutoffs
.
push_back
(
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
)
;
}
D
dis
(
mean
(
)
stddev
(
)
)
;
std
:
:
vector
<
int32_t
>
counts
(
cutoffs
.
size
(
)
0
)
;
for
(
int
j
=
0
;
j
<
kSamples
;
j
+
+
)
{
const
double
x
=
dis
(
rng_
)
;
auto
it
=
std
:
:
upper_bound
(
cutoffs
.
begin
(
)
cutoffs
.
end
(
)
x
)
;
counts
[
std
:
:
distance
(
cutoffs
.
begin
(
)
it
)
]
+
+
;
}
const
int
dof
=
static_cast
<
int
>
(
counts
.
size
(
)
)
-
1
;
const
double
threshold
=
absl
:
:
random_internal
:
:
ChiSquareValue
(
dof
0
.
98
)
;
const
double
expected
=
static_cast
<
double
>
(
kSamples
)
/
static_cast
<
double
>
(
counts
.
size
(
)
)
;
double
chi_square
=
absl
:
:
random_internal
:
:
ChiSquareWithExpected
(
std
:
:
begin
(
counts
)
std
:
:
end
(
counts
)
expected
)
;
double
p
=
absl
:
:
random_internal
:
:
ChiSquarePValue
(
chi_square
dof
)
;
if
(
chi_square
>
threshold
)
{
for
(
int
i
=
0
;
i
<
cutoffs
.
size
(
)
;
i
+
+
)
{
ABSL_INTERNAL_LOG
(
INFO
absl
:
:
StrFormat
(
"
%
d
:
(
%
f
)
=
%
d
"
i
cutoffs
[
i
]
counts
[
i
]
)
)
;
}
ABSL_INTERNAL_LOG
(
INFO
absl
:
:
StrCat
(
"
mean
=
"
mean
(
)
"
stddev
=
"
stddev
(
)
"
\
n
"
"
expected
"
expected
"
\
n
"
kChiSquared
"
"
chi_square
"
(
"
p
"
)
\
n
"
kChiSquared
"
0
.
98
=
"
threshold
)
)
;
}
return
p
;
}
TEST_P
(
GaussianDistributionTests
ZTest
)
{
const
size_t
kSamples
=
10000
;
const
auto
&
param
=
GetParam
(
)
;
const
int
expected_failures
=
std
:
:
max
(
1
static_cast
<
int
>
(
std
:
:
ceil
(
param
.
trials
*
param
.
p_fail
)
)
)
;
const
double
p
=
absl
:
:
random_internal
:
:
RequiredSuccessProbability
(
param
.
p_fail
param
.
trials
)
;
int
failures
=
0
;
for
(
int
i
=
0
;
i
<
param
.
trials
;
i
+
+
)
{
failures
+
=
SingleZTest
<
absl
:
:
gaussian_distribution
<
double
>
>
(
p
kSamples
)
?
0
:
1
;
}
EXPECT_LE
(
failures
expected_failures
)
;
}
TEST_P
(
GaussianDistributionTests
ChiSquaredTest
)
{
const
int
kTrials
=
20
;
int
failures
=
0
;
for
(
int
i
=
0
;
i
<
kTrials
;
i
+
+
)
{
double
p_value
=
SingleChiSquaredTest
<
absl
:
:
gaussian_distribution
<
double
>
>
(
)
;
if
(
p_value
<
0
.
0025
)
{
failures
+
+
;
}
}
EXPECT_LE
(
failures
4
)
;
}
std
:
:
vector
<
Param
>
GenParams
(
)
{
return
{
Param
{
0
.
0
1
.
0
0
.
01
100
}
Param
{
0
.
0
1e2
0
.
01
100
}
Param
{
0
.
0
1e4
0
.
01
100
}
Param
{
0
.
0
1e8
0
.
01
100
}
Param
{
0
.
0
1e16
0
.
01
100
}
Param
{
0
.
0
1e
-
3
0
.
01
100
}
Param
{
0
.
0
1e
-
5
0
.
01
100
}
Param
{
0
.
0
1e
-
9
0
.
01
100
}
Param
{
0
.
0
1e
-
17
0
.
01
100
}
Param
{
1
.
0
1
.
0
0
.
01
100
}
Param
{
1
.
0
1e2
0
.
01
100
}
Param
{
1
.
0
1e
-
2
0
.
01
100
}
Param
{
1e2
1
.
0
0
.
01
100
}
Param
{
-
1e2
1
.
0
0
.
01
100
}
Param
{
1e2
1e6
0
.
01
100
}
Param
{
-
1e2
1e6
0
.
01
100
}
Param
{
1e4
1e4
0
.
01
100
}
Param
{
1e8
1e4
0
.
01
100
}
Param
{
1e12
1e4
0
.
01
100
}
}
;
}
std
:
:
string
ParamName
(
const
:
:
testing
:
:
TestParamInfo
<
Param
>
&
info
)
{
const
auto
&
p
=
info
.
param
;
std
:
:
string
name
=
absl
:
:
StrCat
(
"
mean_
"
absl
:
:
SixDigits
(
p
.
mean
)
"
__stddev_
"
absl
:
:
SixDigits
(
p
.
stddev
)
)
;
return
absl
:
:
StrReplaceAll
(
name
{
{
"
+
"
"
_
"
}
{
"
-
"
"
_
"
}
{
"
.
"
"
_
"
}
}
)
;
}
INSTANTIATE_TEST_SUITE_P
(
All
GaussianDistributionTests
:
:
testing
:
:
ValuesIn
(
GenParams
(
)
)
ParamName
)
;
TEST
(
GaussianDistributionTest
StabilityTest
)
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
0x0003eb76f6f7f755ull
0xFFCEA50FDB2F953Bull
0xC332DDEFBE6C5AA5ull
0x6558218568AB9702ull
0x2AEF7DAD5B6E2F84ull
0x1521B62829076170ull
0xECDD4775619F1510ull
0x13CCA830EB61BD96ull
0x0334FE1EAA0363CFull
0xB5735C904C70A239ull
0xD59E9E0BCBAADE14ull
0xEECC86BC60622CA7ull
}
)
;
std
:
:
vector
<
int
>
output
(
11
)
;
{
absl
:
:
gaussian_distribution
<
double
>
dist
;
std
:
:
generate
(
std
:
:
begin
(
output
)
std
:
:
end
(
output
)
[
&
]
{
return
static_cast
<
int
>
(
10000000
.
0
*
dist
(
urbg
)
)
;
}
)
;
EXPECT_EQ
(
13
urbg
.
invocations
(
)
)
;
EXPECT_THAT
(
output
testing
:
:
ElementsAre
(
1494
25518841
9991550
1351856
-
20373238
3456682
333530
-
6804981
-
15279580
-
16459654
1494
)
)
;
}
urbg
.
reset
(
)
;
{
absl
:
:
gaussian_distribution
<
float
>
dist
;
std
:
:
generate
(
std
:
:
begin
(
output
)
std
:
:
end
(
output
)
[
&
]
{
return
static_cast
<
int
>
(
1000000
.
0f
*
dist
(
urbg
)
)
;
}
)
;
EXPECT_EQ
(
13
urbg
.
invocations
(
)
)
;
EXPECT_THAT
(
output
testing
:
:
ElementsAre
(
149
2551884
999155
135185
-
2037323
345668
33353
-
680498
-
1527958
-
1645965
149
)
)
;
}
}
TEST
(
GaussianDistributionTest
AlgorithmBounds
)
{
absl
:
:
gaussian_distribution
<
double
>
dist
;
const
uint64_t
kValues
[
]
=
{
0x1000000000000100ull
0x2000000000000100ull
0x3000000000000100ull
0x4000000000000100ull
0x5000000000000100ull
0x6000000000000100ull
0x9000000000000100ull
0xa000000000000100ull
0xb000000000000100ull
0xc000000000000100ull
0xd000000000000100ull
0xe000000000000100ull
}
;
const
uint64_t
kExtraValues
[
]
=
{
0x7000000000000100ull
0x7800000000000100ull
0x7c00000000000100ull
0x7e00000000000100ull
0xf000000000000100ull
0xf800000000000100ull
0xfc00000000000100ull
0xfe00000000000100ull
}
;
auto
make_box
=
[
]
(
uint64_t
v
uint64_t
box
)
{
return
(
v
&
0xffffffffffffff80ull
)
|
box
;
}
;
for
(
uint64_t
box
=
0
;
box
<
0x7f
;
box
+
+
)
{
for
(
const
uint64_t
v
:
kValues
)
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_box
(
v
box
)
0x0003eb76f6f7f755ull
0x5FCEA50FDB2F953Bull
}
)
;
auto
a
=
dist
(
urbg
)
;
EXPECT_EQ
(
1
urbg
.
invocations
(
)
)
<
<
box
<
<
"
"
<
<
std
:
:
hex
<
<
v
;
if
(
v
&
0x8000000000000000ull
)
{
EXPECT_LT
(
a
0
.
0
)
<
<
box
<
<
"
"
<
<
std
:
:
hex
<
<
v
;
}
else
{
EXPECT_GT
(
a
0
.
0
)
<
<
box
<
<
"
"
<
<
std
:
:
hex
<
<
v
;
}
}
if
(
box
>
10
&
&
box
<
100
)
{
for
(
const
uint64_t
v
:
kExtraValues
)
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_box
(
v
box
)
0x0003eb76f6f7f755ull
0x5FCEA50FDB2F953Bull
}
)
;
auto
a
=
dist
(
urbg
)
;
EXPECT_EQ
(
1
urbg
.
invocations
(
)
)
<
<
box
<
<
"
"
<
<
std
:
:
hex
<
<
v
;
if
(
v
&
0x8000000000000000ull
)
{
EXPECT_LT
(
a
0
.
0
)
<
<
box
<
<
"
"
<
<
std
:
:
hex
<
<
v
;
}
else
{
EXPECT_GT
(
a
0
.
0
)
<
<
box
<
<
"
"
<
<
std
:
:
hex
<
<
v
;
}
}
}
}
auto
make_fallback
=
[
]
(
uint64_t
v
)
{
return
(
v
&
0xffffffffffffff80ull
)
;
}
;
double
tail
[
2
]
;
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_fallback
(
0x7800000000000000ull
)
0x13CCA830EB61BD96ull
0x00000076f6f7f755ull
}
)
;
tail
[
0
]
=
dist
(
urbg
)
;
EXPECT_EQ
(
3
urbg
.
invocations
(
)
)
;
EXPECT_GT
(
tail
[
0
]
0
)
;
}
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_fallback
(
0xf800000000000000ull
)
0x13CCA830EB61BD96ull
0x00000076f6f7f755ull
}
)
;
tail
[
1
]
=
dist
(
urbg
)
;
EXPECT_EQ
(
3
urbg
.
invocations
(
)
)
;
EXPECT_LT
(
tail
[
1
]
0
)
;
}
EXPECT_EQ
(
tail
[
0
]
-
tail
[
1
]
)
;
EXPECT_EQ
(
418610
static_cast
<
int64_t
>
(
tail
[
0
]
*
100000
.
0
)
)
;
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_box
(
0x7f00000000000000ull
120
)
0xe000000000000001ull
0x13CCA830EB61BD96ull
}
)
;
tail
[
0
]
=
dist
(
urbg
)
;
EXPECT_EQ
(
2
urbg
.
invocations
(
)
)
;
EXPECT_GT
(
tail
[
0
]
0
)
;
}
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_box
(
0xff00000000000000ull
120
)
0xe000000000000001ull
0x13CCA830EB61BD96ull
}
)
;
tail
[
1
]
=
dist
(
urbg
)
;
EXPECT_EQ
(
2
urbg
.
invocations
(
)
)
;
EXPECT_LT
(
tail
[
1
]
0
)
;
}
EXPECT_EQ
(
tail
[
0
]
-
tail
[
1
]
)
;
EXPECT_EQ
(
61948
static_cast
<
int64_t
>
(
tail
[
0
]
*
100000
.
0
)
)
;
{
absl
:
:
random_internal
:
:
sequence_urbg
urbg
(
{
make_box
(
0xff00000000000000ull
120
)
0x1000000000000001
make_box
(
0x1000000000000100ull
50
)
0x13CCA830EB61BD96ull
}
)
;
dist
(
urbg
)
;
EXPECT_EQ
(
3
urbg
.
invocations
(
)
)
;
}
}
}
