#
ifndef
ABSL_RANDOM_UNIFORM_REAL_DISTRIBUTION_H_
#
define
ABSL_RANDOM_UNIFORM_REAL_DISTRIBUTION_H_
#
include
<
cassert
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
istream
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
absl
/
meta
/
type_traits
.
h
"
#
include
"
absl
/
random
/
internal
/
fast_uniform_bits
.
h
"
#
include
"
absl
/
random
/
internal
/
generate_real
.
h
"
#
include
"
absl
/
random
/
internal
/
iostream_state_saver
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
RealType
=
double
>
class
uniform_real_distribution
{
public
:
using
result_type
=
RealType
;
class
param_type
{
public
:
using
distribution_type
=
uniform_real_distribution
;
explicit
param_type
(
result_type
lo
=
0
result_type
hi
=
1
)
:
lo_
(
lo
)
hi_
(
hi
)
range_
(
hi
-
lo
)
{
assert
(
lo
<
=
hi
)
;
assert
(
range_
<
=
(
std
:
:
numeric_limits
<
result_type
>
:
:
max
)
(
)
)
;
}
result_type
a
(
)
const
{
return
lo_
;
}
result_type
b
(
)
const
{
return
hi_
;
}
friend
bool
operator
=
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
a
.
lo_
=
=
b
.
lo_
&
&
a
.
hi_
=
=
b
.
hi_
;
}
friend
bool
operator
!
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
friend
class
uniform_real_distribution
;
result_type
lo_
hi_
range_
;
static_assert
(
std
:
:
is_floating_point
<
RealType
>
:
:
value
"
Class
-
template
absl
:
:
uniform_real_distribution
<
>
must
be
"
"
parameterized
using
a
floating
-
point
type
.
"
)
;
}
;
uniform_real_distribution
(
)
:
uniform_real_distribution
(
0
)
{
}
explicit
uniform_real_distribution
(
result_type
lo
result_type
hi
=
1
)
:
param_
(
lo
hi
)
{
}
explicit
uniform_real_distribution
(
const
param_type
&
param
)
:
param_
(
param
)
{
}
void
reset
(
)
{
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
gen
)
{
return
operator
(
)
(
gen
param_
)
;
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
gen
const
param_type
&
p
)
;
result_type
a
(
)
const
{
return
param_
.
a
(
)
;
}
result_type
b
(
)
const
{
return
param_
.
b
(
)
;
}
param_type
param
(
)
const
{
return
param_
;
}
void
param
(
const
param_type
&
params
)
{
param_
=
params
;
}
result_type
(
min
)
(
)
const
{
return
a
(
)
;
}
result_type
(
max
)
(
)
const
{
return
b
(
)
;
}
friend
bool
operator
=
=
(
const
uniform_real_distribution
&
a
const
uniform_real_distribution
&
b
)
{
return
a
.
param_
=
=
b
.
param_
;
}
friend
bool
operator
!
=
(
const
uniform_real_distribution
&
a
const
uniform_real_distribution
&
b
)
{
return
a
.
param_
!
=
b
.
param_
;
}
private
:
param_type
param_
;
random_internal
:
:
FastUniformBits
<
uint64_t
>
fast_u64_
;
}
;
template
<
typename
RealType
>
template
<
typename
URBG
>
typename
uniform_real_distribution
<
RealType
>
:
:
result_type
uniform_real_distribution
<
RealType
>
:
:
operator
(
)
(
URBG
&
gen
const
param_type
&
p
)
{
using
random_internal
:
:
GeneratePositiveTag
;
using
random_internal
:
:
GenerateRealFromBits
;
using
real_type
=
absl
:
:
conditional_t
<
std
:
:
is_same
<
RealType
float
>
:
:
value
float
double
>
;
while
(
true
)
{
const
result_type
sample
=
GenerateRealFromBits
<
real_type
GeneratePositiveTag
true
>
(
fast_u64_
(
gen
)
)
;
const
result_type
res
=
p
.
a
(
)
+
(
sample
*
p
.
range_
)
;
if
(
res
<
p
.
b
(
)
|
|
p
.
range_
<
=
0
|
|
!
std
:
:
isfinite
(
p
.
range_
)
)
{
return
res
;
}
}
}
template
<
typename
CharT
typename
Traits
typename
RealType
>
std
:
:
basic_ostream
<
CharT
Traits
>
&
operator
<
<
(
std
:
:
basic_ostream
<
CharT
Traits
>
&
os
const
uniform_real_distribution
<
RealType
>
&
x
)
{
auto
saver
=
random_internal
:
:
make_ostream_state_saver
(
os
)
;
os
.
precision
(
random_internal
:
:
stream_precision_helper
<
RealType
>
:
:
kPrecision
)
;
os
<
<
x
.
a
(
)
<
<
os
.
fill
(
)
<
<
x
.
b
(
)
;
return
os
;
}
template
<
typename
CharT
typename
Traits
typename
RealType
>
std
:
:
basic_istream
<
CharT
Traits
>
&
operator
>
>
(
std
:
:
basic_istream
<
CharT
Traits
>
&
is
uniform_real_distribution
<
RealType
>
&
x
)
{
using
param_type
=
typename
uniform_real_distribution
<
RealType
>
:
:
param_type
;
using
result_type
=
typename
uniform_real_distribution
<
RealType
>
:
:
result_type
;
auto
saver
=
random_internal
:
:
make_istream_state_saver
(
is
)
;
auto
a
=
random_internal
:
:
read_floating_point
<
result_type
>
(
is
)
;
if
(
is
.
fail
(
)
)
return
is
;
auto
b
=
random_internal
:
:
read_floating_point
<
result_type
>
(
is
)
;
if
(
!
is
.
fail
(
)
)
{
x
.
param
(
param_type
(
a
b
)
)
;
}
return
is
;
}
ABSL_NAMESPACE_END
}
#
endif
