#
ifndef
ABSL_RANDOM_POISSON_DISTRIBUTION_H_
#
define
ABSL_RANDOM_POISSON_DISTRIBUTION_H_
#
include
<
cassert
>
#
include
<
cmath
>
#
include
<
istream
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
absl
/
random
/
internal
/
fast_uniform_bits
.
h
"
#
include
"
absl
/
random
/
internal
/
fastmath
.
h
"
#
include
"
absl
/
random
/
internal
/
generate_real
.
h
"
#
include
"
absl
/
random
/
internal
/
iostream_state_saver
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
template
<
typename
IntType
=
int
>
class
poisson_distribution
{
public
:
using
result_type
=
IntType
;
class
param_type
{
public
:
using
distribution_type
=
poisson_distribution
;
explicit
param_type
(
double
mean
=
1
.
0
)
;
double
mean
(
)
const
{
return
mean_
;
}
friend
bool
operator
=
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
a
.
mean_
=
=
b
.
mean_
;
}
friend
bool
operator
!
=
(
const
param_type
&
a
const
param_type
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
friend
class
poisson_distribution
;
double
mean_
;
double
emu_
;
double
lmu_
;
double
s_
;
double
log_k_
;
int
split_
;
static_assert
(
std
:
:
is_integral
<
IntType
>
:
:
value
"
Class
-
template
absl
:
:
poisson_distribution
<
>
must
be
"
"
parameterized
using
an
integral
type
.
"
)
;
}
;
poisson_distribution
(
)
:
poisson_distribution
(
1
.
0
)
{
}
explicit
poisson_distribution
(
double
mean
)
:
param_
(
mean
)
{
}
explicit
poisson_distribution
(
const
param_type
&
p
)
:
param_
(
p
)
{
}
void
reset
(
)
{
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
)
{
return
(
*
this
)
(
g
param_
)
;
}
template
<
typename
URBG
>
result_type
operator
(
)
(
URBG
&
g
const
param_type
&
p
)
;
param_type
param
(
)
const
{
return
param_
;
}
void
param
(
const
param_type
&
p
)
{
param_
=
p
;
}
result_type
(
min
)
(
)
const
{
return
0
;
}
result_type
(
max
)
(
)
const
{
return
(
std
:
:
numeric_limits
<
result_type
>
:
:
max
)
(
)
;
}
double
mean
(
)
const
{
return
param_
.
mean
(
)
;
}
friend
bool
operator
=
=
(
const
poisson_distribution
&
a
const
poisson_distribution
&
b
)
{
return
a
.
param_
=
=
b
.
param_
;
}
friend
bool
operator
!
=
(
const
poisson_distribution
&
a
const
poisson_distribution
&
b
)
{
return
a
.
param_
!
=
b
.
param_
;
}
private
:
param_type
param_
;
random_internal
:
:
FastUniformBits
<
uint64_t
>
fast_u64_
;
}
;
template
<
typename
IntType
>
poisson_distribution
<
IntType
>
:
:
param_type
:
:
param_type
(
double
mean
)
:
mean_
(
mean
)
split_
(
0
)
{
assert
(
mean
>
=
0
)
;
assert
(
mean
<
=
(
std
:
:
numeric_limits
<
result_type
>
:
:
max
)
(
)
)
;
assert
(
mean
<
=
1e10
)
;
if
(
mean_
<
10
)
{
split_
=
1
;
emu_
=
std
:
:
exp
(
-
mean_
)
;
}
else
if
(
mean_
<
=
50
)
{
split_
=
1
+
static_cast
<
int
>
(
mean_
/
10
.
0
)
;
emu_
=
std
:
:
exp
(
-
mean_
/
static_cast
<
double
>
(
split_
)
)
;
}
else
{
constexpr
double
k2E
=
0
.
7357588823428846
;
constexpr
double
kSA
=
0
.
4494580810294493
;
lmu_
=
std
:
:
log
(
mean_
)
;
double
a
=
mean_
+
0
.
5
;
s_
=
kSA
+
std
:
:
sqrt
(
k2E
*
a
)
;
const
double
mode
=
std
:
:
ceil
(
mean_
)
-
1
;
log_k_
=
lmu_
*
mode
-
absl
:
:
random_internal
:
:
StirlingLogFactorial
(
mode
)
;
}
}
template
<
typename
IntType
>
template
<
typename
URBG
>
typename
poisson_distribution
<
IntType
>
:
:
result_type
poisson_distribution
<
IntType
>
:
:
operator
(
)
(
URBG
&
g
const
param_type
&
p
)
{
using
random_internal
:
:
GeneratePositiveTag
;
using
random_internal
:
:
GenerateRealFromBits
;
using
random_internal
:
:
GenerateSignedTag
;
if
(
p
.
split_
!
=
0
)
{
result_type
n
=
0
;
for
(
int
split
=
p
.
split_
;
split
>
0
;
-
-
split
)
{
double
r
=
1
.
0
;
do
{
r
*
=
GenerateRealFromBits
<
double
GeneratePositiveTag
true
>
(
fast_u64_
(
g
)
)
;
+
+
n
;
}
while
(
r
>
p
.
emu_
)
;
-
-
n
;
}
return
n
;
}
const
double
a
=
p
.
mean_
+
0
.
5
;
for
(
;
;
)
{
const
double
u
=
GenerateRealFromBits
<
double
GeneratePositiveTag
false
>
(
fast_u64_
(
g
)
)
;
const
double
v
=
GenerateRealFromBits
<
double
GenerateSignedTag
false
>
(
fast_u64_
(
g
)
)
;
const
double
x
=
std
:
:
floor
(
p
.
s_
*
v
/
u
+
a
)
;
if
(
x
<
0
)
continue
;
const
double
rhs
=
x
*
p
.
lmu_
;
double
s
=
(
x
<
=
1
.
0
)
?
0
.
0
:
(
x
=
=
2
.
0
)
?
0
.
693147180559945
:
absl
:
:
random_internal
:
:
StirlingLogFactorial
(
x
)
;
const
double
lhs
=
2
.
0
*
std
:
:
log
(
u
)
+
p
.
log_k_
+
s
;
if
(
lhs
<
rhs
)
{
return
x
>
(
max
)
(
)
?
(
max
)
(
)
:
static_cast
<
result_type
>
(
x
)
;
}
}
}
template
<
typename
CharT
typename
Traits
typename
IntType
>
std
:
:
basic_ostream
<
CharT
Traits
>
&
operator
<
<
(
std
:
:
basic_ostream
<
CharT
Traits
>
&
os
const
poisson_distribution
<
IntType
>
&
x
)
{
auto
saver
=
random_internal
:
:
make_ostream_state_saver
(
os
)
;
os
.
precision
(
random_internal
:
:
stream_precision_helper
<
double
>
:
:
kPrecision
)
;
os
<
<
x
.
mean
(
)
;
return
os
;
}
template
<
typename
CharT
typename
Traits
typename
IntType
>
std
:
:
basic_istream
<
CharT
Traits
>
&
operator
>
>
(
std
:
:
basic_istream
<
CharT
Traits
>
&
is
poisson_distribution
<
IntType
>
&
x
)
{
using
param_type
=
typename
poisson_distribution
<
IntType
>
:
:
param_type
;
auto
saver
=
random_internal
:
:
make_istream_state_saver
(
is
)
;
double
mean
=
random_internal
:
:
read_floating_point
<
double
>
(
is
)
;
if
(
!
is
.
fail
(
)
)
{
x
.
param
(
param_type
(
mean
)
)
;
}
return
is
;
}
ABSL_NAMESPACE_END
}
#
endif
