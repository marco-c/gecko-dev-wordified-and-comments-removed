#
ifndef
ABSL_BASE_MACROS_H_
#
define
ABSL_BASE_MACROS_H_
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
base
/
port
.
h
"
#
define
ABSL_ARRAYSIZE
(
array
)
\
(
sizeof
(
:
:
absl
:
:
macros_internal
:
:
ArraySizeHelper
(
array
)
)
)
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
macros_internal
{
template
<
typename
T
size_t
N
>
auto
ArraySizeHelper
(
const
T
(
&
array
)
[
N
]
)
-
>
char
(
&
)
[
N
]
;
}
ABSL_NAMESPACE_END
}
#
if
ABSL_HAVE_ATTRIBUTE
(
enable_if
)
#
define
ABSL_BAD_CALL_IF
(
expr
msg
)
\
__attribute__
(
(
enable_if
(
expr
"
Bad
call
trap
"
)
unavailable
(
msg
)
)
)
#
endif
#
if
defined
(
NDEBUG
)
#
define
ABSL_ASSERT
(
expr
)
\
(
false
?
static_cast
<
void
>
(
expr
)
:
static_cast
<
void
>
(
0
)
)
#
else
#
define
ABSL_ASSERT
(
expr
)
\
(
ABSL_PREDICT_TRUE
(
(
expr
)
)
?
static_cast
<
void
>
(
0
)
\
:
[
]
{
assert
(
false
&
&
#
expr
)
;
}
(
)
)
/
/
NOLINT
#
endif
#
if
(
ABSL_HAVE_BUILTIN
(
__builtin_trap
)
&
&
\
ABSL_HAVE_BUILTIN
(
__builtin_unreachable
)
)
|
|
\
(
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
)
#
define
ABSL_INTERNAL_HARDENING_ABORT
(
)
\
do
{
\
__builtin_trap
(
)
;
\
__builtin_unreachable
(
)
;
\
}
while
(
false
)
#
else
#
define
ABSL_INTERNAL_HARDENING_ABORT
(
)
abort
(
)
#
endif
#
if
ABSL_OPTION_HARDENED
=
=
1
&
&
defined
(
NDEBUG
)
#
define
ABSL_HARDENING_ASSERT
(
expr
)
\
(
ABSL_PREDICT_TRUE
(
(
expr
)
)
?
static_cast
<
void
>
(
0
)
\
:
[
]
{
ABSL_INTERNAL_HARDENING_ABORT
(
)
;
}
(
)
)
#
else
#
define
ABSL_HARDENING_ASSERT
(
expr
)
ABSL_ASSERT
(
expr
)
#
endif
#
ifdef
ABSL_HAVE_EXCEPTIONS
#
define
ABSL_INTERNAL_TRY
try
#
define
ABSL_INTERNAL_CATCH_ANY
catch
(
.
.
.
)
#
define
ABSL_INTERNAL_RETHROW
do
{
throw
;
}
while
(
false
)
#
else
#
define
ABSL_INTERNAL_TRY
if
(
true
)
#
define
ABSL_INTERNAL_CATCH_ANY
else
if
(
false
)
#
define
ABSL_INTERNAL_RETHROW
do
{
}
while
(
false
)
#
endif
#
endif
