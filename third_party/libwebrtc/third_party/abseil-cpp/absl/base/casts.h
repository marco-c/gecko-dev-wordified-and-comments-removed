#
ifndef
ABSL_BASE_CASTS_H_
#
define
ABSL_BASE_CASTS_H_
#
include
<
cstring
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
internal
/
identity
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
internal_casts
{
template
<
class
Dest
class
Source
>
struct
is_bitcastable
:
std
:
:
integral_constant
<
bool
sizeof
(
Dest
)
=
=
sizeof
(
Source
)
&
&
type_traits_internal
:
:
is_trivially_copyable
<
Source
>
:
:
value
&
&
type_traits_internal
:
:
is_trivially_copyable
<
Dest
>
:
:
value
&
&
std
:
:
is_default_constructible
<
Dest
>
:
:
value
>
{
}
;
}
template
<
typename
To
>
constexpr
To
implicit_cast
(
typename
absl
:
:
internal
:
:
identity_t
<
To
>
to
)
{
return
to
;
}
template
<
typename
Dest
typename
Source
typename
std
:
:
enable_if
<
internal_casts
:
:
is_bitcastable
<
Dest
Source
>
:
:
value
int
>
:
:
type
=
0
>
inline
Dest
bit_cast
(
const
Source
&
source
)
{
Dest
dest
;
memcpy
(
static_cast
<
void
*
>
(
std
:
:
addressof
(
dest
)
)
static_cast
<
const
void
*
>
(
std
:
:
addressof
(
source
)
)
sizeof
(
dest
)
)
;
return
dest
;
}
template
<
typename
Dest
typename
Source
typename
std
:
:
enable_if
<
!
internal_casts
:
:
is_bitcastable
<
Dest
Source
>
:
:
value
int
>
:
:
type
=
0
>
ABSL_DEPRECATED
(
"
absl
:
:
bit_cast
type
requirements
were
violated
.
Update
the
types
"
"
being
used
such
that
they
are
the
same
size
and
are
both
"
"
TriviallyCopyable
.
"
)
inline
Dest
bit_cast
(
const
Source
&
source
)
{
static_assert
(
sizeof
(
Dest
)
=
=
sizeof
(
Source
)
"
Source
and
destination
types
should
have
equal
sizes
.
"
)
;
Dest
dest
;
memcpy
(
&
dest
&
source
sizeof
(
dest
)
)
;
return
dest
;
}
ABSL_NAMESPACE_END
}
#
endif
