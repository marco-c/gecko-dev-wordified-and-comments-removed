#
ifndef
ABSL_BASE_INTERNAL_LOW_LEVEL_ALLOC_H_
#
define
ABSL_BASE_INTERNAL_LOW_LEVEL_ALLOC_H_
#
include
<
sys
/
types
.
h
>
#
include
<
cstdint
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
ifdef
ABSL_LOW_LEVEL_ALLOC_MISSING
#
error
ABSL_LOW_LEVEL_ALLOC_MISSING
cannot
be
directly
set
#
elif
!
defined
(
ABSL_HAVE_MMAP
)
&
&
!
defined
(
_WIN32
)
#
define
ABSL_LOW_LEVEL_ALLOC_MISSING
1
#
endif
#
ifdef
ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
#
error
ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
cannot
be
directly
set
#
elif
defined
(
_WIN32
)
|
|
defined
(
__asmjs__
)
|
|
defined
(
__wasm__
)
|
|
\
defined
(
__hexagon__
)
#
define
ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
1
#
endif
#
include
<
cstddef
>
#
include
"
absl
/
base
/
port
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
class
LowLevelAlloc
{
public
:
struct
Arena
;
static
void
*
Alloc
(
size_t
request
)
ABSL_ATTRIBUTE_SECTION
(
malloc_hook
)
;
static
void
*
AllocWithArena
(
size_t
request
Arena
*
arena
)
ABSL_ATTRIBUTE_SECTION
(
malloc_hook
)
;
static
void
Free
(
void
*
s
)
ABSL_ATTRIBUTE_SECTION
(
malloc_hook
)
;
enum
{
kCallMallocHook
=
0x0001
#
ifndef
ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
kAsyncSignalSafe
=
0x0002
#
endif
}
;
static
Arena
*
NewArena
(
uint32_t
flags
)
;
static
bool
DeleteArena
(
Arena
*
arena
)
;
static
Arena
*
DefaultArena
(
)
;
private
:
LowLevelAlloc
(
)
;
}
;
}
ABSL_NAMESPACE_END
}
#
endif
