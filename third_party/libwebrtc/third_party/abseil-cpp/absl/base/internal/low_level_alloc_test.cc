#
include
"
absl
/
base
/
internal
/
low_level_alloc
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
thread
>
#
include
<
unordered_map
>
#
include
<
utility
>
#
ifdef
__EMSCRIPTEN__
#
include
<
emscripten
.
h
>
#
endif
#
include
"
absl
/
container
/
node_hash_map
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
namespace
{
#
define
TEST_ASSERT
(
x
)
\
if
(
!
(
x
)
)
{
\
printf
(
"
TEST_ASSERT
(
%
s
)
FAILED
ON
LINE
%
d
\
n
"
#
x
__LINE__
)
;
\
abort
(
)
;
\
}
struct
BlockDesc
{
char
*
ptr
;
int
len
;
int
fill
;
}
;
static
void
CheckBlockDesc
(
const
BlockDesc
&
d
)
{
for
(
int
i
=
0
;
i
!
=
d
.
len
;
i
+
+
)
{
TEST_ASSERT
(
(
d
.
ptr
[
i
]
&
0xff
)
=
=
(
(
d
.
fill
+
i
)
&
0xff
)
)
;
}
}
static
void
RandomizeBlockDesc
(
BlockDesc
*
d
)
{
d
-
>
fill
=
rand
(
)
&
0xff
;
for
(
int
i
=
0
;
i
!
=
d
-
>
len
;
i
+
+
)
{
d
-
>
ptr
[
i
]
=
(
d
-
>
fill
+
i
)
&
0xff
;
}
}
static
bool
using_low_level_alloc
=
false
;
static
void
Test
(
bool
use_new_arena
bool
call_malloc_hook
int
n
)
{
typedef
absl
:
:
node_hash_map
<
int
BlockDesc
>
AllocMap
;
AllocMap
allocated
;
AllocMap
:
:
iterator
it
;
BlockDesc
block_desc
;
int
rnd
;
LowLevelAlloc
:
:
Arena
*
arena
=
nullptr
;
if
(
use_new_arena
)
{
int32_t
flags
=
call_malloc_hook
?
LowLevelAlloc
:
:
kCallMallocHook
:
0
;
arena
=
LowLevelAlloc
:
:
NewArena
(
flags
)
;
}
for
(
int
i
=
0
;
i
!
=
n
;
i
+
+
)
{
if
(
i
!
=
0
&
&
i
%
10000
=
=
0
)
{
printf
(
"
.
"
)
;
fflush
(
stdout
)
;
}
switch
(
rand
(
)
&
1
)
{
case
0
:
using_low_level_alloc
=
true
;
block_desc
.
len
=
rand
(
)
&
0x3fff
;
block_desc
.
ptr
=
reinterpret_cast
<
char
*
>
(
arena
=
=
nullptr
?
LowLevelAlloc
:
:
Alloc
(
block_desc
.
len
)
:
LowLevelAlloc
:
:
AllocWithArena
(
block_desc
.
len
arena
)
)
;
using_low_level_alloc
=
false
;
RandomizeBlockDesc
(
&
block_desc
)
;
rnd
=
rand
(
)
;
it
=
allocated
.
find
(
rnd
)
;
if
(
it
!
=
allocated
.
end
(
)
)
{
CheckBlockDesc
(
it
-
>
second
)
;
using_low_level_alloc
=
true
;
LowLevelAlloc
:
:
Free
(
it
-
>
second
.
ptr
)
;
using_low_level_alloc
=
false
;
it
-
>
second
=
block_desc
;
}
else
{
allocated
[
rnd
]
=
block_desc
;
}
break
;
case
1
:
it
=
allocated
.
begin
(
)
;
if
(
it
!
=
allocated
.
end
(
)
)
{
CheckBlockDesc
(
it
-
>
second
)
;
using_low_level_alloc
=
true
;
LowLevelAlloc
:
:
Free
(
it
-
>
second
.
ptr
)
;
using_low_level_alloc
=
false
;
allocated
.
erase
(
it
)
;
}
break
;
}
}
while
(
(
it
=
allocated
.
begin
(
)
)
!
=
allocated
.
end
(
)
)
{
CheckBlockDesc
(
it
-
>
second
)
;
using_low_level_alloc
=
true
;
LowLevelAlloc
:
:
Free
(
it
-
>
second
.
ptr
)
;
using_low_level_alloc
=
false
;
allocated
.
erase
(
it
)
;
}
if
(
use_new_arena
)
{
TEST_ASSERT
(
LowLevelAlloc
:
:
DeleteArena
(
arena
)
)
;
}
}
static
struct
BeforeMain
{
BeforeMain
(
)
{
Test
(
false
false
50000
)
;
Test
(
true
false
50000
)
;
Test
(
true
true
50000
)
;
}
}
before_main
;
}
}
ABSL_NAMESPACE_END
}
int
main
(
int
argc
char
*
argv
[
]
)
{
printf
(
"
PASS
\
n
"
)
;
#
ifdef
__EMSCRIPTEN__
MAIN_THREAD_EM_ASM
(
{
if
(
ENVIRONMENT_IS_WEB
)
{
if
(
typeof
TEST_FINISH
=
=
=
'
function
'
)
{
TEST_FINISH
(
0
)
;
}
else
{
console
.
error
(
'
Attempted
to
exit
with
status
'
+
0
)
;
console
.
error
(
'
But
TEST_FINSIHED
is
not
a
function
.
'
)
;
}
}
}
0
)
;
#
endif
return
0
;
}
