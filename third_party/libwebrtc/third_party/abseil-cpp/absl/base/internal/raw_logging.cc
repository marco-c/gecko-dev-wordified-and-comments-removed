#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
<
cstdarg
>
#
include
<
cstddef
>
#
include
<
cstdio
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
string
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
atomic_hook
.
h
"
#
include
"
absl
/
base
/
internal
/
errno_saver
.
h
"
#
include
"
absl
/
base
/
log_severity
.
h
"
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
|
|
defined
(
__FreeBSD__
)
|
|
\
defined
(
__Fuchsia__
)
|
|
defined
(
__native_client__
)
|
|
\
defined
(
__OpenBSD__
)
|
|
defined
(
__EMSCRIPTEN__
)
|
|
defined
(
__ASYLO__
)
#
include
<
unistd
.
h
>
#
define
ABSL_HAVE_POSIX_WRITE
1
#
define
ABSL_LOW_LEVEL_WRITE_SUPPORTED
1
#
else
#
undef
ABSL_HAVE_POSIX_WRITE
#
endif
#
if
(
defined
(
__linux__
)
|
|
defined
(
__FreeBSD__
)
|
|
defined
(
__OpenBSD__
)
)
&
&
\
!
defined
(
__ANDROID__
)
#
include
<
sys
/
syscall
.
h
>
#
define
ABSL_HAVE_SYSCALL_WRITE
1
#
define
ABSL_LOW_LEVEL_WRITE_SUPPORTED
1
#
else
#
undef
ABSL_HAVE_SYSCALL_WRITE
#
endif
#
ifdef
_WIN32
#
include
<
io
.
h
>
#
define
ABSL_HAVE_RAW_IO
1
#
define
ABSL_LOW_LEVEL_WRITE_SUPPORTED
1
#
else
#
undef
ABSL_HAVE_RAW_IO
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
raw_logging_internal
{
namespace
{
#
ifdef
ABSL_LOW_LEVEL_WRITE_SUPPORTED
constexpr
char
kTruncated
[
]
=
"
.
.
.
(
message
truncated
)
\
n
"
;
bool
VADoRawLog
(
char
*
*
buf
int
*
size
const
char
*
format
va_list
ap
)
ABSL_PRINTF_ATTRIBUTE
(
3
0
)
;
bool
VADoRawLog
(
char
*
*
buf
int
*
size
const
char
*
format
va_list
ap
)
{
int
n
=
vsnprintf
(
*
buf
*
size
format
ap
)
;
bool
result
=
true
;
if
(
n
<
0
|
|
n
>
*
size
)
{
result
=
false
;
if
(
static_cast
<
size_t
>
(
*
size
)
>
sizeof
(
kTruncated
)
)
{
n
=
*
size
-
sizeof
(
kTruncated
)
;
}
else
{
n
=
0
;
}
}
*
size
-
=
n
;
*
buf
+
=
n
;
return
result
;
}
#
endif
constexpr
int
kLogBufSize
=
3000
;
bool
DoRawLog
(
char
*
*
buf
int
*
size
const
char
*
format
.
.
.
)
ABSL_PRINTF_ATTRIBUTE
(
3
4
)
;
bool
DoRawLog
(
char
*
*
buf
int
*
size
const
char
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
int
n
=
vsnprintf
(
*
buf
*
size
format
ap
)
;
va_end
(
ap
)
;
if
(
n
<
0
|
|
n
>
*
size
)
return
false
;
*
size
-
=
n
;
*
buf
+
=
n
;
return
true
;
}
bool
DefaultLogFilterAndPrefix
(
absl
:
:
LogSeverity
const
char
*
file
int
line
char
*
*
buf
int
*
buf_size
)
{
DoRawLog
(
buf
buf_size
"
[
%
s
:
%
d
]
RAW
:
"
file
line
)
;
return
true
;
}
ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES
absl
:
:
base_internal
:
:
AtomicHook
<
LogFilterAndPrefixHook
>
log_filter_and_prefix_hook
(
DefaultLogFilterAndPrefix
)
;
ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES
absl
:
:
base_internal
:
:
AtomicHook
<
AbortHook
>
abort_hook
;
void
RawLogVA
(
absl
:
:
LogSeverity
severity
const
char
*
file
int
line
const
char
*
format
va_list
ap
)
ABSL_PRINTF_ATTRIBUTE
(
4
0
)
;
void
RawLogVA
(
absl
:
:
LogSeverity
severity
const
char
*
file
int
line
const
char
*
format
va_list
ap
)
{
char
buffer
[
kLogBufSize
]
;
char
*
buf
=
buffer
;
int
size
=
sizeof
(
buffer
)
;
#
ifdef
ABSL_LOW_LEVEL_WRITE_SUPPORTED
bool
enabled
=
true
;
#
else
bool
enabled
=
false
;
#
endif
#
ifdef
ABSL_MIN_LOG_LEVEL
if
(
severity
<
static_cast
<
absl
:
:
LogSeverity
>
(
ABSL_MIN_LOG_LEVEL
)
&
&
severity
<
absl
:
:
LogSeverity
:
:
kFatal
)
{
enabled
=
false
;
}
#
endif
enabled
=
log_filter_and_prefix_hook
(
severity
file
line
&
buf
&
size
)
;
const
char
*
const
prefix_end
=
buf
;
#
ifdef
ABSL_LOW_LEVEL_WRITE_SUPPORTED
if
(
enabled
)
{
bool
no_chop
=
VADoRawLog
(
&
buf
&
size
format
ap
)
;
if
(
no_chop
)
{
DoRawLog
(
&
buf
&
size
"
\
n
"
)
;
}
else
{
DoRawLog
(
&
buf
&
size
"
%
s
"
kTruncated
)
;
}
AsyncSignalSafeWriteToStderr
(
buffer
strlen
(
buffer
)
)
;
}
#
else
static_cast
<
void
>
(
format
)
;
static_cast
<
void
>
(
ap
)
;
static_cast
<
void
>
(
enabled
)
;
#
endif
if
(
severity
=
=
absl
:
:
LogSeverity
:
:
kFatal
)
{
abort_hook
(
file
line
buffer
prefix_end
buffer
+
kLogBufSize
)
;
abort
(
)
;
}
}
void
DefaultInternalLog
(
absl
:
:
LogSeverity
severity
const
char
*
file
int
line
const
std
:
:
string
&
message
)
{
RawLog
(
severity
file
line
"
%
.
*
s
"
static_cast
<
int
>
(
message
.
size
(
)
)
message
.
data
(
)
)
;
}
}
void
AsyncSignalSafeWriteToStderr
(
const
char
*
s
size_t
len
)
{
absl
:
:
base_internal
:
:
ErrnoSaver
errno_saver
;
#
if
defined
(
ABSL_HAVE_SYSCALL_WRITE
)
syscall
(
SYS_write
STDERR_FILENO
s
len
)
;
#
elif
defined
(
ABSL_HAVE_POSIX_WRITE
)
write
(
STDERR_FILENO
s
len
)
;
#
elif
defined
(
ABSL_HAVE_RAW_IO
)
_write
(
2
s
len
)
;
#
else
(
void
)
s
;
(
void
)
len
;
#
endif
}
void
RawLog
(
absl
:
:
LogSeverity
severity
const
char
*
file
int
line
const
char
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
RawLogVA
(
severity
file
line
format
ap
)
;
va_end
(
ap
)
;
}
bool
RawLoggingFullySupported
(
)
{
#
ifdef
ABSL_LOW_LEVEL_WRITE_SUPPORTED
return
true
;
#
else
return
false
;
#
endif
}
ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES
ABSL_DLL
absl
:
:
base_internal
:
:
AtomicHook
<
InternalLogFunction
>
internal_log_function
(
DefaultInternalLog
)
;
void
RegisterLogFilterAndPrefixHook
(
LogFilterAndPrefixHook
func
)
{
log_filter_and_prefix_hook
.
Store
(
func
)
;
}
void
RegisterAbortHook
(
AbortHook
func
)
{
abort_hook
.
Store
(
func
)
;
}
void
RegisterInternalLogFunction
(
InternalLogFunction
func
)
{
internal_log_function
.
Store
(
func
)
;
}
}
ABSL_NAMESPACE_END
}
