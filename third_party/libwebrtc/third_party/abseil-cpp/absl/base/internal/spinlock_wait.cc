#
include
<
atomic
>
#
include
<
cstdint
>
#
include
"
absl
/
base
/
internal
/
spinlock_wait
.
h
"
#
if
defined
(
_WIN32
)
#
include
"
absl
/
base
/
internal
/
spinlock_win32
.
inc
"
#
elif
defined
(
__linux__
)
#
include
"
absl
/
base
/
internal
/
spinlock_linux
.
inc
"
#
elif
defined
(
__akaros__
)
#
include
"
absl
/
base
/
internal
/
spinlock_akaros
.
inc
"
#
else
#
include
"
absl
/
base
/
internal
/
spinlock_posix
.
inc
"
#
endif
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
uint32_t
SpinLockWait
(
std
:
:
atomic
<
uint32_t
>
*
w
int
n
const
SpinLockWaitTransition
trans
[
]
base_internal
:
:
SchedulingMode
scheduling_mode
)
{
int
loop
=
0
;
for
(
;
;
)
{
uint32_t
v
=
w
-
>
load
(
std
:
:
memory_order_acquire
)
;
int
i
;
for
(
i
=
0
;
i
!
=
n
&
&
v
!
=
trans
[
i
]
.
from
;
i
+
+
)
{
}
if
(
i
=
=
n
)
{
SpinLockDelay
(
w
v
+
+
loop
scheduling_mode
)
;
}
else
if
(
trans
[
i
]
.
to
=
=
v
|
|
w
-
>
compare_exchange_strong
(
v
trans
[
i
]
.
to
std
:
:
memory_order_acquire
std
:
:
memory_order_relaxed
)
)
{
if
(
trans
[
i
]
.
done
)
return
v
;
}
}
}
static
std
:
:
atomic
<
uint64_t
>
delay_rand
;
int
SpinLockSuggestedDelayNS
(
int
loop
)
{
uint64_t
r
=
delay_rand
.
load
(
std
:
:
memory_order_relaxed
)
;
r
=
0x5deece66dLL
*
r
+
0xb
;
delay_rand
.
store
(
r
std
:
:
memory_order_relaxed
)
;
if
(
loop
<
0
|
|
loop
>
32
)
{
loop
=
32
;
}
const
int
kMinDelay
=
128
<
<
10
;
int
delay
=
kMinDelay
<
<
(
loop
/
8
)
;
return
delay
|
(
(
delay
-
1
)
&
static_cast
<
int
>
(
r
)
)
;
}
}
ABSL_NAMESPACE_END
}
