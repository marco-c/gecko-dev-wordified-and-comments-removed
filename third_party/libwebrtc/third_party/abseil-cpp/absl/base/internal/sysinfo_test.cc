#
include
"
absl
/
base
/
internal
/
sysinfo
.
h
"
#
ifndef
_WIN32
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
<
thread
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
synchronization
/
barrier
.
h
"
#
include
"
absl
/
synchronization
/
mutex
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
namespace
{
TEST
(
SysinfoTest
NumCPUs
)
{
EXPECT_NE
(
NumCPUs
(
)
0
)
<
<
"
NumCPUs
(
)
should
not
have
the
default
value
of
0
"
;
}
#
if
!
(
defined
(
__linux
)
&
&
(
defined
(
__ppc64__
)
|
|
defined
(
__PPC64__
)
)
)
TEST
(
SysinfoTest
NominalCPUFrequency
)
{
#
if
defined
(
__linux__
)
&
&
\
(
defined
(
__aarch64__
)
|
|
defined
(
__hppa__
)
|
|
defined
(
__mips__
)
|
|
\
defined
(
__riscv
)
|
|
defined
(
__s390x__
)
)
|
|
\
defined
(
__EMSCRIPTEN__
)
EXPECT_EQ
(
NominalCPUFrequency
(
)
1
.
0
)
<
<
"
CPU
frequency
detection
was
fixed
!
Please
update
unittest
.
"
;
#
else
EXPECT_GE
(
NominalCPUFrequency
(
)
1000
.
0
)
<
<
"
NominalCPUFrequency
(
)
did
not
return
a
reasonable
value
"
;
#
endif
}
#
endif
TEST
(
SysinfoTest
GetTID
)
{
EXPECT_EQ
(
GetTID
(
)
GetTID
(
)
)
;
#
ifdef
__native_client__
return
;
#
endif
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
constexpr
int
kNumThreads
=
10
;
Barrier
all_threads_done
(
kNumThreads
)
;
std
:
:
vector
<
std
:
:
thread
>
threads
;
Mutex
mutex
;
std
:
:
unordered_set
<
pid_t
>
tids
;
for
(
int
j
=
0
;
j
<
kNumThreads
;
+
+
j
)
{
threads
.
push_back
(
std
:
:
thread
(
[
&
]
(
)
{
pid_t
id
=
GetTID
(
)
;
{
MutexLock
lock
(
&
mutex
)
;
ASSERT_TRUE
(
tids
.
find
(
id
)
=
=
tids
.
end
(
)
)
;
tids
.
insert
(
id
)
;
}
all_threads_done
.
Block
(
)
;
}
)
)
;
}
for
(
auto
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
}
}
#
ifdef
__linux__
TEST
(
SysinfoTest
LinuxGetTID
)
{
EXPECT_EQ
(
GetTID
(
)
getpid
(
)
)
;
}
#
endif
}
}
ABSL_NAMESPACE_END
}
