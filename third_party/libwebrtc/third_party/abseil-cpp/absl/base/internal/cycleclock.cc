#
include
"
absl
/
base
/
internal
/
cycleclock
.
h
"
#
include
<
atomic
>
#
include
<
chrono
>
#
include
"
absl
/
base
/
internal
/
unscaledcycleclock
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
#
if
ABSL_USE_UNSCALED_CYCLECLOCK
namespace
{
#
ifdef
NDEBUG
#
ifdef
ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY
static
constexpr
int32_t
kShift
=
1
;
#
else
static
constexpr
int32_t
kShift
=
0
;
#
endif
#
else
static
constexpr
int32_t
kShift
=
2
;
#
endif
static
constexpr
double
kFrequencyScale
=
1
.
0
/
(
1
<
<
kShift
)
;
static
std
:
:
atomic
<
CycleClockSourceFunc
>
cycle_clock_source
;
CycleClockSourceFunc
LoadCycleClockSource
(
)
{
if
(
cycle_clock_source
.
load
(
std
:
:
memory_order_relaxed
)
=
=
nullptr
)
{
return
nullptr
;
}
return
cycle_clock_source
.
load
(
std
:
:
memory_order_acquire
)
;
}
}
int64_t
CycleClock
:
:
Now
(
)
{
auto
fn
=
LoadCycleClockSource
(
)
;
if
(
fn
=
=
nullptr
)
{
return
base_internal
:
:
UnscaledCycleClock
:
:
Now
(
)
>
>
kShift
;
}
return
fn
(
)
>
>
kShift
;
}
double
CycleClock
:
:
Frequency
(
)
{
return
kFrequencyScale
*
base_internal
:
:
UnscaledCycleClock
:
:
Frequency
(
)
;
}
void
CycleClockSource
:
:
Register
(
CycleClockSourceFunc
source
)
{
cycle_clock_source
.
store
(
source
std
:
:
memory_order_release
)
;
}
#
else
int64_t
CycleClock
:
:
Now
(
)
{
return
std
:
:
chrono
:
:
duration_cast
<
std
:
:
chrono
:
:
nanoseconds
>
(
std
:
:
chrono
:
:
steady_clock
:
:
now
(
)
.
time_since_epoch
(
)
)
.
count
(
)
;
}
double
CycleClock
:
:
Frequency
(
)
{
return
1e9
;
}
#
endif
}
ABSL_NAMESPACE_END
}
