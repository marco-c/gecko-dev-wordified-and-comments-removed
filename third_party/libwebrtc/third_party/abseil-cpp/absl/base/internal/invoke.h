#
ifndef
ABSL_BASE_INTERNAL_INVOKE_H_
#
define
ABSL_BASE_INTERNAL_INVOKE_H_
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
template
<
typename
Derived
>
struct
StrippedAccept
{
template
<
typename
.
.
.
Args
>
struct
Accept
:
Derived
:
:
template
AcceptImpl
<
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
Args
>
:
:
type
>
:
:
type
.
.
.
>
{
}
;
}
;
struct
MemFunAndRef
:
StrippedAccept
<
MemFunAndRef
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
MemFunType
typename
C
typename
Obj
typename
.
.
.
Args
>
struct
AcceptImpl
<
MemFunType
C
:
:
*
Obj
Args
.
.
.
>
:
std
:
:
integral_constant
<
bool
std
:
:
is_base_of
<
C
Obj
>
:
:
value
&
&
absl
:
:
is_function
<
MemFunType
>
:
:
value
>
{
}
;
template
<
typename
MemFun
typename
Obj
typename
.
.
.
Args
>
static
decltype
(
(
std
:
:
declval
<
Obj
>
(
)
.
*
std
:
:
declval
<
MemFun
>
(
)
)
(
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
Invoke
(
MemFun
&
&
mem_fun
Obj
&
&
obj
Args
&
&
.
.
.
args
)
{
return
(
std
:
:
forward
<
Obj
>
(
obj
)
.
*
std
:
:
forward
<
MemFun
>
(
mem_fun
)
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
struct
MemFunAndPtr
:
StrippedAccept
<
MemFunAndPtr
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
MemFunType
typename
C
typename
Ptr
typename
.
.
.
Args
>
struct
AcceptImpl
<
MemFunType
C
:
:
*
Ptr
Args
.
.
.
>
:
std
:
:
integral_constant
<
bool
!
std
:
:
is_base_of
<
C
Ptr
>
:
:
value
&
&
absl
:
:
is_function
<
MemFunType
>
:
:
value
>
{
}
;
template
<
typename
MemFun
typename
Ptr
typename
.
.
.
Args
>
static
decltype
(
(
(
*
std
:
:
declval
<
Ptr
>
(
)
)
.
*
std
:
:
declval
<
MemFun
>
(
)
)
(
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
Invoke
(
MemFun
&
&
mem_fun
Ptr
&
&
ptr
Args
&
&
.
.
.
args
)
{
return
(
(
*
std
:
:
forward
<
Ptr
>
(
ptr
)
)
.
*
std
:
:
forward
<
MemFun
>
(
mem_fun
)
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
struct
DataMemAndRef
:
StrippedAccept
<
DataMemAndRef
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
C
typename
Obj
>
struct
AcceptImpl
<
R
C
:
:
*
Obj
>
:
std
:
:
integral_constant
<
bool
std
:
:
is_base_of
<
C
Obj
>
:
:
value
&
&
!
absl
:
:
is_function
<
R
>
:
:
value
>
{
}
;
template
<
typename
DataMem
typename
Ref
>
static
decltype
(
std
:
:
declval
<
Ref
>
(
)
.
*
std
:
:
declval
<
DataMem
>
(
)
)
Invoke
(
DataMem
&
&
data_mem
Ref
&
&
ref
)
{
return
std
:
:
forward
<
Ref
>
(
ref
)
.
*
std
:
:
forward
<
DataMem
>
(
data_mem
)
;
}
}
;
struct
DataMemAndPtr
:
StrippedAccept
<
DataMemAndPtr
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
C
typename
Ptr
>
struct
AcceptImpl
<
R
C
:
:
*
Ptr
>
:
std
:
:
integral_constant
<
bool
!
std
:
:
is_base_of
<
C
Ptr
>
:
:
value
&
&
!
absl
:
:
is_function
<
R
>
:
:
value
>
{
}
;
template
<
typename
DataMem
typename
Ptr
>
static
decltype
(
(
*
std
:
:
declval
<
Ptr
>
(
)
)
.
*
std
:
:
declval
<
DataMem
>
(
)
)
Invoke
(
DataMem
&
&
data_mem
Ptr
&
&
ptr
)
{
return
(
*
std
:
:
forward
<
Ptr
>
(
ptr
)
)
.
*
std
:
:
forward
<
DataMem
>
(
data_mem
)
;
}
}
;
struct
Callable
{
template
<
typename
F
typename
.
.
.
Args
>
static
decltype
(
std
:
:
declval
<
F
>
(
)
(
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
Invoke
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
std
:
:
forward
<
F
>
(
f
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
.
.
.
Args
>
struct
Invoker
{
typedef
typename
std
:
:
conditional
<
MemFunAndRef
:
:
Accept
<
Args
.
.
.
>
:
:
value
MemFunAndRef
typename
std
:
:
conditional
<
MemFunAndPtr
:
:
Accept
<
Args
.
.
.
>
:
:
value
MemFunAndPtr
typename
std
:
:
conditional
<
DataMemAndRef
:
:
Accept
<
Args
.
.
.
>
:
:
value
DataMemAndRef
typename
std
:
:
conditional
<
DataMemAndPtr
:
:
Accept
<
Args
.
.
.
>
:
:
value
DataMemAndPtr
Callable
>
:
:
type
>
:
:
type
>
:
:
type
>
:
:
type
type
;
}
;
template
<
typename
F
typename
.
.
.
Args
>
using
invoke_result_t
=
decltype
(
Invoker
<
F
Args
.
.
.
>
:
:
type
:
:
Invoke
(
std
:
:
declval
<
F
>
(
)
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
;
template
<
typename
F
typename
.
.
.
Args
>
invoke_result_t
<
F
Args
.
.
.
>
invoke
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
Invoker
<
F
Args
.
.
.
>
:
:
type
:
:
Invoke
(
std
:
:
forward
<
F
>
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
