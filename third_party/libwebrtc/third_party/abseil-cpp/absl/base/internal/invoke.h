#
ifndef
ABSL_BASE_INTERNAL_INVOKE_H_
#
define
ABSL_BASE_INTERNAL_INVOKE_H_
#
include
"
absl
/
base
/
config
.
h
"
#
if
ABSL_INTERNAL_CPLUSPLUS_LANG
>
=
201703L
#
include
<
functional
>
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
using
std
:
:
invoke
;
using
std
:
:
invoke_result_t
;
using
std
:
:
is_invocable_r
;
}
ABSL_NAMESPACE_END
}
#
else
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
meta
/
type_traits
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
template
<
typename
Derived
>
struct
StrippedAccept
{
template
<
typename
.
.
.
Args
>
struct
Accept
:
Derived
:
:
template
AcceptImpl
<
typename
std
:
:
remove_cv
<
typename
std
:
:
remove_reference
<
Args
>
:
:
type
>
:
:
type
.
.
.
>
{
}
;
}
;
struct
MemFunAndRef
:
StrippedAccept
<
MemFunAndRef
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
MemFunType
typename
C
typename
Obj
typename
.
.
.
Args
>
struct
AcceptImpl
<
MemFunType
C
:
:
*
Obj
Args
.
.
.
>
:
std
:
:
integral_constant
<
bool
std
:
:
is_base_of
<
C
Obj
>
:
:
value
&
&
absl
:
:
is_function
<
MemFunType
>
:
:
value
>
{
}
;
template
<
typename
MemFun
typename
Obj
typename
.
.
.
Args
>
static
decltype
(
(
std
:
:
declval
<
Obj
>
(
)
.
*
std
:
:
declval
<
MemFun
>
(
)
)
(
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
Invoke
(
MemFun
&
&
mem_fun
Obj
&
&
obj
Args
&
&
.
.
.
args
)
{
#
if
ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION
(
11
0
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Warray
-
bounds
"
#
pragma
GCC
diagnostic
ignored
"
-
Wmaybe
-
uninitialized
"
#
endif
return
(
std
:
:
forward
<
Obj
>
(
obj
)
.
*
std
:
:
forward
<
MemFun
>
(
mem_fun
)
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
#
if
ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION
(
11
0
)
#
pragma
GCC
diagnostic
pop
#
endif
}
}
;
struct
MemFunAndPtr
:
StrippedAccept
<
MemFunAndPtr
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
MemFunType
typename
C
typename
Ptr
typename
.
.
.
Args
>
struct
AcceptImpl
<
MemFunType
C
:
:
*
Ptr
Args
.
.
.
>
:
std
:
:
integral_constant
<
bool
!
std
:
:
is_base_of
<
C
Ptr
>
:
:
value
&
&
absl
:
:
is_function
<
MemFunType
>
:
:
value
>
{
}
;
template
<
typename
MemFun
typename
Ptr
typename
.
.
.
Args
>
static
decltype
(
(
(
*
std
:
:
declval
<
Ptr
>
(
)
)
.
*
std
:
:
declval
<
MemFun
>
(
)
)
(
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
Invoke
(
MemFun
&
&
mem_fun
Ptr
&
&
ptr
Args
&
&
.
.
.
args
)
{
return
(
(
*
std
:
:
forward
<
Ptr
>
(
ptr
)
)
.
*
std
:
:
forward
<
MemFun
>
(
mem_fun
)
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
struct
DataMemAndRef
:
StrippedAccept
<
DataMemAndRef
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
C
typename
Obj
>
struct
AcceptImpl
<
R
C
:
:
*
Obj
>
:
std
:
:
integral_constant
<
bool
std
:
:
is_base_of
<
C
Obj
>
:
:
value
&
&
!
absl
:
:
is_function
<
R
>
:
:
value
>
{
}
;
template
<
typename
DataMem
typename
Ref
>
static
decltype
(
std
:
:
declval
<
Ref
>
(
)
.
*
std
:
:
declval
<
DataMem
>
(
)
)
Invoke
(
DataMem
&
&
data_mem
Ref
&
&
ref
)
{
return
std
:
:
forward
<
Ref
>
(
ref
)
.
*
std
:
:
forward
<
DataMem
>
(
data_mem
)
;
}
}
;
struct
DataMemAndPtr
:
StrippedAccept
<
DataMemAndPtr
>
{
template
<
typename
.
.
.
Args
>
struct
AcceptImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
C
typename
Ptr
>
struct
AcceptImpl
<
R
C
:
:
*
Ptr
>
:
std
:
:
integral_constant
<
bool
!
std
:
:
is_base_of
<
C
Ptr
>
:
:
value
&
&
!
absl
:
:
is_function
<
R
>
:
:
value
>
{
}
;
template
<
typename
DataMem
typename
Ptr
>
static
decltype
(
(
*
std
:
:
declval
<
Ptr
>
(
)
)
.
*
std
:
:
declval
<
DataMem
>
(
)
)
Invoke
(
DataMem
&
&
data_mem
Ptr
&
&
ptr
)
{
return
(
*
std
:
:
forward
<
Ptr
>
(
ptr
)
)
.
*
std
:
:
forward
<
DataMem
>
(
data_mem
)
;
}
}
;
struct
Callable
{
template
<
typename
F
typename
.
.
.
Args
>
static
decltype
(
std
:
:
declval
<
F
>
(
)
(
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
Invoke
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
std
:
:
forward
<
F
>
(
f
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
.
.
.
Args
>
struct
Invoker
{
typedef
typename
std
:
:
conditional
<
MemFunAndRef
:
:
Accept
<
Args
.
.
.
>
:
:
value
MemFunAndRef
typename
std
:
:
conditional
<
MemFunAndPtr
:
:
Accept
<
Args
.
.
.
>
:
:
value
MemFunAndPtr
typename
std
:
:
conditional
<
DataMemAndRef
:
:
Accept
<
Args
.
.
.
>
:
:
value
DataMemAndRef
typename
std
:
:
conditional
<
DataMemAndPtr
:
:
Accept
<
Args
.
.
.
>
:
:
value
DataMemAndPtr
Callable
>
:
:
type
>
:
:
type
>
:
:
type
>
:
:
type
type
;
}
;
template
<
typename
F
typename
.
.
.
Args
>
using
invoke_result_t
=
decltype
(
Invoker
<
F
Args
.
.
.
>
:
:
type
:
:
Invoke
(
std
:
:
declval
<
F
>
(
)
std
:
:
declval
<
Args
>
(
)
.
.
.
)
)
;
template
<
typename
F
typename
.
.
.
Args
>
invoke_result_t
<
F
Args
.
.
.
>
invoke
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
Invoker
<
F
Args
.
.
.
>
:
:
type
:
:
Invoke
(
std
:
:
forward
<
F
>
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
AlwaysVoid
typename
typename
typename
.
.
.
>
struct
IsInvocableRImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
F
typename
.
.
.
Args
>
struct
IsInvocableRImpl
<
absl
:
:
void_t
<
absl
:
:
base_internal
:
:
invoke_result_t
<
F
Args
.
.
.
>
>
R
F
Args
.
.
.
>
:
std
:
:
integral_constant
<
bool
std
:
:
is_convertible
<
absl
:
:
base_internal
:
:
invoke_result_t
<
F
Args
.
.
.
>
R
>
:
:
value
|
|
std
:
:
is_void
<
R
>
:
:
value
>
{
}
;
template
<
typename
R
typename
F
typename
.
.
.
Args
>
using
is_invocable_r
=
IsInvocableRImpl
<
void
R
F
Args
.
.
.
>
;
}
ABSL_NAMESPACE_END
}
#
endif
#
endif
