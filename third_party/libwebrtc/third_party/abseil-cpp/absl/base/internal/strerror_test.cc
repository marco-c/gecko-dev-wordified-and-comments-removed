#
include
"
absl
/
base
/
internal
/
strerror
.
h
"
#
include
<
atomic
>
#
include
<
cerrno
>
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
<
string
>
#
include
<
thread
>
#
include
<
vector
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
absl
/
strings
/
match
.
h
"
namespace
{
using
:
:
testing
:
:
AnyOf
;
using
:
:
testing
:
:
Eq
;
TEST
(
StrErrorTest
ValidErrorCode
)
{
errno
=
ERANGE
;
EXPECT_THAT
(
absl
:
:
base_internal
:
:
StrError
(
EDOM
)
Eq
(
strerror
(
EDOM
)
)
)
;
EXPECT_THAT
(
errno
Eq
(
ERANGE
)
)
;
}
TEST
(
StrErrorTest
InvalidErrorCode
)
{
errno
=
ERANGE
;
EXPECT_THAT
(
absl
:
:
base_internal
:
:
StrError
(
-
1
)
AnyOf
(
Eq
(
"
No
error
information
"
)
Eq
(
"
Unknown
error
-
1
"
)
)
)
;
EXPECT_THAT
(
errno
Eq
(
ERANGE
)
)
;
}
TEST
(
StrErrorTest
MultipleThreads
)
{
const
int
kNumCodes
=
1000
;
std
:
:
vector
<
std
:
:
string
>
expected_strings
(
kNumCodes
)
;
for
(
int
i
=
0
;
i
<
kNumCodes
;
+
+
i
)
{
expected_strings
[
i
]
=
strerror
(
i
)
;
}
std
:
:
atomic_int
counter
(
0
)
;
auto
thread_fun
=
[
&
]
(
)
{
for
(
int
i
=
0
;
i
<
kNumCodes
;
+
+
i
)
{
+
+
counter
;
errno
=
ERANGE
;
const
std
:
:
string
value
=
absl
:
:
base_internal
:
:
StrError
(
i
)
;
int
check_err
=
errno
;
EXPECT_THAT
(
check_err
Eq
(
ERANGE
)
)
;
if
(
!
absl
:
:
StartsWith
(
value
"
Unknown
error
"
)
)
{
EXPECT_THAT
(
value
Eq
(
expected_strings
[
i
]
)
)
;
}
}
}
;
const
int
kNumThreads
=
100
;
std
:
:
vector
<
std
:
:
thread
>
threads
;
for
(
int
i
=
0
;
i
<
kNumThreads
;
+
+
i
)
{
threads
.
push_back
(
std
:
:
thread
(
thread_fun
)
)
;
}
for
(
auto
&
thread
:
threads
)
{
thread
.
join
(
)
;
}
EXPECT_THAT
(
counter
Eq
(
kNumThreads
*
kNumCodes
)
)
;
}
}
