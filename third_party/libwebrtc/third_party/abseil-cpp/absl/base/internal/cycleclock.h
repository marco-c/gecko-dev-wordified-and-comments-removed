#
ifndef
ABSL_BASE_INTERNAL_CYCLECLOCK_H_
#
define
ABSL_BASE_INTERNAL_CYCLECLOCK_H_
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
unscaledcycleclock
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
base_internal
{
using
CycleClockSourceFunc
=
int64_t
(
*
)
(
)
;
class
CycleClock
{
public
:
static
int64_t
Now
(
)
;
static
double
Frequency
(
)
;
private
:
#
if
ABSL_USE_UNSCALED_CYCLECLOCK
static
CycleClockSourceFunc
LoadCycleClockSource
(
)
;
#
ifdef
NDEBUG
#
ifdef
ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY
static
constexpr
int32_t
kShift
=
1
;
#
else
static
constexpr
int32_t
kShift
=
0
;
#
endif
#
else
static
constexpr
int32_t
kShift
=
2
;
#
endif
static
constexpr
double
kFrequencyScale
=
1
.
0
/
(
1
<
<
kShift
)
;
ABSL_CONST_INIT
static
std
:
:
atomic
<
CycleClockSourceFunc
>
cycle_clock_source_
;
#
endif
CycleClock
(
)
=
delete
;
CycleClock
(
const
CycleClock
&
)
=
delete
;
CycleClock
&
operator
=
(
const
CycleClock
&
)
=
delete
;
friend
class
CycleClockSource
;
}
;
class
CycleClockSource
{
private
:
static
void
Register
(
CycleClockSourceFunc
source
)
;
}
;
#
if
ABSL_USE_UNSCALED_CYCLECLOCK
inline
CycleClockSourceFunc
CycleClock
:
:
LoadCycleClockSource
(
)
{
#
if
!
defined
(
__x86_64__
)
if
(
cycle_clock_source_
.
load
(
std
:
:
memory_order_relaxed
)
=
=
nullptr
)
{
return
nullptr
;
}
#
endif
return
cycle_clock_source_
.
load
(
std
:
:
memory_order_acquire
)
;
}
#
ifndef
_WIN32
inline
int64_t
CycleClock
:
:
Now
(
)
{
auto
fn
=
LoadCycleClockSource
(
)
;
if
(
fn
=
=
nullptr
)
{
return
base_internal
:
:
UnscaledCycleClock
:
:
Now
(
)
>
>
kShift
;
}
return
fn
(
)
>
>
kShift
;
}
#
endif
inline
double
CycleClock
:
:
Frequency
(
)
{
return
kFrequencyScale
*
base_internal
:
:
UnscaledCycleClock
:
:
Frequency
(
)
;
}
#
endif
}
ABSL_NAMESPACE_END
}
#
endif
