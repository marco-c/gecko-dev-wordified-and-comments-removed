#
ifndef
ABSL_BASE_INTERNAL_LOW_LEVEL_SCHEDULING_H_
#
define
ABSL_BASE_INTERNAL_LOW_LEVEL_SCHEDULING_H_
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
internal
/
scheduling_mode
.
h
"
#
include
"
absl
/
base
/
macros
.
h
"
extern
"
C
"
bool
__google_disable_rescheduling
(
void
)
;
extern
"
C
"
void
__google_enable_rescheduling
(
bool
disable_result
)
;
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
CondVar
;
class
Mutex
;
namespace
synchronization_internal
{
int
MutexDelay
(
int32_t
c
int
mode
)
;
}
namespace
base_internal
{
class
SchedulingHelper
;
class
SpinLock
;
class
SchedulingGuard
{
public
:
static
bool
ReschedulingIsAllowed
(
)
;
SchedulingGuard
(
const
SchedulingGuard
&
)
=
delete
;
SchedulingGuard
&
operator
=
(
const
SchedulingGuard
&
)
=
delete
;
private
:
static
bool
DisableRescheduling
(
)
;
static
void
EnableRescheduling
(
bool
disable_result
)
;
struct
ScopedDisable
{
ScopedDisable
(
)
{
disabled
=
SchedulingGuard
:
:
DisableRescheduling
(
)
;
}
~
ScopedDisable
(
)
{
SchedulingGuard
:
:
EnableRescheduling
(
disabled
)
;
}
bool
disabled
;
}
;
class
ScopedEnable
{
public
:
ScopedEnable
(
)
;
~
ScopedEnable
(
)
;
private
:
int
scheduling_disabled_depth_
;
}
;
friend
class
absl
:
:
CondVar
;
friend
class
absl
:
:
Mutex
;
friend
class
SchedulingHelper
;
friend
class
SpinLock
;
friend
int
absl
:
:
synchronization_internal
:
:
MutexDelay
(
int32_t
c
int
mode
)
;
}
;
inline
bool
SchedulingGuard
:
:
ReschedulingIsAllowed
(
)
{
return
false
;
}
inline
bool
SchedulingGuard
:
:
DisableRescheduling
(
)
{
return
false
;
}
inline
void
SchedulingGuard
:
:
EnableRescheduling
(
bool
)
{
return
;
}
inline
SchedulingGuard
:
:
ScopedEnable
:
:
ScopedEnable
(
)
:
scheduling_disabled_depth_
(
0
)
{
}
inline
SchedulingGuard
:
:
ScopedEnable
:
:
~
ScopedEnable
(
)
{
ABSL_RAW_CHECK
(
scheduling_disabled_depth_
=
=
0
"
disable
unused
warning
"
)
;
}
}
ABSL_NAMESPACE_END
}
#
endif
