#
ifndef
ABSL_TIME_TIME_H_
#
define
ABSL_TIME_TIME_H_
#
if
!
defined
(
_MSC_VER
)
#
include
<
sys
/
time
.
h
>
#
else
struct
timeval
;
#
endif
#
include
<
chrono
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
ctime
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
base
/
macros
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
time
/
civil_time
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
time_zone
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
class
Duration
;
class
Time
;
class
TimeZone
;
namespace
time_internal
{
int64_t
IDivDuration
(
bool
satq
Duration
num
Duration
den
Duration
*
rem
)
;
constexpr
Time
FromUnixDuration
(
Duration
d
)
;
constexpr
Duration
ToUnixDuration
(
Time
t
)
;
constexpr
int64_t
GetRepHi
(
Duration
d
)
;
constexpr
uint32_t
GetRepLo
(
Duration
d
)
;
constexpr
Duration
MakeDuration
(
int64_t
hi
uint32_t
lo
)
;
constexpr
Duration
MakeDuration
(
int64_t
hi
int64_t
lo
)
;
inline
Duration
MakePosDoubleDuration
(
double
n
)
;
constexpr
int64_t
kTicksPerNanosecond
=
4
;
constexpr
int64_t
kTicksPerSecond
=
1000
*
1000
*
1000
*
kTicksPerNanosecond
;
template
<
std
:
:
intmax_t
N
>
constexpr
Duration
FromInt64
(
int64_t
v
std
:
:
ratio
<
1
N
>
)
;
constexpr
Duration
FromInt64
(
int64_t
v
std
:
:
ratio
<
60
>
)
;
constexpr
Duration
FromInt64
(
int64_t
v
std
:
:
ratio
<
3600
>
)
;
template
<
typename
T
>
using
EnableIfIntegral
=
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
|
|
std
:
:
is_enum
<
T
>
:
:
value
int
>
:
:
type
;
template
<
typename
T
>
using
EnableIfFloat
=
typename
std
:
:
enable_if
<
std
:
:
is_floating_point
<
T
>
:
:
value
int
>
:
:
type
;
}
class
Duration
{
public
:
constexpr
Duration
(
)
:
rep_hi_
(
0
)
rep_lo_
(
0
)
{
}
#
if
!
defined
(
__clang__
)
&
&
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1910
constexpr
Duration
(
const
Duration
&
d
)
:
rep_hi_
(
d
.
rep_hi_
)
rep_lo_
(
d
.
rep_lo_
)
{
}
#
else
constexpr
Duration
(
const
Duration
&
d
)
=
default
;
#
endif
Duration
&
operator
=
(
const
Duration
&
d
)
=
default
;
Duration
&
operator
+
=
(
Duration
d
)
;
Duration
&
operator
-
=
(
Duration
d
)
;
Duration
&
operator
*
=
(
int64_t
r
)
;
Duration
&
operator
*
=
(
double
r
)
;
Duration
&
operator
/
=
(
int64_t
r
)
;
Duration
&
operator
/
=
(
double
r
)
;
Duration
&
operator
%
=
(
Duration
rhs
)
;
template
<
typename
T
>
Duration
&
operator
*
=
(
T
r
)
{
int64_t
x
=
r
;
return
*
this
*
=
x
;
}
template
<
typename
T
>
Duration
&
operator
/
=
(
T
r
)
{
int64_t
x
=
r
;
return
*
this
/
=
x
;
}
Duration
&
operator
*
=
(
float
r
)
{
return
*
this
*
=
static_cast
<
double
>
(
r
)
;
}
Duration
&
operator
/
=
(
float
r
)
{
return
*
this
/
=
static_cast
<
double
>
(
r
)
;
}
template
<
typename
H
>
friend
H
AbslHashValue
(
H
h
Duration
d
)
{
return
H
:
:
combine
(
std
:
:
move
(
h
)
d
.
rep_hi_
d
.
rep_lo_
)
;
}
private
:
friend
constexpr
int64_t
time_internal
:
:
GetRepHi
(
Duration
d
)
;
friend
constexpr
uint32_t
time_internal
:
:
GetRepLo
(
Duration
d
)
;
friend
constexpr
Duration
time_internal
:
:
MakeDuration
(
int64_t
hi
uint32_t
lo
)
;
constexpr
Duration
(
int64_t
hi
uint32_t
lo
)
:
rep_hi_
(
hi
)
rep_lo_
(
lo
)
{
}
int64_t
rep_hi_
;
uint32_t
rep_lo_
;
}
;
constexpr
bool
operator
<
(
Duration
lhs
Duration
rhs
)
;
constexpr
bool
operator
>
(
Duration
lhs
Duration
rhs
)
{
return
rhs
<
lhs
;
}
constexpr
bool
operator
>
=
(
Duration
lhs
Duration
rhs
)
{
return
!
(
lhs
<
rhs
)
;
}
constexpr
bool
operator
<
=
(
Duration
lhs
Duration
rhs
)
{
return
!
(
rhs
<
lhs
)
;
}
constexpr
bool
operator
=
=
(
Duration
lhs
Duration
rhs
)
;
constexpr
bool
operator
!
=
(
Duration
lhs
Duration
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
constexpr
Duration
operator
-
(
Duration
d
)
;
inline
Duration
operator
+
(
Duration
lhs
Duration
rhs
)
{
return
lhs
+
=
rhs
;
}
inline
Duration
operator
-
(
Duration
lhs
Duration
rhs
)
{
return
lhs
-
=
rhs
;
}
template
<
typename
T
>
Duration
operator
*
(
Duration
lhs
T
rhs
)
{
return
lhs
*
=
rhs
;
}
template
<
typename
T
>
Duration
operator
*
(
T
lhs
Duration
rhs
)
{
return
rhs
*
=
lhs
;
}
template
<
typename
T
>
Duration
operator
/
(
Duration
lhs
T
rhs
)
{
return
lhs
/
=
rhs
;
}
inline
int64_t
operator
/
(
Duration
lhs
Duration
rhs
)
{
return
time_internal
:
:
IDivDuration
(
true
lhs
rhs
&
lhs
)
;
}
inline
Duration
operator
%
(
Duration
lhs
Duration
rhs
)
{
return
lhs
%
=
rhs
;
}
inline
int64_t
IDivDuration
(
Duration
num
Duration
den
Duration
*
rem
)
{
return
time_internal
:
:
IDivDuration
(
true
num
den
rem
)
;
}
double
FDivDuration
(
Duration
num
Duration
den
)
;
constexpr
Duration
ZeroDuration
(
)
{
return
Duration
(
)
;
}
inline
Duration
AbsDuration
(
Duration
d
)
{
return
(
d
<
ZeroDuration
(
)
)
?
-
d
:
d
;
}
Duration
Trunc
(
Duration
d
Duration
unit
)
;
Duration
Floor
(
Duration
d
Duration
unit
)
;
Duration
Ceil
(
Duration
d
Duration
unit
)
;
constexpr
Duration
InfiniteDuration
(
)
;
constexpr
Duration
Nanoseconds
(
int64_t
n
)
;
constexpr
Duration
Microseconds
(
int64_t
n
)
;
constexpr
Duration
Milliseconds
(
int64_t
n
)
;
constexpr
Duration
Seconds
(
int64_t
n
)
;
constexpr
Duration
Minutes
(
int64_t
n
)
;
constexpr
Duration
Hours
(
int64_t
n
)
;
template
<
typename
T
time_internal
:
:
EnableIfFloat
<
T
>
=
0
>
Duration
Nanoseconds
(
T
n
)
{
return
n
*
Nanoseconds
(
1
)
;
}
template
<
typename
T
time_internal
:
:
EnableIfFloat
<
T
>
=
0
>
Duration
Microseconds
(
T
n
)
{
return
n
*
Microseconds
(
1
)
;
}
template
<
typename
T
time_internal
:
:
EnableIfFloat
<
T
>
=
0
>
Duration
Milliseconds
(
T
n
)
{
return
n
*
Milliseconds
(
1
)
;
}
template
<
typename
T
time_internal
:
:
EnableIfFloat
<
T
>
=
0
>
Duration
Seconds
(
T
n
)
{
if
(
n
>
=
0
)
{
if
(
n
>
=
static_cast
<
T
>
(
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
)
)
{
return
InfiniteDuration
(
)
;
}
return
time_internal
:
:
MakePosDoubleDuration
(
n
)
;
}
else
{
if
(
std
:
:
isnan
(
n
)
)
return
std
:
:
signbit
(
n
)
?
-
InfiniteDuration
(
)
:
InfiniteDuration
(
)
;
if
(
n
<
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
)
return
-
InfiniteDuration
(
)
;
return
-
time_internal
:
:
MakePosDoubleDuration
(
-
n
)
;
}
}
template
<
typename
T
time_internal
:
:
EnableIfFloat
<
T
>
=
0
>
Duration
Minutes
(
T
n
)
{
return
n
*
Minutes
(
1
)
;
}
template
<
typename
T
time_internal
:
:
EnableIfFloat
<
T
>
=
0
>
Duration
Hours
(
T
n
)
{
return
n
*
Hours
(
1
)
;
}
int64_t
ToInt64Nanoseconds
(
Duration
d
)
;
int64_t
ToInt64Microseconds
(
Duration
d
)
;
int64_t
ToInt64Milliseconds
(
Duration
d
)
;
int64_t
ToInt64Seconds
(
Duration
d
)
;
int64_t
ToInt64Minutes
(
Duration
d
)
;
int64_t
ToInt64Hours
(
Duration
d
)
;
double
ToDoubleNanoseconds
(
Duration
d
)
;
double
ToDoubleMicroseconds
(
Duration
d
)
;
double
ToDoubleMilliseconds
(
Duration
d
)
;
double
ToDoubleSeconds
(
Duration
d
)
;
double
ToDoubleMinutes
(
Duration
d
)
;
double
ToDoubleHours
(
Duration
d
)
;
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
nanoseconds
&
d
)
;
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
microseconds
&
d
)
;
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
milliseconds
&
d
)
;
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
seconds
&
d
)
;
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
minutes
&
d
)
;
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
hours
&
d
)
;
std
:
:
chrono
:
:
nanoseconds
ToChronoNanoseconds
(
Duration
d
)
;
std
:
:
chrono
:
:
microseconds
ToChronoMicroseconds
(
Duration
d
)
;
std
:
:
chrono
:
:
milliseconds
ToChronoMilliseconds
(
Duration
d
)
;
std
:
:
chrono
:
:
seconds
ToChronoSeconds
(
Duration
d
)
;
std
:
:
chrono
:
:
minutes
ToChronoMinutes
(
Duration
d
)
;
std
:
:
chrono
:
:
hours
ToChronoHours
(
Duration
d
)
;
std
:
:
string
FormatDuration
(
Duration
d
)
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
Duration
d
)
{
return
os
<
<
FormatDuration
(
d
)
;
}
bool
ParseDuration
(
absl
:
:
string_view
dur_string
Duration
*
d
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
text
Duration
*
dst
std
:
:
string
*
error
)
;
std
:
:
string
AbslUnparseFlag
(
Duration
d
)
;
ABSL_DEPRECATED
(
"
Use
AbslParseFlag
(
)
instead
.
"
)
bool
ParseFlag
(
const
std
:
:
string
&
text
Duration
*
dst
std
:
:
string
*
error
)
;
ABSL_DEPRECATED
(
"
Use
AbslUnparseFlag
(
)
instead
.
"
)
std
:
:
string
UnparseFlag
(
Duration
d
)
;
class
Time
{
public
:
constexpr
Time
(
)
=
default
;
constexpr
Time
(
const
Time
&
t
)
=
default
;
Time
&
operator
=
(
const
Time
&
t
)
=
default
;
Time
&
operator
+
=
(
Duration
d
)
{
rep_
+
=
d
;
return
*
this
;
}
Time
&
operator
-
=
(
Duration
d
)
{
rep_
-
=
d
;
return
*
this
;
}
struct
Breakdown
{
int64_t
year
;
int
month
;
int
day
;
int
hour
;
int
minute
;
int
second
;
Duration
subsecond
;
int
weekday
;
int
yearday
;
int
offset
;
bool
is_dst
;
const
char
*
zone_abbr
;
}
;
Breakdown
In
(
TimeZone
tz
)
const
;
template
<
typename
H
>
friend
H
AbslHashValue
(
H
h
Time
t
)
{
return
H
:
:
combine
(
std
:
:
move
(
h
)
t
.
rep_
)
;
}
private
:
friend
constexpr
Time
time_internal
:
:
FromUnixDuration
(
Duration
d
)
;
friend
constexpr
Duration
time_internal
:
:
ToUnixDuration
(
Time
t
)
;
friend
constexpr
bool
operator
<
(
Time
lhs
Time
rhs
)
;
friend
constexpr
bool
operator
=
=
(
Time
lhs
Time
rhs
)
;
friend
Duration
operator
-
(
Time
lhs
Time
rhs
)
;
friend
constexpr
Time
UniversalEpoch
(
)
;
friend
constexpr
Time
InfiniteFuture
(
)
;
friend
constexpr
Time
InfinitePast
(
)
;
constexpr
explicit
Time
(
Duration
rep
)
:
rep_
(
rep
)
{
}
Duration
rep_
;
}
;
constexpr
bool
operator
<
(
Time
lhs
Time
rhs
)
{
return
lhs
.
rep_
<
rhs
.
rep_
;
}
constexpr
bool
operator
>
(
Time
lhs
Time
rhs
)
{
return
rhs
<
lhs
;
}
constexpr
bool
operator
>
=
(
Time
lhs
Time
rhs
)
{
return
!
(
lhs
<
rhs
)
;
}
constexpr
bool
operator
<
=
(
Time
lhs
Time
rhs
)
{
return
!
(
rhs
<
lhs
)
;
}
constexpr
bool
operator
=
=
(
Time
lhs
Time
rhs
)
{
return
lhs
.
rep_
=
=
rhs
.
rep_
;
}
constexpr
bool
operator
!
=
(
Time
lhs
Time
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
inline
Time
operator
+
(
Time
lhs
Duration
rhs
)
{
return
lhs
+
=
rhs
;
}
inline
Time
operator
+
(
Duration
lhs
Time
rhs
)
{
return
rhs
+
=
lhs
;
}
inline
Time
operator
-
(
Time
lhs
Duration
rhs
)
{
return
lhs
-
=
rhs
;
}
inline
Duration
operator
-
(
Time
lhs
Time
rhs
)
{
return
lhs
.
rep_
-
rhs
.
rep_
;
}
constexpr
Time
UnixEpoch
(
)
{
return
Time
(
)
;
}
constexpr
Time
UniversalEpoch
(
)
{
return
Time
(
time_internal
:
:
MakeDuration
(
-
24
*
719162
*
int64_t
{
3600
}
0U
)
)
;
}
constexpr
Time
InfiniteFuture
(
)
{
return
Time
(
time_internal
:
:
MakeDuration
(
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
~
0U
)
)
;
}
constexpr
Time
InfinitePast
(
)
{
return
Time
(
time_internal
:
:
MakeDuration
(
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
~
0U
)
)
;
}
constexpr
Time
FromUnixNanos
(
int64_t
ns
)
;
constexpr
Time
FromUnixMicros
(
int64_t
us
)
;
constexpr
Time
FromUnixMillis
(
int64_t
ms
)
;
constexpr
Time
FromUnixSeconds
(
int64_t
s
)
;
constexpr
Time
FromTimeT
(
time_t
t
)
;
Time
FromUDate
(
double
udate
)
;
Time
FromUniversal
(
int64_t
universal
)
;
int64_t
ToUnixNanos
(
Time
t
)
;
int64_t
ToUnixMicros
(
Time
t
)
;
int64_t
ToUnixMillis
(
Time
t
)
;
int64_t
ToUnixSeconds
(
Time
t
)
;
time_t
ToTimeT
(
Time
t
)
;
double
ToUDate
(
Time
t
)
;
int64_t
ToUniversal
(
Time
t
)
;
Duration
DurationFromTimespec
(
timespec
ts
)
;
Duration
DurationFromTimeval
(
timeval
tv
)
;
timespec
ToTimespec
(
Duration
d
)
;
timeval
ToTimeval
(
Duration
d
)
;
Time
TimeFromTimespec
(
timespec
ts
)
;
Time
TimeFromTimeval
(
timeval
tv
)
;
timespec
ToTimespec
(
Time
t
)
;
timeval
ToTimeval
(
Time
t
)
;
Time
FromChrono
(
const
std
:
:
chrono
:
:
system_clock
:
:
time_point
&
tp
)
;
std
:
:
chrono
:
:
system_clock
:
:
time_point
ToChronoTime
(
Time
)
;
bool
AbslParseFlag
(
absl
:
:
string_view
text
Time
*
t
std
:
:
string
*
error
)
;
std
:
:
string
AbslUnparseFlag
(
Time
t
)
;
ABSL_DEPRECATED
(
"
Use
AbslParseFlag
(
)
instead
.
"
)
bool
ParseFlag
(
const
std
:
:
string
&
text
Time
*
t
std
:
:
string
*
error
)
;
ABSL_DEPRECATED
(
"
Use
AbslUnparseFlag
(
)
instead
.
"
)
std
:
:
string
UnparseFlag
(
Time
t
)
;
class
TimeZone
{
public
:
explicit
TimeZone
(
time_internal
:
:
cctz
:
:
time_zone
tz
)
:
cz_
(
tz
)
{
}
TimeZone
(
)
=
default
;
TimeZone
(
const
TimeZone
&
)
=
default
;
TimeZone
&
operator
=
(
const
TimeZone
&
)
=
default
;
explicit
operator
time_internal
:
:
cctz
:
:
time_zone
(
)
const
{
return
cz_
;
}
std
:
:
string
name
(
)
const
{
return
cz_
.
name
(
)
;
}
struct
CivilInfo
{
CivilSecond
cs
;
Duration
subsecond
;
int
offset
;
bool
is_dst
;
const
char
*
zone_abbr
;
}
;
CivilInfo
At
(
Time
t
)
const
;
struct
TimeInfo
{
enum
CivilKind
{
UNIQUE
SKIPPED
REPEATED
}
kind
;
Time
pre
;
Time
trans
;
Time
post
;
}
;
TimeInfo
At
(
CivilSecond
ct
)
const
;
struct
CivilTransition
{
CivilSecond
from
;
CivilSecond
to
;
}
;
bool
NextTransition
(
Time
t
CivilTransition
*
trans
)
const
;
bool
PrevTransition
(
Time
t
CivilTransition
*
trans
)
const
;
template
<
typename
H
>
friend
H
AbslHashValue
(
H
h
TimeZone
tz
)
{
return
H
:
:
combine
(
std
:
:
move
(
h
)
tz
.
cz_
)
;
}
private
:
friend
bool
operator
=
=
(
TimeZone
a
TimeZone
b
)
{
return
a
.
cz_
=
=
b
.
cz_
;
}
friend
bool
operator
!
=
(
TimeZone
a
TimeZone
b
)
{
return
a
.
cz_
!
=
b
.
cz_
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
TimeZone
tz
)
{
return
os
<
<
tz
.
name
(
)
;
}
time_internal
:
:
cctz
:
:
time_zone
cz_
;
}
;
inline
bool
LoadTimeZone
(
absl
:
:
string_view
name
TimeZone
*
tz
)
{
if
(
name
=
=
"
localtime
"
)
{
*
tz
=
TimeZone
(
time_internal
:
:
cctz
:
:
local_time_zone
(
)
)
;
return
true
;
}
time_internal
:
:
cctz
:
:
time_zone
cz
;
const
bool
b
=
time_internal
:
:
cctz
:
:
load_time_zone
(
std
:
:
string
(
name
)
&
cz
)
;
*
tz
=
TimeZone
(
cz
)
;
return
b
;
}
inline
TimeZone
FixedTimeZone
(
int
seconds
)
{
return
TimeZone
(
time_internal
:
:
cctz
:
:
fixed_time_zone
(
std
:
:
chrono
:
:
seconds
(
seconds
)
)
)
;
}
inline
TimeZone
UTCTimeZone
(
)
{
return
TimeZone
(
time_internal
:
:
cctz
:
:
utc_time_zone
(
)
)
;
}
inline
TimeZone
LocalTimeZone
(
)
{
return
TimeZone
(
time_internal
:
:
cctz
:
:
local_time_zone
(
)
)
;
}
inline
CivilSecond
ToCivilSecond
(
Time
t
TimeZone
tz
)
{
return
tz
.
At
(
t
)
.
cs
;
}
inline
CivilMinute
ToCivilMinute
(
Time
t
TimeZone
tz
)
{
return
CivilMinute
(
tz
.
At
(
t
)
.
cs
)
;
}
inline
CivilHour
ToCivilHour
(
Time
t
TimeZone
tz
)
{
return
CivilHour
(
tz
.
At
(
t
)
.
cs
)
;
}
inline
CivilDay
ToCivilDay
(
Time
t
TimeZone
tz
)
{
return
CivilDay
(
tz
.
At
(
t
)
.
cs
)
;
}
inline
CivilMonth
ToCivilMonth
(
Time
t
TimeZone
tz
)
{
return
CivilMonth
(
tz
.
At
(
t
)
.
cs
)
;
}
inline
CivilYear
ToCivilYear
(
Time
t
TimeZone
tz
)
{
return
CivilYear
(
tz
.
At
(
t
)
.
cs
)
;
}
inline
Time
FromCivil
(
CivilSecond
ct
TimeZone
tz
)
{
const
auto
ti
=
tz
.
At
(
ct
)
;
if
(
ti
.
kind
=
=
TimeZone
:
:
TimeInfo
:
:
SKIPPED
)
return
ti
.
trans
;
return
ti
.
pre
;
}
struct
TimeConversion
{
Time
pre
;
Time
trans
;
Time
post
;
enum
Kind
{
UNIQUE
SKIPPED
REPEATED
}
;
Kind
kind
;
bool
normalized
;
}
;
TimeConversion
ConvertDateTime
(
int64_t
year
int
mon
int
day
int
hour
int
min
int
sec
TimeZone
tz
)
;
inline
Time
FromDateTime
(
int64_t
year
int
mon
int
day
int
hour
int
min
int
sec
TimeZone
tz
)
{
return
ConvertDateTime
(
year
mon
day
hour
min
sec
tz
)
.
pre
;
}
Time
FromTM
(
const
struct
tm
&
tm
TimeZone
tz
)
;
struct
tm
ToTM
(
Time
t
TimeZone
tz
)
;
ABSL_DLL
extern
const
char
RFC3339_full
[
]
;
ABSL_DLL
extern
const
char
RFC3339_sec
[
]
;
ABSL_DLL
extern
const
char
RFC1123_full
[
]
;
ABSL_DLL
extern
const
char
RFC1123_no_wday
[
]
;
std
:
:
string
FormatTime
(
absl
:
:
string_view
format
Time
t
TimeZone
tz
)
;
std
:
:
string
FormatTime
(
Time
t
TimeZone
tz
)
;
std
:
:
string
FormatTime
(
Time
t
)
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
Time
t
)
{
return
os
<
<
FormatTime
(
t
)
;
}
bool
ParseTime
(
absl
:
:
string_view
format
absl
:
:
string_view
input
Time
*
time
std
:
:
string
*
err
)
;
bool
ParseTime
(
absl
:
:
string_view
format
absl
:
:
string_view
input
TimeZone
tz
Time
*
time
std
:
:
string
*
err
)
;
namespace
time_internal
{
constexpr
Duration
MakeDuration
(
int64_t
hi
uint32_t
lo
=
0
)
{
return
Duration
(
hi
lo
)
;
}
constexpr
Duration
MakeDuration
(
int64_t
hi
int64_t
lo
)
{
return
MakeDuration
(
hi
static_cast
<
uint32_t
>
(
lo
)
)
;
}
inline
Duration
MakePosDoubleDuration
(
double
n
)
{
const
int64_t
int_secs
=
static_cast
<
int64_t
>
(
n
)
;
const
uint32_t
ticks
=
static_cast
<
uint32_t
>
(
(
n
-
static_cast
<
double
>
(
int_secs
)
)
*
kTicksPerSecond
+
0
.
5
)
;
return
ticks
<
kTicksPerSecond
?
MakeDuration
(
int_secs
ticks
)
:
MakeDuration
(
int_secs
+
1
ticks
-
kTicksPerSecond
)
;
}
constexpr
Duration
MakeNormalizedDuration
(
int64_t
sec
int64_t
ticks
)
{
return
(
ticks
<
0
)
?
MakeDuration
(
sec
-
1
ticks
+
kTicksPerSecond
)
:
MakeDuration
(
sec
ticks
)
;
}
constexpr
int64_t
GetRepHi
(
Duration
d
)
{
return
d
.
rep_hi_
;
}
constexpr
uint32_t
GetRepLo
(
Duration
d
)
{
return
d
.
rep_lo_
;
}
constexpr
bool
IsInfiniteDuration
(
Duration
d
)
{
return
GetRepLo
(
d
)
=
=
~
0U
;
}
constexpr
Duration
OppositeInfinity
(
Duration
d
)
{
return
GetRepHi
(
d
)
<
0
?
MakeDuration
(
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
~
0U
)
:
MakeDuration
(
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
~
0U
)
;
}
constexpr
int64_t
NegateAndSubtractOne
(
int64_t
n
)
{
return
(
n
<
0
)
?
-
(
n
+
1
)
:
(
-
n
)
-
1
;
}
constexpr
Time
FromUnixDuration
(
Duration
d
)
{
return
Time
(
d
)
;
}
constexpr
Duration
ToUnixDuration
(
Time
t
)
{
return
t
.
rep_
;
}
template
<
std
:
:
intmax_t
N
>
constexpr
Duration
FromInt64
(
int64_t
v
std
:
:
ratio
<
1
N
>
)
{
static_assert
(
0
<
N
&
&
N
<
=
1000
*
1000
*
1000
"
Unsupported
ratio
"
)
;
return
MakeNormalizedDuration
(
v
/
N
v
%
N
*
kTicksPerNanosecond
*
1000
*
1000
*
1000
/
N
)
;
}
constexpr
Duration
FromInt64
(
int64_t
v
std
:
:
ratio
<
60
>
)
{
return
(
v
<
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
/
60
&
&
v
>
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
/
60
)
?
MakeDuration
(
v
*
60
)
:
v
>
0
?
InfiniteDuration
(
)
:
-
InfiniteDuration
(
)
;
}
constexpr
Duration
FromInt64
(
int64_t
v
std
:
:
ratio
<
3600
>
)
{
return
(
v
<
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
/
3600
&
&
v
>
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
/
3600
)
?
MakeDuration
(
v
*
3600
)
:
v
>
0
?
InfiniteDuration
(
)
:
-
InfiniteDuration
(
)
;
}
template
<
typename
T
>
constexpr
auto
IsValidRep64
(
int
)
-
>
decltype
(
int64_t
{
std
:
:
declval
<
T
>
(
)
}
=
=
0
)
{
return
true
;
}
template
<
typename
T
>
constexpr
auto
IsValidRep64
(
char
)
-
>
bool
{
return
false
;
}
template
<
typename
Rep
typename
Period
>
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
duration
<
Rep
Period
>
&
d
)
{
static_assert
(
IsValidRep64
<
Rep
>
(
0
)
"
duration
:
:
rep
is
invalid
"
)
;
return
FromInt64
(
int64_t
{
d
.
count
(
)
}
Period
{
}
)
;
}
template
<
typename
Ratio
>
int64_t
ToInt64
(
Duration
d
Ratio
)
{
return
ToInt64Seconds
(
d
*
Ratio
:
:
den
/
Ratio
:
:
num
)
;
}
inline
int64_t
ToInt64
(
Duration
d
std
:
:
nano
)
{
return
ToInt64Nanoseconds
(
d
)
;
}
inline
int64_t
ToInt64
(
Duration
d
std
:
:
micro
)
{
return
ToInt64Microseconds
(
d
)
;
}
inline
int64_t
ToInt64
(
Duration
d
std
:
:
milli
)
{
return
ToInt64Milliseconds
(
d
)
;
}
inline
int64_t
ToInt64
(
Duration
d
std
:
:
ratio
<
1
>
)
{
return
ToInt64Seconds
(
d
)
;
}
inline
int64_t
ToInt64
(
Duration
d
std
:
:
ratio
<
60
>
)
{
return
ToInt64Minutes
(
d
)
;
}
inline
int64_t
ToInt64
(
Duration
d
std
:
:
ratio
<
3600
>
)
{
return
ToInt64Hours
(
d
)
;
}
template
<
typename
T
>
T
ToChronoDuration
(
Duration
d
)
{
using
Rep
=
typename
T
:
:
rep
;
using
Period
=
typename
T
:
:
period
;
static_assert
(
IsValidRep64
<
Rep
>
(
0
)
"
duration
:
:
rep
is
invalid
"
)
;
if
(
time_internal
:
:
IsInfiniteDuration
(
d
)
)
return
d
<
ZeroDuration
(
)
?
(
T
:
:
min
)
(
)
:
(
T
:
:
max
)
(
)
;
const
auto
v
=
ToInt64
(
d
Period
{
}
)
;
if
(
v
>
(
std
:
:
numeric_limits
<
Rep
>
:
:
max
)
(
)
)
return
(
T
:
:
max
)
(
)
;
if
(
v
<
(
std
:
:
numeric_limits
<
Rep
>
:
:
min
)
(
)
)
return
(
T
:
:
min
)
(
)
;
return
T
{
v
}
;
}
}
constexpr
Duration
Nanoseconds
(
int64_t
n
)
{
return
time_internal
:
:
FromInt64
(
n
std
:
:
nano
{
}
)
;
}
constexpr
Duration
Microseconds
(
int64_t
n
)
{
return
time_internal
:
:
FromInt64
(
n
std
:
:
micro
{
}
)
;
}
constexpr
Duration
Milliseconds
(
int64_t
n
)
{
return
time_internal
:
:
FromInt64
(
n
std
:
:
milli
{
}
)
;
}
constexpr
Duration
Seconds
(
int64_t
n
)
{
return
time_internal
:
:
FromInt64
(
n
std
:
:
ratio
<
1
>
{
}
)
;
}
constexpr
Duration
Minutes
(
int64_t
n
)
{
return
time_internal
:
:
FromInt64
(
n
std
:
:
ratio
<
60
>
{
}
)
;
}
constexpr
Duration
Hours
(
int64_t
n
)
{
return
time_internal
:
:
FromInt64
(
n
std
:
:
ratio
<
3600
>
{
}
)
;
}
constexpr
bool
operator
<
(
Duration
lhs
Duration
rhs
)
{
return
time_internal
:
:
GetRepHi
(
lhs
)
!
=
time_internal
:
:
GetRepHi
(
rhs
)
?
time_internal
:
:
GetRepHi
(
lhs
)
<
time_internal
:
:
GetRepHi
(
rhs
)
:
time_internal
:
:
GetRepHi
(
lhs
)
=
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
?
time_internal
:
:
GetRepLo
(
lhs
)
+
1
<
time_internal
:
:
GetRepLo
(
rhs
)
+
1
:
time_internal
:
:
GetRepLo
(
lhs
)
<
time_internal
:
:
GetRepLo
(
rhs
)
;
}
constexpr
bool
operator
=
=
(
Duration
lhs
Duration
rhs
)
{
return
time_internal
:
:
GetRepHi
(
lhs
)
=
=
time_internal
:
:
GetRepHi
(
rhs
)
&
&
time_internal
:
:
GetRepLo
(
lhs
)
=
=
time_internal
:
:
GetRepLo
(
rhs
)
;
}
constexpr
Duration
operator
-
(
Duration
d
)
{
return
time_internal
:
:
GetRepLo
(
d
)
=
=
0
?
time_internal
:
:
GetRepHi
(
d
)
=
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
)
(
)
?
InfiniteDuration
(
)
:
time_internal
:
:
MakeDuration
(
-
time_internal
:
:
GetRepHi
(
d
)
)
:
time_internal
:
:
IsInfiniteDuration
(
d
)
?
time_internal
:
:
OppositeInfinity
(
d
)
:
time_internal
:
:
MakeDuration
(
time_internal
:
:
NegateAndSubtractOne
(
time_internal
:
:
GetRepHi
(
d
)
)
time_internal
:
:
kTicksPerSecond
-
time_internal
:
:
GetRepLo
(
d
)
)
;
}
constexpr
Duration
InfiniteDuration
(
)
{
return
time_internal
:
:
MakeDuration
(
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
)
(
)
~
0U
)
;
}
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
nanoseconds
&
d
)
{
return
time_internal
:
:
FromChrono
(
d
)
;
}
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
microseconds
&
d
)
{
return
time_internal
:
:
FromChrono
(
d
)
;
}
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
milliseconds
&
d
)
{
return
time_internal
:
:
FromChrono
(
d
)
;
}
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
seconds
&
d
)
{
return
time_internal
:
:
FromChrono
(
d
)
;
}
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
minutes
&
d
)
{
return
time_internal
:
:
FromChrono
(
d
)
;
}
constexpr
Duration
FromChrono
(
const
std
:
:
chrono
:
:
hours
&
d
)
{
return
time_internal
:
:
FromChrono
(
d
)
;
}
constexpr
Time
FromUnixNanos
(
int64_t
ns
)
{
return
time_internal
:
:
FromUnixDuration
(
Nanoseconds
(
ns
)
)
;
}
constexpr
Time
FromUnixMicros
(
int64_t
us
)
{
return
time_internal
:
:
FromUnixDuration
(
Microseconds
(
us
)
)
;
}
constexpr
Time
FromUnixMillis
(
int64_t
ms
)
{
return
time_internal
:
:
FromUnixDuration
(
Milliseconds
(
ms
)
)
;
}
constexpr
Time
FromUnixSeconds
(
int64_t
s
)
{
return
time_internal
:
:
FromUnixDuration
(
Seconds
(
s
)
)
;
}
constexpr
Time
FromTimeT
(
time_t
t
)
{
return
time_internal
:
:
FromUnixDuration
(
Seconds
(
t
)
)
;
}
ABSL_NAMESPACE_END
}
#
endif
