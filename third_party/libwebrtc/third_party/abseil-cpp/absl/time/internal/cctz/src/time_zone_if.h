#
ifndef
ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
#
define
ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
#
include
<
chrono
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
civil_time
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
time_zone
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
time_internal
{
namespace
cctz
{
class
TimeZoneIf
{
public
:
static
std
:
:
unique_ptr
<
TimeZoneIf
>
UTC
(
)
;
static
std
:
:
unique_ptr
<
TimeZoneIf
>
Make
(
const
std
:
:
string
&
name
)
;
virtual
~
TimeZoneIf
(
)
;
virtual
time_zone
:
:
absolute_lookup
BreakTime
(
const
time_point
<
seconds
>
&
tp
)
const
=
0
;
virtual
time_zone
:
:
civil_lookup
MakeTime
(
const
civil_second
&
cs
)
const
=
0
;
virtual
bool
NextTransition
(
const
time_point
<
seconds
>
&
tp
time_zone
:
:
civil_transition
*
trans
)
const
=
0
;
virtual
bool
PrevTransition
(
const
time_point
<
seconds
>
&
tp
time_zone
:
:
civil_transition
*
trans
)
const
=
0
;
virtual
std
:
:
string
Version
(
)
const
=
0
;
virtual
std
:
:
string
Description
(
)
const
=
0
;
protected
:
TimeZoneIf
(
)
=
default
;
TimeZoneIf
(
const
TimeZoneIf
&
)
=
delete
;
TimeZoneIf
&
operator
=
(
const
TimeZoneIf
&
)
=
delete
;
}
;
inline
std
:
:
int_fast64_t
ToUnixSeconds
(
const
time_point
<
seconds
>
&
tp
)
{
return
(
tp
-
std
:
:
chrono
:
:
time_point_cast
<
seconds
>
(
std
:
:
chrono
:
:
system_clock
:
:
from_time_t
(
0
)
)
)
.
count
(
)
;
}
inline
time_point
<
seconds
>
FromUnixSeconds
(
std
:
:
int_fast64_t
t
)
{
return
std
:
:
chrono
:
:
time_point_cast
<
seconds
>
(
std
:
:
chrono
:
:
system_clock
:
:
from_time_t
(
0
)
)
+
seconds
(
t
)
;
}
}
}
ABSL_NAMESPACE_END
}
#
endif
