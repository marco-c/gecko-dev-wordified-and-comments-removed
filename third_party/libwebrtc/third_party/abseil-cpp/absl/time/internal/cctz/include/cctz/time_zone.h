#
ifndef
ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_
#
define
ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_
#
include
<
chrono
>
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
ratio
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
civil_time
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
time_internal
{
namespace
cctz
{
template
<
typename
D
>
using
time_point
=
std
:
:
chrono
:
:
time_point
<
std
:
:
chrono
:
:
system_clock
D
>
;
using
seconds
=
std
:
:
chrono
:
:
duration
<
std
:
:
int_fast64_t
>
;
using
sys_seconds
=
seconds
;
namespace
detail
{
template
<
typename
D
>
std
:
:
pair
<
time_point
<
seconds
>
D
>
split_seconds
(
const
time_point
<
D
>
&
tp
)
;
std
:
:
pair
<
time_point
<
seconds
>
seconds
>
split_seconds
(
const
time_point
<
seconds
>
&
tp
)
;
}
class
time_zone
{
public
:
time_zone
(
)
:
time_zone
(
nullptr
)
{
}
time_zone
(
const
time_zone
&
)
=
default
;
time_zone
&
operator
=
(
const
time_zone
&
)
=
default
;
std
:
:
string
name
(
)
const
;
struct
absolute_lookup
{
civil_second
cs
;
int
offset
;
bool
is_dst
;
const
char
*
abbr
;
}
;
absolute_lookup
lookup
(
const
time_point
<
seconds
>
&
tp
)
const
;
template
<
typename
D
>
absolute_lookup
lookup
(
const
time_point
<
D
>
&
tp
)
const
{
return
lookup
(
detail
:
:
split_seconds
(
tp
)
.
first
)
;
}
struct
civil_lookup
{
enum
civil_kind
{
UNIQUE
SKIPPED
REPEATED
}
kind
;
time_point
<
seconds
>
pre
;
time_point
<
seconds
>
trans
;
time_point
<
seconds
>
post
;
}
;
civil_lookup
lookup
(
const
civil_second
&
cs
)
const
;
struct
civil_transition
{
civil_second
from
;
civil_second
to
;
}
;
bool
next_transition
(
const
time_point
<
seconds
>
&
tp
civil_transition
*
trans
)
const
;
template
<
typename
D
>
bool
next_transition
(
const
time_point
<
D
>
&
tp
civil_transition
*
trans
)
const
{
return
next_transition
(
detail
:
:
split_seconds
(
tp
)
.
first
trans
)
;
}
bool
prev_transition
(
const
time_point
<
seconds
>
&
tp
civil_transition
*
trans
)
const
;
template
<
typename
D
>
bool
prev_transition
(
const
time_point
<
D
>
&
tp
civil_transition
*
trans
)
const
{
return
prev_transition
(
detail
:
:
split_seconds
(
tp
)
.
first
trans
)
;
}
std
:
:
string
version
(
)
const
;
std
:
:
string
description
(
)
const
;
friend
bool
operator
=
=
(
time_zone
lhs
time_zone
rhs
)
{
return
&
lhs
.
effective_impl
(
)
=
=
&
rhs
.
effective_impl
(
)
;
}
friend
bool
operator
!
=
(
time_zone
lhs
time_zone
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
template
<
typename
H
>
friend
H
AbslHashValue
(
H
h
time_zone
tz
)
{
return
H
:
:
combine
(
std
:
:
move
(
h
)
&
tz
.
effective_impl
(
)
)
;
}
class
Impl
;
private
:
explicit
time_zone
(
const
Impl
*
impl
)
:
impl_
(
impl
)
{
}
const
Impl
&
effective_impl
(
)
const
;
const
Impl
*
impl_
;
}
;
bool
load_time_zone
(
const
std
:
:
string
&
name
time_zone
*
tz
)
;
time_zone
utc_time_zone
(
)
;
time_zone
fixed_time_zone
(
const
seconds
&
offset
)
;
time_zone
local_time_zone
(
)
;
template
<
typename
D
>
inline
civil_second
convert
(
const
time_point
<
D
>
&
tp
const
time_zone
&
tz
)
{
return
tz
.
lookup
(
tp
)
.
cs
;
}
inline
time_point
<
seconds
>
convert
(
const
civil_second
&
cs
const
time_zone
&
tz
)
{
const
time_zone
:
:
civil_lookup
cl
=
tz
.
lookup
(
cs
)
;
if
(
cl
.
kind
=
=
time_zone
:
:
civil_lookup
:
:
SKIPPED
)
return
cl
.
trans
;
return
cl
.
pre
;
}
namespace
detail
{
using
femtoseconds
=
std
:
:
chrono
:
:
duration
<
std
:
:
int_fast64_t
std
:
:
femto
>
;
std
:
:
string
format
(
const
std
:
:
string
&
const
time_point
<
seconds
>
&
const
femtoseconds
&
const
time_zone
&
)
;
bool
parse
(
const
std
:
:
string
&
const
std
:
:
string
&
const
time_zone
&
time_point
<
seconds
>
*
femtoseconds
*
std
:
:
string
*
err
=
nullptr
)
;
template
<
typename
Rep
std
:
:
intmax_t
Denom
>
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
fs
time_point
<
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
1
Denom
>
>
>
*
tpp
)
;
template
<
typename
Rep
std
:
:
intmax_t
Num
>
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
fs
time_point
<
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
Num
1
>
>
>
*
tpp
)
;
template
<
typename
Rep
>
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
fs
time_point
<
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
1
1
>
>
>
*
tpp
)
;
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
time_point
<
seconds
>
*
tpp
)
;
}
template
<
typename
D
>
inline
std
:
:
string
format
(
const
std
:
:
string
&
fmt
const
time_point
<
D
>
&
tp
const
time_zone
&
tz
)
{
const
auto
p
=
detail
:
:
split_seconds
(
tp
)
;
const
auto
n
=
std
:
:
chrono
:
:
duration_cast
<
detail
:
:
femtoseconds
>
(
p
.
second
)
;
return
detail
:
:
format
(
fmt
p
.
first
n
tz
)
;
}
template
<
typename
D
>
inline
bool
parse
(
const
std
:
:
string
&
fmt
const
std
:
:
string
&
input
const
time_zone
&
tz
time_point
<
D
>
*
tpp
)
{
time_point
<
seconds
>
sec
;
detail
:
:
femtoseconds
fs
;
return
detail
:
:
parse
(
fmt
input
tz
&
sec
&
fs
)
&
&
detail
:
:
join_seconds
(
sec
fs
tpp
)
;
}
namespace
detail
{
template
<
typename
D
>
std
:
:
pair
<
time_point
<
seconds
>
D
>
split_seconds
(
const
time_point
<
D
>
&
tp
)
{
auto
sec
=
std
:
:
chrono
:
:
time_point_cast
<
seconds
>
(
tp
)
;
auto
sub
=
tp
-
sec
;
if
(
sub
.
count
(
)
<
0
)
{
sec
-
=
seconds
(
1
)
;
sub
+
=
seconds
(
1
)
;
}
return
{
sec
std
:
:
chrono
:
:
duration_cast
<
D
>
(
sub
)
}
;
}
inline
std
:
:
pair
<
time_point
<
seconds
>
seconds
>
split_seconds
(
const
time_point
<
seconds
>
&
tp
)
{
return
{
tp
seconds
:
:
zero
(
)
}
;
}
template
<
typename
Rep
std
:
:
intmax_t
Denom
>
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
fs
time_point
<
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
1
Denom
>
>
>
*
tpp
)
{
using
D
=
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
1
Denom
>
>
;
*
tpp
=
std
:
:
chrono
:
:
time_point_cast
<
D
>
(
sec
)
;
*
tpp
+
=
std
:
:
chrono
:
:
duration_cast
<
D
>
(
fs
)
;
return
true
;
}
template
<
typename
Rep
std
:
:
intmax_t
Num
>
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
time_point
<
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
Num
1
>
>
>
*
tpp
)
{
using
D
=
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
Num
1
>
>
;
auto
count
=
sec
.
time_since_epoch
(
)
.
count
(
)
;
if
(
count
>
=
0
|
|
count
%
Num
=
=
0
)
{
count
/
=
Num
;
}
else
{
count
/
=
Num
;
count
-
=
1
;
}
if
(
count
>
(
std
:
:
numeric_limits
<
Rep
>
:
:
max
)
(
)
)
return
false
;
if
(
count
<
(
std
:
:
numeric_limits
<
Rep
>
:
:
min
)
(
)
)
return
false
;
*
tpp
=
time_point
<
D
>
(
)
+
D
{
static_cast
<
Rep
>
(
count
)
}
;
return
true
;
}
template
<
typename
Rep
>
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
time_point
<
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
1
1
>
>
>
*
tpp
)
{
using
D
=
std
:
:
chrono
:
:
duration
<
Rep
std
:
:
ratio
<
1
1
>
>
;
auto
count
=
sec
.
time_since_epoch
(
)
.
count
(
)
;
if
(
count
>
(
std
:
:
numeric_limits
<
Rep
>
:
:
max
)
(
)
)
return
false
;
if
(
count
<
(
std
:
:
numeric_limits
<
Rep
>
:
:
min
)
(
)
)
return
false
;
*
tpp
=
time_point
<
D
>
(
)
+
D
{
static_cast
<
Rep
>
(
count
)
}
;
return
true
;
}
inline
bool
join_seconds
(
const
time_point
<
seconds
>
&
sec
const
femtoseconds
&
time_point
<
seconds
>
*
tpp
)
{
*
tpp
=
sec
;
return
true
;
}
}
}
}
ABSL_NAMESPACE_END
}
#
endif
