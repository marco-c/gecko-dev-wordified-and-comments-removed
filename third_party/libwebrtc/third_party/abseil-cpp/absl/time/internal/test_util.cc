#
include
"
absl
/
time
/
internal
/
test_util
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstring
>
#
include
<
memory
>
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
time
/
internal
/
cctz
/
include
/
cctz
/
zone_info_source
.
h
"
namespace
cctz
=
absl
:
:
time_internal
:
:
cctz
;
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
time_internal
{
TimeZone
LoadTimeZone
(
const
std
:
:
string
&
name
)
{
TimeZone
tz
;
ABSL_RAW_CHECK
(
LoadTimeZone
(
name
&
tz
)
name
.
c_str
(
)
)
;
return
tz
;
}
}
ABSL_NAMESPACE_END
}
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
time_internal
{
namespace
cctz_extension
{
namespace
{
#
include
"
absl
/
time
/
internal
/
zoneinfo
.
inc
"
const
struct
ZoneInfo
{
const
char
*
name
;
const
char
*
data
;
std
:
:
size_t
length
;
}
kZoneInfo
[
]
=
{
{
"
America
/
Los_Angeles
"
reinterpret_cast
<
char
*
>
(
America_Los_Angeles
)
America_Los_Angeles_len
}
{
"
America
/
New_York
"
reinterpret_cast
<
char
*
>
(
America_New_York
)
America_New_York_len
}
{
"
Australia
/
Sydney
"
reinterpret_cast
<
char
*
>
(
Australia_Sydney
)
Australia_Sydney_len
}
{
"
Invalid
/
TimeZone
"
nullptr
0
}
{
"
"
nullptr
0
}
#
ifdef
_MSC_VER
{
"
localtime
"
reinterpret_cast
<
char
*
>
(
America_Los_Angeles
)
America_Los_Angeles_len
}
#
else
{
"
/
etc
/
localtime
"
reinterpret_cast
<
char
*
>
(
America_Los_Angeles
)
America_Los_Angeles_len
}
#
endif
}
;
class
TestZoneInfoSource
:
public
cctz
:
:
ZoneInfoSource
{
public
:
TestZoneInfoSource
(
const
char
*
data
std
:
:
size_t
size
)
:
data_
(
data
)
end_
(
data
+
size
)
{
}
std
:
:
size_t
Read
(
void
*
ptr
std
:
:
size_t
size
)
override
{
const
std
:
:
size_t
len
=
std
:
:
min
<
std
:
:
size_t
>
(
size
end_
-
data_
)
;
memcpy
(
ptr
data_
len
)
;
data_
+
=
len
;
return
len
;
}
int
Skip
(
std
:
:
size_t
offset
)
override
{
data_
+
=
std
:
:
min
<
std
:
:
size_t
>
(
offset
end_
-
data_
)
;
return
0
;
}
private
:
const
char
*
data_
;
const
char
*
const
end_
;
}
;
std
:
:
unique_ptr
<
cctz
:
:
ZoneInfoSource
>
TestFactory
(
const
std
:
:
string
&
name
const
std
:
:
function
<
std
:
:
unique_ptr
<
cctz
:
:
ZoneInfoSource
>
(
const
std
:
:
string
&
name
)
>
&
)
{
for
(
const
ZoneInfo
&
zoneinfo
:
kZoneInfo
)
{
if
(
name
=
=
zoneinfo
.
name
)
{
if
(
zoneinfo
.
data
=
=
nullptr
)
return
nullptr
;
return
std
:
:
unique_ptr
<
cctz
:
:
ZoneInfoSource
>
(
new
TestZoneInfoSource
(
zoneinfo
.
data
zoneinfo
.
length
)
)
;
}
}
return
nullptr
;
}
}
#
if
!
defined
(
__MINGW32__
)
ZoneInfoSourceFactory
zone_info_source_factory
=
TestFactory
;
#
endif
}
}
ABSL_NAMESPACE_END
}
