#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
flags
/
flag
.
h
"
#
include
"
absl
/
flags
/
marshalling
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
time
/
time
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
benchmark
/
benchmark
.
h
"
namespace
{
using
String
=
std
:
:
string
;
using
VectorOfStrings
=
std
:
:
vector
<
std
:
:
string
>
;
using
AbslDuration
=
absl
:
:
Duration
;
using
AbslOptionalInt
=
absl
:
:
optional
<
int
>
;
struct
OptionalInt
:
AbslOptionalInt
{
using
AbslOptionalInt
:
:
AbslOptionalInt
;
}
;
bool
AbslParseFlag
(
absl
:
:
string_view
src
OptionalInt
*
flag
std
:
:
string
*
error
)
{
int
val
;
if
(
src
.
empty
(
)
)
flag
-
>
reset
(
)
;
else
if
(
!
absl
:
:
ParseFlag
(
src
&
val
error
)
)
return
false
;
*
flag
=
val
;
return
true
;
}
std
:
:
string
AbslUnparseFlag
(
const
OptionalInt
&
flag
)
{
return
!
flag
?
"
"
:
absl
:
:
UnparseFlag
(
*
flag
)
;
}
using
AbslOptionalString
=
absl
:
:
optional
<
std
:
:
string
>
;
struct
OptionalString
:
AbslOptionalString
{
using
AbslOptionalString
:
:
AbslOptionalString
;
}
;
bool
AbslParseFlag
(
absl
:
:
string_view
src
OptionalString
*
flag
std
:
:
string
*
error
)
{
std
:
:
string
val
;
if
(
src
.
empty
(
)
)
flag
-
>
reset
(
)
;
else
if
(
!
absl
:
:
ParseFlag
(
src
&
val
error
)
)
return
false
;
*
flag
=
val
;
return
true
;
}
std
:
:
string
AbslUnparseFlag
(
const
OptionalString
&
flag
)
{
return
!
flag
?
"
"
:
absl
:
:
UnparseFlag
(
*
flag
)
;
}
struct
UDT
{
UDT
(
)
=
default
;
UDT
(
const
UDT
&
)
{
}
UDT
&
operator
=
(
const
UDT
&
)
{
return
*
this
;
}
}
;
bool
AbslParseFlag
(
absl
:
:
string_view
UDT
*
std
:
:
string
*
)
{
return
true
;
}
std
:
:
string
AbslUnparseFlag
(
const
UDT
&
)
{
return
"
"
;
}
}
#
define
BENCHMARKED_TYPES
(
A
)
\
A
(
bool
)
\
A
(
int16_t
)
\
A
(
uint16_t
)
\
A
(
int32_t
)
\
A
(
uint32_t
)
\
A
(
int64_t
)
\
A
(
uint64_t
)
\
A
(
double
)
\
A
(
float
)
\
A
(
String
)
\
A
(
VectorOfStrings
)
\
A
(
OptionalInt
)
\
A
(
OptionalString
)
\
A
(
AbslDuration
)
\
A
(
UDT
)
#
define
FLAG_DEF
(
T
)
ABSL_FLAG
(
T
T
#
#
_flag
{
}
"
"
)
;
BENCHMARKED_TYPES
(
FLAG_DEF
)
namespace
{
#
define
BM_GetFlag
(
T
)
\
void
BM_GetFlag_
#
#
T
(
benchmark
:
:
State
&
state
)
{
\
for
(
auto
_
:
state
)
{
\
benchmark
:
:
DoNotOptimize
(
absl
:
:
GetFlag
(
FLAGS_
#
#
T
#
#
_flag
)
)
;
\
}
\
}
\
BENCHMARK
(
BM_GetFlag_
#
#
T
)
;
BENCHMARKED_TYPES
(
BM_GetFlag
)
}
#
define
InvokeGetFlag
(
T
)
\
T
AbslInvokeGetFlag
#
#
T
(
)
{
return
absl
:
:
GetFlag
(
FLAGS_
#
#
T
#
#
_flag
)
;
}
\
int
odr
#
#
T
=
(
benchmark
:
:
DoNotOptimize
(
AbslInvokeGetFlag
#
#
T
)
1
)
;
BENCHMARKED_TYPES
(
InvokeGetFlag
)
