#
ifndef
ABSL_FLAGS_FLAG_H_
#
define
ABSL_FLAGS_FLAG_H_
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
optimization
.
h
"
#
include
"
absl
/
flags
/
config
.
h
"
#
include
"
absl
/
flags
/
internal
/
flag
.
h
"
#
include
"
absl
/
flags
/
internal
/
registry
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
#
if
!
defined
(
_MSC_VER
)
|
|
defined
(
__clang__
)
template
<
typename
T
>
using
Flag
=
flags_internal
:
:
Flag
<
T
>
;
#
else
namespace
flags_internal
{
absl
:
:
Mutex
*
GetGlobalConstructionGuard
(
)
;
}
template
<
typename
T
>
class
Flag
{
public
:
#
if
_MSC_VER
<
=
1900
constexpr
Flag
(
const
char
*
name
const
char
*
filename
const
flags_internal
:
:
HelpGenFunc
help_gen
const
flags_internal
:
:
FlagDfltGenFunc
default_value_gen
)
:
name_
(
name
)
filename_
(
filename
)
help_gen_
(
help_gen
)
default_value_gen_
(
default_value_gen
)
inited_
(
false
)
impl_
(
nullptr
)
{
}
#
endif
flags_internal
:
:
Flag
<
T
>
&
GetImpl
(
)
const
{
if
(
!
inited_
.
load
(
std
:
:
memory_order_acquire
)
)
{
absl
:
:
MutexLock
l
(
flags_internal
:
:
GetGlobalConstructionGuard
(
)
)
;
if
(
inited_
.
load
(
std
:
:
memory_order_acquire
)
)
{
return
*
impl_
;
}
impl_
=
new
flags_internal
:
:
Flag
<
T
>
(
name_
filename_
{
flags_internal
:
:
FlagHelpMsg
(
help_gen_
)
flags_internal
:
:
FlagHelpKind
:
:
kGenFunc
}
{
flags_internal
:
:
FlagDefaultSrc
(
default_value_gen_
)
flags_internal
:
:
FlagDefaultKind
:
:
kGenFunc
}
)
;
inited_
.
store
(
true
std
:
:
memory_order_release
)
;
}
return
*
impl_
;
}
bool
IsRetired
(
)
const
{
return
GetImpl
(
)
.
IsRetired
(
)
;
}
absl
:
:
string_view
Name
(
)
const
{
return
GetImpl
(
)
.
Name
(
)
;
}
std
:
:
string
Help
(
)
const
{
return
GetImpl
(
)
.
Help
(
)
;
}
bool
IsModified
(
)
const
{
return
GetImpl
(
)
.
IsModified
(
)
;
}
bool
IsSpecifiedOnCommandLine
(
)
const
{
return
GetImpl
(
)
.
IsSpecifiedOnCommandLine
(
)
;
}
std
:
:
string
Filename
(
)
const
{
return
GetImpl
(
)
.
Filename
(
)
;
}
std
:
:
string
DefaultValue
(
)
const
{
return
GetImpl
(
)
.
DefaultValue
(
)
;
}
std
:
:
string
CurrentValue
(
)
const
{
return
GetImpl
(
)
.
CurrentValue
(
)
;
}
template
<
typename
U
>
inline
bool
IsOfType
(
)
const
{
return
GetImpl
(
)
.
template
IsOfType
<
U
>
(
)
;
}
T
Get
(
)
const
{
return
flags_internal
:
:
FlagImplPeer
:
:
InvokeGet
<
T
>
(
GetImpl
(
)
)
;
}
void
Set
(
const
T
&
v
)
{
flags_internal
:
:
FlagImplPeer
:
:
InvokeSet
(
GetImpl
(
)
v
)
;
}
void
InvokeCallback
(
)
{
GetImpl
(
)
.
InvokeCallback
(
)
;
}
const
CommandLineFlag
&
Reflect
(
)
const
{
return
flags_internal
:
:
FlagImplPeer
:
:
InvokeReflect
(
GetImpl
(
)
)
;
}
const
char
*
name_
;
const
char
*
filename_
;
const
flags_internal
:
:
HelpGenFunc
help_gen_
;
const
flags_internal
:
:
FlagDfltGenFunc
default_value_gen_
;
mutable
std
:
:
atomic
<
bool
>
inited_
;
mutable
flags_internal
:
:
Flag
<
T
>
*
impl_
;
}
;
#
endif
template
<
typename
T
>
ABSL_MUST_USE_RESULT
T
GetFlag
(
const
absl
:
:
Flag
<
T
>
&
flag
)
{
return
flags_internal
:
:
FlagImplPeer
:
:
InvokeGet
<
T
>
(
flag
)
;
}
template
<
typename
T
>
void
SetFlag
(
absl
:
:
Flag
<
T
>
*
flag
const
T
&
v
)
{
flags_internal
:
:
FlagImplPeer
:
:
InvokeSet
(
*
flag
v
)
;
}
template
<
typename
T
typename
V
>
void
SetFlag
(
absl
:
:
Flag
<
T
>
*
flag
const
V
&
v
)
{
T
value
(
v
)
;
flags_internal
:
:
FlagImplPeer
:
:
InvokeSet
(
*
flag
value
)
;
}
template
<
typename
T
>
const
CommandLineFlag
&
GetFlagReflectionHandle
(
const
absl
:
:
Flag
<
T
>
&
f
)
{
return
flags_internal
:
:
FlagImplPeer
:
:
InvokeReflect
(
f
)
;
}
ABSL_NAMESPACE_END
}
#
define
ABSL_FLAG
(
Type
name
default_value
help
)
\
ABSL_FLAG_IMPL
(
Type
name
default_value
help
)
#
if
!
defined
(
_MSC_VER
)
|
|
defined
(
__clang__
)
#
define
ABSL_FLAG_IMPL_FLAG_PTR
(
flag
)
flag
#
define
ABSL_FLAG_IMPL_HELP_ARG
(
name
)
\
absl
:
:
flags_internal
:
:
HelpArg
<
AbslFlagHelpGenFor
#
#
name
>
(
\
FLAGS_help_storage_
#
#
name
)
#
define
ABSL_FLAG_IMPL_DEFAULT_ARG
(
Type
name
)
\
absl
:
:
flags_internal
:
:
DefaultArg
<
Type
AbslFlagDefaultGenFor
#
#
name
>
(
0
)
#
else
#
define
ABSL_FLAG_IMPL_FLAG_PTR
(
flag
)
flag
.
GetImpl
(
)
#
define
ABSL_FLAG_IMPL_HELP_ARG
(
name
)
&
AbslFlagHelpGenFor
#
#
name
:
:
NonConst
#
define
ABSL_FLAG_IMPL_DEFAULT_ARG
(
Type
name
)
&
AbslFlagDefaultGenFor
#
#
name
:
:
Gen
#
endif
#
if
ABSL_FLAGS_STRIP_NAMES
#
define
ABSL_FLAG_IMPL_FLAGNAME
(
txt
)
"
"
#
define
ABSL_FLAG_IMPL_FILENAME
(
)
"
"
#
define
ABSL_FLAG_IMPL_REGISTRAR
(
T
flag
)
\
absl
:
:
flags_internal
:
:
FlagRegistrar
<
T
false
>
(
ABSL_FLAG_IMPL_FLAG_PTR
(
flag
)
\
nullptr
)
#
else
#
define
ABSL_FLAG_IMPL_FLAGNAME
(
txt
)
txt
#
define
ABSL_FLAG_IMPL_FILENAME
(
)
__FILE__
#
define
ABSL_FLAG_IMPL_REGISTRAR
(
T
flag
)
\
absl
:
:
flags_internal
:
:
FlagRegistrar
<
T
true
>
(
ABSL_FLAG_IMPL_FLAG_PTR
(
flag
)
\
__FILE__
)
#
endif
#
if
ABSL_FLAGS_STRIP_HELP
#
define
ABSL_FLAG_IMPL_FLAGHELP
(
txt
)
absl
:
:
flags_internal
:
:
kStrippedFlagHelp
#
else
#
define
ABSL_FLAG_IMPL_FLAGHELP
(
txt
)
txt
#
endif
#
define
ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER
(
name
txt
)
\
struct
AbslFlagHelpGenFor
#
#
name
{
\
/
*
The
expression
is
run
in
the
caller
as
part
of
the
*
/
\
/
*
default
value
argument
.
That
keeps
temporaries
alive
*
/
\
/
*
long
enough
for
NonConst
to
work
correctly
.
*
/
\
static
constexpr
absl
:
:
string_view
Value
(
\
absl
:
:
string_view
v
=
ABSL_FLAG_IMPL_FLAGHELP
(
txt
)
)
{
\
return
v
;
\
}
\
static
std
:
:
string
NonConst
(
)
{
return
std
:
:
string
(
Value
(
)
)
;
}
\
}
;
\
constexpr
auto
FLAGS_help_storage_
#
#
name
ABSL_INTERNAL_UNIQUE_SMALL_NAME
(
)
\
ABSL_ATTRIBUTE_SECTION_VARIABLE
(
flags_help_cold
)
=
\
absl
:
:
flags_internal
:
:
HelpStringAsArray
<
AbslFlagHelpGenFor
#
#
name
>
(
\
0
)
;
#
define
ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER
(
name
Type
default_value
)
\
struct
AbslFlagDefaultGenFor
#
#
name
{
\
Type
value
=
absl
:
:
flags_internal
:
:
InitDefaultValue
<
Type
>
(
default_value
)
;
\
static
void
Gen
(
void
*
p
)
{
\
new
(
p
)
Type
(
AbslFlagDefaultGenFor
#
#
name
{
}
.
value
)
;
\
}
\
}
;
#
define
ABSL_FLAG_IMPL
(
Type
name
default_value
help
)
\
namespace
absl
/
*
block
flags
in
namespaces
*
/
{
}
\
ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER
(
name
Type
default_value
)
\
ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER
(
name
help
)
\
ABSL_CONST_INIT
absl
:
:
Flag
<
Type
>
FLAGS_
#
#
name
{
\
ABSL_FLAG_IMPL_FLAGNAME
(
#
name
)
ABSL_FLAG_IMPL_FILENAME
(
)
\
ABSL_FLAG_IMPL_HELP_ARG
(
name
)
ABSL_FLAG_IMPL_DEFAULT_ARG
(
Type
name
)
}
;
\
extern
absl
:
:
flags_internal
:
:
FlagRegistrarEmpty
FLAGS_no
#
#
name
;
\
absl
:
:
flags_internal
:
:
FlagRegistrarEmpty
FLAGS_no
#
#
name
=
\
ABSL_FLAG_IMPL_REGISTRAR
(
Type
FLAGS_
#
#
name
)
#
define
ABSL_RETIRED_FLAG
(
type
name
default_value
explanation
)
\
static
absl
:
:
flags_internal
:
:
RetiredFlag
<
type
>
RETIRED_FLAGS_
#
#
name
;
\
ABSL_ATTRIBUTE_UNUSED
static
const
auto
RETIRED_FLAGS_REG_
#
#
name
=
\
(
RETIRED_FLAGS_
#
#
name
.
Retire
(
#
name
)
\
:
:
absl
:
:
flags_internal
:
:
FlagRegistrarEmpty
{
}
)
#
endif
