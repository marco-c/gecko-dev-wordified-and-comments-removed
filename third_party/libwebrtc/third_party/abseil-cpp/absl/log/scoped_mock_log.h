#
ifndef
ABSL_LOG_SCOPED_MOCK_LOG_H_
#
define
ABSL_LOG_SCOPED_MOCK_LOG_H_
#
include
<
atomic
>
#
include
<
string
>
#
include
"
gmock
/
gmock
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
log_severity
.
h
"
#
include
"
absl
/
log
/
log_entry
.
h
"
#
include
"
absl
/
log
/
log_sink
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
enum
class
MockLogDefault
{
kIgnoreUnexpected
kDisallowUnexpected
}
;
class
ScopedMockLog
final
{
public
:
explicit
ScopedMockLog
(
MockLogDefault
default_exp
=
MockLogDefault
:
:
kIgnoreUnexpected
)
;
ScopedMockLog
(
const
ScopedMockLog
&
)
=
delete
;
ScopedMockLog
&
operator
=
(
const
ScopedMockLog
&
)
=
delete
;
~
ScopedMockLog
(
)
;
void
StartCapturingLogs
(
)
;
void
StopCapturingLogs
(
)
;
absl
:
:
LogSink
&
UseAsLocalSink
(
)
;
MOCK_METHOD
(
void
Log
(
absl
:
:
LogSeverity
severity
const
std
:
:
string
&
file_path
const
std
:
:
string
&
message
)
)
;
MOCK_METHOD
(
void
Send
(
const
absl
:
:
LogEntry
&
)
)
;
MOCK_METHOD
(
void
Flush
(
)
)
;
private
:
class
ForwardingSink
final
:
public
absl
:
:
LogSink
{
public
:
explicit
ForwardingSink
(
ScopedMockLog
*
sml
)
:
sml_
(
sml
)
{
}
ForwardingSink
(
const
ForwardingSink
&
)
=
delete
;
ForwardingSink
&
operator
=
(
const
ForwardingSink
&
)
=
delete
;
void
Send
(
const
absl
:
:
LogEntry
&
entry
)
override
{
sml_
-
>
Send
(
entry
)
;
}
void
Flush
(
)
override
{
sml_
-
>
Flush
(
)
;
}
private
:
ScopedMockLog
*
sml_
;
}
;
ForwardingSink
sink_
;
bool
is_capturing_logs_
;
std
:
:
atomic
<
bool
>
is_triggered_
;
}
;
ABSL_NAMESPACE_END
}
#
endif
