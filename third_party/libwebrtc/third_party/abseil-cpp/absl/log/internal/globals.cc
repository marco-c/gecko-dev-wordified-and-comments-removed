#
include
"
absl
/
log
/
internal
/
globals
.
h
"
#
include
<
atomic
>
#
include
<
cstdio
>
#
if
defined
(
__EMSCRIPTEN__
)
#
include
<
emscripten
/
console
.
h
>
#
endif
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
base
/
config
.
h
"
#
include
"
absl
/
base
/
internal
/
raw_logging
.
h
"
#
include
"
absl
/
base
/
log_severity
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
strings
/
strip
.
h
"
#
include
"
absl
/
time
/
time
.
h
"
namespace
absl
{
ABSL_NAMESPACE_BEGIN
namespace
log_internal
{
namespace
{
ABSL_CONST_INIT
std
:
:
atomic
<
bool
>
logging_initialized
(
false
)
;
ABSL_CONST_INIT
std
:
:
atomic
<
absl
:
:
TimeZone
*
>
timezone_ptr
{
nullptr
}
;
ABSL_CONST_INIT
std
:
:
atomic
<
bool
>
symbolize_stack_trace
(
true
)
;
ABSL_CONST_INIT
std
:
:
atomic
<
int
>
max_frames_in_stack_trace
(
64
)
;
ABSL_CONST_INIT
std
:
:
atomic
<
bool
>
exit_on_dfatal
(
true
)
;
ABSL_CONST_INIT
std
:
:
atomic
<
bool
>
suppress_sigabort_trace
(
false
)
;
}
bool
IsInitialized
(
)
{
return
logging_initialized
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
SetInitialized
(
)
{
logging_initialized
.
store
(
true
std
:
:
memory_order_release
)
;
}
void
WriteToStderr
(
absl
:
:
string_view
message
absl
:
:
LogSeverity
severity
)
{
if
(
message
.
empty
(
)
)
return
;
#
if
defined
(
__EMSCRIPTEN__
)
const
auto
message_minus_newline
=
absl
:
:
StripSuffix
(
message
"
\
n
"
)
;
#
if
ABSL_INTERNAL_EMSCRIPTEN_VERSION
>
=
3001043
emscripten_errn
(
message_minus_newline
.
data
(
)
message_minus_newline
.
size
(
)
)
;
#
else
std
:
:
string
null_terminated_message
(
message_minus_newline
)
;
_emscripten_err
(
null_terminated_message
.
c_str
(
)
)
;
#
endif
#
else
std
:
:
fwrite
(
message
.
data
(
)
message
.
size
(
)
1
stderr
)
;
#
endif
#
if
defined
(
_WIN64
)
|
|
defined
(
_WIN32
)
|
|
defined
(
_WIN16
)
if
(
severity
>
=
absl
:
:
LogSeverity
:
:
kWarning
)
{
std
:
:
fflush
(
stderr
)
;
}
#
else
(
void
)
severity
;
#
endif
}
void
SetTimeZone
(
absl
:
:
TimeZone
tz
)
{
absl
:
:
TimeZone
*
expected
=
nullptr
;
absl
:
:
TimeZone
*
new_tz
=
new
absl
:
:
TimeZone
(
tz
)
;
if
(
!
timezone_ptr
.
compare_exchange_strong
(
expected
new_tz
std
:
:
memory_order_release
std
:
:
memory_order_relaxed
)
)
{
ABSL_RAW_LOG
(
FATAL
"
absl
:
:
log_internal
:
:
SetTimeZone
(
)
has
already
been
called
"
)
;
}
}
const
absl
:
:
TimeZone
*
TimeZone
(
)
{
return
timezone_ptr
.
load
(
std
:
:
memory_order_acquire
)
;
}
bool
ShouldSymbolizeLogStackTrace
(
)
{
return
symbolize_stack_trace
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
EnableSymbolizeLogStackTrace
(
bool
on_off
)
{
symbolize_stack_trace
.
store
(
on_off
std
:
:
memory_order_release
)
;
}
int
MaxFramesInLogStackTrace
(
)
{
return
max_frames_in_stack_trace
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
SetMaxFramesInLogStackTrace
(
int
max_num_frames
)
{
max_frames_in_stack_trace
.
store
(
max_num_frames
std
:
:
memory_order_release
)
;
}
bool
ExitOnDFatal
(
)
{
return
exit_on_dfatal
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
SetExitOnDFatal
(
bool
on_off
)
{
exit_on_dfatal
.
store
(
on_off
std
:
:
memory_order_release
)
;
}
bool
SuppressSigabortTrace
(
)
{
return
suppress_sigabort_trace
.
load
(
std
:
:
memory_order_acquire
)
;
}
bool
SetSuppressSigabortTrace
(
bool
on_off
)
{
return
suppress_sigabort_trace
.
exchange
(
on_off
)
;
}
}
ABSL_NAMESPACE_END
}
