#
ifndef
BASE_COMMANDLINEFLAGS_H_
#
define
BASE_COMMANDLINEFLAGS_H_
#
include
<
string
>
#
include
<
vector
>
#
include
<
gflags
/
gflags_declare
.
h
>
namespace
google
{
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
GFLAGS_DLL_DECL
)
#
define
GFLAGS_DLL_DECL
__declspec
(
dllimport
)
#
endif
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
GFLAGS_DLL_DEFINE_FLAG
)
#
define
GFLAGS_DLL_DEFINE_FLAG
__declspec
(
dllexport
)
#
endif
extern
GFLAGS_DLL_DECL
bool
RegisterFlagValidator
(
const
bool
*
flag
bool
(
*
validate_fn
)
(
const
char
*
bool
)
)
;
extern
GFLAGS_DLL_DECL
bool
RegisterFlagValidator
(
const
int32
*
flag
bool
(
*
validate_fn
)
(
const
char
*
int32
)
)
;
extern
GFLAGS_DLL_DECL
bool
RegisterFlagValidator
(
const
int64
*
flag
bool
(
*
validate_fn
)
(
const
char
*
int64
)
)
;
extern
GFLAGS_DLL_DECL
bool
RegisterFlagValidator
(
const
uint64
*
flag
bool
(
*
validate_fn
)
(
const
char
*
uint64
)
)
;
extern
GFLAGS_DLL_DECL
bool
RegisterFlagValidator
(
const
double
*
flag
bool
(
*
validate_fn
)
(
const
char
*
double
)
)
;
extern
GFLAGS_DLL_DECL
bool
RegisterFlagValidator
(
const
std
:
:
string
*
flag
bool
(
*
validate_fn
)
(
const
char
*
const
std
:
:
string
&
)
)
;
struct
GFLAGS_DLL_DECL
CommandLineFlagInfo
{
std
:
:
string
name
;
std
:
:
string
type
;
std
:
:
string
description
;
std
:
:
string
current_value
;
std
:
:
string
default_value
;
std
:
:
string
filename
;
bool
has_validator_fn
;
bool
is_default
;
const
void
*
flag_ptr
;
}
;
extern
GFLAGS_DLL_DECL
void
GetAllFlags
(
std
:
:
vector
<
CommandLineFlagInfo
>
*
OUTPUT
)
;
extern
GFLAGS_DLL_DECL
void
ShowUsageWithFlags
(
const
char
*
argv0
)
;
extern
GFLAGS_DLL_DECL
void
ShowUsageWithFlagsRestrict
(
const
char
*
argv0
const
char
*
restrict
)
;
extern
GFLAGS_DLL_DECL
std
:
:
string
DescribeOneFlag
(
const
CommandLineFlagInfo
&
flag
)
;
extern
GFLAGS_DLL_DECL
void
SetArgv
(
int
argc
const
char
*
*
argv
)
;
extern
GFLAGS_DLL_DECL
const
std
:
:
vector
<
std
:
:
string
>
&
GetArgvs
(
)
;
extern
GFLAGS_DLL_DECL
const
char
*
GetArgv
(
)
;
extern
GFLAGS_DLL_DECL
const
char
*
GetArgv0
(
)
;
extern
GFLAGS_DLL_DECL
uint32
GetArgvSum
(
)
;
extern
GFLAGS_DLL_DECL
const
char
*
ProgramInvocationName
(
)
;
extern
GFLAGS_DLL_DECL
const
char
*
ProgramInvocationShortName
(
)
;
extern
GFLAGS_DLL_DECL
const
char
*
ProgramUsage
(
)
;
extern
GFLAGS_DLL_DECL
const
char
*
VersionString
(
)
;
extern
GFLAGS_DLL_DECL
bool
GetCommandLineOption
(
const
char
*
name
std
:
:
string
*
OUTPUT
)
;
extern
GFLAGS_DLL_DECL
bool
GetCommandLineFlagInfo
(
const
char
*
name
CommandLineFlagInfo
*
OUTPUT
)
;
extern
GFLAGS_DLL_DECL
CommandLineFlagInfo
GetCommandLineFlagInfoOrDie
(
const
char
*
name
)
;
enum
GFLAGS_DLL_DECL
FlagSettingMode
{
SET_FLAGS_VALUE
SET_FLAG_IF_DEFAULT
SET_FLAGS_DEFAULT
}
;
extern
GFLAGS_DLL_DECL
std
:
:
string
SetCommandLineOption
(
const
char
*
name
const
char
*
value
)
;
extern
GFLAGS_DLL_DECL
std
:
:
string
SetCommandLineOptionWithMode
(
const
char
*
name
const
char
*
value
FlagSettingMode
set_mode
)
;
class
GFLAGS_DLL_DECL
FlagSaver
{
public
:
FlagSaver
(
)
;
~
FlagSaver
(
)
;
private
:
class
FlagSaverImpl
*
impl_
;
FlagSaver
(
const
FlagSaver
&
)
;
void
operator
=
(
const
FlagSaver
&
)
;
}
;
extern
GFLAGS_DLL_DECL
std
:
:
string
CommandlineFlagsIntoString
(
)
;
extern
GFLAGS_DLL_DECL
bool
ReadFlagsFromString
(
const
std
:
:
string
&
flagfilecontents
const
char
*
prog_name
bool
errors_are_fatal
)
;
extern
GFLAGS_DLL_DECL
bool
AppendFlagsIntoFile
(
const
std
:
:
string
&
filename
const
char
*
prog_name
)
;
extern
GFLAGS_DLL_DECL
bool
ReadFromFlagsFile
(
const
std
:
:
string
&
filename
const
char
*
prog_name
bool
errors_are_fatal
)
;
extern
GFLAGS_DLL_DECL
bool
BoolFromEnv
(
const
char
*
varname
bool
defval
)
;
extern
GFLAGS_DLL_DECL
int32
Int32FromEnv
(
const
char
*
varname
int32
defval
)
;
extern
GFLAGS_DLL_DECL
int64
Int64FromEnv
(
const
char
*
varname
int64
defval
)
;
extern
GFLAGS_DLL_DECL
uint64
Uint64FromEnv
(
const
char
*
varname
uint64
defval
)
;
extern
GFLAGS_DLL_DECL
double
DoubleFromEnv
(
const
char
*
varname
double
defval
)
;
extern
GFLAGS_DLL_DECL
const
char
*
StringFromEnv
(
const
char
*
varname
const
char
*
defval
)
;
extern
GFLAGS_DLL_DECL
void
SetUsageMessage
(
const
std
:
:
string
&
usage
)
;
extern
GFLAGS_DLL_DECL
void
SetVersionString
(
const
std
:
:
string
&
version
)
;
#
ifndef
SWIG
extern
GFLAGS_DLL_DECL
uint32
ParseCommandLineFlags
(
int
*
argc
char
*
*
*
argv
bool
remove_flags
)
;
#
endif
extern
GFLAGS_DLL_DECL
uint32
ParseCommandLineNonHelpFlags
(
int
*
argc
char
*
*
*
argv
bool
remove_flags
)
;
extern
GFLAGS_DLL_DECL
void
HandleCommandLineHelpFlags
(
)
;
extern
GFLAGS_DLL_DECL
void
AllowCommandLineReparsing
(
)
;
extern
GFLAGS_DLL_DECL
void
ReparseCommandLineNonHelpFlags
(
)
;
extern
GFLAGS_DLL_DECL
void
ShutDownCommandLineFlags
(
)
;
class
GFLAGS_DLL_DECL
FlagRegisterer
{
public
:
FlagRegisterer
(
const
char
*
name
const
char
*
type
const
char
*
help
const
char
*
filename
void
*
current_storage
void
*
defvalue_storage
)
;
}
;
extern
GFLAGS_DLL_DECL
const
char
kStrippedFlagHelp
[
]
;
}
#
ifndef
SWIG
#
if
defined
(
STRIP_FLAG_HELP
)
&
&
STRIP_FLAG_HELP
>
0
#
define
MAYBE_STRIPPED_HELP
(
txt
)
\
(
false
?
(
txt
)
:
:
:
google
:
:
kStrippedFlagHelp
)
#
else
#
define
MAYBE_STRIPPED_HELP
(
txt
)
txt
#
endif
#
define
DEFINE_VARIABLE
(
type
shorttype
name
value
help
)
\
namespace
fL
#
#
shorttype
{
\
static
const
type
FLAGS_nono
#
#
name
=
value
;
\
/
*
We
always
want
to
export
defined
variables
dll
or
no
*
/
\
GFLAGS_DLL_DEFINE_FLAG
type
FLAGS_
#
#
name
=
FLAGS_nono
#
#
name
;
\
type
FLAGS_no
#
#
name
=
FLAGS_nono
#
#
name
;
\
static
:
:
google
:
:
FlagRegisterer
o_
#
#
name
(
\
#
name
#
type
MAYBE_STRIPPED_HELP
(
help
)
__FILE__
\
&
FLAGS_
#
#
name
&
FLAGS_no
#
#
name
)
;
\
}
\
using
fL
#
#
shorttype
:
:
FLAGS_
#
#
name
namespace
fLB
{
struct
CompileAssert
{
}
;
typedef
CompileAssert
expected_sizeof_double_neq_sizeof_bool
[
(
sizeof
(
double
)
!
=
sizeof
(
bool
)
)
?
1
:
-
1
]
;
template
<
typename
From
>
double
GFLAGS_DLL_DECL
IsBoolFlag
(
const
From
&
from
)
;
GFLAGS_DLL_DECL
bool
IsBoolFlag
(
bool
from
)
;
}
#
define
DEFINE_bool
(
name
val
txt
)
\
namespace
fLB
{
\
typedef
:
:
fLB
:
:
CompileAssert
FLAG_
#
#
name
#
#
_value_is_not_a_bool
[
\
(
sizeof
(
:
:
fLB
:
:
IsBoolFlag
(
val
)
)
!
=
sizeof
(
double
)
)
?
1
:
-
1
]
;
\
}
\
DEFINE_VARIABLE
(
bool
B
name
val
txt
)
#
define
DEFINE_int32
(
name
val
txt
)
\
DEFINE_VARIABLE
(
:
:
google
:
:
int32
I
\
name
val
txt
)
#
define
DEFINE_int64
(
name
val
txt
)
\
DEFINE_VARIABLE
(
:
:
google
:
:
int64
I64
\
name
val
txt
)
#
define
DEFINE_uint64
(
name
val
txt
)
\
DEFINE_VARIABLE
(
:
:
google
:
:
uint64
U64
\
name
val
txt
)
#
define
DEFINE_double
(
name
val
txt
)
\
DEFINE_VARIABLE
(
double
D
name
val
txt
)
namespace
fLS
{
inline
clstring
*
dont_pass0toDEFINE_string
(
char
*
stringspot
const
char
*
value
)
{
return
new
(
stringspot
)
clstring
(
value
)
;
}
inline
clstring
*
dont_pass0toDEFINE_string
(
char
*
stringspot
const
clstring
&
value
)
{
return
new
(
stringspot
)
clstring
(
value
)
;
}
inline
clstring
*
dont_pass0toDEFINE_string
(
char
*
stringspot
int
value
)
;
}
#
define
DEFINE_string
(
name
val
txt
)
\
namespace
fLS
{
\
using
:
:
fLS
:
:
clstring
;
\
static
union
{
void
*
align
;
char
s
[
sizeof
(
clstring
)
]
;
}
s_
#
#
name
[
2
]
;
\
clstring
*
const
FLAGS_no
#
#
name
=
:
:
fLS
:
:
\
dont_pass0toDEFINE_string
(
s_
#
#
name
[
0
]
.
s
\
val
)
;
\
static
:
:
google
:
:
FlagRegisterer
o_
#
#
name
(
\
#
name
"
string
"
MAYBE_STRIPPED_HELP
(
txt
)
__FILE__
\
s_
#
#
name
[
0
]
.
s
new
(
s_
#
#
name
[
1
]
.
s
)
clstring
(
*
FLAGS_no
#
#
name
)
)
;
\
extern
GFLAGS_DLL_DEFINE_FLAG
clstring
&
FLAGS_
#
#
name
;
\
using
fLS
:
:
FLAGS_
#
#
name
;
\
clstring
&
FLAGS_
#
#
name
=
*
FLAGS_no
#
#
name
;
\
}
\
using
fLS
:
:
FLAGS_
#
#
name
#
endif
#
endif
