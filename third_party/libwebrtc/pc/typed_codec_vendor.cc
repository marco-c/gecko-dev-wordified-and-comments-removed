#
include
"
pc
/
typed_codec_vendor
.
h
"
#
include
<
stddef
.
h
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
media_types
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
codec_list
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
media
/
base
/
media_engine
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
namespace
{
std
:
:
vector
<
Codec
>
CollectAudioCodecs
(
const
std
:
:
vector
<
AudioCodecSpec
>
&
specs
)
{
std
:
:
vector
<
Codec
>
out
;
std
:
:
map
<
int
bool
std
:
:
greater
<
int
>
>
generate_cn
=
{
{
8000
false
}
}
;
std
:
:
map
<
int
bool
std
:
:
greater
<
int
>
>
generate_dtmf
=
{
{
8000
false
}
{
48000
false
}
}
;
for
(
const
auto
&
spec
:
specs
)
{
Codec
codec
=
CreateAudioCodec
(
spec
.
format
)
;
if
(
spec
.
info
.
supports_network_adaption
)
{
codec
.
AddFeedbackParam
(
FeedbackParam
(
cricket
:
:
kRtcpFbParamTransportCc
cricket
:
:
kParamValueEmpty
)
)
;
}
if
(
spec
.
info
.
allow_comfort_noise
)
{
auto
cn
=
generate_cn
.
find
(
spec
.
format
.
clockrate_hz
)
;
if
(
cn
!
=
generate_cn
.
end
(
)
)
{
cn
-
>
second
=
true
;
}
}
auto
dtmf
=
generate_dtmf
.
find
(
spec
.
format
.
clockrate_hz
)
;
if
(
dtmf
!
=
generate_dtmf
.
end
(
)
)
{
dtmf
-
>
second
=
true
;
}
out
.
push_back
(
codec
)
;
if
(
codec
.
name
=
=
cricket
:
:
kOpusCodecName
)
{
Codec
red_codec
=
CreateAudioCodec
(
{
cricket
:
:
kRedCodecName
48000
2
}
)
;
out
.
push_back
(
red_codec
)
;
}
}
for
(
const
auto
&
cn
:
generate_cn
)
{
if
(
cn
.
second
)
{
Codec
cn_codec
=
CreateAudioCodec
(
{
cricket
:
:
kCnCodecName
cn
.
first
1
}
)
;
out
.
push_back
(
cn_codec
)
;
}
}
for
(
const
auto
&
dtmf
:
generate_dtmf
)
{
if
(
dtmf
.
second
)
{
Codec
dtmf_codec
=
CreateAudioCodec
(
{
cricket
:
:
kDtmfCodecName
dtmf
.
first
1
}
)
;
out
.
push_back
(
dtmf_codec
)
;
}
}
return
out
;
}
}
TypedCodecVendor
:
:
TypedCodecVendor
(
cricket
:
:
MediaEngineInterface
*
media_engine
MediaType
type
bool
is_sender
bool
rtx_enabled
const
FieldTrialsView
&
trials
)
{
if
(
trials
.
IsEnabled
(
"
WebRTC
-
PayloadTypesInTransport
"
)
)
{
if
(
type
=
=
MediaType
:
:
AUDIO
)
{
if
(
is_sender
)
{
if
(
media_engine
-
>
voice
(
)
.
encoder_factory
(
)
)
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
CollectAudioCodecs
(
media_engine
-
>
voice
(
)
.
encoder_factory
(
)
-
>
GetSupportedEncoders
(
)
)
)
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
No
voice
encoder
factory
.
Should
only
happen
in
test
.
"
;
}
}
else
{
if
(
media_engine
-
>
voice
(
)
.
decoder_factory
(
)
)
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
CollectAudioCodecs
(
media_engine
-
>
voice
(
)
.
decoder_factory
(
)
-
>
GetSupportedDecoders
(
)
)
)
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
No
voice
decoder
factory
.
Should
only
happen
in
test
.
"
;
}
}
}
else
{
if
(
is_sender
)
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
media_engine
-
>
video
(
)
.
LegacySendCodecs
(
rtx_enabled
)
)
;
}
else
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
media_engine
-
>
video
(
)
.
LegacyRecvCodecs
(
rtx_enabled
)
)
;
}
}
}
else
{
if
(
type
=
=
MediaType
:
:
AUDIO
)
{
if
(
is_sender
)
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
media_engine
-
>
voice
(
)
.
LegacySendCodecs
(
)
)
;
}
else
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
media_engine
-
>
voice
(
)
.
LegacyRecvCodecs
(
)
)
;
}
}
else
{
if
(
is_sender
)
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
media_engine
-
>
video
(
)
.
LegacySendCodecs
(
rtx_enabled
)
)
;
}
else
{
codecs_
=
CodecList
:
:
CreateFromTrustedData
(
media_engine
-
>
video
(
)
.
LegacyRecvCodecs
(
rtx_enabled
)
)
;
}
}
}
}
}
