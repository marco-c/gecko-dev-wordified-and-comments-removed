#
include
<
stdint
.
h
>
#
include
<
atomic
>
#
include
<
cstdlib
>
#
include
<
iterator
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
api
/
data_channel_interface
.
h
"
#
include
"
api
/
dtls_transport_interface
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
peer_connection_interface
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sctp_transport_interface
.
h
"
#
include
"
api
/
stats
/
rtc_stats_report
.
h
"
#
include
"
api
/
stats
/
rtcstats_objects
.
h
"
#
include
"
api
/
test
/
rtc_error_matchers
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
base
/
transport_info
.
h
"
#
include
"
p2p
/
test
/
test_turn_server
.
h
"
#
include
"
pc
/
media_session
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
test
/
fake_rtc_certificate_generator
.
h
"
#
include
"
pc
/
test
/
integration_test_helpers
.
h
"
#
include
"
pc
/
test
/
mock_peer_connection_observers
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
rtc_base
/
task_queue_for_test
.
h
"
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
wait_until
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
IsTrue
;
using
:
:
testing
:
:
Ne
;
using
:
:
testing
:
:
ValuesIn
;
#
ifdef
WEBRTC_HAVE_SCTP
#
if
defined
(
WEBRTC_ANDROID
)
#
define
DISABLED_ON_ANDROID
(
t
)
DISABLED_
#
#
t
#
else
#
define
DISABLED_ON_ANDROID
(
t
)
t
#
endif
class
DataChannelIntegrationTest
:
public
PeerConnectionIntegrationBaseTest
public
:
:
testing
:
:
WithParamInterface
<
std
:
:
tuple
<
SdpSemantics
bool
>
>
{
protected
:
DataChannelIntegrationTest
(
)
:
PeerConnectionIntegrationBaseTest
(
std
:
:
get
<
0
>
(
GetParam
(
)
)
)
allow_media_
(
std
:
:
get
<
1
>
(
GetParam
(
)
)
)
{
}
bool
allow_media
(
)
{
return
allow_media_
;
}
bool
CreatePeerConnectionWrappers
(
)
{
if
(
allow_media_
)
{
return
PeerConnectionIntegrationBaseTest
:
:
CreatePeerConnectionWrappers
(
)
;
}
return
PeerConnectionIntegrationBaseTest
:
:
CreatePeerConnectionWrappersWithoutMediaEngine
(
)
;
}
private
:
const
bool
allow_media_
;
}
;
class
FakeClockForTest
:
public
ScopedFakeClock
{
protected
:
FakeClockForTest
(
)
{
AdvanceTime
(
TimeDelta
:
:
Seconds
(
1
)
)
;
}
ScopedFakeClock
&
FakeClock
(
)
{
return
*
this
;
}
}
;
class
DataChannelIntegrationTestPlanB
:
public
PeerConnectionIntegrationBaseTest
{
protected
:
DataChannelIntegrationTestPlanB
(
)
:
PeerConnectionIntegrationBaseTest
(
SdpSemantics
:
:
kPlanB_DEPRECATED
)
{
}
}
;
class
DataChannelIntegrationTestUnifiedPlan
:
public
PeerConnectionIntegrationBaseTest
{
protected
:
DataChannelIntegrationTestUnifiedPlan
(
)
:
PeerConnectionIntegrationBaseTest
(
SdpSemantics
:
:
kUnifiedPlan
)
{
}
}
;
void
MakeOfferHaveActiveDtlsRole
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
desc
)
{
auto
&
transport_infos
=
desc
-
>
description
(
)
-
>
transport_infos
(
)
;
for
(
auto
&
transport_info
:
transport_infos
)
{
transport_info
.
description
.
connection_role
=
cricket
:
:
CONNECTIONROLE_ACTIVE
;
}
}
void
MakeOfferHavePassiveDtlsRole
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
desc
)
{
auto
&
transport_infos
=
desc
-
>
description
(
)
-
>
transport_infos
(
)
;
for
(
auto
&
transport_info
:
transport_infos
)
{
transport_info
.
description
.
connection_role
=
cricket
:
:
CONNECTIONROLE_PASSIVE
;
}
}
TEST_P
(
DataChannelIntegrationTest
DataChannelWhileDisconnected
)
{
CreatePeerConnectionWrappers
(
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data1
=
"
hello
first
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data1
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data1
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
1
.
0
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
standardized_ice_connection_state
(
)
;
}
Eq
(
PeerConnectionInterface
:
:
kIceConnectionDisconnected
)
{
.
timeout
=
TimeDelta
:
:
Seconds
(
10
)
}
)
IsRtcOk
(
)
)
;
std
:
:
string
data2
=
"
hello
second
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data2
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
0
.
0
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data2
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
DataChannelWhileDisconnectedIceRestart
)
{
CreatePeerConnectionWrappers
(
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data1
=
"
hello
first
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data1
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data1
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
1
.
0
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
standardized_ice_connection_state
(
)
;
}
Eq
(
PeerConnectionInterface
:
:
kIceConnectionDisconnected
)
{
.
timeout
=
TimeDelta
:
:
Seconds
(
10
)
}
)
IsRtcOk
(
)
)
;
std
:
:
string
data2
=
"
hello
second
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data2
)
)
;
caller
(
)
-
>
SetOfferAnswerOptions
(
IceRestartOfferAnswerOptions
(
)
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
0
.
0
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data2
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
EndToEndCallWithSctpDataChannel
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
if
(
allow_media
(
)
)
{
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
callee
(
)
-
>
AddAudioVideoTracks
(
)
;
}
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
if
(
allow_media
(
)
)
{
MediaExpectations
media_expectations
;
media_expectations
.
ExpectBidirectionalAudioAndVideo
(
)
;
ASSERT_TRUE
(
ExpectNewFrames
(
media_expectations
)
)
;
}
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data
=
"
hello
world
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
EndToEndCallWithSctpDataChannelVariousSizes
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
for
(
int
message_size
=
1
;
message_size
<
100000
;
message_size
*
=
2
)
{
std
:
:
string
data
(
message_size
'
a
'
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
for
(
int
message_size
=
1100
;
message_size
<
1300
;
message_size
+
=
1
)
{
std
:
:
string
data
(
message_size
'
a
'
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
caller
(
)
-
>
data_channel
(
)
-
>
Close
(
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
state
(
)
;
}
Eq
(
webrtc
:
:
DataChannelInterface
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
state
(
)
;
}
Eq
(
webrtc
:
:
DataChannelInterface
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
EndToEndCallWithSctpDataChannelFullBuffer
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data
(
256
*
1024
'
a
'
)
;
for
(
size_t
queued_size
=
0
;
queued_size
<
webrtc
:
:
DataChannelInterface
:
:
MaxSendQueueSize
(
)
;
queued_size
+
=
data
.
size
(
)
)
{
caller
(
)
-
>
data_channel
(
)
-
>
SendAsync
(
DataBuffer
(
data
)
nullptr
)
;
}
caller
(
)
-
>
data_channel
(
)
-
>
Close
(
)
;
DataChannelInterface
:
:
DataState
expected_states
[
]
=
{
DataChannelInterface
:
:
DataState
:
:
kConnecting
DataChannelInterface
:
:
DataState
:
:
kOpen
DataChannelInterface
:
:
DataState
:
:
kClosing
DataChannelInterface
:
:
DataState
:
:
kClosed
}
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
{
.
timeout
=
kLongTimeout
}
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
caller
(
)
-
>
data_observer
(
)
-
>
states
(
)
:
:
testing
:
:
ElementsAreArray
(
expected_states
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
callee
(
)
-
>
data_observer
(
)
-
>
states
(
)
:
:
testing
:
:
ElementsAreArray
(
expected_states
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
EndToEndCallWithSctpDataChannelEmptyMessages
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data
=
"
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
.
empty
(
)
)
;
EXPECT_FALSE
(
callee
(
)
-
>
data_observer
(
)
-
>
messages
(
)
.
back
(
)
.
binary
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
.
empty
(
)
)
;
EXPECT_FALSE
(
caller
(
)
-
>
data_observer
(
)
-
>
messages
(
)
.
back
(
)
.
binary
)
;
rtc
:
:
CopyOnWriteBuffer
empty_buffer
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
empty_buffer
true
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
2u
)
)
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
callee
(
)
-
>
data_observer
(
)
-
>
messages
(
)
.
back
(
)
.
binary
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
empty_buffer
true
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
2u
)
)
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
caller
(
)
-
>
data_observer
(
)
-
>
messages
(
)
.
back
(
)
.
binary
)
;
}
TEST_P
(
DataChannelIntegrationTest
EndToEndCallWithSctpDataChannelLowestSafeMtu
)
{
const
size_t
kLowestSafePayloadSizeLimit
=
1225
;
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_max_udp_payload
(
kLowestSafePayloadSizeLimit
)
;
for
(
int
message_size
=
1140
;
message_size
<
1240
;
message_size
+
=
1
)
{
std
:
:
string
data
(
message_size
'
a
'
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
}
TEST_P
(
DataChannelIntegrationTest
EndToEndCallWithSctpDataChannelHarmfulMtu
)
{
const
size_t
kLowestSafePayloadSizeLimit
=
1225
;
const
size_t
kMessageSizeThatIsNotDelivered
=
1157
;
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
if
(
caller
(
)
-
>
tls_version
(
)
=
=
kDtls13VersionBytes
)
{
ASSERT_EQ
(
caller
(
)
-
>
tls_version
(
)
kDtls13VersionBytes
)
;
GTEST_SKIP
(
)
<
<
"
DTLS1
.
3
fragments
packets
larger
than
MTU
"
;
}
virtual_socket_server
(
)
-
>
set_max_udp_payload
(
kLowestSafePayloadSizeLimit
-
1
)
;
bool
failure_seen
=
false
;
for
(
size_t
message_size
=
1110
;
message_size
<
1400
;
message_size
+
+
)
{
const
size_t
message_count
=
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
const
std
:
:
string
data
(
message_size
'
a
'
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
WAIT
(
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
>
message_count
100
)
;
if
(
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
=
=
message_count
)
{
ASSERT_EQ
(
kMessageSizeThatIsNotDelivered
message_size
)
;
failure_seen
=
true
;
break
;
}
}
ASSERT_TRUE
(
failure_seen
)
;
}
TEST_P
(
DataChannelIntegrationTest
CalleeClosesSctpDataChannel
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
if
(
allow_media
(
)
)
{
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
callee
(
)
-
>
AddAudioVideoTracks
(
)
;
}
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Close
(
)
;
DataChannelInterface
:
:
DataState
expected_states
[
]
=
{
DataChannelInterface
:
:
DataState
:
:
kConnecting
DataChannelInterface
:
:
DataState
:
:
kOpen
DataChannelInterface
:
:
DataState
:
:
kClosing
DataChannelInterface
:
:
DataState
:
:
kClosed
}
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
caller
(
)
-
>
data_observer
(
)
-
>
states
(
)
:
:
testing
:
:
ElementsAreArray
(
expected_states
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
callee
(
)
-
>
data_observer
(
)
-
>
states
(
)
:
:
testing
:
:
ElementsAreArray
(
expected_states
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
SctpDataChannelConfigSentToOtherSide
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
DataChannelInit
init
;
init
.
id
=
53
;
init
.
maxRetransmits
=
52
;
caller
(
)
-
>
CreateDataChannel
(
"
data
-
channel
"
&
init
)
;
if
(
allow_media
(
)
)
{
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
callee
(
)
-
>
AddAudioVideoTracks
(
)
;
}
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_NE
(
init
.
id
callee
(
)
-
>
data_channel
(
)
-
>
id
(
)
)
;
EXPECT_EQ
(
"
data
-
channel
"
callee
(
)
-
>
data_channel
(
)
-
>
label
(
)
)
;
EXPECT_EQ
(
init
.
maxRetransmits
*
callee
(
)
-
>
data_channel
(
)
-
>
maxRetransmitsOpt
(
)
)
;
EXPECT_FALSE
(
callee
(
)
-
>
data_channel
(
)
-
>
negotiated
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
StressTestUnorderedSctpDataChannel
)
{
virtual_socket_server
(
)
-
>
set_delay_mean
(
20
)
;
virtual_socket_server
(
)
-
>
set_delay_stddev
(
5
)
;
virtual_socket_server
(
)
-
>
UpdateDelayDistribution
(
)
;
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
DataChannelInit
init
;
init
.
ordered
=
false
;
caller
(
)
-
>
CreateDataChannel
(
&
init
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
static
constexpr
int
kNumMessages
=
100
;
static
constexpr
size_t
kMaxMessageSize
=
4096
;
std
:
:
vector
<
std
:
:
string
>
sent_messages
;
for
(
int
i
=
0
;
i
<
kNumMessages
;
+
+
i
)
{
size_t
length
=
(
rand
(
)
%
kMaxMessageSize
)
+
1
;
std
:
:
string
message
;
ASSERT_TRUE
(
CreateRandomString
(
length
&
message
)
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
message
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
message
)
)
;
sent_messages
.
push_back
(
message
)
;
}
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
checked_cast
<
size_t
>
(
kNumMessages
)
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
checked_cast
<
size_t
>
(
kNumMessages
)
)
)
IsRtcOk
(
)
)
;
std
:
:
vector
<
std
:
:
string
>
caller_received_messages
;
absl
:
:
c_transform
(
caller
(
)
-
>
data_observer
(
)
-
>
messages
(
)
std
:
:
back_inserter
(
caller_received_messages
)
[
]
(
const
auto
&
a
)
{
return
a
.
data
;
}
)
;
std
:
:
vector
<
std
:
:
string
>
callee_received_messages
;
absl
:
:
c_transform
(
callee
(
)
-
>
data_observer
(
)
-
>
messages
(
)
std
:
:
back_inserter
(
callee_received_messages
)
[
]
(
const
auto
&
a
)
{
return
a
.
data
;
}
)
;
absl
:
:
c_sort
(
sent_messages
)
;
absl
:
:
c_sort
(
caller_received_messages
)
;
absl
:
:
c_sort
(
callee_received_messages
)
;
EXPECT_EQ
(
sent_messages
caller_received_messages
)
;
EXPECT_EQ
(
sent_messages
callee_received_messages
)
;
}
TEST_P
(
DataChannelIntegrationTest
StressTestOpenCloseChannelNoDelay
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
int
channel_id
=
0
;
const
size_t
kChannelCount
=
8
;
const
size_t
kIterations
=
10
;
bool
has_negotiated
=
false
;
DataChannelInit
init
;
for
(
size_t
repeats
=
0
;
repeats
<
kIterations
;
+
+
repeats
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Iteration
"
<
<
(
repeats
+
1
)
<
<
"
/
"
<
<
kIterations
;
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
StringBuilder
sb
;
sb
<
<
"
channel
-
"
<
<
channel_id
+
+
;
caller
(
)
-
>
CreateDataChannel
(
sb
.
Release
(
)
&
init
)
;
}
ASSERT_EQ
(
caller
(
)
-
>
data_channels
(
)
.
size
(
)
kChannelCount
)
;
if
(
!
has_negotiated
)
{
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
has_negotiated
=
true
;
}
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kOpen
)
)
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Caller
Channel
"
<
<
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
label
(
)
<
<
"
with
id
"
<
<
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
id
(
)
<
<
"
is
open
.
"
;
}
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
.
size
(
)
;
}
Eq
(
kChannelCount
)
)
IsRtcOk
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kOpen
)
)
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Callee
Channel
"
<
<
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
label
(
)
<
<
"
with
id
"
<
<
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
id
(
)
<
<
"
is
open
.
"
;
}
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
if
(
i
%
3
=
=
0
)
{
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
}
else
{
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
}
}
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
}
caller
(
)
-
>
data_channels
(
)
.
clear
(
)
;
caller
(
)
-
>
data_observers
(
)
.
clear
(
)
;
callee
(
)
-
>
data_channels
(
)
.
clear
(
)
;
callee
(
)
-
>
data_observers
(
)
.
clear
(
)
;
}
}
TEST_P
(
DataChannelIntegrationTest
StressTestOpenCloseChannelWithDelay
)
{
virtual_socket_server
(
)
-
>
set_delay_mean
(
20
)
;
virtual_socket_server
(
)
-
>
set_delay_stddev
(
5
)
;
virtual_socket_server
(
)
-
>
UpdateDelayDistribution
(
)
;
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
int
channel_id
=
0
;
const
size_t
kChannelCount
=
8
;
const
size_t
kIterations
=
10
;
bool
has_negotiated
=
false
;
DataChannelInit
init
;
for
(
size_t
repeats
=
0
;
repeats
<
kIterations
;
+
+
repeats
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Iteration
"
<
<
(
repeats
+
1
)
<
<
"
/
"
<
<
kIterations
;
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
StringBuilder
sb
;
sb
<
<
"
channel
-
"
<
<
channel_id
+
+
;
caller
(
)
-
>
CreateDataChannel
(
sb
.
Release
(
)
&
init
)
;
}
ASSERT_EQ
(
caller
(
)
-
>
data_channels
(
)
.
size
(
)
kChannelCount
)
;
if
(
!
has_negotiated
)
{
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
has_negotiated
=
true
;
}
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kOpen
)
)
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Caller
Channel
"
<
<
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
label
(
)
<
<
"
with
id
"
<
<
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
id
(
)
<
<
"
is
open
.
"
;
}
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
.
size
(
)
;
}
Eq
(
kChannelCount
)
)
IsRtcOk
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kOpen
)
)
IsRtcOk
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Callee
Channel
"
<
<
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
label
(
)
<
<
"
with
id
"
<
<
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
id
(
)
<
<
"
is
open
.
"
;
}
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
if
(
i
%
3
=
=
0
)
{
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
}
else
{
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
Close
(
)
;
}
}
for
(
size_t
i
=
0
;
i
<
kChannelCount
;
+
+
i
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
[
i
]
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
DataState
:
:
kClosed
)
)
IsRtcOk
(
)
)
;
}
caller
(
)
-
>
data_channels
(
)
.
clear
(
)
;
caller
(
)
-
>
data_observers
(
)
.
clear
(
)
;
callee
(
)
-
>
data_channels
(
)
.
clear
(
)
;
callee
(
)
-
>
data_observers
(
)
.
clear
(
)
;
}
}
TEST_P
(
DataChannelIntegrationTest
AddSctpDataChannelInSubsequentOffer
)
{
if
(
!
allow_media
(
)
)
{
return
;
}
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
callee
(
)
-
>
AddAudioVideoTracks
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_NE
(
nullptr
caller
(
)
-
>
data_channel
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data
=
"
hello
world
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
SctpDataChannelToAudioVideoUpgrade
)
{
if
(
!
allow_media
(
)
)
{
return
;
}
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
callee
(
)
-
>
AddAudioVideoTracks
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
MediaExpectations
media_expectations
;
media_expectations
.
ExpectBidirectionalAudioAndVideo
(
)
;
ASSERT_TRUE
(
ExpectNewFrames
(
media_expectations
)
)
;
}
static
void
MakeSpecCompliantSctpOffer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
desc
)
{
SctpDataContentDescription
*
dcd_offer
=
GetFirstSctpDataContentDescription
(
desc
-
>
description
(
)
)
;
ASSERT_TRUE
(
dcd_offer
)
;
dcd_offer
-
>
set_use_sctpmap
(
false
)
;
dcd_offer
-
>
set_protocol
(
"
UDP
/
DTLS
/
SCTP
"
)
;
}
TEST_P
(
DataChannelIntegrationTest
DataChannelWorksWhenSpecCompliantSctpOfferReceived
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
SetGeneratedSdpMunger
(
MakeSpecCompliantSctpOffer
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
Ne
(
nullptr
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
std
:
:
string
data
=
"
hello
world
"
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
data
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
ClosingConnectionStopsPacketFlow
)
{
if
(
!
allow_media
(
)
)
{
return
;
}
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
MediaExpectations
media_expectations
;
media_expectations
.
CalleeExpectsSomeAudioAndVideo
(
)
;
ASSERT_TRUE
(
ExpectNewFrames
(
media_expectations
)
)
;
ClosePeerConnections
(
)
;
uint32_t
sent_packets_a
=
virtual_socket_server
(
)
-
>
sent_packets
(
)
;
WAIT
(
false
1000
)
;
uint32_t
sent_packets_b
=
virtual_socket_server
(
)
-
>
sent_packets
(
)
;
EXPECT_EQ
(
sent_packets_a
sent_packets_b
)
;
}
TEST_P
(
DataChannelIntegrationTest
DtlsRoleIsSetNormally
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
ASSERT_FALSE
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
)
;
ASSERT_TRUE
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
)
;
EXPECT_TRUE
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
)
;
EXPECT_EQ
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
DtlsTransportTlsRole
:
:
kServer
)
;
EXPECT_EQ
(
callee
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
DtlsTransportTlsRole
:
:
kClient
)
;
EXPECT_EQ
(
caller
(
)
-
>
data_channel
(
)
-
>
id
(
)
1
)
;
}
TEST_P
(
DataChannelIntegrationTest
DtlsRoleIsSetWhenReversed
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
callee
(
)
-
>
SetReceivedSdpMunger
(
MakeOfferHaveActiveDtlsRole
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
)
;
EXPECT_EQ
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
DtlsTransportTlsRole
:
:
kClient
)
;
EXPECT_EQ
(
callee
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
DtlsTransportTlsRole
:
:
kServer
)
;
EXPECT_EQ
(
caller
(
)
-
>
data_channel
(
)
-
>
id
(
)
0
)
;
}
TEST_P
(
DataChannelIntegrationTest
DtlsRoleIsSetWhenReversedWithChannelCollision
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
callee
(
)
-
>
SetReceivedSdpMunger
(
[
this
]
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
desc
)
{
MakeOfferHaveActiveDtlsRole
(
desc
)
;
callee
(
)
-
>
CreateDataChannel
(
)
;
}
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channels
(
)
.
size
(
)
;
}
Eq
(
2U
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
data_channels
(
)
.
size
(
)
;
}
Eq
(
2U
)
)
IsRtcOk
(
)
)
;
EXPECT_TRUE
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
)
;
EXPECT_EQ
(
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
DtlsTransportTlsRole
:
:
kClient
)
;
EXPECT_EQ
(
callee
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
dtls_transport
(
)
-
>
Information
(
)
.
role
(
)
DtlsTransportTlsRole
:
:
kServer
)
;
ASSERT_EQ
(
caller
(
)
-
>
data_channels
(
)
.
size
(
)
2U
)
;
ASSERT_EQ
(
callee
(
)
-
>
data_channels
(
)
.
size
(
)
2U
)
;
EXPECT_EQ
(
caller
(
)
-
>
data_channels
(
)
[
0
]
-
>
id
(
)
0
)
;
EXPECT_EQ
(
caller
(
)
-
>
data_channels
(
)
[
1
]
-
>
id
(
)
1
)
;
EXPECT_EQ
(
callee
(
)
-
>
data_channels
(
)
[
0
]
-
>
id
(
)
1
)
;
EXPECT_EQ
(
callee
(
)
-
>
data_channels
(
)
[
1
]
-
>
id
(
)
0
)
;
}
TEST_P
(
DataChannelIntegrationTest
TransportStatsReportedForDataChannelOnlyConnection
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
auto
caller_report
=
caller
(
)
-
>
NewGetStats
(
)
;
EXPECT_EQ
(
1u
caller_report
-
>
GetStatsOfType
<
RTCTransportStats
>
(
)
.
size
(
)
)
;
auto
callee_report
=
callee
(
)
-
>
NewGetStats
(
)
;
EXPECT_EQ
(
1u
callee_report
-
>
GetStatsOfType
<
RTCTransportStats
>
(
)
.
size
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
QueuedPacketsGetDeliveredInReliableMode
)
{
CreatePeerConnectionWrappers
(
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
hello
first
"
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
1
.
0
)
;
for
(
int
i
=
1
;
i
<
=
10
;
i
+
+
)
{
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
Sent
while
blocked
"
)
)
;
}
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
0
.
0
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
11u
)
)
IsRtcOk
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
QueuedPacketsGetDroppedInUnreliableMode
)
{
CreatePeerConnectionWrappers
(
)
;
ConnectFakeSignaling
(
)
;
DataChannelInit
init
;
init
.
maxRetransmits
=
0
;
init
.
ordered
=
false
;
caller
(
)
-
>
CreateDataChannel
(
&
init
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
hello
first
"
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
1
.
0
)
;
for
(
int
i
=
1
;
i
<
=
10
;
i
+
+
)
{
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
Sent
while
blocked
"
)
)
;
}
WAIT
(
false
10
)
;
EXPECT_EQ
(
1u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
0
.
0
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
After
block
"
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
"
After
block
"
)
)
IsRtcOk
(
)
)
;
EXPECT_GT
(
11u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_LE
(
2u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_EQ
(
2u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
QueuedPacketsGetDroppedInLifetimeLimitedMode
)
{
CreatePeerConnectionWrappers
(
)
;
ConnectFakeSignaling
(
)
;
DataChannelInit
init
;
init
.
maxRetransmitTime
=
1
;
init
.
ordered
=
false
;
caller
(
)
-
>
CreateDataChannel
(
&
init
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
hello
first
"
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
1
.
0
)
;
for
(
int
i
=
1
;
i
<
=
200
;
i
+
+
)
{
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
Sent
while
blocked
"
)
)
;
}
WAIT
(
false
10
)
;
EXPECT_EQ
(
1u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
0
.
0
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
After
block
"
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
"
After
block
"
)
)
IsRtcOk
(
)
)
;
EXPECT_GT
(
202u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_LE
(
2u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_EQ
(
2u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTest
DISABLED_ON_ANDROID
(
SomeQueuedPacketsGetDroppedInMaxRetransmitsMode
)
)
{
CreatePeerConnectionWrappers
(
)
;
ConnectFakeSignaling
(
)
;
DataChannelInit
init
;
init
.
maxRetransmits
=
0
;
init
.
ordered
=
false
;
caller
(
)
-
>
CreateDataChannel
(
&
init
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
hello
first
"
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
;
}
Eq
(
1u
)
)
IsRtcOk
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
1
.
0
)
;
constexpr
size_t
kBufferedDataInSctpSocket
=
2
'
000
'
000
;
size_t
packet_counter
=
0
;
while
(
caller
(
)
-
>
data_channel
(
)
-
>
buffered_amount
(
)
<
kBufferedDataInSctpSocket
&
&
packet_counter
<
10000
)
{
packet_counter
+
+
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
Sent
while
blocked
"
)
)
;
}
if
(
caller
(
)
-
>
data_channel
(
)
-
>
buffered_amount
(
)
>
kBufferedDataInSctpSocket
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Buffered
data
after
"
<
<
packet_counter
<
<
"
packets
"
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
No
buffered
data
after
"
<
<
packet_counter
<
<
"
packets
"
;
}
WAIT
(
false
10
)
;
EXPECT_EQ
(
1u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
virtual_socket_server
(
)
-
>
set_drop_probability
(
0
.
0
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Send
(
DataBuffer
(
"
After
block
"
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
"
After
block
"
)
)
IsRtcOk
(
)
)
;
EXPECT_GT
(
packet_counter
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_LE
(
2u
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_GT
(
2
+
packet_counter
-
100
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
EXPECT_LT
(
2
+
packet_counter
-
500
callee
(
)
-
>
data_observer
(
)
-
>
received_message_count
(
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
DataChannelIntegrationTest
DataChannelIntegrationTest
Combine
(
Values
(
SdpSemantics
:
:
kPlanB_DEPRECATED
SdpSemantics
:
:
kUnifiedPlan
)
testing
:
:
Bool
(
)
)
)
;
TEST_F
(
DataChannelIntegrationTestUnifiedPlan
EndToEndCallWithBundledSctpDataChannel
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappers
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
AddAudioVideoTracks
(
)
;
callee
(
)
-
>
AddAudioVideoTracks
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
(
)
-
>
pc
(
)
-
>
GetSctpTransport
(
)
-
>
Information
(
)
.
state
(
)
;
}
Eq
(
SctpTransportState
:
:
kConnected
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
}
TEST_F
(
DataChannelIntegrationTestUnifiedPlan
EndToEndCallWithDataChannelOnlyConnects
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappersWithoutMediaEngine
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_channel
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_TRUE
(
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
)
;
}
TEST_F
(
DataChannelIntegrationTestUnifiedPlan
DataChannelClosesWhenClosed
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappersWithoutMediaEngine
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
data_channel
(
)
-
>
Close
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
!
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
}
TEST_F
(
DataChannelIntegrationTestUnifiedPlan
DataChannelClosesWhenClosedReverse
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappersWithoutMediaEngine
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
callee
(
)
-
>
data_channel
(
)
-
>
Close
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
!
caller
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
}
TEST_F
(
DataChannelIntegrationTestUnifiedPlan
DataChannelClosesWhenPeerConnectionClosed
)
{
ASSERT_TRUE
(
CreatePeerConnectionWrappersWithoutMediaEngine
(
)
)
;
ConnectFakeSignaling
(
)
;
caller
(
)
-
>
CreateDataChannel
(
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
SignalingStateStable
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
caller
(
)
-
>
pc
(
)
-
>
Close
(
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
!
callee
(
)
-
>
data_observer
(
)
-
>
IsOpen
(
)
;
}
IsTrue
(
)
)
IsRtcOk
(
)
)
;
}
class
DataChannelIntegrationTestUnifiedPlanFieldTrials
:
public
DataChannelIntegrationTestUnifiedPlan
public
:
:
testing
:
:
WithParamInterface
<
std
:
:
tuple
<
bool
const
char
*
const
char
*
const
char
*
>
>
{
protected
:
DataChannelIntegrationTestUnifiedPlanFieldTrials
(
)
{
const
bool
callee_active
=
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
dtls_active
:
"
<
<
(
callee_active
?
"
callee
"
:
"
caller
"
)
<
<
"
field
-
trials
:
caller
:
"
<
<
std
:
:
get
<
1
>
(
GetParam
(
)
)
<
<
"
callee
:
"
<
<
std
:
:
get
<
2
>
(
GetParam
(
)
)
<
<
"
callee2
:
"
<
<
std
:
:
get
<
3
>
(
GetParam
(
)
)
;
SetFieldTrials
(
kCallerName
std
:
:
get
<
1
>
(
GetParam
(
)
)
)
;
SetFieldTrials
(
kCalleeName
std
:
:
get
<
2
>
(
GetParam
(
)
)
)
;
SetFieldTrials
(
"
Callee2
"
std
:
:
get
<
3
>
(
GetParam
(
)
)
)
;
}
std
:
:
unique_ptr
<
PeerConnectionIntegrationWrapper
>
SetupCallee2AndDc
(
bool
addTurn
)
{
RTCConfiguration
config
;
if
(
addTurn
)
{
static
const
rtc
:
:
SocketAddress
turn_server_1_internal_address
{
"
192
.
0
.
2
.
1
"
3478
}
;
static
const
rtc
:
:
SocketAddress
turn_server_1_external_address
{
"
192
.
0
.
3
.
1
"
0
}
;
TestTurnServer
*
turn_server_1
=
CreateTurnServer
(
turn_server_1_internal_address
turn_server_1_external_address
)
;
SendTask
(
network_thread
(
)
[
turn_server_1
]
{
turn_server_1
-
>
set_enable_permission_checks
(
false
)
;
}
)
;
PeerConnectionInterface
:
:
IceServer
ice_server_1
;
ice_server_1
.
urls
.
push_back
(
"
turn
:
192
.
0
.
2
.
1
:
3478
"
)
;
ice_server_1
.
username
=
"
test
"
;
ice_server_1
.
password
=
"
test
"
;
config
.
servers
.
push_back
(
ice_server_1
)
;
config
.
type
=
PeerConnectionInterface
:
:
kRelay
;
config
.
presume_writable_when_fully_relayed
=
true
;
}
CreatePeerConnectionWrappersWithConfig
(
config
config
false
)
;
PeerConnectionDependencies
dependencies
(
nullptr
)
;
std
:
:
unique_ptr
<
FakeRTCCertificateGenerator
>
cert_generator
(
new
FakeRTCCertificateGenerator
(
)
)
;
cert_generator
-
>
use_alternate_key
(
)
;
dependencies
.
cert_generator
=
std
:
:
move
(
cert_generator
)
;
auto
callee2
=
CreatePeerConnectionWrapper
(
"
Callee2
"
nullptr
&
config
std
:
:
move
(
dependencies
)
nullptr
false
false
false
)
;
ConnectFakeSignaling
(
)
;
DataChannelInit
dc_init
;
dc_init
.
negotiated
=
true
;
dc_init
.
id
=
77
;
caller
(
)
-
>
CreateDataChannel
(
"
label
"
&
dc_init
)
;
callee
(
)
-
>
CreateDataChannel
(
"
label
"
&
dc_init
)
;
callee2
-
>
CreateDataChannel
(
"
label
"
&
dc_init
)
;
callee2
-
>
set_signaling_message_receiver
(
caller
(
)
)
;
return
callee2
;
}
void
WaitConnectedAndDcOpen
(
bool
prAnswer
PeerConnectionIntegrationWrapper
*
caller
PeerConnectionIntegrationWrapper
*
callee
)
{
if
(
prAnswer
)
{
EXPECT_EQ
(
caller
-
>
pc
(
)
-
>
signaling_state
(
)
PeerConnectionInterface
:
:
kHaveRemotePrAnswer
)
;
EXPECT_EQ
(
callee
-
>
pc
(
)
-
>
signaling_state
(
)
PeerConnectionInterface
:
:
kHaveLocalPrAnswer
)
;
}
else
{
EXPECT_EQ
(
caller
-
>
pc
(
)
-
>
signaling_state
(
)
PeerConnectionInterface
:
:
kStable
)
;
EXPECT_EQ
(
callee
-
>
pc
(
)
-
>
signaling_state
(
)
PeerConnectionInterface
:
:
kStable
)
;
}
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
-
>
data_channel
(
)
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
kOpen
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
-
>
data_channel
(
)
-
>
state
(
)
;
}
Eq
(
DataChannelInterface
:
:
kOpen
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
caller
-
>
pc
(
)
-
>
peer_connection_state
(
)
;
}
Eq
(
PeerConnectionInterface
:
:
PeerConnectionState
:
:
kConnected
)
)
IsRtcOk
(
)
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee
-
>
pc
(
)
-
>
peer_connection_state
(
)
;
}
Eq
(
PeerConnectionInterface
:
:
PeerConnectionState
:
:
kConnected
)
)
IsRtcOk
(
)
)
;
}
static
void
SendOnDatachannelWhenConnectedCallback
(
PeerConnectionIntegrationWrapper
*
peer
const
std
:
:
string
&
data
std
:
:
atomic
<
int
>
&
signal
)
{
if
(
peer
-
>
pc
(
)
-
>
peer_connection_state
(
)
=
=
PeerConnectionInterface
:
:
PeerConnectionState
:
:
kConnected
&
&
peer
-
>
data_channel
(
)
-
>
state
(
)
=
=
DataChannelInterface
:
:
kOpen
)
{
peer
-
>
data_channel
(
)
-
>
SendAsync
(
DataBuffer
(
data
)
[
&
]
(
RTCError
err
)
{
signal
.
store
(
err
.
ok
(
)
?
1
:
-
1
)
;
}
)
;
}
}
void
VerifyDtlsRoles
(
PeerConnectionIntegrationWrapper
*
caller
PeerConnectionIntegrationWrapper
*
callee
)
{
const
bool
callee_active
=
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
if
(
callee_active
)
{
ASSERT_THAT
(
caller
-
>
dtls_transport_role
(
)
Eq
(
DtlsTransportTlsRole
:
:
kServer
)
)
;
ASSERT_THAT
(
callee
-
>
dtls_transport_role
(
)
Eq
(
DtlsTransportTlsRole
:
:
kClient
)
)
;
}
else
{
ASSERT_THAT
(
caller
-
>
dtls_transport_role
(
)
Eq
(
DtlsTransportTlsRole
:
:
kClient
)
)
;
ASSERT_THAT
(
callee
-
>
dtls_transport_role
(
)
Eq
(
DtlsTransportTlsRole
:
:
kServer
)
)
;
}
}
void
VerifyReceivedDcMessages
(
PeerConnectionIntegrationWrapper
*
peer
const
std
:
:
string
&
data
std
:
:
atomic
<
int
>
&
signal
)
{
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
signal
.
load
(
)
;
}
Ne
(
0
)
)
IsRtcOk
(
)
)
;
EXPECT_THAT
(
WaitUntil
(
[
&
]
{
return
peer
-
>
data_observer
(
)
-
>
last_message
(
)
;
}
Eq
(
data
)
)
IsRtcOk
(
)
)
;
}
const
char
*
CheckSupported
(
)
{
const
bool
callee_active
=
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
const
bool
callee_has_dtls_in_stun
=
absl
:
:
StrContains
(
std
:
:
get
<
2
>
(
GetParam
(
)
)
"
WebRTC
-
IceHandshakeDtls
/
Enabled
/
"
)
;
const
bool
callee2_has_dtls_in_stun
=
absl
:
:
StrContains
(
std
:
:
get
<
3
>
(
GetParam
(
)
)
"
WebRTC
-
IceHandshakeDtls
/
Enabled
/
"
)
;
if
(
callee_active
&
&
(
callee_has_dtls_in_stun
|
|
callee2_has_dtls_in_stun
)
)
{
return
"
dtls
-
in
-
stun
when
callee
(
s
)
are
dtls
clients
"
;
}
return
nullptr
;
}
}
;
static
const
char
*
kTrialsVariants
[
]
=
{
"
"
"
WebRTC
-
ForceDtls13
/
Enabled
/
"
"
WebRTC
-
IceHandshakeDtls
/
Enabled
/
"
"
WebRTC
-
ForceDtls13
/
Enabled
/
WebRTC
-
IceHandshakeDtls
/
Enabled
/
"
}
;
INSTANTIATE_TEST_SUITE_P
(
DataChannelIntegrationTestUnifiedPlanFieldTrials
DataChannelIntegrationTestUnifiedPlanFieldTrials
Combine
(
testing
:
:
Bool
(
)
ValuesIn
(
kTrialsVariants
)
ValuesIn
(
kTrialsVariants
)
ValuesIn
(
kTrialsVariants
)
)
)
;
TEST_P
(
DataChannelIntegrationTestUnifiedPlanFieldTrials
DtlsRestartOneCalleAtATime
)
{
if
(
auto
msg
=
CheckSupported
(
)
)
{
GTEST_SKIP
(
)
<
<
"
Testcase
not
supported
for
this
scenario
:
"
<
<
msg
;
}
auto
callee2
=
SetupCallee2AndDc
(
false
)
;
const
bool
callee_active
=
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
offer
;
callee
(
)
-
>
SetReceivedSdpMunger
(
[
&
]
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
sdp
)
{
if
(
callee_active
)
{
MakeOfferHavePassiveDtlsRole
(
sdp
)
;
}
else
{
MakeOfferHaveActiveDtlsRole
(
sdp
)
;
}
offer
=
sdp
-
>
Clone
(
)
;
}
)
;
callee
(
)
-
>
SetGeneratedSdpMunger
(
[
&
]
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
sdp
)
{
SetSdpType
(
sdp
SdpType
:
:
kPrAnswer
)
;
if
(
callee_active
)
{
MakeOfferHaveActiveDtlsRole
(
sdp
)
;
}
else
{
MakeOfferHavePassiveDtlsRole
(
sdp
)
;
}
}
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
WaitConnectedAndDcOpen
(
true
caller
(
)
callee
(
)
)
;
VerifyDtlsRoles
(
caller
(
)
callee
(
)
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
std
:
:
atomic
<
int
>
caller_sent_on_dc
(
0
)
;
std
:
:
atomic
<
int
>
callee2_sent_on_dc
(
0
)
;
caller
(
)
-
>
set_connection_change_callback
(
[
&
]
(
auto
new_state
)
{
SendOnDatachannelWhenConnectedCallback
(
caller
(
)
"
KESO
"
caller_sent_on_dc
)
;
}
)
;
callee2
-
>
set_connection_change_callback
(
[
&
]
(
auto
new_state
)
{
SendOnDatachannelWhenConnectedCallback
(
callee2
.
get
(
)
"
KENT
"
callee2_sent_on_dc
)
;
}
)
;
callee2
-
>
data_observer
(
)
-
>
set_state_change_callback
(
[
&
]
(
auto
new_state
)
{
SendOnDatachannelWhenConnectedCallback
(
callee2
.
get
(
)
"
KENT
"
callee2_sent_on_dc
)
;
}
)
;
std
:
:
string
offer_sdp
;
EXPECT_TRUE
(
offer
-
>
ToString
(
&
offer_sdp
)
)
;
callee2
-
>
ReceiveSdpMessage
(
SdpType
:
:
kOffer
offer_sdp
)
;
WaitConnectedAndDcOpen
(
false
caller
(
)
callee2
.
get
(
)
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
VerifyReceivedDcMessages
(
caller
(
)
"
KENT
"
callee2_sent_on_dc
)
;
VerifyReceivedDcMessages
(
callee2
.
get
(
)
"
KESO
"
caller_sent_on_dc
)
;
VerifyDtlsRoles
(
caller
(
)
callee2
.
get
(
)
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
}
TEST_P
(
DataChannelIntegrationTestUnifiedPlanFieldTrials
DtlsRestartTwoActiveCallees
)
{
if
(
auto
msg
=
CheckSupported
(
)
)
{
GTEST_SKIP
(
)
<
<
"
Testcase
not
supported
for
this
scenario
:
"
<
<
msg
;
}
auto
callee2
=
SetupCallee2AndDc
(
true
)
;
const
bool
callee_active
=
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
offer
;
callee
(
)
-
>
SetReceivedSdpMunger
(
[
&
]
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
sdp
)
{
if
(
callee_active
)
{
MakeOfferHavePassiveDtlsRole
(
sdp
)
;
}
else
{
MakeOfferHaveActiveDtlsRole
(
sdp
)
;
}
offer
=
sdp
-
>
Clone
(
)
;
}
)
;
callee
(
)
-
>
SetGeneratedSdpMunger
(
[
&
]
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
sdp
)
{
SetSdpType
(
sdp
SdpType
:
:
kPrAnswer
)
;
if
(
callee_active
)
{
MakeOfferHaveActiveDtlsRole
(
sdp
)
;
}
else
{
MakeOfferHavePassiveDtlsRole
(
sdp
)
;
}
}
)
;
bool
first_answer
=
true
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
answer
;
caller
(
)
-
>
SetReceivedSdpMunger
(
[
&
]
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
&
sdp
)
{
if
(
first_answer
)
{
first_answer
=
false
;
}
else
{
answer
=
std
:
:
move
(
sdp
)
;
}
}
)
;
caller
(
)
-
>
CreateAndSetAndSignalOffer
(
)
;
std
:
:
string
offer_sdp
;
EXPECT_TRUE
(
offer
-
>
ToString
(
&
offer_sdp
)
)
;
callee2
-
>
ReceiveSdpMessage
(
SdpType
:
:
kOffer
offer_sdp
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
EXPECT_EQ
(
callee2
-
>
pc
(
)
-
>
signaling_state
(
)
PeerConnectionInterface
:
:
kStable
)
;
WaitConnectedAndDcOpen
(
true
caller
(
)
callee
(
)
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
auto
candidate
=
caller
(
)
-
>
last_gathered_ice_candidate
(
)
;
std
:
:
string
ice_sdp
;
EXPECT_TRUE
(
candidate
-
>
ToString
(
&
ice_sdp
)
)
;
callee2
-
>
ReceiveIceMessage
(
candidate
-
>
sdp_mid
(
)
candidate
-
>
sdp_mline_index
(
)
ice_sdp
)
;
ASSERT_THAT
(
WaitUntil
(
[
&
]
{
return
callee2
-
>
pc
(
)
-
>
standardized_ice_connection_state
(
)
;
}
Eq
(
PeerConnectionInterface
:
:
kIceConnectionConnected
)
)
IsRtcOk
(
)
)
;
VerifyDtlsRoles
(
caller
(
)
callee
(
)
)
;
ASSERT_THAT
(
callee2
-
>
dtls_transport_role
(
)
Eq
(
std
:
:
nullopt
)
)
;
std
:
:
atomic
<
int
>
caller_sent_on_dc
(
0
)
;
std
:
:
atomic
<
int
>
callee2_sent_on_dc
(
0
)
;
caller
(
)
-
>
set_connection_change_callback
(
[
&
]
(
auto
new_state
)
{
SendOnDatachannelWhenConnectedCallback
(
caller
(
)
"
KESO
"
caller_sent_on_dc
)
;
}
)
;
callee2
-
>
set_connection_change_callback
(
[
&
]
(
auto
new_state
)
{
SendOnDatachannelWhenConnectedCallback
(
callee2
.
get
(
)
"
KENT
"
callee2_sent_on_dc
)
;
}
)
;
callee2
-
>
data_observer
(
)
-
>
set_state_change_callback
(
[
&
]
(
auto
new_state
)
{
SendOnDatachannelWhenConnectedCallback
(
callee2
.
get
(
)
"
KENT
"
callee2_sent_on_dc
)
;
}
)
;
first_answer
=
true
;
ASSERT_THAT
(
answer
testing
:
:
Not
(
testing
:
:
IsNull
(
)
)
)
;
std
:
:
string
answer_sdp
;
EXPECT_TRUE
(
answer
-
>
ToString
(
&
answer_sdp
)
)
;
caller
(
)
-
>
ReceiveSdpMessage
(
SdpType
:
:
kAnswer
answer_sdp
)
;
EXPECT_EQ
(
caller
(
)
-
>
pc
(
)
-
>
signaling_state
(
)
PeerConnectionInterface
:
:
kStable
)
;
VerifyReceivedDcMessages
(
caller
(
)
"
KENT
"
callee2_sent_on_dc
)
;
VerifyReceivedDcMessages
(
callee2
.
get
(
)
"
KESO
"
caller_sent_on_dc
)
;
VerifyDtlsRoles
(
caller
(
)
callee2
.
get
(
)
)
;
ASSERT_FALSE
(
HasFailure
(
)
)
;
}
#
endif
}
}
