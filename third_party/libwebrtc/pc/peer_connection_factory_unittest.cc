#
include
"
pc
/
peer_connection_factory
.
h
"
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
audio
/
audio_mixer
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_encoder_factory
.
h
"
#
include
"
api
/
create_peerconnection_factory
.
h
"
#
include
"
api
/
data_channel_interface
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
media_stream_interface
.
h
"
#
include
"
api
/
video_codecs
/
builtin_video_decoder_factory
.
h
"
#
include
"
api
/
video_codecs
/
builtin_video_encoder_factory
.
h
"
#
include
"
media
/
base
/
fake_frame_source
.
h
"
#
include
"
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
p2p
/
base
/
fake_port_allocator
.
h
"
#
include
"
p2p
/
base
/
port
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
pc
/
test
/
fake_audio_capture_module
.
h
"
#
include
"
pc
/
test
/
fake_video_track_source
.
h
"
#
include
"
rtc_base
/
rtc_certificate_generator
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
test
/
gtest
.
h
"
#
ifdef
WEBRTC_ANDROID
#
include
"
pc
/
test
/
android_test_initializer
.
h
"
#
endif
#
include
"
pc
/
test
/
fake_rtc_certificate_generator
.
h
"
#
include
"
pc
/
test
/
fake_video_track_renderer
.
h
"
using
webrtc
:
:
DataChannelInterface
;
using
webrtc
:
:
FakeVideoTrackRenderer
;
using
webrtc
:
:
MediaStreamInterface
;
using
webrtc
:
:
PeerConnectionFactoryInterface
;
using
webrtc
:
:
PeerConnectionInterface
;
using
webrtc
:
:
PeerConnectionObserver
;
using
webrtc
:
:
VideoTrackInterface
;
using
webrtc
:
:
VideoTrackSourceInterface
;
namespace
{
static
const
char
kStunIceServer
[
]
=
"
stun
:
stun
.
l
.
google
.
com
:
19302
"
;
static
const
char
kTurnIceServer
[
]
=
"
turn
:
test
.
com
:
1234
"
;
static
const
char
kTurnIceServerWithTransport
[
]
=
"
turn
:
hello
.
com
?
transport
=
tcp
"
;
static
const
char
kSecureTurnIceServer
[
]
=
"
turns
:
hello
.
com
?
transport
=
tcp
"
;
static
const
char
kSecureTurnIceServerWithoutTransportParam
[
]
=
"
turns
:
hello
.
com
:
443
"
;
static
const
char
kSecureTurnIceServerWithoutTransportAndPortParam
[
]
=
"
turns
:
hello
.
com
"
;
static
const
char
kTurnIceServerWithNoUsernameInUri
[
]
=
"
turn
:
test
.
com
:
1234
"
;
static
const
char
kTurnPassword
[
]
=
"
turnpassword
"
;
static
const
int
kDefaultStunPort
=
3478
;
static
const
int
kDefaultStunTlsPort
=
5349
;
static
const
char
kTurnUsername
[
]
=
"
test
"
;
static
const
char
kStunIceServerWithIPv4Address
[
]
=
"
stun
:
1
.
2
.
3
.
4
:
1234
"
;
static
const
char
kStunIceServerWithIPv4AddressWithoutPort
[
]
=
"
stun
:
1
.
2
.
3
.
4
"
;
static
const
char
kStunIceServerWithIPv6Address
[
]
=
"
stun
:
[
2401
:
fa00
:
4
:
:
]
:
1234
"
;
static
const
char
kStunIceServerWithIPv6AddressWithoutPort
[
]
=
"
stun
:
[
2401
:
fa00
:
4
:
:
]
"
;
static
const
char
kTurnIceServerWithIPv6Address
[
]
=
"
turn
:
[
2401
:
fa00
:
4
:
:
]
:
1234
"
;
class
NullPeerConnectionObserver
:
public
PeerConnectionObserver
{
public
:
virtual
~
NullPeerConnectionObserver
(
)
=
default
;
void
OnSignalingChange
(
PeerConnectionInterface
:
:
SignalingState
new_state
)
override
{
}
void
OnAddStream
(
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
stream
)
override
{
}
void
OnRemoveStream
(
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
stream
)
override
{
}
void
OnDataChannel
(
rtc
:
:
scoped_refptr
<
DataChannelInterface
>
data_channel
)
override
{
}
void
OnRenegotiationNeeded
(
)
override
{
}
void
OnIceConnectionChange
(
PeerConnectionInterface
:
:
IceConnectionState
new_state
)
override
{
}
void
OnIceGatheringChange
(
PeerConnectionInterface
:
:
IceGatheringState
new_state
)
override
{
}
void
OnIceCandidate
(
const
webrtc
:
:
IceCandidateInterface
*
candidate
)
override
{
}
}
;
}
class
PeerConnectionFactoryTest
:
public
:
:
testing
:
:
Test
{
void
SetUp
(
)
{
#
ifdef
WEBRTC_ANDROID
webrtc
:
:
InitializeAndroidObjects
(
)
;
#
endif
factory_
=
webrtc
:
:
CreatePeerConnectionFactory
(
rtc
:
:
Thread
:
:
Current
(
)
rtc
:
:
Thread
:
:
Current
(
)
rtc
:
:
Thread
:
:
Current
(
)
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDeviceModule
>
(
FakeAudioCaptureModule
:
:
Create
(
)
)
webrtc
:
:
CreateBuiltinAudioEncoderFactory
(
)
webrtc
:
:
CreateBuiltinAudioDecoderFactory
(
)
webrtc
:
:
CreateBuiltinVideoEncoderFactory
(
)
webrtc
:
:
CreateBuiltinVideoDecoderFactory
(
)
nullptr
nullptr
)
;
ASSERT_TRUE
(
factory_
.
get
(
)
!
=
NULL
)
;
port_allocator_
.
reset
(
new
cricket
:
:
FakePortAllocator
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
)
;
raw_port_allocator_
=
port_allocator_
.
get
(
)
;
}
protected
:
void
VerifyStunServers
(
cricket
:
:
ServerAddresses
stun_servers
)
{
EXPECT_EQ
(
stun_servers
raw_port_allocator_
-
>
stun_servers
(
)
)
;
}
void
VerifyTurnServers
(
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
)
{
EXPECT_EQ
(
turn_servers
.
size
(
)
raw_port_allocator_
-
>
turn_servers
(
)
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
turn_servers
.
size
(
)
;
+
+
i
)
{
ASSERT_EQ
(
1u
turn_servers
[
i
]
.
ports
.
size
(
)
)
;
EXPECT_EQ
(
1u
raw_port_allocator_
-
>
turn_servers
(
)
[
i
]
.
ports
.
size
(
)
)
;
EXPECT_EQ
(
turn_servers
[
i
]
.
ports
[
0
]
.
address
.
ToString
(
)
raw_port_allocator_
-
>
turn_servers
(
)
[
i
]
.
ports
[
0
]
.
address
.
ToString
(
)
)
;
EXPECT_EQ
(
turn_servers
[
i
]
.
ports
[
0
]
.
proto
raw_port_allocator_
-
>
turn_servers
(
)
[
i
]
.
ports
[
0
]
.
proto
)
;
EXPECT_EQ
(
turn_servers
[
i
]
.
credentials
.
username
raw_port_allocator_
-
>
turn_servers
(
)
[
i
]
.
credentials
.
username
)
;
EXPECT_EQ
(
turn_servers
[
i
]
.
credentials
.
password
raw_port_allocator_
-
>
turn_servers
(
)
[
i
]
.
credentials
.
password
)
;
}
}
void
VerifyAudioCodecCapability
(
const
webrtc
:
:
RtpCodecCapability
&
codec
)
{
EXPECT_EQ
(
codec
.
kind
cricket
:
:
MEDIA_TYPE_AUDIO
)
;
EXPECT_FALSE
(
codec
.
name
.
empty
(
)
)
;
EXPECT_GT
(
codec
.
clock_rate
0
)
;
EXPECT_GT
(
codec
.
num_channels
0
)
;
}
void
VerifyVideoCodecCapability
(
const
webrtc
:
:
RtpCodecCapability
&
codec
)
{
EXPECT_EQ
(
codec
.
kind
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
EXPECT_FALSE
(
codec
.
name
.
empty
(
)
)
;
EXPECT_GT
(
codec
.
clock_rate
0
)
;
}
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
factory_
;
NullPeerConnectionObserver
observer_
;
std
:
:
unique_ptr
<
cricket
:
:
FakePortAllocator
>
port_allocator_
;
cricket
:
:
FakePortAllocator
*
raw_port_allocator_
;
}
;
TEST
(
PeerConnectionFactoryTestInternal
DISABLED_CreatePCUsingInternalModules
)
{
#
ifdef
WEBRTC_ANDROID
webrtc
:
:
InitializeAndroidObjects
(
)
;
#
endif
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
factory
(
webrtc
:
:
CreatePeerConnectionFactory
(
nullptr
nullptr
nullptr
nullptr
webrtc
:
:
CreateBuiltinAudioEncoderFactory
(
)
webrtc
:
:
CreateBuiltinAudioDecoderFactory
(
)
webrtc
:
:
CreateBuiltinVideoEncoderFactory
(
)
webrtc
:
:
CreateBuiltinVideoDecoderFactory
(
)
nullptr
nullptr
)
)
;
NullPeerConnectionObserver
observer
;
webrtc
:
:
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
std
:
:
unique_ptr
<
FakeRTCCertificateGenerator
>
cert_generator
(
new
FakeRTCCertificateGenerator
(
)
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer
)
;
pc_dependencies
.
cert_generator
=
std
:
:
move
(
cert_generator
)
;
auto
result
=
factory
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
EXPECT_TRUE
(
result
.
ok
(
)
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CheckRtpSenderAudioCapabilities
)
{
webrtc
:
:
RtpCapabilities
audio_capabilities
=
factory_
-
>
GetRtpSenderCapabilities
(
cricket
:
:
MEDIA_TYPE_AUDIO
)
;
EXPECT_FALSE
(
audio_capabilities
.
codecs
.
empty
(
)
)
;
for
(
const
auto
&
codec
:
audio_capabilities
.
codecs
)
{
VerifyAudioCodecCapability
(
codec
)
;
}
EXPECT_FALSE
(
audio_capabilities
.
header_extensions
.
empty
(
)
)
;
for
(
const
auto
&
header_extension
:
audio_capabilities
.
header_extensions
)
{
EXPECT_FALSE
(
header_extension
.
uri
.
empty
(
)
)
;
}
}
TEST_F
(
PeerConnectionFactoryTest
CheckRtpSenderVideoCapabilities
)
{
webrtc
:
:
RtpCapabilities
video_capabilities
=
factory_
-
>
GetRtpSenderCapabilities
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
EXPECT_FALSE
(
video_capabilities
.
codecs
.
empty
(
)
)
;
for
(
const
auto
&
codec
:
video_capabilities
.
codecs
)
{
VerifyVideoCodecCapability
(
codec
)
;
}
EXPECT_FALSE
(
video_capabilities
.
header_extensions
.
empty
(
)
)
;
for
(
const
auto
&
header_extension
:
video_capabilities
.
header_extensions
)
{
EXPECT_FALSE
(
header_extension
.
uri
.
empty
(
)
)
;
}
}
TEST_F
(
PeerConnectionFactoryTest
CheckRtpSenderDataCapabilities
)
{
webrtc
:
:
RtpCapabilities
data_capabilities
=
factory_
-
>
GetRtpSenderCapabilities
(
cricket
:
:
MEDIA_TYPE_DATA
)
;
EXPECT_TRUE
(
data_capabilities
.
codecs
.
empty
(
)
)
;
EXPECT_TRUE
(
data_capabilities
.
header_extensions
.
empty
(
)
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CheckRtpReceiverAudioCapabilities
)
{
webrtc
:
:
RtpCapabilities
audio_capabilities
=
factory_
-
>
GetRtpReceiverCapabilities
(
cricket
:
:
MEDIA_TYPE_AUDIO
)
;
EXPECT_FALSE
(
audio_capabilities
.
codecs
.
empty
(
)
)
;
for
(
const
auto
&
codec
:
audio_capabilities
.
codecs
)
{
VerifyAudioCodecCapability
(
codec
)
;
}
EXPECT_FALSE
(
audio_capabilities
.
header_extensions
.
empty
(
)
)
;
for
(
const
auto
&
header_extension
:
audio_capabilities
.
header_extensions
)
{
EXPECT_FALSE
(
header_extension
.
uri
.
empty
(
)
)
;
}
}
TEST_F
(
PeerConnectionFactoryTest
CheckRtpReceiverVideoCapabilities
)
{
webrtc
:
:
RtpCapabilities
video_capabilities
=
factory_
-
>
GetRtpReceiverCapabilities
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
EXPECT_FALSE
(
video_capabilities
.
codecs
.
empty
(
)
)
;
for
(
const
auto
&
codec
:
video_capabilities
.
codecs
)
{
VerifyVideoCodecCapability
(
codec
)
;
}
EXPECT_FALSE
(
video_capabilities
.
header_extensions
.
empty
(
)
)
;
for
(
const
auto
&
header_extension
:
video_capabilities
.
header_extensions
)
{
EXPECT_FALSE
(
header_extension
.
uri
.
empty
(
)
)
;
}
}
TEST_F
(
PeerConnectionFactoryTest
CheckRtpReceiverDataCapabilities
)
{
webrtc
:
:
RtpCapabilities
data_capabilities
=
factory_
-
>
GetRtpReceiverCapabilities
(
cricket
:
:
MEDIA_TYPE_DATA
)
;
EXPECT_TRUE
(
data_capabilities
.
codecs
.
empty
(
)
)
;
EXPECT_TRUE
(
data_capabilities
.
header_extensions
.
empty
(
)
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CreatePCUsingIceServers
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
webrtc
:
:
PeerConnectionInterface
:
:
IceServer
ice_server
;
ice_server
.
uri
=
kStunIceServer
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kTurnIceServer
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kTurnIceServerWithTransport
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer_
)
;
pc_dependencies
.
cert_generator
=
std
:
:
make_unique
<
FakeRTCCertificateGenerator
>
(
)
;
pc_dependencies
.
allocator
=
std
:
:
move
(
port_allocator_
)
;
auto
result
=
factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
ASSERT_TRUE
(
result
.
ok
(
)
)
;
cricket
:
:
ServerAddresses
stun_servers
;
rtc
:
:
SocketAddress
stun1
(
"
stun
.
l
.
google
.
com
"
19302
)
;
stun_servers
.
insert
(
stun1
)
;
VerifyStunServers
(
stun_servers
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
;
cricket
:
:
RelayServerConfig
turn1
(
"
test
.
com
"
1234
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_UDP
)
;
turn_servers
.
push_back
(
turn1
)
;
cricket
:
:
RelayServerConfig
turn2
(
"
hello
.
com
"
kDefaultStunPort
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_TCP
)
;
turn_servers
.
push_back
(
turn2
)
;
VerifyTurnServers
(
turn_servers
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CreatePCUsingIceServersUrls
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
webrtc
:
:
PeerConnectionInterface
:
:
IceServer
ice_server
;
ice_server
.
urls
.
push_back
(
kStunIceServer
)
;
ice_server
.
urls
.
push_back
(
kTurnIceServer
)
;
ice_server
.
urls
.
push_back
(
kTurnIceServerWithTransport
)
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer_
)
;
pc_dependencies
.
cert_generator
=
std
:
:
make_unique
<
FakeRTCCertificateGenerator
>
(
)
;
pc_dependencies
.
allocator
=
std
:
:
move
(
port_allocator_
)
;
auto
result
=
factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
ASSERT_TRUE
(
result
.
ok
(
)
)
;
cricket
:
:
ServerAddresses
stun_servers
;
rtc
:
:
SocketAddress
stun1
(
"
stun
.
l
.
google
.
com
"
19302
)
;
stun_servers
.
insert
(
stun1
)
;
VerifyStunServers
(
stun_servers
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
;
cricket
:
:
RelayServerConfig
turn1
(
"
test
.
com
"
1234
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_UDP
)
;
turn_servers
.
push_back
(
turn1
)
;
cricket
:
:
RelayServerConfig
turn2
(
"
hello
.
com
"
kDefaultStunPort
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_TCP
)
;
turn_servers
.
push_back
(
turn2
)
;
VerifyTurnServers
(
turn_servers
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CreatePCUsingNoUsernameInUri
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
webrtc
:
:
PeerConnectionInterface
:
:
IceServer
ice_server
;
ice_server
.
uri
=
kStunIceServer
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kTurnIceServerWithNoUsernameInUri
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer_
)
;
pc_dependencies
.
cert_generator
=
std
:
:
make_unique
<
FakeRTCCertificateGenerator
>
(
)
;
pc_dependencies
.
allocator
=
std
:
:
move
(
port_allocator_
)
;
auto
result
=
factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
ASSERT_TRUE
(
result
.
ok
(
)
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
;
cricket
:
:
RelayServerConfig
turn
(
"
test
.
com
"
1234
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_UDP
)
;
turn_servers
.
push_back
(
turn
)
;
VerifyTurnServers
(
turn_servers
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CreatePCUsingTurnUrlWithTransportParam
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
webrtc
:
:
PeerConnectionInterface
:
:
IceServer
ice_server
;
ice_server
.
uri
=
kTurnIceServerWithTransport
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer_
)
;
pc_dependencies
.
cert_generator
=
std
:
:
make_unique
<
FakeRTCCertificateGenerator
>
(
)
;
pc_dependencies
.
allocator
=
std
:
:
move
(
port_allocator_
)
;
auto
result
=
factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
ASSERT_TRUE
(
result
.
ok
(
)
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
;
cricket
:
:
RelayServerConfig
turn
(
"
hello
.
com
"
kDefaultStunPort
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_TCP
)
;
turn_servers
.
push_back
(
turn
)
;
VerifyTurnServers
(
turn_servers
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CreatePCUsingSecureTurnUrl
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
webrtc
:
:
PeerConnectionInterface
:
:
IceServer
ice_server
;
ice_server
.
uri
=
kSecureTurnIceServer
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kSecureTurnIceServerWithoutTransportParam
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kSecureTurnIceServerWithoutTransportAndPortParam
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer_
)
;
pc_dependencies
.
cert_generator
=
std
:
:
make_unique
<
FakeRTCCertificateGenerator
>
(
)
;
pc_dependencies
.
allocator
=
std
:
:
move
(
port_allocator_
)
;
auto
result
=
factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
ASSERT_TRUE
(
result
.
ok
(
)
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
;
cricket
:
:
RelayServerConfig
turn1
(
"
hello
.
com
"
kDefaultStunTlsPort
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_TLS
)
;
turn_servers
.
push_back
(
turn1
)
;
cricket
:
:
RelayServerConfig
turn2
(
"
hello
.
com
"
443
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_TLS
)
;
turn_servers
.
push_back
(
turn2
)
;
cricket
:
:
RelayServerConfig
turn3
(
"
hello
.
com
"
kDefaultStunTlsPort
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_TLS
)
;
turn_servers
.
push_back
(
turn3
)
;
VerifyTurnServers
(
turn_servers
)
;
}
TEST_F
(
PeerConnectionFactoryTest
CreatePCUsingIPLiteralAddress
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
webrtc
:
:
SdpSemantics
:
:
kUnifiedPlan
;
webrtc
:
:
PeerConnectionInterface
:
:
IceServer
ice_server
;
ice_server
.
uri
=
kStunIceServerWithIPv4Address
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kStunIceServerWithIPv4AddressWithoutPort
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kStunIceServerWithIPv6Address
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kStunIceServerWithIPv6AddressWithoutPort
;
config
.
servers
.
push_back
(
ice_server
)
;
ice_server
.
uri
=
kTurnIceServerWithIPv6Address
;
ice_server
.
username
=
kTurnUsername
;
ice_server
.
password
=
kTurnPassword
;
config
.
servers
.
push_back
(
ice_server
)
;
webrtc
:
:
PeerConnectionDependencies
pc_dependencies
(
&
observer_
)
;
pc_dependencies
.
cert_generator
=
std
:
:
make_unique
<
FakeRTCCertificateGenerator
>
(
)
;
pc_dependencies
.
allocator
=
std
:
:
move
(
port_allocator_
)
;
auto
result
=
factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pc_dependencies
)
)
;
ASSERT_TRUE
(
result
.
ok
(
)
)
;
cricket
:
:
ServerAddresses
stun_servers
;
rtc
:
:
SocketAddress
stun1
(
"
1
.
2
.
3
.
4
"
1234
)
;
stun_servers
.
insert
(
stun1
)
;
rtc
:
:
SocketAddress
stun2
(
"
1
.
2
.
3
.
4
"
3478
)
;
stun_servers
.
insert
(
stun2
)
;
rtc
:
:
SocketAddress
stun3
(
"
2401
:
fa00
:
4
:
:
"
1234
)
;
stun_servers
.
insert
(
stun3
)
;
rtc
:
:
SocketAddress
stun4
(
"
2401
:
fa00
:
4
:
:
"
3478
)
;
stun_servers
.
insert
(
stun4
)
;
VerifyStunServers
(
stun_servers
)
;
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
;
cricket
:
:
RelayServerConfig
turn1
(
"
2401
:
fa00
:
4
:
:
"
1234
kTurnUsername
kTurnPassword
cricket
:
:
PROTO_UDP
)
;
turn_servers
.
push_back
(
turn1
)
;
VerifyTurnServers
(
turn_servers
)
;
}
TEST_F
(
PeerConnectionFactoryTest
LocalRendering
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
FakeVideoTrackSource
>
source
=
webrtc
:
:
FakeVideoTrackSource
:
:
Create
(
false
)
;
cricket
:
:
FakeFrameSource
frame_source
(
1280
720
rtc
:
:
kNumMicrosecsPerSec
/
30
)
;
ASSERT_TRUE
(
source
.
get
(
)
!
=
NULL
)
;
rtc
:
:
scoped_refptr
<
VideoTrackInterface
>
track
(
factory_
-
>
CreateVideoTrack
(
"
testlabel
"
source
)
)
;
ASSERT_TRUE
(
track
.
get
(
)
!
=
NULL
)
;
FakeVideoTrackRenderer
local_renderer
(
track
)
;
EXPECT_EQ
(
0
local_renderer
.
num_rendered_frames
(
)
)
;
source
-
>
InjectFrame
(
frame_source
.
GetFrame
(
)
)
;
EXPECT_EQ
(
1
local_renderer
.
num_rendered_frames
(
)
)
;
EXPECT_FALSE
(
local_renderer
.
black_frame
(
)
)
;
track
-
>
set_enabled
(
false
)
;
source
-
>
InjectFrame
(
frame_source
.
GetFrame
(
)
)
;
EXPECT_EQ
(
2
local_renderer
.
num_rendered_frames
(
)
)
;
EXPECT_TRUE
(
local_renderer
.
black_frame
(
)
)
;
track
-
>
set_enabled
(
true
)
;
source
-
>
InjectFrame
(
frame_source
.
GetFrame
(
)
)
;
EXPECT_EQ
(
3
local_renderer
.
num_rendered_frames
(
)
)
;
EXPECT_FALSE
(
local_renderer
.
black_frame
(
)
)
;
}
