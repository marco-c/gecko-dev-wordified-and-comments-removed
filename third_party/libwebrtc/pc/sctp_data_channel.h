#
ifndef
PC_SCTP_DATA_CHANNEL_H_
#
define
PC_SCTP_DATA_CHANNEL_H_
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
data_channel_interface
.
h
"
#
include
"
api
/
priority
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
transport
/
data_channel_transport_interface
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
pc
/
data_channel_utils
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
weak_ptr
.
h
"
namespace
webrtc
{
class
SctpDataChannel
;
class
SctpDataChannelControllerInterface
{
public
:
virtual
bool
SendData
(
int
sid
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
cricket
:
:
SendDataResult
*
result
)
=
0
;
virtual
bool
ConnectDataChannel
(
SctpDataChannel
*
data_channel
)
=
0
;
virtual
void
DisconnectDataChannel
(
SctpDataChannel
*
data_channel
)
=
0
;
virtual
void
AddSctpDataStream
(
int
sid
)
=
0
;
virtual
void
RemoveSctpDataStream
(
int
sid
)
=
0
;
virtual
bool
ReadyToSendData
(
)
const
=
0
;
virtual
void
OnChannelStateChanged
(
SctpDataChannel
*
data_channel
DataChannelInterface
:
:
DataState
state
)
=
0
;
protected
:
virtual
~
SctpDataChannelControllerInterface
(
)
{
}
}
;
struct
InternalDataChannelInit
:
public
DataChannelInit
{
enum
OpenHandshakeRole
{
kOpener
kAcker
kNone
}
;
InternalDataChannelInit
(
)
:
open_handshake_role
(
kOpener
)
{
}
explicit
InternalDataChannelInit
(
const
DataChannelInit
&
base
)
;
bool
IsValid
(
)
const
;
OpenHandshakeRole
open_handshake_role
;
}
;
class
SctpSidAllocator
{
public
:
bool
AllocateSid
(
rtc
:
:
SSLRole
role
int
*
sid
)
;
bool
ReserveSid
(
int
sid
)
;
void
ReleaseSid
(
int
sid
)
;
private
:
bool
IsSidAvailable
(
int
sid
)
const
;
std
:
:
set
<
int
>
used_sids_
;
}
;
class
SctpDataChannel
:
public
DataChannelInterface
public
sigslot
:
:
has_slots
<
>
{
public
:
static
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
Create
(
rtc
:
:
WeakPtr
<
SctpDataChannelControllerInterface
>
controller
const
std
:
:
string
&
label
const
InternalDataChannelInit
&
config
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
Thread
*
network_thread
)
;
static
rtc
:
:
scoped_refptr
<
DataChannelInterface
>
CreateProxy
(
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
channel
)
;
void
RegisterObserver
(
DataChannelObserver
*
observer
)
override
;
void
UnregisterObserver
(
)
override
;
std
:
:
string
label
(
)
const
override
{
return
label_
;
}
bool
reliable
(
)
const
override
;
bool
ordered
(
)
const
override
{
return
config_
.
ordered
;
}
uint16_t
maxRetransmitTime
(
)
const
override
{
return
config_
.
maxRetransmitTime
?
*
config_
.
maxRetransmitTime
:
static_cast
<
uint16_t
>
(
-
1
)
;
}
uint16_t
maxRetransmits
(
)
const
override
{
return
config_
.
maxRetransmits
?
*
config_
.
maxRetransmits
:
static_cast
<
uint16_t
>
(
-
1
)
;
}
absl
:
:
optional
<
int
>
maxPacketLifeTime
(
)
const
override
{
return
config_
.
maxRetransmitTime
;
}
absl
:
:
optional
<
int
>
maxRetransmitsOpt
(
)
const
override
{
return
config_
.
maxRetransmits
;
}
std
:
:
string
protocol
(
)
const
override
{
return
config_
.
protocol
;
}
bool
negotiated
(
)
const
override
{
return
config_
.
negotiated
;
}
int
id
(
)
const
override
{
return
config_
.
id
;
}
Priority
priority
(
)
const
override
{
return
config_
.
priority
?
*
config_
.
priority
:
Priority
:
:
kLow
;
}
virtual
int
internal_id
(
)
const
{
return
internal_id_
;
}
uint64_t
buffered_amount
(
)
const
override
;
void
Close
(
)
override
;
DataState
state
(
)
const
override
;
RTCError
error
(
)
const
override
;
uint32_t
messages_sent
(
)
const
override
;
uint64_t
bytes_sent
(
)
const
override
;
uint32_t
messages_received
(
)
const
override
;
uint64_t
bytes_received
(
)
const
override
;
bool
Send
(
const
DataBuffer
&
buffer
)
override
;
void
CloseAbruptlyWithError
(
RTCError
error
)
;
void
CloseAbruptlyWithDataChannelFailure
(
const
std
:
:
string
&
message
)
;
void
OnTransportReady
(
bool
writable
)
;
void
OnDataReceived
(
const
cricket
:
:
ReceiveDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
)
;
void
SetSctpSid
(
int
sid
)
;
void
OnClosingProcedureStartedRemotely
(
int
sid
)
;
void
OnClosingProcedureComplete
(
int
sid
)
;
void
OnTransportChannelCreated
(
)
;
void
OnTransportChannelClosed
(
RTCError
error
)
;
DataChannelStats
GetStats
(
)
const
;
static
void
ResetInternalIdAllocatorForTesting
(
int
new_value
)
;
protected
:
SctpDataChannel
(
const
InternalDataChannelInit
&
config
rtc
:
:
WeakPtr
<
SctpDataChannelControllerInterface
>
controller
const
std
:
:
string
&
label
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
Thread
*
network_thread
)
;
~
SctpDataChannel
(
)
override
;
private
:
enum
HandshakeState
{
kHandshakeInit
kHandshakeShouldSendOpen
kHandshakeShouldSendAck
kHandshakeWaitingForAck
kHandshakeReady
}
;
void
Init
(
)
;
void
UpdateState
(
)
;
void
SetState
(
DataState
state
)
;
void
DisconnectFromTransport
(
)
;
void
DeliverQueuedReceivedData
(
)
;
void
SendQueuedDataMessages
(
)
;
bool
SendDataMessage
(
const
DataBuffer
&
buffer
bool
queue_if_blocked
)
;
bool
QueueSendDataMessage
(
const
DataBuffer
&
buffer
)
;
void
SendQueuedControlMessages
(
)
;
void
QueueControlMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
bool
SendControlMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
rtc
:
:
Thread
*
const
signaling_thread_
;
rtc
:
:
Thread
*
const
network_thread_
;
const
int
internal_id_
;
const
std
:
:
string
label_
;
const
InternalDataChannelInit
config_
;
DataChannelObserver
*
observer_
RTC_GUARDED_BY
(
signaling_thread_
)
=
nullptr
;
DataState
state_
RTC_GUARDED_BY
(
signaling_thread_
)
=
kConnecting
;
RTCError
error_
RTC_GUARDED_BY
(
signaling_thread_
)
;
uint32_t
messages_sent_
RTC_GUARDED_BY
(
signaling_thread_
)
=
0
;
uint64_t
bytes_sent_
RTC_GUARDED_BY
(
signaling_thread_
)
=
0
;
uint32_t
messages_received_
RTC_GUARDED_BY
(
signaling_thread_
)
=
0
;
uint64_t
bytes_received_
RTC_GUARDED_BY
(
signaling_thread_
)
=
0
;
rtc
:
:
WeakPtr
<
SctpDataChannelControllerInterface
>
controller_
RTC_GUARDED_BY
(
signaling_thread_
)
;
HandshakeState
handshake_state_
RTC_GUARDED_BY
(
signaling_thread_
)
=
kHandshakeInit
;
bool
connected_to_transport_
RTC_GUARDED_BY
(
signaling_thread_
)
=
false
;
bool
writable_
RTC_GUARDED_BY
(
signaling_thread_
)
=
false
;
bool
started_closing_procedure_
RTC_GUARDED_BY
(
signaling_thread_
)
=
false
;
PacketQueue
queued_control_data_
RTC_GUARDED_BY
(
signaling_thread_
)
;
PacketQueue
queued_received_data_
RTC_GUARDED_BY
(
signaling_thread_
)
;
PacketQueue
queued_send_data_
RTC_GUARDED_BY
(
signaling_thread_
)
;
}
;
SctpDataChannel
*
DowncastProxiedDataChannelInterfaceToSctpDataChannelForTesting
(
DataChannelInterface
*
channel
)
;
}
#
endif
