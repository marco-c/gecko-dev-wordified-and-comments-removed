#
include
"
pc
/
connection_context
.
h
"
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
api
/
transport
/
field_trial_based_config
.
h
"
#
include
"
media
/
sctp
/
sctp_transport_factory
.
h
"
#
include
"
rtc_base
/
helpers
.
h
"
#
include
"
rtc_base
/
ref_counted_object
.
h
"
#
include
"
rtc_base
/
task_utils
/
to_queued_task
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
{
rtc
:
:
Thread
*
MaybeStartThread
(
rtc
:
:
Thread
*
old_thread
const
std
:
:
string
&
thread_name
bool
with_socket_server
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
&
thread_holder
)
{
if
(
old_thread
)
{
return
old_thread
;
}
if
(
with_socket_server
)
{
thread_holder
=
rtc
:
:
Thread
:
:
CreateWithSocketServer
(
)
;
}
else
{
thread_holder
=
rtc
:
:
Thread
:
:
Create
(
)
;
}
thread_holder
-
>
SetName
(
thread_name
nullptr
)
;
thread_holder
-
>
Start
(
)
;
return
thread_holder
.
get
(
)
;
}
rtc
:
:
Thread
*
MaybeWrapThread
(
rtc
:
:
Thread
*
signaling_thread
bool
&
wraps_current_thread
)
{
wraps_current_thread
=
false
;
if
(
signaling_thread
)
{
return
signaling_thread
;
}
auto
this_thread
=
rtc
:
:
Thread
:
:
Current
(
)
;
if
(
!
this_thread
)
{
this_thread
=
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
WrapCurrentThread
(
)
;
wraps_current_thread
=
true
;
}
return
this_thread
;
}
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
MaybeCreateSctpFactory
(
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
factory
rtc
:
:
Thread
*
network_thread
)
{
if
(
factory
)
{
return
factory
;
}
#
ifdef
WEBRTC_HAVE_SCTP
return
std
:
:
make_unique
<
cricket
:
:
SctpTransportFactory
>
(
network_thread
)
;
#
else
return
nullptr
;
#
endif
}
}
rtc
:
:
scoped_refptr
<
ConnectionContext
>
ConnectionContext
:
:
Create
(
PeerConnectionFactoryDependencies
*
dependencies
)
{
return
new
rtc
:
:
RefCountedObject
<
ConnectionContext
>
(
dependencies
)
;
}
ConnectionContext
:
:
ConnectionContext
(
PeerConnectionFactoryDependencies
*
dependencies
)
:
network_thread_
(
MaybeStartThread
(
dependencies
-
>
network_thread
"
pc_network_thread
"
true
owned_network_thread_
)
)
worker_thread_
(
MaybeStartThread
(
dependencies
-
>
worker_thread
"
pc_worker_thread
"
false
owned_worker_thread_
)
)
signaling_thread_
(
MaybeWrapThread
(
dependencies
-
>
signaling_thread
wraps_current_thread_
)
)
network_monitor_factory_
(
std
:
:
move
(
dependencies
-
>
network_monitor_factory
)
)
call_factory_
(
std
:
:
move
(
dependencies
-
>
call_factory
)
)
sctp_factory_
(
MaybeCreateSctpFactory
(
std
:
:
move
(
dependencies
-
>
sctp_factory
)
network_thread
(
)
)
)
trials_
(
dependencies
-
>
trials
?
std
:
:
move
(
dependencies
-
>
trials
)
:
std
:
:
make_unique
<
FieldTrialBasedConfig
>
(
)
)
{
signaling_thread_
-
>
AllowInvokesToThread
(
worker_thread_
)
;
signaling_thread_
-
>
AllowInvokesToThread
(
network_thread_
)
;
worker_thread_
-
>
AllowInvokesToThread
(
network_thread_
)
;
if
(
network_thread_
-
>
IsCurrent
(
)
)
{
network_thread_
-
>
DisallowAllInvokes
(
)
;
}
else
{
network_thread_
-
>
PostTask
(
ToQueuedTask
(
[
thread
=
network_thread_
]
{
thread
-
>
DisallowBlockingCalls
(
)
;
thread
-
>
DisallowAllInvokes
(
)
;
}
)
)
;
}
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
rtc
:
:
InitRandom
(
rtc
:
:
Time32
(
)
)
;
default_network_manager_
=
std
:
:
make_unique
<
rtc
:
:
BasicNetworkManager
>
(
network_monitor_factory_
.
get
(
)
)
;
default_socket_factory_
=
std
:
:
make_unique
<
rtc
:
:
BasicPacketSocketFactory
>
(
network_thread
(
)
)
;
worker_thread_
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
[
&
]
(
)
{
channel_manager_
=
cricket
:
:
ChannelManager
:
:
Create
(
std
:
:
move
(
dependencies
-
>
media_engine
)
true
worker_thread
(
)
network_thread
(
)
)
;
}
)
;
signaling_thread_
-
>
SetDispatchWarningMs
(
100
)
;
worker_thread_
-
>
SetDispatchWarningMs
(
30
)
;
network_thread_
-
>
SetDispatchWarningMs
(
10
)
;
}
ConnectionContext
:
:
~
ConnectionContext
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
worker_thread_
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
[
&
]
(
)
{
channel_manager_
.
reset
(
nullptr
)
;
}
)
;
default_socket_factory_
=
nullptr
;
default_network_manager_
=
nullptr
;
if
(
wraps_current_thread_
)
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
UnwrapCurrentThread
(
)
;
}
cricket
:
:
ChannelManager
*
ConnectionContext
:
:
channel_manager
(
)
const
{
return
channel_manager_
.
get
(
)
;
}
}
