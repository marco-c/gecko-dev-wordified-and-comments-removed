#
include
"
pc
/
connection_context
.
h
"
#
include
<
utility
>
#
include
"
api
/
transport
/
field_trial_based_config
.
h
"
#
include
"
media
/
base
/
rtp_data_engine
.
h
"
namespace
webrtc
{
namespace
{
rtc
:
:
Thread
*
MaybeStartThread
(
rtc
:
:
Thread
*
old_thread
const
std
:
:
string
&
thread_name
bool
with_socket_server
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
&
thread_holder
)
{
if
(
old_thread
)
{
return
old_thread
;
}
if
(
with_socket_server
)
{
thread_holder
=
rtc
:
:
Thread
:
:
CreateWithSocketServer
(
)
;
}
else
{
thread_holder
=
rtc
:
:
Thread
:
:
Create
(
)
;
}
thread_holder
-
>
SetName
(
thread_name
nullptr
)
;
thread_holder
-
>
Start
(
)
;
return
thread_holder
.
get
(
)
;
}
rtc
:
:
Thread
*
MaybeWrapThread
(
rtc
:
:
Thread
*
signaling_thread
bool
&
wraps_current_thread
)
{
wraps_current_thread
=
false
;
if
(
signaling_thread
)
{
return
signaling_thread
;
}
auto
this_thread
=
rtc
:
:
Thread
:
:
Current
(
)
;
if
(
!
this_thread
)
{
this_thread
=
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
WrapCurrentThread
(
)
;
wraps_current_thread
=
true
;
}
return
this_thread
;
}
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
MaybeCreateSctpFactory
(
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
factory
rtc
:
:
Thread
*
network_thread
)
{
if
(
factory
)
{
return
factory
;
}
#
ifdef
HAVE_SCTP
return
std
:
:
make_unique
<
cricket
:
:
SctpTransportFactory
>
(
network_thread
)
;
#
else
return
nullptr
;
#
endif
}
}
ConnectionContext
:
:
ConnectionContext
(
PeerConnectionFactoryDependencies
&
dependencies
)
:
network_thread_
(
MaybeStartThread
(
dependencies
.
network_thread
"
pc_network_thread
"
true
owned_network_thread_
)
)
worker_thread_
(
MaybeStartThread
(
dependencies
.
worker_thread
"
pc_worker_thread
"
false
owned_worker_thread_
)
)
signaling_thread_
(
MaybeWrapThread
(
dependencies
.
signaling_thread
wraps_current_thread_
)
)
network_monitor_factory_
(
std
:
:
move
(
dependencies
.
network_monitor_factory
)
)
call_factory_
(
std
:
:
move
(
dependencies
.
call_factory
)
)
media_engine_
(
std
:
:
move
(
dependencies
.
media_engine
)
)
sctp_factory_
(
MaybeCreateSctpFactory
(
std
:
:
move
(
dependencies
.
sctp_factory
)
network_thread
(
)
)
)
trials_
(
dependencies
.
trials
?
std
:
:
move
(
dependencies
.
trials
)
:
std
:
:
make_unique
<
FieldTrialBasedConfig
>
(
)
)
{
signaling_thread_
-
>
AllowInvokesToThread
(
worker_thread_
)
;
signaling_thread_
-
>
AllowInvokesToThread
(
network_thread_
)
;
worker_thread_
-
>
AllowInvokesToThread
(
network_thread_
)
;
network_thread_
-
>
DisallowAllInvokes
(
)
;
}
ConnectionContext
:
:
~
ConnectionContext
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
channel_manager_
.
reset
(
nullptr
)
;
default_socket_factory_
=
nullptr
;
default_network_manager_
=
nullptr
;
if
(
wraps_current_thread_
)
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
UnwrapCurrentThread
(
)
;
}
void
ConnectionContext
:
:
SetOptions
(
const
PeerConnectionFactoryInterface
:
:
Options
&
options
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
options_
=
options
;
}
bool
ConnectionContext
:
:
Initialize
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
rtc
:
:
InitRandom
(
rtc
:
:
Time32
(
)
)
;
default_network_manager_
.
reset
(
new
rtc
:
:
BasicNetworkManager
(
network_monitor_factory_
.
get
(
)
)
)
;
if
(
!
default_network_manager_
)
{
return
false
;
}
default_socket_factory_
.
reset
(
new
rtc
:
:
BasicPacketSocketFactory
(
network_thread
(
)
)
)
;
if
(
!
default_socket_factory_
)
{
return
false
;
}
channel_manager_
=
std
:
:
make_unique
<
cricket
:
:
ChannelManager
>
(
std
:
:
move
(
media_engine_
)
std
:
:
make_unique
<
cricket
:
:
RtpDataEngine
>
(
)
worker_thread
(
)
network_thread
(
)
)
;
channel_manager_
-
>
SetVideoRtxEnabled
(
true
)
;
return
channel_manager_
-
>
Init
(
)
;
}
cricket
:
:
ChannelManager
*
ConnectionContext
:
:
channel_manager
(
)
const
{
return
channel_manager_
.
get
(
)
;
}
}
