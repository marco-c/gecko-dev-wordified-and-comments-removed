#
include
"
pc
/
connection_context
.
h
"
#
include
<
memory
>
#
include
<
utility
>
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
transport
/
sctp_transport_factory_interface
.
h
"
#
include
"
media
/
base
/
media_engine
.
h
"
#
include
"
media
/
sctp
/
sctp_transport_factory
.
h
"
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
#
include
"
pc
/
media_factory
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
crypto_random
.
h
"
#
include
"
rtc_base
/
internal
/
default_socket_server
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
socket_factory
.
h
"
#
include
"
rtc_base
/
socket_server
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
{
Thread
*
MaybeStartNetworkThread
(
Thread
*
old_thread
std
:
:
unique_ptr
<
SocketFactory
>
&
socket_factory_holder
std
:
:
unique_ptr
<
Thread
>
&
thread_holder
)
{
if
(
old_thread
)
{
return
old_thread
;
}
std
:
:
unique_ptr
<
SocketServer
>
socket_server
=
CreateDefaultSocketServer
(
)
;
thread_holder
=
std
:
:
make_unique
<
Thread
>
(
socket_server
.
get
(
)
)
;
socket_factory_holder
=
std
:
:
move
(
socket_server
)
;
thread_holder
-
>
SetName
(
"
pc_network_thread
"
nullptr
)
;
thread_holder
-
>
Start
(
)
;
return
thread_holder
.
get
(
)
;
}
Thread
*
MaybeWrapThread
(
Thread
*
signaling_thread
bool
&
wraps_current_thread
)
{
wraps_current_thread
=
false
;
if
(
signaling_thread
)
{
return
signaling_thread
;
}
auto
this_thread
=
Thread
:
:
Current
(
)
;
if
(
!
this_thread
)
{
this_thread
=
ThreadManager
:
:
Instance
(
)
-
>
WrapCurrentThread
(
)
;
wraps_current_thread
=
true
;
}
return
this_thread
;
}
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
MaybeCreateSctpFactory
(
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
factory
Thread
*
network_thread
)
{
if
(
factory
)
{
return
factory
;
}
#
ifdef
WEBRTC_HAVE_SCTP
return
std
:
:
make_unique
<
cricket
:
:
SctpTransportFactory
>
(
network_thread
)
;
#
else
return
nullptr
;
#
endif
}
}
rtc
:
:
scoped_refptr
<
ConnectionContext
>
ConnectionContext
:
:
Create
(
const
Environment
&
env
PeerConnectionFactoryDependencies
*
dependencies
)
{
return
rtc
:
:
scoped_refptr
<
ConnectionContext
>
(
new
ConnectionContext
(
env
dependencies
)
)
;
}
ConnectionContext
:
:
ConnectionContext
(
const
Environment
&
env
PeerConnectionFactoryDependencies
*
dependencies
)
:
network_thread_
(
MaybeStartNetworkThread
(
dependencies
-
>
network_thread
owned_socket_factory_
owned_network_thread_
)
)
worker_thread_
(
dependencies
-
>
worker_thread
[
]
(
)
{
auto
thread_holder
=
Thread
:
:
Create
(
)
;
thread_holder
-
>
SetName
(
"
pc_worker_thread
"
nullptr
)
;
thread_holder
-
>
Start
(
)
;
return
thread_holder
;
}
)
signaling_thread_
(
MaybeWrapThread
(
dependencies
-
>
signaling_thread
wraps_current_thread_
)
)
env_
(
env
)
media_engine_
(
dependencies
-
>
media_factory
!
=
nullptr
?
dependencies
-
>
media_factory
-
>
CreateMediaEngine
(
env_
*
dependencies
)
:
nullptr
)
network_monitor_factory_
(
std
:
:
move
(
dependencies
-
>
network_monitor_factory
)
)
default_network_manager_
(
std
:
:
move
(
dependencies
-
>
network_manager
)
)
call_factory_
(
std
:
:
move
(
dependencies
-
>
media_factory
)
)
default_socket_factory_
(
std
:
:
move
(
dependencies
-
>
packet_socket_factory
)
)
sctp_factory_
(
MaybeCreateSctpFactory
(
std
:
:
move
(
dependencies
-
>
sctp_factory
)
network_thread
(
)
)
)
use_rtx_
(
true
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
RTC_DCHECK
(
!
(
default_network_manager_
&
&
network_monitor_factory_
)
)
<
<
"
You
can
'
t
set
both
network_manager
and
network_monitor_factory
.
"
;
signaling_thread_
-
>
AllowInvokesToThread
(
worker_thread
(
)
)
;
signaling_thread_
-
>
AllowInvokesToThread
(
network_thread_
)
;
worker_thread_
-
>
AllowInvokesToThread
(
network_thread_
)
;
if
(
!
network_thread_
-
>
IsCurrent
(
)
)
{
network_thread_
-
>
PostTask
(
[
thread
=
network_thread_
worker_thread
=
worker_thread_
.
get
(
)
]
{
thread
-
>
DisallowBlockingCalls
(
)
;
thread
-
>
DisallowAllInvokes
(
)
;
if
(
worker_thread
=
=
thread
)
{
thread
-
>
AllowInvokesToThread
(
thread
)
;
}
}
)
;
}
InitRandom
(
Time32
(
)
)
;
SocketFactory
*
socket_factory
=
dependencies
-
>
socket_factory
;
if
(
socket_factory
=
=
nullptr
)
{
if
(
owned_socket_factory_
)
{
socket_factory
=
owned_socket_factory_
.
get
(
)
;
}
else
{
socket_factory
=
network_thread
(
)
-
>
socketserver
(
)
;
}
}
if
(
!
default_network_manager_
)
{
default_network_manager_
=
std
:
:
make_unique
<
BasicNetworkManager
>
(
env
socket_factory
network_monitor_factory_
.
get
(
)
)
;
}
if
(
!
default_socket_factory_
)
{
default_socket_factory_
=
std
:
:
make_unique
<
BasicPacketSocketFactory
>
(
socket_factory
)
;
}
signaling_thread_
-
>
SetDispatchWarningMs
(
100
)
;
worker_thread_
-
>
SetDispatchWarningMs
(
30
)
;
network_thread_
-
>
SetDispatchWarningMs
(
10
)
;
if
(
media_engine_
)
{
worker_thread_
-
>
BlockingCall
(
[
&
]
{
media_engine_
-
>
Init
(
)
;
}
)
;
}
}
ConnectionContext
:
:
~
ConnectionContext
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
worker_thread_
-
>
PostTask
(
[
media_engine
=
std
:
:
move
(
media_engine_
)
]
{
}
)
;
default_socket_factory_
=
nullptr
;
default_network_manager_
=
nullptr
;
if
(
wraps_current_thread_
)
ThreadManager
:
:
Instance
(
)
-
>
UnwrapCurrentThread
(
)
;
}
}
