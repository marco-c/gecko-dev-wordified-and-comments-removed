#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
audio
/
audio_mixer
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_encoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
opus_audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
opus_audio_encoder_factory
.
h
"
#
include
"
api
/
create_peerconnection_factory
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
media_types
.
h
"
#
include
"
api
/
peer_connection_interface
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
api
/
rtp_sender_interface
.
h
"
#
include
"
api
/
rtp_transceiver_direction
.
h
"
#
include
"
api
/
rtp_transceiver_interface
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
stats
/
rtcstats_objects
.
h
"
#
include
"
api
/
uma_metrics
.
h
"
#
include
"
api
/
video
/
video_codec_constants
.
h
"
#
include
"
api
/
video_codecs
/
builtin_video_decoder_factory
.
h
"
#
include
"
api
/
video_codecs
/
builtin_video_encoder_factory
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
media
/
base
/
rid_description
.
h
"
#
include
"
media
/
base
/
stream_params
.
h
"
#
include
"
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
pc
/
channel_interface
.
h
"
#
include
"
pc
/
peer_connection_wrapper
.
h
"
#
include
"
pc
/
sdp_utils
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
simulcast_description
.
h
"
#
include
"
pc
/
test
/
fake_audio_capture_module
.
h
"
#
include
"
pc
/
test
/
mock_peer_connection_observers
.
h
"
#
include
"
pc
/
test
/
peer_connection_test_wrapper
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
physical_socket_server
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
unique_id_generator
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
#
include
"
test
/
field_trial
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
using
:
:
testing
:
:
Contains
;
using
:
:
testing
:
:
Each
;
using
:
:
testing
:
:
ElementsAre
;
using
:
:
testing
:
:
ElementsAreArray
;
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
Field
;
using
:
:
testing
:
:
IsEmpty
;
using
:
:
testing
:
:
Le
;
using
:
:
testing
:
:
Ne
;
using
:
:
testing
:
:
Optional
;
using
:
:
testing
:
:
Pair
;
using
:
:
testing
:
:
Property
;
using
:
:
testing
:
:
SizeIs
;
using
:
:
testing
:
:
StartsWith
;
using
:
:
testing
:
:
StrCaseEq
;
using
:
:
testing
:
:
StrEq
;
using
cricket
:
:
MediaContentDescription
;
using
cricket
:
:
RidDescription
;
using
cricket
:
:
SimulcastDescription
;
using
cricket
:
:
SimulcastLayer
;
using
cricket
:
:
StreamParams
;
namespace
cricket
{
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
SimulcastLayer
&
layer
)
{
if
(
layer
.
is_paused
)
{
os
<
<
"
~
"
;
}
return
os
<
<
layer
.
rid
;
}
}
namespace
{
std
:
:
vector
<
SimulcastLayer
>
CreateLayers
(
const
std
:
:
vector
<
std
:
:
string
>
&
rids
const
std
:
:
vector
<
bool
>
&
active
)
{
RTC_DCHECK_EQ
(
rids
.
size
(
)
active
.
size
(
)
)
;
std
:
:
vector
<
SimulcastLayer
>
result
;
absl
:
:
c_transform
(
rids
active
std
:
:
back_inserter
(
result
)
[
]
(
const
std
:
:
string
&
rid
bool
is_active
)
{
return
SimulcastLayer
(
rid
!
is_active
)
;
}
)
;
return
result
;
}
std
:
:
vector
<
SimulcastLayer
>
CreateLayers
(
const
std
:
:
vector
<
std
:
:
string
>
&
rids
bool
active
)
{
return
CreateLayers
(
rids
std
:
:
vector
<
bool
>
(
rids
.
size
(
)
active
)
)
;
}
#
if
RTC_METRICS_ENABLED
std
:
:
vector
<
SimulcastLayer
>
CreateLayers
(
int
num_layers
bool
active
)
{
rtc
:
:
UniqueStringGenerator
rid_generator
;
std
:
:
vector
<
std
:
:
string
>
rids
;
for
(
int
i
=
0
;
i
<
num_layers
;
+
+
i
)
{
rids
.
push_back
(
rid_generator
.
GenerateString
(
)
)
;
}
return
CreateLayers
(
rids
active
)
;
}
#
endif
bool
IsReliabilityMechanism
(
const
webrtc
:
:
RtpCodecCapability
&
codec
)
{
return
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kRtxCodecName
)
|
|
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kRedCodecName
)
|
|
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kUlpfecCodecName
)
;
}
std
:
:
string
GetCurrentCodecMimeType
(
rtc
:
:
scoped_refptr
<
const
webrtc
:
:
RTCStatsReport
>
report
const
webrtc
:
:
RTCOutboundRtpStreamStats
&
outbound_rtp
)
{
return
outbound_rtp
.
codec_id
.
is_defined
(
)
?
*
report
-
>
GetAs
<
webrtc
:
:
RTCCodecStats
>
(
*
outbound_rtp
.
codec_id
)
-
>
mime_type
:
"
"
;
}
struct
RidAndResolution
{
std
:
:
string
rid
;
uint32_t
width
;
uint32_t
height
;
}
;
const
webrtc
:
:
RTCOutboundRtpStreamStats
*
FindOutboundRtpByRid
(
const
std
:
:
vector
<
const
webrtc
:
:
RTCOutboundRtpStreamStats
*
>
&
outbound_rtps
const
absl
:
:
string_view
&
rid
)
{
for
(
const
auto
*
outbound_rtp
:
outbound_rtps
)
{
if
(
outbound_rtp
-
>
rid
.
is_defined
(
)
&
&
*
outbound_rtp
-
>
rid
=
=
rid
)
{
return
outbound_rtp
;
}
}
return
nullptr
;
}
}
namespace
webrtc
{
constexpr
TimeDelta
kDefaultTimeout
=
TimeDelta
:
:
Seconds
(
5
)
;
#
if
!
defined
(
ADDRESS_SANITIZER
)
constexpr
TimeDelta
kLongTimeoutForRampingUp
=
TimeDelta
:
:
Seconds
(
30
)
;
#
endif
class
PeerConnectionSimulcastTests
:
public
:
:
testing
:
:
Test
{
public
:
PeerConnectionSimulcastTests
(
)
:
pc_factory_
(
CreatePeerConnectionFactory
(
rtc
:
:
Thread
:
:
Current
(
)
rtc
:
:
Thread
:
:
Current
(
)
rtc
:
:
Thread
:
:
Current
(
)
FakeAudioCaptureModule
:
:
Create
(
)
CreateBuiltinAudioEncoderFactory
(
)
CreateBuiltinAudioDecoderFactory
(
)
CreateBuiltinVideoEncoderFactory
(
)
CreateBuiltinVideoDecoderFactory
(
)
nullptr
nullptr
)
)
{
}
rtc
:
:
scoped_refptr
<
PeerConnectionInterface
>
CreatePeerConnection
(
MockPeerConnectionObserver
*
observer
)
{
PeerConnectionInterface
:
:
RTCConfiguration
config
;
config
.
sdp_semantics
=
SdpSemantics
:
:
kUnifiedPlan
;
PeerConnectionDependencies
pcd
(
observer
)
;
auto
result
=
pc_factory_
-
>
CreatePeerConnectionOrError
(
config
std
:
:
move
(
pcd
)
)
;
EXPECT_TRUE
(
result
.
ok
(
)
)
;
observer
-
>
SetPeerConnectionInterface
(
result
.
value
(
)
.
get
(
)
)
;
return
result
.
MoveValue
(
)
;
}
std
:
:
unique_ptr
<
PeerConnectionWrapper
>
CreatePeerConnectionWrapper
(
)
{
auto
observer
=
std
:
:
make_unique
<
MockPeerConnectionObserver
>
(
)
;
auto
pc
=
CreatePeerConnection
(
observer
.
get
(
)
)
;
return
std
:
:
make_unique
<
PeerConnectionWrapper
>
(
pc_factory_
pc
std
:
:
move
(
observer
)
)
;
}
void
ExchangeOfferAnswer
(
PeerConnectionWrapper
*
local
PeerConnectionWrapper
*
remote
const
std
:
:
vector
<
SimulcastLayer
>
&
answer_layers
)
{
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
err
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
err
)
)
<
<
err
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
auto
mcd_answer
=
answer
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
auto
&
receive_layers
=
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
;
for
(
const
SimulcastLayer
&
layer
:
answer_layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
err
)
)
<
<
err
;
}
RtpTransceiverInit
CreateTransceiverInit
(
const
std
:
:
vector
<
SimulcastLayer
>
&
layers
)
{
RtpTransceiverInit
init
;
for
(
const
SimulcastLayer
&
layer
:
layers
)
{
RtpEncodingParameters
encoding
;
encoding
.
rid
=
layer
.
rid
;
encoding
.
active
=
!
layer
.
is_paused
;
init
.
send_encodings
.
push_back
(
encoding
)
;
}
return
init
;
}
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
AddTransceiver
(
PeerConnectionWrapper
*
pc
const
std
:
:
vector
<
SimulcastLayer
>
&
layers
cricket
:
:
MediaType
media_type
=
cricket
:
:
MEDIA_TYPE_VIDEO
)
{
auto
init
=
CreateTransceiverInit
(
layers
)
;
return
pc
-
>
AddTransceiver
(
media_type
init
)
;
}
SimulcastDescription
RemoveSimulcast
(
SessionDescriptionInterface
*
sd
)
{
auto
mcd
=
sd
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
auto
result
=
mcd
-
>
simulcast_description
(
)
;
mcd
-
>
set_simulcast_description
(
SimulcastDescription
(
)
)
;
return
result
;
}
void
AddRequestToReceiveSimulcast
(
const
std
:
:
vector
<
SimulcastLayer
>
&
layers
SessionDescriptionInterface
*
sd
)
{
auto
mcd
=
sd
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
SimulcastDescription
simulcast
;
auto
&
receive_layers
=
simulcast
.
receive_layers
(
)
;
for
(
const
SimulcastLayer
&
layer
:
layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
mcd
-
>
set_simulcast_description
(
simulcast
)
;
}
void
ValidateTransceiverParameters
(
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
const
std
:
:
vector
<
SimulcastLayer
>
&
layers
)
{
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
std
:
:
vector
<
SimulcastLayer
>
result_layers
;
absl
:
:
c_transform
(
parameters
.
encodings
std
:
:
back_inserter
(
result_layers
)
[
]
(
const
RtpEncodingParameters
&
encoding
)
{
return
SimulcastLayer
(
encoding
.
rid
!
encoding
.
active
)
;
}
)
;
EXPECT_THAT
(
result_layers
ElementsAreArray
(
layers
)
)
;
}
private
:
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
pc_factory_
;
}
;
#
if
RTC_METRICS_ENABLED
class
PeerConnectionSimulcastMetricsTests
:
public
PeerConnectionSimulcastTests
public
:
:
testing
:
:
WithParamInterface
<
int
>
{
protected
:
PeerConnectionSimulcastMetricsTests
(
)
{
webrtc
:
:
metrics
:
:
Reset
(
)
;
}
std
:
:
map
<
int
int
>
LocalDescriptionSamples
(
)
{
return
metrics
:
:
Samples
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
ApplyLocalDescription
"
)
;
}
std
:
:
map
<
int
int
>
RemoteDescriptionSamples
(
)
{
return
metrics
:
:
Samples
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
ApplyRemoteDescription
"
)
;
}
}
;
#
endif
TEST_F
(
PeerConnectionSimulcastTests
CanCreateTransceiverWithRid
)
{
auto
pc
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
pc
.
get
(
)
layers
)
;
ASSERT_TRUE
(
transceiver
)
;
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
EXPECT_THAT
(
parameters
.
encodings
ElementsAre
(
Field
(
"
rid
"
&
RtpEncodingParameters
:
:
rid
Eq
(
"
"
)
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
CanCreateTransceiverWithSimulcast
)
{
auto
pc
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
pc
.
get
(
)
layers
)
;
ASSERT_TRUE
(
transceiver
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
RidsAreAutogeneratedIfNotProvided
)
{
auto
pc
=
CreatePeerConnectionWrapper
(
)
;
auto
init
=
CreateTransceiverInit
(
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
)
;
for
(
RtpEncodingParameters
&
parameters
:
init
.
send_encodings
)
{
parameters
.
rid
=
"
"
;
}
auto
transceiver
=
pc
-
>
AddTransceiver
(
cricket
:
:
MEDIA_TYPE_VIDEO
init
)
;
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
ASSERT_EQ
(
3u
parameters
.
encodings
.
size
(
)
)
;
EXPECT_THAT
(
parameters
.
encodings
Each
(
Field
(
"
rid
"
&
RtpEncodingParameters
:
:
rid
Ne
(
"
"
)
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
MustSupplyAllOrNoRidsInSimulcast
)
{
auto
pc_wrapper
=
CreatePeerConnectionWrapper
(
)
;
auto
pc
=
pc_wrapper
-
>
pc
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
remove
"
}
true
)
;
auto
init
=
CreateTransceiverInit
(
layers
)
;
init
.
send_encodings
[
2
]
.
rid
=
"
"
;
auto
error
=
pc
-
>
AddTransceiver
(
cricket
:
:
MEDIA_TYPE_VIDEO
init
)
;
EXPECT_EQ
(
RTCErrorType
:
:
INVALID_PARAMETER
error
.
error
(
)
.
type
(
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
ChecksForIllegalRidValues
)
{
auto
pc_wrapper
=
CreatePeerConnectionWrapper
(
)
;
auto
pc
=
pc_wrapper
-
>
pc
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
~
q
"
}
true
)
;
auto
init
=
CreateTransceiverInit
(
layers
)
;
auto
error
=
pc
-
>
AddTransceiver
(
cricket
:
:
MEDIA_TYPE_VIDEO
init
)
;
EXPECT_EQ
(
RTCErrorType
:
:
INVALID_PARAMETER
error
.
error
(
)
.
type
(
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
SingleRidIsRemovedFromSessionDescription
)
{
auto
pc
=
CreatePeerConnectionWrapper
(
)
;
auto
transceiver
=
AddTransceiver
(
pc
.
get
(
)
CreateLayers
(
{
"
1
"
}
true
)
)
;
auto
offer
=
pc
-
>
CreateOfferAndSetAsLocal
(
)
;
ASSERT_TRUE
(
offer
)
;
auto
contents
=
offer
-
>
description
(
)
-
>
contents
(
)
;
ASSERT_EQ
(
1u
contents
.
size
(
)
)
;
EXPECT_THAT
(
contents
[
0
]
.
media_description
(
)
-
>
streams
(
)
ElementsAre
(
Property
(
&
StreamParams
:
:
has_rids
false
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
SimulcastLayersRemovedFromTail
)
{
static_assert
(
kMaxSimulcastStreams
<
8
"
Test
assumes
that
the
platform
does
not
allow
8
simulcast
layers
"
)
;
auto
pc
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
}
true
)
;
std
:
:
vector
<
SimulcastLayer
>
expected_layers
;
std
:
:
copy_n
(
layers
.
begin
(
)
kMaxSimulcastStreams
std
:
:
back_inserter
(
expected_layers
)
)
;
auto
transceiver
=
AddTransceiver
(
pc
.
get
(
)
layers
)
;
ValidateTransceiverParameters
(
transceiver
expected_layers
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
SimulcastAppearsInSessionDescription
)
{
auto
pc
=
CreatePeerConnectionWrapper
(
)
;
std
:
:
vector
<
std
:
:
string
>
rids
(
{
"
f
"
"
h
"
"
q
"
}
)
;
auto
layers
=
CreateLayers
(
rids
true
)
;
auto
transceiver
=
AddTransceiver
(
pc
.
get
(
)
layers
)
;
auto
offer
=
pc
-
>
CreateOffer
(
)
;
ASSERT_TRUE
(
offer
)
;
auto
contents
=
offer
-
>
description
(
)
-
>
contents
(
)
;
ASSERT_EQ
(
1u
contents
.
size
(
)
)
;
auto
content
=
contents
[
0
]
;
auto
mcd
=
content
.
media_description
(
)
;
ASSERT_TRUE
(
mcd
-
>
HasSimulcast
(
)
)
;
auto
simulcast
=
mcd
-
>
simulcast_description
(
)
;
EXPECT_THAT
(
simulcast
.
receive_layers
(
)
IsEmpty
(
)
)
;
EXPECT_THAT
(
simulcast
.
send_layers
(
)
SizeIs
(
3
)
)
;
std
:
:
vector
<
SimulcastLayer
>
result
=
simulcast
.
send_layers
(
)
.
GetAllLayers
(
)
;
EXPECT_THAT
(
result
ElementsAreArray
(
layers
)
)
;
auto
streams
=
mcd
-
>
streams
(
)
;
ASSERT_EQ
(
1u
streams
.
size
(
)
)
;
auto
stream
=
streams
[
0
]
;
EXPECT_FALSE
(
stream
.
has_ssrcs
(
)
)
;
EXPECT_TRUE
(
stream
.
has_rids
(
)
)
;
std
:
:
vector
<
std
:
:
string
>
result_rids
;
absl
:
:
c_transform
(
stream
.
rids
(
)
std
:
:
back_inserter
(
result_rids
)
[
]
(
const
RidDescription
&
rid
)
{
return
rid
.
rid
;
}
)
;
EXPECT_THAT
(
result_rids
ElementsAreArray
(
rids
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
SimulcastLayersAreSetInSender
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
{
SCOPED_TRACE
(
"
after
create
offer
"
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
auto
simulcast
=
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
auto
mcd_answer
=
answer
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
mcd_answer
-
>
mutable_streams
(
)
.
clear
(
)
;
auto
simulcast_layers
=
simulcast
.
send_layers
(
)
.
GetAllLayers
(
)
;
auto
&
receive_layers
=
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
;
for
(
const
auto
&
layer
:
simulcast_layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
error
)
)
<
<
error
;
{
SCOPED_TRACE
(
"
after
set
remote
"
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
}
TEST_F
(
PeerConnectionSimulcastTests
PausedSimulcastLayersAreDisabledInSender
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
{
true
false
true
}
)
;
auto
server_layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
{
true
false
false
}
)
;
RTC_DCHECK_EQ
(
layers
.
size
(
)
server_layers
.
size
(
)
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
{
SCOPED_TRACE
(
"
after
create
offer
"
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
auto
mcd_answer
=
answer
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
mcd_answer
-
>
mutable_streams
(
)
.
clear
(
)
;
auto
&
receive_layers
=
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
;
for
(
const
SimulcastLayer
&
layer
:
server_layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
error
)
)
<
<
error
;
{
SCOPED_TRACE
(
"
after
set
remote
"
)
;
ValidateTransceiverParameters
(
transceiver
server_layers
)
;
}
}
TEST_F
(
PeerConnectionSimulcastTests
SimulcastRejectedRemovesExtraLayers
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
"
4
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
{
}
)
;
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
EXPECT_THAT
(
parameters
.
encodings
ElementsAre
(
Field
(
"
rid
"
&
RtpEncodingParameters
:
:
rid
Eq
(
"
1
"
)
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
RejectedSimulcastLayersAreDeactivated
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
auto
expected_layers
=
CreateLayers
(
{
"
2
"
"
3
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
{
SCOPED_TRACE
(
"
after
create
offer
"
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
auto
removed_simulcast
=
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
auto
mcd_answer
=
answer
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
auto
simulcast_layers
=
removed_simulcast
.
send_layers
(
)
.
GetAllLayers
(
)
;
simulcast_layers
.
erase
(
simulcast_layers
.
begin
(
)
)
;
auto
&
receive_layers
=
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
;
for
(
const
auto
&
layer
:
simulcast_layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
ASSERT_TRUE
(
mcd_answer
-
>
HasSimulcast
(
)
)
;
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
error
)
)
<
<
error
;
{
SCOPED_TRACE
(
"
after
set
remote
"
)
;
ValidateTransceiverParameters
(
transceiver
expected_layers
)
;
}
}
TEST_F
(
PeerConnectionSimulcastTests
ServerSendsOfferToReceiveSimulcast
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
AddRequestToReceiveSimulcast
(
layers
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
auto
transceiver
=
remote
-
>
pc
(
)
-
>
GetTransceivers
(
)
[
0
]
;
transceiver
-
>
SetDirectionWithError
(
RtpTransceiverDirection
:
:
kSendRecv
)
;
EXPECT_TRUE
(
remote
-
>
CreateAnswerAndSetAsLocal
(
)
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
TransceiverIsNotRecycledWithSimulcast
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
AddRequestToReceiveSimulcast
(
layers
offer
.
get
(
)
)
;
remote
-
>
AddVideoTrack
(
"
fake_track
"
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
auto
transceivers
=
remote
-
>
pc
(
)
-
>
GetTransceivers
(
)
;
ASSERT_EQ
(
2u
transceivers
.
size
(
)
)
;
auto
transceiver
=
transceivers
[
1
]
;
transceiver
-
>
SetDirectionWithError
(
RtpTransceiverDirection
:
:
kSendRecv
)
;
EXPECT_TRUE
(
remote
-
>
CreateAnswerAndSetAsLocal
(
)
)
;
ValidateTransceiverParameters
(
transceiver
layers
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
ParametersAreInvalidatedWhenLayersChange
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
ASSERT_EQ
(
3u
parameters
.
encodings
.
size
(
)
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
{
}
)
;
auto
result
=
transceiver
-
>
sender
(
)
-
>
SetParameters
(
parameters
)
;
EXPECT_EQ
(
RTCErrorType
:
:
INVALID_STATE
result
.
type
(
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
NegotiationDoesNotInvalidateParameterTransactions
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
auto
expected_layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
false
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
expected_layers
)
;
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
expected_layers
)
;
auto
result
=
transceiver
-
>
sender
(
)
-
>
SetParameters
(
parameters
)
;
EXPECT_TRUE
(
result
.
ok
(
)
)
;
ValidateTransceiverParameters
(
transceiver
expected_layers
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
NegotiationDoesNotHaveRidExtension
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
auto
expected_layers
=
CreateLayers
(
{
"
1
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
err
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
err
)
)
<
<
err
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
auto
mcd_answer
=
answer
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
auto
&
receive_layers
=
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
;
for
(
const
SimulcastLayer
&
layer
:
layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
cricket
:
:
RtpHeaderExtensions
extensions
;
for
(
auto
extension
:
mcd_answer
-
>
rtp_header_extensions
(
)
)
{
if
(
extension
.
uri
!
=
RtpExtension
:
:
kRidUri
)
{
extensions
.
push_back
(
extension
)
;
}
}
mcd_answer
-
>
set_rtp_header_extensions
(
extensions
)
;
EXPECT_EQ
(
layers
.
size
(
)
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
.
GetAllLayers
(
)
.
size
(
)
)
;
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
err
)
)
<
<
err
;
ValidateTransceiverParameters
(
transceiver
expected_layers
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
SimulcastAudioRejected
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
"
4
"
}
true
)
;
auto
transceiver
=
AddTransceiver
(
local
.
get
(
)
layers
cricket
:
:
MEDIA_TYPE_AUDIO
)
;
auto
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
EXPECT_EQ
(
1u
parameters
.
encodings
.
size
(
)
)
;
EXPECT_THAT
(
parameters
.
encodings
ElementsAre
(
Field
(
"
rid
"
&
RtpEncodingParameters
:
:
rid
Eq
(
"
"
)
)
)
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
{
}
)
;
parameters
=
transceiver
-
>
sender
(
)
-
>
GetParameters
(
)
;
EXPECT_EQ
(
1u
parameters
.
encodings
.
size
(
)
)
;
EXPECT_THAT
(
parameters
.
encodings
ElementsAre
(
Field
(
"
rid
"
&
RtpEncodingParameters
:
:
rid
Eq
(
"
"
)
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastTests
SimulcastSldModificationRejected
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOffer
(
)
;
std
:
:
string
as_string
;
EXPECT_TRUE
(
offer
-
>
ToString
(
&
as_string
)
)
;
auto
simulcast_marker
=
"
a
=
rid
:
3
send
\
r
\
na
=
simulcast
:
send
1
;
2
;
3
\
r
\
n
"
;
auto
pos
=
as_string
.
find
(
simulcast_marker
)
;
EXPECT_NE
(
pos
std
:
:
string
:
:
npos
)
;
as_string
.
erase
(
pos
strlen
(
simulcast_marker
)
)
;
SdpParseError
parse_error
;
auto
modified_offer
=
CreateSessionDescription
(
SdpType
:
:
kOffer
as_string
&
parse_error
)
;
EXPECT_TRUE
(
modified_offer
)
;
EXPECT_TRUE
(
local
-
>
SetLocalDescription
(
std
:
:
move
(
modified_offer
)
)
)
;
}
#
if
RTC_METRICS_ENABLED
TEST_F
(
PeerConnectionSimulcastMetricsTests
NoSimulcastUsageIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
0
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
layers
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
2
)
)
)
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
2
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastMetricsTests
SpecComplianceIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
3
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
layers
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
1
)
Pair
(
kSimulcastApiVersionSpecCompliant
1
)
)
)
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
1
)
Pair
(
kSimulcastApiVersionSpecCompliant
1
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastMetricsTests
IncomingSimulcastIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
3
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionSpecCompliant
1
)
)
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
AddRequestToReceiveSimulcast
(
layers
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionSpecCompliant
1
)
)
)
;
auto
transceiver
=
remote
-
>
pc
(
)
-
>
GetTransceivers
(
)
[
0
]
;
transceiver
-
>
SetDirectionWithError
(
RtpTransceiverDirection
:
:
kSendRecv
)
;
EXPECT_TRUE
(
remote
-
>
CreateAnswerAndSetAsLocal
(
)
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionSpecCompliant
2
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastMetricsTests
RejectedSimulcastIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionSpecCompliant
1
)
)
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
1
)
)
)
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
1
)
Pair
(
kSimulcastApiVersionSpecCompliant
1
)
)
)
;
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
error
)
)
<
<
error
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
2
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastMetricsTests
LegacySimulcastIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
0
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOffer
(
)
;
const
std
:
:
string
end_line
=
"
\
r
\
n
"
;
std
:
:
string
sdp
;
offer
-
>
ToString
(
&
sdp
)
;
rtc
:
:
StringBuilder
builder
(
sdp
)
;
builder
<
<
"
a
=
ssrc
:
1111
cname
:
slimshady
"
<
<
end_line
;
builder
<
<
"
a
=
ssrc
:
2222
cname
:
slimshady
"
<
<
end_line
;
builder
<
<
"
a
=
ssrc
:
3333
cname
:
slimshady
"
<
<
end_line
;
builder
<
<
"
a
=
ssrc
-
group
:
SIM
1111
2222
3333
"
<
<
end_line
;
SdpParseError
parse_error
;
auto
sd
=
CreateSessionDescription
(
SdpType
:
:
kOffer
builder
.
str
(
)
&
parse_error
)
;
ASSERT_TRUE
(
sd
)
<
<
parse_error
.
line
<
<
parse_error
.
description
;
std
:
:
string
error
;
EXPECT_TRUE
(
local
-
>
SetLocalDescription
(
std
:
:
move
(
sd
)
&
error
)
)
<
<
error
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionLegacy
1
)
)
)
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
1
)
)
)
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
EXPECT_THAT
(
LocalDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
1
)
Pair
(
kSimulcastApiVersionLegacy
1
)
)
)
;
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
error
)
)
<
<
error
;
EXPECT_THAT
(
RemoteDescriptionSamples
(
)
ElementsAre
(
Pair
(
kSimulcastApiVersionNone
2
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastMetricsTests
SimulcastDisabledIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
auto
offer
=
local
-
>
CreateOfferAndSetAsLocal
(
)
;
RemoveSimulcast
(
offer
.
get
(
)
)
;
std
:
:
string
error
;
EXPECT_TRUE
(
remote
-
>
SetRemoteDescription
(
std
:
:
move
(
offer
)
&
error
)
)
<
<
error
;
auto
answer
=
remote
-
>
CreateAnswerAndSetAsLocal
(
)
;
EXPECT_TRUE
(
local
-
>
SetRemoteDescription
(
std
:
:
move
(
answer
)
&
error
)
)
<
<
error
;
EXPECT_EQ
(
1
metrics
:
:
NumSamples
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
Disabled
"
)
)
;
EXPECT_EQ
(
1
metrics
:
:
NumEvents
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
Disabled
"
1
)
)
;
}
TEST_F
(
PeerConnectionSimulcastMetricsTests
SimulcastDisabledIsNotLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
remote
=
CreatePeerConnectionWrapper
(
)
;
auto
layers
=
CreateLayers
(
{
"
1
"
"
2
"
"
3
"
}
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
ExchangeOfferAnswer
(
local
.
get
(
)
remote
.
get
(
)
layers
)
;
EXPECT_EQ
(
0
metrics
:
:
NumSamples
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
Disabled
"
)
)
;
}
const
int
kMaxLayersInMetricsTest
=
8
;
TEST_P
(
PeerConnectionSimulcastMetricsTests
NumberOfSendEncodingsIsLogged
)
{
auto
local
=
CreatePeerConnectionWrapper
(
)
;
auto
num_layers
=
GetParam
(
)
;
auto
layers
=
CreateLayers
(
num_layers
true
)
;
AddTransceiver
(
local
.
get
(
)
layers
)
;
EXPECT_EQ
(
1
metrics
:
:
NumSamples
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
NumberOfSendEncodings
"
)
)
;
EXPECT_EQ
(
1
metrics
:
:
NumEvents
(
"
WebRTC
.
PeerConnection
.
Simulcast
.
NumberOfSendEncodings
"
num_layers
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
NumberOfSendEncodings
PeerConnectionSimulcastMetricsTests
:
:
testing
:
:
Range
(
0
kMaxLayersInMetricsTest
)
)
;
#
endif
class
PeerConnectionSimulcastWithMediaFlowTests
:
public
PeerConnectionSimulcastTests
{
public
:
PeerConnectionSimulcastWithMediaFlowTests
(
)
:
background_thread_
(
std
:
:
make_unique
<
rtc
:
:
Thread
>
(
&
pss_
)
)
{
RTC_CHECK
(
background_thread_
-
>
Start
(
)
)
;
}
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
CreatePc
(
)
{
auto
pc_wrapper
=
rtc
:
:
make_ref_counted
<
PeerConnectionTestWrapper
>
(
"
pc
"
&
pss_
background_thread_
.
get
(
)
background_thread_
.
get
(
)
)
;
pc_wrapper
-
>
CreatePc
(
{
}
webrtc
:
:
CreateOpusAudioEncoderFactory
(
)
webrtc
:
:
CreateOpusAudioDecoderFactory
(
)
)
;
return
pc_wrapper
;
}
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
AddTransceiverWithSimulcastLayers
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote
std
:
:
vector
<
SimulcastLayer
>
init_layers
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
MediaStreamInterface
>
stream
=
local
-
>
GetUserMedia
(
false
cricket
:
:
AudioOptions
(
)
true
{
.
width
=
1280
.
height
=
720
}
)
;
rtc
:
:
scoped_refptr
<
VideoTrackInterface
>
track
=
stream
-
>
GetVideoTracks
(
)
[
0
]
;
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
transceiver_or_error
=
local
-
>
pc
(
)
-
>
AddTransceiver
(
track
CreateTransceiverInit
(
init_layers
)
)
;
EXPECT_TRUE
(
transceiver_or_error
.
ok
(
)
)
;
return
transceiver_or_error
.
value
(
)
;
}
bool
HasSenderVideoCodecCapability
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
absl
:
:
string_view
codec_name
)
{
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
pc_wrapper
-
>
pc_factory
(
)
-
>
GetRtpSenderCapabilities
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
.
codecs
;
return
std
:
:
find_if
(
codecs
.
begin
(
)
codecs
.
end
(
)
[
&
codec_name
]
(
const
RtpCodecCapability
&
codec
)
{
return
absl
:
:
EqualsIgnoreCase
(
codec
.
name
codec_name
)
;
}
)
!
=
codecs
.
end
(
)
;
}
std
:
:
vector
<
RtpCodecCapability
>
GetCapabilitiesAndRestrictToCodec
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
absl
:
:
string_view
codec_name
)
{
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
pc_wrapper
-
>
pc_factory
(
)
-
>
GetRtpSenderCapabilities
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
.
codecs
;
codecs
.
erase
(
std
:
:
remove_if
(
codecs
.
begin
(
)
codecs
.
end
(
)
[
&
codec_name
]
(
const
RtpCodecCapability
&
codec
)
{
return
!
IsReliabilityMechanism
(
codec
)
&
&
!
absl
:
:
EqualsIgnoreCase
(
codec
.
name
codec_name
)
;
}
)
codecs
.
end
(
)
)
;
RTC_DCHECK
(
std
:
:
find_if
(
codecs
.
begin
(
)
codecs
.
end
(
)
[
&
codec_name
]
(
const
RtpCodecCapability
&
codec
)
{
return
absl
:
:
EqualsIgnoreCase
(
codec
.
name
codec_name
)
;
}
)
!
=
codecs
.
end
(
)
)
;
return
codecs
;
}
void
ExchangeIceCandidates
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
)
{
local_pc_wrapper
-
>
SignalOnIceCandidateReady
.
connect
(
remote_pc_wrapper
.
get
(
)
&
PeerConnectionTestWrapper
:
:
AddIceCandidate
)
;
remote_pc_wrapper
-
>
SignalOnIceCandidateReady
.
connect
(
local_pc_wrapper
.
get
(
)
&
PeerConnectionTestWrapper
:
:
AddIceCandidate
)
;
}
void
NegotiateWithSimulcastTweaks
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
std
:
:
vector
<
SimulcastLayer
>
init_layers
)
{
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
offer
=
CreateOffer
(
local_pc_wrapper
)
;
rtc
:
:
scoped_refptr
<
MockSetSessionDescriptionObserver
>
p1
=
SetLocalDescription
(
local_pc_wrapper
offer
.
get
(
)
)
;
SimulcastDescription
simulcast_description
=
RemoveSimulcast
(
offer
.
get
(
)
)
;
rtc
:
:
scoped_refptr
<
MockSetSessionDescriptionObserver
>
p2
=
SetRemoteDescription
(
remote_pc_wrapper
offer
.
get
(
)
)
;
EXPECT_TRUE
(
Await
(
{
p1
p2
}
)
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
answer
=
CreateAnswer
(
remote_pc_wrapper
)
;
p1
=
SetLocalDescription
(
remote_pc_wrapper
answer
.
get
(
)
)
;
cricket
:
:
MediaContentDescription
*
mcd_answer
=
answer
-
>
description
(
)
-
>
contents
(
)
[
0
]
.
media_description
(
)
;
mcd_answer
-
>
mutable_streams
(
)
.
clear
(
)
;
std
:
:
vector
<
SimulcastLayer
>
simulcast_layers
=
simulcast_description
.
send_layers
(
)
.
GetAllLayers
(
)
;
cricket
:
:
SimulcastLayerList
&
receive_layers
=
mcd_answer
-
>
simulcast_description
(
)
.
receive_layers
(
)
;
for
(
const
auto
&
layer
:
simulcast_layers
)
{
receive_layers
.
AddLayer
(
layer
)
;
}
p2
=
SetRemoteDescription
(
local_pc_wrapper
answer
.
get
(
)
)
;
EXPECT_TRUE
(
Await
(
{
p1
p2
}
)
)
;
}
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
GetStats
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
)
{
auto
callback
=
rtc
:
:
make_ref_counted
<
MockRTCStatsCollectorCallback
>
(
)
;
pc_wrapper
-
>
pc
(
)
-
>
GetStats
(
callback
.
get
(
)
)
;
EXPECT_TRUE_WAIT
(
callback
-
>
called
(
)
kDefaultTimeout
.
ms
(
)
)
;
return
callback
-
>
report
(
)
;
}
bool
HasOutboundRtpBytesSent
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
size_t
num_layers
)
{
return
HasOutboundRtpBytesSent
(
pc_wrapper
num_layers
num_layers
)
;
}
bool
HasOutboundRtpBytesSent
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
size_t
num_layers
size_t
num_active_layers
)
{
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
if
(
outbound_rtps
.
size
(
)
!
=
num_layers
)
{
return
false
;
}
size_t
num_sending_layers
=
0
;
for
(
const
auto
*
outbound_rtp
:
outbound_rtps
)
{
if
(
outbound_rtp
-
>
bytes_sent
.
is_defined
(
)
&
&
*
outbound_rtp
-
>
bytes_sent
>
0u
)
{
+
+
num_sending_layers
;
}
}
return
num_sending_layers
=
=
num_active_layers
;
}
bool
HasOutboundRtpWithRidAndScalabilityMode
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
absl
:
:
string_view
rid
absl
:
:
string_view
expected_scalability_mode
uint32_t
frame_height
)
{
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
auto
*
outbound_rtp
=
FindOutboundRtpByRid
(
outbound_rtps
rid
)
;
if
(
!
outbound_rtp
|
|
!
outbound_rtp
-
>
scalability_mode
.
is_defined
(
)
|
|
*
outbound_rtp
-
>
scalability_mode
!
=
expected_scalability_mode
)
{
return
false
;
}
if
(
outbound_rtp
-
>
frame_height
.
is_defined
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Waiting
for
target
resolution
(
"
<
<
frame_height
<
<
"
p
)
.
Currently
at
"
<
<
*
outbound_rtp
-
>
frame_height
<
<
"
p
.
.
.
"
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
Waiting
for
target
resolution
.
No
frames
encoded
yet
.
.
.
"
;
}
if
(
!
outbound_rtp
-
>
frame_height
.
is_defined
(
)
|
|
*
outbound_rtp
-
>
frame_height
!
=
frame_height
)
{
rtc
:
:
Thread
:
:
Current
(
)
-
>
SleepMs
(
1000
)
;
return
false
;
}
return
true
;
}
bool
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
std
:
:
vector
<
RidAndResolution
>
resolutions
)
{
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
for
(
const
RidAndResolution
&
resolution
:
resolutions
)
{
const
RTCOutboundRtpStreamStats
*
outbound_rtp
=
nullptr
;
if
(
!
resolution
.
rid
.
empty
(
)
)
{
outbound_rtp
=
FindOutboundRtpByRid
(
outbound_rtps
resolution
.
rid
)
;
}
else
if
(
outbound_rtps
.
size
(
)
=
=
1u
)
{
outbound_rtp
=
outbound_rtps
[
0
]
;
}
if
(
!
outbound_rtp
|
|
!
outbound_rtp
-
>
frame_width
.
is_defined
(
)
|
|
!
outbound_rtp
-
>
frame_height
.
is_defined
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
rid
=
"
<
<
resolution
.
rid
<
<
"
does
not
have
"
<
<
"
resolution
metrics
"
;
return
false
;
}
if
(
*
outbound_rtp
-
>
frame_width
>
resolution
.
width
|
|
*
outbound_rtp
-
>
frame_height
>
resolution
.
height
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
rid
=
"
<
<
resolution
.
rid
<
<
"
is
"
<
<
*
outbound_rtp
-
>
frame_width
<
<
"
x
"
<
<
*
outbound_rtp
-
>
frame_height
<
<
"
this
is
greater
than
the
"
<
<
"
expected
"
<
<
resolution
.
width
<
<
"
x
"
<
<
resolution
.
height
;
return
false
;
}
}
return
true
;
}
protected
:
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateOffer
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
)
{
auto
observer
=
rtc
:
:
make_ref_counted
<
MockCreateSessionDescriptionObserver
>
(
)
;
pc_wrapper
-
>
pc
(
)
-
>
CreateOffer
(
observer
.
get
(
)
{
}
)
;
EXPECT_EQ_WAIT
(
true
observer
-
>
called
(
)
kDefaultTimeout
.
ms
(
)
)
;
return
observer
-
>
MoveDescription
(
)
;
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateAnswer
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
)
{
auto
observer
=
rtc
:
:
make_ref_counted
<
MockCreateSessionDescriptionObserver
>
(
)
;
pc_wrapper
-
>
pc
(
)
-
>
CreateAnswer
(
observer
.
get
(
)
{
}
)
;
EXPECT_EQ_WAIT
(
true
observer
-
>
called
(
)
kDefaultTimeout
.
ms
(
)
)
;
return
observer
-
>
MoveDescription
(
)
;
}
rtc
:
:
scoped_refptr
<
MockSetSessionDescriptionObserver
>
SetLocalDescription
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
SessionDescriptionInterface
*
sdp
)
{
auto
observer
=
rtc
:
:
make_ref_counted
<
MockSetSessionDescriptionObserver
>
(
)
;
pc_wrapper
-
>
pc
(
)
-
>
SetLocalDescription
(
observer
.
get
(
)
CloneSessionDescription
(
sdp
)
.
release
(
)
)
;
return
observer
;
}
rtc
:
:
scoped_refptr
<
MockSetSessionDescriptionObserver
>
SetRemoteDescription
(
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
pc_wrapper
SessionDescriptionInterface
*
sdp
)
{
auto
observer
=
rtc
:
:
make_ref_counted
<
MockSetSessionDescriptionObserver
>
(
)
;
pc_wrapper
-
>
pc
(
)
-
>
SetRemoteDescription
(
observer
.
get
(
)
CloneSessionDescription
(
sdp
)
.
release
(
)
)
;
return
observer
;
}
bool
Await
(
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MockSetSessionDescriptionObserver
>
>
observers
)
{
for
(
auto
&
observer
:
observers
)
{
EXPECT_EQ_WAIT
(
true
observer
-
>
called
(
)
kDefaultTimeout
.
ms
(
)
)
;
if
(
!
observer
-
>
result
(
)
)
{
return
false
;
}
}
return
true
;
}
rtc
:
:
PhysicalSocketServer
pss_
;
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
background_thread_
;
}
;
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingOneEncodings_VP8_DefaultsToL1T1
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP8
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
1u
)
kDefaultTimeout
.
ms
(
)
)
;
EXPECT_TRUE
(
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
local_pc_wrapper
{
{
"
"
1280
720
}
}
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
1u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
VP8
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T1
"
)
)
;
}
#
if
!
defined
(
ADDRESS_SANITIZER
)
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_VP8_Simulcast
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP8
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
3u
)
kLongTimeoutForRampingUp
.
ms
(
)
)
;
EXPECT_TRUE
(
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
local_pc_wrapper
{
{
"
f
"
320
180
}
{
"
h
"
640
360
}
{
"
q
"
1280
720
}
}
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
3u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
VP8
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
1
]
)
StrCaseEq
(
"
video
/
VP8
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
2
]
)
StrCaseEq
(
"
video
/
VP8
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
1
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
2
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingOneEncoding_VP8_RejectsSVCWhenNotPossibleAndDefaultsToL1T1
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP8
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L3T3_KEY
"
;
EXPECT_FALSE
(
sender
-
>
SetParameters
(
parameters
)
.
ok
(
)
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Eq
(
absl
:
:
nullopt
)
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
1u
)
kDefaultTimeout
.
ms
(
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
1u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
VP8
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T1
"
)
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Eq
(
absl
:
:
nullopt
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingOneEncoding_VP8_FallbackFromSVCResultsInL1T2
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
local_pc_wrapper
-
>
pc_factory
(
)
-
>
GetRtpSenderCapabilities
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
.
codecs
;
EXPECT_THAT
(
codecs
[
0
]
.
name
StrCaseEq
(
"
VP8
"
)
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L3T3_KEY
"
;
EXPECT_TRUE
(
sender
-
>
SetParameters
(
parameters
)
.
ok
(
)
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L3T3_KEY
"
)
)
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T2
"
)
)
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
1u
)
kDefaultTimeout
.
ms
(
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
1u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
VP8
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T2
"
)
)
;
}
#
if
defined
(
WEBRTC_USE_H264
)
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_H264_Simulcast
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
H264
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
3u
)
kLongTimeoutForRampingUp
.
ms
(
)
)
;
EXPECT_TRUE
(
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
local_pc_wrapper
{
{
"
f
"
320
180
}
{
"
h
"
640
360
}
{
"
q
"
1280
720
}
}
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
3u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
H264
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
1
]
)
StrCaseEq
(
"
video
/
H264
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
2
]
)
StrCaseEq
(
"
video
/
H264
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
1
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
2
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
}
#
endif
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_VP9_LegacySVC
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP9
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
1u
)
kDefaultTimeout
.
ms
(
)
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpWithRidAndScalabilityMode
(
local_pc_wrapper
"
f
"
"
L3T3_KEY
"
720
)
(
2
*
kLongTimeoutForRampingUp
)
.
ms
(
)
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
std
:
:
vector
<
RtpEncodingParameters
>
encodings
=
sender
-
>
GetParameters
(
)
.
encodings
;
ASSERT_EQ
(
encodings
.
size
(
)
3u
)
;
EXPECT_FALSE
(
encodings
[
0
]
.
scalability_mode
.
has_value
(
)
)
;
EXPECT_FALSE
(
encodings
[
1
]
.
scalability_mode
.
has_value
(
)
)
;
EXPECT_FALSE
(
encodings
[
2
]
.
scalability_mode
.
has_value
(
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingOneEncoding_VP9_StandardSVC
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP9
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L3T3_KEY
"
;
EXPECT_TRUE
(
sender
-
>
SetParameters
(
parameters
)
.
ok
(
)
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
1u
)
kDefaultTimeout
.
ms
(
)
)
;
EXPECT_TRUE
(
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
local_pc_wrapper
{
{
"
"
1280
720
}
}
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
1u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
VP9
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L3T3_KEY
"
)
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
1u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L3T3_KEY
"
)
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_VP9_StandardSVC
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP9
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L3T3_KEY
"
;
parameters
.
encodings
[
0
]
.
scale_resolution_down_by
=
1
;
parameters
.
encodings
[
1
]
.
active
=
false
;
parameters
.
encodings
[
2
]
.
active
=
false
;
EXPECT_TRUE
(
sender
-
>
SetParameters
(
parameters
)
.
ok
(
)
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
3u
1u
)
kDefaultTimeout
.
ms
(
)
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpWithRidAndScalabilityMode
(
local_pc_wrapper
"
f
"
"
L3T3_KEY
"
720
)
(
2
*
kLongTimeoutForRampingUp
)
.
ms
(
)
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L3T3_KEY
"
)
)
)
;
EXPECT_FALSE
(
parameters
.
encodings
[
1
]
.
scalability_mode
.
has_value
(
)
)
;
EXPECT_FALSE
(
parameters
.
encodings
[
2
]
.
scalability_mode
.
has_value
(
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_VP9_Simulcast
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP9
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
0
]
.
scale_resolution_down_by
=
4
;
parameters
.
encodings
[
1
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
1
]
.
scale_resolution_down_by
=
2
;
parameters
.
encodings
[
2
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
2
]
.
scale_resolution_down_by
=
1
;
sender
-
>
SetParameters
(
parameters
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T3
"
)
)
)
;
EXPECT_THAT
(
parameters
.
encodings
[
1
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T3
"
)
)
)
;
EXPECT_THAT
(
parameters
.
encodings
[
2
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T3
"
)
)
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
3u
)
kLongTimeoutForRampingUp
.
ms
(
)
)
;
EXPECT_TRUE
(
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
local_pc_wrapper
{
{
"
f
"
320
180
}
{
"
h
"
640
360
}
{
"
q
"
1280
720
}
}
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
3u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
VP9
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
1
]
)
StrCaseEq
(
"
video
/
VP9
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
2
]
)
StrCaseEq
(
"
video
/
VP9
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
1
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
2
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_VP9_FromLegacyToSingleActiveWithScalability
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP9
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
parameters
.
encodings
[
0
]
.
active
=
true
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L2T2_KEY
"
;
parameters
.
encodings
[
0
]
.
scale_resolution_down_by
=
2
.
0
;
parameters
.
encodings
[
1
]
.
active
=
false
;
parameters
.
encodings
[
1
]
.
scalability_mode
=
absl
:
:
nullopt
;
parameters
.
encodings
[
2
]
.
active
=
false
;
parameters
.
encodings
[
2
]
.
scalability_mode
=
absl
:
:
nullopt
;
sender
-
>
SetParameters
(
parameters
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
3u
1u
)
kDefaultTimeout
.
ms
(
)
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpWithRidAndScalabilityMode
(
local_pc_wrapper
"
f
"
"
L2T2_KEY
"
720
/
2
)
(
2
*
kLongTimeoutForRampingUp
)
.
ms
(
)
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L2T2_KEY
"
)
)
)
;
EXPECT_FALSE
(
parameters
.
encodings
[
1
]
.
scalability_mode
.
has_value
(
)
)
;
EXPECT_FALSE
(
parameters
.
encodings
[
2
]
.
scalability_mode
.
has_value
(
)
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_VP9_StandardL1T3_AllLayersInactive
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
VP9
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
0
]
.
scale_resolution_down_by
=
1
;
parameters
.
encodings
[
0
]
.
active
=
false
;
parameters
.
encodings
[
1
]
.
active
=
false
;
parameters
.
encodings
[
2
]
.
active
=
false
;
sender
-
>
SetParameters
(
parameters
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
SleepMs
(
1000
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
3u
)
)
;
EXPECT_EQ
(
*
outbound_rtps
[
0
]
-
>
bytes_sent
0u
)
;
EXPECT_EQ
(
*
outbound_rtps
[
1
]
-
>
bytes_sent
0u
)
;
EXPECT_EQ
(
*
outbound_rtps
[
2
]
-
>
bytes_sent
0u
)
;
}
TEST_F
(
PeerConnectionSimulcastWithMediaFlowTests
SendingThreeEncodings_AV1_Simulcast
)
{
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
local_pc_wrapper
=
CreatePc
(
)
;
if
(
!
HasSenderVideoCodecCapability
(
local_pc_wrapper
"
AV1
"
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
\
n
*
*
*
\
nAV1
is
not
available
skipping
test
.
\
n
*
*
*
"
;
return
;
}
rtc
:
:
scoped_refptr
<
PeerConnectionTestWrapper
>
remote_pc_wrapper
=
CreatePc
(
)
;
ExchangeIceCandidates
(
local_pc_wrapper
remote_pc_wrapper
)
;
std
:
:
vector
<
SimulcastLayer
>
layers
=
CreateLayers
(
{
"
f
"
"
h
"
"
q
"
}
true
)
;
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
transceiver
=
AddTransceiverWithSimulcastLayers
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
std
:
:
vector
<
RtpCodecCapability
>
codecs
=
GetCapabilitiesAndRestrictToCodec
(
local_pc_wrapper
"
AV1
"
)
;
transceiver
-
>
SetCodecPreferences
(
codecs
)
;
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
sender
=
transceiver
-
>
sender
(
)
;
RtpParameters
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
parameters
.
encodings
[
0
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
0
]
.
scale_resolution_down_by
=
4
;
parameters
.
encodings
[
1
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
1
]
.
scale_resolution_down_by
=
2
;
parameters
.
encodings
[
2
]
.
scalability_mode
=
"
L1T3
"
;
parameters
.
encodings
[
2
]
.
scale_resolution_down_by
=
1
;
sender
-
>
SetParameters
(
parameters
)
;
NegotiateWithSimulcastTweaks
(
local_pc_wrapper
remote_pc_wrapper
layers
)
;
local_pc_wrapper
-
>
WaitForConnection
(
)
;
remote_pc_wrapper
-
>
WaitForConnection
(
)
;
parameters
=
sender
-
>
GetParameters
(
)
;
ASSERT_EQ
(
parameters
.
encodings
.
size
(
)
3u
)
;
EXPECT_THAT
(
parameters
.
encodings
[
0
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T3
"
)
)
)
;
EXPECT_THAT
(
parameters
.
encodings
[
1
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T3
"
)
)
)
;
EXPECT_THAT
(
parameters
.
encodings
[
2
]
.
scalability_mode
Optional
(
std
:
:
string
(
"
L1T3
"
)
)
)
;
EXPECT_TRUE_WAIT
(
HasOutboundRtpBytesSent
(
local_pc_wrapper
3u
)
(
2
*
kLongTimeoutForRampingUp
)
.
ms
(
)
)
;
EXPECT_TRUE
(
OutboundRtpResolutionsAreLessThanOrEqualToExpectations
(
local_pc_wrapper
{
{
"
f
"
320
180
}
{
"
h
"
640
360
}
{
"
q
"
1280
720
}
}
)
)
;
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
report
=
GetStats
(
local_pc_wrapper
)
;
std
:
:
vector
<
const
RTCOutboundRtpStreamStats
*
>
outbound_rtps
=
report
-
>
GetStatsOfType
<
RTCOutboundRtpStreamStats
>
(
)
;
ASSERT_THAT
(
outbound_rtps
SizeIs
(
3u
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
0
]
)
StrCaseEq
(
"
video
/
AV1
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
1
]
)
StrCaseEq
(
"
video
/
AV1
"
)
)
;
EXPECT_THAT
(
GetCurrentCodecMimeType
(
report
*
outbound_rtps
[
2
]
)
StrCaseEq
(
"
video
/
AV1
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
0
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
1
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
EXPECT_THAT
(
*
outbound_rtps
[
2
]
-
>
scalability_mode
StrEq
(
"
L1T3
"
)
)
;
}
#
endif
}
