#
ifndef
PC_SCTP_UTILS_H_
#
define
PC_SCTP_UTILS_H_
#
include
<
string
>
#
include
"
api
/
data_channel_interface
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
transport
/
data_channel_transport_interface
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
net
/
dcsctp
/
public
/
types
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
namespace
rtc
{
class
CopyOnWriteBuffer
;
}
namespace
webrtc
{
struct
DataChannelInit
;
class
StreamId
{
public
:
StreamId
(
)
;
explicit
StreamId
(
int
id
)
;
explicit
StreamId
(
const
StreamId
&
sid
)
;
bool
HasValue
(
)
const
;
int
stream_id_int
(
)
const
;
void
reset
(
)
;
StreamId
&
operator
=
(
const
StreamId
&
sid
)
;
bool
operator
=
=
(
const
StreamId
&
sid
)
const
;
bool
operator
<
(
const
StreamId
&
sid
)
const
;
bool
operator
!
=
(
const
StreamId
&
sid
)
const
{
return
!
(
operator
=
=
(
sid
)
)
;
}
private
:
RTC_NO_UNIQUE_ADDRESS
webrtc
:
:
SequenceChecker
thread_checker_
;
absl
:
:
optional
<
dcsctp
:
:
StreamID
>
id_
RTC_GUARDED_BY
(
thread_checker_
)
;
}
;
bool
IsOpenMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
payload
)
;
bool
ParseDataChannelOpenMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
payload
std
:
:
string
*
label
DataChannelInit
*
config
)
;
bool
ParseDataChannelOpenAckMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
payload
)
;
bool
WriteDataChannelOpenMessage
(
const
std
:
:
string
&
label
const
std
:
:
string
&
protocol
absl
:
:
optional
<
Priority
>
priority
bool
ordered
absl
:
:
optional
<
int
>
max_retransmits
absl
:
:
optional
<
int
>
max_retransmit_time
rtc
:
:
CopyOnWriteBuffer
*
payload
)
;
bool
WriteDataChannelOpenMessage
(
const
std
:
:
string
&
label
const
DataChannelInit
&
config
rtc
:
:
CopyOnWriteBuffer
*
payload
)
;
void
WriteDataChannelOpenAckMessage
(
rtc
:
:
CopyOnWriteBuffer
*
payload
)
;
}
#
endif
