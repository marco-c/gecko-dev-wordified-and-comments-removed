#
include
"
pc
/
sctp_data_channel
.
h
"
#
include
<
limits
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
api
/
priority
.
h
"
#
include
"
media
/
sctp
/
sctp_transport_internal
.
h
"
#
include
"
pc
/
proxy
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
system
/
unused
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
namespace
{
static
size_t
kMaxQueuedReceivedDataBytes
=
16
*
1024
*
1024
;
static
std
:
:
atomic
<
int
>
g_unique_id
{
0
}
;
int
GenerateUniqueId
(
)
{
return
+
+
g_unique_id
;
}
BEGIN_PROXY_MAP
(
DataChannel
)
PROXY_PRIMARY_THREAD_DESTRUCTOR
(
)
BYPASS_PROXY_METHOD1
(
void
RegisterObserver
DataChannelObserver
*
)
BYPASS_PROXY_METHOD0
(
void
UnregisterObserver
)
BYPASS_PROXY_CONSTMETHOD0
(
std
:
:
string
label
)
BYPASS_PROXY_CONSTMETHOD0
(
bool
reliable
)
BYPASS_PROXY_CONSTMETHOD0
(
bool
ordered
)
BYPASS_PROXY_CONSTMETHOD0
(
uint16_t
maxRetransmitTime
)
BYPASS_PROXY_CONSTMETHOD0
(
uint16_t
maxRetransmits
)
BYPASS_PROXY_CONSTMETHOD0
(
absl
:
:
optional
<
int
>
maxRetransmitsOpt
)
BYPASS_PROXY_CONSTMETHOD0
(
absl
:
:
optional
<
int
>
maxPacketLifeTime
)
BYPASS_PROXY_CONSTMETHOD0
(
std
:
:
string
protocol
)
BYPASS_PROXY_CONSTMETHOD0
(
bool
negotiated
)
PROXY_SECONDARY_CONSTMETHOD0
(
int
id
)
BYPASS_PROXY_CONSTMETHOD0
(
PriorityValue
priority
)
BYPASS_PROXY_CONSTMETHOD0
(
DataState
state
)
BYPASS_PROXY_CONSTMETHOD0
(
RTCError
error
)
PROXY_SECONDARY_CONSTMETHOD0
(
uint32_t
messages_sent
)
PROXY_SECONDARY_CONSTMETHOD0
(
uint64_t
bytes_sent
)
PROXY_SECONDARY_CONSTMETHOD0
(
uint32_t
messages_received
)
PROXY_SECONDARY_CONSTMETHOD0
(
uint64_t
bytes_received
)
PROXY_SECONDARY_CONSTMETHOD0
(
uint64_t
buffered_amount
)
PROXY_SECONDARY_METHOD0
(
void
Close
)
PROXY_SECONDARY_METHOD1
(
bool
Send
const
DataBuffer
&
)
BYPASS_PROXY_METHOD2
(
void
SendAsync
DataBuffer
absl
:
:
AnyInvocable
<
void
(
RTCError
)
&
&
>
)
END_PROXY_MAP
(
DataChannel
)
}
InternalDataChannelInit
:
:
InternalDataChannelInit
(
const
DataChannelInit
&
base
)
:
DataChannelInit
(
base
)
open_handshake_role
(
kOpener
)
{
if
(
base
.
negotiated
)
{
open_handshake_role
=
kNone
;
}
else
{
id
=
-
1
;
}
if
(
maxRetransmits
)
{
if
(
*
maxRetransmits
<
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Accepting
maxRetransmits
<
0
for
backwards
compatibility
"
;
maxRetransmits
=
absl
:
:
nullopt
;
}
else
if
(
*
maxRetransmits
>
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
{
maxRetransmits
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
;
}
}
if
(
maxRetransmitTime
)
{
if
(
*
maxRetransmitTime
<
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Accepting
maxRetransmitTime
<
0
for
backwards
compatibility
"
;
maxRetransmitTime
=
absl
:
:
nullopt
;
}
else
if
(
*
maxRetransmitTime
>
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
{
maxRetransmitTime
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
;
}
}
}
bool
InternalDataChannelInit
:
:
IsValid
(
)
const
{
if
(
id
<
-
1
)
return
false
;
if
(
maxRetransmits
.
has_value
(
)
&
&
maxRetransmits
.
value
(
)
<
0
)
return
false
;
if
(
maxRetransmitTime
.
has_value
(
)
&
&
maxRetransmitTime
.
value
(
)
<
0
)
return
false
;
if
(
maxRetransmits
.
has_value
(
)
&
&
maxRetransmitTime
.
has_value
(
)
)
return
false
;
return
true
;
}
absl
:
:
optional
<
StreamId
>
SctpSidAllocator
:
:
AllocateSid
(
rtc
:
:
SSLRole
role
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
int
potential_sid
=
(
role
=
=
rtc
:
:
SSL_CLIENT
)
?
0
:
1
;
while
(
potential_sid
<
=
static_cast
<
int
>
(
cricket
:
:
kMaxSctpSid
)
)
{
StreamId
sid
(
potential_sid
)
;
if
(
used_sids_
.
insert
(
sid
)
.
second
)
return
sid
;
potential_sid
+
=
2
;
}
RTC_LOG
(
LS_ERROR
)
<
<
"
SCTP
sid
allocation
pool
exhausted
.
"
;
return
absl
:
:
nullopt
;
}
bool
SctpSidAllocator
:
:
ReserveSid
(
StreamId
sid
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
return
used_sids_
.
insert
(
sid
)
.
second
;
}
void
SctpSidAllocator
:
:
ReleaseSid
(
StreamId
sid
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
used_sids_
.
erase
(
sid
)
;
}
class
SctpDataChannel
:
:
ObserverAdapter
:
public
DataChannelObserver
{
public
:
explicit
ObserverAdapter
(
SctpDataChannel
*
channel
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
signaling_safety
)
:
channel_
(
channel
)
signaling_safety_
(
std
:
:
move
(
signaling_safety
)
)
{
}
bool
IsInsideCallback
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
cached_getters_
!
=
nullptr
;
}
DataChannelInterface
:
:
DataState
cached_state
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
IsInsideCallback
(
)
)
;
return
cached_getters_
-
>
state
(
)
;
}
RTCError
cached_error
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
IsInsideCallback
(
)
)
;
return
cached_getters_
-
>
error
(
)
;
}
void
SetDelegate
(
DataChannelObserver
*
delegate
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
delegate_
=
delegate
;
safety_
.
reset
(
PendingTaskSafetyFlag
:
:
CreateDetached
(
)
)
;
}
static
void
DeleteOnSignalingThread
(
std
:
:
unique_ptr
<
ObserverAdapter
>
observer
)
{
auto
*
signaling_thread
=
observer
-
>
signaling_thread
(
)
;
if
(
!
signaling_thread
-
>
IsCurrent
(
)
)
signaling_thread
-
>
PostTask
(
[
observer
=
std
:
:
move
(
observer
)
]
(
)
{
}
)
;
}
private
:
class
CachedGetters
{
public
:
explicit
CachedGetters
(
ObserverAdapter
*
adapter
)
:
adapter_
(
adapter
)
cached_state_
(
adapter_
-
>
channel_
-
>
state
(
)
)
cached_error_
(
adapter_
-
>
channel_
-
>
error
(
)
)
{
RTC_DCHECK_RUN_ON
(
adapter
-
>
network_thread
(
)
)
;
}
~
CachedGetters
(
)
{
if
(
!
was_dropped_
)
{
RTC_DCHECK_RUN_ON
(
adapter_
-
>
signaling_thread
(
)
)
;
RTC_DCHECK_EQ
(
adapter_
-
>
cached_getters_
this
)
;
adapter_
-
>
cached_getters_
=
nullptr
;
}
}
bool
PrepareForCallback
(
)
{
RTC_DCHECK_RUN_ON
(
adapter_
-
>
signaling_thread
(
)
)
;
RTC_DCHECK
(
was_dropped_
)
;
was_dropped_
=
false
;
adapter_
-
>
cached_getters_
=
this
;
return
adapter_
-
>
delegate_
&
&
adapter_
-
>
signaling_safety_
-
>
alive
(
)
;
}
RTCError
error
(
)
{
return
cached_error_
;
}
DataChannelInterface
:
:
DataState
state
(
)
{
return
cached_state_
;
}
private
:
ObserverAdapter
*
const
adapter_
;
bool
was_dropped_
=
true
;
const
DataChannelInterface
:
:
DataState
cached_state_
;
const
RTCError
cached_error_
;
}
;
void
OnStateChange
(
)
override
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
safety_
.
flag
(
)
[
this
cached_state
=
std
:
:
make_unique
<
CachedGetters
>
(
this
)
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
cached_state
-
>
PrepareForCallback
(
)
)
delegate_
-
>
OnStateChange
(
)
;
}
)
)
;
}
void
OnMessage
(
const
DataBuffer
&
buffer
)
override
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
safety_
.
flag
(
)
[
this
buffer
=
buffer
cached_state
=
std
:
:
make_unique
<
CachedGetters
>
(
this
)
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
cached_state
-
>
PrepareForCallback
(
)
)
delegate_
-
>
OnMessage
(
buffer
)
;
}
)
)
;
}
void
OnBufferedAmountChange
(
uint64_t
sent_data_size
)
override
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
safety_
.
flag
(
)
[
this
sent_data_size
cached_state
=
std
:
:
make_unique
<
CachedGetters
>
(
this
)
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
cached_state
-
>
PrepareForCallback
(
)
)
delegate_
-
>
OnBufferedAmountChange
(
sent_data_size
)
;
}
)
)
;
}
bool
IsOkToCallOnTheNetworkThread
(
)
override
{
return
true
;
}
rtc
:
:
Thread
*
signaling_thread
(
)
const
{
return
signaling_thread_
;
}
rtc
:
:
Thread
*
network_thread
(
)
const
{
return
channel_
-
>
network_thread_
;
}
DataChannelObserver
*
delegate_
RTC_GUARDED_BY
(
signaling_thread
(
)
)
=
nullptr
;
SctpDataChannel
*
const
channel_
;
rtc
:
:
Thread
*
const
signaling_thread_
{
channel_
-
>
signaling_thread_
}
;
ScopedTaskSafety
safety_
;
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
signaling_safety_
;
CachedGetters
*
cached_getters_
RTC_GUARDED_BY
(
signaling_thread
(
)
)
=
nullptr
;
}
;
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
SctpDataChannel
:
:
Create
(
rtc
:
:
WeakPtr
<
SctpDataChannelControllerInterface
>
controller
const
std
:
:
string
&
label
bool
connected_to_transport
const
InternalDataChannelInit
&
config
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
Thread
*
network_thread
)
{
RTC_DCHECK
(
config
.
IsValid
(
)
)
;
return
rtc
:
:
make_ref_counted
<
SctpDataChannel
>
(
config
std
:
:
move
(
controller
)
label
connected_to_transport
signaling_thread
network_thread
)
;
}
rtc
:
:
scoped_refptr
<
DataChannelInterface
>
SctpDataChannel
:
:
CreateProxy
(
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
channel
rtc
:
:
scoped_refptr
<
PendingTaskSafetyFlag
>
signaling_safety
)
{
auto
*
signaling_thread
=
channel
-
>
signaling_thread_
;
auto
*
network_thread
=
channel
-
>
network_thread_
;
channel
-
>
observer_adapter_
=
std
:
:
make_unique
<
ObserverAdapter
>
(
channel
.
get
(
)
std
:
:
move
(
signaling_safety
)
)
;
return
DataChannelProxy
:
:
Create
(
signaling_thread
network_thread
std
:
:
move
(
channel
)
)
;
}
SctpDataChannel
:
:
SctpDataChannel
(
const
InternalDataChannelInit
&
config
rtc
:
:
WeakPtr
<
SctpDataChannelControllerInterface
>
controller
const
std
:
:
string
&
label
bool
connected_to_transport
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
Thread
*
network_thread
)
:
signaling_thread_
(
signaling_thread
)
network_thread_
(
network_thread
)
id_n_
(
config
.
id
=
=
-
1
?
absl
:
:
nullopt
:
absl
:
:
make_optional
(
config
.
id
)
)
internal_id_
(
GenerateUniqueId
(
)
)
label_
(
label
)
protocol_
(
config
.
protocol
)
max_retransmit_time_
(
config
.
maxRetransmitTime
)
max_retransmits_
(
config
.
maxRetransmits
)
priority_
(
config
.
priority
)
negotiated_
(
config
.
negotiated
)
ordered_
(
config
.
ordered
)
observer_
(
nullptr
)
controller_
(
std
:
:
move
(
controller
)
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_UNUSED
(
network_thread_
)
;
RTC_DCHECK
(
config
.
IsValid
(
)
)
;
if
(
connected_to_transport
)
network_safety_
-
>
SetAlive
(
)
;
switch
(
config
.
open_handshake_role
)
{
case
InternalDataChannelInit
:
:
kNone
:
handshake_state_
=
kHandshakeReady
;
break
;
case
InternalDataChannelInit
:
:
kOpener
:
handshake_state_
=
kHandshakeShouldSendOpen
;
break
;
case
InternalDataChannelInit
:
:
kAcker
:
handshake_state_
=
kHandshakeShouldSendAck
;
break
;
}
}
SctpDataChannel
:
:
~
SctpDataChannel
(
)
{
if
(
observer_adapter_
)
ObserverAdapter
:
:
DeleteOnSignalingThread
(
std
:
:
move
(
observer_adapter_
)
)
;
}
void
SctpDataChannel
:
:
RegisterObserver
(
DataChannelObserver
*
observer
)
{
const
auto
*
current_thread
=
rtc
:
:
Thread
:
:
Current
(
)
;
if
(
!
observer
-
>
IsOkToCallOnTheNetworkThread
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
DataChannelObserver
-
adapter
needed
"
;
auto
prepare_observer
=
[
&
]
(
)
{
RTC_DCHECK
(
observer_adapter_
)
<
<
"
CreateProxy
hasn
'
t
been
called
"
;
observer_adapter_
-
>
SetDelegate
(
observer
)
;
return
observer_adapter_
.
get
(
)
;
}
;
if
(
signaling_thread_
=
=
current_thread
)
{
observer
=
prepare_observer
(
)
;
}
else
{
observer
=
signaling_thread_
-
>
BlockingCall
(
std
:
:
move
(
prepare_observer
)
)
;
}
}
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
me
(
this
)
;
auto
register_observer
=
[
me
=
std
:
:
move
(
me
)
observer
=
observer
]
{
RTC_DCHECK_RUN_ON
(
me
-
>
network_thread_
)
;
me
-
>
observer_
=
observer
;
me
-
>
DeliverQueuedReceivedData
(
)
;
}
;
if
(
network_thread_
=
=
current_thread
)
{
register_observer
(
)
;
}
else
{
network_thread_
-
>
BlockingCall
(
std
:
:
move
(
register_observer
)
)
;
}
}
void
SctpDataChannel
:
:
UnregisterObserver
(
)
{
const
auto
*
current_thread
=
rtc
:
:
Thread
:
:
Current
(
)
;
RTC_DCHECK
(
current_thread
!
=
network_thread_
|
|
network_thread_
=
=
signaling_thread_
)
;
auto
unregister_observer
=
[
&
]
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
observer_
=
nullptr
;
}
;
if
(
current_thread
=
=
network_thread_
)
{
unregister_observer
(
)
;
}
else
{
network_thread_
-
>
BlockingCall
(
std
:
:
move
(
unregister_observer
)
)
;
}
auto
clear_observer
=
[
&
]
(
)
{
if
(
observer_adapter_
)
observer_adapter_
-
>
SetDelegate
(
nullptr
)
;
}
;
if
(
current_thread
!
=
signaling_thread_
)
{
signaling_thread_
-
>
BlockingCall
(
std
:
:
move
(
clear_observer
)
)
;
}
else
{
clear_observer
(
)
;
}
}
std
:
:
string
SctpDataChannel
:
:
label
(
)
const
{
return
label_
;
}
bool
SctpDataChannel
:
:
reliable
(
)
const
{
return
!
max_retransmits_
&
&
!
max_retransmit_time_
;
}
bool
SctpDataChannel
:
:
ordered
(
)
const
{
return
ordered_
;
}
uint16_t
SctpDataChannel
:
:
maxRetransmitTime
(
)
const
{
return
max_retransmit_time_
?
*
max_retransmit_time_
:
static_cast
<
uint16_t
>
(
-
1
)
;
}
uint16_t
SctpDataChannel
:
:
maxRetransmits
(
)
const
{
return
max_retransmits_
?
*
max_retransmits_
:
static_cast
<
uint16_t
>
(
-
1
)
;
}
absl
:
:
optional
<
int
>
SctpDataChannel
:
:
maxPacketLifeTime
(
)
const
{
return
max_retransmit_time_
;
}
absl
:
:
optional
<
int
>
SctpDataChannel
:
:
maxRetransmitsOpt
(
)
const
{
return
max_retransmits_
;
}
std
:
:
string
SctpDataChannel
:
:
protocol
(
)
const
{
return
protocol_
;
}
bool
SctpDataChannel
:
:
negotiated
(
)
const
{
return
negotiated_
;
}
int
SctpDataChannel
:
:
id
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
id_n_
.
has_value
(
)
?
id_n_
-
>
stream_id_int
(
)
:
-
1
;
}
PriorityValue
SctpDataChannel
:
:
priority
(
)
const
{
return
priority_
.
value_or
(
PriorityValue
(
Priority
:
:
kLow
)
)
;
}
uint64_t
SctpDataChannel
:
:
buffered_amount
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
controller_
!
=
nullptr
&
&
id_n_
.
has_value
(
)
)
{
return
controller_
-
>
buffered_amount
(
*
id_n_
)
;
}
return
0u
;
}
void
SctpDataChannel
:
:
Close
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
state_
=
=
kClosing
|
|
state_
=
=
kClosed
)
return
;
SetState
(
kClosing
)
;
UpdateState
(
)
;
}
SctpDataChannel
:
:
DataState
SctpDataChannel
:
:
state
(
)
const
{
const
auto
*
current_thread
=
rtc
:
:
Thread
:
:
Current
(
)
;
if
(
current_thread
=
=
signaling_thread_
&
&
observer_adapter_
&
&
observer_adapter_
-
>
IsInsideCallback
(
)
)
{
return
observer_adapter_
-
>
cached_state
(
)
;
}
auto
return_state
=
[
&
]
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
state_
;
}
;
return
current_thread
=
=
network_thread_
?
return_state
(
)
:
network_thread_
-
>
BlockingCall
(
std
:
:
move
(
return_state
)
)
;
}
RTCError
SctpDataChannel
:
:
error
(
)
const
{
const
auto
*
current_thread
=
rtc
:
:
Thread
:
:
Current
(
)
;
if
(
current_thread
=
=
signaling_thread_
&
&
observer_adapter_
&
&
observer_adapter_
-
>
IsInsideCallback
(
)
)
{
return
observer_adapter_
-
>
cached_error
(
)
;
}
auto
return_error
=
[
&
]
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
error_
;
}
;
return
current_thread
=
=
network_thread_
?
return_error
(
)
:
network_thread_
-
>
BlockingCall
(
std
:
:
move
(
return_error
)
)
;
}
uint32_t
SctpDataChannel
:
:
messages_sent
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
messages_sent_
;
}
uint64_t
SctpDataChannel
:
:
bytes_sent
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
bytes_sent_
;
}
uint32_t
SctpDataChannel
:
:
messages_received
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
messages_received_
;
}
uint64_t
SctpDataChannel
:
:
bytes_received
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
bytes_received_
;
}
bool
SctpDataChannel
:
:
Send
(
const
DataBuffer
&
buffer
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTCError
err
=
SendImpl
(
buffer
)
;
if
(
err
.
type
(
)
=
=
RTCErrorType
:
:
INVALID_STATE
|
|
err
.
type
(
)
=
=
RTCErrorType
:
:
RESOURCE_EXHAUSTED
)
{
return
false
;
}
return
true
;
}
RTCError
SctpDataChannel
:
:
SendImpl
(
DataBuffer
buffer
)
{
expected_buffer_amount_
+
=
buffer
.
size
(
)
;
if
(
state_
!
=
kOpen
)
{
error_
=
RTCError
(
RTCErrorType
:
:
INVALID_STATE
)
;
return
error_
;
}
return
SendDataMessage
(
buffer
true
)
;
}
void
SctpDataChannel
:
:
SendAsync
(
DataBuffer
buffer
absl
:
:
AnyInvocable
<
void
(
RTCError
)
&
&
>
on_complete
)
{
network_thread_
-
>
PostTask
(
SafeTask
(
network_safety_
[
this
buffer
=
std
:
:
move
(
buffer
)
on_complete
=
std
:
:
move
(
on_complete
)
]
(
)
mutable
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTCError
err
=
SendImpl
(
std
:
:
move
(
buffer
)
)
;
if
(
on_complete
)
std
:
:
move
(
on_complete
)
(
err
)
;
}
)
)
;
}
void
SctpDataChannel
:
:
SetSctpSid_n
(
StreamId
sid
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK
(
!
id_n_
.
has_value
(
)
)
;
RTC_DCHECK_NE
(
handshake_state_
kHandshakeWaitingForAck
)
;
RTC_DCHECK_EQ
(
state_
kConnecting
)
;
id_n_
=
sid
;
}
void
SctpDataChannel
:
:
OnClosingProcedureStartedRemotely
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
state_
!
=
kClosing
&
&
state_
!
=
kClosed
)
{
started_closing_procedure_
=
true
;
SetState
(
kClosing
)
;
}
}
void
SctpDataChannel
:
:
OnClosingProcedureComplete
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK_EQ
(
state_
kClosing
)
;
if
(
controller_
&
&
id_n_
.
has_value
(
)
)
{
RTC_DCHECK_EQ
(
controller_
-
>
buffered_amount
(
*
id_n_
)
0
)
;
}
SetState
(
kClosed
)
;
}
void
SctpDataChannel
:
:
OnTransportChannelCreated
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
network_safety_
-
>
SetAlive
(
)
;
}
void
SctpDataChannel
:
:
OnTransportChannelClosed
(
RTCError
error
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
CloseAbruptlyWithError
(
std
:
:
move
(
error
)
)
;
}
void
SctpDataChannel
:
:
OnBufferedAmountLow
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
MaybeSendOnBufferedAmountChanged
(
)
;
if
(
state_
=
=
DataChannelInterface
:
:
kClosing
&
&
!
started_closing_procedure_
&
&
id_n_
.
has_value
(
)
&
&
buffered_amount
(
)
=
=
0
)
{
started_closing_procedure_
=
true
;
controller_
-
>
RemoveSctpDataStream
(
*
id_n_
)
;
}
}
DataChannelStats
SctpDataChannel
:
:
GetStats
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
DataChannelStats
stats
{
internal_id_
id
(
)
label
(
)
protocol
(
)
state
(
)
messages_sent
(
)
messages_received
(
)
bytes_sent
(
)
bytes_received
(
)
}
;
return
stats
;
}
void
SctpDataChannel
:
:
OnDataReceived
(
DataMessageType
type
const
rtc
:
:
CopyOnWriteBuffer
&
payload
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK
(
id_n_
.
has_value
(
)
)
;
if
(
type
=
=
DataMessageType
:
:
kControl
)
{
if
(
handshake_state_
!
=
kHandshakeWaitingForAck
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
DataChannel
received
unexpected
CONTROL
message
sid
=
"
<
<
id_n_
-
>
stream_id_int
(
)
;
return
;
}
if
(
ParseDataChannelOpenAckMessage
(
payload
)
)
{
handshake_state_
=
kHandshakeReady
;
RTC_LOG
(
LS_INFO
)
<
<
"
DataChannel
received
OPEN_ACK
message
sid
=
"
<
<
id_n_
-
>
stream_id_int
(
)
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
DataChannel
failed
to
parse
OPEN_ACK
message
sid
=
"
<
<
id_n_
-
>
stream_id_int
(
)
;
}
return
;
}
RTC_DCHECK
(
type
=
=
DataMessageType
:
:
kBinary
|
|
type
=
=
DataMessageType
:
:
kText
)
;
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
DataChannel
received
DATA
message
sid
=
"
<
<
id_n_
-
>
stream_id_int
(
)
;
if
(
handshake_state_
=
=
kHandshakeWaitingForAck
)
{
handshake_state_
=
kHandshakeReady
;
}
bool
binary
=
(
type
=
=
DataMessageType
:
:
kBinary
)
;
auto
buffer
=
std
:
:
make_unique
<
DataBuffer
>
(
payload
binary
)
;
if
(
state_
=
=
kOpen
&
&
observer_
)
{
+
+
messages_received_
;
bytes_received_
+
=
buffer
-
>
size
(
)
;
observer_
-
>
OnMessage
(
*
buffer
.
get
(
)
)
;
}
else
{
if
(
queued_received_data_
.
byte_count
(
)
+
payload
.
size
(
)
>
kMaxQueuedReceivedDataBytes
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Queued
received
data
exceeds
the
max
buffer
size
.
"
;
queued_received_data_
.
Clear
(
)
;
CloseAbruptlyWithError
(
RTCError
(
RTCErrorType
:
:
RESOURCE_EXHAUSTED
"
Queued
received
data
exceeds
the
max
buffer
size
.
"
)
)
;
return
;
}
queued_received_data_
.
PushBack
(
std
:
:
move
(
buffer
)
)
;
}
}
void
SctpDataChannel
:
:
OnTransportReady
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK
(
connected_to_transport
(
)
)
;
RTC_DCHECK
(
id_n_
.
has_value
(
)
)
;
UpdateState
(
)
;
}
void
SctpDataChannel
:
:
CloseAbruptlyWithError
(
RTCError
error
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
state_
=
=
kClosed
)
{
return
;
}
network_safety_
-
>
SetNotAlive
(
)
;
SetState
(
kClosing
)
;
error_
=
std
:
:
move
(
error
)
;
SetState
(
kClosed
)
;
}
void
SctpDataChannel
:
:
CloseAbruptlyWithDataChannelFailure
(
const
std
:
:
string
&
message
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTCError
error
(
RTCErrorType
:
:
OPERATION_ERROR_WITH_DATA
message
)
;
error
.
set_error_detail
(
RTCErrorDetailType
:
:
DATA_CHANNEL_FAILURE
)
;
CloseAbruptlyWithError
(
std
:
:
move
(
error
)
)
;
}
void
SctpDataChannel
:
:
UpdateState
(
)
{
switch
(
state_
)
{
case
kConnecting
:
{
if
(
connected_to_transport
(
)
&
&
controller_
)
{
if
(
handshake_state_
=
=
kHandshakeShouldSendOpen
)
{
rtc
:
:
CopyOnWriteBuffer
payload
;
WriteDataChannelOpenMessage
(
label_
protocol_
priority_
ordered_
max_retransmits_
max_retransmit_time_
&
payload
)
;
SendControlMessage
(
payload
)
;
}
else
if
(
handshake_state_
=
=
kHandshakeShouldSendAck
)
{
rtc
:
:
CopyOnWriteBuffer
payload
;
WriteDataChannelOpenAckMessage
(
&
payload
)
;
SendControlMessage
(
payload
)
;
}
if
(
handshake_state_
=
=
kHandshakeReady
|
|
handshake_state_
=
=
kHandshakeWaitingForAck
)
{
SetState
(
kOpen
)
;
DeliverQueuedReceivedData
(
)
;
}
}
else
{
RTC_DCHECK
(
!
id_n_
.
has_value
(
)
)
;
}
break
;
}
case
kOpen
:
{
break
;
}
case
kClosing
:
{
if
(
connected_to_transport
(
)
&
&
controller_
&
&
id_n_
.
has_value
(
)
)
{
if
(
controller_
-
>
buffered_amount
(
*
id_n_
)
=
=
0
)
{
if
(
!
started_closing_procedure_
&
&
id_n_
.
has_value
(
)
)
{
started_closing_procedure_
=
true
;
controller_
-
>
RemoveSctpDataStream
(
*
id_n_
)
;
}
}
}
else
{
SetState
(
kClosed
)
;
}
break
;
}
case
kClosed
:
break
;
}
}
void
SctpDataChannel
:
:
SetState
(
DataState
state
)
{
if
(
state_
=
=
state
)
{
return
;
}
state_
=
state
;
if
(
observer_
)
{
observer_
-
>
OnStateChange
(
)
;
}
if
(
controller_
)
controller_
-
>
OnChannelStateChanged
(
this
state_
)
;
}
void
SctpDataChannel
:
:
DeliverQueuedReceivedData
(
)
{
if
(
!
observer_
|
|
state_
!
=
kOpen
)
{
return
;
}
while
(
!
queued_received_data_
.
Empty
(
)
)
{
std
:
:
unique_ptr
<
DataBuffer
>
buffer
=
queued_received_data_
.
PopFront
(
)
;
+
+
messages_received_
;
bytes_received_
+
=
buffer
-
>
size
(
)
;
observer_
-
>
OnMessage
(
*
buffer
)
;
}
}
void
SctpDataChannel
:
:
MaybeSendOnBufferedAmountChanged
(
)
{
if
(
!
controller_
|
|
!
id_n_
.
has_value
(
)
|
|
!
observer_
)
{
return
;
}
static
constexpr
int64_t
kMinBufferedAmountDiffToTriggerCallback
=
100
*
1024
;
size_t
actual_buffer_amount
=
controller_
-
>
buffered_amount
(
*
id_n_
)
;
if
(
actual_buffer_amount
>
expected_buffer_amount_
)
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
Actual
buffer_amount
larger
than
expected
"
;
return
;
}
if
(
(
actual_buffer_amount
=
=
0
&
&
expected_buffer_amount_
!
=
0
)
|
|
(
expected_buffer_amount_
-
actual_buffer_amount
>
kMinBufferedAmountDiffToTriggerCallback
)
)
{
uint64_t
diff
=
expected_buffer_amount_
-
actual_buffer_amount
;
expected_buffer_amount_
=
actual_buffer_amount
;
observer_
-
>
OnBufferedAmountChange
(
diff
)
;
}
controller_
-
>
SetBufferedAmountLowThreshold
(
*
id_n_
actual_buffer_amount
>
kMinBufferedAmountDiffToTriggerCallback
?
actual_buffer_amount
-
kMinBufferedAmountDiffToTriggerCallback
:
0
)
;
}
RTCError
SctpDataChannel
:
:
SendDataMessage
(
const
DataBuffer
&
buffer
bool
queue_if_blocked
)
{
SendDataParams
send_params
;
if
(
!
controller_
|
|
!
id_n_
.
has_value
(
)
)
{
error_
=
RTCError
(
RTCErrorType
:
:
INVALID_STATE
)
;
return
error_
;
}
send_params
.
ordered
=
ordered_
;
if
(
handshake_state_
!
=
kHandshakeReady
&
&
!
ordered_
)
{
send_params
.
ordered
=
true
;
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
Sending
data
as
ordered
for
unordered
DataChannel
"
"
because
the
OPEN_ACK
message
has
not
been
received
.
"
;
}
send_params
.
max_rtx_count
=
max_retransmits_
;
send_params
.
max_rtx_ms
=
max_retransmit_time_
;
send_params
.
type
=
buffer
.
binary
?
DataMessageType
:
:
kBinary
:
DataMessageType
:
:
kText
;
error_
=
controller_
-
>
SendData
(
*
id_n_
send_params
buffer
.
data
)
;
MaybeSendOnBufferedAmountChanged
(
)
;
if
(
error_
.
ok
(
)
)
{
+
+
messages_sent_
;
bytes_sent_
+
=
buffer
.
size
(
)
;
return
error_
;
}
RTC_LOG
(
LS_ERROR
)
<
<
"
Closing
the
DataChannel
due
to
a
failure
to
send
data
"
"
send_result
=
"
<
<
ToString
(
error_
.
type
(
)
)
<
<
"
:
"
<
<
error_
.
message
(
)
;
CloseAbruptlyWithError
(
RTCError
(
RTCErrorType
:
:
NETWORK_ERROR
"
Failure
to
send
data
"
)
)
;
return
error_
;
}
bool
SctpDataChannel
:
:
SendControlMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
RTC_DCHECK
(
connected_to_transport
(
)
)
;
RTC_DCHECK
(
id_n_
.
has_value
(
)
)
;
RTC_DCHECK
(
controller_
)
;
bool
is_open_message
=
handshake_state_
=
=
kHandshakeShouldSendOpen
;
RTC_DCHECK
(
!
is_open_message
|
|
!
negotiated_
)
;
SendDataParams
send_params
;
send_params
.
ordered
=
ordered_
|
|
is_open_message
;
send_params
.
type
=
DataMessageType
:
:
kControl
;
RTCError
err
=
controller_
-
>
SendData
(
*
id_n_
send_params
buffer
)
;
if
(
err
.
ok
(
)
)
{
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
Sent
CONTROL
message
on
channel
"
<
<
id_n_
-
>
stream_id_int
(
)
;
if
(
handshake_state_
=
=
kHandshakeShouldSendAck
)
{
handshake_state_
=
kHandshakeReady
;
}
else
if
(
handshake_state_
=
=
kHandshakeShouldSendOpen
)
{
handshake_state_
=
kHandshakeWaitingForAck
;
}
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Closing
the
DataChannel
due
to
a
failure
to
send
"
"
the
CONTROL
message
send_result
=
"
<
<
ToString
(
err
.
type
(
)
)
;
err
.
set_message
(
"
Failed
to
send
a
CONTROL
message
"
)
;
CloseAbruptlyWithError
(
err
)
;
}
return
err
.
ok
(
)
;
}
void
SctpDataChannel
:
:
ResetInternalIdAllocatorForTesting
(
int
new_value
)
{
g_unique_id
=
new_value
;
}
}
