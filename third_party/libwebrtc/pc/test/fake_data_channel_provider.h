#
ifndef
PC_TEST_FAKE_DATA_CHANNEL_PROVIDER_H_
#
define
PC_TEST_FAKE_DATA_CHANNEL_PROVIDER_H_
#
include
<
set
>
#
include
"
pc
/
sctp_data_channel
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
class
FakeDataChannelProvider
:
public
webrtc
:
:
SctpDataChannelProviderInterface
{
public
:
FakeDataChannelProvider
(
)
:
send_blocked_
(
false
)
transport_available_
(
false
)
ready_to_send_
(
false
)
transport_error_
(
false
)
{
}
virtual
~
FakeDataChannelProvider
(
)
{
}
bool
SendData
(
const
cricket
:
:
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
cricket
:
:
SendDataResult
*
result
)
override
{
RTC_CHECK
(
ready_to_send_
)
;
RTC_CHECK
(
transport_available_
)
;
if
(
send_blocked_
)
{
*
result
=
cricket
:
:
SDR_BLOCK
;
return
false
;
}
if
(
transport_error_
)
{
*
result
=
cricket
:
:
SDR_ERROR
;
return
false
;
}
last_send_data_params_
=
params
;
return
true
;
}
bool
ConnectDataChannel
(
webrtc
:
:
SctpDataChannel
*
data_channel
)
override
{
RTC_CHECK
(
connected_channels_
.
find
(
data_channel
)
=
=
connected_channels_
.
end
(
)
)
;
if
(
!
transport_available_
)
{
return
false
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
DataChannel
connected
"
<
<
data_channel
;
connected_channels_
.
insert
(
data_channel
)
;
return
true
;
}
void
DisconnectDataChannel
(
webrtc
:
:
SctpDataChannel
*
data_channel
)
override
{
RTC_CHECK
(
connected_channels_
.
find
(
data_channel
)
!
=
connected_channels_
.
end
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
DataChannel
disconnected
"
<
<
data_channel
;
connected_channels_
.
erase
(
data_channel
)
;
}
void
AddSctpDataStream
(
int
sid
)
override
{
RTC_CHECK
(
sid
>
=
0
)
;
if
(
!
transport_available_
)
{
return
;
}
send_ssrcs_
.
insert
(
sid
)
;
recv_ssrcs_
.
insert
(
sid
)
;
}
void
RemoveSctpDataStream
(
int
sid
)
override
{
RTC_CHECK
(
sid
>
=
0
)
;
send_ssrcs_
.
erase
(
sid
)
;
recv_ssrcs_
.
erase
(
sid
)
;
for
(
webrtc
:
:
SctpDataChannel
*
ch
:
std
:
:
set
<
webrtc
:
:
SctpDataChannel
*
>
(
connected_channels_
.
begin
(
)
connected_channels_
.
end
(
)
)
)
{
if
(
connected_channels_
.
count
(
ch
)
)
{
ch
-
>
OnClosingProcedureComplete
(
sid
)
;
}
}
}
bool
ReadyToSendData
(
)
const
override
{
return
ready_to_send_
;
}
void
set_send_blocked
(
bool
blocked
)
{
send_blocked_
=
blocked
;
if
(
!
blocked
)
{
for
(
webrtc
:
:
SctpDataChannel
*
ch
:
std
:
:
set
<
webrtc
:
:
SctpDataChannel
*
>
(
connected_channels_
.
begin
(
)
connected_channels_
.
end
(
)
)
)
{
if
(
connected_channels_
.
count
(
ch
)
)
{
ch
-
>
OnTransportReady
(
true
)
;
}
}
}
}
void
set_transport_available
(
bool
available
)
{
transport_available_
=
available
;
}
void
set_ready_to_send
(
bool
ready
)
{
RTC_CHECK
(
transport_available_
)
;
ready_to_send_
=
ready
;
if
(
ready
)
{
std
:
:
set
<
webrtc
:
:
SctpDataChannel
*
>
:
:
iterator
it
;
for
(
it
=
connected_channels_
.
begin
(
)
;
it
!
=
connected_channels_
.
end
(
)
;
+
+
it
)
{
(
*
it
)
-
>
OnTransportReady
(
true
)
;
}
}
}
void
set_transport_error
(
)
{
transport_error_
=
true
;
}
cricket
:
:
SendDataParams
last_send_data_params
(
)
const
{
return
last_send_data_params_
;
}
bool
IsConnected
(
webrtc
:
:
SctpDataChannel
*
data_channel
)
const
{
return
connected_channels_
.
find
(
data_channel
)
!
=
connected_channels_
.
end
(
)
;
}
bool
IsSendStreamAdded
(
uint32_t
stream
)
const
{
return
send_ssrcs_
.
find
(
stream
)
!
=
send_ssrcs_
.
end
(
)
;
}
bool
IsRecvStreamAdded
(
uint32_t
stream
)
const
{
return
recv_ssrcs_
.
find
(
stream
)
!
=
recv_ssrcs_
.
end
(
)
;
}
private
:
cricket
:
:
SendDataParams
last_send_data_params_
;
bool
send_blocked_
;
bool
transport_available_
;
bool
ready_to_send_
;
bool
transport_error_
;
std
:
:
set
<
webrtc
:
:
SctpDataChannel
*
>
connected_channels_
;
std
:
:
set
<
uint32_t
>
send_ssrcs_
;
std
:
:
set
<
uint32_t
>
recv_ssrcs_
;
}
;
#
endif
