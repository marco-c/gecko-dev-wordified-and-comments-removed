#
ifndef
PC_TEST_FAKE_AUDIO_CAPTURE_MODULE_H_
#
define
PC_TEST_FAKE_AUDIO_CAPTURE_MODULE_H_
#
include
<
memory
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
rtc_base
/
message_handler
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
synchronization
/
sequence_checker
.
h
"
namespace
rtc
{
class
Thread
;
}
class
FakeAudioCaptureModule
:
public
webrtc
:
:
AudioDeviceModule
public
rtc
:
:
MessageHandlerAutoCleanup
{
public
:
typedef
uint16_t
Sample
;
static
const
size_t
kNumberSamples
=
440
;
static
const
size_t
kNumberBytesPerSample
=
sizeof
(
Sample
)
;
static
rtc
:
:
scoped_refptr
<
FakeAudioCaptureModule
>
Create
(
)
;
int
frames_received
(
)
const
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
int32_t
ActiveAudioLayer
(
AudioLayer
*
audio_layer
)
const
override
;
int32_t
RegisterAudioCallback
(
webrtc
:
:
AudioTransport
*
audio_callback
)
override
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
int32_t
Init
(
)
override
;
int32_t
Terminate
(
)
override
;
bool
Initialized
(
)
const
override
;
int16_t
PlayoutDevices
(
)
override
;
int16_t
RecordingDevices
(
)
override
;
int32_t
PlayoutDeviceName
(
uint16_t
index
char
name
[
webrtc
:
:
kAdmMaxDeviceNameSize
]
char
guid
[
webrtc
:
:
kAdmMaxGuidSize
]
)
override
;
int32_t
RecordingDeviceName
(
uint16_t
index
char
name
[
webrtc
:
:
kAdmMaxDeviceNameSize
]
char
guid
[
webrtc
:
:
kAdmMaxGuidSize
]
)
override
;
int32_t
SetPlayoutDevice
(
uint16_t
index
)
override
;
int32_t
SetPlayoutDevice
(
WindowsDeviceType
device
)
override
;
int32_t
SetRecordingDevice
(
uint16_t
index
)
override
;
int32_t
SetRecordingDevice
(
WindowsDeviceType
device
)
override
;
int32_t
PlayoutIsAvailable
(
bool
*
available
)
override
;
int32_t
InitPlayout
(
)
override
;
bool
PlayoutIsInitialized
(
)
const
override
;
int32_t
RecordingIsAvailable
(
bool
*
available
)
override
;
int32_t
InitRecording
(
)
override
;
bool
RecordingIsInitialized
(
)
const
override
;
int32_t
StartPlayout
(
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
int32_t
StopPlayout
(
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
bool
Playing
(
)
const
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
int32_t
StartRecording
(
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
int32_t
StopRecording
(
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
bool
Recording
(
)
const
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
int32_t
InitSpeaker
(
)
override
;
bool
SpeakerIsInitialized
(
)
const
override
;
int32_t
InitMicrophone
(
)
override
;
bool
MicrophoneIsInitialized
(
)
const
override
;
int32_t
SpeakerVolumeIsAvailable
(
bool
*
available
)
override
;
int32_t
SetSpeakerVolume
(
uint32_t
volume
)
override
;
int32_t
SpeakerVolume
(
uint32_t
*
volume
)
const
override
;
int32_t
MaxSpeakerVolume
(
uint32_t
*
max_volume
)
const
override
;
int32_t
MinSpeakerVolume
(
uint32_t
*
min_volume
)
const
override
;
int32_t
MicrophoneVolumeIsAvailable
(
bool
*
available
)
override
;
int32_t
SetMicrophoneVolume
(
uint32_t
volume
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
int32_t
MicrophoneVolume
(
uint32_t
*
volume
)
const
RTC_LOCKS_EXCLUDED
(
mutex_
)
override
;
int32_t
MaxMicrophoneVolume
(
uint32_t
*
max_volume
)
const
override
;
int32_t
MinMicrophoneVolume
(
uint32_t
*
min_volume
)
const
override
;
int32_t
SpeakerMuteIsAvailable
(
bool
*
available
)
override
;
int32_t
SetSpeakerMute
(
bool
enable
)
override
;
int32_t
SpeakerMute
(
bool
*
enabled
)
const
override
;
int32_t
MicrophoneMuteIsAvailable
(
bool
*
available
)
override
;
int32_t
SetMicrophoneMute
(
bool
enable
)
override
;
int32_t
MicrophoneMute
(
bool
*
enabled
)
const
override
;
int32_t
StereoPlayoutIsAvailable
(
bool
*
available
)
const
override
;
int32_t
SetStereoPlayout
(
bool
enable
)
override
;
int32_t
StereoPlayout
(
bool
*
enabled
)
const
override
;
int32_t
StereoRecordingIsAvailable
(
bool
*
available
)
const
override
;
int32_t
SetStereoRecording
(
bool
enable
)
override
;
int32_t
StereoRecording
(
bool
*
enabled
)
const
override
;
int32_t
PlayoutDelay
(
uint16_t
*
delay_ms
)
const
override
;
bool
BuiltInAECIsAvailable
(
)
const
override
{
return
false
;
}
int32_t
EnableBuiltInAEC
(
bool
enable
)
override
{
return
-
1
;
}
bool
BuiltInAGCIsAvailable
(
)
const
override
{
return
false
;
}
int32_t
EnableBuiltInAGC
(
bool
enable
)
override
{
return
-
1
;
}
bool
BuiltInNSIsAvailable
(
)
const
override
{
return
false
;
}
int32_t
EnableBuiltInNS
(
bool
enable
)
override
{
return
-
1
;
}
int32_t
GetPlayoutUnderrunCount
(
)
const
override
{
return
-
1
;
}
#
if
defined
(
WEBRTC_IOS
)
int
GetPlayoutAudioParameters
(
webrtc
:
:
AudioParameters
*
params
)
const
override
{
return
-
1
;
}
int
GetRecordAudioParameters
(
webrtc
:
:
AudioParameters
*
params
)
const
override
{
return
-
1
;
}
#
endif
void
OnMessage
(
rtc
:
:
Message
*
msg
)
override
;
protected
:
FakeAudioCaptureModule
(
)
;
virtual
~
FakeAudioCaptureModule
(
)
;
private
:
bool
Initialize
(
)
;
void
SetSendBuffer
(
int
value
)
;
void
ResetRecBuffer
(
)
;
bool
CheckRecBuffer
(
int
value
)
;
bool
ShouldStartProcessing
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
UpdateProcessing
(
bool
start
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
void
StartProcessP
(
)
;
void
ProcessFrameP
(
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
void
ReceiveFrameP
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
SendFrameP
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
webrtc
:
:
AudioTransport
*
audio_callback_
RTC_GUARDED_BY
(
mutex_
)
;
bool
recording_
RTC_GUARDED_BY
(
mutex_
)
;
bool
playing_
RTC_GUARDED_BY
(
mutex_
)
;
bool
play_is_initialized_
;
bool
rec_is_initialized_
;
uint32_t
current_mic_level_
RTC_GUARDED_BY
(
mutex_
)
;
bool
started_
RTC_GUARDED_BY
(
mutex_
)
;
int64_t
next_frame_time_
RTC_GUARDED_BY
(
process_thread_checker_
)
;
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
process_thread_
;
char
rec_buffer_
[
kNumberSamples
*
kNumberBytesPerSample
]
;
char
send_buffer_
[
kNumberSamples
*
kNumberBytesPerSample
]
;
int
frames_received_
;
mutable
webrtc
:
:
Mutex
mutex_
;
webrtc
:
:
SequenceChecker
process_thread_checker_
;
}
;
#
endif
