#
include
"
pc
/
data_channel_controller
.
h
"
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
peer_connection_interface
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
pc
/
peer_connection_internal
.
h
"
#
include
"
pc
/
sctp_utils
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
DataChannelController
:
:
~
DataChannelController
(
)
{
#
if
RTC_DCHECK_IS_ON
if
(
!
sctp_data_channels_n_
.
empty
(
)
)
{
RTC_DCHECK_EQ
(
sctp_data_channels_n_
.
size
(
)
sctp_data_channels_
.
size
(
)
)
;
}
#
endif
}
bool
DataChannelController
:
:
HasDataChannelsForTest
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
!
sctp_data_channels_
.
empty
(
)
;
}
bool
DataChannelController
:
:
HasUsedDataChannels
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
has_used_data_channels_
;
}
RTCError
DataChannelController
:
:
SendData
(
StreamId
sid
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
)
{
if
(
data_channel_transport
(
)
)
return
DataChannelSendData
(
sid
params
payload
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
SendData
called
before
transport
is
ready
"
;
return
RTCError
(
RTCErrorType
:
:
INVALID_STATE
)
;
}
void
DataChannelController
:
:
AddSctpDataStream
(
StreamId
sid
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
RTC_DCHECK
(
sid
.
HasValue
(
)
)
;
if
(
data_channel_transport
(
)
)
{
data_channel_transport
(
)
-
>
OpenChannel
(
sid
.
stream_id_int
(
)
)
;
}
}
void
DataChannelController
:
:
RemoveSctpDataStream
(
StreamId
sid
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
if
(
data_channel_transport
(
)
)
{
data_channel_transport
(
)
-
>
CloseChannel
(
sid
.
stream_id_int
(
)
)
;
}
}
void
DataChannelController
:
:
OnChannelStateChanged
(
SctpDataChannel
*
channel
DataChannelInterface
:
:
DataState
state
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
state
=
=
DataChannelInterface
:
:
DataState
:
:
kClosed
)
OnSctpDataChannelClosed
(
channel
)
;
pc_
-
>
OnSctpDataChannelStateChanged
(
channel
-
>
internal_id
(
)
state
)
;
}
void
DataChannelController
:
:
OnDataReceived
(
int
channel_id
DataMessageType
type
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
if
(
HandleOpenMessage_n
(
channel_id
type
buffer
)
)
return
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
channel_id
type
buffer
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
auto
it
=
FindChannel
(
StreamId
(
channel_id
)
)
;
if
(
it
!
=
sctp_data_channels_
.
end
(
)
)
(
*
it
)
-
>
OnDataReceived
(
type
buffer
)
;
}
)
)
;
}
void
DataChannelController
:
:
OnChannelClosing
(
int
channel_id
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
channel_id
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
auto
it
=
FindChannel
(
StreamId
(
channel_id
)
)
;
if
(
it
!
=
sctp_data_channels_
.
end
(
)
)
(
*
it
)
-
>
OnClosingProcedureStartedRemotely
(
)
;
}
)
)
;
}
void
DataChannelController
:
:
OnChannelClosed
(
int
channel_id
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
StreamId
sid
(
channel_id
)
;
sid_allocator_
.
ReleaseSid
(
sid
)
;
auto
it
=
absl
:
:
c_find_if
(
sctp_data_channels_n_
[
&
]
(
const
auto
&
c
)
{
return
c
-
>
sid
(
)
=
=
sid
;
}
)
;
if
(
it
!
=
sctp_data_channels_n_
.
end
(
)
)
sctp_data_channels_n_
.
erase
(
it
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
sid
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
auto
it
=
FindChannel
(
sid
)
;
if
(
it
!
=
sctp_data_channels_
.
end
(
)
)
{
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
channel
=
std
:
:
move
(
*
it
)
;
sctp_data_channels_
.
erase
(
it
)
;
channel
-
>
OnClosingProcedureComplete
(
)
;
}
}
)
)
;
}
void
DataChannelController
:
:
OnReadyToSend
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
auto
copy
=
sctp_data_channels_
;
for
(
const
auto
&
channel
:
copy
)
channel
-
>
OnTransportReady
(
)
;
}
)
)
;
}
void
DataChannelController
:
:
OnTransportClosed
(
RTCError
error
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
error
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
OnTransportChannelClosed
(
error
)
;
}
)
)
;
}
void
DataChannelController
:
:
SetupDataChannelTransport_n
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
NotifyDataChannelsOfTransportCreated
(
)
;
}
void
DataChannelController
:
:
TeardownDataChannelTransport_n
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
if
(
data_channel_transport
(
)
)
{
data_channel_transport
(
)
-
>
SetDataSink
(
nullptr
)
;
}
set_data_channel_transport
(
nullptr
)
;
sctp_data_channels_n_
.
clear
(
)
;
}
void
DataChannelController
:
:
OnTransportChanged
(
DataChannelTransportInterface
*
new_data_channel_transport
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
if
(
data_channel_transport
(
)
&
&
data_channel_transport
(
)
!
=
new_data_channel_transport
)
{
data_channel_transport
(
)
-
>
SetDataSink
(
nullptr
)
;
set_data_channel_transport
(
new_data_channel_transport
)
;
if
(
new_data_channel_transport
)
{
new_data_channel_transport
-
>
SetDataSink
(
this
)
;
NotifyDataChannelsOfTransportCreated
(
)
;
}
}
}
std
:
:
vector
<
DataChannelStats
>
DataChannelController
:
:
GetDataChannelStats
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
std
:
:
vector
<
DataChannelStats
>
stats
;
stats
.
reserve
(
sctp_data_channels_
.
size
(
)
)
;
for
(
const
auto
&
channel
:
sctp_data_channels_
)
stats
.
push_back
(
channel
-
>
GetStats
(
)
)
;
return
stats
;
}
bool
DataChannelController
:
:
HandleOpenMessage_n
(
int
channel_id
DataMessageType
type
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
if
(
type
!
=
DataMessageType
:
:
kControl
|
|
!
IsOpenMessage
(
buffer
)
)
return
false
;
std
:
:
string
label
;
InternalDataChannelInit
config
;
config
.
id
=
channel_id
;
if
(
!
ParseDataChannelOpenMessage
(
buffer
&
label
&
config
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
parse
the
OPEN
message
for
sid
"
<
<
channel_id
;
}
else
{
config
.
open_handshake_role
=
InternalDataChannelInit
:
:
kAcker
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
label
=
std
:
:
move
(
label
)
config
=
std
:
:
move
(
config
)
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
OnDataChannelOpenMessage
(
label
config
)
;
}
)
)
;
}
return
true
;
}
void
DataChannelController
:
:
OnDataChannelOpenMessage
(
const
std
:
:
string
&
label
const
InternalDataChannelInit
&
config
)
{
auto
channel_or_error
=
InternalCreateDataChannelWithProxy
(
label
config
)
;
if
(
!
channel_or_error
.
ok
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
create
DataChannel
from
the
OPEN
message
.
"
<
<
ToString
(
channel_or_error
.
error
(
)
.
type
(
)
)
;
return
;
}
pc_
-
>
Observer
(
)
-
>
OnDataChannel
(
channel_or_error
.
MoveValue
(
)
)
;
pc_
-
>
NoteDataAddedEvent
(
)
;
}
RTCError
DataChannelController
:
:
ReserveOrAllocateSid
(
StreamId
&
sid
absl
:
:
optional
<
rtc
:
:
SSLRole
>
fallback_ssl_role
)
{
if
(
sid
.
HasValue
(
)
)
{
return
sid_allocator_
.
ReserveSid
(
sid
)
?
RTCError
:
:
OK
(
)
:
RTCError
(
RTCErrorType
:
:
INVALID_RANGE
"
StreamId
out
of
range
or
reserved
.
"
)
;
}
absl
:
:
optional
<
rtc
:
:
SSLRole
>
role
=
pc_
-
>
GetSctpSslRole_n
(
)
;
if
(
!
role
)
role
=
fallback_ssl_role
;
if
(
role
)
{
sid
=
sid_allocator_
.
AllocateSid
(
*
role
)
;
if
(
!
sid
.
HasValue
(
)
)
return
RTCError
(
RTCErrorType
:
:
RESOURCE_EXHAUSTED
)
;
}
RTC_DCHECK
(
sid
.
HasValue
(
)
|
|
!
role
)
;
return
RTCError
:
:
OK
(
)
;
}
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
DataChannelInterface
>
>
DataChannelController
:
:
InternalCreateDataChannelWithProxy
(
const
std
:
:
string
&
label
const
InternalDataChannelInit
&
config
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
!
pc_
-
>
IsClosed
(
)
)
;
if
(
!
config
.
IsValid
(
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
Invalid
DataChannelInit
"
)
;
}
bool
ready_to_send
=
false
;
InternalDataChannelInit
new_config
=
config
;
StreamId
sid
(
new_config
.
id
)
;
auto
weak_ptr
=
weak_factory_
.
GetWeakPtr
(
)
;
RTC_DCHECK
(
weak_ptr
)
;
auto
ret
=
network_thread
(
)
-
>
BlockingCall
(
[
&
]
(
)
-
>
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
>
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
RTCError
err
=
ReserveOrAllocateSid
(
sid
new_config
.
fallback_ssl_role
)
;
if
(
!
err
.
ok
(
)
)
return
err
;
new_config
.
id
=
sid
.
stream_id_int
(
)
;
ready_to_send
=
data_channel_transport_
&
&
data_channel_transport_
-
>
IsReadyToSend
(
)
;
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
channel
(
SctpDataChannel
:
:
Create
(
std
:
:
move
(
weak_ptr
)
label
data_channel_transport_
!
=
nullptr
new_config
signaling_thread
(
)
network_thread
(
)
)
)
;
RTC_DCHECK
(
channel
)
;
sctp_data_channels_n_
.
push_back
(
channel
)
;
if
(
sid
.
HasValue
(
)
)
AddSctpDataStream
(
sid
)
;
return
channel
;
}
)
;
if
(
!
ret
.
ok
(
)
)
return
ret
.
MoveError
(
)
;
if
(
ready_to_send
)
{
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
channel
=
ret
.
value
(
)
]
{
if
(
channel
-
>
state
(
)
!
=
DataChannelInterface
:
:
DataState
:
:
kClosed
)
channel
-
>
OnTransportReady
(
)
;
}
)
)
;
}
sctp_data_channels_
.
push_back
(
ret
.
value
(
)
)
;
has_used_data_channels_
=
true
;
return
SctpDataChannel
:
:
CreateProxy
(
ret
.
MoveValue
(
)
)
;
}
void
DataChannelController
:
:
AllocateSctpSids
(
rtc
:
:
SSLRole
role
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
std
:
:
vector
<
std
:
:
pair
<
SctpDataChannel
*
StreamId
>
>
channels_to_update
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
>
channels_to_close
;
network_thread
(
)
-
>
BlockingCall
(
[
&
]
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
for
(
auto
it
=
sctp_data_channels_n_
.
begin
(
)
;
it
!
=
sctp_data_channels_n_
.
end
(
)
;
)
{
if
(
!
(
*
it
)
-
>
sid
(
)
.
HasValue
(
)
)
{
StreamId
sid
=
sid_allocator_
.
AllocateSid
(
role
)
;
if
(
sid
.
HasValue
(
)
)
{
AddSctpDataStream
(
sid
)
;
channels_to_update
.
push_back
(
std
:
:
make_pair
(
(
*
it
)
.
get
(
)
sid
)
)
;
}
else
{
channels_to_close
.
push_back
(
std
:
:
move
(
*
it
)
)
;
it
=
sctp_data_channels_n_
.
erase
(
it
)
;
continue
;
}
}
+
+
it
;
}
}
)
;
for
(
const
auto
&
channel
:
channels_to_close
)
{
channel
-
>
CloseAbruptlyWithDataChannelFailure
(
"
Failed
to
allocate
SCTP
SID
"
)
;
RTC_DCHECK
(
absl
:
:
c_find_if
(
sctp_data_channels_
[
&
]
(
const
auto
&
c
)
{
return
c
.
get
(
)
=
=
channel
.
get
(
)
;
}
)
=
=
sctp_data_channels_
.
end
(
)
)
;
}
for
(
auto
&
pair
:
channels_to_update
)
{
auto
it
=
absl
:
:
c_find_if
(
sctp_data_channels_
[
&
]
(
const
auto
&
c
)
{
return
c
.
get
(
)
=
=
pair
.
first
;
}
)
;
RTC_DCHECK
(
it
!
=
sctp_data_channels_
.
end
(
)
)
;
(
*
it
)
-
>
SetSctpSid
(
pair
.
second
)
;
}
}
void
DataChannelController
:
:
OnSctpDataChannelClosed
(
SctpDataChannel
*
channel
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
network_thread
(
)
-
>
BlockingCall
(
[
&
sid
=
channel
-
>
sid
(
)
]
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
if
(
sid
.
HasValue
(
)
)
sid_allocator_
.
ReleaseSid
(
sid
)
;
auto
it
=
absl
:
:
c_find_if
(
sctp_data_channels_n_
[
&
]
(
const
auto
&
c
)
{
return
c
.
get
(
)
=
=
channel
;
}
)
;
if
(
it
!
=
sctp_data_channels_n_
.
end
(
)
)
sctp_data_channels_n_
.
erase
(
it
)
;
}
)
;
for
(
auto
it
=
sctp_data_channels_
.
begin
(
)
;
it
!
=
sctp_data_channels_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
get
(
)
=
=
channel
)
{
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
release
=
std
:
:
move
(
*
it
)
;
sctp_data_channels_
.
erase
(
it
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
release
=
std
:
:
move
(
release
)
]
{
}
)
)
;
return
;
}
}
}
void
DataChannelController
:
:
OnTransportChannelClosed
(
RTCError
error
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
>
temp_sctp_dcs
;
temp_sctp_dcs
.
swap
(
sctp_data_channels_
)
;
for
(
const
auto
&
channel
:
temp_sctp_dcs
)
{
channel
-
>
OnTransportChannelClosed
(
error
)
;
}
}
DataChannelTransportInterface
*
DataChannelController
:
:
data_channel_transport
(
)
const
{
return
data_channel_transport_
;
}
void
DataChannelController
:
:
set_data_channel_transport
(
DataChannelTransportInterface
*
transport
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
data_channel_transport_
=
transport
;
}
RTCError
DataChannelController
:
:
DataChannelSendData
(
StreamId
sid
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
data_channel_transport
(
)
)
;
return
network_thread
(
)
-
>
BlockingCall
(
[
this
sid
params
payload
]
{
return
data_channel_transport
(
)
-
>
SendData
(
sid
.
stream_id_int
(
)
params
payload
)
;
}
)
;
}
void
DataChannelController
:
:
NotifyDataChannelsOfTransportCreated
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
RTC_DCHECK
(
data_channel_transport
(
)
)
;
signaling_thread
(
)
-
>
PostTask
(
SafeTask
(
signaling_safety_
.
flag
(
)
[
this
]
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
auto
copy
=
sctp_data_channels_
;
for
(
const
auto
&
channel
:
copy
)
{
channel
-
>
OnTransportChannelCreated
(
)
;
}
}
)
)
;
}
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
SctpDataChannel
>
>
:
:
iterator
DataChannelController
:
:
FindChannel
(
StreamId
stream_id
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
absl
:
:
c_find_if
(
sctp_data_channels_
[
&
]
(
const
auto
&
c
)
{
return
c
-
>
sid
(
)
=
=
stream_id
;
}
)
;
}
rtc
:
:
Thread
*
DataChannelController
:
:
network_thread
(
)
const
{
return
pc_
-
>
network_thread
(
)
;
}
rtc
:
:
Thread
*
DataChannelController
:
:
signaling_thread
(
)
const
{
return
pc_
-
>
signaling_thread
(
)
;
}
}
