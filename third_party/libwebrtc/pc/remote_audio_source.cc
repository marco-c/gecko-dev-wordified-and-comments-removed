#
include
"
pc
/
remote_audio_source
.
h
"
#
include
<
stddef
.
h
>
#
include
<
memory
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
strings
/
string_format
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
class
RemoteAudioSource
:
:
AudioDataProxy
:
public
AudioSinkInterface
{
public
:
explicit
AudioDataProxy
(
RemoteAudioSource
*
source
)
:
source_
(
source
)
{
RTC_DCHECK
(
source
)
;
}
AudioDataProxy
(
)
=
delete
;
AudioDataProxy
(
const
AudioDataProxy
&
)
=
delete
;
AudioDataProxy
&
operator
=
(
const
AudioDataProxy
&
)
=
delete
;
~
AudioDataProxy
(
)
override
{
source_
-
>
OnAudioChannelGone
(
)
;
}
void
OnData
(
const
AudioSinkInterface
:
:
Data
&
audio
)
override
{
source_
-
>
OnData
(
audio
)
;
}
private
:
const
rtc
:
:
scoped_refptr
<
RemoteAudioSource
>
source_
;
}
;
RemoteAudioSource
:
:
RemoteAudioSource
(
rtc
:
:
Thread
*
worker_thread
)
:
main_thread_
(
rtc
:
:
Thread
:
:
Current
(
)
)
worker_thread_
(
worker_thread
)
state_
(
MediaSourceInterface
:
:
kLive
)
{
RTC_DCHECK
(
main_thread_
)
;
RTC_DCHECK
(
worker_thread_
)
;
}
RemoteAudioSource
:
:
~
RemoteAudioSource
(
)
{
RTC_DCHECK
(
main_thread_
-
>
IsCurrent
(
)
)
;
RTC_DCHECK
(
audio_observers_
.
empty
(
)
)
;
RTC_DCHECK
(
sinks_
.
empty
(
)
)
;
}
void
RemoteAudioSource
:
:
Start
(
cricket
:
:
VoiceMediaChannel
*
media_channel
absl
:
:
optional
<
uint32_t
>
ssrc
)
{
RTC_DCHECK_RUN_ON
(
main_thread_
)
;
RTC_DCHECK
(
media_channel
)
;
worker_thread_
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
[
&
]
{
ssrc
?
media_channel
-
>
SetRawAudioSink
(
*
ssrc
std
:
:
make_unique
<
AudioDataProxy
>
(
this
)
)
:
media_channel
-
>
SetDefaultRawAudioSink
(
std
:
:
make_unique
<
AudioDataProxy
>
(
this
)
)
;
}
)
;
}
void
RemoteAudioSource
:
:
Stop
(
cricket
:
:
VoiceMediaChannel
*
media_channel
absl
:
:
optional
<
uint32_t
>
ssrc
)
{
RTC_DCHECK_RUN_ON
(
main_thread_
)
;
RTC_DCHECK
(
media_channel
)
;
worker_thread_
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
[
&
]
{
ssrc
?
media_channel
-
>
SetRawAudioSink
(
*
ssrc
nullptr
)
:
media_channel
-
>
SetDefaultRawAudioSink
(
nullptr
)
;
}
)
;
}
MediaSourceInterface
:
:
SourceState
RemoteAudioSource
:
:
state
(
)
const
{
RTC_DCHECK
(
main_thread_
-
>
IsCurrent
(
)
)
;
return
state_
;
}
bool
RemoteAudioSource
:
:
remote
(
)
const
{
RTC_DCHECK
(
main_thread_
-
>
IsCurrent
(
)
)
;
return
true
;
}
void
RemoteAudioSource
:
:
SetVolume
(
double
volume
)
{
RTC_DCHECK_GE
(
volume
0
)
;
RTC_DCHECK_LE
(
volume
10
)
;
RTC_LOG
(
LS_INFO
)
<
<
rtc
:
:
StringFormat
(
"
RAS
:
:
%
s
(
{
volume
=
%
.
2f
}
)
"
__func__
volume
)
;
for
(
auto
*
observer
:
audio_observers_
)
{
observer
-
>
OnSetVolume
(
volume
)
;
}
}
void
RemoteAudioSource
:
:
RegisterAudioObserver
(
AudioObserver
*
observer
)
{
RTC_DCHECK
(
observer
!
=
NULL
)
;
RTC_DCHECK
(
!
absl
:
:
c_linear_search
(
audio_observers_
observer
)
)
;
audio_observers_
.
push_back
(
observer
)
;
}
void
RemoteAudioSource
:
:
UnregisterAudioObserver
(
AudioObserver
*
observer
)
{
RTC_DCHECK
(
observer
!
=
NULL
)
;
audio_observers_
.
remove
(
observer
)
;
}
void
RemoteAudioSource
:
:
AddSink
(
AudioTrackSinkInterface
*
sink
)
{
RTC_DCHECK
(
main_thread_
-
>
IsCurrent
(
)
)
;
RTC_DCHECK
(
sink
)
;
if
(
state_
!
=
MediaSourceInterface
:
:
kLive
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Can
'
t
register
sink
as
the
source
isn
'
t
live
.
"
;
return
;
}
MutexLock
lock
(
&
sink_lock_
)
;
RTC_DCHECK
(
!
absl
:
:
c_linear_search
(
sinks_
sink
)
)
;
sinks_
.
push_back
(
sink
)
;
}
void
RemoteAudioSource
:
:
RemoveSink
(
AudioTrackSinkInterface
*
sink
)
{
RTC_DCHECK
(
main_thread_
-
>
IsCurrent
(
)
)
;
RTC_DCHECK
(
sink
)
;
MutexLock
lock
(
&
sink_lock_
)
;
sinks_
.
remove
(
sink
)
;
}
void
RemoteAudioSource
:
:
OnData
(
const
AudioSinkInterface
:
:
Data
&
audio
)
{
MutexLock
lock
(
&
sink_lock_
)
;
for
(
auto
*
sink
:
sinks_
)
{
sink
-
>
OnData
(
audio
.
data
16
audio
.
sample_rate
audio
.
channels
audio
.
samples_per_channel
absl
:
:
nullopt
)
;
}
}
void
RemoteAudioSource
:
:
OnAudioChannelGone
(
)
{
main_thread_
-
>
Post
(
RTC_FROM_HERE
this
0
new
rtc
:
:
ScopedRefMessageData
<
RemoteAudioSource
>
(
this
)
)
;
}
void
RemoteAudioSource
:
:
OnMessage
(
rtc
:
:
Message
*
msg
)
{
RTC_DCHECK
(
main_thread_
-
>
IsCurrent
(
)
)
;
sinks_
.
clear
(
)
;
state_
=
MediaSourceInterface
:
:
kEnded
;
FireOnChanged
(
)
;
delete
msg
-
>
pdata
;
}
}
