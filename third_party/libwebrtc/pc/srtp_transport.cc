#
include
"
pc
/
srtp_transport
.
h
"
#
include
<
string
.
h
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
media
/
base
/
rtp_utils
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_util
.
h
"
#
include
"
pc
/
rtp_transport
.
h
"
#
include
"
pc
/
srtp_session
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
#
include
"
rtc_base
/
zero_memory
.
h
"
namespace
webrtc
{
SrtpTransport
:
:
SrtpTransport
(
bool
rtcp_mux_enabled
const
FieldTrialsView
&
field_trials
)
:
RtpTransport
(
rtcp_mux_enabled
field_trials
)
field_trials_
(
field_trials
)
{
}
bool
SrtpTransport
:
:
SendRtpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
int
flags
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
send
the
packet
because
SRTP
transport
is
inactive
.
"
;
return
false
;
}
rtc
:
:
PacketOptions
updated_options
=
options
;
TRACE_EVENT0
(
"
webrtc
"
"
SRTP
Encode
"
)
;
bool
res
;
uint8_t
*
data
=
packet
-
>
MutableData
(
)
;
int
len
=
rtc
:
:
checked_cast
<
int
>
(
packet
-
>
size
(
)
)
;
#
if
!
defined
(
ENABLE_EXTERNAL_AUTH
)
res
=
ProtectRtp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
)
;
#
else
if
(
!
IsExternalAuthActive
(
)
)
{
res
=
ProtectRtp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
)
;
}
else
{
updated_options
.
packet_time_params
.
rtp_sendtime_extension_id
=
rtp_abs_sendtime_extn_id_
;
res
=
ProtectRtp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
&
updated_options
.
packet_time_params
.
srtp_packet_index
)
;
if
(
res
)
{
uint8_t
*
auth_key
=
nullptr
;
int
key_len
=
0
;
res
=
GetRtpAuthParams
(
&
auth_key
&
key_len
&
updated_options
.
packet_time_params
.
srtp_auth_tag_len
)
;
if
(
res
)
{
updated_options
.
packet_time_params
.
srtp_auth_key
.
resize
(
key_len
)
;
updated_options
.
packet_time_params
.
srtp_auth_key
.
assign
(
auth_key
auth_key
+
key_len
)
;
}
}
}
#
endif
if
(
!
res
)
{
uint16_t
seq_num
=
ParseRtpSequenceNumber
(
*
packet
)
;
uint32_t
ssrc
=
ParseRtpSsrc
(
*
packet
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
protect
RTP
packet
:
size
=
"
<
<
len
<
<
"
seqnum
=
"
<
<
seq_num
<
<
"
SSRC
=
"
<
<
ssrc
;
return
false
;
}
packet
-
>
SetSize
(
len
)
;
return
SendPacket
(
false
packet
updated_options
flags
)
;
}
bool
SrtpTransport
:
:
SendRtcpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
int
flags
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
send
the
packet
because
SRTP
transport
is
inactive
.
"
;
return
false
;
}
TRACE_EVENT0
(
"
webrtc
"
"
SRTP
Encode
"
)
;
uint8_t
*
data
=
packet
-
>
MutableData
(
)
;
int
len
=
rtc
:
:
checked_cast
<
int
>
(
packet
-
>
size
(
)
)
;
if
(
!
ProtectRtcp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
)
)
{
int
type
=
-
1
;
cricket
:
:
GetRtcpType
(
data
len
&
type
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
protect
RTCP
packet
:
size
=
"
<
<
len
<
<
"
type
=
"
<
<
type
;
return
false
;
}
packet
-
>
SetSize
(
len
)
;
return
SendPacket
(
true
packet
options
flags
)
;
}
void
SrtpTransport
:
:
OnRtpPacketReceived
(
const
rtc
:
:
ReceivedPacket
&
packet
)
{
TRACE_EVENT0
(
"
webrtc
"
"
SrtpTransport
:
:
OnRtpPacketReceived
"
)
;
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Inactive
SRTP
transport
received
an
RTP
packet
.
Drop
it
.
"
;
return
;
}
rtc
:
:
CopyOnWriteBuffer
payload
(
packet
.
payload
(
)
)
;
char
*
data
=
payload
.
MutableData
<
char
>
(
)
;
int
len
=
rtc
:
:
checked_cast
<
int
>
(
payload
.
size
(
)
)
;
if
(
!
UnprotectRtp
(
data
len
&
len
)
)
{
const
int
kFailureLogThrottleCount
=
100
;
if
(
decryption_failure_count_
%
kFailureLogThrottleCount
=
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
unprotect
RTP
packet
:
size
=
"
<
<
len
<
<
"
seqnum
=
"
<
<
ParseRtpSequenceNumber
(
payload
)
<
<
"
SSRC
=
"
<
<
ParseRtpSsrc
(
payload
)
<
<
"
previous
failure
count
:
"
<
<
decryption_failure_count_
;
}
+
+
decryption_failure_count_
;
return
;
}
payload
.
SetSize
(
len
)
;
DemuxPacket
(
std
:
:
move
(
payload
)
packet
.
arrival_time
(
)
.
value_or
(
Timestamp
:
:
MinusInfinity
(
)
)
packet
.
ecn
(
)
)
;
}
void
SrtpTransport
:
:
OnRtcpPacketReceived
(
const
rtc
:
:
ReceivedPacket
&
packet
)
{
TRACE_EVENT0
(
"
webrtc
"
"
SrtpTransport
:
:
OnRtcpPacketReceived
"
)
;
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Inactive
SRTP
transport
received
an
RTCP
packet
.
Drop
it
.
"
;
return
;
}
rtc
:
:
CopyOnWriteBuffer
payload
(
packet
.
payload
(
)
)
;
char
*
data
=
payload
.
MutableData
<
char
>
(
)
;
int
len
=
rtc
:
:
checked_cast
<
int
>
(
payload
.
size
(
)
)
;
if
(
!
UnprotectRtcp
(
data
len
&
len
)
)
{
int
type
=
-
1
;
cricket
:
:
GetRtcpType
(
data
len
&
type
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
unprotect
RTCP
packet
:
size
=
"
<
<
len
<
<
"
type
=
"
<
<
type
;
return
;
}
payload
.
SetSize
(
len
)
;
SendRtcpPacketReceived
(
&
payload
packet
.
arrival_time
(
)
?
packet
.
arrival_time
(
)
-
>
us
(
)
:
-
1
)
;
}
void
SrtpTransport
:
:
OnNetworkRouteChanged
(
std
:
:
optional
<
rtc
:
:
NetworkRoute
>
network_route
)
{
if
(
network_route
)
{
int
srtp_overhead
=
0
;
if
(
IsSrtpActive
(
)
)
{
GetSrtpOverhead
(
&
srtp_overhead
)
;
}
network_route
-
>
packet_overhead
+
=
srtp_overhead
;
}
SendNetworkRouteChanged
(
network_route
)
;
}
void
SrtpTransport
:
:
OnWritableState
(
rtc
:
:
PacketTransportInternal
*
packet_transport
)
{
SendWritableState
(
IsWritable
(
false
)
&
&
IsWritable
(
true
)
)
;
}
bool
SrtpTransport
:
:
SetRtpParams
(
int
send_crypto_suite
const
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
&
send_key
const
std
:
:
vector
<
int
>
&
send_extension_ids
int
recv_crypto_suite
const
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
&
recv_key
const
std
:
:
vector
<
int
>
&
recv_extension_ids
)
{
bool
new_sessions
=
false
;
if
(
!
send_session_
)
{
RTC_DCHECK
(
!
recv_session_
)
;
CreateSrtpSessions
(
)
;
new_sessions
=
true
;
}
bool
ret
=
new_sessions
?
send_session_
-
>
SetSend
(
send_crypto_suite
send_key
send_extension_ids
)
:
send_session_
-
>
UpdateSend
(
send_crypto_suite
send_key
send_extension_ids
)
;
if
(
!
ret
)
{
ResetParams
(
)
;
return
false
;
}
ret
=
new_sessions
?
recv_session_
-
>
SetReceive
(
recv_crypto_suite
recv_key
recv_extension_ids
)
:
recv_session_
-
>
UpdateReceive
(
recv_crypto_suite
recv_key
recv_extension_ids
)
;
if
(
!
ret
)
{
ResetParams
(
)
;
return
false
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
SRTP
"
<
<
(
new_sessions
?
"
activated
"
:
"
updated
"
)
<
<
"
with
negotiated
parameters
:
send
crypto_suite
"
<
<
send_crypto_suite
<
<
"
recv
crypto_suite
"
<
<
recv_crypto_suite
;
MaybeUpdateWritableState
(
)
;
return
true
;
}
bool
SrtpTransport
:
:
SetRtcpParams
(
int
send_crypto_suite
const
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
&
send_key
const
std
:
:
vector
<
int
>
&
send_extension_ids
int
recv_crypto_suite
const
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
&
recv_key
const
std
:
:
vector
<
int
>
&
recv_extension_ids
)
{
if
(
send_rtcp_session_
|
|
recv_rtcp_session_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Tried
to
set
SRTCP
Params
when
filter
already
active
"
;
return
false
;
}
send_rtcp_session_
.
reset
(
new
cricket
:
:
SrtpSession
(
field_trials_
)
)
;
if
(
!
send_rtcp_session_
-
>
SetSend
(
send_crypto_suite
send_key
send_extension_ids
)
)
{
return
false
;
}
recv_rtcp_session_
.
reset
(
new
cricket
:
:
SrtpSession
(
field_trials_
)
)
;
if
(
!
recv_rtcp_session_
-
>
SetReceive
(
recv_crypto_suite
recv_key
recv_extension_ids
)
)
{
return
false
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
SRTCP
activated
with
negotiated
parameters
:
"
"
send
crypto_suite
"
<
<
send_crypto_suite
<
<
"
recv
crypto_suite
"
<
<
recv_crypto_suite
;
MaybeUpdateWritableState
(
)
;
return
true
;
}
bool
SrtpTransport
:
:
IsSrtpActive
(
)
const
{
return
send_session_
&
&
recv_session_
;
}
bool
SrtpTransport
:
:
IsWritable
(
bool
rtcp
)
const
{
return
IsSrtpActive
(
)
&
&
RtpTransport
:
:
IsWritable
(
rtcp
)
;
}
void
SrtpTransport
:
:
ResetParams
(
)
{
send_session_
=
nullptr
;
recv_session_
=
nullptr
;
send_rtcp_session_
=
nullptr
;
recv_rtcp_session_
=
nullptr
;
MaybeUpdateWritableState
(
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
The
params
in
SRTP
transport
are
reset
.
"
;
}
void
SrtpTransport
:
:
CreateSrtpSessions
(
)
{
send_session_
.
reset
(
new
cricket
:
:
SrtpSession
(
field_trials_
)
)
;
recv_session_
.
reset
(
new
cricket
:
:
SrtpSession
(
field_trials_
)
)
;
if
(
external_auth_enabled_
)
{
send_session_
-
>
EnableExternalAuth
(
)
;
}
}
bool
SrtpTransport
:
:
ProtectRtp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
ProtectRtp
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
return
send_session_
-
>
ProtectRtp
(
p
in_len
max_len
out_len
)
;
}
bool
SrtpTransport
:
:
ProtectRtp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
int64_t
*
index
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
ProtectRtp
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
return
send_session_
-
>
ProtectRtp
(
p
in_len
max_len
out_len
index
)
;
}
bool
SrtpTransport
:
:
ProtectRtcp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
ProtectRtcp
:
SRTP
not
active
"
;
return
false
;
}
if
(
send_rtcp_session_
)
{
return
send_rtcp_session_
-
>
ProtectRtcp
(
p
in_len
max_len
out_len
)
;
}
else
{
RTC_CHECK
(
send_session_
)
;
return
send_session_
-
>
ProtectRtcp
(
p
in_len
max_len
out_len
)
;
}
}
bool
SrtpTransport
:
:
UnprotectRtp
(
void
*
p
int
in_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
UnprotectRtp
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
recv_session_
)
;
return
recv_session_
-
>
UnprotectRtp
(
p
in_len
out_len
)
;
}
bool
SrtpTransport
:
:
UnprotectRtcp
(
void
*
p
int
in_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
UnprotectRtcp
:
SRTP
not
active
"
;
return
false
;
}
if
(
recv_rtcp_session_
)
{
return
recv_rtcp_session_
-
>
UnprotectRtcp
(
p
in_len
out_len
)
;
}
else
{
RTC_CHECK
(
recv_session_
)
;
return
recv_session_
-
>
UnprotectRtcp
(
p
in_len
out_len
)
;
}
}
bool
SrtpTransport
:
:
GetRtpAuthParams
(
uint8_t
*
*
key
int
*
key_len
int
*
tag_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
GetRtpAuthParams
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
return
send_session_
-
>
GetRtpAuthParams
(
key
key_len
tag_len
)
;
}
bool
SrtpTransport
:
:
GetSrtpOverhead
(
int
*
srtp_overhead
)
const
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
GetSrtpOverhead
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
*
srtp_overhead
=
send_session_
-
>
GetSrtpOverhead
(
)
;
return
true
;
}
void
SrtpTransport
:
:
EnableExternalAuth
(
)
{
RTC_DCHECK
(
!
IsSrtpActive
(
)
)
;
external_auth_enabled_
=
true
;
}
bool
SrtpTransport
:
:
IsExternalAuthEnabled
(
)
const
{
return
external_auth_enabled_
;
}
bool
SrtpTransport
:
:
IsExternalAuthActive
(
)
const
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
check
IsExternalAuthActive
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
return
send_session_
-
>
IsExternalAuthActive
(
)
;
}
void
SrtpTransport
:
:
MaybeUpdateWritableState
(
)
{
bool
writable
=
IsWritable
(
true
)
&
&
IsWritable
(
false
)
;
if
(
writable_
!
=
writable
)
{
writable_
=
writable
;
SendWritableState
(
writable_
)
;
}
}
bool
SrtpTransport
:
:
UnregisterRtpDemuxerSink
(
RtpPacketSinkInterface
*
sink
)
{
if
(
recv_session_
&
&
field_trials_
.
IsEnabled
(
"
WebRTC
-
SrtpRemoveReceiveStream
"
)
)
{
for
(
const
auto
ssrc
:
GetSsrcsForSink
(
sink
)
)
{
if
(
!
recv_session_
-
>
RemoveSsrcFromSession
(
ssrc
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Could
not
remove
SSRC
"
<
<
ssrc
<
<
"
from
SRTP
session
.
"
;
}
}
}
return
RtpTransport
:
:
UnregisterRtpDemuxerSink
(
sink
)
;
}
}
