#
ifndef
PC_CHANNEL_MANAGER_H_
#
define
PC_CHANNEL_MANAGER_H_
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
audio_options
.
h
"
#
include
"
api
/
crypto
/
crypto_options
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
api
/
video
/
video_bitrate_allocator_factory
.
h
"
#
include
"
call
/
call
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
media
/
base
/
media_config
.
h
"
#
include
"
media
/
base
/
media_engine
.
h
"
#
include
"
pc
/
channel
.
h
"
#
include
"
pc
/
rtp_transport_internal
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
rtc_base
/
system
/
file_wrapper
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
unique_id_generator
.
h
"
namespace
cricket
{
class
ChannelManager
final
{
public
:
static
std
:
:
unique_ptr
<
ChannelManager
>
Create
(
std
:
:
unique_ptr
<
MediaEngineInterface
>
media_engine
bool
enable_rtx
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
network_thread
)
;
ChannelManager
(
)
=
delete
;
~
ChannelManager
(
)
;
rtc
:
:
Thread
*
worker_thread
(
)
const
{
return
worker_thread_
;
}
rtc
:
:
Thread
*
network_thread
(
)
const
{
return
network_thread_
;
}
MediaEngineInterface
*
media_engine
(
)
{
return
media_engine_
.
get
(
)
;
}
void
GetSupportedAudioSendCodecs
(
std
:
:
vector
<
AudioCodec
>
*
codecs
)
const
;
void
GetSupportedAudioReceiveCodecs
(
std
:
:
vector
<
AudioCodec
>
*
codecs
)
const
;
void
GetSupportedVideoSendCodecs
(
std
:
:
vector
<
VideoCodec
>
*
codecs
)
const
;
void
GetSupportedVideoReceiveCodecs
(
std
:
:
vector
<
VideoCodec
>
*
codecs
)
const
;
RtpHeaderExtensions
GetDefaultEnabledAudioRtpHeaderExtensions
(
)
const
;
std
:
:
vector
<
webrtc
:
:
RtpHeaderExtensionCapability
>
GetSupportedAudioRtpHeaderExtensions
(
)
const
;
RtpHeaderExtensions
GetDefaultEnabledVideoRtpHeaderExtensions
(
)
const
;
std
:
:
vector
<
webrtc
:
:
RtpHeaderExtensionCapability
>
GetSupportedVideoRtpHeaderExtensions
(
)
const
;
VoiceChannel
*
CreateVoiceChannel
(
webrtc
:
:
Call
*
call
const
MediaConfig
&
media_config
webrtc
:
:
RtpTransportInternal
*
rtp_transport
rtc
:
:
Thread
*
signaling_thread
const
std
:
:
string
&
content_name
bool
srtp_required
const
webrtc
:
:
CryptoOptions
&
crypto_options
rtc
:
:
UniqueRandomIdGenerator
*
ssrc_generator
const
AudioOptions
&
options
)
;
void
DestroyVoiceChannel
(
VoiceChannel
*
voice_channel
)
;
VideoChannel
*
CreateVideoChannel
(
webrtc
:
:
Call
*
call
const
MediaConfig
&
media_config
webrtc
:
:
RtpTransportInternal
*
rtp_transport
rtc
:
:
Thread
*
signaling_thread
const
std
:
:
string
&
content_name
bool
srtp_required
const
webrtc
:
:
CryptoOptions
&
crypto_options
rtc
:
:
UniqueRandomIdGenerator
*
ssrc_generator
const
VideoOptions
&
options
webrtc
:
:
VideoBitrateAllocatorFactory
*
video_bitrate_allocator_factory
)
;
void
DestroyVideoChannel
(
VideoChannel
*
video_channel
)
;
bool
StartAecDump
(
webrtc
:
:
FileWrapper
file
int64_t
max_size_bytes
)
;
void
StopAecDump
(
)
;
private
:
ChannelManager
(
std
:
:
unique_ptr
<
MediaEngineInterface
>
media_engine
bool
enable_rtx
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
network_thread
)
;
const
std
:
:
unique_ptr
<
MediaEngineInterface
>
media_engine_
;
rtc
:
:
Thread
*
const
worker_thread_
;
rtc
:
:
Thread
*
const
network_thread_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
VoiceChannel
>
>
voice_channels_
RTC_GUARDED_BY
(
worker_thread_
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
VideoChannel
>
>
video_channels_
RTC_GUARDED_BY
(
worker_thread_
)
;
const
bool
enable_rtx_
;
}
;
}
#
endif
