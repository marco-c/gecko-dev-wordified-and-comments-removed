#
include
"
pc
/
jitter_buffer_delay
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
{
constexpr
int
kDefaultDelay
=
0
;
constexpr
int
kMaximumDelayMs
=
10000
;
}
namespace
webrtc
{
JitterBufferDelay
:
:
JitterBufferDelay
(
rtc
:
:
Thread
*
worker_thread
)
:
signaling_thread_
(
rtc
:
:
Thread
:
:
Current
(
)
)
worker_thread_
(
worker_thread
)
{
RTC_DCHECK
(
worker_thread_
)
;
}
void
JitterBufferDelay
:
:
OnStart
(
cricket
:
:
Delayable
*
media_channel
uint32_t
ssrc
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
media_channel_
=
media_channel
;
ssrc_
=
ssrc
;
if
(
cached_delay_seconds_
)
{
Set
(
cached_delay_seconds_
.
value
(
)
)
;
}
}
void
JitterBufferDelay
:
:
OnStop
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
media_channel_
=
nullptr
;
ssrc_
=
absl
:
:
nullopt
;
}
void
JitterBufferDelay
:
:
Set
(
absl
:
:
optional
<
double
>
delay_seconds
)
{
RTC_DCHECK_RUN_ON
(
worker_thread_
)
;
int
delay_ms
=
rtc
:
:
saturated_cast
<
int
>
(
delay_seconds
.
value_or
(
kDefaultDelay
)
*
1000
)
;
delay_ms
=
rtc
:
:
SafeClamp
(
delay_ms
0
kMaximumDelayMs
)
;
cached_delay_seconds_
=
delay_seconds
;
if
(
media_channel_
&
&
ssrc_
)
{
media_channel_
-
>
SetBaseMinimumPlayoutDelayMs
(
ssrc_
.
value
(
)
delay_ms
)
;
}
}
}
