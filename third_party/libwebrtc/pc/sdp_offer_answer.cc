#
include
"
pc
/
sdp_offer_answer
.
h
"
#
include
"
api
/
media_stream_proxy
.
h
"
#
include
"
api
/
uma_metrics
.
h
"
#
include
"
pc
/
media_stream
.
h
"
#
include
"
pc
/
peer_connection
.
h
"
#
include
"
pc
/
rtp_media_utils
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
using
cricket
:
:
ContentInfo
;
using
cricket
:
:
ContentInfos
;
using
cricket
:
:
MediaContentDescription
;
using
cricket
:
:
MediaProtocolType
;
using
cricket
:
:
RidDescription
;
using
cricket
:
:
RidDirection
;
using
cricket
:
:
SessionDescription
;
using
cricket
:
:
SimulcastDescription
;
using
cricket
:
:
SimulcastLayer
;
using
cricket
:
:
SimulcastLayerList
;
using
cricket
:
:
StreamParams
;
using
cricket
:
:
TransportInfo
;
using
cricket
:
:
LOCAL_PORT_TYPE
;
using
cricket
:
:
PRFLX_PORT_TYPE
;
using
cricket
:
:
RELAY_PORT_TYPE
;
using
cricket
:
:
STUN_PORT_TYPE
;
namespace
webrtc
{
namespace
{
const
char
kInvalidSdp
[
]
=
"
Invalid
session
description
.
"
;
const
char
kInvalidCandidates
[
]
=
"
Description
contains
invalid
candidates
.
"
;
const
char
kBundleWithoutRtcpMux
[
]
=
"
rtcp
-
mux
must
be
enabled
when
BUNDLE
"
"
is
enabled
.
"
;
const
char
kMlineMismatchInAnswer
[
]
=
"
The
order
of
m
-
lines
in
answer
doesn
'
t
match
order
in
offer
.
Rejecting
"
"
answer
.
"
;
const
char
kMlineMismatchInSubsequentOffer
[
]
=
"
The
order
of
m
-
lines
in
subsequent
offer
doesn
'
t
match
order
from
"
"
previous
offer
/
answer
.
"
;
const
char
kSdpWithoutIceUfragPwd
[
]
=
"
Called
with
SDP
without
ice
-
ufrag
and
ice
-
pwd
.
"
;
const
char
kSdpWithoutDtlsFingerprint
[
]
=
"
Called
with
SDP
without
DTLS
fingerprint
.
"
;
const
char
kSdpWithoutSdesCrypto
[
]
=
"
Called
with
SDP
without
SDES
crypto
.
"
;
const
char
kSimulcastVersionApplyLocalDescription
[
]
=
"
WebRTC
.
PeerConnection
.
Simulcast
.
ApplyLocalDescription
"
;
const
char
kSimulcastVersionApplyRemoteDescription
[
]
=
"
WebRTC
.
PeerConnection
.
Simulcast
.
ApplyRemoteDescription
"
;
const
char
kSimulcastDisabled
[
]
=
"
WebRTC
.
PeerConnection
.
Simulcast
.
Disabled
"
;
void
NoteAddIceCandidateResult
(
int
result
)
{
RTC_HISTOGRAM_ENUMERATION
(
"
WebRTC
.
PeerConnection
.
AddIceCandidate
"
result
kAddIceCandidateMax
)
;
}
void
NoteKeyProtocolAndMedia
(
KeyExchangeProtocolType
protocol_type
cricket
:
:
MediaType
media_type
)
{
static
constexpr
struct
{
KeyExchangeProtocolType
protocol_type
;
cricket
:
:
MediaType
media_type
;
KeyExchangeProtocolMedia
protocol_media
;
}
kEnumCounterKeyProtocolMediaMap
[
]
=
{
{
kEnumCounterKeyProtocolDtls
cricket
:
:
MEDIA_TYPE_AUDIO
kEnumCounterKeyProtocolMediaTypeDtlsAudio
}
{
kEnumCounterKeyProtocolDtls
cricket
:
:
MEDIA_TYPE_VIDEO
kEnumCounterKeyProtocolMediaTypeDtlsVideo
}
{
kEnumCounterKeyProtocolDtls
cricket
:
:
MEDIA_TYPE_DATA
kEnumCounterKeyProtocolMediaTypeDtlsData
}
{
kEnumCounterKeyProtocolSdes
cricket
:
:
MEDIA_TYPE_AUDIO
kEnumCounterKeyProtocolMediaTypeSdesAudio
}
{
kEnumCounterKeyProtocolSdes
cricket
:
:
MEDIA_TYPE_VIDEO
kEnumCounterKeyProtocolMediaTypeSdesVideo
}
{
kEnumCounterKeyProtocolSdes
cricket
:
:
MEDIA_TYPE_DATA
kEnumCounterKeyProtocolMediaTypeSdesData
}
}
;
RTC_HISTOGRAM_ENUMERATION
(
"
WebRTC
.
PeerConnection
.
KeyProtocol
"
protocol_type
kEnumCounterKeyProtocolMax
)
;
for
(
const
auto
&
i
:
kEnumCounterKeyProtocolMediaMap
)
{
if
(
i
.
protocol_type
=
=
protocol_type
&
&
i
.
media_type
=
=
media_type
)
{
RTC_HISTOGRAM_ENUMERATION
(
"
WebRTC
.
PeerConnection
.
KeyProtocolByMedia
"
i
.
protocol_media
kEnumCounterKeyProtocolMediaTypeMax
)
;
}
}
}
bool
CheckForRemoteIceRestart
(
const
SessionDescriptionInterface
*
old_desc
const
SessionDescriptionInterface
*
new_desc
const
std
:
:
string
&
content_name
)
{
if
(
!
old_desc
)
{
return
false
;
}
const
SessionDescription
*
new_sd
=
new_desc
-
>
description
(
)
;
const
SessionDescription
*
old_sd
=
old_desc
-
>
description
(
)
;
const
ContentInfo
*
cinfo
=
new_sd
-
>
GetContentByName
(
content_name
)
;
if
(
!
cinfo
|
|
cinfo
-
>
rejected
)
{
return
false
;
}
const
cricket
:
:
TransportDescription
*
new_transport_desc
=
new_sd
-
>
GetTransportDescriptionByName
(
content_name
)
;
const
cricket
:
:
TransportDescription
*
old_transport_desc
=
old_sd
-
>
GetTransportDescriptionByName
(
content_name
)
;
if
(
!
new_transport_desc
|
|
!
old_transport_desc
)
{
return
false
;
}
if
(
cricket
:
:
IceCredentialsChanged
(
old_transport_desc
-
>
ice_ufrag
old_transport_desc
-
>
ice_pwd
new_transport_desc
-
>
ice_ufrag
new_transport_desc
-
>
ice_pwd
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Remote
peer
requests
ICE
restart
for
"
<
<
content_name
<
<
"
.
"
;
return
true
;
}
return
false
;
}
std
:
:
string
GetSetDescriptionErrorMessage
(
cricket
:
:
ContentSource
source
SdpType
type
const
RTCError
&
error
)
{
rtc
:
:
StringBuilder
oss
;
oss
<
<
"
Failed
to
set
"
<
<
(
source
=
=
cricket
:
:
CS_LOCAL
?
"
local
"
:
"
remote
"
)
<
<
"
"
<
<
SdpTypeToString
(
type
)
<
<
"
sdp
:
"
<
<
error
.
message
(
)
;
return
oss
.
Release
(
)
;
}
std
:
:
string
GetStreamIdsString
(
rtc
:
:
ArrayView
<
const
std
:
:
string
>
stream_ids
)
{
std
:
:
string
output
=
"
streams
=
[
"
;
const
char
*
separator
=
"
"
;
for
(
const
auto
&
stream_id
:
stream_ids
)
{
output
.
append
(
separator
)
.
append
(
stream_id
)
;
separator
=
"
"
;
}
output
.
append
(
"
]
"
)
;
return
output
;
}
void
ReportSimulcastApiVersion
(
const
char
*
name
const
SessionDescription
&
session
)
{
bool
has_legacy
=
false
;
bool
has_spec_compliant
=
false
;
for
(
const
ContentInfo
&
content
:
session
.
contents
(
)
)
{
if
(
!
content
.
media_description
(
)
)
{
continue
;
}
has_spec_compliant
|
=
content
.
media_description
(
)
-
>
HasSimulcast
(
)
;
for
(
const
StreamParams
&
sp
:
content
.
media_description
(
)
-
>
streams
(
)
)
{
has_legacy
|
=
sp
.
has_ssrc_group
(
cricket
:
:
kSimSsrcGroupSemantics
)
;
}
}
if
(
has_legacy
)
{
RTC_HISTOGRAM_ENUMERATION
(
name
kSimulcastApiVersionLegacy
kSimulcastApiVersionMax
)
;
}
if
(
has_spec_compliant
)
{
RTC_HISTOGRAM_ENUMERATION
(
name
kSimulcastApiVersionSpecCompliant
kSimulcastApiVersionMax
)
;
}
if
(
!
has_legacy
&
&
!
has_spec_compliant
)
{
RTC_HISTOGRAM_ENUMERATION
(
name
kSimulcastApiVersionNone
kSimulcastApiVersionMax
)
;
}
}
const
ContentInfo
*
FindTransceiverMSection
(
RtpTransceiverProxyWithInternal
<
RtpTransceiver
>
*
transceiver
const
SessionDescriptionInterface
*
session_description
)
{
return
transceiver
-
>
mid
(
)
?
session_description
-
>
description
(
)
-
>
GetContentByName
(
*
transceiver
-
>
mid
(
)
)
:
nullptr
;
}
std
:
:
vector
<
cricket
:
:
StreamParams
>
GetActiveStreams
(
const
cricket
:
:
MediaContentDescription
*
desc
)
{
return
RtpTransceiverDirectionHasSend
(
desc
-
>
direction
(
)
)
?
desc
-
>
streams
(
)
:
std
:
:
vector
<
cricket
:
:
StreamParams
>
(
)
;
}
bool
IsMediaSectionBeingRecycled
(
SdpType
type
const
ContentInfo
&
content
const
ContentInfo
*
old_content_one
const
ContentInfo
*
old_content_two
)
{
return
type
=
=
SdpType
:
:
kOffer
&
&
!
content
.
rejected
&
&
(
(
old_content_one
&
&
old_content_one
-
>
rejected
)
|
|
(
old_content_two
&
&
old_content_two
-
>
rejected
)
)
;
}
bool
MediaSectionsInSameOrder
(
const
SessionDescription
&
current_desc
const
SessionDescription
*
secondary_current_desc
const
SessionDescription
&
new_desc
const
SdpType
type
)
{
if
(
current_desc
.
contents
(
)
.
size
(
)
>
new_desc
.
contents
(
)
.
size
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
current_desc
.
contents
(
)
.
size
(
)
;
+
+
i
)
{
const
cricket
:
:
ContentInfo
*
secondary_content_info
=
nullptr
;
if
(
secondary_current_desc
&
&
i
<
secondary_current_desc
-
>
contents
(
)
.
size
(
)
)
{
secondary_content_info
=
&
secondary_current_desc
-
>
contents
(
)
[
i
]
;
}
if
(
IsMediaSectionBeingRecycled
(
type
new_desc
.
contents
(
)
[
i
]
&
current_desc
.
contents
(
)
[
i
]
secondary_content_info
)
)
{
continue
;
}
if
(
new_desc
.
contents
(
)
[
i
]
.
name
!
=
current_desc
.
contents
(
)
[
i
]
.
name
)
{
return
false
;
}
const
MediaContentDescription
*
new_desc_mdesc
=
new_desc
.
contents
(
)
[
i
]
.
media_description
(
)
;
const
MediaContentDescription
*
current_desc_mdesc
=
current_desc
.
contents
(
)
[
i
]
.
media_description
(
)
;
if
(
new_desc_mdesc
-
>
type
(
)
!
=
current_desc_mdesc
-
>
type
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
MediaSectionsHaveSameCount
(
const
SessionDescription
&
desc1
const
SessionDescription
&
desc2
)
{
return
desc1
.
contents
(
)
.
size
(
)
=
=
desc2
.
contents
(
)
.
size
(
)
;
}
RTCError
VerifyCrypto
(
const
SessionDescription
*
desc
bool
dtls_enabled
)
{
const
cricket
:
:
ContentGroup
*
bundle
=
desc
-
>
GetGroupByName
(
cricket
:
:
GROUP_TYPE_BUNDLE
)
;
for
(
const
cricket
:
:
ContentInfo
&
content_info
:
desc
-
>
contents
(
)
)
{
if
(
content_info
.
rejected
)
{
continue
;
}
NoteKeyProtocolAndMedia
(
dtls_enabled
?
webrtc
:
:
kEnumCounterKeyProtocolDtls
:
webrtc
:
:
kEnumCounterKeyProtocolSdes
content_info
.
media_description
(
)
-
>
type
(
)
)
;
const
std
:
:
string
&
mid
=
content_info
.
name
;
if
(
bundle
&
&
bundle
-
>
HasContentName
(
mid
)
&
&
mid
!
=
*
(
bundle
-
>
FirstContentName
(
)
)
)
{
continue
;
}
const
MediaContentDescription
*
media
=
content_info
.
media_description
(
)
;
const
TransportInfo
*
tinfo
=
desc
-
>
GetTransportInfoByName
(
mid
)
;
if
(
!
media
|
|
!
tinfo
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kInvalidSdp
)
;
}
if
(
dtls_enabled
)
{
if
(
!
tinfo
-
>
description
.
identity_fingerprint
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Session
description
must
have
DTLS
fingerprint
if
"
"
DTLS
enabled
.
"
;
return
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
kSdpWithoutDtlsFingerprint
)
;
}
}
else
{
if
(
media
-
>
cryptos
(
)
.
empty
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Session
description
must
have
SDES
when
DTLS
disabled
.
"
;
return
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
kSdpWithoutSdesCrypto
)
;
}
}
}
return
RTCError
:
:
OK
(
)
;
}
bool
VerifyIceUfragPwdPresent
(
const
SessionDescription
*
desc
)
{
const
cricket
:
:
ContentGroup
*
bundle
=
desc
-
>
GetGroupByName
(
cricket
:
:
GROUP_TYPE_BUNDLE
)
;
for
(
const
cricket
:
:
ContentInfo
&
content_info
:
desc
-
>
contents
(
)
)
{
if
(
content_info
.
rejected
)
{
continue
;
}
const
std
:
:
string
&
mid
=
content_info
.
name
;
if
(
bundle
&
&
bundle
-
>
HasContentName
(
mid
)
&
&
mid
!
=
*
(
bundle
-
>
FirstContentName
(
)
)
)
{
continue
;
}
const
TransportInfo
*
tinfo
=
desc
-
>
GetTransportInfoByName
(
mid
)
;
if
(
!
tinfo
)
{
RTC_LOG
(
LS_ERROR
)
<
<
kInvalidSdp
;
return
false
;
}
if
(
tinfo
-
>
description
.
ice_ufrag
.
empty
(
)
|
|
tinfo
-
>
description
.
ice_pwd
.
empty
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Session
description
must
have
ice
ufrag
and
pwd
.
"
;
return
false
;
}
}
return
true
;
}
static
RTCError
ValidateMids
(
const
cricket
:
:
SessionDescription
&
description
)
{
std
:
:
set
<
std
:
:
string
>
mids
;
for
(
const
cricket
:
:
ContentInfo
&
content
:
description
.
contents
(
)
)
{
if
(
content
.
name
.
empty
(
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
A
media
section
is
missing
a
MID
attribute
.
"
)
;
}
if
(
!
mids
.
insert
(
content
.
name
)
.
second
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
Duplicate
a
=
mid
value
'
"
+
content
.
name
+
"
'
.
"
)
;
}
}
return
RTCError
:
:
OK
(
)
;
}
bool
IsValidOfferToReceiveMedia
(
int
value
)
{
typedef
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
Options
;
return
(
value
>
=
Options
:
:
kUndefined
)
&
&
(
value
<
=
Options
:
:
kMaxOfferToReceiveMedia
)
;
}
bool
ValidateOfferAnswerOptions
(
const
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
&
rtc_options
)
{
return
IsValidOfferToReceiveMedia
(
rtc_options
.
offer_to_receive_audio
)
&
&
IsValidOfferToReceiveMedia
(
rtc_options
.
offer_to_receive_video
)
;
}
std
:
:
string
GetSignalingStateString
(
PeerConnectionInterface
:
:
SignalingState
state
)
{
switch
(
state
)
{
case
PeerConnectionInterface
:
:
kStable
:
return
"
stable
"
;
case
PeerConnectionInterface
:
:
kHaveLocalOffer
:
return
"
have
-
local
-
offer
"
;
case
PeerConnectionInterface
:
:
kHaveLocalPrAnswer
:
return
"
have
-
local
-
pranswer
"
;
case
PeerConnectionInterface
:
:
kHaveRemoteOffer
:
return
"
have
-
remote
-
offer
"
;
case
PeerConnectionInterface
:
:
kHaveRemotePrAnswer
:
return
"
have
-
remote
-
pranswer
"
;
case
PeerConnectionInterface
:
:
kClosed
:
return
"
closed
"
;
}
RTC_NOTREACHED
(
)
;
return
"
"
;
}
static
std
:
:
vector
<
RtpEncodingParameters
>
GetSendEncodingsFromRemoteDescription
(
const
MediaContentDescription
&
desc
)
{
if
(
!
desc
.
HasSimulcast
(
)
)
{
return
{
}
;
}
std
:
:
vector
<
RtpEncodingParameters
>
result
;
const
SimulcastDescription
&
simulcast
=
desc
.
simulcast_description
(
)
;
for
(
const
auto
&
alternatives
:
simulcast
.
receive_layers
(
)
)
{
RTC_DCHECK
(
!
alternatives
.
empty
(
)
)
;
const
SimulcastLayer
&
layer
=
alternatives
[
0
]
;
RtpEncodingParameters
parameters
;
parameters
.
rid
=
layer
.
rid
;
parameters
.
active
=
!
layer
.
is_paused
;
result
.
push_back
(
parameters
)
;
}
return
result
;
}
static
RTCError
UpdateSimulcastLayerStatusInSender
(
const
std
:
:
vector
<
SimulcastLayer
>
&
layers
rtc
:
:
scoped_refptr
<
RtpSenderInternal
>
sender
)
{
RTC_DCHECK
(
sender
)
;
RtpParameters
parameters
=
sender
-
>
GetParametersInternal
(
)
;
std
:
:
vector
<
std
:
:
string
>
disabled_layers
;
for
(
RtpEncodingParameters
&
encoding
:
parameters
.
encodings
)
{
auto
iter
=
std
:
:
find_if
(
layers
.
begin
(
)
layers
.
end
(
)
[
&
encoding
]
(
const
SimulcastLayer
&
layer
)
{
return
layer
.
rid
=
=
encoding
.
rid
;
}
)
;
if
(
iter
=
=
layers
.
end
(
)
)
{
disabled_layers
.
push_back
(
encoding
.
rid
)
;
continue
;
}
encoding
.
active
=
!
iter
-
>
is_paused
;
}
RTCError
result
=
sender
-
>
SetParametersInternal
(
parameters
)
;
if
(
result
.
ok
(
)
)
{
result
=
sender
-
>
DisableEncodingLayers
(
disabled_layers
)
;
}
return
result
;
}
static
bool
SimulcastIsRejected
(
const
ContentInfo
*
local_content
const
MediaContentDescription
&
answer_media_desc
)
{
bool
simulcast_offered
=
local_content
&
&
local_content
-
>
media_description
(
)
&
&
local_content
-
>
media_description
(
)
-
>
HasSimulcast
(
)
;
bool
simulcast_answered
=
answer_media_desc
.
HasSimulcast
(
)
;
bool
rids_supported
=
RtpExtension
:
:
FindHeaderExtensionByUri
(
answer_media_desc
.
rtp_header_extensions
(
)
RtpExtension
:
:
kRidUri
)
;
return
simulcast_offered
&
&
(
!
simulcast_answered
|
|
!
rids_supported
)
;
}
static
RTCError
DisableSimulcastInSender
(
rtc
:
:
scoped_refptr
<
RtpSenderInternal
>
sender
)
{
RTC_DCHECK
(
sender
)
;
RtpParameters
parameters
=
sender
-
>
GetParametersInternal
(
)
;
if
(
parameters
.
encodings
.
size
(
)
<
=
1
)
{
return
RTCError
:
:
OK
(
)
;
}
std
:
:
vector
<
std
:
:
string
>
disabled_layers
;
std
:
:
transform
(
parameters
.
encodings
.
begin
(
)
+
1
parameters
.
encodings
.
end
(
)
std
:
:
back_inserter
(
disabled_layers
)
[
]
(
const
RtpEncodingParameters
&
encoding
)
{
return
encoding
.
rid
;
}
)
;
return
sender
-
>
DisableEncodingLayers
(
disabled_layers
)
;
}
}
class
SdpOfferAnswerHandler
:
:
ImplicitCreateSessionDescriptionObserver
:
public
CreateSessionDescriptionObserver
{
public
:
ImplicitCreateSessionDescriptionObserver
(
rtc
:
:
WeakPtr
<
SdpOfferAnswerHandler
>
sdp_handler
rtc
:
:
scoped_refptr
<
SetLocalDescriptionObserverInterface
>
set_local_description_observer
)
:
sdp_handler_
(
std
:
:
move
(
sdp_handler
)
)
set_local_description_observer_
(
std
:
:
move
(
set_local_description_observer
)
)
{
}
~
ImplicitCreateSessionDescriptionObserver
(
)
override
{
RTC_DCHECK
(
was_called_
)
;
}
void
SetOperationCompleteCallback
(
std
:
:
function
<
void
(
)
>
operation_complete_callback
)
{
operation_complete_callback_
=
std
:
:
move
(
operation_complete_callback
)
;
}
bool
was_called
(
)
const
{
return
was_called_
;
}
void
OnSuccess
(
SessionDescriptionInterface
*
desc_ptr
)
override
{
RTC_DCHECK
(
!
was_called_
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
(
desc_ptr
)
;
was_called_
=
true
;
if
(
!
sdp_handler_
)
{
operation_complete_callback_
(
)
;
return
;
}
sdp_handler_
-
>
DoSetLocalDescription
(
std
:
:
move
(
desc
)
std
:
:
move
(
set_local_description_observer_
)
)
;
operation_complete_callback_
(
)
;
}
void
OnFailure
(
RTCError
error
)
override
{
RTC_DCHECK
(
!
was_called_
)
;
was_called_
=
true
;
set_local_description_observer_
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
error
.
type
(
)
std
:
:
string
(
"
SetLocalDescription
failed
to
create
"
"
session
description
-
"
)
+
error
.
message
(
)
)
)
;
operation_complete_callback_
(
)
;
}
private
:
bool
was_called_
=
false
;
rtc
:
:
WeakPtr
<
SdpOfferAnswerHandler
>
sdp_handler_
;
rtc
:
:
scoped_refptr
<
SetLocalDescriptionObserverInterface
>
set_local_description_observer_
;
std
:
:
function
<
void
(
)
>
operation_complete_callback_
;
}
;
class
CreateSessionDescriptionObserverOperationWrapper
:
public
CreateSessionDescriptionObserver
{
public
:
CreateSessionDescriptionObserverOperationWrapper
(
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserver
>
observer
std
:
:
function
<
void
(
)
>
operation_complete_callback
)
:
observer_
(
std
:
:
move
(
observer
)
)
operation_complete_callback_
(
std
:
:
move
(
operation_complete_callback
)
)
{
RTC_DCHECK
(
observer_
)
;
}
~
CreateSessionDescriptionObserverOperationWrapper
(
)
override
{
RTC_DCHECK
(
was_called_
)
;
}
void
OnSuccess
(
SessionDescriptionInterface
*
desc
)
override
{
RTC_DCHECK
(
!
was_called_
)
;
#
ifdef
RTC_DCHECK_IS_ON
was_called_
=
true
;
#
endif
operation_complete_callback_
(
)
;
observer_
-
>
OnSuccess
(
desc
)
;
}
void
OnFailure
(
RTCError
error
)
override
{
RTC_DCHECK
(
!
was_called_
)
;
#
ifdef
RTC_DCHECK_IS_ON
was_called_
=
true
;
#
endif
operation_complete_callback_
(
)
;
observer_
-
>
OnFailure
(
std
:
:
move
(
error
)
)
;
}
private
:
#
ifdef
RTC_DCHECK_IS_ON
bool
was_called_
=
false
;
#
endif
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserver
>
observer_
;
std
:
:
function
<
void
(
)
>
operation_complete_callback_
;
}
;
class
SdpOfferAnswerHandler
:
:
SetSessionDescriptionObserverAdapter
:
public
SetLocalDescriptionObserverInterface
public
SetRemoteDescriptionObserverInterface
{
public
:
SetSessionDescriptionObserverAdapter
(
rtc
:
:
WeakPtr
<
SdpOfferAnswerHandler
>
handler
rtc
:
:
scoped_refptr
<
SetSessionDescriptionObserver
>
inner_observer
)
:
handler_
(
std
:
:
move
(
handler
)
)
inner_observer_
(
std
:
:
move
(
inner_observer
)
)
{
}
void
OnSetLocalDescriptionComplete
(
RTCError
error
)
override
{
OnSetDescriptionComplete
(
std
:
:
move
(
error
)
)
;
}
void
OnSetRemoteDescriptionComplete
(
RTCError
error
)
override
{
OnSetDescriptionComplete
(
std
:
:
move
(
error
)
)
;
}
private
:
void
OnSetDescriptionComplete
(
RTCError
error
)
{
if
(
!
handler_
)
return
;
if
(
error
.
ok
(
)
)
{
handler_
-
>
pc_
-
>
PostSetSessionDescriptionSuccess
(
inner_observer_
)
;
}
else
{
handler_
-
>
pc_
-
>
PostSetSessionDescriptionFailure
(
inner_observer_
std
:
:
move
(
error
)
)
;
}
}
rtc
:
:
WeakPtr
<
SdpOfferAnswerHandler
>
handler_
;
rtc
:
:
scoped_refptr
<
SetSessionDescriptionObserver
>
inner_observer_
;
}
;
class
SdpOfferAnswerHandler
:
:
LocalIceCredentialsToReplace
{
public
:
void
SetIceCredentialsFromLocalDescriptions
(
const
SessionDescriptionInterface
*
current_local_description
const
SessionDescriptionInterface
*
pending_local_description
)
{
ice_credentials_
.
clear
(
)
;
if
(
current_local_description
)
{
AppendIceCredentialsFromSessionDescription
(
*
current_local_description
)
;
}
if
(
pending_local_description
)
{
AppendIceCredentialsFromSessionDescription
(
*
pending_local_description
)
;
}
}
void
ClearIceCredentials
(
)
{
ice_credentials_
.
clear
(
)
;
}
bool
HasIceCredentials
(
)
const
{
return
!
ice_credentials_
.
empty
(
)
;
}
bool
SatisfiesIceRestart
(
const
SessionDescriptionInterface
&
local_description
)
const
{
for
(
const
auto
&
transport_info
:
local_description
.
description
(
)
-
>
transport_infos
(
)
)
{
if
(
ice_credentials_
.
find
(
std
:
:
make_pair
(
transport_info
.
description
.
ice_ufrag
transport_info
.
description
.
ice_pwd
)
)
!
=
ice_credentials_
.
end
(
)
)
{
return
false
;
}
}
return
true
;
}
private
:
void
AppendIceCredentialsFromSessionDescription
(
const
SessionDescriptionInterface
&
desc
)
{
for
(
const
auto
&
transport_info
:
desc
.
description
(
)
-
>
transport_infos
(
)
)
{
ice_credentials_
.
insert
(
std
:
:
make_pair
(
transport_info
.
description
.
ice_ufrag
transport_info
.
description
.
ice_pwd
)
)
;
}
}
std
:
:
set
<
std
:
:
pair
<
std
:
:
string
std
:
:
string
>
>
ice_credentials_
;
}
;
SdpOfferAnswerHandler
:
:
SdpOfferAnswerHandler
(
PeerConnection
*
pc
)
:
pc_
(
pc
)
operations_chain_
(
rtc
:
:
OperationsChain
:
:
Create
(
)
)
local_ice_credentials_to_replace_
(
new
LocalIceCredentialsToReplace
(
)
)
weak_ptr_factory_
(
this
)
{
operations_chain_
-
>
SetOnChainEmptyCallback
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
]
(
)
{
if
(
!
this_weak_ptr
)
return
;
this_weak_ptr
-
>
OnOperationsChainEmpty
(
)
;
}
)
;
}
SdpOfferAnswerHandler
:
:
~
SdpOfferAnswerHandler
(
)
{
}
void
SdpOfferAnswerHandler
:
:
PrepareForShutdown
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
weak_ptr_factory_
.
InvalidateWeakPtrs
(
)
;
}
void
SdpOfferAnswerHandler
:
:
Close
(
)
{
ChangeSignalingState
(
PeerConnectionInterface
:
:
kClosed
)
;
}
void
SdpOfferAnswerHandler
:
:
RestartIce
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
local_ice_credentials_to_replace_
-
>
SetIceCredentialsFromLocalDescriptions
(
current_local_description
(
)
pending_local_description
(
)
)
;
UpdateNegotiationNeeded
(
)
;
}
rtc
:
:
Thread
*
SdpOfferAnswerHandler
:
:
signaling_thread
(
)
const
{
return
pc_
-
>
signaling_thread
(
)
;
}
void
SdpOfferAnswerHandler
:
:
CreateOffer
(
CreateSessionDescriptionObserver
*
observer
const
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
&
options
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
observer_refptr
=
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserver
>
(
observer
)
options
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
{
if
(
!
this_weak_ptr
)
{
observer_refptr
-
>
OnFailure
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
CreateOffer
failed
because
the
session
was
shut
down
"
)
)
;
operations_chain_callback
(
)
;
return
;
}
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserverOperationWrapper
>
observer_wrapper
(
new
rtc
:
:
RefCountedObject
<
CreateSessionDescriptionObserverOperationWrapper
>
(
std
:
:
move
(
observer_refptr
)
std
:
:
move
(
operations_chain_callback
)
)
)
;
this_weak_ptr
-
>
DoCreateOffer
(
options
observer_wrapper
)
;
}
)
;
}
void
SdpOfferAnswerHandler
:
:
SetLocalDescription
(
SetSessionDescriptionObserver
*
observer
SessionDescriptionInterface
*
desc_ptr
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
observer_refptr
=
rtc
:
:
scoped_refptr
<
SetSessionDescriptionObserver
>
(
observer
)
desc
=
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
(
desc_ptr
)
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
mutable
{
if
(
!
this_weak_ptr
)
{
operations_chain_callback
(
)
;
return
;
}
this_weak_ptr
-
>
DoSetLocalDescription
(
std
:
:
move
(
desc
)
rtc
:
:
scoped_refptr
<
SetLocalDescriptionObserverInterface
>
(
new
rtc
:
:
RefCountedObject
<
SetSessionDescriptionObserverAdapter
>
(
this_weak_ptr
observer_refptr
)
)
)
;
operations_chain_callback
(
)
;
}
)
;
}
void
SdpOfferAnswerHandler
:
:
SetLocalDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
rtc
:
:
scoped_refptr
<
SetLocalDescriptionObserverInterface
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
observer
desc
=
std
:
:
move
(
desc
)
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
mutable
{
if
(
!
this_weak_ptr
)
{
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
SetLocalDescription
failed
because
the
session
was
shut
down
"
)
)
;
operations_chain_callback
(
)
;
return
;
}
this_weak_ptr
-
>
DoSetLocalDescription
(
std
:
:
move
(
desc
)
observer
)
;
operations_chain_callback
(
)
;
}
)
;
}
void
SdpOfferAnswerHandler
:
:
SetLocalDescription
(
SetSessionDescriptionObserver
*
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
SetLocalDescription
(
new
rtc
:
:
RefCountedObject
<
SetSessionDescriptionObserverAdapter
>
(
weak_ptr_factory_
.
GetWeakPtr
(
)
observer
)
)
;
}
void
SdpOfferAnswerHandler
:
:
SetLocalDescription
(
rtc
:
:
scoped_refptr
<
SetLocalDescriptionObserverInterface
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
rtc
:
:
scoped_refptr
<
ImplicitCreateSessionDescriptionObserver
>
create_sdp_observer
(
new
rtc
:
:
RefCountedObject
<
ImplicitCreateSessionDescriptionObserver
>
(
weak_ptr_factory_
.
GetWeakPtr
(
)
observer
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
create_sdp_observer
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
{
create_sdp_observer
-
>
SetOperationCompleteCallback
(
std
:
:
move
(
operations_chain_callback
)
)
;
if
(
!
this_weak_ptr
)
{
create_sdp_observer
-
>
OnFailure
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
SetLocalDescription
failed
because
the
session
was
shut
down
"
)
)
;
return
;
}
switch
(
this_weak_ptr
-
>
signaling_state
(
)
)
{
case
PeerConnectionInterface
:
:
kStable
:
case
PeerConnectionInterface
:
:
kHaveLocalOffer
:
case
PeerConnectionInterface
:
:
kHaveRemotePrAnswer
:
this_weak_ptr
-
>
DoCreateOffer
(
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
(
)
create_sdp_observer
)
;
break
;
case
PeerConnectionInterface
:
:
kHaveLocalPrAnswer
:
case
PeerConnectionInterface
:
:
kHaveRemoteOffer
:
this_weak_ptr
-
>
DoCreateAnswer
(
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
(
)
create_sdp_observer
)
;
break
;
case
PeerConnectionInterface
:
:
kClosed
:
create_sdp_observer
-
>
OnFailure
(
RTCError
(
RTCErrorType
:
:
INVALID_STATE
"
SetLocalDescription
called
when
PeerConnection
is
closed
.
"
)
)
;
break
;
}
}
)
;
}
RTCError
SdpOfferAnswerHandler
:
:
ApplyLocalDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
desc
)
;
pc_
-
>
stats
(
)
-
>
UpdateStats
(
PeerConnectionInterface
:
:
kStatsOutputLevelStandard
)
;
const
SessionDescriptionInterface
*
old_local_description
=
local_description
(
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
replaced_local_description
;
SdpType
type
=
desc
-
>
GetType
(
)
;
if
(
type
=
=
SdpType
:
:
kAnswer
)
{
replaced_local_description
=
pending_local_description_
?
std
:
:
move
(
pending_local_description_
)
:
std
:
:
move
(
current_local_description_
)
;
current_local_description_
=
std
:
:
move
(
desc
)
;
pending_local_description_
=
nullptr
;
current_remote_description_
=
std
:
:
move
(
pending_remote_description_
)
;
}
else
{
replaced_local_description
=
std
:
:
move
(
pending_local_description_
)
;
pending_local_description_
=
std
:
:
move
(
desc
)
;
}
RTC_DCHECK
(
local_description
(
)
)
;
ReportSimulcastApiVersion
(
kSimulcastVersionApplyLocalDescription
*
local_description
(
)
-
>
description
(
)
)
;
if
(
!
is_caller_
)
{
if
(
remote_description
(
)
)
{
is_caller_
=
false
;
}
else
{
is_caller_
=
true
;
}
}
RTCError
error
=
pc_
-
>
PushdownTransportDescription
(
cricket
:
:
CS_LOCAL
type
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
if
(
IsUnifiedPlan
(
)
)
{
RTCError
error
=
UpdateTransceiversAndDataChannels
(
cricket
:
:
CS_LOCAL
*
local_description
(
)
old_local_description
remote_description
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
remove_list
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
removed_streams
;
for
(
const
auto
&
transceiver
:
pc_
-
>
transceivers_
.
List
(
)
)
{
if
(
transceiver
-
>
stopped
(
)
)
{
continue
;
}
if
(
transceiver
-
>
mid
(
)
)
{
auto
dtls_transport
=
pc_
-
>
LookupDtlsTransportByMidInternal
(
*
transceiver
-
>
mid
(
)
)
;
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
-
>
set_transport
(
dtls_transport
)
;
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
-
>
set_transport
(
dtls_transport
)
;
}
const
ContentInfo
*
content
=
pc_
-
>
FindMediaSectionForTransceiver
(
transceiver
local_description
(
)
)
;
if
(
!
content
)
{
continue
;
}
const
MediaContentDescription
*
media_desc
=
content
-
>
media_description
(
)
;
if
(
type
=
=
SdpType
:
:
kPrAnswer
|
|
type
=
=
SdpType
:
:
kAnswer
)
{
if
(
!
RtpTransceiverDirectionHasRecv
(
media_desc
-
>
direction
(
)
)
&
&
(
transceiver
-
>
internal
(
)
-
>
fired_direction
(
)
&
&
RtpTransceiverDirectionHasRecv
(
*
transceiver
-
>
internal
(
)
-
>
fired_direction
(
)
)
)
)
{
pc_
-
>
ProcessRemovalOfRemoteTrack
(
transceiver
&
remove_list
&
removed_streams
)
;
}
transceiver
-
>
internal
(
)
-
>
set_current_direction
(
media_desc
-
>
direction
(
)
)
;
transceiver
-
>
internal
(
)
-
>
set_fired_direction
(
media_desc
-
>
direction
(
)
)
;
}
}
auto
observer
=
pc_
-
>
Observer
(
)
;
for
(
const
auto
&
transceiver
:
remove_list
)
{
observer
-
>
OnRemoveTrack
(
transceiver
-
>
receiver
(
)
)
;
}
for
(
const
auto
&
stream
:
removed_streams
)
{
observer
-
>
OnRemoveStream
(
stream
)
;
}
}
else
{
if
(
type
=
=
SdpType
:
:
kOffer
)
{
RTCError
error
=
pc_
-
>
CreateChannels
(
*
local_description
(
)
-
>
description
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
}
pc_
-
>
RemoveUnusedChannels
(
local_description
(
)
-
>
description
(
)
)
;
}
error
=
UpdateSessionState
(
type
cricket
:
:
CS_LOCAL
local_description
(
)
-
>
description
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
if
(
remote_description
(
)
)
{
pc_
-
>
UseCandidatesInSessionDescription
(
remote_description
(
)
)
;
}
pending_ice_restarts_
.
clear
(
)
;
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INTERNAL_ERROR
pc_
-
>
GetSessionErrorMsg
(
)
)
;
}
rtc
:
:
SSLRole
role
;
if
(
IsSctpLike
(
pc_
-
>
data_channel_type
(
)
)
&
&
pc_
-
>
GetSctpSslRole
(
&
role
)
)
{
pc_
-
>
data_channel_controller
(
)
-
>
AllocateSctpSids
(
role
)
;
}
if
(
IsUnifiedPlan
(
)
)
{
for
(
const
auto
&
transceiver
:
pc_
-
>
transceivers_
.
List
(
)
)
{
if
(
transceiver
-
>
stopped
(
)
)
{
continue
;
}
const
ContentInfo
*
content
=
pc_
-
>
FindMediaSectionForTransceiver
(
transceiver
local_description
(
)
)
;
if
(
!
content
)
{
continue
;
}
cricket
:
:
ChannelInterface
*
channel
=
transceiver
-
>
internal
(
)
-
>
channel
(
)
;
if
(
content
-
>
rejected
|
|
!
channel
|
|
channel
-
>
local_streams
(
)
.
empty
(
)
)
{
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
-
>
SetSsrc
(
0
)
;
}
else
{
const
std
:
:
vector
<
StreamParams
>
&
streams
=
channel
-
>
local_streams
(
)
;
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
-
>
set_stream_ids
(
streams
[
0
]
.
stream_ids
(
)
)
;
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
-
>
SetSsrc
(
streams
[
0
]
.
first_ssrc
(
)
)
;
}
}
}
else
{
const
cricket
:
:
ContentInfo
*
audio_content
=
GetFirstAudioContent
(
local_description
(
)
-
>
description
(
)
)
;
if
(
audio_content
)
{
if
(
audio_content
-
>
rejected
)
{
pc_
-
>
RemoveSenders
(
cricket
:
:
MEDIA_TYPE_AUDIO
)
;
}
else
{
const
cricket
:
:
AudioContentDescription
*
audio_desc
=
audio_content
-
>
media_description
(
)
-
>
as_audio
(
)
;
pc_
-
>
UpdateLocalSenders
(
audio_desc
-
>
streams
(
)
audio_desc
-
>
type
(
)
)
;
}
}
const
cricket
:
:
ContentInfo
*
video_content
=
GetFirstVideoContent
(
local_description
(
)
-
>
description
(
)
)
;
if
(
video_content
)
{
if
(
video_content
-
>
rejected
)
{
pc_
-
>
RemoveSenders
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
}
else
{
const
cricket
:
:
VideoContentDescription
*
video_desc
=
video_content
-
>
media_description
(
)
-
>
as_video
(
)
;
pc_
-
>
UpdateLocalSenders
(
video_desc
-
>
streams
(
)
video_desc
-
>
type
(
)
)
;
}
}
}
const
cricket
:
:
ContentInfo
*
data_content
=
GetFirstDataContent
(
local_description
(
)
-
>
description
(
)
)
;
if
(
data_content
)
{
const
cricket
:
:
RtpDataContentDescription
*
rtp_data_desc
=
data_content
-
>
media_description
(
)
-
>
as_rtp_data
(
)
;
if
(
rtp_data_desc
)
{
pc_
-
>
data_channel_controller
(
)
-
>
UpdateLocalRtpDataChannels
(
rtp_data_desc
-
>
streams
(
)
)
;
}
}
if
(
type
=
=
SdpType
:
:
kAnswer
&
&
local_ice_credentials_to_replace_
-
>
SatisfiesIceRestart
(
*
current_local_description_
)
)
{
local_ice_credentials_to_replace_
-
>
ClearIceCredentials
(
)
;
}
return
RTCError
:
:
OK
(
)
;
}
void
SdpOfferAnswerHandler
:
:
SetRemoteDescription
(
SetSessionDescriptionObserver
*
observer
SessionDescriptionInterface
*
desc_ptr
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
observer_refptr
=
rtc
:
:
scoped_refptr
<
SetSessionDescriptionObserver
>
(
observer
)
desc
=
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
(
desc_ptr
)
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
mutable
{
if
(
!
this_weak_ptr
)
{
operations_chain_callback
(
)
;
return
;
}
this_weak_ptr
-
>
DoSetRemoteDescription
(
std
:
:
move
(
desc
)
rtc
:
:
scoped_refptr
<
SetRemoteDescriptionObserverInterface
>
(
new
rtc
:
:
RefCountedObject
<
SetSessionDescriptionObserverAdapter
>
(
this_weak_ptr
observer_refptr
)
)
)
;
operations_chain_callback
(
)
;
}
)
;
}
void
SdpOfferAnswerHandler
:
:
SetRemoteDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
rtc
:
:
scoped_refptr
<
SetRemoteDescriptionObserverInterface
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
observer
desc
=
std
:
:
move
(
desc
)
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
mutable
{
if
(
!
this_weak_ptr
)
{
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
SetRemoteDescription
failed
because
the
session
was
shut
down
"
)
)
;
operations_chain_callback
(
)
;
return
;
}
this_weak_ptr
-
>
DoSetRemoteDescription
(
std
:
:
move
(
desc
)
std
:
:
move
(
observer
)
)
;
operations_chain_callback
(
)
;
}
)
;
}
RTCError
SdpOfferAnswerHandler
:
:
ApplyRemoteDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
desc
)
;
pc_
-
>
stats
(
)
-
>
UpdateStats
(
PeerConnectionInterface
:
:
kStatsOutputLevelStandard
)
;
const
SessionDescriptionInterface
*
old_remote_description
=
remote_description
(
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
replaced_remote_description
;
SdpType
type
=
desc
-
>
GetType
(
)
;
if
(
type
=
=
SdpType
:
:
kAnswer
)
{
replaced_remote_description
=
pending_remote_description_
?
std
:
:
move
(
pending_remote_description_
)
:
std
:
:
move
(
current_remote_description_
)
;
current_remote_description_
=
std
:
:
move
(
desc
)
;
pending_remote_description_
=
nullptr
;
current_local_description_
=
std
:
:
move
(
pending_local_description_
)
;
}
else
{
replaced_remote_description
=
std
:
:
move
(
pending_remote_description_
)
;
pending_remote_description_
=
std
:
:
move
(
desc
)
;
}
RTC_DCHECK
(
remote_description
(
)
)
;
ReportSimulcastApiVersion
(
kSimulcastVersionApplyRemoteDescription
*
remote_description
(
)
-
>
description
(
)
)
;
RTCError
error
=
pc_
-
>
PushdownTransportDescription
(
cricket
:
:
CS_REMOTE
type
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
if
(
IsUnifiedPlan
(
)
)
{
RTCError
error
=
UpdateTransceiversAndDataChannels
(
cricket
:
:
CS_REMOTE
*
remote_description
(
)
local_description
(
)
old_remote_description
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
}
else
{
if
(
type
=
=
SdpType
:
:
kOffer
)
{
RTCError
error
=
pc_
-
>
CreateChannels
(
*
remote_description
(
)
-
>
description
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
}
pc_
-
>
RemoveUnusedChannels
(
remote_description
(
)
-
>
description
(
)
)
;
}
error
=
UpdateSessionState
(
type
cricket
:
:
CS_REMOTE
remote_description
(
)
-
>
description
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
if
(
local_description
(
)
&
&
!
pc_
-
>
UseCandidatesInSessionDescription
(
remote_description
(
)
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kInvalidCandidates
)
;
}
if
(
old_remote_description
)
{
for
(
const
cricket
:
:
ContentInfo
&
content
:
old_remote_description
-
>
description
(
)
-
>
contents
(
)
)
{
if
(
CheckForRemoteIceRestart
(
old_remote_description
remote_description
(
)
content
.
name
)
)
{
if
(
type
=
=
SdpType
:
:
kOffer
)
{
pending_ice_restarts_
.
insert
(
content
.
name
)
;
}
}
else
{
WebRtcSessionDescriptionFactory
:
:
CopyCandidatesFromSessionDescription
(
old_remote_description
content
.
name
mutable_remote_description
(
)
)
;
}
}
}
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INTERNAL_ERROR
pc_
-
>
GetSessionErrorMsg
(
)
)
;
}
if
(
remote_description
(
)
-
>
GetType
(
)
!
=
SdpType
:
:
kOffer
&
&
remote_description
(
)
-
>
number_of_mediasections
(
)
>
0u
&
&
pc_
-
>
ice_connection_state
(
)
=
=
PeerConnectionInterface
:
:
kIceConnectionNew
)
{
pc_
-
>
SetIceConnectionState
(
PeerConnectionInterface
:
:
kIceConnectionChecking
)
;
}
rtc
:
:
SSLRole
role
;
if
(
IsSctpLike
(
pc_
-
>
data_channel_type
(
)
)
&
&
pc_
-
>
GetSctpSslRole
(
&
role
)
)
{
pc_
-
>
data_channel_controller
(
)
-
>
AllocateSctpSids
(
role
)
;
}
if
(
IsUnifiedPlan
(
)
)
{
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
now_receiving_transceivers
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
remove_list
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
added_streams
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
removed_streams
;
for
(
const
auto
&
transceiver
:
pc_
-
>
transceivers_
.
List
(
)
)
{
const
ContentInfo
*
content
=
pc_
-
>
FindMediaSectionForTransceiver
(
transceiver
remote_description
(
)
)
;
if
(
!
content
)
{
continue
;
}
const
MediaContentDescription
*
media_desc
=
content
-
>
media_description
(
)
;
RtpTransceiverDirection
local_direction
=
RtpTransceiverDirectionReversed
(
media_desc
-
>
direction
(
)
)
;
if
(
RtpTransceiverDirectionHasRecv
(
local_direction
)
)
{
std
:
:
vector
<
std
:
:
string
>
stream_ids
;
if
(
!
media_desc
-
>
streams
(
)
.
empty
(
)
)
{
stream_ids
=
media_desc
-
>
streams
(
)
[
0
]
.
stream_ids
(
)
;
}
pc_
-
>
transceivers_
.
StableState
(
transceiver
)
-
>
SetRemoteStreamIdsIfUnset
(
transceiver
-
>
receiver
(
)
-
>
stream_ids
(
)
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Processing
the
MSIDs
for
MID
=
"
<
<
content
-
>
name
<
<
"
(
"
<
<
GetStreamIdsString
(
stream_ids
)
<
<
"
)
.
"
;
SetAssociatedRemoteStreams
(
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
stream_ids
&
added_streams
&
removed_streams
)
;
if
(
!
transceiver
-
>
fired_direction
(
)
|
|
!
RtpTransceiverDirectionHasRecv
(
*
transceiver
-
>
fired_direction
(
)
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Processing
the
addition
of
a
remote
track
for
MID
=
"
<
<
content
-
>
name
<
<
"
.
"
;
now_receiving_transceivers
.
push_back
(
transceiver
)
;
}
}
if
(
!
RtpTransceiverDirectionHasRecv
(
local_direction
)
&
&
(
transceiver
-
>
fired_direction
(
)
&
&
RtpTransceiverDirectionHasRecv
(
*
transceiver
-
>
fired_direction
(
)
)
)
)
{
pc_
-
>
ProcessRemovalOfRemoteTrack
(
transceiver
&
remove_list
&
removed_streams
)
;
}
transceiver
-
>
internal
(
)
-
>
set_fired_direction
(
local_direction
)
;
if
(
type
=
=
SdpType
:
:
kPrAnswer
|
|
type
=
=
SdpType
:
:
kAnswer
)
{
transceiver
-
>
internal
(
)
-
>
set_current_direction
(
local_direction
)
;
if
(
transceiver
-
>
mid
(
)
)
{
auto
dtls_transport
=
pc_
-
>
LookupDtlsTransportByMidInternal
(
*
transceiver
-
>
mid
(
)
)
;
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
-
>
set_transport
(
dtls_transport
)
;
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
-
>
set_transport
(
dtls_transport
)
;
}
}
if
(
content
-
>
rejected
&
&
!
transceiver
-
>
stopped
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Stopping
transceiver
for
MID
=
"
<
<
content
-
>
name
<
<
"
since
the
media
section
was
rejected
.
"
;
transceiver
-
>
internal
(
)
-
>
StopTransceiverProcedure
(
)
;
}
if
(
!
content
-
>
rejected
&
&
RtpTransceiverDirectionHasRecv
(
local_direction
)
)
{
if
(
!
media_desc
-
>
streams
(
)
.
empty
(
)
&
&
media_desc
-
>
streams
(
)
[
0
]
.
has_ssrcs
(
)
)
{
uint32_t
ssrc
=
media_desc
-
>
streams
(
)
[
0
]
.
first_ssrc
(
)
;
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
-
>
SetupMediaChannel
(
ssrc
)
;
}
else
{
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
-
>
SetupUnsignaledMediaChannel
(
)
;
}
}
}
auto
observer
=
pc_
-
>
Observer
(
)
;
for
(
const
auto
&
transceiver
:
now_receiving_transceivers
)
{
pc_
-
>
stats
(
)
-
>
AddTrack
(
transceiver
-
>
receiver
(
)
-
>
track
(
)
)
;
observer
-
>
OnTrack
(
transceiver
)
;
observer
-
>
OnAddTrack
(
transceiver
-
>
receiver
(
)
transceiver
-
>
receiver
(
)
-
>
streams
(
)
)
;
}
for
(
const
auto
&
stream
:
added_streams
)
{
observer
-
>
OnAddStream
(
stream
)
;
}
for
(
const
auto
&
transceiver
:
remove_list
)
{
observer
-
>
OnRemoveTrack
(
transceiver
-
>
receiver
(
)
)
;
}
for
(
const
auto
&
stream
:
removed_streams
)
{
observer
-
>
OnRemoveStream
(
stream
)
;
}
}
const
cricket
:
:
ContentInfo
*
audio_content
=
GetFirstAudioContent
(
remote_description
(
)
-
>
description
(
)
)
;
const
cricket
:
:
ContentInfo
*
video_content
=
GetFirstVideoContent
(
remote_description
(
)
-
>
description
(
)
)
;
const
cricket
:
:
AudioContentDescription
*
audio_desc
=
GetFirstAudioContentDescription
(
remote_description
(
)
-
>
description
(
)
)
;
const
cricket
:
:
VideoContentDescription
*
video_desc
=
GetFirstVideoContentDescription
(
remote_description
(
)
-
>
description
(
)
)
;
const
cricket
:
:
RtpDataContentDescription
*
rtp_data_desc
=
GetFirstRtpDataContentDescription
(
remote_description
(
)
-
>
description
(
)
)
;
if
(
remote_description
(
)
-
>
description
(
)
-
>
msid_supported
(
)
|
|
(
audio_desc
&
&
!
audio_desc
-
>
streams
(
)
.
empty
(
)
)
|
|
(
video_desc
&
&
!
video_desc
-
>
streams
(
)
.
empty
(
)
)
)
{
remote_peer_supports_msid_
=
true
;
}
rtc
:
:
scoped_refptr
<
StreamCollection
>
new_streams
(
StreamCollection
:
:
Create
(
)
)
;
if
(
!
IsUnifiedPlan
(
)
)
{
if
(
audio_content
)
{
if
(
audio_content
-
>
rejected
)
{
pc_
-
>
RemoveSenders
(
cricket
:
:
MEDIA_TYPE_AUDIO
)
;
}
else
{
bool
default_audio_track_needed
=
!
remote_peer_supports_msid_
&
&
RtpTransceiverDirectionHasSend
(
audio_desc
-
>
direction
(
)
)
;
pc_
-
>
UpdateRemoteSendersList
(
GetActiveStreams
(
audio_desc
)
default_audio_track_needed
audio_desc
-
>
type
(
)
new_streams
)
;
}
}
if
(
video_content
)
{
if
(
video_content
-
>
rejected
)
{
pc_
-
>
RemoveSenders
(
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
}
else
{
bool
default_video_track_needed
=
!
remote_peer_supports_msid_
&
&
RtpTransceiverDirectionHasSend
(
video_desc
-
>
direction
(
)
)
;
pc_
-
>
UpdateRemoteSendersList
(
GetActiveStreams
(
video_desc
)
default_video_track_needed
video_desc
-
>
type
(
)
new_streams
)
;
}
}
if
(
rtp_data_desc
)
{
pc_
-
>
data_channel_controller
(
)
-
>
UpdateRemoteRtpDataChannels
(
GetActiveStreams
(
rtp_data_desc
)
)
;
}
auto
observer
=
pc_
-
>
Observer
(
)
;
for
(
size_t
i
=
0
;
i
<
new_streams
-
>
count
(
)
;
+
+
i
)
{
MediaStreamInterface
*
new_stream
=
new_streams
-
>
at
(
i
)
;
pc_
-
>
stats
(
)
-
>
AddStream
(
new_stream
)
;
observer
-
>
OnAddStream
(
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
(
new_stream
)
)
;
}
pc_
-
>
UpdateEndedRemoteMediaStreams
(
)
;
}
if
(
type
=
=
SdpType
:
:
kAnswer
&
&
local_ice_credentials_to_replace_
-
>
SatisfiesIceRestart
(
*
current_local_description_
)
)
{
local_ice_credentials_to_replace_
-
>
ClearIceCredentials
(
)
;
}
return
RTCError
:
:
OK
(
)
;
}
void
SdpOfferAnswerHandler
:
:
DoSetLocalDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
rtc
:
:
scoped_refptr
<
SetLocalDescriptionObserverInterface
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
TRACE_EVENT0
(
"
webrtc
"
"
SdpOfferAnswerHandler
:
:
DoSetLocalDescription
"
)
;
if
(
!
observer
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SetLocalDescription
-
observer
is
NULL
.
"
;
return
;
}
if
(
!
desc
)
{
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
SessionDescription
is
NULL
.
"
)
)
;
return
;
}
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
std
:
:
string
error_message
=
pc_
-
>
GetSessionErrorMsg
(
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
SetLocalDescription
:
"
<
<
error_message
;
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
std
:
:
move
(
error_message
)
)
)
;
return
;
}
if
(
desc
-
>
GetType
(
)
=
=
SdpType
:
:
kRollback
)
{
if
(
IsUnifiedPlan
(
)
)
{
observer
-
>
OnSetLocalDescriptionComplete
(
Rollback
(
desc
-
>
GetType
(
)
)
)
;
}
else
{
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
UNSUPPORTED_OPERATION
"
Rollback
not
supported
in
Plan
B
"
)
)
;
}
return
;
}
RTCError
error
=
ValidateSessionDescription
(
desc
.
get
(
)
cricket
:
:
CS_LOCAL
)
;
if
(
!
error
.
ok
(
)
)
{
std
:
:
string
error_message
=
GetSetDescriptionErrorMessage
(
cricket
:
:
CS_LOCAL
desc
-
>
GetType
(
)
error
)
;
RTC_LOG
(
LS_ERROR
)
<
<
error_message
;
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
std
:
:
move
(
error_message
)
)
)
;
return
;
}
const
SdpType
type
=
desc
-
>
GetType
(
)
;
error
=
ApplyLocalDescription
(
std
:
:
move
(
desc
)
)
;
if
(
!
error
.
ok
(
)
)
{
pc_
-
>
SetSessionError
(
PeerConnection
:
:
SessionError
:
:
kContent
error
.
message
(
)
)
;
std
:
:
string
error_message
=
GetSetDescriptionErrorMessage
(
cricket
:
:
CS_LOCAL
type
error
)
;
RTC_LOG
(
LS_ERROR
)
<
<
error_message
;
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
std
:
:
move
(
error_message
)
)
)
;
return
;
}
RTC_DCHECK
(
local_description
(
)
)
;
if
(
local_description
(
)
-
>
GetType
(
)
=
=
SdpType
:
:
kAnswer
)
{
pc_
-
>
RemoveStoppedTransceivers
(
)
;
pc_
-
>
network_thread
(
)
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
rtc
:
:
Bind
(
&
cricket
:
:
PortAllocator
:
:
DiscardCandidatePool
pc_
-
>
port_allocator_
.
get
(
)
)
)
;
pc_
-
>
ReportNegotiatedSdpSemantics
(
*
local_description
(
)
)
;
}
observer
-
>
OnSetLocalDescriptionComplete
(
RTCError
:
:
OK
(
)
)
;
pc_
-
>
NoteUsageEvent
(
PeerConnection
:
:
UsageEvent
:
:
SET_LOCAL_DESCRIPTION_SUCCEEDED
)
;
if
(
IsUnifiedPlan
(
)
)
{
bool
was_negotiation_needed
=
is_negotiation_needed_
;
UpdateNegotiationNeeded
(
)
;
if
(
signaling_state
(
)
=
=
PeerConnectionInterface
:
:
kStable
&
&
was_negotiation_needed
&
&
is_negotiation_needed_
)
{
pc_
-
>
Observer
(
)
-
>
OnRenegotiationNeeded
(
)
;
GenerateNegotiationNeededEvent
(
)
;
}
}
pc_
-
>
transport_controller_
-
>
MaybeStartGathering
(
)
;
}
void
SdpOfferAnswerHandler
:
:
DoCreateOffer
(
const
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
&
options
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserver
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
TRACE_EVENT0
(
"
webrtc
"
"
SdpOfferAnswerHandler
:
:
DoCreateOffer
"
)
;
if
(
!
observer
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
CreateOffer
-
observer
is
NULL
.
"
;
return
;
}
if
(
pc_
-
>
IsClosed
(
)
)
{
std
:
:
string
error
=
"
CreateOffer
called
when
PeerConnection
is
closed
.
"
;
RTC_LOG
(
LS_ERROR
)
<
<
error
;
pc_
-
>
PostCreateSessionDescriptionFailure
(
observer
RTCError
(
RTCErrorType
:
:
INVALID_STATE
std
:
:
move
(
error
)
)
)
;
return
;
}
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
std
:
:
string
error_message
=
pc_
-
>
GetSessionErrorMsg
(
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
CreateOffer
:
"
<
<
error_message
;
pc_
-
>
PostCreateSessionDescriptionFailure
(
observer
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
std
:
:
move
(
error_message
)
)
)
;
return
;
}
if
(
!
ValidateOfferAnswerOptions
(
options
)
)
{
std
:
:
string
error
=
"
CreateOffer
called
with
invalid
options
.
"
;
RTC_LOG
(
LS_ERROR
)
<
<
error
;
pc_
-
>
PostCreateSessionDescriptionFailure
(
observer
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
std
:
:
move
(
error
)
)
)
;
return
;
}
if
(
IsUnifiedPlan
(
)
)
{
RTCError
error
=
pc_
-
>
HandleLegacyOfferOptions
(
options
)
;
if
(
!
error
.
ok
(
)
)
{
pc_
-
>
PostCreateSessionDescriptionFailure
(
observer
std
:
:
move
(
error
)
)
;
return
;
}
}
cricket
:
:
MediaSessionOptions
session_options
;
pc_
-
>
GetOptionsForOffer
(
options
&
session_options
)
;
webrtc_session_desc_factory_
-
>
CreateOffer
(
observer
options
session_options
)
;
}
void
SdpOfferAnswerHandler
:
:
CreateAnswer
(
CreateSessionDescriptionObserver
*
observer
const
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
&
options
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
observer_refptr
=
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserver
>
(
observer
)
options
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
{
if
(
!
this_weak_ptr
)
{
observer_refptr
-
>
OnFailure
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
CreateAnswer
failed
because
the
session
was
shut
down
"
)
)
;
operations_chain_callback
(
)
;
return
;
}
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserverOperationWrapper
>
observer_wrapper
(
new
rtc
:
:
RefCountedObject
<
CreateSessionDescriptionObserverOperationWrapper
>
(
std
:
:
move
(
observer_refptr
)
std
:
:
move
(
operations_chain_callback
)
)
)
;
this_weak_ptr
-
>
DoCreateAnswer
(
options
observer_wrapper
)
;
}
)
;
}
void
SdpOfferAnswerHandler
:
:
DoCreateAnswer
(
const
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
&
options
rtc
:
:
scoped_refptr
<
CreateSessionDescriptionObserver
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
TRACE_EVENT0
(
"
webrtc
"
"
SdpOfferAnswerHandler
:
:
DoCreateAnswer
"
)
;
if
(
!
observer
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
CreateAnswer
-
observer
is
NULL
.
"
;
return
;
}
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
std
:
:
string
error_message
=
pc_
-
>
GetSessionErrorMsg
(
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
CreateAnswer
:
"
<
<
error_message
;
pc_
-
>
PostCreateSessionDescriptionFailure
(
observer
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
std
:
:
move
(
error_message
)
)
)
;
return
;
}
if
(
!
(
signaling_state_
=
=
PeerConnectionInterface
:
:
kHaveRemoteOffer
|
|
signaling_state_
=
=
PeerConnectionInterface
:
:
kHaveLocalPrAnswer
)
)
{
std
:
:
string
error
=
"
PeerConnection
cannot
create
an
answer
in
a
state
other
than
"
"
have
-
remote
-
offer
or
have
-
local
-
pranswer
.
"
;
RTC_LOG
(
LS_ERROR
)
<
<
error
;
pc_
-
>
PostCreateSessionDescriptionFailure
(
observer
RTCError
(
RTCErrorType
:
:
INVALID_STATE
std
:
:
move
(
error
)
)
)
;
return
;
}
RTC_DCHECK
(
remote_description
(
)
)
;
if
(
IsUnifiedPlan
(
)
)
{
if
(
options
.
offer_to_receive_audio
!
=
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
:
:
kUndefined
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
CreateAnswer
:
offer_to_receive_audio
is
not
"
"
supported
with
Unified
Plan
semantics
.
Use
the
"
"
RtpTransceiver
API
instead
.
"
;
}
if
(
options
.
offer_to_receive_video
!
=
PeerConnectionInterface
:
:
RTCOfferAnswerOptions
:
:
kUndefined
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
CreateAnswer
:
offer_to_receive_video
is
not
"
"
supported
with
Unified
Plan
semantics
.
Use
the
"
"
RtpTransceiver
API
instead
.
"
;
}
}
cricket
:
:
MediaSessionOptions
session_options
;
pc_
-
>
GetOptionsForAnswer
(
options
&
session_options
)
;
webrtc_session_desc_factory_
-
>
CreateAnswer
(
observer
session_options
)
;
}
void
SdpOfferAnswerHandler
:
:
DoSetRemoteDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
rtc
:
:
scoped_refptr
<
SetRemoteDescriptionObserverInterface
>
observer
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
TRACE_EVENT0
(
"
webrtc
"
"
SdpOfferAnswerHandler
:
:
DoSetRemoteDescription
"
)
;
if
(
!
observer
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SetRemoteDescription
-
observer
is
NULL
.
"
;
return
;
}
if
(
!
desc
)
{
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
"
SessionDescription
is
NULL
.
"
)
)
;
return
;
}
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
std
:
:
string
error_message
=
pc_
-
>
GetSessionErrorMsg
(
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
SetRemoteDescription
:
"
<
<
error_message
;
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
std
:
:
move
(
error_message
)
)
)
;
return
;
}
if
(
IsUnifiedPlan
(
)
)
{
if
(
pc_
-
>
configuration
(
)
-
>
enable_implicit_rollback
)
{
if
(
desc
-
>
GetType
(
)
=
=
SdpType
:
:
kOffer
&
&
signaling_state
(
)
=
=
PeerConnectionInterface
:
:
kHaveLocalOffer
)
{
Rollback
(
desc
-
>
GetType
(
)
)
;
}
}
if
(
desc
-
>
GetType
(
)
=
=
SdpType
:
:
kRollback
)
{
observer
-
>
OnSetRemoteDescriptionComplete
(
Rollback
(
desc
-
>
GetType
(
)
)
)
;
return
;
}
}
else
if
(
desc
-
>
GetType
(
)
=
=
SdpType
:
:
kRollback
)
{
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
(
RTCErrorType
:
:
UNSUPPORTED_OPERATION
"
Rollback
not
supported
in
Plan
B
"
)
)
;
return
;
}
if
(
desc
-
>
GetType
(
)
=
=
SdpType
:
:
kOffer
)
{
pc_
-
>
ReportSdpFormatReceived
(
*
desc
)
;
}
pc_
-
>
FillInMissingRemoteMids
(
desc
-
>
description
(
)
)
;
RTCError
error
=
ValidateSessionDescription
(
desc
.
get
(
)
cricket
:
:
CS_REMOTE
)
;
if
(
!
error
.
ok
(
)
)
{
std
:
:
string
error_message
=
GetSetDescriptionErrorMessage
(
cricket
:
:
CS_REMOTE
desc
-
>
GetType
(
)
error
)
;
RTC_LOG
(
LS_ERROR
)
<
<
error_message
;
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
(
error
.
type
(
)
std
:
:
move
(
error_message
)
)
)
;
return
;
}
const
SdpType
type
=
desc
-
>
GetType
(
)
;
error
=
ApplyRemoteDescription
(
std
:
:
move
(
desc
)
)
;
if
(
!
error
.
ok
(
)
)
{
pc_
-
>
SetSessionError
(
PeerConnection
:
:
SessionError
:
:
kContent
error
.
message
(
)
)
;
std
:
:
string
error_message
=
GetSetDescriptionErrorMessage
(
cricket
:
:
CS_REMOTE
type
error
)
;
RTC_LOG
(
LS_ERROR
)
<
<
error_message
;
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
(
error
.
type
(
)
std
:
:
move
(
error_message
)
)
)
;
return
;
}
RTC_DCHECK
(
remote_description
(
)
)
;
if
(
type
=
=
SdpType
:
:
kAnswer
)
{
pc_
-
>
RemoveStoppedTransceivers
(
)
;
pc_
-
>
network_thread
(
)
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
rtc
:
:
Bind
(
&
cricket
:
:
PortAllocator
:
:
DiscardCandidatePool
pc_
-
>
port_allocator_
.
get
(
)
)
)
;
pc_
-
>
ReportNegotiatedSdpSemantics
(
*
remote_description
(
)
)
;
}
observer
-
>
OnSetRemoteDescriptionComplete
(
RTCError
:
:
OK
(
)
)
;
pc_
-
>
NoteUsageEvent
(
PeerConnection
:
:
UsageEvent
:
:
SET_REMOTE_DESCRIPTION_SUCCEEDED
)
;
if
(
IsUnifiedPlan
(
)
)
{
bool
was_negotiation_needed
=
is_negotiation_needed_
;
UpdateNegotiationNeeded
(
)
;
if
(
signaling_state
(
)
=
=
PeerConnectionInterface
:
:
kStable
&
&
was_negotiation_needed
&
&
is_negotiation_needed_
)
{
pc_
-
>
Observer
(
)
-
>
OnRenegotiationNeeded
(
)
;
GenerateNegotiationNeededEvent
(
)
;
}
}
}
void
SdpOfferAnswerHandler
:
:
SetAssociatedRemoteStreams
(
rtc
:
:
scoped_refptr
<
RtpReceiverInternal
>
receiver
const
std
:
:
vector
<
std
:
:
string
>
&
stream_ids
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
*
added_streams
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
*
removed_streams
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
media_streams
;
for
(
const
std
:
:
string
&
stream_id
:
stream_ids
)
{
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
stream
=
pc_
-
>
remote_streams_internal
(
)
-
>
find
(
stream_id
)
;
if
(
!
stream
)
{
stream
=
MediaStreamProxy
:
:
Create
(
rtc
:
:
Thread
:
:
Current
(
)
MediaStream
:
:
Create
(
stream_id
)
)
;
pc_
-
>
remote_streams_internal
(
)
-
>
AddStream
(
stream
)
;
added_streams
-
>
push_back
(
stream
)
;
}
media_streams
.
push_back
(
stream
)
;
}
if
(
media_streams
.
empty
(
)
&
&
!
(
remote_description
(
)
-
>
description
(
)
-
>
msid_signaling
(
)
&
cricket
:
:
kMsidSignalingMediaSection
)
)
{
if
(
!
missing_msid_default_stream_
)
{
missing_msid_default_stream_
=
MediaStreamProxy
:
:
Create
(
rtc
:
:
Thread
:
:
Current
(
)
MediaStream
:
:
Create
(
rtc
:
:
CreateRandomUuid
(
)
)
)
;
added_streams
-
>
push_back
(
missing_msid_default_stream_
)
;
}
media_streams
.
push_back
(
missing_msid_default_stream_
)
;
}
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
previous_streams
=
receiver
-
>
streams
(
)
;
receiver
-
>
SetStreams
(
media_streams
)
;
pc_
-
>
RemoveRemoteStreamsIfEmpty
(
previous_streams
removed_streams
)
;
}
bool
SdpOfferAnswerHandler
:
:
AddIceCandidate
(
const
IceCandidateInterface
*
ice_candidate
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
TRACE_EVENT0
(
"
webrtc
"
"
SdpOfferAnswerHandler
:
:
AddIceCandidate
"
)
;
if
(
pc_
-
>
IsClosed
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
AddIceCandidate
:
PeerConnection
is
closed
.
"
;
NoteAddIceCandidateResult
(
kAddIceCandidateFailClosed
)
;
return
false
;
}
if
(
!
remote_description
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
AddIceCandidate
:
ICE
candidates
can
'
t
be
added
"
"
without
any
remote
session
description
.
"
;
NoteAddIceCandidateResult
(
kAddIceCandidateFailNoRemoteDescription
)
;
return
false
;
}
if
(
!
ice_candidate
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
AddIceCandidate
:
Candidate
is
null
.
"
;
NoteAddIceCandidateResult
(
kAddIceCandidateFailNullCandidate
)
;
return
false
;
}
bool
valid
=
false
;
bool
ready
=
pc_
-
>
ReadyToUseRemoteCandidate
(
ice_candidate
nullptr
&
valid
)
;
if
(
!
valid
)
{
NoteAddIceCandidateResult
(
kAddIceCandidateFailNotValid
)
;
return
false
;
}
if
(
!
mutable_remote_description
(
)
-
>
AddCandidate
(
ice_candidate
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
AddIceCandidate
:
Candidate
cannot
be
used
.
"
;
NoteAddIceCandidateResult
(
kAddIceCandidateFailInAddition
)
;
return
false
;
}
if
(
ready
)
{
bool
result
=
pc_
-
>
UseCandidate
(
ice_candidate
)
;
if
(
result
)
{
pc_
-
>
NoteUsageEvent
(
PeerConnection
:
:
UsageEvent
:
:
ADD_ICE_CANDIDATE_SUCCEEDED
)
;
NoteAddIceCandidateResult
(
kAddIceCandidateSuccess
)
;
}
else
{
NoteAddIceCandidateResult
(
kAddIceCandidateFailNotUsable
)
;
}
return
result
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
AddIceCandidate
:
Not
ready
to
use
candidate
.
"
;
NoteAddIceCandidateResult
(
kAddIceCandidateFailNotReady
)
;
return
true
;
}
}
void
SdpOfferAnswerHandler
:
:
AddIceCandidate
(
std
:
:
unique_ptr
<
IceCandidateInterface
>
candidate
std
:
:
function
<
void
(
RTCError
)
>
callback
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
operations_chain_
-
>
ChainOperation
(
[
this_weak_ptr
=
weak_ptr_factory_
.
GetWeakPtr
(
)
candidate
=
std
:
:
move
(
candidate
)
callback
=
std
:
:
move
(
callback
)
]
(
std
:
:
function
<
void
(
)
>
operations_chain_callback
)
{
if
(
!
this_weak_ptr
)
{
operations_chain_callback
(
)
;
callback
(
RTCError
(
RTCErrorType
:
:
INVALID_STATE
"
AddIceCandidate
failed
because
the
session
was
shut
down
"
)
)
;
return
;
}
if
(
!
this_weak_ptr
-
>
AddIceCandidate
(
candidate
.
get
(
)
)
)
{
operations_chain_callback
(
)
;
callback
(
RTCError
(
RTCErrorType
:
:
UNSUPPORTED_OPERATION
"
Error
processing
ICE
candidate
"
)
)
;
return
;
}
operations_chain_callback
(
)
;
callback
(
RTCError
:
:
OK
(
)
)
;
}
)
;
}
bool
SdpOfferAnswerHandler
:
:
RemoveIceCandidates
(
const
std
:
:
vector
<
cricket
:
:
Candidate
>
&
candidates
)
{
TRACE_EVENT0
(
"
webrtc
"
"
SdpOfferAnswerHandler
:
:
RemoveIceCandidates
"
)
;
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
pc_
-
>
IsClosed
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
RemoveIceCandidates
:
PeerConnection
is
closed
.
"
;
return
false
;
}
if
(
!
remote_description
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
RemoveIceCandidates
:
ICE
candidates
can
'
t
be
removed
"
"
without
any
remote
session
description
.
"
;
return
false
;
}
if
(
candidates
.
empty
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
RemoveIceCandidates
:
candidates
are
empty
.
"
;
return
false
;
}
size_t
number_removed
=
mutable_remote_description
(
)
-
>
RemoveCandidates
(
candidates
)
;
if
(
number_removed
!
=
candidates
.
size
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
RemoveIceCandidates
:
Failed
to
remove
candidates
.
Requested
"
<
<
candidates
.
size
(
)
<
<
"
but
only
"
<
<
number_removed
<
<
"
are
removed
.
"
;
}
RTCError
error
=
pc_
-
>
transport_controller_
-
>
RemoveRemoteCandidates
(
candidates
)
;
if
(
!
error
.
ok
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
RemoveIceCandidates
:
Error
when
removing
remote
candidates
:
"
<
<
error
.
message
(
)
;
}
return
true
;
}
void
SdpOfferAnswerHandler
:
:
AddLocalIceCandidate
(
const
JsepIceCandidate
*
candidate
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
local_description
(
)
)
{
mutable_local_description
(
)
-
>
AddCandidate
(
candidate
)
;
}
}
void
SdpOfferAnswerHandler
:
:
RemoveLocalIceCandidates
(
const
std
:
:
vector
<
cricket
:
:
Candidate
>
&
candidates
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
local_description
(
)
)
{
mutable_local_description
(
)
-
>
RemoveCandidates
(
candidates
)
;
}
}
const
SessionDescriptionInterface
*
SdpOfferAnswerHandler
:
:
local_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
pending_local_description_
?
pending_local_description_
.
get
(
)
:
current_local_description_
.
get
(
)
;
}
const
SessionDescriptionInterface
*
SdpOfferAnswerHandler
:
:
remote_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
pending_remote_description_
?
pending_remote_description_
.
get
(
)
:
current_remote_description_
.
get
(
)
;
}
const
SessionDescriptionInterface
*
SdpOfferAnswerHandler
:
:
current_local_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
current_local_description_
.
get
(
)
;
}
const
SessionDescriptionInterface
*
SdpOfferAnswerHandler
:
:
current_remote_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
current_remote_description_
.
get
(
)
;
}
const
SessionDescriptionInterface
*
SdpOfferAnswerHandler
:
:
pending_local_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
pending_local_description_
.
get
(
)
;
}
const
SessionDescriptionInterface
*
SdpOfferAnswerHandler
:
:
pending_remote_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
pending_remote_description_
.
get
(
)
;
}
PeerConnectionInterface
:
:
SignalingState
SdpOfferAnswerHandler
:
:
signaling_state
(
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
signaling_state_
;
}
void
SdpOfferAnswerHandler
:
:
ChangeSignalingState
(
PeerConnectionInterface
:
:
SignalingState
signaling_state
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
signaling_state_
=
=
signaling_state
)
{
return
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
Session
:
"
<
<
pc_
-
>
session_id
(
)
<
<
"
Old
state
:
"
<
<
GetSignalingStateString
(
signaling_state_
)
<
<
"
New
state
:
"
<
<
GetSignalingStateString
(
signaling_state
)
;
signaling_state_
=
signaling_state
;
pc_
-
>
Observer
(
)
-
>
OnSignalingChange
(
signaling_state_
)
;
}
RTCError
SdpOfferAnswerHandler
:
:
UpdateSessionState
(
SdpType
type
cricket
:
:
ContentSource
source
const
cricket
:
:
SessionDescription
*
description
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
pc_
-
>
session_error
(
)
=
=
PeerConnection
:
:
SessionError
:
:
kNone
)
;
if
(
type
=
=
SdpType
:
:
kPrAnswer
|
|
type
=
=
SdpType
:
:
kAnswer
)
{
pc_
-
>
EnableSending
(
)
;
}
if
(
type
=
=
SdpType
:
:
kOffer
)
{
ChangeSignalingState
(
source
=
=
cricket
:
:
CS_LOCAL
?
PeerConnectionInterface
:
:
kHaveLocalOffer
:
PeerConnectionInterface
:
:
kHaveRemoteOffer
)
;
}
else
if
(
type
=
=
SdpType
:
:
kPrAnswer
)
{
ChangeSignalingState
(
source
=
=
cricket
:
:
CS_LOCAL
?
PeerConnectionInterface
:
:
kHaveLocalPrAnswer
:
PeerConnectionInterface
:
:
kHaveRemotePrAnswer
)
;
}
else
{
RTC_DCHECK_RUN_ON
(
pc_
-
>
signaling_thread
(
)
)
;
RTC_DCHECK
(
type
=
=
SdpType
:
:
kAnswer
)
;
ChangeSignalingState
(
PeerConnectionInterface
:
:
kStable
)
;
pc_
-
>
transceivers_
.
DiscardStableStates
(
)
;
pc_
-
>
have_pending_rtp_data_channel_
=
false
;
}
RTCError
error
=
pc_
-
>
PushdownMediaDescription
(
type
source
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
return
RTCError
:
:
OK
(
)
;
}
bool
SdpOfferAnswerHandler
:
:
ShouldFireNegotiationNeededEvent
(
uint32_t
event_id
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
!
IsUnifiedPlan
(
)
)
{
return
true
;
}
if
(
event_id
!
=
negotiation_needed_event_id_
)
{
return
false
;
}
if
(
!
operations_chain_
-
>
IsEmpty
(
)
)
{
is_negotiation_needed_
=
false
;
update_negotiation_needed_on_empty_chain_
=
true
;
return
false
;
}
if
(
signaling_state_
!
=
PeerConnectionInterface
:
:
kStable
)
{
return
false
;
}
return
true
;
}
RTCError
SdpOfferAnswerHandler
:
:
Rollback
(
SdpType
desc_type
)
{
auto
state
=
signaling_state
(
)
;
if
(
state
!
=
PeerConnectionInterface
:
:
kHaveLocalOffer
&
&
state
!
=
PeerConnectionInterface
:
:
kHaveRemoteOffer
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_STATE
"
Called
in
wrong
signalingState
:
"
+
GetSignalingStateString
(
signaling_state
(
)
)
)
;
}
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
IsUnifiedPlan
(
)
)
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
all_added_streams
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
all_removed_streams
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpReceiverInterface
>
>
removed_receivers
;
for
(
auto
&
&
transceivers_stable_state_pair
:
pc_
-
>
transceivers_
.
StableStates
(
)
)
{
auto
transceiver
=
transceivers_stable_state_pair
.
first
;
auto
state
=
transceivers_stable_state_pair
.
second
;
if
(
state
.
remote_stream_ids
(
)
)
{
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
added_streams
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
removed_streams
;
SetAssociatedRemoteStreams
(
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
state
.
remote_stream_ids
(
)
.
value
(
)
&
added_streams
&
removed_streams
)
;
all_added_streams
.
insert
(
all_added_streams
.
end
(
)
added_streams
.
begin
(
)
added_streams
.
end
(
)
)
;
all_removed_streams
.
insert
(
all_removed_streams
.
end
(
)
removed_streams
.
begin
(
)
removed_streams
.
end
(
)
)
;
if
(
!
state
.
has_m_section
(
)
&
&
!
state
.
newly_created
(
)
)
{
continue
;
}
}
RTC_DCHECK
(
transceiver
-
>
internal
(
)
-
>
mid
(
)
.
has_value
(
)
)
;
pc_
-
>
DestroyTransceiverChannel
(
transceiver
)
;
if
(
signaling_state
(
)
=
=
PeerConnectionInterface
:
:
kHaveRemoteOffer
&
&
transceiver
-
>
receiver
(
)
)
{
removed_receivers
.
push_back
(
transceiver
-
>
receiver
(
)
)
;
}
if
(
state
.
newly_created
(
)
)
{
if
(
transceiver
-
>
internal
(
)
-
>
reused_for_addtrack
(
)
)
{
transceiver
-
>
internal
(
)
-
>
set_created_by_addtrack
(
true
)
;
}
else
{
pc_
-
>
transceivers_
.
Remove
(
transceiver
)
;
}
}
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
-
>
set_transport
(
nullptr
)
;
transceiver
-
>
internal
(
)
-
>
receiver_internal
(
)
-
>
set_transport
(
nullptr
)
;
transceiver
-
>
internal
(
)
-
>
set_mid
(
state
.
mid
(
)
)
;
transceiver
-
>
internal
(
)
-
>
set_mline_index
(
state
.
mline_index
(
)
)
;
}
pc_
-
>
transport_controller_
-
>
RollbackTransports
(
)
;
{
RTC_DCHECK_RUN_ON
(
pc_
-
>
signaling_thread
(
)
)
;
if
(
pc_
-
>
have_pending_rtp_data_channel_
)
{
pc_
-
>
DestroyDataChannelTransport
(
)
;
pc_
-
>
have_pending_rtp_data_channel_
=
false
;
}
pc_
-
>
transceivers_
.
DiscardStableStates
(
)
;
}
pending_local_description_
.
reset
(
)
;
pending_remote_description_
.
reset
(
)
;
ChangeSignalingState
(
PeerConnectionInterface
:
:
kStable
)
;
for
(
const
auto
&
receiver
:
removed_receivers
)
{
pc_
-
>
Observer
(
)
-
>
OnRemoveTrack
(
receiver
)
;
}
for
(
const
auto
&
stream
:
all_added_streams
)
{
pc_
-
>
Observer
(
)
-
>
OnAddStream
(
stream
)
;
}
for
(
const
auto
&
stream
:
all_removed_streams
)
{
pc_
-
>
Observer
(
)
-
>
OnRemoveStream
(
stream
)
;
}
if
(
desc_type
=
=
SdpType
:
:
kRollback
)
{
UpdateNegotiationNeeded
(
)
;
if
(
is_negotiation_needed_
)
{
pc_
-
>
Observer
(
)
-
>
OnRenegotiationNeeded
(
)
;
GenerateNegotiationNeededEvent
(
)
;
}
}
return
RTCError
:
:
OK
(
)
;
}
bool
SdpOfferAnswerHandler
:
:
IsUnifiedPlan
(
)
const
{
RTC_DCHECK_RUN_ON
(
pc_
-
>
signaling_thread
(
)
)
;
return
pc_
-
>
IsUnifiedPlan
(
)
;
}
void
SdpOfferAnswerHandler
:
:
OnOperationsChainEmpty
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
pc_
-
>
IsClosed
(
)
|
|
!
update_negotiation_needed_on_empty_chain_
)
return
;
update_negotiation_needed_on_empty_chain_
=
false
;
if
(
IsUnifiedPlan
(
)
)
{
UpdateNegotiationNeeded
(
)
;
}
}
absl
:
:
optional
<
bool
>
SdpOfferAnswerHandler
:
:
is_caller
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
is_caller_
;
}
bool
SdpOfferAnswerHandler
:
:
HasNewIceCredentials
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
local_ice_credentials_to_replace_
-
>
HasIceCredentials
(
)
;
}
bool
SdpOfferAnswerHandler
:
:
IceRestartPending
(
const
std
:
:
string
&
content_name
)
const
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
return
pending_ice_restarts_
.
find
(
content_name
)
!
=
pending_ice_restarts_
.
end
(
)
;
}
void
SdpOfferAnswerHandler
:
:
UpdateNegotiationNeeded
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
!
IsUnifiedPlan
(
)
)
{
pc_
-
>
Observer
(
)
-
>
OnRenegotiationNeeded
(
)
;
GenerateNegotiationNeededEvent
(
)
;
return
;
}
if
(
pc_
-
>
IsClosed
(
)
)
return
;
if
(
signaling_state
(
)
!
=
PeerConnectionInterface
:
:
kStable
)
return
;
bool
is_negotiation_needed
=
CheckIfNegotiationIsNeeded
(
)
;
if
(
!
is_negotiation_needed
)
{
is_negotiation_needed_
=
false
;
+
+
negotiation_needed_event_id_
;
return
;
}
if
(
is_negotiation_needed_
)
return
;
is_negotiation_needed_
=
true
;
pc_
-
>
Observer
(
)
-
>
OnRenegotiationNeeded
(
)
;
GenerateNegotiationNeededEvent
(
)
;
}
bool
SdpOfferAnswerHandler
:
:
CheckIfNegotiationIsNeeded
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
if
(
local_ice_credentials_to_replace_
-
>
HasIceCredentials
(
)
)
{
return
true
;
}
const
SessionDescriptionInterface
*
description
=
current_local_description
(
)
;
if
(
!
description
)
return
true
;
if
(
pc_
-
>
data_channel_controller
(
)
-
>
HasSctpDataChannels
(
)
)
{
if
(
!
cricket
:
:
GetFirstDataContent
(
description
-
>
description
(
)
-
>
contents
(
)
)
)
return
true
;
}
for
(
const
auto
&
transceiver
:
pc_
-
>
transceivers_
.
List
(
)
)
{
const
ContentInfo
*
current_local_msection
=
FindTransceiverMSection
(
transceiver
.
get
(
)
description
)
;
const
ContentInfo
*
current_remote_msection
=
FindTransceiverMSection
(
transceiver
.
get
(
)
current_remote_description
(
)
)
;
if
(
transceiver
-
>
stopped
(
)
)
{
RTC_DCHECK
(
transceiver
-
>
stopping
(
)
)
;
if
(
current_local_msection
&
&
!
current_local_msection
-
>
rejected
&
&
(
(
current_remote_msection
&
&
!
current_remote_msection
-
>
rejected
)
|
|
!
current_remote_msection
)
)
{
return
true
;
}
continue
;
}
if
(
transceiver
-
>
stopping
(
)
&
&
!
transceiver
-
>
stopped
(
)
)
return
true
;
if
(
!
current_local_msection
)
return
true
;
const
MediaContentDescription
*
current_local_media_description
=
current_local_msection
-
>
media_description
(
)
;
if
(
RtpTransceiverDirectionHasSend
(
transceiver
-
>
direction
(
)
)
)
{
if
(
current_local_media_description
-
>
streams
(
)
.
size
(
)
=
=
0
)
return
true
;
std
:
:
vector
<
std
:
:
string
>
msection_msids
;
for
(
const
auto
&
stream
:
current_local_media_description
-
>
streams
(
)
)
{
for
(
const
std
:
:
string
&
msid
:
stream
.
stream_ids
(
)
)
msection_msids
.
push_back
(
msid
)
;
}
std
:
:
vector
<
std
:
:
string
>
transceiver_msids
=
transceiver
-
>
sender
(
)
-
>
stream_ids
(
)
;
if
(
msection_msids
.
size
(
)
!
=
transceiver_msids
.
size
(
)
)
return
true
;
absl
:
:
c_sort
(
transceiver_msids
)
;
absl
:
:
c_sort
(
msection_msids
)
;
if
(
transceiver_msids
!
=
msection_msids
)
return
true
;
}
if
(
description
-
>
GetType
(
)
=
=
SdpType
:
:
kOffer
)
{
if
(
!
current_remote_description
(
)
)
return
true
;
if
(
!
current_remote_msection
)
return
true
;
RtpTransceiverDirection
current_local_direction
=
current_local_media_description
-
>
direction
(
)
;
RtpTransceiverDirection
current_remote_direction
=
current_remote_msection
-
>
media_description
(
)
-
>
direction
(
)
;
if
(
transceiver
-
>
direction
(
)
!
=
current_local_direction
&
&
transceiver
-
>
direction
(
)
!
=
RtpTransceiverDirectionReversed
(
current_remote_direction
)
)
{
return
true
;
}
}
if
(
description
-
>
GetType
(
)
=
=
SdpType
:
:
kAnswer
)
{
if
(
!
remote_description
(
)
)
return
true
;
const
ContentInfo
*
offered_remote_msection
=
FindTransceiverMSection
(
transceiver
.
get
(
)
remote_description
(
)
)
;
RtpTransceiverDirection
offered_direction
=
offered_remote_msection
?
offered_remote_msection
-
>
media_description
(
)
-
>
direction
(
)
:
RtpTransceiverDirection
:
:
kInactive
;
if
(
current_local_media_description
-
>
direction
(
)
!
=
(
RtpTransceiverDirectionIntersection
(
transceiver
-
>
direction
(
)
RtpTransceiverDirectionReversed
(
offered_direction
)
)
)
)
{
return
true
;
}
}
}
return
false
;
}
void
SdpOfferAnswerHandler
:
:
GenerateNegotiationNeededEvent
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
+
+
negotiation_needed_event_id_
;
pc_
-
>
Observer
(
)
-
>
OnNegotiationNeededEvent
(
negotiation_needed_event_id_
)
;
}
RTCError
SdpOfferAnswerHandler
:
:
ValidateSessionDescription
(
const
SessionDescriptionInterface
*
sdesc
cricket
:
:
ContentSource
source
)
{
if
(
pc_
-
>
session_error
(
)
!
=
PeerConnection
:
:
SessionError
:
:
kNone
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INTERNAL_ERROR
pc_
-
>
GetSessionErrorMsg
(
)
)
;
}
if
(
!
sdesc
|
|
!
sdesc
-
>
description
(
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kInvalidSdp
)
;
}
SdpType
type
=
sdesc
-
>
GetType
(
)
;
if
(
(
source
=
=
cricket
:
:
CS_LOCAL
&
&
!
pc_
-
>
ExpectSetLocalDescription
(
type
)
)
|
|
(
source
=
=
cricket
:
:
CS_REMOTE
&
&
!
pc_
-
>
ExpectSetRemoteDescription
(
type
)
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_STATE
"
Called
in
wrong
state
:
"
+
GetSignalingStateString
(
signaling_state
(
)
)
)
;
}
RTCError
error
=
ValidateMids
(
*
sdesc
-
>
description
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
std
:
:
string
crypto_error
;
if
(
webrtc_session_desc_factory_
-
>
SdesPolicy
(
)
=
=
cricket
:
:
SEC_REQUIRED
|
|
pc_
-
>
dtls_enabled
(
)
)
{
RTCError
crypto_error
=
VerifyCrypto
(
sdesc
-
>
description
(
)
pc_
-
>
dtls_enabled
(
)
)
;
if
(
!
crypto_error
.
ok
(
)
)
{
return
crypto_error
;
}
}
if
(
!
VerifyIceUfragPwdPresent
(
sdesc
-
>
description
(
)
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kSdpWithoutIceUfragPwd
)
;
}
if
(
!
pc_
-
>
ValidateBundleSettings
(
sdesc
-
>
description
(
)
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kBundleWithoutRtcpMux
)
;
}
if
(
type
=
=
SdpType
:
:
kPrAnswer
|
|
type
=
=
SdpType
:
:
kAnswer
)
{
const
cricket
:
:
SessionDescription
*
offer_desc
=
(
source
=
=
cricket
:
:
CS_LOCAL
)
?
remote_description
(
)
-
>
description
(
)
:
local_description
(
)
-
>
description
(
)
;
if
(
!
MediaSectionsHaveSameCount
(
*
offer_desc
*
sdesc
-
>
description
(
)
)
|
|
!
MediaSectionsInSameOrder
(
*
offer_desc
nullptr
*
sdesc
-
>
description
(
)
type
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kMlineMismatchInAnswer
)
;
}
}
else
{
const
cricket
:
:
SessionDescription
*
current_desc
=
nullptr
;
const
cricket
:
:
SessionDescription
*
secondary_current_desc
=
nullptr
;
if
(
local_description
(
)
)
{
current_desc
=
local_description
(
)
-
>
description
(
)
;
if
(
remote_description
(
)
)
{
secondary_current_desc
=
remote_description
(
)
-
>
description
(
)
;
}
}
else
if
(
remote_description
(
)
)
{
current_desc
=
remote_description
(
)
-
>
description
(
)
;
}
if
(
current_desc
&
&
!
MediaSectionsInSameOrder
(
*
current_desc
secondary_current_desc
*
sdesc
-
>
description
(
)
type
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
kMlineMismatchInSubsequentOffer
)
;
}
}
if
(
IsUnifiedPlan
(
)
)
{
for
(
const
ContentInfo
&
content
:
sdesc
-
>
description
(
)
-
>
contents
(
)
)
{
const
MediaContentDescription
&
desc
=
*
content
.
media_description
(
)
;
if
(
(
desc
.
type
(
)
=
=
cricket
:
:
MEDIA_TYPE_AUDIO
|
|
desc
.
type
(
)
=
=
cricket
:
:
MEDIA_TYPE_VIDEO
)
&
&
desc
.
streams
(
)
.
size
(
)
>
1u
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
Media
section
has
more
than
one
track
specified
"
"
with
a
=
ssrc
lines
which
is
not
supported
with
"
"
Unified
Plan
.
"
)
;
}
}
}
return
RTCError
:
:
OK
(
)
;
}
RTCError
SdpOfferAnswerHandler
:
:
UpdateTransceiversAndDataChannels
(
cricket
:
:
ContentSource
source
const
SessionDescriptionInterface
&
new_session
const
SessionDescriptionInterface
*
old_local_description
const
SessionDescriptionInterface
*
old_remote_description
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread
(
)
)
;
RTC_DCHECK
(
IsUnifiedPlan
(
)
)
;
const
cricket
:
:
ContentGroup
*
bundle_group
=
nullptr
;
if
(
new_session
.
GetType
(
)
=
=
SdpType
:
:
kOffer
)
{
auto
bundle_group_or_error
=
GetEarlyBundleGroup
(
*
new_session
.
description
(
)
)
;
if
(
!
bundle_group_or_error
.
ok
(
)
)
{
return
bundle_group_or_error
.
MoveError
(
)
;
}
bundle_group
=
bundle_group_or_error
.
MoveValue
(
)
;
}
const
ContentInfos
&
new_contents
=
new_session
.
description
(
)
-
>
contents
(
)
;
for
(
size_t
i
=
0
;
i
<
new_contents
.
size
(
)
;
+
+
i
)
{
const
cricket
:
:
ContentInfo
&
new_content
=
new_contents
[
i
]
;
cricket
:
:
MediaType
media_type
=
new_content
.
media_description
(
)
-
>
type
(
)
;
pc_
-
>
mid_generator
(
)
-
>
AddKnownId
(
new_content
.
name
)
;
if
(
media_type
=
=
cricket
:
:
MEDIA_TYPE_AUDIO
|
|
media_type
=
=
cricket
:
:
MEDIA_TYPE_VIDEO
)
{
const
cricket
:
:
ContentInfo
*
old_local_content
=
nullptr
;
if
(
old_local_description
&
&
i
<
old_local_description
-
>
description
(
)
-
>
contents
(
)
.
size
(
)
)
{
old_local_content
=
&
old_local_description
-
>
description
(
)
-
>
contents
(
)
[
i
]
;
}
const
cricket
:
:
ContentInfo
*
old_remote_content
=
nullptr
;
if
(
old_remote_description
&
&
i
<
old_remote_description
-
>
description
(
)
-
>
contents
(
)
.
size
(
)
)
{
old_remote_content
=
&
old_remote_description
-
>
description
(
)
-
>
contents
(
)
[
i
]
;
}
if
(
old_local_content
&
&
old_local_content
-
>
rejected
&
&
old_remote_content
&
&
old_remote_content
-
>
rejected
&
&
new_content
.
rejected
)
{
continue
;
}
auto
transceiver_or_error
=
AssociateTransceiver
(
source
new_session
.
GetType
(
)
i
new_content
old_local_content
old_remote_content
)
;
if
(
!
transceiver_or_error
.
ok
(
)
)
{
return
transceiver_or_error
.
MoveError
(
)
;
}
auto
transceiver
=
transceiver_or_error
.
MoveValue
(
)
;
RTCError
error
=
UpdateTransceiverChannel
(
transceiver
new_content
bundle_group
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
}
else
if
(
media_type
=
=
cricket
:
:
MEDIA_TYPE_DATA
)
{
if
(
pc_
-
>
GetDataMid
(
)
&
&
new_content
.
name
!
=
*
(
pc_
-
>
GetDataMid
(
)
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Ignoring
data
media
section
with
MID
=
"
<
<
new_content
.
name
;
continue
;
}
RTCError
error
=
UpdateDataChannel
(
source
new_content
bundle_group
)
;
if
(
!
error
.
ok
(
)
)
{
return
error
;
}
}
else
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INTERNAL_ERROR
"
Unknown
section
type
.
"
)
;
}
}
return
RTCError
:
:
OK
(
)
;
}
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
RtpTransceiverProxyWithInternal
<
RtpTransceiver
>
>
>
SdpOfferAnswerHandler
:
:
AssociateTransceiver
(
cricket
:
:
ContentSource
source
SdpType
type
size_t
mline_index
const
ContentInfo
&
content
const
ContentInfo
*
old_local_content
const
ContentInfo
*
old_remote_content
)
{
RTC_DCHECK
(
IsUnifiedPlan
(
)
)
;
if
(
IsMediaSectionBeingRecycled
(
type
content
old_local_content
old_remote_content
)
)
{
const
std
:
:
string
&
old_mid
=
(
old_local_content
&
&
old_local_content
-
>
rejected
)
?
old_local_content
-
>
name
:
old_remote_content
-
>
name
;
auto
old_transceiver
=
pc_
-
>
GetAssociatedTransceiver
(
old_mid
)
;
RTC_DCHECK
(
!
old_transceiver
)
;
}
const
MediaContentDescription
*
media_desc
=
content
.
media_description
(
)
;
auto
transceiver
=
pc_
-
>
GetAssociatedTransceiver
(
content
.
name
)
;
if
(
source
=
=
cricket
:
:
CS_LOCAL
)
{
if
(
!
transceiver
)
{
transceiver
=
pc_
-
>
GetTransceiverByMLineIndex
(
mline_index
)
;
}
if
(
!
transceiver
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
Unknown
transceiver
"
)
;
}
}
else
{
RTC_DCHECK_EQ
(
source
cricket
:
:
CS_REMOTE
)
;
if
(
!
transceiver
&
&
RtpTransceiverDirectionHasRecv
(
media_desc
-
>
direction
(
)
)
&
&
!
media_desc
-
>
HasSimulcast
(
)
)
{
transceiver
=
pc_
-
>
FindAvailableTransceiverToReceive
(
media_desc
-
>
type
(
)
)
;
}
if
(
!
transceiver
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Adding
"
<
<
cricket
:
:
MediaTypeToString
(
media_desc
-
>
type
(
)
)
<
<
"
transceiver
for
MID
=
"
<
<
content
.
name
<
<
"
at
i
=
"
<
<
mline_index
<
<
"
in
response
to
the
remote
description
.
"
;
std
:
:
string
sender_id
=
rtc
:
:
CreateRandomUuid
(
)
;
std
:
:
vector
<
RtpEncodingParameters
>
send_encodings
=
GetSendEncodingsFromRemoteDescription
(
*
media_desc
)
;
auto
sender
=
pc_
-
>
CreateSender
(
media_desc
-
>
type
(
)
sender_id
nullptr
{
}
send_encodings
)
;
std
:
:
string
receiver_id
;
if
(
!
media_desc
-
>
streams
(
)
.
empty
(
)
)
{
receiver_id
=
media_desc
-
>
streams
(
)
[
0
]
.
id
;
}
else
{
receiver_id
=
rtc
:
:
CreateRandomUuid
(
)
;
}
auto
receiver
=
pc_
-
>
CreateReceiver
(
media_desc
-
>
type
(
)
receiver_id
)
;
transceiver
=
pc_
-
>
CreateAndAddTransceiver
(
sender
receiver
)
;
transceiver
-
>
internal
(
)
-
>
set_direction
(
RtpTransceiverDirection
:
:
kRecvOnly
)
;
if
(
type
=
=
SdpType
:
:
kOffer
)
{
pc_
-
>
transceivers_
.
StableState
(
transceiver
)
-
>
set_newly_created
(
)
;
}
}
if
(
SimulcastIsRejected
(
old_local_content
*
media_desc
)
)
{
RTC_HISTOGRAM_BOOLEAN
(
kSimulcastDisabled
true
)
;
RTCError
error
=
DisableSimulcastInSender
(
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
remove
rejected
simulcast
.
"
;
return
std
:
:
move
(
error
)
;
}
}
}
RTC_DCHECK
(
transceiver
)
;
if
(
transceiver
-
>
media_type
(
)
!
=
media_desc
-
>
type
(
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
Transceiver
type
does
not
match
media
description
type
.
"
)
;
}
if
(
media_desc
-
>
HasSimulcast
(
)
)
{
std
:
:
vector
<
SimulcastLayer
>
layers
=
source
=
=
cricket
:
:
CS_LOCAL
?
media_desc
-
>
simulcast_description
(
)
.
send_layers
(
)
.
GetAllLayers
(
)
:
media_desc
-
>
simulcast_description
(
)
.
receive_layers
(
)
.
GetAllLayers
(
)
;
RTCError
error
=
UpdateSimulcastLayerStatusInSender
(
layers
transceiver
-
>
internal
(
)
-
>
sender_internal
(
)
)
;
if
(
!
error
.
ok
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
updating
status
for
simulcast
layers
.
"
;
return
std
:
:
move
(
error
)
;
}
}
if
(
type
=
=
SdpType
:
:
kOffer
)
{
bool
state_changes
=
transceiver
-
>
internal
(
)
-
>
mid
(
)
!
=
content
.
name
|
|
transceiver
-
>
internal
(
)
-
>
mline_index
(
)
!
=
mline_index
;
if
(
state_changes
)
{
pc_
-
>
transceivers_
.
StableState
(
transceiver
)
-
>
SetMSectionIfUnset
(
transceiver
-
>
internal
(
)
-
>
mid
(
)
transceiver
-
>
internal
(
)
-
>
mline_index
(
)
)
;
}
}
transceiver
-
>
internal
(
)
-
>
set_mid
(
content
.
name
)
;
transceiver
-
>
internal
(
)
-
>
set_mline_index
(
mline_index
)
;
return
std
:
:
move
(
transceiver
)
;
}
RTCErrorOr
<
const
cricket
:
:
ContentGroup
*
>
SdpOfferAnswerHandler
:
:
GetEarlyBundleGroup
(
const
SessionDescription
&
desc
)
const
{
const
cricket
:
:
ContentGroup
*
bundle_group
=
nullptr
;
if
(
pc_
-
>
configuration
(
)
-
>
bundle_policy
=
=
PeerConnectionInterface
:
:
kBundlePolicyMaxBundle
)
{
bundle_group
=
desc
.
GetGroupByName
(
cricket
:
:
GROUP_TYPE_BUNDLE
)
;
if
(
!
bundle_group
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
max
-
bundle
configured
but
session
description
"
"
has
no
BUNDLE
group
"
)
;
}
}
return
bundle_group
;
}
RTCError
SdpOfferAnswerHandler
:
:
UpdateTransceiverChannel
(
rtc
:
:
scoped_refptr
<
RtpTransceiverProxyWithInternal
<
RtpTransceiver
>
>
transceiver
const
cricket
:
:
ContentInfo
&
content
const
cricket
:
:
ContentGroup
*
bundle_group
)
{
RTC_DCHECK
(
IsUnifiedPlan
(
)
)
;
RTC_DCHECK
(
transceiver
)
;
cricket
:
:
ChannelInterface
*
channel
=
transceiver
-
>
internal
(
)
-
>
channel
(
)
;
if
(
content
.
rejected
)
{
if
(
channel
)
{
transceiver
-
>
internal
(
)
-
>
SetChannel
(
nullptr
)
;
pc_
-
>
DestroyChannelInterface
(
channel
)
;
}
}
else
{
if
(
!
channel
)
{
if
(
transceiver
-
>
media_type
(
)
=
=
cricket
:
:
MEDIA_TYPE_AUDIO
)
{
channel
=
pc_
-
>
CreateVoiceChannel
(
content
.
name
)
;
}
else
{
RTC_DCHECK_EQ
(
cricket
:
:
MEDIA_TYPE_VIDEO
transceiver
-
>
media_type
(
)
)
;
channel
=
pc_
-
>
CreateVideoChannel
(
content
.
name
)
;
}
if
(
!
channel
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INTERNAL_ERROR
"
Failed
to
create
channel
for
mid
=
"
+
content
.
name
)
;
}
transceiver
-
>
internal
(
)
-
>
SetChannel
(
channel
)
;
}
}
return
RTCError
:
:
OK
(
)
;
}
RTCError
SdpOfferAnswerHandler
:
:
UpdateDataChannel
(
cricket
:
:
ContentSource
source
const
cricket
:
:
ContentInfo
&
content
const
cricket
:
:
ContentGroup
*
bundle_group
)
{
if
(
pc_
-
>
data_channel_type
(
)
=
=
cricket
:
:
DCT_NONE
)
{
return
RTCError
:
:
OK
(
)
;
}
if
(
content
.
rejected
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Rejected
data
channel
mid
=
"
<
<
content
.
mid
(
)
;
pc_
-
>
DestroyDataChannelTransport
(
)
;
}
else
{
if
(
!
pc_
-
>
data_channel_controller_
.
rtp_data_channel
(
)
&
&
!
pc_
-
>
data_channel_controller_
.
data_channel_transport
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Creating
data
channel
mid
=
"
<
<
content
.
mid
(
)
;
if
(
!
pc_
-
>
CreateDataChannel
(
content
.
name
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INTERNAL_ERROR
"
Failed
to
create
data
channel
.
"
)
;
}
}
if
(
source
=
=
cricket
:
:
CS_REMOTE
)
{
const
MediaContentDescription
*
data_desc
=
content
.
media_description
(
)
;
if
(
data_desc
&
&
cricket
:
:
IsRtpProtocol
(
data_desc
-
>
protocol
(
)
)
)
{
pc_
-
>
data_channel_controller_
.
UpdateRemoteRtpDataChannels
(
GetActiveStreams
(
data_desc
)
)
;
}
}
}
return
RTCError
:
:
OK
(
)
;
}
}
