#
ifndef
PC_DTLS_TRANSPORT_H_
#
define
PC_DTLS_TRANSPORT_H_
#
include
<
memory
>
#
include
<
utility
>
#
include
"
api
/
dtls_transport_interface
.
h
"
#
include
"
api
/
ice_transport_interface
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
p2p
/
dtls
/
dtls_transport_internal
.
h
"
#
include
"
pc
/
ice_transport
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
IceTransportWithPointer
;
class
DtlsTransport
:
public
DtlsTransportInterface
{
public
:
explicit
DtlsTransport
(
std
:
:
unique_ptr
<
DtlsTransportInternal
>
internal
)
;
rtc
:
:
scoped_refptr
<
IceTransportInterface
>
ice_transport
(
)
override
;
DtlsTransportInformation
Information
(
)
override
;
void
RegisterObserver
(
DtlsTransportObserverInterface
*
observer
)
override
;
void
UnregisterObserver
(
)
override
;
void
Clear
(
)
;
DtlsTransportInternal
*
internal
(
)
{
RTC_DCHECK_RUN_ON
(
owner_thread_
)
;
return
internal_dtls_transport_
.
get
(
)
;
}
const
DtlsTransportInternal
*
internal
(
)
const
{
RTC_DCHECK_RUN_ON
(
owner_thread_
)
;
return
internal_dtls_transport_
.
get
(
)
;
}
protected
:
~
DtlsTransport
(
)
;
private
:
void
OnInternalDtlsState
(
DtlsTransportInternal
*
transport
DtlsTransportState
state
)
;
void
UpdateInformation
(
)
;
void
set_info
(
DtlsTransportInformation
&
&
info
)
RTC_RUN_ON
(
owner_thread_
)
{
MutexLock
lock
(
&
lock_
)
;
info_
=
std
:
:
move
(
info
)
;
}
DtlsTransportObserverInterface
*
observer_
=
nullptr
;
Thread
*
owner_thread_
;
mutable
Mutex
lock_
;
DtlsTransportInformation
info_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
unique_ptr
<
DtlsTransportInternal
>
internal_dtls_transport_
RTC_GUARDED_BY
(
owner_thread_
)
;
const
rtc
:
:
scoped_refptr
<
IceTransportWithPointer
>
ice_transport_
;
}
;
}
#
endif
