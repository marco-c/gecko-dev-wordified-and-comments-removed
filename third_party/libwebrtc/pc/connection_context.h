#
ifndef
PC_CONNECTION_CONTEXT_H_
#
define
PC_CONNECTION_CONTEXT_H_
#
include
<
memory
>
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
packet_socket_factory
.
h
"
#
include
"
api
/
peer_connection_interface
.
h
"
#
include
"
api
/
ref_counted_base
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
transport
/
sctp_transport_factory_interface
.
h
"
#
include
"
media
/
base
/
media_engine
.
h
"
#
include
"
rtc_base
/
memory
/
always_valid_pointer
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network_monitor_factory
.
h
"
#
include
"
rtc_base
/
socket_factory
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
unique_id_generator
.
h
"
namespace
webrtc
{
class
ConnectionContext
final
:
public
RefCountedNonVirtual
<
ConnectionContext
>
{
public
:
static
rtc
:
:
scoped_refptr
<
ConnectionContext
>
Create
(
const
Environment
&
env
PeerConnectionFactoryDependencies
*
dependencies
)
;
ConnectionContext
(
const
ConnectionContext
&
)
=
delete
;
ConnectionContext
&
operator
=
(
const
ConnectionContext
&
)
=
delete
;
SctpTransportFactoryInterface
*
sctp_transport_factory
(
)
const
{
return
sctp_factory_
.
get
(
)
;
}
MediaEngineInterface
*
media_engine
(
)
const
{
return
media_engine_
.
get
(
)
;
}
Thread
*
signaling_thread
(
)
{
return
signaling_thread_
;
}
const
Thread
*
signaling_thread
(
)
const
{
return
signaling_thread_
;
}
Thread
*
worker_thread
(
)
{
return
worker_thread_
.
get
(
)
;
}
const
Thread
*
worker_thread
(
)
const
{
return
worker_thread_
.
get
(
)
;
}
Thread
*
network_thread
(
)
{
return
network_thread_
;
}
const
Thread
*
network_thread
(
)
const
{
return
network_thread_
;
}
const
Environment
&
env
(
)
const
{
return
env_
;
}
NetworkManager
*
default_network_manager
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
return
default_network_manager_
.
get
(
)
;
}
PacketSocketFactory
*
default_socket_factory
(
)
{
RTC_DCHECK_RUN_ON
(
signaling_thread_
)
;
return
default_socket_factory_
.
get
(
)
;
}
MediaFactory
*
call_factory
(
)
{
RTC_DCHECK_RUN_ON
(
worker_thread
(
)
)
;
return
call_factory_
.
get
(
)
;
}
UniqueRandomIdGenerator
*
ssrc_generator
(
)
{
return
&
ssrc_generator_
;
}
bool
use_rtx
(
)
{
return
use_rtx_
;
}
void
set_use_rtx
(
bool
use_rtx
)
{
use_rtx_
=
use_rtx
;
}
protected
:
ConnectionContext
(
const
Environment
&
env
PeerConnectionFactoryDependencies
*
dependencies
)
;
friend
class
RefCountedNonVirtual
<
ConnectionContext
>
;
~
ConnectionContext
(
)
;
private
:
bool
wraps_current_thread_
;
std
:
:
unique_ptr
<
SocketFactory
>
owned_socket_factory_
;
std
:
:
unique_ptr
<
Thread
>
owned_network_thread_
RTC_GUARDED_BY
(
signaling_thread_
)
;
Thread
*
const
network_thread_
;
AlwaysValidPointer
<
Thread
>
const
worker_thread_
;
Thread
*
const
signaling_thread_
;
const
Environment
env_
;
std
:
:
unique_ptr
<
MediaEngineInterface
>
media_engine_
;
UniqueRandomIdGenerator
ssrc_generator_
;
std
:
:
unique_ptr
<
NetworkMonitorFactory
>
const
network_monitor_factory_
RTC_GUARDED_BY
(
signaling_thread_
)
;
std
:
:
unique_ptr
<
NetworkManager
>
default_network_manager_
RTC_GUARDED_BY
(
signaling_thread_
)
;
std
:
:
unique_ptr
<
MediaFactory
>
const
call_factory_
RTC_GUARDED_BY
(
worker_thread
(
)
)
;
std
:
:
unique_ptr
<
PacketSocketFactory
>
default_socket_factory_
RTC_GUARDED_BY
(
signaling_thread_
)
;
std
:
:
unique_ptr
<
SctpTransportFactoryInterface
>
const
sctp_factory_
;
bool
use_rtx_
;
}
;
}
#
endif
