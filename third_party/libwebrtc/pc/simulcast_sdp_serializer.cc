#
include
"
pc
/
simulcast_sdp_serializer
.
h
"
#
include
<
algorithm
>
#
include
<
map
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
codec_comparators
.
h
"
#
include
"
media
/
base
/
rid_description
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
simulcast_description
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
string_encode
.
h
"
#
include
"
rtc_base
/
string_to_number
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
using
cricket
:
:
RidDescription
;
using
cricket
:
:
RidDirection
;
using
:
:
webrtc
:
:
SimulcastDescription
;
using
:
:
webrtc
:
:
SimulcastLayer
;
using
:
:
webrtc
:
:
SimulcastLayerList
;
namespace
webrtc
{
namespace
{
const
char
kDelimiterComma
[
]
=
"
"
;
const
char
kDelimiterCommaChar
=
'
'
;
const
char
kDelimiterEqual
[
]
=
"
=
"
;
const
char
kDelimiterEqualChar
=
'
=
'
;
const
char
kDelimiterSemicolon
[
]
=
"
;
"
;
const
char
kDelimiterSemicolonChar
=
'
;
'
;
const
char
kDelimiterSpace
[
]
=
"
"
;
const
char
kDelimiterSpaceChar
=
'
'
;
const
char
kSimulcastPausedStream
[
]
=
"
~
"
;
const
char
kSimulcastPausedStreamChar
=
'
~
'
;
const
char
kSendDirection
[
]
=
"
send
"
;
const
char
kReceiveDirection
[
]
=
"
recv
"
;
const
char
kPayloadType
[
]
=
"
pt
"
;
RTCError
ParseError
(
absl
:
:
string_view
message
)
{
return
RTCError
(
RTCErrorType
:
:
SYNTAX_ERROR
message
)
;
}
StringBuilder
&
operator
<
<
(
StringBuilder
&
builder
const
SimulcastLayer
&
simulcast_layer
)
{
if
(
simulcast_layer
.
is_paused
)
{
builder
<
<
kSimulcastPausedStream
;
}
builder
<
<
simulcast_layer
.
rid
;
return
builder
;
}
StringBuilder
&
operator
<
<
(
StringBuilder
&
builder
const
std
:
:
vector
<
SimulcastLayer
>
&
layer_alternatives
)
{
bool
first
=
true
;
for
(
const
SimulcastLayer
&
rid
:
layer_alternatives
)
{
if
(
!
first
)
{
builder
<
<
kDelimiterComma
;
}
builder
<
<
rid
;
first
=
false
;
}
return
builder
;
}
StringBuilder
&
operator
<
<
(
StringBuilder
&
builder
const
SimulcastLayerList
&
simulcast_layers
)
{
bool
first
=
true
;
for
(
const
auto
&
alternatives
:
simulcast_layers
)
{
if
(
!
first
)
{
builder
<
<
kDelimiterSemicolon
;
}
builder
<
<
alternatives
;
first
=
false
;
}
return
builder
;
}
RTCErrorOr
<
SimulcastLayerList
>
ParseSimulcastLayerList
(
const
std
:
:
string
&
str
)
{
std
:
:
vector
<
absl
:
:
string_view
>
tokens
=
split
(
str
kDelimiterSemicolonChar
)
;
if
(
tokens
.
empty
(
)
)
{
return
ParseError
(
"
Layer
list
cannot
be
empty
.
"
)
;
}
SimulcastLayerList
result
;
for
(
const
absl
:
:
string_view
&
token
:
tokens
)
{
if
(
token
.
empty
(
)
)
{
return
ParseError
(
"
Simulcast
alternative
layer
list
is
empty
.
"
)
;
}
std
:
:
vector
<
absl
:
:
string_view
>
rid_tokens
=
split
(
token
kDelimiterCommaChar
)
;
if
(
rid_tokens
.
empty
(
)
)
{
return
ParseError
(
"
Simulcast
alternative
layer
list
is
malformed
.
"
)
;
}
std
:
:
vector
<
SimulcastLayer
>
layers
;
for
(
const
absl
:
:
string_view
&
rid_token
:
rid_tokens
)
{
if
(
rid_token
.
empty
(
)
|
|
rid_token
=
=
kSimulcastPausedStream
)
{
return
ParseError
(
"
Rid
must
not
be
empty
.
"
)
;
}
bool
paused
=
rid_token
[
0
]
=
=
kSimulcastPausedStreamChar
;
absl
:
:
string_view
rid
=
paused
?
rid_token
.
substr
(
1
)
:
rid_token
;
layers
.
push_back
(
SimulcastLayer
(
rid
paused
)
)
;
}
result
.
AddLayerWithAlternatives
(
layers
)
;
}
return
std
:
:
move
(
result
)
;
}
webrtc
:
:
RTCError
ParseRidPayloadList
(
const
std
:
:
string
&
payload_list
RidDescription
*
rid_description
std
:
:
vector
<
int
>
*
rid_payload_types
)
{
RTC_DCHECK
(
rid_description
)
;
RTC_DCHECK
(
rid_payload_types
)
;
if
(
!
rid_payload_types
-
>
empty
(
)
)
{
return
ParseError
(
"
Multiple
pt
=
found
in
RID
Description
.
"
)
;
}
if
(
!
rid_description
-
>
restrictions
.
empty
(
)
)
{
return
ParseError
(
"
Payload
list
must
appear
first
in
the
restrictions
.
"
)
;
}
if
(
payload_list
.
empty
(
)
)
{
return
ParseError
(
"
Payload
list
must
have
at
least
one
value
.
"
)
;
}
std
:
:
vector
<
std
:
:
string
>
string_payloads
;
tokenize
(
payload_list
kDelimiterCommaChar
&
string_payloads
)
;
if
(
string_payloads
.
empty
(
)
)
{
return
ParseError
(
"
Payload
list
must
have
at
least
one
value
.
"
)
;
}
for
(
const
std
:
:
string
&
payload_type
:
string_payloads
)
{
std
:
:
optional
<
int
>
value
=
StringToNumber
<
int
>
(
payload_type
)
;
if
(
!
value
.
has_value
(
)
)
{
return
ParseError
(
"
Invalid
payload
type
:
"
+
payload_type
)
;
}
if
(
absl
:
:
c_linear_search
(
*
rid_payload_types
value
.
value
(
)
)
)
{
return
ParseError
(
"
Duplicate
payload
type
in
list
:
"
+
payload_type
)
;
}
rid_payload_types
-
>
push_back
(
value
.
value
(
)
)
;
}
return
RTCError
:
:
OK
(
)
;
}
}
std
:
:
string
SimulcastSdpSerializer
:
:
SerializeSimulcastDescription
(
const
SimulcastDescription
&
simulcast
)
const
{
StringBuilder
sb
;
std
:
:
string
delimiter
;
if
(
!
simulcast
.
send_layers
(
)
.
empty
(
)
)
{
sb
<
<
kSendDirection
<
<
kDelimiterSpace
<
<
simulcast
.
send_layers
(
)
;
delimiter
=
kDelimiterSpace
;
}
if
(
!
simulcast
.
receive_layers
(
)
.
empty
(
)
)
{
sb
<
<
delimiter
<
<
kReceiveDirection
<
<
kDelimiterSpace
<
<
simulcast
.
receive_layers
(
)
;
}
return
sb
.
Release
(
)
;
}
RTCErrorOr
<
SimulcastDescription
>
SimulcastSdpSerializer
:
:
DeserializeSimulcastDescription
(
absl
:
:
string_view
string
)
const
{
std
:
:
vector
<
std
:
:
string
>
tokens
;
tokenize
(
std
:
:
string
(
string
)
kDelimiterSpaceChar
&
tokens
)
;
if
(
tokens
.
size
(
)
!
=
2
&
&
tokens
.
size
(
)
!
=
4
)
{
return
ParseError
(
"
Must
have
one
or
two
<
direction
streams
>
pairs
.
"
)
;
}
bool
bidirectional
=
tokens
.
size
(
)
=
=
4
;
if
(
(
tokens
[
0
]
!
=
kSendDirection
&
&
tokens
[
0
]
!
=
kReceiveDirection
)
|
|
(
bidirectional
&
&
tokens
[
2
]
!
=
kSendDirection
&
&
tokens
[
2
]
!
=
kReceiveDirection
)
|
|
(
bidirectional
&
&
tokens
[
0
]
=
=
tokens
[
2
]
)
)
{
return
ParseError
(
"
Valid
values
:
send
/
recv
.
"
)
;
}
RTCErrorOr
<
SimulcastLayerList
>
list1
list2
;
list1
=
ParseSimulcastLayerList
(
tokens
[
1
]
)
;
if
(
!
list1
.
ok
(
)
)
{
return
list1
.
MoveError
(
)
;
}
if
(
bidirectional
)
{
list2
=
ParseSimulcastLayerList
(
tokens
[
3
]
)
;
if
(
!
list2
.
ok
(
)
)
{
return
list2
.
MoveError
(
)
;
}
}
if
(
tokens
[
0
]
!
=
kSendDirection
)
{
std
:
:
swap
(
list1
list2
)
;
}
SimulcastDescription
simulcast
;
if
(
list1
.
ok
(
)
)
{
simulcast
.
send_layers
(
)
=
list1
.
MoveValue
(
)
;
}
if
(
list2
.
ok
(
)
)
{
simulcast
.
receive_layers
(
)
=
list2
.
MoveValue
(
)
;
}
return
std
:
:
move
(
simulcast
)
;
}
std
:
:
string
SimulcastSdpSerializer
:
:
SerializeRidDescription
(
const
MediaContentDescription
&
media_desc
const
RidDescription
&
rid_description
)
const
{
RTC_DCHECK
(
!
rid_description
.
rid
.
empty
(
)
)
;
RTC_DCHECK
(
rid_description
.
direction
=
=
RidDirection
:
:
kSend
|
|
rid_description
.
direction
=
=
RidDirection
:
:
kReceive
)
;
StringBuilder
builder
;
builder
<
<
rid_description
.
rid
<
<
kDelimiterSpace
<
<
(
rid_description
.
direction
=
=
RidDirection
:
:
kSend
?
kSendDirection
:
kReceiveDirection
)
;
std
:
:
vector
<
int
>
payload_types
;
for
(
const
Codec
&
codec
:
rid_description
.
codecs
)
{
RtpCodec
rtp_codec
=
codec
.
ToCodecParameters
(
)
;
const
auto
it
=
std
:
:
find_if
(
media_desc
.
codecs
(
)
.
begin
(
)
media_desc
.
codecs
(
)
.
end
(
)
[
&
rtp_codec
]
(
const
Codec
&
m_section_codec
)
{
return
IsSameRtpCodecIgnoringLevel
(
m_section_codec
rtp_codec
)
;
}
)
;
if
(
it
=
=
media_desc
.
codecs
(
)
.
end
(
)
)
{
break
;
}
if
(
it
-
>
id
=
=
Codec
:
:
kIdNotSet
)
{
RTC_DCHECK_NOTREACHED
(
)
;
break
;
}
payload_types
.
push_back
(
it
-
>
id
)
;
}
const
auto
&
restrictions
=
rid_description
.
restrictions
;
const
char
*
propertyDelimiter
=
kDelimiterSpace
;
if
(
!
payload_types
.
empty
(
)
)
{
builder
<
<
propertyDelimiter
<
<
kPayloadType
<
<
kDelimiterEqual
;
propertyDelimiter
=
kDelimiterSemicolon
;
const
char
*
formatDelimiter
=
"
"
;
for
(
int
payload_type
:
payload_types
)
{
builder
<
<
formatDelimiter
<
<
payload_type
;
formatDelimiter
=
kDelimiterComma
;
}
}
for
(
const
auto
&
pair
:
restrictions
)
{
builder
<
<
propertyDelimiter
<
<
pair
.
first
;
if
(
!
pair
.
second
.
empty
(
)
)
{
builder
<
<
kDelimiterEqual
<
<
pair
.
second
;
}
propertyDelimiter
=
kDelimiterSemicolon
;
}
return
builder
.
Release
(
)
;
}
RTCErrorOr
<
RidDescription
>
SimulcastSdpSerializer
:
:
DeserializeRidDescription
(
const
MediaContentDescription
&
media_desc
absl
:
:
string_view
string
)
const
{
std
:
:
vector
<
std
:
:
string
>
tokens
;
tokenize
(
std
:
:
string
(
string
)
kDelimiterSpaceChar
&
tokens
)
;
if
(
tokens
.
size
(
)
<
2
)
{
return
ParseError
(
"
RID
Description
must
contain
<
RID
>
<
direction
>
.
"
)
;
}
if
(
tokens
.
size
(
)
>
3
)
{
return
ParseError
(
"
Invalid
RID
Description
format
.
Too
many
arguments
.
"
)
;
}
if
(
!
IsLegalRsidName
(
tokens
[
0
]
)
)
{
return
ParseError
(
"
Invalid
RID
value
:
"
+
tokens
[
0
]
+
"
.
"
)
;
}
if
(
tokens
[
1
]
!
=
kSendDirection
&
&
tokens
[
1
]
!
=
kReceiveDirection
)
{
return
ParseError
(
"
Invalid
RID
direction
.
Supported
values
:
send
/
recv
.
"
)
;
}
RidDirection
direction
=
tokens
[
1
]
=
=
kSendDirection
?
RidDirection
:
:
kSend
:
RidDirection
:
:
kReceive
;
RidDescription
rid_description
(
tokens
[
0
]
direction
)
;
std
:
:
vector
<
int
>
rid_payload_types
;
if
(
tokens
.
size
(
)
=
=
3
)
{
std
:
:
vector
<
std
:
:
string
>
restrictions
;
tokenize
(
tokens
[
2
]
kDelimiterSemicolonChar
&
restrictions
)
;
if
(
restrictions
.
empty
(
)
)
{
return
ParseError
(
"
Invalid
RID
restriction
list
:
"
+
tokens
[
2
]
)
;
}
for
(
const
std
:
:
string
&
restriction
:
restrictions
)
{
std
:
:
vector
<
std
:
:
string
>
parts
;
tokenize
(
restriction
kDelimiterEqualChar
&
parts
)
;
if
(
parts
.
empty
(
)
|
|
parts
.
size
(
)
>
2
)
{
return
ParseError
(
"
Invalid
format
for
restriction
:
"
+
restriction
)
;
}
if
(
parts
[
0
]
=
=
kPayloadType
)
{
RTCError
error
=
ParseRidPayloadList
(
parts
.
size
(
)
>
1
?
parts
[
1
]
:
std
:
:
string
(
)
&
rid_description
&
rid_payload_types
)
;
if
(
!
error
.
ok
(
)
)
{
return
std
:
:
move
(
error
)
;
}
continue
;
}
if
(
rid_description
.
restrictions
.
find
(
parts
[
0
]
)
!
=
rid_description
.
restrictions
.
end
(
)
)
{
return
ParseError
(
"
Duplicate
restriction
specified
:
"
+
parts
[
0
]
)
;
}
rid_description
.
restrictions
[
parts
[
0
]
]
=
parts
.
size
(
)
>
1
?
parts
[
1
]
:
std
:
:
string
(
)
;
}
}
for
(
const
int
&
payload_type
:
rid_payload_types
)
{
const
auto
it
=
std
:
:
find_if
(
media_desc
.
codecs
(
)
.
begin
(
)
media_desc
.
codecs
(
)
.
end
(
)
[
&
payload_type
]
(
const
Codec
&
m_section_codec
)
{
return
m_section_codec
.
id
=
=
payload_type
;
}
)
;
if
(
it
=
=
media_desc
.
codecs
(
)
.
end
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
A
RID
contains
an
unknown
payload
type
.
"
;
continue
;
}
rid_description
.
codecs
.
push_back
(
*
it
)
;
}
return
std
:
:
move
(
rid_description
)
;
}
}
