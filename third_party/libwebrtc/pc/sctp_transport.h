#
ifndef
PC_SCTP_TRANSPORT_H_
#
define
PC_SCTP_TRANSPORT_H_
#
include
<
memory
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sctp_transport_interface
.
h
"
#
include
"
media
/
sctp
/
sctp_transport
.
h
"
#
include
"
pc
/
dtls_transport
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
webrtc
{
class
SctpTransport
:
public
SctpTransportInterface
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
SctpTransport
(
std
:
:
unique_ptr
<
cricket
:
:
SctpTransportInternal
>
internal
)
;
rtc
:
:
scoped_refptr
<
DtlsTransportInterface
>
dtls_transport
(
)
const
override
;
SctpTransportInformation
Information
(
)
const
override
;
void
RegisterObserver
(
SctpTransportObserverInterface
*
observer
)
override
;
void
UnregisterObserver
(
)
override
;
void
Clear
(
)
;
void
SetDtlsTransport
(
rtc
:
:
scoped_refptr
<
DtlsTransport
>
)
;
void
Start
(
int
local_port
int
remote_port
int
max_message_size
)
;
cricket
:
:
SctpTransportInternal
*
internal
(
)
{
MutexLock
lock
(
&
lock_
)
;
return
internal_sctp_transport_
.
get
(
)
;
}
const
cricket
:
:
SctpTransportInternal
*
internal
(
)
const
{
MutexLock
lock
(
&
lock_
)
;
return
internal_sctp_transport_
.
get
(
)
;
}
protected
:
~
SctpTransport
(
)
override
;
private
:
void
UpdateInformation
(
SctpTransportState
state
)
;
void
OnInternalReadyToSendData
(
)
;
void
OnAssociationChangeCommunicationUp
(
)
;
void
OnInternalClosingProcedureStartedRemotely
(
int
sid
)
;
void
OnInternalClosingProcedureComplete
(
int
sid
)
;
void
OnDtlsStateChange
(
cricket
:
:
DtlsTransportInternal
*
transport
cricket
:
:
DtlsTransportState
state
)
;
rtc
:
:
Thread
*
owner_thread_
;
mutable
Mutex
lock_
;
SctpTransportInformation
info_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
unique_ptr
<
cricket
:
:
SctpTransportInternal
>
internal_sctp_transport_
RTC_GUARDED_BY
(
lock_
)
;
SctpTransportObserverInterface
*
observer_
RTC_GUARDED_BY
(
owner_thread_
)
=
nullptr
;
rtc
:
:
scoped_refptr
<
DtlsTransport
>
dtls_transport_
RTC_GUARDED_BY
(
owner_thread_
)
;
}
;
}
#
endif
