#
ifndef
PC_SRTP_FILTER_H_
#
define
PC_SRTP_FILTER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
crypto_params
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
struct
srtp_event_data_t
;
struct
srtp_ctx_t_
;
namespace
cricket
{
class
SrtpFilter
{
public
:
enum
Mode
{
PROTECT
UNPROTECT
}
;
enum
Error
{
ERROR_NONE
ERROR_FAIL
ERROR_AUTH
ERROR_REPLAY
}
;
SrtpFilter
(
)
;
~
SrtpFilter
(
)
;
bool
IsActive
(
)
const
;
bool
Process
(
const
std
:
:
vector
<
CryptoParams
>
&
cryptos
webrtc
:
:
SdpType
type
ContentSource
source
)
;
bool
SetOffer
(
const
std
:
:
vector
<
CryptoParams
>
&
offer_params
ContentSource
source
)
;
bool
SetProvisionalAnswer
(
const
std
:
:
vector
<
CryptoParams
>
&
answer_params
ContentSource
source
)
;
bool
SetAnswer
(
const
std
:
:
vector
<
CryptoParams
>
&
answer_params
ContentSource
source
)
;
bool
ResetParams
(
)
;
static
bool
ParseKeyParams
(
const
std
:
:
string
&
params
uint8_t
*
key
size_t
len
)
;
absl
:
:
optional
<
int
>
send_cipher_suite
(
)
{
return
send_cipher_suite_
;
}
absl
:
:
optional
<
int
>
recv_cipher_suite
(
)
{
return
recv_cipher_suite_
;
}
rtc
:
:
ArrayView
<
const
uint8_t
>
send_key
(
)
{
return
send_key_
;
}
rtc
:
:
ArrayView
<
const
uint8_t
>
recv_key
(
)
{
return
recv_key_
;
}
protected
:
bool
ExpectOffer
(
ContentSource
source
)
;
bool
StoreParams
(
const
std
:
:
vector
<
CryptoParams
>
&
params
ContentSource
source
)
;
bool
ExpectAnswer
(
ContentSource
source
)
;
bool
DoSetAnswer
(
const
std
:
:
vector
<
CryptoParams
>
&
answer_params
ContentSource
source
bool
final
)
;
bool
NegotiateParams
(
const
std
:
:
vector
<
CryptoParams
>
&
answer_params
CryptoParams
*
selected_params
)
;
private
:
bool
ApplySendParams
(
const
CryptoParams
&
send_params
)
;
bool
ApplyRecvParams
(
const
CryptoParams
&
recv_params
)
;
enum
State
{
ST_INIT
ST_SENTOFFER
ST_RECEIVEDOFFER
ST_SENTPRANSWER_NO_CRYPTO
ST_RECEIVEDPRANSWER_NO_CRYPTO
ST_ACTIVE
ST_SENTUPDATEDOFFER
ST_RECEIVEDUPDATEDOFFER
ST_SENTPRANSWER
ST_RECEIVEDPRANSWER
}
;
State
state_
=
ST_INIT
;
std
:
:
vector
<
CryptoParams
>
offer_params_
;
CryptoParams
applied_send_params_
;
CryptoParams
applied_recv_params_
;
absl
:
:
optional
<
int
>
send_cipher_suite_
;
absl
:
:
optional
<
int
>
recv_cipher_suite_
;
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
send_key_
;
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
recv_key_
;
}
;
}
#
endif
