#
ifndef
PC_CHANNEL_H_
#
define
PC_CHANNEL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
call
/
audio_sink
.
h
"
#
include
"
api
/
crypto
/
crypto_options
.
h
"
#
include
"
api
/
function_view
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
media_types
.
h
"
#
include
"
api
/
rtp_receiver_interface
.
h
"
#
include
"
api
/
rtp_transceiver_direction
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
api
/
video
/
video_source_interface
.
h
"
#
include
"
call
/
rtp_demuxer
.
h
"
#
include
"
call
/
rtp_packet_sink_interface
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
media
/
base
/
media_engine
.
h
"
#
include
"
media
/
base
/
stream_params
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
p2p
/
base
/
dtls_transport_internal
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
pc
/
channel_interface
.
h
"
#
include
"
pc
/
dtls_srtp_transport
.
h
"
#
include
"
pc
/
media_session
.
h
"
#
include
"
pc
/
rtp_transport
.
h
"
#
include
"
pc
/
rtp_transport_internal
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
srtp_filter
.
h
"
#
include
"
pc
/
srtp_transport
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
async_udp_socket
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
message_handler
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
task_utils
/
pending_task_safety_flag
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
thread_message
.
h
"
#
include
"
rtc_base
/
unique_id_generator
.
h
"
namespace
webrtc
{
class
AudioSinkInterface
;
}
namespace
cricket
{
struct
CryptoParams
;
class
BaseChannel
:
public
ChannelInterface
public
rtc
:
:
MessageHandlerAutoCleanup
public
sigslot
:
:
has_slots
<
>
public
MediaChannel
:
:
NetworkInterface
public
webrtc
:
:
RtpPacketSinkInterface
{
public
:
BaseChannel
(
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
signaling_thread
std
:
:
unique_ptr
<
MediaChannel
>
media_channel
const
std
:
:
string
&
content_name
bool
srtp_required
webrtc
:
:
CryptoOptions
crypto_options
rtc
:
:
UniqueRandomIdGenerator
*
ssrc_generator
)
;
virtual
~
BaseChannel
(
)
;
virtual
void
Init_w
(
webrtc
:
:
RtpTransportInternal
*
rtp_transport
)
;
void
Deinit
(
)
;
rtc
:
:
Thread
*
worker_thread
(
)
const
{
return
worker_thread_
;
}
rtc
:
:
Thread
*
network_thread
(
)
const
{
return
network_thread_
;
}
const
std
:
:
string
&
content_name
(
)
const
override
{
return
content_name_
;
}
const
std
:
:
string
&
transport_name
(
)
const
override
{
return
transport_name_
;
}
bool
enabled
(
)
const
override
{
return
enabled_
;
}
bool
srtp_active
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
return
rtp_transport_
&
&
rtp_transport_
-
>
IsSrtpActive
(
)
;
}
bool
SrtpActiveForTesting
(
)
const
{
if
(
!
network_thread_
-
>
IsCurrent
(
)
)
{
return
network_thread_
-
>
Invoke
<
bool
>
(
RTC_FROM_HERE
[
this
]
{
return
srtp_active
(
)
;
}
)
;
}
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
return
srtp_active
(
)
;
}
bool
SetRtpTransport
(
webrtc
:
:
RtpTransportInternal
*
rtp_transport
)
override
;
webrtc
:
:
RtpTransportInternal
*
rtp_transport
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
return
rtp_transport_
;
}
webrtc
:
:
RtpTransportInternal
*
RtpTransportForTesting
(
)
const
{
if
(
!
network_thread_
-
>
IsCurrent
(
)
)
{
return
network_thread_
-
>
Invoke
<
webrtc
:
:
RtpTransportInternal
*
>
(
RTC_FROM_HERE
[
this
]
{
return
rtp_transport
(
)
;
}
)
;
}
RTC_DCHECK_RUN_ON
(
network_thread
(
)
)
;
return
rtp_transport
(
)
;
}
bool
SetLocalContent
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
bool
SetRemoteContent
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
bool
SetPayloadTypeDemuxingEnabled
(
bool
enabled
)
override
;
bool
Enable
(
bool
enable
)
override
;
const
std
:
:
vector
<
StreamParams
>
&
local_streams
(
)
const
override
{
return
local_streams_
;
}
const
std
:
:
vector
<
StreamParams
>
&
remote_streams
(
)
const
override
{
return
remote_streams_
;
}
sigslot
:
:
signal1
<
ChannelInterface
*
>
&
SignalFirstPacketReceived
(
)
override
;
sigslot
:
:
signal1
<
const
rtc
:
:
SentPacket
&
>
&
SignalSentPacket
(
)
;
void
OnTransportReadyToSend
(
bool
ready
)
;
int
SetOption
(
SocketType
type
rtc
:
:
Socket
:
:
Option
o
int
val
)
override
;
int
SetOption_n
(
SocketType
type
rtc
:
:
Socket
:
:
Option
o
int
val
)
RTC_RUN_ON
(
network_thread
(
)
)
;
void
OnRtpPacket
(
const
webrtc
:
:
RtpPacketReceived
&
packet
)
override
;
void
set_transport_name_for_testing
(
const
std
:
:
string
&
transport_name
)
{
transport_name_
=
transport_name
;
}
MediaChannel
*
media_channel
(
)
const
override
{
return
media_channel_
.
get
(
)
;
}
protected
:
bool
was_ever_writable
(
)
const
{
RTC_DCHECK_RUN_ON
(
worker_thread
(
)
)
;
return
was_ever_writable_
;
}
void
set_local_content_direction
(
webrtc
:
:
RtpTransceiverDirection
direction
)
{
RTC_DCHECK_RUN_ON
(
worker_thread
(
)
)
;
local_content_direction_
=
direction
;
}
void
set_remote_content_direction
(
webrtc
:
:
RtpTransceiverDirection
direction
)
{
RTC_DCHECK_RUN_ON
(
worker_thread
(
)
)
;
remote_content_direction_
=
direction
;
}
bool
IsReadyToReceiveMedia_w
(
)
const
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
IsReadyToSendMedia_w
(
)
const
RTC_RUN_ON
(
worker_thread
(
)
)
;
rtc
:
:
Thread
*
signaling_thread
(
)
const
{
return
signaling_thread_
;
}
void
FlushRtcpMessages_n
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
bool
SendPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
override
;
bool
SendRtcp
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
override
;
void
OnWritableState
(
bool
writable
)
;
void
OnNetworkRouteChanged
(
absl
:
:
optional
<
rtc
:
:
NetworkRoute
>
network_route
)
;
bool
SendPacket
(
bool
rtcp
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
;
void
EnableMedia_w
(
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
void
DisableMedia_w
(
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
void
UpdateWritableState_n
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
void
ChannelWritable_n
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
void
ChannelNotWritable_n
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
bool
AddRecvStream_w
(
const
StreamParams
&
sp
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
RemoveRecvStream_w
(
uint32_t
ssrc
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
void
ResetUnsignaledRecvStream_w
(
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
SetPayloadTypeDemuxingEnabled_w
(
bool
enabled
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
AddSendStream_w
(
const
StreamParams
&
sp
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
RemoveSendStream_w
(
uint32_t
ssrc
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
virtual
void
UpdateMediaSendRecvState_w
(
)
RTC_RUN_ON
(
worker_thread
(
)
)
=
0
;
bool
UpdateLocalStreams_w
(
const
std
:
:
vector
<
StreamParams
>
&
streams
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
UpdateRemoteStreams_w
(
const
std
:
:
vector
<
StreamParams
>
&
streams
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
virtual
bool
SetLocalContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
RTC_RUN_ON
(
worker_thread
(
)
)
=
0
;
virtual
bool
SetRemoteContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
RTC_RUN_ON
(
worker_thread
(
)
)
=
0
;
RtpHeaderExtensions
GetFilteredRtpHeaderExtensions
(
const
RtpHeaderExtensions
&
extensions
)
;
void
OnMessage
(
rtc
:
:
Message
*
pmsg
)
override
;
template
<
class
T
>
T
InvokeOnWorker
(
const
rtc
:
:
Location
&
posted_from
rtc
:
:
FunctionView
<
T
(
)
>
functor
)
{
return
worker_thread_
-
>
Invoke
<
T
>
(
posted_from
functor
)
;
}
void
MaybeAddHandledPayloadType
(
int
payload_type
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
void
ClearHandledPayloadTypes
(
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
void
UpdateRtpHeaderExtensionMap
(
const
RtpHeaderExtensions
&
header_extensions
)
;
bool
RegisterRtpDemuxerSink_w
(
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
bool
RegisterRtpDemuxerSink_n
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
std
:
:
string
ToString
(
)
const
;
void
SetNegotiatedHeaderExtensions_w
(
const
RtpHeaderExtensions
&
extensions
)
RTC_RUN_ON
(
worker_thread
(
)
)
;
RtpHeaderExtensions
GetNegotiatedRtpHeaderExtensions
(
)
const
override
;
private
:
bool
ConnectToRtpTransport
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
void
DisconnectFromRtpTransport
(
)
RTC_RUN_ON
(
network_thread
(
)
)
;
void
SignalSentPacket_n
(
const
rtc
:
:
SentPacket
&
sent_packet
)
RTC_RUN_ON
(
network_thread
(
)
)
;
rtc
:
:
Thread
*
const
worker_thread_
;
rtc
:
:
Thread
*
const
network_thread_
;
rtc
:
:
Thread
*
const
signaling_thread_
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
PendingTaskSafetyFlag
>
alive_
;
sigslot
:
:
signal1
<
ChannelInterface
*
>
SignalFirstPacketReceived_
RTC_GUARDED_BY
(
signaling_thread_
)
;
sigslot
:
:
signal1
<
const
rtc
:
:
SentPacket
&
>
SignalSentPacket_
RTC_GUARDED_BY
(
worker_thread_
)
;
const
std
:
:
string
content_name_
;
bool
has_received_packet_
=
false
;
std
:
:
string
transport_name_
;
webrtc
:
:
RtpTransportInternal
*
rtp_transport_
RTC_GUARDED_BY
(
network_thread
(
)
)
=
nullptr
;
std
:
:
vector
<
std
:
:
pair
<
rtc
:
:
Socket
:
:
Option
int
>
>
socket_options_
RTC_GUARDED_BY
(
network_thread
(
)
)
;
std
:
:
vector
<
std
:
:
pair
<
rtc
:
:
Socket
:
:
Option
int
>
>
rtcp_socket_options_
RTC_GUARDED_BY
(
network_thread
(
)
)
;
bool
writable_
RTC_GUARDED_BY
(
network_thread
(
)
)
=
false
;
bool
was_ever_writable_n_
RTC_GUARDED_BY
(
network_thread
(
)
)
=
false
;
bool
was_ever_writable_
RTC_GUARDED_BY
(
worker_thread
(
)
)
=
false
;
const
bool
srtp_required_
=
true
;
const
webrtc
:
:
CryptoOptions
crypto_options_
;
const
std
:
:
unique_ptr
<
MediaChannel
>
media_channel_
;
bool
enabled_
=
false
;
bool
payload_type_demuxing_enabled_
RTC_GUARDED_BY
(
worker_thread
(
)
)
=
true
;
std
:
:
vector
<
StreamParams
>
local_streams_
RTC_GUARDED_BY
(
worker_thread
(
)
)
;
std
:
:
vector
<
StreamParams
>
remote_streams_
RTC_GUARDED_BY
(
worker_thread
(
)
)
;
webrtc
:
:
RtpTransceiverDirection
local_content_direction_
=
webrtc
:
:
RtpTransceiverDirection
:
:
kInactive
;
webrtc
:
:
RtpTransceiverDirection
remote_content_direction_
=
webrtc
:
:
RtpTransceiverDirection
:
:
kInactive
;
std
:
:
set
<
uint8_t
>
payload_types_
RTC_GUARDED_BY
(
worker_thread
(
)
)
;
webrtc
:
:
RtpDemuxerCriteria
demuxer_criteria_
;
rtc
:
:
UniqueRandomIdGenerator
*
const
ssrc_generator_
;
mutable
webrtc
:
:
Mutex
negotiated_header_extensions_lock_
;
RtpHeaderExtensions
negotiated_header_extensions_
RTC_GUARDED_BY
(
negotiated_header_extensions_lock_
)
;
}
;
class
VoiceChannel
:
public
BaseChannel
{
public
:
VoiceChannel
(
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
signaling_thread
std
:
:
unique_ptr
<
VoiceMediaChannel
>
channel
const
std
:
:
string
&
content_name
bool
srtp_required
webrtc
:
:
CryptoOptions
crypto_options
rtc
:
:
UniqueRandomIdGenerator
*
ssrc_generator
)
;
~
VoiceChannel
(
)
;
VoiceMediaChannel
*
media_channel
(
)
const
override
{
return
static_cast
<
VoiceMediaChannel
*
>
(
BaseChannel
:
:
media_channel
(
)
)
;
}
cricket
:
:
MediaType
media_type
(
)
const
override
{
return
cricket
:
:
MEDIA_TYPE_AUDIO
;
}
void
Init_w
(
webrtc
:
:
RtpTransportInternal
*
rtp_transport
)
override
;
private
:
void
UpdateMediaSendRecvState_w
(
)
override
;
bool
SetLocalContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
bool
SetRemoteContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
AudioSendParameters
last_send_params_
;
AudioRecvParameters
last_recv_params_
;
}
;
class
VideoChannel
:
public
BaseChannel
{
public
:
VideoChannel
(
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
signaling_thread
std
:
:
unique_ptr
<
VideoMediaChannel
>
media_channel
const
std
:
:
string
&
content_name
bool
srtp_required
webrtc
:
:
CryptoOptions
crypto_options
rtc
:
:
UniqueRandomIdGenerator
*
ssrc_generator
)
;
~
VideoChannel
(
)
;
VideoMediaChannel
*
media_channel
(
)
const
override
{
return
static_cast
<
VideoMediaChannel
*
>
(
BaseChannel
:
:
media_channel
(
)
)
;
}
void
FillBitrateInfo
(
BandwidthEstimationInfo
*
bwe_info
)
;
cricket
:
:
MediaType
media_type
(
)
const
override
{
return
cricket
:
:
MEDIA_TYPE_VIDEO
;
}
private
:
void
UpdateMediaSendRecvState_w
(
)
override
;
bool
SetLocalContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
bool
SetRemoteContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
VideoSendParameters
last_send_params_
;
VideoRecvParameters
last_recv_params_
;
}
;
class
RtpDataChannel
:
public
BaseChannel
{
public
:
RtpDataChannel
(
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
signaling_thread
std
:
:
unique_ptr
<
DataMediaChannel
>
channel
const
std
:
:
string
&
content_name
bool
srtp_required
webrtc
:
:
CryptoOptions
crypto_options
rtc
:
:
UniqueRandomIdGenerator
*
ssrc_generator
)
;
~
RtpDataChannel
(
)
;
void
Init_w
(
DtlsTransportInternal
*
rtp_dtls_transport
DtlsTransportInternal
*
rtcp_dtls_transport
rtc
:
:
PacketTransportInternal
*
rtp_packet_transport
rtc
:
:
PacketTransportInternal
*
rtcp_packet_transport
)
;
void
Init_w
(
webrtc
:
:
RtpTransportInternal
*
rtp_transport
)
override
;
virtual
bool
SendData
(
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
SendDataResult
*
result
)
;
bool
ready_to_send_data
(
)
const
{
return
ready_to_send_data_
;
}
sigslot
:
:
signal2
<
const
ReceiveDataParams
&
const
rtc
:
:
CopyOnWriteBuffer
&
>
SignalDataReceived
;
sigslot
:
:
signal1
<
bool
>
SignalReadyToSendData
;
cricket
:
:
MediaType
media_type
(
)
const
override
{
return
cricket
:
:
MEDIA_TYPE_DATA
;
}
protected
:
DataMediaChannel
*
media_channel
(
)
const
override
{
return
static_cast
<
DataMediaChannel
*
>
(
BaseChannel
:
:
media_channel
(
)
)
;
}
private
:
struct
SendDataMessageData
:
public
rtc
:
:
MessageData
{
SendDataMessageData
(
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
*
payload
SendDataResult
*
result
)
:
params
(
params
)
payload
(
payload
)
result
(
result
)
succeeded
(
false
)
{
}
const
SendDataParams
&
params
;
const
rtc
:
:
CopyOnWriteBuffer
*
payload
;
SendDataResult
*
result
;
bool
succeeded
;
}
;
struct
DataReceivedMessageData
:
public
rtc
:
:
MessageData
{
DataReceivedMessageData
(
const
ReceiveDataParams
&
params
const
char
*
data
size_t
len
)
:
params
(
params
)
payload
(
data
len
)
{
}
const
ReceiveDataParams
params
;
const
rtc
:
:
CopyOnWriteBuffer
payload
;
}
;
typedef
rtc
:
:
TypedMessageData
<
bool
>
DataChannelReadyToSendMessageData
;
bool
CheckDataChannelTypeFromContent
(
const
MediaContentDescription
*
content
std
:
:
string
*
error_desc
)
;
bool
SetLocalContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
bool
SetRemoteContent_w
(
const
MediaContentDescription
*
content
webrtc
:
:
SdpType
type
std
:
:
string
*
error_desc
)
override
;
void
UpdateMediaSendRecvState_w
(
)
override
;
void
OnMessage
(
rtc
:
:
Message
*
pmsg
)
override
;
void
OnDataReceived
(
const
ReceiveDataParams
&
params
const
char
*
data
size_t
len
)
;
void
OnDataChannelReadyToSend
(
bool
writable
)
;
bool
ready_to_send_data_
=
false
;
DataSendParameters
last_send_params_
;
DataRecvParameters
last_recv_params_
;
}
;
}
#
endif
