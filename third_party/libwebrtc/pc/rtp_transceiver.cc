#
include
"
pc
/
rtp_transceiver
.
h
"
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
pc
/
channel_manager
.
h
"
#
include
"
pc
/
rtp_media_utils
.
h
"
#
include
"
pc
/
rtp_parameters_conversion
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
namespace
{
template
<
class
T
>
RTCError
VerifyCodecPreferences
(
const
std
:
:
vector
<
RtpCodecCapability
>
&
codecs
const
std
:
:
vector
<
T
>
&
send_codecs
const
std
:
:
vector
<
T
>
&
recv_codecs
)
{
if
(
!
absl
:
:
c_any_of
(
codecs
[
&
recv_codecs
]
(
const
RtpCodecCapability
&
codec
)
{
return
codec
.
name
!
=
cricket
:
:
kRtxCodecName
&
&
codec
.
name
!
=
cricket
:
:
kRedCodecName
&
&
codec
.
name
!
=
cricket
:
:
kFlexfecCodecName
&
&
absl
:
:
c_any_of
(
recv_codecs
[
&
codec
]
(
const
T
&
recv_codec
)
{
return
recv_codec
.
MatchesCapability
(
codec
)
;
}
)
;
}
)
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_MODIFICATION
"
Invalid
codec
preferences
:
Missing
codec
from
recv
"
"
codec
capabilities
.
"
)
;
}
if
(
!
absl
:
:
c_any_of
(
codecs
[
&
send_codecs
]
(
const
RtpCodecCapability
&
codec
)
{
return
codec
.
name
!
=
cricket
:
:
kRtxCodecName
&
&
codec
.
name
!
=
cricket
:
:
kRedCodecName
&
&
codec
.
name
!
=
cricket
:
:
kFlexfecCodecName
&
&
absl
:
:
c_any_of
(
send_codecs
[
&
codec
]
(
const
T
&
send_codec
)
{
return
send_codec
.
MatchesCapability
(
codec
)
;
}
)
;
}
)
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_MODIFICATION
"
Invalid
codec
preferences
:
Missing
codec
from
send
"
"
codec
capabilities
.
"
)
;
}
for
(
const
auto
&
codec_preference
:
codecs
)
{
bool
is_recv_codec
=
absl
:
:
c_any_of
(
recv_codecs
[
&
codec_preference
]
(
const
T
&
codec
)
{
return
codec
.
MatchesCapability
(
codec_preference
)
;
}
)
;
bool
is_send_codec
=
absl
:
:
c_any_of
(
send_codecs
[
&
codec_preference
]
(
const
T
&
codec
)
{
return
codec
.
MatchesCapability
(
codec_preference
)
;
}
)
;
if
(
!
is_recv_codec
&
&
!
is_send_codec
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_MODIFICATION
std
:
:
string
(
"
Invalid
codec
preferences
:
invalid
codec
with
name
\
"
"
)
+
codec_preference
.
name
+
"
\
"
.
"
)
;
}
}
if
(
absl
:
:
c_all_of
(
codecs
[
]
(
const
RtpCodecCapability
&
codec
)
{
return
codec
.
name
=
=
cricket
:
:
kRtxCodecName
|
|
codec
.
name
=
=
cricket
:
:
kRedCodecName
|
|
codec
.
name
=
=
cricket
:
:
kUlpfecCodecName
;
}
)
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_MODIFICATION
"
Invalid
codec
preferences
:
codec
list
must
have
a
non
"
"
RTX
RED
or
FEC
entry
.
"
)
;
}
return
RTCError
:
:
OK
(
)
;
}
TaskQueueBase
*
GetCurrentTaskQueueOrThread
(
)
{
TaskQueueBase
*
current
=
TaskQueueBase
:
:
Current
(
)
;
if
(
!
current
)
current
=
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
CurrentThread
(
)
;
return
current
;
}
}
RtpTransceiver
:
:
RtpTransceiver
(
cricket
:
:
MediaType
media_type
)
:
thread_
(
GetCurrentTaskQueueOrThread
(
)
)
unified_plan_
(
false
)
media_type_
(
media_type
)
{
RTC_DCHECK
(
media_type
=
=
cricket
:
:
MEDIA_TYPE_AUDIO
|
|
media_type
=
=
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
}
RtpTransceiver
:
:
RtpTransceiver
(
rtc
:
:
scoped_refptr
<
RtpSenderProxyWithInternal
<
RtpSenderInternal
>
>
sender
rtc
:
:
scoped_refptr
<
RtpReceiverProxyWithInternal
<
RtpReceiverInternal
>
>
receiver
cricket
:
:
ChannelManager
*
channel_manager
std
:
:
vector
<
RtpHeaderExtensionCapability
>
header_extensions_offered
)
:
thread_
(
GetCurrentTaskQueueOrThread
(
)
)
unified_plan_
(
true
)
media_type_
(
sender
-
>
media_type
(
)
)
channel_manager_
(
channel_manager
)
header_extensions_to_offer_
(
std
:
:
move
(
header_extensions_offered
)
)
{
RTC_DCHECK
(
media_type_
=
=
cricket
:
:
MEDIA_TYPE_AUDIO
|
|
media_type_
=
=
cricket
:
:
MEDIA_TYPE_VIDEO
)
;
RTC_DCHECK_EQ
(
sender
-
>
media_type
(
)
receiver
-
>
media_type
(
)
)
;
senders_
.
push_back
(
sender
)
;
receivers_
.
push_back
(
receiver
)
;
}
RtpTransceiver
:
:
~
RtpTransceiver
(
)
{
StopInternal
(
)
;
}
void
RtpTransceiver
:
:
SetChannel
(
cricket
:
:
ChannelInterface
*
channel
)
{
if
(
stopped_
&
&
channel
)
{
return
;
}
if
(
channel
)
{
RTC_DCHECK_EQ
(
media_type
(
)
channel
-
>
media_type
(
)
)
;
}
if
(
channel_
)
{
channel_
-
>
SignalFirstPacketReceived
(
)
.
disconnect
(
this
)
;
}
channel_
=
channel
;
if
(
channel_
)
{
channel_
-
>
SignalFirstPacketReceived
(
)
.
connect
(
this
&
RtpTransceiver
:
:
OnFirstPacketReceived
)
;
}
for
(
const
auto
&
sender
:
senders_
)
{
sender
-
>
internal
(
)
-
>
SetMediaChannel
(
channel_
?
channel_
-
>
media_channel
(
)
:
nullptr
)
;
}
for
(
const
auto
&
receiver
:
receivers_
)
{
if
(
!
channel_
)
{
receiver
-
>
internal
(
)
-
>
Stop
(
)
;
}
receiver
-
>
internal
(
)
-
>
SetMediaChannel
(
channel_
?
channel_
-
>
media_channel
(
)
:
nullptr
)
;
}
}
void
RtpTransceiver
:
:
AddSender
(
rtc
:
:
scoped_refptr
<
RtpSenderProxyWithInternal
<
RtpSenderInternal
>
>
sender
)
{
RTC_DCHECK
(
!
stopped_
)
;
RTC_DCHECK
(
!
unified_plan_
)
;
RTC_DCHECK
(
sender
)
;
RTC_DCHECK_EQ
(
media_type
(
)
sender
-
>
media_type
(
)
)
;
RTC_DCHECK
(
!
absl
:
:
c_linear_search
(
senders_
sender
)
)
;
senders_
.
push_back
(
sender
)
;
}
bool
RtpTransceiver
:
:
RemoveSender
(
RtpSenderInterface
*
sender
)
{
RTC_DCHECK
(
!
unified_plan_
)
;
if
(
sender
)
{
RTC_DCHECK_EQ
(
media_type
(
)
sender
-
>
media_type
(
)
)
;
}
auto
it
=
absl
:
:
c_find
(
senders_
sender
)
;
if
(
it
=
=
senders_
.
end
(
)
)
{
return
false
;
}
(
*
it
)
-
>
internal
(
)
-
>
Stop
(
)
;
senders_
.
erase
(
it
)
;
return
true
;
}
void
RtpTransceiver
:
:
AddReceiver
(
rtc
:
:
scoped_refptr
<
RtpReceiverProxyWithInternal
<
RtpReceiverInternal
>
>
receiver
)
{
RTC_DCHECK
(
!
stopped_
)
;
RTC_DCHECK
(
!
unified_plan_
)
;
RTC_DCHECK
(
receiver
)
;
RTC_DCHECK_EQ
(
media_type
(
)
receiver
-
>
media_type
(
)
)
;
RTC_DCHECK
(
!
absl
:
:
c_linear_search
(
receivers_
receiver
)
)
;
receivers_
.
push_back
(
receiver
)
;
}
bool
RtpTransceiver
:
:
RemoveReceiver
(
RtpReceiverInterface
*
receiver
)
{
RTC_DCHECK
(
!
unified_plan_
)
;
if
(
receiver
)
{
RTC_DCHECK_EQ
(
media_type
(
)
receiver
-
>
media_type
(
)
)
;
}
auto
it
=
absl
:
:
c_find
(
receivers_
receiver
)
;
if
(
it
=
=
receivers_
.
end
(
)
)
{
return
false
;
}
(
*
it
)
-
>
internal
(
)
-
>
Stop
(
)
;
(
*
it
)
-
>
internal
(
)
-
>
SetMediaChannel
(
nullptr
)
;
receivers_
.
erase
(
it
)
;
return
true
;
}
rtc
:
:
scoped_refptr
<
RtpSenderInternal
>
RtpTransceiver
:
:
sender_internal
(
)
const
{
RTC_DCHECK
(
unified_plan_
)
;
RTC_CHECK_EQ
(
1u
senders_
.
size
(
)
)
;
return
senders_
[
0
]
-
>
internal
(
)
;
}
rtc
:
:
scoped_refptr
<
RtpReceiverInternal
>
RtpTransceiver
:
:
receiver_internal
(
)
const
{
RTC_DCHECK
(
unified_plan_
)
;
RTC_CHECK_EQ
(
1u
receivers_
.
size
(
)
)
;
return
receivers_
[
0
]
-
>
internal
(
)
;
}
cricket
:
:
MediaType
RtpTransceiver
:
:
media_type
(
)
const
{
return
media_type_
;
}
absl
:
:
optional
<
std
:
:
string
>
RtpTransceiver
:
:
mid
(
)
const
{
return
mid_
;
}
void
RtpTransceiver
:
:
OnFirstPacketReceived
(
cricket
:
:
ChannelInterface
*
)
{
for
(
const
auto
&
receiver
:
receivers_
)
{
receiver
-
>
internal
(
)
-
>
NotifyFirstPacketReceived
(
)
;
}
}
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
RtpTransceiver
:
:
sender
(
)
const
{
RTC_DCHECK
(
unified_plan_
)
;
RTC_CHECK_EQ
(
1u
senders_
.
size
(
)
)
;
return
senders_
[
0
]
;
}
rtc
:
:
scoped_refptr
<
RtpReceiverInterface
>
RtpTransceiver
:
:
receiver
(
)
const
{
RTC_DCHECK
(
unified_plan_
)
;
RTC_CHECK_EQ
(
1u
receivers_
.
size
(
)
)
;
return
receivers_
[
0
]
;
}
void
RtpTransceiver
:
:
set_current_direction
(
RtpTransceiverDirection
direction
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Changing
transceiver
(
MID
=
"
<
<
mid_
.
value_or
(
"
<
not
set
>
"
)
<
<
"
)
current
direction
from
"
<
<
(
current_direction_
?
RtpTransceiverDirectionToString
(
*
current_direction_
)
:
"
<
not
set
>
"
)
<
<
"
to
"
<
<
RtpTransceiverDirectionToString
(
direction
)
<
<
"
.
"
;
current_direction_
=
direction
;
if
(
RtpTransceiverDirectionHasSend
(
*
current_direction_
)
)
{
has_ever_been_used_to_send_
=
true
;
}
}
void
RtpTransceiver
:
:
set_fired_direction
(
RtpTransceiverDirection
direction
)
{
fired_direction_
=
direction
;
}
bool
RtpTransceiver
:
:
stopped
(
)
const
{
return
stopped_
;
}
bool
RtpTransceiver
:
:
stopping
(
)
const
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
return
stopping_
;
}
RtpTransceiverDirection
RtpTransceiver
:
:
direction
(
)
const
{
if
(
unified_plan_
&
&
stopping
(
)
)
return
webrtc
:
:
RtpTransceiverDirection
:
:
kStopped
;
return
direction_
;
}
RTCError
RtpTransceiver
:
:
SetDirectionWithError
(
RtpTransceiverDirection
new_direction
)
{
if
(
unified_plan_
&
&
stopping
(
)
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_STATE
"
Cannot
set
direction
on
a
stopping
transceiver
.
"
)
;
}
if
(
new_direction
=
=
direction_
)
return
RTCError
:
:
OK
(
)
;
if
(
new_direction
=
=
RtpTransceiverDirection
:
:
kStopped
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_PARAMETER
"
The
set
direction
'
stopped
'
is
invalid
.
"
)
;
}
direction_
=
new_direction
;
SignalNegotiationNeeded
(
)
;
return
RTCError
:
:
OK
(
)
;
}
absl
:
:
optional
<
RtpTransceiverDirection
>
RtpTransceiver
:
:
current_direction
(
)
const
{
if
(
unified_plan_
&
&
stopped
(
)
)
return
webrtc
:
:
RtpTransceiverDirection
:
:
kStopped
;
return
current_direction_
;
}
absl
:
:
optional
<
RtpTransceiverDirection
>
RtpTransceiver
:
:
fired_direction
(
)
const
{
return
fired_direction_
;
}
void
RtpTransceiver
:
:
StopSendingAndReceiving
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
for
(
const
auto
&
sender
:
senders_
)
sender
-
>
internal
(
)
-
>
Stop
(
)
;
for
(
const
auto
&
receiver
:
receivers_
)
receiver
-
>
internal
(
)
-
>
StopAndEndTrack
(
)
;
stopping_
=
true
;
direction_
=
webrtc
:
:
RtpTransceiverDirection
:
:
kInactive
;
}
RTCError
RtpTransceiver
:
:
StopStandard
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
if
(
!
unified_plan_
)
{
StopInternal
(
)
;
return
RTCError
:
:
OK
(
)
;
}
if
(
is_pc_closed_
)
{
LOG_AND_RETURN_ERROR
(
RTCErrorType
:
:
INVALID_STATE
"
PeerConnection
is
closed
.
"
)
;
}
if
(
stopping_
)
return
RTCError
:
:
OK
(
)
;
StopSendingAndReceiving
(
)
;
SignalNegotiationNeeded
(
)
;
return
RTCError
:
:
OK
(
)
;
}
void
RtpTransceiver
:
:
StopInternal
(
)
{
StopTransceiverProcedure
(
)
;
}
void
RtpTransceiver
:
:
StopTransceiverProcedure
(
)
{
RTC_DCHECK_RUN_ON
(
thread_
)
;
if
(
!
stopping_
)
StopSendingAndReceiving
(
)
;
stopped_
=
true
;
for
(
const
auto
&
sender
:
senders_
)
sender
-
>
internal
(
)
-
>
SetTransceiverAsStopped
(
)
;
current_direction_
=
absl
:
:
nullopt
;
}
RTCError
RtpTransceiver
:
:
SetCodecPreferences
(
rtc
:
:
ArrayView
<
RtpCodecCapability
>
codec_capabilities
)
{
RTC_DCHECK
(
unified_plan_
)
;
if
(
codec_capabilities
.
empty
(
)
)
{
codec_preferences_
.
clear
(
)
;
return
RTCError
:
:
OK
(
)
;
}
std
:
:
vector
<
RtpCodecCapability
>
codecs
;
absl
:
:
c_remove_copy_if
(
codec_capabilities
std
:
:
back_inserter
(
codecs
)
[
&
codecs
]
(
const
RtpCodecCapability
&
codec
)
{
return
absl
:
:
c_linear_search
(
codecs
codec
)
;
}
)
;
RTCError
result
;
if
(
media_type_
=
=
cricket
:
:
MEDIA_TYPE_AUDIO
)
{
std
:
:
vector
<
cricket
:
:
AudioCodec
>
recv_codecs
send_codecs
;
channel_manager_
-
>
GetSupportedAudioReceiveCodecs
(
&
recv_codecs
)
;
channel_manager_
-
>
GetSupportedAudioSendCodecs
(
&
send_codecs
)
;
result
=
VerifyCodecPreferences
(
codecs
send_codecs
recv_codecs
)
;
}
else
if
(
media_type_
=
=
cricket
:
:
MEDIA_TYPE_VIDEO
)
{
std
:
:
vector
<
cricket
:
:
VideoCodec
>
recv_codecs
send_codecs
;
channel_manager_
-
>
GetSupportedVideoReceiveCodecs
(
&
recv_codecs
)
;
channel_manager_
-
>
GetSupportedVideoSendCodecs
(
&
send_codecs
)
;
result
=
VerifyCodecPreferences
(
codecs
send_codecs
recv_codecs
)
;
}
if
(
result
.
ok
(
)
)
{
codec_preferences_
=
codecs
;
}
return
result
;
}
std
:
:
vector
<
RtpHeaderExtensionCapability
>
RtpTransceiver
:
:
HeaderExtensionsToOffer
(
)
const
{
return
header_extensions_to_offer_
;
}
RTCError
RtpTransceiver
:
:
SetOfferedRtpHeaderExtensions
(
rtc
:
:
ArrayView
<
const
RtpHeaderExtensionCapability
>
header_extensions_to_offer
)
{
for
(
const
auto
&
entry
:
header_extensions_to_offer
)
{
auto
it
=
std
:
:
find_if
(
header_extensions_to_offer_
.
begin
(
)
header_extensions_to_offer_
.
end
(
)
[
&
entry
]
(
const
auto
&
offered
)
{
return
entry
.
uri
=
=
offered
.
uri
;
}
)
;
if
(
it
=
=
header_extensions_to_offer_
.
end
(
)
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
"
Attempted
to
modify
an
unoffered
extension
.
"
)
;
}
if
(
(
entry
.
uri
=
=
RtpExtension
:
:
kMidUri
|
|
entry
.
uri
=
=
RtpExtension
:
:
kVideoRotationUri
)
&
&
entry
.
direction
!
=
RtpTransceiverDirection
:
:
kSendRecv
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_MODIFICATION
"
Attempted
to
stop
a
mandatory
extension
.
"
)
;
}
}
for
(
const
auto
&
entry
:
header_extensions_to_offer
)
{
auto
it
=
std
:
:
find_if
(
header_extensions_to_offer_
.
begin
(
)
header_extensions_to_offer_
.
end
(
)
[
&
entry
]
(
const
auto
&
offered
)
{
return
entry
.
uri
=
=
offered
.
uri
;
}
)
;
it
-
>
direction
=
entry
.
direction
;
}
return
RTCError
:
:
OK
(
)
;
}
void
RtpTransceiver
:
:
SetPeerConnectionClosed
(
)
{
is_pc_closed_
=
true
;
}
}
