#
ifndef
PC_JSEP_TRANSPORT_H_
#
define
PC_JSEP_TRANSPORT_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
crypto_params
.
h
"
#
include
"
api
/
ice_transport_interface
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
transport
/
data_channel_transport_interface
.
h
"
#
include
"
media
/
sctp
/
sctp_transport_internal
.
h
"
#
include
"
p2p
/
base
/
dtls_transport
.
h
"
#
include
"
p2p
/
base
/
dtls_transport_internal
.
h
"
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
base
/
transport_info
.
h
"
#
include
"
pc
/
composite_rtp_transport
.
h
"
#
include
"
pc
/
dtls_srtp_transport
.
h
"
#
include
"
pc
/
dtls_transport
.
h
"
#
include
"
pc
/
rtcp_mux_filter
.
h
"
#
include
"
pc
/
rtp_transport
.
h
"
#
include
"
pc
/
rtp_transport_internal
.
h
"
#
include
"
pc
/
sctp_transport
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
srtp_filter
.
h
"
#
include
"
pc
/
srtp_transport
.
h
"
#
include
"
pc
/
transport_stats
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
rtc_certificate
.
h
"
#
include
"
rtc_base
/
ssl_fingerprint
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
synchronization
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
cricket
{
class
DtlsTransportInternal
;
struct
JsepTransportDescription
{
public
:
JsepTransportDescription
(
)
;
JsepTransportDescription
(
bool
rtcp_mux_enabled
const
std
:
:
vector
<
CryptoParams
>
&
cryptos
const
std
:
:
vector
<
int
>
&
encrypted_header_extension_ids
int
rtp_abs_sendtime_extn_id
const
TransportDescription
&
transport_description
)
;
JsepTransportDescription
(
const
JsepTransportDescription
&
from
)
;
~
JsepTransportDescription
(
)
;
JsepTransportDescription
&
operator
=
(
const
JsepTransportDescription
&
from
)
;
bool
rtcp_mux_enabled
=
true
;
std
:
:
vector
<
CryptoParams
>
cryptos
;
std
:
:
vector
<
int
>
encrypted_header_extension_ids
;
int
rtp_abs_sendtime_extn_id
=
-
1
;
TransportDescription
transport_desc
;
}
;
class
JsepTransport
:
public
sigslot
:
:
has_slots
<
>
{
public
:
JsepTransport
(
const
std
:
:
string
&
mid
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
local_certificate
rtc
:
:
scoped_refptr
<
webrtc
:
:
IceTransportInterface
>
ice_transport
rtc
:
:
scoped_refptr
<
webrtc
:
:
IceTransportInterface
>
rtcp_ice_transport
std
:
:
unique_ptr
<
webrtc
:
:
RtpTransport
>
unencrypted_rtp_transport
std
:
:
unique_ptr
<
webrtc
:
:
SrtpTransport
>
sdes_transport
std
:
:
unique_ptr
<
webrtc
:
:
DtlsSrtpTransport
>
dtls_srtp_transport
std
:
:
unique_ptr
<
webrtc
:
:
RtpTransportInternal
>
datagram_rtp_transport
std
:
:
unique_ptr
<
DtlsTransportInternal
>
rtp_dtls_transport
std
:
:
unique_ptr
<
DtlsTransportInternal
>
rtcp_dtls_transport
std
:
:
unique_ptr
<
SctpTransportInternal
>
sctp_transport
)
;
~
JsepTransport
(
)
override
;
const
std
:
:
string
&
mid
(
)
const
{
return
mid_
;
}
void
SetLocalCertificate
(
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
local_certificate
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
local_certificate_
=
local_certificate
;
}
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
GetLocalCertificate
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
local_certificate_
;
}
webrtc
:
:
RTCError
SetLocalJsepTransportDescription
(
const
JsepTransportDescription
&
jsep_description
webrtc
:
:
SdpType
type
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
webrtc
:
:
RTCError
SetRemoteJsepTransportDescription
(
const
JsepTransportDescription
&
jsep_description
webrtc
:
:
SdpType
type
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
webrtc
:
:
RTCError
AddRemoteCandidates
(
const
Candidates
&
candidates
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
void
SetNeedsIceRestartFlag
(
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
bool
needs_ice_restart
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
return
needs_ice_restart_
;
}
absl
:
:
optional
<
rtc
:
:
SSLRole
>
GetDtlsRole
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
bool
GetStats
(
TransportStats
*
stats
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
const
JsepTransportDescription
*
local_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
local_description_
.
get
(
)
;
}
const
JsepTransportDescription
*
remote_description
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
remote_description_
.
get
(
)
;
}
webrtc
:
:
RtpTransportInternal
*
rtp_transport
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
if
(
composite_rtp_transport_
)
{
return
composite_rtp_transport_
.
get
(
)
;
}
else
if
(
datagram_rtp_transport_
)
{
return
datagram_rtp_transport_
.
get
(
)
;
}
else
{
return
default_rtp_transport
(
)
;
}
}
const
DtlsTransportInternal
*
rtp_dtls_transport
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
if
(
rtp_dtls_transport_
)
{
return
rtp_dtls_transport_
-
>
internal
(
)
;
}
else
{
return
nullptr
;
}
}
DtlsTransportInternal
*
rtp_dtls_transport
(
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
return
rtp_dtls_transport_locked
(
)
;
}
const
DtlsTransportInternal
*
rtcp_dtls_transport
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
if
(
rtcp_dtls_transport_
)
{
return
rtcp_dtls_transport_
-
>
internal
(
)
;
}
else
{
return
nullptr
;
}
}
DtlsTransportInternal
*
rtcp_dtls_transport
(
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
if
(
rtcp_dtls_transport_
)
{
return
rtcp_dtls_transport_
-
>
internal
(
)
;
}
else
{
return
nullptr
;
}
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
DtlsTransport
>
RtpDtlsTransport
(
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
return
rtp_dtls_transport_
;
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
SctpTransport
>
SctpTransport
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
return
sctp_transport_
;
}
webrtc
:
:
DataChannelTransportInterface
*
data_channel_transport
(
)
const
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
{
webrtc
:
:
MutexLock
lock
(
&
accessor_lock_
)
;
if
(
sctp_data_channel_transport_
)
{
return
sctp_data_channel_transport_
.
get
(
)
;
}
return
nullptr
;
}
sigslot
:
:
signal
<
>
SignalRtcpMuxActive
;
webrtc
:
:
RTCError
VerifyCertificateFingerprint
(
const
rtc
:
:
RTCCertificate
*
certificate
const
rtc
:
:
SSLFingerprint
*
fingerprint
)
const
;
void
SetActiveResetSrtpParams
(
bool
active_reset_srtp_params
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
private
:
DtlsTransportInternal
*
rtp_dtls_transport_locked
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
accessor_lock_
)
{
if
(
rtp_dtls_transport_
)
{
return
rtp_dtls_transport_
-
>
internal
(
)
;
}
else
{
return
nullptr
;
}
}
bool
SetRtcpMux
(
bool
enable
webrtc
:
:
SdpType
type
ContentSource
source
)
;
void
ActivateRtcpMux
(
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
bool
SetSdes
(
const
std
:
:
vector
<
CryptoParams
>
&
cryptos
const
std
:
:
vector
<
int
>
&
encrypted_extension_ids
webrtc
:
:
SdpType
type
ContentSource
source
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
accessor_lock_
)
;
webrtc
:
:
RTCError
NegotiateAndSetDtlsParameters
(
webrtc
:
:
SdpType
local_description_type
)
;
webrtc
:
:
RTCError
NegotiateDtlsRole
(
webrtc
:
:
SdpType
local_description_type
ConnectionRole
local_connection_role
ConnectionRole
remote_connection_role
absl
:
:
optional
<
rtc
:
:
SSLRole
>
*
negotiated_dtls_role
)
RTC_LOCKS_EXCLUDED
(
accessor_lock_
)
;
void
SetRemoteIceParameters
(
const
IceParameters
&
ice_parameters
IceTransportInternal
*
ice
)
;
static
webrtc
:
:
RTCError
SetNegotiatedDtlsParameters
(
DtlsTransportInternal
*
dtls_transport
absl
:
:
optional
<
rtc
:
:
SSLRole
>
dtls_role
rtc
:
:
SSLFingerprint
*
remote_fingerprint
)
;
bool
GetTransportStats
(
DtlsTransportInternal
*
dtls_transport
TransportStats
*
stats
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
accessor_lock_
)
;
webrtc
:
:
RtpTransportInternal
*
default_rtp_transport
(
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
accessor_lock_
)
{
if
(
dtls_srtp_transport_
)
{
return
dtls_srtp_transport_
.
get
(
)
;
}
else
if
(
sdes_transport_
)
{
return
sdes_transport_
.
get
(
)
;
}
else
if
(
unencrypted_rtp_transport_
)
{
return
unencrypted_rtp_transport_
.
get
(
)
;
}
else
{
return
nullptr
;
}
}
const
rtc
:
:
Thread
*
const
network_thread_
;
mutable
webrtc
:
:
Mutex
accessor_lock_
;
const
std
:
:
string
mid_
;
bool
needs_ice_restart_
RTC_GUARDED_BY
(
accessor_lock_
)
=
false
;
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
local_certificate_
RTC_GUARDED_BY
(
network_thread_
)
;
std
:
:
unique_ptr
<
JsepTransportDescription
>
local_description_
RTC_GUARDED_BY
(
network_thread_
)
;
std
:
:
unique_ptr
<
JsepTransportDescription
>
remote_description_
RTC_GUARDED_BY
(
network_thread_
)
;
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
IceTransportInterface
>
ice_transport_
;
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
IceTransportInterface
>
rtcp_ice_transport_
;
std
:
:
unique_ptr
<
webrtc
:
:
RtpTransport
>
unencrypted_rtp_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
std
:
:
unique_ptr
<
webrtc
:
:
SrtpTransport
>
sdes_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
std
:
:
unique_ptr
<
webrtc
:
:
DtlsSrtpTransport
>
dtls_srtp_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
std
:
:
unique_ptr
<
webrtc
:
:
CompositeRtpTransport
>
composite_rtp_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
DtlsTransport
>
rtp_dtls_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
DtlsTransport
>
rtcp_dtls_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
DtlsTransport
>
datagram_dtls_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
std
:
:
unique_ptr
<
webrtc
:
:
DataChannelTransportInterface
>
sctp_data_channel_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
SctpTransport
>
sctp_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
SrtpFilter
sdes_negotiator_
RTC_GUARDED_BY
(
network_thread_
)
;
RtcpMuxFilter
rtcp_mux_negotiator_
RTC_GUARDED_BY
(
network_thread_
)
;
absl
:
:
optional
<
std
:
:
vector
<
int
>
>
send_extension_ids_
RTC_GUARDED_BY
(
network_thread_
)
;
absl
:
:
optional
<
std
:
:
vector
<
int
>
>
recv_extension_ids_
RTC_GUARDED_BY
(
network_thread_
)
;
std
:
:
unique_ptr
<
webrtc
:
:
RtpTransportInternal
>
datagram_rtp_transport_
RTC_GUARDED_BY
(
accessor_lock_
)
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
JsepTransport
)
;
}
;
}
#
endif
