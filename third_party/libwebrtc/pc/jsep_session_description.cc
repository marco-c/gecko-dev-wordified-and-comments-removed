#
include
"
api
/
jsep_session_description
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
iterator
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
base
/
transport_info
.
h
"
#
include
"
pc
/
media_session
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
webrtc_sdp
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
net_helper
.
h
"
#
include
"
rtc_base
/
net_helpers
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
using
webrtc
:
:
Candidate
;
using
:
:
webrtc
:
:
SessionDescription
;
namespace
webrtc
{
namespace
{
constexpr
char
kDummyAddress
[
]
=
"
0
.
0
.
0
.
0
"
;
constexpr
int
kDummyPort
=
9
;
void
UpdateConnectionAddress
(
const
JsepCandidateCollection
&
candidate_collection
MediaContentDescription
*
media_desc
)
{
int
port
=
kDummyPort
;
std
:
:
string
ip
=
kDummyAddress
;
std
:
:
string
hostname
;
int
current_preference
=
0
;
int
current_family
=
AF_UNSPEC
;
for
(
size_t
i
=
0
;
i
<
candidate_collection
.
count
(
)
;
+
+
i
)
{
const
IceCandidate
*
jsep_candidate
=
candidate_collection
.
at
(
i
)
;
if
(
jsep_candidate
-
>
candidate
(
)
.
component
(
)
!
=
ICE_CANDIDATE_COMPONENT_RTP
)
{
continue
;
}
if
(
jsep_candidate
-
>
candidate
(
)
.
protocol
(
)
!
=
UDP_PROTOCOL_NAME
)
{
continue
;
}
const
int
preference
=
jsep_candidate
-
>
candidate
(
)
.
type_preference
(
)
;
const
int
family
=
jsep_candidate
-
>
candidate
(
)
.
address
(
)
.
ipaddr
(
)
.
family
(
)
;
if
(
(
preference
<
=
current_preference
&
&
current_family
=
=
family
)
|
|
(
current_family
=
=
AF_INET
&
&
family
=
=
AF_INET6
)
)
{
continue
;
}
current_preference
=
preference
;
current_family
=
family
;
const
SocketAddress
&
candidate_addr
=
jsep_candidate
-
>
candidate
(
)
.
address
(
)
;
port
=
candidate_addr
.
port
(
)
;
ip
=
candidate_addr
.
ipaddr
(
)
.
ToString
(
)
;
hostname
=
candidate_addr
.
hostname
(
)
;
}
SocketAddress
connection_addr
(
ip
port
)
;
if
(
IPIsUnspec
(
connection_addr
.
ipaddr
(
)
)
&
&
!
hostname
.
empty
(
)
)
{
connection_addr
=
SocketAddress
(
kDummyAddress
kDummyPort
)
;
}
media_desc
-
>
set_connection_address
(
connection_addr
)
;
}
std
:
:
vector
<
IceCandidateCollection
>
CloneCandidateCollection
(
const
std
:
:
vector
<
IceCandidateCollection
>
&
original
)
{
std
:
:
vector
<
IceCandidateCollection
>
ret
;
ret
.
reserve
(
original
.
size
(
)
)
;
for
(
const
auto
&
collection
:
original
)
{
ret
.
push_back
(
collection
.
Clone
(
)
)
;
}
return
ret
;
}
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateSessionDescription
(
SdpType
type
const
std
:
:
string
&
sdp
)
{
return
CreateSessionDescription
(
type
sdp
nullptr
)
;
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateSessionDescription
(
SdpType
type
const
std
:
:
string
&
sdp
SdpParseError
*
error_out
)
{
if
(
type
=
=
SdpType
:
:
kRollback
)
{
return
CreateRollbackSessionDescription
(
)
;
}
return
SdpDeserialize
(
type
sdp
error_out
)
;
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateSessionDescription
(
SdpType
type
const
std
:
:
string
&
session_id
const
std
:
:
string
&
session_version
std
:
:
unique_ptr
<
SessionDescription
>
description
)
{
return
SessionDescriptionInterface
:
:
Create
(
type
std
:
:
move
(
description
)
session_id
session_version
)
;
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateRollbackSessionDescription
(
absl
:
:
string_view
session_id
absl
:
:
string_view
session_version
)
{
return
SessionDescriptionInterface
:
:
Create
(
SdpType
:
:
kRollback
nullptr
session_id
session_version
)
;
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
SessionDescriptionInterface
:
:
Create
(
SdpType
type
std
:
:
unique_ptr
<
SessionDescription
>
description
absl
:
:
string_view
id
absl
:
:
string_view
version
std
:
:
vector
<
IceCandidateCollection
>
candidates
)
{
if
(
!
description
&
&
type
!
=
SdpType
:
:
kRollback
)
return
nullptr
;
return
absl
:
:
WrapUnique
(
new
SessionDescriptionInterface
(
type
std
:
:
move
(
description
)
id
version
std
:
:
move
(
candidates
)
)
)
;
}
SessionDescriptionInternal
:
:
SessionDescriptionInternal
(
SdpType
type
std
:
:
unique_ptr
<
SessionDescription
>
description
absl
:
:
string_view
id
absl
:
:
string_view
version
)
:
sdp_type_
(
type
)
id_
(
id
)
version_
(
version
)
description_
(
std
:
:
move
(
description
)
)
{
RTC_DCHECK
(
description_
|
|
sdp_type_
=
=
SdpType
:
:
kRollback
)
;
}
SessionDescriptionInternal
:
:
~
SessionDescriptionInternal
(
)
=
default
;
size_t
SessionDescriptionInternal
:
:
mediasection_count
(
)
const
{
return
description_
?
description_
-
>
contents
(
)
.
size
(
)
:
0u
;
}
void
SessionDescriptionInternal
:
:
RelinquishThreadOwnership
(
)
{
sequence_checker_
.
Detach
(
)
;
}
SessionDescriptionInterface
:
:
SessionDescriptionInterface
(
SdpType
type
std
:
:
unique_ptr
<
SessionDescription
>
desc
absl
:
:
string_view
id
absl
:
:
string_view
version
std
:
:
vector
<
IceCandidateCollection
>
candidates
)
:
SessionDescriptionInternal
(
type
std
:
:
move
(
desc
)
id
version
)
candidate_collection_
(
std
:
:
move
(
candidates
)
)
{
RTC_DCHECK
(
description
(
)
|
|
type
=
=
SdpType
:
:
kRollback
)
;
RTC_DCHECK
(
candidate_collection_
.
empty
(
)
|
|
candidate_collection_
.
size
(
)
=
=
number_of_mediasections
(
)
)
;
candidate_collection_
.
resize
(
number_of_mediasections
(
)
)
;
}
JsepSessionDescription
:
:
JsepSessionDescription
(
SdpType
type
)
:
SessionDescriptionInterface
(
type
nullptr
"
"
"
"
)
{
}
JsepSessionDescription
:
:
JsepSessionDescription
(
SdpType
type
std
:
:
unique_ptr
<
SessionDescription
>
desc
absl
:
:
string_view
session_id
absl
:
:
string_view
session_version
std
:
:
vector
<
IceCandidateCollection
>
candidates
)
:
SessionDescriptionInterface
(
type
std
:
:
move
(
desc
)
session_id
session_version
std
:
:
move
(
candidates
)
)
{
}
JsepSessionDescription
:
:
~
JsepSessionDescription
(
)
{
}
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
SessionDescriptionInterface
:
:
Clone
(
)
const
{
RTC_DCHECK_RUN_ON
(
sequence_checker
(
)
)
;
return
SessionDescriptionInterface
:
:
Create
(
sdp_type
(
)
description
(
)
?
description
(
)
-
>
Clone
(
)
:
nullptr
id
(
)
version
(
)
CloneCandidateCollection
(
candidate_collection_
)
)
;
}
bool
SessionDescriptionInterface
:
:
AddCandidate
(
const
IceCandidate
*
candidate
)
{
RTC_DCHECK_RUN_ON
(
sequence_checker
(
)
)
;
if
(
!
candidate
)
return
false
;
size_t
index
=
0
;
if
(
!
GetMediasectionIndex
(
candidate
&
index
)
)
{
return
false
;
}
ContentInfo
&
content
=
description
(
)
-
>
contents
(
)
[
index
]
;
const
TransportInfo
*
transport_info
=
description
(
)
-
>
GetTransportInfoByName
(
content
.
mid
(
)
)
;
if
(
!
transport_info
)
{
return
false
;
}
Candidate
updated_candidate
=
candidate
-
>
candidate
(
)
;
if
(
updated_candidate
.
username
(
)
.
empty
(
)
)
{
updated_candidate
.
set_username
(
transport_info
-
>
description
.
ice_ufrag
)
;
}
if
(
updated_candidate
.
password
(
)
.
empty
(
)
)
{
updated_candidate
.
set_password
(
transport_info
-
>
description
.
ice_pwd
)
;
}
RTC_DCHECK
(
candidate
-
>
sdp_mid
(
)
.
empty
(
)
|
|
candidate
-
>
sdp_mid
(
)
=
=
content
.
mid
(
)
)
<
<
"
sdp_mid
=
'
"
<
<
candidate
-
>
sdp_mid
(
)
<
<
"
'
content
.
mid
(
)
=
'
"
<
<
content
.
mid
(
)
<
<
"
'
"
;
auto
updated_candidate_wrapper
=
std
:
:
make_unique
<
IceCandidate
>
(
content
.
mid
(
)
static_cast
<
int
>
(
index
)
updated_candidate
)
;
IceCandidateCollection
&
candidates
=
candidate_collection_
[
index
]
;
if
(
!
candidates
.
HasCandidate
(
updated_candidate_wrapper
.
get
(
)
)
)
{
candidates
.
add
(
std
:
:
move
(
updated_candidate_wrapper
)
)
;
UpdateConnectionAddress
(
candidates
content
.
media_description
(
)
)
;
}
return
true
;
}
bool
SessionDescriptionInterface
:
:
RemoveCandidate
(
const
IceCandidate
*
candidate
)
{
RTC_DCHECK_RUN_ON
(
sequence_checker
(
)
)
;
size_t
index
=
0u
;
if
(
!
GetMediasectionIndex
(
candidate
&
index
)
)
{
return
false
;
}
IceCandidateCollection
&
candidates
=
candidate_collection_
[
index
]
;
if
(
!
candidates
.
remove
(
candidate
)
)
{
return
false
;
}
UpdateConnectionAddress
(
candidates
description
(
)
-
>
contents
(
)
[
index
]
.
media_description
(
)
)
;
return
true
;
}
const
IceCandidateCollection
*
SessionDescriptionInterface
:
:
candidates
(
size_t
mediasection_index
)
const
{
RTC_DCHECK_RUN_ON
(
sequence_checker
(
)
)
;
if
(
mediasection_index
>
=
candidate_collection_
.
size
(
)
)
return
nullptr
;
return
&
candidate_collection_
[
mediasection_index
]
;
}
bool
SessionDescriptionInterface
:
:
ToString
(
std
:
:
string
*
out
)
const
{
if
(
!
description
(
)
|
|
!
out
)
{
return
false
;
}
*
out
=
SdpSerialize
(
*
this
)
;
return
!
out
-
>
empty
(
)
;
}
bool
SessionDescriptionInterface
:
:
IsValidMLineIndex
(
int
index
)
const
{
RTC_DCHECK
(
description
(
)
)
;
return
index
>
=
0
&
&
index
<
static_cast
<
int
>
(
description
(
)
-
>
contents
(
)
.
size
(
)
)
;
}
bool
SessionDescriptionInterface
:
:
GetMediasectionIndex
(
const
IceCandidate
*
candidate
size_t
*
index
)
const
{
if
(
!
candidate
|
|
!
index
|
|
!
description
(
)
)
{
return
false
;
}
auto
mid
=
candidate
-
>
sdp_mid
(
)
;
if
(
!
mid
.
empty
(
)
)
{
*
index
=
GetMediasectionIndex
(
mid
)
;
}
else
{
*
index
=
static_cast
<
size_t
>
(
candidate
-
>
sdp_mline_index
(
)
)
;
}
return
IsValidMLineIndex
(
*
index
)
;
}
int
SessionDescriptionInterface
:
:
GetMediasectionIndex
(
absl
:
:
string_view
mid
)
const
{
const
auto
&
contents
=
description
(
)
-
>
contents
(
)
;
auto
it
=
std
:
:
find_if
(
contents
.
begin
(
)
contents
.
end
(
)
[
&
]
(
const
auto
&
content
)
{
return
mid
=
=
content
.
mid
(
)
;
}
)
;
return
it
=
=
contents
.
end
(
)
?
-
1
:
std
:
:
distance
(
contents
.
begin
(
)
it
)
;
}
}
