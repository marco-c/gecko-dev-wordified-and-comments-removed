#
include
"
pc
/
ice_server_parsing
.
h
"
#
include
<
stddef
.
h
>
#
include
<
cctype
>
#
include
<
string
>
#
include
"
p2p
/
base
/
port_interface
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
namespace
webrtc
{
static
const
size_t
kTurnTransportTokensNum
=
2
;
static
const
int
kDefaultStunPort
=
3478
;
static
const
int
kDefaultStunTlsPort
=
5349
;
static
const
char
kTransport
[
]
=
"
transport
"
;
static
const
char
kRegNameCharacters
[
]
=
"
abcdefghijklmnopqrstuvwxyz
"
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ
"
"
0123456789
"
"
-
.
_
~
"
"
%
"
"
!
&
'
(
)
*
+
;
=
"
;
static
const
char
*
kValidIceServiceTypes
[
]
=
{
"
stun
"
"
stuns
"
"
turn
"
"
turns
"
}
;
enum
ServiceType
{
STUN
=
0
STUNS
TURN
TURNS
INVALID
}
;
static_assert
(
INVALID
=
=
arraysize
(
kValidIceServiceTypes
)
"
kValidIceServiceTypes
must
have
as
many
strings
as
ServiceType
"
"
has
values
.
"
)
;
static
bool
GetServiceTypeAndHostnameFromUri
(
const
std
:
:
string
&
in_str
ServiceType
*
service_type
std
:
:
string
*
hostname
)
{
const
std
:
:
string
:
:
size_type
colonpos
=
in_str
.
find
(
'
:
'
)
;
if
(
colonpos
=
=
std
:
:
string
:
:
npos
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Missing
'
:
'
in
ICE
URI
:
"
<
<
in_str
;
return
false
;
}
if
(
(
colonpos
+
1
)
=
=
in_str
.
length
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Empty
hostname
in
ICE
URI
:
"
<
<
in_str
;
return
false
;
}
*
service_type
=
INVALID
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
kValidIceServiceTypes
)
;
+
+
i
)
{
if
(
in_str
.
compare
(
0
colonpos
kValidIceServiceTypes
[
i
]
)
=
=
0
)
{
*
service_type
=
static_cast
<
ServiceType
>
(
i
)
;
break
;
}
}
if
(
*
service_type
=
=
INVALID
)
{
return
false
;
}
*
hostname
=
in_str
.
substr
(
colonpos
+
1
std
:
:
string
:
:
npos
)
;
return
true
;
}
static
bool
ParsePort
(
const
std
:
:
string
&
in_str
int
*
port
)
{
for
(
const
char
&
c
:
in_str
)
{
if
(
!
std
:
:
isdigit
(
c
)
)
{
return
false
;
}
}
return
rtc
:
:
FromString
(
in_str
port
)
;
}
static
bool
ParseHostnameAndPortFromString
(
const
std
:
:
string
&
in_str
std
:
:
string
*
host
int
*
port
)
{
RTC_DCHECK
(
host
-
>
empty
(
)
)
;
if
(
in_str
.
at
(
0
)
=
=
'
[
'
)
{
std
:
:
string
:
:
size_type
closebracket
=
in_str
.
rfind
(
'
]
'
)
;
if
(
closebracket
!
=
std
:
:
string
:
:
npos
)
{
std
:
:
string
:
:
size_type
colonpos
=
in_str
.
find
(
'
:
'
closebracket
)
;
if
(
std
:
:
string
:
:
npos
!
=
colonpos
)
{
if
(
!
ParsePort
(
in_str
.
substr
(
closebracket
+
2
std
:
:
string
:
:
npos
)
port
)
)
{
return
false
;
}
}
*
host
=
in_str
.
substr
(
1
closebracket
-
1
)
;
}
else
{
return
false
;
}
}
else
{
std
:
:
string
:
:
size_type
colonpos
=
in_str
.
find
(
'
:
'
)
;
if
(
std
:
:
string
:
:
npos
!
=
colonpos
)
{
if
(
!
ParsePort
(
in_str
.
substr
(
colonpos
+
1
std
:
:
string
:
:
npos
)
port
)
)
{
return
false
;
}
*
host
=
in_str
.
substr
(
0
colonpos
)
;
}
else
{
*
host
=
in_str
;
}
if
(
host
-
>
find_first_not_of
(
kRegNameCharacters
)
!
=
std
:
:
string
:
:
npos
)
{
return
false
;
}
}
return
!
host
-
>
empty
(
)
;
}
static
RTCErrorType
ParseIceServerUrl
(
const
PeerConnectionInterface
:
:
IceServer
&
server
const
std
:
:
string
&
url
cricket
:
:
ServerAddresses
*
stun_servers
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
*
turn_servers
)
{
RTC_DCHECK
(
stun_servers
!
=
nullptr
)
;
RTC_DCHECK
(
turn_servers
!
=
nullptr
)
;
std
:
:
vector
<
std
:
:
string
>
tokens
;
cricket
:
:
ProtocolType
turn_transport_type
=
cricket
:
:
PROTO_UDP
;
RTC_DCHECK
(
!
url
.
empty
(
)
)
;
rtc
:
:
tokenize_with_empty_tokens
(
url
'
?
'
&
tokens
)
;
std
:
:
string
uri_without_transport
=
tokens
[
0
]
;
if
(
tokens
.
size
(
)
=
=
kTurnTransportTokensNum
)
{
std
:
:
string
uri_transport_param
=
tokens
[
1
]
;
rtc
:
:
tokenize_with_empty_tokens
(
uri_transport_param
'
=
'
&
tokens
)
;
if
(
tokens
[
0
]
!
=
kTransport
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Invalid
transport
parameter
key
.
"
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
if
(
tokens
.
size
(
)
<
2
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Transport
parameter
missing
value
.
"
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
if
(
!
cricket
:
:
StringToProto
(
tokens
[
1
]
.
c_str
(
)
&
turn_transport_type
)
|
|
(
turn_transport_type
!
=
cricket
:
:
PROTO_UDP
&
&
turn_transport_type
!
=
cricket
:
:
PROTO_TCP
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Transport
parameter
should
always
be
udp
or
tcp
.
"
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
}
std
:
:
string
hoststring
;
ServiceType
service_type
;
if
(
!
GetServiceTypeAndHostnameFromUri
(
uri_without_transport
&
service_type
&
hoststring
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Invalid
transport
parameter
in
ICE
URI
:
"
<
<
url
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
RTC_DCHECK
(
!
hoststring
.
empty
(
)
)
;
int
port
=
kDefaultStunPort
;
if
(
service_type
=
=
TURNS
)
{
port
=
kDefaultStunTlsPort
;
turn_transport_type
=
cricket
:
:
PROTO_TLS
;
}
if
(
hoststring
.
find
(
'
'
)
!
=
std
:
:
string
:
:
npos
)
{
RTC_LOG
(
WARNING
)
<
<
"
Invalid
url
:
"
<
<
uri_without_transport
;
RTC_LOG
(
WARNING
)
<
<
"
Note
that
user
-
info
in
turn
:
-
urls
is
long
-
deprecated
.
"
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
std
:
:
string
address
;
if
(
!
ParseHostnameAndPortFromString
(
hoststring
&
address
&
port
)
)
{
RTC_LOG
(
WARNING
)
<
<
"
Invalid
hostname
format
:
"
<
<
uri_without_transport
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
if
(
port
<
=
0
|
|
port
>
0xffff
)
{
RTC_LOG
(
WARNING
)
<
<
"
Invalid
port
:
"
<
<
port
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
switch
(
service_type
)
{
case
STUN
:
case
STUNS
:
stun_servers
-
>
insert
(
rtc
:
:
SocketAddress
(
address
port
)
)
;
break
;
case
TURN
:
case
TURNS
:
{
if
(
server
.
username
.
empty
(
)
|
|
server
.
password
.
empty
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
TURN
server
with
empty
username
or
password
"
;
return
RTCErrorType
:
:
INVALID_PARAMETER
;
}
const
std
:
:
string
&
hostname
=
server
.
hostname
.
empty
(
)
?
address
:
server
.
hostname
;
rtc
:
:
SocketAddress
socket_address
(
hostname
port
)
;
if
(
!
server
.
hostname
.
empty
(
)
)
{
rtc
:
:
IPAddress
ip
;
if
(
!
IPFromString
(
address
&
ip
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IceServer
has
hostname
field
set
but
URI
does
not
"
"
contain
an
IP
address
.
"
;
return
RTCErrorType
:
:
INVALID_PARAMETER
;
}
socket_address
.
SetResolvedIP
(
ip
)
;
}
cricket
:
:
RelayServerConfig
config
=
cricket
:
:
RelayServerConfig
(
socket_address
server
.
username
server
.
password
turn_transport_type
)
;
if
(
server
.
tls_cert_policy
=
=
PeerConnectionInterface
:
:
kTlsCertPolicyInsecureNoCheck
)
{
config
.
tls_cert_policy
=
cricket
:
:
TlsCertPolicy
:
:
TLS_CERT_POLICY_INSECURE_NO_CHECK
;
}
config
.
tls_alpn_protocols
=
server
.
tls_alpn_protocols
;
config
.
tls_elliptic_curves
=
server
.
tls_elliptic_curves
;
turn_servers
-
>
push_back
(
config
)
;
break
;
}
default
:
RTC_NOTREACHED
(
)
<
<
"
Unexpected
service
type
"
;
return
RTCErrorType
:
:
INTERNAL_ERROR
;
}
return
RTCErrorType
:
:
NONE
;
}
RTCErrorType
ParseIceServers
(
const
PeerConnectionInterface
:
:
IceServers
&
servers
cricket
:
:
ServerAddresses
*
stun_servers
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
*
turn_servers
)
{
for
(
const
PeerConnectionInterface
:
:
IceServer
&
server
:
servers
)
{
if
(
!
server
.
urls
.
empty
(
)
)
{
for
(
const
std
:
:
string
&
url
:
server
.
urls
)
{
if
(
url
.
empty
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Empty
uri
.
"
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
RTCErrorType
err
=
ParseIceServerUrl
(
server
url
stun_servers
turn_servers
)
;
if
(
err
!
=
RTCErrorType
:
:
NONE
)
{
return
err
;
}
}
}
else
if
(
!
server
.
uri
.
empty
(
)
)
{
RTCErrorType
err
=
ParseIceServerUrl
(
server
server
.
uri
stun_servers
turn_servers
)
;
if
(
err
!
=
RTCErrorType
:
:
NONE
)
{
return
err
;
}
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Empty
uri
.
"
;
return
RTCErrorType
:
:
SYNTAX_ERROR
;
}
}
int
priority
=
static_cast
<
int
>
(
turn_servers
-
>
size
(
)
-
1
)
;
for
(
cricket
:
:
RelayServerConfig
&
turn_server
:
*
turn_servers
)
{
turn_server
.
priority
=
priority
-
-
;
}
return
RTCErrorType
:
:
NONE
;
}
}
