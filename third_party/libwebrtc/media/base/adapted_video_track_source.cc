#
include
"
media
/
base
/
adapted_video_track_source
.
h
"
#
include
<
cstdint
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
api
/
video
/
video_source_interface
.
h
"
#
include
"
api
/
video_track_source_constraints
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
AdaptedVideoTrackSource
:
:
AdaptedVideoTrackSource
(
)
=
default
;
AdaptedVideoTrackSource
:
:
AdaptedVideoTrackSource
(
int
required_alignment
)
:
video_adapter_
(
required_alignment
)
{
}
AdaptedVideoTrackSource
:
:
~
AdaptedVideoTrackSource
(
)
=
default
;
bool
AdaptedVideoTrackSource
:
:
GetStats
(
Stats
*
stats
)
{
MutexLock
lock
(
&
stats_mutex_
)
;
if
(
!
stats_
)
{
return
false
;
}
*
stats
=
*
stats_
;
return
true
;
}
void
AdaptedVideoTrackSource
:
:
OnFrame
(
const
VideoFrame
&
frame
)
{
scoped_refptr
<
VideoFrameBuffer
>
buffer
(
frame
.
video_frame_buffer
(
)
)
;
if
(
apply_rotation
(
)
&
&
frame
.
rotation
(
)
!
=
webrtc
:
:
kVideoRotation_0
&
&
buffer
-
>
type
(
)
=
=
VideoFrameBuffer
:
:
Type
:
:
kI420
)
{
VideoFrame
rotated_frame
(
frame
)
;
rotated_frame
.
set_video_frame_buffer
(
I420Buffer
:
:
Rotate
(
*
buffer
-
>
GetI420
(
)
frame
.
rotation
(
)
)
)
;
rotated_frame
.
set_rotation
(
webrtc
:
:
kVideoRotation_0
)
;
broadcaster_
.
OnFrame
(
rotated_frame
)
;
}
else
{
broadcaster_
.
OnFrame
(
frame
)
;
}
}
void
AdaptedVideoTrackSource
:
:
OnFrameDropped
(
)
{
broadcaster_
.
OnDiscardedFrame
(
)
;
}
void
AdaptedVideoTrackSource
:
:
AddOrUpdateSink
(
VideoSinkInterface
<
VideoFrame
>
*
sink
const
VideoSinkWants
&
wants
)
{
broadcaster_
.
AddOrUpdateSink
(
sink
wants
)
;
OnSinkWantsChanged
(
broadcaster_
.
wants
(
)
)
;
}
void
AdaptedVideoTrackSource
:
:
RemoveSink
(
VideoSinkInterface
<
VideoFrame
>
*
sink
)
{
broadcaster_
.
RemoveSink
(
sink
)
;
OnSinkWantsChanged
(
broadcaster_
.
wants
(
)
)
;
}
bool
AdaptedVideoTrackSource
:
:
apply_rotation
(
)
{
return
broadcaster_
.
wants
(
)
.
rotation_applied
;
}
void
AdaptedVideoTrackSource
:
:
OnSinkWantsChanged
(
const
VideoSinkWants
&
wants
)
{
video_adapter_
.
OnSinkWants
(
wants
)
;
}
bool
AdaptedVideoTrackSource
:
:
AdaptFrame
(
int
width
int
height
int64_t
time_us
int
*
out_width
int
*
out_height
int
*
crop_width
int
*
crop_height
int
*
crop_x
int
*
crop_y
)
{
{
MutexLock
lock
(
&
stats_mutex_
)
;
stats_
=
Stats
{
width
height
}
;
}
if
(
!
broadcaster_
.
frame_wanted
(
)
)
{
return
false
;
}
if
(
!
video_adapter_
.
AdaptFrameResolution
(
width
height
time_us
*
webrtc
:
:
kNumNanosecsPerMicrosec
crop_width
crop_height
out_width
out_height
)
)
{
broadcaster_
.
OnDiscardedFrame
(
)
;
return
false
;
}
*
crop_x
=
(
width
-
*
crop_width
)
/
2
;
*
crop_y
=
(
height
-
*
crop_height
)
/
2
;
return
true
;
}
void
AdaptedVideoTrackSource
:
:
ProcessConstraints
(
const
VideoTrackSourceConstraints
&
constraints
)
{
broadcaster_
.
ProcessConstraints
(
constraints
)
;
}
}
