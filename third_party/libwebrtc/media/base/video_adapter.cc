#
include
"
media
/
base
/
video_adapter
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
limits
>
#
include
<
utility
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
media
/
base
/
video_common
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
namespace
{
struct
Fraction
{
int
numerator
;
int
denominator
;
void
DivideByGcd
(
)
{
int
g
=
cricket
:
:
GreatestCommonDivisor
(
numerator
denominator
)
;
numerator
/
=
g
;
denominator
/
=
g
;
}
int
scale_pixel_count
(
int
input_pixels
)
{
return
(
numerator
*
numerator
*
input_pixels
)
/
(
denominator
*
denominator
)
;
}
}
;
int
roundUp
(
int
value_to_round
int
multiple
int
max_value
)
{
const
int
rounded_value
=
(
value_to_round
+
multiple
-
1
)
/
multiple
*
multiple
;
return
rounded_value
<
=
max_value
?
rounded_value
:
(
max_value
/
multiple
*
multiple
)
;
}
Fraction
FindScale
(
int
input_width
int
input_height
int
target_pixels
int
max_pixels
bool
variable_start_scale_factor
)
{
RTC_DCHECK_GT
(
target_pixels
0
)
;
RTC_DCHECK_GT
(
max_pixels
0
)
;
RTC_DCHECK_GE
(
max_pixels
target_pixels
)
;
const
int
input_pixels
=
input_width
*
input_height
;
if
(
target_pixels
>
=
input_pixels
)
return
Fraction
{
1
1
}
;
Fraction
current_scale
=
Fraction
{
1
1
}
;
Fraction
best_scale
=
Fraction
{
1
1
}
;
if
(
variable_start_scale_factor
)
{
if
(
input_width
%
3
=
=
0
&
&
input_height
%
3
=
=
0
)
{
current_scale
=
Fraction
{
6
6
}
;
}
if
(
input_width
%
9
=
=
0
&
&
input_height
%
9
=
=
0
)
{
current_scale
=
Fraction
{
36
36
}
;
}
}
int
min_pixel_diff
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
if
(
input_pixels
<
=
max_pixels
)
{
min_pixel_diff
=
std
:
:
abs
(
input_pixels
-
target_pixels
)
;
}
while
(
current_scale
.
scale_pixel_count
(
input_pixels
)
>
target_pixels
)
{
if
(
current_scale
.
numerator
%
3
=
=
0
&
&
current_scale
.
denominator
%
2
=
=
0
)
{
current_scale
.
numerator
/
=
3
;
current_scale
.
denominator
/
=
2
;
}
else
{
current_scale
.
numerator
*
=
3
;
current_scale
.
denominator
*
=
4
;
}
int
output_pixels
=
current_scale
.
scale_pixel_count
(
input_pixels
)
;
if
(
output_pixels
<
=
max_pixels
)
{
int
diff
=
std
:
:
abs
(
target_pixels
-
output_pixels
)
;
if
(
diff
<
min_pixel_diff
)
{
min_pixel_diff
=
diff
;
best_scale
=
current_scale
;
}
}
}
best_scale
.
DivideByGcd
(
)
;
return
best_scale
;
}
}
namespace
cricket
{
VideoAdapter
:
:
VideoAdapter
(
int
source_resolution_alignment
)
:
frames_in_
(
0
)
frames_out_
(
0
)
frames_scaled_
(
0
)
adaption_changes_
(
0
)
previous_width_
(
0
)
previous_height_
(
0
)
variable_start_scale_factor_
(
!
webrtc
:
:
field_trial
:
:
IsDisabled
(
"
WebRTC
-
Video
-
VariableStartScaleFactor
"
)
)
source_resolution_alignment_
(
source_resolution_alignment
)
resolution_alignment_
(
source_resolution_alignment
)
resolution_request_target_pixel_count_
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
resolution_request_max_pixel_count_
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
max_framerate_request_
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
}
VideoAdapter
:
:
VideoAdapter
(
)
:
VideoAdapter
(
1
)
{
}
VideoAdapter
:
:
~
VideoAdapter
(
)
{
}
bool
VideoAdapter
:
:
DropFrame
(
int64_t
in_timestamp_ns
)
{
int
max_fps
=
max_framerate_request_
;
if
(
max_fps_
)
max_fps
=
std
:
:
min
(
max_fps
*
max_fps_
)
;
framerate_controller_
.
SetMaxFramerate
(
max_fps
)
;
return
framerate_controller_
.
ShouldDropFrame
(
in_timestamp_ns
)
;
}
bool
VideoAdapter
:
:
AdaptFrameResolution
(
int
in_width
int
in_height
int64_t
in_timestamp_ns
int
*
cropped_width
int
*
cropped_height
int
*
out_width
int
*
out_height
)
{
webrtc
:
:
MutexLock
lock
(
&
mutex_
)
;
+
+
frames_in_
;
int
max_pixel_count
=
resolution_request_max_pixel_count_
;
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
target_aspect_ratio
;
if
(
in_width
>
in_height
)
{
target_aspect_ratio
=
target_landscape_aspect_ratio_
;
if
(
max_landscape_pixel_count_
)
max_pixel_count
=
std
:
:
min
(
max_pixel_count
*
max_landscape_pixel_count_
)
;
}
else
{
target_aspect_ratio
=
target_portrait_aspect_ratio_
;
if
(
max_portrait_pixel_count_
)
max_pixel_count
=
std
:
:
min
(
max_pixel_count
*
max_portrait_pixel_count_
)
;
}
if
(
scale_
)
{
int
scaled_pixel_count
=
(
in_width
*
in_height
/
scale_resolution_by_
)
/
scale_resolution_by_
;
max_pixel_count
=
std
:
:
min
(
max_pixel_count
scaled_pixel_count
)
;
}
int
target_pixel_count
=
std
:
:
min
(
resolution_request_target_pixel_count_
max_pixel_count
)
;
if
(
max_pixel_count
<
=
0
|
|
DropFrame
(
in_timestamp_ns
)
)
{
if
(
(
frames_in_
-
frames_out_
)
%
90
=
=
0
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
VAdapt
Drop
Frame
:
scaled
"
<
<
frames_scaled_
<
<
"
/
out
"
<
<
frames_out_
<
<
"
/
in
"
<
<
frames_in_
<
<
"
Changes
:
"
<
<
adaption_changes_
<
<
"
Input
:
"
<
<
in_width
<
<
"
x
"
<
<
in_height
<
<
"
timestamp
:
"
<
<
in_timestamp_ns
<
<
"
Output
fps
:
"
<
<
max_framerate_request_
<
<
"
/
"
<
<
max_fps_
.
value_or
(
-
1
)
<
<
"
alignment
:
"
<
<
resolution_alignment_
;
}
return
false
;
}
if
(
!
target_aspect_ratio
|
|
target_aspect_ratio
-
>
first
<
=
0
|
|
target_aspect_ratio
-
>
second
<
=
0
)
{
*
cropped_width
=
in_width
;
*
cropped_height
=
in_height
;
}
else
{
const
float
requested_aspect
=
target_aspect_ratio
-
>
first
/
static_cast
<
float
>
(
target_aspect_ratio
-
>
second
)
;
*
cropped_width
=
std
:
:
min
(
in_width
static_cast
<
int
>
(
in_height
*
requested_aspect
)
)
;
*
cropped_height
=
std
:
:
min
(
in_height
static_cast
<
int
>
(
in_width
/
requested_aspect
)
)
;
}
const
Fraction
scale
=
FindScale
(
*
cropped_width
*
cropped_height
target_pixel_count
max_pixel_count
variable_start_scale_factor_
)
;
*
cropped_width
=
roundUp
(
*
cropped_width
scale
.
denominator
*
resolution_alignment_
in_width
)
;
*
cropped_height
=
roundUp
(
*
cropped_height
scale
.
denominator
*
resolution_alignment_
in_height
)
;
RTC_DCHECK_EQ
(
0
*
cropped_width
%
scale
.
denominator
)
;
RTC_DCHECK_EQ
(
0
*
cropped_height
%
scale
.
denominator
)
;
*
out_width
=
*
cropped_width
/
scale
.
denominator
*
scale
.
numerator
;
*
out_height
=
*
cropped_height
/
scale
.
denominator
*
scale
.
numerator
;
RTC_DCHECK_EQ
(
0
*
out_width
%
resolution_alignment_
)
;
RTC_DCHECK_EQ
(
0
*
out_height
%
resolution_alignment_
)
;
+
+
frames_out_
;
if
(
scale
.
numerator
!
=
scale
.
denominator
)
+
+
frames_scaled_
;
if
(
(
previous_width_
|
|
scale_
)
&
&
(
previous_width_
!
=
*
out_width
|
|
previous_height_
!
=
*
out_height
)
)
{
+
+
adaption_changes_
;
RTC_LOG
(
LS_INFO
)
<
<
"
Frame
size
changed
:
scaled
"
<
<
frames_scaled_
<
<
"
/
out
"
<
<
frames_out_
<
<
"
/
in
"
<
<
frames_in_
<
<
"
Changes
:
"
<
<
adaption_changes_
<
<
"
Input
:
"
<
<
in_width
<
<
"
x
"
<
<
in_height
<
<
"
Scale
:
"
<
<
scale
.
numerator
<
<
"
/
"
<
<
scale
.
denominator
<
<
"
Output
:
"
<
<
*
out_width
<
<
"
x
"
<
<
*
out_height
<
<
"
fps
:
"
<
<
max_framerate_request_
<
<
"
/
"
<
<
max_fps_
.
value_or
(
-
1
)
<
<
"
alignment
:
"
<
<
resolution_alignment_
;
}
previous_width_
=
*
out_width
;
previous_height_
=
*
out_height
;
return
true
;
}
void
VideoAdapter
:
:
OnOutputFormatRequest
(
const
absl
:
:
optional
<
VideoFormat
>
&
format
)
{
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
target_aspect_ratio
;
absl
:
:
optional
<
int
>
max_pixel_count
;
absl
:
:
optional
<
int
>
max_fps
;
if
(
format
)
{
target_aspect_ratio
=
std
:
:
make_pair
(
format
-
>
width
format
-
>
height
)
;
max_pixel_count
=
format
-
>
width
*
format
-
>
height
;
if
(
format
-
>
interval
>
0
)
max_fps
=
rtc
:
:
kNumNanosecsPerSec
/
format
-
>
interval
;
}
OnOutputFormatRequest
(
target_aspect_ratio
max_pixel_count
max_fps
)
;
}
void
VideoAdapter
:
:
OnOutputFormatRequest
(
const
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
&
target_aspect_ratio
const
absl
:
:
optional
<
int
>
&
max_pixel_count
const
absl
:
:
optional
<
int
>
&
max_fps
)
{
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
target_landscape_aspect_ratio
;
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
target_portrait_aspect_ratio
;
if
(
target_aspect_ratio
&
&
target_aspect_ratio
-
>
first
>
0
&
&
target_aspect_ratio
-
>
second
>
0
)
{
const
int
max_side
=
std
:
:
max
(
target_aspect_ratio
-
>
first
target_aspect_ratio
-
>
second
)
;
const
int
min_side
=
std
:
:
min
(
target_aspect_ratio
-
>
first
target_aspect_ratio
-
>
second
)
;
target_landscape_aspect_ratio
=
std
:
:
make_pair
(
max_side
min_side
)
;
target_portrait_aspect_ratio
=
std
:
:
make_pair
(
min_side
max_side
)
;
}
OnOutputFormatRequest
(
target_landscape_aspect_ratio
max_pixel_count
target_portrait_aspect_ratio
max_pixel_count
max_fps
)
;
}
void
VideoAdapter
:
:
OnOutputFormatRequest
(
const
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
&
target_landscape_aspect_ratio
const
absl
:
:
optional
<
int
>
&
max_landscape_pixel_count
const
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
&
target_portrait_aspect_ratio
const
absl
:
:
optional
<
int
>
&
max_portrait_pixel_count
const
absl
:
:
optional
<
int
>
&
max_fps
)
{
webrtc
:
:
MutexLock
lock
(
&
mutex_
)
;
target_landscape_aspect_ratio_
=
target_landscape_aspect_ratio
;
max_landscape_pixel_count_
=
max_landscape_pixel_count
;
target_portrait_aspect_ratio_
=
target_portrait_aspect_ratio
;
max_portrait_pixel_count_
=
max_portrait_pixel_count
;
max_fps_
=
max_fps
;
framerate_controller_
.
Reset
(
)
;
}
void
VideoAdapter
:
:
OnSinkWants
(
const
rtc
:
:
VideoSinkWants
&
sink_wants
)
{
webrtc
:
:
MutexLock
lock
(
&
mutex_
)
;
resolution_request_max_pixel_count_
=
sink_wants
.
max_pixel_count
;
resolution_request_target_pixel_count_
=
sink_wants
.
target_pixel_count
.
value_or
(
resolution_request_max_pixel_count_
)
;
max_framerate_request_
=
sink_wants
.
max_framerate_fps
;
resolution_alignment_
=
cricket
:
:
LeastCommonMultiple
(
source_resolution_alignment_
sink_wants
.
resolution_alignment
)
;
}
int
VideoAdapter
:
:
GetTargetPixels
(
)
const
{
webrtc
:
:
MutexLock
lock
(
&
mutex_
)
;
return
resolution_request_target_pixel_count_
;
}
float
VideoAdapter
:
:
GetMaxFramerate
(
)
const
{
webrtc
:
:
MutexLock
lock
(
&
mutex_
)
;
int
framerate
=
std
:
:
min
(
max_framerate_request_
max_fps_
.
value_or
(
max_framerate_request_
)
)
;
if
(
framerate
=
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
return
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
}
else
{
return
max_framerate_request_
;
}
}
void
VideoAdapter
:
:
OnScaleResolutionBy
(
absl
:
:
optional
<
float
>
scale_resolution_by
)
{
webrtc
:
:
MutexLock
lock
(
&
mutex_
)
;
scale_resolution_by_
=
scale_resolution_by
.
value_or
(
1
.
0
)
;
RTC_DCHECK_GE
(
scale_resolution_by_
1
.
0
)
;
scale_
=
static_cast
<
bool
>
(
scale_resolution_by
)
;
}
}
