#
include
"
media
/
base
/
sdp_video_format_utils
.
h
"
#
include
<
cstring
>
#
include
<
map
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
api
/
video_codecs
/
h264_profile_level_id
.
h
"
#
ifdef
RTC_ENABLE_H265
#
include
"
api
/
video_codecs
/
h265_profile_tier_level
.
h
"
#
endif
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
string_to_number
.
h
"
namespace
webrtc
{
namespace
{
const
char
kProfileLevelId
[
]
=
"
profile
-
level
-
id
"
;
const
char
kH264LevelAsymmetryAllowed
[
]
=
"
level
-
asymmetry
-
allowed
"
;
const
char
kVPxFmtpMaxFrameRate
[
]
=
"
max
-
fr
"
;
const
char
kVPxFmtpMaxFrameSize
[
]
=
"
max
-
fs
"
;
const
int
kVPxFmtpFrameSizeSubBlockPixels
=
256
;
#
ifdef
RTC_ENABLE_H265
constexpr
char
kH265ProfileId
[
]
=
"
profile
-
id
"
;
constexpr
char
kH265TierFlag
[
]
=
"
tier
-
flag
"
;
constexpr
char
kH265LevelId
[
]
=
"
level
-
id
"
;
#
endif
bool
IsH264LevelAsymmetryAllowed
(
const
CodecParameterMap
&
params
)
{
const
auto
it
=
params
.
find
(
kH264LevelAsymmetryAllowed
)
;
return
it
!
=
params
.
end
(
)
&
&
strcmp
(
it
-
>
second
.
c_str
(
)
"
1
"
)
=
=
0
;
}
bool
H264LevelIsLess
(
H264Level
a
H264Level
b
)
{
if
(
a
=
=
H264Level
:
:
kLevel1_b
)
return
b
!
=
H264Level
:
:
kLevel1
&
&
b
!
=
H264Level
:
:
kLevel1_b
;
if
(
b
=
=
H264Level
:
:
kLevel1_b
)
return
a
=
=
H264Level
:
:
kLevel1
;
return
a
<
b
;
}
H264Level
H264LevelMin
(
H264Level
a
H264Level
b
)
{
return
H264LevelIsLess
(
a
b
)
?
a
:
b
;
}
std
:
:
optional
<
int
>
ParsePositiveNumberFromParams
(
const
CodecParameterMap
&
params
const
char
*
parameter_name
)
{
const
auto
max_frame_rate_it
=
params
.
find
(
parameter_name
)
;
if
(
max_frame_rate_it
=
=
params
.
end
(
)
)
return
std
:
:
nullopt
;
const
std
:
:
optional
<
int
>
i
=
StringToNumber
<
int
>
(
max_frame_rate_it
-
>
second
)
;
if
(
!
i
.
has_value
(
)
|
|
i
.
value
(
)
<
=
0
)
return
std
:
:
nullopt
;
return
i
;
}
#
ifdef
RTC_ENABLE_H265
H265Level
H265LevelMin
(
H265Level
a
H265Level
b
)
{
return
a
<
=
b
?
a
:
b
;
}
bool
IsDefaultH265PTL
(
const
CodecParameterMap
&
params
)
{
return
!
params
.
count
(
kH265ProfileId
)
&
&
!
params
.
count
(
kH265TierFlag
)
&
&
!
params
.
count
(
kH265LevelId
)
;
}
#
endif
}
#
ifdef
RTC_ENABLE_H265
void
H265GenerateProfileTierLevelForAnswer
(
const
CodecParameterMap
&
local_supported_params
const
CodecParameterMap
&
remote_offered_params
CodecParameterMap
*
answer_params
)
{
if
(
IsDefaultH265PTL
(
local_supported_params
)
&
&
IsDefaultH265PTL
(
remote_offered_params
)
)
{
return
;
}
const
std
:
:
optional
<
H265ProfileTierLevel
>
local_profile_tier_level
=
ParseSdpForH265ProfileTierLevel
(
local_supported_params
)
;
const
std
:
:
optional
<
H265ProfileTierLevel
>
remote_profile_tier_level
=
ParseSdpForH265ProfileTierLevel
(
remote_offered_params
)
;
RTC_DCHECK
(
local_profile_tier_level
)
;
RTC_DCHECK
(
remote_profile_tier_level
)
;
RTC_DCHECK_EQ
(
local_profile_tier_level
-
>
profile
remote_profile_tier_level
-
>
profile
)
;
RTC_DCHECK_EQ
(
local_profile_tier_level
-
>
tier
remote_profile_tier_level
-
>
tier
)
;
const
H265Level
answer_level
=
H265LevelMin
(
local_profile_tier_level
-
>
level
remote_profile_tier_level
-
>
level
)
;
(
*
answer_params
)
[
kH265LevelId
]
=
H265LevelToString
(
answer_level
)
;
}
#
endif
void
H264GenerateProfileLevelIdForAnswer
(
const
CodecParameterMap
&
local_supported_params
const
CodecParameterMap
&
remote_offered_params
CodecParameterMap
*
answer_params
)
{
if
(
!
local_supported_params
.
count
(
kProfileLevelId
)
&
&
!
remote_offered_params
.
count
(
kProfileLevelId
)
)
{
return
;
}
const
std
:
:
optional
<
H264ProfileLevelId
>
local_profile_level_id
=
ParseSdpForH264ProfileLevelId
(
local_supported_params
)
;
const
std
:
:
optional
<
H264ProfileLevelId
>
remote_profile_level_id
=
ParseSdpForH264ProfileLevelId
(
remote_offered_params
)
;
RTC_DCHECK
(
local_profile_level_id
)
;
RTC_DCHECK
(
remote_profile_level_id
)
;
RTC_DCHECK_EQ
(
local_profile_level_id
-
>
profile
remote_profile_level_id
-
>
profile
)
;
const
bool
level_asymmetry_allowed
=
IsH264LevelAsymmetryAllowed
(
local_supported_params
)
&
&
IsH264LevelAsymmetryAllowed
(
remote_offered_params
)
;
const
H264Level
local_level
=
local_profile_level_id
-
>
level
;
const
H264Level
remote_level
=
remote_profile_level_id
-
>
level
;
const
H264Level
min_level
=
H264LevelMin
(
local_level
remote_level
)
;
const
H264Level
answer_level
=
level_asymmetry_allowed
?
local_level
:
min_level
;
(
*
answer_params
)
[
kProfileLevelId
]
=
*
H264ProfileLevelIdToString
(
H264ProfileLevelId
(
local_profile_level_id
-
>
profile
answer_level
)
)
;
}
std
:
:
optional
<
int
>
ParseSdpForVPxMaxFrameRate
(
const
CodecParameterMap
&
params
)
{
return
ParsePositiveNumberFromParams
(
params
kVPxFmtpMaxFrameRate
)
;
}
std
:
:
optional
<
int
>
ParseSdpForVPxMaxFrameSize
(
const
CodecParameterMap
&
params
)
{
const
std
:
:
optional
<
int
>
i
=
ParsePositiveNumberFromParams
(
params
kVPxFmtpMaxFrameSize
)
;
return
i
?
std
:
:
make_optional
(
i
.
value
(
)
*
kVPxFmtpFrameSizeSubBlockPixels
)
:
std
:
:
nullopt
;
}
bool
SupportsPerLayerPictureLossIndication
(
const
CodecParameterMap
&
params
)
{
return
absl
:
:
c_find_if
(
params
[
]
(
const
std
:
:
pair
<
std
:
:
string
std
:
:
string
>
&
kv
)
{
return
kv
.
first
=
=
kCodecParamPerLayerPictureLossIndication
&
&
kv
.
second
=
=
"
1
"
;
}
)
!
=
params
.
end
(
)
;
}
}
