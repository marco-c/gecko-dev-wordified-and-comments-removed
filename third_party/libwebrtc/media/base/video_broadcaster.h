#
ifndef
MEDIA_BASE_VIDEO_BROADCASTER_H_
#
define
MEDIA_BASE_VIDEO_BROADCASTER_H_
#
include
<
optional
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
api
/
video
/
video_source_interface
.
h
"
#
include
"
api
/
video_track_source_constraints
.
h
"
#
include
"
media
/
base
/
video_source_base
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
VideoBroadcaster
:
public
VideoSourceBase
public
VideoSinkInterface
<
VideoFrame
>
{
public
:
VideoBroadcaster
(
)
;
~
VideoBroadcaster
(
)
override
;
void
AddOrUpdateSink
(
VideoSinkInterface
<
VideoFrame
>
*
sink
const
VideoSinkWants
&
wants
)
override
;
void
RemoveSink
(
VideoSinkInterface
<
VideoFrame
>
*
sink
)
override
;
bool
frame_wanted
(
)
const
;
VideoSinkWants
wants
(
)
const
;
void
OnFrame
(
const
VideoFrame
&
frame
)
override
;
void
OnDiscardedFrame
(
)
override
;
void
ProcessConstraints
(
const
VideoTrackSourceConstraints
&
constraints
)
;
protected
:
void
UpdateWants
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
sinks_and_wants_lock_
)
;
const
scoped_refptr
<
VideoFrameBuffer
>
&
GetBlackFrameBuffer
(
int
width
int
height
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
sinks_and_wants_lock_
)
;
mutable
Mutex
sinks_and_wants_lock_
;
VideoSinkWants
current_wants_
RTC_GUARDED_BY
(
sinks_and_wants_lock_
)
;
scoped_refptr
<
VideoFrameBuffer
>
black_frame_buffer_
;
bool
previous_frame_sent_to_all_sinks_
RTC_GUARDED_BY
(
sinks_and_wants_lock_
)
=
true
;
std
:
:
optional
<
VideoTrackSourceConstraints
>
last_constraints_
RTC_GUARDED_BY
(
sinks_and_wants_lock_
)
;
}
;
}
namespace
rtc
{
using
:
:
webrtc
:
:
VideoBroadcaster
;
}
#
endif
