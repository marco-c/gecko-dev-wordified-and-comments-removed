#
include
"
media
/
base
/
video_broadcaster
.
h
"
#
include
<
algorithm
>
#
include
<
numeric
>
#
include
<
optional
>
#
include
<
vector
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
api
/
video
/
video_source_interface
.
h
"
#
include
"
api
/
video_track_source_constraints
.
h
"
#
include
"
media
/
base
/
video_source_base
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
webrtc
{
VideoBroadcaster
:
:
VideoBroadcaster
(
)
=
default
;
VideoBroadcaster
:
:
~
VideoBroadcaster
(
)
=
default
;
void
VideoBroadcaster
:
:
AddOrUpdateSink
(
VideoSinkInterface
<
VideoFrame
>
*
sink
const
VideoSinkWants
&
wants
)
{
RTC_DCHECK
(
sink
!
=
nullptr
)
;
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
if
(
!
FindSinkPair
(
sink
)
)
{
previous_frame_sent_to_all_sinks_
=
false
;
if
(
last_constraints_
.
has_value
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
__func__
<
<
"
forwarding
stored
constraints
min_fps
"
<
<
last_constraints_
-
>
min_fps
.
value_or
(
-
1
)
<
<
"
max_fps
"
<
<
last_constraints_
-
>
max_fps
.
value_or
(
-
1
)
;
sink
-
>
OnConstraintsChanged
(
*
last_constraints_
)
;
}
}
VideoSourceBase
:
:
AddOrUpdateSink
(
sink
wants
)
;
UpdateWants
(
)
;
}
void
VideoBroadcaster
:
:
RemoveSink
(
VideoSinkInterface
<
VideoFrame
>
*
sink
)
{
RTC_DCHECK
(
sink
!
=
nullptr
)
;
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
VideoSourceBase
:
:
RemoveSink
(
sink
)
;
UpdateWants
(
)
;
}
bool
VideoBroadcaster
:
:
frame_wanted
(
)
const
{
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
return
!
sink_pairs
(
)
.
empty
(
)
;
}
VideoSinkWants
VideoBroadcaster
:
:
wants
(
)
const
{
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
return
current_wants_
;
}
void
VideoBroadcaster
:
:
OnFrame
(
const
VideoFrame
&
frame
)
{
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
bool
current_frame_was_discarded
=
false
;
for
(
auto
&
sink_pair
:
sink_pairs
(
)
)
{
if
(
sink_pair
.
wants
.
rotation_applied
&
&
frame
.
rotation
(
)
!
=
webrtc
:
:
kVideoRotation_0
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Discarding
frame
with
unexpected
rotation
.
"
;
sink_pair
.
sink
-
>
OnDiscardedFrame
(
)
;
current_frame_was_discarded
=
true
;
continue
;
}
if
(
sink_pair
.
wants
.
black_frames
)
{
VideoFrame
black_frame
=
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
GetBlackFrameBuffer
(
frame
.
width
(
)
frame
.
height
(
)
)
)
.
set_rotation
(
frame
.
rotation
(
)
)
.
set_timestamp_us
(
frame
.
timestamp_us
(
)
)
.
set_id
(
frame
.
id
(
)
)
.
build
(
)
;
sink_pair
.
sink
-
>
OnFrame
(
black_frame
)
;
}
else
if
(
!
previous_frame_sent_to_all_sinks_
&
&
frame
.
has_update_rect
(
)
)
{
VideoFrame
copy
=
frame
;
copy
.
clear_update_rect
(
)
;
sink_pair
.
sink
-
>
OnFrame
(
copy
)
;
}
else
{
sink_pair
.
sink
-
>
OnFrame
(
frame
)
;
}
}
previous_frame_sent_to_all_sinks_
=
!
current_frame_was_discarded
;
}
void
VideoBroadcaster
:
:
OnDiscardedFrame
(
)
{
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
for
(
auto
&
sink_pair
:
sink_pairs
(
)
)
{
sink_pair
.
sink
-
>
OnDiscardedFrame
(
)
;
}
}
void
VideoBroadcaster
:
:
ProcessConstraints
(
const
VideoTrackSourceConstraints
&
constraints
)
{
MutexLock
lock
(
&
sinks_and_wants_lock_
)
;
RTC_LOG
(
LS_INFO
)
<
<
__func__
<
<
"
min_fps
"
<
<
constraints
.
min_fps
.
value_or
(
-
1
)
<
<
"
max_fps
"
<
<
constraints
.
max_fps
.
value_or
(
-
1
)
<
<
"
broadcasting
to
"
<
<
sink_pairs
(
)
.
size
(
)
<
<
"
sinks
.
"
;
last_constraints_
=
constraints
;
for
(
auto
&
sink_pair
:
sink_pairs
(
)
)
sink_pair
.
sink
-
>
OnConstraintsChanged
(
constraints
)
;
}
void
VideoBroadcaster
:
:
UpdateWants
(
)
{
VideoSinkWants
wants
;
wants
.
rotation_applied
=
false
;
wants
.
resolution_alignment
=
1
;
wants
.
aggregates
.
emplace
(
VideoSinkWants
:
:
Aggregates
(
)
)
;
wants
.
is_active
=
false
;
bool
ignore_inactive_encoders_old_api
=
false
;
for
(
auto
&
sink
:
sink_pairs
(
)
)
{
if
(
sink
.
wants
.
is_active
&
&
sink
.
wants
.
requested_resolution
.
has_value
(
)
)
{
ignore_inactive_encoders_old_api
=
true
;
break
;
}
}
for
(
auto
&
sink
:
sink_pairs
(
)
)
{
if
(
!
sink
.
wants
.
is_active
&
&
(
sink
.
wants
.
requested_resolution
|
|
ignore_inactive_encoders_old_api
)
)
{
continue
;
}
if
(
sink
.
wants
.
rotation_applied
)
{
wants
.
rotation_applied
=
true
;
}
if
(
sink
.
wants
.
max_pixel_count
<
wants
.
max_pixel_count
)
{
wants
.
max_pixel_count
=
sink
.
wants
.
max_pixel_count
;
}
if
(
sink
.
wants
.
target_pixel_count
&
&
(
!
wants
.
target_pixel_count
|
|
(
*
sink
.
wants
.
target_pixel_count
<
*
wants
.
target_pixel_count
)
)
)
{
wants
.
target_pixel_count
=
sink
.
wants
.
target_pixel_count
;
}
if
(
sink
.
wants
.
max_framerate_fps
<
wants
.
max_framerate_fps
)
{
wants
.
max_framerate_fps
=
sink
.
wants
.
max_framerate_fps
;
}
wants
.
resolution_alignment
=
std
:
:
lcm
(
wants
.
resolution_alignment
sink
.
wants
.
resolution_alignment
)
;
if
(
sink
.
wants
.
requested_resolution
)
{
if
(
!
wants
.
requested_resolution
)
{
wants
.
requested_resolution
=
sink
.
wants
.
requested_resolution
;
}
else
{
wants
.
requested_resolution
-
>
width
=
std
:
:
max
(
wants
.
requested_resolution
-
>
width
sink
.
wants
.
requested_resolution
-
>
width
)
;
wants
.
requested_resolution
-
>
height
=
std
:
:
max
(
wants
.
requested_resolution
-
>
height
sink
.
wants
.
requested_resolution
-
>
height
)
;
}
}
else
if
(
sink
.
wants
.
is_active
)
{
wants
.
aggregates
-
>
any_active_without_requested_resolution
=
true
;
}
wants
.
is_active
|
=
sink
.
wants
.
is_active
;
}
if
(
wants
.
target_pixel_count
&
&
*
wants
.
target_pixel_count
>
=
wants
.
max_pixel_count
)
{
wants
.
target_pixel_count
.
emplace
(
wants
.
max_pixel_count
)
;
}
current_wants_
=
wants
;
}
const
scoped_refptr
<
VideoFrameBuffer
>
&
VideoBroadcaster
:
:
GetBlackFrameBuffer
(
int
width
int
height
)
{
if
(
!
black_frame_buffer_
|
|
black_frame_buffer_
-
>
width
(
)
!
=
width
|
|
black_frame_buffer_
-
>
height
(
)
!
=
height
)
{
scoped_refptr
<
I420Buffer
>
buffer
=
I420Buffer
:
:
Create
(
width
height
)
;
I420Buffer
:
:
SetBlack
(
buffer
.
get
(
)
)
;
black_frame_buffer_
=
buffer
;
}
return
black_frame_buffer_
;
}
}
