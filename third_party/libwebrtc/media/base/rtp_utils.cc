#
include
"
media
/
base
/
rtp_utils
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
media
/
base
/
turn_utils
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_util
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
byte_order
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
message_digest
.
h
"
namespace
webrtc
{
static
const
size_t
kRtcpPayloadTypeOffset
=
1
;
static
const
size_t
kRtpExtensionHeaderLen
=
4
;
static
const
size_t
kAbsSendTimeExtensionLen
=
3
;
static
const
size_t
kOneByteExtensionHeaderLen
=
1
;
static
const
size_t
kTwoByteExtensionHeaderLen
=
2
;
namespace
{
const
uint8_t
kFakeAuthTag
[
10
]
=
{
0xba
0xdd
0xba
0xdd
0xba
0xdd
0xba
0xdd
0xba
0xdd
}
;
void
UpdateAbsSendTimeExtensionValue
(
uint8_t
*
extension_data
size_t
length
uint64_t
time_us
)
{
if
(
length
!
=
kAbsSendTimeExtensionLen
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
uint32_t
send_time
=
(
(
time_us
<
<
18
)
/
1000000
)
&
0x00FFFFFF
;
extension_data
[
0
]
=
static_cast
<
uint8_t
>
(
send_time
>
>
16
)
;
extension_data
[
1
]
=
static_cast
<
uint8_t
>
(
send_time
>
>
8
)
;
extension_data
[
2
]
=
static_cast
<
uint8_t
>
(
send_time
)
;
}
void
UpdateRtpAuthTag
(
ArrayView
<
uint8_t
>
rtp
const
PacketTimeUpdateParams
&
packet_time_params
)
{
if
(
packet_time_params
.
srtp_auth_key
.
empty
(
)
)
{
return
;
}
size_t
tag_length
=
packet_time_params
.
srtp_auth_tag_len
;
const
size_t
kRocLength
=
4
;
if
(
tag_length
<
kRocLength
|
|
tag_length
>
rtp
.
size
(
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
uint8_t
*
auth_tag
=
rtp
.
data
(
)
+
(
rtp
.
size
(
)
-
tag_length
)
;
RTC_DCHECK_EQ
(
0
memcmp
(
auth_tag
kFakeAuthTag
tag_length
)
)
;
memcpy
(
auth_tag
&
packet_time_params
.
srtp_packet_index
kRocLength
)
;
size_t
auth_required_length
=
rtp
.
size
(
)
-
tag_length
+
kRocLength
;
uint8_t
output
[
64
]
;
size_t
result
=
ComputeHmac
(
DIGEST_SHA_1
&
packet_time_params
.
srtp_auth_key
[
0
]
packet_time_params
.
srtp_auth_key
.
size
(
)
rtp
.
data
(
)
auth_required_length
output
sizeof
(
output
)
)
;
if
(
result
<
tag_length
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
memcpy
(
auth_tag
output
tag_length
)
;
}
bool
GetUint8
(
const
void
*
data
size_t
offset
int
*
value
)
{
if
(
!
data
|
|
!
value
)
{
return
false
;
}
*
value
=
*
(
static_cast
<
const
uint8_t
*
>
(
data
)
+
offset
)
;
return
true
;
}
}
bool
GetRtcpType
(
const
void
*
data
size_t
len
int
*
value
)
{
if
(
len
<
kMinRtcpPacketLen
)
{
return
false
;
}
return
GetUint8
(
data
kRtcpPayloadTypeOffset
value
)
;
}
bool
GetRtcpSsrc
(
const
void
*
data
size_t
len
uint32_t
*
value
)
{
if
(
!
data
|
|
len
<
kMinRtcpPacketLen
+
4
|
|
!
value
)
return
false
;
int
pl_type
;
if
(
!
GetRtcpType
(
data
len
&
pl_type
)
)
return
false
;
if
(
pl_type
=
=
kRtcpTypeSDES
)
return
false
;
*
value
=
GetBE32
(
static_cast
<
const
uint8_t
*
>
(
data
)
+
4
)
;
return
true
;
}
bool
IsValidRtpPayloadType
(
int
payload_type
)
{
return
payload_type
>
=
0
&
&
payload_type
<
=
127
;
}
bool
IsValidRtpPacketSize
(
RtpPacketType
packet_type
size_t
size
)
{
RTC_DCHECK_NE
(
RtpPacketType
:
:
kUnknown
packet_type
)
;
size_t
min_packet_length
=
packet_type
=
=
RtpPacketType
:
:
kRtcp
?
kMinRtcpPacketLen
:
kMinRtpPacketLen
;
return
size
>
=
min_packet_length
&
&
size
<
=
kMaxRtpPacketLen
;
}
absl
:
:
string_view
RtpPacketTypeToString
(
RtpPacketType
packet_type
)
{
switch
(
packet_type
)
{
case
RtpPacketType
:
:
kRtp
:
return
"
RTP
"
;
case
RtpPacketType
:
:
kRtcp
:
return
"
RTCP
"
;
case
RtpPacketType
:
:
kUnknown
:
return
"
Unknown
"
;
}
RTC_CHECK_NOTREACHED
(
)
;
}
RtpPacketType
InferRtpPacketType
(
ArrayView
<
const
uint8_t
>
packet
)
{
if
(
IsRtcpPacket
(
packet
)
)
{
return
RtpPacketType
:
:
kRtcp
;
}
if
(
IsRtpPacket
(
packet
)
)
{
return
RtpPacketType
:
:
kRtp
;
}
return
RtpPacketType
:
:
kUnknown
;
}
bool
ValidateRtpHeader
(
ArrayView
<
const
uint8_t
>
rtp
size_t
*
header_length
)
{
size_t
length
=
rtp
.
size
(
)
;
if
(
header_length
)
{
*
header_length
=
0
;
}
if
(
length
<
kMinRtpPacketLen
)
{
return
false
;
}
size_t
cc_count
=
rtp
[
0
]
&
0x0F
;
size_t
header_length_without_extension
=
kMinRtpPacketLen
+
4
*
cc_count
;
if
(
header_length_without_extension
>
length
)
{
return
false
;
}
if
(
!
(
rtp
[
0
]
&
0x10
)
)
{
if
(
header_length
)
*
header_length
=
header_length_without_extension
;
return
true
;
}
if
(
header_length_without_extension
+
kRtpExtensionHeaderLen
>
length
)
{
return
false
;
}
uint16_t
extension_length_in_32bits
=
GetBE16
(
&
rtp
[
header_length_without_extension
+
2
]
)
;
size_t
extension_length
=
extension_length_in_32bits
*
4
;
size_t
rtp_header_length
=
extension_length
+
header_length_without_extension
+
kRtpExtensionHeaderLen
;
if
(
rtp_header_length
>
length
)
{
return
false
;
}
if
(
header_length
)
{
*
header_length
=
rtp_header_length
;
}
return
true
;
}
bool
UpdateRtpAbsSendTimeExtension
(
ArrayView
<
uint8_t
>
packet
int
extension_id
uint64_t
time_us
)
{
if
(
!
(
packet
[
0
]
&
0x10
)
)
{
return
true
;
}
size_t
cc_count
=
packet
[
0
]
&
0x0F
;
size_t
header_length_without_extension
=
kMinRtpPacketLen
+
4
*
cc_count
;
uint8_t
*
rtp
=
packet
.
data
(
)
;
rtp
+
=
header_length_without_extension
;
uint16_t
profile_id
=
GetBE16
(
rtp
)
;
uint16_t
extension_length_in_32bits
=
GetBE16
(
rtp
+
2
)
;
size_t
extension_length
=
extension_length_in_32bits
*
4
;
rtp
+
=
kRtpExtensionHeaderLen
;
constexpr
uint16_t
kOneByteExtensionProfileId
=
0xBEDE
;
constexpr
uint16_t
kTwoByteExtensionProfileId
=
0x1000
;
bool
found
=
false
;
if
(
profile_id
=
=
kOneByteExtensionProfileId
|
|
profile_id
=
=
kTwoByteExtensionProfileId
)
{
size_t
extension_header_length
=
profile_id
=
=
kOneByteExtensionProfileId
?
kOneByteExtensionHeaderLen
:
kTwoByteExtensionHeaderLen
;
const
uint8_t
*
extension_start
=
rtp
;
const
uint8_t
*
extension_end
=
extension_start
+
extension_length
;
while
(
rtp
+
1
<
extension_end
)
{
const
int
id
=
profile_id
=
=
kOneByteExtensionProfileId
?
(
*
rtp
&
0xF0
)
>
>
4
:
*
rtp
;
const
size_t
length
=
profile_id
=
=
kOneByteExtensionProfileId
?
(
*
rtp
&
0x0F
)
+
1
:
*
(
rtp
+
1
)
;
if
(
rtp
+
extension_header_length
+
length
>
extension_end
)
{
return
false
;
}
if
(
id
=
=
extension_id
)
{
UpdateAbsSendTimeExtensionValue
(
rtp
+
extension_header_length
length
time_us
)
;
found
=
true
;
break
;
}
rtp
+
=
extension_header_length
+
length
;
while
(
(
rtp
<
extension_end
)
&
&
(
*
rtp
=
=
0
)
)
{
+
+
rtp
;
}
}
}
return
found
;
}
bool
ApplyPacketOptions
(
ArrayView
<
uint8_t
>
data
const
PacketTimeUpdateParams
&
packet_time_params
uint64_t
time_us
)
{
RTC_DCHECK
(
data
.
size
(
)
>
0
)
;
if
(
packet_time_params
.
rtp_sendtime_extension_id
=
=
-
1
&
&
packet_time_params
.
srtp_auth_key
.
empty
(
)
)
{
return
true
;
}
size_t
rtp_start_pos
;
size_t
rtp_length
;
if
(
!
UnwrapTurnPacket
(
data
.
data
(
)
data
.
size
(
)
&
rtp_start_pos
&
rtp_length
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
false
;
}
auto
packet
=
data
.
subview
(
rtp_start_pos
rtp_length
)
;
if
(
!
IsRtpPacket
(
packet
)
|
|
!
ValidateRtpHeader
(
packet
nullptr
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
false
;
}
if
(
packet_time_params
.
rtp_sendtime_extension_id
!
=
-
1
)
{
UpdateRtpAbsSendTimeExtension
(
packet
packet_time_params
.
rtp_sendtime_extension_id
time_us
)
;
}
UpdateRtpAuthTag
(
packet
packet_time_params
)
;
return
true
;
}
}
