#
include
"
media
/
base
/
rtp_utils
.
h
"
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
"
media
/
base
/
turn_utils
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
byte_order
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
message_digest
.
h
"
namespace
cricket
{
static
const
uint8_t
kRtpVersion
=
2
;
static
const
size_t
kRtpFlagsOffset
=
0
;
static
const
size_t
kRtpPayloadTypeOffset
=
1
;
static
const
size_t
kRtpSeqNumOffset
=
2
;
static
const
size_t
kRtpTimestampOffset
=
4
;
static
const
size_t
kRtpSsrcOffset
=
8
;
static
const
size_t
kRtcpPayloadTypeOffset
=
1
;
static
const
size_t
kRtpExtensionHeaderLen
=
4
;
static
const
size_t
kAbsSendTimeExtensionLen
=
3
;
static
const
size_t
kOneByteExtensionHeaderLen
=
1
;
static
const
size_t
kTwoByteExtensionHeaderLen
=
2
;
namespace
{
static
const
uint8_t
kFakeAuthTag
[
10
]
=
{
0xba
0xdd
0xba
0xdd
0xba
0xdd
0xba
0xdd
0xba
0xdd
}
;
void
UpdateAbsSendTimeExtensionValue
(
uint8_t
*
extension_data
size_t
length
uint64_t
time_us
)
{
if
(
length
!
=
kAbsSendTimeExtensionLen
)
{
RTC_NOTREACHED
(
)
;
return
;
}
uint32_t
send_time
=
(
(
time_us
<
<
18
)
/
1000000
)
&
0x00FFFFFF
;
extension_data
[
0
]
=
static_cast
<
uint8_t
>
(
send_time
>
>
16
)
;
extension_data
[
1
]
=
static_cast
<
uint8_t
>
(
send_time
>
>
8
)
;
extension_data
[
2
]
=
static_cast
<
uint8_t
>
(
send_time
)
;
}
void
UpdateRtpAuthTag
(
uint8_t
*
rtp
size_t
length
const
rtc
:
:
PacketTimeUpdateParams
&
packet_time_params
)
{
if
(
packet_time_params
.
srtp_auth_key
.
empty
(
)
)
{
return
;
}
size_t
tag_length
=
packet_time_params
.
srtp_auth_tag_len
;
const
size_t
kRocLength
=
4
;
if
(
tag_length
<
kRocLength
|
|
tag_length
>
length
)
{
RTC_NOTREACHED
(
)
;
return
;
}
uint8_t
*
auth_tag
=
rtp
+
(
length
-
tag_length
)
;
RTC_DCHECK_EQ
(
0
memcmp
(
auth_tag
kFakeAuthTag
tag_length
)
)
;
memcpy
(
auth_tag
&
packet_time_params
.
srtp_packet_index
kRocLength
)
;
size_t
auth_required_length
=
length
-
tag_length
+
kRocLength
;
uint8_t
output
[
64
]
;
size_t
result
=
rtc
:
:
ComputeHmac
(
rtc
:
:
DIGEST_SHA_1
&
packet_time_params
.
srtp_auth_key
[
0
]
packet_time_params
.
srtp_auth_key
.
size
(
)
rtp
auth_required_length
output
sizeof
(
output
)
)
;
if
(
result
<
tag_length
)
{
RTC_NOTREACHED
(
)
;
return
;
}
memcpy
(
auth_tag
output
tag_length
)
;
}
}
bool
GetUint8
(
const
void
*
data
size_t
offset
int
*
value
)
{
if
(
!
data
|
|
!
value
)
{
return
false
;
}
*
value
=
*
(
static_cast
<
const
uint8_t
*
>
(
data
)
+
offset
)
;
return
true
;
}
bool
GetUint16
(
const
void
*
data
size_t
offset
int
*
value
)
{
if
(
!
data
|
|
!
value
)
{
return
false
;
}
*
value
=
static_cast
<
int
>
(
rtc
:
:
GetBE16
(
static_cast
<
const
uint8_t
*
>
(
data
)
+
offset
)
)
;
return
true
;
}
bool
GetUint32
(
const
void
*
data
size_t
offset
uint32_t
*
value
)
{
if
(
!
data
|
|
!
value
)
{
return
false
;
}
*
value
=
rtc
:
:
GetBE32
(
static_cast
<
const
uint8_t
*
>
(
data
)
+
offset
)
;
return
true
;
}
bool
SetUint8
(
void
*
data
size_t
offset
uint8_t
value
)
{
if
(
!
data
)
{
return
false
;
}
rtc
:
:
Set8
(
data
offset
value
)
;
return
true
;
}
bool
SetUint16
(
void
*
data
size_t
offset
uint16_t
value
)
{
if
(
!
data
)
{
return
false
;
}
rtc
:
:
SetBE16
(
static_cast
<
uint8_t
*
>
(
data
)
+
offset
value
)
;
return
true
;
}
bool
SetUint32
(
void
*
data
size_t
offset
uint32_t
value
)
{
if
(
!
data
)
{
return
false
;
}
rtc
:
:
SetBE32
(
static_cast
<
uint8_t
*
>
(
data
)
+
offset
value
)
;
return
true
;
}
bool
GetRtpFlags
(
const
void
*
data
size_t
len
int
*
value
)
{
if
(
len
<
kMinRtpPacketLen
)
{
return
false
;
}
return
GetUint8
(
data
kRtpFlagsOffset
value
)
;
}
bool
GetRtpPayloadType
(
const
void
*
data
size_t
len
int
*
value
)
{
if
(
len
<
kMinRtpPacketLen
)
{
return
false
;
}
if
(
!
GetUint8
(
data
kRtpPayloadTypeOffset
value
)
)
{
return
false
;
}
*
value
&
=
0x7F
;
return
true
;
}
bool
GetRtpSeqNum
(
const
void
*
data
size_t
len
int
*
value
)
{
if
(
len
<
kMinRtpPacketLen
)
{
return
false
;
}
return
GetUint16
(
data
kRtpSeqNumOffset
value
)
;
}
bool
GetRtpTimestamp
(
const
void
*
data
size_t
len
uint32_t
*
value
)
{
if
(
len
<
kMinRtpPacketLen
)
{
return
false
;
}
return
GetUint32
(
data
kRtpTimestampOffset
value
)
;
}
bool
GetRtpSsrc
(
const
void
*
data
size_t
len
uint32_t
*
value
)
{
if
(
len
<
kMinRtpPacketLen
)
{
return
false
;
}
return
GetUint32
(
data
kRtpSsrcOffset
value
)
;
}
bool
GetRtpHeaderLen
(
const
void
*
data
size_t
len
size_t
*
value
)
{
if
(
!
data
|
|
len
<
kMinRtpPacketLen
|
|
!
value
)
return
false
;
const
uint8_t
*
header
=
static_cast
<
const
uint8_t
*
>
(
data
)
;
size_t
header_size
=
kMinRtpPacketLen
+
(
header
[
0
]
&
0xF
)
*
sizeof
(
uint32_t
)
;
if
(
len
<
header_size
)
return
false
;
if
(
header
[
0
]
&
0x10
)
{
if
(
len
<
header_size
+
sizeof
(
uint32_t
)
)
return
false
;
header_size
+
=
(
(
rtc
:
:
GetBE16
(
header
+
header_size
+
2
)
+
1
)
*
sizeof
(
uint32_t
)
)
;
if
(
len
<
header_size
)
return
false
;
}
*
value
=
header_size
;
return
true
;
}
bool
GetRtpHeader
(
const
void
*
data
size_t
len
RtpHeader
*
header
)
{
return
(
GetRtpPayloadType
(
data
len
&
(
header
-
>
payload_type
)
)
&
&
GetRtpSeqNum
(
data
len
&
(
header
-
>
seq_num
)
)
&
&
GetRtpTimestamp
(
data
len
&
(
header
-
>
timestamp
)
)
&
&
GetRtpSsrc
(
data
len
&
(
header
-
>
ssrc
)
)
)
;
}
bool
GetRtcpType
(
const
void
*
data
size_t
len
int
*
value
)
{
if
(
len
<
kMinRtcpPacketLen
)
{
return
false
;
}
return
GetUint8
(
data
kRtcpPayloadTypeOffset
value
)
;
}
bool
GetRtcpSsrc
(
const
void
*
data
size_t
len
uint32_t
*
value
)
{
if
(
!
data
|
|
len
<
kMinRtcpPacketLen
+
4
|
|
!
value
)
return
false
;
int
pl_type
;
if
(
!
GetRtcpType
(
data
len
&
pl_type
)
)
return
false
;
if
(
pl_type
=
=
kRtcpTypeSDES
)
return
false
;
*
value
=
rtc
:
:
GetBE32
(
static_cast
<
const
uint8_t
*
>
(
data
)
+
4
)
;
return
true
;
}
bool
SetRtpSsrc
(
void
*
data
size_t
len
uint32_t
value
)
{
return
SetUint32
(
data
kRtpSsrcOffset
value
)
;
}
bool
SetRtpHeader
(
void
*
data
size_t
len
const
RtpHeader
&
header
)
{
if
(
!
IsValidRtpPayloadType
(
header
.
payload_type
)
|
|
header
.
seq_num
<
0
|
|
header
.
seq_num
>
static_cast
<
int
>
(
UINT16_MAX
)
)
{
return
false
;
}
return
(
SetUint8
(
data
kRtpFlagsOffset
kRtpVersion
<
<
6
)
&
&
SetUint8
(
data
kRtpPayloadTypeOffset
header
.
payload_type
&
0x7F
)
&
&
SetUint16
(
data
kRtpSeqNumOffset
static_cast
<
uint16_t
>
(
header
.
seq_num
)
)
&
&
SetUint32
(
data
kRtpTimestampOffset
header
.
timestamp
)
&
&
SetRtpSsrc
(
data
len
header
.
ssrc
)
)
;
}
static
bool
HasCorrectRtpVersion
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
{
return
packet
.
data
(
)
[
0
]
>
>
6
=
=
kRtpVersion
;
}
bool
IsRtpPacket
(
rtc
:
:
ArrayView
<
const
char
>
packet
)
{
return
packet
.
size
(
)
>
=
kMinRtpPacketLen
&
&
HasCorrectRtpVersion
(
rtc
:
:
reinterpret_array_view
<
const
uint8_t
>
(
packet
)
)
;
}
bool
IsRtcpPacket
(
rtc
:
:
ArrayView
<
const
char
>
packet
)
{
if
(
packet
.
size
(
)
<
kMinRtcpPacketLen
|
|
!
HasCorrectRtpVersion
(
rtc
:
:
reinterpret_array_view
<
const
uint8_t
>
(
packet
)
)
)
{
return
false
;
}
char
pt
=
packet
[
1
]
&
0x7F
;
return
(
63
<
pt
)
&
&
(
pt
<
96
)
;
}
bool
IsValidRtpPayloadType
(
int
payload_type
)
{
return
payload_type
>
=
0
&
&
payload_type
<
=
127
;
}
bool
IsValidRtpPacketSize
(
RtpPacketType
packet_type
size_t
size
)
{
RTC_DCHECK_NE
(
RtpPacketType
:
:
kUnknown
packet_type
)
;
size_t
min_packet_length
=
packet_type
=
=
RtpPacketType
:
:
kRtcp
?
kMinRtcpPacketLen
:
kMinRtpPacketLen
;
return
size
>
=
min_packet_length
&
&
size
<
=
kMaxRtpPacketLen
;
}
absl
:
:
string_view
RtpPacketTypeToString
(
RtpPacketType
packet_type
)
{
switch
(
packet_type
)
{
case
RtpPacketType
:
:
kRtp
:
return
"
RTP
"
;
case
RtpPacketType
:
:
kRtcp
:
return
"
RTCP
"
;
case
RtpPacketType
:
:
kUnknown
:
return
"
Unknown
"
;
}
RTC_CHECK
(
false
)
;
}
RtpPacketType
InferRtpPacketType
(
rtc
:
:
ArrayView
<
const
char
>
packet
)
{
if
(
IsRtcpPacket
(
packet
)
)
{
return
RtpPacketType
:
:
kRtcp
;
}
if
(
IsRtpPacket
(
packet
)
)
{
return
RtpPacketType
:
:
kRtp
;
}
return
RtpPacketType
:
:
kUnknown
;
}
bool
ValidateRtpHeader
(
const
uint8_t
*
rtp
size_t
length
size_t
*
header_length
)
{
if
(
header_length
)
{
*
header_length
=
0
;
}
if
(
length
<
kMinRtpPacketLen
)
{
return
false
;
}
size_t
cc_count
=
rtp
[
0
]
&
0x0F
;
size_t
header_length_without_extension
=
kMinRtpPacketLen
+
4
*
cc_count
;
if
(
header_length_without_extension
>
length
)
{
return
false
;
}
if
(
!
(
rtp
[
0
]
&
0x10
)
)
{
if
(
header_length
)
*
header_length
=
header_length_without_extension
;
return
true
;
}
rtp
+
=
header_length_without_extension
;
if
(
header_length_without_extension
+
kRtpExtensionHeaderLen
>
length
)
{
return
false
;
}
uint16_t
extension_length_in_32bits
=
rtc
:
:
GetBE16
(
rtp
+
2
)
;
size_t
extension_length
=
extension_length_in_32bits
*
4
;
size_t
rtp_header_length
=
extension_length
+
header_length_without_extension
+
kRtpExtensionHeaderLen
;
if
(
rtp_header_length
>
length
)
{
return
false
;
}
if
(
header_length
)
{
*
header_length
=
rtp_header_length
;
}
return
true
;
}
bool
UpdateRtpAbsSendTimeExtension
(
uint8_t
*
rtp
size_t
length
int
extension_id
uint64_t
time_us
)
{
if
(
!
(
rtp
[
0
]
&
0x10
)
)
{
return
true
;
}
size_t
cc_count
=
rtp
[
0
]
&
0x0F
;
size_t
header_length_without_extension
=
kMinRtpPacketLen
+
4
*
cc_count
;
rtp
+
=
header_length_without_extension
;
uint16_t
profile_id
=
rtc
:
:
GetBE16
(
rtp
)
;
uint16_t
extension_length_in_32bits
=
rtc
:
:
GetBE16
(
rtp
+
2
)
;
size_t
extension_length
=
extension_length_in_32bits
*
4
;
rtp
+
=
kRtpExtensionHeaderLen
;
constexpr
uint16_t
kOneByteExtensionProfileId
=
0xBEDE
;
constexpr
uint16_t
kTwoByteExtensionProfileId
=
0x1000
;
bool
found
=
false
;
if
(
profile_id
=
=
kOneByteExtensionProfileId
|
|
profile_id
=
=
kTwoByteExtensionProfileId
)
{
size_t
extension_header_length
=
profile_id
=
=
kOneByteExtensionProfileId
?
kOneByteExtensionHeaderLen
:
kTwoByteExtensionHeaderLen
;
const
uint8_t
*
extension_start
=
rtp
;
const
uint8_t
*
extension_end
=
extension_start
+
extension_length
;
while
(
rtp
+
1
<
extension_end
)
{
const
int
id
=
profile_id
=
=
kOneByteExtensionProfileId
?
(
*
rtp
&
0xF0
)
>
>
4
:
*
rtp
;
const
size_t
length
=
profile_id
=
=
kOneByteExtensionProfileId
?
(
*
rtp
&
0x0F
)
+
1
:
*
(
rtp
+
1
)
;
if
(
rtp
+
extension_header_length
+
length
>
extension_end
)
{
return
false
;
}
if
(
id
=
=
extension_id
)
{
UpdateAbsSendTimeExtensionValue
(
rtp
+
extension_header_length
length
time_us
)
;
found
=
true
;
break
;
}
rtp
+
=
extension_header_length
+
length
;
while
(
(
rtp
<
extension_end
)
&
&
(
*
rtp
=
=
0
)
)
{
+
+
rtp
;
}
}
}
return
found
;
}
bool
ApplyPacketOptions
(
uint8_t
*
data
size_t
length
const
rtc
:
:
PacketTimeUpdateParams
&
packet_time_params
uint64_t
time_us
)
{
RTC_DCHECK
(
data
)
;
RTC_DCHECK
(
length
)
;
if
(
packet_time_params
.
rtp_sendtime_extension_id
=
=
-
1
&
&
packet_time_params
.
srtp_auth_key
.
empty
(
)
)
{
return
true
;
}
size_t
rtp_start_pos
;
size_t
rtp_length
;
if
(
!
UnwrapTurnPacket
(
data
length
&
rtp_start_pos
&
rtp_length
)
)
{
RTC_NOTREACHED
(
)
;
return
false
;
}
auto
packet
=
rtc
:
:
MakeArrayView
(
data
+
rtp_start_pos
rtp_length
)
;
if
(
!
IsRtpPacket
(
rtc
:
:
reinterpret_array_view
<
const
char
>
(
packet
)
)
|
|
!
ValidateRtpHeader
(
data
+
rtp_start_pos
rtp_length
nullptr
)
)
{
RTC_NOTREACHED
(
)
;
return
false
;
}
uint8_t
*
start
=
data
+
rtp_start_pos
;
if
(
packet_time_params
.
rtp_sendtime_extension_id
!
=
-
1
)
{
UpdateRtpAbsSendTimeExtension
(
start
rtp_length
packet_time_params
.
rtp_sendtime_extension_id
time_us
)
;
}
UpdateRtpAuthTag
(
start
rtp_length
packet_time_params
)
;
return
true
;
}
}
