#
ifndef
MEDIA_BASE_H264_PROFILE_LEVEL_ID_H_
#
define
MEDIA_BASE_H264_PROFILE_LEVEL_ID_H_
#
include
<
map
>
#
include
<
string
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
webrtc
{
namespace
H264
{
enum
Profile
{
kProfileConstrainedBaseline
kProfileBaseline
kProfileMain
kProfileConstrainedHigh
kProfileHigh
}
;
typedef
std
:
:
map
<
std
:
:
string
std
:
:
string
>
CodecParameterMap
;
enum
Level
{
kLevel1_b
=
0
kLevel1
=
10
kLevel1_1
=
11
kLevel1_2
=
12
kLevel1_3
=
13
kLevel2
=
20
kLevel2_1
=
21
kLevel2_2
=
22
kLevel3
=
30
kLevel3_1
=
31
kLevel3_2
=
32
kLevel4
=
40
kLevel4_1
=
41
kLevel4_2
=
42
kLevel5
=
50
kLevel5_1
=
51
kLevel5_2
=
52
}
;
struct
ProfileLevelId
{
constexpr
ProfileLevelId
(
Profile
profile
Level
level
)
:
profile
(
profile
)
level
(
level
)
{
}
Profile
profile
;
Level
level
;
}
;
absl
:
:
optional
<
ProfileLevelId
>
ParseProfileLevelId
(
const
char
*
str
)
;
RTC_EXPORT
absl
:
:
optional
<
ProfileLevelId
>
ParseSdpProfileLevelId
(
const
CodecParameterMap
&
params
)
;
RTC_EXPORT
absl
:
:
optional
<
Level
>
SupportedLevel
(
int
max_frame_pixel_count
float
max_fps
)
;
RTC_EXPORT
absl
:
:
optional
<
std
:
:
string
>
ProfileLevelIdToString
(
const
ProfileLevelId
&
profile_level_id
)
;
void
GenerateProfileLevelIdForAnswer
(
const
CodecParameterMap
&
local_supported_params
const
CodecParameterMap
&
remote_offered_params
CodecParameterMap
*
answer_params
)
;
bool
IsSameH264Profile
(
const
CodecParameterMap
&
params1
const
CodecParameterMap
&
params2
)
;
}
}
#
endif
