#
ifndef
MEDIA_BASE_MEDIA_CHANNEL_IMPL_H_
#
define
MEDIA_BASE_MEDIA_CHANNEL_IMPL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
api
/
crypto
/
frame_decryptor_interface
.
h
"
#
include
"
api
/
crypto
/
frame_encryptor_interface
.
h
"
#
include
"
api
/
frame_transformer_interface
.
h
"
#
include
"
api
/
media_types
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
network
/
sent_packet
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
cricket
{
class
VoiceMediaChannel
;
class
VideoMediaChannel
;
class
MediaChannel
:
public
MediaSendChannelInterface
public
MediaReceiveChannelInterface
{
public
:
explicit
MediaChannel
(
webrtc
:
:
TaskQueueBase
*
network_thread
bool
enable_dscp
=
false
)
;
virtual
~
MediaChannel
(
)
;
MediaSendChannelInterface
*
AsSendChannel
(
)
{
return
this
;
}
MediaReceiveChannelInterface
*
AsReceiveChannel
(
)
{
return
this
;
}
virtual
VideoMediaChannel
*
AsVideoChannel
(
)
{
RTC_CHECK_NOTREACHED
(
)
;
return
nullptr
;
}
virtual
VoiceMediaChannel
*
AsVoiceChannel
(
)
{
RTC_CHECK_NOTREACHED
(
)
;
return
nullptr
;
}
cricket
:
:
MediaType
media_type
(
)
const
override
=
0
;
void
OnPacketReceived
(
rtc
:
:
CopyOnWriteBuffer
packet
int64_t
packet_time_us
)
override
=
0
;
void
OnPacketSent
(
const
rtc
:
:
SentPacket
&
sent_packet
)
override
=
0
;
void
OnReadyToSend
(
bool
ready
)
override
=
0
;
void
OnNetworkRouteChanged
(
absl
:
:
string_view
transport_name
const
rtc
:
:
NetworkRoute
&
network_route
)
override
=
0
;
virtual
void
SetInterface
(
MediaChannelNetworkInterface
*
iface
)
;
virtual
int
GetRtpSendTimeExtnId
(
)
const
;
bool
SendPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
;
bool
SendRtcp
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
)
;
int
SetOption
(
MediaChannelNetworkInterface
:
:
SocketType
type
rtc
:
:
Socket
:
:
Option
opt
int
option
)
;
void
SetExtmapAllowMixed
(
bool
extmap_allow_mixed
)
override
;
bool
ExtmapAllowMixed
(
)
const
override
;
bool
HasNetworkInterface
(
)
const
;
void
SetFrameEncryptor
(
uint32_t
ssrc
rtc
:
:
scoped_refptr
<
webrtc
:
:
FrameEncryptorInterface
>
frame_encryptor
)
override
;
void
SetFrameDecryptor
(
uint32_t
ssrc
rtc
:
:
scoped_refptr
<
webrtc
:
:
FrameDecryptorInterface
>
frame_decryptor
)
override
;
void
SetEncoderToPacketizerFrameTransformer
(
uint32_t
ssrc
rtc
:
:
scoped_refptr
<
webrtc
:
:
FrameTransformerInterface
>
frame_transformer
)
override
;
void
SetDepacketizerToDecoderFrameTransformer
(
uint32_t
ssrc
rtc
:
:
scoped_refptr
<
webrtc
:
:
FrameTransformerInterface
>
frame_transformer
)
override
;
protected
:
int
SetOptionLocked
(
MediaChannelNetworkInterface
:
:
SocketType
type
rtc
:
:
Socket
:
:
Option
opt
int
option
)
RTC_RUN_ON
(
network_thread_
)
;
bool
DscpEnabled
(
)
const
;
rtc
:
:
DiffServCodePoint
PreferredDscp
(
)
const
;
void
SetPreferredDscp
(
rtc
:
:
DiffServCodePoint
new_dscp
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
PendingTaskSafetyFlag
>
network_safety
(
)
;
void
SendRtp
(
const
uint8_t
*
data
size_t
len
const
webrtc
:
:
PacketOptions
&
options
)
;
void
SendRtcp
(
const
uint8_t
*
data
size_t
len
)
;
private
:
void
UpdateDscp
(
)
RTC_RUN_ON
(
network_thread_
)
;
bool
DoSendPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
bool
rtcp
const
rtc
:
:
PacketOptions
&
options
)
;
const
bool
enable_dscp_
;
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
PendingTaskSafetyFlag
>
network_safety_
RTC_PT_GUARDED_BY
(
network_thread_
)
;
webrtc
:
:
TaskQueueBase
*
const
network_thread_
;
MediaChannelNetworkInterface
*
network_interface_
RTC_GUARDED_BY
(
network_thread_
)
=
nullptr
;
rtc
:
:
DiffServCodePoint
preferred_dscp_
RTC_GUARDED_BY
(
network_thread_
)
=
rtc
:
:
DSCP_DEFAULT
;
bool
extmap_allow_mixed_
=
false
;
}
;
class
VideoMediaChannel
:
public
MediaChannel
public
VideoMediaSendChannelInterface
public
VideoMediaReceiveChannelInterface
{
public
:
explicit
VideoMediaChannel
(
webrtc
:
:
TaskQueueBase
*
network_thread
bool
enable_dscp
=
false
)
:
MediaChannel
(
network_thread
enable_dscp
)
{
}
~
VideoMediaChannel
(
)
override
{
}
VideoMediaSendChannelInterface
*
AsVideoSendChannel
(
)
override
{
return
this
;
}
VideoMediaReceiveChannelInterface
*
AsVideoReceiveChannel
(
)
override
{
return
this
;
}
cricket
:
:
MediaType
media_type
(
)
const
override
;
VideoMediaChannel
*
AsVideoChannel
(
)
override
{
return
this
;
}
void
SetExtmapAllowMixed
(
bool
mixed
)
override
{
MediaChannel
:
:
SetExtmapAllowMixed
(
mixed
)
;
}
bool
ExtmapAllowMixed
(
)
const
override
{
return
MediaChannel
:
:
ExtmapAllowMixed
(
)
;
}
virtual
void
FillBitrateInfo
(
BandwidthEstimationInfo
*
bwe_info
)
=
0
;
virtual
bool
GetStats
(
VideoMediaInfo
*
info
)
=
0
;
void
SetVideoCodecSwitchingEnabled
(
bool
enabled
)
override
;
}
;
class
VoiceMediaChannel
:
public
MediaChannel
public
VoiceMediaSendChannelInterface
public
VoiceMediaReceiveChannelInterface
{
public
:
MediaType
media_type
(
)
const
override
;
VoiceMediaChannel
(
webrtc
:
:
TaskQueueBase
*
network_thread
bool
enable_dscp
=
false
)
:
MediaChannel
(
network_thread
enable_dscp
)
{
}
~
VoiceMediaChannel
(
)
override
{
}
VoiceMediaSendChannelInterface
*
AsVoiceSendChannel
(
)
override
{
return
this
;
}
VoiceMediaReceiveChannelInterface
*
AsVoiceReceiveChannel
(
)
override
{
return
this
;
}
VoiceMediaChannel
*
AsVoiceChannel
(
)
override
{
return
this
;
}
void
SetExtmapAllowMixed
(
bool
mixed
)
override
{
MediaChannel
:
:
SetExtmapAllowMixed
(
mixed
)
;
}
bool
ExtmapAllowMixed
(
)
const
override
{
return
MediaChannel
:
:
ExtmapAllowMixed
(
)
;
}
virtual
bool
GetStats
(
VoiceMediaInfo
*
info
bool
get_and_clear_legacy_stats
)
=
0
;
}
;
}
#
endif
