#
ifndef
MEDIA_BASE_MEDIA_CHANNEL_IMPL_H_
#
define
MEDIA_BASE_MEDIA_CHANNEL_IMPL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
dscp
.
h
"
#
include
"
rtc_base
/
socket
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
MediaChannelUtil
{
public
:
explicit
MediaChannelUtil
(
TaskQueueBase
*
network_thread
bool
enable_dscp
=
false
)
;
virtual
~
MediaChannelUtil
(
)
;
virtual
int
GetRtpSendTimeExtnId
(
)
const
;
Transport
*
transport
(
)
{
return
&
transport_
;
}
bool
SendPacket
(
CopyOnWriteBuffer
*
packet
const
AsyncSocketPacketOptions
&
options
)
;
bool
SendRtcp
(
CopyOnWriteBuffer
*
packet
const
AsyncSocketPacketOptions
&
options
)
;
int
SetOption
(
MediaChannelNetworkInterface
:
:
SocketType
type
Socket
:
:
Option
opt
int
option
)
;
void
SetExtmapAllowMixed
(
bool
extmap_allow_mixed
)
;
bool
ExtmapAllowMixed
(
)
const
;
void
SetInterface
(
MediaChannelNetworkInterface
*
iface
)
;
bool
HasNetworkInterface
(
)
const
;
protected
:
bool
DscpEnabled
(
)
const
;
void
SetPreferredDscp
(
DiffServCodePoint
new_dscp
)
;
private
:
class
TransportForMediaChannels
:
public
Transport
{
public
:
TransportForMediaChannels
(
TaskQueueBase
*
network_thread
bool
enable_dscp
)
;
virtual
~
TransportForMediaChannels
(
)
;
bool
SendRtp
(
ArrayView
<
const
uint8_t
>
packet
const
PacketOptions
&
options
)
override
;
bool
SendRtcp
(
ArrayView
<
const
uint8_t
>
packet
)
override
;
void
SetInterface
(
MediaChannelNetworkInterface
*
iface
)
;
int
SetOption
(
MediaChannelNetworkInterface
:
:
SocketType
type
Socket
:
:
Option
opt
int
option
)
;
bool
DoSendPacket
(
CopyOnWriteBuffer
*
packet
bool
rtcp
const
AsyncSocketPacketOptions
&
options
)
;
bool
HasNetworkInterface
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
network_interface_
!
=
nullptr
;
}
bool
DscpEnabled
(
)
const
{
return
enable_dscp_
;
}
void
SetPreferredDscp
(
DiffServCodePoint
new_dscp
)
;
private
:
DiffServCodePoint
PreferredDscp
(
)
const
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
preferred_dscp_
;
}
void
UpdateDscp
(
)
RTC_RUN_ON
(
network_thread_
)
;
int
SetOptionLocked
(
MediaChannelNetworkInterface
:
:
SocketType
type
Socket
:
:
Option
opt
int
option
)
RTC_RUN_ON
(
network_thread_
)
;
const
scoped_refptr
<
PendingTaskSafetyFlag
>
network_safety_
RTC_PT_GUARDED_BY
(
network_thread_
)
;
TaskQueueBase
*
const
network_thread_
;
const
bool
enable_dscp_
;
MediaChannelNetworkInterface
*
network_interface_
RTC_GUARDED_BY
(
network_thread_
)
=
nullptr
;
DiffServCodePoint
preferred_dscp_
RTC_GUARDED_BY
(
network_thread_
)
=
webrtc
:
:
DSCP_DEFAULT
;
}
;
bool
extmap_allow_mixed_
=
false
;
TransportForMediaChannels
transport_
;
}
;
}
#
endif
