#
include
<
errno
.
h
>
namespace
{
enum
PreservedErrno
{
SCTP_EINPROGRESS
=
EINPROGRESS
SCTP_EWOULDBLOCK
=
EWOULDBLOCK
}
;
constexpr
int
kSctpSuccessReturn
=
1
;
}
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
usrsctp
.
h
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
unordered_map
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
media
/
base
/
stream_params
.
h
"
#
include
"
media
/
sctp
/
sctp_transport
.
h
"
#
include
"
p2p
/
base
/
dtls_transport_internal
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
helpers
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
string_utils
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
task_utils
/
to_queued_task
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
namespace
{
static
constexpr
size_t
kSctpMtu
=
1191
;
ABSL_CONST_INIT
int
g_usrsctp_usage_count
=
0
;
ABSL_CONST_INIT
bool
g_usrsctp_initialized_
=
false
;
ABSL_CONST_INIT
webrtc
:
:
GlobalMutex
g_usrsctp_lock_
(
absl
:
:
kConstInit
)
;
enum
{
PPID_NONE
=
0
PPID_CONTROL
=
50
PPID_BINARY_PARTIAL
=
52
PPID_BINARY_LAST
=
53
PPID_TEXT_PARTIAL
=
54
PPID_TEXT_LAST
=
51
}
;
ABSL_CONST_INIT
cricket
:
:
SctpTransportMap
*
g_transport_map_
=
nullptr
;
#
if
defined
(
__GNUC__
)
__attribute__
(
(
__format__
(
__printf__
1
2
)
)
)
#
endif
void
DebugSctpPrintf
(
const
char
*
format
.
.
.
)
{
#
if
RTC_DCHECK_IS_ON
char
s
[
255
]
;
va_list
ap
;
va_start
(
ap
format
)
;
vsnprintf
(
s
sizeof
(
s
)
format
ap
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP
:
"
<
<
s
;
va_end
(
ap
)
;
#
endif
}
uint32_t
GetPpid
(
cricket
:
:
DataMessageType
type
)
{
switch
(
type
)
{
default
:
case
cricket
:
:
DMT_NONE
:
return
PPID_NONE
;
case
cricket
:
:
DMT_CONTROL
:
return
PPID_CONTROL
;
case
cricket
:
:
DMT_BINARY
:
return
PPID_BINARY_LAST
;
case
cricket
:
:
DMT_TEXT
:
return
PPID_TEXT_LAST
;
}
}
bool
GetDataMediaType
(
uint32_t
ppid
cricket
:
:
DataMessageType
*
dest
)
{
RTC_DCHECK
(
dest
!
=
NULL
)
;
switch
(
ppid
)
{
case
PPID_BINARY_PARTIAL
:
case
PPID_BINARY_LAST
:
*
dest
=
cricket
:
:
DMT_BINARY
;
return
true
;
case
PPID_TEXT_PARTIAL
:
case
PPID_TEXT_LAST
:
*
dest
=
cricket
:
:
DMT_TEXT
;
return
true
;
case
PPID_CONTROL
:
*
dest
=
cricket
:
:
DMT_CONTROL
;
return
true
;
case
PPID_NONE
:
*
dest
=
cricket
:
:
DMT_NONE
;
return
true
;
default
:
return
false
;
}
}
void
VerboseLogPacket
(
const
void
*
data
size_t
length
int
direction
)
{
if
(
RTC_LOG_CHECK_LEVEL
(
LS_VERBOSE
)
&
&
length
>
0
)
{
char
*
dump_buf
;
if
(
(
dump_buf
=
usrsctp_dumppacket
(
const_cast
<
void
*
>
(
data
)
length
direction
)
)
!
=
NULL
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
dump_buf
;
usrsctp_freedumpbuffer
(
dump_buf
)
;
}
}
}
sctp_sendv_spa
CreateSctpSendParams
(
const
cricket
:
:
SendDataParams
&
params
)
{
struct
sctp_sendv_spa
spa
=
{
0
}
;
spa
.
sendv_flags
|
=
SCTP_SEND_SNDINFO_VALID
;
spa
.
sendv_sndinfo
.
snd_sid
=
params
.
sid
;
spa
.
sendv_sndinfo
.
snd_ppid
=
rtc
:
:
HostToNetwork32
(
GetPpid
(
params
.
type
)
)
;
spa
.
sendv_sndinfo
.
snd_flags
|
=
SCTP_EOR
;
if
(
!
params
.
ordered
)
{
spa
.
sendv_sndinfo
.
snd_flags
|
=
SCTP_UNORDERED
;
if
(
params
.
max_rtx_count
>
=
0
|
|
params
.
max_rtx_ms
=
=
0
)
{
spa
.
sendv_flags
|
=
SCTP_SEND_PRINFO_VALID
;
spa
.
sendv_prinfo
.
pr_policy
=
SCTP_PR_SCTP_RTX
;
spa
.
sendv_prinfo
.
pr_value
=
params
.
max_rtx_count
;
}
else
{
spa
.
sendv_flags
|
=
SCTP_SEND_PRINFO_VALID
;
spa
.
sendv_prinfo
.
pr_policy
=
SCTP_PR_SCTP_TTL
;
spa
.
sendv_prinfo
.
pr_value
=
params
.
max_rtx_ms
;
}
}
return
spa
;
}
}
namespace
cricket
{
class
SctpTransportMap
{
public
:
SctpTransportMap
(
)
=
default
;
uintptr_t
Register
(
cricket
:
:
SctpTransport
*
transport
)
{
webrtc
:
:
MutexLock
lock
(
&
lock_
)
;
if
(
next_id_
=
=
0
)
{
+
+
next_id_
;
}
while
(
map_
.
find
(
next_id_
)
!
=
map_
.
end
(
)
)
{
+
+
next_id_
;
if
(
next_id_
=
=
0
)
{
+
+
next_id_
;
}
}
;
map_
[
next_id_
]
=
transport
;
return
next_id_
+
+
;
}
bool
Deregister
(
uintptr_t
id
)
{
webrtc
:
:
MutexLock
lock
(
&
lock_
)
;
return
map_
.
erase
(
id
)
>
0
;
}
SctpTransport
*
Retrieve
(
uintptr_t
id
)
const
{
webrtc
:
:
MutexLock
lock
(
&
lock_
)
;
SctpTransport
*
transport
=
RetrieveWhileHoldingLock
(
id
)
;
if
(
transport
)
{
RTC_DCHECK_RUN_ON
(
transport
-
>
network_thread
(
)
)
;
}
return
transport
;
}
bool
PostToTransportThread
(
uintptr_t
id
std
:
:
function
<
void
(
SctpTransport
*
)
>
action
)
const
{
webrtc
:
:
MutexLock
lock
(
&
lock_
)
;
SctpTransport
*
transport
=
RetrieveWhileHoldingLock
(
id
)
;
if
(
!
transport
)
{
return
false
;
}
transport
-
>
network_thread_
-
>
PostTask
(
ToQueuedTask
(
transport
-
>
task_safety_
[
transport
action
]
(
)
{
action
(
transport
)
;
}
)
)
;
return
true
;
}
private
:
SctpTransport
*
RetrieveWhileHoldingLock
(
uintptr_t
id
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
{
auto
it
=
map_
.
find
(
id
)
;
if
(
it
=
=
map_
.
end
(
)
)
{
return
nullptr
;
}
return
it
-
>
second
;
}
mutable
webrtc
:
:
Mutex
lock_
;
uintptr_t
next_id_
RTC_GUARDED_BY
(
lock_
)
=
0
;
std
:
:
unordered_map
<
uintptr_t
SctpTransport
*
>
map_
RTC_GUARDED_BY
(
lock_
)
;
}
;
class
SctpTransport
:
:
UsrSctpWrapper
{
public
:
static
void
InitializeUsrSctp
(
)
{
RTC_LOG
(
LS_INFO
)
<
<
__FUNCTION__
;
if
(
g_usrsctp_initialized_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Not
reinitializing
usrsctp
since
last
attempt
at
"
"
usrsctp_finish
failed
.
"
;
}
else
{
usrsctp_init
(
0
&
UsrSctpWrapper
:
:
OnSctpOutboundPacket
&
DebugSctpPrintf
)
;
g_usrsctp_initialized_
=
true
;
}
usrsctp_sysctl_set_sctp_ecn_enable
(
0
)
;
usrsctp_sysctl_set_sctp_asconf_enable
(
0
)
;
usrsctp_sysctl_set_sctp_auth_enable
(
0
)
;
int
send_size
=
usrsctp_sysctl_get_sctp_sendspace
(
)
;
if
(
send_size
!
=
kSctpSendBufferSize
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Got
different
send
size
than
expected
:
"
<
<
send_size
;
}
usrsctp_sysctl_set_sctp_nr_outgoing_streams_default
(
kMaxSctpStreams
)
;
g_transport_map_
=
new
SctpTransportMap
(
)
;
}
static
void
UninitializeUsrSctp
(
)
{
RTC_LOG
(
LS_INFO
)
<
<
__FUNCTION__
;
for
(
size_t
i
=
0
;
i
<
300
;
+
+
i
)
{
if
(
usrsctp_finish
(
)
=
=
0
)
{
g_usrsctp_initialized_
=
false
;
delete
g_transport_map_
;
g_transport_map_
=
nullptr
;
return
;
}
rtc
:
:
Thread
:
:
SleepMs
(
10
)
;
}
delete
g_transport_map_
;
g_transport_map_
=
nullptr
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
shutdown
usrsctp
.
"
;
}
static
void
IncrementUsrSctpUsageCount
(
)
{
webrtc
:
:
GlobalMutexLock
lock
(
&
g_usrsctp_lock_
)
;
if
(
!
g_usrsctp_usage_count
)
{
InitializeUsrSctp
(
)
;
}
+
+
g_usrsctp_usage_count
;
}
static
void
DecrementUsrSctpUsageCount
(
)
{
webrtc
:
:
GlobalMutexLock
lock
(
&
g_usrsctp_lock_
)
;
-
-
g_usrsctp_usage_count
;
if
(
!
g_usrsctp_usage_count
)
{
UninitializeUsrSctp
(
)
;
}
}
static
int
OnSctpOutboundPacket
(
void
*
addr
void
*
data
size_t
length
uint8_t
tos
uint8_t
set_df
)
{
if
(
!
g_transport_map_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
OnSctpOutboundPacket
called
after
usrsctp
uninitialized
?
"
;
return
EINVAL
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
global
OnSctpOutboundPacket
(
)
:
"
"
addr
:
"
<
<
addr
<
<
"
;
length
:
"
<
<
length
<
<
"
;
tos
:
"
<
<
rtc
:
:
ToHex
(
tos
)
<
<
"
;
set_df
:
"
<
<
rtc
:
:
ToHex
(
set_df
)
;
VerboseLogPacket
(
data
length
SCTP_DUMP_OUTBOUND
)
;
rtc
:
:
CopyOnWriteBuffer
buf
(
reinterpret_cast
<
uint8_t
*
>
(
data
)
length
)
;
bool
found
=
g_transport_map_
-
>
PostToTransportThread
(
reinterpret_cast
<
uintptr_t
>
(
addr
)
[
buf
]
(
SctpTransport
*
transport
)
{
transport
-
>
OnPacketFromSctpToNetwork
(
buf
)
;
}
)
;
if
(
!
found
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
OnSctpOutboundPacket
:
Failed
to
get
transport
for
socket
ID
"
<
<
addr
;
return
EINVAL
;
}
return
0
;
}
static
int
OnSctpInboundPacket
(
struct
socket
*
sock
union
sctp_sockstore
addr
void
*
data
size_t
length
struct
sctp_rcvinfo
rcv
int
flags
void
*
ulp_info
)
{
SctpTransport
*
transport
=
GetTransportFromSocket
(
sock
)
;
if
(
!
transport
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
OnSctpInboundPacket
:
Failed
to
get
transport
for
socket
"
<
<
sock
<
<
"
;
possibly
was
already
destroyed
.
"
;
free
(
data
)
;
return
0
;
}
RTC_CHECK_EQ
(
transport
static_cast
<
SctpTransport
*
>
(
ulp_info
)
)
;
int
result
=
transport
-
>
OnDataOrNotificationFromSctp
(
data
length
rcv
flags
)
;
free
(
data
)
;
return
result
;
}
static
SctpTransport
*
GetTransportFromSocket
(
struct
socket
*
sock
)
{
struct
sockaddr
*
addrs
=
nullptr
;
int
naddrs
=
usrsctp_getladdrs
(
sock
0
&
addrs
)
;
if
(
naddrs
<
=
0
|
|
addrs
[
0
]
.
sa_family
!
=
AF_CONN
)
{
return
nullptr
;
}
struct
sockaddr_conn
*
sconn
=
reinterpret_cast
<
struct
sockaddr_conn
*
>
(
&
addrs
[
0
]
)
;
if
(
!
g_transport_map_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
GetTransportFromSocket
called
after
usrsctp
uninitialized
?
"
;
usrsctp_freeladdrs
(
addrs
)
;
return
nullptr
;
}
SctpTransport
*
transport
=
g_transport_map_
-
>
Retrieve
(
reinterpret_cast
<
uintptr_t
>
(
sconn
-
>
sconn_addr
)
)
;
usrsctp_freeladdrs
(
addrs
)
;
return
transport
;
}
static
int
SendThresholdCallback
(
struct
socket
*
sock
uint32_t
sb_free
)
{
SctpTransport
*
transport
=
GetTransportFromSocket
(
sock
)
;
if
(
!
transport
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SendThresholdCallback
:
Failed
to
get
transport
for
socket
"
<
<
sock
<
<
"
;
possibly
was
already
destroyed
.
"
;
return
0
;
}
transport
-
>
OnSendThresholdCallback
(
)
;
return
0
;
}
static
int
SendThresholdCallback
(
struct
socket
*
sock
uint32_t
sb_free
void
*
ulp_info
)
{
SctpTransport
*
transport
=
GetTransportFromSocket
(
sock
)
;
if
(
!
transport
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SendThresholdCallback
:
Failed
to
get
transport
for
socket
"
<
<
sock
<
<
"
;
possibly
was
already
destroyed
.
"
;
return
0
;
}
RTC_CHECK_EQ
(
transport
static_cast
<
SctpTransport
*
>
(
ulp_info
)
)
;
transport
-
>
OnSendThresholdCallback
(
)
;
return
0
;
}
}
;
SctpTransport
:
:
SctpTransport
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
PacketTransportInternal
*
transport
)
:
network_thread_
(
network_thread
)
transport_
(
transport
)
was_ever_writable_
(
transport
?
transport
-
>
writable
(
)
:
false
)
{
RTC_DCHECK
(
network_thread_
)
;
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
ConnectTransportSignals
(
)
;
}
SctpTransport
:
:
~
SctpTransport
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
CloseSctpSocket
(
)
;
network_thread_
=
nullptr
;
transport_
=
nullptr
;
}
void
SctpTransport
:
:
SetDtlsTransport
(
rtc
:
:
PacketTransportInternal
*
transport
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
DisconnectTransportSignals
(
)
;
transport_
=
transport
;
ConnectTransportSignals
(
)
;
if
(
!
was_ever_writable_
&
&
transport
&
&
transport
-
>
writable
(
)
)
{
was_ever_writable_
=
true
;
if
(
started_
)
{
RTC_DCHECK
(
!
sock_
)
;
Connect
(
)
;
}
}
}
bool
SctpTransport
:
:
Start
(
int
local_sctp_port
int
remote_sctp_port
int
max_message_size
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
local_sctp_port
=
=
-
1
)
{
local_sctp_port
=
kSctpDefaultPort
;
}
if
(
remote_sctp_port
=
=
-
1
)
{
remote_sctp_port
=
kSctpDefaultPort
;
}
if
(
max_message_size
>
kSctpSendBufferSize
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Max
message
size
of
"
<
<
max_message_size
<
<
"
is
larger
than
send
bufffer
size
"
<
<
kSctpSendBufferSize
;
return
false
;
}
if
(
max_message_size
<
1
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Max
message
size
of
"
<
<
max_message_size
<
<
"
is
too
small
"
;
return
false
;
}
max_message_size_
=
max_message_size
;
if
(
started_
)
{
if
(
local_sctp_port
!
=
local_port_
|
|
remote_sctp_port
!
=
remote_port_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Can
'
t
change
SCTP
port
after
SCTP
association
formed
.
"
;
return
false
;
}
return
true
;
}
local_port_
=
local_sctp_port
;
remote_port_
=
remote_sctp_port
;
started_
=
true
;
RTC_DCHECK
(
!
sock_
)
;
if
(
was_ever_writable_
)
{
return
Connect
(
)
;
}
return
true
;
}
bool
SctpTransport
:
:
OpenStream
(
int
sid
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
sid
>
kMaxSctpSid
)
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
OpenStream
(
.
.
.
)
:
"
"
Not
adding
data
stream
"
"
with
sid
=
"
<
<
sid
<
<
"
because
sid
is
too
high
.
"
;
return
false
;
}
auto
it
=
stream_status_by_sid_
.
find
(
sid
)
;
if
(
it
=
=
stream_status_by_sid_
.
end
(
)
)
{
stream_status_by_sid_
[
sid
]
=
StreamStatus
(
)
;
return
true
;
}
if
(
it
-
>
second
.
is_open
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
OpenStream
(
.
.
.
)
:
"
"
Not
adding
data
stream
"
"
with
sid
=
"
<
<
sid
<
<
"
because
stream
is
already
open
.
"
;
return
false
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
OpenStream
(
.
.
.
)
:
"
"
Not
adding
data
stream
"
"
with
sid
=
"
<
<
sid
<
<
"
because
stream
is
still
closing
.
"
;
return
false
;
}
}
bool
SctpTransport
:
:
ResetStream
(
int
sid
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
auto
it
=
stream_status_by_sid_
.
find
(
sid
)
;
if
(
it
=
=
stream_status_by_sid_
.
end
(
)
|
|
!
it
-
>
second
.
is_open
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
ResetStream
(
"
<
<
sid
<
<
"
)
:
stream
not
open
.
"
;
return
false
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
debug_name_
<
<
"
-
>
ResetStream
(
"
<
<
sid
<
<
"
)
:
"
"
Queuing
RE
-
CONFIG
chunk
.
"
;
it
-
>
second
.
closure_initiated
=
true
;
SendQueuedStreamResets
(
)
;
return
true
;
}
bool
SctpTransport
:
:
SendData
(
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
SendDataResult
*
result
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
partial_outgoing_message_
.
has_value
(
)
)
{
if
(
result
)
{
*
result
=
SDR_BLOCK
;
}
ready_to_send_data_
=
false
;
return
false
;
}
size_t
payload_size
=
payload
.
size
(
)
;
OutgoingMessage
message
(
payload
params
)
;
SendDataResult
send_message_result
=
SendMessageInternal
(
&
message
)
;
if
(
result
)
{
*
result
=
send_message_result
;
}
if
(
payload_size
=
=
message
.
size
(
)
)
{
return
false
;
}
RTC_DCHECK_LT
(
message
.
size
(
)
payload_size
)
;
if
(
message
.
size
(
)
>
0
)
{
RTC_DCHECK
(
!
partial_outgoing_message_
.
has_value
(
)
)
;
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
Partially
sent
message
.
Buffering
the
remaining
"
<
<
message
.
size
(
)
<
<
"
/
"
<
<
payload_size
<
<
"
bytes
.
"
;
partial_outgoing_message_
.
emplace
(
message
)
;
}
return
true
;
}
SendDataResult
SctpTransport
:
:
SendMessageInternal
(
OutgoingMessage
*
message
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
!
sock_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
SendMessageInternal
(
.
.
.
)
:
"
"
Not
sending
packet
with
sid
=
"
<
<
message
-
>
send_params
(
)
.
sid
<
<
"
len
=
"
<
<
message
-
>
size
(
)
<
<
"
before
Start
(
)
.
"
;
return
SDR_ERROR
;
}
if
(
message
-
>
send_params
(
)
.
type
!
=
DMT_CONTROL
)
{
auto
it
=
stream_status_by_sid_
.
find
(
message
-
>
send_params
(
)
.
sid
)
;
if
(
it
=
=
stream_status_by_sid_
.
end
(
)
|
|
!
it
-
>
second
.
is_open
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
SendMessageInternal
(
.
.
.
)
:
"
"
Not
sending
data
because
sid
is
unknown
or
closing
:
"
<
<
message
-
>
send_params
(
)
.
sid
;
return
SDR_ERROR
;
}
}
if
(
message
-
>
size
(
)
>
static_cast
<
size_t
>
(
max_message_size_
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Attempting
to
send
message
of
size
"
<
<
message
-
>
size
(
)
<
<
"
which
is
larger
than
limit
"
<
<
max_message_size_
;
return
SDR_ERROR
;
}
sctp_sendv_spa
spa
=
CreateSctpSendParams
(
message
-
>
send_params
(
)
)
;
ssize_t
send_res
=
usrsctp_sendv
(
sock_
message
-
>
data
(
)
message
-
>
size
(
)
NULL
0
&
spa
rtc
:
:
checked_cast
<
socklen_t
>
(
sizeof
(
spa
)
)
SCTP_SENDV_SPA
0
)
;
if
(
send_res
<
0
)
{
if
(
errno
=
=
SCTP_EWOULDBLOCK
)
{
ready_to_send_data_
=
false
;
RTC_LOG
(
LS_INFO
)
<
<
debug_name_
<
<
"
-
>
SendMessageInternal
(
.
.
.
)
:
EWOULDBLOCK
returned
"
;
return
SDR_BLOCK
;
}
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
"
ERROR
:
"
<
<
debug_name_
<
<
"
-
>
SendMessageInternal
(
.
.
.
)
:
"
"
usrsctp_sendv
:
"
;
return
SDR_ERROR
;
}
size_t
amount_sent
=
static_cast
<
size_t
>
(
send_res
)
;
RTC_DCHECK_LE
(
amount_sent
message
-
>
size
(
)
)
;
message
-
>
Advance
(
amount_sent
)
;
return
SDR_SUCCESS
;
}
bool
SctpTransport
:
:
ReadyToSendData
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
return
ready_to_send_data_
;
}
void
SctpTransport
:
:
ConnectTransportSignals
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
!
transport_
)
{
return
;
}
transport_
-
>
SignalWritableState
.
connect
(
this
&
SctpTransport
:
:
OnWritableState
)
;
transport_
-
>
SignalReadPacket
.
connect
(
this
&
SctpTransport
:
:
OnPacketRead
)
;
transport_
-
>
SignalClosed
.
connect
(
this
&
SctpTransport
:
:
OnClosed
)
;
}
void
SctpTransport
:
:
DisconnectTransportSignals
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
!
transport_
)
{
return
;
}
transport_
-
>
SignalWritableState
.
disconnect
(
this
)
;
transport_
-
>
SignalReadPacket
.
disconnect
(
this
)
;
transport_
-
>
SignalClosed
.
disconnect
(
this
)
;
}
bool
SctpTransport
:
:
Connect
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
debug_name_
<
<
"
-
>
Connect
(
)
.
"
;
RTC_DCHECK
(
!
sock_
)
;
if
(
sock_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
Connect
(
)
:
Ignored
as
socket
"
"
is
already
established
.
"
;
return
true
;
}
if
(
!
OpenSctpSocket
(
)
)
{
return
false
;
}
sockaddr_conn
local_sconn
=
GetSctpSockAddr
(
local_port_
)
;
if
(
usrsctp_bind
(
sock_
reinterpret_cast
<
sockaddr
*
>
(
&
local_sconn
)
sizeof
(
local_sconn
)
)
<
0
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
Connect
(
)
:
"
<
<
(
"
Failed
usrsctp_bind
"
)
;
CloseSctpSocket
(
)
;
return
false
;
}
sockaddr_conn
remote_sconn
=
GetSctpSockAddr
(
remote_port_
)
;
int
connect_result
=
usrsctp_connect
(
sock_
reinterpret_cast
<
sockaddr
*
>
(
&
remote_sconn
)
sizeof
(
remote_sconn
)
)
;
if
(
connect_result
<
0
&
&
errno
!
=
SCTP_EINPROGRESS
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
Connect
(
)
:
"
"
Failed
usrsctp_connect
.
got
errno
=
"
<
<
errno
<
<
"
but
wanted
"
<
<
SCTP_EINPROGRESS
;
CloseSctpSocket
(
)
;
return
false
;
}
sctp_paddrparams
params
=
{
}
;
memcpy
(
&
params
.
spp_address
&
remote_sconn
sizeof
(
remote_sconn
)
)
;
params
.
spp_flags
=
SPP_PMTUD_DISABLE
;
params
.
spp_pathmtu
=
kSctpMtu
-
sizeof
(
struct
sctp_common_header
)
;
if
(
usrsctp_setsockopt
(
sock_
IPPROTO_SCTP
SCTP_PEER_ADDR_PARAMS
&
params
sizeof
(
params
)
)
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
Connect
(
)
:
"
"
Failed
to
set
SCTP_PEER_ADDR_PARAMS
.
"
;
}
SetReadyToSendData
(
)
;
return
true
;
}
bool
SctpTransport
:
:
OpenSctpSocket
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
sock_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
OpenSctpSocket
(
)
:
"
"
Ignoring
attempt
to
re
-
create
existing
socket
.
"
;
return
false
;
}
UsrSctpWrapper
:
:
IncrementUsrSctpUsageCount
(
)
;
static
const
int
kSendThreshold
=
usrsctp_sysctl_get_sctp_sendspace
(
)
/
4
;
sock_
=
usrsctp_socket
(
AF_CONN
SOCK_STREAM
IPPROTO_SCTP
&
UsrSctpWrapper
:
:
OnSctpInboundPacket
&
UsrSctpWrapper
:
:
SendThresholdCallback
kSendThreshold
this
)
;
if
(
!
sock_
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
OpenSctpSocket
(
)
:
"
"
Failed
to
create
SCTP
socket
.
"
;
UsrSctpWrapper
:
:
DecrementUsrSctpUsageCount
(
)
;
return
false
;
}
if
(
!
ConfigureSctpSocket
(
)
)
{
usrsctp_close
(
sock_
)
;
sock_
=
nullptr
;
UsrSctpWrapper
:
:
DecrementUsrSctpUsageCount
(
)
;
return
false
;
}
id_
=
g_transport_map_
-
>
Register
(
this
)
;
usrsctp_register_address
(
reinterpret_cast
<
void
*
>
(
id_
)
)
;
return
true
;
}
bool
SctpTransport
:
:
ConfigureSctpSocket
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK
(
sock_
)
;
if
(
usrsctp_set_non_blocking
(
sock_
1
)
<
0
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
ConfigureSctpSocket
(
)
:
"
"
Failed
to
set
SCTP
to
non
blocking
.
"
;
return
false
;
}
linger
linger_opt
;
linger_opt
.
l_onoff
=
1
;
linger_opt
.
l_linger
=
0
;
if
(
usrsctp_setsockopt
(
sock_
SOL_SOCKET
SO_LINGER
&
linger_opt
sizeof
(
linger_opt
)
)
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
ConfigureSctpSocket
(
)
:
"
"
Failed
to
set
SO_LINGER
.
"
;
return
false
;
}
struct
sctp_assoc_value
stream_rst
;
stream_rst
.
assoc_id
=
SCTP_ALL_ASSOC
;
stream_rst
.
assoc_value
=
1
;
if
(
usrsctp_setsockopt
(
sock_
IPPROTO_SCTP
SCTP_ENABLE_STREAM_RESET
&
stream_rst
sizeof
(
stream_rst
)
)
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
ConfigureSctpSocket
(
)
:
"
"
Failed
to
set
SCTP_ENABLE_STREAM_RESET
.
"
;
return
false
;
}
uint32_t
nodelay
=
1
;
if
(
usrsctp_setsockopt
(
sock_
IPPROTO_SCTP
SCTP_NODELAY
&
nodelay
sizeof
(
nodelay
)
)
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
ConfigureSctpSocket
(
)
:
"
"
Failed
to
set
SCTP_NODELAY
.
"
;
return
false
;
}
uint32_t
eor
=
1
;
if
(
usrsctp_setsockopt
(
sock_
IPPROTO_SCTP
SCTP_EXPLICIT_EOR
&
eor
sizeof
(
eor
)
)
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
ConfigureSctpSocket
(
)
:
"
"
Failed
to
set
SCTP_EXPLICIT_EOR
.
"
;
return
false
;
}
int
event_types
[
]
=
{
SCTP_ASSOC_CHANGE
SCTP_PEER_ADDR_CHANGE
SCTP_SENDER_DRY_EVENT
SCTP_STREAM_RESET_EVENT
}
;
struct
sctp_event
event
=
{
0
}
;
event
.
se_assoc_id
=
SCTP_ALL_ASSOC
;
event
.
se_on
=
1
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
event_types
)
;
i
+
+
)
{
event
.
se_type
=
event_types
[
i
]
;
if
(
usrsctp_setsockopt
(
sock_
IPPROTO_SCTP
SCTP_EVENT
&
event
sizeof
(
event
)
)
<
0
)
{
RTC_LOG_ERRNO
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
ConfigureSctpSocket
(
)
:
"
"
Failed
to
set
SCTP_EVENT
type
:
"
<
<
event
.
se_type
;
return
false
;
}
}
return
true
;
}
void
SctpTransport
:
:
CloseSctpSocket
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
sock_
)
{
usrsctp_close
(
sock_
)
;
sock_
=
nullptr
;
usrsctp_deregister_address
(
reinterpret_cast
<
void
*
>
(
id_
)
)
;
RTC_CHECK
(
g_transport_map_
-
>
Deregister
(
id_
)
)
;
UsrSctpWrapper
:
:
DecrementUsrSctpUsageCount
(
)
;
ready_to_send_data_
=
false
;
}
}
bool
SctpTransport
:
:
SendQueuedStreamResets
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
size_t
num_streams
=
absl
:
:
c_count_if
(
stream_status_by_sid_
[
]
(
const
std
:
:
map
<
uint32_t
StreamStatus
>
:
:
value_type
&
stream
)
{
return
stream
.
second
.
need_outgoing_reset
(
)
;
}
)
;
if
(
num_streams
=
=
0
)
{
return
true
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
SendQueuedStreamResets
[
"
<
<
debug_name_
<
<
"
]
:
Resetting
"
<
<
num_streams
<
<
"
outgoing
streams
.
"
;
const
size_t
num_bytes
=
sizeof
(
struct
sctp_reset_streams
)
+
(
num_streams
*
sizeof
(
uint16_t
)
)
;
std
:
:
vector
<
uint8_t
>
reset_stream_buf
(
num_bytes
0
)
;
struct
sctp_reset_streams
*
resetp
=
reinterpret_cast
<
sctp_reset_streams
*
>
(
&
reset_stream_buf
[
0
]
)
;
resetp
-
>
srs_assoc_id
=
SCTP_ALL_ASSOC
;
resetp
-
>
srs_flags
=
SCTP_STREAM_RESET_OUTGOING
;
resetp
-
>
srs_number_streams
=
rtc
:
:
checked_cast
<
uint16_t
>
(
num_streams
)
;
int
result_idx
=
0
;
for
(
const
std
:
:
map
<
uint32_t
StreamStatus
>
:
:
value_type
&
stream
:
stream_status_by_sid_
)
{
if
(
!
stream
.
second
.
need_outgoing_reset
(
)
)
{
continue
;
}
resetp
-
>
srs_stream_list
[
result_idx
+
+
]
=
stream
.
first
;
}
int
ret
=
usrsctp_setsockopt
(
sock_
IPPROTO_SCTP
SCTP_RESET_STREAMS
resetp
rtc
:
:
checked_cast
<
socklen_t
>
(
reset_stream_buf
.
size
(
)
)
)
;
if
(
ret
<
0
)
{
RTC_LOG_ERRNO
(
LS_WARNING
)
<
<
debug_name_
<
<
"
-
>
SendQueuedStreamResets
(
)
:
"
"
Failed
to
send
a
stream
reset
for
"
<
<
num_streams
<
<
"
streams
"
;
return
false
;
}
for
(
auto
it
=
stream_status_by_sid_
.
begin
(
)
;
it
!
=
stream_status_by_sid_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
second
.
need_outgoing_reset
(
)
)
{
it
-
>
second
.
outgoing_reset_initiated
=
true
;
}
}
return
true
;
}
void
SctpTransport
:
:
SetReadyToSendData
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
!
ready_to_send_data_
)
{
ready_to_send_data_
=
true
;
SignalReadyToSendData
(
)
;
}
}
bool
SctpTransport
:
:
SendBufferedMessage
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK
(
partial_outgoing_message_
.
has_value
(
)
)
;
RTC_DLOG
(
LS_VERBOSE
)
<
<
"
Sending
partially
buffered
message
of
size
"
<
<
partial_outgoing_message_
-
>
size
(
)
<
<
"
.
"
;
SendMessageInternal
(
&
partial_outgoing_message_
.
value
(
)
)
;
if
(
partial_outgoing_message_
-
>
size
(
)
>
0
)
{
return
false
;
}
RTC_DCHECK_EQ
(
0u
partial_outgoing_message_
-
>
size
(
)
)
;
partial_outgoing_message_
.
reset
(
)
;
return
true
;
}
void
SctpTransport
:
:
OnWritableState
(
rtc
:
:
PacketTransportInternal
*
transport
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK_EQ
(
transport_
transport
)
;
if
(
!
was_ever_writable_
&
&
transport
-
>
writable
(
)
)
{
was_ever_writable_
=
true
;
if
(
started_
)
{
Connect
(
)
;
}
}
}
void
SctpTransport
:
:
OnPacketRead
(
rtc
:
:
PacketTransportInternal
*
transport
const
char
*
data
size_t
len
const
int64_t
&
int
flags
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_DCHECK_EQ
(
transport_
transport
)
;
TRACE_EVENT0
(
"
webrtc
"
"
SctpTransport
:
:
OnPacketRead
"
)
;
if
(
flags
&
PF_SRTP_BYPASS
)
{
return
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
debug_name_
<
<
"
-
>
OnPacketRead
(
.
.
.
)
:
"
"
length
=
"
<
<
len
<
<
"
started
:
"
<
<
started_
;
if
(
sock_
)
{
VerboseLogPacket
(
data
len
SCTP_DUMP_INBOUND
)
;
usrsctp_conninput
(
reinterpret_cast
<
void
*
>
(
id_
)
data
len
0
)
;
}
else
{
}
}
void
SctpTransport
:
:
OnClosed
(
rtc
:
:
PacketTransportInternal
*
transport
)
{
SignalClosedAbruptly
(
)
;
}
void
SctpTransport
:
:
OnSendThresholdCallback
(
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
partial_outgoing_message_
.
has_value
(
)
)
{
if
(
!
SendBufferedMessage
(
)
)
{
return
;
}
}
SetReadyToSendData
(
)
;
}
sockaddr_conn
SctpTransport
:
:
GetSctpSockAddr
(
int
port
)
{
sockaddr_conn
sconn
=
{
0
}
;
sconn
.
sconn_family
=
AF_CONN
;
#
ifdef
HAVE_SCONN_LEN
sconn
.
sconn_len
=
sizeof
(
sockaddr_conn
)
;
#
endif
sconn
.
sconn_port
=
rtc
:
:
HostToNetwork16
(
port
)
;
sconn
.
sconn_addr
=
reinterpret_cast
<
void
*
>
(
id_
)
;
return
sconn
;
}
void
SctpTransport
:
:
OnPacketFromSctpToNetwork
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
buffer
.
size
(
)
>
(
kSctpMtu
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
debug_name_
<
<
"
-
>
OnPacketFromSctpToNetwork
(
.
.
.
)
:
"
"
SCTP
seems
to
have
made
a
packet
that
is
bigger
"
"
than
its
official
MTU
:
"
<
<
buffer
.
size
(
)
<
<
"
vs
max
of
"
<
<
kSctpMtu
;
}
TRACE_EVENT0
(
"
webrtc
"
"
SctpTransport
:
:
OnPacketFromSctpToNetwork
"
)
;
if
(
!
transport_
|
|
!
transport_
-
>
writable
(
)
)
{
return
;
}
transport_
-
>
SendPacket
(
buffer
.
data
<
char
>
(
)
buffer
.
size
(
)
rtc
:
:
PacketOptions
(
)
PF_NORMAL
)
;
}
int
SctpTransport
:
:
InjectDataOrNotificationFromSctpForTesting
(
const
void
*
data
size_t
length
struct
sctp_rcvinfo
rcv
int
flags
)
{
return
OnDataOrNotificationFromSctp
(
data
length
rcv
flags
)
;
}
int
SctpTransport
:
:
OnDataOrNotificationFromSctp
(
const
void
*
data
size_t
length
struct
sctp_rcvinfo
rcv
int
flags
)
{
if
(
!
data
)
{
RTC_LOG
(
LS_INFO
)
<
<
debug_name_
<
<
"
-
>
OnDataOrNotificationFromSctp
(
.
.
.
)
:
"
"
No
data
;
association
closed
.
"
;
return
kSctpSuccessReturn
;
}
if
(
flags
&
MSG_NOTIFICATION
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
debug_name_
<
<
"
-
>
OnDataOrNotificationFromSctp
(
.
.
.
)
:
SCTP
notification
"
<
<
"
length
=
"
<
<
length
;
rtc
:
:
CopyOnWriteBuffer
notification
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
length
)
;
network_thread_
-
>
PostTask
(
ToQueuedTask
(
task_safety_
[
this
notification
=
std
:
:
move
(
notification
)
]
(
)
{
OnNotificationFromSctp
(
notification
)
;
}
)
)
;
return
kSctpSuccessReturn
;
}
const
uint32_t
ppid
=
rtc
:
:
NetworkToHost32
(
rcv
.
rcv_ppid
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
debug_name_
<
<
"
-
>
OnDataOrNotificationFromSctp
(
.
.
.
)
:
SCTP
data
chunk
"
<
<
"
length
=
"
<
<
length
<
<
"
sid
=
"
<
<
rcv
.
rcv_sid
<
<
"
ppid
=
"
<
<
ppid
<
<
"
ssn
=
"
<
<
rcv
.
rcv_ssn
<
<
"
cum
-
tsn
=
"
<
<
rcv
.
rcv_cumtsn
<
<
"
eor
=
"
<
<
(
(
flags
&
MSG_EOR
)
?
"
y
"
:
"
n
"
)
;
DataMessageType
type
=
DMT_NONE
;
if
(
!
GetDataMediaType
(
ppid
&
type
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Received
an
unknown
PPID
"
<
<
ppid
<
<
"
on
an
SCTP
packet
.
Dropping
.
"
;
return
kSctpSuccessReturn
;
}
if
(
(
partial_incoming_message_
.
size
(
)
!
=
0
)
&
&
(
rcv
.
rcv_sid
!
=
partial_params_
.
sid
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Received
a
new
SID
without
EOR
in
the
previous
"
<
<
"
SCTP
packet
.
Discarding
the
previous
packet
.
"
;
partial_incoming_message_
.
Clear
(
)
;
}
ReceiveDataParams
params
;
params
.
type
=
type
;
params
.
sid
=
rcv
.
rcv_sid
;
params
.
seq_num
=
rcv
.
rcv_ssn
;
params
.
timestamp
=
0
;
partial_incoming_message_
.
AppendData
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
length
)
;
partial_params_
=
params
;
partial_flags_
=
flags
;
if
(
!
(
flags
&
MSG_EOR
)
)
{
if
(
partial_incoming_message_
.
size
(
)
<
kSctpSendBufferSize
)
{
return
kSctpSuccessReturn
;
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Handing
out
partial
SCTP
message
.
"
;
}
}
network_thread_
-
>
PostTask
(
webrtc
:
:
ToQueuedTask
(
task_safety_
[
this
params
=
std
:
:
move
(
params
)
message
=
partial_incoming_message_
]
(
)
{
OnDataFromSctpToTransport
(
params
message
)
;
}
)
)
;
partial_incoming_message_
.
Clear
(
)
;
return
kSctpSuccessReturn
;
}
void
SctpTransport
:
:
OnDataFromSctpToTransport
(
const
ReceiveDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
debug_name_
<
<
"
-
>
OnDataFromSctpToTransport
(
.
.
.
)
:
"
"
Posting
with
length
:
"
<
<
buffer
.
size
(
)
<
<
"
on
stream
"
<
<
params
.
sid
;
SignalDataReceived
(
params
buffer
)
;
}
void
SctpTransport
:
:
OnNotificationFromSctp
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
if
(
buffer
.
size
(
)
<
sizeof
(
sctp_notification
:
:
sn_header
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SCTP
notification
is
shorter
than
header
size
:
"
<
<
buffer
.
size
(
)
;
return
;
}
const
sctp_notification
&
notification
=
reinterpret_cast
<
const
sctp_notification
&
>
(
*
buffer
.
data
(
)
)
;
if
(
buffer
.
size
(
)
!
=
notification
.
sn_header
.
sn_length
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SCTP
notification
length
(
"
<
<
buffer
.
size
(
)
<
<
"
)
does
not
match
sn_length
field
(
"
<
<
notification
.
sn_header
.
sn_length
<
<
"
)
.
"
;
return
;
}
switch
(
notification
.
sn_header
.
sn_type
)
{
case
SCTP_ASSOC_CHANGE
:
RTC_LOG
(
LS_VERBOSE
)
<
<
"
SCTP_ASSOC_CHANGE
"
;
if
(
buffer
.
size
(
)
<
sizeof
(
notification
.
sn_assoc_change
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SCTP_ASSOC_CHANGE
notification
has
less
than
required
length
:
"
<
<
buffer
.
size
(
)
;
return
;
}
OnNotificationAssocChange
(
notification
.
sn_assoc_change
)
;
break
;
case
SCTP_REMOTE_ERROR
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_REMOTE_ERROR
"
;
break
;
case
SCTP_SHUTDOWN_EVENT
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_SHUTDOWN_EVENT
"
;
break
;
case
SCTP_ADAPTATION_INDICATION
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_ADAPTATION_INDICATION
"
;
break
;
case
SCTP_PARTIAL_DELIVERY_EVENT
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_PARTIAL_DELIVERY_EVENT
"
;
break
;
case
SCTP_AUTHENTICATION_EVENT
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_AUTHENTICATION_EVENT
"
;
break
;
case
SCTP_SENDER_DRY_EVENT
:
RTC_LOG
(
LS_VERBOSE
)
<
<
"
SCTP_SENDER_DRY_EVENT
"
;
SetReadyToSendData
(
)
;
break
;
case
SCTP_NOTIFICATIONS_STOPPED_EVENT
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_NOTIFICATIONS_STOPPED_EVENT
"
;
break
;
case
SCTP_SEND_FAILED_EVENT
:
{
if
(
buffer
.
size
(
)
<
sizeof
(
notification
.
sn_send_failed_event
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SCTP_SEND_FAILED_EVENT
notification
has
less
"
"
than
required
length
:
"
<
<
buffer
.
size
(
)
;
return
;
}
const
struct
sctp_send_failed_event
&
ssfe
=
notification
.
sn_send_failed_event
;
RTC_LOG
(
LS_WARNING
)
<
<
"
SCTP_SEND_FAILED_EVENT
:
message
with
"
"
PPID
=
"
<
<
rtc
:
:
NetworkToHost32
(
ssfe
.
ssfe_info
.
snd_ppid
)
<
<
"
SID
=
"
<
<
ssfe
.
ssfe_info
.
snd_sid
<
<
"
flags
=
"
<
<
rtc
:
:
ToHex
(
ssfe
.
ssfe_info
.
snd_flags
)
<
<
"
failed
to
sent
due
to
error
=
"
<
<
rtc
:
:
ToHex
(
ssfe
.
ssfe_error
)
;
break
;
}
case
SCTP_STREAM_RESET_EVENT
:
if
(
buffer
.
size
(
)
<
sizeof
(
notification
.
sn_strreset_event
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
SCTP_STREAM_RESET_EVENT
notification
has
less
"
"
than
required
length
:
"
<
<
buffer
.
size
(
)
;
return
;
}
OnStreamResetEvent
(
&
notification
.
sn_strreset_event
)
;
break
;
case
SCTP_ASSOC_RESET_EVENT
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_ASSOC_RESET_EVENT
"
;
break
;
case
SCTP_STREAM_CHANGE_EVENT
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_STREAM_CHANGE_EVENT
"
;
break
;
case
SCTP_PEER_ADDR_CHANGE
:
RTC_LOG
(
LS_INFO
)
<
<
"
SCTP_PEER_ADDR_CHANGE
"
;
break
;
default
:
RTC_LOG
(
LS_WARNING
)
<
<
"
Unknown
SCTP
event
:
"
<
<
notification
.
sn_header
.
sn_type
;
break
;
}
}
void
SctpTransport
:
:
OnNotificationAssocChange
(
const
sctp_assoc_change
&
change
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
switch
(
change
.
sac_state
)
{
case
SCTP_COMM_UP
:
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Association
change
SCTP_COMM_UP
stream
#
is
"
<
<
change
.
sac_outbound_streams
<
<
"
outbound
"
<
<
change
.
sac_inbound_streams
<
<
"
inbound
.
"
;
max_outbound_streams_
=
change
.
sac_outbound_streams
;
max_inbound_streams_
=
change
.
sac_inbound_streams
;
SignalAssociationChangeCommunicationUp
(
)
;
SendQueuedStreamResets
(
)
;
break
;
case
SCTP_COMM_LOST
:
RTC_LOG
(
LS_INFO
)
<
<
"
Association
change
SCTP_COMM_LOST
"
;
break
;
case
SCTP_RESTART
:
RTC_LOG
(
LS_INFO
)
<
<
"
Association
change
SCTP_RESTART
"
;
break
;
case
SCTP_SHUTDOWN_COMP
:
RTC_LOG
(
LS_INFO
)
<
<
"
Association
change
SCTP_SHUTDOWN_COMP
"
;
break
;
case
SCTP_CANT_STR_ASSOC
:
RTC_LOG
(
LS_INFO
)
<
<
"
Association
change
SCTP_CANT_STR_ASSOC
"
;
break
;
default
:
RTC_LOG
(
LS_INFO
)
<
<
"
Association
change
UNKNOWN
"
;
break
;
}
}
void
SctpTransport
:
:
OnStreamResetEvent
(
const
struct
sctp_stream_reset_event
*
evt
)
{
RTC_DCHECK_RUN_ON
(
network_thread_
)
;
const
int
num_sids
=
(
evt
-
>
strreset_length
-
sizeof
(
*
evt
)
)
/
sizeof
(
evt
-
>
strreset_stream_list
[
0
]
)
;
if
(
evt
-
>
strreset_flags
&
SCTP_STREAM_RESET_FAILED
)
{
for
(
std
:
:
map
<
uint32_t
StreamStatus
>
:
:
value_type
&
stream
:
stream_status_by_sid_
)
{
stream
.
second
.
outgoing_reset_initiated
=
false
;
}
SendQueuedStreamResets
(
)
;
return
;
}
for
(
int
i
=
0
;
i
<
num_sids
;
i
+
+
)
{
const
uint32_t
sid
=
evt
-
>
strreset_stream_list
[
i
]
;
auto
it
=
stream_status_by_sid_
.
find
(
sid
)
;
if
(
it
=
=
stream_status_by_sid_
.
end
(
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
SCTP_STREAM_RESET_EVENT
(
"
<
<
debug_name_
<
<
"
)
:
Unknown
sid
"
<
<
sid
;
continue
;
}
StreamStatus
&
status
=
it
-
>
second
;
if
(
evt
-
>
strreset_flags
&
SCTP_STREAM_RESET_INCOMING_SSN
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
SCTP_STREAM_RESET_INCOMING_SSN
(
"
<
<
debug_name_
<
<
"
)
:
sid
"
<
<
sid
;
status
.
incoming_reset_complete
=
true
;
if
(
!
status
.
closure_initiated
)
{
SignalClosingProcedureStartedRemotely
(
sid
)
;
}
}
if
(
evt
-
>
strreset_flags
&
SCTP_STREAM_RESET_OUTGOING_SSN
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
SCTP_STREAM_RESET_OUTGOING_SSN
(
"
<
<
debug_name_
<
<
"
)
:
sid
"
<
<
sid
;
status
.
outgoing_reset_complete
=
true
;
}
if
(
status
.
reset_complete
(
)
)
{
stream_status_by_sid_
.
erase
(
it
)
;
SignalClosingProcedureComplete
(
sid
)
;
}
}
SendQueuedStreamResets
(
)
;
}
}
