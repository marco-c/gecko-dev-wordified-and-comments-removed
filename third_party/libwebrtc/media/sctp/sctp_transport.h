#
ifndef
MEDIA_SCTP_SCTP_TRANSPORT_H_
#
define
MEDIA_SCTP_SCTP_TRANSPORT_H_
#
include
<
errno
.
h
>
#
include
<
cstdint
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
transport
/
sctp_transport_factory_interface
.
h
"
#
include
"
rtc_base
/
async_invoker
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
media
/
base
/
media_channel
.
h
"
#
include
"
media
/
sctp
/
sctp_transport_internal
.
h
"
struct
sockaddr_conn
;
struct
sctp_assoc_change
;
struct
sctp_rcvinfo
;
struct
sctp_stream_reset_event
;
struct
sctp_sendv_spa
;
struct
socket
;
namespace
cricket
{
struct
SctpInboundPacket
;
class
SctpTransport
:
public
SctpTransportInternal
public
sigslot
:
:
has_slots
<
>
{
public
:
SctpTransport
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
PacketTransportInternal
*
transport
)
;
~
SctpTransport
(
)
override
;
void
SetDtlsTransport
(
rtc
:
:
PacketTransportInternal
*
transport
)
override
;
bool
Start
(
int
local_port
int
remote_port
int
max_message_size
)
override
;
bool
OpenStream
(
int
sid
)
override
;
bool
ResetStream
(
int
sid
)
override
;
bool
SendData
(
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
SendDataResult
*
result
=
nullptr
)
override
;
bool
ReadyToSendData
(
)
override
;
int
max_message_size
(
)
const
override
{
return
max_message_size_
;
}
absl
:
:
optional
<
int
>
max_outbound_streams
(
)
const
override
{
return
max_outbound_streams_
;
}
absl
:
:
optional
<
int
>
max_inbound_streams
(
)
const
override
{
return
max_inbound_streams_
;
}
void
set_debug_name_for_testing
(
const
char
*
debug_name
)
override
{
debug_name_
=
debug_name
;
}
int
InjectDataOrNotificationFromSctpForTesting
(
void
*
data
size_t
length
struct
sctp_rcvinfo
rcv
int
flags
)
;
rtc
:
:
Thread
*
network_thread
(
)
const
{
return
network_thread_
;
}
private
:
class
OutgoingMessage
{
public
:
OutgoingMessage
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
const
SendDataParams
&
send_params
)
:
buffer_
(
buffer
)
send_params_
(
send_params
)
{
}
void
Advance
(
size_t
increment
)
{
RTC_DCHECK_LE
(
increment
+
offset_
buffer_
.
size
(
)
)
;
offset_
+
=
increment
;
}
size_t
size
(
)
const
{
return
buffer_
.
size
(
)
-
offset_
;
}
const
void
*
data
(
)
const
{
return
buffer_
.
data
(
)
+
offset_
;
}
SendDataParams
send_params
(
)
const
{
return
send_params_
;
}
private
:
const
rtc
:
:
CopyOnWriteBuffer
buffer_
;
const
SendDataParams
send_params_
;
size_t
offset_
=
0
;
}
;
void
ConnectTransportSignals
(
)
;
void
DisconnectTransportSignals
(
)
;
bool
Connect
(
)
;
bool
OpenSctpSocket
(
)
;
bool
ConfigureSctpSocket
(
)
;
void
CloseSctpSocket
(
)
;
bool
SendQueuedStreamResets
(
)
;
void
SetReadyToSendData
(
)
;
bool
SendBufferedMessage
(
)
;
SendDataResult
SendMessageInternal
(
OutgoingMessage
*
message
)
;
void
OnWritableState
(
rtc
:
:
PacketTransportInternal
*
transport
)
;
virtual
void
OnPacketRead
(
rtc
:
:
PacketTransportInternal
*
transport
const
char
*
data
size_t
len
const
int64_t
&
packet_time_us
int
flags
)
;
void
OnClosed
(
rtc
:
:
PacketTransportInternal
*
transport
)
;
void
OnSendThresholdCallback
(
)
;
sockaddr_conn
GetSctpSockAddr
(
int
port
)
;
void
OnPacketFromSctpToNetwork
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
int
OnDataOrNotificationFromSctp
(
void
*
data
size_t
length
struct
sctp_rcvinfo
rcv
int
flags
)
;
void
OnDataFromSctpToTransport
(
const
ReceiveDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
void
OnNotificationFromSctp
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
void
OnNotificationAssocChange
(
const
sctp_assoc_change
&
change
)
;
void
OnStreamResetEvent
(
const
struct
sctp_stream_reset_event
*
evt
)
;
rtc
:
:
Thread
*
network_thread_
;
rtc
:
:
AsyncInvoker
invoker_
;
rtc
:
:
PacketTransportInternal
*
transport_
=
nullptr
;
rtc
:
:
CopyOnWriteBuffer
partial_incoming_message_
;
ReceiveDataParams
partial_params_
;
int
partial_flags_
;
absl
:
:
optional
<
OutgoingMessage
>
partial_outgoing_message_
;
bool
was_ever_writable_
=
false
;
int
local_port_
=
kSctpDefaultPort
;
int
remote_port_
=
kSctpDefaultPort
;
int
max_message_size_
=
kSctpSendBufferSize
;
struct
socket
*
sock_
=
nullptr
;
bool
started_
=
false
;
bool
ready_to_send_data_
=
false
;
struct
StreamStatus
{
bool
closure_initiated
=
false
;
bool
outgoing_reset_initiated
=
false
;
bool
outgoing_reset_complete
=
false
;
bool
incoming_reset_complete
=
false
;
bool
is_open
(
)
const
{
return
!
closure_initiated
&
&
!
incoming_reset_complete
&
&
!
outgoing_reset_complete
;
}
bool
need_outgoing_reset
(
)
const
{
return
(
incoming_reset_complete
|
|
closure_initiated
)
&
&
!
outgoing_reset_initiated
;
}
bool
reset_complete
(
)
const
{
return
outgoing_reset_complete
&
&
incoming_reset_complete
;
}
}
;
std
:
:
map
<
uint32_t
StreamStatus
>
stream_status_by_sid_
;
const
char
*
debug_name_
=
"
SctpTransport
"
;
class
UsrSctpWrapper
;
absl
:
:
optional
<
int
>
max_outbound_streams_
;
absl
:
:
optional
<
int
>
max_inbound_streams_
;
uintptr_t
id_
=
0
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
SctpTransport
)
;
}
;
class
SctpTransportFactory
:
public
webrtc
:
:
SctpTransportFactoryInterface
{
public
:
explicit
SctpTransportFactory
(
rtc
:
:
Thread
*
network_thread
)
:
network_thread_
(
network_thread
)
{
}
std
:
:
unique_ptr
<
SctpTransportInternal
>
CreateSctpTransport
(
rtc
:
:
PacketTransportInternal
*
transport
)
override
{
return
std
:
:
unique_ptr
<
SctpTransportInternal
>
(
new
SctpTransport
(
network_thread_
transport
)
)
;
}
private
:
rtc
:
:
Thread
*
network_thread_
;
}
;
}
#
endif
