#
include
"
media
/
engine
/
simulcast_encoder_adapter
.
h
"
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_codec_constants
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_factory
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_software_fallback_wrapper
.
h
"
#
include
"
media
/
base
/
video_common
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_error_codes
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
simulcast_rate_allocator
.
h
"
#
include
"
rtc_base
/
atomic_ops
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
rate_control_settings
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
namespace
{
const
unsigned
int
kDefaultMinQp
=
2
;
const
unsigned
int
kDefaultMaxQp
=
56
;
const
unsigned
int
kLowestResMaxQp
=
45
;
absl
:
:
optional
<
unsigned
int
>
GetScreenshareBoostedQpValue
(
)
{
std
:
:
string
experiment_group
=
webrtc
:
:
field_trial
:
:
FindFullName
(
"
WebRTC
-
BoostedScreenshareQp
"
)
;
unsigned
int
qp
;
if
(
sscanf
(
experiment_group
.
c_str
(
)
"
%
u
"
&
qp
)
!
=
1
)
return
absl
:
:
nullopt
;
qp
=
std
:
:
min
(
qp
63u
)
;
qp
=
std
:
:
max
(
qp
1u
)
;
return
qp
;
}
uint32_t
SumStreamMaxBitrate
(
int
streams
const
webrtc
:
:
VideoCodec
&
codec
)
{
uint32_t
bitrate_sum
=
0
;
for
(
int
i
=
0
;
i
<
streams
;
+
+
i
)
{
bitrate_sum
+
=
codec
.
simulcastStream
[
i
]
.
maxBitrate
;
}
return
bitrate_sum
;
}
int
CountAllStreams
(
const
webrtc
:
:
VideoCodec
&
codec
)
{
int
total_streams_count
=
codec
.
numberOfSimulcastStreams
<
1
?
1
:
codec
.
numberOfSimulcastStreams
;
uint32_t
simulcast_max_bitrate
=
SumStreamMaxBitrate
(
total_streams_count
codec
)
;
if
(
simulcast_max_bitrate
=
=
0
)
{
total_streams_count
=
1
;
}
return
total_streams_count
;
}
int
CountActiveStreams
(
const
webrtc
:
:
VideoCodec
&
codec
)
{
if
(
codec
.
numberOfSimulcastStreams
<
1
)
{
return
1
;
}
int
total_streams_count
=
CountAllStreams
(
codec
)
;
int
active_streams_count
=
0
;
for
(
int
i
=
0
;
i
<
total_streams_count
;
+
+
i
)
{
if
(
codec
.
simulcastStream
[
i
]
.
active
)
{
+
+
active_streams_count
;
}
}
return
active_streams_count
;
}
int
VerifyCodec
(
const
webrtc
:
:
VideoCodec
*
inst
)
{
if
(
inst
=
=
nullptr
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
maxFramerate
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
maxBitrate
>
0
&
&
inst
-
>
startBitrate
>
inst
-
>
maxBitrate
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
width
<
=
1
|
|
inst
-
>
height
<
=
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
codecType
=
=
webrtc
:
:
kVideoCodecVP8
&
&
inst
-
>
VP8
(
)
.
automaticResizeOn
&
&
CountActiveStreams
(
*
inst
)
>
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
bool
StreamQualityCompare
(
const
webrtc
:
:
SpatialLayer
&
a
const
webrtc
:
:
SpatialLayer
&
b
)
{
return
std
:
:
tie
(
a
.
height
a
.
width
a
.
maxBitrate
a
.
maxFramerate
)
<
std
:
:
tie
(
b
.
height
b
.
width
b
.
maxBitrate
b
.
maxFramerate
)
;
}
void
GetLowestAndHighestQualityStreamIndixes
(
rtc
:
:
ArrayView
<
webrtc
:
:
SpatialLayer
>
streams
int
*
lowest_quality_stream_idx
int
*
highest_quality_stream_idx
)
{
const
auto
lowest_highest_quality_streams
=
absl
:
:
c_minmax_element
(
streams
StreamQualityCompare
)
;
*
lowest_quality_stream_idx
=
std
:
:
distance
(
streams
.
begin
(
)
lowest_highest_quality_streams
.
first
)
;
*
highest_quality_stream_idx
=
std
:
:
distance
(
streams
.
begin
(
)
lowest_highest_quality_streams
.
second
)
;
}
std
:
:
vector
<
uint32_t
>
GetStreamStartBitratesKbps
(
const
webrtc
:
:
VideoCodec
&
codec
)
{
std
:
:
vector
<
uint32_t
>
start_bitrates
;
std
:
:
unique_ptr
<
webrtc
:
:
VideoBitrateAllocator
>
rate_allocator
=
std
:
:
make_unique
<
webrtc
:
:
SimulcastRateAllocator
>
(
codec
)
;
webrtc
:
:
VideoBitrateAllocation
allocation
=
rate_allocator
-
>
Allocate
(
webrtc
:
:
VideoBitrateAllocationParameters
(
codec
.
startBitrate
*
1000
codec
.
maxFramerate
)
)
;
int
total_streams_count
=
CountAllStreams
(
codec
)
;
for
(
int
i
=
0
;
i
<
total_streams_count
;
+
+
i
)
{
uint32_t
stream_bitrate
=
allocation
.
GetSpatialLayerSum
(
i
)
/
1000
;
start_bitrates
.
push_back
(
stream_bitrate
)
;
}
return
start_bitrates
;
}
}
namespace
webrtc
{
SimulcastEncoderAdapter
:
:
EncoderContext
:
:
EncoderContext
(
std
:
:
unique_ptr
<
VideoEncoder
>
encoder
bool
prefer_temporal_support
)
:
encoder_
(
std
:
:
move
(
encoder
)
)
prefer_temporal_support_
(
prefer_temporal_support
)
{
}
void
SimulcastEncoderAdapter
:
:
EncoderContext
:
:
Release
(
)
{
if
(
encoder_
)
{
encoder_
-
>
RegisterEncodeCompleteCallback
(
nullptr
)
;
encoder_
-
>
Release
(
)
;
}
}
SimulcastEncoderAdapter
:
:
StreamContext
:
:
StreamContext
(
SimulcastEncoderAdapter
*
parent
std
:
:
unique_ptr
<
EncoderContext
>
encoder_context
std
:
:
unique_ptr
<
FramerateController
>
framerate_controller
int
stream_idx
uint16_t
width
uint16_t
height
bool
is_paused
)
:
parent_
(
parent
)
encoder_context_
(
std
:
:
move
(
encoder_context
)
)
framerate_controller_
(
std
:
:
move
(
framerate_controller
)
)
stream_idx_
(
stream_idx
)
width_
(
width
)
height_
(
height
)
is_keyframe_needed_
(
false
)
is_paused_
(
is_paused
)
{
if
(
parent_
)
{
encoder_context_
-
>
encoder
(
)
.
RegisterEncodeCompleteCallback
(
this
)
;
}
}
SimulcastEncoderAdapter
:
:
StreamContext
:
:
StreamContext
(
StreamContext
&
&
rhs
)
:
parent_
(
rhs
.
parent_
)
encoder_context_
(
std
:
:
move
(
rhs
.
encoder_context_
)
)
framerate_controller_
(
std
:
:
move
(
rhs
.
framerate_controller_
)
)
stream_idx_
(
rhs
.
stream_idx_
)
width_
(
rhs
.
width_
)
height_
(
rhs
.
height_
)
is_keyframe_needed_
(
rhs
.
is_keyframe_needed_
)
is_paused_
(
rhs
.
is_paused_
)
{
if
(
parent_
)
{
encoder_context_
-
>
encoder
(
)
.
RegisterEncodeCompleteCallback
(
this
)
;
}
}
SimulcastEncoderAdapter
:
:
StreamContext
:
:
~
StreamContext
(
)
{
if
(
encoder_context_
)
{
encoder_context_
-
>
Release
(
)
;
}
}
std
:
:
unique_ptr
<
SimulcastEncoderAdapter
:
:
EncoderContext
>
SimulcastEncoderAdapter
:
:
StreamContext
:
:
ReleaseEncoderContext
(
)
&
&
{
encoder_context_
-
>
Release
(
)
;
return
std
:
:
move
(
encoder_context_
)
;
}
void
SimulcastEncoderAdapter
:
:
StreamContext
:
:
OnKeyframe
(
Timestamp
timestamp
)
{
is_keyframe_needed_
=
false
;
if
(
framerate_controller_
)
{
framerate_controller_
-
>
AddFrame
(
timestamp
.
ms
(
)
)
;
}
}
bool
SimulcastEncoderAdapter
:
:
StreamContext
:
:
ShouldDropFrame
(
Timestamp
timestamp
)
{
if
(
!
framerate_controller_
)
{
return
false
;
}
if
(
framerate_controller_
-
>
DropFrame
(
timestamp
.
ms
(
)
)
)
{
return
true
;
}
framerate_controller_
-
>
AddFrame
(
timestamp
.
ms
(
)
)
;
return
false
;
}
EncodedImageCallback
:
:
Result
SimulcastEncoderAdapter
:
:
StreamContext
:
:
OnEncodedImage
(
const
EncodedImage
&
encoded_image
const
CodecSpecificInfo
*
codec_specific_info
)
{
RTC_CHECK
(
parent_
)
;
return
parent_
-
>
OnEncodedImage
(
stream_idx_
encoded_image
codec_specific_info
)
;
}
void
SimulcastEncoderAdapter
:
:
StreamContext
:
:
OnDroppedFrame
(
DropReason
)
{
RTC_CHECK
(
parent_
)
;
parent_
-
>
OnDroppedFrame
(
stream_idx_
)
;
}
SimulcastEncoderAdapter
:
:
SimulcastEncoderAdapter
(
VideoEncoderFactory
*
factory
const
SdpVideoFormat
&
format
)
:
SimulcastEncoderAdapter
(
factory
nullptr
format
)
{
}
SimulcastEncoderAdapter
:
:
SimulcastEncoderAdapter
(
VideoEncoderFactory
*
primary_factory
VideoEncoderFactory
*
fallback_factory
const
SdpVideoFormat
&
format
)
:
inited_
(
0
)
primary_encoder_factory_
(
primary_factory
)
fallback_encoder_factory_
(
fallback_factory
)
video_format_
(
format
)
total_streams_count_
(
0
)
bypass_mode_
(
false
)
encoded_complete_callback_
(
nullptr
)
experimental_boosted_screenshare_qp_
(
GetScreenshareBoostedQpValue
(
)
)
boost_base_layer_quality_
(
RateControlSettings
:
:
ParseFromFieldTrials
(
)
.
Vp8BoostBaseLayerQuality
(
)
)
prefer_temporal_support_on_base_layer_
(
field_trial
:
:
IsEnabled
(
"
WebRTC
-
Video
-
PreferTemporalSupportOnBaseLayer
"
)
)
{
RTC_DCHECK
(
primary_factory
)
;
encoder_queue_
.
Detach
(
)
;
}
SimulcastEncoderAdapter
:
:
~
SimulcastEncoderAdapter
(
)
{
RTC_DCHECK
(
!
Initialized
(
)
)
;
DestroyStoredEncoders
(
)
;
}
void
SimulcastEncoderAdapter
:
:
SetFecControllerOverride
(
FecControllerOverride
*
)
{
}
int
SimulcastEncoderAdapter
:
:
Release
(
)
{
RTC_DCHECK_RUN_ON
(
&
encoder_queue_
)
;
while
(
!
stream_contexts_
.
empty
(
)
)
{
cached_encoder_contexts_
.
push_front
(
std
:
:
move
(
stream_contexts_
.
back
(
)
)
.
ReleaseEncoderContext
(
)
)
;
stream_contexts_
.
pop_back
(
)
;
}
bypass_mode_
=
false
;
encoder_queue_
.
Detach
(
)
;
rtc
:
:
AtomicOps
:
:
ReleaseStore
(
&
inited_
0
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
InitEncode
(
const
VideoCodec
*
inst
const
VideoEncoder
:
:
Settings
&
settings
)
{
RTC_DCHECK_RUN_ON
(
&
encoder_queue_
)
;
if
(
settings
.
number_of_cores
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
int
ret
=
VerifyCodec
(
inst
)
;
if
(
ret
<
0
)
{
return
ret
;
}
Release
(
)
;
codec_
=
*
inst
;
total_streams_count_
=
CountAllStreams
(
*
inst
)
;
if
(
codec_
.
qpMax
<
kDefaultMinQp
)
{
codec_
.
qpMax
=
kDefaultMaxQp
;
}
bool
is_legacy_singlecast
=
codec_
.
numberOfSimulcastStreams
=
=
0
;
int
lowest_quality_stream_idx
=
0
;
int
highest_quality_stream_idx
=
0
;
if
(
!
is_legacy_singlecast
)
{
GetLowestAndHighestQualityStreamIndixes
(
rtc
:
:
ArrayView
<
SpatialLayer
>
(
codec_
.
simulcastStream
total_streams_count_
)
&
lowest_quality_stream_idx
&
highest_quality_stream_idx
)
;
}
std
:
:
unique_ptr
<
EncoderContext
>
encoder_context
=
FetchOrCreateEncoderContext
(
(
is_legacy_singlecast
|
|
codec_
.
simulcastStream
[
lowest_quality_stream_idx
]
.
active
)
)
;
if
(
encoder_context
=
=
nullptr
)
{
return
WEBRTC_VIDEO_CODEC_MEMORY
;
}
if
(
total_streams_count_
=
=
1
|
|
encoder_context
-
>
encoder
(
)
.
GetEncoderInfo
(
)
.
supports_simulcast
)
{
int
ret
=
encoder_context
-
>
encoder
(
)
.
InitEncode
(
&
codec_
settings
)
;
if
(
ret
>
=
0
)
{
int
active_streams_count
=
CountActiveStreams
(
*
inst
)
;
stream_contexts_
.
emplace_back
(
nullptr
std
:
:
move
(
encoder_context
)
nullptr
0
codec_
.
width
codec_
.
height
active_streams_count
=
=
0
)
;
bypass_mode_
=
true
;
DestroyStoredEncoders
(
)
;
rtc
:
:
AtomicOps
:
:
ReleaseStore
(
&
inited_
1
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
encoder_context
-
>
Release
(
)
;
if
(
total_streams_count_
=
=
1
)
{
return
ret
;
}
}
std
:
:
vector
<
uint32_t
>
stream_start_bitrate_kbps
=
GetStreamStartBitratesKbps
(
codec_
)
;
for
(
int
stream_idx
=
0
;
stream_idx
<
total_streams_count_
;
+
+
stream_idx
)
{
if
(
!
is_legacy_singlecast
&
&
!
codec_
.
simulcastStream
[
stream_idx
]
.
active
)
{
continue
;
}
if
(
encoder_context
=
=
nullptr
)
{
encoder_context
=
FetchOrCreateEncoderContext
(
stream_idx
=
=
lowest_quality_stream_idx
)
;
}
if
(
encoder_context
=
=
nullptr
)
{
Release
(
)
;
return
WEBRTC_VIDEO_CODEC_MEMORY
;
}
VideoCodec
stream_codec
=
MakeStreamCodec
(
codec_
stream_idx
stream_start_bitrate_kbps
[
stream_idx
]
stream_idx
=
=
lowest_quality_stream_idx
stream_idx
=
=
highest_quality_stream_idx
)
;
int
ret
=
encoder_context
-
>
encoder
(
)
.
InitEncode
(
&
stream_codec
settings
)
;
if
(
ret
<
0
)
{
encoder_context
.
reset
(
)
;
Release
(
)
;
return
ret
;
}
SimulcastEncoderAdapter
*
parent
=
stream_idx
>
0
?
this
:
nullptr
;
bool
is_paused
=
stream_start_bitrate_kbps
[
stream_idx
]
=
=
0
;
stream_contexts_
.
emplace_back
(
parent
std
:
:
move
(
encoder_context
)
std
:
:
make_unique
<
FramerateController
>
(
stream_codec
.
maxFramerate
)
stream_idx
stream_codec
.
width
stream_codec
.
height
is_paused
)
;
}
DestroyStoredEncoders
(
)
;
rtc
:
:
AtomicOps
:
:
ReleaseStore
(
&
inited_
1
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
Encode
(
const
VideoFrame
&
input_image
const
std
:
:
vector
<
VideoFrameType
>
*
frame_types
)
{
RTC_DCHECK_RUN_ON
(
&
encoder_queue_
)
;
if
(
!
Initialized
(
)
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
encoded_complete_callback_
=
=
nullptr
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
encoder_info_override_
.
requested_resolution_alignment
(
)
)
{
const
int
alignment
=
*
encoder_info_override_
.
requested_resolution_alignment
(
)
;
if
(
input_image
.
width
(
)
%
alignment
!
=
0
|
|
input_image
.
height
(
)
%
alignment
!
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Frame
"
<
<
input_image
.
width
(
)
<
<
"
x
"
<
<
input_image
.
height
(
)
<
<
"
not
divisible
by
"
<
<
alignment
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
if
(
encoder_info_override_
.
apply_alignment_to_all_simulcast_layers
(
)
)
{
for
(
const
auto
&
layer
:
stream_contexts_
)
{
if
(
layer
.
width
(
)
%
alignment
!
=
0
|
|
layer
.
height
(
)
%
alignment
!
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Codec
"
<
<
layer
.
width
(
)
<
<
"
x
"
<
<
layer
.
height
(
)
<
<
"
not
divisible
by
"
<
<
alignment
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
}
}
}
bool
is_keyframe_needed
=
false
;
if
(
frame_types
)
{
for
(
const
auto
&
frame_type
:
*
frame_types
)
{
if
(
frame_type
=
=
VideoFrameType
:
:
kVideoFrameKey
)
{
is_keyframe_needed
=
true
;
break
;
}
}
}
if
(
!
is_keyframe_needed
)
{
for
(
const
auto
&
layer
:
stream_contexts_
)
{
if
(
layer
.
is_keyframe_needed
(
)
)
{
is_keyframe_needed
=
true
;
break
;
}
}
}
rtc
:
:
scoped_refptr
<
VideoFrameBuffer
>
src_buffer
;
int
src_width
=
input_image
.
width
(
)
;
int
src_height
=
input_image
.
height
(
)
;
for
(
auto
&
layer
:
stream_contexts_
)
{
if
(
layer
.
is_paused
(
)
)
{
continue
;
}
const
Timestamp
frame_timestamp
=
Timestamp
:
:
Micros
(
(
1000
*
input_image
.
timestamp
(
)
)
/
90
)
;
std
:
:
vector
<
VideoFrameType
>
stream_frame_types
(
bypass_mode_
?
total_streams_count_
:
1
)
;
if
(
is_keyframe_needed
)
{
std
:
:
fill
(
stream_frame_types
.
begin
(
)
stream_frame_types
.
end
(
)
VideoFrameType
:
:
kVideoFrameKey
)
;
layer
.
OnKeyframe
(
frame_timestamp
)
;
}
else
{
if
(
layer
.
ShouldDropFrame
(
frame_timestamp
)
)
{
continue
;
}
std
:
:
fill
(
stream_frame_types
.
begin
(
)
stream_frame_types
.
end
(
)
VideoFrameType
:
:
kVideoFrameDelta
)
;
}
if
(
(
layer
.
width
(
)
=
=
src_width
&
&
layer
.
height
(
)
=
=
src_height
)
|
|
(
input_image
.
video_frame_buffer
(
)
-
>
type
(
)
=
=
VideoFrameBuffer
:
:
Type
:
:
kNative
&
&
layer
.
encoder
(
)
.
GetEncoderInfo
(
)
.
supports_native_handle
)
)
{
int
ret
=
layer
.
encoder
(
)
.
Encode
(
input_image
&
stream_frame_types
)
;
if
(
ret
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
return
ret
;
}
}
else
{
if
(
src_buffer
=
=
nullptr
)
{
src_buffer
=
input_image
.
video_frame_buffer
(
)
;
}
rtc
:
:
scoped_refptr
<
VideoFrameBuffer
>
dst_buffer
=
src_buffer
-
>
Scale
(
layer
.
width
(
)
layer
.
height
(
)
)
;
if
(
!
dst_buffer
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
scale
video
frame
"
;
return
WEBRTC_VIDEO_CODEC_ENCODER_FAILURE
;
}
VideoFrame
frame
(
input_image
)
;
frame
.
set_video_frame_buffer
(
dst_buffer
)
;
frame
.
set_rotation
(
webrtc
:
:
kVideoRotation_0
)
;
frame
.
set_update_rect
(
VideoFrame
:
:
UpdateRect
{
0
0
frame
.
width
(
)
frame
.
height
(
)
}
)
;
int
ret
=
layer
.
encoder
(
)
.
Encode
(
frame
&
stream_frame_types
)
;
if
(
ret
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
return
ret
;
}
}
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
RegisterEncodeCompleteCallback
(
EncodedImageCallback
*
callback
)
{
RTC_DCHECK_RUN_ON
(
&
encoder_queue_
)
;
encoded_complete_callback_
=
callback
;
if
(
!
stream_contexts_
.
empty
(
)
&
&
stream_contexts_
.
front
(
)
.
stream_idx
(
)
=
=
0
)
{
stream_contexts_
.
front
(
)
.
encoder
(
)
.
RegisterEncodeCompleteCallback
(
callback
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
SimulcastEncoderAdapter
:
:
SetRates
(
const
RateControlParameters
&
parameters
)
{
RTC_DCHECK_RUN_ON
(
&
encoder_queue_
)
;
if
(
!
Initialized
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
SetRates
while
not
initialized
"
;
return
;
}
if
(
parameters
.
framerate_fps
<
1
.
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Invalid
framerate
:
"
<
<
parameters
.
framerate_fps
;
return
;
}
codec_
.
maxFramerate
=
static_cast
<
uint32_t
>
(
parameters
.
framerate_fps
+
0
.
5
)
;
if
(
bypass_mode_
)
{
stream_contexts_
.
front
(
)
.
encoder
(
)
.
SetRates
(
parameters
)
;
return
;
}
for
(
StreamContext
&
layer_context
:
stream_contexts_
)
{
int
stream_idx
=
layer_context
.
stream_idx
(
)
;
uint32_t
stream_bitrate_kbps
=
parameters
.
bitrate
.
GetSpatialLayerSum
(
stream_idx
)
/
1000
;
if
(
stream_bitrate_kbps
>
0
&
&
layer_context
.
is_paused
(
)
)
{
layer_context
.
set_is_keyframe_needed
(
)
;
}
layer_context
.
set_is_paused
(
stream_bitrate_kbps
=
=
0
)
;
RateControlParameters
stream_parameters
=
parameters
;
stream_parameters
.
bitrate
=
VideoBitrateAllocation
(
)
;
for
(
int
i
=
0
;
i
<
kMaxTemporalStreams
;
+
+
i
)
{
if
(
parameters
.
bitrate
.
HasBitrate
(
stream_idx
i
)
)
{
stream_parameters
.
bitrate
.
SetBitrate
(
0
i
parameters
.
bitrate
.
GetBitrate
(
stream_idx
i
)
)
;
}
}
if
(
!
parameters
.
bandwidth_allocation
.
IsZero
(
)
&
&
parameters
.
bitrate
.
get_sum_bps
(
)
>
0
)
{
stream_parameters
.
bandwidth_allocation
=
DataRate
:
:
BitsPerSec
(
(
parameters
.
bandwidth_allocation
.
bps
(
)
*
stream_parameters
.
bitrate
.
get_sum_bps
(
)
)
/
parameters
.
bitrate
.
get_sum_bps
(
)
)
;
if
(
stream_parameters
.
bandwidth_allocation
.
bps
(
)
<
stream_parameters
.
bitrate
.
get_sum_bps
(
)
)
{
stream_parameters
.
bandwidth_allocation
=
DataRate
:
:
BitsPerSec
(
stream_parameters
.
bitrate
.
get_sum_bps
(
)
)
;
}
}
stream_parameters
.
framerate_fps
=
std
:
:
min
<
double
>
(
parameters
.
framerate_fps
layer_context
.
target_fps
(
)
.
value_or
(
parameters
.
framerate_fps
)
)
;
layer_context
.
encoder
(
)
.
SetRates
(
stream_parameters
)
;
}
}
void
SimulcastEncoderAdapter
:
:
OnPacketLossRateUpdate
(
float
packet_loss_rate
)
{
for
(
auto
&
c
:
stream_contexts_
)
{
c
.
encoder
(
)
.
OnPacketLossRateUpdate
(
packet_loss_rate
)
;
}
}
void
SimulcastEncoderAdapter
:
:
OnRttUpdate
(
int64_t
rtt_ms
)
{
for
(
auto
&
c
:
stream_contexts_
)
{
c
.
encoder
(
)
.
OnRttUpdate
(
rtt_ms
)
;
}
}
void
SimulcastEncoderAdapter
:
:
OnLossNotification
(
const
LossNotification
&
loss_notification
)
{
for
(
auto
&
c
:
stream_contexts_
)
{
c
.
encoder
(
)
.
OnLossNotification
(
loss_notification
)
;
}
}
EncodedImageCallback
:
:
Result
SimulcastEncoderAdapter
:
:
OnEncodedImage
(
size_t
stream_idx
const
EncodedImage
&
encodedImage
const
CodecSpecificInfo
*
codecSpecificInfo
)
{
EncodedImage
stream_image
(
encodedImage
)
;
CodecSpecificInfo
stream_codec_specific
=
*
codecSpecificInfo
;
stream_image
.
SetSpatialIndex
(
stream_idx
)
;
return
encoded_complete_callback_
-
>
OnEncodedImage
(
stream_image
&
stream_codec_specific
)
;
}
void
SimulcastEncoderAdapter
:
:
OnDroppedFrame
(
size_t
stream_idx
)
{
}
bool
SimulcastEncoderAdapter
:
:
Initialized
(
)
const
{
return
rtc
:
:
AtomicOps
:
:
AcquireLoad
(
&
inited_
)
=
=
1
;
}
void
SimulcastEncoderAdapter
:
:
DestroyStoredEncoders
(
)
{
while
(
!
cached_encoder_contexts_
.
empty
(
)
)
{
cached_encoder_contexts_
.
pop_back
(
)
;
}
}
std
:
:
unique_ptr
<
SimulcastEncoderAdapter
:
:
EncoderContext
>
SimulcastEncoderAdapter
:
:
FetchOrCreateEncoderContext
(
bool
is_lowest_quality_stream
)
{
bool
prefer_temporal_support
=
fallback_encoder_factory_
!
=
nullptr
&
&
is_lowest_quality_stream
&
&
prefer_temporal_support_on_base_layer_
;
auto
encoder_context_iter
=
std
:
:
find_if
(
cached_encoder_contexts_
.
begin
(
)
cached_encoder_contexts_
.
end
(
)
[
&
]
(
auto
&
encoder_context
)
{
return
encoder_context
-
>
prefer_temporal_support
(
)
=
=
prefer_temporal_support
;
}
)
;
std
:
:
unique_ptr
<
SimulcastEncoderAdapter
:
:
EncoderContext
>
encoder_context
;
if
(
encoder_context_iter
!
=
cached_encoder_contexts_
.
end
(
)
)
{
encoder_context
=
std
:
:
move
(
*
encoder_context_iter
)
;
cached_encoder_contexts_
.
erase
(
encoder_context_iter
)
;
}
else
{
std
:
:
unique_ptr
<
VideoEncoder
>
encoder
=
primary_encoder_factory_
-
>
CreateVideoEncoder
(
video_format_
)
;
if
(
fallback_encoder_factory_
!
=
nullptr
)
{
encoder
=
CreateVideoEncoderSoftwareFallbackWrapper
(
fallback_encoder_factory_
-
>
CreateVideoEncoder
(
video_format_
)
std
:
:
move
(
encoder
)
prefer_temporal_support
)
;
}
encoder_context
=
std
:
:
make_unique
<
SimulcastEncoderAdapter
:
:
EncoderContext
>
(
std
:
:
move
(
encoder
)
prefer_temporal_support
)
;
}
encoder_context
-
>
encoder
(
)
.
RegisterEncodeCompleteCallback
(
encoded_complete_callback_
)
;
return
encoder_context
;
}
webrtc
:
:
VideoCodec
SimulcastEncoderAdapter
:
:
MakeStreamCodec
(
const
webrtc
:
:
VideoCodec
&
codec
int
stream_idx
uint32_t
start_bitrate_kbps
bool
is_lowest_quality_stream
bool
is_highest_quality_stream
)
{
webrtc
:
:
VideoCodec
codec_params
=
codec
;
const
SpatialLayer
&
stream_params
=
codec
.
simulcastStream
[
stream_idx
]
;
codec_params
.
numberOfSimulcastStreams
=
0
;
codec_params
.
width
=
stream_params
.
width
;
codec_params
.
height
=
stream_params
.
height
;
codec_params
.
maxBitrate
=
stream_params
.
maxBitrate
;
codec_params
.
minBitrate
=
stream_params
.
minBitrate
;
codec_params
.
maxFramerate
=
stream_params
.
maxFramerate
;
codec_params
.
qpMax
=
stream_params
.
qpMax
;
codec_params
.
active
=
stream_params
.
active
;
if
(
is_lowest_quality_stream
)
{
if
(
codec
.
mode
=
=
VideoCodecMode
:
:
kScreensharing
)
{
if
(
experimental_boosted_screenshare_qp_
)
{
codec_params
.
qpMax
=
*
experimental_boosted_screenshare_qp_
;
}
}
else
if
(
boost_base_layer_quality_
)
{
codec_params
.
qpMax
=
kLowestResMaxQp
;
}
}
if
(
codec
.
codecType
=
=
webrtc
:
:
kVideoCodecVP8
)
{
codec_params
.
VP8
(
)
-
>
numberOfTemporalLayers
=
stream_params
.
numberOfTemporalLayers
;
if
(
!
is_highest_quality_stream
)
{
int
pixels_per_frame
=
codec_params
.
width
*
codec_params
.
height
;
if
(
pixels_per_frame
<
352
*
288
)
{
codec_params
.
VP8
(
)
-
>
complexity
=
webrtc
:
:
VideoCodecComplexity
:
:
kComplexityHigher
;
}
codec_params
.
VP8
(
)
-
>
denoisingOn
=
false
;
}
}
else
if
(
codec
.
codecType
=
=
webrtc
:
:
kVideoCodecH264
)
{
codec_params
.
H264
(
)
-
>
numberOfTemporalLayers
=
stream_params
.
numberOfTemporalLayers
;
}
codec_params
.
startBitrate
=
std
:
:
max
(
stream_params
.
minBitrate
start_bitrate_kbps
)
;
codec_params
.
legacy_conference_mode
=
codec
.
legacy_conference_mode
&
&
stream_idx
=
=
0
;
return
codec_params
;
}
void
SimulcastEncoderAdapter
:
:
OverrideFromFieldTrial
(
VideoEncoder
:
:
EncoderInfo
*
info
)
const
{
if
(
encoder_info_override_
.
requested_resolution_alignment
(
)
)
{
info
-
>
requested_resolution_alignment
=
*
encoder_info_override_
.
requested_resolution_alignment
(
)
;
info
-
>
apply_alignment_to_all_simulcast_layers
=
encoder_info_override_
.
apply_alignment_to_all_simulcast_layers
(
)
;
}
if
(
!
encoder_info_override_
.
resolution_bitrate_limits
(
)
.
empty
(
)
)
{
info
-
>
resolution_bitrate_limits
=
encoder_info_override_
.
resolution_bitrate_limits
(
)
;
}
}
VideoEncoder
:
:
EncoderInfo
SimulcastEncoderAdapter
:
:
GetEncoderInfo
(
)
const
{
if
(
stream_contexts_
.
size
(
)
=
=
1
)
{
VideoEncoder
:
:
EncoderInfo
info
=
stream_contexts_
.
front
(
)
.
encoder
(
)
.
GetEncoderInfo
(
)
;
OverrideFromFieldTrial
(
&
info
)
;
return
info
;
}
VideoEncoder
:
:
EncoderInfo
encoder_info
;
encoder_info
.
implementation_name
=
"
SimulcastEncoderAdapter
"
;
encoder_info
.
requested_resolution_alignment
=
1
;
encoder_info
.
apply_alignment_to_all_simulcast_layers
=
false
;
encoder_info
.
supports_native_handle
=
true
;
encoder_info
.
scaling_settings
.
thresholds
=
absl
:
:
nullopt
;
if
(
stream_contexts_
.
empty
(
)
)
{
OverrideFromFieldTrial
(
&
encoder_info
)
;
return
encoder_info
;
}
encoder_info
.
scaling_settings
=
VideoEncoder
:
:
ScalingSettings
:
:
kOff
;
for
(
size_t
i
=
0
;
i
<
stream_contexts_
.
size
(
)
;
+
+
i
)
{
VideoEncoder
:
:
EncoderInfo
encoder_impl_info
=
stream_contexts_
[
i
]
.
encoder
(
)
.
GetEncoderInfo
(
)
;
if
(
i
=
=
0
)
{
encoder_info
.
implementation_name
+
=
"
(
"
;
encoder_info
.
implementation_name
+
=
encoder_impl_info
.
implementation_name
;
encoder_info
.
supports_native_handle
=
encoder_impl_info
.
supports_native_handle
;
encoder_info
.
has_trusted_rate_controller
=
encoder_impl_info
.
has_trusted_rate_controller
;
encoder_info
.
is_hardware_accelerated
=
encoder_impl_info
.
is_hardware_accelerated
;
encoder_info
.
has_internal_source
=
encoder_impl_info
.
has_internal_source
;
}
else
{
encoder_info
.
implementation_name
+
=
"
"
;
encoder_info
.
implementation_name
+
=
encoder_impl_info
.
implementation_name
;
encoder_info
.
supports_native_handle
|
=
encoder_impl_info
.
supports_native_handle
;
encoder_info
.
has_trusted_rate_controller
&
=
encoder_impl_info
.
has_trusted_rate_controller
;
encoder_info
.
is_hardware_accelerated
|
=
encoder_impl_info
.
is_hardware_accelerated
;
encoder_info
.
has_internal_source
&
=
encoder_impl_info
.
has_internal_source
;
}
encoder_info
.
fps_allocation
[
i
]
=
encoder_impl_info
.
fps_allocation
[
0
]
;
encoder_info
.
requested_resolution_alignment
=
cricket
:
:
LeastCommonMultiple
(
encoder_info
.
requested_resolution_alignment
encoder_impl_info
.
requested_resolution_alignment
)
;
if
(
encoder_impl_info
.
apply_alignment_to_all_simulcast_layers
)
{
encoder_info
.
apply_alignment_to_all_simulcast_layers
=
true
;
}
}
encoder_info
.
implementation_name
+
=
"
)
"
;
OverrideFromFieldTrial
(
&
encoder_info
)
;
return
encoder_info
;
}
}
