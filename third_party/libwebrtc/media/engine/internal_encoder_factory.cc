#
include
"
media
/
engine
/
internal_encoder_factory
.
h
"
#
include
<
string
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
api
/
video_codecs
/
sdp_video_format
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
av1
/
libaom_av1_encoder
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
h264
/
include
/
h264
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp8
/
include
/
vp8
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp9
/
include
/
vp9
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
std
:
:
vector
<
SdpVideoFormat
>
InternalEncoderFactory
:
:
SupportedFormats
(
)
{
std
:
:
vector
<
SdpVideoFormat
>
supported_codecs
;
supported_codecs
.
push_back
(
SdpVideoFormat
(
cricket
:
:
kVp8CodecName
)
)
;
for
(
const
webrtc
:
:
SdpVideoFormat
&
format
:
webrtc
:
:
SupportedVP9Codecs
(
)
)
supported_codecs
.
push_back
(
format
)
;
for
(
const
webrtc
:
:
SdpVideoFormat
&
format
:
webrtc
:
:
SupportedH264Codecs
(
)
)
supported_codecs
.
push_back
(
format
)
;
return
supported_codecs
;
}
std
:
:
vector
<
SdpVideoFormat
>
InternalEncoderFactory
:
:
GetSupportedFormats
(
)
const
{
return
SupportedFormats
(
)
;
}
std
:
:
unique_ptr
<
VideoEncoder
>
InternalEncoderFactory
:
:
CreateVideoEncoder
(
const
SdpVideoFormat
&
format
)
{
if
(
absl
:
:
EqualsIgnoreCase
(
format
.
name
cricket
:
:
kVp8CodecName
)
)
return
VP8Encoder
:
:
Create
(
)
;
if
(
absl
:
:
EqualsIgnoreCase
(
format
.
name
cricket
:
:
kVp9CodecName
)
)
return
VP9Encoder
:
:
Create
(
cricket
:
:
VideoCodec
(
format
)
)
;
if
(
absl
:
:
EqualsIgnoreCase
(
format
.
name
cricket
:
:
kH264CodecName
)
)
return
H264Encoder
:
:
Create
(
cricket
:
:
VideoCodec
(
format
)
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Trying
to
created
encoder
of
unsupported
format
"
<
<
format
.
name
;
return
nullptr
;
}
}
