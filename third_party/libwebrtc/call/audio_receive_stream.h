#
ifndef
CALL_AUDIO_RECEIVE_STREAM_H_
#
define
CALL_AUDIO_RECEIVE_STREAM_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
map
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
audio
/
audio_mixer
.
h
"
#
include
"
api
/
audio_codecs
/
audio_codec_pair_id
.
h
"
#
include
"
api
/
audio_codecs
/
audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
api
/
crypto
/
crypto_options
.
h
"
#
include
"
api
/
crypto
/
frame_decryptor_interface
.
h
"
#
include
"
api
/
frame_transformer_interface
.
h
"
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
call
/
receive_stream
.
h
"
#
include
"
call
/
rtp_config
.
h
"
namespace
webrtc
{
class
AudioSinkInterface
;
class
AudioReceiveStreamInterface
:
public
MediaReceiveStreamInterface
{
public
:
struct
Stats
{
Stats
(
)
;
~
Stats
(
)
;
uint32_t
remote_ssrc
=
0
;
int64_t
payload_bytes_received
=
0
;
int64_t
header_and_padding_bytes_received
=
0
;
uint32_t
packets_received
=
0
;
uint64_t
fec_packets_received
=
0
;
uint64_t
fec_packets_discarded
=
0
;
int32_t
packets_lost
=
0
;
uint64_t
packets_discarded
=
0
;
uint32_t
nacks_sent
=
0
;
std
:
:
string
codec_name
;
std
:
:
optional
<
int
>
codec_payload_type
;
uint32_t
jitter_ms
=
0
;
uint32_t
jitter_buffer_ms
=
0
;
uint32_t
jitter_buffer_preferred_ms
=
0
;
uint32_t
delay_estimate_ms
=
0
;
int32_t
audio_level
=
-
1
;
double
total_output_energy
=
0
.
0
;
uint64_t
total_samples_received
=
0
;
double
total_output_duration
=
0
.
0
;
uint64_t
concealed_samples
=
0
;
uint64_t
silent_concealed_samples
=
0
;
uint64_t
concealment_events
=
0
;
double
jitter_buffer_delay_seconds
=
0
.
0
;
uint64_t
jitter_buffer_emitted_count
=
0
;
double
jitter_buffer_target_delay_seconds
=
0
.
0
;
double
jitter_buffer_minimum_delay_seconds
=
0
.
0
;
uint64_t
inserted_samples_for_deceleration
=
0
;
uint64_t
removed_samples_for_acceleration
=
0
;
double
total_processing_delay_seconds
=
0
.
0
;
float
expand_rate
=
0
.
0f
;
float
speech_expand_rate
=
0
.
0f
;
float
secondary_decoded_rate
=
0
.
0f
;
float
secondary_discarded_rate
=
0
.
0f
;
float
accelerate_rate
=
0
.
0f
;
float
preemptive_expand_rate
=
0
.
0f
;
uint64_t
delayed_packet_outage_samples
=
0
;
int32_t
decoding_calls_to_silence_generator
=
0
;
int32_t
decoding_calls_to_neteq
=
0
;
int32_t
decoding_normal
=
0
;
int32_t
decoding_plc
=
0
;
int32_t
decoding_codec_plc
=
0
;
int32_t
decoding_cng
=
0
;
int32_t
decoding_plc_cng
=
0
;
int32_t
decoding_muted_output
=
0
;
int64_t
capture_start_ntp_time_ms
=
0
;
std
:
:
optional
<
Timestamp
>
last_packet_received
;
uint64_t
jitter_buffer_flushes
=
0
;
double
relative_packet_arrival_delay_seconds
=
0
.
0
;
int32_t
interruption_count
=
0
;
int32_t
total_interruption_duration_ms
=
0
;
std
:
:
optional
<
int64_t
>
estimated_playout_ntp_timestamp_ms
;
std
:
:
optional
<
Timestamp
>
last_sender_report_timestamp
;
std
:
:
optional
<
Timestamp
>
last_sender_report_utc_timestamp
;
std
:
:
optional
<
Timestamp
>
last_sender_report_remote_utc_timestamp
;
uint64_t
sender_reports_packets_sent
=
0
;
uint64_t
sender_reports_bytes_sent
=
0
;
uint64_t
sender_reports_reports_count
=
0
;
std
:
:
optional
<
TimeDelta
>
round_trip_time
;
TimeDelta
total_round_trip_time
=
TimeDelta
:
:
Zero
(
)
;
int
round_trip_time_measurements
=
0
;
}
;
struct
Config
{
Config
(
)
;
~
Config
(
)
;
std
:
:
string
ToString
(
)
const
;
struct
Rtp
:
public
ReceiveStreamRtpConfig
{
Rtp
(
)
;
~
Rtp
(
)
;
std
:
:
string
ToString
(
)
const
;
NackConfig
nack
;
RtcpMode
rtcp_mode
=
RtcpMode
:
:
kCompound
;
RtcpEventObserver
*
rtcp_event_observer
=
nullptr
;
}
rtp
;
bool
enable_non_sender_rtt
=
false
;
Transport
*
rtcp_send_transport
=
nullptr
;
size_t
jitter_buffer_max_packets
=
200
;
bool
jitter_buffer_fast_accelerate
=
false
;
int
jitter_buffer_min_delay_ms
=
0
;
std
:
:
string
sync_group
;
std
:
:
map
<
int
SdpAudioFormat
>
decoder_map
;
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
;
std
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
;
webrtc
:
:
CryptoOptions
crypto_options
;
scoped_refptr
<
webrtc
:
:
FrameDecryptorInterface
>
frame_decryptor
;
scoped_refptr
<
webrtc
:
:
FrameTransformerInterface
>
frame_transformer
;
}
;
virtual
void
SetDecoderMap
(
std
:
:
map
<
int
SdpAudioFormat
>
decoder_map
)
=
0
;
virtual
void
SetNackHistory
(
int
history_ms
)
=
0
;
virtual
void
SetNonSenderRttMeasurement
(
bool
enabled
)
=
0
;
virtual
bool
IsRunning
(
)
const
=
0
;
virtual
Stats
GetStats
(
bool
get_and_clear_legacy_stats
)
const
=
0
;
Stats
GetStats
(
)
{
return
GetStats
(
true
)
;
}
virtual
void
SetSink
(
AudioSinkInterface
*
sink
)
=
0
;
virtual
void
SetGain
(
float
gain
)
=
0
;
virtual
bool
SetBaseMinimumPlayoutDelayMs
(
int
delay_ms
)
=
0
;
virtual
int
GetBaseMinimumPlayoutDelayMs
(
)
const
=
0
;
virtual
uint32_t
remote_ssrc
(
)
const
=
0
;
virtual
AudioMixer
:
:
Source
*
source
(
)
=
0
;
protected
:
virtual
~
AudioReceiveStreamInterface
(
)
{
}
}
;
}
#
endif
