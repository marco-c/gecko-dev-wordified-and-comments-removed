#
include
"
call
/
flexfec_receive_stream_impl
.
h
"
#
include
<
stddef
.
h
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
call
/
rtp_stream_receiver_controller_interface
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
flexfec_receiver
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
receive_statistics
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
modules
/
utility
/
include
/
process_thread
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
std
:
:
string
FlexfecReceiveStream
:
:
Stats
:
:
ToString
(
int64_t
time_ms
)
const
{
char
buf
[
1024
]
;
rtc
:
:
SimpleStringBuilder
ss
(
buf
)
;
ss
<
<
"
FlexfecReceiveStream
stats
:
"
<
<
time_ms
<
<
"
{
flexfec_bitrate_bps
:
"
<
<
flexfec_bitrate_bps
<
<
"
}
"
;
return
ss
.
str
(
)
;
}
std
:
:
string
FlexfecReceiveStream
:
:
Config
:
:
ToString
(
)
const
{
char
buf
[
1024
]
;
rtc
:
:
SimpleStringBuilder
ss
(
buf
)
;
ss
<
<
"
{
payload_type
:
"
<
<
payload_type
;
ss
<
<
"
remote_ssrc
:
"
<
<
rtp
.
remote_ssrc
;
ss
<
<
"
local_ssrc
:
"
<
<
rtp
.
local_ssrc
;
ss
<
<
"
protected_media_ssrcs
:
[
"
;
size_t
i
=
0
;
for
(
;
i
+
1
<
protected_media_ssrcs
.
size
(
)
;
+
+
i
)
ss
<
<
protected_media_ssrcs
[
i
]
<
<
"
"
;
if
(
!
protected_media_ssrcs
.
empty
(
)
)
ss
<
<
protected_media_ssrcs
[
i
]
;
ss
<
<
"
]
transport_cc
:
"
<
<
(
rtp
.
transport_cc
?
"
on
"
:
"
off
"
)
;
ss
<
<
"
rtp
.
extensions
:
[
"
;
i
=
0
;
for
(
;
i
+
1
<
rtp
.
extensions
.
size
(
)
;
+
+
i
)
ss
<
<
rtp
.
extensions
[
i
]
.
ToString
(
)
<
<
"
"
;
if
(
!
rtp
.
extensions
.
empty
(
)
)
ss
<
<
rtp
.
extensions
[
i
]
.
ToString
(
)
;
ss
<
<
"
]
}
"
;
return
ss
.
str
(
)
;
}
bool
FlexfecReceiveStream
:
:
Config
:
:
IsCompleteAndEnabled
(
)
const
{
if
(
payload_type
<
0
)
return
false
;
if
(
rtp
.
remote_ssrc
=
=
0
)
return
false
;
if
(
protected_media_ssrcs
.
size
(
)
!
=
1u
)
return
false
;
return
true
;
}
namespace
{
std
:
:
unique_ptr
<
FlexfecReceiver
>
MaybeCreateFlexfecReceiver
(
Clock
*
clock
const
FlexfecReceiveStream
:
:
Config
&
config
RecoveredPacketReceiver
*
recovered_packet_receiver
)
{
if
(
config
.
payload_type
<
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Invalid
FlexFEC
payload
type
given
.
"
"
This
FlexfecReceiveStream
will
therefore
be
useless
.
"
;
return
nullptr
;
}
RTC_DCHECK_GE
(
config
.
payload_type
0
)
;
RTC_DCHECK_LE
(
config
.
payload_type
127
)
;
if
(
config
.
rtp
.
remote_ssrc
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Invalid
FlexFEC
SSRC
given
.
"
"
This
FlexfecReceiveStream
will
therefore
be
useless
.
"
;
return
nullptr
;
}
if
(
config
.
protected_media_ssrcs
.
empty
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
No
protected
media
SSRC
supplied
.
"
"
This
FlexfecReceiveStream
will
therefore
be
useless
.
"
;
return
nullptr
;
}
if
(
config
.
protected_media_ssrcs
.
size
(
)
>
1
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
The
supplied
FlexfecConfig
contained
multiple
protected
"
"
media
streams
but
our
implementation
currently
only
"
"
supports
protecting
a
single
media
stream
.
"
"
To
avoid
confusion
disabling
FlexFEC
completely
.
"
;
return
nullptr
;
}
RTC_DCHECK_EQ
(
1U
config
.
protected_media_ssrcs
.
size
(
)
)
;
return
std
:
:
unique_ptr
<
FlexfecReceiver
>
(
new
FlexfecReceiver
(
clock
config
.
rtp
.
remote_ssrc
config
.
protected_media_ssrcs
[
0
]
recovered_packet_receiver
)
)
;
}
std
:
:
unique_ptr
<
ModuleRtpRtcpImpl2
>
CreateRtpRtcpModule
(
Clock
*
clock
ReceiveStatistics
*
receive_statistics
const
FlexfecReceiveStreamImpl
:
:
Config
&
config
RtcpRttStats
*
rtt_stats
)
{
RtpRtcpInterface
:
:
Configuration
configuration
;
configuration
.
audio
=
false
;
configuration
.
receiver_only
=
true
;
configuration
.
clock
=
clock
;
configuration
.
receive_statistics
=
receive_statistics
;
configuration
.
outgoing_transport
=
config
.
rtcp_send_transport
;
configuration
.
rtt_stats
=
rtt_stats
;
configuration
.
local_media_ssrc
=
config
.
rtp
.
local_ssrc
;
return
ModuleRtpRtcpImpl2
:
:
Create
(
configuration
)
;
}
}
FlexfecReceiveStreamImpl
:
:
FlexfecReceiveStreamImpl
(
Clock
*
clock
const
Config
&
config
RecoveredPacketReceiver
*
recovered_packet_receiver
RtcpRttStats
*
rtt_stats
ProcessThread
*
process_thread
)
:
config_
(
config
)
receiver_
(
MaybeCreateFlexfecReceiver
(
clock
config_
recovered_packet_receiver
)
)
rtp_receive_statistics_
(
ReceiveStatistics
:
:
Create
(
clock
)
)
rtp_rtcp_
(
CreateRtpRtcpModule
(
clock
rtp_receive_statistics_
.
get
(
)
config_
rtt_stats
)
)
process_thread_
(
process_thread
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
FlexfecReceiveStreamImpl
:
"
<
<
config_
.
ToString
(
)
;
packet_sequence_checker_
.
Detach
(
)
;
rtp_rtcp_
-
>
SetRTCPStatus
(
config_
.
rtcp_mode
)
;
process_thread_
-
>
RegisterModule
(
rtp_rtcp_
.
get
(
)
RTC_FROM_HERE
)
;
}
FlexfecReceiveStreamImpl
:
:
~
FlexfecReceiveStreamImpl
(
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
~
FlexfecReceiveStreamImpl
:
"
<
<
config_
.
ToString
(
)
;
process_thread_
-
>
DeRegisterModule
(
rtp_rtcp_
.
get
(
)
)
;
}
void
FlexfecReceiveStreamImpl
:
:
RegisterWithTransport
(
RtpStreamReceiverControllerInterface
*
receiver_controller
)
{
RTC_DCHECK_RUN_ON
(
&
packet_sequence_checker_
)
;
RTC_DCHECK
(
!
rtp_stream_receiver_
)
;
if
(
!
receiver_
)
return
;
rtp_stream_receiver_
=
receiver_controller
-
>
CreateReceiver
(
config_
.
rtp
.
remote_ssrc
this
)
;
}
void
FlexfecReceiveStreamImpl
:
:
UnregisterFromTransport
(
)
{
RTC_DCHECK_RUN_ON
(
&
packet_sequence_checker_
)
;
rtp_stream_receiver_
.
reset
(
)
;
}
void
FlexfecReceiveStreamImpl
:
:
OnRtpPacket
(
const
RtpPacketReceived
&
packet
)
{
if
(
!
receiver_
)
return
;
receiver_
-
>
OnRtpPacket
(
packet
)
;
if
(
packet
.
Ssrc
(
)
=
=
config_
.
rtp
.
remote_ssrc
)
{
rtp_receive_statistics_
-
>
OnRtpPacket
(
packet
)
;
}
}
FlexfecReceiveStreamImpl
:
:
Stats
FlexfecReceiveStreamImpl
:
:
GetStats
(
)
const
{
return
FlexfecReceiveStream
:
:
Stats
(
)
;
}
}
