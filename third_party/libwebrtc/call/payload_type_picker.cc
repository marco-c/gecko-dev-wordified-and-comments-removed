#
include
"
call
/
payload_type_picker
.
h
"
#
include
<
algorithm
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
call
/
payload_type
.
h
"
#
include
"
media
/
base
/
codec
.
h
"
#
include
"
media
/
base
/
codec_comparators
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
string_encode
.
h
"
namespace
webrtc
{
namespace
{
static
const
int
kFirstDynamicPayloadTypeLowerRange
=
35
;
static
const
int
kLastDynamicPayloadTypeLowerRange
=
63
;
static
const
int
kFirstDynamicPayloadTypeUpperRange
=
96
;
static
const
int
kLastDynamicPayloadTypeUpperRange
=
127
;
struct
MapTableEntry
{
webrtc
:
:
SdpAudioFormat
format
;
int
payload_type
;
}
;
bool
CodecPrefersLowerRange
(
const
Codec
&
codec
)
{
if
(
codec
.
type
=
=
Codec
:
:
Type
:
:
kAudio
)
{
return
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kRedCodecName
)
;
}
if
(
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kFlexfecCodecName
)
|
|
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kAv1CodecName
)
|
|
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kH265CodecName
)
)
{
return
true
;
}
else
if
(
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kH264CodecName
)
)
{
std
:
:
string
profile_level_id
;
std
:
:
string
packetization_mode
;
if
(
codec
.
GetParam
(
cricket
:
:
kH264FmtpProfileLevelId
&
profile_level_id
)
)
{
if
(
absl
:
:
StartsWithIgnoreCase
(
profile_level_id
"
4d00
"
)
)
{
if
(
codec
.
GetParam
(
cricket
:
:
kH264FmtpPacketizationMode
&
packetization_mode
)
)
{
return
packetization_mode
=
=
"
0
"
;
}
}
return
absl
:
:
StartsWithIgnoreCase
(
profile_level_id
"
f400
"
)
;
}
}
else
if
(
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kVp9CodecName
)
)
{
std
:
:
string
profile_id
;
if
(
codec
.
GetParam
(
cricket
:
:
kVP9ProfileId
&
profile_id
)
)
{
if
(
profile_id
=
=
"
1
"
|
|
profile_id
=
=
"
3
"
)
{
return
true
;
}
}
}
else
if
(
absl
:
:
EqualsIgnoreCase
(
codec
.
name
cricket
:
:
kRtxCodecName
)
)
{
std
:
:
string
associated_pt_str
;
int
associated_pt
;
return
codec
.
GetParam
(
cricket
:
:
kCodecParamAssociatedPayloadType
&
associated_pt_str
)
&
&
FromString
(
associated_pt_str
&
associated_pt
)
&
&
associated_pt
>
=
kFirstDynamicPayloadTypeLowerRange
&
&
associated_pt
<
=
kLastDynamicPayloadTypeLowerRange
;
}
return
false
;
}
RTCErrorOr
<
PayloadType
>
FindFreePayloadType
(
const
Codec
&
codec
std
:
:
set
<
PayloadType
>
seen_pt
)
{
bool
prefer_lower_range
=
CodecPrefersLowerRange
(
codec
)
;
if
(
prefer_lower_range
)
{
for
(
auto
i
=
kFirstDynamicPayloadTypeLowerRange
;
i
<
=
kLastDynamicPayloadTypeLowerRange
;
i
+
+
)
{
if
(
seen_pt
.
count
(
PayloadType
(
i
)
)
=
=
0
)
{
return
PayloadType
(
i
)
;
}
}
}
for
(
auto
i
=
kFirstDynamicPayloadTypeUpperRange
;
i
<
=
kLastDynamicPayloadTypeUpperRange
;
i
+
+
)
{
if
(
seen_pt
.
count
(
PayloadType
(
i
)
)
=
=
0
)
{
return
PayloadType
(
i
)
;
}
}
if
(
!
prefer_lower_range
)
{
for
(
auto
i
=
kFirstDynamicPayloadTypeLowerRange
;
i
<
=
kLastDynamicPayloadTypeLowerRange
;
i
+
+
)
{
if
(
seen_pt
.
count
(
PayloadType
(
i
)
)
=
=
0
)
{
return
PayloadType
(
i
)
;
}
}
}
if
(
prefer_lower_range
)
{
return
RTCError
(
RTCErrorType
:
:
RESOURCE_EXHAUSTED
"
All
available
dynamic
PTs
have
been
assigned
"
)
;
}
else
{
return
RTCError
(
RTCErrorType
:
:
RESOURCE_EXHAUSTED
"
All
available
dynamic
PTs
have
been
assigned
codec
preferred
upper
"
)
;
}
}
}
PayloadTypePicker
:
:
PayloadTypePicker
(
)
{
const
MapTableEntry
default_audio_mappings
[
]
=
{
{
{
cricket
:
:
kPcmuCodecName
8000
1
}
0
}
{
{
"
GSM
"
8000
1
}
3
}
{
{
"
G723
"
8000
1
}
4
}
{
{
"
DVI4
"
8000
1
}
5
}
{
{
"
DVI4
"
16000
1
}
6
}
{
{
"
LPC
"
8000
1
}
7
}
{
{
cricket
:
:
kPcmaCodecName
8000
1
}
8
}
{
{
cricket
:
:
kG722CodecName
8000
1
}
9
}
{
{
cricket
:
:
kL16CodecName
44100
2
}
10
}
{
{
cricket
:
:
kL16CodecName
44100
1
}
11
}
{
{
"
QCELP
"
8000
1
}
12
}
{
{
cricket
:
:
kCnCodecName
8000
1
}
13
}
{
{
"
MPA
"
90000
0
}
14
}
{
{
"
MPA
"
90000
1
}
14
}
{
{
"
G728
"
8000
1
}
15
}
{
{
"
DVI4
"
11025
1
}
16
}
{
{
"
DVI4
"
22050
1
}
17
}
{
{
"
G729
"
8000
1
}
18
}
{
{
"
reserved
-
do
-
not
-
use
"
0
0
}
102
}
{
{
cricket
:
:
kCnCodecName
16000
1
}
105
}
{
{
cricket
:
:
kCnCodecName
32000
1
}
106
}
{
{
cricket
:
:
kOpusCodecName
48000
2
{
{
cricket
:
:
kCodecParamMinPTime
"
10
"
}
{
cricket
:
:
kCodecParamUseInbandFec
cricket
:
:
kParamValueTrue
}
}
}
111
}
{
{
cricket
:
:
kRedCodecName
48000
2
{
{
cricket
:
:
kCodecParamNotInNameValueFormat
"
111
/
111
"
}
}
}
63
}
{
{
cricket
:
:
kDtmfCodecName
48000
1
}
110
}
{
{
cricket
:
:
kDtmfCodecName
32000
1
}
112
}
{
{
cricket
:
:
kDtmfCodecName
16000
1
}
113
}
{
{
cricket
:
:
kDtmfCodecName
8000
1
}
126
}
}
;
for
(
const
MapTableEntry
&
entry
:
default_audio_mappings
)
{
AddMapping
(
PayloadType
(
entry
.
payload_type
)
CreateAudioCodec
(
entry
.
format
)
)
;
}
}
RTCErrorOr
<
PayloadType
>
PayloadTypePicker
:
:
SuggestMapping
(
Codec
codec
const
PayloadTypeRecorder
*
excluder
)
{
if
(
codec
.
id
>
=
0
&
&
codec
.
id
<
=
kLastDynamicPayloadTypeUpperRange
&
&
seen_payload_types_
.
count
(
PayloadType
(
codec
.
id
)
)
=
=
0
)
{
AddMapping
(
PayloadType
(
codec
.
id
)
codec
)
;
return
PayloadType
(
codec
.
id
)
;
}
for
(
const
MapEntry
&
entry
:
entries_
)
{
if
(
MatchesWithReferenceAttributes
(
entry
.
codec
(
)
codec
)
)
{
if
(
excluder
)
{
auto
result
=
excluder
-
>
LookupCodec
(
entry
.
payload_type
(
)
)
;
if
(
result
.
ok
(
)
&
&
!
MatchesWithReferenceAttributes
(
result
.
value
(
)
codec
)
)
{
continue
;
}
}
return
entry
.
payload_type
(
)
;
}
}
RTCErrorOr
<
PayloadType
>
found_pt
=
FindFreePayloadType
(
codec
seen_payload_types_
)
;
if
(
found_pt
.
ok
(
)
)
{
AddMapping
(
found_pt
.
value
(
)
codec
)
;
}
return
found_pt
;
}
RTCError
PayloadTypePicker
:
:
AddMapping
(
PayloadType
payload_type
Codec
codec
)
{
for
(
const
MapEntry
&
entry
:
entries_
)
{
if
(
payload_type
=
=
entry
.
payload_type
(
)
&
&
MatchesWithReferenceAttributes
(
codec
entry
.
codec
(
)
)
)
{
return
RTCError
:
:
OK
(
)
;
}
}
entries_
.
emplace_back
(
MapEntry
(
payload_type
codec
)
)
;
seen_payload_types_
.
emplace
(
payload_type
)
;
return
RTCError
:
:
OK
(
)
;
}
RTCError
PayloadTypeRecorder
:
:
AddMapping
(
PayloadType
payload_type
Codec
codec
)
{
auto
existing_codec_it
=
payload_type_to_codec_
.
find
(
payload_type
)
;
if
(
existing_codec_it
!
=
payload_type_to_codec_
.
end
(
)
&
&
!
MatchesWithCodecRules
(
codec
existing_codec_it
-
>
second
)
)
{
if
(
disallow_redefinition_level_
>
0
)
{
if
(
accepted_definitions_
.
count
(
payload_type
)
>
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Rejected
attempt
to
redefine
mapping
for
PT
"
<
<
payload_type
<
<
"
from
"
<
<
existing_codec_it
-
>
second
<
<
"
to
"
<
<
codec
;
return
RTCError
(
RTCErrorType
:
:
INVALID_MODIFICATION
"
Attempt
to
redefine
a
codec
mapping
"
)
;
}
}
if
(
absl
:
:
EqualsIgnoreCase
(
codec
.
name
existing_codec_it
-
>
second
.
name
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Warning
:
Attempt
to
change
a
codec
'
s
parameters
"
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Warning
:
You
attempted
to
redefine
a
codec
from
"
<
<
existing_codec_it
-
>
second
<
<
"
to
"
<
<
"
new
codec
"
<
<
codec
;
}
accepted_definitions_
.
emplace
(
payload_type
)
;
payload_type_to_codec_
.
insert_or_assign
(
payload_type
codec
)
;
return
RTCError
:
:
OK
(
)
;
}
accepted_definitions_
.
emplace
(
payload_type
)
;
payload_type_to_codec_
.
emplace
(
payload_type
codec
)
;
suggester_
.
AddMapping
(
payload_type
codec
)
;
return
RTCError
:
:
OK
(
)
;
}
std
:
:
vector
<
std
:
:
pair
<
PayloadType
Codec
>
>
PayloadTypeRecorder
:
:
GetMappings
(
)
const
{
return
std
:
:
vector
<
std
:
:
pair
<
PayloadType
Codec
>
>
{
}
;
}
RTCErrorOr
<
PayloadType
>
PayloadTypeRecorder
:
:
LookupPayloadType
(
Codec
codec
)
const
{
auto
result
=
std
:
:
find_if
(
payload_type_to_codec_
.
begin
(
)
payload_type_to_codec_
.
end
(
)
[
codec
]
(
const
auto
&
iter
)
{
return
MatchesWithReferenceAttributes
(
iter
.
second
codec
)
;
}
)
;
if
(
result
=
=
payload_type_to_codec_
.
end
(
)
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
"
No
payload
type
found
for
codec
"
)
;
}
return
result
-
>
first
;
}
RTCErrorOr
<
Codec
>
PayloadTypeRecorder
:
:
LookupCodec
(
PayloadType
payload_type
)
const
{
auto
result
=
payload_type_to_codec_
.
find
(
payload_type
)
;
if
(
result
=
=
payload_type_to_codec_
.
end
(
)
)
{
return
RTCError
(
RTCErrorType
:
:
INVALID_PARAMETER
"
No
such
payload
type
"
)
;
}
return
result
-
>
second
;
}
void
PayloadTypeRecorder
:
:
DisallowRedefinition
(
)
{
if
(
disallow_redefinition_level_
=
=
0
)
{
accepted_definitions_
.
clear
(
)
;
}
+
+
disallow_redefinition_level_
;
}
void
PayloadTypeRecorder
:
:
ReallowRedefinition
(
)
{
RTC_CHECK
(
disallow_redefinition_level_
>
0
)
;
-
-
disallow_redefinition_level_
;
}
void
PayloadTypeRecorder
:
:
Commit
(
)
{
checkpoint_payload_type_to_codec_
=
payload_type_to_codec_
;
}
void
PayloadTypeRecorder
:
:
Rollback
(
)
{
payload_type_to_codec_
=
checkpoint_payload_type_to_codec_
;
}
}
