#
ifndef
LOGGING_RTC_EVENT_LOG_EVENTS_RTC_EVENT_FIELD_EXTRACTION_H_
#
define
LOGGING_RTC_EVENT_LOG_EVENTS_RTC_EVENT_FIELD_EXTRACTION_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
rtc_event_log
/
rtc_event
.
h
"
#
include
"
logging
/
rtc_event_log
/
encoder
/
rtc_event_log_encoder_common
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc_event_logging
{
uint8_t
UnsignedBitWidth
(
uint64_t
max_magnitude
)
;
uint8_t
SignedBitWidth
(
uint64_t
max_pos_magnitude
uint64_t
max_neg_magnitude
)
;
uint64_t
MaxUnsignedValueOfBitWidth
(
uint64_t
bit_width
)
;
uint64_t
UnsignedDelta
(
uint64_t
previous
uint64_t
current
uint64_t
bit_mask
)
;
}
namespace
webrtc
{
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_signed
<
T
>
:
:
value
bool
>
=
true
>
uint64_t
EncodeAsUnsigned
(
T
value
)
{
return
webrtc_event_logging
:
:
ToUnsigned
(
value
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_unsigned
<
T
>
:
:
value
bool
>
=
true
>
uint64_t
EncodeAsUnsigned
(
T
value
)
{
return
static_cast
<
uint64_t
>
(
value
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_signed
<
T
>
:
:
value
bool
>
=
true
>
T
DecodeFromUnsignedToType
(
uint64_t
value
)
{
T
signed_value
=
0
;
bool
success
=
webrtc_event_logging
:
:
ToSigned
<
T
>
(
value
&
signed_value
)
;
if
(
!
success
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
convert
"
<
<
value
<
<
"
to
signed
type
.
"
;
}
return
signed_value
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_unsigned
<
T
>
:
:
value
bool
>
=
true
>
T
DecodeFromUnsignedToType
(
uint64_t
value
)
{
return
static_cast
<
T
>
(
value
)
;
}
template
<
typename
T
typename
E
std
:
:
enable_if_t
<
std
:
:
is_integral
<
T
>
:
:
value
bool
>
=
true
>
std
:
:
vector
<
uint64_t
>
ExtractRtcEventMember
(
rtc
:
:
ArrayView
<
const
RtcEvent
*
>
batch
const
T
E
:
:
*
member
)
{
std
:
:
vector
<
uint64_t
>
values
;
values
.
reserve
(
batch
.
size
(
)
)
;
for
(
const
RtcEvent
*
event
:
batch
)
{
RTC_CHECK_EQ
(
event
-
>
GetType
(
)
E
:
:
kType
)
;
T
value
=
static_cast
<
const
E
*
>
(
event
)
-
>
*
member
;
values
.
push_back
(
EncodeAsUnsigned
(
value
)
)
;
}
return
values
;
}
struct
ValuesWithPositions
{
std
:
:
vector
<
bool
>
position_mask
;
std
:
:
vector
<
uint64_t
>
values
;
}
;
template
<
typename
T
typename
E
std
:
:
enable_if_t
<
std
:
:
is_integral
<
T
>
:
:
value
bool
>
=
true
>
ValuesWithPositions
ExtractRtcEventMember
(
rtc
:
:
ArrayView
<
const
RtcEvent
*
>
batch
const
absl
:
:
optional
<
T
>
E
:
:
*
member
)
{
ValuesWithPositions
result
;
result
.
position_mask
.
reserve
(
batch
.
size
(
)
)
;
result
.
values
.
reserve
(
batch
.
size
(
)
)
;
for
(
const
RtcEvent
*
event
:
batch
)
{
RTC_CHECK_EQ
(
event
-
>
GetType
(
)
E
:
:
kType
)
;
absl
:
:
optional
<
T
>
field
=
static_cast
<
const
E
*
>
(
event
)
-
>
*
member
;
result
.
position_mask
.
push_back
(
field
.
has_value
(
)
)
;
if
(
field
.
has_value
(
)
)
{
result
.
values
.
push_back
(
EncodeAsUnsigned
(
field
.
value
(
)
)
)
;
}
}
return
result
;
}
template
<
typename
T
typename
E
std
:
:
enable_if_t
<
std
:
:
is_integral
<
T
>
:
:
value
bool
>
=
true
>
void
PopulateRtcEventMember
(
const
std
:
:
vector
<
uint64_t
>
&
values
T
E
:
:
*
member
rtc
:
:
ArrayView
<
E
>
output
)
{
size_t
batch_size
=
values
.
size
(
)
;
RTC_CHECK_EQ
(
output
.
size
(
)
batch_size
)
;
for
(
size_t
i
=
0
;
i
<
batch_size
;
+
+
i
)
{
output
[
i
]
.
*
member
=
DecodeFromUnsignedToType
<
T
>
(
values
[
i
]
)
;
}
}
template
<
typename
T
typename
E
std
:
:
enable_if_t
<
std
:
:
is_integral
<
T
>
:
:
value
bool
>
=
true
>
void
PopulateRtcEventMember
(
const
std
:
:
vector
<
bool
>
&
positions
const
std
:
:
vector
<
uint64_t
>
&
values
absl
:
:
optional
<
T
>
E
:
:
*
member
rtc
:
:
ArrayView
<
E
>
output
)
{
size_t
batch_size
=
positions
.
size
(
)
;
RTC_CHECK_EQ
(
output
.
size
(
)
batch_size
)
;
RTC_CHECK_LE
(
values
.
size
(
)
batch_size
)
;
auto
value_it
=
values
.
begin
(
)
;
for
(
size_t
i
=
0
;
i
<
batch_size
;
+
+
i
)
{
if
(
positions
[
i
]
)
{
RTC_CHECK
(
value_it
!
=
values
.
end
(
)
)
;
output
[
i
]
.
*
member
=
DecodeFromUnsignedToType
<
T
>
(
value_it
)
;
+
+
value_it
;
}
else
{
output
[
i
]
.
*
member
=
absl
:
:
nullopt
;
}
}
RTC_CHECK
(
value_it
=
=
values
.
end
(
)
)
;
}
}
#
endif
