#
ifndef
LOGGING_RTC_EVENT_LOG_RTC_EVENT_PROCESSOR_H_
#
define
LOGGING_RTC_EVENT_LOG_RTC_EVENT_PROCESSOR_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
function_view
.
h
"
#
include
"
logging
/
rtc_event_log
/
rtc_event_log_parser
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
event_processor_impl
{
class
ProcessableEventListInterface
{
public
:
virtual
~
ProcessableEventListInterface
(
)
=
default
;
virtual
void
ProcessNext
(
)
=
0
;
virtual
bool
IsEmpty
(
)
const
=
0
;
virtual
int64_t
GetNextTime
(
)
const
=
0
;
virtual
int
GetTieBreaker
(
)
const
=
0
;
}
;
template
<
typename
Iterator
typename
T
>
class
ProcessableEventList
:
public
ProcessableEventListInterface
{
public
:
ProcessableEventList
(
Iterator
begin
Iterator
end
std
:
:
function
<
void
(
const
T
&
)
>
f
int
tie_breaker
)
:
begin_
(
begin
)
end_
(
end
)
f_
(
f
)
tie_breaker_
(
tie_breaker
)
{
}
void
ProcessNext
(
)
override
{
RTC_DCHECK
(
!
IsEmpty
(
)
)
;
f_
(
*
begin_
)
;
+
+
begin_
;
}
bool
IsEmpty
(
)
const
override
{
return
begin_
=
=
end_
;
}
int64_t
GetNextTime
(
)
const
override
{
RTC_DCHECK
(
!
IsEmpty
(
)
)
;
return
begin_
-
>
log_time_us
(
)
;
}
int
GetTieBreaker
(
)
const
override
{
return
tie_breaker_
;
}
private
:
Iterator
begin_
;
Iterator
end_
;
std
:
:
function
<
void
(
const
T
&
)
>
f_
;
int
tie_breaker_
;
}
;
}
class
RtcEventProcessor
{
public
:
RtcEventProcessor
(
)
;
~
RtcEventProcessor
(
)
;
template
<
typename
Iterable
>
void
AddEvents
(
const
Iterable
&
iterable
std
:
:
function
<
void
(
const
typename
Iterable
:
:
value_type
&
)
>
handler
)
{
if
(
iterable
.
begin
(
)
=
=
iterable
.
end
(
)
)
return
;
event_lists_
.
push_back
(
std
:
:
make_unique
<
event_processor_impl
:
:
ProcessableEventList
<
typename
Iterable
:
:
const_iterator
typename
Iterable
:
:
value_type
>
>
(
iterable
.
begin
(
)
iterable
.
end
(
)
handler
insertion_order_index_
+
+
)
)
;
std
:
:
push_heap
(
event_lists_
.
begin
(
)
event_lists_
.
end
(
)
Cmp
)
;
}
template
<
typename
Iterable
>
void
AddEvents
(
const
Iterable
&
iterable
std
:
:
function
<
void
(
const
typename
Iterable
:
:
value_type
&
)
>
handler
PacketDirection
)
{
AddEvents
(
iterable
handler
)
;
}
void
ProcessEventsInOrder
(
)
;
private
:
using
ListPtrType
=
std
:
:
unique_ptr
<
event_processor_impl
:
:
ProcessableEventListInterface
>
;
int
insertion_order_index_
=
0
;
std
:
:
vector
<
ListPtrType
>
event_lists_
;
static
bool
Cmp
(
const
ListPtrType
&
a
const
ListPtrType
&
b
)
;
}
;
}
#
endif
