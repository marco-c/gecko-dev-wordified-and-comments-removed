#
ifndef
COMMON_AUDIO_INCLUDE_AUDIO_UTIL_H_
#
define
COMMON_AUDIO_INCLUDE_AUDIO_UTIL_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
"
api
/
audio
/
audio_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
typedef
std
:
:
numeric_limits
<
int16_t
>
limits_int16
;
constexpr
int
kMaxSampleRateHz
=
384000
;
constexpr
size_t
kMaxSamplesPerChannel10ms
=
kMaxSampleRateHz
/
100u
;
static
inline
float
S16ToFloat
(
int16_t
v
)
{
constexpr
float
kScaling
=
1
.
f
/
32768
.
f
;
return
v
*
kScaling
;
}
static
inline
int16_t
FloatS16ToS16
(
float
v
)
{
v
=
std
:
:
min
(
v
32767
.
f
)
;
v
=
std
:
:
max
(
v
-
32768
.
f
)
;
return
static_cast
<
int16_t
>
(
v
+
std
:
:
copysign
(
0
.
5f
v
)
)
;
}
static
inline
int16_t
FloatToS16
(
float
v
)
{
v
*
=
32768
.
f
;
v
=
std
:
:
min
(
v
32767
.
f
)
;
v
=
std
:
:
max
(
v
-
32768
.
f
)
;
return
static_cast
<
int16_t
>
(
v
+
std
:
:
copysign
(
0
.
5f
v
)
)
;
}
static
inline
float
FloatToFloatS16
(
float
v
)
{
v
=
std
:
:
min
(
v
1
.
f
)
;
v
=
std
:
:
max
(
v
-
1
.
f
)
;
return
v
*
32768
.
f
;
}
static
inline
float
FloatS16ToFloat
(
float
v
)
{
v
=
std
:
:
min
(
v
32768
.
f
)
;
v
=
std
:
:
max
(
v
-
32768
.
f
)
;
constexpr
float
kScaling
=
1
.
f
/
32768
.
f
;
return
v
*
kScaling
;
}
void
FloatToS16
(
const
float
*
src
size_t
size
int16_t
*
dest
)
;
void
S16ToFloat
(
const
int16_t
*
src
size_t
size
float
*
dest
)
;
void
S16ToFloatS16
(
const
int16_t
*
src
size_t
size
float
*
dest
)
;
void
FloatS16ToS16
(
const
float
*
src
size_t
size
int16_t
*
dest
)
;
void
FloatToFloatS16
(
const
float
*
src
size_t
size
float
*
dest
)
;
void
FloatS16ToFloat
(
const
float
*
src
size_t
size
float
*
dest
)
;
inline
float
DbToRatio
(
float
v
)
{
return
std
:
:
pow
(
10
.
0f
v
/
20
.
0f
)
;
}
inline
float
DbfsToFloatS16
(
float
v
)
{
static
constexpr
float
kMaximumAbsFloatS16
=
-
limits_int16
:
:
min
(
)
;
return
DbToRatio
(
v
)
*
kMaximumAbsFloatS16
;
}
inline
float
FloatS16ToDbfs
(
float
v
)
{
RTC_DCHECK_GE
(
v
0
)
;
static
constexpr
float
kMinDbfs
=
-
90
.
30899869919436f
;
if
(
v
<
=
1
.
0f
)
{
return
kMinDbfs
;
}
return
20
.
0f
*
std
:
:
log10
(
v
)
+
kMinDbfs
;
}
template
<
typename
T
>
void
CopyAudioIfNeeded
(
const
T
*
const
*
src
int
num_frames
int
num_channels
T
*
const
*
dest
)
{
for
(
int
i
=
0
;
i
<
num_channels
;
+
+
i
)
{
if
(
src
[
i
]
!
=
dest
[
i
]
)
{
std
:
:
copy
(
src
[
i
]
src
[
i
]
+
num_frames
dest
[
i
]
)
;
}
}
}
template
<
typename
T
>
void
Deinterleave
(
const
InterleavedView
<
const
T
>
&
interleaved
const
DeinterleavedView
<
T
>
&
deinterleaved
)
{
RTC_DCHECK_EQ
(
NumChannels
(
interleaved
)
NumChannels
(
deinterleaved
)
)
;
RTC_DCHECK_EQ
(
SamplesPerChannel
(
interleaved
)
SamplesPerChannel
(
deinterleaved
)
)
;
const
auto
num_channels
=
NumChannels
(
interleaved
)
;
const
auto
samples_per_channel
=
SamplesPerChannel
(
interleaved
)
;
for
(
size_t
i
=
0
;
i
<
num_channels
;
+
+
i
)
{
MonoView
<
T
>
channel
=
deinterleaved
[
i
]
;
size_t
interleaved_idx
=
i
;
for
(
size_t
j
=
0
;
j
<
samples_per_channel
;
+
+
j
)
{
channel
[
j
]
=
interleaved
[
interleaved_idx
]
;
interleaved_idx
+
=
num_channels
;
}
}
}
template
<
typename
T
>
void
Interleave
(
const
DeinterleavedView
<
const
T
>
&
deinterleaved
const
InterleavedView
<
T
>
&
interleaved
)
{
RTC_DCHECK_EQ
(
NumChannels
(
interleaved
)
NumChannels
(
deinterleaved
)
)
;
RTC_DCHECK_EQ
(
SamplesPerChannel
(
interleaved
)
SamplesPerChannel
(
deinterleaved
)
)
;
for
(
size_t
i
=
0
;
i
<
deinterleaved
.
num_channels
(
)
;
+
+
i
)
{
const
auto
channel
=
deinterleaved
[
i
]
;
size_t
interleaved_idx
=
i
;
for
(
size_t
j
=
0
;
j
<
deinterleaved
.
samples_per_channel
(
)
;
+
+
j
)
{
interleaved
[
interleaved_idx
]
=
channel
[
j
]
;
interleaved_idx
+
=
deinterleaved
.
num_channels
(
)
;
}
}
}
template
<
typename
T
typename
Intermediate
>
void
DownmixInterleavedToMonoImpl
(
const
T
*
interleaved
size_t
num_frames
int
num_channels
T
*
deinterleaved
)
{
RTC_DCHECK_GT
(
num_channels
0
)
;
RTC_DCHECK_GT
(
num_frames
0
)
;
const
T
*
const
end
=
interleaved
+
num_frames
*
num_channels
;
while
(
interleaved
<
end
)
{
const
T
*
const
frame_end
=
interleaved
+
num_channels
;
Intermediate
value
=
*
interleaved
+
+
;
while
(
interleaved
<
frame_end
)
{
value
+
=
*
interleaved
+
+
;
}
*
deinterleaved
+
+
=
value
/
num_channels
;
}
}
template
<
typename
T
>
void
DownmixInterleavedToMono
(
const
T
*
interleaved
size_t
num_frames
int
num_channels
T
*
deinterleaved
)
;
template
<
>
void
DownmixInterleavedToMono
<
int16_t
>
(
const
int16_t
*
interleaved
size_t
num_frames
int
num_channels
int16_t
*
deinterleaved
)
;
}
#
endif
