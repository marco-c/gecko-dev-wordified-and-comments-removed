#
include
"
common_audio
/
resampler
/
sinc_resampler
.
h
"
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
<
numbers
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
cpu_info
.
h
"
#
include
"
rtc_base
/
memory
/
aligned_malloc
.
h
"
#
include
"
rtc_base
/
system
/
arch
.
h
"
namespace
webrtc
{
namespace
{
double
SincScaleFactor
(
double
io_ratio
)
{
double
sinc_scale_factor
=
io_ratio
>
1
.
0
?
1
.
0
/
io_ratio
:
1
.
0
;
sinc_scale_factor
*
=
0
.
9
;
return
sinc_scale_factor
;
}
}
const
size_t
SincResampler
:
:
kKernelSize
;
void
SincResampler
:
:
InitializeCPUSpecificFeatures
(
)
{
#
if
defined
(
WEBRTC_HAS_NEON
)
convolve_proc_
=
Convolve_NEON
;
#
elif
defined
(
WEBRTC_ARCH_X86_FAMILY
)
if
(
cpu_info
:
:
Supports
(
cpu_info
:
:
ISA
:
:
kAVX2
)
&
&
cpu_info
:
:
Supports
(
cpu_info
:
:
ISA
:
:
kFMA3
)
)
convolve_proc_
=
Convolve_AVX2
;
else
if
(
cpu_info
:
:
Supports
(
cpu_info
:
:
ISA
:
:
kSSE2
)
)
convolve_proc_
=
Convolve_SSE
;
else
convolve_proc_
=
Convolve_C
;
#
else
convolve_proc_
=
Convolve_C
;
#
endif
}
SincResampler
:
:
SincResampler
(
double
io_sample_rate_ratio
size_t
request_frames
SincResamplerCallback
*
read_cb
)
:
io_sample_rate_ratio_
(
io_sample_rate_ratio
)
read_cb_
(
read_cb
)
request_frames_
(
request_frames
)
input_buffer_size_
(
request_frames_
+
kKernelSize
)
kernel_storage_
(
static_cast
<
float
*
>
(
AlignedMalloc
(
sizeof
(
float
)
*
kKernelStorageSize
32
)
)
)
kernel_pre_sinc_storage_
(
static_cast
<
float
*
>
(
AlignedMalloc
(
sizeof
(
float
)
*
kKernelStorageSize
32
)
)
)
kernel_window_storage_
(
static_cast
<
float
*
>
(
AlignedMalloc
(
sizeof
(
float
)
*
kKernelStorageSize
32
)
)
)
input_buffer_
(
static_cast
<
float
*
>
(
AlignedMalloc
(
sizeof
(
float
)
*
input_buffer_size_
32
)
)
)
convolve_proc_
(
nullptr
)
r1_
(
input_buffer_
.
get
(
)
)
r2_
(
input_buffer_
.
get
(
)
+
kKernelSize
/
2
)
{
InitializeCPUSpecificFeatures
(
)
;
RTC_DCHECK
(
convolve_proc_
)
;
RTC_DCHECK_GT
(
request_frames_
0
)
;
Flush
(
)
;
RTC_DCHECK_GT
(
block_size_
kKernelSize
)
;
memset
(
kernel_storage_
.
get
(
)
0
sizeof
(
*
kernel_storage_
.
get
(
)
)
*
kKernelStorageSize
)
;
memset
(
kernel_pre_sinc_storage_
.
get
(
)
0
sizeof
(
*
kernel_pre_sinc_storage_
.
get
(
)
)
*
kKernelStorageSize
)
;
memset
(
kernel_window_storage_
.
get
(
)
0
sizeof
(
*
kernel_window_storage_
.
get
(
)
)
*
kKernelStorageSize
)
;
InitializeKernel
(
)
;
}
SincResampler
:
:
~
SincResampler
(
)
{
}
void
SincResampler
:
:
UpdateRegions
(
bool
second_load
)
{
r0_
=
input_buffer_
.
get
(
)
+
(
second_load
?
kKernelSize
:
kKernelSize
/
2
)
;
r3_
=
r0_
+
request_frames_
-
kKernelSize
;
r4_
=
r0_
+
request_frames_
-
kKernelSize
/
2
;
block_size_
=
r4_
-
r2_
;
RTC_DCHECK_EQ
(
r1_
input_buffer_
.
get
(
)
)
;
RTC_DCHECK_EQ
(
r2_
-
r1_
r4_
-
r3_
)
;
RTC_DCHECK_LT
(
r2_
r3_
)
;
}
void
SincResampler
:
:
InitializeKernel
(
)
{
static
const
double
kAlpha
=
0
.
16
;
static
const
double
kA0
=
0
.
5
*
(
1
.
0
-
kAlpha
)
;
static
const
double
kA1
=
0
.
5
;
static
const
double
kA2
=
0
.
5
*
kAlpha
;
const
double
sinc_scale_factor
=
SincScaleFactor
(
io_sample_rate_ratio_
)
;
for
(
size_t
offset_idx
=
0
;
offset_idx
<
=
kKernelOffsetCount
;
+
+
offset_idx
)
{
const
float
subsample_offset
=
static_cast
<
float
>
(
offset_idx
)
/
kKernelOffsetCount
;
for
(
size_t
i
=
0
;
i
<
kKernelSize
;
+
+
i
)
{
const
size_t
idx
=
i
+
offset_idx
*
kKernelSize
;
const
float
pre_sinc
=
static_cast
<
float
>
(
std
:
:
numbers
:
:
pi
*
(
static_cast
<
int
>
(
i
)
-
static_cast
<
int
>
(
kKernelSize
/
2
)
-
subsample_offset
)
)
;
kernel_pre_sinc_storage_
[
idx
]
=
pre_sinc
;
const
float
x
=
(
i
-
subsample_offset
)
/
kKernelSize
;
const
float
window
=
static_cast
<
float
>
(
kA0
-
kA1
*
cos
(
2
.
0
*
std
:
:
numbers
:
:
pi
*
x
)
+
kA2
*
cos
(
4
.
0
*
std
:
:
numbers
:
:
pi
*
x
)
)
;
kernel_window_storage_
[
idx
]
=
window
;
kernel_storage_
[
idx
]
=
static_cast
<
float
>
(
window
*
(
(
pre_sinc
=
=
0
)
?
sinc_scale_factor
:
(
sin
(
sinc_scale_factor
*
pre_sinc
)
/
pre_sinc
)
)
)
;
}
}
}
void
SincResampler
:
:
SetRatio
(
double
io_sample_rate_ratio
)
{
if
(
fabs
(
io_sample_rate_ratio_
-
io_sample_rate_ratio
)
<
std
:
:
numeric_limits
<
double
>
:
:
epsilon
(
)
)
{
return
;
}
io_sample_rate_ratio_
=
io_sample_rate_ratio
;
const
double
sinc_scale_factor
=
SincScaleFactor
(
io_sample_rate_ratio_
)
;
for
(
size_t
offset_idx
=
0
;
offset_idx
<
=
kKernelOffsetCount
;
+
+
offset_idx
)
{
for
(
size_t
i
=
0
;
i
<
kKernelSize
;
+
+
i
)
{
const
size_t
idx
=
i
+
offset_idx
*
kKernelSize
;
const
float
window
=
kernel_window_storage_
[
idx
]
;
const
float
pre_sinc
=
kernel_pre_sinc_storage_
[
idx
]
;
kernel_storage_
[
idx
]
=
static_cast
<
float
>
(
window
*
(
(
pre_sinc
=
=
0
)
?
sinc_scale_factor
:
(
sin
(
sinc_scale_factor
*
pre_sinc
)
/
pre_sinc
)
)
)
;
}
}
}
void
SincResampler
:
:
Resample
(
size_t
frames
float
*
destination
)
{
size_t
remaining_frames
=
frames
;
if
(
!
buffer_primed_
&
&
remaining_frames
)
{
read_cb_
-
>
Run
(
request_frames_
r0_
)
;
buffer_primed_
=
true
;
}
const
double
current_io_ratio
=
io_sample_rate_ratio_
;
const
float
*
const
kernel_ptr
=
kernel_storage_
.
get
(
)
;
while
(
remaining_frames
)
{
for
(
int
i
=
static_cast
<
int
>
(
ceil
(
(
block_size_
-
virtual_source_idx_
)
/
current_io_ratio
)
)
;
i
>
0
;
-
-
i
)
{
RTC_DCHECK_LT
(
virtual_source_idx_
block_size_
)
;
const
int
source_idx
=
static_cast
<
int
>
(
virtual_source_idx_
)
;
const
double
subsample_remainder
=
virtual_source_idx_
-
source_idx
;
const
double
virtual_offset_idx
=
subsample_remainder
*
kKernelOffsetCount
;
const
int
offset_idx
=
static_cast
<
int
>
(
virtual_offset_idx
)
;
const
float
*
const
k1
=
kernel_ptr
+
offset_idx
*
kKernelSize
;
const
float
*
const
k2
=
k1
+
kKernelSize
;
RTC_DCHECK_EQ
(
0
reinterpret_cast
<
uintptr_t
>
(
k1
)
%
32
)
;
RTC_DCHECK_EQ
(
0
reinterpret_cast
<
uintptr_t
>
(
k2
)
%
32
)
;
const
float
*
const
input_ptr
=
r1_
+
source_idx
;
const
double
kernel_interpolation_factor
=
virtual_offset_idx
-
offset_idx
;
*
destination
+
+
=
convolve_proc_
(
input_ptr
k1
k2
kernel_interpolation_factor
)
;
virtual_source_idx_
+
=
current_io_ratio
;
if
(
!
-
-
remaining_frames
)
return
;
}
virtual_source_idx_
-
=
block_size_
;
memcpy
(
r1_
r3_
sizeof
(
*
input_buffer_
.
get
(
)
)
*
kKernelSize
)
;
if
(
r0_
=
=
r2_
)
UpdateRegions
(
true
)
;
read_cb_
-
>
Run
(
request_frames_
r0_
)
;
}
}
#
undef
CONVOLVE_FUNC
size_t
SincResampler
:
:
ChunkSize
(
)
const
{
return
static_cast
<
size_t
>
(
block_size_
/
io_sample_rate_ratio_
)
;
}
void
SincResampler
:
:
Flush
(
)
{
virtual_source_idx_
=
0
;
buffer_primed_
=
false
;
memset
(
input_buffer_
.
get
(
)
0
sizeof
(
*
input_buffer_
.
get
(
)
)
*
input_buffer_size_
)
;
UpdateRegions
(
false
)
;
}
float
SincResampler
:
:
Convolve_C
(
const
float
*
input_ptr
const
float
*
k1
const
float
*
k2
double
kernel_interpolation_factor
)
{
float
sum1
=
0
;
float
sum2
=
0
;
size_t
n
=
kKernelSize
;
while
(
n
-
-
)
{
sum1
+
=
*
input_ptr
*
*
k1
+
+
;
sum2
+
=
*
input_ptr
+
+
*
*
k2
+
+
;
}
return
static_cast
<
float
>
(
(
1
.
0
-
kernel_interpolation_factor
)
*
sum1
+
kernel_interpolation_factor
*
sum2
)
;
}
}
