#
include
"
common_audio
/
vad
/
vad_unittest
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
cstdint
>
#
include
<
iterator
>
#
include
"
common_audio
/
signal_processing
/
include
/
signal_processing_library
.
h
"
#
include
"
common_audio
/
vad
/
include
/
webrtc_vad
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
test
/
gtest
.
h
"
VadTest
:
:
VadTest
(
)
{
}
void
VadTest
:
:
SetUp
(
)
{
}
void
VadTest
:
:
TearDown
(
)
{
}
bool
VadTest
:
:
ValidRatesAndFrameLengths
(
int
rate
size_t
frame_length
)
{
if
(
rate
=
=
8000
)
{
if
(
frame_length
=
=
80
|
|
frame_length
=
=
160
|
|
frame_length
=
=
240
)
{
return
true
;
}
return
false
;
}
else
if
(
rate
=
=
16000
)
{
if
(
frame_length
=
=
160
|
|
frame_length
=
=
320
|
|
frame_length
=
=
480
)
{
return
true
;
}
return
false
;
}
else
if
(
rate
=
=
32000
)
{
if
(
frame_length
=
=
320
|
|
frame_length
=
=
640
|
|
frame_length
=
=
960
)
{
return
true
;
}
return
false
;
}
else
if
(
rate
=
=
48000
)
{
if
(
frame_length
=
=
480
|
|
frame_length
=
=
960
|
|
frame_length
=
=
1440
)
{
return
true
;
}
return
false
;
}
return
false
;
}
namespace
webrtc
{
namespace
test
{
#
if
defined
(
__has_feature
)
&
&
__has_feature
(
undefined_behavior_sanitizer
)
TEST_F
(
VadTest
DISABLED_ApiTest
)
{
#
else
TEST_F
(
VadTest
ApiTest
)
{
#
endif
VadInst
*
handle
=
WebRtcVad_Create
(
)
;
int16_t
zeros
[
kMaxFrameLength
]
=
{
0
}
;
int16_t
speech
[
kMaxFrameLength
]
;
for
(
size_t
i
=
0
;
i
<
kMaxFrameLength
;
i
+
+
)
{
speech
[
i
]
=
static_cast
<
int16_t
>
(
i
*
i
)
;
}
EXPECT_EQ
(
-
1
WebRtcVad_Init
(
nullptr
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_set_mode
(
nullptr
kModes
[
0
]
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_Process
(
nullptr
kRates
[
0
]
speech
kFrameLengths
[
0
]
)
)
;
RTC_CHECK
(
handle
)
;
EXPECT_EQ
(
-
1
WebRtcVad_Process
(
handle
kRates
[
0
]
speech
kFrameLengths
[
0
]
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_set_mode
(
handle
kModes
[
0
]
)
)
;
ASSERT_EQ
(
0
WebRtcVad_Init
(
handle
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_set_mode
(
handle
WebRtcSpl_MinValueW32
(
kModes
kModesSize
)
-
1
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_set_mode
(
handle
WebRtcSpl_MaxValueW32
(
kModes
kModesSize
)
+
1
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_Process
(
handle
kRates
[
0
]
nullptr
kFrameLengths
[
0
]
)
)
;
EXPECT_EQ
(
-
1
WebRtcVad_Process
(
handle
9999
speech
kFrameLengths
[
0
]
)
)
;
EXPECT_EQ
(
0
WebRtcVad_Process
(
handle
kRates
[
0
]
zeros
kFrameLengths
[
0
]
)
)
;
for
(
size_t
k
=
0
;
k
<
kModesSize
;
k
+
+
)
{
EXPECT_EQ
(
0
WebRtcVad_set_mode
(
handle
kModes
[
k
]
)
)
;
for
(
size_t
i
=
0
;
i
<
kRatesSize
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
kFrameLengthsSize
;
j
+
+
)
{
if
(
ValidRatesAndFrameLengths
(
kRates
[
i
]
kFrameLengths
[
j
]
)
)
{
EXPECT_EQ
(
1
WebRtcVad_Process
(
handle
kRates
[
i
]
speech
kFrameLengths
[
j
]
)
)
;
}
else
{
EXPECT_EQ
(
-
1
WebRtcVad_Process
(
handle
kRates
[
i
]
speech
kFrameLengths
[
j
]
)
)
;
}
}
}
}
WebRtcVad_Free
(
handle
)
;
}
TEST_F
(
VadTest
ValidRatesFrameLengths
)
{
const
int
kInvalidRates
[
]
=
{
-
8000
-
4000
0
4000
8000
8001
15999
16000
32000
48000
48001
96000
}
;
const
size_t
kInvalidFrameLengths
[
]
=
{
0
80
81
159
160
240
320
480
640
960
1440
2000
}
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
kInvalidRates
)
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
std
:
:
size
(
kInvalidFrameLengths
)
;
j
+
+
)
{
if
(
ValidRatesAndFrameLengths
(
kInvalidRates
[
i
]
kInvalidFrameLengths
[
j
]
)
)
{
EXPECT_EQ
(
0
WebRtcVad_ValidRateAndFrameLength
(
kInvalidRates
[
i
]
kInvalidFrameLengths
[
j
]
)
)
;
}
else
{
EXPECT_EQ
(
-
1
WebRtcVad_ValidRateAndFrameLength
(
kInvalidRates
[
i
]
kInvalidFrameLengths
[
j
]
)
)
;
}
}
}
}
}
}
