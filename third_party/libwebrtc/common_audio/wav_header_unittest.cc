#
include
"
common_audio
/
wav_header
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
class
WavHeaderBufferReader
:
public
WavHeaderReader
{
public
:
WavHeaderBufferReader
(
const
uint8_t
*
buf
size_t
size
bool
check_read_size
)
:
buf_
(
buf
)
size_
(
size
)
pos_
(
0
)
buf_exhausted_
(
false
)
check_read_size_
(
check_read_size
)
{
}
~
WavHeaderBufferReader
(
)
override
{
if
(
check_read_size_
)
EXPECT_EQ
(
size_
pos_
)
;
}
size_t
Read
(
void
*
buf
size_t
num_bytes
)
override
{
EXPECT_FALSE
(
buf_exhausted_
)
;
const
size_t
bytes_remaining
=
size_
-
pos_
;
if
(
num_bytes
>
bytes_remaining
)
{
buf_exhausted_
=
true
;
num_bytes
=
bytes_remaining
;
}
memcpy
(
buf
&
buf_
[
pos_
]
num_bytes
)
;
pos_
+
=
num_bytes
;
return
num_bytes
;
}
bool
SeekForward
(
uint32_t
num_bytes
)
override
{
if
(
size_
>
=
kPcmWavHeaderSize
)
EXPECT_GE
(
size_
pos_
+
num_bytes
)
;
EXPECT_FALSE
(
buf_exhausted_
)
;
const
size_t
bytes_remaining
=
size_
-
pos_
;
if
(
num_bytes
>
bytes_remaining
)
{
return
false
;
}
if
(
num_bytes
=
=
bytes_remaining
)
{
buf_exhausted_
=
true
;
}
pos_
+
=
num_bytes
;
return
true
;
}
int64_t
GetPosition
(
)
override
{
return
pos_
;
}
private
:
const
uint8_t
*
buf_
;
const
size_t
size_
;
size_t
pos_
;
bool
buf_exhausted_
;
const
bool
check_read_size_
;
}
;
TEST
(
WavHeaderTest
CheckWavParameters
)
{
EXPECT_TRUE
(
CheckWavParameters
(
1
8000
WavFormat
:
:
kWavFormatPcm
0
)
)
;
EXPECT_FALSE
(
CheckWavParameters
(
0
8000
WavFormat
:
:
kWavFormatPcm
0
)
)
;
EXPECT_FALSE
(
CheckWavParameters
(
0x10000
8000
WavFormat
:
:
kWavFormatPcm
0
)
)
;
EXPECT_FALSE
(
CheckWavParameters
(
1
0
WavFormat
:
:
kWavFormatPcm
0
)
)
;
EXPECT_FALSE
(
CheckWavParameters
(
1
<
<
20
1
<
<
20
WavFormat
:
:
kWavFormatPcm
0
)
)
;
EXPECT_FALSE
(
CheckWavParameters
(
1
8000
WavFormat
:
:
kWavFormatPcm
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
)
;
EXPECT_FALSE
(
CheckWavParameters
(
3
8000
WavFormat
:
:
kWavFormatPcm
5
)
)
;
}
TEST
(
WavHeaderTest
ReadWavHeaderWithErrors
)
{
size_t
num_channels
=
0
;
int
sample_rate
=
0
;
WavFormat
format
=
WavFormat
:
:
kWavFormatPcm
;
size_t
bytes_per_sample
=
0
;
size_t
num_samples
=
0
;
int64_t
data_start_pos
=
0
;
{
constexpr
uint8_t
kBadRiffID
[
]
=
{
'
R
'
'
i
'
'
f
'
'
f
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
8
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
WavHeaderBufferReader
r
(
kBadRiffID
sizeof
(
kBadRiffID
)
false
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
{
constexpr
uint8_t
kBadBitsPerSample
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
1
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
WavHeaderBufferReader
r
(
kBadBitsPerSample
sizeof
(
kBadBitsPerSample
)
true
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
{
constexpr
uint8_t
kBadByteRate
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
17
0
0x39
0x30
0
0
0x00
0x33
0x03
0
17
0
8
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
WavHeaderBufferReader
r
(
kBadByteRate
sizeof
(
kBadByteRate
)
true
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
{
constexpr
uint8_t
kBadFmtHeaderSize
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
17
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
8
0
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
WavHeaderBufferReader
r
(
kBadFmtHeaderSize
sizeof
(
kBadFmtHeaderSize
)
false
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
{
constexpr
uint8_t
kNonZeroExtensionField
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
18
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
8
0
1
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
WavHeaderBufferReader
r
(
kNonZeroExtensionField
sizeof
(
kNonZeroExtensionField
)
false
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
{
constexpr
uint8_t
kMissingDataChunk
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
8
0
}
;
WavHeaderBufferReader
r
(
kMissingDataChunk
sizeof
(
kMissingDataChunk
)
true
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
{
constexpr
uint8_t
kMissingFmtAndDataChunks
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
}
;
WavHeaderBufferReader
r
(
kMissingFmtAndDataChunks
sizeof
(
kMissingFmtAndDataChunks
)
true
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
}
TEST
(
WavHeaderTest
WriteAndReadWavHeader
)
{
constexpr
int
kSize
=
4
+
kPcmWavHeaderSize
+
4
;
uint8_t
buf
[
kSize
]
;
size_t
header_size
;
memset
(
buf
0xa4
sizeof
(
buf
)
)
;
WriteWavHeader
(
17
12345
WavFormat
:
:
kWavFormatPcm
123457689
buf
+
4
&
header_size
)
;
constexpr
uint8_t
kExpectedBuf
[
]
=
{
0xa4
0xa4
0xa4
0xa4
'
R
'
'
I
'
'
F
'
'
F
'
0x56
0xa1
0xb7
0x0e
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
17
0
0x39
0x30
0
0
0x92
0x67
0x06
0
34
0
16
0
'
d
'
'
a
'
'
t
'
'
a
'
0x32
0xa1
0xb7
0x0e
0xa4
0xa4
0xa4
0xa4
}
;
static_assert
(
sizeof
(
kExpectedBuf
)
=
=
kSize
"
buffer
size
"
)
;
EXPECT_EQ
(
0
memcmp
(
kExpectedBuf
buf
kSize
)
)
;
size_t
num_channels
=
0
;
int
sample_rate
=
0
;
WavFormat
format
=
WavFormat
:
:
kWavFormatPcm
;
size_t
bytes_per_sample
=
0
;
size_t
num_samples
=
0
;
int64_t
data_start_pos
=
0
;
WavHeaderBufferReader
r
(
buf
+
4
sizeof
(
buf
)
-
8
true
)
;
EXPECT_TRUE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
EXPECT_EQ
(
17u
num_channels
)
;
EXPECT_EQ
(
12345
sample_rate
)
;
EXPECT_EQ
(
WavFormat
:
:
kWavFormatPcm
format
)
;
EXPECT_EQ
(
2u
bytes_per_sample
)
;
EXPECT_EQ
(
123457689u
num_samples
)
;
}
TEST
(
WavHeaderTest
ReadAtypicalWavHeader
)
{
constexpr
uint8_t
kBuf
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xbf
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
18
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
8
0
0
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
size_t
num_channels
=
0
;
int
sample_rate
=
0
;
WavFormat
format
=
WavFormat
:
:
kWavFormatPcm
;
size_t
bytes_per_sample
=
0
;
size_t
num_samples
=
0
;
int64_t
data_start_pos
=
0
;
WavHeaderBufferReader
r
(
kBuf
sizeof
(
kBuf
)
true
)
;
EXPECT_TRUE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
EXPECT_EQ
(
17u
num_channels
)
;
EXPECT_EQ
(
12345
sample_rate
)
;
EXPECT_EQ
(
WavFormat
:
:
kWavFormatPcm
format
)
;
EXPECT_EQ
(
1u
bytes_per_sample
)
;
EXPECT_EQ
(
123457689u
num_samples
)
;
}
TEST
(
WavHeaderTest
ReadWavHeaderWithOptionalChunk
)
{
constexpr
uint8_t
kBuf
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
0xcd
0xd0
0x5b
0x07
'
W
'
'
A
'
'
V
'
'
E
'
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
17
0
0x39
0x30
0
0
0xc9
0x33
0x03
0
17
0
8
0
'
L
'
'
I
'
'
S
'
'
T
'
16
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
'
d
'
'
a
'
'
t
'
'
a
'
0x99
0xd0
0x5b
0x07
}
;
size_t
num_channels
=
0
;
int
sample_rate
=
0
;
WavFormat
format
=
WavFormat
:
:
kWavFormatPcm
;
size_t
bytes_per_sample
=
0
;
size_t
num_samples
=
0
;
int64_t
data_start_pos
=
0
;
WavHeaderBufferReader
r
(
kBuf
sizeof
(
kBuf
)
true
)
;
EXPECT_TRUE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
EXPECT_EQ
(
17u
num_channels
)
;
EXPECT_EQ
(
12345
sample_rate
)
;
EXPECT_EQ
(
WavFormat
:
:
kWavFormatPcm
format
)
;
EXPECT_EQ
(
1u
bytes_per_sample
)
;
EXPECT_EQ
(
123457689u
num_samples
)
;
}
TEST
(
WavHeaderTest
ReadWavHeaderWithDataBeforeFormat
)
{
constexpr
uint8_t
kBuf
[
]
=
{
'
R
'
'
I
'
'
F
'
'
F
'
52
0
0
0
'
W
'
'
A
'
'
V
'
'
E
'
'
d
'
'
a
'
'
t
'
'
a
'
16
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
'
f
'
'
m
'
'
t
'
'
'
16
0
0
0
1
0
1
0
60
0
0
0
60
0
0
0
1
0
8
0
}
;
size_t
num_channels
=
0
;
int
sample_rate
=
0
;
WavFormat
format
=
WavFormat
:
:
kWavFormatPcm
;
size_t
bytes_per_sample
=
0
;
size_t
num_samples
=
0
;
int64_t
data_start_pos
=
0
;
WavHeaderBufferReader
r
(
kBuf
sizeof
(
kBuf
)
false
)
;
EXPECT_FALSE
(
ReadWavHeader
(
&
r
&
num_channels
&
sample_rate
&
format
&
bytes_per_sample
&
num_samples
&
data_start_pos
)
)
;
}
}
