#
include
"
test
/
pc
/
e2e
/
sdp
/
sdp_changer
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
jsep_session_description
.
h
"
#
include
"
api
/
media_types
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
api
/
rtp_transceiver_direction
.
h
"
#
include
"
api
/
test
/
pclf
/
media_configuration
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
media
/
base
/
rid_description
.
h
"
#
include
"
media
/
base
/
stream_params
.
h
"
#
include
"
p2p
/
base
/
p2p_constants
.
h
"
#
include
"
p2p
/
base
/
transport_description
.
h
"
#
include
"
p2p
/
base
/
transport_info
.
h
"
#
include
"
pc
/
sdp_utils
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
pc
/
simulcast_description
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
rtc_base
/
unique_id_generator
.
h
"
namespace
webrtc
{
namespace
webrtc_pc_e2e
{
namespace
{
std
:
:
string
CodecRequiredParamsToString
(
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
codec_required_params
)
{
StringBuilder
out
;
for
(
const
auto
&
entry
:
codec_required_params
)
{
out
<
<
entry
.
first
<
<
"
=
"
<
<
entry
.
second
<
<
"
;
"
;
}
return
out
.
str
(
)
;
}
std
:
:
string
SupportedCodecsToString
(
ArrayView
<
const
RtpCodecCapability
>
supported_codecs
)
{
StringBuilder
out
;
for
(
const
auto
&
codec
:
supported_codecs
)
{
out
<
<
codec
.
name
;
if
(
!
codec
.
parameters
.
empty
(
)
)
{
out
<
<
"
(
"
;
for
(
const
auto
&
param
:
codec
.
parameters
)
{
out
<
<
param
.
first
<
<
"
=
"
<
<
param
.
second
<
<
"
;
"
;
}
out
<
<
"
)
"
;
}
out
<
<
"
;
"
;
}
return
out
.
str
(
)
;
}
}
std
:
:
vector
<
RtpCodecCapability
>
FilterVideoCodecCapabilities
(
ArrayView
<
const
VideoCodecConfig
>
video_codecs
bool
use_rtx
bool
use_ulpfec
bool
use_flexfec
ArrayView
<
const
RtpCodecCapability
>
supported_codecs
)
{
std
:
:
vector
<
RtpCodecCapability
>
output_codecs
;
for
(
auto
&
codec_request
:
video_codecs
)
{
size_t
size_before
=
output_codecs
.
size
(
)
;
for
(
auto
&
codec
:
supported_codecs
)
{
if
(
codec
.
name
!
=
codec_request
.
name
)
{
continue
;
}
bool
parameters_matched
=
true
;
for
(
const
auto
&
item
:
codec_request
.
required_params
)
{
auto
it
=
codec
.
parameters
.
find
(
item
.
first
)
;
if
(
it
=
=
codec
.
parameters
.
end
(
)
)
{
parameters_matched
=
false
;
break
;
}
if
(
item
.
second
!
=
it
-
>
second
)
{
parameters_matched
=
false
;
break
;
}
}
if
(
parameters_matched
)
{
output_codecs
.
push_back
(
codec
)
;
}
}
RTC_CHECK_GT
(
output_codecs
.
size
(
)
size_before
)
<
<
"
Codec
with
name
=
"
<
<
codec_request
.
name
<
<
"
and
params
{
"
<
<
CodecRequiredParamsToString
(
codec_request
.
required_params
)
<
<
"
}
is
unsupported
for
this
peer
connection
.
Supported
codecs
are
:
"
<
<
SupportedCodecsToString
(
supported_codecs
)
;
}
for
(
auto
&
codec
:
supported_codecs
)
{
if
(
codec
.
name
=
=
kRtxCodecName
&
&
use_rtx
)
{
output_codecs
.
push_back
(
codec
)
;
}
else
if
(
codec
.
name
=
=
kFlexfecCodecName
&
&
use_flexfec
)
{
output_codecs
.
push_back
(
codec
)
;
}
else
if
(
(
codec
.
name
=
=
kRedCodecName
|
|
codec
.
name
=
=
kUlpfecCodecName
)
&
&
use_ulpfec
)
{
output_codecs
.
push_back
(
codec
)
;
}
}
return
output_codecs
;
}
void
SignalingInterceptor
:
:
FillSimulcastContext
(
SessionDescriptionInterface
*
offer
)
{
for
(
auto
&
content
:
offer
-
>
description
(
)
-
>
contents
(
)
)
{
MediaContentDescription
*
media_desc
=
content
.
media_description
(
)
;
if
(
media_desc
-
>
type
(
)
!
=
MediaType
:
:
VIDEO
)
{
continue
;
}
if
(
media_desc
-
>
HasSimulcast
(
)
)
{
RTC_CHECK_EQ
(
media_desc
-
>
mutable_streams
(
)
.
size
(
)
1
)
;
RTC_CHECK
(
media_desc
-
>
mutable_streams
(
)
[
0
]
.
has_rids
(
)
)
;
SimulcastSectionInfo
info
(
content
.
mid
(
)
content
.
type
media_desc
-
>
mutable_streams
(
)
[
0
]
.
rids
(
)
)
;
std
:
:
vector
<
RidDescription
>
rids
;
SimulcastDescription
simulcast_description
;
for
(
std
:
:
string
&
rid
:
info
.
rids
)
{
rids
.
emplace_back
(
rid
RidDirection
:
:
kSend
)
;
simulcast_description
.
send_layers
(
)
.
AddLayer
(
SimulcastLayer
(
rid
false
)
)
;
}
media_desc
-
>
mutable_streams
(
)
[
0
]
.
set_rids
(
rids
)
;
media_desc
-
>
set_simulcast_description
(
simulcast_description
)
;
info
.
simulcast_description
=
media_desc
-
>
simulcast_description
(
)
;
for
(
const
auto
&
extension
:
media_desc
-
>
rtp_header_extensions
(
)
)
{
if
(
extension
.
uri
=
=
RtpExtension
:
:
kMidUri
)
{
info
.
mid_extension
=
extension
;
}
else
if
(
extension
.
uri
=
=
RtpExtension
:
:
kRidUri
)
{
info
.
rid_extension
=
extension
;
}
else
if
(
extension
.
uri
=
=
RtpExtension
:
:
kRepairedRidUri
)
{
info
.
rrid_extension
=
extension
;
}
}
RTC_CHECK_NE
(
info
.
rid_extension
.
id
0
)
;
RTC_CHECK_NE
(
info
.
mid_extension
.
id
0
)
;
bool
transport_description_found
=
false
;
for
(
auto
&
transport_info
:
offer
-
>
description
(
)
-
>
transport_infos
(
)
)
{
if
(
transport_info
.
content_name
=
=
info
.
mid
)
{
info
.
transport_description
=
transport_info
.
description
;
transport_description_found
=
true
;
break
;
}
}
RTC_CHECK
(
transport_description_found
)
;
context_
.
AddSimulcastInfo
(
info
)
;
}
}
}
LocalAndRemoteSdp
SignalingInterceptor
:
:
PatchOffer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
offer
const
VideoCodecConfig
&
first_codec
)
{
for
(
auto
&
content
:
offer
-
>
description
(
)
-
>
contents
(
)
)
{
context_
.
mids_order
.
push_back
(
content
.
mid
(
)
)
;
MediaContentDescription
*
media_desc
=
content
.
media_description
(
)
;
if
(
media_desc
-
>
type
(
)
!
=
MediaType
:
:
VIDEO
)
{
continue
;
}
if
(
content
.
media_description
(
)
-
>
streams
(
)
.
empty
(
)
)
{
RTC_CHECK_EQ
(
content
.
media_description
(
)
-
>
direction
(
)
RtpTransceiverDirection
:
:
kRecvOnly
)
;
continue
;
}
media_desc
-
>
set_conference_mode
(
params_
.
use_conference_mode
)
;
}
if
(
!
params_
.
stream_label_to_simulcast_streams_count
.
empty
(
)
)
{
if
(
first_codec
.
name
=
=
kVp8CodecName
)
{
return
PatchVp8Offer
(
std
:
:
move
(
offer
)
)
;
}
if
(
first_codec
.
name
=
=
kVp9CodecName
)
{
return
PatchVp9Offer
(
std
:
:
move
(
offer
)
)
;
}
}
auto
offer_for_remote
=
CloneSessionDescription
(
offer
.
get
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
offer
)
std
:
:
move
(
offer_for_remote
)
)
;
}
LocalAndRemoteSdp
SignalingInterceptor
:
:
PatchVp8Offer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
offer
)
{
FillSimulcastContext
(
offer
.
get
(
)
)
;
if
(
!
context_
.
HasSimulcast
(
)
)
{
auto
offer_for_remote
=
CloneSessionDescription
(
offer
.
get
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
offer
)
std
:
:
move
(
offer_for_remote
)
)
;
}
std
:
:
unique_ptr
<
SessionDescription
>
desc
=
offer
-
>
description
(
)
-
>
Clone
(
)
;
for
(
auto
&
info
:
context_
.
simulcast_infos
)
{
ContentInfo
*
simulcast_content
=
desc
-
>
GetContentByName
(
info
.
mid
)
;
std
:
:
unique_ptr
<
MediaContentDescription
>
prototype_media_desc
=
simulcast_content
-
>
media_description
(
)
-
>
Clone
(
)
;
RTC_CHECK
(
desc
-
>
RemoveContentByName
(
simulcast_content
-
>
mid
(
)
)
)
;
simulcast_content
=
nullptr
;
std
:
:
vector
<
RtpExtension
>
extensions
=
prototype_media_desc
-
>
rtp_header_extensions
(
)
;
for
(
auto
ext_it
=
extensions
.
begin
(
)
;
ext_it
!
=
extensions
.
end
(
)
;
)
{
if
(
ext_it
-
>
uri
=
=
RtpExtension
:
:
kRidUri
)
{
ext_it
=
extensions
.
erase
(
ext_it
)
;
continue
;
}
if
(
ext_it
-
>
uri
=
=
RtpExtension
:
:
kRepairedRidUri
)
{
ext_it
=
extensions
.
erase
(
ext_it
)
;
continue
;
}
if
(
ext_it
-
>
uri
=
=
RtpExtension
:
:
kMidUri
)
{
ext_it
-
>
id
=
info
.
rid_extension
.
id
;
}
+
+
ext_it
;
}
prototype_media_desc
-
>
ClearRtpHeaderExtensions
(
)
;
prototype_media_desc
-
>
set_rtp_header_extensions
(
extensions
)
;
RTC_CHECK_EQ
(
prototype_media_desc
-
>
mutable_streams
(
)
.
size
(
)
1
)
;
RTC_CHECK
(
prototype_media_desc
-
>
mutable_streams
(
)
[
0
]
.
has_rids
(
)
)
;
prototype_media_desc
-
>
mutable_streams
(
)
[
0
]
.
set_rids
(
{
}
)
;
prototype_media_desc
-
>
set_simulcast_description
(
SimulcastDescription
(
)
)
;
for
(
std
:
:
string
&
rid
:
info
.
rids
)
{
desc
-
>
AddContent
(
rid
info
.
media_protocol_type
prototype_media_desc
-
>
Clone
(
)
)
;
}
}
ContentGroup
bundle_group
(
GROUP_TYPE_BUNDLE
)
;
for
(
auto
&
content
:
desc
-
>
contents
(
)
)
{
bundle_group
.
AddContentName
(
content
.
mid
(
)
)
;
}
if
(
desc
-
>
HasGroup
(
GROUP_TYPE_BUNDLE
)
)
{
desc
-
>
RemoveGroupByName
(
GROUP_TYPE_BUNDLE
)
;
}
desc
-
>
AddGroup
(
bundle_group
)
;
std
:
:
vector
<
TransportInfo
>
transport_infos
=
desc
-
>
transport_infos
(
)
;
transport_infos
.
erase
(
std
:
:
remove_if
(
transport_infos
.
begin
(
)
transport_infos
.
end
(
)
[
this
]
(
const
TransportInfo
&
ti
)
{
return
context_
.
simulcast_infos_by_mid
.
find
(
ti
.
content_name
)
!
=
context_
.
simulcast_infos_by_mid
.
end
(
)
;
}
)
)
;
for
(
auto
&
info
:
context_
.
simulcast_infos
)
{
for
(
auto
&
rid
:
info
.
rids
)
{
transport_infos
.
emplace_back
(
rid
info
.
transport_description
)
;
}
}
desc
-
>
set_transport_infos
(
transport_infos
)
;
auto
patched_offer
=
std
:
:
make_unique
<
JsepSessionDescription
>
(
SdpType
:
:
kOffer
)
;
patched_offer
-
>
Initialize
(
std
:
:
move
(
desc
)
offer
-
>
session_id
(
)
offer
-
>
session_version
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
offer
)
std
:
:
move
(
patched_offer
)
)
;
}
LocalAndRemoteSdp
SignalingInterceptor
:
:
PatchVp9Offer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
offer
)
{
UniqueRandomIdGenerator
ssrcs_generator
;
for
(
auto
&
content
:
offer
-
>
description
(
)
-
>
contents
(
)
)
{
for
(
auto
&
stream
:
content
.
media_description
(
)
-
>
streams
(
)
)
{
for
(
auto
&
ssrc
:
stream
.
ssrcs
)
{
ssrcs_generator
.
AddKnownId
(
ssrc
)
;
}
}
}
for
(
auto
&
content
:
offer
-
>
description
(
)
-
>
contents
(
)
)
{
if
(
content
.
media_description
(
)
-
>
type
(
)
!
=
MediaType
:
:
VIDEO
)
{
continue
;
}
if
(
content
.
media_description
(
)
-
>
direction
(
)
=
=
RtpTransceiverDirection
:
:
kRecvOnly
)
{
continue
;
}
RTC_CHECK_EQ
(
content
.
media_description
(
)
-
>
streams
(
)
.
size
(
)
1
)
;
StreamParams
&
stream
=
content
.
media_description
(
)
-
>
mutable_streams
(
)
[
0
]
;
RTC_CHECK_EQ
(
stream
.
stream_ids
(
)
.
size
(
)
2
)
<
<
"
Expected
2
stream
ids
in
video
stream
:
1st
-
sync_group
2nd
-
"
"
unique
label
"
;
std
:
:
string
stream_label
=
stream
.
stream_ids
(
)
[
1
]
;
auto
it
=
params_
.
stream_label_to_simulcast_streams_count
.
find
(
stream_label
)
;
if
(
it
=
=
params_
.
stream_label_to_simulcast_streams_count
.
end
(
)
)
{
continue
;
}
int
svc_layers_count
=
it
-
>
second
;
RTC_CHECK
(
stream
.
has_ssrc_groups
(
)
)
<
<
"
Only
SVC
with
RTX
is
supported
"
;
RTC_CHECK_EQ
(
stream
.
ssrc_groups
.
size
(
)
1
)
<
<
"
Too
many
ssrc
groups
in
the
track
"
;
std
:
:
vector
<
uint32_t
>
primary_ssrcs
;
stream
.
GetPrimarySsrcs
(
&
primary_ssrcs
)
;
RTC_CHECK
(
primary_ssrcs
.
size
(
)
=
=
1
)
;
for
(
int
i
=
1
;
i
<
svc_layers_count
;
+
+
i
)
{
uint32_t
ssrc
=
ssrcs_generator
.
GenerateId
(
)
;
primary_ssrcs
.
push_back
(
ssrc
)
;
stream
.
add_ssrc
(
ssrc
)
;
stream
.
AddFidSsrc
(
ssrc
ssrcs_generator
.
GenerateId
(
)
)
;
}
stream
.
ssrc_groups
.
push_back
(
SsrcGroup
(
kSimSsrcGroupSemantics
primary_ssrcs
)
)
;
}
auto
offer_for_remote
=
CloneSessionDescription
(
offer
.
get
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
offer
)
std
:
:
move
(
offer_for_remote
)
)
;
}
LocalAndRemoteSdp
SignalingInterceptor
:
:
PatchAnswer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
answer
const
VideoCodecConfig
&
first_codec
)
{
for
(
auto
&
content
:
answer
-
>
description
(
)
-
>
contents
(
)
)
{
MediaContentDescription
*
media_desc
=
content
.
media_description
(
)
;
if
(
media_desc
-
>
type
(
)
!
=
MediaType
:
:
VIDEO
)
{
continue
;
}
if
(
content
.
media_description
(
)
-
>
direction
(
)
!
=
RtpTransceiverDirection
:
:
kRecvOnly
)
{
continue
;
}
media_desc
-
>
set_conference_mode
(
params_
.
use_conference_mode
)
;
}
if
(
!
params_
.
stream_label_to_simulcast_streams_count
.
empty
(
)
)
{
if
(
first_codec
.
name
=
=
kVp8CodecName
)
{
return
PatchVp8Answer
(
std
:
:
move
(
answer
)
)
;
}
if
(
first_codec
.
name
=
=
kVp9CodecName
)
{
return
PatchVp9Answer
(
std
:
:
move
(
answer
)
)
;
}
}
auto
answer_for_remote
=
CloneSessionDescription
(
answer
.
get
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
answer
)
std
:
:
move
(
answer_for_remote
)
)
;
}
LocalAndRemoteSdp
SignalingInterceptor
:
:
PatchVp8Answer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
answer
)
{
if
(
!
context_
.
HasSimulcast
(
)
)
{
auto
answer_for_remote
=
CloneSessionDescription
(
answer
.
get
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
answer
)
std
:
:
move
(
answer_for_remote
)
)
;
}
std
:
:
unique_ptr
<
SessionDescription
>
desc
=
answer
-
>
description
(
)
-
>
Clone
(
)
;
for
(
auto
&
info
:
context_
.
simulcast_infos
)
{
ContentInfo
*
simulcast_content
=
desc
-
>
GetContentByName
(
info
.
rids
[
0
]
)
;
RTC_CHECK
(
simulcast_content
)
;
std
:
:
unique_ptr
<
MediaContentDescription
>
media_desc
=
simulcast_content
-
>
media_description
(
)
-
>
Clone
(
)
;
simulcast_content
=
nullptr
;
for
(
auto
&
rid
:
info
.
rids
)
{
RTC_CHECK
(
desc
-
>
RemoveContentByName
(
rid
)
)
;
}
std
:
:
vector
<
RtpExtension
>
extensions
=
media_desc
-
>
rtp_header_extensions
(
)
;
extensions
.
erase
(
std
:
:
remove_if
(
extensions
.
begin
(
)
extensions
.
end
(
)
[
]
(
const
webrtc
:
:
RtpExtension
&
e
)
{
return
e
.
uri
=
=
RtpExtension
:
:
kMidUri
|
|
e
.
uri
=
=
RtpExtension
:
:
kRidUri
|
|
e
.
uri
=
=
RtpExtension
:
:
kRepairedRidUri
;
}
)
)
;
extensions
.
push_back
(
info
.
mid_extension
)
;
extensions
.
push_back
(
info
.
rid_extension
)
;
media_desc
-
>
ClearRtpHeaderExtensions
(
)
;
media_desc
-
>
set_rtp_header_extensions
(
extensions
)
;
RTC_CHECK_EQ
(
media_desc
-
>
mutable_streams
(
)
.
size
(
)
0
)
;
std
:
:
vector
<
RidDescription
>
rids
;
for
(
auto
&
rid
:
info
.
rids
)
{
rids
.
emplace_back
(
rid
RidDirection
:
:
kReceive
)
;
}
StreamParams
stream_params
;
stream_params
.
set_rids
(
rids
)
;
media_desc
-
>
mutable_streams
(
)
.
push_back
(
stream_params
)
;
SimulcastDescription
simulcast_description
;
for
(
const
auto
&
layer
:
info
.
simulcast_description
.
send_layers
(
)
)
{
simulcast_description
.
receive_layers
(
)
.
AddLayerWithAlternatives
(
layer
)
;
}
media_desc
-
>
set_simulcast_description
(
simulcast_description
)
;
desc
-
>
AddContent
(
info
.
mid
info
.
media_protocol_type
std
:
:
move
(
media_desc
)
)
;
}
desc
=
RestoreMediaSectionsOrder
(
std
:
:
move
(
desc
)
)
;
ContentGroup
bundle_group
(
GROUP_TYPE_BUNDLE
)
;
for
(
auto
&
content
:
desc
-
>
contents
(
)
)
{
bundle_group
.
AddContentName
(
content
.
mid
(
)
)
;
}
if
(
desc
-
>
HasGroup
(
GROUP_TYPE_BUNDLE
)
)
{
desc
-
>
RemoveGroupByName
(
GROUP_TYPE_BUNDLE
)
;
}
desc
-
>
AddGroup
(
bundle_group
)
;
std
:
:
vector
<
TransportInfo
>
transport_infos
=
desc
-
>
transport_infos
(
)
;
std
:
:
map
<
std
:
:
string
TransportDescription
>
mid_to_transport_description
;
for
(
auto
info_it
=
transport_infos
.
begin
(
)
;
info_it
!
=
transport_infos
.
end
(
)
;
)
{
auto
it
=
context_
.
simulcast_infos_by_rid
.
find
(
info_it
-
>
content_name
)
;
if
(
it
!
=
context_
.
simulcast_infos_by_rid
.
end
(
)
)
{
mid_to_transport_description
.
insert
(
{
it
-
>
second
-
>
mid
info_it
-
>
description
}
)
;
info_it
=
transport_infos
.
erase
(
info_it
)
;
}
else
{
+
+
info_it
;
}
}
for
(
auto
&
info
:
context_
.
simulcast_infos
)
{
transport_infos
.
emplace_back
(
info
.
mid
mid_to_transport_description
.
at
(
info
.
mid
)
)
;
}
desc
-
>
set_transport_infos
(
transport_infos
)
;
auto
patched_answer
=
std
:
:
make_unique
<
JsepSessionDescription
>
(
SdpType
:
:
kAnswer
)
;
patched_answer
-
>
Initialize
(
std
:
:
move
(
desc
)
answer
-
>
session_id
(
)
answer
-
>
session_version
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
answer
)
std
:
:
move
(
patched_answer
)
)
;
}
std
:
:
unique_ptr
<
SessionDescription
>
SignalingInterceptor
:
:
RestoreMediaSectionsOrder
(
std
:
:
unique_ptr
<
SessionDescription
>
source
)
{
std
:
:
unique_ptr
<
SessionDescription
>
out
=
source
-
>
Clone
(
)
;
for
(
auto
&
mid
:
context_
.
mids_order
)
{
RTC_CHECK
(
out
-
>
RemoveContentByName
(
mid
)
)
;
}
RTC_CHECK_EQ
(
out
-
>
contents
(
)
.
size
(
)
0
)
;
for
(
auto
&
mid
:
context_
.
mids_order
)
{
ContentInfo
*
content
=
source
-
>
GetContentByName
(
mid
)
;
RTC_CHECK
(
content
)
;
out
-
>
AddContent
(
mid
content
-
>
type
content
-
>
media_description
(
)
-
>
Clone
(
)
)
;
}
return
out
;
}
LocalAndRemoteSdp
SignalingInterceptor
:
:
PatchVp9Answer
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
answer
)
{
auto
answer_for_remote
=
CloneSessionDescription
(
answer
.
get
(
)
)
;
return
LocalAndRemoteSdp
(
std
:
:
move
(
answer
)
std
:
:
move
(
answer_for_remote
)
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
SignalingInterceptor
:
:
PatchOffererIceCandidates
(
ArrayView
<
const
IceCandidate
*
const
>
candidates
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
out
;
for
(
auto
*
candidate
:
candidates
)
{
auto
simulcast_info_it
=
context_
.
simulcast_infos_by_mid
.
find
(
candidate
-
>
sdp_mid
(
)
)
;
if
(
simulcast_info_it
!
=
context_
.
simulcast_infos_by_mid
.
end
(
)
)
{
for
(
const
std
:
:
string
&
rid
:
simulcast_info_it
-
>
second
-
>
rids
)
{
out
.
push_back
(
CreateIceCandidate
(
rid
-
1
candidate
-
>
candidate
(
)
)
)
;
}
}
else
{
out
.
push_back
(
CreateIceCandidate
(
candidate
-
>
sdp_mid
(
)
candidate
-
>
sdp_mline_index
(
)
candidate
-
>
candidate
(
)
)
)
;
}
}
RTC_CHECK_GT
(
out
.
size
(
)
0
)
;
return
out
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
SignalingInterceptor
:
:
PatchAnswererIceCandidates
(
ArrayView
<
const
IceCandidate
*
const
>
candidates
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
out
;
for
(
auto
*
candidate
:
candidates
)
{
auto
simulcast_info_it
=
context_
.
simulcast_infos_by_rid
.
find
(
candidate
-
>
sdp_mid
(
)
)
;
if
(
simulcast_info_it
!
=
context_
.
simulcast_infos_by_rid
.
end
(
)
)
{
out
.
push_back
(
CreateIceCandidate
(
simulcast_info_it
-
>
second
-
>
mid
0
candidate
-
>
candidate
(
)
)
)
;
}
else
if
(
!
context_
.
simulcast_infos_by_rid
.
empty
(
)
)
{
out
.
push_back
(
CreateIceCandidate
(
"
"
0
candidate
-
>
candidate
(
)
)
)
;
}
else
{
out
.
push_back
(
CreateIceCandidate
(
candidate
-
>
sdp_mid
(
)
candidate
-
>
sdp_mline_index
(
)
candidate
-
>
candidate
(
)
)
)
;
}
}
RTC_CHECK_GT
(
out
.
size
(
)
0
)
;
return
out
;
}
SignalingInterceptor
:
:
SimulcastSectionInfo
:
:
SimulcastSectionInfo
(
const
std
:
:
string
&
mid
MediaProtocolType
media_protocol_type
const
std
:
:
vector
<
RidDescription
>
&
rids_desc
)
:
mid
(
mid
)
media_protocol_type
(
media_protocol_type
)
{
for
(
auto
&
rid
:
rids_desc
)
{
rids
.
push_back
(
rid
.
rid
)
;
}
}
void
SignalingInterceptor
:
:
SignalingContext
:
:
AddSimulcastInfo
(
const
SimulcastSectionInfo
&
info
)
{
simulcast_infos
.
push_back
(
info
)
;
bool
inserted
=
simulcast_infos_by_mid
.
insert
(
{
info
.
mid
&
simulcast_infos
.
back
(
)
}
)
.
second
;
RTC_CHECK
(
inserted
)
;
for
(
auto
&
rid
:
info
.
rids
)
{
inserted
=
simulcast_infos_by_rid
.
insert
(
{
rid
&
simulcast_infos
.
back
(
)
}
)
.
second
;
RTC_CHECK
(
inserted
)
;
}
}
}
}
