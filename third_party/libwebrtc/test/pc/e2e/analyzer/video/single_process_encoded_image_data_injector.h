#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_SINGLE_PROCESS_ENCODED_IMAGE_DATA_INJECTOR_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_SINGLE_PROCESS_ENCODED_IMAGE_DATA_INJECTOR_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
map
>
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
encoded_image_data_injector
.
h
"
namespace
webrtc
{
namespace
webrtc_pc_e2e
{
class
SingleProcessEncodedImageDataInjector
:
public
EncodedImageDataPropagator
{
public
:
SingleProcessEncodedImageDataInjector
(
)
;
~
SingleProcessEncodedImageDataInjector
(
)
override
;
EncodedImage
InjectData
(
uint16_t
id
bool
discard
const
EncodedImage
&
source
)
override
;
void
Start
(
int
expected_receivers_count
)
override
{
MutexLock
crit
(
&
lock_
)
;
expected_receivers_count_
=
expected_receivers_count
;
}
void
AddParticipantInCall
(
)
override
;
void
RemoveParticipantInCall
(
)
override
;
EncodedImageExtractionResult
ExtractData
(
const
EncodedImage
&
source
)
override
;
private
:
struct
ExtractionInfo
{
const
static
size_t
kUsedBufferSize
=
3
;
uint8_t
sub_id
;
bool
discard
;
uint8_t
origin_data
[
ExtractionInfo
:
:
kUsedBufferSize
]
;
int
received_count
=
0
;
}
;
struct
ExtractionInfoVector
{
ExtractionInfoVector
(
)
;
~
ExtractionInfoVector
(
)
;
uint8_t
next_sub_id
=
0
;
std
:
:
map
<
uint8_t
ExtractionInfo
>
infos
;
}
;
Mutex
lock_
;
int
expected_receivers_count_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
map
<
uint16_t
ExtractionInfoVector
>
extraction_cache_
RTC_GUARDED_BY
(
lock_
)
;
}
;
}
}
#
endif
