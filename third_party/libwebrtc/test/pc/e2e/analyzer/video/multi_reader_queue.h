#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_MULTI_READER_QUEUE_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_MULTI_READER_QUEUE_H_
#
include
<
cstddef
>
#
include
<
deque
>
#
include
<
optional
>
#
include
<
set
>
#
include
<
unordered_map
>
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
template
<
typename
T
>
class
MultiReaderQueue
{
public
:
explicit
MultiReaderQueue
(
size_t
readers_count
)
{
for
(
size_t
i
=
0
;
i
<
readers_count
;
+
+
i
)
{
heads_
[
i
]
=
0
;
}
}
explicit
MultiReaderQueue
(
std
:
:
set
<
size_t
>
readers
)
{
for
(
size_t
reader
:
readers
)
{
heads_
[
reader
]
=
0
;
}
}
void
AddReader
(
size_t
reader
size_t
reader_to_copy
)
{
size_t
pos
=
GetHeadPositionOrDie
(
reader_to_copy
)
;
auto
it
=
heads_
.
find
(
reader
)
;
RTC_CHECK
(
it
=
=
heads_
.
end
(
)
)
<
<
"
Reader
"
<
<
reader
<
<
"
is
already
in
the
queue
"
;
heads_
[
reader
]
=
heads_
[
reader_to_copy
]
;
for
(
size_t
i
=
pos
;
i
<
queue_
.
size
(
)
;
+
+
i
)
{
in_queues_
[
i
]
+
+
;
}
}
void
AddReader
(
size_t
reader
)
{
auto
it
=
heads_
.
find
(
reader
)
;
RTC_CHECK
(
it
=
=
heads_
.
end
(
)
)
<
<
"
Reader
"
<
<
reader
<
<
"
is
already
in
the
queue
"
;
heads_
[
reader
]
=
removed_elements_count_
;
for
(
size_t
i
=
0
;
i
<
queue_
.
size
(
)
;
+
+
i
)
{
in_queues_
[
i
]
+
+
;
}
}
void
RemoveReader
(
size_t
reader
)
{
size_t
pos
=
GetHeadPositionOrDie
(
reader
)
;
for
(
size_t
i
=
pos
;
i
<
queue_
.
size
(
)
;
+
+
i
)
{
in_queues_
[
i
]
-
-
;
}
while
(
!
in_queues_
.
empty
(
)
&
&
in_queues_
[
0
]
=
=
0
)
{
PopFront
(
)
;
}
heads_
.
erase
(
reader
)
;
}
void
PushBack
(
T
value
)
{
queue_
.
push_back
(
value
)
;
in_queues_
.
push_back
(
heads_
.
size
(
)
)
;
}
std
:
:
optional
<
T
>
PopFront
(
size_t
reader
)
{
size_t
pos
=
GetHeadPositionOrDie
(
reader
)
;
if
(
pos
>
=
queue_
.
size
(
)
)
{
return
std
:
:
nullopt
;
}
T
out
=
queue_
[
pos
]
;
in_queues_
[
pos
]
-
-
;
heads_
[
reader
]
+
+
;
if
(
in_queues_
[
pos
]
=
=
0
)
{
RTC_DCHECK_EQ
(
pos
0
)
;
PopFront
(
)
;
}
return
out
;
}
std
:
:
optional
<
T
>
Front
(
size_t
reader
)
const
{
size_t
pos
=
GetHeadPositionOrDie
(
reader
)
;
if
(
pos
>
=
queue_
.
size
(
)
)
{
return
std
:
:
nullopt
;
}
return
queue_
[
pos
]
;
}
bool
IsEmpty
(
size_t
reader
)
const
{
size_t
pos
=
GetHeadPositionOrDie
(
reader
)
;
return
pos
>
=
queue_
.
size
(
)
;
}
size_t
size
(
)
const
{
return
queue_
.
size
(
)
;
}
size_t
size
(
size_t
reader
)
const
{
size_t
pos
=
GetHeadPositionOrDie
(
reader
)
;
return
queue_
.
size
(
)
-
pos
;
}
size_t
readers_count
(
)
const
{
return
heads_
.
size
(
)
;
}
private
:
size_t
GetHeadPositionOrDie
(
size_t
reader
)
const
{
auto
it
=
heads_
.
find
(
reader
)
;
RTC_CHECK
(
it
!
=
heads_
.
end
(
)
)
<
<
"
No
queue
for
reader
"
<
<
reader
;
return
it
-
>
second
-
removed_elements_count_
;
}
void
PopFront
(
)
{
RTC_DCHECK
(
!
queue_
.
empty
(
)
)
;
RTC_DCHECK_EQ
(
in_queues_
[
0
]
0
)
;
queue_
.
pop_front
(
)
;
in_queues_
.
pop_front
(
)
;
removed_elements_count_
+
+
;
}
size_t
removed_elements_count_
=
0
;
std
:
:
deque
<
T
>
queue_
;
std
:
:
deque
<
size_t
>
in_queues_
;
std
:
:
unordered_map
<
size_t
size_t
>
heads_
;
}
;
}
#
endif
