#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_FRAME_IN_FLIGHT_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_FRAME_IN_FLIGHT_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
map
>
#
include
<
optional
>
#
include
<
set
>
#
include
<
unordered_map
>
#
include
<
vector
>
#
include
"
api
/
numerics
/
samples_stats_counter
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
default_video_quality_analyzer_internal_shared_objects
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
default_video_quality_analyzer_shared_objects
.
h
"
namespace
webrtc
{
struct
ReceiverFrameStats
{
Timestamp
received_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_start_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_end_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
rendered_time
=
Timestamp
:
:
MinusInfinity
(
)
;
std
:
:
optional
<
Timestamp
>
prev_frame_rendered_time
=
std
:
:
nullopt
;
std
:
:
optional
<
TimeDelta
>
time_between_rendered_frames
=
std
:
:
nullopt
;
VideoFrameType
frame_type
=
VideoFrameType
:
:
kEmptyFrame
;
DataSize
encoded_image_size
=
DataSize
:
:
Bytes
(
0
)
;
std
:
:
optional
<
int
>
decoded_frame_width
=
std
:
:
nullopt
;
std
:
:
optional
<
int
>
decoded_frame_height
=
std
:
:
nullopt
;
std
:
:
optional
<
uint8_t
>
decoded_frame_qp
=
std
:
:
nullopt
;
std
:
:
optional
<
StreamCodecInfo
>
used_decoder
=
std
:
:
nullopt
;
bool
dropped
=
false
;
bool
decoder_failed
=
false
;
bool
superfluous
=
false
;
}
;
class
FrameInFlight
{
public
:
FrameInFlight
(
size_t
stream
uint16_t
frame_id
Timestamp
captured_time
std
:
:
optional
<
TimeDelta
>
time_between_captured_frames
std
:
:
set
<
size_t
>
expected_receivers
)
;
size_t
stream
(
)
const
{
return
stream_
;
}
uint16_t
id
(
)
const
{
return
frame_id_
;
}
Timestamp
captured_time
(
)
const
{
return
captured_time_
;
}
void
AddExpectedReceiver
(
size_t
peer
)
{
expected_receivers_
.
insert
(
peer
)
;
}
void
RemoveExpectedReceiver
(
size_t
peer
)
{
expected_receivers_
.
erase
(
peer
)
;
}
std
:
:
vector
<
size_t
>
GetPeersWhichDidntReceive
(
)
const
;
bool
HaveAllPeersReceived
(
)
const
;
void
SetPreEncodeTime
(
Timestamp
time
)
{
pre_encode_time_
=
time
;
}
void
OnFrameEncoded
(
Timestamp
time
std
:
:
optional
<
TimeDelta
>
time_between_encoded_frames
VideoFrameType
frame_type
DataSize
encoded_image_size
uint32_t
target_encode_bitrate
int
stream_index
int
qp
StreamCodecInfo
used_encoder
)
;
bool
HasEncodedTime
(
)
const
{
return
encoded_time_
.
IsFinite
(
)
;
}
void
OnFramePreDecode
(
size_t
peer
Timestamp
received_time
Timestamp
decode_start_time
VideoFrameType
frame_type
DataSize
encoded_image_size
)
;
bool
HasReceivedTime
(
size_t
peer
)
const
;
void
OnFrameDecoded
(
size_t
peer
Timestamp
time
int
width
int
height
const
StreamCodecInfo
&
used_decoder
const
std
:
:
optional
<
uint8_t
>
qp
)
;
void
OnDecoderError
(
size_t
peer
const
StreamCodecInfo
&
used_decoder
)
;
bool
HasDecodeEndTime
(
size_t
peer
)
const
;
void
OnFrameRendered
(
size_t
peer
Timestamp
time
)
;
bool
HasRenderedTime
(
size_t
peer
)
const
;
Timestamp
rendered_time
(
size_t
peer
)
const
{
return
receiver_stats_
.
at
(
peer
)
.
rendered_time
;
}
void
MarkDropped
(
size_t
peer
)
{
receiver_stats_
[
peer
]
.
dropped
=
true
;
}
bool
IsDropped
(
size_t
peer
)
const
;
void
MarkSuperfluous
(
size_t
peer
)
{
receiver_stats_
[
peer
]
.
superfluous
=
true
;
}
bool
IsSuperfluous
(
size_t
peer
)
const
;
void
SetPrevFrameRenderedTime
(
size_t
peer
webrtc
:
:
Timestamp
time
)
{
receiver_stats_
[
peer
]
.
prev_frame_rendered_time
=
time
;
}
void
SetTimeBetweenRenderedFrames
(
size_t
peer
TimeDelta
time
)
{
receiver_stats_
[
peer
]
.
time_between_rendered_frames
=
time
;
}
FrameStats
GetStatsForPeer
(
size_t
peer
)
const
;
private
:
const
size_t
stream_
;
std
:
:
set
<
size_t
>
expected_receivers_
;
uint16_t
frame_id_
=
VideoFrame
:
:
kNotSetId
;
Timestamp
captured_time_
;
Timestamp
pre_encode_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
encoded_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
std
:
:
optional
<
TimeDelta
>
time_between_captured_frames_
=
std
:
:
nullopt
;
std
:
:
optional
<
TimeDelta
>
time_between_encoded_frames_
=
std
:
:
nullopt
;
VideoFrameType
frame_type_
=
VideoFrameType
:
:
kEmptyFrame
;
DataSize
encoded_image_size_
=
DataSize
:
:
Bytes
(
0
)
;
uint32_t
target_encode_bitrate_
=
0
;
std
:
:
map
<
int
SamplesStatsCounter
>
stream_layers_qp_
;
std
:
:
optional
<
StreamCodecInfo
>
used_encoder_
=
std
:
:
nullopt
;
std
:
:
unordered_map
<
size_t
ReceiverFrameStats
>
receiver_stats_
;
}
;
}
#
endif
