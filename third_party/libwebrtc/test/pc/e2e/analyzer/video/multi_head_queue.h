#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_MULTI_HEAD_QUEUE_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_MULTI_HEAD_QUEUE_H_
#
include
<
deque
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
template
<
typename
T
>
class
MultiHeadQueue
{
public
:
explicit
MultiHeadQueue
(
size_t
readers_count
)
{
for
(
size_t
i
=
0
;
i
<
readers_count
;
+
+
i
)
{
queues_
.
push_back
(
std
:
:
deque
<
T
>
(
)
)
;
}
}
void
AddHead
(
size_t
copy_index
)
{
queues_
.
push_back
(
queues_
[
copy_index
]
)
;
}
void
PushBack
(
T
value
)
{
for
(
auto
&
queue
:
queues_
)
{
queue
.
push_back
(
value
)
;
}
}
absl
:
:
optional
<
T
>
PopFront
(
size_t
index
)
{
RTC_CHECK_LT
(
index
queues_
.
size
(
)
)
;
if
(
queues_
[
index
]
.
empty
(
)
)
{
return
absl
:
:
nullopt
;
}
T
out
=
queues_
[
index
]
.
front
(
)
;
queues_
[
index
]
.
pop_front
(
)
;
return
out
;
}
absl
:
:
optional
<
T
>
Front
(
size_t
index
)
const
{
RTC_CHECK_LT
(
index
queues_
.
size
(
)
)
;
if
(
queues_
[
index
]
.
empty
(
)
)
{
return
absl
:
:
nullopt
;
}
return
queues_
[
index
]
.
front
(
)
;
}
bool
IsEmpty
(
size_t
index
)
const
{
RTC_CHECK_LT
(
index
queues_
.
size
(
)
)
;
return
queues_
[
index
]
.
empty
(
)
;
}
size_t
size
(
)
const
{
size_t
size
=
0
;
for
(
auto
&
queue
:
queues_
)
{
if
(
queue
.
size
(
)
>
size
)
{
size
=
queue
.
size
(
)
;
}
}
return
size
;
}
size_t
size
(
size_t
index
)
const
{
RTC_CHECK_LT
(
index
queues_
.
size
(
)
)
;
return
queues_
[
index
]
.
size
(
)
;
}
size_t
readers_count
(
)
const
{
return
queues_
.
size
(
)
;
}
private
:
std
:
:
vector
<
std
:
:
deque
<
T
>
>
queues_
;
}
;
}
#
endif
