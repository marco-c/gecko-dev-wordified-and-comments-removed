#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_INTERNAL_SHARED_OBJECTS_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_INTERNAL_SHARED_OBJECTS_H_
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
numerics
/
samples_stats_counter
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
default_video_quality_analyzer_shared_objects
.
h
"
namespace
webrtc
{
struct
InternalStatsKey
{
InternalStatsKey
(
size_t
stream
size_t
sender
size_t
receiver
)
:
stream
(
stream
)
sender
(
sender
)
receiver
(
receiver
)
{
}
std
:
:
string
ToString
(
)
const
;
size_t
stream
;
size_t
sender
;
size_t
receiver
;
}
;
bool
operator
<
(
const
InternalStatsKey
&
a
const
InternalStatsKey
&
b
)
;
bool
operator
=
=
(
const
InternalStatsKey
&
a
const
InternalStatsKey
&
b
)
;
struct
FrameStats
{
FrameStats
(
uint16_t
frame_id
Timestamp
captured_time
)
:
frame_id
(
frame_id
)
captured_time
(
captured_time
)
{
}
uint16_t
frame_id
;
Timestamp
captured_time
;
Timestamp
pre_encode_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
encoded_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
received_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_start_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_end_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
rendered_time
=
Timestamp
:
:
MinusInfinity
(
)
;
std
:
:
optional
<
Timestamp
>
prev_frame_rendered_time
=
std
:
:
nullopt
;
std
:
:
optional
<
TimeDelta
>
time_between_captured_frames
=
std
:
:
nullopt
;
std
:
:
optional
<
TimeDelta
>
time_between_encoded_frames
=
std
:
:
nullopt
;
std
:
:
optional
<
TimeDelta
>
time_between_rendered_frames
=
std
:
:
nullopt
;
VideoFrameType
encoded_frame_type
=
VideoFrameType
:
:
kEmptyFrame
;
DataSize
encoded_image_size
=
DataSize
:
:
Bytes
(
0
)
;
VideoFrameType
pre_decoded_frame_type
=
VideoFrameType
:
:
kEmptyFrame
;
DataSize
pre_decoded_image_size
=
DataSize
:
:
Bytes
(
0
)
;
uint32_t
target_encode_bitrate
=
0
;
std
:
:
map
<
int
SamplesStatsCounter
>
spatial_layers_qp
;
std
:
:
optional
<
uint8_t
>
decoded_frame_qp
=
std
:
:
nullopt
;
std
:
:
optional
<
int
>
decoded_frame_width
=
std
:
:
nullopt
;
std
:
:
optional
<
int
>
decoded_frame_height
=
std
:
:
nullopt
;
std
:
:
optional
<
StreamCodecInfo
>
used_encoder
=
std
:
:
nullopt
;
std
:
:
optional
<
StreamCodecInfo
>
used_decoder
=
std
:
:
nullopt
;
bool
decoder_failed
=
false
;
}
;
enum
class
OverloadReason
{
kNone
kCpu
kMemory
}
;
enum
class
FrameComparisonType
{
kRegular
kDroppedFrame
kFrameInFlight
}
;
struct
FrameComparison
{
FrameComparison
(
InternalStatsKey
stats_key
std
:
:
optional
<
VideoFrame
>
captured
std
:
:
optional
<
VideoFrame
>
rendered
FrameComparisonType
type
FrameStats
frame_stats
OverloadReason
overload_reason
)
;
InternalStatsKey
stats_key
;
std
:
:
optional
<
VideoFrame
>
captured
;
std
:
:
optional
<
VideoFrame
>
rendered
;
FrameComparisonType
type
;
FrameStats
frame_stats
;
OverloadReason
overload_reason
;
}
;
}
#
endif
