#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_ANALYZING_VIDEO_SINK_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_ANALYZING_VIDEO_SINK_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
numerics
/
samples_stats_counter
.
h
"
#
include
"
api
/
test
/
metrics
/
metrics_logger
.
h
"
#
include
"
api
/
test
/
pclf
/
media_configuration
.
h
"
#
include
"
api
/
test
/
video
/
video_frame_writer
.
h
"
#
include
"
api
/
test
/
video_quality_analyzer_interface
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
analyzing_video_sinks_helper
.
h
"
namespace
webrtc
{
namespace
webrtc_pc_e2e
{
class
AnalyzingVideoSink
:
public
VideoSinkInterface
<
VideoFrame
>
{
public
:
struct
Stats
{
SamplesStatsCounter
scaling_tims_ms
;
SamplesStatsCounter
analyzing_sink_processing_time_ms
;
}
;
AnalyzingVideoSink
(
absl
:
:
string_view
peer_name
Clock
*
clock
VideoQualityAnalyzerInterface
&
analyzer
AnalyzingVideoSinksHelper
&
sinks_helper
const
VideoSubscription
&
subscription
bool
report_infra_stats
)
;
void
UpdateSubscription
(
const
VideoSubscription
&
subscription
)
;
void
OnFrame
(
const
VideoFrame
&
frame
)
override
;
void
LogMetrics
(
webrtc
:
:
test
:
:
MetricsLogger
&
metrics_logger
absl
:
:
string_view
test_case_name
)
const
;
Stats
stats
(
)
const
;
private
:
struct
SinksDescriptor
{
SinksDescriptor
(
absl
:
:
string_view
sender_peer_name
const
VideoResolution
&
resolution
)
:
sender_peer_name
(
sender_peer_name
)
resolution
(
resolution
)
{
}
std
:
:
string
sender_peer_name
;
VideoResolution
resolution
;
test
:
:
VideoFrameWriter
*
video_frame_writer
=
nullptr
;
std
:
:
vector
<
std
:
:
unique_ptr
<
VideoSinkInterface
<
VideoFrame
>
>
>
sinks
;
}
;
VideoFrame
ScaleVideoFrame
(
const
VideoFrame
&
frame
const
VideoResolution
&
required_resolution
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
AnalyzeFrame
(
const
VideoFrame
&
frame
)
;
SinksDescriptor
*
PopulateSinks
(
absl
:
:
string_view
stream_label
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
const
std
:
:
string
peer_name_
;
const
bool
report_infra_stats_
;
Clock
*
const
clock_
;
VideoQualityAnalyzerInterface
*
const
analyzer_
;
AnalyzingVideoSinksHelper
*
const
sinks_helper_
;
mutable
Mutex
mutex_
;
VideoSubscription
subscription_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
map
<
std
:
:
string
SinksDescriptor
>
stream_sinks_
RTC_GUARDED_BY
(
mutex_
)
;
Stats
stats_
RTC_GUARDED_BY
(
mutex_
)
;
}
;
}
}
#
endif
