#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_STREAM_STATE_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_STREAM_STATE_H_
#
include
<
map
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
multi_reader_queue
.
h
"
namespace
webrtc
{
class
StreamState
{
public
:
StreamState
(
size_t
owner
size_t
peers_count
bool
enable_receive_own_stream
Timestamp
stream_started_time
)
:
owner_
(
owner
)
enable_receive_own_stream_
(
enable_receive_own_stream
)
stream_started_time_
(
stream_started_time
)
frame_ids_
(
enable_receive_own_stream
?
peers_count
+
1
:
peers_count
)
{
}
size_t
owner
(
)
const
{
return
owner_
;
}
Timestamp
stream_started_time
(
)
const
{
return
stream_started_time_
;
}
void
PushBack
(
uint16_t
frame_id
)
{
frame_ids_
.
PushBack
(
frame_id
)
;
}
uint16_t
PopFront
(
size_t
peer
)
;
bool
IsEmpty
(
size_t
peer
)
const
{
return
frame_ids_
.
IsEmpty
(
GetPeerQueueIndex
(
peer
)
)
;
}
uint16_t
Front
(
size_t
peer
)
const
{
return
frame_ids_
.
Front
(
GetPeerQueueIndex
(
peer
)
)
.
value
(
)
;
}
void
AddPeer
(
)
{
frame_ids_
.
AddReader
(
GetAliveFramesQueueIndex
(
)
)
;
}
size_t
GetAliveFramesCount
(
)
const
{
return
frame_ids_
.
size
(
GetAliveFramesQueueIndex
(
)
)
;
}
uint16_t
MarkNextAliveFrameAsDead
(
)
;
void
SetLastRenderedFrameTime
(
size_t
peer
Timestamp
time
)
;
absl
:
:
optional
<
Timestamp
>
last_rendered_frame_time
(
size_t
peer
)
const
;
private
:
size_t
GetPeerQueueIndex
(
size_t
peer_index
)
const
;
size_t
GetAliveFramesQueueIndex
(
)
const
;
const
size_t
owner_
;
const
bool
enable_receive_own_stream_
;
const
Timestamp
stream_started_time_
;
MultiReaderQueue
<
uint16_t
>
frame_ids_
;
std
:
:
map
<
size_t
Timestamp
>
last_rendered_frame_time_
;
}
;
}
#
endif
