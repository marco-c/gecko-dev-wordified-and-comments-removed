#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_STREAM_STATE_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_STREAM_STATE_H_
#
include
<
limits
>
#
include
<
set
>
#
include
<
unordered_map
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
dvqa
/
pausable_state
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
multi_reader_queue
.
h
"
namespace
webrtc
{
class
StreamState
{
public
:
StreamState
(
size_t
sender
std
:
:
set
<
size_t
>
receivers
Timestamp
stream_started_time
Clock
*
clock
)
;
size_t
sender
(
)
const
{
return
sender_
;
}
Timestamp
stream_started_time
(
)
const
{
return
stream_started_time_
;
}
void
PushBack
(
uint16_t
frame_id
)
{
frame_ids_
.
PushBack
(
frame_id
)
;
}
uint16_t
PopFront
(
size_t
peer
)
;
bool
IsEmpty
(
size_t
peer
)
const
{
return
frame_ids_
.
IsEmpty
(
peer
)
;
}
uint16_t
Front
(
size_t
peer
)
const
{
return
frame_ids_
.
Front
(
peer
)
.
value
(
)
;
}
void
AddPeer
(
size_t
peer
)
;
void
RemovePeer
(
size_t
peer
)
;
PausableState
*
GetPausableState
(
size_t
peer
)
;
size_t
GetAliveFramesCount
(
)
const
{
return
frame_ids_
.
size
(
kAliveFramesQueueIndex
)
;
}
uint16_t
MarkNextAliveFrameAsDead
(
)
;
void
SetLastRenderedFrameTime
(
size_t
peer
Timestamp
time
)
;
absl
:
:
optional
<
Timestamp
>
last_rendered_frame_time
(
size_t
peer
)
const
;
private
:
static
constexpr
size_t
kAliveFramesQueueIndex
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
size_t
GetLongestReceiverQueue
(
)
const
;
const
size_t
sender_
;
const
Timestamp
stream_started_time_
;
Clock
*
const
clock_
;
std
:
:
set
<
size_t
>
receivers_
;
MultiReaderQueue
<
uint16_t
>
frame_ids_
;
std
:
:
unordered_map
<
size_t
Timestamp
>
last_rendered_frame_time_
;
std
:
:
unordered_map
<
size_t
PausableState
>
pausable_state_
;
}
;
}
#
endif
