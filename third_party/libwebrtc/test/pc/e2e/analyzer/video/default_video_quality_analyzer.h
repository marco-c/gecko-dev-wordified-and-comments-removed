#
ifndef
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_H_
#
define
TEST_PC_E2E_ANALYZER_VIDEO_DEFAULT_VIDEO_QUALITY_ANALYZER_H_
#
include
<
atomic
>
#
include
<
deque
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
numerics
/
samples_stats_counter
.
h
"
#
include
"
api
/
test
/
video_quality_analyzer_interface
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
pc
/
e2e
/
analyzer
/
video
/
multi_head_queue
.
h
"
#
include
"
test
/
testsupport
/
perf_test
.
h
"
namespace
webrtc
{
namespace
webrtc_pc_e2e
{
constexpr
size_t
kDefaultMaxFramesInFlightPerStream
=
270
;
class
RateCounter
{
public
:
void
AddEvent
(
Timestamp
event_time
)
;
bool
IsEmpty
(
)
const
{
return
event_first_time_
=
=
event_last_time_
;
}
double
GetEventsPerSecond
(
)
const
;
private
:
Timestamp
event_first_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
event_last_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
int64_t
event_count_
=
0
;
}
;
struct
FrameCounters
{
int64_t
captured
=
0
;
int64_t
pre_encoded
=
0
;
int64_t
encoded
=
0
;
int64_t
received
=
0
;
int64_t
decoded
=
0
;
int64_t
rendered
=
0
;
int64_t
dropped
=
0
;
}
;
struct
StreamStats
{
SamplesStatsCounter
psnr
;
SamplesStatsCounter
ssim
;
SamplesStatsCounter
transport_time_ms
;
SamplesStatsCounter
total_delay_incl_transport_ms
;
SamplesStatsCounter
time_between_rendered_frames_ms
;
RateCounter
encode_frame_rate
;
SamplesStatsCounter
encode_time_ms
;
SamplesStatsCounter
decode_time_ms
;
SamplesStatsCounter
receive_to_render_time_ms
;
SamplesStatsCounter
skipped_between_rendered
;
SamplesStatsCounter
freeze_time_ms
;
SamplesStatsCounter
time_between_freezes_ms
;
SamplesStatsCounter
resolution_of_rendered_frame
;
SamplesStatsCounter
target_encode_bitrate
;
int64_t
total_encoded_images_payload
=
0
;
int64_t
dropped_by_encoder
=
0
;
int64_t
dropped_before_encoder
=
0
;
}
;
struct
AnalyzerStats
{
SamplesStatsCounter
comparisons_queue_size
;
int64_t
comparisons_done
=
0
;
int64_t
cpu_overloaded_comparisons_done
=
0
;
int64_t
memory_overloaded_comparisons_done
=
0
;
SamplesStatsCounter
frames_in_flight_left_count
;
}
;
struct
StatsKey
{
StatsKey
(
std
:
:
string
stream_label
std
:
:
string
sender
std
:
:
string
receiver
)
:
stream_label
(
std
:
:
move
(
stream_label
)
)
sender
(
std
:
:
move
(
sender
)
)
receiver
(
std
:
:
move
(
receiver
)
)
{
}
std
:
:
string
ToString
(
)
const
;
std
:
:
string
stream_label
;
std
:
:
string
sender
;
std
:
:
string
receiver
;
}
;
bool
operator
<
(
const
StatsKey
&
a
const
StatsKey
&
b
)
;
bool
operator
=
=
(
const
StatsKey
&
a
const
StatsKey
&
b
)
;
struct
InternalStatsKey
{
InternalStatsKey
(
size_t
stream
size_t
sender
size_t
receiver
)
:
stream
(
stream
)
sender
(
sender
)
receiver
(
receiver
)
{
}
std
:
:
string
ToString
(
)
const
;
size_t
stream
;
size_t
sender
;
size_t
receiver
;
}
;
bool
operator
<
(
const
InternalStatsKey
&
a
const
InternalStatsKey
&
b
)
;
bool
operator
=
=
(
const
InternalStatsKey
&
a
const
InternalStatsKey
&
b
)
;
struct
DefaultVideoQualityAnalyzerOptions
{
bool
heavy_metrics_computation_enabled
=
true
;
bool
adjust_cropping_before_comparing_frames
=
false
;
size_t
max_frames_in_flight_per_stream_count
=
kDefaultMaxFramesInFlightPerStream
;
}
;
class
DefaultVideoQualityAnalyzer
:
public
VideoQualityAnalyzerInterface
{
public
:
explicit
DefaultVideoQualityAnalyzer
(
webrtc
:
:
Clock
*
clock
DefaultVideoQualityAnalyzerOptions
options
=
DefaultVideoQualityAnalyzerOptions
(
)
)
;
~
DefaultVideoQualityAnalyzer
(
)
override
;
void
Start
(
std
:
:
string
test_case_name
rtc
:
:
ArrayView
<
const
std
:
:
string
>
peer_names
int
max_threads_count
)
override
;
uint16_t
OnFrameCaptured
(
absl
:
:
string_view
peer_name
const
std
:
:
string
&
stream_label
const
VideoFrame
&
frame
)
override
;
void
OnFramePreEncode
(
absl
:
:
string_view
peer_name
const
VideoFrame
&
frame
)
override
;
void
OnFrameEncoded
(
absl
:
:
string_view
peer_name
uint16_t
frame_id
const
EncodedImage
&
encoded_image
const
EncoderStats
&
stats
)
override
;
void
OnFrameDropped
(
absl
:
:
string_view
peer_name
EncodedImageCallback
:
:
DropReason
reason
)
override
;
void
OnFramePreDecode
(
absl
:
:
string_view
peer_name
uint16_t
frame_id
const
EncodedImage
&
input_image
)
override
;
void
OnFrameDecoded
(
absl
:
:
string_view
peer_name
const
VideoFrame
&
frame
const
DecoderStats
&
stats
)
override
;
void
OnFrameRendered
(
absl
:
:
string_view
peer_name
const
VideoFrame
&
frame
)
override
;
void
OnEncoderError
(
absl
:
:
string_view
peer_name
const
VideoFrame
&
frame
int32_t
error_code
)
override
;
void
OnDecoderError
(
absl
:
:
string_view
peer_name
uint16_t
frame_id
int32_t
error_code
)
override
;
void
Stop
(
)
override
;
std
:
:
string
GetStreamLabel
(
uint16_t
frame_id
)
override
;
void
OnStatsReports
(
absl
:
:
string_view
pc_label
const
rtc
:
:
scoped_refptr
<
const
RTCStatsReport
>
&
report
)
override
{
}
std
:
:
set
<
StatsKey
>
GetKnownVideoStreams
(
)
const
;
const
FrameCounters
&
GetGlobalCounters
(
)
const
;
std
:
:
map
<
StatsKey
FrameCounters
>
GetPerStreamCounters
(
)
const
;
std
:
:
map
<
StatsKey
StreamStats
>
GetStats
(
)
const
;
AnalyzerStats
GetAnalyzerStats
(
)
const
;
private
:
struct
FrameStats
{
FrameStats
(
Timestamp
captured_time
)
:
captured_time
(
captured_time
)
{
}
Timestamp
captured_time
;
Timestamp
pre_encode_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
encoded_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
received_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_start_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_end_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
rendered_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
prev_frame_rendered_time
=
Timestamp
:
:
MinusInfinity
(
)
;
int64_t
encoded_image_size
=
0
;
uint32_t
target_encode_bitrate
=
0
;
absl
:
:
optional
<
int
>
rendered_frame_width
=
absl
:
:
nullopt
;
absl
:
:
optional
<
int
>
rendered_frame_height
=
absl
:
:
nullopt
;
}
;
enum
class
OverloadReason
{
kNone
kCpu
kMemory
}
;
struct
FrameComparison
{
FrameComparison
(
InternalStatsKey
stats_key
absl
:
:
optional
<
VideoFrame
>
captured
absl
:
:
optional
<
VideoFrame
>
rendered
bool
dropped
FrameStats
frame_stats
OverloadReason
overload_reason
)
;
InternalStatsKey
stats_key
;
absl
:
:
optional
<
VideoFrame
>
captured
;
absl
:
:
optional
<
VideoFrame
>
rendered
;
bool
dropped
;
FrameStats
frame_stats
;
OverloadReason
overload_reason
;
}
;
class
StreamState
{
public
:
StreamState
(
size_t
owner
size_t
peers_count
)
:
owner_
(
owner
)
frame_ids_
(
peers_count
)
{
}
size_t
owner
(
)
const
{
return
owner_
;
}
void
PushBack
(
uint16_t
frame_id
)
{
frame_ids_
.
PushBack
(
frame_id
)
;
}
uint16_t
PopFront
(
size_t
peer
)
;
bool
IsEmpty
(
size_t
peer
)
const
{
return
frame_ids_
.
IsEmpty
(
peer
)
;
}
uint16_t
Front
(
size_t
peer
)
const
{
return
frame_ids_
.
Front
(
peer
)
.
value
(
)
;
}
size_t
GetAliveFramesCount
(
)
{
return
frame_ids_
.
size
(
owner_
)
;
}
uint16_t
MarkNextAliveFrameAsDead
(
)
;
void
SetLastRenderedFrameTime
(
size_t
peer
Timestamp
time
)
;
absl
:
:
optional
<
Timestamp
>
last_rendered_frame_time
(
size_t
peer
)
const
;
private
:
const
size_t
owner_
;
MultiHeadQueue
<
uint16_t
>
frame_ids_
;
std
:
:
map
<
size_t
Timestamp
>
last_rendered_frame_time_
;
}
;
enum
State
{
kNew
kActive
kStopped
}
;
struct
ReceiverFrameStats
{
Timestamp
received_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_start_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
decode_end_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
rendered_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
prev_frame_rendered_time
=
Timestamp
:
:
MinusInfinity
(
)
;
absl
:
:
optional
<
int
>
rendered_frame_width
=
absl
:
:
nullopt
;
absl
:
:
optional
<
int
>
rendered_frame_height
=
absl
:
:
nullopt
;
bool
dropped
=
false
;
}
;
class
FrameInFlight
{
public
:
FrameInFlight
(
size_t
stream
VideoFrame
frame
Timestamp
captured_time
size_t
owner
size_t
peers_count
)
:
stream_
(
stream
)
owner_
(
owner
)
peers_count_
(
peers_count
)
frame_
(
std
:
:
move
(
frame
)
)
captured_time_
(
captured_time
)
{
}
size_t
stream
(
)
const
{
return
stream_
;
}
const
absl
:
:
optional
<
VideoFrame
>
&
frame
(
)
const
{
return
frame_
;
}
bool
RemoveFrame
(
)
;
void
SetFrameId
(
uint16_t
id
)
;
std
:
:
vector
<
size_t
>
GetPeersWhichDidntReceive
(
)
const
;
bool
HaveAllPeersReceived
(
)
const
;
void
SetPreEncodeTime
(
webrtc
:
:
Timestamp
time
)
{
pre_encode_time_
=
time
;
}
void
OnFrameEncoded
(
webrtc
:
:
Timestamp
time
int64_t
encoded_image_size
uint32_t
target_encode_bitrate
)
;
bool
HasEncodedTime
(
)
const
{
return
encoded_time_
.
IsFinite
(
)
;
}
void
OnFramePreDecode
(
size_t
peer
webrtc
:
:
Timestamp
received_time
webrtc
:
:
Timestamp
decode_start_time
)
;
bool
HasReceivedTime
(
size_t
peer
)
const
;
void
SetDecodeEndTime
(
size_t
peer
webrtc
:
:
Timestamp
time
)
{
receiver_stats_
[
peer
]
.
decode_end_time
=
time
;
}
bool
HasDecodeEndTime
(
size_t
peer
)
const
;
void
OnFrameRendered
(
size_t
peer
webrtc
:
:
Timestamp
time
int
width
int
height
)
;
bool
HasRenderedTime
(
size_t
peer
)
const
;
webrtc
:
:
Timestamp
rendered_time
(
size_t
peer
)
const
{
return
receiver_stats_
.
at
(
peer
)
.
rendered_time
;
}
void
MarkDropped
(
size_t
peer
)
{
receiver_stats_
[
peer
]
.
dropped
=
true
;
}
void
SetPrevFrameRenderedTime
(
size_t
peer
webrtc
:
:
Timestamp
time
)
{
receiver_stats_
[
peer
]
.
prev_frame_rendered_time
=
time
;
}
FrameStats
GetStatsForPeer
(
size_t
peer
)
const
;
private
:
const
size_t
stream_
;
const
size_t
owner_
;
const
size_t
peers_count_
;
absl
:
:
optional
<
VideoFrame
>
frame_
;
Timestamp
captured_time_
;
Timestamp
pre_encode_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
encoded_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
int64_t
encoded_image_size_
=
0
;
uint32_t
target_encode_bitrate_
=
0
;
std
:
:
map
<
size_t
ReceiverFrameStats
>
receiver_stats_
;
}
;
class
NamesCollection
{
public
:
NamesCollection
(
)
=
default
;
explicit
NamesCollection
(
rtc
:
:
ArrayView
<
const
std
:
:
string
>
names
)
{
names_
=
std
:
:
vector
<
std
:
:
string
>
(
names
.
begin
(
)
names
.
end
(
)
)
;
for
(
size_t
i
=
0
;
i
<
names_
.
size
(
)
;
+
+
i
)
{
index_
.
emplace
(
names_
[
i
]
i
)
;
}
}
size_t
size
(
)
const
{
return
names_
.
size
(
)
;
}
size_t
index
(
absl
:
:
string_view
name
)
const
{
return
index_
.
at
(
name
)
;
}
const
std
:
:
string
&
name
(
size_t
index
)
const
{
return
names_
[
index
]
;
}
bool
HasName
(
absl
:
:
string_view
name
)
const
{
return
index_
.
find
(
name
)
!
=
index_
.
end
(
)
;
}
size_t
AddIfAbsent
(
absl
:
:
string_view
name
)
;
private
:
std
:
:
vector
<
std
:
:
string
>
names_
;
std
:
:
map
<
absl
:
:
string_view
size_t
>
index_
;
}
;
void
AddComparison
(
InternalStatsKey
stats_key
absl
:
:
optional
<
VideoFrame
>
captured
absl
:
:
optional
<
VideoFrame
>
rendered
bool
dropped
FrameStats
frame_stats
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
comparison_lock_
)
;
static
void
ProcessComparisonsThread
(
void
*
obj
)
;
void
ProcessComparisons
(
)
;
void
ProcessComparison
(
const
FrameComparison
&
comparison
)
;
void
ReportResults
(
)
;
void
ReportResults
(
const
std
:
:
string
&
test_case_name
const
StreamStats
&
stats
const
FrameCounters
&
frame_counters
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
static
void
ReportResult
(
const
std
:
:
string
&
metric_name
const
std
:
:
string
&
test_case_name
const
SamplesStatsCounter
&
counter
const
std
:
:
string
&
unit
webrtc
:
:
test
:
:
ImproveDirection
improve_direction
=
webrtc
:
:
test
:
:
ImproveDirection
:
:
kNone
)
;
std
:
:
string
GetTestCaseName
(
const
std
:
:
string
&
stream_label
)
const
;
Timestamp
Now
(
)
;
StatsKey
ToStatsKey
(
const
InternalStatsKey
&
key
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
std
:
:
string
StatsKeyToMetricName
(
const
StatsKey
&
key
)
;
void
StartMeasuringCpuProcessTime
(
)
;
void
StopMeasuringCpuProcessTime
(
)
;
void
StartExcludingCpuThreadTime
(
)
;
void
StopExcludingCpuThreadTime
(
)
;
double
GetCpuUsagePercent
(
)
;
DefaultVideoQualityAnalyzerOptions
options_
;
webrtc
:
:
Clock
*
const
clock_
;
std
:
:
atomic
<
uint16_t
>
next_frame_id_
{
0
}
;
std
:
:
string
test_label_
;
std
:
:
unique_ptr
<
NamesCollection
>
peers_
;
mutable
Mutex
lock_
;
State
state_
RTC_GUARDED_BY
(
lock_
)
=
State
:
:
kNew
;
Timestamp
start_time_
RTC_GUARDED_BY
(
lock_
)
=
Timestamp
:
:
MinusInfinity
(
)
;
NamesCollection
streams_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
map
<
uint16_t
FrameInFlight
>
captured_frames_in_flight_
RTC_GUARDED_BY
(
lock_
)
;
FrameCounters
frame_counters_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
map
<
InternalStatsKey
FrameCounters
>
stream_frame_counters_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
map
<
size_t
StreamState
>
stream_states_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
map
<
size_t
size_t
>
stream_to_sender_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
map
<
size_t
std
:
:
set
<
uint16_t
>
>
stream_to_frame_id_history_
RTC_GUARDED_BY
(
lock_
)
;
mutable
Mutex
comparison_lock_
;
std
:
:
map
<
InternalStatsKey
StreamStats
>
stream_stats_
RTC_GUARDED_BY
(
comparison_lock_
)
;
std
:
:
map
<
InternalStatsKey
Timestamp
>
stream_last_freeze_end_time_
RTC_GUARDED_BY
(
comparison_lock_
)
;
std
:
:
deque
<
FrameComparison
>
comparisons_
RTC_GUARDED_BY
(
comparison_lock_
)
;
AnalyzerStats
analyzer_stats_
RTC_GUARDED_BY
(
comparison_lock_
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
rtc
:
:
PlatformThread
>
>
thread_pool_
;
rtc
:
:
Event
comparison_available_event_
;
Mutex
cpu_measurement_lock_
;
int64_t
cpu_time_
RTC_GUARDED_BY
(
cpu_measurement_lock_
)
=
0
;
int64_t
wallclock_time_
RTC_GUARDED_BY
(
cpu_measurement_lock_
)
=
0
;
}
;
}
}
#
endif
