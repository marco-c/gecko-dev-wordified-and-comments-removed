#
include
<
cmath
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
pcm16b
/
audio_encoder_pcm16b
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
audio_checksum
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
encode_neteq_input
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
neteq_test
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
test
/
fuzzers
/
fuzz_data_helper
.
h
"
namespace
webrtc
{
namespace
test
{
namespace
{
class
SineAndNoiseGenerator
:
public
EncodeNetEqInput
:
:
Generator
{
public
:
SineAndNoiseGenerator
(
int
sample_rate_hz
FuzzDataHelper
*
fuzz_data
)
:
sample_rate_hz_
(
sample_rate_hz
)
fuzz_data_
(
*
fuzz_data
)
noise_generator_
(
fuzz_data_
.
ReadOrDefaultValueNotZero
<
uint64_t
>
(
1
)
)
{
}
rtc
:
:
ArrayView
<
const
int16_t
>
Generate
(
size_t
num_samples
)
override
{
if
(
samples_
.
size
(
)
<
num_samples
)
{
samples_
.
resize
(
num_samples
)
;
}
rtc
:
:
ArrayView
<
int16_t
>
output
(
samples_
.
data
(
)
num_samples
)
;
const
float
amplitude
=
fuzz_data_
.
ReadOrDefaultValue
<
uint16_t
>
(
65000
)
/
2
;
const
float
noise_std
=
fuzz_data_
.
ReadOrDefaultValue
<
uint16_t
>
(
0
)
%
2000
;
for
(
auto
&
x
:
output
)
{
x
=
rtc
:
:
saturated_cast
<
int16_t
>
(
amplitude
*
std
:
:
sin
(
phase_
)
+
noise_generator_
.
Gaussian
(
0
noise_std
)
)
;
phase_
+
=
2
*
kPi
*
kFreqHz
/
sample_rate_hz_
;
}
return
output
;
}
private
:
static
constexpr
int
kFreqHz
=
300
;
const
int
sample_rate_hz_
;
const
double
kPi
=
std
:
:
acos
(
-
1
)
;
std
:
:
vector
<
int16_t
>
samples_
;
double
phase_
=
0
.
0
;
FuzzDataHelper
&
fuzz_data_
;
Random
noise_generator_
;
}
;
class
FuzzSignalInput
:
public
NetEqInput
{
public
:
explicit
FuzzSignalInput
(
FuzzDataHelper
*
fuzz_data
int
sample_rate
uint8_t
payload_type
)
:
fuzz_data_
(
*
fuzz_data
)
{
AudioEncoderPcm16B
:
:
Config
config
;
config
.
payload_type
=
payload_type
;
config
.
sample_rate_hz
=
sample_rate
;
std
:
:
unique_ptr
<
AudioEncoder
>
encoder
(
new
AudioEncoderPcm16B
(
config
)
)
;
std
:
:
unique_ptr
<
EncodeNetEqInput
:
:
Generator
>
generator
(
new
SineAndNoiseGenerator
(
config
.
sample_rate_hz
fuzz_data
)
)
;
input_
.
reset
(
new
EncodeNetEqInput
(
std
:
:
move
(
generator
)
std
:
:
move
(
encoder
)
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
)
;
packet_
=
input_
-
>
PopPacket
(
)
;
constexpr
int
output_event_periods
[
]
=
{
9
10
11
}
;
output_event_period_ms_
=
fuzz_data_
.
SelectOneOf
(
output_event_periods
)
;
}
absl
:
:
optional
<
int64_t
>
NextPacketTime
(
)
const
override
{
return
packet_
-
>
time_ms
;
}
absl
:
:
optional
<
int64_t
>
NextOutputEventTime
(
)
const
override
{
return
next_output_event_ms_
;
}
std
:
:
unique_ptr
<
PacketData
>
PopPacket
(
)
override
{
RTC_DCHECK
(
packet_
)
;
std
:
:
unique_ptr
<
PacketData
>
packet_to_return
=
std
:
:
move
(
packet_
)
;
do
{
packet_
=
input_
-
>
PopPacket
(
)
;
}
while
(
fuzz_data_
.
CanReadBytes
(
1
)
&
&
fuzz_data_
.
Read
<
uint8_t
>
(
)
=
=
0
)
;
if
(
fuzz_data_
.
CanReadBytes
(
1
)
)
{
const
int8_t
arrival_time_offset_ms
=
fuzz_data_
.
Read
<
int8_t
>
(
)
;
packet_
-
>
time_ms
=
std
:
:
max
(
packet_to_return
-
>
time_ms
packet_
-
>
time_ms
+
arrival_time_offset_ms
)
;
}
else
{
ended_
=
true
;
}
return
packet_to_return
;
}
void
AdvanceOutputEvent
(
)
override
{
next_output_event_ms_
+
=
output_event_period_ms_
;
}
bool
ended
(
)
const
override
{
return
ended_
;
}
absl
:
:
optional
<
RTPHeader
>
NextHeader
(
)
const
override
{
RTC_DCHECK
(
packet_
)
;
return
packet_
-
>
header
;
}
private
:
bool
ended_
=
false
;
FuzzDataHelper
&
fuzz_data_
;
std
:
:
unique_ptr
<
EncodeNetEqInput
>
input_
;
std
:
:
unique_ptr
<
PacketData
>
packet_
;
int64_t
next_output_event_ms_
=
0
;
int64_t
output_event_period_ms_
=
10
;
}
;
template
<
class
T
>
bool
MapHas
(
const
std
:
:
map
<
int
T
>
&
m
int
key
const
T
&
value
)
{
const
auto
it
=
m
.
find
(
key
)
;
return
(
it
!
=
m
.
end
(
)
&
&
it
-
>
second
=
=
value
)
;
}
}
void
FuzzOneInputTest
(
const
uint8_t
*
data
size_t
size
)
{
if
(
size
<
1
|
|
size
>
65000
)
{
return
;
}
FuzzDataHelper
fuzz_data
(
rtc
:
:
ArrayView
<
const
uint8_t
>
(
data
size
)
)
;
std
:
:
pair
<
int
uint8_t
>
rate_types
[
]
=
{
{
8000
93
}
{
16000
94
}
{
32000
95
}
{
48000
96
}
}
;
const
auto
rate_type
=
fuzz_data
.
SelectOneOf
(
rate_types
)
;
const
int
sample_rate
=
rate_type
.
first
;
const
uint8_t
payload_type
=
rate_type
.
second
;
std
:
:
unique_ptr
<
FuzzSignalInput
>
input
(
new
FuzzSignalInput
(
&
fuzz_data
sample_rate
payload_type
)
)
;
std
:
:
unique_ptr
<
AudioChecksum
>
output
(
new
AudioChecksum
)
;
NetEqTest
:
:
Callbacks
callbacks
;
NetEq
:
:
Config
config
;
config
.
enable_post_decode_vad
=
true
;
config
.
enable_fast_accelerate
=
true
;
auto
codecs
=
NetEqTest
:
:
StandardDecoderMap
(
)
;
RTC_CHECK
(
MapHas
(
codecs
rate_types
[
0
]
.
second
SdpAudioFormat
(
"
l16
"
8000
1
)
)
)
;
RTC_CHECK
(
MapHas
(
codecs
rate_types
[
1
]
.
second
SdpAudioFormat
(
"
l16
"
16000
1
)
)
)
;
RTC_CHECK
(
MapHas
(
codecs
rate_types
[
2
]
.
second
SdpAudioFormat
(
"
l16
"
32000
1
)
)
)
;
RTC_CHECK
(
MapHas
(
codecs
rate_types
[
3
]
.
second
SdpAudioFormat
(
"
l16
"
48000
1
)
)
)
;
NetEqTest
test
(
config
CreateBuiltinAudioDecoderFactory
(
)
codecs
nullptr
nullptr
std
:
:
move
(
input
)
std
:
:
move
(
output
)
callbacks
)
;
test
.
Run
(
)
;
}
}
void
FuzzOneInput
(
const
uint8_t
*
data
size_t
size
)
{
test
:
:
FuzzOneInputTest
(
data
size
)
;
}
}
