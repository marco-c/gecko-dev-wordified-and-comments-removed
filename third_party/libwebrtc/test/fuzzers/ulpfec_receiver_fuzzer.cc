#
include
<
algorithm
>
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
ulpfec_receiver
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
test
/
fuzzers
/
fuzz_data_helper
.
h
"
namespace
webrtc
{
namespace
{
class
DummyCallback
:
public
RecoveredPacketReceiver
{
void
OnRecoveredPacket
(
const
uint8_t
*
packet
size_t
length
)
override
{
}
}
;
}
void
FuzzOneInput
(
const
uint8_t
*
data
size_t
size
)
{
constexpr
size_t
kMinDataNeeded
=
12
;
if
(
size
<
kMinDataNeeded
|
|
size
>
2000
)
{
return
;
}
uint32_t
ulpfec_ssrc
=
ByteReader
<
uint32_t
>
:
:
ReadLittleEndian
(
data
+
0
)
;
uint16_t
ulpfec_seq_num
=
ByteReader
<
uint16_t
>
:
:
ReadLittleEndian
(
data
+
4
)
;
uint32_t
media_ssrc
=
ByteReader
<
uint32_t
>
:
:
ReadLittleEndian
(
data
+
6
)
;
uint16_t
media_seq_num
=
ByteReader
<
uint16_t
>
:
:
ReadLittleEndian
(
data
+
10
)
;
DummyCallback
callback
;
std
:
:
unique_ptr
<
UlpfecReceiver
>
receiver
(
UlpfecReceiver
:
:
Create
(
ulpfec_ssrc
&
callback
{
}
)
)
;
test
:
:
FuzzDataHelper
fuzz_data
(
rtc
:
:
MakeArrayView
(
data
size
)
)
;
while
(
fuzz_data
.
CanReadBytes
(
kMinDataNeeded
)
)
{
size_t
packet_length
=
kRtpHeaderSize
+
fuzz_data
.
Read
<
uint8_t
>
(
)
;
auto
raw_packet
=
fuzz_data
.
ReadByteArray
(
packet_length
)
;
RtpPacketReceived
parsed_packet
;
if
(
!
parsed_packet
.
Parse
(
raw_packet
)
)
continue
;
if
(
fuzz_data
.
ReadOrDefaultValue
<
uint8_t
>
(
0
)
%
2
=
=
0
)
{
parsed_packet
.
SetSequenceNumber
(
ulpfec_seq_num
+
+
)
;
parsed_packet
.
SetSsrc
(
ulpfec_ssrc
)
;
}
else
{
parsed_packet
.
SetSequenceNumber
(
media_seq_num
+
+
)
;
parsed_packet
.
SetSsrc
(
media_ssrc
)
;
}
receiver
-
>
AddReceivedRedPacket
(
parsed_packet
0
)
;
}
receiver
-
>
ProcessReceivedFec
(
)
;
}
}
