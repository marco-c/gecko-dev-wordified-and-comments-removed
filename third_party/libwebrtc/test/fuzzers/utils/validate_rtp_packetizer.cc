#
include
"
test
/
fuzzers
/
utils
/
validate_rtp_packetizer
.
h
"
#
include
<
cstddef
>
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
namespace
webrtc
{
RtpPacketizer
:
:
PayloadSizeLimits
ReadPayloadSizeLimits
(
test
:
:
FuzzDataHelper
&
fuzz_input
)
{
RtpPacketizer
:
:
PayloadSizeLimits
limits
;
limits
.
max_payload_len
=
1200
;
limits
.
first_packet_reduction_len
=
fuzz_input
.
ReadOrDefaultValue
<
uint8_t
>
(
0
)
;
limits
.
last_packet_reduction_len
=
fuzz_input
.
ReadOrDefaultValue
<
uint8_t
>
(
0
)
;
limits
.
single_packet_reduction_len
=
fuzz_input
.
ReadOrDefaultValue
<
uint8_t
>
(
0
)
;
return
limits
;
}
void
ValidateRtpPacketizer
(
const
RtpPacketizer
:
:
PayloadSizeLimits
&
limits
RtpPacketizer
&
packetizer
)
{
size_t
num_packets
=
packetizer
.
NumPackets
(
)
;
if
(
num_packets
=
=
0
)
{
return
;
}
RtpPacketToSend
rtp_packet
(
nullptr
)
;
if
(
num_packets
=
=
1
)
{
RTC_CHECK
(
packetizer
.
NextPacket
(
&
rtp_packet
)
)
;
RTC_CHECK_LE
(
rtp_packet
.
payload_size
(
)
limits
.
max_payload_len
-
limits
.
single_packet_reduction_len
)
;
return
;
}
RTC_CHECK
(
packetizer
.
NextPacket
(
&
rtp_packet
)
)
;
RTC_CHECK_LE
(
rtp_packet
.
payload_size
(
)
limits
.
max_payload_len
-
limits
.
first_packet_reduction_len
)
;
for
(
size_t
i
=
1
;
i
<
num_packets
-
1
;
+
+
i
)
{
rtp_packet
.
Clear
(
)
;
RTC_CHECK
(
packetizer
.
NextPacket
(
&
rtp_packet
)
)
<
<
"
Failed
to
get
packet
#
"
<
<
i
;
RTC_CHECK_LE
(
rtp_packet
.
payload_size
(
)
limits
.
max_payload_len
)
<
<
"
Packet
#
"
<
<
i
<
<
"
exceeds
it
'
s
limit
"
;
}
rtp_packet
.
Clear
(
)
;
RTC_CHECK
(
packetizer
.
NextPacket
(
&
rtp_packet
)
)
;
RTC_CHECK_LE
(
rtp_packet
.
payload_size
(
)
limits
.
max_payload_len
-
limits
.
last_packet_reduction_len
)
;
}
}
