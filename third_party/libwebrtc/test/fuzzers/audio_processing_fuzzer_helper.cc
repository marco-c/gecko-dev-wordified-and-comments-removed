#
include
"
test
/
fuzzers
/
audio_processing_fuzzer_helper
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cmath
>
#
include
<
limits
>
#
include
"
api
/
audio
/
audio_frame
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_frame_proxies
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
{
bool
ValidForApm
(
float
x
)
{
return
std
:
:
isfinite
(
x
)
&
&
-
1
.
0f
<
=
x
&
&
x
<
=
1
.
0f
;
}
void
GenerateFloatFrame
(
test
:
:
FuzzDataHelper
*
fuzz_data
size_t
input_rate
size_t
num_channels
float
*
const
*
float_frames
)
{
const
size_t
samples_per_input_channel
=
rtc
:
:
CheckedDivExact
(
input_rate
static_cast
<
size_t
>
(
100
)
)
;
RTC_DCHECK_LE
(
samples_per_input_channel
480
)
;
for
(
size_t
i
=
0
;
i
<
num_channels
;
+
+
i
)
{
std
:
:
fill
(
float_frames
[
i
]
float_frames
[
i
]
+
samples_per_input_channel
0
)
;
const
size_t
read_bytes
=
sizeof
(
float
)
*
samples_per_input_channel
;
if
(
fuzz_data
-
>
CanReadBytes
(
read_bytes
)
)
{
rtc
:
:
ArrayView
<
const
uint8_t
>
byte_array
=
fuzz_data
-
>
ReadByteArray
(
read_bytes
)
;
memmove
(
float_frames
[
i
]
byte_array
.
begin
(
)
read_bytes
)
;
}
for
(
size_t
j
=
0
;
j
<
samples_per_input_channel
;
+
+
j
)
{
if
(
!
ValidForApm
(
float_frames
[
i
]
[
j
]
)
)
{
float_frames
[
i
]
[
j
]
=
0
.
f
;
}
}
}
}
void
GenerateFixedFrame
(
test
:
:
FuzzDataHelper
*
fuzz_data
size_t
input_rate
size_t
num_channels
AudioFrame
*
fixed_frame
)
{
const
size_t
samples_per_input_channel
=
rtc
:
:
CheckedDivExact
(
input_rate
static_cast
<
size_t
>
(
100
)
)
;
fixed_frame
-
>
samples_per_channel_
=
samples_per_input_channel
;
fixed_frame
-
>
sample_rate_hz_
=
input_rate
;
fixed_frame
-
>
num_channels_
=
num_channels
;
RTC_DCHECK_LE
(
samples_per_input_channel
*
num_channels
AudioFrame
:
:
kMaxDataSizeSamples
)
;
for
(
size_t
i
=
0
;
i
<
samples_per_input_channel
*
num_channels
;
+
+
i
)
{
fixed_frame
-
>
mutable_data
(
)
[
i
]
=
fuzz_data
-
>
ReadOrDefaultValue
<
int16_t
>
(
0
)
;
}
}
}
void
FuzzAudioProcessing
(
test
:
:
FuzzDataHelper
*
fuzz_data
std
:
:
unique_ptr
<
AudioProcessing
>
apm
)
{
AudioFrame
fixed_frame
;
constexpr
int
kMaxNumChannels
=
9
;
std
:
:
array
<
std
:
:
array
<
float
480
>
kMaxNumChannels
>
float_frames
;
std
:
:
array
<
float
*
kMaxNumChannels
>
float_frame_ptrs
;
for
(
int
i
=
0
;
i
<
kMaxNumChannels
;
+
+
i
)
{
float_frame_ptrs
[
i
]
=
float_frames
[
i
]
.
data
(
)
;
}
float
*
const
*
ptr_to_float_frames
=
&
float_frame_ptrs
[
0
]
;
using
Rate
=
AudioProcessing
:
:
NativeRate
;
const
Rate
rate_kinds
[
]
=
{
Rate
:
:
kSampleRate8kHz
Rate
:
:
kSampleRate16kHz
Rate
:
:
kSampleRate32kHz
Rate
:
:
kSampleRate48kHz
}
;
while
(
fuzz_data
-
>
CanReadBytes
(
1
)
)
{
const
bool
is_float
=
fuzz_data
-
>
ReadOrDefaultValue
(
true
)
;
const
auto
input_rate
=
static_cast
<
size_t
>
(
fuzz_data
-
>
SelectOneOf
(
rate_kinds
)
)
;
const
auto
output_rate
=
static_cast
<
size_t
>
(
fuzz_data
-
>
SelectOneOf
(
rate_kinds
)
)
;
const
uint8_t
stream_delay
=
fuzz_data
-
>
ReadOrDefaultValue
<
uint8_t
>
(
0
)
;
apm
-
>
set_stream_delay_ms
(
stream_delay
)
;
const
bool
key_pressed
=
fuzz_data
-
>
ReadOrDefaultValue
(
true
)
;
apm
-
>
set_stream_key_pressed
(
key_pressed
)
;
const
bool
is_capture
=
fuzz_data
-
>
ReadOrDefaultValue
(
true
)
;
int
apm_return_code
=
AudioProcessing
:
:
Error
:
:
kNoError
;
if
(
is_float
)
{
const
int
num_channels
=
fuzz_data
-
>
ReadOrDefaultValue
<
uint8_t
>
(
1
)
%
kMaxNumChannels
;
GenerateFloatFrame
(
fuzz_data
input_rate
num_channels
ptr_to_float_frames
)
;
if
(
is_capture
)
{
apm_return_code
=
apm
-
>
ProcessStream
(
ptr_to_float_frames
StreamConfig
(
input_rate
num_channels
)
StreamConfig
(
output_rate
num_channels
)
ptr_to_float_frames
)
;
}
else
{
apm_return_code
=
apm
-
>
ProcessReverseStream
(
ptr_to_float_frames
StreamConfig
(
input_rate
num_channels
)
StreamConfig
(
output_rate
num_channels
)
ptr_to_float_frames
)
;
}
}
else
{
const
int
num_channels
=
fuzz_data
-
>
ReadOrDefaultValue
(
true
)
?
2
:
1
;
GenerateFixedFrame
(
fuzz_data
input_rate
num_channels
&
fixed_frame
)
;
if
(
is_capture
)
{
apm_return_code
=
ProcessAudioFrame
(
apm
.
get
(
)
&
fixed_frame
)
;
}
else
{
apm_return_code
=
ProcessReverseAudioFrame
(
apm
.
get
(
)
&
fixed_frame
)
;
}
}
static_cast
<
void
>
(
apm
-
>
GetStatistics
(
true
)
)
;
RTC_DCHECK_NE
(
apm_return_code
AudioProcessing
:
:
kBadDataLengthError
)
;
}
}
}
