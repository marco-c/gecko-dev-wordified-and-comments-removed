#
ifndef
TEST_FUZZERS_FUZZ_DATA_HELPER_H_
#
define
TEST_FUZZERS_FUZZ_DATA_HELPER_H_
#
include
<
limits
>
#
include
"
api
/
array_view
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
namespace
webrtc
{
namespace
test
{
class
FuzzDataHelper
{
public
:
explicit
FuzzDataHelper
(
ArrayView
<
const
uint8_t
>
data
)
;
bool
CanReadBytes
(
size_t
n
)
const
{
return
data_ix_
+
n
<
=
data_
.
size
(
)
;
}
template
<
typename
T
>
T
Read
(
)
{
RTC_CHECK
(
CanReadBytes
(
sizeof
(
T
)
)
)
;
T
x
=
ByteReader
<
T
>
:
:
ReadLittleEndian
(
&
data_
[
data_ix_
]
)
;
data_ix_
+
=
sizeof
(
T
)
;
return
x
;
}
template
<
typename
T
>
T
ReadOrDefaultValue
(
T
default_value
)
{
if
(
!
CanReadBytes
(
sizeof
(
T
)
)
)
{
return
default_value
;
}
return
Read
<
T
>
(
)
;
}
template
<
typename
T
>
T
ReadOrDefaultValueNotZero
(
T
default_value
)
{
static_assert
(
std
:
:
is_integral
<
T
>
:
:
value
"
"
)
;
T
x
=
ReadOrDefaultValue
(
default_value
)
;
return
x
=
=
0
?
default_value
:
x
;
}
template
<
typename
T
size_t
N
>
T
SelectOneOf
(
const
T
(
&
select_from
)
[
N
]
)
{
static_assert
(
N
<
=
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
(
)
"
"
)
;
uint8_t
index
=
ReadOrDefaultValue
<
uint8_t
>
(
0
)
%
N
;
return
select_from
[
index
]
;
}
ArrayView
<
const
uint8_t
>
ReadByteArray
(
size_t
bytes
)
{
if
(
!
CanReadBytes
(
bytes
)
)
{
return
ArrayView
<
const
uint8_t
>
(
nullptr
0
)
;
}
const
size_t
index_to_return
=
data_ix_
;
data_ix_
+
=
bytes
;
return
data_
.
subview
(
index_to_return
bytes
)
;
}
template
<
typename
T
>
void
CopyTo
(
T
*
object
)
{
memset
(
object
0
sizeof
(
T
)
)
;
size_t
bytes_to_copy
=
std
:
:
min
(
BytesLeft
(
)
sizeof
(
T
)
)
;
memcpy
(
object
data_
.
data
(
)
+
data_ix_
bytes_to_copy
)
;
data_ix_
+
=
bytes_to_copy
;
}
size_t
BytesRead
(
)
const
{
return
data_ix_
;
}
size_t
BytesLeft
(
)
const
{
return
data_
.
size
(
)
-
data_ix_
;
}
private
:
ArrayView
<
const
uint8_t
>
data_
;
size_t
data_ix_
=
0
;
}
;
}
}
#
endif
