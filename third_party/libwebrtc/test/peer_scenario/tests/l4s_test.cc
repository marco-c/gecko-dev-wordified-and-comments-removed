#
include
<
atomic
>
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
congestion_control_feedback
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
rtpfb
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
transport_feedback
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_util
.
h
"
#
include
"
test
/
create_frame_generator_capturer
.
h
"
#
include
"
test
/
field_trial
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
peer_scenario
/
peer_scenario
.
h
"
#
include
"
test
/
peer_scenario
/
peer_scenario_client
.
h
"
namespace
webrtc
{
namespace
{
using
test
:
:
PeerScenario
;
using
test
:
:
PeerScenarioClient
;
using
:
:
testing
:
:
HasSubstr
;
class
RtcpFeedbackCounter
{
public
:
void
Count
(
const
EmulatedIpPacket
&
packet
)
{
if
(
!
IsRtcpPacket
(
packet
.
data
)
)
{
return
;
}
rtcp
:
:
CommonHeader
header
;
ASSERT_TRUE
(
header
.
Parse
(
packet
.
data
.
cdata
(
)
packet
.
data
.
size
(
)
)
)
;
if
(
header
.
type
(
)
!
=
rtcp
:
:
Rtpfb
:
:
kPacketType
)
{
return
;
}
if
(
header
.
fmt
(
)
=
=
rtcp
:
:
CongestionControlFeedback
:
:
kFeedbackMessageType
)
{
+
+
congestion_control_feedback_
;
}
if
(
header
.
fmt
(
)
=
=
rtcp
:
:
TransportFeedback
:
:
kFeedbackMessageType
)
{
+
+
transport_sequence_number_feedback_
;
}
}
int
FeedbackAccordingToRfc8888
(
)
const
{
return
congestion_control_feedback_
;
}
int
FeedbackAccordingToTransportCc
(
)
const
{
return
transport_sequence_number_feedback_
;
}
private
:
int
congestion_control_feedback_
=
0
;
int
transport_sequence_number_feedback_
=
0
;
}
;
TEST
(
L4STest
NegotiateAndUseCcfbIfEnabled
)
{
test
:
:
ScopedFieldTrials
trials
(
"
WebRTC
-
RFC8888CongestionControlFeedback
/
Enabled
/
"
)
;
PeerScenario
s
(
*
test_info_
)
;
PeerScenarioClient
:
:
Config
config
=
PeerScenarioClient
:
:
Config
(
)
;
config
.
disable_encryption
=
true
;
PeerScenarioClient
*
caller
=
s
.
CreateClient
(
config
)
;
PeerScenarioClient
*
callee
=
s
.
CreateClient
(
config
)
;
auto
send_node
=
s
.
net
(
)
-
>
NodeBuilder
(
)
.
Build
(
)
.
node
;
auto
ret_node
=
s
.
net
(
)
-
>
NodeBuilder
(
)
.
Build
(
)
.
node
;
s
.
net
(
)
-
>
CreateRoute
(
caller
-
>
endpoint
(
)
{
send_node
}
callee
-
>
endpoint
(
)
)
;
s
.
net
(
)
-
>
CreateRoute
(
callee
-
>
endpoint
(
)
{
ret_node
}
caller
-
>
endpoint
(
)
)
;
RtcpFeedbackCounter
send_node_feedback_counter
;
send_node
-
>
router
(
)
-
>
SetFilter
(
[
&
]
(
const
EmulatedIpPacket
&
packet
)
{
send_node_feedback_counter
.
Count
(
packet
)
;
return
true
;
}
)
;
RtcpFeedbackCounter
ret_node_feedback_counter
;
ret_node
-
>
router
(
)
-
>
SetFilter
(
[
&
]
(
const
EmulatedIpPacket
&
packet
)
{
ret_node_feedback_counter
.
Count
(
packet
)
;
return
true
;
}
)
;
auto
signaling
=
s
.
ConnectSignaling
(
caller
callee
{
send_node
}
{
ret_node
}
)
;
PeerScenarioClient
:
:
VideoSendTrackConfig
video_conf
;
video_conf
.
generator
.
squares_video
-
>
framerate
=
15
;
caller
-
>
CreateVideo
(
"
VIDEO_1
"
video_conf
)
;
callee
-
>
CreateVideo
(
"
VIDEO_2
"
video_conf
)
;
signaling
.
StartIceSignaling
(
)
;
std
:
:
atomic
<
bool
>
offer_exchange_done
(
false
)
;
signaling
.
NegotiateSdp
(
[
&
]
(
SessionDescriptionInterface
*
offer
)
{
std
:
:
string
offer_str
=
absl
:
:
StrCat
(
*
offer
)
;
EXPECT_THAT
(
offer_str
HasSubstr
(
"
a
=
rtcp
-
fb
:
*
ack
ccfb
\
r
\
n
"
)
)
;
EXPECT_THAT
(
offer_str
HasSubstr
(
"
transport
-
cc
"
)
)
;
EXPECT_THAT
(
offer_str
HasSubstr
(
"
http
:
/
/
www
.
ietf
.
org
/
id
/
"
"
draft
-
holmer
-
rmcat
-
transport
-
wide
-
cc
-
extensions
"
)
)
;
}
[
&
]
(
const
SessionDescriptionInterface
&
answer
)
{
std
:
:
string
answer_str
=
absl
:
:
StrCat
(
answer
)
;
EXPECT_THAT
(
answer_str
HasSubstr
(
"
a
=
rtcp
-
fb
:
*
ack
ccfb
\
r
\
n
"
)
)
;
EXPECT_THAT
(
answer_str
Not
(
HasSubstr
(
"
transport
-
cc
"
)
)
)
;
EXPECT_THAT
(
answer_str
Not
(
HasSubstr
(
"
http
:
/
/
www
.
ietf
.
org
/
id
/
"
"
draft
-
holmer
-
rmcat
-
transport
-
wide
-
cc
-
extensions
-
"
)
)
)
;
offer_exchange_done
=
true
;
}
)
;
s
.
WaitAndProcess
(
&
offer_exchange_done
)
;
s
.
ProcessMessages
(
TimeDelta
:
:
Seconds
(
2
)
)
;
EXPECT_GT
(
send_node_feedback_counter
.
FeedbackAccordingToRfc8888
(
)
0
)
;
EXPECT_GT
(
ret_node_feedback_counter
.
FeedbackAccordingToRfc8888
(
)
0
)
;
EXPECT_EQ
(
ret_node_feedback_counter
.
FeedbackAccordingToTransportCc
(
)
0
)
;
}
}
}
