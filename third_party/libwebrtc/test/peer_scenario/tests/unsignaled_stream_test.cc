#
include
"
media
/
base
/
stream_params
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_util
.
h
"
#
include
"
pc
/
media_session
.
h
"
#
include
"
pc
/
session_description
.
h
"
#
include
"
test
/
field_trial
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
peer_scenario
/
peer_scenario
.
h
"
namespace
webrtc
{
namespace
test
{
namespace
{
enum
class
MidTestConfiguration
{
kMidNotNegotiated
kMidNegotiatedButMissingFromPackets
kMidNegotiatedAndPresentInPackets
}
;
std
:
:
string
TestParametersMidTestConfigurationToString
(
testing
:
:
TestParamInfo
<
MidTestConfiguration
>
info
)
{
switch
(
info
.
param
)
{
case
MidTestConfiguration
:
:
kMidNotNegotiated
:
return
"
MidNotNegotiated
"
;
case
MidTestConfiguration
:
:
kMidNegotiatedButMissingFromPackets
:
return
"
MidNegotiatedButMissingFromPackets
"
;
case
MidTestConfiguration
:
:
kMidNegotiatedAndPresentInPackets
:
return
"
MidNegotiatedAndPresentInPackets
"
;
}
}
class
FrameObserver
:
public
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
{
public
:
FrameObserver
(
)
:
frame_observed_
(
false
)
{
}
void
OnFrame
(
const
VideoFrame
&
)
override
{
frame_observed_
=
true
;
}
std
:
:
atomic
<
bool
>
frame_observed_
;
}
;
uint32_t
get_ssrc
(
SessionDescriptionInterface
*
offer
size_t
track_index
)
{
EXPECT_LT
(
track_index
offer
-
>
description
(
)
-
>
contents
(
)
.
size
(
)
)
;
return
offer
-
>
description
(
)
-
>
contents
(
)
[
track_index
]
.
media_description
(
)
-
>
streams
(
)
[
0
]
.
ssrcs
[
0
]
;
}
void
set_ssrc
(
SessionDescriptionInterface
*
offer
size_t
index
uint32_t
ssrc
)
{
EXPECT_LT
(
index
offer
-
>
description
(
)
-
>
contents
(
)
.
size
(
)
)
;
cricket
:
:
StreamParams
&
new_stream_params
=
offer
-
>
description
(
)
-
>
contents
(
)
[
index
]
.
media_description
(
)
-
>
mutable_streams
(
)
[
0
]
;
new_stream_params
.
ssrcs
[
0
]
=
ssrc
;
new_stream_params
.
ssrc_groups
[
0
]
.
ssrcs
[
0
]
=
ssrc
;
}
}
class
UnsignaledStreamTest
:
public
:
:
testing
:
:
Test
public
:
:
testing
:
:
WithParamInterface
<
MidTestConfiguration
>
{
}
;
TEST_P
(
UnsignaledStreamTest
ReplacesUnsignaledStreamOnCompletedSignaling
)
{
const
MidTestConfiguration
kMidTestConfiguration
=
GetParam
(
)
;
PeerScenario
s
(
*
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
)
;
PeerScenarioClient
:
:
Config
config
=
PeerScenarioClient
:
:
Config
(
)
;
config
.
disable_encryption
=
true
;
auto
*
caller
=
s
.
CreateClient
(
config
)
;
auto
*
callee
=
s
.
CreateClient
(
config
)
;
auto
send_node
=
s
.
net
(
)
-
>
NodeBuilder
(
)
.
Build
(
)
.
node
;
auto
ret_node
=
s
.
net
(
)
-
>
NodeBuilder
(
)
.
Build
(
)
.
node
;
s
.
net
(
)
-
>
CreateRoute
(
caller
-
>
endpoint
(
)
{
send_node
}
callee
-
>
endpoint
(
)
)
;
s
.
net
(
)
-
>
CreateRoute
(
callee
-
>
endpoint
(
)
{
ret_node
}
caller
-
>
endpoint
(
)
)
;
auto
signaling
=
s
.
ConnectSignaling
(
caller
callee
{
send_node
}
{
ret_node
}
)
;
PeerScenarioClient
:
:
VideoSendTrackConfig
video_conf
;
video_conf
.
generator
.
squares_video
-
>
framerate
=
15
;
auto
first_track
=
caller
-
>
CreateVideo
(
"
VIDEO
"
video_conf
)
;
FrameObserver
first_sink
;
callee
-
>
AddVideoReceiveSink
(
first_track
.
track
-
>
id
(
)
&
first_sink
)
;
signaling
.
StartIceSignaling
(
)
;
std
:
:
atomic
<
bool
>
offer_exchange_done
(
false
)
;
std
:
:
atomic
<
bool
>
got_unsignaled_packet
(
false
)
;
uint32_t
first_ssrc
=
0
;
uint32_t
second_ssrc
=
0
;
absl
:
:
optional
<
int
>
mid_header_extension_id
=
absl
:
:
nullopt
;
signaling
.
NegotiateSdp
(
[
&
]
(
SessionDescriptionInterface
*
offer
)
{
for
(
cricket
:
:
ContentInfo
&
content_info
:
offer
-
>
description
(
)
-
>
contents
(
)
)
{
std
:
:
vector
<
RtpExtension
>
header_extensions
=
content_info
.
media_description
(
)
-
>
rtp_header_extensions
(
)
;
for
(
auto
it
=
header_extensions
.
begin
(
)
;
it
!
=
header_extensions
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
uri
=
=
RtpExtension
:
:
kMidUri
)
{
mid_header_extension_id
=
it
-
>
id
;
if
(
kMidTestConfiguration
=
=
MidTestConfiguration
:
:
kMidNotNegotiated
)
{
header_extensions
.
erase
(
it
)
;
}
break
;
}
}
content_info
.
media_description
(
)
-
>
set_rtp_header_extensions
(
std
:
:
move
(
header_extensions
)
)
;
}
ASSERT_TRUE
(
mid_header_extension_id
.
has_value
(
)
)
;
}
[
&
]
(
SessionDescriptionInterface
*
offer
)
{
first_ssrc
=
get_ssrc
(
offer
0
)
;
second_ssrc
=
first_ssrc
+
1
;
send_node
-
>
router
(
)
-
>
SetWatcher
(
[
&
]
(
const
EmulatedIpPacket
&
packet
)
{
if
(
IsRtpPacket
(
packet
.
data
)
&
&
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
&
(
packet
.
cdata
(
)
[
8
]
)
)
=
=
first_ssrc
&
&
!
got_unsignaled_packet
)
{
std
:
:
vector
<
RtpExtension
>
extensions
;
extensions
.
emplace_back
(
RtpExtension
:
:
kMidUri
mid_header_extension_id
.
value
(
)
)
;
RtpHeaderExtensionMap
extensions_map
(
extensions
)
;
RtpPacket
parsed_packet
;
parsed_packet
.
IdentifyExtensions
(
extensions_map
)
;
ASSERT_TRUE
(
parsed_packet
.
Parse
(
packet
.
data
)
)
;
parsed_packet
.
SetSsrc
(
second_ssrc
)
;
switch
(
kMidTestConfiguration
)
{
case
MidTestConfiguration
:
:
kMidNotNegotiated
:
EXPECT_FALSE
(
parsed_packet
.
HasExtension
<
RtpMid
>
(
)
)
;
break
;
case
MidTestConfiguration
:
:
kMidNegotiatedButMissingFromPackets
:
EXPECT_TRUE
(
parsed_packet
.
HasExtension
<
RtpMid
>
(
)
)
;
ASSERT_TRUE
(
parsed_packet
.
RemoveExtension
(
RtpMid
:
:
kId
)
)
;
break
;
case
MidTestConfiguration
:
:
kMidNegotiatedAndPresentInPackets
:
EXPECT_TRUE
(
parsed_packet
.
HasExtension
<
RtpMid
>
(
)
)
;
ASSERT_TRUE
(
parsed_packet
.
SetExtension
<
RtpMid
>
(
"
1
"
)
)
;
break
;
}
rtc
:
:
CopyOnWriteBuffer
updated_buffer
=
parsed_packet
.
Buffer
(
)
;
EmulatedIpPacket
updated_packet
(
packet
.
from
packet
.
to
updated_buffer
packet
.
arrival_time
)
;
send_node
-
>
OnPacketReceived
(
std
:
:
move
(
updated_packet
)
)
;
got_unsignaled_packet
=
true
;
}
}
)
;
}
[
&
]
(
const
SessionDescriptionInterface
&
answer
)
{
EXPECT_EQ
(
answer
.
description
(
)
-
>
contents
(
)
.
size
(
)
1u
)
;
offer_exchange_done
=
true
;
}
)
;
EXPECT_TRUE
(
s
.
WaitAndProcess
(
&
offer_exchange_done
)
)
;
EXPECT_TRUE
(
s
.
WaitAndProcess
(
&
got_unsignaled_packet
)
)
;
EXPECT_TRUE
(
s
.
WaitAndProcess
(
&
first_sink
.
frame_observed_
)
)
;
auto
second_track
=
caller
-
>
CreateVideo
(
"
VIDEO2
"
video_conf
)
;
FrameObserver
second_sink
;
callee
-
>
AddVideoReceiveSink
(
second_track
.
track
-
>
id
(
)
&
second_sink
)
;
offer_exchange_done
=
false
;
signaling
.
NegotiateSdp
(
[
&
]
(
SessionDescriptionInterface
*
offer
)
{
set_ssrc
(
offer
1
second_ssrc
)
;
}
{
}
[
&
]
(
const
SessionDescriptionInterface
&
answer
)
{
EXPECT_EQ
(
answer
.
description
(
)
-
>
contents
(
)
.
size
(
)
2u
)
;
offer_exchange_done
=
true
;
}
)
;
EXPECT_TRUE
(
s
.
WaitAndProcess
(
&
offer_exchange_done
)
)
;
EXPECT_TRUE
(
s
.
WaitAndProcess
(
&
second_sink
.
frame_observed_
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
All
UnsignaledStreamTest
:
:
testing
:
:
Values
(
MidTestConfiguration
:
:
kMidNotNegotiated
MidTestConfiguration
:
:
kMidNegotiatedButMissingFromPackets
MidTestConfiguration
:
:
kMidNegotiatedAndPresentInPackets
)
TestParametersMidTestConfigurationToString
)
;
}
}
