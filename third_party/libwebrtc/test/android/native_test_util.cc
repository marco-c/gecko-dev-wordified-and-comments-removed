#
include
"
test
/
android
/
native_test_util
.
h
"
#
include
<
android
/
log
.
h
>
#
include
<
cstdio
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
absl
/
strings
/
str_split
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
namespace
webrtc
{
namespace
test
{
namespace
android
{
namespace
{
const
char
kLogTag
[
]
=
"
webrtc
"
;
std
:
:
optional
<
std
:
:
string
>
ReadFileToString
(
const
char
*
path
)
{
FILE
*
file
=
fopen
(
path
"
rb
"
)
;
if
(
!
file
)
{
AndroidLog
(
ANDROID_LOG_ERROR
"
Failed
to
open
%
s
\
n
"
path
)
;
return
std
:
:
nullopt
;
}
if
(
fseek
(
file
0
SEEK_END
)
!
=
0
)
{
return
std
:
:
nullopt
;
}
auto
size
=
ftell
(
file
)
;
if
(
size
<
0
|
|
size
>
1
'
000
'
000
'
000
)
{
AndroidLog
(
ANDROID_LOG_ERROR
"
Expected
size
of
%
s
between
0
and
1
GB
got
%
ld
bytes
\
n
"
path
size
)
;
return
std
:
:
nullopt
;
}
std
:
:
string
contents
;
contents
.
resize
(
size
)
;
fseek
(
file
0
SEEK_SET
)
;
if
(
fread
(
contents
.
data
(
)
1
size
file
)
!
=
static_cast
<
size_t
>
(
size
)
)
{
return
std
:
:
nullopt
;
}
if
(
ferror
(
file
)
)
{
return
std
:
:
nullopt
;
}
return
contents
;
}
}
void
AndroidLog
(
int
priority
const
char
*
format
.
.
.
)
{
va_list
args
;
va_start
(
args
format
)
;
__android_log_vprint
(
priority
kLogTag
format
args
)
;
va_end
(
args
)
;
}
std
:
:
string
ASCIIJavaStringToUTF8
(
JNIEnv
*
env
jstring
str
)
{
if
(
!
str
)
{
return
"
"
;
}
const
jsize
length
=
env
-
>
GetStringLength
(
str
)
;
if
(
!
length
)
{
return
"
"
;
}
const
jchar
*
jchars
=
env
-
>
GetStringChars
(
str
NULL
)
;
const
char16_t
*
chars
=
reinterpret_cast
<
const
char16_t
*
>
(
jchars
)
;
std
:
:
string
out
(
chars
chars
+
length
)
;
env
-
>
ReleaseStringChars
(
str
jchars
)
;
return
out
;
}
void
ParseArgsFromString
(
const
std
:
:
string
&
command_line
std
:
:
vector
<
std
:
:
string
>
*
args
)
{
std
:
:
vector
<
absl
:
:
string_view
>
v
=
absl
:
:
StrSplit
(
command_line
absl
:
:
ByAsciiWhitespace
(
)
)
;
for
(
absl
:
:
string_view
arg
:
v
)
{
args
-
>
push_back
(
std
:
:
string
(
arg
)
)
;
}
}
void
ParseArgsFromCommandLineFile
(
const
char
*
path
std
:
:
vector
<
std
:
:
string
>
*
args
)
{
std
:
:
optional
<
std
:
:
string
>
command_line_string
=
ReadFileToString
(
path
)
;
if
(
command_line_string
.
has_value
(
)
)
{
ParseArgsFromString
(
*
command_line_string
args
)
;
}
}
int
ArgsToArgv
(
const
std
:
:
vector
<
std
:
:
string
>
&
args
std
:
:
vector
<
char
*
>
*
argv
)
{
int
argc
=
args
.
size
(
)
;
argv
-
>
resize
(
argc
+
1
)
;
for
(
int
i
=
0
;
i
<
argc
;
+
+
i
)
{
(
*
argv
)
[
i
]
=
const_cast
<
char
*
>
(
args
[
i
]
.
c_str
(
)
)
;
}
(
*
argv
)
[
argc
]
=
NULL
;
return
argc
;
}
}
}
}
