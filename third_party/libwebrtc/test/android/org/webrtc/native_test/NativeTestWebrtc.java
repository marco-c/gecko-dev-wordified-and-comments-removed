package
org
.
webrtc
.
native_test
;
import
android
.
app
.
Activity
;
import
android
.
content
.
Intent
;
import
android
.
os
.
Bundle
;
import
android
.
os
.
Environment
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Process
;
import
android
.
system
.
ErrnoException
;
import
android
.
system
.
Os
;
import
android
.
util
.
Log
;
import
org
.
jni_zero
.
JNINamespace
;
import
org
.
jni_zero
.
JniType
;
import
org
.
jni_zero
.
NativeMethods
;
import
org
.
webrtc
.
native_test
.
StrictModeContext
;
import
org
.
chromium
.
build
.
gtest_apk
.
NativeTestIntent
;
import
org
.
chromium
.
test
.
reporter
.
TestStatusReporter
;
import
java
.
io
.
File
;
JNINamespace
(
"
webrtc
:
:
test
:
:
android
"
)
public
class
NativeTestWebrtc
{
private
static
final
String
TAG
=
"
NativeTestWebrtc
"
;
private
String
mCommandLineFilePath
;
private
StringBuilder
mCommandLineFlags
=
new
StringBuilder
(
)
;
private
TestStatusReporter
mReporter
;
private
boolean
mRunInSubThread
;
private
String
mStdoutFilePath
;
private
static
class
ReportingUncaughtExceptionHandler
implements
Thread
.
UncaughtExceptionHandler
{
private
TestStatusReporter
mReporter
;
private
Thread
.
UncaughtExceptionHandler
mWrappedHandler
;
public
ReportingUncaughtExceptionHandler
(
TestStatusReporter
reporter
Thread
.
UncaughtExceptionHandler
wrappedHandler
)
{
mReporter
=
reporter
;
mWrappedHandler
=
wrappedHandler
;
}
Override
public
void
uncaughtException
(
Thread
thread
Throwable
ex
)
{
mReporter
.
uncaughtException
(
Process
.
myPid
(
)
ex
)
;
if
(
mWrappedHandler
!
=
null
)
mWrappedHandler
.
uncaughtException
(
thread
ex
)
;
}
}
public
void
preCreate
(
Activity
activity
)
{
String
coverageDeviceFile
=
activity
.
getIntent
(
)
.
getStringExtra
(
NativeTestIntent
.
EXTRA_COVERAGE_DEVICE_FILE
)
;
if
(
coverageDeviceFile
!
=
null
)
{
try
{
Os
.
setenv
(
"
LLVM_PROFILE_FILE
"
coverageDeviceFile
true
)
;
}
catch
(
ErrnoException
e
)
{
Log
.
w
(
TAG
"
failed
to
set
LLVM_PROFILE_FILE
"
+
e
.
toString
(
)
)
;
}
}
try
{
Os
.
setenv
(
"
TMPDIR
"
activity
.
getApplicationContext
(
)
.
getCacheDir
(
)
.
getPath
(
)
false
)
;
}
catch
(
ErrnoException
e
)
{
Log
.
w
(
TAG
"
failed
to
set
TMPDIR
"
+
e
.
toString
(
)
)
;
}
}
public
void
postCreate
(
Activity
activity
)
{
parseArgumentsFromIntent
(
activity
activity
.
getIntent
(
)
)
;
mReporter
=
new
TestStatusReporter
(
activity
)
;
mReporter
.
testRunStarted
(
Process
.
myPid
(
)
)
;
Thread
.
setDefaultUncaughtExceptionHandler
(
new
ReportingUncaughtExceptionHandler
(
mReporter
Thread
.
getDefaultUncaughtExceptionHandler
(
)
)
)
;
}
private
void
parseArgumentsFromIntent
(
Activity
activity
Intent
intent
)
{
Log
.
i
(
TAG
"
Extras
:
"
)
;
Bundle
extras
=
intent
.
getExtras
(
)
;
if
(
extras
!
=
null
)
{
for
(
String
s
:
extras
.
keySet
(
)
)
{
Log
.
i
(
TAG
"
"
+
s
)
;
}
}
mCommandLineFilePath
=
intent
.
getStringExtra
(
NativeTestIntent
.
EXTRA_COMMAND_LINE_FILE
)
;
if
(
mCommandLineFilePath
=
=
null
)
{
mCommandLineFilePath
=
"
"
;
}
else
{
File
commandLineFile
=
new
File
(
mCommandLineFilePath
)
;
if
(
!
commandLineFile
.
isAbsolute
(
)
)
{
mCommandLineFilePath
=
Environment
.
getExternalStorageDirectory
(
)
+
"
/
"
+
mCommandLineFilePath
;
}
Log
.
i
(
TAG
"
command
line
file
path
:
"
+
mCommandLineFilePath
)
;
}
String
commandLineFlags
=
intent
.
getStringExtra
(
NativeTestIntent
.
EXTRA_COMMAND_LINE_FLAGS
)
;
if
(
commandLineFlags
!
=
null
)
mCommandLineFlags
.
append
(
commandLineFlags
)
;
mRunInSubThread
=
intent
.
hasExtra
(
NativeTestIntent
.
EXTRA_RUN_IN_SUB_THREAD
)
;
String
gtestFilter
=
intent
.
getStringExtra
(
NativeTestIntent
.
EXTRA_GTEST_FILTER
)
;
if
(
gtestFilter
!
=
null
)
{
appendCommandLineFlags
(
"
-
-
gtest_filter
=
"
+
gtestFilter
)
;
}
mStdoutFilePath
=
intent
.
getStringExtra
(
NativeTestIntent
.
EXTRA_STDOUT_FILE
)
;
}
public
void
appendCommandLineFlags
(
String
flags
)
{
mCommandLineFlags
.
append
(
"
"
)
.
append
(
flags
)
;
}
public
void
postStart
(
final
Activity
activity
boolean
forceRunInSubThread
)
{
final
Runnable
runTestsTask
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
runTests
(
activity
)
;
}
}
;
if
(
mRunInSubThread
|
|
forceRunInSubThread
)
{
final
Handler
handler
=
new
Handler
(
)
;
final
Runnable
startTestThreadTask
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
new
Thread
(
runTestsTask
)
.
start
(
)
;
}
}
;
final
Runnable
postTestStarterTask
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
handler
.
post
(
startTestThreadTask
)
;
}
}
;
handler
.
post
(
postTestStarterTask
)
;
}
else
{
new
Handler
(
)
.
post
(
runTestsTask
)
;
}
}
private
void
runTests
(
Activity
activity
)
{
Natives
jni
=
NativeTestWebrtcJni
.
get
(
)
;
String
isolated_test_root
=
NativeTestWebrtc
.
getIsolatedTestRoot
(
)
;
Log
.
i
(
TAG
"
Calling
into
native
code
"
)
;
jni
.
runTests
(
mCommandLineFlags
.
toString
(
)
mCommandLineFilePath
mStdoutFilePath
isolated_test_root
)
;
Log
.
i
(
TAG
"
Call
into
native
code
returned
"
)
;
activity
.
finish
(
)
;
mReporter
.
testRunFinished
(
Process
.
myPid
(
)
)
;
}
public
static
String
getIsolatedTestRoot
(
)
{
try
(
StrictModeContext
ignored
=
StrictModeContext
.
allowDiskReads
(
)
)
{
return
Environment
.
getExternalStorageDirectory
(
)
.
getAbsolutePath
(
)
+
"
/
chromium_tests_root
"
;
}
}
private
void
nativeTestFailed
(
)
{
Log
.
e
(
TAG
"
[
RUNNER_FAILED
]
could
not
load
native
library
"
)
;
}
NativeMethods
interface
Natives
{
void
runTests
(
JniType
(
"
std
:
:
string
"
)
String
commandLineFlags
JniType
(
"
std
:
:
string
"
)
String
commandLineFilePath
JniType
(
"
std
:
:
string
"
)
String
stdoutFilePath
JniType
(
"
std
:
:
string
"
)
String
testDataDir
)
;
}
}
