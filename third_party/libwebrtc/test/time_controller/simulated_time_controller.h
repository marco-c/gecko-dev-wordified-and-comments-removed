#
ifndef
TEST_TIME_CONTROLLER_SIMULATED_TIME_CONTROLLER_H_
#
define
TEST_TIME_CONTROLLER_SIMULATED_TIME_CONTROLLER_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
test
/
time_controller
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
platform_thread_types
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
synchronization
/
yield_policy
.
h
"
namespace
webrtc
{
namespace
sim_time_impl
{
class
SimulatedSequenceRunner
{
public
:
virtual
~
SimulatedSequenceRunner
(
)
=
default
;
virtual
Timestamp
GetNextRunTime
(
)
const
=
0
;
virtual
void
RunReady
(
Timestamp
at_time
)
=
0
;
virtual
TaskQueueBase
*
GetAsTaskQueue
(
)
=
0
;
}
;
class
SimulatedTimeControllerImpl
:
public
TaskQueueFactory
public
YieldInterface
{
public
:
explicit
SimulatedTimeControllerImpl
(
Timestamp
start_time
)
;
~
SimulatedTimeControllerImpl
(
)
override
;
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
CreateTaskQueue
(
absl
:
:
string_view
name
Priority
priority
)
const
RTC_LOCKS_EXCLUDED
(
time_lock_
)
override
;
void
YieldExecution
(
)
RTC_LOCKS_EXCLUDED
(
time_lock_
lock_
)
override
;
std
:
:
unique_ptr
<
Thread
>
CreateThread
(
const
std
:
:
string
&
name
std
:
:
unique_ptr
<
SocketServer
>
socket_server
)
RTC_LOCKS_EXCLUDED
(
time_lock_
lock_
)
;
void
RunReadyRunners
(
)
RTC_LOCKS_EXCLUDED
(
time_lock_
lock_
)
;
Timestamp
CurrentTime
(
)
const
RTC_LOCKS_EXCLUDED
(
time_lock_
)
;
Timestamp
NextRunTime
(
)
const
RTC_LOCKS_EXCLUDED
(
lock_
)
;
void
AdvanceTime
(
Timestamp
target_time
)
RTC_LOCKS_EXCLUDED
(
time_lock_
)
;
void
Register
(
SimulatedSequenceRunner
*
runner
)
RTC_LOCKS_EXCLUDED
(
lock_
)
;
void
Unregister
(
SimulatedSequenceRunner
*
runner
)
RTC_LOCKS_EXCLUDED
(
lock_
)
;
void
StartYield
(
TaskQueueBase
*
yielding_from
)
;
void
StopYield
(
TaskQueueBase
*
yielding_from
)
;
private
:
const
rtc
:
:
PlatformThreadId
thread_id_
;
const
std
:
:
unique_ptr
<
Thread
>
dummy_thread_
=
Thread
:
:
Create
(
)
;
mutable
Mutex
time_lock_
;
Timestamp
current_time_
RTC_GUARDED_BY
(
time_lock_
)
;
mutable
Mutex
lock_
;
std
:
:
vector
<
SimulatedSequenceRunner
*
>
runners_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
list
<
SimulatedSequenceRunner
*
>
ready_runners_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
unordered_set
<
TaskQueueBase
*
>
yielded_
;
}
;
}
class
TokenTaskQueue
:
public
TaskQueueBase
{
public
:
using
CurrentTaskQueueSetter
=
TaskQueueBase
:
:
CurrentTaskQueueSetter
;
void
Delete
(
)
override
{
RTC_DCHECK_NOTREACHED
(
)
;
}
void
PostTaskImpl
(
absl
:
:
AnyInvocable
<
void
(
)
&
&
>
task
const
PostTaskTraits
&
traits
const
Location
&
location
)
override
{
RTC_DCHECK_NOTREACHED
(
)
;
}
void
PostDelayedTaskImpl
(
absl
:
:
AnyInvocable
<
void
(
)
&
&
>
task
TimeDelta
delay
const
PostDelayedTaskTraits
&
traits
const
Location
&
location
)
override
{
RTC_DCHECK_NOTREACHED
(
)
;
}
}
;
class
GlobalSimulatedTimeController
:
public
TimeController
{
public
:
explicit
GlobalSimulatedTimeController
(
Timestamp
start_time
)
;
~
GlobalSimulatedTimeController
(
)
override
;
Clock
*
GetClock
(
)
override
;
TaskQueueFactory
*
GetTaskQueueFactory
(
)
override
;
std
:
:
unique_ptr
<
Thread
>
CreateThread
(
const
std
:
:
string
&
name
std
:
:
unique_ptr
<
SocketServer
>
socket_server
)
override
;
Thread
*
GetMainThread
(
)
override
;
void
AdvanceTime
(
TimeDelta
duration
)
override
;
void
SkipForwardBy
(
TimeDelta
duration
)
;
void
Register
(
sim_time_impl
:
:
SimulatedSequenceRunner
*
runner
)
;
void
Unregister
(
sim_time_impl
:
:
SimulatedSequenceRunner
*
runner
)
;
private
:
ScopedBaseFakeClock
global_clock_
;
SimulatedClock
sim_clock_
;
sim_time_impl
:
:
SimulatedTimeControllerImpl
impl_
;
ScopedYieldPolicy
yield_policy_
;
std
:
:
unique_ptr
<
Thread
>
main_thread_
;
}
;
}
#
endif
