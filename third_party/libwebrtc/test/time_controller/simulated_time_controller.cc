#
include
"
test
/
time_controller
/
simulated_time_controller
.
h
"
#
include
<
algorithm
>
#
include
<
deque
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
thread
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
test
/
time_controller
/
simulated_process_thread
.
h
"
#
include
"
test
/
time_controller
/
simulated_task_queue
.
h
"
#
include
"
test
/
time_controller
/
simulated_thread
.
h
"
namespace
webrtc
{
namespace
{
template
<
class
C
>
bool
RemoveByValue
(
C
*
vec
typename
C
:
:
value_type
val
)
{
auto
it
=
std
:
:
find
(
vec
-
>
begin
(
)
vec
-
>
end
(
)
val
)
;
if
(
it
=
=
vec
-
>
end
(
)
)
return
false
;
vec
-
>
erase
(
it
)
;
return
true
;
}
}
namespace
sim_time_impl
{
SimulatedTimeControllerImpl
:
:
SimulatedTimeControllerImpl
(
Timestamp
start_time
)
:
thread_id_
(
rtc
:
:
CurrentThreadId
(
)
)
current_time_
(
start_time
)
{
}
SimulatedTimeControllerImpl
:
:
~
SimulatedTimeControllerImpl
(
)
=
default
;
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
SimulatedTimeControllerImpl
:
:
CreateTaskQueue
(
absl
:
:
string_view
name
TaskQueueFactory
:
:
Priority
priority
)
const
{
auto
mutable_this
=
const_cast
<
SimulatedTimeControllerImpl
*
>
(
this
)
;
auto
task_queue
=
std
:
:
unique_ptr
<
SimulatedTaskQueue
TaskQueueDeleter
>
(
new
SimulatedTaskQueue
(
mutable_this
name
)
)
;
;
mutable_this
-
>
Register
(
task_queue
.
get
(
)
)
;
return
task_queue
;
}
std
:
:
unique_ptr
<
ProcessThread
>
SimulatedTimeControllerImpl
:
:
CreateProcessThread
(
const
char
*
thread_name
)
{
auto
process_thread
=
std
:
:
make_unique
<
SimulatedProcessThread
>
(
this
thread_name
)
;
Register
(
process_thread
.
get
(
)
)
;
return
process_thread
;
}
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
SimulatedTimeControllerImpl
:
:
CreateThread
(
const
std
:
:
string
&
name
std
:
:
unique_ptr
<
rtc
:
:
SocketServer
>
socket_server
)
{
auto
thread
=
std
:
:
make_unique
<
SimulatedThread
>
(
this
name
std
:
:
move
(
socket_server
)
)
;
Register
(
thread
.
get
(
)
)
;
return
thread
;
}
void
SimulatedTimeControllerImpl
:
:
YieldExecution
(
)
{
if
(
rtc
:
:
CurrentThreadId
(
)
=
=
thread_id_
)
{
TaskQueueBase
*
yielding_from
=
TaskQueueBase
:
:
Current
(
)
;
TokenTaskQueue
:
:
CurrentTaskQueueSetter
reset_queue
(
nullptr
)
;
auto
inserted
=
yielded_
.
insert
(
yielding_from
)
;
RTC_DCHECK
(
inserted
.
second
)
;
RunReadyRunners
(
)
;
yielded_
.
erase
(
inserted
.
first
)
;
}
}
void
SimulatedTimeControllerImpl
:
:
RunReadyRunners
(
)
{
SimulatedThread
:
:
CurrentThreadSetter
set_current
(
dummy_thread_
.
get
(
)
)
;
MutexLock
lock
(
&
lock_
)
;
RTC_DCHECK_EQ
(
rtc
:
:
CurrentThreadId
(
)
thread_id_
)
;
Timestamp
current_time
=
CurrentTime
(
)
;
ready_runners_
.
clear
(
)
;
while
(
true
)
{
for
(
auto
*
runner
:
runners_
)
{
if
(
yielded_
.
find
(
runner
-
>
GetAsTaskQueue
(
)
)
=
=
yielded_
.
end
(
)
&
&
runner
-
>
GetNextRunTime
(
)
<
=
current_time
)
{
ready_runners_
.
push_back
(
runner
)
;
}
}
if
(
ready_runners_
.
empty
(
)
)
break
;
while
(
!
ready_runners_
.
empty
(
)
)
{
auto
*
runner
=
ready_runners_
.
front
(
)
;
ready_runners_
.
pop_front
(
)
;
lock_
.
Unlock
(
)
;
runner
-
>
RunReady
(
current_time
)
;
lock_
.
Lock
(
)
;
}
}
}
Timestamp
SimulatedTimeControllerImpl
:
:
CurrentTime
(
)
const
{
MutexLock
lock
(
&
time_lock_
)
;
return
current_time_
;
}
Timestamp
SimulatedTimeControllerImpl
:
:
NextRunTime
(
)
const
{
Timestamp
current_time
=
CurrentTime
(
)
;
Timestamp
next_time
=
Timestamp
:
:
PlusInfinity
(
)
;
MutexLock
lock
(
&
lock_
)
;
for
(
auto
*
runner
:
runners_
)
{
Timestamp
next_run_time
=
runner
-
>
GetNextRunTime
(
)
;
if
(
next_run_time
<
=
current_time
)
return
current_time
;
next_time
=
std
:
:
min
(
next_time
next_run_time
)
;
}
return
next_time
;
}
void
SimulatedTimeControllerImpl
:
:
AdvanceTime
(
Timestamp
target_time
)
{
MutexLock
time_lock
(
&
time_lock_
)
;
RTC_DCHECK_GE
(
target_time
current_time_
)
;
current_time_
=
target_time
;
}
void
SimulatedTimeControllerImpl
:
:
Register
(
SimulatedSequenceRunner
*
runner
)
{
MutexLock
lock
(
&
lock_
)
;
runners_
.
push_back
(
runner
)
;
}
void
SimulatedTimeControllerImpl
:
:
Unregister
(
SimulatedSequenceRunner
*
runner
)
{
MutexLock
lock
(
&
lock_
)
;
bool
removed
=
RemoveByValue
(
&
runners_
runner
)
;
RTC_CHECK
(
removed
)
;
RemoveByValue
(
&
ready_runners_
runner
)
;
}
void
SimulatedTimeControllerImpl
:
:
StartYield
(
TaskQueueBase
*
yielding_from
)
{
auto
inserted
=
yielded_
.
insert
(
yielding_from
)
;
RTC_DCHECK
(
inserted
.
second
)
;
}
void
SimulatedTimeControllerImpl
:
:
StopYield
(
TaskQueueBase
*
yielding_from
)
{
yielded_
.
erase
(
yielding_from
)
;
}
}
GlobalSimulatedTimeController
:
:
GlobalSimulatedTimeController
(
Timestamp
start_time
)
:
sim_clock_
(
start_time
.
us
(
)
)
impl_
(
start_time
)
yield_policy_
(
&
impl_
)
{
global_clock_
.
SetTime
(
start_time
)
;
auto
main_thread
=
std
:
:
make_unique
<
SimulatedMainThread
>
(
&
impl_
)
;
impl_
.
Register
(
main_thread
.
get
(
)
)
;
main_thread_
=
std
:
:
move
(
main_thread
)
;
}
GlobalSimulatedTimeController
:
:
~
GlobalSimulatedTimeController
(
)
=
default
;
Clock
*
GlobalSimulatedTimeController
:
:
GetClock
(
)
{
return
&
sim_clock_
;
}
TaskQueueFactory
*
GlobalSimulatedTimeController
:
:
GetTaskQueueFactory
(
)
{
return
&
impl_
;
}
std
:
:
unique_ptr
<
ProcessThread
>
GlobalSimulatedTimeController
:
:
CreateProcessThread
(
const
char
*
thread_name
)
{
return
impl_
.
CreateProcessThread
(
thread_name
)
;
}
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
GlobalSimulatedTimeController
:
:
CreateThread
(
const
std
:
:
string
&
name
std
:
:
unique_ptr
<
rtc
:
:
SocketServer
>
socket_server
)
{
return
impl_
.
CreateThread
(
name
std
:
:
move
(
socket_server
)
)
;
}
rtc
:
:
Thread
*
GlobalSimulatedTimeController
:
:
GetMainThread
(
)
{
return
main_thread_
.
get
(
)
;
}
void
GlobalSimulatedTimeController
:
:
AdvanceTime
(
TimeDelta
duration
)
{
rtc
:
:
ScopedYieldPolicy
yield_policy
(
&
impl_
)
;
Timestamp
current_time
=
impl_
.
CurrentTime
(
)
;
Timestamp
target_time
=
current_time
+
duration
;
RTC_DCHECK_EQ
(
current_time
.
us
(
)
rtc
:
:
TimeMicros
(
)
)
;
while
(
current_time
<
target_time
)
{
impl_
.
RunReadyRunners
(
)
;
Timestamp
next_time
=
std
:
:
min
(
impl_
.
NextRunTime
(
)
target_time
)
;
impl_
.
AdvanceTime
(
next_time
)
;
auto
delta
=
next_time
-
current_time
;
current_time
=
next_time
;
sim_clock_
.
AdvanceTimeMicroseconds
(
delta
.
us
(
)
)
;
global_clock_
.
AdvanceTime
(
delta
)
;
}
impl_
.
RunReadyRunners
(
)
;
}
}
