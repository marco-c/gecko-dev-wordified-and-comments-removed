#
ifndef
TEST_FRAME_GENERATOR_H_
#
define
TEST_FRAME_GENERATOR_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
test
/
frame_generator_interface
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
api
/
video
/
video_source_interface
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
test
{
class
SquareGenerator
:
public
FrameGeneratorInterface
{
public
:
SquareGenerator
(
int
width
int
height
OutputType
type
int
num_squares
)
;
void
ChangeResolution
(
size_t
width
size_t
height
)
override
;
VideoFrameData
NextFrame
(
)
override
;
private
:
rtc
:
:
scoped_refptr
<
I420Buffer
>
CreateI420Buffer
(
int
width
int
height
)
;
class
Square
{
public
:
Square
(
int
width
int
height
int
seed
)
;
void
Draw
(
const
rtc
:
:
scoped_refptr
<
VideoFrameBuffer
>
&
frame_buffer
)
;
private
:
Random
random_generator_
;
int
x_
;
int
y_
;
const
int
length_
;
const
uint8_t
yuv_y_
;
const
uint8_t
yuv_u_
;
const
uint8_t
yuv_v_
;
const
uint8_t
yuv_a_
;
}
;
Mutex
mutex_
;
const
OutputType
type_
;
int
width_
RTC_GUARDED_BY
(
&
mutex_
)
;
int
height_
RTC_GUARDED_BY
(
&
mutex_
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Square
>
>
squares_
RTC_GUARDED_BY
(
&
mutex_
)
;
}
;
class
YuvFileGenerator
:
public
FrameGeneratorInterface
{
public
:
YuvFileGenerator
(
std
:
:
vector
<
FILE
*
>
files
size_t
width
size_t
height
int
frame_repeat_count
)
;
~
YuvFileGenerator
(
)
;
VideoFrameData
NextFrame
(
)
override
;
void
ChangeResolution
(
size_t
width
size_t
height
)
override
{
RTC_NOTREACHED
(
)
;
}
private
:
bool
ReadNextFrame
(
)
;
size_t
file_index_
;
size_t
frame_index_
;
const
std
:
:
vector
<
FILE
*
>
files_
;
const
size_t
width_
;
const
size_t
height_
;
const
size_t
frame_size_
;
const
std
:
:
unique_ptr
<
uint8_t
[
]
>
frame_buffer_
;
const
int
frame_display_count_
;
int
current_display_count_
;
rtc
:
:
scoped_refptr
<
I420Buffer
>
last_read_buffer_
;
}
;
class
SlideGenerator
:
public
FrameGeneratorInterface
{
public
:
SlideGenerator
(
int
width
int
height
int
frame_repeat_count
)
;
VideoFrameData
NextFrame
(
)
override
;
void
ChangeResolution
(
size_t
width
size_t
height
)
override
{
RTC_NOTREACHED
(
)
;
}
private
:
void
GenerateNewFrame
(
)
;
const
int
width_
;
const
int
height_
;
const
int
frame_display_count_
;
int
current_display_count_
;
Random
random_generator_
;
rtc
:
:
scoped_refptr
<
I420Buffer
>
buffer_
;
}
;
class
ScrollingImageFrameGenerator
:
public
FrameGeneratorInterface
{
public
:
ScrollingImageFrameGenerator
(
Clock
*
clock
const
std
:
:
vector
<
FILE
*
>
&
files
size_t
source_width
size_t
source_height
size_t
target_width
size_t
target_height
int64_t
scroll_time_ms
int64_t
pause_time_ms
)
;
~
ScrollingImageFrameGenerator
(
)
override
=
default
;
VideoFrameData
NextFrame
(
)
override
;
void
ChangeResolution
(
size_t
width
size_t
height
)
override
{
RTC_NOTREACHED
(
)
;
}
private
:
void
UpdateSourceFrame
(
size_t
frame_num
)
;
void
CropSourceToScrolledImage
(
double
scroll_factor
)
;
Clock
*
const
clock_
;
const
int64_t
start_time_
;
const
int64_t
scroll_time_
;
const
int64_t
pause_time_
;
const
size_t
num_frames_
;
const
int
target_width_
;
const
int
target_height_
;
size_t
current_frame_num_
;
bool
prev_frame_not_scrolled_
;
VideoFrameData
current_source_frame_
;
VideoFrameData
current_frame_
;
YuvFileGenerator
file_generator_
;
}
;
}
}
#
endif
