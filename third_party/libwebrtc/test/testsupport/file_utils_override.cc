#
include
"
test
/
testsupport
/
file_utils_override
.
h
"
#
include
<
limits
.
h
>
#
include
<
stdio
.
h
>
#
if
defined
(
WEBRTC_WIN
)
#
include
<
direct
.
h
>
#
include
<
tchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
algorithm
>
#
include
<
codecvt
>
#
include
<
locale
>
#
include
"
Shlwapi
.
h
"
#
include
"
WinDef
.
h
"
#
include
"
rtc_base
/
win32
.
h
"
#
define
GET_CURRENT_DIR
_getcwd
#
else
#
include
<
unistd
.
h
>
#
define
GET_CURRENT_DIR
getcwd
#
endif
#
if
defined
(
WEBRTC_IOS
)
#
include
"
test
/
testsupport
/
ios_file_utils
.
h
"
#
endif
#
if
defined
(
WEBRTC_MAC
)
#
include
"
test
/
testsupport
/
mac_file_utils
.
h
"
#
endif
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
string_utils
.
h
"
namespace
webrtc
{
namespace
test
{
std
:
:
string
DirName
(
const
std
:
:
string
&
path
)
;
bool
CreateDir
(
const
std
:
:
string
&
directory_name
)
;
namespace
internal
{
namespace
{
#
if
defined
(
WEBRTC_WIN
)
const
char
*
kPathDelimiter
=
"
\
\
"
;
#
elif
!
defined
(
WEBRTC_IOS
)
const
char
*
kPathDelimiter
=
"
/
"
;
#
endif
#
if
defined
(
WEBRTC_ANDROID
)
const
char
*
kAndroidChromiumTestsRoot
=
"
/
sdcard
/
chromium_tests_root
/
"
;
#
endif
#
if
!
defined
(
WEBRTC_IOS
)
const
char
*
kResourcesDirName
=
"
resources
"
;
#
endif
}
absl
:
:
optional
<
std
:
:
string
>
ProjectRootPath
(
)
{
#
if
defined
(
WEBRTC_ANDROID
)
return
kAndroidChromiumTestsRoot
;
#
elif
defined
WEBRTC_IOS
return
IOSRootPath
(
)
;
#
elif
defined
(
WEBRTC_MAC
)
std
:
:
string
path
;
GetNSExecutablePath
(
&
path
)
;
std
:
:
string
exe_dir
=
DirName
(
path
)
;
return
DirName
(
DirName
(
exe_dir
)
)
+
kPathDelimiter
;
#
elif
defined
(
WEBRTC_POSIX
)
char
buf
[
PATH_MAX
]
;
ssize_t
count
=
:
:
readlink
(
"
/
proc
/
self
/
exe
"
buf
arraysize
(
buf
)
)
;
if
(
count
<
=
0
)
{
RTC_NOTREACHED
(
)
<
<
"
Unable
to
resolve
/
proc
/
self
/
exe
.
"
;
return
absl
:
:
nullopt
;
}
std
:
:
string
exe_dir
=
DirName
(
std
:
:
string
(
buf
count
)
)
;
return
DirName
(
DirName
(
exe_dir
)
)
+
kPathDelimiter
;
#
elif
defined
(
WEBRTC_WIN
)
wchar_t
buf
[
MAX_PATH
]
;
buf
[
0
]
=
0
;
if
(
GetModuleFileNameW
(
NULL
buf
MAX_PATH
)
=
=
0
)
return
absl
:
:
nullopt
;
std
:
:
string
exe_path
=
rtc
:
:
ToUtf8
(
std
:
:
wstring
(
buf
)
)
;
std
:
:
string
exe_dir
=
DirName
(
exe_path
)
;
return
DirName
(
DirName
(
exe_dir
)
)
+
kPathDelimiter
;
#
endif
}
std
:
:
string
OutputPath
(
)
{
#
if
defined
(
WEBRTC_IOS
)
return
IOSOutputPath
(
)
;
#
elif
defined
(
WEBRTC_ANDROID
)
return
kAndroidChromiumTestsRoot
;
#
else
absl
:
:
optional
<
std
:
:
string
>
path_opt
=
ProjectRootPath
(
)
;
RTC_DCHECK
(
path_opt
)
;
std
:
:
string
path
=
*
path_opt
+
"
out
"
;
if
(
!
CreateDir
(
path
)
)
{
return
"
.
/
"
;
}
return
path
+
kPathDelimiter
;
#
endif
}
std
:
:
string
WorkingDir
(
)
{
#
if
defined
(
WEBRTC_ANDROID
)
return
kAndroidChromiumTestsRoot
;
#
else
char
path_buffer
[
FILENAME_MAX
]
;
if
(
!
GET_CURRENT_DIR
(
path_buffer
sizeof
(
path_buffer
)
)
)
{
fprintf
(
stderr
"
Cannot
get
current
directory
!
\
n
"
)
;
return
"
.
/
"
;
}
else
{
return
std
:
:
string
(
path_buffer
)
;
}
#
endif
}
std
:
:
string
ResourcePath
(
const
std
:
:
string
&
name
const
std
:
:
string
&
extension
)
{
#
if
defined
(
WEBRTC_IOS
)
return
IOSResourcePath
(
name
extension
)
;
#
else
absl
:
:
optional
<
std
:
:
string
>
path_opt
=
ProjectRootPath
(
)
;
RTC_DCHECK
(
path_opt
)
;
std
:
:
string
resources_path
=
*
path_opt
+
kResourcesDirName
+
kPathDelimiter
;
return
resources_path
+
name
+
"
.
"
+
extension
;
#
endif
}
}
}
}
