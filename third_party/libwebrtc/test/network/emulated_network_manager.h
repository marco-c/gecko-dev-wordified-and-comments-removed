#
ifndef
TEST_NETWORK_EMULATED_NETWORK_MANAGER_H_
#
define
TEST_NETWORK_EMULATED_NETWORK_MANAGER_H_
#
include
<
functional
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
test
/
network_emulation_manager
.
h
"
#
include
"
api
/
test
/
time_controller
.
h
"
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
socket_server
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
test
/
network
/
network_emulation
.
h
"
namespace
webrtc
{
namespace
test
{
class
EmulatedNetworkManager
:
public
rtc
:
:
NetworkManagerBase
public
sigslot
:
:
has_slots
<
>
public
EmulatedNetworkManagerInterface
{
public
:
EmulatedNetworkManager
(
TimeController
*
time_controller
TaskQueueForTest
*
task_queue
EndpointsContainer
*
endpoints_container
)
;
void
EnableEndpoint
(
EmulatedEndpointImpl
*
endpoint
)
;
void
DisableEndpoint
(
EmulatedEndpointImpl
*
endpoint
)
;
void
StartUpdating
(
)
override
;
void
StopUpdating
(
)
override
;
std
:
:
vector
<
const
rtc
:
:
Network
*
>
GetAnyAddressNetworks
(
)
override
{
return
{
}
;
}
rtc
:
:
Thread
*
network_thread
(
)
override
{
return
network_thread_
.
get
(
)
;
}
rtc
:
:
NetworkManager
*
network_manager
(
)
override
{
return
this
;
}
rtc
:
:
PacketSocketFactory
*
packet_socket_factory
(
)
override
{
return
packet_socket_factory_
.
get
(
)
;
}
std
:
:
vector
<
EmulatedEndpoint
*
>
endpoints
(
)
const
override
{
return
endpoints_container_
-
>
GetEndpoints
(
)
;
}
void
GetStats
(
std
:
:
function
<
void
(
EmulatedNetworkStats
)
>
stats_callback
)
const
override
;
private
:
void
UpdateNetworksOnce
(
)
;
void
MaybeSignalNetworksChanged
(
)
;
TaskQueueForTest
*
const
task_queue_
;
const
EndpointsContainer
*
const
endpoints_container_
;
std
:
:
unique_ptr
<
rtc
:
:
Thread
>
network_thread_
;
std
:
:
unique_ptr
<
rtc
:
:
PacketSocketFactory
>
packet_socket_factory_
;
bool
sent_first_update_
RTC_GUARDED_BY
(
network_thread_
)
;
int
start_count_
RTC_GUARDED_BY
(
network_thread_
)
;
}
;
}
}
#
endif
