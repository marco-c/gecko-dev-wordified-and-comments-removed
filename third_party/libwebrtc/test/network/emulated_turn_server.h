#
ifndef
TEST_NETWORK_EMULATED_TURN_SERVER_H_
#
define
TEST_NETWORK_EMULATED_TURN_SERVER_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
test
/
network_emulation
/
network_emulation_interfaces
.
h
"
#
include
"
api
/
test
/
network_emulation_manager
.
h
"
#
include
"
api
/
transport
/
stun
.
h
"
#
include
"
p2p
/
test
/
turn_server
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
namespace
test
{
class
EmulatedTURNServer
:
public
EmulatedTURNServerInterface
public
TurnAuthInterface
public
webrtc
:
:
EmulatedNetworkReceiverInterface
{
public
:
EmulatedTURNServer
(
const
EmulatedTURNServerConfig
&
config
std
:
:
unique_ptr
<
Thread
>
thread
EmulatedEndpoint
*
client
EmulatedEndpoint
*
peer
)
;
~
EmulatedTURNServer
(
)
override
;
IceServerConfig
GetIceServerConfig
(
)
const
override
{
return
ice_config_
;
}
EmulatedEndpoint
*
GetClientEndpoint
(
)
const
override
{
return
client_
;
}
SocketAddress
GetClientEndpointAddress
(
)
const
override
{
return
client_address_
;
}
EmulatedEndpoint
*
GetPeerEndpoint
(
)
const
override
{
return
peer_
;
}
bool
GetKey
(
absl
:
:
string_view
username
absl
:
:
string_view
realm
std
:
:
string
*
key
)
override
{
return
ComputeStunCredentialHash
(
std
:
:
string
(
username
)
std
:
:
string
(
realm
)
std
:
:
string
(
username
)
key
)
;
}
AsyncPacketSocket
*
CreatePeerSocket
(
)
{
return
Wrap
(
peer_
)
;
}
void
OnPacketReceived
(
webrtc
:
:
EmulatedIpPacket
packet
)
override
;
void
Unbind
(
SocketAddress
address
)
;
void
Stop
(
)
;
private
:
std
:
:
unique_ptr
<
Thread
>
thread_
;
SocketAddress
client_address_
;
IceServerConfig
ice_config_
;
EmulatedEndpoint
*
const
client_
;
EmulatedEndpoint
*
const
peer_
;
std
:
:
unique_ptr
<
TurnServer
>
turn_server_
RTC_GUARDED_BY
(
&
thread_
)
;
class
AsyncPacketSocketWrapper
;
std
:
:
map
<
SocketAddress
AsyncPacketSocketWrapper
*
>
sockets_
RTC_GUARDED_BY
(
&
thread_
)
;
AsyncPacketSocket
*
Wrap
(
EmulatedEndpoint
*
endpoint
)
;
}
;
}
}
#
endif
