#
ifndef
TEST_WAIT_UNTIL_H_
#
define
TEST_WAIT_UNTIL_H_
#
include
<
string
>
#
include
"
absl
/
types
/
variant
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
test
/
time_controller
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
wait_until_internal
.
h
"
namespace
webrtc
{
using
ClockVariant
=
absl
:
:
variant
<
absl
:
:
monostate
SimulatedClock
*
rtc
:
:
FakeClock
*
rtc
:
:
ThreadProcessingFakeClock
*
TimeController
*
>
;
namespace
wait_until_internal
{
Timestamp
GetTimeFromClockVariant
(
const
ClockVariant
&
clock
)
;
void
AdvanceTimeOnClockVariant
(
ClockVariant
&
clock
TimeDelta
delta
)
;
}
struct
WaitUntilSettings
{
TimeDelta
timeout
=
TimeDelta
:
:
Seconds
(
5
)
;
TimeDelta
polling_interval
=
TimeDelta
:
:
Millis
(
1
)
;
ClockVariant
clock
=
absl
:
:
monostate
(
)
;
std
:
:
string
result_name
=
"
result
"
;
}
;
template
<
typename
Fn
typename
Matcher
>
[
[
nodiscard
]
]
auto
WaitUntil
(
const
Fn
&
fn
Matcher
matcher
WaitUntilSettings
settings
=
{
}
)
-
>
RTCErrorOr
<
decltype
(
fn
(
)
)
>
{
if
(
absl
:
:
holds_alternative
<
absl
:
:
monostate
>
(
settings
.
clock
)
)
{
RTC_CHECK
(
rtc
:
:
Thread
:
:
Current
(
)
)
<
<
"
A
current
thread
is
required
.
An
"
"
rtc
:
:
AutoThread
can
work
for
tests
.
"
;
}
Timestamp
start
=
wait_until_internal
:
:
GetTimeFromClockVariant
(
settings
.
clock
)
;
do
{
auto
result
=
fn
(
)
;
if
(
:
:
testing
:
:
Value
(
result
matcher
)
)
{
return
result
;
}
wait_until_internal
:
:
AdvanceTimeOnClockVariant
(
settings
.
clock
settings
.
polling_interval
)
;
}
while
(
wait_until_internal
:
:
GetTimeFromClockVariant
(
settings
.
clock
)
<
start
+
settings
.
timeout
)
;
auto
result
=
fn
(
)
;
:
:
testing
:
:
StringMatchResultListener
listener
;
if
(
wait_until_internal
:
:
ExplainMatchResult
(
matcher
result
&
listener
settings
.
result_name
)
)
{
return
result
;
}
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
listener
.
str
(
)
)
;
}
}
#
endif
