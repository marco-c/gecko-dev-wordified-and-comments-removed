#
ifndef
TEST_WAIT_UNTIL_H_
#
define
TEST_WAIT_UNTIL_H_
#
include
<
string
>
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
wait_until_internal
.
h
"
namespace
webrtc
{
struct
WaitUntilSettings
{
TimeDelta
timeout
=
TimeDelta
:
:
Seconds
(
5
)
;
TimeDelta
polling_interval
=
TimeDelta
:
:
Millis
(
1
)
;
absl
:
:
Nullable
<
SimulatedClock
*
>
clock
=
nullptr
;
std
:
:
string
result_name
=
"
result
"
;
}
;
template
<
typename
Fn
typename
Matcher
>
auto
WaitUntil
(
const
Fn
&
fn
Matcher
matcher
WaitUntilSettings
settings
=
{
}
)
-
>
RTCErrorOr
<
decltype
(
fn
(
)
)
>
{
if
(
!
settings
.
clock
)
{
RTC_CHECK
(
rtc
:
:
Thread
:
:
Current
(
)
)
<
<
"
A
current
thread
is
required
.
An
"
"
rtc
:
:
AutoThread
can
work
for
tests
.
"
;
}
absl
:
:
Nonnull
<
Clock
*
>
clock
=
settings
.
clock
?
settings
.
clock
:
Clock
:
:
GetRealTimeClock
(
)
;
Timestamp
start
=
clock
-
>
CurrentTime
(
)
;
do
{
auto
result
=
fn
(
)
;
if
(
testing
:
:
Value
(
result
matcher
)
)
{
return
result
;
}
if
(
settings
.
clock
)
{
settings
.
clock
-
>
AdvanceTime
(
settings
.
polling_interval
)
;
}
else
{
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
0
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
SleepMs
(
settings
.
polling_interval
.
ms
(
)
)
;
}
}
while
(
clock
-
>
CurrentTime
(
)
<
start
+
settings
.
timeout
)
;
auto
result
=
fn
(
)
;
testing
:
:
StringMatchResultListener
listener
;
if
(
wait_until_internal
:
:
ExplainMatchResult
(
matcher
result
&
listener
settings
.
result_name
)
)
{
return
result
;
}
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
listener
.
str
(
)
)
;
}
}
#
endif
