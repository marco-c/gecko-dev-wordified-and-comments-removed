#
ifndef
TEST_WAIT_UNTIL_H_
#
define
TEST_WAIT_UNTIL_H_
#
include
<
optional
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
variant
>
#
include
"
api
/
function_view
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
test
/
time_controller
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
wait_until_internal
.
h
"
namespace
webrtc
{
using
ClockVariant
=
std
:
:
variant
<
std
:
:
monostate
SimulatedClock
*
FakeClock
*
ThreadProcessingFakeClock
*
TimeController
*
>
;
struct
WaitUntilSettings
{
TimeDelta
timeout
=
TimeDelta
:
:
Seconds
(
5
)
;
TimeDelta
polling_interval
=
TimeDelta
:
:
Millis
(
1
)
;
ClockVariant
clock
=
std
:
:
monostate
(
)
;
std
:
:
string
result_name
=
"
result
"
;
}
;
[
[
nodiscard
]
]
bool
WaitUntil
(
FunctionView
<
bool
(
)
>
fn
WaitUntilSettings
settings
=
{
}
)
;
template
<
typename
Fn
>
[
[
nodiscard
]
]
RTCErrorOr
<
std
:
:
invoke_result_t
<
Fn
>
>
WaitUntil
(
const
Fn
&
fn
:
:
testing
:
:
Matcher
<
std
:
:
invoke_result_t
<
Fn
>
>
matcher
WaitUntilSettings
settings
=
{
}
)
{
std
:
:
optional
<
std
:
:
invoke_result_t
<
Fn
>
>
result
;
bool
ok
=
WaitUntil
(
[
&
]
{
result
.
emplace
(
fn
(
)
)
;
return
:
:
testing
:
:
Value
(
*
result
matcher
)
;
}
settings
)
;
RTC_CHECK
(
result
.
has_value
(
)
)
;
if
(
ok
)
{
return
*
std
:
:
move
(
result
)
;
}
:
:
testing
:
:
StringMatchResultListener
listener
;
wait_until_internal
:
:
ExplainMatchResult
(
matcher
*
result
&
listener
settings
.
result_name
)
;
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
listener
.
str
(
)
)
;
}
}
#
endif
