#
include
"
audio
/
voip
/
audio_egress
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_encoder_factory
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
audio_mixer
/
sine_wave_generator
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_rtcp_impl2
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
mock_transport
.
h
"
#
include
"
test
/
run_loop
.
h
"
#
include
"
test
/
time_controller
/
simulated_time_controller
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
Unused
;
std
:
:
unique_ptr
<
ModuleRtpRtcpImpl2
>
CreateRtpStack
(
Clock
*
clock
Transport
*
transport
uint32_t
remote_ssrc
)
{
RtpRtcpInterface
:
:
Configuration
rtp_config
;
rtp_config
.
clock
=
clock
;
rtp_config
.
audio
=
true
;
rtp_config
.
rtcp_report_interval_ms
=
5000
;
rtp_config
.
outgoing_transport
=
transport
;
rtp_config
.
local_media_ssrc
=
remote_ssrc
;
auto
rtp_rtcp
=
ModuleRtpRtcpImpl2
:
:
Create
(
rtp_config
)
;
rtp_rtcp
-
>
SetSendingMediaStatus
(
false
)
;
rtp_rtcp
-
>
SetRTCPStatus
(
RtcpMode
:
:
kCompound
)
;
return
rtp_rtcp
;
}
constexpr
int16_t
kAudioLevel
=
3004
;
class
AudioEgressTest
:
public
:
:
testing
:
:
Test
{
public
:
static
constexpr
uint16_t
kSeqNum
=
12345
;
static
constexpr
uint64_t
kStartTime
=
123456789
;
static
constexpr
uint32_t
kRemoteSsrc
=
0xDEADBEEF
;
const
SdpAudioFormat
kPcmuFormat
=
{
"
pcmu
"
8000
1
}
;
AudioEgressTest
(
)
:
wave_generator_
(
1000
.
0
kAudioLevel
)
{
encoder_factory_
=
CreateBuiltinAudioEncoderFactory
(
)
;
}
void
SetUp
(
)
override
{
rtp_rtcp_
=
CreateRtpStack
(
time_controller_
.
GetClock
(
)
&
transport_
kRemoteSsrc
)
;
egress_
=
std
:
:
make_unique
<
AudioEgress
>
(
rtp_rtcp_
.
get
(
)
time_controller_
.
GetClock
(
)
time_controller_
.
GetTaskQueueFactory
(
)
)
;
constexpr
int
kPcmuPayload
=
0
;
egress_
-
>
SetEncoder
(
kPcmuPayload
kPcmuFormat
encoder_factory_
-
>
Create
(
env_
kPcmuFormat
{
.
payload_type
=
kPcmuPayload
}
)
)
;
egress_
-
>
StartSend
(
)
;
rtp_rtcp_
-
>
SetSequenceNumber
(
kSeqNum
)
;
rtp_rtcp_
-
>
SetSendingStatus
(
true
)
;
}
void
TearDown
(
)
override
{
egress_
-
>
StopSend
(
)
;
rtp_rtcp_
-
>
SetSendingStatus
(
false
)
;
egress_
.
reset
(
)
;
rtp_rtcp_
.
reset
(
)
;
}
std
:
:
unique_ptr
<
AudioFrame
>
GetAudioFrame
(
int
order
)
{
auto
frame
=
std
:
:
make_unique
<
AudioFrame
>
(
)
;
frame
-
>
sample_rate_hz_
=
kPcmuFormat
.
clockrate_hz
;
frame
-
>
samples_per_channel_
=
kPcmuFormat
.
clockrate_hz
/
100
;
frame
-
>
num_channels_
=
kPcmuFormat
.
num_channels
;
frame
-
>
timestamp_
=
frame
-
>
samples_per_channel_
*
order
;
wave_generator_
.
GenerateNextFrame
(
frame
.
get
(
)
)
;
return
frame
;
}
GlobalSimulatedTimeController
time_controller_
{
Timestamp
:
:
Micros
(
kStartTime
)
}
;
const
Environment
env_
=
CreateEnvironment
(
time_controller_
.
GetClock
(
)
time_controller_
.
GetTaskQueueFactory
(
)
)
;
NiceMock
<
MockTransport
>
transport_
;
SineWaveGenerator
wave_generator_
;
std
:
:
unique_ptr
<
ModuleRtpRtcpImpl2
>
rtp_rtcp_
;
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
encoder_factory_
;
std
:
:
unique_ptr
<
AudioEgress
>
egress_
;
}
;
TEST_F
(
AudioEgressTest
SendingStatusAfterStartAndStop
)
{
EXPECT_TRUE
(
egress_
-
>
IsSending
(
)
)
;
egress_
-
>
StopSend
(
)
;
EXPECT_FALSE
(
egress_
-
>
IsSending
(
)
)
;
}
TEST_F
(
AudioEgressTest
ProcessAudioWithMute
)
{
constexpr
int
kExpected
=
10
;
rtc
:
:
Event
event
;
int
rtp_count
=
0
;
RtpPacketReceived
rtp
;
auto
rtp_sent
=
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
Unused
)
{
rtp
.
Parse
(
packet
)
;
if
(
+
+
rtp_count
=
=
kExpected
)
{
event
.
Set
(
)
;
}
return
true
;
}
;
EXPECT_CALL
(
transport_
SendRtp
)
.
WillRepeatedly
(
Invoke
(
rtp_sent
)
)
;
egress_
-
>
SetMute
(
true
)
;
for
(
size_t
i
=
0
;
i
<
kExpected
*
2
;
i
+
+
)
{
egress_
-
>
SendAudioData
(
GetAudioFrame
(
i
)
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
}
event
.
Wait
(
TimeDelta
:
:
Seconds
(
1
)
)
;
EXPECT_EQ
(
rtp_count
kExpected
)
;
RTPHeader
header
;
rtp
.
GetHeader
(
&
header
)
;
size_t
packet_length
=
rtp
.
size
(
)
;
size_t
payload_length
=
packet_length
-
header
.
headerLength
;
size_t
payload_data_length
=
payload_length
-
header
.
paddingLength
;
const
uint8_t
*
payload
=
rtp
.
data
(
)
+
header
.
headerLength
;
for
(
size_t
i
=
0
;
i
<
payload_data_length
;
+
+
i
)
{
EXPECT_EQ
(
*
payload
+
+
255
)
;
}
}
TEST_F
(
AudioEgressTest
ProcessAudioWithSineWave
)
{
constexpr
int
kExpected
=
10
;
rtc
:
:
Event
event
;
int
rtp_count
=
0
;
RtpPacketReceived
rtp
;
auto
rtp_sent
=
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
Unused
)
{
rtp
.
Parse
(
packet
)
;
if
(
+
+
rtp_count
=
=
kExpected
)
{
event
.
Set
(
)
;
}
return
true
;
}
;
EXPECT_CALL
(
transport_
SendRtp
)
.
WillRepeatedly
(
Invoke
(
rtp_sent
)
)
;
for
(
size_t
i
=
0
;
i
<
kExpected
*
2
;
i
+
+
)
{
egress_
-
>
SendAudioData
(
GetAudioFrame
(
i
)
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
}
event
.
Wait
(
TimeDelta
:
:
Seconds
(
1
)
)
;
EXPECT_EQ
(
rtp_count
kExpected
)
;
RTPHeader
header
;
rtp
.
GetHeader
(
&
header
)
;
size_t
packet_length
=
rtp
.
size
(
)
;
size_t
payload_length
=
packet_length
-
header
.
headerLength
;
size_t
payload_data_length
=
payload_length
-
header
.
paddingLength
;
const
uint8_t
*
payload
=
rtp
.
data
(
)
+
header
.
headerLength
;
for
(
size_t
i
=
0
;
i
<
payload_data_length
;
+
+
i
)
{
EXPECT_NE
(
*
payload
+
+
255
)
;
}
}
TEST_F
(
AudioEgressTest
SkipAudioEncodingAfterStopSend
)
{
constexpr
int
kExpected
=
10
;
rtc
:
:
Event
event
;
int
rtp_count
=
0
;
auto
rtp_sent
=
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
Unused
)
{
if
(
+
+
rtp_count
=
=
kExpected
)
{
event
.
Set
(
)
;
}
return
true
;
}
;
EXPECT_CALL
(
transport_
SendRtp
)
.
WillRepeatedly
(
Invoke
(
rtp_sent
)
)
;
for
(
size_t
i
=
0
;
i
<
kExpected
*
2
;
i
+
+
)
{
egress_
-
>
SendAudioData
(
GetAudioFrame
(
i
)
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
}
event
.
Wait
(
TimeDelta
:
:
Seconds
(
1
)
)
;
EXPECT_EQ
(
rtp_count
kExpected
)
;
egress_
-
>
StopSend
(
)
;
for
(
size_t
i
=
0
;
i
<
kExpected
*
2
;
i
+
+
)
{
egress_
-
>
SendAudioData
(
GetAudioFrame
(
i
)
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
}
}
TEST_F
(
AudioEgressTest
ChangeEncoderFromPcmuToOpus
)
{
absl
:
:
optional
<
SdpAudioFormat
>
pcmu
=
egress_
-
>
GetEncoderFormat
(
)
;
EXPECT_TRUE
(
pcmu
)
;
EXPECT_EQ
(
pcmu
-
>
clockrate_hz
kPcmuFormat
.
clockrate_hz
)
;
EXPECT_EQ
(
pcmu
-
>
num_channels
kPcmuFormat
.
num_channels
)
;
constexpr
int
kOpusPayload
=
120
;
const
SdpAudioFormat
kOpusFormat
=
{
"
opus
"
48000
2
}
;
egress_
-
>
SetEncoder
(
kOpusPayload
kOpusFormat
encoder_factory_
-
>
Create
(
env_
kOpusFormat
{
.
payload_type
=
kOpusPayload
}
)
)
;
absl
:
:
optional
<
SdpAudioFormat
>
opus
=
egress_
-
>
GetEncoderFormat
(
)
;
EXPECT_TRUE
(
opus
)
;
EXPECT_EQ
(
opus
-
>
clockrate_hz
kOpusFormat
.
clockrate_hz
)
;
EXPECT_EQ
(
opus
-
>
num_channels
kOpusFormat
.
num_channels
)
;
}
TEST_F
(
AudioEgressTest
SendDTMF
)
{
constexpr
int
kExpected
=
7
;
constexpr
int
kPayloadType
=
100
;
constexpr
int
kDurationMs
=
100
;
constexpr
int
kSampleRate
=
8000
;
constexpr
int
kEvent
=
3
;
egress_
-
>
RegisterTelephoneEventType
(
kPayloadType
kSampleRate
)
;
egress_
-
>
SendTelephoneEvent
(
kEvent
kDurationMs
)
;
rtc
:
:
Event
event
;
int
dtmf_count
=
0
;
auto
is_dtmf
=
[
&
]
(
RtpPacketReceived
&
rtp
)
{
return
(
rtp
.
PayloadType
(
)
=
=
kPayloadType
&
&
rtp
.
SequenceNumber
(
)
=
=
kSeqNum
+
dtmf_count
&
&
rtp
.
padding_size
(
)
=
=
0
&
&
rtp
.
Marker
(
)
=
=
(
dtmf_count
=
=
0
)
&
&
rtp
.
Ssrc
(
)
=
=
kRemoteSsrc
)
;
}
;
auto
rtp_sent
=
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
Unused
)
{
RtpPacketReceived
rtp
;
rtp
.
Parse
(
packet
)
;
if
(
is_dtmf
(
rtp
)
&
&
+
+
dtmf_count
=
=
kExpected
)
{
event
.
Set
(
)
;
}
return
true
;
}
;
EXPECT_CALL
(
transport_
SendRtp
)
.
WillRepeatedly
(
Invoke
(
rtp_sent
)
)
;
for
(
size_t
i
=
0
;
i
<
kExpected
*
2
;
i
+
+
)
{
egress_
-
>
SendAudioData
(
GetAudioFrame
(
i
)
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
}
event
.
Wait
(
TimeDelta
:
:
Seconds
(
1
)
)
;
EXPECT_EQ
(
dtmf_count
kExpected
)
;
}
TEST_F
(
AudioEgressTest
TestAudioInputLevelAndEnergyDuration
)
{
constexpr
int
kExpected
=
6
;
rtc
:
:
Event
event
;
int
rtp_count
=
0
;
auto
rtp_sent
=
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
Unused
)
{
if
(
+
+
rtp_count
=
=
kExpected
)
{
event
.
Set
(
)
;
}
return
true
;
}
;
EXPECT_CALL
(
transport_
SendRtp
)
.
WillRepeatedly
(
Invoke
(
rtp_sent
)
)
;
for
(
size_t
i
=
0
;
i
<
kExpected
*
2
;
i
+
+
)
{
egress_
-
>
SendAudioData
(
GetAudioFrame
(
i
)
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
}
event
.
Wait
(
TimeDelta
:
:
Seconds
(
1
)
)
;
EXPECT_EQ
(
rtp_count
kExpected
)
;
constexpr
double
kExpectedEnergy
=
0
.
00016809565587789564
;
constexpr
double
kExpectedDuration
=
0
.
11999999999999998
;
EXPECT_EQ
(
egress_
-
>
GetInputAudioLevel
(
)
kAudioLevel
)
;
EXPECT_DOUBLE_EQ
(
egress_
-
>
GetInputTotalEnergy
(
)
kExpectedEnergy
)
;
EXPECT_DOUBLE_EQ
(
egress_
-
>
GetInputTotalDuration
(
)
kExpectedDuration
)
;
}
}
}
