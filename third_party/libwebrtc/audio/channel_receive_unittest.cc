#
include
"
audio
/
channel_receive
.
h
"
#
include
"
absl
/
strings
/
escaping
.
h
"
#
include
"
api
/
audio
/
audio_device
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
api
/
crypto
/
frame_decryptor_interface
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
test
/
mock_frame_transformer
.
h
"
#
include
"
modules
/
audio_device
/
include
/
mock_audio_device
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
ntp_time_util
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
receiver_report
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
report_block
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
sdes
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
sender_report
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
mock_audio_decoder_factory
.
h
"
#
include
"
test
/
mock_transport
.
h
"
#
include
"
test
/
time_controller
/
simulated_time_controller
.
h
"
namespace
webrtc
{
namespace
voe
{
namespace
{
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
NotNull
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
Test
;
constexpr
uint32_t
kLocalSsrc
=
1111
;
constexpr
uint32_t
kRemoteSsrc
=
2222
;
constexpr
char
kPayloadName
[
]
=
"
PCMA
"
;
constexpr
int
kPayloadType
=
8
;
constexpr
int
kSampleRateHz
=
8000
;
class
ChannelReceiveTest
:
public
Test
{
public
:
ChannelReceiveTest
(
)
:
time_controller_
(
Timestamp
:
:
Seconds
(
5555
)
)
audio_device_module_
(
test
:
:
MockAudioDeviceModule
:
:
CreateNice
(
)
)
audio_decoder_factory_
(
CreateBuiltinAudioDecoderFactory
(
)
)
{
ON_CALL
(
*
audio_device_module_
PlayoutDelay
)
.
WillByDefault
(
Return
(
0
)
)
;
}
std
:
:
unique_ptr
<
ChannelReceiveInterface
>
CreateTestChannelReceive
(
)
{
CryptoOptions
crypto_options
;
auto
channel
=
CreateChannelReceive
(
CreateEnvironment
(
time_controller_
.
GetClock
(
)
)
nullptr
audio_device_module_
.
get
(
)
&
transport_
kLocalSsrc
kRemoteSsrc
0
false
0
false
audio_decoder_factory_
std
:
:
nullopt
nullptr
crypto_options
nullptr
)
;
channel
-
>
SetReceiveCodecs
(
{
{
kPayloadType
{
kPayloadName
kSampleRateHz
1
}
}
}
)
;
return
channel
;
}
NtpTime
NtpNow
(
)
{
return
time_controller_
.
GetClock
(
)
-
>
CurrentNtpTime
(
)
;
}
uint32_t
RtpNow
(
)
{
return
TimeMillis
(
)
*
1000
/
kSampleRateHz
;
}
RtpPacketReceived
CreateRtpPacket
(
)
{
RtpPacketReceived
packet
;
packet
.
set_arrival_time
(
time_controller_
.
GetClock
(
)
-
>
CurrentTime
(
)
)
;
packet
.
SetTimestamp
(
RtpNow
(
)
)
;
packet
.
SetSsrc
(
kLocalSsrc
)
;
packet
.
SetPayloadType
(
kPayloadType
)
;
uint8_t
*
datapos
=
packet
.
SetPayloadSize
(
100
)
;
memset
(
datapos
0
100
)
;
return
packet
;
}
std
:
:
vector
<
uint8_t
>
CreateRtcpSenderReport
(
)
{
std
:
:
vector
<
uint8_t
>
packet
(
1024
)
;
size_t
pos
=
0
;
rtcp
:
:
SenderReport
report
;
report
.
SetSenderSsrc
(
kRemoteSsrc
)
;
report
.
SetNtp
(
NtpNow
(
)
)
;
report
.
SetRtpTimestamp
(
RtpNow
(
)
)
;
report
.
SetPacketCount
(
0
)
;
report
.
SetOctetCount
(
0
)
;
report
.
Create
(
&
packet
[
0
]
&
pos
packet
.
size
(
)
nullptr
)
;
packet
.
resize
(
pos
)
;
return
packet
;
}
std
:
:
vector
<
uint8_t
>
CreateRtcpReceiverReport
(
)
{
rtcp
:
:
ReportBlock
block
;
block
.
SetMediaSsrc
(
kLocalSsrc
)
;
block
.
SetLastSr
(
CompactNtp
(
NtpNow
(
)
)
)
;
block
.
SetDelayLastSr
(
0
)
;
rtcp
:
:
ReceiverReport
report
;
report
.
SetSenderSsrc
(
kRemoteSsrc
)
;
report
.
AddReportBlock
(
block
)
;
std
:
:
vector
<
uint8_t
>
packet
(
1024
)
;
size_t
pos
=
0
;
report
.
Create
(
&
packet
[
0
]
&
pos
packet
.
size
(
)
nullptr
)
;
packet
.
resize
(
pos
)
;
return
packet
;
}
void
HandleGeneratedRtcp
(
ChannelReceiveInterface
&
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
{
if
(
packet
[
1
]
=
=
rtcp
:
:
ReceiverReport
:
:
kPacketType
)
{
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unexpected
RTCP
packet
generated
"
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Packet
content
"
<
<
hex_encode_with_delimiter
(
absl
:
:
string_view
(
reinterpret_cast
<
char
*
>
(
packet
.
data
(
)
[
0
]
)
packet
.
size
(
)
)
'
'
)
;
}
}
int64_t
ProbeCaptureStartNtpTime
(
ChannelReceiveInterface
&
channel
)
{
AudioFrame
audio_frame
;
channel
.
OnRtpPacket
(
CreateRtpPacket
(
)
)
;
channel
.
GetAudioFrameWithInfo
(
kSampleRateHz
&
audio_frame
)
;
CallReceiveStatistics
stats
=
channel
.
GetRTCPStatistics
(
)
;
return
stats
.
capture_start_ntp_time_ms
;
}
protected
:
GlobalSimulatedTimeController
time_controller_
;
rtc
:
:
scoped_refptr
<
test
:
:
MockAudioDeviceModule
>
audio_device_module_
;
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory_
;
MockTransport
transport_
;
}
;
TEST_F
(
ChannelReceiveTest
CreateAndDestroy
)
{
auto
channel
=
CreateTestChannelReceive
(
)
;
EXPECT_THAT
(
channel
NotNull
(
)
)
;
}
TEST_F
(
ChannelReceiveTest
ReceiveReportGeneratedOnTime
)
{
auto
channel
=
CreateTestChannelReceive
(
)
;
bool
receiver_report_sent
=
false
;
EXPECT_CALL
(
transport_
SendRtcp
)
.
WillRepeatedly
(
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
{
if
(
packet
.
size
(
)
>
=
2
&
&
packet
[
1
]
=
=
rtcp
:
:
ReceiverReport
:
:
kPacketType
)
{
receiver_report_sent
=
true
;
}
return
true
;
}
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
5
)
)
;
EXPECT_TRUE
(
receiver_report_sent
)
;
}
TEST_F
(
ChannelReceiveTest
CaptureStartTimeBecomesValid
)
{
auto
channel
=
CreateTestChannelReceive
(
)
;
EXPECT_CALL
(
transport_
SendRtcp
)
.
WillRepeatedly
(
[
&
]
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
{
HandleGeneratedRtcp
(
*
channel
packet
)
;
return
true
;
}
)
;
EXPECT_EQ
(
ProbeCaptureStartNtpTime
(
*
channel
)
-
1
)
;
channel
-
>
StartPlayout
(
)
;
channel
-
>
OnRtpPacket
(
CreateRtpPacket
(
)
)
;
EXPECT_EQ
(
ProbeCaptureStartNtpTime
(
*
channel
)
-
1
)
;
auto
rtcp_packet_1
=
CreateRtcpSenderReport
(
)
;
channel
-
>
ReceivedRTCPPacket
(
rtcp_packet_1
.
data
(
)
rtcp_packet_1
.
size
(
)
)
;
EXPECT_EQ
(
ProbeCaptureStartNtpTime
(
*
channel
)
-
1
)
;
time_controller_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
5
)
)
;
auto
rtcp_rr
=
CreateRtcpReceiverReport
(
)
;
channel
-
>
ReceivedRTCPPacket
(
rtcp_rr
.
data
(
)
rtcp_rr
.
size
(
)
)
;
EXPECT_EQ
(
ProbeCaptureStartNtpTime
(
*
channel
)
-
1
)
;
auto
rtcp_packet_2
=
CreateRtcpSenderReport
(
)
;
channel
-
>
ReceivedRTCPPacket
(
rtcp_packet_2
.
data
(
)
rtcp_packet_2
.
size
(
)
)
;
EXPECT_NE
(
ProbeCaptureStartNtpTime
(
*
channel
)
-
1
)
;
}
TEST_F
(
ChannelReceiveTest
SettingFrameTransformer
)
{
auto
channel
=
CreateTestChannelReceive
(
)
;
rtc
:
:
scoped_refptr
<
MockFrameTransformer
>
mock_frame_transformer
=
rtc
:
:
make_ref_counted
<
MockFrameTransformer
>
(
)
;
EXPECT_CALL
(
*
mock_frame_transformer
RegisterTransformedFrameCallback
)
;
channel
-
>
SetDepacketizerToDecoderFrameTransformer
(
mock_frame_transformer
)
;
channel
-
>
StartPlayout
(
)
;
RtpPacketReceived
packet
=
CreateRtpPacket
(
)
;
EXPECT_CALL
(
*
mock_frame_transformer
Transform
)
;
channel
-
>
OnRtpPacket
(
packet
)
;
}
TEST_F
(
ChannelReceiveTest
SettingFrameTransformerMultipleTimes
)
{
auto
channel
=
CreateTestChannelReceive
(
)
;
rtc
:
:
scoped_refptr
<
MockFrameTransformer
>
mock_frame_transformer
=
rtc
:
:
make_ref_counted
<
MockFrameTransformer
>
(
)
;
EXPECT_CALL
(
*
mock_frame_transformer
RegisterTransformedFrameCallback
)
;
channel
-
>
SetDepacketizerToDecoderFrameTransformer
(
mock_frame_transformer
)
;
EXPECT_CALL
(
*
mock_frame_transformer
RegisterTransformedFrameCallback
)
.
Times
(
0
)
;
channel
-
>
SetDepacketizerToDecoderFrameTransformer
(
mock_frame_transformer
)
;
}
}
}
}
