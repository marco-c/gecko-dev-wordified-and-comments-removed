from
__future__
import
division
from
__future__
import
print_function
import
array
import
difflib
import
distutils
.
dir_util
import
filecmp
import
io
import
operator
import
os
import
re
import
shutil
import
struct
import
subprocess
import
sys
import
tempfile
import
uuid
from
functools
import
reduce
def
ZapTimestamp
(
filename
)
:
  
contents
=
open
(
filename
'
rb
'
)
.
read
(
)
  
if
filename
.
endswith
(
'
.
tlb
'
)
:
    
assert
contents
[
0
:
8
]
=
=
b
'
MSFT
\
x02
\
x00
\
x01
\
x00
'
    
ntypes
=
struct
.
unpack_from
(
'
<
I
'
contents
0x20
)
    
custom_off
custom_len
=
struct
.
unpack_from
(
        
'
<
II
'
contents
0x54
+
4
*
ntypes
+
11
*
16
)
    
assert
custom_len
>
=
0x54
    
assert
contents
[
custom_off
:
custom_off
+
6
]
=
=
b
'
\
x08
\
x00
\
x3e
\
x00
\
x00
\
x00
'
    
assert
re
.
match
(
        
br
'
Created
by
MIDL
version
8
\
.
\
d
\
d
\
.
\
d
{
4
}
at
.
.
.
Jan
1
.
.
.
:
.
.
:
.
.
2038
\
n
'
        
contents
[
custom_off
+
6
:
custom_off
+
6
+
0x3e
]
)
    
assert
contents
[
custom_off
+
6
+
0x3e
:
custom_off
+
6
+
0x3e
+
8
]
=
=
\
        
b
'
\
x13
\
x00
\
xff
\
xff
\
xff
\
x7f
\
x57
\
x57
'
    
assert
contents
[
custom_off
+
6
+
0x3e
+
8
:
custom_off
+
6
+
0x3e
+
8
+
                    
2
]
=
=
b
'
\
x13
\
x00
'
    
contents
=
(
        
contents
[
0
:
custom_off
+
6
]
+
        
b
'
Created
by
MIDL
version
8
.
xx
.
xxxx
at
a
redacted
point
in
time
\
n
'
+
        
b
'
\
x13
\
x00
\
xff
\
xff
\
xff
\
x7f
\
x57
\
x57
\
x13
\
x00
\
x6e
\
x02
\
x01
\
x08
\
x57
\
x57
'
+
        
contents
[
custom_off
+
0x54
:
]
)
  
else
:
    
contents
=
re
.
sub
(
        
br
'
File
created
by
MIDL
compiler
version
8
\
.
\
d
\
d
\
.
\
d
{
4
}
\
*
/
\
r
\
n
'
        
br
'
/
\
*
at
.
.
.
Jan
1
.
.
.
:
.
.
:
.
.
2038
'
        
br
'
File
created
by
MIDL
compiler
version
8
.
xx
.
xxxx
*
/
\
r
\
n
'
        
br
'
/
*
at
a
redacted
point
in
time
'
contents
)
    
contents
=
re
.
sub
(
        
br
'
Oicf
W1
Zp8
env
=
(
.
.
.
.
.
)
\
(
32b
run
\
)
'
        
br
'
target_arch
=
(
AMD64
|
X86
)
8
\
.
\
d
\
d
\
.
\
d
{
4
}
'
        
br
'
Oicf
W1
Zp8
env
=
\
1
(
32b
run
)
target_arch
=
\
2
8
.
xx
.
xxxx
'
        
contents
)
    
contents
=
contents
.
replace
(
b
'
#
endif
!
_MIDL_USE_GUIDDEF_
'
                                
b
'
#
endif
/
/
!
_MIDL_USE_GUIDDEF_
'
)
    
contents
=
contents
.
replace
(
b
'
0x801026c
/
*
MIDL
Version
8
.
1
.
620
*
/
'
                                
b
'
0x801026e
/
*
MIDL
Version
8
.
1
.
622
*
/
'
)
  
open
(
filename
'
wb
'
)
.
write
(
contents
)
def
overwrite_cls_guid_h
(
h_file
dynamic_guid
)
:
  
contents
=
open
(
h_file
'
rb
'
)
.
read
(
)
  
contents
=
re
.
sub
(
br
'
class
DECLSPEC_UUID
\
(
"
[
^
"
]
*
"
\
)
'
                    
br
'
class
DECLSPEC_UUID
(
"
%
s
"
)
'
%
str
(
dynamic_guid
)
.
encode
(
)
                    
contents
)
  
open
(
h_file
'
wb
'
)
.
write
(
contents
)
def
overwrite_cls_guid_iid
(
iid_file
dynamic_guid
)
:
  
contents
=
open
(
iid_file
'
rb
'
)
.
read
(
)
  
hexuuid
=
'
0x
%
08x
0x
%
04x
0x
%
04x
'
%
dynamic_guid
.
fields
[
0
:
3
]
  
if
sys
.
version_info
.
major
=
=
2
:
    
hexuuid
+
=
'
'
.
join
(
'
0x
%
02x
'
%
ord
(
b
)
for
b
in
dynamic_guid
.
bytes
[
8
:
]
)
  
else
:
    
hexuuid
+
=
'
'
.
join
(
'
0x
%
02x
'
%
b
for
b
in
dynamic_guid
.
bytes
[
8
:
]
)
  
contents
=
re
.
sub
(
br
'
MIDL_DEFINE_GUID
\
(
CLSID
(
[
^
]
*
)
[
^
)
]
*
\
)
'
                    
br
'
MIDL_DEFINE_GUID
(
CLSID
\
1
%
s
)
'
%
hexuuid
.
encode
(
)
                    
contents
)
  
open
(
iid_file
'
wb
'
)
.
write
(
contents
)
def
overwrite_cls_guid_tlb
(
tlb_file
dynamic_guid
)
:
  
contents
=
open
(
tlb_file
'
rb
'
)
.
read
(
)
  
assert
contents
[
0
:
8
]
=
=
b
'
MSFT
\
x02
\
x00
\
x01
\
x00
'
  
ntypes
=
struct
.
unpack_from
(
'
<
I
'
contents
0x20
)
  
type_off
type_len
=
struct
.
unpack_from
(
'
<
II
'
contents
0x54
+
4
*
ntypes
)
  
if
sys
.
version_info
.
major
=
=
2
:
    
coclass
=
ord
(
contents
[
type_off
]
)
  
else
:
    
coclass
=
contents
[
type_off
]
  
assert
coclass
=
=
0x25
"
expected
coclass
"
  
guidind
=
struct
.
unpack_from
(
'
<
I
'
contents
type_off
+
0x2c
)
[
0
]
  
guid_off
guid_len
=
struct
.
unpack_from
(
      
'
<
II
'
contents
0x54
+
4
*
ntypes
+
5
*
16
)
  
assert
guidind
+
14
<
=
guid_len
  
contents
=
array
.
array
(
'
B
'
contents
)
  
struct
.
pack_into
(
'
<
IHH8s
'
contents
guid_off
+
guidind
                   
*
(
dynamic_guid
.
fields
[
0
:
3
]
+
(
dynamic_guid
.
bytes
[
8
:
]
)
)
)
  
hashtab
=
[
0xffffffff
]
*
(
0x80
/
/
4
)
  
for
guidind
in
range
(
guid_off
guid_off
+
guid_len
24
)
:
    
guidbytes
typeoff
nextguid
=
struct
.
unpack_from
(
        
'
<
16sII
'
contents
guidind
)
    
words
=
struct
.
unpack
(
'
<
8H
'
guidbytes
)
    
guidhash
=
reduce
(
operator
.
xor
[
w
for
w
in
words
]
)
%
(
0x80
/
/
4
)
    
nextguid
=
hashtab
[
guidhash
]
    
struct
.
pack_into
(
'
<
I
'
contents
guidind
+
0x14
nextguid
)
    
hashtab
[
guidhash
]
=
guidind
-
guid_off
  
hash_off
hash_len
=
struct
.
unpack_from
(
      
'
<
II
'
contents
0x54
+
4
*
ntypes
+
4
*
16
)
  
for
i
hashval
in
enumerate
(
hashtab
)
:
    
struct
.
pack_into
(
'
<
I
'
contents
hash_off
+
4
*
i
hashval
)
  
open
(
tlb_file
'
wb
'
)
.
write
(
contents
)
def
overwrite_cls_guid
(
h_file
iid_file
tlb_file
dynamic_guid
)
:
  
overwrite_cls_guid_h
(
h_file
dynamic_guid
)
  
overwrite_cls_guid_iid
(
iid_file
dynamic_guid
)
  
overwrite_cls_guid_tlb
(
tlb_file
dynamic_guid
)
def
main
(
arch
gendir
outdir
dynamic_guid
tlb
h
dlldata
iid
proxy
clang
         
idl
*
flags
)
:
  
source
=
gendir
  
if
os
.
path
.
isdir
(
os
.
path
.
join
(
source
os
.
path
.
basename
(
idl
)
)
)
:
    
source
=
os
.
path
.
join
(
source
os
.
path
.
basename
(
idl
)
)
  
source
=
os
.
path
.
join
(
source
arch
.
split
(
'
.
'
)
[
1
]
)
  
source
=
os
.
path
.
normpath
(
source
)
  
distutils
.
dir_util
.
copy_tree
(
source
outdir
preserve_times
=
False
)
  
if
dynamic_guid
!
=
'
none
'
:
    
overwrite_cls_guid
(
os
.
path
.
join
(
outdir
h
)
                       
os
.
path
.
join
(
outdir
iid
)
                       
os
.
path
.
join
(
outdir
tlb
)
                       
uuid
.
UUID
(
dynamic_guid
)
)
  
if
sys
.
platform
!
=
'
win32
'
:
    
return
0
  
tmp_dir
=
tempfile
.
mkdtemp
(
)
  
delete_tmp_dir
=
True
  
env_pairs
=
open
(
arch
)
.
read
(
)
[
:
-
2
]
.
split
(
'
\
0
'
)
  
env_dict
=
dict
(
[
item
.
split
(
'
=
'
1
)
for
item
in
env_pairs
]
)
  
preprocessor_options
=
'
-
E
-
nologo
-
Wno
-
nonportable
-
include
-
path
'
  
preprocessor_options
+
=
'
'
.
join
(
      
[
'
'
+
flag
for
flag
in
flags
if
flag
.
startswith
(
'
/
D
'
)
]
)
  
args
=
[
'
midl
'
'
/
nologo
'
]
+
list
(
flags
)
+
[
      
'
/
out
'
tmp_dir
      
'
/
tlb
'
tlb
      
'
/
h
'
h
      
'
/
dlldata
'
dlldata
      
'
/
iid
'
iid
      
'
/
proxy
'
proxy
      
'
/
cpp_cmd
'
clang
      
'
/
cpp_opt
'
preprocessor_options
      
idl
]
  
try
:
    
popen
=
subprocess
.
Popen
(
args
shell
=
True
env
=
env_dict
                             
stdout
=
subprocess
.
PIPE
stderr
=
subprocess
.
STDOUT
)
    
out
_
=
popen
.
communicate
(
)
    
lines
=
out
.
decode
(
'
utf
-
8
'
)
.
splitlines
(
)
    
prefixes
=
(
'
Processing
'
'
64
bit
Processing
'
)
    
processing
=
set
(
os
.
path
.
basename
(
x
)
                     
for
x
in
lines
if
x
.
startswith
(
prefixes
)
)
    
for
line
in
lines
:
      
if
not
line
.
startswith
(
prefixes
)
and
line
not
in
processing
:
        
print
(
line
)
    
if
popen
.
returncode
!
=
0
:
      
return
popen
.
returncode
    
for
f
in
os
.
listdir
(
tmp_dir
)
:
      
ZapTimestamp
(
os
.
path
.
join
(
tmp_dir
f
)
)
    
diff
=
filecmp
.
dircmp
(
tmp_dir
outdir
)
    
if
diff
.
diff_files
:
      
print
(
'
midl
.
exe
output
different
from
files
in
%
s
see
%
s
'
%
(
outdir
                                                                    
tmp_dir
)
)
      
for
f
in
diff
.
diff_files
:
        
if
f
.
endswith
(
'
.
tlb
'
)
:
continue
        
fromfile
=
os
.
path
.
join
(
outdir
f
)
        
tofile
=
os
.
path
.
join
(
tmp_dir
f
)
        
print
(
'
'
.
join
(
            
difflib
.
unified_diff
(
                
io
.
open
(
fromfile
)
.
readlines
(
)
                
io
.
open
(
tofile
)
.
readlines
(
)
fromfile
tofile
)
)
)
      
delete_tmp_dir
=
False
      
print
(
'
To
rebaseline
:
'
)
      
print
(
r
'
copy
/
y
%
s
\
*
%
s
'
%
(
tmp_dir
source
)
)
      
sys
.
exit
(
1
)
    
return
0
  
finally
:
    
if
os
.
path
.
exists
(
tmp_dir
)
and
delete_tmp_dir
:
      
shutil
.
rmtree
(
tmp_dir
)
if
__name__
=
=
'
__main__
'
:
  
sys
.
exit
(
main
(
*
sys
.
argv
[
1
:
]
)
)
