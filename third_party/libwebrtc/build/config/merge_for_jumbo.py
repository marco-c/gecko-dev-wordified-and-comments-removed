"
"
"
This
script
creates
a
"
jumbo
"
file
which
merges
all
incoming
files
for
compiling
.
"
"
"
from
__future__
import
print_function
from
__future__
import
unicode_literals
import
argparse
import
hashlib
import
io
import
os
def
cut_ranges
(
boundaries
)
:
  
for
start
stop
in
zip
(
boundaries
boundaries
[
1
:
]
)
:
    
yield
range
(
start
stop
)
def
generate_chunk_stops
(
inputs
output_count
smart_merge
=
True
)
:
  
input_count
=
len
(
inputs
)
  
stops
=
[
(
(
i
+
1
)
*
input_count
+
output_count
-
1
)
/
/
output_count
           
for
i
in
range
(
output_count
)
]
  
if
smart_merge
:
    
hasher
=
lambda
n
:
hashlib
.
md5
(
inputs
[
n
]
.
encode
(
)
)
.
hexdigest
(
)
    
centers
=
[
min
(
indices
key
=
hasher
)
for
indices
in
cut_ranges
(
[
0
]
+
stops
)
]
    
stops
=
[
max
(
indices
key
=
hasher
)
for
indices
in
cut_ranges
(
centers
)
]
    
stops
.
append
(
input_count
)
  
return
stops
def
write_jumbo_files
(
inputs
outputs
written_input_set
written_output_set
)
:
  
chunk_stops
=
generate_chunk_stops
(
inputs
len
(
outputs
)
)
  
written_inputs
=
0
  
for
output_index
output_file
in
enumerate
(
outputs
)
:
    
written_output_set
.
add
(
output_file
)
    
if
os
.
path
.
isfile
(
output_file
)
:
      
with
open
(
output_file
"
r
"
)
as
current
:
        
current_jumbo_file
=
current
.
read
(
)
    
else
:
      
current_jumbo_file
=
None
    
out
=
io
.
StringIO
(
)
    
out
.
write
(
"
/
*
This
is
a
Jumbo
file
.
Don
'
t
edit
.
*
/
\
n
\
n
"
)
    
out
.
write
(
"
/
*
Generated
with
merge_for_jumbo
.
py
.
*
/
\
n
\
n
"
)
    
input_limit
=
chunk_stops
[
output_index
]
    
while
written_inputs
<
input_limit
:
      
filename
=
inputs
[
written_inputs
]
      
written_inputs
+
=
1
      
out
.
write
(
"
#
include
\
"
%
s
\
"
\
n
"
%
filename
)
      
written_input_set
.
add
(
filename
)
    
new_jumbo_file
=
out
.
getvalue
(
)
    
out
.
close
(
)
    
if
new_jumbo_file
!
=
current_jumbo_file
:
      
with
open
(
output_file
"
w
"
)
as
out
:
        
out
.
write
(
new_jumbo_file
)
def
main
(
)
:
  
parser
=
argparse
.
ArgumentParser
(
)
  
parser
.
add_argument
(
"
-
-
outputs
"
nargs
=
"
+
"
required
=
True
                      
help
=
'
List
of
output
files
to
split
input
into
'
)
  
parser
.
add_argument
(
"
-
-
file
-
list
"
required
=
True
)
  
parser
.
add_argument
(
"
-
-
verbose
"
action
=
"
store_true
"
)
  
args
=
parser
.
parse_args
(
)
  
lines
=
[
]
  
with
open
(
args
.
file_list
)
as
file_list_file
:
    
lines
=
[
line
.
strip
(
)
for
line
in
file_list_file
if
line
.
strip
(
)
]
  
all_inputs
=
[
]
  
for
line
in
lines
:
    
all_inputs
.
extend
(
line
.
split
(
)
)
  
written_output_set
=
set
(
)
  
written_input_set
=
set
(
)
  
for
language_ext
in
(
"
.
cc
"
"
.
c
"
"
.
mm
"
)
:
    
if
language_ext
=
=
"
.
cc
"
:
      
ext_pattern
=
(
"
.
cc
"
"
.
cpp
"
)
    
else
:
      
ext_pattern
=
tuple
(
[
language_ext
]
)
    
outputs
=
[
x
for
x
in
args
.
outputs
if
x
.
endswith
(
ext_pattern
)
]
    
inputs
=
[
x
for
x
in
all_inputs
if
x
.
endswith
(
ext_pattern
)
]
    
if
not
outputs
:
      
assert
not
inputs
      
continue
    
write_jumbo_files
(
inputs
outputs
written_input_set
written_output_set
)
  
assert
set
(
args
.
outputs
)
=
=
written_output_set
"
Did
not
fill
all
outputs
"
  
assert
set
(
all_inputs
)
=
=
written_input_set
"
Did
not
use
all
inputs
"
  
if
args
.
verbose
:
    
print
(
"
Generated
%
s
(
%
d
files
)
based
on
%
s
"
%
(
      
str
(
args
.
outputs
)
len
(
written_input_set
)
args
.
file_list
)
)
if
__name__
=
=
"
__main__
"
:
  
main
(
)
