package
org
.
chromium
.
incrementalinstall
;
import
android
.
app
.
Application
;
import
android
.
app
.
Instrumentation
;
import
android
.
content
.
Context
;
import
android
.
content
.
pm
.
ApplicationInfo
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
content
.
pm
.
PackageManager
.
NameNotFoundException
;
import
android
.
os
.
Bundle
;
import
android
.
util
.
Log
;
import
dalvik
.
system
.
DexFile
;
import
java
.
io
.
File
;
import
java
.
lang
.
ref
.
WeakReference
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
public
final
class
BootstrapApplication
extends
Application
{
private
static
final
String
TAG
=
"
incrementalinstall
"
;
private
static
final
String
MANAGED_DIR_PREFIX
=
"
/
data
/
local
/
tmp
/
incremental
-
app
-
"
;
private
static
final
String
REAL_APP_META_DATA_NAME
=
"
incremental
-
install
-
real
-
app
"
;
private
static
final
String
REAL_INSTRUMENTATION_META_DATA_NAME0
=
"
incremental
-
install
-
real
-
instrumentation
-
0
"
;
private
static
final
String
REAL_INSTRUMENTATION_META_DATA_NAME1
=
"
incremental
-
install
-
real
-
instrumentation
-
1
"
;
private
ClassLoaderPatcher
mClassLoaderPatcher
;
private
Application
mRealApplication
;
private
Instrumentation
mOrigInstrumentation
;
private
Instrumentation
mRealInstrumentation
;
private
Object
mStashedProviderList
;
private
Object
mActivityThread
;
public
static
DexFile
[
]
sIncrementalDexFiles
;
Override
protected
void
attachBaseContext
(
Context
context
)
{
super
.
attachBaseContext
(
context
)
;
try
{
mActivityThread
=
Reflect
.
invokeMethod
(
Class
.
forName
(
"
android
.
app
.
ActivityThread
"
)
"
currentActivityThread
"
)
;
mClassLoaderPatcher
=
new
ClassLoaderPatcher
(
context
)
;
mOrigInstrumentation
=
(
Instrumentation
)
Reflect
.
getField
(
mActivityThread
"
mInstrumentation
"
)
;
Context
instContext
=
mOrigInstrumentation
.
getContext
(
)
;
if
(
instContext
=
=
null
)
{
instContext
=
context
;
}
String
appPackageName
=
getPackageName
(
)
;
String
instPackageName
=
instContext
.
getPackageName
(
)
;
boolean
instPackageNameDiffers
=
!
appPackageName
.
equals
(
instPackageName
)
;
Log
.
i
(
TAG
"
App
PackageName
:
"
+
appPackageName
)
;
if
(
instPackageNameDiffers
)
{
Log
.
i
(
TAG
"
Inst
PackageName
:
"
+
instPackageName
)
;
}
File
appIncrementalRootDir
=
new
File
(
MANAGED_DIR_PREFIX
+
appPackageName
)
;
File
appLibDir
=
new
File
(
appIncrementalRootDir
"
lib
"
)
;
File
appDexDir
=
new
File
(
appIncrementalRootDir
"
dex
"
)
;
File
appInstallLockFile
=
new
File
(
appIncrementalRootDir
"
install
.
lock
"
)
;
File
appFirstRunLockFile
=
new
File
(
appIncrementalRootDir
"
firstrun
.
lock
"
)
;
File
instIncrementalRootDir
=
new
File
(
MANAGED_DIR_PREFIX
+
instPackageName
)
;
File
instLibDir
=
new
File
(
instIncrementalRootDir
"
lib
"
)
;
File
instDexDir
=
new
File
(
instIncrementalRootDir
"
dex
"
)
;
File
instInstallLockFile
=
new
File
(
instIncrementalRootDir
"
install
.
lock
"
)
;
File
instFirstRunLockFile
=
new
File
(
instIncrementalRootDir
"
firstrun
.
lock
"
)
;
boolean
isFirstRun
=
LockFile
.
installerLockExists
(
appFirstRunLockFile
)
|
|
(
instPackageNameDiffers
&
&
LockFile
.
installerLockExists
(
instFirstRunLockFile
)
)
;
if
(
isFirstRun
)
{
if
(
mClassLoaderPatcher
.
mIsPrimaryProcess
)
{
LockFile
.
waitForInstallerLock
(
appInstallLockFile
30
*
1000
)
;
LockFile
.
waitForInstallerLock
(
instInstallLockFile
30
*
1000
)
;
}
else
{
LockFile
.
waitForInstallerLock
(
appFirstRunLockFile
60
*
1000
)
;
LockFile
.
waitForInstallerLock
(
instFirstRunLockFile
60
*
1000
)
;
}
}
mClassLoaderPatcher
.
importNativeLibs
(
instLibDir
)
;
sIncrementalDexFiles
=
mClassLoaderPatcher
.
loadDexFiles
(
instDexDir
instPackageName
)
;
if
(
instPackageNameDiffers
)
{
mClassLoaderPatcher
.
importNativeLibs
(
appLibDir
)
;
mClassLoaderPatcher
.
loadDexFiles
(
appDexDir
appPackageName
)
;
}
if
(
isFirstRun
&
&
mClassLoaderPatcher
.
mIsPrimaryProcess
)
{
LockFile
.
clearInstallerLock
(
appFirstRunLockFile
)
;
if
(
instPackageNameDiffers
)
{
LockFile
.
clearInstallerLock
(
instFirstRunLockFile
)
;
}
}
if
(
Reflect
.
getField
(
mActivityThread
"
mInstrumentationAppDir
"
)
!
=
null
)
{
String
metaDataName
=
REAL_INSTRUMENTATION_META_DATA_NAME0
;
if
(
mOrigInstrumentation
instanceof
SecondInstrumentation
)
{
metaDataName
=
REAL_INSTRUMENTATION_META_DATA_NAME1
;
}
mRealInstrumentation
=
initInstrumentation
(
getClassNameFromMetadata
(
metaDataName
instContext
)
)
;
}
else
{
Log
.
i
(
TAG
"
No
instrumentation
active
.
"
)
;
}
BootstrapInstrumentation
bootstrapInstrumentation
=
new
BootstrapInstrumentation
(
this
)
;
populateInstrumenationFields
(
bootstrapInstrumentation
)
;
Reflect
.
setField
(
mActivityThread
"
mInstrumentation
"
bootstrapInstrumentation
)
;
String
realApplicationName
=
getClassNameFromMetadata
(
REAL_APP_META_DATA_NAME
context
)
;
Log
.
i
(
TAG
"
Instantiating
"
+
realApplicationName
)
;
Instrumentation
anyInstrumentation
=
mRealInstrumentation
!
=
null
?
mRealInstrumentation
:
mOrigInstrumentation
;
mRealApplication
=
anyInstrumentation
.
newApplication
(
getClassLoader
(
)
realApplicationName
context
)
;
disableContentProviders
(
)
;
Log
.
i
(
TAG
"
Waiting
for
Instrumentation
.
onCreate
"
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
"
Incremental
install
failed
.
"
e
)
;
}
}
private
static
String
getClassNameFromMetadata
(
String
key
Context
context
)
throws
NameNotFoundException
{
String
pkgName
=
context
.
getPackageName
(
)
;
ApplicationInfo
appInfo
=
context
.
getPackageManager
(
)
.
getApplicationInfo
(
pkgName
PackageManager
.
GET_META_DATA
)
;
String
value
=
appInfo
.
metaData
.
getString
(
key
)
;
if
(
value
!
=
null
&
&
!
value
.
contains
(
"
.
"
)
)
{
value
=
pkgName
+
"
.
"
+
value
;
}
return
value
;
}
private
Instrumentation
initInstrumentation
(
String
realInstrumentationName
)
throws
ReflectiveOperationException
{
if
(
realInstrumentationName
=
=
null
)
{
Log
.
i
(
TAG
"
Running
with
external
instrumentation
"
)
;
return
null
;
}
Log
.
i
(
TAG
"
Instantiating
instrumentation
"
+
realInstrumentationName
)
;
Instrumentation
ret
=
(
Instrumentation
)
Reflect
.
newInstance
(
Class
.
forName
(
realInstrumentationName
)
)
;
populateInstrumenationFields
(
ret
)
;
return
ret
;
}
private
void
populateInstrumenationFields
(
Instrumentation
target
)
throws
ReflectiveOperationException
{
String
[
]
initFields
=
{
"
mAppContext
"
"
mComponent
"
"
mInstrContext
"
"
mMessageQueue
"
"
mThread
"
"
mUiAutomationConnection
"
"
mWatcher
"
}
;
for
(
String
fieldName
:
initFields
)
{
Reflect
.
setField
(
target
fieldName
Reflect
.
getField
(
mOrigInstrumentation
fieldName
)
)
;
}
}
void
onInstrumentationCreate
(
Bundle
arguments
)
{
Log
.
i
(
TAG
"
Instrumentation
.
onCreate
(
)
called
.
Swapping
references
.
"
)
;
try
{
swapApplicationReferences
(
)
;
enableContentProviders
(
)
;
if
(
mRealInstrumentation
!
=
null
)
{
Reflect
.
setField
(
mActivityThread
"
mInstrumentation
"
mRealInstrumentation
)
;
mRealInstrumentation
.
onCreate
(
arguments
)
;
}
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
"
Incremental
install
failed
.
"
e
)
;
}
}
Override
public
void
onCreate
(
)
{
super
.
onCreate
(
)
;
try
{
Log
.
i
(
TAG
"
Application
.
onCreate
(
)
called
.
"
)
;
mRealApplication
.
onCreate
(
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
"
Incremental
install
failed
.
"
e
)
;
}
}
private
void
disableContentProviders
(
)
throws
ReflectiveOperationException
{
Object
data
=
Reflect
.
getField
(
mActivityThread
"
mBoundApplication
"
)
;
mStashedProviderList
=
Reflect
.
getField
(
data
"
providers
"
)
;
Reflect
.
setField
(
data
"
providers
"
null
)
;
}
private
void
enableContentProviders
(
)
throws
ReflectiveOperationException
{
Object
data
=
Reflect
.
getField
(
mActivityThread
"
mBoundApplication
"
)
;
Reflect
.
setField
(
data
"
providers
"
mStashedProviderList
)
;
if
(
mStashedProviderList
!
=
null
&
&
mClassLoaderPatcher
.
mIsPrimaryProcess
)
{
Log
.
i
(
TAG
"
Instantiating
content
providers
"
)
;
Reflect
.
invokeMethod
(
mActivityThread
"
installContentProviders
"
mRealApplication
mStashedProviderList
)
;
}
mStashedProviderList
=
null
;
}
SuppressWarnings
(
"
unchecked
"
)
private
void
swapApplicationReferences
(
)
throws
ReflectiveOperationException
{
if
(
Reflect
.
getField
(
mActivityThread
"
mInitialApplication
"
)
=
=
this
)
{
Reflect
.
setField
(
mActivityThread
"
mInitialApplication
"
mRealApplication
)
;
}
List
<
Application
>
allApplications
=
(
List
<
Application
>
)
Reflect
.
getField
(
mActivityThread
"
mAllApplications
"
)
;
for
(
int
i
=
0
;
i
<
allApplications
.
size
(
)
;
i
+
+
)
{
if
(
allApplications
.
get
(
i
)
=
=
this
)
{
allApplications
.
set
(
i
mRealApplication
)
;
}
}
Context
contextImpl
=
mRealApplication
.
getBaseContext
(
)
;
Reflect
.
setField
(
contextImpl
"
mOuterContext
"
mRealApplication
)
;
for
(
String
fieldName
:
new
String
[
]
{
"
mPackages
"
"
mResourcePackages
"
}
)
{
Map
<
String
WeakReference
<
?
>
>
packageMap
=
(
Map
<
String
WeakReference
<
?
>
>
)
Reflect
.
getField
(
mActivityThread
fieldName
)
;
for
(
Map
.
Entry
<
String
WeakReference
<
?
>
>
entry
:
packageMap
.
entrySet
(
)
)
{
Object
loadedApk
=
entry
.
getValue
(
)
.
get
(
)
;
if
(
loadedApk
!
=
null
&
&
Reflect
.
getField
(
loadedApk
"
mApplication
"
)
=
=
this
)
{
Reflect
.
setField
(
loadedApk
"
mApplication
"
mRealApplication
)
;
}
}
}
}
}
