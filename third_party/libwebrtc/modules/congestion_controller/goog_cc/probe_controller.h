#
ifndef
MODULES_CONGESTION_CONTROLLER_GOOG_CC_PROBE_CONTROLLER_H_
#
define
MODULES_CONGESTION_CONTROLLER_GOOG_CC_PROBE_CONTROLLER_H_
#
include
<
stdint
.
h
>
#
include
<
initializer_list
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
rtc_event_log
/
rtc_event_log
.
h
"
#
include
"
api
/
transport
/
network_control
.
h
"
#
include
"
api
/
transport
/
webrtc_key_value_config
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
system
/
unused
.
h
"
namespace
webrtc
{
struct
ProbeControllerConfig
{
explicit
ProbeControllerConfig
(
const
WebRtcKeyValueConfig
*
key_value_config
)
;
ProbeControllerConfig
(
const
ProbeControllerConfig
&
)
;
ProbeControllerConfig
&
operator
=
(
const
ProbeControllerConfig
&
)
=
default
;
~
ProbeControllerConfig
(
)
;
FieldTrialParameter
<
double
>
first_exponential_probe_scale
;
FieldTrialOptional
<
double
>
second_exponential_probe_scale
;
FieldTrialParameter
<
double
>
further_exponential_probe_scale
;
FieldTrialParameter
<
double
>
further_probe_threshold
;
FieldTrialParameter
<
TimeDelta
>
alr_probing_interval
;
FieldTrialParameter
<
double
>
alr_probe_scale
;
FieldTrialOptional
<
double
>
first_allocation_probe_scale
;
FieldTrialOptional
<
double
>
second_allocation_probe_scale
;
FieldTrialFlag
allocation_allow_further_probing
;
FieldTrialParameter
<
DataRate
>
allocation_probe_max
;
}
;
class
ProbeController
{
public
:
explicit
ProbeController
(
const
WebRtcKeyValueConfig
*
key_value_config
RtcEventLog
*
event_log
)
;
~
ProbeController
(
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
SetBitrates
(
int64_t
min_bitrate_bps
int64_t
start_bitrate_bps
int64_t
max_bitrate_bps
int64_t
at_time_ms
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
OnMaxTotalAllocatedBitrate
(
int64_t
max_total_allocated_bitrate
int64_t
at_time_ms
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
OnNetworkAvailability
(
NetworkAvailability
msg
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
SetEstimatedBitrate
(
int64_t
bitrate_bps
int64_t
at_time_ms
)
;
void
EnablePeriodicAlrProbing
(
bool
enable
)
;
void
SetAlrStartTimeMs
(
absl
:
:
optional
<
int64_t
>
alr_start_time
)
;
void
SetAlrEndedTimeMs
(
int64_t
alr_end_time
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
RequestProbe
(
int64_t
at_time_ms
)
;
void
SetMaxBitrate
(
int64_t
max_bitrate_bps
)
;
void
Reset
(
int64_t
at_time_ms
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
Process
(
int64_t
at_time_ms
)
;
private
:
enum
class
State
{
kInit
kWaitingForProbingResult
kProbingComplete
}
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
InitiateExponentialProbing
(
int64_t
at_time_ms
)
;
RTC_WARN_UNUSED_RESULT
std
:
:
vector
<
ProbeClusterConfig
>
InitiateProbing
(
int64_t
now_ms
std
:
:
vector
<
int64_t
>
bitrates_to_probe
bool
probe_further
)
;
bool
network_available_
;
State
state_
;
int64_t
min_bitrate_to_probe_further_bps_
;
int64_t
time_last_probing_initiated_ms_
;
int64_t
estimated_bitrate_bps_
;
int64_t
start_bitrate_bps_
;
int64_t
max_bitrate_bps_
;
int64_t
last_bwe_drop_probing_time_ms_
;
absl
:
:
optional
<
int64_t
>
alr_start_time_ms_
;
absl
:
:
optional
<
int64_t
>
alr_end_time_ms_
;
bool
enable_periodic_alr_probing_
;
int64_t
time_of_last_large_drop_ms_
;
int64_t
bitrate_before_last_large_drop_bps_
;
int64_t
max_total_allocated_bitrate_
;
const
bool
in_rapid_recovery_experiment_
;
const
bool
limit_probes_with_allocateable_rate_
;
bool
mid_call_probing_waiting_for_result_
;
int64_t
mid_call_probing_bitrate_bps_
;
int64_t
mid_call_probing_succcess_threshold_
;
RtcEventLog
*
event_log_
;
int32_t
next_probe_cluster_id_
=
1
;
ProbeControllerConfig
config_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
ProbeController
)
;
}
;
}
#
endif
