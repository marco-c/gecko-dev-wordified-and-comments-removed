#
ifndef
MODULES_CONGESTION_CONTROLLER_GOOG_CC_LOSS_BASED_BWE_V2_H_
#
define
MODULES_CONGESTION_CONTROLLER_GOOG_CC_LOSS_BASED_BWE_V2_H_
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
transport
/
network_types
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
namespace
webrtc
{
enum
class
LossBasedState
{
kIncreasing
=
0
kIncreaseUsingPadding
=
1
kDecreasing
=
2
kDelayBasedEstimate
=
3
}
;
class
LossBasedBweV2
{
public
:
struct
Result
{
~
Result
(
)
=
default
;
DataRate
bandwidth_estimate
=
DataRate
:
:
Zero
(
)
;
LossBasedState
state
=
LossBasedState
:
:
kDelayBasedEstimate
;
}
;
explicit
LossBasedBweV2
(
const
FieldTrialsView
*
key_value_config
)
;
LossBasedBweV2
(
const
LossBasedBweV2
&
)
=
delete
;
LossBasedBweV2
&
operator
=
(
const
LossBasedBweV2
&
)
=
delete
;
~
LossBasedBweV2
(
)
=
default
;
bool
IsEnabled
(
)
const
;
bool
IsReady
(
)
const
;
bool
ReadyToUseInStartPhase
(
)
const
;
Result
GetLossBasedResult
(
)
const
;
void
SetAcknowledgedBitrate
(
DataRate
acknowledged_bitrate
)
;
void
SetMinMaxBitrate
(
DataRate
min_bitrate
DataRate
max_bitrate
)
;
void
UpdateBandwidthEstimate
(
rtc
:
:
ArrayView
<
const
PacketResult
>
packet_results
DataRate
delay_based_estimate
bool
in_alr
)
;
void
SetBandwidthEstimate
(
DataRate
bandwidth_estimate
)
;
private
:
struct
ChannelParameters
{
double
inherent_loss
=
0
.
0
;
DataRate
loss_limited_bandwidth
=
DataRate
:
:
MinusInfinity
(
)
;
}
;
struct
Config
{
double
bandwidth_rampup_upper_bound_factor
=
0
.
0
;
double
rampup_acceleration_max_factor
=
0
.
0
;
TimeDelta
rampup_acceleration_maxout_time
=
TimeDelta
:
:
Zero
(
)
;
std
:
:
vector
<
double
>
candidate_factors
;
double
higher_bandwidth_bias_factor
=
0
.
0
;
double
higher_log_bandwidth_bias_factor
=
0
.
0
;
double
inherent_loss_lower_bound
=
0
.
0
;
double
loss_threshold_of_high_bandwidth_preference
=
0
.
0
;
double
bandwidth_preference_smoothing_factor
=
0
.
0
;
DataRate
inherent_loss_upper_bound_bandwidth_balance
=
DataRate
:
:
MinusInfinity
(
)
;
double
inherent_loss_upper_bound_offset
=
0
.
0
;
double
initial_inherent_loss_estimate
=
0
.
0
;
int
newton_iterations
=
0
;
double
newton_step_size
=
0
.
0
;
bool
append_acknowledged_rate_candidate
=
true
;
bool
append_delay_based_estimate_candidate
=
false
;
bool
append_upper_bound_candidate_in_alr
=
false
;
TimeDelta
observation_duration_lower_bound
=
TimeDelta
:
:
Zero
(
)
;
int
observation_window_size
=
0
;
double
sending_rate_smoothing_factor
=
0
.
0
;
double
instant_upper_bound_temporal_weight_factor
=
0
.
0
;
DataRate
instant_upper_bound_bandwidth_balance
=
DataRate
:
:
MinusInfinity
(
)
;
double
instant_upper_bound_loss_offset
=
0
.
0
;
double
temporal_weight_factor
=
0
.
0
;
double
bandwidth_backoff_lower_bound_factor
=
0
.
0
;
double
max_increase_factor
=
0
.
0
;
TimeDelta
delayed_increase_window
=
TimeDelta
:
:
Zero
(
)
;
bool
not_increase_if_inherent_loss_less_than_average_loss
=
false
;
double
high_loss_rate_threshold
=
1
.
0
;
DataRate
bandwidth_cap_at_high_loss_rate
=
DataRate
:
:
MinusInfinity
(
)
;
double
slope_of_bwe_high_loss_func
=
1000
.
0
;
bool
not_use_acked_rate_in_alr
=
false
;
bool
use_in_start_phase
=
false
;
int
min_num_observations
=
0
;
double
lower_bound_by_acked_rate_factor
=
0
.
0
;
bool
use_padding_for_increase
=
false
;
double
hold_duration_factor
=
0
.
0
;
bool
use_byte_loss_rate
=
false
;
}
;
struct
Derivatives
{
double
first
=
0
.
0
;
double
second
=
0
.
0
;
}
;
struct
Observation
{
bool
IsInitialized
(
)
const
{
return
id
!
=
-
1
;
}
int
num_packets
=
0
;
int
num_lost_packets
=
0
;
int
num_received_packets
=
0
;
DataRate
sending_rate
=
DataRate
:
:
MinusInfinity
(
)
;
DataSize
size
=
DataSize
:
:
Zero
(
)
;
DataSize
lost_size
=
DataSize
:
:
Zero
(
)
;
int
id
=
-
1
;
}
;
struct
PartialObservation
{
int
num_packets
=
0
;
int
num_lost_packets
=
0
;
DataSize
size
=
DataSize
:
:
Zero
(
)
;
DataSize
lost_size
=
DataSize
:
:
Zero
(
)
;
}
;
static
absl
:
:
optional
<
Config
>
CreateConfig
(
const
FieldTrialsView
*
key_value_config
)
;
bool
IsConfigValid
(
)
const
;
double
GetAverageReportedLossRatio
(
)
const
;
double
GetAverageReportedPacketLossRatio
(
)
const
;
double
GetAverageReportedByteLossRatio
(
)
const
;
std
:
:
vector
<
ChannelParameters
>
GetCandidates
(
bool
in_alr
)
const
;
DataRate
GetCandidateBandwidthUpperBound
(
)
const
;
Derivatives
GetDerivatives
(
const
ChannelParameters
&
channel_parameters
)
const
;
double
GetFeasibleInherentLoss
(
const
ChannelParameters
&
channel_parameters
)
const
;
double
GetInherentLossUpperBound
(
DataRate
bandwidth
)
const
;
double
AdjustBiasFactor
(
double
loss_rate
double
bias_factor
)
const
;
double
GetHighBandwidthBias
(
DataRate
bandwidth
)
const
;
double
GetObjective
(
const
ChannelParameters
&
channel_parameters
)
const
;
DataRate
GetSendingRate
(
DataRate
instantaneous_sending_rate
)
const
;
DataRate
GetInstantUpperBound
(
)
const
;
void
CalculateInstantUpperBound
(
)
;
DataRate
GetInstantLowerBound
(
)
const
;
void
CalculateInstantLowerBound
(
)
;
void
CalculateTemporalWeights
(
)
;
void
NewtonsMethodUpdate
(
ChannelParameters
&
channel_parameters
)
const
;
bool
PushBackObservation
(
rtc
:
:
ArrayView
<
const
PacketResult
>
packet_results
)
;
void
UpdateResult
(
)
;
bool
IsEstimateIncreasingWhenLossLimited
(
DataRate
old_estimate
DataRate
new_estimate
)
;
bool
IsInLossLimitedState
(
)
const
;
absl
:
:
optional
<
DataRate
>
acknowledged_bitrate_
;
absl
:
:
optional
<
Config
>
config_
;
ChannelParameters
current_best_estimate_
;
int
num_observations_
=
0
;
std
:
:
vector
<
Observation
>
observations_
;
PartialObservation
partial_observation_
;
Timestamp
last_send_time_most_recent_observation_
=
Timestamp
:
:
PlusInfinity
(
)
;
Timestamp
last_time_estimate_reduced_
=
Timestamp
:
:
MinusInfinity
(
)
;
absl
:
:
optional
<
DataRate
>
cached_instant_upper_bound_
;
absl
:
:
optional
<
DataRate
>
cached_instant_lower_bound_
;
std
:
:
vector
<
double
>
instant_upper_bound_temporal_weights_
;
std
:
:
vector
<
double
>
temporal_weights_
;
Timestamp
recovering_after_loss_timestamp_
=
Timestamp
:
:
MinusInfinity
(
)
;
DataRate
bandwidth_limit_in_current_window_
=
DataRate
:
:
PlusInfinity
(
)
;
DataRate
min_bitrate_
=
DataRate
:
:
KilobitsPerSec
(
1
)
;
DataRate
max_bitrate_
=
DataRate
:
:
PlusInfinity
(
)
;
DataRate
delay_based_estimate_
=
DataRate
:
:
PlusInfinity
(
)
;
LossBasedBweV2
:
:
Result
loss_based_result_
=
LossBasedBweV2
:
:
Result
(
)
;
Timestamp
last_hold_timestamp_
=
Timestamp
:
:
MinusInfinity
(
)
;
TimeDelta
hold_duration_
=
TimeDelta
:
:
Zero
(
)
;
}
;
}
#
endif
