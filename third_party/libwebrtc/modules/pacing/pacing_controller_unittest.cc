#
include
"
modules
/
pacing
/
pacing_controller
.
h
"
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
transport
/
network_types
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
pacing
/
packet_router
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
explicit_key_value_config
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AnyNumber
;
using
:
:
testing
:
:
Field
;
using
:
:
testing
:
:
Pointee
;
using
:
:
testing
:
:
Property
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
WithoutArgs
;
using
:
:
webrtc
:
:
test
:
:
ExplicitKeyValueConfig
;
namespace
webrtc
{
namespace
{
constexpr
DataRate
kFirstClusterRate
=
DataRate
:
:
KilobitsPerSec
(
900
)
;
constexpr
DataRate
kSecondClusterRate
=
DataRate
:
:
KilobitsPerSec
(
1800
)
;
constexpr
DataRate
kProbingErrorMargin
=
DataRate
:
:
KilobitsPerSec
(
150
)
;
const
float
kPaceMultiplier
=
2
.
5f
;
constexpr
uint32_t
kAudioSsrc
=
12345
;
constexpr
uint32_t
kVideoSsrc
=
234565
;
constexpr
DataRate
kTargetRate
=
DataRate
:
:
KilobitsPerSec
(
800
)
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
BuildPacket
(
RtpPacketMediaType
type
uint32_t
ssrc
uint16_t
sequence_number
int64_t
capture_time_ms
size_t
size
)
{
auto
packet
=
std
:
:
make_unique
<
RtpPacketToSend
>
(
nullptr
)
;
packet
-
>
set_packet_type
(
type
)
;
packet
-
>
SetSsrc
(
ssrc
)
;
packet
-
>
SetSequenceNumber
(
sequence_number
)
;
packet
-
>
set_capture_time
(
Timestamp
:
:
Millis
(
capture_time_ms
)
)
;
packet
-
>
SetPayloadSize
(
size
)
;
return
packet
;
}
class
MediaStream
{
public
:
MediaStream
(
SimulatedClock
&
clock
RtpPacketMediaType
type
uint32_t
ssrc
size_t
packet_size
)
:
clock_
(
clock
)
type_
(
type
)
ssrc_
(
ssrc
)
packet_size_
(
packet_size
)
{
}
std
:
:
unique_ptr
<
RtpPacketToSend
>
BuildNextPacket
(
)
{
return
BuildPacket
(
type_
ssrc_
seq_num_
+
+
clock_
.
TimeInMilliseconds
(
)
packet_size_
)
;
}
std
:
:
unique_ptr
<
RtpPacketToSend
>
BuildNextPacket
(
size_t
size
)
{
return
BuildPacket
(
type_
ssrc_
seq_num_
+
+
clock_
.
TimeInMilliseconds
(
)
size
)
;
}
private
:
SimulatedClock
&
clock_
;
const
RtpPacketMediaType
type_
;
const
uint32_t
ssrc_
;
const
size_t
packet_size_
;
uint16_t
seq_num_
=
1000
;
}
;
class
MockPacingControllerCallback
:
public
PacingController
:
:
PacketSender
{
public
:
void
SendPacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
const
PacedPacketInfo
&
cluster_info
)
override
{
SendPacket
(
packet
-
>
Ssrc
(
)
packet
-
>
SequenceNumber
(
)
packet
-
>
capture_time
(
)
.
ms
(
)
packet
-
>
packet_type
(
)
=
=
RtpPacketMediaType
:
:
kRetransmission
packet
-
>
packet_type
(
)
=
=
RtpPacketMediaType
:
:
kPadding
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
GeneratePadding
(
DataSize
target_size
)
override
{
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
ret
;
size_t
padding_size
=
SendPadding
(
target_size
.
bytes
(
)
)
;
if
(
padding_size
>
0
)
{
auto
packet
=
std
:
:
make_unique
<
RtpPacketToSend
>
(
nullptr
)
;
packet
-
>
SetPayloadSize
(
padding_size
)
;
packet
-
>
set_packet_type
(
RtpPacketMediaType
:
:
kPadding
)
;
ret
.
emplace_back
(
std
:
:
move
(
packet
)
)
;
}
return
ret
;
}
MOCK_METHOD
(
void
SendPacket
(
uint32_t
ssrc
uint16_t
sequence_number
int64_t
capture_timestamp
bool
retransmission
bool
padding
)
)
;
MOCK_METHOD
(
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
FetchFec
(
)
(
override
)
)
;
MOCK_METHOD
(
size_t
SendPadding
(
size_t
target_size
)
)
;
MOCK_METHOD
(
void
OnAbortedRetransmissions
(
uint32_t
rtc
:
:
ArrayView
<
const
uint16_t
>
)
(
override
)
)
;
MOCK_METHOD
(
absl
:
:
optional
<
uint32_t
>
GetRtxSsrcForMedia
(
uint32_t
)
(
const
override
)
)
;
}
;
class
MockPacketSender
:
public
PacingController
:
:
PacketSender
{
public
:
MOCK_METHOD
(
void
SendPacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
const
PacedPacketInfo
&
cluster_info
)
(
override
)
)
;
MOCK_METHOD
(
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
FetchFec
(
)
(
override
)
)
;
MOCK_METHOD
(
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
GeneratePadding
(
DataSize
target_size
)
(
override
)
)
;
MOCK_METHOD
(
void
OnAbortedRetransmissions
(
uint32_t
rtc
:
:
ArrayView
<
const
uint16_t
>
)
(
override
)
)
;
MOCK_METHOD
(
absl
:
:
optional
<
uint32_t
>
GetRtxSsrcForMedia
(
uint32_t
)
(
const
override
)
)
;
}
;
class
PacingControllerPadding
:
public
PacingController
:
:
PacketSender
{
public
:
static
const
size_t
kPaddingPacketSize
=
224
;
PacingControllerPadding
(
)
:
padding_sent_
(
0
)
total_bytes_sent_
(
0
)
{
}
void
SendPacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
const
PacedPacketInfo
&
pacing_info
)
override
{
total_bytes_sent_
+
=
packet
-
>
payload_size
(
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
FetchFec
(
)
override
{
return
{
}
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
GeneratePadding
(
DataSize
target_size
)
override
{
size_t
num_packets
=
(
target_size
.
bytes
(
)
+
kPaddingPacketSize
-
1
)
/
kPaddingPacketSize
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
packets
;
for
(
size_t
i
=
0
;
i
<
num_packets
;
+
+
i
)
{
packets
.
emplace_back
(
std
:
:
make_unique
<
RtpPacketToSend
>
(
nullptr
)
)
;
packets
.
back
(
)
-
>
SetPadding
(
kPaddingPacketSize
)
;
packets
.
back
(
)
-
>
set_packet_type
(
RtpPacketMediaType
:
:
kPadding
)
;
padding_sent_
+
=
kPaddingPacketSize
;
}
return
packets
;
}
void
OnAbortedRetransmissions
(
uint32_t
rtc
:
:
ArrayView
<
const
uint16_t
>
)
override
{
}
absl
:
:
optional
<
uint32_t
>
GetRtxSsrcForMedia
(
uint32_t
)
const
override
{
return
absl
:
:
nullopt
;
}
size_t
padding_sent
(
)
{
return
padding_sent_
;
}
size_t
total_bytes_sent
(
)
{
return
total_bytes_sent_
;
}
private
:
size_t
padding_sent_
;
size_t
total_bytes_sent_
;
}
;
class
PacingControllerProbing
:
public
PacingController
:
:
PacketSender
{
public
:
PacingControllerProbing
(
)
=
default
;
void
SetCanGeneratePadding
(
bool
can_generate
)
{
can_generate_padding_
=
can_generate
;
}
void
SendPacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
const
PacedPacketInfo
&
pacing_info
)
override
{
if
(
packet
-
>
packet_type
(
)
!
=
RtpPacketMediaType
:
:
kPadding
)
{
+
+
packets_sent_
;
}
else
{
+
+
padding_packets_sent_
;
}
last_pacing_info_
=
pacing_info
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
FetchFec
(
)
override
{
return
{
}
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
GeneratePadding
(
DataSize
target_size
)
override
{
if
(
!
can_generate_padding_
)
{
return
{
}
;
}
const
DataSize
kMaxPadding
=
DataSize
:
:
Bytes
(
224
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
packets
;
while
(
target_size
>
DataSize
:
:
Zero
(
)
)
{
DataSize
padding_size
=
std
:
:
min
(
kMaxPadding
target_size
)
;
packets
.
emplace_back
(
std
:
:
make_unique
<
RtpPacketToSend
>
(
nullptr
)
)
;
packets
.
back
(
)
-
>
SetPadding
(
padding_size
.
bytes
(
)
)
;
packets
.
back
(
)
-
>
set_packet_type
(
RtpPacketMediaType
:
:
kPadding
)
;
padding_sent_
+
=
padding_size
.
bytes
(
)
;
target_size
-
=
padding_size
;
}
return
packets
;
}
void
OnAbortedRetransmissions
(
uint32_t
rtc
:
:
ArrayView
<
const
uint16_t
>
)
override
{
}
absl
:
:
optional
<
uint32_t
>
GetRtxSsrcForMedia
(
uint32_t
)
const
override
{
return
absl
:
:
nullopt
;
}
int
packets_sent
(
)
const
{
return
packets_sent_
;
}
int
padding_packets_sent
(
)
const
{
return
padding_packets_sent_
;
}
int
padding_sent
(
)
const
{
return
padding_sent_
;
}
int
total_packets_sent
(
)
const
{
return
packets_sent_
+
padding_sent_
;
}
PacedPacketInfo
last_pacing_info
(
)
const
{
return
last_pacing_info_
;
}
private
:
bool
can_generate_padding_
=
true
;
int
packets_sent_
=
0
;
int
padding_packets_sent_
=
0
;
int
padding_sent_
=
0
;
PacedPacketInfo
last_pacing_info_
;
}
;
class
PacingControllerTest
:
public
:
:
testing
:
:
Test
{
protected
:
PacingControllerTest
(
)
:
clock_
(
123456
)
trials_
(
"
"
)
{
}
void
SendAndExpectPacket
(
PacingController
*
pacer
RtpPacketMediaType
type
uint32_t
ssrc
uint16_t
sequence_number
int64_t
capture_time_ms
size_t
size
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
type
ssrc
sequence_number
capture_time_ms
size
)
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
sequence_number
capture_time_ms
type
=
=
RtpPacketMediaType
:
:
kRetransmission
false
)
)
;
}
void
AdvanceTimeUntil
(
webrtc
:
:
Timestamp
time
)
{
Timestamp
now
=
clock_
.
CurrentTime
(
)
;
clock_
.
AdvanceTime
(
std
:
:
max
(
TimeDelta
:
:
Zero
(
)
time
-
now
)
)
;
}
void
ConsumeInitialBudget
(
PacingController
*
pacer
)
{
const
uint32_t
kSsrc
=
54321
;
uint16_t
sequence_number
=
1234
;
int64_t
capture_time_ms
=
clock_
.
TimeInMilliseconds
(
)
;
const
size_t
kPacketSize
=
250
;
EXPECT_TRUE
(
pacer
-
>
OldestPacketEnqueueTime
(
)
.
IsInfinite
(
)
)
;
const
size_t
packets_to_send_per_interval
=
kTargetRate
.
bps
(
)
*
kPaceMultiplier
/
(
8
*
kPacketSize
*
200
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
+
+
capture_time_ms
kPacketSize
)
;
}
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
}
SimulatedClock
clock_
;
MediaStream
audio_
=
MediaStream
(
clock_
RtpPacketMediaType
:
:
kAudio
kAudioSsrc
100
)
;
MediaStream
video_
=
MediaStream
(
clock_
RtpPacketMediaType
:
:
kVideo
kVideoSsrc
1000
)
;
:
:
testing
:
:
NiceMock
<
MockPacingControllerCallback
>
callback_
;
ExplicitKeyValueConfig
trials_
;
}
;
TEST_F
(
PacingControllerTest
DefaultNoPaddingInSilence
)
{
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
"
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
pacer
.
SetPacingRates
(
kTargetRate
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
clock_
.
AdvanceTimeMilliseconds
(
500
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
PaddingInSilenceWithTrial
)
{
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Pacer
-
PadInSilence
/
Enabled
/
"
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
pacer
.
SetPacingRates
(
kTargetRate
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
2
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
WillOnce
(
Return
(
1000
)
)
;
clock_
.
AdvanceTimeMilliseconds
(
500
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
CongestionWindowAffectsAudioInTrial
)
{
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Pacer
-
BlockAudio
/
Enabled
/
"
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
pacer
.
SetPacingRates
(
DataRate
:
:
KilobitsPerSec
(
10000
)
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
pacer
.
SetCongested
(
true
)
;
pacer
.
EnqueuePacket
(
audio_
.
BuildNextPacket
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPadding
(
1
)
)
.
Times
(
2
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
pacer
.
SetCongested
(
false
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
DefaultCongestionWindowDoesNotAffectAudio
)
{
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
"
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
pacer
.
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
10000000
)
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
pacer
.
SetCongested
(
true
)
;
pacer
.
EnqueuePacket
(
audio_
.
BuildNextPacket
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
BudgetAffectsAudioInTrial
)
{
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Pacer
-
BlockAudio
/
Enabled
/
"
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
const
size_t
kPacketSize
=
1000
;
const
int
kProcessIntervalsPerSecond
=
1000
/
5
;
DataRate
pacing_rate
=
DataRate
:
:
BitsPerSec
(
kPacketSize
/
3
*
8
*
kProcessIntervalsPerSecond
)
;
pacer
.
SetPacingRates
(
pacing_rate
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
kPacketSize
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
pacer
.
EnqueuePacket
(
audio_
.
BuildNextPacket
(
)
)
;
Timestamp
wait_start_time
=
clock_
.
CurrentTime
(
)
;
Timestamp
wait_end_time
=
Timestamp
:
:
MinusInfinity
(
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
WillOnce
(
WithoutArgs
(
[
&
]
(
)
{
wait_end_time
=
clock_
.
CurrentTime
(
)
;
}
)
)
;
while
(
!
wait_end_time
.
IsFinite
(
)
)
{
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
}
const
TimeDelta
expected_wait_time
=
DataSize
:
:
Bytes
(
kPacketSize
)
/
pacing_rate
;
EXPECT_LT
(
(
(
wait_end_time
-
wait_start_time
)
-
expected_wait_time
)
.
Abs
(
)
PacingController
:
:
kMinSleepTime
)
;
}
TEST_F
(
PacingControllerTest
DefaultBudgetDoesNotAffectAudio
)
{
const
size_t
kPacketSize
=
1000
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
"
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
const
int
kProcessIntervalsPerSecond
=
1000
/
5
;
pacer
.
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
kPacketSize
/
3
*
8
*
kProcessIntervalsPerSecond
)
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
kPacketSize
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
pacer
.
EnqueuePacket
(
audio_
.
BuildNextPacket
(
)
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
FirstSentPacketTimeIsSet
)
{
const
Timestamp
kStartTime
=
clock_
.
CurrentTime
(
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
EXPECT_FALSE
(
pacer
-
>
FirstSentPacketTime
(
)
.
has_value
(
)
)
;
pacer
-
>
EnqueuePacket
(
video_
.
BuildNextPacket
(
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
kStartTime
pacer
-
>
FirstSentPacketTime
(
)
)
;
}
TEST_F
(
PacingControllerTest
QueueAndPacePackets
)
{
const
uint32_t
kSsrc
=
12345
;
uint16_t
sequence_number
=
1234
;
const
DataSize
kPackeSize
=
DataSize
:
:
Bytes
(
250
)
;
const
TimeDelta
kSendInterval
=
TimeDelta
:
:
Millis
(
5
)
;
const
size_t
kPacketsToSend
=
(
kSendInterval
*
kTargetRate
)
.
bytes
(
)
*
kPaceMultiplier
/
kPackeSize
.
bytes
(
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kPacketsToSend
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPackeSize
.
bytes
(
)
)
;
}
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
int64_t
queued_packet_timestamp
=
clock_
.
TimeInMilliseconds
(
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
queued_packet_timestamp
kPackeSize
.
bytes
(
)
)
)
;
EXPECT_EQ
(
kPacketsToSend
+
1
pacer
-
>
QueueSizePackets
(
)
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
1
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_LT
(
clock_
.
CurrentTime
(
)
-
start_time
kSendInterval
)
;
EXPECT_CALL
(
callback_
SendPacket
(
kSsrc
sequence_number
queued_packet_timestamp
false
false
)
)
.
Times
(
1
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_GE
(
clock_
.
CurrentTime
(
)
-
start_time
kSendInterval
)
;
EXPECT_EQ
(
pacer
-
>
QueueSizePackets
(
)
0u
)
;
}
TEST_F
(
PacingControllerTest
PaceQueuedPackets
)
{
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
const
size_t
kPacketSize
=
250
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
const
size_t
packets_to_send_per_interval
=
kTargetRate
.
bps
(
)
*
kPaceMultiplier
/
(
8
*
kPacketSize
*
200
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
}
for
(
size_t
j
=
0
;
j
<
packets_to_send_per_interval
*
10
;
+
+
j
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
}
EXPECT_EQ
(
packets_to_send_per_interval
+
packets_to_send_per_interval
*
10
pacer
-
>
QueueSizePackets
(
)
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
packets_to_send_per_interval
*
10
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_EQ
(
pacer
-
>
QueueSizePackets
(
)
packets_to_send_per_interval
*
10
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
_
_
false
false
)
)
.
Times
(
pacer
-
>
QueueSizePackets
(
)
)
;
const
TimeDelta
expected_pace_time
=
DataSize
:
:
Bytes
(
pacer
-
>
QueueSizePackets
(
)
*
kPacketSize
)
/
(
kPaceMultiplier
*
kTargetRate
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
const
TimeDelta
actual_pace_time
=
clock_
.
CurrentTime
(
)
-
start_time
;
EXPECT_LT
(
(
actual_pace_time
-
expected_pace_time
)
.
Abs
(
)
PacingController
:
:
kMinSleepTime
)
;
EXPECT_EQ
(
0u
pacer
-
>
QueueSizePackets
(
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
EXPECT_EQ
(
0u
pacer
-
>
QueueSizePackets
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
250
)
;
}
EXPECT_EQ
(
packets_to_send_per_interval
pacer
-
>
QueueSizePackets
(
)
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_EQ
(
0u
pacer
-
>
QueueSizePackets
(
)
)
;
}
TEST_F
(
PacingControllerTest
RepeatedRetransmissionsAllowed
)
{
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
for
(
size_t
i
=
0
;
i
<
3
;
i
+
+
)
{
constexpr
uint32_t
ssrc
=
333
;
constexpr
uint16_t
sequence_number
=
444
;
constexpr
size_t
bytes
=
250
;
bool
is_retransmission
=
(
i
!
=
0
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
is_retransmission
?
RtpPacketMediaType
:
:
kRetransmission
:
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
clock_
.
TimeInMilliseconds
(
)
bytes
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
}
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
}
TEST_F
(
PacingControllerTest
CanQueuePacketsWithSameSequenceNumberOnDifferentSsrcs
)
{
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
clock_
.
TimeInMilliseconds
(
)
250
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
+
1
sequence_number
clock_
.
TimeInMilliseconds
(
)
250
)
;
clock_
.
AdvanceTimeMilliseconds
(
1000
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
}
TEST_F
(
PacingControllerTest
Padding
)
{
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
const
size_t
kPacketSize
=
250
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
kTargetRate
)
;
const
size_t
kPacketsToSend
=
20
;
for
(
size_t
i
=
0
;
i
<
kPacketsToSend
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
}
const
TimeDelta
expected_pace_time
=
DataSize
:
:
Bytes
(
pacer
-
>
QueueSizePackets
(
)
*
kPacketSize
)
/
(
kPaceMultiplier
*
kTargetRate
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
const
TimeDelta
actual_pace_time
=
clock_
.
CurrentTime
(
)
-
start_time
;
EXPECT_LE
(
(
actual_pace_time
-
expected_pace_time
)
.
Abs
(
)
PacingController
:
:
kMinSleepTime
)
;
const
TimeDelta
time_to_padding_debt_free
=
(
expected_pace_time
*
kPaceMultiplier
)
-
actual_pace_time
;
clock_
.
AdvanceTime
(
time_to_padding_debt_free
-
PacingController
:
:
kMinSleepTime
)
;
pacer
-
>
ProcessPackets
(
)
;
const
size_t
kPaddingPacketsToSend
=
10
;
DataSize
padding_sent
=
DataSize
:
:
Zero
(
)
;
size_t
packets_sent
=
0
;
Timestamp
first_send_time
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
last_send_time
=
Timestamp
:
:
MinusInfinity
(
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
kPaddingPacketsToSend
)
.
WillRepeatedly
(
[
&
]
(
size_t
target_size
)
{
+
+
packets_sent
;
if
(
packets_sent
<
kPaddingPacketsToSend
)
{
padding_sent
+
=
DataSize
:
:
Bytes
(
target_size
)
;
}
if
(
first_send_time
.
IsInfinite
(
)
)
{
first_send_time
=
clock_
.
CurrentTime
(
)
;
}
else
{
last_send_time
=
clock_
.
CurrentTime
(
)
;
}
return
target_size
;
}
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
false
true
)
)
.
Times
(
kPaddingPacketsToSend
)
;
while
(
packets_sent
<
kPaddingPacketsToSend
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TimeDelta
padding_duration
=
last_send_time
-
first_send_time
;
DataRate
padding_rate
=
padding_sent
/
padding_duration
;
EXPECT_EQ
(
padding_rate
kTargetRate
)
;
}
TEST_F
(
PacingControllerTest
NoPaddingBeforeNormalPacket
)
{
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
kTargetRate
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
pacer
-
>
ProcessPackets
(
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
int64_t
capture_time_ms
=
56789
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
capture_time_ms
250
)
;
bool
padding_sent
=
false
;
EXPECT_CALL
(
callback_
SendPadding
)
.
WillOnce
(
[
&
]
(
size_t
padding
)
{
padding_sent
=
true
;
return
padding
;
}
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
_
true
)
)
.
Times
(
1
)
;
while
(
!
padding_sent
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
}
TEST_F
(
PacingControllerTest
VerifyAverageBitrateVaryingMediaPayload
)
{
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
int64_t
capture_time_ms
=
56789
;
const
TimeDelta
kAveragingWindowLength
=
TimeDelta
:
:
Seconds
(
10
)
;
PacingControllerPadding
callback
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback
trials_
)
;
pacer
-
>
SetProbingEnabled
(
false
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
kTargetRate
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
size_t
media_bytes
=
0
;
while
(
clock_
.
CurrentTime
(
)
-
start_time
<
kAveragingWindowLength
)
{
int
rand_value
=
rand
(
)
;
while
(
media_bytes
<
(
kTargetRate
*
(
clock_
.
CurrentTime
(
)
-
start_time
)
)
.
bytes
<
size_t
>
(
)
)
{
size_t
media_payload
=
rand_value
%
400
+
800
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
capture_time_ms
media_payload
)
)
;
media_bytes
+
=
media_payload
;
}
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_NEAR
(
kTargetRate
.
bps
(
)
(
DataSize
:
:
Bytes
(
callback
.
total_bytes_sent
(
)
)
/
kAveragingWindowLength
)
.
bps
(
)
(
kTargetRate
*
0
.
01
)
.
bps
(
)
)
;
}
TEST_F
(
PacingControllerTest
Priority
)
{
uint32_t
ssrc_low_priority
=
12345
;
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
int64_t
capture_time_ms
=
56789
;
int64_t
capture_time_ms_low_priority
=
1234567
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
ConsumeInitialBudget
(
pacer
.
get
(
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc_low_priority
sequence_number
+
+
capture_time_ms_low_priority
250
)
)
;
const
size_t
packets_to_send_per_interval
=
kTargetRate
.
bps
(
)
*
kPaceMultiplier
/
(
8
*
250
*
200
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kRetransmission
ssrc
sequence_number
+
+
capture_time_ms
250
)
)
;
}
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kAudio
ssrc
sequence_number
+
+
capture_time_ms
250
)
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
_
capture_time_ms
_
_
)
)
.
Times
(
packets_to_send_per_interval
+
1
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
1
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_EQ
(
1u
pacer
-
>
QueueSizePackets
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc_low_priority
_
capture_time_ms_low_priority
_
_
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
RetransmissionPriority
)
{
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
int64_t
capture_time_ms
=
45678
;
int64_t
capture_time_ms_retransmission
=
56789
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
const
size_t
packets_to_send_per_interval
=
kTargetRate
.
bps
(
)
*
kPaceMultiplier
/
(
8
*
250
*
200
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
0u
pacer
-
>
QueueSizePackets
(
)
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
capture_time_ms
250
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kRetransmission
ssrc
sequence_number
+
+
capture_time_ms_retransmission
250
)
)
;
}
EXPECT_EQ
(
2
*
packets_to_send_per_interval
pacer
-
>
QueueSizePackets
(
)
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
false
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
_
capture_time_ms_retransmission
true
_
)
)
.
Times
(
packets_to_send_per_interval
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
packets_to_send_per_interval
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_EQ
(
packets_to_send_per_interval
pacer
-
>
QueueSizePackets
(
)
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
true
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
_
capture_time_ms
false
_
)
)
.
Times
(
packets_to_send_per_interval
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_EQ
(
0u
pacer
-
>
QueueSizePackets
(
)
)
;
}
TEST_F
(
PacingControllerTest
HighPrioDoesntAffectBudget
)
{
const
size_t
kPacketSize
=
250
;
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
int64_t
capture_time_ms
=
56789
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
const
size_t
kNumAudioPackets
=
25
;
for
(
size_t
i
=
0
;
i
<
kNumAudioPackets
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kAudio
ssrc
sequence_number
+
+
capture_time_ms
kPacketSize
)
;
}
pacer
-
>
ProcessPackets
(
)
;
const
size_t
kPacketsToSendPerInterval
=
kTargetRate
.
bps
(
)
*
kPaceMultiplier
/
(
8
*
kPacketSize
*
200
)
;
for
(
size_t
i
=
0
;
i
<
kPacketsToSendPerInterval
;
+
+
i
)
{
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
}
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TimeDelta
pacing_time
=
clock_
.
CurrentTime
(
)
-
start_time
;
TimeDelta
expected_pacing_time
=
DataSize
:
:
Bytes
(
kPacketsToSendPerInterval
*
kPacketSize
)
/
(
kTargetRate
*
kPaceMultiplier
)
;
EXPECT_NEAR
(
pacing_time
.
us
<
double
>
(
)
expected_pacing_time
.
us
<
double
>
(
)
PacingController
:
:
kMinSleepTime
.
us
<
double
>
(
)
)
;
}
TEST_F
(
PacingControllerTest
SendsOnlyPaddingWhenCongested
)
{
uint32_t
ssrc
=
202020
;
uint16_t
sequence_number
=
1000
;
int
kPacketSize
=
250
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
pacer
-
>
SetCongested
(
true
)
;
size_t
blocked_packets
=
0
;
int64_t
expected_time_until_padding
=
500
;
while
(
expected_time_until_padding
>
5
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
blocked_packets
+
+
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
ProcessPackets
(
)
;
expected_time_until_padding
-
=
5
;
}
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
EXPECT_CALL
(
callback_
SendPadding
(
1
)
)
.
WillOnce
(
Return
(
1
)
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
_
true
)
)
.
Times
(
1
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
blocked_packets
pacer
-
>
QueueSizePackets
(
)
)
;
}
TEST_F
(
PacingControllerTest
DoesNotAllowOveruseAfterCongestion
)
{
uint32_t
ssrc
=
202020
;
uint16_t
seq_num
=
1000
;
int
size
=
1000
;
auto
now_ms
=
[
this
]
{
return
clock_
.
TimeInMilliseconds
(
)
;
}
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
400
*
8
*
1000
/
5
)
DataRate
:
:
Zero
(
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
seq_num
+
+
now_ms
(
)
size
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
ProcessPackets
(
)
;
pacer
-
>
SetCongested
(
true
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
seq_num
+
+
now_ms
(
)
size
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
0
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
ProcessPackets
(
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
seq_num
+
+
now_ms
(
)
size
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
0
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
ProcessPackets
(
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
seq_num
+
+
now_ms
(
)
size
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
SetCongested
(
false
)
;
pacer
-
>
ProcessPackets
(
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
seq_num
+
+
now_ms
(
)
size
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
0
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
Pause
)
{
uint32_t
ssrc_low_priority
=
12345
;
uint32_t
ssrc
=
12346
;
uint32_t
ssrc_high_priority
=
12347
;
uint16_t
sequence_number
=
1234
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
EXPECT_TRUE
(
pacer
-
>
OldestPacketEnqueueTime
(
)
.
IsInfinite
(
)
)
;
ConsumeInitialBudget
(
pacer
.
get
(
)
)
;
pacer
-
>
Pause
(
)
;
int64_t
capture_time_ms
=
clock_
.
TimeInMilliseconds
(
)
;
const
size_t
packets_to_send_per_interval
=
kTargetRate
.
bps
(
)
*
kPaceMultiplier
/
(
8
*
250
*
200
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc_low_priority
sequence_number
+
+
capture_time_ms
250
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kRetransmission
ssrc
sequence_number
+
+
capture_time_ms
250
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kAudio
ssrc_high_priority
sequence_number
+
+
capture_time_ms
250
)
)
;
}
clock_
.
AdvanceTimeMilliseconds
(
10000
)
;
int64_t
second_capture_time_ms
=
clock_
.
TimeInMilliseconds
(
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc_low_priority
sequence_number
+
+
second_capture_time_ms
250
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kRetransmission
ssrc
sequence_number
+
+
second_capture_time_ms
250
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kAudio
ssrc_high_priority
sequence_number
+
+
second_capture_time_ms
250
)
)
;
}
EXPECT_EQ
(
capture_time_ms
pacer
-
>
OldestPacketEnqueueTime
(
)
.
ms
(
)
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
WillOnce
(
[
]
(
size_t
padding
)
{
return
padding
;
}
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
_
true
)
)
.
Times
(
1
)
;
pacer
-
>
ProcessPackets
(
)
;
const
TimeDelta
kProcessInterval
=
TimeDelta
:
:
Millis
(
5
)
;
TimeDelta
expected_time_until_send
=
PacingController
:
:
kPausedProcessInterval
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
while
(
expected_time_until_send
>
=
kProcessInterval
)
{
pacer
-
>
ProcessPackets
(
)
;
clock_
.
AdvanceTime
(
kProcessInterval
)
;
expected_time_until_send
-
=
kProcessInterval
;
}
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
WillOnce
(
[
]
(
size_t
padding
)
{
return
padding
;
}
)
;
EXPECT_CALL
(
callback_
SendPacket
(
_
_
_
_
true
)
)
.
Times
(
1
)
;
clock_
.
AdvanceTime
(
kProcessInterval
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
{
:
:
testing
:
:
InSequence
sequence
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc_high_priority
_
capture_time_ms
_
_
)
)
.
Times
(
packets_to_send_per_interval
)
;
EXPECT_CALL
(
callback_
SendPacket
(
ssrc_high_priority
_
second_capture_time_ms
_
_
)
)
.
Times
(
packets_to_send_per_interval
)
;
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
_
capture_time_ms
_
_
)
)
.
Times
(
1
)
;
}
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
EXPECT_CALL
(
callback_
SendPacket
(
ssrc
_
second_capture_time_ms
_
_
)
)
.
Times
(
1
)
;
}
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
EXPECT_CALL
(
callback_
SendPacket
(
ssrc_low_priority
_
capture_time_ms
_
_
)
)
.
Times
(
1
)
;
}
for
(
size_t
i
=
0
;
i
<
packets_to_send_per_interval
;
+
+
i
)
{
EXPECT_CALL
(
callback_
SendPacket
(
ssrc_low_priority
_
second_capture_time_ms
_
_
)
)
.
Times
(
1
)
;
}
}
pacer
-
>
Resume
(
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_TRUE
(
pacer
-
>
OldestPacketEnqueueTime
(
)
.
IsInfinite
(
)
)
;
}
TEST_F
(
PacingControllerTest
InactiveFromStart
)
{
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetProbingEnabled
(
false
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
kTargetRate
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
0
)
;
pacer
-
>
ProcessPackets
(
)
;
const
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
const
TimeDelta
time_margin
=
PacingController
:
:
kMinSleepTime
+
TimeDelta
:
:
Micros
(
1
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
start_time
PacingController
:
:
kPausedProcessInterval
)
;
clock_
.
AdvanceTime
(
PacingController
:
:
kPausedProcessInterval
-
time_margin
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
start_time
PacingController
:
:
kPausedProcessInterval
)
;
clock_
.
AdvanceTime
(
time_margin
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
start_time
2
*
PacingController
:
:
kPausedProcessInterval
)
;
}
TEST_F
(
PacingControllerTest
QueueTimeGrowsOverTime
)
{
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
EXPECT_TRUE
(
pacer
-
>
OldestPacketEnqueueTime
(
)
.
IsInfinite
(
)
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
30000
*
kPaceMultiplier
)
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
clock_
.
TimeInMilliseconds
(
)
1200
)
;
clock_
.
AdvanceTimeMilliseconds
(
500
)
;
EXPECT_EQ
(
clock_
.
TimeInMilliseconds
(
)
-
500
pacer
-
>
OldestPacketEnqueueTime
(
)
.
ms
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_TRUE
(
pacer
-
>
OldestPacketEnqueueTime
(
)
.
IsInfinite
(
)
)
;
}
TEST_F
(
PacingControllerTest
ProbingWithInsertedPackets
)
{
const
size_t
kPacketSize
=
1200
;
const
int
kInitialBitrateBps
=
300000
;
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
PacingControllerProbing
packet_sender
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
packet_sender
trials_
)
;
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kSecondClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
1
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
kInitialBitrateBps
*
kPaceMultiplier
)
DataRate
:
:
Zero
(
)
)
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
}
int64_t
start
=
clock_
.
TimeInMilliseconds
(
)
;
while
(
packet_sender
.
packets_sent
(
)
<
5
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
int
packets_sent
=
packet_sender
.
packets_sent
(
)
;
EXPECT_NEAR
(
(
packets_sent
-
1
)
*
kPacketSize
*
8000
/
(
clock_
.
TimeInMilliseconds
(
)
-
start
)
kFirstClusterRate
.
bps
(
)
kProbingErrorMargin
.
bps
(
)
)
;
EXPECT_EQ
(
1
packet_sender
.
padding_sent
(
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
start
=
clock_
.
TimeInMilliseconds
(
)
;
while
(
packet_sender
.
packets_sent
(
)
<
10
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
packets_sent
=
packet_sender
.
packets_sent
(
)
-
packets_sent
;
EXPECT_NEAR
(
(
packets_sent
-
1
)
*
kPacketSize
*
8000
/
(
clock_
.
TimeInMilliseconds
(
)
-
start
)
kSecondClusterRate
.
bps
(
)
kProbingErrorMargin
.
bps
(
)
)
;
}
TEST_F
(
PacingControllerTest
SkipsProbesWhenProcessIntervalTooLarge
)
{
const
size_t
kPacketSize
=
1200
;
const
int
kInitialBitrateBps
=
300000
;
const
uint32_t
ssrc
=
12346
;
const
int
kProbeClusterId
=
3
;
uint16_t
sequence_number
=
1234
;
PacingControllerProbing
packet_sender
;
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Bwe
-
ProbingBehavior
/
max_probe_delay
:
2ms
/
"
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
packet_sender
trials
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
kInitialBitrateBps
*
kPaceMultiplier
)
DataRate
:
:
BitsPerSec
(
kInitialBitrateBps
)
)
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
}
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
DataRate
:
:
KilobitsPerSec
(
10000
)
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
kProbeClusterId
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
const
int
packets_sent_before_probe
=
packet_sender
.
packets_sent
(
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
packet_sender
.
packets_sent
(
)
packets_sent_before_probe
+
1
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
TimeDelta
time_between_probes
=
clock_
.
CurrentTime
(
)
-
start_time
;
clock_
.
AdvanceTime
(
time_between_probes
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
packet_sender
.
packets_sent
(
)
packets_sent_before_probe
+
2
)
;
PacedPacketInfo
last_pacing_info
=
packet_sender
.
last_pacing_info
(
)
;
EXPECT_EQ
(
last_pacing_info
.
probe_cluster_id
kProbeClusterId
)
;
const
Timestamp
probe_time
=
clock_
.
CurrentTime
(
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
clock_
.
CurrentTime
(
)
)
;
BitrateProberConfig
probing_config
(
&
trials
)
;
EXPECT_GT
(
probing_config
.
max_probe_delay
.
Get
(
)
TimeDelta
:
:
Zero
(
)
)
;
clock_
.
AdvanceTime
(
probing_config
.
max_probe_delay
.
Get
(
)
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
probe_time
)
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Micros
(
1
)
)
;
int
packets_sent_before_timeout
=
packet_sender
.
total_packets_sent
(
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
probe_time
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_EQ
(
packet_sender
.
total_packets_sent
(
)
packets_sent_before_timeout
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
const
int
expected_probe_id
=
PacedPacketInfo
:
:
kNotAProbe
;
EXPECT_EQ
(
packet_sender
.
last_pacing_info
(
)
.
probe_cluster_id
expected_probe_id
)
;
}
TEST_F
(
PacingControllerTest
ProbingWithPaddingSupport
)
{
const
size_t
kPacketSize
=
1200
;
const
int
kInitialBitrateBps
=
300000
;
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
PacingControllerProbing
packet_sender
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
packet_sender
trials_
)
;
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
kInitialBitrateBps
*
kPaceMultiplier
)
DataRate
:
:
Zero
(
)
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
}
int64_t
start
=
clock_
.
TimeInMilliseconds
(
)
;
int
process_count
=
0
;
while
(
process_count
<
5
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
+
+
process_count
;
}
int
packets_sent
=
packet_sender
.
packets_sent
(
)
;
int
padding_sent
=
packet_sender
.
padding_sent
(
)
;
EXPECT_GT
(
packets_sent
0
)
;
EXPECT_GT
(
padding_sent
0
)
;
EXPECT_NEAR
(
(
packets_sent
*
kPacketSize
*
8000
+
padding_sent
)
/
(
clock_
.
TimeInMilliseconds
(
)
-
start
)
kFirstClusterRate
.
bps
(
)
kProbingErrorMargin
.
bps
(
)
)
;
}
TEST_F
(
PacingControllerTest
CanProbeWithPaddingBeforeFirstMediaPacket
)
{
const
int
kInitialBitrateBps
=
300000
;
PacingControllerProbing
packet_sender
;
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Bwe
-
ProbingBehavior
/
min_packet_size
:
0
/
"
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
packet_sender
trials
)
;
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
kInitialBitrateBps
*
kPaceMultiplier
)
DataRate
:
:
Zero
(
)
)
;
Timestamp
start
=
clock_
.
CurrentTime
(
)
;
Timestamp
next_process
=
pacer
-
>
NextSendTime
(
)
;
while
(
clock_
.
CurrentTime
(
)
<
start
+
TimeDelta
:
:
Millis
(
100
)
&
&
next_process
.
IsFinite
(
)
)
{
AdvanceTimeUntil
(
next_process
)
;
pacer
-
>
ProcessPackets
(
)
;
next_process
=
pacer
-
>
NextSendTime
(
)
;
}
EXPECT_GT
(
packet_sender
.
padding_packets_sent
(
)
5
)
;
}
TEST_F
(
PacingControllerTest
CanNotProbeWithPaddingIfGeneratePaddingFails
)
{
const
int
kInitialBitrateBps
=
300000
;
PacingControllerProbing
packet_sender
;
packet_sender
.
SetCanGeneratePadding
(
false
)
;
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Bwe
-
ProbingBehavior
/
min_packet_size
:
0
/
"
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
packet_sender
trials
)
;
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
kInitialBitrateBps
*
kPaceMultiplier
)
DataRate
:
:
Zero
(
)
)
;
Timestamp
start
=
clock_
.
CurrentTime
(
)
;
int
process_count
=
0
;
Timestamp
next_process
=
pacer
-
>
NextSendTime
(
)
;
while
(
clock_
.
CurrentTime
(
)
<
start
+
TimeDelta
:
:
Millis
(
100
)
&
&
next_process
.
IsFinite
(
)
)
{
AdvanceTimeUntil
(
next_process
)
;
pacer
-
>
ProcessPackets
(
)
;
+
+
process_count
;
next_process
=
pacer
-
>
NextSendTime
(
)
;
}
EXPECT_LT
(
process_count
10
)
;
EXPECT_EQ
(
packet_sender
.
padding_packets_sent
(
)
0
)
;
}
TEST_F
(
PacingControllerTest
PaddingOveruse
)
{
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
const
size_t
kPacketSize
=
1200
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
60000
*
kPaceMultiplier
)
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
pacer
-
>
ProcessPackets
(
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
pacer
-
>
SetPacingRates
(
DataRate
:
:
BitsPerSec
(
60000
*
kPaceMultiplier
)
DataRate
:
:
BitsPerSec
(
30000
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
EXPECT_LT
(
TimeDelta
:
:
Millis
(
5
)
pacer
-
>
ExpectedQueueTime
(
)
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
ProbeClusterId
)
{
MockPacketSender
callback
;
uint32_t
ssrc
=
12346
;
uint16_t
sequence_number
=
1234
;
const
size_t
kPacketSize
=
1200
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback
trials_
)
;
pacer
-
>
CreateProbeClusters
(
std
:
:
vector
<
ProbeClusterConfig
>
(
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kSecondClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
1
}
}
)
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
kTargetRate
)
;
pacer
-
>
SetProbingEnabled
(
true
)
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
)
;
}
EXPECT_CALL
(
callback
SendPacket
(
_
Field
(
&
PacedPacketInfo
:
:
probe_cluster_id
0
)
)
)
.
Times
(
5
)
;
for
(
int
i
=
0
;
i
<
5
;
+
+
i
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
EXPECT_CALL
(
callback
SendPacket
(
_
Field
(
&
PacedPacketInfo
:
:
probe_cluster_id
1
)
)
)
.
Times
(
5
)
;
for
(
int
i
=
0
;
i
<
5
;
+
+
i
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
const
int
kNotAProbe
=
PacedPacketInfo
:
:
kNotAProbe
;
EXPECT_CALL
(
callback
GeneratePadding
)
.
WillOnce
(
[
&
]
(
DataSize
padding_size
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
padding_packets
;
padding_packets
.
emplace_back
(
BuildPacket
(
RtpPacketMediaType
:
:
kPadding
ssrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
padding_size
.
bytes
(
)
)
)
;
return
padding_packets
;
}
)
;
bool
non_probe_packet_seen
=
false
;
EXPECT_CALL
(
callback
SendPacket
)
.
WillOnce
(
[
&
]
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
const
PacedPacketInfo
&
cluster_info
)
{
EXPECT_EQ
(
cluster_info
.
probe_cluster_id
kNotAProbe
)
;
non_probe_packet_seen
=
true
;
}
)
;
while
(
!
non_probe_packet_seen
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
}
TEST_F
(
PacingControllerTest
OwnedPacketPrioritizedOnType
)
{
MockPacketSender
callback
;
uint32_t
ssrc
=
123
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback
trials_
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
for
(
RtpPacketMediaType
type
:
{
RtpPacketMediaType
:
:
kPadding
RtpPacketMediaType
:
:
kForwardErrorCorrection
RtpPacketMediaType
:
:
kVideo
RtpPacketMediaType
:
:
kRetransmission
RtpPacketMediaType
:
:
kAudio
}
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
type
+
+
ssrc
123
clock_
.
TimeInMilliseconds
(
)
150
)
)
;
}
:
:
testing
:
:
InSequence
seq
;
EXPECT_CALL
(
callback
SendPacket
(
Pointee
(
Property
(
&
RtpPacketToSend
:
:
packet_type
RtpPacketMediaType
:
:
kAudio
)
)
_
)
)
;
EXPECT_CALL
(
callback
SendPacket
(
Pointee
(
Property
(
&
RtpPacketToSend
:
:
packet_type
RtpPacketMediaType
:
:
kRetransmission
)
)
_
)
)
;
EXPECT_CALL
(
callback
SendPacket
(
Pointee
(
Property
(
&
RtpPacketToSend
:
:
packet_type
RtpPacketMediaType
:
:
kForwardErrorCorrection
)
)
_
)
)
;
EXPECT_CALL
(
callback
SendPacket
(
Pointee
(
Property
(
&
RtpPacketToSend
:
:
packet_type
RtpPacketMediaType
:
:
kVideo
)
)
_
)
)
;
EXPECT_CALL
(
callback
SendPacket
(
Pointee
(
Property
(
&
RtpPacketToSend
:
:
packet_type
RtpPacketMediaType
:
:
kPadding
)
)
_
)
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
}
TEST_F
(
PacingControllerTest
SmallFirstProbePacket
)
{
MockPacketSender
callback
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback
trials_
)
;
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
pacer
-
>
EnqueuePacket
(
audio_
.
BuildNextPacket
(
234
)
)
;
EXPECT_CALL
(
callback
GeneratePadding
(
DataSize
:
:
Bytes
(
1
)
)
)
.
WillOnce
(
[
&
]
(
DataSize
padding_size
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
padding_packets
;
padding_packets
.
emplace_back
(
BuildPacket
(
RtpPacketMediaType
:
:
kPadding
kAudioSsrc
1
clock_
.
TimeInMilliseconds
(
)
1
)
)
;
return
padding_packets
;
}
)
;
size_t
packets_sent
=
0
;
bool
media_seen
=
false
;
EXPECT_CALL
(
callback
SendPacket
)
.
Times
(
AnyNumber
(
)
)
.
WillRepeatedly
(
[
&
]
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
const
PacedPacketInfo
&
cluster_info
)
{
if
(
packets_sent
=
=
0
)
{
EXPECT_EQ
(
packet
-
>
packet_type
(
)
RtpPacketMediaType
:
:
kPadding
)
;
}
else
{
if
(
packet
-
>
packet_type
(
)
=
=
RtpPacketMediaType
:
:
kAudio
)
{
media_seen
=
true
;
}
}
packets_sent
+
+
;
}
)
;
while
(
!
media_seen
)
{
pacer
-
>
ProcessPackets
(
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
}
}
TEST_F
(
PacingControllerTest
TaskLate
)
{
DataRate
kSendRate
=
DataRate
:
:
KilobitsPerSec
(
30
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kSendRate
DataRate
:
:
Zero
(
)
)
;
pacer
-
>
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
-
>
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
-
>
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
-
>
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
pacer
-
>
ProcessPackets
(
)
;
Timestamp
next_send_time
=
pacer
-
>
NextSendTime
(
)
;
const
TimeDelta
time_between_packets
=
next_send_time
-
clock_
.
CurrentTime
(
)
;
const
TimeDelta
kOffset
=
TimeDelta
:
:
Millis
(
1
)
;
clock_
.
AdvanceTime
(
(
time_between_packets
*
3
)
-
kOffset
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
2
)
;
pacer
-
>
ProcessPackets
(
)
;
next_send_time
=
pacer
-
>
NextSendTime
(
)
;
const
TimeDelta
time_left
=
next_send_time
-
clock_
.
CurrentTime
(
)
;
EXPECT_EQ
(
time_left
.
RoundTo
(
TimeDelta
:
:
Millis
(
1
)
)
kOffset
)
;
clock_
.
AdvanceTime
(
time_left
)
;
EXPECT_CALL
(
callback_
SendPacket
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
NoProbingWhilePaused
)
{
uint32_t
ssrc
=
12345
;
uint16_t
sequence_number
=
1234
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetProbingEnabled
(
true
)
;
pacer
-
>
SetPacingRates
(
kTargetRate
*
kPaceMultiplier
DataRate
:
:
Zero
(
)
)
;
pacer
-
>
CreateProbeClusters
(
std
:
:
vector
<
ProbeClusterConfig
>
(
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kFirstClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
0
}
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
kSecondClusterRate
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
1
}
}
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
ssrc
sequence_number
clock_
.
TimeInMilliseconds
(
)
250
)
;
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
std
:
:
vector
<
ProbeClusterConfig
>
probe_clusters
=
{
{
.
at_time
=
clock_
.
CurrentTime
(
)
.
target_data_rate
=
DataRate
:
:
KilobitsPerSec
(
10000
)
.
target_duration
=
TimeDelta
:
:
Millis
(
15
)
.
target_probe_count
=
5
.
id
=
3
}
}
;
pacer
-
>
CreateProbeClusters
(
probe_clusters
)
;
EXPECT_LT
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
PacingController
:
:
kPausedProcessInterval
)
;
pacer
-
>
Pause
(
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
PacingController
:
:
kPausedProcessInterval
)
;
}
TEST_F
(
PacingControllerTest
AudioNotPacedEvenWhenAccountedFor
)
{
const
uint32_t
kSsrc
=
12345
;
uint16_t
sequence_number
=
1234
;
const
size_t
kPacketSize
=
123
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetAccountForAudioPackets
(
true
)
;
pacer
-
>
SetPacingRates
(
DataSize
:
:
Bytes
(
kPacketSize
)
/
TimeDelta
:
:
Seconds
(
1
)
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kAudio
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
pacer
-
>
ProcessPackets
(
)
;
clock_
.
AdvanceTimeMilliseconds
(
5
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kAudio
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
PaddingResumesAfterSaturationEvenWithConcurrentAudio
)
{
const
uint32_t
kSsrc
=
12345
;
const
DataRate
kPacingDataRate
=
DataRate
:
:
KilobitsPerSec
(
125
)
;
const
DataRate
kPaddingDataRate
=
DataRate
:
:
KilobitsPerSec
(
100
)
;
const
TimeDelta
kMaxBufferInTime
=
TimeDelta
:
:
Millis
(
500
)
;
const
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
130
)
;
const
TimeDelta
kAudioPacketInterval
=
TimeDelta
:
:
Millis
(
20
)
;
for
(
bool
account_for_audio
:
{
false
true
}
)
{
uint16_t
sequence_number
=
1234
;
MockPacketSender
callback
;
EXPECT_CALL
(
callback
SendPacket
)
.
Times
(
AnyNumber
(
)
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback
trials_
)
;
pacer
-
>
SetAccountForAudioPackets
(
account_for_audio
)
;
pacer
-
>
SetPacingRates
(
kPacingDataRate
kPaddingDataRate
)
;
const
TimeDelta
kPaddingSaturationTime
=
kMaxBufferInTime
*
kPaddingDataRate
/
(
kPacingDataRate
-
kPaddingDataRate
)
;
const
DataSize
kVideoToSend
=
kPaddingSaturationTime
*
kPacingDataRate
;
const
DataSize
kVideoPacketSize
=
DataSize
:
:
Bytes
(
1200
)
;
DataSize
video_sent
=
DataSize
:
:
Zero
(
)
;
while
(
video_sent
<
kVideoToSend
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kVideoPacketSize
.
bytes
(
)
)
)
;
video_sent
+
=
kVideoPacketSize
;
}
while
(
pacer
-
>
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
pacer
-
>
SetPacingRates
(
kPacingDataRate
kPaddingDataRate
)
;
bool
padding_seen
=
false
;
EXPECT_CALL
(
callback
GeneratePadding
)
.
WillOnce
(
[
&
]
(
DataSize
padding_size
)
{
padding_seen
=
true
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
padding_packets
;
padding_packets
.
emplace_back
(
BuildPacket
(
RtpPacketMediaType
:
:
kPadding
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
padding_size
.
bytes
(
)
)
)
;
return
padding_packets
;
}
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
Timestamp
last_audio_time
=
start_time
;
while
(
!
padding_seen
)
{
Timestamp
now
=
clock_
.
CurrentTime
(
)
;
Timestamp
next_send_time
=
pacer
-
>
NextSendTime
(
)
;
TimeDelta
sleep_time
=
std
:
:
min
(
next_send_time
last_audio_time
+
kAudioPacketInterval
)
-
now
;
clock_
.
AdvanceTime
(
sleep_time
)
;
while
(
clock_
.
CurrentTime
(
)
>
=
last_audio_time
+
kAudioPacketInterval
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kAudio
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
)
;
last_audio_time
+
=
kAudioPacketInterval
;
}
pacer
-
>
ProcessPackets
(
)
;
}
const
DataRate
kAudioDataRate
=
kPacketSize
/
kAudioPacketInterval
;
const
TimeDelta
expected_drain_time
=
account_for_audio
?
(
kMaxBufferInTime
*
kPaddingDataRate
/
(
kPaddingDataRate
-
kAudioDataRate
)
)
:
kMaxBufferInTime
;
const
TimeDelta
actual_drain_time
=
clock_
.
CurrentTime
(
)
-
start_time
;
EXPECT_NEAR
(
actual_drain_time
.
ms
(
)
expected_drain_time
.
ms
(
)
expected_drain_time
.
ms
(
)
*
0
.
02
)
<
<
"
where
account_for_audio
=
"
<
<
(
account_for_audio
?
"
true
"
:
"
false
"
)
;
}
}
TEST_F
(
PacingControllerTest
AccountsForAudioEnqueueTime
)
{
const
uint32_t
kSsrc
=
12345
;
const
DataRate
kPacingDataRate
=
DataRate
:
:
KilobitsPerSec
(
125
)
;
const
DataRate
kPaddingDataRate
=
DataRate
:
:
Zero
(
)
;
const
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
130
)
;
const
TimeDelta
kPacketPacingTime
=
kPacketSize
/
kPacingDataRate
;
uint32_t
sequnce_number
=
1
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetAccountForAudioPackets
(
true
)
;
pacer
-
>
SetPacingRates
(
kPacingDataRate
kPaddingDataRate
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kAudio
kSsrc
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kAudio
kSsrc
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
;
clock_
.
AdvanceTime
(
kPacketPacingTime
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
+
1
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
kPacketPacingTime
)
;
}
TEST_F
(
PacingControllerTest
NextSendTimeAccountsForPadding
)
{
const
uint32_t
kSsrc
=
12345
;
const
DataRate
kPacingDataRate
=
DataRate
:
:
KilobitsPerSec
(
125
)
;
const
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
130
)
;
const
TimeDelta
kPacketPacingTime
=
kPacketSize
/
kPacingDataRate
;
uint32_t
sequnce_number
=
1
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kPacingDataRate
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
kSsrc
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
PacingController
:
:
kPausedProcessInterval
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
kSsrc
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
kPacketPacingTime
)
;
clock_
.
AdvanceTime
(
kPacketPacingTime
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
PacingController
:
:
kPausedProcessInterval
)
;
pacer
-
>
SetPacingRates
(
kPacingDataRate
kPacingDataRate
/
2
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
kPacketPacingTime
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
WillOnce
(
Return
(
kPacketSize
.
bytes
(
)
)
)
;
clock_
.
AdvanceTime
(
kPacketPacingTime
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
kPacketPacingTime
*
2
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
)
;
EXPECT_EQ
(
pacer
-
>
NextSendTime
(
)
-
clock_
.
CurrentTime
(
)
kPacketPacingTime
)
;
}
TEST_F
(
PacingControllerTest
PaddingTargetAccountsForPaddingRate
)
{
const
TimeDelta
kPaddingTarget
=
TimeDelta
:
:
Millis
(
5
)
;
srand
(
0
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
const
uint32_t
kSsrc
=
12345
;
const
DataRate
kPacingDataRate
=
DataRate
:
:
KilobitsPerSec
(
125
)
;
const
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
130
)
;
uint32_t
sequnce_number
=
1
;
pacer
-
>
SetPacingRates
(
kPacingDataRate
kPacingDataRate
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
kSsrc
sequnce_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
size_t
expected_padding_target_bytes
=
(
kPaddingTarget
*
kPacingDataRate
)
.
bytes
(
)
;
EXPECT_CALL
(
callback_
SendPadding
(
expected_padding_target_bytes
)
)
.
WillOnce
(
Return
(
expected_padding_target_bytes
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
pacer
-
>
SetPacingRates
(
kPacingDataRate
kPacingDataRate
/
2
)
;
EXPECT_CALL
(
callback_
SendPadding
(
expected_padding_target_bytes
/
2
)
)
.
WillOnce
(
Return
(
expected_padding_target_bytes
/
2
)
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
SendsFecPackets
)
{
const
uint32_t
kSsrc
=
12345
;
const
uint32_t
kFlexSsrc
=
54321
;
uint16_t
sequence_number
=
1234
;
uint16_t
flexfec_sequence_number
=
4321
;
const
size_t
kPacketSize
=
123
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
DataSize
:
:
Bytes
(
1000
*
kPacketSize
)
/
TimeDelta
:
:
Seconds
(
1
)
DataRate
:
:
Zero
(
)
)
;
int64_t
now
=
clock_
.
TimeInMilliseconds
(
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
now
kPacketSize
)
)
;
EXPECT_CALL
(
callback_
SendPacket
(
kSsrc
sequence_number
now
false
false
)
)
;
EXPECT_CALL
(
callback_
FetchFec
)
.
WillOnce
(
[
&
]
(
)
{
EXPECT_CALL
(
callback_
SendPacket
(
kFlexSsrc
flexfec_sequence_number
now
false
false
)
)
;
EXPECT_CALL
(
callback_
FetchFec
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
fec_packets
;
fec_packets
.
push_back
(
BuildPacket
(
RtpPacketMediaType
:
:
kForwardErrorCorrection
kFlexSsrc
flexfec_sequence_number
now
kPacketSize
)
)
;
return
fec_packets
;
}
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
AdvanceTimeUntil
(
pacer
-
>
NextSendTime
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
GapInPacingDoesntAccumulateBudget
)
{
const
uint32_t
kSsrc
=
12345
;
uint16_t
sequence_number
=
1234
;
const
DataSize
kPackeSize
=
DataSize
:
:
Bytes
(
250
)
;
const
TimeDelta
kPacketSendTime
=
TimeDelta
:
:
Millis
(
15
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
kPackeSize
/
kPacketSendTime
DataRate
:
:
Zero
(
)
)
;
SendAndExpectPacket
(
pacer
.
get
(
)
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
+
+
clock_
.
TimeInMilliseconds
(
)
kPackeSize
.
bytes
(
)
)
;
pacer
-
>
ProcessPackets
(
)
;
:
:
testing
:
:
Mock
:
:
VerifyAndClearExpectations
(
&
callback_
)
;
clock_
.
AdvanceTime
(
2
*
kPacketSendTime
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
+
1
clock_
.
TimeInMilliseconds
(
)
kPackeSize
.
bytes
(
)
)
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kSsrc
sequence_number
+
2
clock_
.
TimeInMilliseconds
(
)
kPackeSize
.
bytes
(
)
)
)
;
EXPECT_CALL
(
callback_
SendPacket
(
kSsrc
sequence_number
+
1
clock_
.
TimeInMilliseconds
(
)
false
false
)
)
;
pacer
-
>
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
HandlesSubMicrosecondSendIntervals
)
{
static
constexpr
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
1
)
;
static
constexpr
TimeDelta
kPacketSendTime
=
TimeDelta
:
:
Micros
(
1
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
2
*
kPacketSize
/
kPacketSendTime
DataRate
:
:
Zero
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
2
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
12345
i
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
)
;
}
pacer
-
>
ProcessPackets
(
)
;
EXPECT_GT
(
pacer
-
>
NextSendTime
(
)
clock_
.
CurrentTime
(
)
)
;
}
TEST_F
(
PacingControllerTest
HandlesSubMicrosecondPaddingInterval
)
{
static
constexpr
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
1
)
;
static
constexpr
TimeDelta
kPacketSendTime
=
TimeDelta
:
:
Micros
(
1
)
;
auto
pacer
=
std
:
:
make_unique
<
PacingController
>
(
&
clock_
&
callback_
trials_
)
;
pacer
-
>
SetPacingRates
(
2
*
kPacketSize
/
kPacketSendTime
2
*
kPacketSize
/
kPacketSendTime
)
;
EXPECT_CALL
(
callback_
SendPacket
)
;
pacer
-
>
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
12345
1234
clock_
.
TimeInMilliseconds
(
)
kPacketSize
.
bytes
(
)
)
)
;
pacer
-
>
ProcessPackets
(
)
;
EXPECT_GT
(
pacer
-
>
NextSendTime
(
)
clock_
.
CurrentTime
(
)
)
;
}
TEST_F
(
PacingControllerTest
SendsPacketsInBurstImmediately
)
{
constexpr
TimeDelta
kMaxDelay
=
TimeDelta
:
:
Millis
(
20
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials_
)
;
pacer
.
SetSendBurstInterval
(
kMaxDelay
)
;
pacer
.
SetPacingRates
(
DataRate
:
:
BytesPerSec
(
10000
)
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
100
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
100
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
100
)
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_EQ
(
pacer
.
QueueSizePackets
(
)
1u
)
;
EXPECT_EQ
(
pacer
.
NextSendTime
(
)
clock_
.
CurrentTime
(
)
+
kMaxDelay
)
;
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_EQ
(
pacer
.
QueueSizePackets
(
)
0u
)
;
}
TEST_F
(
PacingControllerTest
SendsPacketsInBurstEvenIfNotEnqueedAtSameTime
)
{
constexpr
TimeDelta
kMaxDelay
=
TimeDelta
:
:
Millis
(
20
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials_
)
;
pacer
.
SetSendBurstInterval
(
kMaxDelay
)
;
pacer
.
SetPacingRates
(
DataRate
:
:
BytesPerSec
(
10000
)
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
200
)
)
;
EXPECT_EQ
(
pacer
.
NextSendTime
(
)
clock_
.
CurrentTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
1
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
200
)
)
;
EXPECT_EQ
(
pacer
.
NextSendTime
(
)
clock_
.
CurrentTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_EQ
(
pacer
.
QueueSizePackets
(
)
0u
)
;
}
TEST_F
(
PacingControllerTest
RespectsTargetRateWhenSendingPacketsInBursts
)
{
PacingController
pacer
(
&
clock_
&
callback_
trials_
)
;
pacer
.
SetSendBurstInterval
(
TimeDelta
:
:
Millis
(
20
)
)
;
pacer
.
SetAccountForAudioPackets
(
true
)
;
pacer
.
SetPacingRates
(
DataRate
:
:
KilobitsPerSec
(
1000
)
DataRate
:
:
Zero
(
)
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
12
)
;
int
number_of_bursts
=
0
;
while
(
clock_
.
CurrentTime
(
)
<
start_time
+
TimeDelta
:
:
Millis
(
100
)
)
{
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
1000
)
)
;
if
(
pacer
.
NextSendTime
(
)
<
=
clock_
.
CurrentTime
(
)
)
{
pacer
.
ProcessPackets
(
)
;
+
+
number_of_bursts
;
}
clock_
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
5
)
)
;
}
EXPECT_EQ
(
pacer
.
QueueSizePackets
(
)
88u
)
;
EXPECT_EQ
(
number_of_bursts
4
)
;
}
TEST_F
(
PacingControllerTest
RespectsQueueTimeLimit
)
{
static
constexpr
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
100
)
;
static
constexpr
DataRate
kNominalPacingRate
=
DataRate
:
:
KilobitsPerSec
(
200
)
;
static
constexpr
TimeDelta
kPacketPacingTime
=
kPacketSize
/
kNominalPacingRate
;
static
constexpr
TimeDelta
kQueueTimeLimit
=
TimeDelta
:
:
Millis
(
1000
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials_
)
;
pacer
.
SetPacingRates
(
kNominalPacingRate
DataRate
:
:
Zero
(
)
)
;
pacer
.
SetQueueTimeLimit
(
kQueueTimeLimit
)
;
static
constexpr
int
kNumPackets
=
kQueueTimeLimit
/
kPacketPacingTime
;
for
(
int
i
=
0
;
i
<
kNumPackets
;
+
+
i
)
{
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
kPacketSize
.
bytes
(
)
)
)
;
}
EXPECT_EQ
(
pacer
.
ExpectedQueueTime
(
)
kQueueTimeLimit
)
;
EXPECT_EQ
(
pacer
.
pacing_rate
(
)
kNominalPacingRate
)
;
for
(
int
i
=
0
;
i
<
kNumPackets
;
+
+
i
)
{
pacer
.
EnqueuePacket
(
video_
.
BuildNextPacket
(
kPacketSize
.
bytes
(
)
)
)
;
}
EXPECT_EQ
(
pacer
.
ExpectedQueueTime
(
)
kQueueTimeLimit
)
;
EXPECT_EQ
(
pacer
.
pacing_rate
(
)
2
*
kNominalPacingRate
)
;
Timestamp
start_time
=
clock_
.
CurrentTime
(
)
;
while
(
pacer
.
QueueSizePackets
(
)
>
0
)
{
AdvanceTimeUntil
(
pacer
.
NextSendTime
(
)
)
;
pacer
.
ProcessPackets
(
)
;
}
EXPECT_EQ
(
clock_
.
CurrentTime
(
)
-
start_time
kQueueTimeLimit
)
;
EXPECT_EQ
(
pacer
.
pacing_rate
(
)
kNominalPacingRate
)
;
}
TEST_F
(
PacingControllerTest
BudgetDoesNotAffectRetransmissionInsTrial
)
{
const
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
1000
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
const
test
:
:
ExplicitKeyValueConfig
trials
(
"
WebRTC
-
Pacer
-
FastRetransmissions
/
Enabled
/
"
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials
)
;
pacer
.
SetPacingRates
(
kTargetRate
DataRate
:
:
Zero
(
)
)
;
pacer
.
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kVideoSsrc
1
1
kPacketSize
.
bytes
(
)
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
;
pacer
.
ProcessPackets
(
)
;
EXPECT_GT
(
pacer
.
NextSendTime
(
)
clock_
.
CurrentTime
(
)
)
;
EXPECT_CALL
(
callback_
SendPacket
)
;
pacer
.
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kRetransmission
kVideoSsrc
1
1
kPacketSize
.
bytes
(
)
)
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
AbortsAfterReachingCircuitBreakLimit
)
{
const
DataSize
kPacketSize
=
DataSize
:
:
Bytes
(
1000
)
;
EXPECT_CALL
(
callback_
SendPadding
)
.
Times
(
0
)
;
PacingController
pacer
(
&
clock_
&
callback_
trials_
)
;
pacer
.
SetPacingRates
(
kTargetRate
DataRate
:
:
Zero
(
)
)
;
pacer
.
SetCircuitBreakerThreshold
(
1
)
;
EXPECT_CALL
(
callback_
SendPacket
)
.
Times
(
1
)
;
pacer
.
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kVideoSsrc
1
1
kPacketSize
.
bytes
(
)
)
)
;
pacer
.
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kVideoSsrc
2
2
kPacketSize
.
bytes
(
)
)
)
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
1
)
)
;
pacer
.
ProcessPackets
(
)
;
}
TEST_F
(
PacingControllerTest
DoesNotPadIfProcessThreadIsBorked
)
{
PacingControllerPadding
callback
;
PacingController
pacer
(
&
clock_
&
callback
trials_
)
;
pacer
.
SetPacingRates
(
kTargetRate
kTargetRate
)
;
pacer
.
EnqueuePacket
(
BuildPacket
(
RtpPacketMediaType
:
:
kVideo
kVideoSsrc
1
1
1000
)
)
;
clock_
.
AdvanceTime
(
TimeDelta
:
:
Seconds
(
42
)
)
;
pacer
.
ProcessPackets
(
)
;
const
DataSize
kMaxPadding
=
(
PacingController
:
:
kMaxPaddingReplayDuration
+
PacingController
:
:
kTargetPaddingDuration
)
*
kTargetRate
;
EXPECT_LE
(
callback
.
padding_sent
(
)
kMaxPadding
.
bytes
<
size_t
>
(
)
)
;
}
}
}
