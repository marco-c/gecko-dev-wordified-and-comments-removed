#
ifndef
MODULES_PACING_TASK_QUEUE_PACED_SENDER_H_
#
define
MODULES_PACING_TASK_QUEUE_PACED_SENDER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
task_queue_factory
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
include
/
module
.
h
"
#
include
"
modules
/
pacing
/
pacing_controller
.
h
"
#
include
"
modules
/
pacing
/
packet_router
.
h
"
#
include
"
modules
/
pacing
/
rtp_packet_pacer
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
Clock
;
class
RtcEventLog
;
class
TaskQueuePacedSender
:
public
RtpPacketPacer
public
RtpPacketSender
{
public
:
TaskQueuePacedSender
(
Clock
*
clock
PacketRouter
*
packet_router
RtcEventLog
*
event_log
const
WebRtcKeyValueConfig
*
field_trials
TaskQueueFactory
*
task_queue_factory
TimeDelta
hold_back_window
=
PacingController
:
:
kMinSleepTime
)
;
~
TaskQueuePacedSender
(
)
override
;
void
EnqueuePackets
(
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
packets
)
override
;
void
CreateProbeCluster
(
DataRate
bitrate
int
cluster_id
)
override
;
void
Pause
(
)
override
;
void
Resume
(
)
override
;
void
SetCongestionWindow
(
DataSize
congestion_window_size
)
override
;
void
UpdateOutstandingData
(
DataSize
outstanding_data
)
override
;
void
SetPacingRates
(
DataRate
pacing_rate
DataRate
padding_rate
)
override
;
void
SetAccountForAudioPackets
(
bool
account_for_audio
)
override
;
void
SetIncludeOverhead
(
)
override
;
void
SetTransportOverhead
(
DataSize
overhead_per_packet
)
override
;
TimeDelta
OldestPacketWaitTime
(
)
const
override
;
DataSize
QueueSizeData
(
)
const
override
;
absl
:
:
optional
<
Timestamp
>
FirstSentPacketTime
(
)
const
override
;
TimeDelta
ExpectedQueueTime
(
)
const
override
;
void
SetQueueTimeLimit
(
TimeDelta
limit
)
override
;
protected
:
struct
Stats
{
Stats
(
)
:
oldest_packet_wait_time
(
TimeDelta
:
:
Zero
(
)
)
queue_size
(
DataSize
:
:
Zero
(
)
)
expected_queue_time
(
TimeDelta
:
:
Zero
(
)
)
{
}
TimeDelta
oldest_packet_wait_time
;
DataSize
queue_size
;
TimeDelta
expected_queue_time
;
absl
:
:
optional
<
Timestamp
>
first_sent_packet_time
;
}
;
virtual
void
OnStatsUpdated
(
const
Stats
&
stats
)
;
private
:
void
MaybeProcessPackets
(
Timestamp
scheduled_process_time
)
;
void
MaybeUpdateStats
(
bool
is_scheduled_call
)
RTC_RUN_ON
(
task_queue_
)
;
Stats
GetStats
(
)
const
;
Clock
*
const
clock_
;
const
TimeDelta
hold_back_window_
;
PacingController
pacing_controller_
RTC_GUARDED_BY
(
task_queue_
)
;
Timestamp
next_process_time_
RTC_GUARDED_BY
(
task_queue_
)
;
bool
stats_update_scheduled_
RTC_GUARDED_BY
(
task_queue_
)
;
Timestamp
last_stats_time_
RTC_GUARDED_BY
(
task_queue_
)
;
bool
is_shutdown_
RTC_GUARDED_BY
(
task_queue_
)
;
mutable
Mutex
stats_mutex_
;
Stats
current_stats_
RTC_GUARDED_BY
(
stats_mutex_
)
;
rtc
:
:
TaskQueue
task_queue_
;
}
;
}
#
endif
