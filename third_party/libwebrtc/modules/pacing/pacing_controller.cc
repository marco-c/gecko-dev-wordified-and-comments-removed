#
include
"
modules
/
pacing
/
pacing_controller
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
modules
/
pacing
/
bitrate_prober
.
h
"
#
include
"
modules
/
pacing
/
interval_budget
.
h
"
#
include
"
modules
/
utility
/
include
/
process_thread
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
{
constexpr
TimeDelta
kDefaultMinPacketLimit
=
TimeDelta
:
:
Millis
(
5
)
;
constexpr
TimeDelta
kCongestedPacketInterval
=
TimeDelta
:
:
Millis
(
500
)
;
constexpr
TimeDelta
kMaxDebtInTime
=
TimeDelta
:
:
Millis
(
500
)
;
constexpr
TimeDelta
kMaxElapsedTime
=
TimeDelta
:
:
Seconds
(
2
)
;
constexpr
TimeDelta
kMaxProcessingInterval
=
TimeDelta
:
:
Millis
(
30
)
;
constexpr
TimeDelta
kMaxEarlyProbeProcessing
=
TimeDelta
:
:
Millis
(
1
)
;
constexpr
int
kFirstPriority
=
0
;
bool
IsDisabled
(
const
WebRtcKeyValueConfig
&
field_trials
absl
:
:
string_view
key
)
{
return
absl
:
:
StartsWith
(
field_trials
.
Lookup
(
key
)
"
Disabled
"
)
;
}
bool
IsEnabled
(
const
WebRtcKeyValueConfig
&
field_trials
absl
:
:
string_view
key
)
{
return
absl
:
:
StartsWith
(
field_trials
.
Lookup
(
key
)
"
Enabled
"
)
;
}
TimeDelta
GetDynamicPaddingTarget
(
const
WebRtcKeyValueConfig
&
field_trials
)
{
FieldTrialParameter
<
TimeDelta
>
padding_target
(
"
timedelta
"
TimeDelta
:
:
Millis
(
5
)
)
;
ParseFieldTrial
(
{
&
padding_target
}
field_trials
.
Lookup
(
"
WebRTC
-
Pacer
-
DynamicPaddingTarget
"
)
)
;
return
padding_target
.
Get
(
)
;
}
int
GetPriorityForType
(
RtpPacketMediaType
type
)
{
switch
(
type
)
{
case
RtpPacketMediaType
:
:
kAudio
:
return
kFirstPriority
+
1
;
case
RtpPacketMediaType
:
:
kRetransmission
:
return
kFirstPriority
+
2
;
case
RtpPacketMediaType
:
:
kVideo
:
case
RtpPacketMediaType
:
:
kForwardErrorCorrection
:
return
kFirstPriority
+
3
;
case
RtpPacketMediaType
:
:
kPadding
:
return
kFirstPriority
+
4
;
}
RTC_CHECK_NOTREACHED
(
)
;
}
}
const
TimeDelta
PacingController
:
:
kMaxExpectedQueueLength
=
TimeDelta
:
:
Millis
(
2000
)
;
const
float
PacingController
:
:
kDefaultPaceMultiplier
=
2
.
5f
;
const
TimeDelta
PacingController
:
:
kPausedProcessInterval
=
kCongestedPacketInterval
;
const
TimeDelta
PacingController
:
:
kMinSleepTime
=
TimeDelta
:
:
Millis
(
1
)
;
PacingController
:
:
PacingController
(
Clock
*
clock
PacketSender
*
packet_sender
RtcEventLog
*
event_log
const
WebRtcKeyValueConfig
*
field_trials
ProcessMode
mode
)
:
mode_
(
mode
)
clock_
(
clock
)
packet_sender_
(
packet_sender
)
fallback_field_trials_
(
!
field_trials
?
std
:
:
make_unique
<
FieldTrialBasedConfig
>
(
)
:
nullptr
)
field_trials_
(
field_trials
?
field_trials
:
fallback_field_trials_
.
get
(
)
)
drain_large_queues_
(
!
IsDisabled
(
*
field_trials_
"
WebRTC
-
Pacer
-
DrainQueue
"
)
)
send_padding_if_silent_
(
IsEnabled
(
*
field_trials_
"
WebRTC
-
Pacer
-
PadInSilence
"
)
)
pace_audio_
(
IsEnabled
(
*
field_trials_
"
WebRTC
-
Pacer
-
BlockAudio
"
)
)
ignore_transport_overhead_
(
IsEnabled
(
*
field_trials_
"
WebRTC
-
Pacer
-
IgnoreTransportOverhead
"
)
)
padding_target_duration_
(
GetDynamicPaddingTarget
(
*
field_trials_
)
)
min_packet_limit_
(
kDefaultMinPacketLimit
)
transport_overhead_per_packet_
(
DataSize
:
:
Zero
(
)
)
last_timestamp_
(
clock_
-
>
CurrentTime
(
)
)
paused_
(
false
)
media_budget_
(
0
)
padding_budget_
(
0
)
media_debt_
(
DataSize
:
:
Zero
(
)
)
padding_debt_
(
DataSize
:
:
Zero
(
)
)
media_rate_
(
DataRate
:
:
Zero
(
)
)
padding_rate_
(
DataRate
:
:
Zero
(
)
)
prober_
(
*
field_trials_
)
probing_send_failure_
(
false
)
pacing_bitrate_
(
DataRate
:
:
Zero
(
)
)
last_process_time_
(
clock
-
>
CurrentTime
(
)
)
last_send_time_
(
last_process_time_
)
packet_queue_
(
last_process_time_
field_trials_
)
packet_counter_
(
0
)
congestion_window_size_
(
DataSize
:
:
PlusInfinity
(
)
)
outstanding_data_
(
DataSize
:
:
Zero
(
)
)
queue_time_limit
(
kMaxExpectedQueueLength
)
account_for_audio_
(
false
)
include_overhead_
(
false
)
{
if
(
!
drain_large_queues_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Pacer
queues
will
not
be
drained
"
"
pushback
experiment
must
be
enabled
.
"
;
}
FieldTrialParameter
<
int
>
min_packet_limit_ms
(
"
"
min_packet_limit_
.
ms
(
)
)
;
ParseFieldTrial
(
{
&
min_packet_limit_ms
}
field_trials_
-
>
Lookup
(
"
WebRTC
-
Pacer
-
MinPacketLimitMs
"
)
)
;
min_packet_limit_
=
TimeDelta
:
:
Millis
(
min_packet_limit_ms
.
Get
(
)
)
;
UpdateBudgetWithElapsedTime
(
min_packet_limit_
)
;
}
PacingController
:
:
~
PacingController
(
)
=
default
;
void
PacingController
:
:
CreateProbeCluster
(
DataRate
bitrate
int
cluster_id
)
{
prober_
.
CreateProbeCluster
(
bitrate
CurrentTime
(
)
cluster_id
)
;
}
void
PacingController
:
:
Pause
(
)
{
if
(
!
paused_
)
RTC_LOG
(
LS_INFO
)
<
<
"
PacedSender
paused
.
"
;
paused_
=
true
;
packet_queue_
.
SetPauseState
(
true
CurrentTime
(
)
)
;
}
void
PacingController
:
:
Resume
(
)
{
if
(
paused_
)
RTC_LOG
(
LS_INFO
)
<
<
"
PacedSender
resumed
.
"
;
paused_
=
false
;
packet_queue_
.
SetPauseState
(
false
CurrentTime
(
)
)
;
}
bool
PacingController
:
:
IsPaused
(
)
const
{
return
paused_
;
}
void
PacingController
:
:
SetCongestionWindow
(
DataSize
congestion_window_size
)
{
const
bool
was_congested
=
Congested
(
)
;
congestion_window_size_
=
congestion_window_size
;
if
(
was_congested
&
&
!
Congested
(
)
)
{
TimeDelta
elapsed_time
=
UpdateTimeAndGetElapsed
(
CurrentTime
(
)
)
;
UpdateBudgetWithElapsedTime
(
elapsed_time
)
;
}
}
void
PacingController
:
:
UpdateOutstandingData
(
DataSize
outstanding_data
)
{
const
bool
was_congested
=
Congested
(
)
;
outstanding_data_
=
outstanding_data
;
if
(
was_congested
&
&
!
Congested
(
)
)
{
TimeDelta
elapsed_time
=
UpdateTimeAndGetElapsed
(
CurrentTime
(
)
)
;
UpdateBudgetWithElapsedTime
(
elapsed_time
)
;
}
}
bool
PacingController
:
:
Congested
(
)
const
{
if
(
congestion_window_size_
.
IsFinite
(
)
)
{
return
outstanding_data_
>
=
congestion_window_size_
;
}
return
false
;
}
bool
PacingController
:
:
IsProbing
(
)
const
{
return
prober_
.
is_probing
(
)
;
}
Timestamp
PacingController
:
:
CurrentTime
(
)
const
{
Timestamp
time
=
clock_
-
>
CurrentTime
(
)
;
if
(
time
<
last_timestamp_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Non
-
monotonic
clock
behavior
observed
.
Previous
timestamp
:
"
<
<
last_timestamp_
.
ms
(
)
<
<
"
new
timestamp
:
"
<
<
time
.
ms
(
)
;
RTC_DCHECK_GE
(
time
last_timestamp_
)
;
time
=
last_timestamp_
;
}
last_timestamp_
=
time
;
return
time
;
}
void
PacingController
:
:
SetProbingEnabled
(
bool
enabled
)
{
RTC_CHECK_EQ
(
0
packet_counter_
)
;
prober_
.
SetEnabled
(
enabled
)
;
}
void
PacingController
:
:
SetPacingRates
(
DataRate
pacing_rate
DataRate
padding_rate
)
{
RTC_DCHECK_GT
(
pacing_rate
DataRate
:
:
Zero
(
)
)
;
media_rate_
=
pacing_rate
;
padding_rate_
=
padding_rate
;
pacing_bitrate_
=
pacing_rate
;
padding_budget_
.
set_target_rate_kbps
(
padding_rate
.
kbps
(
)
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
bwe
:
pacer_updated
pacing_kbps
=
"
<
<
pacing_bitrate_
.
kbps
(
)
<
<
"
padding_budget_kbps
=
"
<
<
padding_rate
.
kbps
(
)
;
}
void
PacingController
:
:
EnqueuePacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
)
{
RTC_DCHECK
(
pacing_bitrate_
>
DataRate
:
:
Zero
(
)
)
<
<
"
SetPacingRate
must
be
called
before
InsertPacket
.
"
;
RTC_CHECK
(
packet
-
>
packet_type
(
)
)
;
const
int
priority
=
GetPriorityForType
(
*
packet
-
>
packet_type
(
)
)
;
EnqueuePacketInternal
(
std
:
:
move
(
packet
)
priority
)
;
}
void
PacingController
:
:
SetAccountForAudioPackets
(
bool
account_for_audio
)
{
account_for_audio_
=
account_for_audio
;
}
void
PacingController
:
:
SetIncludeOverhead
(
)
{
include_overhead_
=
true
;
packet_queue_
.
SetIncludeOverhead
(
)
;
}
void
PacingController
:
:
SetTransportOverhead
(
DataSize
overhead_per_packet
)
{
if
(
ignore_transport_overhead_
)
return
;
transport_overhead_per_packet_
=
overhead_per_packet
;
packet_queue_
.
SetTransportOverhead
(
overhead_per_packet
)
;
}
TimeDelta
PacingController
:
:
ExpectedQueueTime
(
)
const
{
RTC_DCHECK_GT
(
pacing_bitrate_
DataRate
:
:
Zero
(
)
)
;
return
TimeDelta
:
:
Millis
(
(
QueueSizeData
(
)
.
bytes
(
)
*
8
*
rtc
:
:
kNumMillisecsPerSec
)
/
pacing_bitrate_
.
bps
(
)
)
;
}
size_t
PacingController
:
:
QueueSizePackets
(
)
const
{
return
packet_queue_
.
SizeInPackets
(
)
;
}
DataSize
PacingController
:
:
QueueSizeData
(
)
const
{
return
packet_queue_
.
Size
(
)
;
}
DataSize
PacingController
:
:
CurrentBufferLevel
(
)
const
{
return
std
:
:
max
(
media_debt_
padding_debt_
)
;
}
absl
:
:
optional
<
Timestamp
>
PacingController
:
:
FirstSentPacketTime
(
)
const
{
return
first_sent_packet_time_
;
}
TimeDelta
PacingController
:
:
OldestPacketWaitTime
(
)
const
{
Timestamp
oldest_packet
=
packet_queue_
.
OldestEnqueueTime
(
)
;
if
(
oldest_packet
.
IsInfinite
(
)
)
{
return
TimeDelta
:
:
Zero
(
)
;
}
return
CurrentTime
(
)
-
oldest_packet
;
}
void
PacingController
:
:
EnqueuePacketInternal
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
int
priority
)
{
prober_
.
OnIncomingPacket
(
DataSize
:
:
Bytes
(
packet
-
>
payload_size
(
)
)
)
;
Timestamp
now
=
CurrentTime
(
)
;
if
(
packet
-
>
capture_time_ms
(
)
<
=
0
)
{
packet
-
>
set_capture_time_ms
(
now
.
ms
(
)
)
;
}
if
(
mode_
=
=
ProcessMode
:
:
kDynamic
&
&
packet_queue_
.
Empty
(
)
&
&
NextSendTime
(
)
<
=
now
)
{
TimeDelta
elapsed_time
=
UpdateTimeAndGetElapsed
(
now
)
;
UpdateBudgetWithElapsedTime
(
elapsed_time
)
;
}
packet_queue_
.
Push
(
priority
now
packet_counter_
+
+
std
:
:
move
(
packet
)
)
;
}
TimeDelta
PacingController
:
:
UpdateTimeAndGetElapsed
(
Timestamp
now
)
{
if
(
last_process_time_
.
IsMinusInfinity
(
)
|
|
now
<
last_process_time_
)
{
return
TimeDelta
:
:
Zero
(
)
;
}
RTC_DCHECK_GE
(
now
last_process_time_
)
;
TimeDelta
elapsed_time
=
now
-
last_process_time_
;
last_process_time_
=
now
;
if
(
elapsed_time
>
kMaxElapsedTime
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Elapsed
time
(
"
<
<
elapsed_time
.
ms
(
)
<
<
"
ms
)
longer
than
expected
limiting
to
"
<
<
kMaxElapsedTime
.
ms
(
)
;
elapsed_time
=
kMaxElapsedTime
;
}
return
elapsed_time
;
}
bool
PacingController
:
:
ShouldSendKeepalive
(
Timestamp
now
)
const
{
if
(
send_padding_if_silent_
|
|
paused_
|
|
Congested
(
)
|
|
packet_counter_
=
=
0
)
{
TimeDelta
elapsed_since_last_send
=
now
-
last_send_time_
;
if
(
elapsed_since_last_send
>
=
kCongestedPacketInterval
)
{
return
true
;
}
}
return
false
;
}
Timestamp
PacingController
:
:
NextSendTime
(
)
const
{
const
Timestamp
now
=
CurrentTime
(
)
;
if
(
paused_
)
{
return
last_send_time_
+
kPausedProcessInterval
;
}
if
(
prober_
.
is_probing
(
)
)
{
Timestamp
probe_time
=
prober_
.
NextProbeTime
(
now
)
;
if
(
probe_time
!
=
Timestamp
:
:
PlusInfinity
(
)
&
&
!
probing_send_failure_
)
{
return
probe_time
;
}
}
if
(
mode_
=
=
ProcessMode
:
:
kPeriodic
)
{
return
last_process_time_
+
min_packet_limit_
;
}
if
(
!
pace_audio_
)
{
absl
:
:
optional
<
Timestamp
>
audio_enqueue_time
=
packet_queue_
.
LeadingAudioPacketEnqueueTime
(
)
;
if
(
audio_enqueue_time
.
has_value
(
)
)
{
return
*
audio_enqueue_time
;
}
}
if
(
Congested
(
)
|
|
packet_counter_
=
=
0
)
{
return
last_send_time_
+
kCongestedPacketInterval
;
}
if
(
media_rate_
>
DataRate
:
:
Zero
(
)
&
&
!
packet_queue_
.
Empty
(
)
)
{
return
std
:
:
min
(
last_send_time_
+
kPausedProcessInterval
last_process_time_
+
media_debt_
/
media_rate_
)
;
}
if
(
padding_rate_
>
DataRate
:
:
Zero
(
)
&
&
packet_queue_
.
Empty
(
)
)
{
TimeDelta
drain_time
=
std
:
:
max
(
media_debt_
/
media_rate_
padding_debt_
/
padding_rate_
)
;
return
std
:
:
min
(
last_send_time_
+
kPausedProcessInterval
last_process_time_
+
drain_time
)
;
}
if
(
send_padding_if_silent_
)
{
return
last_send_time_
+
kPausedProcessInterval
;
}
return
last_process_time_
+
kPausedProcessInterval
;
}
void
PacingController
:
:
ProcessPackets
(
)
{
Timestamp
now
=
CurrentTime
(
)
;
Timestamp
target_send_time
=
now
;
if
(
mode_
=
=
ProcessMode
:
:
kDynamic
)
{
target_send_time
=
NextSendTime
(
)
;
TimeDelta
early_execute_margin
=
prober_
.
is_probing
(
)
?
kMaxEarlyProbeProcessing
:
TimeDelta
:
:
Zero
(
)
;
if
(
target_send_time
.
IsMinusInfinity
(
)
)
{
target_send_time
=
now
;
}
else
if
(
now
<
target_send_time
-
early_execute_margin
)
{
TimeDelta
elapsed_time
=
UpdateTimeAndGetElapsed
(
now
)
;
UpdateBudgetWithElapsedTime
(
elapsed_time
)
;
return
;
}
if
(
target_send_time
<
last_process_time_
)
{
UpdateBudgetWithElapsedTime
(
last_process_time_
-
target_send_time
)
;
target_send_time
=
last_process_time_
;
}
}
Timestamp
previous_process_time
=
last_process_time_
;
TimeDelta
elapsed_time
=
UpdateTimeAndGetElapsed
(
now
)
;
if
(
ShouldSendKeepalive
(
now
)
)
{
if
(
packet_counter_
=
=
0
)
{
last_send_time_
=
now
;
}
else
{
DataSize
keepalive_data_sent
=
DataSize
:
:
Zero
(
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
keepalive_packets
=
packet_sender_
-
>
GeneratePadding
(
DataSize
:
:
Bytes
(
1
)
)
;
for
(
auto
&
packet
:
keepalive_packets
)
{
keepalive_data_sent
+
=
DataSize
:
:
Bytes
(
packet
-
>
payload_size
(
)
+
packet
-
>
padding_size
(
)
)
;
packet_sender_
-
>
SendPacket
(
std
:
:
move
(
packet
)
PacedPacketInfo
(
)
)
;
for
(
auto
&
packet
:
packet_sender_
-
>
FetchFec
(
)
)
{
EnqueuePacket
(
std
:
:
move
(
packet
)
)
;
}
}
OnPaddingSent
(
keepalive_data_sent
)
;
}
}
if
(
paused_
)
{
return
;
}
if
(
elapsed_time
>
TimeDelta
:
:
Zero
(
)
)
{
DataRate
target_rate
=
pacing_bitrate_
;
DataSize
queue_size_data
=
packet_queue_
.
Size
(
)
;
if
(
queue_size_data
>
DataSize
:
:
Zero
(
)
)
{
packet_queue_
.
UpdateQueueTime
(
now
)
;
if
(
drain_large_queues_
)
{
TimeDelta
avg_time_left
=
std
:
:
max
(
TimeDelta
:
:
Millis
(
1
)
queue_time_limit
-
packet_queue_
.
AverageQueueTime
(
)
)
;
DataRate
min_rate_needed
=
queue_size_data
/
avg_time_left
;
if
(
min_rate_needed
>
target_rate
)
{
target_rate
=
min_rate_needed
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
bwe
:
large_pacing_queue
pacing_rate_kbps
=
"
<
<
target_rate
.
kbps
(
)
;
}
}
}
if
(
mode_
=
=
ProcessMode
:
:
kPeriodic
)
{
media_budget_
.
set_target_rate_kbps
(
target_rate
.
kbps
(
)
)
;
UpdateBudgetWithElapsedTime
(
elapsed_time
)
;
}
else
{
media_rate_
=
target_rate
;
}
}
bool
first_packet_in_probe
=
false
;
PacedPacketInfo
pacing_info
;
DataSize
recommended_probe_size
=
DataSize
:
:
Zero
(
)
;
bool
is_probing
=
prober_
.
is_probing
(
)
;
if
(
is_probing
)
{
pacing_info
=
prober_
.
CurrentCluster
(
now
)
.
value_or
(
PacedPacketInfo
(
)
)
;
if
(
pacing_info
.
probe_cluster_id
!
=
PacedPacketInfo
:
:
kNotAProbe
)
{
first_packet_in_probe
=
pacing_info
.
probe_cluster_bytes_sent
=
=
0
;
recommended_probe_size
=
prober_
.
RecommendedMinProbeSize
(
)
;
RTC_DCHECK_GT
(
recommended_probe_size
DataSize
:
:
Zero
(
)
)
;
}
else
{
is_probing
=
false
;
}
}
DataSize
data_sent
=
DataSize
:
:
Zero
(
)
;
while
(
!
paused_
)
{
if
(
first_packet_in_probe
)
{
auto
padding
=
packet_sender_
-
>
GeneratePadding
(
DataSize
:
:
Bytes
(
1
)
)
;
if
(
!
padding
.
empty
(
)
)
{
EnqueuePacketInternal
(
std
:
:
move
(
padding
[
0
]
)
kFirstPriority
)
;
RTC_DCHECK_EQ
(
padding
.
size
(
)
1u
)
;
}
first_packet_in_probe
=
false
;
}
if
(
mode_
=
=
ProcessMode
:
:
kDynamic
&
&
previous_process_time
<
target_send_time
)
{
UpdateBudgetWithElapsedTime
(
target_send_time
-
previous_process_time
)
;
previous_process_time
=
target_send_time
;
}
std
:
:
unique_ptr
<
RtpPacketToSend
>
rtp_packet
=
GetPendingPacket
(
pacing_info
target_send_time
now
)
;
if
(
rtp_packet
=
=
nullptr
)
{
DataSize
padding_to_add
=
PaddingToAdd
(
recommended_probe_size
data_sent
)
;
if
(
padding_to_add
>
DataSize
:
:
Zero
(
)
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
padding_packets
=
packet_sender_
-
>
GeneratePadding
(
padding_to_add
)
;
if
(
padding_packets
.
empty
(
)
)
{
break
;
}
for
(
auto
&
packet
:
padding_packets
)
{
EnqueuePacket
(
std
:
:
move
(
packet
)
)
;
}
continue
;
}
break
;
}
RTC_DCHECK
(
rtp_packet
)
;
RTC_DCHECK
(
rtp_packet
-
>
packet_type
(
)
.
has_value
(
)
)
;
const
RtpPacketMediaType
packet_type
=
*
rtp_packet
-
>
packet_type
(
)
;
DataSize
packet_size
=
DataSize
:
:
Bytes
(
rtp_packet
-
>
payload_size
(
)
+
rtp_packet
-
>
padding_size
(
)
)
;
if
(
include_overhead_
)
{
packet_size
+
=
DataSize
:
:
Bytes
(
rtp_packet
-
>
headers_size
(
)
)
+
transport_overhead_per_packet_
;
}
packet_sender_
-
>
SendPacket
(
std
:
:
move
(
rtp_packet
)
pacing_info
)
;
for
(
auto
&
packet
:
packet_sender_
-
>
FetchFec
(
)
)
{
EnqueuePacket
(
std
:
:
move
(
packet
)
)
;
}
data_sent
+
=
packet_size
;
OnPacketSent
(
packet_type
packet_size
target_send_time
)
;
if
(
is_probing
&
&
data_sent
>
=
recommended_probe_size
)
{
break
;
}
if
(
mode_
=
=
ProcessMode
:
:
kDynamic
)
{
Timestamp
next_send_time
=
NextSendTime
(
)
;
if
(
next_send_time
.
IsMinusInfinity
(
)
)
{
target_send_time
=
now
;
}
else
{
target_send_time
=
std
:
:
min
(
now
next_send_time
)
;
}
}
}
last_process_time_
=
std
:
:
max
(
last_process_time_
previous_process_time
)
;
if
(
is_probing
)
{
probing_send_failure_
=
data_sent
=
=
DataSize
:
:
Zero
(
)
;
if
(
!
probing_send_failure_
)
{
prober_
.
ProbeSent
(
CurrentTime
(
)
data_sent
)
;
}
}
}
DataSize
PacingController
:
:
PaddingToAdd
(
DataSize
recommended_probe_size
DataSize
data_sent
)
const
{
if
(
!
packet_queue_
.
Empty
(
)
)
{
return
DataSize
:
:
Zero
(
)
;
}
if
(
Congested
(
)
)
{
return
DataSize
:
:
Zero
(
)
;
}
if
(
packet_counter_
=
=
0
)
{
return
DataSize
:
:
Zero
(
)
;
}
if
(
!
recommended_probe_size
.
IsZero
(
)
)
{
if
(
recommended_probe_size
>
data_sent
)
{
return
recommended_probe_size
-
data_sent
;
}
return
DataSize
:
:
Zero
(
)
;
}
if
(
mode_
=
=
ProcessMode
:
:
kPeriodic
)
{
return
DataSize
:
:
Bytes
(
padding_budget_
.
bytes_remaining
(
)
)
;
}
else
if
(
padding_rate_
>
DataRate
:
:
Zero
(
)
&
&
padding_debt_
=
=
DataSize
:
:
Zero
(
)
)
{
return
padding_target_duration_
*
padding_rate_
;
}
return
DataSize
:
:
Zero
(
)
;
}
std
:
:
unique_ptr
<
RtpPacketToSend
>
PacingController
:
:
GetPendingPacket
(
const
PacedPacketInfo
&
pacing_info
Timestamp
target_send_time
Timestamp
now
)
{
if
(
packet_queue_
.
Empty
(
)
)
{
return
nullptr
;
}
bool
unpaced_audio_packet
=
!
pace_audio_
&
&
packet_queue_
.
LeadingAudioPacketEnqueueTime
(
)
.
has_value
(
)
;
bool
is_probe
=
pacing_info
.
probe_cluster_id
!
=
PacedPacketInfo
:
:
kNotAProbe
;
if
(
!
unpaced_audio_packet
&
&
!
is_probe
)
{
if
(
Congested
(
)
)
{
return
nullptr
;
}
if
(
mode_
=
=
ProcessMode
:
:
kPeriodic
)
{
if
(
media_budget_
.
bytes_remaining
(
)
<
=
0
)
{
return
nullptr
;
}
}
else
{
if
(
now
<
=
target_send_time
)
{
TimeDelta
flush_time
=
media_debt_
/
media_rate_
;
if
(
now
+
flush_time
>
target_send_time
)
{
return
nullptr
;
}
}
}
}
return
packet_queue_
.
Pop
(
)
;
}
void
PacingController
:
:
OnPacketSent
(
RtpPacketMediaType
packet_type
DataSize
packet_size
Timestamp
send_time
)
{
if
(
!
first_sent_packet_time_
)
{
first_sent_packet_time_
=
send_time
;
}
bool
audio_packet
=
packet_type
=
=
RtpPacketMediaType
:
:
kAudio
;
if
(
!
audio_packet
|
|
account_for_audio_
)
{
UpdateBudgetWithSentData
(
packet_size
)
;
}
last_send_time_
=
send_time
;
last_process_time_
=
send_time
;
}
void
PacingController
:
:
OnPaddingSent
(
DataSize
data_sent
)
{
if
(
data_sent
>
DataSize
:
:
Zero
(
)
)
{
UpdateBudgetWithSentData
(
data_sent
)
;
}
Timestamp
now
=
CurrentTime
(
)
;
last_send_time_
=
now
;
last_process_time_
=
now
;
}
void
PacingController
:
:
UpdateBudgetWithElapsedTime
(
TimeDelta
delta
)
{
if
(
mode_
=
=
ProcessMode
:
:
kPeriodic
)
{
delta
=
std
:
:
min
(
kMaxProcessingInterval
delta
)
;
media_budget_
.
IncreaseBudget
(
delta
.
ms
(
)
)
;
padding_budget_
.
IncreaseBudget
(
delta
.
ms
(
)
)
;
}
else
{
media_debt_
-
=
std
:
:
min
(
media_debt_
media_rate_
*
delta
)
;
padding_debt_
-
=
std
:
:
min
(
padding_debt_
padding_rate_
*
delta
)
;
}
}
void
PacingController
:
:
UpdateBudgetWithSentData
(
DataSize
size
)
{
outstanding_data_
+
=
size
;
if
(
mode_
=
=
ProcessMode
:
:
kPeriodic
)
{
media_budget_
.
UseBudget
(
size
.
bytes
(
)
)
;
padding_budget_
.
UseBudget
(
size
.
bytes
(
)
)
;
}
else
{
media_debt_
+
=
size
;
media_debt_
=
std
:
:
min
(
media_debt_
media_rate_
*
kMaxDebtInTime
)
;
padding_debt_
+
=
size
;
padding_debt_
=
std
:
:
min
(
padding_debt_
padding_rate_
*
kMaxDebtInTime
)
;
}
}
void
PacingController
:
:
SetQueueTimeLimit
(
TimeDelta
limit
)
{
queue_time_limit
=
limit
;
}
}
