#
include
"
modules
/
pacing
/
round_robin_packet_queue
.
h
"
#
include
<
utility
>
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
constexpr
uint32_t
kDefaultSsrc
=
123
;
constexpr
int
kDefaultPayloadSize
=
321
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
CreatePacket
(
RtpPacketMediaType
type
uint16_t
sequence_number
)
{
auto
packet
=
std
:
:
make_unique
<
RtpPacketToSend
>
(
nullptr
)
;
packet
-
>
set_packet_type
(
type
)
;
packet
-
>
SetSsrc
(
kDefaultSsrc
)
;
packet
-
>
SetSequenceNumber
(
sequence_number
)
;
packet
-
>
SetPayloadSize
(
kDefaultPayloadSize
)
;
return
packet
;
}
}
TEST
(
RoundRobinPacketQueueTest
PushAndPopUpdatesSizeInPacketsPerRtpPacketMediaType
)
{
Timestamp
now
=
Timestamp
:
:
Zero
(
)
;
RoundRobinPacketQueue
queue
(
now
)
;
for
(
size_t
i
=
0
;
i
<
kNumMediaTypes
;
+
+
i
)
{
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
i
]
0
)
;
}
queue
.
Push
(
now
CreatePacket
(
RtpPacketMediaType
:
:
kAudio
1
)
)
;
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
static_cast
<
size_t
>
(
RtpPacketMediaType
:
:
kAudio
)
]
1
)
;
queue
.
Push
(
now
CreatePacket
(
RtpPacketMediaType
:
:
kVideo
2
)
)
;
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
static_cast
<
size_t
>
(
RtpPacketMediaType
:
:
kVideo
)
]
1
)
;
queue
.
Push
(
now
CreatePacket
(
RtpPacketMediaType
:
:
kRetransmission
3
)
)
;
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
static_cast
<
size_t
>
(
RtpPacketMediaType
:
:
kRetransmission
)
]
1
)
;
queue
.
Push
(
now
CreatePacket
(
RtpPacketMediaType
:
:
kForwardErrorCorrection
4
)
)
;
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
static_cast
<
size_t
>
(
RtpPacketMediaType
:
:
kForwardErrorCorrection
)
]
1
)
;
queue
.
Push
(
now
CreatePacket
(
RtpPacketMediaType
:
:
kPadding
5
)
)
;
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
static_cast
<
size_t
>
(
RtpPacketMediaType
:
:
kPadding
)
]
1
)
;
for
(
size_t
i
=
0
;
i
<
kNumMediaTypes
;
+
+
i
)
{
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
i
]
1
)
;
}
for
(
size_t
i
=
0
;
i
<
kNumMediaTypes
;
+
+
i
)
{
auto
popped_packet
=
queue
.
Pop
(
)
;
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
static_cast
<
size_t
>
(
popped_packet
-
>
packet_type
(
)
.
value
(
)
)
]
0
)
;
}
for
(
size_t
i
=
0
;
i
<
kNumMediaTypes
;
+
+
i
)
{
EXPECT_EQ
(
queue
.
SizeInPacketsPerRtpPacketMediaType
(
)
[
i
]
0
)
;
}
}
}
