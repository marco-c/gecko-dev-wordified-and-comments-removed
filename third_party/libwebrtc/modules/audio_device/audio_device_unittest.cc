#
include
"
api
/
audio
/
audio_device
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
numeric
>
#
include
<
optional
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio
/
audio_device_defines
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
default_task_queue_factory
.
h
"
#
include
"
api
/
task_queue
/
task_queue_factory
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
modules
/
audio_device
/
audio_device_impl
.
h
"
#
include
"
modules
/
audio_device
/
include
/
mock_audio_transport
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
race_checker
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
#
ifdef
WEBRTC_WIN
#
include
"
modules
/
audio_device
/
include
/
audio_device_factory
.
h
"
#
include
"
modules
/
audio_device
/
win
/
core_audio_utility_win
.
h
"
#
include
"
rtc_base
/
win
/
scoped_com_initializer
.
h
"
#
endif
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AtLeast
;
using
:
:
testing
:
:
Ge
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
Mock
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
NotNull
;
namespace
webrtc
{
namespace
{
#
if
defined
(
WEBRTC_WIN
)
#
define
AUDIO_DEVICE_ID
(
AudioDeviceModule
:
:
WindowsDeviceType
:
:
kDefaultDevice
)
#
else
#
define
AUDIO_DEVICE_ID
(
0u
)
#
endif
#
ifdef
ENABLE_DEBUG_PRINTF
#
define
PRINTD
(
.
.
.
)
fprintf
(
stderr
__VA_ARGS__
)
;
#
else
#
define
PRINTD
(
.
.
.
)
(
(
void
)
0
)
#
endif
#
define
PRINT
(
.
.
.
)
fprintf
(
stderr
__VA_ARGS__
)
;
#
define
SKIP_TEST_IF_NOT
(
requirements_satisfied
)
\
do
{
\
if
(
!
requirements_satisfied
)
{
\
GTEST_SKIP
(
)
<
<
"
Skipped
.
No
audio
device
found
.
"
;
\
}
\
}
while
(
false
)
static
constexpr
size_t
kNumCallbacks
=
10
;
static
constexpr
TimeDelta
kTestTimeOut
=
TimeDelta
:
:
Seconds
(
10
)
;
static
constexpr
size_t
kNumCallbacksPerSecond
=
100
;
static
constexpr
TimeDelta
kFullDuplexTime
=
TimeDelta
:
:
Seconds
(
5
)
;
static
constexpr
TimeDelta
kMeasureLatencyTime
=
TimeDelta
:
:
Seconds
(
10
)
;
static
constexpr
size_t
kImpulseFrequencyInHz
=
1
;
static
constexpr
int
kImpulseThreshold
=
1000
;
enum
class
TransportType
{
kInvalid
kPlay
kRecord
kPlayAndRecord
}
;
class
AudioStream
{
public
:
virtual
void
Write
(
ArrayView
<
const
int16_t
>
source
)
=
0
;
virtual
void
Read
(
ArrayView
<
int16_t
>
destination
)
=
0
;
virtual
~
AudioStream
(
)
=
default
;
}
;
int
IndexToMilliseconds
(
size_t
index
size_t
frames_per_10ms_buffer
)
{
return
checked_cast
<
int
>
(
10
.
0
*
(
static_cast
<
double
>
(
index
)
/
frames_per_10ms_buffer
)
+
0
.
5
)
;
}
}
class
FifoAudioStream
:
public
AudioStream
{
public
:
void
Write
(
ArrayView
<
const
int16_t
>
source
)
override
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
const
size_t
size
=
[
&
]
{
MutexLock
lock
(
&
lock_
)
;
fifo_
.
push_back
(
Buffer16
(
source
.
data
(
)
source
.
size
(
)
)
)
;
return
fifo_
.
size
(
)
;
}
(
)
;
if
(
size
>
max_size_
)
{
max_size_
=
size
;
}
if
(
write_count_
+
+
%
100
=
=
0
)
{
PRINTD
(
"
.
"
)
;
}
written_elements_
+
=
size
;
}
void
Read
(
ArrayView
<
int16_t
>
destination
)
override
{
MutexLock
lock
(
&
lock_
)
;
if
(
fifo_
.
empty
(
)
)
{
std
:
:
fill
(
destination
.
begin
(
)
destination
.
end
(
)
0
)
;
}
else
{
const
Buffer16
&
buffer
=
fifo_
.
front
(
)
;
if
(
buffer
.
size
(
)
=
=
destination
.
size
(
)
)
{
std
:
:
copy
(
buffer
.
begin
(
)
buffer
.
end
(
)
destination
.
begin
(
)
)
;
}
else
if
(
destination
.
size
(
)
=
=
2
*
buffer
.
size
(
)
)
{
for
(
size_t
i
=
0
;
i
<
buffer
.
size
(
)
;
+
+
i
)
{
destination
[
2
*
i
]
=
buffer
[
i
]
;
destination
[
2
*
i
+
1
]
=
buffer
[
i
]
;
}
}
else
if
(
buffer
.
size
(
)
=
=
2
*
destination
.
size
(
)
)
{
for
(
size_t
i
=
0
;
i
<
destination
.
size
(
)
;
+
+
i
)
{
destination
[
i
]
=
(
static_cast
<
int32_t
>
(
buffer
[
2
*
i
]
)
+
buffer
[
2
*
i
+
1
]
)
/
2
;
}
}
else
{
RTC_DCHECK_NOTREACHED
(
)
<
<
"
Required
conversion
is
not
support
"
;
}
fifo_
.
pop_front
(
)
;
}
}
size_t
size
(
)
const
{
MutexLock
lock
(
&
lock_
)
;
return
fifo_
.
size
(
)
;
}
size_t
max_size
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
return
max_size_
;
}
size_t
average_size
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
return
0
.
5
+
static_cast
<
float
>
(
written_elements_
/
write_count_
)
;
}
using
Buffer16
=
BufferT
<
int16_t
>
;
mutable
Mutex
lock_
;
RaceChecker
race_checker_
;
std
:
:
list
<
Buffer16
>
fifo_
RTC_GUARDED_BY
(
lock_
)
;
size_t
write_count_
RTC_GUARDED_BY
(
race_checker_
)
=
0
;
size_t
max_size_
RTC_GUARDED_BY
(
race_checker_
)
=
0
;
size_t
written_elements_
RTC_GUARDED_BY
(
race_checker_
)
=
0
;
}
;
class
LatencyAudioStream
:
public
AudioStream
{
public
:
LatencyAudioStream
(
)
{
read_thread_checker_
.
Detach
(
)
;
write_thread_checker_
.
Detach
(
)
;
}
void
Read
(
ArrayView
<
int16_t
>
destination
)
override
{
RTC_DCHECK_RUN_ON
(
&
read_thread_checker_
)
;
if
(
read_count_
=
=
0
)
{
PRINT
(
"
[
"
)
;
}
read_count_
+
+
;
std
:
:
fill
(
destination
.
begin
(
)
destination
.
end
(
)
0
)
;
if
(
read_count_
%
(
kNumCallbacksPerSecond
/
kImpulseFrequencyInHz
)
=
=
0
)
{
PRINT
(
"
.
"
)
;
{
MutexLock
lock
(
&
lock_
)
;
if
(
!
pulse_time_
)
{
pulse_time_
=
TimeMillis
(
)
;
}
}
constexpr
int16_t
impulse
=
std
:
:
numeric_limits
<
int16_t
>
:
:
max
(
)
;
std
:
:
fill_n
(
destination
.
begin
(
)
2
impulse
)
;
}
}
void
Write
(
ArrayView
<
const
int16_t
>
source
)
override
{
RTC_DCHECK_RUN_ON
(
&
write_thread_checker_
)
;
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
MutexLock
lock
(
&
lock_
)
;
write_count_
+
+
;
if
(
!
pulse_time_
)
{
return
;
}
const
size_t
index_of_max
=
std
:
:
max_element
(
source
.
begin
(
)
source
.
end
(
)
)
-
source
.
begin
(
)
;
const
size_t
max
=
source
[
index_of_max
]
;
if
(
max
>
kImpulseThreshold
)
{
PRINTD
(
"
(
%
zu
%
zu
)
"
max
index_of_max
)
;
int64_t
now_time
=
TimeMillis
(
)
;
int
extra_delay
=
IndexToMilliseconds
(
index_of_max
source
.
size
(
)
)
;
PRINTD
(
"
[
%
d
]
"
webrtc
:
:
checked_cast
<
int
>
(
now_time
-
pulse_time_
)
)
;
PRINTD
(
"
[
%
d
]
"
extra_delay
)
;
latencies_
.
push_back
(
now_time
-
*
pulse_time_
+
extra_delay
)
;
pulse_time_
.
reset
(
)
;
}
else
{
PRINTD
(
"
-
"
)
;
}
}
size_t
num_latency_values
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
return
latencies_
.
size
(
)
;
}
int
min_latency
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
if
(
latencies_
.
empty
(
)
)
return
0
;
return
*
std
:
:
min_element
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
)
;
}
int
max_latency
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
if
(
latencies_
.
empty
(
)
)
return
0
;
return
*
std
:
:
max_element
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
)
;
}
int
average_latency
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
if
(
latencies_
.
empty
(
)
)
return
0
;
return
0
.
5
+
static_cast
<
double
>
(
std
:
:
accumulate
(
latencies_
.
begin
(
)
latencies_
.
end
(
)
0
)
)
/
latencies_
.
size
(
)
;
}
void
PrintResults
(
)
const
{
RTC_DCHECK_RUNS_SERIALIZED
(
&
race_checker_
)
;
PRINT
(
"
]
"
)
;
for
(
auto
it
=
latencies_
.
begin
(
)
;
it
!
=
latencies_
.
end
(
)
;
+
+
it
)
{
PRINTD
(
"
%
d
"
*
it
)
;
}
PRINT
(
"
\
n
"
)
;
PRINT
(
"
[
.
.
.
.
.
.
.
.
.
.
]
[
min
max
avg
]
=
[
%
d
%
d
%
d
]
ms
\
n
"
min_latency
(
)
max_latency
(
)
average_latency
(
)
)
;
}
Mutex
lock_
;
RaceChecker
race_checker_
;
SequenceChecker
read_thread_checker_
;
SequenceChecker
write_thread_checker_
;
std
:
:
optional
<
int64_t
>
pulse_time_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
vector
<
int
>
latencies_
RTC_GUARDED_BY
(
race_checker_
)
;
size_t
read_count_
RTC_GUARDED_BY
(
read_thread_checker_
)
=
0
;
size_t
write_count_
RTC_GUARDED_BY
(
write_thread_checker_
)
=
0
;
}
;
class
MockAudioTransport
:
public
test
:
:
MockAudioTransport
{
public
:
explicit
MockAudioTransport
(
TransportType
type
)
:
type_
(
type
)
{
}
~
MockAudioTransport
(
)
{
}
void
HandleCallbacks
(
Event
*
event
AudioStream
*
audio_stream
int
num_callbacks
)
{
event_
=
event
;
audio_stream_
=
audio_stream
;
num_callbacks_
=
num_callbacks
;
if
(
play_mode
(
)
)
{
ON_CALL
(
*
this
NeedMorePlayData
(
_
_
_
_
_
_
_
_
)
)
.
WillByDefault
(
Invoke
(
this
&
MockAudioTransport
:
:
RealNeedMorePlayData
)
)
;
}
if
(
rec_mode
(
)
)
{
ON_CALL
(
*
this
RecordedDataIsAvailable
(
_
_
_
_
_
_
_
_
_
_
)
)
.
WillByDefault
(
Invoke
(
this
&
MockAudioTransport
:
:
RealRecordedDataIsAvailable
)
)
;
}
}
void
HandleCallbacks
(
AudioStream
*
audio_stream
)
{
HandleCallbacks
(
nullptr
audio_stream
0
)
;
}
int32_t
RealRecordedDataIsAvailable
(
const
void
*
audio_buffer
const
size_t
samples_per_channel
const
size_t
bytes_per_frame
const
size_t
channels
const
uint32_t
sample_rate
const
uint32_t
const
int32_t
const
uint32_t
const
bool
uint32_t
&
)
{
EXPECT_TRUE
(
rec_mode
(
)
)
<
<
"
No
test
is
expecting
these
callbacks
.
"
;
if
(
!
record_parameters_
.
is_complete
(
)
)
{
record_parameters_
.
reset
(
sample_rate
channels
samples_per_channel
)
;
}
else
{
EXPECT_EQ
(
samples_per_channel
record_parameters_
.
frames_per_buffer
(
)
)
;
EXPECT_EQ
(
bytes_per_frame
record_parameters_
.
GetBytesPerFrame
(
)
)
;
EXPECT_EQ
(
channels
record_parameters_
.
channels
(
)
)
;
EXPECT_EQ
(
static_cast
<
int
>
(
sample_rate
)
record_parameters_
.
sample_rate
(
)
)
;
EXPECT_EQ
(
samples_per_channel
record_parameters_
.
frames_per_10ms_buffer
(
)
)
;
}
{
MutexLock
lock
(
&
lock_
)
;
rec_count_
+
+
;
}
if
(
audio_stream_
)
{
audio_stream_
-
>
Write
(
MakeArrayView
(
static_cast
<
const
int16_t
*
>
(
audio_buffer
)
samples_per_channel
*
channels
)
)
;
}
if
(
event_
&
&
ReceivedEnoughCallbacks
(
)
)
{
event_
-
>
Set
(
)
;
}
return
0
;
}
int32_t
RealNeedMorePlayData
(
const
size_t
samples_per_channel
const
size_t
bytes_per_frame
const
size_t
channels
const
uint32_t
sample_rate
void
*
audio_buffer
size_t
&
samples_out
int64_t
*
int64_t
*
)
{
EXPECT_TRUE
(
play_mode
(
)
)
<
<
"
No
test
is
expecting
these
callbacks
.
"
;
if
(
!
playout_parameters_
.
is_complete
(
)
)
{
playout_parameters_
.
reset
(
sample_rate
channels
samples_per_channel
)
;
}
else
{
EXPECT_EQ
(
samples_per_channel
playout_parameters_
.
frames_per_buffer
(
)
)
;
EXPECT_EQ
(
bytes_per_frame
playout_parameters_
.
GetBytesPerFrame
(
)
)
;
EXPECT_EQ
(
channels
playout_parameters_
.
channels
(
)
)
;
EXPECT_EQ
(
static_cast
<
int
>
(
sample_rate
)
playout_parameters_
.
sample_rate
(
)
)
;
EXPECT_EQ
(
samples_per_channel
playout_parameters_
.
frames_per_10ms_buffer
(
)
)
;
}
{
MutexLock
lock
(
&
lock_
)
;
play_count_
+
+
;
}
samples_out
=
samples_per_channel
*
channels
;
if
(
audio_stream_
)
{
audio_stream_
-
>
Read
(
MakeArrayView
(
static_cast
<
int16_t
*
>
(
audio_buffer
)
samples_per_channel
*
channels
)
)
;
}
else
{
const
size_t
num_bytes
=
samples_per_channel
*
bytes_per_frame
;
std
:
:
memset
(
audio_buffer
0
num_bytes
)
;
}
if
(
event_
&
&
ReceivedEnoughCallbacks
(
)
)
{
event_
-
>
Set
(
)
;
}
return
0
;
}
bool
ReceivedEnoughCallbacks
(
)
{
bool
recording_done
=
false
;
if
(
rec_mode
(
)
)
{
MutexLock
lock
(
&
lock_
)
;
recording_done
=
rec_count_
>
=
num_callbacks_
;
}
else
{
recording_done
=
true
;
}
bool
playout_done
=
false
;
if
(
play_mode
(
)
)
{
MutexLock
lock
(
&
lock_
)
;
playout_done
=
play_count_
>
=
num_callbacks_
;
}
else
{
playout_done
=
true
;
}
return
recording_done
&
&
playout_done
;
}
bool
play_mode
(
)
const
{
return
type_
=
=
TransportType
:
:
kPlay
|
|
type_
=
=
TransportType
:
:
kPlayAndRecord
;
}
bool
rec_mode
(
)
const
{
return
type_
=
=
TransportType
:
:
kRecord
|
|
type_
=
=
TransportType
:
:
kPlayAndRecord
;
}
void
ResetCallbackCounters
(
)
{
MutexLock
lock
(
&
lock_
)
;
if
(
play_mode
(
)
)
{
play_count_
=
0
;
}
if
(
rec_mode
(
)
)
{
rec_count_
=
0
;
}
}
private
:
Mutex
lock_
;
TransportType
type_
=
TransportType
:
:
kInvalid
;
Event
*
event_
=
nullptr
;
AudioStream
*
audio_stream_
=
nullptr
;
size_t
num_callbacks_
=
0
;
size_t
play_count_
RTC_GUARDED_BY
(
lock_
)
=
0
;
size_t
rec_count_
RTC_GUARDED_BY
(
lock_
)
=
0
;
AudioParameters
playout_parameters_
;
AudioParameters
record_parameters_
;
}
;
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
|
|
defined
(
UNDEFINED_SANITIZER
)
#
define
MAYBE_AudioDeviceTest
DISABLED_AudioDeviceTest
#
else
#
define
MAYBE_AudioDeviceTest
AudioDeviceTest
#
endif
class
MAYBE_AudioDeviceTest
:
public
:
:
testing
:
:
TestWithParam
<
webrtc
:
:
AudioDeviceModule
:
:
AudioLayer
>
{
protected
:
MAYBE_AudioDeviceTest
(
)
:
audio_layer_
(
GetParam
(
)
)
task_queue_factory_
(
CreateDefaultTaskQueueFactory
(
)
)
{
LogMessage
:
:
LogToDebug
(
LS_INFO
)
;
LogMessage
:
:
LogTimestamps
(
)
;
LogMessage
:
:
LogThreads
(
)
;
audio_device_
=
CreateAudioDevice
(
)
;
EXPECT_NE
(
audio_device_
.
get
(
)
nullptr
)
;
AudioDeviceModule
:
:
AudioLayer
audio_layer
;
int
got_platform_audio_layer
=
audio_device_
-
>
ActiveAudioLayer
(
&
audio_layer
)
;
if
(
got_platform_audio_layer
!
=
0
)
{
requirements_satisfied_
=
false
;
}
if
(
requirements_satisfied_
)
{
requirements_satisfied_
=
(
audio_device_
-
>
Init
(
)
=
=
0
)
;
}
if
(
requirements_satisfied_
)
{
const
int16_t
num_playout_devices
=
audio_device_
-
>
PlayoutDevices
(
)
;
const
int16_t
num_record_devices
=
audio_device_
-
>
RecordingDevices
(
)
;
requirements_satisfied_
=
num_playout_devices
>
0
&
&
num_record_devices
>
0
;
}
if
(
requirements_satisfied_
)
{
EXPECT_EQ
(
0
audio_device_
-
>
SetPlayoutDevice
(
AUDIO_DEVICE_ID
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
InitSpeaker
(
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
StereoPlayoutIsAvailable
(
&
stereo_playout_
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetStereoPlayout
(
stereo_playout_
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetRecordingDevice
(
AUDIO_DEVICE_ID
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
InitMicrophone
(
)
)
;
EXPECT_EQ
(
0
audio_device_
-
>
SetStereoRecording
(
false
)
)
;
}
}
void
PreTearDown
(
)
{
EXPECT_EQ
(
0
audio_device_
-
>
Terminate
(
)
)
;
}
virtual
~
MAYBE_AudioDeviceTest
(
)
{
if
(
audio_device_
)
{
EXPECT_EQ
(
0
audio_device_
-
>
Terminate
(
)
)
;
}
}
bool
requirements_satisfied
(
)
const
{
return
requirements_satisfied_
;
}
Event
*
event
(
)
{
return
&
event_
;
}
AudioDeviceModule
:
:
AudioLayer
audio_layer
(
)
const
{
return
audio_layer_
;
}
const
scoped_refptr
<
AudioDeviceModuleForTest
>
&
audio_device
(
)
const
{
return
audio_device_
;
}
scoped_refptr
<
AudioDeviceModuleForTest
>
CreateAudioDevice
(
)
{
if
(
audio_layer_
=
=
AudioDeviceModule
:
:
kPlatformDefaultAudio
)
{
return
AudioDeviceModuleImpl
:
:
Create
(
audio_layer_
task_queue_factory_
.
get
(
)
)
;
}
else
if
(
audio_layer_
=
=
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
{
#
ifdef
WEBRTC_WIN
com_initializer_
=
std
:
:
make_unique
<
ScopedCOMInitializer
>
(
ScopedCOMInitializer
:
:
kMTA
)
;
EXPECT_TRUE
(
com_initializer_
-
>
Succeeded
(
)
)
;
EXPECT_TRUE
(
webrtc_win
:
:
core_audio_utility
:
:
IsSupported
(
)
)
;
EXPECT_TRUE
(
webrtc_win
:
:
core_audio_utility
:
:
IsMMCSSSupported
(
)
)
;
return
CreateWindowsCoreAudioAudioDeviceModuleForTest
(
task_queue_factory_
.
get
(
)
true
)
;
#
else
return
nullptr
;
#
endif
}
else
{
return
nullptr
;
}
}
void
StartPlayout
(
)
{
EXPECT_FALSE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Playing
(
)
)
;
}
void
StopPlayout
(
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopPlayout
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
}
void
StartRecording
(
)
{
EXPECT_FALSE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Recording
(
)
)
;
}
void
StopRecording
(
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
StopRecording
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
}
bool
NewWindowsAudioDeviceModuleIsUsed
(
)
{
#
ifdef
WEBRTC_WIN
AudioDeviceModule
:
:
AudioLayer
audio_layer
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
ActiveAudioLayer
(
&
audio_layer
)
)
;
if
(
audio_layer
=
=
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
{
return
true
;
}
#
endif
return
false
;
}
private
:
#
ifdef
WEBRTC_WIN
std
:
:
unique_ptr
<
ScopedCOMInitializer
>
com_initializer_
;
#
endif
AudioDeviceModule
:
:
AudioLayer
audio_layer_
;
std
:
:
unique_ptr
<
TaskQueueFactory
>
task_queue_factory_
;
bool
requirements_satisfied_
=
true
;
Event
event_
;
scoped_refptr
<
AudioDeviceModuleForTest
>
audio_device_
;
bool
stereo_playout_
=
false
;
}
;
TEST
(
MAYBE_AudioDeviceTestWin
ConstructDestructWithFactory
)
{
std
:
:
unique_ptr
<
TaskQueueFactory
>
task_queue_factory
=
CreateDefaultTaskQueueFactory
(
)
;
scoped_refptr
<
AudioDeviceModule
>
audio_device
;
audio_device
=
AudioDeviceModule
:
:
Create
(
AudioDeviceModule
:
:
kPlatformDefaultAudio
task_queue_factory
.
get
(
)
)
;
EXPECT_TRUE
(
audio_device
)
;
audio_device
=
nullptr
;
#
ifdef
WEBRTC_WIN
audio_device
=
AudioDeviceModule
:
:
Create
(
AudioDeviceModule
:
:
kWindowsCoreAudio2
task_queue_factory
.
get
(
)
)
;
EXPECT_FALSE
(
audio_device
)
;
audio_device
=
nullptr
;
ScopedCOMInitializer
com_initializer
(
ScopedCOMInitializer
:
:
kMTA
)
;
EXPECT_TRUE
(
com_initializer
.
Succeeded
(
)
)
;
audio_device
=
CreateWindowsCoreAudioAudioDeviceModule
(
task_queue_factory
.
get
(
)
)
;
EXPECT_TRUE
(
audio_device
)
;
AudioDeviceModule
:
:
AudioLayer
audio_layer
;
EXPECT_EQ
(
0
audio_device
-
>
ActiveAudioLayer
(
&
audio_layer
)
)
;
EXPECT_EQ
(
audio_layer
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
;
#
endif
}
TEST_P
(
MAYBE_AudioDeviceTest
ConstructDestructDefault
)
{
}
TEST_P
(
MAYBE_AudioDeviceTest
InitTerminate
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Initialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
Terminate
(
)
)
;
EXPECT_FALSE
(
audio_device
(
)
-
>
Initialized
(
)
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
PlayoutDeviceNames
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
char
device_name
[
kAdmMaxDeviceNameSize
]
;
char
unique_id
[
kAdmMaxGuidSize
]
;
int
num_devices
=
audio_device
(
)
-
>
PlayoutDevices
(
)
;
if
(
NewWindowsAudioDeviceModuleIsUsed
(
)
)
{
num_devices
+
=
2
;
}
EXPECT_GT
(
num_devices
0
)
;
for
(
int
i
=
0
;
i
<
num_devices
;
+
+
i
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
PlayoutDeviceName
(
i
device_name
unique_id
)
)
;
}
EXPECT_EQ
(
-
1
audio_device
(
)
-
>
PlayoutDeviceName
(
num_devices
device_name
unique_id
)
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
RecordingDeviceNames
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
char
device_name
[
kAdmMaxDeviceNameSize
]
;
char
unique_id
[
kAdmMaxGuidSize
]
;
int
num_devices
=
audio_device
(
)
-
>
RecordingDevices
(
)
;
if
(
NewWindowsAudioDeviceModuleIsUsed
(
)
)
{
num_devices
+
=
2
;
}
EXPECT_GT
(
num_devices
0
)
;
for
(
int
i
=
0
;
i
<
num_devices
;
+
+
i
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
RecordingDeviceName
(
i
device_name
unique_id
)
)
;
}
EXPECT_EQ
(
-
1
audio_device
(
)
-
>
RecordingDeviceName
(
num_devices
device_name
unique_id
)
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
SetPlayoutDevice
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
int
num_devices
=
audio_device
(
)
-
>
PlayoutDevices
(
)
;
if
(
NewWindowsAudioDeviceModuleIsUsed
(
)
)
{
num_devices
+
=
2
;
}
EXPECT_GT
(
num_devices
0
)
;
for
(
int
i
=
0
;
i
<
num_devices
;
+
+
i
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetPlayoutDevice
(
i
)
)
;
}
EXPECT_EQ
(
-
1
audio_device
(
)
-
>
SetPlayoutDevice
(
num_devices
)
)
;
#
ifdef
WEBRTC_WIN
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetPlayoutDevice
(
AudioDeviceModule
:
:
kDefaultDevice
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetPlayoutDevice
(
AudioDeviceModule
:
:
kDefaultCommunicationDevice
)
)
;
#
endif
}
TEST_P
(
MAYBE_AudioDeviceTest
SetRecordingDevice
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
int
num_devices
=
audio_device
(
)
-
>
RecordingDevices
(
)
;
if
(
NewWindowsAudioDeviceModuleIsUsed
(
)
)
{
num_devices
+
=
2
;
}
EXPECT_GT
(
num_devices
0
)
;
for
(
int
i
=
0
;
i
<
num_devices
;
+
+
i
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetRecordingDevice
(
i
)
)
;
}
EXPECT_EQ
(
-
1
audio_device
(
)
-
>
SetRecordingDevice
(
num_devices
)
)
;
#
ifdef
WEBRTC_WIN
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetRecordingDevice
(
AudioDeviceModule
:
:
kDefaultDevice
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetRecordingDevice
(
AudioDeviceModule
:
:
kDefaultCommunicationDevice
)
)
;
#
endif
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopPlayout
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartRecording
(
)
;
StopRecording
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopPlayoutWithRealDevice
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
int
num_devices
=
audio_device
(
)
-
>
PlayoutDevices
(
)
;
if
(
NewWindowsAudioDeviceModuleIsUsed
(
)
)
{
num_devices
+
=
2
;
}
EXPECT_GT
(
num_devices
0
)
;
for
(
int
i
=
0
;
i
<
num_devices
;
+
+
i
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetPlayoutDevice
(
i
)
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
}
#
ifdef
WEBRTC_WIN
AudioDeviceModule
:
:
WindowsDeviceType
device_role
[
]
=
{
AudioDeviceModule
:
:
kDefaultDevice
AudioDeviceModule
:
:
kDefaultCommunicationDevice
}
;
for
(
AudioDeviceModule
:
:
WindowsDeviceType
device_type
:
device_role
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetPlayoutDevice
(
device_type
)
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
}
#
endif
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopRecordingWithRealDevice
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
int
num_devices
=
audio_device
(
)
-
>
RecordingDevices
(
)
;
if
(
NewWindowsAudioDeviceModuleIsUsed
(
)
)
{
num_devices
+
=
2
;
}
EXPECT_GT
(
num_devices
0
)
;
for
(
int
i
=
0
;
i
<
num_devices
;
+
+
i
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetRecordingDevice
(
i
)
)
;
StartRecording
(
)
;
StopRecording
(
)
;
}
#
ifdef
WEBRTC_WIN
AudioDeviceModule
:
:
WindowsDeviceType
device_role
[
]
=
{
AudioDeviceModule
:
:
kDefaultDevice
AudioDeviceModule
:
:
kDefaultCommunicationDevice
}
;
for
(
AudioDeviceModule
:
:
WindowsDeviceType
device_type
:
device_role
)
{
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetRecordingDevice
(
device_type
)
)
;
StartRecording
(
)
;
StopRecording
(
)
;
}
#
endif
}
TEST_P
(
MAYBE_AudioDeviceTest
InitStopInitRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
StopRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
StopRecording
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartInitRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartRecording
(
)
)
;
StopRecording
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartInitPlayout
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartPlayout
(
)
)
;
StopPlayout
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
InitStopInitRecordingWhilePlaying
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
StopRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
InitStopInitPlayout
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
StopPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
StopPlayout
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
InitStopInitPlayoutWhileRecording
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartRecording
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
StopPlayout
(
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
StopPlayout
(
)
;
StopRecording
(
)
;
}
#
ifdef
WEBRTC_WIN
TEST_P
(
MAYBE_AudioDeviceTest
StartStopPlayoutWithExternalRestart
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
StartPlayout
(
)
;
StopPlayout
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopRecordingWithExternalRestart
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
StartRecording
(
)
;
StopRecording
(
)
;
StartRecording
(
)
;
StopRecording
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopPlayoutWithInternalRestart
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
if
(
audio_layer
(
)
!
=
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
{
return
;
}
MockAudioTransport
mock
(
TransportType
:
:
kPlay
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
_
_
_
_
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RestartPlayoutInternally
(
)
)
;
EXPECT_EQ
(
-
1
audio_device
(
)
-
>
StopPlayout
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Playing
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
PlayoutIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitPlayout
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartPlayout
(
)
)
;
ASSERT_TRUE
(
Mock
:
:
VerifyAndClearExpectations
(
&
mock
)
)
;
mock
.
ResetCallbackCounters
(
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
_
_
_
_
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Playing
(
)
)
;
StopPlayout
(
)
;
PreTearDown
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
StartStopRecordingWithInternalRestart
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
if
(
audio_layer
(
)
!
=
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
{
return
;
}
MockAudioTransport
mock
(
TransportType
:
:
kRecord
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
_
_
_
_
Ge
(
0u
)
0
_
false
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RestartRecordingInternally
(
)
)
;
EXPECT_EQ
(
-
1
audio_device
(
)
-
>
StopRecording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Recording
(
)
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
RecordingIsInitialized
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
InitRecording
(
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
StartRecording
(
)
)
;
ASSERT_TRUE
(
Mock
:
:
VerifyAndClearExpectations
(
&
mock
)
)
;
mock
.
ResetCallbackCounters
(
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
_
_
_
_
Ge
(
0u
)
0
_
false
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
EXPECT_TRUE
(
audio_device
(
)
-
>
Recording
(
)
)
;
StopRecording
(
)
;
PreTearDown
(
)
;
}
#
endif
TEST_P
(
MAYBE_AudioDeviceTest
StartPlayoutVerifyCallbacks
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
MockAudioTransport
mock
(
TransportType
:
:
kPlay
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
_
_
_
_
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
StopPlayout
(
)
;
PreTearDown
(
)
;
}
#
if
defined
(
ADDRESS_SANITIZER
)
|
|
defined
(
MEMORY_SANITIZER
)
|
|
\
defined
(
THREAD_SANITIZER
)
#
define
MAYBE_StartRecordingVerifyCallbacks
\
DISABLED_StartRecordingVerifyCallbacks
#
define
MAYBE_StartPlayoutAndRecordingVerifyCallbacks
\
DISABLED_StartPlayoutAndRecordingVerifyCallbacks
#
else
#
define
MAYBE_StartRecordingVerifyCallbacks
StartRecordingVerifyCallbacks
#
define
MAYBE_StartPlayoutAndRecordingVerifyCallbacks
\
StartPlayoutAndRecordingVerifyCallbacks
#
endif
TEST_P
(
MAYBE_AudioDeviceTest
MAYBE_StartRecordingVerifyCallbacks
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
MockAudioTransport
mock
(
TransportType
:
:
kRecord
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
_
_
_
_
Ge
(
0u
)
0
_
false
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
StopRecording
(
)
;
PreTearDown
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
MAYBE_StartPlayoutAndRecordingVerifyCallbacks
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
MockAudioTransport
mock
(
TransportType
:
:
kPlayAndRecord
)
;
mock
.
HandleCallbacks
(
event
(
)
nullptr
kNumCallbacks
)
;
EXPECT_CALL
(
mock
NeedMorePlayData
(
_
_
_
_
NotNull
(
)
_
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_CALL
(
mock
RecordedDataIsAvailable
(
NotNull
(
)
_
_
_
_
Ge
(
0u
)
0
_
false
_
_
)
)
.
Times
(
AtLeast
(
kNumCallbacks
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
kTestTimeOut
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
PreTearDown
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
RunPlayoutAndRecordingInFullDuplex
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
NiceMock
<
MockAudioTransport
>
mock
(
TransportType
:
:
kPlayAndRecord
)
;
FifoAudioStream
audio_stream
;
mock
.
HandleCallbacks
(
event
(
)
&
audio_stream
kFullDuplexTime
.
seconds
(
)
*
kNumCallbacksPerSecond
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoPlayout
(
true
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoRecording
(
true
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetSpeakerVolume
(
0
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
std
:
:
max
(
kTestTimeOut
kFullDuplexTime
)
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
PreTearDown
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
DISABLED_RunPlayoutAndRecordingInFullDuplexAndWaitForEnterKey
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
if
(
audio_layer
(
)
!
=
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
{
return
;
}
NiceMock
<
MockAudioTransport
>
mock
(
TransportType
:
:
kPlayAndRecord
)
;
FifoAudioStream
audio_stream
;
mock
.
HandleCallbacks
(
&
audio_stream
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoPlayout
(
true
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoRecording
(
true
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetPlayoutSampleRate
(
48000
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetRecordingSampleRate
(
48000
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
do
{
PRINT
(
"
Loopback
audio
is
active
at
48kHz
.
Press
Enter
to
stop
.
\
n
"
)
;
}
while
(
getchar
(
)
!
=
'
\
n
'
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
PreTearDown
(
)
;
}
TEST_P
(
MAYBE_AudioDeviceTest
DISABLED_MeasureLoopbackLatency
)
{
SKIP_TEST_IF_NOT
(
requirements_satisfied
(
)
)
;
NiceMock
<
MockAudioTransport
>
mock
(
TransportType
:
:
kPlayAndRecord
)
;
LatencyAudioStream
audio_stream
;
mock
.
HandleCallbacks
(
event
(
)
&
audio_stream
kMeasureLatencyTime
.
seconds
(
)
*
kNumCallbacksPerSecond
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
RegisterAudioCallback
(
&
mock
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoPlayout
(
true
)
)
;
EXPECT_EQ
(
0
audio_device
(
)
-
>
SetStereoRecording
(
true
)
)
;
StartPlayout
(
)
;
StartRecording
(
)
;
event
(
)
-
>
Wait
(
std
:
:
max
(
kTestTimeOut
kMeasureLatencyTime
)
)
;
StopRecording
(
)
;
StopPlayout
(
)
;
PreTearDown
(
)
;
EXPECT_GE
(
audio_stream
.
num_latency_values
(
)
static_cast
<
size_t
>
(
kImpulseFrequencyInHz
*
kMeasureLatencyTime
.
seconds
(
)
-
2
)
)
;
audio_stream
.
PrintResults
(
)
;
}
#
ifdef
WEBRTC_WIN
INSTANTIATE_TEST_SUITE_P
(
AudioLayerWin
MAYBE_AudioDeviceTest
:
:
testing
:
:
Values
(
AudioDeviceModule
:
:
kPlatformDefaultAudio
AudioDeviceModule
:
:
kWindowsCoreAudio2
)
)
;
#
else
INSTANTIATE_TEST_SUITE_P
(
AudioLayer
MAYBE_AudioDeviceTest
:
:
testing
:
:
Values
(
AudioDeviceModule
:
:
kPlatformDefaultAudio
)
)
;
#
endif
}
