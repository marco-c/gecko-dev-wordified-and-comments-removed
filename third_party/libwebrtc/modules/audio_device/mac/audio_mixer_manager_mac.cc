#
include
"
modules
/
audio_device
/
mac
/
audio_mixer_manager_mac
.
h
"
#
include
<
unistd
.
h
>
#
include
"
rtc_base
/
system
/
arch
.
h
"
namespace
webrtc
{
#
define
WEBRTC_CA_RETURN_ON_ERR
(
expr
)
\
do
{
\
err
=
expr
;
\
if
(
err
!
=
noErr
)
{
\
logCAMsg
(
rtc
:
:
LS_ERROR
"
Error
in
"
#
expr
(
const
char
*
)
&
err
)
;
\
return
-
1
;
\
}
\
}
while
(
0
)
#
define
WEBRTC_CA_LOG_ERR
(
expr
)
\
do
{
\
err
=
expr
;
\
if
(
err
!
=
noErr
)
{
\
logCAMsg
(
rtc
:
:
LS_ERROR
"
Error
in
"
#
expr
(
const
char
*
)
&
err
)
;
\
}
\
}
while
(
0
)
#
define
WEBRTC_CA_LOG_WARN
(
expr
)
\
do
{
\
err
=
expr
;
\
if
(
err
!
=
noErr
)
{
\
logCAMsg
(
rtc
:
:
LS_WARNING
"
Error
in
"
#
expr
(
const
char
*
)
&
err
)
;
\
}
\
}
while
(
0
)
AudioMixerManagerMac
:
:
AudioMixerManagerMac
(
)
:
_inputDeviceID
(
kAudioObjectUnknown
)
_outputDeviceID
(
kAudioObjectUnknown
)
_noInputChannels
(
0
)
_noOutputChannels
(
0
)
{
RTC_DLOG
(
LS_INFO
)
<
<
__FUNCTION__
<
<
"
created
"
;
}
AudioMixerManagerMac
:
:
~
AudioMixerManagerMac
(
)
{
RTC_DLOG
(
LS_INFO
)
<
<
__FUNCTION__
<
<
"
destroyed
"
;
Close
(
)
;
}
int32_t
AudioMixerManagerMac
:
:
Close
(
)
{
RTC_DLOG
(
LS_VERBOSE
)
<
<
__FUNCTION__
;
MutexLock
lock
(
&
mutex_
)
;
CloseSpeakerLocked
(
)
;
CloseMicrophoneLocked
(
)
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
CloseSpeaker
(
)
{
MutexLock
lock
(
&
mutex_
)
;
return
CloseSpeakerLocked
(
)
;
}
int32_t
AudioMixerManagerMac
:
:
CloseSpeakerLocked
(
)
{
RTC_DLOG
(
LS_VERBOSE
)
<
<
__FUNCTION__
;
_outputDeviceID
=
kAudioObjectUnknown
;
_noOutputChannels
=
0
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
CloseMicrophone
(
)
{
MutexLock
lock
(
&
mutex_
)
;
return
CloseMicrophoneLocked
(
)
;
}
int32_t
AudioMixerManagerMac
:
:
CloseMicrophoneLocked
(
)
{
RTC_DLOG
(
LS_VERBOSE
)
<
<
__FUNCTION__
;
_inputDeviceID
=
kAudioObjectUnknown
;
_noInputChannels
=
0
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
OpenSpeaker
(
AudioDeviceID
deviceID
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
OpenSpeaker
(
id
=
"
<
<
deviceID
<
<
"
)
"
;
MutexLock
lock
(
&
mutex_
)
;
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
pid_t
hogPid
=
-
1
;
_outputDeviceID
=
deviceID
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyHogMode
kAudioDevicePropertyScopeOutput
0
}
;
if
(
AudioObjectHasProperty
(
_outputDeviceID
&
propertyAddress
)
)
{
size
=
sizeof
(
hogPid
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
&
size
&
hogPid
)
)
;
if
(
hogPid
=
=
-
1
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
No
process
has
hogged
the
output
device
"
;
}
else
if
(
hogPid
=
=
getpid
(
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Our
process
has
hogged
the
output
device
"
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Another
process
(
pid
=
"
<
<
static_cast
<
int
>
(
hogPid
)
<
<
"
)
has
hogged
the
output
device
"
;
return
-
1
;
}
}
propertyAddress
.
mSelector
=
kAudioDevicePropertyStreamFormat
;
AudioStreamBasicDescription
streamFormat
;
size
=
sizeof
(
AudioStreamBasicDescription
)
;
memset
(
&
streamFormat
0
size
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
&
size
&
streamFormat
)
)
;
_noOutputChannels
=
streamFormat
.
mChannelsPerFrame
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
OpenMicrophone
(
AudioDeviceID
deviceID
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
OpenMicrophone
(
id
=
"
<
<
deviceID
<
<
"
)
"
;
MutexLock
lock
(
&
mutex_
)
;
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
pid_t
hogPid
=
-
1
;
_inputDeviceID
=
deviceID
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyHogMode
kAudioDevicePropertyScopeInput
0
}
;
size
=
sizeof
(
hogPid
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
&
size
&
hogPid
)
)
;
if
(
hogPid
=
=
-
1
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
No
process
has
hogged
the
input
device
"
;
}
else
if
(
hogPid
=
=
getpid
(
)
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
Our
process
has
hogged
the
input
device
"
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Another
process
(
pid
=
"
<
<
static_cast
<
int
>
(
hogPid
)
<
<
"
)
has
hogged
the
input
device
"
;
return
-
1
;
}
propertyAddress
.
mSelector
=
kAudioDevicePropertyStreamFormat
;
AudioStreamBasicDescription
streamFormat
;
size
=
sizeof
(
AudioStreamBasicDescription
)
;
memset
(
&
streamFormat
0
size
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
&
size
&
streamFormat
)
)
;
_noInputChannels
=
streamFormat
.
mChannelsPerFrame
;
return
0
;
}
bool
AudioMixerManagerMac
:
:
SpeakerIsInitialized
(
)
const
{
RTC_DLOG
(
LS_INFO
)
<
<
__FUNCTION__
;
return
(
_outputDeviceID
!
=
kAudioObjectUnknown
)
;
}
bool
AudioMixerManagerMac
:
:
MicrophoneIsInitialized
(
)
const
{
RTC_DLOG
(
LS_INFO
)
<
<
__FUNCTION__
;
return
(
_inputDeviceID
!
=
kAudioObjectUnknown
)
;
}
int32_t
AudioMixerManagerMac
:
:
SetSpeakerVolume
(
uint32_t
volume
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
SetSpeakerVolume
(
volume
=
"
<
<
volume
<
<
"
)
"
;
MutexLock
lock
(
&
mutex_
)
;
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
bool
success
=
false
;
const
Float32
vol
=
(
Float32
)
(
volume
/
255
.
0
)
;
RTC_DCHECK
(
vol
<
=
1
.
0
&
&
vol
>
=
0
.
0
)
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyVolumeScalar
kAudioDevicePropertyScopeOutput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
vol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
size
&
vol
)
)
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noOutputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
vol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
size
&
vol
)
)
;
}
success
=
true
;
}
if
(
!
success
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
set
a
volume
on
any
output
channel
"
;
return
-
1
;
}
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SpeakerVolume
(
uint32_t
&
volume
)
const
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
unsigned
int
channels
=
0
;
Float32
channelVol
=
0
;
Float32
vol
=
0
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyVolumeScalar
kAudioDevicePropertyScopeOutput
0
}
;
Boolean
hasProperty
=
AudioObjectHasProperty
(
_outputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
vol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
&
size
&
vol
)
)
;
volume
=
static_cast
<
uint32_t
>
(
vol
*
255
+
0
.
5
)
;
}
else
{
vol
=
0
;
for
(
UInt32
i
=
1
;
i
<
=
_noOutputChannels
;
i
+
+
)
{
channelVol
=
0
;
propertyAddress
.
mElement
=
i
;
hasProperty
=
AudioObjectHasProperty
(
_outputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
channelVol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
&
size
&
channelVol
)
)
;
vol
+
=
channelVol
;
channels
+
+
;
}
}
if
(
channels
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
get
a
volume
on
any
channel
"
;
return
-
1
;
}
RTC_DCHECK_GT
(
channels
0
)
;
volume
=
static_cast
<
uint32_t
>
(
255
*
vol
/
channels
+
0
.
5
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
SpeakerVolume
(
)
=
>
vol
=
"
<
<
vol
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MaxSpeakerVolume
(
uint32_t
&
maxVolume
)
const
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
maxVolume
=
255
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MinSpeakerVolume
(
uint32_t
&
minVolume
)
const
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
minVolume
=
0
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SpeakerVolumeIsAvailable
(
bool
&
available
)
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyVolumeScalar
kAudioDevicePropertyScopeOutput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
available
=
true
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noOutputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
!
=
noErr
|
|
!
isSettable
)
{
available
=
false
;
RTC_LOG
(
LS_WARNING
)
<
<
"
Volume
cannot
be
set
for
output
channel
"
<
<
i
<
<
"
err
=
"
<
<
err
;
return
-
1
;
}
}
available
=
true
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SpeakerMuteIsAvailable
(
bool
&
available
)
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyMute
kAudioDevicePropertyScopeOutput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
available
=
true
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noOutputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
!
=
noErr
|
|
!
isSettable
)
{
available
=
false
;
RTC_LOG
(
LS_WARNING
)
<
<
"
Mute
cannot
be
set
for
output
channel
"
<
<
i
<
<
"
err
=
"
<
<
err
;
return
-
1
;
}
}
available
=
true
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SetSpeakerMute
(
bool
enable
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
SetSpeakerMute
(
enable
=
"
<
<
enable
<
<
"
)
"
;
MutexLock
lock
(
&
mutex_
)
;
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
UInt32
mute
=
enable
?
1
:
0
;
bool
success
=
false
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyMute
kAudioDevicePropertyScopeOutput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
mute
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
size
&
mute
)
)
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noOutputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_outputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
mute
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
size
&
mute
)
)
;
}
success
=
true
;
}
if
(
!
success
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
set
mute
on
any
input
channel
"
;
return
-
1
;
}
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SpeakerMute
(
bool
&
enabled
)
const
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
unsigned
int
channels
=
0
;
UInt32
channelMuted
=
0
;
UInt32
muted
=
0
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyMute
kAudioDevicePropertyScopeOutput
0
}
;
Boolean
hasProperty
=
AudioObjectHasProperty
(
_outputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
muted
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
&
size
&
muted
)
)
;
enabled
=
static_cast
<
bool
>
(
muted
)
;
}
else
{
for
(
UInt32
i
=
1
;
i
<
=
_noOutputChannels
;
i
+
+
)
{
muted
=
0
;
propertyAddress
.
mElement
=
i
;
hasProperty
=
AudioObjectHasProperty
(
_outputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
channelMuted
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_outputDeviceID
&
propertyAddress
0
NULL
&
size
&
channelMuted
)
)
;
muted
=
(
muted
&
&
channelMuted
)
;
channels
+
+
;
}
}
if
(
channels
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
get
mute
for
any
channel
"
;
return
-
1
;
}
RTC_DCHECK_GT
(
channels
0
)
;
enabled
=
static_cast
<
bool
>
(
muted
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
SpeakerMute
(
)
=
>
enabled
=
"
<
<
enabled
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
StereoPlayoutIsAvailable
(
bool
&
available
)
{
if
(
_outputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
available
=
(
_noOutputChannels
=
=
2
)
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
StereoRecordingIsAvailable
(
bool
&
available
)
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
available
=
(
_noInputChannels
=
=
2
)
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MicrophoneMuteIsAvailable
(
bool
&
available
)
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyMute
kAudioDevicePropertyScopeInput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
available
=
true
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noInputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
!
=
noErr
|
|
!
isSettable
)
{
available
=
false
;
RTC_LOG
(
LS_WARNING
)
<
<
"
Mute
cannot
be
set
for
output
channel
"
<
<
i
<
<
"
err
=
"
<
<
err
;
return
-
1
;
}
}
available
=
true
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SetMicrophoneMute
(
bool
enable
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
SetMicrophoneMute
(
enable
=
"
<
<
enable
<
<
"
)
"
;
MutexLock
lock
(
&
mutex_
)
;
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
UInt32
mute
=
enable
?
1
:
0
;
bool
success
=
false
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyMute
kAudioDevicePropertyScopeInput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
mute
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
size
&
mute
)
)
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noInputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
mute
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
size
&
mute
)
)
;
}
success
=
true
;
}
if
(
!
success
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
set
mute
on
any
input
channel
"
;
return
-
1
;
}
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MicrophoneMute
(
bool
&
enabled
)
const
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
unsigned
int
channels
=
0
;
UInt32
channelMuted
=
0
;
UInt32
muted
=
0
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyMute
kAudioDevicePropertyScopeInput
0
}
;
Boolean
hasProperty
=
AudioObjectHasProperty
(
_inputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
muted
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
&
size
&
muted
)
)
;
enabled
=
static_cast
<
bool
>
(
muted
)
;
}
else
{
for
(
UInt32
i
=
1
;
i
<
=
_noInputChannels
;
i
+
+
)
{
muted
=
0
;
propertyAddress
.
mElement
=
i
;
hasProperty
=
AudioObjectHasProperty
(
_inputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
channelMuted
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
&
size
&
channelMuted
)
)
;
muted
=
(
muted
&
&
channelMuted
)
;
channels
+
+
;
}
}
if
(
channels
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
get
mute
for
any
channel
"
;
return
-
1
;
}
RTC_DCHECK_GT
(
channels
0
)
;
enabled
=
static_cast
<
bool
>
(
muted
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
MicrophoneMute
(
)
=
>
enabled
=
"
<
<
enabled
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MicrophoneVolumeIsAvailable
(
bool
&
available
)
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyVolumeScalar
kAudioDevicePropertyScopeInput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
available
=
true
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noInputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
!
=
noErr
|
|
!
isSettable
)
{
available
=
false
;
RTC_LOG
(
LS_WARNING
)
<
<
"
Volume
cannot
be
set
for
input
channel
"
<
<
i
<
<
"
err
=
"
<
<
err
;
return
-
1
;
}
}
available
=
true
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
SetMicrophoneVolume
(
uint32_t
volume
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
SetMicrophoneVolume
(
volume
=
"
<
<
volume
<
<
"
)
"
;
MutexLock
lock
(
&
mutex_
)
;
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
bool
success
=
false
;
const
Float32
vol
=
(
Float32
)
(
volume
/
255
.
0
)
;
RTC_DCHECK
(
vol
<
=
1
.
0
&
&
vol
>
=
0
.
0
)
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyVolumeScalar
kAudioDevicePropertyScopeInput
0
}
;
Boolean
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
vol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
size
&
vol
)
)
;
return
0
;
}
for
(
UInt32
i
=
1
;
i
<
=
_noInputChannels
;
i
+
+
)
{
propertyAddress
.
mElement
=
i
;
isSettable
=
false
;
err
=
AudioObjectIsPropertySettable
(
_inputDeviceID
&
propertyAddress
&
isSettable
)
;
if
(
err
=
=
noErr
&
&
isSettable
)
{
size
=
sizeof
(
vol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectSetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
size
&
vol
)
)
;
}
success
=
true
;
}
if
(
!
success
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
set
a
level
on
any
input
channel
"
;
return
-
1
;
}
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MicrophoneVolume
(
uint32_t
&
volume
)
const
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
OSStatus
err
=
noErr
;
UInt32
size
=
0
;
unsigned
int
channels
=
0
;
Float32
channelVol
=
0
;
Float32
volFloat32
=
0
;
AudioObjectPropertyAddress
propertyAddress
=
{
kAudioDevicePropertyVolumeScalar
kAudioDevicePropertyScopeInput
0
}
;
Boolean
hasProperty
=
AudioObjectHasProperty
(
_inputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
volFloat32
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
&
size
&
volFloat32
)
)
;
volume
=
static_cast
<
uint32_t
>
(
volFloat32
*
255
+
0
.
5
)
;
}
else
{
volFloat32
=
0
;
for
(
UInt32
i
=
1
;
i
<
=
_noInputChannels
;
i
+
+
)
{
channelVol
=
0
;
propertyAddress
.
mElement
=
i
;
hasProperty
=
AudioObjectHasProperty
(
_inputDeviceID
&
propertyAddress
)
;
if
(
hasProperty
)
{
size
=
sizeof
(
channelVol
)
;
WEBRTC_CA_RETURN_ON_ERR
(
AudioObjectGetPropertyData
(
_inputDeviceID
&
propertyAddress
0
NULL
&
size
&
channelVol
)
)
;
volFloat32
+
=
channelVol
;
channels
+
+
;
}
}
if
(
channels
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Unable
to
get
a
level
on
any
channel
"
;
return
-
1
;
}
RTC_DCHECK_GT
(
channels
0
)
;
volume
=
static_cast
<
uint32_t
>
(
255
*
volFloat32
/
channels
+
0
.
5
)
;
}
RTC_LOG
(
LS_VERBOSE
)
<
<
"
AudioMixerManagerMac
:
:
MicrophoneVolume
(
)
=
>
vol
=
"
<
<
volume
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MaxMicrophoneVolume
(
uint32_t
&
maxVolume
)
const
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
maxVolume
=
255
;
return
0
;
}
int32_t
AudioMixerManagerMac
:
:
MinMicrophoneVolume
(
uint32_t
&
minVolume
)
const
{
if
(
_inputDeviceID
=
=
kAudioObjectUnknown
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
device
ID
has
not
been
set
"
;
return
-
1
;
}
minVolume
=
0
;
return
0
;
}
void
AudioMixerManagerMac
:
:
logCAMsg
(
const
rtc
:
:
LoggingSeverity
sev
const
char
*
msg
const
char
*
err
)
{
RTC_DCHECK
(
msg
!
=
NULL
)
;
RTC_DCHECK
(
err
!
=
NULL
)
;
RTC_DCHECK
(
sev
=
=
rtc
:
:
LS_ERROR
|
|
sev
=
=
rtc
:
:
LS_WARNING
)
;
#
ifdef
WEBRTC_ARCH_BIG_ENDIAN
switch
(
sev
)
{
case
rtc
:
:
LS_ERROR
:
RTC_LOG
(
LS_ERROR
)
<
<
msg
<
<
"
:
"
<
<
err
[
0
]
<
<
err
[
1
]
<
<
err
[
2
]
<
<
err
[
3
]
;
break
;
case
rtc
:
:
LS_WARNING
:
RTC_LOG
(
LS_WARNING
)
<
<
msg
<
<
"
:
"
<
<
err
[
0
]
<
<
err
[
1
]
<
<
err
[
2
]
<
<
err
[
3
]
;
break
;
default
:
break
;
}
#
else
switch
(
sev
)
{
case
rtc
:
:
LS_ERROR
:
RTC_LOG
(
LS_ERROR
)
<
<
msg
<
<
"
:
"
<
<
err
[
3
]
<
<
err
[
2
]
<
<
err
[
1
]
<
<
err
[
0
]
;
break
;
case
rtc
:
:
LS_WARNING
:
RTC_LOG
(
LS_WARNING
)
<
<
msg
<
<
"
:
"
<
<
err
[
3
]
<
<
err
[
2
]
<
<
err
[
1
]
<
<
err
[
0
]
;
break
;
default
:
break
;
}
#
endif
}
}
