#
include
"
modules
/
audio_device
/
win
/
core_audio_output_win
.
h
"
#
include
<
memory
>
#
include
"
modules
/
audio_device
/
audio_device_buffer
.
h
"
#
include
"
modules
/
audio_device
/
fine_audio_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
using
Microsoft
:
:
WRL
:
:
ComPtr
;
namespace
webrtc
{
namespace
webrtc_win
{
CoreAudioOutput
:
:
CoreAudioOutput
(
bool
automatic_restart
)
:
CoreAudioBase
(
CoreAudioBase
:
:
Direction
:
:
kOutput
automatic_restart
[
this
]
(
uint64_t
freq
)
{
return
OnDataCallback
(
freq
)
;
}
[
this
]
(
ErrorType
err
)
{
return
OnErrorCallback
(
err
)
;
}
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
thread_checker_audio_
.
Detach
(
)
;
}
CoreAudioOutput
:
:
~
CoreAudioOutput
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
Terminate
(
)
;
}
int
CoreAudioOutput
:
:
Init
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
0
;
}
int
CoreAudioOutput
:
:
Terminate
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
StopPlayout
(
)
;
return
0
;
}
int
CoreAudioOutput
:
:
NumDevices
(
)
const
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
core_audio_utility
:
:
NumberOfActiveDevices
(
eRender
)
;
}
int
CoreAudioOutput
:
:
SetDevice
(
int
index
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
index
;
RTC_DCHECK_GE
(
index
0
)
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
CoreAudioBase
:
:
SetDevice
(
index
)
;
}
int
CoreAudioOutput
:
:
SetDevice
(
AudioDeviceModule
:
:
WindowsDeviceType
device
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
(
(
device
=
=
AudioDeviceModule
:
:
kDefaultDevice
)
?
"
Default
"
:
"
DefaultCommunication
"
)
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
SetDevice
(
(
device
=
=
AudioDeviceModule
:
:
kDefaultDevice
)
?
0
:
1
)
;
}
int
CoreAudioOutput
:
:
DeviceName
(
int
index
std
:
:
string
*
name
std
:
:
string
*
guid
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
index
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
RTC_DCHECK
(
name
)
;
return
CoreAudioBase
:
:
DeviceName
(
index
name
guid
)
;
}
void
CoreAudioOutput
:
:
AttachAudioBuffer
(
AudioDeviceBuffer
*
audio_buffer
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
audio_device_buffer_
=
audio_buffer
;
}
bool
CoreAudioOutput
:
:
PlayoutIsInitialized
(
)
const
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
initialized_
;
}
int
CoreAudioOutput
:
:
InitPlayout
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
IsRestarting
(
)
;
RTC_DCHECK
(
!
initialized_
)
;
RTC_DCHECK
(
!
Playing
(
)
)
;
RTC_DCHECK
(
!
audio_render_client_
)
;
if
(
!
CoreAudioBase
:
:
Init
(
)
)
{
return
-
1
;
}
RTC_DCHECK
(
audio_client_
)
;
RTC_DCHECK
(
audio_device_buffer_
)
;
WAVEFORMATEX
*
format
=
&
format_
.
Format
;
RTC_DCHECK_EQ
(
format
-
>
wFormatTag
WAVE_FORMAT_EXTENSIBLE
)
;
audio_device_buffer_
-
>
SetPlayoutSampleRate
(
format
-
>
nSamplesPerSec
)
;
audio_device_buffer_
-
>
SetPlayoutChannels
(
format
-
>
nChannels
)
;
fine_audio_buffer_
=
std
:
:
make_unique
<
FineAudioBuffer
>
(
audio_device_buffer_
)
;
ComPtr
<
IAudioRenderClient
>
audio_render_client
=
core_audio_utility
:
:
CreateRenderClient
(
audio_client_
.
Get
(
)
)
;
if
(
!
audio_render_client
.
Get
(
)
)
{
return
-
1
;
}
ComPtr
<
IAudioClock
>
audio_clock
=
core_audio_utility
:
:
CreateAudioClock
(
audio_client_
.
Get
(
)
)
;
if
(
!
audio_clock
.
Get
(
)
)
{
return
-
1
;
}
audio_render_client_
=
audio_render_client
;
audio_clock_
=
audio_clock
;
initialized_
=
true
;
return
0
;
}
int
CoreAudioOutput
:
:
StartPlayout
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
IsRestarting
(
)
;
RTC_DCHECK
(
!
Playing
(
)
)
;
RTC_DCHECK
(
fine_audio_buffer_
)
;
RTC_DCHECK
(
audio_device_buffer_
)
;
if
(
!
initialized_
)
{
RTC_DLOG
(
LS_WARNING
)
<
<
"
Playout
can
not
start
since
InitPlayout
must
succeed
first
"
;
}
fine_audio_buffer_
-
>
ResetPlayout
(
)
;
if
(
!
IsRestarting
(
)
)
{
audio_device_buffer_
-
>
StartPlayout
(
)
;
}
if
(
!
core_audio_utility
:
:
FillRenderEndpointBufferWithSilence
(
audio_client_
.
Get
(
)
audio_render_client_
.
Get
(
)
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
prepare
output
endpoint
with
silence
"
;
}
num_frames_written_
=
endpoint_buffer_size_frames_
;
if
(
!
Start
(
)
)
{
return
-
1
;
}
is_active_
=
true
;
return
0
;
}
int
CoreAudioOutput
:
:
StopPlayout
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
IsRestarting
(
)
;
if
(
!
initialized_
)
{
return
0
;
}
if
(
!
Playing
(
)
)
{
RTC_DLOG
(
WARNING
)
<
<
"
No
output
stream
is
active
"
;
ReleaseCOMObjects
(
)
;
initialized_
=
false
;
return
0
;
}
if
(
!
Stop
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
StopPlayout
failed
"
;
return
-
1
;
}
if
(
!
IsRestarting
(
)
)
{
RTC_DCHECK
(
audio_device_buffer_
)
;
audio_device_buffer_
-
>
StopPlayout
(
)
;
}
ReleaseCOMObjects
(
)
;
initialized_
=
false
;
is_active_
=
false
;
return
0
;
}
bool
CoreAudioOutput
:
:
Playing
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
is_active_
;
return
is_active_
;
}
int
CoreAudioOutput
:
:
VolumeIsAvailable
(
bool
*
available
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
IsVolumeControlAvailable
(
available
)
?
0
:
-
1
;
}
int
CoreAudioOutput
:
:
RestartPlayout
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
if
(
!
Playing
(
)
)
{
return
0
;
}
if
(
!
Restart
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
RestartPlayout
failed
"
;
return
-
1
;
}
return
0
;
}
bool
CoreAudioOutput
:
:
Restarting
(
)
const
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
IsRestarting
(
)
;
}
int
CoreAudioOutput
:
:
SetSampleRate
(
uint32_t
sample_rate
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
sample_rate_
=
sample_rate
;
return
0
;
}
void
CoreAudioOutput
:
:
ReleaseCOMObjects
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
CoreAudioBase
:
:
ReleaseCOMObjects
(
)
;
if
(
audio_render_client_
.
Get
(
)
)
{
audio_render_client_
.
Reset
(
)
;
}
}
bool
CoreAudioOutput
:
:
OnErrorCallback
(
ErrorType
error
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
:
"
<
<
as_integer
(
error
)
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_audio_
)
;
if
(
!
initialized_
|
|
!
Playing
(
)
)
{
return
true
;
}
if
(
error
=
=
CoreAudioBase
:
:
ErrorType
:
:
kStreamDisconnected
)
{
HandleStreamDisconnected
(
)
;
}
else
{
RTC_DLOG
(
WARNING
)
<
<
"
Unsupported
error
type
"
;
}
return
true
;
}
bool
CoreAudioOutput
:
:
OnDataCallback
(
uint64_t
device_frequency
)
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_audio_
)
;
if
(
num_data_callbacks_
=
=
0
)
{
RTC_LOG
(
INFO
)
<
<
"
-
-
-
Output
audio
stream
is
alive
-
-
-
"
;
}
UINT32
num_unread_frames
=
0
;
_com_error
error
=
audio_client_
-
>
GetCurrentPadding
(
&
num_unread_frames
)
;
if
(
error
.
Error
(
)
=
=
AUDCLNT_E_DEVICE_INVALIDATED
)
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
AUDCLNT_E_DEVICE_INVALIDATED
"
;
return
true
;
}
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioClient
:
:
GetCurrentPadding
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
return
false
;
}
UINT32
num_requested_frames
=
endpoint_buffer_size_frames_
-
num_unread_frames
;
if
(
num_requested_frames
=
=
0
)
{
RTC_DLOG
(
LS_WARNING
)
<
<
"
Audio
thread
is
signaled
but
no
new
audio
samples
are
needed
"
;
return
true
;
}
uint8_t
*
audio_data
;
error
=
audio_render_client_
-
>
GetBuffer
(
num_requested_frames
&
audio_data
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioRenderClient
:
:
GetBuffer
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
return
false
;
}
if
(
num_data_callbacks_
%
100
=
=
0
)
{
latency_ms_
=
EstimateOutputLatencyMillis
(
device_frequency
)
;
if
(
num_data_callbacks_
%
500
=
=
0
)
{
RTC_DLOG
(
INFO
)
<
<
"
latency
:
"
<
<
latency_ms_
;
}
}
fine_audio_buffer_
-
>
GetPlayoutData
(
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
int16_t
*
>
(
audio_data
)
num_requested_frames
*
format_
.
Format
.
nChannels
)
latency_ms_
)
;
error
=
audio_render_client_
-
>
ReleaseBuffer
(
num_requested_frames
0
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioRenderClient
:
:
ReleaseBuffer
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
return
false
;
}
num_frames_written_
+
=
num_requested_frames
;
+
+
num_data_callbacks_
;
return
true
;
}
int
CoreAudioOutput
:
:
EstimateOutputLatencyMillis
(
uint64_t
device_frequency
)
{
UINT64
position
=
0
;
UINT64
qpc_position
=
0
;
int
delay_ms
=
0
;
_com_error
error
=
audio_clock_
-
>
GetPosition
(
&
position
&
qpc_position
)
;
if
(
error
.
Error
(
)
=
=
S_OK
)
{
const
uint64_t
num_played_out_frames
=
format_
.
Format
.
nSamplesPerSec
*
position
/
device_frequency
;
const
uint64_t
delay_frames
=
num_frames_written_
-
num_played_out_frames
;
webrtc
:
:
TimeDelta
delay
=
webrtc
:
:
TimeDelta
:
:
Micros
(
delay_frames
*
rtc
:
:
kNumMicrosecsPerSec
/
format_
.
Format
.
nSamplesPerSec
)
;
delay_ms
=
delay
.
ms
(
)
;
}
return
delay_ms
;
}
bool
CoreAudioOutput
:
:
HandleStreamDisconnected
(
)
{
RTC_DLOG
(
INFO
)
<
<
"
<
<
<
-
-
-
"
<
<
__FUNCTION__
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_audio_
)
;
RTC_DCHECK
(
automatic_restart
(
)
)
;
if
(
StopPlayout
(
)
!
=
0
)
{
return
false
;
}
if
(
!
SwitchDeviceIfNeeded
(
)
)
{
return
false
;
}
if
(
InitPlayout
(
)
!
=
0
)
{
return
false
;
}
if
(
StartPlayout
(
)
!
=
0
)
{
return
false
;
}
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
-
-
-
>
>
>
"
;
return
true
;
}
}
}
