#
ifndef
MODULES_AUDIO_DEVICE_WIN_CORE_AUDIO_UTILITY_WIN_H_
#
define
MODULES_AUDIO_DEVICE_WIN_CORE_AUDIO_UTILITY_WIN_H_
#
include
<
audioclient
.
h
>
#
include
<
audiopolicy
.
h
>
#
include
<
avrt
.
h
>
#
include
<
comdef
.
h
>
#
include
<
mmdeviceapi
.
h
>
#
include
<
objbase
.
h
>
#
include
<
propidl
.
h
>
#
include
<
wrl
/
client
.
h
>
#
include
<
string
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
audio
/
audio_device_defines
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
modules
/
audio_device
/
audio_device_name
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
string_utils
.
h
"
#
pragma
comment
(
lib
"
Avrt
.
lib
"
)
namespace
webrtc
{
namespace
webrtc_win
{
class
ScopedMMCSSRegistration
{
public
:
const
char
*
PriorityClassToString
(
DWORD
priority_class
)
{
switch
(
priority_class
)
{
case
ABOVE_NORMAL_PRIORITY_CLASS
:
return
"
ABOVE_NORMAL
"
;
case
BELOW_NORMAL_PRIORITY_CLASS
:
return
"
BELOW_NORMAL
"
;
case
HIGH_PRIORITY_CLASS
:
return
"
HIGH
"
;
case
IDLE_PRIORITY_CLASS
:
return
"
IDLE
"
;
case
NORMAL_PRIORITY_CLASS
:
return
"
NORMAL
"
;
case
REALTIME_PRIORITY_CLASS
:
return
"
REALTIME
"
;
default
:
return
"
INVALID
"
;
}
}
const
char
*
PriorityToString
(
int
priority
)
{
switch
(
priority
)
{
case
THREAD_PRIORITY_ABOVE_NORMAL
:
return
"
ABOVE_NORMAL
"
;
case
THREAD_PRIORITY_BELOW_NORMAL
:
return
"
BELOW_NORMAL
"
;
case
THREAD_PRIORITY_HIGHEST
:
return
"
HIGHEST
"
;
case
THREAD_PRIORITY_IDLE
:
return
"
IDLE
"
;
case
THREAD_PRIORITY_LOWEST
:
return
"
LOWEST
"
;
case
THREAD_PRIORITY_NORMAL
:
return
"
NORMAL
"
;
case
THREAD_PRIORITY_TIME_CRITICAL
:
return
"
TIME_CRITICAL
"
;
default
:
return
"
INVALID
"
;
}
}
explicit
ScopedMMCSSRegistration
(
const
wchar_t
*
task_name
)
{
RTC_DLOG
(
LS_INFO
)
<
<
"
ScopedMMCSSRegistration
:
"
<
<
webrtc
:
:
ToUtf8
(
task_name
)
;
DWORD
mmcss_task_index
=
0
;
mmcss_handle_
=
AvSetMmThreadCharacteristicsW
(
task_name
&
mmcss_task_index
)
;
if
(
mmcss_handle_
=
=
nullptr
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
enable
MMCSS
on
this
thread
:
"
<
<
GetLastError
(
)
;
}
else
{
const
DWORD
priority_class
=
GetPriorityClass
(
GetCurrentProcess
(
)
)
;
const
int
priority
=
GetThreadPriority
(
GetCurrentThread
(
)
)
;
RTC_DLOG
(
LS_INFO
)
<
<
"
priority
class
:
"
<
<
PriorityClassToString
(
priority_class
)
<
<
"
(
"
<
<
priority_class
<
<
"
)
"
;
RTC_DLOG
(
LS_INFO
)
<
<
"
priority
:
"
<
<
PriorityToString
(
priority
)
<
<
"
(
"
<
<
priority
<
<
"
)
"
;
}
}
~
ScopedMMCSSRegistration
(
)
{
if
(
Succeeded
(
)
)
{
RTC_DLOG
(
LS_INFO
)
<
<
"
~
ScopedMMCSSRegistration
"
;
AvRevertMmThreadCharacteristics
(
mmcss_handle_
)
;
}
}
ScopedMMCSSRegistration
(
const
ScopedMMCSSRegistration
&
)
=
delete
;
ScopedMMCSSRegistration
&
operator
=
(
const
ScopedMMCSSRegistration
&
)
=
delete
;
bool
Succeeded
(
)
const
{
return
mmcss_handle_
!
=
nullptr
;
}
private
:
HANDLE
mmcss_handle_
=
nullptr
;
}
;
class
ScopedPropVariant
{
public
:
ScopedPropVariant
(
)
{
PropVariantInit
(
&
pv_
)
;
}
~
ScopedPropVariant
(
)
{
Reset
(
)
;
}
ScopedPropVariant
(
const
ScopedPropVariant
&
)
=
delete
;
ScopedPropVariant
&
operator
=
(
const
ScopedPropVariant
&
)
=
delete
;
bool
operator
=
=
(
const
ScopedPropVariant
&
)
const
=
delete
;
bool
operator
!
=
(
const
ScopedPropVariant
&
)
const
=
delete
;
PROPVARIANT
*
Receive
(
)
{
RTC_DCHECK_EQ
(
pv_
.
vt
VT_EMPTY
)
;
return
&
pv_
;
}
void
Reset
(
)
{
if
(
pv_
.
vt
!
=
VT_EMPTY
)
{
HRESULT
result
=
PropVariantClear
(
&
pv_
)
;
RTC_DCHECK_EQ
(
result
S_OK
)
;
}
}
const
PROPVARIANT
&
get
(
)
const
{
return
pv_
;
}
const
PROPVARIANT
*
ptr
(
)
const
{
return
&
pv_
;
}
private
:
PROPVARIANT
pv_
;
}
;
template
<
typename
T
>
class
ScopedCoMem
{
public
:
ScopedCoMem
(
)
:
mem_ptr_
(
nullptr
)
{
}
~
ScopedCoMem
(
)
{
Reset
(
nullptr
)
;
}
ScopedCoMem
(
const
ScopedCoMem
&
)
=
delete
;
ScopedCoMem
&
operator
=
(
const
ScopedCoMem
&
)
=
delete
;
T
*
*
operator
&
(
)
{
RTC_DCHECK
(
mem_ptr_
=
=
nullptr
)
;
return
&
mem_ptr_
;
}
operator
T
*
(
)
{
return
mem_ptr_
;
}
T
*
operator
-
>
(
)
{
RTC_DCHECK
(
mem_ptr_
!
=
nullptr
)
;
return
mem_ptr_
;
}
const
T
*
operator
-
>
(
)
const
{
RTC_DCHECK
(
mem_ptr_
!
=
nullptr
)
;
return
mem_ptr_
;
}
explicit
operator
bool
(
)
const
{
return
mem_ptr_
;
}
friend
bool
operator
=
=
(
const
ScopedCoMem
&
lhs
std
:
:
nullptr_t
)
{
return
lhs
.
Get
(
)
=
=
nullptr
;
}
friend
bool
operator
=
=
(
std
:
:
nullptr_t
const
ScopedCoMem
&
rhs
)
{
return
rhs
.
Get
(
)
=
=
nullptr
;
}
friend
bool
operator
!
=
(
const
ScopedCoMem
&
lhs
std
:
:
nullptr_t
)
{
return
lhs
.
Get
(
)
!
=
nullptr
;
}
friend
bool
operator
!
=
(
std
:
:
nullptr_t
const
ScopedCoMem
&
rhs
)
{
return
rhs
.
Get
(
)
!
=
nullptr
;
}
void
Reset
(
T
*
ptr
)
{
if
(
mem_ptr_
)
CoTaskMemFree
(
mem_ptr_
)
;
mem_ptr_
=
ptr
;
}
T
*
Get
(
)
const
{
return
mem_ptr_
;
}
private
:
T
*
mem_ptr_
;
}
;
class
ScopedHandle
{
public
:
ScopedHandle
(
)
:
handle_
(
nullptr
)
{
}
explicit
ScopedHandle
(
HANDLE
h
)
:
handle_
(
nullptr
)
{
Set
(
h
)
;
}
~
ScopedHandle
(
)
{
Close
(
)
;
}
ScopedHandle
&
operator
=
(
const
ScopedHandle
&
)
=
delete
;
bool
operator
=
=
(
const
ScopedHandle
&
)
const
=
delete
;
bool
operator
!
=
(
const
ScopedHandle
&
)
const
=
delete
;
bool
IsValid
(
)
const
{
return
handle_
!
=
nullptr
;
}
void
Set
(
HANDLE
new_handle
)
{
Close
(
)
;
if
(
new_handle
!
=
INVALID_HANDLE_VALUE
)
{
handle_
=
new_handle
;
}
}
HANDLE
Get
(
)
const
{
return
handle_
;
}
operator
HANDLE
(
)
const
{
return
handle_
;
}
void
Close
(
)
{
if
(
handle_
)
{
if
(
!
:
:
CloseHandle
(
handle_
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
}
handle_
=
nullptr
;
}
}
private
:
HANDLE
handle_
;
}
;
namespace
core_audio_utility
{
class
WaveFormatWrapper
{
public
:
WaveFormatWrapper
(
WAVEFORMATEXTENSIBLE
*
p
)
:
ptr_
(
reinterpret_cast
<
WAVEFORMATEX
*
>
(
p
)
)
{
}
WaveFormatWrapper
(
WAVEFORMATEX
*
p
)
:
ptr_
(
p
)
{
}
~
WaveFormatWrapper
(
)
=
default
;
operator
WAVEFORMATEX
*
(
)
const
{
return
ptr_
;
}
WAVEFORMATEX
*
operator
-
>
(
)
const
{
return
ptr_
;
}
WAVEFORMATEX
*
get
(
)
const
{
return
ptr_
;
}
WAVEFORMATEXTENSIBLE
*
GetExtensible
(
)
const
;
bool
IsExtensible
(
)
const
;
bool
IsPcm
(
)
const
;
bool
IsFloat
(
)
const
;
size_t
size
(
)
const
;
private
:
WAVEFORMATEX
*
ptr_
;
}
;
bool
IsSupported
(
)
;
bool
IsMMCSSSupported
(
)
;
int
NumberOfActiveDevices
(
EDataFlow
data_flow
)
;
uint32_t
GetAudioClientVersion
(
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMMDeviceEnumerator
>
CreateDeviceEnumerator
(
)
;
std
:
:
string
GetDefaultInputDeviceID
(
)
;
std
:
:
string
GetDefaultOutputDeviceID
(
)
;
std
:
:
string
GetCommunicationsInputDeviceID
(
)
;
std
:
:
string
GetCommunicationsOutputDeviceID
(
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMMDevice
>
CreateDevice
(
absl
:
:
string_view
device_id
EDataFlow
data_flow
ERole
role
)
;
webrtc
:
:
AudioDeviceName
GetDeviceName
(
IMMDevice
*
device
)
;
std
:
:
string
GetFriendlyName
(
absl
:
:
string_view
device_id
EDataFlow
data_flow
ERole
role
)
;
EDataFlow
GetDataFlow
(
IMMDevice
*
device
)
;
bool
GetInputDeviceNames
(
webrtc
:
:
AudioDeviceNames
*
device_names
)
;
bool
GetOutputDeviceNames
(
webrtc
:
:
AudioDeviceNames
*
device_names
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioSessionManager2
>
CreateSessionManager2
(
IMMDevice
*
device
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioSessionEnumerator
>
CreateSessionEnumerator
(
IMMDevice
*
device
)
;
int
NumberOfActiveSessions
(
IMMDevice
*
device
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioClient
>
CreateClient
(
absl
:
:
string_view
device_id
EDataFlow
data_flow
ERole
role
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioClient2
>
CreateClient2
(
absl
:
:
string_view
device_id
EDataFlow
data_flow
ERole
role
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioClient3
>
CreateClient3
(
absl
:
:
string_view
device_id
EDataFlow
data_flow
ERole
role
)
;
HRESULT
SetClientProperties
(
IAudioClient2
*
client
)
;
HRESULT
GetBufferSizeLimits
(
IAudioClient2
*
client
const
WAVEFORMATEXTENSIBLE
*
format
REFERENCE_TIME
*
min_buffer_duration
REFERENCE_TIME
*
max_buffer_duration
)
;
HRESULT
GetSharedModeMixFormat
(
IAudioClient
*
client
WAVEFORMATEXTENSIBLE
*
format
)
;
bool
IsFormatSupported
(
IAudioClient
*
client
AUDCLNT_SHAREMODE
share_mode
const
WAVEFORMATEXTENSIBLE
*
format
)
;
HRESULT
GetDevicePeriod
(
IAudioClient
*
client
AUDCLNT_SHAREMODE
share_mode
REFERENCE_TIME
*
device_period
)
;
HRESULT
GetSharedModeEnginePeriod
(
IAudioClient3
*
client3
const
WAVEFORMATEXTENSIBLE
*
format
uint32_t
*
default_period_in_frames
uint32_t
*
fundamental_period_in_frames
uint32_t
*
min_period_in_frames
uint32_t
*
max_period_in_frames
)
;
HRESULT
GetPreferredAudioParameters
(
IAudioClient
*
client
webrtc
:
:
AudioParameters
*
params
)
;
HRESULT
GetPreferredAudioParameters
(
IAudioClient
*
client
webrtc
:
:
AudioParameters
*
params
uint32_t
sample_rate
)
;
HRESULT
SharedModeInitialize
(
IAudioClient
*
client
const
WAVEFORMATEXTENSIBLE
*
format
HANDLE
event_handle
REFERENCE_TIME
buffer_duration
bool
auto_convert_pcm
uint32_t
*
endpoint_buffer_size
)
;
HRESULT
SharedModeInitializeLowLatency
(
IAudioClient3
*
client
const
WAVEFORMATEXTENSIBLE
*
format
HANDLE
event_handle
uint32_t
period_in_frames
bool
auto_convert_pcm
uint32_t
*
endpoint_buffer_size
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioRenderClient
>
CreateRenderClient
(
IAudioClient
*
client
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioCaptureClient
>
CreateCaptureClient
(
IAudioClient
*
client
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioClock
>
CreateAudioClock
(
IAudioClient
*
client
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IAudioSessionControl
>
CreateAudioSessionControl
(
IAudioClient
*
client
)
;
Microsoft
:
:
WRL
:
:
ComPtr
<
ISimpleAudioVolume
>
CreateSimpleAudioVolume
(
IAudioClient
*
client
)
;
bool
FillRenderEndpointBufferWithSilence
(
IAudioClient
*
client
IAudioRenderClient
*
render_client
)
;
std
:
:
string
WaveFormatToString
(
WaveFormatWrapper
format
)
;
webrtc
:
:
TimeDelta
ReferenceTimeToTimeDelta
(
REFERENCE_TIME
time
)
;
double
FramesToMilliseconds
(
uint32_t
num_frames
uint16_t
sample_rate
)
;
std
:
:
string
ErrorToString
(
const
_com_error
&
error
)
;
}
}
}
#
endif
