#
include
"
modules
/
audio_device
/
win
/
core_audio_base_win
.
h
"
#
include
<
memory
>
#
include
<
string
>
#
include
"
modules
/
audio_device
/
audio_device_buffer
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
win
/
scoped_com_initializer
.
h
"
#
include
"
rtc_base
/
win
/
windows_version
.
h
"
using
Microsoft
:
:
WRL
:
:
ComPtr
;
namespace
webrtc
{
namespace
webrtc_win
{
namespace
{
const
bool
kEnableLowLatencyIfSupported
=
false
;
enum
DefaultDeviceType
{
kUndefined
=
-
1
kDefault
=
0
kDefaultCommunications
=
1
kDefaultDeviceTypeMaxCount
=
kDefaultCommunications
+
1
}
;
const
char
*
DirectionToString
(
CoreAudioBase
:
:
Direction
direction
)
{
switch
(
direction
)
{
case
CoreAudioBase
:
:
Direction
:
:
kOutput
:
return
"
Output
"
;
case
CoreAudioBase
:
:
Direction
:
:
kInput
:
return
"
Input
"
;
default
:
return
"
Unkown
"
;
}
}
const
char
*
RoleToString
(
const
ERole
role
)
{
switch
(
role
)
{
case
eConsole
:
return
"
Console
"
;
case
eMultimedia
:
return
"
Multimedia
"
;
case
eCommunications
:
return
"
Communications
"
;
default
:
return
"
Unsupported
"
;
}
}
std
:
:
string
IndexToString
(
int
index
)
{
std
:
:
string
ss
=
std
:
:
to_string
(
index
)
;
switch
(
index
)
{
case
kDefault
:
ss
+
=
"
(
Default
)
"
;
break
;
case
kDefaultCommunications
:
ss
+
=
"
(
Communications
)
"
;
break
;
default
:
break
;
}
return
ss
;
}
const
char
*
SessionStateToString
(
AudioSessionState
state
)
{
switch
(
state
)
{
case
AudioSessionStateActive
:
return
"
Active
"
;
case
AudioSessionStateInactive
:
return
"
Inactive
"
;
case
AudioSessionStateExpired
:
return
"
Expired
"
;
default
:
return
"
Invalid
"
;
}
}
const
char
*
SessionDisconnectReasonToString
(
AudioSessionDisconnectReason
reason
)
{
switch
(
reason
)
{
case
DisconnectReasonDeviceRemoval
:
return
"
DeviceRemoval
"
;
case
DisconnectReasonServerShutdown
:
return
"
ServerShutdown
"
;
case
DisconnectReasonFormatChanged
:
return
"
FormatChanged
"
;
case
DisconnectReasonSessionLogoff
:
return
"
SessionLogoff
"
;
case
DisconnectReasonSessionDisconnected
:
return
"
Disconnected
"
;
case
DisconnectReasonExclusiveModeOverride
:
return
"
ExclusiveModeOverride
"
;
default
:
return
"
Invalid
"
;
}
}
void
Run
(
void
*
obj
)
{
RTC_DCHECK
(
obj
)
;
reinterpret_cast
<
CoreAudioBase
*
>
(
obj
)
-
>
ThreadRun
(
)
;
}
bool
IsLowLatencySupported
(
IAudioClient3
*
client3
const
WAVEFORMATEXTENSIBLE
*
format
uint32_t
*
min_period_in_frames
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
uint32_t
default_period
=
0
;
uint32_t
fundamental_period
=
0
;
uint32_t
min_period
=
0
;
uint32_t
max_period
=
0
;
if
(
FAILED
(
core_audio_utility
:
:
GetSharedModeEnginePeriod
(
client3
format
&
default_period
&
fundamental_period
&
min_period
&
max_period
)
)
)
{
return
false
;
}
const
bool
low_latency
=
min_period
<
default_period
;
RTC_LOG
(
INFO
)
<
<
"
low_latency
:
"
<
<
low_latency
;
*
min_period_in_frames
=
low_latency
?
min_period
:
0
;
return
low_latency
;
}
}
CoreAudioBase
:
:
CoreAudioBase
(
Direction
direction
bool
automatic_restart
OnDataCallback
data_callback
OnErrorCallback
error_callback
)
:
format_
(
)
direction_
(
direction
)
automatic_restart_
(
automatic_restart
)
on_data_callback_
(
data_callback
)
on_error_callback_
(
error_callback
)
device_index_
(
kUndefined
)
is_restarting_
(
false
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
)
<
<
"
]
"
;
RTC_DLOG
(
INFO
)
<
<
"
Automatic
restart
:
"
<
<
automatic_restart
;
RTC_DLOG
(
INFO
)
<
<
"
Windows
version
:
"
<
<
rtc
:
:
rtc_win
:
:
GetVersion
(
)
;
audio_samples_event_
.
Set
(
CreateEvent
(
nullptr
false
false
nullptr
)
)
;
RTC_DCHECK
(
audio_samples_event_
.
IsValid
(
)
)
;
stop_event_
.
Set
(
CreateEvent
(
nullptr
false
false
nullptr
)
)
;
RTC_DCHECK
(
stop_event_
.
IsValid
(
)
)
;
restart_event_
.
Set
(
CreateEvent
(
nullptr
false
false
nullptr
)
)
;
RTC_DCHECK
(
restart_event_
.
IsValid
(
)
)
;
}
CoreAudioBase
:
:
~
CoreAudioBase
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK_EQ
(
ref_count_
1
)
;
}
EDataFlow
CoreAudioBase
:
:
GetDataFlow
(
)
const
{
return
direction_
=
=
CoreAudioBase
:
:
Direction
:
:
kOutput
?
eRender
:
eCapture
;
}
bool
CoreAudioBase
:
:
IsRestarting
(
)
const
{
return
is_restarting_
;
}
int64_t
CoreAudioBase
:
:
TimeSinceStart
(
)
const
{
return
rtc
:
:
TimeSince
(
start_time_
)
;
}
int
CoreAudioBase
:
:
NumberOfActiveDevices
(
)
const
{
return
core_audio_utility
:
:
NumberOfActiveDevices
(
GetDataFlow
(
)
)
;
}
int
CoreAudioBase
:
:
NumberOfEnumeratedDevices
(
)
const
{
const
int
num_active
=
NumberOfActiveDevices
(
)
;
return
num_active
>
0
?
num_active
+
kDefaultDeviceTypeMaxCount
:
0
;
}
void
CoreAudioBase
:
:
ReleaseCOMObjects
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
if
(
audio_client_
)
{
audio_client_
.
Reset
(
)
;
}
if
(
audio_clock_
.
Get
(
)
)
{
audio_clock_
.
Reset
(
)
;
}
if
(
audio_session_control_
.
Get
(
)
)
{
audio_session_control_
.
Reset
(
)
;
}
}
bool
CoreAudioBase
:
:
IsDefaultDevice
(
int
index
)
const
{
return
index
=
=
kDefault
;
}
bool
CoreAudioBase
:
:
IsDefaultCommunicationsDevice
(
int
index
)
const
{
return
index
=
=
kDefaultCommunications
;
}
bool
CoreAudioBase
:
:
IsDefaultDeviceId
(
const
std
:
:
string
&
device_id
)
const
{
return
(
IsInput
(
)
&
&
(
device_id
=
=
core_audio_utility
:
:
GetDefaultInputDeviceID
(
)
)
)
|
|
(
IsOutput
(
)
&
&
(
device_id
=
=
core_audio_utility
:
:
GetDefaultOutputDeviceID
(
)
)
)
;
}
bool
CoreAudioBase
:
:
IsDefaultCommunicationsDeviceId
(
const
std
:
:
string
&
device_id
)
const
{
return
(
IsInput
(
)
&
&
(
device_id
=
=
core_audio_utility
:
:
GetCommunicationsInputDeviceID
(
)
)
)
|
|
(
IsOutput
(
)
&
&
(
device_id
=
=
core_audio_utility
:
:
GetCommunicationsOutputDeviceID
(
)
)
)
;
}
bool
CoreAudioBase
:
:
IsInput
(
)
const
{
return
direction_
=
=
CoreAudioBase
:
:
Direction
:
:
kInput
;
}
bool
CoreAudioBase
:
:
IsOutput
(
)
const
{
return
direction_
=
=
CoreAudioBase
:
:
Direction
:
:
kOutput
;
}
std
:
:
string
CoreAudioBase
:
:
GetDeviceID
(
int
index
)
const
{
if
(
index
>
=
NumberOfEnumeratedDevices
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Invalid
device
index
"
;
return
std
:
:
string
(
)
;
}
std
:
:
string
device_id
;
if
(
IsDefaultDevice
(
index
)
)
{
device_id
=
IsInput
(
)
?
core_audio_utility
:
:
GetDefaultInputDeviceID
(
)
:
core_audio_utility
:
:
GetDefaultOutputDeviceID
(
)
;
}
else
if
(
IsDefaultCommunicationsDevice
(
index
)
)
{
device_id
=
IsInput
(
)
?
core_audio_utility
:
:
GetCommunicationsInputDeviceID
(
)
:
core_audio_utility
:
:
GetCommunicationsOutputDeviceID
(
)
;
}
else
{
AudioDeviceNames
device_names
;
bool
ok
=
IsInput
(
)
?
core_audio_utility
:
:
GetInputDeviceNames
(
&
device_names
)
:
core_audio_utility
:
:
GetOutputDeviceNames
(
&
device_names
)
;
if
(
ok
)
{
device_id
=
device_names
[
index
]
.
unique_id
;
}
}
return
device_id
;
}
int
CoreAudioBase
:
:
SetDevice
(
int
index
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
:
index
=
"
<
<
IndexToString
(
index
)
;
if
(
initialized_
)
{
return
-
1
;
}
std
:
:
string
device_id
=
GetDeviceID
(
index
)
;
RTC_DLOG
(
INFO
)
<
<
"
index
=
"
<
<
IndexToString
(
index
)
<
<
"
=
>
device_id
:
"
<
<
device_id
;
device_index_
=
index
;
device_id_
=
device_id
;
return
device_id_
.
empty
(
)
?
-
1
:
0
;
}
int
CoreAudioBase
:
:
DeviceName
(
int
index
std
:
:
string
*
name
std
:
:
string
*
guid
)
const
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
:
index
=
"
<
<
IndexToString
(
index
)
;
if
(
index
>
NumberOfEnumeratedDevices
(
)
-
1
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Invalid
device
index
"
;
return
-
1
;
}
AudioDeviceNames
device_names
;
bool
ok
=
IsInput
(
)
?
core_audio_utility
:
:
GetInputDeviceNames
(
&
device_names
)
:
core_audio_utility
:
:
GetOutputDeviceNames
(
&
device_names
)
;
if
(
!
ok
|
|
static_cast
<
int
>
(
device_names
.
size
(
)
)
<
=
index
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
get
the
device
name
"
;
return
-
1
;
}
*
name
=
device_names
[
index
]
.
device_name
;
RTC_DLOG
(
INFO
)
<
<
"
name
:
"
<
<
*
name
;
if
(
guid
!
=
nullptr
)
{
*
guid
=
device_names
[
index
]
.
unique_id
;
RTC_DLOG
(
INFO
)
<
<
"
guid
:
"
<
<
*
guid
;
}
return
0
;
}
bool
CoreAudioBase
:
:
Init
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
"
;
RTC_DCHECK_GE
(
device_index_
0
)
;
RTC_DCHECK
(
!
device_id_
.
empty
(
)
)
;
RTC_DCHECK
(
audio_device_buffer_
)
;
RTC_DCHECK
(
!
audio_client_
)
;
RTC_DCHECK
(
!
audio_session_control_
.
Get
(
)
)
;
std
:
:
string
device_id
=
AudioDeviceName
:
:
kDefaultDeviceId
;
ERole
role
=
ERole
(
)
;
if
(
IsDefaultDevice
(
device_index_
)
)
{
role
=
eConsole
;
}
else
if
(
IsDefaultCommunicationsDevice
(
device_index_
)
)
{
role
=
eCommunications
;
}
else
{
device_id
=
device_id_
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
Unique
device
identifier
:
device_id
=
"
<
<
device_id
<
<
"
role
=
"
<
<
RoleToString
(
role
)
;
ComPtr
<
IAudioClient
>
audio_client
;
if
(
core_audio_utility
:
:
GetAudioClientVersion
(
)
=
=
3
)
{
RTC_DLOG
(
INFO
)
<
<
"
Using
IAudioClient3
"
;
audio_client
=
core_audio_utility
:
:
CreateClient3
(
device_id
GetDataFlow
(
)
role
)
;
}
else
if
(
core_audio_utility
:
:
GetAudioClientVersion
(
)
=
=
2
)
{
RTC_DLOG
(
INFO
)
<
<
"
Using
IAudioClient2
"
;
audio_client
=
core_audio_utility
:
:
CreateClient2
(
device_id
GetDataFlow
(
)
role
)
;
}
else
{
RTC_DLOG
(
INFO
)
<
<
"
Using
IAudioClient
"
;
audio_client
=
core_audio_utility
:
:
CreateClient
(
device_id
GetDataFlow
(
)
role
)
;
}
if
(
!
audio_client
)
{
return
false
;
}
if
(
core_audio_utility
:
:
GetAudioClientVersion
(
)
>
=
2
)
{
if
(
FAILED
(
core_audio_utility
:
:
SetClientProperties
(
static_cast
<
IAudioClient2
*
>
(
audio_client
.
Get
(
)
)
)
)
)
{
return
false
;
}
}
AudioParameters
params
;
HRESULT
res
=
sample_rate_
?
core_audio_utility
:
:
GetPreferredAudioParameters
(
audio_client
.
Get
(
)
&
params
*
sample_rate_
)
:
core_audio_utility
:
:
GetPreferredAudioParameters
(
audio_client
.
Get
(
)
&
params
)
;
if
(
FAILED
(
res
)
)
{
return
false
;
}
WAVEFORMATEX
*
format
=
&
format_
.
Format
;
format
-
>
wFormatTag
=
WAVE_FORMAT_EXTENSIBLE
;
if
(
params
.
channels
(
)
<
=
2
)
{
format
-
>
nChannels
=
rtc
:
:
dchecked_cast
<
WORD
>
(
params
.
channels
(
)
)
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Using
channel
upmixing
in
WASAPI
audio
engine
(
2
=
>
"
<
<
params
.
channels
(
)
<
<
"
)
"
;
format
-
>
nChannels
=
2
;
}
format
-
>
nSamplesPerSec
=
params
.
sample_rate
(
)
;
format
-
>
wBitsPerSample
=
rtc
:
:
dchecked_cast
<
WORD
>
(
params
.
bits_per_sample
(
)
)
;
format
-
>
nBlockAlign
=
(
format
-
>
wBitsPerSample
/
8
)
*
format
-
>
nChannels
;
format
-
>
nAvgBytesPerSec
=
format
-
>
nSamplesPerSec
*
format
-
>
nBlockAlign
;
format
-
>
cbSize
=
sizeof
(
WAVEFORMATEXTENSIBLE
)
-
sizeof
(
WAVEFORMATEX
)
;
format_
.
Samples
.
wValidBitsPerSample
=
rtc
:
:
dchecked_cast
<
WORD
>
(
params
.
bits_per_sample
(
)
)
;
format_
.
dwChannelMask
=
format
-
>
nChannels
=
=
1
?
KSAUDIO_SPEAKER_MONO
:
KSAUDIO_SPEAKER_STEREO
;
format_
.
SubFormat
=
KSDATAFORMAT_SUBTYPE_PCM
;
RTC_DLOG
(
INFO
)
<
<
core_audio_utility
:
:
WaveFormatToString
(
&
format_
)
;
if
(
!
sample_rate_
)
{
if
(
!
core_audio_utility
:
:
IsFormatSupported
(
audio_client
.
Get
(
)
AUDCLNT_SHAREMODE_SHARED
&
format_
)
)
{
return
false
;
}
}
bool
low_latency_support
=
false
;
uint32_t
min_period_in_frames
=
0
;
if
(
kEnableLowLatencyIfSupported
&
&
core_audio_utility
:
:
GetAudioClientVersion
(
)
>
=
3
)
{
low_latency_support
=
IsLowLatencySupported
(
static_cast
<
IAudioClient3
*
>
(
audio_client
.
Get
(
)
)
&
format_
&
min_period_in_frames
)
;
}
if
(
low_latency_support
)
{
RTC_DCHECK_GE
(
core_audio_utility
:
:
GetAudioClientVersion
(
)
3
)
;
if
(
FAILED
(
core_audio_utility
:
:
SharedModeInitializeLowLatency
(
static_cast
<
IAudioClient3
*
>
(
audio_client
.
Get
(
)
)
&
format_
audio_samples_event_
min_period_in_frames
sample_rate_
.
has_value
(
)
&
endpoint_buffer_size_frames_
)
)
)
{
return
false
;
}
}
else
{
const
REFERENCE_TIME
requested_buffer_size
=
0
;
if
(
FAILED
(
core_audio_utility
:
:
SharedModeInitialize
(
audio_client
.
Get
(
)
&
format_
audio_samples_event_
requested_buffer_size
sample_rate_
.
has_value
(
)
&
endpoint_buffer_size_frames_
)
)
)
{
return
false
;
}
}
REFERENCE_TIME
device_period
;
if
(
FAILED
(
core_audio_utility
:
:
GetDevicePeriod
(
audio_client
.
Get
(
)
AUDCLNT_SHAREMODE_SHARED
&
device_period
)
)
)
{
return
false
;
}
const
double
device_period_in_seconds
=
static_cast
<
double
>
(
core_audio_utility
:
:
ReferenceTimeToTimeDelta
(
device_period
)
.
ms
(
)
)
/
1000
.
0L
;
const
int
preferred_frames_per_buffer
=
static_cast
<
int
>
(
params
.
sample_rate
(
)
*
device_period_in_seconds
+
0
.
5
)
;
RTC_DLOG
(
INFO
)
<
<
"
preferred_frames_per_buffer
:
"
<
<
preferred_frames_per_buffer
;
if
(
preferred_frames_per_buffer
%
params
.
frames_per_buffer
(
)
)
{
RTC_LOG
(
WARNING
)
<
<
"
Buffer
size
of
"
<
<
params
.
frames_per_buffer
(
)
<
<
"
is
not
an
even
divisor
of
"
<
<
preferred_frames_per_buffer
;
}
ComPtr
<
IAudioSessionControl
>
audio_session_control
=
core_audio_utility
:
:
CreateAudioSessionControl
(
audio_client
.
Get
(
)
)
;
if
(
!
audio_session_control
.
Get
(
)
)
{
return
false
;
}
AudioSessionState
state
;
if
(
FAILED
(
audio_session_control
-
>
GetState
(
&
state
)
)
)
{
return
false
;
}
RTC_DLOG
(
INFO
)
<
<
"
audio
session
state
:
"
<
<
SessionStateToString
(
state
)
;
RTC_DCHECK_EQ
(
state
AudioSessionStateInactive
)
;
if
(
FAILED
(
audio_session_control
-
>
RegisterAudioSessionNotification
(
this
)
)
)
{
return
false
;
}
audio_client_
=
audio_client
;
audio_session_control_
=
audio_session_control
;
return
true
;
}
bool
CoreAudioBase
:
:
Start
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
"
;
if
(
IsRestarting
(
)
)
{
RTC_DCHECK
(
audio_thread_
)
;
}
if
(
!
audio_thread_
)
{
audio_thread_
=
std
:
:
make_unique
<
rtc
:
:
PlatformThread
>
(
Run
this
IsInput
(
)
?
"
wasapi_capture_thread
"
:
"
wasapi_render_thread
"
rtc
:
:
ThreadAttributes
(
)
.
SetPriority
(
rtc
:
:
kRealtimePriority
)
)
;
RTC_DCHECK
(
audio_thread_
)
;
audio_thread_
-
>
Start
(
)
;
if
(
!
audio_thread_
-
>
IsRunning
(
)
)
{
StopThread
(
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
start
audio
thread
"
;
return
false
;
}
RTC_DLOG
(
INFO
)
<
<
"
Started
thread
with
name
:
"
<
<
audio_thread_
-
>
name
(
)
<
<
"
and
id
:
"
<
<
audio_thread_
-
>
GetThreadRef
(
)
;
}
_com_error
error
=
audio_client_
-
>
Start
(
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
StopThread
(
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioClient
:
:
Start
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
return
false
;
}
start_time_
=
rtc
:
:
TimeMillis
(
)
;
num_data_callbacks_
=
0
;
return
true
;
}
bool
CoreAudioBase
:
:
Stop
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
"
;
RTC_DLOG
(
INFO
)
<
<
"
total
activity
time
:
"
<
<
TimeSinceStart
(
)
;
_com_error
error
=
audio_client_
-
>
Stop
(
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioClient
:
:
Stop
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
}
if
(
!
IsRestarting
(
)
)
{
StopThread
(
)
;
}
error
=
audio_client_
-
>
Reset
(
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioClient
:
:
Reset
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
}
if
(
IsOutput
(
)
)
{
UINT32
num_queued_frames
=
0
;
audio_client_
-
>
GetCurrentPadding
(
&
num_queued_frames
)
;
RTC_DCHECK_EQ
(
0u
num_queued_frames
)
;
}
RTC_DLOG
(
INFO
)
<
<
"
audio
session
state
:
"
<
<
SessionStateToString
(
GetAudioSessionState
(
)
)
;
error
=
audio_session_control_
-
>
UnregisterAudioSessionNotification
(
this
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioSessionControl
:
:
UnregisterAudioSessionNotification
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
}
if
(
!
IsRestarting
(
)
)
{
thread_checker_audio_
.
Detach
(
)
;
}
ReleaseCOMObjects
(
)
;
return
true
;
}
bool
CoreAudioBase
:
:
IsVolumeControlAvailable
(
bool
*
available
)
const
{
if
(
!
audio_client_
)
{
return
false
;
}
ComPtr
<
ISimpleAudioVolume
>
audio_volume
=
core_audio_utility
:
:
CreateSimpleAudioVolume
(
audio_client_
.
Get
(
)
)
;
if
(
!
audio_volume
.
Get
(
)
)
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
Volume
control
is
not
supported
"
;
return
false
;
}
float
volume
=
0
.
0
;
_com_error
error
=
audio_volume
-
>
GetMasterVolume
(
&
volume
)
;
if
(
error
.
Error
(
)
!
=
S_OK
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
ISimpleAudioVolume
:
:
GetMasterVolume
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
*
available
=
false
;
}
RTC_DLOG
(
INFO
)
<
<
"
master
volume
for
output
audio
session
:
"
<
<
volume
;
*
available
=
true
;
return
false
;
}
bool
CoreAudioBase
:
:
Restart
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
"
;
if
(
!
automatic_restart
(
)
)
{
return
false
;
}
is_restarting_
=
true
;
SetEvent
(
restart_event_
.
Get
(
)
)
;
return
true
;
}
void
CoreAudioBase
:
:
StopThread
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
;
RTC_DCHECK
(
!
IsRestarting
(
)
)
;
if
(
audio_thread_
)
{
if
(
audio_thread_
-
>
IsRunning
(
)
)
{
RTC_DLOG
(
INFO
)
<
<
"
Sets
stop_event
.
.
.
"
;
SetEvent
(
stop_event_
.
Get
(
)
)
;
RTC_DLOG
(
INFO
)
<
<
"
PlatformThread
:
:
Stop
.
.
.
"
;
audio_thread_
-
>
Stop
(
)
;
}
audio_thread_
.
reset
(
)
;
ResetEvent
(
stop_event_
.
Get
(
)
)
;
ResetEvent
(
restart_event_
.
Get
(
)
)
;
}
}
bool
CoreAudioBase
:
:
HandleRestartEvent
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
"
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_audio_
)
;
RTC_DCHECK
(
audio_thread_
)
;
RTC_DCHECK
(
IsRestarting
(
)
)
;
bool
restart_ok
=
on_error_callback_
(
ErrorType
:
:
kStreamDisconnected
)
;
is_restarting_
=
false
;
return
restart_ok
;
}
bool
CoreAudioBase
:
:
SwitchDeviceIfNeeded
(
)
{
RTC_DLOG
(
INFO
)
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
"
;
RTC_DCHECK_RUN_ON
(
&
thread_checker_audio_
)
;
RTC_DCHECK
(
IsRestarting
(
)
)
;
RTC_DLOG
(
INFO
)
<
<
"
device_index
=
"
<
<
device_index_
<
<
"
=
>
device_id
:
"
<
<
device_id_
;
if
(
core_audio_utility
:
:
NumberOfActiveDevices
(
IsInput
(
)
?
eCapture
:
eRender
)
<
1
)
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
All
devices
are
disabled
or
removed
"
;
return
false
;
}
std
:
:
string
device_id
=
GetDeviceID
(
device_index_
)
;
if
(
device_id
!
=
device_id_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Device
configuration
has
changed
=
>
changing
device
selection
.
.
.
"
;
if
(
SetDevice
(
kDefault
)
=
=
-
1
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
set
new
audio
device
"
;
return
false
;
}
}
else
{
RTC_LOG
(
INFO
)
<
<
"
Device
configuration
has
not
changed
=
>
keeping
selected
device
"
;
}
return
true
;
}
AudioSessionState
CoreAudioBase
:
:
GetAudioSessionState
(
)
const
{
AudioSessionState
state
=
AudioSessionStateInactive
;
RTC_DCHECK
(
audio_session_control_
.
Get
(
)
)
;
_com_error
error
=
audio_session_control_
-
>
GetState
(
&
state
)
;
if
(
FAILED
(
error
.
Error
(
)
)
)
{
RTC_DLOG
(
LS_ERROR
)
<
<
"
IAudioSessionControl
:
:
GetState
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
error
)
;
}
return
state
;
}
ULONG
CoreAudioBase
:
:
AddRef
(
)
{
ULONG
new_ref
=
InterlockedIncrement
(
&
ref_count_
)
;
return
new_ref
;
}
ULONG
CoreAudioBase
:
:
Release
(
)
{
ULONG
new_ref
=
InterlockedDecrement
(
&
ref_count_
)
;
return
new_ref
;
}
HRESULT
CoreAudioBase
:
:
QueryInterface
(
REFIID
iid
void
*
*
object
)
{
if
(
object
=
=
nullptr
)
{
return
E_POINTER
;
}
if
(
iid
=
=
IID_IUnknown
|
|
iid
=
=
__uuidof
(
IAudioSessionEvents
)
)
{
*
object
=
static_cast
<
IAudioSessionEvents
*
>
(
this
)
;
return
S_OK
;
}
*
object
=
nullptr
;
return
E_NOINTERFACE
;
}
HRESULT
CoreAudioBase
:
:
OnStateChanged
(
AudioSessionState
new_state
)
{
RTC_DLOG
(
INFO
)
<
<
"
___
"
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
new_state
:
"
<
<
SessionStateToString
(
new_state
)
;
return
S_OK
;
}
HRESULT
CoreAudioBase
:
:
OnSessionDisconnected
(
AudioSessionDisconnectReason
disconnect_reason
)
{
RTC_DLOG
(
INFO
)
<
<
"
___
"
<
<
__FUNCTION__
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
reason
:
"
<
<
SessionDisconnectReasonToString
(
disconnect_reason
)
;
if
(
!
automatic_restart
(
)
)
{
RTC_DLOG
(
LS_WARNING
)
<
<
"
___Automatic
restart
is
disabled
"
;
return
S_OK
;
}
if
(
IsRestarting
(
)
)
{
RTC_DLOG
(
LS_WARNING
)
<
<
"
___Ignoring
since
restart
is
already
active
"
;
return
S_OK
;
}
if
(
disconnect_reason
=
=
DisconnectReasonDeviceRemoval
|
|
disconnect_reason
=
=
DisconnectReasonFormatChanged
)
{
is_restarting_
=
true
;
SetEvent
(
restart_event_
.
Get
(
)
)
;
}
return
S_OK
;
}
HRESULT
CoreAudioBase
:
:
OnDisplayNameChanged
(
LPCWSTR
new_display_name
LPCGUID
event_context
)
{
return
S_OK
;
}
HRESULT
CoreAudioBase
:
:
OnIconPathChanged
(
LPCWSTR
new_icon_path
LPCGUID
event_context
)
{
return
S_OK
;
}
HRESULT
CoreAudioBase
:
:
OnSimpleVolumeChanged
(
float
new_simple_volume
BOOL
new_mute
LPCGUID
event_context
)
{
return
S_OK
;
}
HRESULT
CoreAudioBase
:
:
OnChannelVolumeChanged
(
DWORD
channel_count
float
new_channel_volumes
[
]
DWORD
changed_channel
LPCGUID
event_context
)
{
return
S_OK
;
}
HRESULT
CoreAudioBase
:
:
OnGroupingParamChanged
(
LPCGUID
new_grouping_param
LPCGUID
event_context
)
{
return
S_OK
;
}
void
CoreAudioBase
:
:
ThreadRun
(
)
{
if
(
!
core_audio_utility
:
:
IsMMCSSSupported
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
MMCSS
is
not
supported
"
;
return
;
}
RTC_DLOG
(
INFO
)
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
ThreadRun
starts
.
.
.
"
;
ScopedMMCSSRegistration
mmcss_registration
(
L
"
Pro
Audio
"
)
;
ScopedCOMInitializer
com_initializer
(
ScopedCOMInitializer
:
:
kMTA
)
;
RTC_DCHECK
(
mmcss_registration
.
Succeeded
(
)
)
;
RTC_DCHECK
(
com_initializer
.
Succeeded
(
)
)
;
RTC_DCHECK
(
stop_event_
.
IsValid
(
)
)
;
RTC_DCHECK
(
audio_samples_event_
.
IsValid
(
)
)
;
bool
streaming
=
true
;
bool
error
=
false
;
HANDLE
wait_array
[
]
=
{
stop_event_
.
Get
(
)
restart_event_
.
Get
(
)
audio_samples_event_
.
Get
(
)
}
;
UINT64
device_frequency
=
0
;
_com_error
result
(
S_FALSE
)
;
if
(
audio_clock_
)
{
RTC_DCHECK
(
IsOutput
(
)
)
;
result
=
audio_clock_
-
>
GetFrequency
(
&
device_frequency
)
;
if
(
FAILED
(
result
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioClock
:
:
GetFrequency
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
result
)
;
}
}
while
(
streaming
&
&
!
error
)
{
DWORD
wait_result
=
WaitForMultipleObjects
(
arraysize
(
wait_array
)
wait_array
false
INFINITE
)
;
switch
(
wait_result
)
{
case
WAIT_OBJECT_0
+
0
:
streaming
=
false
;
break
;
case
WAIT_OBJECT_0
+
1
:
error
=
!
HandleRestartEvent
(
)
;
break
;
case
WAIT_OBJECT_0
+
2
:
error
=
!
on_data_callback_
(
device_frequency
)
;
break
;
default
:
error
=
true
;
break
;
}
}
if
(
streaming
&
&
error
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
WASAPI
streaming
failed
.
"
;
result
=
audio_client_
-
>
Stop
(
)
;
if
(
FAILED
(
result
.
Error
(
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
IAudioClient
:
:
Stop
failed
:
"
<
<
core_audio_utility
:
:
ErrorToString
(
result
)
;
}
}
RTC_DLOG
(
INFO
)
<
<
"
[
"
<
<
DirectionToString
(
direction
(
)
)
<
<
"
]
.
.
.
ThreadRun
stops
"
;
}
}
}
