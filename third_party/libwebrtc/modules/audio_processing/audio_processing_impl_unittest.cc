#
include
"
modules
/
audio_processing
/
audio_processing_impl
.
h
"
#
include
<
array
>
#
include
<
memory
>
#
include
<
tuple
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
make_ref_counted
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
modules
/
audio_processing
/
optionally_built_submodule_creators
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
audio_processing_builder_for_testing
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
echo_canceller_test_tools
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
echo_control_mock
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
test_utils
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
test
/
field_trial
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NotNull
;
class
MockInitialize
:
public
AudioProcessingImpl
{
public
:
MockInitialize
(
)
:
AudioProcessingImpl
(
)
{
}
MOCK_METHOD
(
void
InitializeLocked
(
)
(
override
)
)
;
void
RealInitializeLocked
(
)
{
AssertLockedForTest
(
)
;
AudioProcessingImpl
:
:
InitializeLocked
(
)
;
}
MOCK_METHOD
(
void
AddRef
(
)
(
const
override
)
)
;
MOCK_METHOD
(
rtc
:
:
RefCountReleaseStatus
Release
(
)
(
const
override
)
)
;
}
;
class
MockEchoControlFactory
:
public
EchoControlFactory
{
public
:
MockEchoControlFactory
(
)
:
next_mock_
(
std
:
:
make_unique
<
MockEchoControl
>
(
)
)
{
}
MockEchoControl
*
GetNext
(
)
const
{
return
next_mock_
.
get
(
)
;
}
std
:
:
unique_ptr
<
EchoControl
>
Create
(
int
sample_rate_hz
int
num_render_channels
int
num_capture_channels
)
override
{
std
:
:
unique_ptr
<
EchoControl
>
mock
=
std
:
:
move
(
next_mock_
)
;
next_mock_
=
std
:
:
make_unique
<
MockEchoControl
>
(
)
;
return
mock
;
}
private
:
std
:
:
unique_ptr
<
MockEchoControl
>
next_mock_
;
}
;
class
TestEchoDetector
:
public
EchoDetector
{
public
:
TestEchoDetector
(
)
:
analyze_render_audio_called_
(
false
)
last_render_audio_first_sample_
(
0
.
f
)
{
}
~
TestEchoDetector
(
)
override
=
default
;
void
AnalyzeRenderAudio
(
rtc
:
:
ArrayView
<
const
float
>
render_audio
)
override
{
last_render_audio_first_sample_
=
render_audio
[
0
]
;
analyze_render_audio_called_
=
true
;
}
void
AnalyzeCaptureAudio
(
rtc
:
:
ArrayView
<
const
float
>
capture_audio
)
override
{
}
void
Initialize
(
int
capture_sample_rate_hz
int
num_capture_channels
int
render_sample_rate_hz
int
num_render_channels
)
override
{
}
EchoDetector
:
:
Metrics
GetMetrics
(
)
const
override
{
return
{
}
;
}
bool
analyze_render_audio_called
(
)
const
{
return
analyze_render_audio_called_
;
}
float
last_render_audio_first_sample
(
)
const
{
return
last_render_audio_first_sample_
;
}
private
:
bool
analyze_render_audio_called_
;
float
last_render_audio_first_sample_
;
}
;
class
TestRenderPreProcessor
:
public
CustomProcessing
{
public
:
TestRenderPreProcessor
(
)
=
default
;
~
TestRenderPreProcessor
(
)
=
default
;
void
Initialize
(
int
sample_rate_hz
int
num_channels
)
override
{
}
void
Process
(
AudioBuffer
*
audio
)
override
{
for
(
size_t
k
=
0
;
k
<
audio
-
>
num_channels
(
)
;
+
+
k
)
{
rtc
:
:
ArrayView
<
float
>
channel_view
(
audio
-
>
channels
(
)
[
k
]
audio
-
>
num_frames
(
)
)
;
std
:
:
transform
(
channel_view
.
begin
(
)
channel_view
.
end
(
)
channel_view
.
begin
(
)
ProcessSample
)
;
}
}
std
:
:
string
ToString
(
)
const
override
{
return
"
TestRenderPreProcessor
"
;
}
void
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
setting
)
override
{
}
static
constexpr
float
ProcessSample
(
float
x
)
{
return
2
.
f
*
x
;
}
}
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
CreateApmForInputVolumeTest
(
bool
agc1_analog_gain_controller_enabled
bool
agc2_input_volume_controller_enabled
)
{
webrtc
:
:
AudioProcessing
:
:
Config
config
;
config
.
gain_controller1
.
enabled
=
agc1_analog_gain_controller_enabled
;
config
.
gain_controller1
.
analog_gain_controller
.
enabled
=
agc1_analog_gain_controller_enabled
;
config
.
gain_controller2
.
input_volume_controller
.
enabled
=
agc2_input_volume_controller_enabled
;
config
.
gain_controller1
.
analog_gain_controller
.
enable_digital_adaptive
=
false
;
config
.
gain_controller2
.
enabled
=
true
;
config
.
gain_controller2
.
adaptive_digital
.
enabled
=
true
;
auto
apm
(
AudioProcessingBuilder
(
)
.
Create
(
)
)
;
apm
-
>
ApplyConfig
(
config
)
;
return
apm
;
}
int
ProcessInputVolume
(
AudioProcessing
&
apm
int
num_frames
int
initial_volume
)
{
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
int
recommended_input_volume
=
initial_volume
;
for
(
int
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
Random
random_generator
(
2341U
)
;
RandomizeSampleVector
(
&
random_generator
buffer
)
;
apm
.
set_stream_analog_level
(
recommended_input_volume
)
;
apm
.
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
;
recommended_input_volume
=
apm
.
recommended_stream_analog_level
(
)
;
}
return
recommended_input_volume
;
}
constexpr
char
kMinMicLevelFieldTrial
[
]
=
"
WebRTC
-
Audio
-
2ndAgcMinMicLevelExperiment
"
;
constexpr
char
kMinInputVolumeFieldTrial
[
]
=
"
WebRTC
-
Audio
-
Agc2
-
MinInputVolume
"
;
constexpr
int
kMinInputVolume
=
12
;
std
:
:
string
GetMinMicLevelExperimentFieldTrial
(
absl
:
:
optional
<
int
>
value
)
{
char
field_trial_buffer
[
128
]
;
rtc
:
:
SimpleStringBuilder
builder
(
field_trial_buffer
)
;
if
(
value
.
has_value
(
)
)
{
RTC_DCHECK_GE
(
*
value
0
)
;
RTC_DCHECK_LE
(
*
value
255
)
;
builder
<
<
kMinMicLevelFieldTrial
<
<
"
/
Enabled
-
"
<
<
*
value
<
<
"
/
"
;
builder
<
<
kMinInputVolumeFieldTrial
<
<
"
/
Enabled
-
"
<
<
*
value
<
<
"
/
"
;
}
else
{
builder
<
<
kMinMicLevelFieldTrial
<
<
"
/
Disabled
/
"
;
builder
<
<
kMinInputVolumeFieldTrial
<
<
"
/
Disabled
/
"
;
}
return
builder
.
str
(
)
;
}
class
InputVolumeStartupParameterizedTest
:
public
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
int
absl
:
:
optional
<
int
>
bool
bool
>
>
{
protected
:
InputVolumeStartupParameterizedTest
(
)
:
field_trials_
(
GetMinMicLevelExperimentFieldTrial
(
std
:
:
get
<
1
>
(
GetParam
(
)
)
)
)
{
}
int
GetStartupVolume
(
)
const
{
return
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
}
int
GetMinVolume
(
)
const
{
return
std
:
:
get
<
1
>
(
GetParam
(
)
)
.
value_or
(
kMinInputVolume
)
;
}
bool
GetAgc1AnalogControllerEnabled
(
)
const
{
return
std
:
:
get
<
2
>
(
GetParam
(
)
)
;
}
bool
GetAgc2InputVolumeControllerEnabled
(
)
const
{
return
std
:
:
get
<
3
>
(
GetParam
(
)
)
;
}
private
:
test
:
:
ScopedFieldTrials
field_trials_
;
}
;
class
InputVolumeNotZeroParameterizedTest
:
public
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
int
int
absl
:
:
optional
<
int
>
bool
bool
>
>
{
protected
:
InputVolumeNotZeroParameterizedTest
(
)
:
field_trials_
(
GetMinMicLevelExperimentFieldTrial
(
std
:
:
get
<
2
>
(
GetParam
(
)
)
)
)
{
}
int
GetStartupVolume
(
)
const
{
return
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
}
int
GetVolume
(
)
const
{
return
std
:
:
get
<
1
>
(
GetParam
(
)
)
;
}
int
GetMinVolume
(
)
const
{
return
std
:
:
get
<
2
>
(
GetParam
(
)
)
.
value_or
(
kMinInputVolume
)
;
}
bool
GetMinMicLevelExperimentEnabled
(
)
{
return
std
:
:
get
<
2
>
(
GetParam
(
)
)
.
has_value
(
)
;
}
bool
GetAgc1AnalogControllerEnabled
(
)
const
{
return
std
:
:
get
<
3
>
(
GetParam
(
)
)
;
}
bool
GetAgc2InputVolumeControllerEnabled
(
)
const
{
return
std
:
:
get
<
4
>
(
GetParam
(
)
)
;
}
private
:
test
:
:
ScopedFieldTrials
field_trials_
;
}
;
class
InputVolumeZeroParameterizedTest
:
public
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
int
absl
:
:
optional
<
int
>
bool
bool
>
>
{
protected
:
InputVolumeZeroParameterizedTest
(
)
:
field_trials_
(
GetMinMicLevelExperimentFieldTrial
(
std
:
:
get
<
1
>
(
GetParam
(
)
)
)
)
{
}
int
GetStartupVolume
(
)
const
{
return
std
:
:
get
<
0
>
(
GetParam
(
)
)
;
}
int
GetMinVolume
(
)
const
{
return
std
:
:
get
<
1
>
(
GetParam
(
)
)
.
value_or
(
kMinInputVolume
)
;
}
bool
GetAgc1AnalogControllerEnabled
(
)
const
{
return
std
:
:
get
<
2
>
(
GetParam
(
)
)
;
}
bool
GetAgc2InputVolumeControllerEnabled
(
)
const
{
return
std
:
:
get
<
3
>
(
GetParam
(
)
)
;
}
private
:
test
:
:
ScopedFieldTrials
field_trials_
;
}
;
}
TEST
(
AudioProcessingImplTest
AudioParameterChangeTriggersInit
)
{
MockInitialize
mock
;
ON_CALL
(
mock
InitializeLocked
)
.
WillByDefault
(
Invoke
(
&
mock
&
MockInitialize
:
:
RealInitializeLocked
)
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
1
)
;
mock
.
Initialize
(
)
;
constexpr
size_t
kMaxSampleRateHz
=
32000
;
constexpr
size_t
kMaxNumChannels
=
2
;
std
:
:
array
<
int16_t
kMaxNumChannels
*
kMaxSampleRateHz
/
100
>
frame
;
frame
.
fill
(
0
)
;
StreamConfig
config
(
16000
1
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
0
)
;
EXPECT_NOERR
(
mock
.
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
EXPECT_NOERR
(
mock
.
ProcessReverseStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
config
=
StreamConfig
(
32000
1
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
1
)
;
EXPECT_NOERR
(
mock
.
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
config
=
StreamConfig
(
32000
2
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
2
)
;
EXPECT_NOERR
(
mock
.
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
EXPECT_NOERR
(
mock
.
ProcessReverseStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
config
=
StreamConfig
(
16000
2
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
1
)
;
EXPECT_NOERR
(
mock
.
ProcessReverseStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
}
TEST
(
AudioProcessingImplTest
UpdateCapturePreGainRuntimeSetting
)
{
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
pre_amplifier
.
enabled
=
true
;
apm_config
.
pre_amplifier
.
fixed_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_EQ
(
frame
[
100
]
kAudioLevel
)
<
<
"
With
factor
1
frame
shouldn
'
t
be
modified
.
"
;
constexpr
float
kGainFactor
=
2
.
f
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
kGainFactor
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
EXPECT_EQ
(
frame
[
100
]
kGainFactor
*
kAudioLevel
)
<
<
"
Frame
should
be
amplified
.
"
;
}
TEST
(
AudioProcessingImplTest
LevelAdjustmentUpdateCapturePreGainRuntimeSetting
)
{
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
capture_level_adjustment
.
enabled
=
true
;
apm_config
.
capture_level_adjustment
.
pre_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_EQ
(
frame
[
100
]
kAudioLevel
)
<
<
"
With
factor
1
frame
shouldn
'
t
be
modified
.
"
;
constexpr
float
kGainFactor
=
2
.
f
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
kGainFactor
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
EXPECT_EQ
(
frame
[
100
]
kGainFactor
*
kAudioLevel
)
<
<
"
Frame
should
be
amplified
.
"
;
}
TEST
(
AudioProcessingImplTest
LevelAdjustmentUpdateCapturePostGainRuntimeSetting
)
{
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
capture_level_adjustment
.
enabled
=
true
;
apm_config
.
capture_level_adjustment
.
post_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_EQ
(
frame
[
100
]
kAudioLevel
)
<
<
"
With
factor
1
frame
shouldn
'
t
be
modified
.
"
;
constexpr
float
kGainFactor
=
2
.
f
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePostGain
(
kGainFactor
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
EXPECT_EQ
(
frame
[
100
]
kGainFactor
*
kAudioLevel
)
<
<
"
Frame
should
be
amplified
.
"
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesSetCaptureUsageChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
MockEchoControlFactory
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Create
(
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
testing
:
:
_
)
)
.
Times
(
0
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
false
)
)
.
Times
(
1
)
;
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
true
)
)
.
Times
(
1
)
;
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
true
)
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
constexpr
int
kNumSlotsInQueue
=
RuntimeSettingQueueSize
(
)
;
for
(
int
k
=
0
;
k
<
kNumSlotsInQueue
-
1
;
+
+
k
)
{
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
}
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
false
)
)
.
Times
(
kNumSlotsInQueue
-
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
for
(
int
k
=
0
;
k
<
kNumSlotsInQueue
;
+
+
k
)
{
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
}
EXPECT_FALSE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
EXPECT_FALSE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
false
)
)
.
Times
(
kNumSlotsInQueue
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
true
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesPreAmplifierEchoPathGainChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm_config
.
pre_amplifier
.
enabled
=
true
;
apm_config
.
pre_amplifier
.
fixed_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
2
.
f
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesLevelAdjustmentPreGainEchoPathGainChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm_config
.
capture_level_adjustment
.
enabled
=
true
;
apm_config
.
capture_level_adjustment
.
pre_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
2
.
f
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesAnalogAgc1EchoPathGainChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
true
;
apm_config
.
gain_controller1
.
analog_gain_controller
.
enabled
=
true
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm_config
.
pre_amplifier
.
enabled
=
false
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
1000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
constexpr
int
kInitialStreamAnalogLevel
=
123
;
apm
-
>
set_stream_analog_level
(
kInitialStreamAnalogLevel
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
int
recommended_analog_level
=
apm
-
>
recommended_stream_analog_level
(
)
;
if
(
recommended_analog_level
=
=
kInitialStreamAnalogLevel
)
{
recommended_analog_level
+
+
;
}
apm
-
>
set_stream_analog_level
(
recommended_analog_level
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
ProcessWithAgc2AndTransientSuppressorVadModeDefault
)
{
webrtc
:
:
test
:
:
ScopedFieldTrials
field_trials
(
"
WebRTC
-
Audio
-
TransientSuppressorVadMode
/
Enabled
-
Default
/
"
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilder
(
)
.
Create
(
)
;
ASSERT_EQ
(
apm
-
>
Initialize
(
)
AudioProcessing
:
:
kNoError
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
true
;
apm_config
.
gain_controller2
.
adaptive_digital
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcess
=
10
;
for
(
int
i
=
0
;
i
<
kFramesToProcess
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
ASSERT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
}
}
TEST
(
AudioProcessingImplTest
ProcessWithAgc2AndTransientSuppressorVadModeRnnVad
)
{
webrtc
:
:
test
:
:
ScopedFieldTrials
field_trials
(
"
WebRTC
-
Audio
-
TransientSuppressorVadMode
/
Enabled
-
RnnVad
/
"
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilder
(
)
.
Create
(
)
;
ASSERT_EQ
(
apm
-
>
Initialize
(
)
AudioProcessing
:
:
kNoError
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
true
;
apm_config
.
gain_controller2
.
adaptive_digital
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcess
=
10
;
for
(
int
i
=
0
;
i
<
kFramesToProcess
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
ASSERT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
}
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesPlayoutVolumeChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreatePlayoutVolumeChange
(
50
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreatePlayoutVolumeChange
(
50
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreatePlayoutVolumeChange
(
100
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
RenderPreProcessorBeforeEchoDetector
)
{
auto
test_echo_detector
=
rtc
:
:
make_ref_counted
<
TestEchoDetector
>
(
)
;
std
:
:
unique_ptr
<
CustomProcessing
>
test_render_pre_processor
(
new
TestRenderPreProcessor
(
)
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm
=
AudioProcessingBuilderForTesting
(
)
.
SetEchoDetector
(
test_echo_detector
)
.
SetRenderPreProcessing
(
std
:
:
move
(
test_render_pre_processor
)
)
.
Create
(
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
pre_amplifier
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
1000
;
constexpr
int
kSampleRateHz
=
16000
;
constexpr
size_t
kNumChannels
=
1
;
const
ProcessingConfig
processing_config
=
{
{
{
kSampleRateHz
kNumChannels
}
{
kSampleRateHz
kNumChannels
}
{
kSampleRateHz
kNumChannels
}
{
kSampleRateHz
kNumChannels
}
}
}
;
apm
-
>
Initialize
(
processing_config
)
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
constexpr
float
kAudioLevelFloat
=
static_cast
<
float
>
(
kAudioLevel
)
;
constexpr
float
kExpectedPreprocessedAudioLevel
=
TestRenderPreProcessor
:
:
ProcessSample
(
kAudioLevelFloat
)
;
ASSERT_NE
(
kAudioLevelFloat
kExpectedPreprocessedAudioLevel
)
;
frame
.
fill
(
kAudioLevel
)
;
ASSERT_EQ
(
AudioProcessing
:
:
Error
:
:
kNoError
apm
-
>
ProcessReverseStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
)
;
frame
.
fill
(
kAudioLevel
)
;
ASSERT_EQ
(
AudioProcessing
:
:
Error
:
:
kNoError
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
)
;
ASSERT_TRUE
(
test_echo_detector
-
>
analyze_render_audio_called
(
)
)
;
EXPECT_EQ
(
kExpectedPreprocessedAudioLevel
test_echo_detector
-
>
last_render_audio_first_sample
(
)
)
;
}
TEST
(
ApmWithSubmodulesExcludedTest
BitexactWithDisabledModules
)
{
auto
apm
=
rtc
:
:
make_ref_counted
<
AudioProcessingImpl
>
(
)
;
ASSERT_EQ
(
apm
-
>
Initialize
(
)
AudioProcessing
:
:
kNoError
)
;
ApmSubmoduleCreationOverrides
overrides
;
overrides
.
transient_suppression
=
true
;
apm
-
>
OverrideSubmoduleCreationForTesting
(
overrides
)
;
AudioProcessing
:
:
Config
apm_config
=
apm
-
>
GetConfig
(
)
;
apm_config
.
transient_suppression
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
apm_config
)
;
rtc
:
:
scoped_refptr
<
AudioProcessing
>
apm_reference
=
AudioProcessingBuilder
(
)
.
Create
(
)
;
apm_config
=
apm_reference
-
>
GetConfig
(
)
;
apm_config
.
transient_suppression
.
enabled
=
false
;
apm_reference
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
16000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer_reference
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
float
*
channel_pointers_reference
[
]
=
{
buffer_reference
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcessPerConfiguration
=
10
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
std
:
:
copy
(
buffer
.
begin
(
)
buffer
.
end
(
)
buffer_reference
.
begin
(
)
)
;
ASSERT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
ASSERT_EQ
(
apm_reference
-
>
ProcessStream
(
channel_pointers_reference
stream_config
stream_config
channel_pointers_reference
)
kNoErr
)
;
for
(
int
j
=
0
;
j
<
kSampleRateHz
/
100
;
+
+
j
)
{
EXPECT_EQ
(
buffer
[
j
]
buffer_reference
[
j
]
)
;
}
}
}
TEST
(
ApmWithSubmodulesExcludedTest
ReinitializeTransientSuppressor
)
{
auto
apm
=
rtc
:
:
make_ref_counted
<
AudioProcessingImpl
>
(
)
;
ASSERT_EQ
(
apm
-
>
Initialize
(
)
kNoErr
)
;
ApmSubmoduleCreationOverrides
overrides
;
overrides
.
transient_suppression
=
true
;
apm
-
>
OverrideSubmoduleCreationForTesting
(
overrides
)
;
AudioProcessing
:
:
Config
config
=
apm
-
>
GetConfig
(
)
;
config
.
transient_suppression
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
config
)
;
float
buffer
[
960
]
;
float
*
channel_pointers
[
]
=
{
&
buffer
[
0
]
&
buffer
[
480
]
}
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcessPerConfiguration
=
3
;
StreamConfig
initial_stream_config
(
16000
1
)
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
EXPECT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
initial_stream_config
initial_stream_config
channel_pointers
)
kNoErr
)
;
}
StreamConfig
stereo_stream_config
(
16000
2
)
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
EXPECT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stereo_stream_config
stereo_stream_config
channel_pointers
)
kNoErr
)
;
}
StreamConfig
high_sample_rate_stream_config
(
48000
2
)
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
EXPECT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
high_sample_rate_stream_config
high_sample_rate_stream_config
channel_pointers
)
kNoErr
)
;
}
}
TEST
(
ApmWithSubmodulesExcludedTest
ToggleTransientSuppressor
)
{
auto
apm
=
rtc
:
:
make_ref_counted
<
AudioProcessingImpl
>
(
)
;
ASSERT_EQ
(
apm
-
>
Initialize
(
)
AudioProcessing
:
:
kNoError
)
;
ApmSubmoduleCreationOverrides
overrides
;
overrides
.
transient_suppression
=
true
;
apm
-
>
OverrideSubmoduleCreationForTesting
(
overrides
)
;
float
buffer
[
960
]
;
float
*
channel_pointers
[
]
=
{
&
buffer
[
0
]
&
buffer
[
480
]
}
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcessPerConfiguration
=
3
;
StreamConfig
stream_config
(
16000
1
)
;
AudioProcessing
:
:
Config
config
=
apm
-
>
GetConfig
(
)
;
config
.
transient_suppression
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
config
)
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
EXPECT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
}
config
=
apm
-
>
GetConfig
(
)
;
config
.
transient_suppression
.
enabled
=
false
;
apm
-
>
ApplyConfig
(
config
)
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
EXPECT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
}
config
=
apm
-
>
GetConfig
(
)
;
config
.
transient_suppression
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
config
)
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
EXPECT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
}
}
TEST_P
(
InputVolumeStartupParameterizedTest
VerifyStartupMinVolumeAppliedAtStartup
)
{
const
int
applied_startup_input_volume
=
GetStartupVolume
(
)
;
const
int
expected_volume
=
std
:
:
max
(
applied_startup_input_volume
GetMinVolume
(
)
)
;
const
bool
agc1_analog_controller_enabled
=
GetAgc1AnalogControllerEnabled
(
)
;
const
bool
agc2_input_volume_controller_enabled
=
GetAgc2InputVolumeControllerEnabled
(
)
;
auto
apm
=
CreateApmForInputVolumeTest
(
agc1_analog_controller_enabled
agc2_input_volume_controller_enabled
)
;
const
int
recommended_input_volume
=
ProcessInputVolume
(
*
apm
1
applied_startup_input_volume
)
;
if
(
!
agc1_analog_controller_enabled
&
&
!
agc2_input_volume_controller_enabled
)
{
ASSERT_EQ
(
recommended_input_volume
applied_startup_input_volume
)
;
}
else
{
ASSERT_EQ
(
recommended_input_volume
expected_volume
)
;
}
}
TEST_P
(
InputVolumeNotZeroParameterizedTest
VerifyMinVolumeMaybeAppliedAfterManualVolumeAdjustments
)
{
const
int
applied_startup_input_volume
=
GetStartupVolume
(
)
;
const
int
applied_input_volume
=
GetVolume
(
)
;
const
int
expected_volume
=
std
:
:
max
(
applied_input_volume
GetMinVolume
(
)
)
;
const
bool
agc1_analog_controller_enabled
=
GetAgc1AnalogControllerEnabled
(
)
;
const
bool
agc2_input_volume_controller_enabled
=
GetAgc2InputVolumeControllerEnabled
(
)
;
auto
apm
=
CreateApmForInputVolumeTest
(
agc1_analog_controller_enabled
agc2_input_volume_controller_enabled
)
;
ProcessInputVolume
(
*
apm
1
applied_startup_input_volume
)
;
const
int
recommended_input_volume
=
ProcessInputVolume
(
*
apm
1
applied_input_volume
)
;
ASSERT_NE
(
applied_input_volume
0
)
;
if
(
!
agc1_analog_controller_enabled
&
&
!
agc2_input_volume_controller_enabled
)
{
ASSERT_EQ
(
recommended_input_volume
applied_input_volume
)
;
}
else
{
if
(
GetMinMicLevelExperimentEnabled
(
)
|
|
(
!
agc1_analog_controller_enabled
&
&
agc2_input_volume_controller_enabled
)
)
{
ASSERT_EQ
(
recommended_input_volume
expected_volume
)
;
}
else
{
ASSERT_EQ
(
recommended_input_volume
applied_input_volume
)
;
}
}
}
TEST_P
(
InputVolumeZeroParameterizedTest
VerifyMinVolumeNotAppliedAfterManualVolumeAdjustments
)
{
constexpr
int
kZeroVolume
=
0
;
const
int
applied_startup_input_volume
=
GetStartupVolume
(
)
;
const
bool
agc1_analog_controller_enabled
=
GetAgc1AnalogControllerEnabled
(
)
;
const
bool
agc2_input_volume_controller_enabled
=
GetAgc2InputVolumeControllerEnabled
(
)
;
auto
apm
=
CreateApmForInputVolumeTest
(
agc1_analog_controller_enabled
agc2_input_volume_controller_enabled
)
;
const
int
recommended_input_volume_after_startup
=
ProcessInputVolume
(
*
apm
1
applied_startup_input_volume
)
;
const
int
recommended_input_volume
=
ProcessInputVolume
(
*
apm
1
kZeroVolume
)
;
if
(
!
agc1_analog_controller_enabled
&
&
!
agc2_input_volume_controller_enabled
)
{
ASSERT_EQ
(
recommended_input_volume
kZeroVolume
)
;
}
else
{
ASSERT_NE
(
recommended_input_volume
recommended_input_volume_after_startup
)
;
ASSERT_EQ
(
recommended_input_volume
kZeroVolume
)
;
}
}
TEST_P
(
InputVolumeNotZeroParameterizedTest
VerifyMinVolumeAppliedAfterAutomaticVolumeAdjustments
)
{
const
int
applied_startup_input_volume
=
GetStartupVolume
(
)
;
const
int
applied_input_volume
=
GetVolume
(
)
;
const
bool
agc1_analog_controller_enabled
=
GetAgc1AnalogControllerEnabled
(
)
;
const
bool
agc2_input_volume_controller_enabled
=
GetAgc2InputVolumeControllerEnabled
(
)
;
auto
apm
=
CreateApmForInputVolumeTest
(
agc1_analog_controller_enabled
agc2_input_volume_controller_enabled
)
;
ProcessInputVolume
(
*
apm
1
applied_startup_input_volume
)
;
const
int
recommended_input_volume
=
ProcessInputVolume
(
*
apm
400
applied_input_volume
)
;
ASSERT_NE
(
applied_input_volume
0
)
;
if
(
!
agc1_analog_controller_enabled
&
&
!
agc2_input_volume_controller_enabled
)
{
ASSERT_EQ
(
recommended_input_volume
applied_input_volume
)
;
}
else
{
if
(
recommended_input_volume
!
=
applied_input_volume
)
{
ASSERT_GE
(
recommended_input_volume
GetMinVolume
(
)
)
;
}
}
}
TEST_P
(
InputVolumeZeroParameterizedTest
VerifyMinVolumeNotAppliedAfterAutomaticVolumeAdjustments
)
{
constexpr
int
kZeroVolume
=
0
;
const
int
applied_startup_input_volume
=
GetStartupVolume
(
)
;
const
bool
agc1_analog_controller_enabled
=
GetAgc1AnalogControllerEnabled
(
)
;
const
bool
agc2_input_volume_controller_enabled
=
GetAgc2InputVolumeControllerEnabled
(
)
;
auto
apm
=
CreateApmForInputVolumeTest
(
agc1_analog_controller_enabled
agc2_input_volume_controller_enabled
)
;
const
int
recommended_input_volume_after_startup
=
ProcessInputVolume
(
*
apm
1
applied_startup_input_volume
)
;
const
int
recommended_input_volume
=
ProcessInputVolume
(
*
apm
400
kZeroVolume
)
;
if
(
!
agc1_analog_controller_enabled
&
&
!
agc2_input_volume_controller_enabled
)
{
ASSERT_EQ
(
recommended_input_volume
kZeroVolume
)
;
}
else
{
ASSERT_NE
(
recommended_input_volume
recommended_input_volume_after_startup
)
;
ASSERT_EQ
(
recommended_input_volume
kZeroVolume
)
;
}
}
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingImplTest
InputVolumeStartupParameterizedTest
:
:
testing
:
:
Combine
(
:
:
testing
:
:
Values
(
0
5
30
)
:
:
testing
:
:
Values
(
absl
:
:
nullopt
20
)
:
:
testing
:
:
Bool
(
)
:
:
testing
:
:
Bool
(
)
)
)
;
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingImplTest
InputVolumeNotZeroParameterizedTest
:
:
testing
:
:
Combine
(
:
:
testing
:
:
Values
(
0
5
15
)
:
:
testing
:
:
Values
(
1
5
30
)
:
:
testing
:
:
Values
(
absl
:
:
nullopt
20
)
:
:
testing
:
:
Bool
(
)
:
:
testing
:
:
Bool
(
)
)
)
;
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingImplTest
InputVolumeZeroParameterizedTest
:
:
testing
:
:
Combine
(
:
:
testing
:
:
Values
(
0
5
15
)
:
:
testing
:
:
Values
(
absl
:
:
nullopt
20
)
:
:
testing
:
:
Bool
(
)
:
:
testing
:
:
Bool
(
)
)
)
;
TEST
(
AudioProcessingImplTest
RecommendAppliedInputVolumeWithNoAgcWithNoEmulation
)
{
auto
apm
=
AudioProcessingBuilder
(
)
.
SetConfig
(
{
.
capture_level_adjustment
=
{
.
enabled
=
false
}
.
gain_controller1
=
{
.
enabled
=
false
}
}
)
.
Create
(
)
;
constexpr
int
kOneFrame
=
1
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
123
)
123
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
59
)
59
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
135
)
135
)
;
}
TEST
(
AudioProcessingImplTest
DISABLED_RecommendAppliedInputVolumeWithNoAgcWithEmulation
)
{
auto
apm
=
AudioProcessingBuilder
(
)
.
SetConfig
(
{
.
capture_level_adjustment
=
{
.
enabled
=
true
.
analog_mic_gain_emulation
{
.
enabled
=
true
.
initial_level
=
255
}
}
.
gain_controller1
=
{
.
enabled
=
false
}
}
)
.
Create
(
)
;
constexpr
int
kOneFrame
=
1
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
123
)
123
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
59
)
59
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
135
)
135
)
;
}
TEST
(
AudioProcessingImplTest
DISABLED_RecommendAppliedInputVolumeWithAgcWithEmulation
)
{
auto
apm
=
AudioProcessingBuilder
(
)
.
SetConfig
(
{
.
capture_level_adjustment
=
{
.
enabled
=
true
.
analog_mic_gain_emulation
{
.
enabled
=
true
}
}
.
gain_controller1
=
{
.
enabled
=
true
.
analog_gain_controller
{
.
enabled
=
true
}
}
}
)
.
Create
(
)
;
constexpr
int
kOneFrame
=
1
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
123
)
123
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
59
)
59
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
135
)
135
)
;
}
}
