#
include
"
modules
/
audio_processing
/
audio_processing_impl
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
tuple
>
#
include
"
api
/
audio
/
audio_processing
.
h
"
#
include
"
api
/
audio
/
builtin_audio_processing_builder
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
make_ref_counted
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
echo_canceller_test_tools
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
echo_control_mock
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
test_utils
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
test
/
field_trial
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NotNull
;
class
MockInitialize
:
public
AudioProcessingImpl
{
public
:
MockInitialize
(
)
:
AudioProcessingImpl
(
CreateEnvironment
(
)
)
{
}
MOCK_METHOD
(
void
InitializeLocked
(
)
(
override
)
)
;
void
RealInitializeLocked
(
)
{
AssertLockedForTest
(
)
;
AudioProcessingImpl
:
:
InitializeLocked
(
)
;
}
MOCK_METHOD
(
void
AddRef
(
)
(
const
override
)
)
;
MOCK_METHOD
(
RefCountReleaseStatus
Release
(
)
(
const
override
)
)
;
}
;
class
MockEchoControlFactory
:
public
EchoControlFactory
{
public
:
MockEchoControlFactory
(
)
:
next_mock_
(
std
:
:
make_unique
<
MockEchoControl
>
(
)
)
{
}
MockEchoControl
*
GetNext
(
)
const
{
return
next_mock_
.
get
(
)
;
}
std
:
:
unique_ptr
<
EchoControl
>
Create
(
const
Environment
&
int
int
int
)
override
{
std
:
:
unique_ptr
<
EchoControl
>
mock
=
std
:
:
move
(
next_mock_
)
;
next_mock_
=
std
:
:
make_unique
<
MockEchoControl
>
(
)
;
return
mock
;
}
private
:
std
:
:
unique_ptr
<
MockEchoControl
>
next_mock_
;
}
;
class
TestEchoDetector
:
public
EchoDetector
{
public
:
TestEchoDetector
(
)
:
analyze_render_audio_called_
(
false
)
last_render_audio_first_sample_
(
0
.
f
)
{
}
~
TestEchoDetector
(
)
override
=
default
;
void
AnalyzeRenderAudio
(
ArrayView
<
const
float
>
render_audio
)
override
{
last_render_audio_first_sample_
=
render_audio
[
0
]
;
analyze_render_audio_called_
=
true
;
}
void
AnalyzeCaptureAudio
(
ArrayView
<
const
float
>
)
override
{
}
void
Initialize
(
int
int
int
int
)
override
{
}
EchoDetector
:
:
Metrics
GetMetrics
(
)
const
override
{
return
{
}
;
}
bool
analyze_render_audio_called
(
)
const
{
return
analyze_render_audio_called_
;
}
float
last_render_audio_first_sample
(
)
const
{
return
last_render_audio_first_sample_
;
}
private
:
bool
analyze_render_audio_called_
;
float
last_render_audio_first_sample_
;
}
;
class
TestRenderPreProcessor
:
public
CustomProcessing
{
public
:
TestRenderPreProcessor
(
)
=
default
;
~
TestRenderPreProcessor
(
)
=
default
;
void
Initialize
(
int
int
)
override
{
}
void
Process
(
AudioBuffer
*
audio
)
override
{
for
(
size_t
k
=
0
;
k
<
audio
-
>
num_channels
(
)
;
+
+
k
)
{
ArrayView
<
float
>
channel_view
(
audio
-
>
channels
(
)
[
k
]
audio
-
>
num_frames
(
)
)
;
std
:
:
transform
(
channel_view
.
begin
(
)
channel_view
.
end
(
)
channel_view
.
begin
(
)
ProcessSample
)
;
}
}
std
:
:
string
ToString
(
)
const
override
{
return
"
TestRenderPreProcessor
"
;
}
void
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
)
override
{
}
static
constexpr
float
ProcessSample
(
float
x
)
{
return
2
.
f
*
x
;
}
}
;
int
ProcessInputVolume
(
AudioProcessing
&
apm
int
num_frames
int
initial_volume
)
{
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
int
recommended_input_volume
=
initial_volume
;
for
(
int
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
Random
random_generator
(
2341U
)
;
RandomizeSampleVector
(
&
random_generator
buffer
)
;
apm
.
set_stream_analog_level
(
recommended_input_volume
)
;
apm
.
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
;
recommended_input_volume
=
apm
.
recommended_stream_analog_level
(
)
;
}
return
recommended_input_volume
;
}
}
TEST
(
AudioProcessingImplTest
AudioParameterChangeTriggersInit
)
{
MockInitialize
mock
;
ON_CALL
(
mock
InitializeLocked
)
.
WillByDefault
(
Invoke
(
&
mock
&
MockInitialize
:
:
RealInitializeLocked
)
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
1
)
;
mock
.
Initialize
(
)
;
constexpr
size_t
kMaxTestedSampleRateHz
=
32000
;
constexpr
size_t
kMaxTestedNumChannels
=
2
;
std
:
:
array
<
int16_t
kMaxTestedNumChannels
*
kMaxTestedSampleRateHz
/
100
>
frame
;
frame
.
fill
(
0
)
;
StreamConfig
config
(
16000
1
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
0
)
;
EXPECT_NOERR
(
mock
.
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
EXPECT_NOERR
(
mock
.
ProcessReverseStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
config
=
StreamConfig
(
32000
1
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
1
)
;
EXPECT_NOERR
(
mock
.
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
config
=
StreamConfig
(
32000
2
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
2
)
;
EXPECT_NOERR
(
mock
.
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
EXPECT_NOERR
(
mock
.
ProcessReverseStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
config
=
StreamConfig
(
16000
2
)
;
EXPECT_CALL
(
mock
InitializeLocked
)
.
Times
(
1
)
;
EXPECT_NOERR
(
mock
.
ProcessReverseStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
)
;
}
TEST
(
AudioProcessingImplTest
UpdateCapturePreGainRuntimeSetting
)
{
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
pre_amplifier
.
enabled
=
true
;
apm_config
.
pre_amplifier
.
fixed_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_EQ
(
frame
[
100
]
kAudioLevel
)
<
<
"
With
factor
1
frame
shouldn
'
t
be
modified
.
"
;
constexpr
float
kGainFactor
=
2
.
f
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
kGainFactor
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
EXPECT_EQ
(
frame
[
100
]
kGainFactor
*
kAudioLevel
)
<
<
"
Frame
should
be
amplified
.
"
;
}
TEST
(
AudioProcessingImplTest
LevelAdjustmentUpdateCapturePreGainRuntimeSetting
)
{
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
capture_level_adjustment
.
enabled
=
true
;
apm_config
.
capture_level_adjustment
.
pre_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_EQ
(
frame
[
100
]
kAudioLevel
)
<
<
"
With
factor
1
frame
shouldn
'
t
be
modified
.
"
;
constexpr
float
kGainFactor
=
2
.
f
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
kGainFactor
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
EXPECT_EQ
(
frame
[
100
]
kGainFactor
*
kAudioLevel
)
<
<
"
Frame
should
be
amplified
.
"
;
}
TEST
(
AudioProcessingImplTest
LevelAdjustmentUpdateCapturePostGainRuntimeSetting
)
{
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
capture_level_adjustment
.
enabled
=
true
;
apm_config
.
capture_level_adjustment
.
post_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_EQ
(
frame
[
100
]
kAudioLevel
)
<
<
"
With
factor
1
frame
shouldn
'
t
be
modified
.
"
;
constexpr
float
kGainFactor
=
2
.
f
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePostGain
(
kGainFactor
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
frame
.
fill
(
kAudioLevel
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
EXPECT_EQ
(
frame
[
100
]
kGainFactor
*
kAudioLevel
)
<
<
"
Frame
should
be
amplified
.
"
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesSetCaptureUsageChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
MockEchoControlFactory
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
testing
:
:
_
)
)
.
Times
(
0
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
false
)
)
.
Times
(
1
)
;
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
true
)
)
.
Times
(
1
)
;
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
true
)
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
constexpr
int
kNumSlotsInQueue
=
RuntimeSettingQueueSize
(
)
;
for
(
int
k
=
0
;
k
<
kNumSlotsInQueue
-
1
;
+
+
k
)
{
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
}
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
false
)
)
.
Times
(
kNumSlotsInQueue
-
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
for
(
int
k
=
0
;
k
<
kNumSlotsInQueue
;
+
+
k
)
{
EXPECT_TRUE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
}
EXPECT_FALSE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
EXPECT_FALSE
(
apm
-
>
PostRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCaptureOutputUsedSetting
(
false
)
)
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
false
)
)
.
Times
(
kNumSlotsInQueue
)
;
EXPECT_CALL
(
*
echo_control_mock
SetCaptureOutputUsage
(
true
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesPreAmplifierEchoPathGainChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm_config
.
pre_amplifier
.
enabled
=
true
;
apm_config
.
pre_amplifier
.
fixed_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
2
.
f
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesLevelAdjustmentPreGainEchoPathGainChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm_config
.
capture_level_adjustment
.
enabled
=
true
;
apm_config
.
capture_level_adjustment
.
pre_gain_factor
=
1
.
f
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreateCapturePreGain
(
2
.
f
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
config
config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesAnalogAgc1EchoPathGainChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
true
;
apm_config
.
gain_controller1
.
analog_gain_controller
.
enabled
=
true
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm_config
.
pre_amplifier
.
enabled
=
false
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
1000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
constexpr
int
kInitialStreamAnalogLevel
=
123
;
apm
-
>
set_stream_analog_level
(
kInitialStreamAnalogLevel
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
int
recommended_analog_level
=
apm
-
>
recommended_stream_analog_level
(
)
;
if
(
recommended_analog_level
=
=
kInitialStreamAnalogLevel
)
{
recommended_analog_level
+
+
;
}
apm
-
>
set_stream_analog_level
(
recommended_analog_level
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
EchoControllerObservesPlayoutVolumeChange
)
{
auto
echo_control_factory
=
std
:
:
make_unique
<
MockEchoControlFactory
>
(
)
;
const
auto
*
echo_control_factory_ptr
=
echo_control_factory
.
get
(
)
;
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
SetEchoControlFactory
(
std
:
:
move
(
echo_control_factory
)
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
gain_controller2
.
enabled
=
false
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
10000
;
constexpr
size_t
kSampleRateHz
=
48000
;
constexpr
size_t
kNumChannels
=
2
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
frame
.
fill
(
kAudioLevel
)
;
MockEchoControl
*
echo_control_mock
=
echo_control_factory_ptr
-
>
GetNext
(
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreatePlayoutVolumeChange
(
50
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
false
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreatePlayoutVolumeChange
(
50
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
EXPECT_CALL
(
*
echo_control_mock
AnalyzeCapture
(
testing
:
:
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
echo_control_mock
ProcessCapture
(
NotNull
(
)
testing
:
:
_
true
)
)
.
Times
(
1
)
;
apm
-
>
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
:
:
CreatePlayoutVolumeChange
(
100
)
)
;
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
;
}
TEST
(
AudioProcessingImplTest
RenderPreProcessorBeforeEchoDetector
)
{
auto
test_echo_detector
=
make_ref_counted
<
TestEchoDetector
>
(
)
;
std
:
:
unique_ptr
<
CustomProcessing
>
test_render_pre_processor
(
new
TestRenderPreProcessor
(
)
)
;
scoped_refptr
<
AudioProcessing
>
apm
=
BuiltinAudioProcessingBuilder
(
)
.
SetEchoDetector
(
test_echo_detector
)
.
SetRenderPreProcessing
(
std
:
:
move
(
test_render_pre_processor
)
)
.
Build
(
CreateEnvironment
(
)
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
pre_amplifier
.
enabled
=
true
;
apm
-
>
ApplyConfig
(
apm_config
)
;
constexpr
int16_t
kAudioLevel
=
1000
;
constexpr
int
kSampleRateHz
=
16000
;
constexpr
size_t
kNumChannels
=
1
;
const
ProcessingConfig
processing_config
=
{
{
{
kSampleRateHz
kNumChannels
}
{
kSampleRateHz
kNumChannels
}
{
kSampleRateHz
kNumChannels
}
{
kSampleRateHz
kNumChannels
}
}
}
;
apm
-
>
Initialize
(
processing_config
)
;
std
:
:
array
<
int16_t
kNumChannels
*
kSampleRateHz
/
100
>
frame
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
constexpr
float
kAudioLevelFloat
=
static_cast
<
float
>
(
kAudioLevel
)
;
constexpr
float
kExpectedPreprocessedAudioLevel
=
TestRenderPreProcessor
:
:
ProcessSample
(
kAudioLevelFloat
)
;
ASSERT_NE
(
kAudioLevelFloat
kExpectedPreprocessedAudioLevel
)
;
frame
.
fill
(
kAudioLevel
)
;
ASSERT_EQ
(
AudioProcessing
:
:
Error
:
:
kNoError
apm
-
>
ProcessReverseStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
)
;
frame
.
fill
(
kAudioLevel
)
;
ASSERT_EQ
(
AudioProcessing
:
:
Error
:
:
kNoError
apm
-
>
ProcessStream
(
frame
.
data
(
)
stream_config
stream_config
frame
.
data
(
)
)
)
;
ASSERT_TRUE
(
test_echo_detector
-
>
analyze_render_audio_called
(
)
)
;
EXPECT_EQ
(
kExpectedPreprocessedAudioLevel
test_echo_detector
-
>
last_render_audio_first_sample
(
)
)
;
}
class
StartupInputVolumeParameterizedTest
:
public
:
:
testing
:
:
TestWithParam
<
int
>
{
}
;
TEST_P
(
StartupInputVolumeParameterizedTest
WithNoInputVolumeControllerStartupVolumeNotModified
)
{
webrtc
:
:
AudioProcessing
:
:
Config
config
;
config
.
gain_controller1
.
enabled
=
false
;
config
.
gain_controller2
.
enabled
=
false
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
config
)
.
Build
(
CreateEnvironment
(
)
)
;
int
startup_volume
=
GetParam
(
)
;
int
recommended_volume
=
ProcessInputVolume
(
*
apm
1
startup_volume
)
;
EXPECT_EQ
(
recommended_volume
startup_volume
)
;
}
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingImplTest
StartupInputVolumeParameterizedTest
:
:
testing
:
:
Values
(
0
5
15
50
100
)
)
;
TEST
(
AudioProcessingImplTest
WithNoInputVolumeControllerAppliedAndRecommendedVolumesMatch
)
{
webrtc
:
:
AudioProcessing
:
:
Config
config
;
config
.
gain_controller1
.
enabled
=
false
;
config
.
gain_controller2
.
enabled
=
false
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
config
)
.
Build
(
CreateEnvironment
(
)
)
;
Random
rand_gen
(
42
)
;
for
(
int
i
=
0
;
i
<
32
;
+
+
i
)
{
SCOPED_TRACE
(
i
)
;
int32_t
applied_volume
=
rand_gen
.
Rand
(
0
255
)
;
int
recommended_volume
=
ProcessInputVolume
(
*
apm
1
applied_volume
)
;
EXPECT_EQ
(
recommended_volume
applied_volume
)
;
}
}
class
ApmInputVolumeControllerParametrizedTest
:
public
:
:
testing
:
:
TestWithParam
<
std
:
:
tuple
<
int
int
AudioProcessing
:
:
Config
>
>
{
protected
:
ApmInputVolumeControllerParametrizedTest
(
)
:
sample_rate_hz_
(
std
:
:
get
<
0
>
(
GetParam
(
)
)
)
num_channels_
(
std
:
:
get
<
1
>
(
GetParam
(
)
)
)
channels_
(
num_channels_
)
channel_pointers_
(
num_channels_
)
{
const
int
frame_size
=
sample_rate_hz_
/
100
;
for
(
int
c
=
0
;
c
<
num_channels_
;
+
+
c
)
{
channels_
[
c
]
.
resize
(
frame_size
)
;
channel_pointers_
[
c
]
=
channels_
[
c
]
.
data
(
)
;
std
:
:
fill
(
channels_
[
c
]
.
begin
(
)
channels_
[
c
]
.
end
(
)
0
.
0f
)
;
}
}
int
sample_rate_hz
(
)
const
{
return
sample_rate_hz_
;
}
int
num_channels
(
)
const
{
return
num_channels_
;
}
AudioProcessing
:
:
Config
GetConfig
(
)
const
{
return
std
:
:
get
<
2
>
(
GetParam
(
)
)
;
}
float
*
const
*
channel_pointers
(
)
{
return
channel_pointers_
.
data
(
)
;
}
private
:
const
int
sample_rate_hz_
;
const
int
num_channels_
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
channels_
;
std
:
:
vector
<
float
*
>
channel_pointers_
;
}
;
TEST_P
(
ApmInputVolumeControllerParametrizedTest
EnforceMinInputVolumeAtStartupWithZeroVolume
)
{
const
StreamConfig
stream_config
(
sample_rate_hz
(
)
num_channels
(
)
)
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
GetConfig
(
)
)
.
Build
(
CreateEnvironment
(
)
)
;
apm
-
>
set_stream_analog_level
(
0
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
EXPECT_GT
(
apm
-
>
recommended_stream_analog_level
(
)
0
)
;
}
TEST_P
(
ApmInputVolumeControllerParametrizedTest
EnforceMinInputVolumeAtStartupWithNonZeroVolume
)
{
const
StreamConfig
stream_config
(
sample_rate_hz
(
)
num_channels
(
)
)
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
GetConfig
(
)
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int
kStartupVolume
=
3
;
apm
-
>
set_stream_analog_level
(
kStartupVolume
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
EXPECT_GT
(
apm
-
>
recommended_stream_analog_level
(
)
kStartupVolume
)
;
}
TEST_P
(
ApmInputVolumeControllerParametrizedTest
EnforceMinInputVolumeAfterManualVolumeAdjustment
)
{
const
auto
config
=
GetConfig
(
)
;
if
(
config
.
gain_controller1
.
enabled
)
{
GTEST_SKIP
(
)
<
<
"
Does
not
apply
to
AGC1
"
;
}
const
StreamConfig
stream_config
(
sample_rate_hz
(
)
num_channels
(
)
)
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
GetConfig
(
)
)
.
Build
(
CreateEnvironment
(
)
)
;
apm
-
>
set_stream_analog_level
(
20
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
constexpr
int
kManuallyAdjustedVolume
=
3
;
apm
-
>
set_stream_analog_level
(
kManuallyAdjustedVolume
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
EXPECT_GT
(
apm
-
>
recommended_stream_analog_level
(
)
kManuallyAdjustedVolume
)
;
}
TEST_P
(
ApmInputVolumeControllerParametrizedTest
DoNotEnforceMinInputVolumeAtStartupWithHighVolume
)
{
const
StreamConfig
stream_config
(
sample_rate_hz
(
)
num_channels
(
)
)
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
GetConfig
(
)
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int
kStartupVolume
=
200
;
apm
-
>
set_stream_analog_level
(
kStartupVolume
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
EXPECT_EQ
(
apm
-
>
recommended_stream_analog_level
(
)
kStartupVolume
)
;
}
TEST_P
(
ApmInputVolumeControllerParametrizedTest
DoNotEnforceMinInputVolumeAfterManualVolumeAdjustmentToZero
)
{
const
StreamConfig
stream_config
(
sample_rate_hz
(
)
num_channels
(
)
)
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
GetConfig
(
)
)
.
Build
(
CreateEnvironment
(
)
)
;
apm
-
>
set_stream_analog_level
(
100
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
apm
-
>
set_stream_analog_level
(
0
)
;
apm
-
>
ProcessStream
(
channel_pointers
(
)
stream_config
stream_config
channel_pointers
(
)
)
;
EXPECT_EQ
(
apm
-
>
recommended_stream_analog_level
(
)
0
)
;
}
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingImplTest
ApmInputVolumeControllerParametrizedTest
:
:
testing
:
:
Combine
(
:
:
testing
:
:
Values
(
8000
16000
32000
48000
)
:
:
testing
:
:
Values
(
1
2
)
:
:
testing
:
:
Values
(
AudioProcessing
:
:
Config
{
.
gain_controller1
=
{
.
enabled
=
true
.
analog_gain_controller
=
{
.
enabled
=
true
.
enable_digital_adaptive
=
true
}
}
.
gain_controller2
=
{
.
enabled
=
false
}
}
AudioProcessing
:
:
Config
{
.
gain_controller1
=
{
.
enabled
=
true
.
analog_gain_controller
=
{
.
enabled
=
true
.
enable_digital_adaptive
=
false
}
}
.
gain_controller2
=
{
.
enabled
=
true
.
adaptive_digital
=
{
.
enabled
=
true
}
}
}
)
)
)
;
TEST
(
AudioProcessingImplTest
RecommendAppliedInputVolumeWithNoAgcWithNoEmulation
)
{
auto
apm
=
BuiltinAudioProcessingBuilder
(
{
.
capture_level_adjustment
=
{
.
enabled
=
false
}
.
gain_controller1
=
{
.
enabled
=
false
}
}
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int
kOneFrame
=
1
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
123
)
123
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
59
)
59
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
135
)
135
)
;
}
TEST
(
AudioProcessingImplTest
DISABLED_RecommendAppliedInputVolumeWithNoAgcWithEmulation
)
{
auto
apm
=
BuiltinAudioProcessingBuilder
(
{
.
capture_level_adjustment
=
{
.
enabled
=
true
.
analog_mic_gain_emulation
{
.
enabled
=
true
.
initial_level
=
255
}
}
.
gain_controller1
=
{
.
enabled
=
false
}
}
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int
kOneFrame
=
1
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
123
)
123
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
59
)
59
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
135
)
135
)
;
}
TEST
(
AudioProcessingImplTest
DISABLED_RecommendAppliedInputVolumeWithAgcWithEmulation
)
{
auto
apm
=
BuiltinAudioProcessingBuilder
(
{
.
capture_level_adjustment
=
{
.
enabled
=
true
.
analog_mic_gain_emulation
{
.
enabled
=
true
}
}
.
gain_controller1
=
{
.
enabled
=
true
.
analog_gain_controller
{
.
enabled
=
true
}
}
}
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int
kOneFrame
=
1
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
123
)
123
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
59
)
59
)
;
EXPECT_EQ
(
ProcessInputVolume
(
*
apm
kOneFrame
135
)
135
)
;
}
class
Agc2ParametrizedTest
:
public
:
:
testing
:
:
TestWithParam
<
AudioProcessing
:
:
Config
>
{
}
;
TEST_P
(
Agc2ParametrizedTest
ProcessSucceedsWhenOneAgcEnabled
)
{
auto
apm
=
BuiltinAudioProcessingBuilder
(
GetParam
(
)
)
.
Build
(
CreateEnvironment
(
)
)
;
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcess
=
10
;
int
volume
=
100
;
for
(
int
i
=
0
;
i
<
kFramesToProcess
;
+
+
i
)
{
SCOPED_TRACE
(
i
)
;
RandomizeSampleVector
(
&
random_generator
buffer
)
;
apm
-
>
set_stream_analog_level
(
volume
)
;
ASSERT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
volume
=
apm
-
>
recommended_stream_analog_level
(
)
;
}
}
TEST_P
(
Agc2ParametrizedTest
BitExactWithAndWithoutTransientSuppressionEnabledInConfig
)
{
const
Environment
env
=
CreateEnvironment
(
)
;
auto
config
=
GetParam
(
)
;
config
.
transient_suppression
.
enabled
=
true
;
auto
apm
=
BuiltinAudioProcessingBuilder
(
config
)
.
Build
(
env
)
;
ASSERT_EQ
(
apm
-
>
Initialize
(
)
AudioProcessing
:
:
kNoError
)
;
auto
config_reference
=
GetParam
(
)
;
config_reference
.
transient_suppression
.
enabled
=
false
;
auto
apm_reference
=
BuiltinAudioProcessingBuilder
(
config_reference
)
.
Build
(
env
)
;
ASSERT_EQ
(
apm_reference
-
>
Initialize
(
)
AudioProcessing
:
:
kNoError
)
;
constexpr
int
kSampleRateHz
=
16000
;
constexpr
int
kNumChannels
=
1
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer
;
std
:
:
array
<
float
kSampleRateHz
/
100
>
buffer_reference
;
float
*
channel_pointers
[
]
=
{
buffer
.
data
(
)
}
;
float
*
channel_pointers_reference
[
]
=
{
buffer_reference
.
data
(
)
}
;
StreamConfig
stream_config
(
kSampleRateHz
kNumChannels
)
;
Random
random_generator
(
2341U
)
;
constexpr
int
kFramesToProcessPerConfiguration
=
100
;
int
volume
=
100
;
int
volume_reference
=
100
;
for
(
int
i
=
0
;
i
<
kFramesToProcessPerConfiguration
;
+
+
i
)
{
RandomizeSampleVector
(
&
random_generator
buffer
)
;
std
:
:
copy
(
buffer
.
begin
(
)
buffer
.
end
(
)
buffer_reference
.
begin
(
)
)
;
apm
-
>
set_stream_analog_level
(
volume
)
;
apm_reference
-
>
set_stream_analog_level
(
volume_reference
)
;
ASSERT_EQ
(
apm
-
>
ProcessStream
(
channel_pointers
stream_config
stream_config
channel_pointers
)
kNoErr
)
;
ASSERT_EQ
(
apm_reference
-
>
ProcessStream
(
channel_pointers_reference
stream_config
stream_config
channel_pointers_reference
)
kNoErr
)
;
volume
=
apm
-
>
recommended_stream_analog_level
(
)
;
volume_reference
=
apm_reference
-
>
recommended_stream_analog_level
(
)
;
for
(
int
j
=
0
;
j
<
kSampleRateHz
/
100
;
+
+
j
)
{
EXPECT_EQ
(
buffer
[
j
]
buffer_reference
[
j
]
)
;
}
}
}
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingImplTest
Agc2ParametrizedTest
:
:
testing
:
:
Values
(
AudioProcessing
:
:
Config
{
.
transient_suppression
=
{
.
enabled
=
false
}
.
gain_controller1
=
{
.
enabled
=
true
.
analog_gain_controller
=
{
.
enabled
=
true
.
enable_digital_adaptive
=
true
}
}
.
gain_controller2
=
{
.
enabled
=
false
}
}
AudioProcessing
:
:
Config
{
.
transient_suppression
=
{
.
enabled
=
false
}
.
gain_controller1
=
{
.
enabled
=
true
.
analog_gain_controller
=
{
.
enabled
=
true
.
enable_digital_adaptive
=
false
}
}
.
gain_controller2
=
{
.
enabled
=
true
.
adaptive_digital
=
{
.
enabled
=
true
}
}
}
AudioProcessing
:
:
Config
{
.
transient_suppression
=
{
.
enabled
=
false
}
.
gain_controller1
=
{
.
enabled
=
false
.
analog_gain_controller
=
{
.
enabled
=
false
.
enable_digital_adaptive
=
false
}
}
.
gain_controller2
=
{
.
enabled
=
true
.
input_volume_controller
=
{
.
enabled
=
true
}
.
adaptive_digital
=
{
.
enabled
=
true
}
}
}
)
)
;
}
