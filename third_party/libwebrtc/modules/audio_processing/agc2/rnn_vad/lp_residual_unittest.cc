#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
lp_residual
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
vector
>
#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
common
.
h
"
#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
test_utils
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
rnn_vad
{
namespace
test
{
TEST
(
RnnVadTest
LpResidualOfEmptyFrame
)
{
std
:
:
array
<
float
kFrameSize10ms24kHz
>
empty_frame
;
empty_frame
.
fill
(
0
.
f
)
;
std
:
:
array
<
float
kNumLpcCoefficients
>
lpc_coeffs
;
ComputeAndPostProcessLpcCoefficients
(
empty_frame
lpc_coeffs
)
;
std
:
:
array
<
float
kFrameSize10ms24kHz
>
lp_residual
;
ComputeLpResidual
(
lpc_coeffs
empty_frame
lp_residual
)
;
}
TEST
(
RnnVadTest
LpResidualPipelineBitExactness
)
{
auto
pitch_buf_24kHz_reader
=
CreatePitchBuffer24kHzReader
(
)
;
auto
lp_residual_reader
=
CreateLpResidualAndPitchPeriodGainReader
(
)
;
std
:
:
vector
<
float
>
pitch_buf_data
(
kBufSize24kHz
)
;
std
:
:
array
<
float
kNumLpcCoefficients
>
lpc_coeffs
;
std
:
:
vector
<
float
>
computed_lp_residual
(
kBufSize24kHz
)
;
std
:
:
vector
<
float
>
expected_lp_residual
(
kBufSize24kHz
)
;
const
size_t
num_frames
=
std
:
:
min
(
pitch_buf_24kHz_reader
.
second
static_cast
<
size_t
>
(
300
)
)
;
ASSERT_GE
(
lp_residual_reader
.
second
num_frames
)
;
{
for
(
size_t
i
=
0
;
i
<
num_frames
;
+
+
i
)
{
ASSERT_TRUE
(
pitch_buf_24kHz_reader
.
first
-
>
ReadChunk
(
pitch_buf_data
)
)
;
ASSERT_TRUE
(
lp_residual_reader
.
first
-
>
ReadChunk
(
expected_lp_residual
)
)
;
float
unused
;
ASSERT_TRUE
(
lp_residual_reader
.
first
-
>
ReadValue
(
&
unused
)
)
;
ASSERT_TRUE
(
lp_residual_reader
.
first
-
>
ReadValue
(
&
unused
)
)
;
if
(
i
%
20
!
=
0
)
{
continue
;
}
SCOPED_TRACE
(
i
)
;
ComputeAndPostProcessLpcCoefficients
(
pitch_buf_data
lpc_coeffs
)
;
ComputeLpResidual
(
lpc_coeffs
pitch_buf_data
computed_lp_residual
)
;
ExpectNearAbsolute
(
expected_lp_residual
computed_lp_residual
kFloatMin
)
;
}
}
}
}
}
}
