#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
symmetric_matrix_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
ring_buffer
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
rnn_vad
{
namespace
{
template
<
typename
T
int
S
>
void
CheckSymmetry
(
const
SymmetricMatrixBuffer
<
T
S
>
*
sym_matrix_buf
)
{
for
(
int
row
=
0
;
row
<
S
-
1
;
+
+
row
)
for
(
int
col
=
row
+
1
;
col
<
S
;
+
+
col
)
EXPECT_EQ
(
sym_matrix_buf
-
>
GetValue
(
row
col
)
sym_matrix_buf
-
>
GetValue
(
col
row
)
)
;
}
using
PairType
=
std
:
:
pair
<
int
int
>
;
template
<
int
S
>
bool
CheckPairsWithValueExist
(
const
SymmetricMatrixBuffer
<
PairType
S
>
*
sym_matrix_buf
const
int
value
)
{
for
(
int
row
=
0
;
row
<
S
-
1
;
+
+
row
)
{
for
(
int
col
=
row
+
1
;
col
<
S
;
+
+
col
)
{
auto
p
=
sym_matrix_buf
-
>
GetValue
(
row
col
)
;
if
(
p
.
first
=
=
value
|
|
p
.
second
=
=
value
)
return
true
;
}
}
return
false
;
}
TEST
(
RnnVadTest
SymmetricMatrixBufferUseCase
)
{
constexpr
int
kRingBufSize
=
10
;
RingBuffer
<
int
1
kRingBufSize
>
ring_buf
;
SymmetricMatrixBuffer
<
PairType
kRingBufSize
>
sym_matrix_buf
;
for
(
int
t
=
1
;
t
<
=
100
;
+
+
t
)
{
SCOPED_TRACE
(
t
)
;
const
int
t_removed
=
ring_buf
.
GetArrayView
(
kRingBufSize
-
1
)
[
0
]
;
ring_buf
.
Push
(
{
&
t
1
}
)
;
ASSERT_EQ
(
t
ring_buf
.
GetArrayView
(
0
)
[
0
]
)
;
std
:
:
array
<
PairType
kRingBufSize
-
1
>
new_comparions
;
for
(
int
i
=
0
;
i
<
kRingBufSize
-
1
;
+
+
i
)
{
const
int
delay
=
i
+
1
;
const
auto
t_prev
=
ring_buf
.
GetArrayView
(
delay
)
[
0
]
;
ASSERT_EQ
(
std
:
:
max
(
0
t
-
delay
)
t_prev
)
;
new_comparions
[
i
]
.
first
=
t_prev
;
new_comparions
[
i
]
.
second
=
t
;
}
sym_matrix_buf
.
Push
(
{
new_comparions
.
data
(
)
new_comparions
.
size
(
)
}
)
;
CheckSymmetry
(
&
sym_matrix_buf
)
;
for
(
int
delay1
=
0
;
delay1
<
kRingBufSize
-
1
;
+
+
delay1
)
{
for
(
int
delay2
=
delay1
+
1
;
delay2
<
kRingBufSize
;
+
+
delay2
)
{
const
auto
t1
=
ring_buf
.
GetArrayView
(
delay1
)
[
0
]
;
const
auto
t2
=
ring_buf
.
GetArrayView
(
delay2
)
[
0
]
;
ASSERT_LE
(
t2
t1
)
;
const
auto
p
=
sym_matrix_buf
.
GetValue
(
delay1
delay2
)
;
EXPECT_EQ
(
p
.
first
t2
)
;
EXPECT_EQ
(
p
.
second
t1
)
;
}
}
for
(
int
delay
=
1
;
delay
<
kRingBufSize
;
+
+
delay
)
{
const
auto
t_prev
=
ring_buf
.
GetArrayView
(
delay
)
[
0
]
;
EXPECT_TRUE
(
CheckPairsWithValueExist
(
&
sym_matrix_buf
t_prev
)
)
;
}
if
(
t
>
kRingBufSize
-
1
)
{
EXPECT_FALSE
(
CheckPairsWithValueExist
(
&
sym_matrix_buf
t_removed
)
)
;
}
}
}
}
}
}
