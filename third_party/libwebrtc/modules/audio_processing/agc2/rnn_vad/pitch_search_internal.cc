#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
pitch_search_internal
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
numeric
>
#
include
"
modules
/
audio_processing
/
agc2
/
rnn_vad
/
common
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_compare
.
h
"
namespace
webrtc
{
namespace
rnn_vad
{
namespace
{
constexpr
int
kMaxPitch24kHzInt
=
static_cast
<
int
>
(
kMaxPitch24kHz
)
;
int
GetInvertedLag
(
int
lag
)
{
RTC_DCHECK_LE
(
lag
kMaxPitch24kHzInt
)
;
return
kMaxPitch24kHzInt
-
lag
;
}
float
ComputeAutoCorrelationCoeff
(
rtc
:
:
ArrayView
<
const
float
>
pitch_buf
int
inv_lag
int
max_pitch_period
)
{
RTC_DCHECK_LT
(
inv_lag
static_cast
<
int
>
(
pitch_buf
.
size
(
)
)
)
;
RTC_DCHECK_LT
(
max_pitch_period
static_cast
<
int
>
(
pitch_buf
.
size
(
)
)
)
;
RTC_DCHECK_LE
(
inv_lag
static_cast
<
int
>
(
max_pitch_period
)
)
;
return
std
:
:
inner_product
(
pitch_buf
.
begin
(
)
+
static_cast
<
size_t
>
(
max_pitch_period
)
pitch_buf
.
end
(
)
pitch_buf
.
begin
(
)
+
static_cast
<
size_t
>
(
inv_lag
)
0
.
f
)
;
}
int
GetPitchPseudoInterpolationOffset
(
float
prev_auto_corr
float
lag_auto_corr
float
next_auto_corr
)
{
const
float
&
a
=
prev_auto_corr
;
const
float
&
b
=
lag_auto_corr
;
const
float
&
c
=
next_auto_corr
;
int
offset
=
0
;
if
(
(
c
-
a
)
>
0
.
7f
*
(
b
-
a
)
)
{
offset
=
1
;
}
else
if
(
(
a
-
c
)
>
0
.
7f
*
(
b
-
c
)
)
{
offset
=
-
1
;
}
return
offset
;
}
int
PitchPseudoInterpolationLagPitchBuf
(
int
lag
rtc
:
:
ArrayView
<
const
float
kBufSize24kHz
>
pitch_buf
)
{
int
offset
=
0
;
if
(
lag
>
0
&
&
lag
<
kMaxPitch24kHzInt
)
{
offset
=
GetPitchPseudoInterpolationOffset
(
ComputeAutoCorrelationCoeff
(
pitch_buf
GetInvertedLag
(
lag
-
1
)
kMaxPitch24kHzInt
)
ComputeAutoCorrelationCoeff
(
pitch_buf
GetInvertedLag
(
lag
)
kMaxPitch24kHzInt
)
ComputeAutoCorrelationCoeff
(
pitch_buf
GetInvertedLag
(
lag
+
1
)
kMaxPitch24kHzInt
)
)
;
}
return
2
*
lag
+
offset
;
}
int
PitchPseudoInterpolationInvLagAutoCorr
(
int
inv_lag
rtc
:
:
ArrayView
<
const
float
>
auto_corr
)
{
int
offset
=
0
;
if
(
inv_lag
>
0
&
&
inv_lag
<
static_cast
<
int
>
(
auto_corr
.
size
(
)
)
-
1
)
{
offset
=
GetPitchPseudoInterpolationOffset
(
auto_corr
[
inv_lag
+
1
]
auto_corr
[
inv_lag
]
auto_corr
[
inv_lag
-
1
]
)
;
}
return
2
*
inv_lag
+
offset
;
}
constexpr
std
:
:
array
<
int
14
>
kSubHarmonicMultipliers
=
{
{
3
2
3
2
5
2
3
2
3
2
5
2
3
2
}
}
;
constexpr
std
:
:
array
<
int
14
>
kInitialPitchPeriodThresholds
=
{
{
20
45
80
125
180
245
320
405
500
605
720
845
980
1125
}
}
;
}
void
Decimate2x
(
rtc
:
:
ArrayView
<
const
float
kBufSize24kHz
>
src
rtc
:
:
ArrayView
<
float
kBufSize12kHz
>
dst
)
{
static_assert
(
2
*
dst
.
size
(
)
=
=
src
.
size
(
)
"
"
)
;
for
(
size_t
i
=
0
;
i
<
dst
.
size
(
)
;
+
+
i
)
{
dst
[
i
]
=
src
[
2
*
i
]
;
}
}
float
ComputePitchGainThreshold
(
int
candidate_pitch_period
int
pitch_period_ratio
int
initial_pitch_period
float
initial_pitch_gain
int
prev_pitch_period
float
prev_pitch_gain
)
{
const
int
&
t1
=
candidate_pitch_period
;
const
int
&
k
=
pitch_period_ratio
;
const
int
&
t0
=
initial_pitch_period
;
const
float
&
g0
=
initial_pitch_gain
;
const
int
&
t_prev
=
prev_pitch_period
;
const
float
&
g_prev
=
prev_pitch_gain
;
RTC_DCHECK_GE
(
t1
0
)
;
RTC_DCHECK_GE
(
k
2
)
;
RTC_DCHECK_GE
(
t0
0
)
;
RTC_DCHECK_GE
(
t_prev
0
)
;
float
lower_threshold_term
=
0
;
if
(
abs
(
t1
-
t_prev
)
<
=
1
)
{
lower_threshold_term
=
g_prev
;
}
else
if
(
abs
(
t1
-
t_prev
)
=
=
2
&
&
t0
>
kInitialPitchPeriodThresholds
[
k
-
2
]
)
{
lower_threshold_term
=
0
.
5f
*
g_prev
;
}
float
threshold
=
std
:
:
max
(
0
.
3f
0
.
7f
*
g0
-
lower_threshold_term
)
;
if
(
static_cast
<
size_t
>
(
t1
)
<
3
*
kMinPitch24kHz
)
{
threshold
=
std
:
:
max
(
0
.
4f
0
.
85f
*
g0
-
lower_threshold_term
)
;
}
else
if
(
static_cast
<
size_t
>
(
t1
)
<
2
*
kMinPitch24kHz
)
{
threshold
=
std
:
:
max
(
0
.
5f
0
.
9f
*
g0
-
lower_threshold_term
)
;
}
return
threshold
;
}
void
ComputeSlidingFrameSquareEnergies
(
rtc
:
:
ArrayView
<
const
float
kBufSize24kHz
>
pitch_buf
rtc
:
:
ArrayView
<
float
kMaxPitch24kHz
+
1
>
yy_values
)
{
float
yy
=
ComputeAutoCorrelationCoeff
(
pitch_buf
kMaxPitch24kHzInt
kMaxPitch24kHzInt
)
;
yy_values
[
0
]
=
yy
;
for
(
size_t
i
=
1
;
i
<
yy_values
.
size
(
)
;
+
+
i
)
{
RTC_DCHECK_LE
(
i
kMaxPitch24kHz
+
kFrameSize20ms24kHz
)
;
RTC_DCHECK_LE
(
i
kMaxPitch24kHz
)
;
const
float
old_coeff
=
pitch_buf
[
kMaxPitch24kHz
+
kFrameSize20ms24kHz
-
i
]
;
const
float
new_coeff
=
pitch_buf
[
kMaxPitch24kHz
-
i
]
;
yy
-
=
old_coeff
*
old_coeff
;
yy
+
=
new_coeff
*
new_coeff
;
yy
=
std
:
:
max
(
0
.
f
yy
)
;
yy_values
[
i
]
=
yy
;
}
}
CandidatePitchPeriods
FindBestPitchPeriods
(
rtc
:
:
ArrayView
<
const
float
>
auto_corr
rtc
:
:
ArrayView
<
const
float
>
pitch_buf
int
max_pitch_period
)
{
struct
PitchCandidate
{
int
period_inverted_lag
=
0
;
float
strength_numerator
=
-
1
.
f
;
float
strength_denominator
=
0
.
f
;
bool
HasStrongerPitchThan
(
const
PitchCandidate
&
b
)
const
{
return
strength_numerator
*
b
.
strength_denominator
>
b
.
strength_numerator
*
strength_denominator
;
}
}
;
RTC_DCHECK_GT
(
max_pitch_period
static_cast
<
int
>
(
auto_corr
.
size
(
)
)
)
;
RTC_DCHECK_LT
(
max_pitch_period
static_cast
<
int
>
(
pitch_buf
.
size
(
)
)
)
;
const
int
frame_size
=
static_cast
<
int
>
(
pitch_buf
.
size
(
)
)
-
max_pitch_period
;
RTC_DCHECK_GT
(
frame_size
0
)
;
float
yy
=
std
:
:
inner_product
(
pitch_buf
.
begin
(
)
pitch_buf
.
begin
(
)
+
frame_size
+
1
pitch_buf
.
begin
(
)
1
.
f
)
;
PitchCandidate
candidate
;
PitchCandidate
best
;
PitchCandidate
second_best
;
second_best
.
period_inverted_lag
=
1
;
for
(
int
inv_lag
=
0
;
inv_lag
<
static_cast
<
int
>
(
auto_corr
.
size
(
)
)
;
+
+
inv_lag
)
{
if
(
auto_corr
[
inv_lag
]
>
0
)
{
candidate
.
period_inverted_lag
=
inv_lag
;
candidate
.
strength_numerator
=
auto_corr
[
inv_lag
]
*
auto_corr
[
inv_lag
]
;
candidate
.
strength_denominator
=
yy
;
if
(
candidate
.
HasStrongerPitchThan
(
second_best
)
)
{
if
(
candidate
.
HasStrongerPitchThan
(
best
)
)
{
second_best
=
best
;
best
=
candidate
;
}
else
{
second_best
=
candidate
;
}
}
}
const
float
old_coeff
=
pitch_buf
[
inv_lag
]
;
const
float
new_coeff
=
pitch_buf
[
inv_lag
+
frame_size
]
;
yy
-
=
old_coeff
*
old_coeff
;
yy
+
=
new_coeff
*
new_coeff
;
yy
=
std
:
:
max
(
0
.
f
yy
)
;
}
return
{
best
.
period_inverted_lag
second_best
.
period_inverted_lag
}
;
}
int
RefinePitchPeriod48kHz
(
rtc
:
:
ArrayView
<
const
float
kBufSize24kHz
>
pitch_buf
CandidatePitchPeriods
pitch_candidates_inverted_lags
)
{
std
:
:
array
<
float
kNumInvertedLags24kHz
>
auto_correlation
;
auto_correlation
.
fill
(
0
.
f
)
;
auto
is_neighbor
=
[
]
(
int
i
int
j
)
{
return
(
(
i
>
j
)
?
(
i
-
j
)
:
(
j
-
i
)
)
<
=
2
;
}
;
for
(
int
inverted_lag
=
0
;
rtc
:
:
SafeLt
(
inverted_lag
auto_correlation
.
size
(
)
)
;
+
+
inverted_lag
)
{
if
(
is_neighbor
(
inverted_lag
pitch_candidates_inverted_lags
.
best
)
|
|
is_neighbor
(
inverted_lag
pitch_candidates_inverted_lags
.
second_best
)
)
auto_correlation
[
inverted_lag
]
=
ComputeAutoCorrelationCoeff
(
pitch_buf
inverted_lag
kMaxPitch24kHzInt
)
;
}
const
CandidatePitchPeriods
pitch_candidates_24kHz
=
FindBestPitchPeriods
(
auto_correlation
pitch_buf
kMaxPitch24kHzInt
)
;
return
PitchPseudoInterpolationInvLagAutoCorr
(
pitch_candidates_24kHz
.
best
auto_correlation
)
;
}
PitchInfo
CheckLowerPitchPeriodsAndComputePitchGain
(
rtc
:
:
ArrayView
<
const
float
kBufSize24kHz
>
pitch_buf
int
initial_pitch_period_48kHz
PitchInfo
prev_pitch_48kHz
)
{
RTC_DCHECK_LE
(
kMinPitch48kHz
initial_pitch_period_48kHz
)
;
RTC_DCHECK_LE
(
initial_pitch_period_48kHz
kMaxPitch48kHz
)
;
struct
RefinedPitchCandidate
{
RefinedPitchCandidate
(
)
{
}
RefinedPitchCandidate
(
int
period_24kHz
float
gain
float
xy
float
yy
)
:
period_24kHz
(
period_24kHz
)
gain
(
gain
)
xy
(
xy
)
yy
(
yy
)
{
}
int
period_24kHz
;
float
gain
;
float
xy
;
float
yy
;
}
;
std
:
:
array
<
float
kMaxPitch24kHz
+
1
>
yy_values
;
ComputeSlidingFrameSquareEnergies
(
pitch_buf
{
yy_values
.
data
(
)
yy_values
.
size
(
)
}
)
;
const
float
xx
=
yy_values
[
0
]
;
const
auto
pitch_gain
=
[
]
(
float
xy
float
yy
float
xx
)
{
RTC_DCHECK_LE
(
0
.
f
xx
*
yy
)
;
return
xy
/
std
:
:
sqrt
(
1
.
f
+
xx
*
yy
)
;
}
;
RefinedPitchCandidate
best_pitch
;
best_pitch
.
period_24kHz
=
std
:
:
min
(
initial_pitch_period_48kHz
/
2
kMaxPitch24kHzInt
-
1
)
;
best_pitch
.
xy
=
ComputeAutoCorrelationCoeff
(
pitch_buf
GetInvertedLag
(
best_pitch
.
period_24kHz
)
kMaxPitch24kHzInt
)
;
best_pitch
.
yy
=
yy_values
[
best_pitch
.
period_24kHz
]
;
best_pitch
.
gain
=
pitch_gain
(
best_pitch
.
xy
best_pitch
.
yy
xx
)
;
const
int
initial_pitch_period
=
best_pitch
.
period_24kHz
;
const
float
initial_pitch_gain
=
best_pitch
.
gain
;
const
auto
alternative_period
=
[
]
(
int
period
int
k
int
n
)
-
>
int
{
RTC_DCHECK_GT
(
k
0
)
;
return
(
2
*
n
*
period
+
k
)
/
(
2
*
k
)
;
}
;
const
int
max_k
=
(
2
*
initial_pitch_period
)
/
(
2
*
static_cast
<
int
>
(
kMinPitch24kHz
)
-
1
)
;
for
(
int
k
=
2
;
k
<
=
max_k
;
+
+
k
)
{
int
candidate_pitch_period
=
alternative_period
(
initial_pitch_period
k
1
)
;
RTC_DCHECK_GE
(
candidate_pitch_period
static_cast
<
int
>
(
kMinPitch24kHz
)
)
;
int
candidate_pitch_secondary_period
=
alternative_period
(
initial_pitch_period
k
kSubHarmonicMultipliers
[
k
-
2
]
)
;
RTC_DCHECK_GT
(
candidate_pitch_secondary_period
0
)
;
if
(
k
=
=
2
&
&
candidate_pitch_secondary_period
>
kMaxPitch24kHzInt
)
{
candidate_pitch_secondary_period
=
initial_pitch_period
;
}
RTC_DCHECK_NE
(
candidate_pitch_period
candidate_pitch_secondary_period
)
<
<
"
The
lower
pitch
period
and
the
additional
sub
-
harmonic
must
not
"
"
coincide
.
"
;
float
xy_primary_period
=
ComputeAutoCorrelationCoeff
(
pitch_buf
GetInvertedLag
(
candidate_pitch_period
)
kMaxPitch24kHzInt
)
;
float
xy_secondary_period
=
ComputeAutoCorrelationCoeff
(
pitch_buf
GetInvertedLag
(
candidate_pitch_secondary_period
)
kMaxPitch24kHzInt
)
;
float
xy
=
0
.
5f
*
(
xy_primary_period
+
xy_secondary_period
)
;
float
yy
=
0
.
5f
*
(
yy_values
[
candidate_pitch_period
]
+
yy_values
[
candidate_pitch_secondary_period
]
)
;
float
candidate_pitch_gain
=
pitch_gain
(
xy
yy
xx
)
;
float
threshold
=
ComputePitchGainThreshold
(
candidate_pitch_period
k
initial_pitch_period
initial_pitch_gain
prev_pitch_48kHz
.
period
/
2
prev_pitch_48kHz
.
gain
)
;
if
(
candidate_pitch_gain
>
threshold
)
{
best_pitch
=
{
candidate_pitch_period
candidate_pitch_gain
xy
yy
}
;
}
}
best_pitch
.
xy
=
std
:
:
max
(
0
.
f
best_pitch
.
xy
)
;
RTC_DCHECK_LE
(
0
.
f
best_pitch
.
yy
)
;
float
final_pitch_gain
=
(
best_pitch
.
yy
<
=
best_pitch
.
xy
)
?
1
.
f
:
best_pitch
.
xy
/
(
best_pitch
.
yy
+
1
.
f
)
;
final_pitch_gain
=
std
:
:
min
(
best_pitch
.
gain
final_pitch_gain
)
;
int
final_pitch_period_48kHz
=
std
:
:
max
(
static_cast
<
int
>
(
kMinPitch48kHz
)
PitchPseudoInterpolationLagPitchBuf
(
best_pitch
.
period_24kHz
pitch_buf
)
)
;
return
{
final_pitch_period_48kHz
final_pitch_gain
}
;
}
}
}
