#
ifndef
MODULES_AUDIO_PROCESSING_AGC2_SATURATION_PROTECTOR_H_
#
define
MODULES_AUDIO_PROCESSING_AGC2_SATURATION_PROTECTOR_H_
#
include
<
array
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
modules
/
audio_processing
/
agc2
/
agc2_common
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_compare
.
h
"
namespace
webrtc
{
namespace
saturation_protector_impl
{
class
RingBuffer
{
public
:
bool
operator
=
=
(
const
RingBuffer
&
b
)
const
;
inline
bool
operator
!
=
(
const
RingBuffer
&
b
)
const
{
return
!
(
*
this
=
=
b
)
;
}
int
Capacity
(
)
const
{
return
buffer_
.
size
(
)
;
}
int
Size
(
)
const
{
return
size_
;
}
void
Reset
(
)
;
void
PushBack
(
float
v
)
;
absl
:
:
optional
<
float
>
Front
(
)
const
;
private
:
inline
int
FrontIndex
(
)
const
{
return
rtc
:
:
SafeEq
(
size_
buffer_
.
size
(
)
)
?
next_
:
0
;
}
std
:
:
array
<
float
kPeakEnveloperBufferSize
>
buffer_
;
int
next_
=
0
;
int
size_
=
0
;
}
;
}
struct
SaturationProtectorState
{
bool
operator
=
=
(
const
SaturationProtectorState
&
s
)
const
;
inline
bool
operator
!
=
(
const
SaturationProtectorState
&
s
)
const
{
return
!
(
*
this
=
=
s
)
;
}
float
margin_db
;
saturation_protector_impl
:
:
RingBuffer
peak_delay_buffer
;
float
max_peaks_dbfs
;
int
time_since_push_ms
;
}
;
void
ResetSaturationProtectorState
(
float
initial_margin_db
SaturationProtectorState
&
state
)
;
void
UpdateSaturationProtectorState
(
float
speech_peak_dbfs
float
speech_level_dbfs
SaturationProtectorState
&
state
)
;
}
#
endif
