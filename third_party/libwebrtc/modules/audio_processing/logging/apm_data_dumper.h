#
ifndef
MODULES_AUDIO_PROCESSING_LOGGING_APM_DATA_DUMPER_H_
#
define
MODULES_AUDIO_PROCESSING_LOGGING_APM_DATA_DUMPER_H_
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
string
>
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
#
include
<
memory
>
#
include
<
unordered_map
>
#
endif
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
#
include
"
common_audio
/
wav_file
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
endif
#
if
!
defined
(
WEBRTC_APM_DEBUG_DUMP
)
|
|
\
(
WEBRTC_APM_DEBUG_DUMP
!
=
0
&
&
WEBRTC_APM_DEBUG_DUMP
!
=
1
)
#
error
"
Set
WEBRTC_APM_DEBUG_DUMP
to
either
0
or
1
"
#
endif
namespace
webrtc
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
struct
RawFileCloseFunctor
{
void
operator
(
)
(
FILE
*
f
)
const
{
if
(
f
)
fclose
(
f
)
;
}
}
;
#
endif
class
ApmDataDumper
{
public
:
explicit
ApmDataDumper
(
int
instance_index
)
;
ApmDataDumper
(
)
=
delete
;
ApmDataDumper
(
const
ApmDataDumper
&
)
=
delete
;
ApmDataDumper
&
operator
=
(
const
ApmDataDumper
&
)
=
delete
;
~
ApmDataDumper
(
)
;
static
void
SetActivated
(
bool
activated
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
recording_activated_
=
activated
;
#
endif
}
static
constexpr
size_t
kDefaultDumpSet
=
0
;
static
void
SetDumpSetToUse
(
int
dump_set_to_use
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
dump_set_to_use_
=
dump_set_to_use
;
#
endif
}
static
void
SetOutputDirectory
(
const
std
:
:
string
&
output_dir
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
RTC_CHECK_LT
(
output_dir
.
size
(
)
kOutputDirMaxLength
)
;
strncpy
(
output_dir_
output_dir
.
c_str
(
)
output_dir
.
size
(
)
)
;
#
endif
}
void
InitiateNewSetOfRecordings
(
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
+
+
recording_set_index_
;
debug_written_
=
0
;
#
endif
}
void
DumpRaw
(
const
char
*
name
double
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
&
v
sizeof
(
v
)
1
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v_length
const
double
*
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
v
sizeof
(
v
[
0
]
)
v_length
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
rtc
:
:
ArrayView
<
const
double
>
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpRaw
(
name
v
.
size
(
)
v
.
data
(
)
)
;
}
#
endif
}
void
DumpRaw
(
const
char
*
name
float
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
&
v
sizeof
(
v
)
1
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v_length
const
float
*
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
v
sizeof
(
v
[
0
]
)
v_length
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
rtc
:
:
ArrayView
<
const
float
>
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpRaw
(
name
v
.
size
(
)
v
.
data
(
)
)
;
}
#
endif
}
void
DumpRaw
(
const
char
*
name
bool
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpRaw
(
name
static_cast
<
int16_t
>
(
v
)
)
;
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v_length
const
bool
*
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
for
(
size_t
k
=
0
;
k
<
v_length
;
+
+
k
)
{
int16_t
value
=
static_cast
<
int16_t
>
(
v
[
k
]
)
;
fwrite
(
&
value
sizeof
(
value
)
1
file
)
;
}
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
rtc
:
:
ArrayView
<
const
bool
>
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpRaw
(
name
v
.
size
(
)
v
.
data
(
)
)
;
}
#
endif
}
void
DumpRaw
(
const
char
*
name
int16_t
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
&
v
sizeof
(
v
)
1
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v_length
const
int16_t
*
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
v
sizeof
(
v
[
0
]
)
v_length
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
rtc
:
:
ArrayView
<
const
int16_t
>
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpRaw
(
name
v
.
size
(
)
v
.
data
(
)
)
;
}
#
endif
}
void
DumpRaw
(
const
char
*
name
int32_t
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
&
v
sizeof
(
v
)
1
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v_length
const
int32_t
*
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
v
sizeof
(
v
[
0
]
)
v_length
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
&
v
sizeof
(
v
)
1
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
size_t
v_length
const
size_t
*
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
FILE
*
file
=
GetRawFile
(
name
)
;
if
(
file
)
{
fwrite
(
v
sizeof
(
v
[
0
]
)
v_length
file
)
;
}
}
#
endif
}
void
DumpRaw
(
const
char
*
name
rtc
:
:
ArrayView
<
const
int32_t
>
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpRaw
(
name
v
.
size
(
)
v
.
data
(
)
)
;
}
#
endif
}
void
DumpRaw
(
const
char
*
name
rtc
:
:
ArrayView
<
const
size_t
>
v
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
DumpRaw
(
name
v
.
size
(
)
v
.
data
(
)
)
;
#
endif
}
void
DumpWav
(
const
char
*
name
size_t
v_length
const
float
*
v
int
sample_rate_hz
int
num_channels
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
WavWriter
*
file
=
GetWavFile
(
name
sample_rate_hz
num_channels
WavFile
:
:
SampleFormat
:
:
kFloat
)
;
file
-
>
WriteSamples
(
v
v_length
)
;
if
(
strcmp
(
name
"
aec_near
"
)
=
=
0
)
{
updateDebugWritten
(
v_length
*
sizeof
(
float
)
)
;
}
}
#
endif
}
void
DumpWav
(
const
char
*
name
rtc
:
:
ArrayView
<
const
float
>
v
int
sample_rate_hz
int
num_channels
int
dump_set
=
kDefaultDumpSet
)
{
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
if
(
dump_set_to_use_
&
&
*
dump_set_to_use_
!
=
dump_set
)
return
;
if
(
recording_activated_
)
{
DumpWav
(
name
v
.
size
(
)
v
.
data
(
)
sample_rate_hz
num_channels
)
;
}
#
endif
}
private
:
#
if
WEBRTC_APM_DEBUG_DUMP
=
=
1
static
bool
recording_activated_
;
static
absl
:
:
optional
<
int
>
dump_set_to_use_
;
static
constexpr
size_t
kOutputDirMaxLength
=
1024
;
static
char
output_dir_
[
kOutputDirMaxLength
]
;
const
int
instance_index_
;
int
recording_set_index_
=
0
;
std
:
:
unordered_map
<
std
:
:
string
std
:
:
unique_ptr
<
FILE
RawFileCloseFunctor
>
>
raw_files_
;
std
:
:
unordered_map
<
std
:
:
string
std
:
:
unique_ptr
<
WavWriter
>
>
wav_files_
;
FILE
*
GetRawFile
(
const
char
*
name
)
;
WavWriter
*
GetWavFile
(
const
char
*
name
int
sample_rate_hz
int
num_channels
WavFile
:
:
SampleFormat
format
)
;
uint32_t
debug_written_
=
0
;
void
updateDebugWritten
(
uint32_t
amount
)
{
debug_written_
+
=
amount
;
if
(
debug_written_
>
=
webrtc
:
:
Trace
:
:
aec_debug_size
(
)
)
{
SetActivated
(
false
)
;
}
}
#
endif
}
;
}
#
endif
