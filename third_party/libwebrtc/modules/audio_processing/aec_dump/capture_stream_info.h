#
ifndef
MODULES_AUDIO_PROCESSING_AEC_DUMP_CAPTURE_STREAM_INFO_H_
#
define
MODULES_AUDIO_PROCESSING_AEC_DUMP_CAPTURE_STREAM_INFO_H_
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
modules
/
audio_processing
/
aec_dump
/
write_to_file_task
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
aec_dump
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
ignore_wundef
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
RTC_PUSH_IGNORING_WUNDEF
(
)
#
ifdef
WEBRTC_ANDROID_PLATFORM_BUILD
#
include
"
external
/
webrtc
/
webrtc
/
modules
/
audio_processing
/
debug
.
pb
.
h
"
#
else
#
include
"
modules
/
audio_processing
/
debug
.
pb
.
h
"
#
endif
RTC_POP_IGNORING_WUNDEF
(
)
namespace
webrtc
{
class
CaptureStreamInfo
{
public
:
explicit
CaptureStreamInfo
(
std
:
:
unique_ptr
<
WriteToFileTask
>
task
)
;
~
CaptureStreamInfo
(
)
;
void
AddInput
(
const
AudioFrameView
<
const
float
>
&
src
)
;
void
AddOutput
(
const
AudioFrameView
<
const
float
>
&
src
)
;
void
AddInput
(
const
int16_t
*
const
data
int
num_channels
int
samples_per_channel
)
;
void
AddOutput
(
const
int16_t
*
const
data
int
num_channels
int
samples_per_channel
)
;
void
AddAudioProcessingState
(
const
AecDump
:
:
AudioProcessingState
&
state
)
;
std
:
:
unique_ptr
<
WriteToFileTask
>
GetTask
(
)
{
RTC_DCHECK
(
task_
)
;
return
std
:
:
move
(
task_
)
;
}
void
SetTask
(
std
:
:
unique_ptr
<
WriteToFileTask
>
task
)
{
RTC_DCHECK
(
!
task_
)
;
RTC_DCHECK
(
task
)
;
task_
=
std
:
:
move
(
task
)
;
task_
-
>
GetEvent
(
)
-
>
set_type
(
audioproc
:
:
Event
:
:
STREAM
)
;
}
private
:
std
:
:
unique_ptr
<
WriteToFileTask
>
task_
;
}
;
}
#
endif
