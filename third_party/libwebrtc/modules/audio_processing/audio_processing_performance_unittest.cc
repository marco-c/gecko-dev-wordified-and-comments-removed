#
include
<
math
.
h
>
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio
/
builtin_audio_processing_builder
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
numerics
/
samples_stats_counter
.
h
"
#
include
"
api
/
test
/
metrics
/
global_metrics_logger_and_exporter
.
h
"
#
include
"
api
/
test
/
metrics
/
metric
.
h
"
#
include
"
modules
/
audio_processing
/
audio_processing_impl
.
h
"
#
include
"
modules
/
audio_processing
/
test
/
test_utils
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
using
:
:
webrtc
:
:
test
:
:
GetGlobalMetricsLogger
;
using
:
:
webrtc
:
:
test
:
:
ImprovementDirection
;
using
:
:
webrtc
:
:
test
:
:
Metric
;
using
:
:
webrtc
:
:
test
:
:
Unit
;
class
CallSimulator
;
enum
class
ProcessorType
{
kRender
kCapture
}
;
enum
class
SettingsType
{
kDefaultApmDesktop
kDefaultApmMobile
kAllSubmodulesTurnedOff
kDefaultApmDesktopWithoutDelayAgnostic
kDefaultApmDesktopWithoutExtendedFilter
}
;
struct
AudioFrameData
{
explicit
AudioFrameData
(
size_t
max_frame_size
)
{
input_framechannels
.
resize
(
2
*
max_frame_size
)
;
input_frame
.
resize
(
2
)
;
input_frame
[
0
]
=
&
input_framechannels
[
0
]
;
input_frame
[
1
]
=
&
input_framechannels
[
max_frame_size
]
;
output_frame_channels
.
resize
(
2
*
max_frame_size
)
;
output_frame
.
resize
(
2
)
;
output_frame
[
0
]
=
&
output_frame_channels
[
0
]
;
output_frame
[
1
]
=
&
output_frame_channels
[
max_frame_size
]
;
}
std
:
:
vector
<
float
>
output_frame_channels
;
std
:
:
vector
<
float
*
>
output_frame
;
std
:
:
vector
<
float
>
input_framechannels
;
std
:
:
vector
<
float
*
>
input_frame
;
StreamConfig
input_stream_config
;
StreamConfig
output_stream_config
;
}
;
struct
SimulationConfig
{
SimulationConfig
(
int
sample_rate_hz
SettingsType
simulation_settings
)
:
sample_rate_hz
(
sample_rate_hz
)
simulation_settings
(
simulation_settings
)
{
}
static
std
:
:
vector
<
SimulationConfig
>
GenerateSimulationConfigs
(
)
{
std
:
:
vector
<
SimulationConfig
>
simulation_configs
;
#
ifndef
WEBRTC_ANDROID
const
SettingsType
desktop_settings
[
]
=
{
SettingsType
:
:
kDefaultApmDesktop
SettingsType
:
:
kAllSubmodulesTurnedOff
SettingsType
:
:
kDefaultApmDesktopWithoutDelayAgnostic
SettingsType
:
:
kDefaultApmDesktopWithoutExtendedFilter
}
;
const
int
desktop_sample_rates
[
]
=
{
8000
16000
32000
48000
}
;
for
(
auto
sample_rate
:
desktop_sample_rates
)
{
for
(
auto
settings
:
desktop_settings
)
{
simulation_configs
.
push_back
(
SimulationConfig
(
sample_rate
settings
)
)
;
}
}
#
endif
const
SettingsType
mobile_settings
[
]
=
{
SettingsType
:
:
kDefaultApmMobile
}
;
const
int
mobile_sample_rates
[
]
=
{
8000
16000
}
;
for
(
auto
sample_rate
:
mobile_sample_rates
)
{
for
(
auto
settings
:
mobile_settings
)
{
simulation_configs
.
push_back
(
SimulationConfig
(
sample_rate
settings
)
)
;
}
}
return
simulation_configs
;
}
std
:
:
string
SettingsDescription
(
)
const
{
std
:
:
string
description
;
switch
(
simulation_settings
)
{
case
SettingsType
:
:
kDefaultApmMobile
:
description
=
"
DefaultApmMobile
"
;
break
;
case
SettingsType
:
:
kDefaultApmDesktop
:
description
=
"
DefaultApmDesktop
"
;
break
;
case
SettingsType
:
:
kAllSubmodulesTurnedOff
:
description
=
"
AllSubmodulesOff
"
;
break
;
case
SettingsType
:
:
kDefaultApmDesktopWithoutDelayAgnostic
:
description
=
"
DefaultApmDesktopWithoutDelayAgnostic
"
;
break
;
case
SettingsType
:
:
kDefaultApmDesktopWithoutExtendedFilter
:
description
=
"
DefaultApmDesktopWithoutExtendedFilter
"
;
break
;
}
return
description
;
}
int
sample_rate_hz
=
16000
;
SettingsType
simulation_settings
=
SettingsType
:
:
kDefaultApmDesktop
;
}
;
class
FrameCounters
{
public
:
void
IncreaseRenderCounter
(
)
{
render_count_
.
fetch_add
(
1
)
;
}
void
IncreaseCaptureCounter
(
)
{
capture_count_
.
fetch_add
(
1
)
;
}
int
CaptureMinusRenderCounters
(
)
const
{
return
capture_count_
.
load
(
std
:
:
memory_order_acquire
)
-
render_count_
.
load
(
std
:
:
memory_order_acquire
)
;
}
int
RenderMinusCaptureCounters
(
)
const
{
return
-
CaptureMinusRenderCounters
(
)
;
}
bool
BothCountersExceedeThreshold
(
int
threshold
)
const
{
const
int
capture_count
=
capture_count_
.
load
(
std
:
:
memory_order_acquire
)
;
const
int
render_count
=
render_count_
.
load
(
std
:
:
memory_order_acquire
)
;
return
(
render_count
>
threshold
&
&
capture_count
>
threshold
)
;
}
private
:
std
:
:
atomic
<
int
>
render_count_
{
0
}
;
std
:
:
atomic
<
int
>
capture_count_
{
0
}
;
}
;
class
LockedFlag
{
public
:
bool
get_flag
(
)
const
{
return
flag_
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
set_flag
(
)
{
if
(
!
get_flag
(
)
)
{
int
zero
=
0
;
flag_
.
compare_exchange_strong
(
zero
1
)
;
}
}
private
:
std
:
:
atomic
<
int
>
flag_
{
0
}
;
}
;
class
TimedThreadApiProcessor
{
public
:
TimedThreadApiProcessor
(
ProcessorType
processor_type
Random
*
rand_gen
FrameCounters
*
shared_counters_state
LockedFlag
*
capture_call_checker
CallSimulator
*
test_framework
const
SimulationConfig
*
simulation_config
AudioProcessing
*
apm
int
num_durations_to_store
float
input_level
int
num_channels
)
:
rand_gen_
(
rand_gen
)
frame_counters_
(
shared_counters_state
)
capture_call_checker_
(
capture_call_checker
)
test_
(
test_framework
)
simulation_config_
(
simulation_config
)
apm_
(
apm
)
frame_data_
(
kMaxFrameSize
)
clock_
(
webrtc
:
:
Clock
:
:
GetRealTimeClock
(
)
)
num_durations_to_store_
(
num_durations_to_store
)
api_call_durations_
(
num_durations_to_store_
-
kNumInitializationFrames
)
samples_count_
(
0
)
input_level_
(
input_level
)
processor_type_
(
processor_type
)
num_channels_
(
num_channels
)
{
}
bool
Process
(
)
;
void
print_processor_statistics
(
absl
:
:
string_view
processor_name
)
const
{
const
std
:
:
string
modifier
=
"
_api_call_duration
"
;
const
std
:
:
string
sample_rate_name
=
"
_
"
+
std
:
:
to_string
(
simulation_config_
-
>
sample_rate_hz
)
+
"
Hz
"
;
GetGlobalMetricsLogger
(
)
-
>
LogMetric
(
"
apm_timing
"
+
sample_rate_name
processor_name
api_call_durations_
Unit
:
:
kMilliseconds
ImprovementDirection
:
:
kNeitherIsBetter
)
;
}
void
AddDuration
(
int64_t
duration
)
{
if
(
samples_count_
>
=
kNumInitializationFrames
&
&
samples_count_
<
num_durations_to_store_
)
{
api_call_durations_
.
AddSample
(
duration
)
;
}
samples_count_
+
+
;
}
private
:
static
const
int
kMaxCallDifference
=
10
;
static
const
int
kMaxFrameSize
=
480
;
static
const
int
kNumInitializationFrames
=
5
;
int
ProcessCapture
(
)
{
apm_
-
>
set_stream_delay_ms
(
30
)
;
const
int64_t
start_time
=
clock_
-
>
TimeInMicroseconds
(
)
;
const
int
result
=
apm_
-
>
ProcessStream
(
&
frame_data_
.
input_frame
[
0
]
frame_data_
.
input_stream_config
frame_data_
.
output_stream_config
&
frame_data_
.
output_frame
[
0
]
)
;
const
int64_t
end_time
=
clock_
-
>
TimeInMicroseconds
(
)
;
frame_counters_
-
>
IncreaseCaptureCounter
(
)
;
AddDuration
(
end_time
-
start_time
)
;
if
(
first_process_call_
)
{
capture_call_checker_
-
>
set_flag
(
)
;
first_process_call_
=
false
;
}
return
result
;
}
bool
ReadyToProcessCapture
(
)
{
return
(
frame_counters_
-
>
CaptureMinusRenderCounters
(
)
<
=
kMaxCallDifference
)
;
}
int
ProcessRender
(
)
{
const
int64_t
start_time
=
clock_
-
>
TimeInMicroseconds
(
)
;
const
int
result
=
apm_
-
>
ProcessReverseStream
(
&
frame_data_
.
input_frame
[
0
]
frame_data_
.
input_stream_config
frame_data_
.
output_stream_config
&
frame_data_
.
output_frame
[
0
]
)
;
const
int64_t
end_time
=
clock_
-
>
TimeInMicroseconds
(
)
;
frame_counters_
-
>
IncreaseRenderCounter
(
)
;
AddDuration
(
end_time
-
start_time
)
;
return
result
;
}
bool
ReadyToProcessRender
(
)
{
if
(
first_process_call_
&
&
!
capture_call_checker_
-
>
get_flag
(
)
)
{
return
false
;
}
if
(
frame_counters_
-
>
RenderMinusCaptureCounters
(
)
>
kMaxCallDifference
)
{
return
false
;
}
first_process_call_
=
false
;
return
true
;
}
void
PrepareFrame
(
)
{
auto
populate_audio_frame
=
[
]
(
float
amplitude
size_t
num_channels
size_t
samples_per_channel
Random
*
rand_gen
float
*
*
frame
)
{
for
(
size_t
ch
=
0
;
ch
<
num_channels
;
ch
+
+
)
{
for
(
size_t
k
=
0
;
k
<
samples_per_channel
;
k
+
+
)
{
frame
[
ch
]
[
k
]
=
amplitude
*
(
2
*
rand_gen
-
>
Rand
<
float
>
(
)
-
1
)
;
}
}
}
;
frame_data_
.
input_stream_config
.
set_sample_rate_hz
(
simulation_config_
-
>
sample_rate_hz
)
;
frame_data_
.
input_stream_config
.
set_num_channels
(
num_channels_
)
;
populate_audio_frame
(
input_level_
num_channels_
(
simulation_config_
-
>
sample_rate_hz
*
AudioProcessing
:
:
kChunkSizeMs
/
1000
)
rand_gen_
&
frame_data_
.
input_frame
[
0
]
)
;
frame_data_
.
output_stream_config
.
set_sample_rate_hz
(
simulation_config_
-
>
sample_rate_hz
)
;
frame_data_
.
output_stream_config
.
set_num_channels
(
1
)
;
}
bool
ReadyToProcess
(
)
{
switch
(
processor_type_
)
{
case
ProcessorType
:
:
kRender
:
return
ReadyToProcessRender
(
)
;
case
ProcessorType
:
:
kCapture
:
return
ReadyToProcessCapture
(
)
;
}
RTC_DCHECK_NOTREACHED
(
)
;
return
false
;
}
Random
*
rand_gen_
=
nullptr
;
FrameCounters
*
frame_counters_
=
nullptr
;
LockedFlag
*
capture_call_checker_
=
nullptr
;
CallSimulator
*
test_
=
nullptr
;
const
SimulationConfig
*
const
simulation_config_
=
nullptr
;
AudioProcessing
*
apm_
=
nullptr
;
AudioFrameData
frame_data_
;
webrtc
:
:
Clock
*
clock_
;
const
size_t
num_durations_to_store_
;
SamplesStatsCounter
api_call_durations_
;
size_t
samples_count_
=
0
;
const
float
input_level_
;
bool
first_process_call_
=
true
;
const
ProcessorType
processor_type_
;
const
int
num_channels_
=
1
;
}
;
class
CallSimulator
:
public
:
:
testing
:
:
TestWithParam
<
SimulationConfig
>
{
public
:
CallSimulator
(
)
:
rand_gen_
(
42U
)
simulation_config_
(
static_cast
<
SimulationConfig
>
(
GetParam
(
)
)
)
{
}
bool
Run
(
)
{
StartThreads
(
)
;
bool
result
=
test_complete_
.
Wait
(
kTestTimeout
)
;
StopThreads
(
)
;
render_thread_state_
-
>
print_processor_statistics
(
simulation_config_
.
SettingsDescription
(
)
+
"
_render
"
)
;
capture_thread_state_
-
>
print_processor_statistics
(
simulation_config_
.
SettingsDescription
(
)
+
"
_capture
"
)
;
return
result
;
}
bool
MaybeEndTest
(
)
{
if
(
frame_counters_
.
BothCountersExceedeThreshold
(
kMinNumFramesToProcess
)
)
{
test_complete_
.
Set
(
)
;
return
true
;
}
return
false
;
}
private
:
static
const
float
kCaptureInputFloatLevel
;
static
const
float
kRenderInputFloatLevel
;
static
const
int
kMinNumFramesToProcess
=
150
;
static
constexpr
TimeDelta
kTestTimeout
=
TimeDelta
:
:
Millis
(
3
*
10
*
kMinNumFramesToProcess
)
;
void
StopThreads
(
)
{
render_thread_
.
Finalize
(
)
;
capture_thread_
.
Finalize
(
)
;
}
void
SetUp
(
)
override
{
auto
set_default_desktop_apm_runtime_settings
=
[
]
(
AudioProcessing
*
apm
)
{
AudioProcessing
:
:
Config
apm_config
=
apm
-
>
GetConfig
(
)
;
apm_config
.
echo_canceller
.
enabled
=
true
;
apm_config
.
echo_canceller
.
mobile_mode
=
false
;
apm_config
.
noise_suppression
.
enabled
=
true
;
apm_config
.
gain_controller1
.
enabled
=
true
;
apm_config
.
gain_controller1
.
mode
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kAdaptiveDigital
;
apm
-
>
ApplyConfig
(
apm_config
)
;
}
;
auto
set_default_mobile_apm_runtime_settings
=
[
]
(
AudioProcessing
*
apm
)
{
AudioProcessing
:
:
Config
apm_config
=
apm
-
>
GetConfig
(
)
;
apm_config
.
echo_canceller
.
enabled
=
true
;
apm_config
.
echo_canceller
.
mobile_mode
=
true
;
apm_config
.
noise_suppression
.
enabled
=
true
;
apm_config
.
gain_controller1
.
mode
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kAdaptiveDigital
;
apm
-
>
ApplyConfig
(
apm_config
)
;
}
;
auto
turn_off_default_apm_runtime_settings
=
[
]
(
AudioProcessing
*
apm
)
{
AudioProcessing
:
:
Config
apm_config
=
apm
-
>
GetConfig
(
)
;
apm_config
.
echo_canceller
.
enabled
=
false
;
apm_config
.
gain_controller1
.
enabled
=
false
;
apm_config
.
noise_suppression
.
enabled
=
false
;
apm
-
>
ApplyConfig
(
apm_config
)
;
}
;
int
num_capture_channels
=
1
;
switch
(
simulation_config_
.
simulation_settings
)
{
case
SettingsType
:
:
kDefaultApmMobile
:
{
apm_
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
ASSERT_TRUE
(
!
!
apm_
)
;
set_default_mobile_apm_runtime_settings
(
apm_
.
get
(
)
)
;
break
;
}
case
SettingsType
:
:
kDefaultApmDesktop
:
{
apm_
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
ASSERT_TRUE
(
!
!
apm_
)
;
set_default_desktop_apm_runtime_settings
(
apm_
.
get
(
)
)
;
break
;
}
case
SettingsType
:
:
kAllSubmodulesTurnedOff
:
{
apm_
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
ASSERT_TRUE
(
!
!
apm_
)
;
turn_off_default_apm_runtime_settings
(
apm_
.
get
(
)
)
;
break
;
}
case
SettingsType
:
:
kDefaultApmDesktopWithoutDelayAgnostic
:
{
apm_
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
ASSERT_TRUE
(
!
!
apm_
)
;
set_default_desktop_apm_runtime_settings
(
apm_
.
get
(
)
)
;
break
;
}
case
SettingsType
:
:
kDefaultApmDesktopWithoutExtendedFilter
:
{
apm_
=
BuiltinAudioProcessingBuilder
(
)
.
Build
(
CreateEnvironment
(
)
)
;
ASSERT_TRUE
(
!
!
apm_
)
;
set_default_desktop_apm_runtime_settings
(
apm_
.
get
(
)
)
;
break
;
}
}
render_thread_state_
.
reset
(
new
TimedThreadApiProcessor
(
ProcessorType
:
:
kRender
&
rand_gen_
&
frame_counters_
&
capture_call_checker_
this
&
simulation_config_
apm_
.
get
(
)
kMinNumFramesToProcess
kRenderInputFloatLevel
1
)
)
;
capture_thread_state_
.
reset
(
new
TimedThreadApiProcessor
(
ProcessorType
:
:
kCapture
&
rand_gen_
&
frame_counters_
&
capture_call_checker_
this
&
simulation_config_
apm_
.
get
(
)
kMinNumFramesToProcess
kCaptureInputFloatLevel
num_capture_channels
)
)
;
}
void
StartThreads
(
)
{
const
auto
attributes
=
ThreadAttributes
(
)
.
SetPriority
(
ThreadPriority
:
:
kRealtime
)
;
render_thread_
=
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
render_thread_state_
-
>
Process
(
)
)
{
}
}
"
render
"
attributes
)
;
capture_thread_
=
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
capture_thread_state_
-
>
Process
(
)
)
{
}
}
"
capture
"
attributes
)
;
}
Event
test_complete_
;
Random
rand_gen_
;
scoped_refptr
<
AudioProcessing
>
apm_
;
const
SimulationConfig
simulation_config_
;
FrameCounters
frame_counters_
;
LockedFlag
capture_call_checker_
;
std
:
:
unique_ptr
<
TimedThreadApiProcessor
>
render_thread_state_
;
std
:
:
unique_ptr
<
TimedThreadApiProcessor
>
capture_thread_state_
;
PlatformThread
render_thread_
;
PlatformThread
capture_thread_
;
}
;
bool
TimedThreadApiProcessor
:
:
Process
(
)
{
PrepareFrame
(
)
;
while
(
!
ReadyToProcess
(
)
)
{
}
int
result
=
AudioProcessing
:
:
kNoError
;
switch
(
processor_type_
)
{
case
ProcessorType
:
:
kRender
:
result
=
ProcessRender
(
)
;
break
;
case
ProcessorType
:
:
kCapture
:
result
=
ProcessCapture
(
)
;
break
;
}
EXPECT_EQ
(
result
AudioProcessing
:
:
kNoError
)
;
return
!
test_
-
>
MaybeEndTest
(
)
;
}
const
float
CallSimulator
:
:
kRenderInputFloatLevel
=
0
.
5f
;
const
float
CallSimulator
:
:
kCaptureInputFloatLevel
=
0
.
03125f
;
}
TEST_P
(
CallSimulator
ApiCallDurationTest
)
{
EXPECT_TRUE
(
Run
(
)
)
;
}
INSTANTIATE_TEST_SUITE_P
(
AudioProcessingPerformanceTest
CallSimulator
:
:
testing
:
:
ValuesIn
(
SimulationConfig
:
:
GenerateSimulationConfigs
(
)
)
)
;
}
