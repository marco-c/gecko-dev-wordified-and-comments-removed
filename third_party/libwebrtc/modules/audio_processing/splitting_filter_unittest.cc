#
include
"
modules
/
audio_processing
/
splitting_filter
.
h
"
#
include
<
cmath
>
#
include
<
cstddef
>
#
include
<
cstring
>
#
include
<
numbers
>
#
include
"
common_audio
/
channel_buffer
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
constexpr
size_t
kSamplesPer16kHzChannel
=
160
;
constexpr
size_t
kSamplesPer48kHzChannel
=
480
;
}
TEST
(
SplittingFilterTest
SplitsIntoThreeBandsAndReconstructs
)
{
static
const
int
kChannels
=
1
;
static
const
int
kSampleRateHz
=
48000
;
static
const
size_t
kNumBands
=
3
;
static
const
int
kFrequenciesHz
[
kNumBands
]
=
{
1000
12000
18000
}
;
static
const
float
kAmplitude
=
8192
.
f
;
static
const
size_t
kChunks
=
8
;
SplittingFilter
splitting_filter
(
kChannels
kNumBands
kSamplesPer48kHzChannel
)
;
ChannelBuffer
<
float
>
in_data
(
kSamplesPer48kHzChannel
kChannels
kNumBands
)
;
ChannelBuffer
<
float
>
bands
(
kSamplesPer48kHzChannel
kChannels
kNumBands
)
;
ChannelBuffer
<
float
>
out_data
(
kSamplesPer48kHzChannel
kChannels
kNumBands
)
;
for
(
size_t
i
=
0
;
i
<
kChunks
;
+
+
i
)
{
bool
is_present
[
kNumBands
]
;
memset
(
in_data
.
channels
(
)
[
0
]
0
kSamplesPer48kHzChannel
*
sizeof
(
in_data
.
channels
(
)
[
0
]
[
0
]
)
)
;
for
(
size_t
j
=
0
;
j
<
kNumBands
;
+
+
j
)
{
is_present
[
j
]
=
i
&
(
static_cast
<
size_t
>
(
1
)
<
<
j
)
;
float
amplitude
=
is_present
[
j
]
?
kAmplitude
:
0
.
f
;
for
(
size_t
k
=
0
;
k
<
kSamplesPer48kHzChannel
;
+
+
k
)
{
in_data
.
channels
(
)
[
0
]
[
k
]
+
=
amplitude
*
sin
(
2
.
f
*
std
:
:
numbers
:
:
pi
*
kFrequenciesHz
[
j
]
*
(
i
*
kSamplesPer48kHzChannel
+
k
)
/
kSampleRateHz
)
;
}
}
splitting_filter
.
Analysis
(
&
in_data
&
bands
)
;
float
energy
[
kNumBands
]
;
for
(
size_t
j
=
0
;
j
<
kNumBands
;
+
+
j
)
{
energy
[
j
]
=
0
.
f
;
for
(
size_t
k
=
0
;
k
<
kSamplesPer16kHzChannel
;
+
+
k
)
{
energy
[
j
]
+
=
bands
.
channels
(
j
)
[
0
]
[
k
]
*
bands
.
channels
(
j
)
[
0
]
[
k
]
;
}
energy
[
j
]
/
=
kSamplesPer16kHzChannel
;
if
(
is_present
[
j
]
)
{
EXPECT_GT
(
energy
[
j
]
kAmplitude
*
kAmplitude
/
4
)
;
}
else
{
EXPECT_LT
(
energy
[
j
]
kAmplitude
*
kAmplitude
/
4
)
;
}
}
splitting_filter
.
Synthesis
(
&
bands
&
out_data
)
;
float
xcorr
=
0
.
f
;
for
(
size_t
delay
=
0
;
delay
<
kSamplesPer48kHzChannel
;
+
+
delay
)
{
float
tmpcorr
=
0
.
f
;
for
(
size_t
j
=
delay
;
j
<
kSamplesPer48kHzChannel
;
+
+
j
)
{
tmpcorr
+
=
in_data
.
channels
(
)
[
0
]
[
j
-
delay
]
*
out_data
.
channels
(
)
[
0
]
[
j
]
;
}
tmpcorr
/
=
kSamplesPer48kHzChannel
;
if
(
tmpcorr
>
xcorr
)
{
xcorr
=
tmpcorr
;
}
}
bool
any_present
=
false
;
for
(
size_t
j
=
0
;
j
<
kNumBands
;
+
+
j
)
{
any_present
|
=
is_present
[
j
]
;
}
if
(
any_present
)
{
EXPECT_GT
(
xcorr
kAmplitude
*
kAmplitude
/
4
)
;
}
}
}
}
