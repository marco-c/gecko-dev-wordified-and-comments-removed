#
ifndef
MODULES_AUDIO_PROCESSING_INCLUDE_AUDIO_PROCESSING_H_
#
define
MODULES_AUDIO_PROCESSING_INCLUDE_AUDIO_PROCESSING_H_
#
include
<
math
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio
/
echo_canceller3_config
.
h
"
#
include
"
api
/
audio
/
echo_control
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing_statistics
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
config
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
deprecation
.
h
"
#
include
"
rtc_base
/
ref_count
.
h
"
#
include
"
rtc_base
/
system
/
file_wrapper
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
rtc
{
class
TaskQueue
;
}
namespace
webrtc
{
class
AecDump
;
class
AudioBuffer
;
class
StreamConfig
;
class
ProcessingConfig
;
class
EchoDetector
;
class
CustomAudioAnalyzer
;
class
CustomProcessing
;
#
if
defined
(
WEBRTC_CHROMIUM_BUILD
)
static
const
int
kAgcStartupMinVolume
=
85
;
#
else
static
const
int
kAgcStartupMinVolume
=
0
;
#
endif
static
constexpr
int
kClippedLevelMin
=
70
;
struct
ExperimentalAgc
{
ExperimentalAgc
(
)
=
default
;
explicit
ExperimentalAgc
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
ExperimentalAgc
(
bool
enabled
int
startup_min_volume
)
:
enabled
(
enabled
)
startup_min_volume
(
startup_min_volume
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kExperimentalAgc
;
bool
enabled
=
true
;
int
startup_min_volume
=
kAgcStartupMinVolume
;
int
clipped_level_min
=
kClippedLevelMin
;
bool
digital_adaptive_disabled
=
false
;
}
;
struct
ExperimentalNs
{
ExperimentalNs
(
)
:
enabled
(
false
)
{
}
explicit
ExperimentalNs
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kExperimentalNs
;
bool
enabled
;
}
;
class
RTC_EXPORT
AudioProcessing
:
public
rtc
:
:
RefCountInterface
{
public
:
struct
RTC_EXPORT
Config
{
struct
RTC_EXPORT
Pipeline
{
int
maximum_internal_processing_rate
=
48000
;
bool
multi_channel_render
=
false
;
bool
multi_channel_capture
=
false
;
}
pipeline
;
struct
PreAmplifier
{
bool
enabled
=
false
;
float
fixed_gain_factor
=
1
.
f
;
}
pre_amplifier
;
struct
HighPassFilter
{
bool
enabled
=
false
;
bool
apply_in_full_band
=
true
;
}
high_pass_filter
;
struct
EchoCanceller
{
bool
enabled
=
false
;
bool
mobile_mode
=
false
;
bool
export_linear_aec_output
=
false
;
bool
enforce_high_pass_filtering
=
true
;
}
echo_canceller
;
struct
NoiseSuppression
{
bool
enabled
=
false
;
enum
Level
{
kLow
kModerate
kHigh
kVeryHigh
}
;
Level
level
=
kModerate
;
bool
analyze_linear_aec_output_when_available
=
false
;
}
noise_suppression
;
struct
TransientSuppression
{
bool
enabled
=
false
;
}
transient_suppression
;
struct
VoiceDetection
{
bool
enabled
=
false
;
}
voice_detection
;
struct
GainController1
{
bool
operator
=
=
(
const
GainController1
&
rhs
)
const
;
bool
operator
!
=
(
const
GainController1
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
enabled
=
false
;
enum
Mode
{
kAdaptiveAnalog
kAdaptiveDigital
kFixedDigital
}
;
Mode
mode
=
kAdaptiveAnalog
;
int
target_level_dbfs
=
3
;
int
compression_gain_db
=
9
;
bool
enable_limiter
=
true
;
int
analog_level_minimum
=
0
;
int
analog_level_maximum
=
255
;
struct
AnalogGainController
{
bool
enabled
=
true
;
int
startup_min_volume
=
kAgcStartupMinVolume
;
int
clipped_level_min
=
kClippedLevelMin
;
bool
enable_digital_adaptive
=
true
;
}
analog_gain_controller
;
}
gain_controller1
;
struct
GainController2
{
bool
operator
=
=
(
const
GainController2
&
rhs
)
const
;
bool
operator
!
=
(
const
GainController2
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
enum
LevelEstimator
{
kRms
kPeak
}
;
bool
enabled
=
false
;
struct
FixedDigital
{
float
gain_db
=
0
.
f
;
}
fixed_digital
;
struct
AdaptiveDigital
{
bool
enabled
=
false
;
float
vad_probability_attack
=
1
.
f
;
LevelEstimator
level_estimator
=
kRms
;
int
level_estimator_adjacent_speech_frames_threshold
=
1
;
bool
use_saturation_protector
=
true
;
float
initial_saturation_margin_db
=
20
.
f
;
float
extra_saturation_margin_db
=
2
.
f
;
int
gain_applier_adjacent_speech_frames_threshold
=
1
;
float
max_gain_change_db_per_second
=
3
.
f
;
float
max_output_noise_level_dbfs
=
-
50
.
f
;
bool
sse2_allowed
=
true
;
bool
avx2_allowed
=
true
;
bool
neon_allowed
=
true
;
}
adaptive_digital
;
}
gain_controller2
;
struct
ResidualEchoDetector
{
bool
enabled
=
true
;
}
residual_echo_detector
;
struct
LevelEstimation
{
bool
enabled
=
false
;
}
level_estimation
;
std
:
:
string
ToString
(
)
const
;
}
;
enum
ChannelLayout
{
kMono
kStereo
kMonoAndKeyboard
kStereoAndKeyboard
}
;
class
RuntimeSetting
{
public
:
enum
class
Type
{
kNotSpecified
kCapturePreGain
kCaptureCompressionGain
kCaptureFixedPostGain
kPlayoutVolumeChange
kCustomRenderProcessingRuntimeSetting
kPlayoutAudioDeviceChange
kCaptureOutputUsed
}
;
struct
PlayoutAudioDeviceInfo
{
int
id
;
int
max_volume
;
}
;
RuntimeSetting
(
)
:
type_
(
Type
:
:
kNotSpecified
)
value_
(
0
.
f
)
{
}
~
RuntimeSetting
(
)
=
default
;
static
RuntimeSetting
CreateCapturePreGain
(
float
gain
)
{
RTC_DCHECK_GE
(
gain
1
.
f
)
<
<
"
Attenuation
is
not
allowed
.
"
;
return
{
Type
:
:
kCapturePreGain
gain
}
;
}
static
RuntimeSetting
CreateCompressionGainDb
(
int
gain_db
)
{
RTC_DCHECK_GE
(
gain_db
0
)
;
RTC_DCHECK_LE
(
gain_db
90
)
;
return
{
Type
:
:
kCaptureCompressionGain
static_cast
<
float
>
(
gain_db
)
}
;
}
static
RuntimeSetting
CreateCaptureFixedPostGain
(
float
gain_db
)
{
RTC_DCHECK_GE
(
gain_db
0
.
f
)
;
RTC_DCHECK_LE
(
gain_db
90
.
f
)
;
return
{
Type
:
:
kCaptureFixedPostGain
gain_db
}
;
}
static
RuntimeSetting
CreatePlayoutAudioDeviceChange
(
PlayoutAudioDeviceInfo
audio_device
)
{
return
{
Type
:
:
kPlayoutAudioDeviceChange
audio_device
}
;
}
static
RuntimeSetting
CreatePlayoutVolumeChange
(
int
volume
)
{
return
{
Type
:
:
kPlayoutVolumeChange
volume
}
;
}
static
RuntimeSetting
CreateCustomRenderSetting
(
float
payload
)
{
return
{
Type
:
:
kCustomRenderProcessingRuntimeSetting
payload
}
;
}
static
RuntimeSetting
CreateCaptureOutputUsedSetting
(
bool
payload
)
{
return
{
Type
:
:
kCaptureOutputUsed
payload
}
;
}
Type
type
(
)
const
{
return
type_
;
}
void
GetFloat
(
float
*
value
)
const
{
RTC_DCHECK
(
value
)
;
*
value
=
value_
.
float_value
;
}
void
GetInt
(
int
*
value
)
const
{
RTC_DCHECK
(
value
)
;
*
value
=
value_
.
int_value
;
}
void
GetBool
(
bool
*
value
)
const
{
RTC_DCHECK
(
value
)
;
*
value
=
value_
.
bool_value
;
}
void
GetPlayoutAudioDeviceInfo
(
PlayoutAudioDeviceInfo
*
value
)
const
{
RTC_DCHECK
(
value
)
;
*
value
=
value_
.
playout_audio_device_info
;
}
private
:
RuntimeSetting
(
Type
id
float
value
)
:
type_
(
id
)
value_
(
value
)
{
}
RuntimeSetting
(
Type
id
int
value
)
:
type_
(
id
)
value_
(
value
)
{
}
RuntimeSetting
(
Type
id
PlayoutAudioDeviceInfo
value
)
:
type_
(
id
)
value_
(
value
)
{
}
Type
type_
;
union
U
{
U
(
)
{
}
U
(
int
value
)
:
int_value
(
value
)
{
}
U
(
float
value
)
:
float_value
(
value
)
{
}
U
(
PlayoutAudioDeviceInfo
value
)
:
playout_audio_device_info
(
value
)
{
}
float
float_value
;
int
int_value
;
bool
bool_value
;
PlayoutAudioDeviceInfo
playout_audio_device_info
;
}
value_
;
}
;
~
AudioProcessing
(
)
override
{
}
virtual
int
Initialize
(
)
=
0
;
virtual
int
Initialize
(
const
ProcessingConfig
&
processing_config
)
=
0
;
virtual
int
Initialize
(
int
capture_input_sample_rate_hz
int
capture_output_sample_rate_hz
int
render_sample_rate_hz
ChannelLayout
capture_input_layout
ChannelLayout
capture_output_layout
ChannelLayout
render_input_layout
)
=
0
;
virtual
void
ApplyConfig
(
const
Config
&
config
)
=
0
;
virtual
int
proc_sample_rate_hz
(
)
const
=
0
;
virtual
int
proc_split_sample_rate_hz
(
)
const
=
0
;
virtual
size_t
num_input_channels
(
)
const
=
0
;
virtual
size_t
num_proc_channels
(
)
const
=
0
;
virtual
size_t
num_output_channels
(
)
const
=
0
;
virtual
size_t
num_reverse_channels
(
)
const
=
0
;
virtual
void
set_output_will_be_muted
(
bool
muted
)
=
0
;
virtual
void
SetRuntimeSetting
(
RuntimeSetting
setting
)
=
0
;
virtual
bool
PostRuntimeSetting
(
RuntimeSetting
setting
)
{
return
false
;
}
virtual
int
ProcessStream
(
const
int16_t
*
const
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
int16_t
*
const
dest
)
=
0
;
virtual
int
ProcessStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
=
0
;
virtual
int
ProcessReverseStream
(
const
int16_t
*
const
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
int16_t
*
const
dest
)
=
0
;
virtual
int
ProcessReverseStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
=
0
;
virtual
int
AnalyzeReverseStream
(
const
float
*
const
*
data
const
StreamConfig
&
reverse_config
)
=
0
;
virtual
bool
GetLinearAecOutput
(
rtc
:
:
ArrayView
<
std
:
:
array
<
float
160
>
>
linear_output
)
const
=
0
;
virtual
void
set_stream_analog_level
(
int
level
)
=
0
;
virtual
int
recommended_stream_analog_level
(
)
const
=
0
;
virtual
int
set_stream_delay_ms
(
int
delay
)
=
0
;
virtual
int
stream_delay_ms
(
)
const
=
0
;
virtual
void
set_stream_key_pressed
(
bool
key_pressed
)
=
0
;
virtual
bool
CreateAndAttachAecDump
(
const
std
:
:
string
&
file_name
int64_t
max_log_size_bytes
rtc
:
:
TaskQueue
*
worker_queue
)
=
0
;
virtual
bool
CreateAndAttachAecDump
(
FILE
*
handle
int64_t
max_log_size_bytes
rtc
:
:
TaskQueue
*
worker_queue
)
=
0
;
virtual
void
AttachAecDump
(
std
:
:
unique_ptr
<
AecDump
>
aec_dump
)
=
0
;
virtual
void
DetachAecDump
(
)
=
0
;
virtual
AudioProcessingStats
GetStatistics
(
)
=
0
;
virtual
AudioProcessingStats
GetStatistics
(
bool
has_remote_tracks
)
=
0
;
virtual
AudioProcessing
:
:
Config
GetConfig
(
)
const
=
0
;
enum
Error
{
kNoError
=
0
kUnspecifiedError
=
-
1
kCreationFailedError
=
-
2
kUnsupportedComponentError
=
-
3
kUnsupportedFunctionError
=
-
4
kNullPointerError
=
-
5
kBadParameterError
=
-
6
kBadSampleRateError
=
-
7
kBadDataLengthError
=
-
8
kBadNumberChannelsError
=
-
9
kFileError
=
-
10
kStreamParameterNotSetError
=
-
11
kNotEnabledError
=
-
12
kBadStreamParameterWarning
=
-
13
}
;
enum
NativeRate
{
kSampleRate8kHz
=
8000
kSampleRate16kHz
=
16000
kSampleRate32kHz
=
32000
kSampleRate44_1kHz
=
44100
kSampleRate48kHz
=
48000
}
;
static
constexpr
int
kNativeSampleRatesHz
[
4
]
=
{
kSampleRate8kHz
kSampleRate16kHz
kSampleRate32kHz
kSampleRate48kHz
}
;
static
constexpr
size_t
kNumNativeSampleRates
=
arraysize
(
kNativeSampleRatesHz
)
;
static
constexpr
int
kMaxNativeSampleRateHz
=
kNativeSampleRatesHz
[
kNumNativeSampleRates
-
1
]
;
static
constexpr
int
kChunkSizeMs
=
10
;
}
;
class
RTC_EXPORT
AudioProcessingBuilder
{
public
:
AudioProcessingBuilder
(
)
;
~
AudioProcessingBuilder
(
)
;
AudioProcessingBuilder
&
SetEchoControlFactory
(
std
:
:
unique_ptr
<
EchoControlFactory
>
echo_control_factory
)
{
echo_control_factory_
=
std
:
:
move
(
echo_control_factory
)
;
return
*
this
;
}
AudioProcessingBuilder
&
SetCapturePostProcessing
(
std
:
:
unique_ptr
<
CustomProcessing
>
capture_post_processing
)
{
capture_post_processing_
=
std
:
:
move
(
capture_post_processing
)
;
return
*
this
;
}
AudioProcessingBuilder
&
SetRenderPreProcessing
(
std
:
:
unique_ptr
<
CustomProcessing
>
render_pre_processing
)
{
render_pre_processing_
=
std
:
:
move
(
render_pre_processing
)
;
return
*
this
;
}
AudioProcessingBuilder
&
SetEchoDetector
(
rtc
:
:
scoped_refptr
<
EchoDetector
>
echo_detector
)
{
echo_detector_
=
std
:
:
move
(
echo_detector
)
;
return
*
this
;
}
AudioProcessingBuilder
&
SetCaptureAnalyzer
(
std
:
:
unique_ptr
<
CustomAudioAnalyzer
>
capture_analyzer
)
{
capture_analyzer_
=
std
:
:
move
(
capture_analyzer
)
;
return
*
this
;
}
AudioProcessing
*
Create
(
)
;
AudioProcessing
*
Create
(
const
webrtc
:
:
Config
&
config
)
;
private
:
std
:
:
unique_ptr
<
EchoControlFactory
>
echo_control_factory_
;
std
:
:
unique_ptr
<
CustomProcessing
>
capture_post_processing_
;
std
:
:
unique_ptr
<
CustomProcessing
>
render_pre_processing_
;
rtc
:
:
scoped_refptr
<
EchoDetector
>
echo_detector_
;
std
:
:
unique_ptr
<
CustomAudioAnalyzer
>
capture_analyzer_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AudioProcessingBuilder
)
;
}
;
class
StreamConfig
{
public
:
StreamConfig
(
int
sample_rate_hz
=
0
size_t
num_channels
=
0
bool
has_keyboard
=
false
)
:
sample_rate_hz_
(
sample_rate_hz
)
num_channels_
(
num_channels
)
has_keyboard_
(
has_keyboard
)
num_frames_
(
calculate_frames
(
sample_rate_hz
)
)
{
}
void
set_sample_rate_hz
(
int
value
)
{
sample_rate_hz_
=
value
;
num_frames_
=
calculate_frames
(
value
)
;
}
void
set_num_channels
(
size_t
value
)
{
num_channels_
=
value
;
}
void
set_has_keyboard
(
bool
value
)
{
has_keyboard_
=
value
;
}
int
sample_rate_hz
(
)
const
{
return
sample_rate_hz_
;
}
size_t
num_channels
(
)
const
{
return
num_channels_
;
}
bool
has_keyboard
(
)
const
{
return
has_keyboard_
;
}
size_t
num_frames
(
)
const
{
return
num_frames_
;
}
size_t
num_samples
(
)
const
{
return
num_channels_
*
num_frames_
;
}
bool
operator
=
=
(
const
StreamConfig
&
other
)
const
{
return
sample_rate_hz_
=
=
other
.
sample_rate_hz_
&
&
num_channels_
=
=
other
.
num_channels_
&
&
has_keyboard_
=
=
other
.
has_keyboard_
;
}
bool
operator
!
=
(
const
StreamConfig
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
private
:
static
size_t
calculate_frames
(
int
sample_rate_hz
)
{
return
static_cast
<
size_t
>
(
AudioProcessing
:
:
kChunkSizeMs
*
sample_rate_hz
/
1000
)
;
}
int
sample_rate_hz_
;
size_t
num_channels_
;
bool
has_keyboard_
;
size_t
num_frames_
;
}
;
class
ProcessingConfig
{
public
:
enum
StreamName
{
kInputStream
kOutputStream
kReverseInputStream
kReverseOutputStream
kNumStreamNames
}
;
const
StreamConfig
&
input_stream
(
)
const
{
return
streams
[
StreamName
:
:
kInputStream
]
;
}
const
StreamConfig
&
output_stream
(
)
const
{
return
streams
[
StreamName
:
:
kOutputStream
]
;
}
const
StreamConfig
&
reverse_input_stream
(
)
const
{
return
streams
[
StreamName
:
:
kReverseInputStream
]
;
}
const
StreamConfig
&
reverse_output_stream
(
)
const
{
return
streams
[
StreamName
:
:
kReverseOutputStream
]
;
}
StreamConfig
&
input_stream
(
)
{
return
streams
[
StreamName
:
:
kInputStream
]
;
}
StreamConfig
&
output_stream
(
)
{
return
streams
[
StreamName
:
:
kOutputStream
]
;
}
StreamConfig
&
reverse_input_stream
(
)
{
return
streams
[
StreamName
:
:
kReverseInputStream
]
;
}
StreamConfig
&
reverse_output_stream
(
)
{
return
streams
[
StreamName
:
:
kReverseOutputStream
]
;
}
bool
operator
=
=
(
const
ProcessingConfig
&
other
)
const
{
for
(
int
i
=
0
;
i
<
StreamName
:
:
kNumStreamNames
;
+
+
i
)
{
if
(
this
-
>
streams
[
i
]
!
=
other
.
streams
[
i
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
ProcessingConfig
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
StreamConfig
streams
[
StreamName
:
:
kNumStreamNames
]
;
}
;
class
CustomAudioAnalyzer
{
public
:
virtual
void
Initialize
(
int
sample_rate_hz
int
num_channels
)
=
0
;
virtual
void
Analyze
(
const
AudioBuffer
*
audio
)
=
0
;
virtual
std
:
:
string
ToString
(
)
const
=
0
;
virtual
~
CustomAudioAnalyzer
(
)
{
}
}
;
class
CustomProcessing
{
public
:
virtual
void
Initialize
(
int
sample_rate_hz
int
num_channels
)
=
0
;
virtual
void
Process
(
AudioBuffer
*
audio
)
=
0
;
virtual
std
:
:
string
ToString
(
)
const
=
0
;
virtual
void
SetRuntimeSetting
(
AudioProcessing
:
:
RuntimeSetting
setting
)
;
virtual
~
CustomProcessing
(
)
{
}
}
;
class
EchoDetector
:
public
rtc
:
:
RefCountInterface
{
public
:
virtual
void
Initialize
(
int
capture_sample_rate_hz
int
num_capture_channels
int
render_sample_rate_hz
int
num_render_channels
)
=
0
;
virtual
void
AnalyzeRenderAudio
(
rtc
:
:
ArrayView
<
const
float
>
render_audio
)
=
0
;
virtual
void
AnalyzeCaptureAudio
(
rtc
:
:
ArrayView
<
const
float
>
capture_audio
)
=
0
;
static
void
PackRenderAudioBuffer
(
AudioBuffer
*
audio
std
:
:
vector
<
float
>
*
packed_buffer
)
;
struct
Metrics
{
absl
:
:
optional
<
double
>
echo_likelihood
;
absl
:
:
optional
<
double
>
echo_likelihood_recent_max
;
}
;
virtual
Metrics
GetMetrics
(
)
const
=
0
;
}
;
}
#
endif
