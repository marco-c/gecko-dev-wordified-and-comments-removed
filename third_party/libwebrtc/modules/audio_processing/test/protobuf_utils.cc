#
include
"
modules
/
audio_processing
/
test
/
protobuf_utils
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstdio
>
#
include
<
memory
>
#
include
<
sstream
>
#
include
"
rtc_base
/
protobuf_utils
.
h
"
#
include
"
rtc_base
/
system
/
arch
.
h
"
namespace
{
size_t
ReadMessageBytesFromString
(
std
:
:
stringstream
*
input
std
:
:
unique_ptr
<
uint8_t
[
]
>
*
bytes
)
{
int32_t
size
=
0
;
input
-
>
read
(
reinterpret_cast
<
char
*
>
(
&
size
)
sizeof
(
int32_t
)
)
;
int32_t
size_read
=
input
-
>
gcount
(
)
;
if
(
size_read
!
=
sizeof
(
int32_t
)
)
return
0
;
if
(
size
<
=
0
)
return
0
;
*
bytes
=
std
:
:
make_unique
<
uint8_t
[
]
>
(
size
)
;
input
-
>
read
(
reinterpret_cast
<
char
*
>
(
bytes
-
>
get
(
)
)
size
*
sizeof
(
(
*
bytes
)
[
0
]
)
)
;
size_read
=
input
-
>
gcount
(
)
;
return
size_read
=
=
size
?
size
:
0
;
}
}
namespace
webrtc
{
size_t
ReadMessageBytesFromFile
(
FILE
*
file
std
:
:
unique_ptr
<
uint8_t
[
]
>
*
bytes
)
{
#
ifndef
WEBRTC_ARCH_LITTLE_ENDIAN
#
error
"
Need
to
convert
messsage
from
little
-
endian
.
"
#
endif
int32_t
size
=
0
;
if
(
fread
(
&
size
sizeof
(
size
)
1
file
)
!
=
1
)
return
0
;
if
(
size
<
=
0
)
return
0
;
*
bytes
=
std
:
:
make_unique
<
uint8_t
[
]
>
(
size
)
;
return
fread
(
bytes
-
>
get
(
)
sizeof
(
(
*
bytes
)
[
0
]
)
size
file
)
;
}
bool
ReadMessageFromFile
(
FILE
*
file
MessageLite
*
msg
)
{
std
:
:
unique_ptr
<
uint8_t
[
]
>
bytes
;
size_t
size
=
ReadMessageBytesFromFile
(
file
&
bytes
)
;
if
(
!
size
)
return
false
;
msg
-
>
Clear
(
)
;
return
msg
-
>
ParseFromArray
(
bytes
.
get
(
)
size
)
;
}
bool
ReadMessageFromString
(
std
:
:
stringstream
*
input
MessageLite
*
msg
)
{
std
:
:
unique_ptr
<
uint8_t
[
]
>
bytes
;
size_t
size
=
ReadMessageBytesFromString
(
input
&
bytes
)
;
if
(
!
size
)
return
false
;
msg
-
>
Clear
(
)
;
return
msg
-
>
ParseFromArray
(
bytes
.
get
(
)
size
)
;
}
}
