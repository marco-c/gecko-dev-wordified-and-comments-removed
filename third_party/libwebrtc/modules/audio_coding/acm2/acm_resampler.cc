#
include
"
modules
/
audio_coding
/
acm2
/
acm_resampler
.
h
"
#
include
<
array
>
#
include
<
cstdint
>
#
include
"
api
/
audio
/
audio_frame
.
h
"
#
include
"
api
/
audio
/
audio_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
acm2
{
ResamplerHelper
:
:
ResamplerHelper
(
)
{
ClearSamples
(
last_audio_buffer_
)
;
}
bool
ResamplerHelper
:
:
MaybeResample
(
int
desired_sample_rate_hz
AudioFrame
*
audio_frame
)
{
const
int
current_sample_rate_hz
=
audio_frame
-
>
sample_rate_hz_
;
RTC_DCHECK_NE
(
current_sample_rate_hz
0
)
;
RTC_DCHECK_GT
(
desired_sample_rate_hz
0
)
;
const
bool
need_resampling
=
(
desired_sample_rate_hz
!
=
-
1
)
&
&
(
current_sample_rate_hz
!
=
desired_sample_rate_hz
)
;
if
(
need_resampling
&
&
!
resampled_last_output_frame_
)
{
InterleavedView
<
const
int16_t
>
src
(
last_audio_buffer_
.
data
(
)
audio_frame
-
>
samples_per_channel
(
)
audio_frame
-
>
num_channels
(
)
)
;
std
:
:
array
<
int16_t
AudioFrame
:
:
kMaxDataSizeSamples
>
temp_output
;
InterleavedView
<
int16_t
>
dst
(
temp_output
.
data
(
)
SampleRateToDefaultChannelSize
(
desired_sample_rate_hz
)
audio_frame
-
>
num_channels_
)
;
resampler_
.
Resample
(
src
dst
)
;
}
if
(
need_resampling
)
{
InterleavedView
<
const
int16_t
>
src
=
audio_frame
-
>
data_view
(
)
;
audio_frame
-
>
SetSampleRateAndChannelSize
(
desired_sample_rate_hz
)
;
InterleavedView
<
int16_t
>
dst
=
audio_frame
-
>
mutable_data
(
audio_frame
-
>
samples_per_channel
(
)
audio_frame
-
>
num_channels
(
)
)
;
resampler_
.
Resample
(
src
dst
)
;
resampled_last_output_frame_
=
true
;
}
else
{
resampled_last_output_frame_
=
false
;
}
InterleavedView
<
int16_t
>
dst
(
last_audio_buffer_
.
data
(
)
audio_frame
-
>
samples_per_channel
(
)
audio_frame
-
>
num_channels
(
)
)
;
CopySamples
(
dst
audio_frame
-
>
data_view
(
)
)
;
return
true
;
}
}
}
