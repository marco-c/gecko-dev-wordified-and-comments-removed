#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
audio_codecs
/
audio_encoder
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_encoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
opus
/
audio_decoder_multi_channel_opus
.
h
"
#
include
"
api
/
audio_codecs
/
opus
/
audio_decoder_opus
.
h
"
#
include
"
api
/
audio_codecs
/
opus
/
audio_encoder_multi_channel_opus
.
h
"
#
include
"
api
/
audio_codecs
/
opus
/
audio_encoder_opus
.
h
"
#
include
"
modules
/
audio_coding
/
acm2
/
acm_receive_test
.
h
"
#
include
"
modules
/
audio_coding
/
acm2
/
acm_send_test
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
cng
/
audio_encoder_cng
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
g711
/
audio_decoder_pcm
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
g711
/
audio_encoder_pcm
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
isac
/
main
/
include
/
audio_encoder_isac
.
h
"
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module_typedefs
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
audio_checksum
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
audio_loop
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
constant_pcm_packet_source
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
input_audio_file
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
output_audio_file
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
output_wav_file
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
packet
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
rtp_file_source
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
message_digest
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
ref_counted_object
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
system
/
arch
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
system_wrappers
/
include
/
cpu_features_wrapper
.
h
"
#
include
"
system_wrappers
/
include
/
sleep
.
h
"
#
include
"
test
/
audio_decoder_proxy_factory
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
mock_audio_decoder
.
h
"
#
include
"
test
/
mock_audio_encoder
.
h
"
#
include
"
test
/
testsupport
/
file_utils
.
h
"
#
include
"
test
/
testsupport
/
rtc_expect_death
.
h
"
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AtLeast
;
using
:
:
testing
:
:
Invoke
;
namespace
webrtc
{
namespace
{
const
int
kSampleRateHz
=
16000
;
const
int
kNumSamples10ms
=
kSampleRateHz
/
100
;
const
int
kFrameSizeMs
=
10
;
const
int
kFrameSizeSamples
=
kFrameSizeMs
/
10
*
kNumSamples10ms
;
const
int
kPayloadSizeBytes
=
kFrameSizeSamples
*
sizeof
(
int16_t
)
;
const
uint8_t
kPayloadType
=
111
;
}
class
RtpData
{
public
:
RtpData
(
int
samples_per_packet
uint8_t
payload_type
)
:
samples_per_packet_
(
samples_per_packet
)
payload_type_
(
payload_type
)
{
}
virtual
~
RtpData
(
)
{
}
void
Populate
(
RTPHeader
*
rtp_header
)
{
rtp_header
-
>
sequenceNumber
=
0xABCD
;
rtp_header
-
>
timestamp
=
0xABCDEF01
;
rtp_header
-
>
payloadType
=
payload_type_
;
rtp_header
-
>
markerBit
=
false
;
rtp_header
-
>
ssrc
=
0x1234
;
rtp_header
-
>
numCSRCs
=
0
;
rtp_header
-
>
payload_type_frequency
=
kSampleRateHz
;
}
void
Forward
(
RTPHeader
*
rtp_header
)
{
+
+
rtp_header
-
>
sequenceNumber
;
rtp_header
-
>
timestamp
+
=
samples_per_packet_
;
}
private
:
int
samples_per_packet_
;
uint8_t
payload_type_
;
}
;
class
PacketizationCallbackStubOldApi
:
public
AudioPacketizationCallback
{
public
:
PacketizationCallbackStubOldApi
(
)
:
num_calls_
(
0
)
last_frame_type_
(
AudioFrameType
:
:
kEmptyFrame
)
last_payload_type_
(
-
1
)
last_timestamp_
(
0
)
{
}
int32_t
SendData
(
AudioFrameType
frame_type
uint8_t
payload_type
uint32_t
timestamp
const
uint8_t
*
payload_data
size_t
payload_len_bytes
int64_t
absolute_capture_timestamp_ms
)
override
{
MutexLock
lock
(
&
mutex_
)
;
+
+
num_calls_
;
last_frame_type_
=
frame_type
;
last_payload_type_
=
payload_type
;
last_timestamp_
=
timestamp
;
last_payload_vec_
.
assign
(
payload_data
payload_data
+
payload_len_bytes
)
;
return
0
;
}
int
num_calls
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
num_calls_
;
}
int
last_payload_len_bytes
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
rtc
:
:
checked_cast
<
int
>
(
last_payload_vec_
.
size
(
)
)
;
}
AudioFrameType
last_frame_type
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
last_frame_type_
;
}
int
last_payload_type
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
last_payload_type_
;
}
uint32_t
last_timestamp
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
last_timestamp_
;
}
void
SwapBuffers
(
std
:
:
vector
<
uint8_t
>
*
payload
)
{
MutexLock
lock
(
&
mutex_
)
;
last_payload_vec_
.
swap
(
*
payload
)
;
}
private
:
int
num_calls_
RTC_GUARDED_BY
(
mutex_
)
;
AudioFrameType
last_frame_type_
RTC_GUARDED_BY
(
mutex_
)
;
int
last_payload_type_
RTC_GUARDED_BY
(
mutex_
)
;
uint32_t
last_timestamp_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
vector
<
uint8_t
>
last_payload_vec_
RTC_GUARDED_BY
(
mutex_
)
;
mutable
Mutex
mutex_
;
}
;
class
AudioCodingModuleTestOldApi
:
public
:
:
testing
:
:
Test
{
protected
:
AudioCodingModuleTestOldApi
(
)
:
rtp_utility_
(
new
RtpData
(
kFrameSizeSamples
kPayloadType
)
)
clock_
(
Clock
:
:
GetRealTimeClock
(
)
)
{
}
~
AudioCodingModuleTestOldApi
(
)
{
}
void
TearDown
(
)
{
}
void
SetUp
(
)
{
acm_
.
reset
(
AudioCodingModule
:
:
Create
(
[
this
]
{
AudioCodingModule
:
:
Config
config
;
config
.
clock
=
clock_
;
config
.
decoder_factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
return
config
;
}
(
)
)
)
;
rtp_utility_
-
>
Populate
(
&
rtp_header_
)
;
input_frame_
.
sample_rate_hz_
=
kSampleRateHz
;
input_frame_
.
num_channels_
=
1
;
input_frame_
.
samples_per_channel_
=
kSampleRateHz
*
10
/
1000
;
static_assert
(
kSampleRateHz
*
10
/
1000
<
=
AudioFrame
:
:
kMaxDataSizeSamples
"
audio
frame
too
small
"
)
;
input_frame_
.
Mute
(
)
;
ASSERT_EQ
(
0
acm_
-
>
RegisterTransportCallback
(
&
packet_cb_
)
)
;
SetUpL16Codec
(
)
;
}
virtual
void
SetUpL16Codec
(
)
{
audio_format_
=
SdpAudioFormat
(
"
L16
"
kSampleRateHz
1
)
;
pac_size_
=
160
;
}
virtual
void
RegisterCodec
(
)
{
acm_
-
>
SetReceiveCodecs
(
{
{
kPayloadType
*
audio_format_
}
}
)
;
acm_
-
>
SetEncoder
(
CreateBuiltinAudioEncoderFactory
(
)
-
>
MakeAudioEncoder
(
kPayloadType
*
audio_format_
absl
:
:
nullopt
)
)
;
}
virtual
void
InsertPacketAndPullAudio
(
)
{
InsertPacket
(
)
;
PullAudio
(
)
;
}
virtual
void
InsertPacket
(
)
{
const
uint8_t
kPayload
[
kPayloadSizeBytes
]
=
{
0
}
;
ASSERT_EQ
(
0
acm_
-
>
IncomingPacket
(
kPayload
kPayloadSizeBytes
rtp_header_
)
)
;
rtp_utility_
-
>
Forward
(
&
rtp_header_
)
;
}
virtual
void
PullAudio
(
)
{
AudioFrame
audio_frame
;
bool
muted
;
ASSERT_EQ
(
0
acm_
-
>
PlayoutData10Ms
(
-
1
&
audio_frame
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
}
virtual
void
InsertAudio
(
)
{
ASSERT_GE
(
acm_
-
>
Add10MsData
(
input_frame_
)
0
)
;
input_frame_
.
timestamp_
+
=
kNumSamples10ms
;
}
virtual
void
VerifyEncoding
(
)
{
int
last_length
=
packet_cb_
.
last_payload_len_bytes
(
)
;
EXPECT_TRUE
(
last_length
=
=
2
*
pac_size_
|
|
last_length
=
=
0
)
<
<
"
Last
encoded
packet
was
"
<
<
last_length
<
<
"
bytes
.
"
;
}
virtual
void
InsertAudioAndVerifyEncoding
(
)
{
InsertAudio
(
)
;
VerifyEncoding
(
)
;
}
std
:
:
unique_ptr
<
RtpData
>
rtp_utility_
;
std
:
:
unique_ptr
<
AudioCodingModule
>
acm_
;
PacketizationCallbackStubOldApi
packet_cb_
;
RTPHeader
rtp_header_
;
AudioFrame
input_frame_
;
absl
:
:
optional
<
SdpAudioFormat
>
audio_format_
;
int
pac_size_
=
-
1
;
Clock
*
clock_
;
}
;
class
AudioCodingModuleTestOldApiDeathTest
:
public
AudioCodingModuleTestOldApi
{
}
;
TEST_F
(
AudioCodingModuleTestOldApi
VerifyOutputFrame
)
{
AudioFrame
audio_frame
;
const
int
kSampleRateHz
=
32000
;
bool
muted
;
EXPECT_EQ
(
0
acm_
-
>
PlayoutData10Ms
(
kSampleRateHz
&
audio_frame
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
EXPECT_EQ
(
0u
audio_frame
.
timestamp_
)
;
EXPECT_GT
(
audio_frame
.
num_channels_
0u
)
;
EXPECT_EQ
(
static_cast
<
size_t
>
(
kSampleRateHz
/
100
)
audio_frame
.
samples_per_channel_
)
;
EXPECT_EQ
(
kSampleRateHz
audio_frame
.
sample_rate_hz_
)
;
}
#
if
!
defined
(
WEBRTC_WIN
)
&
&
defined
(
__clang__
)
&
&
RTC_DCHECK_IS_ON
&
&
\
GTEST_HAS_DEATH_TEST
&
&
!
defined
(
WEBRTC_ANDROID
)
TEST_F
(
AudioCodingModuleTestOldApiDeathTest
FailOnZeroDesiredFrequency
)
{
AudioFrame
audio_frame
;
bool
muted
;
RTC_EXPECT_DEATH
(
acm_
-
>
PlayoutData10Ms
(
0
&
audio_frame
&
muted
)
"
dst_sample_rate_hz
"
)
;
}
#
endif
TEST_F
(
AudioCodingModuleTestOldApi
TransportCallbackIsInvokedForEachPacket
)
{
const
int
k10MsBlocksPerPacket
=
3
;
pac_size_
=
k10MsBlocksPerPacket
*
kSampleRateHz
/
100
;
audio_format_
-
>
parameters
[
"
ptime
"
]
=
"
30
"
;
RegisterCodec
(
)
;
const
int
kLoops
=
10
;
for
(
int
i
=
0
;
i
<
kLoops
;
+
+
i
)
{
EXPECT_EQ
(
i
/
k10MsBlocksPerPacket
packet_cb_
.
num_calls
(
)
)
;
if
(
packet_cb_
.
num_calls
(
)
>
0
)
EXPECT_EQ
(
AudioFrameType
:
:
kAudioFrameSpeech
packet_cb_
.
last_frame_type
(
)
)
;
InsertAudioAndVerifyEncoding
(
)
;
}
EXPECT_EQ
(
kLoops
/
k10MsBlocksPerPacket
packet_cb_
.
num_calls
(
)
)
;
EXPECT_EQ
(
AudioFrameType
:
:
kAudioFrameSpeech
packet_cb_
.
last_frame_type
(
)
)
;
}
#
if
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
TEST_F
(
AudioCodingModuleTestOldApi
TimestampSeriesContinuesWhenCodecChanges
)
{
RegisterCodec
(
)
;
uint32_t
expected_ts
=
input_frame_
.
timestamp_
;
int
blocks_per_packet
=
pac_size_
/
(
kSampleRateHz
/
100
)
;
const
int
kNumPackets1
=
5
;
for
(
int
j
=
0
;
j
<
kNumPackets1
;
+
+
j
)
{
for
(
int
i
=
0
;
i
<
blocks_per_packet
;
+
+
i
)
{
EXPECT_EQ
(
j
packet_cb_
.
num_calls
(
)
)
;
InsertAudio
(
)
;
}
EXPECT_EQ
(
j
+
1
packet_cb_
.
num_calls
(
)
)
;
EXPECT_EQ
(
expected_ts
packet_cb_
.
last_timestamp
(
)
)
;
expected_ts
+
=
pac_size_
;
}
audio_format_
=
SdpAudioFormat
(
"
ISAC
"
kSampleRateHz
1
)
;
pac_size_
=
480
;
RegisterCodec
(
)
;
blocks_per_packet
=
pac_size_
/
(
kSampleRateHz
/
100
)
;
const
int
kNumPackets2
=
5
;
for
(
int
j
=
0
;
j
<
kNumPackets2
;
+
+
j
)
{
for
(
int
i
=
0
;
i
<
blocks_per_packet
;
+
+
i
)
{
EXPECT_EQ
(
kNumPackets1
+
j
packet_cb_
.
num_calls
(
)
)
;
InsertAudio
(
)
;
}
EXPECT_EQ
(
kNumPackets1
+
j
+
1
packet_cb_
.
num_calls
(
)
)
;
EXPECT_EQ
(
expected_ts
packet_cb_
.
last_timestamp
(
)
)
;
expected_ts
+
=
pac_size_
;
}
}
#
endif
class
AudioCodingModuleTestWithComfortNoiseOldApi
:
public
AudioCodingModuleTestOldApi
{
protected
:
void
RegisterCngCodec
(
int
rtp_payload_type
)
{
acm_
-
>
SetReceiveCodecs
(
{
{
kPayloadType
*
audio_format_
}
{
rtp_payload_type
{
"
cn
"
kSampleRateHz
1
}
}
}
)
;
acm_
-
>
ModifyEncoder
(
[
&
]
(
std
:
:
unique_ptr
<
AudioEncoder
>
*
enc
)
{
AudioEncoderCngConfig
config
;
config
.
speech_encoder
=
std
:
:
move
(
*
enc
)
;
config
.
num_channels
=
1
;
config
.
payload_type
=
rtp_payload_type
;
config
.
vad_mode
=
Vad
:
:
kVadNormal
;
*
enc
=
CreateComfortNoiseEncoder
(
std
:
:
move
(
config
)
)
;
}
)
;
}
void
VerifyEncoding
(
)
override
{
int
last_length
=
packet_cb_
.
last_payload_len_bytes
(
)
;
EXPECT_TRUE
(
last_length
=
=
9
|
|
last_length
=
=
0
)
<
<
"
Last
encoded
packet
was
"
<
<
last_length
<
<
"
bytes
.
"
;
}
void
DoTest
(
int
blocks_per_packet
int
cng_pt
)
{
const
int
kLoops
=
40
;
const
struct
{
int
ix
;
AudioFrameType
type
;
}
expectation
[
]
=
{
{
2
AudioFrameType
:
:
kAudioFrameCN
}
{
5
AudioFrameType
:
:
kEmptyFrame
}
{
8
AudioFrameType
:
:
kEmptyFrame
}
{
11
AudioFrameType
:
:
kAudioFrameCN
}
{
14
AudioFrameType
:
:
kEmptyFrame
}
{
17
AudioFrameType
:
:
kEmptyFrame
}
{
20
AudioFrameType
:
:
kAudioFrameCN
}
{
23
AudioFrameType
:
:
kEmptyFrame
}
{
26
AudioFrameType
:
:
kEmptyFrame
}
{
29
AudioFrameType
:
:
kEmptyFrame
}
{
32
AudioFrameType
:
:
kAudioFrameCN
}
{
35
AudioFrameType
:
:
kEmptyFrame
}
{
38
AudioFrameType
:
:
kEmptyFrame
}
}
;
for
(
int
i
=
0
;
i
<
kLoops
;
+
+
i
)
{
int
num_calls_before
=
packet_cb_
.
num_calls
(
)
;
EXPECT_EQ
(
i
/
blocks_per_packet
num_calls_before
)
;
InsertAudioAndVerifyEncoding
(
)
;
int
num_calls
=
packet_cb_
.
num_calls
(
)
;
if
(
num_calls
=
=
num_calls_before
+
1
)
{
EXPECT_EQ
(
expectation
[
num_calls
-
1
]
.
ix
i
)
;
EXPECT_EQ
(
expectation
[
num_calls
-
1
]
.
type
packet_cb_
.
last_frame_type
(
)
)
<
<
"
Wrong
frame
type
for
lap
"
<
<
i
;
EXPECT_EQ
(
cng_pt
packet_cb_
.
last_payload_type
(
)
)
;
}
else
{
EXPECT_EQ
(
num_calls
num_calls_before
)
;
}
}
}
}
;
TEST_F
(
AudioCodingModuleTestWithComfortNoiseOldApi
TransportCallbackTestForComfortNoiseRegisterCngLast
)
{
const
int
k10MsBlocksPerPacket
=
3
;
pac_size_
=
k10MsBlocksPerPacket
*
kSampleRateHz
/
100
;
audio_format_
-
>
parameters
[
"
ptime
"
]
=
"
30
"
;
RegisterCodec
(
)
;
const
int
kCngPayloadType
=
105
;
RegisterCngCodec
(
kCngPayloadType
)
;
DoTest
(
k10MsBlocksPerPacket
kCngPayloadType
)
;
}
class
AudioCodingModuleMtTestOldApi
:
public
AudioCodingModuleTestOldApi
{
protected
:
static
const
int
kNumPackets
=
500
;
static
const
int
kNumPullCalls
=
500
;
AudioCodingModuleMtTestOldApi
(
)
:
AudioCodingModuleTestOldApi
(
)
send_count_
(
0
)
insert_packet_count_
(
0
)
pull_audio_count_
(
0
)
next_insert_packet_time_ms_
(
0
)
fake_clock_
(
new
SimulatedClock
(
0
)
)
{
clock_
=
fake_clock_
.
get
(
)
;
}
void
SetUp
(
)
{
AudioCodingModuleTestOldApi
:
:
SetUp
(
)
;
RegisterCodec
(
)
;
StartThreads
(
)
;
}
void
StartThreads
(
)
{
quit_
.
store
(
false
)
;
const
auto
attributes
=
rtc
:
:
ThreadAttributes
(
)
.
SetPriority
(
rtc
:
:
ThreadPriority
:
:
kRealtime
)
;
send_thread_
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
!
quit_
.
load
(
)
)
{
CbSendImpl
(
)
;
}
}
"
send
"
attributes
)
;
insert_packet_thread_
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
!
quit_
.
load
(
)
)
{
CbInsertPacketImpl
(
)
;
}
}
"
insert_packet
"
attributes
)
;
pull_audio_thread_
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
!
quit_
.
load
(
)
)
{
CbPullAudioImpl
(
)
;
}
}
"
pull_audio
"
attributes
)
;
}
void
TearDown
(
)
{
AudioCodingModuleTestOldApi
:
:
TearDown
(
)
;
quit_
.
store
(
true
)
;
pull_audio_thread_
.
Finalize
(
)
;
send_thread_
.
Finalize
(
)
;
insert_packet_thread_
.
Finalize
(
)
;
}
bool
RunTest
(
)
{
return
test_complete_
.
Wait
(
10
*
60
*
1000
)
;
}
virtual
bool
TestDone
(
)
{
if
(
packet_cb_
.
num_calls
(
)
>
kNumPackets
)
{
MutexLock
lock
(
&
mutex_
)
;
if
(
pull_audio_count_
>
kNumPullCalls
)
{
return
true
;
}
}
return
false
;
}
void
CbSendImpl
(
)
{
SleepMs
(
1
)
;
if
(
HasFatalFailure
(
)
)
{
test_complete_
.
Set
(
)
;
}
+
+
send_count_
;
InsertAudioAndVerifyEncoding
(
)
;
if
(
TestDone
(
)
)
{
test_complete_
.
Set
(
)
;
}
}
void
CbInsertPacketImpl
(
)
{
SleepMs
(
1
)
;
{
MutexLock
lock
(
&
mutex_
)
;
if
(
clock_
-
>
TimeInMilliseconds
(
)
<
next_insert_packet_time_ms_
)
{
return
;
}
next_insert_packet_time_ms_
+
=
10
;
}
+
+
insert_packet_count_
;
InsertPacket
(
)
;
}
void
CbPullAudioImpl
(
)
{
SleepMs
(
1
)
;
{
MutexLock
lock
(
&
mutex_
)
;
if
(
next_insert_packet_time_ms_
<
clock_
-
>
TimeInMilliseconds
(
)
)
{
return
;
}
+
+
pull_audio_count_
;
}
PullAudio
(
)
;
fake_clock_
-
>
AdvanceTimeMilliseconds
(
10
)
;
}
rtc
:
:
PlatformThread
send_thread_
;
rtc
:
:
PlatformThread
insert_packet_thread_
;
rtc
:
:
PlatformThread
pull_audio_thread_
;
std
:
:
atomic
<
bool
>
quit_
;
rtc
:
:
Event
test_complete_
;
int
send_count_
;
int
insert_packet_count_
;
int
pull_audio_count_
RTC_GUARDED_BY
(
mutex_
)
;
Mutex
mutex_
;
int64_t
next_insert_packet_time_ms_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
unique_ptr
<
SimulatedClock
>
fake_clock_
;
}
;
#
if
defined
(
WEBRTC_IOS
)
#
define
MAYBE_DoTest
DISABLED_DoTest
#
else
#
define
MAYBE_DoTest
DoTest
#
endif
TEST_F
(
AudioCodingModuleMtTestOldApi
MAYBE_DoTest
)
{
EXPECT_TRUE
(
RunTest
(
)
)
;
}
class
AcmIsacMtTestOldApi
:
public
AudioCodingModuleMtTestOldApi
{
protected
:
static
const
int
kNumPackets
=
500
;
static
const
int
kNumPullCalls
=
500
;
AcmIsacMtTestOldApi
(
)
:
AudioCodingModuleMtTestOldApi
(
)
last_packet_number_
(
0
)
{
}
~
AcmIsacMtTestOldApi
(
)
{
}
void
SetUp
(
)
override
{
AudioCodingModuleTestOldApi
:
:
SetUp
(
)
;
RegisterCodec
(
)
;
const
std
:
:
string
input_file_name
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
speech_mono_16kHz
"
"
pcm
"
)
;
audio_loop_
.
Init
(
input_file_name
5
*
kSampleRateHz
kNumSamples10ms
)
;
int
loop_counter
=
0
;
while
(
packet_cb_
.
last_payload_len_bytes
(
)
=
=
0
)
{
InsertAudio
(
)
;
ASSERT_LT
(
loop_counter
+
+
10
)
;
}
last_packet_number_
=
packet_cb_
.
num_calls
(
)
-
1
;
StartThreads
(
)
;
}
void
RegisterCodec
(
)
override
{
static_assert
(
kSampleRateHz
=
=
16000
"
test
designed
for
iSAC
16
kHz
"
)
;
audio_format_
=
SdpAudioFormat
(
"
isac
"
kSampleRateHz
1
)
;
pac_size_
=
480
;
acm_
-
>
SetReceiveCodecs
(
{
{
kPayloadType
*
audio_format_
}
}
)
;
acm_
-
>
SetEncoder
(
CreateBuiltinAudioEncoderFactory
(
)
-
>
MakeAudioEncoder
(
kPayloadType
*
audio_format_
absl
:
:
nullopt
)
)
;
}
void
InsertPacket
(
)
override
{
int
num_calls
=
packet_cb_
.
num_calls
(
)
;
if
(
num_calls
>
last_packet_number_
)
{
packet_cb_
.
SwapBuffers
(
&
last_payload_vec_
)
;
ASSERT_GT
(
last_payload_vec_
.
size
(
)
0u
)
;
rtp_utility_
-
>
Forward
(
&
rtp_header_
)
;
last_packet_number_
=
num_calls
;
}
ASSERT_GT
(
last_payload_vec_
.
size
(
)
0u
)
;
ASSERT_EQ
(
0
acm_
-
>
IncomingPacket
(
&
last_payload_vec_
[
0
]
last_payload_vec_
.
size
(
)
rtp_header_
)
)
;
}
void
InsertAudio
(
)
override
{
memcpy
(
input_frame_
.
mutable_data
(
)
audio_loop_
.
GetNextBlock
(
)
.
data
(
)
kNumSamples10ms
)
;
AudioCodingModuleTestOldApi
:
:
InsertAudio
(
)
;
}
void
VerifyEncoding
(
)
override
{
}
bool
TestDone
(
)
override
{
if
(
packet_cb_
.
num_calls
(
)
>
kNumPackets
)
{
MutexLock
lock
(
&
mutex_
)
;
if
(
pull_audio_count_
>
kNumPullCalls
)
{
return
true
;
}
}
return
false
;
}
int
last_packet_number_
;
std
:
:
vector
<
uint8_t
>
last_payload_vec_
;
test
:
:
AudioLoop
audio_loop_
;
}
;
#
if
defined
(
WEBRTC_IOS
)
#
define
MAYBE_DoTest
DISABLED_DoTest
#
else
#
define
MAYBE_DoTest
DoTest
#
endif
#
if
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
TEST_F
(
AcmIsacMtTestOldApi
MAYBE_DoTest
)
{
EXPECT_TRUE
(
RunTest
(
)
)
;
}
#
endif
class
AcmReRegisterIsacMtTestOldApi
:
public
AudioCodingModuleTestOldApi
{
protected
:
static
const
int
kRegisterAfterNumPackets
=
5
;
static
const
int
kNumPackets
=
10
;
static
const
int
kPacketSizeMs
=
30
;
static
const
int
kPacketSizeSamples
=
kPacketSizeMs
*
16
;
AcmReRegisterIsacMtTestOldApi
(
)
:
AudioCodingModuleTestOldApi
(
)
codec_registered_
(
false
)
receive_packet_count_
(
0
)
next_insert_packet_time_ms_
(
0
)
fake_clock_
(
new
SimulatedClock
(
0
)
)
{
AudioEncoderIsacFloatImpl
:
:
Config
config
;
config
.
payload_type
=
kPayloadType
;
isac_encoder_
.
reset
(
new
AudioEncoderIsacFloatImpl
(
config
)
)
;
clock_
=
fake_clock_
.
get
(
)
;
}
void
SetUp
(
)
override
{
AudioCodingModuleTestOldApi
:
:
SetUp
(
)
;
const
std
:
:
string
input_file_name
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
speech_mono_16kHz
"
"
pcm
"
)
;
audio_loop_
.
Init
(
input_file_name
5
*
kSampleRateHz
kNumSamples10ms
)
;
RegisterCodec
(
)
;
StartThreads
(
)
;
}
void
RegisterCodec
(
)
override
{
static_assert
(
kSampleRateHz
=
=
16000
"
test
designed
for
iSAC
16
kHz
"
)
;
acm_
-
>
SetReceiveCodecs
(
{
{
kPayloadType
{
"
ISAC
"
kSampleRateHz
1
}
}
}
)
;
}
void
StartThreads
(
)
{
quit_
.
store
(
false
)
;
const
auto
attributes
=
rtc
:
:
ThreadAttributes
(
)
.
SetPriority
(
rtc
:
:
ThreadPriority
:
:
kRealtime
)
;
receive_thread_
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
!
quit_
.
load
(
)
&
&
CbReceiveImpl
(
)
)
{
}
}
"
receive
"
attributes
)
;
codec_registration_thread_
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
this
]
{
while
(
!
quit_
.
load
(
)
)
{
CbCodecRegistrationImpl
(
)
;
}
}
"
codec_registration
"
attributes
)
;
}
void
TearDown
(
)
override
{
AudioCodingModuleTestOldApi
:
:
TearDown
(
)
;
quit_
.
store
(
true
)
;
receive_thread_
.
Finalize
(
)
;
codec_registration_thread_
.
Finalize
(
)
;
}
bool
RunTest
(
)
{
return
test_complete_
.
Wait
(
10
*
60
*
1000
)
;
}
bool
CbReceiveImpl
(
)
{
SleepMs
(
1
)
;
rtc
:
:
Buffer
encoded
;
AudioEncoder
:
:
EncodedInfo
info
;
{
MutexLock
lock
(
&
mutex_
)
;
if
(
clock_
-
>
TimeInMilliseconds
(
)
<
next_insert_packet_time_ms_
)
{
return
true
;
}
next_insert_packet_time_ms_
+
=
kPacketSizeMs
;
+
+
receive_packet_count_
;
uint32_t
input_timestamp
=
rtp_header_
.
timestamp
;
while
(
info
.
encoded_bytes
=
=
0
)
{
info
=
isac_encoder_
-
>
Encode
(
input_timestamp
audio_loop_
.
GetNextBlock
(
)
&
encoded
)
;
input_timestamp
+
=
160
;
}
EXPECT_EQ
(
rtp_header_
.
timestamp
+
kPacketSizeSamples
input_timestamp
)
;
EXPECT_EQ
(
rtp_header_
.
timestamp
info
.
encoded_timestamp
)
;
EXPECT_EQ
(
rtp_header_
.
payloadType
info
.
payload_type
)
;
}
EXPECT_EQ
(
0
acm_
-
>
IncomingPacket
(
encoded
.
data
(
)
info
.
encoded_bytes
rtp_header_
)
)
;
for
(
int
i
=
0
;
i
<
rtc
:
:
CheckedDivExact
(
kPacketSizeMs
10
)
;
+
+
i
)
{
AudioFrame
audio_frame
;
bool
muted
;
EXPECT_EQ
(
0
acm_
-
>
PlayoutData10Ms
(
-
1
&
audio_frame
&
muted
)
)
;
if
(
muted
)
{
ADD_FAILURE
(
)
;
return
false
;
}
fake_clock_
-
>
AdvanceTimeMilliseconds
(
10
)
;
}
rtp_utility_
-
>
Forward
(
&
rtp_header_
)
;
return
true
;
}
void
CbCodecRegistrationImpl
(
)
{
SleepMs
(
1
)
;
if
(
HasFatalFailure
(
)
)
{
test_complete_
.
Set
(
)
;
}
MutexLock
lock
(
&
mutex_
)
;
if
(
!
codec_registered_
&
&
receive_packet_count_
>
kRegisterAfterNumPackets
)
{
acm_
-
>
SetEncoder
(
CreateBuiltinAudioEncoderFactory
(
)
-
>
MakeAudioEncoder
(
kPayloadType
*
audio_format_
absl
:
:
nullopt
)
)
;
codec_registered_
=
true
;
}
if
(
codec_registered_
&
&
receive_packet_count_
>
kNumPackets
)
{
test_complete_
.
Set
(
)
;
}
}
rtc
:
:
PlatformThread
receive_thread_
;
rtc
:
:
PlatformThread
codec_registration_thread_
;
std
:
:
atomic
<
bool
>
quit_
;
rtc
:
:
Event
test_complete_
;
Mutex
mutex_
;
bool
codec_registered_
RTC_GUARDED_BY
(
mutex_
)
;
int
receive_packet_count_
RTC_GUARDED_BY
(
mutex_
)
;
int64_t
next_insert_packet_time_ms_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
unique_ptr
<
AudioEncoderIsacFloatImpl
>
isac_encoder_
;
std
:
:
unique_ptr
<
SimulatedClock
>
fake_clock_
;
test
:
:
AudioLoop
audio_loop_
;
}
;
#
if
defined
(
WEBRTC_IOS
)
#
define
MAYBE_DoTest
DISABLED_DoTest
#
else
#
define
MAYBE_DoTest
DoTest
#
endif
#
if
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
TEST_F
(
AcmReRegisterIsacMtTestOldApi
MAYBE_DoTest
)
{
EXPECT_TRUE
(
RunTest
(
)
)
;
}
#
endif
#
if
!
defined
(
WEBRTC_IOS
)
class
AcmReceiverBitExactnessOldApi
:
public
:
:
testing
:
:
Test
{
public
:
static
std
:
:
string
PlatformChecksum
(
std
:
:
string
others
std
:
:
string
win64
std
:
:
string
android_arm32
std
:
:
string
android_arm64
std
:
:
string
android_arm64_clang
std
:
:
string
mac_arm64
)
{
#
if
defined
(
_WIN32
)
&
&
defined
(
WEBRTC_ARCH_64_BITS
)
return
win64
;
#
elif
defined
(
WEBRTC_MAC
)
&
&
defined
(
WEBRTC_ARCH_ARM64
)
return
mac_arm64
;
#
elif
defined
(
WEBRTC_ANDROID
)
&
&
defined
(
WEBRTC_ARCH_ARM
)
return
android_arm32
;
#
elif
defined
(
WEBRTC_ANDROID
)
&
&
defined
(
WEBRTC_ARCH_ARM64
)
#
if
defined
(
__clang__
)
return
android_arm64_clang
;
#
else
return
android_arm64
;
#
endif
#
else
return
others
;
#
endif
}
protected
:
struct
ExternalDecoder
{
int
rtp_payload_type
;
AudioDecoder
*
external_decoder
;
int
sample_rate_hz
;
int
num_channels
;
std
:
:
string
name
;
}
;
void
Run
(
int
output_freq_hz
const
std
:
:
string
&
checksum_ref
)
{
Run
(
output_freq_hz
checksum_ref
CreateBuiltinAudioDecoderFactory
(
)
[
]
(
AudioCodingModule
*
)
{
}
)
;
}
void
Run
(
int
output_freq_hz
const
std
:
:
string
&
checksum_ref
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
rtc
:
:
FunctionView
<
void
(
AudioCodingModule
*
)
>
decoder_reg
)
{
const
std
:
:
string
input_file_name
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
neteq_universal_new
"
"
rtp
"
)
;
std
:
:
unique_ptr
<
test
:
:
RtpFileSource
>
packet_source
(
test
:
:
RtpFileSource
:
:
Create
(
input_file_name
)
)
;
#
ifdef
WEBRTC_ANDROID
packet_source
-
>
FilterOutPayloadType
(
102
)
;
packet_source
-
>
FilterOutPayloadType
(
104
)
;
#
endif
test
:
:
AudioChecksum
checksum
;
const
std
:
:
string
output_file_name
=
webrtc
:
:
test
:
:
OutputPath
(
)
+
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
test_case_name
(
)
+
"
_
"
+
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
name
(
)
+
"
_output
.
wav
"
;
test
:
:
OutputWavFile
output_file
(
output_file_name
output_freq_hz
1
)
;
test
:
:
AudioSinkFork
output
(
&
checksum
&
output_file
)
;
test
:
:
AcmReceiveTestOldApi
test
(
packet_source
.
get
(
)
&
output
output_freq_hz
test
:
:
AcmReceiveTestOldApi
:
:
kArbitraryChannels
std
:
:
move
(
decoder_factory
)
)
;
ASSERT_NO_FATAL_FAILURE
(
test
.
RegisterNetEqTestCodecs
(
)
)
;
decoder_reg
(
test
.
get_acm
(
)
)
;
test
.
Run
(
)
;
std
:
:
string
checksum_string
=
checksum
.
Finish
(
)
;
EXPECT_EQ
(
checksum_ref
checksum_string
)
;
remove
(
output_file_name
.
c_str
(
)
)
;
}
}
;
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
&
&
\
defined
(
WEBRTC_CODEC_ILBC
)
TEST_F
(
AcmReceiverBitExactnessOldApi
8kHzOutput
)
{
std
:
:
string
others_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
e0c966d7b8c36ff60167988fa35d33e0
"
#
if
defined
(
WEBRTC_LINUX
)
&
&
defined
(
NDEBUG
)
:
"
5af28619e3a3c606b2242c9a12f4f64e
"
;
#
else
:
"
7d8f6b84abd1e57ec010a53bc2130652
"
;
#
endif
std
:
:
string
win64_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
405a50f0bcb8827e20aa944299fc59f6
"
:
"
0ed5830930f5527a01bbec0ba11f8541
"
;
Run
(
8000
PlatformChecksum
(
others_checksum_reference
win64_checksum_reference
"
b892ed69c38b21b16c132ec2ce03aa7b
"
"
4598140b5e4f7ee66c5adad609e65a3e
"
"
5fec8d770778ef7969ec98c56d9eb10f
"
"
636efe6d0a148f22c5383f356da3deac
"
)
)
;
}
TEST_F
(
AcmReceiverBitExactnessOldApi
16kHzOutput
)
{
std
:
:
string
others_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
a63c578e1195c8420f453962c6d8519c
"
#
if
defined
(
WEBRTC_LINUX
)
&
&
defined
(
NDEBUG
)
:
"
f788cc9200ac4a7d498d9081987808a3
"
;
#
else
:
"
6bac83762c1306b932cd25a560155681
"
;
#
endif
std
:
:
string
win64_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
58fd62a5c49ee513f9fa6fe7dbf62c97
"
:
"
0509cf0672f543efb4b050e8cffefb1d
"
;
Run
(
16000
PlatformChecksum
(
others_checksum_reference
win64_checksum_reference
"
3cea9abbeabbdea9a79719941b241af5
"
"
f2aad418af974a3b1694d5ae5cc2c3c7
"
"
9d4b92c31c00e321a4cff29ad002d6a2
"
"
1e2d1b482fdc924f79a838503ee7ead5
"
)
)
;
}
TEST_F
(
AcmReceiverBitExactnessOldApi
32kHzOutput
)
{
std
:
:
string
others_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
8775ce387f44dc5ff4a26da295d5ee7c
"
#
if
defined
(
WEBRTC_LINUX
)
&
&
defined
(
NDEBUG
)
:
"
5b84b2a179cb8533a8f9bcd19612e7f0
"
;
#
else
:
"
e319222ca47733709f90fdf33c8574db
"
;
#
endif
std
:
:
string
win64_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
04ce6a1dac5ffdd8438d804623d0132f
"
:
"
39a4a7a1c455b35baeffb9fd193d7858
"
;
Run
(
32000
PlatformChecksum
(
others_checksum_reference
win64_checksum_reference
"
4df55b3b62bcbf4328786d474ae87f61
"
"
100869c8dcde51346c2073e52a272d98
"
"
ff58d3153d2780a3df6bc2068844cb2d
"
"
51788e9784a10ae14a030f075a039205
"
)
)
;
}
TEST_F
(
AcmReceiverBitExactnessOldApi
48kHzOutput
)
{
std
:
:
string
others_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
7a55700b7ca9aa60237db58b33e55606
"
#
if
defined
(
WEBRTC_LINUX
)
&
&
defined
(
NDEBUG
)
:
"
a2459749062f96297283cce4a8c7e6db
"
;
#
else
:
"
57d1d316c88279f4f3da3511665069a9
"
;
#
endif
std
:
:
string
win64_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
f59833d9b0924f4b0704707dd3589f80
"
:
"
74cbe7345e2b6b45c1e455a5d1e921ca
"
;
Run
(
48000
PlatformChecksum
(
others_checksum_reference
win64_checksum_reference
"
f52bc7bf0f499c9da25932fdf176c4ec
"
"
bd44bf97e7899186532f91235cef444d
"
"
364d403dae55d73cd69e6dbd6b723a4d
"
"
71bc5c15a151400517c2119d1602ee9f
"
)
)
;
}
TEST_F
(
AcmReceiverBitExactnessOldApi
48kHzOutputExternalDecoder
)
{
class
ADFactory
:
public
AudioDecoderFactory
{
public
:
ADFactory
(
)
:
mock_decoder_
(
new
MockAudioDecoder
(
)
)
pcmu_decoder_
(
1
)
decode_forwarder_
(
&
pcmu_decoder_
)
fact_
(
CreateBuiltinAudioDecoderFactory
(
)
)
{
EXPECT_CALL
(
*
mock_decoder_
SampleRateHz
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
pcmu_decoder_
&
AudioDecoderPcmU
:
:
SampleRateHz
)
)
;
EXPECT_CALL
(
*
mock_decoder_
Channels
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
pcmu_decoder_
&
AudioDecoderPcmU
:
:
Channels
)
)
;
EXPECT_CALL
(
*
mock_decoder_
DecodeInternal
(
_
_
_
_
_
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
decode_forwarder_
&
DecodeForwarder
:
:
Decode
)
)
;
EXPECT_CALL
(
*
mock_decoder_
HasDecodePlc
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
pcmu_decoder_
&
AudioDecoderPcmU
:
:
HasDecodePlc
)
)
;
EXPECT_CALL
(
*
mock_decoder_
PacketDuration
(
_
_
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
pcmu_decoder_
&
AudioDecoderPcmU
:
:
PacketDuration
)
)
;
EXPECT_CALL
(
*
mock_decoder_
Die
(
)
)
;
}
std
:
:
vector
<
AudioCodecSpec
>
GetSupportedDecoders
(
)
override
{
return
fact_
-
>
GetSupportedDecoders
(
)
;
}
bool
IsSupportedDecoder
(
const
SdpAudioFormat
&
format
)
override
{
return
format
.
name
=
=
"
MockPCMu
"
?
true
:
fact_
-
>
IsSupportedDecoder
(
format
)
;
}
std
:
:
unique_ptr
<
AudioDecoder
>
MakeAudioDecoder
(
const
SdpAudioFormat
&
format
absl
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
)
override
{
return
format
.
name
=
=
"
MockPCMu
"
?
std
:
:
move
(
mock_decoder_
)
:
fact_
-
>
MakeAudioDecoder
(
format
codec_pair_id
)
;
}
private
:
class
DecodeForwarder
{
public
:
explicit
DecodeForwarder
(
AudioDecoder
*
decoder
)
:
decoder_
(
decoder
)
{
}
int
Decode
(
const
uint8_t
*
encoded
size_t
encoded_len
int
sample_rate_hz
int16_t
*
decoded
AudioDecoder
:
:
SpeechType
*
speech_type
)
{
return
decoder_
-
>
Decode
(
encoded
encoded_len
sample_rate_hz
decoder_
-
>
PacketDuration
(
encoded
encoded_len
)
*
decoder_
-
>
Channels
(
)
*
sizeof
(
int16_t
)
decoded
speech_type
)
;
}
private
:
AudioDecoder
*
const
decoder_
;
}
;
std
:
:
unique_ptr
<
MockAudioDecoder
>
mock_decoder_
;
AudioDecoderPcmU
pcmu_decoder_
;
DecodeForwarder
decode_forwarder_
;
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
fact_
;
}
;
rtc
:
:
scoped_refptr
<
rtc
:
:
RefCountedObject
<
ADFactory
>
>
factory
(
new
rtc
:
:
RefCountedObject
<
ADFactory
>
)
;
std
:
:
string
others_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
7a55700b7ca9aa60237db58b33e55606
"
#
if
defined
(
WEBRTC_LINUX
)
&
&
defined
(
NDEBUG
)
:
"
a2459749062f96297283cce4a8c7e6db
"
;
#
else
:
"
57d1d316c88279f4f3da3511665069a9
"
;
#
endif
std
:
:
string
win64_checksum_reference
=
GetCPUInfo
(
kAVX2
)
!
=
0
?
"
f59833d9b0924f4b0704707dd3589f80
"
:
"
74cbe7345e2b6b45c1e455a5d1e921ca
"
;
Run
(
48000
PlatformChecksum
(
others_checksum_reference
win64_checksum_reference
"
f52bc7bf0f499c9da25932fdf176c4ec
"
"
bd44bf97e7899186532f91235cef444d
"
"
364d403dae55d73cd69e6dbd6b723a4d
"
"
71bc5c15a151400517c2119d1602ee9f
"
)
factory
[
]
(
AudioCodingModule
*
acm
)
{
acm
-
>
SetReceiveCodecs
(
{
{
0
{
"
MockPCMu
"
8000
1
}
}
{
103
{
"
ISAC
"
16000
1
}
}
{
104
{
"
ISAC
"
32000
1
}
}
{
93
{
"
L16
"
8000
1
}
}
{
94
{
"
L16
"
16000
1
}
}
{
95
{
"
L16
"
32000
1
}
}
{
8
{
"
PCMA
"
8000
1
}
}
{
102
{
"
ILBC
"
8000
1
}
}
{
13
{
"
CN
"
8000
1
}
}
{
98
{
"
CN
"
16000
1
}
}
{
99
{
"
CN
"
32000
1
}
}
}
)
;
}
)
;
}
#
endif
class
AcmSenderBitExactnessOldApi
:
public
:
:
testing
:
:
Test
public
test
:
:
PacketSource
{
protected
:
static
const
int
kTestDurationMs
=
1000
;
AcmSenderBitExactnessOldApi
(
)
:
frame_size_rtp_timestamps_
(
0
)
packet_count_
(
0
)
payload_type_
(
0
)
last_sequence_number_
(
0
)
last_timestamp_
(
0
)
payload_checksum_
(
rtc
:
:
MessageDigestFactory
:
:
Create
(
rtc
:
:
DIGEST_MD5
)
)
{
}
bool
SetUpSender
(
std
:
:
string
input_file_name
int
source_rate
)
{
audio_source_
.
reset
(
new
test
:
:
InputAudioFile
(
input_file_name
)
)
;
send_test_
.
reset
(
new
test
:
:
AcmSendTestOldApi
(
audio_source_
.
get
(
)
source_rate
kTestDurationMs
)
)
;
return
send_test_
.
get
(
)
!
=
NULL
;
}
bool
RegisterSendCodec
(
const
char
*
payload_name
int
sampling_freq_hz
int
channels
int
payload_type
int
frame_size_samples
int
frame_size_rtp_timestamps
)
{
payload_type_
=
payload_type
;
frame_size_rtp_timestamps_
=
frame_size_rtp_timestamps
;
return
send_test_
-
>
RegisterCodec
(
payload_name
sampling_freq_hz
channels
payload_type
frame_size_samples
)
;
}
void
RegisterExternalSendCodec
(
std
:
:
unique_ptr
<
AudioEncoder
>
external_speech_encoder
int
payload_type
)
{
payload_type_
=
payload_type
;
frame_size_rtp_timestamps_
=
rtc
:
:
checked_cast
<
uint32_t
>
(
external_speech_encoder
-
>
Num10MsFramesInNextPacket
(
)
*
external_speech_encoder
-
>
RtpTimestampRateHz
(
)
/
100
)
;
send_test_
-
>
RegisterExternalCodec
(
std
:
:
move
(
external_speech_encoder
)
)
;
}
void
Run
(
const
std
:
:
string
&
audio_checksum_ref
const
std
:
:
string
&
payload_checksum_ref
int
expected_packets
test
:
:
AcmReceiveTestOldApi
:
:
NumOutputChannels
expected_channels
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
=
nullptr
)
{
if
(
!
decoder_factory
)
{
decoder_factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
}
test
:
:
AudioChecksum
audio_checksum
;
const
std
:
:
string
output_file_name
=
webrtc
:
:
test
:
:
OutputPath
(
)
+
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
test_case_name
(
)
+
"
_
"
+
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
name
(
)
+
"
_output
.
wav
"
;
const
int
kOutputFreqHz
=
8000
;
test
:
:
OutputWavFile
output_file
(
output_file_name
kOutputFreqHz
expected_channels
)
;
test
:
:
AudioSinkFork
output
(
&
audio_checksum
&
output_file
)
;
test
:
:
AcmReceiveTestOldApi
receive_test
(
this
&
output
kOutputFreqHz
expected_channels
decoder_factory
)
;
ASSERT_NO_FATAL_FAILURE
(
receive_test
.
RegisterDefaultCodecs
(
)
)
;
receive_test
.
Run
(
)
;
std
:
:
string
checksum_string
=
audio_checksum
.
Finish
(
)
;
ExpectChecksumEq
(
audio_checksum_ref
checksum_string
)
;
rtc
:
:
Buffer
checksum_result
(
payload_checksum_
-
>
Size
(
)
)
;
payload_checksum_
-
>
Finish
(
checksum_result
.
data
(
)
checksum_result
.
size
(
)
)
;
checksum_string
=
rtc
:
:
hex_encode
(
checksum_result
.
data
<
char
>
(
)
checksum_result
.
size
(
)
)
;
ExpectChecksumEq
(
payload_checksum_ref
checksum_string
)
;
EXPECT_EQ
(
expected_packets
packet_count_
)
;
remove
(
output_file_name
.
c_str
(
)
)
;
}
void
ExpectChecksumEq
(
std
:
:
string
ref
std
:
:
string
result
)
{
if
(
ref
.
size
(
)
=
=
result
.
size
(
)
)
{
EXPECT_EQ
(
ref
result
)
;
}
else
{
EXPECT_NE
(
ref
.
find
(
result
)
std
:
:
string
:
:
npos
)
<
<
result
<
<
"
must
be
one
of
these
:
\
n
"
<
<
ref
;
}
}
std
:
:
unique_ptr
<
test
:
:
Packet
>
NextPacket
(
)
override
{
auto
packet
=
send_test_
-
>
NextPacket
(
)
;
if
(
!
packet
)
return
NULL
;
VerifyPacket
(
packet
.
get
(
)
)
;
return
packet
;
}
void
VerifyPacket
(
const
test
:
:
Packet
*
packet
)
{
EXPECT_TRUE
(
packet
-
>
valid_header
(
)
)
;
EXPECT_EQ
(
payload_type_
packet
-
>
header
(
)
.
payloadType
)
;
if
(
packet_count_
>
0
)
{
uint16_t
sequence_number_diff
=
packet
-
>
header
(
)
.
sequenceNumber
-
last_sequence_number_
;
EXPECT_EQ
(
1
sequence_number_diff
)
;
uint32_t
timestamp_diff
=
packet
-
>
header
(
)
.
timestamp
-
last_timestamp_
;
EXPECT_EQ
(
frame_size_rtp_timestamps_
timestamp_diff
)
;
}
+
+
packet_count_
;
last_sequence_number_
=
packet
-
>
header
(
)
.
sequenceNumber
;
last_timestamp_
=
packet
-
>
header
(
)
.
timestamp
;
payload_checksum_
-
>
Update
(
packet
-
>
payload
(
)
packet
-
>
payload_length_bytes
(
)
)
;
}
void
SetUpTest
(
const
char
*
codec_name
int
codec_sample_rate_hz
int
channels
int
payload_type
int
codec_frame_size_samples
int
codec_frame_size_rtp_timestamps
)
{
ASSERT_TRUE
(
SetUpSender
(
channels
=
=
1
?
kTestFileMono32kHz
:
kTestFileFakeStereo32kHz
32000
)
)
;
ASSERT_TRUE
(
RegisterSendCodec
(
codec_name
codec_sample_rate_hz
channels
payload_type
codec_frame_size_samples
codec_frame_size_rtp_timestamps
)
)
;
}
void
SetUpTestExternalEncoder
(
std
:
:
unique_ptr
<
AudioEncoder
>
external_speech_encoder
int
payload_type
)
{
ASSERT_TRUE
(
send_test_
)
;
RegisterExternalSendCodec
(
std
:
:
move
(
external_speech_encoder
)
payload_type
)
;
}
std
:
:
unique_ptr
<
test
:
:
AcmSendTestOldApi
>
send_test_
;
std
:
:
unique_ptr
<
test
:
:
InputAudioFile
>
audio_source_
;
uint32_t
frame_size_rtp_timestamps_
;
int
packet_count_
;
uint8_t
payload_type_
;
uint16_t
last_sequence_number_
;
uint32_t
last_timestamp_
;
std
:
:
unique_ptr
<
rtc
:
:
MessageDigest
>
payload_checksum_
;
const
std
:
:
string
kTestFileMono32kHz
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
testfile32kHz
"
"
pcm
"
)
;
const
std
:
:
string
kTestFileFakeStereo32kHz
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
testfile_fake_stereo_32kHz
"
"
pcm
"
)
;
const
std
:
:
string
kTestFileQuad48kHz
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
speech_4_channels_48k_one_second
"
"
wav
"
)
;
}
;
class
AcmSenderBitExactnessNewApi
:
public
AcmSenderBitExactnessOldApi
{
}
;
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
&
&
\
defined
(
NDEBUG
)
TEST_F
(
AcmSenderBitExactnessOldApi
IsacWb30ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
ISAC
"
16000
1
103
480
480
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
#
if
defined
(
WEBRTC_WIN
)
&
&
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
\
defined
(
WEBRTC_ARCH_X86
)
"
2c9cb15d4ed55b5a0cadd04883bc73b0
"
#
else
"
6f7f227f4e2ace7027257eecb7b17e08
"
#
endif
"
9336a9b993cbd8a751f0e8958e66c89c
"
"
5c2eb46199994506236f68b2c8e51b0d
"
"
343f1f42be0607c61e6516aece424609
"
"
2c9cb15d4ed55b5a0cadd04883bc73b0
"
"
2c9cb15d4ed55b5a0cadd04883bc73b0
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
#
if
defined
(
WEBRTC_WIN
)
&
&
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
\
defined
(
WEBRTC_ARCH_X86
)
"
3c79f16f34218271f3dca4e2b1dfe1bb
"
#
else
"
3fbb620556a08bcb88d9134e846bbb8e
"
#
endif
"
d42cb5195463da26c8129bbfe73a22e6
"
"
83de248aea9c3c2bd680b6952401b4ca
"
"
3c79f16f34218271f3dca4e2b1dfe1bb
"
"
3c79f16f34218271f3dca4e2b1dfe1bb
"
"
3c79f16f34218271f3dca4e2b1dfe1bb
"
)
33
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
IsacWb60ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
ISAC
"
16000
1
103
960
960
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
#
if
defined
(
WEBRTC_WIN
)
&
&
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
\
defined
(
WEBRTC_ARCH_X86
)
"
1ad29139a04782a33daad8c2b9b35875
"
#
else
"
8b4377f3048d946d69b771c1e5fa8839
"
#
endif
"
14d63c5f08127d280e722e3191b73bdd
"
"
9a81e467eb1485f84aca796f8ea65011
"
"
ef75e900e6f375e3061163c53fd09a63
"
"
1ad29139a04782a33daad8c2b9b35875
"
"
1ad29139a04782a33daad8c2b9b35875
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
#
if
defined
(
WEBRTC_WIN
)
&
&
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
\
defined
(
WEBRTC_ARCH_X86
)
"
9e0a0ab743ad987b55b8e14802769c56
"
#
else
"
080f341c0d498e7a60522084bf8264ae
"
#
endif
"
ebe04a819d3a9d83a83a17f271e1139a
"
"
97aeef98553b5a4b5a68f8b716e8eaf0
"
"
9e0a0ab743ad987b55b8e14802769c56
"
"
9e0a0ab743ad987b55b8e14802769c56
"
"
9e0a0ab743ad987b55b8e14802769c56
"
)
16
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
#
endif
#
if
defined
(
WEBRTC_ANDROID
)
|
|
!
defined
(
NDEBUG
)
#
define
MAYBE_IsacSwb30ms
DISABLED_IsacSwb30ms
#
else
#
define
MAYBE_IsacSwb30ms
IsacSwb30ms
#
endif
#
if
defined
(
WEBRTC_CODEC_ISAC
)
TEST_F
(
AcmSenderBitExactnessOldApi
MAYBE_IsacSwb30ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
ISAC
"
32000
1
104
960
960
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
#
if
defined
(
WEBRTC_LINUX
)
&
&
defined
(
WEBRTC_ARCH_X86
)
"
521a04159bb991fa2f32f550d5184f60
"
#
elif
defined
(
WEBRTC_WIN
)
&
&
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
\
defined
(
WEBRTC_ARCH_X86
)
"
5683b58da0fbf2063c7adc2e6bfb3fb8
"
#
else
"
c1858ba5d734df6fe52e715eb1b25f31
"
#
endif
"
2b3c387d06f00b7b7aad4c9be56fb83d
"
"
android_arm32_audio
"
"
android_arm64_audio
"
"
android_arm64_clang_audio
"
"
5683b58da0fbf2063c7adc2e6bfb3fb8
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
#
if
defined
(
WEBRTC_WIN
)
&
&
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
\
defined
(
WEBRTC_ARCH_X86
)
"
ce86106a93419aefb063097108ec94ab
"
#
else
"
127e24a1005ac80394b1f88d0cbc72a8
"
#
endif
"
bcc2041e7744c7ebd9f701866856849c
"
"
android_arm32_payload
"
"
android_arm64_payload
"
"
android_arm64_clang_payload
"
"
ce86106a93419aefb063097108ec94ab
"
)
33
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
#
endif
TEST_F
(
AcmSenderBitExactnessOldApi
Pcm16_8000khz_10ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
L16
"
8000
1
107
80
80
)
)
;
Run
(
"
15396f66b5b0ab6842e151c807395e4c
"
"
c1edd36339ce0326cc4550041ad719a0
"
100
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcm16_16000khz_10ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
L16
"
16000
1
108
160
160
)
)
;
Run
(
"
54ae004529874c2b362c7f0ccd19cb99
"
"
ad786526383178b08d80d6eee06e9bad
"
100
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcm16_32000khz_10ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
L16
"
32000
1
109
320
320
)
)
;
Run
(
"
d6a4a68b8c838dcc1e7ae7136467cdf0
"
"
5ef82ea885e922263606c6fdbc49f651
"
100
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcm16_stereo_8000khz_10ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
L16
"
8000
2
111
80
80
)
)
;
Run
(
"
6b011dab43e3a8a46ccff7e4412ed8a2
"
"
62ce5adb0d4965d0a52ec98ae7f98974
"
100
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcm16_stereo_16000khz_10ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
L16
"
16000
2
112
160
160
)
)
;
Run
(
"
17fc9854358bfe0419408290664bd78e
"
"
41ca8edac4b8c71cd54fd9f25ec14870
"
100
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcm16_stereo_32000khz_10ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
L16
"
32000
2
113
320
320
)
)
;
Run
(
"
9ac9a1f64d55da2fc9f3167181cc511d
"
"
50e58502fb04421bf5b857dda4c96879
"
100
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcmu_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
PCMU
"
8000
1
0
160
160
)
)
;
Run
(
"
81a9d4c0bb72e9becc43aef124c981e9
"
"
8f9b8750bd80fe26b6cbf6659b89f0f9
"
50
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcma_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
PCMA
"
8000
1
8
160
160
)
)
;
Run
(
"
39611f798969053925a49dc06d08de29
"
"
6ad745e55aa48981bfc790d0eeef2dd1
"
50
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcmu_stereo_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
PCMU
"
8000
2
110
160
160
)
)
;
Run
(
"
437bec032fdc5cbaa0d5175430af7b18
"
"
60b6f25e8d1e74cb679cfe756dd9bca5
"
50
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
Pcma_stereo_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
PCMA
"
8000
2
118
160
160
)
)
;
Run
(
"
a5c6d83c5b7cedbeff734238220a4b0c
"
"
92b282c83efd20e7eeef52ba40842cf7
"
50
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
#
if
defined
(
WEBRTC_ANDROID
)
#
define
MAYBE_Ilbc_30ms
DISABLED_Ilbc_30ms
#
else
#
define
MAYBE_Ilbc_30ms
Ilbc_30ms
#
endif
#
if
defined
(
WEBRTC_CODEC_ILBC
)
TEST_F
(
AcmSenderBitExactnessOldApi
MAYBE_Ilbc_30ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
ILBC
"
8000
1
102
240
240
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
7b6ec10910debd9af08011d3ed5249f7
"
"
7b6ec10910debd9af08011d3ed5249f7
"
"
android_arm32_audio
"
"
android_arm64_audio
"
"
android_arm64_clang_audio
"
"
7b6ec10910debd9af08011d3ed5249f7
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
cfae2e9f6aba96e145f2bcdd5050ce78
"
"
cfae2e9f6aba96e145f2bcdd5050ce78
"
"
android_arm32_payload
"
"
android_arm64_payload
"
"
android_arm64_clang_payload
"
"
cfae2e9f6aba96e145f2bcdd5050ce78
"
)
33
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
#
endif
#
if
defined
(
WEBRTC_ANDROID
)
#
define
MAYBE_G722_20ms
DISABLED_G722_20ms
#
else
#
define
MAYBE_G722_20ms
G722_20ms
#
endif
TEST_F
(
AcmSenderBitExactnessOldApi
MAYBE_G722_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
G722
"
16000
1
9
320
160
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
e99c89be49a46325d03c0d990c292d68
"
"
e99c89be49a46325d03c0d990c292d68
"
"
android_arm32_audio
"
"
android_arm64_audio
"
"
android_arm64_clang_audio
"
"
e99c89be49a46325d03c0d990c292d68
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
fc68a87e1380614e658087cb35d5ca10
"
"
fc68a87e1380614e658087cb35d5ca10
"
"
android_arm32_payload
"
"
android_arm64_payload
"
"
android_arm64_clang_payload
"
"
fc68a87e1380614e658087cb35d5ca10
"
)
50
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
#
if
defined
(
WEBRTC_ANDROID
)
#
define
MAYBE_G722_stereo_20ms
DISABLED_G722_stereo_20ms
#
else
#
define
MAYBE_G722_stereo_20ms
G722_stereo_20ms
#
endif
TEST_F
(
AcmSenderBitExactnessOldApi
MAYBE_G722_stereo_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
G722
"
16000
2
119
320
160
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
e280aed283e499d37091b481ca094807
"
"
e280aed283e499d37091b481ca094807
"
"
android_arm32_audio
"
"
android_arm64_audio
"
"
android_arm64_clang_audio
"
"
e280aed283e499d37091b481ca094807
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
66516152eeaa1e650ad94ff85f668dac
"
"
66516152eeaa1e650ad94ff85f668dac
"
"
android_arm32_payload
"
"
android_arm64_payload
"
"
android_arm64_clang_payload
"
"
66516152eeaa1e650ad94ff85f668dac
"
)
50
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
namespace
{
const
std
:
:
string
audio_maybe_sse
=
"
e0ddf36854059151cdb7a0c4af3d282a
"
"
|
32574e78db4eab0c467d3c0785e3b484
"
;
const
std
:
:
string
payload_maybe_sse
=
"
b43bdf7638b2bc2a5a6f30bdc640b9ed
"
"
|
c30d463e7ed10bdd1da9045f80561f27
"
;
const
std
:
:
string
audio_checksum
=
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
audio_maybe_sse
audio_maybe_sse
"
6fcceb83acf427730570bc13eeac920c
"
"
fd96f15d547c4e155daeeef4253b174e
"
"
fd96f15d547c4e155daeeef4253b174e
"
"
Mac_arm64_checksum_placeholder
"
)
;
const
std
:
:
string
payload_checksum
=
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
payload_maybe_sse
payload_maybe_sse
"
4bd846d0aa5656ecd5dfd85701a1b78c
"
"
7efbfc9f8e3b4b2933ae2d01ab919028
"
"
7efbfc9f8e3b4b2933ae2d01ab919028
"
"
Mac_arm64_checksum_placeholder
"
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
DISABLED_Opus_stereo_20ms
)
{
ASSERT_NO_FATAL_FAILURE
(
SetUpTest
(
"
opus
"
48000
2
120
960
960
)
)
;
Run
(
audio_checksum
payload_checksum
50
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessNewApi
DISABLED_OpusFromFormat_stereo_20ms
)
{
const
auto
config
=
AudioEncoderOpus
:
:
SdpToConfig
(
SdpAudioFormat
(
"
opus
"
48000
2
{
{
"
stereo
"
"
1
"
}
}
)
)
;
ASSERT_TRUE
(
SetUpSender
(
kTestFileFakeStereo32kHz
32000
)
)
;
ASSERT_NO_FATAL_FAILURE
(
SetUpTestExternalEncoder
(
AudioEncoderOpus
:
:
MakeAudioEncoder
(
*
config
120
)
120
)
)
;
Run
(
audio_checksum
payload_checksum
50
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
TEST_F
(
AcmSenderBitExactnessNewApi
DISABLED_OpusManyChannels
)
{
constexpr
int
kNumChannels
=
4
;
constexpr
int
kOpusPayloadType
=
120
;
ASSERT_TRUE
(
SetUpSender
(
kTestFileQuad48kHz
48000
)
)
;
const
auto
sdp_format
=
SdpAudioFormat
(
"
multiopus
"
48000
kNumChannels
{
{
"
channel_mapping
"
"
0
1
2
3
"
}
{
"
coupled_streams
"
"
2
"
}
{
"
num_streams
"
"
2
"
}
}
)
;
const
auto
encoder_config
=
AudioEncoderMultiChannelOpus
:
:
SdpToConfig
(
sdp_format
)
;
ASSERT_TRUE
(
encoder_config
.
has_value
(
)
)
;
ASSERT_NO_FATAL_FAILURE
(
SetUpTestExternalEncoder
(
AudioEncoderMultiChannelOpus
:
:
MakeAudioEncoder
(
*
encoder_config
kOpusPayloadType
)
kOpusPayloadType
)
)
;
const
auto
decoder_config
=
AudioDecoderMultiChannelOpus
:
:
SdpToConfig
(
sdp_format
)
;
const
auto
opus_decoder
=
AudioDecoderMultiChannelOpus
:
:
MakeAudioDecoder
(
*
decoder_config
)
;
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
=
new
rtc
:
:
RefCountedObject
<
test
:
:
AudioDecoderProxyFactory
>
(
opus_decoder
.
get
(
)
)
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
audio
checksum
check
"
"
downstream
|
8051617907766bec5f4e4a4f7c6d5291
"
"
8051617907766bec5f4e4a4f7c6d5291
"
"
6183752a62dc1368f959eb3a8c93b846
"
"
android
arm64
audio
checksum
"
"
48bf1f3ca0b72f3c9cdfbe79956122b1
"
"
Mac_arm64_checksum_placeholder
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
"
payload
checksum
check
"
"
downstream
|
b09c52e44b2bdd9a0809e3a5b1623a76
"
"
b09c52e44b2bdd9a0809e3a5b1623a76
"
"
2ea535ef60f7d0c9d89e3002d4c2124f
"
"
android
arm64
payload
checksum
"
"
e87995a80f50a0a735a230ca8b04a67d
"
"
Mac_arm64_checksum_placeholder
"
)
50
test
:
:
AcmReceiveTestOldApi
:
:
kQuadOutput
decoder_factory
)
;
}
TEST_F
(
AcmSenderBitExactnessNewApi
DISABLED_OpusFromFormat_stereo_20ms_voip
)
{
auto
config
=
AudioEncoderOpus
:
:
SdpToConfig
(
SdpAudioFormat
(
"
opus
"
48000
2
{
{
"
stereo
"
"
1
"
}
}
)
)
;
config
-
>
application
=
AudioEncoderOpusConfig
:
:
ApplicationMode
:
:
kVoip
;
ASSERT_TRUE
(
SetUpSender
(
kTestFileFakeStereo32kHz
32000
)
)
;
ASSERT_NO_FATAL_FAILURE
(
SetUpTestExternalEncoder
(
AudioEncoderOpus
:
:
MakeAudioEncoder
(
*
config
120
)
120
)
)
;
const
std
:
:
string
audio_maybe_sse
=
"
2d7e5797444f75e5bfeaffbd8c25176b
"
"
|
408d4bdc05a8c23e46c6ac06c5b917ee
"
;
const
std
:
:
string
payload_maybe_sse
=
"
b38b5584cfa7b6999b2e8e996c950c88
"
"
|
eb0752ce1b6f2436fefc2e19bd084fb5
"
;
Run
(
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
audio_maybe_sse
audio_maybe_sse
"
f1cefe107ffdced7694d7f735342adf3
"
"
3b1bfe5dd8ed16ee5b04b93a5b5e7e48
"
"
3b1bfe5dd8ed16ee5b04b93a5b5e7e48
"
"
Mac_arm64_checksum_placeholder
"
)
AcmReceiverBitExactnessOldApi
:
:
PlatformChecksum
(
payload_maybe_sse
payload_maybe_sse
"
5e79a2f51c633fe145b6c10ae198d1aa
"
"
e730050cb304d54d853fd285ab0424fa
"
"
e730050cb304d54d853fd285ab0424fa
"
"
Mac_arm64_checksum_placeholder
"
)
50
test
:
:
AcmReceiveTestOldApi
:
:
kStereoOutput
)
;
}
class
AcmSetBitRateTest
:
public
:
:
testing
:
:
Test
{
protected
:
static
const
int
kTestDurationMs
=
1000
;
bool
SetUpSender
(
)
{
const
std
:
:
string
input_file_name
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
testfile32kHz
"
"
pcm
"
)
;
audio_source_
.
reset
(
new
test
:
:
InputAudioFile
(
input_file_name
)
)
;
static
const
int
kSourceRateHz
=
32000
;
send_test_
.
reset
(
new
test
:
:
AcmSendTestOldApi
(
audio_source_
.
get
(
)
kSourceRateHz
kTestDurationMs
)
)
;
return
send_test_
.
get
(
)
;
}
virtual
bool
RegisterSendCodec
(
const
char
*
payload_name
int
sampling_freq_hz
int
channels
int
payload_type
int
frame_size_samples
int
frame_size_rtp_timestamps
)
{
return
send_test_
-
>
RegisterCodec
(
payload_name
sampling_freq_hz
channels
payload_type
frame_size_samples
)
;
}
void
RegisterExternalSendCodec
(
std
:
:
unique_ptr
<
AudioEncoder
>
external_speech_encoder
int
payload_type
)
{
send_test_
-
>
RegisterExternalCodec
(
std
:
:
move
(
external_speech_encoder
)
)
;
}
void
RunInner
(
int
min_expected_total_bits
int
max_expected_total_bits
)
{
int
nr_bytes
=
0
;
while
(
std
:
:
unique_ptr
<
test
:
:
Packet
>
next_packet
=
send_test_
-
>
NextPacket
(
)
)
{
nr_bytes
+
=
rtc
:
:
checked_cast
<
int
>
(
next_packet
-
>
payload_length_bytes
(
)
)
;
}
EXPECT_LE
(
min_expected_total_bits
nr_bytes
*
8
)
;
EXPECT_GE
(
max_expected_total_bits
nr_bytes
*
8
)
;
}
void
SetUpTest
(
const
char
*
codec_name
int
codec_sample_rate_hz
int
channels
int
payload_type
int
codec_frame_size_samples
int
codec_frame_size_rtp_timestamps
)
{
ASSERT_TRUE
(
SetUpSender
(
)
)
;
ASSERT_TRUE
(
RegisterSendCodec
(
codec_name
codec_sample_rate_hz
channels
payload_type
codec_frame_size_samples
codec_frame_size_rtp_timestamps
)
)
;
}
std
:
:
unique_ptr
<
test
:
:
AcmSendTestOldApi
>
send_test_
;
std
:
:
unique_ptr
<
test
:
:
InputAudioFile
>
audio_source_
;
}
;
class
AcmSetBitRateNewApi
:
public
AcmSetBitRateTest
{
protected
:
void
Run
(
int
min_expected_total_bits
int
max_expected_total_bits
)
{
RunInner
(
min_expected_total_bits
max_expected_total_bits
)
;
}
}
;
TEST_F
(
AcmSetBitRateNewApi
OpusFromFormat_48khz_20ms_10kbps
)
{
const
auto
config
=
AudioEncoderOpus
:
:
SdpToConfig
(
SdpAudioFormat
(
"
opus
"
48000
2
{
{
"
maxaveragebitrate
"
"
10000
"
}
}
)
)
;
ASSERT_TRUE
(
SetUpSender
(
)
)
;
RegisterExternalSendCodec
(
AudioEncoderOpus
:
:
MakeAudioEncoder
(
*
config
107
)
107
)
;
RunInner
(
7000
12000
)
;
}
TEST_F
(
AcmSetBitRateNewApi
OpusFromFormat_48khz_20ms_50kbps
)
{
const
auto
config
=
AudioEncoderOpus
:
:
SdpToConfig
(
SdpAudioFormat
(
"
opus
"
48000
2
{
{
"
maxaveragebitrate
"
"
50000
"
}
}
)
)
;
ASSERT_TRUE
(
SetUpSender
(
)
)
;
RegisterExternalSendCodec
(
AudioEncoderOpus
:
:
MakeAudioEncoder
(
*
config
107
)
107
)
;
RunInner
(
40000
60000
)
;
}
TEST_F
(
AudioCodingModuleTestOldApi
SendingMultiChannelForMonoInput
)
{
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kSamplesPerChannel
=
kSampleRateHz
*
10
/
1000
;
audio_format_
=
SdpAudioFormat
(
{
"
multiopus
"
kSampleRateHz
6
{
{
"
minptime
"
"
10
"
}
{
"
useinbandfec
"
"
1
"
}
{
"
channel_mapping
"
"
0
4
1
2
3
5
"
}
{
"
num_streams
"
"
4
"
}
{
"
coupled_streams
"
"
2
"
}
}
}
)
;
RegisterCodec
(
)
;
input_frame_
.
sample_rate_hz_
=
kSampleRateHz
;
input_frame_
.
num_channels_
=
1
;
input_frame_
.
samples_per_channel_
=
kSamplesPerChannel
;
for
(
size_t
k
=
0
;
k
<
10
;
+
+
k
)
{
ASSERT_GE
(
acm_
-
>
Add10MsData
(
input_frame_
)
0
)
;
input_frame_
.
timestamp_
+
=
kSamplesPerChannel
;
}
}
TEST_F
(
AudioCodingModuleTestOldApi
SendingMultiChannelForStereoInput
)
{
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kSamplesPerChannel
=
(
kSampleRateHz
*
10
)
/
1000
;
audio_format_
=
SdpAudioFormat
(
{
"
multiopus
"
kSampleRateHz
6
{
{
"
minptime
"
"
10
"
}
{
"
useinbandfec
"
"
1
"
}
{
"
channel_mapping
"
"
0
4
1
2
3
5
"
}
{
"
num_streams
"
"
4
"
}
{
"
coupled_streams
"
"
2
"
}
}
}
)
;
RegisterCodec
(
)
;
input_frame_
.
sample_rate_hz_
=
kSampleRateHz
;
input_frame_
.
num_channels_
=
2
;
input_frame_
.
samples_per_channel_
=
kSamplesPerChannel
;
for
(
size_t
k
=
0
;
k
<
10
;
+
+
k
)
{
ASSERT_GE
(
acm_
-
>
Add10MsData
(
input_frame_
)
0
)
;
input_frame_
.
timestamp_
+
=
kSamplesPerChannel
;
}
}
TEST_F
(
AudioCodingModuleTestOldApi
SendingStereoForMonoInput
)
{
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kSamplesPerChannel
=
(
kSampleRateHz
*
10
)
/
1000
;
audio_format_
=
SdpAudioFormat
(
"
L16
"
kSampleRateHz
2
)
;
RegisterCodec
(
)
;
input_frame_
.
sample_rate_hz_
=
kSampleRateHz
;
input_frame_
.
num_channels_
=
1
;
input_frame_
.
samples_per_channel_
=
kSamplesPerChannel
;
for
(
size_t
k
=
0
;
k
<
10
;
+
+
k
)
{
ASSERT_GE
(
acm_
-
>
Add10MsData
(
input_frame_
)
0
)
;
input_frame_
.
timestamp_
+
=
kSamplesPerChannel
;
}
}
TEST_F
(
AudioCodingModuleTestOldApi
SendingMonoForStereoInput
)
{
constexpr
int
kSampleRateHz
=
48000
;
constexpr
int
kSamplesPerChannel
=
(
kSampleRateHz
*
10
)
/
1000
;
audio_format_
=
SdpAudioFormat
(
"
L16
"
kSampleRateHz
1
)
;
RegisterCodec
(
)
;
input_frame_
.
sample_rate_hz_
=
kSampleRateHz
;
input_frame_
.
num_channels_
=
1
;
input_frame_
.
samples_per_channel_
=
kSamplesPerChannel
;
for
(
size_t
k
=
0
;
k
<
10
;
+
+
k
)
{
ASSERT_GE
(
acm_
-
>
Add10MsData
(
input_frame_
)
0
)
;
input_frame_
.
timestamp_
+
=
kSamplesPerChannel
;
}
}
#
if
defined
(
WEBRTC_ANDROID
)
#
define
MAYBE_OpusFromFormat_48khz_20ms_100kbps
\
DISABLED_OpusFromFormat_48khz_20ms_100kbps
#
else
#
define
MAYBE_OpusFromFormat_48khz_20ms_100kbps
\
OpusFromFormat_48khz_20ms_100kbps
#
endif
TEST_F
(
AcmSetBitRateNewApi
MAYBE_OpusFromFormat_48khz_20ms_100kbps
)
{
const
auto
config
=
AudioEncoderOpus
:
:
SdpToConfig
(
SdpAudioFormat
(
"
opus
"
48000
2
{
{
"
maxaveragebitrate
"
"
100000
"
}
}
)
)
;
ASSERT_TRUE
(
SetUpSender
(
)
)
;
RegisterExternalSendCodec
(
AudioEncoderOpus
:
:
MakeAudioEncoder
(
*
config
107
)
107
)
;
RunInner
(
80000
120000
)
;
}
TEST_F
(
AcmSenderBitExactnessOldApi
External_Pcmu_20ms
)
{
AudioEncoderPcmU
:
:
Config
config
;
config
.
frame_size_ms
=
20
;
config
.
num_channels
=
1
;
config
.
payload_type
=
0
;
AudioEncoderPcmU
encoder
(
config
)
;
auto
mock_encoder
=
std
:
:
make_unique
<
MockAudioEncoder
>
(
)
;
EXPECT_CALL
(
*
mock_encoder
SampleRateHz
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
encoder
&
AudioEncoderPcmU
:
:
SampleRateHz
)
)
;
EXPECT_CALL
(
*
mock_encoder
NumChannels
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
encoder
&
AudioEncoderPcmU
:
:
NumChannels
)
)
;
EXPECT_CALL
(
*
mock_encoder
RtpTimestampRateHz
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
encoder
&
AudioEncoderPcmU
:
:
RtpTimestampRateHz
)
)
;
EXPECT_CALL
(
*
mock_encoder
Num10MsFramesInNextPacket
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
encoder
&
AudioEncoderPcmU
:
:
Num10MsFramesInNextPacket
)
)
;
EXPECT_CALL
(
*
mock_encoder
GetTargetBitrate
(
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
encoder
&
AudioEncoderPcmU
:
:
GetTargetBitrate
)
)
;
EXPECT_CALL
(
*
mock_encoder
EncodeImpl
(
_
_
_
)
)
.
Times
(
AtLeast
(
1
)
)
.
WillRepeatedly
(
Invoke
(
&
encoder
static_cast
<
AudioEncoder
:
:
EncodedInfo
(
AudioEncoder
:
:
*
)
(
uint32_t
rtc
:
:
ArrayView
<
const
int16_t
>
rtc
:
:
Buffer
*
)
>
(
&
AudioEncoderPcmU
:
:
Encode
)
)
)
;
ASSERT_TRUE
(
SetUpSender
(
kTestFileMono32kHz
32000
)
)
;
ASSERT_NO_FATAL_FAILURE
(
SetUpTestExternalEncoder
(
std
:
:
move
(
mock_encoder
)
config
.
payload_type
)
)
;
Run
(
"
81a9d4c0bb72e9becc43aef124c981e9
"
"
8f9b8750bd80fe26b6cbf6659b89f0f9
"
50
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
}
class
AcmSwitchingOutputFrequencyOldApi
:
public
:
:
testing
:
:
Test
public
test
:
:
PacketSource
public
test
:
:
AudioSink
{
protected
:
static
const
size_t
kTestNumPackets
=
50
;
static
const
int
kEncodedSampleRateHz
=
16000
;
static
const
size_t
kPayloadLenSamples
=
30
*
kEncodedSampleRateHz
/
1000
;
static
const
int
kPayloadType
=
108
;
AcmSwitchingOutputFrequencyOldApi
(
)
:
first_output_
(
true
)
num_packets_
(
0
)
packet_source_
(
kPayloadLenSamples
kSampleValue
kEncodedSampleRateHz
kPayloadType
)
output_freq_2_
(
0
)
has_toggled_
(
false
)
{
}
void
Run
(
int
output_freq_1
int
output_freq_2
int
toggle_period_ms
)
{
const
std
:
:
string
output_file_name
=
webrtc
:
:
test
:
:
OutputPath
(
)
+
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
test_case_name
(
)
+
"
_
"
+
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
name
(
)
+
"
_output
.
pcm
"
;
test
:
:
OutputAudioFile
output_file
(
output_file_name
)
;
test
:
:
AudioSinkFork
output
(
this
&
output_file
)
;
test
:
:
AcmReceiveTestToggleOutputFreqOldApi
receive_test
(
this
&
output
output_freq_1
output_freq_2
toggle_period_ms
test
:
:
AcmReceiveTestOldApi
:
:
kMonoOutput
)
;
ASSERT_NO_FATAL_FAILURE
(
receive_test
.
RegisterDefaultCodecs
(
)
)
;
output_freq_2_
=
output_freq_2
;
receive_test
.
Run
(
)
;
remove
(
output_file_name
.
c_str
(
)
)
;
}
std
:
:
unique_ptr
<
test
:
:
Packet
>
NextPacket
(
)
override
{
if
(
num_packets_
+
+
>
kTestNumPackets
)
{
EXPECT_TRUE
(
has_toggled_
)
;
return
NULL
;
}
return
packet_source_
.
NextPacket
(
)
;
}
bool
WriteArray
(
const
int16_t
*
audio
size_t
num_samples
)
override
{
if
(
first_output_
)
{
first_output_
=
false
;
return
true
;
}
for
(
size_t
i
=
0
;
i
<
num_samples
;
+
+
i
)
{
EXPECT_EQ
(
kSampleValue
audio
[
i
]
)
;
}
if
(
num_samples
=
=
static_cast
<
size_t
>
(
output_freq_2_
/
100
)
)
has_toggled_
=
true
;
return
true
;
}
const
int16_t
kSampleValue
=
1000
;
bool
first_output_
;
size_t
num_packets_
;
test
:
:
ConstantPcmPacketSource
packet_source_
;
int
output_freq_2_
;
bool
has_toggled_
;
}
;
TEST_F
(
AcmSwitchingOutputFrequencyOldApi
TestWithoutToggling
)
{
Run
(
16000
16000
1000
)
;
}
TEST_F
(
AcmSwitchingOutputFrequencyOldApi
Toggle16KhzTo32Khz
)
{
Run
(
16000
32000
1000
)
;
}
TEST_F
(
AcmSwitchingOutputFrequencyOldApi
Toggle32KhzTo16Khz
)
{
Run
(
32000
16000
1000
)
;
}
TEST_F
(
AcmSwitchingOutputFrequencyOldApi
Toggle16KhzTo8Khz
)
{
Run
(
16000
8000
1000
)
;
}
TEST_F
(
AcmSwitchingOutputFrequencyOldApi
Toggle8KhzTo16Khz
)
{
Run
(
8000
16000
1000
)
;
}
#
endif
}
