#
include
"
modules
/
audio_coding
/
neteq
/
packet_buffer
.
h
"
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
api
/
audio_codecs
/
audio_decoder
.
h
"
#
include
"
api
/
neteq
/
tick_timer
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
decoder_database
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
statistics_calculator
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
namespace
webrtc
{
namespace
{
class
NewTimestampIsLarger
{
public
:
explicit
NewTimestampIsLarger
(
const
Packet
&
new_packet
)
:
new_packet_
(
new_packet
)
{
}
bool
operator
(
)
(
const
Packet
&
packet
)
{
return
(
new_packet_
>
=
packet
)
;
}
private
:
const
Packet
&
new_packet_
;
}
;
bool
EqualSampleRates
(
uint8_t
pt1
uint8_t
pt2
const
DecoderDatabase
&
decoder_database
)
{
auto
*
di1
=
decoder_database
.
GetDecoderInfo
(
pt1
)
;
auto
*
di2
=
decoder_database
.
GetDecoderInfo
(
pt2
)
;
return
di1
&
&
di2
&
&
di1
-
>
SampleRateHz
(
)
=
=
di2
-
>
SampleRateHz
(
)
;
}
void
LogPacketDiscarded
(
int
codec_level
StatisticsCalculator
*
stats
)
{
RTC_CHECK
(
stats
)
;
if
(
codec_level
>
0
)
{
stats
-
>
SecondaryPacketsDiscarded
(
1
)
;
}
else
{
stats
-
>
PacketsDiscarded
(
1
)
;
}
}
}
PacketBuffer
:
:
PacketBuffer
(
size_t
max_number_of_packets
const
TickTimer
*
tick_timer
)
:
max_number_of_packets_
(
max_number_of_packets
)
tick_timer_
(
tick_timer
)
{
}
PacketBuffer
:
:
~
PacketBuffer
(
)
{
Flush
(
)
;
}
void
PacketBuffer
:
:
Flush
(
)
{
buffer_
.
clear
(
)
;
}
bool
PacketBuffer
:
:
Empty
(
)
const
{
return
buffer_
.
empty
(
)
;
}
int
PacketBuffer
:
:
InsertPacket
(
Packet
&
&
packet
StatisticsCalculator
*
stats
)
{
if
(
packet
.
empty
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
InsertPacket
invalid
packet
"
;
return
kInvalidPacket
;
}
RTC_DCHECK_GE
(
packet
.
priority
.
codec_level
0
)
;
RTC_DCHECK_GE
(
packet
.
priority
.
red_level
0
)
;
int
return_val
=
kOK
;
packet
.
waiting_time
=
tick_timer_
-
>
GetNewStopwatch
(
)
;
if
(
buffer_
.
size
(
)
>
=
max_number_of_packets_
)
{
Flush
(
)
;
stats
-
>
FlushedPacketBuffer
(
)
;
RTC_LOG
(
LS_WARNING
)
<
<
"
Packet
buffer
flushed
"
;
return_val
=
kFlushed
;
}
PacketList
:
:
reverse_iterator
rit
=
std
:
:
find_if
(
buffer_
.
rbegin
(
)
buffer_
.
rend
(
)
NewTimestampIsLarger
(
packet
)
)
;
if
(
rit
!
=
buffer_
.
rend
(
)
&
&
packet
.
timestamp
=
=
rit
-
>
timestamp
)
{
LogPacketDiscarded
(
packet
.
priority
.
codec_level
stats
)
;
return
return_val
;
}
PacketList
:
:
iterator
it
=
rit
.
base
(
)
;
if
(
it
!
=
buffer_
.
end
(
)
&
&
packet
.
timestamp
=
=
it
-
>
timestamp
)
{
LogPacketDiscarded
(
it
-
>
priority
.
codec_level
stats
)
;
it
=
buffer_
.
erase
(
it
)
;
}
buffer_
.
insert
(
it
std
:
:
move
(
packet
)
)
;
return
return_val
;
}
int
PacketBuffer
:
:
InsertPacketList
(
PacketList
*
packet_list
const
DecoderDatabase
&
decoder_database
absl
:
:
optional
<
uint8_t
>
*
current_rtp_payload_type
absl
:
:
optional
<
uint8_t
>
*
current_cng_rtp_payload_type
StatisticsCalculator
*
stats
)
{
RTC_DCHECK
(
stats
)
;
bool
flushed
=
false
;
for
(
auto
&
packet
:
*
packet_list
)
{
if
(
decoder_database
.
IsComfortNoise
(
packet
.
payload_type
)
)
{
if
(
*
current_cng_rtp_payload_type
&
&
*
*
current_cng_rtp_payload_type
!
=
packet
.
payload_type
)
{
*
current_rtp_payload_type
=
absl
:
:
nullopt
;
Flush
(
)
;
flushed
=
true
;
}
*
current_cng_rtp_payload_type
=
packet
.
payload_type
;
}
else
if
(
!
decoder_database
.
IsDtmf
(
packet
.
payload_type
)
)
{
if
(
(
*
current_rtp_payload_type
&
&
*
*
current_rtp_payload_type
!
=
packet
.
payload_type
)
|
|
(
*
current_cng_rtp_payload_type
&
&
!
EqualSampleRates
(
packet
.
payload_type
*
*
current_cng_rtp_payload_type
decoder_database
)
)
)
{
*
current_cng_rtp_payload_type
=
absl
:
:
nullopt
;
Flush
(
)
;
flushed
=
true
;
}
*
current_rtp_payload_type
=
packet
.
payload_type
;
}
int
return_val
=
InsertPacket
(
std
:
:
move
(
packet
)
stats
)
;
if
(
return_val
=
=
kFlushed
)
{
flushed
=
true
;
}
else
if
(
return_val
!
=
kOK
)
{
packet_list
-
>
clear
(
)
;
return
return_val
;
}
}
packet_list
-
>
clear
(
)
;
return
flushed
?
kFlushed
:
kOK
;
}
int
PacketBuffer
:
:
NextTimestamp
(
uint32_t
*
next_timestamp
)
const
{
if
(
Empty
(
)
)
{
return
kBufferEmpty
;
}
if
(
!
next_timestamp
)
{
return
kInvalidPointer
;
}
*
next_timestamp
=
buffer_
.
front
(
)
.
timestamp
;
return
kOK
;
}
int
PacketBuffer
:
:
NextHigherTimestamp
(
uint32_t
timestamp
uint32_t
*
next_timestamp
)
const
{
if
(
Empty
(
)
)
{
return
kBufferEmpty
;
}
if
(
!
next_timestamp
)
{
return
kInvalidPointer
;
}
PacketList
:
:
const_iterator
it
;
for
(
it
=
buffer_
.
begin
(
)
;
it
!
=
buffer_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
timestamp
>
=
timestamp
)
{
*
next_timestamp
=
it
-
>
timestamp
;
return
kOK
;
}
}
return
kNotFound
;
}
const
Packet
*
PacketBuffer
:
:
PeekNextPacket
(
)
const
{
return
buffer_
.
empty
(
)
?
nullptr
:
&
buffer_
.
front
(
)
;
}
absl
:
:
optional
<
Packet
>
PacketBuffer
:
:
GetNextPacket
(
)
{
if
(
Empty
(
)
)
{
return
absl
:
:
nullopt
;
}
absl
:
:
optional
<
Packet
>
packet
(
std
:
:
move
(
buffer_
.
front
(
)
)
)
;
RTC_DCHECK
(
!
packet
-
>
empty
(
)
)
;
buffer_
.
pop_front
(
)
;
return
packet
;
}
int
PacketBuffer
:
:
DiscardNextPacket
(
StatisticsCalculator
*
stats
)
{
if
(
Empty
(
)
)
{
return
kBufferEmpty
;
}
const
Packet
&
packet
=
buffer_
.
front
(
)
;
RTC_DCHECK
(
!
packet
.
empty
(
)
)
;
LogPacketDiscarded
(
packet
.
priority
.
codec_level
stats
)
;
buffer_
.
pop_front
(
)
;
return
kOK
;
}
void
PacketBuffer
:
:
DiscardOldPackets
(
uint32_t
timestamp_limit
uint32_t
horizon_samples
StatisticsCalculator
*
stats
)
{
buffer_
.
remove_if
(
[
timestamp_limit
horizon_samples
stats
]
(
const
Packet
&
p
)
{
if
(
timestamp_limit
=
=
p
.
timestamp
|
|
!
IsObsoleteTimestamp
(
p
.
timestamp
timestamp_limit
horizon_samples
)
)
{
return
false
;
}
LogPacketDiscarded
(
p
.
priority
.
codec_level
stats
)
;
return
true
;
}
)
;
}
void
PacketBuffer
:
:
DiscardAllOldPackets
(
uint32_t
timestamp_limit
StatisticsCalculator
*
stats
)
{
DiscardOldPackets
(
timestamp_limit
0
stats
)
;
}
void
PacketBuffer
:
:
DiscardPacketsWithPayloadType
(
uint8_t
payload_type
StatisticsCalculator
*
stats
)
{
buffer_
.
remove_if
(
[
payload_type
stats
]
(
const
Packet
&
p
)
{
if
(
p
.
payload_type
!
=
payload_type
)
{
return
false
;
}
LogPacketDiscarded
(
p
.
priority
.
codec_level
stats
)
;
return
true
;
}
)
;
}
size_t
PacketBuffer
:
:
NumPacketsInBuffer
(
)
const
{
return
buffer_
.
size
(
)
;
}
size_t
PacketBuffer
:
:
NumSamplesInBuffer
(
size_t
last_decoded_length
)
const
{
size_t
num_samples
=
0
;
size_t
last_duration
=
last_decoded_length
;
for
(
const
Packet
&
packet
:
buffer_
)
{
if
(
packet
.
frame
)
{
if
(
packet
.
priority
!
=
Packet
:
:
Priority
(
0
0
)
)
{
continue
;
}
size_t
duration
=
packet
.
frame
-
>
Duration
(
)
;
if
(
duration
>
0
)
{
last_duration
=
duration
;
}
}
num_samples
+
=
last_duration
;
}
return
num_samples
;
}
size_t
PacketBuffer
:
:
GetSpanSamples
(
size_t
last_decoded_length
size_t
sample_rate
bool
count_dtx_waiting_time
)
const
{
if
(
buffer_
.
size
(
)
=
=
0
)
{
return
0
;
}
size_t
span
=
buffer_
.
back
(
)
.
timestamp
-
buffer_
.
front
(
)
.
timestamp
;
if
(
buffer_
.
back
(
)
.
frame
&
&
buffer_
.
back
(
)
.
frame
-
>
Duration
(
)
>
0
)
{
size_t
duration
=
buffer_
.
back
(
)
.
frame
-
>
Duration
(
)
;
if
(
count_dtx_waiting_time
&
&
buffer_
.
back
(
)
.
frame
-
>
IsDtxPacket
(
)
)
{
size_t
waiting_time_samples
=
rtc
:
:
dchecked_cast
<
size_t
>
(
buffer_
.
back
(
)
.
waiting_time
-
>
ElapsedMs
(
)
*
(
sample_rate
/
1000
)
)
;
duration
=
std
:
:
max
(
duration
waiting_time_samples
)
;
}
span
+
=
duration
;
}
else
{
span
+
=
last_decoded_length
;
}
return
span
;
}
bool
PacketBuffer
:
:
ContainsDtxOrCngPacket
(
const
DecoderDatabase
*
decoder_database
)
const
{
RTC_DCHECK
(
decoder_database
)
;
for
(
const
Packet
&
packet
:
buffer_
)
{
if
(
(
packet
.
frame
&
&
packet
.
frame
-
>
IsDtxPacket
(
)
)
|
|
decoder_database
-
>
IsComfortNoise
(
packet
.
payload_type
)
)
{
return
true
;
}
}
return
false
;
}
}
