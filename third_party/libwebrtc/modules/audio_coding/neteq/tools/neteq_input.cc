#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
neteq_input
.
h
"
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
namespace
webrtc
{
namespace
test
{
std
:
:
string
NetEqInput
:
:
ToString
(
const
RtpPacketReceived
&
packet
)
{
StringBuilder
ss
;
ss
<
<
"
{
"
"
time_ms
:
"
<
<
packet
.
arrival_time
(
)
.
ms
(
)
<
<
"
"
"
header
:
{
"
"
pt
:
"
<
<
static_cast
<
int
>
(
packet
.
PayloadType
(
)
)
<
<
"
"
"
sn
:
"
<
<
packet
.
SequenceNumber
(
)
<
<
"
"
"
ts
:
"
<
<
packet
.
Timestamp
(
)
<
<
"
"
"
ssrc
:
"
<
<
packet
.
Ssrc
(
)
<
<
"
}
"
"
payload
bytes
:
"
<
<
packet
.
payload_size
(
)
<
<
"
}
"
;
return
ss
.
Release
(
)
;
}
TimeLimitedNetEqInput
:
:
TimeLimitedNetEqInput
(
std
:
:
unique_ptr
<
NetEqInput
>
input
int64_t
duration_ms
)
:
input_
(
std
:
:
move
(
input
)
)
start_time_ms_
(
input_
-
>
NextEventTime
(
)
)
duration_ms_
(
duration_ms
)
{
}
TimeLimitedNetEqInput
:
:
~
TimeLimitedNetEqInput
(
)
=
default
;
std
:
:
optional
<
int64_t
>
TimeLimitedNetEqInput
:
:
NextPacketTime
(
)
const
{
return
ended_
?
std
:
:
nullopt
:
input_
-
>
NextPacketTime
(
)
;
}
std
:
:
optional
<
int64_t
>
TimeLimitedNetEqInput
:
:
NextOutputEventTime
(
)
const
{
return
ended_
?
std
:
:
nullopt
:
input_
-
>
NextOutputEventTime
(
)
;
}
std
:
:
optional
<
NetEqInput
:
:
SetMinimumDelayInfo
>
TimeLimitedNetEqInput
:
:
NextSetMinimumDelayInfo
(
)
const
{
return
ended_
?
std
:
:
nullopt
:
input_
-
>
NextSetMinimumDelayInfo
(
)
;
}
std
:
:
unique_ptr
<
RtpPacketReceived
>
TimeLimitedNetEqInput
:
:
PopPacket
(
)
{
if
(
ended_
)
{
return
nullptr
;
}
auto
packet
=
input_
-
>
PopPacket
(
)
;
MaybeSetEnded
(
)
;
return
packet
;
}
void
TimeLimitedNetEqInput
:
:
AdvanceOutputEvent
(
)
{
if
(
!
ended_
)
{
input_
-
>
AdvanceOutputEvent
(
)
;
MaybeSetEnded
(
)
;
}
}
void
TimeLimitedNetEqInput
:
:
AdvanceSetMinimumDelay
(
)
{
if
(
!
ended_
)
{
input_
-
>
AdvanceSetMinimumDelay
(
)
;
MaybeSetEnded
(
)
;
}
}
bool
TimeLimitedNetEqInput
:
:
ended
(
)
const
{
return
ended_
|
|
input_
-
>
ended
(
)
;
}
std
:
:
optional
<
RTPHeader
>
TimeLimitedNetEqInput
:
:
NextHeader
(
)
const
{
return
ended_
?
std
:
:
nullopt
:
input_
-
>
NextHeader
(
)
;
}
void
TimeLimitedNetEqInput
:
:
MaybeSetEnded
(
)
{
if
(
NextEventTime
(
)
&
&
start_time_ms_
&
&
*
NextEventTime
(
)
-
*
start_time_ms_
>
duration_ms_
)
{
ended_
=
true
;
}
}
}
}
