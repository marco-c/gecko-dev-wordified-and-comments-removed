#
ifndef
MODULES_AUDIO_CODING_NETEQ_TOOLS_NETEQ_INPUT_H_
#
define
MODULES_AUDIO_CODING_NETEQ_TOOLS_NETEQ_INPUT_H_
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
packet
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
packet_source
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
namespace
webrtc
{
namespace
test
{
class
NetEqInput
{
public
:
struct
PacketData
{
PacketData
(
)
;
~
PacketData
(
)
;
std
:
:
string
ToString
(
)
const
;
RTPHeader
header
;
rtc
:
:
Buffer
payload
;
int64_t
time_ms
;
}
;
struct
SetMinimumDelayInfo
{
SetMinimumDelayInfo
(
int64_t
timestamp_ms_in
int
delay_ms_in
)
:
timestamp_ms
(
timestamp_ms_in
)
delay_ms
(
delay_ms_in
)
{
}
int64_t
timestamp_ms
;
int
delay_ms
;
}
;
virtual
~
NetEqInput
(
)
=
default
;
virtual
absl
:
:
optional
<
int64_t
>
NextPacketTime
(
)
const
=
0
;
virtual
absl
:
:
optional
<
int64_t
>
NextOutputEventTime
(
)
const
=
0
;
virtual
absl
:
:
optional
<
SetMinimumDelayInfo
>
NextSetMinimumDelayInfo
(
)
const
=
0
;
absl
:
:
optional
<
int64_t
>
NextEventTime
(
)
const
{
absl
:
:
optional
<
int64_t
>
next_event_time
=
NextPacketTime
(
)
;
const
auto
next_output_time
=
NextOutputEventTime
(
)
;
if
(
next_output_time
)
{
next_event_time
=
next_event_time
?
std
:
:
min
(
next_event_time
.
value
(
)
next_output_time
.
value
(
)
)
:
next_output_time
;
}
const
auto
next_neteq_minimum_delay
=
NextSetMinimumDelayInfo
(
)
;
if
(
next_neteq_minimum_delay
)
{
next_event_time
=
next_event_time
?
std
:
:
min
(
next_event_time
.
value
(
)
next_neteq_minimum_delay
.
value
(
)
.
timestamp_ms
)
:
next_neteq_minimum_delay
.
value
(
)
.
timestamp_ms
;
}
return
next_event_time
;
}
virtual
std
:
:
unique_ptr
<
PacketData
>
PopPacket
(
)
=
0
;
virtual
void
AdvanceOutputEvent
(
)
=
0
;
virtual
void
AdvanceSetMinimumDelay
(
)
=
0
;
virtual
bool
ended
(
)
const
=
0
;
virtual
absl
:
:
optional
<
RTPHeader
>
NextHeader
(
)
const
=
0
;
}
;
class
TimeLimitedNetEqInput
:
public
NetEqInput
{
public
:
TimeLimitedNetEqInput
(
std
:
:
unique_ptr
<
NetEqInput
>
input
int64_t
duration_ms
)
;
~
TimeLimitedNetEqInput
(
)
override
;
absl
:
:
optional
<
int64_t
>
NextPacketTime
(
)
const
override
;
absl
:
:
optional
<
int64_t
>
NextOutputEventTime
(
)
const
override
;
absl
:
:
optional
<
SetMinimumDelayInfo
>
NextSetMinimumDelayInfo
(
)
const
override
;
std
:
:
unique_ptr
<
PacketData
>
PopPacket
(
)
override
;
void
AdvanceOutputEvent
(
)
override
;
void
AdvanceSetMinimumDelay
(
)
override
;
bool
ended
(
)
const
override
;
absl
:
:
optional
<
RTPHeader
>
NextHeader
(
)
const
override
;
private
:
void
MaybeSetEnded
(
)
;
std
:
:
unique_ptr
<
NetEqInput
>
input_
;
const
absl
:
:
optional
<
int64_t
>
start_time_ms_
;
const
int64_t
duration_ms_
;
bool
ended_
=
false
;
}
;
}
}
#
endif
