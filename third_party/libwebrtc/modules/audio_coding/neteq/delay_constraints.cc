#
include
"
modules
/
audio_coding
/
neteq
/
delay_constraints
.
h
"
#
include
<
algorithm
>
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
namespace
webrtc
{
constexpr
int
kMinBaseMinimumDelayMs
=
0
;
constexpr
int
kMaxBaseMinimumDelayMs
=
10000
;
DelayConstraints
:
:
DelayConstraints
(
int
max_packets_in_buffer
int
base_minimum_delay_ms
)
:
max_packets_in_buffer_
(
max_packets_in_buffer
)
base_minimum_delay_ms_
(
base_minimum_delay_ms
)
effective_minimum_delay_ms_
(
base_minimum_delay_ms
)
minimum_delay_ms_
(
0
)
maximum_delay_ms_
(
0
)
{
}
int
DelayConstraints
:
:
Clamp
(
int
delay_ms
)
const
{
delay_ms
=
std
:
:
max
(
delay_ms
effective_minimum_delay_ms_
)
;
if
(
maximum_delay_ms_
>
0
)
{
delay_ms
=
std
:
:
min
(
delay_ms
maximum_delay_ms_
)
;
}
if
(
packet_len_ms_
>
0
)
{
delay_ms
=
std
:
:
min
(
delay_ms
3
*
max_packets_in_buffer_
*
packet_len_ms_
/
4
)
;
}
return
delay_ms
;
}
bool
DelayConstraints
:
:
SetPacketAudioLength
(
int
length_ms
)
{
if
(
length_ms
<
=
0
)
{
RTC_LOG_F
(
LS_ERROR
)
<
<
"
length_ms
=
"
<
<
length_ms
;
return
false
;
}
packet_len_ms_
=
length_ms
;
return
true
;
}
bool
DelayConstraints
:
:
IsValidMinimumDelay
(
int
delay_ms
)
const
{
return
0
<
=
delay_ms
&
&
delay_ms
<
=
MinimumDelayUpperBound
(
)
;
}
bool
DelayConstraints
:
:
IsValidBaseMinimumDelay
(
int
delay_ms
)
const
{
return
kMinBaseMinimumDelayMs
<
=
delay_ms
&
&
delay_ms
<
=
kMaxBaseMinimumDelayMs
;
}
bool
DelayConstraints
:
:
SetMinimumDelay
(
int
delay_ms
)
{
if
(
!
IsValidMinimumDelay
(
delay_ms
)
)
{
return
false
;
}
minimum_delay_ms_
=
delay_ms
;
UpdateEffectiveMinimumDelay
(
)
;
return
true
;
}
bool
DelayConstraints
:
:
SetMaximumDelay
(
int
delay_ms
)
{
if
(
delay_ms
!
=
0
&
&
delay_ms
<
minimum_delay_ms_
)
{
return
false
;
}
maximum_delay_ms_
=
delay_ms
;
UpdateEffectiveMinimumDelay
(
)
;
return
true
;
}
bool
DelayConstraints
:
:
SetBaseMinimumDelay
(
int
delay_ms
)
{
if
(
!
IsValidBaseMinimumDelay
(
delay_ms
)
)
{
return
false
;
}
base_minimum_delay_ms_
=
delay_ms
;
UpdateEffectiveMinimumDelay
(
)
;
return
true
;
}
int
DelayConstraints
:
:
GetBaseMinimumDelay
(
)
const
{
return
base_minimum_delay_ms_
;
}
void
DelayConstraints
:
:
UpdateEffectiveMinimumDelay
(
)
{
const
int
base_minimum_delay_ms
=
rtc
:
:
SafeClamp
(
base_minimum_delay_ms_
0
MinimumDelayUpperBound
(
)
)
;
effective_minimum_delay_ms_
=
std
:
:
max
(
minimum_delay_ms_
base_minimum_delay_ms
)
;
}
int
DelayConstraints
:
:
MinimumDelayUpperBound
(
)
const
{
int
q75
=
max_packets_in_buffer_
*
packet_len_ms_
*
3
/
4
;
q75
=
q75
>
0
?
q75
:
kMaxBaseMinimumDelayMs
;
const
int
maximum_delay_ms
=
maximum_delay_ms_
>
0
?
maximum_delay_ms_
:
kMaxBaseMinimumDelayMs
;
return
std
:
:
min
(
maximum_delay_ms
q75
)
;
}
}
