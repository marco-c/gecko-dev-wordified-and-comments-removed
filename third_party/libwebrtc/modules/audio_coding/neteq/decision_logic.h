#
ifndef
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_
#
define
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
neteq
/
delay_manager_interface
.
h
"
#
include
"
api
/
neteq
/
neteq
.
h
"
#
include
"
api
/
neteq
/
neteq_controller
.
h
"
#
include
"
api
/
neteq
/
tick_timer
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
buffer_level_filter
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
delay_constraints
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
packet_arrival_history
.
h
"
namespace
webrtc
{
class
DecisionLogic
:
public
NetEqController
{
public
:
DecisionLogic
(
const
Environment
&
env
NetEqController
:
:
Config
config
std
:
:
unique_ptr
<
DelayManagerInterface
>
delay_manager
)
;
DecisionLogic
(
NetEqController
:
:
Config
config
std
:
:
unique_ptr
<
DelayManagerInterface
>
delay_manager
std
:
:
unique_ptr
<
BufferLevelFilter
>
buffer_level_filter
std
:
:
unique_ptr
<
PacketArrivalHistory
>
packet_arrival_history
=
nullptr
)
;
~
DecisionLogic
(
)
override
;
DecisionLogic
(
const
DecisionLogic
&
)
=
delete
;
DecisionLogic
&
operator
=
(
const
DecisionLogic
&
)
=
delete
;
void
Reset
(
)
override
{
}
void
SoftReset
(
)
override
;
void
SetSampleRate
(
int
fs_hz
size_t
output_size_samples
)
override
;
NetEq
:
:
Operation
GetDecision
(
const
NetEqController
:
:
NetEqStatus
&
status
bool
*
reset_decoder
)
override
;
void
ExpandDecision
(
NetEq
:
:
Operation
)
override
{
}
void
AddSampleMemory
(
int32_t
value
)
override
{
sample_memory_
+
=
value
;
}
int
TargetLevelMs
(
)
const
override
;
int
UnlimitedTargetLevelMs
(
)
const
override
;
std
:
:
optional
<
int
>
PacketArrived
(
int
fs_hz
bool
should_update_stats
const
PacketArrivedInfo
&
info
)
override
;
void
RegisterEmptyPacket
(
)
override
{
}
bool
SetMaximumDelay
(
int
delay_ms
)
override
{
return
delay_constraints_
.
SetMaximumDelay
(
delay_ms
)
;
}
bool
SetMinimumDelay
(
int
delay_ms
)
override
{
return
delay_constraints_
.
SetMinimumDelay
(
delay_ms
)
;
}
bool
SetBaseMinimumDelay
(
int
delay_ms
)
override
{
return
delay_constraints_
.
SetBaseMinimumDelay
(
delay_ms
)
;
}
int
GetBaseMinimumDelay
(
)
const
override
{
return
delay_constraints_
.
GetBaseMinimumDelay
(
)
;
}
bool
PeakFound
(
)
const
override
{
return
false
;
}
int
GetFilteredBufferLevel
(
)
const
override
;
void
set_sample_memory
(
int32_t
value
)
override
{
sample_memory_
=
value
;
}
size_t
noise_fast_forward
(
)
const
override
{
return
noise_fast_forward_
;
}
size_t
packet_length_samples
(
)
const
override
{
return
packet_length_samples_
;
}
void
set_packet_length_samples
(
size_t
value
)
override
{
packet_length_samples_
=
value
;
}
void
set_prev_time_scale
(
bool
value
)
override
{
prev_time_scale_
=
value
;
}
private
:
static
const
int
kMinTimescaleInterval
=
5
;
void
FilterBufferLevel
(
size_t
buffer_size_samples
)
;
virtual
NetEq
:
:
Operation
CngOperation
(
NetEqController
:
:
NetEqStatus
status
)
;
virtual
NetEq
:
:
Operation
NoPacket
(
NetEqController
:
:
NetEqStatus
status
)
;
virtual
NetEq
:
:
Operation
ExpectedPacketAvailable
(
NetEqController
:
:
NetEqStatus
status
)
;
virtual
NetEq
:
:
Operation
FuturePacketAvailable
(
NetEqController
:
:
NetEqStatus
status
)
;
bool
TimescaleAllowed
(
)
const
{
return
!
timescale_countdown_
|
|
timescale_countdown_
-
>
Finished
(
)
;
}
bool
UnderTargetLevel
(
)
const
;
bool
PostponeDecode
(
NetEqController
:
:
NetEqStatus
status
)
const
;
bool
PacketTooEarly
(
NetEqController
:
:
NetEqStatus
status
)
const
;
int
GetPlayoutDelayMs
(
NetEqController
:
:
NetEqStatus
status
)
const
;
std
:
:
unique_ptr
<
DelayManagerInterface
>
delay_manager_
;
DelayConstraints
delay_constraints_
;
std
:
:
unique_ptr
<
BufferLevelFilter
>
buffer_level_filter_
;
std
:
:
unique_ptr
<
PacketArrivalHistory
>
packet_arrival_history_
;
const
TickTimer
*
tick_timer_
;
int
sample_rate_khz_
;
size_t
output_size_samples_
;
size_t
noise_fast_forward_
=
0
;
size_t
packet_length_samples_
=
0
;
int
sample_memory_
=
0
;
bool
prev_time_scale_
=
false
;
bool
disallow_time_stretching_
;
std
:
:
unique_ptr
<
TickTimer
:
:
Countdown
>
timescale_countdown_
;
int
time_stretched_cn_samples_
=
0
;
bool
buffer_flush_
=
false
;
}
;
}
#
endif
