#
ifndef
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_
#
define
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_
#
include
<
memory
>
#
include
"
api
/
neteq
/
neteq
.
h
"
#
include
"
api
/
neteq
/
neteq_controller
.
h
"
#
include
"
api
/
neteq
/
tick_timer
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
buffer_level_filter
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
delay_manager
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
namespace
webrtc
{
class
DecisionLogic
:
public
NetEqController
{
public
:
static
const
int
kReinitAfterExpands
=
100
;
static
const
int
kMaxWaitForPacket
=
10
;
DecisionLogic
(
NetEqController
:
:
Config
config
)
;
DecisionLogic
(
NetEqController
:
:
Config
config
std
:
:
unique_ptr
<
DelayManager
>
delay_manager
std
:
:
unique_ptr
<
BufferLevelFilter
>
buffer_level_filter
)
;
~
DecisionLogic
(
)
override
;
DecisionLogic
(
const
DecisionLogic
&
)
=
delete
;
DecisionLogic
&
operator
=
(
const
DecisionLogic
&
)
=
delete
;
void
Reset
(
)
override
;
void
SoftReset
(
)
override
;
void
SetSampleRate
(
int
fs_hz
size_t
output_size_samples
)
override
;
NetEq
:
:
Operation
GetDecision
(
const
NetEqController
:
:
NetEqStatus
&
status
bool
*
reset_decoder
)
override
;
bool
CngRfc3389On
(
)
const
override
{
return
cng_state_
=
=
kCngRfc3389On
;
}
bool
CngOff
(
)
const
override
{
return
cng_state_
=
=
kCngOff
;
}
void
SetCngOff
(
)
override
{
cng_state_
=
kCngOff
;
}
void
ExpandDecision
(
NetEq
:
:
Operation
operation
)
override
;
void
AddSampleMemory
(
int32_t
value
)
override
{
sample_memory_
+
=
value
;
}
int
TargetLevelMs
(
)
const
override
{
return
delay_manager_
-
>
TargetDelayMs
(
)
;
}
absl
:
:
optional
<
int
>
PacketArrived
(
int
fs_hz
bool
should_update_stats
const
PacketArrivedInfo
&
info
)
override
;
void
RegisterEmptyPacket
(
)
override
{
}
void
NotifyMutedState
(
)
override
{
}
bool
SetMaximumDelay
(
int
delay_ms
)
override
{
return
delay_manager_
-
>
SetMaximumDelay
(
delay_ms
)
;
}
bool
SetMinimumDelay
(
int
delay_ms
)
override
{
return
delay_manager_
-
>
SetMinimumDelay
(
delay_ms
)
;
}
bool
SetBaseMinimumDelay
(
int
delay_ms
)
override
{
return
delay_manager_
-
>
SetBaseMinimumDelay
(
delay_ms
)
;
}
int
GetBaseMinimumDelay
(
)
const
override
{
return
delay_manager_
-
>
GetBaseMinimumDelay
(
)
;
}
bool
PeakFound
(
)
const
override
{
return
false
;
}
int
GetFilteredBufferLevel
(
)
const
override
{
return
buffer_level_filter_
-
>
filtered_current_level
(
)
;
}
void
set_sample_memory
(
int32_t
value
)
override
{
sample_memory_
=
value
;
}
size_t
noise_fast_forward
(
)
const
override
{
return
noise_fast_forward_
;
}
size_t
packet_length_samples
(
)
const
override
{
return
packet_length_samples_
;
}
void
set_packet_length_samples
(
size_t
value
)
override
{
packet_length_samples_
=
value
;
}
void
set_prev_time_scale
(
bool
value
)
override
{
prev_time_scale_
=
value
;
}
private
:
static
const
int
kMinTimescaleInterval
=
5
;
enum
CngState
{
kCngOff
kCngRfc3389On
kCngInternalOn
}
;
void
FilterBufferLevel
(
size_t
buffer_size_samples
)
;
virtual
NetEq
:
:
Operation
CngOperation
(
NetEq
:
:
Mode
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
size_t
generated_noise_samples
)
;
virtual
NetEq
:
:
Operation
NoPacket
(
bool
play_dtmf
)
;
virtual
NetEq
:
:
Operation
ExpectedPacketAvailable
(
NetEq
:
:
Mode
prev_mode
bool
play_dtmf
)
;
virtual
NetEq
:
:
Operation
FuturePacketAvailable
(
size_t
decoder_frame_length
NetEq
:
:
Mode
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
bool
play_dtmf
size_t
generated_noise_samples
size_t
span_samples_in_packet_buffer
size_t
num_packets_in_packet_buffer
)
;
bool
TimescaleAllowed
(
)
const
{
return
!
timescale_countdown_
|
|
timescale_countdown_
-
>
Finished
(
)
;
}
bool
UnderTargetLevel
(
)
const
;
bool
ReinitAfterExpands
(
uint32_t
timestamp_leap
)
const
;
bool
PacketTooEarly
(
uint32_t
timestamp_leap
)
const
;
bool
MaxWaitForPacket
(
)
const
;
std
:
:
unique_ptr
<
DelayManager
>
delay_manager_
;
std
:
:
unique_ptr
<
BufferLevelFilter
>
buffer_level_filter_
;
const
TickTimer
*
tick_timer_
;
int
sample_rate_
;
size_t
output_size_samples_
;
CngState
cng_state_
=
kCngOff
;
size_t
noise_fast_forward_
=
0
;
size_t
packet_length_samples_
=
0
;
int
sample_memory_
=
0
;
bool
prev_time_scale_
=
false
;
bool
disallow_time_stretching_
;
std
:
:
unique_ptr
<
TickTimer
:
:
Countdown
>
timescale_countdown_
;
int
num_consecutive_expands_
=
0
;
int
time_stretched_cn_samples_
=
0
;
bool
last_pack_cng_or_dtmf_
=
true
;
bool
buffer_flush_
=
false
;
FieldTrialConstrained
<
int
>
target_level_window_ms_
;
}
;
}
#
endif
