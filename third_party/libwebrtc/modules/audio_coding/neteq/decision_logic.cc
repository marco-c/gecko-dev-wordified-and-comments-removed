#
include
"
modules
/
audio_coding
/
neteq
/
decision_logic
.
h
"
#
include
<
stdio
.
h
>
#
include
<
string
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
packet_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
namespace
{
constexpr
int
kPostponeDecodingLevel
=
50
;
constexpr
int
kDefaultTargetLevelWindowMs
=
100
;
constexpr
int
kDecelerationTargetLevelOffsetMs
=
85
;
}
namespace
webrtc
{
DecisionLogic
:
:
DecisionLogic
(
NetEqController
:
:
Config
config
)
:
DecisionLogic
(
config
DelayManager
:
:
Create
(
config
.
max_packets_in_buffer
config
.
base_min_delay_ms
config
.
tick_timer
)
std
:
:
make_unique
<
BufferLevelFilter
>
(
)
)
{
}
DecisionLogic
:
:
DecisionLogic
(
NetEqController
:
:
Config
config
std
:
:
unique_ptr
<
DelayManager
>
delay_manager
std
:
:
unique_ptr
<
BufferLevelFilter
>
buffer_level_filter
)
:
delay_manager_
(
std
:
:
move
(
delay_manager
)
)
buffer_level_filter_
(
std
:
:
move
(
buffer_level_filter
)
)
tick_timer_
(
config
.
tick_timer
)
disallow_time_stretching_
(
!
config
.
allow_time_stretching
)
timescale_countdown_
(
tick_timer_
-
>
GetNewCountdown
(
kMinTimescaleInterval
+
1
)
)
estimate_dtx_delay_
(
"
estimate_dtx_delay
"
true
)
time_stretch_cn_
(
"
time_stretch_cn
"
true
)
target_level_window_ms_
(
"
target_level_window
"
kDefaultTargetLevelWindowMs
0
absl
:
:
nullopt
)
{
const
std
:
:
string
field_trial_name
=
field_trial
:
:
FindFullName
(
"
WebRTC
-
Audio
-
NetEqDecisionLogicSettings
"
)
;
ParseFieldTrial
(
{
&
estimate_dtx_delay_
&
time_stretch_cn_
&
target_level_window_ms_
}
field_trial_name
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
NetEq
decision
logic
settings
:
"
"
estimate_dtx_delay
=
"
<
<
static_cast
<
bool
>
(
estimate_dtx_delay_
)
<
<
"
time_stretch_cn
=
"
<
<
static_cast
<
bool
>
(
time_stretch_cn_
)
<
<
"
target_level_window_ms
=
"
<
<
target_level_window_ms_
;
}
DecisionLogic
:
:
~
DecisionLogic
(
)
=
default
;
void
DecisionLogic
:
:
Reset
(
)
{
cng_state_
=
kCngOff
;
noise_fast_forward_
=
0
;
packet_length_samples_
=
0
;
sample_memory_
=
0
;
prev_time_scale_
=
false
;
last_pack_cng_or_dtmf_
=
true
;
timescale_countdown_
.
reset
(
)
;
num_consecutive_expands_
=
0
;
time_stretched_cn_samples_
=
0
;
}
void
DecisionLogic
:
:
SoftReset
(
)
{
packet_length_samples_
=
0
;
sample_memory_
=
0
;
prev_time_scale_
=
false
;
last_pack_cng_or_dtmf_
=
true
;
timescale_countdown_
=
tick_timer_
-
>
GetNewCountdown
(
kMinTimescaleInterval
+
1
)
;
time_stretched_cn_samples_
=
0
;
delay_manager_
-
>
Reset
(
)
;
buffer_level_filter_
-
>
Reset
(
)
;
}
void
DecisionLogic
:
:
SetSampleRate
(
int
fs_hz
size_t
output_size_samples
)
{
RTC_DCHECK
(
fs_hz
=
=
8000
|
|
fs_hz
=
=
16000
|
|
fs_hz
=
=
32000
|
|
fs_hz
=
=
48000
)
;
sample_rate_
=
fs_hz
;
output_size_samples_
=
output_size_samples
;
}
NetEq
:
:
Operation
DecisionLogic
:
:
GetDecision
(
const
NetEqStatus
&
status
bool
*
reset_decoder
)
{
if
(
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kRfc3389Cng
)
{
cng_state_
=
kCngRfc3389On
;
}
else
if
(
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kCodecInternalCng
)
{
cng_state_
=
kCngInternalOn
;
}
size_t
cur_size_samples
=
estimate_dtx_delay_
?
status
.
packet_buffer_info
.
span_samples
:
status
.
packet_buffer_info
.
num_samples
;
prev_time_scale_
=
prev_time_scale_
&
&
(
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kAccelerateSuccess
|
|
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kAccelerateLowEnergy
|
|
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kPreemptiveExpandSuccess
|
|
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kPreemptiveExpandLowEnergy
)
;
if
(
status
.
last_mode
!
=
NetEq
:
:
Mode
:
:
kRfc3389Cng
&
&
status
.
last_mode
!
=
NetEq
:
:
Mode
:
:
kCodecInternalCng
&
&
!
(
status
.
next_packet
&
&
status
.
next_packet
-
>
is_dtx
&
&
!
estimate_dtx_delay_
)
)
{
FilterBufferLevel
(
cur_size_samples
)
;
}
if
(
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kError
)
{
if
(
!
status
.
next_packet
)
{
return
NetEq
:
:
Operation
:
:
kExpand
;
}
else
{
return
NetEq
:
:
Operation
:
:
kUndefined
;
}
}
if
(
status
.
next_packet
&
&
status
.
next_packet
-
>
is_cng
)
{
return
CngOperation
(
status
.
last_mode
status
.
target_timestamp
status
.
next_packet
-
>
timestamp
status
.
generated_noise_samples
)
;
}
if
(
!
status
.
next_packet
)
{
return
NoPacket
(
status
.
play_dtmf
)
;
}
if
(
num_consecutive_expands_
>
kReinitAfterExpands
)
{
*
reset_decoder
=
true
;
return
NetEq
:
:
Operation
:
:
kNormal
;
}
const
size_t
current_span
=
estimate_dtx_delay_
?
status
.
packet_buffer_info
.
span_samples
:
status
.
packet_buffer_info
.
span_samples_no_dtx
;
const
int
target_level_samples
=
delay_manager_
-
>
TargetDelayMs
(
)
*
sample_rate_
/
1000
;
if
(
(
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kExpand
|
|
status
.
last_mode
=
=
NetEq
:
:
Mode
:
:
kCodecPlc
)
&
&
status
.
expand_mutefactor
<
16384
/
2
&
&
current_span
<
static_cast
<
size_t
>
(
target_level_samples
*
kPostponeDecodingLevel
/
100
)
&
&
!
status
.
packet_buffer_info
.
dtx_or_cng
)
{
return
NetEq
:
:
Operation
:
:
kExpand
;
}
const
uint32_t
five_seconds_samples
=
static_cast
<
uint32_t
>
(
5
*
sample_rate_
)
;
if
(
status
.
target_timestamp
=
=
status
.
next_packet
-
>
timestamp
)
{
return
ExpectedPacketAvailable
(
status
.
last_mode
status
.
play_dtmf
)
;
}
else
if
(
!
PacketBuffer
:
:
IsObsoleteTimestamp
(
status
.
next_packet
-
>
timestamp
status
.
target_timestamp
five_seconds_samples
)
)
{
return
FuturePacketAvailable
(
status
.
last_packet_samples
status
.
last_mode
status
.
target_timestamp
status
.
next_packet
-
>
timestamp
status
.
play_dtmf
status
.
generated_noise_samples
status
.
packet_buffer_info
.
span_samples
status
.
packet_buffer_info
.
num_packets
)
;
}
else
{
return
NetEq
:
:
Operation
:
:
kUndefined
;
}
}
void
DecisionLogic
:
:
ExpandDecision
(
NetEq
:
:
Operation
operation
)
{
if
(
operation
=
=
NetEq
:
:
Operation
:
:
kExpand
)
{
num_consecutive_expands_
+
+
;
}
else
{
num_consecutive_expands_
=
0
;
}
}
absl
:
:
optional
<
int
>
DecisionLogic
:
:
PacketArrived
(
int
fs_hz
bool
should_update_stats
const
PacketArrivedInfo
&
info
)
{
buffer_flush_
=
buffer_flush_
|
|
info
.
buffer_flush
;
if
(
info
.
is_cng_or_dtmf
)
{
last_pack_cng_or_dtmf_
=
true
;
return
absl
:
:
nullopt
;
}
if
(
!
should_update_stats
)
{
return
absl
:
:
nullopt
;
}
if
(
info
.
packet_length_samples
>
0
&
&
fs_hz
>
0
&
&
info
.
packet_length_samples
!
=
packet_length_samples_
)
{
packet_length_samples_
=
info
.
packet_length_samples
;
delay_manager_
-
>
SetPacketAudioLength
(
packet_length_samples_
*
1000
/
fs_hz
)
;
}
auto
relative_delay
=
delay_manager_
-
>
Update
(
info
.
main_timestamp
fs_hz
last_pack_cng_or_dtmf_
)
;
last_pack_cng_or_dtmf_
=
false
;
return
relative_delay
;
}
void
DecisionLogic
:
:
FilterBufferLevel
(
size_t
buffer_size_samples
)
{
buffer_level_filter_
-
>
SetTargetBufferLevel
(
delay_manager_
-
>
TargetDelayMs
(
)
)
;
int
time_stretched_samples
=
time_stretched_cn_samples_
;
if
(
prev_time_scale_
)
{
time_stretched_samples
+
=
sample_memory_
;
timescale_countdown_
=
tick_timer_
-
>
GetNewCountdown
(
kMinTimescaleInterval
)
;
}
if
(
buffer_flush_
)
{
buffer_level_filter_
-
>
SetFilteredBufferLevel
(
buffer_size_samples
)
;
buffer_flush_
=
false
;
}
else
{
buffer_level_filter_
-
>
Update
(
buffer_size_samples
time_stretched_samples
)
;
}
prev_time_scale_
=
false
;
time_stretched_cn_samples_
=
0
;
}
NetEq
:
:
Operation
DecisionLogic
:
:
CngOperation
(
NetEq
:
:
Mode
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
size_t
generated_noise_samples
)
{
int32_t
timestamp_diff
=
static_cast
<
int32_t
>
(
static_cast
<
uint32_t
>
(
generated_noise_samples
+
target_timestamp
)
-
available_timestamp
)
;
int
optimal_level_samp
=
delay_manager_
-
>
TargetDelayMs
(
)
*
sample_rate_
/
1000
;
const
int64_t
excess_waiting_time_samp
=
-
static_cast
<
int64_t
>
(
timestamp_diff
)
-
optimal_level_samp
;
if
(
excess_waiting_time_samp
>
optimal_level_samp
/
2
)
{
noise_fast_forward_
=
rtc
:
:
saturated_cast
<
size_t
>
(
noise_fast_forward_
+
excess_waiting_time_samp
)
;
timestamp_diff
=
rtc
:
:
saturated_cast
<
int32_t
>
(
timestamp_diff
+
excess_waiting_time_samp
)
;
}
if
(
timestamp_diff
<
0
&
&
prev_mode
=
=
NetEq
:
:
Mode
:
:
kRfc3389Cng
)
{
return
NetEq
:
:
Operation
:
:
kRfc3389CngNoPacket
;
}
else
{
noise_fast_forward_
=
0
;
return
NetEq
:
:
Operation
:
:
kRfc3389Cng
;
}
}
NetEq
:
:
Operation
DecisionLogic
:
:
NoPacket
(
bool
play_dtmf
)
{
if
(
cng_state_
=
=
kCngRfc3389On
)
{
return
NetEq
:
:
Operation
:
:
kRfc3389CngNoPacket
;
}
else
if
(
cng_state_
=
=
kCngInternalOn
)
{
return
NetEq
:
:
Operation
:
:
kCodecInternalCng
;
}
else
if
(
play_dtmf
)
{
return
NetEq
:
:
Operation
:
:
kDtmf
;
}
else
{
return
NetEq
:
:
Operation
:
:
kExpand
;
}
}
NetEq
:
:
Operation
DecisionLogic
:
:
ExpectedPacketAvailable
(
NetEq
:
:
Mode
prev_mode
bool
play_dtmf
)
{
if
(
!
disallow_time_stretching_
&
&
prev_mode
!
=
NetEq
:
:
Mode
:
:
kExpand
&
&
!
play_dtmf
)
{
const
int
samples_per_ms
=
sample_rate_
/
1000
;
const
int
target_level_samples
=
delay_manager_
-
>
TargetDelayMs
(
)
*
samples_per_ms
;
const
int
low_limit
=
std
:
:
max
(
target_level_samples
*
3
/
4
target_level_samples
-
kDecelerationTargetLevelOffsetMs
*
samples_per_ms
)
;
const
int
high_limit
=
std
:
:
max
(
target_level_samples
low_limit
+
20
*
samples_per_ms
)
;
const
int
buffer_level_samples
=
buffer_level_filter_
-
>
filtered_current_level
(
)
;
if
(
buffer_level_samples
>
=
high_limit
<
<
2
)
return
NetEq
:
:
Operation
:
:
kFastAccelerate
;
if
(
TimescaleAllowed
(
)
)
{
if
(
buffer_level_samples
>
=
high_limit
)
return
NetEq
:
:
Operation
:
:
kAccelerate
;
if
(
buffer_level_samples
<
low_limit
)
return
NetEq
:
:
Operation
:
:
kPreemptiveExpand
;
}
}
return
NetEq
:
:
Operation
:
:
kNormal
;
}
NetEq
:
:
Operation
DecisionLogic
:
:
FuturePacketAvailable
(
size_t
decoder_frame_length
NetEq
:
:
Mode
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
bool
play_dtmf
size_t
generated_noise_samples
size_t
span_samples_in_packet_buffer
size_t
num_packets_in_packet_buffer
)
{
uint32_t
timestamp_leap
=
available_timestamp
-
target_timestamp
;
if
(
(
prev_mode
=
=
NetEq
:
:
Mode
:
:
kExpand
|
|
prev_mode
=
=
NetEq
:
:
Mode
:
:
kCodecPlc
)
&
&
!
ReinitAfterExpands
(
timestamp_leap
)
&
&
!
MaxWaitForPacket
(
)
&
&
PacketTooEarly
(
timestamp_leap
)
&
&
UnderTargetLevel
(
)
)
{
if
(
play_dtmf
)
{
return
NetEq
:
:
Operation
:
:
kDtmf
;
}
else
{
return
NetEq
:
:
Operation
:
:
kExpand
;
}
}
if
(
prev_mode
=
=
NetEq
:
:
Mode
:
:
kCodecPlc
)
{
return
NetEq
:
:
Operation
:
:
kNormal
;
}
if
(
prev_mode
=
=
NetEq
:
:
Mode
:
:
kRfc3389Cng
|
|
prev_mode
=
=
NetEq
:
:
Mode
:
:
kCodecInternalCng
)
{
size_t
cur_size_samples
=
estimate_dtx_delay_
?
span_samples_in_packet_buffer
:
num_packets_in_packet_buffer
*
decoder_frame_length
;
const
size_t
target_level_samples
=
delay_manager_
-
>
TargetDelayMs
(
)
*
sample_rate_
/
1000
;
const
bool
generated_enough_noise
=
static_cast
<
uint32_t
>
(
generated_noise_samples
+
target_timestamp
)
>
=
available_timestamp
;
if
(
time_stretch_cn_
)
{
const
size_t
target_threshold_samples
=
target_level_window_ms_
/
2
*
(
sample_rate_
/
1000
)
;
const
bool
above_target_window
=
cur_size_samples
>
target_level_samples
+
target_threshold_samples
;
const
bool
below_target_window
=
target_level_samples
>
target_threshold_samples
&
&
cur_size_samples
<
target_level_samples
-
target_threshold_samples
;
if
(
(
generated_enough_noise
&
&
!
below_target_window
)
|
|
above_target_window
)
{
time_stretched_cn_samples_
=
timestamp_leap
-
generated_noise_samples
;
return
NetEq
:
:
Operation
:
:
kNormal
;
}
}
else
{
if
(
generated_enough_noise
|
|
cur_size_samples
>
target_level_samples
*
4
)
{
return
NetEq
:
:
Operation
:
:
kNormal
;
}
}
if
(
prev_mode
=
=
NetEq
:
:
Mode
:
:
kRfc3389Cng
)
{
return
NetEq
:
:
Operation
:
:
kRfc3389CngNoPacket
;
}
return
NetEq
:
:
Operation
:
:
kCodecInternalCng
;
}
if
(
prev_mode
=
=
NetEq
:
:
Mode
:
:
kExpand
)
{
return
NetEq
:
:
Operation
:
:
kMerge
;
}
else
if
(
play_dtmf
)
{
return
NetEq
:
:
Operation
:
:
kDtmf
;
}
else
{
return
NetEq
:
:
Operation
:
:
kExpand
;
}
}
bool
DecisionLogic
:
:
UnderTargetLevel
(
)
const
{
return
buffer_level_filter_
-
>
filtered_current_level
(
)
<
delay_manager_
-
>
TargetDelayMs
(
)
*
sample_rate_
/
1000
;
}
bool
DecisionLogic
:
:
ReinitAfterExpands
(
uint32_t
timestamp_leap
)
const
{
return
timestamp_leap
>
=
static_cast
<
uint32_t
>
(
output_size_samples_
*
kReinitAfterExpands
)
;
}
bool
DecisionLogic
:
:
PacketTooEarly
(
uint32_t
timestamp_leap
)
const
{
return
timestamp_leap
>
static_cast
<
uint32_t
>
(
output_size_samples_
*
num_consecutive_expands_
)
;
}
bool
DecisionLogic
:
:
MaxWaitForPacket
(
)
const
{
return
num_consecutive_expands_
>
=
kMaxWaitForPacket
;
}
}
