#
ifndef
MODULES_AUDIO_CODING_CODECS_OPUS_AUDIO_CODER_OPUS_COMMON_H_
#
define
MODULES_AUDIO_CODING_CODECS_OPUS_AUDIO_CODER_OPUS_COMMON_H_
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
audio_codecs
/
audio_decoder
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
rtc_base
/
string_to_number
.
h
"
namespace
webrtc
{
std
:
:
optional
<
std
:
:
string
>
GetFormatParameter
(
const
SdpAudioFormat
&
format
absl
:
:
string_view
param
)
;
template
<
typename
T
>
std
:
:
optional
<
T
>
GetFormatParameter
(
const
SdpAudioFormat
&
format
absl
:
:
string_view
param
)
{
return
StringToNumber
<
T
>
(
GetFormatParameter
(
format
param
)
.
value_or
(
"
"
)
)
;
}
template
<
>
std
:
:
optional
<
std
:
:
vector
<
unsigned
char
>
>
GetFormatParameter
(
const
SdpAudioFormat
&
format
absl
:
:
string_view
param
)
;
class
OpusFrame
:
public
AudioDecoder
:
:
EncodedAudioFrame
{
public
:
OpusFrame
(
AudioDecoder
*
decoder
Buffer
&
&
payload
bool
is_primary_payload
)
:
decoder_
(
decoder
)
payload_
(
std
:
:
move
(
payload
)
)
is_primary_payload_
(
is_primary_payload
)
{
}
size_t
Duration
(
)
const
override
{
int
ret
;
if
(
is_primary_payload_
)
{
ret
=
decoder_
-
>
PacketDuration
(
payload_
.
data
(
)
payload_
.
size
(
)
)
;
}
else
{
ret
=
decoder_
-
>
PacketDurationRedundant
(
payload_
.
data
(
)
payload_
.
size
(
)
)
;
}
return
(
ret
<
0
)
?
0
:
static_cast
<
size_t
>
(
ret
)
;
}
bool
IsDtxPacket
(
)
const
override
{
return
payload_
.
size
(
)
<
=
2
;
}
std
:
:
optional
<
DecodeResult
>
Decode
(
ArrayView
<
int16_t
>
decoded
)
const
override
{
AudioDecoder
:
:
SpeechType
speech_type
=
AudioDecoder
:
:
kSpeech
;
int
ret
;
if
(
is_primary_payload_
)
{
ret
=
decoder_
-
>
Decode
(
payload_
.
data
(
)
payload_
.
size
(
)
decoder_
-
>
SampleRateHz
(
)
decoded
.
size
(
)
*
sizeof
(
int16_t
)
decoded
.
data
(
)
&
speech_type
)
;
}
else
{
ret
=
decoder_
-
>
DecodeRedundant
(
payload_
.
data
(
)
payload_
.
size
(
)
decoder_
-
>
SampleRateHz
(
)
decoded
.
size
(
)
*
sizeof
(
int16_t
)
decoded
.
data
(
)
&
speech_type
)
;
}
if
(
ret
<
0
)
return
std
:
:
nullopt
;
return
DecodeResult
{
static_cast
<
size_t
>
(
ret
)
speech_type
}
;
}
private
:
AudioDecoder
*
const
decoder_
;
const
Buffer
payload_
;
const
bool
is_primary_payload_
;
}
;
}
#
endif
