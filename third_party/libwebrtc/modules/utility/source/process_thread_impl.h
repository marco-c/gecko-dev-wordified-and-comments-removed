#
ifndef
MODULES_UTILITY_SOURCE_PROCESS_THREAD_IMPL_H_
#
define
MODULES_UTILITY_SOURCE_PROCESS_THREAD_IMPL_H_
#
include
<
stdint
.
h
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
queue
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
queued_task
.
h
"
#
include
"
modules
/
include
/
module
.
h
"
#
include
"
modules
/
utility
/
include
/
process_thread
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
namespace
webrtc
{
class
ProcessThreadImpl
:
public
ProcessThread
{
public
:
explicit
ProcessThreadImpl
(
const
char
*
thread_name
)
;
~
ProcessThreadImpl
(
)
override
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
WakeUp
(
Module
*
module
)
override
;
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
override
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
override
;
void
RegisterModule
(
Module
*
module
const
rtc
:
:
Location
&
from
)
override
;
void
DeRegisterModule
(
Module
*
module
)
override
;
protected
:
bool
Process
(
)
;
private
:
struct
ModuleCallback
{
ModuleCallback
(
)
=
delete
;
ModuleCallback
(
ModuleCallback
&
&
cb
)
=
default
;
ModuleCallback
(
const
ModuleCallback
&
cb
)
=
default
;
ModuleCallback
(
Module
*
module
const
rtc
:
:
Location
&
location
)
:
module
(
module
)
location
(
location
)
{
}
bool
operator
=
=
(
const
ModuleCallback
&
cb
)
const
{
return
cb
.
module
=
=
module
;
}
Module
*
const
module
;
int64_t
next_callback
=
0
;
const
rtc
:
:
Location
location
;
private
:
ModuleCallback
&
operator
=
(
ModuleCallback
&
)
;
}
;
struct
DelayedTask
{
DelayedTask
(
int64_t
run_at_ms
uint64_t
sequence_id
std
:
:
unique_ptr
<
QueuedTask
>
task
)
:
run_at_ms
(
run_at_ms
)
sequence_id_
(
sequence_id
)
task
(
task
.
release
(
)
)
{
}
friend
bool
operator
<
(
const
DelayedTask
&
lhs
const
DelayedTask
&
rhs
)
{
if
(
lhs
.
run_at_ms
!
=
rhs
.
run_at_ms
)
{
return
lhs
.
run_at_ms
>
rhs
.
run_at_ms
;
}
return
lhs
.
sequence_id_
>
rhs
.
sequence_id_
;
}
int64_t
run_at_ms
;
uint64_t
sequence_id_
;
QueuedTask
*
task
;
}
;
typedef
std
:
:
list
<
ModuleCallback
>
ModuleList
;
void
Delete
(
)
override
;
void
StopNoLocks
(
)
;
void
WakeUpNoLocks
(
Module
*
module
)
;
void
WakeUpInternal
(
Module
*
module
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
Mutex
mutex_
;
SequenceChecker
thread_checker_
;
rtc
:
:
Event
wake_up_
;
rtc
:
:
PlatformThread
thread_
;
ModuleList
modules_
RTC_GUARDED_BY
(
mutex_
)
;
bool
holds_mutex_
RTC_GUARDED_BY
(
this
)
=
false
;
std
:
:
queue
<
QueuedTask
*
>
queue_
;
std
:
:
priority_queue
<
DelayedTask
>
delayed_tasks_
RTC_GUARDED_BY
(
mutex_
)
;
uint64_t
sequence_id_
RTC_GUARDED_BY
(
mutex_
)
=
0
;
bool
stop_
RTC_GUARDED_BY
(
mutex_
)
;
const
char
*
thread_name_
;
}
;
}
#
endif
