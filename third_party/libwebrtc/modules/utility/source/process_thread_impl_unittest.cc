#
include
"
modules
/
utility
/
source
/
process_thread_impl
.
h
"
#
include
<
memory
>
#
include
<
utility
>
#
include
"
api
/
task_queue
/
queued_task
.
h
"
#
include
"
api
/
task_queue
/
task_queue_test
.
h
"
#
include
"
modules
/
include
/
module
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
DoAll
;
using
:
:
testing
:
:
InSequence
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
SetArgPointee
;
static
const
int
kEventWaitTimeout
=
500
;
class
MockModule
:
public
Module
{
public
:
MOCK_METHOD
(
int64_t
TimeUntilNextProcess
(
)
(
override
)
)
;
MOCK_METHOD
(
void
Process
(
)
(
override
)
)
;
MOCK_METHOD
(
void
ProcessThreadAttached
(
ProcessThread
*
)
(
override
)
)
;
}
;
class
RaiseEventTask
:
public
QueuedTask
{
public
:
RaiseEventTask
(
rtc
:
:
Event
*
event
)
:
event_
(
event
)
{
}
bool
Run
(
)
override
{
event_
-
>
Set
(
)
;
return
true
;
}
private
:
rtc
:
:
Event
*
event_
;
}
;
ACTION_P
(
SetEvent
event
)
{
event
-
>
Set
(
)
;
}
ACTION_P
(
Increment
counter
)
{
+
+
(
*
counter
)
;
}
ACTION_P
(
SetTimestamp
ptr
)
{
*
ptr
=
rtc
:
:
TimeMillis
(
)
;
}
TEST
(
ProcessThreadImpl
StartStop
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
thread
.
Start
(
)
;
thread
.
Stop
(
)
;
}
TEST
(
ProcessThreadImpl
MultipleStartStop
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
for
(
int
i
=
0
;
i
<
5
;
+
+
i
)
{
thread
.
Start
(
)
;
thread
.
Stop
(
)
;
}
}
TEST
(
ProcessThreadImpl
ProcessCall
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
thread
.
Start
(
)
;
rtc
:
:
Event
event
;
MockModule
module
;
EXPECT_CALL
(
module
TimeUntilNextProcess
(
)
)
.
WillOnce
(
Return
(
0
)
)
.
WillRepeatedly
(
Return
(
1
)
)
;
EXPECT_CALL
(
module
Process
(
)
)
.
WillOnce
(
DoAll
(
SetEvent
(
&
event
)
Return
(
)
)
)
.
WillRepeatedly
(
Return
(
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
&
thread
)
)
.
Times
(
1
)
;
thread
.
RegisterModule
(
&
module
RTC_FROM_HERE
)
;
EXPECT_TRUE
(
event
.
Wait
(
kEventWaitTimeout
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
nullptr
)
)
.
Times
(
1
)
;
thread
.
Stop
(
)
;
}
TEST
(
ProcessThreadImpl
ProcessCall2
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
rtc
:
:
Event
event
;
MockModule
module
;
EXPECT_CALL
(
module
TimeUntilNextProcess
(
)
)
.
WillOnce
(
Return
(
0
)
)
.
WillRepeatedly
(
Return
(
1
)
)
;
EXPECT_CALL
(
module
Process
(
)
)
.
WillOnce
(
DoAll
(
SetEvent
(
&
event
)
Return
(
)
)
)
.
WillRepeatedly
(
Return
(
)
)
;
thread
.
RegisterModule
(
&
module
RTC_FROM_HERE
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
&
thread
)
)
.
Times
(
1
)
;
thread
.
Start
(
)
;
EXPECT_TRUE
(
event
.
Wait
(
kEventWaitTimeout
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
nullptr
)
)
.
Times
(
1
)
;
thread
.
Stop
(
)
;
}
TEST
(
ProcessThreadImpl
Deregister
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
rtc
:
:
Event
event
;
int
process_count
=
0
;
MockModule
module
;
EXPECT_CALL
(
module
TimeUntilNextProcess
(
)
)
.
WillOnce
(
Return
(
0
)
)
.
WillRepeatedly
(
Return
(
1
)
)
;
EXPECT_CALL
(
module
Process
(
)
)
.
WillOnce
(
DoAll
(
SetEvent
(
&
event
)
Increment
(
&
process_count
)
Return
(
)
)
)
.
WillRepeatedly
(
DoAll
(
Increment
(
&
process_count
)
Return
(
)
)
)
;
thread
.
RegisterModule
(
&
module
RTC_FROM_HERE
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
&
thread
)
)
.
Times
(
1
)
;
thread
.
Start
(
)
;
EXPECT_TRUE
(
event
.
Wait
(
kEventWaitTimeout
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
nullptr
)
)
.
Times
(
1
)
;
thread
.
DeRegisterModule
(
&
module
)
;
EXPECT_GE
(
process_count
1
)
;
int
count_after_deregister
=
process_count
;
EXPECT_FALSE
(
event
.
Wait
(
20
)
)
;
EXPECT_EQ
(
count_after_deregister
process_count
)
;
thread
.
Stop
(
)
;
}
void
ProcessCallAfterAFewMs
(
int64_t
milliseconds
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
thread
.
Start
(
)
;
rtc
:
:
Event
event
;
MockModule
module
;
int64_t
start_time
=
0
;
int64_t
called_time
=
0
;
EXPECT_CALL
(
module
TimeUntilNextProcess
(
)
)
.
WillOnce
(
DoAll
(
SetTimestamp
(
&
start_time
)
Return
(
milliseconds
)
)
)
.
WillRepeatedly
(
Return
(
milliseconds
)
)
;
EXPECT_CALL
(
module
Process
(
)
)
.
WillOnce
(
DoAll
(
SetTimestamp
(
&
called_time
)
SetEvent
(
&
event
)
Return
(
)
)
)
.
WillRepeatedly
(
Return
(
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
&
thread
)
)
.
Times
(
1
)
;
thread
.
RegisterModule
(
&
module
RTC_FROM_HERE
)
;
EXPECT_TRUE
(
event
.
Wait
(
milliseconds
+
50
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
nullptr
)
)
.
Times
(
1
)
;
thread
.
Stop
(
)
;
ASSERT_GT
(
start_time
0
)
;
ASSERT_GT
(
called_time
0
)
;
EXPECT_GE
(
called_time
start_time
)
;
uint32_t
diff
=
called_time
-
start_time
;
EXPECT_GE
(
diff
milliseconds
-
15
)
;
EXPECT_LT
(
diff
milliseconds
+
15
)
;
}
TEST
(
ProcessThreadImpl
DISABLED_ProcessCallAfter5ms
)
{
ProcessCallAfterAFewMs
(
5
)
;
}
TEST
(
ProcessThreadImpl
DISABLED_ProcessCallAfter50ms
)
{
ProcessCallAfterAFewMs
(
50
)
;
}
TEST
(
ProcessThreadImpl
DISABLED_ProcessCallAfter200ms
)
{
ProcessCallAfterAFewMs
(
200
)
;
}
TEST
(
ProcessThreadImpl
DISABLED_Process50Times
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
thread
.
Start
(
)
;
rtc
:
:
Event
event
;
MockModule
module
;
int
callback_count
=
0
;
EXPECT_CALL
(
module
TimeUntilNextProcess
(
)
)
.
WillRepeatedly
(
Return
(
20
)
)
;
EXPECT_CALL
(
module
Process
(
)
)
.
WillRepeatedly
(
DoAll
(
Increment
(
&
callback_count
)
Return
(
)
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
&
thread
)
)
.
Times
(
1
)
;
thread
.
RegisterModule
(
&
module
RTC_FROM_HERE
)
;
EXPECT_TRUE
(
event
.
Wait
(
1000
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
nullptr
)
)
.
Times
(
1
)
;
thread
.
Stop
(
)
;
printf
(
"
Callback
count
:
%
i
\
n
"
callback_count
)
;
EXPECT_GE
(
callback_count
25
)
;
EXPECT_LE
(
callback_count
50
)
;
}
TEST
(
ProcessThreadImpl
WakeUp
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
thread
.
Start
(
)
;
rtc
:
:
Event
started
;
rtc
:
:
Event
called
;
MockModule
module
;
int64_t
start_time
;
int64_t
called_time
;
EXPECT_CALL
(
module
TimeUntilNextProcess
(
)
)
.
WillOnce
(
DoAll
(
SetTimestamp
(
&
start_time
)
SetEvent
(
&
started
)
Return
(
1000
)
)
)
.
WillOnce
(
Return
(
1000
)
)
;
EXPECT_CALL
(
module
Process
(
)
)
.
WillOnce
(
DoAll
(
SetTimestamp
(
&
called_time
)
SetEvent
(
&
called
)
Return
(
)
)
)
.
WillRepeatedly
(
Return
(
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
&
thread
)
)
.
Times
(
1
)
;
thread
.
RegisterModule
(
&
module
RTC_FROM_HERE
)
;
EXPECT_TRUE
(
started
.
Wait
(
kEventWaitTimeout
)
)
;
thread
.
WakeUp
(
&
module
)
;
EXPECT_TRUE
(
called
.
Wait
(
kEventWaitTimeout
)
)
;
EXPECT_CALL
(
module
ProcessThreadAttached
(
nullptr
)
)
.
Times
(
1
)
;
thread
.
Stop
(
)
;
EXPECT_GE
(
called_time
start_time
)
;
uint32_t
diff
=
called_time
-
start_time
;
EXPECT_LE
(
diff
100u
)
;
}
TEST
(
ProcessThreadImpl
PostTask
)
{
ProcessThreadImpl
thread
(
"
ProcessThread
"
)
;
rtc
:
:
Event
task_ran
;
std
:
:
unique_ptr
<
RaiseEventTask
>
task
(
new
RaiseEventTask
(
&
task_ran
)
)
;
thread
.
Start
(
)
;
thread
.
PostTask
(
std
:
:
move
(
task
)
)
;
EXPECT_TRUE
(
task_ran
.
Wait
(
kEventWaitTimeout
)
)
;
thread
.
Stop
(
)
;
}
class
ProcessThreadFactory
:
public
TaskQueueFactory
{
public
:
~
ProcessThreadFactory
(
)
override
=
default
;
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
CreateTaskQueue
(
absl
:
:
string_view
name
Priority
priority
)
const
override
{
ProcessThreadImpl
*
process_thread
=
new
ProcessThreadImpl
(
"
thread
"
)
;
process_thread
-
>
Start
(
)
;
return
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
(
process_thread
)
;
}
}
;
INSTANTIATE_TEST_SUITE_P
(
ProcessThread
TaskQueueTest
testing
:
:
Values
(
std
:
:
make_unique
<
ProcessThreadFactory
>
)
)
;
}
