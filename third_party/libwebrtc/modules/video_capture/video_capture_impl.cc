#
include
"
modules
/
video_capture
/
video_capture_impl
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
modules
/
video_capture
/
video_capture_config
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
#
include
"
third_party
/
libyuv
/
include
/
libyuv
.
h
"
namespace
webrtc
{
namespace
videocapturemodule
{
const
char
*
VideoCaptureImpl
:
:
CurrentDeviceName
(
)
const
{
return
_deviceUniqueId
;
}
int32_t
VideoCaptureImpl
:
:
RotationFromDegrees
(
int
degrees
VideoRotation
*
rotation
)
{
switch
(
degrees
)
{
case
0
:
*
rotation
=
kVideoRotation_0
;
return
0
;
case
90
:
*
rotation
=
kVideoRotation_90
;
return
0
;
case
180
:
*
rotation
=
kVideoRotation_180
;
return
0
;
case
270
:
*
rotation
=
kVideoRotation_270
;
return
0
;
default
:
return
-
1
;
;
}
}
int32_t
VideoCaptureImpl
:
:
RotationInDegrees
(
VideoRotation
rotation
int
*
degrees
)
{
switch
(
rotation
)
{
case
kVideoRotation_0
:
*
degrees
=
0
;
return
0
;
case
kVideoRotation_90
:
*
degrees
=
90
;
return
0
;
case
kVideoRotation_180
:
*
degrees
=
180
;
return
0
;
case
kVideoRotation_270
:
*
degrees
=
270
;
return
0
;
}
return
-
1
;
}
VideoCaptureImpl
:
:
VideoCaptureImpl
(
)
:
_deviceUniqueId
(
NULL
)
_requestedCapability
(
)
_lastProcessTimeNanos
(
rtc
:
:
TimeNanos
(
)
)
_lastFrameRateCallbackTimeNanos
(
rtc
:
:
TimeNanos
(
)
)
_rawDataCallBack
(
NULL
)
_lastProcessFrameTimeNanos
(
rtc
:
:
TimeNanos
(
)
)
_rotateFrame
(
kVideoRotation_0
)
apply_rotation_
(
false
)
{
_requestedCapability
.
width
=
kDefaultWidth
;
_requestedCapability
.
height
=
kDefaultHeight
;
_requestedCapability
.
maxFPS
=
30
;
_requestedCapability
.
videoType
=
VideoType
:
:
kI420
;
memset
(
_incomingFrameTimesNanos
0
sizeof
(
_incomingFrameTimesNanos
)
)
;
}
VideoCaptureImpl
:
:
~
VideoCaptureImpl
(
)
{
if
(
_deviceUniqueId
)
delete
[
]
_deviceUniqueId
;
}
void
VideoCaptureImpl
:
:
RegisterCaptureDataCallback
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
dataCallBack
)
{
MutexLock
lock
(
&
api_lock_
)
;
RTC_DCHECK
(
!
_rawDataCallBack
)
;
_dataCallBacks
.
insert
(
dataCallBack
)
;
}
void
VideoCaptureImpl
:
:
RegisterCaptureDataCallback
(
RawVideoSinkInterface
*
dataCallBack
)
{
MutexLock
lock
(
&
api_lock_
)
;
RTC_DCHECK
(
_dataCallBacks
.
empty
(
)
)
;
_rawDataCallBack
=
dataCallBack
;
}
void
VideoCaptureImpl
:
:
DeRegisterCaptureDataCallback
(
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
dataCallBack
)
{
MutexLock
lock
(
&
api_lock_
)
;
auto
it
=
_dataCallBacks
.
find
(
dataCallBack
)
;
if
(
it
!
=
_dataCallBacks
.
end
(
)
)
{
_dataCallBacks
.
erase
(
it
)
;
}
_rawDataCallBack
=
NULL
;
}
int32_t
VideoCaptureImpl
:
:
StopCaptureIfAllClientsClose
(
)
{
if
(
_dataCallBacks
.
empty
(
)
)
{
return
StopCapture
(
)
;
}
else
{
return
0
;
}
}
int32_t
VideoCaptureImpl
:
:
DeliverCapturedFrame
(
VideoFrame
&
captureFrame
)
{
UpdateFrameCount
(
)
;
for
(
auto
dataCallBack
:
_dataCallBacks
)
{
dataCallBack
-
>
OnFrame
(
captureFrame
)
;
}
return
0
;
}
void
VideoCaptureImpl
:
:
DeliverRawFrame
(
uint8_t
*
videoFrame
size_t
videoFrameLength
const
VideoCaptureCapability
&
frameInfo
int64_t
captureTime
)
{
UpdateFrameCount
(
)
;
_rawDataCallBack
-
>
OnRawFrame
(
videoFrame
videoFrameLength
frameInfo
_rotateFrame
captureTime
)
;
}
int32_t
VideoCaptureImpl
:
:
IncomingFrame
(
uint8_t
*
videoFrame
size_t
videoFrameLength
const
VideoCaptureCapability
&
frameInfo
int64_t
captureTime
)
{
MutexLock
lock
(
&
api_lock_
)
;
const
int32_t
width
=
frameInfo
.
width
;
const
int32_t
height
=
frameInfo
.
height
;
TRACE_EVENT1
(
"
webrtc
"
"
VC
:
:
IncomingFrame
"
"
capture_time
"
captureTime
)
;
if
(
_rawDataCallBack
)
{
DeliverRawFrame
(
videoFrame
videoFrameLength
frameInfo
captureTime
)
;
return
0
;
}
if
(
frameInfo
.
videoType
!
=
VideoType
:
:
kMJPEG
)
{
if
(
auto
size
=
CalcBufferSize
(
frameInfo
.
videoType
width
abs
(
height
)
)
;
videoFrameLength
<
size
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Wrong
incoming
frame
length
.
Expected
"
<
<
size
<
<
"
Got
"
<
<
videoFrameLength
<
<
"
.
"
;
return
-
1
;
}
}
int
target_width
=
width
;
int
target_height
=
abs
(
height
)
;
if
(
apply_rotation_
)
{
if
(
_rotateFrame
=
=
kVideoRotation_90
|
|
_rotateFrame
=
=
kVideoRotation_270
)
{
target_width
=
abs
(
height
)
;
target_height
=
width
;
}
}
int
stride_y
=
target_width
;
int
stride_uv
=
(
target_width
+
1
)
/
2
;
rtc
:
:
scoped_refptr
<
I420Buffer
>
buffer
=
I420Buffer
:
:
Create
(
target_width
target_height
stride_y
stride_uv
stride_uv
)
;
libyuv
:
:
RotationMode
rotation_mode
=
libyuv
:
:
kRotate0
;
if
(
apply_rotation_
)
{
switch
(
_rotateFrame
)
{
case
kVideoRotation_0
:
rotation_mode
=
libyuv
:
:
kRotate0
;
break
;
case
kVideoRotation_90
:
rotation_mode
=
libyuv
:
:
kRotate90
;
break
;
case
kVideoRotation_180
:
rotation_mode
=
libyuv
:
:
kRotate180
;
break
;
case
kVideoRotation_270
:
rotation_mode
=
libyuv
:
:
kRotate270
;
break
;
}
}
int
dst_width
=
buffer
-
>
width
(
)
;
int
dst_height
=
buffer
-
>
height
(
)
;
if
(
rotation_mode
=
=
libyuv
:
:
kRotate90
|
|
rotation_mode
=
=
libyuv
:
:
kRotate270
)
{
std
:
:
swap
(
dst_width
dst_height
)
;
}
const
int
conversionResult
=
libyuv
:
:
ConvertToI420
(
videoFrame
videoFrameLength
buffer
.
get
(
)
-
>
MutableDataY
(
)
buffer
.
get
(
)
-
>
StrideY
(
)
buffer
.
get
(
)
-
>
MutableDataU
(
)
buffer
.
get
(
)
-
>
StrideU
(
)
buffer
.
get
(
)
-
>
MutableDataV
(
)
buffer
.
get
(
)
-
>
StrideV
(
)
0
0
width
height
dst_width
dst_height
rotation_mode
ConvertVideoType
(
frameInfo
.
videoType
)
)
;
if
(
conversionResult
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
convert
capture
frame
from
type
"
<
<
static_cast
<
int
>
(
frameInfo
.
videoType
)
<
<
"
to
I420
.
"
;
return
-
1
;
}
VideoFrame
captureFrame
=
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
buffer
)
.
set_timestamp_rtp
(
0
)
.
set_timestamp_ms
(
rtc
:
:
TimeMillis
(
)
)
.
set_rotation
(
!
apply_rotation_
?
_rotateFrame
:
kVideoRotation_0
)
.
build
(
)
;
captureFrame
.
set_ntp_time_ms
(
captureTime
)
;
captureFrame
.
set_rotation
(
_rotateFrame
)
;
DeliverCapturedFrame
(
captureFrame
)
;
return
0
;
}
int32_t
VideoCaptureImpl
:
:
StartCapture
(
const
VideoCaptureCapability
&
capability
)
{
_requestedCapability
=
capability
;
return
-
1
;
}
int32_t
VideoCaptureImpl
:
:
StopCapture
(
)
{
return
-
1
;
}
bool
VideoCaptureImpl
:
:
CaptureStarted
(
)
{
return
false
;
}
int32_t
VideoCaptureImpl
:
:
CaptureSettings
(
VideoCaptureCapability
&
)
{
return
-
1
;
}
int32_t
VideoCaptureImpl
:
:
SetCaptureRotation
(
VideoRotation
rotation
)
{
MutexLock
lock
(
&
api_lock_
)
;
_rotateFrame
=
rotation
;
return
0
;
}
bool
VideoCaptureImpl
:
:
SetApplyRotation
(
bool
enable
)
{
MutexLock
lock
(
&
api_lock_
)
;
apply_rotation_
=
enable
;
return
true
;
}
bool
VideoCaptureImpl
:
:
GetApplyRotation
(
)
{
MutexLock
lock
(
&
api_lock_
)
;
return
apply_rotation_
;
}
void
VideoCaptureImpl
:
:
UpdateFrameCount
(
)
{
if
(
_incomingFrameTimesNanos
[
0
]
/
rtc
:
:
kNumNanosecsPerMicrosec
=
=
0
)
{
}
else
{
for
(
int
i
=
(
kFrameRateCountHistorySize
-
2
)
;
i
>
=
0
;
-
-
i
)
{
_incomingFrameTimesNanos
[
i
+
1
]
=
_incomingFrameTimesNanos
[
i
]
;
}
}
_incomingFrameTimesNanos
[
0
]
=
rtc
:
:
TimeNanos
(
)
;
}
uint32_t
VideoCaptureImpl
:
:
CalculateFrameRate
(
int64_t
now_ns
)
{
int32_t
num
=
0
;
int32_t
nrOfFrames
=
0
;
for
(
num
=
1
;
num
<
(
kFrameRateCountHistorySize
-
1
)
;
+
+
num
)
{
if
(
_incomingFrameTimesNanos
[
num
]
<
=
0
|
|
(
now_ns
-
_incomingFrameTimesNanos
[
num
]
)
/
rtc
:
:
kNumNanosecsPerMillisec
>
kFrameRateHistoryWindowMs
)
{
break
;
}
else
{
nrOfFrames
+
+
;
}
}
if
(
num
>
1
)
{
int64_t
diff
=
(
now_ns
-
_incomingFrameTimesNanos
[
num
-
1
]
)
/
rtc
:
:
kNumNanosecsPerMillisec
;
if
(
diff
>
0
)
{
return
uint32_t
(
(
nrOfFrames
*
1000
.
0f
/
diff
)
+
0
.
5f
)
;
}
}
return
nrOfFrames
;
}
}
}
