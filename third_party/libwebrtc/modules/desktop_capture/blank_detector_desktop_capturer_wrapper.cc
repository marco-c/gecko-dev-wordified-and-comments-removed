#
include
"
modules
/
desktop_capture
/
blank_detector_desktop_capturer_wrapper
.
h
"
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
modules
/
desktop_capture
/
desktop_capture_types
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_frame
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_geometry
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_region
.
h
"
#
include
"
modules
/
desktop_capture
/
rgba_color
.
h
"
#
include
"
modules
/
desktop_capture
/
shared_memory
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
namespace
webrtc
{
BlankDetectorDesktopCapturerWrapper
:
:
BlankDetectorDesktopCapturerWrapper
(
std
:
:
unique_ptr
<
DesktopCapturer
>
capturer
RgbaColor
blank_pixel
bool
check_per_capture
)
:
capturer_
(
std
:
:
move
(
capturer
)
)
blank_pixel_
(
blank_pixel
)
check_per_capture_
(
check_per_capture
)
{
RTC_DCHECK
(
capturer_
)
;
}
BlankDetectorDesktopCapturerWrapper
:
:
~
BlankDetectorDesktopCapturerWrapper
(
)
=
default
;
void
BlankDetectorDesktopCapturerWrapper
:
:
Start
(
DesktopCapturer
:
:
Callback
*
callback
)
{
callback_
=
callback
;
capturer_
-
>
Start
(
this
)
;
}
void
BlankDetectorDesktopCapturerWrapper
:
:
SetSharedMemoryFactory
(
std
:
:
unique_ptr
<
SharedMemoryFactory
>
shared_memory_factory
)
{
capturer_
-
>
SetSharedMemoryFactory
(
std
:
:
move
(
shared_memory_factory
)
)
;
}
void
BlankDetectorDesktopCapturerWrapper
:
:
CaptureFrame
(
)
{
RTC_DCHECK
(
callback_
)
;
capturer_
-
>
CaptureFrame
(
)
;
}
void
BlankDetectorDesktopCapturerWrapper
:
:
SetExcludedWindow
(
WindowId
window
)
{
capturer_
-
>
SetExcludedWindow
(
window
)
;
}
bool
BlankDetectorDesktopCapturerWrapper
:
:
GetSourceList
(
SourceList
*
sources
)
{
return
capturer_
-
>
GetSourceList
(
sources
)
;
}
bool
BlankDetectorDesktopCapturerWrapper
:
:
SelectSource
(
SourceId
id
)
{
if
(
check_per_capture_
)
{
is_first_frame_
=
true
;
non_blank_frame_received_
=
false
;
}
return
capturer_
-
>
SelectSource
(
id
)
;
}
bool
BlankDetectorDesktopCapturerWrapper
:
:
FocusOnSelectedSource
(
)
{
return
capturer_
-
>
FocusOnSelectedSource
(
)
;
}
bool
BlankDetectorDesktopCapturerWrapper
:
:
IsOccluded
(
const
DesktopVector
&
pos
)
{
return
capturer_
-
>
IsOccluded
(
pos
)
;
}
void
BlankDetectorDesktopCapturerWrapper
:
:
OnCaptureResult
(
Result
result
std
:
:
unique_ptr
<
DesktopFrame
>
frame
)
{
RTC_DCHECK
(
callback_
)
;
if
(
result
!
=
Result
:
:
SUCCESS
|
|
non_blank_frame_received_
)
{
callback_
-
>
OnCaptureResult
(
result
std
:
:
move
(
frame
)
)
;
return
;
}
if
(
!
frame
)
{
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
std
:
:
unique_ptr
<
DesktopFrame
>
(
)
)
;
return
;
}
if
(
!
frame
-
>
updated_region
(
)
.
is_empty
(
)
|
|
is_first_frame_
)
{
last_frame_is_blank_
=
IsBlankFrame
(
*
frame
)
;
is_first_frame_
=
false
;
}
RTC_HISTOGRAM_BOOLEAN
(
"
WebRTC
.
DesktopCapture
.
BlankFrameDetected
"
last_frame_is_blank_
)
;
if
(
!
last_frame_is_blank_
)
{
non_blank_frame_received_
=
true
;
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
frame
)
)
;
return
;
}
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
std
:
:
unique_ptr
<
DesktopFrame
>
(
)
)
;
}
bool
BlankDetectorDesktopCapturerWrapper
:
:
IsBlankFrame
(
const
DesktopFrame
&
frame
)
const
{
for
(
int
i
=
0
;
i
<
frame
.
size
(
)
.
width
(
)
*
frame
.
size
(
)
.
height
(
)
;
i
+
=
105
)
{
const
int
x
=
i
%
frame
.
size
(
)
.
width
(
)
;
const
int
y
=
i
/
frame
.
size
(
)
.
width
(
)
;
if
(
!
IsBlankPixel
(
frame
x
y
)
)
{
return
false
;
}
}
return
IsBlankPixel
(
frame
frame
.
size
(
)
.
width
(
)
/
2
frame
.
size
(
)
.
height
(
)
/
2
)
;
}
bool
BlankDetectorDesktopCapturerWrapper
:
:
IsBlankPixel
(
const
DesktopFrame
&
frame
int
x
int
y
)
const
{
uint8_t
*
pixel_data
=
frame
.
GetFrameDataAtPos
(
DesktopVector
(
x
y
)
)
;
return
RgbaColor
(
pixel_data
)
=
=
blank_pixel_
;
}
}
