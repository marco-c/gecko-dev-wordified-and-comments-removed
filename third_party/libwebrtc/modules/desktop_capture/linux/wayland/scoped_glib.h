#
ifndef
MODULES_DESKTOP_CAPTURE_LINUX_WAYLAND_SCOPED_GLIB_H_
#
define
MODULES_DESKTOP_CAPTURE_LINUX_WAYLAND_SCOPED_GLIB_H_
#
include
<
gio
/
gio
.
h
>
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
template
<
class
T
>
class
Scoped
{
public
:
Scoped
(
)
{
}
explicit
Scoped
(
T
*
val
)
{
ptr_
=
val
;
}
~
Scoped
(
)
{
RTC_DCHECK_NOTREACHED
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
ptr_
;
}
explicit
operator
bool
(
)
const
{
return
ptr_
!
=
nullptr
;
}
bool
operator
!
(
)
const
{
return
ptr_
=
=
nullptr
;
}
T
*
get
(
)
const
{
return
ptr_
;
}
T
*
*
receive
(
)
{
RTC_CHECK
(
!
ptr_
)
;
return
&
ptr_
;
}
Scoped
&
operator
=
(
T
*
val
)
{
RTC_DCHECK
(
val
)
;
ptr_
=
val
;
return
*
this
;
}
protected
:
T
*
ptr_
=
nullptr
;
}
;
template
<
>
Scoped
<
GError
>
:
:
~
Scoped
(
)
{
if
(
ptr_
)
{
g_error_free
(
ptr_
)
;
}
}
template
<
>
Scoped
<
char
>
:
:
~
Scoped
(
)
{
if
(
ptr_
)
{
g_free
(
ptr_
)
;
}
}
template
<
>
Scoped
<
GVariant
>
:
:
~
Scoped
(
)
{
if
(
ptr_
)
{
g_variant_unref
(
ptr_
)
;
}
}
template
<
>
Scoped
<
GVariantIter
>
:
:
~
Scoped
(
)
{
if
(
ptr_
)
{
g_variant_iter_free
(
ptr_
)
;
}
}
template
<
>
Scoped
<
GDBusMessage
>
:
:
~
Scoped
(
)
{
if
(
ptr_
)
{
g_object_unref
(
ptr_
)
;
}
}
template
<
>
Scoped
<
GUnixFDList
>
:
:
~
Scoped
(
)
{
if
(
ptr_
)
{
g_object_unref
(
ptr_
)
;
}
}
}
#
endif
