#
include
"
modules
/
desktop_capture
/
linux
/
x11
/
shared_x_display
.
h
"
#
include
<
X11
/
Xlib
.
h
>
#
if
!
defined
(
WEBRTC_MOZILLA_BUILD
)
#
include
<
X11
/
extensions
/
XTest
.
h
>
#
endif
#
include
<
algorithm
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
SharedXDisplay
:
:
SharedXDisplay
(
Display
*
display
)
:
display_
(
display
)
{
RTC_DCHECK
(
display_
)
;
}
SharedXDisplay
:
:
~
SharedXDisplay
(
)
{
RTC_DCHECK
(
event_handlers_
.
empty
(
)
)
;
XCloseDisplay
(
display_
)
;
}
scoped_refptr
<
SharedXDisplay
>
SharedXDisplay
:
:
Create
(
absl
:
:
string_view
display_name
)
{
Display
*
display
=
XOpenDisplay
(
display_name
.
empty
(
)
?
NULL
:
std
:
:
string
(
display_name
)
.
c_str
(
)
)
;
if
(
!
display
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unable
to
open
display
"
;
return
nullptr
;
}
return
scoped_refptr
<
SharedXDisplay
>
(
new
SharedXDisplay
(
display
)
)
;
}
scoped_refptr
<
SharedXDisplay
>
SharedXDisplay
:
:
CreateDefault
(
)
{
return
Create
(
std
:
:
string
(
)
)
;
}
void
SharedXDisplay
:
:
AddEventHandler
(
int
type
XEventHandler
*
handler
)
{
MutexLock
lock
(
&
mutex_
)
;
event_handlers_
[
type
]
.
push_back
(
handler
)
;
}
void
SharedXDisplay
:
:
RemoveEventHandler
(
int
type
XEventHandler
*
handler
)
{
MutexLock
lock
(
&
mutex_
)
;
EventHandlersMap
:
:
iterator
handlers
=
event_handlers_
.
find
(
type
)
;
if
(
handlers
=
=
event_handlers_
.
end
(
)
)
return
;
std
:
:
vector
<
XEventHandler
*
>
:
:
iterator
new_end
=
std
:
:
remove
(
handlers
-
>
second
.
begin
(
)
handlers
-
>
second
.
end
(
)
handler
)
;
handlers
-
>
second
.
erase
(
new_end
handlers
-
>
second
.
end
(
)
)
;
if
(
handlers
-
>
second
.
empty
(
)
)
event_handlers_
.
erase
(
handlers
)
;
}
void
SharedXDisplay
:
:
ProcessPendingXEvents
(
)
{
scoped_refptr
<
SharedXDisplay
>
self
(
this
)
;
MutexLock
lock
(
&
mutex_
)
;
int
events_to_process
=
XPending
(
display
(
)
)
;
XEvent
e
;
for
(
int
i
=
0
;
i
<
events_to_process
;
i
+
+
)
{
XNextEvent
(
display
(
)
&
e
)
;
EventHandlersMap
:
:
iterator
handlers
=
event_handlers_
.
find
(
e
.
type
)
;
if
(
handlers
=
=
event_handlers_
.
end
(
)
)
continue
;
for
(
std
:
:
vector
<
XEventHandler
*
>
:
:
iterator
it
=
handlers
-
>
second
.
begin
(
)
;
it
!
=
handlers
-
>
second
.
end
(
)
;
+
+
it
)
{
if
(
(
*
it
)
-
>
HandleXEvent
(
e
)
)
break
;
}
}
}
void
SharedXDisplay
:
:
IgnoreXServerGrabs
(
)
{
#
if
!
defined
(
WEBRTC_MOZILLA_BUILD
)
int
test_event_base
=
0
;
int
test_error_base
=
0
;
int
major
=
0
;
int
minor
=
0
;
if
(
XTestQueryExtension
(
display
(
)
&
test_event_base
&
test_error_base
&
major
&
minor
)
)
{
XTestGrabControl
(
display
(
)
true
)
;
}
#
endif
}
}
