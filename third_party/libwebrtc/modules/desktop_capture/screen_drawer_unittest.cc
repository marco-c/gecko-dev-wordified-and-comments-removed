#
include
"
modules
/
desktop_capture
/
screen_drawer
.
h
"
#
include
<
stdint
.
h
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
"
api
/
function_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
system_wrappers
/
include
/
sleep
.
h
"
#
include
"
test
/
gtest
.
h
"
#
if
defined
(
WEBRTC_POSIX
)
#
include
"
modules
/
desktop_capture
/
screen_drawer_lock_posix
.
h
"
#
endif
namespace
webrtc
{
namespace
{
void
TestScreenDrawerLock
(
rtc
:
:
FunctionView
<
std
:
:
unique_ptr
<
ScreenDrawerLock
>
(
)
>
ctor
)
{
constexpr
int
kLockDurationMs
=
100
;
std
:
:
atomic
<
bool
>
created
(
false
)
;
std
:
:
atomic
<
bool
>
ready
(
false
)
;
class
Task
{
public
:
Task
(
std
:
:
atomic
<
bool
>
*
created
const
std
:
:
atomic
<
bool
>
&
ready
rtc
:
:
FunctionView
<
std
:
:
unique_ptr
<
ScreenDrawerLock
>
(
)
>
ctor
)
:
created_
(
created
)
ready_
(
ready
)
ctor_
(
ctor
)
{
}
~
Task
(
)
=
default
;
void
RunTask
(
)
{
std
:
:
unique_ptr
<
ScreenDrawerLock
>
lock
=
ctor_
(
)
;
ASSERT_TRUE
(
!
!
lock
)
;
created_
-
>
store
(
true
)
;
while
(
!
ready_
.
load
(
)
)
{
SleepMs
(
1
)
;
}
const
int64_t
current_ms
=
rtc
:
:
TimeMillis
(
)
;
while
(
rtc
:
:
TimeMillis
(
)
-
current_ms
<
kLockDurationMs
)
{
SleepMs
(
kLockDurationMs
-
(
rtc
:
:
TimeMillis
(
)
-
current_ms
)
)
;
}
}
private
:
std
:
:
atomic
<
bool
>
*
const
created_
;
const
std
:
:
atomic
<
bool
>
&
ready_
;
const
rtc
:
:
FunctionView
<
std
:
:
unique_ptr
<
ScreenDrawerLock
>
(
)
>
ctor_
;
}
task
(
&
created
ready
ctor
)
;
auto
lock_thread
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
&
task
]
{
task
.
RunTask
(
)
;
}
"
lock_thread
"
)
;
while
(
!
created
.
load
(
)
)
{
SleepMs
(
1
)
;
}
const
int64_t
start_ms
=
rtc
:
:
TimeMillis
(
)
;
ready
.
store
(
true
)
;
ASSERT_GT
(
kLockDurationMs
rtc
:
:
TimeMillis
(
)
-
start_ms
)
;
ctor
(
)
;
ASSERT_LE
(
kLockDurationMs
rtc
:
:
TimeMillis
(
)
-
start_ms
)
;
}
}
TEST
(
ScreenDrawerTest
DISABLED_DrawRectangles
)
{
std
:
:
unique_ptr
<
ScreenDrawer
>
drawer
=
ScreenDrawer
:
:
Create
(
)
;
if
(
!
drawer
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
No
ScreenDrawer
implementation
for
current
platform
.
"
;
return
;
}
if
(
drawer
-
>
DrawableRegion
(
)
.
is_empty
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
ScreenDrawer
of
current
platform
does
not
provide
a
"
"
non
-
empty
DrawableRegion
(
)
.
"
;
return
;
}
DesktopRect
rect
=
drawer
-
>
DrawableRegion
(
)
;
Random
random
(
rtc
:
:
TimeMicros
(
)
)
;
for
(
int
i
=
0
;
i
<
100
;
i
+
+
)
{
int
left
=
random
.
Rand
(
rect
.
left
(
)
rect
.
right
(
)
-
2
)
;
int
top
=
random
.
Rand
(
rect
.
top
(
)
rect
.
bottom
(
)
-
2
)
;
drawer
-
>
DrawRectangle
(
DesktopRect
:
:
MakeLTRB
(
left
top
random
.
Rand
(
left
+
1
rect
.
right
(
)
)
random
.
Rand
(
top
+
1
rect
.
bottom
(
)
)
)
RgbaColor
(
random
.
Rand
<
uint8_t
>
(
)
random
.
Rand
<
uint8_t
>
(
)
random
.
Rand
<
uint8_t
>
(
)
random
.
Rand
<
uint8_t
>
(
)
)
)
;
if
(
i
=
=
50
)
{
SleepMs
(
10000
)
;
}
}
SleepMs
(
10000
)
;
}
#
if
defined
(
THREAD_SANITIZER
)
#
define
MAYBE_TwoScreenDrawerLocks
DISABLED_TwoScreenDrawerLocks
#
else
#
define
MAYBE_TwoScreenDrawerLocks
TwoScreenDrawerLocks
#
endif
TEST
(
ScreenDrawerTest
MAYBE_TwoScreenDrawerLocks
)
{
#
if
defined
(
WEBRTC_POSIX
)
const
char
*
semaphore_name
=
"
GSDL8784541a812011e788ff67427b
"
;
ScreenDrawerLockPosix
:
:
Unlink
(
semaphore_name
)
;
TestScreenDrawerLock
(
[
semaphore_name
]
(
)
{
return
std
:
:
make_unique
<
ScreenDrawerLockPosix
>
(
semaphore_name
)
;
}
)
;
#
elif
defined
(
WEBRTC_WIN
)
TestScreenDrawerLock
(
[
]
(
)
{
return
ScreenDrawerLock
:
:
Create
(
)
;
}
)
;
#
endif
}
}
