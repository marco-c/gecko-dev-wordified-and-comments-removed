#
include
<
ApplicationServices
/
ApplicationServices
.
h
>
#
include
<
chrono
>
#
include
<
memory
>
#
include
<
thread
>
#
include
"
modules
/
desktop_capture
/
desktop_capture_options
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_frame
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_geometry
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_region
.
h
"
#
include
"
modules
/
desktop_capture
/
mac
/
desktop_configuration
.
h
"
#
include
"
modules
/
desktop_capture
/
mock_desktop_capturer_callback
.
h
"
#
include
"
test
/
gtest
.
h
"
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
AnyNumber
;
using
:
:
testing
:
:
AnyOf
;
using
:
:
testing
:
:
InSequence
;
namespace
webrtc
{
class
ScreenCapturerMacTest
:
public
:
:
testing
:
:
Test
{
public
:
void
CaptureDoneCallback1
(
DesktopCapturer
:
:
Result
result
std
:
:
unique_ptr
<
DesktopFrame
>
*
frame
)
;
void
CaptureDoneCallback2
(
DesktopCapturer
:
:
Result
result
std
:
:
unique_ptr
<
DesktopFrame
>
*
frame
)
;
protected
:
void
SetUp
(
)
override
{
capturer_
=
DesktopCapturer
:
:
CreateScreenCapturer
(
DesktopCaptureOptions
:
:
CreateDefault
(
)
)
;
}
std
:
:
unique_ptr
<
DesktopCapturer
>
capturer_
;
MockDesktopCapturerCallback
callback_
;
}
;
class
ScreenCapturerSckTest
:
public
ScreenCapturerMacTest
{
protected
:
void
SetUp
(
)
override
{
auto
options
=
DesktopCaptureOptions
:
:
CreateDefault
(
)
;
options
.
set_allow_sck_capturer
(
true
)
;
capturer_
=
DesktopCapturer
:
:
CreateScreenCapturer
(
options
)
;
}
std
:
:
unique_ptr
<
DesktopCapturer
>
capturer_
;
MockDesktopCapturerCallback
callback_
;
}
;
void
ScreenCapturerMacTest
:
:
CaptureDoneCallback1
(
DesktopCapturer
:
:
Result
result
std
:
:
unique_ptr
<
DesktopFrame
>
*
frame
)
{
EXPECT_EQ
(
result
DesktopCapturer
:
:
Result
:
:
SUCCESS
)
;
MacDesktopConfiguration
config
=
MacDesktopConfiguration
:
:
GetCurrent
(
MacDesktopConfiguration
:
:
BottomLeftOrigin
)
;
DesktopRegion
:
:
Iterator
it
(
(
*
frame
)
-
>
updated_region
(
)
)
;
EXPECT_TRUE
(
!
it
.
IsAtEnd
(
)
&
&
it
.
rect
(
)
.
equals
(
config
.
pixel_bounds
)
)
;
}
void
ScreenCapturerMacTest
:
:
CaptureDoneCallback2
(
DesktopCapturer
:
:
Result
result
std
:
:
unique_ptr
<
DesktopFrame
>
*
frame
)
{
EXPECT_EQ
(
result
DesktopCapturer
:
:
Result
:
:
SUCCESS
)
;
MacDesktopConfiguration
config
=
MacDesktopConfiguration
:
:
GetCurrent
(
MacDesktopConfiguration
:
:
BottomLeftOrigin
)
;
int
width
=
config
.
pixel_bounds
.
width
(
)
;
int
height
=
config
.
pixel_bounds
.
height
(
)
;
EXPECT_EQ
(
width
(
*
frame
)
-
>
size
(
)
.
width
(
)
)
;
EXPECT_EQ
(
height
(
*
frame
)
-
>
size
(
)
.
height
(
)
)
;
EXPECT_TRUE
(
(
*
frame
)
-
>
data
(
)
!
=
NULL
)
;
EXPECT_LE
(
static_cast
<
int
>
(
sizeof
(
uint32_t
)
*
width
)
abs
(
(
*
frame
)
-
>
stride
(
)
)
)
;
}
TEST_F
(
ScreenCapturerMacTest
Capture
)
{
EXPECT_CALL
(
callback_
OnCaptureResultPtr
(
DesktopCapturer
:
:
Result
:
:
SUCCESS
_
)
)
.
Times
(
2
)
.
WillOnce
(
Invoke
(
this
&
ScreenCapturerMacTest
:
:
CaptureDoneCallback1
)
)
.
WillOnce
(
Invoke
(
this
&
ScreenCapturerMacTest
:
:
CaptureDoneCallback2
)
)
;
SCOPED_TRACE
(
"
"
)
;
capturer_
-
>
Start
(
&
callback_
)
;
capturer_
-
>
CaptureFrame
(
)
;
capturer_
-
>
CaptureFrame
(
)
;
}
TEST_F
(
ScreenCapturerSckTest
Capture
)
{
if
(
!
CGPreflightScreenCaptureAccess
(
)
)
{
GTEST_SKIP
(
)
<
<
"
ScreenCapturerSckTest
needs
TCC
ScreenCapture
authorization
"
;
}
std
:
:
atomic
<
bool
>
done
{
false
}
;
std
:
:
atomic
<
DesktopCapturer
:
:
Result
>
result
{
DesktopCapturer
:
:
Result
:
:
ERROR_TEMPORARY
}
;
InSequence
s
;
EXPECT_CALL
(
callback_
OnCaptureResultPtr
(
DesktopCapturer
:
:
Result
:
:
ERROR_TEMPORARY
_
)
)
.
Times
(
AnyNumber
(
)
)
;
EXPECT_CALL
(
callback_
OnCaptureResultPtr
(
AnyOf
(
DesktopCapturer
:
:
Result
:
:
ERROR_PERMANENT
DesktopCapturer
:
:
Result
:
:
SUCCESS
)
_
)
)
.
WillOnce
(
[
this
&
result
]
(
DesktopCapturer
:
:
Result
res
std
:
:
unique_ptr
<
DesktopFrame
>
*
frame
)
{
result
=
res
;
if
(
res
=
=
DesktopCapturer
:
:
Result
:
:
SUCCESS
)
{
CaptureDoneCallback1
(
res
frame
)
;
}
}
)
;
SCOPED_TRACE
(
"
"
)
;
capturer_
-
>
Start
(
&
callback_
)
;
while
(
result
=
=
DesktopCapturer
:
:
Result
:
:
ERROR_TEMPORARY
)
{
capturer_
-
>
CaptureFrame
(
)
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
ASSERT_NE
(
result
DesktopCapturer
:
:
Result
:
:
ERROR_PERMANENT
)
;
EXPECT_CALL
(
callback_
OnCaptureResultPtr
(
DesktopCapturer
:
:
Result
:
:
SUCCESS
_
)
)
.
Times
(
1
)
.
WillOnce
(
[
this
&
done
]
(
auto
res
auto
frame
)
{
CaptureDoneCallback2
(
res
frame
)
;
done
=
true
;
}
)
;
while
(
!
done
)
{
capturer_
-
>
CaptureFrame
(
)
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
}
}
