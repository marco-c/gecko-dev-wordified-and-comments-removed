#
include
"
modules
/
desktop_capture
/
mac
/
screen_capturer_sck
.
h
"
#
import
<
ScreenCaptureKit
/
ScreenCaptureKit
.
h
>
#
include
<
atomic
>
#
include
"
modules
/
desktop_capture
/
mac
/
desktop_frame_iosurface
.
h
"
#
include
"
modules
/
desktop_capture
/
shared_desktop_frame
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
sdk
/
objc
/
helpers
/
scoped_cftyperef
.
h
"
using
webrtc
:
:
DesktopFrameIOSurface
;
#
define
SCK_AVAILABLE
available
(
macOS
14
.
0
*
)
namespace
webrtc
{
class
ScreenCapturerSck
;
}
API_AVAILABLE
(
macos
(
14
.
0
)
)
interface
SckHelper
:
NSObject
<
SCStreamDelegate
SCStreamOutput
>
-
(
instancetype
)
initWithCapturer
:
(
webrtc
:
:
ScreenCapturerSck
*
)
capturer
;
-
(
void
)
onShareableContentCreated
:
(
SCShareableContent
*
)
content
;
-
(
void
)
releaseCapturer
;
end
namespace
webrtc
{
bool
ScreenCapturerSckAvailable
(
)
{
bool
sonomaOrHigher
=
false
;
if
(
SCK_AVAILABLE
)
{
sonomaOrHigher
=
true
;
}
return
sonomaOrHigher
;
}
class
API_AVAILABLE
(
macos
(
14
.
0
)
)
ScreenCapturerSck
final
:
public
DesktopCapturer
{
public
:
explicit
ScreenCapturerSck
(
const
DesktopCaptureOptions
&
options
)
;
ScreenCapturerSck
(
const
ScreenCapturerSck
&
)
=
delete
;
ScreenCapturerSck
&
operator
=
(
const
ScreenCapturerSck
&
)
=
delete
;
~
ScreenCapturerSck
(
)
override
;
void
Start
(
DesktopCapturer
:
:
Callback
*
callback
)
override
;
void
SetMaxFrameRate
(
uint32_t
max_frame_rate
)
override
;
void
CaptureFrame
(
)
override
;
bool
SelectSource
(
SourceId
id
)
override
;
void
OnShareableContentCreated
(
SCShareableContent
*
content
)
;
void
OnNewIOSurface
(
IOSurfaceRef
io_surface
CFDictionaryRef
attachment
)
;
private
:
void
StartOrReconfigureCapturer
(
)
;
SckHelper
*
__strong
helper_
;
Callback
*
callback_
=
nullptr
;
DesktopCaptureOptions
capture_options_
;
std
:
:
atomic
<
bool
>
permanent_error_
=
false
;
Mutex
lock_
;
SCStream
*
__strong
stream_
RTC_GUARDED_BY
(
lock_
)
;
CGDirectDisplayID
current_display_
RTC_GUARDED_BY
(
lock_
)
=
0
;
MacDesktopConfiguration
desktop_config_
;
Mutex
latest_frame_lock_
;
std
:
:
unique_ptr
<
SharedDesktopFrame
>
latest_frame_
RTC_GUARDED_BY
(
latest_frame_lock_
)
;
int32_t
latest_frame_dpi_
RTC_GUARDED_BY
(
latest_frame_lock_
)
=
kStandardDPI
;
bool
frame_is_dirty_
RTC_GUARDED_BY
(
latest_frame_lock_
)
=
true
;
}
;
ScreenCapturerSck
:
:
ScreenCapturerSck
(
const
DesktopCaptureOptions
&
options
)
:
capture_options_
(
options
)
{
helper_
=
[
[
SckHelper
alloc
]
initWithCapturer
:
this
]
;
}
ScreenCapturerSck
:
:
~
ScreenCapturerSck
(
)
{
[
stream_
stopCaptureWithCompletionHandler
:
nil
]
;
[
helper_
releaseCapturer
]
;
}
void
ScreenCapturerSck
:
:
Start
(
DesktopCapturer
:
:
Callback
*
callback
)
{
callback_
=
callback
;
desktop_config_
=
capture_options_
.
configuration_monitor
(
)
-
>
desktop_configuration
(
)
;
StartOrReconfigureCapturer
(
)
;
}
void
ScreenCapturerSck
:
:
SetMaxFrameRate
(
uint32_t
max_frame_rate
)
{
}
void
ScreenCapturerSck
:
:
CaptureFrame
(
)
{
int64_t
capture_start_time_millis
=
rtc
:
:
TimeMillis
(
)
;
if
(
permanent_error_
)
{
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_PERMANENT
nullptr
)
;
return
;
}
MacDesktopConfiguration
new_config
=
capture_options_
.
configuration_monitor
(
)
-
>
desktop_configuration
(
)
;
if
(
!
desktop_config_
.
Equals
(
new_config
)
)
{
desktop_config_
=
new_config
;
StartOrReconfigureCapturer
(
)
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
frame
;
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
if
(
latest_frame_
)
{
frame
=
latest_frame_
-
>
Share
(
)
;
frame
-
>
set_dpi
(
DesktopVector
(
latest_frame_dpi_
latest_frame_dpi_
)
)
;
if
(
frame_is_dirty_
)
{
frame
-
>
mutable_updated_region
(
)
-
>
AddRect
(
DesktopRect
:
:
MakeSize
(
frame
-
>
size
(
)
)
)
;
frame_is_dirty_
=
false
;
}
}
}
if
(
frame
)
{
frame
-
>
set_capture_time_ms
(
rtc
:
:
TimeSince
(
capture_start_time_millis
)
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
frame
)
)
;
}
else
{
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
}
}
bool
ScreenCapturerSck
:
:
SelectSource
(
SourceId
id
)
{
bool
stream_started
=
false
;
{
MutexLock
lock
(
&
lock_
)
;
current_display_
=
id
;
if
(
stream_
)
{
stream_started
=
true
;
}
}
if
(
stream_started
)
{
StartOrReconfigureCapturer
(
)
;
}
return
true
;
}
void
ScreenCapturerSck
:
:
OnShareableContentCreated
(
SCShareableContent
*
content
)
{
if
(
!
content
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
getShareableContent
failed
.
"
;
permanent_error_
=
true
;
return
;
}
if
(
!
content
.
displays
.
count
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
getShareableContent
returned
no
displays
.
"
;
permanent_error_
=
true
;
return
;
}
SCDisplay
*
captured_display
;
{
MutexLock
lock
(
&
lock_
)
;
for
(
SCDisplay
*
display
in
content
.
displays
)
{
if
(
current_display_
=
=
display
.
displayID
)
{
captured_display
=
display
;
break
;
}
}
if
(
!
captured_display
)
{
if
(
current_display_
=
=
static_cast
<
CGDirectDisplayID
>
(
kFullDesktopScreenId
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Full
screen
capture
is
not
supported
falling
back
to
first
display
.
"
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Display
"
<
<
current_display_
<
<
"
not
found
falling
back
to
first
display
.
"
;
}
captured_display
=
content
.
displays
.
firstObject
;
}
}
SCContentFilter
*
filter
=
[
[
SCContentFilter
alloc
]
initWithDisplay
:
captured_display
excludingWindows
:
[
]
]
;
SCStreamConfiguration
*
config
=
[
[
SCStreamConfiguration
alloc
]
init
]
;
config
.
pixelFormat
=
kCVPixelFormatType_32BGRA
;
config
.
showsCursor
=
capture_options_
.
prefer_cursor_embedded
(
)
;
config
.
width
=
filter
.
contentRect
.
size
.
width
*
filter
.
pointPixelScale
;
config
.
height
=
filter
.
contentRect
.
size
.
height
*
filter
.
pointPixelScale
;
config
.
captureResolution
=
SCCaptureResolutionNominal
;
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
latest_frame_dpi_
=
filter
.
pointPixelScale
*
kStandardDPI
;
}
MutexLock
lock
(
&
lock_
)
;
if
(
stream_
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Updating
stream
configuration
.
"
;
[
stream_
updateContentFilter
:
filter
completionHandler
:
nil
]
;
[
stream_
updateConfiguration
:
config
completionHandler
:
nil
]
;
}
else
{
stream_
=
[
[
SCStream
alloc
]
initWithFilter
:
filter
configuration
:
config
delegate
:
helper_
]
;
NSError
*
add_stream_output_error
;
bool
add_stream_output_result
=
[
stream_
addStreamOutput
:
helper_
type
:
SCStreamOutputTypeScreen
sampleHandlerQueue
:
nil
error
:
&
add_stream_output_error
]
;
if
(
!
add_stream_output_result
)
{
stream_
=
nil
;
RTC_LOG
(
LS_ERROR
)
<
<
"
addStreamOutput
failed
.
"
;
permanent_error_
=
true
;
return
;
}
auto
handler
=
^
(
NSError
*
error
)
{
if
(
error
)
{
permanent_error_
=
true
;
RTC_LOG
(
LS_ERROR
)
<
<
"
startCaptureWithCompletionHandler
failed
.
"
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
Capture
started
.
"
;
}
}
;
[
stream_
startCaptureWithCompletionHandler
:
handler
]
;
}
}
void
ScreenCapturerSck
:
:
OnNewIOSurface
(
IOSurfaceRef
io_surface
CFDictionaryRef
attachment
)
{
rtc
:
:
ScopedCFTypeRef
<
IOSurfaceRef
>
scoped_io_surface
(
io_surface
rtc
:
:
RetainPolicy
:
:
RETAIN
)
;
std
:
:
unique_ptr
<
DesktopFrameIOSurface
>
desktop_frame_io_surface
=
DesktopFrameIOSurface
:
:
Wrap
(
scoped_io_surface
)
;
if
(
!
desktop_frame_io_surface
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
lock
IOSurface
.
"
;
return
;
}
std
:
:
unique_ptr
<
SharedDesktopFrame
>
frame
=
SharedDesktopFrame
:
:
Wrap
(
std
:
:
move
(
desktop_frame_io_surface
)
)
;
bool
dirty
;
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
dirty
=
!
latest_frame_
|
|
!
latest_frame_
-
>
size
(
)
.
equals
(
frame
-
>
size
(
)
)
;
}
if
(
!
dirty
)
{
const
void
*
dirty_rects_ptr
=
CFDictionaryGetValue
(
attachment
(
__bridge
CFStringRef
)
SCStreamFrameInfoDirtyRects
)
;
if
(
!
dirty_rects_ptr
)
{
return
;
}
if
(
CFGetTypeID
(
dirty_rects_ptr
)
!
=
CFArrayGetTypeID
(
)
)
{
return
;
}
CFArrayRef
dirty_rects_array
=
static_cast
<
CFArrayRef
>
(
dirty_rects_ptr
)
;
int
size
=
CFArrayGetCount
(
dirty_rects_array
)
;
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
const
void
*
rect_ptr
=
CFArrayGetValueAtIndex
(
dirty_rects_array
i
)
;
if
(
CFGetTypeID
(
rect_ptr
)
!
=
CFDictionaryGetTypeID
(
)
)
{
return
;
}
CGRect
rect
{
}
;
CGRectMakeWithDictionaryRepresentation
(
static_cast
<
CFDictionaryRef
>
(
rect_ptr
)
&
rect
)
;
if
(
!
CGRectIsEmpty
(
rect
)
)
{
dirty
=
true
;
break
;
}
}
}
if
(
dirty
)
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
frame_is_dirty_
=
true
;
std
:
:
swap
(
latest_frame_
frame
)
;
}
}
void
ScreenCapturerSck
:
:
StartOrReconfigureCapturer
(
)
{
SckHelper
*
local_helper
=
helper_
;
auto
handler
=
^
(
SCShareableContent
*
content
NSError
*
error
)
{
[
local_helper
onShareableContentCreated
:
content
]
;
}
;
[
SCShareableContent
getShareableContentWithCompletionHandler
:
handler
]
;
}
std
:
:
unique_ptr
<
DesktopCapturer
>
CreateScreenCapturerSck
(
const
DesktopCaptureOptions
&
options
)
{
if
(
SCK_AVAILABLE
)
{
return
std
:
:
make_unique
<
ScreenCapturerSck
>
(
options
)
;
}
return
nullptr
;
}
}
implementation
SckHelper
{
webrtc
:
:
Mutex
_capturer_lock
;
webrtc
:
:
ScreenCapturerSck
*
_capturer
;
}
-
(
instancetype
)
initWithCapturer
:
(
webrtc
:
:
ScreenCapturerSck
*
)
capturer
{
if
(
self
=
[
super
init
]
)
{
_capturer
=
capturer
;
}
return
self
;
}
-
(
void
)
onShareableContentCreated
:
(
SCShareableContent
*
)
content
{
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
if
(
_capturer
)
{
_capturer
-
>
OnShareableContentCreated
(
content
)
;
}
}
-
(
void
)
stream
:
(
SCStream
*
)
stream
didOutputSampleBuffer
:
(
CMSampleBufferRef
)
sampleBuffer
ofType
:
(
SCStreamOutputType
)
type
{
CVPixelBufferRef
pixelBuffer
=
CMSampleBufferGetImageBuffer
(
sampleBuffer
)
;
if
(
!
pixelBuffer
)
{
return
;
}
IOSurfaceRef
ioSurface
=
CVPixelBufferGetIOSurface
(
pixelBuffer
)
;
if
(
!
ioSurface
)
{
return
;
}
CFArrayRef
attachmentsArray
=
CMSampleBufferGetSampleAttachmentsArray
(
sampleBuffer
false
)
;
if
(
!
attachmentsArray
|
|
CFArrayGetCount
(
attachmentsArray
)
<
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Discarding
frame
with
no
attachments
.
"
;
return
;
}
CFDictionaryRef
attachment
=
static_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
attachmentsArray
0
)
)
;
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
if
(
_capturer
)
{
_capturer
-
>
OnNewIOSurface
(
ioSurface
attachment
)
;
}
}
-
(
void
)
releaseCapturer
{
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
_capturer
=
nullptr
;
}
end
#
undef
SCK_AVAILABLE
