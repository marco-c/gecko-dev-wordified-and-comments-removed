#
include
"
modules
/
desktop_capture
/
mac
/
screen_capturer_sck
.
h
"
#
import
<
ScreenCaptureKit
/
ScreenCaptureKit
.
h
>
#
include
<
atomic
>
#
include
"
modules
/
desktop_capture
/
mac
/
desktop_frame_iosurface
.
h
"
#
include
"
modules
/
desktop_capture
/
shared_desktop_frame
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
#
include
"
sdk
/
objc
/
helpers
/
scoped_cftyperef
.
h
"
using
webrtc
:
:
DesktopFrameIOSurface
;
namespace
webrtc
{
class
ScreenCapturerSck
;
}
API_AVAILABLE
(
macos
(
14
.
0
)
)
interface
SckHelper
:
NSObject
<
SCStreamDelegate
SCStreamOutput
>
-
(
instancetype
)
initWithCapturer
:
(
webrtc
:
:
ScreenCapturerSck
*
)
capturer
;
-
(
void
)
onShareableContentCreated
:
(
SCShareableContent
*
)
content
error
:
(
NSError
*
)
error
;
-
(
void
)
releaseCapturer
;
end
namespace
webrtc
{
class
API_AVAILABLE
(
macos
(
14
.
0
)
)
ScreenCapturerSck
final
:
public
DesktopCapturer
{
public
:
explicit
ScreenCapturerSck
(
const
DesktopCaptureOptions
&
options
)
;
ScreenCapturerSck
(
const
ScreenCapturerSck
&
)
=
delete
;
ScreenCapturerSck
&
operator
=
(
const
ScreenCapturerSck
&
)
=
delete
;
~
ScreenCapturerSck
(
)
override
;
void
Start
(
DesktopCapturer
:
:
Callback
*
callback
)
override
;
void
SetMaxFrameRate
(
uint32_t
max_frame_rate
)
override
;
void
CaptureFrame
(
)
override
;
bool
SelectSource
(
SourceId
id
)
override
;
void
NotifyCaptureStopped
(
SCStream
*
stream
)
;
void
OnShareableContentCreated
(
SCShareableContent
*
content
NSError
*
error
)
;
void
OnNewIOSurface
(
IOSurfaceRef
io_surface
NSDictionary
*
attachment
)
;
private
:
void
StartOrReconfigureCapturer
(
)
;
SckHelper
*
__strong
helper_
;
Callback
*
callback_
=
nullptr
;
const
DesktopCaptureOptions
capture_options_
;
std
:
:
atomic
<
bool
>
permanent_error_
=
false
;
Mutex
lock_
;
SCStream
*
__strong
stream_
RTC_GUARDED_BY
(
lock_
)
;
CGDirectDisplayID
current_display_
RTC_GUARDED_BY
(
lock_
)
=
0
;
uint32_t
max_frame_rate_
RTC_GUARDED_BY
(
lock_
)
=
0
;
MacDesktopConfiguration
desktop_config_
;
Mutex
latest_frame_lock_
RTC_ACQUIRED_AFTER
(
lock_
)
;
std
:
:
unique_ptr
<
SharedDesktopFrame
>
latest_frame_
RTC_GUARDED_BY
(
latest_frame_lock_
)
;
int32_t
latest_frame_dpi_
RTC_GUARDED_BY
(
latest_frame_lock_
)
=
kStandardDPI
;
bool
frame_is_dirty_
RTC_GUARDED_BY
(
latest_frame_lock_
)
=
true
;
bool
frame_needs_reconfigure_
RTC_GUARDED_BY
(
latest_frame_lock_
)
=
false
;
std
:
:
optional
<
CGSize
>
frame_reconfigure_img_size_
RTC_GUARDED_BY
(
latest_frame_lock_
)
;
}
;
ScreenCapturerSck
:
:
ScreenCapturerSck
(
const
DesktopCaptureOptions
&
options
)
:
capture_options_
(
options
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
created
"
;
helper_
=
[
[
SckHelper
alloc
]
initWithCapturer
:
this
]
;
}
ScreenCapturerSck
:
:
~
ScreenCapturerSck
(
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
destroyed
.
"
;
[
stream_
stopCaptureWithCompletionHandler
:
nil
]
;
[
helper_
releaseCapturer
]
;
}
void
ScreenCapturerSck
:
:
Start
(
DesktopCapturer
:
:
Callback
*
callback
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
"
<
<
__func__
<
<
"
.
"
;
callback_
=
callback
;
desktop_config_
=
capture_options_
.
configuration_monitor
(
)
-
>
desktop_configuration
(
)
;
StartOrReconfigureCapturer
(
)
;
}
void
ScreenCapturerSck
:
:
SetMaxFrameRate
(
uint32_t
max_frame_rate
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
SetMaxFrameRate
(
"
<
<
max_frame_rate
<
<
"
)
.
"
;
bool
stream_started
=
false
;
{
MutexLock
lock
(
&
lock_
)
;
if
(
max_frame_rate_
=
=
max_frame_rate
)
{
return
;
}
max_frame_rate_
=
max_frame_rate
;
stream_started
=
stream_
;
}
if
(
stream_started
)
{
StartOrReconfigureCapturer
(
)
;
}
}
void
ScreenCapturerSck
:
:
CaptureFrame
(
)
{
int64_t
capture_start_time_millis
=
rtc
:
:
TimeMillis
(
)
;
if
(
permanent_error_
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
CaptureFrame
(
)
-
>
ERROR_PERMANENT
"
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_PERMANENT
nullptr
)
;
return
;
}
MacDesktopConfiguration
new_config
=
capture_options_
.
configuration_monitor
(
)
-
>
desktop_configuration
(
)
;
if
(
!
desktop_config_
.
Equals
(
new_config
)
)
{
desktop_config_
=
new_config
;
StartOrReconfigureCapturer
(
)
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
frame
;
bool
needs_reconfigure
=
false
;
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
if
(
latest_frame_
)
{
frame
=
latest_frame_
-
>
Share
(
)
;
if
(
frame_is_dirty_
)
{
frame
-
>
mutable_updated_region
(
)
-
>
AddRect
(
DesktopRect
:
:
MakeSize
(
frame
-
>
size
(
)
)
)
;
frame_is_dirty_
=
false
;
}
}
needs_reconfigure
=
frame_needs_reconfigure_
;
frame_needs_reconfigure_
=
false
;
}
if
(
needs_reconfigure
)
{
StartOrReconfigureCapturer
(
)
;
}
if
(
frame
)
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
CaptureFrame
(
)
-
>
SUCCESS
"
;
frame
-
>
set_capture_time_ms
(
rtc
:
:
TimeSince
(
capture_start_time_millis
)
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
frame
)
)
;
}
else
{
RTC_LOG
(
LS_VERBOSE
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
CaptureFrame
(
)
-
>
ERROR_TEMPORARY
"
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
}
}
void
ScreenCapturerSck
:
:
NotifyCaptureStopped
(
SCStream
*
stream
)
{
MutexLock
lock
(
&
lock_
)
;
if
(
stream_
!
=
stream
)
{
return
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
"
<
<
__func__
<
<
"
.
"
;
permanent_error_
=
true
;
}
bool
ScreenCapturerSck
:
:
SelectSource
(
SourceId
id
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
SelectSource
(
id
=
"
<
<
id
<
<
"
)
.
"
;
bool
stream_started
=
false
;
{
MutexLock
lock
(
&
lock_
)
;
if
(
current_display_
=
=
id
)
{
return
true
;
}
current_display_
=
id
;
if
(
stream_
)
{
stream_started
=
true
;
}
}
if
(
stream_started
)
{
StartOrReconfigureCapturer
(
)
;
}
return
true
;
}
void
ScreenCapturerSck
:
:
OnShareableContentCreated
(
SCShareableContent
*
content
NSError
*
error
)
{
if
(
!
content
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
getShareableContent
failed
with
error
code
"
<
<
(
error
?
error
.
code
:
0
)
<
<
"
.
"
;
permanent_error_
=
true
;
return
;
}
if
(
!
content
.
displays
.
count
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
getShareableContent
returned
no
displays
.
"
;
permanent_error_
=
true
;
return
;
}
MutexLock
lock
(
&
lock_
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
"
<
<
__func__
<
<
"
.
current_display_
=
"
<
<
current_display_
;
SCDisplay
*
captured_display
;
for
(
SCDisplay
*
display
in
content
.
displays
)
{
if
(
current_display_
=
=
display
.
displayID
)
{
captured_display
=
display
;
break
;
}
}
if
(
!
captured_display
)
{
if
(
current_display_
=
=
static_cast
<
CGDirectDisplayID
>
(
kFullDesktopScreenId
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
Full
screen
"
"
capture
is
not
supported
falling
back
to
first
"
"
display
.
"
;
}
else
{
RTC_LOG
(
LS_WARNING
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
Display
"
<
<
current_display_
<
<
"
not
found
falling
back
to
"
"
first
display
.
"
;
}
captured_display
=
content
.
displays
.
firstObject
;
}
SCContentFilter
*
filter
=
[
[
SCContentFilter
alloc
]
initWithDisplay
:
captured_display
excludingWindows
:
[
]
]
;
SCStreamConfiguration
*
config
=
[
[
SCStreamConfiguration
alloc
]
init
]
;
config
.
pixelFormat
=
kCVPixelFormatType_32BGRA
;
config
.
colorSpaceName
=
kCGColorSpaceSRGB
;
config
.
showsCursor
=
capture_options_
.
prefer_cursor_embedded
(
)
;
config
.
width
=
filter
.
contentRect
.
size
.
width
*
filter
.
pointPixelScale
;
config
.
height
=
filter
.
contentRect
.
size
.
height
*
filter
.
pointPixelScale
;
config
.
captureResolution
=
SCCaptureResolutionNominal
;
config
.
minimumFrameInterval
=
max_frame_rate_
>
0
?
CMTimeMake
(
1
static_cast
<
int32_t
>
(
max_frame_rate_
)
)
:
kCMTimeZero
;
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
latest_frame_dpi_
=
filter
.
pointPixelScale
*
kStandardDPI
;
frame_reconfigure_img_size_
=
std
:
:
nullopt
;
}
if
(
stream_
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
Updating
stream
configuration
to
size
=
"
<
<
config
.
width
<
<
"
x
"
<
<
config
.
height
<
<
"
and
max_frame_rate
=
"
<
<
max_frame_rate_
<
<
"
.
"
;
[
stream_
updateContentFilter
:
filter
completionHandler
:
nil
]
;
[
stream_
updateConfiguration
:
config
completionHandler
:
nil
]
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
Creating
new
stream
.
"
;
stream_
=
[
[
SCStream
alloc
]
initWithFilter
:
filter
configuration
:
config
delegate
:
helper_
]
;
NSError
*
add_stream_output_error
;
bool
add_stream_output_result
=
[
stream_
addStreamOutput
:
helper_
type
:
SCStreamOutputTypeScreen
sampleHandlerQueue
:
nil
error
:
&
add_stream_output_error
]
;
if
(
!
add_stream_output_result
)
{
stream_
=
nil
;
RTC_LOG
(
LS_ERROR
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
addStreamOutput
failed
.
"
;
permanent_error_
=
true
;
return
;
}
auto
handler
=
^
(
NSError
*
error
)
{
if
(
error
)
{
permanent_error_
=
true
;
RTC_LOG
(
LS_ERROR
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
Starting
failed
.
"
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
Capture
started
.
"
;
}
}
;
[
stream_
startCaptureWithCompletionHandler
:
handler
]
;
}
}
void
ScreenCapturerSck
:
:
OnNewIOSurface
(
IOSurfaceRef
io_surface
NSDictionary
*
attachment
)
{
bool
has_frame_to_process
=
false
;
if
(
auto
status_nr
=
(
NSNumber
*
)
attachment
[
SCStreamFrameInfoStatus
]
)
{
auto
status
=
(
SCFrameStatus
)
[
status_nr
integerValue
]
;
has_frame_to_process
=
status
=
=
SCFrameStatusComplete
|
|
status
=
=
SCFrameStatusStarted
;
}
if
(
!
has_frame_to_process
)
{
return
;
}
double
scale_factor
=
1
;
if
(
auto
factor
=
(
NSNumber
*
)
attachment
[
SCStreamFrameInfoScaleFactor
]
)
{
scale_factor
=
[
factor
floatValue
]
;
}
double
content_scale
=
1
;
if
(
auto
scale
=
(
NSNumber
*
)
attachment
[
SCStreamFrameInfoContentScale
]
)
{
content_scale
=
[
scale
floatValue
]
;
}
CGRect
content_rect
=
{
}
;
if
(
const
auto
*
rect_dict
=
(
__bridge
CFDictionaryRef
)
attachment
[
SCStreamFrameInfoContentRect
]
)
{
if
(
!
CGRectMakeWithDictionaryRepresentation
(
rect_dict
&
content_rect
)
)
{
content_rect
=
CGRect
(
)
;
}
}
CGRect
bounding_rect
=
{
}
;
if
(
const
auto
*
rect_dict
=
(
__bridge
CFDictionaryRef
)
attachment
[
SCStreamFrameInfoBoundingRect
]
)
{
if
(
!
CGRectMakeWithDictionaryRepresentation
(
rect_dict
&
bounding_rect
)
)
{
bounding_rect
=
CGRect
(
)
;
}
}
CGRect
overlay_rect
=
{
}
;
if
(
available
(
macOS
14
.
2
*
)
)
{
if
(
const
auto
*
rect_dict
=
(
__bridge
CFDictionaryRef
)
attachment
[
SCStreamFrameInfoPresenterOverlayContentRect
]
)
{
if
(
!
CGRectMakeWithDictionaryRepresentation
(
rect_dict
&
overlay_rect
)
)
{
overlay_rect
=
CGRect
(
)
;
}
}
}
const
auto
*
dirty_rects
=
(
NSArray
*
)
attachment
[
SCStreamFrameInfoDirtyRects
]
;
auto
img_bounding_rect
=
CGRectMake
(
scale_factor
*
bounding_rect
.
origin
.
x
scale_factor
*
bounding_rect
.
origin
.
y
scale_factor
*
bounding_rect
.
size
.
width
scale_factor
*
bounding_rect
.
size
.
height
)
;
rtc
:
:
ScopedCFTypeRef
<
IOSurfaceRef
>
scoped_io_surface
(
io_surface
rtc
:
:
RetainPolicy
:
:
RETAIN
)
;
std
:
:
unique_ptr
<
DesktopFrameIOSurface
>
desktop_frame_io_surface
=
DesktopFrameIOSurface
:
:
Wrap
(
scoped_io_surface
img_bounding_rect
)
;
if
(
!
desktop_frame_io_surface
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
lock
IOSurface
.
"
;
return
;
}
const
size_t
width
=
IOSurfaceGetWidth
(
io_surface
)
;
const
size_t
height
=
IOSurfaceGetHeight
(
io_surface
)
;
RTC_LOG
(
LS_VERBOSE
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
"
<
<
__func__
<
<
"
.
New
surface
:
width
=
"
<
<
width
<
<
"
height
=
"
<
<
height
<
<
"
content_rect
=
"
<
<
NSStringFromRect
(
content_rect
)
.
UTF8String
<
<
"
bounding_rect
=
"
<
<
NSStringFromRect
(
bounding_rect
)
.
UTF8String
<
<
"
overlay_rect
=
(
"
<
<
NSStringFromRect
(
overlay_rect
)
.
UTF8String
<
<
"
scale_factor
=
"
<
<
scale_factor
<
<
"
content_scale
=
"
<
<
content_scale
<
<
"
.
Cropping
to
rect
"
<
<
NSStringFromRect
(
img_bounding_rect
)
.
UTF8String
<
<
"
.
"
;
std
:
:
unique_ptr
<
SharedDesktopFrame
>
frame
=
SharedDesktopFrame
:
:
Wrap
(
std
:
:
move
(
desktop_frame_io_surface
)
)
;
bool
dirty
;
{
MutexLock
lock
(
&
latest_frame_lock_
)
;
dirty
=
!
latest_frame_
|
|
!
latest_frame_
-
>
size
(
)
.
equals
(
frame
-
>
size
(
)
)
;
}
if
(
!
dirty
)
{
if
(
!
dirty_rects
)
{
return
;
}
for
(
NSUInteger
i
=
0
;
i
<
dirty_rects
.
count
;
i
+
+
)
{
const
auto
*
rect_ptr
=
(
__bridge
CFDictionaryRef
)
dirty_rects
[
i
]
;
if
(
CFGetTypeID
(
rect_ptr
)
!
=
CFDictionaryGetTypeID
(
)
)
{
return
;
}
CGRect
rect
{
}
;
CGRectMakeWithDictionaryRepresentation
(
rect_ptr
&
rect
)
;
if
(
!
CGRectIsEmpty
(
rect
)
)
{
dirty
=
true
;
break
;
}
}
}
MutexLock
lock
(
&
latest_frame_lock_
)
;
if
(
content_scale
>
0
&
&
content_scale
<
1
)
{
frame_needs_reconfigure_
=
true
;
double
scale
=
1
/
content_scale
;
frame_reconfigure_img_size_
=
CGSizeMake
(
std
:
:
ceil
(
scale
*
width
)
std
:
:
ceil
(
scale
*
height
)
)
;
}
if
(
dirty
)
{
frame
-
>
set_dpi
(
DesktopVector
(
latest_frame_dpi_
latest_frame_dpi_
)
)
;
frame
-
>
set_may_contain_cursor
(
capture_options_
.
prefer_cursor_embedded
(
)
)
;
frame_is_dirty_
=
true
;
std
:
:
swap
(
latest_frame_
frame
)
;
}
}
void
ScreenCapturerSck
:
:
StartOrReconfigureCapturer
(
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
this
<
<
"
"
<
<
__func__
<
<
"
.
"
;
SckHelper
*
local_helper
=
helper_
;
auto
handler
=
^
(
SCShareableContent
*
content
NSError
*
error
)
{
[
local_helper
onShareableContentCreated
:
content
error
:
error
]
;
}
;
[
SCShareableContent
getShareableContentWithCompletionHandler
:
handler
]
;
}
bool
ScreenCapturerSckAvailable
(
)
{
static
bool
available
=
(
[
]
{
if
(
available
(
macOS
14
.
0
*
)
)
{
return
true
;
}
return
false
;
}
)
(
)
;
return
available
;
}
std
:
:
unique_ptr
<
DesktopCapturer
>
CreateScreenCapturerSck
(
const
DesktopCaptureOptions
&
options
)
{
if
(
available
(
macOS
14
.
0
*
)
)
{
return
std
:
:
make_unique
<
ScreenCapturerSck
>
(
options
)
;
}
return
nullptr
;
}
}
implementation
SckHelper
{
webrtc
:
:
Mutex
_capturer_lock
;
webrtc
:
:
ScreenCapturerSck
*
_capturer
;
}
-
(
instancetype
)
initWithCapturer
:
(
webrtc
:
:
ScreenCapturerSck
*
)
capturer
{
self
=
[
super
init
]
;
if
(
self
)
{
_capturer
=
capturer
;
}
return
self
;
}
-
(
void
)
onShareableContentCreated
:
(
SCShareableContent
*
)
content
error
:
(
NSError
*
)
error
{
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
if
(
_capturer
)
{
_capturer
-
>
OnShareableContentCreated
(
content
error
)
;
}
}
-
(
void
)
stream
:
(
SCStream
*
)
stream
didStopWithError
:
(
NSError
*
)
error
{
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
_capturer
<
<
"
"
<
<
__func__
<
<
"
.
"
;
if
(
_capturer
)
{
_capturer
-
>
NotifyCaptureStopped
(
stream
)
;
}
}
-
(
void
)
userDidStopStream
:
(
SCStream
*
)
stream
NS_SWIFT_NAME
(
userDidStopStream
(
_
:
)
)
API_AVAILABLE
(
macos
(
14
.
4
)
)
{
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
_capturer
<
<
"
"
<
<
__func__
<
<
"
.
"
;
if
(
_capturer
)
{
_capturer
-
>
NotifyCaptureStopped
(
stream
)
;
}
}
-
(
void
)
stream
:
(
SCStream
*
)
stream
didOutputSampleBuffer
:
(
CMSampleBufferRef
)
sampleBuffer
ofType
:
(
SCStreamOutputType
)
type
{
CVPixelBufferRef
pixelBuffer
=
CMSampleBufferGetImageBuffer
(
sampleBuffer
)
;
if
(
!
pixelBuffer
)
{
return
;
}
IOSurfaceRef
ioSurface
=
CVPixelBufferGetIOSurface
(
pixelBuffer
)
;
if
(
!
ioSurface
)
{
return
;
}
CFArrayRef
attachmentsArray
=
CMSampleBufferGetSampleAttachmentsArray
(
sampleBuffer
false
)
;
if
(
!
attachmentsArray
|
|
CFArrayGetCount
(
attachmentsArray
)
<
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Discarding
frame
with
no
attachments
.
"
;
return
;
}
CFDictionaryRef
attachment
=
static_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
attachmentsArray
0
)
)
;
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
if
(
_capturer
)
{
_capturer
-
>
OnNewIOSurface
(
ioSurface
(
__bridge
NSDictionary
*
)
attachment
)
;
}
}
-
(
void
)
releaseCapturer
{
webrtc
:
:
MutexLock
lock
(
&
_capturer_lock
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
ScreenCapturerSck
"
<
<
_capturer
<
<
"
"
<
<
__func__
<
<
"
.
"
;
_capturer
=
nullptr
;
}
end
