#
include
<
stddef
.
h
>
#
include
<
cstdint
>
#
include
<
vector
>
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
api
/
video_codecs
/
video_decoder
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_video_header
.
h
"
#
include
"
modules
/
video_coding
/
deprecated
/
jitter_buffer
.
h
"
#
include
"
modules
/
video_coding
/
deprecated
/
packet
.
h
"
#
include
"
modules
/
video_coding
/
deprecated
/
receiver
.
h
"
#
include
"
modules
/
video_coding
/
encoded_frame
.
h
"
#
include
"
modules
/
video_coding
/
generic_decoder
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
modules
/
video_coding
/
internal_defines
.
h
"
#
include
"
modules
/
video_coding
/
timing
/
timing
.
h
"
#
include
"
modules
/
video_coding
/
video_coding_impl
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
one_time_event
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
vcm
{
VideoReceiver
:
:
VideoReceiver
(
Clock
*
clock
VCMTiming
*
timing
const
FieldTrialsView
&
field_trials
)
:
clock_
(
clock
)
_timing
(
timing
)
_receiver
(
_timing
clock_
field_trials
)
_decodedFrameCallback
(
_timing
clock_
field_trials
nullptr
)
_frameTypeCallback
(
nullptr
)
_packetRequestCallback
(
nullptr
)
_scheduleKeyRequest
(
false
)
drop_frames_until_keyframe_
(
false
)
max_nack_list_size_
(
0
)
_codecDataBase
(
)
_retransmissionTimer
(
10
clock_
)
_keyRequestTimer
(
500
clock_
)
{
decoder_thread_checker_
.
Detach
(
)
;
module_thread_checker_
.
Detach
(
)
;
}
VideoReceiver
:
:
~
VideoReceiver
(
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
}
void
VideoReceiver
:
:
Process
(
)
{
RTC_DCHECK_RUN_ON
(
&
module_thread_checker_
)
;
if
(
_keyRequestTimer
.
TimeUntilProcess
(
)
=
=
0
)
{
_keyRequestTimer
.
Processed
(
)
;
bool
request_key_frame
=
_frameTypeCallback
!
=
nullptr
;
if
(
request_key_frame
)
{
MutexLock
lock
(
&
process_mutex_
)
;
request_key_frame
=
_scheduleKeyRequest
;
}
if
(
request_key_frame
)
RequestKeyFrame
(
)
;
}
if
(
_retransmissionTimer
.
TimeUntilProcess
(
)
=
=
0
)
{
_retransmissionTimer
.
Processed
(
)
;
bool
callback_registered
=
_packetRequestCallback
!
=
nullptr
;
uint16_t
length
=
max_nack_list_size_
;
if
(
callback_registered
&
&
length
>
0
)
{
bool
request_key_frame
=
false
;
std
:
:
vector
<
uint16_t
>
nackList
=
_receiver
.
NackList
(
&
request_key_frame
)
;
int32_t
ret
=
VCM_OK
;
if
(
request_key_frame
)
{
ret
=
RequestKeyFrame
(
)
;
}
if
(
ret
=
=
VCM_OK
&
&
!
nackList
.
empty
(
)
)
{
MutexLock
lock
(
&
process_mutex_
)
;
if
(
_packetRequestCallback
!
=
nullptr
)
{
_packetRequestCallback
-
>
ResendPackets
(
&
nackList
[
0
]
nackList
.
size
(
)
)
;
}
}
}
}
}
int32_t
VideoReceiver
:
:
RegisterReceiveCallback
(
VCMReceiveCallback
*
receiveCallback
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
_decodedFrameCallback
.
SetUserReceiveCallback
(
receiveCallback
)
;
return
VCM_OK
;
}
void
VideoReceiver
:
:
RegisterExternalDecoder
(
VideoDecoder
*
externalDecoder
uint8_t
payloadType
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
if
(
externalDecoder
=
=
nullptr
)
{
RTC_CHECK
(
_codecDataBase
.
DeregisterExternalDecoder
(
payloadType
)
)
;
return
;
}
_codecDataBase
.
RegisterExternalDecoder
(
payloadType
externalDecoder
)
;
}
int32_t
VideoReceiver
:
:
RegisterFrameTypeCallback
(
VCMFrameTypeCallback
*
frameTypeCallback
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
_frameTypeCallback
=
frameTypeCallback
;
return
VCM_OK
;
}
int32_t
VideoReceiver
:
:
RegisterPacketRequestCallback
(
VCMPacketRequestCallback
*
callback
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
_packetRequestCallback
=
callback
;
return
VCM_OK
;
}
int32_t
VideoReceiver
:
:
Decode
(
uint16_t
maxWaitTimeMs
)
{
RTC_DCHECK_RUN_ON
(
&
decoder_thread_checker_
)
;
VCMEncodedFrame
*
frame
=
_receiver
.
FrameForDecoding
(
maxWaitTimeMs
true
)
;
if
(
!
frame
)
return
VCM_FRAME_NOT_READY
;
bool
drop_frame
=
false
;
{
MutexLock
lock
(
&
process_mutex_
)
;
if
(
drop_frames_until_keyframe_
)
{
if
(
frame
-
>
FrameType
(
)
!
=
VideoFrameType
:
:
kVideoFrameKey
)
{
drop_frame
=
true
;
_scheduleKeyRequest
=
true
;
}
else
{
drop_frames_until_keyframe_
=
false
;
}
}
}
if
(
drop_frame
)
{
_receiver
.
ReleaseFrame
(
frame
)
;
return
VCM_FRAME_NOT_READY
;
}
if
(
frame
-
>
RenderTimeMs
(
)
>
0
)
_timing
-
>
UpdateCurrentDelay
(
Timestamp
:
:
Millis
(
frame
-
>
RenderTimeMs
(
)
)
clock_
-
>
CurrentTime
(
)
)
;
if
(
first_frame_received_
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Received
first
complete
decodable
video
frame
"
;
}
const
int32_t
ret
=
Decode
(
*
frame
)
;
_receiver
.
ReleaseFrame
(
frame
)
;
return
ret
;
}
int32_t
VideoReceiver
:
:
RequestKeyFrame
(
)
{
RTC_DCHECK_RUN_ON
(
&
module_thread_checker_
)
;
TRACE_EVENT0
(
"
webrtc
"
"
RequestKeyFrame
"
)
;
if
(
_frameTypeCallback
!
=
nullptr
)
{
const
int32_t
ret
=
_frameTypeCallback
-
>
RequestKeyFrame
(
)
;
if
(
ret
<
0
)
{
return
ret
;
}
MutexLock
lock
(
&
process_mutex_
)
;
_scheduleKeyRequest
=
false
;
}
else
{
return
VCM_MISSING_CALLBACK
;
}
return
VCM_OK
;
}
int32_t
VideoReceiver
:
:
Decode
(
const
VCMEncodedFrame
&
frame
)
{
RTC_DCHECK_RUN_ON
(
&
decoder_thread_checker_
)
;
TRACE_EVENT0
(
"
webrtc
"
"
VideoReceiver
:
:
Decode
"
)
;
VCMGenericDecoder
*
decoder
=
_codecDataBase
.
GetDecoder
(
frame
&
_decodedFrameCallback
)
;
if
(
decoder
=
=
nullptr
)
{
return
VCM_NO_CODEC_REGISTERED
;
}
return
decoder
-
>
Decode
(
frame
clock_
-
>
CurrentTime
(
)
)
;
}
void
VideoReceiver
:
:
RegisterReceiveCodec
(
uint8_t
payload_type
const
VideoDecoder
:
:
Settings
&
settings
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
_codecDataBase
.
RegisterReceiveCodec
(
payload_type
settings
)
;
}
int32_t
VideoReceiver
:
:
IncomingPacket
(
const
uint8_t
*
incomingPayload
size_t
payloadLength
const
RTPHeader
&
rtp_header
const
RTPVideoHeader
&
video_header
)
{
RTC_DCHECK_RUN_ON
(
&
module_thread_checker_
)
;
if
(
video_header
.
frame_type
=
=
VideoFrameType
:
:
kVideoFrameKey
)
{
TRACE_EVENT1
(
"
webrtc
"
"
VCM
:
:
PacketKeyFrame
"
"
seqnum
"
rtp_header
.
sequenceNumber
)
;
}
if
(
incomingPayload
=
=
nullptr
)
{
payloadLength
=
0
;
}
const
VCMPacket
packet
(
incomingPayload
payloadLength
rtp_header
video_header
0
clock_
-
>
CurrentTime
(
)
)
;
int32_t
ret
=
_receiver
.
InsertPacket
(
packet
)
;
if
(
ret
=
=
VCM_FLUSH_INDICATOR
)
{
{
MutexLock
lock
(
&
process_mutex_
)
;
drop_frames_until_keyframe_
=
true
;
}
RequestKeyFrame
(
)
;
}
else
if
(
ret
<
0
)
{
return
ret
;
}
return
VCM_OK
;
}
void
VideoReceiver
:
:
SetNackSettings
(
size_t
max_nack_list_size
int
max_packet_age_to_nack
int
max_incomplete_time_ms
)
{
RTC_DCHECK_RUN_ON
(
&
construction_thread_checker_
)
;
if
(
max_nack_list_size
!
=
0
)
{
max_nack_list_size_
=
max_nack_list_size
;
}
_receiver
.
SetNackSettings
(
max_nack_list_size
max_packet_age_to_nack
max_incomplete_time_ms
)
;
}
}
}
