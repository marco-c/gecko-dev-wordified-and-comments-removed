#
ifndef
MODULES_VIDEO_CODING_CODECS_H264_INCLUDE_H264_GLOBALS_H_
#
define
MODULES_VIDEO_CODING_CODECS_H264_INCLUDE_H264_GLOBALS_H_
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
modules
/
video_coding
/
codecs
/
interface
/
common_constants
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
enum
H264PacketizationTypes
{
kH264SingleNalu
kH264StapA
kH264FuA
}
;
enum
class
H264PacketizationMode
{
NonInterleaved
=
0
SingleNalUnit
}
;
inline
std
:
:
string
ToString
(
H264PacketizationMode
mode
)
{
if
(
mode
=
=
H264PacketizationMode
:
:
NonInterleaved
)
{
return
"
NonInterleaved
"
;
}
else
if
(
mode
=
=
H264PacketizationMode
:
:
SingleNalUnit
)
{
return
"
SingleNalUnit
"
;
}
RTC_DCHECK_NOTREACHED
(
)
;
return
"
"
;
}
struct
NaluInfo
{
uint8_t
type
;
int
sps_id
;
int
pps_id
;
friend
bool
operator
=
=
(
const
NaluInfo
&
lhs
const
NaluInfo
&
rhs
)
{
return
lhs
.
type
=
=
rhs
.
type
&
&
lhs
.
sps_id
=
=
rhs
.
sps_id
&
&
lhs
.
pps_id
=
=
rhs
.
pps_id
;
}
friend
bool
operator
!
=
(
const
NaluInfo
&
lhs
const
NaluInfo
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
}
;
struct
RTPVideoHeaderH264
{
uint8_t
nalu_type
;
H264PacketizationTypes
packetization_type
;
std
:
:
vector
<
NaluInfo
>
nalus
;
H264PacketizationMode
packetization_mode
;
friend
bool
operator
=
=
(
const
RTPVideoHeaderH264
&
lhs
const
RTPVideoHeaderH264
&
rhs
)
{
return
lhs
.
nalu_type
=
=
rhs
.
nalu_type
&
&
lhs
.
packetization_type
=
=
rhs
.
packetization_type
&
&
lhs
.
nalus
=
=
rhs
.
nalus
&
&
lhs
.
packetization_mode
=
=
rhs
.
packetization_mode
;
}
friend
bool
operator
!
=
(
const
RTPVideoHeaderH264
&
lhs
const
RTPVideoHeaderH264
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
}
;
}
#
endif
