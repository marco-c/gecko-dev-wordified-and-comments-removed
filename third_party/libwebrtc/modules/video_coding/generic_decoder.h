#
ifndef
MODULES_VIDEO_CODING_GENERIC_DECODER_H_
#
define
MODULES_VIDEO_CODING_GENERIC_DECODER_H_
#
include
<
memory
>
#
include
<
string
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
modules
/
video_coding
/
encoded_frame
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_codec_interface
.
h
"
#
include
"
modules
/
video_coding
/
timestamp_map
.
h
"
#
include
"
modules
/
video_coding
/
timing
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
webrtc
{
class
VCMReceiveCallback
;
enum
{
kDecoderFrameMemoryLength
=
30
}
;
struct
VCMFrameInformation
{
int64_t
renderTimeMs
;
absl
:
:
optional
<
Timestamp
>
decodeStart
;
void
*
userData
;
VideoRotation
rotation
;
VideoContentType
content_type
;
PlayoutDelay
playout_delay
;
EncodedImage
:
:
Timing
timing
;
int64_t
ntp_time_ms
;
RtpPacketInfos
packet_infos
;
}
;
class
VCMDecodedFrameCallback
:
public
DecodedImageCallback
{
public
:
VCMDecodedFrameCallback
(
VCMTiming
*
timing
Clock
*
clock
)
;
~
VCMDecodedFrameCallback
(
)
override
;
void
SetUserReceiveCallback
(
VCMReceiveCallback
*
receiveCallback
)
;
VCMReceiveCallback
*
UserReceiveCallback
(
)
;
int32_t
Decoded
(
VideoFrame
&
decodedImage
)
override
;
int32_t
Decoded
(
VideoFrame
&
decodedImage
int64_t
decode_time_ms
)
override
;
void
Decoded
(
VideoFrame
&
decodedImage
absl
:
:
optional
<
int32_t
>
decode_time_ms
absl
:
:
optional
<
uint8_t
>
qp
)
override
;
void
OnDecoderImplementationName
(
const
char
*
implementation_name
)
;
void
Map
(
uint32_t
timestamp
VCMFrameInformation
*
frameInfo
)
;
int32_t
Pop
(
uint32_t
timestamp
)
;
private
:
SequenceChecker
construction_thread_
;
Clock
*
const
_clock
;
VCMReceiveCallback
*
_receiveCallback
=
nullptr
;
VCMTiming
*
_timing
;
Mutex
lock_
;
VCMTimestampMap
_timestampMap
RTC_GUARDED_BY
(
lock_
)
;
int64_t
ntp_offset_
;
FieldTrialOptional
<
TimeDelta
>
_extra_decode_time
;
FieldTrialParameter
<
bool
>
low_latency_renderer_enabled_
;
FieldTrialParameter
<
bool
>
low_latency_renderer_include_predecode_buffer_
;
}
;
class
VCMGenericDecoder
{
public
:
explicit
VCMGenericDecoder
(
std
:
:
unique_ptr
<
VideoDecoder
>
decoder
)
;
explicit
VCMGenericDecoder
(
VideoDecoder
*
decoder
bool
isExternal
=
false
)
;
~
VCMGenericDecoder
(
)
;
int32_t
InitDecode
(
const
VideoCodec
*
settings
int32_t
numberOfCores
)
;
int32_t
Decode
(
const
VCMEncodedFrame
&
inputFrame
Timestamp
now
)
;
int32_t
RegisterDecodeCompleteCallback
(
VCMDecodedFrameCallback
*
callback
)
;
bool
IsSameDecoder
(
VideoDecoder
*
decoder
)
const
{
return
decoder_
.
get
(
)
=
=
decoder
;
}
private
:
VCMDecodedFrameCallback
*
_callback
;
VCMFrameInformation
_frameInfos
[
kDecoderFrameMemoryLength
]
;
uint32_t
_nextFrameInfoIdx
;
std
:
:
unique_ptr
<
VideoDecoder
>
decoder_
;
VideoCodecType
_codecType
;
const
bool
_isExternal
;
VideoContentType
_last_keyframe_content_type
;
VideoDecoder
:
:
DecoderInfo
decoder_info_
;
}
;
}
#
endif
