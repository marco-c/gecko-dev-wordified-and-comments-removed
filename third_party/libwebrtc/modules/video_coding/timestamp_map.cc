#
include
"
modules
/
video_coding
/
timestamp_map
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
modules
/
include
/
module_common_types_public
.
h
"
namespace
webrtc
{
VCMTimestampMap
:
:
VCMTimestampMap
(
size_t
capacity
)
:
ring_buffer_
(
new
TimestampDataTuple
[
capacity
]
)
capacity_
(
capacity
)
next_add_idx_
(
0
)
next_pop_idx_
(
0
)
{
}
VCMTimestampMap
:
:
~
VCMTimestampMap
(
)
{
}
void
VCMTimestampMap
:
:
Add
(
uint32_t
timestamp
const
VCMFrameInformation
&
data
)
{
ring_buffer_
[
next_add_idx_
]
.
timestamp
=
timestamp
;
ring_buffer_
[
next_add_idx_
]
.
data
=
data
;
next_add_idx_
=
(
next_add_idx_
+
1
)
%
capacity_
;
if
(
next_add_idx_
=
=
next_pop_idx_
)
{
next_pop_idx_
=
(
next_pop_idx_
+
1
)
%
capacity_
;
}
}
absl
:
:
optional
<
VCMFrameInformation
>
VCMTimestampMap
:
:
Pop
(
uint32_t
timestamp
)
{
while
(
!
IsEmpty
(
)
)
{
if
(
ring_buffer_
[
next_pop_idx_
]
.
timestamp
=
=
timestamp
)
{
const
VCMFrameInformation
&
data
=
ring_buffer_
[
next_pop_idx_
]
.
data
;
ring_buffer_
[
next_pop_idx_
]
.
timestamp
=
0
;
next_pop_idx_
=
(
next_pop_idx_
+
1
)
%
capacity_
;
return
data
;
}
else
if
(
IsNewerTimestamp
(
ring_buffer_
[
next_pop_idx_
]
.
timestamp
timestamp
)
)
{
return
absl
:
:
nullopt
;
}
next_pop_idx_
=
(
next_pop_idx_
+
1
)
%
capacity_
;
}
return
absl
:
:
nullopt
;
}
bool
VCMTimestampMap
:
:
IsEmpty
(
)
const
{
return
(
next_add_idx_
=
=
next_pop_idx_
)
;
}
size_t
VCMTimestampMap
:
:
Size
(
)
const
{
return
next_add_idx_
>
=
next_pop_idx_
?
next_add_idx_
-
next_pop_idx_
:
next_add_idx_
+
capacity_
-
next_pop_idx_
;
}
void
VCMTimestampMap
:
:
Clear
(
)
{
while
(
!
IsEmpty
(
)
)
{
ring_buffer_
[
next_pop_idx_
]
.
timestamp
=
0
;
next_pop_idx_
=
(
next_pop_idx_
+
1
)
%
capacity_
;
}
}
}
