#
ifndef
MODULES_VIDEO_CODING_ENCODED_FRAME_H_
#
define
MODULES_VIDEO_CODING_ENCODED_FRAME_H_
#
include
<
vector
>
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_video_header
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_codec_interface
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
webrtc
{
class
RTC_EXPORT
VCMEncodedFrame
:
protected
EncodedImage
{
public
:
VCMEncodedFrame
(
)
;
VCMEncodedFrame
(
const
VCMEncodedFrame
&
)
;
~
VCMEncodedFrame
(
)
;
void
SetRenderTime
(
const
int64_t
renderTimeMs
)
{
_renderTimeMs
=
renderTimeMs
;
}
VideoPlayoutDelay
PlayoutDelay
(
)
const
{
return
playout_delay_
;
}
void
SetPlayoutDelay
(
VideoPlayoutDelay
playout_delay
)
{
playout_delay_
=
playout_delay
;
}
const
webrtc
:
:
EncodedImage
&
EncodedImage
(
)
const
{
return
static_cast
<
const
webrtc
:
:
EncodedImage
&
>
(
*
this
)
;
}
using
EncodedImage
:
:
ColorSpace
;
using
EncodedImage
:
:
data
;
using
EncodedImage
:
:
GetEncodedData
;
using
EncodedImage
:
:
NtpTimeMs
;
using
EncodedImage
:
:
PacketInfos
;
using
EncodedImage
:
:
Retain
;
using
EncodedImage
:
:
set_size
;
using
EncodedImage
:
:
SetColorSpace
;
using
EncodedImage
:
:
SetEncodedData
;
using
EncodedImage
:
:
SetPacketInfos
;
using
EncodedImage
:
:
SetSpatialIndex
;
using
EncodedImage
:
:
SetSpatialLayerFrameSize
;
using
EncodedImage
:
:
SetTimestamp
;
using
EncodedImage
:
:
size
;
using
EncodedImage
:
:
SpatialIndex
;
using
EncodedImage
:
:
SpatialLayerFrameSize
;
using
EncodedImage
:
:
Timestamp
;
int64_t
RenderTimeMs
(
)
const
{
return
_renderTimeMs
;
}
webrtc
:
:
VideoFrameType
FrameType
(
)
const
{
return
_frameType
;
}
void
SetFrameType
(
webrtc
:
:
VideoFrameType
frame_type
)
{
_frameType
=
frame_type
;
}
VideoRotation
rotation
(
)
const
{
return
rotation_
;
}
VideoContentType
contentType
(
)
const
{
return
content_type_
;
}
EncodedImage
:
:
Timing
video_timing
(
)
const
{
return
timing_
;
}
EncodedImage
:
:
Timing
*
video_timing_mutable
(
)
{
return
&
timing_
;
}
bool
Complete
(
)
const
{
return
_completeFrame
;
}
bool
MissingFrame
(
)
const
{
return
_missingFrame
;
}
uint8_t
PayloadType
(
)
const
{
return
_payloadType
;
}
const
CodecSpecificInfo
*
CodecSpecific
(
)
const
{
return
&
_codecSpecificInfo
;
}
void
SetCodecSpecific
(
const
CodecSpecificInfo
*
codec_specific
)
{
_codecSpecificInfo
=
*
codec_specific
;
}
protected
:
void
Reset
(
)
;
void
CopyCodecSpecific
(
const
RTPVideoHeader
*
header
)
;
int64_t
_renderTimeMs
;
uint8_t
_payloadType
;
bool
_missingFrame
;
CodecSpecificInfo
_codecSpecificInfo
;
webrtc
:
:
VideoCodecType
_codec
;
}
;
}
#
endif
