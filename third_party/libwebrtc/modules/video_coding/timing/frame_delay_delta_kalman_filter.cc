#
include
"
modules
/
video_coding
/
timing
/
frame_delay_delta_kalman_filter
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
namespace
webrtc
{
namespace
{
constexpr
double
kThetaLow
=
0
.
000001
;
}
FrameDelayDeltaKalmanFilter
:
:
FrameDelayDeltaKalmanFilter
(
)
{
estimate_
[
0
]
=
1
/
(
512e3
/
8
)
;
estimate_
[
1
]
=
0
;
estimate_cov_
[
0
]
[
0
]
=
1e
-
4
;
estimate_cov_
[
1
]
[
1
]
=
1e2
;
estimate_cov_
[
0
]
[
1
]
=
estimate_cov_
[
1
]
[
0
]
=
0
;
process_noise_cov_diag_
[
0
]
=
2
.
5e
-
10
;
process_noise_cov_diag_
[
1
]
=
1e
-
10
;
}
void
FrameDelayDeltaKalmanFilter
:
:
PredictAndUpdate
(
TimeDelta
frame_delay_variation
double
frame_size_variation_bytes
DataSize
max_frame_size
double
var_noise
)
{
estimate_cov_
[
0
]
[
0
]
+
=
process_noise_cov_diag_
[
0
]
;
estimate_cov_
[
1
]
[
1
]
+
=
process_noise_cov_diag_
[
1
]
;
double
Mh
[
2
]
;
double
hMh_sigma
;
double
kalmanGain
[
2
]
;
double
measureRes
;
double
t00
t01
;
Mh
[
0
]
=
estimate_cov_
[
0
]
[
0
]
*
frame_size_variation_bytes
+
estimate_cov_
[
0
]
[
1
]
;
Mh
[
1
]
=
estimate_cov_
[
1
]
[
0
]
*
frame_size_variation_bytes
+
estimate_cov_
[
1
]
[
1
]
;
if
(
max_frame_size
<
DataSize
:
:
Bytes
(
1
)
)
{
return
;
}
double
sigma
=
(
300
.
0
*
exp
(
-
fabs
(
frame_size_variation_bytes
)
/
(
1e0
*
max_frame_size
.
bytes
(
)
)
)
+
1
)
*
sqrt
(
var_noise
)
;
if
(
sigma
<
1
.
0
)
{
sigma
=
1
.
0
;
}
hMh_sigma
=
frame_size_variation_bytes
*
Mh
[
0
]
+
Mh
[
1
]
+
sigma
;
if
(
(
hMh_sigma
<
1e
-
9
&
&
hMh_sigma
>
=
0
)
|
|
(
hMh_sigma
>
-
1e
-
9
&
&
hMh_sigma
<
=
0
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
kalmanGain
[
0
]
=
Mh
[
0
]
/
hMh_sigma
;
kalmanGain
[
1
]
=
Mh
[
1
]
/
hMh_sigma
;
measureRes
=
frame_delay_variation
.
ms
(
)
-
(
frame_size_variation_bytes
*
estimate_
[
0
]
+
estimate_
[
1
]
)
;
estimate_
[
0
]
+
=
kalmanGain
[
0
]
*
measureRes
;
estimate_
[
1
]
+
=
kalmanGain
[
1
]
*
measureRes
;
if
(
estimate_
[
0
]
<
kThetaLow
)
{
estimate_
[
0
]
=
kThetaLow
;
}
t00
=
estimate_cov_
[
0
]
[
0
]
;
t01
=
estimate_cov_
[
0
]
[
1
]
;
estimate_cov_
[
0
]
[
0
]
=
(
1
-
kalmanGain
[
0
]
*
frame_size_variation_bytes
)
*
t00
-
kalmanGain
[
0
]
*
estimate_cov_
[
1
]
[
0
]
;
estimate_cov_
[
0
]
[
1
]
=
(
1
-
kalmanGain
[
0
]
*
frame_size_variation_bytes
)
*
t01
-
kalmanGain
[
0
]
*
estimate_cov_
[
1
]
[
1
]
;
estimate_cov_
[
1
]
[
0
]
=
estimate_cov_
[
1
]
[
0
]
*
(
1
-
kalmanGain
[
1
]
)
-
kalmanGain
[
1
]
*
frame_size_variation_bytes
*
t00
;
estimate_cov_
[
1
]
[
1
]
=
estimate_cov_
[
1
]
[
1
]
*
(
1
-
kalmanGain
[
1
]
)
-
kalmanGain
[
1
]
*
frame_size_variation_bytes
*
t01
;
RTC_DCHECK
(
estimate_cov_
[
0
]
[
0
]
+
estimate_cov_
[
1
]
[
1
]
>
=
0
&
&
estimate_cov_
[
0
]
[
0
]
*
estimate_cov_
[
1
]
[
1
]
-
estimate_cov_
[
0
]
[
1
]
*
estimate_cov_
[
1
]
[
0
]
>
=
0
&
&
estimate_cov_
[
0
]
[
0
]
>
=
0
)
;
}
double
FrameDelayDeltaKalmanFilter
:
:
GetFrameDelayVariationEstimateSizeBased
(
double
frame_size_variation_bytes
)
const
{
return
estimate_
[
0
]
*
frame_size_variation_bytes
;
}
double
FrameDelayDeltaKalmanFilter
:
:
GetFrameDelayVariationEstimateTotal
(
double
frame_size_variation_bytes
)
const
{
double
frame_transmission_delay_ms
=
GetFrameDelayVariationEstimateSizeBased
(
frame_size_variation_bytes
)
;
double
link_queuing_delay_ms
=
estimate_
[
1
]
;
return
frame_transmission_delay_ms
+
link_queuing_delay_ms
;
}
}
