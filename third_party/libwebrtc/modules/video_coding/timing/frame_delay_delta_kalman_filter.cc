#
include
"
modules
/
video_coding
/
timing
/
frame_delay_delta_kalman_filter
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
namespace
webrtc
{
namespace
{
constexpr
double
kThetaLow
=
0
.
000001
;
}
FrameDelayDeltaKalmanFilter
:
:
FrameDelayDeltaKalmanFilter
(
)
{
Reset
(
)
;
}
void
FrameDelayDeltaKalmanFilter
:
:
Reset
(
)
{
theta_
[
0
]
=
1
/
(
512e3
/
8
)
;
theta_
[
1
]
=
0
;
theta_cov_
[
0
]
[
0
]
=
1e
-
4
;
theta_cov_
[
1
]
[
1
]
=
1e2
;
theta_cov_
[
0
]
[
1
]
=
theta_cov_
[
1
]
[
0
]
=
0
;
q_cov_
[
0
]
[
0
]
=
2
.
5e
-
10
;
q_cov_
[
1
]
[
1
]
=
1e
-
10
;
q_cov_
[
0
]
[
1
]
=
q_cov_
[
1
]
[
0
]
=
0
;
}
void
FrameDelayDeltaKalmanFilter
:
:
KalmanEstimateChannel
(
TimeDelta
frame_delay
double
delta_frame_size_bytes
DataSize
max_frame_size
double
var_noise
)
{
double
Mh
[
2
]
;
double
hMh_sigma
;
double
kalmanGain
[
2
]
;
double
measureRes
;
double
t00
t01
;
theta_cov_
[
0
]
[
0
]
+
=
q_cov_
[
0
]
[
0
]
;
theta_cov_
[
0
]
[
1
]
+
=
q_cov_
[
0
]
[
1
]
;
theta_cov_
[
1
]
[
0
]
+
=
q_cov_
[
1
]
[
0
]
;
theta_cov_
[
1
]
[
1
]
+
=
q_cov_
[
1
]
[
1
]
;
Mh
[
0
]
=
theta_cov_
[
0
]
[
0
]
*
delta_frame_size_bytes
+
theta_cov_
[
0
]
[
1
]
;
Mh
[
1
]
=
theta_cov_
[
1
]
[
0
]
*
delta_frame_size_bytes
+
theta_cov_
[
1
]
[
1
]
;
if
(
max_frame_size
<
DataSize
:
:
Bytes
(
1
)
)
{
return
;
}
double
sigma
=
(
300
.
0
*
exp
(
-
fabs
(
delta_frame_size_bytes
)
/
(
1e0
*
max_frame_size
.
bytes
(
)
)
)
+
1
)
*
sqrt
(
var_noise
)
;
if
(
sigma
<
1
.
0
)
{
sigma
=
1
.
0
;
}
hMh_sigma
=
delta_frame_size_bytes
*
Mh
[
0
]
+
Mh
[
1
]
+
sigma
;
if
(
(
hMh_sigma
<
1e
-
9
&
&
hMh_sigma
>
=
0
)
|
|
(
hMh_sigma
>
-
1e
-
9
&
&
hMh_sigma
<
=
0
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
kalmanGain
[
0
]
=
Mh
[
0
]
/
hMh_sigma
;
kalmanGain
[
1
]
=
Mh
[
1
]
/
hMh_sigma
;
measureRes
=
frame_delay
.
ms
(
)
-
(
delta_frame_size_bytes
*
theta_
[
0
]
+
theta_
[
1
]
)
;
theta_
[
0
]
+
=
kalmanGain
[
0
]
*
measureRes
;
theta_
[
1
]
+
=
kalmanGain
[
1
]
*
measureRes
;
if
(
theta_
[
0
]
<
kThetaLow
)
{
theta_
[
0
]
=
kThetaLow
;
}
t00
=
theta_cov_
[
0
]
[
0
]
;
t01
=
theta_cov_
[
0
]
[
1
]
;
theta_cov_
[
0
]
[
0
]
=
(
1
-
kalmanGain
[
0
]
*
delta_frame_size_bytes
)
*
t00
-
kalmanGain
[
0
]
*
theta_cov_
[
1
]
[
0
]
;
theta_cov_
[
0
]
[
1
]
=
(
1
-
kalmanGain
[
0
]
*
delta_frame_size_bytes
)
*
t01
-
kalmanGain
[
0
]
*
theta_cov_
[
1
]
[
1
]
;
theta_cov_
[
1
]
[
0
]
=
theta_cov_
[
1
]
[
0
]
*
(
1
-
kalmanGain
[
1
]
)
-
kalmanGain
[
1
]
*
delta_frame_size_bytes
*
t00
;
theta_cov_
[
1
]
[
1
]
=
theta_cov_
[
1
]
[
1
]
*
(
1
-
kalmanGain
[
1
]
)
-
kalmanGain
[
1
]
*
delta_frame_size_bytes
*
t01
;
RTC_DCHECK
(
theta_cov_
[
0
]
[
0
]
+
theta_cov_
[
1
]
[
1
]
>
=
0
&
&
theta_cov_
[
0
]
[
0
]
*
theta_cov_
[
1
]
[
1
]
-
theta_cov_
[
0
]
[
1
]
*
theta_cov_
[
1
]
[
0
]
>
=
0
&
&
theta_cov_
[
0
]
[
0
]
>
=
0
)
;
}
double
FrameDelayDeltaKalmanFilter
:
:
DeviationFromExpectedDelay
(
TimeDelta
frame_delay
double
delta_frame_size_bytes
)
const
{
return
frame_delay
.
ms
(
)
-
(
theta_
[
0
]
*
delta_frame_size_bytes
+
theta_
[
1
]
)
;
}
double
FrameDelayDeltaKalmanFilter
:
:
GetSlope
(
)
const
{
return
theta_
[
0
]
;
}
}
