#
include
"
modules
/
video_coding
/
timing
/
jitter_estimator
.
h
"
#
include
<
math
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
frequency
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
video_coding
/
timing
/
rtt_filter
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
{
static
constexpr
uint32_t
kStartupDelaySamples
=
30
;
static
constexpr
int64_t
kFsAccuStartupSamples
=
5
;
static
constexpr
Frequency
kMaxFramerateEstimate
=
Frequency
:
:
Hertz
(
200
)
;
static
constexpr
TimeDelta
kNackCountTimeout
=
TimeDelta
:
:
Seconds
(
60
)
;
static
constexpr
double
kDefaultMaxTimestampDeviationInSigmas
=
3
.
5
;
static
constexpr
double
kDefaultAvgAndMaxFrameSize
=
500
;
constexpr
double
kPhi
=
0
.
97
;
constexpr
double
kPsi
=
0
.
9999
;
constexpr
uint32_t
kAlphaCountMax
=
400
;
constexpr
uint32_t
kNackLimit
=
3
;
constexpr
int32_t
kNumStdDevDelayOutlier
=
15
;
constexpr
int32_t
kNumStdDevFrameSizeOutlier
=
3
;
constexpr
double
kNoiseStdDevs
=
2
.
33
;
constexpr
double
kNoiseStdDevOffset
=
30
.
0
;
}
JitterEstimator
:
:
JitterEstimator
(
Clock
*
clock
const
FieldTrialsView
&
field_trials
)
:
fps_counter_
(
30
)
clock_
(
clock
)
{
Reset
(
)
;
}
JitterEstimator
:
:
~
JitterEstimator
(
)
=
default
;
void
JitterEstimator
:
:
Reset
(
)
{
avg_frame_size_bytes_
=
kDefaultAvgAndMaxFrameSize
;
max_frame_size_bytes_
=
kDefaultAvgAndMaxFrameSize
;
var_frame_size_bytes2_
=
100
;
last_update_time_
=
absl
:
:
nullopt
;
prev_estimate_
=
absl
:
:
nullopt
;
prev_frame_size_
=
absl
:
:
nullopt
;
avg_noise_ms_
=
0
.
0
;
var_noise_ms2_
=
4
.
0
;
alpha_count_
=
1
;
filter_jitter_estimate_
=
TimeDelta
:
:
Zero
(
)
;
latest_nack_
=
Timestamp
:
:
Zero
(
)
;
nack_count_
=
0
;
startup_frame_size_sum_bytes_
=
0
;
startup_frame_size_count_
=
0
;
startup_count_
=
0
;
rtt_filter_
.
Reset
(
)
;
fps_counter_
.
Reset
(
)
;
kalman_filter_
=
FrameDelayVariationKalmanFilter
(
)
;
}
void
JitterEstimator
:
:
UpdateEstimate
(
TimeDelta
frame_delay
DataSize
frame_size
)
{
if
(
frame_size
.
IsZero
(
)
)
{
return
;
}
double
delta_frame_bytes
=
frame_size
.
bytes
(
)
-
prev_frame_size_
.
value_or
(
DataSize
:
:
Zero
(
)
)
.
bytes
(
)
;
if
(
startup_frame_size_count_
<
kFsAccuStartupSamples
)
{
startup_frame_size_sum_bytes_
+
=
frame_size
.
bytes
(
)
;
startup_frame_size_count_
+
+
;
}
else
if
(
startup_frame_size_count_
=
=
kFsAccuStartupSamples
)
{
avg_frame_size_bytes_
=
startup_frame_size_sum_bytes_
/
static_cast
<
double
>
(
startup_frame_size_count_
)
;
startup_frame_size_count_
+
+
;
}
double
avg_frame_size_bytes
=
kPhi
*
avg_frame_size_bytes_
+
(
1
-
kPhi
)
*
frame_size
.
bytes
(
)
;
double
deviation_size_bytes
=
2
*
sqrt
(
var_frame_size_bytes2_
)
;
if
(
frame_size
.
bytes
(
)
<
avg_frame_size_bytes_
+
deviation_size_bytes
)
{
avg_frame_size_bytes_
=
avg_frame_size_bytes
;
}
double
delta_bytes
=
frame_size
.
bytes
(
)
-
avg_frame_size_bytes
;
var_frame_size_bytes2_
=
std
:
:
max
(
kPhi
*
var_frame_size_bytes2_
+
(
1
-
kPhi
)
*
(
delta_bytes
*
delta_bytes
)
1
.
0
)
;
max_frame_size_bytes_
=
std
:
:
max
<
double
>
(
kPsi
*
max_frame_size_bytes_
frame_size
.
bytes
(
)
)
;
if
(
!
prev_frame_size_
)
{
prev_frame_size_
=
frame_size
;
return
;
}
prev_frame_size_
=
frame_size
;
TimeDelta
max_time_deviation
=
TimeDelta
:
:
Millis
(
kDefaultMaxTimestampDeviationInSigmas
*
sqrt
(
var_noise_ms2_
)
+
0
.
5
)
;
frame_delay
.
Clamp
(
-
max_time_deviation
max_time_deviation
)
;
double
deviation_ms
=
frame_delay
.
ms
(
)
-
kalman_filter_
.
GetFrameDelayVariationEstimateTotal
(
delta_frame_bytes
)
;
if
(
fabs
(
deviation_ms
)
<
kNumStdDevDelayOutlier
*
sqrt
(
var_noise_ms2_
)
|
|
frame_size
.
bytes
(
)
>
avg_frame_size_bytes_
+
kNumStdDevFrameSizeOutlier
*
sqrt
(
var_frame_size_bytes2_
)
)
{
EstimateRandomJitter
(
deviation_ms
)
;
if
(
delta_frame_bytes
>
-
0
.
25
*
max_frame_size_bytes_
)
{
kalman_filter_
.
PredictAndUpdate
(
frame_delay
.
ms
(
)
delta_frame_bytes
max_frame_size_bytes_
var_noise_ms2_
)
;
}
}
else
{
int
nStdDev
=
(
deviation_ms
>
=
0
)
?
kNumStdDevDelayOutlier
:
-
kNumStdDevDelayOutlier
;
EstimateRandomJitter
(
nStdDev
*
sqrt
(
var_noise_ms2_
)
)
;
}
if
(
startup_count_
>
=
kStartupDelaySamples
)
{
PostProcessEstimate
(
)
;
}
else
{
startup_count_
+
+
;
}
}
void
JitterEstimator
:
:
FrameNacked
(
)
{
if
(
nack_count_
<
kNackLimit
)
{
nack_count_
+
+
;
}
latest_nack_
=
clock_
-
>
CurrentTime
(
)
;
}
void
JitterEstimator
:
:
EstimateRandomJitter
(
double
d_dT
)
{
Timestamp
now
=
clock_
-
>
CurrentTime
(
)
;
if
(
last_update_time_
.
has_value
(
)
)
{
fps_counter_
.
AddSample
(
(
now
-
*
last_update_time_
)
.
us
(
)
)
;
}
last_update_time_
=
now
;
if
(
alpha_count_
=
=
0
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
double
alpha
=
static_cast
<
double
>
(
alpha_count_
-
1
)
/
static_cast
<
double
>
(
alpha_count_
)
;
alpha_count_
+
+
;
if
(
alpha_count_
>
kAlphaCountMax
)
alpha_count_
=
kAlphaCountMax
;
Frequency
fps
=
GetFrameRate
(
)
;
if
(
fps
>
Frequency
:
:
Zero
(
)
)
{
constexpr
Frequency
k30Fps
=
Frequency
:
:
Hertz
(
30
)
;
double
rate_scale
=
k30Fps
/
fps
;
if
(
alpha_count_
<
kStartupDelaySamples
)
{
rate_scale
=
(
alpha_count_
*
rate_scale
+
(
kStartupDelaySamples
-
alpha_count_
)
)
/
kStartupDelaySamples
;
}
alpha
=
pow
(
alpha
rate_scale
)
;
}
double
avg_noise_ms
=
alpha
*
avg_noise_ms_
+
(
1
-
alpha
)
*
d_dT
;
double
var_noise_ms2
=
alpha
*
var_noise_ms2_
+
(
1
-
alpha
)
*
(
d_dT
-
avg_noise_ms_
)
*
(
d_dT
-
avg_noise_ms_
)
;
avg_noise_ms_
=
avg_noise_ms
;
var_noise_ms2_
=
var_noise_ms2
;
if
(
var_noise_ms2_
<
1
.
0
)
{
var_noise_ms2_
=
1
.
0
;
}
}
double
JitterEstimator
:
:
NoiseThreshold
(
)
const
{
double
noise_threshold_ms
=
kNoiseStdDevs
*
sqrt
(
var_noise_ms2_
)
-
kNoiseStdDevOffset
;
if
(
noise_threshold_ms
<
1
.
0
)
{
noise_threshold_ms
=
1
.
0
;
}
return
noise_threshold_ms
;
}
TimeDelta
JitterEstimator
:
:
CalculateEstimate
(
)
{
double
retMs
=
kalman_filter_
.
GetFrameDelayVariationEstimateSizeBased
(
max_frame_size_bytes_
-
avg_frame_size_bytes_
)
+
NoiseThreshold
(
)
;
TimeDelta
ret
=
TimeDelta
:
:
Millis
(
retMs
)
;
constexpr
TimeDelta
kMinEstimate
=
TimeDelta
:
:
Millis
(
1
)
;
constexpr
TimeDelta
kMaxEstimate
=
TimeDelta
:
:
Seconds
(
10
)
;
if
(
ret
<
kMinEstimate
)
{
ret
=
prev_estimate_
.
value_or
(
kMinEstimate
)
;
RTC_DCHECK_GE
(
ret
kMinEstimate
)
;
}
else
if
(
ret
>
kMaxEstimate
)
{
ret
=
kMaxEstimate
;
}
prev_estimate_
=
ret
;
return
ret
;
}
void
JitterEstimator
:
:
PostProcessEstimate
(
)
{
filter_jitter_estimate_
=
CalculateEstimate
(
)
;
}
void
JitterEstimator
:
:
UpdateRtt
(
TimeDelta
rtt
)
{
rtt_filter_
.
Update
(
rtt
)
;
}
TimeDelta
JitterEstimator
:
:
GetJitterEstimate
(
double
rtt_multiplier
absl
:
:
optional
<
TimeDelta
>
rtt_mult_add_cap
)
{
TimeDelta
jitter
=
CalculateEstimate
(
)
+
OPERATING_SYSTEM_JITTER
;
Timestamp
now
=
clock_
-
>
CurrentTime
(
)
;
if
(
now
-
latest_nack_
>
kNackCountTimeout
)
nack_count_
=
0
;
if
(
filter_jitter_estimate_
>
jitter
)
jitter
=
filter_jitter_estimate_
;
if
(
nack_count_
>
=
kNackLimit
)
{
if
(
rtt_mult_add_cap
.
has_value
(
)
)
{
jitter
+
=
std
:
:
min
(
rtt_filter_
.
Rtt
(
)
*
rtt_multiplier
rtt_mult_add_cap
.
value
(
)
)
;
}
else
{
jitter
+
=
rtt_filter_
.
Rtt
(
)
*
rtt_multiplier
;
}
}
static
const
Frequency
kJitterScaleLowThreshold
=
Frequency
:
:
Hertz
(
5
)
;
static
const
Frequency
kJitterScaleHighThreshold
=
Frequency
:
:
Hertz
(
10
)
;
Frequency
fps
=
GetFrameRate
(
)
;
if
(
fps
<
kJitterScaleLowThreshold
)
{
if
(
fps
.
IsZero
(
)
)
{
return
std
:
:
max
(
TimeDelta
:
:
Zero
(
)
jitter
)
;
}
return
TimeDelta
:
:
Zero
(
)
;
}
if
(
fps
<
kJitterScaleHighThreshold
)
{
jitter
=
(
1
.
0
/
(
kJitterScaleHighThreshold
-
kJitterScaleLowThreshold
)
)
*
(
fps
-
kJitterScaleLowThreshold
)
*
jitter
;
}
return
std
:
:
max
(
TimeDelta
:
:
Zero
(
)
jitter
)
;
}
Frequency
JitterEstimator
:
:
GetFrameRate
(
)
const
{
TimeDelta
mean_frame_period
=
TimeDelta
:
:
Micros
(
fps_counter_
.
ComputeMean
(
)
)
;
if
(
mean_frame_period
<
=
TimeDelta
:
:
Zero
(
)
)
return
Frequency
:
:
Zero
(
)
;
Frequency
fps
=
1
/
mean_frame_period
;
RTC_DCHECK_GE
(
fps
Frequency
:
:
Zero
(
)
)
;
return
std
:
:
min
(
fps
kMaxFramerateEstimate
)
;
}
}
