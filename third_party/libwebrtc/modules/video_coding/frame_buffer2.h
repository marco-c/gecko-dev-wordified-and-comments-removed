#
ifndef
MODULES_VIDEO_CODING_FRAME_BUFFER2_H_
#
define
MODULES_VIDEO_CODING_FRAME_BUFFER2_H_
#
include
<
array
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
container
/
inlined_vector
.
h
"
#
include
"
api
/
video
/
encoded_frame
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
modules
/
video_coding
/
inter_frame_delay
.
h
"
#
include
"
modules
/
video_coding
/
jitter_estimator
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
decoded_frames_history
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
experiments
/
rtt_mult_experiment
.
h
"
#
include
"
rtc_base
/
numerics
/
sequence_number_util
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
synchronization
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
task_utils
/
repeating_task
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
Clock
;
class
VCMReceiveStatisticsCallback
;
class
VCMJitterEstimator
;
class
VCMTiming
;
namespace
video_coding
{
class
FrameBuffer
{
public
:
enum
ReturnReason
{
kFrameFound
kTimeout
kStopped
}
;
FrameBuffer
(
Clock
*
clock
VCMTiming
*
timing
VCMReceiveStatisticsCallback
*
stats_callback
)
;
FrameBuffer
(
)
=
delete
;
FrameBuffer
(
const
FrameBuffer
&
)
=
delete
;
FrameBuffer
&
operator
=
(
const
FrameBuffer
&
)
=
delete
;
virtual
~
FrameBuffer
(
)
;
int64_t
InsertFrame
(
std
:
:
unique_ptr
<
EncodedFrame
>
frame
)
;
void
NextFrame
(
int64_t
max_wait_time_ms
bool
keyframe_required
rtc
:
:
TaskQueue
*
callback_queue
std
:
:
function
<
void
(
std
:
:
unique_ptr
<
EncodedFrame
>
ReturnReason
)
>
handler
)
;
void
SetProtectionMode
(
VCMVideoProtection
mode
)
;
void
Start
(
)
;
void
Stop
(
)
;
void
UpdateRtt
(
int64_t
rtt_ms
)
;
void
Clear
(
)
;
private
:
struct
FrameInfo
{
FrameInfo
(
)
;
FrameInfo
(
FrameInfo
&
&
)
;
~
FrameInfo
(
)
;
absl
:
:
InlinedVector
<
VideoLayerFrameId
8
>
dependent_frames
;
size_t
num_missing_continuous
=
0
;
size_t
num_missing_decodable
=
0
;
bool
continuous
=
false
;
std
:
:
unique_ptr
<
EncodedFrame
>
frame
;
}
;
using
FrameMap
=
std
:
:
map
<
VideoLayerFrameId
FrameInfo
>
;
bool
ValidReferences
(
const
EncodedFrame
&
frame
)
const
;
int64_t
FindNextFrame
(
int64_t
now_ms
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
EncodedFrame
*
GetNextFrame
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
StartWaitForNextFrameOnQueue
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
CancelCallback
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
PropagateContinuity
(
FrameMap
:
:
iterator
start
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
PropagateDecodability
(
const
FrameInfo
&
info
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
bool
UpdateFrameInfoWithIncomingFrame
(
const
EncodedFrame
&
frame
FrameMap
:
:
iterator
info
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
UpdateJitterDelay
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
UpdateTimingFrameInfo
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
ClearFramesAndHistory
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
bool
IsCompleteSuperFrame
(
const
EncodedFrame
&
frame
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
bool
HasBadRenderTiming
(
const
EncodedFrame
&
frame
int64_t
now_ms
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
EncodedFrame
*
CombineAndDeleteFrames
(
const
std
:
:
vector
<
EncodedFrame
*
>
&
frames
)
const
;
SequenceChecker
construction_checker_
;
SequenceChecker
callback_checker_
;
FrameMap
frames_
RTC_GUARDED_BY
(
mutex_
)
;
DecodedFramesHistory
decoded_frames_history_
RTC_GUARDED_BY
(
mutex_
)
;
Mutex
mutex_
;
Clock
*
const
clock_
;
rtc
:
:
TaskQueue
*
callback_queue_
RTC_GUARDED_BY
(
mutex_
)
;
RepeatingTaskHandle
callback_task_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
function
<
void
(
std
:
:
unique_ptr
<
EncodedFrame
>
ReturnReason
)
>
frame_handler_
RTC_GUARDED_BY
(
mutex_
)
;
int64_t
latest_return_time_ms_
RTC_GUARDED_BY
(
mutex_
)
;
bool
keyframe_required_
RTC_GUARDED_BY
(
mutex_
)
;
VCMJitterEstimator
jitter_estimator_
RTC_GUARDED_BY
(
mutex_
)
;
VCMTiming
*
const
timing_
RTC_GUARDED_BY
(
mutex_
)
;
VCMInterFrameDelay
inter_frame_delay_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
VideoLayerFrameId
>
last_continuous_frame_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
vector
<
FrameMap
:
:
iterator
>
frames_to_decode_
RTC_GUARDED_BY
(
mutex_
)
;
bool
stopped_
RTC_GUARDED_BY
(
mutex_
)
;
VCMVideoProtection
protection_mode_
RTC_GUARDED_BY
(
mutex_
)
;
VCMReceiveStatisticsCallback
*
const
stats_callback_
;
int64_t
last_log_non_decoded_ms_
RTC_GUARDED_BY
(
mutex_
)
;
const
bool
add_rtt_to_playout_delay_
;
const
absl
:
:
optional
<
RttMultExperiment
:
:
Settings
>
rtt_mult_settings_
;
}
;
}
}
#
endif
