#
include
"
modules
/
video_coding
/
inter_frame_delay
.
h
"
#
include
<
limits
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
units
/
frequency
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
constexpr
Frequency
k30Fps
=
Frequency
:
:
Hertz
(
30
)
;
constexpr
TimeDelta
kFrameDelay
=
1
/
k30Fps
;
constexpr
uint32_t
kRtpTicksPerFrame
=
Frequency
:
:
KiloHertz
(
90
)
/
k30Fps
;
constexpr
Timestamp
kStartTime
=
Timestamp
:
:
Millis
(
1337
)
;
}
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
Optional
;
TEST
(
InterFrameDelayTest
OldRtpTimestamp
)
{
VCMInterFrameDelay
inter_frame_delay
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
180000
kStartTime
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
90000
kStartTime
)
Eq
(
absl
:
:
nullopt
)
)
;
}
TEST
(
InterFrameDelayTest
NegativeWrapAroundIsSameAsOldRtpTimestamp
)
{
VCMInterFrameDelay
inter_frame_delay
;
uint32_t
rtp
=
1500
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
kStartTime
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
-
=
3000
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
kStartTime
)
Eq
(
absl
:
:
nullopt
)
)
;
}
TEST
(
InterFrameDelayTest
CorrectDelayForFrames
)
{
VCMInterFrameDelay
inter_frame_delay
;
SimulatedClock
clock
(
kStartTime
)
;
uint32_t
rtp
=
90000
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
clock
.
AdvanceTime
(
kFrameDelay
)
;
rtp
+
=
kRtpTicksPerFrame
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
clock
.
AdvanceTime
(
kFrameDelay
-
TimeDelta
:
:
Millis
(
3
)
)
;
rtp
+
=
kRtpTicksPerFrame
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
-
TimeDelta
:
:
Millis
(
3
)
)
)
;
clock
.
AdvanceTime
(
kFrameDelay
+
TimeDelta
:
:
Micros
(
5125
)
)
;
rtp
+
=
kRtpTicksPerFrame
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Micros
(
5125
)
)
)
;
clock
.
AdvanceTime
(
kFrameDelay
)
;
rtp
+
=
kRtpTicksPerFrame
/
2
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
kFrameDelay
/
2
.
0
)
)
;
clock
.
AdvanceTime
(
kFrameDelay
)
;
rtp
+
=
1
.
5
*
kRtpTicksPerFrame
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
-
kFrameDelay
/
2
.
0
)
)
;
}
TEST
(
InterFrameDelayTest
PositiveWrapAround
)
{
VCMInterFrameDelay
inter_frame_delay
;
SimulatedClock
clock
(
kStartTime
)
;
uint32_t
rtp
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
1500
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
+
=
kRtpTicksPerFrame
;
clock
.
AdvanceTime
(
kFrameDelay
+
TimeDelta
:
:
Millis
(
1
)
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Millis
(
1
)
)
)
;
}
TEST
(
InterFrameDelayTest
MultipleWrapArounds
)
{
constexpr
Frequency
k90Khz
=
Frequency
:
:
KiloHertz
(
90
)
;
constexpr
uint32_t
kHalfRtp
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
/
2
;
constexpr
TimeDelta
kWrapAroundDelay
=
kHalfRtp
/
k90Khz
;
VCMInterFrameDelay
inter_frame_delay
;
SimulatedClock
clock
(
kStartTime
)
;
uint32_t
rtp
=
0
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
+
=
kHalfRtp
;
clock
.
AdvanceTime
(
kWrapAroundDelay
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
+
=
kHalfRtp
+
1
;
clock
.
AdvanceTime
(
kWrapAroundDelay
+
TimeDelta
:
:
Millis
(
1
)
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Millis
(
1
)
-
(
1
/
k90Khz
)
)
)
;
rtp
+
=
kHalfRtp
;
clock
.
AdvanceTime
(
kWrapAroundDelay
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
+
=
kHalfRtp
+
1
;
clock
.
AdvanceTime
(
kWrapAroundDelay
-
TimeDelta
:
:
Millis
(
1
)
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
-
TimeDelta
:
:
Millis
(
1
)
-
(
1
/
k90Khz
)
)
)
;
rtp
+
=
kHalfRtp
;
clock
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
-
(
kWrapAroundDelay
-
TimeDelta
:
:
Millis
(
10
)
)
)
)
;
rtp
+
=
kHalfRtp
+
1
;
clock
.
AdvanceTime
(
TimeDelta
:
:
Millis
(
10
)
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
-
(
kWrapAroundDelay
-
TimeDelta
:
:
Millis
(
10
)
+
(
1
/
k90Khz
)
)
)
)
;
}
TEST
(
InterFrameDelayTest
NegativeWrapAroundAfterPositiveWrapAround
)
{
VCMInterFrameDelay
inter_frame_delay
;
SimulatedClock
clock
(
kStartTime
)
;
uint32_t
rtp
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
-
1500
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
+
=
kRtpTicksPerFrame
;
clock
.
AdvanceTime
(
kFrameDelay
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Optional
(
TimeDelta
:
:
Zero
(
)
)
)
;
rtp
-
=
kRtpTicksPerFrame
;
clock
.
AdvanceTime
(
kFrameDelay
)
;
EXPECT_THAT
(
inter_frame_delay
.
CalculateDelay
(
rtp
clock
.
CurrentTime
(
)
)
Eq
(
absl
:
:
nullopt
)
)
;
}
}
