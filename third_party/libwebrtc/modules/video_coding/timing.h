#
ifndef
MODULES_VIDEO_CODING_TIMING_H_
#
define
MODULES_VIDEO_CODING_TIMING_H_
#
include
<
memory
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
video
/
video_timing
.
h
"
#
include
"
modules
/
video_coding
/
codec_timer
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
time
/
timestamp_extrapolator
.
h
"
namespace
webrtc
{
class
Clock
;
class
TimestampExtrapolator
;
class
VCMTiming
{
public
:
explicit
VCMTiming
(
Clock
*
clock
)
;
virtual
~
VCMTiming
(
)
=
default
;
void
Reset
(
)
;
void
set_render_delay
(
int
render_delay_ms
)
;
void
SetJitterDelay
(
int
required_delay_ms
)
;
void
set_min_playout_delay
(
int
min_playout_delay_ms
)
;
int
min_playout_delay
(
)
;
void
set_max_playout_delay
(
int
max_playout_delay_ms
)
;
int
max_playout_delay
(
)
;
void
UpdateCurrentDelay
(
uint32_t
frame_timestamp
)
;
void
UpdateCurrentDelay
(
int64_t
render_time_ms
int64_t
actual_decode_time_ms
)
;
void
StopDecodeTimer
(
int32_t
decode_time_ms
int64_t
now_ms
)
;
void
StopDecodeTimer
(
uint32_t
time_stamp
int32_t
decode_time_ms
int64_t
now_ms
int64_t
render_time_ms
)
;
void
IncomingTimestamp
(
uint32_t
time_stamp
int64_t
last_packet_time_ms
)
;
virtual
int64_t
RenderTimeMs
(
uint32_t
frame_timestamp
int64_t
now_ms
)
const
;
virtual
int64_t
MaxWaitingTime
(
int64_t
render_time_ms
int64_t
now_ms
)
;
int
TargetVideoDelay
(
)
const
;
virtual
bool
GetTimings
(
int
*
max_decode_ms
int
*
current_delay_ms
int
*
target_delay_ms
int
*
jitter_buffer_ms
int
*
min_playout_delay_ms
int
*
render_delay_ms
)
const
;
void
SetTimingFrameInfo
(
const
TimingFrameInfo
&
info
)
;
absl
:
:
optional
<
TimingFrameInfo
>
GetTimingFrameInfo
(
)
;
void
SetMaxCompositionDelayInFrames
(
absl
:
:
optional
<
int
>
max_composition_delay_in_frames
)
;
absl
:
:
optional
<
int
>
MaxCompositionDelayInFrames
(
)
const
;
enum
{
kDefaultRenderDelayMs
=
10
}
;
enum
{
kDelayMaxChangeMsPerS
=
100
}
;
protected
:
int
RequiredDecodeTimeMs
(
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
int64_t
RenderTimeMsInternal
(
uint32_t
frame_timestamp
int64_t
now_ms
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
int
TargetDelayInternal
(
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
private
:
mutable
Mutex
mutex_
;
Clock
*
const
clock_
;
const
std
:
:
unique_ptr
<
TimestampExtrapolator
>
ts_extrapolator_
RTC_PT_GUARDED_BY
(
mutex_
)
;
std
:
:
unique_ptr
<
VCMCodecTimer
>
codec_timer_
RTC_GUARDED_BY
(
mutex_
)
RTC_PT_GUARDED_BY
(
mutex_
)
;
int
render_delay_ms_
RTC_GUARDED_BY
(
mutex_
)
;
int
min_playout_delay_ms_
RTC_GUARDED_BY
(
mutex_
)
;
int
max_playout_delay_ms_
RTC_GUARDED_BY
(
mutex_
)
;
int
jitter_delay_ms_
RTC_GUARDED_BY
(
mutex_
)
;
int
current_delay_ms_
RTC_GUARDED_BY
(
mutex_
)
;
uint32_t
prev_frame_timestamp_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
TimingFrameInfo
>
timing_frame_info_
RTC_GUARDED_BY
(
mutex_
)
;
size_t
num_decoded_frames_
RTC_GUARDED_BY
(
mutex_
)
;
FieldTrialParameter
<
bool
>
low_latency_renderer_enabled_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
int
>
max_composition_delay_in_frames_
RTC_GUARDED_BY
(
mutex_
)
;
FieldTrialParameter
<
TimeDelta
>
zero_playout_delay_min_pacing_
RTC_GUARDED_BY
(
mutex_
)
;
int64_t
earliest_next_decode_start_time_
RTC_GUARDED_BY
(
mutex_
)
;
}
;
}
#
endif
