#
include
"
modules
/
video_coding
/
jitter_estimator
.
h
"
#
include
<
math
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
frequency
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
video_coding
/
rtt_filter
.
h
"
#
include
"
rtc_base
/
experiments
/
jitter_upper_bound_experiment
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
namespace
webrtc
{
namespace
{
static
constexpr
uint32_t
kStartupDelaySamples
=
30
;
static
constexpr
int64_t
kFsAccuStartupSamples
=
5
;
static
constexpr
Frequency
kMaxFramerateEstimate
=
Frequency
:
:
Hertz
(
200
)
;
static
constexpr
TimeDelta
kNackCountTimeout
=
TimeDelta
:
:
Seconds
(
60
)
;
static
constexpr
double
kDefaultMaxTimestampDeviationInSigmas
=
3
.
5
;
constexpr
double
kPhi
=
0
.
97
;
constexpr
double
kPsi
=
0
.
9999
;
constexpr
uint32_t
kAlphaCountMax
=
400
;
constexpr
double
kThetaLow
=
0
.
000001
;
constexpr
uint32_t
kNackLimit
=
3
;
constexpr
int32_t
kNumStdDevDelayOutlier
=
15
;
constexpr
int32_t
kNumStdDevFrameSizeOutlier
=
3
;
constexpr
double
kNoiseStdDevs
=
2
.
33
;
constexpr
double
kNoiseStdDevOffset
=
30
.
0
;
}
VCMJitterEstimator
:
:
VCMJitterEstimator
(
Clock
*
clock
)
:
fps_counter_
(
30
)
time_deviation_upper_bound_
(
JitterUpperBoundExperiment
:
:
GetUpperBoundSigmas
(
)
.
value_or
(
kDefaultMaxTimestampDeviationInSigmas
)
)
enable_reduced_delay_
(
!
field_trial
:
:
IsEnabled
(
"
WebRTC
-
ReducedJitterDelayKillSwitch
"
)
)
clock_
(
clock
)
{
Reset
(
)
;
}
VCMJitterEstimator
:
:
~
VCMJitterEstimator
(
)
=
default
;
void
VCMJitterEstimator
:
:
Reset
(
)
{
theta_
[
0
]
=
1
/
(
512e3
/
8
)
;
theta_
[
1
]
=
0
;
var_noise_
=
4
.
0
;
theta_cov_
[
0
]
[
0
]
=
1e
-
4
;
theta_cov_
[
1
]
[
1
]
=
1e2
;
theta_cov_
[
0
]
[
1
]
=
theta_cov_
[
1
]
[
0
]
=
0
;
q_cov_
[
0
]
[
0
]
=
2
.
5e
-
10
;
q_cov_
[
1
]
[
1
]
=
1e
-
10
;
q_cov_
[
0
]
[
1
]
=
q_cov_
[
1
]
[
0
]
=
0
;
avg_frame_size_
=
kDefaultAvgAndMaxFrameSize
;
max_frame_size_
=
kDefaultAvgAndMaxFrameSize
;
var_frame_size_
=
100
;
last_update_time_
=
absl
:
:
nullopt
;
prev_estimate_
=
absl
:
:
nullopt
;
prev_frame_size_
=
absl
:
:
nullopt
;
avg_noise_
=
0
.
0
;
alpha_count_
=
1
;
filter_jitter_estimate_
=
TimeDelta
:
:
Zero
(
)
;
latest_nack_
=
Timestamp
:
:
Zero
(
)
;
nack_count_
=
0
;
frame_size_sum_
=
DataSize
:
:
Zero
(
)
;
frame_size_count_
=
0
;
startup_count_
=
0
;
rtt_filter_
.
Reset
(
)
;
fps_counter_
.
Reset
(
)
;
}
void
VCMJitterEstimator
:
:
UpdateEstimate
(
TimeDelta
frame_delay
DataSize
frame_size
bool
incomplete_frame
)
{
if
(
frame_size
.
IsZero
(
)
)
{
return
;
}
double
delta_frame_bytes
=
frame_size
.
bytes
(
)
-
prev_frame_size_
.
value_or
(
DataSize
:
:
Zero
(
)
)
.
bytes
(
)
;
if
(
frame_size_count_
<
kFsAccuStartupSamples
)
{
frame_size_sum_
+
=
frame_size
;
frame_size_count_
+
+
;
}
else
if
(
frame_size_count_
=
=
kFsAccuStartupSamples
)
{
avg_frame_size_
=
frame_size_sum_
/
static_cast
<
double
>
(
frame_size_count_
)
;
frame_size_count_
+
+
;
}
if
(
!
incomplete_frame
|
|
frame_size
>
avg_frame_size_
)
{
DataSize
avg_frame_size
=
kPhi
*
avg_frame_size_
+
(
1
-
kPhi
)
*
frame_size
;
DataSize
deviation_size
=
DataSize
:
:
Bytes
(
2
*
sqrt
(
var_frame_size_
)
)
;
if
(
frame_size
<
avg_frame_size_
+
deviation_size
)
{
avg_frame_size_
=
avg_frame_size
;
}
double
delta_bytes
=
frame_size
.
bytes
(
)
-
avg_frame_size
.
bytes
(
)
;
var_frame_size_
=
std
:
:
max
(
kPhi
*
var_frame_size_
+
(
1
-
kPhi
)
*
(
delta_bytes
*
delta_bytes
)
1
.
0
)
;
}
max_frame_size_
=
std
:
:
max
(
kPsi
*
max_frame_size_
frame_size
)
;
if
(
!
prev_frame_size_
)
{
prev_frame_size_
=
frame_size
;
return
;
}
prev_frame_size_
=
frame_size
;
TimeDelta
max_time_deviation
=
TimeDelta
:
:
Millis
(
time_deviation_upper_bound_
*
sqrt
(
var_noise_
)
+
0
.
5
)
;
frame_delay
.
Clamp
(
-
max_time_deviation
max_time_deviation
)
;
double
deviation
=
DeviationFromExpectedDelay
(
frame_delay
delta_frame_bytes
)
;
if
(
fabs
(
deviation
)
<
kNumStdDevDelayOutlier
*
sqrt
(
var_noise_
)
|
|
frame_size
.
bytes
(
)
>
avg_frame_size_
.
bytes
(
)
+
kNumStdDevFrameSizeOutlier
*
sqrt
(
var_frame_size_
)
)
{
EstimateRandomJitter
(
deviation
incomplete_frame
)
;
if
(
(
!
incomplete_frame
|
|
deviation
>
=
0
)
&
&
delta_frame_bytes
>
-
0
.
25
*
max_frame_size_
.
bytes
(
)
)
{
KalmanEstimateChannel
(
frame_delay
delta_frame_bytes
)
;
}
}
else
{
int
nStdDev
=
(
deviation
>
=
0
)
?
kNumStdDevDelayOutlier
:
-
kNumStdDevDelayOutlier
;
EstimateRandomJitter
(
nStdDev
*
sqrt
(
var_noise_
)
incomplete_frame
)
;
}
if
(
startup_count_
>
=
kStartupDelaySamples
)
{
PostProcessEstimate
(
)
;
}
else
{
startup_count_
+
+
;
}
}
void
VCMJitterEstimator
:
:
FrameNacked
(
)
{
if
(
nack_count_
<
kNackLimit
)
{
nack_count_
+
+
;
}
latest_nack_
=
clock_
-
>
CurrentTime
(
)
;
}
void
VCMJitterEstimator
:
:
KalmanEstimateChannel
(
TimeDelta
frame_delay
double
delta_frame_size_bytes
)
{
double
Mh
[
2
]
;
double
hMh_sigma
;
double
kalmanGain
[
2
]
;
double
measureRes
;
double
t00
t01
;
theta_cov_
[
0
]
[
0
]
+
=
q_cov_
[
0
]
[
0
]
;
theta_cov_
[
0
]
[
1
]
+
=
q_cov_
[
0
]
[
1
]
;
theta_cov_
[
1
]
[
0
]
+
=
q_cov_
[
1
]
[
0
]
;
theta_cov_
[
1
]
[
1
]
+
=
q_cov_
[
1
]
[
1
]
;
Mh
[
0
]
=
theta_cov_
[
0
]
[
0
]
*
delta_frame_size_bytes
+
theta_cov_
[
0
]
[
1
]
;
Mh
[
1
]
=
theta_cov_
[
1
]
[
0
]
*
delta_frame_size_bytes
+
theta_cov_
[
1
]
[
1
]
;
if
(
max_frame_size_
<
DataSize
:
:
Bytes
(
1
)
)
{
return
;
}
double
sigma
=
(
300
.
0
*
exp
(
-
fabs
(
delta_frame_size_bytes
)
/
(
1e0
*
max_frame_size_
.
bytes
(
)
)
)
+
1
)
*
sqrt
(
var_noise_
)
;
if
(
sigma
<
1
.
0
)
{
sigma
=
1
.
0
;
}
hMh_sigma
=
delta_frame_size_bytes
*
Mh
[
0
]
+
Mh
[
1
]
+
sigma
;
if
(
(
hMh_sigma
<
1e
-
9
&
&
hMh_sigma
>
=
0
)
|
|
(
hMh_sigma
>
-
1e
-
9
&
&
hMh_sigma
<
=
0
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
kalmanGain
[
0
]
=
Mh
[
0
]
/
hMh_sigma
;
kalmanGain
[
1
]
=
Mh
[
1
]
/
hMh_sigma
;
measureRes
=
frame_delay
.
ms
(
)
-
(
delta_frame_size_bytes
*
theta_
[
0
]
+
theta_
[
1
]
)
;
theta_
[
0
]
+
=
kalmanGain
[
0
]
*
measureRes
;
theta_
[
1
]
+
=
kalmanGain
[
1
]
*
measureRes
;
if
(
theta_
[
0
]
<
kThetaLow
)
{
theta_
[
0
]
=
kThetaLow
;
}
t00
=
theta_cov_
[
0
]
[
0
]
;
t01
=
theta_cov_
[
0
]
[
1
]
;
theta_cov_
[
0
]
[
0
]
=
(
1
-
kalmanGain
[
0
]
*
delta_frame_size_bytes
)
*
t00
-
kalmanGain
[
0
]
*
theta_cov_
[
1
]
[
0
]
;
theta_cov_
[
0
]
[
1
]
=
(
1
-
kalmanGain
[
0
]
*
delta_frame_size_bytes
)
*
t01
-
kalmanGain
[
0
]
*
theta_cov_
[
1
]
[
1
]
;
theta_cov_
[
1
]
[
0
]
=
theta_cov_
[
1
]
[
0
]
*
(
1
-
kalmanGain
[
1
]
)
-
kalmanGain
[
1
]
*
delta_frame_size_bytes
*
t00
;
theta_cov_
[
1
]
[
1
]
=
theta_cov_
[
1
]
[
1
]
*
(
1
-
kalmanGain
[
1
]
)
-
kalmanGain
[
1
]
*
delta_frame_size_bytes
*
t01
;
RTC_DCHECK
(
theta_cov_
[
0
]
[
0
]
+
theta_cov_
[
1
]
[
1
]
>
=
0
&
&
theta_cov_
[
0
]
[
0
]
*
theta_cov_
[
1
]
[
1
]
-
theta_cov_
[
0
]
[
1
]
*
theta_cov_
[
1
]
[
0
]
>
=
0
&
&
theta_cov_
[
0
]
[
0
]
>
=
0
)
;
}
double
VCMJitterEstimator
:
:
DeviationFromExpectedDelay
(
TimeDelta
frame_delay
double
delta_frame_size_bytes
)
const
{
return
frame_delay
.
ms
(
)
-
(
theta_
[
0
]
*
delta_frame_size_bytes
+
theta_
[
1
]
)
;
}
void
VCMJitterEstimator
:
:
EstimateRandomJitter
(
double
d_dT
bool
incomplete_frame
)
{
Timestamp
now
=
clock_
-
>
CurrentTime
(
)
;
if
(
last_update_time_
.
has_value
(
)
)
{
fps_counter_
.
AddSample
(
(
now
-
*
last_update_time_
)
.
us
(
)
)
;
}
last_update_time_
=
now
;
if
(
alpha_count_
=
=
0
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
;
}
double
alpha
=
static_cast
<
double
>
(
alpha_count_
-
1
)
/
static_cast
<
double
>
(
alpha_count_
)
;
alpha_count_
+
+
;
if
(
alpha_count_
>
kAlphaCountMax
)
alpha_count_
=
kAlphaCountMax
;
Frequency
fps
=
GetFrameRate
(
)
;
if
(
fps
>
Frequency
:
:
Zero
(
)
)
{
constexpr
Frequency
k30Fps
=
Frequency
:
:
Hertz
(
30
)
;
double
rate_scale
=
k30Fps
/
fps
;
if
(
alpha_count_
<
kStartupDelaySamples
)
{
rate_scale
=
(
alpha_count_
*
rate_scale
+
(
kStartupDelaySamples
-
alpha_count_
)
)
/
kStartupDelaySamples
;
}
alpha
=
pow
(
alpha
rate_scale
)
;
}
double
avgNoise
=
alpha
*
avg_noise_
+
(
1
-
alpha
)
*
d_dT
;
double
varNoise
=
alpha
*
var_noise_
+
(
1
-
alpha
)
*
(
d_dT
-
avg_noise_
)
*
(
d_dT
-
avg_noise_
)
;
if
(
!
incomplete_frame
|
|
varNoise
>
var_noise_
)
{
avg_noise_
=
avgNoise
;
var_noise_
=
varNoise
;
}
if
(
var_noise_
<
1
.
0
)
{
var_noise_
=
1
.
0
;
}
}
double
VCMJitterEstimator
:
:
NoiseThreshold
(
)
const
{
double
noiseThreshold
=
kNoiseStdDevs
*
sqrt
(
var_noise_
)
-
kNoiseStdDevOffset
;
if
(
noiseThreshold
<
1
.
0
)
{
noiseThreshold
=
1
.
0
;
}
return
noiseThreshold
;
}
TimeDelta
VCMJitterEstimator
:
:
CalculateEstimate
(
)
{
double
retMs
=
theta_
[
0
]
*
(
max_frame_size_
.
bytes
(
)
-
avg_frame_size_
.
bytes
(
)
)
+
NoiseThreshold
(
)
;
TimeDelta
ret
=
TimeDelta
:
:
Millis
(
retMs
)
;
constexpr
TimeDelta
kMinPrevEstimate
=
TimeDelta
:
:
Micros
(
10
)
;
constexpr
TimeDelta
kMaxEstimate
=
TimeDelta
:
:
Seconds
(
10
)
;
if
(
ret
<
TimeDelta
:
:
Millis
(
1
)
)
{
if
(
!
prev_estimate_
|
|
prev_estimate_
<
=
kMinPrevEstimate
)
{
ret
=
TimeDelta
:
:
Millis
(
1
)
;
}
else
{
ret
=
*
prev_estimate_
;
}
}
if
(
ret
>
kMaxEstimate
)
{
ret
=
kMaxEstimate
;
}
prev_estimate_
=
ret
;
return
ret
;
}
void
VCMJitterEstimator
:
:
PostProcessEstimate
(
)
{
filter_jitter_estimate_
=
CalculateEstimate
(
)
;
}
void
VCMJitterEstimator
:
:
UpdateRtt
(
TimeDelta
rtt
)
{
rtt_filter_
.
Update
(
rtt
)
;
}
TimeDelta
VCMJitterEstimator
:
:
GetJitterEstimate
(
double
rtt_multiplier
absl
:
:
optional
<
TimeDelta
>
rtt_mult_add_cap
)
{
TimeDelta
jitter
=
CalculateEstimate
(
)
+
OPERATING_SYSTEM_JITTER
;
Timestamp
now
=
clock_
-
>
CurrentTime
(
)
;
if
(
now
-
latest_nack_
>
kNackCountTimeout
)
nack_count_
=
0
;
if
(
filter_jitter_estimate_
>
jitter
)
jitter
=
filter_jitter_estimate_
;
if
(
nack_count_
>
=
kNackLimit
)
{
if
(
rtt_mult_add_cap
.
has_value
(
)
)
{
jitter
+
=
std
:
:
min
(
rtt_filter_
.
Rtt
(
)
*
rtt_multiplier
rtt_mult_add_cap
.
value
(
)
)
;
}
else
{
jitter
+
=
rtt_filter_
.
Rtt
(
)
*
rtt_multiplier
;
}
}
if
(
enable_reduced_delay_
)
{
static
const
Frequency
kJitterScaleLowThreshold
=
Frequency
:
:
Hertz
(
5
)
;
static
const
Frequency
kJitterScaleHighThreshold
=
Frequency
:
:
Hertz
(
10
)
;
Frequency
fps
=
GetFrameRate
(
)
;
if
(
fps
<
kJitterScaleLowThreshold
)
{
if
(
fps
.
IsZero
(
)
)
{
return
std
:
:
max
(
TimeDelta
:
:
Zero
(
)
jitter
)
;
}
return
TimeDelta
:
:
Zero
(
)
;
}
if
(
fps
<
kJitterScaleHighThreshold
)
{
jitter
=
(
1
.
0
/
(
kJitterScaleHighThreshold
-
kJitterScaleLowThreshold
)
)
*
(
fps
-
kJitterScaleLowThreshold
)
*
jitter
;
}
}
return
std
:
:
max
(
TimeDelta
:
:
Zero
(
)
jitter
)
;
}
Frequency
VCMJitterEstimator
:
:
GetFrameRate
(
)
const
{
TimeDelta
mean_frame_period
=
TimeDelta
:
:
Micros
(
fps_counter_
.
ComputeMean
(
)
)
;
if
(
mean_frame_period
<
=
TimeDelta
:
:
Zero
(
)
)
return
Frequency
:
:
Zero
(
)
;
Frequency
fps
=
1
/
mean_frame_period
;
RTC_DCHECK_GE
(
fps
Frequency
:
:
Zero
(
)
)
;
return
std
:
:
min
(
fps
kMaxFramerateEstimate
)
;
}
}
