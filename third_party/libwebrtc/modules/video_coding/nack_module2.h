#
ifndef
MODULES_VIDEO_CODING_NACK_MODULE2_H_
#
define
MODULES_VIDEO_CODING_NACK_MODULE2_H_
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
set
>
#
include
<
vector
>
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
modules
/
video_coding
/
histogram
.
h
"
#
include
"
rtc_base
/
numerics
/
sequence_number_util
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
task_utils
/
pending_task_safety_flag
.
h
"
#
include
"
rtc_base
/
task_utils
/
repeating_task
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
class
NackModule2
final
{
public
:
static
constexpr
TimeDelta
kUpdateInterval
=
TimeDelta
:
:
Millis
(
20
)
;
NackModule2
(
TaskQueueBase
*
current_queue
Clock
*
clock
NackSender
*
nack_sender
KeyFrameRequestSender
*
keyframe_request_sender
TimeDelta
update_interval
=
kUpdateInterval
)
;
~
NackModule2
(
)
;
int
OnReceivedPacket
(
uint16_t
seq_num
bool
is_keyframe
)
;
int
OnReceivedPacket
(
uint16_t
seq_num
bool
is_keyframe
bool
is_recovered
)
;
void
ClearUpTo
(
uint16_t
seq_num
)
;
void
UpdateRtt
(
int64_t
rtt_ms
)
;
private
:
enum
NackFilterOptions
{
kSeqNumOnly
kTimeOnly
kSeqNumAndTime
}
;
struct
NackInfo
{
NackInfo
(
)
;
NackInfo
(
uint16_t
seq_num
uint16_t
send_at_seq_num
int64_t
created_at_time
)
;
uint16_t
seq_num
;
uint16_t
send_at_seq_num
;
int64_t
created_at_time
;
int64_t
sent_at_time
;
int
retries
;
}
;
struct
BackoffSettings
{
BackoffSettings
(
TimeDelta
min_retry
TimeDelta
max_rtt
double
base
)
;
static
absl
:
:
optional
<
BackoffSettings
>
ParseFromFieldTrials
(
)
;
const
TimeDelta
min_retry_interval
;
const
TimeDelta
max_rtt
;
const
double
base
;
}
;
void
AddPacketsToNack
(
uint16_t
seq_num_start
uint16_t
seq_num_end
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
worker_thread_
)
;
bool
RemovePacketsUntilKeyFrame
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
worker_thread_
)
;
std
:
:
vector
<
uint16_t
>
GetNackBatch
(
NackFilterOptions
options
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
worker_thread_
)
;
void
UpdateReorderingStatistics
(
uint16_t
seq_num
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
worker_thread_
)
;
int
WaitNumberOfPackets
(
float
probability
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
worker_thread_
)
;
TaskQueueBase
*
const
worker_thread_
;
RepeatingTaskHandle
repeating_task_
RTC_GUARDED_BY
(
worker_thread_
)
;
const
TimeDelta
update_interval_
;
Clock
*
const
clock_
;
NackSender
*
const
nack_sender_
;
KeyFrameRequestSender
*
const
keyframe_request_sender_
;
std
:
:
map
<
uint16_t
NackInfo
DescendingSeqNumComp
<
uint16_t
>
>
nack_list_
RTC_GUARDED_BY
(
worker_thread_
)
;
std
:
:
set
<
uint16_t
DescendingSeqNumComp
<
uint16_t
>
>
keyframe_list_
RTC_GUARDED_BY
(
worker_thread_
)
;
std
:
:
set
<
uint16_t
DescendingSeqNumComp
<
uint16_t
>
>
recovered_list_
RTC_GUARDED_BY
(
worker_thread_
)
;
video_coding
:
:
Histogram
reordering_histogram_
RTC_GUARDED_BY
(
worker_thread_
)
;
bool
initialized_
RTC_GUARDED_BY
(
worker_thread_
)
;
int64_t
rtt_ms_
RTC_GUARDED_BY
(
worker_thread_
)
;
uint16_t
newest_seq_num_
RTC_GUARDED_BY
(
worker_thread_
)
;
const
int64_t
send_nack_delay_ms_
;
const
absl
:
:
optional
<
BackoffSettings
>
backoff_settings_
;
ScopedTaskSafety
task_safety_
;
}
;
}
#
endif
