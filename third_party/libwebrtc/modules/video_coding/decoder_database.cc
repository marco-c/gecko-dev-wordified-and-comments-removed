#
include
"
modules
/
video_coding
/
decoder_database
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
bool
VCMDecoderDataBase
:
:
DeregisterExternalDecoder
(
uint8_t
payload_type
)
{
auto
it
=
decoders_
.
find
(
payload_type
)
;
if
(
it
=
=
decoders_
.
end
(
)
)
{
return
false
;
}
if
(
current_decoder_
&
&
current_decoder_
-
>
IsSameDecoder
(
it
-
>
second
)
)
{
current_decoder_
=
absl
:
:
nullopt
;
}
decoders_
.
erase
(
it
)
;
return
true
;
}
void
VCMDecoderDataBase
:
:
RegisterExternalDecoder
(
uint8_t
payload_type
VideoDecoder
*
external_decoder
)
{
DeregisterExternalDecoder
(
payload_type
)
;
decoders_
[
payload_type
]
=
external_decoder
;
}
bool
VCMDecoderDataBase
:
:
IsExternalDecoderRegistered
(
uint8_t
payload_type
)
const
{
return
payload_type
=
=
current_payload_type_
|
|
decoders_
.
find
(
payload_type
)
!
=
decoders_
.
end
(
)
;
}
bool
VCMDecoderDataBase
:
:
RegisterReceiveCodec
(
uint8_t
payload_type
const
VideoCodec
&
receive_codec
int
number_of_cores
)
{
if
(
number_of_cores
<
0
)
{
return
false
;
}
if
(
payload_type
=
=
current_payload_type_
)
{
current_payload_type_
=
absl
:
:
nullopt
;
}
auto
&
entry
=
decoder_settings_
[
payload_type
]
;
entry
.
settings
=
receive_codec
;
entry
.
number_of_cores
=
number_of_cores
;
return
true
;
}
bool
VCMDecoderDataBase
:
:
DeregisterReceiveCodec
(
uint8_t
payload_type
)
{
if
(
decoder_settings_
.
erase
(
payload_type
)
=
=
0
)
{
return
false
;
}
if
(
payload_type
=
=
current_payload_type_
)
{
current_payload_type_
=
absl
:
:
nullopt
;
}
return
true
;
}
VCMGenericDecoder
*
VCMDecoderDataBase
:
:
GetDecoder
(
const
VCMEncodedFrame
&
frame
VCMDecodedFrameCallback
*
decoded_frame_callback
)
{
RTC_DCHECK
(
decoded_frame_callback
-
>
UserReceiveCallback
(
)
)
;
uint8_t
payload_type
=
frame
.
PayloadType
(
)
;
if
(
payload_type
=
=
current_payload_type_
|
|
payload_type
=
=
0
)
{
return
current_decoder_
.
has_value
(
)
?
&
*
current_decoder_
:
nullptr
;
}
if
(
current_decoder_
.
has_value
(
)
)
{
current_decoder_
=
absl
:
:
nullopt
;
current_payload_type_
=
absl
:
:
nullopt
;
}
CreateAndInitDecoder
(
frame
)
;
if
(
current_decoder_
=
=
absl
:
:
nullopt
)
{
return
nullptr
;
}
VCMReceiveCallback
*
callback
=
decoded_frame_callback
-
>
UserReceiveCallback
(
)
;
callback
-
>
OnIncomingPayloadType
(
payload_type
)
;
if
(
current_decoder_
-
>
RegisterDecodeCompleteCallback
(
decoded_frame_callback
)
<
0
)
{
current_decoder_
=
absl
:
:
nullopt
;
return
nullptr
;
}
current_payload_type_
=
payload_type
;
return
&
*
current_decoder_
;
}
void
VCMDecoderDataBase
:
:
CreateAndInitDecoder
(
const
VCMEncodedFrame
&
frame
)
{
uint8_t
payload_type
=
frame
.
PayloadType
(
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
Initializing
decoder
with
payload
type
'
"
<
<
int
{
payload_type
}
<
<
"
'
.
"
;
auto
decoder_item
=
decoder_settings_
.
find
(
payload_type
)
;
if
(
decoder_item
=
=
decoder_settings_
.
end
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Can
'
t
find
a
decoder
associated
with
payload
type
:
"
<
<
int
{
payload_type
}
;
return
;
}
auto
external_dec_item
=
decoders_
.
find
(
payload_type
)
;
if
(
external_dec_item
=
=
decoders_
.
end
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
No
decoder
of
this
type
exists
.
"
;
return
;
}
current_decoder_
.
emplace
(
external_dec_item
-
>
second
)
;
if
(
frame
.
EncodedImage
(
)
.
_encodedWidth
>
0
&
&
frame
.
EncodedImage
(
)
.
_encodedHeight
>
0
)
{
decoder_item
-
>
second
.
settings
.
width
=
frame
.
EncodedImage
(
)
.
_encodedWidth
;
decoder_item
-
>
second
.
settings
.
height
=
frame
.
EncodedImage
(
)
.
_encodedHeight
;
}
int
err
=
current_decoder_
-
>
InitDecode
(
&
decoder_item
-
>
second
.
settings
decoder_item
-
>
second
.
number_of_cores
)
;
if
(
err
<
0
)
{
current_decoder_
=
absl
:
:
nullopt
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
initialize
decoder
.
Error
code
:
"
<
<
err
;
}
}
}
