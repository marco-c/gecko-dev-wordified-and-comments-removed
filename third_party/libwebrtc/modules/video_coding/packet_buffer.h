#
ifndef
MODULES_VIDEO_CODING_PACKET_BUFFER_H_
#
define
MODULES_VIDEO_CODING_PACKET_BUFFER_H_
#
include
<
memory
>
#
include
<
queue
>
#
include
<
set
>
#
include
<
vector
>
#
include
"
absl
/
base
/
attributes
.
h
"
#
include
"
api
/
rtp_packet_info
.
h
"
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_video_header
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
numerics
/
sequence_number_util
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
video_coding
{
class
PacketBuffer
{
public
:
struct
Packet
{
Packet
(
)
=
default
;
Packet
(
const
RtpPacketReceived
&
rtp_packet
const
RTPVideoHeader
&
video_header
int64_t
receive_time_ms
)
;
Packet
(
const
Packet
&
)
=
delete
;
Packet
(
Packet
&
&
)
=
delete
;
Packet
&
operator
=
(
const
Packet
&
)
=
delete
;
Packet
&
operator
=
(
Packet
&
&
)
=
delete
;
~
Packet
(
)
=
default
;
VideoCodecType
codec
(
)
const
{
return
video_header
.
codec
;
}
int
width
(
)
const
{
return
video_header
.
width
;
}
int
height
(
)
const
{
return
video_header
.
height
;
}
bool
is_first_packet_in_frame
(
)
const
{
return
video_header
.
is_first_packet_in_frame
;
}
bool
is_last_packet_in_frame
(
)
const
{
return
video_header
.
is_last_packet_in_frame
;
}
bool
continuous
=
false
;
bool
marker_bit
=
false
;
uint8_t
payload_type
=
0
;
uint16_t
seq_num
=
0
;
uint32_t
timestamp
=
0
;
int
times_nacked
=
-
1
;
rtc
:
:
CopyOnWriteBuffer
video_payload
;
RTPVideoHeader
video_header
;
RtpPacketInfo
packet_info
;
}
;
struct
InsertResult
{
std
:
:
vector
<
std
:
:
unique_ptr
<
Packet
>
>
packets
;
bool
buffer_cleared
=
false
;
}
;
PacketBuffer
(
Clock
*
clock
size_t
start_buffer_size
size_t
max_buffer_size
)
;
~
PacketBuffer
(
)
;
ABSL_MUST_USE_RESULT
InsertResult
InsertPacket
(
std
:
:
unique_ptr
<
Packet
>
packet
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
ABSL_MUST_USE_RESULT
InsertResult
InsertPadding
(
uint16_t
seq_num
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
uint32_t
ClearTo
(
uint16_t
seq_num
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
void
Clear
(
)
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
absl
:
:
optional
<
int64_t
>
LastReceivedPacketMs
(
)
const
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
absl
:
:
optional
<
int64_t
>
LastReceivedKeyframePacketMs
(
)
const
RTC_LOCKS_EXCLUDED
(
mutex_
)
;
void
ForceSpsPpsIdrIsH264Keyframe
(
)
;
private
:
Clock
*
const
clock_
;
void
ClearInternal
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
bool
ExpandBufferSize
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
bool
PotentialNewFrame
(
uint16_t
seq_num
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Packet
>
>
FindFrames
(
uint16_t
seq_num
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
void
UpdateMissingPackets
(
uint16_t
seq_num
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
mutex_
)
;
mutable
Mutex
mutex_
;
const
size_t
max_size_
;
uint16_t
first_seq_num_
RTC_GUARDED_BY
(
mutex_
)
;
bool
first_packet_received_
RTC_GUARDED_BY
(
mutex_
)
;
bool
is_cleared_to_first_seq_num_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Packet
>
>
buffer_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
int64_t
>
last_received_packet_ms_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
int64_t
>
last_received_keyframe_packet_ms_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
uint32_t
>
last_received_keyframe_rtp_timestamp_
RTC_GUARDED_BY
(
mutex_
)
;
absl
:
:
optional
<
uint16_t
>
newest_inserted_seq_num_
RTC_GUARDED_BY
(
mutex_
)
;
std
:
:
set
<
uint16_t
DescendingSeqNumComp
<
uint16_t
>
>
missing_packets_
RTC_GUARDED_BY
(
mutex_
)
;
bool
sps_pps_idr_is_h264_keyframe_
;
}
;
}
}
#
endif
