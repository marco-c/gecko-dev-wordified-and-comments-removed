#
include
"
modules
/
remote_bitrate_estimator
/
remote_bitrate_estimator_single_stream
.
h
"
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
aimd_rate_control
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
include
/
bwe_defines
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
inter_arrival
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
overuse_detector
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
overuse_estimator
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_header_extensions
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
namespace
webrtc
{
namespace
{
absl
:
:
optional
<
DataRate
>
OptionalRateFromOptionalBps
(
absl
:
:
optional
<
int
>
bitrate_bps
)
{
if
(
bitrate_bps
)
{
return
DataRate
:
:
BitsPerSec
(
*
bitrate_bps
)
;
}
else
{
return
absl
:
:
nullopt
;
}
}
}
enum
{
kTimestampGroupLengthMs
=
5
}
;
static
const
double
kTimestampToMs
=
1
.
0
/
90
.
0
;
struct
RemoteBitrateEstimatorSingleStream
:
:
Detector
{
explicit
Detector
(
int64_t
last_packet_time_ms
)
:
last_packet_time_ms
(
last_packet_time_ms
)
inter_arrival
(
90
*
kTimestampGroupLengthMs
kTimestampToMs
)
{
}
int64_t
last_packet_time_ms
;
InterArrival
inter_arrival
;
OveruseEstimator
estimator
;
OveruseDetector
detector
;
}
;
RemoteBitrateEstimatorSingleStream
:
:
RemoteBitrateEstimatorSingleStream
(
RemoteBitrateObserver
*
observer
Clock
*
clock
)
:
clock_
(
clock
)
incoming_bitrate_
(
kBitrateWindowMs
8000
)
last_valid_incoming_bitrate_
(
0
)
remote_rate_
(
field_trials_
)
observer_
(
observer
)
last_process_time_
(
-
1
)
process_interval_ms_
(
kProcessIntervalMs
)
uma_recorded_
(
false
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
RemoteBitrateEstimatorSingleStream
:
Instantiating
.
"
;
}
RemoteBitrateEstimatorSingleStream
:
:
~
RemoteBitrateEstimatorSingleStream
(
)
{
while
(
!
overuse_detectors_
.
empty
(
)
)
{
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
begin
(
)
;
delete
it
-
>
second
;
overuse_detectors_
.
erase
(
it
)
;
}
}
void
RemoteBitrateEstimatorSingleStream
:
:
IncomingPacket
(
const
RtpPacketReceived
&
rtp_packet
)
{
absl
:
:
optional
<
int32_t
>
transmission_time_offset
=
rtp_packet
.
GetExtension
<
TransmissionOffset
>
(
)
;
if
(
!
uma_recorded_
)
{
BweNames
type
=
transmission_time_offset
.
has_value
(
)
?
BweNames
:
:
kReceiverTOffset
:
BweNames
:
:
kReceiverNoExtension
;
RTC_HISTOGRAM_ENUMERATION
(
kBweTypeHistogram
type
BweNames
:
:
kBweNamesMax
)
;
uma_recorded_
=
true
;
}
uint32_t
ssrc
=
rtp_packet
.
Ssrc
(
)
;
uint32_t
rtp_timestamp
=
rtp_packet
.
Timestamp
(
)
+
transmission_time_offset
.
value_or
(
0
)
;
int64_t
now_ms
=
clock_
-
>
TimeInMilliseconds
(
)
;
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
find
(
ssrc
)
;
if
(
it
=
=
overuse_detectors_
.
end
(
)
)
{
std
:
:
pair
<
SsrcOveruseEstimatorMap
:
:
iterator
bool
>
insert_result
=
overuse_detectors_
.
insert
(
std
:
:
make_pair
(
ssrc
new
Detector
(
now_ms
)
)
)
;
it
=
insert_result
.
first
;
}
Detector
*
estimator
=
it
-
>
second
;
estimator
-
>
last_packet_time_ms
=
now_ms
;
absl
:
:
optional
<
uint32_t
>
incoming_bitrate
=
incoming_bitrate_
.
Rate
(
now_ms
)
;
if
(
incoming_bitrate
)
{
last_valid_incoming_bitrate_
=
*
incoming_bitrate
;
}
else
if
(
last_valid_incoming_bitrate_
>
0
)
{
incoming_bitrate_
.
Reset
(
)
;
last_valid_incoming_bitrate_
=
0
;
}
size_t
payload_size
=
rtp_packet
.
payload_size
(
)
+
rtp_packet
.
padding_size
(
)
;
incoming_bitrate_
.
Update
(
payload_size
now_ms
)
;
const
BandwidthUsage
prior_state
=
estimator
-
>
detector
.
State
(
)
;
uint32_t
timestamp_delta
=
0
;
int64_t
time_delta
=
0
;
int
size_delta
=
0
;
if
(
estimator
-
>
inter_arrival
.
ComputeDeltas
(
rtp_timestamp
rtp_packet
.
arrival_time
(
)
.
ms
(
)
now_ms
payload_size
&
timestamp_delta
&
time_delta
&
size_delta
)
)
{
double
timestamp_delta_ms
=
timestamp_delta
*
kTimestampToMs
;
estimator
-
>
estimator
.
Update
(
time_delta
timestamp_delta_ms
size_delta
estimator
-
>
detector
.
State
(
)
now_ms
)
;
estimator
-
>
detector
.
Detect
(
estimator
-
>
estimator
.
offset
(
)
timestamp_delta_ms
estimator
-
>
estimator
.
num_of_deltas
(
)
now_ms
)
;
}
if
(
estimator
-
>
detector
.
State
(
)
=
=
BandwidthUsage
:
:
kBwOverusing
)
{
absl
:
:
optional
<
uint32_t
>
incoming_bitrate_bps
=
incoming_bitrate_
.
Rate
(
now_ms
)
;
if
(
incoming_bitrate_bps
&
&
(
prior_state
!
=
BandwidthUsage
:
:
kBwOverusing
|
|
remote_rate_
.
TimeToReduceFurther
(
Timestamp
:
:
Millis
(
now_ms
)
DataRate
:
:
BitsPerSec
(
*
incoming_bitrate_bps
)
)
)
)
{
UpdateEstimate
(
now_ms
)
;
}
}
}
TimeDelta
RemoteBitrateEstimatorSingleStream
:
:
Process
(
)
{
int64_t
now_ms
=
clock_
-
>
TimeInMilliseconds
(
)
;
int64_t
next_process_time_ms
=
last_process_time_
+
process_interval_ms_
;
if
(
last_process_time_
=
=
-
1
|
|
now_ms
>
=
next_process_time_ms
)
{
UpdateEstimate
(
now_ms
)
;
last_process_time_
=
now_ms
;
return
TimeDelta
:
:
Millis
(
process_interval_ms_
)
;
}
return
TimeDelta
:
:
Millis
(
next_process_time_ms
-
now_ms
)
;
}
void
RemoteBitrateEstimatorSingleStream
:
:
UpdateEstimate
(
int64_t
now_ms
)
{
BandwidthUsage
bw_state
=
BandwidthUsage
:
:
kBwNormal
;
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
begin
(
)
;
while
(
it
!
=
overuse_detectors_
.
end
(
)
)
{
const
int64_t
time_of_last_received_packet
=
it
-
>
second
-
>
last_packet_time_ms
;
if
(
time_of_last_received_packet
>
=
0
&
&
now_ms
-
time_of_last_received_packet
>
kStreamTimeOutMs
)
{
delete
it
-
>
second
;
overuse_detectors_
.
erase
(
it
+
+
)
;
}
else
{
if
(
it
-
>
second
-
>
detector
.
State
(
)
>
bw_state
)
{
bw_state
=
it
-
>
second
-
>
detector
.
State
(
)
;
}
+
+
it
;
}
}
if
(
overuse_detectors_
.
empty
(
)
)
{
return
;
}
const
RateControlInput
input
(
bw_state
OptionalRateFromOptionalBps
(
incoming_bitrate_
.
Rate
(
now_ms
)
)
)
;
uint32_t
target_bitrate
=
remote_rate_
.
Update
(
input
Timestamp
:
:
Millis
(
now_ms
)
)
.
bps
<
uint32_t
>
(
)
;
if
(
remote_rate_
.
ValidEstimate
(
)
)
{
process_interval_ms_
=
remote_rate_
.
GetFeedbackInterval
(
)
.
ms
(
)
;
RTC_DCHECK_GT
(
process_interval_ms_
0
)
;
std
:
:
vector
<
uint32_t
>
ssrcs
;
GetSsrcs
(
&
ssrcs
)
;
if
(
observer_
)
observer_
-
>
OnReceiveBitrateChanged
(
ssrcs
target_bitrate
)
;
}
}
void
RemoteBitrateEstimatorSingleStream
:
:
OnRttUpdate
(
int64_t
avg_rtt_ms
int64_t
max_rtt_ms
)
{
remote_rate_
.
SetRtt
(
TimeDelta
:
:
Millis
(
avg_rtt_ms
)
)
;
}
void
RemoteBitrateEstimatorSingleStream
:
:
RemoveStream
(
unsigned
int
ssrc
)
{
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
find
(
ssrc
)
;
if
(
it
!
=
overuse_detectors_
.
end
(
)
)
{
delete
it
-
>
second
;
overuse_detectors_
.
erase
(
it
)
;
}
}
DataRate
RemoteBitrateEstimatorSingleStream
:
:
LatestEstimate
(
)
const
{
if
(
!
remote_rate_
.
ValidEstimate
(
)
|
|
overuse_detectors_
.
empty
(
)
)
{
return
DataRate
:
:
Zero
(
)
;
}
return
remote_rate_
.
LatestEstimate
(
)
;
}
void
RemoteBitrateEstimatorSingleStream
:
:
GetSsrcs
(
std
:
:
vector
<
uint32_t
>
*
ssrcs
)
const
{
RTC_DCHECK
(
ssrcs
)
;
ssrcs
-
>
resize
(
overuse_detectors_
.
size
(
)
)
;
int
i
=
0
;
for
(
SsrcOveruseEstimatorMap
:
:
const_iterator
it
=
overuse_detectors_
.
begin
(
)
;
it
!
=
overuse_detectors_
.
end
(
)
;
+
+
it
+
+
i
)
{
(
*
ssrcs
)
[
i
]
=
it
-
>
first
;
}
}
}
