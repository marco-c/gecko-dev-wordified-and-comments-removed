#
ifndef
MODULES_REMOTE_BITRATE_ESTIMATOR_CONGESTION_CONTROL_FEEDBACK_GENERATOR_H_
#
define
MODULES_REMOTE_BITRATE_ESTIMATOR_CONGESTION_CONTROL_FEEDBACK_GENERATOR_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
rtp_transport_feedback_generator
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
rtc_base
/
experiments
/
field_trial_parser
.
h
"
#
include
"
rtc_base
/
numerics
/
sequence_number_unwrapper
.
h
"
namespace
webrtc
{
class
CongestionControlFeedbackGenerator
:
public
RtpTransportFeedbackGenerator
{
public
:
CongestionControlFeedbackGenerator
(
const
Environment
&
env
RtpTransportFeedbackGenerator
:
:
RtcpSender
feedback_sender
)
;
~
CongestionControlFeedbackGenerator
(
)
=
default
;
void
OnReceivedPacket
(
const
RtpPacketReceived
&
packet
)
override
;
void
OnSendBandwidthEstimateChanged
(
DataRate
estimate
)
override
;
TimeDelta
Process
(
Timestamp
now
)
override
;
void
SetTransportOverhead
(
DataSize
overhead_per_packet
)
override
;
private
:
struct
PacketInfo
{
uint32_t
ssrc
;
int64_t
unwrapped_sequence_number
=
0
;
Timestamp
arrival_time
;
rtc
:
:
EcnMarking
ecn
=
rtc
:
:
EcnMarking
:
:
kNotEct
;
}
;
Timestamp
NextFeedbackTime
(
)
const
RTC_RUN_ON
(
sequence_checker_
)
;
void
SendFeedback
(
Timestamp
now
)
RTC_RUN_ON
(
sequence_checker_
)
;
void
CalculateNextPossibleSendTime
(
DataSize
feedback_size
Timestamp
now
)
RTC_RUN_ON
(
sequence_checker_
)
;
const
Environment
env_
;
SequenceChecker
sequence_checker_
;
const
RtcpSender
rtcp_sender_
;
FieldTrialParameter
<
TimeDelta
>
min_time_between_feedback_
;
FieldTrialParameter
<
TimeDelta
>
max_time_to_wait_for_packet_with_marker_
;
FieldTrialParameter
<
TimeDelta
>
max_time_between_feedback_
;
DataRate
max_feedback_rate_
=
DataRate
:
:
KilobitsPerSec
(
1000
)
;
DataSize
packet_overhead_
=
DataSize
:
:
Zero
(
)
;
DataSize
send_rate_debt_
=
DataSize
:
:
Zero
(
)
;
std
:
:
map
<
uint32_t
SeqNumUnwrapper
<
uint16_t
>
>
sequence_number_unwrappers_
;
std
:
:
vector
<
PacketInfo
>
packets_
;
Timestamp
last_feedback_sent_time_
=
Timestamp
:
:
Zero
(
)
;
bool
marker_bit_seen_
=
false
;
Timestamp
next_possible_feedback_send_time_
=
Timestamp
:
:
Zero
(
)
;
}
;
}
#
endif
