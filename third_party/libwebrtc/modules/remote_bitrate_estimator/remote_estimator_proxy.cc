#
include
"
modules
/
remote_bitrate_estimator
/
remote_estimator_proxy
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
transport_feedback
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
const
int
RemoteEstimatorProxy
:
:
kMaxNumberOfPackets
=
(
1
<
<
15
)
;
static
constexpr
int64_t
kMaxTimeMs
=
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
/
1000
;
RemoteEstimatorProxy
:
:
RemoteEstimatorProxy
(
Clock
*
clock
TransportFeedbackSender
feedback_sender
const
WebRtcKeyValueConfig
*
key_value_config
NetworkStateEstimator
*
network_state_estimator
)
:
clock_
(
clock
)
feedback_sender_
(
std
:
:
move
(
feedback_sender
)
)
send_config_
(
key_value_config
)
last_process_time_ms_
(
-
1
)
network_state_estimator_
(
network_state_estimator
)
media_ssrc_
(
0
)
feedback_packet_count_
(
0
)
send_interval_ms_
(
send_config_
.
default_interval
-
>
ms
(
)
)
send_periodic_feedback_
(
true
)
previous_abs_send_time_
(
0
)
abs_send_timestamp_
(
clock
-
>
CurrentTime
(
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Maximum
interval
between
transport
feedback
RTCP
messages
(
ms
)
:
"
<
<
send_config_
.
max_interval
-
>
ms
(
)
;
}
RemoteEstimatorProxy
:
:
~
RemoteEstimatorProxy
(
)
{
}
void
RemoteEstimatorProxy
:
:
AddPacket
(
int64_t
sequence_number
int64_t
arrival_time_ms
)
{
packet_arrival_times_
[
sequence_number
]
=
arrival_time_ms
;
}
void
RemoteEstimatorProxy
:
:
MaybeCullOldPackets
(
int64_t
sequence_number
int64_t
arrival_time_ms
)
{
if
(
periodic_window_start_seq_
&
&
packet_arrival_times_
.
lower_bound
(
*
periodic_window_start_seq_
)
=
=
packet_arrival_times_
.
end
(
)
)
{
for
(
auto
it
=
packet_arrival_times_
.
begin
(
)
;
it
!
=
packet_arrival_times_
.
end
(
)
&
&
it
-
>
first
<
sequence_number
&
&
arrival_time_ms
-
it
-
>
second
>
=
send_config_
.
back_window
-
>
ms
(
)
;
)
{
it
=
packet_arrival_times_
.
erase
(
it
)
;
}
}
}
void
RemoteEstimatorProxy
:
:
IncomingPacket
(
int64_t
arrival_time_ms
size_t
payload_size
const
RTPHeader
&
header
)
{
if
(
arrival_time_ms
<
0
|
|
arrival_time_ms
>
kMaxTimeMs
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Arrival
time
out
of
bounds
:
"
<
<
arrival_time_ms
;
return
;
}
MutexLock
lock
(
&
lock_
)
;
media_ssrc_
=
header
.
ssrc
;
int64_t
seq
=
0
;
if
(
header
.
extension
.
hasTransportSequenceNumber
)
{
seq
=
unwrapper_
.
Unwrap
(
header
.
extension
.
transportSequenceNumber
)
;
if
(
send_periodic_feedback_
)
{
MaybeCullOldPackets
(
seq
arrival_time_ms
)
;
if
(
!
periodic_window_start_seq_
|
|
seq
<
*
periodic_window_start_seq_
)
{
periodic_window_start_seq_
=
seq
;
}
}
if
(
packet_arrival_times_
.
find
(
seq
)
!
=
packet_arrival_times_
.
end
(
)
)
return
;
AddPacket
(
seq
arrival_time_ms
)
;
auto
first_arrival_time_to_keep
=
packet_arrival_times_
.
lower_bound
(
packet_arrival_times_
.
rbegin
(
)
-
>
first
-
kMaxNumberOfPackets
)
;
if
(
first_arrival_time_to_keep
!
=
packet_arrival_times_
.
begin
(
)
)
{
packet_arrival_times_
.
erase
(
packet_arrival_times_
.
begin
(
)
first_arrival_time_to_keep
)
;
if
(
send_periodic_feedback_
)
{
RTC_DCHECK
(
!
packet_arrival_times_
.
empty
(
)
)
;
periodic_window_start_seq_
=
packet_arrival_times_
.
begin
(
)
-
>
first
;
}
}
if
(
header
.
extension
.
feedback_request
)
{
SendFeedbackOnRequest
(
seq
header
.
extension
.
feedback_request
.
value
(
)
)
;
}
}
if
(
network_state_estimator_
&
&
header
.
extension
.
hasAbsoluteSendTime
)
{
PacketResult
packet_result
;
packet_result
.
receive_time
=
Timestamp
:
:
Millis
(
arrival_time_ms
)
;
abs_send_timestamp_
+
=
std
:
:
max
(
header
.
extension
.
GetAbsoluteSendTimeDelta
(
previous_abs_send_time_
)
TimeDelta
:
:
Millis
(
0
)
)
;
previous_abs_send_time_
=
header
.
extension
.
absoluteSendTime
;
packet_result
.
sent_packet
.
send_time
=
abs_send_timestamp_
;
packet_result
.
sent_packet
.
size
=
DataSize
:
:
Bytes
(
header
.
headerLength
+
payload_size
)
;
packet_result
.
sent_packet
.
sequence_number
=
seq
;
network_state_estimator_
-
>
OnReceivedPacket
(
packet_result
)
;
}
}
bool
RemoteEstimatorProxy
:
:
LatestEstimate
(
std
:
:
vector
<
unsigned
int
>
*
ssrcs
unsigned
int
*
bitrate_bps
)
const
{
return
false
;
}
int64_t
RemoteEstimatorProxy
:
:
TimeUntilNextProcess
(
)
{
MutexLock
lock
(
&
lock_
)
;
if
(
!
send_periodic_feedback_
)
{
return
24
*
60
*
60
*
1000
;
}
else
if
(
last_process_time_ms_
!
=
-
1
)
{
int64_t
now
=
clock_
-
>
TimeInMilliseconds
(
)
;
if
(
now
-
last_process_time_ms_
<
send_interval_ms_
)
return
last_process_time_ms_
+
send_interval_ms_
-
now
;
}
return
0
;
}
void
RemoteEstimatorProxy
:
:
Process
(
)
{
MutexLock
lock
(
&
lock_
)
;
if
(
!
send_periodic_feedback_
)
{
return
;
}
last_process_time_ms_
=
clock_
-
>
TimeInMilliseconds
(
)
;
SendPeriodicFeedbacks
(
)
;
}
void
RemoteEstimatorProxy
:
:
OnBitrateChanged
(
int
bitrate_bps
)
{
constexpr
int
kTwccReportSize
=
20
+
8
+
10
+
30
;
const
double
kMinTwccRate
=
kTwccReportSize
*
8
.
0
*
1000
.
0
/
send_config_
.
max_interval
-
>
ms
(
)
;
const
double
kMaxTwccRate
=
kTwccReportSize
*
8
.
0
*
1000
.
0
/
send_config_
.
min_interval
-
>
ms
(
)
;
MutexLock
lock
(
&
lock_
)
;
send_interval_ms_
=
static_cast
<
int
>
(
0
.
5
+
kTwccReportSize
*
8
.
0
*
1000
.
0
/
rtc
:
:
SafeClamp
(
static_cast
<
double
>
(
send_config_
.
bandwidth_fraction
)
*
bitrate_bps
kMinTwccRate
kMaxTwccRate
)
)
;
}
void
RemoteEstimatorProxy
:
:
SetSendPeriodicFeedback
(
bool
send_periodic_feedback
)
{
MutexLock
lock
(
&
lock_
)
;
send_periodic_feedback_
=
send_periodic_feedback
;
}
void
RemoteEstimatorProxy
:
:
SendPeriodicFeedbacks
(
)
{
if
(
!
periodic_window_start_seq_
)
return
;
std
:
:
unique_ptr
<
rtcp
:
:
RemoteEstimate
>
remote_estimate
;
if
(
network_state_estimator_
)
{
absl
:
:
optional
<
NetworkStateEstimate
>
state_estimate
=
network_state_estimator_
-
>
GetCurrentEstimate
(
)
;
if
(
state_estimate
)
{
remote_estimate
=
std
:
:
make_unique
<
rtcp
:
:
RemoteEstimate
>
(
)
;
remote_estimate
-
>
SetEstimate
(
state_estimate
.
value
(
)
)
;
}
}
for
(
auto
begin_iterator
=
packet_arrival_times_
.
lower_bound
(
*
periodic_window_start_seq_
)
;
begin_iterator
!
=
packet_arrival_times_
.
cend
(
)
;
begin_iterator
=
packet_arrival_times_
.
lower_bound
(
*
periodic_window_start_seq_
)
)
{
auto
feedback_packet
=
BuildFeedbackPacket
(
true
*
periodic_window_start_seq_
begin_iterator
packet_arrival_times_
.
cend
(
)
true
)
;
RTC_DCHECK
(
feedback_sender_
!
=
nullptr
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
rtcp
:
:
RtcpPacket
>
>
packets
;
if
(
remote_estimate
)
{
packets
.
push_back
(
std
:
:
move
(
remote_estimate
)
)
;
}
packets
.
push_back
(
std
:
:
move
(
feedback_packet
)
)
;
feedback_sender_
(
std
:
:
move
(
packets
)
)
;
}
}
void
RemoteEstimatorProxy
:
:
SendFeedbackOnRequest
(
int64_t
sequence_number
const
FeedbackRequest
&
feedback_request
)
{
if
(
feedback_request
.
sequence_count
=
=
0
)
{
return
;
}
int64_t
first_sequence_number
=
sequence_number
-
feedback_request
.
sequence_count
+
1
;
auto
begin_iterator
=
packet_arrival_times_
.
lower_bound
(
first_sequence_number
)
;
auto
end_iterator
=
packet_arrival_times_
.
upper_bound
(
sequence_number
)
;
auto
feedback_packet
=
BuildFeedbackPacket
(
feedback_request
.
include_timestamps
first_sequence_number
begin_iterator
end_iterator
false
)
;
packet_arrival_times_
.
erase
(
packet_arrival_times_
.
begin
(
)
begin_iterator
)
;
RTC_DCHECK
(
feedback_sender_
!
=
nullptr
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
rtcp
:
:
RtcpPacket
>
>
packets
;
packets
.
push_back
(
std
:
:
move
(
feedback_packet
)
)
;
feedback_sender_
(
std
:
:
move
(
packets
)
)
;
}
std
:
:
unique_ptr
<
rtcp
:
:
TransportFeedback
>
RemoteEstimatorProxy
:
:
BuildFeedbackPacket
(
bool
include_timestamps
int64_t
base_sequence_number
std
:
:
map
<
int64_t
int64_t
>
:
:
const_iterator
begin_iterator
std
:
:
map
<
int64_t
int64_t
>
:
:
const_iterator
end_iterator
bool
is_periodic_update
)
{
RTC_DCHECK
(
begin_iterator
!
=
end_iterator
)
;
auto
feedback_packet
=
std
:
:
make_unique
<
rtcp
:
:
TransportFeedback
>
(
include_timestamps
)
;
feedback_packet
-
>
SetMediaSsrc
(
media_ssrc_
)
;
feedback_packet
-
>
SetBase
(
static_cast
<
uint16_t
>
(
base_sequence_number
&
0xFFFF
)
begin_iterator
-
>
second
*
1000
)
;
feedback_packet
-
>
SetFeedbackSequenceNumber
(
feedback_packet_count_
+
+
)
;
int64_t
next_sequence_number
=
base_sequence_number
;
for
(
auto
it
=
begin_iterator
;
it
!
=
end_iterator
;
+
+
it
)
{
if
(
!
feedback_packet
-
>
AddReceivedPacket
(
static_cast
<
uint16_t
>
(
it
-
>
first
&
0xFFFF
)
it
-
>
second
*
1000
)
)
{
RTC_CHECK
(
begin_iterator
!
=
it
)
;
break
;
}
next_sequence_number
=
it
-
>
first
+
1
;
}
if
(
is_periodic_update
)
{
periodic_window_start_seq_
=
next_sequence_number
;
}
return
feedback_packet
;
}
}
