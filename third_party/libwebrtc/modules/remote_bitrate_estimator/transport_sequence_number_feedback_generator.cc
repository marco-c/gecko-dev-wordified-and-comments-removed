#
include
"
modules
/
remote_bitrate_estimator
/
transport_sequence_number_feedback_generator
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
api
/
units
/
data_rate
.
h
"
#
include
"
api
/
units
/
data_size
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
remote_bitrate_estimator
/
packet_arrival_map
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
transport_feedback
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_header_extensions
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
webrtc
{
namespace
{
constexpr
TimeDelta
kBackWindow
=
TimeDelta
:
:
Millis
(
500
)
;
constexpr
TimeDelta
kMinInterval
=
TimeDelta
:
:
Millis
(
50
)
;
constexpr
TimeDelta
kMaxInterval
=
TimeDelta
:
:
Millis
(
250
)
;
constexpr
TimeDelta
kDefaultInterval
=
TimeDelta
:
:
Millis
(
100
)
;
}
TransportSequenceNumberFeedbackGenenerator
:
:
TransportSequenceNumberFeedbackGenenerator
(
RtcpSender
feedback_sender
)
:
feedback_sender_
(
std
:
:
move
(
feedback_sender
)
)
last_process_time_
(
Timestamp
:
:
MinusInfinity
(
)
)
media_ssrc_
(
0
)
feedback_packet_count_
(
0
)
send_interval_
(
kDefaultInterval
)
send_periodic_feedback_
(
true
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Maximum
interval
between
transport
feedback
RTCP
messages
:
"
<
<
kMaxInterval
;
}
TransportSequenceNumberFeedbackGenenerator
:
:
~
TransportSequenceNumberFeedbackGenenerator
(
)
{
}
void
TransportSequenceNumberFeedbackGenenerator
:
:
MaybeCullOldPackets
(
int64_t
sequence_number
Timestamp
arrival_time
)
{
if
(
periodic_window_start_seq_
>
=
packet_arrival_times_
.
end_sequence_number
(
)
&
&
arrival_time
-
Timestamp
:
:
Zero
(
)
>
=
kBackWindow
)
{
packet_arrival_times_
.
RemoveOldPackets
(
sequence_number
arrival_time
-
kBackWindow
)
;
}
}
void
TransportSequenceNumberFeedbackGenenerator
:
:
OnReceivedPacket
(
const
RtpPacketReceived
&
packet
)
{
if
(
packet
.
arrival_time
(
)
.
IsInfinite
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Arrival
time
not
set
.
"
;
return
;
}
uint16_t
seqnum
=
0
;
std
:
:
optional
<
FeedbackRequest
>
feedback_request
;
if
(
!
packet
.
GetExtension
<
TransportSequenceNumber
>
(
&
seqnum
)
&
&
!
packet
.
GetExtension
<
TransportSequenceNumberV2
>
(
&
seqnum
&
feedback_request
)
)
{
RTC_DCHECK
(
packet
.
HasExtension
<
TransportSequenceNumber
>
(
)
|
|
packet
.
HasExtension
<
TransportSequenceNumberV2
>
(
)
)
<
<
"
Expected
transport
sequence
number
.
"
;
return
;
}
MutexLock
lock
(
&
lock_
)
;
send_periodic_feedback_
=
packet
.
HasExtension
<
TransportSequenceNumber
>
(
)
;
media_ssrc_
=
packet
.
Ssrc
(
)
;
int64_t
seq
=
unwrapper_
.
Unwrap
(
seqnum
)
;
if
(
send_periodic_feedback_
)
{
MaybeCullOldPackets
(
seq
packet
.
arrival_time
(
)
)
;
if
(
!
periodic_window_start_seq_
|
|
seq
<
*
periodic_window_start_seq_
)
{
periodic_window_start_seq_
=
seq
;
}
}
if
(
packet_arrival_times_
.
has_received
(
seq
)
)
{
return
;
}
packet_arrival_times_
.
AddPacket
(
seq
packet
.
arrival_time
(
)
)
;
if
(
periodic_window_start_seq_
<
packet_arrival_times_
.
begin_sequence_number
(
)
)
{
periodic_window_start_seq_
=
packet_arrival_times_
.
begin_sequence_number
(
)
;
}
if
(
feedback_request
.
has_value
(
)
)
{
SendFeedbackOnRequest
(
seq
*
feedback_request
)
;
}
}
TimeDelta
TransportSequenceNumberFeedbackGenenerator
:
:
Process
(
Timestamp
now
)
{
MutexLock
lock
(
&
lock_
)
;
if
(
!
send_periodic_feedback_
)
{
return
TimeDelta
:
:
PlusInfinity
(
)
;
}
Timestamp
next_process_time
=
last_process_time_
+
send_interval_
;
if
(
now
>
=
next_process_time
)
{
last_process_time_
=
now
;
SendPeriodicFeedbacks
(
)
;
return
send_interval_
;
}
return
next_process_time
-
now
;
}
void
TransportSequenceNumberFeedbackGenenerator
:
:
OnSendBandwidthEstimateChanged
(
DataRate
estimate
)
{
constexpr
DataSize
kTwccReportSize
=
DataSize
:
:
Bytes
(
20
+
8
+
10
+
30
)
;
constexpr
DataRate
kMinTwccRate
=
kTwccReportSize
/
kMaxInterval
;
DataRate
twcc_bitrate
=
0
.
05
*
estimate
;
TimeDelta
send_interval
=
twcc_bitrate
<
=
kMinTwccRate
?
kMaxInterval
:
std
:
:
max
(
kTwccReportSize
/
twcc_bitrate
kMinInterval
)
;
MutexLock
lock
(
&
lock_
)
;
send_interval_
=
send_interval
;
}
void
TransportSequenceNumberFeedbackGenenerator
:
:
SendPeriodicFeedbacks
(
)
{
if
(
!
periodic_window_start_seq_
)
return
;
int64_t
packet_arrival_times_end_seq
=
packet_arrival_times_
.
end_sequence_number
(
)
;
while
(
periodic_window_start_seq_
<
packet_arrival_times_end_seq
)
{
auto
feedback_packet
=
MaybeBuildFeedbackPacket
(
true
*
periodic_window_start_seq_
packet_arrival_times_end_seq
true
)
;
if
(
feedback_packet
=
=
nullptr
)
{
break
;
}
RTC_DCHECK
(
feedback_sender_
!
=
nullptr
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
rtcp
:
:
RtcpPacket
>
>
packets
;
packets
.
push_back
(
std
:
:
move
(
feedback_packet
)
)
;
feedback_sender_
(
std
:
:
move
(
packets
)
)
;
}
}
void
TransportSequenceNumberFeedbackGenenerator
:
:
SendFeedbackOnRequest
(
int64_t
sequence_number
const
FeedbackRequest
&
feedback_request
)
{
if
(
feedback_request
.
sequence_count
=
=
0
)
{
return
;
}
int64_t
first_sequence_number
=
sequence_number
-
feedback_request
.
sequence_count
+
1
;
auto
feedback_packet
=
MaybeBuildFeedbackPacket
(
feedback_request
.
include_timestamps
first_sequence_number
sequence_number
+
1
false
)
;
if
(
feedback_packet
=
=
nullptr
)
{
return
;
}
packet_arrival_times_
.
EraseTo
(
first_sequence_number
)
;
RTC_DCHECK
(
feedback_sender_
!
=
nullptr
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
rtcp
:
:
RtcpPacket
>
>
packets
;
packets
.
push_back
(
std
:
:
move
(
feedback_packet
)
)
;
feedback_sender_
(
std
:
:
move
(
packets
)
)
;
}
std
:
:
unique_ptr
<
rtcp
:
:
TransportFeedback
>
TransportSequenceNumberFeedbackGenenerator
:
:
MaybeBuildFeedbackPacket
(
bool
include_timestamps
int64_t
begin_sequence_number_inclusive
int64_t
end_sequence_number_exclusive
bool
is_periodic_update
)
{
RTC_DCHECK_LT
(
begin_sequence_number_inclusive
end_sequence_number_exclusive
)
;
int64_t
start_seq
=
packet_arrival_times_
.
clamp
(
begin_sequence_number_inclusive
)
;
int64_t
end_seq
=
packet_arrival_times_
.
clamp
(
end_sequence_number_exclusive
)
;
std
:
:
unique_ptr
<
rtcp
:
:
TransportFeedback
>
feedback_packet
;
int64_t
next_sequence_number
=
begin_sequence_number_inclusive
;
for
(
int64_t
seq
=
start_seq
;
seq
<
end_seq
;
+
+
seq
)
{
PacketArrivalTimeMap
:
:
PacketArrivalTime
packet
=
packet_arrival_times_
.
FindNextAtOrAfter
(
seq
)
;
seq
=
packet
.
sequence_number
;
if
(
seq
>
=
end_seq
)
{
break
;
}
if
(
feedback_packet
=
=
nullptr
)
{
feedback_packet
=
std
:
:
make_unique
<
rtcp
:
:
TransportFeedback
>
(
include_timestamps
)
;
feedback_packet
-
>
SetMediaSsrc
(
media_ssrc_
)
;
static
constexpr
int
kMaxMissingSequenceNumbers
=
0x7FFE
;
int64_t
base_sequence_number
=
std
:
:
max
(
begin_sequence_number_inclusive
seq
-
kMaxMissingSequenceNumbers
)
;
feedback_packet
-
>
SetBase
(
static_cast
<
uint16_t
>
(
base_sequence_number
)
packet
.
arrival_time
)
;
feedback_packet
-
>
SetFeedbackSequenceNumber
(
feedback_packet_count_
+
+
)
;
if
(
!
feedback_packet
-
>
AddReceivedPacket
(
static_cast
<
uint16_t
>
(
seq
)
packet
.
arrival_time
)
)
{
RTC_DCHECK_NOTREACHED
(
)
<
<
"
Failed
to
create
an
RTCP
transport
feedback
with
base
sequence
"
"
number
"
<
<
base_sequence_number
<
<
"
and
1st
received
"
<
<
seq
;
periodic_window_start_seq_
=
seq
;
return
nullptr
;
}
}
else
{
if
(
!
feedback_packet
-
>
AddReceivedPacket
(
static_cast
<
uint16_t
>
(
seq
)
packet
.
arrival_time
)
)
{
break
;
}
}
next_sequence_number
=
seq
+
1
;
}
if
(
is_periodic_update
)
{
periodic_window_start_seq_
=
next_sequence_number
;
}
return
feedback_packet
;
}
}
