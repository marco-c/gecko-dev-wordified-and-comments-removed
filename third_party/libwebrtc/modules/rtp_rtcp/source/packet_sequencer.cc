#
include
"
modules
/
rtp_rtcp
/
source
/
packet_sequencer
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
optional
>
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
namespace
{
constexpr
size_t
kRedForFecHeaderLength
=
1
;
constexpr
uint32_t
kTimestampTicksPerMs
=
90
;
}
PacketSequencer
:
:
PacketSequencer
(
uint32_t
media_ssrc
std
:
:
optional
<
uint32_t
>
rtx_ssrc
bool
require_marker_before_media_padding
Clock
*
clock
)
:
media_ssrc_
(
media_ssrc
)
rtx_ssrc_
(
rtx_ssrc
)
require_marker_before_media_padding_
(
require_marker_before_media_padding
)
clock_
(
clock
)
media_sequence_number_
(
0
)
rtx_sequence_number_
(
0
)
last_payload_type_
(
-
1
)
last_rtp_timestamp_
(
0
)
last_packet_marker_bit_
(
false
)
{
Random
random
(
clock_
-
>
TimeInMicroseconds
(
)
)
;
constexpr
uint16_t
kMaxInitRtpSeqNumber
=
0x7fff
;
media_sequence_number_
=
random
.
Rand
(
1
kMaxInitRtpSeqNumber
)
;
rtx_sequence_number_
=
random
.
Rand
(
1
kMaxInitRtpSeqNumber
)
;
}
void
PacketSequencer
:
:
Sequence
(
RtpPacketToSend
&
packet
)
{
if
(
packet
.
Ssrc
(
)
=
=
media_ssrc_
)
{
if
(
packet
.
packet_type
(
)
=
=
RtpPacketMediaType
:
:
kRetransmission
)
{
return
;
}
else
if
(
packet
.
packet_type
(
)
=
=
RtpPacketMediaType
:
:
kPadding
)
{
PopulatePaddingFields
(
packet
)
;
}
packet
.
SetSequenceNumber
(
media_sequence_number_
+
+
)
;
if
(
packet
.
packet_type
(
)
!
=
RtpPacketMediaType
:
:
kPadding
)
{
UpdateLastPacketState
(
packet
)
;
}
}
else
if
(
packet
.
Ssrc
(
)
=
=
rtx_ssrc_
)
{
if
(
packet
.
packet_type
(
)
=
=
RtpPacketMediaType
:
:
kPadding
)
{
PopulatePaddingFields
(
packet
)
;
}
packet
.
SetSequenceNumber
(
rtx_sequence_number_
+
+
)
;
}
else
{
RTC_DCHECK_NOTREACHED
(
)
<
<
"
Unexpected
ssrc
"
<
<
packet
.
Ssrc
(
)
;
}
}
void
PacketSequencer
:
:
SetRtpState
(
const
RtpState
&
state
)
{
media_sequence_number_
=
state
.
sequence_number
;
last_rtp_timestamp_
=
state
.
timestamp
;
last_capture_time_
=
state
.
capture_time
;
last_timestamp_time_
=
state
.
last_timestamp_time
;
}
void
PacketSequencer
:
:
PopulateRtpState
(
RtpState
&
state
)
const
{
state
.
sequence_number
=
media_sequence_number_
;
state
.
timestamp
=
last_rtp_timestamp_
;
state
.
capture_time
=
last_capture_time_
;
state
.
last_timestamp_time
=
last_timestamp_time_
;
}
void
PacketSequencer
:
:
UpdateLastPacketState
(
const
RtpPacketToSend
&
packet
)
{
last_packet_marker_bit_
=
packet
.
Marker
(
)
;
if
(
packet
.
is_red
(
)
)
{
RTC_DCHECK_GE
(
packet
.
payload_size
(
)
kRedForFecHeaderLength
)
;
last_payload_type_
=
packet
.
PayloadBuffer
(
)
[
0
]
;
}
else
{
last_payload_type_
=
packet
.
PayloadType
(
)
;
}
last_rtp_timestamp_
=
packet
.
Timestamp
(
)
;
last_timestamp_time_
=
clock_
-
>
CurrentTime
(
)
;
last_capture_time_
=
packet
.
capture_time
(
)
;
}
void
PacketSequencer
:
:
PopulatePaddingFields
(
RtpPacketToSend
&
packet
)
{
if
(
packet
.
Ssrc
(
)
=
=
media_ssrc_
)
{
RTC_DCHECK
(
CanSendPaddingOnMediaSsrc
(
)
)
;
packet
.
SetTimestamp
(
last_rtp_timestamp_
)
;
packet
.
set_capture_time
(
last_capture_time_
)
;
packet
.
SetPayloadType
(
last_payload_type_
)
;
return
;
}
RTC_DCHECK
(
packet
.
Ssrc
(
)
=
=
rtx_ssrc_
)
;
if
(
packet
.
payload_size
(
)
>
0
)
{
return
;
}
packet
.
SetTimestamp
(
last_rtp_timestamp_
)
;
packet
.
set_capture_time
(
last_capture_time_
)
;
if
(
last_timestamp_time_
>
Timestamp
:
:
Zero
(
)
)
{
TimeDelta
since_last_media
=
clock_
-
>
CurrentTime
(
)
-
last_timestamp_time_
;
packet
.
SetTimestamp
(
packet
.
Timestamp
(
)
+
since_last_media
.
ms
(
)
*
kTimestampTicksPerMs
)
;
if
(
packet
.
capture_time
(
)
>
Timestamp
:
:
Zero
(
)
)
{
packet
.
set_capture_time
(
packet
.
capture_time
(
)
+
since_last_media
)
;
}
}
}
bool
PacketSequencer
:
:
CanSendPaddingOnMediaSsrc
(
)
const
{
if
(
last_payload_type_
=
=
-
1
)
{
return
false
;
}
if
(
require_marker_before_media_padding_
&
&
!
last_packet_marker_bit_
)
{
return
false
;
}
return
true
;
}
}
