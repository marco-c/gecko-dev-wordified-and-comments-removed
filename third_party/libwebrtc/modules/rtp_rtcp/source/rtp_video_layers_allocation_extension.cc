#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_video_layers_allocation_extension
.
h
"
#
include
<
limits
>
#
include
"
api
/
video
/
video_layers_allocation
.
h
"
#
include
"
rtc_base
/
bit_buffer
.
h
"
namespace
webrtc
{
constexpr
RTPExtensionType
RtpVideoLayersAllocationExtension
:
:
kId
;
constexpr
const
char
RtpVideoLayersAllocationExtension
:
:
kUri
[
]
;
namespace
{
size_t
CountBits
(
uint64_t
val
)
{
size_t
bit_count
=
0
;
while
(
val
!
=
0
)
{
bit_count
+
+
;
val
>
>
=
1
;
}
return
bit_count
;
}
size_t
SizeExponentialGolomb
(
uint32_t
val
)
{
if
(
val
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
return
0
;
}
uint64_t
val_to_encode
=
static_cast
<
uint64_t
>
(
val
)
+
1
;
return
CountBits
(
val_to_encode
)
*
2
-
1
;
}
}
bool
RtpVideoLayersAllocationExtension
:
:
Write
(
rtc
:
:
ArrayView
<
uint8_t
>
data
const
VideoLayersAllocation
&
allocation
)
{
RTC_DCHECK_LT
(
allocation
.
rtp_stream_index
VideoLayersAllocation
:
:
kMaxSpatialIds
)
;
RTC_DCHECK_GE
(
data
.
size
(
)
ValueSize
(
allocation
)
)
;
rtc
:
:
BitBufferWriter
writer
(
data
.
data
(
)
data
.
size
(
)
)
;
if
(
allocation
.
active_spatial_layers
.
empty
(
)
)
return
false
;
writer
.
WriteBits
(
allocation
.
active_spatial_layers
.
size
(
)
-
1
2
)
;
writer
.
WriteBits
(
allocation
.
rtp_stream_index
2
)
;
bool
num_tls_is_the_same
=
true
;
size_t
first_layers_number_of_temporal_layers
=
allocation
.
active_spatial_layers
.
front
(
)
.
target_bitrate_per_temporal_layer
.
size
(
)
;
for
(
const
auto
&
spatial_layer
:
allocation
.
active_spatial_layers
)
{
if
(
first_layers_number_of_temporal_layers
!
=
spatial_layer
.
target_bitrate_per_temporal_layer
.
size
(
)
)
{
num_tls_is_the_same
=
false
;
break
;
}
}
writer
.
WriteBits
(
num_tls_is_the_same
?
1
:
0
1
)
;
writer
.
WriteBits
(
allocation
.
resolution_and_frame_rate_is_valid
?
1
:
0
1
)
;
writer
.
WriteBits
(
0
2
)
;
if
(
num_tls_is_the_same
)
{
writer
.
WriteBits
(
first_layers_number_of_temporal_layers
-
1
2
)
;
}
else
{
for
(
const
auto
&
spatial_layer
:
allocation
.
active_spatial_layers
)
{
writer
.
WriteBits
(
spatial_layer
.
target_bitrate_per_temporal_layer
.
size
(
)
-
1
2
)
;
}
}
for
(
const
auto
&
spatial_layer
:
allocation
.
active_spatial_layers
)
{
writer
.
WriteBits
(
spatial_layer
.
rtp_stream_index
2
)
;
writer
.
WriteBits
(
spatial_layer
.
spatial_id
2
)
;
for
(
const
DataRate
&
bitrate
:
spatial_layer
.
target_bitrate_per_temporal_layer
)
{
writer
.
WriteExponentialGolomb
(
bitrate
.
kbps
(
)
)
;
}
}
if
(
allocation
.
resolution_and_frame_rate_is_valid
)
{
for
(
const
auto
&
spatial_layer
:
allocation
.
active_spatial_layers
)
{
writer
.
WriteUInt16
(
spatial_layer
.
width
)
;
writer
.
WriteUInt16
(
spatial_layer
.
height
)
;
writer
.
WriteUInt8
(
spatial_layer
.
frame_rate_fps
)
;
}
}
return
true
;
}
bool
RtpVideoLayersAllocationExtension
:
:
Parse
(
rtc
:
:
ArrayView
<
const
uint8_t
>
data
VideoLayersAllocation
*
allocation
)
{
if
(
data
.
size
(
)
=
=
0
)
return
false
;
rtc
:
:
BitBuffer
reader
(
data
.
data
(
)
data
.
size
(
)
)
;
if
(
!
allocation
)
return
false
;
uint32_t
val
;
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
int
active_spatial_layers
=
val
+
1
;
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
allocation
-
>
rtp_stream_index
=
val
;
if
(
!
reader
.
ReadBits
(
&
val
1
)
)
return
false
;
bool
num_tls_is_constant
=
(
val
=
=
1
)
;
if
(
!
reader
.
ReadBits
(
&
val
1
)
)
return
false
;
allocation
-
>
resolution_and_frame_rate_is_valid
=
(
val
=
=
1
)
;
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
int
number_of_temporal_layers
[
VideoLayersAllocation
:
:
kMaxSpatialIds
]
;
if
(
num_tls_is_constant
)
{
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
for
(
int
sl_idx
=
0
;
sl_idx
<
active_spatial_layers
;
+
+
sl_idx
)
{
number_of_temporal_layers
[
sl_idx
]
=
val
+
1
;
}
}
else
{
for
(
int
sl_idx
=
0
;
sl_idx
<
active_spatial_layers
;
+
+
sl_idx
)
{
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
number_of_temporal_layers
[
sl_idx
]
=
val
+
1
;
if
(
number_of_temporal_layers
[
sl_idx
]
>
VideoLayersAllocation
:
:
kMaxTemporalIds
)
return
false
;
}
}
for
(
int
sl_idx
=
0
;
sl_idx
<
active_spatial_layers
;
+
+
sl_idx
)
{
allocation
-
>
active_spatial_layers
.
emplace_back
(
)
;
auto
&
spatial_layer
=
allocation
-
>
active_spatial_layers
.
back
(
)
;
auto
&
temporal_layers
=
spatial_layer
.
target_bitrate_per_temporal_layer
;
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
spatial_layer
.
rtp_stream_index
=
val
;
if
(
!
reader
.
ReadBits
(
&
val
2
)
)
return
false
;
spatial_layer
.
spatial_id
=
val
;
for
(
int
tl_idx
=
0
;
tl_idx
<
number_of_temporal_layers
[
sl_idx
]
;
+
+
tl_idx
)
{
reader
.
ReadExponentialGolomb
(
&
val
)
;
temporal_layers
.
push_back
(
DataRate
:
:
KilobitsPerSec
(
val
)
)
;
}
}
if
(
allocation
-
>
resolution_and_frame_rate_is_valid
)
{
for
(
auto
&
spatial_layer
:
allocation
-
>
active_spatial_layers
)
{
if
(
!
reader
.
ReadUInt16
(
&
spatial_layer
.
width
)
)
return
false
;
if
(
!
reader
.
ReadUInt16
(
&
spatial_layer
.
height
)
)
return
false
;
if
(
!
reader
.
ReadUInt8
(
&
spatial_layer
.
frame_rate_fps
)
)
return
false
;
}
}
return
true
;
}
size_t
RtpVideoLayersAllocationExtension
:
:
ValueSize
(
const
VideoLayersAllocation
&
allocation
)
{
if
(
allocation
.
active_spatial_layers
.
empty
(
)
)
{
return
0
;
}
size_t
size_in_bits
=
8
;
bool
num_tls_is_the_same
=
true
;
size_t
first_layers_number_of_temporal_layers
=
allocation
.
active_spatial_layers
.
front
(
)
.
target_bitrate_per_temporal_layer
.
size
(
)
;
for
(
const
auto
&
spatial_layer
:
allocation
.
active_spatial_layers
)
{
if
(
first_layers_number_of_temporal_layers
!
=
spatial_layer
.
target_bitrate_per_temporal_layer
.
size
(
)
)
{
num_tls_is_the_same
=
false
;
}
size_in_bits
+
=
4
;
for
(
const
auto
&
bitrate
:
spatial_layer
.
target_bitrate_per_temporal_layer
)
{
size_in_bits
+
=
SizeExponentialGolomb
(
bitrate
.
kbps
(
)
)
;
}
}
if
(
num_tls_is_the_same
)
{
size_in_bits
+
=
2
;
}
else
{
for
(
const
auto
&
spatial_layer
:
allocation
.
active_spatial_layers
)
{
size_in_bits
+
=
2
*
spatial_layer
.
target_bitrate_per_temporal_layer
.
size
(
)
;
}
}
if
(
allocation
.
resolution_and_frame_rate_is_valid
)
{
size_in_bits
+
=
allocation
.
active_spatial_layers
.
size
(
)
*
5
*
8
;
}
return
(
size_in_bits
+
7
)
/
8
;
}
}
