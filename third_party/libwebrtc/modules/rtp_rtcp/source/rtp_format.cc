#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format
.
h
"
#
include
<
memory
>
#
include
"
absl
/
types
/
variant
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format_h264
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format_video_generic
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format_vp8
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format_vp9
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packetizer_av1
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
h264
/
include
/
h264_globals
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp8
/
include
/
vp8_globals
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp9
/
include
/
vp9_globals
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
std
:
:
unique_ptr
<
RtpPacketizer
>
RtpPacketizer
:
:
Create
(
absl
:
:
optional
<
VideoCodecType
>
type
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
PayloadSizeLimits
limits
const
RTPVideoHeader
&
rtp_video_header
)
{
if
(
!
type
)
{
return
std
:
:
make_unique
<
RtpPacketizerGeneric
>
(
payload
limits
)
;
}
switch
(
*
type
)
{
case
kVideoCodecH264
:
{
const
auto
&
h264
=
absl
:
:
get
<
RTPVideoHeaderH264
>
(
rtp_video_header
.
video_type_header
)
;
return
std
:
:
make_unique
<
RtpPacketizerH264
>
(
payload
limits
h264
.
packetization_mode
)
;
}
case
kVideoCodecVP8
:
{
const
auto
&
vp8
=
absl
:
:
get
<
RTPVideoHeaderVP8
>
(
rtp_video_header
.
video_type_header
)
;
return
std
:
:
make_unique
<
RtpPacketizerVp8
>
(
payload
limits
vp8
)
;
}
case
kVideoCodecVP9
:
{
const
auto
&
vp9
=
absl
:
:
get
<
RTPVideoHeaderVP9
>
(
rtp_video_header
.
video_type_header
)
;
return
std
:
:
make_unique
<
RtpPacketizerVp9
>
(
payload
limits
vp9
)
;
}
case
kVideoCodecAV1
:
return
std
:
:
make_unique
<
RtpPacketizerAv1
>
(
payload
limits
rtp_video_header
.
frame_type
rtp_video_header
.
is_last_frame_in_picture
)
;
default
:
{
return
std
:
:
make_unique
<
RtpPacketizerGeneric
>
(
payload
limits
rtp_video_header
)
;
}
}
}
std
:
:
vector
<
int
>
RtpPacketizer
:
:
SplitAboutEqually
(
int
payload_len
const
PayloadSizeLimits
&
limits
)
{
RTC_DCHECK_GT
(
payload_len
0
)
;
RTC_DCHECK_GE
(
limits
.
first_packet_reduction_len
0
)
;
RTC_DCHECK_GE
(
limits
.
last_packet_reduction_len
0
)
;
std
:
:
vector
<
int
>
result
;
if
(
limits
.
max_payload_len
>
=
limits
.
single_packet_reduction_len
+
payload_len
)
{
result
.
push_back
(
payload_len
)
;
return
result
;
}
if
(
limits
.
max_payload_len
-
limits
.
first_packet_reduction_len
<
1
|
|
limits
.
max_payload_len
-
limits
.
last_packet_reduction_len
<
1
)
{
return
result
;
}
int
total_bytes
=
payload_len
+
limits
.
first_packet_reduction_len
+
limits
.
last_packet_reduction_len
;
int
num_packets_left
=
(
total_bytes
+
limits
.
max_payload_len
-
1
)
/
limits
.
max_payload_len
;
if
(
num_packets_left
=
=
1
)
{
num_packets_left
=
2
;
}
if
(
payload_len
<
num_packets_left
)
{
return
result
;
}
int
bytes_per_packet
=
total_bytes
/
num_packets_left
;
int
num_larger_packets
=
total_bytes
%
num_packets_left
;
int
remaining_data
=
payload_len
;
result
.
reserve
(
num_packets_left
)
;
bool
first_packet
=
true
;
while
(
remaining_data
>
0
)
{
if
(
num_packets_left
=
=
num_larger_packets
)
+
+
bytes_per_packet
;
int
current_packet_bytes
=
bytes_per_packet
;
if
(
first_packet
)
{
if
(
current_packet_bytes
>
limits
.
first_packet_reduction_len
+
1
)
current_packet_bytes
-
=
limits
.
first_packet_reduction_len
;
else
current_packet_bytes
=
1
;
}
if
(
current_packet_bytes
>
remaining_data
)
{
current_packet_bytes
=
remaining_data
;
}
if
(
num_packets_left
=
=
2
&
&
current_packet_bytes
=
=
remaining_data
)
{
-
-
current_packet_bytes
;
}
result
.
push_back
(
current_packet_bytes
)
;
remaining_data
-
=
current_packet_bytes
;
-
-
num_packets_left
;
first_packet
=
false
;
}
return
result
;
}
}
