#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_PACKET_RECEIVED_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_PACKET_RECEIVED_H_
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
api
/
ref_counted_base
.
h
"
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet
.
h
"
#
include
"
rtc_base
/
network
/
ecn_marking
.
h
"
namespace
webrtc
{
class
RtpPacketReceived
:
public
RtpPacket
{
public
:
RtpPacketReceived
(
)
;
explicit
RtpPacketReceived
(
const
ExtensionManager
*
extensions
webrtc
:
:
Timestamp
arrival_time
=
webrtc
:
:
Timestamp
:
:
MinusInfinity
(
)
)
;
RtpPacketReceived
(
const
RtpPacketReceived
&
packet
)
;
RtpPacketReceived
(
RtpPacketReceived
&
&
packet
)
;
RtpPacketReceived
&
operator
=
(
const
RtpPacketReceived
&
packet
)
;
RtpPacketReceived
&
operator
=
(
RtpPacketReceived
&
&
packet
)
;
~
RtpPacketReceived
(
)
;
void
GetHeader
(
RTPHeader
*
header
)
const
;
webrtc
:
:
Timestamp
arrival_time
(
)
const
{
return
arrival_time_
;
}
void
set_arrival_time
(
webrtc
:
:
Timestamp
time
)
{
arrival_time_
=
time
;
}
EcnMarking
ecn
(
)
const
{
return
ecn_
;
}
void
set_ecn
(
EcnMarking
ecn
)
{
ecn_
=
ecn
;
}
bool
recovered
(
)
const
{
return
recovered_
;
}
void
set_recovered
(
bool
value
)
{
recovered_
=
value
;
}
int
payload_type_frequency
(
)
const
{
return
payload_type_frequency_
;
}
void
set_payload_type_frequency
(
int
value
)
{
payload_type_frequency_
=
value
;
}
scoped_refptr
<
RefCountedBase
>
additional_data
(
)
const
{
return
additional_data_
;
}
void
set_additional_data
(
scoped_refptr
<
RefCountedBase
>
data
)
{
additional_data_
=
std
:
:
move
(
data
)
;
}
private
:
webrtc
:
:
Timestamp
arrival_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
EcnMarking
ecn_
=
EcnMarking
:
:
kNotEct
;
int
payload_type_frequency_
=
0
;
bool
recovered_
=
false
;
scoped_refptr
<
RefCountedBase
>
additional_data_
;
}
;
}
#
endif
