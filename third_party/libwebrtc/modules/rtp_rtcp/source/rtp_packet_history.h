#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_PACKET_HISTORY_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_PACKET_HISTORY_H_
#
include
<
deque
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
vector
>
#
include
"
api
/
function_view
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
Clock
;
class
RtpPacketToSend
;
class
RtpPacketHistory
{
public
:
enum
class
StorageMode
{
kDisabled
kStoreAndCull
}
;
static
constexpr
size_t
kMaxCapacity
=
9600
;
static
constexpr
size_t
kMaxPaddingHistory
=
63
;
static
constexpr
int64_t
kMinPacketDurationMs
=
1000
;
static
constexpr
int
kMinPacketDurationRtt
=
3
;
static
constexpr
int
kPacketCullingDelayFactor
=
3
;
RtpPacketHistory
(
Clock
*
clock
bool
enable_padding_prio
)
;
RtpPacketHistory
(
)
=
delete
;
RtpPacketHistory
(
const
RtpPacketHistory
&
)
=
delete
;
RtpPacketHistory
&
operator
=
(
const
RtpPacketHistory
&
)
=
delete
;
~
RtpPacketHistory
(
)
;
void
SetStorePacketsStatus
(
StorageMode
mode
size_t
number_to_store
)
;
StorageMode
GetStorageMode
(
)
const
;
void
SetRtt
(
int64_t
rtt_ms
)
;
void
PutRtpPacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
int64_t
send_time_ms
)
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
GetPacketAndMarkAsPending
(
uint16_t
sequence_number
)
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
GetPacketAndMarkAsPending
(
uint16_t
sequence_number
rtc
:
:
FunctionView
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
(
const
RtpPacketToSend
&
)
>
encapsulate
)
;
void
MarkPacketAsSent
(
uint16_t
sequence_number
)
;
bool
GetPacketState
(
uint16_t
sequence_number
)
const
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
GetPayloadPaddingPacket
(
)
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
GetPayloadPaddingPacket
(
rtc
:
:
FunctionView
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
(
const
RtpPacketToSend
&
)
>
encapsulate
)
;
void
CullAcknowledgedPackets
(
rtc
:
:
ArrayView
<
const
uint16_t
>
sequence_numbers
)
;
void
Clear
(
)
;
private
:
struct
MoreUseful
;
class
StoredPacket
;
using
PacketPrioritySet
=
std
:
:
set
<
StoredPacket
*
MoreUseful
>
;
class
StoredPacket
{
public
:
StoredPacket
(
)
=
default
;
StoredPacket
(
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet
int64_t
send_time_ms
uint64_t
insert_order
)
;
StoredPacket
(
StoredPacket
&
&
)
;
StoredPacket
&
operator
=
(
StoredPacket
&
&
)
;
~
StoredPacket
(
)
;
uint64_t
insert_order
(
)
const
{
return
insert_order_
;
}
size_t
times_retransmitted
(
)
const
{
return
times_retransmitted_
;
}
void
IncrementTimesRetransmitted
(
PacketPrioritySet
*
priority_set
)
;
int64_t
send_time_ms_
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
packet_
;
bool
pending_transmission_
;
private
:
uint64_t
insert_order_
;
size_t
times_retransmitted_
;
}
;
struct
MoreUseful
{
bool
operator
(
)
(
StoredPacket
*
lhs
StoredPacket
*
rhs
)
const
;
}
;
bool
VerifyRtt
(
const
StoredPacket
&
packet
int64_t
now_ms
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
void
Reset
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
void
CullOldPackets
(
int64_t
now_ms
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
std
:
:
unique_ptr
<
RtpPacketToSend
>
RemovePacket
(
int
packet_index
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
int
GetPacketIndex
(
uint16_t
sequence_number
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
StoredPacket
*
GetStoredPacket
(
uint16_t
sequence_number
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
lock_
)
;
Clock
*
const
clock_
;
const
bool
enable_padding_prio_
;
mutable
Mutex
lock_
;
size_t
number_to_store_
RTC_GUARDED_BY
(
lock_
)
;
StorageMode
mode_
RTC_GUARDED_BY
(
lock_
)
;
int64_t
rtt_ms_
RTC_GUARDED_BY
(
lock_
)
;
std
:
:
deque
<
StoredPacket
>
packet_history_
RTC_GUARDED_BY
(
lock_
)
;
uint64_t
packets_inserted_
RTC_GUARDED_BY
(
lock_
)
;
PacketPrioritySet
padding_priority_
RTC_GUARDED_BY
(
lock_
)
;
}
;
}
#
endif
