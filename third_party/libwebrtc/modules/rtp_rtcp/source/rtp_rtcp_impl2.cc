#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_rtcp_impl2
.
h
"
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
api
/
transport
/
field_trial_based_config
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
dlrr
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_rtcp_config
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
ifdef
_WIN32
#
pragma
warning
(
disable
:
4355
)
#
endif
namespace
webrtc
{
namespace
{
const
int64_t
kRtpRtcpMaxIdleTimeProcessMs
=
5
;
const
int64_t
kDefaultExpectedRetransmissionTimeMs
=
125
;
constexpr
TimeDelta
kRttUpdateInterval
=
TimeDelta
:
:
Millis
(
1000
)
;
}
ModuleRtpRtcpImpl2
:
:
RtpSenderContext
:
:
RtpSenderContext
(
const
RtpRtcpInterface
:
:
Configuration
&
config
)
:
packet_history
(
config
.
clock
config
.
enable_rtx_padding_prioritization
)
packet_sender
(
config
&
packet_history
)
non_paced_sender
(
&
packet_sender
this
)
packet_generator
(
config
&
packet_history
config
.
paced_sender
?
config
.
paced_sender
:
&
non_paced_sender
)
{
}
void
ModuleRtpRtcpImpl2
:
:
RtpSenderContext
:
:
AssignSequenceNumber
(
RtpPacketToSend
*
packet
)
{
packet_generator
.
AssignSequenceNumber
(
packet
)
;
}
ModuleRtpRtcpImpl2
:
:
ModuleRtpRtcpImpl2
(
const
Configuration
&
configuration
)
:
worker_queue_
(
configuration
.
task_queue
)
rtcp_sender_
(
configuration
)
rtcp_receiver_
(
configuration
this
)
clock_
(
configuration
.
clock
)
last_rtt_process_time_
(
clock_
-
>
TimeInMilliseconds
(
)
)
next_process_time_
(
clock_
-
>
TimeInMilliseconds
(
)
+
kRtpRtcpMaxIdleTimeProcessMs
)
packet_overhead_
(
28
)
nack_last_time_sent_full_ms_
(
0
)
nack_last_seq_number_sent_
(
0
)
remote_bitrate_
(
configuration
.
remote_bitrate_estimator
)
rtt_stats_
(
configuration
.
rtt_stats
)
rtt_ms_
(
0
)
{
process_thread_checker_
.
Detach
(
)
;
if
(
!
configuration
.
receiver_only
)
{
rtp_sender_
=
std
:
:
make_unique
<
RtpSenderContext
>
(
configuration
)
;
rtcp_sender_
.
SetTimestampOffset
(
rtp_sender_
-
>
packet_generator
.
TimestampOffset
(
)
)
;
}
const
size_t
kTcpOverIpv4HeaderSize
=
40
;
SetMaxRtpPacketSize
(
IP_PACKET_SIZE
-
kTcpOverIpv4HeaderSize
)
;
if
(
rtt_stats_
)
{
RTC_DCHECK
(
worker_queue_
)
;
rtt_update_task_
=
RepeatingTaskHandle
:
:
DelayedStart
(
worker_queue_
kRttUpdateInterval
[
this
]
(
)
{
PeriodicUpdate
(
)
;
return
kRttUpdateInterval
;
}
)
;
}
}
ModuleRtpRtcpImpl2
:
:
~
ModuleRtpRtcpImpl2
(
)
{
if
(
worker_queue_
)
{
RTC_DCHECK_RUN_ON
(
worker_queue_
)
;
rtt_update_task_
.
Stop
(
)
;
}
}
int64_t
ModuleRtpRtcpImpl2
:
:
TimeUntilNextProcess
(
)
{
RTC_DCHECK_RUN_ON
(
&
process_thread_checker_
)
;
return
std
:
:
max
<
int64_t
>
(
0
next_process_time_
-
clock_
-
>
TimeInMilliseconds
(
)
)
;
}
void
ModuleRtpRtcpImpl2
:
:
Process
(
)
{
RTC_DCHECK_RUN_ON
(
&
process_thread_checker_
)
;
const
Timestamp
now
=
clock_
-
>
CurrentTime
(
)
;
next_process_time_
=
now
.
ms
(
)
+
kRtpRtcpMaxIdleTimeProcessMs
;
if
(
remote_bitrate_
&
&
rtcp_sender_
.
Sending
(
)
&
&
rtcp_sender_
.
TMMBR
(
)
)
{
unsigned
int
target_bitrate
=
0
;
std
:
:
vector
<
unsigned
int
>
ssrcs
;
if
(
remote_bitrate_
-
>
LatestEstimate
(
&
ssrcs
&
target_bitrate
)
)
{
if
(
!
ssrcs
.
empty
(
)
)
{
target_bitrate
=
target_bitrate
/
ssrcs
.
size
(
)
;
}
rtcp_sender_
.
SetTargetBitrate
(
target_bitrate
)
;
}
}
if
(
rtcp_sender_
.
TimeToSendRTCPReport
(
)
)
rtcp_sender_
.
SendRTCP
(
GetFeedbackState
(
)
kRtcpReport
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRtxSendStatus
(
int
mode
)
{
rtp_sender_
-
>
packet_generator
.
SetRtxStatus
(
mode
)
;
}
int
ModuleRtpRtcpImpl2
:
:
RtxSendStatus
(
)
const
{
return
rtp_sender_
?
rtp_sender_
-
>
packet_generator
.
RtxStatus
(
)
:
kRtxOff
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRtxSendPayloadType
(
int
payload_type
int
associated_payload_type
)
{
rtp_sender_
-
>
packet_generator
.
SetRtxPayloadType
(
payload_type
associated_payload_type
)
;
}
absl
:
:
optional
<
uint32_t
>
ModuleRtpRtcpImpl2
:
:
RtxSsrc
(
)
const
{
return
rtp_sender_
?
rtp_sender_
-
>
packet_generator
.
RtxSsrc
(
)
:
absl
:
:
nullopt
;
}
absl
:
:
optional
<
uint32_t
>
ModuleRtpRtcpImpl2
:
:
FlexfecSsrc
(
)
const
{
if
(
rtp_sender_
)
{
return
rtp_sender_
-
>
packet_generator
.
FlexfecSsrc
(
)
;
}
return
absl
:
:
nullopt
;
}
void
ModuleRtpRtcpImpl2
:
:
IncomingRtcpPacket
(
const
uint8_t
*
rtcp_packet
const
size_t
length
)
{
rtcp_receiver_
.
IncomingPacket
(
rtcp_packet
length
)
;
}
void
ModuleRtpRtcpImpl2
:
:
RegisterSendPayloadFrequency
(
int
payload_type
int
payload_frequency
)
{
rtcp_sender_
.
SetRtpClockRate
(
payload_type
payload_frequency
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
DeRegisterSendPayload
(
const
int8_t
payload_type
)
{
return
0
;
}
uint32_t
ModuleRtpRtcpImpl2
:
:
StartTimestamp
(
)
const
{
return
rtp_sender_
-
>
packet_generator
.
TimestampOffset
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetStartTimestamp
(
const
uint32_t
timestamp
)
{
rtcp_sender_
.
SetTimestampOffset
(
timestamp
)
;
rtp_sender_
-
>
packet_generator
.
SetTimestampOffset
(
timestamp
)
;
rtp_sender_
-
>
packet_sender
.
SetTimestampOffset
(
timestamp
)
;
}
uint16_t
ModuleRtpRtcpImpl2
:
:
SequenceNumber
(
)
const
{
return
rtp_sender_
-
>
packet_generator
.
SequenceNumber
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetSequenceNumber
(
const
uint16_t
seq_num
)
{
rtp_sender_
-
>
packet_generator
.
SetSequenceNumber
(
seq_num
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRtpState
(
const
RtpState
&
rtp_state
)
{
rtp_sender_
-
>
packet_generator
.
SetRtpState
(
rtp_state
)
;
rtcp_sender_
.
SetTimestampOffset
(
rtp_state
.
start_timestamp
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRtxState
(
const
RtpState
&
rtp_state
)
{
rtp_sender_
-
>
packet_generator
.
SetRtxRtpState
(
rtp_state
)
;
}
RtpState
ModuleRtpRtcpImpl2
:
:
GetRtpState
(
)
const
{
RtpState
state
=
rtp_sender_
-
>
packet_generator
.
GetRtpState
(
)
;
return
state
;
}
RtpState
ModuleRtpRtcpImpl2
:
:
GetRtxState
(
)
const
{
return
rtp_sender_
-
>
packet_generator
.
GetRtxRtpState
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRid
(
const
std
:
:
string
&
rid
)
{
if
(
rtp_sender_
)
{
rtp_sender_
-
>
packet_generator
.
SetRid
(
rid
)
;
}
}
void
ModuleRtpRtcpImpl2
:
:
SetMid
(
const
std
:
:
string
&
mid
)
{
if
(
rtp_sender_
)
{
rtp_sender_
-
>
packet_generator
.
SetMid
(
mid
)
;
}
}
void
ModuleRtpRtcpImpl2
:
:
SetCsrcs
(
const
std
:
:
vector
<
uint32_t
>
&
csrcs
)
{
rtcp_sender_
.
SetCsrcs
(
csrcs
)
;
rtp_sender_
-
>
packet_generator
.
SetCsrcs
(
csrcs
)
;
}
RTCPSender
:
:
FeedbackState
ModuleRtpRtcpImpl2
:
:
GetFeedbackState
(
)
{
RTCPSender
:
:
FeedbackState
state
;
if
(
rtp_sender_
)
{
StreamDataCounters
rtp_stats
;
StreamDataCounters
rtx_stats
;
rtp_sender_
-
>
packet_sender
.
GetDataCounters
(
&
rtp_stats
&
rtx_stats
)
;
state
.
packets_sent
=
rtp_stats
.
transmitted
.
packets
+
rtx_stats
.
transmitted
.
packets
;
state
.
media_bytes_sent
=
rtp_stats
.
transmitted
.
payload_bytes
+
rtx_stats
.
transmitted
.
payload_bytes
;
state
.
send_bitrate
=
rtp_sender_
-
>
packet_sender
.
GetSendRates
(
)
.
Sum
(
)
.
bps
<
uint32_t
>
(
)
;
}
state
.
receiver
=
&
rtcp_receiver_
;
uint32_t
received_ntp_secs
=
0
;
uint32_t
received_ntp_frac
=
0
;
state
.
remote_sr
=
0
;
if
(
rtcp_receiver_
.
NTP
(
&
received_ntp_secs
&
received_ntp_frac
&
state
.
last_rr_ntp_secs
&
state
.
last_rr_ntp_frac
nullptr
nullptr
nullptr
nullptr
)
)
{
state
.
remote_sr
=
(
(
received_ntp_secs
&
0x0000ffff
)
<
<
16
)
+
(
(
received_ntp_frac
&
0xffff0000
)
>
>
16
)
;
}
state
.
last_xr_rtis
=
rtcp_receiver_
.
ConsumeReceivedXrReferenceTimeInfo
(
)
;
return
state
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
SetSendingStatus
(
const
bool
sending
)
{
if
(
rtcp_sender_
.
Sending
(
)
!
=
sending
)
{
if
(
rtcp_sender_
.
SetSendingStatus
(
GetFeedbackState
(
)
sending
)
!
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
send
RTCP
BYE
"
;
}
}
return
0
;
}
bool
ModuleRtpRtcpImpl2
:
:
Sending
(
)
const
{
return
rtcp_sender_
.
Sending
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetSendingMediaStatus
(
const
bool
sending
)
{
if
(
rtp_sender_
)
{
rtp_sender_
-
>
packet_generator
.
SetSendingMediaStatus
(
sending
)
;
}
else
{
RTC_DCHECK
(
!
sending
)
;
}
}
bool
ModuleRtpRtcpImpl2
:
:
SendingMedia
(
)
const
{
return
rtp_sender_
?
rtp_sender_
-
>
packet_generator
.
SendingMedia
(
)
:
false
;
}
bool
ModuleRtpRtcpImpl2
:
:
IsAudioConfigured
(
)
const
{
return
rtp_sender_
?
rtp_sender_
-
>
packet_generator
.
IsAudioConfigured
(
)
:
false
;
}
void
ModuleRtpRtcpImpl2
:
:
SetAsPartOfAllocation
(
bool
part_of_allocation
)
{
RTC_CHECK
(
rtp_sender_
)
;
rtp_sender_
-
>
packet_sender
.
ForceIncludeSendPacketsInAllocation
(
part_of_allocation
)
;
}
bool
ModuleRtpRtcpImpl2
:
:
OnSendingRtpFrame
(
uint32_t
timestamp
int64_t
capture_time_ms
int
payload_type
bool
force_sender_report
)
{
if
(
!
Sending
(
)
)
return
false
;
rtcp_sender_
.
SetLastRtpTime
(
timestamp
capture_time_ms
payload_type
)
;
if
(
rtcp_sender_
.
TimeToSendRTCPReport
(
force_sender_report
)
)
rtcp_sender_
.
SendRTCP
(
GetFeedbackState
(
)
kRtcpReport
)
;
return
true
;
}
bool
ModuleRtpRtcpImpl2
:
:
TrySendPacket
(
RtpPacketToSend
*
packet
const
PacedPacketInfo
&
pacing_info
)
{
RTC_DCHECK
(
rtp_sender_
)
;
if
(
!
rtp_sender_
-
>
packet_generator
.
SendingMedia
(
)
)
{
return
false
;
}
rtp_sender_
-
>
packet_sender
.
SendPacket
(
packet
pacing_info
)
;
return
true
;
}
void
ModuleRtpRtcpImpl2
:
:
SetFecProtectionParams
(
const
FecProtectionParams
&
delta_params
const
FecProtectionParams
&
key_params
)
{
RTC_DCHECK
(
rtp_sender_
)
;
rtp_sender_
-
>
packet_sender
.
SetFecProtectionParameters
(
delta_params
key_params
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
ModuleRtpRtcpImpl2
:
:
FetchFecPackets
(
)
{
RTC_DCHECK
(
rtp_sender_
)
;
auto
fec_packets
=
rtp_sender_
-
>
packet_sender
.
FetchFecPackets
(
)
;
if
(
!
fec_packets
.
empty
(
)
)
{
const
bool
generate_sequence_numbers
=
!
rtp_sender_
-
>
packet_sender
.
FlexFecSsrc
(
)
.
has_value
(
)
;
if
(
generate_sequence_numbers
)
{
for
(
auto
&
fec_packet
:
fec_packets
)
{
rtp_sender_
-
>
packet_generator
.
AssignSequenceNumber
(
fec_packet
.
get
(
)
)
;
}
}
}
return
fec_packets
;
}
void
ModuleRtpRtcpImpl2
:
:
OnPacketsAcknowledged
(
rtc
:
:
ArrayView
<
const
uint16_t
>
sequence_numbers
)
{
RTC_DCHECK
(
rtp_sender_
)
;
rtp_sender_
-
>
packet_history
.
CullAcknowledgedPackets
(
sequence_numbers
)
;
}
bool
ModuleRtpRtcpImpl2
:
:
SupportsPadding
(
)
const
{
RTC_DCHECK
(
rtp_sender_
)
;
return
rtp_sender_
-
>
packet_generator
.
SupportsPadding
(
)
;
}
bool
ModuleRtpRtcpImpl2
:
:
SupportsRtxPayloadPadding
(
)
const
{
RTC_DCHECK
(
rtp_sender_
)
;
return
rtp_sender_
-
>
packet_generator
.
SupportsRtxPayloadPadding
(
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RtpPacketToSend
>
>
ModuleRtpRtcpImpl2
:
:
GeneratePadding
(
size_t
target_size_bytes
)
{
RTC_DCHECK
(
rtp_sender_
)
;
return
rtp_sender_
-
>
packet_generator
.
GeneratePadding
(
target_size_bytes
rtp_sender_
-
>
packet_sender
.
MediaHasBeenSent
(
)
)
;
}
std
:
:
vector
<
RtpSequenceNumberMap
:
:
Info
>
ModuleRtpRtcpImpl2
:
:
GetSentRtpPacketInfos
(
rtc
:
:
ArrayView
<
const
uint16_t
>
sequence_numbers
)
const
{
RTC_DCHECK
(
rtp_sender_
)
;
return
rtp_sender_
-
>
packet_sender
.
GetSentRtpPacketInfos
(
sequence_numbers
)
;
}
size_t
ModuleRtpRtcpImpl2
:
:
ExpectedPerPacketOverhead
(
)
const
{
if
(
!
rtp_sender_
)
{
return
0
;
}
return
rtp_sender_
-
>
packet_generator
.
ExpectedPerPacketOverhead
(
)
;
}
size_t
ModuleRtpRtcpImpl2
:
:
MaxRtpPacketSize
(
)
const
{
RTC_DCHECK
(
rtp_sender_
)
;
return
rtp_sender_
-
>
packet_generator
.
MaxRtpPacketSize
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetMaxRtpPacketSize
(
size_t
rtp_packet_size
)
{
RTC_DCHECK_LE
(
rtp_packet_size
IP_PACKET_SIZE
)
<
<
"
rtp
packet
size
too
large
:
"
<
<
rtp_packet_size
;
RTC_DCHECK_GT
(
rtp_packet_size
packet_overhead_
)
<
<
"
rtp
packet
size
too
small
:
"
<
<
rtp_packet_size
;
rtcp_sender_
.
SetMaxRtpPacketSize
(
rtp_packet_size
)
;
if
(
rtp_sender_
)
{
rtp_sender_
-
>
packet_generator
.
SetMaxRtpPacketSize
(
rtp_packet_size
)
;
}
}
RtcpMode
ModuleRtpRtcpImpl2
:
:
RTCP
(
)
const
{
return
rtcp_sender_
.
Status
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRTCPStatus
(
const
RtcpMode
method
)
{
rtcp_sender_
.
SetRTCPStatus
(
method
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
SetCNAME
(
const
char
*
c_name
)
{
return
rtcp_sender_
.
SetCNAME
(
c_name
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
RemoteNTP
(
uint32_t
*
received_ntpsecs
uint32_t
*
received_ntpfrac
uint32_t
*
rtcp_arrival_time_secs
uint32_t
*
rtcp_arrival_time_frac
uint32_t
*
rtcp_timestamp
)
const
{
return
rtcp_receiver_
.
NTP
(
received_ntpsecs
received_ntpfrac
rtcp_arrival_time_secs
rtcp_arrival_time_frac
rtcp_timestamp
nullptr
nullptr
nullptr
)
?
0
:
-
1
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
RTT
(
const
uint32_t
remote_ssrc
int64_t
*
rtt
int64_t
*
avg_rtt
int64_t
*
min_rtt
int64_t
*
max_rtt
)
const
{
int32_t
ret
=
rtcp_receiver_
.
RTT
(
remote_ssrc
rtt
avg_rtt
min_rtt
max_rtt
)
;
if
(
rtt
&
&
*
rtt
=
=
0
)
{
*
rtt
=
rtt_ms
(
)
;
}
return
ret
;
}
int64_t
ModuleRtpRtcpImpl2
:
:
ExpectedRetransmissionTimeMs
(
)
const
{
int64_t
expected_retransmission_time_ms
=
rtt_ms
(
)
;
if
(
expected_retransmission_time_ms
>
0
)
{
return
expected_retransmission_time_ms
;
}
if
(
rtcp_receiver_
.
RTT
(
rtcp_receiver_
.
RemoteSSRC
(
)
nullptr
&
expected_retransmission_time_ms
nullptr
nullptr
)
=
=
0
)
{
return
expected_retransmission_time_ms
;
}
return
kDefaultExpectedRetransmissionTimeMs
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
SendRTCP
(
RTCPPacketType
packet_type
)
{
return
rtcp_sender_
.
SendRTCP
(
GetFeedbackState
(
)
packet_type
)
;
}
void
ModuleRtpRtcpImpl2
:
:
GetSendStreamDataCounters
(
StreamDataCounters
*
rtp_counters
StreamDataCounters
*
rtx_counters
)
const
{
rtp_sender_
-
>
packet_sender
.
GetDataCounters
(
rtp_counters
rtx_counters
)
;
}
void
ModuleRtpRtcpImpl2
:
:
RemoteRTCPSenderInfo
(
uint32_t
*
packet_count
uint32_t
*
octet_count
int64_t
*
ntp_timestamp_ms
int64_t
*
remote_ntp_timestamp_ms
)
const
{
return
rtcp_receiver_
.
RemoteRTCPSenderInfo
(
packet_count
octet_count
ntp_timestamp_ms
remote_ntp_timestamp_ms
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
RemoteRTCPStat
(
std
:
:
vector
<
RTCPReportBlock
>
*
receive_blocks
)
const
{
return
rtcp_receiver_
.
StatisticsReceived
(
receive_blocks
)
;
}
std
:
:
vector
<
ReportBlockData
>
ModuleRtpRtcpImpl2
:
:
GetLatestReportBlockData
(
)
const
{
return
rtcp_receiver_
.
GetLatestReportBlockData
(
)
;
}
absl
:
:
optional
<
RtpRtcpInterface
:
:
SenderReportStats
>
ModuleRtpRtcpImpl2
:
:
GetSenderReportStats
(
)
const
{
SenderReportStats
stats
;
uint32_t
remote_timestamp_secs
;
uint32_t
remote_timestamp_frac
;
uint32_t
arrival_timestamp_secs
;
uint32_t
arrival_timestamp_frac
;
if
(
rtcp_receiver_
.
NTP
(
&
remote_timestamp_secs
&
remote_timestamp_frac
&
arrival_timestamp_secs
&
arrival_timestamp_frac
nullptr
&
stats
.
packets_sent
&
stats
.
bytes_sent
&
stats
.
reports_count
)
)
{
stats
.
last_remote_timestamp
.
Set
(
remote_timestamp_secs
remote_timestamp_frac
)
;
stats
.
last_arrival_timestamp
.
Set
(
arrival_timestamp_secs
arrival_timestamp_frac
)
;
return
stats
;
}
return
absl
:
:
nullopt
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRemb
(
int64_t
bitrate_bps
std
:
:
vector
<
uint32_t
>
ssrcs
)
{
rtcp_sender_
.
SetRemb
(
bitrate_bps
std
:
:
move
(
ssrcs
)
)
;
}
void
ModuleRtpRtcpImpl2
:
:
UnsetRemb
(
)
{
rtcp_sender_
.
UnsetRemb
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetExtmapAllowMixed
(
bool
extmap_allow_mixed
)
{
rtp_sender_
-
>
packet_generator
.
SetExtmapAllowMixed
(
extmap_allow_mixed
)
;
}
void
ModuleRtpRtcpImpl2
:
:
RegisterRtpHeaderExtension
(
absl
:
:
string_view
uri
int
id
)
{
bool
registered
=
rtp_sender_
-
>
packet_generator
.
RegisterRtpHeaderExtension
(
uri
id
)
;
RTC_CHECK
(
registered
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
DeregisterSendRtpHeaderExtension
(
const
RTPExtensionType
type
)
{
return
rtp_sender_
-
>
packet_generator
.
DeregisterRtpHeaderExtension
(
type
)
;
}
void
ModuleRtpRtcpImpl2
:
:
DeregisterSendRtpHeaderExtension
(
absl
:
:
string_view
uri
)
{
rtp_sender_
-
>
packet_generator
.
DeregisterRtpHeaderExtension
(
uri
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetTmmbn
(
std
:
:
vector
<
rtcp
:
:
TmmbItem
>
bounding_set
)
{
rtcp_sender_
.
SetTmmbn
(
std
:
:
move
(
bounding_set
)
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
SendNACK
(
const
uint16_t
*
nack_list
const
uint16_t
size
)
{
uint16_t
nack_length
=
size
;
uint16_t
start_id
=
0
;
int64_t
now_ms
=
clock_
-
>
TimeInMilliseconds
(
)
;
if
(
TimeToSendFullNackList
(
now_ms
)
)
{
nack_last_time_sent_full_ms_
=
now_ms
;
}
else
{
if
(
nack_last_seq_number_sent_
=
=
nack_list
[
size
-
1
]
)
{
return
0
;
}
for
(
int
i
=
0
;
i
<
size
;
+
+
i
)
{
if
(
nack_last_seq_number_sent_
=
=
nack_list
[
i
]
)
{
start_id
=
i
+
1
;
break
;
}
}
nack_length
=
size
-
start_id
;
}
if
(
nack_length
>
kRtcpMaxNackFields
)
{
nack_length
=
kRtcpMaxNackFields
;
}
nack_last_seq_number_sent_
=
nack_list
[
start_id
+
nack_length
-
1
]
;
return
rtcp_sender_
.
SendRTCP
(
GetFeedbackState
(
)
kRtcpNack
nack_length
&
nack_list
[
start_id
]
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SendNack
(
const
std
:
:
vector
<
uint16_t
>
&
sequence_numbers
)
{
rtcp_sender_
.
SendRTCP
(
GetFeedbackState
(
)
kRtcpNack
sequence_numbers
.
size
(
)
sequence_numbers
.
data
(
)
)
;
}
bool
ModuleRtpRtcpImpl2
:
:
TimeToSendFullNackList
(
int64_t
now
)
const
{
int64_t
rtt
=
rtt_ms
(
)
;
if
(
rtt
=
=
0
)
{
rtcp_receiver_
.
RTT
(
rtcp_receiver_
.
RemoteSSRC
(
)
NULL
&
rtt
NULL
NULL
)
;
}
const
int64_t
kStartUpRttMs
=
100
;
int64_t
wait_time
=
5
+
(
(
rtt
*
3
)
>
>
1
)
;
if
(
rtt
=
=
0
)
{
wait_time
=
kStartUpRttMs
;
}
return
now
-
nack_last_time_sent_full_ms_
>
wait_time
;
}
void
ModuleRtpRtcpImpl2
:
:
SetStorePacketsStatus
(
const
bool
enable
const
uint16_t
number_to_store
)
{
rtp_sender_
-
>
packet_history
.
SetStorePacketsStatus
(
enable
?
RtpPacketHistory
:
:
StorageMode
:
:
kStoreAndCull
:
RtpPacketHistory
:
:
StorageMode
:
:
kDisabled
number_to_store
)
;
}
bool
ModuleRtpRtcpImpl2
:
:
StorePackets
(
)
const
{
return
rtp_sender_
-
>
packet_history
.
GetStorageMode
(
)
!
=
RtpPacketHistory
:
:
StorageMode
:
:
kDisabled
;
}
void
ModuleRtpRtcpImpl2
:
:
SendCombinedRtcpPacket
(
std
:
:
vector
<
std
:
:
unique_ptr
<
rtcp
:
:
RtcpPacket
>
>
rtcp_packets
)
{
rtcp_sender_
.
SendCombinedRtcpPacket
(
std
:
:
move
(
rtcp_packets
)
)
;
}
int32_t
ModuleRtpRtcpImpl2
:
:
SendLossNotification
(
uint16_t
last_decoded_seq_num
uint16_t
last_received_seq_num
bool
decodability_flag
bool
buffering_allowed
)
{
return
rtcp_sender_
.
SendLossNotification
(
GetFeedbackState
(
)
last_decoded_seq_num
last_received_seq_num
decodability_flag
buffering_allowed
)
;
}
void
ModuleRtpRtcpImpl2
:
:
SetRemoteSSRC
(
const
uint32_t
ssrc
)
{
rtcp_sender_
.
SetRemoteSSRC
(
ssrc
)
;
rtcp_receiver_
.
SetRemoteSSRC
(
ssrc
)
;
}
RtpSendRates
ModuleRtpRtcpImpl2
:
:
GetSendRates
(
)
const
{
RTC_DCHECK_RUN_ON
(
worker_queue_
)
;
return
rtp_sender_
-
>
packet_sender
.
GetSendRates
(
)
;
}
void
ModuleRtpRtcpImpl2
:
:
OnRequestSendReport
(
)
{
SendRTCP
(
kRtcpSr
)
;
}
void
ModuleRtpRtcpImpl2
:
:
OnReceivedNack
(
const
std
:
:
vector
<
uint16_t
>
&
nack_sequence_numbers
)
{
if
(
!
rtp_sender_
)
return
;
if
(
!
StorePackets
(
)
|
|
nack_sequence_numbers
.
empty
(
)
)
{
return
;
}
int64_t
rtt
=
rtt_ms
(
)
;
if
(
rtt
=
=
0
)
{
rtcp_receiver_
.
RTT
(
rtcp_receiver_
.
RemoteSSRC
(
)
NULL
&
rtt
NULL
NULL
)
;
}
rtp_sender_
-
>
packet_generator
.
OnReceivedNack
(
nack_sequence_numbers
rtt
)
;
}
void
ModuleRtpRtcpImpl2
:
:
OnReceivedRtcpReportBlocks
(
const
ReportBlockList
&
report_blocks
)
{
if
(
rtp_sender_
)
{
uint32_t
ssrc
=
SSRC
(
)
;
absl
:
:
optional
<
uint32_t
>
rtx_ssrc
;
if
(
rtp_sender_
-
>
packet_generator
.
RtxStatus
(
)
!
=
kRtxOff
)
{
rtx_ssrc
=
rtp_sender_
-
>
packet_generator
.
RtxSsrc
(
)
;
}
for
(
const
RTCPReportBlock
&
report_block
:
report_blocks
)
{
if
(
ssrc
=
=
report_block
.
source_ssrc
)
{
rtp_sender_
-
>
packet_generator
.
OnReceivedAckOnSsrc
(
report_block
.
extended_highest_sequence_number
)
;
}
else
if
(
rtx_ssrc
&
&
*
rtx_ssrc
=
=
report_block
.
source_ssrc
)
{
rtp_sender_
-
>
packet_generator
.
OnReceivedAckOnRtxSsrc
(
report_block
.
extended_highest_sequence_number
)
;
}
}
}
}
void
ModuleRtpRtcpImpl2
:
:
set_rtt_ms
(
int64_t
rtt_ms
)
{
RTC_DCHECK_RUN_ON
(
worker_queue_
)
;
{
MutexLock
lock
(
&
mutex_rtt_
)
;
rtt_ms_
=
rtt_ms
;
}
if
(
rtp_sender_
)
{
rtp_sender_
-
>
packet_history
.
SetRtt
(
rtt_ms
)
;
}
}
int64_t
ModuleRtpRtcpImpl2
:
:
rtt_ms
(
)
const
{
MutexLock
lock
(
&
mutex_rtt_
)
;
return
rtt_ms_
;
}
void
ModuleRtpRtcpImpl2
:
:
SetVideoBitrateAllocation
(
const
VideoBitrateAllocation
&
bitrate
)
{
rtcp_sender_
.
SetVideoBitrateAllocation
(
bitrate
)
;
}
RTPSender
*
ModuleRtpRtcpImpl2
:
:
RtpSender
(
)
{
return
rtp_sender_
?
&
rtp_sender_
-
>
packet_generator
:
nullptr
;
}
const
RTPSender
*
ModuleRtpRtcpImpl2
:
:
RtpSender
(
)
const
{
return
rtp_sender_
?
&
rtp_sender_
-
>
packet_generator
:
nullptr
;
}
void
ModuleRtpRtcpImpl2
:
:
PeriodicUpdate
(
)
{
RTC_DCHECK_RUN_ON
(
worker_queue_
)
;
Timestamp
check_since
=
clock_
-
>
CurrentTime
(
)
-
kRttUpdateInterval
;
absl
:
:
optional
<
TimeDelta
>
rtt
=
rtcp_receiver_
.
OnPeriodicRttUpdate
(
check_since
rtcp_sender_
.
Sending
(
)
)
;
if
(
rtt
)
{
rtt_stats_
-
>
OnRttUpdate
(
rtt
-
>
ms
(
)
)
;
set_rtt_ms
(
rtt
-
>
ms
(
)
)
;
}
if
(
rtcp_sender_
.
TMMBR
(
)
&
&
rtcp_receiver_
.
UpdateTmmbrTimers
(
)
)
rtcp_receiver_
.
NotifyTmmbrUpdated
(
)
;
}
}
