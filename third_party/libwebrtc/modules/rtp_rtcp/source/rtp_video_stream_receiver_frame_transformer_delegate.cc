#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_video_stream_receiver_frame_transformer_delegate
.
h
"
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_descriptor_authentication
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
namespace
{
class
TransformableVideoReceiverFrame
:
public
TransformableVideoFrameInterface
{
public
:
TransformableVideoReceiverFrame
(
std
:
:
unique_ptr
<
RtpFrameObject
>
frame
uint32_t
ssrc
RtpVideoFrameReceiver
*
receiver
)
:
frame_
(
std
:
:
move
(
frame
)
)
metadata_
(
frame_
-
>
GetRtpVideoHeader
(
)
.
GetAsMetadata
(
)
)
receiver_
(
receiver
)
{
metadata_
.
SetSsrc
(
ssrc
)
;
metadata_
.
SetCsrcs
(
frame_
-
>
Csrcs
(
)
)
;
}
~
TransformableVideoReceiverFrame
(
)
override
=
default
;
rtc
:
:
ArrayView
<
const
uint8_t
>
GetData
(
)
const
override
{
return
*
frame_
-
>
GetEncodedData
(
)
;
}
void
SetData
(
rtc
:
:
ArrayView
<
const
uint8_t
>
data
)
override
{
frame_
-
>
SetEncodedData
(
EncodedImageBuffer
:
:
Create
(
data
.
data
(
)
data
.
size
(
)
)
)
;
}
uint8_t
GetPayloadType
(
)
const
override
{
return
frame_
-
>
PayloadType
(
)
;
}
uint32_t
GetSsrc
(
)
const
override
{
return
metadata_
.
GetSsrc
(
)
;
}
uint32_t
GetTimestamp
(
)
const
override
{
return
frame_
-
>
Timestamp
(
)
;
}
bool
IsKeyFrame
(
)
const
override
{
return
frame_
-
>
FrameType
(
)
=
=
VideoFrameType
:
:
kVideoFrameKey
;
}
const
std
:
:
string
&
GetRid
(
)
const
override
{
static
const
std
:
:
string
empty
;
return
empty
;
}
VideoFrameMetadata
Metadata
(
)
const
override
{
return
metadata_
;
}
void
SetMetadata
(
const
VideoFrameMetadata
&
)
override
{
RTC_DCHECK_NOTREACHED
(
)
<
<
"
TransformableVideoReceiverFrame
:
:
SetMetadata
is
not
implemented
"
;
}
std
:
:
unique_ptr
<
RtpFrameObject
>
ExtractFrame
(
)
&
&
{
return
std
:
:
move
(
frame_
)
;
}
Direction
GetDirection
(
)
const
override
{
return
Direction
:
:
kReceiver
;
}
const
RtpVideoFrameReceiver
*
Receiver
(
)
{
return
receiver_
;
}
private
:
std
:
:
unique_ptr
<
RtpFrameObject
>
frame_
;
VideoFrameMetadata
metadata_
;
RtpVideoFrameReceiver
*
receiver_
;
}
;
}
RtpVideoStreamReceiverFrameTransformerDelegate
:
:
RtpVideoStreamReceiverFrameTransformerDelegate
(
RtpVideoFrameReceiver
*
receiver
Clock
*
clock
rtc
:
:
scoped_refptr
<
FrameTransformerInterface
>
frame_transformer
TaskQueueBase
*
network_thread
uint32_t
ssrc
)
:
receiver_
(
receiver
)
frame_transformer_
(
std
:
:
move
(
frame_transformer
)
)
network_thread_
(
network_thread
)
ssrc_
(
ssrc
)
clock_
(
clock
)
{
}
void
RtpVideoStreamReceiverFrameTransformerDelegate
:
:
Init
(
)
{
RTC_DCHECK_RUN_ON
(
&
network_sequence_checker_
)
;
frame_transformer_
-
>
RegisterTransformedFrameSinkCallback
(
rtc
:
:
scoped_refptr
<
TransformedFrameCallback
>
(
this
)
ssrc_
)
;
}
void
RtpVideoStreamReceiverFrameTransformerDelegate
:
:
Reset
(
)
{
RTC_DCHECK_RUN_ON
(
&
network_sequence_checker_
)
;
frame_transformer_
-
>
UnregisterTransformedFrameSinkCallback
(
ssrc_
)
;
frame_transformer_
=
nullptr
;
receiver_
=
nullptr
;
}
void
RtpVideoStreamReceiverFrameTransformerDelegate
:
:
TransformFrame
(
std
:
:
unique_ptr
<
RtpFrameObject
>
frame
)
{
RTC_DCHECK_RUN_ON
(
&
network_sequence_checker_
)
;
frame_transformer_
-
>
Transform
(
std
:
:
make_unique
<
TransformableVideoReceiverFrame
>
(
std
:
:
move
(
frame
)
ssrc_
receiver_
)
)
;
}
void
RtpVideoStreamReceiverFrameTransformerDelegate
:
:
OnTransformedFrame
(
std
:
:
unique_ptr
<
TransformableFrameInterface
>
frame
)
{
rtc
:
:
scoped_refptr
<
RtpVideoStreamReceiverFrameTransformerDelegate
>
delegate
(
this
)
;
network_thread_
-
>
PostTask
(
[
delegate
=
std
:
:
move
(
delegate
)
frame
=
std
:
:
move
(
frame
)
]
(
)
mutable
{
delegate
-
>
ManageFrame
(
std
:
:
move
(
frame
)
)
;
}
)
;
}
void
RtpVideoStreamReceiverFrameTransformerDelegate
:
:
ManageFrame
(
std
:
:
unique_ptr
<
TransformableFrameInterface
>
frame
)
{
RTC_DCHECK_RUN_ON
(
&
network_sequence_checker_
)
;
if
(
!
receiver_
)
return
;
if
(
frame
-
>
GetDirection
(
)
=
=
TransformableFrameInterface
:
:
Direction
:
:
kReceiver
)
{
auto
transformed_frame
=
absl
:
:
WrapUnique
(
static_cast
<
TransformableVideoReceiverFrame
*
>
(
frame
.
release
(
)
)
)
;
auto
frame_receiver
=
transformed_frame
-
>
Receiver
(
)
;
std
:
:
unique_ptr
<
RtpFrameObject
>
frame_object
=
std
:
:
move
(
*
transformed_frame
)
.
ExtractFrame
(
)
;
if
(
frame_receiver
!
=
receiver_
)
{
frame_object
-
>
SetFirstSeqNum
(
frame_object
-
>
Id
(
)
)
;
frame_object
-
>
SetLastSeqNum
(
frame_object
-
>
Id
(
)
)
;
}
receiver_
-
>
ManageFrame
(
std
:
:
move
(
frame_object
)
)
;
}
else
{
RTC_CHECK_EQ
(
frame
-
>
GetDirection
(
)
TransformableFrameInterface
:
:
Direction
:
:
kSender
)
;
auto
transformed_frame
=
absl
:
:
WrapUnique
(
static_cast
<
TransformableVideoFrameInterface
*
>
(
frame
.
release
(
)
)
)
;
VideoFrameMetadata
metadata
=
transformed_frame
-
>
Metadata
(
)
;
RTPVideoHeader
video_header
=
RTPVideoHeader
:
:
FromMetadata
(
metadata
)
;
VideoSendTiming
timing
;
rtc
:
:
ArrayView
<
const
uint8_t
>
data
=
transformed_frame
-
>
GetData
(
)
;
int64_t
receive_time
=
clock_
-
>
CurrentTime
(
)
.
ms
(
)
;
receiver_
-
>
ManageFrame
(
std
:
:
make_unique
<
RtpFrameObject
>
(
metadata
.
GetFrameId
(
)
.
value_or
(
0
)
metadata
.
GetFrameId
(
)
.
value_or
(
0
)
video_header
.
is_last_frame_in_picture
0
receive_time
receive_time
transformed_frame
-
>
GetTimestamp
(
)
0
timing
transformed_frame
-
>
GetPayloadType
(
)
metadata
.
GetCodec
(
)
metadata
.
GetRotation
(
)
metadata
.
GetContentType
(
)
video_header
video_header
.
color_space
RtpPacketInfos
(
)
EncodedImageBuffer
:
:
Create
(
data
.
data
(
)
data
.
size
(
)
)
)
)
;
}
}
}
