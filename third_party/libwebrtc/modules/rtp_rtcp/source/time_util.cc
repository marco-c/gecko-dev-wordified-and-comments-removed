#
include
"
modules
/
rtp_rtcp
/
source
/
time_util
.
h
"
#
include
<
algorithm
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
divide_round
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
namespace
{
int64_t
NtpOffsetMsCalledOnce
(
)
{
constexpr
int64_t
kNtpJan1970Sec
=
2208988800
;
int64_t
clock_time
=
rtc
:
:
TimeMillis
(
)
;
int64_t
utc_time
=
rtc
:
:
TimeUTCMillis
(
)
;
return
utc_time
-
clock_time
+
kNtpJan1970Sec
*
rtc
:
:
kNumMillisecsPerSec
;
}
}
int64_t
NtpOffsetMs
(
)
{
static
int64_t
ntp_offset_ms
=
NtpOffsetMsCalledOnce
(
)
;
return
ntp_offset_ms
;
}
NtpTime
TimeMicrosToNtp
(
int64_t
time_us
)
{
int64_t
time_ntp_us
=
time_us
+
NtpOffsetMs
(
)
*
1000
;
RTC_DCHECK_GE
(
time_ntp_us
0
)
;
uint32_t
ntp_seconds
=
static_cast
<
uint64_t
>
(
time_ntp_us
/
rtc
:
:
kNumMicrosecsPerSec
)
;
constexpr
int64_t
kNtpInSecond
=
1LL
<
<
32
;
int64_t
us_fractions
=
time_ntp_us
%
rtc
:
:
kNumMicrosecsPerSec
;
uint32_t
ntp_fractions
=
us_fractions
*
kNtpInSecond
/
rtc
:
:
kNumMicrosecsPerSec
;
return
NtpTime
(
ntp_seconds
ntp_fractions
)
;
}
uint32_t
SaturatedUsToCompactNtp
(
int64_t
us
)
{
constexpr
uint32_t
kMaxCompactNtp
=
0xFFFFFFFF
;
constexpr
int
kCompactNtpInSecond
=
0x10000
;
if
(
us
<
=
0
)
return
0
;
if
(
us
>
=
kMaxCompactNtp
*
rtc
:
:
kNumMicrosecsPerSec
/
kCompactNtpInSecond
)
return
kMaxCompactNtp
;
return
DivideRoundToNearest
(
us
*
kCompactNtpInSecond
rtc
:
:
kNumMicrosecsPerSec
)
;
}
int64_t
CompactNtpRttToMs
(
uint32_t
compact_ntp_interval
)
{
if
(
compact_ntp_interval
>
0x80000000
)
return
1
;
int64_t
value
=
static_cast
<
int64_t
>
(
compact_ntp_interval
)
;
int64_t
ms
=
DivideRoundToNearest
(
value
*
1000
1
<
<
16
)
;
return
std
:
:
max
<
int64_t
>
(
ms
1
)
;
}
}
