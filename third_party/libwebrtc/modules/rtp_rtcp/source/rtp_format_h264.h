#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H264_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H264_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
deque
>
#
include
<
memory
>
#
include
<
queue
>
#
include
"
api
/
array_view
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
h264
/
include
/
h264_globals
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
namespace
webrtc
{
class
RtpPacketizerH264
:
public
RtpPacketizer
{
public
:
RtpPacketizerH264
(
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
PayloadSizeLimits
limits
H264PacketizationMode
packetization_mode
)
;
~
RtpPacketizerH264
(
)
override
;
size_t
NumPackets
(
)
const
override
;
bool
NextPacket
(
RtpPacketToSend
*
rtp_packet
)
override
;
private
:
struct
PacketUnit
{
PacketUnit
(
rtc
:
:
ArrayView
<
const
uint8_t
>
source_fragment
bool
first_fragment
bool
last_fragment
bool
aggregated
uint8_t
header
)
:
source_fragment
(
source_fragment
)
first_fragment
(
first_fragment
)
last_fragment
(
last_fragment
)
aggregated
(
aggregated
)
header
(
header
)
{
}
rtc
:
:
ArrayView
<
const
uint8_t
>
source_fragment
;
bool
first_fragment
;
bool
last_fragment
;
bool
aggregated
;
uint8_t
header
;
}
;
bool
GeneratePackets
(
H264PacketizationMode
packetization_mode
)
;
bool
PacketizeFuA
(
size_t
fragment_index
)
;
size_t
PacketizeStapA
(
size_t
fragment_index
)
;
bool
PacketizeSingleNalu
(
size_t
fragment_index
)
;
void
NextAggregatePacket
(
RtpPacketToSend
*
rtp_packet
)
;
void
NextFragmentPacket
(
RtpPacketToSend
*
rtp_packet
)
;
const
PayloadSizeLimits
limits_
;
size_t
num_packets_left_
;
std
:
:
deque
<
rtc
:
:
ArrayView
<
const
uint8_t
>
>
input_fragments_
;
std
:
:
queue
<
PacketUnit
>
packets_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
RtpPacketizerH264
)
;
}
;
}
#
endif
