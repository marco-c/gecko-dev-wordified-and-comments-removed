#
include
"
modules
/
rtp_rtcp
/
source
/
absolute_capture_time_sender
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
optional
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
absolute_capture_time_interpolator
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
system_wrappers
/
include
/
ntp_time
.
h
"
namespace
webrtc
{
static_assert
(
AbsoluteCaptureTimeInterpolator
:
:
kInterpolationMaxInterval
>
=
AbsoluteCaptureTimeSender
:
:
kInterpolationMaxInterval
"
Receivers
should
be
as
willing
to
interpolate
timestamps
as
senders
.
"
)
;
AbsoluteCaptureTimeSender
:
:
AbsoluteCaptureTimeSender
(
Clock
*
clock
)
:
clock_
(
clock
)
{
}
uint32_t
AbsoluteCaptureTimeSender
:
:
GetSource
(
uint32_t
ssrc
ArrayView
<
const
uint32_t
>
csrcs
)
{
return
AbsoluteCaptureTimeInterpolator
:
:
GetSource
(
ssrc
csrcs
)
;
}
std
:
:
optional
<
AbsoluteCaptureTime
>
AbsoluteCaptureTimeSender
:
:
OnSendPacket
(
uint32_t
source
uint32_t
rtp_timestamp
uint32_t
rtp_clock_frequency
uint64_t
absolute_capture_timestamp
std
:
:
optional
<
int64_t
>
estimated_capture_clock_offset
)
{
return
OnSendPacket
(
source
rtp_timestamp
rtp_clock_frequency
NtpTime
(
absolute_capture_timestamp
)
estimated_capture_clock_offset
false
)
;
}
std
:
:
optional
<
AbsoluteCaptureTime
>
AbsoluteCaptureTimeSender
:
:
OnSendPacket
(
uint32_t
source
uint32_t
rtp_timestamp
int
rtp_clock_frequency_hz
NtpTime
absolute_capture_time
std
:
:
optional
<
int64_t
>
estimated_capture_clock_offset
bool
force
)
{
Timestamp
send_time
=
clock_
-
>
CurrentTime
(
)
;
if
(
!
(
force
|
|
ShouldSendExtension
(
send_time
source
rtp_timestamp
rtp_clock_frequency_hz
absolute_capture_time
estimated_capture_clock_offset
)
)
)
{
return
std
:
:
nullopt
;
}
last_source_
=
source
;
last_rtp_timestamp_
=
rtp_timestamp
;
last_rtp_clock_frequency_hz_
=
rtp_clock_frequency_hz
;
last_absolute_capture_time_
=
absolute_capture_time
;
last_estimated_capture_clock_offset_
=
estimated_capture_clock_offset
;
last_send_time_
=
send_time
;
return
AbsoluteCaptureTime
{
.
absolute_capture_timestamp
=
uint64_t
{
absolute_capture_time
}
.
estimated_capture_clock_offset
=
estimated_capture_clock_offset
}
;
}
bool
AbsoluteCaptureTimeSender
:
:
ShouldSendExtension
(
Timestamp
send_time
uint32_t
source
uint32_t
rtp_timestamp
int
rtp_clock_frequency_hz
NtpTime
absolute_capture_time
std
:
:
optional
<
int64_t
>
estimated_capture_clock_offset
)
const
{
if
(
send_time
-
last_send_time_
>
kInterpolationMaxInterval
)
{
return
true
;
}
if
(
last_source_
!
=
source
)
{
return
true
;
}
if
(
last_rtp_clock_frequency_hz_
!
=
rtp_clock_frequency_hz
)
{
return
true
;
}
if
(
rtp_clock_frequency_hz
<
=
0
)
{
return
true
;
}
if
(
last_estimated_capture_clock_offset_
!
=
estimated_capture_clock_offset
)
{
return
true
;
}
const
uint64_t
interpolated_absolute_capture_timestamp
=
AbsoluteCaptureTimeInterpolator
:
:
InterpolateAbsoluteCaptureTimestamp
(
rtp_timestamp
rtp_clock_frequency_hz
last_rtp_timestamp_
uint64_t
{
last_absolute_capture_time_
}
)
;
const
uint64_t
absolute_capture_timestamp
=
uint64_t
{
absolute_capture_time
}
;
const
int64_t
interpolation_error_ms
=
UQ32x32ToInt64Ms
(
std
:
:
min
(
interpolated_absolute_capture_timestamp
-
absolute_capture_timestamp
absolute_capture_timestamp
-
interpolated_absolute_capture_timestamp
)
)
;
if
(
interpolation_error_ms
>
kInterpolationMaxError
.
ms
(
)
)
{
return
true
;
}
return
false
;
}
}
