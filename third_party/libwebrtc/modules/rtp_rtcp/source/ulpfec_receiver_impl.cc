#
include
"
modules
/
rtp_rtcp
/
source
/
ulpfec_receiver_impl
.
h
"
#
include
<
memory
>
#
include
<
utility
>
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
std
:
:
unique_ptr
<
UlpfecReceiver
>
UlpfecReceiver
:
:
Create
(
uint32_t
ssrc
RecoveredPacketReceiver
*
callback
rtc
:
:
ArrayView
<
const
RtpExtension
>
extensions
)
{
return
std
:
:
make_unique
<
UlpfecReceiverImpl
>
(
ssrc
callback
extensions
)
;
}
UlpfecReceiverImpl
:
:
UlpfecReceiverImpl
(
uint32_t
ssrc
RecoveredPacketReceiver
*
callback
rtc
:
:
ArrayView
<
const
RtpExtension
>
extensions
)
:
ssrc_
(
ssrc
)
extensions_
(
extensions
)
recovered_packet_callback_
(
callback
)
fec_
(
ForwardErrorCorrection
:
:
CreateUlpfec
(
ssrc_
)
)
{
}
UlpfecReceiverImpl
:
:
~
UlpfecReceiverImpl
(
)
{
received_packets_
.
clear
(
)
;
fec_
-
>
ResetState
(
&
recovered_packets_
)
;
}
FecPacketCounter
UlpfecReceiverImpl
:
:
GetPacketCounter
(
)
const
{
MutexLock
lock
(
&
mutex_
)
;
return
packet_counter_
;
}
bool
UlpfecReceiverImpl
:
:
AddReceivedRedPacket
(
const
RtpPacketReceived
&
rtp_packet
uint8_t
ulpfec_payload_type
)
{
if
(
rtp_packet
.
Ssrc
(
)
!
=
ssrc_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Received
RED
packet
with
different
SSRC
than
expected
;
dropping
.
"
;
return
false
;
}
if
(
rtp_packet
.
size
(
)
>
IP_PACKET_SIZE
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Received
RED
packet
with
length
exceeds
maximum
IP
"
"
packet
size
;
dropping
.
"
;
return
false
;
}
MutexLock
lock
(
&
mutex_
)
;
static
constexpr
uint8_t
kRedHeaderLength
=
1
;
if
(
rtp_packet
.
payload_size
(
)
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Corrupt
/
truncated
FEC
packet
.
"
;
return
false
;
}
auto
received_packet
=
std
:
:
make_unique
<
ForwardErrorCorrection
:
:
ReceivedPacket
>
(
)
;
received_packet
-
>
pkt
=
new
ForwardErrorCorrection
:
:
Packet
(
)
;
uint8_t
payload_type
=
rtp_packet
.
payload
(
)
[
0
]
&
0x7f
;
received_packet
-
>
is_fec
=
payload_type
=
=
ulpfec_payload_type
;
received_packet
-
>
is_recovered
=
rtp_packet
.
recovered
(
)
;
received_packet
-
>
ssrc
=
rtp_packet
.
Ssrc
(
)
;
received_packet
-
>
seq_num
=
rtp_packet
.
SequenceNumber
(
)
;
if
(
rtp_packet
.
payload
(
)
[
0
]
&
0x80
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
More
than
1
block
in
RED
packet
is
not
supported
.
"
;
return
false
;
}
+
+
packet_counter_
.
num_packets
;
packet_counter_
.
num_bytes
+
=
rtp_packet
.
size
(
)
;
if
(
packet_counter_
.
first_packet_time_ms
=
=
-
1
)
{
packet_counter_
.
first_packet_time_ms
=
rtc
:
:
TimeMillis
(
)
;
}
if
(
received_packet
-
>
is_fec
)
{
+
+
packet_counter_
.
num_fec_packets
;
received_packet
-
>
pkt
-
>
data
=
rtp_packet
.
Buffer
(
)
.
Slice
(
rtp_packet
.
headers_size
(
)
+
kRedHeaderLength
rtp_packet
.
payload_size
(
)
-
kRedHeaderLength
)
;
}
else
{
auto
red_payload
=
rtp_packet
.
payload
(
)
.
subview
(
kRedHeaderLength
)
;
received_packet
-
>
pkt
-
>
data
.
EnsureCapacity
(
rtp_packet
.
headers_size
(
)
+
red_payload
.
size
(
)
)
;
received_packet
-
>
pkt
-
>
data
.
SetData
(
rtp_packet
.
data
(
)
rtp_packet
.
headers_size
(
)
)
;
uint8_t
&
payload_type_byte
=
received_packet
-
>
pkt
-
>
data
.
MutableData
(
)
[
1
]
;
payload_type_byte
&
=
0x80
;
payload_type_byte
+
=
payload_type
;
received_packet
-
>
pkt
-
>
data
.
AppendData
(
red_payload
.
data
(
)
red_payload
.
size
(
)
)
;
}
if
(
received_packet
-
>
pkt
-
>
data
.
size
(
)
>
0
)
{
received_packets_
.
push_back
(
std
:
:
move
(
received_packet
)
)
;
}
return
true
;
}
int32_t
UlpfecReceiverImpl
:
:
ProcessReceivedFec
(
)
{
mutex_
.
Lock
(
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ForwardErrorCorrection
:
:
ReceivedPacket
>
>
received_packets
;
received_packets
.
swap
(
received_packets_
)
;
for
(
const
auto
&
received_packet
:
received_packets
)
{
if
(
!
received_packet
-
>
is_fec
)
{
ForwardErrorCorrection
:
:
Packet
*
packet
=
received_packet
-
>
pkt
;
mutex_
.
Unlock
(
)
;
recovered_packet_callback_
-
>
OnRecoveredPacket
(
packet
-
>
data
.
data
(
)
packet
-
>
data
.
size
(
)
)
;
mutex_
.
Lock
(
)
;
RtpPacketReceived
rtp_packet
;
const
uint8_t
*
const
original_data
=
packet
-
>
data
.
cdata
(
)
;
if
(
!
rtp_packet
.
Parse
(
packet
-
>
data
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Corrupted
media
packet
"
;
}
else
{
rtp_packet
.
IdentifyExtensions
(
extensions_
)
;
packet
-
>
data
=
rtc
:
:
CopyOnWriteBuffer
(
0
)
;
rtp_packet
.
ZeroMutableExtensions
(
)
;
packet
-
>
data
=
rtp_packet
.
Buffer
(
)
;
RTC_DCHECK_EQ
(
packet
-
>
data
.
cdata
(
)
original_data
)
;
}
}
if
(
!
received_packet
-
>
is_recovered
)
{
fec_
-
>
DecodeFec
(
*
received_packet
&
recovered_packets_
)
;
}
}
for
(
const
auto
&
recovered_packet
:
recovered_packets_
)
{
if
(
recovered_packet
-
>
returned
)
{
continue
;
}
ForwardErrorCorrection
:
:
Packet
*
packet
=
recovered_packet
-
>
pkt
;
+
+
packet_counter_
.
num_recovered_packets
;
recovered_packet
-
>
returned
=
true
;
mutex_
.
Unlock
(
)
;
recovered_packet_callback_
-
>
OnRecoveredPacket
(
packet
-
>
data
.
data
(
)
packet
-
>
data
.
size
(
)
)
;
mutex_
.
Lock
(
)
;
}
mutex_
.
Unlock
(
)
;
return
0
;
}
}
