#
include
<
cstdint
>
#
include
<
optional
>
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_header_extensions
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet_to_send
.
h
"
namespace
webrtc
{
RtpPacketSendInfo
RtpPacketSendInfo
:
:
From
(
const
RtpPacketToSend
&
packet
const
PacedPacketInfo
&
pacing_info
)
{
RtpPacketSendInfo
packet_info
;
if
(
packet
.
transport_sequence_number
(
)
)
{
packet_info
.
transport_sequence_number
=
*
packet
.
transport_sequence_number
(
)
&
0xFFFF
;
}
else
{
std
:
:
optional
<
uint16_t
>
packet_id
=
packet
.
GetExtension
<
TransportSequenceNumber
>
(
)
;
if
(
packet_id
)
{
packet_info
.
transport_sequence_number
=
*
packet_id
;
}
}
packet_info
.
rtp_timestamp
=
packet
.
Timestamp
(
)
;
packet_info
.
length
=
packet
.
size
(
)
;
packet_info
.
pacing_info
=
pacing_info
;
packet_info
.
packet_type
=
packet
.
packet_type
(
)
;
switch
(
*
packet_info
.
packet_type
)
{
case
RtpPacketMediaType
:
:
kAudio
:
case
RtpPacketMediaType
:
:
kVideo
:
packet_info
.
media_ssrc
=
packet
.
Ssrc
(
)
;
packet_info
.
rtp_sequence_number
=
packet
.
SequenceNumber
(
)
;
break
;
case
RtpPacketMediaType
:
:
kRetransmission
:
RTC_DCHECK
(
packet
.
original_ssrc
(
)
&
&
packet
.
retransmitted_sequence_number
(
)
)
;
packet_info
.
media_ssrc
=
packet
.
original_ssrc
(
)
.
value_or
(
0
)
;
packet_info
.
rtp_sequence_number
=
packet
.
retransmitted_sequence_number
(
)
.
value_or
(
0
)
;
break
;
case
RtpPacketMediaType
:
:
kPadding
:
case
RtpPacketMediaType
:
:
kForwardErrorCorrection
:
break
;
}
return
packet_info
;
}
}
