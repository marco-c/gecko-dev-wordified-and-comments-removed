#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_PACKET_TO_SEND_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_PACKET_TO_SEND_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
ref_counted_base
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
video
/
video_timing
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_header_extensions
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_packet
.
h
"
namespace
webrtc
{
class
RtpPacketToSend
:
public
RtpPacket
{
public
:
using
Type
=
RtpPacketMediaType
;
explicit
RtpPacketToSend
(
const
ExtensionManager
*
extensions
)
;
RtpPacketToSend
(
const
ExtensionManager
*
extensions
size_t
capacity
)
;
RtpPacketToSend
(
const
RtpPacketToSend
&
packet
)
;
RtpPacketToSend
(
RtpPacketToSend
&
&
packet
)
;
RtpPacketToSend
&
operator
=
(
const
RtpPacketToSend
&
packet
)
;
RtpPacketToSend
&
operator
=
(
RtpPacketToSend
&
&
packet
)
;
~
RtpPacketToSend
(
)
;
int64_t
capture_time_ms
(
)
const
{
return
capture_time_ms_
;
}
void
set_capture_time_ms
(
int64_t
time
)
{
capture_time_ms_
=
time
;
}
void
set_packet_type
(
RtpPacketMediaType
type
)
{
packet_type_
=
type
;
}
absl
:
:
optional
<
RtpPacketMediaType
>
packet_type
(
)
const
{
return
packet_type_
;
}
void
set_retransmitted_sequence_number
(
uint16_t
sequence_number
)
{
retransmitted_sequence_number_
=
sequence_number
;
}
absl
:
:
optional
<
uint16_t
>
retransmitted_sequence_number
(
)
{
return
retransmitted_sequence_number_
;
}
void
set_allow_retransmission
(
bool
allow_retransmission
)
{
allow_retransmission_
=
allow_retransmission
;
}
bool
allow_retransmission
(
)
{
return
allow_retransmission_
;
}
rtc
:
:
ArrayView
<
const
uint8_t
>
application_data
(
)
const
{
return
application_data_
;
}
void
set_application_data
(
rtc
:
:
ArrayView
<
const
uint8_t
>
data
)
{
application_data_
.
assign
(
data
.
begin
(
)
data
.
end
(
)
)
;
}
rtc
:
:
scoped_refptr
<
rtc
:
:
RefCountedBase
>
additional_data
(
)
const
{
return
additional_data_
;
}
void
set_additional_data
(
rtc
:
:
scoped_refptr
<
rtc
:
:
RefCountedBase
>
data
)
{
additional_data_
=
std
:
:
move
(
data
)
;
}
void
set_packetization_finish_time_ms
(
int64_t
time
)
{
SetExtension
<
VideoTimingExtension
>
(
VideoSendTiming
:
:
GetDeltaCappedMs
(
capture_time_ms_
time
)
VideoTimingExtension
:
:
kPacketizationFinishDeltaOffset
)
;
}
void
set_pacer_exit_time_ms
(
int64_t
time
)
{
SetExtension
<
VideoTimingExtension
>
(
VideoSendTiming
:
:
GetDeltaCappedMs
(
capture_time_ms_
time
)
VideoTimingExtension
:
:
kPacerExitDeltaOffset
)
;
}
void
set_network_time_ms
(
int64_t
time
)
{
SetExtension
<
VideoTimingExtension
>
(
VideoSendTiming
:
:
GetDeltaCappedMs
(
capture_time_ms_
time
)
VideoTimingExtension
:
:
kNetworkTimestampDeltaOffset
)
;
}
void
set_network2_time_ms
(
int64_t
time
)
{
SetExtension
<
VideoTimingExtension
>
(
VideoSendTiming
:
:
GetDeltaCappedMs
(
capture_time_ms_
time
)
VideoTimingExtension
:
:
kNetwork2TimestampDeltaOffset
)
;
}
void
set_first_packet_of_frame
(
bool
is_first_packet
)
{
is_first_packet_of_frame_
=
is_first_packet
;
}
bool
is_first_packet_of_frame
(
)
const
{
return
is_first_packet_of_frame_
;
}
void
set_is_key_frame
(
bool
is_key_frame
)
{
is_key_frame_
=
is_key_frame
;
}
bool
is_key_frame
(
)
const
{
return
is_key_frame_
;
}
void
set_fec_protect_packet
(
bool
protect
)
{
fec_protect_packet_
=
protect
;
}
bool
fec_protect_packet
(
)
const
{
return
fec_protect_packet_
;
}
void
set_is_red
(
bool
is_red
)
{
is_red_
=
is_red
;
}
bool
is_red
(
)
const
{
return
is_red_
;
}
private
:
int64_t
capture_time_ms_
=
0
;
absl
:
:
optional
<
RtpPacketMediaType
>
packet_type_
;
bool
allow_retransmission_
=
false
;
absl
:
:
optional
<
uint16_t
>
retransmitted_sequence_number_
;
std
:
:
vector
<
uint8_t
>
application_data_
;
rtc
:
:
scoped_refptr
<
rtc
:
:
RefCountedBase
>
additional_data_
;
bool
is_first_packet_of_frame_
=
false
;
bool
is_key_frame_
=
false
;
bool
fec_protect_packet_
=
false
;
bool
is_red_
=
false
;
}
;
}
#
endif
