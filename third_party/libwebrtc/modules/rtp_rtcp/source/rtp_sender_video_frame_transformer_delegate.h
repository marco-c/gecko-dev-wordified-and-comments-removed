#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_SENDER_VIDEO_FRAME_TRANSFORMER_DELEGATE_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_SENDER_VIDEO_FRAME_TRANSFORMER_DELEGATE_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
frame_transformer_interface
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
task_queue
/
task_queue_factory
.
h
"
#
include
"
api
/
transport
/
rtp
/
dependency_descriptor
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
encoded_image
.
h
"
#
include
"
api
/
video
/
video_codec_type
.
h
"
#
include
"
api
/
video
/
video_layers_allocation
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_video_header
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
RTPVideoFrameSenderInterface
{
public
:
virtual
bool
SendVideo
(
int
payload_type
std
:
:
optional
<
VideoCodecType
>
codec_type
uint32_t
rtp_timestamp
Timestamp
capture_time
ArrayView
<
const
uint8_t
>
payload
size_t
encoder_output_size
RTPVideoHeader
video_header
TimeDelta
expected_retransmission_time
std
:
:
vector
<
uint32_t
>
csrcs
)
=
0
;
virtual
void
SetVideoStructureAfterTransformation
(
const
FrameDependencyStructure
*
video_structure
)
=
0
;
virtual
void
SetVideoLayersAllocationAfterTransformation
(
VideoLayersAllocation
allocation
)
=
0
;
protected
:
virtual
~
RTPVideoFrameSenderInterface
(
)
=
default
;
}
;
class
RTPSenderVideoFrameTransformerDelegate
:
public
TransformedFrameCallback
{
public
:
RTPSenderVideoFrameTransformerDelegate
(
RTPVideoFrameSenderInterface
*
sender
scoped_refptr
<
FrameTransformerInterface
>
frame_transformer
uint32_t
ssrc
std
:
:
string
rid
TaskQueueFactory
*
send_transport_queue
)
;
void
Init
(
)
;
bool
TransformFrame
(
int
payload_type
std
:
:
optional
<
VideoCodecType
>
codec_type
uint32_t
rtp_timestamp
const
EncodedImage
&
encoded_image
RTPVideoHeader
video_header
TimeDelta
expected_retransmission_time
const
std
:
:
vector
<
uint32_t
>
&
csrcs
=
{
}
)
;
void
OnTransformedFrame
(
std
:
:
unique_ptr
<
TransformableFrameInterface
>
frame
)
override
;
void
StartShortCircuiting
(
)
override
;
void
SendVideo
(
std
:
:
unique_ptr
<
TransformableFrameInterface
>
frame
)
const
RTC_RUN_ON
(
transformation_queue_
)
;
void
SetVideoStructureUnderLock
(
const
FrameDependencyStructure
*
video_structure
)
;
void
SetVideoLayersAllocationUnderLock
(
VideoLayersAllocation
allocation
)
;
void
Reset
(
)
;
protected
:
~
RTPSenderVideoFrameTransformerDelegate
(
)
override
=
default
;
private
:
void
EnsureEncoderQueueCreated
(
)
;
mutable
Mutex
sender_lock_
;
RTPVideoFrameSenderInterface
*
sender_
RTC_GUARDED_BY
(
sender_lock_
)
;
scoped_refptr
<
FrameTransformerInterface
>
frame_transformer_
;
const
uint32_t
ssrc_
;
const
std
:
:
string
rid_
;
std
:
:
unique_ptr
<
TaskQueueBase
TaskQueueDeleter
>
transformation_queue_
;
bool
short_circuit_
RTC_GUARDED_BY
(
sender_lock_
)
=
false
;
}
;
std
:
:
unique_ptr
<
TransformableVideoFrameInterface
>
CloneSenderVideoFrame
(
TransformableVideoFrameInterface
*
original
)
;
}
#
endif
