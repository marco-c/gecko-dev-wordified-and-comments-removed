#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_SENDER_VIDEO_FRAME_TRANSFORMER_DELEGATE_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_SENDER_VIDEO_FRAME_TRANSFORMER_DELEGATE_H_
#
include
<
memory
>
#
include
"
api
/
frame_transformer_interface
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
task_queue
/
task_queue_base
.
h
"
#
include
"
api
/
video
/
video_layers_allocation
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
namespace
webrtc
{
class
RTPSenderVideo
;
class
RTPSenderVideoFrameTransformerDelegate
:
public
TransformedFrameCallback
{
public
:
RTPSenderVideoFrameTransformerDelegate
(
RTPSenderVideo
*
sender
rtc
:
:
scoped_refptr
<
FrameTransformerInterface
>
frame_transformer
uint32_t
ssrc
TaskQueueBase
*
send_transport_queue
)
;
void
Init
(
)
;
bool
TransformFrame
(
int
payload_type
absl
:
:
optional
<
VideoCodecType
>
codec_type
uint32_t
rtp_timestamp
const
EncodedImage
&
encoded_image
RTPVideoHeader
video_header
absl
:
:
optional
<
int64_t
>
expected_retransmission_time_ms
)
;
void
OnTransformedFrame
(
std
:
:
unique_ptr
<
TransformableFrameInterface
>
frame
)
override
;
void
SendVideo
(
std
:
:
unique_ptr
<
TransformableFrameInterface
>
frame
)
const
;
void
SetVideoStructureUnderLock
(
const
FrameDependencyStructure
*
video_structure
)
;
void
SetVideoLayersAllocationUnderLock
(
VideoLayersAllocation
allocation
)
;
void
Reset
(
)
;
protected
:
~
RTPSenderVideoFrameTransformerDelegate
(
)
override
=
default
;
private
:
mutable
Mutex
sender_lock_
;
RTPSenderVideo
*
sender_
RTC_GUARDED_BY
(
sender_lock_
)
;
rtc
:
:
scoped_refptr
<
FrameTransformerInterface
>
frame_transformer_
;
const
uint32_t
ssrc_
;
TaskQueueBase
*
encoder_queue_
=
nullptr
;
TaskQueueBase
*
send_transport_queue_
;
}
;
}
#
endif
