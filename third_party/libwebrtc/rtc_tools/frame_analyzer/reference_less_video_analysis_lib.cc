#
include
"
rtc_tools
/
frame_analyzer
/
reference_less_video_analysis_lib
.
h
"
#
include
<
stdio
.
h
>
#
include
<
numeric
>
#
include
<
vector
>
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
rtc_tools
/
frame_analyzer
/
video_quality_analysis
.
h
"
#
define
STATS_LINE_LENGTH
28
#
define
PSNR_FREEZE_THRESHOLD
47
#
define
SSIM_FREEZE_THRESHOLD
.
999
#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
#
define
strtok_r
strtok_s
#
endif
bool
frozen_frame
(
std
:
:
vector
<
double
>
psnr_per_frame
std
:
:
vector
<
double
>
ssim_per_frame
size_t
frame
)
{
if
(
psnr_per_frame
[
frame
]
>
=
PSNR_FREEZE_THRESHOLD
|
|
ssim_per_frame
[
frame
]
>
=
SSIM_FREEZE_THRESHOLD
)
return
true
;
return
false
;
}
std
:
:
vector
<
int
>
find_frame_clusters
(
const
std
:
:
vector
<
double
>
&
psnr_per_frame
const
std
:
:
vector
<
double
>
&
ssim_per_frame
)
{
std
:
:
vector
<
int
>
identical_frame_clusters
;
int
num_frozen
=
0
;
size_t
total_no_of_frames
=
psnr_per_frame
.
size
(
)
;
for
(
size_t
each_frame
=
0
;
each_frame
<
total_no_of_frames
;
each_frame
+
+
)
{
if
(
frozen_frame
(
psnr_per_frame
ssim_per_frame
each_frame
)
)
{
num_frozen
+
+
;
}
else
if
(
num_frozen
>
0
)
{
identical_frame_clusters
.
push_back
(
num_frozen
)
;
num_frozen
=
0
;
}
}
return
identical_frame_clusters
;
}
void
print_freezing_metrics
(
const
std
:
:
vector
<
double
>
&
psnr_per_frame
const
std
:
:
vector
<
double
>
&
ssim_per_frame
)
{
size_t
total_no_of_frames
=
psnr_per_frame
.
size
(
)
;
std
:
:
vector
<
int
>
identical_frame_clusters
=
find_frame_clusters
(
psnr_per_frame
ssim_per_frame
)
;
int
total_identical_frames
=
std
:
:
accumulate
(
identical_frame_clusters
.
begin
(
)
identical_frame_clusters
.
end
(
)
0
)
;
size_t
unique_frames
=
total_no_of_frames
-
total_identical_frames
;
printf
(
"
Total
number
of
frames
received
:
%
zu
\
n
"
total_no_of_frames
)
;
printf
(
"
Total
identical
frames
:
%
d
\
n
"
total_identical_frames
)
;
printf
(
"
Number
of
unique
frames
:
%
zu
\
n
"
unique_frames
)
;
printf
(
"
Printing
Identical
Frames
:
\
n
"
)
;
for
(
size_t
frame
=
0
;
frame
<
total_no_of_frames
;
frame
+
+
)
{
if
(
frozen_frame
(
psnr_per_frame
ssim_per_frame
frame
)
)
{
printf
(
"
Frame
Number
:
%
zu
PSNR
:
%
f
SSIM
:
%
f
\
n
"
frame
psnr_per_frame
[
frame
]
ssim_per_frame
[
frame
]
)
;
}
}
printf
(
"
Print
identical
frame
which
appears
in
clusters
:
\
n
"
)
;
for
(
int
cluster
=
0
;
cluster
<
static_cast
<
int
>
(
identical_frame_clusters
.
size
(
)
)
;
cluster
+
+
)
printf
(
"
%
d
"
identical_frame_clusters
[
cluster
]
)
;
printf
(
"
\
n
"
)
;
}
void
compute_metrics
(
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
test
:
:
Video
>
&
video
std
:
:
vector
<
double
>
*
psnr_per_frame
std
:
:
vector
<
double
>
*
ssim_per_frame
)
{
for
(
size_t
i
=
0
;
i
<
video
-
>
number_of_frames
(
)
-
1
;
+
+
i
)
{
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420BufferInterface
>
current_frame
=
video
-
>
GetFrame
(
i
)
;
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420BufferInterface
>
next_frame
=
video
-
>
GetFrame
(
i
+
1
)
;
double
result_psnr
=
webrtc
:
:
test
:
:
Psnr
(
current_frame
next_frame
)
;
double
result_ssim
=
webrtc
:
:
test
:
:
Ssim
(
current_frame
next_frame
)
;
psnr_per_frame
-
>
push_back
(
result_psnr
)
;
ssim_per_frame
-
>
push_back
(
result_ssim
)
;
}
}
int
run_analysis
(
const
std
:
:
string
&
video_file
)
{
std
:
:
vector
<
double
>
psnr_per_frame
;
std
:
:
vector
<
double
>
ssim_per_frame
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
test
:
:
Video
>
video
=
webrtc
:
:
test
:
:
OpenY4mFile
(
video_file
)
;
if
(
video
)
{
compute_metrics
(
video
&
psnr_per_frame
&
ssim_per_frame
)
;
}
else
{
return
-
1
;
}
printf
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
printf
(
"
Printing
metrics
for
file
:
%
s
\
n
"
video_file
.
c_str
(
)
)
;
printf
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
print_freezing_metrics
(
psnr_per_frame
ssim_per_frame
)
;
return
0
;
}
