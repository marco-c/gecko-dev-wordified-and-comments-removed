#
ifndef
RTC_TOOLS_RTC_EVENT_LOG_VISUALIZER_ANALYZER_COMMON_H_
#
define
RTC_TOOLS_RTC_EVENT_LOG_VISUALIZER_ANALYZER_COMMON_H_
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
function_view
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
logging
/
rtc_event_log
/
rtc_event_log_parser
.
h
"
#
include
"
rtc_tools
/
rtc_event_log_visualizer
/
plot_base
.
h
"
namespace
webrtc
{
constexpr
int
kNumMicrosecsPerSec
=
1000000
;
constexpr
int
kNumMillisecsPerSec
=
1000
;
constexpr
float
kLeftMargin
=
0
.
01f
;
constexpr
float
kRightMargin
=
0
.
02f
;
constexpr
float
kBottomMargin
=
0
.
02f
;
constexpr
float
kTopMargin
=
0
.
05f
;
class
AnalyzerConfig
{
public
:
float
GetCallTimeSec
(
Timestamp
timestamp
)
const
{
Timestamp
offset
=
normalize_time_
?
begin_time_
:
Timestamp
:
:
Zero
(
)
;
return
static_cast
<
float
>
(
(
timestamp
-
offset
)
.
us
(
)
)
/
1000000
;
}
float
GetCallTimeSecFromMs
(
int64_t
timestamp_ms
)
const
{
return
GetCallTimeSec
(
Timestamp
:
:
Millis
(
timestamp_ms
)
)
;
}
float
CallBeginTimeSec
(
)
const
{
return
GetCallTimeSec
(
begin_time_
)
;
}
float
CallEndTimeSec
(
)
const
{
return
GetCallTimeSec
(
end_time_
)
;
}
int64_t
CallTimeToUtcOffsetMs
(
)
{
if
(
normalize_time_
)
{
Timestamp
utc_begin_time_
=
begin_time_
+
rtc_to_utc_offset_
;
return
utc_begin_time_
.
ms
(
)
;
}
return
rtc_to_utc_offset_
.
ms
(
)
;
}
TimeDelta
window_duration_
=
TimeDelta
:
:
Millis
(
250
)
;
TimeDelta
step_
=
TimeDelta
:
:
Millis
(
10
)
;
Timestamp
begin_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
Timestamp
end_time_
=
Timestamp
:
:
MinusInfinity
(
)
;
TimeDelta
rtc_to_utc_offset_
=
TimeDelta
:
:
Zero
(
)
;
bool
normalize_time_
;
}
;
struct
LayerDescription
{
LayerDescription
(
uint32_t
ssrc
uint8_t
spatial_layer
uint8_t
temporal_layer
)
:
ssrc
(
ssrc
)
spatial_layer
(
spatial_layer
)
temporal_layer
(
temporal_layer
)
{
}
bool
operator
<
(
const
LayerDescription
&
other
)
const
{
if
(
ssrc
!
=
other
.
ssrc
)
return
ssrc
<
other
.
ssrc
;
if
(
spatial_layer
!
=
other
.
spatial_layer
)
return
spatial_layer
<
other
.
spatial_layer
;
return
temporal_layer
<
other
.
temporal_layer
;
}
uint32_t
ssrc
;
uint8_t
spatial_layer
;
uint8_t
temporal_layer
;
}
;
bool
IsRtxSsrc
(
const
ParsedRtcEventLog
&
parsed_log
PacketDirection
direction
uint32_t
ssrc
)
;
bool
IsVideoSsrc
(
const
ParsedRtcEventLog
&
parsed_log
PacketDirection
direction
uint32_t
ssrc
)
;
bool
IsAudioSsrc
(
const
ParsedRtcEventLog
&
parsed_log
PacketDirection
direction
uint32_t
ssrc
)
;
std
:
:
string
GetStreamName
(
const
ParsedRtcEventLog
&
parsed_log
PacketDirection
direction
uint32_t
ssrc
)
;
std
:
:
string
GetLayerName
(
LayerDescription
layer
)
;
template
<
typename
DataType
typename
IterableType
>
void
ProcessPoints
(
rtc
:
:
FunctionView
<
float
(
const
DataType
&
)
>
fx
rtc
:
:
FunctionView
<
absl
:
:
optional
<
float
>
(
const
DataType
&
)
>
fy
const
IterableType
&
data_view
TimeSeries
*
result
)
{
for
(
size_t
i
=
0
;
i
<
data_view
.
size
(
)
;
i
+
+
)
{
const
DataType
&
elem
=
data_view
[
i
]
;
float
x
=
fx
(
elem
)
;
absl
:
:
optional
<
float
>
y
=
fy
(
elem
)
;
if
(
y
)
result
-
>
points
.
emplace_back
(
x
*
y
)
;
}
}
template
<
typename
DataType
typename
ResultType
typename
IterableType
>
void
ProcessPairs
(
rtc
:
:
FunctionView
<
float
(
const
DataType
&
)
>
fx
rtc
:
:
FunctionView
<
absl
:
:
optional
<
ResultType
>
(
const
DataType
&
const
DataType
&
)
>
fy
const
IterableType
&
data
TimeSeries
*
result
)
{
for
(
size_t
i
=
1
;
i
<
data
.
size
(
)
;
i
+
+
)
{
float
x
=
fx
(
data
[
i
]
)
;
absl
:
:
optional
<
ResultType
>
y
=
fy
(
data
[
i
-
1
]
data
[
i
]
)
;
if
(
y
)
result
-
>
points
.
emplace_back
(
x
static_cast
<
float
>
(
*
y
)
)
;
}
}
template
<
typename
DataType
typename
ResultType
typename
IterableType
>
void
AccumulatePairs
(
rtc
:
:
FunctionView
<
float
(
const
DataType
&
)
>
fx
rtc
:
:
FunctionView
<
absl
:
:
optional
<
ResultType
>
(
const
DataType
&
const
DataType
&
)
>
fy
const
IterableType
&
data
TimeSeries
*
result
)
{
ResultType
sum
=
0
;
for
(
size_t
i
=
1
;
i
<
data
.
size
(
)
;
i
+
+
)
{
float
x
=
fx
(
data
[
i
]
)
;
absl
:
:
optional
<
ResultType
>
y
=
fy
(
data
[
i
-
1
]
data
[
i
]
)
;
if
(
y
)
{
sum
+
=
*
y
;
result
-
>
points
.
emplace_back
(
x
static_cast
<
float
>
(
sum
)
)
;
}
}
}
template
<
typename
DataType
typename
ResultType
typename
IterableType
>
void
MovingAverage
(
rtc
:
:
FunctionView
<
absl
:
:
optional
<
ResultType
>
(
const
DataType
&
)
>
fy
const
IterableType
&
data_view
AnalyzerConfig
config
TimeSeries
*
result
)
{
size_t
window_index_begin
=
0
;
size_t
window_index_end
=
0
;
ResultType
sum_in_window
=
0
;
for
(
Timestamp
t
=
config
.
begin_time_
;
t
<
config
.
end_time_
+
config
.
step_
;
t
+
=
config
.
step_
)
{
while
(
window_index_end
<
data_view
.
size
(
)
&
&
data_view
[
window_index_end
]
.
log_time
(
)
<
t
)
{
absl
:
:
optional
<
ResultType
>
value
=
fy
(
data_view
[
window_index_end
]
)
;
if
(
value
)
sum_in_window
+
=
*
value
;
+
+
window_index_end
;
}
while
(
window_index_begin
<
data_view
.
size
(
)
&
&
data_view
[
window_index_begin
]
.
log_time
(
)
<
t
-
config
.
window_duration_
)
{
absl
:
:
optional
<
ResultType
>
value
=
fy
(
data_view
[
window_index_begin
]
)
;
if
(
value
)
sum_in_window
-
=
*
value
;
+
+
window_index_begin
;
}
float
window_duration_s
=
static_cast
<
float
>
(
config
.
window_duration_
.
us
(
)
)
/
kNumMicrosecsPerSec
;
float
x
=
config
.
GetCallTimeSec
(
t
)
;
float
y
=
sum_in_window
/
window_duration_s
;
result
-
>
points
.
emplace_back
(
x
y
)
;
}
}
}
#
endif
