#
include
<
stdio
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
flags
/
flag
.
h
"
#
include
"
absl
/
flags
/
parse
.
h
"
#
include
"
absl
/
flags
/
usage
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
logging
/
rtc_event_log
/
rtc_event_log_parser
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_tools
/
rtc_event_log_to_text
/
converter
.
h
"
ABSL_FLAG
(
bool
parse_unconfigured_header_extensions
true
"
Attempt
to
parse
unconfigured
header
extensions
using
the
default
"
"
WebRTC
mapping
.
This
can
give
very
misleading
results
if
the
"
"
application
negotiates
a
different
mapping
.
"
)
;
int
main
(
int
argc
char
*
argv
[
]
)
{
absl
:
:
SetProgramUsageMessage
(
"
A
tool
for
converting
WebRTC
event
logs
to
text
.
\
n
"
"
The
events
are
sorted
by
log
time
and
printed
\
n
"
"
with
one
event
per
line
using
the
following
format
:
\
n
"
"
<
EVENT_TYPE
>
<
log_time_ms
>
<
field1
>
=
<
value1
>
<
field2
>
=
<
value2
>
.
.
.
\
n
"
"
\
n
"
"
Example
usage
:
\
n
"
"
.
/
rtc_event_log_to_text
<
inputfile
>
<
outputfile
>
\
n
"
"
.
/
rtc_event_log_to_text
<
inputfile
>
\
n
"
"
If
no
output
file
is
specified
the
output
is
written
to
stdout
\
n
"
)
;
std
:
:
vector
<
char
*
>
args
=
absl
:
:
ParseCommandLine
(
argc
argv
)
;
if
(
webrtc
:
:
LogMessage
:
:
GetLogToDebug
(
)
>
webrtc
:
:
LS_WARNING
)
{
webrtc
:
:
LogMessage
:
:
LogToDebug
(
webrtc
:
:
LS_WARNING
)
;
}
webrtc
:
:
LogMessage
:
:
SetLogToStderr
(
true
)
;
webrtc
:
:
ParsedRtcEventLog
:
:
UnconfiguredHeaderExtensions
header_extensions
=
webrtc
:
:
ParsedRtcEventLog
:
:
UnconfiguredHeaderExtensions
:
:
kDontParse
;
if
(
absl
:
:
GetFlag
(
FLAGS_parse_unconfigured_header_extensions
)
)
{
header_extensions
=
webrtc
:
:
ParsedRtcEventLog
:
:
UnconfiguredHeaderExtensions
:
:
kAttemptWebrtcDefaultConfig
;
}
std
:
:
string
inputfile
;
FILE
*
output
=
nullptr
;
if
(
args
.
size
(
)
=
=
3
)
{
inputfile
=
args
[
1
]
;
std
:
:
string
outputfile
=
args
[
2
]
;
output
=
fopen
(
outputfile
.
c_str
(
)
"
w
"
)
;
}
else
if
(
args
.
size
(
)
=
=
2
)
{
inputfile
=
args
[
1
]
;
output
=
stdout
;
}
else
{
absl
:
:
string_view
usage
=
absl
:
:
ProgramUsageMessage
(
)
;
fwrite
(
usage
.
data
(
)
usage
.
size
(
)
1
stderr
)
;
return
1
;
}
bool
success
=
webrtc
:
:
Convert
(
inputfile
output
header_extensions
)
;
return
success
?
0
:
1
;
}
