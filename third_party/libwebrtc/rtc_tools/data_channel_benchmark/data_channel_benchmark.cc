#
include
<
inttypes
.
h
>
#
include
<
charconv
>
#
include
"
absl
/
cleanup
/
cleanup
.
h
"
#
include
"
absl
/
flags
/
flag
.
h
"
#
include
"
absl
/
flags
/
parse
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
ssl_adapter
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_tools
/
data_channel_benchmark
/
grpc_signaling
.
h
"
#
include
"
rtc_tools
/
data_channel_benchmark
/
peer_connection_client
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
ABSL_FLAG
(
int
verbose
0
"
verbosity
level
(
0
-
5
)
"
)
;
ABSL_FLAG
(
bool
server
false
"
Server
mode
"
)
;
ABSL_FLAG
(
bool
oneshot
true
"
Terminate
after
serving
a
client
"
)
;
ABSL_FLAG
(
std
:
:
string
address
"
localhost
"
"
Connect
to
server
address
"
)
;
ABSL_FLAG
(
uint16_t
port
0
"
Connect
to
port
(
0
for
random
)
"
)
;
ABSL_FLAG
(
uint64_t
transfer_size
2
"
Transfer
size
(
MiB
)
"
)
;
ABSL_FLAG
(
uint64_t
packet_size
256
*
1024
"
Packet
size
"
)
;
ABSL_FLAG
(
std
:
:
string
force_fieldtrials
"
"
"
Field
trials
control
experimental
feature
code
which
can
be
forced
.
"
"
E
.
g
.
running
with
-
-
force_fieldtrials
=
WebRTC
-
FooFeature
/
Enable
/
"
"
will
assign
the
group
Enable
to
field
trial
WebRTC
-
FooFeature
.
"
)
;
struct
SetupMessage
{
size_t
packet_size
;
size_t
transfer_size
;
std
:
:
string
ToString
(
)
{
char
buffer
[
64
]
;
rtc
:
:
SimpleStringBuilder
sb
(
buffer
)
;
sb
<
<
packet_size
<
<
"
"
<
<
transfer_size
;
return
sb
.
str
(
)
;
}
static
SetupMessage
FromString
(
absl
:
:
string_view
sv
)
{
SetupMessage
result
;
auto
parameters
=
rtc
:
:
split
(
sv
'
'
)
;
std
:
:
from_chars
(
parameters
[
0
]
.
data
(
)
parameters
[
0
]
.
data
(
)
+
parameters
[
0
]
.
size
(
)
result
.
packet_size
10
)
;
std
:
:
from_chars
(
parameters
[
1
]
.
data
(
)
parameters
[
1
]
.
data
(
)
+
parameters
[
1
]
.
size
(
)
result
.
transfer_size
10
)
;
return
result
;
}
}
;
class
DataChannelObserverImpl
:
public
webrtc
:
:
DataChannelObserver
{
public
:
explicit
DataChannelObserverImpl
(
webrtc
:
:
DataChannelInterface
*
dc
)
:
dc_
(
dc
)
bytes_received_
(
0
)
{
}
void
OnStateChange
(
)
override
{
RTC_LOG
(
LS_INFO
)
<
<
"
State
changed
to
"
<
<
dc_
-
>
state
(
)
;
switch
(
dc_
-
>
state
(
)
)
{
case
webrtc
:
:
DataChannelInterface
:
:
DataState
:
:
kOpen
:
open_event_
.
Set
(
)
;
break
;
case
webrtc
:
:
DataChannelInterface
:
:
DataState
:
:
kClosed
:
closed_event_
.
Set
(
)
;
break
;
default
:
break
;
}
}
void
OnMessage
(
const
webrtc
:
:
DataBuffer
&
buffer
)
override
{
bytes_received_
+
=
buffer
.
data
.
size
(
)
;
if
(
bytes_received_threshold_
&
&
bytes_received_
>
=
bytes_received_threshold_
)
{
bytes_received_event_
.
Set
(
)
;
}
if
(
setup_message_
.
empty
(
)
&
&
!
buffer
.
binary
)
{
setup_message_
.
assign
(
buffer
.
data
.
cdata
<
char
>
(
)
buffer
.
data
.
size
(
)
)
;
setup_message_event_
.
Set
(
)
;
}
}
void
OnBufferedAmountChange
(
uint64_t
sent_data_size
)
override
{
if
(
dc_
-
>
buffered_amount
(
)
<
webrtc
:
:
DataChannelInterface
:
:
MaxSendQueueSize
(
)
/
2
)
low_buffered_threshold_event_
.
Set
(
)
;
else
low_buffered_threshold_event_
.
Reset
(
)
;
}
bool
WaitForOpenState
(
int
duration_ms
)
{
return
dc_
-
>
state
(
)
=
=
webrtc
:
:
DataChannelInterface
:
:
DataState
:
:
kOpen
|
|
open_event_
.
Wait
(
duration_ms
)
;
}
bool
WaitForClosedState
(
int
duration_ms
)
{
return
dc_
-
>
state
(
)
=
=
webrtc
:
:
DataChannelInterface
:
:
DataState
:
:
kClosed
|
|
closed_event_
.
Wait
(
duration_ms
)
;
}
void
SetBytesReceivedThreshold
(
uint64_t
bytes_received_threshold
)
{
bytes_received_threshold_
=
bytes_received_threshold
;
if
(
bytes_received_
>
=
bytes_received_threshold_
)
bytes_received_event_
.
Set
(
)
;
}
bool
WaitForBytesReceivedThreshold
(
int
duration_ms
)
{
return
(
bytes_received_threshold_
&
&
bytes_received_
>
=
bytes_received_threshold_
)
|
|
bytes_received_event_
.
Wait
(
duration_ms
)
;
}
bool
WaitForLowbufferedThreshold
(
int
duration_ms
)
{
return
low_buffered_threshold_event_
.
Wait
(
duration_ms
)
;
}
std
:
:
string
SetupMessage
(
)
{
return
setup_message_
;
}
bool
WaitForSetupMessage
(
int
duration_ms
)
{
return
setup_message_event_
.
Wait
(
duration_ms
)
;
}
private
:
webrtc
:
:
DataChannelInterface
*
dc_
;
rtc
:
:
Event
open_event_
;
rtc
:
:
Event
closed_event_
;
rtc
:
:
Event
bytes_received_event_
;
absl
:
:
optional
<
uint64_t
>
bytes_received_threshold_
;
uint64_t
bytes_received_
;
rtc
:
:
Event
low_buffered_threshold_event_
;
std
:
:
string
setup_message_
;
rtc
:
:
Event
setup_message_event_
;
}
;
int
RunServer
(
)
{
bool
oneshot
=
absl
:
:
GetFlag
(
FLAGS_oneshot
)
;
uint16_t
port
=
absl
:
:
GetFlag
(
FLAGS_port
)
;
auto
signaling_thread
=
rtc
:
:
Thread
:
:
Create
(
)
;
signaling_thread
-
>
Start
(
)
;
{
auto
factory
=
webrtc
:
:
PeerConnectionClient
:
:
CreateDefaultFactory
(
signaling_thread
.
get
(
)
)
;
auto
grpc_server
=
webrtc
:
:
GrpcSignalingServerInterface
:
:
Create
(
[
factory
=
rtc
:
:
scoped_refptr
<
webrtc
:
:
PeerConnectionFactoryInterface
>
(
factory
)
]
(
webrtc
:
:
SignalingInterface
*
signaling
)
{
webrtc
:
:
PeerConnectionClient
client
(
factory
.
get
(
)
signaling
)
;
client
.
StartPeerConnection
(
)
;
auto
peer_connection
=
client
.
peerConnection
(
)
;
auto
dc_or_error
=
peer_connection
-
>
CreateDataChannelOrError
(
"
benchmark
"
nullptr
)
;
auto
data_channel
=
dc_or_error
.
MoveValue
(
)
;
auto
data_channel_observer
=
std
:
:
make_unique
<
DataChannelObserverImpl
>
(
data_channel
.
get
(
)
)
;
data_channel
-
>
RegisterObserver
(
data_channel_observer
.
get
(
)
)
;
absl
:
:
Cleanup
unregister_observer
(
[
data_channel
]
{
data_channel
-
>
UnregisterObserver
(
)
;
}
)
;
data_channel_observer
-
>
WaitForSetupMessage
(
rtc
:
:
Event
:
:
kForever
)
;
auto
parameters
=
SetupMessage
:
:
FromString
(
data_channel_observer
-
>
SetupMessage
(
)
)
;
absl
:
:
SleepFor
(
absl
:
:
Seconds
(
1
)
)
;
std
:
:
string
data
(
parameters
.
packet_size
'
0
'
)
;
size_t
remaining_data
=
parameters
.
transfer_size
;
auto
begin_time
=
webrtc
:
:
Clock
:
:
GetRealTimeClock
(
)
-
>
CurrentTime
(
)
;
while
(
remaining_data
)
{
if
(
remaining_data
<
data
.
size
(
)
)
data
.
resize
(
remaining_data
)
;
rtc
:
:
CopyOnWriteBuffer
buffer
(
data
)
;
webrtc
:
:
DataBuffer
data_buffer
(
buffer
true
)
;
if
(
!
data_channel
-
>
Send
(
data_buffer
)
)
{
data_channel_observer
-
>
WaitForLowbufferedThreshold
(
rtc
:
:
Event
:
:
kForever
)
;
continue
;
}
remaining_data
-
=
buffer
.
size
(
)
;
fprintf
(
stderr
"
Progress
:
%
zu
/
%
zu
(
%
zu
%
%
)
\
n
"
(
parameters
.
transfer_size
-
remaining_data
)
parameters
.
transfer_size
(
100
-
remaining_data
*
100
/
parameters
.
transfer_size
)
)
;
}
data_channel_observer
-
>
WaitForClosedState
(
rtc
:
:
Event
:
:
kForever
)
;
auto
end_time
=
webrtc
:
:
Clock
:
:
GetRealTimeClock
(
)
-
>
CurrentTime
(
)
;
auto
duration_ms
=
(
end_time
-
begin_time
)
.
ms
<
size_t
>
(
)
;
double
throughput
=
(
parameters
.
transfer_size
/
1024
.
/
1024
.
)
/
(
duration_ms
/
1000
.
)
;
printf
(
"
Elapsed
time
:
%
zums
%
gMiB
/
s
\
n
"
duration_ms
throughput
)
;
}
port
oneshot
)
;
grpc_server
-
>
Start
(
)
;
printf
(
"
Server
listening
on
port
%
d
\
n
"
grpc_server
-
>
SelectedPort
(
)
)
;
grpc_server
-
>
Wait
(
)
;
}
signaling_thread
-
>
Quit
(
)
;
return
0
;
}
int
RunClient
(
)
{
uint16_t
port
=
absl
:
:
GetFlag
(
FLAGS_port
)
;
std
:
:
string
server_address
=
absl
:
:
GetFlag
(
FLAGS_address
)
;
size_t
transfer_size
=
absl
:
:
GetFlag
(
FLAGS_transfer_size
)
*
1024
*
1024
;
size_t
packet_size
=
absl
:
:
GetFlag
(
FLAGS_packet_size
)
;
auto
signaling_thread
=
rtc
:
:
Thread
:
:
Create
(
)
;
signaling_thread
-
>
Start
(
)
;
{
auto
factory
=
webrtc
:
:
PeerConnectionClient
:
:
CreateDefaultFactory
(
signaling_thread
.
get
(
)
)
;
auto
grpc_client
=
webrtc
:
:
GrpcSignalingClientInterface
:
:
Create
(
server_address
+
"
:
"
+
std
:
:
to_string
(
port
)
)
;
webrtc
:
:
PeerConnectionClient
client
(
factory
.
get
(
)
grpc_client
-
>
signaling_client
(
)
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
DataChannelInterface
>
data_channel
;
rtc
:
:
Event
got_data_channel
;
client
.
SetOnDataChannel
(
[
&
data_channel
&
got_data_channel
]
(
rtc
:
:
scoped_refptr
<
webrtc
:
:
DataChannelInterface
>
channel
)
{
data_channel
=
channel
;
got_data_channel
.
Set
(
)
;
}
)
;
if
(
!
grpc_client
-
>
Start
(
)
)
{
fprintf
(
stderr
"
Failed
to
connect
to
server
\
n
"
)
;
return
1
;
}
got_data_channel
.
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
DataChannelObserverImpl
observer
(
data_channel
.
get
(
)
)
;
observer
.
SetBytesReceivedThreshold
(
transfer_size
)
;
data_channel
-
>
RegisterObserver
(
&
observer
)
;
absl
:
:
Cleanup
unregister_observer
(
[
data_channel
]
{
data_channel
-
>
UnregisterObserver
(
)
;
}
)
;
observer
.
WaitForOpenState
(
rtc
:
:
Event
:
:
kForever
)
;
SetupMessage
setup_message
=
{
.
packet_size
=
packet_size
.
transfer_size
=
transfer_size
}
;
if
(
!
data_channel
-
>
Send
(
webrtc
:
:
DataBuffer
(
setup_message
.
ToString
(
)
)
)
)
{
fprintf
(
stderr
"
Failed
to
send
parameter
string
\
n
"
)
;
return
1
;
}
observer
.
WaitForBytesReceivedThreshold
(
rtc
:
:
Event
:
:
kForever
)
;
data_channel
-
>
Close
(
)
;
}
signaling_thread
-
>
Quit
(
)
;
return
0
;
}
int
main
(
int
argc
char
*
*
argv
)
{
rtc
:
:
InitializeSSL
(
)
;
absl
:
:
ParseCommandLine
(
argc
argv
)
;
auto
logging_severity
=
std
:
:
max
(
0
rtc
:
:
LS_NONE
-
absl
:
:
GetFlag
(
FLAGS_verbose
)
)
;
rtc
:
:
LogMessage
:
:
LogToDebug
(
static_cast
<
rtc
:
:
LoggingSeverity
>
(
logging_severity
)
)
;
bool
is_server
=
absl
:
:
GetFlag
(
FLAGS_server
)
;
std
:
:
string
field_trials
=
absl
:
:
GetFlag
(
FLAGS_force_fieldtrials
)
;
webrtc
:
:
field_trial
:
:
InitFieldTrialsFromString
(
field_trials
.
c_str
(
)
)
;
return
is_server
?
RunServer
(
)
:
RunClient
(
)
;
}
