#
import
<
Foundation
/
Foundation
.
h
>
#
import
<
OCMock
/
OCMock
.
h
>
#
import
<
QuartzCore
/
CoreAnimation
.
h
>
#
import
<
XCTest
/
XCTest
.
h
>
#
include
"
rtc_base
/
ssl_adapter
.
h
"
#
import
<
WebRTC
/
RTCMediaConstraints
.
h
>
#
import
<
WebRTC
/
RTCPeerConnectionFactory
.
h
>
#
import
"
ARDAppClient
+
Internal
.
h
"
#
import
"
ARDJoinResponse
+
Internal
.
h
"
#
import
"
ARDMessageResponse
+
Internal
.
h
"
#
import
"
ARDSettingsModel
.
h
"
interface
ARDAppClientTest
:
XCTestCase
end
implementation
ARDAppClientTest
#
pragma
mark
-
Mock
helpers
-
(
id
)
mockRoomServerClientForRoomId
:
(
NSString
*
)
roomId
clientId
:
(
NSString
*
)
clientId
isInitiator
:
(
BOOL
)
isInitiator
messages
:
(
NSArray
*
)
messages
messageHandler
:
(
void
(
^
)
(
ARDSignalingMessage
*
)
)
messageHandler
{
id
mockRoomServerClient
=
[
OCMockObject
mockForProtocol
:
protocol
(
ARDRoomServerClient
)
]
;
ARDJoinResponse
*
joinResponse
=
[
[
ARDJoinResponse
alloc
]
init
]
;
joinResponse
.
result
=
kARDJoinResultTypeSuccess
;
joinResponse
.
roomId
=
roomId
;
joinResponse
.
clientId
=
clientId
;
joinResponse
.
isInitiator
=
isInitiator
;
joinResponse
.
messages
=
messages
;
ARDMessageResponse
*
messageResponse
=
[
[
ARDMessageResponse
alloc
]
init
]
;
messageResponse
.
result
=
kARDMessageResultTypeSuccess
;
[
[
[
mockRoomServerClient
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
__unsafe_unretained
void
(
^
completionHandler
)
(
ARDJoinResponse
*
response
NSError
*
error
)
;
[
invocation
getArgument
:
&
completionHandler
atIndex
:
4
]
;
completionHandler
(
joinResponse
nil
)
;
}
]
joinRoomWithRoomId
:
roomId
isLoopback
:
NO
completionHandler
:
[
OCMArg
any
]
]
;
[
[
[
mockRoomServerClient
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
__unsafe_unretained
ARDSignalingMessage
*
message
;
__unsafe_unretained
void
(
^
completionHandler
)
(
ARDMessageResponse
*
response
NSError
*
error
)
;
[
invocation
getArgument
:
&
message
atIndex
:
2
]
;
[
invocation
getArgument
:
&
completionHandler
atIndex
:
5
]
;
messageHandler
(
message
)
;
completionHandler
(
messageResponse
nil
)
;
}
]
sendMessage
:
[
OCMArg
any
]
forRoomId
:
roomId
clientId
:
clientId
completionHandler
:
[
OCMArg
any
]
]
;
[
[
[
mockRoomServerClient
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
__unsafe_unretained
void
(
^
completionHandler
)
(
NSError
*
error
)
;
[
invocation
getArgument
:
&
completionHandler
atIndex
:
4
]
;
if
(
completionHandler
)
{
completionHandler
(
nil
)
;
}
}
]
leaveRoomWithRoomId
:
roomId
clientId
:
clientId
completionHandler
:
[
OCMArg
any
]
]
;
return
mockRoomServerClient
;
}
-
(
id
)
mockSignalingChannelForRoomId
:
(
NSString
*
)
roomId
clientId
:
(
NSString
*
)
clientId
messageHandler
:
(
void
(
^
)
(
ARDSignalingMessage
*
message
)
)
messageHandler
{
id
mockSignalingChannel
=
[
OCMockObject
niceMockForProtocol
:
protocol
(
ARDSignalingChannel
)
]
;
[
[
mockSignalingChannel
stub
]
registerForRoomId
:
roomId
clientId
:
clientId
]
;
[
[
[
mockSignalingChannel
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
__unsafe_unretained
ARDSignalingMessage
*
message
;
[
invocation
getArgument
:
&
message
atIndex
:
2
]
;
messageHandler
(
message
)
;
}
]
sendMessage
:
[
OCMArg
any
]
]
;
return
mockSignalingChannel
;
}
-
(
id
)
mockTURNClient
{
id
mockTURNClient
=
[
OCMockObject
mockForProtocol
:
protocol
(
ARDTURNClient
)
]
;
[
[
[
mockTURNClient
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
__unsafe_unretained
void
(
^
completionHandler
)
(
NSArray
*
turnServers
NSError
*
error
)
;
[
invocation
getArgument
:
&
completionHandler
atIndex
:
2
]
;
completionHandler
(
[
NSArray
array
]
nil
)
;
}
]
requestServersWithCompletionHandler
:
[
OCMArg
any
]
]
;
return
mockTURNClient
;
}
-
(
id
)
mockSettingsModel
{
ARDSettingsModel
*
model
=
[
[
ARDSettingsModel
alloc
]
init
]
;
id
partialMock
=
[
OCMockObject
partialMockForObject
:
model
]
;
[
[
[
partialMock
stub
]
andReturn
:
[
"
640x480
"
"
960x540
"
"
1280x720
"
]
]
availableVideoResolutions
]
;
return
model
;
}
-
(
ARDAppClient
*
)
createAppClientForRoomId
:
(
NSString
*
)
roomId
clientId
:
(
NSString
*
)
clientId
isInitiator
:
(
BOOL
)
isInitiator
messages
:
(
NSArray
*
)
messages
messageHandler
:
(
void
(
^
)
(
ARDSignalingMessage
*
message
)
)
messageHandler
connectedHandler
:
(
void
(
^
)
(
void
)
)
connectedHandler
localVideoTrackHandler
:
(
void
(
^
)
(
void
)
)
localVideoTrackHandler
{
id
turnClient
=
[
self
mockTURNClient
]
;
id
signalingChannel
=
[
self
mockSignalingChannelForRoomId
:
roomId
clientId
:
clientId
messageHandler
:
messageHandler
]
;
id
roomServerClient
=
[
self
mockRoomServerClientForRoomId
:
roomId
clientId
:
clientId
isInitiator
:
isInitiator
messages
:
messages
messageHandler
:
messageHandler
]
;
id
delegate
=
[
OCMockObject
niceMockForProtocol
:
protocol
(
ARDAppClientDelegate
)
]
;
[
[
[
delegate
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
connectedHandler
(
)
;
}
]
appClient
:
[
OCMArg
any
]
didChangeConnectionState
:
RTCIceConnectionStateConnected
]
;
[
[
[
delegate
stub
]
andDo
:
^
(
NSInvocation
*
invocation
)
{
localVideoTrackHandler
(
)
;
}
]
appClient
:
[
OCMArg
any
]
didReceiveLocalVideoTrack
:
[
OCMArg
any
]
]
;
return
[
[
ARDAppClient
alloc
]
initWithRoomServerClient
:
roomServerClient
signalingChannel
:
signalingChannel
turnClient
:
turnClient
delegate
:
delegate
]
;
}
#
pragma
mark
-
Cases
-
(
void
)
testSession
{
ARDAppClient
*
caller
=
nil
;
ARDAppClient
*
answerer
=
nil
;
__block
__weak
ARDAppClient
*
weakCaller
=
nil
;
__block
__weak
ARDAppClient
*
weakAnswerer
=
nil
;
NSString
*
roomId
=
"
testRoom
"
;
NSString
*
callerId
=
"
testCallerId
"
;
NSString
*
answererId
=
"
testAnswererId
"
;
XCTestExpectation
*
callerConnectionExpectation
=
[
self
expectationWithDescription
:
"
Caller
PC
connected
"
]
;
XCTestExpectation
*
answererConnectionExpectation
=
[
self
expectationWithDescription
:
"
Answerer
PC
connected
"
]
;
caller
=
[
self
createAppClientForRoomId
:
roomId
clientId
:
callerId
isInitiator
:
YES
messages
:
[
NSArray
array
]
messageHandler
:
^
(
ARDSignalingMessage
*
message
)
{
ARDAppClient
*
strongAnswerer
=
weakAnswerer
;
[
strongAnswerer
channel
:
strongAnswerer
.
channel
didReceiveMessage
:
message
]
;
}
connectedHandler
:
^
{
[
callerConnectionExpectation
fulfill
]
;
}
localVideoTrackHandler
:
^
{
}
]
;
caller
.
defaultPeerConnectionConstraints
=
[
[
RTC_OBJC_TYPE
(
RTCMediaConstraints
)
alloc
]
initWithMandatoryConstraints
:
nil
optionalConstraints
:
nil
]
;
weakCaller
=
caller
;
answerer
=
[
self
createAppClientForRoomId
:
roomId
clientId
:
answererId
isInitiator
:
NO
messages
:
[
NSArray
array
]
messageHandler
:
^
(
ARDSignalingMessage
*
message
)
{
ARDAppClient
*
strongCaller
=
weakCaller
;
[
strongCaller
channel
:
strongCaller
.
channel
didReceiveMessage
:
message
]
;
}
connectedHandler
:
^
{
[
answererConnectionExpectation
fulfill
]
;
}
localVideoTrackHandler
:
^
{
}
]
;
answerer
.
defaultPeerConnectionConstraints
=
[
[
RTC_OBJC_TYPE
(
RTCMediaConstraints
)
alloc
]
initWithMandatoryConstraints
:
nil
optionalConstraints
:
nil
]
;
weakAnswerer
=
answerer
;
[
caller
connectToRoomWithId
:
roomId
settings
:
[
self
mockSettingsModel
]
isLoopback
:
NO
]
;
[
answerer
connectToRoomWithId
:
roomId
settings
:
[
self
mockSettingsModel
]
isLoopback
:
NO
]
;
[
self
waitForExpectationsWithTimeout
:
20
handler
:
^
(
NSError
*
error
)
{
if
(
error
)
{
XCTFail
(
"
Expectation
failed
with
error
%
.
"
error
)
;
}
}
]
;
}
#
if
!
TARGET_IPHONE_SIMULATOR
-
(
void
)
testSessionShouldGetLocalVideoTrackCallback
{
ARDAppClient
*
caller
=
nil
;
NSString
*
roomId
=
"
testRoom
"
;
NSString
*
callerId
=
"
testCallerId
"
;
XCTestExpectation
*
localVideoTrackExpectation
=
[
self
expectationWithDescription
:
"
Caller
got
local
video
.
"
]
;
caller
=
[
self
createAppClientForRoomId
:
roomId
clientId
:
callerId
isInitiator
:
YES
messages
:
[
NSArray
array
]
messageHandler
:
^
(
ARDSignalingMessage
*
message
)
{
}
connectedHandler
:
^
{
}
localVideoTrackHandler
:
^
{
[
localVideoTrackExpectation
fulfill
]
;
}
]
;
caller
.
defaultPeerConnectionConstraints
=
[
[
RTC_OBJC_TYPE
(
RTCMediaConstraints
)
alloc
]
initWithMandatoryConstraints
:
nil
optionalConstraints
:
nil
]
;
[
caller
connectToRoomWithId
:
roomId
settings
:
[
self
mockSettingsModel
]
isLoopback
:
NO
]
;
[
self
waitForExpectationsWithTimeout
:
20
handler
:
^
(
NSError
*
error
)
{
if
(
error
)
{
XCTFail
(
"
Expectation
timed
out
with
error
:
%
.
"
error
)
;
}
}
]
;
}
#
endif
end
