#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
flags
/
parse
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
conductor
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
flag_defs
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
main_wnd
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
peer_connection_client
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructor_magic
.
h
"
#
include
"
rtc_base
/
ssl_adapter
.
h
"
#
include
"
rtc_base
/
string_utils
.
h
"
#
include
"
rtc_base
/
win32_socket_init
.
h
"
#
include
"
rtc_base
/
win32_socket_server
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
#
include
"
test
/
field_trial
.
h
"
namespace
{
class
WindowsCommandLineArguments
{
public
:
WindowsCommandLineArguments
(
)
;
int
argc
(
)
{
return
argv_
.
size
(
)
;
}
char
*
*
argv
(
)
{
return
argv_
.
data
(
)
;
}
private
:
std
:
:
vector
<
std
:
:
string
>
args_
;
std
:
:
vector
<
char
*
>
argv_
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
WindowsCommandLineArguments
)
;
}
;
WindowsCommandLineArguments
:
:
WindowsCommandLineArguments
(
)
{
LPCWSTR
command_line
=
:
:
GetCommandLineW
(
)
;
int
argc
;
LPWSTR
*
wide_argv
=
:
:
CommandLineToArgvW
(
command_line
&
argc
)
;
for
(
int
i
=
0
;
i
<
argc
;
+
+
i
)
{
args_
.
push_back
(
rtc
:
:
ToUtf8
(
wide_argv
[
i
]
wcslen
(
wide_argv
[
i
]
)
)
)
;
argv_
.
push_back
(
const_cast
<
char
*
>
(
args_
.
back
(
)
.
c_str
(
)
)
)
;
}
LocalFree
(
wide_argv
)
;
}
}
int
PASCAL
wWinMain
(
HINSTANCE
instance
HINSTANCE
prev_instance
wchar_t
*
cmd_line
int
cmd_show
)
{
rtc
:
:
WinsockInitializer
winsock_init
;
rtc
:
:
Win32SocketServer
w32_ss
;
rtc
:
:
Win32Thread
w32_thread
(
&
w32_ss
)
;
rtc
:
:
ThreadManager
:
:
Instance
(
)
-
>
SetCurrentThread
(
&
w32_thread
)
;
WindowsCommandLineArguments
win_args
;
int
argc
=
win_args
.
argc
(
)
;
char
*
*
argv
=
win_args
.
argv
(
)
;
absl
:
:
ParseCommandLine
(
argc
argv
)
;
const
std
:
:
string
forced_field_trials
=
absl
:
:
GetFlag
(
FLAGS_force_fieldtrials
)
;
webrtc
:
:
field_trial
:
:
InitFieldTrialsFromString
(
forced_field_trials
.
c_str
(
)
)
;
if
(
(
absl
:
:
GetFlag
(
FLAGS_port
)
<
1
)
|
|
(
absl
:
:
GetFlag
(
FLAGS_port
)
>
65535
)
)
{
printf
(
"
Error
:
%
i
is
not
a
valid
port
.
\
n
"
absl
:
:
GetFlag
(
FLAGS_port
)
)
;
return
-
1
;
}
const
std
:
:
string
server
=
absl
:
:
GetFlag
(
FLAGS_server
)
;
MainWnd
wnd
(
server
.
c_str
(
)
absl
:
:
GetFlag
(
FLAGS_port
)
absl
:
:
GetFlag
(
FLAGS_autoconnect
)
absl
:
:
GetFlag
(
FLAGS_autocall
)
)
;
if
(
!
wnd
.
Create
(
)
)
{
RTC_NOTREACHED
(
)
;
return
-
1
;
}
rtc
:
:
InitializeSSL
(
)
;
PeerConnectionClient
client
;
rtc
:
:
scoped_refptr
<
Conductor
>
conductor
(
new
rtc
:
:
RefCountedObject
<
Conductor
>
(
&
client
&
wnd
)
)
;
MSG
msg
;
BOOL
gm
;
while
(
(
gm
=
:
:
GetMessage
(
&
msg
NULL
0
0
)
)
!
=
0
&
&
gm
!
=
-
1
)
{
if
(
!
wnd
.
PreTranslateMessage
(
&
msg
)
)
{
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessage
(
&
msg
)
;
}
}
if
(
conductor
-
>
connection_active
(
)
|
|
client
.
is_connected
(
)
)
{
while
(
(
conductor
-
>
connection_active
(
)
|
|
client
.
is_connected
(
)
)
&
&
(
gm
=
:
:
GetMessage
(
&
msg
NULL
0
0
)
)
!
=
0
&
&
gm
!
=
-
1
)
{
if
(
!
wnd
.
PreTranslateMessage
(
&
msg
)
)
{
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessage
(
&
msg
)
;
}
}
}
rtc
:
:
CleanupSSL
(
)
;
return
0
;
}
