#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
flags
/
parse
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
conductor
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
flag_defs
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
main_wnd
.
h
"
#
include
"
examples
/
peerconnection
/
client
/
peer_connection_client
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
ssl_adapter
.
h
"
#
include
"
rtc_base
/
string_utils
.
h
"
#
include
"
rtc_base
/
win32_socket_init
.
h
"
#
include
"
system_wrappers
/
include
/
field_trial
.
h
"
#
include
"
test
/
field_trial
.
h
"
namespace
{
class
WindowsCommandLineArguments
{
public
:
WindowsCommandLineArguments
(
)
;
WindowsCommandLineArguments
(
const
WindowsCommandLineArguments
&
)
=
delete
;
WindowsCommandLineArguments
&
operator
=
(
WindowsCommandLineArguments
&
)
=
delete
;
int
argc
(
)
{
return
argv_
.
size
(
)
;
}
char
*
*
argv
(
)
{
return
argv_
.
data
(
)
;
}
private
:
std
:
:
vector
<
std
:
:
string
>
args_
;
std
:
:
vector
<
char
*
>
argv_
;
}
;
WindowsCommandLineArguments
:
:
WindowsCommandLineArguments
(
)
{
LPCWSTR
command_line
=
:
:
GetCommandLineW
(
)
;
int
argc
;
LPWSTR
*
wide_argv
=
:
:
CommandLineToArgvW
(
command_line
&
argc
)
;
for
(
int
i
=
0
;
i
<
argc
;
+
+
i
)
{
args_
.
push_back
(
webrtc
:
:
ToUtf8
(
wide_argv
[
i
]
wcslen
(
wide_argv
[
i
]
)
)
)
;
argv_
.
push_back
(
const_cast
<
char
*
>
(
args_
.
back
(
)
.
c_str
(
)
)
)
;
}
LocalFree
(
wide_argv
)
;
}
}
int
PASCAL
wWinMain
(
HINSTANCE
instance
HINSTANCE
prev_instance
wchar_t
*
cmd_line
int
cmd_show
)
{
webrtc
:
:
WinsockInitializer
winsock_init
;
webrtc
:
:
PhysicalSocketServer
ss
;
webrtc
:
:
AutoSocketServerThread
main_thread
(
&
ss
)
;
WindowsCommandLineArguments
win_args
;
int
argc
=
win_args
.
argc
(
)
;
char
*
*
argv
=
win_args
.
argv
(
)
;
absl
:
:
ParseCommandLine
(
argc
argv
)
;
const
std
:
:
string
forced_field_trials
=
absl
:
:
GetFlag
(
FLAGS_force_fieldtrials
)
;
webrtc
:
:
field_trial
:
:
InitFieldTrialsFromString
(
forced_field_trials
.
c_str
(
)
)
;
if
(
(
absl
:
:
GetFlag
(
FLAGS_port
)
<
1
)
|
|
(
absl
:
:
GetFlag
(
FLAGS_port
)
>
65535
)
)
{
printf
(
"
Error
:
%
i
is
not
a
valid
port
.
\
n
"
absl
:
:
GetFlag
(
FLAGS_port
)
)
;
return
-
1
;
}
const
std
:
:
string
server
=
absl
:
:
GetFlag
(
FLAGS_server
)
;
MainWnd
wnd
(
server
.
c_str
(
)
absl
:
:
GetFlag
(
FLAGS_port
)
absl
:
:
GetFlag
(
FLAGS_autoconnect
)
absl
:
:
GetFlag
(
FLAGS_autocall
)
)
;
if
(
!
wnd
.
Create
(
)
)
{
RTC_DCHECK_NOTREACHED
(
)
;
return
-
1
;
}
webrtc
:
:
InitializeSSL
(
)
;
PeerConnectionClient
client
;
auto
conductor
=
webrtc
:
:
make_ref_counted
<
Conductor
>
(
&
client
&
wnd
)
;
MSG
msg
;
BOOL
gm
;
while
(
(
gm
=
:
:
GetMessage
(
&
msg
NULL
0
0
)
)
!
=
0
&
&
gm
!
=
-
1
)
{
if
(
!
wnd
.
PreTranslateMessage
(
&
msg
)
)
{
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessage
(
&
msg
)
;
}
}
if
(
conductor
-
>
connection_active
(
)
|
|
client
.
is_connected
(
)
)
{
while
(
(
conductor
-
>
connection_active
(
)
|
|
client
.
is_connected
(
)
)
&
&
(
gm
=
:
:
GetMessage
(
&
msg
NULL
0
0
)
)
!
=
0
&
&
gm
!
=
-
1
)
{
if
(
!
wnd
.
PreTranslateMessage
(
&
msg
)
)
{
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessage
(
&
msg
)
;
}
}
}
webrtc
:
:
CleanupSSL
(
)
;
return
0
;
}
