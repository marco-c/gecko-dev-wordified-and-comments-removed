package
org
.
appspot
.
apprtc
.
test
;
import
static
org
.
junit
.
Assert
.
assertTrue
;
import
static
org
.
junit
.
Assert
.
fail
;
import
android
.
os
.
Build
;
import
android
.
support
.
test
.
InstrumentationRegistry
;
import
android
.
support
.
test
.
runner
.
AndroidJUnit4
;
import
android
.
util
.
Log
;
import
androidx
.
test
.
filters
.
SmallTest
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
java
.
util
.
concurrent
.
ExecutorService
;
import
java
.
util
.
concurrent
.
Executors
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
appspot
.
apprtc
.
AppRTCClient
.
SignalingParameters
;
import
org
.
appspot
.
apprtc
.
PeerConnectionClient
;
import
org
.
appspot
.
apprtc
.
PeerConnectionClient
.
PeerConnectionEvents
;
import
org
.
appspot
.
apprtc
.
PeerConnectionClient
.
PeerConnectionParameters
;
import
org
.
junit
.
After
;
import
org
.
junit
.
Before
;
import
org
.
junit
.
Test
;
import
org
.
junit
.
runner
.
RunWith
;
import
org
.
webrtc
.
Camera1Enumerator
;
import
org
.
webrtc
.
Camera2Enumerator
;
import
org
.
webrtc
.
CameraEnumerator
;
import
org
.
webrtc
.
EglBase
;
import
org
.
webrtc
.
IceCandidate
;
import
org
.
webrtc
.
PeerConnection
;
import
org
.
webrtc
.
PeerConnectionFactory
;
import
org
.
webrtc
.
RTCStatsReport
;
import
org
.
webrtc
.
SessionDescription
;
import
org
.
webrtc
.
VideoCapturer
;
import
org
.
webrtc
.
VideoFrame
;
import
org
.
webrtc
.
VideoSink
;
RunWith
(
AndroidJUnit4
.
class
)
public
class
PeerConnectionClientTest
implements
PeerConnectionEvents
{
private
static
final
String
TAG
=
"
RTCClientTest
"
;
private
static
final
int
ICE_CONNECTION_WAIT_TIMEOUT
=
10000
;
private
static
final
int
WAIT_TIMEOUT
=
7000
;
private
static
final
int
CAMERA_SWITCH_ATTEMPTS
=
3
;
private
static
final
int
VIDEO_RESTART_ATTEMPTS
=
3
;
private
static
final
int
CAPTURE_FORMAT_CHANGE_ATTEMPTS
=
3
;
private
static
final
int
VIDEO_RESTART_TIMEOUT
=
500
;
private
static
final
int
EXPECTED_VIDEO_FRAMES
=
10
;
private
static
final
String
VIDEO_CODEC_VP8
=
"
VP8
"
;
private
static
final
String
VIDEO_CODEC_VP9
=
"
VP9
"
;
private
static
final
String
VIDEO_CODEC_H264
=
"
H264
"
;
private
static
final
int
AUDIO_RUN_TIMEOUT
=
1000
;
private
static
final
String
LOCAL_RENDERER_NAME
=
"
Local
renderer
"
;
private
static
final
String
REMOTE_RENDERER_NAME
=
"
Remote
renderer
"
;
private
static
final
int
MAX_VIDEO_FPS
=
30
;
private
static
final
int
WIDTH_VGA
=
640
;
private
static
final
int
HEIGHT_VGA
=
480
;
private
static
final
int
WIDTH_QVGA
=
320
;
private
static
final
int
HEIGHT_QVGA
=
240
;
private
volatile
PeerConnectionClient
pcClient
;
private
volatile
boolean
loopback
;
private
ExecutorService
signalingExecutor
;
private
boolean
isClosed
;
private
boolean
isIceConnected
;
private
SessionDescription
localDesc
;
private
List
<
IceCandidate
>
iceCandidates
=
new
ArrayList
<
>
(
)
;
private
final
Object
localDescEvent
=
new
Object
(
)
;
private
final
Object
iceCandidateEvent
=
new
Object
(
)
;
private
final
Object
iceConnectedEvent
=
new
Object
(
)
;
private
final
Object
closeEvent
=
new
Object
(
)
;
private
static
class
MockSink
implements
VideoSink
{
private
String
rendererName
;
private
boolean
renderFrameCalled
;
private
CountDownLatch
doneRendering
;
public
MockSink
(
int
expectedFrames
String
rendererName
)
{
this
.
rendererName
=
rendererName
;
reset
(
expectedFrames
)
;
}
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
void
reset
(
int
expectedFrames
)
{
renderFrameCalled
=
false
;
doneRendering
=
new
CountDownLatch
(
expectedFrames
)
;
}
Override
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
void
onFrame
(
VideoFrame
frame
)
{
if
(
!
renderFrameCalled
)
{
if
(
rendererName
!
=
null
)
{
Log
.
d
(
TAG
rendererName
+
"
render
frame
:
"
+
frame
.
getRotatedWidth
(
)
+
"
x
"
+
frame
.
getRotatedHeight
(
)
)
;
}
else
{
Log
.
d
(
TAG
"
Render
frame
:
"
+
frame
.
getRotatedWidth
(
)
+
"
x
"
+
frame
.
getRotatedHeight
(
)
)
;
}
}
renderFrameCalled
=
true
;
doneRendering
.
countDown
(
)
;
}
public
boolean
waitForFramesRendered
(
int
timeoutMs
)
throws
InterruptedException
{
doneRendering
.
await
(
timeoutMs
TimeUnit
.
MILLISECONDS
)
;
return
(
doneRendering
.
getCount
(
)
<
=
0
)
;
}
}
Override
public
void
onLocalDescription
(
SessionDescription
desc
)
{
Log
.
d
(
TAG
"
Local
description
type
:
"
+
desc
.
type
)
;
synchronized
(
localDescEvent
)
{
localDesc
=
desc
;
localDescEvent
.
notifyAll
(
)
;
}
}
Override
public
void
onIceCandidate
(
final
IceCandidate
candidate
)
{
synchronized
(
iceCandidateEvent
)
{
Log
.
d
(
TAG
"
IceCandidate
#
"
+
iceCandidates
.
size
(
)
+
"
:
"
+
candidate
.
toString
(
)
)
;
if
(
loopback
)
{
signalingExecutor
.
execute
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
pcClient
.
addRemoteIceCandidate
(
candidate
)
;
}
}
)
;
}
iceCandidates
.
add
(
candidate
)
;
iceCandidateEvent
.
notifyAll
(
)
;
}
}
Override
public
void
onIceCandidatesRemoved
(
final
IceCandidate
[
]
candidates
)
{
}
Override
public
void
onIceConnected
(
)
{
Log
.
d
(
TAG
"
ICE
Connected
"
)
;
synchronized
(
iceConnectedEvent
)
{
isIceConnected
=
true
;
iceConnectedEvent
.
notifyAll
(
)
;
}
}
Override
public
void
onIceDisconnected
(
)
{
Log
.
d
(
TAG
"
ICE
Disconnected
"
)
;
synchronized
(
iceConnectedEvent
)
{
isIceConnected
=
false
;
iceConnectedEvent
.
notifyAll
(
)
;
}
}
Override
public
void
onConnected
(
)
{
Log
.
d
(
TAG
"
DTLS
Connected
"
)
;
}
Override
public
void
onDisconnected
(
)
{
Log
.
d
(
TAG
"
DTLS
Disconnected
"
)
;
}
Override
public
void
onPeerConnectionClosed
(
)
{
Log
.
d
(
TAG
"
PeerConnection
closed
"
)
;
synchronized
(
closeEvent
)
{
isClosed
=
true
;
closeEvent
.
notifyAll
(
)
;
}
}
Override
public
void
onPeerConnectionError
(
String
description
)
{
fail
(
"
PC
Error
:
"
+
description
)
;
}
Override
public
void
onPeerConnectionStatsReady
(
final
RTCStatsReport
report
)
{
}
private
boolean
waitForLocalDescription
(
int
timeoutMs
)
throws
InterruptedException
{
synchronized
(
localDescEvent
)
{
final
long
endTimeMs
=
System
.
currentTimeMillis
(
)
+
timeoutMs
;
while
(
localDesc
=
=
null
)
{
final
long
waitTimeMs
=
endTimeMs
-
System
.
currentTimeMillis
(
)
;
if
(
waitTimeMs
<
0
)
{
return
false
;
}
localDescEvent
.
wait
(
waitTimeMs
)
;
}
return
true
;
}
}
private
boolean
waitForIceCandidates
(
int
timeoutMs
)
throws
InterruptedException
{
synchronized
(
iceCandidateEvent
)
{
final
long
endTimeMs
=
System
.
currentTimeMillis
(
)
+
timeoutMs
;
while
(
iceCandidates
.
size
(
)
=
=
0
)
{
final
long
waitTimeMs
=
endTimeMs
-
System
.
currentTimeMillis
(
)
;
if
(
waitTimeMs
<
0
)
{
return
false
;
}
iceCandidateEvent
.
wait
(
timeoutMs
)
;
}
return
true
;
}
}
private
boolean
waitForIceConnected
(
int
timeoutMs
)
throws
InterruptedException
{
synchronized
(
iceConnectedEvent
)
{
final
long
endTimeMs
=
System
.
currentTimeMillis
(
)
+
timeoutMs
;
while
(
!
isIceConnected
)
{
final
long
waitTimeMs
=
endTimeMs
-
System
.
currentTimeMillis
(
)
;
if
(
waitTimeMs
<
0
)
{
Log
.
e
(
TAG
"
ICE
connection
failure
"
)
;
return
false
;
}
iceConnectedEvent
.
wait
(
timeoutMs
)
;
}
return
true
;
}
}
private
boolean
waitForPeerConnectionClosed
(
int
timeoutMs
)
throws
InterruptedException
{
synchronized
(
closeEvent
)
{
final
long
endTimeMs
=
System
.
currentTimeMillis
(
)
+
timeoutMs
;
while
(
!
isClosed
)
{
final
long
waitTimeMs
=
endTimeMs
-
System
.
currentTimeMillis
(
)
;
if
(
waitTimeMs
<
0
)
{
return
false
;
}
closeEvent
.
wait
(
timeoutMs
)
;
}
return
true
;
}
}
PeerConnectionClient
createPeerConnectionClient
(
MockSink
localRenderer
MockSink
remoteRenderer
PeerConnectionParameters
peerConnectionParameters
VideoCapturer
videoCapturer
)
{
List
<
PeerConnection
.
IceServer
>
iceServers
=
new
ArrayList
<
>
(
)
;
SignalingParameters
signalingParameters
=
new
SignalingParameters
(
iceServers
true
null
null
null
null
null
)
;
final
EglBase
eglBase
=
EglBase
.
create
(
)
;
PeerConnectionClient
client
=
new
PeerConnectionClient
(
InstrumentationRegistry
.
getTargetContext
(
)
eglBase
peerConnectionParameters
this
)
;
PeerConnectionFactory
.
Options
options
=
new
PeerConnectionFactory
.
Options
(
)
;
options
.
networkIgnoreMask
=
0
;
options
.
disableNetworkMonitor
=
true
;
client
.
createPeerConnectionFactory
(
options
)
;
client
.
createPeerConnection
(
localRenderer
remoteRenderer
videoCapturer
signalingParameters
)
;
client
.
createOffer
(
)
;
return
client
;
}
private
PeerConnectionParameters
createParametersForAudioCall
(
)
{
return
new
PeerConnectionParameters
(
false
true
false
0
0
0
0
"
"
true
false
0
"
OPUS
"
false
false
false
false
false
false
false
false
false
null
)
;
}
private
VideoCapturer
createCameraCapturer
(
boolean
captureToTexture
)
{
final
boolean
useCamera2
=
captureToTexture
&
&
Camera2Enumerator
.
isSupported
(
InstrumentationRegistry
.
getTargetContext
(
)
)
;
CameraEnumerator
enumerator
;
if
(
useCamera2
)
{
enumerator
=
new
Camera2Enumerator
(
InstrumentationRegistry
.
getTargetContext
(
)
)
;
}
else
{
enumerator
=
new
Camera1Enumerator
(
captureToTexture
)
;
}
String
deviceName
=
enumerator
.
getDeviceNames
(
)
[
0
]
;
return
enumerator
.
createCapturer
(
deviceName
null
)
;
}
private
PeerConnectionParameters
createParametersForVideoCall
(
String
videoCodec
)
{
return
new
PeerConnectionParameters
(
true
true
false
0
0
0
0
videoCodec
true
false
0
"
OPUS
"
false
false
false
false
false
false
false
false
false
null
)
;
}
Before
public
void
setUp
(
)
{
signalingExecutor
=
Executors
.
newSingleThreadExecutor
(
)
;
}
After
public
void
tearDown
(
)
{
signalingExecutor
.
shutdown
(
)
;
}
Test
SmallTest
public
void
testSetLocalOfferMakesVideoFlowLocally
(
)
throws
InterruptedException
{
Log
.
d
(
TAG
"
testSetLocalOfferMakesVideoFlowLocally
"
)
;
MockSink
localRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
LOCAL_RENDERER_NAME
)
;
pcClient
=
createPeerConnectionClient
(
localRenderer
new
MockSink
(
0
null
)
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
false
)
)
;
assertTrue
(
"
Local
description
was
not
set
.
"
waitForLocalDescription
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
ICE
candidates
were
not
generated
.
"
waitForIceCandidates
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
pcClient
.
close
(
)
;
assertTrue
(
"
PeerConnection
close
event
was
not
received
.
"
waitForPeerConnectionClosed
(
WAIT_TIMEOUT
)
)
;
Log
.
d
(
TAG
"
testSetLocalOfferMakesVideoFlowLocally
Done
.
"
)
;
}
private
void
doLoopbackTest
(
PeerConnectionParameters
parameters
VideoCapturer
videoCapturer
boolean
decodeToTexture
)
throws
InterruptedException
{
loopback
=
true
;
MockSink
localRenderer
=
null
;
MockSink
remoteRenderer
=
null
;
if
(
parameters
.
videoCallEnabled
)
{
Log
.
d
(
TAG
"
testLoopback
for
video
"
+
parameters
.
videoCodec
)
;
localRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
LOCAL_RENDERER_NAME
)
;
remoteRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
REMOTE_RENDERER_NAME
)
;
}
else
{
Log
.
d
(
TAG
"
testLoopback
for
audio
.
"
)
;
}
pcClient
=
createPeerConnectionClient
(
localRenderer
remoteRenderer
parameters
videoCapturer
)
;
assertTrue
(
"
Local
description
was
not
set
.
"
waitForLocalDescription
(
WAIT_TIMEOUT
)
)
;
SessionDescription
remoteDescription
=
new
SessionDescription
(
SessionDescription
.
Type
.
fromCanonicalForm
(
"
answer
"
)
localDesc
.
description
)
;
pcClient
.
setRemoteDescription
(
remoteDescription
)
;
assertTrue
(
"
ICE
connection
failure
.
"
waitForIceConnected
(
ICE_CONNECTION_WAIT_TIMEOUT
)
)
;
if
(
parameters
.
videoCallEnabled
)
{
assertTrue
(
"
Local
video
frames
were
not
rendered
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
}
else
{
Thread
.
sleep
(
AUDIO_RUN_TIMEOUT
)
;
}
pcClient
.
close
(
)
;
assertTrue
(
waitForPeerConnectionClosed
(
WAIT_TIMEOUT
)
)
;
Log
.
d
(
TAG
"
testLoopback
done
.
"
)
;
}
Test
SmallTest
public
void
testLoopbackAudio
(
)
throws
InterruptedException
{
doLoopbackTest
(
createParametersForAudioCall
(
)
null
false
)
;
}
Test
SmallTest
public
void
testLoopbackVp8
(
)
throws
InterruptedException
{
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
false
)
false
)
;
}
Test
SmallTest
public
void
testLoopbackVp9
(
)
throws
InterruptedException
{
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_VP9
)
createCameraCapturer
(
false
)
false
)
;
}
Test
SmallTest
public
void
testLoopbackH264
(
)
throws
InterruptedException
{
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_H264
)
createCameraCapturer
(
false
)
false
)
;
}
Test
SmallTest
public
void
testLoopbackVp8DecodeToTexture
(
)
throws
InterruptedException
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
)
{
Log
.
i
(
TAG
"
Decode
to
textures
is
not
supported
requires
SDK
version
19
.
"
)
;
return
;
}
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
false
)
true
)
;
}
Test
SmallTest
public
void
testLoopbackVp9DecodeToTexture
(
)
throws
InterruptedException
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
)
{
Log
.
i
(
TAG
"
Decode
to
textures
is
not
supported
requires
SDK
version
19
.
"
)
;
return
;
}
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_VP9
)
createCameraCapturer
(
false
)
true
)
;
}
Test
SmallTest
public
void
testLoopbackH264DecodeToTexture
(
)
throws
InterruptedException
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
)
{
Log
.
i
(
TAG
"
Decode
to
textures
is
not
supported
requires
SDK
version
19
.
"
)
;
return
;
}
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_H264
)
createCameraCapturer
(
false
)
true
)
;
}
Test
SmallTest
public
void
testLoopbackVp8CaptureToTexture
(
)
throws
InterruptedException
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
)
{
Log
.
i
(
TAG
"
Encode
to
textures
is
not
supported
.
Requires
SDK
version
19
"
)
;
return
;
}
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
true
)
true
)
;
}
Test
SmallTest
public
void
testLoopbackH264CaptureToTexture
(
)
throws
InterruptedException
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
)
{
Log
.
i
(
TAG
"
Encode
to
textures
is
not
supported
.
Requires
KITKAT
"
)
;
return
;
}
doLoopbackTest
(
createParametersForVideoCall
(
VIDEO_CODEC_H264
)
createCameraCapturer
(
true
)
true
)
;
}
Test
SmallTest
public
void
testCameraSwitch
(
)
throws
InterruptedException
{
Log
.
d
(
TAG
"
testCameraSwitch
"
)
;
loopback
=
true
;
MockSink
localRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
LOCAL_RENDERER_NAME
)
;
MockSink
remoteRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
REMOTE_RENDERER_NAME
)
;
pcClient
=
createPeerConnectionClient
(
localRenderer
remoteRenderer
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
false
)
)
;
assertTrue
(
"
Local
description
was
not
set
.
"
waitForLocalDescription
(
WAIT_TIMEOUT
)
)
;
SessionDescription
remoteDescription
=
new
SessionDescription
(
SessionDescription
.
Type
.
fromCanonicalForm
(
"
answer
"
)
localDesc
.
description
)
;
pcClient
.
setRemoteDescription
(
remoteDescription
)
;
assertTrue
(
"
ICE
connection
failure
.
"
waitForIceConnected
(
ICE_CONNECTION_WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
before
camera
switch
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
before
camera
switch
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
for
(
int
i
=
0
;
i
<
CAMERA_SWITCH_ATTEMPTS
;
i
+
+
)
{
pcClient
.
switchCamera
(
)
;
localRenderer
.
reset
(
EXPECTED_VIDEO_FRAMES
)
;
remoteRenderer
.
reset
(
EXPECTED_VIDEO_FRAMES
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
after
camera
switch
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
after
camera
switch
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
}
pcClient
.
close
(
)
;
assertTrue
(
waitForPeerConnectionClosed
(
WAIT_TIMEOUT
)
)
;
Log
.
d
(
TAG
"
testCameraSwitch
done
.
"
)
;
}
Test
SmallTest
public
void
testVideoSourceRestart
(
)
throws
InterruptedException
{
Log
.
d
(
TAG
"
testVideoSourceRestart
"
)
;
loopback
=
true
;
MockSink
localRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
LOCAL_RENDERER_NAME
)
;
MockSink
remoteRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
REMOTE_RENDERER_NAME
)
;
pcClient
=
createPeerConnectionClient
(
localRenderer
remoteRenderer
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
false
)
)
;
assertTrue
(
"
Local
description
was
not
set
.
"
waitForLocalDescription
(
WAIT_TIMEOUT
)
)
;
SessionDescription
remoteDescription
=
new
SessionDescription
(
SessionDescription
.
Type
.
fromCanonicalForm
(
"
answer
"
)
localDesc
.
description
)
;
pcClient
.
setRemoteDescription
(
remoteDescription
)
;
assertTrue
(
"
ICE
connection
failure
.
"
waitForIceConnected
(
ICE_CONNECTION_WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
before
video
restart
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
before
video
restart
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
for
(
int
i
=
0
;
i
<
VIDEO_RESTART_ATTEMPTS
;
i
+
+
)
{
pcClient
.
stopVideoSource
(
)
;
Thread
.
sleep
(
VIDEO_RESTART_TIMEOUT
)
;
pcClient
.
startVideoSource
(
)
;
localRenderer
.
reset
(
EXPECTED_VIDEO_FRAMES
)
;
remoteRenderer
.
reset
(
EXPECTED_VIDEO_FRAMES
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
after
video
restart
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
after
video
restart
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
}
pcClient
.
close
(
)
;
assertTrue
(
waitForPeerConnectionClosed
(
WAIT_TIMEOUT
)
)
;
Log
.
d
(
TAG
"
testVideoSourceRestart
done
.
"
)
;
}
Test
SmallTest
public
void
testCaptureFormatChange
(
)
throws
InterruptedException
{
Log
.
d
(
TAG
"
testCaptureFormatChange
"
)
;
loopback
=
true
;
MockSink
localRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
LOCAL_RENDERER_NAME
)
;
MockSink
remoteRenderer
=
new
MockSink
(
EXPECTED_VIDEO_FRAMES
REMOTE_RENDERER_NAME
)
;
pcClient
=
createPeerConnectionClient
(
localRenderer
remoteRenderer
createParametersForVideoCall
(
VIDEO_CODEC_VP8
)
createCameraCapturer
(
false
)
)
;
assertTrue
(
"
Local
description
was
not
set
.
"
waitForLocalDescription
(
WAIT_TIMEOUT
)
)
;
SessionDescription
remoteDescription
=
new
SessionDescription
(
SessionDescription
.
Type
.
fromCanonicalForm
(
"
answer
"
)
localDesc
.
description
)
;
pcClient
.
setRemoteDescription
(
remoteDescription
)
;
assertTrue
(
"
ICE
connection
failure
.
"
waitForIceConnected
(
ICE_CONNECTION_WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
before
camera
resolution
change
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
before
camera
resolution
change
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
for
(
int
i
=
0
;
i
<
2
*
CAPTURE_FORMAT_CHANGE_ATTEMPTS
;
i
+
+
)
{
if
(
i
%
2
=
=
0
)
{
pcClient
.
changeCaptureFormat
(
WIDTH_VGA
HEIGHT_VGA
MAX_VIDEO_FPS
)
;
}
else
{
pcClient
.
changeCaptureFormat
(
WIDTH_QVGA
HEIGHT_QVGA
MAX_VIDEO_FPS
)
;
}
localRenderer
.
reset
(
EXPECTED_VIDEO_FRAMES
)
;
remoteRenderer
.
reset
(
EXPECTED_VIDEO_FRAMES
)
;
assertTrue
(
"
Local
video
frames
were
not
rendered
after
capture
format
change
.
"
localRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
assertTrue
(
"
Remote
video
frames
were
not
rendered
after
capture
format
change
.
"
remoteRenderer
.
waitForFramesRendered
(
WAIT_TIMEOUT
)
)
;
}
pcClient
.
close
(
)
;
assertTrue
(
waitForPeerConnectionClosed
(
WAIT_TIMEOUT
)
)
;
Log
.
d
(
TAG
"
testCaptureFormatChange
done
.
"
)
;
}
}
