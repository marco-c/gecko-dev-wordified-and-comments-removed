package
org
.
webrtc
;
import
static
com
.
google
.
common
.
truth
.
Truth
.
assertThat
;
import
static
java
.
util
.
concurrent
.
TimeUnit
.
SECONDS
;
import
static
org
.
mockito
.
ArgumentMatchers
.
any
;
import
static
org
.
mockito
.
ArgumentMatchers
.
anyInt
;
import
static
org
.
mockito
.
ArgumentMatchers
.
anyLong
;
import
static
org
.
mockito
.
Mockito
.
spy
;
import
static
org
.
mockito
.
Mockito
.
times
;
import
static
org
.
mockito
.
Mockito
.
verify
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodecInfo
;
import
android
.
media
.
MediaFormat
;
import
android
.
os
.
Bundle
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
import
org
.
chromium
.
testing
.
local
.
LocalRobolectricTestRunner
;
import
org
.
junit
.
Before
;
import
org
.
junit
.
Test
;
import
org
.
junit
.
runner
.
RunWith
;
import
org
.
mockito
.
ArgumentCaptor
;
import
org
.
mockito
.
Mock
;
import
org
.
mockito
.
MockitoAnnotations
;
import
org
.
robolectric
.
annotation
.
Config
;
import
org
.
webrtc
.
EncodedImage
;
import
org
.
webrtc
.
EncodedImage
.
FrameType
;
import
org
.
webrtc
.
FakeMediaCodecWrapper
.
State
;
import
org
.
webrtc
.
VideoCodecStatus
;
import
org
.
webrtc
.
VideoEncoder
;
import
org
.
webrtc
.
VideoEncoder
.
BitrateAllocation
;
import
org
.
webrtc
.
VideoEncoder
.
CodecSpecificInfo
;
import
org
.
webrtc
.
VideoEncoder
.
EncodeInfo
;
import
org
.
webrtc
.
VideoEncoder
.
Settings
;
import
org
.
webrtc
.
VideoFrame
;
import
org
.
webrtc
.
VideoFrame
.
Buffer
;
import
org
.
webrtc
.
VideoFrame
.
I420Buffer
;
RunWith
(
LocalRobolectricTestRunner
.
class
)
Config
(
manifest
=
Config
.
NONE
)
public
class
HardwareVideoEncoderTest
{
private
static
final
VideoEncoder
.
Settings
TEST_ENCODER_SETTINGS
=
new
Settings
(
1
640
480
10000
30
1
true
new
VideoEncoder
.
Capabilities
(
false
)
)
;
private
static
final
long
POLL_DELAY_MS
=
10
;
private
static
final
long
DELIVER_ENCODED_IMAGE_DELAY_MS
=
10
;
private
static
final
EncodeInfo
ENCODE_INFO_KEY_FRAME
=
new
EncodeInfo
(
new
FrameType
[
]
{
FrameType
.
VideoFrameKey
}
)
;
private
static
final
EncodeInfo
ENCODE_INFO_DELTA_FRAME
=
new
EncodeInfo
(
new
FrameType
[
]
{
FrameType
.
VideoFrameDelta
}
)
;
private
static
class
TestEncoder
extends
HardwareVideoEncoder
{
private
final
Object
deliverEncodedImageLock
=
new
Object
(
)
;
private
boolean
deliverEncodedImageDone
=
true
;
TestEncoder
(
MediaCodecWrapperFactory
mediaCodecWrapperFactory
String
codecName
VideoCodecMimeType
codecType
Integer
surfaceColorFormat
Integer
yuvColorFormat
Map
<
String
String
>
params
int
keyFrameIntervalSec
int
forceKeyFrameIntervalMs
BitrateAdjuster
bitrateAdjuster
EglBase14
.
Context
sharedContext
)
{
super
(
mediaCodecWrapperFactory
codecName
codecType
surfaceColorFormat
yuvColorFormat
params
keyFrameIntervalSec
forceKeyFrameIntervalMs
bitrateAdjuster
sharedContext
)
;
}
public
void
waitDeliverEncodedImage
(
)
throws
InterruptedException
{
synchronized
(
deliverEncodedImageLock
)
{
deliverEncodedImageDone
=
false
;
deliverEncodedImageLock
.
notifyAll
(
)
;
while
(
!
deliverEncodedImageDone
)
{
deliverEncodedImageLock
.
wait
(
)
;
}
}
}
SuppressWarnings
(
"
WaitNotInLoop
"
)
Override
protected
void
deliverEncodedImage
(
)
{
synchronized
(
deliverEncodedImageLock
)
{
if
(
deliverEncodedImageDone
)
{
try
{
deliverEncodedImageLock
.
wait
(
DELIVER_ENCODED_IMAGE_DELAY_MS
)
;
}
catch
(
InterruptedException
e
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
return
;
}
}
if
(
deliverEncodedImageDone
)
{
return
;
}
super
.
deliverEncodedImage
(
)
;
deliverEncodedImageDone
=
true
;
deliverEncodedImageLock
.
notifyAll
(
)
;
}
}
Override
protected
void
fillInputBuffer
(
ByteBuffer
buffer
Buffer
videoFrameBuffer
)
{
I420Buffer
i420Buffer
=
videoFrameBuffer
.
toI420
(
)
;
buffer
.
put
(
i420Buffer
.
getDataY
(
)
)
;
buffer
.
put
(
i420Buffer
.
getDataU
(
)
)
;
buffer
.
put
(
i420Buffer
.
getDataV
(
)
)
;
buffer
.
flip
(
)
;
i420Buffer
.
release
(
)
;
}
}
private
class
TestEncoderBuilder
{
private
VideoCodecMimeType
codecType
=
VideoCodecMimeType
.
VP8
;
private
BitrateAdjuster
bitrateAdjuster
=
new
BaseBitrateAdjuster
(
)
;
public
TestEncoderBuilder
setCodecType
(
VideoCodecMimeType
codecType
)
{
this
.
codecType
=
codecType
;
return
this
;
}
public
TestEncoderBuilder
setBitrateAdjuster
(
BitrateAdjuster
bitrateAdjuster
)
{
this
.
bitrateAdjuster
=
bitrateAdjuster
;
return
this
;
}
public
TestEncoder
build
(
)
{
return
new
TestEncoder
(
(
String
name
)
-
>
fakeMediaCodecWrapper
"
org
.
webrtc
.
testencoder
"
codecType
null
MediaCodecInfo
.
CodecCapabilities
.
COLOR_FormatYUV420Planar
new
HashMap
<
>
(
)
0
0
bitrateAdjuster
null
)
;
}
}
private
VideoFrame
createTestVideoFrame
(
long
timestampNs
)
{
byte
[
]
i420
=
CodecTestHelper
.
generateRandomData
(
TEST_ENCODER_SETTINGS
.
width
*
TEST_ENCODER_SETTINGS
.
height
*
3
/
2
)
;
final
VideoFrame
.
I420Buffer
testBuffer
=
CodecTestHelper
.
wrapI420
(
TEST_ENCODER_SETTINGS
.
width
TEST_ENCODER_SETTINGS
.
height
i420
)
;
return
new
VideoFrame
(
testBuffer
0
timestampNs
)
;
}
Mock
VideoEncoder
.
Callback
mockEncoderCallback
;
private
FakeMediaCodecWrapper
fakeMediaCodecWrapper
;
Before
public
void
setUp
(
)
{
MockitoAnnotations
.
initMocks
(
this
)
;
MediaFormat
outputFormat
=
new
MediaFormat
(
)
;
fakeMediaCodecWrapper
=
spy
(
new
FakeMediaCodecWrapper
(
outputFormat
)
)
;
}
Test
public
void
testInit
(
)
{
HardwareVideoEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
setCodecType
(
VideoCodecMimeType
.
VP8
)
.
build
(
)
;
assertThat
(
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
)
.
isEqualTo
(
VideoCodecStatus
.
OK
)
;
assertThat
(
fakeMediaCodecWrapper
.
getState
(
)
)
.
isEqualTo
(
State
.
EXECUTING_RUNNING
)
;
MediaFormat
mediaFormat
=
fakeMediaCodecWrapper
.
getConfiguredFormat
(
)
;
assertThat
(
mediaFormat
)
.
isNotNull
(
)
;
assertThat
(
mediaFormat
.
getInteger
(
MediaFormat
.
KEY_WIDTH
)
)
.
isEqualTo
(
TEST_ENCODER_SETTINGS
.
width
)
;
assertThat
(
mediaFormat
.
getInteger
(
MediaFormat
.
KEY_HEIGHT
)
)
.
isEqualTo
(
TEST_ENCODER_SETTINGS
.
height
)
;
assertThat
(
mediaFormat
.
getString
(
MediaFormat
.
KEY_MIME
)
)
.
isEqualTo
(
VideoCodecMimeType
.
VP8
.
mimeType
(
)
)
;
assertThat
(
fakeMediaCodecWrapper
.
getConfiguredFlags
(
)
)
.
isEqualTo
(
MediaCodec
.
CONFIGURE_FLAG_ENCODE
)
;
}
Test
public
void
testEncodeByteBuffer
(
)
{
HardwareVideoEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
build
(
)
;
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
;
byte
[
]
i420
=
CodecTestHelper
.
generateRandomData
(
TEST_ENCODER_SETTINGS
.
width
*
TEST_ENCODER_SETTINGS
.
height
*
3
/
2
)
;
final
VideoFrame
.
I420Buffer
testBuffer
=
CodecTestHelper
.
wrapI420
(
TEST_ENCODER_SETTINGS
.
width
TEST_ENCODER_SETTINGS
.
height
i420
)
;
final
VideoFrame
testFrame
=
new
VideoFrame
(
testBuffer
0
0
)
;
assertThat
(
encoder
.
encode
(
testFrame
new
EncodeInfo
(
new
FrameType
[
]
{
FrameType
.
VideoFrameKey
}
)
)
)
.
isEqualTo
(
VideoCodecStatus
.
OK
)
;
ArgumentCaptor
<
Integer
>
indexCaptor
=
ArgumentCaptor
.
forClass
(
Integer
.
class
)
;
ArgumentCaptor
<
Integer
>
offsetCaptor
=
ArgumentCaptor
.
forClass
(
Integer
.
class
)
;
ArgumentCaptor
<
Integer
>
sizeCaptor
=
ArgumentCaptor
.
forClass
(
Integer
.
class
)
;
verify
(
fakeMediaCodecWrapper
)
.
queueInputBuffer
(
indexCaptor
.
capture
(
)
offsetCaptor
.
capture
(
)
sizeCaptor
.
capture
(
)
anyLong
(
)
anyInt
(
)
)
;
ByteBuffer
buffer
=
fakeMediaCodecWrapper
.
getInputBuffers
(
)
[
indexCaptor
.
getValue
(
)
]
;
CodecTestHelper
.
assertEqualContents
(
i420
buffer
offsetCaptor
.
getValue
(
)
sizeCaptor
.
getValue
(
)
)
;
}
Test
public
void
testDeliversOutputData
(
)
throws
InterruptedException
{
TestEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
build
(
)
;
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
;
encoder
.
encode
(
createTestVideoFrame
(
42
)
ENCODE_INFO_KEY_FRAME
)
;
byte
[
]
outputData
=
CodecTestHelper
.
generateRandomData
(
100
)
;
fakeMediaCodecWrapper
.
addOutputData
(
outputData
0
MediaCodec
.
BUFFER_FLAG_SYNC_FRAME
)
;
encoder
.
waitDeliverEncodedImage
(
)
;
ArgumentCaptor
<
EncodedImage
>
videoFrameCaptor
=
ArgumentCaptor
.
forClass
(
EncodedImage
.
class
)
;
verify
(
mockEncoderCallback
)
.
onEncodedFrame
(
videoFrameCaptor
.
capture
(
)
any
(
CodecSpecificInfo
.
class
)
)
;
EncodedImage
videoFrame
=
videoFrameCaptor
.
getValue
(
)
;
assertThat
(
videoFrame
)
.
isNotNull
(
)
;
assertThat
(
videoFrame
.
encodedWidth
)
.
isEqualTo
(
TEST_ENCODER_SETTINGS
.
width
)
;
assertThat
(
videoFrame
.
encodedHeight
)
.
isEqualTo
(
TEST_ENCODER_SETTINGS
.
height
)
;
assertThat
(
videoFrame
.
rotation
)
.
isEqualTo
(
0
)
;
assertThat
(
videoFrame
.
captureTimeNs
)
.
isEqualTo
(
42
)
;
assertThat
(
videoFrame
.
frameType
)
.
isEqualTo
(
FrameType
.
VideoFrameKey
)
;
CodecTestHelper
.
assertEqualContents
(
outputData
videoFrame
.
buffer
0
videoFrame
.
buffer
.
capacity
(
)
)
;
}
Test
public
void
testRelease
(
)
{
HardwareVideoEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
build
(
)
;
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
;
assertThat
(
encoder
.
release
(
)
)
.
isEqualTo
(
VideoCodecStatus
.
OK
)
;
assertThat
(
fakeMediaCodecWrapper
.
getState
(
)
)
.
isEqualTo
(
State
.
RELEASED
)
;
}
Test
public
void
testReleaseMultipleTimes
(
)
{
HardwareVideoEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
build
(
)
;
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
;
assertThat
(
encoder
.
release
(
)
)
.
isEqualTo
(
VideoCodecStatus
.
OK
)
;
assertThat
(
encoder
.
release
(
)
)
.
isEqualTo
(
VideoCodecStatus
.
OK
)
;
assertThat
(
fakeMediaCodecWrapper
.
getState
(
)
)
.
isEqualTo
(
State
.
RELEASED
)
;
}
Test
public
void
testFramerateWithFramerateBitrateAdjuster
(
)
{
HardwareVideoEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
setBitrateAdjuster
(
new
FramerateBitrateAdjuster
(
)
)
.
build
(
)
;
encoder
.
initEncode
(
new
Settings
(
1
640
480
10000
15
1
true
new
VideoEncoder
.
Capabilities
(
false
)
)
mockEncoderCallback
)
;
MediaFormat
mediaFormat
=
fakeMediaCodecWrapper
.
getConfiguredFormat
(
)
;
assertThat
(
mediaFormat
.
getInteger
(
MediaFormat
.
KEY_FRAME_RATE
)
)
.
isEqualTo
(
30
)
;
}
Test
public
void
testBitrateWithFramerateBitrateAdjuster
(
)
throws
InterruptedException
{
TestEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
setBitrateAdjuster
(
new
FramerateBitrateAdjuster
(
)
)
.
build
(
)
;
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
;
encoder
.
encode
(
createTestVideoFrame
(
0
)
ENCODE_INFO_KEY_FRAME
)
;
BitrateAllocation
bitrateAllocation
=
new
BitrateAllocation
(
new
int
[
]
[
]
{
new
int
[
]
{
TEST_ENCODER_SETTINGS
.
startBitrate
}
}
)
;
encoder
.
setRateAllocation
(
bitrateAllocation
TEST_ENCODER_SETTINGS
.
maxFramerate
/
2
)
;
fakeMediaCodecWrapper
.
addOutputData
(
CodecTestHelper
.
generateRandomData
(
100
)
0
0
)
;
encoder
.
waitDeliverEncodedImage
(
)
;
ArgumentCaptor
<
Bundle
>
bundleCaptor
=
ArgumentCaptor
.
forClass
(
Bundle
.
class
)
;
verify
(
fakeMediaCodecWrapper
times
(
2
)
)
.
setParameters
(
bundleCaptor
.
capture
(
)
)
;
Bundle
params
=
bundleCaptor
.
getAllValues
(
)
.
get
(
1
)
;
assertThat
(
params
.
containsKey
(
MediaCodec
.
PARAMETER_KEY_VIDEO_BITRATE
)
)
.
isTrue
(
)
;
assertThat
(
params
.
getInt
(
MediaCodec
.
PARAMETER_KEY_VIDEO_BITRATE
)
)
.
isEqualTo
(
TEST_ENCODER_SETTINGS
.
startBitrate
*
2
)
;
}
Test
public
void
testTimestampsWithFramerateBitrateAdjuster
(
)
throws
InterruptedException
{
TestEncoder
encoder
=
new
TestEncoderBuilder
(
)
.
setBitrateAdjuster
(
new
FramerateBitrateAdjuster
(
)
)
.
build
(
)
;
encoder
.
initEncode
(
TEST_ENCODER_SETTINGS
mockEncoderCallback
)
;
encoder
.
encode
(
createTestVideoFrame
(
0
)
ENCODE_INFO_KEY_FRAME
)
;
BitrateAllocation
bitrateAllocation
=
new
BitrateAllocation
(
new
int
[
]
[
]
{
new
int
[
]
{
TEST_ENCODER_SETTINGS
.
startBitrate
}
}
)
;
encoder
.
setRateAllocation
(
bitrateAllocation
TEST_ENCODER_SETTINGS
.
maxFramerate
/
2
)
;
fakeMediaCodecWrapper
.
addOutputData
(
CodecTestHelper
.
generateRandomData
(
100
)
0
0
)
;
encoder
.
waitDeliverEncodedImage
(
)
;
encoder
.
encode
(
createTestVideoFrame
(
1
)
ENCODE_INFO_DELTA_FRAME
)
;
encoder
.
encode
(
createTestVideoFrame
(
2
)
ENCODE_INFO_DELTA_FRAME
)
;
ArgumentCaptor
<
Long
>
timestampCaptor
=
ArgumentCaptor
.
forClass
(
Long
.
class
)
;
verify
(
fakeMediaCodecWrapper
times
(
3
)
)
.
queueInputBuffer
(
anyInt
(
)
anyInt
(
)
anyInt
(
)
timestampCaptor
.
capture
(
)
anyInt
(
)
)
;
long
frameDurationMs
=
SECONDS
.
toMicros
(
1
)
/
30
;
assertThat
(
timestampCaptor
.
getAllValues
(
)
)
.
containsExactly
(
0L
frameDurationMs
2
*
frameDurationMs
)
;
}
}
