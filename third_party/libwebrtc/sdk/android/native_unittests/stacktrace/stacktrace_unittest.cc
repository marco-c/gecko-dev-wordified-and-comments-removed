#
include
"
sdk
/
android
/
native_api
/
stacktrace
/
stacktrace
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
string_utils
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
rtc_base
/
system
/
inline
.
h
"
#
include
"
system_wrappers
/
include
/
sleep
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
test
{
namespace
{
class
SimpleSpinEvent
{
public
:
SimpleSpinEvent
(
)
{
static_cast
<
void
>
(
blocked_
.
test_and_set
(
std
:
:
memory_order_seq_cst
)
)
;
}
void
Wait
(
)
{
bool
was_blocked
;
do
{
was_blocked
=
blocked_
.
test_and_set
(
std
:
:
memory_order_seq_cst
)
;
}
while
(
was_blocked
)
;
}
void
Set
(
)
{
blocked_
.
clear
(
std
:
:
memory_order_seq_cst
)
;
}
private
:
std
:
:
atomic_flag
blocked_
;
}
;
RTC_NO_INLINE
uint32_t
GetCurrentRelativeExecutionAddress
(
)
{
void
*
pc
=
__builtin_return_address
(
0
)
;
Dl_info
dl_info
=
{
}
;
const
bool
success
=
dladdr
(
pc
&
dl_info
)
;
EXPECT_TRUE
(
success
)
;
return
static_cast
<
uint32_t
>
(
reinterpret_cast
<
uintptr_t
>
(
pc
)
-
reinterpret_cast
<
uintptr_t
>
(
dl_info
.
dli_fbase
)
)
;
}
bool
StackTraceContainsRange
(
const
std
:
:
vector
<
StackTraceElement
>
&
stack_trace
uintptr_t
pc_low
uintptr_t
pc_high
)
{
for
(
const
StackTraceElement
&
stack_trace_element
:
stack_trace
)
{
if
(
pc_low
<
=
stack_trace_element
.
relative_address
&
&
pc_high
>
=
stack_trace_element
.
relative_address
)
{
return
true
;
}
}
return
false
;
}
class
DeadlockInterface
{
public
:
virtual
~
DeadlockInterface
(
)
{
}
virtual
void
Deadlock
(
)
=
0
;
virtual
void
Release
(
)
=
0
;
}
;
struct
ThreadParams
{
volatile
int
tid
;
SimpleSpinEvent
deadlock_start_event
;
DeadlockInterface
*
volatile
deadlock_impl
;
volatile
uint32_t
deadlock_region_start_address
;
volatile
uint32_t
deadlock_region_end_address
;
rtc
:
:
Event
deadlock_done_event
;
}
;
class
RtcEventDeadlock
:
public
DeadlockInterface
{
private
:
void
Deadlock
(
)
override
{
event
.
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
}
void
Release
(
)
override
{
event
.
Set
(
)
;
}
rtc
:
:
Event
event
;
}
;
class
RtcCriticalSectionDeadlock
:
public
DeadlockInterface
{
public
:
RtcCriticalSectionDeadlock
(
)
:
mutex_lock_
(
std
:
:
make_unique
<
MutexLock
>
(
&
mutex_
)
)
{
}
private
:
void
Deadlock
(
)
override
{
MutexLock
lock
(
&
mutex_
)
;
}
void
Release
(
)
override
{
mutex_lock_
.
reset
(
)
;
}
Mutex
mutex_
;
std
:
:
unique_ptr
<
MutexLock
>
mutex_lock_
;
}
;
class
SpinDeadlock
:
public
DeadlockInterface
{
public
:
SpinDeadlock
(
)
:
is_deadlocked_
(
true
)
{
}
private
:
void
Deadlock
(
)
override
{
while
(
is_deadlocked_
)
{
}
}
void
Release
(
)
override
{
is_deadlocked_
=
false
;
}
std
:
:
atomic
<
bool
>
is_deadlocked_
;
}
;
class
SleepDeadlock
:
public
DeadlockInterface
{
private
:
void
Deadlock
(
)
override
{
sleep
(
1000000
)
;
}
void
Release
(
)
override
{
}
}
;
void
TestStacktrace
(
std
:
:
unique_ptr
<
DeadlockInterface
>
deadlock_impl
)
{
ThreadParams
params
;
params
.
deadlock_impl
=
deadlock_impl
.
get
(
)
;
auto
thread
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
&
params
]
{
params
.
tid
=
gettid
(
)
;
params
.
deadlock_region_start_address
=
GetCurrentRelativeExecutionAddress
(
)
;
params
.
deadlock_start_event
.
Set
(
)
;
params
.
deadlock_impl
-
>
Deadlock
(
)
;
params
.
deadlock_region_end_address
=
GetCurrentRelativeExecutionAddress
(
)
;
params
.
deadlock_done_event
.
Set
(
)
;
}
"
StacktraceTest
"
)
;
params
.
deadlock_start_event
.
Wait
(
)
;
SleepMs
(
1
)
;
std
:
:
vector
<
StackTraceElement
>
stack_trace
=
GetStackTrace
(
params
.
tid
)
;
deadlock_impl
-
>
Release
(
)
;
params
.
deadlock_done_event
.
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
EXPECT_TRUE
(
StackTraceContainsRange
(
stack_trace
params
.
deadlock_region_start_address
params
.
deadlock_region_end_address
)
)
<
<
"
Deadlock
region
:
[
"
<
<
rtc
:
:
ToHex
(
params
.
deadlock_region_start_address
)
<
<
"
"
<
<
rtc
:
:
ToHex
(
params
.
deadlock_region_end_address
)
<
<
"
]
not
contained
in
:
"
<
<
StackTraceToString
(
stack_trace
)
;
}
class
LookoutLogSink
final
:
public
rtc
:
:
LogSink
{
public
:
explicit
LookoutLogSink
(
std
:
:
string
look_for
)
:
look_for_
(
std
:
:
move
(
look_for
)
)
{
}
void
OnLogMessage
(
const
std
:
:
string
&
message
)
override
{
OnLogMessage
(
absl
:
:
string_view
(
message
)
)
;
}
void
OnLogMessage
(
absl
:
:
string_view
message
)
override
{
if
(
message
.
find
(
look_for_
)
!
=
std
:
:
string
:
:
npos
)
{
when_found_
.
Set
(
)
;
}
}
rtc
:
:
Event
&
WhenFound
(
)
{
return
when_found_
;
}
private
:
const
std
:
:
string
look_for_
;
rtc
:
:
Event
when_found_
;
}
;
}
TEST
(
Stacktrace
TestCurrentThread
)
{
const
uint32_t
start_addr
=
GetCurrentRelativeExecutionAddress
(
)
;
const
std
:
:
vector
<
StackTraceElement
>
stack_trace
=
GetStackTrace
(
)
;
const
uint32_t
end_addr
=
GetCurrentRelativeExecutionAddress
(
)
;
EXPECT_TRUE
(
StackTraceContainsRange
(
stack_trace
start_addr
end_addr
)
)
<
<
"
Caller
region
:
[
"
<
<
rtc
:
:
ToHex
(
start_addr
)
<
<
"
"
<
<
rtc
:
:
ToHex
(
end_addr
)
<
<
"
]
not
contained
in
:
"
<
<
StackTraceToString
(
stack_trace
)
;
}
TEST
(
Stacktrace
TestSpinLock
)
{
TestStacktrace
(
std
:
:
make_unique
<
SpinDeadlock
>
(
)
)
;
}
TEST
(
Stacktrace
TestSleep
)
{
TestStacktrace
(
std
:
:
make_unique
<
SleepDeadlock
>
(
)
)
;
}
#
ifdef
WEBRTC_ARCH_ARM64
TEST
(
Stacktrace
TestRtcEvent
)
{
TestStacktrace
(
std
:
:
make_unique
<
RtcEventDeadlock
>
(
)
)
;
}
TEST
(
Stacktrace
TestRtcCriticalSection
)
{
TestStacktrace
(
std
:
:
make_unique
<
RtcCriticalSectionDeadlock
>
(
)
)
;
}
#
endif
TEST
(
Stacktrace
TestRtcEventDeadlockDetection
)
{
LookoutLogSink
sink
(
"
Probable
deadlock
"
)
;
rtc
:
:
LogMessage
:
:
AddLogToStream
(
&
sink
rtc
:
:
LS_WARNING
)
;
rtc
:
:
Event
ev
;
auto
thread
=
rtc
:
:
PlatformThread
:
:
SpawnJoinable
(
[
&
ev
]
{
ev
.
Wait
(
rtc
:
:
Event
:
:
kForever
)
;
}
"
TestRtcEventDeadlockDetection
"
)
;
EXPECT_TRUE
(
sink
.
WhenFound
(
)
.
Wait
(
10000
)
)
;
ev
.
Set
(
)
;
thread
.
Finalize
(
)
;
rtc
:
:
LogMessage
:
:
RemoveLogToStream
(
&
sink
)
;
}
}
}
