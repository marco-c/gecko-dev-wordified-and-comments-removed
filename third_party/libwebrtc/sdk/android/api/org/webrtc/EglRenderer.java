package
org
.
webrtc
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
Matrix
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
opengl
.
GLES20
;
import
android
.
view
.
Surface
;
import
androidx
.
annotation
.
GuardedBy
;
import
androidx
.
annotation
.
Nullable
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
text
.
DecimalFormat
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Optional
;
import
java
.
util
.
UUID
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
class
EglRenderer
implements
VideoSink
{
private
static
final
String
TAG
=
"
EglRenderer
"
;
private
static
final
long
LOG_INTERVAL_SEC
=
4
;
public
interface
FrameListener
{
void
onFrame
(
Bitmap
frame
)
;
}
public
interface
RenderListener
{
void
onRender
(
long
timestampNs
)
;
}
public
static
interface
ErrorCallback
{
void
onGlOutOfMemory
(
)
;
}
private
static
class
FrameListenerAndParams
{
public
final
FrameListener
listener
;
public
final
float
scale
;
public
final
RendererCommon
.
GlDrawer
drawer
;
public
final
boolean
applyFpsReduction
;
public
FrameListenerAndParams
(
FrameListener
listener
float
scale
RendererCommon
.
GlDrawer
drawer
boolean
applyFpsReduction
)
{
this
.
listener
=
listener
;
this
.
scale
=
scale
;
this
.
drawer
=
drawer
;
this
.
applyFpsReduction
=
applyFpsReduction
;
}
}
private
class
EglSurfaceCreation
implements
Runnable
{
private
Object
surface
;
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
void
setSurface
(
Object
surface
)
{
this
.
surface
=
surface
;
}
Override
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
void
run
(
)
{
if
(
surface
!
=
null
&
&
eglBase
!
=
null
&
&
!
eglBase
.
hasSurface
(
)
)
{
if
(
surface
instanceof
Surface
)
{
eglBase
.
createSurface
(
(
Surface
)
surface
)
;
}
else
if
(
surface
instanceof
SurfaceTexture
)
{
eglBase
.
createSurface
(
(
SurfaceTexture
)
surface
)
;
}
else
{
throw
new
IllegalStateException
(
"
Invalid
surface
:
"
+
surface
)
;
}
eglBase
.
makeCurrent
(
)
;
GLES20
.
glPixelStorei
(
GLES20
.
GL_UNPACK_ALIGNMENT
1
)
;
}
}
}
protected
final
String
name
;
private
Optional
<
UUID
>
id
=
Optional
.
empty
(
)
;
private
final
Object
threadLock
=
new
Object
(
)
;
GuardedBy
(
"
threadLock
"
)
Nullable
private
EglThread
eglThread
;
private
final
Runnable
eglExceptionCallback
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
synchronized
(
threadLock
)
{
eglThread
=
null
;
}
}
}
;
private
final
ArrayList
<
FrameListenerAndParams
>
frameListeners
=
new
ArrayList
<
>
(
)
;
private
final
ArrayList
<
RenderListener
>
renderListeners
=
new
ArrayList
<
>
(
)
;
private
volatile
ErrorCallback
errorCallback
;
private
final
Object
fpsReductionLock
=
new
Object
(
)
;
private
long
nextFrameTimeNs
;
private
long
minRenderPeriodNs
;
Nullable
private
EglBase
eglBase
;
private
final
VideoFrameDrawer
frameDrawer
;
Nullable
private
RendererCommon
.
GlDrawer
drawer
;
private
boolean
usePresentationTimeStamp
;
private
final
Matrix
drawMatrix
=
new
Matrix
(
)
;
private
final
Object
frameLock
=
new
Object
(
)
;
Nullable
private
VideoFrame
pendingFrame
;
private
final
Object
layoutLock
=
new
Object
(
)
;
private
float
layoutAspectRatio
;
private
boolean
mirrorHorizontally
;
private
boolean
mirrorVertically
;
private
final
Object
statisticsLock
=
new
Object
(
)
;
private
int
framesReceived
;
private
int
framesDropped
;
private
int
framesRendered
;
private
long
statisticsStartTimeNs
;
private
long
renderTimeNs
;
private
long
renderSwapBufferTimeNs
;
private
final
GlTextureFrameBuffer
bitmapTextureFramebuffer
=
new
GlTextureFrameBuffer
(
GLES20
.
GL_RGBA
)
;
private
final
Runnable
logStatisticsRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
logStatistics
(
)
;
synchronized
(
threadLock
)
{
if
(
eglThread
!
=
null
)
{
eglThread
.
getHandler
(
)
.
removeCallbacks
(
logStatisticsRunnable
)
;
eglThread
.
getHandler
(
)
.
postDelayed
(
logStatisticsRunnable
TimeUnit
.
SECONDS
.
toMillis
(
LOG_INTERVAL_SEC
)
)
;
}
}
}
}
;
private
final
EglSurfaceCreation
eglSurfaceCreationRunnable
=
new
EglSurfaceCreation
(
)
;
public
EglRenderer
(
String
name
)
{
this
(
name
new
VideoFrameDrawer
(
)
)
;
}
public
EglRenderer
(
String
name
VideoFrameDrawer
videoFrameDrawer
)
{
this
.
name
=
name
;
this
.
frameDrawer
=
videoFrameDrawer
;
}
public
void
init
(
EglThread
eglThread
RendererCommon
.
GlDrawer
drawer
boolean
usePresentationTimeStamp
)
{
synchronized
(
threadLock
)
{
if
(
this
.
eglThread
!
=
null
)
{
throw
new
IllegalStateException
(
name
+
"
Already
initialized
"
)
;
}
logD
(
"
Initializing
EglRenderer
"
)
;
this
.
eglThread
=
eglThread
;
this
.
drawer
=
drawer
;
this
.
usePresentationTimeStamp
=
usePresentationTimeStamp
;
eglThread
.
addExceptionCallback
(
eglExceptionCallback
)
;
eglBase
=
eglThread
.
createEglBaseWithSharedConnection
(
)
;
eglThread
.
getHandler
(
)
.
post
(
eglSurfaceCreationRunnable
)
;
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
resetStatistics
(
currentTimeNs
)
;
eglThread
.
getHandler
(
)
.
postDelayed
(
logStatisticsRunnable
TimeUnit
.
SECONDS
.
toMillis
(
LOG_INTERVAL_SEC
)
)
;
}
}
public
void
init
(
EglThread
eglThread
RendererCommon
.
GlDrawer
drawer
boolean
usePresentationTimeStamp
boolean
overwritePendingFrames
)
{
if
(
overwritePendingFrames
)
{
id
=
Optional
.
of
(
UUID
.
randomUUID
(
)
)
;
}
init
(
eglThread
drawer
usePresentationTimeStamp
)
;
}
public
void
init
(
Nullable
final
EglBase
.
Context
sharedContext
final
int
[
]
configAttributes
RendererCommon
.
GlDrawer
drawer
boolean
usePresentationTimeStamp
)
{
EglThread
thread
=
EglThread
.
create
(
null
sharedContext
configAttributes
)
;
init
(
thread
drawer
usePresentationTimeStamp
)
;
}
public
void
init
(
Nullable
final
EglBase
.
Context
sharedContext
final
int
[
]
configAttributes
RendererCommon
.
GlDrawer
drawer
)
{
init
(
sharedContext
configAttributes
drawer
false
)
;
}
public
void
createEglSurface
(
Surface
surface
)
{
createEglSurfaceInternal
(
surface
)
;
}
public
void
createEglSurface
(
SurfaceTexture
surfaceTexture
)
{
createEglSurfaceInternal
(
surfaceTexture
)
;
}
private
void
createEglSurfaceInternal
(
Object
surface
)
{
eglSurfaceCreationRunnable
.
setSurface
(
surface
)
;
postToRenderThread
(
eglSurfaceCreationRunnable
)
;
}
public
void
release
(
)
{
logD
(
"
Releasing
.
"
)
;
final
CountDownLatch
eglCleanupBarrier
=
new
CountDownLatch
(
1
)
;
synchronized
(
threadLock
)
{
if
(
eglThread
=
=
null
)
{
logD
(
"
Already
released
"
)
;
return
;
}
eglThread
.
getHandler
(
)
.
removeCallbacks
(
logStatisticsRunnable
)
;
eglThread
.
removeExceptionCallback
(
eglExceptionCallback
)
;
eglThread
.
getHandler
(
)
.
postAtFrontOfQueue
(
(
)
-
>
{
synchronized
(
EglBase
.
lock
)
{
GLES20
.
glUseProgram
(
0
)
;
}
if
(
drawer
!
=
null
)
{
drawer
.
release
(
)
;
drawer
=
null
;
}
frameDrawer
.
release
(
)
;
bitmapTextureFramebuffer
.
release
(
)
;
if
(
eglBase
!
=
null
)
{
logD
(
"
eglBase
detach
and
release
.
"
)
;
eglBase
.
detachCurrent
(
)
;
eglBase
.
release
(
)
;
eglBase
=
null
;
}
renderListeners
.
clear
(
)
;
frameListeners
.
clear
(
)
;
eglCleanupBarrier
.
countDown
(
)
;
}
)
;
eglThread
.
release
(
)
;
eglThread
=
null
;
}
ThreadUtils
.
awaitUninterruptibly
(
eglCleanupBarrier
)
;
synchronized
(
frameLock
)
{
if
(
pendingFrame
!
=
null
)
{
pendingFrame
.
release
(
)
;
pendingFrame
=
null
;
}
}
logD
(
"
Releasing
done
.
"
)
;
}
private
void
resetStatistics
(
long
currentTimeNs
)
{
synchronized
(
statisticsLock
)
{
statisticsStartTimeNs
=
currentTimeNs
;
framesReceived
=
0
;
framesDropped
=
0
;
framesRendered
=
0
;
renderTimeNs
=
0
;
renderSwapBufferTimeNs
=
0
;
}
}
public
void
printStackTrace
(
)
{
synchronized
(
threadLock
)
{
final
Thread
renderThread
=
(
eglThread
=
=
null
)
?
null
:
eglThread
.
getHandler
(
)
.
getLooper
(
)
.
getThread
(
)
;
if
(
renderThread
!
=
null
)
{
final
StackTraceElement
[
]
renderStackTrace
=
renderThread
.
getStackTrace
(
)
;
if
(
renderStackTrace
.
length
>
0
)
{
logW
(
"
EglRenderer
stack
trace
:
"
)
;
for
(
StackTraceElement
traceElem
:
renderStackTrace
)
{
logW
(
traceElem
.
toString
(
)
)
;
}
}
}
}
}
public
void
setMirror
(
final
boolean
mirror
)
{
synchronized
(
layoutLock
)
{
this
.
mirrorHorizontally
=
mirror
;
}
}
public
void
setMirrorVertically
(
final
boolean
mirrorVertically
)
{
synchronized
(
layoutLock
)
{
this
.
mirrorVertically
=
mirrorVertically
;
}
}
public
void
setLayoutAspectRatio
(
float
layoutAspectRatio
)
{
synchronized
(
layoutLock
)
{
this
.
layoutAspectRatio
=
layoutAspectRatio
;
}
}
public
void
setFpsReduction
(
float
fps
)
{
synchronized
(
fpsReductionLock
)
{
final
long
previousRenderPeriodNs
=
minRenderPeriodNs
;
if
(
fps
<
=
0
)
{
minRenderPeriodNs
=
Long
.
MAX_VALUE
;
}
else
{
minRenderPeriodNs
=
(
long
)
(
TimeUnit
.
SECONDS
.
toNanos
(
1
)
/
fps
)
;
}
if
(
minRenderPeriodNs
!
=
previousRenderPeriodNs
)
{
nextFrameTimeNs
=
System
.
nanoTime
(
)
;
}
}
}
public
void
disableFpsReduction
(
)
{
setFpsReduction
(
Float
.
POSITIVE_INFINITY
)
;
}
public
void
pauseVideo
(
)
{
setFpsReduction
(
0
)
;
}
public
void
addFrameListener
(
final
FrameListener
listener
final
float
scale
)
{
addFrameListener
(
listener
scale
null
false
)
;
}
public
void
addFrameListener
(
final
FrameListener
listener
final
float
scale
final
RendererCommon
.
GlDrawer
drawerParam
)
{
addFrameListener
(
listener
scale
drawerParam
false
)
;
}
public
void
addFrameListener
(
final
FrameListener
listener
final
float
scale
Nullable
final
RendererCommon
.
GlDrawer
drawerParam
final
boolean
applyFpsReduction
)
{
postToRenderThread
(
(
)
-
>
{
final
RendererCommon
.
GlDrawer
listenerDrawer
=
drawerParam
=
=
null
?
drawer
:
drawerParam
;
frameListeners
.
add
(
new
FrameListenerAndParams
(
listener
scale
listenerDrawer
applyFpsReduction
)
)
;
}
)
;
}
public
void
addRenderListener
(
final
RenderListener
listener
)
{
renderListeners
.
add
(
listener
)
;
}
public
void
removeFrameListener
(
final
FrameListener
listener
)
{
final
CountDownLatch
latch
=
new
CountDownLatch
(
1
)
;
synchronized
(
threadLock
)
{
if
(
eglThread
=
=
null
)
{
return
;
}
if
(
Thread
.
currentThread
(
)
=
=
eglThread
.
getHandler
(
)
.
getLooper
(
)
.
getThread
(
)
)
{
throw
new
RuntimeException
(
"
removeFrameListener
must
not
be
called
on
the
render
thread
.
"
)
;
}
postToRenderThread
(
(
)
-
>
{
latch
.
countDown
(
)
;
final
Iterator
<
FrameListenerAndParams
>
iter
=
frameListeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
if
(
iter
.
next
(
)
.
listener
=
=
listener
)
{
iter
.
remove
(
)
;
}
}
}
)
;
}
ThreadUtils
.
awaitUninterruptibly
(
latch
)
;
}
public
void
removeRenderListener
(
final
RenderListener
listener
)
{
final
CountDownLatch
latch
=
new
CountDownLatch
(
1
)
;
synchronized
(
threadLock
)
{
if
(
eglThread
=
=
null
)
{
return
;
}
if
(
Thread
.
currentThread
(
)
=
=
eglThread
.
getHandler
(
)
.
getLooper
(
)
.
getThread
(
)
)
{
throw
new
RuntimeException
(
"
removeRenderListener
must
not
be
called
on
the
render
thread
.
"
)
;
}
postToRenderThread
(
(
)
-
>
{
latch
.
countDown
(
)
;
final
Iterator
<
RenderListener
>
iter
=
renderListeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
if
(
iter
.
next
(
)
=
=
listener
)
{
iter
.
remove
(
)
;
}
}
}
)
;
}
ThreadUtils
.
awaitUninterruptibly
(
latch
)
;
}
public
void
setErrorCallback
(
ErrorCallback
errorCallback
)
{
this
.
errorCallback
=
errorCallback
;
}
Override
public
void
onFrame
(
VideoFrame
frame
)
{
synchronized
(
statisticsLock
)
{
+
+
framesReceived
;
}
final
boolean
dropOldFrame
;
synchronized
(
threadLock
)
{
if
(
eglThread
=
=
null
)
{
logD
(
"
Dropping
frame
-
Not
initialized
or
already
released
.
"
)
;
return
;
}
synchronized
(
frameLock
)
{
dropOldFrame
=
(
pendingFrame
!
=
null
)
;
if
(
dropOldFrame
)
{
pendingFrame
.
release
(
)
;
}
pendingFrame
=
frame
;
pendingFrame
.
retain
(
)
;
eglThread
.
getHandler
(
)
.
post
(
this
:
:
renderFrameOnRenderThread
)
;
}
}
if
(
dropOldFrame
)
{
synchronized
(
statisticsLock
)
{
+
+
framesDropped
;
}
}
}
public
void
releaseEglSurface
(
final
Runnable
completionCallback
)
{
eglSurfaceCreationRunnable
.
setSurface
(
null
)
;
synchronized
(
threadLock
)
{
if
(
eglThread
!
=
null
)
{
eglThread
.
getHandler
(
)
.
removeCallbacks
(
eglSurfaceCreationRunnable
)
;
eglThread
.
getHandler
(
)
.
postAtFrontOfQueue
(
(
)
-
>
{
if
(
eglBase
!
=
null
)
{
eglBase
.
detachCurrent
(
)
;
eglBase
.
releaseSurface
(
)
;
}
completionCallback
.
run
(
)
;
}
)
;
return
;
}
}
completionCallback
.
run
(
)
;
}
private
void
postToRenderThread
(
Runnable
runnable
)
{
synchronized
(
threadLock
)
{
if
(
eglThread
!
=
null
)
{
eglThread
.
getHandler
(
)
.
post
(
runnable
)
;
}
}
}
private
void
clearSurfaceOnRenderThread
(
float
r
float
g
float
b
float
a
)
{
if
(
eglBase
!
=
null
&
&
eglBase
.
hasSurface
(
)
)
{
logD
(
"
clearSurface
"
)
;
eglBase
.
makeCurrent
(
)
;
GLES20
.
glClearColor
(
r
g
b
a
)
;
GLES20
.
glClear
(
GLES20
.
GL_COLOR_BUFFER_BIT
)
;
eglBase
.
swapBuffers
(
)
;
}
}
public
void
clearImage
(
)
{
clearImage
(
0
0
0
0
)
;
}
public
void
clearImage
(
final
float
r
final
float
g
final
float
b
final
float
a
)
{
synchronized
(
threadLock
)
{
if
(
eglThread
=
=
null
)
{
return
;
}
eglThread
.
getHandler
(
)
.
postAtFrontOfQueue
(
(
)
-
>
clearSurfaceOnRenderThread
(
r
g
b
a
)
)
;
}
}
private
void
swapBuffersOnRenderThread
(
final
VideoFrame
frame
long
swapBuffersStartTimeNs
)
{
synchronized
(
threadLock
)
{
if
(
eglThread
=
=
null
)
{
return
;
}
EglThread
.
RenderUpdate
renderUpdate
=
runsInline
-
>
{
if
(
!
runsInline
)
{
if
(
eglBase
=
=
null
|
|
!
eglBase
.
hasSurface
(
)
)
{
return
;
}
eglBase
.
makeCurrent
(
)
;
}
if
(
usePresentationTimeStamp
)
{
eglBase
.
swapBuffers
(
frame
.
getTimestampNs
(
)
)
;
}
else
{
eglBase
.
swapBuffers
(
)
;
}
for
(
var
listener
:
renderListeners
)
{
listener
.
onRender
(
System
.
nanoTime
(
)
)
;
}
synchronized
(
statisticsLock
)
{
renderSwapBufferTimeNs
+
=
(
System
.
nanoTime
(
)
-
swapBuffersStartTimeNs
)
;
}
}
;
if
(
id
.
isPresent
(
)
)
{
eglThread
.
scheduleRenderUpdate
(
id
.
get
(
)
renderUpdate
)
;
}
else
{
eglThread
.
scheduleRenderUpdate
(
renderUpdate
)
;
}
}
}
private
void
renderFrameOnRenderThread
(
)
{
final
VideoFrame
frame
;
synchronized
(
frameLock
)
{
if
(
pendingFrame
=
=
null
)
{
return
;
}
frame
=
pendingFrame
;
pendingFrame
=
null
;
}
if
(
eglBase
=
=
null
|
|
!
eglBase
.
hasSurface
(
)
)
{
logD
(
"
Dropping
frame
-
No
surface
"
)
;
frame
.
release
(
)
;
return
;
}
eglBase
.
makeCurrent
(
)
;
final
boolean
shouldRenderFrame
;
synchronized
(
fpsReductionLock
)
{
if
(
minRenderPeriodNs
=
=
Long
.
MAX_VALUE
)
{
shouldRenderFrame
=
false
;
}
else
if
(
minRenderPeriodNs
<
=
0
)
{
shouldRenderFrame
=
true
;
}
else
{
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
if
(
currentTimeNs
<
nextFrameTimeNs
)
{
logD
(
"
Skipping
frame
rendering
-
fps
reduction
is
active
.
"
)
;
shouldRenderFrame
=
false
;
}
else
{
nextFrameTimeNs
+
=
minRenderPeriodNs
;
nextFrameTimeNs
=
Math
.
max
(
nextFrameTimeNs
currentTimeNs
)
;
shouldRenderFrame
=
true
;
}
}
}
final
long
startTimeNs
=
System
.
nanoTime
(
)
;
final
float
frameAspectRatio
=
frame
.
getRotatedWidth
(
)
/
(
float
)
frame
.
getRotatedHeight
(
)
;
final
float
drawnAspectRatio
;
synchronized
(
layoutLock
)
{
drawnAspectRatio
=
layoutAspectRatio
!
=
0f
?
layoutAspectRatio
:
frameAspectRatio
;
}
final
float
scaleX
;
final
float
scaleY
;
if
(
frameAspectRatio
>
drawnAspectRatio
)
{
scaleX
=
drawnAspectRatio
/
frameAspectRatio
;
scaleY
=
1f
;
}
else
{
scaleX
=
1f
;
scaleY
=
frameAspectRatio
/
drawnAspectRatio
;
}
drawMatrix
.
reset
(
)
;
drawMatrix
.
preTranslate
(
0
.
5f
0
.
5f
)
;
drawMatrix
.
preScale
(
mirrorHorizontally
?
-
1f
:
1f
mirrorVertically
?
-
1f
:
1f
)
;
drawMatrix
.
preScale
(
scaleX
scaleY
)
;
drawMatrix
.
preTranslate
(
-
0
.
5f
-
0
.
5f
)
;
try
{
if
(
shouldRenderFrame
)
{
GLES20
.
glClearColor
(
0
0
0
0
)
;
GLES20
.
glClear
(
GLES20
.
GL_COLOR_BUFFER_BIT
)
;
frameDrawer
.
drawFrame
(
frame
drawer
drawMatrix
0
0
eglBase
.
surfaceWidth
(
)
eglBase
.
surfaceHeight
(
)
)
;
final
long
swapBuffersStartTimeNs
=
System
.
nanoTime
(
)
;
swapBuffersOnRenderThread
(
frame
swapBuffersStartTimeNs
)
;
synchronized
(
statisticsLock
)
{
+
+
framesRendered
;
renderTimeNs
+
=
(
swapBuffersStartTimeNs
-
startTimeNs
)
;
}
}
notifyCallbacks
(
frame
shouldRenderFrame
)
;
}
catch
(
GlUtil
.
GlOutOfMemoryException
e
)
{
logE
(
"
Error
while
drawing
frame
"
e
)
;
final
ErrorCallback
errorCallback
=
this
.
errorCallback
;
if
(
errorCallback
!
=
null
)
{
errorCallback
.
onGlOutOfMemory
(
)
;
}
drawer
.
release
(
)
;
frameDrawer
.
release
(
)
;
bitmapTextureFramebuffer
.
release
(
)
;
}
finally
{
frame
.
release
(
)
;
}
}
private
void
notifyCallbacks
(
VideoFrame
frame
boolean
wasRendered
)
{
if
(
frameListeners
.
isEmpty
(
)
)
return
;
drawMatrix
.
reset
(
)
;
drawMatrix
.
preTranslate
(
0
.
5f
0
.
5f
)
;
drawMatrix
.
preScale
(
mirrorHorizontally
?
-
1f
:
1f
mirrorVertically
?
-
1f
:
1f
)
;
drawMatrix
.
preScale
(
1f
-
1f
)
;
drawMatrix
.
preTranslate
(
-
0
.
5f
-
0
.
5f
)
;
Iterator
<
FrameListenerAndParams
>
it
=
frameListeners
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
FrameListenerAndParams
listenerAndParams
=
it
.
next
(
)
;
if
(
!
wasRendered
&
&
listenerAndParams
.
applyFpsReduction
)
{
continue
;
}
it
.
remove
(
)
;
final
int
scaledWidth
=
(
int
)
(
listenerAndParams
.
scale
*
frame
.
getRotatedWidth
(
)
)
;
final
int
scaledHeight
=
(
int
)
(
listenerAndParams
.
scale
*
frame
.
getRotatedHeight
(
)
)
;
if
(
scaledWidth
=
=
0
|
|
scaledHeight
=
=
0
)
{
listenerAndParams
.
listener
.
onFrame
(
null
)
;
continue
;
}
bitmapTextureFramebuffer
.
setSize
(
scaledWidth
scaledHeight
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
bitmapTextureFramebuffer
.
getFrameBufferId
(
)
)
;
GLES20
.
glFramebufferTexture2D
(
GLES20
.
GL_FRAMEBUFFER
GLES20
.
GL_COLOR_ATTACHMENT0
GLES20
.
GL_TEXTURE_2D
bitmapTextureFramebuffer
.
getTextureId
(
)
0
)
;
GLES20
.
glClearColor
(
0
0
0
0
)
;
GLES20
.
glClear
(
GLES20
.
GL_COLOR_BUFFER_BIT
)
;
frameDrawer
.
drawFrame
(
frame
listenerAndParams
.
drawer
drawMatrix
0
0
scaledWidth
scaledHeight
)
;
final
ByteBuffer
bitmapBuffer
=
ByteBuffer
.
allocateDirect
(
scaledWidth
*
scaledHeight
*
4
)
;
GLES20
.
glViewport
(
0
0
scaledWidth
scaledHeight
)
;
GLES20
.
glReadPixels
(
0
0
scaledWidth
scaledHeight
GLES20
.
GL_RGBA
GLES20
.
GL_UNSIGNED_BYTE
bitmapBuffer
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
0
)
;
GlUtil
.
checkNoGLES2Error
(
"
EglRenderer
.
notifyCallbacks
"
)
;
final
Bitmap
bitmap
=
Bitmap
.
createBitmap
(
scaledWidth
scaledHeight
Bitmap
.
Config
.
ARGB_8888
)
;
bitmap
.
copyPixelsFromBuffer
(
bitmapBuffer
)
;
listenerAndParams
.
listener
.
onFrame
(
bitmap
)
;
}
}
private
String
averageTimeAsString
(
long
sumTimeNs
int
count
)
{
return
(
count
<
=
0
)
?
"
NA
"
:
TimeUnit
.
NANOSECONDS
.
toMicros
(
sumTimeNs
/
count
)
+
"
us
"
;
}
private
void
logStatistics
(
)
{
final
DecimalFormat
fpsFormat
=
new
DecimalFormat
(
"
#
.
0
"
)
;
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
synchronized
(
statisticsLock
)
{
final
long
elapsedTimeNs
=
currentTimeNs
-
statisticsStartTimeNs
;
if
(
elapsedTimeNs
<
=
0
|
|
(
minRenderPeriodNs
=
=
Long
.
MAX_VALUE
&
&
framesReceived
=
=
0
)
)
{
return
;
}
final
float
renderFps
=
framesRendered
*
TimeUnit
.
SECONDS
.
toNanos
(
1
)
/
(
float
)
elapsedTimeNs
;
logD
(
"
Duration
:
"
+
TimeUnit
.
NANOSECONDS
.
toMillis
(
elapsedTimeNs
)
+
"
ms
.
"
+
"
Frames
received
:
"
+
framesReceived
+
"
.
"
+
"
Dropped
:
"
+
framesDropped
+
"
.
"
+
"
Rendered
:
"
+
framesRendered
+
"
.
"
+
"
Render
fps
:
"
+
fpsFormat
.
format
(
renderFps
)
+
"
.
"
+
"
Average
render
time
:
"
+
averageTimeAsString
(
renderTimeNs
framesRendered
)
+
"
.
"
+
"
Average
swapBuffer
time
:
"
+
averageTimeAsString
(
renderSwapBufferTimeNs
framesRendered
)
+
"
.
"
)
;
resetStatistics
(
currentTimeNs
)
;
}
}
private
void
logE
(
String
string
Throwable
e
)
{
Logging
.
e
(
TAG
name
+
string
e
)
;
}
private
void
logD
(
String
string
)
{
Logging
.
d
(
TAG
name
+
string
)
;
}
private
void
logW
(
String
string
)
{
Logging
.
w
(
TAG
name
+
string
)
;
}
}
