package
org
.
webrtc
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
view
.
Choreographer
;
import
androidx
.
annotation
.
GuardedBy
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
CopyOnWriteArrayList
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
final
class
RenderSynchronizer
{
public
interface
Listener
{
void
onRenderWindowOpen
(
)
;
void
onRenderWindowClose
(
)
;
}
private
static
final
String
TAG
=
"
RenderSynchronizer
"
;
private
static
final
float
DEFAULT_TARGET_FPS
=
30f
;
private
final
Object
lock
=
new
Object
(
)
;
private
final
List
<
Listener
>
listeners
=
new
CopyOnWriteArrayList
<
>
(
)
;
private
final
long
targetFrameIntervalNanos
;
private
final
Handler
mainThreadHandler
;
private
Choreographer
choreographer
;
GuardedBy
(
"
lock
"
)
private
boolean
isListening
;
private
boolean
renderWindowOpen
;
private
long
lastRefreshTimeNanos
;
private
long
lastOpenedTimeNanos
;
public
RenderSynchronizer
(
float
targetFrameRateFps
)
{
this
.
targetFrameIntervalNanos
=
Math
.
round
(
TimeUnit
.
SECONDS
.
toNanos
(
1
)
/
targetFrameRateFps
)
;
this
.
mainThreadHandler
=
new
Handler
(
Looper
.
getMainLooper
(
)
)
;
mainThreadHandler
.
post
(
(
)
-
>
this
.
choreographer
=
Choreographer
.
getInstance
(
)
)
;
Logging
.
d
(
TAG
"
Created
"
)
;
}
public
RenderSynchronizer
(
)
{
this
(
DEFAULT_TARGET_FPS
)
;
}
public
void
registerListener
(
Listener
listener
)
{
listeners
.
add
(
listener
)
;
synchronized
(
lock
)
{
if
(
!
isListening
)
{
Logging
.
d
(
TAG
"
First
listener
subscribing
to
frame
callbacks
"
)
;
isListening
=
true
;
mainThreadHandler
.
post
(
(
)
-
>
choreographer
.
postFrameCallback
(
this
:
:
onDisplayRefreshCycleBegin
)
)
;
}
}
}
public
void
removeListener
(
Listener
listener
)
{
listeners
.
remove
(
listener
)
;
}
private
void
onDisplayRefreshCycleBegin
(
long
refreshTimeNanos
)
{
synchronized
(
lock
)
{
if
(
listeners
.
isEmpty
(
)
)
{
Logging
.
d
(
TAG
"
No
listeners
unsubscribing
to
frame
callbacks
"
)
;
isListening
=
false
;
return
;
}
}
choreographer
.
postFrameCallback
(
this
:
:
onDisplayRefreshCycleBegin
)
;
long
lastOpenDeltaNanos
=
refreshTimeNanos
-
lastOpenedTimeNanos
;
long
refreshDeltaNanos
=
refreshTimeNanos
-
lastRefreshTimeNanos
;
lastRefreshTimeNanos
=
refreshTimeNanos
;
if
(
Math
.
abs
(
lastOpenDeltaNanos
-
targetFrameIntervalNanos
)
<
Math
.
abs
(
lastOpenDeltaNanos
-
targetFrameIntervalNanos
+
refreshDeltaNanos
)
)
{
lastOpenedTimeNanos
=
refreshTimeNanos
;
openRenderWindow
(
)
;
}
else
if
(
renderWindowOpen
)
{
closeRenderWindow
(
)
;
}
}
private
void
openRenderWindow
(
)
{
renderWindowOpen
=
true
;
for
(
Listener
listener
:
listeners
)
{
listener
.
onRenderWindowOpen
(
)
;
}
}
private
void
closeRenderWindow
(
)
{
renderWindowOpen
=
false
;
for
(
Listener
listener
:
listeners
)
{
listener
.
onRenderWindowClose
(
)
;
}
}
}
