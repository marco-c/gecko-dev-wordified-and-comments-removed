package
org
.
webrtc
;
import
android
.
os
.
Handler
;
import
android
.
os
.
HandlerThread
;
import
android
.
os
.
Looper
;
import
android
.
os
.
Message
;
import
androidx
.
annotation
.
GuardedBy
;
import
androidx
.
annotation
.
Nullable
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
org
.
webrtc
.
EglBase
.
EglConnection
;
public
class
EglThread
implements
RenderSynchronizer
.
Listener
{
public
interface
ReleaseMonitor
{
boolean
onRelease
(
EglThread
eglThread
)
;
}
public
interface
RenderUpdate
{
void
update
(
boolean
runsInline
)
;
}
public
static
EglThread
create
(
Nullable
ReleaseMonitor
releaseMonitor
Nullable
final
EglBase
.
Context
sharedContext
final
int
[
]
configAttributes
Nullable
RenderSynchronizer
renderSynchronizer
)
{
final
HandlerThread
renderThread
=
new
HandlerThread
(
"
EglThread
"
)
;
renderThread
.
start
(
)
;
HandlerWithExceptionCallbacks
handler
=
new
HandlerWithExceptionCallbacks
(
renderThread
.
getLooper
(
)
)
;
EglConnection
eglConnection
=
ThreadUtils
.
invokeAtFrontUninterruptibly
(
handler
(
)
-
>
{
if
(
sharedContext
=
=
null
)
{
return
EglConnection
.
createEgl10
(
configAttributes
)
;
}
else
{
return
EglConnection
.
create
(
sharedContext
configAttributes
)
;
}
}
)
;
return
new
EglThread
(
releaseMonitor
!
=
null
?
releaseMonitor
:
eglThread
-
>
true
handler
eglConnection
renderSynchronizer
)
;
}
public
static
EglThread
create
(
Nullable
ReleaseMonitor
releaseMonitor
Nullable
final
EglBase
.
Context
sharedContext
final
int
[
]
configAttributes
)
{
return
create
(
releaseMonitor
sharedContext
configAttributes
null
)
;
}
private
static
class
HandlerWithExceptionCallbacks
extends
Handler
{
private
final
Object
callbackLock
=
new
Object
(
)
;
GuardedBy
(
"
callbackLock
"
)
private
final
List
<
Runnable
>
exceptionCallbacks
=
new
ArrayList
<
>
(
)
;
public
HandlerWithExceptionCallbacks
(
Looper
looper
)
{
super
(
looper
)
;
}
Override
public
void
dispatchMessage
(
Message
msg
)
{
try
{
super
.
dispatchMessage
(
msg
)
;
}
catch
(
Exception
e
)
{
Logging
.
e
(
"
EglThread
"
"
Exception
on
EglThread
"
e
)
;
synchronized
(
callbackLock
)
{
for
(
Runnable
callback
:
exceptionCallbacks
)
{
callback
.
run
(
)
;
}
}
throw
e
;
}
}
public
void
addExceptionCallback
(
Runnable
callback
)
{
synchronized
(
callbackLock
)
{
exceptionCallbacks
.
add
(
callback
)
;
}
}
public
void
removeExceptionCallback
(
Runnable
callback
)
{
synchronized
(
callbackLock
)
{
exceptionCallbacks
.
remove
(
callback
)
;
}
}
}
private
final
ReleaseMonitor
releaseMonitor
;
private
final
HandlerWithExceptionCallbacks
handler
;
private
final
EglConnection
eglConnection
;
private
final
RenderSynchronizer
renderSynchronizer
;
private
final
List
<
RenderUpdate
>
pendingRenderUpdates
=
new
ArrayList
<
>
(
)
;
private
boolean
renderWindowOpen
=
true
;
private
EglThread
(
ReleaseMonitor
releaseMonitor
HandlerWithExceptionCallbacks
handler
EglConnection
eglConnection
RenderSynchronizer
renderSynchronizer
)
{
this
.
releaseMonitor
=
releaseMonitor
;
this
.
handler
=
handler
;
this
.
eglConnection
=
eglConnection
;
this
.
renderSynchronizer
=
renderSynchronizer
;
if
(
renderSynchronizer
!
=
null
)
{
renderSynchronizer
.
registerListener
(
this
)
;
}
}
public
void
release
(
)
{
if
(
!
releaseMonitor
.
onRelease
(
this
)
)
{
return
;
}
if
(
renderSynchronizer
!
=
null
)
{
renderSynchronizer
.
removeListener
(
this
)
;
}
handler
.
post
(
eglConnection
:
:
release
)
;
handler
.
getLooper
(
)
.
quitSafely
(
)
;
}
public
EglBase
createEglBaseWithSharedConnection
(
)
{
return
EglBase
.
create
(
eglConnection
)
;
}
public
Handler
getHandler
(
)
{
return
handler
;
}
public
void
addExceptionCallback
(
Runnable
callback
)
{
handler
.
addExceptionCallback
(
callback
)
;
}
public
void
removeExceptionCallback
(
Runnable
callback
)
{
handler
.
removeExceptionCallback
(
callback
)
;
}
public
void
scheduleRenderUpdate
(
RenderUpdate
update
)
{
if
(
renderWindowOpen
)
{
update
.
update
(
true
)
;
}
else
{
pendingRenderUpdates
.
add
(
update
)
;
}
}
Override
public
void
onRenderWindowOpen
(
)
{
handler
.
post
(
(
)
-
>
{
renderWindowOpen
=
true
;
for
(
RenderUpdate
update
:
pendingRenderUpdates
)
{
update
.
update
(
false
)
;
}
pendingRenderUpdates
.
clear
(
)
;
}
)
;
}
Override
public
void
onRenderWindowClose
(
)
{
handler
.
post
(
(
)
-
>
renderWindowOpen
=
false
)
;
}
}
