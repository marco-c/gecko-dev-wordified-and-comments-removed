package
org
.
webrtc
;
import
static
org
.
junit
.
Assert
.
assertEquals
;
import
static
org
.
junit
.
Assert
.
assertFalse
;
import
static
org
.
junit
.
Assert
.
assertNotNull
;
import
static
org
.
junit
.
Assert
.
assertNull
;
import
static
org
.
junit
.
Assert
.
assertTrue
;
import
static
org
.
junit
.
Assert
.
fail
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
android
.
support
.
test
.
InstrumentationRegistry
;
import
androidx
.
test
.
filters
.
SmallTest
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
org
.
junit
.
After
;
import
org
.
junit
.
Before
;
import
org
.
junit
.
Test
;
public
class
EglRendererTest
{
private
final
static
String
TAG
=
"
EglRendererTest
"
;
private
final
static
int
RENDER_WAIT_MS
=
1000
;
private
final
static
int
SURFACE_WAIT_MS
=
1000
;
private
final
static
int
TEST_FRAME_WIDTH
=
4
;
private
final
static
int
TEST_FRAME_HEIGHT
=
4
;
private
final
static
int
REMOVE_FRAME_LISTENER_RACY_NUM_TESTS
=
10
;
private
final
static
byte
[
]
[
]
[
]
TEST_FRAMES_DATA
=
{
{
new
byte
[
]
{
-
99
-
93
-
88
-
83
-
78
-
73
-
68
-
62
-
56
-
52
-
46
-
41
-
36
-
31
-
26
-
20
}
new
byte
[
]
{
110
113
116
118
}
new
byte
[
]
{
31
45
59
73
}
}
{
new
byte
[
]
{
-
108
-
103
-
98
-
93
-
87
-
82
-
77
-
72
-
67
-
62
-
56
-
50
-
45
-
40
-
35
-
30
}
new
byte
[
]
{
120
123
125
-
127
}
new
byte
[
]
{
87
100
114
127
}
}
{
new
byte
[
]
{
-
117
-
112
-
107
-
102
-
97
-
92
-
87
-
81
-
75
-
71
-
65
-
60
-
55
-
50
-
44
-
39
}
new
byte
[
]
{
113
116
118
120
}
new
byte
[
]
{
45
59
73
87
}
}
}
;
private
final
static
ByteBuffer
[
]
[
]
TEST_FRAMES
=
copyTestDataToDirectByteBuffers
(
TEST_FRAMES_DATA
)
;
private
static
class
TestFrameListener
implements
EglRenderer
.
FrameListener
{
final
private
ArrayList
<
Bitmap
>
bitmaps
=
new
ArrayList
<
Bitmap
>
(
)
;
boolean
bitmapReceived
;
Bitmap
storedBitmap
;
Override
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
void
onFrame
(
Bitmap
bitmap
)
{
if
(
bitmapReceived
)
{
fail
(
"
Unexpected
bitmap
was
received
.
"
)
;
}
bitmapReceived
=
true
;
storedBitmap
=
bitmap
;
notify
(
)
;
}
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
boolean
waitForBitmap
(
int
timeoutMs
)
throws
InterruptedException
{
final
long
endTimeMs
=
System
.
currentTimeMillis
(
)
+
timeoutMs
;
while
(
!
bitmapReceived
)
{
final
long
waitTimeMs
=
endTimeMs
-
System
.
currentTimeMillis
(
)
;
if
(
waitTimeMs
<
0
)
{
return
false
;
}
wait
(
timeoutMs
)
;
}
return
true
;
}
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
synchronized
Bitmap
resetAndGetBitmap
(
)
{
bitmapReceived
=
false
;
return
storedBitmap
;
}
}
final
TestFrameListener
testFrameListener
=
new
TestFrameListener
(
)
;
EglRenderer
eglRenderer
;
CountDownLatch
surfaceReadyLatch
=
new
CountDownLatch
(
1
)
;
int
oesTextureId
;
SurfaceTexture
surfaceTexture
;
Before
public
void
setUp
(
)
throws
Exception
{
PeerConnectionFactory
.
initialize
(
PeerConnectionFactory
.
InitializationOptions
.
builder
(
InstrumentationRegistry
.
getTargetContext
(
)
)
.
setNativeLibraryName
(
TestConstants
.
NATIVE_LIBRARY
)
.
createInitializationOptions
(
)
)
;
eglRenderer
=
new
EglRenderer
(
"
TestRenderer
:
"
)
;
eglRenderer
.
init
(
null
EglBase
.
CONFIG_RGBA
new
GlRectDrawer
(
)
)
;
oesTextureId
=
GlUtil
.
generateTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
)
;
surfaceTexture
=
new
SurfaceTexture
(
oesTextureId
)
;
surfaceTexture
.
setDefaultBufferSize
(
1
1
)
;
eglRenderer
.
createEglSurface
(
surfaceTexture
)
;
}
After
public
void
tearDown
(
)
{
surfaceTexture
.
release
(
)
;
GLES20
.
glDeleteTextures
(
1
new
int
[
]
{
oesTextureId
}
0
)
;
eglRenderer
.
release
(
)
;
}
private
static
void
checkBitmap
(
Bitmap
bitmap
float
scale
)
{
assertNotNull
(
bitmap
)
;
assertEquals
(
(
int
)
(
TEST_FRAME_WIDTH
*
scale
)
bitmap
.
getWidth
(
)
)
;
assertEquals
(
(
int
)
(
TEST_FRAME_HEIGHT
*
scale
)
bitmap
.
getHeight
(
)
)
;
}
private
static
float
linearSample
(
ByteBuffer
plane
int
planeWidth
int
planeHeight
float
x
float
y
)
{
final
int
stride
=
planeWidth
;
final
float
coordX
=
x
*
planeWidth
;
final
float
coordY
=
y
*
planeHeight
;
int
lowIndexX
=
(
int
)
Math
.
floor
(
coordX
-
0
.
5f
)
;
int
lowIndexY
=
(
int
)
Math
.
floor
(
coordY
-
0
.
5f
)
;
int
highIndexX
=
lowIndexX
+
1
;
int
highIndexY
=
lowIndexY
+
1
;
final
float
highWeightX
=
coordX
-
lowIndexX
-
0
.
5f
;
final
float
highWeightY
=
coordY
-
lowIndexY
-
0
.
5f
;
final
float
lowWeightX
=
1f
-
highWeightX
;
final
float
lowWeightY
=
1f
-
highWeightY
;
lowIndexX
=
Math
.
max
(
0
lowIndexX
)
;
lowIndexY
=
Math
.
max
(
0
lowIndexY
)
;
highIndexX
=
Math
.
min
(
planeWidth
-
1
highIndexX
)
;
highIndexY
=
Math
.
min
(
planeHeight
-
1
highIndexY
)
;
float
lowYValue
=
(
plane
.
get
(
lowIndexY
*
stride
+
lowIndexX
)
&
0xFF
)
*
lowWeightX
+
(
plane
.
get
(
lowIndexY
*
stride
+
highIndexX
)
&
0xFF
)
*
highWeightX
;
float
highYValue
=
(
plane
.
get
(
highIndexY
*
stride
+
lowIndexX
)
&
0xFF
)
*
lowWeightX
+
(
plane
.
get
(
highIndexY
*
stride
+
highIndexX
)
&
0xFF
)
*
highWeightX
;
return
lowWeightY
*
lowYValue
+
highWeightY
*
highYValue
;
}
private
static
byte
saturatedFloatToByte
(
float
c
)
{
return
(
byte
)
Math
.
round
(
255f
*
Math
.
max
(
0f
Math
.
min
(
1f
c
)
)
)
;
}
private
static
byte
[
]
convertYUVFrameToRGBA
(
ByteBuffer
[
]
yuvFrame
)
{
final
byte
[
]
argbFrame
=
new
byte
[
TEST_FRAME_WIDTH
*
TEST_FRAME_HEIGHT
*
4
]
;
final
int
argbStride
=
TEST_FRAME_WIDTH
*
4
;
final
int
yStride
=
TEST_FRAME_WIDTH
;
final
int
vStride
=
TEST_FRAME_WIDTH
/
2
;
for
(
int
y
=
0
;
y
<
TEST_FRAME_HEIGHT
;
y
+
+
)
{
for
(
int
x
=
0
;
x
<
TEST_FRAME_WIDTH
;
x
+
+
)
{
final
float
yC
=
(
(
yuvFrame
[
0
]
.
get
(
y
*
yStride
+
x
)
&
0xFF
)
-
16f
)
/
219f
;
final
float
uC
=
(
linearSample
(
yuvFrame
[
1
]
TEST_FRAME_WIDTH
/
2
TEST_FRAME_HEIGHT
/
2
(
x
+
0
.
5f
)
/
TEST_FRAME_WIDTH
(
y
+
0
.
5f
)
/
TEST_FRAME_HEIGHT
)
-
16f
)
/
224f
-
0
.
5f
;
final
float
vC
=
(
linearSample
(
yuvFrame
[
2
]
TEST_FRAME_WIDTH
/
2
TEST_FRAME_HEIGHT
/
2
(
x
+
0
.
5f
)
/
TEST_FRAME_WIDTH
(
y
+
0
.
5f
)
/
TEST_FRAME_HEIGHT
)
-
16f
)
/
224f
-
0
.
5f
;
final
float
rC
=
yC
+
1
.
403f
*
vC
;
final
float
gC
=
yC
-
0
.
344f
*
uC
-
0
.
714f
*
vC
;
final
float
bC
=
yC
+
1
.
77f
*
uC
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
0
]
=
saturatedFloatToByte
(
rC
)
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
1
]
=
saturatedFloatToByte
(
gC
)
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
2
]
=
saturatedFloatToByte
(
bC
)
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
3
]
=
(
byte
)
255
;
}
}
return
argbFrame
;
}
SuppressWarnings
(
"
ByteBufferBackingArray
"
)
private
static
void
checkBitmapContent
(
Bitmap
bitmap
int
frame
)
{
checkBitmap
(
bitmap
1f
)
;
byte
[
]
expectedRGBA
=
convertYUVFrameToRGBA
(
TEST_FRAMES
[
frame
]
)
;
ByteBuffer
bitmapBuffer
=
ByteBuffer
.
allocateDirect
(
bitmap
.
getByteCount
(
)
)
;
bitmap
.
copyPixelsToBuffer
(
bitmapBuffer
)
;
for
(
int
i
=
0
;
i
<
expectedRGBA
.
length
;
i
+
+
)
{
int
expected
=
expectedRGBA
[
i
]
&
0xFF
;
int
value
=
bitmapBuffer
.
get
(
i
)
&
0xFF
;
if
(
Math
.
abs
(
value
-
expected
)
>
1
)
{
Logging
.
d
(
TAG
"
Expected
bitmap
content
:
"
+
Arrays
.
toString
(
expectedRGBA
)
)
;
Logging
.
d
(
TAG
"
Bitmap
content
:
"
+
Arrays
.
toString
(
bitmapBuffer
.
array
(
)
)
)
;
fail
(
"
Frame
doesn
'
t
match
original
frame
on
byte
"
+
i
+
"
.
Expected
:
"
+
expected
+
"
Result
:
"
+
value
)
;
}
}
}
private
void
feedFrame
(
int
i
)
{
final
VideoFrame
.
I420Buffer
buffer
=
JavaI420Buffer
.
wrap
(
TEST_FRAME_WIDTH
TEST_FRAME_HEIGHT
TEST_FRAMES
[
i
]
[
0
]
TEST_FRAME_WIDTH
TEST_FRAMES
[
i
]
[
1
]
TEST_FRAME_WIDTH
/
2
TEST_FRAMES
[
i
]
[
2
]
TEST_FRAME_WIDTH
/
2
null
)
;
final
VideoFrame
frame
=
new
VideoFrame
(
buffer
0
0
)
;
eglRenderer
.
onFrame
(
frame
)
;
frame
.
release
(
)
;
}
Test
SmallTest
public
void
testAddFrameListener
(
)
throws
Exception
{
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
feedFrame
(
0
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
assertNull
(
testFrameListener
.
resetAndGetBitmap
(
)
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
feedFrame
(
1
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
assertNull
(
testFrameListener
.
resetAndGetBitmap
(
)
)
;
feedFrame
(
2
)
;
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
Test
SmallTest
public
void
testAddFrameListenerBitmap
(
)
throws
Exception
{
eglRenderer
.
addFrameListener
(
testFrameListener
1f
)
;
feedFrame
(
0
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmapContent
(
testFrameListener
.
resetAndGetBitmap
(
)
0
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
1f
)
;
feedFrame
(
1
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmapContent
(
testFrameListener
.
resetAndGetBitmap
(
)
1
)
;
}
Test
SmallTest
public
void
testAddFrameListenerBitmapScale
(
)
throws
Exception
{
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
float
scale
=
i
*
0
.
5f
+
0
.
5f
;
eglRenderer
.
addFrameListener
(
testFrameListener
scale
)
;
feedFrame
(
i
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmap
(
testFrameListener
.
resetAndGetBitmap
(
)
scale
)
;
}
}
Test
SmallTest
public
void
testFrameListenerNotCalledWithOldFrames
(
)
throws
Exception
{
feedFrame
(
0
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
Test
SmallTest
public
void
testRemoveFrameListenerNotRacy
(
)
throws
Exception
{
for
(
int
i
=
0
;
i
<
REMOVE_FRAME_LISTENER_RACY_NUM_TESTS
;
i
+
+
)
{
feedFrame
(
0
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
eglRenderer
.
removeFrameListener
(
testFrameListener
)
;
feedFrame
(
1
)
;
}
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
Test
SmallTest
public
void
testFrameListenersFpsReduction
(
)
throws
Exception
{
eglRenderer
.
pauseVideo
(
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
1f
)
;
feedFrame
(
0
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmapContent
(
testFrameListener
.
resetAndGetBitmap
(
)
0
)
;
eglRenderer
.
disableFpsReduction
(
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
1f
null
true
)
;
feedFrame
(
1
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmapContent
(
testFrameListener
.
resetAndGetBitmap
(
)
1
)
;
eglRenderer
.
pauseVideo
(
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
1f
null
true
)
;
feedFrame
(
1
)
;
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
private
static
ByteBuffer
[
]
[
]
copyTestDataToDirectByteBuffers
(
byte
[
]
[
]
[
]
testData
)
{
final
ByteBuffer
[
]
[
]
result
=
new
ByteBuffer
[
testData
.
length
]
[
]
;
for
(
int
i
=
0
;
i
<
testData
.
length
;
i
+
+
)
{
result
[
i
]
=
new
ByteBuffer
[
testData
[
i
]
.
length
]
;
for
(
int
j
=
0
;
j
<
testData
[
i
]
.
length
;
j
+
+
)
{
result
[
i
]
[
j
]
=
ByteBuffer
.
allocateDirect
(
testData
[
i
]
[
j
]
.
length
)
;
result
[
i
]
[
j
]
.
put
(
testData
[
i
]
[
j
]
)
;
result
[
i
]
[
j
]
.
rewind
(
)
;
}
}
return
result
;
}
}
