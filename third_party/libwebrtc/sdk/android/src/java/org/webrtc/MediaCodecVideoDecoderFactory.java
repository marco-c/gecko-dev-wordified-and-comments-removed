package
org
.
webrtc
;
import
static
org
.
webrtc
.
MediaCodecUtils
.
EXYNOS_PREFIX
;
import
static
org
.
webrtc
.
MediaCodecUtils
.
QCOM_PREFIX
;
import
android
.
media
.
MediaCodecInfo
;
import
android
.
media
.
MediaCodecInfo
.
CodecCapabilities
;
import
android
.
media
.
MediaCodecList
;
import
android
.
os
.
Build
;
import
androidx
.
annotation
.
Nullable
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
SuppressWarnings
(
"
deprecation
"
)
class
MediaCodecVideoDecoderFactory
implements
VideoDecoderFactory
{
private
static
final
String
TAG
=
"
MediaCodecVideoDecoderFactory
"
;
private
final
Nullable
EglBase
.
Context
sharedContext
;
private
final
Nullable
Predicate
<
MediaCodecInfo
>
codecAllowedPredicate
;
public
MediaCodecVideoDecoderFactory
(
Nullable
EglBase
.
Context
sharedContext
Nullable
Predicate
<
MediaCodecInfo
>
codecAllowedPredicate
)
{
this
.
sharedContext
=
sharedContext
;
this
.
codecAllowedPredicate
=
codecAllowedPredicate
;
}
Nullable
Override
public
VideoDecoder
createDecoder
(
VideoCodecInfo
codecType
)
{
VideoCodecMimeType
type
=
VideoCodecMimeType
.
valueOf
(
codecType
.
getName
(
)
)
;
MediaCodecInfo
info
=
findCodecForType
(
type
)
;
if
(
info
=
=
null
)
{
return
null
;
}
CodecCapabilities
capabilities
=
info
.
getCapabilitiesForType
(
type
.
mimeType
(
)
)
;
return
new
AndroidVideoDecoder
(
new
MediaCodecWrapperFactoryImpl
(
)
info
.
getName
(
)
type
MediaCodecUtils
.
selectColorFormat
(
MediaCodecUtils
.
DECODER_COLOR_FORMATS
capabilities
)
sharedContext
)
;
}
Override
public
VideoCodecInfo
[
]
getSupportedCodecs
(
)
{
List
<
VideoCodecInfo
>
supportedCodecInfos
=
new
ArrayList
<
VideoCodecInfo
>
(
)
;
for
(
VideoCodecMimeType
type
:
new
VideoCodecMimeType
[
]
{
VideoCodecMimeType
.
VP8
VideoCodecMimeType
.
VP9
VideoCodecMimeType
.
H264
VideoCodecMimeType
.
AV1
}
)
{
MediaCodecInfo
codec
=
findCodecForType
(
type
)
;
if
(
codec
!
=
null
)
{
String
name
=
type
.
name
(
)
;
if
(
type
=
=
VideoCodecMimeType
.
H264
&
&
isH264HighProfileSupported
(
codec
)
)
{
supportedCodecInfos
.
add
(
new
VideoCodecInfo
(
name
MediaCodecUtils
.
getCodecProperties
(
type
true
)
)
)
;
}
supportedCodecInfos
.
add
(
new
VideoCodecInfo
(
name
MediaCodecUtils
.
getCodecProperties
(
type
false
)
)
)
;
}
}
return
supportedCodecInfos
.
toArray
(
new
VideoCodecInfo
[
supportedCodecInfos
.
size
(
)
]
)
;
}
private
Nullable
MediaCodecInfo
findCodecForType
(
VideoCodecMimeType
type
)
{
if
(
Build
.
VERSION
.
SDK_INT
<
Build
.
VERSION_CODES
.
KITKAT
)
{
return
null
;
}
for
(
int
i
=
0
;
i
<
MediaCodecList
.
getCodecCount
(
)
;
+
+
i
)
{
MediaCodecInfo
info
=
null
;
try
{
info
=
MediaCodecList
.
getCodecInfoAt
(
i
)
;
}
catch
(
IllegalArgumentException
e
)
{
Logging
.
e
(
TAG
"
Cannot
retrieve
decoder
codec
info
"
e
)
;
}
if
(
info
=
=
null
|
|
info
.
isEncoder
(
)
)
{
continue
;
}
if
(
isSupportedCodec
(
info
type
)
)
{
return
info
;
}
}
return
null
;
}
private
boolean
isSupportedCodec
(
MediaCodecInfo
info
VideoCodecMimeType
type
)
{
String
name
=
info
.
getName
(
)
;
if
(
!
MediaCodecUtils
.
codecSupportsType
(
info
type
)
)
{
return
false
;
}
if
(
MediaCodecUtils
.
selectColorFormat
(
MediaCodecUtils
.
DECODER_COLOR_FORMATS
info
.
getCapabilitiesForType
(
type
.
mimeType
(
)
)
)
=
=
null
)
{
return
false
;
}
return
isCodecAllowed
(
info
)
;
}
private
boolean
isCodecAllowed
(
MediaCodecInfo
info
)
{
if
(
codecAllowedPredicate
=
=
null
)
{
return
true
;
}
return
codecAllowedPredicate
.
test
(
info
)
;
}
private
boolean
isH264HighProfileSupported
(
MediaCodecInfo
info
)
{
String
name
=
info
.
getName
(
)
;
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
LOLLIPOP
&
&
name
.
startsWith
(
QCOM_PREFIX
)
)
{
return
true
;
}
if
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
M
&
&
name
.
startsWith
(
EXYNOS_PREFIX
)
)
{
return
true
;
}
return
false
;
}
}
