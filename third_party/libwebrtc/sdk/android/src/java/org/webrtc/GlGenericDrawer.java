package
org
.
webrtc
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
androidx
.
annotation
.
Nullable
;
import
java
.
nio
.
FloatBuffer
;
import
org
.
webrtc
.
GlShader
;
import
org
.
webrtc
.
GlUtil
;
import
org
.
webrtc
.
RendererCommon
;
class
GlGenericDrawer
implements
RendererCommon
.
GlDrawer
{
public
static
enum
ShaderType
{
OES
RGB
YUV
}
public
static
interface
ShaderCallbacks
{
void
onNewShader
(
GlShader
shader
)
;
void
onPrepareShader
(
GlShader
shader
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportWidth
int
viewportHeight
)
;
}
private
static
final
String
INPUT_VERTEX_COORDINATE_NAME
=
"
in_pos
"
;
private
static
final
String
INPUT_TEXTURE_COORDINATE_NAME
=
"
in_tc
"
;
private
static
final
String
TEXTURE_MATRIX_NAME
=
"
tex_mat
"
;
private
static
final
String
DEFAULT_VERTEX_SHADER_STRING
=
"
varying
vec2
tc
;
\
n
"
+
"
attribute
vec4
in_pos
;
\
n
"
+
"
attribute
vec4
in_tc
;
\
n
"
+
"
uniform
mat4
tex_mat
;
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_Position
=
in_pos
;
\
n
"
+
"
tc
=
(
tex_mat
*
in_tc
)
.
xy
;
\
n
"
+
"
}
\
n
"
;
private
static
final
FloatBuffer
FULL_RECTANGLE_BUFFER
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
final
FloatBuffer
FULL_RECTANGLE_TEXTURE_BUFFER
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
static
String
createFragmentShaderString
(
String
genericFragmentSource
ShaderType
shaderType
)
{
final
StringBuilder
stringBuilder
=
new
StringBuilder
(
)
;
if
(
shaderType
=
=
ShaderType
.
OES
)
{
stringBuilder
.
append
(
"
#
extension
GL_OES_EGL_image_external
:
require
\
n
"
)
;
}
stringBuilder
.
append
(
"
precision
mediump
float
;
\
n
"
)
;
stringBuilder
.
append
(
"
varying
vec2
tc
;
\
n
"
)
;
if
(
shaderType
=
=
ShaderType
.
YUV
)
{
stringBuilder
.
append
(
"
uniform
sampler2D
y_tex
;
\
n
"
)
;
stringBuilder
.
append
(
"
uniform
sampler2D
u_tex
;
\
n
"
)
;
stringBuilder
.
append
(
"
uniform
sampler2D
v_tex
;
\
n
"
)
;
stringBuilder
.
append
(
"
vec4
sample
(
vec2
p
)
{
\
n
"
)
;
stringBuilder
.
append
(
"
float
y
=
texture2D
(
y_tex
p
)
.
r
*
1
.
16438
;
\
n
"
)
;
stringBuilder
.
append
(
"
float
u
=
texture2D
(
u_tex
p
)
.
r
;
\
n
"
)
;
stringBuilder
.
append
(
"
float
v
=
texture2D
(
v_tex
p
)
.
r
;
\
n
"
)
;
stringBuilder
.
append
(
"
return
vec4
(
y
+
1
.
59603
*
v
-
0
.
874202
\
n
"
)
;
stringBuilder
.
append
(
"
y
-
0
.
391762
*
u
-
0
.
812968
*
v
+
0
.
531668
\
n
"
)
;
stringBuilder
.
append
(
"
y
+
2
.
01723
*
u
-
1
.
08563
1
)
;
\
n
"
)
;
stringBuilder
.
append
(
"
}
\
n
"
)
;
stringBuilder
.
append
(
genericFragmentSource
)
;
}
else
{
final
String
samplerName
=
shaderType
=
=
ShaderType
.
OES
?
"
samplerExternalOES
"
:
"
sampler2D
"
;
stringBuilder
.
append
(
"
uniform
"
)
.
append
(
samplerName
)
.
append
(
"
tex
;
\
n
"
)
;
stringBuilder
.
append
(
genericFragmentSource
.
replace
(
"
sample
(
"
"
texture2D
(
tex
"
)
)
;
}
return
stringBuilder
.
toString
(
)
;
}
private
final
String
genericFragmentSource
;
private
final
String
vertexShader
;
private
final
ShaderCallbacks
shaderCallbacks
;
Nullable
private
ShaderType
currentShaderType
;
Nullable
private
GlShader
currentShader
;
private
int
inPosLocation
;
private
int
inTcLocation
;
private
int
texMatrixLocation
;
public
GlGenericDrawer
(
String
genericFragmentSource
ShaderCallbacks
shaderCallbacks
)
{
this
(
DEFAULT_VERTEX_SHADER_STRING
genericFragmentSource
shaderCallbacks
)
;
}
public
GlGenericDrawer
(
String
vertexShader
String
genericFragmentSource
ShaderCallbacks
shaderCallbacks
)
{
this
.
vertexShader
=
vertexShader
;
this
.
genericFragmentSource
=
genericFragmentSource
;
this
.
shaderCallbacks
=
shaderCallbacks
;
}
GlShader
createShader
(
ShaderType
shaderType
)
{
return
new
GlShader
(
vertexShader
createFragmentShaderString
(
genericFragmentSource
shaderType
)
)
;
}
Override
public
void
drawOes
(
int
oesTextureId
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportX
int
viewportY
int
viewportWidth
int
viewportHeight
)
{
prepareShader
(
ShaderType
.
OES
texMatrix
frameWidth
frameHeight
viewportWidth
viewportHeight
)
;
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
oesTextureId
)
;
GLES20
.
glViewport
(
viewportX
viewportY
viewportWidth
viewportHeight
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
0
)
;
}
Override
public
void
drawRgb
(
int
textureId
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportX
int
viewportY
int
viewportWidth
int
viewportHeight
)
{
prepareShader
(
ShaderType
.
RGB
texMatrix
frameWidth
frameHeight
viewportWidth
viewportHeight
)
;
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
textureId
)
;
GLES20
.
glViewport
(
viewportX
viewportY
viewportWidth
viewportHeight
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
0
)
;
}
Override
public
void
drawYuv
(
int
[
]
yuvTextures
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportX
int
viewportY
int
viewportWidth
int
viewportHeight
)
{
prepareShader
(
ShaderType
.
YUV
texMatrix
frameWidth
frameHeight
viewportWidth
viewportHeight
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
+
i
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
yuvTextures
[
i
]
)
;
}
GLES20
.
glViewport
(
viewportX
viewportY
viewportWidth
viewportHeight
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
+
i
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
0
)
;
}
}
private
void
prepareShader
(
ShaderType
shaderType
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportWidth
int
viewportHeight
)
{
final
GlShader
shader
;
if
(
shaderType
.
equals
(
currentShaderType
)
)
{
shader
=
currentShader
;
}
else
{
currentShaderType
=
null
;
if
(
currentShader
!
=
null
)
{
currentShader
.
release
(
)
;
currentShader
=
null
;
}
shader
=
createShader
(
shaderType
)
;
currentShaderType
=
shaderType
;
currentShader
=
shader
;
shader
.
useProgram
(
)
;
if
(
shaderType
=
=
ShaderType
.
YUV
)
{
GLES20
.
glUniform1i
(
shader
.
getUniformLocation
(
"
y_tex
"
)
0
)
;
GLES20
.
glUniform1i
(
shader
.
getUniformLocation
(
"
u_tex
"
)
1
)
;
GLES20
.
glUniform1i
(
shader
.
getUniformLocation
(
"
v_tex
"
)
2
)
;
}
else
{
GLES20
.
glUniform1i
(
shader
.
getUniformLocation
(
"
tex
"
)
0
)
;
}
GlUtil
.
checkNoGLES2Error
(
"
Create
shader
"
)
;
shaderCallbacks
.
onNewShader
(
shader
)
;
texMatrixLocation
=
shader
.
getUniformLocation
(
TEXTURE_MATRIX_NAME
)
;
inPosLocation
=
shader
.
getAttribLocation
(
INPUT_VERTEX_COORDINATE_NAME
)
;
inTcLocation
=
shader
.
getAttribLocation
(
INPUT_TEXTURE_COORDINATE_NAME
)
;
}
shader
.
useProgram
(
)
;
GLES20
.
glEnableVertexAttribArray
(
inPosLocation
)
;
GLES20
.
glVertexAttribPointer
(
inPosLocation
2
GLES20
.
GL_FLOAT
false
0
FULL_RECTANGLE_BUFFER
)
;
GLES20
.
glEnableVertexAttribArray
(
inTcLocation
)
;
GLES20
.
glVertexAttribPointer
(
inTcLocation
2
GLES20
.
GL_FLOAT
false
0
FULL_RECTANGLE_TEXTURE_BUFFER
)
;
GLES20
.
glUniformMatrix4fv
(
texMatrixLocation
1
false
texMatrix
0
)
;
shaderCallbacks
.
onPrepareShader
(
shader
texMatrix
frameWidth
frameHeight
viewportWidth
viewportHeight
)
;
GlUtil
.
checkNoGLES2Error
(
"
Prepare
shader
"
)
;
}
Override
public
void
release
(
)
{
if
(
currentShader
!
=
null
)
{
currentShader
.
release
(
)
;
currentShader
=
null
;
currentShaderType
=
null
;
}
}
}
