#
ifndef
SDK_ANDROID_SRC_JNI_VIDEO_ENCODER_WRAPPER_H_
#
define
SDK_ANDROID_SRC_JNI_VIDEO_ENCODER_WRAPPER_H_
#
include
<
jni
.
h
>
#
include
<
deque
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
common_video
/
h264
/
h264_bitstream_parser
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp9
/
include
/
vp9_globals
.
h
"
#
include
"
modules
/
video_coding
/
svc
/
scalable_video_controller_no_layering
.
h
"
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
#
include
"
sdk
/
android
/
src
/
jni
/
jni_helpers
.
h
"
namespace
webrtc
{
namespace
jni
{
class
VideoEncoderWrapper
:
public
VideoEncoder
{
public
:
VideoEncoderWrapper
(
JNIEnv
*
jni
const
JavaRef
<
jobject
>
&
j_encoder
)
;
~
VideoEncoderWrapper
(
)
override
;
int32_t
InitEncode
(
const
VideoCodec
*
codec_settings
const
Settings
&
settings
)
override
;
int32_t
RegisterEncodeCompleteCallback
(
EncodedImageCallback
*
callback
)
override
;
int32_t
Release
(
)
override
;
int32_t
Encode
(
const
VideoFrame
&
frame
const
std
:
:
vector
<
VideoFrameType
>
*
frame_types
)
override
;
void
SetRates
(
const
RateControlParameters
&
parameters
)
override
;
EncoderInfo
GetEncoderInfo
(
)
const
override
;
void
OnEncodedFrame
(
JNIEnv
*
jni
const
JavaRef
<
jobject
>
&
j_encoded_image
)
;
private
:
struct
FrameExtraInfo
{
int64_t
capture_time_ns
;
uint32_t
timestamp_rtp
;
}
;
int32_t
InitEncodeInternal
(
JNIEnv
*
jni
)
;
int32_t
HandleReturnCode
(
JNIEnv
*
jni
const
JavaRef
<
jobject
>
&
j_value
const
char
*
method_name
)
;
int
ParseQp
(
rtc
:
:
ArrayView
<
const
uint8_t
>
buffer
)
;
CodecSpecificInfo
ParseCodecSpecificInfo
(
const
EncodedImage
&
frame
)
;
ScopedJavaLocalRef
<
jobject
>
ToJavaBitrateAllocation
(
JNIEnv
*
jni
const
VideoBitrateAllocation
&
allocation
)
;
void
UpdateEncoderInfo
(
JNIEnv
*
jni
)
;
ScalingSettings
GetScalingSettingsInternal
(
JNIEnv
*
jni
)
const
;
std
:
:
vector
<
ResolutionBitrateLimits
>
GetResolutionBitrateLimits
(
JNIEnv
*
jni
)
const
;
const
ScopedJavaGlobalRef
<
jobject
>
encoder_
;
const
ScopedJavaGlobalRef
<
jclass
>
int_array_class_
;
Mutex
frame_extra_infos_lock_
;
std
:
:
deque
<
FrameExtraInfo
>
frame_extra_infos_
RTC_GUARDED_BY
(
frame_extra_infos_lock_
)
;
EncodedImageCallback
*
callback_
;
bool
initialized_
;
int
num_resets_
;
absl
:
:
optional
<
VideoEncoder
:
:
Capabilities
>
capabilities_
;
int
number_of_cores_
;
VideoCodec
codec_settings_
;
EncoderInfo
encoder_info_
;
H264BitstreamParser
h264_bitstream_parser_
;
ScalableVideoControllerNoLayering
svc_controller_
;
GofInfoVP9
gof_
;
size_t
gof_idx_
;
}
;
std
:
:
unique_ptr
<
VideoEncoder
>
JavaToNativeVideoEncoder
(
JNIEnv
*
jni
const
JavaRef
<
jobject
>
&
j_encoder
)
;
bool
IsHardwareVideoEncoder
(
JNIEnv
*
jni
const
JavaRef
<
jobject
>
&
j_encoder
)
;
std
:
:
vector
<
VideoEncoder
:
:
ResolutionBitrateLimits
>
JavaToNativeResolutionBitrateLimits
(
JNIEnv
*
jni
const
JavaRef
<
jobjectArray
>
&
j_bitrate_limits_array
)
;
}
}
#
endif
