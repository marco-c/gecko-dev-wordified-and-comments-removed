#
import
<
XCTest
/
XCTest
.
h
>
#
if
defined
(
WEBRTC_IOS
)
#
import
"
sdk
/
objc
/
native
/
api
/
audio_device_module
.
h
"
#
endif
#
include
"
api
/
scoped_refptr
.
h
"
typedef
int32_t
(
^
NeedMorePlayDataBlock
)
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
;
typedef
int32_t
(
^
RecordedDataIsAvailableBlock
)
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
;
class
MockAudioTransport
:
public
webrtc
:
:
AudioTransport
{
public
:
MockAudioTransport
(
)
{
}
~
MockAudioTransport
(
)
override
{
}
void
expectNeedMorePlayData
(
NeedMorePlayDataBlock
block
)
{
needMorePlayDataBlock
=
block
;
}
void
expectRecordedDataIsAvailable
(
RecordedDataIsAvailableBlock
block
)
{
recordedDataIsAvailableBlock
=
block
;
}
int32_t
NeedMorePlayData
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
override
{
return
needMorePlayDataBlock
(
nSamples
nBytesPerSample
nChannels
samplesPerSec
audioSamples
nSamplesOut
elapsed_time_ms
ntp_time_ms
)
;
}
int32_t
RecordedDataIsAvailable
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
override
{
return
recordedDataIsAvailableBlock
(
audioSamples
nSamples
nBytesPerSample
nChannels
samplesPerSec
totalDelayMS
clockDrift
currentMicLevel
keyPressed
newMicLevel
)
;
}
void
PullRenderData
(
int
bits_per_sample
int
sample_rate
size_t
number_of_channels
size_t
number_of_frames
void
*
audio_data
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
override
{
}
private
:
NeedMorePlayDataBlock
needMorePlayDataBlock
;
RecordedDataIsAvailableBlock
recordedDataIsAvailableBlock
;
}
;
static
const
NSUInteger
kNumCallbacks
=
10
;
static
const
NSTimeInterval
kTestTimeOutInSec
=
20
.
0
;
static
const
NSUInteger
kBitsPerSample
=
16
;
static
const
NSUInteger
kBytesPerSample
=
kBitsPerSample
/
8
;
static
const
NSUInteger
kNumCallbacksPerSecond
=
100
;
static
const
NSUInteger
kFilePlayTimeInSec
=
15
;
static
const
NSUInteger
kFullDuplexTimeInSec
=
10
;
static
const
NSUInteger
kNumIgnoreFirstCallbacks
=
50
;
interface
RTCAudioDeviceModuleTests
:
XCTestCase
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDeviceModule
>
audioDeviceModule
;
MockAudioTransport
mock
;
}
property
(
nonatomic
assign
)
webrtc
:
:
AudioParameters
playoutParameters
;
property
(
nonatomic
assign
)
webrtc
:
:
AudioParameters
recordParameters
;
end
implementation
RTCAudioDeviceModuleTests
synthesize
playoutParameters
;
synthesize
recordParameters
;
-
(
void
)
setUp
{
[
super
setUp
]
;
audioDeviceModule
=
webrtc
:
:
CreateAudioDeviceModule
(
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
Init
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
GetPlayoutAudioParameters
(
&
playoutParameters
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
GetRecordAudioParameters
(
&
recordParameters
)
)
;
}
-
(
void
)
tearDown
{
XCTAssertEqual
(
0
audioDeviceModule
-
>
Terminate
(
)
)
;
audioDeviceModule
=
nullptr
;
[
super
tearDown
]
;
}
-
(
void
)
startPlayout
{
XCTAssertFalse
(
audioDeviceModule
-
>
Playing
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
InitPlayout
(
)
)
;
XCTAssertTrue
(
audioDeviceModule
-
>
PlayoutIsInitialized
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
StartPlayout
(
)
)
;
XCTAssertTrue
(
audioDeviceModule
-
>
Playing
(
)
)
;
}
-
(
void
)
stopPlayout
{
XCTAssertEqual
(
0
audioDeviceModule
-
>
StopPlayout
(
)
)
;
XCTAssertFalse
(
audioDeviceModule
-
>
Playing
(
)
)
;
}
-
(
void
)
startRecording
{
XCTAssertFalse
(
audioDeviceModule
-
>
Recording
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
InitRecording
(
)
)
;
XCTAssertTrue
(
audioDeviceModule
-
>
RecordingIsInitialized
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
StartRecording
(
)
)
;
XCTAssertTrue
(
audioDeviceModule
-
>
Recording
(
)
)
;
}
-
(
void
)
stopRecording
{
XCTAssertEqual
(
0
audioDeviceModule
-
>
StopRecording
(
)
)
;
XCTAssertFalse
(
audioDeviceModule
-
>
Recording
(
)
)
;
}
-
(
NSURL
*
)
fileURLForSampleRate
:
(
int
)
sampleRate
{
XCTAssertTrue
(
sampleRate
=
=
48000
|
|
sampleRate
=
=
44100
|
|
sampleRate
=
=
16000
)
;
NSString
*
filename
=
[
NSString
stringWithFormat
:
"
audio_short
%
d
"
sampleRate
/
1000
]
;
NSURL
*
url
=
[
[
NSBundle
mainBundle
]
URLForResource
:
filename
withExtension
:
"
pcm
"
]
;
XCTAssertNotNil
(
url
)
;
return
url
;
}
#
pragma
mark
-
Tests
-
(
void
)
testConstructDestruct
{
}
-
(
void
)
testInitTerminate
{
XCTAssertTrue
(
audioDeviceModule
-
>
Initialized
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
Terminate
(
)
)
;
XCTAssertFalse
(
audioDeviceModule
-
>
Initialized
(
)
)
;
}
-
(
void
)
testStartStopPlayout
{
[
self
startPlayout
]
;
[
self
stopPlayout
]
;
[
self
startPlayout
]
;
[
self
stopPlayout
]
;
}
-
(
void
)
testStartStopRecording
{
[
self
startRecording
]
;
[
self
stopRecording
]
;
[
self
startRecording
]
;
[
self
stopRecording
]
;
}
-
(
void
)
testStopPlayoutRequiresInitToRestart
{
XCTAssertEqual
(
0
audioDeviceModule
-
>
InitPlayout
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
StartPlayout
(
)
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
StopPlayout
(
)
)
;
XCTAssertFalse
(
audioDeviceModule
-
>
PlayoutIsInitialized
(
)
)
;
}
-
(
void
)
testStartPlayoutOnTwoInstances
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDeviceModule
>
secondAudioDeviceModule
=
webrtc
:
:
CreateAudioDeviceModule
(
)
;
XCTAssertNotEqual
(
secondAudioDeviceModule
.
get
(
)
nullptr
)
;
XCTAssertEqual
(
0
secondAudioDeviceModule
-
>
Init
(
)
)
;
mock
.
expectNeedMorePlayData
(
^
int32_t
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
nSamplesOut
=
nSamples
;
XCTAssertEqual
(
nSamples
self
.
playoutParameters
.
frames_per_10ms_buffer
(
)
)
;
XCTAssertEqual
(
nBytesPerSample
kBytesPerSample
)
;
XCTAssertEqual
(
nChannels
self
.
playoutParameters
.
channels
(
)
)
;
XCTAssertEqual
(
(
int
)
samplesPerSec
self
.
playoutParameters
.
sample_rate
(
)
)
;
XCTAssertNotEqual
(
(
void
*
)
NULL
audioSamples
)
;
return
0
;
}
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
RegisterAudioCallback
(
&
mock
)
)
;
[
self
startPlayout
]
;
XCTAssertEqual
(
0
secondAudioDeviceModule
-
>
InitPlayout
(
)
)
;
XCTAssertTrue
(
secondAudioDeviceModule
-
>
PlayoutIsInitialized
(
)
)
;
XCTestExpectation
*
playoutExpectation
=
[
self
expectationWithDescription
:
"
NeedMorePlayoutData
"
]
;
__block
int
num_callbacks
=
0
;
MockAudioTransport
mock2
;
mock2
.
expectNeedMorePlayData
(
^
int32_t
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
nSamplesOut
=
nSamples
;
XCTAssertEqual
(
nSamples
self
.
playoutParameters
.
frames_per_10ms_buffer
(
)
)
;
XCTAssertEqual
(
nBytesPerSample
kBytesPerSample
)
;
XCTAssertEqual
(
nChannels
self
.
playoutParameters
.
channels
(
)
)
;
XCTAssertEqual
(
(
int
)
samplesPerSec
self
.
playoutParameters
.
sample_rate
(
)
)
;
XCTAssertNotEqual
(
(
void
*
)
NULL
audioSamples
)
;
if
(
+
+
num_callbacks
=
=
kNumCallbacks
)
{
[
playoutExpectation
fulfill
]
;
}
return
0
;
}
)
;
XCTAssertEqual
(
0
secondAudioDeviceModule
-
>
RegisterAudioCallback
(
&
mock2
)
)
;
XCTAssertEqual
(
0
secondAudioDeviceModule
-
>
StartPlayout
(
)
)
;
XCTAssertTrue
(
secondAudioDeviceModule
-
>
Playing
(
)
)
;
[
self
waitForExpectationsWithTimeout
:
kTestTimeOutInSec
handler
:
nil
]
;
[
self
stopPlayout
]
;
XCTAssertEqual
(
0
secondAudioDeviceModule
-
>
StopPlayout
(
)
)
;
XCTAssertFalse
(
secondAudioDeviceModule
-
>
Playing
(
)
)
;
XCTAssertFalse
(
secondAudioDeviceModule
-
>
PlayoutIsInitialized
(
)
)
;
XCTAssertEqual
(
0
secondAudioDeviceModule
-
>
Terminate
(
)
)
;
}
-
(
void
)
testStartPlayoutVerifyCallbacks
{
XCTestExpectation
*
playoutExpectation
=
[
self
expectationWithDescription
:
"
NeedMorePlayoutData
"
]
;
__block
int
num_callbacks
=
0
;
mock
.
expectNeedMorePlayData
(
^
int32_t
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
nSamplesOut
=
nSamples
;
XCTAssertEqual
(
nSamples
self
.
playoutParameters
.
frames_per_10ms_buffer
(
)
)
;
XCTAssertEqual
(
nBytesPerSample
kBytesPerSample
)
;
XCTAssertEqual
(
nChannels
self
.
playoutParameters
.
channels
(
)
)
;
XCTAssertEqual
(
(
int
)
samplesPerSec
self
.
playoutParameters
.
sample_rate
(
)
)
;
XCTAssertNotEqual
(
(
void
*
)
NULL
audioSamples
)
;
if
(
+
+
num_callbacks
=
=
kNumCallbacks
)
{
[
playoutExpectation
fulfill
]
;
}
return
0
;
}
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
RegisterAudioCallback
(
&
mock
)
)
;
[
self
startPlayout
]
;
[
self
waitForExpectationsWithTimeout
:
kTestTimeOutInSec
handler
:
nil
]
;
[
self
stopPlayout
]
;
}
-
(
void
)
testStartRecordingVerifyCallbacks
{
XCTestExpectation
*
recordExpectation
=
[
self
expectationWithDescription
:
"
RecordedDataIsAvailable
"
]
;
__block
int
num_callbacks
=
0
;
mock
.
expectRecordedDataIsAvailable
(
^
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
{
XCTAssertNotEqual
(
(
void
*
)
NULL
audioSamples
)
;
XCTAssertEqual
(
nSamples
self
.
recordParameters
.
frames_per_10ms_buffer
(
)
)
;
XCTAssertEqual
(
nBytesPerSample
kBytesPerSample
)
;
XCTAssertEqual
(
nChannels
self
.
recordParameters
.
channels
(
)
)
;
XCTAssertEqual
(
(
int
)
samplesPerSec
self
.
recordParameters
.
sample_rate
(
)
)
;
XCTAssertEqual
(
0
clockDrift
)
;
XCTAssertEqual
(
0u
currentMicLevel
)
;
XCTAssertFalse
(
keyPressed
)
;
if
(
+
+
num_callbacks
=
=
kNumCallbacks
)
{
[
recordExpectation
fulfill
]
;
}
return
0
;
}
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
RegisterAudioCallback
(
&
mock
)
)
;
[
self
startRecording
]
;
[
self
waitForExpectationsWithTimeout
:
kTestTimeOutInSec
handler
:
nil
]
;
[
self
stopRecording
]
;
}
-
(
void
)
testStartPlayoutAndRecordingVerifyCallbacks
{
XCTestExpectation
*
playoutExpectation
=
[
self
expectationWithDescription
:
"
NeedMorePlayoutData
"
]
;
__block
NSUInteger
callbackCount
=
0
;
XCTestExpectation
*
recordExpectation
=
[
self
expectationWithDescription
:
"
RecordedDataIsAvailable
"
]
;
recordExpectation
.
expectedFulfillmentCount
=
kNumCallbacks
;
mock
.
expectNeedMorePlayData
(
^
int32_t
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
nSamplesOut
=
nSamples
;
XCTAssertEqual
(
nSamples
self
.
playoutParameters
.
frames_per_10ms_buffer
(
)
)
;
XCTAssertEqual
(
nBytesPerSample
kBytesPerSample
)
;
XCTAssertEqual
(
nChannels
self
.
playoutParameters
.
channels
(
)
)
;
XCTAssertEqual
(
(
int
)
samplesPerSec
self
.
playoutParameters
.
sample_rate
(
)
)
;
XCTAssertNotEqual
(
(
void
*
)
NULL
audioSamples
)
;
if
(
callbackCount
+
+
>
=
kNumCallbacks
)
{
[
playoutExpectation
fulfill
]
;
}
return
0
;
}
)
;
mock
.
expectRecordedDataIsAvailable
(
^
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
{
XCTAssertNotEqual
(
(
void
*
)
NULL
audioSamples
)
;
XCTAssertEqual
(
nSamples
self
.
recordParameters
.
frames_per_10ms_buffer
(
)
)
;
XCTAssertEqual
(
nBytesPerSample
kBytesPerSample
)
;
XCTAssertEqual
(
nChannels
self
.
recordParameters
.
channels
(
)
)
;
XCTAssertEqual
(
(
int
)
samplesPerSec
self
.
recordParameters
.
sample_rate
(
)
)
;
XCTAssertEqual
(
0
clockDrift
)
;
XCTAssertEqual
(
0u
currentMicLevel
)
;
XCTAssertFalse
(
keyPressed
)
;
[
recordExpectation
fulfill
]
;
return
0
;
}
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
RegisterAudioCallback
(
&
mock
)
)
;
[
self
startPlayout
]
;
[
self
startRecording
]
;
[
self
waitForExpectationsWithTimeout
:
kTestTimeOutInSec
handler
:
nil
]
;
[
self
stopRecording
]
;
[
self
stopPlayout
]
;
}
-
(
void
)
testRunPlayoutWithFileAsSource
{
XCTAssertEqual
(
1u
playoutParameters
.
channels
(
)
)
;
XCTestExpectation
*
playoutExpectation
=
[
self
expectationWithDescription
:
"
NeedMorePlayoutData
"
]
;
const
int
expectedCallbackCount
=
kFilePlayTimeInSec
*
kNumCallbacksPerSecond
;
__block
int
callbackCount
=
0
;
NSURL
*
fileURL
=
[
self
fileURLForSampleRate
:
playoutParameters
.
sample_rate
(
)
]
;
NSInputStream
*
inputStream
=
[
[
NSInputStream
alloc
]
initWithURL
:
fileURL
]
;
mock
.
expectNeedMorePlayData
(
^
int32_t
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
[
inputStream
read
:
(
uint8_t
*
)
audioSamples
maxLength
:
nSamples
*
nBytesPerSample
*
nChannels
]
;
nSamplesOut
=
nSamples
;
if
(
callbackCount
+
+
=
=
expectedCallbackCount
)
{
[
playoutExpectation
fulfill
]
;
}
return
0
;
}
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
RegisterAudioCallback
(
&
mock
)
)
;
[
self
startPlayout
]
;
NSTimeInterval
waitTimeout
=
kFilePlayTimeInSec
*
2
.
0
;
[
self
waitForExpectationsWithTimeout
:
waitTimeout
handler
:
nil
]
;
[
self
stopPlayout
]
;
}
-
(
void
)
testDevices
{
XCTAssertEqual
(
1
audioDeviceModule
-
>
PlayoutDevices
(
)
)
;
XCTAssertEqual
(
1
audioDeviceModule
-
>
RecordingDevices
(
)
)
;
}
-
(
void
)
testRunPlayoutAndRecordingInFullDuplex
{
XCTAssertEqual
(
recordParameters
.
channels
(
)
playoutParameters
.
channels
(
)
)
;
XCTAssertEqual
(
recordParameters
.
sample_rate
(
)
playoutParameters
.
sample_rate
(
)
)
;
XCTestExpectation
*
playoutExpectation
=
[
self
expectationWithDescription
:
"
NeedMorePlayoutData
"
]
;
__block
NSUInteger
playoutCallbacks
=
0
;
NSUInteger
expectedPlayoutCallbacks
=
kFullDuplexTimeInSec
*
kNumCallbacksPerSecond
;
NSMutableArray
*
fifoBuffer
=
[
NSMutableArray
arrayWithCapacity
:
20
]
;
__block
NSUInteger
fifoMaxSize
=
0
;
__block
NSUInteger
fifoTotalWrittenElements
=
0
;
__block
NSUInteger
fifoWriteCount
=
0
;
mock
.
expectRecordedDataIsAvailable
(
^
(
const
void
*
audioSamples
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
const
uint32_t
totalDelayMS
const
int32_t
clockDrift
const
uint32_t
currentMicLevel
const
bool
keyPressed
uint32_t
&
newMicLevel
)
{
if
(
fifoWriteCount
+
+
<
kNumIgnoreFirstCallbacks
)
{
return
0
;
}
NSData
*
data
=
[
NSData
dataWithBytes
:
audioSamples
length
:
nSamples
*
nBytesPerSample
*
nChannels
]
;
synchronized
(
fifoBuffer
)
{
[
fifoBuffer
addObject
:
data
]
;
fifoMaxSize
=
MAX
(
fifoMaxSize
fifoBuffer
.
count
)
;
fifoTotalWrittenElements
+
=
fifoBuffer
.
count
;
}
return
0
;
}
)
;
mock
.
expectNeedMorePlayData
(
^
int32_t
(
const
size_t
nSamples
const
size_t
nBytesPerSample
const
size_t
nChannels
const
uint32_t
samplesPerSec
void
*
audioSamples
size_t
&
nSamplesOut
int64_t
*
elapsed_time_ms
int64_t
*
ntp_time_ms
)
{
nSamplesOut
=
nSamples
;
NSData
*
data
;
synchronized
(
fifoBuffer
)
{
data
=
fifoBuffer
.
firstObject
;
if
(
data
)
{
[
fifoBuffer
removeObjectAtIndex
:
0
]
;
}
}
if
(
data
)
{
memcpy
(
audioSamples
(
char
*
)
data
.
bytes
data
.
length
)
;
}
else
{
memset
(
audioSamples
0
nSamples
*
nBytesPerSample
*
nChannels
)
;
}
if
(
playoutCallbacks
+
+
=
=
expectedPlayoutCallbacks
)
{
[
playoutExpectation
fulfill
]
;
}
return
0
;
}
)
;
XCTAssertEqual
(
0
audioDeviceModule
-
>
RegisterAudioCallback
(
&
mock
)
)
;
[
self
startRecording
]
;
[
self
startPlayout
]
;
NSTimeInterval
waitTimeout
=
kFullDuplexTimeInSec
*
2
.
0
;
[
self
waitForExpectationsWithTimeout
:
waitTimeout
handler
:
nil
]
;
size_t
fifoAverageSize
=
(
fifoTotalWrittenElements
=
=
0
)
?
0
.
0
:
0
.
5
+
(
double
)
fifoTotalWrittenElements
/
(
fifoWriteCount
-
kNumIgnoreFirstCallbacks
)
;
[
self
stopPlayout
]
;
[
self
stopRecording
]
;
XCTAssertLessThan
(
fifoAverageSize
10u
)
;
XCTAssertLessThan
(
fifoMaxSize
20u
)
;
}
end
