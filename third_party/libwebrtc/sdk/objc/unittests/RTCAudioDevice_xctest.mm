#
import
<
XCTest
/
XCTest
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
environment
/
environment_factory
.
h
"
#
include
"
api
/
task_queue
/
default_task_queue_factory
.
h
"
#
import
"
sdk
/
objc
/
components
/
audio
/
RTCAudioSession
+
Private
.
h
"
#
import
"
sdk
/
objc
/
native
/
api
/
audio_device_module
.
h
"
#
import
"
sdk
/
objc
/
native
/
src
/
audio
/
audio_device_ios
.
h
"
interface
RTCAudioDeviceTests
:
XCTestCase
{
bool
_testEnabled
;
webrtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDeviceModule
>
_audioDeviceModule
;
std
:
:
unique_ptr
<
webrtc
:
:
ios_adm
:
:
AudioDeviceIOS
>
_audio_device
;
}
property
(
nonatomic
)
RTC_OBJC_TYPE
(
RTCAudioSession
)
*
audioSession
;
end
implementation
RTCAudioDeviceTests
synthesize
audioSession
=
_audioSession
;
-
(
void
)
setUp
{
[
super
setUp
]
;
#
if
defined
(
WEBRTC_IOS
)
&
&
TARGET_OS_SIMULATOR
_testEnabled
=
false
;
if
(
:
:
getenv
(
"
WEBRTC_IOS_RUN_AUDIO_TESTS
"
)
!
=
nullptr
)
{
_testEnabled
=
true
;
}
#
else
_testEnabled
=
true
;
#
endif
webrtc
:
:
Environment
env
=
webrtc
:
:
CreateEnvironment
(
)
;
_audioDeviceModule
=
webrtc
:
:
CreateAudioDeviceModule
(
env
)
;
_audio_device
.
reset
(
new
webrtc
:
:
ios_adm
:
:
AudioDeviceIOS
(
env
false
nullptr
nullptr
)
)
;
self
.
audioSession
=
[
RTC_OBJC_TYPE
(
RTCAudioSession
)
sharedInstance
]
;
NSError
*
error
=
nil
;
[
self
.
audioSession
lockForConfiguration
]
;
[
self
.
audioSession
setCategory
:
AVAudioSessionCategoryPlayAndRecord
withOptions
:
0
error
:
&
error
]
;
XCTAssertNil
(
error
)
;
[
self
.
audioSession
setMode
:
AVAudioSessionModeVoiceChat
error
:
&
error
]
;
XCTAssertNil
(
error
)
;
[
self
.
audioSession
setActive
:
YES
error
:
&
error
]
;
XCTAssertNil
(
error
)
;
[
self
.
audioSession
unlockForConfiguration
]
;
}
-
(
void
)
tearDown
{
_audio_device
-
>
Terminate
(
)
;
_audio_device
.
reset
(
nullptr
)
;
_audioDeviceModule
=
nullptr
;
[
self
.
audioSession
notifyDidEndInterruptionWithShouldResumeSession
:
NO
]
;
[
super
tearDown
]
;
}
-
(
void
)
testInterruptedAudioSession
{
XCTSkipIf
(
!
_testEnabled
)
;
XCTAssertTrue
(
self
.
audioSession
.
isActive
)
;
XCTAssertTrue
(
[
self
.
audioSession
.
category
isEqual
:
AVAudioSessionCategoryPlayAndRecord
]
|
|
[
self
.
audioSession
.
category
isEqual
:
AVAudioSessionCategoryPlayback
]
)
;
XCTAssertEqual
(
AVAudioSessionModeVoiceChat
self
.
audioSession
.
mode
)
;
std
:
:
unique_ptr
<
webrtc
:
:
TaskQueueFactory
>
task_queue_factory
=
webrtc
:
:
CreateDefaultTaskQueueFactory
(
)
;
std
:
:
unique_ptr
<
webrtc
:
:
AudioDeviceBuffer
>
audio_buffer
;
audio_buffer
.
reset
(
new
webrtc
:
:
AudioDeviceBuffer
(
task_queue_factory
.
get
(
)
)
)
;
_audio_device
-
>
AttachAudioBuffer
(
audio_buffer
.
get
(
)
)
;
XCTAssertEqual
(
webrtc
:
:
AudioDeviceGeneric
:
:
InitStatus
:
:
OK
_audio_device
-
>
Init
(
)
)
;
XCTAssertEqual
(
0
_audio_device
-
>
InitPlayout
(
)
)
;
XCTAssertEqual
(
0
_audio_device
-
>
StartPlayout
(
)
)
;
[
self
.
audioSession
notifyDidBeginInterruption
]
;
webrtc
:
:
ThreadManager
:
:
ProcessAllMessageQueuesForTesting
(
)
;
XCTAssertTrue
(
_audio_device
-
>
IsInterrupted
(
)
)
;
_audio_device
-
>
StopPlayout
(
)
;
[
self
.
audioSession
notifyDidEndInterruptionWithShouldResumeSession
:
YES
]
;
webrtc
:
:
ThreadManager
:
:
ProcessAllMessageQueuesForTesting
(
)
;
XCTAssertTrue
(
_audio_device
-
>
IsInterrupted
(
)
)
;
_audio_device
-
>
Init
(
)
;
_audio_device
-
>
InitPlayout
(
)
;
XCTAssertFalse
(
_audio_device
-
>
IsInterrupted
(
)
)
;
}
-
(
void
)
testMuteSpeechHandlerCalledWithStartedWhenSpeechActivityHasStarted
{
XCTestExpectation
*
handlerExpectation
=
[
self
expectationWithDescription
:
"
mutedSpeechHandler
"
]
;
webrtc
:
:
AudioDeviceModule
:
:
MutedSpeechEventHandler
muted_speech_event_handler
=
^
void
(
webrtc
:
:
AudioDeviceModule
:
:
MutedSpeechEvent
event
)
{
XCTAssertEqual
(
event
webrtc
:
:
AudioDeviceModule
:
:
kMutedSpeechStarted
)
;
[
handlerExpectation
fulfill
]
;
}
;
_audio_device
.
reset
(
new
webrtc
:
:
ios_adm
:
:
AudioDeviceIOS
(
webrtc
:
:
CreateEnvironment
(
)
false
muted_speech_event_handler
nullptr
)
)
;
_audio_device
-
>
OnReceivedMutedSpeechActivity
(
kAUVoiceIOSpeechActivityHasStarted
)
;
[
self
waitForExpectations
:
[
handlerExpectation
]
timeout
:
10
.
0
]
;
}
-
(
void
)
testMuteSpeechHandlerCalledWithEndedWhenSpeechActivityHasEnded
{
XCTestExpectation
*
handlerExpectation
=
[
self
expectationWithDescription
:
"
mutedSpeechHandler
"
]
;
webrtc
:
:
AudioDeviceModule
:
:
MutedSpeechEventHandler
muted_speech_event_handler
=
^
void
(
webrtc
:
:
AudioDeviceModule
:
:
MutedSpeechEvent
event
)
{
XCTAssertEqual
(
event
webrtc
:
:
AudioDeviceModule
:
:
kMutedSpeechEnded
)
;
[
handlerExpectation
fulfill
]
;
}
;
_audio_device
.
reset
(
new
webrtc
:
:
ios_adm
:
:
AudioDeviceIOS
(
webrtc
:
:
CreateEnvironment
(
)
false
muted_speech_event_handler
nullptr
)
)
;
_audio_device
-
>
OnReceivedMutedSpeechActivity
(
kAUVoiceIOSpeechActivityHasEnded
)
;
[
self
waitForExpectations
:
[
handlerExpectation
]
timeout
:
10
.
0
]
;
}
end
