#
include
"
net
/
dcsctp
/
rx
/
data_tracker
.
h
"
#
include
<
cstdint
>
#
include
<
iterator
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
net
/
dcsctp
/
common
/
sequence_numbers
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
sack_chunk
.
h
"
#
include
"
net
/
dcsctp
/
timer
/
timer
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
namespace
dcsctp
{
void
DataTracker
:
:
Observe
(
TSN
tsn
AnyDataChunk
:
:
ImmediateAckFlag
immediate_ack
)
{
UnwrappedTSN
unwrapped_tsn
=
tsn_unwrapper_
.
Unwrap
(
tsn
)
;
if
(
unwrapped_tsn
<
=
last_cumulative_acked_tsn_
)
{
return
;
}
if
(
unwrapped_tsn
=
=
last_cumulative_acked_tsn_
.
next_value
(
)
)
{
last_cumulative_acked_tsn_
=
unwrapped_tsn
;
while
(
!
additional_tsns
.
empty
(
)
&
&
*
additional_tsns
.
begin
(
)
=
=
last_cumulative_acked_tsn_
.
next_value
(
)
)
{
last_cumulative_acked_tsn_
.
Increment
(
)
;
additional_tsns
.
erase
(
additional_tsns
.
begin
(
)
)
;
}
}
else
{
additional_tsns
.
insert
(
unwrapped_tsn
)
;
}
if
(
!
additional_tsns
.
empty
(
)
)
{
UpdateAckState
(
AckState
:
:
kImmediate
"
packet
loss
"
)
;
}
if
(
*
immediate_ack
)
{
UpdateAckState
(
AckState
:
:
kImmediate
"
immediate
-
ack
bit
set
"
)
;
}
if
(
!
seen_packet_
)
{
seen_packet_
=
true
;
UpdateAckState
(
AckState
:
:
kImmediate
"
first
DATA
chunk
"
)
;
}
if
(
ack_state_
=
=
AckState
:
:
kIdle
)
{
UpdateAckState
(
AckState
:
:
kBecomingDelayed
"
received
DATA
when
idle
"
)
;
}
else
if
(
ack_state_
=
=
AckState
:
:
kDelayed
)
{
UpdateAckState
(
AckState
:
:
kImmediate
"
received
DATA
when
already
delayed
"
)
;
}
}
void
DataTracker
:
:
HandleForwardTsn
(
TSN
new_cumulative_ack
)
{
UnwrappedTSN
unwrapped_tsn
=
tsn_unwrapper_
.
Unwrap
(
new_cumulative_ack
)
;
UnwrappedTSN
prev_last_cum_ack_tsn
=
last_cumulative_acked_tsn_
;
if
(
unwrapped_tsn
<
=
last_cumulative_acked_tsn_
)
{
UpdateAckState
(
AckState
:
:
kImmediate
"
FORWARD_TSN
new_cumulative_tsn
was
behind
"
)
;
return
;
}
last_cumulative_acked_tsn_
=
unwrapped_tsn
;
int
erased_additional_tsns
=
std
:
:
distance
(
additional_tsns
.
begin
(
)
additional_tsns
.
upper_bound
(
unwrapped_tsn
)
)
;
additional_tsns
.
erase
(
additional_tsns
.
begin
(
)
additional_tsns
.
upper_bound
(
unwrapped_tsn
)
)
;
while
(
!
additional_tsns
.
empty
(
)
&
&
*
additional_tsns
.
begin
(
)
=
=
last_cumulative_acked_tsn_
.
next_value
(
)
)
{
last_cumulative_acked_tsn_
.
Increment
(
)
;
additional_tsns
.
erase
(
additional_tsns
.
begin
(
)
)
;
+
+
erased_additional_tsns
;
}
RTC_DLOG
(
LS_VERBOSE
)
<
<
log_prefix_
<
<
"
FORWARD_TSN
cum_ack_tsn
=
"
<
<
*
prev_last_cum_ack_tsn
.
Wrap
(
)
<
<
"
-
>
"
<
<
*
new_cumulative_ack
<
<
"
-
>
"
<
<
*
last_cumulative_acked_tsn_
.
Wrap
(
)
<
<
"
removed
"
<
<
erased_additional_tsns
<
<
"
additional
TSNs
"
;
if
(
ack_state_
=
=
AckState
:
:
kIdle
)
{
UpdateAckState
(
AckState
:
:
kBecomingDelayed
"
received
FORWARD_TSN
when
idle
"
)
;
}
else
if
(
ack_state_
=
=
AckState
:
:
kDelayed
)
{
UpdateAckState
(
AckState
:
:
kImmediate
"
received
FORWARD_TSN
when
already
delayed
"
)
;
}
}
SackChunk
DataTracker
:
:
CreateSelectiveAck
(
size_t
a_rwnd
)
{
std
:
:
vector
<
TSN
>
duplicate_tsns
;
duplicate_tsns
.
reserve
(
duplicates_
.
size
(
)
)
;
for
(
UnwrappedTSN
tsn
:
duplicates_
)
{
duplicate_tsns
.
push_back
(
tsn
.
Wrap
(
)
)
;
}
duplicates_
.
clear
(
)
;
return
SackChunk
(
last_cumulative_acked_tsn_
.
Wrap
(
)
a_rwnd
CreateGapAckBlocks
(
)
duplicate_tsns
)
;
}
std
:
:
vector
<
SackChunk
:
:
GapAckBlock
>
DataTracker
:
:
CreateGapAckBlocks
(
)
const
{
std
:
:
vector
<
SackChunk
:
:
GapAckBlock
>
gap_ack_blocks
;
absl
:
:
optional
<
UnwrappedTSN
>
first_tsn_in_block
=
absl
:
:
nullopt
;
absl
:
:
optional
<
UnwrappedTSN
>
last_tsn_in_block
=
absl
:
:
nullopt
;
auto
flush
=
[
&
]
(
)
{
if
(
first_tsn_in_block
.
has_value
(
)
)
{
int
start_diff
=
first_tsn_in_block
-
>
Difference
(
last_cumulative_acked_tsn_
)
;
int
end_diff
=
last_tsn_in_block
-
>
Difference
(
last_cumulative_acked_tsn_
)
;
gap_ack_blocks
.
emplace_back
(
static_cast
<
uint16_t
>
(
start_diff
)
static_cast
<
uint16_t
>
(
end_diff
)
)
;
first_tsn_in_block
=
absl
:
:
nullopt
;
last_tsn_in_block
=
absl
:
:
nullopt
;
}
}
;
for
(
UnwrappedTSN
tsn
:
additional_tsns
)
{
if
(
last_tsn_in_block
.
has_value
(
)
&
&
last_tsn_in_block
-
>
next_value
(
)
=
=
tsn
)
{
last_tsn_in_block
=
tsn
;
}
else
{
flush
(
)
;
first_tsn_in_block
=
tsn
;
last_tsn_in_block
=
tsn
;
}
}
flush
(
)
;
return
gap_ack_blocks
;
}
bool
DataTracker
:
:
ShouldSendAck
(
bool
also_if_delayed
)
{
if
(
ack_state_
=
=
AckState
:
:
kImmediate
|
|
(
also_if_delayed
&
&
(
ack_state_
=
=
AckState
:
:
kBecomingDelayed
|
|
ack_state_
=
=
AckState
:
:
kDelayed
)
)
)
{
UpdateAckState
(
AckState
:
:
kIdle
"
sending
SACK
"
)
;
return
true
;
}
return
false
;
}
bool
DataTracker
:
:
will_increase_cum_ack_tsn
(
TSN
tsn
)
const
{
UnwrappedTSN
unwrapped
=
tsn_unwrapper_
.
PeekUnwrap
(
tsn
)
;
return
unwrapped
=
=
last_cumulative_acked_tsn_
.
next_value
(
)
;
}
void
DataTracker
:
:
ForceImmediateSack
(
)
{
ack_state_
=
AckState
:
:
kImmediate
;
}
void
DataTracker
:
:
HandleDelayedAckTimerExpiry
(
)
{
UpdateAckState
(
AckState
:
:
kImmediate
"
delayed
ack
timer
expired
"
)
;
}
void
DataTracker
:
:
ObservePacketEnd
(
)
{
if
(
ack_state_
=
=
AckState
:
:
kBecomingDelayed
)
{
UpdateAckState
(
AckState
:
:
kDelayed
"
packet
end
"
)
;
}
}
void
DataTracker
:
:
UpdateAckState
(
AckState
new_state
absl
:
:
string_view
reason
)
{
if
(
new_state
!
=
ack_state_
)
{
RTC_DLOG
(
LS_VERBOSE
)
<
<
log_prefix_
<
<
"
State
changed
from
"
<
<
ToString
(
ack_state_
)
<
<
"
to
"
<
<
ToString
(
new_state
)
<
<
"
due
to
"
<
<
reason
;
if
(
ack_state_
=
=
AckState
:
:
kDelayed
)
{
delayed_ack_timer_
.
Stop
(
)
;
}
else
if
(
new_state
=
=
AckState
:
:
kDelayed
)
{
delayed_ack_timer_
.
Start
(
)
;
}
ack_state_
=
new_state
;
}
}
absl
:
:
string_view
DataTracker
:
:
ToString
(
AckState
ack_state
)
{
switch
(
ack_state
)
{
case
AckState
:
:
kIdle
:
return
"
IDLE
"
;
case
AckState
:
:
kBecomingDelayed
:
return
"
BECOMING_DELAYED
"
;
case
AckState
:
:
kDelayed
:
return
"
DELAYED
"
;
case
AckState
:
:
kImmediate
:
return
"
IMMEDIATE
"
;
}
}
}
