#
ifndef
NET_DCSCTP_RX_DATA_TRACKER_H_
#
define
NET_DCSCTP_RX_DATA_TRACKER_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
cstdint
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
net
/
dcsctp
/
common
/
sequence_numbers
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
data_common
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
sack_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
data
.
h
"
#
include
"
net
/
dcsctp
/
timer
/
timer
.
h
"
namespace
dcsctp
{
class
DataTracker
{
public
:
explicit
DataTracker
(
absl
:
:
string_view
log_prefix
Timer
*
delayed_ack_timer
TSN
peer_initial_tsn
)
:
log_prefix_
(
std
:
:
string
(
log_prefix
)
+
"
dtrack
:
"
)
delayed_ack_timer_
(
*
delayed_ack_timer
)
last_cumulative_acked_tsn_
(
tsn_unwrapper_
.
Unwrap
(
TSN
(
*
peer_initial_tsn
-
1
)
)
)
{
}
void
Observe
(
TSN
tsn
AnyDataChunk
:
:
ImmediateAckFlag
immediate_ack
=
AnyDataChunk
:
:
ImmediateAckFlag
(
false
)
)
;
void
ObservePacketEnd
(
)
;
void
HandleForwardTsn
(
TSN
new_cumulative_ack
)
;
bool
ShouldSendAck
(
bool
also_if_delayed
=
false
)
;
TSN
last_cumulative_acked_tsn
(
)
const
{
return
TSN
(
last_cumulative_acked_tsn_
.
Wrap
(
)
)
;
}
bool
will_increase_cum_ack_tsn
(
TSN
tsn
)
const
;
void
ForceImmediateSack
(
)
;
SackChunk
CreateSelectiveAck
(
size_t
a_rwnd
)
;
void
HandleDelayedAckTimerExpiry
(
)
;
private
:
enum
class
AckState
{
kIdle
kBecomingDelayed
kDelayed
kImmediate
}
;
std
:
:
vector
<
SackChunk
:
:
GapAckBlock
>
CreateGapAckBlocks
(
)
const
;
void
UpdateAckState
(
AckState
new_state
absl
:
:
string_view
reason
)
;
static
absl
:
:
string_view
ToString
(
AckState
ack_state
)
;
const
std
:
:
string
log_prefix_
;
bool
seen_packet_
=
false
;
Timer
&
delayed_ack_timer_
;
AckState
ack_state_
=
AckState
:
:
kIdle
;
UnwrappedTSN
:
:
Unwrapper
tsn_unwrapper_
;
UnwrappedTSN
last_cumulative_acked_tsn_
;
std
:
:
set
<
UnwrappedTSN
>
additional_tsns
;
std
:
:
set
<
UnwrappedTSN
>
duplicates_
;
}
;
}
#
endif
