#
ifndef
NET_DCSCTP_TIMER_TIMER_H_
#
define
NET_DCSCTP_TIMER_TIMER_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
unordered_map
>
#
include
<
utility
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
net
/
dcsctp
/
public
/
strong_alias
.
h
"
#
include
"
net
/
dcsctp
/
public
/
timeout
.
h
"
namespace
dcsctp
{
using
TimerID
=
StrongAlias
<
class
TimerIDTag
uint32_t
>
;
using
TimerGeneration
=
StrongAlias
<
class
TimerGenerationTag
uint32_t
>
;
enum
class
TimerBackoffAlgorithm
{
kFixed
kExponential
}
;
struct
TimerOptions
{
explicit
TimerOptions
(
DurationMs
duration
)
:
TimerOptions
(
duration
TimerBackoffAlgorithm
:
:
kExponential
)
{
}
TimerOptions
(
DurationMs
duration
TimerBackoffAlgorithm
backoff_algorithm
)
:
TimerOptions
(
duration
backoff_algorithm
-
1
)
{
}
TimerOptions
(
DurationMs
duration
TimerBackoffAlgorithm
backoff_algorithm
int
max_restarts
)
:
duration
(
duration
)
backoff_algorithm
(
backoff_algorithm
)
max_restarts
(
max_restarts
)
{
}
const
DurationMs
duration
;
const
TimerBackoffAlgorithm
backoff_algorithm
;
const
int
max_restarts
;
}
;
class
Timer
{
public
:
static
constexpr
DurationMs
kMaxTimerDuration
=
DurationMs
(
24
*
3600
*
1000
)
;
using
OnExpired
=
std
:
:
function
<
absl
:
:
optional
<
DurationMs
>
(
)
>
;
Timer
(
const
Timer
&
)
=
delete
;
Timer
&
operator
=
(
const
Timer
&
)
=
delete
;
~
Timer
(
)
;
void
Start
(
)
;
void
Stop
(
)
;
void
set_duration
(
DurationMs
duration
)
{
duration_
=
std
:
:
min
(
duration
kMaxTimerDuration
)
;
}
DurationMs
duration
(
)
const
{
return
duration_
;
}
int
expiration_count
(
)
const
{
return
expiration_count_
;
}
const
TimerOptions
&
options
(
)
const
{
return
options_
;
}
absl
:
:
string_view
name
(
)
const
{
return
name_
;
}
bool
is_running
(
)
const
{
return
is_running_
;
}
private
:
friend
class
TimerManager
;
using
UnregisterHandler
=
std
:
:
function
<
void
(
)
>
;
Timer
(
TimerID
id
absl
:
:
string_view
name
OnExpired
on_expired
UnregisterHandler
unregister
std
:
:
unique_ptr
<
Timeout
>
timeout
const
TimerOptions
&
options
)
;
void
Trigger
(
TimerGeneration
generation
)
;
const
TimerID
id_
;
const
std
:
:
string
name_
;
const
TimerOptions
options_
;
const
OnExpired
on_expired_
;
const
UnregisterHandler
unregister_handler_
;
const
std
:
:
unique_ptr
<
Timeout
>
timeout_
;
DurationMs
duration_
;
TimerGeneration
generation_
=
TimerGeneration
(
0
)
;
bool
is_running_
=
false
;
int
expiration_count_
=
0
;
}
;
class
TimerManager
{
public
:
explicit
TimerManager
(
std
:
:
function
<
std
:
:
unique_ptr
<
Timeout
>
(
)
>
create_timeout
)
:
create_timeout_
(
std
:
:
move
(
create_timeout
)
)
{
}
std
:
:
unique_ptr
<
Timer
>
CreateTimer
(
absl
:
:
string_view
name
Timer
:
:
OnExpired
on_expired
const
TimerOptions
&
options
)
;
void
HandleTimeout
(
TimeoutID
timeout_id
)
;
private
:
const
std
:
:
function
<
std
:
:
unique_ptr
<
Timeout
>
(
)
>
create_timeout_
;
std
:
:
unordered_map
<
TimerID
Timer
*
TimerID
:
:
Hasher
>
timers_
;
TimerID
next_id_
=
TimerID
(
0
)
;
}
;
}
#
endif
