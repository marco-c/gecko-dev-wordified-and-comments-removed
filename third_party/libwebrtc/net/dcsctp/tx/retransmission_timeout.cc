#
include
"
net
/
dcsctp
/
tx
/
retransmission_timeout
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
api
/
units
/
time_delta
.
h
"
#
include
"
net
/
dcsctp
/
public
/
dcsctp_options
.
h
"
namespace
dcsctp
{
constexpr
double
kRtoAlpha
=
0
.
125
;
constexpr
double
kRtoBeta
=
0
.
25
;
constexpr
double
kHeuristicVarianceAdjustment
=
8
.
0
;
RetransmissionTimeout
:
:
RetransmissionTimeout
(
const
DcSctpOptions
&
options
)
:
min_rto_
(
options
.
rto_min
.
ToTimeDelta
(
)
)
max_rto_
(
options
.
rto_max
.
ToTimeDelta
(
)
)
max_rtt_
(
options
.
rtt_max
.
ToTimeDelta
(
)
)
min_rtt_variance_
(
options
.
min_rtt_variance
.
ToTimeDelta
(
)
/
kHeuristicVarianceAdjustment
)
srtt_
(
options
.
rto_initial
.
ToTimeDelta
(
)
)
rto_
(
options
.
rto_initial
.
ToTimeDelta
(
)
)
{
}
void
RetransmissionTimeout
:
:
ObserveRTT
(
webrtc
:
:
TimeDelta
rtt
)
{
if
(
rtt
<
webrtc
:
:
TimeDelta
:
:
Zero
(
)
|
|
rtt
>
max_rtt_
)
{
return
;
}
if
(
first_measurement_
)
{
srtt_
=
rtt
;
rtt_var_
=
rtt
/
2
;
first_measurement_
=
false
;
}
else
{
webrtc
:
:
TimeDelta
rtt_diff
=
(
srtt_
-
rtt
)
.
Abs
(
)
;
rtt_var_
=
(
1
-
kRtoBeta
)
*
rtt_var_
+
kRtoBeta
*
rtt_diff
;
srtt_
=
(
1
-
kRtoAlpha
)
*
srtt_
+
kRtoAlpha
*
rtt
;
}
if
(
rtt_var_
<
min_rtt_variance_
)
{
rtt_var_
=
min_rtt_variance_
;
}
rto_
=
srtt_
+
4
*
rtt_var_
;
rto_
=
std
:
:
clamp
(
rto_
min_rto_
max_rto_
)
;
}
}
