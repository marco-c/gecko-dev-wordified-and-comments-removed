#
ifndef
NET_DCSCTP_TX_RETRANSMISSION_QUEUE_H_
#
define
NET_DCSCTP_TX_RETRANSMISSION_QUEUE_H_
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
net
/
dcsctp
/
common
/
sequence_numbers
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
forward_tsn_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
iforward_tsn_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
sack_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
data
.
h
"
#
include
"
net
/
dcsctp
/
public
/
dcsctp_options
.
h
"
#
include
"
net
/
dcsctp
/
timer
/
timer
.
h
"
#
include
"
net
/
dcsctp
/
tx
/
retransmission_timeout
.
h
"
#
include
"
net
/
dcsctp
/
tx
/
send_queue
.
h
"
namespace
dcsctp
{
class
RetransmissionQueue
{
public
:
static
constexpr
size_t
kMinimumFragmentedPayload
=
10
;
enum
class
State
{
kInFlight
kNacked
kToBeRetransmitted
kAcked
kAbandoned
}
;
RetransmissionQueue
(
absl
:
:
string_view
log_prefix
TSN
initial_tsn
size_t
a_rwnd
SendQueue
&
send_queue
std
:
:
function
<
void
(
DurationMs
rtt
)
>
on_new_rtt
std
:
:
function
<
void
(
)
>
on_send_queue_empty
std
:
:
function
<
void
(
)
>
on_clear_retransmission_counter
Timer
&
t3_rtx
const
DcSctpOptions
&
options
bool
supports_partial_reliability
=
true
bool
use_message_interleaving
=
false
)
;
bool
HandleSack
(
TimeMs
now
const
SackChunk
&
sack
)
;
void
HandleT3RtxTimerExpiry
(
)
;
std
:
:
vector
<
std
:
:
pair
<
TSN
Data
>
>
GetChunksToSend
(
TimeMs
now
size_t
bytes_remaining_in_packet
)
;
std
:
:
vector
<
std
:
:
pair
<
TSN
State
>
>
GetChunkStatesForTesting
(
)
const
;
TSN
next_tsn
(
)
const
{
return
next_tsn_
.
Wrap
(
)
;
}
size_t
cwnd
(
)
const
{
return
cwnd_
;
}
void
set_cwnd
(
size_t
cwnd
)
{
cwnd_
=
cwnd
;
}
size_t
rwnd
(
)
const
{
return
rwnd_
;
}
size_t
outstanding_bytes
(
)
const
{
return
outstanding_bytes_
;
}
bool
ShouldSendForwardTsn
(
TimeMs
now
)
;
ForwardTsnChunk
CreateForwardTsn
(
)
const
;
IForwardTsnChunk
CreateIForwardTsn
(
)
const
;
void
PrepareResetStreams
(
rtc
:
:
ArrayView
<
const
StreamID
>
streams
)
;
bool
CanResetStreams
(
)
const
;
void
CommitResetStreams
(
)
;
void
RollbackResetStreams
(
)
;
private
:
enum
class
CongestionAlgorithmPhase
{
kSlowStart
kCongestionAvoidance
}
;
class
TxData
{
public
:
explicit
TxData
(
Data
data
absl
:
:
optional
<
size_t
>
max_retransmissions
TimeMs
time_sent
absl
:
:
optional
<
TimeMs
>
expires_at
)
:
max_retransmissions_
(
max_retransmissions
)
time_sent_
(
time_sent
)
expires_at_
(
expires_at
)
data_
(
std
:
:
move
(
data
)
)
{
}
TimeMs
time_sent
(
)
const
{
return
time_sent_
;
}
State
state
(
)
const
{
return
state_
;
}
void
SetState
(
State
state
)
{
state_
=
state
;
}
const
Data
&
data
(
)
const
{
return
data_
;
}
void
Nack
(
)
;
void
Retransmit
(
)
;
bool
has_been_retransmitted
(
)
{
return
num_retransmissions_
>
0
;
}
bool
has_expired
(
TimeMs
now
)
const
;
private
:
State
state_
=
State
:
:
kInFlight
;
size_t
nack_count_
=
0
;
size_t
num_retransmissions_
=
0
;
const
absl
:
:
optional
<
size_t
>
max_retransmissions_
;
const
TimeMs
time_sent_
;
const
absl
:
:
optional
<
TimeMs
>
expires_at_
;
Data
data_
;
}
;
struct
AckInfo
{
explicit
AckInfo
(
UnwrappedTSN
cumulative_tsn_ack
)
:
highest_tsn_acked
(
cumulative_tsn_ack
)
{
}
std
:
:
vector
<
TSN
>
acked_tsns
;
size_t
bytes_acked_by_cumulative_tsn_ack
=
0
;
size_t
bytes_acked_by_new_gap_ack_blocks
=
0
;
bool
has_packet_loss
=
false
;
UnwrappedTSN
highest_tsn_acked
;
}
;
size_t
GetSerializedChunkSize
(
const
Data
&
data
)
const
;
bool
is_in_fast_recovery
(
)
const
{
return
fast_recovery_exit_tsn_
.
has_value
(
)
;
}
bool
is_in_fast_retransmit
(
)
const
{
return
is_in_fast_retransmit_
;
}
bool
IsSackValid
(
const
SackChunk
&
sack
)
const
;
void
RemoveAcked
(
UnwrappedTSN
cumulative_tsn_ack
AckInfo
&
ack_info
)
;
void
AckGapBlocks
(
UnwrappedTSN
cumulative_tsn_ack
rtc
:
:
ArrayView
<
const
SackChunk
:
:
GapAckBlock
>
gap_ack_blocks
AckInfo
&
ack_info
)
;
void
NackBetweenAckBlocks
(
UnwrappedTSN
cumulative_tsn_ack
rtc
:
:
ArrayView
<
const
SackChunk
:
:
GapAckBlock
>
gap_ack_blocks
AckInfo
&
ack_info
)
;
void
UpdateRTT
(
TimeMs
now
UnwrappedTSN
cumulative_tsn_ack
)
;
void
MaybeExitFastRecovery
(
UnwrappedTSN
cumulative_tsn_ack
)
;
void
StopT3RtxTimerOnIncreasedCumulativeTsnAck
(
UnwrappedTSN
cumulative_tsn_ack
)
;
void
HandleIncreasedCumulativeTsnAck
(
size_t
outstanding_bytes
size_t
total_bytes_acked
)
;
void
HandlePacketLoss
(
UnwrappedTSN
highest_tsn_acked
)
;
void
RecalculateOutstandingBytes
(
)
;
void
UpdateReceiverWindow
(
uint32_t
a_rwnd
)
;
std
:
:
vector
<
std
:
:
pair
<
TSN
Data
>
>
GetChunksToBeRetransmitted
(
size_t
max_size
)
;
void
StartT3RtxTimerIfOutstandingData
(
)
;
void
ExpireChunks
(
TimeMs
now
)
;
void
ExpireAllFor
(
const
RetransmissionQueue
:
:
TxData
&
item
)
;
CongestionAlgorithmPhase
phase
(
)
const
{
return
(
cwnd_
<
=
ssthresh_
)
?
CongestionAlgorithmPhase
:
:
kSlowStart
:
CongestionAlgorithmPhase
:
:
kCongestionAvoidance
;
}
const
DcSctpOptions
options_
;
const
bool
partial_reliability_
;
const
std
:
:
string
log_prefix_
;
const
size_t
data_chunk_header_size_
;
const
std
:
:
function
<
void
(
DurationMs
rtt
)
>
on_new_rtt_
;
const
std
:
:
function
<
void
(
)
>
on_send_queue_empty_
;
const
std
:
:
function
<
void
(
)
>
on_clear_retransmission_counter_
;
Timer
&
t3_rtx_
;
UnwrappedTSN
:
:
Unwrapper
tsn_unwrapper_
;
size_t
cwnd_
;
size_t
rwnd_
;
size_t
ssthresh_
;
size_t
partial_bytes_acked_
=
0
;
absl
:
:
optional
<
UnwrappedTSN
>
fast_recovery_exit_tsn_
=
absl
:
:
nullopt
;
bool
is_in_fast_retransmit_
=
false
;
UnwrappedTSN
next_tsn_
;
UnwrappedTSN
last_cumulative_tsn_ack_
;
SendQueue
&
send_queue_
;
std
:
:
map
<
UnwrappedTSN
TxData
>
outstanding_data_
;
size_t
outstanding_bytes_
=
0
;
}
;
}
#
endif
