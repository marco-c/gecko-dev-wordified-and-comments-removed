#
ifndef
NET_DCSCTP_TX_RR_SEND_QUEUE_H_
#
define
NET_DCSCTP_TX_RR_SEND_QUEUE_H_
#
include
<
cstdint
>
#
include
<
deque
>
#
include
<
map
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
net
/
dcsctp
/
public
/
dcsctp_message
.
h
"
#
include
"
net
/
dcsctp
/
public
/
dcsctp_socket
.
h
"
#
include
"
net
/
dcsctp
/
public
/
types
.
h
"
#
include
"
net
/
dcsctp
/
tx
/
send_queue
.
h
"
namespace
dcsctp
{
class
RRSendQueue
:
public
SendQueue
{
public
:
static
constexpr
size_t
kMinimumFragmentedPayload
=
10
;
RRSendQueue
(
absl
:
:
string_view
log_prefix
size_t
buffer_size
std
:
:
function
<
void
(
StreamID
)
>
on_buffered_amount_low
size_t
total_buffered_amount_low_threshold
std
:
:
function
<
void
(
)
>
on_total_buffered_amount_low
const
DcSctpSocketHandoverState
*
handover_state
=
nullptr
)
;
bool
IsFull
(
)
const
;
bool
IsEmpty
(
)
const
;
void
Add
(
TimeMs
now
DcSctpMessage
message
const
SendOptions
&
send_options
=
{
}
)
;
absl
:
:
optional
<
DataToSend
>
Produce
(
TimeMs
now
size_t
max_size
)
override
;
bool
Discard
(
IsUnordered
unordered
StreamID
stream_id
MID
message_id
)
override
;
void
PrepareResetStreams
(
rtc
:
:
ArrayView
<
const
StreamID
>
streams
)
override
;
bool
CanResetStreams
(
)
const
override
;
void
CommitResetStreams
(
)
override
;
void
RollbackResetStreams
(
)
override
;
void
Reset
(
)
override
;
size_t
buffered_amount
(
StreamID
stream_id
)
const
override
;
size_t
total_buffered_amount
(
)
const
override
{
return
total_buffered_amount_
.
value
(
)
;
}
size_t
buffered_amount_low_threshold
(
StreamID
stream_id
)
const
override
;
void
SetBufferedAmountLowThreshold
(
StreamID
stream_id
size_t
bytes
)
override
;
HandoverReadinessStatus
GetHandoverReadiness
(
)
const
;
void
AddHandoverState
(
DcSctpSocketHandoverState
&
state
)
;
void
RestoreFromState
(
const
DcSctpSocketHandoverState
&
state
)
;
private
:
class
ThresholdWatcher
{
public
:
explicit
ThresholdWatcher
(
std
:
:
function
<
void
(
)
>
on_threshold_reached
)
:
on_threshold_reached_
(
std
:
:
move
(
on_threshold_reached
)
)
{
}
void
Increase
(
size_t
bytes
)
{
value_
+
=
bytes
;
}
void
Decrease
(
size_t
bytes
)
;
size_t
value
(
)
const
{
return
value_
;
}
size_t
low_threshold
(
)
const
{
return
low_threshold_
;
}
void
SetLowThreshold
(
size_t
low_threshold
)
;
private
:
const
std
:
:
function
<
void
(
)
>
on_threshold_reached_
;
size_t
value_
=
0
;
size_t
low_threshold_
=
0
;
}
;
class
OutgoingStream
{
public
:
explicit
OutgoingStream
(
std
:
:
function
<
void
(
)
>
on_buffered_amount_low
ThresholdWatcher
&
total_buffered_amount
const
DcSctpSocketHandoverState
:
:
OutgoingStream
*
state
=
nullptr
)
:
next_unordered_mid_
(
MID
(
state
?
state
-
>
next_unordered_mid
:
0
)
)
next_ordered_mid_
(
MID
(
state
?
state
-
>
next_ordered_mid
:
0
)
)
next_ssn_
(
SSN
(
state
?
state
-
>
next_ssn
:
0
)
)
buffered_amount_
(
std
:
:
move
(
on_buffered_amount_low
)
)
total_buffered_amount_
(
total_buffered_amount
)
{
}
void
Add
(
DcSctpMessage
message
TimeMs
expires_at
const
SendOptions
&
send_options
)
;
absl
:
:
optional
<
DataToSend
>
Produce
(
TimeMs
now
size_t
max_size
)
;
const
ThresholdWatcher
&
buffered_amount
(
)
const
{
return
buffered_amount_
;
}
ThresholdWatcher
&
buffered_amount
(
)
{
return
buffered_amount_
;
}
bool
Discard
(
IsUnordered
unordered
MID
message_id
)
;
void
Pause
(
)
;
void
Resume
(
)
{
is_paused_
=
false
;
}
bool
is_paused
(
)
const
{
return
is_paused_
;
}
void
Reset
(
)
;
bool
has_partially_sent_message
(
)
const
;
bool
HasDataToSend
(
TimeMs
now
)
;
void
AddHandoverState
(
DcSctpSocketHandoverState
:
:
OutgoingStream
&
state
)
const
;
private
:
struct
Item
{
explicit
Item
(
DcSctpMessage
msg
TimeMs
expires_at
const
SendOptions
&
send_options
)
:
message
(
std
:
:
move
(
msg
)
)
expires_at
(
expires_at
)
send_options
(
send_options
)
remaining_offset
(
0
)
remaining_size
(
message
.
payload
(
)
.
size
(
)
)
{
}
DcSctpMessage
message
;
TimeMs
expires_at
;
SendOptions
send_options
;
size_t
remaining_offset
;
size_t
remaining_size
;
absl
:
:
optional
<
MID
>
message_id
=
absl
:
:
nullopt
;
absl
:
:
optional
<
SSN
>
ssn
=
absl
:
:
nullopt
;
FSN
current_fsn
=
FSN
(
0
)
;
}
;
bool
IsConsistent
(
)
const
;
bool
is_paused_
=
false
;
MID
next_unordered_mid_
;
MID
next_ordered_mid_
;
SSN
next_ssn_
;
std
:
:
deque
<
Item
>
items_
;
ThresholdWatcher
buffered_amount_
;
ThresholdWatcher
&
total_buffered_amount_
;
}
;
bool
IsConsistent
(
)
const
;
OutgoingStream
&
GetOrCreateStreamInfo
(
StreamID
stream_id
)
;
absl
:
:
optional
<
DataToSend
>
Produce
(
std
:
:
map
<
StreamID
OutgoingStream
>
:
:
iterator
it
TimeMs
now
size_t
max_size
)
;
std
:
:
map
<
StreamID
OutgoingStream
>
:
:
iterator
GetNextStream
(
TimeMs
now
)
;
const
std
:
:
string
log_prefix_
;
const
size_t
buffer_size_
;
const
std
:
:
function
<
void
(
StreamID
)
>
on_buffered_amount_low_
;
const
std
:
:
function
<
void
(
)
>
on_total_buffered_amount_low_
;
ThresholdWatcher
total_buffered_amount_
;
bool
previous_message_has_ended_
=
true
;
StreamID
current_stream_id_
=
StreamID
(
0
)
;
std
:
:
map
<
StreamID
OutgoingStream
>
streams_
;
}
;
}
#
endif
