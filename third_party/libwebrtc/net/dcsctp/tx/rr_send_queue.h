#
ifndef
NET_DCSCTP_TX_RR_SEND_QUEUE_H_
#
define
NET_DCSCTP_TX_RR_SEND_QUEUE_H_
#
include
<
cstdint
>
#
include
<
deque
>
#
include
<
map
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
net
/
dcsctp
/
common
/
pair_hash
.
h
"
#
include
"
net
/
dcsctp
/
public
/
dcsctp_message
.
h
"
#
include
"
net
/
dcsctp
/
public
/
dcsctp_socket
.
h
"
#
include
"
net
/
dcsctp
/
public
/
types
.
h
"
#
include
"
net
/
dcsctp
/
tx
/
send_queue
.
h
"
namespace
dcsctp
{
class
RRSendQueue
:
public
SendQueue
{
public
:
static
constexpr
size_t
kMinimumFragmentedPayload
=
10
;
RRSendQueue
(
absl
:
:
string_view
log_prefix
size_t
buffer_size
)
:
log_prefix_
(
std
:
:
string
(
log_prefix
)
+
"
fcfs
:
"
)
buffer_size_
(
buffer_size
)
{
}
bool
IsFull
(
)
const
;
bool
IsEmpty
(
)
const
;
void
Add
(
TimeMs
now
DcSctpMessage
message
const
SendOptions
&
send_options
=
{
}
)
;
absl
:
:
optional
<
DataToSend
>
Produce
(
TimeMs
now
size_t
max_size
)
override
;
bool
Discard
(
IsUnordered
unordered
StreamID
stream_id
MID
message_id
)
override
;
void
PrepareResetStreams
(
rtc
:
:
ArrayView
<
const
StreamID
>
streams
)
override
;
bool
CanResetStreams
(
)
const
override
;
void
CommitResetStreams
(
)
override
;
void
RollbackResetStreams
(
)
override
;
void
Reset
(
)
override
;
size_t
total_bytes
(
)
const
;
private
:
class
OutgoingStream
{
public
:
void
Add
(
DcSctpMessage
message
absl
:
:
optional
<
TimeMs
>
expires_at
const
SendOptions
&
send_options
)
;
absl
:
:
optional
<
DataToSend
>
Produce
(
TimeMs
now
size_t
max_size
)
;
size_t
buffered_amount
(
)
const
;
bool
Discard
(
IsUnordered
unordered
MID
message_id
)
;
void
Pause
(
)
;
void
Resume
(
)
{
is_paused_
=
false
;
}
bool
is_paused
(
)
const
{
return
is_paused_
;
}
void
Reset
(
)
;
bool
has_partially_sent_message
(
)
const
;
private
:
struct
Item
{
explicit
Item
(
DcSctpMessage
msg
absl
:
:
optional
<
TimeMs
>
expires_at
const
SendOptions
&
send_options
)
:
message
(
std
:
:
move
(
msg
)
)
expires_at
(
expires_at
)
send_options
(
send_options
)
remaining_offset
(
0
)
remaining_size
(
message
.
payload
(
)
.
size
(
)
)
{
}
DcSctpMessage
message
;
absl
:
:
optional
<
TimeMs
>
expires_at
;
SendOptions
send_options
;
size_t
remaining_offset
;
size_t
remaining_size
;
absl
:
:
optional
<
MID
>
message_id
=
absl
:
:
nullopt
;
absl
:
:
optional
<
SSN
>
ssn
=
absl
:
:
nullopt
;
FSN
current_fsn
=
FSN
(
0
)
;
}
;
Item
*
GetFirstNonExpiredMessage
(
TimeMs
now
)
;
bool
is_paused_
=
false
;
MID
next_unordered_mid_
=
MID
(
0
)
;
MID
next_ordered_mid_
=
MID
(
0
)
;
SSN
next_ssn_
=
SSN
(
0
)
;
std
:
:
deque
<
Item
>
items_
;
}
;
OutgoingStream
&
GetOrCreateStreamInfo
(
StreamID
stream_id
)
;
absl
:
:
optional
<
DataToSend
>
Produce
(
std
:
:
map
<
StreamID
OutgoingStream
>
:
:
iterator
it
TimeMs
now
size_t
max_size
)
;
const
std
:
:
string
log_prefix_
;
const
size_t
buffer_size_
;
StreamID
next_stream_id_
=
StreamID
(
0
)
;
std
:
:
map
<
StreamID
OutgoingStream
>
streams_
;
}
;
}
#
endif
