#
ifndef
NET_DCSCTP_TX_OUTSTANDING_DATA_H_
#
define
NET_DCSCTP_TX_OUTSTANDING_DATA_H_
#
include
<
map
>
#
include
<
set
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
net
/
dcsctp
/
common
/
sequence_numbers
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
forward_tsn_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
iforward_tsn_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
sack_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
data
.
h
"
namespace
dcsctp
{
class
OutstandingData
{
public
:
enum
class
State
{
kInFlight
kNacked
kToBeRetransmitted
kAcked
kAbandoned
}
;
struct
AckInfo
{
explicit
AckInfo
(
UnwrappedTSN
cumulative_tsn_ack
)
:
highest_tsn_acked
(
cumulative_tsn_ack
)
{
}
size_t
bytes_acked
=
0
;
bool
has_packet_loss
=
false
;
UnwrappedTSN
highest_tsn_acked
;
}
;
OutstandingData
(
size_t
data_chunk_header_size
UnwrappedTSN
next_tsn
UnwrappedTSN
last_cumulative_tsn_ack
std
:
:
function
<
bool
(
IsUnordered
StreamID
MID
)
>
discard_from_send_queue
)
:
data_chunk_header_size_
(
data_chunk_header_size
)
next_tsn_
(
next_tsn
)
last_cumulative_tsn_ack_
(
last_cumulative_tsn_ack
)
discard_from_send_queue_
(
std
:
:
move
(
discard_from_send_queue
)
)
{
}
AckInfo
HandleSack
(
UnwrappedTSN
cumulative_tsn_ack
rtc
:
:
ArrayView
<
const
SackChunk
:
:
GapAckBlock
>
gap_ack_blocks
bool
is_in_fast_retransmit
)
;
std
:
:
vector
<
std
:
:
pair
<
TSN
Data
>
>
GetChunksToBeRetransmitted
(
size_t
max_size
)
;
size_t
outstanding_bytes
(
)
const
{
return
outstanding_bytes_
;
}
size_t
outstanding_items
(
)
const
{
return
outstanding_items_
;
}
void
ExpireOutstandingChunks
(
TimeMs
now
)
;
bool
empty
(
)
const
{
return
outstanding_data_
.
empty
(
)
;
}
bool
has_data_to_be_retransmitted
(
)
const
{
return
!
to_be_retransmitted_
.
empty
(
)
;
}
UnwrappedTSN
last_cumulative_tsn_ack
(
)
const
{
return
last_cumulative_tsn_ack_
;
}
UnwrappedTSN
next_tsn
(
)
const
{
return
next_tsn_
;
}
UnwrappedTSN
highest_outstanding_tsn
(
)
const
;
absl
:
:
optional
<
UnwrappedTSN
>
Insert
(
const
Data
&
data
MaxRetransmits
max_retransmissions
TimeMs
time_sent
TimeMs
expires_at
)
;
void
NackAll
(
)
;
ForwardTsnChunk
CreateForwardTsn
(
)
const
;
IForwardTsnChunk
CreateIForwardTsn
(
)
const
;
absl
:
:
optional
<
DurationMs
>
MeasureRTT
(
TimeMs
now
UnwrappedTSN
tsn
)
const
;
std
:
:
vector
<
std
:
:
pair
<
TSN
State
>
>
GetChunkStatesForTesting
(
)
const
;
bool
ShouldSendForwardTsn
(
)
const
;
private
:
class
Item
{
public
:
enum
class
NackAction
{
kNothing
kRetransmit
kAbandon
}
;
explicit
Item
(
Data
data
MaxRetransmits
max_retransmissions
TimeMs
time_sent
TimeMs
expires_at
)
:
max_retransmissions_
(
max_retransmissions
)
time_sent_
(
time_sent
)
expires_at_
(
expires_at
)
data_
(
std
:
:
move
(
data
)
)
{
}
TimeMs
time_sent
(
)
const
{
return
time_sent_
;
}
const
Data
&
data
(
)
const
{
return
data_
;
}
void
Ack
(
)
;
NackAction
Nack
(
bool
retransmit_now
=
false
)
;
void
Retransmit
(
)
;
void
Abandon
(
)
;
bool
is_outstanding
(
)
const
{
return
ack_state_
=
=
AckState
:
:
kUnacked
;
}
bool
is_acked
(
)
const
{
return
ack_state_
=
=
AckState
:
:
kAcked
;
}
bool
is_nacked
(
)
const
{
return
ack_state_
=
=
AckState
:
:
kNacked
;
}
bool
is_abandoned
(
)
const
{
return
is_abandoned_
;
}
bool
should_be_retransmitted
(
)
const
{
return
should_be_retransmitted_
;
}
bool
has_been_retransmitted
(
)
const
{
return
num_retransmissions_
>
0
;
}
bool
has_expired
(
TimeMs
now
)
const
;
private
:
enum
class
AckState
{
kUnacked
kAcked
kNacked
}
;
AckState
ack_state_
=
AckState
:
:
kUnacked
;
bool
is_abandoned_
=
false
;
bool
should_be_retransmitted_
=
false
;
uint8_t
nack_count_
=
0
;
uint16_t
num_retransmissions_
=
0
;
const
MaxRetransmits
max_retransmissions_
;
const
TimeMs
time_sent_
;
const
TimeMs
expires_at_
;
Data
data_
;
}
;
size_t
GetSerializedChunkSize
(
const
Data
&
data
)
const
;
void
RemoveAcked
(
UnwrappedTSN
cumulative_tsn_ack
AckInfo
&
ack_info
)
;
void
AckGapBlocks
(
UnwrappedTSN
cumulative_tsn_ack
rtc
:
:
ArrayView
<
const
SackChunk
:
:
GapAckBlock
>
gap_ack_blocks
AckInfo
&
ack_info
)
;
void
NackBetweenAckBlocks
(
UnwrappedTSN
cumulative_tsn_ack
rtc
:
:
ArrayView
<
const
SackChunk
:
:
GapAckBlock
>
gap_ack_blocks
bool
is_in_fast_recovery
OutstandingData
:
:
AckInfo
&
ack_info
)
;
void
AckChunk
(
AckInfo
&
ack_info
std
:
:
map
<
UnwrappedTSN
Item
>
:
:
iterator
iter
)
;
bool
NackItem
(
UnwrappedTSN
tsn
Item
&
item
bool
retransmit_now
)
;
void
AbandonAllFor
(
const
OutstandingData
:
:
Item
&
item
)
;
bool
IsConsistent
(
)
const
;
const
size_t
data_chunk_header_size_
;
UnwrappedTSN
next_tsn_
;
UnwrappedTSN
last_cumulative_tsn_ack_
;
std
:
:
function
<
bool
(
IsUnordered
StreamID
MID
)
>
discard_from_send_queue_
;
std
:
:
map
<
UnwrappedTSN
Item
>
outstanding_data_
;
size_t
outstanding_bytes_
=
0
;
size_t
outstanding_items_
=
0
;
std
:
:
set
<
UnwrappedTSN
>
to_be_retransmitted_
;
}
;
}
#
endif
