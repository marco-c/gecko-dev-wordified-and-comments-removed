#
include
"
net
/
dcsctp
/
tx
/
stream_scheduler
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
vector
>
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
net
/
dcsctp
/
common
/
internal_types
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
chunk
/
idata_chunk
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
data
.
h
"
#
include
"
net
/
dcsctp
/
packet
/
sctp_packet
.
h
"
#
include
"
net
/
dcsctp
/
public
/
types
.
h
"
#
include
"
net
/
dcsctp
/
tx
/
send_queue
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
namespace
dcsctp
{
namespace
{
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
StrictMock
;
using
:
:
webrtc
:
:
Timestamp
;
constexpr
size_t
kMtu
=
1000
;
constexpr
size_t
kPayloadSize
=
4
;
constexpr
Timestamp
kNow
=
Timestamp
:
:
Zero
(
)
;
MATCHER_P
(
HasDataWithMid
mid
"
"
)
{
if
(
!
arg
.
has_value
(
)
)
{
*
result_listener
<
<
"
There
was
no
produced
data
"
;
return
false
;
}
if
(
arg
-
>
data
.
mid
!
=
mid
)
{
*
result_listener
<
<
"
the
produced
data
had
mid
"
<
<
*
arg
-
>
data
.
mid
<
<
"
and
not
the
expected
"
<
<
*
mid
;
return
false
;
}
return
true
;
}
std
:
:
function
<
std
:
:
optional
<
SendQueue
:
:
DataToSend
>
(
Timestamp
size_t
)
>
CreateChunk
(
OutgoingMessageId
message_id
StreamID
sid
MID
mid
size_t
payload_size
=
kPayloadSize
)
{
return
[
sid
mid
payload_size
message_id
]
(
Timestamp
size_t
)
{
return
SendQueue
:
:
DataToSend
(
message_id
Data
(
sid
SSN
(
0
)
mid
FSN
(
0
)
PPID
(
42
)
std
:
:
vector
<
uint8_t
>
(
payload_size
)
Data
:
:
IsBeginning
(
true
)
Data
:
:
IsEnd
(
true
)
IsUnordered
(
true
)
)
)
;
}
;
}
std
:
:
map
<
StreamID
size_t
>
GetPacketCounts
(
StreamScheduler
&
scheduler
size_t
packets_to_generate
)
{
std
:
:
map
<
StreamID
size_t
>
packet_counts
;
for
(
size_t
i
=
0
;
i
<
packets_to_generate
;
+
+
i
)
{
std
:
:
optional
<
SendQueue
:
:
DataToSend
>
data
=
scheduler
.
Produce
(
kNow
kMtu
)
;
if
(
data
.
has_value
(
)
)
{
+
+
packet_counts
[
data
-
>
data
.
stream_id
]
;
}
}
return
packet_counts
;
}
class
MockStreamProducer
:
public
StreamScheduler
:
:
StreamProducer
{
public
:
MOCK_METHOD
(
std
:
:
optional
<
SendQueue
:
:
DataToSend
>
Produce
(
Timestamp
size_t
)
(
override
)
)
;
MOCK_METHOD
(
size_t
bytes_to_send_in_next_message
(
)
(
const
override
)
)
;
}
;
class
TestStream
{
public
:
TestStream
(
StreamScheduler
&
scheduler
StreamID
stream_id
StreamPriority
priority
size_t
packet_size
=
kPayloadSize
)
{
EXPECT_CALL
(
producer_
Produce
)
.
WillRepeatedly
(
CreateChunk
(
OutgoingMessageId
(
0
)
stream_id
MID
(
0
)
packet_size
)
)
;
EXPECT_CALL
(
producer_
bytes_to_send_in_next_message
)
.
WillRepeatedly
(
Return
(
packet_size
)
)
;
stream_
=
scheduler
.
CreateStream
(
&
producer_
stream_id
priority
)
;
stream_
-
>
MaybeMakeActive
(
)
;
}
StreamScheduler
:
:
Stream
&
stream
(
)
{
return
*
stream_
;
}
private
:
StrictMock
<
MockStreamProducer
>
producer_
;
std
:
:
unique_ptr
<
StreamScheduler
:
:
Stream
>
stream_
;
}
;
TEST
(
StreamSchedulerTest
HasNoActiveStreams
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
CanSetAndGetStreamProperties
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer
;
auto
stream
=
scheduler
.
CreateStream
(
&
producer
StreamID
(
1
)
StreamPriority
(
2
)
)
;
EXPECT_EQ
(
stream
-
>
stream_id
(
)
StreamID
(
1
)
)
;
EXPECT_EQ
(
stream
-
>
priority
(
)
StreamPriority
(
2
)
)
;
stream
-
>
SetPriority
(
StreamPriority
(
0
)
)
;
EXPECT_EQ
(
stream
-
>
priority
(
)
StreamPriority
(
0
)
)
;
}
TEST
(
StreamSchedulerTest
CanProduceFromSingleStream
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer
;
EXPECT_CALL
(
producer
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
0
)
)
)
;
EXPECT_CALL
(
producer
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream
=
scheduler
.
CreateStream
(
&
producer
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
0
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillRoundRobinBetweenStreams
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
producer2
;
EXPECT_CALL
(
producer2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
4
)
StreamID
(
2
)
MID
(
200
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
5
)
StreamID
(
2
)
MID
(
201
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
6
)
StreamID
(
2
)
MID
(
202
)
)
)
;
EXPECT_CALL
(
producer2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
producer2
StreamID
(
2
)
StreamPriority
(
2
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
200
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
201
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
202
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillRoundRobinOnlyWhenFinishedProducingChunk
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
)
)
.
WillOnce
(
[
]
(
.
.
.
)
{
return
SendQueue
:
:
DataToSend
(
OutgoingMessageId
(
1
)
Data
(
StreamID
(
1
)
SSN
(
0
)
MID
(
101
)
FSN
(
0
)
PPID
(
42
)
std
:
:
vector
<
uint8_t
>
(
4
)
Data
:
:
IsBeginning
(
true
)
Data
:
:
IsEnd
(
false
)
IsUnordered
(
true
)
)
)
;
}
)
.
WillOnce
(
[
]
(
.
.
.
)
{
return
SendQueue
:
:
DataToSend
(
OutgoingMessageId
(
1
)
Data
(
StreamID
(
1
)
SSN
(
0
)
MID
(
101
)
FSN
(
0
)
PPID
(
42
)
std
:
:
vector
<
uint8_t
>
(
4
)
Data
:
:
IsBeginning
(
false
)
Data
:
:
IsEnd
(
false
)
IsUnordered
(
true
)
)
)
;
}
)
.
WillOnce
(
[
]
(
.
.
.
)
{
return
SendQueue
:
:
DataToSend
(
OutgoingMessageId
(
1
)
Data
(
StreamID
(
1
)
SSN
(
0
)
MID
(
101
)
FSN
(
0
)
PPID
(
42
)
std
:
:
vector
<
uint8_t
>
(
4
)
Data
:
:
IsBeginning
(
false
)
Data
:
:
IsEnd
(
true
)
IsUnordered
(
true
)
)
)
;
}
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
producer2
;
EXPECT_CALL
(
producer2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
3
)
StreamID
(
2
)
MID
(
200
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
4
)
StreamID
(
2
)
MID
(
201
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
5
)
StreamID
(
2
)
MID
(
202
)
)
)
;
EXPECT_CALL
(
producer2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
producer2
StreamID
(
2
)
StreamPriority
(
2
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
200
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
201
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
202
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
StreamsCanBeMadeInactive
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
stream1
-
>
MakeInactive
(
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
SingleStreamCanBeResumed
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
stream1
-
>
MakeInactive
(
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
stream1
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillRoundRobinWithPausedStream
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
producer2
;
EXPECT_CALL
(
producer2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
3
)
StreamID
(
2
)
MID
(
200
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
4
)
StreamID
(
2
)
MID
(
201
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
5
)
StreamID
(
2
)
MID
(
202
)
)
)
;
EXPECT_CALL
(
producer2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
producer2
StreamID
(
2
)
StreamPriority
(
2
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
200
)
)
)
;
stream1
-
>
MakeInactive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
201
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
202
)
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillDistributeRoundRobinPacketsEvenlyTwoStreams
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
TestStream
stream1
(
scheduler
StreamID
(
1
)
StreamPriority
(
1
)
)
;
TestStream
stream2
(
scheduler
StreamID
(
2
)
StreamPriority
(
1
)
)
;
std
:
:
map
<
StreamID
size_t
>
packet_counts
=
GetPacketCounts
(
scheduler
10
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
1
)
]
5U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
2
)
]
5U
)
;
}
TEST
(
StreamSchedulerTest
WillDistributeEvenlyWithPausedAndAddedStreams
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
TestStream
stream1
(
scheduler
StreamID
(
1
)
StreamPriority
(
1
)
)
;
TestStream
stream2
(
scheduler
StreamID
(
2
)
StreamPriority
(
1
)
)
;
std
:
:
map
<
StreamID
size_t
>
packet_counts
=
GetPacketCounts
(
scheduler
10
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
1
)
]
5U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
2
)
]
5U
)
;
stream2
.
stream
(
)
.
MakeInactive
(
)
;
TestStream
stream3
(
scheduler
StreamID
(
3
)
StreamPriority
(
1
)
)
;
TestStream
stream4
(
scheduler
StreamID
(
4
)
StreamPriority
(
1
)
)
;
std
:
:
map
<
StreamID
size_t
>
counts2
=
GetPacketCounts
(
scheduler
15
)
;
EXPECT_EQ
(
counts2
[
StreamID
(
1
)
]
5U
)
;
EXPECT_EQ
(
counts2
[
StreamID
(
2
)
]
0U
)
;
EXPECT_EQ
(
counts2
[
StreamID
(
3
)
]
5U
)
;
EXPECT_EQ
(
counts2
[
StreamID
(
4
)
]
5U
)
;
stream2
.
stream
(
)
.
MaybeMakeActive
(
)
;
std
:
:
map
<
StreamID
size_t
>
counts3
=
GetPacketCounts
(
scheduler
20
)
;
EXPECT_EQ
(
counts3
[
StreamID
(
1
)
]
5U
)
;
EXPECT_EQ
(
counts3
[
StreamID
(
2
)
]
5U
)
;
EXPECT_EQ
(
counts3
[
StreamID
(
3
)
]
5U
)
;
EXPECT_EQ
(
counts3
[
StreamID
(
4
)
]
5U
)
;
}
TEST
(
StreamSchedulerTest
WillDoFairQueuingWithSamePriority
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
constexpr
size_t
kSmallPacket
=
30
;
constexpr
size_t
kLargePacket
=
70
;
StrictMock
<
MockStreamProducer
>
callback1
;
EXPECT_CALL
(
callback1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
kSmallPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
kSmallPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
kSmallPacket
)
)
;
EXPECT_CALL
(
callback1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kSmallPacket
)
)
.
WillOnce
(
Return
(
kSmallPacket
)
)
.
WillOnce
(
Return
(
kSmallPacket
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
callback1
StreamID
(
1
)
StreamPriority
(
2
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
callback2
;
EXPECT_CALL
(
callback2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
3
)
StreamID
(
2
)
MID
(
200
)
kLargePacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
4
)
StreamID
(
2
)
MID
(
201
)
kLargePacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
5
)
StreamID
(
2
)
MID
(
202
)
kLargePacket
)
)
;
EXPECT_CALL
(
callback2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kLargePacket
)
)
.
WillOnce
(
Return
(
kLargePacket
)
)
.
WillOnce
(
Return
(
kLargePacket
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
callback2
StreamID
(
2
)
StreamPriority
(
2
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
200
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
201
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
202
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillDoWeightedFairQueuingSameSizeDifferentPriority
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
StrictMock
<
MockStreamProducer
>
callback1
;
EXPECT_CALL
(
callback1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
)
)
;
EXPECT_CALL
(
callback1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
callback1
StreamID
(
1
)
StreamPriority
(
125
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
callback2
;
EXPECT_CALL
(
callback2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
3
)
StreamID
(
2
)
MID
(
200
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
4
)
StreamID
(
2
)
MID
(
201
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
5
)
StreamID
(
2
)
MID
(
202
)
)
)
;
EXPECT_CALL
(
callback2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
callback2
StreamID
(
2
)
StreamPriority
(
200
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
callback3
;
EXPECT_CALL
(
callback3
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
6
)
StreamID
(
3
)
MID
(
300
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
7
)
StreamID
(
3
)
MID
(
301
)
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
8
)
StreamID
(
3
)
MID
(
302
)
)
)
;
EXPECT_CALL
(
callback3
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
kPayloadSize
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream3
=
scheduler
.
CreateStream
(
&
callback3
StreamID
(
3
)
StreamPriority
(
500
)
)
;
stream3
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
300
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
301
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
200
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
302
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
201
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
202
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillDoWeightedFairQueuingDifferentSizeAndPriority
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
constexpr
size_t
kSmallPacket
=
20
;
constexpr
size_t
kMediumPacket
=
50
;
constexpr
size_t
kLargePacket
=
70
;
StrictMock
<
MockStreamProducer
>
callback1
;
EXPECT_CALL
(
callback1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
100
)
kMediumPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
101
)
kSmallPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
1
)
MID
(
102
)
kLargePacket
)
)
;
EXPECT_CALL
(
callback1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kMediumPacket
)
)
.
WillOnce
(
Return
(
kSmallPacket
)
)
.
WillOnce
(
Return
(
kLargePacket
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
callback1
StreamID
(
1
)
StreamPriority
(
125
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
callback2
;
EXPECT_CALL
(
callback2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
3
)
StreamID
(
2
)
MID
(
200
)
kMediumPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
4
)
StreamID
(
2
)
MID
(
201
)
kLargePacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
5
)
StreamID
(
2
)
MID
(
202
)
kSmallPacket
)
)
;
EXPECT_CALL
(
callback2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kMediumPacket
)
)
.
WillOnce
(
Return
(
kLargePacket
)
)
.
WillOnce
(
Return
(
kSmallPacket
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
callback2
StreamID
(
2
)
StreamPriority
(
200
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
callback3
;
EXPECT_CALL
(
callback3
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
6
)
StreamID
(
3
)
MID
(
300
)
kSmallPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
7
)
StreamID
(
3
)
MID
(
301
)
kMediumPacket
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
8
)
StreamID
(
3
)
MID
(
302
)
kLargePacket
)
)
;
EXPECT_CALL
(
callback3
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
kSmallPacket
)
)
.
WillOnce
(
Return
(
kMediumPacket
)
)
.
WillOnce
(
Return
(
kLargePacket
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream3
=
scheduler
.
CreateStream
(
&
callback3
StreamID
(
3
)
StreamPriority
(
500
)
)
;
stream3
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
300
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
301
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
200
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
302
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
100
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
101
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
201
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
202
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
102
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
WillDistributeWFQPacketsInTwoStreamsByPriority
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
TestStream
stream1
(
scheduler
StreamID
(
1
)
StreamPriority
(
100
)
kPayloadSize
)
;
TestStream
stream2
(
scheduler
StreamID
(
2
)
StreamPriority
(
200
)
kPayloadSize
)
;
std
:
:
map
<
StreamID
size_t
>
packet_counts
=
GetPacketCounts
(
scheduler
15
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
1
)
]
5U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
2
)
]
10U
)
;
}
TEST
(
StreamSchedulerTest
WillDistributeWFQPacketsInFourStreamsByPriority
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
TestStream
stream1
(
scheduler
StreamID
(
1
)
StreamPriority
(
100
)
kPayloadSize
)
;
TestStream
stream2
(
scheduler
StreamID
(
2
)
StreamPriority
(
200
)
kPayloadSize
)
;
TestStream
stream3
(
scheduler
StreamID
(
3
)
StreamPriority
(
300
)
kPayloadSize
)
;
TestStream
stream4
(
scheduler
StreamID
(
4
)
StreamPriority
(
400
)
kPayloadSize
)
;
std
:
:
map
<
StreamID
size_t
>
packet_counts
=
GetPacketCounts
(
scheduler
50
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
1
)
]
5U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
2
)
]
10U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
3
)
]
15U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
4
)
]
20U
)
;
}
TEST
(
StreamSchedulerTest
WillDistributeFromTwoStreamsFairly
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
TestStream
stream1
(
scheduler
StreamID
(
1
)
StreamPriority
(
100
)
8
)
;
TestStream
stream2
(
scheduler
StreamID
(
2
)
StreamPriority
(
400
)
4
)
;
std
:
:
map
<
StreamID
size_t
>
packet_counts
=
GetPacketCounts
(
scheduler
90
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
1
)
]
10U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
2
)
]
80U
)
;
}
TEST
(
StreamSchedulerTest
WillDistributeFromFourStreamsFairly
)
{
StreamScheduler
scheduler
(
"
"
kMtu
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
TestStream
stream1
(
scheduler
StreamID
(
1
)
StreamPriority
(
100
)
10
)
;
TestStream
stream2
(
scheduler
StreamID
(
2
)
StreamPriority
(
200
)
10
)
;
TestStream
stream3
(
scheduler
StreamID
(
3
)
StreamPriority
(
200
)
20
)
;
TestStream
stream4
(
scheduler
StreamID
(
4
)
StreamPriority
(
400
)
30
)
;
std
:
:
map
<
StreamID
size_t
>
packet_counts
=
GetPacketCounts
(
scheduler
80
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
1
)
]
15U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
2
)
]
30U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
3
)
]
15U
)
;
EXPECT_EQ
(
packet_counts
[
StreamID
(
4
)
]
20U
)
;
}
TEST
(
StreamSchedulerTest
SendLargeMessageWithSmallMtu
)
{
StreamScheduler
scheduler
(
"
"
100
+
SctpPacket
:
:
kHeaderSize
+
IDataChunk
:
:
kHeaderSize
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
0
)
100
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
1
)
MID
(
0
)
100
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
200
)
)
.
WillOnce
(
Return
(
100
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
1
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
producer2
;
EXPECT_CALL
(
producer2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
2
)
StreamID
(
2
)
MID
(
1
)
100
)
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
3
)
StreamID
(
2
)
MID
(
1
)
50
)
)
;
EXPECT_CALL
(
producer2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
150
)
)
.
WillOnce
(
Return
(
50
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
producer2
StreamID
(
2
)
StreamPriority
(
1
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
0
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
1
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
1
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
0
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
TEST
(
StreamSchedulerTest
SendLargeMessageWithLargeMtu
)
{
StreamScheduler
scheduler
(
"
"
200
+
SctpPacket
:
:
kHeaderSize
+
IDataChunk
:
:
kHeaderSize
)
;
scheduler
.
EnableMessageInterleaving
(
true
)
;
StrictMock
<
MockStreamProducer
>
producer1
;
EXPECT_CALL
(
producer1
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
0
)
StreamID
(
1
)
MID
(
0
)
200
)
)
;
EXPECT_CALL
(
producer1
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
200
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream1
=
scheduler
.
CreateStream
(
&
producer1
StreamID
(
1
)
StreamPriority
(
1
)
)
;
stream1
-
>
MaybeMakeActive
(
)
;
StrictMock
<
MockStreamProducer
>
producer2
;
EXPECT_CALL
(
producer2
Produce
)
.
WillOnce
(
CreateChunk
(
OutgoingMessageId
(
1
)
StreamID
(
2
)
MID
(
1
)
150
)
)
;
EXPECT_CALL
(
producer2
bytes_to_send_in_next_message
)
.
WillOnce
(
Return
(
150
)
)
.
WillOnce
(
Return
(
0
)
)
;
auto
stream2
=
scheduler
.
CreateStream
(
&
producer2
StreamID
(
2
)
StreamPriority
(
1
)
)
;
stream2
-
>
MaybeMakeActive
(
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
1
)
)
)
;
EXPECT_THAT
(
scheduler
.
Produce
(
kNow
kMtu
)
HasDataWithMid
(
MID
(
0
)
)
)
;
EXPECT_EQ
(
scheduler
.
Produce
(
kNow
kMtu
)
std
:
:
nullopt
)
;
}
}
}
