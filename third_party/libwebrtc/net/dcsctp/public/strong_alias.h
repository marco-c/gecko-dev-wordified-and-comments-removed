#
ifndef
NET_DCSCTP_PUBLIC_STRONG_ALIAS_H_
#
define
NET_DCSCTP_PUBLIC_STRONG_ALIAS_H_
#
include
<
type_traits
>
#
include
<
utility
>
namespace
dcsctp
{
template
<
typename
TagType
typename
TheUnderlyingType
>
class
StrongAlias
{
public
:
using
UnderlyingType
=
TheUnderlyingType
;
constexpr
StrongAlias
(
)
=
default
;
constexpr
explicit
StrongAlias
(
const
UnderlyingType
&
v
)
:
value_
(
v
)
{
}
constexpr
explicit
StrongAlias
(
UnderlyingType
&
&
v
)
noexcept
:
value_
(
std
:
:
move
(
v
)
)
{
}
constexpr
UnderlyingType
*
operator
-
>
(
)
{
return
&
value_
;
}
constexpr
const
UnderlyingType
*
operator
-
>
(
)
const
{
return
&
value_
;
}
constexpr
UnderlyingType
&
operator
*
(
)
&
{
return
value_
;
}
constexpr
const
UnderlyingType
&
operator
*
(
)
const
&
{
return
value_
;
}
constexpr
UnderlyingType
&
&
operator
*
(
)
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
const
UnderlyingType
&
&
operator
*
(
)
const
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
UnderlyingType
&
value
(
)
&
{
return
value_
;
}
constexpr
const
UnderlyingType
&
value
(
)
const
&
{
return
value_
;
}
constexpr
UnderlyingType
&
&
value
(
)
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
const
UnderlyingType
&
&
value
(
)
const
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
explicit
operator
const
UnderlyingType
&
(
)
const
&
{
return
value_
;
}
constexpr
bool
operator
=
=
(
const
StrongAlias
&
other
)
const
{
return
value_
=
=
other
.
value_
;
}
constexpr
bool
operator
!
=
(
const
StrongAlias
&
other
)
const
{
return
value_
!
=
other
.
value_
;
}
constexpr
bool
operator
<
(
const
StrongAlias
&
other
)
const
{
return
value_
<
other
.
value_
;
}
constexpr
bool
operator
<
=
(
const
StrongAlias
&
other
)
const
{
return
value_
<
=
other
.
value_
;
}
constexpr
bool
operator
>
(
const
StrongAlias
&
other
)
const
{
return
value_
>
other
.
value_
;
}
constexpr
bool
operator
>
=
(
const
StrongAlias
&
other
)
const
{
return
value_
>
=
other
.
value_
;
}
struct
Hasher
{
using
argument_type
=
StrongAlias
;
using
result_type
=
std
:
:
size_t
;
result_type
operator
(
)
(
const
argument_type
&
id
)
const
{
return
std
:
:
hash
<
UnderlyingType
>
(
)
(
id
.
value
(
)
)
;
}
}
;
protected
:
UnderlyingType
value_
;
}
;
}
#
endif
