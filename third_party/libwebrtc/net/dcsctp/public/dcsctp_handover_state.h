#
ifndef
NET_DCSCTP_PUBLIC_DCSCTP_HANDOVER_STATE_H_
#
define
NET_DCSCTP_PUBLIC_DCSCTP_HANDOVER_STATE_H_
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
net
/
dcsctp
/
public
/
strong_alias
.
h
"
namespace
dcsctp
{
struct
DcSctpSocketHandoverState
{
enum
class
SocketState
{
kClosed
kConnected
}
;
SocketState
socket_state
=
SocketState
:
:
kClosed
;
uint32_t
my_verification_tag
=
0
;
uint32_t
my_initial_tsn
=
0
;
uint32_t
peer_verification_tag
=
0
;
uint32_t
peer_initial_tsn
=
0
;
uint64_t
tie_tag
=
0
;
struct
Capabilities
{
bool
partial_reliability
=
false
;
bool
message_interleaving
=
false
;
bool
reconfig
=
false
;
}
;
Capabilities
capabilities
;
struct
OutgoingStream
{
uint32_t
id
=
0
;
uint32_t
next_ssn
=
0
;
uint32_t
next_unordered_mid
=
0
;
uint32_t
next_ordered_mid
=
0
;
}
;
struct
Transmission
{
uint32_t
next_tsn
=
0
;
uint32_t
next_reset_req_sn
=
0
;
uint32_t
cwnd
=
0
;
uint32_t
rwnd
=
0
;
uint32_t
ssthresh
=
0
;
uint32_t
partial_bytes_acked
=
0
;
std
:
:
vector
<
OutgoingStream
>
streams
;
}
;
Transmission
tx
;
struct
OrderedStream
{
uint32_t
id
=
0
;
uint32_t
next_ssn
=
0
;
}
;
struct
UnorderedStream
{
uint32_t
id
=
0
;
}
;
struct
Receive
{
bool
seen_packet
=
false
;
uint32_t
last_cumulative_acked_tsn
=
0
;
uint32_t
last_assembled_tsn
=
0
;
uint32_t
last_completed_deferred_reset_req_sn
=
0
;
uint32_t
last_completed_reset_req_sn
=
0
;
std
:
:
vector
<
OrderedStream
>
ordered_streams
;
std
:
:
vector
<
UnorderedStream
>
unordered_streams
;
}
;
Receive
rx
;
}
;
enum
class
HandoverUnreadinessReason
:
uint32_t
{
kWrongConnectionState
=
1
kSendQueueNotEmpty
=
2
kPendingStreamResetRequest
=
4
kDataTrackerTsnBlocksPending
=
8
kPendingStreamReset
=
16
kReassemblyQueueDeliveredTSNsGap
=
32
kStreamResetDeferred
=
64
kOrderedStreamHasUnassembledChunks
=
128
kUnorderedStreamHasUnassembledChunks
=
256
kRetransmissionQueueOutstandingData
=
512
kRetransmissionQueueFastRecovery
=
1024
kRetransmissionQueueNotEmpty
=
2048
kMax
=
kRetransmissionQueueNotEmpty
}
;
class
HandoverReadinessStatus
:
public
StrongAlias
<
class
HandoverReadinessStatusTag
uint32_t
>
{
public
:
constexpr
HandoverReadinessStatus
(
)
:
StrongAlias
<
class
HandoverReadinessStatusTag
uint32_t
>
(
0
)
{
}
constexpr
explicit
HandoverReadinessStatus
(
HandoverUnreadinessReason
reason
)
:
StrongAlias
<
class
HandoverReadinessStatusTag
uint32_t
>
(
static_cast
<
uint32_t
>
(
reason
)
)
{
}
constexpr
bool
IsReady
(
)
const
{
return
value
(
)
=
=
0
;
}
constexpr
bool
Contains
(
HandoverUnreadinessReason
reason
)
const
{
return
value
(
)
&
static_cast
<
uint32_t
>
(
reason
)
;
}
HandoverReadinessStatus
&
Add
(
HandoverUnreadinessReason
reason
)
{
return
Add
(
HandoverReadinessStatus
(
reason
)
)
;
}
HandoverReadinessStatus
&
Add
(
HandoverReadinessStatus
status
)
{
value
(
)
|
=
status
.
value
(
)
;
return
*
this
;
}
std
:
:
string
ToString
(
)
const
;
}
;
}
#
endif
