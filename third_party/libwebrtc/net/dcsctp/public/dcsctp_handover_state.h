#
ifndef
NET_DCSCTP_PUBLIC_DCSCTP_HANDOVER_STATE_H_
#
define
NET_DCSCTP_PUBLIC_DCSCTP_HANDOVER_STATE_H_
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
net
/
dcsctp
/
public
/
strong_alias
.
h
"
namespace
dcsctp
{
struct
DcSctpSocketHandoverState
{
struct
OrderedStream
{
uint32_t
id
=
0
;
uint32_t
next_ssn
=
0
;
}
;
struct
UnorderedStream
{
uint32_t
id
=
0
;
}
;
struct
Receive
{
bool
seen_packet
=
false
;
uint32_t
last_cumulative_acked_tsn
=
0
;
std
:
:
vector
<
OrderedStream
>
ordered_streams
;
std
:
:
vector
<
UnorderedStream
>
unordered_streams
;
}
;
Receive
rx
;
}
;
enum
class
HandoverUnreadinessReason
:
uint32_t
{
kWrongConnectionState
=
1
kSendQueueNotEmpty
=
2
kPendingStreamResetRequest
=
4
kDataTrackerTsnBlocksPending
=
8
kReassemblyQueueNotEmpty
=
16
kReassemblyQueueDeliveredTSNsGap
=
32
kStreamResetDeferred
=
64
kOrderedStreamHasUnassembledChunks
=
128
kUnorderedStreamHasUnassembledChunks
=
256
kRetransmissionQueueOutstandingData
=
512
kRetransmissionQueueFastRecovery
=
1024
kRetransmissionQueueNotEmpty
=
2048
kPendingStreamReset
=
4096
kMax
=
kPendingStreamReset
}
;
class
HandoverReadinessStatus
:
public
StrongAlias
<
class
HandoverReadinessStatusTag
uint32_t
>
{
public
:
constexpr
HandoverReadinessStatus
(
)
:
StrongAlias
<
class
HandoverReadinessStatusTag
uint32_t
>
(
0
)
{
}
constexpr
explicit
HandoverReadinessStatus
(
HandoverUnreadinessReason
reason
)
:
StrongAlias
<
class
HandoverReadinessStatusTag
uint32_t
>
(
static_cast
<
uint32_t
>
(
reason
)
)
{
}
constexpr
bool
IsReady
(
)
const
{
return
value
(
)
=
=
0
;
}
constexpr
bool
Contains
(
HandoverUnreadinessReason
reason
)
const
{
return
value
(
)
&
static_cast
<
uint32_t
>
(
reason
)
;
}
HandoverReadinessStatus
&
Add
(
HandoverUnreadinessReason
reason
)
{
return
Add
(
HandoverReadinessStatus
(
reason
)
)
;
}
HandoverReadinessStatus
&
Add
(
HandoverReadinessStatus
status
)
{
value
(
)
|
=
status
.
value
(
)
;
return
*
this
;
}
}
;
}
#
endif
