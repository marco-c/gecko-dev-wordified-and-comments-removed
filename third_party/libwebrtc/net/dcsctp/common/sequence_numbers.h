#
ifndef
NET_DCSCTP_COMMON_SEQUENCE_NUMBERS_H_
#
define
NET_DCSCTP_COMMON_SEQUENCE_NUMBERS_H_
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
utility
>
#
include
"
net
/
dcsctp
/
common
/
internal_types
.
h
"
namespace
dcsctp
{
template
<
typename
WrappedType
>
class
UnwrappedSequenceNumber
{
public
:
static_assert
(
!
std
:
:
numeric_limits
<
typename
WrappedType
:
:
UnderlyingType
>
:
:
is_signed
"
The
wrapped
type
must
be
unsigned
"
)
;
static_assert
(
std
:
:
numeric_limits
<
typename
WrappedType
:
:
UnderlyingType
>
:
:
max
(
)
<
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
"
The
wrapped
type
must
be
less
than
the
int64_t
value
space
"
)
;
class
Unwrapper
{
public
:
Unwrapper
(
)
:
largest_
(
kValueLimit
)
{
}
Unwrapper
(
const
Unwrapper
&
)
=
default
;
Unwrapper
&
operator
=
(
const
Unwrapper
&
)
=
default
;
UnwrappedSequenceNumber
<
WrappedType
>
Unwrap
(
WrappedType
value
)
{
WrappedType
wrapped_largest
=
static_cast
<
WrappedType
>
(
largest_
%
kValueLimit
)
;
int64_t
result
=
largest_
+
Delta
(
value
wrapped_largest
)
;
if
(
largest_
<
result
)
{
largest_
=
result
;
}
return
UnwrappedSequenceNumber
<
WrappedType
>
(
result
)
;
}
UnwrappedSequenceNumber
<
WrappedType
>
PeekUnwrap
(
WrappedType
value
)
const
{
WrappedType
uint32_largest
=
static_cast
<
WrappedType
>
(
largest_
%
kValueLimit
)
;
int64_t
result
=
largest_
+
Delta
(
value
uint32_largest
)
;
return
UnwrappedSequenceNumber
<
WrappedType
>
(
result
)
;
}
void
Reset
(
)
{
largest_
=
kValueLimit
;
}
private
:
static
int64_t
Delta
(
WrappedType
value
WrappedType
prev_value
)
{
static
constexpr
typename
WrappedType
:
:
UnderlyingType
kBreakpoint
=
kValueLimit
/
2
;
typename
WrappedType
:
:
UnderlyingType
diff
=
*
value
-
*
prev_value
;
diff
%
=
kValueLimit
;
if
(
diff
<
kBreakpoint
)
{
return
static_cast
<
int64_t
>
(
diff
)
;
}
return
static_cast
<
int64_t
>
(
diff
)
-
kValueLimit
;
}
int64_t
largest_
;
}
;
WrappedType
Wrap
(
)
const
{
return
static_cast
<
WrappedType
>
(
value_
%
kValueLimit
)
;
}
template
<
typename
H
>
friend
H
AbslHashValue
(
H
state
const
UnwrappedSequenceNumber
<
WrappedType
>
&
hash
)
{
return
H
:
:
combine
(
std
:
:
move
(
state
)
hash
.
value_
)
;
}
bool
operator
=
=
(
const
UnwrappedSequenceNumber
<
WrappedType
>
&
other
)
const
{
return
value_
=
=
other
.
value_
;
}
bool
operator
!
=
(
const
UnwrappedSequenceNumber
<
WrappedType
>
&
other
)
const
{
return
value_
!
=
other
.
value_
;
}
bool
operator
<
(
const
UnwrappedSequenceNumber
<
WrappedType
>
&
other
)
const
{
return
value_
<
other
.
value_
;
}
bool
operator
>
(
const
UnwrappedSequenceNumber
<
WrappedType
>
&
other
)
const
{
return
value_
>
other
.
value_
;
}
bool
operator
>
=
(
const
UnwrappedSequenceNumber
<
WrappedType
>
&
other
)
const
{
return
value_
>
=
other
.
value_
;
}
bool
operator
<
=
(
const
UnwrappedSequenceNumber
<
WrappedType
>
&
other
)
const
{
return
value_
<
=
other
.
value_
;
}
void
Increment
(
)
{
+
+
value_
;
}
UnwrappedSequenceNumber
<
WrappedType
>
next_value
(
)
const
{
return
UnwrappedSequenceNumber
<
WrappedType
>
(
value_
+
1
)
;
}
UnwrappedSequenceNumber
<
WrappedType
>
AddTo
(
int
delta
)
const
{
return
UnwrappedSequenceNumber
<
WrappedType
>
(
value_
+
delta
)
;
}
typename
WrappedType
:
:
UnderlyingType
Difference
(
UnwrappedSequenceNumber
<
WrappedType
>
other
)
const
{
return
value_
-
other
.
value_
;
}
private
:
explicit
UnwrappedSequenceNumber
(
int64_t
value
)
:
value_
(
value
)
{
}
static
constexpr
int64_t
kValueLimit
=
static_cast
<
int64_t
>
(
1
)
<
<
std
:
:
numeric_limits
<
typename
WrappedType
:
:
UnderlyingType
>
:
:
digits
;
int64_t
value_
;
}
;
using
UnwrappedTSN
=
UnwrappedSequenceNumber
<
TSN
>
;
using
UnwrappedSSN
=
UnwrappedSequenceNumber
<
SSN
>
;
using
UnwrappedMID
=
UnwrappedSequenceNumber
<
MID
>
;
}
#
endif
