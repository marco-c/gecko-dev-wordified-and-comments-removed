#
ifndef
API_RTP_HEADERS_H_
#
define
API_RTP_HEADERS_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
api
/
video
/
color_space
.
h
"
#
include
"
api
/
video
/
video_content_type
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
api
/
video
/
video_timing
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
webrtc
{
struct
FeedbackRequest
{
bool
include_timestamps
;
int
sequence_count
;
}
;
struct
AbsoluteCaptureTime
{
uint64_t
absolute_capture_timestamp
;
absl
:
:
optional
<
int64_t
>
estimated_capture_clock_offset
;
}
;
class
AudioLevel
{
public
:
AudioLevel
(
)
;
AudioLevel
(
bool
voice_activity
int
audio_level
)
;
AudioLevel
(
const
AudioLevel
&
other
)
=
default
;
AudioLevel
&
operator
=
(
const
AudioLevel
&
other
)
=
default
;
bool
voice_activity
(
)
const
{
return
voice_activity_
;
}
int
level
(
)
const
{
return
audio_level_
;
}
private
:
bool
voice_activity_
;
int
audio_level_
;
}
;
inline
bool
operator
=
=
(
const
AbsoluteCaptureTime
&
lhs
const
AbsoluteCaptureTime
&
rhs
)
{
return
(
lhs
.
absolute_capture_timestamp
=
=
rhs
.
absolute_capture_timestamp
)
&
&
(
lhs
.
estimated_capture_clock_offset
=
=
rhs
.
estimated_capture_clock_offset
)
;
}
inline
bool
operator
!
=
(
const
AbsoluteCaptureTime
&
lhs
const
AbsoluteCaptureTime
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
enum
{
kRtpCsrcSize
=
15
}
;
struct
CsrcAudioLevelList
{
CsrcAudioLevelList
(
)
:
numAudioLevels
(
0
)
{
}
CsrcAudioLevelList
(
const
CsrcAudioLevelList
&
)
=
default
;
CsrcAudioLevelList
&
operator
=
(
const
CsrcAudioLevelList
&
)
=
default
;
uint8_t
numAudioLevels
;
uint8_t
arrOfAudioLevels
[
kRtpCsrcSize
]
;
}
;
struct
RTPHeaderExtension
{
RTPHeaderExtension
(
)
;
RTPHeaderExtension
(
const
RTPHeaderExtension
&
other
)
;
RTPHeaderExtension
&
operator
=
(
const
RTPHeaderExtension
&
other
)
;
static
constexpr
int
kAbsSendTimeFraction
=
18
;
Timestamp
GetAbsoluteSendTimestamp
(
)
const
{
RTC_DCHECK
(
hasAbsoluteSendTime
)
;
RTC_DCHECK
(
absoluteSendTime
<
(
1ul
<
<
24
)
)
;
return
Timestamp
:
:
Micros
(
(
absoluteSendTime
*
1000000ll
)
/
(
1
<
<
kAbsSendTimeFraction
)
)
;
}
bool
hasTransmissionTimeOffset
;
int32_t
transmissionTimeOffset
;
bool
hasAbsoluteSendTime
;
uint32_t
absoluteSendTime
;
absl
:
:
optional
<
AbsoluteCaptureTime
>
absolute_capture_time
;
bool
hasTransportSequenceNumber
;
uint16_t
transportSequenceNumber
;
absl
:
:
optional
<
FeedbackRequest
>
feedback_request
;
absl
:
:
optional
<
AudioLevel
>
audio_level
(
)
const
{
return
audio_level_
;
}
void
set_audio_level
(
absl
:
:
optional
<
AudioLevel
>
audio_level
)
{
audio_level_
=
audio_level
;
}
bool
hasVideoRotation
;
VideoRotation
videoRotation
;
bool
hasVideoContentType
;
VideoContentType
videoContentType
;
bool
has_video_timing
;
VideoSendTiming
video_timing
;
VideoPlayoutDelay
playout_delay
;
std
:
:
string
stream_id
;
std
:
:
string
repaired_stream_id
;
std
:
:
string
mid
;
absl
:
:
optional
<
ColorSpace
>
color_space
;
CsrcAudioLevelList
csrcAudioLevels
;
private
:
absl
:
:
optional
<
AudioLevel
>
audio_level_
;
}
;
struct
RTC_EXPORT
RTPHeader
{
RTPHeader
(
)
;
RTPHeader
(
const
RTPHeader
&
other
)
;
RTPHeader
&
operator
=
(
const
RTPHeader
&
other
)
;
bool
markerBit
;
uint8_t
payloadType
;
uint16_t
sequenceNumber
;
uint32_t
timestamp
;
uint32_t
ssrc
;
uint8_t
numCSRCs
;
uint32_t
arrOfCSRCs
[
kRtpCsrcSize
]
;
size_t
paddingLength
;
size_t
headerLength
;
RTPHeaderExtension
extension
;
}
;
enum
class
RtcpMode
{
kOff
kCompound
kReducedSize
}
;
enum
NetworkState
{
kNetworkUp
kNetworkDown
}
;
}
#
endif
