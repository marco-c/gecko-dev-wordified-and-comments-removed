#
ifndef
API_AUDIO_AUDIO_VIEW_H_
#
define
API_AUDIO_AUDIO_VIEW_H_
#
include
<
cstddef
>
#
include
<
iterator
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio
/
channel_layout
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
template
<
typename
T
>
using
MonoView
=
ArrayView
<
T
>
;
template
<
typename
T
>
class
InterleavedView
{
public
:
using
value_type
=
T
;
InterleavedView
(
)
=
default
;
template
<
typename
U
>
InterleavedView
(
U
*
data
size_t
samples_per_channel
size_t
num_channels
)
:
num_channels_
(
num_channels
)
samples_per_channel_
(
samples_per_channel
)
data_
(
data
num_channels
*
samples_per_channel
)
{
RTC_DCHECK_LE
(
num_channels_
kMaxConcurrentChannels
)
;
RTC_DCHECK
(
num_channels_
=
=
0u
|
|
samples_per_channel_
!
=
0u
)
;
}
template
<
typename
U
size_t
N
>
InterleavedView
(
U
(
&
array
)
[
N
]
size_t
num_channels
)
:
InterleavedView
(
array
N
/
num_channels
num_channels
)
{
RTC_DCHECK_EQ
(
N
%
num_channels
0u
)
;
}
template
<
typename
U
>
InterleavedView
(
const
InterleavedView
<
U
>
&
other
)
:
num_channels_
(
other
.
num_channels
(
)
)
samples_per_channel_
(
other
.
samples_per_channel
(
)
)
data_
(
other
.
data
(
)
)
{
}
size_t
num_channels
(
)
const
{
return
num_channels_
;
}
size_t
samples_per_channel
(
)
const
{
return
samples_per_channel_
;
}
ArrayView
<
T
>
data
(
)
const
{
return
data_
;
}
bool
empty
(
)
const
{
return
data_
.
empty
(
)
;
}
size_t
size
(
)
const
{
return
data_
.
size
(
)
;
}
MonoView
<
T
>
AsMono
(
)
const
{
RTC_DCHECK_EQ
(
num_channels
(
)
1u
)
;
RTC_DCHECK_EQ
(
data_
.
size
(
)
samples_per_channel_
)
;
return
data_
;
}
template
<
typename
U
>
void
CopyFrom
(
const
InterleavedView
<
U
>
&
source
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
U
)
"
"
)
;
RTC_DCHECK_EQ
(
num_channels
(
)
source
.
num_channels
(
)
)
;
RTC_DCHECK_EQ
(
samples_per_channel
(
)
source
.
samples_per_channel
(
)
)
;
RTC_DCHECK_GE
(
data_
.
size
(
)
source
.
data
(
)
.
size
(
)
)
;
const
auto
data
=
source
.
data
(
)
;
memcpy
(
&
data_
[
0
]
&
data
[
0
]
data
.
size
(
)
*
sizeof
(
U
)
)
;
}
T
&
operator
[
]
(
size_t
idx
)
const
{
return
data_
[
idx
]
;
}
T
*
begin
(
)
const
{
return
data_
.
begin
(
)
;
}
T
*
end
(
)
const
{
return
data_
.
end
(
)
;
}
const
T
*
cbegin
(
)
const
{
return
data_
.
cbegin
(
)
;
}
const
T
*
cend
(
)
const
{
return
data_
.
cend
(
)
;
}
std
:
:
reverse_iterator
<
T
*
>
rbegin
(
)
const
{
return
data_
.
rbegin
(
)
;
}
std
:
:
reverse_iterator
<
T
*
>
rend
(
)
const
{
return
data_
.
rend
(
)
;
}
std
:
:
reverse_iterator
<
const
T
*
>
crbegin
(
)
const
{
return
data_
.
crbegin
(
)
;
}
std
:
:
reverse_iterator
<
const
T
*
>
crend
(
)
const
{
return
data_
.
crend
(
)
;
}
private
:
size_t
num_channels_
=
0u
;
size_t
samples_per_channel_
=
0u
;
ArrayView
<
T
>
data_
;
}
;
template
<
typename
T
>
class
DeinterleavedView
{
public
:
using
value_type
=
T
;
DeinterleavedView
(
)
=
default
;
template
<
typename
U
>
DeinterleavedView
(
U
*
data
size_t
samples_per_channel
size_t
num_channels
)
:
num_channels_
(
num_channels
)
samples_per_channel_
(
samples_per_channel
)
data_
(
data
num_channels
*
samples_per_channel_
)
{
}
template
<
typename
U
>
DeinterleavedView
(
const
DeinterleavedView
<
U
>
&
other
)
:
num_channels_
(
other
.
num_channels
(
)
)
samples_per_channel_
(
other
.
samples_per_channel
(
)
)
data_
(
other
.
data
(
)
)
{
}
MonoView
<
T
>
operator
[
]
(
size_t
idx
)
const
{
RTC_DCHECK_LT
(
idx
num_channels_
)
;
return
MonoView
<
T
>
(
&
data_
[
idx
*
samples_per_channel_
]
samples_per_channel_
)
;
}
size_t
num_channels
(
)
const
{
return
num_channels_
;
}
size_t
samples_per_channel
(
)
const
{
return
samples_per_channel_
;
}
ArrayView
<
T
>
data
(
)
const
{
return
data_
;
}
bool
empty
(
)
const
{
return
data_
.
empty
(
)
;
}
size_t
size
(
)
const
{
return
data_
.
size
(
)
;
}
MonoView
<
T
>
AsMono
(
)
const
{
RTC_DCHECK_GE
(
num_channels
(
)
1u
)
;
return
(
*
this
)
[
0
]
;
}
private
:
size_t
num_channels_
=
0u
;
size_t
samples_per_channel_
=
0u
;
ArrayView
<
T
>
data_
;
}
;
template
<
typename
T
>
constexpr
size_t
NumChannels
(
const
MonoView
<
T
>
&
)
{
return
1u
;
}
template
<
typename
T
>
size_t
NumChannels
(
const
InterleavedView
<
T
>
&
view
)
{
return
view
.
num_channels
(
)
;
}
template
<
typename
T
>
size_t
NumChannels
(
const
DeinterleavedView
<
T
>
&
view
)
{
return
view
.
num_channels
(
)
;
}
template
<
typename
T
>
constexpr
bool
IsMono
(
const
MonoView
<
T
>
&
)
{
return
true
;
}
template
<
typename
T
>
constexpr
bool
IsInterleavedView
(
const
MonoView
<
T
>
&
)
{
return
true
;
}
template
<
typename
T
>
constexpr
bool
IsInterleavedView
(
const
InterleavedView
<
T
>
&
)
{
return
true
;
}
template
<
typename
T
>
constexpr
bool
IsInterleavedView
(
const
DeinterleavedView
<
const
T
>
&
)
{
return
false
;
}
template
<
typename
T
>
bool
IsMono
(
const
InterleavedView
<
T
>
&
view
)
{
return
NumChannels
(
view
)
=
=
1u
;
}
template
<
typename
T
>
bool
IsMono
(
const
DeinterleavedView
<
T
>
&
view
)
{
return
NumChannels
(
view
)
=
=
1u
;
}
template
<
typename
T
>
size_t
SamplesPerChannel
(
const
MonoView
<
T
>
&
view
)
{
return
view
.
size
(
)
;
}
template
<
typename
T
>
size_t
SamplesPerChannel
(
const
InterleavedView
<
T
>
&
view
)
{
return
view
.
samples_per_channel
(
)
;
}
template
<
typename
T
>
size_t
SamplesPerChannel
(
const
DeinterleavedView
<
T
>
&
view
)
{
return
view
.
samples_per_channel
(
)
;
}
template
<
typename
D
typename
S
>
void
CopySamples
(
D
&
destination
const
S
&
source
)
{
static_assert
(
sizeof
(
typename
D
:
:
value_type
)
=
=
sizeof
(
typename
S
:
:
value_type
)
"
"
)
;
RTC_DCHECK_EQ
(
NumChannels
(
destination
)
NumChannels
(
source
)
)
;
RTC_DCHECK_EQ
(
SamplesPerChannel
(
destination
)
SamplesPerChannel
(
source
)
)
;
RTC_DCHECK_GE
(
destination
.
size
(
)
source
.
size
(
)
)
;
memcpy
(
&
destination
[
0
]
&
source
[
0
]
source
.
size
(
)
*
sizeof
(
typename
S
:
:
value_type
)
)
;
}
template
<
typename
T
>
void
ClearSamples
(
T
&
view
)
{
memset
(
&
view
[
0
]
0
view
.
size
(
)
*
sizeof
(
typename
T
:
:
value_type
)
)
;
}
template
<
typename
T
>
void
ClearSamples
(
T
&
view
size_t
sample_count
)
{
RTC_DCHECK_LE
(
sample_count
view
.
size
(
)
)
;
memset
(
&
view
[
0
]
0
sample_count
*
sizeof
(
typename
T
:
:
value_type
)
)
;
}
}
#
endif
