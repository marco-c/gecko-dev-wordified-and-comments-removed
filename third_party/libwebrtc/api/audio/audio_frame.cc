#
include
"
api
/
audio
/
audio_frame
.
h
"
#
include
<
string
.
h
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
AudioFrame
:
:
AudioFrame
(
)
{
static_assert
(
sizeof
(
data_
)
=
=
kMaxDataSizeBytes
"
kMaxDataSizeBytes
"
)
;
}
void
AudioFrame
:
:
Reset
(
)
{
ResetWithoutMuting
(
)
;
muted_
=
true
;
}
void
AudioFrame
:
:
ResetWithoutMuting
(
)
{
timestamp_
=
0
;
elapsed_time_ms_
=
-
1
;
ntp_time_ms_
=
-
1
;
samples_per_channel_
=
0
;
sample_rate_hz_
=
0
;
num_channels_
=
0
;
channel_layout_
=
CHANNEL_LAYOUT_NONE
;
speech_type_
=
kUndefined
;
vad_activity_
=
kVadUnknown
;
profile_timestamp_ms_
=
0
;
packet_infos_
=
RtpPacketInfos
(
)
;
absolute_capture_timestamp_ms_
=
absl
:
:
nullopt
;
}
void
AudioFrame
:
:
UpdateFrame
(
uint32_t
timestamp
const
int16_t
*
data
size_t
samples_per_channel
int
sample_rate_hz
SpeechType
speech_type
VADActivity
vad_activity
size_t
num_channels
)
{
timestamp_
=
timestamp
;
samples_per_channel_
=
samples_per_channel
;
sample_rate_hz_
=
sample_rate_hz
;
speech_type_
=
speech_type
;
vad_activity_
=
vad_activity
;
num_channels_
=
num_channels
;
channel_layout_
=
GuessChannelLayout
(
num_channels
)
;
if
(
channel_layout_
!
=
CHANNEL_LAYOUT_UNSUPPORTED
)
{
RTC_DCHECK_EQ
(
num_channels
ChannelLayoutToChannelCount
(
channel_layout_
)
)
;
}
const
size_t
length
=
samples_per_channel
*
num_channels
;
RTC_CHECK_LE
(
length
kMaxDataSizeSamples
)
;
if
(
data
!
=
nullptr
)
{
memcpy
(
data_
data
sizeof
(
int16_t
)
*
length
)
;
muted_
=
false
;
}
else
{
muted_
=
true
;
}
}
void
AudioFrame
:
:
CopyFrom
(
const
AudioFrame
&
src
)
{
if
(
this
=
=
&
src
)
return
;
timestamp_
=
src
.
timestamp_
;
elapsed_time_ms_
=
src
.
elapsed_time_ms_
;
ntp_time_ms_
=
src
.
ntp_time_ms_
;
packet_infos_
=
src
.
packet_infos_
;
muted_
=
src
.
muted
(
)
;
samples_per_channel_
=
src
.
samples_per_channel_
;
sample_rate_hz_
=
src
.
sample_rate_hz_
;
speech_type_
=
src
.
speech_type_
;
vad_activity_
=
src
.
vad_activity_
;
num_channels_
=
src
.
num_channels_
;
channel_layout_
=
src
.
channel_layout_
;
absolute_capture_timestamp_ms_
=
src
.
absolute_capture_timestamp_ms
(
)
;
const
size_t
length
=
samples_per_channel_
*
num_channels_
;
RTC_CHECK_LE
(
length
kMaxDataSizeSamples
)
;
if
(
!
src
.
muted
(
)
)
{
memcpy
(
data_
src
.
data
(
)
sizeof
(
int16_t
)
*
length
)
;
muted_
=
false
;
}
}
void
AudioFrame
:
:
UpdateProfileTimeStamp
(
)
{
profile_timestamp_ms_
=
rtc
:
:
TimeMillis
(
)
;
}
int64_t
AudioFrame
:
:
ElapsedProfileTimeMs
(
)
const
{
if
(
profile_timestamp_ms_
=
=
0
)
{
return
-
1
;
}
return
rtc
:
:
TimeSince
(
profile_timestamp_ms_
)
;
}
const
int16_t
*
AudioFrame
:
:
data
(
)
const
{
return
muted_
?
empty_data
(
)
:
data_
;
}
int16_t
*
AudioFrame
:
:
mutable_data
(
)
{
if
(
muted_
)
{
memset
(
data_
0
kMaxDataSizeBytes
)
;
muted_
=
false
;
}
return
data_
;
}
void
AudioFrame
:
:
Mute
(
)
{
muted_
=
true
;
}
bool
AudioFrame
:
:
muted
(
)
const
{
return
muted_
;
}
void
AudioFrame
:
:
SetLayoutAndNumChannels
(
ChannelLayout
layout
size_t
num_channels
)
{
channel_layout_
=
layout
;
num_channels_
=
num_channels
;
#
if
RTC_DCHECK_IS_ON
auto
expected_num_channels
=
ChannelLayoutToChannelCount
(
layout
)
;
if
(
expected_num_channels
)
{
RTC_DCHECK_EQ
(
expected_num_channels
num_channels_
)
;
}
#
endif
RTC_CHECK_LE
(
samples_per_channel_
*
num_channels_
kMaxDataSizeSamples
)
;
}
const
int16_t
*
AudioFrame
:
:
empty_data
(
)
{
static
int16_t
*
null_data
=
new
int16_t
[
kMaxDataSizeSamples
]
(
)
;
return
&
null_data
[
0
]
;
}
}
