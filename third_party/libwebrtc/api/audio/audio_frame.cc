#
include
"
api
/
audio
/
audio_frame
.
h
"
#
include
<
string
.
h
>
#
include
<
cstdint
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio
/
audio_view
.
h
"
#
include
"
api
/
audio
/
channel_layout
.
h
"
#
include
"
api
/
rtp_packet_infos
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
webrtc
{
AudioFrame
:
:
AudioFrame
(
)
{
static_assert
(
sizeof
(
data_
)
=
=
kMaxDataSizeBytes
"
kMaxDataSizeBytes
"
)
;
}
AudioFrame
:
:
AudioFrame
(
int
sample_rate_hz
size_t
num_channels
ChannelLayout
layout
)
:
samples_per_channel_
(
SampleRateToDefaultChannelSize
(
sample_rate_hz
)
)
sample_rate_hz_
(
sample_rate_hz
)
num_channels_
(
num_channels
)
channel_layout_
(
layout
=
=
CHANNEL_LAYOUT_UNSUPPORTED
?
GuessChannelLayout
(
num_channels
)
:
layout
)
{
RTC_DCHECK_LE
(
num_channels_
kMaxConcurrentChannels
)
;
RTC_DCHECK_GT
(
sample_rate_hz_
0
)
;
RTC_DCHECK_GT
(
samples_per_channel_
0u
)
;
}
void
AudioFrame
:
:
Reset
(
)
{
ResetWithoutMuting
(
)
;
muted_
=
true
;
}
void
AudioFrame
:
:
ResetWithoutMuting
(
)
{
timestamp_
=
0
;
elapsed_time_ms_
=
-
1
;
ntp_time_ms_
=
-
1
;
samples_per_channel_
=
0
;
sample_rate_hz_
=
0
;
num_channels_
=
0
;
channel_layout_
=
CHANNEL_LAYOUT_NONE
;
speech_type_
=
kUndefined
;
vad_activity_
=
kVadUnknown
;
profile_timestamp_ms_
=
0
;
packet_infos_
=
RtpPacketInfos
(
)
;
absolute_capture_timestamp_ms_
=
absl
:
:
nullopt
;
}
void
AudioFrame
:
:
UpdateFrame
(
uint32_t
timestamp
const
int16_t
*
data
size_t
samples_per_channel
int
sample_rate_hz
SpeechType
speech_type
VADActivity
vad_activity
size_t
num_channels
)
{
RTC_CHECK_LE
(
num_channels
kMaxConcurrentChannels
)
;
timestamp_
=
timestamp
;
samples_per_channel_
=
samples_per_channel
;
sample_rate_hz_
=
sample_rate_hz
;
speech_type_
=
speech_type
;
vad_activity_
=
vad_activity
;
num_channels_
=
num_channels
;
channel_layout_
=
GuessChannelLayout
(
num_channels
)
;
if
(
channel_layout_
!
=
CHANNEL_LAYOUT_UNSUPPORTED
)
{
RTC_DCHECK_EQ
(
num_channels
ChannelLayoutToChannelCount
(
channel_layout_
)
)
;
}
const
size_t
length
=
samples_per_channel
*
num_channels
;
RTC_CHECK_LE
(
length
data_
.
size
(
)
)
;
if
(
data
!
=
nullptr
)
{
memcpy
(
data_
.
data
(
)
data
sizeof
(
int16_t
)
*
length
)
;
muted_
=
false
;
}
else
{
muted_
=
true
;
}
}
void
AudioFrame
:
:
CopyFrom
(
const
AudioFrame
&
src
)
{
if
(
this
=
=
&
src
)
return
;
if
(
muted_
&
&
!
src
.
muted
(
)
)
{
ClearSamples
(
data_
)
;
}
timestamp_
=
src
.
timestamp_
;
elapsed_time_ms_
=
src
.
elapsed_time_ms_
;
ntp_time_ms_
=
src
.
ntp_time_ms_
;
packet_infos_
=
src
.
packet_infos_
;
muted_
=
src
.
muted
(
)
;
samples_per_channel_
=
src
.
samples_per_channel_
;
sample_rate_hz_
=
src
.
sample_rate_hz_
;
speech_type_
=
src
.
speech_type_
;
vad_activity_
=
src
.
vad_activity_
;
num_channels_
=
src
.
num_channels_
;
channel_layout_
=
src
.
channel_layout_
;
absolute_capture_timestamp_ms_
=
src
.
absolute_capture_timestamp_ms
(
)
;
auto
data
=
src
.
data_view
(
)
;
RTC_CHECK_LE
(
data
.
size
(
)
data_
.
size
(
)
)
;
if
(
!
muted_
&
&
!
data
.
empty
(
)
)
{
memcpy
(
&
data_
[
0
]
&
data
[
0
]
sizeof
(
int16_t
)
*
data
.
size
(
)
)
;
}
}
void
AudioFrame
:
:
UpdateProfileTimeStamp
(
)
{
profile_timestamp_ms_
=
rtc
:
:
TimeMillis
(
)
;
}
int64_t
AudioFrame
:
:
ElapsedProfileTimeMs
(
)
const
{
if
(
profile_timestamp_ms_
=
=
0
)
{
return
-
1
;
}
return
rtc
:
:
TimeSince
(
profile_timestamp_ms_
)
;
}
const
int16_t
*
AudioFrame
:
:
data
(
)
const
{
return
muted_
?
zeroed_data
(
)
.
begin
(
)
:
data_
.
data
(
)
;
}
InterleavedView
<
const
int16_t
>
AudioFrame
:
:
data_view
(
)
const
{
return
InterleavedView
<
const
int16_t
>
(
muted_
?
&
zeroed_data
(
)
[
0
]
:
&
data_
[
0
]
samples_per_channel_
num_channels_
)
;
}
int16_t
*
AudioFrame
:
:
mutable_data
(
)
{
if
(
muted_
)
{
ClearSamples
(
data_
)
;
muted_
=
false
;
}
return
&
data_
[
0
]
;
}
InterleavedView
<
int16_t
>
AudioFrame
:
:
mutable_data
(
size_t
samples_per_channel
size_t
num_channels
)
{
const
size_t
total_samples
=
samples_per_channel
*
num_channels
;
RTC_CHECK_LE
(
total_samples
data_
.
size
(
)
)
;
RTC_CHECK_LE
(
num_channels
kMaxConcurrentChannels
)
;
RTC_DCHECK
(
(
samples_per_channel
=
=
0
&
&
num_channels
=
=
0
)
|
|
num_channels
<
=
samples_per_channel
)
<
<
"
samples_per_channel
=
"
<
<
samples_per_channel
<
<
"
num_channels
=
"
<
<
num_channels
;
if
(
muted_
)
{
ClearSamples
(
data_
total_samples
)
;
muted_
=
false
;
}
samples_per_channel_
=
samples_per_channel
;
num_channels_
=
num_channels
;
return
InterleavedView
<
int16_t
>
(
&
data_
[
0
]
samples_per_channel
num_channels
)
;
}
void
AudioFrame
:
:
Mute
(
)
{
muted_
=
true
;
}
bool
AudioFrame
:
:
muted
(
)
const
{
return
muted_
;
}
void
AudioFrame
:
:
SetLayoutAndNumChannels
(
ChannelLayout
layout
size_t
num_channels
)
{
channel_layout_
=
layout
;
num_channels_
=
num_channels
;
#
if
RTC_DCHECK_IS_ON
auto
expected_num_channels
=
ChannelLayoutToChannelCount
(
layout
)
;
if
(
expected_num_channels
)
{
RTC_DCHECK_EQ
(
expected_num_channels
num_channels_
)
;
}
#
endif
RTC_CHECK_LE
(
samples_per_channel_
*
num_channels_
data_
.
size
(
)
)
;
}
void
AudioFrame
:
:
SetSampleRateAndChannelSize
(
int
sample_rate
)
{
sample_rate_hz_
=
sample_rate
;
samples_per_channel_
=
SampleRateToDefaultChannelSize
(
sample_rate_hz_
)
;
}
rtc
:
:
ArrayView
<
const
int16_t
>
AudioFrame
:
:
zeroed_data
(
)
{
static
int16_t
*
null_data
=
new
int16_t
[
kMaxDataSizeSamples
]
(
)
;
return
rtc
:
:
ArrayView
<
const
int16_t
>
(
null_data
kMaxDataSizeSamples
)
;
}
}
