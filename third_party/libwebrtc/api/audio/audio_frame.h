#
ifndef
API_AUDIO_AUDIO_FRAME_H_
#
define
API_AUDIO_AUDIO_FRAME_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
array
>
#
include
<
optional
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio
/
audio_view
.
h
"
#
include
"
api
/
audio
/
channel_layout
.
h
"
#
include
"
api
/
rtp_packet_infos
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
constexpr
size_t
kDefaultAudioBufferLengthMs
=
10u
;
constexpr
size_t
kDefaultAudioBuffersPerSec
=
1000u
/
kDefaultAudioBufferLengthMs
;
inline
size_t
SampleRateToDefaultChannelSize
(
size_t
sample_rate
)
{
RTC_DCHECK_LE
(
sample_rate
192000
)
;
return
sample_rate
/
kDefaultAudioBuffersPerSec
;
}
class
AudioFrame
{
public
:
enum
:
size_t
{
kMaxDataSizeSamples
=
7680
kMaxDataSizeBytes
=
kMaxDataSizeSamples
*
sizeof
(
int16_t
)
}
;
enum
VADActivity
{
kVadActive
=
0
kVadPassive
=
1
kVadUnknown
=
2
}
;
enum
SpeechType
{
kNormalSpeech
=
0
kPLC
=
1
kCNG
=
2
kPLCCNG
=
3
kCodecPLC
=
5
kUndefined
=
4
}
;
AudioFrame
(
)
;
AudioFrame
(
int
sample_rate_hz
size_t
num_channels
ChannelLayout
layout
=
CHANNEL_LAYOUT_UNSUPPORTED
)
;
AudioFrame
(
const
AudioFrame
&
)
=
delete
;
AudioFrame
&
operator
=
(
const
AudioFrame
&
)
=
delete
;
void
Reset
(
)
;
void
ResetWithoutMuting
(
)
;
void
UpdateFrame
(
uint32_t
timestamp
const
int16_t
*
data
size_t
samples_per_channel
int
sample_rate_hz
SpeechType
speech_type
VADActivity
vad_activity
size_t
num_channels
=
1
)
;
void
CopyFrom
(
const
AudioFrame
&
src
)
;
void
UpdateProfileTimeStamp
(
)
;
int64_t
ElapsedProfileTimeMs
(
)
const
;
const
int16_t
*
data
(
)
const
;
InterleavedView
<
const
int16_t
>
data_view
(
)
const
;
int16_t
*
mutable_data
(
)
;
InterleavedView
<
int16_t
>
mutable_data
(
size_t
samples_per_channel
size_t
num_channels
)
;
void
Mute
(
)
;
bool
muted
(
)
const
;
size_t
max_16bit_samples
(
)
const
{
return
data_
.
size
(
)
;
}
size_t
samples_per_channel
(
)
const
{
return
samples_per_channel_
;
}
size_t
num_channels
(
)
const
{
return
num_channels_
;
}
ChannelLayout
channel_layout
(
)
const
{
return
channel_layout_
;
}
void
SetLayoutAndNumChannels
(
ChannelLayout
layout
size_t
num_channels
)
;
int
sample_rate_hz
(
)
const
{
return
sample_rate_hz_
;
}
void
set_absolute_capture_timestamp_ms
(
int64_t
absolute_capture_time_stamp_ms
)
{
absolute_capture_timestamp_ms_
=
absolute_capture_time_stamp_ms
;
}
std
:
:
optional
<
int64_t
>
absolute_capture_timestamp_ms
(
)
const
{
return
absolute_capture_timestamp_ms_
;
}
void
SetSampleRateAndChannelSize
(
int
sample_rate
)
;
uint32_t
timestamp_
=
0
;
int64_t
elapsed_time_ms_
=
-
1
;
int64_t
ntp_time_ms_
=
-
1
;
size_t
samples_per_channel_
=
0
;
int
sample_rate_hz_
=
0
;
size_t
num_channels_
=
0
;
SpeechType
speech_type_
=
kUndefined
;
VADActivity
vad_activity_
=
kVadUnknown
;
int64_t
profile_timestamp_ms_
=
0
;
RtpPacketInfos
packet_infos_
;
private
:
static
ArrayView
<
const
int16_t
>
zeroed_data
(
)
;
std
:
:
array
<
int16_t
kMaxDataSizeSamples
>
data_
;
bool
muted_
=
true
;
ChannelLayout
channel_layout_
=
CHANNEL_LAYOUT_NONE
;
std
:
:
optional
<
int64_t
>
absolute_capture_timestamp_ms_
;
}
;
}
#
endif
