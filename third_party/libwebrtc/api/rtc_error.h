#
ifndef
API_RTC_ERROR_H_
#
define
API_RTC_ERROR_H_
#
include
<
stdint
.
h
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
absl
/
strings
/
str_cat
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
webrtc
{
enum
class
RTCErrorType
{
NONE
UNSUPPORTED_OPERATION
UNSUPPORTED_PARAMETER
INVALID_PARAMETER
INVALID_RANGE
SYNTAX_ERROR
INVALID_STATE
INVALID_MODIFICATION
NETWORK_ERROR
RESOURCE_EXHAUSTED
INTERNAL_ERROR
OPERATION_ERROR_WITH_DATA
}
;
enum
class
RTCErrorDetailType
{
NONE
DATA_CHANNEL_FAILURE
DTLS_FAILURE
FINGERPRINT_FAILURE
SCTP_FAILURE
SDP_SYNTAX_ERROR
HARDWARE_ENCODER_NOT_AVAILABLE
HARDWARE_ENCODER_ERROR
}
;
RTC_EXPORT
absl
:
:
string_view
ToString
(
RTCErrorType
error
)
;
RTC_EXPORT
absl
:
:
string_view
ToString
(
RTCErrorDetailType
error
)
;
template
<
typename
Sink
>
void
AbslStringify
(
Sink
&
sink
RTCErrorType
error
)
{
sink
.
Append
(
ToString
(
error
)
)
;
}
template
<
typename
Sink
>
void
AbslStringify
(
Sink
&
sink
RTCErrorDetailType
error_detail
)
{
sink
.
Append
(
ToString
(
error_detail
)
)
;
}
class
RTC_EXPORT
RTCError
{
public
:
RTCError
(
)
{
}
explicit
RTCError
(
RTCErrorType
type
)
:
type_
(
type
)
{
}
RTCError
(
RTCErrorType
type
absl
:
:
string_view
message
)
:
type_
(
type
)
message_
(
message
)
{
}
RTCError
(
const
RTCError
&
other
)
=
default
;
RTCError
(
RTCError
&
&
)
=
default
;
RTCError
&
operator
=
(
const
RTCError
&
other
)
=
default
;
RTCError
&
operator
=
(
RTCError
&
&
)
=
default
;
static
RTCError
OK
(
)
;
RTCErrorType
type
(
)
const
{
return
type_
;
}
void
set_type
(
RTCErrorType
type
)
{
type_
=
type
;
}
const
char
*
message
(
)
const
;
void
set_message
(
absl
:
:
string_view
message
)
;
RTCErrorDetailType
error_detail
(
)
const
{
return
error_detail_
;
}
void
set_error_detail
(
RTCErrorDetailType
detail
)
{
error_detail_
=
detail
;
}
std
:
:
optional
<
uint16_t
>
sctp_cause_code
(
)
const
{
return
sctp_cause_code_
;
}
void
set_sctp_cause_code
(
uint16_t
cause_code
)
{
sctp_cause_code_
=
cause_code
;
}
bool
ok
(
)
const
{
return
type_
=
=
RTCErrorType
:
:
NONE
;
}
template
<
typename
Sink
>
friend
void
AbslStringify
(
Sink
&
sink
const
RTCError
&
error
)
{
sink
.
Append
(
ToString
(
error
.
type_
)
)
;
if
(
!
error
.
message_
.
empty
(
)
)
{
sink
.
Append
(
"
with
message
:
\
"
"
)
;
sink
.
Append
(
error
.
message_
)
;
sink
.
Append
(
"
\
"
"
)
;
}
}
private
:
RTCErrorType
type_
=
RTCErrorType
:
:
NONE
;
std
:
:
string
message_
;
RTCErrorDetailType
error_detail_
=
RTCErrorDetailType
:
:
NONE
;
std
:
:
optional
<
uint16_t
>
sctp_cause_code_
;
}
;
#
define
LOG_AND_RETURN_ERROR_EX
(
type
message
severity
)
\
{
\
RTC_DCHECK
(
type
!
=
RTCErrorType
:
:
NONE
)
;
\
RTC_LOG
(
severity
)
<
<
message
<
<
"
(
"
<
<
:
:
webrtc
:
:
ToString
(
type
)
<
<
"
)
"
;
\
return
:
:
webrtc
:
:
RTCError
(
type
message
)
;
\
}
#
define
LOG_AND_RETURN_ERROR
(
type
message
)
\
LOG_AND_RETURN_ERROR_EX
(
type
message
LS_ERROR
)
template
<
typename
T
>
class
RTCErrorOr
{
template
<
typename
U
>
friend
class
RTCErrorOr
;
public
:
typedef
T
element_type
;
RTCErrorOr
(
)
:
error_
(
RTCErrorType
:
:
INTERNAL_ERROR
)
{
}
RTCErrorOr
(
RTCError
&
&
error
)
:
error_
(
std
:
:
move
(
error
)
)
{
RTC_DCHECK
(
!
error_
.
ok
(
)
)
;
}
RTCErrorOr
(
const
T
&
value
)
:
value_
(
value
)
{
}
RTCErrorOr
(
T
&
&
value
)
:
value_
(
std
:
:
move
(
value
)
)
{
}
RTCErrorOr
(
const
RTCErrorOr
&
other
)
=
delete
;
RTCErrorOr
&
operator
=
(
const
RTCErrorOr
&
other
)
=
delete
;
RTCErrorOr
(
RTCErrorOr
&
&
other
)
:
error_
(
std
:
:
move
(
other
.
error_
)
)
value_
(
std
:
:
move
(
other
.
value_
)
)
{
}
RTCErrorOr
&
operator
=
(
RTCErrorOr
&
&
other
)
{
error_
=
std
:
:
move
(
other
.
error_
)
;
value_
=
std
:
:
move
(
other
.
value_
)
;
return
*
this
;
}
template
<
typename
U
>
RTCErrorOr
(
RTCErrorOr
<
U
>
other
)
:
error_
(
std
:
:
move
(
other
.
error_
)
)
value_
(
std
:
:
move
(
other
.
value_
)
)
{
}
template
<
typename
U
>
RTCErrorOr
&
operator
=
(
RTCErrorOr
<
U
>
other
)
{
error_
=
std
:
:
move
(
other
.
error_
)
;
value_
=
std
:
:
move
(
other
.
value_
)
;
return
*
this
;
}
const
RTCError
&
error
(
)
const
{
return
error_
;
}
RTCError
MoveError
(
)
{
return
std
:
:
move
(
error_
)
;
}
bool
ok
(
)
const
{
return
error_
.
ok
(
)
;
}
const
T
&
value
(
)
const
{
RTC_DCHECK
(
ok
(
)
)
;
return
*
value_
;
}
T
&
value
(
)
{
RTC_DCHECK
(
ok
(
)
)
;
return
*
value_
;
}
T
MoveValue
(
)
{
RTC_DCHECK
(
ok
(
)
)
;
return
std
:
:
move
(
*
value_
)
;
}
template
<
typename
Sink
>
friend
void
AbslStringify
(
Sink
&
sink
const
RTCErrorOr
<
T
>
&
error_or
)
{
if
(
error_or
.
ok
(
)
)
{
sink
.
Append
(
"
OK
"
)
;
if
constexpr
(
std
:
:
is_convertible_v
<
T
absl
:
:
AlphaNum
>
)
{
sink
.
Append
(
"
with
value
:
"
)
;
sink
.
Append
(
absl
:
:
StrCat
(
error_or
.
value
(
)
)
)
;
}
}
else
{
sink
.
Append
(
absl
:
:
StrCat
(
error_or
.
error
(
)
)
)
;
}
}
private
:
RTCError
error_
;
std
:
:
optional
<
T
>
value_
;
}
;
}
#
endif
