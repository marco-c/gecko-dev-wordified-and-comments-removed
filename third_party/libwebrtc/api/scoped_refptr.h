#
ifndef
API_SCOPED_REFPTR_H_
#
define
API_SCOPED_REFPTR_H_
#
include
<
memory
>
#
include
<
utility
>
namespace
rtc
{
template
<
class
T
>
class
scoped_refptr
{
public
:
typedef
T
element_type
;
scoped_refptr
(
)
:
ptr_
(
nullptr
)
{
}
scoped_refptr
(
T
*
p
)
:
ptr_
(
p
)
{
if
(
ptr_
)
ptr_
-
>
AddRef
(
)
;
}
scoped_refptr
(
const
scoped_refptr
<
T
>
&
r
)
:
ptr_
(
r
.
ptr_
)
{
if
(
ptr_
)
ptr_
-
>
AddRef
(
)
;
}
template
<
typename
U
>
scoped_refptr
(
const
scoped_refptr
<
U
>
&
r
)
:
ptr_
(
r
.
get
(
)
)
{
if
(
ptr_
)
ptr_
-
>
AddRef
(
)
;
}
scoped_refptr
(
scoped_refptr
<
T
>
&
&
r
)
noexcept
:
ptr_
(
r
.
release
(
)
)
{
}
template
<
typename
U
>
scoped_refptr
(
scoped_refptr
<
U
>
&
&
r
)
noexcept
:
ptr_
(
r
.
release
(
)
)
{
}
~
scoped_refptr
(
)
{
if
(
ptr_
)
ptr_
-
>
Release
(
)
;
}
T
*
get
(
)
const
{
return
ptr_
;
}
operator
T
*
(
)
const
{
return
ptr_
;
}
T
&
operator
*
(
)
const
{
return
*
ptr_
;
}
T
*
operator
-
>
(
)
const
{
return
ptr_
;
}
T
*
release
(
)
{
T
*
retVal
=
ptr_
;
ptr_
=
nullptr
;
return
retVal
;
}
scoped_refptr
<
T
>
&
operator
=
(
T
*
p
)
{
if
(
p
)
p
-
>
AddRef
(
)
;
if
(
ptr_
)
ptr_
-
>
Release
(
)
;
ptr_
=
p
;
return
*
this
;
}
scoped_refptr
<
T
>
&
operator
=
(
const
scoped_refptr
<
T
>
&
r
)
{
return
*
this
=
r
.
ptr_
;
}
template
<
typename
U
>
scoped_refptr
<
T
>
&
operator
=
(
const
scoped_refptr
<
U
>
&
r
)
{
return
*
this
=
r
.
get
(
)
;
}
scoped_refptr
<
T
>
&
operator
=
(
scoped_refptr
<
T
>
&
&
r
)
noexcept
{
scoped_refptr
<
T
>
(
std
:
:
move
(
r
)
)
.
swap
(
*
this
)
;
return
*
this
;
}
template
<
typename
U
>
scoped_refptr
<
T
>
&
operator
=
(
scoped_refptr
<
U
>
&
&
r
)
noexcept
{
scoped_refptr
<
T
>
(
std
:
:
move
(
r
)
)
.
swap
(
*
this
)
;
return
*
this
;
}
void
swap
(
T
*
*
pp
)
noexcept
{
T
*
p
=
ptr_
;
ptr_
=
*
pp
;
*
pp
=
p
;
}
void
swap
(
scoped_refptr
<
T
>
&
r
)
noexcept
{
swap
(
&
r
.
ptr_
)
;
}
protected
:
T
*
ptr_
;
}
;
}
#
endif
