#
ifndef
API_TRANSPORT_RTP_CORRUPTION_DETECTION_MESSAGE_H_
#
define
API_TRANSPORT_RTP_CORRUPTION_DETECTION_MESSAGE_H_
#
include
<
cstddef
>
#
include
<
optional
>
#
include
"
absl
/
container
/
inlined_vector
.
h
"
#
include
"
api
/
array_view
.
h
"
namespace
webrtc
{
class
CorruptionDetectionMessage
{
public
:
class
Builder
;
CorruptionDetectionMessage
(
)
=
default
;
CorruptionDetectionMessage
(
const
CorruptionDetectionMessage
&
)
=
default
;
CorruptionDetectionMessage
&
operator
=
(
const
CorruptionDetectionMessage
&
)
=
default
;
~
CorruptionDetectionMessage
(
)
=
default
;
int
sequence_index
(
)
const
{
return
sequence_index_
;
}
bool
interpret_sequence_index_as_most_significant_bits
(
)
const
{
return
interpret_sequence_index_as_most_significant_bits_
;
}
double
std_dev
(
)
const
{
return
std_dev_
;
}
int
luma_error_threshold
(
)
const
{
return
luma_error_threshold_
;
}
int
chroma_error_threshold
(
)
const
{
return
chroma_error_threshold_
;
}
ArrayView
<
const
double
>
sample_values
(
)
const
{
return
MakeArrayView
(
sample_values_
.
data
(
)
sample_values_
.
size
(
)
)
;
}
private
:
friend
class
CorruptionDetectionExtension
;
static
const
size_t
kMaxSampleSize
=
13
;
int
sequence_index_
=
0
;
bool
interpret_sequence_index_as_most_significant_bits_
=
false
;
double
std_dev_
=
0
.
0
;
int
luma_error_threshold_
=
0
;
int
chroma_error_threshold_
=
0
;
absl
:
:
InlinedVector
<
double
kMaxSampleSize
>
sample_values_
;
}
;
class
CorruptionDetectionMessage
:
:
Builder
{
public
:
Builder
(
)
=
default
;
Builder
(
const
Builder
&
)
=
default
;
Builder
&
operator
=
(
const
Builder
&
)
=
default
;
~
Builder
(
)
=
default
;
std
:
:
optional
<
CorruptionDetectionMessage
>
Build
(
)
{
if
(
message_
.
sequence_index_
<
0
|
|
message_
.
sequence_index_
>
0b0111
'
1111
)
{
return
std
:
:
nullopt
;
}
if
(
message_
.
std_dev_
<
0
.
0
|
|
message_
.
std_dev_
>
40
.
0
)
{
return
std
:
:
nullopt
;
}
if
(
message_
.
luma_error_threshold_
<
0
|
|
message_
.
luma_error_threshold_
>
15
)
{
return
std
:
:
nullopt
;
}
if
(
message_
.
chroma_error_threshold_
<
0
|
|
message_
.
chroma_error_threshold_
>
15
)
{
return
std
:
:
nullopt
;
}
if
(
message_
.
sample_values_
.
size
(
)
>
kMaxSampleSize
)
{
return
std
:
:
nullopt
;
}
for
(
double
sample_value
:
message_
.
sample_values_
)
{
if
(
sample_value
<
0
.
0
|
|
sample_value
>
255
.
0
)
{
return
std
:
:
nullopt
;
}
}
return
message_
;
}
Builder
&
WithSequenceIndex
(
int
sequence_index
)
{
message_
.
sequence_index_
=
sequence_index
;
return
*
this
;
}
Builder
&
WithInterpretSequenceIndexAsMostSignificantBits
(
bool
interpret_sequence_index_as_most_significant_bits
)
{
message_
.
interpret_sequence_index_as_most_significant_bits_
=
interpret_sequence_index_as_most_significant_bits
;
return
*
this
;
}
Builder
&
WithStdDev
(
double
std_dev
)
{
message_
.
std_dev_
=
std_dev
;
return
*
this
;
}
Builder
&
WithLumaErrorThreshold
(
int
luma_error_threshold
)
{
message_
.
luma_error_threshold_
=
luma_error_threshold
;
return
*
this
;
}
Builder
&
WithChromaErrorThreshold
(
int
chroma_error_threshold
)
{
message_
.
chroma_error_threshold_
=
chroma_error_threshold
;
return
*
this
;
}
Builder
&
WithSampleValues
(
const
ArrayView
<
const
double
>
&
sample_values
)
{
message_
.
sample_values_
.
assign
(
sample_values
.
cbegin
(
)
sample_values
.
cend
(
)
)
;
return
*
this
;
}
private
:
CorruptionDetectionMessage
message_
;
}
;
}
#
endif
