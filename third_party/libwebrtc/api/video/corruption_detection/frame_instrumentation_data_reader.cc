#
include
"
api
/
video
/
corruption_detection
/
frame_instrumentation_data_reader
.
h
"
#
include
<
optional
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
transport
/
rtp
/
corruption_detection_message
.
h
"
#
include
"
api
/
video
/
corruption_detection
/
frame_instrumentation_data
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
std
:
:
optional
<
FrameInstrumentationData
>
FrameInstrumentationDataReader
:
:
ParseMessage
(
const
CorruptionDetectionMessage
&
message
)
{
FrameInstrumentationData
data
;
if
(
message
.
interpret_sequence_index_as_most_significant_bits
(
)
)
{
data
.
SetSequenceIndex
(
message
.
sequence_index
(
)
<
<
7
)
;
}
else
{
if
(
!
last_seen_sequence_index_
.
has_value
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Got
Corruption
Detection
Message
with
relative
sequence
index
"
"
where
no
earlier
sequence
index
is
know
.
Ignoring
.
"
;
return
std
:
:
nullopt
;
}
int
upper_bits
=
*
last_seen_sequence_index_
&
0b0011
'
1111
'
1000
'
0000
;
if
(
message
.
sequence_index
(
)
<
(
*
last_seen_sequence_index_
&
0b0111
'
1111
)
)
{
upper_bits
+
=
0b1000
'
0000
;
}
data
.
SetSequenceIndex
(
upper_bits
+
message
.
sequence_index
(
)
)
;
}
ArrayView
<
const
double
>
sample_values
=
message
.
sample_values
(
)
;
last_seen_sequence_index_
=
data
.
sequence_index
(
)
+
sample_values
.
size
(
)
;
if
(
!
sample_values
.
empty
(
)
)
{
data
.
SetStdDev
(
message
.
std_dev
(
)
)
;
data
.
SetLumaErrorThreshold
(
message
.
luma_error_threshold
(
)
)
;
data
.
SetChromaErrorThreshold
(
message
.
chroma_error_threshold
(
)
)
;
data
.
SetSampleValues
(
sample_values
)
;
}
return
data
;
}
}
