#
ifndef
API_WRAPPING_ASYNC_DNS_RESOLVER_H_
#
define
API_WRAPPING_ASYNC_DNS_RESOLVER_H_
#
include
<
functional
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
absl
/
memory
/
memory
.
h
"
#
include
"
api
/
async_dns_resolver
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
async_resolver
.
h
"
#
include
"
rtc_base
/
async_resolver_interface
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
socket_address
.
h
"
#
include
"
rtc_base
/
third_party
/
sigslot
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
namespace
webrtc
{
class
WrappingAsyncDnsResolver
;
class
RTC_EXPORT
WrappingAsyncDnsResolverResult
:
public
AsyncDnsResolverResult
{
public
:
explicit
WrappingAsyncDnsResolverResult
(
WrappingAsyncDnsResolver
*
owner
)
:
owner_
(
owner
)
{
}
~
WrappingAsyncDnsResolverResult
(
)
{
}
bool
GetResolvedAddress
(
int
family
rtc
:
:
SocketAddress
*
addr
)
const
override
;
int
GetError
(
)
const
override
;
private
:
WrappingAsyncDnsResolver
*
const
owner_
;
}
;
class
RTC_EXPORT
WrappingAsyncDnsResolver
:
public
AsyncDnsResolverInterface
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
WrappingAsyncDnsResolver
(
rtc
:
:
AsyncResolverInterface
*
wrapped
)
:
wrapped_
(
absl
:
:
WrapUnique
(
wrapped
)
)
result_
(
this
)
{
}
~
WrappingAsyncDnsResolver
(
)
override
{
RTC_CHECK
(
!
within_resolve_result_
)
;
wrapped_
.
release
(
)
-
>
Destroy
(
false
)
;
}
void
Start
(
const
rtc
:
:
SocketAddress
&
addr
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
override
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
PrepareToResolve
(
std
:
:
move
(
callback
)
)
;
wrapped_
-
>
Start
(
addr
)
;
}
void
Start
(
const
rtc
:
:
SocketAddress
&
addr
int
family
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
override
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
PrepareToResolve
(
std
:
:
move
(
callback
)
)
;
wrapped_
-
>
Start
(
addr
family
)
;
}
const
AsyncDnsResolverResult
&
result
(
)
const
override
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
RTC_DCHECK_EQ
(
State
:
:
kResolved
state_
)
;
return
result_
;
}
private
:
enum
class
State
{
kNotStarted
kStarted
kResolved
}
;
friend
class
WrappingAsyncDnsResolverResult
;
rtc
:
:
AsyncResolverInterface
*
wrapped
(
)
const
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
return
wrapped_
.
get
(
)
;
}
void
PrepareToResolve
(
absl
:
:
AnyInvocable
<
void
(
)
>
callback
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
RTC_DCHECK_EQ
(
State
:
:
kNotStarted
state_
)
;
state_
=
State
:
:
kStarted
;
callback_
=
std
:
:
move
(
callback
)
;
wrapped_
-
>
SignalDone
.
connect
(
this
&
WrappingAsyncDnsResolver
:
:
OnResolveResult
)
;
}
void
OnResolveResult
(
rtc
:
:
AsyncResolverInterface
*
ref
)
{
RTC_DCHECK_RUN_ON
(
&
sequence_checker_
)
;
RTC_DCHECK
(
state_
=
=
State
:
:
kStarted
)
;
RTC_DCHECK_EQ
(
ref
wrapped_
.
get
(
)
)
;
state_
=
State
:
:
kResolved
;
within_resolve_result_
=
true
;
callback_
(
)
;
within_resolve_result_
=
false
;
}
SequenceChecker
sequence_checker_
;
absl
:
:
AnyInvocable
<
void
(
)
>
callback_
RTC_GUARDED_BY
(
sequence_checker_
)
;
std
:
:
unique_ptr
<
rtc
:
:
AsyncResolverInterface
>
wrapped_
RTC_GUARDED_BY
(
sequence_checker_
)
;
State
state_
RTC_GUARDED_BY
(
sequence_checker_
)
=
State
:
:
kNotStarted
;
WrappingAsyncDnsResolverResult
result_
RTC_GUARDED_BY
(
sequence_checker_
)
;
bool
within_resolve_result_
RTC_GUARDED_BY
(
sequence_checker_
)
=
false
;
}
;
}
#
endif
