#
ifndef
API_JSEP_H_
#
define
API_JSEP_H_
#
include
<
stddef
.
h
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
absl
/
strings
/
str_format
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
ref_count
.
h
"
#
include
"
api
/
rtc_error
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
system
/
no_unique_address
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
namespace
webrtc
{
class
SessionDescription
;
struct
SdpParseError
{
public
:
std
:
:
string
line
;
std
:
:
string
description
;
}
;
class
RTC_EXPORT
IceCandidate
final
{
public
:
IceCandidate
(
absl
:
:
string_view
sdp_mid
int
sdp_mline_index
const
Candidate
&
candidate
)
;
~
IceCandidate
(
)
=
default
;
IceCandidate
(
const
IceCandidate
&
)
=
delete
;
IceCandidate
&
operator
=
(
const
IceCandidate
&
)
=
delete
;
static
std
:
:
unique_ptr
<
IceCandidate
>
Create
(
absl
:
:
string_view
mid
int
sdp_mline_index
absl
:
:
string_view
sdp
SdpParseError
*
absl_nullable
error
=
nullptr
)
;
std
:
:
string
sdp_mid
(
)
const
{
return
sdp_mid_
;
}
int
sdp_mline_index
(
)
const
{
return
sdp_mline_index_
;
}
const
Candidate
&
candidate
(
)
const
{
return
candidate_
;
}
std
:
:
string
server_url
(
)
const
{
return
candidate_
.
url
(
)
;
}
std
:
:
string
ToString
(
)
const
;
bool
ToString
(
std
:
:
string
*
out
)
const
{
if
(
!
out
)
return
false
;
*
out
=
ToString
(
)
;
return
!
out
-
>
empty
(
)
;
}
template
<
typename
Sink
>
friend
void
AbslStringify
(
Sink
&
sink
const
IceCandidate
&
c
)
{
absl
:
:
Format
(
&
sink
"
IceCandidate
:
{
'
%
s
'
%
i
'
%
s
'
}
"
c
.
sdp_mid_
.
c_str
(
)
c
.
sdp_mline_index_
c
.
ToString
(
)
.
c_str
(
)
)
;
}
private
:
const
std
:
:
string
sdp_mid_
;
const
int
sdp_mline_index_
;
const
Candidate
candidate_
;
}
;
using
JsepIceCandidate
=
IceCandidate
;
using
IceCandidateInterface
=
IceCandidate
;
RTC_EXPORT
IceCandidate
*
CreateIceCandidate
(
const
std
:
:
string
&
sdp_mid
int
sdp_mline_index
const
std
:
:
string
&
sdp
SdpParseError
*
error
)
;
RTC_EXPORT
std
:
:
unique_ptr
<
IceCandidate
>
CreateIceCandidate
(
const
std
:
:
string
&
sdp_mid
int
sdp_mline_index
const
Candidate
&
candidate
)
;
class
IceCandidateCollection
final
{
public
:
IceCandidateCollection
(
)
=
default
;
explicit
IceCandidateCollection
(
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
&
&
candidates
)
:
candidates_
(
std
:
:
move
(
candidates
)
)
{
}
~
IceCandidateCollection
(
)
=
default
;
IceCandidateCollection
(
IceCandidateCollection
&
&
o
)
=
default
;
IceCandidateCollection
(
const
IceCandidateCollection
&
)
=
delete
;
IceCandidateCollection
&
operator
=
(
const
IceCandidateCollection
&
)
=
delete
;
size_t
count
(
)
const
{
return
candidates_
.
size
(
)
;
}
bool
empty
(
)
const
{
return
candidates_
.
empty
(
)
;
}
const
IceCandidate
*
at
(
size_t
index
)
const
;
void
add
(
std
:
:
unique_ptr
<
IceCandidate
>
candidate
)
;
[
[
deprecated
(
"
Use
unique_ptr
version
"
)
]
]
void
add
(
IceCandidate
*
candidate
)
;
void
Append
(
IceCandidateCollection
collection
)
;
size_t
remove
(
const
IceCandidate
*
candidate
)
;
const
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
&
candidates
(
)
const
{
return
candidates_
;
}
bool
HasCandidate
(
const
IceCandidate
*
candidate
)
const
;
IceCandidateCollection
Clone
(
)
const
;
private
:
std
:
:
vector
<
std
:
:
unique_ptr
<
IceCandidate
>
>
candidates_
;
}
;
using
JsepCandidateCollection
=
IceCandidateCollection
;
enum
class
SdpType
{
kOffer
kPrAnswer
kAnswer
kRollback
}
;
RTC_EXPORT
const
char
*
SdpTypeToString
(
SdpType
type
)
;
template
<
typename
Sink
>
void
AbslStringify
(
Sink
&
sink
SdpType
sdp_type
)
{
sink
.
Append
(
SdpTypeToString
(
sdp_type
)
)
;
}
RTC_EXPORT
std
:
:
optional
<
SdpType
>
SdpTypeFromString
(
const
std
:
:
string
&
type_str
)
;
class
SessionDescriptionInternal
{
public
:
explicit
SessionDescriptionInternal
(
SdpType
type
absl_nullable
std
:
:
unique_ptr
<
SessionDescription
>
description
absl
:
:
string_view
id
absl
:
:
string_view
version
)
;
~
SessionDescriptionInternal
(
)
;
void
RelinquishThreadOwnership
(
)
;
protected
:
SdpType
sdp_type
(
)
const
{
return
sdp_type_
;
}
absl
:
:
string_view
id
(
)
const
{
return
id_
;
}
absl
:
:
string_view
version
(
)
const
{
return
version_
;
}
const
SessionDescription
*
description
(
)
const
{
return
description_
.
get
(
)
;
}
SessionDescription
*
description
(
)
{
return
description_
.
get
(
)
;
}
size_t
mediasection_count
(
)
const
;
protected
:
SequenceChecker
&
sequence_checker
(
)
{
return
sequence_checker_
;
}
private
:
RTC_NO_UNIQUE_ADDRESS
SequenceChecker
sequence_checker_
{
SequenceChecker
:
:
kDetached
}
;
const
SdpType
sdp_type_
;
const
std
:
:
string
id_
;
const
std
:
:
string
version_
;
absl_nullable
const
std
:
:
unique_ptr
<
SessionDescription
>
description_
;
}
;
class
RTC_EXPORT
SessionDescriptionInterface
:
public
SessionDescriptionInternal
{
public
:
static
const
char
kOffer
[
]
;
static
const
char
kPrAnswer
[
]
;
static
const
char
kAnswer
[
]
;
static
const
char
kRollback
[
]
;
virtual
~
SessionDescriptionInterface
(
)
{
}
virtual
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
Clone
(
)
const
=
0
;
virtual
SessionDescription
*
description
(
)
{
return
SessionDescriptionInternal
:
:
description
(
)
;
}
virtual
const
SessionDescription
*
description
(
)
const
{
return
SessionDescriptionInternal
:
:
description
(
)
;
}
virtual
std
:
:
string
session_id
(
)
const
{
return
std
:
:
string
(
id
(
)
)
;
}
virtual
std
:
:
string
session_version
(
)
const
{
return
std
:
:
string
(
version
(
)
)
;
}
virtual
SdpType
GetType
(
)
const
{
return
sdp_type
(
)
;
}
virtual
std
:
:
string
type
(
)
const
{
return
SdpTypeToString
(
sdp_type
(
)
)
;
}
virtual
bool
AddCandidate
(
const
IceCandidate
*
candidate
)
=
0
;
virtual
bool
RemoveCandidate
(
const
IceCandidate
*
candidate
)
=
0
;
virtual
size_t
number_of_mediasections
(
)
const
{
return
mediasection_count
(
)
;
}
virtual
const
IceCandidateCollection
*
candidates
(
size_t
mediasection_index
)
const
=
0
;
virtual
bool
ToString
(
std
:
:
string
*
out
)
const
=
0
;
template
<
typename
Sink
>
friend
void
AbslStringify
(
Sink
&
sink
const
SessionDescriptionInterface
&
p
)
{
sink
.
Append
(
"
\
n
-
-
-
BEGIN
SDP
"
)
;
absl
:
:
Format
(
&
sink
"
%
v
"
p
.
GetType
(
)
)
;
sink
.
Append
(
"
-
-
-
\
n
"
)
;
std
:
:
string
temp
;
if
(
p
.
ToString
(
&
temp
)
)
{
sink
.
Append
(
temp
)
;
}
else
{
sink
.
Append
(
"
Error
in
ToString
\
n
"
)
;
}
sink
.
Append
(
"
-
-
-
END
SDP
-
-
-
\
n
"
)
;
}
protected
:
explicit
SessionDescriptionInterface
(
SdpType
type
std
:
:
unique_ptr
<
SessionDescription
>
description
absl
:
:
string_view
id
absl
:
:
string_view
version
)
;
}
;
RTC_EXPORT
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateSessionDescription
(
SdpType
type
const
std
:
:
string
&
sdp
)
;
RTC_EXPORT
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateSessionDescription
(
SdpType
type
const
std
:
:
string
&
sdp
SdpParseError
*
error_out
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateSessionDescription
(
SdpType
type
const
std
:
:
string
&
session_id
const
std
:
:
string
&
session_version
std
:
:
unique_ptr
<
SessionDescription
>
description
)
;
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
CreateRollbackSessionDescription
(
absl
:
:
string_view
session_id
=
"
"
absl
:
:
string_view
session_version
=
"
"
)
;
class
RTC_EXPORT
CreateSessionDescriptionObserver
:
public
RefCountInterface
{
public
:
virtual
void
OnSuccess
(
SessionDescriptionInterface
*
desc
)
=
0
;
virtual
void
OnFailure
(
RTCError
error
)
=
0
;
protected
:
~
CreateSessionDescriptionObserver
(
)
override
=
default
;
}
;
class
RTC_EXPORT
SetSessionDescriptionObserver
:
public
RefCountInterface
{
public
:
virtual
void
OnSuccess
(
)
=
0
;
virtual
void
OnFailure
(
RTCError
error
)
=
0
;
protected
:
~
SetSessionDescriptionObserver
(
)
override
=
default
;
}
;
}
#
endif
