#
ifndef
API_STATS_RTC_STATS_H_
#
define
API_STATS_RTC_STATS_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
stats
/
attribute
.
h
"
#
include
"
api
/
stats
/
rtc_stats_member
.
h
"
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
#
include
"
rtc_base
/
system
/
rtc_export_template
.
h
"
namespace
webrtc
{
class
RTC_EXPORT
RTCStats
{
public
:
RTCStats
(
const
std
:
:
string
&
id
Timestamp
timestamp
)
:
id_
(
id
)
timestamp_
(
timestamp
)
{
}
RTCStats
(
const
RTCStats
&
other
)
;
virtual
~
RTCStats
(
)
;
virtual
std
:
:
unique_ptr
<
RTCStats
>
copy
(
)
const
=
0
;
const
std
:
:
string
&
id
(
)
const
{
return
id_
;
}
Timestamp
timestamp
(
)
const
{
return
timestamp_
;
}
virtual
const
char
*
type
(
)
const
=
0
;
std
:
:
vector
<
Attribute
>
Attributes
(
)
const
;
std
:
:
vector
<
const
RTCStatsMemberInterface
*
>
Members
(
)
const
;
bool
operator
=
=
(
const
RTCStats
&
other
)
const
;
bool
operator
!
=
(
const
RTCStats
&
other
)
const
;
std
:
:
string
ToJson
(
)
const
;
template
<
typename
T
>
const
T
&
cast_to
(
)
const
{
RTC_DCHECK_EQ
(
type
(
)
T
:
:
kType
)
;
return
static_cast
<
const
T
&
>
(
*
this
)
;
}
protected
:
virtual
std
:
:
vector
<
Attribute
>
AttributesImpl
(
size_t
additional_capacity
)
const
;
std
:
:
string
const
id_
;
Timestamp
timestamp_
;
mutable
std
:
:
vector
<
Attribute
>
cached_attributes_
;
}
;
#
define
WEBRTC_RTCSTATS_DECL
(
)
\
protected
:
\
std
:
:
vector
<
webrtc
:
:
Attribute
>
AttributesImpl
(
size_t
additional_capacity
)
\
const
override
;
\
\
public
:
\
static
const
char
kType
[
]
;
\
\
std
:
:
unique_ptr
<
webrtc
:
:
RTCStats
>
copy
(
)
const
override
;
\
const
char
*
type
(
)
const
override
#
define
WEBRTC_RTCSTATS_IMPL
(
this_class
parent_class
type_str
.
.
.
)
\
const
char
this_class
:
:
kType
[
]
=
type_str
;
\
\
std
:
:
unique_ptr
<
webrtc
:
:
RTCStats
>
this_class
:
:
copy
(
)
const
{
\
return
std
:
:
make_unique
<
this_class
>
(
*
this
)
;
\
}
\
\
const
char
*
this_class
:
:
type
(
)
const
{
\
return
this_class
:
:
kType
;
\
}
\
\
std
:
:
vector
<
webrtc
:
:
Attribute
>
this_class
:
:
AttributesImpl
(
\
size_t
additional_capacity
)
const
{
\
const
webrtc
:
:
RTCStatsMemberInterface
*
this_members
[
]
=
{
__VA_ARGS__
}
;
\
size_t
this_members_size
=
sizeof
(
this_members
)
/
sizeof
(
this_members
[
0
]
)
;
\
std
:
:
vector
<
webrtc
:
:
Attribute
>
attributes
=
\
parent_class
:
:
AttributesImpl
(
this_members_size
+
additional_capacity
)
;
\
for
(
size_t
i
=
0
;
i
<
this_members_size
;
+
+
i
)
{
\
attributes
.
push_back
(
\
webrtc
:
:
Attribute
:
:
FromMemberInterface
(
this_members
[
i
]
)
)
;
\
}
\
return
attributes
;
\
}
#
define
WEBRTC_RTCSTATS_IMPL_NO_MEMBERS
(
this_class
parent_class
type_str
)
\
const
char
this_class
:
:
kType
[
]
=
type_str
;
\
\
std
:
:
unique_ptr
<
webrtc
:
:
RTCStats
>
this_class
:
:
copy
(
)
const
{
\
return
std
:
:
make_unique
<
this_class
>
(
*
this
)
;
\
}
\
\
const
char
*
this_class
:
:
type
(
)
const
{
\
return
this_class
:
:
kType
;
\
}
\
\
std
:
:
vector
<
webrtc
:
:
Attribute
>
this_class
:
:
AttributesImpl
(
\
size_t
additional_capacity
)
const
{
\
return
parent_class
:
:
AttributesImpl
(
0
)
;
\
}
}
#
endif
