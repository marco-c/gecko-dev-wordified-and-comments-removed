#
ifndef
API_AUDIO_CODECS_AUDIO_DECODER_FACTORY_TEMPLATE_H_
#
define
API_AUDIO_CODECS_AUDIO_DECODER_FACTORY_TEMPLATE_H_
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
audio_codecs
/
audio_codec_pair_id
.
h
"
#
include
"
api
/
audio_codecs
/
audio_decoder
.
h
"
#
include
"
api
/
audio_codecs
/
audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
make_ref_counted
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
namespace
webrtc
{
namespace
audio_decoder_factory_template_impl
{
template
<
typename
.
.
.
Ts
>
struct
Helper
;
template
<
>
struct
Helper
<
>
{
static
void
AppendSupportedDecoders
(
std
:
:
vector
<
AudioCodecSpec
>
*
specs
)
{
}
static
bool
IsSupportedDecoder
(
const
SdpAudioFormat
&
format
)
{
return
false
;
}
static
absl
:
:
Nullable
<
std
:
:
unique_ptr
<
AudioDecoder
>
>
MakeAudioDecoder
(
const
Environment
&
env
const
SdpAudioFormat
&
format
absl
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
)
{
return
nullptr
;
}
}
;
struct
Rank0
{
}
;
struct
Rank1
:
Rank0
{
}
;
template
<
typename
Trait
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
decltype
(
Trait
:
:
MakeAudioDecoder
(
std
:
:
declval
<
Environment
>
(
)
std
:
:
declval
<
typename
Trait
:
:
Config
>
(
)
std
:
:
declval
<
absl
:
:
optional
<
AudioCodecPairId
>
>
(
)
)
)
std
:
:
unique_ptr
<
AudioDecoder
>
>
>
>
absl
:
:
Nullable
<
std
:
:
unique_ptr
<
AudioDecoder
>
>
CreateDecoder
(
Rank1
const
Environment
&
env
const
typename
Trait
:
:
Config
&
config
absl
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
)
{
return
Trait
:
:
MakeAudioDecoder
(
env
config
codec_pair_id
)
;
}
template
<
typename
Trait
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
decltype
(
Trait
:
:
MakeAudioDecoder
(
std
:
:
declval
<
typename
Trait
:
:
Config
>
(
)
std
:
:
declval
<
absl
:
:
optional
<
AudioCodecPairId
>
>
(
)
)
)
std
:
:
unique_ptr
<
AudioDecoder
>
>
>
>
absl
:
:
Nullable
<
std
:
:
unique_ptr
<
AudioDecoder
>
>
CreateDecoder
(
Rank0
const
Environment
&
env
const
typename
Trait
:
:
Config
&
config
absl
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
)
{
return
Trait
:
:
MakeAudioDecoder
(
config
codec_pair_id
)
;
}
template
<
typename
T
typename
.
.
.
Ts
>
struct
Helper
<
T
Ts
.
.
.
>
{
static
void
AppendSupportedDecoders
(
std
:
:
vector
<
AudioCodecSpec
>
*
specs
)
{
T
:
:
AppendSupportedDecoders
(
specs
)
;
Helper
<
Ts
.
.
.
>
:
:
AppendSupportedDecoders
(
specs
)
;
}
static
bool
IsSupportedDecoder
(
const
SdpAudioFormat
&
format
)
{
auto
opt_config
=
T
:
:
SdpToConfig
(
format
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
opt_config
)
absl
:
:
optional
<
typename
T
:
:
Config
>
>
:
:
value
"
T
:
:
SdpToConfig
(
)
must
return
a
value
of
type
"
"
absl
:
:
optional
<
T
:
:
Config
>
"
)
;
return
opt_config
?
true
:
Helper
<
Ts
.
.
.
>
:
:
IsSupportedDecoder
(
format
)
;
}
static
absl
:
:
Nullable
<
std
:
:
unique_ptr
<
AudioDecoder
>
>
MakeAudioDecoder
(
const
Environment
&
env
const
SdpAudioFormat
&
format
absl
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
)
{
auto
opt_config
=
T
:
:
SdpToConfig
(
format
)
;
return
opt_config
.
has_value
(
)
?
CreateDecoder
<
T
>
(
Rank1
{
}
env
*
opt_config
codec_pair_id
)
:
Helper
<
Ts
.
.
.
>
:
:
MakeAudioDecoder
(
env
format
codec_pair_id
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
class
AudioDecoderFactoryT
:
public
AudioDecoderFactory
{
public
:
std
:
:
vector
<
AudioCodecSpec
>
GetSupportedDecoders
(
)
override
{
std
:
:
vector
<
AudioCodecSpec
>
specs
;
Helper
<
Ts
.
.
.
>
:
:
AppendSupportedDecoders
(
&
specs
)
;
return
specs
;
}
bool
IsSupportedDecoder
(
const
SdpAudioFormat
&
format
)
override
{
return
Helper
<
Ts
.
.
.
>
:
:
IsSupportedDecoder
(
format
)
;
}
absl
:
:
Nullable
<
std
:
:
unique_ptr
<
AudioDecoder
>
>
Create
(
const
Environment
&
env
const
SdpAudioFormat
&
format
absl
:
:
optional
<
AudioCodecPairId
>
codec_pair_id
)
override
{
return
Helper
<
Ts
.
.
.
>
:
:
MakeAudioDecoder
(
env
format
codec_pair_id
)
;
}
}
;
}
template
<
typename
.
.
.
Ts
>
scoped_refptr
<
AudioDecoderFactory
>
CreateAudioDecoderFactory
(
)
{
static_assert
(
sizeof
.
.
.
(
Ts
)
>
=
1
"
Caller
must
give
at
least
one
template
parameter
"
)
;
return
make_ref_counted
<
audio_decoder_factory_template_impl
:
:
AudioDecoderFactoryT
<
Ts
.
.
.
>
>
(
)
;
}
}
#
endif
