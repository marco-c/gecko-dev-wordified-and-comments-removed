#
ifndef
API_AUDIO_CODECS_AUDIO_ENCODER_FACTORY_TEMPLATE_H_
#
define
API_AUDIO_CODECS_AUDIO_ENCODER_FACTORY_TEMPLATE_H_
#
include
<
memory
>
#
include
<
optional
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
absl
/
base
/
nullability
.
h
"
#
include
"
api
/
audio_codecs
/
audio_codec_pair_id
.
h
"
#
include
"
api
/
audio_codecs
/
audio_encoder
.
h
"
#
include
"
api
/
audio_codecs
/
audio_encoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
make_ref_counted
.
h
"
#
include
"
api
/
scoped_refptr
.
h
"
namespace
webrtc
{
namespace
audio_encoder_factory_template_impl
{
template
<
typename
.
.
.
Ts
>
struct
Helper
;
template
<
>
struct
Helper
<
>
{
static
void
AppendSupportedEncoders
(
std
:
:
vector
<
AudioCodecSpec
>
*
)
{
}
static
std
:
:
optional
<
AudioCodecInfo
>
QueryAudioEncoder
(
const
SdpAudioFormat
&
)
{
return
std
:
:
nullopt
;
}
static
absl_nullable
std
:
:
unique_ptr
<
AudioEncoder
>
CreateAudioEncoder
(
const
Environment
&
const
SdpAudioFormat
&
const
AudioEncoderFactory
:
:
Options
&
)
{
return
nullptr
;
}
}
;
struct
Rank0
{
}
;
struct
Rank1
:
Rank0
{
}
;
template
<
typename
Trait
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
decltype
(
Trait
:
:
MakeAudioEncoder
(
std
:
:
declval
<
Environment
>
(
)
std
:
:
declval
<
typename
Trait
:
:
Config
>
(
)
std
:
:
declval
<
AudioEncoderFactory
:
:
Options
>
(
)
)
)
std
:
:
unique_ptr
<
AudioEncoder
>
>
>
>
absl_nullable
std
:
:
unique_ptr
<
AudioEncoder
>
CreateEncoder
(
Rank1
const
Environment
&
env
const
typename
Trait
:
:
Config
&
config
const
AudioEncoderFactory
:
:
Options
&
options
)
{
return
Trait
:
:
MakeAudioEncoder
(
env
config
options
)
;
}
template
<
typename
Trait
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
decltype
(
Trait
:
:
MakeAudioEncoder
(
std
:
:
declval
<
typename
Trait
:
:
Config
>
(
)
int
{
}
std
:
:
declval
<
std
:
:
optional
<
AudioCodecPairId
>
>
(
)
)
)
std
:
:
unique_ptr
<
AudioEncoder
>
>
>
>
absl_nullable
std
:
:
unique_ptr
<
AudioEncoder
>
CreateEncoder
(
Rank0
const
Environment
&
const
typename
Trait
:
:
Config
&
config
const
AudioEncoderFactory
:
:
Options
&
options
)
{
return
Trait
:
:
MakeAudioEncoder
(
config
options
.
payload_type
options
.
codec_pair_id
)
;
}
template
<
typename
T
typename
.
.
.
Ts
>
struct
Helper
<
T
Ts
.
.
.
>
{
static
void
AppendSupportedEncoders
(
std
:
:
vector
<
AudioCodecSpec
>
*
specs
)
{
T
:
:
AppendSupportedEncoders
(
specs
)
;
Helper
<
Ts
.
.
.
>
:
:
AppendSupportedEncoders
(
specs
)
;
}
static
std
:
:
optional
<
AudioCodecInfo
>
QueryAudioEncoder
(
const
SdpAudioFormat
&
format
)
{
auto
opt_config
=
T
:
:
SdpToConfig
(
format
)
;
static_assert
(
std
:
:
is_same
<
decltype
(
opt_config
)
std
:
:
optional
<
typename
T
:
:
Config
>
>
:
:
value
"
T
:
:
SdpToConfig
(
)
must
return
a
value
of
type
"
"
std
:
:
optional
<
T
:
:
Config
>
"
)
;
return
opt_config
?
std
:
:
optional
<
AudioCodecInfo
>
(
T
:
:
QueryAudioEncoder
(
*
opt_config
)
)
:
Helper
<
Ts
.
.
.
>
:
:
QueryAudioEncoder
(
format
)
;
}
static
absl_nullable
std
:
:
unique_ptr
<
AudioEncoder
>
CreateAudioEncoder
(
const
Environment
&
env
const
SdpAudioFormat
&
format
const
AudioEncoderFactory
:
:
Options
&
options
)
{
if
(
auto
opt_config
=
T
:
:
SdpToConfig
(
format
)
;
opt_config
.
has_value
(
)
)
{
return
CreateEncoder
<
T
>
(
Rank1
{
}
env
*
opt_config
options
)
;
}
return
Helper
<
Ts
.
.
.
>
:
:
CreateAudioEncoder
(
env
format
options
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
class
AudioEncoderFactoryT
:
public
AudioEncoderFactory
{
public
:
std
:
:
vector
<
AudioCodecSpec
>
GetSupportedEncoders
(
)
override
{
std
:
:
vector
<
AudioCodecSpec
>
specs
;
Helper
<
Ts
.
.
.
>
:
:
AppendSupportedEncoders
(
&
specs
)
;
return
specs
;
}
std
:
:
optional
<
AudioCodecInfo
>
QueryAudioEncoder
(
const
SdpAudioFormat
&
format
)
override
{
return
Helper
<
Ts
.
.
.
>
:
:
QueryAudioEncoder
(
format
)
;
}
absl_nullable
std
:
:
unique_ptr
<
AudioEncoder
>
Create
(
const
Environment
&
env
const
SdpAudioFormat
&
format
Options
options
)
override
{
return
Helper
<
Ts
.
.
.
>
:
:
CreateAudioEncoder
(
env
format
options
)
;
}
}
;
}
template
<
typename
.
.
.
Ts
>
scoped_refptr
<
AudioEncoderFactory
>
CreateAudioEncoderFactory
(
)
{
static_assert
(
sizeof
.
.
.
(
Ts
)
>
=
1
"
Caller
must
give
at
least
one
template
parameter
"
)
;
return
make_ref_counted
<
audio_encoder_factory_template_impl
:
:
AudioEncoderFactoryT
<
Ts
.
.
.
>
>
(
)
;
}
}
#
endif
