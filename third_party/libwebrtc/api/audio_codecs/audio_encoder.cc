#
include
"
api
/
audio_codecs
/
audio_encoder
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
call
/
bitrate_allocation
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
namespace
webrtc
{
ANAStats
:
:
ANAStats
(
)
=
default
;
ANAStats
:
:
~
ANAStats
(
)
=
default
;
ANAStats
:
:
ANAStats
(
const
ANAStats
&
)
=
default
;
AudioEncoder
:
:
EncodedInfo
:
:
EncodedInfo
(
)
=
default
;
AudioEncoder
:
:
EncodedInfo
:
:
EncodedInfo
(
const
EncodedInfo
&
)
=
default
;
AudioEncoder
:
:
EncodedInfo
:
:
EncodedInfo
(
EncodedInfo
&
&
)
=
default
;
AudioEncoder
:
:
EncodedInfo
:
:
~
EncodedInfo
(
)
=
default
;
AudioEncoder
:
:
EncodedInfo
&
AudioEncoder
:
:
EncodedInfo
:
:
operator
=
(
const
EncodedInfo
&
)
=
default
;
AudioEncoder
:
:
EncodedInfo
&
AudioEncoder
:
:
EncodedInfo
:
:
operator
=
(
EncodedInfo
&
&
)
=
default
;
int
AudioEncoder
:
:
RtpTimestampRateHz
(
)
const
{
return
SampleRateHz
(
)
;
}
AudioEncoder
:
:
EncodedInfo
AudioEncoder
:
:
Encode
(
uint32_t
rtp_timestamp
ArrayView
<
const
int16_t
>
audio
Buffer
*
encoded
)
{
TRACE_EVENT0
(
"
webrtc
"
"
AudioEncoder
:
:
Encode
"
)
;
RTC_CHECK_EQ
(
audio
.
size
(
)
static_cast
<
size_t
>
(
NumChannels
(
)
*
SampleRateHz
(
)
/
100
)
)
;
const
size_t
old_size
=
encoded
-
>
size
(
)
;
EncodedInfo
info
=
EncodeImpl
(
rtp_timestamp
audio
encoded
)
;
RTC_CHECK_EQ
(
encoded
-
>
size
(
)
-
old_size
info
.
encoded_bytes
)
;
return
info
;
}
bool
AudioEncoder
:
:
SetFec
(
bool
enable
)
{
return
!
enable
;
}
bool
AudioEncoder
:
:
SetDtx
(
bool
enable
)
{
return
!
enable
;
}
bool
AudioEncoder
:
:
GetDtx
(
)
const
{
return
false
;
}
bool
AudioEncoder
:
:
SetApplication
(
Application
)
{
return
false
;
}
void
AudioEncoder
:
:
SetMaxPlaybackRate
(
int
)
{
}
void
AudioEncoder
:
:
SetTargetBitrate
(
int
)
{
}
ArrayView
<
std
:
:
unique_ptr
<
AudioEncoder
>
>
AudioEncoder
:
:
ReclaimContainedEncoders
(
)
{
return
nullptr
;
}
bool
AudioEncoder
:
:
EnableAudioNetworkAdaptor
(
const
std
:
:
string
&
RtcEventLog
*
)
{
return
false
;
}
void
AudioEncoder
:
:
DisableAudioNetworkAdaptor
(
)
{
}
void
AudioEncoder
:
:
OnReceivedUplinkPacketLossFraction
(
float
)
{
}
void
AudioEncoder
:
:
OnReceivedUplinkRecoverablePacketLossFraction
(
float
)
{
RTC_DCHECK_NOTREACHED
(
)
;
}
void
AudioEncoder
:
:
OnReceivedTargetAudioBitrate
(
int
target_audio_bitrate_bps
)
{
OnReceivedUplinkBandwidth
(
target_audio_bitrate_bps
std
:
:
nullopt
)
;
}
void
AudioEncoder
:
:
OnReceivedUplinkBandwidth
(
int
std
:
:
optional
<
int64_t
>
)
{
}
void
AudioEncoder
:
:
OnReceivedUplinkAllocation
(
BitrateAllocationUpdate
update
)
{
OnReceivedUplinkBandwidth
(
update
.
target_bitrate
.
bps
(
)
update
.
bwe_period
.
ms
(
)
)
;
}
void
AudioEncoder
:
:
OnReceivedRtt
(
int
)
{
}
void
AudioEncoder
:
:
OnReceivedOverhead
(
size_t
)
{
}
void
AudioEncoder
:
:
SetReceiverFrameLengthRange
(
int
int
)
{
}
ANAStats
AudioEncoder
:
:
GetANAStats
(
)
const
{
return
ANAStats
(
)
;
}
constexpr
int
AudioEncoder
:
:
kMaxNumberOfChannels
;
}
