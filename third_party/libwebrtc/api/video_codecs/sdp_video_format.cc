#
include
"
api
/
video_codecs
/
sdp_video_format
.
h
"
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
video_codecs
/
av1_profile
.
h
"
#
include
"
api
/
video_codecs
/
h264_profile_level_id
.
h
"
#
ifdef
RTC_ENABLE_H265
#
include
"
api
/
video_codecs
/
h265_profile_tier_level
.
h
"
#
endif
#
include
"
api
/
video_codecs
/
video_codec
.
h
"
#
include
"
api
/
video_codecs
/
vp9_profile
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
strings
/
string_builder
.
h
"
namespace
webrtc
{
namespace
{
std
:
:
string
GetFmtpParameterOrDefault
(
const
CodecParameterMap
&
params
const
std
:
:
string
&
name
const
std
:
:
string
&
default_value
)
{
const
auto
it
=
params
.
find
(
name
)
;
if
(
it
!
=
params
.
end
(
)
)
{
return
it
-
>
second
;
}
return
default_value
;
}
std
:
:
string
H264GetPacketizationModeOrDefault
(
const
CodecParameterMap
&
params
)
{
return
GetFmtpParameterOrDefault
(
params
cricket
:
:
kH264FmtpPacketizationMode
"
0
"
)
;
}
bool
H264IsSamePacketizationMode
(
const
CodecParameterMap
&
left
const
CodecParameterMap
&
right
)
{
return
H264GetPacketizationModeOrDefault
(
left
)
=
=
H264GetPacketizationModeOrDefault
(
right
)
;
}
std
:
:
string
AV1GetTierOrDefault
(
const
CodecParameterMap
&
params
)
{
return
GetFmtpParameterOrDefault
(
params
cricket
:
:
kAv1FmtpTier
"
0
"
)
;
}
bool
AV1IsSameTier
(
const
CodecParameterMap
&
left
const
CodecParameterMap
&
right
)
{
return
AV1GetTierOrDefault
(
left
)
=
=
AV1GetTierOrDefault
(
right
)
;
}
std
:
:
string
AV1GetLevelIdxOrDefault
(
const
CodecParameterMap
&
params
)
{
return
GetFmtpParameterOrDefault
(
params
cricket
:
:
kAv1FmtpLevelIdx
"
5
"
)
;
}
bool
AV1IsSameLevelIdx
(
const
CodecParameterMap
&
left
const
CodecParameterMap
&
right
)
{
return
AV1GetLevelIdxOrDefault
(
left
)
=
=
AV1GetLevelIdxOrDefault
(
right
)
;
}
#
ifdef
RTC_ENABLE_H265
std
:
:
string
GetH265TxModeOrDefault
(
const
CodecParameterMap
&
params
)
{
return
GetFmtpParameterOrDefault
(
params
cricket
:
:
kH265FmtpTxMode
"
SRST
"
)
;
}
bool
IsSameH265TxMode
(
const
CodecParameterMap
&
left
const
CodecParameterMap
&
right
)
{
return
absl
:
:
EqualsIgnoreCase
(
GetH265TxModeOrDefault
(
left
)
GetH265TxModeOrDefault
(
right
)
)
;
}
#
endif
bool
IsSameCodecSpecific
(
const
std
:
:
string
&
name1
const
CodecParameterMap
&
params1
const
std
:
:
string
&
name2
const
CodecParameterMap
&
params2
)
{
RTC_DCHECK
(
absl
:
:
EqualsIgnoreCase
(
name1
name2
)
)
;
VideoCodecType
codec_type
=
PayloadStringToCodecType
(
name1
)
;
switch
(
codec_type
)
{
case
kVideoCodecH264
:
return
H264IsSameProfile
(
params1
params2
)
&
&
H264IsSamePacketizationMode
(
params1
params2
)
;
case
kVideoCodecVP9
:
return
VP9IsSameProfile
(
params1
params2
)
;
case
kVideoCodecAV1
:
return
AV1IsSameProfile
(
params1
params2
)
&
&
AV1IsSameTier
(
params1
params2
)
&
&
AV1IsSameLevelIdx
(
params1
params2
)
;
#
ifdef
RTC_ENABLE_H265
case
kVideoCodecH265
:
return
H265IsSameProfileTierLevel
(
params1
params2
)
&
&
IsSameH265TxMode
(
params1
params2
)
;
#
endif
default
:
return
true
;
}
}
}
SdpVideoFormat
:
:
SdpVideoFormat
(
const
std
:
:
string
&
name
)
:
name
(
name
)
{
}
SdpVideoFormat
:
:
SdpVideoFormat
(
const
std
:
:
string
&
name
const
CodecParameterMap
&
parameters
)
:
name
(
name
)
parameters
(
parameters
)
{
}
SdpVideoFormat
:
:
SdpVideoFormat
(
const
std
:
:
string
&
name
const
CodecParameterMap
&
parameters
const
absl
:
:
InlinedVector
<
ScalabilityMode
kScalabilityModeCount
>
&
scalability_modes
)
:
name
(
name
)
parameters
(
parameters
)
scalability_modes
(
scalability_modes
)
{
}
SdpVideoFormat
:
:
SdpVideoFormat
(
const
SdpVideoFormat
&
)
=
default
;
SdpVideoFormat
:
:
SdpVideoFormat
(
SdpVideoFormat
&
&
)
=
default
;
SdpVideoFormat
&
SdpVideoFormat
:
:
operator
=
(
const
SdpVideoFormat
&
)
=
default
;
SdpVideoFormat
&
SdpVideoFormat
:
:
operator
=
(
SdpVideoFormat
&
&
)
=
default
;
SdpVideoFormat
:
:
~
SdpVideoFormat
(
)
=
default
;
std
:
:
string
SdpVideoFormat
:
:
ToString
(
)
const
{
rtc
:
:
StringBuilder
builder
;
builder
<
<
"
Codec
name
:
"
<
<
name
<
<
"
parameters
:
{
"
;
for
(
const
auto
&
kv
:
parameters
)
{
builder
<
<
"
"
<
<
kv
.
first
<
<
"
=
"
<
<
kv
.
second
;
}
builder
<
<
"
}
"
;
if
(
!
scalability_modes
.
empty
(
)
)
{
builder
<
<
"
scalability_modes
:
[
"
;
bool
first
=
true
;
for
(
const
auto
scalability_mode
:
scalability_modes
)
{
if
(
first
)
{
first
=
false
;
}
else
{
builder
<
<
"
"
;
}
builder
<
<
ScalabilityModeToString
(
scalability_mode
)
;
}
builder
<
<
"
]
"
;
}
return
builder
.
str
(
)
;
}
bool
SdpVideoFormat
:
:
IsSameCodec
(
const
SdpVideoFormat
&
other
)
const
{
return
absl
:
:
EqualsIgnoreCase
(
name
other
.
name
)
&
&
IsSameCodecSpecific
(
name
parameters
other
.
name
other
.
parameters
)
;
}
bool
SdpVideoFormat
:
:
IsCodecInList
(
rtc
:
:
ArrayView
<
const
webrtc
:
:
SdpVideoFormat
>
formats
)
const
{
for
(
const
auto
&
format
:
formats
)
{
if
(
IsSameCodec
(
format
)
)
{
return
true
;
}
}
return
false
;
}
bool
operator
=
=
(
const
SdpVideoFormat
&
a
const
SdpVideoFormat
&
b
)
{
return
a
.
name
=
=
b
.
name
&
&
a
.
parameters
=
=
b
.
parameters
&
&
a
.
scalability_modes
=
=
b
.
scalability_modes
;
}
absl
:
:
optional
<
SdpVideoFormat
>
FuzzyMatchSdpVideoFormat
(
rtc
:
:
ArrayView
<
const
SdpVideoFormat
>
supported_formats
const
SdpVideoFormat
&
format
)
{
absl
:
:
optional
<
SdpVideoFormat
>
res
;
int
best_parameter_match
=
0
;
for
(
const
auto
&
supported_format
:
supported_formats
)
{
if
(
absl
:
:
EqualsIgnoreCase
(
supported_format
.
name
format
.
name
)
)
{
int
matching_parameters
=
0
;
for
(
const
auto
&
kv
:
supported_format
.
parameters
)
{
auto
it
=
format
.
parameters
.
find
(
kv
.
first
)
;
if
(
it
!
=
format
.
parameters
.
end
(
)
&
&
it
-
>
second
=
=
kv
.
second
)
{
matching_parameters
+
=
1
;
}
}
if
(
!
res
|
|
matching_parameters
>
best_parameter_match
)
{
res
=
supported_format
;
best_parameter_match
=
matching_parameters
;
}
}
}
if
(
!
res
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Failed
to
match
SdpVideoFormat
"
<
<
format
.
ToString
(
)
;
}
else
if
(
*
res
!
=
format
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Matched
SdpVideoFormat
"
<
<
format
.
ToString
(
)
<
<
"
with
"
<
<
res
-
>
ToString
(
)
;
}
return
res
;
}
}
