#
ifndef
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_TEMPLATE_H_
#
define
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_TEMPLATE_H_
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
api
/
video_codecs
/
scalability_mode
.
h
"
#
include
"
api
/
video_codecs
/
sdp_video_format
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_factory
.
h
"
#
include
"
modules
/
video_coding
/
svc
/
scalability_mode_util
.
h
"
namespace
webrtc
{
template
<
typename
.
.
.
Ts
>
class
VideoEncoderFactoryTemplate
:
public
VideoEncoderFactory
{
public
:
std
:
:
vector
<
SdpVideoFormat
>
GetSupportedFormats
(
)
const
override
{
return
GetSupportedFormatsInternal
<
Ts
.
.
.
>
(
)
;
}
std
:
:
unique_ptr
<
VideoEncoder
>
Create
(
const
Environment
&
env
const
SdpVideoFormat
&
format
)
override
{
std
:
:
optional
<
SdpVideoFormat
>
matched
=
FuzzyMatchSdpVideoFormat
(
GetSupportedFormats
(
)
format
)
;
return
CreateInternal
<
Ts
.
.
.
>
(
env
matched
.
value_or
(
format
)
)
;
}
CodecSupport
QueryCodecSupport
(
const
SdpVideoFormat
&
format
std
:
:
optional
<
std
:
:
string
>
scalability_mode
)
const
override
{
return
QueryCodecSupportInternal
<
Ts
.
.
.
>
(
format
scalability_mode
)
;
}
private
:
bool
IsFormatInList
(
const
SdpVideoFormat
&
format
ArrayView
<
const
SdpVideoFormat
>
supported_formats
)
const
{
return
absl
:
:
c_any_of
(
supported_formats
[
&
]
(
const
SdpVideoFormat
&
supported_format
)
{
return
supported_format
.
name
=
=
format
.
name
&
&
supported_format
.
parameters
=
=
format
.
parameters
;
}
)
;
}
template
<
typename
V
>
bool
IsScalabilityModeSupported
(
const
std
:
:
optional
<
std
:
:
string
>
&
scalability_mode_string
)
const
{
if
(
!
scalability_mode_string
.
has_value
(
)
)
{
return
true
;
}
std
:
:
optional
<
ScalabilityMode
>
scalability_mode
=
ScalabilityModeFromString
(
*
scalability_mode_string
)
;
return
scalability_mode
.
has_value
(
)
&
&
V
:
:
IsScalabilityModeSupported
(
*
scalability_mode
)
;
}
template
<
typename
V
typename
.
.
.
Vs
>
std
:
:
vector
<
SdpVideoFormat
>
GetSupportedFormatsInternal
(
)
const
{
auto
supported_formats
=
V
:
:
SupportedFormats
(
)
;
if
constexpr
(
sizeof
.
.
.
(
Vs
)
>
0
)
{
for
(
const
auto
&
other_format
:
GetSupportedFormatsInternal
<
Vs
.
.
.
>
(
)
)
{
if
(
!
IsFormatInList
(
other_format
supported_formats
)
)
{
supported_formats
.
push_back
(
other_format
)
;
}
}
}
return
supported_formats
;
}
template
<
typename
V
typename
.
.
.
Vs
>
std
:
:
unique_ptr
<
VideoEncoder
>
CreateInternal
(
const
Environment
&
env
const
SdpVideoFormat
&
format
)
{
if
(
IsFormatInList
(
format
V
:
:
SupportedFormats
(
)
)
)
{
return
V
:
:
CreateEncoder
(
env
format
)
;
}
if
constexpr
(
sizeof
.
.
.
(
Vs
)
>
0
)
{
return
CreateInternal
<
Vs
.
.
.
>
(
env
format
)
;
}
return
nullptr
;
}
template
<
typename
V
typename
.
.
.
Vs
>
CodecSupport
QueryCodecSupportInternal
(
const
SdpVideoFormat
&
format
const
std
:
:
optional
<
std
:
:
string
>
&
scalability_mode
)
const
{
if
(
IsFormatInList
(
format
V
:
:
SupportedFormats
(
)
)
)
{
return
{
.
is_supported
=
IsScalabilityModeSupported
<
V
>
(
scalability_mode
)
}
;
}
if
constexpr
(
sizeof
.
.
.
(
Vs
)
>
0
)
{
return
QueryCodecSupportInternal
<
Vs
.
.
.
>
(
format
scalability_mode
)
;
}
return
{
.
is_supported
=
false
}
;
}
}
;
}
#
endif
