#
ifndef
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_TEMPLATE_H_
#
define
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_TEMPLATE_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_factory
.
h
"
#
include
"
modules
/
video_coding
/
svc
/
scalability_mode_util
.
h
"
namespace
webrtc
{
template
<
typename
.
.
.
Ts
>
class
VideoEncoderFactoryTemplate
:
public
VideoEncoderFactory
{
public
:
std
:
:
vector
<
SdpVideoFormat
>
GetSupportedFormats
(
)
const
override
{
std
:
:
vector
<
SdpVideoFormat
>
formats
;
GetSupportedFormatsInternal
<
Ts
.
.
.
>
(
formats
)
;
return
formats
;
}
std
:
:
unique_ptr
<
VideoEncoder
>
CreateVideoEncoder
(
const
SdpVideoFormat
&
format
)
override
{
return
CreateVideoEncoderInternal
<
Ts
.
.
.
>
(
format
)
;
}
CodecSupport
QueryCodecSupport
(
const
SdpVideoFormat
&
format
absl
:
:
optional
<
std
:
:
string
>
scalability_mode
)
const
override
{
return
QueryCodecSupportInternal
<
Ts
.
.
.
>
(
format
scalability_mode
)
;
}
private
:
template
<
typename
V
>
bool
IsFormatSupported
(
const
SdpVideoFormat
&
format
)
const
{
return
absl
:
:
c_count
(
V
:
:
SupportedFormats
(
)
format
)
>
0
;
}
template
<
typename
V
>
bool
IsScalabilityModeSupported
(
const
absl
:
:
optional
<
std
:
:
string
>
&
scalability_mode_string
)
const
{
if
(
!
scalability_mode_string
.
has_value
(
)
)
{
return
true
;
}
absl
:
:
optional
<
ScalabilityMode
>
scalability_mode
=
ScalabilityModeFromString
(
*
scalability_mode_string
)
;
return
scalability_mode
.
has_value
(
)
&
&
V
:
:
IsScalabilityModeSupported
(
*
scalability_mode
)
;
}
template
<
typename
V
typename
.
.
.
Vs
>
void
GetSupportedFormatsInternal
(
std
:
:
vector
<
SdpVideoFormat
>
&
formats
)
const
{
auto
supported_formats
=
V
:
:
SupportedFormats
(
)
;
for
(
const
auto
&
format
:
supported_formats
)
{
if
(
absl
:
:
c_count
(
formats
format
)
=
=
0
)
{
formats
.
push_back
(
format
)
;
}
}
if
constexpr
(
sizeof
.
.
.
(
Vs
)
>
0
)
{
return
GetSupportedFormatsInternal
<
Vs
.
.
.
>
(
formats
)
;
}
}
template
<
typename
V
typename
.
.
.
Vs
>
std
:
:
unique_ptr
<
VideoEncoder
>
CreateVideoEncoderInternal
(
const
SdpVideoFormat
&
format
)
{
if
(
IsFormatSupported
<
V
>
(
format
)
)
{
return
V
:
:
CreateEncoder
(
format
)
;
}
if
constexpr
(
sizeof
.
.
.
(
Vs
)
>
0
)
{
return
CreateVideoEncoderInternal
<
Vs
.
.
.
>
(
format
)
;
}
return
nullptr
;
}
template
<
typename
V
typename
.
.
.
Vs
>
CodecSupport
QueryCodecSupportInternal
(
const
SdpVideoFormat
&
format
const
absl
:
:
optional
<
std
:
:
string
>
&
scalability_mode
)
const
{
if
(
IsFormatSupported
<
V
>
(
format
)
)
{
return
{
.
is_supported
=
IsScalabilityModeSupported
<
V
>
(
scalability_mode
)
}
;
}
if
constexpr
(
sizeof
.
.
.
(
Vs
)
>
0
)
{
return
QueryCodecSupportInternal
<
Vs
.
.
.
>
(
format
scalability_mode
)
;
}
return
{
.
is_supported
=
false
}
;
}
}
;
}
#
endif
