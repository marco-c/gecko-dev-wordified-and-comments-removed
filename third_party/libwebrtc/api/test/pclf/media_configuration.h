#
ifndef
API_TEST_PCLF_MEDIA_CONFIGURATION_H_
#
define
API_TEST_PCLF_MEDIA_CONFIGURATION_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
audio_options
.
h
"
#
include
"
api
/
media_stream_interface
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
api
/
test
/
video
/
video_frame_writer
.
h
"
#
include
"
api
/
units
/
time_delta
.
h
"
namespace
webrtc
{
namespace
webrtc_pc_e2e
{
constexpr
size_t
kDefaultSlidesWidth
=
1850
;
constexpr
size_t
kDefaultSlidesHeight
=
1110
;
enum
class
CapturingDeviceIndex
:
size_t
{
}
;
struct
ScrollingParams
{
TimeDelta
duration
;
size_t
source_width
=
kDefaultSlidesWidth
;
size_t
source_height
=
kDefaultSlidesHeight
;
}
;
struct
ScreenShareConfig
{
explicit
ScreenShareConfig
(
TimeDelta
slide_change_interval
)
;
TimeDelta
slide_change_interval
;
bool
generate_slides
=
false
;
std
:
:
optional
<
ScrollingParams
>
scrolling_params
;
std
:
:
vector
<
std
:
:
string
>
slides_yuv_file_names
;
}
;
struct
VideoSimulcastConfig
{
explicit
VideoSimulcastConfig
(
int
simulcast_streams_count
)
;
int
simulcast_streams_count
;
}
;
struct
EmulatedSFUConfig
{
EmulatedSFUConfig
(
)
=
default
;
explicit
EmulatedSFUConfig
(
int
target_layer_index
)
;
EmulatedSFUConfig
(
std
:
:
optional
<
int
>
target_layer_index
std
:
:
optional
<
int
>
target_temporal_index
)
;
std
:
:
optional
<
int
>
target_layer_index
;
std
:
:
optional
<
int
>
target_temporal_index
;
}
;
class
VideoResolution
{
public
:
enum
class
Spec
{
kNone
kMaxFromSender
}
;
VideoResolution
(
size_t
width
size_t
height
int32_t
fps
)
;
explicit
VideoResolution
(
Spec
spec
=
Spec
:
:
kNone
)
;
bool
operator
=
=
(
const
VideoResolution
&
other
)
const
;
bool
operator
!
=
(
const
VideoResolution
&
other
)
const
;
size_t
width
(
)
const
{
return
width_
;
}
void
set_width
(
size_t
width
)
{
width_
=
width
;
}
size_t
height
(
)
const
{
return
height_
;
}
void
set_height
(
size_t
height
)
{
height_
=
height
;
}
int32_t
fps
(
)
const
{
return
fps_
;
}
void
set_fps
(
int32_t
fps
)
{
fps_
=
fps
;
}
bool
IsRegular
(
)
const
;
std
:
:
string
ToString
(
)
const
;
private
:
size_t
width_
=
0
;
size_t
height_
=
0
;
int32_t
fps_
=
0
;
Spec
spec_
=
Spec
:
:
kNone
;
}
;
class
VideoDumpOptions
{
public
:
static
constexpr
int
kDefaultSamplingModulo
=
1
;
explicit
VideoDumpOptions
(
absl
:
:
string_view
output_directory
int
sampling_modulo
=
kDefaultSamplingModulo
bool
export_frame_ids
=
false
std
:
:
function
<
std
:
:
unique_ptr
<
test
:
:
VideoFrameWriter
>
(
absl
:
:
string_view
file_name_prefix
const
VideoResolution
&
resolution
)
>
video_frame_writer_factory
=
Y4mVideoFrameWriterFactory
)
;
VideoDumpOptions
(
absl
:
:
string_view
output_directory
bool
export_frame_ids
)
;
VideoDumpOptions
(
const
VideoDumpOptions
&
)
=
default
;
VideoDumpOptions
&
operator
=
(
const
VideoDumpOptions
&
)
=
default
;
VideoDumpOptions
(
VideoDumpOptions
&
&
)
=
default
;
VideoDumpOptions
&
operator
=
(
VideoDumpOptions
&
&
)
=
default
;
std
:
:
string
output_directory
(
)
const
{
return
output_directory_
;
}
int
sampling_modulo
(
)
const
{
return
sampling_modulo_
;
}
bool
export_frame_ids
(
)
const
{
return
export_frame_ids_
;
}
std
:
:
unique_ptr
<
test
:
:
VideoFrameWriter
>
CreateInputDumpVideoFrameWriter
(
absl
:
:
string_view
stream_label
const
VideoResolution
&
resolution
)
const
;
std
:
:
unique_ptr
<
test
:
:
VideoFrameWriter
>
CreateOutputDumpVideoFrameWriter
(
absl
:
:
string_view
stream_label
absl
:
:
string_view
receiver
const
VideoResolution
&
resolution
)
const
;
std
:
:
string
ToString
(
)
const
;
private
:
static
std
:
:
unique_ptr
<
test
:
:
VideoFrameWriter
>
Y4mVideoFrameWriterFactory
(
absl
:
:
string_view
file_name_prefix
const
VideoResolution
&
resolution
)
;
std
:
:
string
GetInputDumpFileName
(
absl
:
:
string_view
stream_label
const
VideoResolution
&
resolution
)
const
;
std
:
:
optional
<
std
:
:
string
>
GetInputFrameIdsDumpFileName
(
absl
:
:
string_view
stream_label
const
VideoResolution
&
resolution
)
const
;
std
:
:
string
GetOutputDumpFileName
(
absl
:
:
string_view
stream_label
absl
:
:
string_view
receiver
const
VideoResolution
&
resolution
)
const
;
std
:
:
optional
<
std
:
:
string
>
GetOutputFrameIdsDumpFileName
(
absl
:
:
string_view
stream_label
absl
:
:
string_view
receiver
const
VideoResolution
&
resolution
)
const
;
std
:
:
string
output_directory_
;
int
sampling_modulo_
=
1
;
bool
export_frame_ids_
=
false
;
std
:
:
function
<
std
:
:
unique_ptr
<
test
:
:
VideoFrameWriter
>
(
absl
:
:
string_view
file_name_prefix
const
VideoResolution
&
resolution
)
>
video_frame_writer_factory_
;
}
;
struct
VideoConfig
{
explicit
VideoConfig
(
const
VideoResolution
&
resolution
)
;
VideoConfig
(
size_t
width
size_t
height
int32_t
fps
)
;
VideoConfig
(
absl
:
:
string_view
stream_label
size_t
width
size_t
height
int32_t
fps
)
;
size_t
width
;
size_t
height
;
int32_t
fps
;
VideoResolution
GetResolution
(
)
const
{
return
VideoResolution
(
width
height
fps
)
;
}
std
:
:
optional
<
std
:
:
string
>
stream_label
;
std
:
:
optional
<
VideoTrackInterface
:
:
ContentHint
>
content_hint
;
std
:
:
optional
<
VideoSimulcastConfig
>
simulcast_config
;
std
:
:
optional
<
EmulatedSFUConfig
>
emulated_sfu_config
;
std
:
:
vector
<
RtpEncodingParameters
>
encoding_params
;
std
:
:
optional
<
int
>
temporal_layers_count
;
std
:
:
optional
<
VideoDumpOptions
>
input_dump_options
;
std
:
:
optional
<
VideoDumpOptions
>
output_dump_options
;
bool
output_dump_use_fixed_framerate
=
false
;
bool
show_on_screen
=
false
;
std
:
:
optional
<
std
:
:
string
>
sync_group
;
std
:
:
optional
<
DegradationPreference
>
degradation_preference
;
}
;
struct
AudioConfig
{
std
:
:
optional
<
std
:
:
string
>
stream_label
;
std
:
:
optional
<
std
:
:
string
>
input_file_name
;
std
:
:
optional
<
std
:
:
string
>
input_dump_file_name
;
std
:
:
optional
<
std
:
:
string
>
output_dump_file_name
;
AudioOptions
audio_options
;
int
sampling_frequency_in_hz
=
48000
;
std
:
:
optional
<
std
:
:
string
>
sync_group
;
}
;
struct
VideoCodecConfig
{
explicit
VideoCodecConfig
(
absl
:
:
string_view
name
)
;
VideoCodecConfig
(
absl
:
:
string_view
name
std
:
:
map
<
std
:
:
string
std
:
:
string
>
required_params
)
;
std
:
:
string
name
;
std
:
:
map
<
std
:
:
string
std
:
:
string
>
required_params
;
}
;
class
VideoSubscription
{
public
:
static
std
:
:
optional
<
VideoResolution
>
GetMaxResolution
(
rtc
:
:
ArrayView
<
const
VideoConfig
>
video_configs
)
;
static
std
:
:
optional
<
VideoResolution
>
GetMaxResolution
(
rtc
:
:
ArrayView
<
const
VideoResolution
>
resolutions
)
;
bool
operator
=
=
(
const
VideoSubscription
&
other
)
const
;
bool
operator
!
=
(
const
VideoSubscription
&
other
)
const
;
VideoSubscription
&
SubscribeToPeer
(
absl
:
:
string_view
peer_name
VideoResolution
resolution
=
VideoResolution
(
VideoResolution
:
:
Spec
:
:
kMaxFromSender
)
)
;
VideoSubscription
&
SubscribeToAllPeers
(
VideoResolution
resolution
=
VideoResolution
(
VideoResolution
:
:
Spec
:
:
kMaxFromSender
)
)
;
std
:
:
optional
<
VideoResolution
>
GetResolutionForPeer
(
absl
:
:
string_view
peer_name
)
const
;
std
:
:
vector
<
std
:
:
string
>
GetSubscribedPeers
(
)
const
;
std
:
:
string
ToString
(
)
const
;
private
:
std
:
:
optional
<
VideoResolution
>
default_resolution_
=
std
:
:
nullopt
;
std
:
:
map
<
std
:
:
string
VideoResolution
>
peers_resolution_
;
}
;
struct
EchoEmulationConfig
{
TimeDelta
echo_delay
=
TimeDelta
:
:
Millis
(
50
)
;
}
;
}
}
#
endif
