#
include
"
api
/
scoped_refptr
.
h
"
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
test
/
gtest
.
h
"
namespace
rtc
{
namespace
{
struct
FunctionsCalled
{
int
addref
=
0
;
int
release
=
0
;
}
;
class
ScopedRefCounted
{
public
:
explicit
ScopedRefCounted
(
FunctionsCalled
*
called
)
:
called_
(
*
called
)
{
}
ScopedRefCounted
(
const
ScopedRefCounted
&
)
=
delete
;
ScopedRefCounted
&
operator
=
(
const
ScopedRefCounted
&
)
=
delete
;
void
AddRef
(
)
{
+
+
called_
.
addref
;
+
+
ref_count_
;
}
void
Release
(
)
{
+
+
called_
.
release
;
if
(
0
=
=
-
-
ref_count_
)
delete
this
;
}
private
:
~
ScopedRefCounted
(
)
=
default
;
FunctionsCalled
&
called_
;
int
ref_count_
=
0
;
}
;
TEST
(
ScopedRefptrTest
IsCopyConstructable
)
{
FunctionsCalled
called
;
scoped_refptr
<
ScopedRefCounted
>
ptr
(
new
ScopedRefCounted
(
&
called
)
)
;
scoped_refptr
<
ScopedRefCounted
>
another_ptr
=
ptr
;
EXPECT_TRUE
(
ptr
)
;
EXPECT_TRUE
(
another_ptr
)
;
EXPECT_EQ
(
called
.
addref
2
)
;
}
TEST
(
ScopedRefptrTest
IsCopyAssignable
)
{
FunctionsCalled
called
;
scoped_refptr
<
ScopedRefCounted
>
another_ptr
;
scoped_refptr
<
ScopedRefCounted
>
ptr
(
new
ScopedRefCounted
(
&
called
)
)
;
another_ptr
=
ptr
;
EXPECT_TRUE
(
ptr
)
;
EXPECT_TRUE
(
another_ptr
)
;
EXPECT_EQ
(
called
.
addref
2
)
;
}
TEST
(
ScopedRefptrTest
IsMoveConstructableWithoutExtraAddRefRelease
)
{
FunctionsCalled
called
;
scoped_refptr
<
ScopedRefCounted
>
ptr
(
new
ScopedRefCounted
(
&
called
)
)
;
scoped_refptr
<
ScopedRefCounted
>
another_ptr
=
std
:
:
move
(
ptr
)
;
EXPECT_FALSE
(
ptr
)
;
EXPECT_TRUE
(
another_ptr
)
;
EXPECT_EQ
(
called
.
addref
1
)
;
EXPECT_EQ
(
called
.
release
0
)
;
}
TEST
(
ScopedRefptrTest
IsMoveAssignableWithoutExtraAddRefRelease
)
{
FunctionsCalled
called
;
scoped_refptr
<
ScopedRefCounted
>
another_ptr
;
scoped_refptr
<
ScopedRefCounted
>
ptr
(
new
ScopedRefCounted
(
&
called
)
)
;
another_ptr
=
std
:
:
move
(
ptr
)
;
EXPECT_FALSE
(
ptr
)
;
EXPECT_TRUE
(
another_ptr
)
;
EXPECT_EQ
(
called
.
addref
1
)
;
EXPECT_EQ
(
called
.
release
0
)
;
}
TEST
(
ScopedRefptrTest
MovableDuringVectorReallocation
)
{
static_assert
(
std
:
:
is_nothrow_move_constructible
<
scoped_refptr
<
ScopedRefCounted
>
>
(
)
"
"
)
;
FunctionsCalled
called
;
std
:
:
vector
<
scoped_refptr
<
ScopedRefCounted
>
>
ptrs
;
ptrs
.
reserve
(
1
)
;
ptrs
.
emplace_back
(
new
ScopedRefCounted
(
&
called
)
)
;
ptrs
.
emplace_back
(
new
ScopedRefCounted
(
&
called
)
)
;
EXPECT_EQ
(
called
.
addref
2
)
;
EXPECT_EQ
(
called
.
release
0
)
;
}
}
}
