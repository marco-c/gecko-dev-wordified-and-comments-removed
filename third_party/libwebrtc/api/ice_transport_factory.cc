#
include
"
api
/
ice_transport_factory
.
h
"
#
include
<
memory
>
#
include
<
utility
>
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
#
include
"
p2p
/
base
/
p2p_transport_channel
.
h
"
#
include
"
p2p
/
base
/
port_allocator
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
webrtc
{
namespace
{
class
IceTransportWithTransportChannel
:
public
IceTransportInterface
{
public
:
IceTransportWithTransportChannel
(
std
:
:
unique_ptr
<
cricket
:
:
IceTransportInternal
>
internal
)
:
internal_
(
std
:
:
move
(
internal
)
)
{
}
~
IceTransportWithTransportChannel
(
)
override
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
}
cricket
:
:
IceTransportInternal
*
internal
(
)
override
{
RTC_DCHECK_RUN_ON
(
&
thread_checker_
)
;
return
internal_
.
get
(
)
;
}
private
:
const
SequenceChecker
thread_checker_
{
}
;
const
std
:
:
unique_ptr
<
cricket
:
:
IceTransportInternal
>
internal_
RTC_GUARDED_BY
(
thread_checker_
)
;
}
;
}
rtc
:
:
scoped_refptr
<
IceTransportInterface
>
CreateIceTransport
(
cricket
:
:
PortAllocator
*
port_allocator
)
{
IceTransportInit
init
;
init
.
set_port_allocator
(
port_allocator
)
;
return
CreateIceTransport
(
std
:
:
move
(
init
)
)
;
}
rtc
:
:
scoped_refptr
<
IceTransportInterface
>
CreateIceTransport
(
IceTransportInit
init
)
{
return
new
rtc
:
:
RefCountedObject
<
IceTransportWithTransportChannel
>
(
std
:
:
make_unique
<
cricket
:
:
P2PTransportChannel
>
(
"
"
0
init
.
port_allocator
(
)
init
.
async_resolver_factory
(
)
init
.
event_log
(
)
)
)
;
}
}
